{"pid": "P1000", "type": "P", "difficulty": 1, "samples": [["", "                ********\n               ************\n               ####....#.\n             #..###.....##....\n             ###.......######              ###            ###\n                ...........               #...#          #...#\n               ##*#######                 #.#.#          #.#.#\n            ####*******######             #.#.#          #.#.#\n           ...#***.****.*###....          #...#          #...#\n           ....**********##.....           ###            ###\n           ....****    *****....\n             ####        ####\n           ######        ######\n##############################################################\n#...#......#.##...#......#.##...#......#.##------------------#\n###########################################------------------#\n#..#....#....##..#....#....##..#....#....#####################\n##########################################    #----------#\n#.....#......##.....#......##.....#......#    #----------#\n##########################################    #----------#\n#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#\n##########################################    ############"]], "limits": {"time": [1000], "memory": [131072]}, "tags": ["字符串", "O2优化"], "title": "超级玛丽游戏", "background": "本题是洛谷的试机题目，可以帮助了解洛谷的使用。\n\n建议完成本题目后继续尝试 [P1001](/problem/P1001)、[P1008](/problem/P1008)。  \n\n另外强烈推荐[新用户必读帖](/discuss/show/241461)。学术版与题目总版内发帖、回复需要达到 [受信任的用户](https://help.luogu.com.cn/rules/community/discuss#%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90) 的权限，在洛谷经常做题、参与比赛即可快速达到该权限等级。", "description": "超级玛丽是一个非常经典的游戏。请你用字符画的形式输出超级玛丽中的一个场景：\n\n```plain\n                ********\n               ************\n               ####....#.\n             #..###.....##....\n             ###.......######              ###            ###\n                ...........               #...#          #...#\n               ##*#######                 #.#.#          #.#.#\n            ####*******######             #.#.#          #.#.#\n           ...#***.****.*###....          #...#          #...#\n           ....**********##.....           ###            ###\n           ....****    *****....\n             ####        ####\n           ######        ######\n##############################################################\n#...#......#.##...#......#.##...#......#.##------------------#\n###########################################------------------#\n#..#....#....##..#....#....##..#....#....#####################\n##########################################    #----------#\n#.....#......##.....#......##.....#......#    #----------#\n##########################################    #----------#\n#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#\n##########################################    ############\n```", "inputFormat": "无", "outputFormat": "如描述。", "hint": "**广告**\n\n洛谷出品的算法教材，帮助您更简单的学习基础算法。[【官方网店绝赞热卖中！】>>>](https://item.taobao.com/item.htm?id=637730514783)\n\n[![](https://cdn.luogu.com.cn/upload/image_hosting/njc7dlng.png)](https://item.taobao.com/item.htm?id=637730514783)", "locale": "zh-CN", "translations": {"en": {"title": "Super Mario Game", "background": "This is a test problem on Luogu, designed to help users get familiar with the platform.  \n\nAfter completing this problem, it is recommended to try [P1001](/problem/P1001) and [P1008](/problem/P1008).  \n\nAdditionally, new users are strongly encouraged to read the [New User Guide](/discuss/show/241461). To post and reply in the academic and general topic boards, one needs to attain the [Trusted User](https://help.luogu.com.cn/rules/community/discuss#%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90) permission. Frequently solving problems and participating in contests on Luogu can quickly help you reach this permission level.", "description": "Super Mario is a classic game. Your task is to output a scene from Super Mario using ASCII art.  \n\n```plain\n                ********\n               ************\n               ####....#.\n             #..###.....##....\n             ###.......######              ###            ###\n                ...........               #...#          #...#\n               ##*#######                 #.#.#          #.#.#\n            ####*******######             #.#.#          #.#.#\n           ...#***.****.*###....          #...#          #...#\n           ....**********##.....           ###            ###\n           ....****    *****....\n             ####        ####\n           ######        ######\n##############################################################\n#...#......#.##...#......#.##...#......#.##------------------#\n###########################################------------------#\n#..#....#....##..#....#....##..#....#....#####################\n##########################################    #----------#\n#.....#......##.....#......##.....#......#    #----------#\n##########################################    #----------#\n#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#\n##########################################    ############\n```", "inputFormat": null, "outputFormat": "As described.", "hint": "**Advertisement**  \n\nLuogu's official algorithm textbooks can help you learn fundamental algorithms more easily.  \n[【Available Now in Our Official Store!】>>>](https://item.taobao.com/item.htm?id=637730514783)  \n\n[![](https://cdn.luogu.com.cn/upload/image_hosting/njc7dlng.png)](https://item.taobao.com/item.htm?id=637730514783)", "locale": "en"}, "zh-CN": {"title": "超级玛丽游戏", "background": "本题是洛谷的试机题目，可以帮助了解洛谷的使用。\n\n建议完成本题目后继续尝试 [P1001](/problem/P1001)、[P1008](/problem/P1008)。  \n\n另外强烈推荐[新用户必读帖](/discuss/show/241461)。学术版与题目总版内发帖、回复需要达到 [受信任的用户](https://help.luogu.com.cn/rules/community/discuss#%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90) 的权限，在洛谷经常做题、参与比赛即可快速达到该权限等级。", "description": "超级玛丽是一个非常经典的游戏。请你用字符画的形式输出超级玛丽中的一个场景：\n\n```plain\n                ********\n               ************\n               ####....#.\n             #..###.....##....\n             ###.......######              ###            ###\n                ...........               #...#          #...#\n               ##*#######                 #.#.#          #.#.#\n            ####*******######             #.#.#          #.#.#\n           ...#***.****.*###....          #...#          #...#\n           ....**********##.....           ###            ###\n           ....****    *****....\n             ####        ####\n           ######        ######\n##############################################################\n#...#......#.##...#......#.##...#......#.##------------------#\n###########################################------------------#\n#..#....#....##..#....#....##..#....#....#####################\n##########################################    #----------#\n#.....#......##.....#......##.....#......#    #----------#\n##########################################    #----------#\n#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#\n##########################################    ############\n```", "inputFormat": "无", "outputFormat": "如描述。", "hint": "**广告**\n\n洛谷出品的算法教材，帮助您更简单的学习基础算法。[【官方网店绝赞热卖中！】>>>](https://item.taobao.com/item.htm?id=637730514783)\n\n[![](https://cdn.luogu.com.cn/upload/image_hosting/njc7dlng.png)](https://item.taobao.com/item.htm?id=637730514783)", "locale": "zh-CN"}}}
{"pid": "P1001", "type": "P", "difficulty": 1, "samples": [["20 30\n", "50\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟"], "title": "A+B Problem", "background": "**不熟悉算法竞赛的选手请看这里：**\n\n算法竞赛中要求的输出格式中，**不能有多余的内容**，**这也包括了“请输入整数 $\\bm a$ 和 $\\bm b$” 这一类的提示用户输入信息的内容**。若包含了这些内容，将会被认为是 `Wrong Answer`，即洛谷上的 `WA`。在对比代码输出和标准输出时，系统将忽略每一行结尾的空格，以及最后一行之后多余的换行符。\n\n若因此类问题出现本机似乎输出了正确的结果，但是实际提交结果为错误的现象，请勿认为是洛谷评测机出了问题，而是你的代码中可能存在多余的输出信息。用户可以参考在题目末尾提供的代码。\n\n此外，**请善用 IDE 模式**，以避免不同平台的评测产生差异。\n\n最后，请不要在对应的题目讨论区中发布自己的题解，请发布到题解区域中，否则将处以删除或禁言的处罚。若发现无法提交题解则表明本题题解数量过多，仍不应发布讨论。若您的做法确实与其他所有题解均不一样，请联系管理员添加题解。\n\n在学术版与题目总版内发帖、回复需要达到 [受信任的用户](https://help.luogu.com.cn/rules/community/discuss#%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90) 的权限，在洛谷经常做题、参与比赛即可快速达到该权限等级。", "description": "输入两个整数 $a, b$，输出它们的和（$|a|,|b| \\le {10}^9$）。\n\n注意\n\n1. Pascal 使用 `integer` 会爆掉哦！\n2. 有负数哦！\n3. C/C++ 的 main 函数必须是 `int` 类型。程序正常结束时的返回值必须是 0。这不仅对洛谷其他题目有效，而且也是 NOIP/CSP/NOI 比赛的要求！\n\n好吧，同志们，我们就从这一题开始，向着大牛的路进发。\n\n> 任何一个伟大的思想，都有一个微不足道的开始。", "inputFormat": "两个以空格分开的整数。", "outputFormat": "一个整数。", "hint": "**广告**\n\n洛谷出品的算法教材，帮助您更简单的学习基础算法。[【官方网店绝赞热卖中！】>>>](https://item.taobao.com/item.htm?id=637730514783)\n\n[![](https://cdn.luogu.com.cn/upload/image_hosting/njc7dlng.png)](https://item.taobao.com/item.htm?id=637730514783)\n\n**本题各种语言的程序范例：**\n\nC\n```c\n#include <stdio.h>\n\nint main()\n{\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    printf(\"%d\\n\", a+b);\n    return 0;\n}\n```\n----------------\n\nC++\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint main()\n{\n    int a,b;\n    cin >> a >> b;\n    cout << a+b << endl;\n    return 0;\n}\n```\n----------------\n\nPascal\n```pascal\nvar a, b: longint;\nbegin\n    readln(a,b);\n    writeln(a+b);\nend.\n```\n-----------------\n\nPython 3\n\n```python\ns = input().split()\nprint(int(s[0]) + int(s[1]))\n```\n-----------------\n\nJava\n```java\nimport java.io.*;\nimport java.util.*;\npublic class Main {\n    public static void main(String args[]) throws Exception {\n        Scanner cin=new Scanner(System.in);\n        int a = cin.nextInt(), b = cin.nextInt();\n        System.out.println(a+b);\n    }\n}\n```\n-----------------\n\nJavaScript （Node.js）\n\n```javascript\nconst fs = require('fs')\nconst data = fs.readFileSync('/dev/stdin')\nconst result = data.toString('ascii').trim().split(' ').map(x => parseInt(x)).reduce((a, b) => a + b, 0)\nconsole.log(result)\nprocess.exit() // 请注意必须在出口点处加入此行\n```\n\n-----------------\n\nRuby\n\n```ruby\na, b = gets.split.map(&:to_i)\nprint a+b\n```\n\n-----------------\n\nPHP\n\n```php\n<?php\n$input = trim(file_get_contents(\"php://stdin\"));\nlist($a, $b) = explode(' ', $input);\necho $a + $b;\n```\n\n-----------------\n\nRust\n\n```rust\nuse std::io;\n\nfn main(){\n    let mut input=String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    let mut s=input.trim().split(' ');\n\n    let a:i32=s.next().unwrap()\n               .parse().unwrap();\n    let b:i32=s.next().unwrap()\n               .parse().unwrap();\n    println!(\"{}\",a+b);\n}\n```\n\n-----------------\n\nGo\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var a, b int\n    fmt.Scanf(\"%d%d\", &a, &b)\n    fmt.Println(a+b)\n}\n```\n\n-----------------\n\nC# Mono\n\n```cs\nusing System;\n\npublic class APlusB{\n    private static void Main(){\n        string[] input = Console.ReadLine().Split(' ');\n        Console.WriteLine(int.Parse(input[0]) + int.Parse(input[1]));\n    }\n}\n```\n\n------------------\n\nKotlin\n\n```kotlin\nfun main(args: Array<String>) {\n    val (a, b) = readLine()!!.split(' ').map(String::toInt)\n    println(a + b)\n}\n```\n\n------------------\n\nHaskell\n\n```haskell\nmain = do\n    [a, b] <- (map read . words) `fmap` getLine\n    print (a+b)\n```\n\n------------------\n\nLua\n\n```lua\na = io.read('*n')\nb = io.read('*n')\nprint(a + b)\n```\n\n------------------\n\nOCaml\n\n```ocaml\nScanf.scanf \"%i %i\\n\" (fun a b -> print_int (a + b))\n```\n\n------------------\n\nJulia\n\n```julia\nnums = map(x -> parse(Int, x), split(readline(), \" \"))\nprintln(nums[1] + nums[2])\n```\n\n------------------\n\nScala\n\n```scala\nobject Main {\n  def main(args: Array[String]): Unit = {\n    import java.util.Scanner\n    \n    val cin = new Scanner(System.in)\n    val a = cin.nextInt()\n    val b = cin.nextInt()\n    System.out.println(a + b)\n  }\n}\n```\n\n------------------\n\nPerl\n\n```perl\nmy $in = <STDIN>;\nchomp $in;\n$in = [split /[\\s,]+/, $in];\nmy $c = $in->[0] + $in->[1];\nprint \"$c\\n\";\n```", "locale": "zh-CN", "translations": {"en": {"title": "A+B Problem", "background": "**If you're new to programming contests, please read this carefully:**\n\nIn programming contests, your program's output **must contain only the answer—nothing extra**.  \n\nThat **includes messages like \"Please enter integers a and b\"** or any other prompts for the user.  \n\nIf you print anything like that, the system will mark your submission as **Wrong Answer** (shown as **WA** on Luogu).\n\nWhen checking your output, the judge system will ignore spaces at the end of any line and extra blank lines after the last line of output.\n\nBut if your code prints extra text (like prompts or explanations), it will be marked wrong—even if the answer itself is correct.\n\nSo, if your program works fine on your own computer but gets WA when you submit it, **don't blame the judge system**.  \n\nInstead, double-check that you're not printing anything unnecessary. You can look at the sample code at the end of this problem for reference.\n\nAlso, **try using the IDE mode** on Luogu—it helps avoid small differences between your local environment and the judge's system.\n\nFinally, **don't post your solution in the discussion section**.  \n\nSolutions should go in the \"Solution\" area. If you post a full solution in the discussion section, it may be deleted, and you could even be muted.  \n\nIf you can't submit a solution, it means too many people have already done so—but you still shouldn't post it in the discussion section.  \n\nOnly if your method is truly different from all existing ones should you contact a site admin to ask for permission to add your solution.", "description": "Input two integers, $a$ and $b$, and output their sum ($|a|,|b| \\le {10}^9$).\n\n### Notes:\n1. In Pascal, using `integer` may overflow.\n2. Negative numbers are allowed.\n3. In C/C++, the `main` function must return `int`, and you must `return 0`. This is a general requirement for problems on Luogu as well as in NOIP/CSP/NOI contests.\n\nLet's get started with this simple problem and begin the journey toward becoming an expert.\n\n> Every great idea has a humble beginning.", "inputFormat": "Two space-separated integers.", "outputFormat": "A single integer.", "hint": "### Program Examples in Various Languages:\n\n**C**\n\n```c\n#include <stdio.h>\n\nint main()\n{\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    printf(\"%d\\n\", a+b);\n    return 0;\n}\n```\n\n**C++**\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint main()\n{\n    int a,b;\n    cin >> a >> b;\n    cout << a+b << endl;\n    return 0;\n}\n```\n\n**Pascal**\n\n```pascal\nvar a, b: longint;\nbegin\n    readln(a,b);\n    writeln(a+b);\nend.\n```\n\n**Python3**\n\n```python\ns = input().split()\nprint(int(s[0]) + int(s[1]))\n```\n\n**Java**\n\n```java\nimport java.io.*;\nimport java.util.*;\npublic class Main {\n    public static void main(String args[]) throws Exception {\n        Scanner cin=new Scanner(System.in);\n        int a = cin.nextInt(), b = cin.nextInt();\n        System.out.println(a+b);\n    }\n}\n```\n\n**JavaScript (Node.js)**\n\n```javascript\nconst fs = require('fs')\nconst data = fs.readFileSync('/dev/stdin')\nconst result = data.toString('ascii').trim().split(' ').map(x => parseInt(x)).reduce((a, b) => a + b, 0)\nconsole.log(result)\nprocess.exit() // Ensure this line is added at the exit point\n```\n\n**Ruby**\n\n```ruby\na, b = gets.split.map(&:to_i)\nprint a+b\n```\n\n**PHP**\n\n```php\n<?php\n$input = trim(file_get_contents(\"php://stdin\"));\nlist($a, $b) = explode(' ', $input);\necho $a + $b;\n```\n\n**Rust**\n\n```rust\nuse std::io;\n\nfn main(){\n    let mut input=String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    let mut s=input.trim().split(' ');\n\n    let a:i32=s.next().unwrap()\n               .parse().unwrap();\n    let b:i32=s.next().unwrap()\n               .parse().unwrap();\n    println!(\"{}\",a+b);\n}\n```\n\n**Go**\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var a, b int\n    fmt.Scanf(\"%d%d\", &a, &b)\n    fmt.Println(a+b)\n}\n```\n\n**C# Mono**\n\n```cs\nusing System;\n\npublic class APlusB{\n    private static void Main(){\n        string[] input = Console.ReadLine().Split(' ');\n        Console.WriteLine(int.Parse(input[0]) + int.Parse(input[1]));\n    }\n}\n```\n\n**Visual Basic Mono**\n\n```vb\nImports System\n\nModule APlusB\n    Sub Main()\n        Dim ins As String() = Console.ReadLine().Split(New Char(){\" \"c})\n        Console.WriteLine(Int(ins(0))+Int(ins(1)))\n    End Sub\nEnd Module\n```\n\n**Kotlin**\n\n```kotlin\nfun main(args: Array<String>) {\n    val (a, b) = readLine()!!.split(' ').map(String::toInt)\n    println(a + b)\n}\n```\n\n**Haskell**\n\n```haskell\nmain = do\n    [a, b] <- (map read . words) `fmap` getLine\n    print (a+b)\n```\n\n**Lua**\n\n```lua\na = io.read('*n')\nb = io.read('*n')\nprint(a + b)\n```\n\n**OCaml**\n\n```ocaml\nScanf.scanf \"%i %i\\n\" (fun a b -> print_int (a + b))\n```\n\n**Julia**\n\n```julia\nnums = map(x -> parse(Int, x), split(readline(), \" \"))\nprintln(nums[1] + nums[2])\n```\n\n**Scala**\n\n```scala\nobject Main {\n  def main(args: Array[String]): Unit = {\n    import java.util.Scanner\n    \n    val cin = new Scanner(System.in)\n    val a = cin.nextInt()\n    val b = cin.nextInt()\n    System.out.println(a + b)\n  }\n}\n```\n\n**Perl**\n\n```perl\nmy $in = <STDIN>;\nchomp $in;\n$in = [split /[\\s,]+/, $in];\nmy $c = $in->[0] + $in->[1];\nprint \"$c\\n\";\n```", "locale": "en"}, "zh-CN": {"title": "A+B Problem", "background": "**不熟悉算法竞赛的选手请看这里：**\n\n算法竞赛中要求的输出格式中，**不能有多余的内容**，**这也包括了“请输入整数 $\\bm a$ 和 $\\bm b$” 这一类的提示用户输入信息的内容**。若包含了这些内容，将会被认为是 `Wrong Answer`，即洛谷上的 `WA`。在对比代码输出和标准输出时，系统将忽略每一行结尾的空格，以及最后一行之后多余的换行符。\n\n若因此类问题出现本机似乎输出了正确的结果，但是实际提交结果为错误的现象，请勿认为是洛谷评测机出了问题，而是你的代码中可能存在多余的输出信息。用户可以参考在题目末尾提供的代码。\n\n此外，**请善用 IDE 模式**，以避免不同平台的评测产生差异。\n\n最后，请不要在对应的题目讨论区中发布自己的题解，请发布到题解区域中，否则将处以删除或禁言的处罚。若发现无法提交题解则表明本题题解数量过多，仍不应发布讨论。若您的做法确实与其他所有题解均不一样，请联系管理员添加题解。\n\n在学术版与题目总版内发帖、回复需要达到 [受信任的用户](https://help.luogu.com.cn/rules/community/discuss#%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90) 的权限，在洛谷经常做题、参与比赛即可快速达到该权限等级。", "description": "输入两个整数 $a, b$，输出它们的和（$|a|,|b| \\le {10}^9$）。\n\n注意\n\n1. Pascal 使用 `integer` 会爆掉哦！\n2. 有负数哦！\n3. C/C++ 的 main 函数必须是 `int` 类型。程序正常结束时的返回值必须是 0。这不仅对洛谷其他题目有效，而且也是 NOIP/CSP/NOI 比赛的要求！\n\n好吧，同志们，我们就从这一题开始，向着大牛的路进发。\n\n> 任何一个伟大的思想，都有一个微不足道的开始。", "inputFormat": "两个以空格分开的整数。", "outputFormat": "一个整数。", "hint": "**广告**\n\n洛谷出品的算法教材，帮助您更简单的学习基础算法。[【官方网店绝赞热卖中！】>>>](https://item.taobao.com/item.htm?id=637730514783)\n\n[![](https://cdn.luogu.com.cn/upload/image_hosting/njc7dlng.png)](https://item.taobao.com/item.htm?id=637730514783)\n\n**本题各种语言的程序范例：**\n\nC\n```c\n#include <stdio.h>\n\nint main()\n{\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    printf(\"%d\\n\", a+b);\n    return 0;\n}\n```\n----------------\n\nC++\n```cpp\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint main()\n{\n    int a,b;\n    cin >> a >> b;\n    cout << a+b << endl;\n    return 0;\n}\n```\n----------------\n\nPascal\n```pascal\nvar a, b: longint;\nbegin\n    readln(a,b);\n    writeln(a+b);\nend.\n```\n-----------------\n\nPython 3\n\n```python\ns = input().split()\nprint(int(s[0]) + int(s[1]))\n```\n-----------------\n\nJava\n```java\nimport java.io.*;\nimport java.util.*;\npublic class Main {\n    public static void main(String args[]) throws Exception {\n        Scanner cin=new Scanner(System.in);\n        int a = cin.nextInt(), b = cin.nextInt();\n        System.out.println(a+b);\n    }\n}\n```\n-----------------\n\nJavaScript （Node.js）\n\n```javascript\nconst fs = require('fs')\nconst data = fs.readFileSync('/dev/stdin')\nconst result = data.toString('ascii').trim().split(' ').map(x => parseInt(x)).reduce((a, b) => a + b, 0)\nconsole.log(result)\nprocess.exit() // 请注意必须在出口点处加入此行\n```\n\n-----------------\n\nRuby\n\n```ruby\na, b = gets.split.map(&:to_i)\nprint a+b\n```\n\n-----------------\n\nPHP\n\n```php\n<?php\n$input = trim(file_get_contents(\"php://stdin\"));\nlist($a, $b) = explode(' ', $input);\necho $a + $b;\n```\n\n-----------------\n\nRust\n\n```rust\nuse std::io;\n\nfn main(){\n    let mut input=String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    let mut s=input.trim().split(' ');\n\n    let a:i32=s.next().unwrap()\n               .parse().unwrap();\n    let b:i32=s.next().unwrap()\n               .parse().unwrap();\n    println!(\"{}\",a+b);\n}\n```\n\n-----------------\n\nGo\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var a, b int\n    fmt.Scanf(\"%d%d\", &a, &b)\n    fmt.Println(a+b)\n}\n```\n\n-----------------\n\nC# Mono\n\n```cs\nusing System;\n\npublic class APlusB{\n    private static void Main(){\n        string[] input = Console.ReadLine().Split(' ');\n        Console.WriteLine(int.Parse(input[0]) + int.Parse(input[1]));\n    }\n}\n```\n\n------------------\n\nKotlin\n\n```kotlin\nfun main(args: Array<String>) {\n    val (a, b) = readLine()!!.split(' ').map(String::toInt)\n    println(a + b)\n}\n```\n\n------------------\n\nHaskell\n\n```haskell\nmain = do\n    [a, b] <- (map read . words) `fmap` getLine\n    print (a+b)\n```\n\n------------------\n\nLua\n\n```lua\na = io.read('*n')\nb = io.read('*n')\nprint(a + b)\n```\n\n------------------\n\nOCaml\n\n```ocaml\nScanf.scanf \"%i %i\\n\" (fun a b -> print_int (a + b))\n```\n\n------------------\n\nJulia\n\n```julia\nnums = map(x -> parse(Int, x), split(readline(), \" \"))\nprintln(nums[1] + nums[2])\n```\n\n------------------\n\nScala\n\n```scala\nobject Main {\n  def main(args: Array[String]): Unit = {\n    import java.util.Scanner\n    \n    val cin = new Scanner(System.in)\n    val a = cin.nextInt()\n    val b = cin.nextInt()\n    System.out.println(a + b)\n  }\n}\n```\n\n------------------\n\nPerl\n\n```perl\nmy $in = <STDIN>;\nchomp $in;\n$in = [split /[\\s,]+/, $in];\nmy $c = $in->[0] + $in->[1];\nprint \"$c\\n\";\n```", "locale": "zh-CN"}}}
{"pid": "P1002", "type": "P", "difficulty": 2, "samples": [["6 6 3 3\n", "6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2002", "NOIP 普及组"], "title": "[NOIP 2002 普及组] 过河卒", "background": "", "description": "棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。\n\n棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ipmwl52i.png)\n\n现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。\n", "inputFormat": "一行四个正整数，分别表示 $B$ 点坐标和马的坐标。\n", "outputFormat": "一个整数，表示所有的路径条数。", "hint": "对于 $100 \\%$ 的数据，$1 \\le n, m \\le 20$，$0 \\le$ 马的坐标 $\\le 20$。\n\n**【题目来源】**\n\nNOIP 2002 普及组第四题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2002 Junior] River-Crossing Pawn", "background": null, "description": "On a chessboard, there is a river-crossing pawn at point $A$ that needs to reach the target point $B$. The pawn moves according to the rules: it may move either downward or rightward. There is also an opposing knight at point $C$ on the board; the knight’s own square and all squares reachable by a single knight move are called the knight’s controlled squares. Therefore, this is called “the knight blocks the river-crossing pawn.”\n\nThe board is represented using coordinates: point $A$ is at $(0, 0)$, point $B$ is at $(n, m)$, and the knight’s position is also given.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ipmwl52i.png)\n\nYou are to compute the number of distinct paths by which the pawn can travel from point $A$ to point $B$, assuming the knight’s position is fixed and does not move in response to the pawn’s moves.", "inputFormat": "One line contains four integers, representing the coordinates of point $B$ and the coordinates of the knight, in order: $n$, $m$, $x$, $y$.", "outputFormat": "Output a single integer, the total number of valid paths.", "hint": "For $100\\%$ of the data, $1 \\le n, m \\le 20$, and the knight’s coordinates satisfy $0 \\le x, y \\le 20$.\n\n[Source]\n\nNOIP 2002 Junior, Problem 4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2002 普及组] 过河卒", "background": "", "description": "棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。\n\n棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ipmwl52i.png)\n\n现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。\n", "inputFormat": "一行四个正整数，分别表示 $B$ 点坐标和马的坐标。\n", "outputFormat": "一个整数，表示所有的路径条数。", "hint": "对于 $100 \\%$ 的数据，$1 \\le n, m \\le 20$，$0 \\le$ 马的坐标 $\\le 20$。\n\n**【题目来源】**\n\nNOIP 2002 普及组第四题", "locale": "zh-CN"}}}
{"pid": "P1003", "type": "P", "difficulty": 2, "samples": [["3\n1 0 2 3\n0 2 3 3\n2 1 3 3\n2 2\n", "3\n"], ["3\n1 0 2 3\n0 2 3 3\n2 1 3 3\n4 5", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2011", "NOIP 提高组", "枚举"], "title": "[NOIP 2011 提高组] 铺地毯", "background": "", "description": "为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。\n\n地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。\n", "inputFormat": "输入共 $n + 2$ 行。\n\n第一行，一个整数 $n$，表示总共有 $n$ 张地毯。\n\n接下来的 $n$ 行中，第 $i+1$ 行表示编号 $i$ 的地毯的信息，包含四个整数 $a ,b ,g ,k$，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标 $(a, b)$ 以及地毯在 $x$ 轴和 $y$ 轴方向的长度。\n\n第 $n + 2$ 行包含两个整数 $x$ 和 $y$，表示所求的地面的点的坐标 $(x, y)$。", "outputFormat": "输出共 $1$ 行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出 `-1`。 \n", "hint": "【样例解释 1】\n\n如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)\n\n【数据范围】\n\n对于 $30\\%$ 的数据，有 $n \\le 2$。  \n对于 $50\\%$ 的数据，$0 \\le a, b, g, k \\le 100$。  \n对于 $100\\%$ 的数据，有 $0 \\le n \\le 10^4$, $0 \\le a, b, g, k \\le {10}^5$。   \n\nnoip2011 提高组 day1 第 $1$ 题。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2011 Senior] Laying Carpets", "background": null, "description": "To prepare a unique awards ceremony, the organizers lay several rectangular carpets on a rectangular area of the venue (regarded as the first quadrant of the plane Cartesian coordinate system). There are $n$ carpets, numbered from $1$ to $n$. These carpets are laid, in increasing order of their indices, axis-parallel; a later carpet is placed on top of those already laid.\n\nAfter all carpets have been laid, the organizers want to know the index of the topmost carpet that covers a given point on the floor. Note: points on the boundary and at the four vertices of a rectangular carpet are also considered covered.", "inputFormat": "The input contains $n + 2$ lines.\n\nThe first line contains an integer $n$, indicating that there are $n$ carpets in total.\n\nEach of the next $n$ lines, the $(i+1)$-th line, describes carpet $i$ with four integers $a, b, g, k$, separated by single spaces, representing the coordinates of the lower-left corner $(a, b)$ and the lengths of the carpet in the $x$- and $y$-directions, respectively.\n\nThe $(n + 2)$-th line contains two integers $x$ and $y$, representing the coordinates $(x, y)$ of the query point.", "outputFormat": "Output a single line containing one integer, the index of the required carpet; if the point is not covered by any carpet, output `-1`.", "hint": "[Sample Explanation 1]\n\nAs shown in the figure, carpet $1$ is drawn with solid lines, carpet $2$ with dashed lines, and carpet $3$ with double solid lines. The topmost carpet covering the point $(2, 2)$ is carpet $3$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)\n\n[Data Range]\n\n- For $30\\%$ of the data, $n \\le 2$.\n- For $50\\%$ of the data, $0 \\le a, b, g, k \\le 100$.\n- For $100\\%$ of the data, $0 \\le n \\le 10^4$, $0 \\le a, b, g, k \\le 10^5$.\n\nNOIP 2011 Senior Day 1 Problem $1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2011 提高组] 铺地毯", "background": "", "description": "为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。\n\n地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。\n", "inputFormat": "输入共 $n + 2$ 行。\n\n第一行，一个整数 $n$，表示总共有 $n$ 张地毯。\n\n接下来的 $n$ 行中，第 $i+1$ 行表示编号 $i$ 的地毯的信息，包含四个整数 $a ,b ,g ,k$，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标 $(a, b)$ 以及地毯在 $x$ 轴和 $y$ 轴方向的长度。\n\n第 $n + 2$ 行包含两个整数 $x$ 和 $y$，表示所求的地面的点的坐标 $(x, y)$。", "outputFormat": "输出共 $1$ 行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出 `-1`。 \n", "hint": "【样例解释 1】\n\n如下图，$1$ 号地毯用实线表示，$2$ 号地毯用虚线表示，$3$ 号用双实线表示，覆盖点 $(2,2)$ 的最上面一张地毯是 $3$ 号地毯。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q4izfzpb.png)\n\n【数据范围】\n\n对于 $30\\%$ 的数据，有 $n \\le 2$。  \n对于 $50\\%$ 的数据，$0 \\le a, b, g, k \\le 100$。  \n对于 $100\\%$ 的数据，有 $0 \\le n \\le 10^4$, $0 \\le a, b, g, k \\le {10}^5$。   \n\nnoip2011 提高组 day1 第 $1$ 题。", "locale": "zh-CN"}}}
{"pid": "P1004", "type": "P", "difficulty": 4, "samples": [["8\n2 3 13\n2 6  6\n3 5  7\n4 4 14\n5 2 21\n5 6  4\n6 3 15\n7 2 14\n0 0  0\n", "67"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2000", "递归", "NOIP 提高组", "记忆化搜索"], "title": "[NOIP 2000 提高组] 方格取数", "background": "NOIP 2000 提高组 T4", "description": "设有 $N \\times N$ 的方格图 $(N \\le 9)$，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 $0$。如下图所示（见样例）:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0bpummja.png)\n\n某人从图的左上角的 $A$ 点出发，可以向下行走，也可以向右走，直到到达右下角的 $B$ 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 $0$）。  \n此人从 $A$ 点到 $B$ 点共走两次，试找出 $2$ 条这样的路径，使得取得的数之和为最大。\n", "inputFormat": "输入的第一行为一个整数 $N$（表示 $N \\times N$ 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 $0$ 表示输入结束。\n", "outputFormat": "只需输出一个整数，表示 $2$ 条路径上取得的最大的和。\n", "hint": "数据范围：$1\\le N\\le 9$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2000 Senior] Collecting Numbers on a Grid", "background": null, "description": "Consider an $N \\times N$ grid ($N \\le 9$). Some cells are filled with positive integers, while the others contain the number $0$. As shown below (see the sample):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0bpummja.png)\n\nA person starts from the top-left corner point $A$, and may move either down or right until reaching the bottom-right corner point $B$. Along the way, he may collect the numbers in the cells he visits (after which those cells become the number $0$).  \nThis person travels from $A$ to $B$ twice. Find two such paths that maximize the total sum collected.", "inputFormat": "The first line contains an integer $N$ (the size of the $N \\times N$ grid). Each subsequent line contains three integers: the first two specify a position, and the third is the number placed at that position. A line containing $0\\ 0\\ 0$ indicates the end of input.", "outputFormat": "Output a single integer, the maximum total collected along the two paths.", "hint": "Constraints: $1 \\le N \\le 9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2000 提高组] 方格取数", "background": "NOIP 2000 提高组 T4", "description": "设有 $N \\times N$ 的方格图 $(N \\le 9)$，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 $0$。如下图所示（见样例）:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0bpummja.png)\n\n某人从图的左上角的 $A$ 点出发，可以向下行走，也可以向右走，直到到达右下角的 $B$ 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 $0$）。  \n此人从 $A$ 点到 $B$ 点共走两次，试找出 $2$ 条这样的路径，使得取得的数之和为最大。\n", "inputFormat": "输入的第一行为一个整数 $N$（表示 $N \\times N$ 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 $0$ 表示输入结束。\n", "outputFormat": "只需输出一个整数，表示 $2$ 条路径上取得的最大的和。\n", "hint": "数据范围：$1\\le N\\le 9$。", "locale": "zh-CN"}}}
{"pid": "P1005", "type": "P", "difficulty": 4, "samples": [["2 3\n1 2 3\n3 4 2\n", "82"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "高精度", "2007", "NOIP 提高组", "区间 DP"], "title": "[NOIP 2007 提高组] 矩阵取数游戏", "background": "", "description": "帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \\times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：\n\n1. 每次取数时须从每行各取走一个元素，共 $n$ 个。经过 $m$ 次后取完矩阵内所有元素；\n2. 每次取走的各个元素只能是该元素所在行的行首或行尾；\n3. 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）；\n4. 游戏结束总得分为 $m$ 次取数得分之和。\n\n帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。\n", "inputFormat": "输入文件包括 $n+1$ 行：\n\n第一行为两个用空格隔开的整数 $n$ 和 $m$。\n\n第 $2\\sim n+1$ 行为 $n \\times m$ 矩阵，其中每行有 $m$ 个用单个空格隔开的非负整数。\n\n\n\n\n", "outputFormat": "输出文件仅包含 $1$ 行，为一个整数，即输入矩阵取数后的最大得分。", "hint": "**【数据范围】**\n\n对于 $60\\%$ 的数据，满足 $1\\le n,m\\le 30$，答案不超过 $10^{16}$。  \n对于 $100\\%$ 的数据，满足 $1\\le n,m\\le 80$，$0\\le a_{i,j}\\le1000$。\n\n**【题目来源】**\n\nNOIP 2007 提高第三题。\n\n\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2007 Senior] Matrix Number Picking Game", "background": null, "description": "Shuai Shuai often plays a matrix number picking game with classmates: given an $n \\times m$ matrix where each element $a_{i,j}$ is a non-negative integer, the game rules are as follows:\n\n1. In each round, exactly one element is taken from each row, for a total of $n$ elements. After $m$ rounds, all elements in the matrix are taken.\n2. Each taken element must be either the leftmost or the rightmost element of its row.\n3. The score of each round is the sum of the per-row scores. The per-row score equals the value of the taken element $\\times 2^i$, where $i$ denotes the $i$-th round (starting from $1$).\n4. The total score of the game is the sum of the scores over all $m$ rounds.\n\nPlease write a program that, for any given matrix, computes the maximum possible total score.", "inputFormat": "The input consists of $n+1$ lines.\n\n- The first line contains two integers $n$ and $m$ separated by a space.\n- Lines $2$ to $n+1$ contain the $n \\times m$ matrix. Each line has $m$ non-negative integers separated by single spaces.", "outputFormat": "Output a single line containing one integer: the maximum possible total score.", "hint": "- Constraints:\n  - For $60\\%$ of the testdata, $1 \\le n, m \\le 30$, and the answer does not exceed $10^{16}$.\n  - For $100\\%$ of the testdata, $1 \\le n, m \\le 80$, $0 \\le a_{i,j} \\le 1000$.\n- Source:\n  NOIP 2007 Senior, Problem 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2007 提高组] 矩阵取数游戏", "background": "", "description": "帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \\times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：\n\n1. 每次取数时须从每行各取走一个元素，共 $n$ 个。经过 $m$ 次后取完矩阵内所有元素；\n2. 每次取走的各个元素只能是该元素所在行的行首或行尾；\n3. 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）；\n4. 游戏结束总得分为 $m$ 次取数得分之和。\n\n帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。\n", "inputFormat": "输入文件包括 $n+1$ 行：\n\n第一行为两个用空格隔开的整数 $n$ 和 $m$。\n\n第 $2\\sim n+1$ 行为 $n \\times m$ 矩阵，其中每行有 $m$ 个用单个空格隔开的非负整数。\n\n\n\n\n", "outputFormat": "输出文件仅包含 $1$ 行，为一个整数，即输入矩阵取数后的最大得分。", "hint": "**【数据范围】**\n\n对于 $60\\%$ 的数据，满足 $1\\le n,m\\le 30$，答案不超过 $10^{16}$。  \n对于 $100\\%$ 的数据，满足 $1\\le n,m\\le 80$，$0\\le a_{i,j}\\le1000$。\n\n**【题目来源】**\n\nNOIP 2007 提高第三题。\n\n\n\n", "locale": "zh-CN"}}}
{"pid": "P1006", "type": "P", "difficulty": 4, "samples": [["3 3\n0 3 9\n2 8 5\n5 7 0\n", "34"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "NOIP 提高组", "费用流"], "title": "[NOIP 2008 提高组] 传纸条", "background": null, "description": "小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排坐成一个 $m$ 行 $n$ 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 $(1,1)$，小轩坐在矩阵的右下角，坐标 $(m,n)$。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。\n\n在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。\n\n还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用 $0$ 表示），可以用一个 $[0,100]$ 内的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的两条路径。", "inputFormat": "第一行有两个用空格隔开的整数 $m$ 和 $n$，表示班里有 $m$ 行 $n$ 列。\n\n接下来的 $m$ 行是一个 $m \\times n$ 的矩阵，矩阵中第 $i$ 行 $j$ 列的整数表示坐在第 $i$ 行 $j$ 列的学生的好心程度。每行的 $n$ 个整数之间用空格隔开。", "outputFormat": "输出文件共一行一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。", "hint": "**【数据范围】**\n\n对于 $30\\%$ 的数据，满足 $2 \\le m,n \\le 10$。  \n对于 $100\\%$ 的数据，满足 $2 \\le m,n \\le 50$。\n\n**【题目来源】**\n\nNOIP 2008 提高组第三题。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2008 Senior] Passing Notes", "background": null, "description": "Xiaoyuan and Xiaoxuan are good friends and classmates who always have a lot to talk about. During a team-building activity, the class is seated in an $m$-by-$n$ grid. Xiaoyuan and Xiaoxuan are placed at opposite ends of the main diagonal, so they cannot talk directly. Fortunately, they can communicate by passing notes. The note must be relayed by several classmates: Xiaoyuan sits at the top-left corner with coordinates $(1,1)$, and Xiaoxuan sits at the bottom-right corner with coordinates $(m,n)$. A note passed from Xiaoyuan to Xiaoxuan may only move down or right; a note passed from Xiaoxuan to Xiaoyuan may only move up or left.\n\nDuring the activity, Xiaoyuan wants to send a note to Xiaoxuan and also receive a reply. Every classmate can help relay notes but will help at most once in total. That is, if a classmate helps when the note is sent from Xiaoyuan to Xiaoxuan, they will not help when the note is sent in the reverse direction, and vice versa.\n\nAnother point to note is that each classmate has a kindness level, which varies from person to person (note: the kindness of Xiaoyuan and Xiaoxuan is undefined and is represented by $0$ in the input). Kindness is represented by a natural number in $[0,100]$, with larger numbers indicating greater kindness. Xiaoyuan and Xiaoxuan wish to choose classmates with as high kindness as possible to relay the notes, i.e., to find two relay paths (there and back) such that the sum of kindness values of classmates on these two paths is maximized. Please help them find such two paths.", "inputFormat": "The first line contains two integers $m$ and $n$ separated by a space, indicating there are $m$ rows and $n$ columns.\n\nThe next $m$ lines describe an $m \\times n$ matrix. The integer in row $i$, column $j$ represents the kindness of the student seated at row $i$, column $j$. The $n$ integers in each row are separated by spaces.", "outputFormat": "Output a single integer on one line, which is the maximum possible sum of kindness values of the students who participate in relaying the two notes.", "hint": "- Constraints:\n  - For $30\\%$ of the testdata, $2 \\le m,n \\le 10$.\n  - For $100\\%$ of the testdata, $2 \\le m,n \\le 50$.\n- Problem Source: NOIP 2008 Senior, Problem 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2008 提高组] 传纸条", "background": null, "description": "小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排坐成一个 $m$ 行 $n$ 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 $(1,1)$，小轩坐在矩阵的右下角，坐标 $(m,n)$。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。\n\n在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。\n\n还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用 $0$ 表示），可以用一个 $[0,100]$ 内的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的两条路径。", "inputFormat": "第一行有两个用空格隔开的整数 $m$ 和 $n$，表示班里有 $m$ 行 $n$ 列。\n\n接下来的 $m$ 行是一个 $m \\times n$ 的矩阵，矩阵中第 $i$ 行 $j$ 列的整数表示坐在第 $i$ 行 $j$ 列的学生的好心程度。每行的 $n$ 个整数之间用空格隔开。", "outputFormat": "输出文件共一行一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。", "hint": "**【数据范围】**\n\n对于 $30\\%$ 的数据，满足 $2 \\le m,n \\le 10$。  \n对于 $100\\%$ 的数据，满足 $2 \\le m,n \\le 50$。\n\n**【题目来源】**\n\nNOIP 2008 提高组第三题。", "locale": "zh-CN"}}}
{"pid": "P1007", "type": "P", "difficulty": 3, "samples": [["4\n2\n1 3\n", "2 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心"], "title": "独木桥", "background": "战争已经进入到紧要时间。你是运输小队长，正在率领运输部队向前线运送物资。运输任务像做题一样的无聊。你希望找些刺激，于是命令你的士兵们到前方的一座独木桥上欣赏风景，而你留在桥下欣赏士兵们。士兵们十分愤怒，因为这座独木桥十分狭窄，只能容纳 $1$ 个人通过。假如有 $2$ 个人相向而行在桥上相遇，那么他们 $2$ 个人将无法绕过对方，只能有 $1$ 个人回头下桥，让另一个人先通过。但是，可以有多个人同时呆在同一个位置。", "description": "突然，你收到从指挥部发来的信息，敌军的轰炸机正朝着你所在的独木桥飞来！为了安全，你的部队必须撤下独木桥。独木桥的长度为 $L$，士兵们只能呆在坐标为整数的地方。所有士兵的速度都为 $1$，但一个士兵某一时刻来到了坐标为 $0$ 或 $L+1$ 的位置，他就离开了独木桥。\n\n每个士兵都有一个初始面对的方向，他们会以匀速朝着这个方向行走，中途不会自己改变方向。但是，如果两个士兵面对面相遇，他们无法彼此通过对方，于是就分别转身，继续行走。转身不需要任何的时间。\n\n由于先前的愤怒，你已不能控制你的士兵。甚至，你连每个士兵初始面对的方向都不知道。因此，你想要知道你的部队最少需要多少时间就可能全部撤离独木桥。另外，总部也在安排阻拦敌人的进攻，因此你还需要知道你的部队最多需要多少时间才能全部撤离独木桥。", "inputFormat": "第一行共一个整数 $L$，表示独木桥的长度。桥上的坐标为 $1, 2, \\cdots, L$。\n\n第二行共一个整数 $N$，表示初始时留在桥上的士兵数目。\n\n第三行共有 $N$ 个整数，分别表示每个士兵的初始坐标。", "outputFormat": "共一行，输出 $2$ 个整数，分别表示部队撤离独木桥的最小时间和最大时间。$2$ 个整数由一个空格符分开。", "hint": "对于 $100\\%$ 的数据，满足初始时，没有两个士兵同在一个坐标，$1\\le  L\\le5\\times 10^3$，$0\\le N\\le5\\times10^3$，且数据保证 $N\\le L$。", "locale": "zh-CN", "translations": {"en": {"title": "Single-Plank Bridge", "background": null, "description": "Suddenly, you receive a message from headquarters: enemy bombers are flying toward the single-plank bridge where you are located. For safety, your unit must evacuate the bridge. The bridge has length $L$, and soldiers can only stay at positions with integer coordinates. All soldiers move at speed $1$, and once a soldier reaches coordinate $0$ or $L+1$ at any moment, he leaves the bridge.\n\nEach soldier has an initial facing direction and will walk uniformly in that direction without changing it on his own. However, if two soldiers meet face to face, they cannot pass through each other, so they both turn around and keep walking. Turning around takes no time.\n\nDue to earlier anger, you can no longer control your soldiers. You do not even know each soldier’s initial facing direction. Therefore, you want to know the minimum possible time for your unit to completely evacuate the bridge. In addition, as headquarters is arranging to block the enemy’s advance, you also need to know the maximum possible time for your unit to completely evacuate the bridge.", "inputFormat": "The first line contains a single integer $L$, the length of the bridge. The coordinates on the bridge are $1, 2, \\cdots, L$.\n\nThe second line contains a single integer $N$, the number of soldiers initially on the bridge.\n\nThe third line contains $N$ integers, the initial coordinate of each soldier.", "outputFormat": "Output a single line with $2$ integers: the minimum and maximum time for the unit to evacuate the bridge. The $2$ integers are separated by a space.", "hint": "For $100\\%$ of the testdata, initially no two soldiers occupy the same coordinate, $1 \\le L \\le 5 \\times 10^3$, $0 \\le N \\le 5 \\times 10^3$, and the data guarantees $N \\le L$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "独木桥", "background": "战争已经进入到紧要时间。你是运输小队长，正在率领运输部队向前线运送物资。运输任务像做题一样的无聊。你希望找些刺激，于是命令你的士兵们到前方的一座独木桥上欣赏风景，而你留在桥下欣赏士兵们。士兵们十分愤怒，因为这座独木桥十分狭窄，只能容纳 $1$ 个人通过。假如有 $2$ 个人相向而行在桥上相遇，那么他们 $2$ 个人将无法绕过对方，只能有 $1$ 个人回头下桥，让另一个人先通过。但是，可以有多个人同时呆在同一个位置。", "description": "突然，你收到从指挥部发来的信息，敌军的轰炸机正朝着你所在的独木桥飞来！为了安全，你的部队必须撤下独木桥。独木桥的长度为 $L$，士兵们只能呆在坐标为整数的地方。所有士兵的速度都为 $1$，但一个士兵某一时刻来到了坐标为 $0$ 或 $L+1$ 的位置，他就离开了独木桥。\n\n每个士兵都有一个初始面对的方向，他们会以匀速朝着这个方向行走，中途不会自己改变方向。但是，如果两个士兵面对面相遇，他们无法彼此通过对方，于是就分别转身，继续行走。转身不需要任何的时间。\n\n由于先前的愤怒，你已不能控制你的士兵。甚至，你连每个士兵初始面对的方向都不知道。因此，你想要知道你的部队最少需要多少时间就可能全部撤离独木桥。另外，总部也在安排阻拦敌人的进攻，因此你还需要知道你的部队最多需要多少时间才能全部撤离独木桥。", "inputFormat": "第一行共一个整数 $L$，表示独木桥的长度。桥上的坐标为 $1, 2, \\cdots, L$。\n\n第二行共一个整数 $N$，表示初始时留在桥上的士兵数目。\n\n第三行共有 $N$ 个整数，分别表示每个士兵的初始坐标。", "outputFormat": "共一行，输出 $2$ 个整数，分别表示部队撤离独木桥的最小时间和最大时间。$2$ 个整数由一个空格符分开。", "hint": "对于 $100\\%$ 的数据，满足初始时，没有两个士兵同在一个坐标，$1\\le  L\\le5\\times 10^3$，$0\\le N\\le5\\times10^3$，且数据保证 $N\\le L$。", "locale": "zh-CN"}}}
{"pid": "P1008", "type": "P", "difficulty": 2, "samples": [["无", "192 384 576\n* * *\n...\n\n* * *\n（剩余部分不予展示）"]], "limits": {"time": [1000], "memory": [65536]}, "tags": ["模拟", "1998", "NOIP 普及组", "提交答案", "枚举"], "title": "[NOIP 1998 普及组] 三连击", "background": "本题为提交答案题，您可以写程序或手算在本机上算出答案后，直接提交答案文本，也可提交答案生成程序。", "description": "将 $1, 2, \\ldots , 9$ 共 $9$ 个数分成 $3$ 组，分别组成 $3$ 个三位数，且使这 $3$ 个三位数构成 $1 : 2 : 3$ 的比例，试求出所有满足条件的 $3$ 个三位数。", "inputFormat": "无", "outputFormat": "若干行，每行 $3$ 个数字。按照每行第 $1$ 个数字升序排列。", "hint": "NOIP1998 普及组 第一题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 1998 Junior] Triple Hit", "background": null, "description": "Partition the $9$ numbers $1, 2, \\ldots , 9$ into $3$ groups to form $3$ three-digit numbers, such that these $3$ three-digit numbers are in the ratio $1 : 2 : 3$. Find all triplets of three-digit numbers that satisfy this condition.", "inputFormat": "None.", "outputFormat": "Several lines, each containing 3 numbers. Sort the lines in ascending order by the first number in each line.", "hint": "NOIP 1998 Junior Problem 1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 1998 普及组] 三连击", "background": "本题为提交答案题，您可以写程序或手算在本机上算出答案后，直接提交答案文本，也可提交答案生成程序。", "description": "将 $1, 2, \\ldots , 9$ 共 $9$ 个数分成 $3$ 组，分别组成 $3$ 个三位数，且使这 $3$ 个三位数构成 $1 : 2 : 3$ 的比例，试求出所有满足条件的 $3$ 个三位数。", "inputFormat": "无", "outputFormat": "若干行，每行 $3$ 个数字。按照每行第 $1$ 个数字升序排列。", "hint": "NOIP1998 普及组 第一题", "locale": "zh-CN"}}}
{"pid": "P1009", "type": "P", "difficulty": 2, "samples": [["3\n", "9"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000]}, "tags": ["数学", "高精度", "1998", "NOIP 普及组"], "title": "[NOIP 1998 普及组] 阶乘之和", "background": "", "description": "用高精度计算出 $S = 1! + 2! + 3! + \\cdots + n!$（$n \\le 50$）。\n\n其中 `!` 表示阶乘，定义为 $n!=n\\times (n-1)\\times (n-2)\\times \\cdots \\times 1$。例如，$5! = 5 \\times 4 \\times 3 \\times 2 \\times 1=120$。", "inputFormat": "一个正整数 $n$。", "outputFormat": "一个正整数 $S$，表示计算结果。", "hint": "**【数据范围】**\n\n对于 $100 \\%$ 的数据，$1 \\le n \\le 50$。\n\n**【其他说明】**\n\n注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 $n \\le 20$，使用书中的代码无法通过本题。\n\n如果希望通过本题，请继续学习第八章高精度的知识。\n\nNOIP1998 普及组 第二题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 1998 Junior] Sum of Factorials", "background": null, "description": "Compute with arbitrary-precision integers the value $S = 1! + 2! + 3! + \\cdots + n!$ ($n \\le 50$).\n\nHere, `!` denotes factorial, defined as $n!=n\\times (n-1)\\times (n-2)\\times \\cdots \\times 1$. For example, $5! = 5 \\times 4 \\times 3 \\times 2 \\times 1=120$.", "inputFormat": "A positive integer $n$.", "outputFormat": "A positive integer $S$, the result of the computation.", "hint": "【Constraints】\n\nFor $100 \\%$ of the testdata, $1 \\le n \\le 50$.\n\n【Additional Notes】\n\nNote: The book “深入浅出基础篇” uses this problem as an example, but its constraint is only $n \\le 20$, so the code in the book cannot pass this problem.\n\nTo pass this problem, please continue studying the Chapter 8 content on arbitrary-precision (“high-precision”) arithmetic.\n\nNOIP 1998 Junior, Problem 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 1998 普及组] 阶乘之和", "background": "", "description": "用高精度计算出 $S = 1! + 2! + 3! + \\cdots + n!$（$n \\le 50$）。\n\n其中 `!` 表示阶乘，定义为 $n!=n\\times (n-1)\\times (n-2)\\times \\cdots \\times 1$。例如，$5! = 5 \\times 4 \\times 3 \\times 2 \\times 1=120$。", "inputFormat": "一个正整数 $n$。", "outputFormat": "一个正整数 $S$，表示计算结果。", "hint": "**【数据范围】**\n\n对于 $100 \\%$ 的数据，$1 \\le n \\le 50$。\n\n**【其他说明】**\n\n注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 $n \\le 20$，使用书中的代码无法通过本题。\n\n如果希望通过本题，请继续学习第八章高精度的知识。\n\nNOIP1998 普及组 第二题", "locale": "zh-CN"}}}
{"pid": "P1010", "type": "P", "difficulty": 2, "samples": [["1315", "2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "1998", "递归", "NOIP 普及组", "分治"], "title": "[NOIP 1998 普及组] 幂次方", "background": "", "description": "任何一个正整数都可以用 $2$ 的幂次方表示。例如 $137=2^7+2^3+2^0 $。\n\n同时约定次方用括号来表示，即 $a^b$ 可表示为 $a(b)$。\n\n由此可知，$137$ 可表示为 $2(7)+2(3)+2(0)$。\n\n进一步：\n\n$7= 2^2+2+2^0$  ( $2^1$ 用 $2$ 表示)，并且 $3=2+2^0$。\n\n所以最后 $137$ 可表示为 $2(2(2)+2+2(0))+2(2+2(0))+2(0)$。\n\n又如 $1315=2^{10} +2^8 +2^5 +2+1$。\n\n所以 $1315$ 最后可表示为 $2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)$。", "inputFormat": "一行一个正整数 $n$。", "outputFormat": "符合约定的 $n$ 的 $0, 2$ 表示（在表示中不能有空格）。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 2 \\times {10}^4$。\n\nNOIP1998 普及组 第三题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 1998 Junior] Powers of Two", "background": null, "description": "Any positive integer can be expressed as a sum of powers of $2$. For example, $137=2^7+2^3+2^0$.\n\nWe also agree to write exponents using parentheses, i.e., $a^b$ can be written as $a(b)$.\n\nThus, $137$ can be written as $2(7)+2(3)+2(0)$.\n\nFurthermore, $7= 2^2+2+2^0$ (where $2^1$ is written as $2$), and $3=2+2^0$.\n\nTherefore, the final expression for $137$ is $2(2(2)+2+2(0))+2(2+2(0))+2(0)$.\n\nAnother example: $1315=2^{10} +2^8 +2^5 +2+1$.\n\nThus, the final expression for $1315$ is $2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)$.", "inputFormat": "One line containing a positive integer $n$.", "outputFormat": "Output the agreed \"0, 2\" representation of $n$ (no spaces are allowed in the expression).", "hint": "- Constraints: For $100\\%$ of the testdata, $1 \\le n \\le 2 \\times {10}^4$.\n- NOIP 1998 Junior, Problem 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 1998 普及组] 幂次方", "background": "", "description": "任何一个正整数都可以用 $2$ 的幂次方表示。例如 $137=2^7+2^3+2^0 $。\n\n同时约定次方用括号来表示，即 $a^b$ 可表示为 $a(b)$。\n\n由此可知，$137$ 可表示为 $2(7)+2(3)+2(0)$。\n\n进一步：\n\n$7= 2^2+2+2^0$  ( $2^1$ 用 $2$ 表示)，并且 $3=2+2^0$。\n\n所以最后 $137$ 可表示为 $2(2(2)+2+2(0))+2(2+2(0))+2(0)$。\n\n又如 $1315=2^{10} +2^8 +2^5 +2+1$。\n\n所以 $1315$ 最后可表示为 $2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)$。", "inputFormat": "一行一个正整数 $n$。", "outputFormat": "符合约定的 $n$ 的 $0, 2$ 表示（在表示中不能有空格）。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 2 \\times {10}^4$。\n\nNOIP1998 普及组 第三题", "locale": "zh-CN"}}}
{"pid": "P1011", "type": "P", "difficulty": 2, "samples": [["5 7 32 4\n", "13\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "1998", "NOIP 提高组", "Fibonacci 数列"], "title": "[NOIP 1998 提高组] 车站", "background": "", "description": "火车从始发站（称为第 $1$ 站）开出，在始发站上车的人数为 $a$，然后到达第 $2$ 站，在第 $2$ 站有人上、下车，但上、下车的人数相同，因此在第 $2$ 站开出时（即在到达第 $3$ 站之前）车上的人数保持为 $a$ 人。从第 $3$ 站起（包括第 $3$ 站）上、下车的人数有一定规律：上车的人数都是前两站上车人数之和，而下车人数等于上一站上车人数，一直到终点站的前一站（第 $n-1$ 站），都满足此规律。现给出的条件是：共有 $n$ 个车站，始发站上车的人数为 $a$，最后一站下车的人数是 $m$（全部下车）。试问 $x$ 站开出时车上的人数是多少？\n", "inputFormat": "输入只有一行四个整数，分别表示始发站上车人数 $a$，车站数 $n$，终点站下车人数 $m$ 和所求的站点编号 $x$。\n", "outputFormat": "输出一行一个整数表示答案：从 $x$ 站开出时车上的人数。\n", "hint": "对于全部的测试点，保证 $1 \\leq a \\leq 20$，$1 \\leq x \\leq n \\leq 20$，$1 \\leq m \\leq 2 \\times 10^4$。\n\nNOIP1998 提高组 第一题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 1998 Senior] Station", "background": null, "description": "A train departs from the origin (called station $1$). At the origin, $a$ people board. It then arrives at station $2$; at station $2$ some people board and alight, but the numbers boarding and alighting are equal, so when departing station $2$ (i.e., before arriving at station $3$), there remain $a$ people on the train. From station $3$ onward (including station $3$), the numbers boarding and alighting follow a rule: the number boarding at each station equals the sum of the numbers who boarded at the previous two stations, and the number alighting equals the number who boarded at the previous station. This holds through the penultimate station, station $n-1$. You are given that there are $n$ stations in total, $a$ people board at the origin, and at the last station the number of people alighting is $m$ (everyone gets off). Find the number of people on the train when departing station $x$.", "inputFormat": "A single line containing four integers: the number of people boarding at the origin $a$, the number of stations $n$, the number of people alighting at the terminal station $m$, and the station index to query $x$.", "outputFormat": "Output a single integer: the number of people on the train when departing station $x$.", "hint": "For all test cases, $1 \\leq a \\leq 20$, $1 \\leq x \\leq n \\leq 20$, $1 \\leq m \\leq 2 \\times 10^4$.\n\nNOIP 1998 Senior Problem 1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 1998 提高组] 车站", "background": "", "description": "火车从始发站（称为第 $1$ 站）开出，在始发站上车的人数为 $a$，然后到达第 $2$ 站，在第 $2$ 站有人上、下车，但上、下车的人数相同，因此在第 $2$ 站开出时（即在到达第 $3$ 站之前）车上的人数保持为 $a$ 人。从第 $3$ 站起（包括第 $3$ 站）上、下车的人数有一定规律：上车的人数都是前两站上车人数之和，而下车人数等于上一站上车人数，一直到终点站的前一站（第 $n-1$ 站），都满足此规律。现给出的条件是：共有 $n$ 个车站，始发站上车的人数为 $a$，最后一站下车的人数是 $m$（全部下车）。试问 $x$ 站开出时车上的人数是多少？\n", "inputFormat": "输入只有一行四个整数，分别表示始发站上车人数 $a$，车站数 $n$，终点站下车人数 $m$ 和所求的站点编号 $x$。\n", "outputFormat": "输出一行一个整数表示答案：从 $x$ 站开出时车上的人数。\n", "hint": "对于全部的测试点，保证 $1 \\leq a \\leq 20$，$1 \\leq x \\leq n \\leq 20$，$1 \\leq m \\leq 2 \\times 10^4$。\n\nNOIP1998 提高组 第一题", "locale": "zh-CN"}}}
{"pid": "P1012", "type": "P", "difficulty": 5, "samples": [["3\n13 312 343\n", "34331213\n"], ["4\n7 13 4 246", "7424613"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "贪心", "1998", "NOIP 提高组", "排序", "状压 DP"], "title": "[NOIP 1998 提高组] 拼数", "background": "", "description": "设有 $n$ 个正整数 $a_1 \\dots a_n$，请将它们联接成一排，相邻数字首尾相接，组成一个最大的整数。", "inputFormat": "第一行有一个整数，表示数字个数 $n$。\n\n第二行有 $n$ 个整数，表示给出的 $n$ 个整数 $a_i$。", "outputFormat": "一个正整数，表示最大的整数。", "hint": "对于全部的测试点，保证 $1 \\leq n \\leq 20$，$1 \\leq a_i \\leq 10^9$。\n\nNOIP1998 提高组 第二题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 1998 Senior] Concatenating Numbers", "background": null, "description": "Given $n$ positive integers $a_1 \\dots a_n$, arrange them in a row, concatenating adjacent numbers end to end, to form the largest possible integer.", "inputFormat": "The first line contains an integer $n$, the number of integers.\n\nThe second line contains $n$ integers $a_i$, the given integers.", "outputFormat": "Output a positive integer, the largest possible integer.", "hint": "Constraints: For all test points, $1 \\leq n \\leq 20$, $1 \\leq a_i \\leq 10^9$.\n\nNOIP 1998 Senior, Problem 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 1998 提高组] 拼数", "background": "", "description": "设有 $n$ 个正整数 $a_1 \\dots a_n$，请将它们联接成一排，相邻数字首尾相接，组成一个最大的整数。", "inputFormat": "第一行有一个整数，表示数字个数 $n$。\n\n第二行有 $n$ 个整数，表示给出的 $n$ 个整数 $a_i$。", "outputFormat": "一个正整数，表示最大的整数。", "hint": "对于全部的测试点，保证 $1 \\leq n \\leq 20$，$1 \\leq a_i \\leq 10^9$。\n\nNOIP1998 提高组 第二题", "locale": "zh-CN"}}}
{"pid": "P1013", "type": "P", "difficulty": 4, "samples": [["5\n+ L K V E\nL L K V E\nK K V E KL\nV V E KL KK\nE E KL KK KV\n", "L=0 K=1 V=2 E=3\n4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "1998", "NOIP 提高组", "枚举", "进制"], "title": "[NOIP 1998 提高组] 进制位", "background": null, "description": "著名科学家卢斯为了检查学生对进位制的理解，他给出了如下的一张加法表，表中的字母代表数字。 例如：\n\n$$\n\\def\\arraystretch{2}\n\\begin{array}{c||c|c|c|c}\n\\rm +  & \\kern{.5cm} \\rm \\mathclap{L} \\kern{.5cm}  &  \\kern{.5cm} \\rm \\mathclap{K} \\kern{.5cm} &  \\kern{.5cm} \\rm \\mathclap{V} \\kern{.5cm} & \\kern{.5cm} \\rm \\mathclap{E} \\kern{.5cm} \\\\ \\hline\\hline\n\\rm L  &  \\rm L  &  \\rm K  &  \\rm V  & \\rm E  \\\\ \\hline\n\\rm K  &  \\rm K  &  \\rm V  &  \\rm E  & \\rm \\mathclap{KL} \\\\ \\hline\n\\rm V  &  \\rm V  &  \\rm E  &  \\rm \\mathclap{KL} & \\rm \\mathclap{KK} \\\\ \\hline\n\\rm E  &  \\rm E  &  \\rm \\mathclap{KL} &  \\rm \\mathclap{KK} & \\rm \\mathclap{KV} \\\\\n\\end{array}$$\n\n其含义为：\n\n$L+L=L$，$L+K=K$，$L+V=V$，$L+E=E$\n\n$K+L=K$，$K+K=V$，$K+V=E$，$K+E=KL$    \n\n$\\cdots$\n\n$E+E=KV$    \n\n根据这些规则可推导出：$L=0$，$K=1$，$V=2$，$E=3$。\n\n同时可以确定该表表示的是 $4$ 进制加法。", "inputFormat": "第一行一个整数 $n$（$3\\le n\\le9$）表示行数。\n\n以下 $n$ 行，每行包括 $n$ 个字符串，每个字符串间用空格隔开。\n\n若记 $s_{i,j}$ 表示第 $i$ 行第 $j$ 个字符串，数据保证 $s_{1,1}=\\texttt +$，$s_{i,1}=s_{1,i}$，$|s_{i,1}|=1$，$s_{i,1}\\ne s_{j,1}$ （$i\\ne j$）。\n\n保证至多有一组解。", "outputFormat": "第一行输出各个字母表示什么数，格式如：`L=0 K=1` $\\cdots$ 按给出的字母顺序排序。不同字母必须代表不同数字。\n\n第二行输出加法运算是几进制的。\n\n若不可能组成加法表，则应输出 `ERROR!`。", "hint": "NOIP1998 提高组 第三题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 1998 Senior] Positional Addition Table", "background": null, "description": "To check students’ understanding of positional numeral systems, the famous scientist Lu Si gave the following addition table, where letters represent digits. For example:\n\n$$\n\\def\\arraystretch{2}\n\\begin{array}{c||c|c|c|c}\n\\rm +  & \\kern{.5cm} \\rm \\mathclap{L} \\kern{.5cm}  &  \\kern{.5cm} \\rm \\mathclap{K} \\kern{.5cm} &  \\kern{.5cm} \\rm \\mathclap{V} \\kern{.5cm} & \\kern{.5cm} \\rm \\mathclap{E} \\kern{.5cm} \\\\ \\hline\\hline\n\\rm L  &  \\rm L  &  \\rm K  &  \\rm V  & \\rm E  \\\\ \\hline\n\\rm K  &  \\rm K  &  \\rm V  &  \\rm E  & \\rm \\mathclap{KL} \\\\ \\hline\n\\rm V  &  \\rm V  &  \\rm E  &  \\rm \\mathclap{KL} & \\rm \\mathclap{KK} \\\\ \\hline\n\\rm E  &  \\rm E  &  \\rm \\mathclap{KL} &  \\rm \\mathclap{KK} & \\rm \\mathclap{KV} \\\\\n\\end{array}$$\n\nIts meaning is:\n\n$L+L=L$，$L+K=K$，$L+V=V$，$L+E=E$\n\n$K+L=K$，$K+K=V$，$K+V=E$，$K+E=KL$    \n\n$\\cdots$\n\n$E+E=KV$    \n\nFrom these rules, we can deduce: $L=0$，$K=1$，$V=2$，$E=3$.\n\nWe can also determine that the table represents base $4$ addition.", "inputFormat": "The first line contains an integer $n$ ($3 \\le n \\le 9$) representing the number of rows.\n\nThe following $n$ lines each contain $n$ strings separated by spaces.\n\nLet $s_{i,j}$ denote the string in row $i$ and column $j$. The testdata guarantees $s_{1,1}=\\texttt{+}$, $s_{i,1}=s_{1,i}$, $|s_{i,1}|=1$, and $s_{i,1} \\ne s_{j,1}$ ($i \\ne j$).\n\nIt is guaranteed that there is at most one solution.", "outputFormat": "On the first line, output which number each letter represents, in the format like: `L=0 K=1` $\\cdots$ sorted in the given letter order. Different letters must represent different digits.\n\nOn the second line, output the base of the addition.\n\nIf it is impossible to form a valid addition table, output `ERROR!`.", "hint": "NOIP 1998 Senior Problem 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 1998 提高组] 进制位", "background": null, "description": "著名科学家卢斯为了检查学生对进位制的理解，他给出了如下的一张加法表，表中的字母代表数字。 例如：\n\n$$\n\\def\\arraystretch{2}\n\\begin{array}{c||c|c|c|c}\n\\rm +  & \\kern{.5cm} \\rm \\mathclap{L} \\kern{.5cm}  &  \\kern{.5cm} \\rm \\mathclap{K} \\kern{.5cm} &  \\kern{.5cm} \\rm \\mathclap{V} \\kern{.5cm} & \\kern{.5cm} \\rm \\mathclap{E} \\kern{.5cm} \\\\ \\hline\\hline\n\\rm L  &  \\rm L  &  \\rm K  &  \\rm V  & \\rm E  \\\\ \\hline\n\\rm K  &  \\rm K  &  \\rm V  &  \\rm E  & \\rm \\mathclap{KL} \\\\ \\hline\n\\rm V  &  \\rm V  &  \\rm E  &  \\rm \\mathclap{KL} & \\rm \\mathclap{KK} \\\\ \\hline\n\\rm E  &  \\rm E  &  \\rm \\mathclap{KL} &  \\rm \\mathclap{KK} & \\rm \\mathclap{KV} \\\\\n\\end{array}$$\n\n其含义为：\n\n$L+L=L$，$L+K=K$，$L+V=V$，$L+E=E$\n\n$K+L=K$，$K+K=V$，$K+V=E$，$K+E=KL$    \n\n$\\cdots$\n\n$E+E=KV$    \n\n根据这些规则可推导出：$L=0$，$K=1$，$V=2$，$E=3$。\n\n同时可以确定该表表示的是 $4$ 进制加法。", "inputFormat": "第一行一个整数 $n$（$3\\le n\\le9$）表示行数。\n\n以下 $n$ 行，每行包括 $n$ 个字符串，每个字符串间用空格隔开。\n\n若记 $s_{i,j}$ 表示第 $i$ 行第 $j$ 个字符串，数据保证 $s_{1,1}=\\texttt +$，$s_{i,1}=s_{1,i}$，$|s_{i,1}|=1$，$s_{i,1}\\ne s_{j,1}$ （$i\\ne j$）。\n\n保证至多有一组解。", "outputFormat": "第一行输出各个字母表示什么数，格式如：`L=0 K=1` $\\cdots$ 按给出的字母顺序排序。不同字母必须代表不同数字。\n\n第二行输出加法运算是几进制的。\n\n若不可能组成加法表，则应输出 `ERROR!`。", "hint": "NOIP1998 提高组 第三题", "locale": "zh-CN"}}}
{"pid": "P1014", "type": "P", "difficulty": 2, "samples": [["7\n", "1/4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "数学", "1999", "NOIP 普及组", "枚举"], "title": "[NOIP 1999 普及组] Cantor 表", "background": null, "description": "现代数学的著名证明之一是 Georg Cantor 证明了有理数是可枚举的。他是用下面这一张表来证明这一命题的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jdjdaf73.png)\n\n我们以 Z 字形给上表的每一项编号。第一项是 $1/1$，然后是 $1/2$，$2/1$，$3/1$，$2/2$，…", "inputFormat": "整数 $N$（$1 \\leq N \\leq 10^7$）。", "outputFormat": "表中的第 $N$ 项。", "hint": "- 2024-11-18 0:30 数据中加入了样例，放在不计分的子任务 2 中。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 1999 Junior] Cantor Table", "background": null, "description": "One of the famous proofs in modern mathematics is Georg Cantor's proof that the rational numbers are countable. He used the following table to prove this statement:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jdjdaf73.png)\n\nWe number each entry of the table in a Z-shaped order. The first entry is $1/1$, then $1/2$, $2/1$, $3/1$, $2/2$, …", "inputFormat": "An integer $N$ ($1 \\leq N \\leq 10^7$).", "outputFormat": "The $N$-th term in the table.", "hint": "- 2024-11-18 00:30 Samples were added to the testdata and placed in the non-scoring Subtask 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 1999 普及组] Cantor 表", "background": null, "description": "现代数学的著名证明之一是 Georg Cantor 证明了有理数是可枚举的。他是用下面这一张表来证明这一命题的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jdjdaf73.png)\n\n我们以 Z 字形给上表的每一项编号。第一项是 $1/1$，然后是 $1/2$，$2/1$，$3/1$，$2/2$，…", "inputFormat": "整数 $N$（$1 \\leq N \\leq 10^7$）。", "outputFormat": "表中的第 $N$ 项。", "hint": "- 2024-11-18 0:30 数据中加入了样例，放在不计分的子任务 2 中。", "locale": "zh-CN"}}}
{"pid": "P1015", "type": "P", "difficulty": 2, "samples": [["10\n87\n", "STEP=4\n"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000]}, "tags": ["模拟", "高精度", "1999", "NOIP 普及组", "进制"], "title": "[NOIP 1999 普及组] 回文数", "background": "", "description": "若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。\n\n例如：给定一个十进制数 $56$，将 $56$ 加 $65$（即把 $56$ 从右向左读），得到 $121$ 是一个回文数。\n\n又如：对于十进制数 $87$：\n\nSTEP1：$87+78=165$  \nSTEP2：$165+561=726$  \nSTEP3：$726+627=1353$   \nSTEP4：$1353+3531=4884$  \n\n在这里的一步是指进行了一次 $N$ 进制的加法，上例最少用了 $4$ 步得到回文数 $4884$。\n\n写一个程序，给定一个 $N$（$2 \\le N \\le 10$ 或 $N=16$）进制数 $M$（$100$ 位之内），求最少经过几步可以得到回文数。如果在 $30$ 步以内（包含 $30$ 步）不可能得到回文数，则输出 `Impossible!`。", "inputFormat": "两行，分别是 $N$，$M$。\n", "outputFormat": "如果能在 $30$ 步以内得到回文数，输出格式形如 `STEP=ans`，其中 $\\text{ans}$ 为最少得到回文数的步数。\n\n否则输出 `Impossible!`。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 1999 Junior] Palindromic Number", "background": null, "description": "If a number (with a nonzero leading digit) reads the same from left to right and from right to left, we call it a palindromic number.\n\nFor example: given the decimal number $56$, adding $56$ and $65$ (i.e., reading $56$ from right to left) yields $121$, which is a palindromic number.\n\nAnother example for the decimal number $87$:\nSTEP1: $87+78=165$.\nSTEP2: $165+561=726$.\nSTEP3: $726+627=1353$.\nSTEP4: $1353+3531=4884$.\n\nHere, one step means performing one addition in base $N$. In the above example, it takes at least $4$ steps to obtain the palindromic number $4884$.\n\nWrite a program that, given a base $N$ ($2 \\le N \\le 10$ or $N=16$) number $M$ (within $100$ digits), finds the minimum number of steps needed to obtain a palindromic number. If it is impossible to obtain a palindromic number within $30$ steps (inclusive), output `Impossible!`.", "inputFormat": "Two lines: $N$, then $M$.", "outputFormat": "If a palindromic number can be obtained within $30$ steps, output in the form `STEP=ans`, where $\\text{ans}$ is the minimum number of steps.\n\nOtherwise, output `Impossible!`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 1999 普及组] 回文数", "background": "", "description": "若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。\n\n例如：给定一个十进制数 $56$，将 $56$ 加 $65$（即把 $56$ 从右向左读），得到 $121$ 是一个回文数。\n\n又如：对于十进制数 $87$：\n\nSTEP1：$87+78=165$  \nSTEP2：$165+561=726$  \nSTEP3：$726+627=1353$   \nSTEP4：$1353+3531=4884$  \n\n在这里的一步是指进行了一次 $N$ 进制的加法，上例最少用了 $4$ 步得到回文数 $4884$。\n\n写一个程序，给定一个 $N$（$2 \\le N \\le 10$ 或 $N=16$）进制数 $M$（$100$ 位之内），求最少经过几步可以得到回文数。如果在 $30$ 步以内（包含 $30$ 步）不可能得到回文数，则输出 `Impossible!`。", "inputFormat": "两行，分别是 $N$，$M$。\n", "outputFormat": "如果能在 $30$ 步以内得到回文数，输出格式形如 `STEP=ans`，其中 $\\text{ans}$ 为最少得到回文数的步数。\n\n否则输出 `Impossible!`。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1016", "type": "P", "difficulty": 3, "samples": [["275.6 11.9 27.4 2.8 2\n102.0 2.9\n220.0 2.2\n", "26.95\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "1999", "递归", "NOIP 普及组", "NOIP 提高组"], "title": "[NOIP 1999 普及组/提高组] 旅行家的预算", "background": null, "description": "一个旅行家想驾驶汽车以最小的费用从一个城市到另一个城市（假设出发时油箱是空的）。给定两个城市之间的距离 $S$、汽车油箱的容量 $C$（以升为单位）、每升汽油能行驶的距离 $L$、出发点每升汽油价格 $P_0$ 和沿途油站数 $N$，油站 $i$ 离出发点的距离 $D_i$、油站 $i$ 每升汽油价格 $P_i\\ (i=1,2,\\dots,N)$，你需要求出最小的费用。", "inputFormat": "第一行，四个实数 $S,C,L,P_0$ 和一个整数 $N$，含义见题目描述。\n\n接下来 $N$ 行，第 $i+1$ 行两个实数 $D_i$ 和 $P_i$，含义见题目描述。", "outputFormat": "仅一行一个实数，代表最小的费用（四舍五入至小数点后两位）。\n\n如果无法到达目的地，输出 `No Solution`。", "hint": "保证 $0 \\leq N \\leq 6$，$0 \\leq S,C,L \\leq 500$，且对于任意 $0\\leq i \\leq N$，均有 $0 \\leq P_i \\leq 500$，$0 \\leq D_i \\leq S$。\n\nNOIP1999 普及组第三题、提高组第三题。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 1999 Junior/Senior] Traveler's Budget", "background": null, "description": "A traveler wants to drive a car from one city to another at the minimum cost (assume the fuel tank is empty at the start). Given the distance between the two cities $S$, the fuel tank capacity $C$ (in liters), the distance per liter $L$, the price per liter at the starting point $P_0$, and the number of gas stations along the route $N$, as well as the distance from the starting point to gas station $i$, $D_i$, and the price per liter at gas station $i$, $P_i\\ (i=1,2,\\dots,N)$, you need to find the minimum cost.", "inputFormat": "The first line contains four real numbers $S, C, L, P_0$ and one integer $N$, as described above.\n\nFor each of the next $N$ lines, the $(i+1)$-th line contains two real numbers $D_i$ and $P_i$, as described above.", "outputFormat": "Print a single real number, the minimum cost (rounded to two decimal places).\n\nIf it is impossible to reach the destination, output `No Solution`.", "hint": "Constraints: $0 \\leq N \\leq 6$, $0 \\leq D_i \\leq S$, $0 \\leq S, C, L, P_0, P_i \\leq 500$.\n\nNOIP 1999 Junior problem 3, Senior problem 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 1999 普及组/提高组] 旅行家的预算", "background": null, "description": "一个旅行家想驾驶汽车以最小的费用从一个城市到另一个城市（假设出发时油箱是空的）。给定两个城市之间的距离 $S$、汽车油箱的容量 $C$（以升为单位）、每升汽油能行驶的距离 $L$、出发点每升汽油价格 $P_0$ 和沿途油站数 $N$，油站 $i$ 离出发点的距离 $D_i$、油站 $i$ 每升汽油价格 $P_i\\ (i=1,2,\\dots,N)$，你需要求出最小的费用。", "inputFormat": "第一行，四个实数 $S,C,L,P_0$ 和一个整数 $N$，含义见题目描述。\n\n接下来 $N$ 行，第 $i+1$ 行两个实数 $D_i$ 和 $P_i$，含义见题目描述。", "outputFormat": "仅一行一个实数，代表最小的费用（四舍五入至小数点后两位）。\n\n如果无法到达目的地，输出 `No Solution`。", "hint": "保证 $0 \\leq N \\leq 6$，$0 \\leq S,C,L \\leq 500$，且对于任意 $0\\leq i \\leq N$，均有 $0 \\leq P_i \\leq 500$，$0 \\leq D_i \\leq S$。\n\nNOIP1999 普及组第三题、提高组第三题。", "locale": "zh-CN"}}}
{"pid": "P1017", "type": "P", "difficulty": 2, "samples": [["30000 -2", "30000=11011010101110000(base-2)"], ["-20000 -2", "-20000=1111011000100000(base-2)"], ["28800 -16", "28800=19180(base-16)"], ["-25000 -16", "-25000=7FB8(base-16)"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2000", "NOIP 提高组", "进制"], "title": "[NOIP 2000 提高组] 进制转换", "background": "NOIP2000 提高组 T1", "description": "我们可以用这样的方式来表示一个十进制数：将每个阿拉伯数字乘以一个以该数字所处位置为指数，以 $10$ 为底数的幂之和的形式。例如 $123$ 可表示为 $1 \\times 10^2+2\\times 10^1+3\\times 10^0$ 这样的形式。\n\n与之相似的，对二进制数来说，也可表示成每个二进制数码乘以一个以该数字所处位置为指数，以 $2$ 为底数的幂之和的形式。  \n\n一般说来，任何一个正整数 $R$ 或一个负整数 $-R$ 都可以被选来作为一个数制系统的基数。如果是以 $R$ 或 $-R$ 为基数，则需要用到的数码为 $0,1,\\dots,R-1$。  \n\n例如当 $R=7$ 时,所需用到的数码是 $0,1,2,3,4,5,6$，这与其是 $R$ 或 $-R$ 无关。如果作为基数的数绝对值超过 $10$，则为了表示这些数码，通常使用英文字母来表示那些大于 $9$ 的数码。例如对 $16$ 进制数来说,用 $A$ 表示 $10$，用 $B$ 表示 $11$，用 $C$ 表示 $12$，以此类推。\n\n在负进制数中是用 $-R $ 作为基数，例如 $-15$（十进制）相当于 $(110001)_{-2}$（$-2$进制），并且它可以被表示为 $2$ 的幂级数的和数：\n\n$$(110001)_{-2}=1\\times (-2)^5+1\\times (-2)^4+0\\times (-2)^3+0\\times (-2)^2+0\\times (-2)^1 +1\\times (-2)^0$$\n\n设计一个程序，读入一个十进制数和一个负进制数的基数，并将此十进制数转换为此负进制下的数。", "inputFormat": "输入的每行有两个输入数据。\n\n第一个是十进制数 $n$。第二个是负进制数的基数 $R$。", "outputFormat": "输出此负进制数及其基数，若此基数的绝对值超过 $10$，则参照 $16$ 进制的方式处理。", "hint": "**数据范围**\n\n对于 $100\\%$ 的数据，$-20 \\le R \\le -2$，$|n| \\le 37336$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2000 Senior] Base Conversion", "background": null, "description": "We can represent a decimal number as the sum of each Arabic digit multiplied by a power of $10$ whose exponent is the position of that digit. For example, $123$ can be written as $1 \\times 10^2+2\\times 10^1+3\\times 10^0$.\n\nSimilarly, a binary number can be written as the sum of each binary digit multiplied by a power of $2$ whose exponent is the position of that digit.\n\nIn general, any positive integer $R$ or negative integer $-R$ can be chosen as the base of a numeral system. If the base is $R$ or $-R$, the required digits are $0,1,\\dots,R-1$.\n\nFor example, when $R=7$, the digits are $0,1,2,3,4,5,6$, regardless of whether the base is $R$ or $-R$. If the absolute value of the base exceeds $10$, letters are commonly used to represent digits greater than $9$. For instance, in base $16$, $A$ represents $10$, $B$ represents $11$, $C$ represents $12$, and so on.\n\nIn a negative-base system, $-R$ is used as the base. For example, $-15$ (in decimal) is equivalent to $(110001)_{-2}$ (base $-2$), and it can be written as a sum of powers of $2$:\n$$(110001)_{-2}=1\\times (-2)^5+1\\times (-2)^4+0\\times (-2)^3+0\\times (-2)^2+0\\times (-2)^1 +1\\times (-2)^0$$\n\nDesign a program that reads a decimal integer and the base of a negative-base system, and converts the decimal number into that negative-base representation.", "inputFormat": "Each line of input contains two values.\n\nThe first is the decimal integer $n$. The second is the base $R$ of the negative-base numeral system.", "outputFormat": "Output the number in this negative-base system together with its base. If the absolute value of the base exceeds $10$, represent digits greater than $9$ using uppercase letters as in hexadecimal.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $-20 \\le R \\le -2$, $|n| \\le 37336$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2000 提高组] 进制转换", "background": "NOIP2000 提高组 T1", "description": "我们可以用这样的方式来表示一个十进制数：将每个阿拉伯数字乘以一个以该数字所处位置为指数，以 $10$ 为底数的幂之和的形式。例如 $123$ 可表示为 $1 \\times 10^2+2\\times 10^1+3\\times 10^0$ 这样的形式。\n\n与之相似的，对二进制数来说，也可表示成每个二进制数码乘以一个以该数字所处位置为指数，以 $2$ 为底数的幂之和的形式。  \n\n一般说来，任何一个正整数 $R$ 或一个负整数 $-R$ 都可以被选来作为一个数制系统的基数。如果是以 $R$ 或 $-R$ 为基数，则需要用到的数码为 $0,1,\\dots,R-1$。  \n\n例如当 $R=7$ 时,所需用到的数码是 $0,1,2,3,4,5,6$，这与其是 $R$ 或 $-R$ 无关。如果作为基数的数绝对值超过 $10$，则为了表示这些数码，通常使用英文字母来表示那些大于 $9$ 的数码。例如对 $16$ 进制数来说,用 $A$ 表示 $10$，用 $B$ 表示 $11$，用 $C$ 表示 $12$，以此类推。\n\n在负进制数中是用 $-R $ 作为基数，例如 $-15$（十进制）相当于 $(110001)_{-2}$（$-2$进制），并且它可以被表示为 $2$ 的幂级数的和数：\n\n$$(110001)_{-2}=1\\times (-2)^5+1\\times (-2)^4+0\\times (-2)^3+0\\times (-2)^2+0\\times (-2)^1 +1\\times (-2)^0$$\n\n设计一个程序，读入一个十进制数和一个负进制数的基数，并将此十进制数转换为此负进制下的数。", "inputFormat": "输入的每行有两个输入数据。\n\n第一个是十进制数 $n$。第二个是负进制数的基数 $R$。", "outputFormat": "输出此负进制数及其基数，若此基数的绝对值超过 $10$，则参照 $16$ 进制的方式处理。", "hint": "**数据范围**\n\n对于 $100\\%$ 的数据，$-20 \\le R \\le -2$，$|n| \\le 37336$。", "locale": "zh-CN"}}}
{"pid": "P1018", "type": "P", "difficulty": 4, "samples": [["4 2\n1231\n", "62"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "高精度", "2000", "NOIP 提高组", "线性 DP"], "title": "[NOIP 2000 提高组] 乘积最大", "background": "NOIP2000 提高组 T2", "description": "今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰 90 周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友 XZ 也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：\n\n\n设有一个长度为 $N$ 的数字串，要求选手使用 $K$ 个乘号将它分成 $K+1$ 个部分，找出一种分法，使得这 $K+1$ 个部分的乘积能够为最大。\n\n\n同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：\n\n\n有一个数字串：$312$，当 $N=3,K=1$ 时会有以下两种分法：\n\n1. $3  \\times  12=36$ \n2. $31  \\times   2=62$  \n\n   \n这时，符合题目要求的结果是：$31  \\times  2 = 62$。\n\n\n现在，请你帮助你的好朋友 XZ 设计一个程序，求得正确的答案。\n", "inputFormat": "程序的输入共有两行：\n\n第一行共有 $2$ 个自然数 $N,K$。\n\n第二行是一个长度为 $N$ 的数字串。\n", "outputFormat": "结果显示在屏幕上，相对于输入，应输出所求得的最大乘积（一个自然数）。\n", "hint": "**数据范围与约定**\n\n对于 $60\\%$ 的测试数据满足 $6≤N≤20$。  \n对于所有测试数据，$6≤N≤40,1≤K≤6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2000 Senior] Maximum Product", "background": null, "description": "The year 2000 was designated as the World Year of Mathematics by the International Mathematical Union, and it also marked the 90th birth anniversary of the renowned Chinese mathematician Hua Luogeng. In Jintan, Jiangsu, Hua Luogeng’s hometown, a special mathematics contest was held. Your good friend XZ participated, and the host posed the following problem:\n\nGiven a numeric string of length $N$, insert $K$ multiplication signs to split it into $K + 1$ parts. Find a way to split it so that the product of these $K + 1$ parts is maximized.\n\nTo help participants understand the problem, the host gave the following example:\n\nGiven the numeric string $312$, when $N = 3, K = 1$, there are two ways to split it:\n1. $3 \\times 12 = 36$.\n2. $31 \\times 2 = 62$.\n\nIn this case, the correct result is $31 \\times 2 = 62$.\n\nNow, please help your friend XZ write a program to compute the correct answer.", "inputFormat": "The input consists of two lines:\n- The first line contains two natural numbers $N, K$.\n- The second line contains a numeric string of length $N$.", "outputFormat": "Output the maximum product (a natural number) corresponding to the given input.", "hint": "Constraints\n- For $60\\%$ of the testdata: $6 \\le N \\le 20$.\n- For all testdata: $6 \\le N \\le 40$, $1 \\le K \\le 6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2000 提高组] 乘积最大", "background": "NOIP2000 提高组 T2", "description": "今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰 90 周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友 XZ 也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：\n\n\n设有一个长度为 $N$ 的数字串，要求选手使用 $K$ 个乘号将它分成 $K+1$ 个部分，找出一种分法，使得这 $K+1$ 个部分的乘积能够为最大。\n\n\n同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：\n\n\n有一个数字串：$312$，当 $N=3,K=1$ 时会有以下两种分法：\n\n1. $3  \\times  12=36$ \n2. $31  \\times   2=62$  \n\n   \n这时，符合题目要求的结果是：$31  \\times  2 = 62$。\n\n\n现在，请你帮助你的好朋友 XZ 设计一个程序，求得正确的答案。\n", "inputFormat": "程序的输入共有两行：\n\n第一行共有 $2$ 个自然数 $N,K$。\n\n第二行是一个长度为 $N$ 的数字串。\n", "outputFormat": "结果显示在屏幕上，相对于输入，应输出所求得的最大乘积（一个自然数）。\n", "hint": "**数据范围与约定**\n\n对于 $60\\%$ 的测试数据满足 $6≤N≤20$。  \n对于所有测试数据，$6≤N≤40,1≤K≤6$。\n", "locale": "zh-CN"}}}
{"pid": "P1019", "type": "P", "difficulty": 3, "samples": [["5\nat\ntouch\ncheat\nchoose\ntact\na\n", "23\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "搜索", "2000", "NOIP 提高组"], "title": "[NOIP 2000 提高组] 单词接龙（疑似错题）", "background": "注意：本题为上古 NOIP 原题，不保证存在靠谱的做法能通过该数据范围下的所有数据。本题的难度仅代表设计算法可以通过本题原始数据的难度。\n\n本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)\n\nNOIP2000 提高组 T3", "description": "单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 `beast` 和 `astonish`，如果接成一条龙则变为 `beastonish`，另外相邻的两部分不能存在包含关系，例如 `at` 和 `atide` 间不能相连。", "inputFormat": "输入的第一行为一个单独的整数 $n$ 表示单词数，以下 $n$ 行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在。", "outputFormat": "只需输出以此字母开头的最长的“龙”的长度。", "hint": "样例解释：连成的“龙”为 `atoucheatactactouchoose`。\n\n$n \\le 20$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2000 Senior] Word Chain (suspected erroneous problem)", "background": null, "description": "Word chain is a game similar to the idiom chain we often play. We are given a set of words and a starting letter, and we are asked to find the longest \"dragon\" that starts with this letter. Each word may appear at most twice in the \"dragon\".\n\nWhen two consecutive words are connected, their overlapping part is merged into one. For example, `beast` and `astonish` become `beastonish` when chained. Moreover, the two adjacent parts must not have a containment relationship; for example, `at` and `atide` cannot be connected.", "inputFormat": "The first line contains a single integer $n$, the number of words. Each of the next $n$ lines contains one word. The last line contains a single character, which is the starting letter of the \"dragon\". You can assume that a \"dragon\" starting with this letter always exists.", "outputFormat": "Output only the length of the longest \"dragon\" that starts with this letter.", "hint": "Sample explanation: the resulting \"dragon\" is `atoucheatactactouchoose`.\n\nConstraints: $n \\le 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2000 提高组] 单词接龙（疑似错题）", "background": "注意：本题为上古 NOIP 原题，不保证存在靠谱的做法能通过该数据范围下的所有数据。本题的难度仅代表设计算法可以通过本题原始数据的难度。\n\n本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)\n\nNOIP2000 提高组 T3", "description": "单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 `beast` 和 `astonish`，如果接成一条龙则变为 `beastonish`，另外相邻的两部分不能存在包含关系，例如 `at` 和 `atide` 间不能相连。", "inputFormat": "输入的第一行为一个单独的整数 $n$ 表示单词数，以下 $n$ 行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在。", "outputFormat": "只需输出以此字母开头的最长的“龙”的长度。", "hint": "样例解释：连成的“龙”为 `atoucheatactactouchoose`。\n\n$n \\le 20$。", "locale": "zh-CN"}}}
{"pid": "P1020", "type": "P", "difficulty": 4, "samples": [["389 207 155 300 299 170 158 65", "6\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "贪心", "1999", "线段树", "二分", "树状数组", "离散化", "NOIP 提高组", "Special Judge", "Dilworth 定理", "线性 DP"], "title": "[NOIP 1999 提高组] 导弹拦截", "background": "", "description": "某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。\n\n   \n输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。", "inputFormat": "一行，若干个整数，中间由空格隔开。", "outputFormat": "两行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。", "hint": "对于前 $50\\%$ 数据，满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用 $\\mathcal O(n^2)$ 做法通过。  \n对于后 $50\\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\\mathcal O(n\\log n)$ 做法通过。\n\n对于全部数据，满足导弹的高度为正整数，且不超过 $5\\times 10^4$。\n\n\n此外本题开启 spj，每点两问，按问给分。\n\nNOIP1999 提高组 第一题\n\n---\n\n$\\text{upd 2022.8.24}$：新增加一组 Hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 1999 Senior] Missile Interception", "background": null, "description": "To defend against enemy missile attacks, a country developed a missile interception system. However, this system has a flaw: although the first shell can reach any height, each subsequent shell cannot be higher than the previous one. One day, the radar detected incoming enemy missiles. Since the system is still in the trial phase, there is only one set available, so it might not be able to intercept all missiles.\n\nGiven the heights of the incoming missiles in order, compute the maximum number of missiles this system can intercept, and the minimum number of such missile interception systems needed to intercept all missiles.", "inputFormat": "One line containing several integers separated by spaces.", "outputFormat": "Two lines, one integer per line. The first number is the maximum number of missiles this single system can intercept. The second number is the minimum number of such systems required to intercept all missiles.", "hint": "For the first $50\\%$ of the testdata (NOIP original testdata), the number of missiles does not exceed $10^4$. This part contributes $100$ points in total. An $\\mathcal O(n^2)$ algorithm can pass.  \nFor the remaining $50\\%$ of the testdata, the number of missiles does not exceed $10^5$. This part also contributes $100$ points in total. Please use an $\\mathcal O(n \\log n)$ algorithm to pass.\n\nFor all testdata, missile heights are positive integers not exceeding $5 \\times 10^4$.\n\nIn addition, this problem enables SPJ; there are two sub-questions per test point, and scoring is per sub-question.\n\nNOIP 1999 Senior Problem 1.\n\n---\n\n$\\text{upd 2022.8.24}$：A new hack testdata has been added.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 1999 提高组] 导弹拦截", "background": "", "description": "某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。\n\n   \n输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。", "inputFormat": "一行，若干个整数，中间由空格隔开。", "outputFormat": "两行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。", "hint": "对于前 $50\\%$ 数据，满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用 $\\mathcal O(n^2)$ 做法通过。  \n对于后 $50\\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\\mathcal O(n\\log n)$ 做法通过。\n\n对于全部数据，满足导弹的高度为正整数，且不超过 $5\\times 10^4$。\n\n\n此外本题开启 spj，每点两问，按问给分。\n\nNOIP1999 提高组 第一题\n\n---\n\n$\\text{upd 2022.8.24}$：新增加一组 Hack 数据。", "locale": "zh-CN"}}}
{"pid": "P1021", "type": "P", "difficulty": 4, "samples": [["3 2\n", "1 3\nMAX=7\n"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "1999", "NOIP 提高组", "背包 DP"], "title": "[NOIP 1999 提高组] 邮票面值设计（疑似错题）", "background": "除直接打表外，本题不保证存在**正确且时间复杂度可以通过全部数据**做法。由于测试数据过水，部分错误做法可以通过此题，通过不代表做法正确。本题不接受 hack 数据。\n\n[关于此类题目的详细内容。](https://www.luogu.com.cn/paste/pf94n89x)", "description": "给定一个信封，最多只允许粘贴 $N$ 张邮票，计算在给定 $K$（$N+K \\le 15$）种邮票的情况下（假定所有的邮票数量都足够），如何设计邮票的面值，能得到最大值 $\\mathsf{MAX}$，使在 $1$ 至 $\\mathsf{MAX}$ 之间的每一个邮资值都能得到。\n\n例如，$N=3$，$K=2$，如果面值分别为 $1$ 分、$4$ 分，则在 $1\\sim 6$ 分之间的每一个邮资值都能得到（当然还有 $8$ 分、$9$ 分和 $12$ 分）；如果面值分别为 $1$ 分、$3$ 分，则在 $1\\sim 7$ 分之间的每一个邮资值都能得到。可以验证当 $N=3$，$K=2$ 时，$7$ 分就是可以得到的连续的邮资最大值，所以 $\\mathsf{MAX}=7$，面值分别为 $1$ 分、$3$ 分。", "inputFormat": "$2$ 个整数，代表 $N$，$K$。", "outputFormat": "输出共 $2$ 行。\n\n第一行输出若干个数字，表示选择的面值，从小到大排序。\n\n第二行，输出 `MAX=S`，$S$ 表示最大的面值。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 1999 Senior] Stamp Denomination Design (suspected wrong problem)", "background": null, "description": "Given an envelope on which at most $N$ stamps may be affixed, determine, for given $K$ types of stamps (with $N+K \\le 15$ and assuming an unlimited supply of each type), how to design the stamp denominations to obtain the largest value $\\mathsf{MAX}$ such that every postage value from $1$ to $\\mathsf{MAX}$ can be formed.\n\nFor example, when $N=3$, $K=2$: if the denominations are $1$ fen and $4$ fen, then every postage value between $1\\sim 6$ can be formed (and, of course, also $8$, $9$, and $12$); if the denominations are $1$ fen and $3$ fen, then every postage value between $1\\sim 7$ can be formed. One can verify that when $N=3$ and $K=2$, $7$ is the largest consecutive postage value that can be obtained, so $\\mathsf{MAX}=7$, with denominations $1$ fen and $3$ fen.", "inputFormat": "Two integers, representing $N$ and $K$.", "outputFormat": "Output a total of $2$ lines.\n\nOn the first line, output the chosen denominations in ascending order.\n\nOn the second line, output `MAX=S`, where $S$ denotes the maximum consecutive postage value.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 1999 提高组] 邮票面值设计（疑似错题）", "background": "除直接打表外，本题不保证存在**正确且时间复杂度可以通过全部数据**做法。由于测试数据过水，部分错误做法可以通过此题，通过不代表做法正确。本题不接受 hack 数据。\n\n[关于此类题目的详细内容。](https://www.luogu.com.cn/paste/pf94n89x)", "description": "给定一个信封，最多只允许粘贴 $N$ 张邮票，计算在给定 $K$（$N+K \\le 15$）种邮票的情况下（假定所有的邮票数量都足够），如何设计邮票的面值，能得到最大值 $\\mathsf{MAX}$，使在 $1$ 至 $\\mathsf{MAX}$ 之间的每一个邮资值都能得到。\n\n例如，$N=3$，$K=2$，如果面值分别为 $1$ 分、$4$ 分，则在 $1\\sim 6$ 分之间的每一个邮资值都能得到（当然还有 $8$ 分、$9$ 分和 $12$ 分）；如果面值分别为 $1$ 分、$3$ 分，则在 $1\\sim 7$ 分之间的每一个邮资值都能得到。可以验证当 $N=3$，$K=2$ 时，$7$ 分就是可以得到的连续的邮资最大值，所以 $\\mathsf{MAX}=7$，面值分别为 $1$ 分、$3$ 分。", "inputFormat": "$2$ 个整数，代表 $N$，$K$。", "outputFormat": "输出共 $2$ 行。\n\n第一行输出若干个数字，表示选择的面值，从小到大排序。\n\n第二行，输出 `MAX=S`，$S$ 表示最大的面值。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1022", "type": "P", "difficulty": 3, "samples": [["6a-5+1=2-2a\n", "a=0.750"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "数学", "2000", "NOIP 普及组"], "title": "[NOIP 2000 普及组] 计算器的改良", "background": "NCL 是一家专门从事计算器改良与升级的实验室，最近该实验室收到了某公司所委托的一个任务：需要在该公司某型号的计算器上加上解一元一次方程的功能。实验室将这个任务交给了一个刚进入的新手 ZL 先生。\n", "description": "为了很好的完成这个任务，ZL 先生首先研究了一些一元一次方程的实例：\n\n- $4+3x=8$。\n- $6a-5+1=2-2a$。\n- $-5+12y=0$。\n\nZL 先生被主管告之，在计算器上键入的一个一元一次方程中，只包含整数、小写字母及 `+`、`-`、`=` 这三个数学符号（当然，符号“`-`”既可作减号，也可作负号）。方程中并没有括号，也没有除号，方程中的字母表示未知数。\n\n你可假设对键入的方程的正确性的判断是由另一个程序员在做，或者说可认为键入的一元一次方程均为合法的，且有唯一实数解。\n", "inputFormat": "一个一元一次方程。\n", "outputFormat": "解方程的结果（精确至小数点后三位）。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2000 Junior] Improvement of the Calculator", "background": null, "description": "To accomplish this task well, Mr. ZL first studied some examples of linear equations in one variable:\n\n- $4+3x=8$.\n- $6a-5+1=2-2a$.\n- $-5+12y=0$.\n\nMr. ZL was told by his supervisor that a linear equation in one variable entered into the calculator contains only integers, lowercase letters, and the three mathematical symbols `+`, `-`, `=` (of course, the symbol `-` can be either a subtraction sign or a unary minus). The equation has no parentheses and no division operator. The letters in the equation denote the unknown.\n\nYou may assume that the correctness of the entered equation is verified by another programmer; in other words, every entered linear equation in one variable is valid and has a unique real solution.", "inputFormat": "A linear equation in one variable.", "outputFormat": "The solution of the equation (rounded to three decimal places).", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2000 普及组] 计算器的改良", "background": "NCL 是一家专门从事计算器改良与升级的实验室，最近该实验室收到了某公司所委托的一个任务：需要在该公司某型号的计算器上加上解一元一次方程的功能。实验室将这个任务交给了一个刚进入的新手 ZL 先生。\n", "description": "为了很好的完成这个任务，ZL 先生首先研究了一些一元一次方程的实例：\n\n- $4+3x=8$。\n- $6a-5+1=2-2a$。\n- $-5+12y=0$。\n\nZL 先生被主管告之，在计算器上键入的一个一元一次方程中，只包含整数、小写字母及 `+`、`-`、`=` 这三个数学符号（当然，符号“`-`”既可作减号，也可作负号）。方程中并没有括号，也没有除号，方程中的字母表示未知数。\n\n你可假设对键入的方程的正确性的判断是由另一个程序员在做，或者说可认为键入的一元一次方程均为合法的，且有唯一实数解。\n", "inputFormat": "一个一元一次方程。\n", "outputFormat": "解方程的结果（精确至小数点后三位）。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1023", "type": "P", "difficulty": 3, "samples": [["31\n28 130\n30 120\n31 110\n-1  -1\n15", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000]}, "tags": ["数学", "2000", "NOIP 普及组", "枚举"], "title": "[NOIP 2000 普及组] 税收与补贴问题", "background": "每样商品的价格越低，其销量就会相应增大。现已知某种商品的成本及其在若干价位上的销量（产品不会低于成本销售），并假设相邻价位间销量的变化是线性的且在价格高于给定的最高价位后，销量以某固定数值递减。（我们假设价格及销售量都是整数）\n\n对于某些特殊商品，不可能完全由市场去调节其价格。这时候就需要政府以税收或补贴的方式来控制。（所谓税收或补贴就是对于每个产品收取或给予生产厂家固定金额的货币）\n", "description": "你是某家咨询公司的项目经理，现在你已经知道政府对某种商品的预期价格，以及在各种价位上的销售情况。要求你确定政府对此商品是应收税还是补贴的最少金额（也为整数），才能使商家在这样一种政府预期的价格上，获取相对其他价位上的最大总利润。\n\n- 总利润 $=$ 单位商品利润 $\\times$ 销量\n- 单位商品利润 $=$ 单位商品价格 $-$ 单位商品成本（减去税金 或者 加上补贴）\n", "inputFormat": "输入的第一行为政府对某种商品的预期价；\n\n 第二行有两个整数，第一个整数为商品成本，第二个整数为以成本价销售时的销售量；\n \n 接下来若干行，每行都有两个整数，第一个为某价位时的单价，第二个为此时的销量，以一行 `-1 -1` 表示所有已知价位及对应的销量输入完毕；\n \n 输入的最后一行为一个单独的整数表示在已知的最高单价外每升高一块钱将减少的销量。\n", "outputFormat": "输出有两种情况：若在政府预期价上能得到最大总利润，则输出一个单独的整数，数的正负表示是补贴还是收税，数的大小表示补贴或收税的金额最小值。若有多解，取绝对值最小的输出。\n\n如在政府预期价上不能得到最大总利润，则输出 `NO SOLUTION`。\n", "hint": "### 数据范围及约定\n\n保证输入的所有数字均小于 $10^5$。\n\n### 样例解释（2023/6/22 更新）\n\n如下图所示是输入样例所对应的价格变化图，横轴表示销售价格，纵轴表示销量。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/21mhtm5i.png)\n\n根据题意，$28$ 元是商品的成本。销售价格不应该低于 $28$ 元；当销售价格大于给出的价格的最大值 $31$ 元后，按照售价每提高一元，销量降低 $15$ 计算，例如当售价为 $33$ 元时，销量为 $110-15\\times (33-31)=80$。在给出来的价位之间，销量呈线性变化。\n\n当政府给该商品补贴 $4$ 元后，企业将该商品定价为 $31$ 元时，取得的利润为 $31-28+4=7$ 元，销量为 $110$ 件，总利润为 $7\\times 110=770$ 元，是企业在所有定价下能够取得的最大的总利润。此时企业的售价为政府的期望售价，因此是一个合法方案。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2000 Junior] Taxation and Subsidy Problem", "background": null, "description": "You are a project manager at a consulting firm. You already know the government's expected price for a certain product, as well as its sales at various price points. You are required to determine the minimum amount (also an integer) of tax to collect or subsidy to grant on this product so that, at the government's expected price, the seller achieves the maximum total profit compared with all other price points.\n\n- Total profit $=$ profit per unit $\\times$ sales.\n- Profit per unit $=$ unit price $-$ unit cost (minus tax or plus subsidy).", "inputFormat": "- The first line is the government's expected price for the product.\n- The second line contains two integers: the first is the product's cost, and the second is the sales volume when sold at cost price.\n- Then follow several lines, each containing two integers: the first is the unit price at some price point, and the second is the sales volume at that price. A line `-1 -1` indicates that all known price points and their corresponding sales have been entered.\n- The last line contains a single integer indicating the decrease in sales for each 1 yuan increase in price beyond the highest known unit price.", "outputFormat": "There are two cases:\n- If the maximum total profit can be achieved at the government's expected price, output a single integer. Its sign indicates whether it is a subsidy or a tax, and its absolute value is the minimum amount. If there are multiple solutions, output the one with the smallest absolute value.\n- If the maximum total profit cannot be achieved at the government's expected price, output `NO SOLUTION`.", "hint": "### Constraints and Conventions\n\nAll input numbers are less than $10^5$.\n\n### Sample Explanation (updated on 2023/6/22)\n\nThe following figure shows the price–sales curve corresponding to the sample input. The horizontal axis represents the selling price, and the vertical axis represents the sales volume.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/21mhtm5i.png)\n\nAccording to the problem statement, the cost is $28$ yuan. The selling price should not be lower than $28$ yuan. When the selling price exceeds the maximum given price $31$ yuan, the sales decrease by $15$ for each 1 yuan increase in price. For example, when the selling price is $33$ yuan, the sales are $110-15\\times (33-31)=80$. Between the given price points, the sales change linearly.\n\nWhen the government provides a subsidy of $4$ yuan for this product and the firm sets the price at $31$ yuan, the profit is $31-28+4=7$ yuan per unit, the sales are $110$ units, and the total profit is $7\\times 110=770$ yuan, which is the maximum total profit the firm can obtain among all pricing choices. In this case, the firm's selling price matches the government's expected price, so this is a valid solution.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2000 普及组] 税收与补贴问题", "background": "每样商品的价格越低，其销量就会相应增大。现已知某种商品的成本及其在若干价位上的销量（产品不会低于成本销售），并假设相邻价位间销量的变化是线性的且在价格高于给定的最高价位后，销量以某固定数值递减。（我们假设价格及销售量都是整数）\n\n对于某些特殊商品，不可能完全由市场去调节其价格。这时候就需要政府以税收或补贴的方式来控制。（所谓税收或补贴就是对于每个产品收取或给予生产厂家固定金额的货币）\n", "description": "你是某家咨询公司的项目经理，现在你已经知道政府对某种商品的预期价格，以及在各种价位上的销售情况。要求你确定政府对此商品是应收税还是补贴的最少金额（也为整数），才能使商家在这样一种政府预期的价格上，获取相对其他价位上的最大总利润。\n\n- 总利润 $=$ 单位商品利润 $\\times$ 销量\n- 单位商品利润 $=$ 单位商品价格 $-$ 单位商品成本（减去税金 或者 加上补贴）\n", "inputFormat": "输入的第一行为政府对某种商品的预期价；\n\n 第二行有两个整数，第一个整数为商品成本，第二个整数为以成本价销售时的销售量；\n \n 接下来若干行，每行都有两个整数，第一个为某价位时的单价，第二个为此时的销量，以一行 `-1 -1` 表示所有已知价位及对应的销量输入完毕；\n \n 输入的最后一行为一个单独的整数表示在已知的最高单价外每升高一块钱将减少的销量。\n", "outputFormat": "输出有两种情况：若在政府预期价上能得到最大总利润，则输出一个单独的整数，数的正负表示是补贴还是收税，数的大小表示补贴或收税的金额最小值。若有多解，取绝对值最小的输出。\n\n如在政府预期价上不能得到最大总利润，则输出 `NO SOLUTION`。\n", "hint": "### 数据范围及约定\n\n保证输入的所有数字均小于 $10^5$。\n\n### 样例解释（2023/6/22 更新）\n\n如下图所示是输入样例所对应的价格变化图，横轴表示销售价格，纵轴表示销量。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/21mhtm5i.png)\n\n根据题意，$28$ 元是商品的成本。销售价格不应该低于 $28$ 元；当销售价格大于给出的价格的最大值 $31$ 元后，按照售价每提高一元，销量降低 $15$ 计算，例如当售价为 $33$ 元时，销量为 $110-15\\times (33-31)=80$。在给出来的价位之间，销量呈线性变化。\n\n当政府给该商品补贴 $4$ 元后，企业将该商品定价为 $31$ 元时，取得的利润为 $31-28+4=7$ 元，销量为 $110$ 件，总利润为 $7\\times 110=770$ 元，是企业在所有定价下能够取得的最大的总利润。此时企业的售价为政府的期望售价，因此是一个合法方案。", "locale": "zh-CN"}}}
{"pid": "P1024", "type": "P", "difficulty": 2, "samples": [["1 -5 -4 20\n", "-2.00 2.00 5.00\n"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000]}, "tags": ["数学", "2001", "二分", "NOIP 提高组", "枚举", "分治"], "title": "[NOIP 2001 提高组] 一元三次方程求解", "background": "", "description": "有形如：$a x^3 + b x^2 + c x + d = 0$  这样的一个一元三次方程。给出该方程中各项的系数（$a,b,c,d$ 均为实数），并约定该方程存在三个不同实根（根的范围在 $-100$ 至 $100$ 之间），且根与根之差的绝对值 $\\ge 1$。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 $2$ 位。\n\n提示：记方程 $f(x) = 0$，若存在 $2$ 个数 $x_1$ 和 $x_2$，且 $x_1 < x_2$，$f(x_1) \\times f(x_2) < 0$，则在 $(x_1, x_2)$ 之间一定有一个根。", "inputFormat": "一行，$4$ 个实数 $a, b, c, d$。", "outputFormat": "一行，$3$ 个实根，从小到大输出，并精确到小数点后 $2$ 位。", "hint": "**【题目来源】**\n\nNOIP 2001 提高组第一题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2001 Senior] Solving a Univariate Cubic Equation", "background": null, "description": "Given a cubic equation of the form $a x^3 + b x^2 + c x + d = 0$. You are given the coefficients of the equation (where $a, b, c, d$ are real numbers). It is guaranteed that the equation has three distinct real roots, the roots lie in the range $-100$ to $100$, and the absolute difference between any two roots is $\\ge 1$. Output the three real roots in increasing order on a single line (separated by spaces), each to exactly 2 decimal places.\n\nHint: Let the equation be $f(x) = 0$. If there exist two numbers $x_1$ and $x_2$ with $x_1 < x_2$ and $f(x_1) \\times f(x_2) < 0$, then there is a root in the interval $(x_1, x_2)$.", "inputFormat": "One line containing $4$ real numbers $a, b, c, d$.", "outputFormat": "One line containing $3$ real roots in increasing order, each to exactly $2$ decimal places.", "hint": "- If $x_1 < x_2$ and $f(x_1) \\times f(x_2) < 0$, then there is a root in $(x_1, x_2)$.\n- Source: NOIP 2001 Senior, Problem 1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2001 提高组] 一元三次方程求解", "background": "", "description": "有形如：$a x^3 + b x^2 + c x + d = 0$  这样的一个一元三次方程。给出该方程中各项的系数（$a,b,c,d$ 均为实数），并约定该方程存在三个不同实根（根的范围在 $-100$ 至 $100$ 之间），且根与根之差的绝对值 $\\ge 1$。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 $2$ 位。\n\n提示：记方程 $f(x) = 0$，若存在 $2$ 个数 $x_1$ 和 $x_2$，且 $x_1 < x_2$，$f(x_1) \\times f(x_2) < 0$，则在 $(x_1, x_2)$ 之间一定有一个根。", "inputFormat": "一行，$4$ 个实数 $a, b, c, d$。", "outputFormat": "一行，$3$ 个实根，从小到大输出，并精确到小数点后 $2$ 位。", "hint": "**【题目来源】**\n\nNOIP 2001 提高组第一题", "locale": "zh-CN"}}}
{"pid": "P1025", "type": "P", "difficulty": 3, "samples": [["7 3\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "递推", "2001", "NOIP 提高组", "剪枝"], "title": "[NOIP 2001 提高组] 数的划分", "background": null, "description": "将整数 $n$ 分成 $k$ 份，且每份不能为空，任意两个方案不相同（不考虑顺序）。\n\n例如：$n=7$，$k=3$，下面三种分法被认为是相同的。\n\n$1,1,5$；   \n$1,5,1$；   \n$5,1,1$。\n\n问有多少种不同的分法。", "inputFormat": "$n,k$（$6<n \\le 200,2  \\le k  \\le  6$）。", "outputFormat": "$1$ 个整数，即不同的分法。", "hint": "四种分法为：  \n$1,1,5$；  \n$1,2,4$；  \n$1,3,3$；  \n$2,2,3$。\n\n**【题目来源】**\n\nNOIP 2001 提高组第二题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2001 Senior] Integer Partition", "background": null, "description": "Partition the integer $n$ into $k$ non-empty parts, and regard two partitions as the same if they differ only in order.\n\nFor example, when $n=7$, $k=3$, the following three partitions are considered the same:\n$1, 1, 5$;  \n$1, 5, 1$;  \n$5, 1, 1$.\n\nHow many different partitions are there?", "inputFormat": "Two integers $n$ and $k$.\n\nConstraints: $6 < n \\le 200$, $2 \\le k \\le 6$.", "outputFormat": "One integer: the number of different partitions.", "hint": "There are four partitions when $n=7$, $k=3$:  \n$1, 1, 5$;  \n$1, 2, 4$;  \n$1, 3, 3$;  \n$2, 2, 3$.\n\nProblem Source: NOIP 2001 Senior, Problem 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2001 提高组] 数的划分", "background": null, "description": "将整数 $n$ 分成 $k$ 份，且每份不能为空，任意两个方案不相同（不考虑顺序）。\n\n例如：$n=7$，$k=3$，下面三种分法被认为是相同的。\n\n$1,1,5$；   \n$1,5,1$；   \n$5,1,1$。\n\n问有多少种不同的分法。", "inputFormat": "$n,k$（$6<n \\le 200,2  \\le k  \\le  6$）。", "outputFormat": "$1$ 个整数，即不同的分法。", "hint": "四种分法为：  \n$1,1,5$；  \n$1,2,4$；  \n$1,3,3$；  \n$2,2,3$。\n\n**【题目来源】**\n\nNOIP 2001 提高组第二题", "locale": "zh-CN"}}}
{"pid": "P1026", "type": "P", "difficulty": 4, "samples": [["1 3\nthisisabookyouareaoh\n4\nis\na\nok\nsab\n", "7\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "动态规划 DP", "2001", "NOIP 提高组", "枚举", "区间 DP"], "title": "[NOIP 2001 提高组] 统计单词个数", "background": null, "description": "给出一个长度不超过 $200$ 的由小写英文字母组成的字母串（该字串以每行 $20$ 个字母的方式输入，且保证每行一定为 $20$ 个）。要求将此字母串分成\n $k$ 份，且每份中包含的单词个数加起来总数最大。  \n\n每份中包含的单词可以部分重叠。当选用一个单词之后，其第一个字母不能再用。例如字符串 `this` 中可包含 `this` 和 `is`，选用 `this` 之后就不能包含\n `th`。\n\n单词在给出的一个不超过 $6$ 个单词的字典中。\n\n要求输出最大的个数。", "inputFormat": "每组的第一行有两个正整数 $p,k$。\n$p$ 表示字串的行数，$k$ 表示分为 $k$ 个部分。\n\n接下来的 $p$ 行，每行均有 $20$ 个字符。\n\n再接下来有一个正整数 $s$，表示字典中单词个数。\n接下来的 $s$ 行，每行均有一个单词。", "outputFormat": "$1$个整数，分别对应每组测试数据的相应结果。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$2 \\le k \\le 40$，$1 \\le s \\le 6$。\n\n**【样例解释】**\n\n划分方案为 this / isabookyoua / reaoh\n\n**【题目来源】**\n\nNOIP 2001 提高组第三题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2001 Senior] Count the Number of Words", "background": null, "description": "You are given a string of lowercase English letters with length at most $200$ (the string is provided as $20$ letters per line, and each line has exactly $20$ letters). You must split this string into $k$ contiguous parts so that the total number of words contained in all parts is maximized.\n\nWords in a part may partially overlap. After selecting one word, its first letter cannot be used again. For example, the string `this` can contain both `this` and `is`, but if `this` is selected, then `th` cannot be included.\n\nThe set of words comes from a given dictionary of at most $6$ words.\n\nOutput the maximum count.", "inputFormat": "The input consists of multiple test cases. For each test case:\n- The first line contains two positive integers $p, k$. Here $p$ is the number of lines of the string, and $k$ is the number of parts to split into.\n- The next $p$ lines each contain exactly $20$ characters.\n- The next line contains a positive integer $s$, the number of dictionary words.\n- The next $s$ lines each contain one word.", "outputFormat": "For each test case, output one integer: the corresponding result.", "hint": "- Constraints: For $100\\%$ of the testdata, $2 \\le k \\le 40$, $1 \\le s \\le 6$.\n- Sample explanation: A valid partition is `this` / `isabookyoua` / `reaoh`.\n- Source: NOIP 2001 Senior, Problem 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2001 提高组] 统计单词个数", "background": null, "description": "给出一个长度不超过 $200$ 的由小写英文字母组成的字母串（该字串以每行 $20$ 个字母的方式输入，且保证每行一定为 $20$ 个）。要求将此字母串分成\n $k$ 份，且每份中包含的单词个数加起来总数最大。  \n\n每份中包含的单词可以部分重叠。当选用一个单词之后，其第一个字母不能再用。例如字符串 `this` 中可包含 `this` 和 `is`，选用 `this` 之后就不能包含\n `th`。\n\n单词在给出的一个不超过 $6$ 个单词的字典中。\n\n要求输出最大的个数。", "inputFormat": "每组的第一行有两个正整数 $p,k$。\n$p$ 表示字串的行数，$k$ 表示分为 $k$ 个部分。\n\n接下来的 $p$ 行，每行均有 $20$ 个字符。\n\n再接下来有一个正整数 $s$，表示字典中单词个数。\n接下来的 $s$ 行，每行均有一个单词。", "outputFormat": "$1$个整数，分别对应每组测试数据的相应结果。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$2 \\le k \\le 40$，$1 \\le s \\le 6$。\n\n**【样例解释】**\n\n划分方案为 this / isabookyoua / reaoh\n\n**【题目来源】**\n\nNOIP 2001 提高组第三题", "locale": "zh-CN"}}}
{"pid": "P1027", "type": "P", "difficulty": 4, "samples": [["1\n3 10 1 3\n1 1 1 3 3 1 30\n2 5 7 4 5 2 1\n8 6 8 8 11 6 3", "47.5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "计算几何", "2001", "NOIP 提高组", "最短路"], "title": "[NOIP 2001 提高组] Car 的旅行路线", "background": null, "description": "又到暑假了，住在城市 A 的 Car 想和朋友一起去城市旅游。  \n她知道每个城市都有 $4$ 个飞机场，分别位于一个矩形的 $4$ 个顶点上，同一个城市中两个机场之间有一条笔直的高速铁路，第 $i$ 个城市中高速铁路的单位里程价格为 $T_i$，任意两个不同城市的机场之间均有航线，所有航线单位里程的价格均为 $t$。\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/odqxn9sz.png)\n\n**注意**：图中并没有标出所有的铁路与航线。\n\n\n那么 Car 应如何安排到城市 B 的路线才能尽可能的节省花费呢？她发现这并不是一个简单的问题，于是她来向你请教。\n\n\n找出一条从城市 A 到 B 的旅游路线，出发和到达城市中的机场可以任意选取，要求总的花费最少。", "inputFormat": "第一行为一个正整数 $n$，表示有 $n$ 组测试数据。\n\n每组的第一行有 $4$ 个正整数 $S,t,A,B$。\n\n$S$ 表示城市的个数，$t$ 表示飞机单位里程的价格，$A$，$B$ 分别为城市A，B 的序号。\n\n接下来有 $S$ 行，其中第 $i$ 行均有 $7$ 个正整数$x_{i1},y_{i1},x_{i2},y_{i2},x_{i3},y_{i3},T_i$，这当中的 $(x_{i1},y_{i1}), (x_{i2},y_{i2}), (x_{i3},y_{i3})$，分别是第 $i$ 个城市中任意 $3$ 个机场的坐标，$T_i$ 为第 $i$ 个城市高速铁路单位里程的价格。", "outputFormat": "共有 $n$ 行，每行 $1$ 个数据对应测试数据。  \n保留一位小数。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 10$，$1\\le S \\le 100$，$1\\le A,B \\le S$，$0\\leq t,x_{i1},y_{i1},x_{i2},y_{i2},x_{i3},y_{i3},T_i\\leq 500$。\n\n**【题目来源】**\n\nNOIP 2001 提高组第四题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2001 Senior] Car's Travel Route", "background": null, "description": "It is summer vacation again. Car, who lives in city A, wants to travel with her friends.  \nShe knows that each city has $4$ airports located at the $4$ vertices of a rectangle. Between any two airports within the same city, there is a straight high-speed railway; in the $i$-th city, the unit distance cost of the high-speed railway is $T_i$. Between any two airports in different cities, there is a flight route, and the unit distance cost of all flight routes is $t$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/odqxn9sz.png)\n\nNote: The figure does not show all railways and flight routes.\n\nHow should Car plan her route to city B to minimize the expense? She finds this is not a simple problem and asks you for help.\n\nFind a travel route from city A to city B. The departure and arrival airports within their respective cities can be chosen arbitrarily. Minimize the total cost.", "inputFormat": "The first line contains a positive integer $n$, the number of test cases.\n\nFor each test case:\n- The first line contains $4$ positive integers $S, t, A, B$.\n  - $S$ is the number of cities.\n  - $t$ is the unit distance cost for flights.\n  - $A$ and $B$ are the indices of city A and city B, respectively.\n- The next $S$ lines each contain $7$ positive integers $x_{i1}, y_{i1}, x_{i2}, y_{i2}, x_{i3}, y_{i3}, T_i$. Here $(x_{i1}, y_{i1})$, $(x_{i2}, y_{i2})$, and $(x_{i3}, y_{i3})$ are the coordinates of any $3$ airports in the $i$-th city, and $T_i$ is the unit distance cost of the high-speed railway in the $i$-th city.", "outputFormat": "Output $n$ lines, one value per test case.  \nRound to one decimal place.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n \\le 10$, $1 \\le S \\le 100$, $1 \\le A, B \\le S$, $0 \\le t, x_{i1}, y_{i1}, x_{i2}, y_{i2}, x_{i3}, y_{i3}, T_i \\le 500$.\n\nSource  \nNOIP 2001 Senior, Problem 4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2001 提高组] Car 的旅行路线", "background": null, "description": "又到暑假了，住在城市 A 的 Car 想和朋友一起去城市旅游。  \n她知道每个城市都有 $4$ 个飞机场，分别位于一个矩形的 $4$ 个顶点上，同一个城市中两个机场之间有一条笔直的高速铁路，第 $i$ 个城市中高速铁路的单位里程价格为 $T_i$，任意两个不同城市的机场之间均有航线，所有航线单位里程的价格均为 $t$。\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/odqxn9sz.png)\n\n**注意**：图中并没有标出所有的铁路与航线。\n\n\n那么 Car 应如何安排到城市 B 的路线才能尽可能的节省花费呢？她发现这并不是一个简单的问题，于是她来向你请教。\n\n\n找出一条从城市 A 到 B 的旅游路线，出发和到达城市中的机场可以任意选取，要求总的花费最少。", "inputFormat": "第一行为一个正整数 $n$，表示有 $n$ 组测试数据。\n\n每组的第一行有 $4$ 个正整数 $S,t,A,B$。\n\n$S$ 表示城市的个数，$t$ 表示飞机单位里程的价格，$A$，$B$ 分别为城市A，B 的序号。\n\n接下来有 $S$ 行，其中第 $i$ 行均有 $7$ 个正整数$x_{i1},y_{i1},x_{i2},y_{i2},x_{i3},y_{i3},T_i$，这当中的 $(x_{i1},y_{i1}), (x_{i2},y_{i2}), (x_{i3},y_{i3})$，分别是第 $i$ 个城市中任意 $3$ 个机场的坐标，$T_i$ 为第 $i$ 个城市高速铁路单位里程的价格。", "outputFormat": "共有 $n$ 行，每行 $1$ 个数据对应测试数据。  \n保留一位小数。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 10$，$1\\le S \\le 100$，$1\\le A,B \\le S$，$0\\leq t,x_{i1},y_{i1},x_{i2},y_{i2},x_{i3},y_{i3},T_i\\leq 500$。\n\n**【题目来源】**\n\nNOIP 2001 提高组第四题", "locale": "zh-CN"}}}
{"pid": "P1028", "type": "P", "difficulty": 2, "samples": [["6\n", "6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2001", "递归", "NOIP 普及组"], "title": "[NOIP 2001 普及组] 数的计算", "background": "", "description": "给出正整数 $n$，要求按如下方式构造数列：\n\n1. 只有一个数 $n$ 的数列是一个合法的数列。\n2. 在一个合法的数列的末尾加入一个正整数，但是这个正整数不能超过该数列最后一项的一半，可以得到一个新的合法数列。\n\n请你求出，一共有多少个合法的数列。两个合法数列 $a, b$ 不同当且仅当两数列长度不同或存在一个正整数 $i \\leq |a|$，使得 $a_i \\neq b_i$。", "inputFormat": "输入只有一行一个整数，表示 $n$。", "outputFormat": "输出一行一个整数，表示合法的数列个数。", "hint": "### 样例 1 解释\n\n满足条件的数列为：\n- $6$\n- $6, 1$\n- $6, 2$\n- $6, 3$\n- $6, 2, 1$\n- $6, 3, 1$\n\n### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 10^3$。\n\n### 说明\n\n本题数据来源是 NOIP 2001 普及组第一题，但是原题的题面描述和数据不符，故对题面进行了修改，使之符合数据。原题面如下，谨供参考：\n\n> 我们要求找出具有下列性质数的个数（包含输入的正整数 $n$）。\n>\n> 先输入一个正整数 $n$（$n \\le 1000$），然后对此正整数按照如下方法进行处理：\n>\n> 1. 不作任何处理；\n> 2. 在它的左边拼接一个正整数，但该正整数不能超过原数，或者是上一个被拼接的数的一半；\n> 3. 加上数后，继续按此规则进行处理，直到不能再加正整数为止。\n\n感谢 @[dbxxx](/user/120868) 对本题情况的反馈，原题面的问题见[本贴](https://www.luogu.com.cn/discuss/526184)。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2001 Junior] Number Calculation", "background": null, "description": "Given a positive integer $n$, construct sequences in the following way.\n\n1. A sequence consisting of only the number $n$ is a valid sequence.\n2. By appending a positive integer to the end of a valid sequence, if this integer does not exceed half of the last term of the sequence, the new sequence is also valid.\n\nPlease find how many valid sequences there are in total. Two valid sequences $a, b$ are different if and only if their lengths are different, or there exists a positive integer $i \\leq |a|$ such that $a_i \\neq b_i$.", "inputFormat": "The input consists of a single line with one integer $n$.", "outputFormat": "Output a single integer, the number of valid sequences.", "hint": "### Explanation for Sample 1\n\nThe sequences that meet the conditions are:\n- $6$.\n- $6, 1$.\n- $6, 2$.\n- $6, 3$.\n- $6, 2, 1$.\n- $6, 3, 1$.\n\n### Constraints\n\nFor all test points, it is guaranteed that $1 \\leq n \\leq 10^3$.\n\n### Notes\n\nThe testdata of this problem comes from the first problem of NOIP 2001 Junior. However, the original statement and the testdata do not match, so the statement has been modified here to match the testdata. The original statement is provided below for reference:\n\n> We want to find the number of numbers with the following properties (including the input positive integer $n$).\n>\n> First input a positive integer $n$ ($n \\le 1000$), and then process this integer as follows:\n>\n> 1. Do nothing.\n> 2. Concatenate a positive integer to its left, but this positive integer cannot exceed the original number, or half of the last concatenated number.\n> 3. After adding a number, continue processing according to this rule until no more positive integers can be added.\n\nThanks to @[dbxxx](/user/120868) for the feedback on this problem. The issue with the original statement can be found in [this post](https://www.luogu.com.cn/discuss/526184).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2001 普及组] 数的计算", "background": "", "description": "给出正整数 $n$，要求按如下方式构造数列：\n\n1. 只有一个数 $n$ 的数列是一个合法的数列。\n2. 在一个合法的数列的末尾加入一个正整数，但是这个正整数不能超过该数列最后一项的一半，可以得到一个新的合法数列。\n\n请你求出，一共有多少个合法的数列。两个合法数列 $a, b$ 不同当且仅当两数列长度不同或存在一个正整数 $i \\leq |a|$，使得 $a_i \\neq b_i$。", "inputFormat": "输入只有一行一个整数，表示 $n$。", "outputFormat": "输出一行一个整数，表示合法的数列个数。", "hint": "### 样例 1 解释\n\n满足条件的数列为：\n- $6$\n- $6, 1$\n- $6, 2$\n- $6, 3$\n- $6, 2, 1$\n- $6, 3, 1$\n\n### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 10^3$。\n\n### 说明\n\n本题数据来源是 NOIP 2001 普及组第一题，但是原题的题面描述和数据不符，故对题面进行了修改，使之符合数据。原题面如下，谨供参考：\n\n> 我们要求找出具有下列性质数的个数（包含输入的正整数 $n$）。\n>\n> 先输入一个正整数 $n$（$n \\le 1000$），然后对此正整数按照如下方法进行处理：\n>\n> 1. 不作任何处理；\n> 2. 在它的左边拼接一个正整数，但该正整数不能超过原数，或者是上一个被拼接的数的一半；\n> 3. 加上数后，继续按此规则进行处理，直到不能再加正整数为止。\n\n感谢 @[dbxxx](/user/120868) 对本题情况的反馈，原题面的问题见[本贴](https://www.luogu.com.cn/discuss/526184)。", "locale": "zh-CN"}}}
{"pid": "P1029", "type": "P", "difficulty": 2, "samples": [["3 60\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2001", "NOIP 普及组", "枚举", "最大公约数 gcd"], "title": "[NOIP 2001 普及组] 最大公约数和最小公倍数问题", "background": "", "description": "输入两个正整数 $x_0, y_0$，求出满足下列条件的 $P, Q$ 的个数：\n\n1. $P,Q$ 是正整数。\n\n2. 要求 $P, Q$ 以 $x_0$ 为最大公约数，以 $y_0$ 为最小公倍数。\n\n试求：满足条件的所有可能的 $P, Q$ 的个数。", "inputFormat": "一行两个正整数 $x_0, y_0$。", "outputFormat": "一行一个数，表示求出满足条件的 $P, Q$ 的个数。", "hint": "$P,Q$ 有 $4$ 种：\n\n1. $3, 60$。\n2. $15, 12$。\n3. $12, 15$。\n4. $60, 3$。\n\n对于 $100\\%$ 的数据，$2 \\le x_0, y_0 \\le {10}^5$。\n\n**【题目来源】**\n\nNOIP 2001 普及组第二题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2001 Junior] Greatest Common Divisor and Least Common Multiple Problem", "background": null, "description": "Given two positive integers $x_0, y_0$, find the number of pairs $P, Q$ that satisfy the following conditions:\n\n1. $P, Q$ are positive integers.\n2. $P, Q$ have greatest common divisor $x_0$ and least common multiple $y_0$.\n\nCompute the number of all possible pairs $(P, Q)$ that satisfy the conditions.", "inputFormat": "One line with two positive integers $x_0, y_0$.", "outputFormat": "One line with a single number, representing the number of pairs $P, Q$ that satisfy the conditions.", "hint": "There are 4 possibilities for $P, Q$:\n1. $3, 60$.\n2. $15, 12$.\n3. $12, 15$.\n4. $60, 3$.\n\nConstraints: For $100\\%$ of the testdata, $2 \\le x_0, y_0 \\le 10^5$.\n\nSource: NOIP 2001 Junior, Problem 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2001 普及组] 最大公约数和最小公倍数问题", "background": "", "description": "输入两个正整数 $x_0, y_0$，求出满足下列条件的 $P, Q$ 的个数：\n\n1. $P,Q$ 是正整数。\n\n2. 要求 $P, Q$ 以 $x_0$ 为最大公约数，以 $y_0$ 为最小公倍数。\n\n试求：满足条件的所有可能的 $P, Q$ 的个数。", "inputFormat": "一行两个正整数 $x_0, y_0$。", "outputFormat": "一行一个数，表示求出满足条件的 $P, Q$ 的个数。", "hint": "$P,Q$ 有 $4$ 种：\n\n1. $3, 60$。\n2. $15, 12$。\n3. $12, 15$。\n4. $60, 3$。\n\n对于 $100\\%$ 的数据，$2 \\le x_0, y_0 \\le {10}^5$。\n\n**【题目来源】**\n\nNOIP 2001 普及组第二题", "locale": "zh-CN"}}}
{"pid": "P1030", "type": "P", "difficulty": 2, "samples": [["BADC\nBDCA\n", "ABCD\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "树形数据结构", "2001", "递归", "NOIP 普及组", "深度优先搜索 DFS"], "title": "[NOIP 2001 普及组] 求先序排列", "background": "", "description": "给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，且二叉树的节点个数 $ \\le 8$）。\n", "inputFormat": "共两行，均为大写字母组成的字符串，表示一棵二叉树的中序与后序排列。\n", "outputFormat": "共一行一个字符串，表示一棵二叉树的先序。\n", "hint": "**【题目来源】**\n\nNOIP 2001 普及组第三题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2001 Junior] Find the Preorder Traversal", "background": null, "description": "Given the inorder and postorder traversals of a binary tree, find its preorder traversal. (Assume that tree nodes are represented by distinct uppercase letters, and the number of nodes in the binary tree is $ \\le 8$).", "inputFormat": "Two lines, each a string of uppercase letters, representing the inorder and postorder traversals of a binary tree.", "outputFormat": "One line containing a string representing the preorder traversal of the binary tree.", "hint": "[Problem Source]\n\nNOIP 2001 Junior Problem 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2001 普及组] 求先序排列", "background": "", "description": "给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，且二叉树的节点个数 $ \\le 8$）。\n", "inputFormat": "共两行，均为大写字母组成的字符串，表示一棵二叉树的中序与后序排列。\n", "outputFormat": "共一行一个字符串，表示一棵二叉树的先序。\n", "hint": "**【题目来源】**\n\nNOIP 2001 普及组第三题", "locale": "zh-CN"}}}
{"pid": "P1031", "type": "P", "difficulty": 2, "samples": [["4\n9 8 17 6\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心", "2002", "NOIP 提高组"], "title": "[NOIP 2002 提高组] 均分纸牌", "background": "", "description": "有 $N$ 堆纸牌，编号分别为 $1,2,\\ldots,N$。每堆上有若干张，但纸牌总数必为 $N$ 的倍数。可以在任一堆上取若干张纸牌，然后移动。\n\n移牌规则为：在编号为 $1$ 堆上取的纸牌，只能移到编号为 $2$ 的堆上；在编号为 $N$ 的堆上取的纸牌，只能移到编号为 $N-1$ 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。\n\n现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。\n\n例如 $N=4$ 时，$4$ 堆纸牌数分别为 $9,8,17,6$。\n\n移动 $3$ 次可达到目的：\n\n- 从第三堆取 $4$ 张牌放到第四堆，此时每堆纸牌数分别为 $9,8,13,10$。\n- 从第三堆取 $3$ 张牌放到第二堆，此时每堆纸牌数分别为 $9,11,10,10$。\n- 从第二堆取 $1$ 张牌放到第一堆，此时每堆纸牌数分别为  $10,10,10,10$。\n", "inputFormat": "第一行共一个整数 $N$，表示纸牌堆数。  \n第二行共 $N$ 个整数 $A_1,A_2,\\ldots,A_N$，表示每堆纸牌初始时的纸牌数。\n", "outputFormat": "共一行，即所有堆均达到相等时的最少移动次数。\n", "hint": "对于 $100\\%$ 的数据，$1  \\le  N  \\le  100$，$1 \\le  A_i  \\le 10000$。\n\n**【题目来源】**\n\nNOIP 2002 提高组第一题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2002 Senior] Equalizing Cards", "background": null, "description": "There are $N$ piles of cards, numbered $1,2,\\ldots,N$. Each pile has some cards, and the total number of cards is a multiple of $N$. You may take any number of cards from any pile and move them.\n\nThe moving rules are: cards taken from pile $1$ can only be moved to pile $2$; cards taken from pile $N$ can only be moved to pile $N-1$; cards taken from any other pile can be moved to the adjacent pile on the left or right.\n\nFind a way to move the cards so that all piles contain the same number of cards, using the minimum number of moves.\n\nFor example, when $N=4$, the numbers of cards in the $4$ piles are $9,8,17,6$.\n\nIt can be done in $3$ moves:\n- Take $4$ cards from the third pile and put them onto the fourth pile; the piles become $9,8,13,10$.\n- Take $3$ cards from the third pile and put them onto the second pile; the piles become $9,11,10,10$.\n- Take $1$ card from the second pile and put it onto the first pile; the piles become $10,10,10,10$.", "inputFormat": "The first line contains an integer $N$, the number of piles.  \nThe second line contains $N$ integers $A_1,A_2,\\ldots,A_N$, the initial number of cards in each pile.", "outputFormat": "Output a single line: the minimum number of moves needed to make all piles equal.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le N \\le 100$, $1 \\le A_i \\le 10000$.\n\nProblem Source: NOIP 2002 Senior, Problem 1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2002 提高组] 均分纸牌", "background": "", "description": "有 $N$ 堆纸牌，编号分别为 $1,2,\\ldots,N$。每堆上有若干张，但纸牌总数必为 $N$ 的倍数。可以在任一堆上取若干张纸牌，然后移动。\n\n移牌规则为：在编号为 $1$ 堆上取的纸牌，只能移到编号为 $2$ 的堆上；在编号为 $N$ 的堆上取的纸牌，只能移到编号为 $N-1$ 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。\n\n现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。\n\n例如 $N=4$ 时，$4$ 堆纸牌数分别为 $9,8,17,6$。\n\n移动 $3$ 次可达到目的：\n\n- 从第三堆取 $4$ 张牌放到第四堆，此时每堆纸牌数分别为 $9,8,13,10$。\n- 从第三堆取 $3$ 张牌放到第二堆，此时每堆纸牌数分别为 $9,11,10,10$。\n- 从第二堆取 $1$ 张牌放到第一堆，此时每堆纸牌数分别为  $10,10,10,10$。\n", "inputFormat": "第一行共一个整数 $N$，表示纸牌堆数。  \n第二行共 $N$ 个整数 $A_1,A_2,\\ldots,A_N$，表示每堆纸牌初始时的纸牌数。\n", "outputFormat": "共一行，即所有堆均达到相等时的最少移动次数。\n", "hint": "对于 $100\\%$ 的数据，$1  \\le  N  \\le  100$，$1 \\le  A_i  \\le 10000$。\n\n**【题目来源】**\n\nNOIP 2002 提高组第一题", "locale": "zh-CN"}}}
{"pid": "P1032", "type": "P", "difficulty": 4, "samples": [["abcd xyz\nabc xu\nud y\ny yz\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "搜索", "2002", "NOIP 提高组", "广度优先搜索 BFS", "剪枝", "折半搜索 meet in the middle"], "title": "[NOIP 2002 提高组] 字串变换（疑似错题）", "background": "本题不保证存在靠谱的多项式复杂度的做法。测试数据非常的水，各种做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。\n\n本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)", "description": "已知有两个字串 $A,B$ 及一组字串变换的规则（至多 $6$ 个规则），形如：\n\n- $A_1\\to B_1$。\n- $A_2\\to B_2$。\n\n规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $ B_1$，$A_2$ 可以变换为 $B_2\\cdots$。\n\n例如：$A=\\texttt{abcd}$，$B＝\\texttt{xyz}$，\n\n变换规则为：\n\n- $\\texttt{abc}\\rightarrow\\texttt{xu}$，$\\texttt{ud}\\rightarrow\\texttt{y}$，$\\texttt{y}\\rightarrow\\texttt{yz}$。\n\n则此时，$A$ 可以经过一系列的变换变为 $B$，其变换的过程为：\n\n- $\\texttt{abcd}\\rightarrow\\texttt{xud}\\rightarrow\\texttt{xy}\\rightarrow\\texttt{xyz}$。\n\n共进行了 $3$ 次变换，使得 $A$ 变换为 $B$。", "inputFormat": "第一行有两个字符串 $A,B$。\n\n接下来若干行，每行有两个字符串 $A_i,B_i$，表示一条变换规则。", "outputFormat": "若在 $10$ 步（包含 $10$ 步）以内能将 $A$ 变换为 $B$，则输出最少的变换步数；否则输出 `NO ANSWER!`。", "hint": "对于 $100\\%$ 数据，保证所有字符串长度的上限为 $20$。\n\n**【题目来源】**\n\nNOIP 2002 提高组第二题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2002 Senior] String Transformation (suspected wrong problem)", "background": null, "description": "You are given two strings $A, B$ and a set of string transformation rules (at most $6$ rules), of the form:\n\n- $A_1 \\to B_1$.\n- $A_2 \\to B_2$.\n\nThe meaning of the rules is: in $A$, a substring $A_1$ can be transformed into $B_1$, $A_2$ can be transformed into $B_2 \\cdots$.\n\nFor example: $A=\\texttt{abcd}$, $B=\\texttt{xyz}$,\n\nwith the transformation rules:\n\n- $\\texttt{abc}\\rightarrow\\texttt{xu}$, $\\texttt{ud}\\rightarrow\\texttt{y}$, $\\texttt{y}\\rightarrow\\texttt{yz}$.\n\nThen $A$ can be transformed into $B$ through a sequence of transformations:\n\n- $\\texttt{abcd}\\rightarrow\\texttt{xud}\\rightarrow\\texttt{xy}\\rightarrow\\texttt{xyz}$.\n\nA total of $3$ transformations are performed to transform $A$ into $B$.", "inputFormat": "The first line contains two strings $A, B$.\n\nEach of the following lines contains two strings $A_i, B_i$, representing one transformation rule.", "outputFormat": "If $A$ can be transformed into $B$ within $10$ steps (inclusive), output the minimum number of steps; otherwise, output `NO ANSWER!`.", "hint": "For $100\\%$ of the testdata, the maximum length of all strings is $20$.\n\nSource: NOIP 2002 Senior, Problem 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2002 提高组] 字串变换（疑似错题）", "background": "本题不保证存在靠谱的多项式复杂度的做法。测试数据非常的水，各种做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。\n\n本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)", "description": "已知有两个字串 $A,B$ 及一组字串变换的规则（至多 $6$ 个规则），形如：\n\n- $A_1\\to B_1$。\n- $A_2\\to B_2$。\n\n规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $ B_1$，$A_2$ 可以变换为 $B_2\\cdots$。\n\n例如：$A=\\texttt{abcd}$，$B＝\\texttt{xyz}$，\n\n变换规则为：\n\n- $\\texttt{abc}\\rightarrow\\texttt{xu}$，$\\texttt{ud}\\rightarrow\\texttt{y}$，$\\texttt{y}\\rightarrow\\texttt{yz}$。\n\n则此时，$A$ 可以经过一系列的变换变为 $B$，其变换的过程为：\n\n- $\\texttt{abcd}\\rightarrow\\texttt{xud}\\rightarrow\\texttt{xy}\\rightarrow\\texttt{xyz}$。\n\n共进行了 $3$ 次变换，使得 $A$ 变换为 $B$。", "inputFormat": "第一行有两个字符串 $A,B$。\n\n接下来若干行，每行有两个字符串 $A_i,B_i$，表示一条变换规则。", "outputFormat": "若在 $10$ 步（包含 $10$ 步）以内能将 $A$ 变换为 $B$，则输出最少的变换步数；否则输出 `NO ANSWER!`。", "hint": "对于 $100\\%$ 数据，保证所有字符串长度的上限为 $20$。\n\n**【题目来源】**\n\nNOIP 2002 提高组第二题", "locale": "zh-CN"}}}
{"pid": "P1033", "type": "P", "difficulty": 3, "samples": [["5.0 9.0 5.0 2.5 1.8 5\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2002", "NOIP 提高组"], "title": "[NOIP 2002 提高组] 自由落体", "background": "", "description": "在高为 $H$ 的天花板上有 $n$ 个小球，体积不计，位置分别为 $0,1,2,\\cdots,n-1$。在地面上有一个小车（长为 $L$，高为 $K$，距原点距离为 $S_1$）。已知小球下落距离计算公式为 $d=0.5 \\times g \\times (t^2)$，其中 $g=10$，$t$ 为下落时间。地面上的小车以速度 $V$ 前进。\n\n如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1d177dhg.png)\n\n小车与所有小球同时开始运动，当小球距小车的距离 $\\le  0.0001$ (感谢 Silver_N 修正) 时，即认为小球被小车接受（小球落到地面后不能被接受）。\n\n请你计算出小车能接受到多少个小球。\n", "inputFormat": "$H,S_1,V,L,K,n$（$1 \\le H,S_1,V,L,K,n \\le 100000$）", "outputFormat": "小车能接受到的小球个数。", "hint": "当球落入车的尾部时，算作落入车内。\n\n**【题目来源】**\n\nNOIP 2002 提高组第三题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2002 Senior] Free Fall", "background": null, "description": "On a ceiling of height $H$, there are $n$ balls with negligible size, located at positions $0, 1, 2, \\cdots, n-1$. On the ground there is a cart (length $L$, height $K$) at a distance $S_1$ from the origin. The falling distance of a ball is given by $d=0.5 \\times g \\times (t^2)$, where $g=10$ and $t$ is the falling time. The cart moves forward at speed $V$.\n\nAs shown in the figure:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1d177dhg.png)\n\nThe cart and all balls start moving at the same time. When the distance between a ball and the cart is $\\le 0.0001$ (thanks to Silver_N for the correction), the ball is considered caught by the cart. A ball cannot be caught after it has reached the ground.\n\nPlease compute how many balls the cart can catch.\n\nSource: NOIP 2002 Senior, Problem 3.", "inputFormat": "A single line contains six integers $H, S_1, V, L, K, n$.\n\nConstraints: $1 \\le H, S_1, V, L, K, n \\le 100000$.", "outputFormat": "Output a single integer: the number of balls the cart can catch.", "hint": "If a ball falls into the rear end of the cart, it is considered to have fallen into the cart.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2002 提高组] 自由落体", "background": "", "description": "在高为 $H$ 的天花板上有 $n$ 个小球，体积不计，位置分别为 $0,1,2,\\cdots,n-1$。在地面上有一个小车（长为 $L$，高为 $K$，距原点距离为 $S_1$）。已知小球下落距离计算公式为 $d=0.5 \\times g \\times (t^2)$，其中 $g=10$，$t$ 为下落时间。地面上的小车以速度 $V$ 前进。\n\n如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1d177dhg.png)\n\n小车与所有小球同时开始运动，当小球距小车的距离 $\\le  0.0001$ (感谢 Silver_N 修正) 时，即认为小球被小车接受（小球落到地面后不能被接受）。\n\n请你计算出小车能接受到多少个小球。\n", "inputFormat": "$H,S_1,V,L,K,n$（$1 \\le H,S_1,V,L,K,n \\le 100000$）", "outputFormat": "小车能接受到的小球个数。", "hint": "当球落入车的尾部时，算作落入车内。\n\n**【题目来源】**\n\nNOIP 2002 提高组第三题", "locale": "zh-CN"}}}
{"pid": "P1034", "type": "P", "difficulty": 4, "samples": [["4 2\n1 1\n2 2\n3 6\n0 7\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "计算几何", "2002", "NOIP 提高组"], "title": "[NOIP 2002 提高组] 矩形覆盖", "background": "", "description": "在平面上有 $n$ 个点，每个点用一对整数坐标表示。例如：当 $n=4$ 时，$4$ 个点的坐标分别为：$p_1(1,1)$，$p_2(2,2)$，$p_3(3,6)$，$p_4(0,7)$，见图一。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dxc1c5k9.png)\n\n这些点可以用 $k$ 个矩形全部覆盖，矩形的边平行于坐标轴。当 $k=2$ 时，可用如图二的两个矩形 $s_1,s_2$ 覆盖，$s_1,s_2$ 面积和为 $4$。问题是当 $n$ 个点坐标和 $k$ 给出后，怎样才能使得覆盖所有点的 $k$ 个矩形的面积之和为最小呢？  \n约定：覆盖一个点的矩形面积为 $0$；覆盖平行于坐标轴直线上点的矩形面积也为 $0$。各个矩形必须完全分开（边线与顶点也都不能重合）。\n", "inputFormat": "第一行共两个整数 $n,k$，含义如题面所示。\n\n接下来 $n$ 行，其中第 $i+1$ 行有两个整数 $x_i,y_i$，表示平面上第 $i$ 个点的坐标。\n", "outputFormat": "共一行一个整数，为满足条件的最小的矩形面积之和。\n", "hint": "对于 $100\\%$ 数据，满足 $1\\le n \\le  50$，$1 \\le k \\le 4$，$0 \\le x_i,y_i  \\le 500$。\n\n**【题目来源】**\n\nNOIP 2002 提高组第四题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2002 Senior] Rectangle Covering", "background": null, "description": "On the plane, there are $n$ points, each represented by a pair of integer coordinates. For example, when $n=4$, the coordinates of the 4 points are $p_1(1,1)$, $p_2(2,2)$, $p_3(3,6)$, $p_4(0,7)$; see Figure 1.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dxc1c5k9.png)\n\nThese points can be fully covered by $k$ rectangles whose sides are parallel to the coordinate axes. When $k=2$, two rectangles $s_1, s_2$ as in Figure 2 can cover them, and the sum of their areas is $4$. Given the $n$ points and $k$, how can we make the sum of the areas of the $k$ rectangles that cover all points as small as possible?\n\nConventions: A rectangle covering a single point has area $0$; a rectangle that degenerates to a line segment parallel to a coordinate axis also has area $0$. The rectangles must be pairwise disjoint; they may not overlap or even touch (edges and vertices may not coincide).", "inputFormat": "The first line contains two integers $n, k$, as described above.\n\nThe next $n$ lines each contain two integers $x_i, y_i$, where the $(i+1)$-th line gives the coordinates of the $i$-th point.", "outputFormat": "Output a single integer: the minimum possible sum of the areas of the $k$ rectangles that satisfy the conditions.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 50$, $1 \\le k \\le 4$, $0 \\le x_i, y_i \\le 500$.\n\nSource: NOIP 2002 Senior, Problem 4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2002 提高组] 矩形覆盖", "background": "", "description": "在平面上有 $n$ 个点，每个点用一对整数坐标表示。例如：当 $n=4$ 时，$4$ 个点的坐标分别为：$p_1(1,1)$，$p_2(2,2)$，$p_3(3,6)$，$p_4(0,7)$，见图一。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dxc1c5k9.png)\n\n这些点可以用 $k$ 个矩形全部覆盖，矩形的边平行于坐标轴。当 $k=2$ 时，可用如图二的两个矩形 $s_1,s_2$ 覆盖，$s_1,s_2$ 面积和为 $4$。问题是当 $n$ 个点坐标和 $k$ 给出后，怎样才能使得覆盖所有点的 $k$ 个矩形的面积之和为最小呢？  \n约定：覆盖一个点的矩形面积为 $0$；覆盖平行于坐标轴直线上点的矩形面积也为 $0$。各个矩形必须完全分开（边线与顶点也都不能重合）。\n", "inputFormat": "第一行共两个整数 $n,k$，含义如题面所示。\n\n接下来 $n$ 行，其中第 $i+1$ 行有两个整数 $x_i,y_i$，表示平面上第 $i$ 个点的坐标。\n", "outputFormat": "共一行一个整数，为满足条件的最小的矩形面积之和。\n", "hint": "对于 $100\\%$ 数据，满足 $1\\le n \\le  50$，$1 \\le k \\le 4$，$0 \\le x_i,y_i  \\le 500$。\n\n**【题目来源】**\n\nNOIP 2002 提高组第四题", "locale": "zh-CN"}}}
{"pid": "P1035", "type": "P", "difficulty": 1, "samples": [["1\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "数学", "2002", "NOIP 普及组"], "title": "[NOIP 2002 普及组] 级数求和", "background": "", "description": "已知：$S_n= 1+\\dfrac{1}{2}+\\dfrac{1}{3}+…+\\dfrac{1}{n}$。显然对于任意一个整数 $k$，当 $n$ 足够大的时候，$S_n>k$。\n\n现给出一个整数 $k$，要求计算出一个最小的 $n$，使得 $S_n>k$。\n", "inputFormat": "一个正整数 $k$。\n", "outputFormat": "一个正整数 $n$。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\le k \\le 15$。\n\n**【题目来源】**\n\nNOIP 2002 普及组第一题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2002 Junior] Series Summation", "background": null, "description": "Given: $S_n= 1+\\dfrac{1}{2}+\\dfrac{1}{3}+…+\\dfrac{1}{n}$. It is obvious that for any integer $k$, when $n$ is sufficiently large, $S_n>k$.\nGiven an integer $k$, compute the smallest $n$ such that $S_n>k$.", "inputFormat": "A positive integer $k$.", "outputFormat": "A positive integer $n$.", "hint": "【Constraints】\nFor $100\\%$ of the testdata, $1\\le k \\le 15$.\n\n【Source】\nNOIP 2002 Junior, Problem 1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2002 普及组] 级数求和", "background": "", "description": "已知：$S_n= 1+\\dfrac{1}{2}+\\dfrac{1}{3}+…+\\dfrac{1}{n}$。显然对于任意一个整数 $k$，当 $n$ 足够大的时候，$S_n>k$。\n\n现给出一个整数 $k$，要求计算出一个最小的 $n$，使得 $S_n>k$。\n", "inputFormat": "一个正整数 $k$。\n", "outputFormat": "一个正整数 $n$。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\le k \\le 15$。\n\n**【题目来源】**\n\nNOIP 2002 普及组第一题", "locale": "zh-CN"}}}
{"pid": "P1036", "type": "P", "difficulty": 2, "samples": [["4 3\n3 7 12 19\n", "1\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "2002", "NOIP 普及组", "深度优先搜索 DFS", "素数判断,质数,筛法"], "title": "[NOIP 2002 普及组] 选数", "background": "", "description": "已知 $n$ 个整数 $x_1,x_2,\\cdots,x_n$，以及 $1$ 个整数 $k$（$k<n$）。从 $n$ 个整数中任选 $k$ 个整数相加，可分别得到一系列的和。例如当 $n=4$，$k=3$，$4$ 个整数分别为 $3,7,12,19$ 时，可得全部的组合与它们的和为：\n\n$3+7+12=22$\n\n$3+7+19=29$\n\n$7+12+19=38$\n\n$3+12+19=34$\n\n现在，要求你计算出和为素数共有多少种。\n\n例如上例，只有一种的和为素数：$3+7+19=29$。", "inputFormat": "第一行两个空格隔开的整数 $n,k$（$1 \\le n \\le 20$，$k<n$）。\n\n第二行 $n$ 个整数，分别为 $x_1,x_2,\\cdots,x_n$（$1 \\le x_i \\le 5\\times 10^6$）。\n", "outputFormat": "输出一个整数，表示种类数。", "hint": "**【题目来源】**\n\nNOIP 2002 普及组第二题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2002 Junior] Choosing Numbers", "background": null, "description": "Given $n$ integers $x_1, x_2, \\cdots, x_n$, and one integer $k$ ($k<n$). Choose any $k$ integers from the $n$ integers and add them up to obtain a set of sums. For example, when $n=4$, $k=3$, and the four integers are $3, 7, 12, 19$, all combinations and their sums are:\n\n$3+7+12=22$.\n\n$3+7+19=29$.\n\n$7+12+19=38$.\n\n$3+12+19=34$.\n\nNow, you are required to compute how many of these sums are prime numbers.\n\nFor example, in the case above, only one sum is prime: $3+7+19=29$.", "inputFormat": "The first line contains two integers $n, k$ separated by a space ($1 \\le n \\le 20$, $k<n$).\n\nThe second line contains $n$ integers $x_1, x_2, \\cdots, x_n$ ($1 \\le x_i \\le 5\\times 10^6$).", "outputFormat": "Output a single integer representing the number of ways.", "hint": "【Source】\n\nNOIP 2002 Junior, Problem 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2002 普及组] 选数", "background": "", "description": "已知 $n$ 个整数 $x_1,x_2,\\cdots,x_n$，以及 $1$ 个整数 $k$（$k<n$）。从 $n$ 个整数中任选 $k$ 个整数相加，可分别得到一系列的和。例如当 $n=4$，$k=3$，$4$ 个整数分别为 $3,7,12,19$ 时，可得全部的组合与它们的和为：\n\n$3+7+12=22$\n\n$3+7+19=29$\n\n$7+12+19=38$\n\n$3+12+19=34$\n\n现在，要求你计算出和为素数共有多少种。\n\n例如上例，只有一种的和为素数：$3+7+19=29$。", "inputFormat": "第一行两个空格隔开的整数 $n,k$（$1 \\le n \\le 20$，$k<n$）。\n\n第二行 $n$ 个整数，分别为 $x_1,x_2,\\cdots,x_n$（$1 \\le x_i \\le 5\\times 10^6$）。\n", "outputFormat": "输出一个整数，表示种类数。", "hint": "**【题目来源】**\n\nNOIP 2002 普及组第二题", "locale": "zh-CN"}}}
{"pid": "P1037", "type": "P", "difficulty": 3, "samples": [["234 2\n2 5\n3 6\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "图论", "高精度", "2002", "NOIP 普及组", "深度优先搜索 DFS", "Floyd 算法"], "title": "[NOIP 2002 普及组] 产生数", "background": "", "description": "给出一个整数 $n$ 和 $k$ 个变换规则。\n\n规则：\n- 一位数可变换成另一个一位数。\n- 规则的右部不能为零。\n\n例如：$n=234,k=2$。有以下两个规则：\n\n- $2\\longrightarrow 5$。  \n- $3\\longrightarrow 6$。 \n\n上面的整数 $234$ 经过变换后可能产生出的整数为（包括原数）:\n\n- $234$。\n- $534$。\n- $264$。\n- $564$。\n\n共 $4$ 种不同的产生数。\n\n现在给出一个整数 $n$ 和 $k$ 个规则。求出经过任意次的变换（$0$ 次或多次），能产生出多少个不同整数。\n\n仅要求输出个数。", "inputFormat": "第一行两个整数 $n,k$，含义如题面所示。\n\n接下来 $k$ 行，每行两个整数 $x_i,y_i$，表示每条规则。", "outputFormat": "共一行，输出能生成的数字个数。\n", "hint": "对于 $100\\%$ 数据，满足 $n \\lt 10^{30}$，$k \\le 15$。\n\n**【题目来源】**\n\nNOIP 2002 普及组第三题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2002 Junior] Generated Numbers", "background": null, "description": "Given an integer $n$ and $k$ transformation rules.\n\nRules:\n- A single digit can be transformed into another single digit.\n- The right-hand side of a rule cannot be zero.\n\nFor example: $n = 234, k = 2$. There are two rules:\n- $2\\longrightarrow 5$.\n- $3\\longrightarrow 6$.\n\nAfter applying transformations, the integer $234$ can produce the following integers (including the original number):\n- $234$.\n- $534$.\n- $264$.\n- $564$.\n\nThere are $4$ distinct generated numbers.\n\nNow, given an integer $n$ and $k$ rules, determine how many different integers can be produced by applying any number of transformations (zero or more). Only output the count.", "inputFormat": "The first line contains two integers $n, k$, as described.\n\nThe next $k$ lines each contain two integers $x_i, y_i$, representing each rule.", "outputFormat": "Output a single line containing the number of distinct integers that can be generated.", "hint": "Constraints: For $100\\%$ of the testdata, $n < 10^{30}$, $k \\le 15$.\n\nProblem Source: NOIP 2002 Junior, Problem 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2002 普及组] 产生数", "background": "", "description": "给出一个整数 $n$ 和 $k$ 个变换规则。\n\n规则：\n- 一位数可变换成另一个一位数。\n- 规则的右部不能为零。\n\n例如：$n=234,k=2$。有以下两个规则：\n\n- $2\\longrightarrow 5$。  \n- $3\\longrightarrow 6$。 \n\n上面的整数 $234$ 经过变换后可能产生出的整数为（包括原数）:\n\n- $234$。\n- $534$。\n- $264$。\n- $564$。\n\n共 $4$ 种不同的产生数。\n\n现在给出一个整数 $n$ 和 $k$ 个规则。求出经过任意次的变换（$0$ 次或多次），能产生出多少个不同整数。\n\n仅要求输出个数。", "inputFormat": "第一行两个整数 $n,k$，含义如题面所示。\n\n接下来 $k$ 行，每行两个整数 $x_i,y_i$，表示每条规则。", "outputFormat": "共一行，输出能生成的数字个数。\n", "hint": "对于 $100\\%$ 数据，满足 $n \\lt 10^{30}$，$k \\le 15$。\n\n**【题目来源】**\n\nNOIP 2002 普及组第三题", "locale": "zh-CN"}}}
{"pid": "P1038", "type": "P", "difficulty": 4, "samples": [["5 6\n1 0\n1 0\n0 1\n0 1\n0 1\n1 3 1\n1 4 1\n1 5 1\n2 3 1\n2 4 1\n2 5 1\n", "3 1\n4 1\n5 1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2003", "NOIP 提高组", "拓扑排序"], "title": "[NOIP 2003 提高组] 神经网络", "background": "人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。", "description": "在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/61qm40kj.png)\n\n神经元（编号为 $i$）\n\n\n图中，$X_1 \\sim X_3$ 是信息输入渠道，$Y_1 \\sim Y_2$ 是信息输出渠道，$C_i$ 表示神经元目前的状态，$U_i$ 是阈值，可视为神经元的一个内在参数。\n\n神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4xd7f8yz.png)\n\n兰兰规定，$C_i$ 服从公式：（其中 $n$ 是网络中所有神经元的数目）\n\n$$C_i=\\left(\\sum\\limits_{(j,i) \\in E} W_{ji}C_{j}\\right)-U_{i}$$\n\n公式中的 $W_{ji}$（可能为负值）表示连接 $j$ 号神经元和 $i$ 号神经元的边的权值。当 $C_i$ 大于 $0$ 时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为 $C_i$。\n\n如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（$C_i$），要求你的程序运算出最后网络输出层的状态。", "inputFormat": "输入文件第一行是两个整数 $n$（$1 \\le n \\le 100$）和 $p$。接下来 $n$ 行，每行 $2$ 个整数，第 $i+1$ 行是神经元 $i$ 最初状态和其阈值（$U_i$），非输入层的神经元开始时状态必然为 $0$。再下面 $p$ 行，每行有两个整数 $i,j$ 及一个整数 $W_{ij}$（$|W_{ij}|\\leq 10^9$），表示连接神经元 $i,j$ 的边权值为 $W_{ij}$。", "outputFormat": "输出文件包含若干行，每行有 $2$ 个整数，分别对应一个神经元的编号，及其最后的状态，$2$ 个整数间以空格分隔。仅输出最后状态大于 $0$ 的输出层神经元状态，并且按照编号由小到大顺序输出。\n\n若输出层的神经元最后状态均小于等于 $0$，则输出 `NULL`。", "hint": "**【题目来源】**\n\nNOIP 2003 提高组第一题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2003 Senior] Neural Network", "background": null, "description": "In Lanlan’s model, a neural network is a directed graph whose nodes are called neurons, and there is at most one edge between any two neurons. The figure below shows an example of one neuron.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/61qm40kj.png)\n\nNeuron (index $i$).\n\nIn the figure, $X_1 \\sim X_3$ are input channels, $Y_1 \\sim Y_2$ are output channels, $C_i$ is the current state of the neuron, and $U_i$ is the threshold, which can be regarded as an intrinsic parameter of the neuron.\n\nNeurons are arranged in order to form the entire neural network. In Lanlan’s model, neurons are divided into multiple layers: the input layer, the output layer, and several intermediate layers. Each layer only outputs information to the next layer and only receives information from the previous layer. The figure below shows a simple three-layer neural network.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4xd7f8yz.png)\n\nLanlan stipulates that $C_i$ follows the formula (where $n$ is the total number of neurons in the network):\n$$C_i=\\left(\\sum\\limits_{(j,i) \\in E} W_{ji}C_{j}\\right)-U_{i}$$\nHere, $W_{ji}$ (which may be negative) denotes the weight of the edge connecting neuron $j$ to neuron $i$. When $C_i$ is greater than $0$, the neuron is excited; otherwise, it is calm. When a neuron is excited, in the next second it will send signals to other neurons, with signal strength equal to $C_i$.\n\nThus, after the neurons in the input layer are stimulated, the entire network operates under the push of information transmission. Now, given a neural network and the current states $C_i$ of the input-layer neurons, compute the final states of the output layer.", "inputFormat": "The first line contains two integers $n$ ($1 \\le n \\le 100$) and $p$. The next $n$ lines each contain $2$ integers; the $(i+1)$-th line gives neuron $i$’s initial state and its threshold $U_i$. Non–input-layer neurons start with state $0$. The following $p$ lines each contain three integers $i$, $j$, and $W_{ij}$ (where $W_{ij} \\le 10^9$ and may be negative), indicating a directed edge from neuron $i$ to neuron $j$ with weight $W_{ij}$.", "outputFormat": "Output several lines, each containing $2$ integers: a neuron’s index and its final state, separated by a space. Output only those output-layer neurons whose final state is greater than $0$, in ascending order of index. If all output-layer neurons have final state less than or equal to $0$, output `NULL`.", "hint": "[Problem Source]\n\nNOIP 2003 Senior, Problem 1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2003 提高组] 神经网络", "background": "人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。", "description": "在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/61qm40kj.png)\n\n神经元（编号为 $i$）\n\n\n图中，$X_1 \\sim X_3$ 是信息输入渠道，$Y_1 \\sim Y_2$ 是信息输出渠道，$C_i$ 表示神经元目前的状态，$U_i$ 是阈值，可视为神经元的一个内在参数。\n\n神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4xd7f8yz.png)\n\n兰兰规定，$C_i$ 服从公式：（其中 $n$ 是网络中所有神经元的数目）\n\n$$C_i=\\left(\\sum\\limits_{(j,i) \\in E} W_{ji}C_{j}\\right)-U_{i}$$\n\n公式中的 $W_{ji}$（可能为负值）表示连接 $j$ 号神经元和 $i$ 号神经元的边的权值。当 $C_i$ 大于 $0$ 时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为 $C_i$。\n\n如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（$C_i$），要求你的程序运算出最后网络输出层的状态。", "inputFormat": "输入文件第一行是两个整数 $n$（$1 \\le n \\le 100$）和 $p$。接下来 $n$ 行，每行 $2$ 个整数，第 $i+1$ 行是神经元 $i$ 最初状态和其阈值（$U_i$），非输入层的神经元开始时状态必然为 $0$。再下面 $p$ 行，每行有两个整数 $i,j$ 及一个整数 $W_{ij}$（$|W_{ij}|\\leq 10^9$），表示连接神经元 $i,j$ 的边权值为 $W_{ij}$。", "outputFormat": "输出文件包含若干行，每行有 $2$ 个整数，分别对应一个神经元的编号，及其最后的状态，$2$ 个整数间以空格分隔。仅输出最后状态大于 $0$ 的输出层神经元状态，并且按照编号由小到大顺序输出。\n\n若输出层的神经元最后状态均小于等于 $0$，则输出 `NULL`。", "hint": "**【题目来源】**\n\nNOIP 2003 提高组第一题", "locale": "zh-CN"}}}
{"pid": "P1039", "type": "P", "difficulty": 5, "samples": [["3 1 5\nMIKE\nCHARLES\nKATE\nMIKE: I am guilty.\nMIKE: Today is Sunday.\nCHARLES: MIKE is guilty.\nKATE: I am guilty.\nKATE: How are you??\n", "MIKE\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "字符串", "2003", "NOIP 提高组", "枚举"], "title": "[NOIP 2003 提高组] 侦探推理", "background": null, "description": "明明同学最近迷上了侦探漫画《柯南》并沉醉于推理游戏之中，于是他召集了一群同学玩推理游戏。游戏的内容是这样的，明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|l|l|}\\hline\n\\textbf{\\textsf{证词内容}} & \\textbf{\\textsf{证词含义}}\\\\\\hline\n\\text{I am guilty.} & \\text{我是罪犯。} \\\\\\hline\n\\text{I am not guilty.} & \\text{我不是罪犯。} \\\\\\hline\n\\text{{\\tt XXX} is guilty.} & \\text{{\\tt XXX} 是罪犯。其中 {\\tt XXX} 表示某个同学的名字。} \\\\\\hline\n\\text{{\\tt XXX} is not guilty.} & \\text{{\\tt XXX} 不是罪犯。} \\\\\\hline\n\\text{Today is {\\tt XXX}.} &\n\\begin{aligned}\n&\\text{今天是 {\\tt XXX}。其中 {\\tt XXX} 表示某个星期的单词。}\\\\\n&\\text{星期只有可能是以下之一：}\\\\\n&\\texttt{Monday}, \\texttt{Tuesday}, \\texttt{Wednesday}, \\texttt{Thursday}, \\\\\n&\\texttt{Friday}, \\texttt{Saturday}, \\texttt{Sunday}。\n\\end{aligned}\n\\\\\\hline\n\\end{array}$$\n\n证词中出现的其他话，都不列入逻辑推理的内容。\n\n\n明明所知道的是，他的同学中有 $N$ 个人始终说假话，其余的人始终说真。\n\n\n现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！", "inputFormat": "输入由若干行组成。\n\n第一行有三个整数，$M,N$ 和 $P$。$M$ 是参加游戏的明明的同学数，$N$ 是其中始终说谎的人数，$P$ 是证言的总数。  \n  \n接下来 $M$ 行，每行是明明的一个同学的名字（英文字母组成，没有空格，全部大写）。\n\n往后有 $P$ 行，每行开始是某个同学的名字，紧跟着一个冒号和一个空格，后面是一句证词，符合前表中所列格式。证词每行不会超过 $250$ 个字符。\n\n输入中不会出现连续的两个空格，而且每行开头和结尾也没有空格。", "outputFormat": "如果你的程序能确定谁是罪犯，则输出他的名字；如果程序判断出不止一个人可能是罪犯，则输出 `Cannot Determine`；如果程序判断出没有人可能成为罪犯，则输出 `Impossible`。", "hint": "对于 $100\\%$ 数据，满足 $1\\le M\\le 20$，$0\\le N\\le M$，$1\\le P\\le 100$。\n\n**【题目来源】**\n\nNOIP 2003 提高组第二题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2003 Senior] Detective Reasoning", "background": null, "description": "Mingming has recently become obsessed with the detective manga \"Conan\" and is immersed in deduction games, so he gathered a group of classmates to play a reasoning game. The game goes like this: Mingming's classmates agree in advance that one of them will act as the criminal (without Mingming knowing). Mingming's task is to find out who the criminal is. Then Mingming asks each classmate one by one, and the respondent may say:\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|l|l|}\\hline\n\\textbf{\\textsf{Statement Content}} & \\textbf{\\textsf{Meaning of the Statement}}\\\\\\hline\n\\text{I am guilty.} & \\text{I am the criminal.} \\\\\\hline\n\\text{I am not guilty.} & \\text{I am not the criminal.} \\\\\\hline\n\\text{{\\tt XXX} is guilty.} & \\text{{\\tt XXX} is the criminal. Here, {\\tt XXX} denotes a student's name.} \\\\\\hline\n\\text{{\\tt XXX} is not guilty.} & \\text{{\\tt XXX} is not the criminal.} \\\\\\hline\n\\text{Today is {\\tt XXX}.} &\n\\begin{aligned}\n&\\text{Today is {\\tt XXX}. Here, {\\tt XXX} denotes a day of the week.}\\\\\n&\\text{The day of the week can only be one of the following:}\\\\\n&\\texttt{Monday}, \\texttt{Tuesday}, \\texttt{Wednesday}, \\texttt{Thursday}, \\\\\n&\\texttt{Friday}, \\texttt{Saturday}, \\texttt{Sunday}.\n\\end{aligned}\n\\\\\\hline\n\\end{array}$$\n\nAny other words that appear in the statements are not included in the logical reasoning.\n\nWhat Mingming knows is that among his classmates, there are $N$ people who always lie, and the rest always tell the truth.\n\nNow Mingming needs you to help him deduce from his classmates' statements who the real criminal is. Remember, there is exactly one criminal!", "inputFormat": "The input consists of multiple lines.\n\nThe first line contains three integers, $M$, $N$, and $P$. $M$ is the number of Mingming's classmates participating in the game, $N$ is the number of people who always lie, and $P$ is the total number of statements.\n\nThe next $M$ lines each contain the name of one of Mingming's classmates (composed of English letters, no spaces, all uppercase).\n\nThen there are $P$ lines. Each line starts with a classmate's name, immediately followed by a colon and a space, and then a single statement that matches one of the formats listed in the table above. Each statement line will not exceed 250 characters.\n\nThe input will not contain two consecutive spaces, and there are no leading or trailing spaces on any line.", "outputFormat": "If your program can determine who the criminal is, output his name. If the program determines that more than one person could be the criminal, output `Cannot Determine`. If the program determines that no one could be the criminal, output `Impossible`.", "hint": "For 100% of the testdata, $1 \\le M \\le 20$, $0 \\le N \\le M$, $1 \\le P \\le 100$.\n\nSource: NOIP 2003 Senior, Problem 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2003 提高组] 侦探推理", "background": null, "description": "明明同学最近迷上了侦探漫画《柯南》并沉醉于推理游戏之中，于是他召集了一群同学玩推理游戏。游戏的内容是这样的，明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|l|l|}\\hline\n\\textbf{\\textsf{证词内容}} & \\textbf{\\textsf{证词含义}}\\\\\\hline\n\\text{I am guilty.} & \\text{我是罪犯。} \\\\\\hline\n\\text{I am not guilty.} & \\text{我不是罪犯。} \\\\\\hline\n\\text{{\\tt XXX} is guilty.} & \\text{{\\tt XXX} 是罪犯。其中 {\\tt XXX} 表示某个同学的名字。} \\\\\\hline\n\\text{{\\tt XXX} is not guilty.} & \\text{{\\tt XXX} 不是罪犯。} \\\\\\hline\n\\text{Today is {\\tt XXX}.} &\n\\begin{aligned}\n&\\text{今天是 {\\tt XXX}。其中 {\\tt XXX} 表示某个星期的单词。}\\\\\n&\\text{星期只有可能是以下之一：}\\\\\n&\\texttt{Monday}, \\texttt{Tuesday}, \\texttt{Wednesday}, \\texttt{Thursday}, \\\\\n&\\texttt{Friday}, \\texttt{Saturday}, \\texttt{Sunday}。\n\\end{aligned}\n\\\\\\hline\n\\end{array}$$\n\n证词中出现的其他话，都不列入逻辑推理的内容。\n\n\n明明所知道的是，他的同学中有 $N$ 个人始终说假话，其余的人始终说真。\n\n\n现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！", "inputFormat": "输入由若干行组成。\n\n第一行有三个整数，$M,N$ 和 $P$。$M$ 是参加游戏的明明的同学数，$N$ 是其中始终说谎的人数，$P$ 是证言的总数。  \n  \n接下来 $M$ 行，每行是明明的一个同学的名字（英文字母组成，没有空格，全部大写）。\n\n往后有 $P$ 行，每行开始是某个同学的名字，紧跟着一个冒号和一个空格，后面是一句证词，符合前表中所列格式。证词每行不会超过 $250$ 个字符。\n\n输入中不会出现连续的两个空格，而且每行开头和结尾也没有空格。", "outputFormat": "如果你的程序能确定谁是罪犯，则输出他的名字；如果程序判断出不止一个人可能是罪犯，则输出 `Cannot Determine`；如果程序判断出没有人可能成为罪犯，则输出 `Impossible`。", "hint": "对于 $100\\%$ 数据，满足 $1\\le M\\le 20$，$0\\le N\\le M$，$1\\le P\\le 100$。\n\n**【题目来源】**\n\nNOIP 2003 提高组第二题", "locale": "zh-CN"}}}
{"pid": "P1040", "type": "P", "difficulty": 4, "samples": [["5\n5 7 1 2 10\n", "145\n3 1 2 4 5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2003", "递归", "NOIP 提高组", "Special Judge", "O2优化", "区间 DP"], "title": "[NOIP 2003 提高组] 加分二叉树", "background": "", "description": "设一个 $n$ 个节点的二叉树 $\\text{tree}$ 的中序遍历为$(1,2,3,\\ldots,n)$，其中数字 $1,2,3,\\ldots,n$ 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，$\\text{tree}$ 及它的每个子树都有一个加分，任一棵子树 $\\text{subtree}$（也包含 $\\text{tree}$ 本身）的加分计算方法如下：\n\n\n$\\text{subtree}$ 的左子树的加分 $\\times$ $\\text{subtree}$ 的右子树的加分 $+$ $\\text{subtree}$ 的根的分数。\n\n若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。\n\n试求一棵符合中序遍历为 $(1,2,3,\\ldots,n)$ 且加分最高的二叉树 $\\text{tree}$。要求输出\n\n1. $\\text{tree}$ 的最高加分。\n\n2. $\\text{tree}$ 的前序遍历。", "inputFormat": "第 $1$ 行 $1$ 个整数 $n$，为节点个数。\n\n第 $2$ 行 $n$ 个用空格隔开的整数，为每个节点的分数\n", "outputFormat": "第 $1$ 行 $1$ 个整数，为最高加分（$ Ans \\le 4,000,000,000$）。\n\n第 $2$ 行 $n$ 个用空格隔开的整数，为该树的前序遍历。\n\n", "hint": "### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n< 30$，节点的分数是小于 $100$ 的正整数，答案不超过 $4 \\times 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2003 Senior] Scoring Binary Tree", "background": null, "description": "Let a binary tree $\\text{tree}$ with $n$ nodes have an inorder traversal of $(1, 2, 3, \\ldots, n)$, where $1, 2, 3, \\ldots, n$ are the node indices. Each node has a positive integer score; denote the score of node $i$ as $d_i$. The tree and each of its subtrees have a score. For any subtree $\\text{subtree}$ (including $\\text{tree}$ itself), its score is computed as follows:\n\nscore of the left subtree of $\\text{subtree}$ $\\times$ score of the right subtree of $\\text{subtree}$ $+$ score of the root of $\\text{subtree}$.\n\nIf a subtree is empty, its score is defined as $1$. The score of a leaf equals the score of the leaf node itself; its empty children are not considered.\n\nFind a binary tree $\\text{tree}$ whose inorder traversal is $(1, 2, 3, \\ldots, n)$ and whose score is maximized. Output:\n1. The maximum score of $\\text{tree}$.\n2. The preorder traversal of $\\text{tree}$.", "inputFormat": "The first line contains one integer $n$, the number of nodes.\n\nThe second line contains $n$ space-separated integers, the score of each node.", "outputFormat": "The first line contains one integer, the maximum score ($Ans \\le 4,000,000,000$).\n\nThe second line contains $n$ space-separated integers, the preorder traversal of the tree.", "hint": "Constraints\n\nFor all testdata, it is guaranteed that $1 \\le n < 30$, each node’s score is a positive integer less than $100$, and the answer does not exceed $4 \\times 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2003 提高组] 加分二叉树", "background": "", "description": "设一个 $n$ 个节点的二叉树 $\\text{tree}$ 的中序遍历为$(1,2,3,\\ldots,n)$，其中数字 $1,2,3,\\ldots,n$ 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，$\\text{tree}$ 及它的每个子树都有一个加分，任一棵子树 $\\text{subtree}$（也包含 $\\text{tree}$ 本身）的加分计算方法如下：\n\n\n$\\text{subtree}$ 的左子树的加分 $\\times$ $\\text{subtree}$ 的右子树的加分 $+$ $\\text{subtree}$ 的根的分数。\n\n若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。\n\n试求一棵符合中序遍历为 $(1,2,3,\\ldots,n)$ 且加分最高的二叉树 $\\text{tree}$。要求输出\n\n1. $\\text{tree}$ 的最高加分。\n\n2. $\\text{tree}$ 的前序遍历。", "inputFormat": "第 $1$ 行 $1$ 个整数 $n$，为节点个数。\n\n第 $2$ 行 $n$ 个用空格隔开的整数，为每个节点的分数\n", "outputFormat": "第 $1$ 行 $1$ 个整数，为最高加分（$ Ans \\le 4,000,000,000$）。\n\n第 $2$ 行 $n$ 个用空格隔开的整数，为该树的前序遍历。\n\n", "hint": "### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n< 30$，节点的分数是小于 $100$ 的正整数，答案不超过 $4 \\times 10^9$。", "locale": "zh-CN"}}}
{"pid": "P1041", "type": "P", "difficulty": 5, "samples": [["7 6\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2003", "NOIP 提高组"], "title": "[NOIP 2003 提高组] 传染病控制（疑似错题）", "background": "本题是错题，后来被证明没有靠谱的多项式复杂度的做法。测试数据非常的水，各种玄学做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。本题的难度仅代表设计算法可以通过本题原始数据的难度。\n\n[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)\n\n---\n\n近来，一种新的传染病肆虐全球。蓬莱国也发现了零星感染者，为防止该病在蓬莱国大范围流行，该国政$ $府决定不惜一切代价控制传染病的蔓延。不幸的是，由于人们尚未完全认识这种传染病，难以准确判别病毒携带者，更没有研制出疫苗以保护易感人群。于是，蓬莱国的疾病控制中心决定采取切断传播途径的方法控制疾病传播。经过 WHO（世界卫生组织）以及全球各国科研部门的努力，这种新兴传染病的传播途径和控制方法已经研究清楚，剩下的任务就是由你协助蓬莱国疾控中心制定一个有效的控制办法。\n", "description": "研究表明，这种传染病的传播具有两种很特殊的性质；\n\n第一是它的传播途径是树型的，一个人 $X$ 只可能被某个特定的人 $Y$ 感染，只要 $Y$ 不得病，或者是 $XY$ 之间的传播途径被切断，则 $X$ 就不会得病。\n\n\n第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。\n\n\n这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。\n\n\n你的程序要针对给定的树，找出合适的切断顺序。\n\n", "inputFormat": "输入格式：  \n第一行是两个整数 $n$ 和 $p$。  \n接下来 $p$ 行，每一行有 $2$ 个整数 $i$ 和 $j$，表示节点 $i$ 和 $j$ 间有边相连。（意即，第 $i$ 人和第 $j$ 人之间有传播途径相连）。其中节点 $1$ 是已经被感染的患者。\n", "outputFormat": "$1$ 行，总共被感染的人数。\n", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 300$。\n\n**【题目来源】**\n\nNOIP 2003 提高组第四题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2003 Senior] Infectious Disease Control (suspected wrong problem)", "background": null, "description": "Studies show that this infectious disease has two very special properties.\n\nFirst, its transmission routes form a tree. A person $X$ can only be infected by a specific person $Y$. As long as $Y$ does not get sick, or the transmission route between $X$ and $Y$ (i.e., $XY$) is cut, $X$ will not get sick.\n\nSecond, the disease spreads periodically. Within one transmission period, it infects only one generation of patients, and does not spread further to the next generation in that period.\n\nThese properties greatly reduce the pressure on Penglai’s disease control efforts, and they have already obtained a potential transmission map (a tree) for part of the susceptible population. However, the problem is not over. Due to limited manpower and technology, during one transmission period they can cut only one transmission route. Any remaining, uncontrolled routes will cause more susceptible people to be infected (that is, people who are connected to the currently infected by a transmission route that has not been cut). When it becomes impossible for any healthy person to be infected, the disease stops spreading. Therefore, Penglai’s CDC must decide an order in which to cut transmission routes so that as few people as possible become infected.\n\nYour program must, for the given tree, find an appropriate cutting order.", "inputFormat": "The first line contains two integers $n$ and $p$.  \nThe next $p$ lines each contain two integers $i$ and $j$, indicating there is an edge between nodes $i$ and $j$ (that is, there is a transmission route between person $i$ and person $j$). Node $1$ is already infected. The graph is a tree, so $p = n - 1$.", "outputFormat": "One line: the total number of people who get infected.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\leq n \\leq 300$.\n\nSource: NOIP 2003 Senior, Problem 4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2003 提高组] 传染病控制（疑似错题）", "background": "本题是错题，后来被证明没有靠谱的多项式复杂度的做法。测试数据非常的水，各种玄学做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。本题的难度仅代表设计算法可以通过本题原始数据的难度。\n\n[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)\n\n---\n\n近来，一种新的传染病肆虐全球。蓬莱国也发现了零星感染者，为防止该病在蓬莱国大范围流行，该国政$ $府决定不惜一切代价控制传染病的蔓延。不幸的是，由于人们尚未完全认识这种传染病，难以准确判别病毒携带者，更没有研制出疫苗以保护易感人群。于是，蓬莱国的疾病控制中心决定采取切断传播途径的方法控制疾病传播。经过 WHO（世界卫生组织）以及全球各国科研部门的努力，这种新兴传染病的传播途径和控制方法已经研究清楚，剩下的任务就是由你协助蓬莱国疾控中心制定一个有效的控制办法。\n", "description": "研究表明，这种传染病的传播具有两种很特殊的性质；\n\n第一是它的传播途径是树型的，一个人 $X$ 只可能被某个特定的人 $Y$ 感染，只要 $Y$ 不得病，或者是 $XY$ 之间的传播途径被切断，则 $X$ 就不会得病。\n\n\n第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。\n\n\n这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。\n\n\n你的程序要针对给定的树，找出合适的切断顺序。\n\n", "inputFormat": "输入格式：  \n第一行是两个整数 $n$ 和 $p$。  \n接下来 $p$ 行，每一行有 $2$ 个整数 $i$ 和 $j$，表示节点 $i$ 和 $j$ 间有边相连。（意即，第 $i$ 人和第 $j$ 人之间有传播途径相连）。其中节点 $1$ 是已经被感染的患者。\n", "outputFormat": "$1$ 行，总共被感染的人数。\n", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 300$。\n\n**【题目来源】**\n\nNOIP 2003 提高组第四题", "locale": "zh-CN"}}}
{"pid": "P1042", "type": "P", "difficulty": 2, "samples": [["WWWWWWWWWWWWWWWWWWWW\nWWLWE\n", "11:0\n11:0\n1:1\n\n21:0\n2:1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "字符串", "2003", "NOIP 普及组"], "title": "[NOIP 2003 普及组] 乒乓球", "background": "国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中 $11$ 分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白 $11$ 分制和 $21$ 分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。", "description": "华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在 $11$ 分制和 $21$ 分制下，双方的比赛结果（截至记录末尾）。\n\n比如现在有这么一份记录，（其中 $\\texttt W$ 表示华华获得一分，$\\texttt L$ 表示华华对手获得一分）：\n\n$$\\texttt{WWWWWWWWWWWWWWWWWWWWWWLW}$$\n\n在 $11$ 分制下，此时比赛的结果是华华第一局 $11$ 比 $0$ 获胜，第二局 $11$ 比 $0$ 获胜，正在进行第三局，当前比分 $1$ 比 $1$。而在 $21$ 分制下，此时比赛结果是华华第一局 $21$ 比 $0$ 获胜，正在进行第二局，比分 $2$ 比 $1$。如果一局比赛刚开始，则此时比分为 $0$ 比 $0$。直到分差大于或者等于 $2$，才一局结束。\n\n**注意：当一局比赛结束后，下一局立刻开始**。\n\n你的程序就是要对于一系列比赛信息的输入（$\\texttt{WL}$ 形式），输出正确的结果。\n", "inputFormat": "每个输入文件包含若干行字符串，字符串由大写的 $\\texttt W$ 、 $\\texttt L$ 和 $\\texttt E$ 组成。其中 $\\texttt E$ 表示比赛信息结束，程序应该忽略 $\\texttt E$ 之后的所有内容。", "outputFormat": "输出由两部分组成，每部分有若干行，每一行对应一局比赛的比分（按比赛信息输入顺序）。其中第一部分是 $11$ 分制下的结果，第二部分是 $21$ 分制下的结果，两部分之间由一个空行分隔。", "hint": "每行至多 $25$ 个字母，最多有 $2500$ 行。\n\n**【管理员附注】**\n\n本题为非常早期的试题，在测试点中出现了如下两个问题。在洛谷上这两个测试点的疏漏被保留：\n\n1. 有一个测试点实际上有 $2501$ 行数据。\n2. 有一个测试点的输入数据出现了非 $\\texttt W$ 、 $\\texttt L$ 和 $\\texttt E$ 的字符，不符合输入格式的要求。不过这些字符只出现在 $\\texttt E$ 字符之后，按题目要求忽略 $\\texttt E$ 之后的全部字符即可。\n\n**【题目来源】**\n\nNOIP 2003 普及组第一题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2003 Junior] Table Tennis", "background": null, "description": "Huahua analyzes the match in the following way: first, list the outcome of each rally, then compute the match results under the $11$-point system and the $21$-point system (up to the end of the record).\n\nFor example, consider the following record (where $\\texttt W$ means Huahua scores a point, and $\\texttt L$ means Huahua’s opponent scores a point):\n\n$$\\texttt{WWWWWWWWWWWWWWWWWWWWWWLW}$$\n\nUnder the $11$-point system, Huahua wins game $1$ by $11$ to $0$, wins game $2$ by $11$ to $0$, and game $3$ is in progress with the current score $1$ to $1$. Under the $21$-point system, Huahua wins game $1$ by $21$ to $0$, and game $2$ is in progress with the score $2$ to $1$. If a game has just started, the score is $0$ to $0$. A game ends only when the point difference is greater than or equal to $2$.\n\nNote: Once a game ends, the next one starts immediately.\n\nYour program should read a sequence of match information in the form of $\\texttt{WL}$ and output the correct results.", "inputFormat": "The input consists of several lines, each being a string of uppercase $\\texttt W$, $\\texttt L$, and $\\texttt E$. The character $\\texttt E$ indicates the end of the match information; the program should ignore everything after $\\texttt E$.", "outputFormat": "The output has two parts. Each part contains several lines, and each line corresponds to the score of one game (in the order implied by the input record). The first part is the result under the $11$-point system, and the second part is the result under the $21$-point system. The two parts are separated by one blank line.", "hint": "- Each line contains at most $25$ letters, and there are at most $2500$ lines.\n\n【Admin Note】\n\nThis is a very early problem, and there are two issues in the test points. These are kept as-is on Luogu:\n\n1. One test point actually contains $2501$ lines.\n2. One test point includes characters other than $\\texttt W$, $\\texttt L$, and $\\texttt E$, which do not conform to the input format. However, those characters only appear after $\\texttt E$, and per the statement, all content after $\\texttt E$ should be ignored.\n\n【Problem Source】\n\nNOIP 2003 Junior, Problem 1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2003 普及组] 乒乓球", "background": "国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中 $11$ 分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白 $11$ 分制和 $21$ 分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。", "description": "华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在 $11$ 分制和 $21$ 分制下，双方的比赛结果（截至记录末尾）。\n\n比如现在有这么一份记录，（其中 $\\texttt W$ 表示华华获得一分，$\\texttt L$ 表示华华对手获得一分）：\n\n$$\\texttt{WWWWWWWWWWWWWWWWWWWWWWLW}$$\n\n在 $11$ 分制下，此时比赛的结果是华华第一局 $11$ 比 $0$ 获胜，第二局 $11$ 比 $0$ 获胜，正在进行第三局，当前比分 $1$ 比 $1$。而在 $21$ 分制下，此时比赛结果是华华第一局 $21$ 比 $0$ 获胜，正在进行第二局，比分 $2$ 比 $1$。如果一局比赛刚开始，则此时比分为 $0$ 比 $0$。直到分差大于或者等于 $2$，才一局结束。\n\n**注意：当一局比赛结束后，下一局立刻开始**。\n\n你的程序就是要对于一系列比赛信息的输入（$\\texttt{WL}$ 形式），输出正确的结果。\n", "inputFormat": "每个输入文件包含若干行字符串，字符串由大写的 $\\texttt W$ 、 $\\texttt L$ 和 $\\texttt E$ 组成。其中 $\\texttt E$ 表示比赛信息结束，程序应该忽略 $\\texttt E$ 之后的所有内容。", "outputFormat": "输出由两部分组成，每部分有若干行，每一行对应一局比赛的比分（按比赛信息输入顺序）。其中第一部分是 $11$ 分制下的结果，第二部分是 $21$ 分制下的结果，两部分之间由一个空行分隔。", "hint": "每行至多 $25$ 个字母，最多有 $2500$ 行。\n\n**【管理员附注】**\n\n本题为非常早期的试题，在测试点中出现了如下两个问题。在洛谷上这两个测试点的疏漏被保留：\n\n1. 有一个测试点实际上有 $2501$ 行数据。\n2. 有一个测试点的输入数据出现了非 $\\texttt W$ 、 $\\texttt L$ 和 $\\texttt E$ 的字符，不符合输入格式的要求。不过这些字符只出现在 $\\texttt E$ 字符之后，按题目要求忽略 $\\texttt E$ 之后的全部字符即可。\n\n**【题目来源】**\n\nNOIP 2003 普及组第一题", "locale": "zh-CN"}}}
{"pid": "P1043", "type": "P", "difficulty": 4, "samples": [["4 2\n4\n3\n-1\n2\n", "7\n81\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "2003", "NOIP 普及组", "区间 DP", "前缀和"], "title": "[NOIP 2003 普及组] 数字游戏", "background": "", "description": "丁丁最近沉迷于一个数字游戏之中。这个游戏看似简单，但丁丁在研究了许多天之后却发觉原来在简单的规则下想要赢得这个游戏并不那么容易。游戏是这样的，在你面前有一圈整数（一共 $n$ 个），你要按顺序将其分为 $m$ 个部分，各部分内的数字相加，相加所得的 $m$ 个结果对 $10$ 取模后再相乘，最终得到一个数 $k$。游戏的要求是使你所得的 $k$ 最大或者最小。\n\n\n例如，对于下面这圈数字（$n=4$，$m=2$）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gy407k49.png)\n\n要求最小值时，$((2-1)\\bmod10)\\times ((4+3)\\bmod10)=1\\times 7=7$，要求最大值时，为 $((2+4+3)\\bmod10)\\times (-1\\bmod10)=9\\times 9=81$。特别值得注意的是，无论是负数还是正数，对 $10$ 取模的结果均为非负值。\n\n丁丁请你编写程序帮他赢得这个游戏。\n", "inputFormat": "输入文件第一行有两个整数，$n$ （$1\\le n\\le 50$） 和 $m$ （$1\\le m\\le 9$）。以下 $n$ 行每行有个整数，其绝对值 $\\le10^4$，按顺序给出圈中的数字，首尾相接。", "outputFormat": "输出文件有 $2$ 行，各包含 $1$ 个非负整数。第 $1$ 行是你程序得到的最小值，第 $2$ 行是最大值。", "hint": "**【题目来源】**\n\nNOIP 2003 普及组第二题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2003 Junior] Number Game", "background": null, "description": "Dingding has recently become obsessed with a number game. The game looks simple, but after many days of study he realized that winning under the simple rules is not easy. The game is as follows: in front of you is a circle of integers (a total of $n$), and you must split them, in order, into $m$ consecutive parts. Within each part, sum the numbers; take each of the $m$ sums modulo $10$, then multiply these $m$ results to obtain a number $k$. The goal is to make $k$ as large as possible or as small as possible.\n\nFor example, for the following circle of numbers ($n=4$, $m=2$):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gy407k49.png)\n\nFor the minimum, $((2-1)\\bmod10)\\times ((4+3)\\bmod10)=1\\times 7=7$. For the maximum, $((2+4+3)\\bmod10)\\times (-1\\bmod10)=9\\times 9=81$. Note in particular that, whether a number is negative or positive, the result of taking modulo $10$ is always non-negative.\n\nPlease write a program to help Dingding win this game.", "inputFormat": "The first line contains two integers, $n$ ($1\\le n\\le 50$) and $m$ ($1\\le m\\le 9$). Each of the next $n$ lines contains one integer with absolute value $\\le 10^4$, given in order around the circle, with the ends connected.", "outputFormat": "Output $2$ lines, each containing $1$ non-negative integer. The first line is the minimum value your program obtains, and the second line is the maximum value.", "hint": "Problem Source: NOIP 2003 Junior, Problem 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2003 普及组] 数字游戏", "background": "", "description": "丁丁最近沉迷于一个数字游戏之中。这个游戏看似简单，但丁丁在研究了许多天之后却发觉原来在简单的规则下想要赢得这个游戏并不那么容易。游戏是这样的，在你面前有一圈整数（一共 $n$ 个），你要按顺序将其分为 $m$ 个部分，各部分内的数字相加，相加所得的 $m$ 个结果对 $10$ 取模后再相乘，最终得到一个数 $k$。游戏的要求是使你所得的 $k$ 最大或者最小。\n\n\n例如，对于下面这圈数字（$n=4$，$m=2$）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gy407k49.png)\n\n要求最小值时，$((2-1)\\bmod10)\\times ((4+3)\\bmod10)=1\\times 7=7$，要求最大值时，为 $((2+4+3)\\bmod10)\\times (-1\\bmod10)=9\\times 9=81$。特别值得注意的是，无论是负数还是正数，对 $10$ 取模的结果均为非负值。\n\n丁丁请你编写程序帮他赢得这个游戏。\n", "inputFormat": "输入文件第一行有两个整数，$n$ （$1\\le n\\le 50$） 和 $m$ （$1\\le m\\le 9$）。以下 $n$ 行每行有个整数，其绝对值 $\\le10^4$，按顺序给出圈中的数字，首尾相接。", "outputFormat": "输出文件有 $2$ 行，各包含 $1$ 个非负整数。第 $1$ 行是你程序得到的最小值，第 $2$ 行是最大值。", "hint": "**【题目来源】**\n\nNOIP 2003 普及组第二题", "locale": "zh-CN"}}}
{"pid": "P1044", "type": "P", "difficulty": 2, "samples": [["3\n", "5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "数学", "递推", "2003", "NOIP 普及组", "Catalan 数", "栈"], "title": "[NOIP 2003 普及组] 栈", "background": "栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。\n\n栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。\n\n栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png)\n\n宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。\n\n现在可以进行两种操作，\n\n1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）\n2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）\n\n使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 `1 2 3` 生成序列 `2 3 1` 的过程。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png)\n\n（原始状态如上图所示）\n\n你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\\ldots,n$ 经过操作可能得到的输出序列的总数。", "inputFormat": "输入文件只含一个整数 $n$（$1 \\leq n \\leq 18$）。\n", "outputFormat": "输出文件只有一行，即可能输出序列的总数目。", "hint": "**【题目来源】**\n\nNOIP 2003 普及组第三题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2003 Junior] Stack", "background": null, "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png)\n\nNingning considers the following problem: given an operand sequence $1, 2, \\ldots, n$ (the figure illustrates the case for $1$ to $3$), stack A has depth greater than $n$.\n\nTwo operations are allowed:\n1. Move a number from the head of the operand sequence to the top of the stack (corresponding to the stack push operation).\n2. Move a number from the top of the stack to the end of the output sequence (corresponding to the stack pop operation).\n\nUsing these two operations, one operand sequence can produce a set of output sequences. The following figure shows the process of generating the sequence `2 3 1` from `1 2 3`.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png)\n\n(The initial state is as shown above.)\n\nFor a given $n$, your program should compute and output the total number of output sequences that can be obtained from the operand sequence $1, 2, \\ldots, n$ through these operations.", "inputFormat": "The input contains a single integer $n$ ($1 \\leq n \\leq 18$).", "outputFormat": "Output a single line containing the total number of possible output sequences.", "hint": "Source: NOIP 2003 Junior, Problem 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2003 普及组] 栈", "background": "栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。\n\n栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。\n\n栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png)\n\n宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。\n\n现在可以进行两种操作，\n\n1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）\n2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）\n\n使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 `1 2 3` 生成序列 `2 3 1` 的过程。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png)\n\n（原始状态如上图所示）\n\n你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\\ldots,n$ 经过操作可能得到的输出序列的总数。", "inputFormat": "输入文件只含一个整数 $n$（$1 \\leq n \\leq 18$）。\n", "outputFormat": "输出文件只有一行，即可能输出序列的总数目。", "hint": "**【题目来源】**\n\nNOIP 2003 普及组第三题", "locale": "zh-CN"}}}
{"pid": "P1045", "type": "P", "difficulty": 3, "samples": [["1279\n", "386\n00000000000000000000000000000000000000000000000000\n00000000000000000000000000000000000000000000000000\n00000000000000104079321946643990819252403273640855\n38615262247266704805319112350403608059673360298012\n23944173232418484242161395428100779138356624832346\n49081399066056773207629241295093892203457731833496\n61583550472959420547689811211693677147548478866962\n50138443826029173234888531116082853841658502825560\n46662248318909188018470682222031405210266984354887\n32958028878050869736186900714720710555703168729087\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "高精度", "2003", "NOIP 普及组"], "title": "[NOIP 2003 普及组] 麦森数", "background": "", "description": "形如 $2^{P}-1$ 的素数称为麦森数，这时 $P$ 一定也是个素数。但反过来不一定，即如果 $P$ 是个素数，$2^{P}-1$ 不一定也是素数。到 1998 年底，人们已找到了 37 个麦森数。最大的一个是 $P=3021377$，它有 909526 位。麦森数有许多重要应用，它与完全数密切相关。\n\n任务：输入 $P(1000<P<3100000)$，计算 $2^{P}-1$ 的位数和最后 $500$ 位数字（用十进制高精度数表示）\n", "inputFormat": "文件中只包含一个整数 $P(1000<P<3100000)$\n", "outputFormat": "第一行：十进制高精度数 $2^{P}-1$ 的位数。\n\n第 $2\\sim 11$ 行：十进制高精度数 $2^{P}-1$ 的最后 $500$ 位数字。（每行输出 $50$ 位，共输出 $10$ 行，不足 $500$ 位时高位补 $0$）\n\n不必验证 $2^{P}-1$ 与 $P$ 是否为素数。\n", "hint": "**【题目来源】**\n\nNOIP 2003 普及组第四题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2003 Junior] Mersenne Number", "background": null, "description": "A prime of the form $2^{P}-1$ is called a \"Mersenne number\"; in that case $P$ must also be a prime. The converse is not necessarily true, i.e., even if $P$ is prime, $2^{P}-1$ may not be prime. By the end of 1998, 37 Mersenne numbers had been found. The largest one had $P=3021377$, and it has 909526 digits. Mersenne numbers have many important applications and are closely related to perfect numbers.\n\nTask: Given $P$ ($1000<P<3100000$), compute the number of digits of $2^{P}-1$ and the last $500$ digits (in decimal big integer representation).", "inputFormat": "The file contains a single integer $P$ ($1000<P<3100000$).", "outputFormat": "- Line 1: The number of digits of the decimal big integer $2^{P}-1$.\n- Lines 2–11: The last $500$ digits of the decimal big integer $2^{P}-1$ (50 digits per line, 10 lines in total; if there are fewer than 500 digits, pad with leading zeros on the most significant side).\n\nYou do not need to verify whether $2^{P}-1$ or $P$ is prime.", "hint": "**[Problem Source]**\n\nNOIP 2003 Junior Problem 4\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2003 普及组] 麦森数", "background": "", "description": "形如 $2^{P}-1$ 的素数称为麦森数，这时 $P$ 一定也是个素数。但反过来不一定，即如果 $P$ 是个素数，$2^{P}-1$ 不一定也是素数。到 1998 年底，人们已找到了 37 个麦森数。最大的一个是 $P=3021377$，它有 909526 位。麦森数有许多重要应用，它与完全数密切相关。\n\n任务：输入 $P(1000<P<3100000)$，计算 $2^{P}-1$ 的位数和最后 $500$ 位数字（用十进制高精度数表示）\n", "inputFormat": "文件中只包含一个整数 $P(1000<P<3100000)$\n", "outputFormat": "第一行：十进制高精度数 $2^{P}-1$ 的位数。\n\n第 $2\\sim 11$ 行：十进制高精度数 $2^{P}-1$ 的最后 $500$ 位数字。（每行输出 $50$ 位，共输出 $10$ 行，不足 $500$ 位时高位补 $0$）\n\n不必验证 $2^{P}-1$ 与 $P$ 是否为素数。\n", "hint": "**【题目来源】**\n\nNOIP 2003 普及组第四题", "locale": "zh-CN"}}}
{"pid": "P1046", "type": "P", "difficulty": 1, "samples": [["100 200 150 140 129 134 167 198 200 111\n110\n", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2005", "NOIP 普及组"], "title": "[NOIP 2005 普及组] 陶陶摘苹果", "background": "", "description": "陶陶家的院子里有一棵苹果树，每到秋天树上就会结出 $10$ 个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个 $30$ 厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。\n\n\n现在已知 $10$ 个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。\n", "inputFormat": "输入包括两行数据。第一行包含 $10$ 个 $100$ 到 $200$ 之间（包括 $100$ 和 $200$）的整数（以厘米为单位）分别表示 $10$ 个苹果到地面的高度，两个相邻的整数之间用一个空格隔开。第二行只包括一个 $100$ 到 $120$ 之间（包含 $100$ 和 $120$）的整数（以厘米为单位），表示陶陶把手伸直的时候能够达到的最大高度。\n\n", "outputFormat": "输出包括一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。\n", "hint": "**【题目来源】**\n\nNOIP 2005 普及组第一题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2005 Junior] Taotao Picks Apples", "background": null, "description": "There is an apple tree in Taotao’s yard. Every autumn the tree bears $10$ apples. When the apples ripen, Taotao goes to pick them. Taotao has a $30$-centimeter-tall stool; when she cannot reach an apple directly with her hand, she will step on the stool and try again.\n\nNow you are given the heights above the ground of the $10$ apples, and the maximum height Taotao can reach when she stretches out her hand. Please help Taotao calculate how many apples she can pick. Assume that if she touches an apple, it will fall.", "inputFormat": "The input consists of two lines of data. The first line contains $10$ integers between $100$ and $200$ inclusive (in centimeters), representing the heights above the ground of the $10$ apples, separated by single spaces. The second line contains a single integer between $100$ and $120$ inclusive (in centimeters), representing the maximum height Taotao can reach when she stretches out her hand.", "outputFormat": "Output a single line containing one integer, which is the number of apples Taotao can pick.", "hint": "[Source]\n\nNOIP 2005 Junior, Problem 1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2005 普及组] 陶陶摘苹果", "background": "", "description": "陶陶家的院子里有一棵苹果树，每到秋天树上就会结出 $10$ 个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个 $30$ 厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。\n\n\n现在已知 $10$ 个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。\n", "inputFormat": "输入包括两行数据。第一行包含 $10$ 个 $100$ 到 $200$ 之间（包括 $100$ 和 $200$）的整数（以厘米为单位）分别表示 $10$ 个苹果到地面的高度，两个相邻的整数之间用一个空格隔开。第二行只包括一个 $100$ 到 $120$ 之间（包含 $100$ 和 $120$）的整数（以厘米为单位），表示陶陶把手伸直的时候能够达到的最大高度。\n\n", "outputFormat": "输出包括一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。\n", "hint": "**【题目来源】**\n\nNOIP 2005 普及组第一题", "locale": "zh-CN"}}}
{"pid": "P1047", "type": "P", "difficulty": 1, "samples": [["500 3\n150 300\n100 200\n470 471\n", "298"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2005", "NOIP 普及组"], "title": "[NOIP 2005 普及组] 校门外的树", "background": "", "description": "某校大门外长度为 $l$ 的马路上有一排树，每两棵相邻的树之间的间隔都是 $1$ 米。我们可以把马路看成一个数轴，马路的一端在数轴 $0$ 的位置，另一端在 $l$ 的位置；数轴上的每个整数点，即 $0,1,2,\\dots,l$，都种有一棵树。\n\n\n由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。\n\n", "inputFormat": "第一行有两个整数，分别表示马路的长度 $l$ 和区域的数目 $m$。\n\n接下来 $m$ 行，每行两个整数 $u, v$，表示一个区域的起始点和终止点的坐标。", "outputFormat": "输出一行一个整数，表示将这些树都移走后，马路上剩余的树木数量。", "hint": "**【数据范围】**\n\n- 对于 $20\\%$ 的数据，保证区域之间没有重合的部分。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq l \\leq 10^4$，$1 \\leq m \\leq 100$，$0 \\leq u \\leq v \\leq l$。\n\n**【题目来源】**\n\nNOIP 2005 普及组第二题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2005 Junior] Trees Outside the School Gate", "background": null, "description": "There is a row of trees along a road of length $l$ outside a school's main gate. The distance between any two adjacent trees is $1$ meter. We can regard the road as a number line, with one end at position $0$ and the other end at $l$. At every integer point on the number line, namely $0, 1, 2, \\dots, l$, there is a tree.\n\nSome regions of the road will be used for building a subway. Each region is represented by its starting point and ending point on the number line. It is known that the coordinates of the starting and ending points of any region are integers, and different regions may overlap. All trees within these regions (including the two trees at the endpoints of each region) will be removed. Your task is to compute how many trees remain on the road after removing these trees.", "inputFormat": "The first line contains two integers, representing the road length $l$ and the number of regions $m$.\n\nThe next $m$ lines each contain two integers $u, v$, representing the starting point and ending point of a region.", "outputFormat": "Output a single integer on one line, representing the number of trees remaining on the road after the removal.", "hint": "- Constraints:\n  - For 20% of the testdata, the regions are guaranteed to be non-overlapping.\n  - For 100% of the testdata, $1 \\leq l \\leq 10^4$, $1 \\leq m \\leq 100$, $0 \\leq u \\leq v \\leq l$.\n\n- Source:\n  NOIP 2005 Junior - Problem 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2005 普及组] 校门外的树", "background": "", "description": "某校大门外长度为 $l$ 的马路上有一排树，每两棵相邻的树之间的间隔都是 $1$ 米。我们可以把马路看成一个数轴，马路的一端在数轴 $0$ 的位置，另一端在 $l$ 的位置；数轴上的每个整数点，即 $0,1,2,\\dots,l$，都种有一棵树。\n\n\n由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。\n\n", "inputFormat": "第一行有两个整数，分别表示马路的长度 $l$ 和区域的数目 $m$。\n\n接下来 $m$ 行，每行两个整数 $u, v$，表示一个区域的起始点和终止点的坐标。", "outputFormat": "输出一行一个整数，表示将这些树都移走后，马路上剩余的树木数量。", "hint": "**【数据范围】**\n\n- 对于 $20\\%$ 的数据，保证区域之间没有重合的部分。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq l \\leq 10^4$，$1 \\leq m \\leq 100$，$0 \\leq u \\leq v \\leq l$。\n\n**【题目来源】**\n\nNOIP 2005 普及组第二题", "locale": "zh-CN"}}}
{"pid": "P1048", "type": "P", "difficulty": 2, "samples": [["70 3\n71 100\n69 1\n1 2\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2005", "NOIP 普及组", "背包 DP"], "title": "[NOIP 2005 普及组] 采药", "background": "", "description": "辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”\n\n\n如果你是辰辰，你能完成这个任务吗？\n", "inputFormat": "第一行有 $2$ 个整数 $T$（$1 \\le T \\le 1000$）和 $M$（$1 \\le  M \\le 100$），用一个空格隔开，$T$ 代表总共能够用来采药的时间，$M$ 代表山洞里的草药的数目。\n\n接下来的 $M$ 行每行包括两个在 $1$ 到 $100$ 之间（包括 $1$ 和 $100$）的整数，分别表示采摘某株草药的时间和这株草药的价值。", "outputFormat": "输出在规定的时间内可以采到的草药的最大总价值。\n", "hint": "**【数据范围】**\n\n- 对于 $30\\%$ 的数据，$M \\le 10$；\n- 对于全部的数据，$M \\le 100$。\n\n**【题目来源】**\n\nNOIP 2005 普及组第三题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2005 Junior] Herb Picking", "background": null, "description": "Chenchen is a gifted child whose dream is to become the greatest physician in the world. To this end, he wants to apprentice with the most respected physician nearby. To assess his aptitude, the physician gave him a challenge. He took him to a cave full of herbs and said, “Child, there are different kinds of herbs in this cave. Picking each herb takes some time, and each has its own value. I will give you a period of time. During this time, you can pick some herbs. If you are clever, you should be able to maximize the total value of the herbs you pick.”\n\nIf you were Chenchen, could you complete this task?", "inputFormat": "The first line contains $2$ integers $T$ ($1 \\le T \\le 1000$) and $M$ ($1 \\le M \\le 100$), separated by a space. $T$ is the total time available for picking, and $M$ is the number of herbs in the cave.\n\nEach of the next $M$ lines contains two integers between $1$ and $100$ inclusive, representing the time to pick a herb and the value of that herb.", "outputFormat": "Output the maximum total value of herbs that can be picked within the given time.", "hint": "**Constraints**\n- For $30\\%$ of the testdata, $M \\le 10$.\n- For all testdata, $M \\le 100$.\n\n**Source**\nNOIP 2005 Junior, Problem 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2005 普及组] 采药", "background": "", "description": "辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”\n\n\n如果你是辰辰，你能完成这个任务吗？\n", "inputFormat": "第一行有 $2$ 个整数 $T$（$1 \\le T \\le 1000$）和 $M$（$1 \\le  M \\le 100$），用一个空格隔开，$T$ 代表总共能够用来采药的时间，$M$ 代表山洞里的草药的数目。\n\n接下来的 $M$ 行每行包括两个在 $1$ 到 $100$ 之间（包括 $1$ 和 $100$）的整数，分别表示采摘某株草药的时间和这株草药的价值。", "outputFormat": "输出在规定的时间内可以采到的草药的最大总价值。\n", "hint": "**【数据范围】**\n\n- 对于 $30\\%$ 的数据，$M \\le 10$；\n- 对于全部的数据，$M \\le 100$。\n\n**【题目来源】**\n\nNOIP 2005 普及组第三题", "locale": "zh-CN"}}}
{"pid": "P1049", "type": "P", "difficulty": 2, "samples": [["24\n6\n8\n3\n12\n7\n9\n7\n", "0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2001", "递归", "NOIP 普及组", "背包 DP"], "title": "[NOIP 2001 普及组] 装箱问题", "background": "", "description": "有一个箱子容量为 $V$，同时有 $n$ 个物品，每个物品有一个体积。\n\n\n现在从 $n$ 个物品中，任取若干个装入箱内（也可以不取），使箱子的剩余空间最小。输出这个最小值。", "inputFormat": "第一行共一个整数 $V$，表示箱子容量。\n\n第二行共一个整数 $n$，表示物品总数。\n\n接下来 $n$ 行，每行有一个正整数，表示第 $i$ 个物品的体积。", "outputFormat": "- 共一行一个整数，表示箱子最小剩余空间。\n", "hint": "对于 $100\\%$ 数据，满足 $0<n \\le 30$，$1 \\le V \\le 20000$。\n\n**【题目来源】**\n\nNOIP 2001 普及组第四题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2001 Junior] Box Packing Problem", "background": null, "description": "There is a box with capacity $V$, and there are $n$ items. Each item has a volume.\n\nNow choose any number of items from the $n$ items (possibly none) to put into the box, so that the remaining space in the box is minimized. Output this minimum value.", "inputFormat": "The first line contains a single integer $V$, indicating the capacity of the box.\n\nThe second line contains a single integer $n$, indicating the total number of items.\n\nThe next $n$ lines each contain a positive integer, where the $i$-th line gives the volume of the $i$-th item.", "outputFormat": "Output a single integer in one line, indicating the minimal remaining space in the box.", "hint": "Constraints:\n- $0 < n \\le 30$.\n- $1 \\le V \\le 20000$.\n\nSource: NOIP 2001 Junior, Problem 4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2001 普及组] 装箱问题", "background": "", "description": "有一个箱子容量为 $V$，同时有 $n$ 个物品，每个物品有一个体积。\n\n\n现在从 $n$ 个物品中，任取若干个装入箱内（也可以不取），使箱子的剩余空间最小。输出这个最小值。", "inputFormat": "第一行共一个整数 $V$，表示箱子容量。\n\n第二行共一个整数 $n$，表示物品总数。\n\n接下来 $n$ 行，每行有一个正整数，表示第 $i$ 个物品的体积。", "outputFormat": "- 共一行一个整数，表示箱子最小剩余空间。\n", "hint": "对于 $100\\%$ 数据，满足 $0<n \\le 30$，$1 \\le V \\le 20000$。\n\n**【题目来源】**\n\nNOIP 2001 普及组第四题", "locale": "zh-CN"}}}
{"pid": "P1050", "type": "P", "difficulty": 5, "samples": [["32 2", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "数学", "高精度", "递推", "2005", "NOIP 普及组"], "title": "[NOIP 2005 普及组] 循环", "background": null, "description": "乐乐是一个聪明而又勤奋好学的孩子。他总喜欢探求事物的规律。一天，他突然对数的正整数次幂产生了兴趣。\n\n\n众所周知，$2$ 的正整数次幂最后一位数总是不断的在重复 $2,4,8,6,2,4,8,6…$ 我们说 $2$ 的正整数次幂最后一位的循环长度是 $4$（实际上 $4$ 的倍数都可以说是循环长度，但我们只考虑最小的循环长度）。类似的，其余的数字的正整数次幂最后一位数也有类似的循环现象：\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{c|c|c}\\hline\n\\textbf{数字}& \\textbf{循环} & \\textbf{循环长度} \\cr\\hline\\hline\n2 & 2,4,8,6 & 4\\cr\\hline\n3 & 3,9,7,1 & 4\\cr\\hline\n4 & 4,6 & 2\\cr\\hline\n5 & 5 &  1\\cr\\hline\n6 & 6 & 1\\cr\\hline\n7 & 7,9,3,1 & 4\\cr\\hline\n8 & 8,4,2,6 & 4\\cr\\hline\n9 & 9,1 & 2\\cr\\hline\n\\end{array}\n$$\n\n这时乐乐的问题就出来了：是不是只有最后一位才有这样的循环呢？对于一个整数 $n$ 的正整数次幂来说，它的后 $k$ 位是否会发生循环？如果循环的话，循环长度是多少呢？\n\n注意：\n\n1. 如果 $n$ 的某个正整数次幂的位数不足 $k$，那么不足的高位看做是 $0$。\n2. 如果循环长度是 $L$，那么说明对于任意的正整数 $a$，$n$ 的 $a$ 次幂和 $a+L$ 次幂的最后 $k$ 位都相同。", "inputFormat": "共一行，包含两个整数 $n$ 和 $k$。$n$ 和 $k$ 之间用一个空格隔开，表示要求 $n$ 的正整数次幂的最后 $k$ 位的循环长度。", "outputFormat": "一个整数，表示循环长度。如果循环不存在，输出 $-1$。", "hint": "**【数据范围】**\n\n对于 $30 \\%$ 的数据，满足 $k \\le 4$；  \n对于 $100 \\%$ 的数据，满足 $1 \\le n < {10}^{100}$，$1 \\le k \\le 100$。\n\n**【题目来源】**\n\nNOIP 2005 普及组第四题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2005 Junior] Cycle", "background": null, "description": "Lele is a clever and diligent child. He always likes to explore patterns of things. One day, he suddenly became interested in the positive integer powers of numbers.\n\nAs is well known, the last digit of the positive integer powers of $2$ keeps repeating $2,4,8,6,2,4,8,6…$. We say the last digit of the positive integer powers of $2$ has a cycle length of $4$ (in fact, any multiple of $4$ can be called a cycle length, but we only consider the minimal cycle length). Similarly, the last digits of the positive integer powers of other digits also show similar cycles:\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{c|c|c}\\hline\n\\textbf{Digit}& \\textbf{Cycle} & \\textbf{Cycle length} \\cr\\hline\\hline\n2 & 2,4,8,6 & 4\\cr\\hline\n3 & 3,9,7,1 & 4\\cr\\hline\n4 & 4,6 & 2\\cr\\hline\n5 & 5 &  1\\cr\\hline\n6 & 6 & 1\\cr\\hline\n7 & 7,9,3,1 & 4\\cr\\hline\n8 & 8,4,2,6 & 4\\cr\\hline\n9 & 9,1 & 2\\cr\\hline\n\\end{array}\n$$\n\nThen Lele’s question arises: Is it only the last digit that has such a cycle? For the positive integer powers of an integer $n$, do the last $k$ digits exhibit a cycle? If they do, what is the cycle length?\n\nNote:\n1. If some positive integer power of $n$ has fewer than $k$ digits, treat the missing higher digits as $0$.\n2. If the cycle length is $L$, then for any positive integer $a$, the last $k$ digits of the $a$-th power of $n$ and the $(a+L)$-th power are the same.", "inputFormat": "One line containing two integers $n$ and $k$. $n$ and $k$ are separated by a single space, indicating that we are to find the cycle length of the last $k$ digits of the positive integer powers of $n$.", "outputFormat": "A single integer representing the cycle length. If no cycle exists, output $-1$.", "hint": "【Constraints】\n\nFor $30\\%$ of the testdata, $k \\le 4$.  \nFor $100\\%$ of the testdata, $1 \\le n < 10^{100}$, $1 \\le k \\le 100$.\n\n【Source】\n\nNOIP 2005 Junior Problem 4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2005 普及组] 循环", "background": null, "description": "乐乐是一个聪明而又勤奋好学的孩子。他总喜欢探求事物的规律。一天，他突然对数的正整数次幂产生了兴趣。\n\n\n众所周知，$2$ 的正整数次幂最后一位数总是不断的在重复 $2,4,8,6,2,4,8,6…$ 我们说 $2$ 的正整数次幂最后一位的循环长度是 $4$（实际上 $4$ 的倍数都可以说是循环长度，但我们只考虑最小的循环长度）。类似的，其余的数字的正整数次幂最后一位数也有类似的循环现象：\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{c|c|c}\\hline\n\\textbf{数字}& \\textbf{循环} & \\textbf{循环长度} \\cr\\hline\\hline\n2 & 2,4,8,6 & 4\\cr\\hline\n3 & 3,9,7,1 & 4\\cr\\hline\n4 & 4,6 & 2\\cr\\hline\n5 & 5 &  1\\cr\\hline\n6 & 6 & 1\\cr\\hline\n7 & 7,9,3,1 & 4\\cr\\hline\n8 & 8,4,2,6 & 4\\cr\\hline\n9 & 9,1 & 2\\cr\\hline\n\\end{array}\n$$\n\n这时乐乐的问题就出来了：是不是只有最后一位才有这样的循环呢？对于一个整数 $n$ 的正整数次幂来说，它的后 $k$ 位是否会发生循环？如果循环的话，循环长度是多少呢？\n\n注意：\n\n1. 如果 $n$ 的某个正整数次幂的位数不足 $k$，那么不足的高位看做是 $0$。\n2. 如果循环长度是 $L$，那么说明对于任意的正整数 $a$，$n$ 的 $a$ 次幂和 $a+L$ 次幂的最后 $k$ 位都相同。", "inputFormat": "共一行，包含两个整数 $n$ 和 $k$。$n$ 和 $k$ 之间用一个空格隔开，表示要求 $n$ 的正整数次幂的最后 $k$ 位的循环长度。", "outputFormat": "一个整数，表示循环长度。如果循环不存在，输出 $-1$。", "hint": "**【数据范围】**\n\n对于 $30 \\%$ 的数据，满足 $k \\le 4$；  \n对于 $100 \\%$ 的数据，满足 $1 \\le n < {10}^{100}$，$1 \\le k \\le 100$。\n\n**【题目来源】**\n\nNOIP 2005 普及组第四题", "locale": "zh-CN"}}}
{"pid": "P1051", "type": "P", "difficulty": 2, "samples": [["4\nYaoLin 87 82 Y N 0\nChenRuiyi 88 78 N Y 1\nLiXin 92 88 N N 0\nZhangQin 83 87 Y N 1\n", "ChenRuiyi\n9000\n28700\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2005", "NOIP 提高组", "排序"], "title": "[NOIP 2005 提高组] 谁拿了最多奖学金", "background": null, "description": "某校的惯例是在每学期的期末考试之后发放奖学金。发放的奖学金共有五种，获取的条件各自不同：\n\n1. 院士奖学金，每人 $8000$ 元，期末平均成绩高于 $80$ 分（$>80$），并且在本学期内发表 $1$ 篇或 $1$ 篇以上论文的学生均可获得；\n2. 五四奖学金，每人 $4000$ 元，期末平均成绩高于 $85$ 分（$>85$），并且班级评议成绩高于 $80$ 分（$>80$）的学生均可获得；\n3. 成绩优秀奖，每人 $2000$ 元，期末平均成绩高于 $90$ 分（$>90$）的学生均可获得；\n4. 西部奖学金，每人 $1000$ 元，期末平均成绩高于 $85$ 分（$>85$）的西部省份学生均可获得；\n5. 班级贡献奖，每人 $850$ 元，班级评议成绩高于 $80$ 分（$>80$）的学生干部均可获得；\n\n只要符合条件就可以得奖，每项奖学金的获奖人数没有限制，每名学生也可以同时获得多项奖学金。例如姚林的期末平均成绩是 $87$ 分，班级评议成绩 $82$ 分，同时他还是一位学生干部，那么他可以同时获得五四奖学金和班级贡献奖，奖金总数是 $4850$ 元。\n\n现在给出若干学生的相关数据，请计算哪些同学获得的奖金总数最高（假设总有同学能满足获得奖学金的条件）。", "inputFormat": "第一行是 $1$ 个整数 $N$，表示学生的总数。\n\n接下来的 $N$ 行每行是一位学生的数据，从左向右依次是姓名，期末平均成绩，班级评议成绩，是否是学生干部，是否是西部省份学生，以及发表的论文数。姓名是由大小写英文字母组成的长度不超过 $20$ 的字符串（不含空格）；期末平均成绩和班级评议成绩都是 $0$ 到 $100$ 之间的整数（包括 $0$ 和 $100$）；是否是学生干部和是否是西部省份学生分别用 $1$ 个字符表示，$\\tt Y$ 表示是，$\\tt N$ 表示不是；发表的论文数是 $0$ 到 $10$ 的整数（包括 $0$ 和 $10$）。每两个相邻数据项之间用一个空格分隔。", "outputFormat": "共 $3$ 行。\n\n- 第 $1$ 行是获得最多奖金的学生的姓名。如果有两位或两位以上的学生获得的奖金最多，输出他们之中在输入文件中出现最早的学生的姓名。\n- 第 $2$ 行是这名学生获得的奖金总数。\n- 第 $3$ 行是这 $N$ 个学生获得的奖学金的总数。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，满足 $1 \\le  N \\le  100$。\n\n**【题目来源】**\n\nNOIP 2005 提高组第一题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2005 Senior] Who Got the Most Scholarship Money", "background": null, "description": "It is customary at this school to award scholarships after each semester’s final exams. There are five types of scholarships, each with different requirements:\n\n1. Academician Scholarship: $8000$ yuan per person. Students whose final average score is greater than $80$ ($>80$) and who have published $1$ or more papers during this semester are eligible.\n2. May Fourth Scholarship: $4000$ yuan per person. Students whose final average score is greater than $85$ ($>85$) and whose class evaluation score is greater than $80$ ($>80$) are eligible.\n3. Outstanding Performance Award: $2000$ yuan per person. Students whose final average score is greater than $90$ ($>90$) are eligible.\n4. Western Scholarship: $1000$ yuan per person. Students from western provinces whose final average score is greater than $85$ ($>85$) are eligible.\n5. Class Contribution Award: $850$ yuan per person. Student cadres whose class evaluation score is greater than $80$ ($>80$) are eligible.\n\nAs long as the conditions are met, the scholarship will be awarded. There is no limit on the number of recipients for each scholarship, and each student may receive multiple scholarships simultaneously. For example, if Yao Lin’s final average score is $87$ and the class evaluation score is $82$, and he is also a student cadre, then he can receive both the May Fourth Scholarship and the Class Contribution Award, for a total of $4850$ yuan.\n\nNow, given data for several students, calculate which student(s) received the highest total amount of scholarship money (assume there is always at least one student who meets some scholarship condition).", "inputFormat": "The first line contains $1$ integer $N$, the total number of students.\n\nEach of the following $N$ lines contains one student’s data, in order: name, final average score, class evaluation score, whether the student is a student cadre, whether the student is from a western province, and the number of published papers. The name is a string of uppercase and lowercase English letters with length at most $20$ (no spaces). The final average score and the class evaluation score are integers between $0$ and $100$ (inclusive). Whether the student is a student cadre and whether the student is from a western province are each represented by $1$ character: $\\tt Y$ means yes, and $\\tt N$ means no. The number of published papers is an integer between $0$ and $10$ (inclusive). Each pair of adjacent data items is separated by a single space.", "outputFormat": "Output $3$ lines.\n\n- Line $1$: the name of the student who received the most scholarship money. If two or more students tie for the most, output the one who appears earliest in the input.\n- Line $2$: the total amount of scholarship money this student received.\n- Line $3$: the total amount of scholarship money received by all $N$ students.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $1 \\le N \\le 100$.\n\nProblem Source\n\nNOIP 2005 Senior, Problem 1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2005 提高组] 谁拿了最多奖学金", "background": null, "description": "某校的惯例是在每学期的期末考试之后发放奖学金。发放的奖学金共有五种，获取的条件各自不同：\n\n1. 院士奖学金，每人 $8000$ 元，期末平均成绩高于 $80$ 分（$>80$），并且在本学期内发表 $1$ 篇或 $1$ 篇以上论文的学生均可获得；\n2. 五四奖学金，每人 $4000$ 元，期末平均成绩高于 $85$ 分（$>85$），并且班级评议成绩高于 $80$ 分（$>80$）的学生均可获得；\n3. 成绩优秀奖，每人 $2000$ 元，期末平均成绩高于 $90$ 分（$>90$）的学生均可获得；\n4. 西部奖学金，每人 $1000$ 元，期末平均成绩高于 $85$ 分（$>85$）的西部省份学生均可获得；\n5. 班级贡献奖，每人 $850$ 元，班级评议成绩高于 $80$ 分（$>80$）的学生干部均可获得；\n\n只要符合条件就可以得奖，每项奖学金的获奖人数没有限制，每名学生也可以同时获得多项奖学金。例如姚林的期末平均成绩是 $87$ 分，班级评议成绩 $82$ 分，同时他还是一位学生干部，那么他可以同时获得五四奖学金和班级贡献奖，奖金总数是 $4850$ 元。\n\n现在给出若干学生的相关数据，请计算哪些同学获得的奖金总数最高（假设总有同学能满足获得奖学金的条件）。", "inputFormat": "第一行是 $1$ 个整数 $N$，表示学生的总数。\n\n接下来的 $N$ 行每行是一位学生的数据，从左向右依次是姓名，期末平均成绩，班级评议成绩，是否是学生干部，是否是西部省份学生，以及发表的论文数。姓名是由大小写英文字母组成的长度不超过 $20$ 的字符串（不含空格）；期末平均成绩和班级评议成绩都是 $0$ 到 $100$ 之间的整数（包括 $0$ 和 $100$）；是否是学生干部和是否是西部省份学生分别用 $1$ 个字符表示，$\\tt Y$ 表示是，$\\tt N$ 表示不是；发表的论文数是 $0$ 到 $10$ 的整数（包括 $0$ 和 $10$）。每两个相邻数据项之间用一个空格分隔。", "outputFormat": "共 $3$ 行。\n\n- 第 $1$ 行是获得最多奖金的学生的姓名。如果有两位或两位以上的学生获得的奖金最多，输出他们之中在输入文件中出现最早的学生的姓名。\n- 第 $2$ 行是这名学生获得的奖金总数。\n- 第 $3$ 行是这 $N$ 个学生获得的奖学金的总数。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，满足 $1 \\le  N \\le  100$。\n\n**【题目来源】**\n\nNOIP 2005 提高组第一题", "locale": "zh-CN"}}}
{"pid": "P1052", "type": "P", "difficulty": 4, "samples": [["10\n2 3 5\n2 3 5 6 7\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "数学", "2005", "NOIP 提高组", "不定方程"], "title": "[NOIP 2005 提高组] 过河", "background": "", "description": "在河上有一座独木桥，一只青蛙想沿着独木桥从河的一侧跳到另一侧。在桥上有一些石子，青蛙很讨厌踩在这些石子上。由于桥的长度和青蛙一次跳过的距离都是正整数，我们可以把独木桥上青蛙可能到达的点看成数轴上的一串整点：$0,1,\\cdots,L$（其中 $L$ 是桥的长度）。坐标为 $0$ 的点表示桥的起点，坐标为 $L$ 的点表示桥的终点。青蛙从桥的起点开始，不停的向终点方向跳跃。一次跳跃的距离是 $S$ 到 $T$ 之间的任意正整数（包括 $S,T$）。当青蛙跳到或跳过坐标为 $L$ 的点时，就算青蛙已经跳出了独木桥。\n\n题目给出独木桥的长度 $L$，青蛙跳跃的距离范围 $S,T$，桥上石子的位置。你的任务是确定青蛙要想过河，最少需要踩到的石子数。", "inputFormat": "输入共三行，\n\n- 第一行有 $1$ 个正整数 $L$，表示独木桥的长度。\n- 第二行有 $3$ 个正整数 $S,T,M$，分别表示青蛙一次跳跃的最小距离，最大距离及桥上石子的个数。\n- 第三行有 $M$ 个不同的正整数分别表示这 $M$ 个石子在数轴上的位置（数据保证桥的起点和终点处没有石子）。所有相邻的整数之间用一个空格隔开。", "outputFormat": "一个整数，表示青蛙过河最少需要踩到的石子数。\n\n", "hint": "**【数据范围】**\n\n- 对于 $30\\%$ 的数据，$1\\le L \\le 10^4$；\n- 对于 $100\\%$ 的数据，$1\\le L \\le 10^9$，$1\\le S\\le T\\le10$，$1\\le M\\le100$。\n\n**【题目来源】**\n\nNOIP 2005 提高组第二题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2005 Senior] Crossing the River", "background": null, "description": "There is a single-plank bridge over a river. A frog wants to jump along the bridge from one side of the river to the other. There are some stones on the bridge, and the frog dislikes stepping on them. Since both the bridge length and each jump distance of the frog are positive integers, we can view all points the frog can reach on the bridge as the sequence of integer points on a number line: $0,1,\\cdots,L$ (where $L$ is the length of the bridge). The point with coordinate $0$ is the starting point of the bridge, and the point with coordinate $L$ is the endpoint of the bridge. The frog starts at the starting point and keeps jumping toward the endpoint. Each jump distance is any positive integer between $S$ and $T$ inclusive. Once the frog reaches or passes the point with coordinate $L$, it is considered to have left the bridge.\n\nGiven the bridge length $L$, the jump distance range $S, T$, and the stone positions on the bridge, your task is to determine the minimum number of stones the frog must step on to cross the river.", "inputFormat": "The input consists of three lines:\n- The first line contains $1$ positive integer $L$, the length of the bridge.\n- The second line contains $3$ positive integers $S, T, M$, denoting the minimum jump distance, the maximum jump distance, and the number of stones on the bridge, respectively.\n- The third line contains $M$ distinct positive integers giving the positions of these $M$ stones on the number line (it is guaranteed that there are no stones at the start or at the end of the bridge). All adjacent integers are separated by a single space.", "outputFormat": "Output a single integer: the minimum number of stones the frog must step on to cross the river.", "hint": "- Constraints\n  - For $30\\%$ of the testdata, $1 \\le L \\le 10^4$.\n  - For $100\\%$ of the testdata, $1 \\le L \\le 10^9$, $1 \\le S \\le T \\le 10$, $1 \\le M \\le 100$.\n- Source\n  - NOIP 2005 Senior, Problem 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2005 提高组] 过河", "background": "", "description": "在河上有一座独木桥，一只青蛙想沿着独木桥从河的一侧跳到另一侧。在桥上有一些石子，青蛙很讨厌踩在这些石子上。由于桥的长度和青蛙一次跳过的距离都是正整数，我们可以把独木桥上青蛙可能到达的点看成数轴上的一串整点：$0,1,\\cdots,L$（其中 $L$ 是桥的长度）。坐标为 $0$ 的点表示桥的起点，坐标为 $L$ 的点表示桥的终点。青蛙从桥的起点开始，不停的向终点方向跳跃。一次跳跃的距离是 $S$ 到 $T$ 之间的任意正整数（包括 $S,T$）。当青蛙跳到或跳过坐标为 $L$ 的点时，就算青蛙已经跳出了独木桥。\n\n题目给出独木桥的长度 $L$，青蛙跳跃的距离范围 $S,T$，桥上石子的位置。你的任务是确定青蛙要想过河，最少需要踩到的石子数。", "inputFormat": "输入共三行，\n\n- 第一行有 $1$ 个正整数 $L$，表示独木桥的长度。\n- 第二行有 $3$ 个正整数 $S,T,M$，分别表示青蛙一次跳跃的最小距离，最大距离及桥上石子的个数。\n- 第三行有 $M$ 个不同的正整数分别表示这 $M$ 个石子在数轴上的位置（数据保证桥的起点和终点处没有石子）。所有相邻的整数之间用一个空格隔开。", "outputFormat": "一个整数，表示青蛙过河最少需要踩到的石子数。\n\n", "hint": "**【数据范围】**\n\n- 对于 $30\\%$ 的数据，$1\\le L \\le 10^4$；\n- 对于 $100\\%$ 的数据，$1\\le L \\le 10^9$，$1\\le S\\le T\\le10$，$1\\le M\\le100$。\n\n**【题目来源】**\n\nNOIP 2005 提高组第二题", "locale": "zh-CN"}}}
{"pid": "P1053", "type": "P", "difficulty": 5, "samples": [["4\n3 4\n4 3\n1 2\n1 2\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "贪心", "2005", "NOIP 提高组"], "title": "[NOIP 2005 提高组] 篝火晚会", "background": null, "description": "佳佳刚进高中，在军训的时候，由于佳佳吃苦耐劳，很快得到了教官的赏识，成为了“小教官”。在军训结束的那天晚上，佳佳被命令组织同学们进行篝火晚会。一共有 $n$ 个同学，编号从 $1$ 到 $n$。一开始，同学们按照 $1,2,\\cdots ,n$ 的顺序坐成一圈，而实际上每个人都有两个最希望相邻的同学。如何下命令调整同学的次序，形成新的一个圈，使之符合同学们的意愿，成为摆在佳佳面前的一大难题。\n\n\n佳佳可向同学们下达命令，每一个命令的形式如下：\n\n$$(b_1, b_2,..., b_{m-1}, b_m)$$\n\n这里 $m$ 的值是由佳佳决定的，每次命令 $m$ 的值都可以不同。这个命令的作用是移动编号是 $b_1,b_2,\\cdots, b_m$ 的这 $m$ 个同学的位置。要求 $b_1$ 换到 $b_2$ 的位置上，$b_2$ 换到 $b_3$ 的位置上，……，要求 $b_m$ 换到 $b_1$ 的位置上。执行每个命令都需要一些代价。我们假定如果一个命令要移动 $m$ 个人的位置，那么这个命令的代价就是 $m$。我们需要佳佳用最少的总代价实现同学们的意愿，你能帮助佳佳吗？", "inputFormat": "第一行是一个整数 $n$，表示一共有 $n$ 个同学。\n\n其后 $n$ 行每行包括 $2$ 个不同的正整数，以一个空格隔开，分别表示编号是 $1$ 的同学最希望相邻的两个同学的编号，编号是 $2$ 的同学最希望相邻的两个同学的编号，……，编号是 $n$ 的同学最希望相邻的两个同学的编号。", "outputFormat": "一个整数，为最小的总代价。如果无论怎么调整都不能符合每个同学的愿望，则输出 $-1$。", "hint": "- 对于 $30\\%$ 的数据，满足 $n \\le 1000$；\n- 对于 $100\\%$ 的数据，满足 $3\\le n  \\le  50000$。\n\n**【题目来源】**\n\nNOIP 2005 提高组第三题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2005 Senior] Bonfire Party", "background": null, "description": "Jiajia has just entered high school. During military training, because Jiajia is hardworking and resilient, she quickly earned the instructor’s appreciation and became a “junior instructor” (xiao jiaoguan). On the last night of the training, Jiajia was ordered to organize a bonfire party. There are $n$ students, numbered from $1$ to $n$. Initially, the students sit in a circle in the order $1, 2, \\cdots, n$. In reality, each person has two classmates they most wish to sit next to. How should Jiajia issue commands to rearrange the students into a new circle that satisfies everyone’s wishes? This is a big challenge for Jiajia.\n\nJiajia can issue commands, each of the following form:\n$$(b_1, b_2, ..., b_{m-1}, b_m)$$\nHere, the value of $m$ is determined by Jiajia and can be different for each command. This command moves the positions of the $m$ students with numbers $b_1, b_2, \\cdots, b_m$: $b_1$ moves to $b_2$’s position, $b_2$ moves to $b_3$’s position, …, and $b_m$ moves to $b_1$’s position. Executing each command incurs a cost. We assume that if a command moves $m$ people, then its cost is $m$. We need Jiajia to achieve everyone’s wishes with the minimum total cost. Can you help Jiajia?", "inputFormat": "The first line contains an integer $n$, the total number of students.\n\nThe next $n$ lines each contain $2$ distinct positive integers, separated by a space. The $i$-th of these lines gives the numbers of the two classmates whom student $i$ most wishes to sit next to.", "outputFormat": "Output a single integer: the minimum total cost. If it is impossible to satisfy every student’s wish no matter how you rearrange, output $-1$.", "hint": "- For $30\\%$ of the testdata, $n \\le 1000$.\n- For $100\\%$ of the testdata, $3 \\le n \\le 50000$.\n\nSource: NOIP 2005 Senior, Problem 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2005 提高组] 篝火晚会", "background": null, "description": "佳佳刚进高中，在军训的时候，由于佳佳吃苦耐劳，很快得到了教官的赏识，成为了“小教官”。在军训结束的那天晚上，佳佳被命令组织同学们进行篝火晚会。一共有 $n$ 个同学，编号从 $1$ 到 $n$。一开始，同学们按照 $1,2,\\cdots ,n$ 的顺序坐成一圈，而实际上每个人都有两个最希望相邻的同学。如何下命令调整同学的次序，形成新的一个圈，使之符合同学们的意愿，成为摆在佳佳面前的一大难题。\n\n\n佳佳可向同学们下达命令，每一个命令的形式如下：\n\n$$(b_1, b_2,..., b_{m-1}, b_m)$$\n\n这里 $m$ 的值是由佳佳决定的，每次命令 $m$ 的值都可以不同。这个命令的作用是移动编号是 $b_1,b_2,\\cdots, b_m$ 的这 $m$ 个同学的位置。要求 $b_1$ 换到 $b_2$ 的位置上，$b_2$ 换到 $b_3$ 的位置上，……，要求 $b_m$ 换到 $b_1$ 的位置上。执行每个命令都需要一些代价。我们假定如果一个命令要移动 $m$ 个人的位置，那么这个命令的代价就是 $m$。我们需要佳佳用最少的总代价实现同学们的意愿，你能帮助佳佳吗？", "inputFormat": "第一行是一个整数 $n$，表示一共有 $n$ 个同学。\n\n其后 $n$ 行每行包括 $2$ 个不同的正整数，以一个空格隔开，分别表示编号是 $1$ 的同学最希望相邻的两个同学的编号，编号是 $2$ 的同学最希望相邻的两个同学的编号，……，编号是 $n$ 的同学最希望相邻的两个同学的编号。", "outputFormat": "一个整数，为最小的总代价。如果无论怎么调整都不能符合每个同学的愿望，则输出 $-1$。", "hint": "- 对于 $30\\%$ 的数据，满足 $n \\le 1000$；\n- 对于 $100\\%$ 的数据，满足 $3\\le n  \\le  50000$。\n\n**【题目来源】**\n\nNOIP 2005 提高组第三题", "locale": "zh-CN"}}}
{"pid": "P1054", "type": "P", "difficulty": 5, "samples": [["( a + 1) ^2\n3\n(a-1)^2+4*a\na + 1+ a\na^2 + 2 * a * 1 + 1^2 + 10 -10 +a -a\n", "AC"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "字符串", "2005", "NOIP 提高组"], "title": "[NOIP 2005 提高组] 等价表达式", "background": null, "description": "明明进了中学之后，学到了代数表达式。有一天，他碰到一个很麻烦的选择题。这个题目的题干中首先给出了一个代数表达式，然后列出了若干选项，每个选项也是一个代数表达式，题目的要求是判断选项中哪些代数表达式是和题干中的表达式等价的。\n\n这个题目手算很麻烦，因为明明对计算机编程很感兴趣，所以他想是不是可以用计算机来解决这个问题。假设你是明明，能完成这个任务吗？\n\n这个选择题中的每个表达式都满足下面的性质：\n\n1. 表达式只可能包含一个变量 $\\tt a$。\n2. 表达式中出现的数都是正整数，而且都小于 $10000$。\n3. 表达式中可以包括四种运算 `+`（加），`-`（减），`*`（乘），`^`（乘幂），以及小括号 `()`。小括号的优先级最高，其次是 `^`，然后是 `*`，最后是 `+` 和 `-`。`+` 和 `-` 的优先级是相同的。相同优先级的运算（**包括 `^` 运算**）都是**从左到右**进行。\n4. 幂指数只可能是 $1$ 到 $10$ 之间的正整数（包括 $1$ 和 $10$）。\n5. 表达式内部，头部或者尾部都可能有一些多余的空格。\n\n如果某个选项出现不合法的表达式（如括号不匹配），忽略这个选项。\n\n下面是一些合理的表达式的例子：\n\n`((a^1) ^ 2)^3`，`a*a+a-a`，`((a+a))`，`9999+(a-a)*a`，`1 + (a -1)^3`，`1^10^9`", "inputFormat": "第一行给出的是题干中的表达式。\n\n第二行是一个整数 $n$，表示选项的个数。后面$n$行，每行包括一个选项中的表达式。这 $n$ 个选项的标号分别是 $A,B,C,D\\cdots $\n\n\n输入中的表达式的长度都不超过 $50$ 个字符，而且保证选项中总有表达式和题干中的表达式是等价的。", "outputFormat": "一行，包括一系列选项的标号，表示哪些选项是和题干中的表达式等价的。选项的标号按照字母顺序排列，而且之间没有空格。", "hint": "- 对于 $30\\%$ 的数据，表达式中只可能出现两种运算符 `+` 和 `-`；\n- 对于其它的数据，四种运算符 `+-*^` 在表达式中都可能出现。  \n- 对于 $100\\%$ 的数据，表达式中都可能出现小括号 `()`，$2 \\le n \\le  26$。\n\n**【题目来源】**\n\nNOIP 2005 提高组第四题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2005 Senior] Equivalent Expressions", "background": null, "description": "After entering middle school, Mingming learned algebraic expressions. One day, he encountered a troublesome multiple-choice question. The stem first gives an algebraic expression, then lists several options, each of which is also an algebraic expression. The task is to determine which options are equivalent to the expression in the stem.\n\nThis is tedious to do by hand. Since Mingming is interested in computer programming, he wonders if a computer can solve it. Suppose you are Mingming. Can you complete this task?\n\nEvery expression in this multiple-choice problem satisfies the following properties:\n1. The expression may contain only one variable, $\\tt a$.\n2. All numbers that appear in the expression are positive integers less than $10000$.\n3. The expression may include four operations: `+` (addition), `-` (subtraction), `*` (multiplication), `^` (exponentiation), and parentheses `()`. Parentheses have the highest precedence, followed by `^`, then `*`, and finally `+` and `-`. `+` and `-` have the same precedence. Operations of the same precedence (including `^`) are evaluated from left to right.\n4. Exponents can only be positive integers from $1$ to $10$ inclusive.\n5. There may be extra spaces within the expression, at the beginning, or at the end.\n\nIf an option contains an invalid expression (e.g., unmatched parentheses), ignore that option.\n\nHere are some valid examples:\n`((a^1) ^ 2)^3`, `a*a+a-a`, `((a+a))`, `9999+(a-a)*a`, `1 + (a -1)^3`, `1^10^9`.", "inputFormat": "The first line contains the expression in the stem.\n\nThe second line contains an integer $n$, the number of options. The next $n$ lines each contain the expression of one option. These $n$ options are labeled $A, B, C, D, \\cdots$.\n\nEach expression in the input has length at most $50$ characters. It is guaranteed that at least one option is equivalent to the expression in the stem.", "outputFormat": "Output one line containing the labels of all options that are equivalent to the expression in the stem. The labels must be in alphabetical order with no spaces.", "hint": "- For $30\\%$ of the testdata, only the two operators `+` and `-` may appear.\n- For the other testdata, all four operators `+-*^` may appear in expressions.\n- For $100\\%$ of the testdata, parentheses `()` may appear, and $2 \\le n \\le 26$.\n\n**Problem Source**\n\nNOIP 2005 Senior Problem 4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2005 提高组] 等价表达式", "background": null, "description": "明明进了中学之后，学到了代数表达式。有一天，他碰到一个很麻烦的选择题。这个题目的题干中首先给出了一个代数表达式，然后列出了若干选项，每个选项也是一个代数表达式，题目的要求是判断选项中哪些代数表达式是和题干中的表达式等价的。\n\n这个题目手算很麻烦，因为明明对计算机编程很感兴趣，所以他想是不是可以用计算机来解决这个问题。假设你是明明，能完成这个任务吗？\n\n这个选择题中的每个表达式都满足下面的性质：\n\n1. 表达式只可能包含一个变量 $\\tt a$。\n2. 表达式中出现的数都是正整数，而且都小于 $10000$。\n3. 表达式中可以包括四种运算 `+`（加），`-`（减），`*`（乘），`^`（乘幂），以及小括号 `()`。小括号的优先级最高，其次是 `^`，然后是 `*`，最后是 `+` 和 `-`。`+` 和 `-` 的优先级是相同的。相同优先级的运算（**包括 `^` 运算**）都是**从左到右**进行。\n4. 幂指数只可能是 $1$ 到 $10$ 之间的正整数（包括 $1$ 和 $10$）。\n5. 表达式内部，头部或者尾部都可能有一些多余的空格。\n\n如果某个选项出现不合法的表达式（如括号不匹配），忽略这个选项。\n\n下面是一些合理的表达式的例子：\n\n`((a^1) ^ 2)^3`，`a*a+a-a`，`((a+a))`，`9999+(a-a)*a`，`1 + (a -1)^3`，`1^10^9`", "inputFormat": "第一行给出的是题干中的表达式。\n\n第二行是一个整数 $n$，表示选项的个数。后面$n$行，每行包括一个选项中的表达式。这 $n$ 个选项的标号分别是 $A,B,C,D\\cdots $\n\n\n输入中的表达式的长度都不超过 $50$ 个字符，而且保证选项中总有表达式和题干中的表达式是等价的。", "outputFormat": "一行，包括一系列选项的标号，表示哪些选项是和题干中的表达式等价的。选项的标号按照字母顺序排列，而且之间没有空格。", "hint": "- 对于 $30\\%$ 的数据，表达式中只可能出现两种运算符 `+` 和 `-`；\n- 对于其它的数据，四种运算符 `+-*^` 在表达式中都可能出现。  \n- 对于 $100\\%$ 的数据，表达式中都可能出现小括号 `()`，$2 \\le n \\le  26$。\n\n**【题目来源】**\n\nNOIP 2005 提高组第四题", "locale": "zh-CN"}}}
{"pid": "P1055", "type": "P", "difficulty": 2, "samples": [["0-670-82162-4", "Right"], ["0-670-82162-0", "0-670-82162-4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "字符串", "2008", "NOIP 普及组"], "title": "[NOIP 2008 普及组] ISBN 号码", "background": "", "description": "每一本正式出版的图书都有一个 ISBN 号码与之对应，ISBN 码包括 $9$ 位数字、$1$ 位识别码和 $3$ 位分隔符，其规定格式如 `x-xxx-xxxxx-x`，其中符号 `-` 就是分隔符（键盘上的减号），最后一位是识别码，例如 `0-670-82162-4`就是一个标准的 ISBN 码。ISBN 码的首位数字表示书籍的出版语言，例如 $0$ 代表英语；第一个分隔符 `-` 之后的三位数字代表出版社，例如 $670$ 代表维京出版社；第二个分隔符后的五位数字代表该书在该出版社的编号；最后一位为识别码。\n\n识别码的计算方法如下：\n\n首位数字乘以 $1$ 加上次位数字乘以 $2$ ……以此类推，用所得的结果 $ \\bmod 11$，所得的余数即为识别码，如果余数为 $10$，则识别码为大写字母 $X$。例如 ISBN 号码 `0-670-82162-4` 中的识别码 $4$ 是这样得到的：对 `067082162` 这 $9$ 个数字，从左至右，分别乘以 $1,2,\\dots,9$ 再求和，即 $0\\times 1+6\\times 2+……+2\\times 9=158$，然后取 $158 \\bmod 11$ 的结果 $4$ 作为识别码。\n\n你的任务是编写程序判断输入的 ISBN 号码中识别码是否正确，如果正确，则仅输出 `Right`；如果错误，则输出你认为是正确的 ISBN 号码。\n", "inputFormat": "一个字符序列，表示一本书的 ISBN 号码（保证输入符合 ISBN 号码的格式要求）。\n", "outputFormat": "一行，假如输入的 ISBN 号码的识别码正确，那么输出 `Right`，否则，按照规定的格式，输出正确的 ISBN 号码（包括分隔符 `-`）。\n", "hint": "2008 普及组第一题\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2008 Junior] ISBN Number", "background": null, "description": "Every formally published book has an ISBN number associated with it. An ISBN consists of $9$ digits, $1$ check digit, and $3$ separators. Its prescribed format is `x-xxx-xxxxx-x`, where the symbol `-` is the separator (the minus sign on the keyboard), and the last character is the check digit. For example, `0-670-82162-4` is a standard ISBN. The first digit indicates the publication language of the book (for example, $0$ represents English); the three digits after the first separator `-` indicate the publisher (for example, $670$ represents Viking Press); the five digits after the second separator indicate the book’s identifier at that publisher; the last character is the check digit.\n\nThe check digit is computed as follows:\n\nMultiply the first digit by $1$, add the second digit multiplied by $2$, and so on. Take the resulting sum $\\bmod 11$; the remainder is the check digit. If the remainder is $10$, then the check digit is the uppercase letter $X$. For example, in the ISBN `0-670-82162-4`, the check digit $4$ is obtained as follows: take the nine digits `067082162` from left to right, multiply them by $1,2,\\dots,9$ respectively and sum, i.e., $0\\times 1 + 6\\times 2 + \\cdots + 2\\times 9 = 158$, then take $158 \\bmod 11$, whose result $4$ is the check digit.\n\nYour task is to write a program to determine whether the check digit in the input ISBN number is correct. If it is correct, output `Right` only; if it is incorrect, output the ISBN number you believe to be correct.", "inputFormat": "A character sequence representing a book’s ISBN number (the input is guaranteed to conform to the format requirements of ISBN numbers).", "outputFormat": "One line. If the check digit of the input ISBN number is correct, output `Right`; otherwise, output the correct ISBN number in the prescribed format (including the separator `-`).", "hint": "2008 Junior Problem 1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2008 普及组] ISBN 号码", "background": "", "description": "每一本正式出版的图书都有一个 ISBN 号码与之对应，ISBN 码包括 $9$ 位数字、$1$ 位识别码和 $3$ 位分隔符，其规定格式如 `x-xxx-xxxxx-x`，其中符号 `-` 就是分隔符（键盘上的减号），最后一位是识别码，例如 `0-670-82162-4`就是一个标准的 ISBN 码。ISBN 码的首位数字表示书籍的出版语言，例如 $0$ 代表英语；第一个分隔符 `-` 之后的三位数字代表出版社，例如 $670$ 代表维京出版社；第二个分隔符后的五位数字代表该书在该出版社的编号；最后一位为识别码。\n\n识别码的计算方法如下：\n\n首位数字乘以 $1$ 加上次位数字乘以 $2$ ……以此类推，用所得的结果 $ \\bmod 11$，所得的余数即为识别码，如果余数为 $10$，则识别码为大写字母 $X$。例如 ISBN 号码 `0-670-82162-4` 中的识别码 $4$ 是这样得到的：对 `067082162` 这 $9$ 个数字，从左至右，分别乘以 $1,2,\\dots,9$ 再求和，即 $0\\times 1+6\\times 2+……+2\\times 9=158$，然后取 $158 \\bmod 11$ 的结果 $4$ 作为识别码。\n\n你的任务是编写程序判断输入的 ISBN 号码中识别码是否正确，如果正确，则仅输出 `Right`；如果错误，则输出你认为是正确的 ISBN 号码。\n", "inputFormat": "一个字符序列，表示一本书的 ISBN 号码（保证输入符合 ISBN 号码的格式要求）。\n", "outputFormat": "一行，假如输入的 ISBN 号码的识别码正确，那么输出 `Right`，否则，按照规定的格式，输出正确的 ISBN 号码（包括分隔符 `-`）。\n", "hint": "2008 普及组第一题\n", "locale": "zh-CN"}}}
{"pid": "P1056", "type": "P", "difficulty": 3, "samples": [["4 5 1 2 3\n4 2 4 3\n2 3 3 3\n2 5 2 4\n", "2\n2 4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2008", "NOIP 普及组", "排序"], "title": "[NOIP 2008 普及组] 排座椅", "background": null, "description": "上课的时候总会有一些同学和前后左右的人交头接耳，这是令小学班主任十分头疼的一件事情。不过，班主任小雪发现了一些有趣的现象，当同学们的座次确定下来之后，只有有限的 $D$ 对同学上课时会交头接耳。\n\n同学们在教室中坐成了 $M$ 行 $N$ 列，坐在第 $i$ 行第 $j$ 列的同学的位置是 $(i,j)$，为了方便同学们进出，在教室中设置了 $K$ 条横向的通道，$L$ 条纵向的通道。\n\n于是，聪明的小雪想到了一个办法，或许可以减少上课时学生交头接耳的问题：她打算重新摆放桌椅，改变同学们桌椅间通道的位置，因为如果一条通道隔开了 $2$ 个会交头接耳的同学，那么他们就不会交头接耳了。\n\n请你帮忙给小雪编写一个程序，给出最好的通道划分方案。在该方案下，上课时交头接耳的学生的对数最少。", "inputFormat": "第一行，有 $5$ 个用空格隔开的整数，分别是 $M,N,K,L,D(2 \\le N,M \\le 1000,0 \\le K<M,0 \\le L<N,0\\le D \\le 2000)$。\n\n接下来的 $D$ 行，每行有 $4$ 个用空格隔开的整数。第 $i$ 行的 $4$ 个整数 $X_i,Y_i,P_i,Q_i$，表示坐在位置 $(X_i,Y_i)$ 与 $(P_i,Q_i)$ 的两个同学会交头接耳（输入保证他们前后相邻或者左右相邻）。\n\n输入数据保证最优方案的唯一性。", "outputFormat": "共两行。  \n第一行包含 $K$ 个整数 $a_1,a_2,\\ldots,a_K$，表示第 $a_1$ 行和 $a_1+1$ 行之间、第 $a_2$ 行和 $a_2+1$ 行之间、…、第 $a_K$ 行和第 $a_K+1$ 行之间要开辟通道，其中 $a_i< a_{i+1}$，每两个整数之间用空格隔开（行尾没有空格）。\n\n第二行包含 $L$ 个整数 $b_1,b_2,\\ldots,b_L$，表示第 $b_1$ 列和 $b_1+1$ 列之间、第 $b_2$ 列和 $b_2+1$ 列之间、…、第 $b_L$ 列和第 $b_L+1$ 列之间要开辟通道，其中$b_i< b_{i+1}$，每两个整数之间用空格隔开（列尾没有空格）。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/0z0p5x1i.png)\n\n上图中用符号\\*、※、+标出了 $3$ 对会交头接耳的学生的位置，图中 $3$ 条粗线的位置表示通道，图示的通道划分方案是唯一的最佳方案。\n\n2008 年普及组第二题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2008 Junior] Seating Arrangement", "background": null, "description": "During class, some students always whisper with the people in front, behind, to the left, or to the right of them. This is very troubling for the primary school homeroom teacher. However, the teacher Xiaoxue noticed something interesting: once the seating positions are fixed, only a limited number $D$ of pairs of students will whisper during class.\n\nStudents sit in $M$ rows and $N$ columns. The student in row $i$ and column $j$ sits at position $(i, j)$. To make it easier for students to enter and exit, there are $K$ horizontal aisles and $L$ vertical aisles in the classroom.\n\nClever Xiaoxue came up with an idea that might reduce whispering: she plans to rearrange the desks and chairs by changing the positions of the aisles. If an aisle separates two students who would whisper, they will stop whispering.\n\nPlease help Xiaoxue write a program to output the best aisle placement. Under this plan, the number of whispering pairs during class is minimized.", "inputFormat": "The first line contains $5$ space-separated integers: $M,N,K,L,D(2 \\le N,M \\le 1000,0 \\le K<M,0 \\le L<N,0\\le D \\le 2000)$.\n\nThe next $D$ lines each contain $4$ space-separated integers. On the $i$-th line, the $4$ integers $X_i,Y_i,P_i,Q_i$ indicate that the two students at positions $(X_i,Y_i)$ and $(P_i,Q_i)$ will whisper (the input guarantees they are adjacent either front/back or left/right).\n\nThe input guarantees that the optimal solution is unique.", "outputFormat": "Output two lines.\nThe first line contains $K$ integers $a_1,a_2,\\ldots,a_K$, indicating that aisles are to be placed between row $a_1$ and row $a_1+1$, between row $a_2$ and row $a_2+1$, …, and between row $a_K$ and row $a_K+1$, where $a_i< a_{i+1}$. Integers are separated by single spaces, with no trailing space.\n\nThe second line contains $L$ integers $b_1,b_2,\\ldots,b_L$, indicating that aisles are to be placed between column $b_1$ and column $b_1+1$, between column $b_2$ and column $b_2+1$, …, and between column $b_L$ and column $b_L+1$, where $b_i< b_{i+1}$. Integers are separated by single spaces, with no trailing space.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/0z0p5x1i.png)\n\nIn the figure, the symbols \\*, ※, and + mark $3$ pairs of students who will whisper. The $3$ bold lines indicate aisles. The shown aisle arrangement is the unique optimal solution.\n\n2008 Junior, problem 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2008 普及组] 排座椅", "background": null, "description": "上课的时候总会有一些同学和前后左右的人交头接耳，这是令小学班主任十分头疼的一件事情。不过，班主任小雪发现了一些有趣的现象，当同学们的座次确定下来之后，只有有限的 $D$ 对同学上课时会交头接耳。\n\n同学们在教室中坐成了 $M$ 行 $N$ 列，坐在第 $i$ 行第 $j$ 列的同学的位置是 $(i,j)$，为了方便同学们进出，在教室中设置了 $K$ 条横向的通道，$L$ 条纵向的通道。\n\n于是，聪明的小雪想到了一个办法，或许可以减少上课时学生交头接耳的问题：她打算重新摆放桌椅，改变同学们桌椅间通道的位置，因为如果一条通道隔开了 $2$ 个会交头接耳的同学，那么他们就不会交头接耳了。\n\n请你帮忙给小雪编写一个程序，给出最好的通道划分方案。在该方案下，上课时交头接耳的学生的对数最少。", "inputFormat": "第一行，有 $5$ 个用空格隔开的整数，分别是 $M,N,K,L,D(2 \\le N,M \\le 1000,0 \\le K<M,0 \\le L<N,0\\le D \\le 2000)$。\n\n接下来的 $D$ 行，每行有 $4$ 个用空格隔开的整数。第 $i$ 行的 $4$ 个整数 $X_i,Y_i,P_i,Q_i$，表示坐在位置 $(X_i,Y_i)$ 与 $(P_i,Q_i)$ 的两个同学会交头接耳（输入保证他们前后相邻或者左右相邻）。\n\n输入数据保证最优方案的唯一性。", "outputFormat": "共两行。  \n第一行包含 $K$ 个整数 $a_1,a_2,\\ldots,a_K$，表示第 $a_1$ 行和 $a_1+1$ 行之间、第 $a_2$ 行和 $a_2+1$ 行之间、…、第 $a_K$ 行和第 $a_K+1$ 行之间要开辟通道，其中 $a_i< a_{i+1}$，每两个整数之间用空格隔开（行尾没有空格）。\n\n第二行包含 $L$ 个整数 $b_1,b_2,\\ldots,b_L$，表示第 $b_1$ 列和 $b_1+1$ 列之间、第 $b_2$ 列和 $b_2+1$ 列之间、…、第 $b_L$ 列和第 $b_L+1$ 列之间要开辟通道，其中$b_i< b_{i+1}$，每两个整数之间用空格隔开（列尾没有空格）。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/0z0p5x1i.png)\n\n上图中用符号\\*、※、+标出了 $3$ 对会交头接耳的学生的位置，图中 $3$ 条粗线的位置表示通道，图示的通道划分方案是唯一的最佳方案。\n\n2008 年普及组第二题", "locale": "zh-CN"}}}
{"pid": "P1057", "type": "P", "difficulty": 3, "samples": [["3 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "动态规划 DP", "递推", "2008", "NOIP 普及组", "记忆化搜索"], "title": "[NOIP 2008 普及组] 传球游戏", "background": "", "description": "上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。\n\n游戏规则是这样的：$n$ 个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没有传出去的那个同学就是败者，要给大家表演一个节目。\n\n聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了 $m$ 次以后，又回到小蛮手里。两种传球方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有三个同学 $1$ 号、$2$ 号、$3$ 号，并假设小蛮为 $1$ 号，球传了 $3$ 次回到小蛮手里的方式有 $1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 1$ 和 $1 \\rightarrow 3 \\rightarrow 2 \\rightarrow 1$，共 $2$ 种。\n", "inputFormat": "一行，有两个用空格隔开的整数 $n,m(3 \\le n \\le 30,1 \\le m \\le 30)$。\n", "outputFormat": "$1$ 个整数，表示符合题意的方法数。\n", "hint": "### 数据范围及约定\n\n- 对于 $40\\%$ 的数据，满足：$3 \\le n \\le 30,1 \\le m \\le 20$；\n- 对于 $100\\%$ 的数据，满足：$3 \\le n \\le 30,1 \\le m \\le 30$。\n\n2008普及组第三题\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2008 Junior] Passing Game", "background": null, "description": "During PE class, Xiaoman’s teacher often plays games with the students. This time, the teacher is leading a passing game.\n\nThe rules are as follows: $n$ students stand in a circle. One student holds a ball at the start. When the teacher blows the whistle, the passing begins. Each student can pass the ball to either of their two neighbors (left or right, chosen arbitrarily). When the teacher blows the whistle again, the passing stops. At that moment, the student holding the ball, who has not passed it on, is the loser and must perform a show for everyone.\n\nXiaoman提出了一个有趣的问题: In how many different ways can the ball, starting from Xiaoman, return to Xiaoman after $m$ passes? Two passing methods are considered different if and only if the sequences of students who receive the ball, in the order they receive it, are different. For example, with three students numbered $1$, $2$, and $3$, and assuming Xiaoman is number $1$, there are $2$ ways for the ball to return to Xiaoman after $3$ passes: $1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 1$ and $1 \\rightarrow 3 \\rightarrow 2 \\rightarrow 1$.", "inputFormat": "One line with two space-separated integers $n,m(3 \\le n \\le 30,1 \\le m \\le 30)$.", "outputFormat": "$1$ integer, representing the number of valid methods.", "hint": "### Constraints and Conventions\n\n- For $40\\%$ of the testdata, it holds that: $3 \\le n \\le 30,1 \\le m \\le 20$.\n- For $100\\%$ of the testdata, it holds that: $3 \\le n \\le 30,1 \\le m \\le 30$.\n\nThird problem of the 2008 Junior.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2008 普及组] 传球游戏", "background": "", "description": "上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。\n\n游戏规则是这样的：$n$ 个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没有传出去的那个同学就是败者，要给大家表演一个节目。\n\n聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了 $m$ 次以后，又回到小蛮手里。两种传球方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有三个同学 $1$ 号、$2$ 号、$3$ 号，并假设小蛮为 $1$ 号，球传了 $3$ 次回到小蛮手里的方式有 $1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 1$ 和 $1 \\rightarrow 3 \\rightarrow 2 \\rightarrow 1$，共 $2$ 种。\n", "inputFormat": "一行，有两个用空格隔开的整数 $n,m(3 \\le n \\le 30,1 \\le m \\le 30)$。\n", "outputFormat": "$1$ 个整数，表示符合题意的方法数。\n", "hint": "### 数据范围及约定\n\n- 对于 $40\\%$ 的数据，满足：$3 \\le n \\le 30,1 \\le m \\le 20$；\n- 对于 $100\\%$ 的数据，满足：$3 \\le n \\le 30,1 \\le m \\le 30$。\n\n2008普及组第三题\n", "locale": "zh-CN"}}}
{"pid": "P1058", "type": "P", "difficulty": 3, "samples": [["3 4\n2 2 1 2\n2 2 1 1\n3 2 1 2\n", "......+---+---+...+---+\n..+---+  /   /|../   /|\n./   /|-+---+ |.+---+ |\n+---+ |/   /| +-|   | +\n|   | +---+ |/+---+ |/|\n|   |/   /| +/   /|-+ |\n+---+---+ |/+---+ |/| +\n|   |   | +-|   | + |/.\n|   |   |/  |   |/| +..\n+---+---+---+---+ |/...\n|   |   |   |   | +....\n|   |   |   |   |/.....\n+---+---+---+---+......"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "2008", "NOIP 普及组", "枚举"], "title": "[NOIP 2008 普及组] 立体图", "background": null, "description": "小渊是个聪明的孩子，他经常会给周围的小朋友们讲些自己认为有趣的内容。最近，他准备给小朋友们讲解立体图，请你帮他画出立体图。\n\n小渊有一块面积为 $m \\times n$ 的矩形区域，上面有 $m \\times n$ 个边长为 $1$ 的格子，每个格子上堆了一些同样大小的积木（积木的长宽高都是 $1$），小渊想请你打印出这些格子的立体图。我们定义每个积木为如下格式，并且不会做任何翻转旋转，只会严格以这一种形式摆放：\n\n$$\n\\def\\arraystretch{1e-10}\n\\begin{aligned}\n&\\verb!  +---+!\\\\\n&\\verb! /   /|!\\\\\n&\\verb!+---+ |!\\quad\\textsf{高}\\\\\n&\\verb!|   | +!\\\\\n&\\verb!|   |/ !\\quad\\textsf{宽}\\\\\n&\\verb!+---+  !\\\\\n& \\quad\\textsf{长}\n\\end{aligned}$$\n\n\n每个顶点用 $1$ 个加号 `+` 表示，长用 $3$ 个 `-` 表示，宽用 $1$ 个 `/`，高用两个 `|` 表示。字符 `+`，`-`，`/`，`|` 的 ASCII 码分别为 $43$，$45$，$47$，$124$。字符 `.`（ASCII 码 $46$）需要作为背景输出，即立体图里的空白部分需要用 `.` 来代替。立体图的画法如下面的规则：\n\n若两块积木左右相邻，图示为：\n\n\n$$\n\\def\\arraystretch{1e-10}\n\\begin{aligned}\n\\verb!..+---+---+!\\\\\n\\verb!./   /   /|!\\\\\n\\verb!+---+---+ |!\\\\\n\\verb!|   |   | +!\\\\\n\\verb!|   |   |/.!\\\\\n\\verb!+---+---+..!\\\\\n\\end{aligned}\n$$\n\n若两块积木上下相邻，图示为：\n\n\n$$\n\\def\\arraystretch{1e-10}\n\\begin{aligned}\n\\verb!..+---+!\\\\\n\\verb!./   /|!\\\\\n\\verb!+---+ |!\\\\\n\\verb!|   | +!\\\\\n\\verb!|   |/|!\\\\\n\\verb!+---+ |!\\\\\n\\verb!|   | +!\\\\\n\\verb!|   |/.!\\\\\n\\verb!+---+..!\\\\\n\\end{aligned}\n$$\n\n若两块积木前后相邻，图示为：\n\n$$\n\\def\\arraystretch{1e-10}\n\\begin{aligned}\n\\verb!....+---+!\\\\\n\\verb!.../   /|!\\\\\n\\verb!..+---+ |!\\\\\n\\verb!./   /| +!\\\\\n\\verb!+---+ |/.!\\\\\n\\verb!|   | +..!\\\\\n\\verb!|   |/...!\\\\\n\\verb!+---+....!\\\\\n\\end{aligned}\n$$\n\n立体图中，定义位于第 $(m,1)$ 的格子（即第 $m$ 行第 $1$ 列的格子）上面自底向上的第一块积木（即最下面的一块积木）的左下角顶点为整张图最左下角的点。", "inputFormat": "第一行有用空格隔开的 $2$ 个整数 $m$ 和 $n$，表示有 $m \\times n$ 个格子 $(1 \\le m,n \\le 50)$。\n\n接下来的 $m$ 行，是一个 $m \\times n$ 的矩阵，每行有 $n$ 个用空格隔开的整数，其中第 $i$ 行第 $j$ 列上的整数表示第 $i$ 行第 $j$ 列的格子上摞有多少个积木（$1 \\le $ 每个格子上的积木数 $ \\le 100$）。", "outputFormat": "输出包含题目要求的立体图，是一个 $K$ 行 $L$ 列的字符串矩阵，其中 $K$ 和 $L$ 表示最少需要 $K$ 行 $L$ 列才能按规定输出立体图。", "hint": "NOIP2008 普及组第四题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2008 Junior] 3D Diagram", "background": null, "description": "Xiao Yuan is a smart kid who often tells his friends things he finds interesting. Recently, he plans to explain 3D diagrams to them and asks you to draw the 3D diagram.\n\nXiao Yuan has a rectangular area of size $m \\times n$ consisting of $m \\times n$ unit squares. On each square, some identical blocks are stacked (each block has length, width, and height all equal to $1$). He wants you to print the 3D diagram of these squares. Each block is defined in the following format, and there is no flipping or rotation; blocks are placed strictly in this single orientation:\n\n$$\n\\def\\arraystretch{1e-10}\n\\begin{aligned}\n&\\verb!  +---+!\\\\\n&\\verb! /   /|!\\\\\n&\\verb!+---+ |!\\quad\\textsf{高}\\\\\n&\\verb!|   | +!\\\\\n&\\verb!|   |/ !\\quad\\textsf{宽}\\\\\n&\\verb!+---+  !\\\\\n& \\quad\\textsf{长}\n\\end{aligned}$$\n\nEach vertex is represented by one plus sign `+`, the length by three `-`, the width by one `/`, and the height by two `|`. The ASCII codes of characters `+`, `-`, `/`, `|` are $43$, $45$, $47$, $124$, respectively. The character `.` (ASCII code $46$) must be printed as the background; that is, blank areas in the 3D diagram should be filled with `.`. The drawing rules are as follows:\n\nIf two blocks are adjacent horizontally (left-right), they look like:\n\n$$\n\\def\\arraystretch{1e-10}\n\\begin{aligned}\n\\verb!..+---+---+!\\\\\n\\verb!./   /   /|!\\\\\n\\verb!+---+---+ |!\\\\\n\\verb!|   |   | +!\\\\\n\\verb!|   |   |/.!\\\\\n\\verb!+---+---+..!\\\\\n\\end{aligned}\n$$\n\nIf two blocks are adjacent vertically (up-down), they look like:\n\n$$\n\\def\\arraystretch{1e-10}\n\\begin{aligned}\n\\verb!..+---+!\\\\\n\\verb!./   /|!\\\\\n\\verb!+---+ |!\\\\\n\\verb!|   | +!\\\\\n\\verb!|   |/|!\\\\\n\\verb!+---+ |!\\\\\n\\verb!|   | +!\\\\\n\\verb!|   |/.!\\\\\n\\verb!+---+..!\\\\\n\\end{aligned}\n$$\n\nIf two blocks are adjacent front-to-back, they look like:\n\n$$\n\\def\\arraystretch{1e-10}\n\\begin{aligned}\n\\verb!....+---+!\\\\\n\\verb!.../   /|!\\\\\n\\verb!..+---+ |!\\\\\n\\verb!./   /| +!\\\\\n\\verb!+---+ |/.!\\\\\n\\verb!|   | +..!\\\\\n\\verb!|   |/...!\\\\\n\\verb!+---+....!\\\\\n\\end{aligned}\n$$\n\nIn the 3D diagram, define the lower-left corner vertex of the bottom-most block on the square at $(m, 1)$ (i.e., row $m$, column $1$) as the lower-left corner of the entire diagram.", "inputFormat": "The first line contains two integers $m$ and $n$ separated by a space, indicating there are $m \\times n$ squares ($1 \\le m, n \\le 50$).\n\nThe next $m$ lines give an $m \\times n$ matrix. Each line contains $n$ integers separated by spaces; the integer at row $i$, column $j$ is the number of blocks stacked on that square ($1 \\le$ the number of blocks on each cell $\\le 100$).", "outputFormat": "Output the required 3D diagram as a $K$-row by $L$-column character matrix, where $K$ and $L$ are the minimal numbers of rows and columns needed to print the diagram according to the rules.", "hint": "NOIP 2008 Junior, Problem 4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2008 普及组] 立体图", "background": null, "description": "小渊是个聪明的孩子，他经常会给周围的小朋友们讲些自己认为有趣的内容。最近，他准备给小朋友们讲解立体图，请你帮他画出立体图。\n\n小渊有一块面积为 $m \\times n$ 的矩形区域，上面有 $m \\times n$ 个边长为 $1$ 的格子，每个格子上堆了一些同样大小的积木（积木的长宽高都是 $1$），小渊想请你打印出这些格子的立体图。我们定义每个积木为如下格式，并且不会做任何翻转旋转，只会严格以这一种形式摆放：\n\n$$\n\\def\\arraystretch{1e-10}\n\\begin{aligned}\n&\\verb!  +---+!\\\\\n&\\verb! /   /|!\\\\\n&\\verb!+---+ |!\\quad\\textsf{高}\\\\\n&\\verb!|   | +!\\\\\n&\\verb!|   |/ !\\quad\\textsf{宽}\\\\\n&\\verb!+---+  !\\\\\n& \\quad\\textsf{长}\n\\end{aligned}$$\n\n\n每个顶点用 $1$ 个加号 `+` 表示，长用 $3$ 个 `-` 表示，宽用 $1$ 个 `/`，高用两个 `|` 表示。字符 `+`，`-`，`/`，`|` 的 ASCII 码分别为 $43$，$45$，$47$，$124$。字符 `.`（ASCII 码 $46$）需要作为背景输出，即立体图里的空白部分需要用 `.` 来代替。立体图的画法如下面的规则：\n\n若两块积木左右相邻，图示为：\n\n\n$$\n\\def\\arraystretch{1e-10}\n\\begin{aligned}\n\\verb!..+---+---+!\\\\\n\\verb!./   /   /|!\\\\\n\\verb!+---+---+ |!\\\\\n\\verb!|   |   | +!\\\\\n\\verb!|   |   |/.!\\\\\n\\verb!+---+---+..!\\\\\n\\end{aligned}\n$$\n\n若两块积木上下相邻，图示为：\n\n\n$$\n\\def\\arraystretch{1e-10}\n\\begin{aligned}\n\\verb!..+---+!\\\\\n\\verb!./   /|!\\\\\n\\verb!+---+ |!\\\\\n\\verb!|   | +!\\\\\n\\verb!|   |/|!\\\\\n\\verb!+---+ |!\\\\\n\\verb!|   | +!\\\\\n\\verb!|   |/.!\\\\\n\\verb!+---+..!\\\\\n\\end{aligned}\n$$\n\n若两块积木前后相邻，图示为：\n\n$$\n\\def\\arraystretch{1e-10}\n\\begin{aligned}\n\\verb!....+---+!\\\\\n\\verb!.../   /|!\\\\\n\\verb!..+---+ |!\\\\\n\\verb!./   /| +!\\\\\n\\verb!+---+ |/.!\\\\\n\\verb!|   | +..!\\\\\n\\verb!|   |/...!\\\\\n\\verb!+---+....!\\\\\n\\end{aligned}\n$$\n\n立体图中，定义位于第 $(m,1)$ 的格子（即第 $m$ 行第 $1$ 列的格子）上面自底向上的第一块积木（即最下面的一块积木）的左下角顶点为整张图最左下角的点。", "inputFormat": "第一行有用空格隔开的 $2$ 个整数 $m$ 和 $n$，表示有 $m \\times n$ 个格子 $(1 \\le m,n \\le 50)$。\n\n接下来的 $m$ 行，是一个 $m \\times n$ 的矩阵，每行有 $n$ 个用空格隔开的整数，其中第 $i$ 行第 $j$ 列上的整数表示第 $i$ 行第 $j$ 列的格子上摞有多少个积木（$1 \\le $ 每个格子上的积木数 $ \\le 100$）。", "outputFormat": "输出包含题目要求的立体图，是一个 $K$ 行 $L$ 列的字符串矩阵，其中 $K$ 和 $L$ 表示最少需要 $K$ 行 $L$ 列才能按规定输出立体图。", "hint": "NOIP2008 普及组第四题", "locale": "zh-CN"}}}
{"pid": "P1059", "type": "P", "difficulty": 2, "samples": [["10\n20 40 32 67 40 20 89 300 400 15\n", "8\n15 20 32 40 67 89 300 400\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2006", "NOIP 普及组", "排序", "STL"], "title": "[NOIP 2006 普及组] 明明的随机数", "background": "", "description": "明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 $N$ 个 $1$ 到 $1000$ 之间的随机整数 $(N\\leq100)$，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。\n", "inputFormat": "输入有两行，第 $1$ 行为 $1$ 个正整数，表示所生成的随机数的个数 $N$。\n\n第 $2$ 行有 $N$ 个用空格隔开的正整数，为所产生的随机数。\n", "outputFormat": "输出也是两行，第 $1$ 行为 $1$ 个正整数 $M$，表示不相同的随机数的个数。\n\n第 $2$ 行为 $M$ 个用空格隔开的正整数，为从小到大排好序的不相同的随机数。\n", "hint": "NOIP 2006 普及组 第一题\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2006 Junior] Mingming's Random Numbers", "background": null, "description": "Mingming wants to invite some classmates at school to fill out a questionnaire. For objectivity, he first uses a computer to generate $N$ random integers between $1$ and $1000$ ($N \\leq 100$). For any duplicates, keep exactly one occurrence and remove the rest; different numbers correspond to different students' ID numbers. Then sort these numbers in ascending order, and visit the classmates in the sorted order. Please help Mingming remove duplicates and sort the numbers.", "inputFormat": "The input has two lines.  \nThe first line contains a positive integer, the number $N$ of generated random integers.  \nThe second line contains $N$ positive integers separated by spaces, which are the generated random integers.", "outputFormat": "The output also has two lines.  \nThe first line contains a positive integer $M$, the number of distinct random integers.  \nThe second line contains $M$ positive integers separated by spaces, which are the distinct random integers in ascending order.", "hint": "NOIP 2006 Junior, Problem 1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2006 普及组] 明明的随机数", "background": "", "description": "明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 $N$ 个 $1$ 到 $1000$ 之间的随机整数 $(N\\leq100)$，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。\n", "inputFormat": "输入有两行，第 $1$ 行为 $1$ 个正整数，表示所生成的随机数的个数 $N$。\n\n第 $2$ 行有 $N$ 个用空格隔开的正整数，为所产生的随机数。\n", "outputFormat": "输出也是两行，第 $1$ 行为 $1$ 个正整数 $M$，表示不相同的随机数的个数。\n\n第 $2$ 行为 $M$ 个用空格隔开的正整数，为从小到大排好序的不相同的随机数。\n", "hint": "NOIP 2006 普及组 第一题\n", "locale": "zh-CN"}}}
{"pid": "P1060", "type": "P", "difficulty": 2, "samples": [["1000 5\n800 2\n400 5\n300 5\n400 3\n200 2\n", "3900"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["动态规划 DP", "2006", "NOIP 普及组", "背包 DP"], "title": "[NOIP 2006 普及组] 开心的金明", "background": null, "description": "金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $N$ 元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 $N$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1-5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过 $N$ 元（可以等于 $N$ 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。\n\n设第 $j$ 件物品的价格为 $v_j$，重要度为 $w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,…,j_k$，则所求的总和为：\n\n$$v_{j_1} \\times w_{j_1}+v_{j_2} \\times w_{j_2} …+v_{j_k} \\times w_{j_k}$$\n\n请你帮助金明设计一个满足要求的购物单。", "inputFormat": "第一行，为 $2$ 个正整数，用一个空格隔开：$n,m$（$n<3\\times10^4,m<25$）其中 $n$ 表示总钱数，$m$ 为希望购买物品的个数。\n\n从第 $2$ 行到第 $m+1$ 行，第 $j$ 行给出了编号为 $j-1$ 的物品的基本数据，每行有 $2$ 个非负整数 $v,p$（其中 $v$ 表示该物品的价格 $(v \\le 10^4)$，$p$ 表示该物品的重要度（$1\\le p\\le5$））。", "outputFormat": "$1$ 个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（$<10^8$）。", "hint": "NOIP 2006 普及组 第二题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2006 Junior] Happy Jinming", "background": null, "description": "Jinming is very happy today because his family is about to receive the keys to their new home, which has a spacious room just for him. What makes him even happier is that his mom told him yesterday: “You decide which items to buy and how to furnish your room, as long as the total cost does not exceed $N$ yuan.” Early this morning, Jinming started making a budget, but there are too many things he wants to buy, so the total will definitely exceed the limit $N$. Therefore, he assigns an importance level to each item, divided into 5 levels, represented by integers 1–5, with level 5 being the most important. He also found the price of each item on the Internet (all in integer yuan). He hopes to maximize the sum of price times importance for the selected items, under the constraint that the total cost does not exceed $N$ yuan (it may be equal to $N$ yuan).\n\nLet the price of item $j$ be $v_j$ and its importance be $w_j$. If $k$ items are selected with indices $j_1, j_2, \\dots, j_k$, then the desired total is:\n$$v_{j_1} \\times w_{j_1} + v_{j_2} \\times w_{j_2} + \\cdots + v_{j_k} \\times w_{j_k}.$$\n\nPlease help Jinming design a shopping list that meets the requirements.", "inputFormat": "The first line contains $2$ positive integers separated by a space: $n, m$ ($n < 30000, m < 25$), where $n$ is the total amount of money and $m$ is the number of items.\n\nFrom line $2$ to line $m+1$, the $i$-th of these lines (corresponding to item $i$) contains two non-negative integers $v, p$, where $v$ is the price ($v \\le 10000$) and $p$ is the importance ($1 \\le p \\le 5$).", "outputFormat": "Output $1$ positive integer: the maximum possible value of the sum of price times importance for the selected items without exceeding the total amount of money (this value is $< 100000000$).", "hint": "NOIP 2006 Junior, Problem 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2006 普及组] 开心的金明", "background": null, "description": "金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $N$ 元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 $N$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1-5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过 $N$ 元（可以等于 $N$ 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。\n\n设第 $j$ 件物品的价格为 $v_j$，重要度为 $w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,…,j_k$，则所求的总和为：\n\n$$v_{j_1} \\times w_{j_1}+v_{j_2} \\times w_{j_2} …+v_{j_k} \\times w_{j_k}$$\n\n请你帮助金明设计一个满足要求的购物单。", "inputFormat": "第一行，为 $2$ 个正整数，用一个空格隔开：$n,m$（$n<3\\times10^4,m<25$）其中 $n$ 表示总钱数，$m$ 为希望购买物品的个数。\n\n从第 $2$ 行到第 $m+1$ 行，第 $j$ 行给出了编号为 $j-1$ 的物品的基本数据，每行有 $2$ 个非负整数 $v,p$（其中 $v$ 表示该物品的价格 $(v \\le 10^4)$，$p$ 表示该物品的重要度（$1\\le p\\le5$））。", "outputFormat": "$1$ 个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（$<10^8$）。", "hint": "NOIP 2006 普及组 第二题", "locale": "zh-CN"}}}
{"pid": "P1061", "type": "P", "difficulty": 3, "samples": [["2 10 5\nbdfij\n", "bdghi\nbdghj\nbdgij\nbdhij\nbefgh\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2006", "NOIP 普及组"], "title": "[NOIP 2006 普及组] Jam 的计数法", "background": "", "description": "Jam 是个喜欢标新立异的科学怪人。他不使用阿拉伯数字计数，而是使用小写英文字母计数，他觉得这样做，会使世界更加丰富多彩。\n\n在他的计数法中，每个数字的位数都是相同的（使用相同个数的字母），英文字母按原先的顺序，排在前面的字母小于排在它后面的字母。我们把这样的“数字”称为 Jam 数字。在 Jam 数字中，每个字母互不相同，而且从左到右是严格递增的。每次，Jam 还指定使用字母的范围，例如，从 $2\\sim 10$，表示只能使用 ${b,c,d,e,f,g,h,i,j}$ 这些字母。如果再规定位数为 $5$，那么，紧接在 Jam 数字 $\\texttt{bdfij}$ 之后的数字应该是 $\\texttt{bdghi}$。（如果我们用 $U$、$V$ 依次表示 Jam 数字 $\\texttt{bdfij}$ 与 $\\texttt{bdghi}$，则 $U<V$，且不存在 Jam 数字 $P$，使 $U<P<V$）。\n\n你的任务是：对于从文件读入的一个 Jam 数字，按顺序输出紧接在后面的 $5$ 个 Jam 数字，如果后面没有那么多 Jam 数字，那么有几个就输出几个。", "inputFormat": "共 $2$ 行。\n\n第 $1$ 行为 $3$ 个正整数 $s, t, w$，用一个空格隔开。\n\n（其中 $s$ 为所使用的最小的字母的序号，$t$ 为所使用的最大的字母的序号。$w$ 为数字的位数，这 $3$ 个数满足：$1\\le s<t\\le 26,2\\le w\\le t-s$）\n\n第 $2$ 行为具有 $w$ 个小写字母的字符串，为一个符合要求的 Jam 数字。\n\n所给的数据都是正确的，不必验证。", "outputFormat": "最多为 $5$ 行，为紧接在输入的 Jam 数字后面的 $5$ 个 Jam 数字，如果后面没有那么多 Jam 数字，那么有几个就输出几个。每行只输出一个 Jam 数字，是由 $w$ 个小写字母组成的字符串，不要有多余的空格。", "hint": "NOIP 2006 普及组 第三题\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2006 Junior] Jam's Counting Method", "background": null, "description": "Jam is an eccentric scientist who likes to be unconventional. He does not count with Arabic numerals, but with lowercase English letters. He believes this makes the world more colorful.\n\nIn his counting system, every number has the same length (uses the same number of letters). The English letters keep their original order, and a letter earlier in the alphabet is smaller than a letter later in the alphabet. We call such “numbers” Jam numbers. In a Jam number, all letters are distinct and strictly increasing from left to right. Each time, Jam also specifies the range of letters to use; for example, from $2\\sim 10$ means only the letters ${b,c,d,e,f,g,h,i,j}$ can be used. If the length is further specified to be $5$, then the number immediately following the Jam number $\\texttt{bdfij}$ should be $\\texttt{bdghi}$ (if we denote the Jam numbers $\\texttt{bdfij}$ and $\\texttt{bdghi}$ by $U$ and $V$ in order, then $U<V$, and there is no Jam number $P$ such that $U<P<V$).\n\nYour task: Given a Jam number read from the file, output in order the next $5$ Jam numbers. If there are fewer than $5$ Jam numbers after it, output as many as exist.", "inputFormat": "There are $2$ lines.\n\nThe first line contains $3$ positive integers $s, t, w$, separated by a space.\n\n(Here, $s$ is the index of the smallest letter used, $t$ is the index of the largest letter used, and $w$ is the length of the number. These $3$ numbers satisfy $1\\le s<t\\le 26,2\\le w\\le t-s$.)\n\nThe second line is a string with $w$ lowercase letters, which is a valid Jam number.\n\nThe given testdata is correct; no validation is needed.", "outputFormat": "Output up to $5$ lines: the next $5$ Jam numbers after the input Jam number in order. If there are fewer than $5$ Jam numbers after it, output as many as exist. Print exactly one Jam number per line, each being a string of $w$ lowercase letters, with no extra spaces.", "hint": "NOIP 2006 Junior Problem 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2006 普及组] Jam 的计数法", "background": "", "description": "Jam 是个喜欢标新立异的科学怪人。他不使用阿拉伯数字计数，而是使用小写英文字母计数，他觉得这样做，会使世界更加丰富多彩。\n\n在他的计数法中，每个数字的位数都是相同的（使用相同个数的字母），英文字母按原先的顺序，排在前面的字母小于排在它后面的字母。我们把这样的“数字”称为 Jam 数字。在 Jam 数字中，每个字母互不相同，而且从左到右是严格递增的。每次，Jam 还指定使用字母的范围，例如，从 $2\\sim 10$，表示只能使用 ${b,c,d,e,f,g,h,i,j}$ 这些字母。如果再规定位数为 $5$，那么，紧接在 Jam 数字 $\\texttt{bdfij}$ 之后的数字应该是 $\\texttt{bdghi}$。（如果我们用 $U$、$V$ 依次表示 Jam 数字 $\\texttt{bdfij}$ 与 $\\texttt{bdghi}$，则 $U<V$，且不存在 Jam 数字 $P$，使 $U<P<V$）。\n\n你的任务是：对于从文件读入的一个 Jam 数字，按顺序输出紧接在后面的 $5$ 个 Jam 数字，如果后面没有那么多 Jam 数字，那么有几个就输出几个。", "inputFormat": "共 $2$ 行。\n\n第 $1$ 行为 $3$ 个正整数 $s, t, w$，用一个空格隔开。\n\n（其中 $s$ 为所使用的最小的字母的序号，$t$ 为所使用的最大的字母的序号。$w$ 为数字的位数，这 $3$ 个数满足：$1\\le s<t\\le 26,2\\le w\\le t-s$）\n\n第 $2$ 行为具有 $w$ 个小写字母的字符串，为一个符合要求的 Jam 数字。\n\n所给的数据都是正确的，不必验证。", "outputFormat": "最多为 $5$ 行，为紧接在输入的 Jam 数字后面的 $5$ 个 Jam 数字，如果后面没有那么多 Jam 数字，那么有几个就输出几个。每行只输出一个 Jam 数字，是由 $w$ 个小写字母组成的字符串，不要有多余的空格。", "hint": "NOIP 2006 普及组 第三题\n", "locale": "zh-CN"}}}
{"pid": "P1062", "type": "P", "difficulty": 2, "samples": [["3 100", "981"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2006", "NOIP 普及组", "进制"], "title": "[NOIP 2006 普及组] 数列", "background": "", "description": "给定一个正整数 $k$（$3\\leq k\\leq 15$），把所有 $k$ 的方幂及所有有限个互不相等的 $k$ 的方幂之和构成一个递增的序列，例如，当 $k = 3$ 时，这个序列是：\n\n$1, 3, 4, 9, 10, 12, 13, \\ldots$\n\n（该序列实际上就是：$3^0,3^1,3^0+3^1,3^2,3^0+3^2,3^1+3^2,3^0+3^1+3^2,…$）\n\n请你求出这个序列的第 $N$ 项的值，用 $10$ 进制数表示。\n\n例如，对于 $k = 3$，$N = 100$，正确答案应该是 $981$。\n", "inputFormat": "两个由空格隔开的正整数 $k, N$（$3\\leq k\\leq 15$，$10\\leq N\\leq 1000$）。", "outputFormat": "一个正整数。整数前不要有空格和其他符号。\n", "hint": "NOIP 2006 普及组 第四题\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2006 Junior] Sequence", "background": null, "description": "Given a positive integer $k$ ($3 \\leq k \\leq 15$), form an increasing sequence consisting of all powers of $k$ and all sums of finitely many distinct powers of $k$. For example, when $k = 3$, the sequence is:\n\n$1, 3, 4, 9, 10, 12, 13, \\ldots$\n\n(This sequence is in fact: $3^0,3^1,3^0+3^1,3^2,3^0+3^2,3^1+3^2,3^0+3^1+3^2,…$.)\n\nPlease compute the value of the $N$-th term of this sequence and output it in base $10$ (decimal).\n\nFor example, for $k = 3$ and $N = 100$, the correct answer is $981$.", "inputFormat": "Two positive integers $k$ and $N$ separated by a space ($3 \\leq k \\leq 15$, $10 \\leq N \\leq 1000$).", "outputFormat": "A single positive integer. Do not print any spaces or other symbols before the integer.", "hint": "NOIP 2006 Junior Problem 4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2006 普及组] 数列", "background": "", "description": "给定一个正整数 $k$（$3\\leq k\\leq 15$），把所有 $k$ 的方幂及所有有限个互不相等的 $k$ 的方幂之和构成一个递增的序列，例如，当 $k = 3$ 时，这个序列是：\n\n$1, 3, 4, 9, 10, 12, 13, \\ldots$\n\n（该序列实际上就是：$3^0,3^1,3^0+3^1,3^2,3^0+3^2,3^1+3^2,3^0+3^1+3^2,…$）\n\n请你求出这个序列的第 $N$ 项的值，用 $10$ 进制数表示。\n\n例如，对于 $k = 3$，$N = 100$，正确答案应该是 $981$。\n", "inputFormat": "两个由空格隔开的正整数 $k, N$（$3\\leq k\\leq 15$，$10\\leq N\\leq 1000$）。", "outputFormat": "一个正整数。整数前不要有空格和其他符号。\n", "hint": "NOIP 2006 普及组 第四题\n", "locale": "zh-CN"}}}
{"pid": "P1063", "type": "P", "difficulty": 4, "samples": [["4\n2 3 5 10\n", "710"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2006", "递归", "NOIP 提高组", "枚举", "区间 DP"], "title": "[NOIP 2006 提高组] 能量项链", "background": "", "description": "在 Mars 星球上，每个 Mars 人都随身佩带着一串能量项链。在项链上有 $N$ 颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是 Mars 人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为 $m$，尾标记为 $r$，后一颗能量珠的头标记为 $r$，尾标记为 $n$，则聚合后释放的能量为 $m \\times r \\times n$（Mars 单位），新产生的珠子的头标记为 $m$，尾标记为 $n$。\n\n需要时，Mars 人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。\n\n例如：设 $N=4$，$4$ 颗珠子的头标记与尾标记依次为 $(2,3)(3,5)(5,10)(10,2)$。我们用记号 $\\oplus$ 表示两颗珠子的聚合操作，$(j \\oplus k)$ 表示第 $j,k$ 两颗珠子聚合后所释放的能量。则第 $4$，$1$ 两颗珠子聚合后释放的能量为：\n\n$(4 \\oplus 1)=10 \\times 2 \\times 3=60$。\n\n这一串项链可以得到最优值的一个聚合顺序所释放的总能量为：\n\n$(((4 \\oplus 1) \\oplus 2) \\oplus 3)=10 \\times 2 \\times 3+10 \\times 3 \\times 5+10 \\times 5 \\times 10=710$。", "inputFormat": "第一行是一个正整数 $N$（$4 \\le N \\le 100$），表示项链上珠子的个数。第二行是 $N$ 个用空格隔开的正整数，所有的数均不超过 $1000$。第 $i$ 个数为第 $i$ 颗珠子的头标记（$1 \\le i \\le N$），当 $i<N$ 时，第 $i$ 颗珠子的尾标记应该等于第 $i+1$ 颗珠子的头标记。第 $N$ 颗珠子的尾标记应该等于第 $1$ 颗珠子的头标记。\n\n至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。", "outputFormat": "一个正整数 $E$（$E\\le 2.1 \\times 10^9$），为一个最优聚合顺序所释放的总能量。\n", "hint": "NOIP 2006 提高组 第一题\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2006 Senior] Energy Necklace", "background": null, "description": "On the planet Mars, every Martian wears an energy necklace. The necklace has $N$ energy beads. Each bead has a head label and a tail label, both being positive integers. For any two adjacent beads, the tail label of the previous bead must be equal to the head label of the next bead. Only in this way, through the action of a suction cup (an organ used by Martians to absorb energy), can the two beads merge into one, while releasing energy that can be absorbed. If the head and tail labels of the previous bead are $m$ and $r$, and the head and tail labels of the next bead are $r$ and $n$, then the energy released by merging is $m \\times r \\times n$ (Mars units), and the new bead will have head label $m$ and tail label $n$.\n\nWhen needed, a Martian uses the suction cup to clamp two adjacent beads and keeps merging to obtain energy until only one bead remains on the necklace. Obviously, different merging orders yield different total energy. Please design a merging order that maximizes the total energy released by the necklace.\n\nFor example: let $N = 4$. The head and tail labels of the 4 beads in order are $(2, 3)(3, 5)(5, 10)(10, 2)$. We use the symbol $\\oplus$ to denote the merging of two beads, and $(j \\oplus k)$ to denote the energy released by merging beads $j$ and $k$. Then the energy released by merging beads $4$ and $1$ is:\n$$(4 \\oplus 1) = 10 \\times 2 \\times 3 = 60.$$\n\nOne optimal merging order yields the following total energy:\n$$(((4 \\oplus 1) \\oplus 2) \\oplus 3) = 10 \\times 2 \\times 3 + 10 \\times 3 \\times 5 + 10 \\times 5 \\times 10 = 710.$$", "inputFormat": "- The first line contains a positive integer $N$ ($4 \\le N \\le 100$), the number of beads on the necklace.\n- The second line contains $N$ positive integers separated by spaces, each not exceeding $1000$. The $i$-th number is the head label of bead $i$ ($1 \\le i \\le N$). When $i < N$, the tail label of bead $i$ is equal to the head label of bead $i + 1$. The tail label of bead $N$ is equal to the head label of bead $1$.\n\nTo determine the order of the beads, place the necklace flat on a table without crossings, arbitrarily choose the first bead, then determine the remaining beads in the clockwise direction.", "outputFormat": "Output a single integer $E$ ($E \\le 2.1 \\times 10^9$), the total energy released by an optimal merging order.", "hint": "NOIP 2006 Senior Problem 1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2006 提高组] 能量项链", "background": "", "description": "在 Mars 星球上，每个 Mars 人都随身佩带着一串能量项链。在项链上有 $N$ 颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是 Mars 人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为 $m$，尾标记为 $r$，后一颗能量珠的头标记为 $r$，尾标记为 $n$，则聚合后释放的能量为 $m \\times r \\times n$（Mars 单位），新产生的珠子的头标记为 $m$，尾标记为 $n$。\n\n需要时，Mars 人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。\n\n例如：设 $N=4$，$4$ 颗珠子的头标记与尾标记依次为 $(2,3)(3,5)(5,10)(10,2)$。我们用记号 $\\oplus$ 表示两颗珠子的聚合操作，$(j \\oplus k)$ 表示第 $j,k$ 两颗珠子聚合后所释放的能量。则第 $4$，$1$ 两颗珠子聚合后释放的能量为：\n\n$(4 \\oplus 1)=10 \\times 2 \\times 3=60$。\n\n这一串项链可以得到最优值的一个聚合顺序所释放的总能量为：\n\n$(((4 \\oplus 1) \\oplus 2) \\oplus 3)=10 \\times 2 \\times 3+10 \\times 3 \\times 5+10 \\times 5 \\times 10=710$。", "inputFormat": "第一行是一个正整数 $N$（$4 \\le N \\le 100$），表示项链上珠子的个数。第二行是 $N$ 个用空格隔开的正整数，所有的数均不超过 $1000$。第 $i$ 个数为第 $i$ 颗珠子的头标记（$1 \\le i \\le N$），当 $i<N$ 时，第 $i$ 颗珠子的尾标记应该等于第 $i+1$ 颗珠子的头标记。第 $N$ 颗珠子的尾标记应该等于第 $1$ 颗珠子的头标记。\n\n至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。", "outputFormat": "一个正整数 $E$（$E\\le 2.1 \\times 10^9$），为一个最优聚合顺序所释放的总能量。\n", "hint": "NOIP 2006 提高组 第一题\n", "locale": "zh-CN"}}}
{"pid": "P1064", "type": "P", "difficulty": 4, "samples": [["1000 5\n800 2 0\n400 5 1\n300 5 1\n400 3 0\n500 2 0\n", "2200"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2006", "NOIP 提高组", "背包 DP"], "title": "[NOIP 2006 提高组] 金明的预算方案", "background": "", "description": "金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $n$ 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：\n\n| 主件 | 附件 |\n| :----------: | :----------: |\n| 电脑 | 打印机，扫描仪 |\n| 书柜 | 图书 |\n| 书桌 | 台灯，文具 |\n| 工作椅 | 无 |\n\n如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 $0$ 个、$1$ 个或 $2$ 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 $n$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1 \\sim 5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是 $10$ 元的整数倍）。他希望在不超过 $n$ 元的前提下，使每件物品的价格与重要度的乘积的总和最大。\n\n设第 $j$ 件物品的价格为 $v_j$，重要度为 $w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,\\dots,j_k$，则所求的总和为：\n\n$$v_{j_1} \\times w_{j_1}+v_{j_2} \\times w_{j_2}+ \\dots +v_{j_k} \\times w_{j_k}$$\n\n请你帮助金明设计一个满足要求的购物单。\n", "inputFormat": "第一行有两个整数，分别表示总钱数 $n$ 和希望购买的物品个数 $m$。\n\n第 $2$ 到第 $(m + 1)$ 行，每行三个整数，第 $(i + 1)$ 行的整数 $v_i$，$p_i$，$q_i$ 分别表示第 $i$ 件物品的价格、重要度以及它对应的的主件。如果 $q_i=0$，表示该物品本身是主件。\n", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 3.2 \\times 10^4$，$1 \\leq m \\leq 60$，$0 \\leq v_i \\leq 10^4$，$1 \\leq p_i \\leq 5$，$0 \\leq q_i \\leq m$，答案不超过 $2 \\times 10^5$。\n\nNOIP 2006 提高组 第二题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2006 Senior] Jinming’s Budget Plan", "background": null, "description": "Jinming is very happy today because his family is about to receive the keys to their new home, which has a spacious room just for him. What makes him even happier is that his mother told him yesterday: “You can decide what to buy and how to arrange your room, as long as it doesn’t cost more than $n$ yuan.” Early this morning, Jinming started budgeting. He divides the items he wants to buy into two categories: main items and accessories. Accessories belong to a specific main item. The table below shows some examples of main items and accessories:\n\n| Main Item | Accessory |\n| :----------: | :----------: |\n| Computer | Printer, scanner |\n| Bookcase | Books |\n| Desk | Desk lamp, stationery |\n| Office chair | None |\n\nTo buy an item classified as an accessory, you must first buy its corresponding main item. Each main item can have $0$, $1$, or $2$ accessories. Each accessory corresponds to one main item, and accessories do not have accessories of their own. Jinming wants to buy many things, and surely the total will exceed $n$ yuan. So he assigns an importance level to each item, divided into $5$ levels represented by integers $1$ to $5$, with level $5$ being the most important. He also found the price of each item on the Internet (all prices are multiples of $10$ yuan). He wants to maximize the sum of the product of price and importance for the selected items without exceeding $n$ yuan.\n\nLet the price of the $j$-th item be $v_j$ and its importance be $w_j$. Suppose $k$ items are selected, with indices $j_1, j_2, \\dots, j_k$. The target sum is:\n\n$$v_{j_1} \\times w_{j_1}+v_{j_2} \\times w_{j_2}+ \\dots +v_{j_k} \\times w_{j_k}$$\n\nPlease help Jinming design a shopping list that meets the requirements.", "inputFormat": "The first line contains two integers, the total budget $n$ and the number of items $m$.\n\nFor lines $2$ to $m + 1$, each line contains three integers. On the $(i + 1)$-th line, the integers $v_i$, $p_i$, $q_i$ denote the price, importance, and the index of its main item for the $i$-th item, respectively. If $q_i = 0$, it means the item itself is a main item.", "outputFormat": "Output a single integer on one line representing the answer.", "hint": "Constraints\n\nFor all test points, it is guaranteed that $1 \\leq n \\leq 3.2 \\times 10^4$, $1 \\leq m \\leq 60$, $0 \\leq v_i \\leq 10^4$, $1 \\leq p_i \\leq 5$, $0 \\leq q_i \\leq m$, and the answer does not exceed $2 \\times 10^5$.\n\nNOIP 2006 Senior, Problem 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2006 提高组] 金明的预算方案", "background": "", "description": "金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $n$ 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：\n\n| 主件 | 附件 |\n| :----------: | :----------: |\n| 电脑 | 打印机，扫描仪 |\n| 书柜 | 图书 |\n| 书桌 | 台灯，文具 |\n| 工作椅 | 无 |\n\n如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 $0$ 个、$1$ 个或 $2$ 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 $n$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1 \\sim 5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是 $10$ 元的整数倍）。他希望在不超过 $n$ 元的前提下，使每件物品的价格与重要度的乘积的总和最大。\n\n设第 $j$ 件物品的价格为 $v_j$，重要度为 $w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,\\dots,j_k$，则所求的总和为：\n\n$$v_{j_1} \\times w_{j_1}+v_{j_2} \\times w_{j_2}+ \\dots +v_{j_k} \\times w_{j_k}$$\n\n请你帮助金明设计一个满足要求的购物单。\n", "inputFormat": "第一行有两个整数，分别表示总钱数 $n$ 和希望购买的物品个数 $m$。\n\n第 $2$ 到第 $(m + 1)$ 行，每行三个整数，第 $(i + 1)$ 行的整数 $v_i$，$p_i$，$q_i$ 分别表示第 $i$ 件物品的价格、重要度以及它对应的的主件。如果 $q_i=0$，表示该物品本身是主件。\n", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 3.2 \\times 10^4$，$1 \\leq m \\leq 60$，$0 \\leq v_i \\leq 10^4$，$1 \\leq p_i \\leq 5$，$0 \\leq q_i \\leq m$，答案不超过 $2 \\times 10^5$。\n\nNOIP 2006 提高组 第二题", "locale": "zh-CN"}}}
{"pid": "P1065", "type": "P", "difficulty": 3, "samples": [["2 3\n1 1 2 3 3 2\n1 2 \n1 2 \n2 1\n3 2 \n2 5 \n2 4\n", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2006", "NOIP 提高组"], "title": "[NOIP 2006 提高组] 作业调度方案", "background": "", "description": "我们现在要利用 $m$ 台机器加工 $n$ 个工件，每个工件都有 $m$ 道工序，每道工序都在不同的指定的机器上完成。每个工件的每道工序都有指定的加工时间。\n\n每个工件的每个工序称为一个操作，我们用记号 `j-k` 表示一个操作，其中 $j$ 为 $1$ 到 $n$ 中的某个数字，为工件号；$k$ 为 $1$ 到 $m$ 中的某个数字，为工序号，例如 `2-4` 表示第 $2$ 个工件第 $4$ 道工序的这个操作。在本题中，我们还给定对于各操作的一个安排顺序。\n\n例如，当 $n=3,m=2$ 时，`1-1,1-2,2-1,3-1,3-2,2-2` 就是一个给定的安排顺序，即先安排第 $1$ 个工件的第 $1$ 个工序，再安排第 $1$ 个工件的第 $2$ 个工序，然后再安排第 $2$ 个工件的第 $1$ 个工序，等等。\n\n一方面，每个操作的安排都要满足以下的两个约束条件。\n\n1. 对同一个工件，每道工序必须在它前面的工序完成后才能开始；\n\n2. 同一时刻每一台机器至多只能加工一个工件。\n\n另一方面，在安排后面的操作时，不能改动前面已安排的操作的工作状态。\n\n由于同一工件都是按工序的顺序安排的，因此，只按原顺序给出工件号，仍可得到同样的安排顺序，于是，在输入数据中，我们将这个安排顺序简写为 `1 1 2 3 3 2`。\n\n还要注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。\n\n例如，取 $n=3,m=2$，已知数据如下（机器号/加工时间）：\n\n\n工件号 |工序 1 | 工序 2\n-|-|-\n$1$  |  $1/3$  |  $2/2$\n$2$  |  $1/2$  |  $2/5$\n$3$  |  $2/2$  |  $1/4$\n\n则对于安排顺序 `1 1 2 3 3 2`，下图中的两个实施方案都是正确的。但所需要的总时间分别是 $10$ 与 $12$。\n\n方案 1，用时 $10$：\n\n|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |\n| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` | `3-2` | `3-2` | `3-2` | `3-2` |  无   |\n| 机器 2 执行工序 | `3-1` | `3-1` |  无   | `1-2` | `1-2` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |\n\n方案 2，用时 $12$：\n\n|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12  |\n| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` |   无   |  无   | `3-2` | `3-2` | `3-2` | `3-2` |  无   |\n| 机器 2 执行工序 | 无 | 无 |  无   | `1-2` | `1-2` | `3-1` | `3-1` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |\n\n当一个操作插入到某台机器的某个空档时（机器上最后的尚未安排操作的部分也可以看作一个空档），可以靠前插入，也可以靠后或居中插入。为了使问题简单一些，我们约定：在保证约束条件 $(1.)(2.)$ 的条件下，尽量靠前插入。并且，我们还约定，如果有多个空档可以插入，就在保证约束条件 $(1.)(2.)$ 的条件下，插入到最前面的一个空档。于是，在这些约定下，上例中的方案一是正确的，而方案二是不正确的。\n\n显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的，请你计算出该方案完成全部任务所需的总时间。\n", "inputFormat": "第 $1$ 行为两个正整数 $m$, $n$，用一个空格隔开，\n其中 $m(<20)$ 表示机器数，$n(<20)$ 表示工件数。\n\n第 $2$ 行：$m \\times n$ 个用空格隔开的数，为给定的安排顺序。\n\n接下来的 $2n$ 行，每行都是用空格隔开的 $m$ 个正整数，每个数不超过 $20$。\n\n其中前 $n$ 行依次表示每个工件的每个工序所使用的机器号，第 $1$ 个数为第 $1$ 个工序的机器号，第 $2$ 个数为第 $2$ 个工序机器号，等等。\n\n后 $n$ 行依次表示每个工件的每个工序的加工时间。\n\n可以保证，以上各数据都是正确的，不必检验。\n", "outputFormat": "$1$ 个正整数，为最少的加工时间。\n", "hint": "NOIP 2006 提高组 第三题\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2006 Senior] Job Scheduling Plan", "background": null, "description": "We need to process $n$ jobs on $m$ machines. Each job has $m$ operations, and every operation must be completed on a specified different machine. Each operation of each job has a specified processing time.\n\nEvery operation of every job is called an action. We denote an action by `j-k`, where $j$ is a number from $1$ to $n$ indicating the job ID, and $k$ is a number from $1$ to $m$ indicating the operation index. For example, `2-4` denotes the action of the $4$-th operation of job $2$. In this problem, we are also given an arrangement order for all actions.\n\nFor example, when $n=3$, $m=2$, the sequence `1-1,1-2,2-1,3-1,3-2,2-2` is a given arrangement order, i.e., first arrange the $1$-st operation of job $1$, then the $2$-nd operation of job $1$, then the $1$-st operation of job $2$, and so on.\n\nOn one hand, arranging each action must satisfy the following two constraints.\n\n1. For the same job, each operation must start only after all its preceding operations have finished.\n\n2. At any time, each machine can process at most one job.\n\nOn the other hand, when arranging later actions, the working states of actions already arranged earlier cannot be changed.\n\nSince the operations of the same job are arranged in order, providing only the job IDs in the original order still yields the same arrangement order. Thus, in the input, this arrangement order is written in a shortened form as `1 1 2 3 3 2`.\n\nNote that the “arrangement order” only requires arranging each action in the given order. It is not necessarily the actual execution order on each machine. In actual execution, an action later in the list may finish earlier than one that appears earlier.\n\nFor example, take $n=3$, $m=2$, with the following data (machine ID/processing time):\n\n\nJob ID | Operation 1 | Operation 2\n-|-|-\n$1$  |  $1/3$  |  $2/2$\n$2$  |  $1/2$  |  $2/5$\n$3$  |  $2/2$  |  $1/4$\n\nThen for the arrangement order `1 1 2 3 3 2`, the two implementation plans below are both valid. However, the total times required are $10$ and $12$, respectively.\n\nPlan 1, time $10$:\n\n|       Time       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |\n| :--------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| Machine 1 action | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` | `3-2` | `3-2` | `3-2` | `3-2` | Idle  |\n| Machine 2 action | `3-1` | `3-1` |  Idle | `1-2` | `1-2` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |\n\nPlan 2, time $12$:\n\n|       Time       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12  |\n| :--------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| Machine 1 action | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` |  Idle |  Idle | `3-2` | `3-2` | `3-2` | `3-2` | Idle  |\n| Machine 2 action | Idle  | Idle  |  Idle | `1-2` | `1-2` | `3-1` | `3-1` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |\n\nWhen inserting an action into some idle interval (gap) on a machine (the final unarranged segment on a machine can also be regarded as an idle interval), it can be inserted at the front, back, or somewhere in the middle. To simplify the problem, we stipulate: under constraints (1) and (2), insert as early as possible. Moreover, if multiple idle intervals can accept the insertion, insert into the earliest one under constraints (1) and (2). Under these rules, Plan 1 above is correct, while Plan 2 is not.\n\nClearly, with these rules, for a given arrangement order, the implementation plan consistent with it is unique. Please compute the total time required by this plan to complete all tasks.", "inputFormat": "The first line contains two positive integers $m$, $n$, separated by a space, where $m$ ($< 20$) is the number of machines and $n$ ($< 20$) is the number of jobs.\n\nThe second line contains $m \\times n$ integers separated by spaces, which is the given arrangement order.\n\nThe next $2n$ lines each contain $m$ positive integers separated by spaces, each not exceeding $20$.\n\nThe first $n$ of these lines give, in order, the machine IDs used by each operation of each job. The first number is the machine ID for the $1$-st operation, the second number is the machine ID for the $2$-nd operation, and so on.\n\nThe last $n$ of these lines give, in order, the processing times of each operation of each job.\n\nYou may assume all the above data are correct, and no validation is required.", "outputFormat": "A single positive integer: the minimum total processing time (makespan).", "hint": "NOIP 2006 Senior, Problem 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2006 提高组] 作业调度方案", "background": "", "description": "我们现在要利用 $m$ 台机器加工 $n$ 个工件，每个工件都有 $m$ 道工序，每道工序都在不同的指定的机器上完成。每个工件的每道工序都有指定的加工时间。\n\n每个工件的每个工序称为一个操作，我们用记号 `j-k` 表示一个操作，其中 $j$ 为 $1$ 到 $n$ 中的某个数字，为工件号；$k$ 为 $1$ 到 $m$ 中的某个数字，为工序号，例如 `2-4` 表示第 $2$ 个工件第 $4$ 道工序的这个操作。在本题中，我们还给定对于各操作的一个安排顺序。\n\n例如，当 $n=3,m=2$ 时，`1-1,1-2,2-1,3-1,3-2,2-2` 就是一个给定的安排顺序，即先安排第 $1$ 个工件的第 $1$ 个工序，再安排第 $1$ 个工件的第 $2$ 个工序，然后再安排第 $2$ 个工件的第 $1$ 个工序，等等。\n\n一方面，每个操作的安排都要满足以下的两个约束条件。\n\n1. 对同一个工件，每道工序必须在它前面的工序完成后才能开始；\n\n2. 同一时刻每一台机器至多只能加工一个工件。\n\n另一方面，在安排后面的操作时，不能改动前面已安排的操作的工作状态。\n\n由于同一工件都是按工序的顺序安排的，因此，只按原顺序给出工件号，仍可得到同样的安排顺序，于是，在输入数据中，我们将这个安排顺序简写为 `1 1 2 3 3 2`。\n\n还要注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。\n\n例如，取 $n=3,m=2$，已知数据如下（机器号/加工时间）：\n\n\n工件号 |工序 1 | 工序 2\n-|-|-\n$1$  |  $1/3$  |  $2/2$\n$2$  |  $1/2$  |  $2/5$\n$3$  |  $2/2$  |  $1/4$\n\n则对于安排顺序 `1 1 2 3 3 2`，下图中的两个实施方案都是正确的。但所需要的总时间分别是 $10$ 与 $12$。\n\n方案 1，用时 $10$：\n\n|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |\n| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` | `3-2` | `3-2` | `3-2` | `3-2` |  无   |\n| 机器 2 执行工序 | `3-1` | `3-1` |  无   | `1-2` | `1-2` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |\n\n方案 2，用时 $12$：\n\n|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12  |\n| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` |   无   |  无   | `3-2` | `3-2` | `3-2` | `3-2` |  无   |\n| 机器 2 执行工序 | 无 | 无 |  无   | `1-2` | `1-2` | `3-1` | `3-1` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |\n\n当一个操作插入到某台机器的某个空档时（机器上最后的尚未安排操作的部分也可以看作一个空档），可以靠前插入，也可以靠后或居中插入。为了使问题简单一些，我们约定：在保证约束条件 $(1.)(2.)$ 的条件下，尽量靠前插入。并且，我们还约定，如果有多个空档可以插入，就在保证约束条件 $(1.)(2.)$ 的条件下，插入到最前面的一个空档。于是，在这些约定下，上例中的方案一是正确的，而方案二是不正确的。\n\n显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的，请你计算出该方案完成全部任务所需的总时间。\n", "inputFormat": "第 $1$ 行为两个正整数 $m$, $n$，用一个空格隔开，\n其中 $m(<20)$ 表示机器数，$n(<20)$ 表示工件数。\n\n第 $2$ 行：$m \\times n$ 个用空格隔开的数，为给定的安排顺序。\n\n接下来的 $2n$ 行，每行都是用空格隔开的 $m$ 个正整数，每个数不超过 $20$。\n\n其中前 $n$ 行依次表示每个工件的每个工序所使用的机器号，第 $1$ 个数为第 $1$ 个工序的机器号，第 $2$ 个数为第 $2$ 个工序机器号，等等。\n\n后 $n$ 行依次表示每个工件的每个工序的加工时间。\n\n可以保证，以上各数据都是正确的，不必检验。\n", "outputFormat": "$1$ 个正整数，为最少的加工时间。\n", "hint": "NOIP 2006 提高组 第三题\n", "locale": "zh-CN"}}}
{"pid": "P1066", "type": "P", "difficulty": 5, "samples": [["3 7", "36"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "高精度", "递推", "2006", "NOIP 提高组", "数位 DP", "进制", "组合数学"], "title": "[NOIP 2006 提高组] 2^k 进制数", "background": null, "description": "设 $r$ 是个 $2^k$ 进制数，并满足以下条件：\n\n- $r$ 至少是个 $2$ 位的 $2^k$ 进制数。\n\n- 作为 $2^k$ 进制数，除最后一位外，$r$ 的每一位严格小于它右边相邻的那一位。\n\n- 将 $r$ 转换为二进制数 $q$ 后，则 $q$ 的总位数不超过 $w$。\n\n在这里，正整数 $k,w$ 是事先给定的。\n\n问：满足上述条件的不同的 $r$ 共有多少个？\n\n我们再从另一角度作些解释：设 $S$ 是长度为 $w$ 的 $01$ 字符串（即字符串 $S$ 由 $w$ 个 $0$ 或 $1$ 组成），$S$ 对应于上述条件三中的 $q$。将 $S$ 从右起划分为若干个长度为 $k$ 的段，每段对应一位 $2^k$ 进制的数，如果 $S$ 至少可分成 $2$ 段，则 $S$ 所对应的二进制数又可以转换为上述的 $2^k$ 进制数 $r$。\n\n例：设 $k=3,w=7$。则 $r$ 是个八进制数（$2^3=8$）。由于 $w=7$，长度为 $7$ 的 $01$ 字符串按 $3$ 位一段分，可分为 $3$ 段（即 $1,3,3$，左边第一段只有一个二进制位），则满足条件的八进制数有：\n\n$2$ 位数：  \n高位为 $1$：$6$ 个（即 $12,13,14,15,16,17$）,   \n高位为 $2$：$5$ 个，  \n…，  \n高位为 $6$：$1$ 个（即 $67$）。  \n共 $6+5+…+1=21$ 个。\n\n$3$ 位数：  \n高位只能是 $1$，  \n第 $2$ 位为 $2$：$5$ 个（即 $123,124,125,126,127$），  \n第 $2$ 位为 $3$：$4$ 个，  \n…，    \n第 $2$ 位为 $6$：$1$ 个（即 $167$）。  \n共 $5+4+…+1=15$ 个。\n\n所以，满足要求的 $r$ 共有 $36$ 个。", "inputFormat": "一行两个正整数 $k,w$ 用一个空格隔开：", "outputFormat": "一行一个个正整数，为所求的计算结果。  \n即满足条件的不同的 $r$ 的个数（用十进制数表示），要求不得有前导零，各数字之间不得插入数字以外的其他字符（例如空格、换行符、逗号等）。\n\n（提示：作为结果的正整数可能很大，但不会超过 $200$ 位）", "hint": "【数据范围】  \n$1\\le k \\le 9$    \n$1\\le w \\le 3\\times 10^4$\n\nNOIP 2006 提高组 第四题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2006 Senior] $2^k$-ary Number", "background": null, "description": "Let $r$ be a base $2^k$ number that satisfies the following conditions.\n\n- $r$ has at least $2$ digits in base $2^k$.\n- As a base $2^k$ number, except for the last digit, each digit of $r$ is strictly less than the digit immediately to its right.\n- After converting $r$ to its binary representation $q$, the total number of bits of $q$ does not exceed $w$.\n\nHere, the positive integers $k, w$ are given in advance.\n\nQuestion: How many different $r$ satisfy the conditions above?\n\nWe further explain from another angle: Let $S$ be a length-$w$ $01$ string (i.e., $S$ consists of $w$ characters, each being $0$ or $1$), and $S$ corresponds to the $q$ mentioned in condition $3$. Partition $S$ from the right into blocks of length $k$, each block corresponding to one digit in base $2^k$. If $S$ can be partitioned into at least $2$ blocks, then the binary number represented by $S$ can be converted into the base $2^k$ number $r$ described above.\n\nExample: Let $k=3, w=7$. Then $r$ is an octal number ($2^3=8$). Since $w=7$, a length-$7$ $01$ string, when split into blocks of $3$ bits, can be divided into $3$ blocks (namely $1, 3, 3$; the leftmost block has only one binary bit). The octal numbers that satisfy the conditions are:\n\n$2$-digit numbers:  \nHigh digit is $1$: $6$ numbers (namely $12, 13, 14, 15, 16, 17$),  \nHigh digit is $2$: $5$ numbers,  \n...,  \nHigh digit is $6$: $1$ number (namely $67$).  \nIn total, $6+5+…+1=21$ numbers.\n\n$3$-digit numbers:  \nThe high digit can only be $1$,  \nSecond digit is $2$: $5$ numbers (namely $123, 124, 125, 126, 127$),  \nSecond digit is $3$: $4$ numbers,  \n...,  \nSecond digit is $6$: $1$ number (namely $167$).  \nIn total, $5+4+…+1=15$ numbers.\n\nTherefore, the total number of $r$ that satisfy the requirements is $36$.", "inputFormat": "One line containing two positive integers $k, w$ separated by a space.", "outputFormat": "Output one line with a single positive integer: the required result.  \nThat is, the number of different $r$ that satisfy the conditions (in decimal). There must be no leading zeros, and no characters other than digits may be inserted between digits (such as spaces, line breaks, commas, etc.).\n\n(Hint: The resulting positive integer may be large, but it will not exceed $200$ digits.)", "hint": "Constraints  \n$1\\le k \\le 9$  \n$1\\le w \\le 3\\times 10^4$\n\nNOIP 2006 Senior Problem 4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2006 提高组] 2^k 进制数", "background": null, "description": "设 $r$ 是个 $2^k$ 进制数，并满足以下条件：\n\n- $r$ 至少是个 $2$ 位的 $2^k$ 进制数。\n\n- 作为 $2^k$ 进制数，除最后一位外，$r$ 的每一位严格小于它右边相邻的那一位。\n\n- 将 $r$ 转换为二进制数 $q$ 后，则 $q$ 的总位数不超过 $w$。\n\n在这里，正整数 $k,w$ 是事先给定的。\n\n问：满足上述条件的不同的 $r$ 共有多少个？\n\n我们再从另一角度作些解释：设 $S$ 是长度为 $w$ 的 $01$ 字符串（即字符串 $S$ 由 $w$ 个 $0$ 或 $1$ 组成），$S$ 对应于上述条件三中的 $q$。将 $S$ 从右起划分为若干个长度为 $k$ 的段，每段对应一位 $2^k$ 进制的数，如果 $S$ 至少可分成 $2$ 段，则 $S$ 所对应的二进制数又可以转换为上述的 $2^k$ 进制数 $r$。\n\n例：设 $k=3,w=7$。则 $r$ 是个八进制数（$2^3=8$）。由于 $w=7$，长度为 $7$ 的 $01$ 字符串按 $3$ 位一段分，可分为 $3$ 段（即 $1,3,3$，左边第一段只有一个二进制位），则满足条件的八进制数有：\n\n$2$ 位数：  \n高位为 $1$：$6$ 个（即 $12,13,14,15,16,17$）,   \n高位为 $2$：$5$ 个，  \n…，  \n高位为 $6$：$1$ 个（即 $67$）。  \n共 $6+5+…+1=21$ 个。\n\n$3$ 位数：  \n高位只能是 $1$，  \n第 $2$ 位为 $2$：$5$ 个（即 $123,124,125,126,127$），  \n第 $2$ 位为 $3$：$4$ 个，  \n…，    \n第 $2$ 位为 $6$：$1$ 个（即 $167$）。  \n共 $5+4+…+1=15$ 个。\n\n所以，满足要求的 $r$ 共有 $36$ 个。", "inputFormat": "一行两个正整数 $k,w$ 用一个空格隔开：", "outputFormat": "一行一个个正整数，为所求的计算结果。  \n即满足条件的不同的 $r$ 的个数（用十进制数表示），要求不得有前导零，各数字之间不得插入数字以外的其他字符（例如空格、换行符、逗号等）。\n\n（提示：作为结果的正整数可能很大，但不会超过 $200$ 位）", "hint": "【数据范围】  \n$1\\le k \\le 9$    \n$1\\le w \\le 3\\times 10^4$\n\nNOIP 2006 提高组 第四题", "locale": "zh-CN"}}}
{"pid": "P1067", "type": "P", "difficulty": 2, "samples": [["5 \n100 -1 1 -3 0 10", "100x^5-x^4+x^3-3x^2+10"], ["3 \n-50 0 0 1 \n", "-50x^3+1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "字符串", "数学", "2009", "NOIP 普及组"], "title": "[NOIP 2009 普及组] 多项式输出", "background": null, "description": "一元 $n$ 次多项式可用如下的表达式表示：\n\n$$f(x)=a_nx^n+a_{n-1}x^{n-1}+\\cdots +a_1x+a_0,a_n\\ne 0$$\n\n其中，$a_ix^i$ 称为 $i$ 次项，$a_i$ 称为 $i$ 次项的系数。给出一个一元多项式各项的次数和系数，请按照如下规定的格式要求输出该多项式：\n\n1. 多项式中自变量为 $x$，从左到右按照次数递减顺序给出多项式。\n\n2. 多项式中只包含系数不为 $0$ 的项。\n\n3. 如果多项式 $n$ 次项系数为正，则多项式开头不出 `+` 号，如果多项式 $n$ 次项系数为负，则多项式以 `-` 号开头。\n\n4. 对于不是最高次的项，以 `+` 号或者 `-` 号连接此项与前一项，分别表示此项系数为正或者系数为负。紧跟一个正整数，表示此项系数的绝对值（如果一个高于 $0$ 次的项，其系数的绝对值为 $1$，则无需输出 $1$）。如果 $x$ 的指数大于 $1$，则接下来紧跟的指数部分的形式为“$x^b$”，其中 $b$ 为 $x$ 的指数；如果 $x$ 的指数为 $1$，则接下来紧跟的指数部分形式为 $x$；如果 $x$ 的指数为 $0$，则仅需输出系数即可。\n\n5. 多项式中，多项式的开头、结尾不含多余的空格。", "inputFormat": "输入共有 $2$ 行。\n\n第一行 $1$ 个整数，$n$，表示一元多项式的次数。\n\n第二行有 $n+1$ 个整数，其中第 $i$ 个整数表示第 $n-i+1$ 次项的系数，每两个整数之间用空格隔开。", "outputFormat": "输出共 $1$ 行，按题目所述格式输出多项式。", "hint": "NOIP 2009 普及组 第一题\n\n对于100%数据，$0 \\le n \\le 100$，$-100 \\le $系数$ \\le 100$\n\n---\n\n$\\text{upd 2022.8.1}$：新增加一组 Hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2009 Junior] Polynomial Output", "background": null, "description": "A univariate polynomial of degree $n$ can be written as:\n$$f(x)=a_nx^n+a_{n-1}x^{n-1}+\\cdots +a_1x+a_0,a_n\\ne 0$$\nHere, $a_ix^i$ is called the $i$-th degree term, and $a_i$ is its coefficient. Given the degree and coefficients of a univariate polynomial, output the polynomial in the following format:\n\n1. The indeterminate is $x$. List the terms from left to right in descending order of degree.\n2. Include only terms whose coefficients are nonzero.\n3. If the leading (degree-$n$) coefficient is positive, the polynomial must not start with a `+` sign; if it is negative, the polynomial must start with a `-` sign.\n4. For any non-leading term, connect it to the previous term with `+` or `-`, indicating a positive or negative coefficient, respectively. Immediately follow with the absolute value of the coefficient as a positive integer (for terms of degree greater than $0$, omit the $1$ if the coefficient’s absolute value is $1$). If the exponent of $x$ is greater than $1$, write it as “$x^b$”, where $b$ is the exponent; if the exponent is $1$, write it as $x$; if the exponent is $0$, output only the coefficient.\n5. There must be no extra spaces at the beginning or the end of the polynomial.", "inputFormat": "There are $2$ lines of input.\n\n- The first line contains one integer $n$, the degree of the polynomial.\n- The second line contains $n+1$ integers. The $i$-th integer is the coefficient of the term of degree $n-i+1$. Integers are separated by single spaces.", "outputFormat": "Output one line: the polynomial formatted as described above.", "hint": "NOIP 2009 Junior, Problem 1.\n\nConstraints: For 100% of the testdata, $0 \\le n \\le 100$, and $-100 \\le a_i \\le 100$.\n\n$\\text{upd 2022.8.1}$: A new set of hack testdata has been added.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2009 普及组] 多项式输出", "background": null, "description": "一元 $n$ 次多项式可用如下的表达式表示：\n\n$$f(x)=a_nx^n+a_{n-1}x^{n-1}+\\cdots +a_1x+a_0,a_n\\ne 0$$\n\n其中，$a_ix^i$ 称为 $i$ 次项，$a_i$ 称为 $i$ 次项的系数。给出一个一元多项式各项的次数和系数，请按照如下规定的格式要求输出该多项式：\n\n1. 多项式中自变量为 $x$，从左到右按照次数递减顺序给出多项式。\n\n2. 多项式中只包含系数不为 $0$ 的项。\n\n3. 如果多项式 $n$ 次项系数为正，则多项式开头不出 `+` 号，如果多项式 $n$ 次项系数为负，则多项式以 `-` 号开头。\n\n4. 对于不是最高次的项，以 `+` 号或者 `-` 号连接此项与前一项，分别表示此项系数为正或者系数为负。紧跟一个正整数，表示此项系数的绝对值（如果一个高于 $0$ 次的项，其系数的绝对值为 $1$，则无需输出 $1$）。如果 $x$ 的指数大于 $1$，则接下来紧跟的指数部分的形式为“$x^b$”，其中 $b$ 为 $x$ 的指数；如果 $x$ 的指数为 $1$，则接下来紧跟的指数部分形式为 $x$；如果 $x$ 的指数为 $0$，则仅需输出系数即可。\n\n5. 多项式中，多项式的开头、结尾不含多余的空格。", "inputFormat": "输入共有 $2$ 行。\n\n第一行 $1$ 个整数，$n$，表示一元多项式的次数。\n\n第二行有 $n+1$ 个整数，其中第 $i$ 个整数表示第 $n-i+1$ 次项的系数，每两个整数之间用空格隔开。", "outputFormat": "输出共 $1$ 行，按题目所述格式输出多项式。", "hint": "NOIP 2009 普及组 第一题\n\n对于100%数据，$0 \\le n \\le 100$，$-100 \\le $系数$ \\le 100$\n\n---\n\n$\\text{upd 2022.8.1}$：新增加一组 Hack 数据。", "locale": "zh-CN"}}}
{"pid": "P1068", "type": "P", "difficulty": 2, "samples": [["6 3 \n1000 90 \n3239 88 \n2390 95 \n7231 84 \n1005 95 \n1001 88", "88 5 \n1005 95 \n2390 95 \n1000 90 \n1001 88 \n3239 88 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2009", "NOIP 普及组", "排序"], "title": "[NOIP 2009 普及组] 分数线划定", "background": "", "description": "世博会志愿者的选拔工作正在 A 市如火如荼的进行。为了选拔最合适的人才，A 市对所有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根据计划录取人数的 $150\\%$ 划定，即如果计划录取 $m$ 名志愿者，则面试分数线为排名第 $m \\times 150\\%$（向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有选手。\n\n现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成绩。", "inputFormat": " \n第一行，两个整数 $n,m(5 \\leq n \\leq 5000,3 \\leq m \\leq n)$，中间用一个空格隔开，其中 $n$ 表示报名参加笔试的选手总数，$m$ 表示计划录取的志愿者人数。输入数据保证 $m \\times 150\\%$ 向下取整后小于等于 $n$。\n\n第二行到第 $n+1$ 行，每行包括两个整数，中间用一个空格隔开，分别是选手的报名号 $k(1000 \\leq k \\leq 9999)$和该选手的笔试成绩 $s(1 \\leq s \\leq 100)$。数据保证选手的报名号各不相同。\n", "outputFormat": "第一行，有 $2$ 个整数，用一个空格隔开，第一个整数表示面试分数线；第二个整数为进入面试的选手的实际人数。\n\n从第二行开始，每行包含 $2$ 个整数，中间用一个空格隔开，分别表示进入面试的选手的报名号和笔试成绩，按照笔试成绩从高到低输出，如果成绩相同，则按报名号由小到大的顺序输出。\n", "hint": "【样例说明】\n\n$m \\times 150\\% = 3 \\times150\\% = 4.5$，向下取整后为 $4$。保证 $4$ 个人进入面试的分数线为 $88$，但因为 $88$ 有重分，所以所有成绩大于等于 $88$ 的选手都可以进入面试，故最终有 $5$ 个人进入面试。\n\nNOIP 2009 普及组 第二题\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2009 Junior] Determining the Cutoff Score", "background": null, "description": "The selection of volunteers for the World Expo is in full swing in City A. To choose the most suitable candidates, City A held a written test for all applicants. Only those whose written scores reach the interview cutoff can enter the interview. The interview cutoff is set at $150\\%$ of the planned admission number. That is, if the plan admits $m$ volunteers, the cutoff score is the score of the contestant ranked at $m \\times 150\\%$ (rounded down), and all contestants whose written scores are not lower than the cutoff will enter the interview.\n\nPlease write a program to determine the interview cutoff score and output the registration IDs and written scores of all contestants who enter the interview.", "inputFormat": "- Line 1: Two integers $n, m$ ($5 \\leq n \\leq 5000, 3 \\leq m \\leq n$), separated by a space. Here $n$ is the total number of contestants who registered for the written test, and $m$ is the planned number of volunteers to admit. It is guaranteed that $m \\times 150\\%$, after rounding down, is less than or equal to $n$.\n- Lines $2$ to $n+1$: Each line contains two integers separated by a space: the contestant’s registration ID $k$ ($1000 \\leq k \\leq 9999$) and written score $s$ ($1 \\leq s \\leq 100$). It is guaranteed that all registration IDs are distinct.", "outputFormat": "- Line 1: Two integers separated by a space. The first integer is the interview cutoff score; the second integer is the actual number of contestants who enter the interview.\n- From line 2 onward: Each line contains two integers separated by a space, the registration ID and written score of a contestant who enters the interview. Output contestants in descending order of written score; for equal scores, sort by ascending registration ID.", "hint": "[Sample Explanation]\n\n$m \\times 150\\% = 3 \\times 150\\% = 4.5$, which is rounded down to $4$. The cutoff ensuring $4$ people enter the interview is $88$. Since there are ties at $88$, all contestants with scores greater than or equal to $88$ enter the interview, so there are $5$ contestants in total.\n\nNOIP 2009 Junior, Problem 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2009 普及组] 分数线划定", "background": "", "description": "世博会志愿者的选拔工作正在 A 市如火如荼的进行。为了选拔最合适的人才，A 市对所有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根据计划录取人数的 $150\\%$ 划定，即如果计划录取 $m$ 名志愿者，则面试分数线为排名第 $m \\times 150\\%$（向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有选手。\n\n现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成绩。", "inputFormat": " \n第一行，两个整数 $n,m(5 \\leq n \\leq 5000,3 \\leq m \\leq n)$，中间用一个空格隔开，其中 $n$ 表示报名参加笔试的选手总数，$m$ 表示计划录取的志愿者人数。输入数据保证 $m \\times 150\\%$ 向下取整后小于等于 $n$。\n\n第二行到第 $n+1$ 行，每行包括两个整数，中间用一个空格隔开，分别是选手的报名号 $k(1000 \\leq k \\leq 9999)$和该选手的笔试成绩 $s(1 \\leq s \\leq 100)$。数据保证选手的报名号各不相同。\n", "outputFormat": "第一行，有 $2$ 个整数，用一个空格隔开，第一个整数表示面试分数线；第二个整数为进入面试的选手的实际人数。\n\n从第二行开始，每行包含 $2$ 个整数，中间用一个空格隔开，分别表示进入面试的选手的报名号和笔试成绩，按照笔试成绩从高到低输出，如果成绩相同，则按报名号由小到大的顺序输出。\n", "hint": "【样例说明】\n\n$m \\times 150\\% = 3 \\times150\\% = 4.5$，向下取整后为 $4$。保证 $4$ 个人进入面试的分数线为 $88$，但因为 $88$ 有重分，所以所有成绩大于等于 $88$ 的选手都可以进入面试，故最终有 $5$ 个人进入面试。\n\nNOIP 2009 普及组 第二题\n", "locale": "zh-CN"}}}
{"pid": "P1069", "type": "P", "difficulty": 4, "samples": [["1 \n2 1 \n3\n", "-1\n"], ["2\n24 1\n30 12\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2009", "NOIP 普及组", "素数判断,质数,筛法"], "title": "[NOIP 2009 普及组] 细胞分裂", "background": "", "description": "Hanks 博士是 BT（Bio-Tech，生物技术）领域的知名专家。现在，他正在为一个细胞实验做准备工作：培养细胞样本。\n\nHanks 博士手里现在有 $N$ 种细胞，编号从 $1 \\sim N$，一个第 $i$ 种细胞经过 $1$ 秒钟可以分裂为 $S_i$ 个同种细胞（$S_i$ 为正整数）。现在他需要选取某种细胞的一个放进培养皿，让其自由分裂，进行培养。一段时间以后，再把培养皿中的所有细胞平均分入 $M$ 个试管，形成 $M$ 份样本，用于实验。Hanks 博士的试管数 $M$ 很大，普通的计算机的基本数据类型无法存储这样大的 $M$ 值，但万幸的是，$M$ 总可以表示为 $m_1$ 的 $m_2$ 次方，即 $M = m_1^{m_2}$，其中 $m_1,m_2$ 均为基本数据类型可以存储的正整数。\n\n注意，整个实验过程中不允许分割单个细胞，比如某个时刻若培养皿中有 $4$ 个细胞，Hanks 博士可以把它们分入 $2$ 个试管，每试管内 $2$ 个，然后开始实验。但如果培养皿中有 $5$ 个细胞，博士就无法将它们均分入 $2$ 个试管。此时，博士就只能等待一段时间，让细胞们继续分裂，使得其个数可以均分，或是干脆改换另一种细胞培养。\n\n为了能让实验尽早开始，Hanks 博士在选定一种细胞开始培养后，总是在得到的细胞“刚好可以平均分入 $M$ 个试管”时停止细胞培养并开始实验。现在博士希望知道，选择哪种细胞培养，可以使得实验的开始时间最早。\n", "inputFormat": "第一行，有一个正整数 $N$，代表细胞种数。\n\n第二行，有两个正整数 $m_1,m_2$，以一个空格隔开，即表示试管的总数 $M = m_1^{m_2}$。\n\n第三行有 $N$ 个正整数，第 $i$ 个数 $S_i$ 表示第 $i$ 种细胞经过 $1$ 秒钟可以分裂成同种细胞的个数。\n", "outputFormat": "一个整数，表示从开始培养细胞到实验能够开始所经过的最少时间（单位为秒）。\n\n如果无论 Hanks 博士选择哪种细胞都不能满足要求，则输出整数 $-1$。\n", "hint": "【输入输出样例 \\#1 说明】\n\n经过 $1$ 秒钟，细胞分裂成 $3$ 个，经过 $2$ 秒钟，细胞分裂成 $9$个，……，可以看出无论怎么分裂，细胞的个数都是奇数，因此永远不能分入 $2$ 个试管。\n\n【输入输出样例 \\#2 说明】\n\n第 $1$ 种细胞最早在 $3$ 秒后才能均分入 $24$ 个试管，而第 $2$ 种最早在 $2$ 秒后就可以均分（每试管 $144 / {24}^1 = 6$ 个）。故实验最早可以在 $2$ 秒后开始。\n\n【数据范围】\n\n对于 $50 \\%$ 的数据，有 $m_1^{m_2} \\le 30000$。\n\n对于所有的数据，有 $1 \\le N \\le 10000$，$1 \\le m_1 \\le 30000$，$1 \\le m_2 \\le 10000$，$1 \\le S_i \\le 2 \\times {10}^9$。\n\n\nNOIP 2009 普及组 第三题\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2009 Junior] Cell Division", "background": null, "description": "Dr. Hanks is a renowned expert in BT (Bio-Tech, 生物技术). He is preparing for a cell experiment: culturing cell samples.\n\nDr. Hanks currently has $N$ types of cells, numbered from $1 \\sim N$. A type $i$ cell can split into $S_i$ cells of the same type after $1$ second ($S_i$ is a positive integer). He needs to select one cell of some type, put it into a Petri dish, and let it divide freely for culturing. After some time, he will evenly distribute all cells in the dish into $M$ test tubes to form $M$ samples for the experiment. The number of test tubes $M$ is very large, so ordinary computer primitive data types cannot store it. Fortunately, $M$ can always be expressed as the $m_2$-th power of $m_1$, i.e., $M = m_1^{m_2}$, where $m_1, m_2$ are both positive integers storable in primitive data types.\n\nNote that splitting a single cell is not allowed during the entire experiment. For example, if at some moment there are $4$ cells in the dish, Dr. Hanks can distribute them into $2$ test tubes with $2$ cells per tube, and then start the experiment. But if there are $5$ cells, he cannot evenly divide them into $2$ test tubes. In that case, he must either wait for a while for further division so that the count becomes divisible, or switch to culturing another cell type.\n\nTo start the experiment as early as possible, once he has fixed a cell type to culture, he always stops culturing and starts the experiment at the first moment when the number of cells can be evenly divided into $M$ test tubes. Now he wants to know which cell type to culture so that the experiment can start at the earliest time.", "inputFormat": "- The first line contains a positive integer $N$, the number of cell types.\n- The second line contains two positive integers $m_1, m_2$ separated by a space, representing the total number of test tubes $M = m_1^{m_2}$.\n- The third line contains $N$ positive integers. The $i$-th number $S_i$ indicates that a type $i$ cell becomes $S_i$ cells of the same type after $1$ second.", "outputFormat": "Output a single integer: the minimum time in seconds from the start of culturing to the moment the experiment can begin.\n\nIf no choice of cell type can satisfy the requirement, output $-1$.", "hint": "Explanation for Sample Input/Output #1:\n\nAfter $1$ second, the cells split into $3$; after $2$ seconds, they split into $9$; … It can be seen that the number of cells is always odd, so they can never be evenly divided into $2$ test tubes.\n\nExplanation for Sample Input/Output #2:\n\nFor the first type of cell, the earliest time to be evenly divided into $24$ test tubes is after $3$ seconds, while for the second type it is already possible after $2$ seconds (each test tube gets $144 / {24}^1 = 6$ cells). Therefore, the earliest time to start the experiment is after $2$ seconds.\n\nConstraints:\n\n- For $50\\%$ of the testdata, $m_1^{m_2} \\le 30000$.\n- For all the testdata, $1 \\le N \\le 10000$, $1 \\le m_1 \\le 30000$, $1 \\le m_2 \\le 10000$, $1 \\le S_i \\le 2 \\times 10^9$.\n\nNOIP 2009 Junior, Problem 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2009 普及组] 细胞分裂", "background": "", "description": "Hanks 博士是 BT（Bio-Tech，生物技术）领域的知名专家。现在，他正在为一个细胞实验做准备工作：培养细胞样本。\n\nHanks 博士手里现在有 $N$ 种细胞，编号从 $1 \\sim N$，一个第 $i$ 种细胞经过 $1$ 秒钟可以分裂为 $S_i$ 个同种细胞（$S_i$ 为正整数）。现在他需要选取某种细胞的一个放进培养皿，让其自由分裂，进行培养。一段时间以后，再把培养皿中的所有细胞平均分入 $M$ 个试管，形成 $M$ 份样本，用于实验。Hanks 博士的试管数 $M$ 很大，普通的计算机的基本数据类型无法存储这样大的 $M$ 值，但万幸的是，$M$ 总可以表示为 $m_1$ 的 $m_2$ 次方，即 $M = m_1^{m_2}$，其中 $m_1,m_2$ 均为基本数据类型可以存储的正整数。\n\n注意，整个实验过程中不允许分割单个细胞，比如某个时刻若培养皿中有 $4$ 个细胞，Hanks 博士可以把它们分入 $2$ 个试管，每试管内 $2$ 个，然后开始实验。但如果培养皿中有 $5$ 个细胞，博士就无法将它们均分入 $2$ 个试管。此时，博士就只能等待一段时间，让细胞们继续分裂，使得其个数可以均分，或是干脆改换另一种细胞培养。\n\n为了能让实验尽早开始，Hanks 博士在选定一种细胞开始培养后，总是在得到的细胞“刚好可以平均分入 $M$ 个试管”时停止细胞培养并开始实验。现在博士希望知道，选择哪种细胞培养，可以使得实验的开始时间最早。\n", "inputFormat": "第一行，有一个正整数 $N$，代表细胞种数。\n\n第二行，有两个正整数 $m_1,m_2$，以一个空格隔开，即表示试管的总数 $M = m_1^{m_2}$。\n\n第三行有 $N$ 个正整数，第 $i$ 个数 $S_i$ 表示第 $i$ 种细胞经过 $1$ 秒钟可以分裂成同种细胞的个数。\n", "outputFormat": "一个整数，表示从开始培养细胞到实验能够开始所经过的最少时间（单位为秒）。\n\n如果无论 Hanks 博士选择哪种细胞都不能满足要求，则输出整数 $-1$。\n", "hint": "【输入输出样例 \\#1 说明】\n\n经过 $1$ 秒钟，细胞分裂成 $3$ 个，经过 $2$ 秒钟，细胞分裂成 $9$个，……，可以看出无论怎么分裂，细胞的个数都是奇数，因此永远不能分入 $2$ 个试管。\n\n【输入输出样例 \\#2 说明】\n\n第 $1$ 种细胞最早在 $3$ 秒后才能均分入 $24$ 个试管，而第 $2$ 种最早在 $2$ 秒后就可以均分（每试管 $144 / {24}^1 = 6$ 个）。故实验最早可以在 $2$ 秒后开始。\n\n【数据范围】\n\n对于 $50 \\%$ 的数据，有 $m_1^{m_2} \\le 30000$。\n\n对于所有的数据，有 $1 \\le N \\le 10000$，$1 \\le m_1 \\le 30000$，$1 \\le m_2 \\le 10000$，$1 \\le S_i \\le 2 \\times {10}^9$。\n\n\nNOIP 2009 普及组 第三题\n", "locale": "zh-CN"}}}
{"pid": "P1070", "type": "P", "difficulty": 5, "samples": [["2 3 2 \n1 2 3 \n2 3 4 \n1 2", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "NOIP 普及组"], "title": "[NOIP 2009 普及组] 道路游戏", "background": null, "description": "小新正在玩一个简单的电脑游戏。\n\n游戏中有一条环形马路，马路上有 $n$ 个机器人工厂，两个相邻机器人工厂之间由一小段马路连接。小新以某个机器人工厂为起点，按顺时针顺序依次将这 $n$ 个机器人工厂编号为 $1\\sim n$，因为马路是环形的，所以第 $n$ 个机器人工厂和第 $1$ 个机器人工厂是由一段马路连接在一起的。小新将连接机器人工厂的这 $n$ 段马路也编号为 $1\\sim n$，并规定第 $i$ 段马路连接第 $i$ 个机器人工厂和第 $i+1$ 个机器人工厂（$1\\le i\\le n-1$），第 $n$ 段马路连接第 $n$ 个机器人工厂和第 $1$ 个机器人工厂。\n\n游戏过程中，每个单位时间内，每段马路上都会存在一些金币（不同时间段互不干扰），金币的数量会随着时间发生变化，即不同单位时间内同一段马路上的金币数量可能是不同的。小新需要机器人的帮助才能收集到马路上的金币。所需的机器人必须在机器人工厂用一些金币来购买，机器人一旦被购买，便会沿着环形马路按顺时针方向一直行走，在每个单位时间内行走一次，即从当前所在的机器人工厂到达相邻的下一个机器人工厂，并将经过的马路上的所有金币收集给小新，例如，小新在 $i$（$1\\le i\\le n$）号机器人工厂购买了一个机器人，这个机器人会从 $i$ 号机器人工厂开始，顺时针在马路上行走，第一次行走会经过 $i$ 号马路，到达 $i+1$ 号机器人工厂（如果 $i=n$，机器人会到达第 $1$ 个机器人工厂），并将 $i$ 号马路上的所有金币收集给小新。游戏中，环形马路上不能同时存在 $2$ 个或者 $2$ 个以上的机器人，并且每个机器人最多能够在环形马路上行走 $p$ 次。小新购买机器人的同时，需要给这个机器人设定行走次数，行走次数可以为 $1\\sim p$ 之间的任意整数。当马路上的机器人行走完规定的次数之后会自动消失，小新必须立刻在任意一个机器人工厂中购买一个新的机器人，并给新的机器人设定新的行走次数。\n\n以下是游戏的一些补充说明：\n\n1. 游戏从小新第一次购买机器人开始计时。\n2. 购买机器人和设定机器人的行走次数是瞬间完成的，不需要花费时间。\n3. 购买机器人和机器人行走是两个独立的过程，机器人行走时不能购买机器人，购买完机器人并且设定机器人行走次数之后机器人才能行走。\n4. 在同一个机器人工厂购买机器人的花费是相同的，但是在不同机器人工厂购买机器人的花费不一定相同。\n5. 购买机器人花费的金币，在游戏结束时再从小新收集的金币中扣除，所以在游戏过程中小新不用担心因金币不足，无法购买机器人而导致游戏无法进行。也因为如此，游戏结束后，收集的金币数量可能为负。\n\n现在已知每段马路上每个单位时间内出现的金币数量和在每个机器人工厂购买机器人需要的花费，请你告诉小新，经过 $m$ 个单位时间后，扣除购买机器人的花费，小新最多能收集到多少金币。", "inputFormat": "第一行 $3$ 个正整数 $n,m,p$，意义如题目所述。\n\n接下来的 $n$ 行，每行有 $m$ 个正整数，每两个整数之间用一个空格隔开，其中第 $i$ 行描述了 $i$ 号马路上每个单位时间内出现的金币数量（$1\\le $ 金币数量 $\\le 100$），即第 $i$ 行的第 $j$（$1\\le j\\le m$）个数表示第 $j$ 个单位时间内 $i$ 号马路上出现的金币数量。\n\n最后一行，有 $n$ 个整数，每两个整数之间用一个空格隔开，其中第 $i$ 个数表示在 $i$ 号机器人工厂购买机器人需要花费的金币数量（$1\\le $ 金币数量 $\\le 100$）。", "outputFormat": "共一行，包含 $1$ 个整数，表示在 $m$ 个单位时间内，扣除购买机器人花费的金币之后，小新最多能收集到多少金币。", "hint": "对于 $40\\%$ 的数据，$2\\le n\\le 40$，$1\\le m\\le 40$。\n\n对于 $90\\%$ 的数据，$2\\le n\\le 200$，$1\\le m\\le 200$。\n\n对于 $100\\%$ 的数据，$2\\le n\\le 1000$，$1\\le m\\le 1000$，$1\\le p\\le m$。\n\nNOIP 2009 普及组 第四题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2009 Junior] Road Game", "background": null, "description": "Xiaoxin is playing a simple computer game.\n\nIn the game, there is a circular road with $n$ robot factories. Between every pair of adjacent robot factories, there is a short segment of road. Starting from some factory, Xiaoxin numbers the $n$ robot factories in clockwise order as $1 \\sim n$. Since the road is circular, factory $n$ and factory $1$ are connected by a segment of road. Xiaoxin also numbers the $n$ road segments as $1 \\sim n$, and stipulates that segment $i$ connects factory $i$ and factory $i+1$ ($1 \\le i \\le n-1$), while segment $n$ connects factory $n$ and factory $1$.\n\nDuring the game, in each time unit, every road segment will spawn some coins, and the number of coins changes over time; that is, the number of coins on the same road segment may differ between time units. Xiaoxin needs a robot’s help to collect the coins on the road. A robot must be purchased at a robot factory using some coins. Once purchased, the robot will walk along the circular road clockwise, moving once per time unit: in each time unit it moves from its current factory to the next factory and collects all coins on the road segment it traverses for Xiaoxin. For example, if Xiaoxin buys a robot at factory $i$ ($1 \\le i \\le n$), then starting from factory $i$, the robot walks clockwise. On its first move, it traverses segment $i$, reaches factory $i+1$ (if $i=n$, it reaches factory $1$), and collects all coins on segment $i$.\n\nAt no time may there be $2$ or more robots on the road simultaneously, and each robot can walk at most $p$ times. When buying a robot, Xiaoxin must also set its number of moves, which can be any integer from $1$ to $p$. After finishing its assigned number of moves, the robot disappears automatically, and Xiaoxin must immediately buy a new robot at any factory and set its number of moves.\n\nAdditional notes:\n\n1. Time starts when Xiaoxin buys a robot for the first time.\n2. Buying a robot and setting its number of moves are instantaneous and take no time.\n3. Buying a robot and a robot’s walking are independent processes. You cannot buy a robot while another robot is moving; a robot starts moving only after it has been bought and its number of moves has been set.\n4. The purchase cost at the same factory is always the same, but the costs at different factories may differ.\n5. All robot purchase costs are deducted from the coins collected at the end of the game. Therefore, during the game, Xiaoxin never fails to proceed due to insufficient coins. Because of this, the final collected coins may be negative.\n\nYou are given, for every road segment and every time unit, the number of coins that appear, as well as the purchase cost at each robot factory. Please tell Xiaoxin the maximum number of coins he can collect after $m$ time units, after subtracting all robot purchase costs.", "inputFormat": "The first line contains $3$ positive integers $n, m, p$, as described above.\n\nThe next $n$ lines each contain $m$ positive integers separated by single spaces. The $i$-th line describes the number of coins that appear on segment $i$ in each time unit ($1 \\le$ coin count $\\le 100$). That is, the $j$-th ($1 \\le j \\le m$) number on the $i$-th line is the number of coins that appear on segment $i$ in the $j$-th time unit.\n\nThe last line contains $n$ integers separated by single spaces. The $i$-th number is the number of coins required to buy a robot at factory $i$ ($1 \\le$ coin count $\\le 100$).", "outputFormat": "Output a single line with $1$ integer: the maximum number of coins Xiaoxin can collect in $m$ time units after subtracting all robot purchase costs.", "hint": "- For $40\\%$ of the testdata: $2 \\le n \\le 40$, $1 \\le m \\le 40$.\n- For $90\\%$ of the testdata: $2 \\le n \\le 200$, $1 \\le m \\le 200$.\n- For $100\\%$ of the testdata: $2 \\le n \\le 1000$, $1 \\le m \\le 1000$, $1 \\le p \\le m$.\n\nNOIP 2009 Junior Problem 4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2009 普及组] 道路游戏", "background": null, "description": "小新正在玩一个简单的电脑游戏。\n\n游戏中有一条环形马路，马路上有 $n$ 个机器人工厂，两个相邻机器人工厂之间由一小段马路连接。小新以某个机器人工厂为起点，按顺时针顺序依次将这 $n$ 个机器人工厂编号为 $1\\sim n$，因为马路是环形的，所以第 $n$ 个机器人工厂和第 $1$ 个机器人工厂是由一段马路连接在一起的。小新将连接机器人工厂的这 $n$ 段马路也编号为 $1\\sim n$，并规定第 $i$ 段马路连接第 $i$ 个机器人工厂和第 $i+1$ 个机器人工厂（$1\\le i\\le n-1$），第 $n$ 段马路连接第 $n$ 个机器人工厂和第 $1$ 个机器人工厂。\n\n游戏过程中，每个单位时间内，每段马路上都会存在一些金币（不同时间段互不干扰），金币的数量会随着时间发生变化，即不同单位时间内同一段马路上的金币数量可能是不同的。小新需要机器人的帮助才能收集到马路上的金币。所需的机器人必须在机器人工厂用一些金币来购买，机器人一旦被购买，便会沿着环形马路按顺时针方向一直行走，在每个单位时间内行走一次，即从当前所在的机器人工厂到达相邻的下一个机器人工厂，并将经过的马路上的所有金币收集给小新，例如，小新在 $i$（$1\\le i\\le n$）号机器人工厂购买了一个机器人，这个机器人会从 $i$ 号机器人工厂开始，顺时针在马路上行走，第一次行走会经过 $i$ 号马路，到达 $i+1$ 号机器人工厂（如果 $i=n$，机器人会到达第 $1$ 个机器人工厂），并将 $i$ 号马路上的所有金币收集给小新。游戏中，环形马路上不能同时存在 $2$ 个或者 $2$ 个以上的机器人，并且每个机器人最多能够在环形马路上行走 $p$ 次。小新购买机器人的同时，需要给这个机器人设定行走次数，行走次数可以为 $1\\sim p$ 之间的任意整数。当马路上的机器人行走完规定的次数之后会自动消失，小新必须立刻在任意一个机器人工厂中购买一个新的机器人，并给新的机器人设定新的行走次数。\n\n以下是游戏的一些补充说明：\n\n1. 游戏从小新第一次购买机器人开始计时。\n2. 购买机器人和设定机器人的行走次数是瞬间完成的，不需要花费时间。\n3. 购买机器人和机器人行走是两个独立的过程，机器人行走时不能购买机器人，购买完机器人并且设定机器人行走次数之后机器人才能行走。\n4. 在同一个机器人工厂购买机器人的花费是相同的，但是在不同机器人工厂购买机器人的花费不一定相同。\n5. 购买机器人花费的金币，在游戏结束时再从小新收集的金币中扣除，所以在游戏过程中小新不用担心因金币不足，无法购买机器人而导致游戏无法进行。也因为如此，游戏结束后，收集的金币数量可能为负。\n\n现在已知每段马路上每个单位时间内出现的金币数量和在每个机器人工厂购买机器人需要的花费，请你告诉小新，经过 $m$ 个单位时间后，扣除购买机器人的花费，小新最多能收集到多少金币。", "inputFormat": "第一行 $3$ 个正整数 $n,m,p$，意义如题目所述。\n\n接下来的 $n$ 行，每行有 $m$ 个正整数，每两个整数之间用一个空格隔开，其中第 $i$ 行描述了 $i$ 号马路上每个单位时间内出现的金币数量（$1\\le $ 金币数量 $\\le 100$），即第 $i$ 行的第 $j$（$1\\le j\\le m$）个数表示第 $j$ 个单位时间内 $i$ 号马路上出现的金币数量。\n\n最后一行，有 $n$ 个整数，每两个整数之间用一个空格隔开，其中第 $i$ 个数表示在 $i$ 号机器人工厂购买机器人需要花费的金币数量（$1\\le $ 金币数量 $\\le 100$）。", "outputFormat": "共一行，包含 $1$ 个整数，表示在 $m$ 个单位时间内，扣除购买机器人花费的金币之后，小新最多能收集到多少金币。", "hint": "对于 $40\\%$ 的数据，$2\\le n\\le 40$，$1\\le m\\le 40$。\n\n对于 $90\\%$ 的数据，$2\\le n\\le 200$，$1\\le m\\le 200$。\n\n对于 $100\\%$ 的数据，$2\\le n\\le 1000$，$1\\le m\\le 1000$，$1\\le p\\le m$。\n\nNOIP 2009 普及组 第四题", "locale": "zh-CN"}}}
{"pid": "P1071", "type": "P", "difficulty": 2, "samples": [["AA \nAB \nEOWIE\n\n", "Failed\n"], ["QWERTYUIOPLKJHGFDSAZXCVBN \nABCDEFGHIJKLMNOPQRSTUVWXY \nDSLIEWO\n", "Failed \n"], ["MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\nYIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\nFLSO ", "NOIP"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "2009", "NOIP 提高组"], "title": "[NOIP 2009 提高组] 潜伏者", "background": "", "description": "R 国和 S 国正陷入战火之中，双方都互派间谍，潜入对方内部，伺机行动。历尽艰险后，潜伏于 S 国的 R 国间谍小 C 终于摸清了 S 国军用密码的编码规则：\n\n1. S 国军方内部欲发送的原信息经过加密后在网络上发送，原信息的内容与加密后所得的内容均由大写字母 $\\texttt{A}\\sim\\texttt{Z}$ 构成（无空格等其他字符）；\n2. S 国对于每个字母规定了对应的密字。加密的过程就是将原信息中的所有字母替换为其对应的密字；\n3. 每个字母只对应一个唯一的密字，不同的字母对应不同的密字。密字可以和原字母相同。\n\n例如，若规定 $\\tt A$ 的密字为 $\\tt A$，$\\tt B$ 的密字为 $\\tt C$（其他字母及密字略），则原信息 $\\tt ABA$ 被加密为 $\\tt ACA$。\n\n现在，小 C 通过内线掌握了 S 国网络上发送的一条加密信息及其对应的原信息。小 C 希望能通过这条信息，破译 S 国的军用密码。小 C 的破译过程是这样的：扫描原信息，对于原信息中的字母 $x$（代表任一大写字母），找到其在加密信息中的对应大写字母 $y$，并认为在密码里 $y$ 是 $x$ 的密字。如此进行下去直到停止于如下的某个状态：\n\n1. 所有信息扫描完毕，$\\texttt{A}\\sim\\texttt{Z}$ 所有 $26$ 个字母在原信息中均出现过并获得了相应的密字；\n2. 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现；\n3. 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 S 国密码的编码规则）。\n\n例：\n\n如某条信息 $\\tt XYZ$ 被翻译为 $\\tt ABA$ 就违反了“不同字母对应不同密字”的规则。\n\n在小 C 忙得头昏脑涨之际，R 国司令部又发来电报，要求他翻译另外一条从 S 国刚刚截取到的加密信息。现在请你帮助小 C：通过内线掌握的信息，尝试破译密码。然后利用破译的密码，翻译电报中的加密信息。\n", "inputFormat": "共三行，每行为一个长度在 $1$ 到 $100$ 之间的字符串。\n\n第一行，为小 C 掌握的一条加密信息；\n\n第二行，为第一行的加密信息所对应的原信息；\n\n第三行，为 R 国司令部要求小 C 翻译的加密信息。\n\n输入数据保证所有字符串仅由大写字母 $\\texttt{A}\\sim\\texttt{Z}$ 构成，且第一行长度与第二行相等。\n", "outputFormat": "共一行。\n\n若破译密码停止时出现 $2,3$ 两种情况，请你输出 $\\tt Failed$；\n\n否则请输出利用密码翻译电报中加密信息后得到的原信息。\n", "hint": "【输入输出样例一说明】\n\n原信息中的字母 $\\tt A$ 和 $\\tt B$ 对应相同的密字，输出 $\\tt Failed$。\n\n【输入输出样例二说明】\n\n字母 $\\tt Z$ 在原信息中没有出现，输出 $\\tt Failed$。\n\nNOIP2009 提高组第一题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2009 Senior] The Infiltrator", "background": null, "description": "Countries R and S are at war and have sent spies into each other’s territory. After many hardships, Xiao C (pinyin) from country R, who is undercover in country S, finally figured out the encoding rules of country S’s military cipher:\n\n1. The plaintext to be sent by country S’s military is encrypted and then sent over the network. Both the plaintext and the ciphertext consist only of uppercase letters $\\texttt{A}\\sim\\texttt{Z}$ (no spaces or other characters).\n2. For each letter, country S specifies a corresponding cipher letter. Encryption replaces every letter in the plaintext with its corresponding cipher letter.\n3. Each letter corresponds to exactly one unique cipher letter, and different letters correspond to different cipher letters. A letter may map to itself.\n\nFor example, if the cipher letter for $\\tt A$ is $\\tt A$, and for $\\tt B$ is $\\tt C$ (others omitted), then the plaintext $\\tt ABA$ is encrypted as $\\tt ACA$.\n\nNow Xiao C has, via an inside source, one encrypted message together with its corresponding plaintext. He wants to break the cipher based on this information. His process is: scan the plaintext; for a plaintext letter $x$ (any uppercase letter), find the corresponding letter $y$ at the same position in the ciphertext, and conclude that in the cipher, $y$ is the cipher letter for $x$. Continue until one of the following states occurs:\n\n1. All information has been scanned, and all $26$ letters $\\texttt{A}\\sim\\texttt{Z}$ have appeared in the plaintext and obtained their corresponding cipher letters.\n2. All information has been scanned, but there exists at least one letter that does not appear in the plaintext.\n3. During scanning, an obvious contradiction or error is found (violating the encoding rules of country S’s cipher).\n\nExample:\n\nIf some plaintext $\\tt XYZ$ is translated as $\\tt ABA$, it violates the rule “different letters correspond to different cipher letters.”\n\nWhile Xiao C is overwhelmed, the headquarters of country R sends another telegram asking him to translate a newly intercepted encrypted message from country S. Please help Xiao C: deduce the cipher from the known pair, and then use the deduced cipher to translate the encrypted message in the telegram.", "inputFormat": "There are three lines. Each line is a string with length between $1$ and $100$.\n\n- The first line is an encrypted message known to Xiao C.\n- The second line is the plaintext corresponding to the first line.\n- The third line is the encrypted message that country R’s headquarters asks Xiao C to translate.\n\nThe testdata guarantees that all strings consist only of uppercase letters $\\texttt{A}\\sim\\texttt{Z}$, and that the lengths of the first and second lines are equal.", "outputFormat": "Output one line.\n\nIf the cipher deduction stops in cases $2$ or $3$, output $\\tt Failed$. Otherwise, output the plaintext obtained by translating the encrypted message using the deduced cipher.", "hint": "- Explanation for Sample 1: Letters $\\tt A$ and $\\tt B$ in the plaintext correspond to the same cipher letter, so output $\\tt Failed$.\n- Explanation for Sample 2: Letter $\\tt Z$ does not appear in the plaintext, so output $\\tt Failed$.\n\nNOIP 2009 Senior Problem 1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2009 提高组] 潜伏者", "background": "", "description": "R 国和 S 国正陷入战火之中，双方都互派间谍，潜入对方内部，伺机行动。历尽艰险后，潜伏于 S 国的 R 国间谍小 C 终于摸清了 S 国军用密码的编码规则：\n\n1. S 国军方内部欲发送的原信息经过加密后在网络上发送，原信息的内容与加密后所得的内容均由大写字母 $\\texttt{A}\\sim\\texttt{Z}$ 构成（无空格等其他字符）；\n2. S 国对于每个字母规定了对应的密字。加密的过程就是将原信息中的所有字母替换为其对应的密字；\n3. 每个字母只对应一个唯一的密字，不同的字母对应不同的密字。密字可以和原字母相同。\n\n例如，若规定 $\\tt A$ 的密字为 $\\tt A$，$\\tt B$ 的密字为 $\\tt C$（其他字母及密字略），则原信息 $\\tt ABA$ 被加密为 $\\tt ACA$。\n\n现在，小 C 通过内线掌握了 S 国网络上发送的一条加密信息及其对应的原信息。小 C 希望能通过这条信息，破译 S 国的军用密码。小 C 的破译过程是这样的：扫描原信息，对于原信息中的字母 $x$（代表任一大写字母），找到其在加密信息中的对应大写字母 $y$，并认为在密码里 $y$ 是 $x$ 的密字。如此进行下去直到停止于如下的某个状态：\n\n1. 所有信息扫描完毕，$\\texttt{A}\\sim\\texttt{Z}$ 所有 $26$ 个字母在原信息中均出现过并获得了相应的密字；\n2. 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现；\n3. 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 S 国密码的编码规则）。\n\n例：\n\n如某条信息 $\\tt XYZ$ 被翻译为 $\\tt ABA$ 就违反了“不同字母对应不同密字”的规则。\n\n在小 C 忙得头昏脑涨之际，R 国司令部又发来电报，要求他翻译另外一条从 S 国刚刚截取到的加密信息。现在请你帮助小 C：通过内线掌握的信息，尝试破译密码。然后利用破译的密码，翻译电报中的加密信息。\n", "inputFormat": "共三行，每行为一个长度在 $1$ 到 $100$ 之间的字符串。\n\n第一行，为小 C 掌握的一条加密信息；\n\n第二行，为第一行的加密信息所对应的原信息；\n\n第三行，为 R 国司令部要求小 C 翻译的加密信息。\n\n输入数据保证所有字符串仅由大写字母 $\\texttt{A}\\sim\\texttt{Z}$ 构成，且第一行长度与第二行相等。\n", "outputFormat": "共一行。\n\n若破译密码停止时出现 $2,3$ 两种情况，请你输出 $\\tt Failed$；\n\n否则请输出利用密码翻译电报中加密信息后得到的原信息。\n", "hint": "【输入输出样例一说明】\n\n原信息中的字母 $\\tt A$ 和 $\\tt B$ 对应相同的密字，输出 $\\tt Failed$。\n\n【输入输出样例二说明】\n\n字母 $\\tt Z$ 在原信息中没有出现，输出 $\\tt Failed$。\n\nNOIP2009 提高组第一题", "locale": "zh-CN"}}}
{"pid": "P1072", "type": "P", "difficulty": 2, "samples": [["2 \n41 1 96 288 \n95 1 37 1776 ", "6 \n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "2009", "NOIP 提高组", "枚举", "最大公约数 gcd"], "title": "[NOIP 2009 提高组] Hankson 的趣味题", "background": null, "description": "Hanks 博士是 BT（Bio-Tech，生物技术）领域的知名专家，他的儿子名叫 Hankson。现在，刚刚放学回家的 Hankson 正在思考一个有趣的问题。\n\n今天在课堂上，老师讲解了如何求两个正整数 $c_1$ 和 $c_2$ 的最大公约数和最小公倍数。现在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数 $a_0,a_1,b_0,b_1$，设某未知正整数 $x$ 满足：\n\n1. $x$ 和 $a_0$ 的最大公约数是 $a_1$；\n\n2. $x$ 和 $b_0$ 的最小公倍数是 $b_1$。\n\nHankson 的“逆问题”就是求出满足条件的正整数 $x$。但稍加思索之后，他发现这样的 $x$ 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的 $x$ 的个数。请你帮助他编程求解这个问题。", "inputFormat": "第一行为一个正整数 $n$，表示有 $n$ 组输入数据。接下来的 $n$ 行每行一组输入数据，为四个正整数 $a_0,a_1,b_0,b_1$，每两个整数之间用一个空格隔开。输入数据保证 $a_0$ 能被 $a_1$ 整除，$b_1$ 能被 $b_0$ 整除。", "outputFormat": "共 $n$ 行。每组输入数据的输出结果占一行，为一个整数。\n\n对于每组数据：若不存在这样的 $x$，请输出 $0$，若存在这样的 $x$，请输出满足条件的 $x$ 的个数；", "hint": "**【样例解释】**\n\n第一组输入数据，$x$ 可以是 $9,18,36,72,144,288$，共有 $6$ 个。\n\n第二组输入数据，$x$ 可以是 $48,1776$，共有 $2$ 个。\n\n**【数据范围】**\n\n- 对于 $50\\%$ 的数据，保证有 $1\\leq a_0,a_1,b_0,b_1 \\leq 10000$ 且 $n \\leq 100$。\n- 对于 $100\\%$ 的数据，保证有 $1 \\leq a_0,a_1,b_0,b_1 \\leq 2 \\times 10^9$ 且 $n≤2000$。\n\nNOIP 2009 提高组 第二题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2009 Senior] Hankson's Fun Problem", "background": null, "description": "Dr. Hanks is a renowned expert in BT (Bio-Tech, 生物技术). His son is named Hankson. Now, just home from school, Hankson is thinking about an interesting problem.\n\nToday in class, the teacher explained how to find the greatest common divisor and least common multiple of two positive integers $c_1$ and $c_2$. Now that Hankson believes he has mastered these topics, he starts considering an \"inverse problem\" to problems like \"finding a common divisor\" and \"finding a common multiple\". The problem is as follows: given positive integers $a_0, a_1, b_0, b_1$, let an unknown positive integer $x$ satisfy:\n\n1. The greatest common divisor of $x$ and $a_0$ is $a_1$.\n2. The least common multiple of $x$ and $b_0$ is $b_1$.\n\nHankson's \"inverse problem\" is to find all positive integers $x$ that satisfy the conditions. After a little thought, he realizes such $x$ are not necessarily unique and may even not exist. Therefore, he turns to counting how many $x$ satisfy the conditions. Please help him write a program to solve this problem.", "inputFormat": "The first line contains a positive integer $n$, indicating there are $n$ sets of input. Each of the next $n$ lines contains one set of input: four positive integers $a_0, a_1, b_0, b_1$, separated by single spaces. It is guaranteed that $a_0$ is divisible by $a_1$, and $b_1$ is divisible by $b_0$.", "outputFormat": "Output $n$ lines. For each set of input, output a single integer on one line.\n\nFor each set: if no such $x$ exists, print $0$; if such $x$ exist, print the number of $x$ that satisfy the conditions.", "hint": "- [Sample Explanation]\n  - For the first set, $x$ can be $9, 18, 36, 72, 144, 288$, for a total of $6$.\n  - For the second set, $x$ can be $48, 1776$, for a total of $2$.\n- [Constraints]\n  - For $50\\%$ of the testdata, it is guaranteed that $1 \\leq a_0, a_1, b_0, b_1 \\leq 10000$ and $n \\leq 100$.\n  - For $100\\%$ of the testdata, it is guaranteed that $1 \\leq a_0, a_1, b_0, b_1 \\leq 2 \\times 10^9$ and $n \\leq 2000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2009 提高组] Hankson 的趣味题", "background": null, "description": "Hanks 博士是 BT（Bio-Tech，生物技术）领域的知名专家，他的儿子名叫 Hankson。现在，刚刚放学回家的 Hankson 正在思考一个有趣的问题。\n\n今天在课堂上，老师讲解了如何求两个正整数 $c_1$ 和 $c_2$ 的最大公约数和最小公倍数。现在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数 $a_0,a_1,b_0,b_1$，设某未知正整数 $x$ 满足：\n\n1. $x$ 和 $a_0$ 的最大公约数是 $a_1$；\n\n2. $x$ 和 $b_0$ 的最小公倍数是 $b_1$。\n\nHankson 的“逆问题”就是求出满足条件的正整数 $x$。但稍加思索之后，他发现这样的 $x$ 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的 $x$ 的个数。请你帮助他编程求解这个问题。", "inputFormat": "第一行为一个正整数 $n$，表示有 $n$ 组输入数据。接下来的 $n$ 行每行一组输入数据，为四个正整数 $a_0,a_1,b_0,b_1$，每两个整数之间用一个空格隔开。输入数据保证 $a_0$ 能被 $a_1$ 整除，$b_1$ 能被 $b_0$ 整除。", "outputFormat": "共 $n$ 行。每组输入数据的输出结果占一行，为一个整数。\n\n对于每组数据：若不存在这样的 $x$，请输出 $0$，若存在这样的 $x$，请输出满足条件的 $x$ 的个数；", "hint": "**【样例解释】**\n\n第一组输入数据，$x$ 可以是 $9,18,36,72,144,288$，共有 $6$ 个。\n\n第二组输入数据，$x$ 可以是 $48,1776$，共有 $2$ 个。\n\n**【数据范围】**\n\n- 对于 $50\\%$ 的数据，保证有 $1\\leq a_0,a_1,b_0,b_1 \\leq 10000$ 且 $n \\leq 100$。\n- 对于 $100\\%$ 的数据，保证有 $1 \\leq a_0,a_1,b_0,b_1 \\leq 2 \\times 10^9$ 且 $n≤2000$。\n\nNOIP 2009 提高组 第二题", "locale": "zh-CN"}}}
{"pid": "P1073", "type": "P", "difficulty": 5, "samples": [["5 5 \n4 3 5 6 1 \n1 2 1 \n1 4 1 \n2 3 2 \n3 5 1 \n4 5 2 ", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "搜索", "图论", "2009", "NOIP 提高组", "最短路", "强连通分量", "Tarjan"], "title": "[NOIP 2009 提高组] 最优贸易", "background": "本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。", "description": "C 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。\n\nC 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。\n\n商人阿龙来到 C 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 C 国 $n$ 个城市的标号从 $1\\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 C 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。\n\n假设 C 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)\n\n假设 $1\\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。\n\n阿龙可以选择如下一条线路：$1\\to2\\to3\\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。\n\n阿龙也可以选择如下一条线路：$1\\to4\\to5\\to4\\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。\n\n现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。", "inputFormat": "第一行包含 $2$ 个正整数 $n$ 和 $m$，中间用一个空格隔开，分别表示城市的数目和道路的数目。\n\n第二行 $n$ 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 $n$ 个城市的商品价格。\n\n接下来 $m$ 行，每行有 $3$ 个正整数 $x,y,z$，每两个整数之间用一个空格隔开。如果 $z=1$，表示这条道路是城市 $x$ 到城市 $y$ 的单向道路；如果 $z=2$，表示这条道路为城市 $x$ 和城市 $y$ 之间的双向道路。", "outputFormat": "一个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出 $0$。", "hint": "【数据范围】\n\n输入数据保证 $1$ 号城市可以到达 $n$ 号城市。\n\n对于 $10\\%$ 的数据，$1\\leq n\\leq 6$。\n\n对于 $30\\%$ 的数据，$1\\leq n\\leq 100$。\n\n对于 $50\\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 100000$，$1\\leq m\\leq 500000$，$1\\leq  x,y\\leq  n$，$1\\leq  z\\leq  2$，$1\\leq $ 各城市的编号 $\\leq  n$。\n\n水晶球价格 $\\leq 100$。\n\nNOIP 2009 提高组 第三题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2009 Senior] Optimal Trade", "background": null, "description": "Country $C$ has $n$ major cities and $m$ roads, each connecting a pair of these $n$ cities. Between any two cities, there is at most one direct road. Among these $m$ roads, some are one-way and some are two-way. A two-way road is still counted as $1$ road.\n\nBecause country $C$ is vast and resources vary by region, the price of the same commodity may differ between cities. However, the buy price and the sell price of the same commodity are always identical within the same city.\n\nA merchant, A-Long, is traveling in country $C$. After learning that the price of the same commodity may differ between cities, he decides to earn some travel money from price differences while touring. The cities in country $C$ are labeled from $1$ to $n$. A-Long will start from city $1$ and eventually end his trip in city $n$. During the trip, he may pass through any city multiple times, and he is not required to visit all $n$ cities. He will earn travel money in this way: he chooses a city he passes to buy his favorite commodity, a crystal ball, and later sells it in another city he passes, using the price difference as his travel funds. Since A-Long mainly came to travel, he will perform this trade at most once. If there is no profitable opportunity, he can choose not to trade.\n\nSuppose there are $5$ major cities in country $C$, with the city indices and road connections shown below. A single arrow indicates a one-way road, and a double arrow indicates a two-way road.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)\n\nAssume the crystal ball prices in cities $1 \\sim n$ are $4, 3, 5, 6, 1$.\n\nA-Long can choose the route $1 \\to 2 \\to 3 \\to 5$, buy a crystal ball in city $2$ at price $3$, and sell it in city $3$ at price $5$, earning $2$.\n\nA-Long can also choose the route $1 \\to 4 \\to 5 \\to 4 \\to 5$, buy a crystal ball the first time he reaches city $5$ at price $1$, and sell it the second time he reaches city $4$ at price $6$, earning $5$.\n\nGiven the crystal ball prices of $n$ cities and the information of $m$ roads (the indices of the two cities connected by each road and whether the road is one-way or two-way), please tell A-Long the maximum travel money he can earn.", "inputFormat": "The first line contains $2$ positive integers $n$ and $m$, separated by a space, representing the number of cities and the number of roads.\n\nThe second line contains $n$ positive integers, separated by spaces, in index order, representing the commodity prices of the $n$ cities.\n\nThe following $m$ lines each contain $3$ positive integers $x, y, z$, separated by spaces. If $z = 1$, the road is a one-way road from city $x$ to city $y$; if $z = 2$, the road is a two-way road between cities $x$ and $y$.", "outputFormat": "Output a single integer, the maximum travel money that can be earned. If no trade is performed, output $0$.", "hint": "Constraints\n\n- It is guaranteed that city $1$ can reach city $n$.\n- For $10\\%$ of the testdata, $1 \\le n \\le 6$.\n- For $30\\%$ of the testdata, $1 \\le n \\le 100$.\n- For $50\\%$ of the testdata, there is no tour route that starts from a city and returns to the same city.\n- For $100\\%$ of the testdata: $1 \\le n \\le 100000$, $1 \\le m \\le 500000$, $1 \\le x, y \\le n$, $1 \\le z \\le 2$, and city prices $\\le 100$.\n\nNOIP 2009 Senior, Problem 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2009 提高组] 最优贸易", "background": "本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。", "description": "C 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。\n\nC 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。\n\n商人阿龙来到 C 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 C 国 $n$ 个城市的标号从 $1\\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 C 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。\n\n假设 C 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)\n\n假设 $1\\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。\n\n阿龙可以选择如下一条线路：$1\\to2\\to3\\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。\n\n阿龙也可以选择如下一条线路：$1\\to4\\to5\\to4\\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。\n\n现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。", "inputFormat": "第一行包含 $2$ 个正整数 $n$ 和 $m$，中间用一个空格隔开，分别表示城市的数目和道路的数目。\n\n第二行 $n$ 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 $n$ 个城市的商品价格。\n\n接下来 $m$ 行，每行有 $3$ 个正整数 $x,y,z$，每两个整数之间用一个空格隔开。如果 $z=1$，表示这条道路是城市 $x$ 到城市 $y$ 的单向道路；如果 $z=2$，表示这条道路为城市 $x$ 和城市 $y$ 之间的双向道路。", "outputFormat": "一个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出 $0$。", "hint": "【数据范围】\n\n输入数据保证 $1$ 号城市可以到达 $n$ 号城市。\n\n对于 $10\\%$ 的数据，$1\\leq n\\leq 6$。\n\n对于 $30\\%$ 的数据，$1\\leq n\\leq 100$。\n\n对于 $50\\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 100000$，$1\\leq m\\leq 500000$，$1\\leq  x,y\\leq  n$，$1\\leq  z\\leq  2$，$1\\leq $ 各城市的编号 $\\leq  n$。\n\n水晶球价格 $\\leq 100$。\n\nNOIP 2009 提高组 第三题", "locale": "zh-CN"}}}
{"pid": "P1074", "type": "P", "difficulty": 5, "samples": [["7 0 0 9 0 0 0 0 1 \n1 0 0 0 0 5 9 0 0 \n0 0 0 2 0 0 0 8 0 \n0 0 5 0 2 0 0 0 3 \n0 0 0 0 0 0 6 4 8 \n4 1 3 0 0 0 0 0 0 \n0 0 7 0 0 2 0 9 0 \n2 0 1 0 6 0 8 0 4 \n0 8 0 5 0 4 0 1 2\n", "2829"], ["0 0 0 7 0 2 4 5 3 \n9 0 0 0 0 8 0 0 0 \n7 4 0 0 0 5 0 1 0 \n1 9 5 0 8 0 0 0 0 \n0 7 0 0 0 0 0 2 5 \n0 3 0 5 7 9 1 0 8 \n0 0 0 6 0 1 0 0 0 \n0 6 0 9 0 0 0 0 1 \n0 0 0 0 0 0 0 0 6", "2852"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2009", "NOIP 提高组", "剪枝", "Dancing Links", "位运算"], "title": "[NOIP 2009 提高组] 靶形数独", "background": "**此为远古题，不保证存在可以通过任意符合要求的输入数据的程序**。", "description": "小城和小华都是热爱数学的好学生，最近，他们不约而同地迷上了数独游戏，好胜的他们想用数独来一比高低。但普通的数独对他们来说都过于简单了，于是他们向 Z 博士请教，Z 博士拿出了他最近发明的“靶形数独”，作为这两个孩子比试的题目。\n\n靶形数独的方格同普通数独一样，在 $9$ 格宽且 $9$ 格高的大九宫格中有 $9$ 个 $3$ 格宽且 $3$ 格高的小九宫格（用粗黑色线隔开的）。在这个大九宫格中，有一些数字是已知的，根据这些数字，利用逻辑推理，在其他的空格上填入 $1$ 到 $9$ 的数字。每个数字在每个小九宫格内不能重复出现，每个数字在每行、每列也不能重复出现。但靶形数独有一点和普通数独不同，即每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高。（如图）\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dhvuc32i.png)\n\n上图具体的分值分布是：最里面一格（黄色区域）为 $10$ 分，黄色区域外面的一圈（红色区域）每个格子为 $9$ 分，再外面一圈（蓝色区域）每个格子为 $8$ 分，蓝色区域外面一圈（棕色区域）每个格子为 $7$ 分，最外面一圈（白色区域）每个格子为 $6$ 分，如上图所示。比赛的要求是：每个人必须完成一个给定的数独（每个给定数独可能有不同的填法），而且要争取更高的总分数。而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和\n\n总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。如图，在以下的这个已经填完数字的靶形数独游戏中，总分数为 $2829$。游戏规定，将以总分数的高低决出胜负。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yx82mmnc.png)\n\n由于求胜心切，小城找到了善于编程的你，让你帮他求出，对于给定的靶形数独，能够得到的最高分数。\n", "inputFormat": "一共 $9$ 行。每行 $9$ 个整数（每个数都在 $0 \\sim 9$ 的范围内），表示一个尚未填满的数独方格，未填的空格用“$0$”表示。每两个数字之间用一个空格隔开。\n", "outputFormat": "输出共 $1$ 行。输出可以得到的靶形数独的最高分数。如果这个数独无解，则输出整数 $-1$。\n", "hint": "#### 数据规模与约定\n\n- 对于 $40\\%$ 的数据，数独中非 $0$ 数的个数不少于 $30$；\n- 对于 $80\\%$ 的数据，数独中非 $0$ 数的个数不少于 $26$；\n- 对于 $100\\%$ 的数据，数独中非 $0$ 数的个数不少于 $24$。\n\nNOIP 2009 提高组 第三题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2009 Senior] Target Sudoku", "background": null, "description": "Xiaocheng and Xiaohua are both good students who love mathematics. Recently, they have both become fascinated with Sudoku. Competitive as they are, they want to use Sudoku to compete. However, ordinary Sudoku is too easy for them, so they consulted Dr. Z, who brought out his recently invented “Target Sudoku” as their challenge.\n\nThe grid of Target Sudoku is the same as ordinary Sudoku: in a $9 \\times 9$ large grid there are $9$ small $3 \\times 3$ subgrids (separated by bold black lines). In this large grid, some numbers are already given. Based on these numbers, use logical reasoning to fill the empty cells with digits $1$ to $9$. Each digit cannot repeat within any small $3 \\times 3$ subgrid, and cannot repeat within any row or column. Target Sudoku differs from ordinary Sudoku in one respect: each cell has a score, and like a target, the closer it is to the center, the higher the score (see figure).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dhvuc32i.png)\n\nThe specific score distribution is: the innermost single cell (yellow region) is worth $10$ points; the ring outside the yellow region (red region) is $9$ points per cell; the next ring (blue region) is $8$ points per cell; the ring outside the blue region (brown region) is $7$ points per cell; and the outermost ring (white region) is $6$ points per cell, as shown above. The task is: each person must complete a given Sudoku (each given Sudoku may have multiple valid completions), and strive for the highest total score. The total score is the sum, over all cells, of the product of the cell’s score and the digit filled in that cell when the Sudoku is completed.\n\nAs shown below, in this completed Target Sudoku, the total score is $2829$. The game rules determine the winner by comparing total scores.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yx82mmnc.png)\n\nEager to win, Xiaocheng turns to you, a skilled programmer, to compute the highest possible total score for a given Target Sudoku.", "inputFormat": "There are $9$ lines in total. Each line contains $9$ integers (each between $0$ and $9$ inclusive), representing a partially filled Sudoku grid. Unfilled cells are represented by $0$. Each pair of integers is separated by a single space.", "outputFormat": "Output a single line: the maximum total score achievable for the given Target Sudoku. If the Sudoku has no solution, output $-1$.", "hint": "- Constraints:\n  - For $40\\%$ of the testdata, the number of non-zero entries in the Sudoku is at least $30$.\n  - For $80\\%$ of the testdata, the number of non-zero entries in the Sudoku is at least $26$.\n  - For $100\\%$ of the testdata, the number of non-zero entries in the Sudoku is at least $24$.\n\nNOIP 2009 Senior, Problem 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2009 提高组] 靶形数独", "background": "**此为远古题，不保证存在可以通过任意符合要求的输入数据的程序**。", "description": "小城和小华都是热爱数学的好学生，最近，他们不约而同地迷上了数独游戏，好胜的他们想用数独来一比高低。但普通的数独对他们来说都过于简单了，于是他们向 Z 博士请教，Z 博士拿出了他最近发明的“靶形数独”，作为这两个孩子比试的题目。\n\n靶形数独的方格同普通数独一样，在 $9$ 格宽且 $9$ 格高的大九宫格中有 $9$ 个 $3$ 格宽且 $3$ 格高的小九宫格（用粗黑色线隔开的）。在这个大九宫格中，有一些数字是已知的，根据这些数字，利用逻辑推理，在其他的空格上填入 $1$ 到 $9$ 的数字。每个数字在每个小九宫格内不能重复出现，每个数字在每行、每列也不能重复出现。但靶形数独有一点和普通数独不同，即每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高。（如图）\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dhvuc32i.png)\n\n上图具体的分值分布是：最里面一格（黄色区域）为 $10$ 分，黄色区域外面的一圈（红色区域）每个格子为 $9$ 分，再外面一圈（蓝色区域）每个格子为 $8$ 分，蓝色区域外面一圈（棕色区域）每个格子为 $7$ 分，最外面一圈（白色区域）每个格子为 $6$ 分，如上图所示。比赛的要求是：每个人必须完成一个给定的数独（每个给定数独可能有不同的填法），而且要争取更高的总分数。而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和\n\n总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。如图，在以下的这个已经填完数字的靶形数独游戏中，总分数为 $2829$。游戏规定，将以总分数的高低决出胜负。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yx82mmnc.png)\n\n由于求胜心切，小城找到了善于编程的你，让你帮他求出，对于给定的靶形数独，能够得到的最高分数。\n", "inputFormat": "一共 $9$ 行。每行 $9$ 个整数（每个数都在 $0 \\sim 9$ 的范围内），表示一个尚未填满的数独方格，未填的空格用“$0$”表示。每两个数字之间用一个空格隔开。\n", "outputFormat": "输出共 $1$ 行。输出可以得到的靶形数独的最高分数。如果这个数独无解，则输出整数 $-1$。\n", "hint": "#### 数据规模与约定\n\n- 对于 $40\\%$ 的数据，数独中非 $0$ 数的个数不少于 $30$；\n- 对于 $80\\%$ 的数据，数独中非 $0$ 数的个数不少于 $26$；\n- 对于 $100\\%$ 的数据，数独中非 $0$ 数的个数不少于 $24$。\n\nNOIP 2009 提高组 第三题", "locale": "zh-CN"}}}
{"pid": "P1075", "type": "P", "difficulty": 2, "samples": [["21", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "2012", "NOIP 普及组", "素数判断,质数,筛法"], "title": "[NOIP 2012 普及组] 质因数分解", "background": "", "description": "已知正整数 $n$ 是两个不同的质数的乘积，试求出两者中较大的那个质数。\n", "inputFormat": "输入一个正整数 $n$。\n", "outputFormat": "输出一个正整数 $p$，即较大的那个质数。\n", "hint": "$1 \\le n\\le 2\\times 10^9$\n\nNOIP 2012 普及组 第一题\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2012 Junior] Prime Factorization", "background": null, "description": "Given a positive integer $n$ that is the product of two distinct primes, find the larger prime.", "inputFormat": "Input a positive integer $n$.", "outputFormat": "Output a positive integer $p$, the larger prime.", "hint": "Constraints: $1 \\le n \\le 2 \\times 10^9$.\n\nNOIP 2012 Junior — Problem 1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2012 普及组] 质因数分解", "background": "", "description": "已知正整数 $n$ 是两个不同的质数的乘积，试求出两者中较大的那个质数。\n", "inputFormat": "输入一个正整数 $n$。\n", "outputFormat": "输出一个正整数 $p$，即较大的那个质数。\n", "hint": "$1 \\le n\\le 2\\times 10^9$\n\nNOIP 2012 普及组 第一题\n", "locale": "zh-CN"}}}
{"pid": "P1076", "type": "P", "difficulty": 3, "samples": [["2 3\n1 2\n0 3\n1 4\n0 1\n1 5\n1 2\n1\n", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2012", "NOIP 普及组"], "title": "[NOIP 2012 普及组] 寻宝", "background": null, "description": "传说很遥远的藏宝楼顶层藏着诱人的宝藏。小明历尽千辛万苦终于找到传说中的这个藏宝楼，藏宝楼的门口竖着一个木板，上面写有几个大字：寻宝说明书。说明书的内容如下：\n\n藏宝楼共有 $N+1$ 层，最上面一层是顶层，顶层有一个房间里面藏着宝藏。除了顶层外，藏宝楼另有 $N$ 层，每层 $M$ 个房间，这 $M$ 个房间围成一圈并按逆时针方向依次编号为 $0,\\cdots,M-1$。其中一些房间有通往上一层的楼梯，每层楼的楼梯设计可能不同。每个房间里有一个指示牌，指示牌上有一个数字 $x$，表示从这个房间开始按逆时针方向选择第 $x$ 个有楼梯的房间（假定该房间的编号为 $k$），从该房间上楼，上楼后到达上一层的 $k$ 号房间。比如当前房间的指示牌上写着 $2$，则按逆时针方向开始尝试，找到第 $2$ 个有楼梯的房间，从该房间上楼。如果当前房间本身就有楼梯通向上层，该房间作为第一个有楼梯的房间。\n\n寻宝说明书的最后用红色大号字体写着：“寻宝须知：帮助你找到每层上楼房间的指示牌上的数字（即每层第一个进入的房间内指示牌上的数字）总和为打开宝箱的密钥”。\n\n请帮助小明算出这个打开宝箱的密钥。", "inputFormat": "第一行有两个整数 $N$ 和 $M$，之间用一个空格隔开。$N$ 表示除了顶层外藏宝楼共 $N$ 层楼，$M$ 表示除顶层外每层楼有 $M$ 个房间。\n\n接下来 $N \\times M$ 行，每行两个整数，之间用一个空格隔开，每行描述一个房间内的情况，其中第 $(i-1) \\times M+j$ 行表示第 $i$ 层 $j-1$ 号房间的情况（$i=1,2,\\cdots, N$；$j=1,2,\\cdots,M$）。第一个整数表示该房间是否有楼梯通往上一层（$0$ 表示没有，$1$ 表示有），第二个整数表示指示牌上的数字。注意，从 $j$ 号房间的楼梯爬到上一层到达的房间一定也是 $j$ 号房间。\n\n最后一行，一个整数，表示小明从藏宝楼底层的几号房间进入开始寻宝（注：房间编号从 $0$ 开始）。", "outputFormat": "一个整数，表示打开宝箱的密钥，这个数可能会很大，请输出对 $20123$ 取模的结果即可。", "hint": "【数据范围】\n\n对于 $50\\%$ 数据，有 $0<N \\le 1000,0<x \\le 10^4$；  \n对于 $100\\%$ 数据，有 $0<N\\le 10000,0<M\\le 100,0<x \\le 10^6$。\n\nNOIP 2012 普及组 第二题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2012 Junior] Treasure Hunt", "background": null, "description": "It is said that a tempting treasure is hidden on the top floor of a distant Treasure Tower. After many hardships, Xiao Ming finally finds the legendary Treasure Tower. At the entrance stands a wooden board with big characters: Treasure Hunt Manual. The manual reads as follows:\n\nThe Treasure Tower has $N+1$ floors. The topmost floor is the top floor, and there is a room on the top floor that contains the treasure. Except for the top floor, there are $N$ other floors, each with $M$ rooms. These $M$ rooms form a circle and are numbered in counterclockwise order as $0,\\cdots,M-1$. Some rooms have stairs leading to the floor above, and the stair layout may be different on each floor. In each room there is a signboard with a number $x$. Starting from this room, choose the $x$-th room with stairs in counterclockwise order (suppose its index is $k$), go upstairs from that room, and after going up you will arrive at room $k$ on the floor above. For example, if the signboard in the current room says $2$, then start searching counterclockwise and find the second room that has stairs, and go upstairs from that room. If the current room itself has stairs to the upper floor, it is counted as the first room with stairs.\n\nAt the end of the manual, in large red characters, it says: \"Treasure Hunt Notice: The sum of the numbers on the signboards that help you find the room to go upstairs on each floor (that is, the number on the signboard in the first room entered on each floor) is the key to open the treasure chest.\"\n\nPlease help Xiao Ming compute this key to open the treasure chest.", "inputFormat": "The first line contains two integers $N$ and $M$, separated by a space. $N$ means there are $N$ floors other than the top floor, and $M$ means there are $M$ rooms on each floor other than the top floor.\n\nThe next $N \\times M$ lines each contain two integers separated by a space, describing the situation in one room. The $(i-1) \\times M + j$-th line describes room $j-1$ on floor $i$ ($i=1,2,\\cdots,N$; $j=1,2,\\cdots,M$). The first integer indicates whether this room has stairs to the floor above ($0$ means no, $1$ means yes). The second integer is the number on the signboard. Note that if you climb the stairs from room $j$ to the floor above, you will arrive at room $j$ on that floor.\n\nThe last line contains one integer, which is the index of the room on the bottom floor where Xiao Ming starts the treasure hunt (note: room indices start from $0$).", "outputFormat": "Output one integer: the key to open the treasure chest. This number can be very large, so output it modulo $20123$.", "hint": "Constraints\n\nFor $50\\%$ of the testdata, $0 < N \\le 1000$, $0 < x \\le 10^4$.  \nFor $100\\%$ of the testdata, $0 < N \\le 10000$, $0 < M \\le 100$, $0 < x \\le 10^6$.\n\nNOIP 2012 Junior, Problem 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2012 普及组] 寻宝", "background": null, "description": "传说很遥远的藏宝楼顶层藏着诱人的宝藏。小明历尽千辛万苦终于找到传说中的这个藏宝楼，藏宝楼的门口竖着一个木板，上面写有几个大字：寻宝说明书。说明书的内容如下：\n\n藏宝楼共有 $N+1$ 层，最上面一层是顶层，顶层有一个房间里面藏着宝藏。除了顶层外，藏宝楼另有 $N$ 层，每层 $M$ 个房间，这 $M$ 个房间围成一圈并按逆时针方向依次编号为 $0,\\cdots,M-1$。其中一些房间有通往上一层的楼梯，每层楼的楼梯设计可能不同。每个房间里有一个指示牌，指示牌上有一个数字 $x$，表示从这个房间开始按逆时针方向选择第 $x$ 个有楼梯的房间（假定该房间的编号为 $k$），从该房间上楼，上楼后到达上一层的 $k$ 号房间。比如当前房间的指示牌上写着 $2$，则按逆时针方向开始尝试，找到第 $2$ 个有楼梯的房间，从该房间上楼。如果当前房间本身就有楼梯通向上层，该房间作为第一个有楼梯的房间。\n\n寻宝说明书的最后用红色大号字体写着：“寻宝须知：帮助你找到每层上楼房间的指示牌上的数字（即每层第一个进入的房间内指示牌上的数字）总和为打开宝箱的密钥”。\n\n请帮助小明算出这个打开宝箱的密钥。", "inputFormat": "第一行有两个整数 $N$ 和 $M$，之间用一个空格隔开。$N$ 表示除了顶层外藏宝楼共 $N$ 层楼，$M$ 表示除顶层外每层楼有 $M$ 个房间。\n\n接下来 $N \\times M$ 行，每行两个整数，之间用一个空格隔开，每行描述一个房间内的情况，其中第 $(i-1) \\times M+j$ 行表示第 $i$ 层 $j-1$ 号房间的情况（$i=1,2,\\cdots, N$；$j=1,2,\\cdots,M$）。第一个整数表示该房间是否有楼梯通往上一层（$0$ 表示没有，$1$ 表示有），第二个整数表示指示牌上的数字。注意，从 $j$ 号房间的楼梯爬到上一层到达的房间一定也是 $j$ 号房间。\n\n最后一行，一个整数，表示小明从藏宝楼底层的几号房间进入开始寻宝（注：房间编号从 $0$ 开始）。", "outputFormat": "一个整数，表示打开宝箱的密钥，这个数可能会很大，请输出对 $20123$ 取模的结果即可。", "hint": "【数据范围】\n\n对于 $50\\%$ 数据，有 $0<N \\le 1000,0<x \\le 10^4$；  \n对于 $100\\%$ 数据，有 $0<N\\le 10000,0<M\\le 100,0<x \\le 10^6$。\n\nNOIP 2012 普及组 第二题", "locale": "zh-CN"}}}
{"pid": "P1077", "type": "P", "difficulty": 2, "samples": [["2 4\n3 2\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2012", "NOIP 普及组"], "title": "[NOIP 2012 普及组] 摆花", "background": "", "description": "小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共 $m$ 盆。通过调查顾客的喜好，小明列出了顾客最喜欢的 $n$ 种花，从 $1$ 到 $n$ 标号。为了在门口展出更多种花，规定第 $i$ 种花不能超过 $a_i$ 盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。\n\n试编程计算，一共有多少种不同的摆花方案。", "inputFormat": "第一行包含两个正整数 $n$ 和 $m$，中间用一个空格隔开。\n\n第二行有 $n$ 个整数，每两个整数之间用一个空格隔开，依次表示 $a_1,a_2, \\cdots ,a_n$。", "outputFormat": "一个整数，表示有多少种方案。注意：因为方案数可能很多，请输出方案数对 $10^6+7$ 取模的结果。", "hint": "【数据范围】\n\n对于 $20\\%$ 数据，有 $0<n \\le 8,0<m \\le 8,0 \\le a_i \\le 8$。\n\n对于 $50\\%$ 数据，有 $0<n \\le 20,0<m \\le 20,0 \\le a_i \\le 20$。\n\n对于 $100\\%$ 数据，有 $0<n \\le 100,0<m \\le 100,0 \\le a_i \\le 100$。\n\nNOIP 2012 普及组 第三题\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2012 Junior] Arranging Flowers", "background": null, "description": "Xiaoming’s flower shop has just opened. To attract customers, he wants to place a row of $m$ pots of flowers at the entrance. Based on a survey, he listed the $n$ most popular types of flowers, numbered from $1$ to $n$. To showcase more types, it is required that for each type $i$, no more than $a_i$ pots are used. When arranging, flowers of the same type must be placed together, and different types must be placed in increasing order of their labels.\n\nWrite a program to compute how many different arrangements there are.", "inputFormat": "The first line contains two positive integers $n$ and $m$, separated by a single space.\n\nThe second line contains $n$ integers, separated by single spaces, representing $a_1, a_2, \\cdots, a_n$.", "outputFormat": "Output a single integer, the number of arrangements. Note: since the number may be large, output the answer modulo $10^6 + 7$.", "hint": "Constraints\n\n- For $20\\%$ of the testdata: $0 < n \\le 8$, $0 < m \\le 8$, $0 \\le a_i \\le 8$.\n- For $50\\%$ of the testdata: $0 < n \\le 20$, $0 < m \\le 20$, $0 \\le a_i \\le 20$.\n- For $100\\%$ of the testdata: $0 < n \\le 100$, $0 < m \\le 100$, $0 \\le a_i \\le 100$.\n\nNOIP 2012 Junior Problem 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2012 普及组] 摆花", "background": "", "description": "小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共 $m$ 盆。通过调查顾客的喜好，小明列出了顾客最喜欢的 $n$ 种花，从 $1$ 到 $n$ 标号。为了在门口展出更多种花，规定第 $i$ 种花不能超过 $a_i$ 盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。\n\n试编程计算，一共有多少种不同的摆花方案。", "inputFormat": "第一行包含两个正整数 $n$ 和 $m$，中间用一个空格隔开。\n\n第二行有 $n$ 个整数，每两个整数之间用一个空格隔开，依次表示 $a_1,a_2, \\cdots ,a_n$。", "outputFormat": "一个整数，表示有多少种方案。注意：因为方案数可能很多，请输出方案数对 $10^6+7$ 取模的结果。", "hint": "【数据范围】\n\n对于 $20\\%$ 数据，有 $0<n \\le 8,0<m \\le 8,0 \\le a_i \\le 8$。\n\n对于 $50\\%$ 数据，有 $0<n \\le 20,0<m \\le 20,0 \\le a_i \\le 20$。\n\n对于 $100\\%$ 数据，有 $0<n \\le 100,0<m \\le 100,0 \\le a_i \\le 100$。\n\nNOIP 2012 普及组 第三题\n", "locale": "zh-CN"}}}
{"pid": "P1078", "type": "P", "difficulty": 4, "samples": [["2 2 1 1 2 \n1 2 \n0 1 \n1 0 \n1 2 10 \n", "-1"], ["2 2 1 1 2 \n1 2 \n0 1 \n0 0 \n1 2 10 ", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "图论", "2012", "NOIP 普及组", "剪枝", "最短路"], "title": "[NOIP 2012 普及组] 文化之旅（疑似错题）", "background": "本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。由于测试数据过水，可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）。本题题目和数据仅供参考。本题不接受添加 hack 数据。\n\n本题为错题。**不建议尝试或提交本题。**[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)", "description": "有一位使者要游历各国，他每到一个国家，都能学到一种文化，但他不愿意学习任何一种文化超过一次（即如果他学习了某种文化，则他就不能到达其他有这种文化的国家）。不同的国家可能有相同的文化。不同文化的国家对其他文化的看法不同，有些文化会排斥外来文化（即如果他学习了某种文化，则他不能到达排斥这种文化的其他国家）。\n\n现给定各个国家间的地理关系，各个国家的文化，每种文化对其他文化的看法，以及这位使者游历的起点和终点（在起点和终点也会学习当地的文化），国家间的道路距离，试求从起点到终点最少需走多少路。", "inputFormat": "第一行为五个整数 $N,K,M,S,T$，每两个整数之间用一个空格隔开，依次代表国家个数（国家编号为 $1$ 到 $N$），文化种数（文化编号为 $1$ 到 $K$），道路的条数，以及起点和终点的编号（保证 $S$ 不等于 $T$）；\n\n第二行为 $N$ 个整数，每两个整数之间用一个空格隔开，其中第 $i$ 个数 $C_i$，表示国家 $i$ 的文化为 $C_i$。\n\n接下来的 $K$ 行，每行 $K$ 个整数，每两个整数之间用一个空格隔开，记第 $i$ 行的第 $j$ 个数为 $a_{ij}$，$a_{ij}=1$ 表示文化 $i$ 排斥外来文化 $j$（$i$ 等于 $j$ 时表示排斥相同文化的外来人），$a_{ij}=0$ 表示不排斥（注意 $i$ 排斥 $j$ 并不保证 $j$ 一定也排斥 $i$）。\n\n接下来的 $M$ 行，每行三个整数 $u,v,d$，每两个整数之间用一个空格隔开，表示国家 $u$ 与国家 $v$ 有一条距离为 $d$ 的可双向通行的道路（保证 $u$ 不等于 $v$，两个国家之间可能有多条道路）。", "outputFormat": "一个整数，表示使者从起点国家到达终点国家最少需要走的距离数（如果无解则输出 $-1$）。", "hint": "### 输入输出样例 1 说明\n\n由于到国家 $2$ 必须要经过国家 $1$，而国家 $2$ 的文明却排斥国家 $1$ 的文明，所以不可能到达国家 $2$。\n\n\n### 输入输出样例 2 说明\n\n路线为 $1\\to 2$。\n\n### 数据范围\n\n对于 $100\\%$ 的数据，有：\n\n- $2 \\le N \\le 100$\n- $1 \\le K \\le 100$\n- $1 \\le M \\le N^2$\n- $1 \\le k_i \\le K$\n- $1 \\le u,v \\le N$\n- $1 \\le d \\le 1000$\n- $1 \\le S,T \\le N$\n- $S \\ne T$\n\nNOIP2012 普及组第四题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2012 Junior] Cultural Journey (suspected incorrect problem)", "background": null, "description": "A messenger plans to travel among countries. Each time he enters a country, he learns that country's culture. He refuses to learn any culture more than once; that is, once he has learned a culture, he cannot visit any other country that has the same culture. Different countries may share the same culture. Different cultures view other cultures differently: some cultures reject certain foreign cultures. Specifically, if he has learned a culture, then he cannot enter any country whose local culture rejects that learned culture. He also learns the local culture at both the start and the end.\n\nGiven the geography (countries and roads), each country's culture, each culture's view of other cultures, the start and end countries, and road distances, find the minimum total distance from the start to the end.", "inputFormat": "The first line contains five integers $N, K, M, S, T$ separated by single spaces, denoting the number of countries (indexed $1$ to $N$), the number of cultures (indexed $1$ to $K$), the number of roads, and the indices of the start and the end, respectively. It is guaranteed that $S \\ne T$.\n\nThe second line contains $N$ integers. The $i$-th integer $C_i$ denotes the culture of country $i$.\n\nThe next $K$ lines each contain $K$ integers separated by single spaces. Let the $j$-th integer on the $i$-th line be $a_{ij}$. If $a_{ij} = 1$, then culture $i$ rejects visitors who have learned culture $j$ (when $i = j$, it means rejecting visitors of the same culture). If $a_{ij} = 0$, it does not reject. Note that $i$ rejecting $j$ does not imply $j$ rejects $i$.\n\nThe next $M$ lines each contain three integers $u, v, d$ separated by single spaces, indicating an undirected road between countries $u$ and $v$ with distance $d$. It is guaranteed that $u \\ne v$, and there may be multiple roads between the same pair of countries.", "outputFormat": "Output a single integer: the minimum total distance for the messenger to travel from $S$ to $T$. If it is impossible, output $-1$.", "hint": "Explanation for Sample 1: Since reaching country $2$ must pass through country $1$, and the culture of country $2$ rejects the culture of country $1$, it is impossible to reach country $2$.\n\nExplanation for Sample 2: The route is $1 \\to 2$.\n\nConstraints:\n- For $100\\%$ of the testdata:\n  - $2 \\le N \\le 100$.\n  - $1 \\le K \\le 100$.\n  - $1 \\le M \\le N^2$.\n  - $1 \\le C_i \\le K$.\n  - $1 \\le u, v \\le N$.\n  - $1 \\le d \\le 1000$.\n  - $1 \\le S, T \\le N$.\n  - $S \\ne T$.\n\nThis is NOIP 2012 Junior Problem 4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2012 普及组] 文化之旅（疑似错题）", "background": "本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。由于测试数据过水，可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）。本题题目和数据仅供参考。本题不接受添加 hack 数据。\n\n本题为错题。**不建议尝试或提交本题。**[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)", "description": "有一位使者要游历各国，他每到一个国家，都能学到一种文化，但他不愿意学习任何一种文化超过一次（即如果他学习了某种文化，则他就不能到达其他有这种文化的国家）。不同的国家可能有相同的文化。不同文化的国家对其他文化的看法不同，有些文化会排斥外来文化（即如果他学习了某种文化，则他不能到达排斥这种文化的其他国家）。\n\n现给定各个国家间的地理关系，各个国家的文化，每种文化对其他文化的看法，以及这位使者游历的起点和终点（在起点和终点也会学习当地的文化），国家间的道路距离，试求从起点到终点最少需走多少路。", "inputFormat": "第一行为五个整数 $N,K,M,S,T$，每两个整数之间用一个空格隔开，依次代表国家个数（国家编号为 $1$ 到 $N$），文化种数（文化编号为 $1$ 到 $K$），道路的条数，以及起点和终点的编号（保证 $S$ 不等于 $T$）；\n\n第二行为 $N$ 个整数，每两个整数之间用一个空格隔开，其中第 $i$ 个数 $C_i$，表示国家 $i$ 的文化为 $C_i$。\n\n接下来的 $K$ 行，每行 $K$ 个整数，每两个整数之间用一个空格隔开，记第 $i$ 行的第 $j$ 个数为 $a_{ij}$，$a_{ij}=1$ 表示文化 $i$ 排斥外来文化 $j$（$i$ 等于 $j$ 时表示排斥相同文化的外来人），$a_{ij}=0$ 表示不排斥（注意 $i$ 排斥 $j$ 并不保证 $j$ 一定也排斥 $i$）。\n\n接下来的 $M$ 行，每行三个整数 $u,v,d$，每两个整数之间用一个空格隔开，表示国家 $u$ 与国家 $v$ 有一条距离为 $d$ 的可双向通行的道路（保证 $u$ 不等于 $v$，两个国家之间可能有多条道路）。", "outputFormat": "一个整数，表示使者从起点国家到达终点国家最少需要走的距离数（如果无解则输出 $-1$）。", "hint": "### 输入输出样例 1 说明\n\n由于到国家 $2$ 必须要经过国家 $1$，而国家 $2$ 的文明却排斥国家 $1$ 的文明，所以不可能到达国家 $2$。\n\n\n### 输入输出样例 2 说明\n\n路线为 $1\\to 2$。\n\n### 数据范围\n\n对于 $100\\%$ 的数据，有：\n\n- $2 \\le N \\le 100$\n- $1 \\le K \\le 100$\n- $1 \\le M \\le N^2$\n- $1 \\le k_i \\le K$\n- $1 \\le u,v \\le N$\n- $1 \\le d \\le 1000$\n- $1 \\le S,T \\le N$\n- $S \\ne T$\n\nNOIP2012 普及组第四题", "locale": "zh-CN"}}}
{"pid": "P1079", "type": "P", "difficulty": 2, "samples": [["CompleteVictory\nYvqgpxaimmklongnzfwpvxmniytm", "Wherethereisawillthereisaway"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "2012", "NOIP 提高组"], "title": "[NOIP 2012 提高组] Vigenère 密码", "background": null, "description": "16 世纪法国外交家 Blaise de Vigenère 设计了一种多表密码加密算法 Vigenère 密码。Vigenère 密码的加密解密算法简单易用，且破译难度比较高，曾在美国南北战争中为南军所广泛使用。\n\n \n在密码学中，我们称需要加密的信息为明文，用 $M$ 表示；称加密后的信息为密文，用 $C$ 表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为 $k$。在 Vigenère 密码中，密钥 $k$ 是一个字母串，$k=k_1,k_2,…,k_n$。当明文 $M=m_1,m_2,…,m_n$ 时，得到的密文 $C=c_1,c_2,…,c_n$，其中 $c_i$=$m_i \\operatorname{\\circledR} k_i$，运算 $\\circledR$ 的规则如下表所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ptr4yu7h.png)\n\nVigenère 加密在操作时需要注意：\n\n1. $\\circledR$ 运算忽略参与运算的字母的大小写，并保持字母在明文 $M$ 中的大小写形式；\n2. 当明文 $M$ 的长度大于密钥 $k$ 的长度时，将密钥 $k$ 重复使用。\n\n例如，明文 $M=\\texttt{Helloworld}$，密钥 $k=\\texttt{abc}$ 时，密文 $C=\\texttt{Hfnlpyosnd}$。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|} \\hline\n\\textsf{明文} & \\tt H & \\tt e & \\tt l & \\tt l & \\tt o & \\tt w & \\tt o & \\tt r & \\tt l & \\tt d \\\\  \\hline\n\\textsf{密钥} & \\tt a & \\tt b & \\tt c & \\tt a & \\tt b & \\tt c & \\tt a & \\tt b & \\tt c & \\tt a \\\\  \\hline\n\\textsf{密文} & \\tt H & \\tt f & \\tt n & \\tt l & \\tt p & \\tt y & \\tt o & \\tt s & \\tt n & \\tt d \\\\  \\hline\n\\end{array}\n$$", "inputFormat": "共 2 行。\n\n第一行为一个字符串，表示密钥 $k$，长度不超过 $100$，其中仅包含大小写字母。  \n\n第二行为一个字符串，表示经加密后的密文，长度不超过 $1000$，其中仅包含大小写字母。", "outputFormat": "一个字符串，表示输入密钥和密文所对应的明文。", "hint": "对于 $100\\%$ 的数据，输入的密钥的长度不超过 $100$，输入的密文的长度不超过 $1000$，且都仅包含英文字母。\n\nNOIP 2012 提高组 第一天 第一题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2012 Senior] Vigenère Cipher", "background": "", "description": "In the 16th century, the French diplomat Blaise de Vigenère designed a polyalphabetic cipher known as the Vigenère cipher. The Vigenère cipher’s encryption and decryption algorithms are simple and easy to use, yet relatively hard to break, and it was widely used by the Confederate Army during the American Civil War.\n\nIn cryptography, the information to be encrypted is called plaintext, denoted by $M$; the encrypted information is called ciphertext, denoted by $C$; and the key is a parameter, the data input to the algorithm that converts plaintext to ciphertext or ciphertext to plaintext, denoted by $k$. In the Vigenère cipher, the key $k$ is a string of letters, $k = k_1, k_2, \\dots, k_n$. When the plaintext is $M = m_1, m_2, \\dots, m_n$, the resulting ciphertext is $C = c_1, c_2, \\dots, c_n$, where $c_i = m_i \\operatorname{\\circledR} k_i$, and the rules of the operation $\\circledR$ are shown in the table below.\n    \n    \n$$\\begin{array}{c|cccccccccccccccccccccccccc}\n\\circledR &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt}  \\\\\\hline\n\\tt A &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt}  \\\\\n\\tt B &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt}  \\\\\n\\tt C &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt}  \\\\\n\\tt D &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt}  \\\\\n\\tt E &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt}  \\\\\n\\tt F &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt}  \\\\\n\\tt G &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt}  \\\\\n\\tt H &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt}  \\\\\n\\tt I &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt}  \\\\\n\\tt J &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt}  \\\\\n\\tt K &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt}  \\\\\n\\tt L &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt}  \\\\\n\\tt M &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt}  \\\\\n\\tt N &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt}  \\\\\n\\tt O &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt}  \\\\\n\\tt P &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt}  \\\\\n\\tt Q &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt}  \\\\\n\\tt R &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt}  \\\\\n\\tt S &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt}  \\\\\n\\tt T &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt}  \\\\\n\\tt U &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt}  \\\\\n\\tt V &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt}  \\\\\n\\tt W &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt}  \\\\\n\\tt X &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt}  \\\\\n\\tt Y &\\tt Y \\kern{-5pt} &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt}  \\\\\n\\tt Z &\\tt Z \\kern{-5pt} &\\tt A \\kern{-5pt} &\\tt B \\kern{-5pt} &\\tt C \\kern{-5pt} &\\tt D \\kern{-5pt} &\\tt E \\kern{-5pt} &\\tt F \\kern{-5pt} &\\tt G \\kern{-5pt} &\\tt H \\kern{-5pt} &\\tt I \\kern{-5pt} &\\tt J \\kern{-5pt} &\\tt K \\kern{-5pt} &\\tt L \\kern{-5pt} &\\tt M \\kern{-5pt} &\\tt N \\kern{-5pt} &\\tt O \\kern{-5pt} &\\tt P \\kern{-5pt} &\\tt Q \\kern{-5pt} &\\tt R \\kern{-5pt} &\\tt S \\kern{-5pt} &\\tt T \\kern{-5pt} &\\tt U \\kern{-5pt} &\\tt V \\kern{-5pt} &\\tt W \\kern{-5pt} &\\tt X \\kern{-5pt} &\\tt Y \\kern{-5pt}  \\\\\n\n\\end{array}\n$$\n\nWhen performing Vigenère encryption, note the following:\n1. The $\\circledR$ operation ignores the case of the letters involved, and preserves the case of each letter as it appears in the plaintext $M$.\n2. When the length of the plaintext $M$ exceeds the length of the key $k$, the key $k$ is reused cyclically.\n\nFor example, when the plaintext is $M=\\texttt{Helloworld}$ and the key is $k=\\texttt{abc}$, the ciphertext is $C=\\texttt{Hfnlpyosnd}$.\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|} \\hline\n\\textsf{明文} & \\tt H & \\tt e & \\tt l & \\tt l & \\tt o & \\tt w & \\tt o & \\tt r & \\tt l & \\tt d \\\\  \\hline\n\\textsf{密钥} & \\tt a & \\tt b & \\tt c & \\tt a & \\tt b & \\tt c & \\tt a & \\tt b & \\tt c & \\tt a \\\\  \\hline\n\\textsf{密文} & \\tt H & \\tt f & \\tt n & \\tt l & \\tt p & \\tt y & \\tt o & \\tt s & \\tt n & \\tt d \\\\  \\hline\n\\end{array}\n$$", "inputFormat": "There are 2 lines in total.\n- The first line contains a string representing the key $k$, with length not exceeding 100, containing only upper- and lowercase letters.\n- The second line contains a string representing the encrypted ciphertext, with length not exceeding 1000, containing only upper- and lowercase letters.", "outputFormat": "A single string representing the plaintext corresponding to the given key and ciphertext.", "hint": "For 100% of the testdata, the length of the input key does not exceed 100, the length of the input ciphertext does not exceed 1000, and both contain only English letters.\n\nNOIP 2012 Senior Day 1 Problem 1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2012 提高组] Vigenère 密码", "background": null, "description": "16 世纪法国外交家 Blaise de Vigenère 设计了一种多表密码加密算法 Vigenère 密码。Vigenère 密码的加密解密算法简单易用，且破译难度比较高，曾在美国南北战争中为南军所广泛使用。\n\n \n在密码学中，我们称需要加密的信息为明文，用 $M$ 表示；称加密后的信息为密文，用 $C$ 表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为 $k$。在 Vigenère 密码中，密钥 $k$ 是一个字母串，$k=k_1,k_2,…,k_n$。当明文 $M=m_1,m_2,…,m_n$ 时，得到的密文 $C=c_1,c_2,…,c_n$，其中 $c_i$=$m_i \\operatorname{\\circledR} k_i$，运算 $\\circledR$ 的规则如下表所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ptr4yu7h.png)\n\nVigenère 加密在操作时需要注意：\n\n1. $\\circledR$ 运算忽略参与运算的字母的大小写，并保持字母在明文 $M$ 中的大小写形式；\n2. 当明文 $M$ 的长度大于密钥 $k$ 的长度时，将密钥 $k$ 重复使用。\n\n例如，明文 $M=\\texttt{Helloworld}$，密钥 $k=\\texttt{abc}$ 时，密文 $C=\\texttt{Hfnlpyosnd}$。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|} \\hline\n\\textsf{明文} & \\tt H & \\tt e & \\tt l & \\tt l & \\tt o & \\tt w & \\tt o & \\tt r & \\tt l & \\tt d \\\\  \\hline\n\\textsf{密钥} & \\tt a & \\tt b & \\tt c & \\tt a & \\tt b & \\tt c & \\tt a & \\tt b & \\tt c & \\tt a \\\\  \\hline\n\\textsf{密文} & \\tt H & \\tt f & \\tt n & \\tt l & \\tt p & \\tt y & \\tt o & \\tt s & \\tt n & \\tt d \\\\  \\hline\n\\end{array}\n$$", "inputFormat": "共 2 行。\n\n第一行为一个字符串，表示密钥 $k$，长度不超过 $100$，其中仅包含大小写字母。  \n\n第二行为一个字符串，表示经加密后的密文，长度不超过 $1000$，其中仅包含大小写字母。", "outputFormat": "一个字符串，表示输入密钥和密文所对应的明文。", "hint": "对于 $100\\%$ 的数据，输入的密钥的长度不超过 $100$，输入的密文的长度不超过 $1000$，且都仅包含英文字母。\n\nNOIP 2012 提高组 第一天 第一题", "locale": "zh-CN"}}}
{"pid": "P1080", "type": "P", "difficulty": 5, "samples": [["3 \n1 1 \n2 3 \n7 4 \n4 6 ", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "高精度", "2012", "NOIP 提高组", "排序"], "title": "[NOIP 2012 提高组] 国王游戏", "background": null, "description": "恰逢 H 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。\n\n国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。", "inputFormat": "第一行包含一个整数 $n$，表示大臣的人数。\n\n第二行包含两个整数 $a$ 和 $b$，之间用一个空格隔开，分别表示国王左手和右手上的整数。\n\n接下来 $n$ 行，每行包含两个整数 $a$ 和 $b$，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。", "outputFormat": "一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。", "hint": "**【输入输出样例说明】**\n\n按 $1$、$2$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；\n\n按 $1$、$3$、$2$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；\n\n按 $2$、$1$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；\n\n按 $2$、$3$、$1$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$；\n\n按 $3$、$1$、$2$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；  \n\n按 $3$、$2$、$1$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$。\n\n因此，奖赏最多的大臣最少获得 $2$ 个金币，答案输出 $2$。\n\n**【数据范围】**\n\n对于 $20\\%$ 的数据，有 $1 \\le n \\le 10,0 < a,b < 8$；\n\n对于 $40\\%$ 的数据，有 $1 \\le n \\le 20,0 < a,b < 8$；\n\n对于 $60\\%$ 的数据，有 $1 \\le n \\le 100$；\n\n对于 $60\\%$ 的数据，保证答案不超过 $10^9$；\n\n对于 $100\\%$ 的数据，有 $1 \\le n \\le 1000,0 < a,b < 10000$。\n\n\n\nNOIP 2012 提高组 第一天 第二题。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2012 Senior] King's Game", "background": "", "description": "It is the National Day of country H, and the king invites $n$ ministers to play a prize game. First, he asks each minister to write an integer on his left hand and an integer on his right hand; the king also writes one integer on his left hand and one on his right hand. Then the $n$ ministers line up in a row, with the king standing at the very front. After the lineup is fixed, every minister will receive some gold coins from the king. The number of coins a minister receives equals the product of the numbers on the left hands of all people standing before that minister, divided by the integer on his own right hand, and then taking the floor.\n\nThe king does not want any single minister to get too many coins, so he asks you to rearrange the order of the ministers to make the maximum number of coins received by any minister as small as possible. Note that the king always stands at the very front.", "inputFormat": "The first line contains an integer $n$, the number of ministers.\n\nThe second line contains two integers $a$ and $b$ separated by a space, representing the integers on the king’s left and right hands, respectively.\n\nEach of the next $n$ lines contains two integers $a$ and $b$ separated by a space, representing one minister’s left- and right-hand integers, respectively.", "outputFormat": "Output one integer, the maximum number of coins received by any minister in the optimal arrangement.", "hint": "[Input/Output Sample Explanation]\n\nIf the lineup is 1, 2, 3, the maximum number of coins received is 2.\nIf the lineup is 1, 3, 2, the maximum number of coins received is 2.\nIf the lineup is 2, 1, 3, the maximum number of coins received is 2.\nIf the lineup is 2, 3, 1, the maximum number of coins received is 9.\nIf the lineup is 3, 1, 2, the maximum number of coins received is 2.\nIf the lineup is 3, 2, 1, the maximum number of coins received is 9.\nTherefore, the minimum possible maximum is 2, so output 2.\n\nConstraints:\nFor 20% of the testdata, $1 \\le n \\le 10$, $0 < a, b < 8$.\nFor 40% of the testdata, $1 \\le n \\le 20$, $0 < a, b < 8$.\nFor 60% of the testdata, $1 \\le n \\le 100$.\nFor 60% of the testdata, it is guaranteed that the answer does not exceed $10^9$.\nFor 100% of the testdata, $1 \\le n \\le 1000$, $0 < a, b < 10000$.\n\nNOIP 2012 Senior, Day 1, Problem 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2012 提高组] 国王游戏", "background": null, "description": "恰逢 H 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。\n\n国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。", "inputFormat": "第一行包含一个整数 $n$，表示大臣的人数。\n\n第二行包含两个整数 $a$ 和 $b$，之间用一个空格隔开，分别表示国王左手和右手上的整数。\n\n接下来 $n$ 行，每行包含两个整数 $a$ 和 $b$，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。", "outputFormat": "一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。", "hint": "**【输入输出样例说明】**\n\n按 $1$、$2$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；\n\n按 $1$、$3$、$2$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；\n\n按 $2$、$1$、$3$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；\n\n按 $2$、$3$、$1$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$；\n\n按 $3$、$1$、$2$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $2$；  \n\n按 $3$、$2$、$1$ 这样排列队伍，获得奖赏最多的大臣所获得金币数为 $9$。\n\n因此，奖赏最多的大臣最少获得 $2$ 个金币，答案输出 $2$。\n\n**【数据范围】**\n\n对于 $20\\%$ 的数据，有 $1 \\le n \\le 10,0 < a,b < 8$；\n\n对于 $40\\%$ 的数据，有 $1 \\le n \\le 20,0 < a,b < 8$；\n\n对于 $60\\%$ 的数据，有 $1 \\le n \\le 100$；\n\n对于 $60\\%$ 的数据，保证答案不超过 $10^9$；\n\n对于 $100\\%$ 的数据，有 $1 \\le n \\le 1000,0 < a,b < 10000$。\n\n\n\nNOIP 2012 提高组 第一天 第二题。", "locale": "zh-CN"}}}
{"pid": "P1081", "type": "P", "difficulty": 6, "samples": [["4 \n2 3 1 4 \n3 \n4 \n1 3 \n2 3 \n3 3 \n4 3\n", "1 \n1 1 \n2 0 \n0 0 \n0 0 "], ["10 \n4 5 6 1 2 3 7 8 9 10 \n7 \n10 \n1 7 \n2 7 \n3 7 \n4 7 \n5 7 \n6 7 \n7 7 \n8 7 \n9 7 \n10 7", "2 \n3 2 \n2 4 \n2 1 \n2 4 \n5 1 \n5 1 \n2 1 \n2 0 \n0 0 \n0 0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "倍增", "NOIP 提高组"], "title": "[NOIP 2012 提高组] 开车旅行", "background": null, "description": "小 $\\text{A}$ 和小 $\\text{B}$ 决定利用假期外出旅行，他们将想去的城市从 $1 $ 到 $n$ 编号，且编号较小的城市在编号较大的城市的西边，已知各个城市的海拔高度互不相同，记城市 $i$ 的海拔高度为$h_i$，城市 $i$ 和城市 $j$ 之间的距离 $d_{i,j}$ 恰好是这两个城市海拔高度之差的绝对值，即 $d_{i,j}=|h_i-h_j|$。\n \n旅行过程中，小 $\\text{A}$ 和小 $\\text{B}$ 轮流开车，第一天小 $\\text{A}$ 开车，之后每天轮换一次。他们计划选择一个城市 $s$ 作为起点，一直向东行驶，并且最多行驶 $x$ 公里就结束旅行。    \n\n小 $\\text{A}$ 和小 $\\text{B}$ 的驾驶风格不同，小 $\\text{B}$ 总是沿着前进方向选择一个最近的城市作为目的地，而小 $\\text{A}$ 总是沿着前进方向选择第二近的城市作为目的地（注意：本题中如果当前城市到两个城市的距离相同，则认为离海拔低的那个城市更近）。如果其中任何一人无法按照自己的原则选择目的城市，或者到达目的地会使行驶的总距离超出 $x$ 公里，他们就会结束旅行。\n\n在启程之前，小 $\\text{A}$ 想知道两个问题：\n\n1、 对于一个给定的 $x=x_0$，从哪一个城市出发，小 $\\text{A}$ 开车行驶的路程总数与小 $\\text{B}$ 行驶的路程总数的比值最小（如果小 $\\text{B}$ 的行驶路程为 $0$，此时的比值可视为无穷大，且两个无穷大视为相等）。如果从多个城市出发，小 $\\text{A}$ 开车行驶的路程总数与小 $\\text{B}$ 行驶的路程总数的比值都最小，则输出海拔最高的那个城市。\n\n2、对任意给定的 $x=x_i$ 和出发城市 $s_i$，小 $\\text{A}$ 开车行驶的路程总数以及小 $\\text B$ 行驶的路程总数。", "inputFormat": "第一行包含一个整数 $n$，表示城市的数目。\n\n第二行有 $n$ 个整数，每两个整数之间用一个空格隔开，依次表示城市 $1$ 到城市 $n$ 的海拔高度，即 $h_1,h_2 ... h_n$，且每个 $h_i$ 都是互不相同的。\n\n第三行包含一个整数 $x_0$。\n\n第四行为一个整数 $m$，表示给定 $m$ 组 $s_i$ 和 $x_i$。\n\n接下来的 $m$ 行，每行包含 $2$ 个整数 $s_i$ 和 $x_i$，表示从城市$s_i$ 出发，最多行驶 $x_i$ 公里。", "outputFormat": "输出共 $m+1$ 行。\n\n第一行包含一个整数 $s_0$，表示对于给定的 $x_0$，从编号为 $s_0$ 的城市出发，小 $\\text A$ 开车行驶的路程总数与小 $\\text B$ 行驶的路程总数的比值最小。\n\n接下来的 $m$ 行，每行包含 $2$ 个整数，之间用一个空格隔开，依次表示在给定的 $s_i$ 和 $x_i$ 下小 $\\text A$ 行驶的里程总数和小 $\\text B$ 行驶的里程总数。", "hint": "【样例1说明】\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zgms0k7y.png)\n\n各个城市的海拔高度以及两个城市间的距离如上图所示。\n\n如果从城市 $1$ 出发，可以到达的城市为 $2,3,4$，这几个城市与城市 $1$ 的距离分别为 $1,1,2$，但是由于城市 $3$ 的海拔高度低于城市 $2$，所以我们认为城市 $3$ 离城市 $1$ 最近，城市 $2$ 离城市 $1$ 第二近，所以小A会走到城市 $2$。到达城市 $2$ 后，前面可以到达的城市为 $3,4$，这两个城市与城市 $2$  的距离分别为 $2,1$，所以城市 $4$ 离城市 $2$ 最近，因此小B会走到城市$4$。到达城市 $4$ 后，前面已没有可到达的城市，所以旅行结束。\n\n如果从城市 $2$ 出发，可以到达的城市为 $3,4$，这两个城市与城市 $2$ 的距离分别为 $2,1$，由于城市 $3$ 离城市 $2$ 第二近，所以小 $\\text A$ 会走到城市 $3$。到达城市 $3$ 后，前面尚未旅行的城市为 $4$，所以城市 $4$ 离城市 $3$ 最近，但是如果要到达城市 $4$，则总路程为 $2+3=5>3$，所以小 $\\text B$ 会直接在城市 $3$ 结束旅行。\n\n如果从城市 $3$ 出发，可以到达的城市为 $4$，由于没有离城市 $3$ 第二近的城市，因此旅行还未开始就结束了。\n\n如果从城市 $4$ 出发，没有可以到达的城市，因此旅行还未开始就结束了。\n\n\n【样例2说明】\n\n当 $x=7$ 时，如果从城市 $1$ 出发，则路线为 $1 \\to 2 \\to 3 \\to 8 \\to 9$，小 $\\text A$ 走的距离为 $1+2=3$，小 $\\text B$ 走的距离为 $1+1=2$。（在城市 $1$ 时，距离小 $\\text A$ 最近的城市是 $2$ 和 $6$，但是城市 $2$ 的海拔更高，视为与城市 $1$ 第二近的城市，所以小 $\\text A$ 最终选择城市 $2$；走到$9$ 后，小 $\\text A$ 只有城市 $10$ 可以走，没有第二选择可以选，所以没法做出选择，结束旅行）\n\n如果从城市 $2$ 出发，则路线为 $2 \\to 6 \\to 7$，小 $\\text A$ 和小 $\\text B$ 走的距离分别为 $2,4$。\n\n如果从城市 $3$ 出发，则路线为 $3 \\to 8 \\to 9$，小 $\\text A$ 和小 $\\text B$ 走的距离分别为$2,1$。\n\n如果从城市 $4$ 出发，则路线为 $4 \\to 6 \\to 7$，小 $\\text A$ 和小 $\\text B$ 走的距离分别为 $2,4$。\n\n如果从城市 $5$ 出发，则路线为 $5 \\to 7 \\to 8$，小 $\\text A$ 和小 $\\text B$ 走的距离分别为 $5,1$。\n\n如果从城市 $6$ 出发，则路线为 $6 \\to 8 \\to 9$，小 $\\text A$ 和小 $\\text B$ 走的距离分别为$5,1$。\n\n如果从城市 $7$ 出发，则路线为 $7 \\to 9 \\to 10$，小 $\\text A$ 和小 $\\text B$ 走的距离分别为$2,1$。\n\n如果从城市 $8$ 出发，则路线为 $8 \\to 10$，小 $\\text A$ 和小 $\\text B$ 走的距离分别为$2,0$。\n\n如果从城市 $9$ 出发，则路线为 $9$，小 $\\text A$ 和小 $\\text B$ 走的距离分别为 $0,0$（旅行一开始就结束了）。\n\n如果从城市 $10$ 出发，则路线为 $10$，小 $\\text A$ 和小 $\\text B$ 走的距离分别为$0,0$。\n\n从城市 $2$ 或者城市 $4$ 出发小 $\\text A$ 行驶的路程总数与小 $\\text B$ 行驶的路程总数的比值都最小，但是城市 $2$ 的海拔更高，所以输出第一行为 $2$。\n\n【数据范围与约定】  \n\n对于 $30\\%$ 的数据，有 $1\\le n \\le 20,1\\le m\\le 20$；\n\n对于 $40\\%$ 的数据，有 $1\\le n \\le 100,1\\le m\\le 100$；\n\n对于 $50\\%$ 的数据，有 $1\\le n \\le 100,1\\le m\\le 1000$；\n\n对于 $70\\%$ 的数据，有 $1\\le n \\le 1000,1\\le m\\le 10^4$；\n\n对于 $100\\%$ 的数据：$1\\le n,m \\le 10^5$，$-10^9 \\le h_i≤10^9$，$1 \\le s_i \\le n$，$0 \\le x_i \\le 10^9$。\n\n数据保证 $h_i$ 互不相同。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2012 Senior] Driving Trip", "background": null, "description": "Little $\\text{A}$ and Little $\\text{B}$ decide to travel during the holidays. They number the cities from $1$ to $n$, where a city with a smaller index lies to the west of a city with a larger index. The altitudes of all cities are distinct. Let the altitude of city $i$ be $h_i$. The distance $d_{i,j}$ between city $i$ and city $j$ is exactly the absolute difference of their altitudes, i.e., $d_{i,j}=|h_i-h_j|$.\n\nDuring the trip, Little $\\text{A}$ and Little $\\text{B}$ take turns driving. Little $\\text{A}$ drives on the first day, and they alternate each subsequent day. They plan to choose some city $s$ as the starting point, always drive eastward, and end the trip after driving at most $x$ kilometers in total.\n\nLittle $\\text{A}$ and Little $\\text{B}$ have different driving styles. Little $\\text{B}$ always chooses the nearest city in the forward (east) direction as the destination, while Little $\\text{A}$ always chooses the second nearest city in the forward direction (note: in this problem, if the distances from the current city to two cities are the same, the city with the lower altitude is considered closer). If either person cannot choose a destination according to their rule, or if reaching the chosen destination would cause the total distance to exceed $x$ kilometers, the trip ends.\n\nBefore setting off, Little $\\text{A}$ wants to know two things:\n\n1. For a given $x=x_0$, from which city should they start so that the ratio of the total distance driven by Little $\\text{A}$ to that driven by Little $\\text{B}$ is minimized (if Little $\\text{B}$'s total distance is $0$, the ratio is considered infinite, and all infinities are regarded equal). If multiple starting cities yield the same minimum ratio, output the city with the highest altitude.\n\n2. For any given $x=x_i$ and starting city $s_i$, the total distance driven by Little $\\text{A}$ and the total distance driven by Little $\\text{B}$.", "inputFormat": "- The first line contains an integer $n$, the number of cities.\n- The second line contains $n$ integers separated by spaces, representing the altitudes of cities $1$ through $n$, i.e., $h_1,h_2,\\dots,h_n$, and all $h_i$ are distinct.\n- The third line contains an integer $x_0$.\n- The fourth line contains an integer $m$, the number of given pairs $(s_i,x_i)$.\n- Each of the next $m$ lines contains $2$ integers $s_i$ and $x_i$, indicating that the trip starts from city $s_i$ and the total distance is at most $x_i$ kilometers.", "outputFormat": "Output $m+1$ lines.\n\n- The first line contains an integer $s_0$, indicating that for the given $x_0$, starting from city $s_0$ minimizes the ratio of the total distance driven by Little $\\text{A}$ to that driven by Little $\\text{B}$.\n- Each of the next $m$ lines contains $2$ integers separated by a space, indicating, for the given $s_i$ and $x_i$, the total distance driven by Little $\\text{A}$ and by Little $\\text{B}$, respectively.", "hint": "[Explanation for Sample 1]\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zgms0k7y.png)\n\nThe altitudes of the cities and the distances between pairs of cities are as shown above.\n\nIf starting from city $1$, the reachable cities ahead are $2,3,4$, with distances from city $1$ being $1,1,2$, respectively. However, since the altitude of city $3$ is lower than that of city $2$, we consider city $3$ closer to city $1$, and city $2$ the second closest, so Little $\\text{A}$ goes to city $2$. After reaching city $2$, the reachable cities ahead are $3,4$, with distances $2,1$, respectively, so city $4$ is closer to city $2$; therefore Little $\\text{B}$ goes to city $4$. After reaching city $4$, there are no reachable cities ahead, so the trip ends.\n\nIf starting from city $2$, the reachable cities ahead are $3,4$, with distances $2,1$, respectively. Since city $3$ is the second closest to city $2$, Little $\\text{A}$ goes to city $3$. After reaching city $3$, the only remaining forward city is $4$, so city $4$ is the closest to city $3$. However, going to city $4$ would make the total distance $2+3=5>3$, so Little $\\text{B}$ ends the trip at city $3$.\n\nIf starting from city $3$, the only reachable city ahead is $4$. Since there is no second closest city to city $3$, the trip ends before it starts.\n\nIf starting from city $4$, there are no reachable cities ahead, so the trip ends before it starts.\n\n[Explanation for Sample 2]\n\nWhen $x=7$, if starting from city $1$, the route is $1 \\to 2 \\to 3 \\to 8 \\to 9$. Little $\\text{A}$ travels $1+2=3$, and Little $\\text{B}$ travels $1+1=2$. (At city $1$, the cities closest to Little $\\text{A}$ are $2$ and $6$, but city $2$ has a higher altitude and is regarded as the second closest to city $1$, so Little $\\text{A}$ ultimately chooses city $2$. After reaching $9$, Little $\\text{A}$ can only go to city $10$, and there is no second choice, so no decision can be made and the trip ends.)\n\nIf starting from city $2$, the route is $2 \\to 6 \\to 7$. Little $\\text{A}$ and Little $\\text{B}$ travel $2$ and $4$, respectively.\n\nIf starting from city $3$, the route is $3 \\to 8 \\to 9$. Little $\\text{A}$ and Little $\\text{B}$ travel $2$ and $1$, respectively.\n\nIf starting from city $4$, the route is $4 \\to 6 \\to 7$. Little $\\text{A}$ and Little $\\text{B}$ travel $2$ and $4$, respectively.\n\nIf starting from city $5$, the route is $5 \\to 7 \\to 8$. Little $\\text{A}$ and Little $\\text{B}$ travel $5$ and $1$, respectively.\n\nIf starting from city $6$, the route is $6 \\to 8 \\to 9$. Little $\\text{A}$ and Little $\\text{B}$ travel $5$ and $1$, respectively.\n\nIf starting from city $7$, the route is $7 \\to 9 \\to 10$. Little $\\text{A}$ and Little $\\text{B}$ travel $2$ and $1$, respectively.\n\nIf starting from city $8$, the route is $8 \\to 10$. Little $\\text{A}$ and Little $\\text{B}$ travel $2$ and $0$, respectively.\n\nIf starting from city $9$, the route is $9$. Little $\\text{A}$ and Little $\\text{B}$ travel $0$ and $0$, respectively (the trip ends immediately).\n\nIf starting from city $10$, the route is $10$. Little $\\text{A}$ and Little $\\text{B}$ travel $0$ and $0$, respectively.\n\nStarting from city $2$ or city $4$ yields the same minimum ratio of Little $\\text{A}$'s total distance to Little $\\text{B}$'s total distance, but city $2$ has a higher altitude, so the first line of the output is $2$.\n\nConstraints\n\n- For $30\\%$ of the testdata: $1 \\le n \\le 20, 1 \\le m \\le 20$.\n- For $40\\%$ of the testdata: $1 \\le n \\le 100, 1 \\le m \\le 100$.\n- For $50\\%$ of the testdata: $1 \\le n \\le 100, 1 \\le m \\le 1000$.\n- For $70\\%$ of the testdata: $1 \\le n \\le 1000, 1 \\le m \\le 10^4$.\n- For $100\\%$ of the testdata: $1 \\le n,m \\le 10^5$, $-10^9 \\le h_i≤10^9$, $1 \\le s_i \\le n$, $0 \\le x_i \\le 10^9$.\n\nThe testdata guarantees that $h_i$ are pairwise distinct.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2012 提高组] 开车旅行", "background": null, "description": "小 $\\text{A}$ 和小 $\\text{B}$ 决定利用假期外出旅行，他们将想去的城市从 $1 $ 到 $n$ 编号，且编号较小的城市在编号较大的城市的西边，已知各个城市的海拔高度互不相同，记城市 $i$ 的海拔高度为$h_i$，城市 $i$ 和城市 $j$ 之间的距离 $d_{i,j}$ 恰好是这两个城市海拔高度之差的绝对值，即 $d_{i,j}=|h_i-h_j|$。\n \n旅行过程中，小 $\\text{A}$ 和小 $\\text{B}$ 轮流开车，第一天小 $\\text{A}$ 开车，之后每天轮换一次。他们计划选择一个城市 $s$ 作为起点，一直向东行驶，并且最多行驶 $x$ 公里就结束旅行。    \n\n小 $\\text{A}$ 和小 $\\text{B}$ 的驾驶风格不同，小 $\\text{B}$ 总是沿着前进方向选择一个最近的城市作为目的地，而小 $\\text{A}$ 总是沿着前进方向选择第二近的城市作为目的地（注意：本题中如果当前城市到两个城市的距离相同，则认为离海拔低的那个城市更近）。如果其中任何一人无法按照自己的原则选择目的城市，或者到达目的地会使行驶的总距离超出 $x$ 公里，他们就会结束旅行。\n\n在启程之前，小 $\\text{A}$ 想知道两个问题：\n\n1、 对于一个给定的 $x=x_0$，从哪一个城市出发，小 $\\text{A}$ 开车行驶的路程总数与小 $\\text{B}$ 行驶的路程总数的比值最小（如果小 $\\text{B}$ 的行驶路程为 $0$，此时的比值可视为无穷大，且两个无穷大视为相等）。如果从多个城市出发，小 $\\text{A}$ 开车行驶的路程总数与小 $\\text{B}$ 行驶的路程总数的比值都最小，则输出海拔最高的那个城市。\n\n2、对任意给定的 $x=x_i$ 和出发城市 $s_i$，小 $\\text{A}$ 开车行驶的路程总数以及小 $\\text B$ 行驶的路程总数。", "inputFormat": "第一行包含一个整数 $n$，表示城市的数目。\n\n第二行有 $n$ 个整数，每两个整数之间用一个空格隔开，依次表示城市 $1$ 到城市 $n$ 的海拔高度，即 $h_1,h_2 ... h_n$，且每个 $h_i$ 都是互不相同的。\n\n第三行包含一个整数 $x_0$。\n\n第四行为一个整数 $m$，表示给定 $m$ 组 $s_i$ 和 $x_i$。\n\n接下来的 $m$ 行，每行包含 $2$ 个整数 $s_i$ 和 $x_i$，表示从城市$s_i$ 出发，最多行驶 $x_i$ 公里。", "outputFormat": "输出共 $m+1$ 行。\n\n第一行包含一个整数 $s_0$，表示对于给定的 $x_0$，从编号为 $s_0$ 的城市出发，小 $\\text A$ 开车行驶的路程总数与小 $\\text B$ 行驶的路程总数的比值最小。\n\n接下来的 $m$ 行，每行包含 $2$ 个整数，之间用一个空格隔开，依次表示在给定的 $s_i$ 和 $x_i$ 下小 $\\text A$ 行驶的里程总数和小 $\\text B$ 行驶的里程总数。", "hint": "【样例1说明】\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zgms0k7y.png)\n\n各个城市的海拔高度以及两个城市间的距离如上图所示。\n\n如果从城市 $1$ 出发，可以到达的城市为 $2,3,4$，这几个城市与城市 $1$ 的距离分别为 $1,1,2$，但是由于城市 $3$ 的海拔高度低于城市 $2$，所以我们认为城市 $3$ 离城市 $1$ 最近，城市 $2$ 离城市 $1$ 第二近，所以小A会走到城市 $2$。到达城市 $2$ 后，前面可以到达的城市为 $3,4$，这两个城市与城市 $2$  的距离分别为 $2,1$，所以城市 $4$ 离城市 $2$ 最近，因此小B会走到城市$4$。到达城市 $4$ 后，前面已没有可到达的城市，所以旅行结束。\n\n如果从城市 $2$ 出发，可以到达的城市为 $3,4$，这两个城市与城市 $2$ 的距离分别为 $2,1$，由于城市 $3$ 离城市 $2$ 第二近，所以小 $\\text A$ 会走到城市 $3$。到达城市 $3$ 后，前面尚未旅行的城市为 $4$，所以城市 $4$ 离城市 $3$ 最近，但是如果要到达城市 $4$，则总路程为 $2+3=5>3$，所以小 $\\text B$ 会直接在城市 $3$ 结束旅行。\n\n如果从城市 $3$ 出发，可以到达的城市为 $4$，由于没有离城市 $3$ 第二近的城市，因此旅行还未开始就结束了。\n\n如果从城市 $4$ 出发，没有可以到达的城市，因此旅行还未开始就结束了。\n\n\n【样例2说明】\n\n当 $x=7$ 时，如果从城市 $1$ 出发，则路线为 $1 \\to 2 \\to 3 \\to 8 \\to 9$，小 $\\text A$ 走的距离为 $1+2=3$，小 $\\text B$ 走的距离为 $1+1=2$。（在城市 $1$ 时，距离小 $\\text A$ 最近的城市是 $2$ 和 $6$，但是城市 $2$ 的海拔更高，视为与城市 $1$ 第二近的城市，所以小 $\\text A$ 最终选择城市 $2$；走到$9$ 后，小 $\\text A$ 只有城市 $10$ 可以走，没有第二选择可以选，所以没法做出选择，结束旅行）\n\n如果从城市 $2$ 出发，则路线为 $2 \\to 6 \\to 7$，小 $\\text A$ 和小 $\\text B$ 走的距离分别为 $2,4$。\n\n如果从城市 $3$ 出发，则路线为 $3 \\to 8 \\to 9$，小 $\\text A$ 和小 $\\text B$ 走的距离分别为$2,1$。\n\n如果从城市 $4$ 出发，则路线为 $4 \\to 6 \\to 7$，小 $\\text A$ 和小 $\\text B$ 走的距离分别为 $2,4$。\n\n如果从城市 $5$ 出发，则路线为 $5 \\to 7 \\to 8$，小 $\\text A$ 和小 $\\text B$ 走的距离分别为 $5,1$。\n\n如果从城市 $6$ 出发，则路线为 $6 \\to 8 \\to 9$，小 $\\text A$ 和小 $\\text B$ 走的距离分别为$5,1$。\n\n如果从城市 $7$ 出发，则路线为 $7 \\to 9 \\to 10$，小 $\\text A$ 和小 $\\text B$ 走的距离分别为$2,1$。\n\n如果从城市 $8$ 出发，则路线为 $8 \\to 10$，小 $\\text A$ 和小 $\\text B$ 走的距离分别为$2,0$。\n\n如果从城市 $9$ 出发，则路线为 $9$，小 $\\text A$ 和小 $\\text B$ 走的距离分别为 $0,0$（旅行一开始就结束了）。\n\n如果从城市 $10$ 出发，则路线为 $10$，小 $\\text A$ 和小 $\\text B$ 走的距离分别为$0,0$。\n\n从城市 $2$ 或者城市 $4$ 出发小 $\\text A$ 行驶的路程总数与小 $\\text B$ 行驶的路程总数的比值都最小，但是城市 $2$ 的海拔更高，所以输出第一行为 $2$。\n\n【数据范围与约定】  \n\n对于 $30\\%$ 的数据，有 $1\\le n \\le 20,1\\le m\\le 20$；\n\n对于 $40\\%$ 的数据，有 $1\\le n \\le 100,1\\le m\\le 100$；\n\n对于 $50\\%$ 的数据，有 $1\\le n \\le 100,1\\le m\\le 1000$；\n\n对于 $70\\%$ 的数据，有 $1\\le n \\le 1000,1\\le m\\le 10^4$；\n\n对于 $100\\%$ 的数据：$1\\le n,m \\le 10^5$，$-10^9 \\le h_i≤10^9$，$1 \\le s_i \\le n$，$0 \\le x_i \\le 10^9$。\n\n数据保证 $h_i$ 互不相同。", "locale": "zh-CN"}}}
{"pid": "P1082", "type": "P", "difficulty": 4, "samples": [["3 10", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2012", "NOIP 提高组", "扩展欧几里德算法"], "title": "[NOIP 2012 提高组] 同余方程", "background": null, "description": "求关于 $ x$ 的同余方程 $ a x \\equiv 1 \\pmod {b}$ 的最小正整数解。", "inputFormat": "一行，包含两个整数 $a,b$，用一个空格隔开。", "outputFormat": "一个整数 $x_0$，即最小正整数解。输入数据保证一定有解。", "hint": "### 数据规模与约定\n\n- 对于 $40\\%$ 的数据，$2 \\le b\\le  10^3$；\n- 对于 $60\\%$ 的数据，$2 \\le b\\le  5\\times 10^7$；\n- 对于 $100\\%$ 的数据，$2 \\le a, b\\le  2\\times 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2012 Senior] Congruence Equation", "background": null, "description": "Find the smallest positive integer solution of $ x$ to the congruence equation $ a x \\equiv 1 \\pmod {b}$.", "inputFormat": "One line containing two integers $a,b$, separated by a single space.", "outputFormat": "A single integer $x_0$, which is the smallest positive solution. The input is guaranteed to have a solution.", "hint": "### Constraints\n\n- For $40\\%$ of the testdata, $2 \\le b \\le 1{,}000$.\n- For $60\\%$ of the testdata, $2 \\le b \\le 50{,}000{,}000$.\n- For $100\\%$ of the testdata, $2 \\le a, b \\le 2{,}000{,}000{,}000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2012 提高组] 同余方程", "background": null, "description": "求关于 $ x$ 的同余方程 $ a x \\equiv 1 \\pmod {b}$ 的最小正整数解。", "inputFormat": "一行，包含两个整数 $a,b$，用一个空格隔开。", "outputFormat": "一个整数 $x_0$，即最小正整数解。输入数据保证一定有解。", "hint": "### 数据规模与约定\n\n- 对于 $40\\%$ 的数据，$2 \\le b\\le  10^3$；\n- 对于 $60\\%$ 的数据，$2 \\le b\\le  5\\times 10^7$；\n- 对于 $100\\%$ 的数据，$2 \\le a, b\\le  2\\times 10^9$。", "locale": "zh-CN"}}}
{"pid": "P1083", "type": "P", "difficulty": 3, "samples": [["4 3 \n2 5 4 3 \n2 1 3 \n3 2 4 \n4 2 4", "-1 \n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2012", "线段树", "二分", "NOIP 提高组", "前缀和", "差分"], "title": "[NOIP 2012 提高组] 借教室", "background": null, "description": "在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。\n\n面对海量租借教室的信息，我们自然希望编程解决这个问题。\n\n我们需要处理接下来 $n$ 天的借教室信息，其中第 $i$ 天学校有 $r_i$ 个教室可供租借。共有 $m$ 份订单，每份订单用三个正整数描述，分别为 $d_j,s_j,t_j$，表示某租借者需要从第 $s_j$ 天到第 $t_j$ 天租借教室（包括第 $s_j$ 天和第 $t_j$ 天），每天需要租借 $d_j$ 个教室。\n\n我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供 $d_j$ 个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。\n\n借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第 $s_j$ 天到第 $t_j$ 天中有至少一天剩余的教室数量不足 $d_j$ 个。\n\n现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。", "inputFormat": "第一行包含两个正整数 $n,m$，表示天数和订单的数量。\n\n第二行包含 $n$ 个正整数，其中第 $i$ 个数为 $r_i$，表示第 $i$ 天可用于租借的教室数量。\n\n接下来有 $m$ 行，每行包含三个正整数 $d_j,s_j,t_j$，表示租借的数量，租借开始、结束分别在第几天。\n\n每行相邻的两个数之间均用一个空格隔开。天数与订单均用从 $1$ 开始的整数编号。", "outputFormat": "如果所有订单均可满足，则输出只有一行，包含一个整数 $0$。\n\n否则（订单无法完全满足）输出两行，第一行输出一个负整数 $-1$，第二行输出需要修改订单的申请人编号。", "hint": "【输入输出样例说明】\n\n第 $1$ 份订单满足后，$4$ 天剩余的教室数分别为 $0,3,2,3$。第 $2$ 份订单要求第 $2$ 天到第 $4$ 天每天提供 $3$ 个教室，而第 $3$ 天剩余的教室数为 $2$，因此无法满足。分配停止，通知第 $2$ 个申请人修改订单。\n\n【数据范围】\n\n对于 $10\\%$ 的数据，有 $1\\le n,m\\le 10$；\n\n对于 $30\\%$ 的数据，有 $1\\le n,m\\le 1000$；\n\n对于 $70\\%$ 的数据，有 $1 \\le n,m \\le 10^5$；\n\n对于 $100\\%$ 的数据，有 $1 \\le n,m \\le 10^6$，$0 \\le r_i,d_j\\le 10^9$，$1 \\le s_j\\le t_j\\le n$。\n\n\nNOIP 2012 提高组 第二天 第二题\n\n2022.2.20 新增一组 hack 数据", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2012 Senior] Borrowing Classrooms", "background": null, "description": "During university, classrooms often need to be rented. From department events to small study groups, everyone needs to apply to the school to borrow classrooms. Classroom sizes and functions differ, and the borrower’s identity may differ, so the procedures vary as well.\n\nGiven a large number of rental requests, we want to solve this problem by programming.\n\nWe need to process borrowing requests for the next $n$ days. On day $i$, the school has $r_i$ classrooms available for rent. There are $m$ orders. Each order is described by three positive integers $d_j, s_j, t_j$, meaning a borrower wants to rent $d_j$ classrooms per day from day $s_j$ to day $t_j$ inclusive.\n\nWe assume borrowers have no requirements regarding classroom size or location. That is, for each order we only need to provide $d_j$ classrooms each day; which specific classrooms they are, or whether they are the same across days, does not matter.\n\nBorrowing follows a first-come, first-served principle. We process orders in the given order and allocate classrooms accordingly. If, during allocation, an order cannot be fully satisfied, we must stop allocation and notify the current applicant to modify the order. Here, “cannot be satisfied” means that on at least one day between $s_j$ and $t_j$, the remaining number of classrooms is less than $d_j$.\n\nWe need to determine whether any order cannot be fully satisfied. If so, which applicant should be notified to modify their order.", "inputFormat": "- The first line contains two positive integers $n, m$, the number of days and the number of orders.\n- The second line contains $n$ positive integers; the $i$-th number is $r_i$, the number of classrooms available on day $i$.\n- The next $m$ lines each contain three positive integers $d_j, s_j, t_j$, denoting the quantity requested per day and the start and end days of the rental.\n- Adjacent numbers on the same line are separated by a single space. Days and orders are both numbered starting from $1$.", "outputFormat": "- If all orders can be satisfied, output a single line containing the integer $0$.\n- Otherwise, output two lines: the first line contains the negative integer $-1$, and the second line contains the index of the applicant whose order needs to be modified.", "hint": "Sample explanation:\n\nAfter satisfying order $1$, the remaining classrooms for $4$ days are $0, 3, 2, 3$. Order $2$ asks for $3$ classrooms per day from day $2$ to day $4$, but on day $3$ the remaining classrooms are $2$, so it cannot be satisfied. Allocation stops, and the applicant of order $2$ is notified to modify the order.\n\nConstraints:\n\n- For $10\\%$ of the testdata, $1 \\le n, m \\le 10$.\n- For $30\\%$ of the testdata, $1 \\le n, m \\le 1000$.\n- For $70\\%$ of the testdata, $1 \\le n, m \\le 10^5$.\n- For $100\\%$ of the testdata, $1 \\le n, m \\le 10^6$, $0 \\le r_i, d_j \\le 10^9$, $1 \\le s_j \\le t_j \\le n$.\n\nAdditional notes:\n\nNOIP 2012 Senior Day 2, Problem 2.\n\nA new set of hack testdata was added on 2022.2.20.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2012 提高组] 借教室", "background": null, "description": "在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。\n\n面对海量租借教室的信息，我们自然希望编程解决这个问题。\n\n我们需要处理接下来 $n$ 天的借教室信息，其中第 $i$ 天学校有 $r_i$ 个教室可供租借。共有 $m$ 份订单，每份订单用三个正整数描述，分别为 $d_j,s_j,t_j$，表示某租借者需要从第 $s_j$ 天到第 $t_j$ 天租借教室（包括第 $s_j$ 天和第 $t_j$ 天），每天需要租借 $d_j$ 个教室。\n\n我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供 $d_j$ 个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。\n\n借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第 $s_j$ 天到第 $t_j$ 天中有至少一天剩余的教室数量不足 $d_j$ 个。\n\n现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。", "inputFormat": "第一行包含两个正整数 $n,m$，表示天数和订单的数量。\n\n第二行包含 $n$ 个正整数，其中第 $i$ 个数为 $r_i$，表示第 $i$ 天可用于租借的教室数量。\n\n接下来有 $m$ 行，每行包含三个正整数 $d_j,s_j,t_j$，表示租借的数量，租借开始、结束分别在第几天。\n\n每行相邻的两个数之间均用一个空格隔开。天数与订单均用从 $1$ 开始的整数编号。", "outputFormat": "如果所有订单均可满足，则输出只有一行，包含一个整数 $0$。\n\n否则（订单无法完全满足）输出两行，第一行输出一个负整数 $-1$，第二行输出需要修改订单的申请人编号。", "hint": "【输入输出样例说明】\n\n第 $1$ 份订单满足后，$4$ 天剩余的教室数分别为 $0,3,2,3$。第 $2$ 份订单要求第 $2$ 天到第 $4$ 天每天提供 $3$ 个教室，而第 $3$ 天剩余的教室数为 $2$，因此无法满足。分配停止，通知第 $2$ 个申请人修改订单。\n\n【数据范围】\n\n对于 $10\\%$ 的数据，有 $1\\le n,m\\le 10$；\n\n对于 $30\\%$ 的数据，有 $1\\le n,m\\le 1000$；\n\n对于 $70\\%$ 的数据，有 $1 \\le n,m \\le 10^5$；\n\n对于 $100\\%$ 的数据，有 $1 \\le n,m \\le 10^6$，$0 \\le r_i,d_j\\le 10^9$，$1 \\le s_j\\le t_j\\le n$。\n\n\nNOIP 2012 提高组 第二天 第二题\n\n2022.2.20 新增一组 hack 数据", "locale": "zh-CN"}}}
{"pid": "P1084", "type": "P", "difficulty": 6, "samples": [["4 \n1 2 1 \n1 3 2 \n3 4 3 \n2 \n2 2", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "树形数据结构", "2012", "倍增", "二分", "NOIP 提高组", "排序", "树链剖分"], "title": "[NOIP 2012 提高组] 疫情控制", "background": null, "description": "H 国有 $n $ 个城市，这 $n$ 个城市用 $ n-1 $ 条双向道路相互连通构成一棵树，$1 $ 号城市是首都，也是树中的根节点。\n\nH 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。\n\n现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。\n\n请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。", "inputFormat": "第一行一个整数 $ n$，表示城市个数。\n\n接下来的 $n-1$ 行，每行 $ 3 $ 个整数，$u,v,w$，每两个整数之间用一个空格隔开，表示从城市 $u $ 到城市 $ v$ 有一条长为 $w$ 的道路。数据保证输入的是一棵树，且根节点编号为 $1$。\n\n接下来一行一个整数 $m$，表示军队个数。\n\n接下来一行 $m $ 个整数，每两个整数之间用一个空格隔开，分别表示这 $m$ 个军队所驻扎的城市的编号。", "outputFormat": "一个整数，表示控制疫情所需要的最少时间。如果无法控制疫情则输出 $-1$。", "hint": "【输入输出样例说明】\n\n第一支军队在 $2$ 号点设立检查点，第二支军队从 $2$ 号点移动到 $3$ 号点设立检查点，所需时间为 $3$ 个小时。\n\n \n【数据范围】\n\n保证军队不会驻扎在首都。\n\n- 对于 $20\\%$ 的数据，$2 \\le n\\le 10$；\n- 对于 $40\\%$ 的数据，$2 \\le n\\le 50$，$0<w <10^5$；\n- 对于 $60\\%$ 的数据，$2 \\le n\\le 1000$，$0<w <10^6$；\n- 对于 $80\\%$ 的数据，$2 \\le n\\le 10^4$；\n- 对于 $100\\%$ 的数据，$2\\le m\\le n≤5\\times 10^4$，$0<w <10^9$。\n\n\nNOIP 2012 提高组 第二天 第三题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2012 Senior] Epidemic Control", "background": "", "description": "Country H has $n$ cities. These $n$ cities are connected by $n-1$ bidirectional roads to form a tree. City $1$ is the capital and is the root of the tree.\n\nA highly dangerous contagious disease has broken out in the capital. To control the epidemic and prevent it from spreading to border cities (cities represented by leaf nodes), the authorities decide to deploy the army to set up checkpoints in some cities so that every path from the capital to any border city contains at least one checkpoint. Checkpoints may also be set in border cities. Note in particular that no checkpoint may be set in the capital.\n\nCurrently, troops are already stationed in some cities of Country H, and multiple troops may be stationed in the same city. A troop can move between adjacent cities along roads and can set up a checkpoint in any city except the capital. Each troop can set a checkpoint in only one city. The time for a troop to move across a road from one city to another equals the length of that road (unit: hours).\n\nWhat is the minimum number of hours needed to control the epidemic? Note that different troops can move simultaneously.", "inputFormat": "The first line contains an integer $n$, the number of cities.\n\nThe next $n-1$ lines each contain $3$ integers, $u, v, w$, separated by single spaces, indicating there is a road of length $w$ between cities $u$ and $v$. It is guaranteed that the input forms a tree, and the root is city $1$.\n\nThe next line contains an integer $m$, the number of troops.\n\nThe next line contains $m$ integers, separated by single spaces, indicating the cities where the $m$ troops are stationed.", "outputFormat": "Output a single integer, the minimum time needed to control the epidemic. If it is impossible to control the epidemic, output $-1$.", "hint": "Sample explanation:\n\nThe first troop sets a checkpoint at city $2$, and the second troop moves from city $2$ to city $3$ to set a checkpoint. The time needed is $3$ hours.\n\nConstraints:\n\nIt is guaranteed that no troop is stationed in the capital.\n\n- For $20\\%$ of the testdata, $2 \\le n \\le 10$. \n- For $40\\%$ of the testdata, $2 \\le n \\le 50$, $0 < w < 10^5$. \n- For $60\\%$ of the testdata, $2 \\le n \\le 1000$, $0 < w < 10^6$. \n- For $80\\%$ of the testdata, $2 \\le n \\le 10^4$. \n- For $100\\%$ of the testdata, $2 \\le m \\le n \\le 5 \\times 10^4$, $0 < w < 10^9$. \n\nNOIP 2012 Senior Day 2, Problem 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2012 提高组] 疫情控制", "background": null, "description": "H 国有 $n $ 个城市，这 $n$ 个城市用 $ n-1 $ 条双向道路相互连通构成一棵树，$1 $ 号城市是首都，也是树中的根节点。\n\nH 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。\n\n现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。\n\n请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。", "inputFormat": "第一行一个整数 $ n$，表示城市个数。\n\n接下来的 $n-1$ 行，每行 $ 3 $ 个整数，$u,v,w$，每两个整数之间用一个空格隔开，表示从城市 $u $ 到城市 $ v$ 有一条长为 $w$ 的道路。数据保证输入的是一棵树，且根节点编号为 $1$。\n\n接下来一行一个整数 $m$，表示军队个数。\n\n接下来一行 $m $ 个整数，每两个整数之间用一个空格隔开，分别表示这 $m$ 个军队所驻扎的城市的编号。", "outputFormat": "一个整数，表示控制疫情所需要的最少时间。如果无法控制疫情则输出 $-1$。", "hint": "【输入输出样例说明】\n\n第一支军队在 $2$ 号点设立检查点，第二支军队从 $2$ 号点移动到 $3$ 号点设立检查点，所需时间为 $3$ 个小时。\n\n \n【数据范围】\n\n保证军队不会驻扎在首都。\n\n- 对于 $20\\%$ 的数据，$2 \\le n\\le 10$；\n- 对于 $40\\%$ 的数据，$2 \\le n\\le 50$，$0<w <10^5$；\n- 对于 $60\\%$ 的数据，$2 \\le n\\le 1000$，$0<w <10^6$；\n- 对于 $80\\%$ 的数据，$2 \\le n\\le 10^4$；\n- 对于 $100\\%$ 的数据，$2\\le m\\le n≤5\\times 10^4$，$0<w <10^9$。\n\n\nNOIP 2012 提高组 第二天 第三题", "locale": "zh-CN"}}}
{"pid": "P1085", "type": "P", "difficulty": 1, "samples": [["5 3\n6 2\n7 2\n5 3\n5 4\n0 4\n0 6\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2004", "NOIP 普及组", "枚举"], "title": "[NOIP 2004 普及组] 不高兴的津津", "background": "", "description": "津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每周妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。假设津津不会因为其它事不高兴，并且她的不高兴不会持续到第二天。请你帮忙检查一下津津下周的日程安排，看看下周她会不会不高兴；如果会的话，哪天最不高兴。\n", "inputFormat": "输入包括 $7$ 行数据，分别表示周一到周日的日程安排。每行包括两个小于 $10$ 的非负整数，用空格隔开，分别表示津津在学校上课的时间和妈妈安排她上课的时间。\n", "outputFormat": "一个数字。如果不会不高兴则输出 $0$，如果会则输出最不高兴的是周几（用 $1, 2, 3, 4, 5, 6, 7$ 分别表示周一，周二，周三，周四，周五，周六，周日）。如果有两天或两天以上不高兴的程度相当，则输出时间最靠前的一天。\n", "hint": "NOIP2004 普及组第 1 题\n\n- 2021-10-27：增加一组 hack 数据\n- 2022-06-05：又增加一组 hack 数据", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2004 Junior] Unhappy Jinjin", "background": null, "description": "Jinjin has started middle school. Her mom thinks she should study harder, so besides going to school, Jinjin also has to attend various review classes that her mom signed her up for. In addition, each week her mom sends her to study recitation, dance, and piano. However, if Jinjin has more than eight hours of classes in a day, she will be unhappy, and the longer she studies, the more unhappy she becomes. Assume Jinjin will not be unhappy for other reasons, and her unhappiness does not carry over to the next day. Please check Jinjin’s schedule for next week and determine whether she will be unhappy; if so, on which day she will be the most unhappy.", "inputFormat": "The input consists of $7$ lines, representing Monday through Sunday. Each line contains two non-negative integers less than $10$, separated by a space, indicating the hours Jinjin spends in school and the hours in the classes arranged by her mother.", "outputFormat": "Output a single integer. Output $0$ if she will not be unhappy; otherwise, output the day of the week on which she is the most unhappy (use $1, 2, 3, 4, 5, 6, 7$ to denote Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday, respectively). If two or more days have the same degree of unhappiness, output the earliest one.", "hint": "NOIP 2004 Junior Problem 1.\n\n- 2021-10-27: Added a hack testdata set.\n- 2022-06-05: Added another hack testdata set.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2004 普及组] 不高兴的津津", "background": "", "description": "津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每周妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。假设津津不会因为其它事不高兴，并且她的不高兴不会持续到第二天。请你帮忙检查一下津津下周的日程安排，看看下周她会不会不高兴；如果会的话，哪天最不高兴。\n", "inputFormat": "输入包括 $7$ 行数据，分别表示周一到周日的日程安排。每行包括两个小于 $10$ 的非负整数，用空格隔开，分别表示津津在学校上课的时间和妈妈安排她上课的时间。\n", "outputFormat": "一个数字。如果不会不高兴则输出 $0$，如果会则输出最不高兴的是周几（用 $1, 2, 3, 4, 5, 6, 7$ 分别表示周一，周二，周三，周四，周五，周六，周日）。如果有两天或两天以上不高兴的程度相当，则输出时间最靠前的一天。\n", "hint": "NOIP2004 普及组第 1 题\n\n- 2021-10-27：增加一组 hack 数据\n- 2022-06-05：又增加一组 hack 数据", "locale": "zh-CN"}}}
{"pid": "P1086", "type": "P", "difficulty": 2, "samples": [["6 7 21\n0 0 0 0 0 0 0\n0 0 0 0 13 0 0\n0 0 0 0 0 0 7\n0 15 0 0 0 0 0\n0 0 0 9 0 0 0\n0 0 0 0 0 0 0", "37"], ["6 7 20\n0 0 0 0 0 0 0\n0 0 0 0 13 0 0\n0 0 0 0 0 0 7\n0 15 0 0 0 0 0\n0 0 0 9 0 0 0\n0 0 0 0 0 0 0\n", "28"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "2004", "NOIP 普及组"], "title": "[NOIP 2004 普及组] 花生采摘", "background": null, "description": "鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。\n\n鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图一）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/unwk7hd0.png)\n\n我们假定多多在每个单位时间内，可以做下列四件事情中的一件：\n\n1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；\n2) 从一棵植株跳到前后左右与之相邻的另一棵植株；\n3) 采摘一棵植株下的花生；\n4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。\n\n现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。\n\n例如，在图 2 所示的花生田里，只有位于 $(2, 5), (3, 7), (4, 2), (5, 4)$ 的植株下长有花生，个数分别为 $13, 7, 15, 9$。沿着图示的路线，多多在 $21$ 个单位时间内，最多可以采到 $37$ 个花生。\n\n**注意：在采摘过程中不能回到路边。**", "inputFormat": "第一行包括三个整数 $M,N,K$，其间以空格隔开，表示花生田的大小为 $M  \\times N$，多多采花生的限定时间为 $K$ 个单位时间。\n\n接下来的 $M$ 行，每行包括 $N$ 个非负整数，也用空格隔开。第 $i + 1$ 行的第 $j$ 个整数 $P_{i,j}$ 表示花生田中植株 $(i, j)$ 下花生的数目，$0$ 表示该植株下没有花生。", "outputFormat": "一个整数，即在限定时间内，多多最多可以采到花生的个数。", "hint": "noip2004普及组第2题\n\n对于 $100\\%$ 的数据，$1  \\le M, N  \\le 20,0  \\le K  \\le  1000,0  \\le P_{i,j}  \\le 500$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2004 Junior] Peanut Picking", "background": null, "description": "Mr. Robinson has a pet monkey named Dodo. One day, while they were walking along a country road, they found a small note on a roadside sign: “Welcome to taste my peanuts for free! — Xiong.”\n\nThey were happy because peanuts are their favorite. Behind the sign, there is indeed a peanut field by the roadside, where peanut plants are arranged in a rectangular grid (see Figure 1). Experienced Dodo can tell how many peanuts are under each plant at a glance. To train Dodo’s arithmetic, Mr. Robinson says: “First find the plant with the most peanuts and pick its peanuts; then among the remaining plants, find the one with the most peanuts and pick it; and so on. But you must return to the roadside within the time limit I set.”\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/unwk7hd0.png)\n\nWe assume that in each unit of time, Dodo can do exactly one of the following four actions:\n1) Jump from the roadside to some peanut plant in the first row (i.e., the row closest to the roadside).\n2) Jump from one plant to another plant adjacent to it in the up, down, left, or right direction.\n3) Pick the peanuts under the current plant.\n4) Jump from some plant in the first row back to the roadside.\n\nGiven the size of the peanut field and the distribution of peanuts, compute the maximum number of peanuts Dodo can pick within the time limit. Note that only some plants may have peanuts under them. Assume that the numbers of peanuts on those plants are pairwise distinct.\n\nFor example, in the peanut field shown in Figure 2, only the plants at $(2, 5), (3, 7), (4, 2), (5, 4)$ have peanuts, in quantities $13, 7, 15, 9$, respectively. Along the illustrated route, Dodo can pick at most $37$ peanuts within $21$ units of time.\n\n**Note: You may not return to the roadside during the picking process.**", "inputFormat": "The first line contains three integers $M, N, K$, separated by spaces, indicating that the field size is $M \\times N$ and the time limit is $K$ units.\n\nThe next $M$ lines each contain $N$ non-negative integers, also separated by spaces. In the $(i + 1)$-th line, the $j$-th integer $P_{i,j}$ denotes the number of peanuts under plant $(i, j)$; $0$ means that plant has no peanuts.", "outputFormat": "Output a single integer: the maximum number of peanuts Dodo can pick within the time limit.", "hint": "NOIP 2004 Junior, Problem 2.\n\nConstraints: For $100\\%$ of the testdata, $1 \\le M, N \\le 20$, $0 \\le K \\le 1000$, $0 \\le P_{i,j} \\le 500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2004 普及组] 花生采摘", "background": null, "description": "鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。\n\n鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图一）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/unwk7hd0.png)\n\n我们假定多多在每个单位时间内，可以做下列四件事情中的一件：\n\n1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；\n2) 从一棵植株跳到前后左右与之相邻的另一棵植株；\n3) 采摘一棵植株下的花生；\n4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。\n\n现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。\n\n例如，在图 2 所示的花生田里，只有位于 $(2, 5), (3, 7), (4, 2), (5, 4)$ 的植株下长有花生，个数分别为 $13, 7, 15, 9$。沿着图示的路线，多多在 $21$ 个单位时间内，最多可以采到 $37$ 个花生。\n\n**注意：在采摘过程中不能回到路边。**", "inputFormat": "第一行包括三个整数 $M,N,K$，其间以空格隔开，表示花生田的大小为 $M  \\times N$，多多采花生的限定时间为 $K$ 个单位时间。\n\n接下来的 $M$ 行，每行包括 $N$ 个非负整数，也用空格隔开。第 $i + 1$ 行的第 $j$ 个整数 $P_{i,j}$ 表示花生田中植株 $(i, j)$ 下花生的数目，$0$ 表示该植株下没有花生。", "outputFormat": "一个整数，即在限定时间内，多多最多可以采到花生的个数。", "hint": "noip2004普及组第2题\n\n对于 $100\\%$ 的数据，$1  \\le M, N  \\le 20,0  \\le K  \\le  1000,0  \\le P_{i,j}  \\le 500$。", "locale": "zh-CN"}}}
{"pid": "P1087", "type": "P", "difficulty": 2, "samples": [["3\n10001011\n", "IBFBBBFIBFIIIFF\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "搜索", "树形数据结构", "2004", "递归", "NOIP 普及组", "构造"], "title": "[NOIP 2004 普及组] FBI 树", "background": "", "description": "我们可以把由 0 和 1 组成的字符串分为三类：全 0 串称为 B 串，全 1 串称为 I 串，既含 0 又含 1 的串则称为 F 串。\n\nFBI 树是一种二叉树，它的结点类型也包括 F 结点，B 结点和 I 结点三种。由一个长度为 $2^N$ 的 01 串 $S$ 可以构造出一棵 FBI 树 $T$，递归的构造方法如下：\n\n1. $T$ 的根结点为 $R$，其类型与串 $S$ 的类型相同；\n2. 若串 $S$ 的长度大于 $1$，将串 $S$ 从中间分开，分为等长的左右子串 $S_1$ 和 $S_2$；由左子串 $S_1$ 构造 $R$ 的左子树 $T_1$，由右子串 $S_2$ 构造 $R$ 的右子树 $T_2$。\n\n现在给定一个长度为 $2^N$ 的 01 串，请用上述构造方法构造出一棵 FBI 树，并输出它的后序遍历序列。\n", "inputFormat": "第一行是一个整数 $N(0 \\le N \\le 10)$，  \n\n第二行是一个长度为 $2^N$ 的 01 串。\n", "outputFormat": "一个字符串，即 FBI 树的后序遍历序列。\n", "hint": "对于 $40\\%$ 的数据，$N \\le 2$；\n\n对于全部的数据，$N \\le 10$。\n\n\nnoip2004普及组第3题\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2004 Junior] FBI Tree", "background": null, "description": "We can divide strings composed of 0 and 1 into three categories: an all-0 string is called a B string, an all-1 string is called an I string, and a string that contains both 0 and 1 is called an F string.\n\nAn FBI tree is a binary tree whose node types are F, B, and I. Given a binary string $S$ of length $2^N$, an FBI tree $T$ can be constructed recursively as follows:\n1. Let $R$ be the root of $T$, and set its type to be the same as the type of $S$.\n2. If the length of $S$ is greater than 1, split $S$ in the middle into equal-length left and right substrings $S_1$ and $S_2$. Construct the left subtree $T_1$ of $R$ from $S_1$, and the right subtree $T_2$ of $R$ from $S_2$.\n\nGiven a binary string of length $2^N$, construct an FBI tree using the method above and output its postorder traversal sequence.", "inputFormat": "The first line contains an integer $N (0 \\le N \\le 10)$.  \nThe second line contains a binary string of length $2^N$.", "outputFormat": "A single string, i.e., the postorder traversal sequence of the FBI tree.", "hint": "For 40% of the testdata, $N \\le 2$.  \nFor all the testdata, $N \\le 10$.  \nThis is the 3rd problem of NOIP 2004 Junior.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2004 普及组] FBI 树", "background": "", "description": "我们可以把由 0 和 1 组成的字符串分为三类：全 0 串称为 B 串，全 1 串称为 I 串，既含 0 又含 1 的串则称为 F 串。\n\nFBI 树是一种二叉树，它的结点类型也包括 F 结点，B 结点和 I 结点三种。由一个长度为 $2^N$ 的 01 串 $S$ 可以构造出一棵 FBI 树 $T$，递归的构造方法如下：\n\n1. $T$ 的根结点为 $R$，其类型与串 $S$ 的类型相同；\n2. 若串 $S$ 的长度大于 $1$，将串 $S$ 从中间分开，分为等长的左右子串 $S_1$ 和 $S_2$；由左子串 $S_1$ 构造 $R$ 的左子树 $T_1$，由右子串 $S_2$ 构造 $R$ 的右子树 $T_2$。\n\n现在给定一个长度为 $2^N$ 的 01 串，请用上述构造方法构造出一棵 FBI 树，并输出它的后序遍历序列。\n", "inputFormat": "第一行是一个整数 $N(0 \\le N \\le 10)$，  \n\n第二行是一个长度为 $2^N$ 的 01 串。\n", "outputFormat": "一个字符串，即 FBI 树的后序遍历序列。\n", "hint": "对于 $40\\%$ 的数据，$N \\le 2$；\n\n对于全部的数据，$N \\le 10$。\n\n\nnoip2004普及组第3题\n", "locale": "zh-CN"}}}
{"pid": "P1088", "type": "P", "difficulty": 2, "samples": [["5\n3\n1 2 3 4 5\n", "1 2 4 5 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "数学", "2004", "NOIP 普及组", "排序"], "title": "[NOIP 2004 普及组] 火星人", "background": null, "description": "人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回答。\n\n火星人用一种非常简单的方式来表示数字――掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为 $1,2,3,\\cdots$。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。\n\n一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指――拇指、食指、中指、无名指和小指分别编号为 $1,2,3,4$ 和 $5$，当它们按正常顺序排列时，形成了 $5$ 位数 $12345$，当你交换无名指和小指的位置时，会形成 $5$ 位数 $12354$，当你把五个手指的顺序完全颠倒时，会形成 $54321$，在所有能够形成的 $120$ 个 $5$ 位数中，$12345$ 最小，它表示 $1$；$12354$ 第二小，它表示 $2$；$54321$ 最大，它表示 $120$。下表展示了只有 $3$ 根手指时能够形成的 $6$ 个 $3$ 位数和它们代表的数字：\n\n\n| 三位数 | 代表的数字 |\n|:-:|:-:|\n| $123$ | $1$ |\n| $132$ | $2$ |\n| $213$ | $3$ |\n| $231$ | $4$ |\n| $312$ | $5$ |\n| $321$ | $6$ |\n\n现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。", "inputFormat": "共三行。  \n第一行一个正整数 $N$，表示火星人手指的数目（$1 \\le N \\le 10000$）。  \n第二行是一个正整数 $M$，表示要加上去的小整数（$1  \\le  M  \\le  100$）。  \n下一行是 $1$ 到 $N$ 这 $N$ 个整数的一个排列，用空格隔开，表示火星人手指的排列顺序。", "outputFormat": "$N$ 个整数，表示改变后的火星人手指的排列顺序。每两个相邻的数中间用一个空格分开，不能有多余的空格。", "hint": "对于 $30\\%$ 的数据，$N \\le 15$。\n\n对于 $60\\%$ 的数据，$N \\le 50$。\n\n对于 $100\\%$ 的数据，$N \\le 10000$。\n\nnoip2004 普及组第 4 题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2004 Junior] Martians", "background": null, "description": "Humans have finally set foot on Mars and met the mysterious Martians. Humans and Martians cannot understand each other's language, but our scientists invented a way to communicate using numbers. The method is as follows: first, the Martian tells the human scientist a very large number. After deciphering its meaning, the scientist adds a very small number to it and tells the result to the Martian as the human's reply.\n\nMartians represent numbers in a very simple way—by bending their fingers. A Martian has only one hand, but this hand has thousands upon thousands of fingers arranged in a line, numbered $1,2,3,\\cdots$. Any two fingers can be swapped arbitrarily, and this is how they count.\n\nA Martian demonstrated finger counting using a human hand. If the five fingers—thumb, index, middle, ring, and little finger—are numbered $1,2,3,4$ and $5$, then when they are in normal order, they form the $5$-digit number $12345$. If you swap the ring and little finger, you get $12354$. If you completely reverse the order of the five fingers, you get $54321$. Among all $120$ possible $5$-digit numbers that can be formed, $12345$ is the smallest and represents $1$; $12354$ is the second smallest and represents $2$; $54321$ is the largest and represents $120$. The table below shows the $6$ possible $3$-digit numbers when there are only $3$ fingers, and the numbers they represent:\n\n| Three-digit number | Represented number |\n|:-:|:-:|\n| $123$ | $1$ |\n| $132$ | $2$ |\n| $213$ | $3$ |\n| $231$ | $4$ |\n| $312$ | $5$ |\n| $321$ | $6$ |\n\nNow you have the honor of being the first human to communicate with a Martian. A Martian will show you his fingers, and the scientists will tell you a small number to add. Your task is to add the number represented by the Martian’s fingers to the number given by the scientists, and then rearrange the Martian’s fingers according to the result. The input guarantees that the result will not exceed the range representable by the Martian’s fingers.", "inputFormat": "There are three lines.  \nThe first line contains a positive integer $N$, the number of the Martian’s fingers ($1 \\le N \\le 10000$).  \nThe second line contains a positive integer $M$, the small integer to add ($1 \\le M \\le 100$).  \nThe third line contains a permutation of the $N$ integers from $1$ to $N$, separated by spaces, representing the order of the Martian’s fingers.", "outputFormat": "Output $N$ integers, the new order of the Martian’s fingers after the change. Separate adjacent numbers with a single space, and do not print extra spaces.", "hint": "For $30\\%$ of the testdata, $N \\le 15$.  \nFor $60\\%$ of the testdata, $N \\le 50$.  \nFor $100\\%$ of the testdata, $N \\le 10000$.\n\nNOIP 2004 Junior Problem 4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2004 普及组] 火星人", "background": null, "description": "人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回答。\n\n火星人用一种非常简单的方式来表示数字――掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为 $1,2,3,\\cdots$。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。\n\n一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指――拇指、食指、中指、无名指和小指分别编号为 $1,2,3,4$ 和 $5$，当它们按正常顺序排列时，形成了 $5$ 位数 $12345$，当你交换无名指和小指的位置时，会形成 $5$ 位数 $12354$，当你把五个手指的顺序完全颠倒时，会形成 $54321$，在所有能够形成的 $120$ 个 $5$ 位数中，$12345$ 最小，它表示 $1$；$12354$ 第二小，它表示 $2$；$54321$ 最大，它表示 $120$。下表展示了只有 $3$ 根手指时能够形成的 $6$ 个 $3$ 位数和它们代表的数字：\n\n\n| 三位数 | 代表的数字 |\n|:-:|:-:|\n| $123$ | $1$ |\n| $132$ | $2$ |\n| $213$ | $3$ |\n| $231$ | $4$ |\n| $312$ | $5$ |\n| $321$ | $6$ |\n\n现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。", "inputFormat": "共三行。  \n第一行一个正整数 $N$，表示火星人手指的数目（$1 \\le N \\le 10000$）。  \n第二行是一个正整数 $M$，表示要加上去的小整数（$1  \\le  M  \\le  100$）。  \n下一行是 $1$ 到 $N$ 这 $N$ 个整数的一个排列，用空格隔开，表示火星人手指的排列顺序。", "outputFormat": "$N$ 个整数，表示改变后的火星人手指的排列顺序。每两个相邻的数中间用一个空格分开，不能有多余的空格。", "hint": "对于 $30\\%$ 的数据，$N \\le 15$。\n\n对于 $60\\%$ 的数据，$N \\le 50$。\n\n对于 $100\\%$ 的数据，$N \\le 10000$。\n\nnoip2004 普及组第 4 题", "locale": "zh-CN"}}}
{"pid": "P1089", "type": "P", "difficulty": 1, "samples": [["290\n230\n280\n200\n300\n170\n340\n50 \n90 \n80 \n200\n60 \n", "-7 \n"], ["290 \n230 \n280 \n200 \n300 \n170 \n330 \n50 \n90 \n80 \n200 \n60 \n", "1580\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2004", "NOIP 提高组", "枚举"], "title": "[NOIP 2004 提高组] 津津的储蓄计划", "background": "", "description": "津津的零花钱一直都是自己管理。每个月的月初妈妈给津津 $300$ 元钱，津津会预算这个月的花销，并且总能做到实际花销和预算的相同。\n\n为了让津津学习如何储蓄，妈妈提出，津津可以随时把整百的钱存在她那里，到了年末她会加上 $20\\%$ 还给津津。因此津津制定了一个储蓄计划：每个月的月初，在得到妈妈给的零花钱后，如果她预计到这个月的月末手中还会有多于 $100$ 元或恰好 $100$ 元，她就会把整百的钱存在妈妈那里，剩余的钱留在自己手中。\n\n\n例如 $11$月初津津手中还有 $83$ 元，妈妈给了津津 $300$ 元。津津预计$11$月的花销是 $180$ 元，那么她就会在妈妈那里存 $200$ 元，自己留下 $183$ 元。到了 $11$ 月月末，津津手中会剩下 $3$ 元钱。\n\n\n津津发现这个储蓄计划的主要风险是，存在妈妈那里的钱在年末之前不能取出。有可能在某个月的月初，津津手中的钱加上这个月妈妈给的钱，不够这个月的原定预算。如果出现这种情况，津津将不得不在这个月省吃俭用，压缩预算。\n\n\n现在请你根据 $2004$ 年 $1$ 月到 $12$ 月每个月津津的预算，判断会不会出现这种情况。如果不会，计算到 $2004$ 年年末，妈妈将津津平常存的钱加上 $20\\%$ 还给津津之后，津津手中会有多少钱。\n", "inputFormat": "$12$ 行数据，每行包含一个小于 $350$ 的非负整数，分别表示 $1$ 月到 $12$ 月津津的预算。\n", "outputFormat": "一个整数。如果储蓄计划实施过程中出现某个月钱不够用的情况，输出 $-X$，$X$ 表示出现这种情况的第一个月；否则输出到 $2004$ 年年末津津手中会有多少钱。\n\n注意，洛谷不需要进行文件输入输出，而是标准输入输出。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2004 Senior] Jinjin's Savings Plan", "background": null, "description": "Jinjin manages her pocket money by herself. At the beginning of each month, mom gives Jinjin $300$ yuan. Jinjin makes a budget for that month’s expenses, and she always keeps the actual expenses equal to the budget.\n\nTo teach Jinjin how to save, mom proposes that Jinjin may deposit any whole hundreds with her at any time, and at year end she will add $20\\%$ and return it to Jinjin. Therefore, Jinjin makes a savings plan: at the beginning of each month, after receiving the pocket money from mom, if she expects that by the end of this month she will have at least $100$ yuan left on hand, she will deposit all the full hundreds with mom, keeping the remainder herself.\n\nFor example, at the beginning of month $11$, Jinjin still has $83$ yuan on hand, and mom gives $300$ yuan. Jinjin plans to spend $180$ yuan in month $11$, so she deposits $200$ yuan with mom and keeps $183$ yuan. By the end of month $11$, Jinjin will have $3$ yuan left.\n\nJinjin finds that the main risk of this savings plan is that the money deposited with mom cannot be withdrawn before year end. It may happen that at the beginning of some month, the money Jinjin has on hand plus this month’s money from mom is not enough for that month’s original budget. If this happens, Jinjin will have to scrimp that month and cut the budget.\n\nNow, given Jinjin’s monthly budgets from January to December of year $2004$, determine whether such a situation occurs. If not, compute how much money Jinjin will have on hand at the end of year $2004$, after mom returns the deposited money plus $20\\%$ to Jinjin.", "inputFormat": "$12$ lines of data, each containing a non-negative integer less than $350$, representing the budgets for months $1$ through $12$.", "outputFormat": "A single integer. If, during the implementation of the savings plan, there is a month when the money is not enough, output $-X$, where $X$ is the first such month; otherwise, output how much money Jinjin will have on hand at the end of year $2004$.\n\nNote that on Luogu you should use standard input and output, not file I/O.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2004 提高组] 津津的储蓄计划", "background": "", "description": "津津的零花钱一直都是自己管理。每个月的月初妈妈给津津 $300$ 元钱，津津会预算这个月的花销，并且总能做到实际花销和预算的相同。\n\n为了让津津学习如何储蓄，妈妈提出，津津可以随时把整百的钱存在她那里，到了年末她会加上 $20\\%$ 还给津津。因此津津制定了一个储蓄计划：每个月的月初，在得到妈妈给的零花钱后，如果她预计到这个月的月末手中还会有多于 $100$ 元或恰好 $100$ 元，她就会把整百的钱存在妈妈那里，剩余的钱留在自己手中。\n\n\n例如 $11$月初津津手中还有 $83$ 元，妈妈给了津津 $300$ 元。津津预计$11$月的花销是 $180$ 元，那么她就会在妈妈那里存 $200$ 元，自己留下 $183$ 元。到了 $11$ 月月末，津津手中会剩下 $3$ 元钱。\n\n\n津津发现这个储蓄计划的主要风险是，存在妈妈那里的钱在年末之前不能取出。有可能在某个月的月初，津津手中的钱加上这个月妈妈给的钱，不够这个月的原定预算。如果出现这种情况，津津将不得不在这个月省吃俭用，压缩预算。\n\n\n现在请你根据 $2004$ 年 $1$ 月到 $12$ 月每个月津津的预算，判断会不会出现这种情况。如果不会，计算到 $2004$ 年年末，妈妈将津津平常存的钱加上 $20\\%$ 还给津津之后，津津手中会有多少钱。\n", "inputFormat": "$12$ 行数据，每行包含一个小于 $350$ 的非负整数，分别表示 $1$ 月到 $12$ 月津津的预算。\n", "outputFormat": "一个整数。如果储蓄计划实施过程中出现某个月钱不够用的情况，输出 $-X$，$X$ 表示出现这种情况的第一个月；否则输出到 $2004$ 年年末津津手中会有多少钱。\n\n注意，洛谷不需要进行文件输入输出，而是标准输入输出。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1090", "type": "P", "difficulty": 3, "samples": [["3 \n1 2 9 \n", "15\n"]], "limits": {"time": [800, 800, 800, 800, 800, 800, 800, 800, 800, 800], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2004", "堆", "NOIP 提高组", "优先队列"], "title": "[NOIP 2004 提高组] 合并果子", "background": "[P6033](https://www.luogu.com.cn/problem/P6033) 为本题加强版。", "description": "在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。\n\n每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $n-1$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。\n\n因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。\n\n例如有 $3$ 种果子，数目依次为 $1$，$2$，$9$。可以先将 $1$、$2$ 堆合并，新堆数目为 $3$，耗费体力为 $3$ 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$，耗费体力为 $12$。所以多多总共耗费体力 $=3+12=15$。可以证明 $15$ 为最小的体力耗费值。", "inputFormat": "共两行。  \n\n第一行是一个整数 $n(1\\leq n\\leq 10^4)$，表示果子的种类数。  \n\n第二行包含 $n$ 个整数，用空格分隔，第 $i$ 个整数 $a_i(1\\leq a_i\\leq 2\\times 10^4)$ 是第 $i$ 种果子的数目。", "outputFormat": "一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 $2^{31}$。", "hint": "对于 $30\\%$ 的数据，保证有 $n \\le 10^3$；\n\n对于 $50\\%$ 的数据，保证有 $n \\le 5\\times10^3$；\n\n对于全部的数据，保证有 $n \\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2004 Senior] Merging Fruits", "background": null, "description": "In an orchard, Duoduo has already knocked down all the fruits and separated them into different piles by type. Duoduo decides to merge all the fruits into a single pile.\n\nIn each merge, Duoduo can combine two piles of fruits, and the effort spent equals the sum of the weights of the two piles. It is clear that after $n-1$ merges, there will be only one pile left. The total effort spent by Duoduo when merging the fruits equals the sum of the efforts of each merge.\n\nBecause it also takes a lot of effort to carry these fruits home, Duoduo wants to save as much effort as possible when merging. Assume each fruit has weight $1$, and you are given the number of types of fruits and the count of each type. Your task is to design a merging order that minimizes the total effort and output this minimum effort.\n\nFor example, there are $3$ types of fruits, with counts $1$, $2$, and $9$. You can first merge the $1$ and $2$ piles to get a new pile of $3$, costing $3$ effort. Then merge this new pile with the original third pile to get a new pile of $12$, costing $12$ effort. So the total effort equals $=3+12=15$. It can be proven that $15$ is the minimum total effort.", "inputFormat": "Two lines.\nThe first line is an integer $n(1\\leq n\\leq 10000)$, representing the number of fruit types.\nThe second line contains $n$ integers separated by spaces. The $i$-th integer $a_i(1\\leq a_i\\leq 20000)$ is the number of fruits of type $i$.", "outputFormat": "A single integer, which is the minimum total effort. The input guarantees that this value is less than $2^{31}$.", "hint": "Constraints:\n- For $30\\%$ of the testdata, $n \\le 1000$.\n- For $50\\%$ of the testdata, $n \\le 5000$.\n- For all testdata, $n \\le 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2004 提高组] 合并果子", "background": "[P6033](https://www.luogu.com.cn/problem/P6033) 为本题加强版。", "description": "在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。\n\n每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $n-1$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。\n\n因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。\n\n例如有 $3$ 种果子，数目依次为 $1$，$2$，$9$。可以先将 $1$、$2$ 堆合并，新堆数目为 $3$，耗费体力为 $3$ 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$，耗费体力为 $12$。所以多多总共耗费体力 $=3+12=15$。可以证明 $15$ 为最小的体力耗费值。", "inputFormat": "共两行。  \n\n第一行是一个整数 $n(1\\leq n\\leq 10^4)$，表示果子的种类数。  \n\n第二行包含 $n$ 个整数，用空格分隔，第 $i$ 个整数 $a_i(1\\leq a_i\\leq 2\\times 10^4)$ 是第 $i$ 种果子的数目。", "outputFormat": "一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 $2^{31}$。", "hint": "对于 $30\\%$ 的数据，保证有 $n \\le 10^3$；\n\n对于 $50\\%$ 的数据，保证有 $n \\le 5\\times10^3$；\n\n对于全部的数据，保证有 $n \\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P1091", "type": "P", "difficulty": 2, "samples": [["8\n186 186 150 200 160 130 197 220\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2004", "单调队列", "NOIP 提高组", "线性 DP"], "title": "[NOIP 2004 提高组] 合唱队形", "background": "", "description": "$n$ 位同学站成一排，音乐老师要请其中的 $n-k$ 位同学出列，使得剩下的 $k$ 位同学排成合唱队形。\n\n合唱队形是指这样的一种队形：设 $k$ 位同学从左到右依次编号为 $1,2,$ … $,k$，他们的身高分别为 $t_1,t_2,$ … $,t_k$，则他们的身高满足 $t_1< \\cdots <t_i>t_{i+1}>$ … $>t_k(1\\le i\\le k)$。\n\n你的任务是，已知所有 $n$ 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。", "inputFormat": "共二行。\n\n第一行是一个整数 $n$（$2\\le n\\le100$），表示同学的总数。\n\n第二行有 $n$ 个整数，用空格分隔，第 $i$ 个整数 $t_i$（$130\\le t_i\\le230$）是第 $i$ 位同学的身高（厘米）。", "outputFormat": "一个整数，最少需要几位同学出列。\n", "hint": "对于 $50\\%$ 的数据，保证有 $n \\le 20$。\n\n对于全部的数据，保证有 $n \\le 100$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2004 Senior] Chorus Formation", "background": null, "description": "$n$ students stand in a row. The music teacher will ask $n - k$ students to step out so that the remaining $k$ students form a \"chorus formation.\"\n\nA chorus formation is defined as follows: suppose the $k$ remaining students are numbered from left to right as $1, 2, \\ldots, k$, and their heights are $t_1, t_2, \\ldots, t_k$. They satisfy $t_1 < \\cdots < t_i > t_{i+1} > \\cdots > t_k \\ (1 \\le i \\le k)$.\n\nYour task is: given the heights of all $n$ students, compute the minimum number of students that must be removed so that the remaining students form a chorus formation.", "inputFormat": "Two lines.\n\n- The first line contains an integer $n$ ($2 \\le n \\le 100$), the total number of students.\n- The second line contains $n$ integers separated by spaces. The $i$-th integer $t_i$ ($130 \\le t_i \\le 230$) is the height (in centimeters) of the $i$-th student.", "outputFormat": "Output a single integer: the minimum number of students who must be removed.", "hint": "For 50% of the testdata, it is guaranteed that $n \\le 20$.\n\nFor all the testdata, it is guaranteed that $n \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2004 提高组] 合唱队形", "background": "", "description": "$n$ 位同学站成一排，音乐老师要请其中的 $n-k$ 位同学出列，使得剩下的 $k$ 位同学排成合唱队形。\n\n合唱队形是指这样的一种队形：设 $k$ 位同学从左到右依次编号为 $1,2,$ … $,k$，他们的身高分别为 $t_1,t_2,$ … $,t_k$，则他们的身高满足 $t_1< \\cdots <t_i>t_{i+1}>$ … $>t_k(1\\le i\\le k)$。\n\n你的任务是，已知所有 $n$ 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。", "inputFormat": "共二行。\n\n第一行是一个整数 $n$（$2\\le n\\le100$），表示同学的总数。\n\n第二行有 $n$ 个整数，用空格分隔，第 $i$ 个整数 $t_i$（$130\\le t_i\\le230$）是第 $i$ 位同学的身高（厘米）。", "outputFormat": "一个整数，最少需要几位同学出列。\n", "hint": "对于 $50\\%$ 的数据，保证有 $n \\le 20$。\n\n对于全部的数据，保证有 $n \\le 100$。\n", "locale": "zh-CN"}}}
{"pid": "P1092", "type": "P", "difficulty": 5, "samples": [["5\nABCED\nBDACE\nEBBAA\n", "1 0 3 4 2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2004", "NOIP 提高组", "深度优先搜索 DFS", "剪枝", "高斯消元"], "title": "[NOIP 2004 提高组] 虫食算", "background": "", "description": "所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的数字。来看一个简单的例子：\n\n$$\\begin{aligned}\n \\verb!43#9865#045! \\\\\n+\\qquad \\verb!8468#6633! \\\\[-1em]\\underline{\\kern{8em}} \\\\\n \\verb!44445509678! \\\\\n\\end{aligned}$$\n\n其中 `#` 号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是 $5$ 和 $3$，第二行的数字是 $5$。\n\n现在，我们对问题做两个限制：\n\n首先，我们只考虑加法的虫食算。这里的加法是 $n$ 进制加法，算式中三个数都有 $n$ 位，允许有前导的 $0$。\n\n其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是 $n$ 进制的，我们就取英文字母表的前 $n$ 个大写字母来表示这个算式中的 $0$ 到 $n - 1$ 这 $n$ 个不同的数字：但是这 $n$ 个字母并不一定顺序地代表 $0$ 到 $n-1$。输入数据保证 $n$ 个字母分别至少出现一次。\n\n$$\\begin{aligned}\n \\verb!BADC! \\\\\n+\\quad \\verb!CBDA! \\\\[-1em]\\underline{\\kern{4em}} \\\\\n \\verb!DCCC! \\\\\n\\end{aligned}$$\n\n上面的算式是一个4进制的算式。很显然，我们只要让 $\\verb!ABCD!$ 分别代表 $0123$，便可以让这个式子成立了。你的任务是，对于给定的 $n$ 进制加法算式，求出 $n$ 个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。\n", "inputFormat": "输入的第一行是一个整数 $n$，代表进制数。\n\n第二到第四行，每行有一个由大写字母组成的字符串，分别代表两个加数以及和。这 $3$ 个字符串左右两端都没有空格，从左到右依次代表从高位到低位，并且恰好有 $n$ 位。\n", "outputFormat": "输出一行 $n$ 个用空格隔开的整数，分别代表 $A,B, \\dots$ 代表的数字。\n", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\le 10$；\n- 对于 $50\\%$ 的数据，保证 $n \\le 15$；\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 26$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2004 Senior] Cryptarithm", "background": null, "description": "A cryptarithm is an arithmetic expression where some digits have been “eaten by worms,” and we must determine the missing digits from the remaining ones. Consider a simple example:\n\n$$\\begin{aligned}\n \\verb!43#9865#045! \\\\\n+\\qquad \\verb!8468#6633! \\\\[-1em]\\underline{\\kern{8em}} \\\\\n \\verb!44445509678! \\\\\n\\end{aligned}$$\n\nHere, the character `#` denotes a missing digit. From the equation, it is easy to see that the two missing digits in the first line are 5 and 3 respectively, and the missing digit in the second line is 5.\n\nNow we add two constraints to the problem:\n\nFirst, we only consider addition cryptarithms. The addition is in base $n$. The three numbers in the expression each have $n$ digits, and leading zeros are allowed.\n\nSecond, all digits have been replaced by letters. We only know which digits are equal; equal digits are represented by the same letter, and different digits by different letters. If the addition is in base $n$, we use the first $n$ uppercase letters of the English alphabet to denote the $n$ distinct digits $0$ to $n - 1$; however, these $n$ letters do not necessarily represent $0$ to $n - 1$ in order. The input guarantees that each of the $n$ letters appears at least once.\n\n$$\\begin{aligned}\n \\verb!BADC! \\\\\n+\\quad \\verb!CBDA! \\\\[-1em]\\underline{\\kern{4em}} \\\\\n \\verb!DCCC! \\\\\n\\end{aligned}$$\n\nThe above is a base-4 equation. Clearly, if we let $\\verb!ABCD!$ represent 0123 respectively, the equation holds. Your task is: given a base-$n$ addition cryptarithm, determine which digits the $n$ different letters represent so that the addition holds. The input guarantees there is exactly one solution.", "inputFormat": "- The first line contains an integer $n$, the base.\n- The second to fourth lines each contain a string of uppercase letters, representing the two addends and the sum, respectively. These 3 strings have no spaces at either end, represent digits from high to low, and each has exactly $n$ characters.", "outputFormat": "Output one line with $n$ integers separated by spaces, representing the digits corresponding to $A, B, \\dots$ in order.", "hint": "Constraints:\n- For 30% of the testdata, $n \\le 10$.\n- For 50% of the testdata, $n \\le 15$.\n- For 100% of the testdata, $1 \\le n \\le 26$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2004 提高组] 虫食算", "background": "", "description": "所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的数字。来看一个简单的例子：\n\n$$\\begin{aligned}\n \\verb!43#9865#045! \\\\\n+\\qquad \\verb!8468#6633! \\\\[-1em]\\underline{\\kern{8em}} \\\\\n \\verb!44445509678! \\\\\n\\end{aligned}$$\n\n其中 `#` 号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是 $5$ 和 $3$，第二行的数字是 $5$。\n\n现在，我们对问题做两个限制：\n\n首先，我们只考虑加法的虫食算。这里的加法是 $n$ 进制加法，算式中三个数都有 $n$ 位，允许有前导的 $0$。\n\n其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是 $n$ 进制的，我们就取英文字母表的前 $n$ 个大写字母来表示这个算式中的 $0$ 到 $n - 1$ 这 $n$ 个不同的数字：但是这 $n$ 个字母并不一定顺序地代表 $0$ 到 $n-1$。输入数据保证 $n$ 个字母分别至少出现一次。\n\n$$\\begin{aligned}\n \\verb!BADC! \\\\\n+\\quad \\verb!CBDA! \\\\[-1em]\\underline{\\kern{4em}} \\\\\n \\verb!DCCC! \\\\\n\\end{aligned}$$\n\n上面的算式是一个4进制的算式。很显然，我们只要让 $\\verb!ABCD!$ 分别代表 $0123$，便可以让这个式子成立了。你的任务是，对于给定的 $n$ 进制加法算式，求出 $n$ 个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。\n", "inputFormat": "输入的第一行是一个整数 $n$，代表进制数。\n\n第二到第四行，每行有一个由大写字母组成的字符串，分别代表两个加数以及和。这 $3$ 个字符串左右两端都没有空格，从左到右依次代表从高位到低位，并且恰好有 $n$ 位。\n", "outputFormat": "输出一行 $n$ 个用空格隔开的整数，分别代表 $A,B, \\dots$ 代表的数字。\n", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\le 10$；\n- 对于 $50\\%$ 的数据，保证 $n \\le 15$；\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 26$。", "locale": "zh-CN"}}}
{"pid": "P1093", "type": "P", "difficulty": 2, "samples": [["6\n90 67 80\n87 66 91\n78 89 91\n88 99 77\n67 89 64\n78 89 98\n", "6 265\n4 264\n3 258\n2 244\n1 237"], ["8\n80 89 89\n88 98 78\n90 67 80\n87 66 91\n78 89 91\n88 99 77\n67 89 64\n78 89 98", "8 265\n2 264\n6 264\n1 258\n5 258"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "数学", "2007", "NOIP 普及组", "排序"], "title": "[NOIP 2007 普及组] 奖学金", "background": "NOIP2007 普及组 T1", "description": "某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前 $5$ 名学生发奖学金。期末，每个学生都有 $3$ 门课的成绩：语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学排在前面，这样，每个学生的排序是唯一确定的。\n\n任务：先根据输入的 $3$ 门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名名学生的学号和总分。\n\n注意，在前 $5$ 名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据（每行输出两个数：学号、总分) 是：\n\n```plain\n7 279  \n5 279\n```\n\n这两行数据的含义是：总分最高的两个同学的学号依次是 $7$ 号、$5$ 号。这两名同学的总分都是 $279$ (总分等于输入的语文、数学、英语三科成绩之和) ，但学号为 $7$ 的学生语文成绩更高一些。\n\n如果你的前两名的输出数据是：\n\n```plain\n5 279  \n7 279\n```\n\n则按输出错误处理，不能得分。", "inputFormat": "共 $n+1$ 行。\n\n第 $1$ 行为一个正整数 $5\\le n \\le 300$，表示该校参加评选的学生人数。\n\n第 $2$ 到 $n+1$ 行，每行有 $3$ 个用空格隔开的数字，每个数字都在 $0$ 到 $100$ 之间。第 $j$ 行的 $3$ 个数字依次表示学号为 $j-1$ 的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为 $1\\sim n$（恰好是输入数据的行号减 $1$）。\n\n保证所给的数据都是正确的，不必检验。", "outputFormat": "共 $5$ 行，每行是两个用空格隔开的正整数，依次表示前 $5$ 名学生的学号和总分。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2007 Junior] Scholarship", "background": null, "description": "An elementary school recently received sponsorship and plans to award scholarships to the top $5$ students with the best academic performance. At the end of the term, each student has scores in $3$ subjects: Chinese, Mathematics, and English. First, sort by total score in descending order. If two students have the same total score, sort by Chinese score in descending order. If both the total score and the Chinese score are the same, the student with the smaller student ID comes first. In this way, each student's ranking is uniquely determined.\n\nTask: First compute the total score from the $3$ subject scores in the input, then sort according to the rules above, and finally output the student IDs and total scores of the top five students in rank order.\n\nNote that among the top $5$ students, each person's scholarship is different, so you must strictly follow the rules above for sorting. For example, in a correct answer, if the first two lines of output data (each line outputs two numbers: student ID and total score) are:\n\n```plain\n7 279  \n5 279\n```\n\nthese two lines mean that the student IDs of the two students with the highest total scores are $7$ and $5$ in order. Both students have a total score of $279$ (the total score equals the sum of the scores in Chinese, Mathematics, and English), but the student with ID $7$ has a higher Chinese score.\n\nIf your first two lines of output are:\n\n```plain\n5 279  \n7 279\n```\n\nthen it will be judged as wrong output and you will receive no score.", "inputFormat": "There are $n+1$ lines.\n\n- The first line contains a positive integer $n \\le 300$, representing the number of students participating in the selection.\n- Lines $2$ to $n+1$ each contain $3$ space-separated integers, each between $0$ and $100$ inclusive. On line $j$, the $3$ integers are the scores of the student with ID $j-1$ in this order: Chinese, Mathematics, English. Each student's ID is numbered from $1$ to $n$ according to the input order (exactly the line number minus $1$).\n\nThe given testdata are guaranteed to be valid; no need to validate.", "outputFormat": "Output $5$ lines. Each line contains two space-separated positive integers, representing the student ID and the total score of the top $5$ students, in order.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2007 普及组] 奖学金", "background": "NOIP2007 普及组 T1", "description": "某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前 $5$ 名学生发奖学金。期末，每个学生都有 $3$ 门课的成绩：语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学排在前面，这样，每个学生的排序是唯一确定的。\n\n任务：先根据输入的 $3$ 门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名名学生的学号和总分。\n\n注意，在前 $5$ 名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据（每行输出两个数：学号、总分) 是：\n\n```plain\n7 279  \n5 279\n```\n\n这两行数据的含义是：总分最高的两个同学的学号依次是 $7$ 号、$5$ 号。这两名同学的总分都是 $279$ (总分等于输入的语文、数学、英语三科成绩之和) ，但学号为 $7$ 的学生语文成绩更高一些。\n\n如果你的前两名的输出数据是：\n\n```plain\n5 279  \n7 279\n```\n\n则按输出错误处理，不能得分。", "inputFormat": "共 $n+1$ 行。\n\n第 $1$ 行为一个正整数 $5\\le n \\le 300$，表示该校参加评选的学生人数。\n\n第 $2$ 到 $n+1$ 行，每行有 $3$ 个用空格隔开的数字，每个数字都在 $0$ 到 $100$ 之间。第 $j$ 行的 $3$ 个数字依次表示学号为 $j-1$ 的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为 $1\\sim n$（恰好是输入数据的行号减 $1$）。\n\n保证所给的数据都是正确的，不必检验。", "outputFormat": "共 $5$ 行，每行是两个用空格隔开的正整数，依次表示前 $5$ 名学生的学号和总分。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1094", "type": "P", "difficulty": 2, "samples": [["100 \n9 \n90 \n20 \n20 \n30 \n50 \n60 \n70 \n80 \n90\n", "6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2007", "NOIP 普及组", "排序", "双指针 two-pointer"], "title": "[NOIP 2007 普及组] 纪念品分组", "background": "NOIP2007 普及组 T2", "description": "元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得的纪念品价值相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品，并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时间内发完所有纪念品，乐乐希望分组的数目最少。\n\n你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。", "inputFormat": "共 $n+2$ 行：\n\n第一行包括一个整数 $w$，为每组纪念品价格之和的上限。\n\n第二行为一个整数 $n$，表示购来的纪念品的总件数 $G$。\n\n第 $3\\sim n+2$ 行每行包含一个正整数 $P_i$ 表示所对应纪念品的价格。", "outputFormat": "一个整数，即最少的分组数目。", "hint": "$50\\%$ 的数据满足：$1\\le n\\le15$。\n\n$100\\%$ 的数据满足：$1\\le n\\le3\\times10^4$，$80\\le w\\le200$，$5 \\le  P_i  \\le  w$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2007 Junior] Souvenir Grouping", "background": null, "description": "New Year’s Day is coming, and the student council has tasked Lele with distributing souvenirs at the New Year’s party. To keep the value of souvenirs received by participants relatively balanced, he wants to group the purchased souvenirs by price. Each group can contain at most two souvenirs, and the sum of prices in a group cannot exceed a given integer $w$. To finish the distribution as quickly as possible, Lele wants to minimize the number of groups.\n\nYour task is to write a program that finds a grouping scheme with the minimal number of groups and outputs that minimal number.", "inputFormat": "A total of $n+2$ lines:\n\n- The first line contains an integer $w$, the upper bound on the sum of prices in each group.\n- The second line contains an integer $n$, the total number of souvenirs.\n- Lines 3 to $n+2$: each line contains a positive integer $P_i$ representing the price of the corresponding souvenir.", "outputFormat": "A single integer: the minimal number of groups.", "hint": "Constraints:\n- $50\\%$ of the testdata: $1 \\le n \\le 15$.\n- $100\\%$ of the testdata: $1 \\le n \\le 3\\times 10^4$, $80 \\le w \\le 200$, $5 \\le P_i \\le w$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2007 普及组] 纪念品分组", "background": "NOIP2007 普及组 T2", "description": "元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得的纪念品价值相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品，并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时间内发完所有纪念品，乐乐希望分组的数目最少。\n\n你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。", "inputFormat": "共 $n+2$ 行：\n\n第一行包括一个整数 $w$，为每组纪念品价格之和的上限。\n\n第二行为一个整数 $n$，表示购来的纪念品的总件数 $G$。\n\n第 $3\\sim n+2$ 行每行包含一个正整数 $P_i$ 表示所对应纪念品的价格。", "outputFormat": "一个整数，即最少的分组数目。", "hint": "$50\\%$ 的数据满足：$1\\le n\\le15$。\n\n$100\\%$ 的数据满足：$1\\le n\\le3\\times10^4$，$80\\le w\\le200$，$5 \\le  P_i  \\le  w$。", "locale": "zh-CN"}}}
{"pid": "P1095", "type": "P", "difficulty": 3, "samples": [["39 200 4\n", "No\n197\n"], ["36 255 10", "Yes\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "动态规划 DP", "贪心", "2007", "NOIP 普及组"], "title": "[NOIP 2007 普及组] 守望者的逃离", "background": "NOIP2007 普及组 T3", "description": "恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。\n\n守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。\n\n为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。\n\n守望者的跑步速度为 $17\\text{m/s}$，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在 $1\\text{s}$ 内移动 $60\\text{m}$，不过每次使用闪烁法术都会消耗魔法值 $10$ 点。守望者的魔法值恢复的速度为 $4$ 点每秒，只有处在原地休息状态时才能恢复。\n\n现在已知守望者的魔法初值 $M$，他所在的初始位置与岛的出口之间的距离 $S$，岛沉没的时间 $T$。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。\n\n注意：守望者跑步、闪烁或休息活动均以秒为单位，且每次活动的持续时间为整数秒。距离的单位为米。", "inputFormat": "输入数据共一行三个非负整数，分别表示 $M$，$S$，$T$。", "outputFormat": "输出数据共两行。\n\n第一行一个字符串 $\\texttt{Yes}$ 或 $\\texttt{No}$，即守望者是否能逃离荒岛。\n\n第二行包含一个整数。第一行为 $\\texttt{Yes}$ 时表示守望者逃离荒岛的最短时间；第一行为 $\\texttt{No}$ 时表示守望者能走的最远距离。", "hint": "对于 $30\\%$ 的数据，$1  \\le  T   \\le  10$，$ 1   \\le   S   \\le  100$；\n\n对于 $50\\%$ 的数据，$1   \\le  T   \\le   10^3$，$ 1   \\le  S  \\le   10^4$；\n\n对于 $100\\%$ 的数据，$1   \\le   T   \\le   3\\times  10^5$，$0   \\le   M   \\le   10^3$，$ 1   \\le  S   \\le   10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2007 Junior] The Warden's Escape", "background": null, "description": "The ambitious demon hunter Youdian (pinyin) betrayed the Night Elves and led the Naga hidden in the depths of the sea in an attempted rebellion.\n\nIn a confrontation with Youdian, the Warden fell into an ambush and was trapped on a desolate island.\n\nTo kill the Warden, Youdian cast a spell on the island, which would soon sink. By then, everyone on the island would perish.\n\nThe Warden’s running speed is $17\\text{m/s}$, which is not enough to escape the island. Fortunately, the Warden has the “Blink” spell, which moves $60\\text{m}$ in $1\\text{s}$, but each use consumes $10$ mana points. The Warden’s mana regenerates at $4$ points per second, and only while standing still to rest.\n\nYou are given the Warden’s initial mana $M$, the distance $S$ from the starting position to the island’s exit, and the time $T$ before the island sinks. Your task is to write a program to help the Warden compute how to escape the island in the shortest time. If escape is impossible, output the farthest distance the Warden can travel within the remaining time.\n\nNote: Running, blinking, and resting are measured in seconds, and each action lasts an integer number of seconds. Distances are measured in meters.", "inputFormat": "A single line containing three non-negative integers, denoting $M$, $S$, $T$.", "outputFormat": "Output two lines.\n\nThe first line contains a string $\\texttt{Yes}$ or $\\texttt{No}$, indicating whether the Warden can escape the island.\n\nThe second line contains an integer. If the first line is $\\texttt{Yes}$, it represents the minimum time for the Warden to escape. If the first line is $\\texttt{No}$, it represents the farthest distance the Warden can travel.", "hint": "For $30\\%$ of the testdata, $1 \\le T \\le 10$, $1 \\le S \\le 100$.\n\nFor $50\\%$ of the testdata, $1 \\le T \\le 10^3$, $1 \\le S \\le 10^4$.\n\nFor $100\\%$ of the testdata, $1 \\le T \\le 3\\times 10^5$, $0 \\le M \\le 10^3$, $1 \\le S \\le 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2007 普及组] 守望者的逃离", "background": "NOIP2007 普及组 T3", "description": "恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。\n\n守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。\n\n为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。\n\n守望者的跑步速度为 $17\\text{m/s}$，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在 $1\\text{s}$ 内移动 $60\\text{m}$，不过每次使用闪烁法术都会消耗魔法值 $10$ 点。守望者的魔法值恢复的速度为 $4$ 点每秒，只有处在原地休息状态时才能恢复。\n\n现在已知守望者的魔法初值 $M$，他所在的初始位置与岛的出口之间的距离 $S$，岛沉没的时间 $T$。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。\n\n注意：守望者跑步、闪烁或休息活动均以秒为单位，且每次活动的持续时间为整数秒。距离的单位为米。", "inputFormat": "输入数据共一行三个非负整数，分别表示 $M$，$S$，$T$。", "outputFormat": "输出数据共两行。\n\n第一行一个字符串 $\\texttt{Yes}$ 或 $\\texttt{No}$，即守望者是否能逃离荒岛。\n\n第二行包含一个整数。第一行为 $\\texttt{Yes}$ 时表示守望者逃离荒岛的最短时间；第一行为 $\\texttt{No}$ 时表示守望者能走的最远距离。", "hint": "对于 $30\\%$ 的数据，$1  \\le  T   \\le  10$，$ 1   \\le   S   \\le  100$；\n\n对于 $50\\%$ 的数据，$1   \\le  T   \\le   10^3$，$ 1   \\le  S  \\le   10^4$；\n\n对于 $100\\%$ 的数据，$1   \\le   T   \\le   3\\times  10^5$，$0   \\le   M   \\le   10^3$，$ 1   \\le  S   \\le   10^8$。", "locale": "zh-CN"}}}
{"pid": "P1096", "type": "P", "difficulty": 3, "samples": [["1", "2"], ["2", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "高精度", "递推", "2007", "递归", "NOIP 普及组"], "title": "[NOIP 2007 普及组] Hanoi 双塔问题", "background": "", "description": "给定 A、B、C 三根足够长的细柱，在 A 柱上放有 $2n$ 个中间有孔的圆盘，共有 $n$ 个不同的尺寸，每个尺寸都有两个相同的圆盘，注意这两个圆盘是不加区分的（下图为 $n=3$ 的情形）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mq2iklbv.png)\n\n现要将这些圆盘移到 C 柱上，在移动过程中可放在 B 柱上暂存。要求：\n\n1. 每次只能移动一个圆盘；\n2. A、B、C 三根细柱上的圆盘都要保持上小下大的顺序。\n\n任务：设 $A_n$ 为 $2n$ 个圆盘完成上述任务所需的最少移动次数，对于输入的 $n$，输出 $A_n$。\n\n", "inputFormat": "一个正整数 $n$，表示在 A 柱上放有 $2n$ 个圆盘。\n", "outputFormat": "一个正整数, 为完成上述任务所需的最少移动次数 $A_n$。\n", "hint": "**限制**\n\n- 对于 $50\\%$ 的数据，$1  \\le  n  \\le  25$；\n- 对于 $100\\%$ 的数据，$1  \\le  n  \\le  200$。\n\n**提示**\n\n设法建立 $A_n$ 与 $A_{n-1}$ 的递推关系式。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2007 Junior] Hanoi Double Tower Problem", "background": null, "description": "Given three sufficiently long thin pegs A, B, and C, there are $2n$ disks with holes on peg A. There are $n$ distinct sizes, and for each size there are two identical disks; note that these two disks are indistinguishable (the figure below shows the case $n=3$).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mq2iklbv.png)\n\nWe need to move all these disks to peg C, and disks may be temporarily placed on peg B during the process. Requirements:\n1. Only one disk may be moved at a time.\n2. On pegs A, B, and C, the disks must always keep the order of smaller on top and larger below.\n\nTask: Let $A_n$ be the minimum number of moves required to complete the task for $2n$ disks. For the given $n$, output $A_n$.", "inputFormat": "A positive integer $n$, indicating there are $2n$ disks on peg A.", "outputFormat": "A positive integer, which is the minimum number of moves $A_n$ required to complete the task.", "hint": "Constraints\n\n- 对于 $50\\%$ 的数据，$1  \\le  n  \\le  25$；\n- 对于 $100\\%$ 的数据，$1  \\le  n  \\le  200$。\n\nHint\n\nTry to establish a recurrence relation between $A_n$ and $A_{n-1}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2007 普及组] Hanoi 双塔问题", "background": "", "description": "给定 A、B、C 三根足够长的细柱，在 A 柱上放有 $2n$ 个中间有孔的圆盘，共有 $n$ 个不同的尺寸，每个尺寸都有两个相同的圆盘，注意这两个圆盘是不加区分的（下图为 $n=3$ 的情形）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mq2iklbv.png)\n\n现要将这些圆盘移到 C 柱上，在移动过程中可放在 B 柱上暂存。要求：\n\n1. 每次只能移动一个圆盘；\n2. A、B、C 三根细柱上的圆盘都要保持上小下大的顺序。\n\n任务：设 $A_n$ 为 $2n$ 个圆盘完成上述任务所需的最少移动次数，对于输入的 $n$，输出 $A_n$。\n\n", "inputFormat": "一个正整数 $n$，表示在 A 柱上放有 $2n$ 个圆盘。\n", "outputFormat": "一个正整数, 为完成上述任务所需的最少移动次数 $A_n$。\n", "hint": "**限制**\n\n- 对于 $50\\%$ 的数据，$1  \\le  n  \\le  25$；\n- 对于 $100\\%$ 的数据，$1  \\le  n  \\le  200$。\n\n**提示**\n\n设法建立 $A_n$ 与 $A_{n-1}$ 的递推关系式。\n", "locale": "zh-CN"}}}
{"pid": "P1097", "type": "P", "difficulty": 2, "samples": [["8\n2\n4\n2\n4\n5\n100\n2\n100", "2 3\n4 2\n5 1\n100 2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2007", "NOIP 提高组", "排序"], "title": "[NOIP 2007 提高组] 统计数字", "background": "", "description": "某次科研调查时得到了 $n$ 个自然数，每个数均不超过 $1.5 \\times 10^9$。已知不相同的数不超过 $10^4$ 个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。\n", "inputFormat": "共 $n+1$ 行。\n\n第一行是整数 $n$，表示自然数的个数；\n\n第 $2$ 至 $n+1$ 每行一个自然数。\n", "outputFormat": "共 $m$ 行（$m$ 为 $n$ 个自然数中不相同数的个数），按照自然数从小到大的顺序输出。  \n\n每行输出 $2$ 个整数，分别是自然数和该数出现的次数，其间用一个空格隔开。\n", "hint": "- $30\\%$ 的数据满足：$1  \\le  n  \\le  1000$；\n- $60\\%$ 的数据满足：$1  \\le  n  \\le  50000$；\n- $100\\%$ 的数据满足：$1  \\le  n  \\le  200000$，每个数均不超过 $1.5 \\times 10^9$。\n\nNOIP 2007 提高第一题\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2007 Senior] Counting Numbers", "background": null, "description": "In a research survey, $n$ natural numbers were collected, each not exceeding $1.5 \\times 10^9$. It is known that the number of distinct values does not exceed $10^4$. Now you need to count how many times each natural number appears and output the results in ascending order of the numbers.", "inputFormat": "There are $n+1$ lines in total.\n\n- The first line contains an integer $n$, the number of natural numbers.\n- Lines $2$ to $n+1$ each contain one natural number.", "outputFormat": "Output $m$ lines in total (where $m$ is the number of distinct numbers among the $n$ natural numbers), in ascending order of the numbers.\n\nEach line outputs $2$ integers: the natural number and the number of times it appears, separated by a single space.", "hint": "- 30% of the testdata satisfy: $1 \\le n \\le 1000$.\n- 60% of the testdata satisfy: $1 \\le n \\le 50000$.\n- 100% of the testdata satisfy: $1 \\le n \\le 200000$, and each number does not exceed $1.5 \\times 10^9$.\n\nNOIP 2007 Senior, Problem 1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2007 提高组] 统计数字", "background": "", "description": "某次科研调查时得到了 $n$ 个自然数，每个数均不超过 $1.5 \\times 10^9$。已知不相同的数不超过 $10^4$ 个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。\n", "inputFormat": "共 $n+1$ 行。\n\n第一行是整数 $n$，表示自然数的个数；\n\n第 $2$ 至 $n+1$ 每行一个自然数。\n", "outputFormat": "共 $m$ 行（$m$ 为 $n$ 个自然数中不相同数的个数），按照自然数从小到大的顺序输出。  \n\n每行输出 $2$ 个整数，分别是自然数和该数出现的次数，其间用一个空格隔开。\n", "hint": "- $30\\%$ 的数据满足：$1  \\le  n  \\le  1000$；\n- $60\\%$ 的数据满足：$1  \\le  n  \\le  50000$；\n- $100\\%$ 的数据满足：$1  \\le  n  \\le  200000$，每个数均不超过 $1.5 \\times 10^9$。\n\nNOIP 2007 提高第一题\n", "locale": "zh-CN"}}}
{"pid": "P1098", "type": "P", "difficulty": 2, "samples": [["1 2 1\nabcs-w1234-9s-4zz", "abcsttuuvvw1234556677889s-4zz"], ["2 3 2\na-d-d", "aCCCBBBd-d"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "2007", "NOIP 提高组"], "title": "[NOIP 2007 提高组] 字符串的展开", "background": null, "description": "在初赛普及组的“阅读程序写结果”的问题中，我们曾给出一个字符串展开的例子：如果在输入的字符串中，含有类似于 `d-h` 或者 `4-8` 的字串，我们就把它当作一种简写，输出时，用连续递增的字母或数字串替代其中的减号，即，将上面两个子串分别输出为 `defgh` 和 `45678`。在本题中，我们通过增加一些参数的设置，使字符串的展开更为灵活。具体约定如下：\n\n1. 遇到下面的情况需要做字符串的展开。在输入的字符串中，出现了减号 `-`，减号两侧同为小写字母或同为数字，且按照 ASCII 码的顺序，减号右边的字符严格大于左边的字符。\n\n2. 参数 $p_1$：展开方式。$p_1=1$ 时，对于字母子串，填充小写字母；$p_1=2$ 时，对于字母子串，填充大写字母。这两种情况下数字子串的填充方式相同；$p_1=3$ 时，不论是字母子串还是数字字串，都用与要填充的字母个数相同的星号 `*` 来填充。\n\n3. 参数 $p_2$：填充字符的重复个数。$p_2=k$ 表示同一个字符要连续填充 $k$ 个。例如，当 $p_2=3$ 时，子串`d-h` 应扩展为 `deeefffgggh`。减号两边的字符不变。\n\n4. 参数 $p_3$：是否改为逆序。$p_3=1$ 表示维持原来顺序；$p_3=2$ 表示采用逆序输出。注意这时候仍然不包括减号两端的字符。例如，当 $p_1=1$、$p_2=2$、$p_3=2$ 时，子串 `d-h` 应扩展为 `dggffeeh`。\n\n5. 如果减号右边的字符恰好是左边字符的后继，只删除中间的减号。例如：`d-e` 应输出为 `de`，`3-4` 应输出为 `34`。如果减号右边的字符按照 ASCII 码的顺序小于或等于左边字符，输出时，要保留中间的减号。例如：`d-d` 应输出为 `d-d`，`3-1` 应输出为 `3-1`。", "inputFormat": "共两行。\n\n第 $1$ 行为用空格隔开的 $3$ 个正整数，依次表示参数 $p_1,p_2,p_3$。\n\n第 $2$ 行为一行字符串，仅由数字、小写字母和减号 `-` 组成。行首和行末均无空格。", "outputFormat": "共一行，为展开后的字符串。", "hint": "$40\\%$ 的数据满足：字符串长度不超过 $5$。\n\n$100\\%$ 的数据满足：$1  \\le  p_1  \\le  3$，$1  \\le  p_2  \\le  8$，$1  \\le  p_3  \\le  2$，字符串长度不超过 $100$。\n\nNOIP 2007 提高组第二题。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2007 Senior] String Expansion", "background": null, "description": "In the preliminary round’s Junior “read the program and write the result” problem, we once gave an example of string expansion: if the input string contains substrings like `d-h` or `4-8`, we treat them as shorthand. In the output, we replace the hyphen with a sequence of consecutively increasing letters or digits; that is, the two substrings above are output as `defgh` and `45678`. In this problem, we add parameters to make the expansion more flexible. The conventions are as follows:\n\n(1) Perform string expansion when the following condition is met: in the input string, there is a hyphen `-`, the characters on both sides are both lowercase letters or both digits, and according to `ASCII` order, the character on the right of the hyphen is strictly greater than the character on the left.\n\n(2) Parameter $p_1$: expansion mode. When $p_1=1$, for letter substrings, fill with lowercase letters; when $p_1=2$, for letter substrings, fill with uppercase letters. In both of these cases, the filling method for digit substrings is the same. When $p_1=3$, regardless of whether it is a letter substring or a digit substring, fill with asterisks `*`, using the same number of asterisks as the number of characters that would be filled.\n\n(3) Parameter $p_2$: the repetition count of each filling character. $p_2=k$ means the same character is repeated $k$ times consecutively. For example, when $p_2=3$, the substring `d-h` should expand to `deeefffgggh`. The characters on both sides of the hyphen remain unchanged.\n\n(4) Parameter $p_3$: whether to reverse the order. $p_3=1$ means keep the original order; $p_3=2$ means output in reverse order. Note that in this case the two endpoint characters are still excluded. For example, when $p_1=1$, $p_2=2$, $p_3=2$, the substring `d-h` should expand to `dggffeeh`.\n\n(5) If the character on the right of the hyphen is exactly the successor of the left character, delete only the hyphen; for example, `d-e` should be output as `de`, and `3-4` should be output as `34`. If, according to `ASCII` order, the character on the right of the hyphen is less than or equal to the left character, keep the hyphen in the output; for example, `d-d` should be output as `d-d`, and `3-1` should be output as `3-1`.", "inputFormat": "Two lines.\n\nLine $1$: three positive integers separated by spaces, representing $p_1, p_2, p_3$.\n\nLine $2$: one string consisting only of digits, lowercase letters, and hyphens `-`. There are no leading or trailing spaces.", "outputFormat": "One line, the expanded string.", "hint": "$40\\%$ of the testdata satisfy: the string length does not exceed $5$.\n\n$100\\%$ of the testdata satisfy: $1 \\le p_1 \\le 3$, $1 \\le p_2 \\le 8$, $1 \\le p_3 \\le 2$. The string length does not exceed $100$.\n\nNOIP 2007 Senior Problem 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2007 提高组] 字符串的展开", "background": null, "description": "在初赛普及组的“阅读程序写结果”的问题中，我们曾给出一个字符串展开的例子：如果在输入的字符串中，含有类似于 `d-h` 或者 `4-8` 的字串，我们就把它当作一种简写，输出时，用连续递增的字母或数字串替代其中的减号，即，将上面两个子串分别输出为 `defgh` 和 `45678`。在本题中，我们通过增加一些参数的设置，使字符串的展开更为灵活。具体约定如下：\n\n1. 遇到下面的情况需要做字符串的展开。在输入的字符串中，出现了减号 `-`，减号两侧同为小写字母或同为数字，且按照 ASCII 码的顺序，减号右边的字符严格大于左边的字符。\n\n2. 参数 $p_1$：展开方式。$p_1=1$ 时，对于字母子串，填充小写字母；$p_1=2$ 时，对于字母子串，填充大写字母。这两种情况下数字子串的填充方式相同；$p_1=3$ 时，不论是字母子串还是数字字串，都用与要填充的字母个数相同的星号 `*` 来填充。\n\n3. 参数 $p_2$：填充字符的重复个数。$p_2=k$ 表示同一个字符要连续填充 $k$ 个。例如，当 $p_2=3$ 时，子串`d-h` 应扩展为 `deeefffgggh`。减号两边的字符不变。\n\n4. 参数 $p_3$：是否改为逆序。$p_3=1$ 表示维持原来顺序；$p_3=2$ 表示采用逆序输出。注意这时候仍然不包括减号两端的字符。例如，当 $p_1=1$、$p_2=2$、$p_3=2$ 时，子串 `d-h` 应扩展为 `dggffeeh`。\n\n5. 如果减号右边的字符恰好是左边字符的后继，只删除中间的减号。例如：`d-e` 应输出为 `de`，`3-4` 应输出为 `34`。如果减号右边的字符按照 ASCII 码的顺序小于或等于左边字符，输出时，要保留中间的减号。例如：`d-d` 应输出为 `d-d`，`3-1` 应输出为 `3-1`。", "inputFormat": "共两行。\n\n第 $1$ 行为用空格隔开的 $3$ 个正整数，依次表示参数 $p_1,p_2,p_3$。\n\n第 $2$ 行为一行字符串，仅由数字、小写字母和减号 `-` 组成。行首和行末均无空格。", "outputFormat": "共一行，为展开后的字符串。", "hint": "$40\\%$ 的数据满足：字符串长度不超过 $5$。\n\n$100\\%$ 的数据满足：$1  \\le  p_1  \\le  3$，$1  \\le  p_2  \\le  8$，$1  \\le  p_3  \\le  2$，字符串长度不超过 $100$。\n\nNOIP 2007 提高组第二题。", "locale": "zh-CN"}}}
{"pid": "P1099", "type": "P", "difficulty": 4, "samples": [["5 2\n1 2 5\n2 3 2\n2 4 4\n2 5 3\n", "5\n"], ["8 6\n1 3 2\n2 3 2 \n3 4 6\n4 5 3\n4 6 4\n4 7 2\n7 8 3\n", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "动态规划 DP", "树形数据结构", "2007", "单调队列", "NOIP 提高组", "枚举", "最短路", "树的直径", "双指针 two-pointer"], "title": "[NOIP 2007 提高组] 树网的核", "background": null, "description": "设 $T=(V,E,W)$ 是一个无圈且连通的无向图（也称为无根树），每条边都有正整数的权，我们称 $T$ 为树网（`treenetwork`），其中 $V$，$E$ 分别表示结点与边的集合，$W$ 表示各边长度的集合，并设 $T$ 有 $n$ 个结点。\n\n路径：树网中任何两结点 $a$，$b$ 都存在唯一的一条简单路径，用 $d(a, b)$ 表示以 $a, b$ 为端点的路径的长度，它是该路径上各边长度之和。我们称 \n$d(a, b)$ 为 $a, b$ 两结点间的距离。\n\n$D(v, P)=\\min\\{d(v, u)\\}$, $u$ 为路径 $P$ 上的结点。\n\n树网的直径：树网中最长的路径称为树网的直径。对于给定的树网 $T$，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。\n\n偏心距 $\\mathrm{ECC}(F)$：树网 $T$ 中距路径 $F$ 最远的结点到路径 $F$ 的距离，即\n\n$$\\mathrm{ECC}(F)=\\max\\{D(v, F),v \\in V\\}$$\n\n任务：对于给定的树网 $T=(V, E, W)$ 和非负整数 $s$，求一个路径 $F$，他是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过 $s$（可以等于 $s$），使偏心距 $\\mathrm{ECC}(F)$ 最小。我们称这个路径为树网 $T=(V, E, W)$ 的核（`Core`）。必要时，$F$ 可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。\n\n下面的图给出了树网的一个实例。图中，$A-B$ 与 $A-C$ 是两条直径，长度均为 $20$。点 $W$ 是树网的中心，$EF$ 边的长度为 $5$。如果指定 $s=11$，则树网的核为路径`DEFG`（也可以取为路径`DEF`），偏心距为 $8$。如果指定 $s=0$（或 $s=1$、$s=2$），则树网的核为结点 $F$，偏心距为 $12$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oms5c6rq.png)", "inputFormat": "共 $n$ 行。\n\n第 $1$ 行，两个正整数 $n$ 和 $s$，中间用一个空格隔开。其中 $n$ 为树网结点的个数，$s$ 为树网的核的长度的上界。设结点编号以此为 $1,2\\dots,n$。\n\n从第 $2$ 行到第 $n$ 行，每行给出 $3$ 个用空格隔开的正整数 $u, v, w$，依次表示每一条边的两个端点编号和长度。例如，`2 4 7` 表示连接结点 $2$ 与 $4$ 的边的长度为 $7$。", "outputFormat": "一个非负整数，为指定意义下的最小偏心距。", "hint": "- 对于 $40\\%$ 的数据，保证 $n \\le 15$。\n- 对于 $70\\%$ 的数据，保证 $n \\le 80$。\n- 对于 $100\\%$ 的数据，保证 $2\\le n \\le 300$，$0\\le s\\le10^3$，$1 \\leq u, v \\leq n$，$0 \\leq w \\leq 10^3$。\n\nNOIP2007 提高组第四题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2007 Senior] Core of the Treenetwork", "background": null, "description": "Let $T=(V, E, W)$ be a connected undirected graph without cycles (also called an unrooted tree), where each edge has a nonnegative integer weight. We call $T$ a \"treenetwork\". Here $V$ and $E$ denote the sets of nodes and edges, respectively, $W$ denotes the set of edge lengths, and $T$ has $n$ nodes.\n\nPath: In a treenetwork, there is a unique simple path between any two nodes $a$ and $b$. Let $d(a, b)$ denote the length of the path whose endpoints are $a$ and $b$, i.e., the sum of the lengths of the edges on that path. We call $d(a, b)$ the distance between nodes $a$ and $b$.\n\n$D(v, P)=\\min\\{d(v, u)\\}$, where $u$ ranges over the nodes on path $P$.\n\nDiameter of a treenetwork: The longest path in a treenetwork is called its diameter. For a given treenetwork $T$, the diameter is not necessarily unique, but it can be proved that the midpoint of any diameter (which may lie in the interior of an edge rather than exactly at a node) is unique; we call this point the center of the treenetwork.\n\nEccentricity $\\mathrm{ECC}(F)$: The distance from the farthest node in $T$ to path $F$, namely\n$$\\mathrm{ECC}(F)=\\max\\{D(v, F), v \\in V\\}.$$\n\nTask: Given a treenetwork $T=(V, E, W)$ and a nonnegative integer $s$, find a path $F$ which is a subpath on some diameter (the endpoints of this path are both nodes in the treenetwork), whose length does not exceed $s$ (it may equal $s$), such that the eccentricity $\\mathrm{ECC}(F)$ is minimized. We call such a path the \"Core\" of treenetwork $T=(V, E, W)$. If necessary, $F$ may degenerate into a single node. In general, under the above definition, the core is not necessarily unique, but the minimal eccentricity is unique.\n\nThe following figure gives an example of a treenetwork. In the figure, $A\\!-\\!B$ and $A\\!-\\!C$ are two diameters, both of length $20$. Point $W$ is the center of the treenetwork, and the length of edge $EF$ is $5$. If $s=11$ is specified, then the core of the treenetwork is path DEFG (it can also be taken as path DEF), and the eccentricity is $8$. If $s=0$ (or $s=1$, $s=2$), then the core of the treenetwork is node $F$, and the eccentricity is $12$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oms5c6rq.png)", "inputFormat": "There are $n$ lines in total.\n\nLine $1$: two positive integers $n$ and $s$, separated by a single space. Here $n$ is the number of nodes in the treenetwork, and $s$ is the upper bound on the length of the core. The nodes are numbered $1, 2, \\dots, n$.\n\nLines $2$ through $n$: each line contains three space-separated integers $u, v, w$, indicating an edge between nodes $u$ and $v$ with length $w$. For example, `2 4 7` means the edge connecting nodes $2$ and $4$ has length $7$.", "outputFormat": "Output a single nonnegative integer: the minimal eccentricity under the given definition.", "hint": "- For $40\\%$ of the testdata, it is guaranteed that $n \\le 15$.\n- For $70\\%$ of the testdata, it is guaranteed that $n \\le 80$.\n- For $100\\%$ of the testdata, it is guaranteed that $2 \\le n \\le 300$, $0 \\le s \\le 10^3$, $1 \\le u, v \\le n$, $0 \\le w \\le 10^3$.\n\nNOIP 2007 Senior Problem 4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2007 提高组] 树网的核", "background": null, "description": "设 $T=(V,E,W)$ 是一个无圈且连通的无向图（也称为无根树），每条边都有正整数的权，我们称 $T$ 为树网（`treenetwork`），其中 $V$，$E$ 分别表示结点与边的集合，$W$ 表示各边长度的集合，并设 $T$ 有 $n$ 个结点。\n\n路径：树网中任何两结点 $a$，$b$ 都存在唯一的一条简单路径，用 $d(a, b)$ 表示以 $a, b$ 为端点的路径的长度，它是该路径上各边长度之和。我们称 \n$d(a, b)$ 为 $a, b$ 两结点间的距离。\n\n$D(v, P)=\\min\\{d(v, u)\\}$, $u$ 为路径 $P$ 上的结点。\n\n树网的直径：树网中最长的路径称为树网的直径。对于给定的树网 $T$，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。\n\n偏心距 $\\mathrm{ECC}(F)$：树网 $T$ 中距路径 $F$ 最远的结点到路径 $F$ 的距离，即\n\n$$\\mathrm{ECC}(F)=\\max\\{D(v, F),v \\in V\\}$$\n\n任务：对于给定的树网 $T=(V, E, W)$ 和非负整数 $s$，求一个路径 $F$，他是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过 $s$（可以等于 $s$），使偏心距 $\\mathrm{ECC}(F)$ 最小。我们称这个路径为树网 $T=(V, E, W)$ 的核（`Core`）。必要时，$F$ 可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。\n\n下面的图给出了树网的一个实例。图中，$A-B$ 与 $A-C$ 是两条直径，长度均为 $20$。点 $W$ 是树网的中心，$EF$ 边的长度为 $5$。如果指定 $s=11$，则树网的核为路径`DEFG`（也可以取为路径`DEF`），偏心距为 $8$。如果指定 $s=0$（或 $s=1$、$s=2$），则树网的核为结点 $F$，偏心距为 $12$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oms5c6rq.png)", "inputFormat": "共 $n$ 行。\n\n第 $1$ 行，两个正整数 $n$ 和 $s$，中间用一个空格隔开。其中 $n$ 为树网结点的个数，$s$ 为树网的核的长度的上界。设结点编号以此为 $1,2\\dots,n$。\n\n从第 $2$ 行到第 $n$ 行，每行给出 $3$ 个用空格隔开的正整数 $u, v, w$，依次表示每一条边的两个端点编号和长度。例如，`2 4 7` 表示连接结点 $2$ 与 $4$ 的边的长度为 $7$。", "outputFormat": "一个非负整数，为指定意义下的最小偏心距。", "hint": "- 对于 $40\\%$ 的数据，保证 $n \\le 15$。\n- 对于 $70\\%$ 的数据，保证 $n \\le 80$。\n- 对于 $100\\%$ 的数据，保证 $2\\le n \\le 300$，$0\\le s\\le10^3$，$1 \\leq u, v \\leq n$，$0 \\leq w \\leq 10^3$。\n\nNOIP2007 提高组第四题", "locale": "zh-CN"}}}
{"pid": "P1100", "type": "P", "difficulty": 2, "samples": [["1314520\n", "249036820\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "数学", "进制", "位运算"], "title": "高低位交换", "background": null, "description": "给出一个小于 $2^{32}$ 的非负整数。这个数可以用一个 $32$ 位的二进制数表示（不足 $32$ 位用 $0$ 补足）。我们称这个二进制数的前 $16$ 位为“高位”，后 $16$ 位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。\n\n例如，数 $1314520$ 用二进制表示为 $0000\\,0000\\,0001\\,0100\\,0000\\,1110\\,1101\\,1000$（添加了 $11$ 个前导 $0$ 补足为 $32$ 位），其中前 $16$ 位为高位，即 $0000\\,0000\\,0001\\,0100$；后 $16$ 位为低位，即 $0000\\,1110\\,1101\\,1000$。将它的高低位进行交换，我们得到了一个新的二进制数 $0000\\,1110\\,1101\\,1000\\,0000\\,0000\\,0001\\,0100$。它即是十进制的 $249036820$。", "inputFormat": "一个小于 $2^{32}$ 的非负整数。", "outputFormat": "将新的数输出。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Swap High and Low Bits", "background": null, "description": "You are given a non-negative integer less than $2^{32}$. This number can be represented as a 32-bit binary number (pad with leading zeros if it has fewer than 32 bits). We call the first 16 bits the high 16 bits, and the last 16 bits the low 16 bits. Swap its high and low 16 bits to obtain a new number. What is this new number (in decimal)?\n\nFor example, the number $1314520$ is represented in binary as $0000\\,0000\\,0001\\,0100\\,0000\\,1110\\,1101\\,1000$ (with $11$ leading zeros added to make it 32 bits), where the high 16 bits are $0000\\,0000\\,0001\\,0100$, and the low 16 bits are $0000\\,1110\\,1101\\,1000$. After swapping the high and low bits, we get a new binary number $0000\\,1110\\,1101\\,1000\\,0000\\,0000\\,0001\\,0100$. This is $249036820$ in decimal.", "inputFormat": "A non-negative integer less than $2^{32}$.", "outputFormat": "Output the new number.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "高低位交换", "background": null, "description": "给出一个小于 $2^{32}$ 的非负整数。这个数可以用一个 $32$ 位的二进制数表示（不足 $32$ 位用 $0$ 补足）。我们称这个二进制数的前 $16$ 位为“高位”，后 $16$ 位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。\n\n例如，数 $1314520$ 用二进制表示为 $0000\\,0000\\,0001\\,0100\\,0000\\,1110\\,1101\\,1000$（添加了 $11$ 个前导 $0$ 补足为 $32$ 位），其中前 $16$ 位为高位，即 $0000\\,0000\\,0001\\,0100$；后 $16$ 位为低位，即 $0000\\,1110\\,1101\\,1000$。将它的高低位进行交换，我们得到了一个新的二进制数 $0000\\,1110\\,1101\\,1000\\,0000\\,0000\\,0001\\,0100$。它即是十进制的 $249036820$。", "inputFormat": "一个小于 $2^{32}$ 的非负整数。", "outputFormat": "将新的数输出。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1101", "type": "P", "difficulty": 2, "samples": [["7\naaaaaaa\naaaaaaa\naaaaaaa\naaaaaaa\naaaaaaa\naaaaaaa\naaaaaaa\n", "*******\n*******\n*******\n*******\n*******\n*******\n*******\n"], ["8\nqyizhong\ngydthkjy\nnwidghji\norbzsfgz\nhhgrhwth\nzzzzzozo\niwdfrgng\nyyyygggg", "*yizhong\ngy******\nn*i*****\no**z****\nh***h***\nz****o**\ni*****n*\ny******g"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "搜索"], "title": "单词方阵", "background": "", "description": "给一 $n \\times n$ 的字母方阵，内可能蕴含多个 `yizhong` 单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 $8$ 个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉，因此有可能共用字母。输出时，将不是单词的字母用 `*` 代替，以突出显示单词。", "inputFormat": "第一行输入一个数 $n$。$(7 \\le n \\le 100)$。\n\n第二行开始输入 $n \\times n$ 的字母矩阵。\n", "outputFormat": "突出显示单词的 $n \\times n$ 矩阵。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Word Grid", "background": null, "description": "Given an $n \\times n$ letter grid, there may be multiple occurrences of the word `yizhong`. Each word is placed contiguously along a single direction. Placement can be along any of the $8$ directions, and the direction does not change within the same word. Different words may cross and share letters. In the output, replace letters that are not part of any occurrence of the word with `*` to highlight the words.", "inputFormat": "- The first line contains an integer $n$ ($7 \\le n \\le 100$).\n- Starting from the second line, input the $n \\times n$ letter matrix.", "outputFormat": "Output the $n \\times n$ matrix where letters not belonging to any `yizhong` are replaced by `*`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "单词方阵", "background": "", "description": "给一 $n \\times n$ 的字母方阵，内可能蕴含多个 `yizhong` 单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 $8$ 个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉，因此有可能共用字母。输出时，将不是单词的字母用 `*` 代替，以突出显示单词。", "inputFormat": "第一行输入一个数 $n$。$(7 \\le n \\le 100)$。\n\n第二行开始输入 $n \\times n$ 的字母矩阵。\n", "outputFormat": "突出显示单词的 $n \\times n$ 矩阵。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1102", "type": "P", "difficulty": 2, "samples": [["4 1\n1 1 2 3\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "数学", "二分", "排序", "哈希 hashing", "双指针 two-pointer", "STL"], "title": "A-B 数对", "background": "出题是一件痛苦的事情！\n\n相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！", "description": "给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。", "inputFormat": "输入共两行。\n\n第一行，两个正整数 $N,C$。\n\n第二行，$N$ 个正整数，作为要求处理的那串数。", "outputFormat": "一行，表示该串正整数中包含的满足 $A - B = C$ 的数对的个数。", "hint": "对于 $75\\%$ 的数据，$1 \\leq N \\leq 2000$。\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 2 \\times 10^5$，$0 \\leq a_i <2^{30}$，$1 \\leq C < 2^{30}$。\n\n2017/4/29 新添数据两组", "locale": "zh-CN", "translations": {"en": {"title": "A - B Pairs", "background": null, "description": "Given a sequence of positive integers and a positive integer $C$, compute the number of pairs $(A, B)$ such that $A - B = C$. Pairs with the same values at different positions are considered distinct.", "inputFormat": "The input consists of two lines.\n\nThe first line contains two positive integers $N, C$.\n\nThe second line contains $N$ positive integers, which form the sequence to be processed.", "outputFormat": "Output one line containing the number of pairs in the sequence that satisfy $A - B = C$.", "hint": "Constraints:\n\n- For $75\\%$ of the testdata, $1 \\leq N \\leq 2000$.\n- For $100\\%$ of the testdata, $1 \\leq N \\leq 2 \\times 10^5$, $0 \\leq a_i < 2^{30}$, $1 \\leq C < 2^{30}$.\n\nTwo new testdata sets were added on 2017/4/29.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "A-B 数对", "background": "出题是一件痛苦的事情！\n\n相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！", "description": "给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。", "inputFormat": "输入共两行。\n\n第一行，两个正整数 $N,C$。\n\n第二行，$N$ 个正整数，作为要求处理的那串数。", "outputFormat": "一行，表示该串正整数中包含的满足 $A - B = C$ 的数对的个数。", "hint": "对于 $75\\%$ 的数据，$1 \\leq N \\leq 2000$。\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 2 \\times 10^5$，$0 \\leq a_i <2^{30}$，$1 \\leq C < 2^{30}$。\n\n2017/4/29 新添数据两组", "locale": "zh-CN"}}}
{"pid": "P1103", "type": "P", "difficulty": 3, "samples": [["4 1\n1 2\n2 4\n3 1\n5 3\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP"], "title": "书本整理", "background": null, "description": "Frank 是一个非常喜爱整洁的人。他有一大堆书和一个书架，想要把书放在书架上。书架可以放下所有的书，所以 Frank 首先将书按高度顺序排列在书架上。但是 Frank 发现，由于很多书的宽度不同，所以书看起来还是非常不整齐。于是他决定从中拿掉 $k$ 本书，使得书架可以看起来整齐一点。\n\n书架的不整齐度是这样定义的：每两本书宽度的差的绝对值的和。例如有 $4$ 本书：\n\n$1 \\times 2$  \n$5 \\times 3$  \n$2 \\times 4$  \n$3 \\times 1$    \n\n那么 Frank 将其排列整齐后是：\n\n$1 \\times 2$  \n$2 \\times 4$  \n$3 \\times 1$  \n$5 \\times 3$  \n\n不整齐度就是 $2+3+2=7$。\n\n已知每本书的高度都不一样，请你求出去掉 $k$ 本书后的最小的不整齐度。", "inputFormat": "第一行两个数字 $n$ 和 $k$，代表书有几本，从中去掉几本（$1 \\le n \\le 100, 1  \\le k<n$）。\n\n下面的 $n$ 行，每行两个数字表示一本书的高度和宽度，均小于等于 $200$。\n\n保证高度不重复。", "outputFormat": "一行一个整数，表示书架的最小不整齐度。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Book Arrangement", "background": "", "description": "Frank is a neat person. He has a large pile of books and a bookshelf, and he wants to put the books on the shelf. The shelf can hold all the books, so Frank first arranges the books on the shelf in order of height. However, Frank finds that since many books have different widths, the shelf still looks messy. He decides to remove $k$ books so that the shelf looks tidier.\n\nThe messiness of the shelf is defined as the sum of the absolute differences of the widths between each pair of adjacent books (after ordering by height). For example, there are $4$ books:\n\n$1 \\times 2$  \n$5 \\times 3$  \n$2 \\times 4$  \n$3 \\times 1$    \n\nAfter arranging them by height, Frank gets:\n\n$1 \\times 2$  \n$2 \\times 4$  \n$3 \\times 1$  \n$5 \\times 3$  \n\nThe messiness is $2+3+2=7$.\n\nEach book has a distinct height. Please find the minimum possible messiness after removing $k$ books.", "inputFormat": "The first line contains two integers $n$ and $k$, the number of books and the number to remove ($1 \\le n \\le 100$, $1 \\le k < n$).\n\nEach of the next $n$ lines contains two integers, the height and width of a book, both no more than $200$.\n\nHeights are guaranteed to be distinct.", "outputFormat": "Output a single integer: the minimum messiness of the shelf.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "书本整理", "background": null, "description": "Frank 是一个非常喜爱整洁的人。他有一大堆书和一个书架，想要把书放在书架上。书架可以放下所有的书，所以 Frank 首先将书按高度顺序排列在书架上。但是 Frank 发现，由于很多书的宽度不同，所以书看起来还是非常不整齐。于是他决定从中拿掉 $k$ 本书，使得书架可以看起来整齐一点。\n\n书架的不整齐度是这样定义的：每两本书宽度的差的绝对值的和。例如有 $4$ 本书：\n\n$1 \\times 2$  \n$5 \\times 3$  \n$2 \\times 4$  \n$3 \\times 1$    \n\n那么 Frank 将其排列整齐后是：\n\n$1 \\times 2$  \n$2 \\times 4$  \n$3 \\times 1$  \n$5 \\times 3$  \n\n不整齐度就是 $2+3+2=7$。\n\n已知每本书的高度都不一样，请你求出去掉 $k$ 本书后的最小的不整齐度。", "inputFormat": "第一行两个数字 $n$ 和 $k$，代表书有几本，从中去掉几本（$1 \\le n \\le 100, 1  \\le k<n$）。\n\n下面的 $n$ 行，每行两个数字表示一本书的高度和宽度，均小于等于 $200$。\n\n保证高度不重复。", "outputFormat": "一行一个整数，表示书架的最小不整齐度。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1104", "type": "P", "difficulty": 2, "samples": [["3\nYangchu 1992 4 23\nQiujingya 1993 10 13\nLuowen 1991 8 1\n", "Luowen\nYangchu\nQiujingya\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "字符串", "排序"], "title": "生日", "background": null, "description": "cjf 君想调查学校 OI 组每个同学的生日，并按照年龄从大到小的顺序排序。但 cjf 君最近作业很多，没有时间，所以请你帮她排序。", "inputFormat": "输入共有 $n + 1$ 行，\n\n第 $1$ 行为 OI 组总人数 $n$；\n\n第 $2$ 行至第 $n+1$ 行分别是每人的姓名 $s$、出生年 $y$、月 $m$、日 $d$。", "outputFormat": "输出共有 $n$ 行，即 $n$ 个年龄从大到小同学的姓名（如果有两个同学年龄相同，输入靠后的同学先输出）。", "hint": "数据保证，$1<n<100$，$1\\leq |s|<20$。保证年月日实际存在，且年份 $\\in [1960,2020]$。", "locale": "zh-CN", "translations": {"en": {"title": "Birthday", "background": null, "description": "cjf wants to collect the birthdays of every student in the school OI group and sort them by age in descending order (older first). However, cjf has a lot of homework recently and has no time, so please help her sort them.", "inputFormat": "The input contains $n + 1$ lines.\n\nThe first line contains the total number $n$ of people in the OI group.\n\nLines $2$ to $n + 1$ each contain one person's name $s$, birth year $y$, month $m$, and day $d$.", "outputFormat": "Output $n$ lines.\n\nPrint the names of the students in descending order of age. (If two students share the same birthday, print the one that appears later in the input first.)", "hint": "It is guaranteed that $1 < n < 100$ and $1 \\leq |s| < 20$. The given dates are valid, and the year $\\in [1960, 2020]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "生日", "background": null, "description": "cjf 君想调查学校 OI 组每个同学的生日，并按照年龄从大到小的顺序排序。但 cjf 君最近作业很多，没有时间，所以请你帮她排序。", "inputFormat": "输入共有 $n + 1$ 行，\n\n第 $1$ 行为 OI 组总人数 $n$；\n\n第 $2$ 行至第 $n+1$ 行分别是每人的姓名 $s$、出生年 $y$、月 $m$、日 $d$。", "outputFormat": "输出共有 $n$ 行，即 $n$ 个年龄从大到小同学的姓名（如果有两个同学年龄相同，输入靠后的同学先输出）。", "hint": "数据保证，$1<n<100$，$1\\leq |s|<20$。保证年月日实际存在，且年份 $\\in [1960,2020]$。", "locale": "zh-CN"}}}
{"pid": "P1105", "type": "P", "difficulty": 2, "samples": [["5\n2 0 2\n4 1 3\n3 1 3\n5 3 4\n1 1 5\n", "0 5\n1 5\n1 5\n5 5\n0 0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "搜索", "排序"], "title": "平台", "background": "", "description": "空间中有一些平台。给出每个平台的位置，请你计算从每一个平台的边缘落下之后会落到哪一个平台上。\n\n注意，如果某两个平台的某个两边缘横坐标相同，物体从上面那个平台落下之后将不会落在下面那个平台上（即平台的范围是一个开区间，不包含端点）。平台**可能会重叠**。\n\n从平台下落时视作从平台下方开始下落，也就是说不会落到高度相同的平台上。**如果有两个平台的高度相同且都可以被落到的话，那么会落到编号靠前的那个平台。**", "inputFormat": "第一行有一个数 $N$ 表示平台的个数;\n\n接下来 $N$ 行每行三个整数 分别是平台的高度 $H_i$，左端点的 $X$ 坐标 $L_i$，右端点的 $X$ 坐标 $R_i$。\n\n其中，$1 \\le N \\le {10}^3$，$0 \\le H,L,R \\le 2 \\times {10}^4$。", "outputFormat": "输出共 $N$ 行，每行两个数，分别表示：\n\n从第 $i$ 个平台的左边缘落下后到达的平台序号和右边缘落下以后到达的平台序号。\n\n输入数据中第一个平台的序号是 $1$。如果某个平台的某个边缘下面没有平台了，输出 $0$。\n", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/qeknowf7.png)", "locale": "zh-CN", "translations": {"en": {"title": "Platforms", "background": null, "description": "There are several platforms in space. Given the position of each platform, determine which platform you will land on after stepping off each platform’s edges.\n\nNote: If the x-coordinates of some edge of two platforms are the same, then an object falling from the upper platform will not land on the lower one (i.e., each platform covers an open interval, excluding endpoints). Platforms may overlap.\n\nWhen stepping off a platform, the fall is considered to start just below that platform, so you will not land on a platform of the same height. If there are two platforms with the same height that are both eligible to be landed on, you will land on the one with the smaller index.", "inputFormat": "The first line contains an integer $N$, the number of platforms.\n\nEach of the next $N$ lines contains three integers: the height $H_i$, the left endpoint’s $X$-coordinate $L_i$, and the right endpoint’s $X$-coordinate $R_i$.\n\nConstraints: $1 \\le N \\le 10^3$, $0 \\le H, L, R \\le 2 \\times 10^4$.", "outputFormat": "Output $N$ lines. For each $i$, output two integers: the index of the platform reached by falling from the left edge of platform $i$, and the index reached by falling from the right edge of platform $i$.\n\nPlatforms are numbered from $1$ in the input. If there is no platform below a given edge, output $0$.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/qeknowf7.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "平台", "background": "", "description": "空间中有一些平台。给出每个平台的位置，请你计算从每一个平台的边缘落下之后会落到哪一个平台上。\n\n注意，如果某两个平台的某个两边缘横坐标相同，物体从上面那个平台落下之后将不会落在下面那个平台上（即平台的范围是一个开区间，不包含端点）。平台**可能会重叠**。\n\n从平台下落时视作从平台下方开始下落，也就是说不会落到高度相同的平台上。**如果有两个平台的高度相同且都可以被落到的话，那么会落到编号靠前的那个平台。**", "inputFormat": "第一行有一个数 $N$ 表示平台的个数;\n\n接下来 $N$ 行每行三个整数 分别是平台的高度 $H_i$，左端点的 $X$ 坐标 $L_i$，右端点的 $X$ 坐标 $R_i$。\n\n其中，$1 \\le N \\le {10}^3$，$0 \\le H,L,R \\le 2 \\times {10}^4$。", "outputFormat": "输出共 $N$ 行，每行两个数，分别表示：\n\n从第 $i$ 个平台的左边缘落下后到达的平台序号和右边缘落下以后到达的平台序号。\n\n输入数据中第一个平台的序号是 $1$。如果某个平台的某个边缘下面没有平台了，输出 $0$。\n", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/qeknowf7.png)", "locale": "zh-CN"}}}
{"pid": "P1106", "type": "P", "difficulty": 3, "samples": [["175438 \n4\n", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "贪心"], "title": "删数问题", "background": null, "description": "键盘输入一个高精度的正整数 $n$（不超过 $250$ 位），去掉其中任意 $k$ 个数字后剩下的数字按原左右次序将组成一个新的非负整数。编程对给定的 $n$ 和 $k$，寻找一种方案使得剩下的数字组成的新数最小。", "inputFormat": "输入两行正整数。\n\n第一行输入一个高精度的正整数 $n$。\n\n第二行输入一个正整数 $k$，表示需要删除的数字个数。", "outputFormat": "输出一个整数，最后剩下的最小数。", "hint": "用 $\\operatorname{len}(n)$ 表示 $n$ 的**位数**，保证 $1 \\leq k < \\operatorname{len}(n) \\leq 250$。\n\n**注意：去掉若干数字后剩下的数可以存在前导零，而输出时不要输出前导零。**", "locale": "zh-CN", "translations": {"en": {"title": "Delete Digits Problem", "background": null, "description": "Input a high-precision positive integer $n$ (no more than $250$ digits). After removing any $k$ digits, the remaining digits, kept in their original left-to-right order, form a new non-negative integer. Given $n$ and $k$, write a program to find a strategy to remove digits so that the resulting number is minimal.", "inputFormat": "The input consists of two lines of positive integers.\n\nThe first line contains the high-precision positive integer $n$.\n\nThe second line contains the positive integer $k$, the number of digits to delete.", "outputFormat": "Output a single integer: the minimal possible remaining number.", "hint": "Let $\\operatorname{len}(n)$ denote the number of digits of $n$, and it is guaranteed that $1 \\leq k < \\operatorname{len}(n) \\leq 250$.\n\nNote: after deleting some digits, the remaining number may have leading zeros, but do not output leading zeros.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "删数问题", "background": null, "description": "键盘输入一个高精度的正整数 $n$（不超过 $250$ 位），去掉其中任意 $k$ 个数字后剩下的数字按原左右次序将组成一个新的非负整数。编程对给定的 $n$ 和 $k$，寻找一种方案使得剩下的数字组成的新数最小。", "inputFormat": "输入两行正整数。\n\n第一行输入一个高精度的正整数 $n$。\n\n第二行输入一个正整数 $k$，表示需要删除的数字个数。", "outputFormat": "输出一个整数，最后剩下的最小数。", "hint": "用 $\\operatorname{len}(n)$ 表示 $n$ 的**位数**，保证 $1 \\leq k < \\operatorname{len}(n) \\leq 250$。\n\n**注意：去掉若干数字后剩下的数可以存在前导零，而输出时不要输出前导零。**", "locale": "zh-CN"}}}
{"pid": "P1107", "type": "P", "difficulty": 4, "samples": [["3 10 2\n3 1 4 10\n6 3 5 9 7 8 9\n5 4 5 3 6 9", "8"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2008", "北京"], "title": "[BJWC2008] 雷涛的小猫", "background": "原最大整数参见 P1012", "description": "雷涛同学非常的有爱心，在他的宿舍里，养着一只因为受伤被救助的小猫（当然，这样的行为是违反学生宿舍管理条例的）。在他的照顾下，小猫很快恢复了健康，并且愈发的活泼可爱了。\n\n可是有一天，雷涛下课回到寝室，却发现小猫不见了！经过一番寻找，才发现她正趴在阳台上对窗外的柿子树发呆…\n\n在北京大学的校园里，有许多柿子树，在雷涛所在的宿舍楼前，就有 $N$ 棵。并且这 $N$ 棵柿子树每棵的高度都是 $H$。冬天的寒冷渐渐笼罩了大地，树上的叶子渐渐掉光了，只剩下一个个黄澄澄的柿子，看着非常喜人。而雷涛的小猫恰好非常的爱吃柿子，看着窗外树上的柿子，她十分眼馋，于是决定利用自己敏捷的跳跃能力跳到树上去吃柿子。\n\n小猫可以从宿舍的阳台上跳到窗外任意一棵柿子树的树顶。之后，她每次都可以在当前位置沿着当前所在的柿子树向下跳 $1$ 单位距离。当然，小猫的能力远不止如此，她还可以在树之间跳跃。每次她都可以从当前这棵树跳到另外的任意一棵，在这个过程中，她的高度会下降 `Delta` 单位距离。每个时刻，只要她所在的位置有柿子，她就可以吃掉。整个“吃柿子行动”一直到小猫落到地面上为止。\n\n雷涛调查了所有柿子树上柿子的生长情况。他很想知道，小猫从阳台出发，最多能吃到多少柿子？他知道写一个程序可以很容易的解决这个问题，但是他现在懒于写任何代码。于是，现在你的任务就是帮助雷涛写一个这样的程序。\n\n图为 $N=3, H=10, Delta=2$ 的一个例子。小猫按照图示路线进行跳跃，可以吃到最多的 $8$ 个柿子。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/69gyw9xt.png)", "inputFormat": "第一行有三个以空格分隔的整数，分别代表 $N,H,Delta$。\n\n接下来的 $N$ 行，每行第一个整数为 $N_i$，代表第 $i$ 棵树上的柿子数量。\n\n接下来是 $N_i$ 个整数，每个整数 $T_{i,j}$ 代表第 $i$ 棵柿子树的 $T_{i,j}$ 高度上长有一个柿子。", "outputFormat": "一个整数，即小猫最多吃到的柿子数。", "hint": "### 数据范围及约定\n\n对于全部数据，$1 \\leq N, H ≤ 2000$，$0 \\leq N_i ≤ 5000$，$1 ≤ Delta ≤ H,1 ≤ T_{i,j} ≤ H$。\n\n输入文件大小不大于 40MB。注意输入输出效率。\n\n来源 Excalibur, 2008。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2008] Lei Tao's Kitten", "background": null, "description": "Lei Tao is very compassionate. In his dormitory, he keeps a kitten that was rescued after being injured (of course, this violates the student dormitory management regulations). Under his care, the kitten quickly recovered and became even more lively and adorable.\n\nBut one day, after class, Lei Tao returned to his room and found that the kitten was missing! After searching for a while, he discovered that she was lying on the balcony, staring blankly at the persimmon tree outside the window.\n\nThere are many persimmon trees on the campus of Peking University, and there are $N$ of them right in front of Lei Tao’s dorm building. All these $N$ persimmon trees have the same height $H$. As the cold of winter gradually spreads over the land, the leaves on the trees fall off, leaving only the golden persimmons, which look very tempting. It just so happens that Lei Tao’s kitten loves to eat persimmons. Seeing the persimmons on the trees outside the window, she became very eager, and decided to use her agile jumping ability to jump onto the trees to eat persimmons.\n\nThe kitten can jump from the dormitory balcony to the top of any tree outside. After that, each time she can jump downward along the current tree by 1 unit of distance. Of course, her abilities are not limited to this—she can also jump between trees. Each time she can jump from the current tree to any other one, and in this process her height decreases by `Delta` units. At any moment, if there is a persimmon at her current position, she can eat it. The entire \"persimmon-eating operation\" continues until the kitten reaches the ground.\n\nThe figure shows an example with $N=3, H=10, Delta=2$. Following the route shown in the figure, the kitten can eat at most 8 persimmons.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/69gyw9xt.png)", "inputFormat": "The first line contains three integers separated by spaces, representing $N, H, Delta$.\n\nThe next $N$ lines each begin with an integer $N_i$, representing the number of persimmons on the $i$-th tree.\n\nThen follow $N_i$ integers, where each integer $T_{i,j}$ indicates that there is a persimmon at height $T_{i,j}$ on the $i$-th tree.", "outputFormat": "Output a single integer: the maximum number of persimmons the kitten can eat.", "hint": "Constraints and Notes\n\nFor all testdata, $1 \\leq N, H \\leq 2000$, $0 \\leq N_i \\leq 5000$, $1 \\leq Delta \\leq H, 1 \\leq T_{i,j} \\leq H$.\n\nThe input file size is no more than 40 MB. Pay attention to I/O efficiency.\n\nSource: Excalibur, 2008.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2008] 雷涛的小猫", "background": "原最大整数参见 P1012", "description": "雷涛同学非常的有爱心，在他的宿舍里，养着一只因为受伤被救助的小猫（当然，这样的行为是违反学生宿舍管理条例的）。在他的照顾下，小猫很快恢复了健康，并且愈发的活泼可爱了。\n\n可是有一天，雷涛下课回到寝室，却发现小猫不见了！经过一番寻找，才发现她正趴在阳台上对窗外的柿子树发呆…\n\n在北京大学的校园里，有许多柿子树，在雷涛所在的宿舍楼前，就有 $N$ 棵。并且这 $N$ 棵柿子树每棵的高度都是 $H$。冬天的寒冷渐渐笼罩了大地，树上的叶子渐渐掉光了，只剩下一个个黄澄澄的柿子，看着非常喜人。而雷涛的小猫恰好非常的爱吃柿子，看着窗外树上的柿子，她十分眼馋，于是决定利用自己敏捷的跳跃能力跳到树上去吃柿子。\n\n小猫可以从宿舍的阳台上跳到窗外任意一棵柿子树的树顶。之后，她每次都可以在当前位置沿着当前所在的柿子树向下跳 $1$ 单位距离。当然，小猫的能力远不止如此，她还可以在树之间跳跃。每次她都可以从当前这棵树跳到另外的任意一棵，在这个过程中，她的高度会下降 `Delta` 单位距离。每个时刻，只要她所在的位置有柿子，她就可以吃掉。整个“吃柿子行动”一直到小猫落到地面上为止。\n\n雷涛调查了所有柿子树上柿子的生长情况。他很想知道，小猫从阳台出发，最多能吃到多少柿子？他知道写一个程序可以很容易的解决这个问题，但是他现在懒于写任何代码。于是，现在你的任务就是帮助雷涛写一个这样的程序。\n\n图为 $N=3, H=10, Delta=2$ 的一个例子。小猫按照图示路线进行跳跃，可以吃到最多的 $8$ 个柿子。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/69gyw9xt.png)", "inputFormat": "第一行有三个以空格分隔的整数，分别代表 $N,H,Delta$。\n\n接下来的 $N$ 行，每行第一个整数为 $N_i$，代表第 $i$ 棵树上的柿子数量。\n\n接下来是 $N_i$ 个整数，每个整数 $T_{i,j}$ 代表第 $i$ 棵柿子树的 $T_{i,j}$ 高度上长有一个柿子。", "outputFormat": "一个整数，即小猫最多吃到的柿子数。", "hint": "### 数据范围及约定\n\n对于全部数据，$1 \\leq N, H ≤ 2000$，$0 \\leq N_i ≤ 5000$，$1 ≤ Delta ≤ H,1 ≤ T_{i,j} ≤ H$。\n\n输入文件大小不大于 40MB。注意输入输出效率。\n\n来源 Excalibur, 2008。", "locale": "zh-CN"}}}
{"pid": "P1108", "type": "P", "difficulty": 3, "samples": [["12\n68 69 54 64 68 64 70 67 78 62 98 87\n", "4 2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "枚举"], "title": "低价购买", "background": null, "description": "“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买；再低价购买”。每次你购买一支股票,你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买；再低价购买”的原则。写一个程序计算最大购买次数。\n\n这里是某支股票的价格清单：\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}\\hline\n\\textsf{日期} & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \\cr\\hline\n\\textsf{价格} & 68 & 69 & 54 & 64 & 68 & 64 & 70 & 67 & 78 & 62& 98 & 87 \\cr\\hline\n\\end{array}$$\n\n最优秀的投资者可以购买最多 $4$ 次股票，可行方案中的一种是：\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|}\\hline\n\\textsf{日期} & 2 & 5 & 6 & 10 \\cr\\hline\n\\textsf{价格} & 69 & 68 & 64 & 62 \\cr\\hline\n\\end{array}\n$$", "inputFormat": "第一行共一个整数 $N\\ (1  \\le  N  \\le 5000)$，股票发行天数。\n\n第二行一行 $N$ 个整数，是每天的股票价格。保证是大小不超过 $2^{16}$ 的正整数。", "outputFormat": "输出共一行两个整数，分别为最大购买次数和拥有最大购买次数的方案数（数据保证 $ \\le 2^{31}$）当二种方案“看起来一样”时（就是说它们构成的价格队列一样的时候）,这 $2$ 种方案被认为是相同的。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Buy Low", "background": null, "description": "The advice “buy low” is half the rule for success in the cow stock market. To be considered a great investor, you must follow this advice: “buy low; buy lower.” Each time you buy a stock, you must buy it at a price lower than the last time you bought it. The more times you buy, the better. Your goal, while following the above advice, is to find the maximum number of times you can buy the stock. You will be given the daily selling prices of a stock over a period of time, and you may choose on which days to buy. Every purchase must follow the “buy low; buy lower” principle. Write a program to compute the maximum number of purchases.\n\nHere is a price list for a certain stock:\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}\\hline\n\\textsf{日期} & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \\cr\\hline\n\\textsf{价格} & 68 & 69 & 54 & 64 & 68 & 64 & 70 & 67 & 78 & 62& 98 & 87 \\cr\\hline\n\\end{array}$$\n\nThe best investor can buy at most $4$ times. One feasible plan is:\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|}\\hline\n\\textsf{日期} & 2 & 5 & 6 & 10 \\cr\\hline\n\\textsf{价格} & 69 & 68 & 64 & 62 \\cr\\hline\n\\end{array}\n$$", "inputFormat": "The first line contains a single integer $N\\ (1  \\le  N  \\le 5000)$, the number of trading days.\n\nThe second line contains $N$ integers, the stock price for each day. Each is guaranteed to be a positive integer not exceeding $2^{16}$.", "outputFormat": "Output two integers in one line: the maximum number of purchases, and the number of schemes that achieve this maximum (guaranteed $ \\le 2^{31}$). When two schemes “look the same” (that is, they form the same sequence of prices), the two schemes are considered identical.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "低价购买", "background": null, "description": "“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买；再低价购买”。每次你购买一支股票,你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买；再低价购买”的原则。写一个程序计算最大购买次数。\n\n这里是某支股票的价格清单：\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}\\hline\n\\textsf{日期} & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \\cr\\hline\n\\textsf{价格} & 68 & 69 & 54 & 64 & 68 & 64 & 70 & 67 & 78 & 62& 98 & 87 \\cr\\hline\n\\end{array}$$\n\n最优秀的投资者可以购买最多 $4$ 次股票，可行方案中的一种是：\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|}\\hline\n\\textsf{日期} & 2 & 5 & 6 & 10 \\cr\\hline\n\\textsf{价格} & 69 & 68 & 64 & 62 \\cr\\hline\n\\end{array}\n$$", "inputFormat": "第一行共一个整数 $N\\ (1  \\le  N  \\le 5000)$，股票发行天数。\n\n第二行一行 $N$ 个整数，是每天的股票价格。保证是大小不超过 $2^{16}$ 的正整数。", "outputFormat": "输出共一行两个整数，分别为最大购买次数和拥有最大购买次数的方案数（数据保证 $ \\le 2^{31}$）当二种方案“看起来一样”时（就是说它们构成的价格队列一样的时候）,这 $2$ 种方案被认为是相同的。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1109", "type": "P", "difficulty": 2, "samples": [["2\n10 20\n10 15\n", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "贪心"], "title": "学生分组", "background": "", "description": "有 $n$ 组学生，给出初始时每组中的学生个数，再给出每组学生人数的上界 $R$ 和下界 $L\\ (L \\le R)$，每次你可以在某组中选出一个学生把他安排到另外一组中，问最少要多少次才可以使 $N$ 组学生的人数都在 $[L,R]$ 中。\n", "inputFormat": "第一行一个整数 $n$，表示学生组数；\n\n第二行 $n$ 个整数，表示每组的学生个数；\n\n第三行两个整数 $L,R$，表示下界和上界。\n", "outputFormat": "一个数，表示最少的交换次数，如果不能满足题目条件输出 $-1$。", "hint": "### 数据范围及约定\n\n对于全部数据，保证 $1\\le n \\le 50$。", "locale": "zh-CN", "translations": {"en": {"title": "Student Grouping", "background": null, "description": "There are $n$ groups of students. You are given the initial number of students in each group, and the upper bound $R$ and lower bound $L$ for each group size (with $L \\le R$). In one operation, you may select one student from a group and move them to another group. What is the minimum number of operations required to make the sizes of all $n$ groups fall within $[L, R]$?", "inputFormat": "The first line contains an integer $n$, the number of student groups.\nThe second line contains $n$ integers, the number of students in each group.\nThe third line contains two integers $L, R$, the lower and upper bounds.", "outputFormat": "Output a single integer, the minimum number of moves. If it is impossible to satisfy the condition, output -1.", "hint": "Constraints\n\nFor all testdata, it is guaranteed that $1 \\le n \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "学生分组", "background": "", "description": "有 $n$ 组学生，给出初始时每组中的学生个数，再给出每组学生人数的上界 $R$ 和下界 $L\\ (L \\le R)$，每次你可以在某组中选出一个学生把他安排到另外一组中，问最少要多少次才可以使 $N$ 组学生的人数都在 $[L,R]$ 中。\n", "inputFormat": "第一行一个整数 $n$，表示学生组数；\n\n第二行 $n$ 个整数，表示每组的学生个数；\n\n第三行两个整数 $L,R$，表示下界和上界。\n", "outputFormat": "一个数，表示最少的交换次数，如果不能满足题目条件输出 $-1$。", "hint": "### 数据范围及约定\n\n对于全部数据，保证 $1\\le n \\le 50$。", "locale": "zh-CN"}}}
{"pid": "P1110", "type": "P", "difficulty": 5, "samples": [["3 5\n5 3 1\nINSERT 2 9\nMIN_SORT_GAP\nINSERT 2 6\nMIN_GAP\nMIN_SORT_GAP\n", "2\n2\n1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2500, 2500], "memory": [162000, 162000, 162000, 162000, 162000, 162000, 162000]}, "tags": ["2007", "线段树", "各省省选", "平衡树", "堆", "浙江", "STL"], "title": "[ZJOI2007] 报表统计", "background": null, "description": "小 Q 的妈妈是一个出纳，经常需要做一些统计报表的工作。今天是妈妈的生日，小 Q 希望可以帮妈妈分担一些工作，作为她的生日礼物之一。\n\n经过仔细观察，小 Q 发现统计一张报表实际上是维护一个非负整数数列，并且进行一些查询操作。\n\n在最开始的时候，有一个长度为 $n$ 的整数序列 $a$，并且有以下三种操作：\n        \n- `INSERT i k`：在原数列的第 $i$ 个元素后面添加一个新元素 $k$；如果原数列的第 $i$ 个元素已经添加了若干元素，则添加在这些元素的最后（见样例说明）。\n- `MIN_GAP`：查询相邻两个元素的之间差值（绝对值）的最小值。\n- `MIN_SORT_GAP`：查询所有元素中最接近的两个元素的差值（绝对值）。\n\n于是小 Q 写了一个程序，使得程序可以自动完成这些操作，但是他发现对于一些大的报表他的程序运行得很慢，你能帮助他改进程序么？", "inputFormat": "第一行包含两个整数，分别表示原数列的长度 $n$ 以及操作的次数 $m$。\n\n第二行为 $n$ 个整数，为初始序列，第 $i$ 个整数表示 $a_i$。\n\n接下来的 $m$ 行，每行一个操作，即 `INSERT i k`，`MIN_GAP`，`MIN_SORT_GAP` 中的一种（无多余空格或者空行）。", "outputFormat": "对于每一个 `MIN_GAP` 和 `MIN_SORT_GAP` 命令，输出一行答案即可。", "hint": "#### 样例输入输出 1 解释\n\n一开始的序列为 $\\{5,3,1\\}$。\n\n执行操作 `INSERT 2  9` 将得到 $\\{5,3,9,1\\}$，此时 `MIN_GAP` 为 $2$，`MIN_SORT_GAP` 为 $2$。\n\n再执行操作 `INSERT 2  6` 将得到：$\\{5,3, 9, 6, 1\\}$。\n\n注意这个时候原序列的第 $2$ 个元素后面已经添加了一个 $9$，此时添加的 $6$ 应加在 $9$ 的后面。这个时候 `MIN_GAP` 为 $2$，`MIN_SORT_GAP` 为 $1$。\n\n---\n\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $2 \\le n, m \\le 5\\times10^5$，$1 \\leq i \\leq n$，$0 \\leq a_i, k \\leq 5 \\times 10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2007] Report Statistics", "background": null, "description": "Little Q’s mother is a cashier and often needs to prepare statistical reports. Today is her birthday, and Little Q wants to help with some of the work as a birthday present.\n\nAfter careful observation, Little Q finds that preparing a report is essentially maintaining a sequence of non-negative integers and performing some queries.\n\nInitially, there is an integer sequence $a$ of length $n$, and the following three operations are supported:\n- `INSERT i k`: Append a new element $k$ immediately after the $i$-th element of the original sequence. If some elements have already been appended after the $i$-th original element, append $k$ after all those appended elements (see the sample explanation).\n- `MIN_GAP`: Query the minimum absolute difference between any two adjacent elements.\n- `MIN_SORT_GAP`: Query the minimum absolute difference between the two closest elements among all elements.\n\nLittle Q wrote a program to automate these operations, but it runs slowly on large reports. Can you help improve it?", "inputFormat": "- The first line contains two integers, the length $n$ of the original sequence and the number of operations $m$.\n- The second line contains $n$ integers, the initial sequence; the $i$-th integer is $a_i$.\n- The next $m$ lines each contain one operation, which is one of `INSERT i k`, `MIN_GAP`, or `MIN_SORT_GAP` (no extra spaces or blank lines).", "outputFormat": "For each `MIN_GAP` and `MIN_SORT_GAP` command, output the answer on its own line.", "hint": "#### Explanation of Sample Input/Output 1\n\nThe initial sequence is $\\{5,3,1\\}$.\n\nAfter performing `INSERT 2 9`, the sequence becomes $\\{5,3,9,1\\}$. At this time, `MIN_GAP` is $2$, and `MIN_SORT_GAP` is $2$.\n\nNext, performing `INSERT 2 6` yields $\\{5,3,9,6,1\\}$.\n\nNote that by this time one $9$ has already been appended after the 2nd element of the original sequence, so the newly inserted $6$ should be placed after $9$. Now `MIN_GAP` is $2$, and `MIN_SORT_GAP` is $1$.\n\n---\n\n#### Constraints\n\nFor all test points, it is guaranteed that $2 \\le n, m \\le 5 \\times 10^5$, $1 \\le i \\le n$, and $0 \\le a_i, k \\le 5 \\times 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2007] 报表统计", "background": null, "description": "小 Q 的妈妈是一个出纳，经常需要做一些统计报表的工作。今天是妈妈的生日，小 Q 希望可以帮妈妈分担一些工作，作为她的生日礼物之一。\n\n经过仔细观察，小 Q 发现统计一张报表实际上是维护一个非负整数数列，并且进行一些查询操作。\n\n在最开始的时候，有一个长度为 $n$ 的整数序列 $a$，并且有以下三种操作：\n        \n- `INSERT i k`：在原数列的第 $i$ 个元素后面添加一个新元素 $k$；如果原数列的第 $i$ 个元素已经添加了若干元素，则添加在这些元素的最后（见样例说明）。\n- `MIN_GAP`：查询相邻两个元素的之间差值（绝对值）的最小值。\n- `MIN_SORT_GAP`：查询所有元素中最接近的两个元素的差值（绝对值）。\n\n于是小 Q 写了一个程序，使得程序可以自动完成这些操作，但是他发现对于一些大的报表他的程序运行得很慢，你能帮助他改进程序么？", "inputFormat": "第一行包含两个整数，分别表示原数列的长度 $n$ 以及操作的次数 $m$。\n\n第二行为 $n$ 个整数，为初始序列，第 $i$ 个整数表示 $a_i$。\n\n接下来的 $m$ 行，每行一个操作，即 `INSERT i k`，`MIN_GAP`，`MIN_SORT_GAP` 中的一种（无多余空格或者空行）。", "outputFormat": "对于每一个 `MIN_GAP` 和 `MIN_SORT_GAP` 命令，输出一行答案即可。", "hint": "#### 样例输入输出 1 解释\n\n一开始的序列为 $\\{5,3,1\\}$。\n\n执行操作 `INSERT 2  9` 将得到 $\\{5,3,9,1\\}$，此时 `MIN_GAP` 为 $2$，`MIN_SORT_GAP` 为 $2$。\n\n再执行操作 `INSERT 2  6` 将得到：$\\{5,3, 9, 6, 1\\}$。\n\n注意这个时候原序列的第 $2$ 个元素后面已经添加了一个 $9$，此时添加的 $6$ 应加在 $9$ 的后面。这个时候 `MIN_GAP` 为 $2$，`MIN_SORT_GAP` 为 $1$。\n\n---\n\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $2 \\le n, m \\le 5\\times10^5$，$1 \\leq i \\leq n$，$0 \\leq a_i, k \\leq 5 \\times 10^8$。", "locale": "zh-CN"}}}
{"pid": "P1111", "type": "P", "difficulty": 3, "samples": [["4 4\n1 2 6\n1 3 4\n1 4 5\n4 2 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["二分", "并查集", "排序", "生成树"], "title": "修复公路", "background": "A 地区在地震过后，连接所有村庄的公路都造成了损坏而无法通车。政府派人修复这些公路。", "description": "给出 A 地区的村庄数 $N$，和公路数 $M$，公路是双向的。并告诉你每条公路的连着哪两个村庄，并告诉你什么时候能修完这条公路。问最早什么时候任意两个村庄能够通车，即最早什么时候任意两条村庄都存在至少一条修复完成的道路（可以由多条公路连成一条道路）。", "inputFormat": "第 $1$ 行两个正整数 $N,M$。\n\n下面 $M$ 行，每行 $3$ 个正整数 $x,y,t$，告诉你这条公路连着 $x,y$ 两个村庄，在时间 $t$ 时能修复完成这条公路。", "outputFormat": "如果全部公路修复完毕仍然存在两个村庄无法通车，则输出 $-1$，否则输出最早什么时候任意两个村庄能够通车。", "hint": "$1\\leq x, y\\leq N \\le 10 ^ 3$，$1\\leq M, t \\le 10 ^ 5$。", "locale": "zh-CN", "translations": {"en": {"title": "Repairing Roads", "background": null, "description": "Given the number of villages $N$ and the number of roads $M$ in region A. The roads are bidirectional. You are told which two villages each road connects and when this road will be completed. Find the earliest time when any two villages can travel between each other, i.e., the earliest time when for any pair of villages there exists at least one completed path (possibly consisting of multiple roads).", "inputFormat": "The first line contains two positive integers $N, M$.\n\nThen the next $M$ lines follow. Each line contains three positive integers $x, y, t$, indicating that this road connects villages $x$ and $y$, and it will be completed at time $t$.", "outputFormat": "If, after all roads are completed, there still exist two villages that cannot travel between each other, output $-1$. Otherwise, output the earliest time when any two villages can travel between each other.", "hint": "$1\\leq x, y\\leq N \\le 10 ^ 3$, $1\\leq M, t \\le 10 ^ 5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "修复公路", "background": "A 地区在地震过后，连接所有村庄的公路都造成了损坏而无法通车。政府派人修复这些公路。", "description": "给出 A 地区的村庄数 $N$，和公路数 $M$，公路是双向的。并告诉你每条公路的连着哪两个村庄，并告诉你什么时候能修完这条公路。问最早什么时候任意两个村庄能够通车，即最早什么时候任意两条村庄都存在至少一条修复完成的道路（可以由多条公路连成一条道路）。", "inputFormat": "第 $1$ 行两个正整数 $N,M$。\n\n下面 $M$ 行，每行 $3$ 个正整数 $x,y,t$，告诉你这条公路连着 $x,y$ 两个村庄，在时间 $t$ 时能修复完成这条公路。", "outputFormat": "如果全部公路修复完毕仍然存在两个村庄无法通车，则输出 $-1$，否则输出最早什么时候任意两个村庄能够通车。", "hint": "$1\\leq x, y\\leq N \\le 10 ^ 3$，$1\\leq M, t \\le 10 ^ 5$。", "locale": "zh-CN"}}}
{"pid": "P1112", "type": "P", "difficulty": 3, "samples": [["10 11 190000 960000 2", "191919\n383838\n575757\n767676\n959595"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "数学", "进制", "构造"], "title": "波浪数", "background": "", "description": "波浪数是在一对**不同**数字之间交替转换的数，如 $1212121$，双重波浪数则是指在两种进制下都是波浪数的数，如十进制数 $191919$ 是一个十进制下的波浪数，它对应的十一进制数 $121212$ 也是一个波浪数，所以十进制数 $191919$ 是一个双重波浪数。特别地，只有一位的数也算作波浪数，例如 $1$。\n\n类似的可以定义三重波浪数，三重波浪数在三种不同的进制中都是波浪数，甚至还有四重波浪数，如 $300_{(10)}=606_{(7)}=363_{(9)}=454_{(8)}=1\\mathtt{A}1_{(13)}$，下标表示采用的进制。你的任务就是在指定范围内找出双重、三重、四重波浪数。\n", "inputFormat": "单独一行包含五个用空格隔开的十进制整数 $l, r, L, R, k$。$[l, r]$ 表示应当考虑的进制的范围，$[L,R]$ 表示应当考虑的数字的范围，$k$ 表示你应该找的波浪数的重数。", "outputFormat": "从小到大以十进制形式输出指定范围内的指定重数的波浪数。一行输出一个数。\n", "hint": "### 数据范围及约定\n\n对于全部数据，保证 $2\\le l\\le r\\le 32$，$1\\le L\\le R\\le 10^7$，$k\\in \\{2, 3, 4\\}$。", "locale": "zh-CN", "translations": {"en": {"title": "Wavy Numbers", "background": null, "description": "A wavy number is a number that alternates between a pair of distinct digits, such as $1212121$. A double wavy number is a number that is wavy in two bases. For example, the decimal number $191919$ is wavy in base 10, and its base 11 representation $121212$ is also wavy, so the decimal number $191919$ is a double wavy number. In particular, a single-digit number also counts as a wavy number, e.g., $1$.\n\nSimilarly, we define triple wavy numbers as numbers that are wavy in three different bases, and even quadruple wavy numbers, e.g., $300_{(10)}=606_{(7)}=363_{(9)}=454_{(8)}=1\\mathtt{A}1_{(13)}$, where the subscript denotes the base. Your task is to find, within the specified ranges, all double, triple, or quadruple wavy numbers.", "inputFormat": "A single line contains five space-separated decimal integers $l, r, L, R, k$. The interval $[l, r]$ denotes the range of bases to consider, the interval $[L, R]$ denotes the range of numbers to consider, and $k$ specifies the multiplicity of wavy numbers to find.", "outputFormat": "Output, in increasing order and in decimal, all wavy numbers within the specified range that have the specified multiplicity. Print one number per line.", "hint": "Constraints\n\nFor all testdata, it is guaranteed that $2 \\le l \\le r \\le 32$, $1 \\le L \\le R \\le 10^7$, and $k \\in \\{2, 3, 4\\}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "波浪数", "background": "", "description": "波浪数是在一对**不同**数字之间交替转换的数，如 $1212121$，双重波浪数则是指在两种进制下都是波浪数的数，如十进制数 $191919$ 是一个十进制下的波浪数，它对应的十一进制数 $121212$ 也是一个波浪数，所以十进制数 $191919$ 是一个双重波浪数。特别地，只有一位的数也算作波浪数，例如 $1$。\n\n类似的可以定义三重波浪数，三重波浪数在三种不同的进制中都是波浪数，甚至还有四重波浪数，如 $300_{(10)}=606_{(7)}=363_{(9)}=454_{(8)}=1\\mathtt{A}1_{(13)}$，下标表示采用的进制。你的任务就是在指定范围内找出双重、三重、四重波浪数。\n", "inputFormat": "单独一行包含五个用空格隔开的十进制整数 $l, r, L, R, k$。$[l, r]$ 表示应当考虑的进制的范围，$[L,R]$ 表示应当考虑的数字的范围，$k$ 表示你应该找的波浪数的重数。", "outputFormat": "从小到大以十进制形式输出指定范围内的指定重数的波浪数。一行输出一个数。\n", "hint": "### 数据范围及约定\n\n对于全部数据，保证 $2\\le l\\le r\\le 32$，$1\\le L\\le R\\le 10^7$，$k\\in \\{2, 3, 4\\}$。", "locale": "zh-CN"}}}
{"pid": "P1113", "type": "P", "difficulty": 3, "samples": [["7\n1 5 0\n2 2 1 0\n3 3 2 0\n4 6 1 0\n5 1 2 4 0\n6 8 2 4 0\n7 4 3 5 6 0\n", "23\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "图论", "递推", "拓扑排序"], "title": "杂务", "background": null, "description": "John 的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。\n\n当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务 $1$。\n\nJohn 有需要完成的 $n$ 个杂务的清单，并且这份清单是有一定顺序的，杂务 $k\\ (k>1)$ 的准备工作只可能在杂务 $1$ 至 $k-1$ 中。\n\n写一个程序依次读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定 John 的农场有足够多的工人来同时完成任意多项任务。", "inputFormat": "第 $1$ 行，一个整数 $n\\ (3 \\le n \\le 10{,}000)$，必须完成的杂务的数目；\n\n第 $2$ 至 $n+1$ 行，每行有一些用空格隔开的整数，分别表示：\n\n- 工作序号（保证在输入文件中是从 $1$ 到 $n$ 有序递增的）；\n- 完成工作所需要的时间 $len\\ (1 \\le len \\le 100)$；\n- 一些必须完成的准备工作，总数不超过 $100$ 个，由一个数字 $0$ 结束。有些杂务没有需要准备的工作只描述一个单独的 $0$。\n\n保证整个输入文件中不会出现多余的空格。", "outputFormat": "一个整数，表示完成所有杂务所需的最短时间。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Chores", "background": null, "description": "Before milking the cows, John's farm has many chores to complete, each requiring a certain amount of time. For example: gathering the cows, driving them into the barn, cleaning their udders, and other tasks. It is necessary to finish all chores as early as possible to have more time to produce more milk.\n\nOf course, some chores must be done only after certain other chores are completed. For example, you can clean a cow’s udder only after driving it into the barn, and you cannot milk a cow before cleaning its udder. We call these the preparatory tasks for a given task. At least one task requires no preparatory work; the earliest task that can be started is labeled task $1$.\n\nJohn has a list of $n$ tasks to complete, and the list has a specific order: the preparatory tasks of task $k\\ (k>1)$ can only be among tasks $1$ to $k-1$.\n\nWrite a program that reads the description of each task in order and computes the minimum time needed to finish all tasks. Independent tasks can be executed simultaneously, and you may assume John's farm has enough workers to carry out any number of tasks in parallel.", "inputFormat": "- Line $1$: an integer $n\\ (3 \\le n \\le 10{,}000)$, the number of tasks to complete.\n- Lines $2$ to $n+1$: each line contains space-separated integers, representing:\n  - the task index (guaranteed to appear in strictly increasing order from $1$ to $n$ in the input file);\n  - the time required to complete the task $len\\ (1 \\le len \\le 100)$;\n  - zero or more preparatory tasks, terminated by a single $0$. If a task has no preparatory tasks, it is described by a single $0$.\n  \nThere are no extra spaces anywhere in the input file.", "outputFormat": "Output a single integer: the minimum time required to complete all tasks.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "杂务", "background": null, "description": "John 的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。\n\n当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务 $1$。\n\nJohn 有需要完成的 $n$ 个杂务的清单，并且这份清单是有一定顺序的，杂务 $k\\ (k>1)$ 的准备工作只可能在杂务 $1$ 至 $k-1$ 中。\n\n写一个程序依次读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定 John 的农场有足够多的工人来同时完成任意多项任务。", "inputFormat": "第 $1$ 行，一个整数 $n\\ (3 \\le n \\le 10{,}000)$，必须完成的杂务的数目；\n\n第 $2$ 至 $n+1$ 行，每行有一些用空格隔开的整数，分别表示：\n\n- 工作序号（保证在输入文件中是从 $1$ 到 $n$ 有序递增的）；\n- 完成工作所需要的时间 $len\\ (1 \\le len \\le 100)$；\n- 一些必须完成的准备工作，总数不超过 $100$ 个，由一个数字 $0$ 结束。有些杂务没有需要准备的工作只描述一个单独的 $0$。\n\n保证整个输入文件中不会出现多余的空格。", "outputFormat": "一个整数，表示完成所有杂务所需的最短时间。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1114", "type": "P", "difficulty": 3, "samples": [["9\n0 1 0 0 0 1 1 0 0\n", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["线性数据结构", "前缀和"], "title": "“非常男女”计划", "background": "", "description": "近来，初一年的 `XXX` 小朋友致力于研究班上同学的配对问题（别想太多，仅是舞伴），通过各种推理和实验，他掌握了大量的实战经验。例如，据他观察，身高相近的人似乎比较合得来。\n\n万圣节来临之际，`XXX` 准备在学校策划一次大型的 “非常男女” 配对活动。对于这次活动的参与者，`XXX` 有自己独特的选择方式。他希望能选择男女人数相等且身高都很接近的一些人。这种选择方式实现起来很简单。他让学校的所有人按照身高排成一排，然后从中选出连续的若干个人，使得这些人中男女人数相等。为了使活动更热闹，`XXX` 当然希望他能选出的人越多越好。请编写程序告诉他，他最多可以选出多少人来。\n", "inputFormat": "第一行有一个正整数 $n\\ (1\\le n \\le 10^5)$，代表学校的人数。\n\n第二行有 $n$ 个用空格隔开的数，这些数只能是 $0$ 或 $1$，其中，$0$ 代表是一个女生，$1$ 代表是一个男生。\n", "outputFormat": "输出一个非负整数。这个数表示在输入数据中最长的一段男女人数相等的子区间的长度。\n\n如果不存在男女人数相等的子区间，请输出 $0$。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "\"The 'Fei Chang Nan Nu' Plan\"", "background": null, "description": "Lately, seventh-grader \"XXX\" has been studying how to pair up classmates (don’t overthink it—just dance partners). Through various reasoning and experiments, he has gained a lot of hands-on experience. For example, he observed that people with similar heights seem to get along better.\n\nWith Halloween approaching, \"XXX\" plans to organize a large-scale \"Fei Chang Nan Nu\" pairing event at school. He has his own unique way of selecting participants: he wants to choose an equal number of boys and girls whose heights are all very close. This is easy to achieve. He asks everyone in the school to line up in order of height, then selects a consecutive segment of people such that the number of boys and girls in that segment is equal. To make the event livelier, \"XXX\" naturally wants to select as many people as possible. Please write a program to tell him the maximum number of people he can select.", "inputFormat": "The first line contains a positive integer $n\\ (1\\le n \\le 10^5)$, representing the number of people in the school.\n\nThe second line contains $n$ space-separated numbers, each of which is $0$ or $1$. Here, $0$ represents a girl and $1$ represents a boy.", "outputFormat": "Output a non-negative integer. This number indicates the length of the longest contiguous subarray in the input where the number of boys and girls is equal.\n\nIf no such subarray exists, output $0$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "“非常男女”计划", "background": "", "description": "近来，初一年的 `XXX` 小朋友致力于研究班上同学的配对问题（别想太多，仅是舞伴），通过各种推理和实验，他掌握了大量的实战经验。例如，据他观察，身高相近的人似乎比较合得来。\n\n万圣节来临之际，`XXX` 准备在学校策划一次大型的 “非常男女” 配对活动。对于这次活动的参与者，`XXX` 有自己独特的选择方式。他希望能选择男女人数相等且身高都很接近的一些人。这种选择方式实现起来很简单。他让学校的所有人按照身高排成一排，然后从中选出连续的若干个人，使得这些人中男女人数相等。为了使活动更热闹，`XXX` 当然希望他能选出的人越多越好。请编写程序告诉他，他最多可以选出多少人来。\n", "inputFormat": "第一行有一个正整数 $n\\ (1\\le n \\le 10^5)$，代表学校的人数。\n\n第二行有 $n$ 个用空格隔开的数，这些数只能是 $0$ 或 $1$，其中，$0$ 代表是一个女生，$1$ 代表是一个男生。\n", "outputFormat": "输出一个非负整数。这个数表示在输入数据中最长的一段男女人数相等的子区间的长度。\n\n如果不存在男女人数相等的子区间，请输出 $0$。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1115", "type": "P", "difficulty": 2, "samples": [["7\n2 -4 3 -1 2 -4 3\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "贪心", "递推", "分治", "前缀和", "线性 DP"], "title": "最大子段和", "background": "", "description": "给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。\n", "inputFormat": "第一行是一个整数，表示序列的长度 $n$。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个数字 $a_i$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 样例 1 解释\n\n选取 $[3, 5]$ 子段 $\\{3, -1, 2\\}$，其和为 $4$。\n\n#### 数据规模与约定\n\n- 对于 $40\\%$ 的数据，保证 $n \\leq 2 \\times 10^3$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 2 \\times 10^5$，$-10^4 \\leq a_i \\leq 10^4$。\n\n---\n\n2026/01/21：增加一组 [hack 数据](https://www.luogu.com.cn/ticket/KLET103093)。", "locale": "zh-CN", "translations": {"en": {"title": "Maximum Subarray Sum", "background": null, "description": "Given a sequence $a$ of length $n$, choose a non-empty contiguous subarray whose sum is maximized.", "inputFormat": "The first line contains an integer $n$, the length of the sequence.\nThe second line contains $n$ integers; the $i$-th is $a_i$.", "outputFormat": "Output one line with a single integer, the answer.", "hint": "- Explanation for Sample 1: Choose the subarray $[3, 5]$, which is $\\{3, -1, 2\\}$; its sum is $4$.\n- Constraints:\n  - For 40% of the testdata, it is guaranteed that $n \\le 2 \\times 10^3$.\n  - For 100% of the testdata, it is guaranteed that $1 \\le n \\le 2 \\times 10^5$ and $-10^4 \\le a_i \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最大子段和", "background": "", "description": "给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。\n", "inputFormat": "第一行是一个整数，表示序列的长度 $n$。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个数字 $a_i$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 样例 1 解释\n\n选取 $[3, 5]$ 子段 $\\{3, -1, 2\\}$，其和为 $4$。\n\n#### 数据规模与约定\n\n- 对于 $40\\%$ 的数据，保证 $n \\leq 2 \\times 10^3$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 2 \\times 10^5$，$-10^4 \\leq a_i \\leq 10^4$。\n\n---\n\n2026/01/21：增加一组 [hack 数据](https://www.luogu.com.cn/ticket/KLET103093)。", "locale": "zh-CN"}}}
{"pid": "P1116", "type": "P", "difficulty": 2, "samples": [["4\n4 3 2 1 ", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "排序"], "title": "车厢重组", "background": "", "description": "在一个旧式的火车站旁边有一座桥，其桥面可以绕河中心的桥墩水平旋转。一个车站的职工发现桥的长度最多能容纳两节车厢，如果将桥旋转 $180$ 度，则可以把相邻两节车厢的位置交换，用这种方法可以重新排列车厢的顺序。于是他就负责用这座桥将进站的车厢按车厢号从小到大排列。他退休后，火车站决定将这一工作自动化，其中一项重要的工作是编一个程序，输入初始的车厢顺序，计算最少用多少步就能将车厢排序。\n", "inputFormat": "共两行。  \n\n第一行是车厢总数 $N( \\le 1000)$。\n  \n第二行是 $N$ 个不同的数表示初始的车厢顺序。  \n（**注**：实际上数据中并不都在同一行，有可能分行输入）\n", "outputFormat": "一个整数，最少的旋转次数。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Carriage Reordering", "background": null, "description": "Next to an old-style railway station there is a bridge whose deck can rotate horizontally around the pier at the center of the river. A station worker discovered that the bridge can hold at most two carriages. If the bridge is rotated by $180$ degrees, the positions of two adjacent carriages can be swapped. Using this method, the order of the carriages can be rearranged. He was responsible for rearranging incoming carriages in increasing order of their carriage numbers. After he retired, the station decided to automate this work. One important task is to write a program that, given the initial order of the carriages, computes the minimum number of steps needed to sort the carriages.", "inputFormat": "The input consists of two parts.\n\nThe first line is the total number of carriages $N( \\le 10000)$.\n\nThe second line contains $N$ distinct integers representing the initial order of the carriages.  \n（Note: In the testdata, these integers are not necessarily on a single line and may be split across multiple lines.）", "outputFormat": "Output a single integer, the minimum number of rotations.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "车厢重组", "background": "", "description": "在一个旧式的火车站旁边有一座桥，其桥面可以绕河中心的桥墩水平旋转。一个车站的职工发现桥的长度最多能容纳两节车厢，如果将桥旋转 $180$ 度，则可以把相邻两节车厢的位置交换，用这种方法可以重新排列车厢的顺序。于是他就负责用这座桥将进站的车厢按车厢号从小到大排列。他退休后，火车站决定将这一工作自动化，其中一项重要的工作是编一个程序，输入初始的车厢顺序，计算最少用多少步就能将车厢排序。\n", "inputFormat": "共两行。  \n\n第一行是车厢总数 $N( \\le 1000)$。\n  \n第二行是 $N$ 个不同的数表示初始的车厢顺序。  \n（**注**：实际上数据中并不都在同一行，有可能分行输入）\n", "outputFormat": "一个整数，最少的旋转次数。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1117", "type": "P", "difficulty": 6, "samples": [["4\naabbbb\ncccccc\naabaabaabaa\nbbaabaababaaba\n", "3\n5\n4\n7\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "2016", "NOI", "O2优化", "枚举", "ST 表", "后缀数组 SA", "差分", "调和级数"], "title": "[NOI2016] 优秀的拆分", "background": "", "description": "如果一个字符串可以被拆分为 $\\text{AABB}$ 的形式，其中 $\\text{A}$ 和 $\\text{B}$ 是任意**非空**字符串，则我们称该字符串的这种拆分是优秀的。  \n例如，对于字符串 $ \\texttt{aabaabaa} $ ，如果令 $\\text{A}=\\texttt{aab}$，$\\text{B}=\\texttt{a}$，我们就找到了这个字符串拆分成 $\\text{AABB}$ 的一种方式。\n\n一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。  \n比如我们令 $\\text{A}=\\texttt{a}$，$\\text{B}=\\texttt{baa}$，也可以用 $\\text{AABB}$ 表示出上述字符串；但是，字符串 $\\texttt{abaabaa}$ 就没有优秀的拆分。\n\n现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。\n\n以下事项需要注意：\n\n1. 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。\n2. 在一个拆分中，允许出现 $\\text{A}=\\text{B}$。例如 $\\texttt{cccc}$ 存在拆分 $\\text{A}=\\text{B}=\\texttt{c}$。\n3. 字符串本身也是它的一个子串。", "inputFormat": "每个输入文件包含多组数据。\n\n输入文件的第一行只有一个整数 $T$，表示数据的组数。\n\n接下来 $T$ 行，每行包含一个仅由英文小写字母构成的字符串 $S$，意义如题所述。", "outputFormat": "输出 $T$ 行，每行包含一个整数，表示字符串 $S$ 所有子串的所有拆分中，总共有多少个是优秀的拆分。", "hint": "### 样例解释\n\n我们用 $S[i, j]$ 表示字符串 $S$ 第 $i$ 个字符到第 $j$ 个字符的子串（从 $1$ 开始计数）。\n\n第一组数据中，共有三个子串存在优秀的拆分：  \n$S[1,4]=\\texttt{aabb}$，优秀的拆分为 $\\text{A}=\\texttt{a}$，$\\text{B}=\\texttt{b}$；  \n$S[3,6]=\\texttt{bbbb}$，优秀的拆分为 $\\text{A}=\\texttt{b}$，$\\text{B}=\\texttt{b}$；  \n$S[1,6]=\\texttt{aabbbb}$，优秀的拆分为 $\\text{A}=\\texttt{a}$，$\\text{B}=\\texttt{bb}$。  \n而剩下的子串不存在优秀的拆分，所以第一组数据的答案是 $3$。\n\n第二组数据中，有两类，总共四个子串存在优秀的拆分：  \n对于子串 $S[1,4]=S[2,5]=S[3,6]=\\texttt{cccc}$，它们优秀的拆分相同，均为 $\\text{A}=\\texttt{c}$，$\\text{B}=\\texttt{c}$，但由于这些子串位置不同，因此要计算三次；  \n对于子串 $S[1,6]=\\texttt{cccccc}$，它优秀的拆分有两种：$\\text{A}=\\texttt{c}$，$\\text{B}=\\texttt{cc}$ 和 $\\text{A}=\\texttt{cc}$，$\\text{B}=\\texttt{c}$，它们是相同子串的不同拆分，也都要计入答案。  \n所以第二组数据的答案是 $3+2=5$。\n\n第三组数据中，$S[1,8]$ 和 $S[4,11]$ 各有两种优秀的拆分，其中 $S[1,8]$ 是问题描述中的例子，所以答案是 $2+2=4$。\n\n第四组数据中，$S[1,4]$，$S[6,11]$，$S[7,12]$，$S[2,11]$，$S[1,8]$ 各有一种优秀的拆分，$S[3,14]$ 有两种优秀的拆分，所以答案是 $5+2=7$。\n\n### 数据范围\n\n对于全部的测试点，保证 $1 \\leq T \\leq 10$。以下对数据的限制均是对于单组输入数据而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件。\n\n我们假定 $n$ 为字符串 $S$ 的长度，每个测试点的详细数据范围见下表：\n\n::cute-table{tuack}\n\n| 测试点编号   | $n \\leq$  | 特殊性质           |\n| :----------: | :-------: | :----------------: |\n| $1 \\sim 2$   | $300$     | $S$ 中所有字符相同 |\n| $3 \\sim 4$   | $2\\,000$  | ^ |\n| $5 \\sim 6$   | $10$      | 无                   |\n| $7 \\sim 8$   | $20$      | ^ |\n| $9 \\sim 10$  | $30$      | ^ |\n| $11 \\sim 12$ | $50$      | ^ |\n| $13 \\sim 14$ | $100$     | ^ |\n| $15$         | $200$     | ^ |\n| $16$         | $300$     | ^ |\n| $17$         | $500$     | ^ |\n| $18$         | $1\\,000$  | ^ |\n| $19$         | $2\\,000$  | ^ |\n| $20$         | $30\\,000$ | ^ |", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2016] Excellent Split", "background": null, "description": "If a string can be split into the form $\\text{AABB}$, where $\\text{A}$ and $\\text{B}$ are any non-empty strings, then we call this split of the string excellent. For example, for the string $\\texttt{aabaabaa}$, if we set $\\text{A}=\\texttt{aab}$ and $\\text{B}=\\texttt{a}$, we have found one way to split this string into $\\text{AABB}$.\n\nA string may have no excellent split, or it may have more than one excellent split. For example, if we set $\\text{A}=\\texttt{a}$ and $\\text{B}=\\texttt{baa}$, the above string can also be expressed as $\\text{AABB}$; however, the string $\\texttt{abaabaa}$ has no excellent split.\n\nNow given a string $S$ of length $n$, we need to count, over all substrings of $S$ and all their possible splits, the total number of excellent splits. Here a substring refers to a contiguous segment of the string.\n\nNotes:\n1. Identical substrings that appear at different positions are considered different substrings, and their excellent splits are all counted in the answer.\n2. In a split, $\\text{A}=\\text{B}$ is allowed. For example, $\\texttt{cccc}$ has the split $\\text{A}=\\text{B}=\\texttt{c}$.\n3. The string itself is also one of its substrings.", "inputFormat": "Each input file contains multiple test cases.\n\nThe first line of the input file contains a single integer $T$, indicating the number of test cases.\n\nThen follow $T$ lines, each containing a string $S$ consisting only of lowercase English letters, as described above.", "outputFormat": "Output $T$ lines. Each line contains an integer, indicating the total number of excellent splits among all splits of all substrings of $S$.", "hint": "Sample explanation.\n\nWe use $S[i, j]$ to denote the substring of $S$ from the $i$-th character to the $j$-th character (1-based indexing).\n\nIn the first dataset, there are three substrings with excellent splits: $S[1,4]=\\texttt{aabb}$, whose excellent split is $\\text{A}=\\texttt{a}$, $\\text{B}=\\texttt{b}$; $S[3,6]=\\texttt{bbbb}$, whose excellent split is $\\text{A}=\\texttt{b}$, $\\text{B}=\\texttt{b}$; $S[1,6]=\\texttt{aabbbb}$, whose excellent split is $\\text{A}=\\texttt{a}$, $\\text{B}=\\texttt{bb}$. The remaining substrings have no excellent splits, so the answer for the first dataset is $3$.\n\nIn the second dataset, there are in total four substrings that have excellent splits, divided into two types: for the substrings $S[1,4]=S[2,5]=S[3,6]=\\texttt{cccc}$, they share the same excellent split $\\text{A}=\\texttt{c}$, $\\text{B}=\\texttt{c}$, but since these substrings are at different positions, they are counted three times; for the substring $S[1,6]=\\texttt{cccccc}$, it has two excellent splits: $\\text{A}=\\texttt{c}$, $\\text{B}=\\texttt{cc}$ and $\\text{A}=\\texttt{cc}$, $\\text{B}=\\texttt{c}$, which are different splits of the same substring and are both counted. Therefore, the answer for the second dataset is $3+2=5$.\n\nIn the third dataset, $S[1,8]$ and $S[4,11]$ each have two excellent splits. Among them, $S[1,8]$ is the example in the problem statement, so the answer is $2+2=4$.\n\nIn the fourth dataset, $S[1,4]$, $S[6,11]$, $S[7,12]$, $S[2,11]$, and $S[1,8]$ each have one excellent split, while $S[3,14]$ has two excellent splits, so the answer is $5+2=7$.\n\n### Constraints\n\nFor all test points, it is guaranteed that $1 \\leq T \\leq 10$. The following limits apply to a single input within a dataset; that is, within the same test point, all of its $T$ datasets satisfy the constraints.\n\nLet $n$ be the length of string $S$. The detailed constraints for each test point are shown in the table below:\n\n::cute-table{tuack}\n\n| Test point ID | $n \\leq$  | Special property                 |\n| :-----------: | :-------: | :------------------------------: |\n| $1 \\sim 2$    | $300$     | All characters in $S$ are the same |\n| $3 \\sim 4$    | $2\\,000$  | ^                                |\n| $5 \\sim 6$    | $10$      | None                             |\n| $7 \\sim 8$    | $20$      | ^                                |\n| $9 \\sim 10$   | $30$      | ^                                |\n| $11 \\sim 12$  | $50$      | ^                                |\n| $13 \\sim 14$  | $100$     | ^                                |\n| $15$          | $200$     | ^                                |\n| $16$          | $300$     | ^                                |\n| $17$          | $500$     | ^                                |\n| $18$          | $1\\,000$  | ^                                |\n| $19$          | $2\\,000$  | ^                                |\n| $20$          | $30\\,000$ | ^                                |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2016] 优秀的拆分", "background": "", "description": "如果一个字符串可以被拆分为 $\\text{AABB}$ 的形式，其中 $\\text{A}$ 和 $\\text{B}$ 是任意**非空**字符串，则我们称该字符串的这种拆分是优秀的。  \n例如，对于字符串 $ \\texttt{aabaabaa} $ ，如果令 $\\text{A}=\\texttt{aab}$，$\\text{B}=\\texttt{a}$，我们就找到了这个字符串拆分成 $\\text{AABB}$ 的一种方式。\n\n一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。  \n比如我们令 $\\text{A}=\\texttt{a}$，$\\text{B}=\\texttt{baa}$，也可以用 $\\text{AABB}$ 表示出上述字符串；但是，字符串 $\\texttt{abaabaa}$ 就没有优秀的拆分。\n\n现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。\n\n以下事项需要注意：\n\n1. 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。\n2. 在一个拆分中，允许出现 $\\text{A}=\\text{B}$。例如 $\\texttt{cccc}$ 存在拆分 $\\text{A}=\\text{B}=\\texttt{c}$。\n3. 字符串本身也是它的一个子串。", "inputFormat": "每个输入文件包含多组数据。\n\n输入文件的第一行只有一个整数 $T$，表示数据的组数。\n\n接下来 $T$ 行，每行包含一个仅由英文小写字母构成的字符串 $S$，意义如题所述。", "outputFormat": "输出 $T$ 行，每行包含一个整数，表示字符串 $S$ 所有子串的所有拆分中，总共有多少个是优秀的拆分。", "hint": "### 样例解释\n\n我们用 $S[i, j]$ 表示字符串 $S$ 第 $i$ 个字符到第 $j$ 个字符的子串（从 $1$ 开始计数）。\n\n第一组数据中，共有三个子串存在优秀的拆分：  \n$S[1,4]=\\texttt{aabb}$，优秀的拆分为 $\\text{A}=\\texttt{a}$，$\\text{B}=\\texttt{b}$；  \n$S[3,6]=\\texttt{bbbb}$，优秀的拆分为 $\\text{A}=\\texttt{b}$，$\\text{B}=\\texttt{b}$；  \n$S[1,6]=\\texttt{aabbbb}$，优秀的拆分为 $\\text{A}=\\texttt{a}$，$\\text{B}=\\texttt{bb}$。  \n而剩下的子串不存在优秀的拆分，所以第一组数据的答案是 $3$。\n\n第二组数据中，有两类，总共四个子串存在优秀的拆分：  \n对于子串 $S[1,4]=S[2,5]=S[3,6]=\\texttt{cccc}$，它们优秀的拆分相同，均为 $\\text{A}=\\texttt{c}$，$\\text{B}=\\texttt{c}$，但由于这些子串位置不同，因此要计算三次；  \n对于子串 $S[1,6]=\\texttt{cccccc}$，它优秀的拆分有两种：$\\text{A}=\\texttt{c}$，$\\text{B}=\\texttt{cc}$ 和 $\\text{A}=\\texttt{cc}$，$\\text{B}=\\texttt{c}$，它们是相同子串的不同拆分，也都要计入答案。  \n所以第二组数据的答案是 $3+2=5$。\n\n第三组数据中，$S[1,8]$ 和 $S[4,11]$ 各有两种优秀的拆分，其中 $S[1,8]$ 是问题描述中的例子，所以答案是 $2+2=4$。\n\n第四组数据中，$S[1,4]$，$S[6,11]$，$S[7,12]$，$S[2,11]$，$S[1,8]$ 各有一种优秀的拆分，$S[3,14]$ 有两种优秀的拆分，所以答案是 $5+2=7$。\n\n### 数据范围\n\n对于全部的测试点，保证 $1 \\leq T \\leq 10$。以下对数据的限制均是对于单组输入数据而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件。\n\n我们假定 $n$ 为字符串 $S$ 的长度，每个测试点的详细数据范围见下表：\n\n::cute-table{tuack}\n\n| 测试点编号   | $n \\leq$  | 特殊性质           |\n| :----------: | :-------: | :----------------: |\n| $1 \\sim 2$   | $300$     | $S$ 中所有字符相同 |\n| $3 \\sim 4$   | $2\\,000$  | ^ |\n| $5 \\sim 6$   | $10$      | 无                   |\n| $7 \\sim 8$   | $20$      | ^ |\n| $9 \\sim 10$  | $30$      | ^ |\n| $11 \\sim 12$ | $50$      | ^ |\n| $13 \\sim 14$ | $100$     | ^ |\n| $15$         | $200$     | ^ |\n| $16$         | $300$     | ^ |\n| $17$         | $500$     | ^ |\n| $18$         | $1\\,000$  | ^ |\n| $19$         | $2\\,000$  | ^ |\n| $20$         | $30\\,000$ | ^ |", "locale": "zh-CN"}}}
{"pid": "P1118", "type": "P", "difficulty": 3, "samples": [["4 16", "3 1 2 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2006", "USACO", "枚举", "深度优先搜索 DFS"], "title": "[USACO06FEB] Backward Digit Sums G/S", "background": null, "description": "`FJ` and his cows enjoy playing a mental game. They write down the numbers from $1$ to $ N(1 \\le N  \\le 12)$ in a certain order and then sum adjacent numbers to produce a new list with one fewer number.  They repeat this until only a single number is left.  For example, one instance of the game (when $N=4$) might go like this:\n\n```cpp\n    3   1   2   4\n      4   3   6\n        7   9\n         16\n```\nBehind `FJ`'s back, the cows have started playing a more difficult game, in which they try to determine the starting sequence from only the final total and the number $N$.  Unfortunately, the game is a bit above `FJ`'s mental arithmetic capabilities.\n\n\nWrite a program to help `FJ` play the game and keep up with the cows.", "inputFormat": "Line 1: Two space-separated integers: $N$ and the final sum.", "outputFormat": "Line 1: An ordering of the integers $1\\cdots N$ that leads to the given sum. If there are multiple solutions, choose the one that is lexicographically least, i.e., that puts smaller numbers first.", "hint": "- For $40\\%$ of the data, $1\\le N\\le 7$;\n- For $80\\%$ of the data, $1\\le N \\le 10$;\n- For $100\\%$ of the data, $1\\le N \\le 12$, $1\\le sum\\le 12345$.", "locale": "en", "translations": {"en": {"title": "[USACO06FEB] Backward Digit Sums G/S", "background": null, "description": "`FJ` and his cows enjoy playing a mental game. They write down the numbers from $1$ to $ N(1 \\le N  \\le 12)$ in a certain order and then sum adjacent numbers to produce a new list with one fewer number.  They repeat this until only a single number is left.  For example, one instance of the game (when $N=4$) might go like this:\n\n```cpp\n    3   1   2   4\n      4   3   6\n        7   9\n         16\n```\nBehind `FJ`'s back, the cows have started playing a more difficult game, in which they try to determine the starting sequence from only the final total and the number $N$.  Unfortunately, the game is a bit above `FJ`'s mental arithmetic capabilities.\n\n\nWrite a program to help `FJ` play the game and keep up with the cows.", "inputFormat": "Line 1: Two space-separated integers: $N$ and the final sum.", "outputFormat": "Line 1: An ordering of the integers $1\\cdots N$ that leads to the given sum. If there are multiple solutions, choose the one that is lexicographically least, i.e., that puts smaller numbers first.", "hint": "- For $40\\%$ of the data, $1\\le N\\le 7$;\n- For $80\\%$ of the data, $1\\le N \\le 10$;\n- For $100\\%$ of the data, $1\\le N \\le 12$, $1\\le sum\\le 12345$.", "locale": "en"}, "zh-CN": {"title": "[USACO06FEB] Backward Digit Sums G/S", "background": "", "description": "`FJ` 和他的奶牛们喜欢玩一个心算游戏。他们将数字从 $1$ 到 $N(1 \\le N \\le 12)$ 按某种顺序写下来，然后将相邻的数字相加，得到一个数字更少的新列表。他们重复这个过程，直到只剩下一个数字。例如，游戏的一种情况（当 $N=4$ 时）可能是这样的：\n\n```cpp\n    3   1   2   4\n      4   3   6\n        7   9\n         16\n```\n在 `FJ` 背后，奶牛们开始玩一个更难的游戏，她们试图从最终的总和和数字 $N$ 中确定起始序列。不幸的是，这个游戏有点超出了 `FJ` 的心算能力。\n\n\n编写一个程序来帮助 `FJ` 玩这个游戏，并跟上奶牛们的步伐。\n\n", "inputFormat": "共一行两个正整数 $n,sum$。\n", "outputFormat": "输出包括一行，为字典序最小的那个答案。\n\n当无解的时候，请什么也不输出。\n", "hint": "- 对于 $40\\%$ 的数据，$1\\le N\\le 7$；\n- 对于 $80\\%$ 的数据，$1\\le N \\le 10$；\n- 对于 $100\\%$ 的数据，$1\\le N \\le 12$，$1\\le sum\\le 12345$。\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P1119", "type": "P", "difficulty": 4, "samples": [["4 5\n1 2 3 4\n0 2 1\n2 3 1\n3 1 2\n2 1 4\n0 3 5\n4\n2 0 2\n0 1 2\n0 1 3\n0 1 4", "-1\n-1\n5\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "枚举", "最短路"], "title": "灾后重建", "background": "B 地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。\n", "description": "给出 B 地区的村庄数 $N$，村庄编号从 $0$ 到 $N-1$，和所有 $M$ 条公路的长度，公路是双向的。并给出第 $i$ 个村庄重建完成的时间 $t_i$，你可以认为是同时开始重建并在第 $t_i$ 天重建完成，并且在当天即可通车。若 $t_i$ 为 $0$ 则说明地震未对此地区造成损坏，一开始就可以通车。之后有 $Q$ 个询问 $(x,y,t)$，对于每个询问你要回答在第 $t$ 天，从村庄 $x$ 到村庄 $y$ 的最短路径长度为多少。如果无法找到从 $x$ 村庄到 $y$ 村庄的路径，经过若干个已重建完成的村庄，或者村庄 $x$ 或村庄 $y$ 在第 $t$ 天仍未重建完成，则需要输出 $-1$。", "inputFormat": "第一行包含两个正整数 $N,M$，表示了村庄的数目与公路的数量。\n\n第二行包含 $N$ 个非负整数 $t_0,t_1,\\cdots,t_{N-1}$，表示了每个村庄重建完成的时间，数据保证了 $t_0 \\le t_1 \\le \\cdots \\le t_{N-1}$。\n\n接下来 $M$ 行，每行 $3$ 个非负整数 $i,j,w$，$w$ 不超过 $10000$，表示了有一条连接村庄 $i$ 与村庄 $j$ 的道路，长度为 $w$，保证 $i\\neq j$，且对于任意一对村庄只会存在一条道路。\n\n接下来一行也就是 $M+3$ 行包含一个正整数 $Q$，表示 $Q$ 个询问。\n\n接下来 $Q$ 行，每行 $3$ 个非负整数 $x,y,t$，询问在第 $t$ 天，从村庄 $x$ 到村庄 $y$ 的最短路径长度为多少，数据保证了 $t$ 是不下降的。", "outputFormat": "共 $Q$ 行，对每一个询问 $(x,y,t)$ 输出对应的答案，即在第 $t$ 天，从村庄 $x$ 到村庄 $y$ 的最短路径长度为多少。如果在第 $t$ 天无法找到从 $x$ 村庄到 $y$ 村庄的路径，经过若干个已重建完成的村庄，或者村庄 $x$ 或村庄 $y$ 在第 $t$ 天仍未修复完成，则输出 $-1$。", "hint": "- 对于 $30\\%$ 的数据，有 $N\\le 50$；\n- 对于 $30\\%$ 的数据，有 $t_i=0$，其中有 $20\\%$ 的数据有 $t_i=0$ 且 $N>50$；\n- 对于 $50\\%$ 的数据，有 $Q\\le 100$；\n- 对于 $100\\%$ 的数据，有 $1\\le N\\le 200$，$0\\le M\\le \\dfrac{N\\times(N-1)}{2}$，$1\\le Q\\le 50000$，所有输入数据涉及整数均不超过 $10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Post-disaster Reconstruction", "background": null, "description": "Given the number of villages $N$ in Region B, numbered from $0$ to $N-1$, and the lengths of all $M$ bidirectional roads. For each village $i$, you are given the day it is completed $t_i$. All reconstructions start simultaneously, and village $i$ is completed on day $t_i$, becoming open to traffic on that day. If $t_i$ is $0$, the earthquake did not damage that village and it is open from the beginning. Then there are $Q$ queries $(x,y,t)$. For each query, answer the length of the shortest path from village $x$ to village $y$ on day $t$. If there is no path from $x$ to $y$ using only villages that have been completed by day $t$, or if village $x$ or village $y$ has not been completed by day $t$, output $-1$.", "inputFormat": "- The first line contains two positive integers $N,M$, the number of villages and the number of roads.\n- The second line contains $N$ non-negative integers $t_0,t_1,\\cdots,t_{N-1}$, the completion day of each village, and it is guaranteed that $t_0 \\le t_1 \\le \\cdots \\le t_{N-1}$.\n- The next $M$ lines each contain three non-negative integers $i,j,w$ with $w \\le 10000$, indicating a road between villages $i$ and $j$ with length $w$. It is guaranteed that $i \\ne j$, and for any pair of villages there is at most one road.\n- The next line contains a positive integer $Q$, the number of queries.\n- The next $Q$ lines each contain three non-negative integers $x,y,t$, asking for the shortest path length from village $x$ to village $y$ on day $t$. It is guaranteed that $t$ is non-decreasing across the queries.", "outputFormat": "Output $Q$ lines. For each query $(x,y,t)$, output the corresponding answer: the length of the shortest path from village $x$ to village $y$ on day $t$. If on day $t$ there is no path from $x$ to $y$ using only villages that have been completed by day $t$, or if village $x$ or village $y$ has not been completed by day $t$, output $-1$.", "hint": "- For $30\\%$ of the testdata, $N \\le 50$.\n- For $30\\%$ of the testdata, $t_i=0$; among them, for $20\\%$ of the testdata, $t_i=0$ and $N>50$.\n- For $50\\%$ of the testdata, $Q \\le 100$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 200$, $0 \\le M \\le \\dfrac{N\\times(N-1)}{2}$, $1 \\le Q \\le 50000$, and all integers in the input are at most $10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "灾后重建", "background": "B 地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。\n", "description": "给出 B 地区的村庄数 $N$，村庄编号从 $0$ 到 $N-1$，和所有 $M$ 条公路的长度，公路是双向的。并给出第 $i$ 个村庄重建完成的时间 $t_i$，你可以认为是同时开始重建并在第 $t_i$ 天重建完成，并且在当天即可通车。若 $t_i$ 为 $0$ 则说明地震未对此地区造成损坏，一开始就可以通车。之后有 $Q$ 个询问 $(x,y,t)$，对于每个询问你要回答在第 $t$ 天，从村庄 $x$ 到村庄 $y$ 的最短路径长度为多少。如果无法找到从 $x$ 村庄到 $y$ 村庄的路径，经过若干个已重建完成的村庄，或者村庄 $x$ 或村庄 $y$ 在第 $t$ 天仍未重建完成，则需要输出 $-1$。", "inputFormat": "第一行包含两个正整数 $N,M$，表示了村庄的数目与公路的数量。\n\n第二行包含 $N$ 个非负整数 $t_0,t_1,\\cdots,t_{N-1}$，表示了每个村庄重建完成的时间，数据保证了 $t_0 \\le t_1 \\le \\cdots \\le t_{N-1}$。\n\n接下来 $M$ 行，每行 $3$ 个非负整数 $i,j,w$，$w$ 不超过 $10000$，表示了有一条连接村庄 $i$ 与村庄 $j$ 的道路，长度为 $w$，保证 $i\\neq j$，且对于任意一对村庄只会存在一条道路。\n\n接下来一行也就是 $M+3$ 行包含一个正整数 $Q$，表示 $Q$ 个询问。\n\n接下来 $Q$ 行，每行 $3$ 个非负整数 $x,y,t$，询问在第 $t$ 天，从村庄 $x$ 到村庄 $y$ 的最短路径长度为多少，数据保证了 $t$ 是不下降的。", "outputFormat": "共 $Q$ 行，对每一个询问 $(x,y,t)$ 输出对应的答案，即在第 $t$ 天，从村庄 $x$ 到村庄 $y$ 的最短路径长度为多少。如果在第 $t$ 天无法找到从 $x$ 村庄到 $y$ 村庄的路径，经过若干个已重建完成的村庄，或者村庄 $x$ 或村庄 $y$ 在第 $t$ 天仍未修复完成，则输出 $-1$。", "hint": "- 对于 $30\\%$ 的数据，有 $N\\le 50$；\n- 对于 $30\\%$ 的数据，有 $t_i=0$，其中有 $20\\%$ 的数据有 $t_i=0$ 且 $N>50$；\n- 对于 $50\\%$ 的数据，有 $Q\\le 100$；\n- 对于 $100\\%$ 的数据，有 $1\\le N\\le 200$，$0\\le M\\le \\dfrac{N\\times(N-1)}{2}$，$1\\le Q\\le 50000$，所有输入数据涉及整数均不超过 $10^5$。", "locale": "zh-CN"}}}
{"pid": "P1120", "type": "P", "difficulty": 5, "samples": [["9\n5 2 1 5 2 1 5 2 1\n", "6"]], "limits": {"time": [260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "O2优化", "枚举", "剪枝", "ICPC", "CERC"], "title": "[CERC 1995] 小木棍", "background": "本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）\n\n本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)", "description": "乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过 $50$。\n\n现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。\n\n给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。", "inputFormat": "第一行是一个整数 $n$，表示小木棍的个数。  \n第二行有 $n$ 个整数，表示各个木棍的长度 $a_i$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "对于全部测试点，$1 \\leq n \\leq 65$，$1 \\leq a_i \\leq 50$。", "locale": "zh-CN", "translations": {"en": {"title": "[CERC 1995] Sticks", "background": null, "description": "George has some small wooden sticks of equal length. He randomly cut these sticks into several pieces until each piece had length no more than $50$. \n\nNow he wants to reassemble the sticks to their original form, but he has forgotten how many sticks he started with and what their lengths were.\n\nGiven the lengths of all the pieces, write a program to find the minimal possible length of the original sticks.", "inputFormat": "The first line contains an integer $n$, the number of stick pieces.  \nThe second line contains $n$ integers, the lengths $a_i$ of the pieces.", "outputFormat": "Output a single integer on one line, representing the answer.", "hint": "For all testdata, $1 \\leq n \\leq 65$, $1 \\leq a_i \\leq 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC 1995] 小木棍", "background": "本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）\n\n本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)", "description": "乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过 $50$。\n\n现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。\n\n给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。", "inputFormat": "第一行是一个整数 $n$，表示小木棍的个数。  \n第二行有 $n$ 个整数，表示各个木棍的长度 $a_i$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "对于全部测试点，$1 \\leq n \\leq 65$，$1 \\leq a_i \\leq 50$。", "locale": "zh-CN"}}}
{"pid": "P1121", "type": "P", "difficulty": 4, "samples": [["7\n2 -4 3 -1 2 -4 3\n", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "线性数据结构", "枚举"], "title": "环状最大两段子段和", "background": "", "description": "给出一段长度为 $n$ 的环状序列 $a$，即认为 $a_1$ 和 $a_n$ 是相邻的，选出其中连续不重叠且非空的两段使得这两段和最大。\n", "inputFormat": "第一行是一个整数 $n$，表示序列的长度。\n\n第二行有 $n$ 个整数，描述序列 $a$，第 $i$ 个数字表示  $a_i$。", "outputFormat": "一行一个整数，为最大的两段子段和是多少。\n", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $2 \\leq n \\leq 2 \\times 10^5$，$-10^4 \\leq a_i \\leq 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "Maximum Sum of Two Non-overlapping Subarrays on a Circle", "background": null, "description": "Given a circular sequence $a$ of length $n$ (that is, $a_1$ and $a_n$ are adjacent), choose two contiguous, non-overlapping, and non-empty subarrays whose total sum is maximized.", "inputFormat": "The first line contains an integer $n$, the length of the sequence.\nThe second line contains $n$ integers describing the sequence $a$; the $i$-th number is $a_i$.", "outputFormat": "Output a single integer on one line: the maximum possible sum of two subarrays.", "hint": "Constraints\n\nFor all test points, it is guaranteed that $2 \\leq n \\leq 2 \\times 10^5$ and $-10^4 \\leq a_i \\leq 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "环状最大两段子段和", "background": "", "description": "给出一段长度为 $n$ 的环状序列 $a$，即认为 $a_1$ 和 $a_n$ 是相邻的，选出其中连续不重叠且非空的两段使得这两段和最大。\n", "inputFormat": "第一行是一个整数 $n$，表示序列的长度。\n\n第二行有 $n$ 个整数，描述序列 $a$，第 $i$ 个数字表示  $a_i$。", "outputFormat": "一行一个整数，为最大的两段子段和是多少。\n", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $2 \\leq n \\leq 2 \\times 10^5$，$-10^4 \\leq a_i \\leq 10^4$。", "locale": "zh-CN"}}}
{"pid": "P1122", "type": "P", "difficulty": 3, "samples": [["7\n-1 -1 -1 1 1 1 0\n1 4\n2 5\n3 6\n4 7\n5 7\n6 7\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "树形 DP"], "title": "最大子树和", "background": null, "description": "小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：\n\n一株奇怪的花卉，上面共连有 $n$ 朵花，共有 $n-1$ 条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。\n\n老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。", "inputFormat": "第一行一个整数 $n\\ (1\\le n\\le 16000)$。表示原始的那株花卉上共 $n$ 朵花。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 朵花的美丽指数。\n\n接下来 $n-1$ 行每行两个整数 $a,b$，表示存在一条连接第 $a$ 朵花和第 $b$ 朵花的枝条。", "outputFormat": "一个数，表示一系列“修剪”之后所能得到的“美丽指数”之和的最大值。保证绝对值不超过 $2147483647$。", "hint": "### 数据范围及约定\n\n- 对于 $60\\%$ 的数据，有 $1\\le n\\le 1000$；\n- 对于 $100\\%$ 的数据，有 $1\\le n\\le 16000$。", "locale": "zh-CN", "translations": {"en": {"title": "Maximum Subtree Sum", "background": null, "description": "Xiao Ming is very interested in mathematics and is a diligent student who always stays after class to ask the teacher questions. One morning on his way to school by bike, he saw an old man trimming plants and suddenly thought of a problem about pruning flowers. After class that day, Xiao Ming presented the following problem to his teacher:\n\nThere is a strange plant with $n$ flowers in total, connected by $n - 1$ branches so that before pruning, no flower is isolated. Each flower has a “beauty index,” where a larger value means the flower is more beautiful; some beauty indices can be negative, meaning the flower looks unpleasant. “Pruning” means removing one of the branches, which splits the plant into two, and then discarding one of them. After a sequence of prunings, only one plant remains (which could be a single flower). The task is to perform a sequence of prunings (or none at all) to maximize the sum of the beauty indices of all flowers on the remaining plant.\n\nThe teacher quickly gave the correct solution. Seeing the problem solved so easily, Xiao Ming felt unsatisfied and brought it to you.", "inputFormat": "- The first line contains an integer $n$ ($1 \\le n \\le 16000$), the number of flowers on the original plant.\n- The second line contains $n$ integers. The $i$-th integer is the beauty index of the $i$-th flower.\n- The next $n - 1$ lines each contain two integers $a, b$, indicating there is a branch connecting the $a$-th flower and the $b$-th flower.", "outputFormat": "Output a single integer, the maximum possible sum of beauty indices after a sequence of prunings. The absolute value is guaranteed not to exceed $2147483647$.", "hint": "### Constraints\n\n- For $60\\%$ of the testdata, $1 \\le n \\le 1000$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 16000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最大子树和", "background": null, "description": "小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：\n\n一株奇怪的花卉，上面共连有 $n$ 朵花，共有 $n-1$ 条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。\n\n老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。", "inputFormat": "第一行一个整数 $n\\ (1\\le n\\le 16000)$。表示原始的那株花卉上共 $n$ 朵花。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 朵花的美丽指数。\n\n接下来 $n-1$ 行每行两个整数 $a,b$，表示存在一条连接第 $a$ 朵花和第 $b$ 朵花的枝条。", "outputFormat": "一个数，表示一系列“修剪”之后所能得到的“美丽指数”之和的最大值。保证绝对值不超过 $2147483647$。", "hint": "### 数据范围及约定\n\n- 对于 $60\\%$ 的数据，有 $1\\le n\\le 1000$；\n- 对于 $100\\%$ 的数据，有 $1\\le n\\le 16000$。", "locale": "zh-CN"}}}
{"pid": "P1123", "type": "P", "difficulty": 3, "samples": [["3\n4 4\n67 75 63 10\n29 29 92 14\n21 68 71 56\n8 67 91 25\n2 3\n87 70 85\n10 3 17\n3 3\n1 1 1\n1 99 1\n1 1 1\n\n", "271\n172\n99\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "枚举", "深度优先搜索 DFS", "状压 DP"], "title": "取数游戏", "background": null, "description": "一个 $N\\times M$ 的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻 $8$ 个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。", "inputFormat": "第一行有一个正整数 $T$，表示了有 $T$ 组数据。\n\n对于每一组数据，第一行有两个正整数 $N$ 和 $M$，表示了数字矩阵为 $N$ 行 $M$ 列。\n\n接下来 $N$ 行，每行 $M$ 个非负整数，描述了这个数字矩阵。", "outputFormat": "共 $T$ 行，每行一个非负整数，输出所求得的答案。", "hint": "### 样例解释\n\n对于第一组数据，取数方式如下：\n\n$$\\begin{matrix}\n[67] & 75 & 63 & 10 \\\\\n29 & 29 & [92] & 14 \\\\\n[21] & 68 & 71 & 56 \\\\\n8 & 67 & [91] & 25 \\\\\n\\end{matrix}$$\n\n\n### 数据范围及约定\n\n- 对于$20\\%$的数据，$1\\le N, M \\le 3$；\n- 对于$40\\%$的数据，$1\\le N, M\\le 4$；\n- 对于$60\\%$的数据，$1\\le N, M\\le 5$；\n- 对于$100\\%$的数据，$1\\le N, M\\le 6$，$1\\le T\\le 20$，$a_{i,j}\\le10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Number Picking Game", "background": null, "description": "Given an $N\\times M$ matrix of non-negative integers, you need to select some numbers such that no two selected numbers are adjacent. Two numbers are considered adjacent if one is in any of the 8 neighboring cells of the other (including diagonals). Find the maximum possible sum of the selected numbers.", "inputFormat": "The first line contains a positive integer $T$, indicating there are $T$ test cases.\n\nFor each test case, the first line contains two positive integers $N$ and $M$, indicating the matrix has $N$ rows and $M$ columns.\n\nThe next $N$ lines each contain $M$ non-negative integers, describing the matrix.", "outputFormat": "Output $T$ lines, each containing a single non-negative integer: the required answer.", "hint": "### Sample Explanation\n\nFor the first test case, a valid selection is as follows:\n\n$$\\begin{matrix}\n[67] & 75 & 63 & 10 \\\\\n29 & 29 & [92] & 14 \\\\\n[21] & 68 & 71 & 56 \\\\\n8 & 67 & [91] & 25 \\\\\n\\end{matrix}$$\n\n### Constraints\n\n- For 20% of the testdata, $1\\le N, M \\le 3$.\n- For 40% of the testdata, $1\\le N, M \\le 4$.\n- For 60% of the testdata, $1\\le N, M \\le 5$.\n- For 100% of the testdata, $1\\le N, M \\le 6$, $1\\le T \\le 20$, $a_{i,j}\\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "取数游戏", "background": null, "description": "一个 $N\\times M$ 的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻 $8$ 个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。", "inputFormat": "第一行有一个正整数 $T$，表示了有 $T$ 组数据。\n\n对于每一组数据，第一行有两个正整数 $N$ 和 $M$，表示了数字矩阵为 $N$ 行 $M$ 列。\n\n接下来 $N$ 行，每行 $M$ 个非负整数，描述了这个数字矩阵。", "outputFormat": "共 $T$ 行，每行一个非负整数，输出所求得的答案。", "hint": "### 样例解释\n\n对于第一组数据，取数方式如下：\n\n$$\\begin{matrix}\n[67] & 75 & 63 & 10 \\\\\n29 & 29 & [92] & 14 \\\\\n[21] & 68 & 71 & 56 \\\\\n8 & 67 & [91] & 25 \\\\\n\\end{matrix}$$\n\n\n### 数据范围及约定\n\n- 对于$20\\%$的数据，$1\\le N, M \\le 3$；\n- 对于$40\\%$的数据，$1\\le N, M\\le 4$；\n- 对于$60\\%$的数据，$1\\le N, M\\le 5$；\n- 对于$100\\%$的数据，$1\\le N, M\\le 6$，$1\\le T\\le 20$，$a_{i,j}\\le10^5$。", "locale": "zh-CN"}}}
{"pid": "P1124", "type": "P", "difficulty": 4, "samples": [["7\nxelpame\n7\n", "example\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串"], "title": "文件压缩", "background": "提高文件的压缩率一直是人们追求的目标。近几年有人提出了这样一种算法，它虽然只是单纯地对文件进行重排，本身并不压缩文件，但是经这种算法调整后的文件在大多数情况下都能获得比原来更大的压缩率。\n", "description": "该算法具体如下：对一个长度为 $n$ 的字符串 $S$，首先根据它构造 $n$ 个字符串，其中第 $i$ 个字符串由将 $S$ 的前 $i-1$ 个字符置于末尾得到。然后把这 $n$ 个字符串按照首字符从小到大排序，如果两个字符串的首字符相等，则按照它们**在 $S$ 中的位置**从小到大排序。排序后的字符串的尾字符可以组成一个新的字符串 $S'$ ，它的长度也是 $n$，并且包含了 $S$ 中的每一个字符。最后输出 $S'$ 以及 $S$ 的首字符在 $S'$ 中的位置 $p$。\n\n举例：$S$ 是 `example`\n\n1. 构造 $n$ 个字符串。\n\n```plain\nexample\nxamplee\nampleex\nmpleexa\npleexam\nleexamp\neexampl\n```\n\n2. 将字符串排序。\n\n```plain\nampleex\nexample\neexampl\nleexamp\nmpleexa\npleexam\nxamplee\n```\n3. 压缩结果。\n\n$S' = \\texttt{xelpame}$，$p = 7$\n\n由于英语单词构造的特殊性，某些字母对出现的频率很高，因此在 $S'$ 中相同的字母有很大几率排在一起，从而提高 $S'$ 的压缩率。虽然这种算法利用了英语单词的特性，然而在实践的过程中，人们发现它几乎适用于所有的文件压缩。\n\n请你编一个程序，读入 $S'$ 和 $p$，输出字符串 $S$。\n\n保证 $S$ 仅含小写字母（所以输入的 $S'$ 也仅含小写字母）。", "inputFormat": "共三行。\n\n第一行是一个整数 $n$（$1 \\le n \\le 10000$），代表 $S'$ 的长度。\n\n第二行是字符串 $S'$。\n\n第三行是整数 $p$。", "outputFormat": "一行，$S$。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "File Compression", "background": null, "description": "The algorithm is as follows: For a string $S$ of length $n$, first construct $n$ strings, where the $i$-th string is obtained by moving the first $i-1$ characters of $S$ to the end. Then sort these $n$ strings by their first character in ascending order; if two strings have the same first character, sort them by their positions in $S$ in ascending order. The last characters of the sorted strings form a new string $S'$, whose length is also $n$ and which contains every character of $S$. Finally, output $S'$ and the position $p$ of the first character of $S$ in $S'$.\n\nExample: $S$ is `example`.\n\n1. Construct $n$ strings.\n\n```plain\nexample\nxamplee\nampleex\nmpleexa\npleexam\nleexamp\neexampl\n```\n\n2. Sort the strings.\n\n```plain\nampleex\nexample\neexampl\nleexamp\nmpleexa\npleexam\nxamplee\n```\n\n3. Compression result.\n\n$S' = \\texttt{xelpame}$，$p = 7$。\n\nBecause of the characteristics of English words, certain letters occur very frequently, so identical letters are very likely to be grouped together in $S'$, which improves the compression ratio of $S'$. Although this algorithm leverages properties of English words, in practice it is found to work for almost all file compression.\n\nWrite a program that reads $S'$ and $p$, and outputs the string $S$.\n\nIt is guaranteed that $S$ contains only lowercase letters (so the input $S'$ also contains only lowercase letters).", "inputFormat": "Three lines in total.\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10000$), the length of $S'$.\n\nThe second line contains the string $S'$.\n\nThe third line contains an integer $p$.", "outputFormat": "One line, the string $S$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "文件压缩", "background": "提高文件的压缩率一直是人们追求的目标。近几年有人提出了这样一种算法，它虽然只是单纯地对文件进行重排，本身并不压缩文件，但是经这种算法调整后的文件在大多数情况下都能获得比原来更大的压缩率。\n", "description": "该算法具体如下：对一个长度为 $n$ 的字符串 $S$，首先根据它构造 $n$ 个字符串，其中第 $i$ 个字符串由将 $S$ 的前 $i-1$ 个字符置于末尾得到。然后把这 $n$ 个字符串按照首字符从小到大排序，如果两个字符串的首字符相等，则按照它们**在 $S$ 中的位置**从小到大排序。排序后的字符串的尾字符可以组成一个新的字符串 $S'$ ，它的长度也是 $n$，并且包含了 $S$ 中的每一个字符。最后输出 $S'$ 以及 $S$ 的首字符在 $S'$ 中的位置 $p$。\n\n举例：$S$ 是 `example`\n\n1. 构造 $n$ 个字符串。\n\n```plain\nexample\nxamplee\nampleex\nmpleexa\npleexam\nleexamp\neexampl\n```\n\n2. 将字符串排序。\n\n```plain\nampleex\nexample\neexampl\nleexamp\nmpleexa\npleexam\nxamplee\n```\n3. 压缩结果。\n\n$S' = \\texttt{xelpame}$，$p = 7$\n\n由于英语单词构造的特殊性，某些字母对出现的频率很高，因此在 $S'$ 中相同的字母有很大几率排在一起，从而提高 $S'$ 的压缩率。虽然这种算法利用了英语单词的特性，然而在实践的过程中，人们发现它几乎适用于所有的文件压缩。\n\n请你编一个程序，读入 $S'$ 和 $p$，输出字符串 $S$。\n\n保证 $S$ 仅含小写字母（所以输入的 $S'$ 也仅含小写字母）。", "inputFormat": "共三行。\n\n第一行是一个整数 $n$（$1 \\le n \\le 10000$），代表 $S'$ 的长度。\n\n第二行是字符串 $S'$。\n\n第三行是整数 $p$。", "outputFormat": "一行，$S$。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1125", "type": "P", "difficulty": 2, "samples": [["error", "Lucky Word\n2"], ["olympic", "No Answer\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "NOIP 提高组", "素数判断,质数,筛法"], "title": "[NOIP 2008 提高组] 笨小猴", "background": null, "description": "笨小猴的词汇量很小，所以每次做英语选择题的时候都很头疼。但是他找到了一种方法，经试验证明，用这种方法去选择选项的时候选对的几率非常大！\n\n这种方法的具体描述如下：假设 $\\text{maxn}$ 是单词中出现次数最多的字母的出现次数，$\\text{minn}$ 是单词中出现次数最少的字母的出现次数，如果 $\\text{maxn}-\\text{minn}$ 是一个质数，那么笨小猴就认为这是个 Lucky Word，这样的单词很可能就是正确的答案。", "inputFormat": "一个单词，其中只可能出现小写字母，并且长度小于 $100$。", "outputFormat": "共两行，第一行是一个字符串，假设输入的单词是 Lucky Word，那么输出 `Lucky Word`，否则输出 `No Answer`；\n\n第二行是一个整数，如果输入的单词是 Lucky Word，输出 $\\text{maxn}-\\text{minn}$ 的值，否则输出 $0$。", "hint": "【输入输出样例 1 解释】\n\n单词 `error` 中出现最多的字母 $\\texttt r$ 出现了 $3$ 次，出现次数最少的字母出现了 $1$ 次，$3-1=2$，$2$ 是质数。\n\n【输入输出样例 2 解释】\n\n单词 `olympic` 中出现最多的字母 $\\texttt i$ 出现了 $1$ 次，出现次数最少的字母出现了 $1$ 次，$1-1=0$，$0$ 不是质数。\n\n（本处原题面错误已经修正）\n\nnoip2008 提高第一题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2008 Senior] Silly Little Monkey", "background": null, "description": "The silly little monkey has a very small vocabulary, so he always struggles with English multiple-choice questions. But he found a method, and experiments show that using this method greatly increases the chance of choosing the correct option.\n\nThe method is described as follows: suppose $ \\text{maxn} $ is the number of occurrences of the most frequent letter in a word, and $ \\text{minn} $ is the number of occurrences of the least frequent letter in the word. If $ \\text{maxn}-\\text{minn} $ is a prime number, then the silly little monkey considers this a Lucky Word. Such a word is very likely to be the correct answer.", "inputFormat": "A single word containing only lowercase letters, with length less than $100$.", "outputFormat": "Two lines in total. The first line is a string: if the input word is a Lucky Word, output `Lucky Word`; otherwise, output `No Answer`.\n\nThe second line is an integer: if the input word is a Lucky Word, output the value of $ \\text{maxn}-\\text{minn} $; otherwise, output $0$.", "hint": "[Explanation for Sample Input/Output 1]\n\nIn the word `error`, the most frequent letter $ \\texttt{r} $ appears $3$ times, and the least frequent letter appears $1$ time. $3-1=2$, and $2$ is a prime number.\n\n[Explanation for Sample Input/Output 2]\n\nIn the word `olympic`, the most frequent letter $ \\texttt{i} $ appears $1$ time, and the least frequent letter appears $1$ time. $1-1=0$, and $0$ is not a prime number.\n\n(The original error in this part has been corrected.)\n\nNOIP 2008 Senior, Problem 1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2008 提高组] 笨小猴", "background": null, "description": "笨小猴的词汇量很小，所以每次做英语选择题的时候都很头疼。但是他找到了一种方法，经试验证明，用这种方法去选择选项的时候选对的几率非常大！\n\n这种方法的具体描述如下：假设 $\\text{maxn}$ 是单词中出现次数最多的字母的出现次数，$\\text{minn}$ 是单词中出现次数最少的字母的出现次数，如果 $\\text{maxn}-\\text{minn}$ 是一个质数，那么笨小猴就认为这是个 Lucky Word，这样的单词很可能就是正确的答案。", "inputFormat": "一个单词，其中只可能出现小写字母，并且长度小于 $100$。", "outputFormat": "共两行，第一行是一个字符串，假设输入的单词是 Lucky Word，那么输出 `Lucky Word`，否则输出 `No Answer`；\n\n第二行是一个整数，如果输入的单词是 Lucky Word，输出 $\\text{maxn}-\\text{minn}$ 的值，否则输出 $0$。", "hint": "【输入输出样例 1 解释】\n\n单词 `error` 中出现最多的字母 $\\texttt r$ 出现了 $3$ 次，出现次数最少的字母出现了 $1$ 次，$3-1=2$，$2$ 是质数。\n\n【输入输出样例 2 解释】\n\n单词 `olympic` 中出现最多的字母 $\\texttt i$ 出现了 $1$ 次，出现次数最少的字母出现了 $1$ 次，$1-1=0$，$0$ 不是质数。\n\n（本处原题面错误已经修正）\n\nnoip2008 提高第一题", "locale": "zh-CN"}}}
{"pid": "P1126", "type": "P", "difficulty": 4, "samples": [["9 10\n0 0 0 0 0 0 1 0 0 0\n0 0 0 0 0 0 0 0 1 0\n0 0 0 1 0 0 0 0 0 0\n0 0 1 0 0 0 0 0 0 0\n0 0 0 0 0 0 1 0 0 0\n0 0 0 0 0 1 0 0 0 0\n0 0 0 1 1 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 0 0 1 0\n7 2 2 7 S", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "广度优先搜索 BFS", "队列"], "title": "机器人搬重物", "background": "", "description": "机器人移动学会（RMI）现在正尝试用机器人搬运物品。机器人的形状是一个直径 $1.6$ 米的球。在试验阶段，机器人被用于在一个储藏室中搬运货物。储藏室是一个 $N\\times M$ 的网格，有些格子为不可移动的障碍。机器人的中心总是在格点上，当然，机器人必须在最短的时间内把物品搬运到指定的地方。机器人接受的指令有：\n\n- 向前移动 $1$ 步（`Creep`）；\n- 向前移动 $2$ 步（`Walk`）；\n- 向前移动 $3$ 步（`Run`）；\n- 向左转（`Left`）；\n- 向右转（`Right`）。\n\n每个指令所需要的时间为 $1$ 秒。请你计算一下机器人完成任务所需的最少时间。", "inputFormat": "第一行为两个正整数 $N,M\\ (1\\le N,M\\le50)$，下面 $N$ 行是储藏室的构造，$0$ 表示无障碍，$1$ 表示有障碍，数字之间用一个空格隔开。接着一行有 $4$ 个整数和 $1$ 个大写字母，分别为起始点和目标点左上角网格的行与列，起始时的面对方向（东 $\\tt  E$，南 $\\tt  S$，西 $\\tt W$，北 $\\tt N$），数与数，数与字母之间均用一个空格隔开。终点的面向方向是任意的。", "outputFormat": "一个整数，表示机器人完成任务所需的最少时间。如果无法到达，输出 $-1$。\n\n \n![](https://cdn.luogu.com.cn/upload/image_hosting/mma661em.png)\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Robot Moving Heavy Objects", "background": null, "description": "The Robot Mobility Institute (RMI) is now trying to use robots to transport items. The robot is a sphere with a diameter of $1.6$ meters. During the trial phase, the robot is used to move cargo in a storeroom. The storeroom is an $N\\times M$ grid, and some cells are immovable obstacles. The robot’s center is always on grid points. Of course, the robot must deliver the item to the designated location in the shortest time. The robot accepts the following commands:\n- Move forward $1$ step (`Creep`);\n- Move forward $2$ steps (`Walk`);\n- Move forward $3$ steps (`Run`);\n- Turn left (`Left`);\n- Turn right (`Right`).\n\nEach command takes $1$ second. Please compute the minimum time required for the robot to complete the task.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mma661em.png)", "inputFormat": "The first line contains two positive integers $N,M\\ (1\\le N,M\\le50)$. The next $N$ lines describe the storeroom layout: $0$ means no obstacle, and $1$ means an obstacle. Numbers are separated by a single space. Then one line contains $4$ integers and $1$ uppercase letter, which are the row and column of the top-left cell of the starting point and the target point, and the initial facing direction (east $\\tt  E$, south $\\tt  S$, west $\\tt W$, north $\\tt N$). There is a single space between numbers, and between numbers and the letter. The facing direction at the destination is arbitrary.", "outputFormat": "Output one integer, the minimum time required for the robot to complete the task. If it is impossible to reach the destination, output $-1$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "机器人搬重物", "background": "", "description": "机器人移动学会（RMI）现在正尝试用机器人搬运物品。机器人的形状是一个直径 $1.6$ 米的球。在试验阶段，机器人被用于在一个储藏室中搬运货物。储藏室是一个 $N\\times M$ 的网格，有些格子为不可移动的障碍。机器人的中心总是在格点上，当然，机器人必须在最短的时间内把物品搬运到指定的地方。机器人接受的指令有：\n\n- 向前移动 $1$ 步（`Creep`）；\n- 向前移动 $2$ 步（`Walk`）；\n- 向前移动 $3$ 步（`Run`）；\n- 向左转（`Left`）；\n- 向右转（`Right`）。\n\n每个指令所需要的时间为 $1$ 秒。请你计算一下机器人完成任务所需的最少时间。", "inputFormat": "第一行为两个正整数 $N,M\\ (1\\le N,M\\le50)$，下面 $N$ 行是储藏室的构造，$0$ 表示无障碍，$1$ 表示有障碍，数字之间用一个空格隔开。接着一行有 $4$ 个整数和 $1$ 个大写字母，分别为起始点和目标点左上角网格的行与列，起始时的面对方向（东 $\\tt  E$，南 $\\tt  S$，西 $\\tt W$，北 $\\tt N$），数与数，数与字母之间均用一个空格隔开。终点的面向方向是任意的。", "outputFormat": "一个整数，表示机器人完成任务所需的最少时间。如果无法到达，输出 $-1$。\n\n \n![](https://cdn.luogu.com.cn/upload/image_hosting/mma661em.png)\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1127", "type": "P", "difficulty": 5, "samples": [["6\naloha\narachnid\ndog\ngopher\nrat\ntiger", "aloha.arachnid.dog.gopher.rat.tiger"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "图论", "欧拉回路"], "title": "词链", "background": "", "description": "如果单词 $X$ 的末字母与单词 $Y$ 的首字母相同，则 $X$ 与 $Y$ 可以相连成 $X.Y$。（注意：$X$、$Y$ 之间是英文的句号 `.`）。例如，单词 `dog` 与单词 `gopher`，则 `dog` 与 `gopher` 可以相连成 `dog.gopher`。\n\n另外还有一些例子：\n- `dog.gopher`\n- `gopher.rat`\n- `rat.tiger`\n- `aloha.aloha`\n- `arachnid.dog`\n\n连接成的词可以与其他单词相连，组成更长的词链，例如：\n\n`aloha.arachnid.dog.gopher.rat.tiger`\n\n注意到，`.` 两边的字母一定是相同的。\n\n现在给你一些单词，请你找到字典序最小的词链，使得每个单词在词链中出现且仅出现一次。注意，相同的单词若出现了 $k$ 次就需要输出 $k$ 次。", "inputFormat": "第一行是一个正整数 $n$（$1 \\le n \\le 1000$），代表单词数量。\n\n接下来共有 $n$ 行，每行是一个由 $1$ 到 $20$ 个小写字母组成的单词。", "outputFormat": "只有一行，表示组成字典序最小的词链，若不存在则只输出三个星号 `***`。\n", "hint": "- 对于 $40\\%$ 的数据，有 $n \\leq 10$；\n- 对于 $100\\%$ 的数据，有 $n \\leq 1000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Word Chain", "background": null, "description": "If the last letter of word $X$ is the same as the first letter of word $Y$, then $X$ and $Y$ can be concatenated as $X.Y$. Note: there is an English period `.` between $X$ and $Y$. For example, for the words `dog` and `gopher`, `dog` and `gopher` can be concatenated as `dog.gopher`.\n\nMore examples:\n- `dog.gopher`\n- `gopher.rat`\n- `rat.tiger`\n- `aloha.aloha`\n- `arachnid.dog`\n\nA concatenated word can be connected with other words to form a longer word chain, for example:\n\n`aloha.arachnid.dog.gopher.rat.tiger`\n\nNote that the letters on both sides of `.` must be the same.\n\nNow you are given some words. Please find the lexicographically smallest word chain such that each word appears in the chain exactly once. Note that if the same word appears $k$ times, you must output it $k$ times.", "inputFormat": "The first line contains a positive integer $n$ ($1 \\le n \\le 1000$), representing the number of words.\n\nThe next $n$ lines each contain a word consisting of $1$ to $20$ lowercase letters.", "outputFormat": "Output a single line: the lexicographically smallest word chain that uses every given word exactly once. If such a chain does not exist, output exactly three asterisks `***`.", "hint": "- For $40\\%$ of the testdata, $n \\le 10$.\n- For $100\\%$ of the testdata, $n \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "词链", "background": "", "description": "如果单词 $X$ 的末字母与单词 $Y$ 的首字母相同，则 $X$ 与 $Y$ 可以相连成 $X.Y$。（注意：$X$、$Y$ 之间是英文的句号 `.`）。例如，单词 `dog` 与单词 `gopher`，则 `dog` 与 `gopher` 可以相连成 `dog.gopher`。\n\n另外还有一些例子：\n- `dog.gopher`\n- `gopher.rat`\n- `rat.tiger`\n- `aloha.aloha`\n- `arachnid.dog`\n\n连接成的词可以与其他单词相连，组成更长的词链，例如：\n\n`aloha.arachnid.dog.gopher.rat.tiger`\n\n注意到，`.` 两边的字母一定是相同的。\n\n现在给你一些单词，请你找到字典序最小的词链，使得每个单词在词链中出现且仅出现一次。注意，相同的单词若出现了 $k$ 次就需要输出 $k$ 次。", "inputFormat": "第一行是一个正整数 $n$（$1 \\le n \\le 1000$），代表单词数量。\n\n接下来共有 $n$ 行，每行是一个由 $1$ 到 $20$ 个小写字母组成的单词。", "outputFormat": "只有一行，表示组成字典序最小的词链，若不存在则只输出三个星号 `***`。\n", "hint": "- 对于 $40\\%$ 的数据，有 $n \\leq 10$；\n- 对于 $100\\%$ 的数据，有 $n \\leq 1000$。\n", "locale": "zh-CN"}}}
{"pid": "P1128", "type": "P", "difficulty": 5, "samples": [[" 4\n", "6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "高精度", "2001", "各省省选", "湖南"], "title": "[HNOI2001] 求正整数", "background": "", "description": "对于任意输入的正整数 $n$，请求出具有 $n$ 个不同因子的最小正整数 $m$。\n\n例如：$n=4$，则 $m=6$，因为 $6$ 有 $4$ 个不同整数因子 $1,2,3,6$；而且是最小的有 $4$ 个因子的整数。", "inputFormat": "输入有且仅有一行一个整数，代表 $n$。\n", "outputFormat": "输出一行一个整数，代表符合条件的最小正整数 $m$。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 5 \\times 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2001] Find the Positive Integer", "background": null, "description": "Given a positive integer $n$, find the smallest positive integer $m$ that has $n$ distinct divisors.\n\nFor example: when $n=4$, $m=6$, because $6$ has $4$ distinct positive divisors $1, 2, 3, 6$, and it is the smallest integer that has $4$ divisors.", "inputFormat": "The input contains exactly one line with a single integer representing $n$.", "outputFormat": "Output a single line with one integer: the smallest positive integer $m$ that satisfies the condition.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 5 \\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2001] 求正整数", "background": "", "description": "对于任意输入的正整数 $n$，请求出具有 $n$ 个不同因子的最小正整数 $m$。\n\n例如：$n=4$，则 $m=6$，因为 $6$ 有 $4$ 个不同整数因子 $1,2,3,6$；而且是最小的有 $4$ 个因子的整数。", "inputFormat": "输入有且仅有一行一个整数，代表 $n$。\n", "outputFormat": "输出一行一个整数，代表符合条件的最小正整数 $m$。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 5 \\times 10^4$。", "locale": "zh-CN"}}}
{"pid": "P1129", "type": "P", "difficulty": 5, "samples": [["2\n2\n0 0\n0 1\n3\n0 0 1\n0 1 0\n1 0 0\n", "No\nYes\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "递归", "网络流", "浙江", "二分图"], "title": "[ZJOI2007] 矩阵游戏", "background": null, "description": "小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \\times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：\n\n- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。\n- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。\n\n游戏的目标，即通过若干次操作，使得方阵的主对角线（左上角到右下角的连线）上的格子均为黑色。\n\n对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。", "inputFormat": "**本题有多组测试数据**。\n\n第一行包含一个整数 $T$，表示数据的组数，对于每组数据，输入格式如下：\n\n第一行为一个整数，代表方阵的大小 $n$。\n接下来 $n$ 行，每行 $n$ 个非零即一的整数，代表该方阵。其中 $0$ 表示白色，$1$ 表示黑色。", "outputFormat": "对于每组数据，输出一行一个字符串，若关卡有解则输出 `Yes`，否则输出 `No`。", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，保证 $n \\leq 7$。\n- 对于 $50\\%$ 的数据，保证 $n \\leq 50$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 200$，$1 \\leq T \\leq 20$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2007] Matrix Game", "background": null, "description": "Little Q is a very smart kid. Besides chess, he also likes a computer puzzle game called the Matrix Game. The game is played on an $n \\times n$ black-and-white grid (similar to a chessboard, but colors are arbitrary). Each move allows one of the following operations:\n\n- Row swap: choose any two rows of the matrix and swap them (i.e., swap the colors of the corresponding cells).\n- Column swap: choose any two columns of the matrix and swap them (i.e., swap the colors of the corresponding cells).\n\nThe goal is to make all cells on the main diagonal (from the top-left corner to the bottom-right corner) black after some number of operations.\n\nFor some levels, Little Q cannot figure out the solution and starts to suspect that they may be unsolvable. So he decides to write a program to determine whether a given level is solvable.", "inputFormat": "This problem has multiple test cases.\n\nThe first line contains an integer $T$, the number of test cases. For each test case:\n- The first line contains an integer $n$, the size of the grid.\n- The next $n$ lines each contain $n$ integers, each being 0 or 1, representing the grid. Here, 0 means white and 1 means black.", "outputFormat": "For each test case, output one line with a single string: output Yes if the level is solvable, otherwise output No.", "hint": "Constraints\n- For 20% of the testdata, $n \\leq 7$.\n- For 50% of the testdata, $n \\leq 50$.\n- For 100% of the testdata, $1 \\leq n \\leq 200$, $1 \\leq T \\leq 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2007] 矩阵游戏", "background": null, "description": "小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \\times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：\n\n- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。\n- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。\n\n游戏的目标，即通过若干次操作，使得方阵的主对角线（左上角到右下角的连线）上的格子均为黑色。\n\n对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。", "inputFormat": "**本题有多组测试数据**。\n\n第一行包含一个整数 $T$，表示数据的组数，对于每组数据，输入格式如下：\n\n第一行为一个整数，代表方阵的大小 $n$。\n接下来 $n$ 行，每行 $n$ 个非零即一的整数，代表该方阵。其中 $0$ 表示白色，$1$ 表示黑色。", "outputFormat": "对于每组数据，输出一行一个字符串，若关卡有解则输出 `Yes`，否则输出 `No`。", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，保证 $n \\leq 7$。\n- 对于 $50\\%$ 的数据，保证 $n \\leq 50$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 200$，$1 \\leq T \\leq 20$。", "locale": "zh-CN"}}}
{"pid": "P1130", "type": "P", "difficulty": 2, "samples": [["4 3 \n2 6 1 8\n3 6 2 6\n4 2 3 6\n", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP"], "title": "红牌", "background": "", "description": "\n某地临时居民想获得长期居住权就必须申请拿到红牌。获得红牌的过程是相当复杂 ，一共包括 $N$ 个步骤。每一步骤都由政府的某个工作人员负责检查你所提交的材料是否符合条件。为了加快进程，每一步政府都派了 $M$ 个工作人员来检查材料。不幸的是，并不是每一个工作人员效率都很高。尽管如此，为了体现“公开政府”的政策，政府部门把每一个工作人员的处理一个申请所花天数都对外界公开。\n\n为了防止所有申请人都到效率高的工作人员去申请。这 $M \\times N$ 个工作人员被分成 $M$ 个小组。每一组在每一步都有一个工作人员。申请人可以选择任意一个小组也可以更换小组。但是更换小组是很严格的，一定要相邻两个步骤之间来更换，而不能在某一步骤已经开始但还没结束的时候提出更换，并且也只能从原来的小组 $I$ 更换到小组 $I+1$，当然从小组 $M$ 可以更换到小组 $1$。对更换小组的次数没有限制。\n\n例如：下面是 $3$ 个小组，每个小组 $4$ 个步骤工作天数：\n\n- 小组 $1$： $2, 6 ,1 ,8$；\n- 小组 $2$：$3,6, 2, 6$；\n- 小组 $3$：$ 4, 2 ,3 ,6$。\n\n例子中，可以选择小组 $1$ 来完成整个过程一共花了$2+6+1+8=17$ 天，也可以从小组 $2$ 开始第一步，然后第二步更换到小组 $3$，第三步到小组 $1$，第四步再到小组 $2$，这样一共花了 $3+2+1+6=12$ 天。你可以发现没有比这样效率更高的选择。\n\n你的任务是求出完成申请所花最少天数。", "inputFormat": "第一行是两个正整数 $N$ 和 $M$，表示步数和小组数。\n\n接下来有 $M$ 行，每行有 $N$ 个非负整数，第 $i+1(1 \\le i  \\le M)$ 行的第 $j$ 个数表示小组 $i$ 完成第 $j$ 步所花的天数，天数都不超过 $1000000$。", "outputFormat": "一个正整数，为完成所有步所需最少天数。", "hint": "对于 $100\\%$ 的数据，$1\\le N,M \\le 2000$。", "locale": "zh-CN", "translations": {"en": {"title": "Red Card", "background": null, "description": "To obtain long-term residency, temporary residents must apply for a red card. The process consists of $N$ steps. Each step is handled by a government staff member who checks whether your submitted materials meet the requirements. To accelerate the process, at each step the government assigns $M$ staff members to check materials. Unfortunately, not every staff member is efficient. Nevertheless, to embody the policy of “open government,” the department publicly releases the number of days each staff member takes to handle one application.\n\nTo prevent all applicants from flocking to the most efficient staff, these $M \\times N$ staff members are divided into $M$ groups. Each group has exactly one staff member at each step. An applicant may choose any one group and may also switch groups. However, switching is strictly limited: it must occur between two adjacent steps, not during a step that has already started but not yet finished; moreover, you can only switch from your current group $I$ to group $I+1$, and from group $M$ you may switch to group $1$. There is no limit on the number of switches.\n\nFor example, here are $3$ groups, with working days for $4$ steps per group:\n- Group $1$: $2, 6 ,1 ,8$;\n- Group $2$: $3,6, 2, 6$;\n- Group $3$: $ 4, 2 ,3 ,6$.\n\nIn this example, you can choose group $1$ for the entire process, which takes $2+6+1+8=17$ days. Alternatively, you may start with group $2$ for step one, then switch to group $3$ for step two, to group $1$ for step three, and to group $2$ for step four, for a total of $3+2+1+6=12$ days. You can see that no choice is more efficient than this.\n\nYour task is to find the minimum number of days needed to complete the application.", "inputFormat": "The first line contains two positive integers $N$ and $M$, the number of steps and the number of groups.\n\nThen there are $M$ lines, each containing $N$ non-negative integers. On the $i$-th of these lines $(1 \\le i \\le M)$, the $j$-th number denotes the number of days group $i$ needs to complete step $j$. All day counts do not exceed $1000000$.", "outputFormat": "Output a single positive integer, the minimum number of days required to complete all steps.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le N,M \\le 2000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "红牌", "background": "", "description": "\n某地临时居民想获得长期居住权就必须申请拿到红牌。获得红牌的过程是相当复杂 ，一共包括 $N$ 个步骤。每一步骤都由政府的某个工作人员负责检查你所提交的材料是否符合条件。为了加快进程，每一步政府都派了 $M$ 个工作人员来检查材料。不幸的是，并不是每一个工作人员效率都很高。尽管如此，为了体现“公开政府”的政策，政府部门把每一个工作人员的处理一个申请所花天数都对外界公开。\n\n为了防止所有申请人都到效率高的工作人员去申请。这 $M \\times N$ 个工作人员被分成 $M$ 个小组。每一组在每一步都有一个工作人员。申请人可以选择任意一个小组也可以更换小组。但是更换小组是很严格的，一定要相邻两个步骤之间来更换，而不能在某一步骤已经开始但还没结束的时候提出更换，并且也只能从原来的小组 $I$ 更换到小组 $I+1$，当然从小组 $M$ 可以更换到小组 $1$。对更换小组的次数没有限制。\n\n例如：下面是 $3$ 个小组，每个小组 $4$ 个步骤工作天数：\n\n- 小组 $1$： $2, 6 ,1 ,8$；\n- 小组 $2$：$3,6, 2, 6$；\n- 小组 $3$：$ 4, 2 ,3 ,6$。\n\n例子中，可以选择小组 $1$ 来完成整个过程一共花了$2+6+1+8=17$ 天，也可以从小组 $2$ 开始第一步，然后第二步更换到小组 $3$，第三步到小组 $1$，第四步再到小组 $2$，这样一共花了 $3+2+1+6=12$ 天。你可以发现没有比这样效率更高的选择。\n\n你的任务是求出完成申请所花最少天数。", "inputFormat": "第一行是两个正整数 $N$ 和 $M$，表示步数和小组数。\n\n接下来有 $M$ 行，每行有 $N$ 个非负整数，第 $i+1(1 \\le i  \\le M)$ 行的第 $j$ 个数表示小组 $i$ 完成第 $j$ 步所花的天数，天数都不超过 $1000000$。", "outputFormat": "一个正整数，为完成所有步所需最少天数。", "hint": "对于 $100\\%$ 的数据，$1\\le N,M \\le 2000$。", "locale": "zh-CN"}}}
{"pid": "P1131", "type": "P", "difficulty": 4, "samples": [["3\n1\n1 2 1\n1 3 3\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "树形数据结构", "2007", "各省省选", "浙江", "树形 DP", "构造"], "title": "[ZJOI2007] 时态同步", "background": "", "description": "小 Q 在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字 $1,2,3\\cdots$ 进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。\n\n在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激励电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。\n\n激励电流在导线上的传播是需要花费时间的，对于每条边 $e$，激励电流通过它需要的时间为 $t_e$，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小 Q 有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小 Q 最少使用多少次道具才可使得所有的“终止节点”时态同步？", "inputFormat": "第一行包含一个正整数 $N$，表示电路板中节点的个数。\n\n第二行包含一个整数 $S$，为该电路板的激发器的编号。\n\n接下来 $N-1$ 行，每行三个整数 $a,b,t$。表示该条导线连接节点 $a$ 与节点 $b$，且激励电流通过这条导线需要 $t$ 个单位时间。", "outputFormat": "仅包含一个整数 $V$，为小 Q 最少使用的道具次数。", "hint": "- 对于 $40\\%$ 的数据，$1\\le N\\le 1000$。\n- 对于 $100\\%$ 的数据，$1\\le N\\le 5\\times 10^5$。\n\n对于所有的数据，$1\\le t_e\\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2007] Temporal Synchronization", "background": null, "description": "Xiao Q is learning to solder circuit boards in an electronics workshop. A circuit board consists of several components, which we will call nodes, labeled by numbers $1, 2, 3, \\cdots$. The nodes on the circuit board are connected by several non-overlapping wires, and for any two nodes on the board, there exists exactly one path (a path is a sequence of wires connecting two components).\n\nThere is a special component on the board called the “exciter.” When the exciter operates, it generates an excitation current that is sent through wires to each node it is connected to. When an intermediate node receives the excitation current, it gets the information and immediately forwards the current to its connected nodes that have not yet received it. Eventually, the excitation current reaches some “terminal nodes”—nodes that, after receiving the current, no longer forward it.\n\nIt takes time for the excitation current to travel along a wire. For each edge $e$, the time required for the current to pass through it is $t_e$, while forwarding at nodes is considered instantaneous. The board requires that every terminal node receive the excitation current at the same time—that is, to maintain temporal synchronization. Since the current construction does not meet the synchronization requirement, we need to modify the wiring. Xiao Q has a tool that, when used once, can increase the transmission time of some wire by $1$. What is the minimum number of times the tool must be used to make all terminal nodes temporally synchronized?", "inputFormat": "- The first line contains an integer $N$, the number of nodes on the circuit board.\n- The second line contains an integer $S$, the index of the exciter.\n- The next $N - 1$ lines each contain three integers $a, b, t$, indicating that there is a wire connecting nodes $a$ and $b$, and the excitation current takes $t$ units of time to pass through this wire.", "outputFormat": "Output a single integer $V$, the minimum number of times the tool must be used.", "hint": "Constraints:\n- For $40\\%$ of the testdata, $1 \\le N \\le 1000$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 5 \\times 10^5$.\n- For all testdata, $1 \\le t_e \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2007] 时态同步", "background": "", "description": "小 Q 在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字 $1,2,3\\cdots$ 进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。\n\n在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激励电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。\n\n激励电流在导线上的传播是需要花费时间的，对于每条边 $e$，激励电流通过它需要的时间为 $t_e$，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小 Q 有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小 Q 最少使用多少次道具才可使得所有的“终止节点”时态同步？", "inputFormat": "第一行包含一个正整数 $N$，表示电路板中节点的个数。\n\n第二行包含一个整数 $S$，为该电路板的激发器的编号。\n\n接下来 $N-1$ 行，每行三个整数 $a,b,t$。表示该条导线连接节点 $a$ 与节点 $b$，且激励电流通过这条导线需要 $t$ 个单位时间。", "outputFormat": "仅包含一个整数 $V$，为小 Q 最少使用的道具次数。", "hint": "- 对于 $40\\%$ 的数据，$1\\le N\\le 1000$。\n- 对于 $100\\%$ 的数据，$1\\le N\\le 5\\times 10^5$。\n\n对于所有的数据，$1\\le t_e\\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P1132", "type": "P", "difficulty": 4, "samples": [["143\n3\n134\n133\n32\n", "1\n-1\n4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索"], "title": "数字生成游戏", "background": null, "description": "小明完成了这样一个数字生成游戏，对于一个不包含 $0$ 的数字 $s$ 来说，有以下 $3$ 种生成新的数的规则：\n\n1.    将 $s$ 的任意两位对换生成新的数字，例如 $143$ 可以生成 $341,413,134$；\n\n2.    将 $s$ 的任意一位删除生成新的数字，例如 $143$ 可以生成 $14,13,43$；\n\n3.    在 $s$ 的相邻两位之间 $s_i,s_{i + 1}$ 之间插入一个数字 $x$，$x$ 需要满足 $s_i<x<s_{i + 1}$。例如 $143$ 可以生成 $1243,1343$，但是不能生成 $1143,1543$ 等。\n\n现在小明想知道，在这个生成法则下，从 $s$ 开始，每次生成一个数，可以用然后用新生成的数生成另外一个数，不断生成直到生成 $t$ 至少需要多少次生成操作。\n\n另外，小明给规则 $3$ 又加了一个限制，即生成数的位数不能超过初始数 $s$ 的位数。若 $s$ 是 $143$，那么 $1243$ 与 $1343$ 都是无法生成的；若 $s$ 为 $1443$，那么可以将 $s$ 删除变为 $143$，再生成 $1243$ 或 $1343$。", "inputFormat": "第一行包含 $1$ 个正整数，为初始数字 $s$。\n\n第二行包含一个正整数 $m$，为询问个数。  \n\n接下来 $m$ 行，每行一个整数 $t$（$t$ 不包含 $0$），表示询问从 $s$ 开始不断生成数字到 $t$ 最少要进行多少次操作。任两个询问独立，即上一个询问生成过的数到下一个询问都不存在，只剩下初始数字 $s$。", "outputFormat": "共 $m$ 行，每行一个正整数，对每个询问输出最少操作数，如果无论如果无论也变换不成，则输出 $-1$。", "hint": "**样例解释**\n\n$143\\to 134$\n\n$133$ 无法得到\n\n$143\\to13\\to123\\to23\\to32$\n\n**数据范围**\n\n对于 $20\\%$ 的数据，$s < 100$；  \n对于 $40\\%$ 的数据，$s < 1000$；  \n对于 $40\\%$ 的数据，$m < 10$；  \n对于 $60\\%$ 的数据，$s < 10000$；  \n对于 $100\\%$ 的数据，$s < 100000,m \\leq 50000$。", "locale": "zh-CN", "translations": {"en": {"title": "Number Generation Game", "background": null, "description": "Xiaoming has completed a number generation game. For a number $s$ that does not contain the digit $0$, there are the following $3$ rules to generate new numbers:\n\n1. Swap any two digits of $s$ to form a new number. For example, $143$ can generate $341, 413, 134$.\n\n2. Delete any single digit of $s$ to form a new number. For example, $143$ can generate $14, 13, 43$.\n\n3. Insert a digit $x$ between two adjacent digits $s_i, s_{i + 1}$ of $s$, where $x$ must satisfy $s_i < x < s_{i + 1}$. For example, $143$ can generate $1243, 1343$, but cannot generate $1143, 1543$, etc.\n\nNow Xiaoming wants to know, under these rules, starting from $s$, each step generating a new number (and then using the newly generated number to generate the next one), what is the minimum number of operations required to obtain $t$.\n\nAdditionally, Xiaoming imposes a further restriction on rule $3$: the number of digits of any generated number cannot exceed the number of digits of the initial number $s$. If $s$ is $143$, then $1243$ and $1343$ are impossible to generate. If $s$ is $1443$, then you can first delete a digit to obtain $143$, and then generate $1243$ or $1343$.", "inputFormat": "The first line contains $1$ positive integer, the initial number $s$.\n\nThe second line contains a positive integer $m$, the number of queries.\n\nThe next $m$ lines each contain an integer $t$ ($t$ does not contain the digit $0$), asking for the minimum number of operations needed to generate $t$ starting from $s$. Any two queries are independent; numbers generated in one query do not carry over to the next, and only the initial number $s$ remains.", "outputFormat": "Output $m$ lines. For each query, output one positive integer: the minimum number of operations. If it is impossible to transform under the rules, output $-1$.", "hint": "Sample explanation:\n\n$143 \\to 134$\n\n$133$ cannot be obtained.\n\n$143 \\to 13 \\to 123 \\to 23 \\to 32$\n\n# Constraints\n\nFor $20\\%$ of the testdata, $s < 100$.\nFor $40\\%$ of the testdata, $s < 1000$.\nFor $40\\%$ of the testdata, $m < 10$.\nFor $60\\%$ of the testdata, $s < 10000$.\nFor $100\\%$ of the testdata, $s < 100000, m \\leq 50000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数字生成游戏", "background": null, "description": "小明完成了这样一个数字生成游戏，对于一个不包含 $0$ 的数字 $s$ 来说，有以下 $3$ 种生成新的数的规则：\n\n1.    将 $s$ 的任意两位对换生成新的数字，例如 $143$ 可以生成 $341,413,134$；\n\n2.    将 $s$ 的任意一位删除生成新的数字，例如 $143$ 可以生成 $14,13,43$；\n\n3.    在 $s$ 的相邻两位之间 $s_i,s_{i + 1}$ 之间插入一个数字 $x$，$x$ 需要满足 $s_i<x<s_{i + 1}$。例如 $143$ 可以生成 $1243,1343$，但是不能生成 $1143,1543$ 等。\n\n现在小明想知道，在这个生成法则下，从 $s$ 开始，每次生成一个数，可以用然后用新生成的数生成另外一个数，不断生成直到生成 $t$ 至少需要多少次生成操作。\n\n另外，小明给规则 $3$ 又加了一个限制，即生成数的位数不能超过初始数 $s$ 的位数。若 $s$ 是 $143$，那么 $1243$ 与 $1343$ 都是无法生成的；若 $s$ 为 $1443$，那么可以将 $s$ 删除变为 $143$，再生成 $1243$ 或 $1343$。", "inputFormat": "第一行包含 $1$ 个正整数，为初始数字 $s$。\n\n第二行包含一个正整数 $m$，为询问个数。  \n\n接下来 $m$ 行，每行一个整数 $t$（$t$ 不包含 $0$），表示询问从 $s$ 开始不断生成数字到 $t$ 最少要进行多少次操作。任两个询问独立，即上一个询问生成过的数到下一个询问都不存在，只剩下初始数字 $s$。", "outputFormat": "共 $m$ 行，每行一个正整数，对每个询问输出最少操作数，如果无论如果无论也变换不成，则输出 $-1$。", "hint": "**样例解释**\n\n$143\\to 134$\n\n$133$ 无法得到\n\n$143\\to13\\to123\\to23\\to32$\n\n**数据范围**\n\n对于 $20\\%$ 的数据，$s < 100$；  \n对于 $40\\%$ 的数据，$s < 1000$；  \n对于 $40\\%$ 的数据，$m < 10$；  \n对于 $60\\%$ 的数据，$s < 10000$；  \n对于 $100\\%$ 的数据，$s < 100000,m \\leq 50000$。", "locale": "zh-CN"}}}
{"pid": "P1133", "type": "P", "difficulty": 4, "samples": [["4 \n1 3 2 \n3 1 2 \n3 1 2 \n3 1 2\n", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP"], "title": "教主的花园", "background": null, "description": "教主有着一个环形的花园，他想在花园周围均匀地种上 $n$ 棵树，但是教主花园的土壤很特别，每个位置适合种的树都不一样，一些树可能会因为不适合这个位置的土壤而损失观赏价值。\n\n教主最喜欢 $3$ 种树，这 $3$ 种树的高度分别为 $10,20,30$。教主希望这一圈树种得有层次感，所以任何一个位置的树要比它相邻的两棵树的高度都高或者都低，并且在此条件下，教主想要你设计出一套方案，使得观赏价值之和最高。", "inputFormat": "第一行为一个正整数 $n$，表示需要种的树的棵数。\n\n接下来 $n$ 行，每行 $3$ 个不超过 $10000$ 的正整数 $a_i,b_i,c_i$，按顺时针顺序表示了第 $i$ 个位置种高度为 $10,20,30$ 的树能获得的观赏价值。\n\n第 $i$ 个位置的树与第 $i+1$ 个位置的树相邻，特别地，第 $1$ 个位置的树与第 $n$ 个位置的树相邻。", "outputFormat": "一个正整数，为最大的观赏价值和。", "hint": "【样例说明】。\n\n第 $1$ 至 $n$ 个位置分别种上高度为 $20,10,30,10$ 的树，价值最高。\n\n【数据规模与约定】。\n\n- 对于 $20\\%$ 的数据，有 $n\\le 10$；\n- 对于 $40\\%$ 的数据，有 $n\\le 100$； \n- 对于 $60\\%$ 的数据，有 $n\\le 1000$；\n- 对于 $100\\%$ 的数据，有 $4\\le n\\le 10^5$，并保证 $n$ 一定为偶数。", "locale": "zh-CN", "translations": {"en": {"title": "The Leader's Garden", "background": "", "description": "The leader has a circular garden and wants to plant $n$ trees evenly around it. However, the soil is special; each position suits different kinds of trees, and some trees may lose aesthetic value if placed in unsuitable soil.\n\nThe leader's three favorite kinds of trees have heights $10,20,30$. He wants the ring of trees to have a sense of layering: at every position, the tree must be strictly higher than both of its adjacent trees or strictly lower than both. Under this condition, design a plan that maximizes the sum of aesthetic values.", "inputFormat": "The first line contains a positive integer $n$, the number of trees to plant.\n\nThe next $n$ lines each contain three positive integers $a_i,b_i,c_i$ not exceeding $10000$, giving, in clockwise order, the aesthetic value obtained by planting at position $i$ a tree of height $10,20,30$, respectively.\n\nThe tree at position $i$ is adjacent to the tree at position $i+1$; in particular, the tree at position $1$ is adjacent to the tree at position $n$.", "outputFormat": "Output a single positive integer, the maximum total aesthetic value.", "hint": "[Sample Explanation].\n\nPlant trees of heights $20,10,30,10$ at positions $1$ through $n$, respectively, to achieve the highest value.\n\n[Constraints].\n\n- For $20\\%$ of the testdata, $n \\le 10$.\n- For $40\\%$ of the testdata, $n \\le 100$.\n- For $60\\%$ of the testdata, $n \\le 1000$.\n- For $100\\%$ of the testdata, $4 \\le n \\le 10^5$, and $n$ is guaranteed to be even.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "教主的花园", "background": null, "description": "教主有着一个环形的花园，他想在花园周围均匀地种上 $n$ 棵树，但是教主花园的土壤很特别，每个位置适合种的树都不一样，一些树可能会因为不适合这个位置的土壤而损失观赏价值。\n\n教主最喜欢 $3$ 种树，这 $3$ 种树的高度分别为 $10,20,30$。教主希望这一圈树种得有层次感，所以任何一个位置的树要比它相邻的两棵树的高度都高或者都低，并且在此条件下，教主想要你设计出一套方案，使得观赏价值之和最高。", "inputFormat": "第一行为一个正整数 $n$，表示需要种的树的棵数。\n\n接下来 $n$ 行，每行 $3$ 个不超过 $10000$ 的正整数 $a_i,b_i,c_i$，按顺时针顺序表示了第 $i$ 个位置种高度为 $10,20,30$ 的树能获得的观赏价值。\n\n第 $i$ 个位置的树与第 $i+1$ 个位置的树相邻，特别地，第 $1$ 个位置的树与第 $n$ 个位置的树相邻。", "outputFormat": "一个正整数，为最大的观赏价值和。", "hint": "【样例说明】。\n\n第 $1$ 至 $n$ 个位置分别种上高度为 $20,10,30,10$ 的树，价值最高。\n\n【数据规模与约定】。\n\n- 对于 $20\\%$ 的数据，有 $n\\le 10$；\n- 对于 $40\\%$ 的数据，有 $n\\le 100$； \n- 对于 $60\\%$ 的数据，有 $n\\le 1000$；\n- 对于 $100\\%$ 的数据，有 $4\\le n\\le 10^5$，并保证 $n$ 一定为偶数。", "locale": "zh-CN"}}}
{"pid": "P1134", "type": "P", "difficulty": 3, "samples": [["12", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "USACO"], "title": "[USACO3.2] 阶乘问题", "background": "", "description": "也许你早就知道阶乘的含义，$N$ 阶乘是由 $1$ 到 $N$ 相乘而产生，如：\n\n$$12!=1\\times 2\\times 3\\times 4\\times 5\\times 6\\times 7\\times 8\\times 9\\times 10\\times 11\\times  12=479{,}001{,}600$$\n\n$12$ 的阶乘最右边的非零位为 $6$。\n\n写一个程序，计算 $N\\ (1\\le N\\le5\\times 10^7)$ 阶乘的最右边的非零位的值。\n\n**注意**：$10{,}000{,}000!$ 的末尾有 $2499999$ 个零。", "inputFormat": "仅一行包含一个正整数 $N$。\n", "outputFormat": "一个整数，表示最右边的非零位的值。\n", "hint": "USACO Training Section 3.2\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO3.2] Factorial Problem", "background": "", "description": "Perhaps you already know what a factorial is; the factorial of $N$ is the product from $1$ to $N$, for example:\n\n$$12!=1\\times 2\\times 3\\times 4\\times 5\\times 6\\times 7\\times 8\\times 9\\times 10\\times 11\\times  12=479{,}001{,}600$$\n\nThe rightmost non-zero digit of the factorial of $12$ is $6$.\n\nWrite a program to compute the value of the rightmost non-zero digit of the factorial of $N\\ (1\\le N\\le5\\times 10^7)$.\n\n**Note**: There are $2499999$ trailing zeros in $10{,}000{,}000!$.", "inputFormat": "A single line containing a positive integer $N$.", "outputFormat": "A single integer, the value of the rightmost non-zero digit.", "hint": "USACO Training Section 3.2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO3.2] 阶乘问题", "background": "", "description": "也许你早就知道阶乘的含义，$N$ 阶乘是由 $1$ 到 $N$ 相乘而产生，如：\n\n$$12!=1\\times 2\\times 3\\times 4\\times 5\\times 6\\times 7\\times 8\\times 9\\times 10\\times 11\\times  12=479{,}001{,}600$$\n\n$12$ 的阶乘最右边的非零位为 $6$。\n\n写一个程序，计算 $N\\ (1\\le N\\le5\\times 10^7)$ 阶乘的最右边的非零位的值。\n\n**注意**：$10{,}000{,}000!$ 的末尾有 $2499999$ 个零。", "inputFormat": "仅一行包含一个正整数 $N$。\n", "outputFormat": "一个整数，表示最右边的非零位的值。\n", "hint": "USACO Training Section 3.2\n", "locale": "zh-CN"}}}
{"pid": "P1135", "type": "P", "difficulty": 3, "samples": [["5 1 5\n3 3 1 2 5\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "广度优先搜索 BFS", "深度优先搜索 DFS", "最短路"], "title": "奇怪的电梯", "background": "感谢 @[yummy](https://www.luogu.com.cn/user/101694) 提供的一些数据。", "description": "呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼（$1 \\le i \\le N$）上有一个数字 $K_i$（$0 \\le K_i \\le N$）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如：$3, 3, 1, 2, 5$ 代表了 $K_i$（$K_1=3$，$K_2=3$，……），从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？", "inputFormat": "共二行。  \n\n第一行为三个用空格隔开的正整数，表示 $N, A, B$（$1 \\le N \\le 200$，$1 \\le A, B \\le N$）。\n\n第二行为 $N$ 个用空格隔开的非负整数，表示 $K_i$。", "outputFormat": "一行，即最少按键次数，若无法到达，则输出 `-1`。", "hint": "对于 $100 \\%$ 的数据，$1 \\le N \\le 200$，$1 \\le A, B \\le N$，$0 \\le K_i \\le N$。\n\n本题共 $16$ 个测试点，前 $15$ 个每个测试点 $6$ 分，最后一个测试点 $10$ 分。", "locale": "zh-CN", "translations": {"en": {"title": "Strange Elevator", "background": "Thanks to @[yummy](https://www.luogu.com.cn/user/101694) for providing some testdata.", "description": "Hehe, one day I had a dream about a very strange elevator. The elevator can stop at every floor of the building, and on floor $i$ ( $1 \\le i \\le N$ ) there is a number $K_i$ ( $0 \\le K_i \\le N$ ). The elevator has only four buttons: Open, Close, Up, and Down. The number of floors moved up or down equals the number on the current floor. Of course, if the move would be invalid, the corresponding button will not work. For example: $3, 3, 1, 2, 5$ represents $K_i$ ( $K_1 = 3$, $K_2 = 3$, ... ), starting from floor $1$. On floor $1$, pressing \"Up\" takes you to floor $4$, and pressing \"Down\" does nothing because there is no floor $-2$. Then, what is the minimum number of button presses to get from floor $A$ to floor $B$?", "inputFormat": "Two lines in total.\n\nThe first line contains three positive integers separated by spaces, denoting $N, A, B$ ( $1 \\le N \\le 200$, $1 \\le A, B \\le N$ ).\n\nThe second line contains $N$ non-negative integers separated by spaces, denoting $K_i$.", "outputFormat": "One line: the minimum number of button presses. If it is impossible to reach, output `-1`.", "hint": "For 100% of the testdata, $1 \\le N \\le 200$, $1 \\le A, B \\le N$, $0 \\le K_i \\le N$.\n\nThere are $16$ test points in total. The first $15$ test points are worth $6$ points each, and the last test point is worth $10$ points.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "奇怪的电梯", "background": "感谢 @[yummy](https://www.luogu.com.cn/user/101694) 提供的一些数据。", "description": "呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼（$1 \\le i \\le N$）上有一个数字 $K_i$（$0 \\le K_i \\le N$）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如：$3, 3, 1, 2, 5$ 代表了 $K_i$（$K_1=3$，$K_2=3$，……），从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？", "inputFormat": "共二行。  \n\n第一行为三个用空格隔开的正整数，表示 $N, A, B$（$1 \\le N \\le 200$，$1 \\le A, B \\le N$）。\n\n第二行为 $N$ 个用空格隔开的非负整数，表示 $K_i$。", "outputFormat": "一行，即最少按键次数，若无法到达，则输出 `-1`。", "hint": "对于 $100 \\%$ 的数据，$1 \\le N \\le 200$，$1 \\le A, B \\le N$，$0 \\le K_i \\le N$。\n\n本题共 $16$ 个测试点，前 $15$ 个每个测试点 $6$ 分，最后一个测试点 $10$ 分。", "locale": "zh-CN"}}}
{"pid": "P1136", "type": "P", "difficulty": 5, "samples": [["5 2 \nzzzjj\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP"], "title": "迎接仪式", "background": "", "description": "LHX 教主要来 X 市指导 OI 学习工作了。为了迎接教主，在一条道路旁，一群“Orz 教主 er”穿着文化衫站在道路两旁迎接教主，每件文化衫上都印着大字。一旁的 Orzer 依次摆出“欢迎欢迎欢迎欢迎……”的大字，但是领队突然发现，另一旁穿着“教”和“主”字文化衫的 Orzer 却不太和谐。\n\n为了简单描述这个不和谐的队列，我们用 `j` 替代“教”，`z` 替代“主”。而一个 `j` 与 `z` 组成的序列则可以描述当前的队列。为了让教主看得尽量舒服，你必须调整队列，使得 `jz` 子串尽量多。每次调整你可以交换任意位置上的两个人，也就是序列中任意位置上的两个字母。而因为教主马上就来了，时间仅够最多做 $K$ 次调整（当然可以调整不满 $K$ 次），所以这个问题交给了你。", "inputFormat": "第一行，两个正整数 $N, K$，分别表示序列长度与最多交换次数。\n\n第二行，一个长度为 $N$ 的字符串，字符串仅由字母 `j` 与字母 `z` 组成，描述了这个序列。", "outputFormat": "一个非负整数，为调整最多 $K$ 次后最后最多能出现多少个 `jz` 子串。", "hint": "**【样例说明】**\n\n第 $1$ 次交换位置 $1$ 上的 `z` 和位置 $4$ 上的 `j`，变为 `jzzzj`；\n\n第 $2$ 次交换位置 $4$ 上的 `z` 和位置 $5$ 上的 `j`，变为 `jzzjz`。\n\n最后的串有 $2$ 个 `jz` 子串。\n\n**【数据规模与约定】**\n\n对于 $10 \\%$ 的数据，有 $N \\le 10$；  \n对于 $30 \\%$ 的数据，有 $K \\le 10$；  \n对于 $40 \\%$ 的数据，有 $N \\le 50$；  \n对于 $100 \\%$ 的数据，有 $1 \\le N \\le 500$，$1 \\le K \\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "Welcoming Ceremony", "background": "", "description": "Leader LHX is coming to City X to guide OI studies. To welcome the Leader (jiaozhu), along a road, a group of Orzer wearing T-shirts stand on both sides of the road, with big characters printed on each shirt. On one side, the Orzer spell out “欢迎欢迎欢迎欢迎……” in order, but the leader of the group suddenly notices that the Orzer on the other side, who wear the characters “教” and “主,” look less harmonious.\n\nTo describe this disharmony simply, we use `j` to replace “教” and `z` to replace “主.” A sequence composed of `j` and `z` then describes the current lineup. To make it as pleasing as possible for the Leader, you must adjust the lineup to maximize the number of `jz` substrings. In each adjustment, you can swap any two people at any positions, that is, swap the two letters at any positions in the sequence. Since the Leader is arriving soon, there is time for at most $K$ adjustments (you may also perform fewer than $K$), so this problem is assigned to you.", "inputFormat": "The first line contains two positive integers $N, K$, denoting the length of the sequence and the maximum number of swaps.\n\nThe second line contains a string of length $N$, consisting only of the letters `j` and `z`, describing the sequence.", "outputFormat": "Output a non-negative integer: after at most $K$ swaps, the maximum possible number of `jz` substrings.", "hint": "【Sample Explanation】\n\nFirst, swap the `z` at position 1 with the `j` at position 4 to get `jzzzj`.\nSecond, swap the `z` at position 4 with the `j` at position 5 to get `jzzjz`.\n\nThe final string has $2$ `jz` substrings.\n\n【Constraints】\n\nFor $10 \\%$ of the testdata, $N \\le 10$.  \nFor $30 \\%$ of the testdata, $K \\le 10$.  \nFor $40 \\%$ of the testdata, $N \\le 50$.  \nFor $100 \\%$ of the testdata, $1 \\le N \\le 500$, $1 \\le K \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "迎接仪式", "background": "", "description": "LHX 教主要来 X 市指导 OI 学习工作了。为了迎接教主，在一条道路旁，一群“Orz 教主 er”穿着文化衫站在道路两旁迎接教主，每件文化衫上都印着大字。一旁的 Orzer 依次摆出“欢迎欢迎欢迎欢迎……”的大字，但是领队突然发现，另一旁穿着“教”和“主”字文化衫的 Orzer 却不太和谐。\n\n为了简单描述这个不和谐的队列，我们用 `j` 替代“教”，`z` 替代“主”。而一个 `j` 与 `z` 组成的序列则可以描述当前的队列。为了让教主看得尽量舒服，你必须调整队列，使得 `jz` 子串尽量多。每次调整你可以交换任意位置上的两个人，也就是序列中任意位置上的两个字母。而因为教主马上就来了，时间仅够最多做 $K$ 次调整（当然可以调整不满 $K$ 次），所以这个问题交给了你。", "inputFormat": "第一行，两个正整数 $N, K$，分别表示序列长度与最多交换次数。\n\n第二行，一个长度为 $N$ 的字符串，字符串仅由字母 `j` 与字母 `z` 组成，描述了这个序列。", "outputFormat": "一个非负整数，为调整最多 $K$ 次后最后最多能出现多少个 `jz` 子串。", "hint": "**【样例说明】**\n\n第 $1$ 次交换位置 $1$ 上的 `z` 和位置 $4$ 上的 `j`，变为 `jzzzj`；\n\n第 $2$ 次交换位置 $4$ 上的 `z` 和位置 $5$ 上的 `j`，变为 `jzzjz`。\n\n最后的串有 $2$ 个 `jz` 子串。\n\n**【数据规模与约定】**\n\n对于 $10 \\%$ 的数据，有 $N \\le 10$；  \n对于 $30 \\%$ 的数据，有 $K \\le 10$；  \n对于 $40 \\%$ 的数据，有 $N \\le 50$；  \n对于 $100 \\%$ 的数据，有 $1 \\le N \\le 500$，$1 \\le K \\le 100$。", "locale": "zh-CN"}}}
{"pid": "P1137", "type": "P", "difficulty": 3, "samples": [["5 6\n1 2\n1 3\n2 3\n2 4\n3 4\n2 5\n", "1\n2\n3\n4\n3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "图论", "递推", "排序", "拓扑排序"], "title": "旅行计划", "background": "", "description": "小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。\n\n所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。\n\n现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。", "inputFormat": "第一行为两个正整数 $N, M$。\n\n接下来 $M$ 行，每行两个正整数 $x, y$，表示了有一条连接城市 $x$ 与城市 $y$ 的道路，保证了城市 $x$ 在城市 $y$ 西面。\n", "outputFormat": "$N$ 行，第 $i$ 行包含一个正整数，表示以第 $i$ 个城市为终点最多能游览多少个城市。\n", "hint": "均选择从城市 $1$ 出发可以得到以上答案。\n\n- 对于 $20\\%$ 的数据，$1\\le N ≤ 100$；\n- 对于 $60\\%$ 的数据，$1\\le N ≤ 1000$；\n- 对于 $100\\%$ 的数据，$1\\le N ≤ 100000$，$1\\le M ≤ 200000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Travel Plan", "background": "", "description": "Xiao Ming is going to travel to a country. This country has $N$ cities, numbered $1$ to $N$, and there are $M$ roads connecting them. Xiao Ming plans to start from some city and only move east until he stops at city $i$.\n\nTherefore, for each city $i$, he needs to choose a starting city and plan a route ending at city $i$, such that along the route, except for the first city, every city lies to the east of the previous city. Under this condition, he also wants to visit as many cities as possible.\n\nYou only know the relative east–west positions of the two cities connected by each road, but you do not know the exact positions of all cities. Now, for every $i$, you need to plan a route for Xiao Ming and compute the maximum number of cities that can be visited on a route ending at city $i$.", "inputFormat": "The first line contains two positive integers $N, M$.\n\nThe next $M$ lines each contain two positive integers $x, y$, indicating there is a road connecting city $x$ and city $y$, and it is guaranteed that city $x$ is to the west of city $y$.", "outputFormat": "Output $N$ lines. The $i$-th line contains a positive integer, the maximum number of cities that can be visited on a route ending at city $i$.", "hint": "Choosing to always start from city $1$ yields the answers.\n\nConstraints:\n- For $20\\%$ of the testdata, $1 \\le N \\le 100$.\n- For $60\\%$ of the testdata, $1 \\le N \\le 1000$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 100000$, $1 \\le M \\le 200000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "旅行计划", "background": "", "description": "小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。\n\n所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。\n\n现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。", "inputFormat": "第一行为两个正整数 $N, M$。\n\n接下来 $M$ 行，每行两个正整数 $x, y$，表示了有一条连接城市 $x$ 与城市 $y$ 的道路，保证了城市 $x$ 在城市 $y$ 西面。\n", "outputFormat": "$N$ 行，第 $i$ 行包含一个正整数，表示以第 $i$ 个城市为终点最多能游览多少个城市。\n", "hint": "均选择从城市 $1$ 出发可以得到以上答案。\n\n- 对于 $20\\%$ 的数据，$1\\le N ≤ 100$；\n- 对于 $60\\%$ 的数据，$1\\le N ≤ 1000$；\n- 对于 $100\\%$ 的数据，$1\\le N ≤ 100000$，$1\\le M ≤ 200000$。\n", "locale": "zh-CN"}}}
{"pid": "P1138", "type": "P", "difficulty": 2, "samples": [["10 3\n1 3 3 7 2 5 1 2 4 6\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "排序"], "title": "第 k 小整数", "background": null, "description": "现有 $n$ 个正整数，要求出这 $n$ 个正整数中的第 $k$ 个最小整数（相同大小的整数只计算一次）。", "inputFormat": "第一行为 $n$ 和 $k$; 第二行开始为 $n$ 个正整数的值，整数间用空格隔开。", "outputFormat": "第$k$个最小整数的值；若无解，则输出 `NO RESULT`。", "hint": "$n \\leq 10000$，$k \\leq 4000$，正整数均小于 $30000$。", "locale": "zh-CN", "translations": {"en": {"title": "The k-th Smallest Integer", "background": "", "description": "You are given $n$ positive integers. Find the $k$-th smallest integer among the distinct values (count equal integers only once).", "inputFormat": "The first line contains $n$ and $k$; starting from the second line are the $n$ positive integers, separated by spaces.", "outputFormat": "Output the value of the $k$-th smallest integer; if there is no solution, output `NO RESULT`.", "hint": "Constraints: $n \\leq 10000$, $k \\leq 4000$, and all positive integers are less than $30000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "第 k 小整数", "background": null, "description": "现有 $n$ 个正整数，要求出这 $n$ 个正整数中的第 $k$ 个最小整数（相同大小的整数只计算一次）。", "inputFormat": "第一行为 $n$ 和 $k$; 第二行开始为 $n$ 个正整数的值，整数间用空格隔开。", "outputFormat": "第$k$个最小整数的值；若无解，则输出 `NO RESULT`。", "hint": "$n \\leq 10000$，$k \\leq 4000$，正整数均小于 $30000$。", "locale": "zh-CN"}}}
{"pid": "P1139", "type": "P", "difficulty": 5, "samples": [["3\ncba\n", "c A B\nb A B\na A D\nb B D\nc B D\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索"], "title": "单向双轨道", "background": "", "description": "如图所示，某火车站有 B、C 两个调度站，左边入口 A 处有$n$ 辆火车等待进站(从左到右以 $a,b,c,d$ 编号)，右边是出口 D，规定在这一段，火车从 A 进入经过 B、C 只能从左向右单向开，并且 B、C 调度站不限定所能停放的车辆数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/m1n53d63.png)\n\n从文件输入 $n$ 及 $n$ 个小写字母的一个排列，该排列表示火车在出口 D 处形成的从左到右的火车编号序列。输出为一系列操作过程，每一行形如 $h, L, R$ 的字母序列，其中 $h$ 为火车编号，$L$ 为 $h$ 车原先所在位置（位置都以$\\verb!A,B,C,D!$ 表示），$R$ 为新位置。或者输出 `NO` 表示不能完成这样的调度。\n", "inputFormat": "一个数 $n\\ (1<n\\le 15)$ 及由 $n$ 个小写字母组成的字符串。\n", "outputFormat": "可以调度则输出最短的调度序列，当有多种方案时输出按操作 $(L,R)$ 字典序最小的方案，不可以调度时则输出 `NO`。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "One-way Double Tracks", "background": "", "description": "As shown in the figure, a rail yard has two shunting stations B and C. At the left entrance A, there are $n$ trains waiting to enter (from left to right labeled $a, b, c, d$), and on the right side is the exit D. On this segment, trains entering from A and passing through B and C can only move one-way from left to right, and shunting stations B and C have no limit on the number of cars they can hold.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/m1n53d63.png)\n\nYou are given $n$ and a permutation of $n$ lowercase letters, which represents the sequence of train IDs from left to right formed at exit D. Output a sequence of operations, one per line, each being a letter sequence of the form $h, L, R$, where $h$ is a train ID, $L$ is the original position of $h$ (positions are denoted by $\\verb!A,B,C,D!$), and $R$ is the new position. Otherwise, output `NO` to indicate that such a dispatch cannot be completed.", "inputFormat": "An integer $n$ ($1 < n \\le 15$) and a string consisting of $n$ lowercase letters.", "outputFormat": "If it is feasible, output the shortest dispatch sequence. When there are multiple solutions, output the lexicographically smallest scheme with respect to the operation $(L, R)$. If it is not feasible, output `NO`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "单向双轨道", "background": "", "description": "如图所示，某火车站有 B、C 两个调度站，左边入口 A 处有$n$ 辆火车等待进站(从左到右以 $a,b,c,d$ 编号)，右边是出口 D，规定在这一段，火车从 A 进入经过 B、C 只能从左向右单向开，并且 B、C 调度站不限定所能停放的车辆数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/m1n53d63.png)\n\n从文件输入 $n$ 及 $n$ 个小写字母的一个排列，该排列表示火车在出口 D 处形成的从左到右的火车编号序列。输出为一系列操作过程，每一行形如 $h, L, R$ 的字母序列，其中 $h$ 为火车编号，$L$ 为 $h$ 车原先所在位置（位置都以$\\verb!A,B,C,D!$ 表示），$R$ 为新位置。或者输出 `NO` 表示不能完成这样的调度。\n", "inputFormat": "一个数 $n\\ (1<n\\le 15)$ 及由 $n$ 个小写字母组成的字符串。\n", "outputFormat": "可以调度则输出最短的调度序列，当有多种方案时输出按操作 $(L,R)$ 字典序最小的方案，不可以调度时则输出 `NO`。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1140", "type": "P", "difficulty": 3, "samples": [["7 AGTGATG\n5 GTTAG\n", "14\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP"], "title": "相似基因", "background": "大家都知道，基因可以看作一个碱基对序列。它包含了 $4$ 种核苷酸，简记作 `A, C, G, T`。生物学家正致力于寻找人类基因的功能，以利用于诊断疾病和发明药物。\n\n在一个人类基因工作组的任务中，生物学家研究的是：两个基因的相似程度。因为这个研究对疾病的治疗有着非同寻常的作用。", "description": "两个基因的相似度的计算方法如下：\n\n对于两个已知基因，例如 `AGTGATG` 和 `GTTAG`，将它们的碱基互相对应。当然，中间可以加入一些空碱基 `-`，例如：\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|c|} \\hline\n\\tt A & \\tt G & \\tt T & \\tt G & \\tt A & \\tt T & \\texttt - & \\tt G \\\\ \\hline\n\\texttt - & \\tt G & \\tt T & \\texttt - & \\texttt - & \\tt T & \\texttt A & \\tt G \\\\ \\hline\n\\end{array}\n$$\n\n这样，两个基因之间的相似度就可以用碱基之间相似度的总和来描述，碱基之间的相似度如下表所示：\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{ |c|c|c|c|c|c|} \\hline\n& \\tt A & \\tt C & \\tt G & \\tt T & \\texttt - \\\\ \\hline\n\\tt A & 5 & -1 & -2 & -1 & -3\\\\ \\hline\n\\tt C & -1 & 5 & -3 & -2 & -4 \\\\\\hline\n\\tt G & -2 & -3 & 5 & -2 & -2 \\\\\\hline\n\\tt T & -1 & -2 & -2 & 5 & -1 \\\\\\hline\n\\texttt - & -3 & -4 & -2 & -1 & * \\\\\\hline\n\\end{array}\n$$ \n\n那么相似度就是：$(-3)+5+5+(-2)+(-3)+5+(-3)+5=9$。因为两个基因的对应方法不唯一，例如又有：\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|} \\hline\n\\tt A & \\tt G & \\tt T & \\tt G & \\tt A & \\tt T & \\tt G \\\\ \\hline\n\\texttt - & \\tt G & \\tt T & \\texttt T & \\texttt A & \\texttt - & \\tt G \\\\ \\hline\n\\end{array}\n$$\n\n相似度为：$(-3)+5+5+(-2)+5+(-1)+5=14$。规定两个基因的相似度为所有对应方法中，相似度最大的那个。\n", "inputFormat": "共两行。每行首先是一个整数 $n$，表示基因序列的长度；隔一个空格后是一个基因序列，序列中只含 $\\verb!A!,\\verb!C!,\\verb!G!,\\verb!T!$ 四种字母。$1 \\le n\\le 100$。\n", "outputFormat": "仅一行，即输入基因的相似度。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Similar Genes", "background": "Everyone knows that a gene can be regarded as a sequence of base pairs. It contains 4 types of nucleotides, abbreviated as `A, C, G, T`. Biologists are working to discover the functions of human genes in order to diagnose diseases and invent medicines.\n\nIn a task by a human gene working group, biologists are studying the similarity between two genes, because this research plays an extraordinary role in treating diseases.", "description": "The similarity between two genes is computed as follows:\n\nFor two given genes, for example `AGTGATG` and `GTTAG`, align their bases with each other. Of course, you may insert some gap bases `-` in between, for example:\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|c|} \\hline\n\\tt A & \\tt G & \\tt T & \\tt G & \\tt A & \\tt T & \\texttt - & \\tt G \\\\ \\hline\n\\texttt - & \\tt G & \\tt T & \\texttt - & \\texttt - & \\tt T & \\texttt A & \\tt G \\\\ \\hline\n\\end{array}\n$$\n\nThen the similarity between the two genes can be described as the sum of pairwise base similarities, as shown in the following table:\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{ |c|c|c|c|c|c|} \\hline\n& \\tt A & \\tt C & \\tt G & \\tt T & \\texttt - \\\\ \\hline\n\\tt A & 5 & -1 & -2 & -1 & -3\\\\ \\hline\n\\tt C & -1 & 5 & -3 & -2 & -4 \\\\\\hline\n\\tt G & -2 & -3 & 5 & -2 & -2 \\\\\\hline\n\\tt T & -1 & -2 & -2 & 5 & -1 \\\\\\hline\n\\texttt - & -3 & -4 & -2 & -1 & * \\\\\\hline\n\\end{array}\n$$ \n\nThus the similarity is: $(-3)+5+5+(-2)+(-3)+5+(-3)+5=9$. Since the alignment between two genes is not unique, for example:\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|} \\hline\n\\tt A & \\tt G & \\tt T & \\tt G & \\tt A & \\tt T & \\tt G \\\\ \\hline\n\\texttt - & \\tt G & \\tt T & \\texttt T & \\texttt A & \\texttt - & \\tt G \\\\ \\hline\n\\end{array}\n$$\n\nThe similarity is: $(-3)+5+5+(-2)+5+(-1)+5=14$. Define the similarity between two genes as the maximum similarity among all alignments.", "inputFormat": "There are two lines. Each line first contains an integer $n$, representing the length of the gene sequence; after a space is a gene sequence that contains only the four letters $\\verb!A!,\\verb!C!,\\verb!G!,\\verb!T!$. $1 \\le n \\le 100$.", "outputFormat": "Only one line: the similarity of the input genes.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "相似基因", "background": "大家都知道，基因可以看作一个碱基对序列。它包含了 $4$ 种核苷酸，简记作 `A, C, G, T`。生物学家正致力于寻找人类基因的功能，以利用于诊断疾病和发明药物。\n\n在一个人类基因工作组的任务中，生物学家研究的是：两个基因的相似程度。因为这个研究对疾病的治疗有着非同寻常的作用。", "description": "两个基因的相似度的计算方法如下：\n\n对于两个已知基因，例如 `AGTGATG` 和 `GTTAG`，将它们的碱基互相对应。当然，中间可以加入一些空碱基 `-`，例如：\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|c|} \\hline\n\\tt A & \\tt G & \\tt T & \\tt G & \\tt A & \\tt T & \\texttt - & \\tt G \\\\ \\hline\n\\texttt - & \\tt G & \\tt T & \\texttt - & \\texttt - & \\tt T & \\texttt A & \\tt G \\\\ \\hline\n\\end{array}\n$$\n\n这样，两个基因之间的相似度就可以用碱基之间相似度的总和来描述，碱基之间的相似度如下表所示：\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{ |c|c|c|c|c|c|} \\hline\n& \\tt A & \\tt C & \\tt G & \\tt T & \\texttt - \\\\ \\hline\n\\tt A & 5 & -1 & -2 & -1 & -3\\\\ \\hline\n\\tt C & -1 & 5 & -3 & -2 & -4 \\\\\\hline\n\\tt G & -2 & -3 & 5 & -2 & -2 \\\\\\hline\n\\tt T & -1 & -2 & -2 & 5 & -1 \\\\\\hline\n\\texttt - & -3 & -4 & -2 & -1 & * \\\\\\hline\n\\end{array}\n$$ \n\n那么相似度就是：$(-3)+5+5+(-2)+(-3)+5+(-3)+5=9$。因为两个基因的对应方法不唯一，例如又有：\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|} \\hline\n\\tt A & \\tt G & \\tt T & \\tt G & \\tt A & \\tt T & \\tt G \\\\ \\hline\n\\texttt - & \\tt G & \\tt T & \\texttt T & \\texttt A & \\texttt - & \\tt G \\\\ \\hline\n\\end{array}\n$$\n\n相似度为：$(-3)+5+5+(-2)+5+(-1)+5=14$。规定两个基因的相似度为所有对应方法中，相似度最大的那个。\n", "inputFormat": "共两行。每行首先是一个整数 $n$，表示基因序列的长度；隔一个空格后是一个基因序列，序列中只含 $\\verb!A!,\\verb!C!,\\verb!G!,\\verb!T!$ 四种字母。$1 \\le n\\le 100$。\n", "outputFormat": "仅一行，即输入基因的相似度。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1141", "type": "P", "difficulty": 3, "samples": [["2 2\n01\n10\n1 1\n2 2\n", "4\n4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "并查集", "广度优先搜索 BFS", "队列"], "title": "01迷宫", "background": "", "description": "有一个仅由数字 $0$ 与 $1$ 组成的 $n \\times n$ 格迷宫。若你位于一格 $0$ 上，那么你可以移动到相邻 $4$ 格中的某一格 $1$ 上，同样若你位于一格 $1$ 上，那么你可以移动到相邻 $4$ 格中的某一格 $0$ 上。\n\n你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。", "inputFormat": "第一行为两个正整数 $n,m$。\n\n下面 $n$ 行，每行 $n$ 个字符，字符只可能是 $0$ 或者 $1$，字符之间没有空格。\n\n接下来 $m$ 行，每行两个用空格分隔的正整数 $i,j$，对应了迷宫中第 $i$ 行第 $j$ 列的一个格子，询问从这一格开始能移动到多少格。", "outputFormat": "$m$ 行，对于每个询问输出相应答案。\n", "hint": "对于样例，所有格子互相可达。\n\n- 对于 $20\\%$ 的数据，$n \\leq 10$；\n- 对于 $40\\%$ 的数据，$n \\leq 50$；\n- 对于 $50\\%$ 的数据，$m \\leq 5$；\n- 对于 $60\\%$ 的数据，$n,m \\leq 100$；\n- 对于 $100\\%$ 的数据，$1\\le n \\leq 1000$，$1\\le m \\leq 100000$。", "locale": "zh-CN", "translations": {"en": {"title": "01 Maze", "background": "", "description": "There is an $n \\times n$ grid maze consisting only of digits $0$ and $1$. If you are on a cell with $0$, you may move to one of the 4 adjacent cells with $1$. Similarly, if you are on a cell with $1$, you may move to one of the 4 adjacent cells with $0$.\n\nYour task is: for the given maze, for each specified starting cell, determine how many cells are reachable (including the starting cell).", "inputFormat": "The first line contains two positive integers $n,m$.\n\nThe next $n$ lines each contain $n$ characters, each of which is either $0$ or $1$, with no spaces between characters.\n\nThen follow $m$ lines. Each line contains two positive integers $i,j$, referring to the cell at row $i$, column $j$ of the maze, asking how many cells are reachable starting from this cell.", "outputFormat": "Output $m$ lines. For each query, print the corresponding answer.", "hint": "For the sample, all cells are mutually reachable.\n\n- For $20\\%$ of the testdata, $n \\leq 10$.\n- For $40\\%$ of the testdata, $n \\leq 50$.\n- For $50\\%$ of the testdata, $m \\leq 5$.\n- For $60\\%$ of the testdata, $n,m \\leq 100$.\n- For $100\\%$ of the testdata, $1\\le n \\leq 1000$, $1\\le m \\leq 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "01迷宫", "background": "", "description": "有一个仅由数字 $0$ 与 $1$ 组成的 $n \\times n$ 格迷宫。若你位于一格 $0$ 上，那么你可以移动到相邻 $4$ 格中的某一格 $1$ 上，同样若你位于一格 $1$ 上，那么你可以移动到相邻 $4$ 格中的某一格 $0$ 上。\n\n你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。", "inputFormat": "第一行为两个正整数 $n,m$。\n\n下面 $n$ 行，每行 $n$ 个字符，字符只可能是 $0$ 或者 $1$，字符之间没有空格。\n\n接下来 $m$ 行，每行两个用空格分隔的正整数 $i,j$，对应了迷宫中第 $i$ 行第 $j$ 列的一个格子，询问从这一格开始能移动到多少格。", "outputFormat": "$m$ 行，对于每个询问输出相应答案。\n", "hint": "对于样例，所有格子互相可达。\n\n- 对于 $20\\%$ 的数据，$n \\leq 10$；\n- 对于 $40\\%$ 的数据，$n \\leq 50$；\n- 对于 $50\\%$ 的数据，$m \\leq 5$；\n- 对于 $60\\%$ 的数据，$n,m \\leq 100$；\n- 对于 $100\\%$ 的数据，$1\\le n \\leq 1000$，$1\\le m \\leq 100000$。", "locale": "zh-CN"}}}
{"pid": "P1142", "type": "P", "difficulty": 3, "samples": [["5\n1 1\n2 2\n3 3\n9 10\n10 11\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "枚举", "排序"], "title": "轰炸", "background": "", "description": "“我该怎么办？”飞行员 klux 向你求助。\n\n事实上，klux 面对的是一个很简单的问题，但是他实在太菜了。\n\nklux 要想轰炸某个区域内的一些地方，它们是位于平面上的一些点，但是（显然地）klux 遇到了抵抗，所以 klux 只能飞一次，而且由于飞机比较破，一但起飞就只能沿直线飞行，无法转弯。现在他想一次轰炸最多的地方。\n", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行，每行有一对整数，表示一个点的坐标。没有一个点会出现两次。\n", "outputFormat": "一个整数，表示一条直线能覆盖的最多的点数。\n", "hint": "### 数据范围\n\n对于全部数据，保证 $1\\le n\\le 700$。\n\n本题翻译并改编自 uva270，数据及解答由 uva 提供。\n", "locale": "zh-CN", "translations": {"en": {"title": "Bombing", "background": "", "description": "\"What should I do?\" pilot klux asks you for help.\n\nIn fact, klux is facing a very simple problem, but he is not good at it.\n\nklux wants to bomb some locations in a certain area; they are points on a plane. However, he meets resistance, so he can fly only once, and because the plane is in poor condition, once it takes off it can only fly in a straight line and cannot turn. Now he wants to hit as many locations as possible in one flight.", "inputFormat": "The first line contains an integer $n$.\n\nThen $n$ lines follow, each containing a pair of integers that represent the coordinates of a point. No point appears twice.", "outputFormat": "A single integer, the maximum number of points that a straight line can cover.", "hint": "Constraints: For all testdata, it is guaranteed that $1\\le n\\le 700$.\n\nThis problem is translated and adapted from UVA 270; testdata and solution are provided by UVA.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "轰炸", "background": "", "description": "“我该怎么办？”飞行员 klux 向你求助。\n\n事实上，klux 面对的是一个很简单的问题，但是他实在太菜了。\n\nklux 要想轰炸某个区域内的一些地方，它们是位于平面上的一些点，但是（显然地）klux 遇到了抵抗，所以 klux 只能飞一次，而且由于飞机比较破，一但起飞就只能沿直线飞行，无法转弯。现在他想一次轰炸最多的地方。\n", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行，每行有一对整数，表示一个点的坐标。没有一个点会出现两次。\n", "outputFormat": "一个整数，表示一条直线能覆盖的最多的点数。\n", "hint": "### 数据范围\n\n对于全部数据，保证 $1\\le n\\le 700$。\n\n本题翻译并改编自 uva270，数据及解答由 uva 提供。\n", "locale": "zh-CN"}}}
{"pid": "P1143", "type": "P", "difficulty": 2, "samples": [["16\nFF\n2\n", "11111111"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "进制"], "title": "进制转换", "background": "", "description": "请你编一程序实现两种不同进制之间的数据转换。\n", "inputFormat": "共三行，第一行是一个正整数，表示需要转换的数的进制 $n\\ (2\\le n\\le 16)$，第二行是一个 $n$ 进制数，若 $n>10$ 则用大写字母 $\\verb!A!\\sim \\verb!F!$ 表示数码 $10\\sim 15$，并且该 $n$ 进制数对应的十进制的值不超过 $10^9$，第三行也是一个正整数，表示转换之后的数的进制 $m\\ (2\\le m\\le 16)$。", "outputFormat": "一个正整数，表示转换之后的 $m$ 进制数。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Base Conversion", "background": "", "description": "Write a program to convert a number between two different bases.", "inputFormat": "There are three lines. The first line is a positive integer denoting the base of the given number, $n\\ (2\\le n\\le 16)$. The second line is a base-$n$ number; if $n>10$, use uppercase letters $\\verb!A!\\sim \\verb!F!$ for digits $10\\sim 15$, and the decimal value of this base-$n$ number does not exceed $10^9$. The third line is also a positive integer denoting the target base, $m\\ (2\\le m\\le 16)$.", "outputFormat": "A single positive integer, which is the number in base $m$ after conversion.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "进制转换", "background": "", "description": "请你编一程序实现两种不同进制之间的数据转换。\n", "inputFormat": "共三行，第一行是一个正整数，表示需要转换的数的进制 $n\\ (2\\le n\\le 16)$，第二行是一个 $n$ 进制数，若 $n>10$ 则用大写字母 $\\verb!A!\\sim \\verb!F!$ 表示数码 $10\\sim 15$，并且该 $n$ 进制数对应的十进制的值不超过 $10^9$，第三行也是一个正整数，表示转换之后的数的进制 $m\\ (2\\le m\\le 16)$。", "outputFormat": "一个正整数，表示转换之后的 $m$ 进制数。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1144", "type": "P", "difficulty": 4, "samples": [["5 7\n1 2\n1 3\n2 4\n3 4\n2 3\n4 5\n4 5\n", "1\n1\n1\n2\n4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "广度优先搜索 BFS", "最短路"], "title": "最短路计数", "background": "", "description": "给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。\n", "inputFormat": "第一行包含 $2$ 个正整数 $N,M$，为图的顶点数与边数。\n\n接下来 $M$ 行，每行 $2$ 个正整数 $x,y$，表示有一条连接顶点 $x$ 和顶点 $y$ 的边，请注意可能有自环与重边。\n", "outputFormat": "共 $N$ 行，每行一个非负整数，第 $i$ 行输出从顶点 $1$ 到顶点 $i$ 有多少条不同的最短路，由于答案有可能会很大，你只需要输出 $ ans \\bmod 100003$ 后的结果即可。如果无法到达顶点 $i$ 则输出 $0$。\n", "hint": "$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\\to 2\\to 4\\to 5$ 和 $2$ 条 $1\\to 3\\to 4\\to 5$（由于 $4\\to 5$ 的边有 $2$ 条）。\n\n对于 $20\\%$ 的数据，$1\\le N \\le 100$；  \n对于 $60\\%$ 的数据，$1\\le N \\le 10^3$；  \n对于 $100\\%$ 的数据，$1\\le N\\le10^6$，$1\\le M\\le 2\\times 10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Shortest Path Counting", "background": "", "description": "Given an undirected, unweighted graph with $N$ vertices and $M$ edges, where vertices are numbered $1\\sim N$. Starting from vertex $1$, determine how many shortest paths there are to every other vertex.", "inputFormat": "The first line contains $2$ positive integers $N, M$, the number of vertices and edges of the graph.\n\nThe next $M$ lines each contain $2$ positive integers $x, y$, indicating there is an edge connecting vertex $x$ and vertex $y$. Note that self-loops and multiple edges may exist.", "outputFormat": "Output $N$ lines. The $i$-th line contains a non-negative integer: the number of different shortest paths from vertex $1$ to vertex $i$. Since the answer can be large, you only need to output $ans \\bmod 100003$. If vertex $i$ is unreachable, output $0$.", "hint": "From $1$ to $5$, there are $4$ shortest paths: $2$ paths $1\\to 2\\to 4\\to 5$ and $2$ paths $1\\to 3\\to 4\\to 5$ (because there are $2$ edges between $4$ and $5$).\n\nConstraints:\n- For $20\\%$ of the testdata, $1\\le N \\le 100$.\n- For $60\\%$ of the testdata, $1\\le N \\le 10^3$.\n- For $100\\%$ of the testdata, $1\\le N \\le 10^6$, $1\\le M \\le 2\\times 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最短路计数", "background": "", "description": "给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。\n", "inputFormat": "第一行包含 $2$ 个正整数 $N,M$，为图的顶点数与边数。\n\n接下来 $M$ 行，每行 $2$ 个正整数 $x,y$，表示有一条连接顶点 $x$ 和顶点 $y$ 的边，请注意可能有自环与重边。\n", "outputFormat": "共 $N$ 行，每行一个非负整数，第 $i$ 行输出从顶点 $1$ 到顶点 $i$ 有多少条不同的最短路，由于答案有可能会很大，你只需要输出 $ ans \\bmod 100003$ 后的结果即可。如果无法到达顶点 $i$ 则输出 $0$。\n", "hint": "$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\\to 2\\to 4\\to 5$ 和 $2$ 条 $1\\to 3\\to 4\\to 5$（由于 $4\\to 5$ 的边有 $2$ 条）。\n\n对于 $20\\%$ 的数据，$1\\le N \\le 100$；  \n对于 $60\\%$ 的数据，$1\\le N \\le 10^3$；  \n对于 $100\\%$ 的数据，$1\\le N\\le10^6$，$1\\le M\\le 2\\times 10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P1145", "type": "P", "difficulty": 2, "samples": [["3", "5"], ["4", "30"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "枚举", "剪枝", "ICPC", "CERC"], "title": "[CERC 1995] 约瑟夫", "background": "", "description": "$2k$ 个人站成一圈，从某个人开始数数，每次数到 $m$ 的人就被杀掉，然后下一个人重新开始数，直到最后只剩一个人。现在有一圈人，$k$ 个好人站在一起，$k$ 个坏人站在一起。从第一个好人开始数数。你要确定一个最小的 $m$，使得在 $k$ 个坏人均被杀死时 $k$ 个好人都存活。", "inputFormat": "一行一个整数 $k$。", "outputFormat": "一行一个整数 $m$。", "hint": "$0\\lt k\\lt 14$。", "locale": "zh-CN", "translations": {"en": {"title": "[CERC 1995] Joseph", "background": null, "description": "$2k$ people stand in a circle. Starting from some person, we count; each time the count reaches $m$, that person is killed, and then the next person starts counting again. This continues until only one person remains. Now consider a circle where $k$ good people stand together and $k$ bad people stand together. Counting starts from the first good person. You must determine the smallest $m$ such that, by the time all $k$ bad people have been killed, all $k$ good people are still alive.", "inputFormat": "One line containing an integer $k$.", "outputFormat": "One line containing an integer $m$.", "hint": "$0 \\lt k \\lt 14$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC 1995] 约瑟夫", "background": "", "description": "$2k$ 个人站成一圈，从某个人开始数数，每次数到 $m$ 的人就被杀掉，然后下一个人重新开始数，直到最后只剩一个人。现在有一圈人，$k$ 个好人站在一起，$k$ 个坏人站在一起。从第一个好人开始数数。你要确定一个最小的 $m$，使得在 $k$ 个坏人均被杀死时 $k$ 个好人都存活。", "inputFormat": "一行一个整数 $k$。", "outputFormat": "一行一个整数 $m$。", "hint": "$0\\lt k\\lt 14$。", "locale": "zh-CN"}}}
{"pid": "P1146", "type": "P", "difficulty": 2, "samples": [["4", "4\n0111\n1100\n0001\n1111\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "数学"], "title": "硬币翻转", "background": "", "description": "在桌面上有一排硬币，共 $N$ 枚，每一枚硬币均为正面朝上。现在要把所有的硬币翻转成反面朝上，规则是每次可翻转任意 $N-1$ 枚硬币（正面向上的被翻转为反面向上，反之亦然）。求一个最短的操作序列（将每次翻转 $N-1$ 枚硬币成为一次操作）。", "inputFormat": "一个自然数 $N$（$N$ 为不大于 $100$ 的偶数）。", "outputFormat": "第一行包含一个整数 $S$，表示最少需要的操作次数。\n\n接下来的 $S$ 行每行分别表示每次操作后桌上硬币的状态（一行包含 $N$ 个整数 $0$ 或 $1$，表示每个硬币的状态，$0$ 表示正面向上，$1$ 表示反面向上。不允许输出多余空格。\n\n对于有多种操作方案的情况，则只需**操作的字典序**最小输出一种。\n\n操作的字典序是指，对于一次操作中的每个位置，$1$ 表示翻转，$0$ 表示不反转。\n\n但是需要你输出的是每一次操作完的状态，$0$ 表示正面朝上，$1$ 表示反面朝上。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Coin Flipping", "background": "", "description": "There is a row of $N$ coins on the table, all initially heads up. You need to turn all coins to tails up. The rule is that each time you may flip any $N-1$ coins (a heads-up coin becomes tails up, and vice versa). Find a shortest sequence of operations (each flip of $N-1$ coins counts as one operation).", "inputFormat": "A natural number $N$ (where $N$ is an even number no greater than 100).", "outputFormat": "The first line contains an integer $S$, the minimal number of operations needed.\n\nThe next $S$ lines each describe the state of the coins on the table after that operation (a line with $N$ integers 0 or 1, indicating each coin’s state; 0 means heads up, 1 means tails up). No extra spaces are allowed.\n\nIf there are multiple valid operation sequences, output one whose sequence of operations is lexicographically smallest.\n\nThe lexicographical order of an operation is defined as follows: for each position in a single operation, 1 means flip, and 0 means do not flip.\n\nHowever, you must output the state after each operation, where 0 means heads up and 1 means tails up.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "硬币翻转", "background": "", "description": "在桌面上有一排硬币，共 $N$ 枚，每一枚硬币均为正面朝上。现在要把所有的硬币翻转成反面朝上，规则是每次可翻转任意 $N-1$ 枚硬币（正面向上的被翻转为反面向上，反之亦然）。求一个最短的操作序列（将每次翻转 $N-1$ 枚硬币成为一次操作）。", "inputFormat": "一个自然数 $N$（$N$ 为不大于 $100$ 的偶数）。", "outputFormat": "第一行包含一个整数 $S$，表示最少需要的操作次数。\n\n接下来的 $S$ 行每行分别表示每次操作后桌上硬币的状态（一行包含 $N$ 个整数 $0$ 或 $1$，表示每个硬币的状态，$0$ 表示正面向上，$1$ 表示反面向上。不允许输出多余空格。\n\n对于有多种操作方案的情况，则只需**操作的字典序**最小输出一种。\n\n操作的字典序是指，对于一次操作中的每个位置，$1$ 表示翻转，$0$ 表示不反转。\n\n但是需要你输出的是每一次操作完的状态，$0$ 表示正面朝上，$1$ 表示反面朝上。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1147", "type": "P", "difficulty": 2, "samples": [["10000\n", "18 142 \n297 328 \n388 412 \n1998 2002\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "枚举", "前缀和", "双指针 two-pointer"], "title": "连续正整数和", "background": null, "description": "给定一个正整数 $M$，求出所有的连续的正整数段（每一段至少有两个数），使得这些连续的正整数段中的全部数之和为 $M$。\n\n例如，$1998+1999+2000+2001+2002=10000$，所以从 $1998$ 到 $2002$ 的一个正整数段为 $M=10000$ 的一个解。", "inputFormat": "输入一行一个正整数，表示 $M$ 的值（$10\\le M\\le 2\\times 10^6$）。", "outputFormat": "输出每行包含两个正整数，表示一个满足条件的连续正整数段的左右端点，两数之间用一个空格隔开。\n\n输出按左端点大小升序排列。", "hint": "对于 $100\\%$ 的数据，保证至少有一个解。", "locale": "zh-CN", "translations": {"en": {"title": "Sum of Consecutive Positive Integers", "background": "", "description": "Given a positive integer $M$, find all segments of consecutive positive integers (each segment must contain at least two numbers) whose sum is $M$.\n\nExample: $1998+1999+2000+2001+2002 = 10000$, so the segment from $1998$ to $2002$ is a solution for $M=10000$.", "inputFormat": "A single line containing an integer giving the value of $M$ ($10 \\le M \\le 2,000,000$).", "outputFormat": "Output one line per solution, containing two positive integers: the first and last numbers of a valid consecutive positive integer segment, separated by a space. Sort all lines by the first number in ascending order. For the given input, at least one solution exists.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "连续正整数和", "background": null, "description": "给定一个正整数 $M$，求出所有的连续的正整数段（每一段至少有两个数），使得这些连续的正整数段中的全部数之和为 $M$。\n\n例如，$1998+1999+2000+2001+2002=10000$，所以从 $1998$ 到 $2002$ 的一个正整数段为 $M=10000$ 的一个解。", "inputFormat": "输入一行一个正整数，表示 $M$ 的值（$10\\le M\\le 2\\times 10^6$）。", "outputFormat": "输出每行包含两个正整数，表示一个满足条件的连续正整数段的左右端点，两数之间用一个空格隔开。\n\n输出按左端点大小升序排列。", "hint": "对于 $100\\%$ 的数据，保证至少有一个解。", "locale": "zh-CN"}}}
{"pid": "P1148", "type": "P", "difficulty": 3, "samples": [["4  S12  H3  H5  H13\n3  D11  H8  H9\n6  C10  H1  H2  H4  H6  H7\n3  H10  H11 H12\n13 H1  H2  H3  H4  H5  H6  H7  H8  H9  H10  H11  H12  H13  \n2  S12  C10\n1  D11\n0\n0\n0\n0\n0\n", "-148 +83 -138 -60\n+200 -200 +100 0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "拱猪计分", "background": null, "description": "「拱猪」是一种很有趣的扑克牌游戏。即使你不知道它的玩法，你也可以由它的计分方式来了解它的趣味性。假设在此我们仅考虑四个人的拱猪牌局，本题要求你根据下面的计分规则，在牌局结束时计算四位玩家所得分数。\n\n1. 我们分别以 $\\texttt S, \\texttt H, \\texttt D, \\texttt C$ 来代表黑桃、红心、方块及梅花，并以数字 $1$ 至 $13$ 来代表 $\\texttt A, \\texttt 2, \\dots, \\texttt Q, \\texttt K$ 等牌点，例如：$H_1$ 为红心 $\\texttt A$，$S_{13}$ 为黑桃 $\\texttt K$；\n2. 牌局结束时，由各玩家持有的有关计分的牌（计分牌）仅有「猪」$S_{12}$，所有红心牌，「羊」$D_{11}$ 及「加倍」$C_{10}$ 等 $16$ 张牌，其它牌均弃置不计（也就是在下面的算分过程中不再考虑这些牌），若一位玩家未持有这 $16$ 张牌中任意一张，则以得零分计算；\n3. 若持有 $C_{10}$ 牌的玩家只有该张牌而没有任何其它牌则得 $+50$ 分，否则将其它计分牌所得分数加倍计算；\n4. 若红心牌不在同一家，则 $H_1$ 至 $H_{13}$ 等 $13$ 张牌均以负分计，其数值依次为 $-50, -2, -3, -4, -5, -6, -7, -8, -9, -10, -20, -30, -40$，且 $S_{12}$ 与 $D_{11}$ 的分值分别以 $-100$ 及 $+100$ 分计算；\n5. 若红心牌 $H_1$ 至 $H_{13}$ 均在同一家，则有下列情形：\n\n+ 所有红心牌以 $+200$ 分计算。**不是每一张牌都以 $+200$ 分计算，而是所有红心牌。**\n+ 若 $S_{12}, D_{11}$ 皆在吃下所有红心牌之一家，则此玩家得 $+500$ 分，**这个分不与红心牌的 $+200$ 分叠加。** 否则这两张牌的分值以前文所述原则计算。\n+ $C_{10}$ 牌依旧以前文所述原则计算。\n\n例一：若各玩家持有计分牌如下：\n\n1. `S12 H3 H5 H13`\n2. `D11 H8 H9`\n3. `C10 H1 H2 H4 H6 H7`\n4. `H10 H11 H12`\n\n则各家之得分依序为：$-148, +83, -138$ 及 $-60$。\n\n例二：若各玩家持有计分牌如下：\n\n1. `H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13`\n2. `S12 C10`\n3. `D11`\n4. 无\n\n则各家之得分依序为：$+200, -200, +100$ 及 $0$。", "inputFormat": "**每个输入文件包含多组数据。**\n\n每组数据有四行，分别描述一个玩家。\n\n每一行，第一个数为该玩家所持有计分牌总数，随后若干个符合题意的字符串描述其所持有之所有计分牌，牌数与各计分牌均以一个以上的空格分开。\n\n相邻两组测试数据之间不包含空白行。若四家持牌数均为 $0$，表示输入文件结束，不应处理这个测试数据。", "outputFormat": "每一行表示一组数据对应的结果，依次输出各家所得分数，共 $4$ 个整数，若非 $0$ 则包含正负号；相邻两个整数之间以一个空格分开。\n\n符号和数字间不带空格。每组数据的输出间不带空白行。", "hint": "样例中两组数据为题面中的例子。", "locale": "zh-CN", "translations": {"en": {"title": "Gongzhu Scoring", "background": "", "description": "“Gongzhu” is a very interesting card game. Even if you do not know how to play it, you can appreciate its fun from the scoring rules. Here we only consider a four-player Gongzhu deal. Based on the rules below, compute the final score of each player when the deal ends.\n\n1. We use $\\texttt S, \\texttt H, \\texttt D, \\texttt C$ to represent Spades, Hearts, Diamonds, and Clubs, and numbers $1$ to $13$ to represent ranks $\\texttt A, \\texttt 2, \\dots, \\texttt Q, \\texttt K$. For example, $H_1$ is Heart $\\texttt A$, and $S_{13}$ is Spade $\\texttt K$.\n2. At the end of the deal, the only cards that matter for scoring (scoring cards) are the “Pig” $S_{12}$, all Heart cards, the “Sheep” $D_{11}$, and the “Double” $C_{10}$ — a total of $16$ cards. All other cards are discarded and do not count (that is, they are not considered in the scoring process below). If a player holds none of these $16$ cards, their score is $0$.\n3. If the player who holds $C_{10}$ has that card and no other scoring cards, they score $+50$ points. Otherwise, double the sum of that player’s other scoring cards.\n4. If the Heart cards are not all held by a single player, then the $13$ Heart cards $H_1$ to $H_{13}$ are negative, with values $-50, -2, -3, -4, -5, -6, -7, -8, -9, -10, -20, -30, -40$ in order. Also, $S_{12}$ and $D_{11}$ are scored as $-100$ and $+100$ points, respectively.\n5. If the Heart cards $H_1$ to $H_{13}$ are all held by a single player, then:\n- All Heart cards are scored as $+200$ points. This means the set of all Heart cards is worth $+200$ in total, not $+200$ per card.\n- If $S_{12}$ and $D_{11}$ are both also held by the same player who took all the Hearts, that player scores $+500$ points. This $+500$ does not stack with the $+200$ from the Hearts. Otherwise, these two cards are scored according to the earlier rules.\n- The $C_{10}$ card is still scored according to the earlier rules.\n\nExample 1: If the players’ scoring cards are:\n1. `S12 H3 H5 H13`\n2. `D11 H8 H9`\n3. `C10 H1 H2 H4 H6 H7`\n4. `H10 H11 H12`\n\nThen the scores for the four players, in order, are: $-148, +83, -138$, and $-60$.\n\nExample 2: If the players’ scoring cards are:\n1. `H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13`\n2. `S12 C10`\n3. `D11`\n4. None\n\nThen the scores for the four players, in order, are: $+200, -200, +100$, and $0$.", "inputFormat": "Each input file contains multiple test cases.\n\nEach test case has four lines, one per player.\n\nOn each line, the first number is the total count of scoring cards held by that player, followed by that many strings describing all their scoring cards. The count and the cards are separated by one or more spaces.\n\nThere are no blank lines between consecutive test cases. If all four players’ counts are $0$, the input ends and this test case should not be processed.", "outputFormat": "Each line corresponds to one test case’s result and contains the four players’ scores, in order, as $4$ integers with a sign if nonzero. Adjacent integers are separated by a single space.\n\nThere is no space between the sign and the number. Do not print blank lines between test cases.", "hint": "The two sample test cases correspond to the examples in the statement.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "拱猪计分", "background": null, "description": "「拱猪」是一种很有趣的扑克牌游戏。即使你不知道它的玩法，你也可以由它的计分方式来了解它的趣味性。假设在此我们仅考虑四个人的拱猪牌局，本题要求你根据下面的计分规则，在牌局结束时计算四位玩家所得分数。\n\n1. 我们分别以 $\\texttt S, \\texttt H, \\texttt D, \\texttt C$ 来代表黑桃、红心、方块及梅花，并以数字 $1$ 至 $13$ 来代表 $\\texttt A, \\texttt 2, \\dots, \\texttt Q, \\texttt K$ 等牌点，例如：$H_1$ 为红心 $\\texttt A$，$S_{13}$ 为黑桃 $\\texttt K$；\n2. 牌局结束时，由各玩家持有的有关计分的牌（计分牌）仅有「猪」$S_{12}$，所有红心牌，「羊」$D_{11}$ 及「加倍」$C_{10}$ 等 $16$ 张牌，其它牌均弃置不计（也就是在下面的算分过程中不再考虑这些牌），若一位玩家未持有这 $16$ 张牌中任意一张，则以得零分计算；\n3. 若持有 $C_{10}$ 牌的玩家只有该张牌而没有任何其它牌则得 $+50$ 分，否则将其它计分牌所得分数加倍计算；\n4. 若红心牌不在同一家，则 $H_1$ 至 $H_{13}$ 等 $13$ 张牌均以负分计，其数值依次为 $-50, -2, -3, -4, -5, -6, -7, -8, -9, -10, -20, -30, -40$，且 $S_{12}$ 与 $D_{11}$ 的分值分别以 $-100$ 及 $+100$ 分计算；\n5. 若红心牌 $H_1$ 至 $H_{13}$ 均在同一家，则有下列情形：\n\n+ 所有红心牌以 $+200$ 分计算。**不是每一张牌都以 $+200$ 分计算，而是所有红心牌。**\n+ 若 $S_{12}, D_{11}$ 皆在吃下所有红心牌之一家，则此玩家得 $+500$ 分，**这个分不与红心牌的 $+200$ 分叠加。** 否则这两张牌的分值以前文所述原则计算。\n+ $C_{10}$ 牌依旧以前文所述原则计算。\n\n例一：若各玩家持有计分牌如下：\n\n1. `S12 H3 H5 H13`\n2. `D11 H8 H9`\n3. `C10 H1 H2 H4 H6 H7`\n4. `H10 H11 H12`\n\n则各家之得分依序为：$-148, +83, -138$ 及 $-60$。\n\n例二：若各玩家持有计分牌如下：\n\n1. `H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13`\n2. `S12 C10`\n3. `D11`\n4. 无\n\n则各家之得分依序为：$+200, -200, +100$ 及 $0$。", "inputFormat": "**每个输入文件包含多组数据。**\n\n每组数据有四行，分别描述一个玩家。\n\n每一行，第一个数为该玩家所持有计分牌总数，随后若干个符合题意的字符串描述其所持有之所有计分牌，牌数与各计分牌均以一个以上的空格分开。\n\n相邻两组测试数据之间不包含空白行。若四家持牌数均为 $0$，表示输入文件结束，不应处理这个测试数据。", "outputFormat": "每一行表示一组数据对应的结果，依次输出各家所得分数，共 $4$ 个整数，若非 $0$ 则包含正负号；相邻两个整数之间以一个空格分开。\n\n符号和数字间不带空格。每组数据的输出间不带空白行。", "hint": "样例中两组数据为题面中的例子。", "locale": "zh-CN"}}}
{"pid": "P1149", "type": "P", "difficulty": 2, "samples": [["14", "2"], ["18", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2008", "NOIP 提高组", "枚举"], "title": "[NOIP 2008 提高组] 火柴棒等式", "background": "", "description": "给你 $n$ 根火柴棍，你可以拼出多少个形如 $A+B=C$ 的等式？等式中的 $A$、$B$、$C$ 是用火柴棍拼出的整数（若该数非零，则最高位不能是 $0$）。用火柴棍拼数字 $0\\sim9$ 的拼法如图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p5hsawt2.png)\n\n注意：\n\n1. 加号与等号各自需要两根火柴棍；\n2. 如果 $A\\neq B$，则 $A+B=C$ 与 $B+A=C$ 视为不同的等式（$A,B,C\\geq0$）；\n3. $n$ 根火柴棍必须全部用上。\n", "inputFormat": "一个整数 $n(1 \\leq n\\leq 24)$。\n", "outputFormat": "一个整数，能拼成的不同等式的数目。\n", "hint": "【输入输出样例 1 解释】\n\n$2$ 个等式为 $0+1=1$ 和 $1+0=1$。\n\n【输入输出样例 2 解释】\n\n$9$ 个等式为\n\n$0+4=4$、$0+11=11$、$1+10=11$、$2+2=4$、$2+7=9$、$4+0=4$、$7+2=9$、$10+1=11$、$11+0=11$。\n\nnoip2008 提高第二题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2008 Senior] Matchstick Equation", "background": "", "description": "Given $n$ matchsticks, how many equations of the form $A+B=C$ can you make? In the equation, $A$, $B$, and $C$ are integers formed with matchsticks (if the number is nonzero, its most significant digit cannot be $0$). The ways to form the digits $0$ to $9$ with matchsticks are shown in the figure:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p5hsawt2.png)\n\nNote:\n1. The plus sign and the equals sign each require two matchsticks.\n2. If $A\\neq B$, then $A+B=C$ and $B+A=C$ are considered different equations ($A,B,C\\geq 0$).\n3. All $n$ matchsticks must be used.", "inputFormat": "A single integer $n$ ($1 \\leq n \\leq 24$).", "outputFormat": "A single integer, the number of different equations that can be formed.", "hint": "[Explanation for Sample 1]\n\nThe $2$ equations are $0+1=1$ and $1+0=1$.\n\n[Explanation for Sample 2]\n\nThe $9$ equations are\n$0+4=4$, $0+11=11$, $1+10=11$, $2+2=4$, $2+7=9$, $4+0=4$, $7+2=9$, $10+1=11$, $11+0=11$.\n\nNOIP 2008 Senior Problem 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2008 提高组] 火柴棒等式", "background": "", "description": "给你 $n$ 根火柴棍，你可以拼出多少个形如 $A+B=C$ 的等式？等式中的 $A$、$B$、$C$ 是用火柴棍拼出的整数（若该数非零，则最高位不能是 $0$）。用火柴棍拼数字 $0\\sim9$ 的拼法如图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p5hsawt2.png)\n\n注意：\n\n1. 加号与等号各自需要两根火柴棍；\n2. 如果 $A\\neq B$，则 $A+B=C$ 与 $B+A=C$ 视为不同的等式（$A,B,C\\geq0$）；\n3. $n$ 根火柴棍必须全部用上。\n", "inputFormat": "一个整数 $n(1 \\leq n\\leq 24)$。\n", "outputFormat": "一个整数，能拼成的不同等式的数目。\n", "hint": "【输入输出样例 1 解释】\n\n$2$ 个等式为 $0+1=1$ 和 $1+0=1$。\n\n【输入输出样例 2 解释】\n\n$9$ 个等式为\n\n$0+4=4$、$0+11=11$、$1+10=11$、$2+2=4$、$2+7=9$、$4+0=4$、$7+2=9$、$10+1=11$、$11+0=11$。\n\nnoip2008 提高第二题", "locale": "zh-CN"}}}
{"pid": "P1150", "type": "P", "difficulty": 1, "samples": [["4 3\n", "5"], ["10 3", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "数学"], "title": "Peter 的烟", "background": "**温馨提醒：吸烟有害健康，请勿尝试吸烟！**", "description": "Peter 有 $n$ 根烟，他每吸完一根烟就把烟蒂保存起来，$k$（$k>1$）个烟蒂可以换一个新的烟，那么 Peter 最终能吸到多少根烟呢？\n\n与某些脑筋急转弯不同的是，Peter 并不能从异次元借到烟蒂，抽完后再还回去。", "inputFormat": "每组测试数据一行包括两个整数 $n, k$（$1 < n, k \\le 10^8$）。\n", "outputFormat": "对于每组测试数据，输出一行包括一个整数表示最终烟的根数。\n", "hint": "对于 $100\\%$ 的数据，$1<n, k \\le 10^8$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Peter's Cigarettes", "background": "**Warm reminder: Smoking is harmful to your health; please do not attempt to smoke!**", "description": "Peter has $n$ cigarettes. Each time he finishes a cigarette, he keeps the butt. $k$ ($k>1$) butts can be exchanged for one new cigarette. How many cigarettes can Peter smoke in total?\n\nUnlike some brain teasers, Peter cannot borrow cigarette butts from another dimension and return them after smoking.", "inputFormat": "Each test case consists of one line containing two integers $n, k$ ($1 < n, k \\le 10^8$).", "outputFormat": "For each test case, output one line containing one integer, the total number of cigarettes.", "hint": "For $100\\%$ of the testdata, $1 < n, k \\le 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Peter 的烟", "background": "**温馨提醒：吸烟有害健康，请勿尝试吸烟！**", "description": "Peter 有 $n$ 根烟，他每吸完一根烟就把烟蒂保存起来，$k$（$k>1$）个烟蒂可以换一个新的烟，那么 Peter 最终能吸到多少根烟呢？\n\n与某些脑筋急转弯不同的是，Peter 并不能从异次元借到烟蒂，抽完后再还回去。", "inputFormat": "每组测试数据一行包括两个整数 $n, k$（$1 < n, k \\le 10^8$）。\n", "outputFormat": "对于每组测试数据，输出一行包括一个整数表示最终烟的根数。\n", "hint": "对于 $100\\%$ 的数据，$1<n, k \\le 10^8$。\n", "locale": "zh-CN"}}}
{"pid": "P1151", "type": "P", "difficulty": 1, "samples": [["15", "22555\n25555\n28555\n30000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "搜索", "枚举"], "title": "子数整数", "background": "", "description": "对于一个五位数 $\\overline{a_1a_2a_3a_4a_5}$，可将其拆分为三个子数：\n\n$sub_1=\\overline{a_1a_2a_3}$\n\n$sub_2=\\overline{a_2a_3a_4}$\n\n$sub_3=\\overline{a_3a_4a_5}$\n\n例如，五位数 $20207$ 可以拆分成\n\n$sub_1=202$\n\n$sub_2=020\\ (=20)$\n\n$sub_3=207$\n\n现在给定一个正整数 $K$，要求你编程求出 $10000$ 到 $30000$ 之间所有满足下述条件的五位数，条件是这些五位数的三个子数 $sub_1,sub_2,sub_3$ 都可被 $K$ 整除。\n", "inputFormat": "一个正整数 $K$。\n", "outputFormat": "每一行为一个满足条件的五位数，要求从小到大输出。不得重复输出或遗漏。如果无解，则输出 `No`。\n", "hint": "$0<K<1000$\n", "locale": "zh-CN", "translations": {"en": {"title": "Subnumber Integers", "background": "", "description": "For a five-digit number $\\overline{a_1a_2a_3a_4a_5}$, it can be split into three subnumbers:\n\n$sub_1=\\overline{a_1a_2a_3}$\n\n$sub_2=\\overline{a_2a_3a_4}$\n\n$sub_3=\\overline{a_3a_4a_5}$\n\nFor example, the five-digit number $20207$ can be split into\n\n$sub_1=202$\n\n$sub_2=020\\ (=20)$\n\n$sub_3=207$\n\nGiven a positive integer $K$, write a program to find all five-digit numbers between $10000$ and $30000$ inclusive such that their three subnumbers $sub_1, sub_2, sub_3$ are all divisible by $K$.", "inputFormat": "A positive integer $K$.", "outputFormat": "Output one qualifying five-digit number per line in increasing order. Do not output duplicates or miss any. If there is no solution, output `No`.", "hint": "$0<K<1000$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "子数整数", "background": "", "description": "对于一个五位数 $\\overline{a_1a_2a_3a_4a_5}$，可将其拆分为三个子数：\n\n$sub_1=\\overline{a_1a_2a_3}$\n\n$sub_2=\\overline{a_2a_3a_4}$\n\n$sub_3=\\overline{a_3a_4a_5}$\n\n例如，五位数 $20207$ 可以拆分成\n\n$sub_1=202$\n\n$sub_2=020\\ (=20)$\n\n$sub_3=207$\n\n现在给定一个正整数 $K$，要求你编程求出 $10000$ 到 $30000$ 之间所有满足下述条件的五位数，条件是这些五位数的三个子数 $sub_1,sub_2,sub_3$ 都可被 $K$ 整除。\n", "inputFormat": "一个正整数 $K$。\n", "outputFormat": "每一行为一个满足条件的五位数，要求从小到大输出。不得重复输出或遗漏。如果无解，则输出 `No`。\n", "hint": "$0<K<1000$\n", "locale": "zh-CN"}}}
{"pid": "P1152", "type": "P", "difficulty": 1, "samples": [["4 1 4 2 3\n", "Jolly\n"], ["5 1 4 2 -1 6", "Not jolly"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "枚举", "排序"], "title": "欢乐的跳", "background": "", "description": "一个 $n$ 个元素的整数数组，如果数组两个连续元素之间差的绝对值包括了 $[1,n-1]$ 之间的所有整数，则称之符合“欢乐的跳”，如数组 $\\{1,4,2,3\\}$ 符合“欢乐的跳”，因为差的绝对值分别为：$3,2,1$。\n\n给定一个数组，你的任务是判断该数组是否符合“欢乐的跳”。\n", "inputFormat": "每组测试数据第一行以一个整数 $n(1 \\le n \\le 1000)$ 开始，接下来 $n$ 个空格隔开的在 $[-10^8,10^8]$ 之间的整数。\n", "outputFormat": "对于每组测试数据，输出一行若该数组符合“欢乐的跳”则输出 `Jolly`，否则输出 `Not jolly`。\n", "hint": "$1 \\le n \\le 1000$\n", "locale": "zh-CN", "translations": {"en": {"title": "Jolly Jumpers", "background": "", "description": "An integer array with $n$ elements is called a jolly jumper if the absolute differences between each pair of consecutive elements include all integers in $[1, n-1]$. For example, the array $\\{1,4,2,3\\}$ is a jolly jumper because the absolute differences are $3, 2, 1$.\n\nGiven an array, your task is to determine whether it is a jolly jumper.", "inputFormat": "Each test case starts with an integer $n(1 \\le n \\le 1000)$, followed by $n$ space-separated integers in $[-10^8, 10^8]$.", "outputFormat": "For each test case, output one line. If the array is a jolly jumper, output `Jolly`; otherwise, output `Not jolly`.", "hint": "$1 \\le n \\le 1000$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "欢乐的跳", "background": "", "description": "一个 $n$ 个元素的整数数组，如果数组两个连续元素之间差的绝对值包括了 $[1,n-1]$ 之间的所有整数，则称之符合“欢乐的跳”，如数组 $\\{1,4,2,3\\}$ 符合“欢乐的跳”，因为差的绝对值分别为：$3,2,1$。\n\n给定一个数组，你的任务是判断该数组是否符合“欢乐的跳”。\n", "inputFormat": "每组测试数据第一行以一个整数 $n(1 \\le n \\le 1000)$ 开始，接下来 $n$ 个空格隔开的在 $[-10^8,10^8]$ 之间的整数。\n", "outputFormat": "对于每组测试数据，输出一行若该数组符合“欢乐的跳”则输出 `Jolly`，否则输出 `Not jolly`。\n", "hint": "$1 \\le n \\le 1000$\n", "locale": "zh-CN"}}}
{"pid": "P1153", "type": "P", "difficulty": 5, "samples": [["100 -10\n-200 0\n45 7\n0 0\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000]}, "tags": ["计算几何"], "title": "点和线", "background": "", "description": "平面上有一些点，你可以用直线将两点连接起来。那么有多少种方法可以把这些点连续地连起来，使得任何两个线都不交叉。\n\n显然，三个点只有一种方法。四个点最多只有 $3$ 种方法。写一个程序计算方法总数。\n", "inputFormat": "每一行是一个点的坐标，坐标值是整数，中间用一个空格隔开。最后一个坐标是原点。任意三点不在一条直线上。", "outputFormat": "输出方案总数。\n", "hint": "最多只有 $10$  个点。\n\n- 必须从一个点出发，途径所有点回到起点的路径才会被统计。\n\n- 两个方案不相同当且仅当围成的简单多边形不同。", "locale": "zh-CN", "translations": {"en": {"title": "Points and Lines", "background": "", "description": "There are some points on a plane. You can connect two points with a straight segment. How many ways are there to connect these points in sequence to form a closed polygonal chain such that no two segments intersect (except at shared endpoints)?\n\nObviously, with three points there is only one way. With four points there are at most $3$ ways. Write a program to compute the total number of ways.", "inputFormat": "Each line contains the coordinates of one point: two integers separated by a single space. The last line is the origin $(0, 0)$. No three points are collinear.", "outputFormat": "Output the total number of valid ways.", "hint": "At most $10$ points.\n\n- Only a tour that starts at some point, visits all points, and returns to the starting point will be counted.\n- Two solutions are different if and only if the resulting simple polygon is different.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "点和线", "background": "", "description": "平面上有一些点，你可以用直线将两点连接起来。那么有多少种方法可以把这些点连续地连起来，使得任何两个线都不交叉。\n\n显然，三个点只有一种方法。四个点最多只有 $3$ 种方法。写一个程序计算方法总数。\n", "inputFormat": "每一行是一个点的坐标，坐标值是整数，中间用一个空格隔开。最后一个坐标是原点。任意三点不在一条直线上。", "outputFormat": "输出方案总数。\n", "hint": "最多只有 $10$  个点。\n\n- 必须从一个点出发，途径所有点回到起点的路径才会被统计。\n\n- 两个方案不相同当且仅当围成的简单多边形不同。", "locale": "zh-CN"}}}
{"pid": "P1154", "type": "P", "difficulty": 3, "samples": [["5 \n4 \n6 \n9 \n10 \n13 \n", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学"], "title": "奶牛分厩", "background": null, "description": "农夫约翰有 $N(1 \\le N \\le 5000)$ 头奶牛，每头奶牛都有一个唯一的不同于其它奶牛的编号 $S_i$，所有的奶牛都睡在一个有 $K$ 个厩的谷仓中，厩的编号为 $0$ 到 $K-1$。每头奶牛都知道自己该睡在哪一个厩中，因为约翰教会了它们做除法，$S_i  \\bmod  K$ 的值就是第 $i$ 头奶牛所睡的厩的编号。", "inputFormat": "第一行一个正整数 $N$，第 $2$ 到 $N+1$ 行每行一个整数表示一头奶牛的编号。", "outputFormat": "一个整数，表示要求的最小的 $K$，对所有的测试数据这样的 $K$ 是一定存在的。", "hint": "$S_i(1\\le S_i \\le 1000000)$", "locale": "zh-CN", "translations": {"en": {"title": "Cow Stall Assignment", "background": "", "description": "Farmer John has $N(1 \\le N \\le 5000)$ cows. Each cow has a unique ID $s_i$, different from every other cow. All the cows sleep in a barn that has $K$ stalls, labeled $0$ to $K-1$. No two cows may share the same stall. Each cow knows which stall to sleep in because John taught them division: the stall index for the $i$-th cow is $S_i  \\bmod  K$. \n\nFind the smallest $K$ such that the assignment is valid (i.e., all cows are assigned to distinct stalls).", "inputFormat": "The first line contains a positive integer $N$. Lines $2$ through $N+1$ each contain one integer, the ID of a cow.", "outputFormat": "Output a single integer, the minimal $K$. For all testdata, such a $K$ is guaranteed to exist.", "hint": "$S_i(1\\le S_i \\le 1000000)$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "奶牛分厩", "background": null, "description": "农夫约翰有 $N(1 \\le N \\le 5000)$ 头奶牛，每头奶牛都有一个唯一的不同于其它奶牛的编号 $S_i$，所有的奶牛都睡在一个有 $K$ 个厩的谷仓中，厩的编号为 $0$ 到 $K-1$。每头奶牛都知道自己该睡在哪一个厩中，因为约翰教会了它们做除法，$S_i  \\bmod  K$ 的值就是第 $i$ 头奶牛所睡的厩的编号。", "inputFormat": "第一行一个正整数 $N$，第 $2$ 到 $N+1$ 行每行一个整数表示一头奶牛的编号。", "outputFormat": "一个整数，表示要求的最小的 $K$，对所有的测试数据这样的 $K$ 是一定存在的。", "hint": "$S_i(1\\le S_i \\le 1000000)$", "locale": "zh-CN"}}}
{"pid": "P1155", "type": "P", "difficulty": 5, "samples": [["4\n1 3 2 4", "a b a a b b a b"], ["4\n2 3 4 1", "0"], ["3\n2 3 1", "a c a b b d"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "贪心", "2008", "NOIP 提高组", "二分图"], "title": "[NOIP 2008 提高组] 双栈排序", "background": "", "description": "Tom 最近在研究一个有趣的排序问题。如图所示，通过 $2$ 个栈 $S_1$ 和 $S_2$，Tom 希望借助以下 $4$ 种操作实现将输入序列升序排序。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gwxu91ud.png)\n\n- 操作 $\\verb!a!$：将第一个元素压入栈 $S_1$。\n- 操作 $\\verb!b!$：将 $S_1$ 栈顶元素弹出至输出序列。\n- 操作 $\\verb!c!$：将第一个元素压入栈 $S_2$。\n- 操作 $\\verb!d!$：将 $S_2$ 栈顶元素弹出至输出序列。\n\n\n如果一个 $1\\sim n$ 的排列 $P$ 可以通过一系列合法操作使得输出序列为 $(1,2,\\cdots,n-1,n)$，Tom 就称 $P$ 是一个“可双栈排序排列”。例如 $(1,3,2,4)$ 就是一个“可双栈排序序列”，而 $(2,3,4,1)$ 不是。下图描述了一个将 $(1,3,2,4)$ 排序的操作序列：$\\texttt {a,c,c,b,a,d,d,b}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jwdjwfee.png)\n\n当然，这样的操作序列有可能有几个，对于上例 $(1,3,2,4)$，$\\texttt{a,b,a,a,b,b,a,b}$ 是另外一个可行的操作序列。Tom 希望知道其中字典序最小的操作序列是什么。", "inputFormat": "第一行是一个整数 $n$。\n\n第二行有 $n$ 个用空格隔开的正整数，构成一个 $1\\sim n$ 的排列。", "outputFormat": "共一行，如果输入的排列不是“可双栈排序排列”，输出 `0`。\n\n否则输出字典序最小的操作序列，每两个操作之间用空格隔开，行尾没有空格。", "hint": "$30\\%$ 的数据满足：$n\\le10$。\n\n$50\\%$ 的数据满足：$n\\le50$。\n\n$100\\%$ 的数据满足：$n\\le1000$。\n\n2021.06.17 加强 by [SSerxhs](https://www.luogu.com.cn/user/29826)。hack 数据单独分为一个 subtask 防止混淆。\n\nnoip2008 提高第四题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2008 Senior] Two-Stack Sorting", "background": "", "description": "Tom has been studying an interesting sorting problem. As shown in the figure, by using 2 stacks $S_1$ and $S_2$, Tom hopes to sort the input sequence in ascending order using the following 4 operations.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gwxu91ud.png)\n\n- Operation $\\verb!a!$: Push the first element of the input sequence onto stack $S_1$.\n- Operation $\\verb!b!$: Pop the top element of $S_1$ to the output sequence.\n- Operation $\\verb!c!$: Push the first element of the input sequence onto stack $S_2$.\n- Operation $\\verb!d!$: Pop the top element of $S_2$ to the output sequence.\n\nIf a permutation $P$ of $1\\sim n$ can, via a series of valid operations, produce the output sequence $(1,2,\\cdots,n-1,n)$, then Tom calls $P$ a \"two-stack sortable permutation.\" For example, $(1,3,2,4)$ is a \"two-stack sortable permutation,\" while $(2,3,4,1)$ is not. The following figure shows an operation sequence that sorts $(1,3,2,4)$: $\\texttt {a,c,c,b,a,d,d,b}$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jwdjwfee.png)\n\nOf course, there may be multiple such operation sequences. For the above example $(1,3,2,4)$, $\\texttt{a,b,a,a,b,b,a,b}$ is another valid operation sequence. Tom wants to know the lexicographically smallest operation sequence among them.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains $n$ positive integers separated by spaces, forming a permutation of $1\\sim n$.", "outputFormat": "Output a single line. If the input permutation is not a \"two-stack sortable permutation,\" output `0`.\n\nOtherwise, output the lexicographically smallest operation sequence, with a space between every two operations and no trailing space at the end.", "hint": "$30\\%$ of the testdata satisfy: $n\\le10$.\n\n$50\\%$ of the testdata satisfy: $n\\le50$.\n\n$100\\%$ of the testdata satisfy: $n\\le1000$.\n\n2021.06.17 strengthened by [SSerxhs](https://www.luogu.com.cn/user/29826). Hack testdata are separated into a single subtask to avoid confusion.\n\nNOIP 2008 Senior Problem 4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2008 提高组] 双栈排序", "background": "", "description": "Tom 最近在研究一个有趣的排序问题。如图所示，通过 $2$ 个栈 $S_1$ 和 $S_2$，Tom 希望借助以下 $4$ 种操作实现将输入序列升序排序。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gwxu91ud.png)\n\n- 操作 $\\verb!a!$：将第一个元素压入栈 $S_1$。\n- 操作 $\\verb!b!$：将 $S_1$ 栈顶元素弹出至输出序列。\n- 操作 $\\verb!c!$：将第一个元素压入栈 $S_2$。\n- 操作 $\\verb!d!$：将 $S_2$ 栈顶元素弹出至输出序列。\n\n\n如果一个 $1\\sim n$ 的排列 $P$ 可以通过一系列合法操作使得输出序列为 $(1,2,\\cdots,n-1,n)$，Tom 就称 $P$ 是一个“可双栈排序排列”。例如 $(1,3,2,4)$ 就是一个“可双栈排序序列”，而 $(2,3,4,1)$ 不是。下图描述了一个将 $(1,3,2,4)$ 排序的操作序列：$\\texttt {a,c,c,b,a,d,d,b}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jwdjwfee.png)\n\n当然，这样的操作序列有可能有几个，对于上例 $(1,3,2,4)$，$\\texttt{a,b,a,a,b,b,a,b}$ 是另外一个可行的操作序列。Tom 希望知道其中字典序最小的操作序列是什么。", "inputFormat": "第一行是一个整数 $n$。\n\n第二行有 $n$ 个用空格隔开的正整数，构成一个 $1\\sim n$ 的排列。", "outputFormat": "共一行，如果输入的排列不是“可双栈排序排列”，输出 `0`。\n\n否则输出字典序最小的操作序列，每两个操作之间用空格隔开，行尾没有空格。", "hint": "$30\\%$ 的数据满足：$n\\le10$。\n\n$50\\%$ 的数据满足：$n\\le50$。\n\n$100\\%$ 的数据满足：$n\\le1000$。\n\n2021.06.17 加强 by [SSerxhs](https://www.luogu.com.cn/user/29826)。hack 数据单独分为一个 subtask 防止混淆。\n\nnoip2008 提高第四题", "locale": "zh-CN"}}}
{"pid": "P1156", "type": "P", "difficulty": 4, "samples": [["20 4\n5 4 9\n9 3 2\n12 6 10\n13 1 1", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "排序", "背包 DP"], "title": "垃圾陷阱", "background": null, "description": "卡门――农夫约翰极其珍视的一头 `Holsteins` 奶牛――已经落到了 “垃圾井” 中。“垃圾井” 是农夫们扔垃圾的地方，它的深度为 $D$（$2 \\le D \\le 100$）英尺。\n\n卡门想把垃圾堆起来，等到堆得与井深同样高或比井深更高（即，垃圾高度总和 $\\geq D$）时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。\n\n每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。\n\n假设卡门预先知道了每个垃圾扔下的时间 $t$（$1 \\le t \\le 1000$），以及每个垃圾堆放的高度 $h$（$1 \\le h \\le 25$）和吃进该垃圾能增加维持生命的时间 $f$（$1 \\le f \\le 30$），要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续 $10$ 小时的能量，如果卡门 $10$ 小时内（不含 $10$ 小时，维持生命的时间同）没有进食，卡门就将饿死。特别地，若体力值为 $0$ 时吃下垃圾或逃出井外也不会饿死。", "inputFormat": "第一行为两个整数，$D$ 和 $G$（$1 \\le G \\le 100$），$G$ 为被投入井的垃圾的数量。\n\n第二到第 $G+1$ 行每行包括三个整数：$t$（$1 \\le t \\le 1000$），表示垃圾被投进井中的时间；$f$（$1 \\le f \\le 30$），表示该垃圾能维持卡门生命的时间；和 $h$（$1 \\le h \\le 25$），该垃圾能垫高的高度。", "outputFormat": "如果卡门可以爬出陷阱，输出一个整数，表示最早什么时候可以爬出；否则输出卡门最长可以存活多长时间。", "hint": "**【样例说明】**\n\n卡门堆放她收到的第一个垃圾：$\\mathrm{height}=9$；\n\n卡门吃掉她收到的第 $2$ 个垃圾，使她的生命从 $10$ 小时延伸到 $13$ 小时；\n\n卡门堆放第 $3$ 个垃圾，$\\mathrm{height}=19$；\n\n卡门堆放第 $4$ 个垃圾，$\\mathrm{height}=20$。", "locale": "zh-CN", "translations": {"en": {"title": "Garbage Trap", "background": "", "description": "Carmen — a `Holsteins` cow dearly valued by Farmer John — has fallen into a “trash well,” a place where farmers dump garbage. The well has a depth of $D$ ($2 \\le D \\le 100$) feet.\n\nCarmen plans to stack trash. When the stacked trash reaches or exceeds the well’s depth (that is, the total trash height $\\geq D$), she can escape. She can also eat some trash to extend her survival.\n\nEach piece of trash can be either eaten or stacked, and stacking takes no time for Carmen.\n\nAssume Carmen knows in advance the time $t$ ($1 \\le t \\le 1000$) when each piece of trash is thrown in, as well as each piece’s stacking height $h$ ($1 \\le h \\le 25$) and the survival time increase $f$ ($1 \\le f \\le 30$) if eaten. Find the earliest time when Carmen can escape. Initially, Carmen has enough energy to last 10 hours. If Carmen goes 10 hours without eating (10 hours excluded; the same applies to added survival time), she will starve. In particular, if her energy is 0 and she eats a piece of trash or escapes at that instant, she will not starve.", "inputFormat": "The first line contains two integers, $D$ and $G$ ($1 \\le G \\le 100$), where $G$ is the number of pieces of trash thrown into the well.\n\nEach of the next $G$ lines contains three integers: $t$ ($1 \\le t \\le 1000$), the time when the trash is thrown in; $f$ ($1 \\le f \\le 30$), the survival time this trash can provide if eaten; and $h$ ($1 \\le h \\le 25$), the height this trash can add if stacked.", "outputFormat": "If Carmen can climb out of the trap, output a single integer, the earliest time when she can climb out. Otherwise, output how long she can survive at most.", "hint": "【Sample Explanation】\n\nCarmen stacks the first piece of trash she receives: $\\mathrm{height}=9$.\n\nCarmen eats the second piece of trash, extending her survival from 10 hours to 13 hours.\n\nCarmen stacks the third piece of trash, $\\mathrm{height}=19$.\n\nCarmen stacks the fourth piece of trash, $\\mathrm{height}=20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "垃圾陷阱", "background": null, "description": "卡门――农夫约翰极其珍视的一头 `Holsteins` 奶牛――已经落到了 “垃圾井” 中。“垃圾井” 是农夫们扔垃圾的地方，它的深度为 $D$（$2 \\le D \\le 100$）英尺。\n\n卡门想把垃圾堆起来，等到堆得与井深同样高或比井深更高（即，垃圾高度总和 $\\geq D$）时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。\n\n每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。\n\n假设卡门预先知道了每个垃圾扔下的时间 $t$（$1 \\le t \\le 1000$），以及每个垃圾堆放的高度 $h$（$1 \\le h \\le 25$）和吃进该垃圾能增加维持生命的时间 $f$（$1 \\le f \\le 30$），要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续 $10$ 小时的能量，如果卡门 $10$ 小时内（不含 $10$ 小时，维持生命的时间同）没有进食，卡门就将饿死。特别地，若体力值为 $0$ 时吃下垃圾或逃出井外也不会饿死。", "inputFormat": "第一行为两个整数，$D$ 和 $G$（$1 \\le G \\le 100$），$G$ 为被投入井的垃圾的数量。\n\n第二到第 $G+1$ 行每行包括三个整数：$t$（$1 \\le t \\le 1000$），表示垃圾被投进井中的时间；$f$（$1 \\le f \\le 30$），表示该垃圾能维持卡门生命的时间；和 $h$（$1 \\le h \\le 25$），该垃圾能垫高的高度。", "outputFormat": "如果卡门可以爬出陷阱，输出一个整数，表示最早什么时候可以爬出；否则输出卡门最长可以存活多长时间。", "hint": "**【样例说明】**\n\n卡门堆放她收到的第一个垃圾：$\\mathrm{height}=9$；\n\n卡门吃掉她收到的第 $2$ 个垃圾，使她的生命从 $10$ 小时延伸到 $13$ 小时；\n\n卡门堆放第 $3$ 个垃圾，$\\mathrm{height}=19$；\n\n卡门堆放第 $4$ 个垃圾，$\\mathrm{height}=20$。", "locale": "zh-CN"}}}
{"pid": "P1157", "type": "P", "difficulty": 2, "samples": [["5 3 \n", "  1  2  3\n  1  2  4\n  1  2  5\n  1  3  4\n  1  3  5\n  1  4  5\n  2  3  4\n  2  3  5\n  2  4  5\n  3  4  5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "递归", "排列组合"], "title": "组合的输出", "background": "", "description": "排列与组合是常用的数学方法，其中组合就是从 $n$ 个元素中抽出 $r$ 个元素（不分顺序且 $r \\le n$），我们可以简单地将 $n$ 个元素理解为自然数 $1,2,\\dots,n$，从中任取 $r$ 个数。\n\n现要求你输出所有组合。\n\n例如 $n=5,r=3$，所有组合为：\n\n$123,124,125,134,135,145,234,235,245,345$。\n", "inputFormat": "一行两个自然数 $n,r(1<n<21,0 \\le r \\le n)$。\n", "outputFormat": "所有的组合，每一个组合占一行且其中的元素按由小到大的顺序排列，每个元素占三个字符的位置，所有的组合也按字典顺序。\n\n**注意哦！输出时，每个数字需要 $3$ 个场宽。以 C++ 为例，你可以使用下列代码：**\n\n```cpp\ncout << setw(3) << x;\n```\n\n输出占 $3$ 个场宽的数 $x$。注意你需要头文件 `iomanip`。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Output of Combinations", "background": "", "description": "Permutation and combination are common mathematical methods. A combination means selecting $r$ elements from $n$ elements (order does not matter and $r \\le n$). We can simply think of the $n$ elements as the natural numbers $1, 2, \\dots, n$, and choose any $r$ numbers from them.\n\nYou are required to output all combinations.\n\nFor example, when $n=5, r=3$, all combinations are:\n\n$123,124,125,134,135,145,234,235,245,345$.", "inputFormat": "A single line with two natural numbers $n, r$ ($1 < n < 21$, $0 \\le r \\le n$).", "outputFormat": "Output all combinations. Each combination occupies one line, and the elements in it are sorted in ascending order. Each element occupies a field width of three characters. All combinations are in lexicographical order.\n\nNote: When outputting, each number must have a field width of $3$. In C++, you can use the following code:\n\n```cpp\ncout << setw(3) << x;\n```\n\nThis outputs a number $x$ with a field width of $3$. Note that you need the header file `iomanip`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "组合的输出", "background": "", "description": "排列与组合是常用的数学方法，其中组合就是从 $n$ 个元素中抽出 $r$ 个元素（不分顺序且 $r \\le n$），我们可以简单地将 $n$ 个元素理解为自然数 $1,2,\\dots,n$，从中任取 $r$ 个数。\n\n现要求你输出所有组合。\n\n例如 $n=5,r=3$，所有组合为：\n\n$123,124,125,134,135,145,234,235,245,345$。\n", "inputFormat": "一行两个自然数 $n,r(1<n<21,0 \\le r \\le n)$。\n", "outputFormat": "所有的组合，每一个组合占一行且其中的元素按由小到大的顺序排列，每个元素占三个字符的位置，所有的组合也按字典顺序。\n\n**注意哦！输出时，每个数字需要 $3$ 个场宽。以 C++ 为例，你可以使用下列代码：**\n\n```cpp\ncout << setw(3) << x;\n```\n\n输出占 $3$ 个场宽的数 $x$。注意你需要头文件 `iomanip`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1158", "type": "P", "difficulty": 3, "samples": [["0 0 10 0\n2\n-3 3\n10 0", "18"], ["0 0 6 0\n5\n-4 -2\n-2 3\n4 0\n6 -2\n9 1", "30"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2010", "NOIP 普及组", "枚举", "排序"], "title": "[NOIP 2010 普及组] 导弹拦截", "background": "", "description": "经过 $11$ 年的韬光养晦，某国研发出了一种新的导弹拦截系统，凡是与它的距离不超过其工作半径的导弹都能够被它成功拦截。当工作半径为 $0$ 时，则能够拦截与它位置恰好相同的导弹。但该导弹拦截系统也存在这样的缺陷：每套系统每天只能设定一次工作半径。而当天的使用代价，就是所有系统工作半径的平方和。\n\n某天，雷达捕捉到敌国的导弹来袭。由于该系统尚处于试验阶段，所以只有两套系统投入工作。如果现在的要求是拦截所有的导弹，请计算这一天的最小使用代价。", "inputFormat": "第一行包含 $4$ 个整数 $x_1,y_1,x_2,y_2$，每两个整数之间用一个空格隔开，表示这两套导弹拦截系统的坐标分别为 $(x_1,y_1), (x_2,y_2)$。第二行包含 $1$ 个整数 $N$，表示有 $N$ 颗导弹。接下来 $N$ 行，每行两个整数 $x,y$，中间用一个空格隔开，表示一颗导弹的坐标 $(x,y)$。不同导弹的坐标可能相同。", "outputFormat": "一个整数，即当天的最小使用代价。\n", "hint": "两个点 $(x_1,y_1),(x_2,y_2)$ 之间距离的平方是 $(x_1-x_2)^2+(y_1-y_2)^2$。\n\n两套系统工作半径 $r_1,r_2$ 的平方和，是指 $r_1,r_2$ 分别取平方后再求和，即 $r_1^2+r_2^2$。\n\n### 样例 1 说明\n\n样例 $1$ 中要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为 $18$ 和 $0$。\n\n### 样例 2 说明\n\n样例 $2$ 中的导弹拦截系统和导弹所在的位置如下图所示。要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为 $20$ 和 $10$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cvgomt03.png)\n\n【数据范围】。\n\n- 对于 $10\\%$ 的数据，$N=1$。\n- 对于 $20\\%$ 的数据，$1\\le N\\le 2$。\n- 对于 $40\\%$ 的数据，$1\\le N\\le 100$。\n- 对于 $70\\%$ 的数据，$1\\le N\\le 1000$。\n- 对于 $100\\%$ 的数据，$1\\le N\\le 10^5$，且所有坐标分量的绝对值都不超过 $1000$。\n\nNOIP2010 普及组 第三题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2010 Junior] Missile Interception", "background": "", "description": "After $11$ years of preparation, a certain country has developed a new missile interception system. Any missile whose distance to the system does not exceed its working radius can be successfully intercepted. When the working radius is $0$, it can intercept missiles that are exactly at the same position as the system. However, the system has a limitation: each set of the system can have its working radius set only once per day. The usage cost for that day is the sum of the squares of the working radii of all systems.\n\nOne day, radar detected incoming enemy missiles. Since the system is still in the trial phase, only two systems are deployed. If the requirement is to intercept all missiles, compute the minimum usage cost for that day.", "inputFormat": "The first line contains $4$ integers $x_1, y_1, x_2, y_2$, separated by a single space, indicating that the coordinates of the two missile interception systems are $(x_1, y_1)$ and $(x_2, y_2)$. The second line contains $1$ integer $N$, the number of missiles. The next $N$ lines each contain two integers $x, y$, separated by a single space, indicating the coordinates $(x, y)$ of a missile. Different missiles may share the same coordinates.", "outputFormat": "A single integer, the minimum usage cost for that day.", "hint": "- The square of the distance between two points $(x_1, y_1)$ and $(x_2, y_2)$ is $(x_1-x_2)^2+(y_1-y_2)^2$.\n- The sum of the squares of the two working radii $r_1, r_2$ means squaring them separately and then summing, i.e., $r_1^2+r_2^2$.\n\nExplanation for Sample $1$:\nTo intercept all missiles with minimum usage cost, the squares of the two systems’ working radii are $18$ and $0$.\n\nExplanation for Sample $2$:\nThe positions of the interception systems and the missiles are shown below. To intercept all missiles with minimum usage cost, the squares of the two systems’ working radii are $20$ and $10$.\n![](https://cdn.luogu.com.cn/upload/image_hosting/cvgomt03.png)\n\nConstraints:\n- For $10\\%$ of the testdata, $N=1$.\n- For $20\\%$ of the testdata, $1\\le N\\le 2$.\n- For $40\\%$ of the testdata, $1\\le N\\le 100$.\n- For $70\\%$ of the testdata, $1\\le N\\le 1000$.\n- For $100\\%$ of the testdata, $1\\le N\\le 10^5$, and the absolute values of all coordinate components do not exceed $1000$.\n\nNOIP 2010 Junior, Problem 3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2010 普及组] 导弹拦截", "background": "", "description": "经过 $11$ 年的韬光养晦，某国研发出了一种新的导弹拦截系统，凡是与它的距离不超过其工作半径的导弹都能够被它成功拦截。当工作半径为 $0$ 时，则能够拦截与它位置恰好相同的导弹。但该导弹拦截系统也存在这样的缺陷：每套系统每天只能设定一次工作半径。而当天的使用代价，就是所有系统工作半径的平方和。\n\n某天，雷达捕捉到敌国的导弹来袭。由于该系统尚处于试验阶段，所以只有两套系统投入工作。如果现在的要求是拦截所有的导弹，请计算这一天的最小使用代价。", "inputFormat": "第一行包含 $4$ 个整数 $x_1,y_1,x_2,y_2$，每两个整数之间用一个空格隔开，表示这两套导弹拦截系统的坐标分别为 $(x_1,y_1), (x_2,y_2)$。第二行包含 $1$ 个整数 $N$，表示有 $N$ 颗导弹。接下来 $N$ 行，每行两个整数 $x,y$，中间用一个空格隔开，表示一颗导弹的坐标 $(x,y)$。不同导弹的坐标可能相同。", "outputFormat": "一个整数，即当天的最小使用代价。\n", "hint": "两个点 $(x_1,y_1),(x_2,y_2)$ 之间距离的平方是 $(x_1-x_2)^2+(y_1-y_2)^2$。\n\n两套系统工作半径 $r_1,r_2$ 的平方和，是指 $r_1,r_2$ 分别取平方后再求和，即 $r_1^2+r_2^2$。\n\n### 样例 1 说明\n\n样例 $1$ 中要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为 $18$ 和 $0$。\n\n### 样例 2 说明\n\n样例 $2$ 中的导弹拦截系统和导弹所在的位置如下图所示。要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为 $20$ 和 $10$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cvgomt03.png)\n\n【数据范围】。\n\n- 对于 $10\\%$ 的数据，$N=1$。\n- 对于 $20\\%$ 的数据，$1\\le N\\le 2$。\n- 对于 $40\\%$ 的数据，$1\\le N\\le 100$。\n- 对于 $70\\%$ 的数据，$1\\le N\\le 1000$。\n- 对于 $100\\%$ 的数据，$1\\le N\\le 10^5$，且所有坐标分量的绝对值都不超过 $1000$。\n\nNOIP2010 普及组 第三题", "locale": "zh-CN"}}}
{"pid": "P1159", "type": "P", "difficulty": 3, "samples": [["5\nHIGHHOPES\nUP\nLOWFEELINGS\nUP\nUPANDDOWN\nDOWN\nIAMSTILLSTANDING\nDOWN\nFOOLINGAROUND\nDOWN\n", "UPANDDOWN\nIAMSTILLSTANDING\nFOOLINGAROUND\nHIGHHOPES\nLOWFEELINGS\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "Special Judge"], "title": "排行榜", "background": "", "description": "小迈克尔住在一个小镇上，他喜欢看每周日下午发布的音乐电视评比。它每周都根据选票介绍相同的歌曲，列出这些歌曲的流行排行榜。\n\n有一个星期日迈克尔和他的朋友在一起玩得太久了以致于未能看到新的流行榜。他非常失望，但是不久他就发现下周至少可以部分地建立出流行榜。除了每首歌曲的位置，排行榜还根据这些歌曲上周的排行列出了它们排行变动的信息，更精确地说，从这周起，不管那首歌是继续排在原位，还是排名上升或排名下降，都会给出一点说明。\n\n编写程序，根据给定的流行榜帮助迈克尔推断出上周可能的排行榜。\n", "inputFormat": "第一行是一个整数 $N(1≤N≤100)$，表示排行榜上歌曲的总数。\n\n接下来的 $N$ 块列出了排行信息。每块有两行组成，第i块第一行是第 $i$ 首歌曲的名称，歌名包括最多不超过 $100$ 个英文大写字母，第二行包含下列三个单词中的一个：`UP`（歌曲在排行榜上的位置上升），`DOWN`（歌曲在排行榜上的位置下滑）或 `SAME`（排行不变），表示与上周排行榜相比，排行榜所发生的变动。\n", "outputFormat": "$N$ 行输出一个上周可能的排行榜。\n\n每一行包含一首歌名，即第 $i$ 行包含排行榜上第 $i$ 首歌的歌名。\n\n注意：解不必是唯一的，但对于每一个测试数据都至少有一个解。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Ranking List", "background": "", "description": "Little Michael lives in a small town, and he likes to watch the music TV ranking show released every Sunday afternoon. Each week it presents the same songs and lists their popularity chart based on votes.\n\nOne Sunday, Michael played with his friends for too long and missed the new chart. He was very disappointed, but soon he realized that next week he could at least partially reconstruct the chart. In addition to each song’s position, the chart also lists how its rank changed compared to last week; more precisely, starting this week, for each song there is a note indicating whether it stayed in place, moved up, or moved down.\n\nWrite a program that, given the current chart, helps Michael infer a possible chart from last week.", "inputFormat": "The first line is an integer $N(1≤N≤100)$, the total number of songs on the chart.\n\nThe next $N$ blocks list the ranking information. Each block consists of two lines. In the i-th block, the first line is the name of the i-th song; the name contains at most 100 uppercase English letters. The second line contains one of the three words: `UP` (the song’s position goes up), `DOWN` (the song’s position goes down), or `SAME` (no change), indicating the change compared to last week’s chart.", "outputFormat": "Output $N$ lines: a possible chart from last week.\n\nEach line contains one song name, that is, the $i$-th line contains the name of the song that was $i$-th on last week’s chart.\n\nNote: The solution does not have to be unique, but for every testdata there is at least one solution.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "排行榜", "background": "", "description": "小迈克尔住在一个小镇上，他喜欢看每周日下午发布的音乐电视评比。它每周都根据选票介绍相同的歌曲，列出这些歌曲的流行排行榜。\n\n有一个星期日迈克尔和他的朋友在一起玩得太久了以致于未能看到新的流行榜。他非常失望，但是不久他就发现下周至少可以部分地建立出流行榜。除了每首歌曲的位置，排行榜还根据这些歌曲上周的排行列出了它们排行变动的信息，更精确地说，从这周起，不管那首歌是继续排在原位，还是排名上升或排名下降，都会给出一点说明。\n\n编写程序，根据给定的流行榜帮助迈克尔推断出上周可能的排行榜。\n", "inputFormat": "第一行是一个整数 $N(1≤N≤100)$，表示排行榜上歌曲的总数。\n\n接下来的 $N$ 块列出了排行信息。每块有两行组成，第i块第一行是第 $i$ 首歌曲的名称，歌名包括最多不超过 $100$ 个英文大写字母，第二行包含下列三个单词中的一个：`UP`（歌曲在排行榜上的位置上升），`DOWN`（歌曲在排行榜上的位置下滑）或 `SAME`（排行不变），表示与上周排行榜相比，排行榜所发生的变动。\n", "outputFormat": "$N$ 行输出一个上周可能的排行榜。\n\n每一行包含一首歌名，即第 $i$ 行包含排行榜上第 $i$ 首歌的歌名。\n\n注意：解不必是唯一的，但对于每一个测试数据都至少有一个解。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1160", "type": "P", "difficulty": 3, "samples": [["4\n1 0\n2 1\n1 0\n2\n3\n3", "2 4 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "线性数据结构", "构造", "链表"], "title": "队列安排", "background": "", "description": "一个学校里老师要将班上 $N$ 个同学排成一列，同学被编号为 $1\\sim N$，他采取如下的方法：\n\n1. 先将 $1$ 号同学安排进队列，这时队列中只有他一个人；\n\n2. $2\\sim N$ 号同学依次入列，编号为 $i$ 的同学入列方式为：老师指定编号为 $i$ 的同学站在编号为 $1\\sim(i-1)$ 中某位同学（即之前已经入列的同学）的左边或右边；\n\n3. 从队列中去掉 $M$ 个同学，其他同学位置顺序不变。\n\n在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。", "inputFormat": "第一行一个整数 $N$，表示了有 $N$ 个同学。\n\n第 $2\\sim N$ 行，第 $i$ 行包含两个整数 $k,p$，其中 $k$ 为小于 $i$ 的正整数，$p$ 为 $0$ 或者 $1$。若 $p$ 为 $0$，则表示将 $i$ 号同学插入到 $k$ 号同学的左边，$p$ 为 $1$ 则表示插入到右边。\n\n第 $N+1$ 行为一个整数 $M$，表示去掉的同学数目。\n\n接下来 $M$ 行，每行一个正整数 $x$，表示将 $x$ 号同学从队列中移去，如果 $x$ 号同学已经不在队列中则忽略这一条指令。\n", "outputFormat": "一行，包含最多 $N$ 个空格隔开的整数，表示了队列从左到右所有同学的编号。\n", "hint": "**【样例解释】**\n\n将同学 $2$ 插入至同学 $1$ 左边，此时队列为：\n\n`2 1`\n\n将同学 $3$ 插入至同学 $2$ 右边，此时队列为：\n\n`2 3 1`  \n\n将同学 $4$ 插入至同学 $1$ 左边，此时队列为：\n\n`2 3 4 1`  \n\n将同学 $3$ 从队列中移出，此时队列为：\n\n`2 4 1`  \n\n同学 $3$ 已经不在队列中，忽略最后一条指令\n\n最终队列：\n\n`2 4 1`  \n\n**【数据范围】**\n\n对于 $20\\%$ 的数据，$1\\leq N\\leq 10$。\n\n对于 $40\\%$ 的数据，$1\\leq N\\leq 1000$。\n\n对于 $100\\%$ 的数据，$1<M\\leq N\\leq 10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Queue Arrangement", "background": "", "description": "In a school, a teacher wants to arrange $N$ students in a line. The students are numbered $1 \\sim N$. The teacher proceeds as follows:\n\n1. First, student $1$ is placed in the queue. At this moment, the queue contains only that student.\n\n2. Students $2 \\sim N$ join the queue one by one. For student numbered $i$, the teacher specifies that student $i$ stands to the left or right of some student among $1 \\sim (i - 1)$ (i.e., a student who has already joined the queue).\n\n3. Remove $M$ students from the queue; the relative order of the remaining students does not change.\n\nAfter all students have been arranged according to the above rules, the teacher wants to know the IDs of all students from left to right.", "inputFormat": "The first line contains an integer $N$, the number of students.\n\nLines $2 \\sim N$: line $i$ contains two integers $k, p$, where $k$ is a positive integer less than $i$, and $p$ is $0$ or $1$. If $p$ is $0$, insert student $i$ to the left of student $k$; if $p$ is $1$, insert student $i$ to the right of student $k$.\n\nLine $N + 1$ contains an integer $M$, the number of students to remove.\n\nThe next $M$ lines each contain a positive integer $x$, meaning student $x$ is removed from the queue. If student $x$ is already not in the queue, ignore this instruction.", "outputFormat": "One line containing at most $N$ space-separated integers, the IDs of the students from left to right.", "hint": "[Sample Explanation]\n\nInsert student $2$ to the left of student $1$. The queue is now:\n\n`2 1`\n\nInsert student $3$ to the right of student $2$. The queue is now:\n\n`2 3 1`\n\nInsert student $4$ to the left of student $1$. The queue is now:\n\n`2 3 4 1`\n\nRemove student $3$. The queue is now:\n\n`2 4 1`\n\nStudent $3$ is no longer in the queue, so ignore the last instruction.\n\nFinal queue:\n\n`2 4 1`\n\nConstraints\n\n- For $20\\%$ of the testdata, $1 \\leq N \\leq 10$.\n- For $40\\%$ of the testdata, $1 \\leq N \\leq 1000$.\n- For $100\\%$ of the testdata, $1 < M \\leq N \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "队列安排", "background": "", "description": "一个学校里老师要将班上 $N$ 个同学排成一列，同学被编号为 $1\\sim N$，他采取如下的方法：\n\n1. 先将 $1$ 号同学安排进队列，这时队列中只有他一个人；\n\n2. $2\\sim N$ 号同学依次入列，编号为 $i$ 的同学入列方式为：老师指定编号为 $i$ 的同学站在编号为 $1\\sim(i-1)$ 中某位同学（即之前已经入列的同学）的左边或右边；\n\n3. 从队列中去掉 $M$ 个同学，其他同学位置顺序不变。\n\n在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。", "inputFormat": "第一行一个整数 $N$，表示了有 $N$ 个同学。\n\n第 $2\\sim N$ 行，第 $i$ 行包含两个整数 $k,p$，其中 $k$ 为小于 $i$ 的正整数，$p$ 为 $0$ 或者 $1$。若 $p$ 为 $0$，则表示将 $i$ 号同学插入到 $k$ 号同学的左边，$p$ 为 $1$ 则表示插入到右边。\n\n第 $N+1$ 行为一个整数 $M$，表示去掉的同学数目。\n\n接下来 $M$ 行，每行一个正整数 $x$，表示将 $x$ 号同学从队列中移去，如果 $x$ 号同学已经不在队列中则忽略这一条指令。\n", "outputFormat": "一行，包含最多 $N$ 个空格隔开的整数，表示了队列从左到右所有同学的编号。\n", "hint": "**【样例解释】**\n\n将同学 $2$ 插入至同学 $1$ 左边，此时队列为：\n\n`2 1`\n\n将同学 $3$ 插入至同学 $2$ 右边，此时队列为：\n\n`2 3 1`  \n\n将同学 $4$ 插入至同学 $1$ 左边，此时队列为：\n\n`2 3 4 1`  \n\n将同学 $3$ 从队列中移出，此时队列为：\n\n`2 4 1`  \n\n同学 $3$ 已经不在队列中，忽略最后一条指令\n\n最终队列：\n\n`2 4 1`  \n\n**【数据范围】**\n\n对于 $20\\%$ 的数据，$1\\leq N\\leq 10$。\n\n对于 $40\\%$ 的数据，$1\\leq N\\leq 1000$。\n\n对于 $100\\%$ 的数据，$1<M\\leq N\\leq 10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P1161", "type": "P", "difficulty": 1, "samples": [["3\n1.618034 13\n2.618034 7\n1.000000 21", "20"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "进制"], "title": "开灯", "background": "", "description": "在一条无限长的路上，有一排无限长的路灯，编号为 $1,2,3,4,\\dots$。\n\n每一盏灯只有两种可能的状态，开或者关。如果按一下某一盏灯的开关，那么这盏灯的状态将发生改变。如果原来是开，将变成关。如果原来是关，将变成开。\n\n在刚开始的时候，所有的灯都是关的。小明每次可以进行如下的操作：\n\n指定两个数，$a,t$（$a$ 为实数，$t$ 为正整数）。将编号为 $\\lfloor a\\rfloor,\\lfloor 2 \\times a\\rfloor,\\lfloor3 \\times a\\rfloor,\\dots,\\lfloor t  \\times a\\rfloor$ 的灯的开关各按一次。其中 $\\lfloor k \\rfloor$ 表示实数 $k$ 的整数部分。\n\n在小明进行了 $n$ 次操作后，小明突然发现，这个时候只有一盏灯是开的，小明很想知道这盏灯的编号，可是这盏灯离小明太远了，小明看不清编号是多少。\n\n幸好，小明还记得之前的 $n$ 次操作。于是小明找到了你，你能帮他计算出这盏开着的灯的编号吗？\n", "inputFormat": "第一行一个正整数 $n$，表示 $n$ 次操作。\n\n接下来有 $n$ 行，每行两个数，$a_i,t_i$。其中 $a_i$ 是实数，小数点后一定有 $6$ 位，$t_i$ 是正整数。", "outputFormat": "仅一个正整数，那盏开着的灯的编号。\n", "hint": "记 $T=\\sum \\limits_{i=1}^n t_i = t_1+t_2+t_3+\\dots+t_n$。\n\n- 对于 $30\\%$ 的数据，满足 $T \\le 1000$；\n- 对于 $80\\%$ 的数据，满足 $T \\le 200000$；\n- 对于 $100\\%$ 的数据，满足 $T \\le 2000000$；\n- 对于 $100\\%$ 的数据，满足 $n \\le 5000$，$1 \\le a_i<1000$，$1 \\le t_i \\le T$。\n\n数据保证，在经过 $n$ 次操作后，有且只有一盏灯是开的，不必判错。而且对于所有的 $i$ 来说，$t_i\\times a_i$ 的最大值不超过 $2000000$。", "locale": "zh-CN", "translations": {"en": {"title": "Turning On the Lights", "background": "", "description": "On an infinitely long road, there is an infinite row of street lamps, numbered $1, 2, 3, 4, \\dots$.\n\nEach lamp has two possible states: on or off. If you press the switch of a lamp once, its state toggles. If it was on, it turns off. If it was off, it turns on.\n\nInitially, all lamps are off. Each time, Xiao Ming can perform the following operation:\n\nSpecify two numbers, $a, t$ ($a$ is a real number, $t$ is a positive integer). Press once the switches of the lamps numbered $\\lfloor a \\rfloor, \\lfloor 2 \\times a \\rfloor, \\lfloor 3 \\times a \\rfloor, \\dots, \\lfloor t \\times a \\rfloor$. Here $\\lfloor k \\rfloor$ denotes the integer part of the real number $k$.\n\nAfter Xiao Ming has performed $n$ such operations, he suddenly discovers that exactly one lamp is on. He wants to know the index of this lamp, but it is too far away for him to read the number.\n\nFortunately, Xiao Ming still remembers the previous $n$ operations. He turns to you for help. Can you compute the index of the lamp that is on?", "inputFormat": "The first line contains a positive integer $n$, the number of operations.\n\nThe next $n$ lines each contain two numbers, $a_i, t_i$. Here $a_i$ is a real number with exactly $6$ digits after the decimal point, and $t_i$ is a positive integer.", "outputFormat": "Output a single positive integer: the index of the lamp that is on.", "hint": "Let $T=\\sum \\limits_{i=1}^n t_i = t_1+t_2+t_3+\\dots+t_n$.\n\n- For 30% of the testdata, $T \\le 1000$.\n- For 80% of the testdata, $T \\le 200000$.\n- For 100% of the testdata, $T \\le 2000000$.\n- For 100% of the testdata, $n \\le 5000$, $1 \\le a_i < 1000$, $1 \\le t_i \\le T$.\n\nIt is guaranteed by the testdata that after $n$ operations, there is exactly one lamp that is on, so you do not need to handle invalid cases. Also, for all $i$, the maximum value of $t_i \\times a_i$ does not exceed $2000000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "开灯", "background": "", "description": "在一条无限长的路上，有一排无限长的路灯，编号为 $1,2,3,4,\\dots$。\n\n每一盏灯只有两种可能的状态，开或者关。如果按一下某一盏灯的开关，那么这盏灯的状态将发生改变。如果原来是开，将变成关。如果原来是关，将变成开。\n\n在刚开始的时候，所有的灯都是关的。小明每次可以进行如下的操作：\n\n指定两个数，$a,t$（$a$ 为实数，$t$ 为正整数）。将编号为 $\\lfloor a\\rfloor,\\lfloor 2 \\times a\\rfloor,\\lfloor3 \\times a\\rfloor,\\dots,\\lfloor t  \\times a\\rfloor$ 的灯的开关各按一次。其中 $\\lfloor k \\rfloor$ 表示实数 $k$ 的整数部分。\n\n在小明进行了 $n$ 次操作后，小明突然发现，这个时候只有一盏灯是开的，小明很想知道这盏灯的编号，可是这盏灯离小明太远了，小明看不清编号是多少。\n\n幸好，小明还记得之前的 $n$ 次操作。于是小明找到了你，你能帮他计算出这盏开着的灯的编号吗？\n", "inputFormat": "第一行一个正整数 $n$，表示 $n$ 次操作。\n\n接下来有 $n$ 行，每行两个数，$a_i,t_i$。其中 $a_i$ 是实数，小数点后一定有 $6$ 位，$t_i$ 是正整数。", "outputFormat": "仅一个正整数，那盏开着的灯的编号。\n", "hint": "记 $T=\\sum \\limits_{i=1}^n t_i = t_1+t_2+t_3+\\dots+t_n$。\n\n- 对于 $30\\%$ 的数据，满足 $T \\le 1000$；\n- 对于 $80\\%$ 的数据，满足 $T \\le 200000$；\n- 对于 $100\\%$ 的数据，满足 $T \\le 2000000$；\n- 对于 $100\\%$ 的数据，满足 $n \\le 5000$，$1 \\le a_i<1000$，$1 \\le t_i \\le T$。\n\n数据保证，在经过 $n$ 次操作后，有且只有一盏灯是开的，不必判错。而且对于所有的 $i$ 来说，$t_i\\times a_i$ 的最大值不超过 $2000000$。", "locale": "zh-CN"}}}
{"pid": "P1162", "type": "P", "difficulty": 2, "samples": [["6\n0 0 0 0 0 0\n0 0 1 1 1 1\n0 1 1 0 0 1\n1 1 0 0 0 1\n1 0 0 0 0 1\n1 1 1 1 1 1\n", "0 0 0 0 0 0\n0 0 1 1 1 1\n0 1 1 2 2 1\n1 1 2 2 2 1\n1 2 2 2 2 1\n1 1 1 1 1 1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "洛谷原创", "广度优先搜索 BFS", "深度优先搜索 DFS", "队列"], "title": "填涂颜色", "background": "", "description": "由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：\n\n如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ **在闭合圈内**。闭合圈不一定是环形的，可以是任意形状，但保证**闭合圈内**的 $0$ 是连通的（两两之间可以相互到达）。\n\n```plain\n0 0 0 0 0 0\n0 0 0 1 1 1\n0 1 1 0 0 1\n1 1 0 0 0 1\n1 0 0 1 0 1\n1 1 1 1 1 1\n```\n```plain\n0 0 0 0 0 0\n0 0 0 1 1 1\n0 1 1 2 2 1\n1 1 2 2 2 1\n1 2 2 1 2 1\n1 1 1 1 1 1\n```", "inputFormat": "每组测试数据第一行一个整数 $n(1 \\le n \\le 30)$。\n\n接下来 $n$ 行，由 $0$ 和 $1$ 组成的 $n \\times n$ 的方阵。\n\n方阵内只有一个闭合圈，圈内至少有一个 $0$。\n", "outputFormat": "已经填好数字 $2$ 的完整方阵。\n", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 30$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Fill Color", "background": "", "description": "In a square grid consisting of digits $0$, there is a closed loop formed by digits $1$ of arbitrary shape. The task is to fill all spaces inside the closed loop with $2$. For example: for a $6 \\times 6$ grid ($n = 6$), the grids before and after filling are as follows:\n\nIf starting from some $0$, moving only in the $4$ directions up, down, left, and right, and passing only through other $0$s, it is impossible to reach the boundary of the grid, then this $0$ is considered to be **inside the closed loop**. The closed loop is not necessarily ring-shaped; it can be any shape, but it is guaranteed that the $0$s **inside the closed loop** are connected (any two can reach each other).\n\n```plain\n0 0 0 0 0 0\n0 0 0 1 1 1\n0 1 1 0 0 1\n1 1 0 0 0 1\n1 0 0 1 0 1\n1 1 1 1 1 1\n```\n```plain\n0 0 0 0 0 0\n0 0 0 1 1 1\n0 1 1 2 2 1\n1 1 2 2 2 1\n1 2 2 1 2 1\n1 1 1 1 1 1\n```", "inputFormat": "For each test case, the first line contains an integer $n$ ($1 \\le n \\le 30$).\n\nThe next $n$ lines contain an $n \\times n$ grid consisting of digits $0$ and $1$.\n\nThere is exactly one closed loop in the grid, and there is at least one $0$ inside the loop.", "outputFormat": "Output the complete grid after filling the inside of the closed loop with the digit $2$.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 30$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "填涂颜色", "background": "", "description": "由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：\n\n如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ **在闭合圈内**。闭合圈不一定是环形的，可以是任意形状，但保证**闭合圈内**的 $0$ 是连通的（两两之间可以相互到达）。\n\n```plain\n0 0 0 0 0 0\n0 0 0 1 1 1\n0 1 1 0 0 1\n1 1 0 0 0 1\n1 0 0 1 0 1\n1 1 1 1 1 1\n```\n```plain\n0 0 0 0 0 0\n0 0 0 1 1 1\n0 1 1 2 2 1\n1 1 2 2 2 1\n1 2 2 1 2 1\n1 1 1 1 1 1\n```", "inputFormat": "每组测试数据第一行一个整数 $n(1 \\le n \\le 30)$。\n\n接下来 $n$ 行，由 $0$ 和 $1$ 组成的 $n \\times n$ 的方阵。\n\n方阵内只有一个闭合圈，圈内至少有一个 $0$。\n", "outputFormat": "已经填好数字 $2$ 的完整方阵。\n", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 30$。\n", "locale": "zh-CN"}}}
{"pid": "P1163", "type": "P", "difficulty": 2, "samples": [["1000 100 12\n", "2.9\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "二分"], "title": "银行贷款", "background": "", "description": "当一个人从银行贷款后，在一段时间内他（她）将不得不每月偿还固定的分期付款。这个问题要求计算出贷款者向银行支付的利率。假设利率按月累计。\n", "inputFormat": "三个用空格隔开的正整数。\n\n第一个整数表示贷款的原值 $w_0$，第二个整数表示每月支付的分期付款金额 $w$，第三个整数表示分期付款还清贷款所需的总月数 $m$。\n", "outputFormat": "一个实数，表示该贷款的月利率（用百分数表示），四舍五入精确到 $0.1\\%$。\n\n数据保证答案不超过 $300.0\\%$。", "hint": "数据保证，$1 \\leq w_0, w\\leq 2^{31}-1$，$1 \\leq m\\leq 3000$。", "locale": "zh-CN", "translations": {"en": {"title": "Bank Loan", "background": "", "description": "After a person takes out a bank loan, he or she must repay a fixed monthly installment over a period of time. This problem asks you to compute the interest rate paid to the bank by the borrower. Assume the interest is compounded monthly.", "inputFormat": "Three positive integers separated by spaces.\n\nThe first integer is the original loan principal $w_0$, the second integer is the fixed monthly installment amount $w$, and the third integer is the total number of months $m$ required to fully repay the loan.", "outputFormat": "Output a real number representing the monthly interest rate (as a percentage), rounded to the nearest 0.1%.\n\nIt is guaranteed that the answer does not exceed 300.0%.", "hint": "It is guaranteed that $1 \\leq w_0, w \\leq 2^{31} - 1$ and $1 \\leq m \\leq 3000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "银行贷款", "background": "", "description": "当一个人从银行贷款后，在一段时间内他（她）将不得不每月偿还固定的分期付款。这个问题要求计算出贷款者向银行支付的利率。假设利率按月累计。\n", "inputFormat": "三个用空格隔开的正整数。\n\n第一个整数表示贷款的原值 $w_0$，第二个整数表示每月支付的分期付款金额 $w$，第三个整数表示分期付款还清贷款所需的总月数 $m$。\n", "outputFormat": "一个实数，表示该贷款的月利率（用百分数表示），四舍五入精确到 $0.1\\%$。\n\n数据保证答案不超过 $300.0\\%$。", "hint": "数据保证，$1 \\leq w_0, w\\leq 2^{31}-1$，$1 \\leq m\\leq 3000$。", "locale": "zh-CN"}}}
{"pid": "P1164", "type": "P", "difficulty": 2, "samples": [["4 4\n1 1 2 2\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "搜索", "洛谷原创", "背包 DP"], "title": "小A点菜", "background": "uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。\n\nuim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。", "description": "不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(0 < M \\le 10000)$。\n\n餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(1 \\le N \\le 100)$，第 $i$ 种卖 $a_i$ 元 $(0 < a_i \\le 1000)$。由于是很低端的餐馆，所以每种菜只有一份。\n\n小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。\n\n由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。", "inputFormat": "第一行两个整数 $N$ 和 $M$，分别表示菜品种类和 uim 身上的钱数。\n\n第二行 $N$ 个正整数 $a_i$（可能有重复），用空格隔开，分别表示每种菜的价格。", "outputFormat": "一个正整数，表示点菜方案数，保证答案的范围在 $[0,2^{31}-1]$ 之内（不超过 C/C++ 的 `int` 范围）。", "hint": "2020.8.29，增添一组 hack 数据 by @yummy", "locale": "zh-CN", "translations": {"en": {"title": "Xiao A Orders Dishes", "background": "After the ace uim got uoi’s ra (lei medal), he immediately dragged his buddy Xiao A to a... restaurant, the really low-end kind. Pointing at the price list on the wall (too low-end to have a menu), he said, \"Order whatever you like.\"", "description": "However, because uim bought some books, he has only $M$ yuan left $(0 < M \\le 10000)$.\n\nAlthough the restaurant is low-end, it still has $N$ kinds of dishes $(1 \\le N \\le 100)$. The $i$-th dish costs $a_i$ yuan $(0 < a_i \\le 1000)$. Since it is a very low-end restaurant, there is only one portion of each dish.\n\nXiao A follows the rule of “not stopping until all the money is spent,” so he will order in such a way that the total cost is exactly all the money uim has. He wants to know how many different ways to order.\n\nBecause Xiao A is too hungry, he can wait at most $1$ second.", "inputFormat": "The first line contains two integers $N$ and $M$, representing the number of dishes and the amount of money uim has.\n\nThe second line contains $N$ positive integers $a_i$ (possibly with duplicates), separated by spaces, representing the price of each dish.", "outputFormat": "Output a single positive integer, the number of ordering plans. It is guaranteed that the answer is in the range $[0, 2^{31}-1]$ (does not exceed the C/C++ int range).", "hint": "2020.8.29, added a set of hack testdata by @yummy.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小A点菜", "background": "uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。\n\nuim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。", "description": "不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(0 < M \\le 10000)$。\n\n餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(1 \\le N \\le 100)$，第 $i$ 种卖 $a_i$ 元 $(0 < a_i \\le 1000)$。由于是很低端的餐馆，所以每种菜只有一份。\n\n小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。\n\n由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。", "inputFormat": "第一行两个整数 $N$ 和 $M$，分别表示菜品种类和 uim 身上的钱数。\n\n第二行 $N$ 个正整数 $a_i$（可能有重复），用空格隔开，分别表示每种菜的价格。", "outputFormat": "一个正整数，表示点菜方案数，保证答案的范围在 $[0,2^{31}-1]$ 之内（不超过 C/C++ 的 `int` 范围）。", "hint": "2020.8.29，增添一组 hack 数据 by @yummy", "locale": "zh-CN"}}}
{"pid": "P1165", "type": "P", "difficulty": 2, "samples": [["13\n0 1\n0 2\n2\n0 4\n0 2\n2\n1\n2\n1\n1\n2\n1\n2\n", "2\n4\n4\n1\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "线性数据结构", "栈"], "title": "日志分析", "background": "", "description": "M 海运公司最近要对旗下仓库的货物进出情况进行统计。目前他们所拥有的唯一记录就是一个记录集装箱进出情况的日志。该日志记录了两类操作：第一类操作为集装箱入库操作，以及该次入库的集装箱重量；第二类操作为集装箱的出库操作。这些记录都严格按时间顺序排列。集装箱入库和出库的规则为先进后出，即每次出库操作出库的集装箱为当前在仓库里所有集装箱中最晚入库的集装箱。\n\n出于分析目的，分析人员在日志中随机插入了若干第三类操作――查询操作。分析日志时，每遇到一次查询操作，都要报告出当前仓库中最大集装箱的重量。\n", "inputFormat": "包含 $N+1$ 行：\n\n第一行为一个正整数 $N$，对应于日志内所含操作的总数。\n\n接下来的 $N$ 行，分别属于以下三种格式之一：\n\n- 格式 1：`0 X`，表示一次集装箱入库操作，正整数 $X$ 表示该次入库的集装箱的重量。\n- 格式 2：`1`，表示一次集装箱出库操作，（就当时而言）最后入库的集装箱出库。\n- 格式 3：`2`，表示一次查询操作，要求分析程序输出当前仓库内最大集装箱的重量。\n\n当仓库为空时你应该忽略出库操作，当仓库为空查询时你应该输出 $0$。\n", "outputFormat": "输出行数等于日志中查询操作的次数。每行为一个整数，表示查询结果。\n", "hint": "### 数据范围及约定\n\n- 对于 $20\\%$ 的数据，有 $N \\le 10$；\n- 对于 $40\\%$ 的数据，有 $N \\le 1000$；\n- 对于 $100\\%$ 的数据，有 $1 \\le N \\le 200000$，$1 \\le X \\le 10^8$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Log Analysis", "background": "", "description": "M Shipping Company needs to analyze the flow of goods in and out of its warehouses. The only records they have are logs tracking container entries and exits. The log contains two types of operations: the first type is an entry operation along with the container’s weight; the second type is an exit operation. All records are strictly in chronological order. The rule for entries and exits is last-in, first-out (LIFO), meaning each exit operation removes the most recently entered container currently in the warehouse.\n\nFor analysis purposes, analysts randomly inserted a third type of operation — a query operation — into the log. When analyzing the log, whenever a query operation is encountered, you must report the maximum container weight currently in the warehouse.", "inputFormat": "Contains $N+1$ lines:\n\nThe first line is a positive integer $N$, which is the total number of operations in the log.\n\nThe next $N$ lines are each in one of the following three formats:\n- Format 1: `0 X`, indicating an entry operation; the positive integer $X$ is the weight of the container being stored.\n- Format 2: `1`, indicating an exit operation; the most recently entered container (at that moment) exits.\n- Format 3: `2`, indicating a query operation; the program must output the maximum container weight currently in the warehouse.\n\nWhen the warehouse is empty, you should ignore a pop operation. When querying an empty warehouse, you should output $0$.", "outputFormat": "The number of output lines equals the number of query operations in the log. Each line contains one integer, which is the query result.", "hint": "### Constraints\n\n- For $20\\%$ of the testdata, $N \\le 10$.\n- For $40\\%$ of the testdata, $N \\le 1000$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 200000$, $1 \\le X \\le 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "日志分析", "background": "", "description": "M 海运公司最近要对旗下仓库的货物进出情况进行统计。目前他们所拥有的唯一记录就是一个记录集装箱进出情况的日志。该日志记录了两类操作：第一类操作为集装箱入库操作，以及该次入库的集装箱重量；第二类操作为集装箱的出库操作。这些记录都严格按时间顺序排列。集装箱入库和出库的规则为先进后出，即每次出库操作出库的集装箱为当前在仓库里所有集装箱中最晚入库的集装箱。\n\n出于分析目的，分析人员在日志中随机插入了若干第三类操作――查询操作。分析日志时，每遇到一次查询操作，都要报告出当前仓库中最大集装箱的重量。\n", "inputFormat": "包含 $N+1$ 行：\n\n第一行为一个正整数 $N$，对应于日志内所含操作的总数。\n\n接下来的 $N$ 行，分别属于以下三种格式之一：\n\n- 格式 1：`0 X`，表示一次集装箱入库操作，正整数 $X$ 表示该次入库的集装箱的重量。\n- 格式 2：`1`，表示一次集装箱出库操作，（就当时而言）最后入库的集装箱出库。\n- 格式 3：`2`，表示一次查询操作，要求分析程序输出当前仓库内最大集装箱的重量。\n\n当仓库为空时你应该忽略出库操作，当仓库为空查询时你应该输出 $0$。\n", "outputFormat": "输出行数等于日志中查询操作的次数。每行为一个整数，表示查询结果。\n", "hint": "### 数据范围及约定\n\n- 对于 $20\\%$ 的数据，有 $N \\le 10$；\n- 对于 $40\\%$ 的数据，有 $N \\le 1000$；\n- 对于 $100\\%$ 的数据，有 $1 \\le N \\le 200000$，$1 \\le X \\le 10^8$。\n", "locale": "zh-CN"}}}
{"pid": "P1166", "type": "P", "difficulty": 3, "samples": [["/ / / 72 9/ 81 8/ / 9/ / 8/", "30 27 19 9 18 9 20 20 20 20 \n30 57 76 85 103 112 132 152 172 192"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟"], "title": "打保龄球", "background": "", "description": "打保龄球是用一个滚球去打击十个站立的柱，将柱击倒。一局分十轮，每轮可滚球一次或多次，以击倒的柱数为依据计分。一局得分为十轮得分之和，而每轮的得分不仅与本轮滚球情况有关，还可能与后续一两轮的滚球情况有关。即某轮某次滚球击倒的柱数不仅要计入本轮得分，还可能会计入前一两轮得分。具体的滚球击柱规则和计分方法如下：\n\n1. 若某一轮的第一次滚球就击倒全部十个柱，则本轮不再滚球（若是第十轮则还需另加两次滚球，不妨称其为第十一轮和第十二轮，并不是所有的情况都需要滚第十一轮和第十二轮球）。该轮得分为本次击倒柱数 $10$ 与以后两次滚球所击倒柱数之和。\n\n2. 若某一轮的第一次滚球未击倒十个柱，则可对剩下未倒的柱再滚球一次。如果这两次滚球击倒全部十个柱，则本轮不再滚球（若是第十轮则还需另加一次滚球），该轮得分为这两次共击倒柱数 $10$ 与以后一次滚球所击倒柱数之和。\n\n3. 若某一轮两次滚球未击倒全部十个柱，则本轮不再继续滚球，该轮得分为这两次滚球击倒的柱数之和。   \n\n总之，若一轮中一次滚球或两次滚球击倒十个柱，则本轮得分是本轮首次滚球开始的连续三次滚球击倒柱数之和（其中有一次或两次不是本轮滚球）。若一轮内二次滚球击倒柱数不足十个，则本轮得分即为这两次击倒柱数之和。下面以实例说明如下(字符 `/` 表示击倒当前球道上的全部的柱)：\n\n| 轮 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| 击球情况  |  /  |  /  |  /  |  72 |  9/ |  81  | 8/  |  / |   9/  |  /  |  8/ |\n| 各轮得分 |  30  | 27  | 19 |  9   |18   | 9  | 20  | 20 |  20 |  20|\n|累计总分 |  30  | 57  |76 |  85|  103 |  112 | 132  |152 | 172 | 192|\n\n现在请你编写一个保龄球实时计分程序，用来计算和显示某轮结束后的得分情况。若某轮的得分暂时无法算出，则**不显示**该轮得分（不输出）。\n", "inputFormat": "仅有一行，为前若干轮滚球的情况，每轮滚球用一到两个字符表示，每一个字符表示一次击球，字符 `/` 表示击倒当前球道上的全部的柱，否则用一个数字字符表示本次滚球击倒的当前球道上的柱的数目，两轮滚球之间用一个空格字符隔开。\n\n如上例对应的输入文件内容为：`/ / / 72 9/ 81 8/ / 9/ / 8/`\n", "outputFormat": "共两行，第一行为每轮得分，第二行为到当前轮为止的总得分。每个得分之间用一个空格隔开。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Bowling", "background": "", "description": "Bowling uses a rolling ball to knock down ten standing pins. A game has ten frames. In each frame, you may roll the ball once or more times, and scoring is based on the number of pins knocked down. The total score for a game is the sum of the scores of the ten frames. A frame’s score depends not only on that frame’s rolls, but may also depend on the rolls in the next one or two frames. That is, the number of pins knocked down by a roll in a later frame may be counted toward the score of one or two previous frames. The specific pin-knocking and scoring rules are as follows:\n\n1. If the first roll of a frame knocks down all ten pins, then there are no more rolls in that frame (if it is the 10th frame, add two more rolls; we may call them the 11th and 12th frames, though not all situations require rolling the 11th and 12th balls). The score of that frame is $10$ plus the total pins knocked down by the next two rolls.\n\n2. If the first roll of a frame does not knock down all ten pins, you may roll once more for the remaining pins. If the two rolls together knock down all ten pins, then there are no more rolls in that frame (if it is the 10th frame, add one more roll). The score of that frame is $10$ plus the pins knocked down by the next roll.\n\n3. If the two rolls in a frame do not knock down all ten pins, then the frame ends. The score of that frame is the sum of pins knocked down in those two rolls.\n\nIn short, if a frame’s one or two rolls knock down all ten pins, then the frame’s score is the sum of the pins knocked down in the first three consecutive rolls starting from that frame’s first roll (one or two of those rolls may belong to the following frames). If the two rolls in a frame knock down fewer than ten pins, the frame’s score is simply the sum of those two rolls. Here is an example (the character `/` means knocking down all currently standing pins):\n\n| Frame | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| Rolls | / | / | / | 72 | 9/ | 81 | 8/ | / | 9/ | / | 8/ |  |\n| Score per frame | 30 | 27 | 19 | 9 | 18 | 9 | 20 | 20 | 20 | 20 |  |  |\n| Cumulative total | 30 | 57 | 76 | 85 | 103 | 112 | 132 | 152 | 172 | 192 |  |  |\n\nNow, please write a real-time bowling scoring program to compute and display the scores after a frame ends. If a frame’s score cannot be determined yet, do not display that frame’s score (do not output it).", "inputFormat": "A single line describing the rolls of the first several frames. Each frame is written with one or two characters, and each character represents one roll. The character `/` means knocking down all currently standing pins; otherwise, a digit character represents the number of pins knocked down in that roll. Frames are separated by a single space character.\n\nFor example, the input corresponding to the sample above is: `/ / / 72 9/ 81 8/ / 9/ / 8/`.", "outputFormat": "Two lines. The first line lists the score for each frame; the second line lists the cumulative total up to the current frame. Separate scores with a single space.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "打保龄球", "background": "", "description": "打保龄球是用一个滚球去打击十个站立的柱，将柱击倒。一局分十轮，每轮可滚球一次或多次，以击倒的柱数为依据计分。一局得分为十轮得分之和，而每轮的得分不仅与本轮滚球情况有关，还可能与后续一两轮的滚球情况有关。即某轮某次滚球击倒的柱数不仅要计入本轮得分，还可能会计入前一两轮得分。具体的滚球击柱规则和计分方法如下：\n\n1. 若某一轮的第一次滚球就击倒全部十个柱，则本轮不再滚球（若是第十轮则还需另加两次滚球，不妨称其为第十一轮和第十二轮，并不是所有的情况都需要滚第十一轮和第十二轮球）。该轮得分为本次击倒柱数 $10$ 与以后两次滚球所击倒柱数之和。\n\n2. 若某一轮的第一次滚球未击倒十个柱，则可对剩下未倒的柱再滚球一次。如果这两次滚球击倒全部十个柱，则本轮不再滚球（若是第十轮则还需另加一次滚球），该轮得分为这两次共击倒柱数 $10$ 与以后一次滚球所击倒柱数之和。\n\n3. 若某一轮两次滚球未击倒全部十个柱，则本轮不再继续滚球，该轮得分为这两次滚球击倒的柱数之和。   \n\n总之，若一轮中一次滚球或两次滚球击倒十个柱，则本轮得分是本轮首次滚球开始的连续三次滚球击倒柱数之和（其中有一次或两次不是本轮滚球）。若一轮内二次滚球击倒柱数不足十个，则本轮得分即为这两次击倒柱数之和。下面以实例说明如下(字符 `/` 表示击倒当前球道上的全部的柱)：\n\n| 轮 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| 击球情况  |  /  |  /  |  /  |  72 |  9/ |  81  | 8/  |  / |   9/  |  /  |  8/ |\n| 各轮得分 |  30  | 27  | 19 |  9   |18   | 9  | 20  | 20 |  20 |  20|\n|累计总分 |  30  | 57  |76 |  85|  103 |  112 | 132  |152 | 172 | 192|\n\n现在请你编写一个保龄球实时计分程序，用来计算和显示某轮结束后的得分情况。若某轮的得分暂时无法算出，则**不显示**该轮得分（不输出）。\n", "inputFormat": "仅有一行，为前若干轮滚球的情况，每轮滚球用一到两个字符表示，每一个字符表示一次击球，字符 `/` 表示击倒当前球道上的全部的柱，否则用一个数字字符表示本次滚球击倒的当前球道上的柱的数目，两轮滚球之间用一个空格字符隔开。\n\n如上例对应的输入文件内容为：`/ / / 72 9/ 81 8/ / 9/ / 8/`\n", "outputFormat": "共两行，第一行为每轮得分，第二行为到当前轮为止的总得分。每个得分之间用一个空格隔开。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1167", "type": "P", "difficulty": 3, "samples": [["2\n1\n1\n2007-06-23-11:59\n2007-06-23-12:00", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "数学", "贪心", "洛谷原创", "排序"], "title": "刷题", "background": "", "description": "NOIP 临近了，小 A 却发现他已经不会写题了。好在现在离竞赛还有一段时间，小 A 决定从现在开始夜以继日地刷题。也就是说小 A 废寝忘食，一天二十四小时地刷题。\n\n今天的日期（时间）是 yyyy 年 mm 月 dd 日 hh 时 MM 分，考试的时间是 yyyy2 年 mm2 月 dd2 日 hh2 时 MM2 分。这之间的所有时间小 A 都用来刷题了，那么考试之前他最多能刷多少题呢？注意哦，考虑闰年。\n\n时间紧张小 A 只管数量不管质量。当然有的题目容易一些，有的题目难一些。根据小 A 的经验，他能一眼看出写出某一个题目需要的时间，以分钟记。\n\n现在给出洛谷 Online Judge 的题目列表，请你挑出最多的题目使小A能在竞赛前写出来。\n\n我们假设从远古到未来，历法的表示与现在一样。\n", "inputFormat": "第一行一个整数 $N$，表示洛谷 Online Judge 的题目数，$N≤5000$。\n\n接下来$N$行，每行一个整数表示刷该题需要用的时间，以分钟记（$ \\le 10000$）。（这个题本身是什么并不重要，不是么？`小A`已经写过题目数为 $0$ 个）。\n\n接下来两行依次是当前时间和竞赛时间。时间给出的格式是：`yyyy-mm-dd-hh:MM`，例如：`2007-06-23-02:00`，采用 $24$ 小时制，每天从 00:00 到 23:59，年份从 $0000$ 到 $9999$。\n", "outputFormat": "一行，一个整数，NOIP 前最多刷的题目数。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Solving Problems", "background": "", "description": "As NOIP approaches, Xiao A realizes he has forgotten how to solve problems. Fortunately, there is still some time before the contest, so he decides to grind problems day and night from now on. That is, Xiao A will forgo sleep and solve problems twenty-four hours a day.\n\nToday’s date (time) is yyyy year mm month dd day hh hour MM minute, and the exam time is yyyy2 year mm2 month dd2 day hh2 hour MM2 minute. He spends all the time in between solving problems. How many problems can he solve at most before the exam? Note: consider leap years.\n\nTime is tight, so Xiao A cares only about quantity, not quality. Of course, some problems are easier and some are harder. Based on his experience, he can instantly tell how long it will take to solve any given problem, in minutes.\n\nGiven the Luogu Online Judge problem list, please choose as many problems as possible so that Xiao A can finish them before the contest.\n\nAssume that from ancient times to the future, the calendar representation is the same as it is now.", "inputFormat": "The first line contains an integer $N$, the number of Luogu Online Judge problems, $N≤5000$.\n\nThe next $N$ lines each contain one integer, the time required to solve that problem, in minutes ($ \\le 10000$). (What the problems themselves are is not important, is it? `小A` has already solved $0$ problems.)\n\nThe next two lines are the current time and the contest time, respectively. The time format is: `yyyy-mm-dd-hh:MM`, for example: `2007-06-23-02:00`, using the $24$-hour system. Each day runs from 00:00 to 23:59, and years range from $0000$ to $9999$.", "outputFormat": "One line containing a single integer: the maximum number of problems that can be solved before NOIP.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "刷题", "background": "", "description": "NOIP 临近了，小 A 却发现他已经不会写题了。好在现在离竞赛还有一段时间，小 A 决定从现在开始夜以继日地刷题。也就是说小 A 废寝忘食，一天二十四小时地刷题。\n\n今天的日期（时间）是 yyyy 年 mm 月 dd 日 hh 时 MM 分，考试的时间是 yyyy2 年 mm2 月 dd2 日 hh2 时 MM2 分。这之间的所有时间小 A 都用来刷题了，那么考试之前他最多能刷多少题呢？注意哦，考虑闰年。\n\n时间紧张小 A 只管数量不管质量。当然有的题目容易一些，有的题目难一些。根据小 A 的经验，他能一眼看出写出某一个题目需要的时间，以分钟记。\n\n现在给出洛谷 Online Judge 的题目列表，请你挑出最多的题目使小A能在竞赛前写出来。\n\n我们假设从远古到未来，历法的表示与现在一样。\n", "inputFormat": "第一行一个整数 $N$，表示洛谷 Online Judge 的题目数，$N≤5000$。\n\n接下来$N$行，每行一个整数表示刷该题需要用的时间，以分钟记（$ \\le 10000$）。（这个题本身是什么并不重要，不是么？`小A`已经写过题目数为 $0$ 个）。\n\n接下来两行依次是当前时间和竞赛时间。时间给出的格式是：`yyyy-mm-dd-hh:MM`，例如：`2007-06-23-02:00`，采用 $24$ 小时制，每天从 00:00 到 23:59，年份从 $0000$ 到 $9999$。\n", "outputFormat": "一行，一个整数，NOIP 前最多刷的题目数。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1168", "type": "P", "difficulty": 3, "samples": [["7\n1 3 5 7 9 11 6", "1\n3\n5\n6"], ["7\n3 1 5 9 8 7 6", "3\n3\n5\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["线段树", "二分", "堆", "树状数组"], "title": "中位数", "background": null, "description": "给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。", "inputFormat": "第一行一个正整数 $N$。\n\n第二行 $N$ 个正整数 $A_{1\\dots N}$。", "outputFormat": "共 $\\lfloor \\frac{N + 1}2\\rfloor$ 行，第 $i$ 行为 $A_{1\\dots 2i - 1}$ 的中位数。", "hint": "对于 $20\\%$ 的数据，$N \\le 100$；\n\n对于 $40\\%$ 的数据，$N \\le 3000$；\n\n对于 $100\\%$ 的数据，$1 \\le N ≤ 10^5$，$0 \\le A_i \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "Median", "background": "", "description": "Given a non-negative integer sequence $A$ of length $N$, find the median for each odd prefix.", "inputFormat": "The first line contains a positive integer $N$.\nThe second line contains $N$ non-negative integers $A_{1\\dots N}$.", "outputFormat": "There are $\\lfloor \\frac{N + 1}2\\rfloor$ lines. The $i$-th line is the median of $A_{1\\dots 2i - 1}$.", "hint": "For 20% of the testdata, $N \\le 100$.\nFor 40% of the testdata, $N \\le 3000$.\nFor 100% of the testdata, $1 \\le N \\le 100000$, $0 \\le A_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "中位数", "background": null, "description": "给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。", "inputFormat": "第一行一个正整数 $N$。\n\n第二行 $N$ 个正整数 $A_{1\\dots N}$。", "outputFormat": "共 $\\lfloor \\frac{N + 1}2\\rfloor$ 行，第 $i$ 行为 $A_{1\\dots 2i - 1}$ 的中位数。", "hint": "对于 $20\\%$ 的数据，$N \\le 100$；\n\n对于 $40\\%$ 的数据，$N \\le 3000$；\n\n对于 $100\\%$ 的数据，$1 \\le N ≤ 10^5$，$0 \\le A_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P1169", "type": "P", "difficulty": 4, "samples": [["3 3\n1 0 1\n0 1 0\n1 0 0\n", "4\n6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2007", "各省省选", "浙江", "栈"], "title": "[ZJOI2007] 棋盘制作", "background": null, "description": "国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个 $8 \\times 8$ 大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。\n\n而我们的主人公 `小Q`，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友 `小W` 决定将棋盘扩大以适应他们的新规则。\n\n`小Q` 找到了一张由 $N \\times M$ 个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。`小Q` 想在这种纸中裁剪一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。\n\n不过 `小Q` 还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。\n\n于是 `小Q` 找到了即将参加全国信息学竞赛的你，你能帮助他么？", "inputFormat": "包含两个整数 $N$ 和 $M$，分别表示矩形纸片的长和宽。接下来的 $N$ 行包含一个 $N\\times M$ 的 $01$ 矩阵，表示这张矩形纸片的颜色（$0$ 表示白色，$1$ 表示黑色）。", "outputFormat": "包含两行，每行包含一个整数。第一行为可以找到的最大正方形棋盘的面积，第二行为可以找到的最大矩形棋盘的面积（注意正方形和矩形是可以相交或者包含的）。", "hint": "对于 $20\\%$ 的数据，$N, M ≤ 80$\n\n对于 $40\\%$ 的数据，$N, M ≤ 400$\n\n对于 $100\\%$ 的数据，$N, M ≤ 2000$", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2007] Chessboard Making", "background": "# Description\n\nChess is one of the oldest games in the world, as famous as China’s Go and Xiangqi and Japan’s Shogi. It is said that chess originated from the ideas of the I Ching: the board is an $8 \\times 8$ checkerboard corresponding to the sixty-four hexagrams, with black and white representing yin and yang.\n\nOur protagonist `小Q` is a die-hard chess enthusiast. As a top expert, he is no longer satisfied with the standard board and rules, so he and his good friend `小W` decide to enlarge the board to suit their new rules.\n\n`小Q` finds a rectangular sheet made up of $N \\times M$ square cells, each painted in one of two colors: black or white. `小Q` wants to cut out a part of this sheet to serve as the new chessboard. Of course, he wants this board to be as large as possible.\n\nHowever, `小Q` has not decided whether to choose a square board or a rectangular board (in either case, the board must be checkerboard-colored, i.e., adjacent cells have different colors). Therefore, he wants to find the maximum possible area of a square chessboard and the maximum possible area of a rectangular chessboard, so that he can decide which is better.\n\nNow `小Q` turns to you, who is about to participate in the National Olympiad in Informatics. Can you help him?", "description": "Chess is one of the oldest games in the world, as famous as China’s Go and Xiangqi and Japan’s Shogi. It is said that chess originated from the ideas of the I Ching: the board is an $8 \\times 8$ checkerboard corresponding to the sixty-four hexagrams, with black and white representing yin and yang.\n\nOur protagonist `小Q` is a die-hard chess enthusiast. As a top expert, he is no longer satisfied with the standard board and rules, so he and his good friend `小W` decide to enlarge the board to suit their new rules.\n\n`小Q` finds a rectangular sheet made up of $N \\times M$ square cells, each painted in one of two colors: black or white. `小Q` wants to cut out a part of this sheet to serve as the new chessboard. Of course, he wants this board to be as large as possible.\n\nHowever, `小Q` has not decided whether to choose a square board or a rectangular board (in either case, the board must be checkerboard-colored, i.e., adjacent cells have different colors). Therefore, he wants to find the maximum possible area of a square chessboard and the maximum possible area of a rectangular chessboard, so that he can decide which is better.\n\nNow `小Q` turns to you, who is about to participate in the National Olympiad in Informatics. Can you help him?\n\n# Description", "inputFormat": "The first line contains two integers $N$ and $M$, denoting the number of rows and columns of the rectangular sheet.\n\nThe next $N$ lines contain a $N \\times M$ $01$ matrix representing the colors ($0$ means white, $1$ means black). Each of these $N$ lines contains exactly $M$ characters without spaces.", "outputFormat": "Output two lines, each containing one integer. The first line is the area of the largest square chessboard that can be found; the second line is the area of the largest rectangular chessboard that can be found (note that the square and the rectangle may overlap or one may contain the other).", "hint": "For $20\\%$ of the testdata, $N, M \\le 80$.\n\nFor $40\\%$ of the testdata, $N, M \\le 400$.\n\nFor $100\\%$ of the testdata, $N, M \\le 2000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2007] 棋盘制作", "background": null, "description": "国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个 $8 \\times 8$ 大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。\n\n而我们的主人公 `小Q`，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友 `小W` 决定将棋盘扩大以适应他们的新规则。\n\n`小Q` 找到了一张由 $N \\times M$ 个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。`小Q` 想在这种纸中裁剪一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。\n\n不过 `小Q` 还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。\n\n于是 `小Q` 找到了即将参加全国信息学竞赛的你，你能帮助他么？", "inputFormat": "包含两个整数 $N$ 和 $M$，分别表示矩形纸片的长和宽。接下来的 $N$ 行包含一个 $N\\times M$ 的 $01$ 矩阵，表示这张矩形纸片的颜色（$0$ 表示白色，$1$ 表示黑色）。", "outputFormat": "包含两行，每行包含一个整数。第一行为可以找到的最大正方形棋盘的面积，第二行为可以找到的最大矩形棋盘的面积（注意正方形和矩形是可以相交或者包含的）。", "hint": "对于 $20\\%$ 的数据，$N, M ≤ 80$\n\n对于 $40\\%$ 的数据，$N, M ≤ 400$\n\n对于 $100\\%$ 的数据，$N, M ≤ 2000$", "locale": "zh-CN"}}}
{"pid": "P1170", "type": "P", "difficulty": 2, "samples": [["1\n1 1\n1 2", "no"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "最大公约数 gcd"], "title": "兔八哥与猎人", "background": null, "description": "兔八哥躲藏在树林旁边的果园里。果园有 $M  \\times  N$ 棵树，组成一个 $M$ 行 $N$ 列的矩阵，水平或垂直相邻的两棵树的距离为 $1$。兔八哥在一棵果树下。\n\n猎人背着猎枪走进了果园，他爬上一棵果树，准备杀死兔八哥。\n\n如果猎人与兔八哥位置的连线上没有其它的果树，猎人就可以看到兔八哥。\n\n现已知猎人和兔八哥的位置，编写程序判断兔子所在的位置是否安全。", "inputFormat": "第一行为 $n$，表示有 $n$ 组数据，每组数据的第一行为两个正整数 $a_x$ 和 $a_y$，表示猎人的位置，第二行为两个正整数 $b_x$ 和 $b_y$，表示兔八哥的位置。", "outputFormat": "共有 $n$ 行，每行为 `yes` 或 `no` 表示兔八哥的位置是否安全。", "hint": "$1\\le n \\le 10^5$，$1 \\le  a_x, a_y, b_x, b_y \\le  10^8$。\n\n题目保证兔八哥和猎人不会在同一个位置。", "locale": "zh-CN", "translations": {"en": {"title": "Bugs Bunny and the Hunter", "background": "", "description": "Bugs Bunny is hiding in an orchard next to a forest. The orchard has $M \\times N$ trees arranged in an $M$-row by $N$-column grid, and the distance between two horizontally or vertically adjacent trees is $1$. Bugs Bunny is under one of the trees.\n\nA hunter carrying a shotgun enters the orchard. He climbs onto a fruit tree, preparing to kill Bugs Bunny.\n\nIf there is no other fruit tree on the line segment connecting the hunter’s position and Bugs Bunny’s position, then the hunter can see Bugs Bunny.\n\nGiven the positions of the hunter and Bugs Bunny, write a program to determine whether the rabbit’s position is safe.", "inputFormat": "The first line contains $n$, the number of test cases. For each test case, the first line contains two positive integers $a_x$ and $a_y$, representing the hunter’s position, and the second line contains two positive integers $b_x$ and $b_y$, representing Bugs Bunny’s position.", "outputFormat": "Output $n$ lines. Each line contains `yes` or `no`, indicating whether Bugs Bunny’s position is safe.", "hint": "$1 \\le n \\le 10^5$, $1 \\le a_x, a_y, b_x, b_y \\le 10^8$.\n\nIt is guaranteed that Bugs Bunny and the hunter are not at the same position.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "兔八哥与猎人", "background": null, "description": "兔八哥躲藏在树林旁边的果园里。果园有 $M  \\times  N$ 棵树，组成一个 $M$ 行 $N$ 列的矩阵，水平或垂直相邻的两棵树的距离为 $1$。兔八哥在一棵果树下。\n\n猎人背着猎枪走进了果园，他爬上一棵果树，准备杀死兔八哥。\n\n如果猎人与兔八哥位置的连线上没有其它的果树，猎人就可以看到兔八哥。\n\n现已知猎人和兔八哥的位置，编写程序判断兔子所在的位置是否安全。", "inputFormat": "第一行为 $n$，表示有 $n$ 组数据，每组数据的第一行为两个正整数 $a_x$ 和 $a_y$，表示猎人的位置，第二行为两个正整数 $b_x$ 和 $b_y$，表示兔八哥的位置。", "outputFormat": "共有 $n$ 行，每行为 `yes` 或 `no` 表示兔八哥的位置是否安全。", "hint": "$1\\le n \\le 10^5$，$1 \\le  a_x, a_y, b_x, b_y \\le  10^8$。\n\n题目保证兔八哥和猎人不会在同一个位置。", "locale": "zh-CN"}}}
{"pid": "P1171", "type": "P", "difficulty": 4, "samples": [["3\n0 2 1\n1 0 2\n2 1 0", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["状压 DP"], "title": "售货员的难题", "background": "**数据有更改**\n", "description": "某乡有 $n$ 个村庄，有一个售货员，他要到各个村庄去售货，各村庄之间的路程 $s_{i,j}$ 是已知的，且 $A$ 村到 $B$ 村与 $B$ 村到 $A$ 村的路大多不同。为了提高效率，他从商店出发到每个村庄一次，然后返回商店所在的村，假设商店所在的村庄为 $1$，他不知道选择什么样的路线才能使所走的路程最短。请你帮他选择一条最短的路。\n", "inputFormat": "第一行是一个整数，表示村庄数 $n$。  \n接下来 $n$ 行，每行 $n$ 个整数，第 $i$ 行的第 $j$ 个整数表示 $i$ 到 $j$ 的单向路径的距离 $s_{i,j}$。", "outputFormat": "一行一个整数表示最短的路程。\n", "hint": "对全部的测试数据，保证 $2 \\leq n \\leq 20$，$1 \\leq s_{i,j} < 10^3$。", "locale": "zh-CN", "translations": {"en": {"title": "The Traveling Salesman Problem", "background": "**The testdata has been updated.**", "description": "In a certain township, there are $n$ villages. A salesman needs to visit each village to sell goods. The distances $s_{i,j}$ between villages are known, and, in general, the road from village A to village B may be different from the road from village B to village A. To improve efficiency, he starts from the store, visits each village exactly once, and then returns to the village where the store is located. Assume the store is in village $1$. He does not know which route will minimize the total distance traveled. Please help him choose a route with the shortest total length.", "inputFormat": "The first line contains an integer $n$, the number of villages.  \nThe next $n$ lines each contain $n$ integers. In the $i$-th line, the $j$-th integer represents the distance $s_{i,j}$ of the one-way path from $i$ to $j$.", "outputFormat": "Output a single integer on one line, representing the length of the shortest route.", "hint": "For all testdata, it is guaranteed that $2 \\leq n \\leq 20$, $1 \\leq s_{i,j} < 10^3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "售货员的难题", "background": "**数据有更改**\n", "description": "某乡有 $n$ 个村庄，有一个售货员，他要到各个村庄去售货，各村庄之间的路程 $s_{i,j}$ 是已知的，且 $A$ 村到 $B$ 村与 $B$ 村到 $A$ 村的路大多不同。为了提高效率，他从商店出发到每个村庄一次，然后返回商店所在的村，假设商店所在的村庄为 $1$，他不知道选择什么样的路线才能使所走的路程最短。请你帮他选择一条最短的路。\n", "inputFormat": "第一行是一个整数，表示村庄数 $n$。  \n接下来 $n$ 行，每行 $n$ 个整数，第 $i$ 行的第 $j$ 个整数表示 $i$ 到 $j$ 的单向路径的距离 $s_{i,j}$。", "outputFormat": "一行一个整数表示最短的路程。\n", "hint": "对全部的测试数据，保证 $2 \\leq n \\leq 20$，$1 \\leq s_{i,j} < 10^3$。", "locale": "zh-CN"}}}
{"pid": "P1173", "type": "P", "difficulty": 7, "samples": [["4\n4 4 2\n1 1\n4 4\n2 3 1\n1 2\n2 2 2\n1 1\n2 2\n1 1 0", "2\n1\n0\n-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2016", "NOI", "O2优化", "双连通分量"], "title": "[NOI2016] 网格", "background": "", "description": "跳蚤国王和蛐蛐国王在玩一个游戏。\n\n他们在一个 $n$ 行 $m$ 列的网格上排兵布阵。其中的 $c$ 个格子中 $(0 \\leq c \\leq n\\cdot m)$，每个格子有一只蛐蛐，其余的格子中，每个格子有一只跳蚤。\n\n我们称占据的格子有公共边的两只跳蚤是相邻的。\n\n我们称两只跳蚤是连通的，当且仅当这两只跳蚤相邻，或存在另一只跳蚤与这两只跳蚤都连通。\n\n现在，蛐蛐国王希望，将某些（零个，一个或多个）跳蚤替换成蛐蛐，使得在此之后存在至少两只跳蚤不连通。\n\n例如：图 $1$ 描述了一个 $n=4$，$m=4$，$c=2$ 的情况。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/96tey4uv.png)\n\n这种情况下蛐蛐国王可以通过将第二行第二列，和第三行第三列的两只跳蚤替换为蛐蛐，从而达成他的希望，如右图所示。并且，不存在更优的方案，但是可能存在其他替换两只跳蚤的方案。\n\n你需要首先判断蛐蛐国王的希望能否被达成。如果能够达成，你还需要最小化被替换的跳蚤的个数。", "inputFormat": "每个输入文件包含多组数据。\n\n输入文件的第一行只有一个整数 $T$，表示数据的组数。\n\n接下来依次输入 $T$ 组数据，每组数据的第一行包含三个整数 $n, m, c$。\n\n接下来 $c$ 行，每行包含两个整数 $x, y$ 表示第 $x$ 行，第 $y$ 列的格子被一个蛐蛐占据。每一组数据当中，同一个蛐蛐不会被多次描述。", "outputFormat": "对于每一组数据依次输出一行答案。\n\n如果这组数据中，蛐蛐国王的希望不能被达成，输出 $-1$。否则，输出被替换的跳蚤的个数的最小值。", "hint": "### 样例解释\n\n第一组数据就是问题描述中的例子。\n\n对于第二组数据，可以将第二行第二列的一只跳蚤替换为蛐蛐，从而使得存在两只跳蚤不连通，并且不存在更优的方案。\n\n对于第三组数据，最初已经存在两只跳蚤不连通，故不需要再进行替换。\n\n对于第四组数据，由于最多只有一只跳蚤，所以无论如何替换都不能存在两只跳蚤不连通。\n\n### 数据范围\n\n对于全部的测试点，保证 $1 \\leq T \\leq 20$。我们记 $\\sum c$ 为某个测试点中，其 $T$ 组输入数据的所有 $c$ 的总和。对于所有的测试点，$\\sum c \\leq 10^5$。\n\n对于全部的数据，满足 $1 \\leq n,m \\leq 10^9$，$0 \\leq c \\leq n \\times m$，$1 \\leq x \\leq n, 1 \\leq y \\leq m$。\n\n每个测试点的详细数据范围见下表。表中的 $n,m,c$ 均是对于单个输入数据（而非测试点）而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件；而 $\\sum c$是对于单个测试点而言的。为了方便阅读，“测试点”一列被放到了表格的中间而不是左边。 \n\n| $n,m$ | 测试点 | $c$ |\n| :----------: | :----------: | :----------: |\n| $n\\times m\\leq 4$ | $1$ | $c\\leq n\\times m$ |\n| $n\\times m\\leq 8$ | $2$ | ^ |\n| $n\\times m\\leq 15$ | $3$ | ^ |\n| $n\\times m\\leq 30$ |  $4$| ^ |\n| $n\\times m\\leq 100$ | $5$ | ^ |\n| $n\\times m\\leq 300$ | $6$ | ^ |\n| $n\\times m\\leq 10^3$ | $7$ | ^ |\n| $n\\times m\\leq 2\\times 10^4$ | $8$ | $c\\leq 5$ |\n| ^ | $9$ | $c\\leq 15$ |\n| ^ | $10$ | $c\\leq 30$ |\n| $n,m\\leq 2\\times 10^4,n\\times m\\leq2\\times 10^4$ | $11$ | $\\sum c\\leq 2\\times 10^4$ |\n| $n,m\\leq 2\\times 10^4,n\\times m\\leq10^5$  | $12$ | ^ |\n| $n,m\\leq 2\\times 10^4,n\\times m\\leq3\\times 10^5$ | $13$ | ^ |\n| $n,m\\leq 2\\times 10^4,n\\times m\\leq10^6$ | $14$ | ^ |\n| $n,m\\leq 2\\times 10^4,n\\times m\\leq 10^9$ | $15$ | ^ |\n| $n,m\\leq 10^5$ | $16$ | $\\sum c\\leq 10^5$ |\n| $n,m\\leq 10^9$ | $17$ | $c=0$ |\n| ^ | $18$ | $c\\leq 1$ |\n| ^ | $19$ | $c\\leq 2$ |\n| ^ | $20$ | $c\\leq 3$ |\n| ^ | $21$ | $c\\leq 10$ |\n| ^ | $22$ | $c\\leq 30$ |\n| ^ | $23$ | $c\\leq 300$ |\n| ^ | $24$ | $\\sum c\\leq 2 \\times 10^4$ |\n| ^ | $25$ | $\\sum c\\leq   10^5$ |", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2016] Grid", "background": "", "description": "The Flea King and the Cricket King are playing a game.\n\nThey deploy pieces on an $n$-row, $m$-column grid. Among the $c$ cells ($0 \\leq c \\leq n \\cdot m$), each such cell contains a cricket, and each remaining cell contains a flea.\n\nTwo fleas are called adjacent if their occupied cells share a side.\n\nTwo fleas are called connected if and only if they are adjacent, or there exists a sequence of fleas starting from one and ending at the other such that consecutive fleas in the sequence are adjacent.\n\nNow, the Cricket King wants to replace some fleas (zero, one, or more) with crickets so that afterwards there exist at least two fleas that are not connected.\n\nFor example: Figure $1$ describes a case with $n=4$, $m=4$, $c=2$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/96tey4uv.png)\n\nIn this case, the Cricket King can replace the fleas at row $2$, column $2$ and row $3$, column $3$ with crickets to achieve his goal, as shown in the right picture. Moreover, no better plan exists, although there may be other plans that also replace two fleas.\n\nYou must first determine whether the Cricket King's goal can be achieved. If it can, you must also minimize the number of fleas replaced.", "inputFormat": "Each input file contains multiple test cases.\n\nThe first line contains a single integer $T$, the number of test cases.\n\nFor each of the next $T$ test cases, the first line contains three integers $n, m, c$.\n\nThen $c$ lines follow. Each line contains two integers $x, y$ indicating that the cell in row $x$, column $y$ is occupied by a cricket. Within each test case, no cricket cell is listed more than once.", "outputFormat": "For each test case, output one line.\n\nIf the Cricket King's goal cannot be achieved for this test case, output $-1$. Otherwise, output the minimum number of fleas that must be replaced.", "hint": "### Sample explanation\n\n- The first test case is the example in the statement.\n- For the second test case, replacing the flea at row $2$, column $2$ makes two fleas not connected, and no better plan exists.\n- For the third test case, there already exist two fleas that are not connected initially, so no replacements are needed.\n- For the fourth test case, since there is at most one flea, no matter how you replace, there cannot exist two fleas that are not connected.\n\n### Constraints\n\nFor all test points, it is guaranteed that $1 \\leq T \\leq 20$. Let $\\sum c$ denote, within one test point, the sum of $c$ over its $T$ test cases. For all test points, $\\sum c \\leq 10^5$.\n\nFor all data, $1 \\leq n, m \\leq 10^9$, $0 \\leq c \\leq n \\times m$, $1 \\leq x \\leq n$, $1 \\leq y \\leq m$.\n\nThe detailed constraints for each test point are shown in the table below. In the table, $n, m, c$ refer to a single test case (not a test point), i.e., all $T$ test cases within the same test point meet the listed limits; and $\\sum c$ is for a single test point. For readability, the “Test Point” column is placed in the middle rather than on the left.\n\n| $n,m$ | Test Point | $c$ |\n| :----------: | :----------: | :----------: |\n| $n\\times m\\leq 4$ | $1$ | $c\\leq n\\times m$ |\n| $n\\times m\\leq 8$ | $2$ | ^ |\n| $n\\times m\\leq 15$ | $3$ | ^ |\n| $n\\times m\\leq 30$ |  $4$| ^ |\n| $n\\times m\\leq 100$ | $5$ | ^ |\n| $n\\times m\\leq 300$ | $6$ | ^ |\n| $n\\times m\\leq 10^3$ | $7$ | ^ |\n| $n\\times m\\leq 2\\times 10^4$ | $8$ | $c\\leq 5$ |\n| ^ | $9$ | $c\\leq 15$ |\n| ^ | $10$ | $c\\leq 30$ |\n| $n,m\\leq 2\\times 10^4,n\\times m\\leq2\\times 10^4$ | $11$ | $\\sum c\\leq 2\\times 10^4$ |\n| $n,m\\leq 2\\times 10^4,n\\times m\\leq10^5$  | $12$ | ^ |\n| $n,m\\leq 2\\times 10^4,n\\times m\\leq3\\times 10^5$ | $13$ | ^ |\n| $n,m\\leq 2\\times 10^4,n\\times m\\leq10^6$ | $14$ | ^ |\n| $n,m\\leq 2\\times 10^4,n\\times m\\leq 10^9$ | $15$ | ^ |\n| $n,m\\leq 10^5$ | $16$ | $\\sum c\\leq 10^5$ |\n| $n,m\\leq 10^9$ | $17$ | $c=0$ |\n| ^ | $18$ | $c\\leq 1$ |\n| ^ | $19$ | $c\\leq 2$ |\n| ^ | $20$ | $c\\leq 3$ |\n| ^ | $21$ | $c\\leq 10$ |\n| ^ | $22$ | $c\\leq 30$ |\n| ^ | $23$ | $c\\leq 300$ |\n| ^ | $24$ | $\\sum c\\leq 2 \\times 10^4$ |\n| ^ | $25$ | $\\sum c\\leq   10^5$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2016] 网格", "background": "", "description": "跳蚤国王和蛐蛐国王在玩一个游戏。\n\n他们在一个 $n$ 行 $m$ 列的网格上排兵布阵。其中的 $c$ 个格子中 $(0 \\leq c \\leq n\\cdot m)$，每个格子有一只蛐蛐，其余的格子中，每个格子有一只跳蚤。\n\n我们称占据的格子有公共边的两只跳蚤是相邻的。\n\n我们称两只跳蚤是连通的，当且仅当这两只跳蚤相邻，或存在另一只跳蚤与这两只跳蚤都连通。\n\n现在，蛐蛐国王希望，将某些（零个，一个或多个）跳蚤替换成蛐蛐，使得在此之后存在至少两只跳蚤不连通。\n\n例如：图 $1$ 描述了一个 $n=4$，$m=4$，$c=2$ 的情况。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/96tey4uv.png)\n\n这种情况下蛐蛐国王可以通过将第二行第二列，和第三行第三列的两只跳蚤替换为蛐蛐，从而达成他的希望，如右图所示。并且，不存在更优的方案，但是可能存在其他替换两只跳蚤的方案。\n\n你需要首先判断蛐蛐国王的希望能否被达成。如果能够达成，你还需要最小化被替换的跳蚤的个数。", "inputFormat": "每个输入文件包含多组数据。\n\n输入文件的第一行只有一个整数 $T$，表示数据的组数。\n\n接下来依次输入 $T$ 组数据，每组数据的第一行包含三个整数 $n, m, c$。\n\n接下来 $c$ 行，每行包含两个整数 $x, y$ 表示第 $x$ 行，第 $y$ 列的格子被一个蛐蛐占据。每一组数据当中，同一个蛐蛐不会被多次描述。", "outputFormat": "对于每一组数据依次输出一行答案。\n\n如果这组数据中，蛐蛐国王的希望不能被达成，输出 $-1$。否则，输出被替换的跳蚤的个数的最小值。", "hint": "### 样例解释\n\n第一组数据就是问题描述中的例子。\n\n对于第二组数据，可以将第二行第二列的一只跳蚤替换为蛐蛐，从而使得存在两只跳蚤不连通，并且不存在更优的方案。\n\n对于第三组数据，最初已经存在两只跳蚤不连通，故不需要再进行替换。\n\n对于第四组数据，由于最多只有一只跳蚤，所以无论如何替换都不能存在两只跳蚤不连通。\n\n### 数据范围\n\n对于全部的测试点，保证 $1 \\leq T \\leq 20$。我们记 $\\sum c$ 为某个测试点中，其 $T$ 组输入数据的所有 $c$ 的总和。对于所有的测试点，$\\sum c \\leq 10^5$。\n\n对于全部的数据，满足 $1 \\leq n,m \\leq 10^9$，$0 \\leq c \\leq n \\times m$，$1 \\leq x \\leq n, 1 \\leq y \\leq m$。\n\n每个测试点的详细数据范围见下表。表中的 $n,m,c$ 均是对于单个输入数据（而非测试点）而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件；而 $\\sum c$是对于单个测试点而言的。为了方便阅读，“测试点”一列被放到了表格的中间而不是左边。 \n\n| $n,m$ | 测试点 | $c$ |\n| :----------: | :----------: | :----------: |\n| $n\\times m\\leq 4$ | $1$ | $c\\leq n\\times m$ |\n| $n\\times m\\leq 8$ | $2$ | ^ |\n| $n\\times m\\leq 15$ | $3$ | ^ |\n| $n\\times m\\leq 30$ |  $4$| ^ |\n| $n\\times m\\leq 100$ | $5$ | ^ |\n| $n\\times m\\leq 300$ | $6$ | ^ |\n| $n\\times m\\leq 10^3$ | $7$ | ^ |\n| $n\\times m\\leq 2\\times 10^4$ | $8$ | $c\\leq 5$ |\n| ^ | $9$ | $c\\leq 15$ |\n| ^ | $10$ | $c\\leq 30$ |\n| $n,m\\leq 2\\times 10^4,n\\times m\\leq2\\times 10^4$ | $11$ | $\\sum c\\leq 2\\times 10^4$ |\n| $n,m\\leq 2\\times 10^4,n\\times m\\leq10^5$  | $12$ | ^ |\n| $n,m\\leq 2\\times 10^4,n\\times m\\leq3\\times 10^5$ | $13$ | ^ |\n| $n,m\\leq 2\\times 10^4,n\\times m\\leq10^6$ | $14$ | ^ |\n| $n,m\\leq 2\\times 10^4,n\\times m\\leq 10^9$ | $15$ | ^ |\n| $n,m\\leq 10^5$ | $16$ | $\\sum c\\leq 10^5$ |\n| $n,m\\leq 10^9$ | $17$ | $c=0$ |\n| ^ | $18$ | $c\\leq 1$ |\n| ^ | $19$ | $c\\leq 2$ |\n| ^ | $20$ | $c\\leq 3$ |\n| ^ | $21$ | $c\\leq 10$ |\n| ^ | $22$ | $c\\leq 30$ |\n| ^ | $23$ | $c\\leq 300$ |\n| ^ | $24$ | $\\sum c\\leq 2 \\times 10^4$ |\n| ^ | $25$ | $\\sum c\\leq   10^5$ |", "locale": "zh-CN"}}}
{"pid": "P1174", "type": "P", "difficulty": 5, "samples": [["3 4 2\n9 N 5 N 1 N 8 N\n5 N 5 Y 5 N 5 N\n6 N 2 N 4 N 3 N", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP"], "title": "打砖块", "background": "", "description": "小红很喜欢玩一个叫打砖块的游戏，这个游戏的规则如下：\n\n在刚开始的时候，有 $n$ 行 $m$ 列的砖块，小红有 $k$ 发子弹。小红每次可以用一发子弹，打碎某一列当前处于这一列最下面的那块砖，并且得到相应的得分。（如图所示）\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/twgirdp6.png)\n\n某些砖块在打碎以后，还可能将得到一发子弹的奖励。最后当所有的砖块都打碎了，或者小红没有子弹了，游戏结束。\n\n小红在游戏开始之前，就已经知道每一块砖在打碎以后的得分，并且知道能不能得到一发奖励的子弹。小红想知道在这次游戏中她可能的最大得分，可是这个问题对于她来说太难了，你能帮帮她吗？\n", "inputFormat": "第一行有 $3$ 个正整数，$n,m,k$。表示开始的时候，有 $n$ 行 $m$ 列的砖块，小红有 $k$ 发子弹。\n\n接下来有 $n$ 行，每行的格式如下：  \n\n$f_1~c_1~f_2~c_2~f_3~c_3\\cdots f_m~c_m$\n\n其中 $f_i$ 为正整数，表示这一行的第 $i$ 列的砖，在打碎以后的得分。$c_i$ 为一个字符，只有两种可能，`Y` 或者 `N`。`Y` 表示有一发奖励的子弹，`N` 表示没有。\n\n所有的数与字符之间用一个空格隔开，行末没有多余的空格。\n", "outputFormat": "仅一个正整数，表示最大的得分。\n", "hint": "对于 $20\\%$ 的数据，满足 $1  \\le n,m  \\le 5$，$1  \\le k  \\le 10$，所有的字符 $c$ 都为 `N`。\n\n对于 $50\\%$ 的数据，满足 $1  \\le n,m  \\le 200$，$1  \\le k  \\le 200$，所有的字符 $c$ 都为 `N`。\n\n对于 $100\\%$ 的数据，满足 $1  \\le n,m  \\le 200$，$1  \\le k  \\le 200$，字符 $c$ 可能为 `Y`。\n\n对于 $100\\%$ 的数据，所有的 $f$ 值满足 $1  \\le f  \\le 10000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Brick Breaker", "background": "", "description": "Xiaohong really likes to play a game called Brick Breaker. The rules are as follows:\n\nAt the beginning, there are $n$ rows and $m$ columns of bricks, and Xiaohong has $k$ bullets. Each time, she can spend one bullet to break the brick that is currently at the bottom of some chosen column, and gain the corresponding score (as shown in the figure).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/twgirdp6.png)\n\nSome bricks, after being broken, may also award one bonus bullet. The game ends when all bricks are broken or when Xiaohong has no bullets left.\n\nBefore the game starts, Xiaohong already knows the score obtained by breaking each brick and whether it awards a bonus bullet. She wants to know the maximum possible total score she can achieve in this game, but this problem is too difficult for her. Can you help her?", "inputFormat": "The first line contains 3 positive integers, $n,m,k$. They indicate that initially there are $n$ rows and $m$ columns of bricks, and Xiaohong has $k$ bullets.\n\nNext there are $n$ lines, each in the following format:  \n$f_1~c_1~f_2~c_2~f_3~c_3\\cdots f_m~c_m$\n\nHere $f_i$ is a positive integer, denoting the score of the brick in row $i$ and the chosen column after it is broken. $c_i$ is a character with only two possibilities, `Y` or `N`. `Y` indicates a bonus bullet is awarded, and `N` indicates none.\n\nAll numbers and characters are separated by a single space, and there are no extra spaces at the end of a line.", "outputFormat": "Output a single positive integer, the maximum total score.", "hint": "For 20% of testdata, $1 \\le n,m \\le 5$, $1 \\le k \\le 10$, and all characters $c$ are `N`.\n\nFor 50% of testdata, $1 \\le n,m \\le 200$, $1 \\le k \\le 200$, and all characters $c$ are `N`.\n\nFor 100% of testdata, $1 \\le n,m \\le 200$, $1 \\le k \\le 200$, and characters $c$ may be `Y`.\n\nFor 100% of testdata, all $f$ satisfy $1 \\le f \\le 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "打砖块", "background": "", "description": "小红很喜欢玩一个叫打砖块的游戏，这个游戏的规则如下：\n\n在刚开始的时候，有 $n$ 行 $m$ 列的砖块，小红有 $k$ 发子弹。小红每次可以用一发子弹，打碎某一列当前处于这一列最下面的那块砖，并且得到相应的得分。（如图所示）\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/twgirdp6.png)\n\n某些砖块在打碎以后，还可能将得到一发子弹的奖励。最后当所有的砖块都打碎了，或者小红没有子弹了，游戏结束。\n\n小红在游戏开始之前，就已经知道每一块砖在打碎以后的得分，并且知道能不能得到一发奖励的子弹。小红想知道在这次游戏中她可能的最大得分，可是这个问题对于她来说太难了，你能帮帮她吗？\n", "inputFormat": "第一行有 $3$ 个正整数，$n,m,k$。表示开始的时候，有 $n$ 行 $m$ 列的砖块，小红有 $k$ 发子弹。\n\n接下来有 $n$ 行，每行的格式如下：  \n\n$f_1~c_1~f_2~c_2~f_3~c_3\\cdots f_m~c_m$\n\n其中 $f_i$ 为正整数，表示这一行的第 $i$ 列的砖，在打碎以后的得分。$c_i$ 为一个字符，只有两种可能，`Y` 或者 `N`。`Y` 表示有一发奖励的子弹，`N` 表示没有。\n\n所有的数与字符之间用一个空格隔开，行末没有多余的空格。\n", "outputFormat": "仅一个正整数，表示最大的得分。\n", "hint": "对于 $20\\%$ 的数据，满足 $1  \\le n,m  \\le 5$，$1  \\le k  \\le 10$，所有的字符 $c$ 都为 `N`。\n\n对于 $50\\%$ 的数据，满足 $1  \\le n,m  \\le 200$，$1  \\le k  \\le 200$，所有的字符 $c$ 都为 `N`。\n\n对于 $100\\%$ 的数据，满足 $1  \\le n,m  \\le 200$，$1  \\le k  \\le 200$，字符 $c$ 可能为 `Y`。\n\n对于 $100\\%$ 的数据，所有的 $f$ 值满足 $1  \\le f  \\le 10000$。\n", "locale": "zh-CN"}}}
{"pid": "P1175", "type": "P", "difficulty": 4, "samples": [["8-(3+2*6)/5+4\n", "8 3 2 6 * + 5 / - 4 + \n8 3 12 + 5 / - 4 + \n8 15 5 / - 4 + \n8 3 - 4 + \n5 4 + \n9\n"], ["2^2^3\n", "2 2 3 ^ ^\n2 8 ^\n256\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "字符串", "线性数据结构", "栈"], "title": "表达式的转换", "background": "", "description": "平常我们书写的表达式称为中缀表达式，因为它将运算符放在两个操作数中间，许多情况下为了确定运算顺序，括号是不可少的，而后缀表达式就不必用括号了。\n\n后缀标记法：书写表达式时采用运算紧跟在两个操作数之后，从而实现了无括号处理和优先级处理，使计算机的处理规则简化为：从左到右顺序完成计算，并用结果取而代之。\n\n例如：`8-(3+2*6)/5+4` 可以写为：`8 3 2 6 * + 5 / - 4 +`\n\n其计算步骤为：\n\n```\n8 3 2 6 * + 5 / - 4 +\n8 3 12 + 5 / - 4 +\n8 15 5 / - 4 +\n8 3 - 4 +\n5 4 +\n9\n```\n\n编写一个程序，完成这个转换，要求输出的每一个数据间都留一个空格。", "inputFormat": "就一行，是一个中缀表达式。输入的符号中只有这些基本符号 `0123456789+-*/^()`，并且不会出现形如 `2*-3` 的格式。\n\n表达式中的基本数字也都是一位的，不会出现形如 `12` 形式的数字。\n\n所输入的字符串不要判错。\n", "outputFormat": "若干个后缀表达式，第 $i + 1$ 行比第 $i$ 行少一个运算符和一个操作数，最后一行只有一个数字，表示运算结果。\n", "hint": "运算的结果可能为负数，`/` 以整除运算。并且中间每一步都不会超过 $2^{31}$。字符串长度不超过 $100$。\n\n注意乘方运算 `^` 是从右向左结合的，即 `2 ^ 2 ^ 3` 为 `2 ^ (2 ^ 3)`，后缀表达式为 `2 2 3 ^ ^`。\n\n其他同优先级的运算是从左向右结合的，即 `4 / 2 / 2 * 2` 为 `((4 / 2) / 2) * 2`，后缀表达式为 `4 2 / 2 / 2 *`。\n\n保证不会出现计算乘方时幂次为负数的情况，故保证一切中间结果为整数。", "locale": "zh-CN", "translations": {"en": {"title": "Expression Conversion", "background": "", "description": "The expressions we usually write are called infix expressions because they place the operator between two operands. In many cases, parentheses are necessary to determine the order of operations. Postfix expressions, however, do not require parentheses.\n\nPostfix notation: when writing an expression, the operator is written immediately after its two operands. This eliminates the need for parentheses and handles precedence, simplifying the computer’s processing rule to: compute from left to right in order, and replace the operands with the result.\n\nFor example: `8-(3+2*6)/5+4` can be written as: `8 3 2 6 * + 5 / - 4 +`.\n\nThe calculation steps are:\n\n```\n8 3 2 6 * + 5 / - 4 +\n8 3 12 + 5 / - 4 +\n8 15 5 / - 4 +\n8 3 - 4 +\n5 4 +\n9\n```\n\nWrite a program to complete this conversion. In the output, leave exactly one space between every token.", "inputFormat": "A single line containing an infix expression. The input symbols include only these basic symbols: `0123456789+-*/^()`, and formats like `2*-3` will not appear.\n\nAll numbers in the expression are single-digit; forms like `12` will not appear.\n\nDo not perform error checking on the input string.", "outputFormat": "Several lines of postfix expressions. The $(i + 1)$-th line contains one fewer operator and one fewer operand than the $i$-th line. The last line contains only a single number, which is the result.", "hint": "The result may be negative, and `/` means integer division. Also, every intermediate value will not exceed $2^{31}$. The string length does not exceed 100.\n\nNote that exponentiation `^` is right-associative, i.e., `2 ^ 2 ^ 3` means `2 ^ (2 ^ 3)`, and the postfix form is `2 2 3 ^ ^`.\n\nOther operators of the same precedence are left-associative, i.e., `4 / 2 / 2 * 2` means `((4 / 2) / 2) * 2`, and the postfix form is `4 2 / 2 / 2 *`.\n\nIt is guaranteed that the exponent in exponentiation will not be negative, so all intermediate results are integers.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "表达式的转换", "background": "", "description": "平常我们书写的表达式称为中缀表达式，因为它将运算符放在两个操作数中间，许多情况下为了确定运算顺序，括号是不可少的，而后缀表达式就不必用括号了。\n\n后缀标记法：书写表达式时采用运算紧跟在两个操作数之后，从而实现了无括号处理和优先级处理，使计算机的处理规则简化为：从左到右顺序完成计算，并用结果取而代之。\n\n例如：`8-(3+2*6)/5+4` 可以写为：`8 3 2 6 * + 5 / - 4 +`\n\n其计算步骤为：\n\n```\n8 3 2 6 * + 5 / - 4 +\n8 3 12 + 5 / - 4 +\n8 15 5 / - 4 +\n8 3 - 4 +\n5 4 +\n9\n```\n\n编写一个程序，完成这个转换，要求输出的每一个数据间都留一个空格。", "inputFormat": "就一行，是一个中缀表达式。输入的符号中只有这些基本符号 `0123456789+-*/^()`，并且不会出现形如 `2*-3` 的格式。\n\n表达式中的基本数字也都是一位的，不会出现形如 `12` 形式的数字。\n\n所输入的字符串不要判错。\n", "outputFormat": "若干个后缀表达式，第 $i + 1$ 行比第 $i$ 行少一个运算符和一个操作数，最后一行只有一个数字，表示运算结果。\n", "hint": "运算的结果可能为负数，`/` 以整除运算。并且中间每一步都不会超过 $2^{31}$。字符串长度不超过 $100$。\n\n注意乘方运算 `^` 是从右向左结合的，即 `2 ^ 2 ^ 3` 为 `2 ^ (2 ^ 3)`，后缀表达式为 `2 2 3 ^ ^`。\n\n其他同优先级的运算是从左向右结合的，即 `4 / 2 / 2 * 2` 为 `((4 / 2) / 2) * 2`，后缀表达式为 `4 2 / 2 / 2 *`。\n\n保证不会出现计算乘方时幂次为负数的情况，故保证一切中间结果为整数。", "locale": "zh-CN"}}}
{"pid": "P1176", "type": "P", "difficulty": 2, "samples": [["3 1\n3 1", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "线性递推"], "title": "路径计数2", "background": "", "description": "一个 $N \\times N$ 的网格，你一开始在 $(1,1)$，即左上角。每次只能移动到下方相邻的格子或者右方相邻的格子，问到达 $(N,N)$，即右下角有多少种方法。\n\n但是这个问题太简单了，所以现在有 $M$ 个格子上有障碍，即不能走到这 $M$ 个格子上。\n", "inputFormat": "输入文件第 $1$ 行包含两个非负整数 $N,M$，表示了网格的边长与障碍数。\n\n接下来 $M$ 行，每行两个不大于 $N$ 的正整数 $x, y$。表示坐标 $(x, y)$ 上有障碍不能通过，且有 $1≤x, y≤n$，且 $x, y$ 至少有一个大于 $1$，并请注意障碍坐标有可能相同。\n", "outputFormat": "一个非负整数，为答案 $\\bmod 100003$ 后的结果。\n", "hint": "对于 $20\\%$ 的数据，有$N≤3$；\n\n对于 $40\\%$ 的数据，有$N≤100$；\n\n对于 $40\\%$ 的数据，有$M=0$；\n\n对于 $100\\%$ 的数据，有$N≤1000,M≤100000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Path Counting 2", "background": "", "description": "On an $N \\times N$ grid, you start at $(1, 1)$, the top-left corner. Each move, you may only go to the adjacent cell below or to the adjacent cell to the right. How many ways are there to reach $(N, N)$, the bottom-right corner?\n\nHowever, this problem is too simple, so now there are $M$ cells with obstacles, meaning you cannot step on these $M$ cells.", "inputFormat": "The first line contains two non-negative integers $N, M$, representing the side length of the grid and the number of obstacles.\n\nThen follow $M$ lines, each containing two positive integers $x, y$ that are not greater than $N$. This means there is an obstacle at coordinate $(x, y)$ that cannot be passed, with $1≤x, y≤n$, and at least one of $x, y$ is greater than $1$. Note that obstacle coordinates may be the same.", "outputFormat": "A non-negative integer, which is the result of the answer $\\bmod 100003$.", "hint": "For $20\\%$ of the testdata, $N≤3$.\n\nFor $40\\%$ of the testdata, $N≤100$.\n\nFor $40\\%$ of the testdata, $M=0$.\n\nFor $100\\%$ of the testdata, $N≤1000,M≤100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "路径计数2", "background": "", "description": "一个 $N \\times N$ 的网格，你一开始在 $(1,1)$，即左上角。每次只能移动到下方相邻的格子或者右方相邻的格子，问到达 $(N,N)$，即右下角有多少种方法。\n\n但是这个问题太简单了，所以现在有 $M$ 个格子上有障碍，即不能走到这 $M$ 个格子上。\n", "inputFormat": "输入文件第 $1$ 行包含两个非负整数 $N,M$，表示了网格的边长与障碍数。\n\n接下来 $M$ 行，每行两个不大于 $N$ 的正整数 $x, y$。表示坐标 $(x, y)$ 上有障碍不能通过，且有 $1≤x, y≤n$，且 $x, y$ 至少有一个大于 $1$，并请注意障碍坐标有可能相同。\n", "outputFormat": "一个非负整数，为答案 $\\bmod 100003$ 后的结果。\n", "hint": "对于 $20\\%$ 的数据，有$N≤3$；\n\n对于 $40\\%$ 的数据，有$N≤100$；\n\n对于 $40\\%$ 的数据，有$M=0$；\n\n对于 $100\\%$ 的数据，有$N≤1000,M≤100000$。\n", "locale": "zh-CN"}}}
{"pid": "P1177", "type": "P", "difficulty": 2, "samples": [["5\n4 2 4 5 1", "1 2 4 4 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144]}, "tags": ["排序", "模板题"], "title": "【模板】排序", "background": "", "description": "将读入的 $N$ 个数从小到大排序后输出。", "inputFormat": "第一行为一个正整数 $N$。\n\n第二行包含 $N$ 个空格隔开的正整数 $a_i$，为你需要进行排序的数。\n", "outputFormat": "将给定的 $N$ 个数从小到大输出，数之间空格隔开，行末换行且无空格。\n", "hint": "对于 $20\\%$ 的数据，有 $1 \\leq N \\leq 10^3$；\n\n对于 $100\\%$ 的数据，有 $1 \\leq N \\leq 10^5$，$1 \\le a_i \\le 10^9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Sorting", "background": null, "description": "Sort the $N$ input numbers in ascending order and output them.", "inputFormat": "The first line contains a positive integer $N$.\n\nThe second line contains $N$ space-separated positive integers $a_i$, which are the numbers you need to sort.", "outputFormat": "Output the given $N$ numbers in ascending order, separated by spaces. The line should end with a newline character and have no trailing space.", "hint": "For $20\\%$ of the testdata, $1 \\leq N \\leq 10^3$.\n\nFor $100\\%$ of the testdata, $1 \\leq N \\leq 10^5$, $1 \\le a_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】排序", "background": "", "description": "将读入的 $N$ 个数从小到大排序后输出。", "inputFormat": "第一行为一个正整数 $N$。\n\n第二行包含 $N$ 个空格隔开的正整数 $a_i$，为你需要进行排序的数。\n", "outputFormat": "将给定的 $N$ 个数从小到大输出，数之间空格隔开，行末换行且无空格。\n", "hint": "对于 $20\\%$ 的数据，有 $1 \\leq N \\leq 10^3$；\n\n对于 $100\\%$ 的数据，有 $1 \\leq N \\leq 10^5$，$1 \\le a_i \\le 10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P1178", "type": "P", "difficulty": 2, "samples": [["2\n3 8\n12 2", "63266"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "到天宫做客", "background": "", "description": "有一天，我做了个梦，梦见我很荣幸的接到了猪八戒的邀请，到天宫陪他吃酒。我犹豫了。天上一日，人间一年啊！当然，我是个闲人，一年之中也没有多少时日是必须在人间的，因此，我希望选一个最长的空闲时间段，使我在天上待的时间尽量长。记住，今年是 $4000$ 年。天上一天也是 $24$ 小时，每小时 $60$ 分，每分 $60$ 秒。\n", "inputFormat": "第一行是一个非负整数 $N$，表示 $4000$ 年中必须呆在人间的天数。  \n\n以下共 $N$ 行，每行两个用空格隔开的正整数，即日期（月，日），输入文件保证无错误，日期无重复。\n", "outputFormat": "一个非负整数，即在天上的时间（四舍五入精确到 $1$ 秒）。\n", "hint": "### 样例解释（2023.9.29 新增）\n\n$4000$ 年是闰年，共有 $366$ 天，其中二月份有 $29$ 天。\n\n最长连续空闲时间是从 $3$ 月 $9$ 日至 $12$ 月 $1$ 日一共 $268$ 天。对应着天上的 $86400\\times 268 \\div 366=63265.57\\approx 63266$ 秒。", "locale": "zh-CN", "translations": {"en": {"title": "Visiting the Heavenly Palace as a Guest", "background": "", "description": "One day I had a dream. I was honored to receive an invitation from Zhu Bajie to go to the Heavenly Palace and drink with him. I hesitated. One day in heaven equals one year on Earth! Of course, I am an idle person, and there are not many days in the year when I must stay on Earth. Therefore, I want to choose the longest continuous free period so that I can stay in heaven as long as possible. Remember, this year is the year $4000$. One day in heaven is also 24 hours, each hour 60 minutes, and each minute 60 seconds.", "inputFormat": "The first line contains a non-negative integer $N$, the number of days in the year $4000$ when I must stay on Earth.  \nThe next $N$ lines each contain two positive integers separated by a space, representing a date (month, day). The input is guaranteed to be valid, and dates are not repeated.", "outputFormat": "A non-negative integer: the time spent in heaven (rounded to the nearest $1$ second).", "hint": "### Sample Explanation (added on 2023.9.29)\n\nThe year $4000$ is a leap year with $366$ days, and February has $29$ days.\n\nThe longest continuous free period is from March $9$ to December $1$, a total of $268$ days. This corresponds to $86400\\times 268 \\div 366=63265.57\\approx 63266$ seconds.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "到天宫做客", "background": "", "description": "有一天，我做了个梦，梦见我很荣幸的接到了猪八戒的邀请，到天宫陪他吃酒。我犹豫了。天上一日，人间一年啊！当然，我是个闲人，一年之中也没有多少时日是必须在人间的，因此，我希望选一个最长的空闲时间段，使我在天上待的时间尽量长。记住，今年是 $4000$ 年。天上一天也是 $24$ 小时，每小时 $60$ 分，每分 $60$ 秒。\n", "inputFormat": "第一行是一个非负整数 $N$，表示 $4000$ 年中必须呆在人间的天数。  \n\n以下共 $N$ 行，每行两个用空格隔开的正整数，即日期（月，日），输入文件保证无错误，日期无重复。\n", "outputFormat": "一个非负整数，即在天上的时间（四舍五入精确到 $1$ 秒）。\n", "hint": "### 样例解释（2023.9.29 新增）\n\n$4000$ 年是闰年，共有 $366$ 天，其中二月份有 $29$ 天。\n\n最长连续空闲时间是从 $3$ 月 $9$ 日至 $12$ 月 $1$ 日一共 $268$ 天。对应着天上的 $86400\\times 268 \\div 366=63265.57\\approx 63266$ 秒。", "locale": "zh-CN"}}}
{"pid": "P1179", "type": "P", "difficulty": 1, "samples": [["2 22\n", "6\n"], ["2 100", "20"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2010", "NOIP 普及组"], "title": "[NOIP 2010 普及组] 数字统计", "background": "", "description": "请统计某个给定范围 $[L, R]$ 的所有整数中，数字 $2$ 出现的次数。\n\n比如给定范围 $[2, 22]$，数字 $2$ 在数 $2$ 中出现了 $1$ 次，在数 $12$ 中出现 $1$ 次，在数 $20$ 中出现 $1$ 次，在数 $21$ 中出现 $1$ 次，在数 $22$ 中出现 $2$ 次，所以数字 $2$ 在该范围内一共出现了 $6$ 次。", "inputFormat": "$2$ 个正整数 $L$ 和 $R$，之间用一个空格隔开。\n", "outputFormat": "数字 $2$ 出现的次数。\n", "hint": "$1 ≤ L ≤R≤ 100000$。\n\nNOIP2010 普及组 第一题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2010 Junior] Digit Statistics", "background": "", "description": "Count how many times the digit $2$ appears among all integers in the given range $[L, R]$.\n\nFor example, for the range $[2, 22]$, the digit $2$ appears 1 time in the number 2, 1 time in 12, 1 time in 20, 1 time in 21, and 2 times in 22, so the digit $2$ appears a total of 6 times in this range.", "inputFormat": "$2$ positive integers $L$ and $R$, separated by a space.", "outputFormat": "The number of occurrences of digit $2$.", "hint": "Constraints: $1 ≤ L ≤ R ≤ 100000$.\n\nNOIP 2010 Junior Problem 1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2010 普及组] 数字统计", "background": "", "description": "请统计某个给定范围 $[L, R]$ 的所有整数中，数字 $2$ 出现的次数。\n\n比如给定范围 $[2, 22]$，数字 $2$ 在数 $2$ 中出现了 $1$ 次，在数 $12$ 中出现 $1$ 次，在数 $20$ 中出现 $1$ 次，在数 $21$ 中出现 $1$ 次，在数 $22$ 中出现 $2$ 次，所以数字 $2$ 在该范围内一共出现了 $6$ 次。", "inputFormat": "$2$ 个正整数 $L$ 和 $R$，之间用一个空格隔开。\n", "outputFormat": "数字 $2$ 出现的次数。\n", "hint": "$1 ≤ L ≤R≤ 100000$。\n\nNOIP2010 普及组 第一题", "locale": "zh-CN"}}}
{"pid": "P1180", "type": "P", "difficulty": 3, "samples": [["600\n40  8.5  128  3\n200  3.52\n350  3.45\n500  365", "13133.2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索"], "title": "驾车旅游", "background": "", "description": "如今许多普通百姓家有了私家车，一些人喜爱自己驾车从一个城市到另一个城市旅游。自己驾车旅游时总会碰到加油和吃饭的问题，在出发之前，驾车人总要想方设法得到从一个城市到另一个城市路线上的加油站的列表，列表中包括了所有加油站的位置及其每升的油价（如 $3.25$ 元/L）。驾车者一般都有以下的习惯：\n\n1. 除非汽车无法用油箱里的汽油达到下一个加油站或目的地，在油箱里还有不少于最大容量一半的汽油时，驾驶员从不在加油站停下来；\n2. 在第一个停下的加油站总是将油箱加满；\n3. 在加油站加油的同时，买快餐等吃的东西花去 $20$ 元。\n4. 从起始城市出发时油箱总是满的。\n5. 加油站付钱总是精确到 $0.1$ 元（四舍五入）。\n6. 驾车者都知道自己的汽车每升汽油能够行驶的里程数。\n\n现在要你帮忙做的就是编写一个程序，计算出驾车从一个城市到另一个城市的旅游在加油和吃饭方面最少的费用。", "inputFormat": "第一行是一个实数，是从出发地到目的地的距离（单位：km）。\n\n第二行是三个实数和一个整数，其中第一个实数是汽车油箱的最大容量（单位：L)；第二个实数是汽车每升油能行驶的公里数；第三个实数是汽车在出发地加满油箱时的费用（单位：元）；一个整数是 $1$ 到 $50$ 间的数，表示从出发地到目的地线路上加油站的数目。\n\n接下来 $n$ 行都是两个实数，第一个数表示从出发地到某一个加油站的距离（单位：km）；第二个实数表示该加油站汽油的价格(单位：元)。\n\n数据项中的每个数据都是正确的，不需判错。一条线路上的加油站根据其到出发地的距离递增排列并且都不会大于从出发地到目的地的距离。", "outputFormat": "输出一个实数，即精确到 $0.1$ 元的最小的加油和吃饭费用。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Self-Driving Tour", "background": "", "description": "Nowadays, many ordinary families own private cars, and some people like to drive themselves from one city to another for travel. When traveling by car, you will always encounter the problems of refueling and eating. Before departure, drivers try to obtain a list of gas stations along the route from one city to another. The list includes the location of every gas station and its price per liter (e.g., $3.25$ yuan/L). Drivers generally have the following habits:\n\n1. The driver never stops at a gas station if there is at least half of the maximum tank capacity left in the tank, unless the car cannot reach the next gas station or the destination with the fuel currently in the tank.\n2. At the first gas station where they stop, they always fill the tank to full.\n3. While refueling at a gas station, they also buy fast food and other snacks, spending 20 yuan.\n4. The tank is always full when departing from the starting city.\n5. Payments at gas stations are always precise to $0.1$ yuan (rounded).\n6. Drivers know how many kilometers their car can travel per liter of gasoline.\n\nYour task is to write a program to compute the minimum total cost for refueling and food on a self-driving trip from one city to another.", "inputFormat": "- The first line is a real number: the distance from the starting point to the destination (unit: km).\n- The second line contains three real numbers and one integer:\n  1) the maximum capacity of the fuel tank (unit: L);\n  2) the number of kilometers the car can travel per liter (unit: km/L);\n  3) the cost when filling the tank to full at the starting city (unit: yuan);\n  4) an integer between $1$ and $50$, indicating the number of gas stations along the route.\n- The next n lines each contain two real numbers: the distance of a gas station from the starting point (unit: km), and the price of gasoline at that station (unit: yuan).\n\nAll data items are valid; no error checking is required. Gas stations on a route are sorted in increasing order by their distance from the starting point, and none of them is farther than the destination.", "outputFormat": "Output a single real number: the minimum total cost for refueling and food, accurate to $0.1$ yuan.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "驾车旅游", "background": "", "description": "如今许多普通百姓家有了私家车，一些人喜爱自己驾车从一个城市到另一个城市旅游。自己驾车旅游时总会碰到加油和吃饭的问题，在出发之前，驾车人总要想方设法得到从一个城市到另一个城市路线上的加油站的列表，列表中包括了所有加油站的位置及其每升的油价（如 $3.25$ 元/L）。驾车者一般都有以下的习惯：\n\n1. 除非汽车无法用油箱里的汽油达到下一个加油站或目的地，在油箱里还有不少于最大容量一半的汽油时，驾驶员从不在加油站停下来；\n2. 在第一个停下的加油站总是将油箱加满；\n3. 在加油站加油的同时，买快餐等吃的东西花去 $20$ 元。\n4. 从起始城市出发时油箱总是满的。\n5. 加油站付钱总是精确到 $0.1$ 元（四舍五入）。\n6. 驾车者都知道自己的汽车每升汽油能够行驶的里程数。\n\n现在要你帮忙做的就是编写一个程序，计算出驾车从一个城市到另一个城市的旅游在加油和吃饭方面最少的费用。", "inputFormat": "第一行是一个实数，是从出发地到目的地的距离（单位：km）。\n\n第二行是三个实数和一个整数，其中第一个实数是汽车油箱的最大容量（单位：L)；第二个实数是汽车每升油能行驶的公里数；第三个实数是汽车在出发地加满油箱时的费用（单位：元）；一个整数是 $1$ 到 $50$ 间的数，表示从出发地到目的地线路上加油站的数目。\n\n接下来 $n$ 行都是两个实数，第一个数表示从出发地到某一个加油站的距离（单位：km）；第二个实数表示该加油站汽油的价格(单位：元)。\n\n数据项中的每个数据都是正确的，不需判错。一条线路上的加油站根据其到出发地的距离递增排列并且都不会大于从出发地到目的地的距离。", "outputFormat": "输出一个实数，即精确到 $0.1$ 元的最小的加油和吃饭费用。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1181", "type": "P", "difficulty": 2, "samples": [["5 6\n4 2 4 5 1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心"], "title": "数列分段 Section I", "background": null, "description": "对于给定的一个长度为 $N$ 的正整数数列 $A_i$，现要将其分成**连续**的若干段，并且每段和不超过 $M$（可以等于 $M$），问最少能将其分成多少段使得满足要求。", "inputFormat": "第1行包含两个正整数 $N,M$，表示了数列 $A_i$ 的长度与每段和的最大值，第 $2$ 行包含 $N$ 个空格隔开的非负整数 $A_i$，如题目所述。", "outputFormat": "一个正整数，输出最少划分的段数。", "hint": "对于 $20\\%$ 的数据，有 $N≤10$；\n\n对于 $40\\%$ 的数据，有 $N≤1000$；\n\n对于 $100\\%$ 的数据，有 $N≤10^5,M≤10^9$，$M$ 大于所有数的最大值，$A_i$ 之和不超过 $10^9$。\n\n\n将数列如下划分：\n\n$[4][2 4][5 1]$\n\n第一段和为 $4$，第 $2$ 段和为 $6$，第 $3$ 段和为 $6$ 均满足和不超过 $M=6$，并可以证明 $3$ 是最少划分的段数。", "locale": "zh-CN", "translations": {"en": {"title": "Sequence Segmentation Section I", "background": "", "description": "Given a sequence $A_i$ of length $N$ consisting of non-negative integers, split it into several consecutive segments such that the sum of each segment does not exceed $M$ (it can be equal to $M$). Find the minimum number of segments needed to meet the requirement.", "inputFormat": "The first line contains two positive integers $N, M$, representing the length of the sequence $A_i$ and the maximum allowed sum of each segment. The second line contains $N$ space-separated non-negative integers $A_i$, as described.", "outputFormat": "Output a single integer: the minimum number of segments.", "hint": "For $20\\%$ of the testdata, there is $N≤10$.\n\nFor $40\\%$ of the testdata, there is $N≤1000$.\n\nFor $100\\%$ of the testdata, there are $N≤100000, M≤10^9$, $M$ is greater than the maximum element, and the sum of $A_i$ does not exceed $10^9$.\n\nSplit the sequence as follows:\n\n$[4][2 4][5 1]$\n\nThe sum of the first segment is $4$, the sum of the $2$nd segment is $6$, and the sum of the $3$rd segment is $6$, all not exceeding $M=6$. It can be proven that $3$ is the minimum number of segments.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数列分段 Section I", "background": null, "description": "对于给定的一个长度为 $N$ 的正整数数列 $A_i$，现要将其分成**连续**的若干段，并且每段和不超过 $M$（可以等于 $M$），问最少能将其分成多少段使得满足要求。", "inputFormat": "第1行包含两个正整数 $N,M$，表示了数列 $A_i$ 的长度与每段和的最大值，第 $2$ 行包含 $N$ 个空格隔开的非负整数 $A_i$，如题目所述。", "outputFormat": "一个正整数，输出最少划分的段数。", "hint": "对于 $20\\%$ 的数据，有 $N≤10$；\n\n对于 $40\\%$ 的数据，有 $N≤1000$；\n\n对于 $100\\%$ 的数据，有 $N≤10^5,M≤10^9$，$M$ 大于所有数的最大值，$A_i$ 之和不超过 $10^9$。\n\n\n将数列如下划分：\n\n$[4][2 4][5 1]$\n\n第一段和为 $4$，第 $2$ 段和为 $6$，第 $3$ 段和为 $6$ 均满足和不超过 $M=6$，并可以证明 $3$ 是最少划分的段数。", "locale": "zh-CN"}}}
{"pid": "P1182", "type": "P", "difficulty": 3, "samples": [["5 3\n4 2 4 5 1", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "二分", "前缀和"], "title": "数列分段 Section II", "background": "", "description": "对于给定的一个长度为 $N$ 的正整数数列 $A_{1\\sim N}$，现要将其分成 $M$（$M\\leq N$）段，并要求每段连续，且每段和的最大值最小。\n\n关于最大值最小：\n\n例如一数列 $4\\ 2\\ 4\\ 5\\ 1$ 要分成 $3$ 段。\n\n将其如下分段：\n\n$$[4\\ 2][4\\ 5][1]$$\n\n第一段和为 $6$，第 $2$ 段和为 $9$，第 $3$ 段和为 $1$，和最大值为 $9$。\n\n将其如下分段：\n\n$$[4][2\\ 4][5\\ 1]$$\n\n第一段和为 $4$，第 $2$ 段和为 $6$，第 $3$ 段和为 $6$，和最大值为 $6$。\n\n并且无论如何分段，最大值不会小于 $6$。\n\n所以可以得到要将数列 $4\\ 2\\ 4\\ 5\\ 1$ 要分成 $3$ 段，每段和的最大值最小为 $6$。\n", "inputFormat": "第 $1$ 行包含两个正整数 $N,M$。  \n\n第 $2$ 行包含 $N$ 个空格隔开的非负整数 $A_i$，含义如题目所述。\n", "outputFormat": "一个正整数，即每段和最大值最小为多少。\n", "hint": "对于 $20\\%$ 的数据，$N\\leq 10$。\n\n对于 $40\\%$ 的数据，$N\\leq 1000$。\n\n对于 $100\\%$ 的数据，$1\\leq N\\leq 10^5$，$M\\leq N$，$A_i < 10^8$， 答案不超过 $10^9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Sequence Partitioning Section II", "background": "", "description": "Given a sequence of positive integers $A_{1\\sim N}$ of length $N$, you need to partition it into $M$ ($M \\leq N$) contiguous segments, such that the maximum segment sum is minimized.\n\nAbout minimizing the maximum:\n\nFor example, consider the sequence $4\\ 2\\ 4\\ 5\\ 1$ to be divided into $3$ segments.\n\nPartition it as:\n$$[4\\ 2][4\\ 5][1]$$\nThe sum of the first segment is $6$, the sum of the second segment is $9$, the sum of the third segment is $1$, and the maximum of these sums is $9$.\n\nPartition it as:\n$$[4][2\\ 4][5\\ 1]$$\nThe sum of the first segment is $4$, the sum of the second segment is $6$, the sum of the third segment is $6$, and the maximum of these sums is $6$.\n\nMoreover, no matter how you partition it, the maximum will not be smaller than $6$.\n\nTherefore, for the sequence $4\\ 2\\ 4\\ 5\\ 1$ divided into $3$ segments, the minimum possible maximum segment sum is $6$.", "inputFormat": "The first line contains two positive integers $N, M$.\n\nThe second line contains $N$ space-separated non-negative integers $A_i$, as described above.", "outputFormat": "A single positive integer: the minimum possible value of the maximum segment sum.", "hint": "Constraints:\n- For $20\\%$ of the testdata, $N \\leq 10$.\n- For $40\\%$ of the testdata, $N \\leq 1000$.\n- For $100\\%$ of the testdata, $1 \\leq N \\leq 10^5$, $M \\leq N$, $A_i < 10^8$, and the answer does not exceed $10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数列分段 Section II", "background": "", "description": "对于给定的一个长度为 $N$ 的正整数数列 $A_{1\\sim N}$，现要将其分成 $M$（$M\\leq N$）段，并要求每段连续，且每段和的最大值最小。\n\n关于最大值最小：\n\n例如一数列 $4\\ 2\\ 4\\ 5\\ 1$ 要分成 $3$ 段。\n\n将其如下分段：\n\n$$[4\\ 2][4\\ 5][1]$$\n\n第一段和为 $6$，第 $2$ 段和为 $9$，第 $3$ 段和为 $1$，和最大值为 $9$。\n\n将其如下分段：\n\n$$[4][2\\ 4][5\\ 1]$$\n\n第一段和为 $4$，第 $2$ 段和为 $6$，第 $3$ 段和为 $6$，和最大值为 $6$。\n\n并且无论如何分段，最大值不会小于 $6$。\n\n所以可以得到要将数列 $4\\ 2\\ 4\\ 5\\ 1$ 要分成 $3$ 段，每段和的最大值最小为 $6$。\n", "inputFormat": "第 $1$ 行包含两个正整数 $N,M$。  \n\n第 $2$ 行包含 $N$ 个空格隔开的非负整数 $A_i$，含义如题目所述。\n", "outputFormat": "一个正整数，即每段和最大值最小为多少。\n", "hint": "对于 $20\\%$ 的数据，$N\\leq 10$。\n\n对于 $40\\%$ 的数据，$N\\leq 1000$。\n\n对于 $100\\%$ 的数据，$1\\leq N\\leq 10^5$，$M\\leq N$，$A_i < 10^8$， 答案不超过 $10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P1183", "type": "P", "difficulty": 3, "samples": [["10\n0 0\n4 0\n4 1\n3 1\n3 3\n2 3\n2 2\n1 2\n1 3\n0 3", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["计算几何", "叉积"], "title": "多边形的面积", "background": "", "description": "给出一个没有缺口的简单多边形，它的边是垂直或者水平的，要求计算多边形的面积。\n\n多边形被放置在一个 $xOy$ 的笛卡尔平面上，它所有的边都平行于两条坐标轴之一。然后按逆时针方向给出各顶点的坐标值。所有的坐标值都是整数，因此多边形的面积也为整数。\n\n**注意：可能存在连续的三个顶点在一条直线上的情况**。", "inputFormat": "第一行给出多边形的顶点数 $n$ 。\n\n接下来 $n$ 行，每行给出多边形一个顶点的坐标值 $x$ 和 $y$，用空格隔开。\n\n顶点按逆时针方向逐个给出。多边形最后是靠从最后一个顶点到第一个顶点画一条边来封闭的。", "outputFormat": "一行，一个整数，表示多边形的面积。\n", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 100$，$-200 \\le x,y \\le 200$。", "locale": "zh-CN", "translations": {"en": {"title": "Area of a Polygon", "background": "", "description": "Given a simple polygon without holes whose edges are vertical or horizontal, compute the area of the polygon.\n\nThe polygon is placed on an $xOy$ Cartesian plane, and all its edges are parallel to one of the two coordinate axes. The vertex coordinates are given in counterclockwise order. All coordinates are integers, so the area of the polygon is also an integer.\n\nNote: There may be three consecutive vertices that are collinear.", "inputFormat": "The first line contains the number of vertices $n$.\n\nThe next $n$ lines each contain the coordinates $x$ and $y$ of a vertex, separated by a space.\n\nThe vertices are given one by one in counterclockwise order. The polygon is closed by drawing an edge from the last vertex to the first.", "outputFormat": "One line with a single integer, representing the area of the polygon.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 100$, $-200 \\le x, y \\le 200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "多边形的面积", "background": "", "description": "给出一个没有缺口的简单多边形，它的边是垂直或者水平的，要求计算多边形的面积。\n\n多边形被放置在一个 $xOy$ 的笛卡尔平面上，它所有的边都平行于两条坐标轴之一。然后按逆时针方向给出各顶点的坐标值。所有的坐标值都是整数，因此多边形的面积也为整数。\n\n**注意：可能存在连续的三个顶点在一条直线上的情况**。", "inputFormat": "第一行给出多边形的顶点数 $n$ 。\n\n接下来 $n$ 行，每行给出多边形一个顶点的坐标值 $x$ 和 $y$，用空格隔开。\n\n顶点按逆时针方向逐个给出。多边形最后是靠从最后一个顶点到第一个顶点画一条边来封闭的。", "outputFormat": "一行，一个整数，表示多边形的面积。\n", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 100$，$-200 \\le x,y \\le 200$。", "locale": "zh-CN"}}}
{"pid": "P1184", "type": "P", "difficulty": 2, "samples": [["1 2\nWC\nCLASS\nWC\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "洛谷原创", "哈希 hashing"], "title": "高手之在一起", "background": "高手是可以复活的，这点我们大家都知道。", "description": "高手列出了一个详尽的日程表，这次他要追求的则是一个心灵纯洁的小萝莉。他和她都是要上课的，但是也会有时间空闲，于是高手决定无时无刻都要跟着她。为了她，高手决定转学到一年级。\n\n现在高手已经花重金买下了她的日程表，每一天都会有她的行踪。现在列出了高手方便去的地方。其中方便去的地方可以去无限次，不方便去的地方不能去。\n\n一共有 $n$ 个方便去的地点，$m$ 天。高手想知道他在这 $m$ 天中，最多能和她在一起多久。不方便去的地方是不会列出的。", "inputFormat": "第一行两个整数 $n,m$。  \n\n接下来 $n$ 行，每行一个地名，高手方便去的地方。  \n\n接下来 $m$ 行，每行一个地名，她这一天在的地方。\n\n**地名中可能有空格。**", "outputFormat": "一个整数，他们在同一个地方的天数。", "hint": "$1 \\leq m \\leq 10^6$，$1 \\leq n \\leq 20$。", "locale": "zh-CN", "translations": {"en": {"title": "Being Together with the Expert", "background": "An expert can be resurrected; we all know that.", "description": "The expert has drawn up a detailed schedule. This time, he wants to pursue a pure-hearted little girl. Both he and she have classes, but there will also be free time, so the expert decides to follow her at all times. For her, the expert decides to transfer to first grade.\n\nNow the expert has spent a lot of money to buy her schedule, which shows where she will be each day. A list of places convenient for the expert to go is also provided. He can visit convenient places any number of times, while inconvenient places cannot be visited.\n\nThere are $n$ convenient places to go and $m$ days. The expert wants to know the maximum number of days, within these $m$ days, that he can be together with her. Inconvenient places are not listed.", "inputFormat": "The first line contains two integers $n, m$.  \nThen follow $n$ lines, each with the name of a place that is convenient for the expert to go.  \nThen follow $m$ lines, each with the name of the place where she is on that day.\n\n**Place names may contain spaces.**", "outputFormat": "An integer: the number of days they are at the same place.", "hint": "$1 \\leq m \\leq 10^6$, $1 \\leq n \\leq 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "高手之在一起", "background": "高手是可以复活的，这点我们大家都知道。", "description": "高手列出了一个详尽的日程表，这次他要追求的则是一个心灵纯洁的小萝莉。他和她都是要上课的，但是也会有时间空闲，于是高手决定无时无刻都要跟着她。为了她，高手决定转学到一年级。\n\n现在高手已经花重金买下了她的日程表，每一天都会有她的行踪。现在列出了高手方便去的地方。其中方便去的地方可以去无限次，不方便去的地方不能去。\n\n一共有 $n$ 个方便去的地点，$m$ 天。高手想知道他在这 $m$ 天中，最多能和她在一起多久。不方便去的地方是不会列出的。", "inputFormat": "第一行两个整数 $n,m$。  \n\n接下来 $n$ 行，每行一个地名，高手方便去的地方。  \n\n接下来 $m$ 行，每行一个地名，她这一天在的地方。\n\n**地名中可能有空格。**", "outputFormat": "一个整数，他们在同一个地方的天数。", "hint": "$1 \\leq m \\leq 10^6$，$1 \\leq n \\leq 20$。", "locale": "zh-CN"}}}
{"pid": "P1185", "type": "P", "difficulty": 4, "samples": [["2 0\n", "  o  \n / \\ \no   o\n"], ["4 0", "           o           \n          / \\          \n         /   \\         \n        /     \\        \n       /       \\       \n      /         \\      \n     o           o     \n    / \\         / \\    \n   /   \\       /   \\   \n  o     o     o     o  \n / \\   / \\   / \\   / \\ \no   o o   o o   o o   o"], ["4 3\n3 2\n4 1\n3 4\n", "           o           \n          / \\          \n         /   \\         \n        /     \\        \n       /       \\       \n      /         \\      \n     o           o     \n    /           /      \n   /           /       \n  o           o        \n   \\         / \\       \n    o       o   o      "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟"], "title": "绘制二叉树", "background": "", "description": "二叉树是一种基本的数据结构，它要么为空，要么由根结点，左子树和右子树组成，同时左子树和右子树也分别是二叉树。\n\n当一颗二叉树高度为 $m-1$ 时，共有 $m$ 层。若一棵二叉树除第 $m$ 层外，其他各层的结点数都达到最大，且叶子结点都在第 $m$ 层时，则其为一棵满二叉树。\n\n现在，需要你用程序来绘制一棵二叉树，它由一棵满二叉树去掉若干结点而成。对于一棵满二叉树，我们需要按照以下要求绘制：\n\n1. 结点用小写字母 `o` 表示，对于一个父亲结点，用 `/` 连接左子树，用 `\\` 连接右子树。\n\n2. 定义 $[i,j]$ 为位于第 $i$ 行第 $j$ 列的某个字符。若 $[i,j]$ 为 `/` ，那么 $[i-1,j+1]$ 与 $[i+1,j-1]$ 要么为 `o` ，要么为 `/`。若 $[i,j]$ 为 `\\` ，那么 $[i-1,j-1]$ 与 $[i+1,j+1]$ 要么为 `o`，要么为 `\\` 。同样，若 $[i,j]$ 为第 $1\\sim m-1$ 层的某个结点 `o` ，那么 $[i+1,j-1]$ 为 `/`，$[i+1,j+1]$ 为 `\\`。\n\n3. 对于第 $m$ 层结点也就是叶子结点点，若两个属于同一个父亲，那么它们之间由 $3$ 个空格隔开；若两个结点相邻但不属于同一个父亲，那么它们之间由 $1$ 个空格隔开。第 $m$ 层左数第 $1$ 个结点之前没有空格。\n\n最后需要在一棵绘制好的满二叉树上删除 $n$ 个结点（包括这个结点的左右子树，以及与父亲的连接），原有的字符用空格替换（空格为 `ASCII 32`，若输出 `ASCII 0` 会被算作错误答案）。", "inputFormat": "第 $1$ 行包含 $2$ 个正整数 $m$ 和 $n$，为需要绘制的二叉树层数和需要删除的结点数。\n\n接下来 $n$ 行，每行两个正整数，表示删除第 $i$ 层的第 $j$ 个结点。", "outputFormat": "按照题目要求绘制的二叉树。\n", "hint": "$30\\%$ 的数据满足：$n=0$；\n\n$50\\%$ 的数据满足：$2\\le m\\le 5$；\n\n$100\\%$ 的数据满足：$2\\le m\\le10,0\\le n\\le 10,1<i\\le M,j\\le 2^{i-1}$。", "locale": "zh-CN", "translations": {"en": {"title": "Drawing a Binary Tree", "background": "", "description": "A binary tree is a basic data structure. It is either empty, or consists of a root node, a left subtree, and a right subtree. The left and right subtrees are also binary trees.\n\nWhen a binary tree has height $m-1$, it has $m$ levels. If, in a binary tree, every level except level $m$ has the maximum possible number of nodes and all leaf nodes are on level $m$, then it is a full binary tree.\n\nNow you are required to write a program to draw a binary tree that is obtained by removing some nodes from a full binary tree. For a full binary tree, draw it according to the following rules:\n\n1. Nodes are represented by the lowercase letter `o`. For a parent node, use `/` to connect to its left child and `\\` to connect to its right child.\n\n2. Define $[i,j]$ as the character located at row $i$ and column $j$. If $[i,j]$ is `/`, then $[i-1,j+1]$ and $[i+1,j-1]$ must be either `o` or `/`. If $[i,j]$ is `\\`, then $[i-1,j-1]$ and $[i+1,j+1]$ must be either `o` or `\\`. Likewise, if $[i,j]$ is a node `o` on levels $1\\sim m-1$, then $[i+1,j-1]$ is `/` and $[i+1,j+1]$ is `\\`.\n\n3. For the nodes on level $m$ (the leaves): if two leaves share the same parent, they are separated by 3 spaces; if two leaves are adjacent but do not share the same parent, they are separated by 1 space. There is no space before the first (leftmost) node on level $m$.\n\nFinally, after drawing a full binary tree, delete $n$ nodes from it (each deletion removes that node, its left and right subtrees, and its connection to its parent). Replace all removed characters with spaces (the space is `ASCII 32`; outputting `ASCII 0` will be judged as a wrong answer).", "inputFormat": "The first line contains two positive integers $m$ and $n$, the number of levels of the binary tree to draw and the number of nodes to delete.\n\nThe next $n$ lines each contain two positive integers, indicating deletion of the $j$-th node on level $i$.", "outputFormat": "Output the binary tree drawn according to the requirements.", "hint": "30% of the testdata satisfy: $n=0$.\n\n50% of the testdata satisfy: $2\\le m\\le 5$.\n\n100% of the testdata satisfy: $2\\le m\\le10,0\\le n\\le 10,1<i\\le m,j\\le 2^{i-1}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "绘制二叉树", "background": "", "description": "二叉树是一种基本的数据结构，它要么为空，要么由根结点，左子树和右子树组成，同时左子树和右子树也分别是二叉树。\n\n当一颗二叉树高度为 $m-1$ 时，共有 $m$ 层。若一棵二叉树除第 $m$ 层外，其他各层的结点数都达到最大，且叶子结点都在第 $m$ 层时，则其为一棵满二叉树。\n\n现在，需要你用程序来绘制一棵二叉树，它由一棵满二叉树去掉若干结点而成。对于一棵满二叉树，我们需要按照以下要求绘制：\n\n1. 结点用小写字母 `o` 表示，对于一个父亲结点，用 `/` 连接左子树，用 `\\` 连接右子树。\n\n2. 定义 $[i,j]$ 为位于第 $i$ 行第 $j$ 列的某个字符。若 $[i,j]$ 为 `/` ，那么 $[i-1,j+1]$ 与 $[i+1,j-1]$ 要么为 `o` ，要么为 `/`。若 $[i,j]$ 为 `\\` ，那么 $[i-1,j-1]$ 与 $[i+1,j+1]$ 要么为 `o`，要么为 `\\` 。同样，若 $[i,j]$ 为第 $1\\sim m-1$ 层的某个结点 `o` ，那么 $[i+1,j-1]$ 为 `/`，$[i+1,j+1]$ 为 `\\`。\n\n3. 对于第 $m$ 层结点也就是叶子结点点，若两个属于同一个父亲，那么它们之间由 $3$ 个空格隔开；若两个结点相邻但不属于同一个父亲，那么它们之间由 $1$ 个空格隔开。第 $m$ 层左数第 $1$ 个结点之前没有空格。\n\n最后需要在一棵绘制好的满二叉树上删除 $n$ 个结点（包括这个结点的左右子树，以及与父亲的连接），原有的字符用空格替换（空格为 `ASCII 32`，若输出 `ASCII 0` 会被算作错误答案）。", "inputFormat": "第 $1$ 行包含 $2$ 个正整数 $m$ 和 $n$，为需要绘制的二叉树层数和需要删除的结点数。\n\n接下来 $n$ 行，每行两个正整数，表示删除第 $i$ 层的第 $j$ 个结点。", "outputFormat": "按照题目要求绘制的二叉树。\n", "hint": "$30\\%$ 的数据满足：$n=0$；\n\n$50\\%$ 的数据满足：$2\\le m\\le 5$；\n\n$100\\%$ 的数据满足：$2\\le m\\le10,0\\le n\\le 10,1<i\\le M,j\\le 2^{i-1}$。", "locale": "zh-CN"}}}
{"pid": "P1186", "type": "P", "difficulty": 6, "samples": [["5 7\n1 2 8\n1 4 10\n2 3 9\n2 4 10\n2 5 1\n3 4 7\n3 5 10\n", "27"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "线段树", "枚举", "最短路"], "title": "玛丽卡", "background": "", "description": "麦克找了个新女朋友，玛丽卡对他非常恼火并伺机报复。\n\n因为她和他们不住在同一个城市，因此她开始准备她的长途旅行。\n\n在这个国家中每两个城市之间最多只有一条路相通，并且我们知道从一个城市到另一个城市路上所需花费的时间。\n\n麦克在车中无意中听到有一条路正在维修，并且那儿正堵车，但没听清楚到底是哪一条路。无论哪一条路正在维修，从玛丽卡所在的城市都能到达麦克所在的城市。\n\n玛丽卡将只从不堵车的路上通过，并且她将按最短路线行车。麦克希望知道在最糟糕的情况下玛丽卡到达他所在的城市需要多长时间，这样他就能保证他的女朋友离开该城市足够远。\n\n编写程序，帮助麦克找出玛丽卡按最短路线通过不堵车道路到达他所在城市所需的最长时间（用分钟表示）。\n", "inputFormat": "第一行有两个用空格隔开的数 $N$ 和 $M$，分别表示城市的数量以及城市间道路的数量。$1 \\le N \\le 1000$，$1 \\le M \\le N \\times (N - 1)/2$。城市用数字 $1 \\sim N$ 标识，麦克在城市 $1$ 中，玛丽卡在城市 $N$ 中。  \n\n接下来的 $M$ 行中每行包含三个用空格隔开的数 $A,B,V$。其中 $1 \\le A, B \\le N$，$1 \\le V \\le 1000$。这些数字表示在 $A$ 和城市 $B$ 中间有一条双行道，并且在 $V$ 分钟内就能通过。", "outputFormat": "一行，写出用分钟表示的最长时间，在这段时间中，无论哪条路在堵车，玛丽卡应该能够到达麦克处，如果少于这个时间的话，则必定存在一条路，该条路一旦堵车，玛丽卡就不能够赶到麦克处。", "hint": "感谢 Imakf 提供的三组 hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "Marika", "background": "", "description": "Mike got a new girlfriend, which made Marika very angry and eager to take revenge.\n\nSince she does not live in the same city as them, she starts preparing for a long trip.\n\nIn this country, between any two cities there is at most one road, and we know the time needed to travel from one city to another.\n\nMike happened to overhear that some road is under repair and is jammed, but he did not catch which road it is. No matter which single road is under repair, it is still possible to get from Marika’s city to Mike’s city.\n\nMarika will travel only on non-jammed roads, and she will follow a shortest route. Mike wants to know, in the worst case, how long it will take Marika to reach his city, so that he can make sure his new girlfriend is far enough away from that city.\n\nWrite a program to help Mike find the maximum time (in minutes) that Marika needs to reach his city by a shortest route using only non-jammed roads.", "inputFormat": "The first line contains two space-separated integers $N$ and $M$, the number of cities and the number of roads, respectively. $1 \\le N \\le 1000$, $1 \\le M \\le N \\times (N - 1)/2$. The cities are labeled $1 \\sim N$, Mike is in city $1$, and Marika is in city $N$.\n\nEach of the next $M$ lines contains three space-separated integers $A, B, V$. Here $1 \\le A, B \\le N$, $1 \\le V \\le 1000$. These numbers mean there is a bidirectional road between city $A$ and city $B$, and it takes $V$ minutes to travel it.", "outputFormat": "Output a single line with the maximum time in minutes such that, no matter which single road is jammed, Marika can reach Mike within this time by a shortest route over non-jammed roads; if the time were any smaller, then there would exist some road which, once jammed, would prevent Marika from reaching Mike within that time.", "hint": "Thanks to Imakf for providing three sets of hack testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "玛丽卡", "background": "", "description": "麦克找了个新女朋友，玛丽卡对他非常恼火并伺机报复。\n\n因为她和他们不住在同一个城市，因此她开始准备她的长途旅行。\n\n在这个国家中每两个城市之间最多只有一条路相通，并且我们知道从一个城市到另一个城市路上所需花费的时间。\n\n麦克在车中无意中听到有一条路正在维修，并且那儿正堵车，但没听清楚到底是哪一条路。无论哪一条路正在维修，从玛丽卡所在的城市都能到达麦克所在的城市。\n\n玛丽卡将只从不堵车的路上通过，并且她将按最短路线行车。麦克希望知道在最糟糕的情况下玛丽卡到达他所在的城市需要多长时间，这样他就能保证他的女朋友离开该城市足够远。\n\n编写程序，帮助麦克找出玛丽卡按最短路线通过不堵车道路到达他所在城市所需的最长时间（用分钟表示）。\n", "inputFormat": "第一行有两个用空格隔开的数 $N$ 和 $M$，分别表示城市的数量以及城市间道路的数量。$1 \\le N \\le 1000$，$1 \\le M \\le N \\times (N - 1)/2$。城市用数字 $1 \\sim N$ 标识，麦克在城市 $1$ 中，玛丽卡在城市 $N$ 中。  \n\n接下来的 $M$ 行中每行包含三个用空格隔开的数 $A,B,V$。其中 $1 \\le A, B \\le N$，$1 \\le V \\le 1000$。这些数字表示在 $A$ 和城市 $B$ 中间有一条双行道，并且在 $V$ 分钟内就能通过。", "outputFormat": "一行，写出用分钟表示的最长时间，在这段时间中，无论哪条路在堵车，玛丽卡应该能够到达麦克处，如果少于这个时间的话，则必定存在一条路，该条路一旦堵车，玛丽卡就不能够赶到麦克处。", "hint": "感谢 Imakf 提供的三组 hack 数据。", "locale": "zh-CN"}}}
{"pid": "P1187", "type": "P", "difficulty": 2, "samples": [["3 3\n111\n212\n111", "38\n"], ["3 4\n1000\n0010\n0000\n", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "3D模型", "background": "", "description": "一座城市建立在规则的 $n \\times m$ 网格上，并且网格均由 $1 \\times 1$ 正方形构成。在每个网格上都可以有一个建筑，建筑由若干个 $1 \\times 1 \\times 1$ 的立方体搭建而成（也就是所有建筑的底部都在同一平面上的）。几个典型的城市模型如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2fxam89n.png)\n\n现在给出每个网格上建筑的高度，即每个网格上建筑由多少个立方体搭建而成，要求这个建筑模型的表面积是多少。", "inputFormat": "第 $1$ 行包含 $2$ 个正整数 $n,m$，为城市模型的长与宽。\n\n接下来 $n$ 行，每行 $m$ 个数字字符，描述了网格每个格子高度（可见所有建筑高度都大于等于 $0$ 且小于等于 $9$）。", "outputFormat": "一个非负整数，为城市模型的表面积。\n", "hint": "- $20\\%$的数据满足：$n, m \\leq 10$；\n- $40\\%$的数据满足：$n, m \\leq 100$；\n- $100\\%$的数据满足：$1 \\leq n, m \\leq 1000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "3D Model", "background": "", "description": "A city is built on a regular $n \\times m$ grid, where each cell is a $1 \\times 1$ square. Each cell may contain a building, which is constructed from some number of $1 \\times 1 \\times 1$ cubes (that is, all building bases lie on the same plane). Several typical city models are shown below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2fxam89n.png)\n\nNow the height of the building on each grid cell is given, i.e., how many cubes are stacked on that cell. Determine the surface area of this city model.", "inputFormat": "The first line contains 2 positive integers $n, m$, the length and width of the city model.\n\nThen follow $n$ lines, each containing $m$ digit characters, describing the height of each cell (all building heights are greater than or equal to $0$ and less than or equal to $9$).", "outputFormat": "A non-negative integer: the surface area of the city model.", "hint": "- 20% of the testdata satisfy: $n, m \\leq 10$;\n- 40% of the testdata satisfy: $n, m \\leq 100$;\n- 100% of the testdata satisfy: $1 \\leq n, m \\leq 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "3D模型", "background": "", "description": "一座城市建立在规则的 $n \\times m$ 网格上，并且网格均由 $1 \\times 1$ 正方形构成。在每个网格上都可以有一个建筑，建筑由若干个 $1 \\times 1 \\times 1$ 的立方体搭建而成（也就是所有建筑的底部都在同一平面上的）。几个典型的城市模型如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2fxam89n.png)\n\n现在给出每个网格上建筑的高度，即每个网格上建筑由多少个立方体搭建而成，要求这个建筑模型的表面积是多少。", "inputFormat": "第 $1$ 行包含 $2$ 个正整数 $n,m$，为城市模型的长与宽。\n\n接下来 $n$ 行，每行 $m$ 个数字字符，描述了网格每个格子高度（可见所有建筑高度都大于等于 $0$ 且小于等于 $9$）。", "outputFormat": "一个非负整数，为城市模型的表面积。\n", "hint": "- $20\\%$的数据满足：$n, m \\leq 10$；\n- $40\\%$的数据满足：$n, m \\leq 100$；\n- $100\\%$的数据满足：$1 \\leq n, m \\leq 1000$。\n", "locale": "zh-CN"}}}
{"pid": "P1188", "type": "P", "difficulty": 3, "samples": [["13 3\n6 12 1\n2 9 0\n10 13 8\n", "6\n7\n8\n9\n10\n11\n12\n2\n3\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "PASTE", "background": "", "description": "我们用文本处理器来处理一个特殊的文本文件，该文本文件共有 $N$ 行文本，每一行文本仅包含一个自然数，第一行为 $1$、第二行为 $2$，以此类推至 $N$ 行为自然数 $N$。\n\n假设对该文本文件执行一次“剪切和粘贴”操作含义如下：首先选定连续的若干行文本，“剪切”操作将选定的文本从文件中剪下，而“粘贴”操作将剪切下来的文本插入到文件中的其他地方。\n\n编写一个程序求出在进行了连续若干次“剪切和粘贴”操作后，文本文件中前十行的内容。\n", "inputFormat": "第一行包含两个用空格隔开的自然数 $N$ 和 $K$，$N$ 表示文件的总行数 $(10≤N≤100,000)$，$K$ 表示“剪切和粘贴”的总次数$(1≤k≤1000)$。\n\n下面$K$行每一行包含一次“剪切和粘贴”操作的执行信息，每行包含三个用空格隔开自然数 $A,B,C$，其中 $1≤A≤B≤N,0≤C≤N-(B-A+1)$。$A$ 和 $B$ 表示选定文本的第一行和最后一行，$C$ 表示被剪切下来的文本待插入处的前一行，如果 $C$ 等于 $0$ 则被剪切下来的的文本将被插入到文件的开头。\n", "outputFormat": "由十行组成，其中包含所有的操作都完成后的文本文件中前十行所包含的数字。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "PASTE", "background": "", "description": "We use a text processor to handle a special text file with $N$ lines. Each line contains exactly one natural number: the first line is $1$, the second line is $2$, and so on, up to line $N$ which is the natural number $N$.\n\nA single \"cut and paste\" operation is defined as follows: first choose a consecutive block of lines. The \"cut\" operation removes the selected lines from the file, and the \"paste\" operation inserts the removed block into another position in the file.\n\nWrite a program to determine the contents of the first ten lines of the text file after performing several \"cut and paste\" operations in sequence.", "inputFormat": "The first line contains two natural numbers $N$ and $K$, where $N$ is the total number of lines in the file $(10 \\le N \\le 100{,}000)$, and $K$ is the total number of \"cut and paste\" operations $(1 \\le K \\le 1000)$.\n\nEach of the next $K$ lines describes one \"cut and paste\" operation with three space-separated natural numbers $A, B, C$, where $1 \\le A \\le B \\le N$, $0 \\le C \\le N - (B - A + 1)$. $A$ and $B$ are the first and last line numbers of the selected block. $C$ is the line number immediately preceding the insertion position of the cut block; if $C = 0$, the block is inserted at the beginning of the file.", "outputFormat": "Output ten lines, which are the numbers contained in the first ten lines of the text file after all operations have been completed.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "PASTE", "background": "", "description": "我们用文本处理器来处理一个特殊的文本文件，该文本文件共有 $N$ 行文本，每一行文本仅包含一个自然数，第一行为 $1$、第二行为 $2$，以此类推至 $N$ 行为自然数 $N$。\n\n假设对该文本文件执行一次“剪切和粘贴”操作含义如下：首先选定连续的若干行文本，“剪切”操作将选定的文本从文件中剪下，而“粘贴”操作将剪切下来的文本插入到文件中的其他地方。\n\n编写一个程序求出在进行了连续若干次“剪切和粘贴”操作后，文本文件中前十行的内容。\n", "inputFormat": "第一行包含两个用空格隔开的自然数 $N$ 和 $K$，$N$ 表示文件的总行数 $(10≤N≤100,000)$，$K$ 表示“剪切和粘贴”的总次数$(1≤k≤1000)$。\n\n下面$K$行每一行包含一次“剪切和粘贴”操作的执行信息，每行包含三个用空格隔开自然数 $A,B,C$，其中 $1≤A≤B≤N,0≤C≤N-(B-A+1)$。$A$ 和 $B$ 表示选定文本的第一行和最后一行，$C$ 表示被剪切下来的文本待插入处的前一行，如果 $C$ 等于 $0$ 则被剪切下来的的文本将被插入到文件的开头。\n", "outputFormat": "由十行组成，其中包含所有的操作都完成后的文本文件中前十行所包含的数字。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1189", "type": "P", "difficulty": 3, "samples": [["4 5\n.....\n.X...\n...*X\nX.X..\n3\nNORTH\nWEST\nSOUTH", ".....\n*X*..\n*.*.X\nX.X..\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "广度优先搜索 BFS", "深度优先搜索 DFS", "记忆化搜索", "迭代加深搜索"], "title": "SEARCH", "background": "", "description": "年轻的拉尔夫开玩笑地从一个小镇上偷走了一辆车，但他没想到的是那辆车属于警察局，并且车上装有用于发射车子移动路线的装置。\n\n那个装置太旧了，以至于只能发射关于那辆车的移动路线的方向信息。\n\n编写程序，通过使用一张小镇的地图帮助警察局找到那辆车。程序必须能表示出该车最终所有可能的位置。\n\n小镇的地图是矩形的，上面的符号用来标明哪儿可以行车哪儿不行。$\\verb!.!$ 表示小镇上那块地方是可以行车的，而符号 $\\verb!X!$ 表示此处不能行车。拉尔夫所开小车的初始位置用字符的 $\\verb!*!$ 表示，且汽车能从初始位置通过。\n\n汽车能向四个方向移动：向北（向上），向南（向下），向西（向左），向东（向右）。\n\n拉尔夫所开小车的行动路线是通过一组给定的方向来描述的。在每个给定的方向，拉尔夫驾驶小车通过小镇上一个或更多的可行车地点。\n", "inputFormat": "输入文件的第一行包含两个用空格隔开的自然数 $R$ 和 $C$，$1\\le R\\le 50$，$1\\le C\\le 50$，分别表示小镇地图中的行数和列数。\n\n以下的 $R$ 行中每行都包含一组 $C$ 个符号（$\\verb!.!$ 或 $\\verb!X!$ 或 $\\verb!*!$）用来描述地图上相应的部位。\n\n接下来的第 $R+2$ 行包含一个自然数 $N$，$1\\le N\\le 1000$，表示一组方向的长度。\n\n接下来的 $N$ 行幅行包含下述单词中的任一个：`NORTH`（北）、`SOUTH`（南）、`WEST`（西）和 `EAST`（东），表示汽车移动的方向，任何两个连续的方向都不相同。\n", "outputFormat": "用 $R$ 行表示的小镇的地图（像输入文件中一样），字符 $\\verb!*!$ 应该仅用来表示汽车最终可能出现的位置。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "SEARCH", "background": "", "description": "Young Ralph jokingly stole a car from a small town, but he did not expect that the car belonged to the police department and that it was equipped with a device that broadcasts the car’s movement route.\n\nThe device is so old that it can only broadcast the directions of the car’s movement.\n\nWrite a program to help the police department find the car using a map of the town. The program must indicate all possible final positions of the car.\n\nThe town map is rectangular, and symbols mark where driving is allowed or not. $\\verb!.!$ denotes a drivable cell in the town, while $\\verb!X!$ denotes a non-drivable cell. The car’s initial position is marked with the character $\\verb!*!$, and that cell is drivable.\n\nThe car can move in four directions: north (up), south (down), west (left), and east (right).\n\nThe car’s route is described by a given sequence of directions. For each given direction, Ralph drives the car through one or more drivable cells of the town.", "inputFormat": "The first line of the input file contains two natural numbers $R$ and $C$, $1 \\le R \\le 50$, $1 \\le C \\le 50$, representing the number of rows and columns of the town map, respectively.\n\nEach of the next $R$ lines contains a sequence of $C$ symbols ($\\verb!.!$ or $\\verb!X!$ or $\\verb!*!$) describing the corresponding part of the map.\n\nThe $(R+2)$-th line contains a natural number $N$, $1 \\le N \\le 1000$, representing the length of the sequence of directions.\n\nEach of the next $N$ lines contains one of the following words: `NORTH` (north), `SOUTH` (south), `WEST` (west), and `EAST` (east), indicating the direction of movement. Any two consecutive directions are different.", "outputFormat": "Output the town map in $R$ lines (as in the input file). The character $\\verb!*!$ should be used only to denote the car’s possible final positions.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "SEARCH", "background": "", "description": "年轻的拉尔夫开玩笑地从一个小镇上偷走了一辆车，但他没想到的是那辆车属于警察局，并且车上装有用于发射车子移动路线的装置。\n\n那个装置太旧了，以至于只能发射关于那辆车的移动路线的方向信息。\n\n编写程序，通过使用一张小镇的地图帮助警察局找到那辆车。程序必须能表示出该车最终所有可能的位置。\n\n小镇的地图是矩形的，上面的符号用来标明哪儿可以行车哪儿不行。$\\verb!.!$ 表示小镇上那块地方是可以行车的，而符号 $\\verb!X!$ 表示此处不能行车。拉尔夫所开小车的初始位置用字符的 $\\verb!*!$ 表示，且汽车能从初始位置通过。\n\n汽车能向四个方向移动：向北（向上），向南（向下），向西（向左），向东（向右）。\n\n拉尔夫所开小车的行动路线是通过一组给定的方向来描述的。在每个给定的方向，拉尔夫驾驶小车通过小镇上一个或更多的可行车地点。\n", "inputFormat": "输入文件的第一行包含两个用空格隔开的自然数 $R$ 和 $C$，$1\\le R\\le 50$，$1\\le C\\le 50$，分别表示小镇地图中的行数和列数。\n\n以下的 $R$ 行中每行都包含一组 $C$ 个符号（$\\verb!.!$ 或 $\\verb!X!$ 或 $\\verb!*!$）用来描述地图上相应的部位。\n\n接下来的第 $R+2$ 行包含一个自然数 $N$，$1\\le N\\le 1000$，表示一组方向的长度。\n\n接下来的 $N$ 行幅行包含下述单词中的任一个：`NORTH`（北）、`SOUTH`（南）、`WEST`（西）和 `EAST`（东），表示汽车移动的方向，任何两个连续的方向都不相同。\n", "outputFormat": "用 $R$ 行表示的小镇的地图（像输入文件中一样），字符 $\\verb!*!$ 应该仅用来表示汽车最终可能出现的位置。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1190", "type": "P", "difficulty": 2, "samples": [["5 3\n4 4 1 2 1\n", "4"], ["8 4\n23 71 87 32 70 93 80 76\n", "163"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "贪心", "2010", "NOIP 普及组"], "title": "[NOIP 2010 普及组] 接水问题", "background": "", "description": "学校里有一个水房，水房里一共装有 $m$ 个龙头可供同学们打开水，每个龙头每秒钟的供水量相等，均为 $1$。\n\n现在有 $n$ 名同学准备接水，他们的初始接水顺序已经确定。将这些同学按接水顺序从 $1$ 到 $n$ 编号，$i$ 号同学的接水量为 $w_i$。接水开始时，$1$ 到 $m$ 号同学各占一个水龙头，并同时打开水龙头接水。当其中某名同学 $j$ 完成其接水量要求 $w_j$ 后，下一名排队等候接水的同学 $k$ 马上接替 $j$ 同学的位置开始接水。这个换人的过程是瞬间完成的，且没有任何水的浪费。即 $j$ 同学第 $x$ 秒结束时完成接水，则 $k$ 同学第 $x+1$ 秒立刻开始接水。若当前接水人数 $n'$ 不足 $m$，则只有 $n'$ 个龙头供水，其它 $m - n'$ 个龙头关闭。\n\n现在给出 $n$ 名同学的接水量，按照上述接水规则，问所有同学都接完水需要多少秒。\n", "inputFormat": "第一行两个整数 $n$ 和 $m$，用一个空格隔开，分别表示接水人数和龙头个数。\n\n第二行 $n$ 个整数 $w_1,w_2,\\ldots,w_n$，每两个整数之间用一个空格隔开，$w_i$ 表示 $i$ 号同学的接水量。", "outputFormat": "一个整数，表示接水所需的总时间。\n", "hint": "【输入输出样例 \\#1 说明】\n\n第 $1$ 秒，$3$ 人接水。第 $1$ 秒结束时，$1,2,3$ 号同学每人的已接水量为 $1,3$ 号同学接完水，$4$ 号同学接替 $3$ 号同学开始接水。\n\n第 $2$ 秒，$3$ 人接水。第 $2$ 秒结束时，$1,2$ 号同学每人的已接水量为 $2,4$ 号同学的已接水量为 $1$。\n\n第 $3$ 秒，$3$ 人接水。第 $3$ 秒结束时，$1,2$ 号同学每人的已接水量为 $3,4$ 号同学的已接水量为 $2$。$4$ 号同学接完水，$5$ 号同学接替 $4$ 号同学开始接水。\n\n第 $4$ 秒，$3$ 人接水。第 $4$ 秒结束时，$1,2$ 号同学每人的已接水量为 $4,5$ 号同学的已接水量为 $1$。$1,2,5$ 号同学接完水，即所有人完成接水的总接水时间为 $4$ 秒。\n\n【数据范围】\n\n$1 \\le n \\le {10}^4$，$1 \\le m \\le 100$，$m \\le n$；\n\n$1 \\le w_i \\le 100$。\n\nNOIP2010 普及组 第二题\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2010 Junior] Fetching Water Problem", "background": "", "description": "There is a water room in the school with a total of $m$ faucets that students can use. Each faucet supplies water at an equal rate of $1$ unit per second.\n\nNow $n$ students are preparing to fetch water, and their initial order is fixed. Number the students from $1$ to $n$ according to this order, and let the required amount for student $i$ be $w_i$. At the start, students $1$ through $m$ each occupy one faucet and start fetching water simultaneously. When some student $j$ finishes their required amount $w_j$, the next student $k$ in the queue immediately takes $j$’s place and starts fetching water. This handover is instantaneous, and no water is wasted. Specifically, if student $j$ finishes at the end of second $x$, then student $k$ starts at second $x+1$. If the current number of students fetching water is $n' < m$, then only $n'$ faucets supply water, and the remaining $m - n'$ faucets are closed.\n\nGiven the required amounts for the $n$ students and following the rules above, determine how many seconds it takes for all students to finish fetching water.", "inputFormat": "The first line contains two integers $n$ and $m$, separated by a space, representing the number of students and the number of faucets.\n\nThe second line contains $n$ integers $w_1,w_2,\\ldots,w_n$, separated by single spaces, where $w_i$ is the required amount for student $i$.", "outputFormat": "Output a single integer representing the total time required.", "hint": "[Sample I/O #1 Explanation]\n\nIn the 1st second, 3 students are fetching water. At the end of the 1st second, students 1, 2, and 3 have each fetched 1 unit. Student 3 finishes, and student 4 takes student 3’s place to start fetching water.\n\nIn the 2nd second, 3 students are fetching water. At the end of the 2nd second, students 1 and 2 have each fetched 2 units, and student 4 has fetched 1 unit.\n\nIn the 3rd second, 3 students are fetching water. At the end of the 3rd second, students 1 and 2 have each fetched 3 units, and student 4 has fetched 2 units. Student 4 finishes, and student 5 takes student 4’s place to start fetching water.\n\nIn the 4th second, 3 students are fetching water. At the end of the 4th second, students 1 and 2 have each fetched 4 units, and student 5 has fetched 1 unit. Students 1, 2, and 5 finish, so the total time for everyone to finish is 4 seconds.\n\nConstraints\n\n$1 \\le n \\le 10^4$, $1 \\le m \\le 100$, $m \\le n$;\n\n$1 \\le w_i \\le 100$.\n\nNOIP 2010 Junior Problem 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2010 普及组] 接水问题", "background": "", "description": "学校里有一个水房，水房里一共装有 $m$ 个龙头可供同学们打开水，每个龙头每秒钟的供水量相等，均为 $1$。\n\n现在有 $n$ 名同学准备接水，他们的初始接水顺序已经确定。将这些同学按接水顺序从 $1$ 到 $n$ 编号，$i$ 号同学的接水量为 $w_i$。接水开始时，$1$ 到 $m$ 号同学各占一个水龙头，并同时打开水龙头接水。当其中某名同学 $j$ 完成其接水量要求 $w_j$ 后，下一名排队等候接水的同学 $k$ 马上接替 $j$ 同学的位置开始接水。这个换人的过程是瞬间完成的，且没有任何水的浪费。即 $j$ 同学第 $x$ 秒结束时完成接水，则 $k$ 同学第 $x+1$ 秒立刻开始接水。若当前接水人数 $n'$ 不足 $m$，则只有 $n'$ 个龙头供水，其它 $m - n'$ 个龙头关闭。\n\n现在给出 $n$ 名同学的接水量，按照上述接水规则，问所有同学都接完水需要多少秒。\n", "inputFormat": "第一行两个整数 $n$ 和 $m$，用一个空格隔开，分别表示接水人数和龙头个数。\n\n第二行 $n$ 个整数 $w_1,w_2,\\ldots,w_n$，每两个整数之间用一个空格隔开，$w_i$ 表示 $i$ 号同学的接水量。", "outputFormat": "一个整数，表示接水所需的总时间。\n", "hint": "【输入输出样例 \\#1 说明】\n\n第 $1$ 秒，$3$ 人接水。第 $1$ 秒结束时，$1,2,3$ 号同学每人的已接水量为 $1,3$ 号同学接完水，$4$ 号同学接替 $3$ 号同学开始接水。\n\n第 $2$ 秒，$3$ 人接水。第 $2$ 秒结束时，$1,2$ 号同学每人的已接水量为 $2,4$ 号同学的已接水量为 $1$。\n\n第 $3$ 秒，$3$ 人接水。第 $3$ 秒结束时，$1,2$ 号同学每人的已接水量为 $3,4$ 号同学的已接水量为 $2$。$4$ 号同学接完水，$5$ 号同学接替 $4$ 号同学开始接水。\n\n第 $4$ 秒，$3$ 人接水。第 $4$ 秒结束时，$1,2$ 号同学每人的已接水量为 $4,5$ 号同学的已接水量为 $1$。$1,2,5$ 号同学接完水，即所有人完成接水的总接水时间为 $4$ 秒。\n\n【数据范围】\n\n$1 \\le n \\le {10}^4$，$1 \\le m \\le 100$，$m \\le n$；\n\n$1 \\le w_i \\le 100$。\n\nNOIP2010 普及组 第二题\n", "locale": "zh-CN"}}}
{"pid": "P1191", "type": "P", "difficulty": 3, "samples": [["4\nWWBW\nBBWB\nWBWW\nWBWB", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "枚举"], "title": "矩形", "background": "", "description": "给出一个 $n \\times n$ 的矩阵，矩阵中，有些格子被染成白色，有些格子被染成黑色，现要求矩阵中白色**矩形**的数量。", "inputFormat": "第一行，一个整数 $n$，表示矩形的大小。\n\n接下来 $n$ 行，每行 $n$ 个字符，这些字符为 $\\verb!W!$ 或 $\\verb!B!$。其中 $\\verb!W!$ 表示白格，$\\verb!B!$ 表示黑格。\n", "outputFormat": "一个正整数，为白色矩形数量。\n", "hint": "对于$30\\%$的数据，$n ≤ 50$；\n\n对于$100\\%$的数据，$n ≤ 150$；\n", "locale": "zh-CN", "translations": {"en": {"title": "Rectangle", "background": "", "description": "You are given an $n \\times n$ matrix. In the matrix, some cells are colored white and some are colored black. Find the number of white rectangles in the matrix.", "inputFormat": "The first line contains an integer $n$, denoting the size of the matrix.\nThen follow $n$ lines, each containing $n$ characters. Each character is $\\verb!W!$ or $\\verb!B!$. Here, $\\verb!W!$ denotes a white cell, and $\\verb!B!$ denotes a black cell.", "outputFormat": "Output a single positive integer: the number of white rectangles.", "hint": "For $30\\%$ of the testdata, $n ≤ 50$.\nFor $100\\%$ of the testdata, $n ≤ 150$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "矩形", "background": "", "description": "给出一个 $n \\times n$ 的矩阵，矩阵中，有些格子被染成白色，有些格子被染成黑色，现要求矩阵中白色**矩形**的数量。", "inputFormat": "第一行，一个整数 $n$，表示矩形的大小。\n\n接下来 $n$ 行，每行 $n$ 个字符，这些字符为 $\\verb!W!$ 或 $\\verb!B!$。其中 $\\verb!W!$ 表示白格，$\\verb!B!$ 表示黑格。\n", "outputFormat": "一个正整数，为白色矩形数量。\n", "hint": "对于$30\\%$的数据，$n ≤ 50$；\n\n对于$100\\%$的数据，$n ≤ 150$；\n", "locale": "zh-CN"}}}
{"pid": "P1192", "type": "P", "difficulty": 2, "samples": [["5 2", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "Fibonacci 数列", "线性递推"], "title": "台阶问题", "background": "", "description": "有 $N$ 级台阶，你一开始在底部，每次可以向上迈 $1\\sim K$ 级台阶，问到达第 $N$ 级台阶有多少种不同方式。", "inputFormat": "两个正整数 $N,K$。", "outputFormat": "一个正整数 $ans\\pmod{100003}$，为到达第 $N$ 级台阶的不同方式数。", "hint": "- 对于 $20\\%$ 的数据，$1\\leq N\\leq10$，$1\\leq K\\leq3$；\n- 对于 $40\\%$ 的数据，$1\\leq N\\leq1000$；\n- 对于 $100\\%$ 的数据，$1\\leq N\\leq100000$，$1\\leq K\\leq100$。", "locale": "zh-CN", "translations": {"en": {"title": "Staircase Problem", "background": "", "description": "There are $N$ steps. You start at the bottom, and each time you can climb $1\\sim K$ steps upward. How many different ways are there to reach the $N$-th step?", "inputFormat": "Two positive integers $N,K$.", "outputFormat": "A single positive integer $ans\\pmod{100003}$, the number of different ways to reach the $N$-th step.", "hint": "- For $20\\%$ of the testdata, $1\\leq N\\leq10$, $1\\leq K\\leq3$.\n- For $40\\%$ of the testdata, $1\\leq N\\leq1000$.\n- For $100\\%$ of the testdata, $1\\leq N\\leq100000$, $1\\leq K\\leq100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "台阶问题", "background": "", "description": "有 $N$ 级台阶，你一开始在底部，每次可以向上迈 $1\\sim K$ 级台阶，问到达第 $N$ 级台阶有多少种不同方式。", "inputFormat": "两个正整数 $N,K$。", "outputFormat": "一个正整数 $ans\\pmod{100003}$，为到达第 $N$ 级台阶的不同方式数。", "hint": "- 对于 $20\\%$ 的数据，$1\\leq N\\leq10$，$1\\leq K\\leq3$；\n- 对于 $40\\%$ 的数据，$1\\leq N\\leq1000$；\n- 对于 $100\\%$ 的数据，$1\\leq N\\leq100000$，$1\\leq K\\leq100$。", "locale": "zh-CN"}}}
{"pid": "P1193", "type": "P", "difficulty": 3, "samples": [["4 4\n501 502 503 504\n2 3 5 7\n50 30 10 5 93 50 1\n10\n501 2 10\n501 2 80\n501 2 70\n502 3 0\n502 3 0\n504 5 100\n503 7 0\n503 7 0\n503 7 0\n503 7 10\n", "480\n372\nUse Luogu!\n"], ["2 3\n101 102\n1 2 3\n70 60 50 1 80 100 0\n6\n101 1 100\n101 2 100\n101 3 100\n102 1 100\n102 2 100\n102 3 100\n", "500\n650\nForget it...\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "洛谷原创", "洛谷月赛"], "title": "洛谷团队训练 VS 传统团队训练", "background": "“在中学的信息学教育领域，[洛谷](/)无疑是一个相当受欢迎的辅助网站。同时有百余所学校正在通过洛谷进行信息学竞赛（以后简称 OI）的教育。洛谷之所以如此受欢迎，是因为洛谷创新的将 OI 教育的几乎每一个环节都搬到了线上，无论是学校的竞赛教练还是学生，均可以仅仅使用这一个网站来进行练习，提升自己的能力。”\n\n\n——摘自《厦门中小学教育科学研究》，2015 年 2 月号。", "description": "XX 中学的两位信息组的教练正在为学校信息组是否应当将洛谷作为主要的训练工具而争论不休，最后决定采取一个量化的办法来决定是否迁移。\n\n该中学的原来训练方法是，在机房的教师机里面用 cena 装载好测试数据，装载数据所需要 $T_a$ 时间，每一道题目都要装载。学生写好代码后，可以跑到教师机上收取程序并进行评测。但由于需要往返的路程，因此每跑一次就要浪费 $T_b$ 时间。所以也允许学生在自己的机子上装载好测试数据，可以根据自己的需要选择装载的题目，这需要花费和在教师机装载数据一样的时间 $T_a$，但是每次评测花费的时间就减少为 $T_c$。此外，该中学可能会用 Excel 记录各位同学的训练情况，如果某位同学的某道题的得分高于表格里的记录，那就会花费 $T_d$ 时间将这个成绩更新，否则就不必费那个事了，如果之前没有提交过这道题视为表格记录的程序为 $0$ 分。\n\n而在洛谷中，只需要将题目和测试数据上传到洛谷，花费 $T_a$ 时间。每次评测学生只需花费 $T_c$ 时间即可。记录成绩？那是洛谷的事儿，一提交完就帮你整理好了表格根本不费时间。\n\n看起来可以省下不少时间吧。。然而，支持传统训练方法的教练认为，洛谷并非 $100 \\%$ 的稳定，在有的情况会无法提供服务，因此首先要将洛谷的耗时除以它的可用度（一个小于 $100\\%$ 的数字 $A\\%$）并去掉小数点。又因为传统观念不易纠正，总是有不信任将题目数据交给洛谷这样的想法（kkksc03：怪我咯？），因此使用洛谷的耗时还要再加上一个罚时 $H$ 以做公平比较。\n\n现在给出该中学的训练情况，希望你帮两位教练分析一下到底该如何选择。", "inputFormat": "第一行，两个整数 $N, M$，代表题目数量与学生数量。\n\n第二行，$N$ 个整数 $P_1, P_2, \\ldots, P_N$，为涉及的题目编号。\n\n第三行，$M$ 个整数 $S_1, S_2, \\ldots, S_M$，为学生的学号。\n\n第四行，七个整数 $T_a, T_b, T_c, T_d, A, H, E$，前六个数字的意义见题目描述，$E$ 如果是 $1$ 那么在 Excel 中记录成绩，如果是 $0$ 则不记录。\n\n第五行，一个整数 $R$，代表评测数量。\n\n接下来 $R$ 行，评测记录，每行是 $\\mathit{Pr}_i, \\mathit{Sr}_i, \\mathit{Sc}_i$，分别为该次评测的题目号、学号以及成绩。", "outputFormat": "三行。\n\n第一行为传统方法的的耗时。\n\n第二行为使用洛谷包括罚时在内的耗时。\n\n第三行是结论，如果使用洛谷的时间小于传统方法的时间，那么输出 `Use Luogu!`。否则输出 `Forget it...`。", "hint": "**【样例解释 #1】**\n\n使用传统方法的话，装载 $4$ 道题目需要 $4 \\times 50=200$，$2$ 号同学和 $7$ 号同学使用教师机所需要的时间分别为 $30 \\times 3=90$、$30 \\times 4 = 120$，但是明显自己装载 cena 只需要 $50+10 \\times 3=80$、$50+10 \\times 4=90$ 更优。而 $3,5$ 同学则使用教师机就好，耗时 $60,30$。$2$ 号同学的前两次评测单调递增，所以额外花费 $2 \\times 5=10$ 时间记录，$3$ 号同学太弱了都是 $0$ 分所以没必要记录了，$5$ 与 $7$ 各耗费 $5$ 时间。所以这种情况总时间耗时为 $200+80+90+60+30+10+5+5=480$。\n\n使用洛谷的话，装载题目耗费 $200$，$10$ 次评测共耗费 $10 \\times10=100$，考虑稳定性时间为 $(200+100) / 93\\% = 322$，所以最后总耗时为 $322+50=372$，所以决定使用洛谷。\n\n**【数据范围】**\n\n其中 $50\\%$ 数据中，不需要进行成绩的 Excel 记录。\n\n其中 $50\\%$ 数据中，题目编号和学号均大于等于 $0$，小于等于 $1000$。\n\n（这两种情况，可能会重叠）\n\n对于 $100\\%$ 的数据，保证 $1 \\le n,m \\le 1000$，$1 \\le T_a, T_b, T_c,T_d,H \\le 10000$，$1 \\le R < 100000$，$0 \\le \\mathit{Sc}_i \\le 100$，$1 \\le A \\le 100$，学号和题目号在 ${10}^8$ 之内。\n\n实际上，根据超级监控颁发的证书，洛谷 2015 年第一季度可靠性（SLA）为 $99.36 \\%$。同时观念也是可以改变的。\n\n洛谷的优点很多都是不能量化的，其精华在于社区。和全国的 OIer 一起学习交流，不很好吗？\n\n最后插一句，去年的【榨取 kkksc03】的布告依然有效，详情。", "locale": "zh-CN", "translations": {"en": {"title": "Luogu Team Training vs Traditional Team Training", "background": "“In the field of secondary-school informatics education, [Luogu](/) is undoubtedly a very popular auxiliary website. At the same time, more than one hundred schools are using Luogu for informatics competitions (hereafter referred to as OI). The reason Luogu is so popular is that it innovatively moves almost every step of OI education online. Both school coaches and students can use this one website to practice and improve their skills.”\n\n— From “Xiamen Primary and Secondary Education Science Research,” February 2015 issue.", "description": "Two coaches of the informatics group at XX Middle School are debating whether the school’s informatics group should adopt Luogu as the primary training tool. They decide to use a quantitative approach to decide whether to switch.\n\nThe school’s original training method is as follows: on the teacher’s machine in the computer room, use cena to load the testdata. Loading the data takes time $T_a$, and this must be done for each problem. After a student finishes writing code, they can go to the teacher’s machine to submit and evaluate the program. However, because of the round trip, each evaluation incurs a waste of time $T_b$. Therefore, students are also allowed to load the testdata on their own machines, and they can choose which problems to load as needed. This takes the same time $T_a$ as loading on the teacher’s machine, but the time spent per evaluation is reduced to $T_c$. In addition, the school may use Excel to record each student’s training progress. If a student’s score on a problem is higher than the score recorded in the sheet, it will take time $T_d$ to update that record; otherwise no time is spent. If the student has not previously submitted that problem, the recorded score is considered to be $0$.\n\nWith Luogu, you only need to upload the problems and testdata to Luogu, taking time $T_a$. Each evaluation then takes only time $T_c$. Recording scores? That’s Luogu’s job—once a submission is completed, the platform organizes the table for you, taking no time.\n\nIt seems this could save quite a bit of time... However, the coach who supports the traditional method argues that Luogu is not $100 \\%$ stable and may be unavailable in some cases. Therefore, first divide Luogu’s total time by its availability (a number less than $100 \\%$, denoted $A\\%$) and remove the fractional part. Furthermore, because traditional perceptions are hard to change and there is always distrust in handing problem data to Luogu (kkksc03: “Blame me?”), add a penalty time $H$ to Luogu’s total for a fair comparison.\n\nGiven the school’s training scenario, please help the two coaches analyze which choice to make.", "inputFormat": "- The first line contains two integers $N, M$, the number of problems and the number of students.\n- The second line contains $N$ integers $P_1, P_2, \\ldots, P_N$, the problem IDs involved.\n- The third line contains $M$ integers $S_1, S_2, \\ldots, S_M$, the student IDs.\n- The fourth line contains seven integers $T_a, T_b, T_c, T_d, A, H, E$. The meanings of the first six numbers are as described above. If $E$ is $1$, scores are recorded in Excel; if $E$ is $0$, they are not recorded.\n- The fifth line contains a single integer $R$, the number of evaluations.\n- The next $R$ lines each contain an evaluation record, with $\\mathit{Pr}_i, \\mathit{Sr}_i, \\mathit{Sc}_i$ denoting the problem ID, the student ID, and the score for that evaluation, respectively.", "outputFormat": "Output three lines.\n\n- The first line is the total time for the traditional method.\n- The second line is the total time for using Luogu, including the penalty time.\n- The third line is the conclusion. If the time using Luogu is less than the time for the traditional method, output `Use Luogu!`. Otherwise, output `Forget it...`.", "hint": "【Sample Explanation #1】\n\nUsing the traditional method, loading $4$ problems takes $4 \\times 50 = 200$. For students No. $2$ and No. $7$, the times to use the teacher’s machine are $30 \\times 3 = 90$ and $30 \\times 4 = 120$, respectively. However, clearly loading cena locally costs only $50 + 10 \\times 3 = 80$ and $50 + 10 \\times 4 = 90$, which are better. Students No. $3$ and No. $5$ should just use the teacher’s machine, costing $60$ and $30$. Student No. $2$’s first two evaluations are strictly increasing, so recording takes an extra $2 \\times 5 = 10$ time. Student No. $3$ is too weak and always gets $0$, so no need to record. Students No. $5$ and No. $7$ each incur $5$. Therefore, the total time is $200 + 80 + 90 + 60 + 30 + 10 + 5 + 5 = 480$.\n\nUsing Luogu, uploading the problems takes $200$. The $10$ evaluations cost $10 \\times 10 = 100$. Considering availability, the time is $$(200+100) / 93\\% = 322,$$ so the final total time is $322 + 50 = 372$. Therefore, choose Luogu.\n\nConstraints\n\n- In $50\\%$ of the testdata, Excel score recording is not required.\n- In $50\\%$ of the testdata, both problem IDs and student IDs are between $0$ and $1000$, inclusive.\n  (These two cases may overlap.)\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\le N, M \\le 1000$, $1 \\le T_a, T_b, T_c, T_d, H \\le 10000$, $1 \\le R < 100000$, $0 \\le \\mathit{Sc}_i \\le 100$, $1 \\le A \\le 100$, and student IDs and problem IDs are less than $10^8$.\n\nIn fact, according to the certificate issued by Supervision, Luogu’s reliability (SLA) for Q1 2015 was $99.36 \\%$. Also, perceptions can be changed.\n\nMany of Luogu’s advantages are not quantifiable. Its essence lies in the community. Isn’t it great to learn and communicate with OIers nationwide?\n\nOne last note: last year’s “[Squeeze kkksc03]” notice is still valid; see details.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "洛谷团队训练 VS 传统团队训练", "background": "“在中学的信息学教育领域，[洛谷](/)无疑是一个相当受欢迎的辅助网站。同时有百余所学校正在通过洛谷进行信息学竞赛（以后简称 OI）的教育。洛谷之所以如此受欢迎，是因为洛谷创新的将 OI 教育的几乎每一个环节都搬到了线上，无论是学校的竞赛教练还是学生，均可以仅仅使用这一个网站来进行练习，提升自己的能力。”\n\n\n——摘自《厦门中小学教育科学研究》，2015 年 2 月号。", "description": "XX 中学的两位信息组的教练正在为学校信息组是否应当将洛谷作为主要的训练工具而争论不休，最后决定采取一个量化的办法来决定是否迁移。\n\n该中学的原来训练方法是，在机房的教师机里面用 cena 装载好测试数据，装载数据所需要 $T_a$ 时间，每一道题目都要装载。学生写好代码后，可以跑到教师机上收取程序并进行评测。但由于需要往返的路程，因此每跑一次就要浪费 $T_b$ 时间。所以也允许学生在自己的机子上装载好测试数据，可以根据自己的需要选择装载的题目，这需要花费和在教师机装载数据一样的时间 $T_a$，但是每次评测花费的时间就减少为 $T_c$。此外，该中学可能会用 Excel 记录各位同学的训练情况，如果某位同学的某道题的得分高于表格里的记录，那就会花费 $T_d$ 时间将这个成绩更新，否则就不必费那个事了，如果之前没有提交过这道题视为表格记录的程序为 $0$ 分。\n\n而在洛谷中，只需要将题目和测试数据上传到洛谷，花费 $T_a$ 时间。每次评测学生只需花费 $T_c$ 时间即可。记录成绩？那是洛谷的事儿，一提交完就帮你整理好了表格根本不费时间。\n\n看起来可以省下不少时间吧。。然而，支持传统训练方法的教练认为，洛谷并非 $100 \\%$ 的稳定，在有的情况会无法提供服务，因此首先要将洛谷的耗时除以它的可用度（一个小于 $100\\%$ 的数字 $A\\%$）并去掉小数点。又因为传统观念不易纠正，总是有不信任将题目数据交给洛谷这样的想法（kkksc03：怪我咯？），因此使用洛谷的耗时还要再加上一个罚时 $H$ 以做公平比较。\n\n现在给出该中学的训练情况，希望你帮两位教练分析一下到底该如何选择。", "inputFormat": "第一行，两个整数 $N, M$，代表题目数量与学生数量。\n\n第二行，$N$ 个整数 $P_1, P_2, \\ldots, P_N$，为涉及的题目编号。\n\n第三行，$M$ 个整数 $S_1, S_2, \\ldots, S_M$，为学生的学号。\n\n第四行，七个整数 $T_a, T_b, T_c, T_d, A, H, E$，前六个数字的意义见题目描述，$E$ 如果是 $1$ 那么在 Excel 中记录成绩，如果是 $0$ 则不记录。\n\n第五行，一个整数 $R$，代表评测数量。\n\n接下来 $R$ 行，评测记录，每行是 $\\mathit{Pr}_i, \\mathit{Sr}_i, \\mathit{Sc}_i$，分别为该次评测的题目号、学号以及成绩。", "outputFormat": "三行。\n\n第一行为传统方法的的耗时。\n\n第二行为使用洛谷包括罚时在内的耗时。\n\n第三行是结论，如果使用洛谷的时间小于传统方法的时间，那么输出 `Use Luogu!`。否则输出 `Forget it...`。", "hint": "**【样例解释 #1】**\n\n使用传统方法的话，装载 $4$ 道题目需要 $4 \\times 50=200$，$2$ 号同学和 $7$ 号同学使用教师机所需要的时间分别为 $30 \\times 3=90$、$30 \\times 4 = 120$，但是明显自己装载 cena 只需要 $50+10 \\times 3=80$、$50+10 \\times 4=90$ 更优。而 $3,5$ 同学则使用教师机就好，耗时 $60,30$。$2$ 号同学的前两次评测单调递增，所以额外花费 $2 \\times 5=10$ 时间记录，$3$ 号同学太弱了都是 $0$ 分所以没必要记录了，$5$ 与 $7$ 各耗费 $5$ 时间。所以这种情况总时间耗时为 $200+80+90+60+30+10+5+5=480$。\n\n使用洛谷的话，装载题目耗费 $200$，$10$ 次评测共耗费 $10 \\times10=100$，考虑稳定性时间为 $(200+100) / 93\\% = 322$，所以最后总耗时为 $322+50=372$，所以决定使用洛谷。\n\n**【数据范围】**\n\n其中 $50\\%$ 数据中，不需要进行成绩的 Excel 记录。\n\n其中 $50\\%$ 数据中，题目编号和学号均大于等于 $0$，小于等于 $1000$。\n\n（这两种情况，可能会重叠）\n\n对于 $100\\%$ 的数据，保证 $1 \\le n,m \\le 1000$，$1 \\le T_a, T_b, T_c,T_d,H \\le 10000$，$1 \\le R < 100000$，$0 \\le \\mathit{Sc}_i \\le 100$，$1 \\le A \\le 100$，学号和题目号在 ${10}^8$ 之内。\n\n实际上，根据超级监控颁发的证书，洛谷 2015 年第一季度可靠性（SLA）为 $99.36 \\%$。同时观念也是可以改变的。\n\n洛谷的优点很多都是不能量化的，其精华在于社区。和全国的 OIer 一起学习交流，不很好吗？\n\n最后插一句，去年的【榨取 kkksc03】的布告依然有效，详情。", "locale": "zh-CN"}}}
{"pid": "P1194", "type": "P", "difficulty": 3, "samples": [["1 1\n0\n", "1"], ["3 3\n0 2 4\n2 0 2\n4 2 0\n", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "生成树"], "title": "买礼物", "background": "", "description": "又到了一年一度的明明生日了，明明想要买 $B$ 样东西，巧的是，这 $B$ 样东西价格都是 $A$ 元。\n\n但是，商店老板说最近有促销活动，也就是：\n\n如果你买了第 $I$ 样东西，再买第 $J$ 样，那么就可以只花 $K_{I,J}$ 元，更巧的是，$K_{I,J}$ 竟然等于 $K_{J,I}$。\n\n现在明明想知道，他最少要花多少钱。", "inputFormat": "第一行两个整数，$A,B$。\n\n接下来 $B$ 行，每行 $B$ 个数，第 $I$ 行第 $J$ 个为 $K_{I,J}$。\n\n我们保证 $K_{I,J}=K_{J,I}$ 并且 $K_{I,I}=0$。\n\n特别的，如果 $K_{I,J}=0$，那么表示这两样东西之间不会导致优惠。\n\n注意 $K_{I,J}$ **可能大于** $A$。", "outputFormat": "一个整数，为最小要花的钱数。\n", "hint": "样例解释 $2$。\n\n先买第 $2$ 样东西，花费 $3$ 元，接下来因为优惠，买 $1,3$ 样都只要 $2$ 元，共 $7$ 元。\n\n（同时满足多个“优惠”的时候，聪明的明明当然不会选择用 $4$ 元买剩下那件，而选择用 $2$ 元。）\n\n数据规模\n\n对于 $30\\%$ 的数据，$1\\le B\\le 10$。\n\n对于 $100\\%$ 的数据，$1\\le B\\le500,0\\le A,K_{I,J}\\le1000$。\n\n2018.7.25新添数据一组", "locale": "zh-CN", "translations": {"en": {"title": "Buying Gifts", "background": "", "description": "It is Mingming’s birthday again. Mingming wants to buy $B$ kinds of items, and coincidentally, each of these $B$ items is priced at $A$ yuan.\n\nHowever, the shop owner says there is a promotion:\n\nIf you have bought item $I$, then when you buy item $J$, you only need to pay $K_{I,J}$ yuan. Moreover, $K_{I,J}$ happens to equal $K_{J,I}$.\n\nNow Mingming wants to know the minimum amount of money he has to spend.", "inputFormat": "The first line contains two integers, $A,B$.\n\nThen there are $B$ lines, each containing $B$ numbers. The $I$-th line and $J$-th number is $K_{I,J}$.\n\nWe guarantee $K_{I,J}=K_{J,I}$ and $K_{I,I}=0$.\n\nIn particular, if $K_{I,J}=0$, it means there is no discount between these two items.\n\nNote that $K_{I,J}$ may be greater than $A$.", "outputFormat": "Output a single integer, the minimum total amount of money required.", "hint": "Explanation for Sample $2$.\n\nBuy item $2$ first, spending 3 yuan. Then, due to the promotion, buying items $1$ and $3$ each costs 2 yuan, for a total of 7 yuan.\n\n(When multiple “discounts” apply at the same time, clever Mingming will of course not choose to pay 4 yuan for the remaining one, but choose to pay 2 yuan.)\n\nConstraints\n\nFor $30\\%$ of the testdata, $1\\le B\\le 10$.\n\nFor $100\\%$ of the testdata, $1\\le B\\le500,0\\le A,K_{I,J}\\le1000$.\n\nAdded one more set of testdata on 2018.7.25.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "买礼物", "background": "", "description": "又到了一年一度的明明生日了，明明想要买 $B$ 样东西，巧的是，这 $B$ 样东西价格都是 $A$ 元。\n\n但是，商店老板说最近有促销活动，也就是：\n\n如果你买了第 $I$ 样东西，再买第 $J$ 样，那么就可以只花 $K_{I,J}$ 元，更巧的是，$K_{I,J}$ 竟然等于 $K_{J,I}$。\n\n现在明明想知道，他最少要花多少钱。", "inputFormat": "第一行两个整数，$A,B$。\n\n接下来 $B$ 行，每行 $B$ 个数，第 $I$ 行第 $J$ 个为 $K_{I,J}$。\n\n我们保证 $K_{I,J}=K_{J,I}$ 并且 $K_{I,I}=0$。\n\n特别的，如果 $K_{I,J}=0$，那么表示这两样东西之间不会导致优惠。\n\n注意 $K_{I,J}$ **可能大于** $A$。", "outputFormat": "一个整数，为最小要花的钱数。\n", "hint": "样例解释 $2$。\n\n先买第 $2$ 样东西，花费 $3$ 元，接下来因为优惠，买 $1,3$ 样都只要 $2$ 元，共 $7$ 元。\n\n（同时满足多个“优惠”的时候，聪明的明明当然不会选择用 $4$ 元买剩下那件，而选择用 $2$ 元。）\n\n数据规模\n\n对于 $30\\%$ 的数据，$1\\le B\\le 10$。\n\n对于 $100\\%$ 的数据，$1\\le B\\le500,0\\le A,K_{I,J}\\le1000$。\n\n2018.7.25新添数据一组", "locale": "zh-CN"}}}
{"pid": "P1195", "type": "P", "difficulty": 3, "samples": [["3 1 2\n1 2 1\n", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "并查集", "生成树"], "title": "口袋的天空", "background": "小杉坐在教室里，透过口袋一样的窗户看口袋一样的天空。\n\n有很多云飘在那里，看起来很漂亮，小杉想摘下那样美的几朵云，做成棉花糖。\n", "description": "给你云朵的个数 $N$，再给你 $M$ 个关系，表示哪些云朵可以连在一起。\n\n现在小杉要把所有云朵连成 $K$ 个棉花糖，一个棉花糖最少要用掉一朵云，小杉想知道他怎么连，花费的代价最小。\n", "inputFormat": "第一行有三个数 $N,M,K$。\n\n接下来 $M$ 行每行三个数 $X,Y,L$，表示 $X$ 云和 $Y$ 云可以通过 $L$ 的代价连在一起。\n\n\n", "outputFormat": "对每组数据输出一行，仅有一个整数，表示最小的代价。\n\n如果怎么连都连不出 $K$ 个棉花糖，请输出 `No Answer`。\n", "hint": "对于 $30\\%$ 的数据，$1 \\le N \\le 100$，$1\\le M \\le 10^3$；\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^3$，$1 \\le M \\le 10^4$，$1 \\le K \\le 10$，$1 \\le X,Y \\le N$，$0 \\le L<10^4$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Pocket's Sky", "background": "Xiaoshan sits in the classroom, looking through a pocket-like window at a pocket-like sky. Many clouds are floating there and look beautiful; Xiaoshan wants to pick a few of those lovely clouds and make cotton candy.", "description": "You are given the number of clouds $N$, and then $M$ relations indicating which clouds can be connected.\n\nNow Xiaoshan wants to connect all clouds into exactly $K$ cotton candies (connected components). Each cotton candy must use at least one cloud. He wants to know how to connect them so that the total cost is minimized.", "inputFormat": "The first line contains three integers $N, M, K$.\n\nEach of the next $M$ lines contains three integers $X, Y, L$, meaning cloud $X$ and cloud $Y$ can be connected at a cost of $L$.", "outputFormat": "Output one line containing a single integer, the minimum total cost.\n\nIf it is impossible to obtain exactly $K$ cotton candies, output `No Answer`.", "hint": "Constraints:\n- For $30\\%$ of the testdata, $1 \\le N \\le 100$, $1 \\le M \\le 10^3$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 10^3$, $1 \\le M \\le 10^4$, $1 \\le K \\le 10$, $1 \\le X, Y \\le N$, $0 \\le L < 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "口袋的天空", "background": "小杉坐在教室里，透过口袋一样的窗户看口袋一样的天空。\n\n有很多云飘在那里，看起来很漂亮，小杉想摘下那样美的几朵云，做成棉花糖。\n", "description": "给你云朵的个数 $N$，再给你 $M$ 个关系，表示哪些云朵可以连在一起。\n\n现在小杉要把所有云朵连成 $K$ 个棉花糖，一个棉花糖最少要用掉一朵云，小杉想知道他怎么连，花费的代价最小。\n", "inputFormat": "第一行有三个数 $N,M,K$。\n\n接下来 $M$ 行每行三个数 $X,Y,L$，表示 $X$ 云和 $Y$ 云可以通过 $L$ 的代价连在一起。\n\n\n", "outputFormat": "对每组数据输出一行，仅有一个整数，表示最小的代价。\n\n如果怎么连都连不出 $K$ 个棉花糖，请输出 `No Answer`。\n", "hint": "对于 $30\\%$ 的数据，$1 \\le N \\le 100$，$1\\le M \\le 10^3$；\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^3$，$1 \\le M \\le 10^4$，$1 \\le K \\le 10$，$1 \\le X,Y \\le N$，$0 \\le L<10^4$。\n", "locale": "zh-CN"}}}
{"pid": "P1196", "type": "P", "difficulty": 4, "samples": [["4\nM 2 3\nC 1 2\nM 2 4\nC 4 2", "-1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2002", "并查集", "NOI"], "title": "[NOI2002] 银河英雄传说", "background": "公元 $5801$ 年，地球居民迁至金牛座 $\\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。\n\n宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。", "description": "杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \\ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  \n\n然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。\n\n在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。\n\n作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。\n\n最终的决战已经展开，银河的历史又翻过了一页……", "inputFormat": "第一行有一个整数 $T$（$1 \\le T \\le 5 \\times 10^5$），表示总共有 $T$ 条指令。\n\n以下有 $T$ 行，每行有一条指令。指令有两种格式：\n\n1. `M i j`：$i$ 和 $j$ 是两个整数（$1 \\le i,j \\le 30000$），表示指令涉及的战舰编号。该指令是莱因哈特窃听到的杨威利发布的舰队调动指令，并且保证第 $i$ 号战舰与第 $j$ 号战舰不在同一列。\n\n2. `C i j`：$i$ 和 $j$ 是两个整数（$1 \\le i,j \\le 30000$），表示指令涉及的战舰编号。该指令是莱因哈特发布的询问指令。\n\n每条指令中都保证 $i\\neq j$。", "outputFormat": "依次对输入的每一条指令进行分析和处理：\n\n- 如果是杨威利发布的舰队调动指令，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息。\n- 如果是莱因哈特发布的询问指令，你的程序要输出一行，仅包含一个整数，表示在同一列上，第 $i$ 号战舰与第 $j$ 号战舰之间布置的战舰数目。如果第 $i$ 号战舰与第 $j$ 号战舰当前不在同一列上，则输出 $-1$。", "hint": "### 样例解释\n\n战舰位置图：表格中阿拉伯数字表示战舰编号。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2002] Legend of the Galactic Heroes", "background": "In the year $5801$ AD, the inhabitants of Earth migrated to the second planet of Taurus $\\alpha$, where they proclaimed the founding of the Galactic Federation. In the same year, the calendar was changed to the Cosmic Era, and expansion toward the depths of the Milky Way began.\n\nIn Cosmic Era $799$, the two major military groups of the galaxy went to war in the Barmilian starfield. The \"Taishan Yading\" Group dispatched fleet commander Reinhard with more than $100{,}000$ warships, while the \"Qitun Shanhe\" Group appointed Yang Wen-li to organize $30{,}000$ warships to meet the enemy.", "description": "Yang Wen-li excels at troop deployment and cleverly uses various tactics to win many battles with fewer forces, which inevitably led to some pride. In this decisive battle, he divided the battlefield of the Barmilian starfield into $30000$ columns, numbered $1, 2, \\ldots, 30000$ in order. Then, he numbered his warships $1, 2, \\ldots, 30000$, placing warship $i$ in column $i$, forming a \"single-file long snake\" formation to lure the enemy deeper. This is the initial formation. When the invading enemy arrives, Yang will repeatedly issue merge commands to concentrate most of the warships into a few columns for a dense attack. A merge command is `M i j`, meaning the entire warship queue containing warship $i$, as a whole (head at the front and tail at the back), is appended to the tail of the warship queue containing warship $j$. Clearly, a warship queue is composed of one or more warships that are in the same column. Executing a merge command will increase the size of a queue.\n\nHowever, the cunning Reinhard has already taken the strategic initiative. During the battle, through a vast intelligence network, he can eavesdrop on Yang’s fleet maneuver commands at any time.\n\nWhile Yang issues commands to maneuver the fleet, Reinhard will also issue query commands to promptly learn the current distribution of Yang’s warships: `C i j`. This command asks the computer whether Yang’s warships $i$ and $j$ are currently in the same column. If they are in the same column, it asks how many warships are placed between them.\n\nAs a seasoned senior programmer, you are required to write a program to process Yang’s commands and answer Reinhard’s queries.\n\nThe decisive battle has begun, and another page in the galaxy’s history has turned.", "inputFormat": "The first line contains an integer $T$ ($1 \\le T \\le 5 \\times 10^5$), indicating there are $T$ instructions in total.\n\nThen follow $T$ lines, each containing one instruction. There are two formats:\n\n1. `M i j`: $i$ and $j$ are two integers ($1 \\le i, j \\le 30000$), representing the warship IDs involved. This instruction is a fleet maneuver command issued by Yang that Reinhard has intercepted, and it is guaranteed that warships $i$ and $j$ are not in the same column.\n\n2. `C i j`: $i$ and $j$ are two integers ($1 \\le i, j \\le 30000$), representing the warship IDs involved. This instruction is a query issued by Reinhard.\n\nIt is guaranteed that in every instruction $i \\ne j$.", "outputFormat": "Process each input instruction in order:\n\n- If it is a fleet maneuver command issued by Yang, the fleet formation changes; your program should record the change but must not output anything.\n- If it is a query issued by Reinhard, output one line containing a single integer: if warships $i$ and $j$ are in the same column, output the number of warships placed strictly between them; otherwise, output $-1$.", "hint": "Sample explanation\n\nWarship position diagram: in the table, Arabic numerals denote warship IDs.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2002] 银河英雄传说", "background": "公元 $5801$ 年，地球居民迁至金牛座 $\\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。\n\n宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。", "description": "杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \\ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  \n\n然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。\n\n在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。\n\n作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。\n\n最终的决战已经展开，银河的历史又翻过了一页……", "inputFormat": "第一行有一个整数 $T$（$1 \\le T \\le 5 \\times 10^5$），表示总共有 $T$ 条指令。\n\n以下有 $T$ 行，每行有一条指令。指令有两种格式：\n\n1. `M i j`：$i$ 和 $j$ 是两个整数（$1 \\le i,j \\le 30000$），表示指令涉及的战舰编号。该指令是莱因哈特窃听到的杨威利发布的舰队调动指令，并且保证第 $i$ 号战舰与第 $j$ 号战舰不在同一列。\n\n2. `C i j`：$i$ 和 $j$ 是两个整数（$1 \\le i,j \\le 30000$），表示指令涉及的战舰编号。该指令是莱因哈特发布的询问指令。\n\n每条指令中都保证 $i\\neq j$。", "outputFormat": "依次对输入的每一条指令进行分析和处理：\n\n- 如果是杨威利发布的舰队调动指令，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息。\n- 如果是莱因哈特发布的询问指令，你的程序要输出一行，仅包含一个整数，表示在同一列上，第 $i$ 号战舰与第 $j$ 号战舰之间布置的战舰数目。如果第 $i$ 号战舰与第 $j$ 号战舰当前不在同一列上，则输出 $-1$。", "hint": "### 样例解释\n\n战舰位置图：表格中阿拉伯数字表示战舰编号。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)", "locale": "zh-CN"}}}
{"pid": "P1197", "type": "P", "difficulty": 4, "samples": [["8 13\n0 1\n1 6\n6 5\n5 0\n0 6\n1 2\n2 3\n3 4\n4 5\n7 1\n7 2\n7 6\n3 6\n5\n1\n6\n3\n5\n7\n", "1\n1\n1\n2\n3\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "并查集", "各省省选", "江苏", "连通块", "离线处理"], "title": "[JSOI2008] 星球大战", "background": null, "description": "很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治着整个星系。\n\n某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。\n\n但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。\n\n现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通块的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。", "inputFormat": "输入文件第一行包含两个整数 $n,m$，分别表示星球的数目和以太隧道的数目。星球用 $0 \\sim n-1$ 的整数编号。\n\n接下来的 $m$ 行，每行包括两个整数 $x,y$，表示星球 $x$ 和星球 $y$ 之间有“以太”隧道，可以直接通讯。\n\n接下来的一行为一个整数 $k$，表示将遭受攻击的星球的数目。\n\n接下来的 $k$ 行，每行有一个整数，按照顺序列出了帝国军的攻击目标。这 $k$ 个数互不相同，且都在 $0$ 到 $n-1$ 的范围内。", "outputFormat": "第一行是开始时星球的连通块个数。接下来的 $k$ 行，每行一个整数，表示经过该次打击后现存星球的连通块个数。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\le m \\le 2\\times 10^5$，$1\\le n \\le 2m$，$x \\neq y$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2008] Star Wars", "background": "", "description": "A long time ago, in a galaxy far away, a dark empire ruled the entire galaxy with its superweapon.\n\nOne day, by a stroke of chance, a rebel force destroyed the empire’s superweapon and captured almost all the planets in the galaxy. These planets are directly or indirectly connected through special “aether” tunnels.\n\nBut the good times did not last. Soon, the empire rebuilt its superweapon. With its power, the empire began systematically destroying the planets occupied by the rebels. As more planets were destroyed, the communication channels between planets also became unreliable.\n\nNow, the leader of the rebels assigns you a task: given the original connectivity of the “aether” tunnels between planets and the order in which the empire attacks the planets, compute as quickly as possible the number of connected components of the planets occupied by the rebels after each strike. (If two planets can be connected directly or indirectly through the existing aether tunnels, then they are in the same connected component.)", "inputFormat": "The first line contains two integers $n,m$, the number of planets and the number of aether tunnels. The planets are numbered by integers $0 \\sim n-1$.\n\nEach of the next $m$ lines contains two integers $x,y$, indicating there is an “aether” tunnel between planet $x$ and planet $y$, allowing direct communication.\n\nThe next line contains an integer $k$, the number of planets that will be attacked.\n\nEach of the next $k$ lines contains one integer, listing the empire’s attack targets in order. These $k$ numbers are pairwise distinct and all lie in the range $0$ to $n-1$.", "outputFormat": "The first line contains the number of connected components of the planets at the beginning. Each of the next $k$ lines contains one integer, the number of connected components of the remaining planets after that strike.", "hint": "**Constraints**\n\nFor $100\\%$ of the testdata, $1\\le m \\le 2\\times 10^5$, $1\\le n \\le 2m$, $x \\neq y$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2008] 星球大战", "background": null, "description": "很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治着整个星系。\n\n某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。\n\n但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。\n\n现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通块的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。", "inputFormat": "输入文件第一行包含两个整数 $n,m$，分别表示星球的数目和以太隧道的数目。星球用 $0 \\sim n-1$ 的整数编号。\n\n接下来的 $m$ 行，每行包括两个整数 $x,y$，表示星球 $x$ 和星球 $y$ 之间有“以太”隧道，可以直接通讯。\n\n接下来的一行为一个整数 $k$，表示将遭受攻击的星球的数目。\n\n接下来的 $k$ 行，每行有一个整数，按照顺序列出了帝国军的攻击目标。这 $k$ 个数互不相同，且都在 $0$ 到 $n-1$ 的范围内。", "outputFormat": "第一行是开始时星球的连通块个数。接下来的 $k$ 行，每行一个整数，表示经过该次打击后现存星球的连通块个数。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\le m \\le 2\\times 10^5$，$1\\le n \\le 2m$，$x \\neq y$。", "locale": "zh-CN"}}}
{"pid": "P1198", "type": "P", "difficulty": 4, "samples": [["5 100\nA 96\nQ 1\nA 97\nQ 1\nQ 2\n", "96\n93\n96\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "线段树", "二分", "各省省选", "江苏", "栈", "ST 表", "单调栈"], "title": "[JSOI2008] 最大数", "background": "", "description": "现在请求你维护一个数列，要求提供以下两种操作：\n\n1.  查询操作。\n\n语法：`Q L`\n\n功能：查询当前数列中末尾 $L$ 个数中的最大的数，并输出这个数的值。\n\n限制：$L$ 不超过当前数列的长度。$(L > 0)$\n\n2. 插入操作。\n\n语法：`A n`\n\n功能：将 $n$ 加上 $t$，其中 $t$ 是最近一次查询操作的答案（如果还未执行过查询操作，则 $t=0$），并将所得结果对一个固定的常数 $D$ 取模，将所得答案插入到数列的末尾。\n\n限制：$n$ 是整数（可能为负数）并且在长整范围内。\n\n注意：初始时数列是空的，没有一个数。\n", "inputFormat": "第一行两个整数，$M$ 和 $D$，其中 $M$ 表示操作的个数，$D$ 如上文中所述。\n\n接下来的 $M$ 行，每行一个字符串，描述一个具体的操作。语法如上文所述。", "outputFormat": "对于每一个查询操作，你应该按照顺序依次输出结果，每个结果占一行。\n", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq M \\leq 2 \\times 10^5$，$1 \\leq D \\leq 2 \\times 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2008] Maximum Number", "background": "", "description": "You are asked to maintain a sequence and support the following two operations:\n\n1. Query operation.\n\nSyntax: `Q L`\n\nFunction: Query the maximum number among the last $L$ numbers in the current sequence, and output its value.\n\nConstraint: $L$ does not exceed the current length of the sequence. $(L > 0)$\n\n2. Insert operation.\n\nSyntax: `A n`\n\nFunction: Add $t$ to $n$, where $t$ is the answer to the most recent query operation (if no query has been performed yet, then $t = 0$). Then take the result modulo a fixed constant $D$, and insert the obtained value at the end of the sequence.\n\nConstraint: $n$ is an integer (possibly negative) and within the 64-bit signed integer range.\n\nNote: Initially, the sequence is empty and contains no numbers.", "inputFormat": "The first line contains two integers, $M$ and $D$, where $M$ is the number of operations and $D$ is the fixed constant mentioned above.\n\nEach of the next $M$ lines contains one string describing a specific operation, with syntax as described above.", "outputFormat": "For each query operation, output the result in order, one per line.", "hint": "Constraints\n\nFor all testdata, it is guaranteed that $1 \\leq M \\leq 2 \\times 10^5$, $1 \\leq D \\leq 2 \\times 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2008] 最大数", "background": "", "description": "现在请求你维护一个数列，要求提供以下两种操作：\n\n1.  查询操作。\n\n语法：`Q L`\n\n功能：查询当前数列中末尾 $L$ 个数中的最大的数，并输出这个数的值。\n\n限制：$L$ 不超过当前数列的长度。$(L > 0)$\n\n2. 插入操作。\n\n语法：`A n`\n\n功能：将 $n$ 加上 $t$，其中 $t$ 是最近一次查询操作的答案（如果还未执行过查询操作，则 $t=0$），并将所得结果对一个固定的常数 $D$ 取模，将所得答案插入到数列的末尾。\n\n限制：$n$ 是整数（可能为负数）并且在长整范围内。\n\n注意：初始时数列是空的，没有一个数。\n", "inputFormat": "第一行两个整数，$M$ 和 $D$，其中 $M$ 表示操作的个数，$D$ 如上文中所述。\n\n接下来的 $M$ 行，每行一个字符串，描述一个具体的操作。语法如上文所述。", "outputFormat": "对于每一个查询操作，你应该按照顺序依次输出结果，每个结果占一行。\n", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq M \\leq 2 \\times 10^5$，$1 \\leq D \\leq 2 \\times 10^9$。", "locale": "zh-CN"}}}
{"pid": "P1199", "type": "P", "difficulty": 3, "samples": [["6 \n5 28 16 29 27 \n23 3 20 1 \n8 32 26 \n33 11 \n12 \n", "1\n32\n\n"], ["8 \n42 24 10 29 27 12 58 \n31 8 16 26 80 6 \n25 3 36 11 5 \n33 20 17 13 \n15 77 9 \n4 50 \n19 ", "1\n77"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "博弈论", "2010", "NOIP 普及组"], "title": "[NOIP 2010 普及组] 三国游戏", "background": null, "description": "小涵很喜欢电脑游戏，这些天他正在玩一个叫做《三国》的游戏。\n\n在游戏中，小涵和计算机各执一方，组建各自的军队进行对战。游戏中共有 $N$ 位武将（$N$ 为偶数且不小于 $4$），任意两个武将之间有一个“默契值”，表示若此两位武将作为一对组合作战时，该组合的威力有多大。游戏开始前，所有武将都是自由的（称为自由武将，一旦某个自由武将被选中作为某方军队的一员，那么他就不再是自由武将了），换句话说，所谓的自由武将不属于任何一方。\n\n游戏开始，小涵和计算机要从自由武将中挑选武将组成自己的军队，规则如下：小涵先从自由武将中选出一个加入自己的军队，然后计算机也从自由武将中选出一个加入计算机方的军队。接下来一直按照“小涵 $\\to$ 计算机 $\\to$ 小涵 $\\to\\dots$ ”的顺序选择武将，直到所有的武将被双方均分完。然后，程序自动从双方军队中各挑出一对默契值最高的武将组合代表自己的军队进行二对二比武，拥有更高默契值的一对武将组合获胜，表示两军交战，拥有获胜武将组合的一方获胜。\n\n已知计算机一方选择武将的原则是尽量破坏对手下一步将形成的最强组合，它采取的具体策略如下：任何时刻，轮到计算机挑选时，它会尝试将对手军队中的每个武将与当前每个自由武将进行一一配对，找出所有配对中默契值最高的那对武将组合，并将该组合中的自由武将选入自己的军队。 下面举例说明计算机的选将策略，例如，游戏中一共有 $6$ 个武将，他们相互之间的默契值如下表所示：\n\n| 武将编号 |  1   |  2   |  3   |  4   |  5   |  6   |\n| :------: | :--: | :--: | :--: | :--: | :--: | :--: |\n|  **1**   |      | $5$  | $28$ | $16$ | $29$ | $27$ |\n|  **2**   | $5$  |      | $23$ | $3$  | $20$ | $1$  |\n|  **3**   | $28$ | $23$ |      | $8$  | $32$ | $26$ |\n|  **4**   | $16$ | $3$  | $8$  |      | $33$ | $11$ |\n|  **5**   | $29$ | $20$ | $32$ | $33$ |      | $12$ |\n|  **6**   | $27$ | $1$  | $26$ | $11$ | $12$ |      |\n\n双方选将过程如下所示：\n\n|        | 小涵 | 轮到计算机时可选的自由武将 |  计算机    |  计算机选将说明    |\n| :----: | :--: | :----------: | :--: | :--: |\n| 第一轮 | $5$ | $1,2,3,4,6$ | $\\color{magenta}4$ | 小涵手中的 $5$ 号武将与 $4$ 号的默契值最高，所以计算机选择 $4$ 号。 |\n| 第二轮 | $5,3$ | $1,2,6$ | $4,\\color{magenta}1$ |  小涵手中的 $5$ 号和 $3$ 号武将与自由武将中配对可产生的最大默契值为 $29$，是由 $5$ 号与 $1$ 号配对产生的，所以计算机选择 $1$ 号。  |\n| 第三轮 | $5,3,6$ | $2$ | $4,1,\\color{magenta}2$ |      |\n\n小涵想知道，如果计算机在一局游戏中始终坚持上面这个策略，那么自己有没有可能必胜？如果有，在所有可能的胜利结局中，自己那对用于比武的武将组合的默契值最大是多少？  \n\n假设整个游戏过程中，对战双方任何时候均能看到自由武将队中的武将和对方军队的武将。为了简化问题，保证对于不同的武将组合，其默契值均不相同。", "inputFormat": "共 $N$ 行。\n\n第一行为一个偶数 $N$，表示武将的个数。\n\n第 $2$ 行到第 $N$ 行里，第 $i+1$ 行有 $N-i$ 个非负整数，每两个数之间用一个空格隔开，表示 $i$ 号武将和 $i+1,i+2,\\dots,N $ 号武将之间的默契值（$0 \\le \\text{默契值} \\le 10^9$）。", "outputFormat": "共一或二行。\n\n若对于给定的游戏输入，存在可以让小涵获胜的选将顺序，则输出 $ 1$，并另起一行输出所有获胜的情况中，小涵最终选出的武将组合的最大默契值。如果不存在可以让小涵获胜的选将顺序，则输出 $0$。", "hint": "**数据范围**\n\n对于 $ 40\\%$ 的数据有 $N≤10$。\n\n对于 $ 70\\%$ 的数据有 $ N≤18$。\n\n对于 $100\\%$ 的数据有 $4\\le N≤500$。保证对于不同的武将组合，其默契值均不相同。\n\nNOIP2010 普及组 第四题", "locale": "zh-CN", "translations": {"en": {"title": "{{[NOIP 2010 Junior] Three Kingdoms Game}}", "background": "{{}}", "description": "{{Xiaohan loves computer games, and these days he is playing a game called \"Three Kingdoms.\"\n\nIn the game, Xiaohan and the computer control opposing sides, each assembling their own army to battle. There are $ N $ generals in total (where $ N $ is even and at least $ 4 $). Between any two generals there is a \"synergy value,\" indicating how powerful a pair would be if they fight together. Before the game starts, all generals are free (called free generals; once a free general is chosen as a member of a side's army, he is no longer a free general). In other words, free generals do not belong to any side.\n\nWhen the game begins, Xiaohan and the computer take turns selecting generals from the free generals to form their armies, following these rules: Xiaohan first selects one free general to join his army, then the computer selects one free general to join the computer's army. They continue selecting in the order \"Xiaohan → computer → Xiaohan → …\" until all generals are evenly split between the two sides. Then, the program automatically selects from each army the pair of generals with the highest synergy value to represent that army in a two-on-two duel. The side whose pair has the higher synergy value wins the duel; that side wins the battle.\n\nIt is known that the computer's principle for choosing is to disrupt the opponent's strongest possible pair on the opponent's next move as much as possible. Its specific strategy is as follows: whenever it is the computer's turn, it tries pairing each general already in the opponent's army with each current free general, finds the pair with the highest synergy value among all such pairings, and then picks the free general from that pair into its own army. For example, suppose there are $ 6 $ generals in total, and their pairwise synergy values are as shown below:\n\n| General ID |  1   |  2   |  3   |  4   |  5   |  6   |\n| :--------: | :--: | :--: | :--: | :--: | :--: | :--: |\n|   **1**    |      | $5$  | $28$ | $16$ | $29$ | $27$ |\n|   **2**    | $5$  |      | $23$ | $3$  | $20$ | $1$  |\n|   **3**    | $28$ | $23$ |      | $8$  | $32$ | $26$ |\n|   **4**    | $16$ | $3$  | $8$  |      | $33$ | $11$ |\n|   **5**    | $29$ | $20$ | $32$ | $33$ |      | $12$ |\n|   **6**    | $27$ | $1$  | $26$ | $11$ | $12$ |      |\n\nThe selection process is as follows:\n\n|        | Xiaohan | Free generals available to the computer on its turn | Computer | Computer's choice explanation |\n| :----: | :-----: | :-------------------------------------------------: | :------: | :---------------------------: |\n| Round 1 | $5$ | $1,2,3,4,6$ | $\\color{magenta}4$ | The synergy value between Xiaohan's $5$ and $4$ is the highest, so the computer selects $4$. |\n| Round 2 | $5,3$ | $1,2,6$ | $4,\\color{magenta}1$ | The maximum synergy value that can be formed by pairing Xiaohan's $5$ and $3$ with a free general is $29$, produced by pairing $5$ with $1$, so the computer selects $1$. |\n| Round 3 | $5,3,6$ | $2$ | $4,1,\\color{magenta}2$ |  |\n\nXiaohan wants to know: if the computer always sticks to the above strategy in a game, is it possible for him to force a win? If yes, among all possible winning outcomes, what is the maximum synergy value of the pair of generals he finally uses for the duel?\n\nAssume that throughout the game, both sides can always see the free generals and the opponent's chosen generals. To simplify the problem, it is guaranteed that for different pairs of generals, their synergy values are all distinct.}}", "inputFormat": "{{A total of $ N $ lines.\n\nThe first line contains an even integer $ N $, the number of generals.\n\nFrom the $ 2 $-nd line to the $ N $-th line, line $ i+1 $ contains $ N-i $ non-negative integers separated by single spaces, representing the synergy values between general $ i $ and generals $ i+1,i+2,\\dots,N $ ($0 \\le \\text{默契值} \\le 10^9$).}}", "outputFormat": "{{One or two lines in total.\n\nIf there exists a selection sequence that allows Xiaohan to win for the given input, output $ 1$, and on the next line output the maximum synergy value of Xiaohan's final chosen pair among all winning cases. If no such selection sequence exists, output $0$.}}", "hint": "{{Constraints\n\nFor $ 40\\% $ of the testdata, $N≤10$.\n\nFor $ 70\\% $ of the testdata, $ N≤18$.\n\nFor $ 100\\% $ of the testdata, $4\\le N≤500$. It is guaranteed that for different pairs of generals, their synergy values are all distinct.\n\nNOIP 2010 Junior Problem 4.}}\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2010 普及组] 三国游戏", "background": null, "description": "小涵很喜欢电脑游戏，这些天他正在玩一个叫做《三国》的游戏。\n\n在游戏中，小涵和计算机各执一方，组建各自的军队进行对战。游戏中共有 $N$ 位武将（$N$ 为偶数且不小于 $4$），任意两个武将之间有一个“默契值”，表示若此两位武将作为一对组合作战时，该组合的威力有多大。游戏开始前，所有武将都是自由的（称为自由武将，一旦某个自由武将被选中作为某方军队的一员，那么他就不再是自由武将了），换句话说，所谓的自由武将不属于任何一方。\n\n游戏开始，小涵和计算机要从自由武将中挑选武将组成自己的军队，规则如下：小涵先从自由武将中选出一个加入自己的军队，然后计算机也从自由武将中选出一个加入计算机方的军队。接下来一直按照“小涵 $\\to$ 计算机 $\\to$ 小涵 $\\to\\dots$ ”的顺序选择武将，直到所有的武将被双方均分完。然后，程序自动从双方军队中各挑出一对默契值最高的武将组合代表自己的军队进行二对二比武，拥有更高默契值的一对武将组合获胜，表示两军交战，拥有获胜武将组合的一方获胜。\n\n已知计算机一方选择武将的原则是尽量破坏对手下一步将形成的最强组合，它采取的具体策略如下：任何时刻，轮到计算机挑选时，它会尝试将对手军队中的每个武将与当前每个自由武将进行一一配对，找出所有配对中默契值最高的那对武将组合，并将该组合中的自由武将选入自己的军队。 下面举例说明计算机的选将策略，例如，游戏中一共有 $6$ 个武将，他们相互之间的默契值如下表所示：\n\n| 武将编号 |  1   |  2   |  3   |  4   |  5   |  6   |\n| :------: | :--: | :--: | :--: | :--: | :--: | :--: |\n|  **1**   |      | $5$  | $28$ | $16$ | $29$ | $27$ |\n|  **2**   | $5$  |      | $23$ | $3$  | $20$ | $1$  |\n|  **3**   | $28$ | $23$ |      | $8$  | $32$ | $26$ |\n|  **4**   | $16$ | $3$  | $8$  |      | $33$ | $11$ |\n|  **5**   | $29$ | $20$ | $32$ | $33$ |      | $12$ |\n|  **6**   | $27$ | $1$  | $26$ | $11$ | $12$ |      |\n\n双方选将过程如下所示：\n\n|        | 小涵 | 轮到计算机时可选的自由武将 |  计算机    |  计算机选将说明    |\n| :----: | :--: | :----------: | :--: | :--: |\n| 第一轮 | $5$ | $1,2,3,4,6$ | $\\color{magenta}4$ | 小涵手中的 $5$ 号武将与 $4$ 号的默契值最高，所以计算机选择 $4$ 号。 |\n| 第二轮 | $5,3$ | $1,2,6$ | $4,\\color{magenta}1$ |  小涵手中的 $5$ 号和 $3$ 号武将与自由武将中配对可产生的最大默契值为 $29$，是由 $5$ 号与 $1$ 号配对产生的，所以计算机选择 $1$ 号。  |\n| 第三轮 | $5,3,6$ | $2$ | $4,1,\\color{magenta}2$ |      |\n\n小涵想知道，如果计算机在一局游戏中始终坚持上面这个策略，那么自己有没有可能必胜？如果有，在所有可能的胜利结局中，自己那对用于比武的武将组合的默契值最大是多少？  \n\n假设整个游戏过程中，对战双方任何时候均能看到自由武将队中的武将和对方军队的武将。为了简化问题，保证对于不同的武将组合，其默契值均不相同。", "inputFormat": "共 $N$ 行。\n\n第一行为一个偶数 $N$，表示武将的个数。\n\n第 $2$ 行到第 $N$ 行里，第 $i+1$ 行有 $N-i$ 个非负整数，每两个数之间用一个空格隔开，表示 $i$ 号武将和 $i+1,i+2,\\dots,N $ 号武将之间的默契值（$0 \\le \\text{默契值} \\le 10^9$）。", "outputFormat": "共一或二行。\n\n若对于给定的游戏输入，存在可以让小涵获胜的选将顺序，则输出 $ 1$，并另起一行输出所有获胜的情况中，小涵最终选出的武将组合的最大默契值。如果不存在可以让小涵获胜的选将顺序，则输出 $0$。", "hint": "**数据范围**\n\n对于 $ 40\\%$ 的数据有 $N≤10$。\n\n对于 $ 70\\%$ 的数据有 $ N≤18$。\n\n对于 $100\\%$ 的数据有 $4\\le N≤500$。保证对于不同的武将组合，其默契值均不相同。\n\nNOIP2010 普及组 第四题", "locale": "zh-CN"}}}
{"pid": "P1200", "type": "P", "difficulty": 1, "samples": [["COMETQ\nHVNGAT", "GO"], ["ABSTAR\nUSACO", "STAY"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "数学", "USACO"], "title": "[USACO1.1] 你的飞碟在这儿 Your Ride Is Here", "background": null, "description": "众所周知，在每一个彗星后都有一只 UFO。这些 UFO 时常来收集地球上的忠诚支持者。不幸的是，他们的飞碟每次出行都只能带上一组支持者。因此，他们要用一种聪明的方案让这些小组提前知道谁会被彗星带走。他们为每个彗星起了一个名字，通过这些名字来决定这个小组是不是被带走的那个特定的小组（你认为是谁给这些彗星取的名字呢？）。关于如何搭配的细节会在下面告诉你；你的任务是写一个程序，通过小组名和彗星名来决定这个小组是否能被那颗彗星后面的 UFO 带走。\n\n\n小组名和彗星名都以下列方式转换成一个数字：最终的数字就是名字中所有字母的积，其中 $\\texttt A$ 是 $1$，$\\texttt Z$ 是 $26$。例如，$\\texttt{USACO}$ 小组就是 $21 \\times 19 \\times 1 \\times 3 \\times 15=17955$。如果小组的数字 $\\bmod 47$ 等于彗星的数字 $\\bmod 47$，你就得告诉这个小组需要准备好被带走！（记住“$a \\bmod b$”是 $a$ 除以 $b$ 的余数，例如 $34 \\bmod 10$ 等于 $4$）\n\n\n写出一个程序，读入彗星名和小组名并算出用上面的方案能否将两个名字搭配起来，如果能搭配，就输出 `GO`，否则输出 `STAY`。小组名和彗星名均是没有空格或标点的一串大写字母（不超过 $6$ 个字母）。", "inputFormat": "第 1 行：一个长度为 $1$ 到 $6$ 的大写字母串，表示彗星的名字。\n\n第 2 行：一个长度为 $1$ 到 $6$ 的大写字母串，表示队伍的名字。", "outputFormat": null, "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 1.1", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.1] Your Ride Is Here", "background": null, "description": "As everyone knows, there is a UFO behind every comet. These UFOs often come to gather loyal supporters on Earth. Unfortunately, their saucer can take only one group of supporters on each trip. Therefore, they use a clever scheme to let the groups know in advance who will be taken by a comet. They give each comet a name and use these names to decide whether a particular group is the one to be taken (who do you think names these comets?). The details of how to match are given below; your task is to write a program that, given a group name and a comet name, decides whether the group will be taken by the UFO behind that comet.\n\nBoth the group name and the comet name are converted into a number as follows: the final number is the product of the values of all letters in the name, where $\\texttt A$ is $1$ and $\\texttt Z$ is $26$. For example, the group $\\texttt{USACO}$ yields $21 \\times 19 \\times 1 \\times 3 \\times 15 = 17955$. If the group’s number $\\bmod 47$ equals the comet’s number $\\bmod 47$, you should tell the group to get ready to go! (Remember that \"$a \\bmod b$\" is the remainder when $a$ is divided by $b$; for example, $34 \\bmod 10$ equals $4$.)\n\nWrite a program that reads the comet name and the group name and determines whether the two names match under the scheme above. If they match, output `GO`; otherwise, output `STAY`. Both the group name and the comet name are strings of uppercase letters with no spaces or punctuation (at most $6$ letters).", "inputFormat": "Line 1: An uppercase string of length $1$ to $6$, the comet's name.\n\nLine 2: An uppercase string of length $1$ to $6$, the group's name.", "outputFormat": null, "hint": "Problem translation from NOCOW.\n\nUSACO Training Section 1.1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.1] 你的飞碟在这儿 Your Ride Is Here", "background": null, "description": "众所周知，在每一个彗星后都有一只 UFO。这些 UFO 时常来收集地球上的忠诚支持者。不幸的是，他们的飞碟每次出行都只能带上一组支持者。因此，他们要用一种聪明的方案让这些小组提前知道谁会被彗星带走。他们为每个彗星起了一个名字，通过这些名字来决定这个小组是不是被带走的那个特定的小组（你认为是谁给这些彗星取的名字呢？）。关于如何搭配的细节会在下面告诉你；你的任务是写一个程序，通过小组名和彗星名来决定这个小组是否能被那颗彗星后面的 UFO 带走。\n\n\n小组名和彗星名都以下列方式转换成一个数字：最终的数字就是名字中所有字母的积，其中 $\\texttt A$ 是 $1$，$\\texttt Z$ 是 $26$。例如，$\\texttt{USACO}$ 小组就是 $21 \\times 19 \\times 1 \\times 3 \\times 15=17955$。如果小组的数字 $\\bmod 47$ 等于彗星的数字 $\\bmod 47$，你就得告诉这个小组需要准备好被带走！（记住“$a \\bmod b$”是 $a$ 除以 $b$ 的余数，例如 $34 \\bmod 10$ 等于 $4$）\n\n\n写出一个程序，读入彗星名和小组名并算出用上面的方案能否将两个名字搭配起来，如果能搭配，就输出 `GO`，否则输出 `STAY`。小组名和彗星名均是没有空格或标点的一串大写字母（不超过 $6$ 个字母）。", "inputFormat": "第 1 行：一个长度为 $1$ 到 $6$ 的大写字母串，表示彗星的名字。\n\n第 2 行：一个长度为 $1$ 到 $6$ 的大写字母串，表示队伍的名字。", "outputFormat": null, "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 1.1", "locale": "zh-CN"}}}
{"pid": "P1201", "type": "P", "difficulty": 2, "samples": [["5\ndave\nlaura\nowen\nvick\namr\ndave\n200 3\nlaura\nowen\nvick\nowen\n500 1\ndave\namr\n150 2\nvick\nowen\nlaura\n0 2\namr\nvick\nvick\n0 0\n", "dave 302\nlaura 66\nowen -359\nvick 141\namr -150\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "USACO"], "title": "[USACO1.1] 贪婪的送礼者 Greedy Gift Givers", "background": null, "description": "对于一群 $n$ 个要互送礼物的朋友，GY 要确定每个人送出的钱比收到的多多少。在这一个问题中，每个人都准备了一些钱来送礼物，而这些钱将会被平均分给那些将收到他的礼物的人。  \n\n然而，在任何一群朋友中，有些人将送出较多的礼物(可能是因为有较多的朋友)，有些人有准备了较多的钱。  \n\n给出一群朋友，没有人的名字会长于 $14$ 字符，给出每个人将花在送礼上的钱，和将收到他的礼物的人的列表，请确定每个人收到的比送出的钱多的数目。", "inputFormat": "第一行一个正整数 $n$，表示人数。\n接下来 $n$ 行，每行一个字符串表示人名。\n\n接下来有 $n$ 段内容，对于每一段：\n第一行是将会送出礼物人的名字。  \n第二行包含二个非负整数，第一个是原有的钱的数目 ( $\\in [0,2000]$ )，第二个 $g_i$ 是将收到这个人礼物的人的个数 如果 $g_i \\neq 0$, 在下面 $g_i$ 行列出礼物的接受者的名字，一个名字一行。", "outputFormat": "输出共 $n$ 行，每行输出一个人的名字和该人收到的钱比送出的钱多的数目。名字的顺序应该与输入第 $ 2 $ 行至 $ n+1 $ 行的顺序相同。\n\n送出的钱永远是整数，即假设送礼人一次向 $ m $ 人送出 $ n $ 元，每个人应该得到 $ \\lfloor n/m \n\\rfloor $ 元。剩余未送出的钱应返还给送礼者。", "hint": "【数据范围】  \n$1\\le n \\le 10$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.1", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.1] Greedy Gift Givers", "background": "", "description": "In a group of $n$ friends who exchange gifts, GY wants to determine, for each person, how much more money they received than they gave.\n\nIn this problem, each person prepares some money for gifts, and that money is evenly divided among the people who will receive gifts from them.\n\nHowever, in any group of friends, some people will give gifts to more recipients (perhaps because they have more friends), and some people prepare more money.\n\nGiven a group of friends (no name is longer than 14 characters), along with how much each person spends on gifts and the list of recipients for each giver, determine for each person the amount of money received minus the amount of money given.", "inputFormat": "- The first line contains a positive integer $n$, the number of people.\n- The next $n$ lines each contain a string, the name of a person.\n\nThen there are $n$ blocks. For each block:\n- The first line is the name of the person who will give gifts.\n- The second line contains two non-negative integers: the first is the initial amount of money in $[0, 2000]$, and the second is $g_i$, the number of recipients of this person's gifts.  \n  If $g_i \\neq 0$, the next $g_i$ lines list the recipients' names, one per line.", "outputFormat": "Output $n$ lines. Each line contains a person's name and the amount of money they received minus the amount they gave. The order of names must be the same as in lines 2 through $n+1$ of the input.\n\nThe amount given out is always an integer. Specifically, suppose a giver distributes $n$ dollars to $m$ people at once; then each person should receive $\\lfloor n/m \\rfloor$ dollars. Any leftover money is returned to the giver.", "hint": "Constraints  \n$1 \\le n \\le 10$.\n\nTranslation adapted from NOCOW.  \nUSACO Training Section 1.1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.1] 贪婪的送礼者 Greedy Gift Givers", "background": null, "description": "对于一群 $n$ 个要互送礼物的朋友，GY 要确定每个人送出的钱比收到的多多少。在这一个问题中，每个人都准备了一些钱来送礼物，而这些钱将会被平均分给那些将收到他的礼物的人。  \n\n然而，在任何一群朋友中，有些人将送出较多的礼物(可能是因为有较多的朋友)，有些人有准备了较多的钱。  \n\n给出一群朋友，没有人的名字会长于 $14$ 字符，给出每个人将花在送礼上的钱，和将收到他的礼物的人的列表，请确定每个人收到的比送出的钱多的数目。", "inputFormat": "第一行一个正整数 $n$，表示人数。\n接下来 $n$ 行，每行一个字符串表示人名。\n\n接下来有 $n$ 段内容，对于每一段：\n第一行是将会送出礼物人的名字。  \n第二行包含二个非负整数，第一个是原有的钱的数目 ( $\\in [0,2000]$ )，第二个 $g_i$ 是将收到这个人礼物的人的个数 如果 $g_i \\neq 0$, 在下面 $g_i$ 行列出礼物的接受者的名字，一个名字一行。", "outputFormat": "输出共 $n$ 行，每行输出一个人的名字和该人收到的钱比送出的钱多的数目。名字的顺序应该与输入第 $ 2 $ 行至 $ n+1 $ 行的顺序相同。\n\n送出的钱永远是整数，即假设送礼人一次向 $ m $ 人送出 $ n $ 元，每个人应该得到 $ \\lfloor n/m \n\\rfloor $ 元。剩余未送出的钱应返还给送礼者。", "hint": "【数据范围】  \n$1\\le n \\le 10$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.1", "locale": "zh-CN"}}}
{"pid": "P1202", "type": "P", "difficulty": 2, "samples": [["20\n", "36 33 34 33 35 35 34\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "数学", "USACO"], "title": "[USACO1.1] 黑色星期五 Friday the Thirteenth", "background": null, "description": "$13$ 号又是一个星期五，那么 $13$ 号在星期五比在其他日子少吗？  \n\n为了回答这个问题，写一个程序，要求计算每个月的十三号落在周一到周日的次数。给出 $n$ 年的一个周期，要求计算 $1900$ 年 $1$ 月 $1$ 日至 $1900+n-1$ 年 $12$ 月 $31$ 日中十三号落在周一到周日的次数。\n\n这里有一些你要知道的：\n1. $1900$ 年 $1$ 月 $1$ 日是星期一。\n2. $4,6,9$ 和 $11$ 月有 $30$ 天，其他月份除了 $2$ 月都有 $31$ 天，闰年 $2$ 月有 $29$ 天，平年 $2$ 月有 $28$ 天。\n3. 年份可以被 $4$ 整除的为闰年（$1992=4\\times 498$ 所以 $1992$ 年是闰年，但是 $1990$ 年不是闰年）。\n4. 以上规则不适合于世纪年。可以被 $400$ 整除的世纪年为闰年，否则为平年。所以，$1700,1800,1900,2100$ 年是平年，而 $2000$ 年是闰年。", "inputFormat": "一个正整数 $n$。", "outputFormat": "依次输出周六、日、一、二、三、四、五在 $13$ 日出现的次数。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 400$。\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 1.1", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.1] Friday the Thirteenth", "background": "", "description": "It is Friday the $13$th again. Does the $13$th fall on Friday less often than on other days?\n\nTo answer this question, write a program that counts, for each month, how many times the $13$th falls on each day of the week. Given a period of $n$ years, compute the counts for dates from January $1$, $1900$ to December $31$, $1900 + n - 1$.\n\nHere are some things you need to know:\n1. January $1$, $1900$ was a Monday.\n2. Months $4$, $6$, $9$ and $11$ have $30$ days; all other months except month $2$ have $31$ days. In a leap year, February has $29$ days; in a common year, February has $28$ days.\n3. A year divisible by $4$ is a leap year ($1992 = 4 \\times 498$, so $1992$ is a leap year, but $1990$ is not).\n4. The above rule does not apply to century years. A century year divisible by $400$ is a leap year; otherwise, it is a common year. Thus, $1700$, $1800$, $1900$, and $2100$ are common years, while $2000$ is a leap year.", "inputFormat": "A single positive integer $n$.", "outputFormat": "Output, in order, the counts of Saturday, Sunday, Monday, Tuesday, Wednesday, Thursday, and Friday on which the $13$th occurs. Print them on one line, separated by spaces.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n \\le 400$.\n\nTranslation from NOCOW.  \nUSACO Training Section $1.1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.1] 黑色星期五 Friday the Thirteenth", "background": null, "description": "$13$ 号又是一个星期五，那么 $13$ 号在星期五比在其他日子少吗？  \n\n为了回答这个问题，写一个程序，要求计算每个月的十三号落在周一到周日的次数。给出 $n$ 年的一个周期，要求计算 $1900$ 年 $1$ 月 $1$ 日至 $1900+n-1$ 年 $12$ 月 $31$ 日中十三号落在周一到周日的次数。\n\n这里有一些你要知道的：\n1. $1900$ 年 $1$ 月 $1$ 日是星期一。\n2. $4,6,9$ 和 $11$ 月有 $30$ 天，其他月份除了 $2$ 月都有 $31$ 天，闰年 $2$ 月有 $29$ 天，平年 $2$ 月有 $28$ 天。\n3. 年份可以被 $4$ 整除的为闰年（$1992=4\\times 498$ 所以 $1992$ 年是闰年，但是 $1990$ 年不是闰年）。\n4. 以上规则不适合于世纪年。可以被 $400$ 整除的世纪年为闰年，否则为平年。所以，$1700,1800,1900,2100$ 年是平年，而 $2000$ 年是闰年。", "inputFormat": "一个正整数 $n$。", "outputFormat": "依次输出周六、日、一、二、三、四、五在 $13$ 日出现的次数。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 400$。\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 1.1", "locale": "zh-CN"}}}
{"pid": "P1203", "type": "P", "difficulty": 2, "samples": [["29 \nwwwbbrwrbrbrrbrbrwrwwrbwrwrrb\n", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP", "搜索", "USACO", "单调队列", "IOI"], "title": "[IOI 1993 / USACO1.1] 坏掉的项链 Broken Necklace", "background": null, "description": "你有一条由 $n$ 个红色的，白色的，或蓝色的珠子组成的项链，珠子是随意安排的。这里是 $n=29$ 的两个例子:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i7imvc0g.png) \n\n第一和第二个珠子在图片中已经被作记号。\n\n图片 A 中的项链可以用下面的字符串表示：`brbrrrbbbrrrrrbrrbbrbbbbrrrrb`\n\n假如你要在一些点打破项链，展开成一条直线，然后从一端开始收集同颜色的珠子直到你遇到一个不同的颜色珠子，在另一端做同样的事（颜色可能与在这之前收集的不同）。确定应该在哪里打破项链来收集到最大数目的珠子。\n\n例如，在图片 A 中的项链中，在珠子 $9$ 和珠子 $10$ 或珠子 $24$ 和珠子 $25$ 之间打断项链可以收集到 $8$ 个珠子。\n\n表现含有白珠项链的字符串将会包括三个符号 `r`，`b`，`w`。\n\n写一个程序来确定从一条被给出的项链可以收集到的珠子最大数目。\n\n::::info[白色珠子是什么？]\n\n在一些项链中还包括白色的珠子（如图片 B）所示。\n\n当收集珠子的时候，一个被遇到的白色珠子可以被当做红色也可以被当做蓝色。\n::::", "inputFormat": "第一行一个正整数 $n$，表示珠子数目。\n\n第二行一串长度为 $n$ 的字符串，每个字符是 `r`，`b` 或 `w`。", "outputFormat": "输出一行一个整数，表示从给出的项链中可以收集到的珠子的最大数量。", "hint": "**【数据范围】** \n\n对于 $100\\%$ 的数据，$3\\le n \\le 350$。\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 1.1", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 1993 / USACO1.1] Broken Necklace", "background": null, "description": "You have a necklace made of $n$ beads that are red, white, or blue, arranged arbitrarily. Here are two examples for $n=29$:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i7imvc0g.png)\n\nThe first and second beads are marked in the picture.\n\nThe necklace in Figure A can be represented by the string: `brbrrrbbbrrrrrbrrbbrbbbbrrrrb`.\n\nSuppose you break the necklace at some point, lay it out in a line, then from one end start collecting beads of a single color until you encounter a bead of a different color, and do the same from the other end (the color you collect on the two sides may differ). Determine where to break the necklace to collect the maximum number of beads.\n\nFor example, for the necklace in Figure A, breaking between bead $9$ and bead $10$, or between bead $24$ and bead $25$, allows you to collect $8$ beads.\n\nA string representing a necklace that may include white beads will use exactly the three symbols `r`, `b`, `w`.\n\nWrite a program to determine the maximum number of beads that can be collected from the given necklace.\n\n::::info[白色珠子是什么？]\nIn some necklaces, there are also white beads (as in Figure B).\n\nWhen collecting beads, any white bead you encounter may be treated as red or as blue.\n::::", "inputFormat": "The first line contains a positive integer $n$, the number of beads.\n\nThe second line contains a string of length $n$, where each character is `r`, `b`, or `w`.", "outputFormat": "Output a single integer on one line: the maximum number of beads that can be collected from the given necklace.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $3\\le n \\le 350$.\n\nTranslated from NOCOW.\n\nUSACO Training Section 1.1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 1993 / USACO1.1] 坏掉的项链 Broken Necklace", "background": null, "description": "你有一条由 $n$ 个红色的，白色的，或蓝色的珠子组成的项链，珠子是随意安排的。这里是 $n=29$ 的两个例子:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i7imvc0g.png) \n\n第一和第二个珠子在图片中已经被作记号。\n\n图片 A 中的项链可以用下面的字符串表示：`brbrrrbbbrrrrrbrrbbrbbbbrrrrb`\n\n假如你要在一些点打破项链，展开成一条直线，然后从一端开始收集同颜色的珠子直到你遇到一个不同的颜色珠子，在另一端做同样的事（颜色可能与在这之前收集的不同）。确定应该在哪里打破项链来收集到最大数目的珠子。\n\n例如，在图片 A 中的项链中，在珠子 $9$ 和珠子 $10$ 或珠子 $24$ 和珠子 $25$ 之间打断项链可以收集到 $8$ 个珠子。\n\n表现含有白珠项链的字符串将会包括三个符号 `r`，`b`，`w`。\n\n写一个程序来确定从一条被给出的项链可以收集到的珠子最大数目。\n\n::::info[白色珠子是什么？]\n\n在一些项链中还包括白色的珠子（如图片 B）所示。\n\n当收集珠子的时候，一个被遇到的白色珠子可以被当做红色也可以被当做蓝色。\n::::", "inputFormat": "第一行一个正整数 $n$，表示珠子数目。\n\n第二行一串长度为 $n$ 的字符串，每个字符是 `r`，`b` 或 `w`。", "outputFormat": "输出一行一个整数，表示从给出的项链中可以收集到的珠子的最大数量。", "hint": "**【数据范围】** \n\n对于 $100\\%$ 的数据，$3\\le n \\le 350$。\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 1.1", "locale": "zh-CN"}}}
{"pid": "P1204", "type": "P", "difficulty": 2, "samples": [["3\n300 1000\n700 1200\n1500 2100\n", "900 300\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "线段树", "USACO", "排序", "差分"], "title": "[USACO1.2] 挤牛奶 Milking Cows", "background": null, "description": "三个农民每天清晨 $5$ 点起床，然后去牛棚给三头牛挤奶。\n\n第一个农民在 $300$ 秒（从 $5$ 点开始计时）给他的牛挤奶，一直到 $1000$ 秒。第二个农民在 $700$ 秒开始，在 $1200$ 秒结束。第三个农民在 $1500$ 秒开始，$2100$ 秒结束。  \n\n期间最长的至少有一个农民在挤奶的连续时间为 $900$ 秒（从 $300$ 秒到 $1200$ 秒），而最长的无人挤奶的连续时间（从挤奶开始一直到挤奶结束）为 $300$ 秒（从 $1200$ 秒到 $1500$ 秒）。\n\n---\n你的任务是编一个程序，读入一个有 $n$ 个农民挤 $n$ 头牛的工作时间列表，计算以下两点（均以秒为单位）：\n\n1. 最长至少有一人在挤奶的时间段。\n2. 最长的无人挤奶的时间段。（从有人挤奶开始算起）", "inputFormat": "第一行一个正整数 $n$。\n\n接下来 $n$ 行，每行两个非负整数 $l,r$，表示一个农民的开始时刻与结束时刻。", "outputFormat": "仅一行两个整数，以一个空格分隔，即题目所要求的两个答案。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 5000$，$0 \\le l \\le r \\le 10^6$。\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 1.2", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.2] Milking Cows", "background": "", "description": "Three farmers get up at $5$ a.m. every morning and go to the barn to milk three cows.\n\nThe first farmer starts milking at $300$ seconds (counted from $5$ o'clock) and continues until $1000$ seconds. The second farmer starts at $700$ seconds and ends at $1200$ seconds. The third farmer starts at $1500$ seconds and ends at $2100$ seconds.  \n\nThe longest continuous time during which at least one farmer is milking is $900$ seconds (from $300$ seconds to $1200$ seconds), and the longest continuous time during which no one is milking (from the beginning of any milking to the end of all milking) is $300$ seconds (from $1200$ seconds to $1500$ seconds).\n\nYour task is to write a program that reads a list of working times for $n$ farmers milking $n$ cows and computes the following two values (both in seconds):\n\n1. The longest interval during which at least one person is milking.\n2. The longest interval during which no one is milking (counted from when milking begins).", "inputFormat": "The first line contains a positive integer $n$.\n\nThe next $n$ lines each contain two non-negative integers $l, r$, representing one farmer’s start time and end time.", "outputFormat": "Output a single line with two integers separated by a single space: the two answers required by the problem.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n \\le 5000$, $0 \\le l \\le r \\le 10^6$.\n\nProblem translation from NOCOW.\n\nUSACO Training Section $1.2$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.2] 挤牛奶 Milking Cows", "background": null, "description": "三个农民每天清晨 $5$ 点起床，然后去牛棚给三头牛挤奶。\n\n第一个农民在 $300$ 秒（从 $5$ 点开始计时）给他的牛挤奶，一直到 $1000$ 秒。第二个农民在 $700$ 秒开始，在 $1200$ 秒结束。第三个农民在 $1500$ 秒开始，$2100$ 秒结束。  \n\n期间最长的至少有一个农民在挤奶的连续时间为 $900$ 秒（从 $300$ 秒到 $1200$ 秒），而最长的无人挤奶的连续时间（从挤奶开始一直到挤奶结束）为 $300$ 秒（从 $1200$ 秒到 $1500$ 秒）。\n\n---\n你的任务是编一个程序，读入一个有 $n$ 个农民挤 $n$ 头牛的工作时间列表，计算以下两点（均以秒为单位）：\n\n1. 最长至少有一人在挤奶的时间段。\n2. 最长的无人挤奶的时间段。（从有人挤奶开始算起）", "inputFormat": "第一行一个正整数 $n$。\n\n接下来 $n$ 行，每行两个非负整数 $l,r$，表示一个农民的开始时刻与结束时刻。", "outputFormat": "仅一行两个整数，以一个空格分隔，即题目所要求的两个答案。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 5000$，$0 \\le l \\le r \\le 10^6$。\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 1.2", "locale": "zh-CN"}}}
{"pid": "P1205", "type": "P", "difficulty": 3, "samples": [["3\n@-@\n---\n@@-\n@-@\n@--\n--@\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "USACO"], "title": "[USACO1.2] 方块转换 Transformations", "background": "", "description": "一块 $n \\times n$ 正方形的黑白瓦片的图案要被转换成新的正方形图案。写一个程序来找出将原始图案按照以下列转换方法转换成新图案的最小方式：\n\n- 转 $90\\degree$：图案按顺时针转 $90\\degree$。\n\n- 转 $180\\degree$：图案按顺时针转 $180\\degree$。\n\n- 转 $270\\degree$：图案按顺时针转 $270\\degree$。\n\n- 反射：图案在水平方向翻转（以中央铅垂线为中心形成原图案的镜像）。\n\n- 组合：图案在水平方向翻转，然后再按照 $1 \\sim 3$ 之间的一种再次转换。\n\n- 不改变：原图案不改变。\n\n- 无效转换：无法用以上方法得到新图案。\n\n如果有多种可用的转换方法，请选择序号最小的那个。\n\n只使用上述 $7$ 个中的一个步骤来完成这次转换。\n", "inputFormat": "第一行一个正整数 $n$。   \n\n然后 $n$ 行，每行 $n$ 个字符，全部为 `@` 或 `-`，表示初始的正方形。\n\n接下来 $n$ 行，每行 $n$ 个字符，全部为 `@` 或 `-`，表示最终的正方形。\n\n", "outputFormat": "单独的一行包括 $1 \\sim 7$ 之间的一个数字（在上文已描述）表明需要将转换前的正方形变为转换后的正方形的转换方法。\n\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 10$。\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 1.2\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.2] Transformations", "background": "", "description": "A black-and-white pattern on an $n \\times n$ square of tiles is to be transformed into a new square pattern. Write a program to find the minimal method to convert the original pattern into the new one using the following transformations:\n\n- Rotate $90\\degree$: Rotate the pattern $90\\degree$ clockwise.\n- Rotate $180\\degree$: Rotate the pattern $180\\degree$ clockwise.\n- Rotate $270\\degree$: Rotate the pattern $270\\degree$ clockwise.\n- Reflect: Flip the pattern horizontally (mirror over the central vertical line).\n- Combination: First reflect horizontally, then apply one of the transformations in $1 \\sim 3$.\n- No change: The original pattern is unchanged.\n- Invalid transformation: The new pattern cannot be obtained by the above methods.\n\nIf more than one method works, choose the one with the smallest index.\n\nUse exactly one of the above $7$ steps to accomplish this transformation.", "inputFormat": "The first line contains a positive integer $n$.\n\nThen follow $n$ lines, each containing $n$ characters, all `@` or `-`, representing the initial square.\n\nThen follow another $n$ lines, each containing $n$ characters, all `@` or `-`, representing the target square.", "outputFormat": "A single line containing a number between $1 \\sim 7$ (as described above) indicating the transformation method required to convert the original square into the target square.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n \\le 10$.\n\nProblem translation from NOCOW.\n\nUSACO Training Section 1.2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.2] 方块转换 Transformations", "background": "", "description": "一块 $n \\times n$ 正方形的黑白瓦片的图案要被转换成新的正方形图案。写一个程序来找出将原始图案按照以下列转换方法转换成新图案的最小方式：\n\n- 转 $90\\degree$：图案按顺时针转 $90\\degree$。\n\n- 转 $180\\degree$：图案按顺时针转 $180\\degree$。\n\n- 转 $270\\degree$：图案按顺时针转 $270\\degree$。\n\n- 反射：图案在水平方向翻转（以中央铅垂线为中心形成原图案的镜像）。\n\n- 组合：图案在水平方向翻转，然后再按照 $1 \\sim 3$ 之间的一种再次转换。\n\n- 不改变：原图案不改变。\n\n- 无效转换：无法用以上方法得到新图案。\n\n如果有多种可用的转换方法，请选择序号最小的那个。\n\n只使用上述 $7$ 个中的一个步骤来完成这次转换。\n", "inputFormat": "第一行一个正整数 $n$。   \n\n然后 $n$ 行，每行 $n$ 个字符，全部为 `@` 或 `-`，表示初始的正方形。\n\n接下来 $n$ 行，每行 $n$ 个字符，全部为 `@` 或 `-`，表示最终的正方形。\n\n", "outputFormat": "单独的一行包括 $1 \\sim 7$ 之间的一个数字（在上文已描述）表明需要将转换前的正方形变为转换后的正方形的转换方法。\n\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 10$。\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 1.2\n", "locale": "zh-CN"}}}
{"pid": "P1206", "type": "P", "difficulty": 2, "samples": [["10\n", "1 1\n2 4\n3 9\n11 121\n22 484\n26 676\n101 10201\n111 12321\n121 14641\n202 40804\n212 44944\n264 69696\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO", "进制"], "title": "[USACO1.2] 回文平方数 Palindromic Squares", "background": "", "description": "回文数是指从左向右念和从右向左念都一样的数。如 $12321$ 就是一个典型的回文数。\n\n给定一个用十进制表示的正整数 $B$，输出所有 $[1,300]$ 中，它的平方用 $B$ 进制表示时是回文数的数。\n", "inputFormat": "共一行，一个单独的正整数 $B$。\n", "outputFormat": "每行两个 $B$ 进制的符合要求的数字，第二个数是第一个数的平方，且第二个数是回文数。\n\n注意大于 $9$ 的数，用字母表示。如用 `A` 表示 $10$，`B` 表示 $11$，用第 $n$ 个大写字母表示 $n+9$。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$2 \\le B \\le 20$\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.2\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.2] Palindromic Squares", "background": "", "description": "A palindromic number is a number that reads the same from left to right and from right to left. For example, $12321$ is a typical palindrome.\n\nGiven a positive integer $B$ written in decimal, output all integers in $[1, 300]$ whose squares, when written in base $B$, are palindromes.", "inputFormat": "One line containing a single positive integer $B$.", "outputFormat": "Each line contains two base-$B$ numbers: the first number and its square. The second number must be a palindrome.\n\nNote that digits greater than $9$ are represented by letters. For example, use `A` for $10$, `B` for $11$, and use the $n$-th uppercase letter to represent $n + 9$.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $2 \\le B \\le 20$.\n\nTranslation from NOCOW.\n\nUSACO Training Section 1.2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.2] 回文平方数 Palindromic Squares", "background": "", "description": "回文数是指从左向右念和从右向左念都一样的数。如 $12321$ 就是一个典型的回文数。\n\n给定一个用十进制表示的正整数 $B$，输出所有 $[1,300]$ 中，它的平方用 $B$ 进制表示时是回文数的数。\n", "inputFormat": "共一行，一个单独的正整数 $B$。\n", "outputFormat": "每行两个 $B$ 进制的符合要求的数字，第二个数是第一个数的平方，且第二个数是回文数。\n\n注意大于 $9$ 的数，用字母表示。如用 `A` 表示 $10$，`B` 表示 $11$，用第 $n$ 个大写字母表示 $n+9$。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$2 \\le B \\le 20$\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.2\n", "locale": "zh-CN"}}}
{"pid": "P1207", "type": "P", "difficulty": 2, "samples": [["3 25\n", "26\n27\n28\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO", "进制"], "title": "[USACO1.2] 双重回文数 Dual Palindromes", "background": "如果一个数从左往右读和从右往左读都是一样，那么这个数就叫做“回文数”。例如，$12321$ 就是一个回文数，而 $77778$ 就不是。当然，回文数的首和尾都应是非零的，因此 $0220$ 就不是回文数。\n\n事实上，有一些数（如 $21$ ），在十进制时不是回文数，但在其它进制（如二进制时为 $10101$ ）时就是回文数。", "description": "给定两个十进制数 $n,s$，然后找出前 $n$ 个满足大于 $s$ 且在不少于两种进制（二进制至十进制）上是回文数的十进制数，输出到文件上。\n\n本问题的解决方案不需要使用大于 $32$ 位的整型数\n\n", "inputFormat": "只有一行，用空格隔开的两个正整数 $n,s$。\n", "outputFormat": "$n$ 行, 每行一个满足上述要求的数，并按从小到大的顺序输出。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 15$，$1\\le s \\le 9999$\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.2\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.2] Dual Palindromes", "background": "If a number reads the same from left to right and from right to left, then it is called a \"palindrome.\" For example, $12321$ is a palindrome, while $77778$ is not. We do not allow leading zeros in the representation; therefore, $0220$ is not considered a palindrome.\n\nIn fact, some numbers (such as $21$) are not palindromes in base $10$, but they are palindromes in other bases (for example, in base $2$ it is $10101$).", "description": "Given two decimal integers $n, s$, find the first $n$ decimal numbers greater than $s$ that are palindromic in at least two bases among base $2$ through base $10$, and output them.\n\nA solution to this problem does not need integers wider than $32$ bits.", "inputFormat": "One line containing two positive integers $n, s$ separated by a space.", "outputFormat": "Output $n$ lines. Each line contains one number that satisfies the requirement, in ascending order.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n \\le 15$, $1 \\le s \\le 9999$.\n\nProblem translation from NOCOW.\n\nUSACO Training Section 1.2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.2] 双重回文数 Dual Palindromes", "background": "如果一个数从左往右读和从右往左读都是一样，那么这个数就叫做“回文数”。例如，$12321$ 就是一个回文数，而 $77778$ 就不是。当然，回文数的首和尾都应是非零的，因此 $0220$ 就不是回文数。\n\n事实上，有一些数（如 $21$ ），在十进制时不是回文数，但在其它进制（如二进制时为 $10101$ ）时就是回文数。", "description": "给定两个十进制数 $n,s$，然后找出前 $n$ 个满足大于 $s$ 且在不少于两种进制（二进制至十进制）上是回文数的十进制数，输出到文件上。\n\n本问题的解决方案不需要使用大于 $32$ 位的整型数\n\n", "inputFormat": "只有一行，用空格隔开的两个正整数 $n,s$。\n", "outputFormat": "$n$ 行, 每行一个满足上述要求的数，并按从小到大的顺序输出。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 15$，$1\\le s \\le 9999$\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.2\n", "locale": "zh-CN"}}}
{"pid": "P1208", "type": "P", "difficulty": 2, "samples": [["100 5\n5 20\n9 40\n3 10\n8 80\n6 30\n", "630\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "USACO"], "title": "[USACO1.3] 混合牛奶 Mixing Milk", "background": null, "description": "由于乳制品产业利润很低，所以降低原材料（牛奶）价格就变得十分重要。帮助 Marry 乳业找到最优的牛奶采购方案。\n\nMarry 乳业从一些奶农手中采购牛奶，并且每一位奶农为乳制品加工企业提供的价格可能相同。此外，就像每头奶牛每天只能挤出固定数量的奶，每位奶农每天能提供的牛奶数量是一定的。每天 Marry 乳业可以从奶农手中采购到小于或者等于奶农最大产量的整数数量的牛奶。\n\n给出 Marry 乳业每天对牛奶的需求量，还有每位奶农提供的牛奶单价和产量。计算采购足够数量的牛奶所需的最小花费。\n\n注：每天所有奶农的总产量不少于 Marry 乳业的需求量。", "inputFormat": "第一行二个整数 $n,m$，表示需要牛奶的总量，和提供牛奶的农民个数。\n\n接下来 $m$ 行，每行两个整数 $p_i,a_i$，表示第 $i$ 个农民牛奶的单价，和农民 $i$ 一天最多能卖出的牛奶量。", "outputFormat": "单独的一行包含单独的一个整数，表示 Marry 的牛奶制造公司拿到所需的牛奶所要的最小费用。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据：  \n$0 \\le n,a_i \\le 2 \\times 10^6$，$0\\le m \\le 5000$，$0 \\le p_i \\le 1000$。\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 1.3", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.3] Mixing Milk", "background": "", "description": "Because the profit margin in the dairy industry is very low, reducing the price of raw materials (milk) becomes very important. Help Marry Dairy find the optimal milk purchasing plan.\n\nMarry Dairy purchases milk from several farmers, and the price offered by each farmer to the dairy processor may be the same. Also, just as each cow can only produce a fixed amount of milk per day, each farmer can provide a fixed amount of milk per day. Each day, Marry Dairy can purchase an integer amount of milk from each farmer, not exceeding that farmer’s maximum daily output.\n\nGiven Marry Dairy’s daily milk demand, as well as each farmer’s unit price and maximum supply, compute the minimum cost to purchase enough milk.\n\nNote: The total daily supply of all farmers is at least Marry Dairy’s demand.", "inputFormat": "The first line contains two integers $n,m$, representing the total amount of milk needed and the number of farmers.\n\nThe next $m$ lines each contain two integers $p_i,a_i$, representing the unit price of milk from the $i$-th farmer and the maximum amount of milk the $i$-th farmer can sell in one day.", "outputFormat": "A single line containing a single integer, representing the minimum cost for Marry Dairy to obtain the required amount of milk.", "hint": "Constraints  \nFor $100\\%$ of the testdata:  \n$0 \\le n,a_i \\le 2 \\times 10^6$，$0\\le m \\le 5000$，$0 \\le p_i \\le 1000$.\n\nTranslation adapted from NOCOW.\n\nUSACO Training Section 1.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.3] 混合牛奶 Mixing Milk", "background": null, "description": "由于乳制品产业利润很低，所以降低原材料（牛奶）价格就变得十分重要。帮助 Marry 乳业找到最优的牛奶采购方案。\n\nMarry 乳业从一些奶农手中采购牛奶，并且每一位奶农为乳制品加工企业提供的价格可能相同。此外，就像每头奶牛每天只能挤出固定数量的奶，每位奶农每天能提供的牛奶数量是一定的。每天 Marry 乳业可以从奶农手中采购到小于或者等于奶农最大产量的整数数量的牛奶。\n\n给出 Marry 乳业每天对牛奶的需求量，还有每位奶农提供的牛奶单价和产量。计算采购足够数量的牛奶所需的最小花费。\n\n注：每天所有奶农的总产量不少于 Marry 乳业的需求量。", "inputFormat": "第一行二个整数 $n,m$，表示需要牛奶的总量，和提供牛奶的农民个数。\n\n接下来 $m$ 行，每行两个整数 $p_i,a_i$，表示第 $i$ 个农民牛奶的单价，和农民 $i$ 一天最多能卖出的牛奶量。", "outputFormat": "单独的一行包含单独的一个整数，表示 Marry 的牛奶制造公司拿到所需的牛奶所要的最小费用。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据：  \n$0 \\le n,a_i \\le 2 \\times 10^6$，$0\\le m \\le 5000$，$0 \\le p_i \\le 1000$。\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 1.3", "locale": "zh-CN"}}}
{"pid": "P1209", "type": "P", "difficulty": 3, "samples": [["4 50 18\n3 \n4 \n6 \n8 \n14\n15 \n16 \n17 \n21\n25 \n26 \n27 \n30 \n31 \n40 \n41 \n42 \n43\n", "25\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "贪心", "USACO", "排序"], "title": "[USACO1.3] 修理牛棚 Barn Repair", "background": "", "description": "在一个月黑风高的暴风雨夜，Farmer John 的牛棚的屋顶、门被吹飞了 好在许多牛正在度假，所以牛棚没有住满。   \n\n牛棚一个紧挨着另一个被排成一行，牛就住在里面过夜。有些牛棚里有牛，有些没有。 所有的牛棚有相同的宽度。   \n\n自门遗失以后，Farmer John 必须尽快在牛棚之前竖立起新的木板。他的新木材供应商将会供应他任何他想要的长度，但是吝啬的供应商只能提供有限数目的木板。 Farmer John 想将他购买的木板总长度减到最少。\n\n给出 $m,s,c$，表示木板最大的数目、牛棚的总数、牛的总数；以及每头牛所在牛棚的编号，请算出拦住所有有牛的牛棚所需木板的最小总长度。\n", "inputFormat": "一行三个整数 $m,s,c$，意义如题目描述。   \n接下来 $c$ 行，每行包含一个整数，表示牛所占的牛棚的编号。\n", "outputFormat": "输出一行一个整数，表示所需木板的最小总长度。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le m \\le 50$，$1\\le c \\le s \\le 200$。 \n\nUSACO Training Section 1.3\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.3] Barn Repair", "background": "", "description": "On a dark and stormy night, the roof and doors of Farmer John's barn were blown off. Fortunately, many cows are on vacation, so the barn is not full.\n\nThe stalls are arranged in a single row, one right next to another, and cows stay in them overnight. Some stalls are occupied, others are empty. All stalls have the same width.\n\nSince the doors were lost, Farmer John must quickly put up new wooden boards in front of the stalls. His new lumber supplier can provide boards of any length he wants, but, being stingy, can supply only a limited number of boards. Farmer John wants to minimize the total length of the boards he buys.\n\nGiven $m, s, c$ — the maximum number of boards, the total number of stalls, and the total number of cows — and the index of the stall occupied by each cow, compute the minimal total length of boards required to block all stalls that contain cows. Each board covers a consecutive range of stalls.", "inputFormat": "One line with three integers $m, s, c$, as described above.  \nThen $c$ lines follow, each containing one integer, the index of a stall that contains a cow.", "outputFormat": "Output a single line with one integer, the minimal total length of boards required.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le m \\le 50$, $1 \\le c \\le s \\le 200$.\n\nUSACO Training Section 1.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.3] 修理牛棚 Barn Repair", "background": "", "description": "在一个月黑风高的暴风雨夜，Farmer John 的牛棚的屋顶、门被吹飞了 好在许多牛正在度假，所以牛棚没有住满。   \n\n牛棚一个紧挨着另一个被排成一行，牛就住在里面过夜。有些牛棚里有牛，有些没有。 所有的牛棚有相同的宽度。   \n\n自门遗失以后，Farmer John 必须尽快在牛棚之前竖立起新的木板。他的新木材供应商将会供应他任何他想要的长度，但是吝啬的供应商只能提供有限数目的木板。 Farmer John 想将他购买的木板总长度减到最少。\n\n给出 $m,s,c$，表示木板最大的数目、牛棚的总数、牛的总数；以及每头牛所在牛棚的编号，请算出拦住所有有牛的牛棚所需木板的最小总长度。\n", "inputFormat": "一行三个整数 $m,s,c$，意义如题目描述。   \n接下来 $c$ 行，每行包含一个整数，表示牛所占的牛棚的编号。\n", "outputFormat": "输出一行一个整数，表示所需木板的最小总长度。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le m \\le 50$，$1\\le c \\le s \\le 200$。 \n\nUSACO Training Section 1.3\n", "locale": "zh-CN"}}}
{"pid": "P1210", "type": "P", "difficulty": 3, "samples": [["Confucius say: Madam, I'm Adam. ", "11\nMadam, I'm Adam"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "搜索", "USACO", "枚举"], "title": "[USACO1.3] 最长的回文 Calf Flac", "background": "", "description": "据说如果你给无限只母牛和无限台巨型便携式电脑（有非常大的键盘 ), 那么母牛们会制造出世上最棒的回文。你的工作就是去寻找这些牛制造的奇观（最棒的回文）。\n\n在寻找回文时不用理睬那些标点符号、空格（但应该保留下来以便做为答案输出）, 只用考虑字母 ${\\tt A}\\sim {\\tt Z}$ 和 ${\\tt a}\\sim {\\tt z}$。要你寻找的最长的回文的文章是一个不超过 $20{,}000$ 个字符的字符串。我们将保证最长的回文不会超过 $2{,}000$ 个字符（在除去标点符号、空格之前）。", "inputFormat": "输入文件不会超过 $20,000$ 字符。这个文件可能一行或多行，但是每行都不超过 $80$ 个字符（不包括最后的换行符）。", "outputFormat": "输出的第一行应该包括找到的最长的回文的长度。\n\n下一行或几行应该包括这个回文的原文（没有除去标点符号、空格），把这个回文输出到一行或多行（如果回文中包括换行符）。\n\n如果有多个回文长度都等于最大值，输出最前面出现的那一个。\n", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 1.3\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.3] Longest Palindrome Calf Flac", "background": "", "description": "It is said that if you give infinitely many cows and infinitely many giant portable computers (with very large keyboards), the cows will create the best palindrome in the world. Your job is to find this marvel (the finest palindrome) produced by the cows.\n\nWhen searching for the palindrome, ignore punctuation and spaces (but keep them so they can be printed in the answer). Only consider the letters ${\\tt A}\\sim {\\tt Z}$ and ${\\tt a}\\sim {\\tt z}$. The text in which you must find the longest palindrome is a string of at most $20{,}000$ characters. We guarantee that the longest palindrome will not exceed $2{,}000$ characters (before removing punctuation and spaces).", "inputFormat": "The input file will not exceed $20{,}000$ characters. This file may have one or more lines, but each line will not exceed $80$ characters (excluding the final newline).", "outputFormat": "The first line should contain the length of the longest palindrome found.\n\nThe next line or lines should contain this palindrome in its original text (without removing punctuation and spaces), printed across one or more lines (if the palindrome contains newline characters).\n\nIf multiple palindromes have the same maximal length, output the one that appears earliest.", "hint": "The problem translation comes from NOCOW.\n\nUSACO Training Section 1.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.3] 最长的回文 Calf Flac", "background": "", "description": "据说如果你给无限只母牛和无限台巨型便携式电脑（有非常大的键盘 ), 那么母牛们会制造出世上最棒的回文。你的工作就是去寻找这些牛制造的奇观（最棒的回文）。\n\n在寻找回文时不用理睬那些标点符号、空格（但应该保留下来以便做为答案输出）, 只用考虑字母 ${\\tt A}\\sim {\\tt Z}$ 和 ${\\tt a}\\sim {\\tt z}$。要你寻找的最长的回文的文章是一个不超过 $20{,}000$ 个字符的字符串。我们将保证最长的回文不会超过 $2{,}000$ 个字符（在除去标点符号、空格之前）。", "inputFormat": "输入文件不会超过 $20,000$ 字符。这个文件可能一行或多行，但是每行都不超过 $80$ 个字符（不包括最后的换行符）。", "outputFormat": "输出的第一行应该包括找到的最长的回文的长度。\n\n下一行或几行应该包括这个回文的原文（没有除去标点符号、空格），把这个回文输出到一行或多行（如果回文中包括换行符）。\n\n如果有多个回文长度都等于最大值，输出最前面出现的那一个。\n", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 1.3\n", "locale": "zh-CN"}}}
{"pid": "P1211", "type": "P", "difficulty": 2, "samples": [["5\n2 3 4 6 8\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO", "枚举"], "title": "[USACO1.3] 牛式 Prime Cryptarithm", "background": "", "description": "下面是一个乘法竖式，如果用我们给定的那 $n$ 个数字来取代 `*`，可以使式子成立的话，我们就叫这个式子为牛式。\n\n```cpp\n          ***\n    x      **\n   ----------\n         ***\n        ***\n   ----------\n        ****\n```\n\n数字只能取代 `*`，当然第一位不能为 $0$，况且给定的数字里不包括 $0$。\n\n\n注意一下在美国的学校中教的“部分乘积”，第一部分乘积是第二个数的个位和第一个数的积，第二部分乘积是第二个数的十位和第一个数的乘积。\n\n请计算出牛式的数量。\n\n", "inputFormat": "第一行一个正整数 $n$，表示可用的数集。   \n第二行 $n$ 个正整数 $a_i$，表示可用的数。\n", "outputFormat": "输出一行一个整数，表示牛式的总数。\n", "hint": "### 样例解释\n\n```\n          222\n    x      22\n   ----------\n         444\n        444\n   ----------\n        4884\n```\n\n不需要别的数，严格符合上图的数位情况，可以证明没有其他情况。\n\n\n\n不加入样例解释：做题人如果理解错题意会进入误区\n\n比如不用填中间的数，位数没有要求 `34*2=68` 符合要求等误区。\n\n### 数据规模  \n对于 $100\\%$ 的数据，$1\\le n \\le 9$，$a_i \\in [1,9] \\cap \\mathbb Z$ 且 $a_i$ 不重复。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.4\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.3] Cow-Style Prime Cryptarithm", "background": "", "description": "Below is a vertical multiplication. If we can replace each `*` with one of the given $n$ digits so that the equation is correct, we call it a \"cow-style\" multiplication.\n\n```cpp\n          ***\n    x      **\n   ----------\n         ***\n        ***\n   ----------\n        ****\n```\n\nDigits may only replace `*`. The leading digit of any number cannot be $0$; besides, $0$ is not among the given digits.\n\nNote the \"partial products\" as taught in U.S. schools: the first partial product is the product of the units digit of the second number and the first number; the second partial product is the product of the tens digit of the second number and the first number.\n\nCompute the number of such \"cow-style\" cryptarithms.\n\nProblem translation from NOCOW. USACO Training Section 1.4.", "inputFormat": "The first line contains a positive integer $n$, the size of the available digit set.  \nThe second line contains $n$ positive integers $a_i$, the available digits.", "outputFormat": "Output a single line with one integer, the total number of cow-style cryptarithms.", "hint": "### Sample Explanation\n\n```\n          222\n    x      22\n   ----------\n         444\n        444\n   ----------\n        4884\n```\n\nNo other digits are needed. This strictly follows the digit layout shown above, and it can be proved there are no other cases.\n\nWithout the sample explanation, solvers may misunderstand the statement and fall into traps, such as thinking the middle partial products need not be present or that the number of digits is unrestricted (e.g., wrongly accepting `34*2=68`).\n\n### Constraints\nFor $100\\%$ of the testdata, $1\\le n \\le 9$, $a_i \\in [1,9] \\cap \\mathbb Z$, and all $a_i$ are distinct.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.3] 牛式 Prime Cryptarithm", "background": "", "description": "下面是一个乘法竖式，如果用我们给定的那 $n$ 个数字来取代 `*`，可以使式子成立的话，我们就叫这个式子为牛式。\n\n```cpp\n          ***\n    x      **\n   ----------\n         ***\n        ***\n   ----------\n        ****\n```\n\n数字只能取代 `*`，当然第一位不能为 $0$，况且给定的数字里不包括 $0$。\n\n\n注意一下在美国的学校中教的“部分乘积”，第一部分乘积是第二个数的个位和第一个数的积，第二部分乘积是第二个数的十位和第一个数的乘积。\n\n请计算出牛式的数量。\n\n", "inputFormat": "第一行一个正整数 $n$，表示可用的数集。   \n第二行 $n$ 个正整数 $a_i$，表示可用的数。\n", "outputFormat": "输出一行一个整数，表示牛式的总数。\n", "hint": "### 样例解释\n\n```\n          222\n    x      22\n   ----------\n         444\n        444\n   ----------\n        4884\n```\n\n不需要别的数，严格符合上图的数位情况，可以证明没有其他情况。\n\n\n\n不加入样例解释：做题人如果理解错题意会进入误区\n\n比如不用填中间的数，位数没有要求 `34*2=68` 符合要求等误区。\n\n### 数据规模  \n对于 $100\\%$ 的数据，$1\\le n \\le 9$，$a_i \\in [1,9] \\cap \\mathbb Z$ 且 $a_i$ 不重复。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.4\n", "locale": "zh-CN"}}}
{"pid": "P1212", "type": "P", "difficulty": 4, "samples": [["1 2\n2 3\n3 4\n4 5\n", "40\n4 10\n5 8\n"]], "limits": {"time": [952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO"], "title": "[USACO1.4] 铺放矩形块 Packing Rectangles", "background": "", "description": "给定 $4$ 个矩形块，找出一个最小的封闭矩形将这 $4$ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)\n\n$4$ 个矩形块中任一个矩形的边都与封闭矩形的边相平行，上图显示出了铺放 $4$ 个矩形块的 $6$ 种方案。  \n\n这 $6$ 种方案是唯一可能的基本铺放方案。因为其它方案能由基本方案通过旋转和镜像反射得到。\n\n可能存在满足条件且有着同样面积的各种不同的封闭矩形，你应该输出所有这些封闭矩形的边长。\n\n", "inputFormat": "共有 $4$ 行，每行两个正整数，表示每个矩形的边长。\n", "outputFormat": "总行数为解的总数加一。  \n\n第一行是一个整数，代表封闭矩形的最小面积。  \n接下来的每一行都表示一个解，由 $p,q\\space (p \\leqslant q)$ 来表示。这些行必须根据 $p$ 的大小按升序排列，且所有行都应是不同的。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，输入的所有数在 $[1,50]$ 内。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.4\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.4] Packing Rectangles", "background": "", "description": "Given $4$ rectangles, find a smallest enclosing rectangle that can contain all $4$ rectangles without overlap. By “smallest” we mean the area is minimal.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)\n\nFor any of the $4$ rectangles, its sides must be parallel to the sides of the enclosing rectangle. The figure above shows $6$ ways to pack the $4$ rectangles.\n\nThese $6$ layouts are the only possible basic layouts. Any other layout can be obtained from a basic one by rotation or mirror reflection.\n\nThere may be multiple enclosing rectangles that satisfy the conditions and have the same area; you should output the side lengths of all such enclosing rectangles.", "inputFormat": "There are $4$ lines, each containing two positive integers, representing the side lengths of each rectangle.", "outputFormat": "The total number of lines equals the number of solutions plus one.\n\nThe first line is an integer, representing the minimal area of the enclosing rectangle.  \nEach of the following lines describes one solution, represented by $p,q\\space (p \\leqslant q)$. These lines must be sorted in ascending order by $p$, and all lines must be distinct.", "hint": "Constraints  \nFor $100\\%$ of the testdata, all input numbers are in [1, 50].\n\nProblem translation from NOCOW.\n\nUSACO Training Section 1.4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.4] 铺放矩形块 Packing Rectangles", "background": "", "description": "给定 $4$ 个矩形块，找出一个最小的封闭矩形将这 $4$ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)\n\n$4$ 个矩形块中任一个矩形的边都与封闭矩形的边相平行，上图显示出了铺放 $4$ 个矩形块的 $6$ 种方案。  \n\n这 $6$ 种方案是唯一可能的基本铺放方案。因为其它方案能由基本方案通过旋转和镜像反射得到。\n\n可能存在满足条件且有着同样面积的各种不同的封闭矩形，你应该输出所有这些封闭矩形的边长。\n\n", "inputFormat": "共有 $4$ 行，每行两个正整数，表示每个矩形的边长。\n", "outputFormat": "总行数为解的总数加一。  \n\n第一行是一个整数，代表封闭矩形的最小面积。  \n接下来的每一行都表示一个解，由 $p,q\\space (p \\leqslant q)$ 来表示。这些行必须根据 $p$ 的大小按升序排列，且所有行都应是不同的。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，输入的所有数在 $[1,50]$ 内。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.4\n", "locale": "zh-CN"}}}
{"pid": "P1213", "type": "P", "difficulty": 4, "samples": [["9 9 12\n6 6 6\n6 3 6 \n", "4 5 8 9\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO", "IOI", "枚举", "剪枝"], "title": "[IOI 1994 / USACO1.4] 时钟 The Clocks", "background": null, "description": "考虑将如此安排在一个 $3 \\times 3$ 行列中的九个时钟:\n\n```plain\n|-------|   |-------|   |-------|\n|       |   |       |   |   |   |\n|---o   |   |---o   |   |   o   |\n|       |   |       |   |       |\n|-------|   |-------|   |-------|\n    A           B           C\n\n|-------|   |-------|   |-------|\n|       |   |       |   |       |\n|   o   |   |   o   |   |   o   |\n|   |   |   |   |   |   |   |   |\n|-------|   |-------|   |-------|\n    D           E           F\n\n|-------|   |-------|   |-------|\n|       |   |       |   |       |\n|   o   |   |   o---|   |   o   |\n|   |   |   |       |   |   |   |\n|-------|   |-------|   |-------|\n    G           H           I\n```\n\n目标要找一个最小的移动顺序将所有的指针指向 $12$ 点。下面的表格列出了 $9$ 种不同的旋转指针的方法，每一种方法都叫一次移动，选择 $1 \\sim 9$ 号移动方法，将会使在表格中对应的时钟的指针顺时针旋转 \n $90$ 度。\n\n\n|移动方法  | 受影响的时钟 |\n| :----------: | :----------: |\n| 1 | ABDE |\n| 2 | ABC |\n| 3 | BCEF |\n| 4 | ADG |\n| 5 | BDEFH |\n| 6 | CFI |\n| 7 | DEGH |\n| 8 | GHI |\n| 9 | EFHI |\n\n例如：\n\n```plain\n9 9 12       9 12 12        9 12 12        12 12 12        12 12 12\n6 6 6   5 -> 9  9  9   8 -> 9  9  9   4 -> 12  9  9   9 -> 12 12 12\n6 3 6        6  6  6        9  9  9        12  9  9        12 12 12\n```\n\n**但这可能不是正确的方法，请看下文。**", "inputFormat": "输入三行，每行三个正整数，表示一个时钟的初始时间（样例中数字的含义和上面 d 的例子一样）。", "outputFormat": "单独的一行包括一个用空格分开的将所有指针指向 $12$ 点的最短移动顺序的列表。\n\n如果有多种方案，输出字典序最小的方案。（例如 `5 2 4 6` 的字典序小于 `9 3 1 1`）。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 1.4", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 1994 / USACO1.4] The Clocks", "background": "", "description": "Consider nine clocks arranged in a $3 \\times 3$ grid:\n\n```plain\n|-------|   |-------|   |-------|\n|       |   |       |   |   |   |\n|---o   |   |---o   |   |   o   |\n|       |   |       |   |       |\n|-------|   |-------|   |-------|\n    A           B           C\n\n|-------|   |-------|   |-------|\n|       |   |       |   |       |\n|   o   |   |   o   |   |   o   |\n|   |   |   |   |   |   |   |   |\n|-------|   |-------|   |-------|\n    D           E           F\n\n|-------|   |-------|   |-------|\n|       |   |       |   |       |\n|   o   |   |   o---|   |   o   |\n|   |   |   |       |   |   |   |\n|-------|   |-------|   |-------|\n    G           H           I\n```\n\nThe goal is to find a shortest sequence of moves that sets all hands to $12$ o'clock. The table below lists $9$ different methods of rotating hands; each method is called a move. Applying moves $1 \\sim 9$ rotates the hands of the indicated clocks by $90$ degrees clockwise.\n\n| Move | Affected clocks |\n| :--: | :-------------: |\n| 1 | ABDE |\n| 2 | ABC |\n| 3 | BCEF |\n| 4 | ADG |\n| 5 | BDEFH |\n| 6 | CFI |\n| 7 | DEGH |\n| 8 | GHI |\n| 9 | EFHI |\n\nFor example:\n\n```plain\n9 9 12       9 12 12        9 12 12        12 12 12        12 12 12\n6 6 6   5 -> 9  9  9   8 -> 9  9  9   4 -> 12  9  9   9 -> 12 12 12\n6 3 6        6  6  6        9  9  9        12  9  9        12 12 12\n```\n\n**But this might not be the correct method; see below.**", "inputFormat": "Three lines, each containing three positive integers, giving the initial time of each clock (the meaning of the numbers is the same as in the example above).", "outputFormat": "A single line containing the shortest sequence of moves that sets all hands to $12$ o'clock, listed in order and separated by single spaces.\n\nIf there are multiple solutions, output the lexicographically smallest one. (For example, `5 2 4 6` is lexicographically smaller than `9 3 1 1`.)", "hint": "Problem translation from NOCOW.\n\nUSACO Training Section 1.4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 1994 / USACO1.4] 时钟 The Clocks", "background": null, "description": "考虑将如此安排在一个 $3 \\times 3$ 行列中的九个时钟:\n\n```plain\n|-------|   |-------|   |-------|\n|       |   |       |   |   |   |\n|---o   |   |---o   |   |   o   |\n|       |   |       |   |       |\n|-------|   |-------|   |-------|\n    A           B           C\n\n|-------|   |-------|   |-------|\n|       |   |       |   |       |\n|   o   |   |   o   |   |   o   |\n|   |   |   |   |   |   |   |   |\n|-------|   |-------|   |-------|\n    D           E           F\n\n|-------|   |-------|   |-------|\n|       |   |       |   |       |\n|   o   |   |   o---|   |   o   |\n|   |   |   |       |   |   |   |\n|-------|   |-------|   |-------|\n    G           H           I\n```\n\n目标要找一个最小的移动顺序将所有的指针指向 $12$ 点。下面的表格列出了 $9$ 种不同的旋转指针的方法，每一种方法都叫一次移动，选择 $1 \\sim 9$ 号移动方法，将会使在表格中对应的时钟的指针顺时针旋转 \n $90$ 度。\n\n\n|移动方法  | 受影响的时钟 |\n| :----------: | :----------: |\n| 1 | ABDE |\n| 2 | ABC |\n| 3 | BCEF |\n| 4 | ADG |\n| 5 | BDEFH |\n| 6 | CFI |\n| 7 | DEGH |\n| 8 | GHI |\n| 9 | EFHI |\n\n例如：\n\n```plain\n9 9 12       9 12 12        9 12 12        12 12 12        12 12 12\n6 6 6   5 -> 9  9  9   8 -> 9  9  9   4 -> 12  9  9   9 -> 12 12 12\n6 3 6        6  6  6        9  9  9        12  9  9        12 12 12\n```\n\n**但这可能不是正确的方法，请看下文。**", "inputFormat": "输入三行，每行三个正整数，表示一个时钟的初始时间（样例中数字的含义和上面 d 的例子一样）。", "outputFormat": "单独的一行包括一个用空格分开的将所有指针指向 $12$ 点的最短移动顺序的列表。\n\n如果有多种方案，输出字典序最小的方案。（例如 `5 2 4 6` 的字典序小于 `9 3 1 1`）。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 1.4", "locale": "zh-CN"}}}
{"pid": "P1214", "type": "P", "difficulty": 4, "samples": [["5\n7\n", "1 4\n37 4\n2 8\n29 8\n1 12\n5 12\n13 12\n17 12\n5 20\n2 24\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "USACO"], "title": "[USACO1.4] 等差数列 Arithmetic Progressions", "background": "", "description": "一个等差数列是一个能表示成 $a, a+b, a+2b, \\dots ,a+nb\\space (n \\in \\mathbb N)$ 的数列。\n\n在这个问题中 $a$ 是一个非负的整数，$b$ 是正整数。  \n写一个程序来找出在双平方数集合：  \n$$\\{ x | x = p^2 + q^2 \\wedge p,q \\in \\mathbb N \\cap [0,m]\\}$$\n中长度为 $n$ 的等差数列。\n\n", "inputFormat": "第一行一个正整数 $n$，表示要找的数列长度。  \n第二行一个非负整数 $m$，表示 $p,q$ 的上界。", "outputFormat": "如果没有找到数列，输出 `NONE`。\n\n如果找到了，输出一行或多行，每行由二个整数组成：$a,b$。\n\n这些行应该以 $b$ 为第一关键字，$a$ 为第二关键字升序排序。\n\n所求的等差数列将不会多于10,000个。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$3 \\le n \\le 25$，$0 \\le m \\le 250$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.4\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.4] Arithmetic Progressions", "background": "", "description": "An arithmetic progression is a sequence that can be written as $a, a+b, a+2b, \\dots ,a+nb\\space (n \\in \\mathbb N)$.\n\nIn this problem, $a$ is a non-negative integer and $b$ is a positive integer.\nWrite a program to find arithmetic progressions of length $n$ within the set of bisquares:\n$$\\{ x | x = p^2 + q^2 \\wedge p,q \\in \\mathbb N \\cap [0,m]\\}$$", "inputFormat": "The first line contains a positive integer $n$, the required length of the progression.\nThe second line contains a non-negative integer $m$, the upper bound for $p, q$.", "outputFormat": "If no progression is found, output `NONE`.\n\nIf found, output one or more lines, each containing two integers: $a, b$.\n\nThese lines should be sorted in ascending order by $b$ as the primary key and by $a$ as the secondary key.\n\nThere will be no more than 10,000 such arithmetic progressions.", "hint": "Constraints\nFor 100% of the testdata, $3 \\le n \\le 25$, $0 \\le m \\le 250$.\n\nProblem translation from NOCOW.\n\nUSACO Training Section 1.4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.4] 等差数列 Arithmetic Progressions", "background": "", "description": "一个等差数列是一个能表示成 $a, a+b, a+2b, \\dots ,a+nb\\space (n \\in \\mathbb N)$ 的数列。\n\n在这个问题中 $a$ 是一个非负的整数，$b$ 是正整数。  \n写一个程序来找出在双平方数集合：  \n$$\\{ x | x = p^2 + q^2 \\wedge p,q \\in \\mathbb N \\cap [0,m]\\}$$\n中长度为 $n$ 的等差数列。\n\n", "inputFormat": "第一行一个正整数 $n$，表示要找的数列长度。  \n第二行一个非负整数 $m$，表示 $p,q$ 的上界。", "outputFormat": "如果没有找到数列，输出 `NONE`。\n\n如果找到了，输出一行或多行，每行由二个整数组成：$a,b$。\n\n这些行应该以 $b$ 为第一关键字，$a$ 为第二关键字升序排序。\n\n所求的等差数列将不会多于10,000个。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$3 \\le n \\le 25$，$0 \\le m \\le 250$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.4\n", "locale": "zh-CN"}}}
{"pid": "P1215", "type": "P", "difficulty": 3, "samples": [["8 9 10\n", "1 2 8 9 10\n"], ["2 5 10", "5 6 7 8 9 10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO"], "title": "[USACO1.4] 母亲的牛奶 Mother's Milk", "background": "", "description": "农民约翰有三个容量分别是 $a,b,c$ 升的桶。  \n\n最初，$a,b$ 桶都是空的，而 $c$ 桶是装满牛奶的。有时，农民把牛奶从一个桶倒到另一个桶中，直到被灌桶装满或原桶空了。  \n\n当然每一次灌注都是完全的。由于节约，牛奶不会有丢失。\n\n写一个程序去帮助农民找出当 $a$ 桶是空的时候，$c$ 桶中牛奶所剩量的所有可能性。\n", "inputFormat": "单独的一行包括三个整数 $a,b,c$。\n", "outputFormat": "只有一行，升序地列出当 $a$ 桶是空的时候，$c$ 桶牛奶所剩量的所有可能性。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le a,b,c \\le 20$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.4\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.4] Mother's Milk", "background": "", "description": "Farmer John has three buckets with capacities of $a, b, c$ liters.\n\nInitially, buckets $a$ and $b$ are empty, and bucket $c$ is full of milk. From time to time, the farmer pours milk from one bucket to another until either the receiving bucket is full or the source bucket is empty.\n\nEach pour is complete. No milk is lost.\n\nWrite a program to help the farmer find all possible amounts of milk remaining in bucket $c$ when bucket $a$ is empty.", "inputFormat": "A single line containing three integers $a, b, c$.", "outputFormat": "Output a single line listing, in ascending order, all possible amounts of milk in bucket $c$ when bucket $a$ is empty.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le a, b, c \\le 20$.\n\nProblem translation from NOCOW.\n\nUSACO Training Section 1.4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.4] 母亲的牛奶 Mother's Milk", "background": "", "description": "农民约翰有三个容量分别是 $a,b,c$ 升的桶。  \n\n最初，$a,b$ 桶都是空的，而 $c$ 桶是装满牛奶的。有时，农民把牛奶从一个桶倒到另一个桶中，直到被灌桶装满或原桶空了。  \n\n当然每一次灌注都是完全的。由于节约，牛奶不会有丢失。\n\n写一个程序去帮助农民找出当 $a$ 桶是空的时候，$c$ 桶中牛奶所剩量的所有可能性。\n", "inputFormat": "单独的一行包括三个整数 $a,b,c$。\n", "outputFormat": "只有一行，升序地列出当 $a$ 桶是空的时候，$c$ 桶牛奶所剩量的所有可能性。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le a,b,c \\le 20$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.4\n", "locale": "zh-CN"}}}
{"pid": "P1216", "type": "P", "difficulty": 2, "samples": [["5\n7\n3 8\n8 1 0\n2 7 4 4\n4 5 2 6 5 \n", "30\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "USACO", "IOI"], "title": "[IOI 1994 / USACO1.5] 数字三角形 Number Triangles", "background": null, "description": "观察下面的数字金字塔。\n\n\n写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/95pzs0ne.png)\n\n在上面的样例中，从 $7 \\to 3 \\to 8 \\to 7 \\to 5$ 的路径产生了最大权值。", "inputFormat": "第一个行一个正整数 $r$，表示行的数目。\n\n后面每行为这个数字金字塔特定行包含的整数。", "outputFormat": "单独的一行，包含那个可能得到的最大的和。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le r\\le 1000$，所有输入在 $[0,100]$ 范围内。\n\n题目翻译来自 NOCOW。\n\nIOI1994 Day1T1 / USACO Training Section 1.5。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 1994 / USACO1.5] Number Triangles", "background": "", "description": "Look at the number pyramid below.\n\nWrite a program to find a path from the top to any position on the bottom that yields the maximum possible sum of the numbers along the path. At each step, you may move to the left-down or right-down adjacent position.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/95pzs0ne.png)\n\nIn the sample above, the path $7 \\to 3 \\to 8 \\to 7 \\to 5$ produces the maximum sum.", "inputFormat": "The first line contains a single integer $r$, the number of rows.\n\nEach of the next $r$ lines describes one row of the number triangle: for each $i$ from $1$ to $r$, the $i$-th line contains $i$ integers.", "outputFormat": "Output a single line containing the maximum possible sum.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le r \\le 1000$, and all input integers are in the range $[0, 100]$.\n\nProblem translation from NOCOW.  \nIOI 1994 Day 1 T1 / USACO Training Section 1.5.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 1994 / USACO1.5] 数字三角形 Number Triangles", "background": null, "description": "观察下面的数字金字塔。\n\n\n写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/95pzs0ne.png)\n\n在上面的样例中，从 $7 \\to 3 \\to 8 \\to 7 \\to 5$ 的路径产生了最大权值。", "inputFormat": "第一个行一个正整数 $r$，表示行的数目。\n\n后面每行为这个数字金字塔特定行包含的整数。", "outputFormat": "单独的一行，包含那个可能得到的最大的和。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le r\\le 1000$，所有输入在 $[0,100]$ 范围内。\n\n题目翻译来自 NOCOW。\n\nIOI1994 Day1T1 / USACO Training Section 1.5。", "locale": "zh-CN"}}}
{"pid": "P1217", "type": "P", "difficulty": 2, "samples": [["5 500\n", "5\n7\n11\n101\n131\n151\n181\n191\n313\n353\n373\n383\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["USACO", "枚举", "素数判断,质数,筛法"], "title": "[USACO1.5] 回文质数 Prime Palindromes", "background": "", "description": "因为 $151$ 既是一个质数又是一个回文数（从左到右和从右到左是看一样的），所以 $151$ 是回文质数。\n\n写一个程序来找出范围 $[a,b] (5 \\le a < b \\le 100,000,000)$（一亿）间的所有回文质数。", "inputFormat": "第一行输入两个正整数 $a$ 和 $b$。", "outputFormat": "输出一个回文质数的列表，一行一个。\n", "hint": "Hint 1: Generate the palindromes and see if they are prime.\n\n提示 1: 找出所有的回文数再判断它们是不是质数（素数）.\n\n\nHint 2: Generate palindromes by combining digits properly. You might need more than one of the loops like below.\n\n提示 2: 要产生正确的回文数，你可能需要几个像下面这样的循环。\n\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.5\n\n\n产生长度为 $5$ 的回文数：\n\n```cpp\nfor (d1 = 1; d1 <= 9; d1+=2) {    // 只有奇数才会是素数\n     for (d2 = 0; d2 <= 9; d2++) {\n         for (d3 = 0; d3 <= 9; d3++) {\n           palindrome = 10000*d1 + 1000*d2 +100*d3 + 10*d2 + d1;//(处理回文数...)\n         }\n     }\n }\n\n```", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.5] Prime Palindromes", "background": "", "description": "Since $151$ is both a prime and a palindrome (it reads the same from left to right and from right to left), $151$ is a palindromic prime.\n\nWrite a program to find all palindromic primes in the range $[a, b]$ with $5 \\le a < b \\le 100,000,000$ (one hundred million).", "inputFormat": "The first line contains two positive integers $a$ and $b$.", "outputFormat": "Output a list of palindromic primes, one per line.", "hint": "Hint 1: Generate palindromes and then check whether they are prime (also called “primes” or “sùshù” in pinyin).\n\nHint 2: Generate palindromes by combining digits properly. You might need several loops like the one below.\n\nProblem translation from NOCOW.\n\nUSACO Training Section 1.5.\n\nGenerating palindromes of length $5$:\n\n```cpp\nfor (d1 = 1; d1 <= 9; d1+=2) {    // 只有奇数才会是素数\n     for (d2 = 0; d2 <= 9; d2++) {\n         for (d3 = 0; d3 <= 9; d3++) {\n           palindrome = 10000*d1 + 1000*d2 +100*d3 + 10*d2 + d1;//(处理回文数...)\n         }\n     }\n }\n\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.5] 回文质数 Prime Palindromes", "background": "", "description": "因为 $151$ 既是一个质数又是一个回文数（从左到右和从右到左是看一样的），所以 $151$ 是回文质数。\n\n写一个程序来找出范围 $[a,b] (5 \\le a < b \\le 100,000,000)$（一亿）间的所有回文质数。", "inputFormat": "第一行输入两个正整数 $a$ 和 $b$。", "outputFormat": "输出一个回文质数的列表，一行一个。\n", "hint": "Hint 1: Generate the palindromes and see if they are prime.\n\n提示 1: 找出所有的回文数再判断它们是不是质数（素数）.\n\n\nHint 2: Generate palindromes by combining digits properly. You might need more than one of the loops like below.\n\n提示 2: 要产生正确的回文数，你可能需要几个像下面这样的循环。\n\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.5\n\n\n产生长度为 $5$ 的回文数：\n\n```cpp\nfor (d1 = 1; d1 <= 9; d1+=2) {    // 只有奇数才会是素数\n     for (d2 = 0; d2 <= 9; d2++) {\n         for (d3 = 0; d3 <= 9; d3++) {\n           palindrome = 10000*d1 + 1000*d2 +100*d3 + 10*d2 + d1;//(处理回文数...)\n         }\n     }\n }\n\n```", "locale": "zh-CN"}}}
{"pid": "P1218", "type": "P", "difficulty": 2, "samples": [["4\n", "2333\n2339\n2393\n2399\n2939\n3119\n3137\n3733\n3739\n3793\n3797\n5939\n7193\n7331\n7333\n7393\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "递推", "USACO", "素数判断,质数,筛法"], "title": "[USACO1.5] 特殊的质数肋骨 Superprime Rib", "background": null, "description": "农民约翰的母牛总是产生最好的肋骨。你能通过农民约翰和美国农业部标记在每根肋骨上的数字认出它们。 \n\n农民约翰确定他卖给买方的是真正的质数肋骨，是因为从右边开始依次取走肋骨，每次还剩下的肋骨上的数字都组成一个质数。  \n\n举例来说：$7\\ 3\\ 3\\ 1$ 全部肋骨上的数字 $7331$ 是质数；三根肋骨 $733$ 是质数；二根肋骨 $73$ 是质数；当然,最后一根肋骨 $7$ 也是质数。$7331$ 被叫做长度 $4$ 的特殊质数。  \n\n写一个程序对给定的肋骨的数目 $n$，求出所有的特殊质数。$1$ 不是质数。", "inputFormat": "一行一个正整数 $n$。", "outputFormat": "按顺序输出长度为 $n$ 的特殊质数,每行一个。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 8$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.5", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.5] Superprime Rib", "background": "", "description": "Farmer John’s cows always produce the best ribs. You can recognize them by the numbers stamped on each rib by Farmer John and the USDA.\n\nFarmer John is sure he sells genuine superprime ribs because, starting from the right and removing one rib at a time, the digits on the ribs that remain always form a prime number.\n\nFor example: for $7\\ 3\\ 3\\ 1$, the digits of all ribs $7331$ form a prime; with three ribs $733$ it is still prime; with two ribs $73$ it is prime; and, of course, the last rib $7$ is also prime. $7331$ is called a superprime of length $4$.\n\nWrite a program that, given the number of ribs $n$, finds all superprimes of length $n$. $1$ is not a prime.", "inputFormat": "A single line containing a positive integer $n$.", "outputFormat": "Output, in increasing order, all superprimes of length $n$, one per line.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n \\le 8$.\n\nProblem translation from NOCOW.  \nUSACO Training Section 1.5.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.5] 特殊的质数肋骨 Superprime Rib", "background": null, "description": "农民约翰的母牛总是产生最好的肋骨。你能通过农民约翰和美国农业部标记在每根肋骨上的数字认出它们。 \n\n农民约翰确定他卖给买方的是真正的质数肋骨，是因为从右边开始依次取走肋骨，每次还剩下的肋骨上的数字都组成一个质数。  \n\n举例来说：$7\\ 3\\ 3\\ 1$ 全部肋骨上的数字 $7331$ 是质数；三根肋骨 $733$ 是质数；二根肋骨 $73$ 是质数；当然,最后一根肋骨 $7$ 也是质数。$7331$ 被叫做长度 $4$ 的特殊质数。  \n\n写一个程序对给定的肋骨的数目 $n$，求出所有的特殊质数。$1$ 不是质数。", "inputFormat": "一行一个正整数 $n$。", "outputFormat": "按顺序输出长度为 $n$ 的特殊质数,每行一个。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 8$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.5", "locale": "zh-CN"}}}
{"pid": "P1219", "type": "P", "difficulty": 3, "samples": [["6\n", "2 4 6 1 3 5\n3 6 2 5 1 4\n4 1 5 2 6 3\n4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO", "深度优先搜索 DFS"], "title": "[USACO1.5] 八皇后 Checker Challenge", "background": "", "description": "一个如下的 $6 \\times 6$ 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3h71x0yf.png)\n\n上面的布局可以用序列 $2\\ 4\\ 6\\ 1\\ 3\\ 5$ 来描述，第 $i$ 个数字表示在第 $i$ 行的相应位置有一个棋子，如下：\n\n行号 $1\\ 2\\ 3\\ 4\\ 5\\ 6$\n\n列号 $2\\ 4\\ 6\\ 1\\ 3\\ 5$\n\n这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。  \n并把它们以上面的序列方法输出，解按字典顺序排列。  \n请输出前 $3$ 个解。最后一行是解的总个数。\n\n", "inputFormat": "一行一个正整数 $n$，表示棋盘是 $n \\times n$ 大小的。\n\n", "outputFormat": "前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$6 \\le n \\le 13$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.5\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.5] Eight Queens Checker Challenge", "background": "", "description": "On a $6 \\times 6$ checkerboard, six pieces are placed so that there is exactly one in each row and each column, and at most one on each diagonal (including all lines parallel to the two main diagonals).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3h71x0yf.png)\n\nThe layout above can be described by the sequence $2\\ 4\\ 6\\ 1\\ 3\\ 5$, where the $i$-th number indicates that there is a piece in row $i$ at the corresponding position, as follows:\n\nRow numbers $1\\ 2\\ 3\\ 4\\ 5\\ 6$\n\nColumn numbers $2\\ 4\\ 6\\ 1\\ 3\\ 5$\n\nThis is just one solution. Write a program to find all valid placements of the pieces. Output them using the sequence representation above, in lexicographical order. Output the first $3$ solutions. The last line is the total number of solutions.", "inputFormat": "One line with a positive integer $n$, indicating the board is of size $n \\times n$.", "outputFormat": "The first three lines are the first three solutions; within each solution, separate the numbers with a single space. The fourth line contains a single number, which is the total number of solutions.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $6 \\le n \\le 13$.\n\nProblem translation is from NOCOW.  \nUSACO Training Section 1.5.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.5] 八皇后 Checker Challenge", "background": "", "description": "一个如下的 $6 \\times 6$ 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3h71x0yf.png)\n\n上面的布局可以用序列 $2\\ 4\\ 6\\ 1\\ 3\\ 5$ 来描述，第 $i$ 个数字表示在第 $i$ 行的相应位置有一个棋子，如下：\n\n行号 $1\\ 2\\ 3\\ 4\\ 5\\ 6$\n\n列号 $2\\ 4\\ 6\\ 1\\ 3\\ 5$\n\n这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。  \n并把它们以上面的序列方法输出，解按字典顺序排列。  \n请输出前 $3$ 个解。最后一行是解的总个数。\n\n", "inputFormat": "一行一个正整数 $n$，表示棋盘是 $n \\times n$ 大小的。\n\n", "outputFormat": "前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$6 \\le n \\le 13$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.5\n", "locale": "zh-CN"}}}
{"pid": "P1220", "type": "P", "difficulty": 4, "samples": [["5 3\n2 10\n3 20\n5 20\n6 30\n8 10", "270  "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "搜索", "区间 DP", "前缀和"], "title": "关路灯", "background": "", "description": "某一村庄在一条路线上安装了 $n$ 盏路灯，每盏灯的功率有大有小（即同一段时间内消耗的电量有多有少）。老张就住在这条路中间某一路灯旁，他有一项工作就是每天早上天亮时一盏一盏地关掉这些路灯。\n\n为了给村里节省电费，老张记录下了每盏路灯的位置和功率，他每次关灯时也都是尽快地去关，但是老张不知道怎样去关灯才能够最节省电。他每天都是在天亮时首先关掉自己所处位置的路灯，然后可以向左也可以向右去关灯。开始他以为先算一下左边路灯的总功率再算一下右边路灯的总功率，然后选择先关掉功率大的一边，再回过头来关掉另一边的路灯，而事实并非如此，因为在关的过程中适当地调头有可能会更省一些。\n\n现在已知老张走的速度为 $1m/s$，每个路灯的位置（是一个整数，即距路线起点的距离，单位：$m$）、功率（$W$），老张关灯所用的时间很短而可以忽略不计。\n\n请你为老张编一程序来安排关灯的顺序，使从老张开始关灯时刻算起所有灯消耗电最少（灯关掉后便不再消耗电了）。", "inputFormat": "第一行是两个数字 $n$（表示路灯的总数）和 $c$（老张所处位置的路灯号）；\n\n接下来 $n$ 行，每行两个数据，表示第 $1$ 盏到第 $n$ 盏路灯的位置和功率。数据保证路灯位置单调递增。", "outputFormat": "一个数据，即最少的功耗（单位：$J$，$1J=1W\\times s$）。", "hint": "### 样例解释\n\n此时关灯顺序为 `3 4 2 1 5`。\n\n### 数据范围\n\n$1\\le n\\le50$，$1\\le c\\le n$，$1\\le W_i \\le 100$，$1 \\leq \\text{路灯位置} \\leq 100$", "locale": "zh-CN", "translations": {"en": {"title": "Turning Off Streetlights", "background": "", "description": "A village installed $n$ streetlights along a road. Each light has a different power rating (that is, they consume different amounts of electricity over the same period). Old Zhang lives next to one of the streetlights somewhere in the middle of this road. His job is to turn off these streetlights one by one every morning at daybreak.\n\nTo save electricity for the village, Old Zhang recorded each streetlight’s position and power. Whenever he turns off the lights, he always walks as fast as possible. However, he does not know the order that minimizes the total electricity consumption. Every day at daybreak, he first turns off the streetlight at his own location, then he may go left or right to turn off other lights. At first, he thought to first sum the total power on the left and on the right, choose the side with the larger total power to turn off first, then go back to turn off the other side. In fact, this is not always optimal, because turning back at suitable moments during the process may save more.\n\nYou are given that Old Zhang’s walking speed is $1m/s$, and each streetlight’s position (an integer, the distance from the starting point of the route, in $m$) and power ($W$). The time he spends switching off a light is very short and can be ignored.\n\nPlease write a program to arrange the order of turning off the lights so that, measured from the moment Old Zhang starts, the total energy consumed by all lights is minimized (after a light is turned off, it no longer consumes power).", "inputFormat": "The first line contains two numbers $n$ (the total number of streetlights) and $c$ (the index of the streetlight where Old Zhang is located).\n\nThe next $n$ lines each contain two values, giving the position and power of the $1$-st through $n$-th streetlight. The positions are guaranteed to be strictly increasing.", "outputFormat": "Output one number: the minimal energy consumption (unit: $J$, $1J=1W\\times s$).", "hint": "### Sample Explanation\n\nIn this case, the turning-off order is `3 4 2 1 5`.\n\n### Constraints\n\n$1\\le n\\le 50$，$1\\le c\\le n$，$1\\le W_i \\le 100$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "关路灯", "background": "", "description": "某一村庄在一条路线上安装了 $n$ 盏路灯，每盏灯的功率有大有小（即同一段时间内消耗的电量有多有少）。老张就住在这条路中间某一路灯旁，他有一项工作就是每天早上天亮时一盏一盏地关掉这些路灯。\n\n为了给村里节省电费，老张记录下了每盏路灯的位置和功率，他每次关灯时也都是尽快地去关，但是老张不知道怎样去关灯才能够最节省电。他每天都是在天亮时首先关掉自己所处位置的路灯，然后可以向左也可以向右去关灯。开始他以为先算一下左边路灯的总功率再算一下右边路灯的总功率，然后选择先关掉功率大的一边，再回过头来关掉另一边的路灯，而事实并非如此，因为在关的过程中适当地调头有可能会更省一些。\n\n现在已知老张走的速度为 $1m/s$，每个路灯的位置（是一个整数，即距路线起点的距离，单位：$m$）、功率（$W$），老张关灯所用的时间很短而可以忽略不计。\n\n请你为老张编一程序来安排关灯的顺序，使从老张开始关灯时刻算起所有灯消耗电最少（灯关掉后便不再消耗电了）。", "inputFormat": "第一行是两个数字 $n$（表示路灯的总数）和 $c$（老张所处位置的路灯号）；\n\n接下来 $n$ 行，每行两个数据，表示第 $1$ 盏到第 $n$ 盏路灯的位置和功率。数据保证路灯位置单调递增。", "outputFormat": "一个数据，即最少的功耗（单位：$J$，$1J=1W\\times s$）。", "hint": "### 样例解释\n\n此时关灯顺序为 `3 4 2 1 5`。\n\n### 数据范围\n\n$1\\le n\\le50$，$1\\le c\\le n$，$1\\le W_i \\le 100$，$1 \\leq \\text{路灯位置} \\leq 100$", "locale": "zh-CN"}}}
{"pid": "P1221", "type": "P", "difficulty": 5, "samples": [["1000 2000", "Between 1000 and 2000, 1680 has a maximum of 40 divisors."]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索"], "title": "最多因子数", "background": "本题疑似错题。", "description": "数学家们喜欢各种类型的有奇怪特性的数。例如，他们认为 $945$ 是一个有趣的数，因为它是第一个所有约数之和大于本身的奇数。\n\n为了帮助他们寻找有趣的数，你将写一个程序扫描一定范围内的数，并确定在此范围内约数个数最多的那个数。不幸的是，这个数和给定的范围的都比较大，用简单的方法寻找可能需要较多的运行时间。所以请确定你的算法能在几秒内完成最大范围内的扫描。", "inputFormat": "只有一行，给出扫描的范围，由下界 $L$ 和上界 $U$ 确定。满足 $2\\le L\\le U\\le10^9$。", "outputFormat": "对于给定的范围，输出该范围内约数个数 $D$ 最多的数 $P$。若有多个，则输出最小的那个。请输出 $\\texttt{Between }L\\texttt{ and }U\\texttt{, }P\\texttt{ has a maximum of }D\\texttt{ divisors.}$，其中 $L,U,P,D$ 的含义同前面所述。", "hint": "update: 2024/6/6 加上了 6 组 hack。", "locale": "zh-CN", "translations": {"en": {"title": "Maximum Number of Divisors", "background": "This problem is suspected to be flawed.", "description": "Mathematicians like numbers with various strange properties. For example, they consider $945$ an interesting number because it is the first odd number whose sum of all divisors is greater than itself.\n\nTo help them find interesting numbers, you will write a program to scan numbers within a given range and determine the number in this range that has the most divisors. Unfortunately, both the number and the given range can be large, and using a simple approach may take a lot of time. So please ensure your algorithm can finish scanning the maximum range within a few seconds.", "inputFormat": "A single line giving the range to scan, specified by the lower bound $L$ and upper bound $U$, satisfying $2 \\le L \\le U \\le 10^9$.", "outputFormat": "For the given range, output the number $P$ in this range that has the maximum number of divisors $D$. If there are multiple, output the smallest one. Please output $\\texttt{Between }L\\texttt{ and }U\\texttt{, }P\\texttt{ has a maximum of }D\\texttt{ divisors.}$, where $L$, $U$, $P$, and $D$ have the meanings stated above.", "hint": "update: 2024/6/6 added 6 hack testcases.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最多因子数", "background": "本题疑似错题。", "description": "数学家们喜欢各种类型的有奇怪特性的数。例如，他们认为 $945$ 是一个有趣的数，因为它是第一个所有约数之和大于本身的奇数。\n\n为了帮助他们寻找有趣的数，你将写一个程序扫描一定范围内的数，并确定在此范围内约数个数最多的那个数。不幸的是，这个数和给定的范围的都比较大，用简单的方法寻找可能需要较多的运行时间。所以请确定你的算法能在几秒内完成最大范围内的扫描。", "inputFormat": "只有一行，给出扫描的范围，由下界 $L$ 和上界 $U$ 确定。满足 $2\\le L\\le U\\le10^9$。", "outputFormat": "对于给定的范围，输出该范围内约数个数 $D$ 最多的数 $P$。若有多个，则输出最小的那个。请输出 $\\texttt{Between }L\\texttt{ and }U\\texttt{, }P\\texttt{ has a maximum of }D\\texttt{ divisors.}$，其中 $L,U,P,D$ 的含义同前面所述。", "hint": "update: 2024/6/6 加上了 6 组 hack。", "locale": "zh-CN"}}}
{"pid": "P1222", "type": "P", "difficulty": 6, "samples": [["5\n-5 -3 6\n-1 -2 3\n0 0 2\n-2 2 1\n-4 -1 2\n", "24.5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何"], "title": "三角形", "background": "", "description": "给出平面上的 $n$ 个等腰直角三角形。每个三角形用三个整数 $x,y,m$ 描述。一个三角形的三个顶点分别是 $(x,y),(x+m,y),(x,y+m)$。\n\n你的任务是计算这些三角形覆盖的总面积。", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行每行描述一个三角形，包括三个整数 $x_i,y_i,m_i$。", "outputFormat": "输出文件仅包含一个实数，精确到小数点后一位，表示总面积。\n", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5ti25vl7.png)\n\n数据范围：$1\\le n \\le 2000$，$1 \\le i \\le n$，$-10^7 \\le x_i,y_i \\le 10^7$，$1\\leq m_i \\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Triangle", "background": "", "description": "Given $n$ isosceles right triangles on the plane. Each triangle is described by three integers $x, y, m$. The three vertices of a triangle are $(x, y)$, $(x + m, y)$, $(x, y + m)$.\n\nYour task is to compute the total area covered by these triangles.", "inputFormat": "The first line contains an integer $n$.\n\nEach of the next $n$ lines describes a triangle with three integers $x_i, y_i, m_i$.", "outputFormat": "Output a single real number with one digit after the decimal point, representing the total area.", "hint": "Sample explanation:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5ti25vl7.png)\n\nConstraints: $1 \\le n \\le 2000$, $1 \\le i \\le n$, $-10^7 \\le x_i, y_i \\le 10^7$, $1 \\leq m_i \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "三角形", "background": "", "description": "给出平面上的 $n$ 个等腰直角三角形。每个三角形用三个整数 $x,y,m$ 描述。一个三角形的三个顶点分别是 $(x,y),(x+m,y),(x,y+m)$。\n\n你的任务是计算这些三角形覆盖的总面积。", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行每行描述一个三角形，包括三个整数 $x_i,y_i,m_i$。", "outputFormat": "输出文件仅包含一个实数，精确到小数点后一位，表示总面积。\n", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5ti25vl7.png)\n\n数据范围：$1\\le n \\le 2000$，$1 \\le i \\le n$，$-10^7 \\le x_i,y_i \\le 10^7$，$1\\leq m_i \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P1223", "type": "P", "difficulty": 2, "samples": [["10 \n56 12 1 99 1000 234 33 55 99 812", "3 2 7 8 1 4 9 6 10 5\n291.90\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "排序"], "title": "排队接水", "background": null, "description": "有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。\n\n一个人的等待时间不包括他的接水时间。\n\n如果两个人接水的时间相同，编号更小的人应当排在前面。", "inputFormat": "第一行为一个整数 $n$。\n\n第二行 $n$ 个整数，第 $i$ 个整数 $T_i$ 表示第 $i$ 个人的接水时间 $T_i$。", "outputFormat": "输出文件有两行，第一行为一种平均时间最短的排队顺序；第二行为这种排列方案下的平均等待时间（输出结果精确到小数点后两位）。", "hint": "$1\\le n \\leq 1000$，$1\\le t_i \\leq 10^6$，不保证 $t_i$ 不重复。", "locale": "zh-CN", "translations": {"en": {"title": "Queueing for Water", "background": "", "description": "There are $n$ people lining up at a faucet. Suppose the time each person needs to fill water is $T_i$. Please write a program to find an ordering of these $n$ people that minimizes the average waiting time of all $n$ people.\n\nA person's waiting time does not include their own filling time.\n\nIf two people have the same filling time, the one with the smaller index should be placed earlier.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains $n$ integers. The $i$-th integer $T_i$ denotes the $i$-th person's filling time $T_i$.", "outputFormat": "Output two lines. The first line is an ordering that yields the minimum average waiting time. The second line is the average waiting time under this ordering (rounded to two decimal places).", "hint": "Constraints: $1 \\le n \\leq 1000$, $1 \\le t_i \\leq 10^6$. The $t_i$ are not guaranteed to be distinct.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "排队接水", "background": null, "description": "有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。\n\n一个人的等待时间不包括他的接水时间。\n\n如果两个人接水的时间相同，编号更小的人应当排在前面。", "inputFormat": "第一行为一个整数 $n$。\n\n第二行 $n$ 个整数，第 $i$ 个整数 $T_i$ 表示第 $i$ 个人的接水时间 $T_i$。", "outputFormat": "输出文件有两行，第一行为一种平均时间最短的排队顺序；第二行为这种排列方案下的平均等待时间（输出结果精确到小数点后两位）。", "hint": "$1\\le n \\leq 1000$，$1\\le t_i \\leq 10^6$，不保证 $t_i$ 不重复。", "locale": "zh-CN"}}}
{"pid": "P1224", "type": "P", "difficulty": 6, "samples": [["3 5 2 \n1 0 1 0 1 \n1 1 0 1 0 \n0 1 0 1 1\n", "2 3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "NOI", "Special Judge", "矩阵乘法", "向量"], "title": "[NOI2013] 向量内积", "background": "", "description": "两个 $d$ 维向量 $A=[a_1,a_2,\\ldots,a_d]$ 与 $B=[b_1,b_2,\\ldots,b_d]$ 的内积为其相对应维度的权值的乘积和，即：\n\n$$(A,B)=\\sum_{i=1}^d a_ib_i=a_1b_1+a_2b_2+\\ldots+a_db_d$$\n\n现有 $n$ 个 $d$ 维向量 $x_1,\\ldots,x_n$ ，小喵喵想知道是否存在两个向量的内积为 $k$ 的倍数。请帮助她解决这个问题。\n", "inputFormat": "第一行包含 $3$ 个正整数 $n,d,k$，分别表示向量的个数，维数以及待检测的倍数。\n\n接下来 $n$ 行每行有 $d$ 个非负整数，其中第 $i$ 行的第 $j$ 个整数表示向量 $x_i$ 的第 $j$ 维权值 $x_{i,j}$。\n", "outputFormat": "包含两个整数，用空格隔开。\n\n如果存在两个向量 $x_p,x_q$ 的内积为 $k$ 的整数倍，则输出两个向量的编号 $p$ 与 $q$（要求 $p<q$）。如果存在多组这样的向量组合，输出其中任意一组即可。\n\n若不存在这样的向量组合，则输出两个 $-1$。\n", "hint": "### 数据范围\n\n::cute-table{tuack}\n\n| 测试点编号 | $n$ | $d$ | $k$ | $x_{i,j}$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $2$ | $20$ | $2$ | $\\leq 10$ |\n| $2$ | $5$ | ^ | ^ | ^ |\n| $3$ | $10$ | $20$ | $3$ | ^ |\n| $4$ | $20$ | $20$ | $2$ | $\\leq 100$ |\n| $5$ | $50$ | $20$ | $3$ | ^ |\n| $6$ | $50$ | $50$ | $2$ | $\\leq 10^3$ |\n| $7$ | $50$ | $50$ | $3$ | $\\leq 3\\times 10^6 $ |\n| $8$ | $80$ | $80$ | $2$ | $\\leq 2\\times 10^6 $ |\n| $9$ | $100$ | $100$ | $3$ | $\\leq 3\\times 10^6 $ |\n| $10$ | $500$ | ^ | ^ | ^ |\n| $11$ | $10^3$ | ^ | $2$ | $\\leq 2\\times 10^6$ |\n| $12$ | $10^3$ | ^ | $3$ | $\\leq 3\\times 10^6$ |\n| $13$ | $10^4$ | ^ | $2$ | $<10$ |\n| $14$ | $10^4$ | ^ | $3$ | ^ |\n| $15$ | $1.5\\times 10^4$ | ^ | $2$ | ^ |\n| $16$ | $1.8\\times 10^4$ | ^ | ^ | ^ |\n| $17$ | $2\\times 10^4$ | ^ | ^ | ^ |\n| $18$ | $5\\times 10^4$ | $30$ | $3$ | ^ |\n| $19$ | $8\\times 10^4$ | ^ | ^ | ^ |\n| $20$ | $10^5$ | ^ | ^ | ^ |", "locale": "zh-CN", "translations": {"en": {"title": "{{[NOI2013] Vector Inner Product}}", "background": "{{}}", "description": "{{The dot product of two $d$-dimensional vectors $A=[a_1,a_2,\\ldots,a_d]$ and $B=[b_1,b_2,\\ldots,b_d]$ is the sum of the products of their corresponding coordinates, i.e.:\n\n$$(A,B)=\\sum_{i=1}^d a_ib_i=a_1b_1+a_2b_2+\\ldots+a_db_d$$\n\nGiven $n$ $d$-dimensional vectors $x_1,\\ldots,x_n$, Xiao Miaomiao (pinyin) wants to know whether there exist two vectors whose dot product is a multiple of $k$. Please help her solve this problem.}}", "inputFormat": "{{The first line contains $3$ positive integers $n, d, k$, representing the number of vectors, the dimension, and the multiple to check, respectively.\n\nThe next $n$ lines each contain $d$ non-negative integers. In the $i$-th line, the $j$-th integer is the $j$-th coordinate value $x_{i,j}$ of vector $x_i$.}}", "outputFormat": "{{Output two integers separated by a space.\n\nIf there exist two vectors $x_p, x_q$ whose dot product is an integer multiple of $k$, output their indices $p$ and $q$ (require $p<q$). If there are multiple valid pairs, output any one of them.\n\nIf no such pair exists, output two $-1$.}}", "hint": "{{### Constraints\n\n| Test point ID | $n$ | $d$ | $k$ | $x_{i,j}$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $2$ | $20$ | $2$ | $\\leq 10$ |\n| $2$ | $5$ | ^ | ^ | ^ |\n| $3$ | $10$ | $20$ | $3$ | ^ |\n| $4$ | $20$ | $20$ | $2$ | $\\leq 100$ |\n| $5$ | $50$ | $20$ | $3$ | ^ |\n| $6$ | $50$ | $50$ | $2$ | $\\leq 10^3$ |\n| $7$ | $50$ | $50$ | $3$ | $\\leq 3\\times 10^6 $ |\n| $8$ | $80$ | $80$ | $2$ | $\\leq 2\\times 10^6 $ |\n| $9$ | $100$ | $100$ | $3$ | $\\leq 3\\times 10^6 $ |\n| $10$ | $500$ | ^ | ^ | ^ |\n| $11$ | $10^3$ | ^ | $2$ | $\\leq 2\\times 10^6$ |\n| $12$ | $10^3$ | ^ | $3$ | $\\leq 3\\times 10^6$ |\n| $13$ | $10^4$ | ^ | $2$ | $<10$ |\n| $14$ | $10^4$ | ^ | $3$ | ^ |\n| $15$ | $1.5\\times 10^4$ | ^ | $2$ | ^ |\n| $16$ | $1.8\\times 10^4$ | ^ | ^ | ^ |\n| $17$ | $2\\times 10^4$ | ^ | ^ | ^ |\n| $18$ | $5\\times 10^4$ | $30$ | $3$ | ^ |\n| $19$ | $8\\times 10^4$ | ^ | ^ | ^ |\n| $20$ | $10^5$ | ^ | ^ | ^ |}}\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2013] 向量内积", "background": "", "description": "两个 $d$ 维向量 $A=[a_1,a_2,\\ldots,a_d]$ 与 $B=[b_1,b_2,\\ldots,b_d]$ 的内积为其相对应维度的权值的乘积和，即：\n\n$$(A,B)=\\sum_{i=1}^d a_ib_i=a_1b_1+a_2b_2+\\ldots+a_db_d$$\n\n现有 $n$ 个 $d$ 维向量 $x_1,\\ldots,x_n$ ，小喵喵想知道是否存在两个向量的内积为 $k$ 的倍数。请帮助她解决这个问题。\n", "inputFormat": "第一行包含 $3$ 个正整数 $n,d,k$，分别表示向量的个数，维数以及待检测的倍数。\n\n接下来 $n$ 行每行有 $d$ 个非负整数，其中第 $i$ 行的第 $j$ 个整数表示向量 $x_i$ 的第 $j$ 维权值 $x_{i,j}$。\n", "outputFormat": "包含两个整数，用空格隔开。\n\n如果存在两个向量 $x_p,x_q$ 的内积为 $k$ 的整数倍，则输出两个向量的编号 $p$ 与 $q$（要求 $p<q$）。如果存在多组这样的向量组合，输出其中任意一组即可。\n\n若不存在这样的向量组合，则输出两个 $-1$。\n", "hint": "### 数据范围\n\n::cute-table{tuack}\n\n| 测试点编号 | $n$ | $d$ | $k$ | $x_{i,j}$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $2$ | $20$ | $2$ | $\\leq 10$ |\n| $2$ | $5$ | ^ | ^ | ^ |\n| $3$ | $10$ | $20$ | $3$ | ^ |\n| $4$ | $20$ | $20$ | $2$ | $\\leq 100$ |\n| $5$ | $50$ | $20$ | $3$ | ^ |\n| $6$ | $50$ | $50$ | $2$ | $\\leq 10^3$ |\n| $7$ | $50$ | $50$ | $3$ | $\\leq 3\\times 10^6 $ |\n| $8$ | $80$ | $80$ | $2$ | $\\leq 2\\times 10^6 $ |\n| $9$ | $100$ | $100$ | $3$ | $\\leq 3\\times 10^6 $ |\n| $10$ | $500$ | ^ | ^ | ^ |\n| $11$ | $10^3$ | ^ | $2$ | $\\leq 2\\times 10^6$ |\n| $12$ | $10^3$ | ^ | $3$ | $\\leq 3\\times 10^6$ |\n| $13$ | $10^4$ | ^ | $2$ | $<10$ |\n| $14$ | $10^4$ | ^ | $3$ | ^ |\n| $15$ | $1.5\\times 10^4$ | ^ | $2$ | ^ |\n| $16$ | $1.8\\times 10^4$ | ^ | ^ | ^ |\n| $17$ | $2\\times 10^4$ | ^ | ^ | ^ |\n| $18$ | $5\\times 10^4$ | $30$ | $3$ | ^ |\n| $19$ | $8\\times 10^4$ | ^ | ^ | ^ |\n| $20$ | $10^5$ | ^ | ^ | ^ |", "locale": "zh-CN"}}}
{"pid": "P1225", "type": "P", "difficulty": 4, "samples": [["1111\n0000\n1110\n0010\n1010\n0101\n1010\n0101\n", "4\n1222\n1424\n3242\n4344\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "Special Judge"], "title": "黑白棋游戏", "background": "", "description": "黑白棋游戏的棋盘由 $4 \\times 4$ 方格阵列构成。棋盘的每一方格中放有 $1$ 枚棋子，共有 $8$ 枚白棋子和 $8$ 枚黑棋子。这 $16$ 枚棋子的每一种放置方案都构成一个游戏状态。在棋盘上拥有 $1$ 条公共边的 $2$ 个方格称为相邻方格。一个方格最多可有 $4$ 个相邻方格。在玩黑白棋游戏时，每一步可将任何 $2$ 个相邻方格中棋子互换位置。对于给定的初始游戏状态和目标游戏状态，编程计算从初始游戏状态变化到目标游戏状态的最短着棋序列。", "inputFormat": "输入文件共有 $8$ 行。前四行是初始游戏状态，后四行是目标游戏状态。每行 $4$ 个数分别表示该行放置的棋子颜色。“ $0$ ”表示白棋；“ $1$ ”表示黑棋。", "outputFormat": "输出文件的第一行是着棋步数 $n$。接下来 $n$ 行，每行 $4$ 个数分别表示该步交换棋子的两个相邻方格的位置。例如，abcd 表示将棋盘上 $(a,b)$ 处的棋子与 $(c,d)$ 处的棋子换位。", "hint": "由 @zhouyonglong 提供 SPJ\n", "locale": "zh-CN", "translations": {"en": {"title": "Black-and-White Chess Game", "background": "", "description": "The board of the black-and-white chess game consists of a $4 \\times 4$ grid. Each square contains $1$ piece, with $8$ white pieces and $8$ black pieces in total. Every arrangement of these $16$ pieces constitutes a game state. Two squares that share a common edge are called adjacent squares. A square can have at most $4$ adjacent squares. In each move, you may swap the pieces in any two adjacent squares. Given an initial game state and a target game state, write a program to compute the shortest sequence of moves that transforms the initial state into the target state.", "inputFormat": "The input consists of $8$ lines. The first $4$ lines describe the initial game state, and the last $4$ lines describe the target game state. Each line contains $4$ numbers indicating the colors of the pieces in that row. \"0\" denotes a white piece; \"1\" denotes a black piece.", "outputFormat": "Output the number of moves $n$ on the first line. Then output $n$ lines, each containing $4$ numbers that represent the positions of the two adjacent squares whose pieces are swapped in that move. For example, abcd denotes swapping the piece at $(a,b)$ with the piece at $(c,d)$.", "hint": "SPJ provided by @zhouyonglong.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "黑白棋游戏", "background": "", "description": "黑白棋游戏的棋盘由 $4 \\times 4$ 方格阵列构成。棋盘的每一方格中放有 $1$ 枚棋子，共有 $8$ 枚白棋子和 $8$ 枚黑棋子。这 $16$ 枚棋子的每一种放置方案都构成一个游戏状态。在棋盘上拥有 $1$ 条公共边的 $2$ 个方格称为相邻方格。一个方格最多可有 $4$ 个相邻方格。在玩黑白棋游戏时，每一步可将任何 $2$ 个相邻方格中棋子互换位置。对于给定的初始游戏状态和目标游戏状态，编程计算从初始游戏状态变化到目标游戏状态的最短着棋序列。", "inputFormat": "输入文件共有 $8$ 行。前四行是初始游戏状态，后四行是目标游戏状态。每行 $4$ 个数分别表示该行放置的棋子颜色。“ $0$ ”表示白棋；“ $1$ ”表示黑棋。", "outputFormat": "输出文件的第一行是着棋步数 $n$。接下来 $n$ 行，每行 $4$ 个数分别表示该步交换棋子的两个相邻方格的位置。例如，abcd 表示将棋盘上 $(a,b)$ 处的棋子与 $(c,d)$ 处的棋子换位。", "hint": "由 @zhouyonglong 提供 SPJ\n", "locale": "zh-CN"}}}
{"pid": "P1226", "type": "P", "difficulty": 2, "samples": [["2 10 9\n", "2^10 mod 9=7\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "递推", "递归", "模板题"], "title": "【模板】快速幂", "background": "", "description": "给你三个整数 $a,b,p$，求 $a^b \\bmod p$。", "inputFormat": "输入只有一行三个整数，分别代表 $a,b,p$。\n", "outputFormat": "输出一行一个字符串 `a^b mod p=s`，其中 $a,b,p$ 分别为题目给定的值， $s$ 为运算结果。", "hint": "**样例解释**\n\n$2^{10} = 1024$，$1024 \\bmod 9 = 7$。\n\n**数据规模与约定**\n\n对于 $100\\%$ 的数据，保证 $0\\le a,b < 2^{31}$，$a+b>0$，$2 \\leq p \\lt 2^{31}$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Fast Power", "background": "", "description": "Given three integers $a$, $b$, $p$, compute $a^b \\bmod p$.", "inputFormat": "The input contains a single line with three integers representing $a$, $b$, $p$.", "outputFormat": "Output one line with the string `a^b mod p=s`, where $a$, $b$, $p$ are the given values and $s$ is the result.", "hint": "Sample Explanation:\n\n$2^{10} = 1024$，$1024 \\bmod 9 = 7$.\n\nConstraints:\n\nFor $100\\%$ of the testdata, it is guaranteed that $0 \\leq a, b < 2^{31}$, $a + b > 0$, $2 \\leq p \\lt 2^{31}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】快速幂", "background": "", "description": "给你三个整数 $a,b,p$，求 $a^b \\bmod p$。", "inputFormat": "输入只有一行三个整数，分别代表 $a,b,p$。\n", "outputFormat": "输出一行一个字符串 `a^b mod p=s`，其中 $a,b,p$ 分别为题目给定的值， $s$ 为运算结果。", "hint": "**样例解释**\n\n$2^{10} = 1024$，$1024 \\bmod 9 = 7$。\n\n**数据规模与约定**\n\n对于 $100\\%$ 的数据，保证 $0\\le a,b < 2^{31}$，$a+b>0$，$2 \\leq p \\lt 2^{31}$。", "locale": "zh-CN"}}}
{"pid": "P1227", "type": "P", "difficulty": 3, "samples": [["8\r\n1 10\r\n3 6\r\n6 8\r\n6 2\r\n3 -4\r\n1 0\r\n-2 -2\r\n-2 4\r\n", "V.I.P. should stay at (2.0,3.0)."]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "数学", "2008", "各省省选", "江苏", "排序"], "title": "[JSOI2008] 完美的对称", "background": "", "description": "在峰会期间，必须使用许多保镖保卫参加会议的各国代表。代表们除了由他自己的随身保镖保护外，组委会还指派了一些其他的特工和阻击手保护他们。为了使他们的工作卓有成效，使被保卫的人的安全尽可能得到保障，保镖被分配到被保护人的各个方向。\n\n保镖的最佳站立位置应该是这样的：被保护人应站在所有保镖的对称中心。但是，只要被保护人一移动，保镖就很难根据要人的新位置调整位置。大多数的特工都很难对此作出实时调整。\n\n因此，安全部长决定将该过程逆转一下，保镖先站好自己的位置，然后要人在他们的对称中心找到合适的位置。如果要人随便走动，我们就对他的安全不必负责。\n\n你的工作是使这个过程自动操作。给出一组 $N$ 个点（保镖的位置），你要找出它们的对称中心 $S$，在这儿被保护人将相对安全。下面以此类推。\n\n首先我们给定一点 $A$ 以及对称中心 $S$，点 $A'$ 是点 $A$ 以 $S$ 为对称中心形成的像点，即点 $S$ 是线段 $AA'$ 的对称中心。\n\n点阵组（$X$）以 $S$ 为中心的像点是由每个点的像点组成的点阵组。$X$ 是用来产生对称中心 $S$ 的，即点阵 $X$ 以 $S$ 为中心的像点的集合即为点阵 $X$ 本身。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/trym53o8.png)\n", "inputFormat": "输入文件第一行是一个整数 $N$，$1\\le N\\le 20000$，接下来的 $N$ 行每行包含用空格隔开的两个整数 $X_i$ 和 $Y_i$，$-10^5\\le X_i,Y_i\\le 10^5$，表示这组点阵中第 $i$ 个点的笛卡尔坐标值。\n\n\n因为任何两个保镖都不会站在同一个位置上，所以在给定的作业中，任何两点都不相同。但注意保镖可以站在被保护人相同的位置。\n", "outputFormat": "输出文件仅有一行。如果给定的点阵能产生一个对称中心，则输出 $\\texttt{V.I.P.  should  stay  at (}x\\texttt{,}y\\texttt{).}$，其中 $x$ 和 $y$ 代表中心的笛卡尔坐标值，格式为四舍五入保留至小数点后一位。\n\n\n如果该组点阵无对称中心，输出 `This is a dangerous situation!`，注意输出时除了两个单词之间用一个空格隔开外，不要输出多余空格。\n", "hint": "JSOI2008 第二轮。\n", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2008] Perfect Symmetry", "background": "", "description": "During the summit, many bodyguards are needed to protect the representatives of various countries. Besides their own personal bodyguards, the organizing committee also assigns additional agents and snipers to protect them. To make their work effective and maximize the safety of the protected person, bodyguards are deployed in all directions around the VIP.\n\nThe optimal standing positions for the bodyguards should be such that the protected person stands at the center of symmetry of all bodyguards. However, once the VIP moves, it becomes hard for the bodyguards to adjust their positions according to the VIP’s new location. Most agents cannot make this adjustment in real time.\n\nTherefore, the Minister of Security decides to reverse the process: the bodyguards take their positions first, and then the VIP finds an appropriate position at their center of symmetry. If the VIP walks around freely, we are not responsible for his safety.\n\nYour task is to automate this process. Given a set of $N$ points (the bodyguards’ positions), find their center of symmetry $S$, where the VIP will be relatively safe. The definitions are as follows.\n\nFirst, given a point $A$ and a center of symmetry $S$, the point $A'$ is the image of $A$ with respect to $S$, i.e., $S$ is the midpoint of segment $AA'$.\n\nThe image of a point set $X$ with respect to $S$ is the point set consisting of the images of all its points. The set $X$ admits a center of symmetry $S$ if the image of $X$ with respect to $S$ equals $X$ itself.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/trym53o8.png)", "inputFormat": "The first line of input contains an integer $N$, $1\\le N\\le 20000$. Each of the next $N$ lines contains two integers $X_i$ and $Y_i$, $-10^5\\le X_i,Y_i\\le 10^5$, giving the Cartesian coordinates of the $i$-th point in the set.\n\nNo two bodyguards will stand at the same position, so any two points in the input are distinct. Note that a bodyguard may stand at the same position as the VIP.", "outputFormat": "Output exactly one line. If the given set admits a center of symmetry, print $\\texttt{V.I.P.  should  stay  at (}x\\texttt{,}y\\texttt{).}$, where $x$ and $y$ are the coordinates of the center, rounded to one decimal place.\n\nIf the set has no center of symmetry, output `This is a dangerous situation!`. Make sure there is exactly one space between words and no extra spaces.", "hint": "JSOI2008 Round 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2008] 完美的对称", "background": "", "description": "在峰会期间，必须使用许多保镖保卫参加会议的各国代表。代表们除了由他自己的随身保镖保护外，组委会还指派了一些其他的特工和阻击手保护他们。为了使他们的工作卓有成效，使被保卫的人的安全尽可能得到保障，保镖被分配到被保护人的各个方向。\n\n保镖的最佳站立位置应该是这样的：被保护人应站在所有保镖的对称中心。但是，只要被保护人一移动，保镖就很难根据要人的新位置调整位置。大多数的特工都很难对此作出实时调整。\n\n因此，安全部长决定将该过程逆转一下，保镖先站好自己的位置，然后要人在他们的对称中心找到合适的位置。如果要人随便走动，我们就对他的安全不必负责。\n\n你的工作是使这个过程自动操作。给出一组 $N$ 个点（保镖的位置），你要找出它们的对称中心 $S$，在这儿被保护人将相对安全。下面以此类推。\n\n首先我们给定一点 $A$ 以及对称中心 $S$，点 $A'$ 是点 $A$ 以 $S$ 为对称中心形成的像点，即点 $S$ 是线段 $AA'$ 的对称中心。\n\n点阵组（$X$）以 $S$ 为中心的像点是由每个点的像点组成的点阵组。$X$ 是用来产生对称中心 $S$ 的，即点阵 $X$ 以 $S$ 为中心的像点的集合即为点阵 $X$ 本身。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/trym53o8.png)\n", "inputFormat": "输入文件第一行是一个整数 $N$，$1\\le N\\le 20000$，接下来的 $N$ 行每行包含用空格隔开的两个整数 $X_i$ 和 $Y_i$，$-10^5\\le X_i,Y_i\\le 10^5$，表示这组点阵中第 $i$ 个点的笛卡尔坐标值。\n\n\n因为任何两个保镖都不会站在同一个位置上，所以在给定的作业中，任何两点都不相同。但注意保镖可以站在被保护人相同的位置。\n", "outputFormat": "输出文件仅有一行。如果给定的点阵能产生一个对称中心，则输出 $\\texttt{V.I.P.  should  stay  at (}x\\texttt{,}y\\texttt{).}$，其中 $x$ 和 $y$ 代表中心的笛卡尔坐标值，格式为四舍五入保留至小数点后一位。\n\n\n如果该组点阵无对称中心，输出 `This is a dangerous situation!`，注意输出时除了两个单词之间用一个空格隔开外，不要输出多余空格。\n", "hint": "JSOI2008 第二轮。\n", "locale": "zh-CN"}}}
{"pid": "P1228", "type": "P", "difficulty": 3, "samples": [["3                          \n3 3   ", "5 5 1\n2 2 4\n1 1 4\n1 4 3\n4 1 2\n4 4 1\n2 7 3\n1 5 4\n1 8 3\n3 6 3\n4 8 1\n7 2 2\n5 1 4\n6 3 2\n8 1 2\n8 4 1\n7 7 1\n6 6 1\n5 8 3\n8 5 2\n8 8 1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递归", "Special Judge", "分治"], "title": "地毯填补问题", "background": "", "description": "相传在一个古老的阿拉伯国家里，有一座宫殿。宫殿里有个四四方方的格子迷宫，国王选择驸马的方法非常特殊，也非常简单：公主就站在其中一个方格子上，只要谁能用地毯将除公主站立的地方外的所有地方盖上，美丽漂亮聪慧的公主就是他的人了。公主这一个方格不能用地毯盖住，毯子的形状有所规定，只能有四种选择（如图）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cik5fiow.png)\n\n并且每一方格只能用一层地毯，迷宫的大小为 $2^k\\times 2^k$ 的方形。当然，也不能让公主无限制的在那儿等，对吧？由于你使用的是计算机，所以实现时间为 $1$ 秒。\n", "inputFormat": "输入文件共 $2$ 行。\n\n第一行一个整数 $k$，即给定被填补迷宫的大小为 $2^k\\times 2^k$（$0\\lt k\\leq 10$）；\n第二行两个整数 $x,y$，即给出公主所在方格的坐标（$x$ 为行坐标，$y$ 为列坐标），$x$ 和 $y$ 之间有一个空格隔开。\n", "outputFormat": "将迷宫填补完整的方案：每一补（行）为 $x\\ y\\ c$（$x,y$ 为毯子拐角的行坐标和列坐标，$c$ 为使用毯子的形状，具体见上面的图 $1$，毯子形状分别用 $1,2,3,4$ 表示，$x,y,c$ 之间用一个空格隔开）。\n", "hint": "spj 报错代码解释：\n\n1. $c$ 越界；\n2. $x,y$ 越界；\n3. $(x,y)$ 位置已被覆盖；\n4. $(x,y)$ 位置从未被覆盖。\n\n$\\text{upd 2023.8.19}$：增加样例解释。\n\n### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r9j8r452.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "Carpet Tiling Problem", "background": "# Description\n\nIt is said that in an ancient Arabian country, there was a palace. Inside the palace, there was a square grid maze. The king’s method for choosing a prince consort was very special and simple: the princess stood on one grid cell, and whoever could cover every other cell with carpets, except the one where the princess stood, would win the beautiful, elegant, and intelligent princess. The princess’s cell must not be covered, and the carpet shape is restricted to four options only (see the figure):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cik5fiow.png)\n\nEach grid cell may be covered by at most one layer of carpet. The maze is a square of size $2^k\\times 2^k$. The time limit is $1$ second.", "description": "", "inputFormat": "", "outputFormat": "Output a complete tiling plan: each placement (one line) is $x\\ y\\ c$ ($x, y$ are the row and column of the carpet’s corner cell, and $c$ is the carpet’s shape; see Figure $1$ above. The four shapes are represented by $1, 2, 3, 4$. Separate $x, y, c$ with a single space).", "hint": "Explanation of SPJ error codes:\n\n1. $c$ is out of range.\n2. $x, y$ are out of range.\n3. The position $(x, y)$ has already been covered.\n4. The position $(x, y)$ was never covered.\n\n$\\text{upd 2023.8.19}$: Added sample explanation.\n\n### Sample Explanation\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r9j8r452.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "地毯填补问题", "background": "", "description": "相传在一个古老的阿拉伯国家里，有一座宫殿。宫殿里有个四四方方的格子迷宫，国王选择驸马的方法非常特殊，也非常简单：公主就站在其中一个方格子上，只要谁能用地毯将除公主站立的地方外的所有地方盖上，美丽漂亮聪慧的公主就是他的人了。公主这一个方格不能用地毯盖住，毯子的形状有所规定，只能有四种选择（如图）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cik5fiow.png)\n\n并且每一方格只能用一层地毯，迷宫的大小为 $2^k\\times 2^k$ 的方形。当然，也不能让公主无限制的在那儿等，对吧？由于你使用的是计算机，所以实现时间为 $1$ 秒。\n", "inputFormat": "输入文件共 $2$ 行。\n\n第一行一个整数 $k$，即给定被填补迷宫的大小为 $2^k\\times 2^k$（$0\\lt k\\leq 10$）；\n第二行两个整数 $x,y$，即给出公主所在方格的坐标（$x$ 为行坐标，$y$ 为列坐标），$x$ 和 $y$ 之间有一个空格隔开。\n", "outputFormat": "将迷宫填补完整的方案：每一补（行）为 $x\\ y\\ c$（$x,y$ 为毯子拐角的行坐标和列坐标，$c$ 为使用毯子的形状，具体见上面的图 $1$，毯子形状分别用 $1,2,3,4$ 表示，$x,y,c$ 之间用一个空格隔开）。\n", "hint": "spj 报错代码解释：\n\n1. $c$ 越界；\n2. $x,y$ 越界；\n3. $(x,y)$ 位置已被覆盖；\n4. $(x,y)$ 位置从未被覆盖。\n\n$\\text{upd 2023.8.19}$：增加样例解释。\n\n### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r9j8r452.png)\n", "locale": "zh-CN"}}}
{"pid": "P1229", "type": "P", "difficulty": 3, "samples": [["abc                           \ncba\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["树形数据结构"], "title": "遍历问题", "background": "", "description": "我们都很熟悉二叉树的前序、中序、后序遍历，在数据结构中常提出这样的问题：已知一棵二叉树的前序和中序遍历，求它的后序遍历，相应的，已知一棵二叉树的后序遍历和中序遍历序列你也能求出它的前序遍历。然而给定一棵二叉树的前序和后序遍历，你却不能确定其中序遍历序列，考虑如下图中的几棵二叉树：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/w75s9yip.png)\n\n所有这些二叉树都有着相同的前序遍历和后序遍历，但中序遍历却不相同。\n\n", "inputFormat": "共两行，第一行表示该二叉树的前序遍历结果 $s_1$，第二行表示该二叉树的后序遍历结果 $s_2$。\n\n\n保证至少存在一棵二叉树满足给出的信息，$s _ 1, s _ 2$ 中只含小写字母，且在某个字符串中不存在相同的字母。", "outputFormat": "输出可能的中序遍历序列的总数，结果不超过 $2^{63}-1$。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Traversal Problem", "background": "", "description": "We are all familiar with preorder, inorder, and postorder traversals of binary trees. In data structures, a common problem is: given the preorder and inorder traversals of a binary tree, find its postorder traversal; similarly, given the postorder and inorder traversals, you can find its preorder traversal. However, given the preorder and postorder traversals of a binary tree, you cannot determine its inorder traversal. Consider the binary trees in the figure below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/w75s9yip.png)\n\nAll these binary trees have the same preorder and postorder traversals, but different inorder traversals.", "inputFormat": "Two lines in total. The first line is the preorder traversal $s_1$ of the binary tree, and the second line is the postorder traversal $s_2$.\n\nIt is guaranteed that at least one binary tree satisfies the given information. $s_1, s_2$ contain only lowercase letters, and within each string no letter appears more than once.", "outputFormat": "Output the total number of possible inorder traversal sequences. The result does not exceed $2^{63}-1$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "遍历问题", "background": "", "description": "我们都很熟悉二叉树的前序、中序、后序遍历，在数据结构中常提出这样的问题：已知一棵二叉树的前序和中序遍历，求它的后序遍历，相应的，已知一棵二叉树的后序遍历和中序遍历序列你也能求出它的前序遍历。然而给定一棵二叉树的前序和后序遍历，你却不能确定其中序遍历序列，考虑如下图中的几棵二叉树：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/w75s9yip.png)\n\n所有这些二叉树都有着相同的前序遍历和后序遍历，但中序遍历却不相同。\n\n", "inputFormat": "共两行，第一行表示该二叉树的前序遍历结果 $s_1$，第二行表示该二叉树的后序遍历结果 $s_2$。\n\n\n保证至少存在一棵二叉树满足给出的信息，$s _ 1, s _ 2$ 中只含小写字母，且在某个字符串中不存在相同的字母。", "outputFormat": "输出可能的中序遍历序列的总数，结果不超过 $2^{63}-1$。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1230", "type": "P", "difficulty": 3, "samples": [["10000\n7\n4 2 4 3 1 4 6\n70 60 50 40 30 20 10\n", "9950"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "排序"], "title": "智力大冲浪", "background": "", "description": "小伟报名参加中央电视台的智力大冲浪节目。本次挑战赛吸引了众多参赛者，主持人为了表彰大家的勇气，先奖励每个参赛者 $m$ 元。先不要太高兴，因为这些钱还不一定都是你的。接下来主持人宣布了比赛规则：\n\n首先，比赛时间分为 $n$ 个时段，它又给出了很多小游戏，每个小游戏都必须在规定期限 $t_i$ 前完成。如果一个游戏没能在规定期限前完成，则要从奖励费 $m$ 元中扣去一部分钱 $w_i$，$w_i$ 为自然数，不同的游戏扣去的钱是不一样的。当然，每个游戏本身都很简单，保证每个参赛者都能在一个时段内完成，而且都必须从整时段开始。主持人只是想考考每个参赛者如何安排组织自己做游戏的顺序。作为参赛者，小伟很想赢得冠军，当然更想赢取最多的钱！注意：比赛绝对不会让参赛者赔钱!\n", "inputFormat": "第一行为 $m$，表示一开始奖励给每位参赛者的钱；\n\n第二行为 $n$，表示有 $n$ 个小游戏；\n\n第三行有 $n$ 个数，分别表示游戏 $1$ 到 $n$ 的规定完成期限；\n\n第四行有 $n$ 个数，分别表示游戏 $1$ 到 $n$ 不能在规定期限前完成的扣款数。", "outputFormat": "输出仅一行，表示小伟能赢取最多的钱。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 500$，$1 \\le m \\le 5 \\times 10^5$，$1 \\le t_i \\le n$，$1 \\le w_i \\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Intellectual Surfing", "background": "", "description": "Xiaowei signed up for China Central Television (CCTV)'s “Intellectual Surfing” show. This challenge has attracted many contestants. To honor everyone’s courage, the host first awards each contestant $m$ yuan. Don’t celebrate too soon, because this money may not all be yours. Next, the host announces the rules:\n\nFirst, the contest time is divided into $n$ time slots, and the host also provides many mini-games. Each mini-game must be completed before its deadline $t_i$. If a game is not completed before its deadline, a penalty $w_i$ will be deducted from the $m$ yuan award. Here $w_i$ are natural numbers, and the deduction differs from game to game. Of course, every game itself is very simple: each contestant can finish any single game within one time slot, and each game must start at the beginning of a whole time slot. The host only wants to test how each contestant schedules the order of games. As a contestant, Xiaowei wants to win the championship and, of course, the most money! Note: The contest will never make contestants lose money.", "inputFormat": "- The first line contains $m$, the initial award for each contestant.\n- The second line contains $n$, the number of mini-games.\n- The third line contains $n$ numbers, the deadlines of games $1$ through $n$.\n- The fourth line contains $n$ numbers, the penalty amounts if games $1$ through $n$ are not completed before their deadlines.", "outputFormat": "Output a single line: the maximum amount of money Xiaowei can win.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le n \\le 500$, $1 \\le m \\le 5 \\times 10^5$, $1 \\le t_i \\le n$, $1 \\le w_i \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "智力大冲浪", "background": "", "description": "小伟报名参加中央电视台的智力大冲浪节目。本次挑战赛吸引了众多参赛者，主持人为了表彰大家的勇气，先奖励每个参赛者 $m$ 元。先不要太高兴，因为这些钱还不一定都是你的。接下来主持人宣布了比赛规则：\n\n首先，比赛时间分为 $n$ 个时段，它又给出了很多小游戏，每个小游戏都必须在规定期限 $t_i$ 前完成。如果一个游戏没能在规定期限前完成，则要从奖励费 $m$ 元中扣去一部分钱 $w_i$，$w_i$ 为自然数，不同的游戏扣去的钱是不一样的。当然，每个游戏本身都很简单，保证每个参赛者都能在一个时段内完成，而且都必须从整时段开始。主持人只是想考考每个参赛者如何安排组织自己做游戏的顺序。作为参赛者，小伟很想赢得冠军，当然更想赢取最多的钱！注意：比赛绝对不会让参赛者赔钱!\n", "inputFormat": "第一行为 $m$，表示一开始奖励给每位参赛者的钱；\n\n第二行为 $n$，表示有 $n$ 个小游戏；\n\n第三行有 $n$ 个数，分别表示游戏 $1$ 到 $n$ 的规定完成期限；\n\n第四行有 $n$ 个数，分别表示游戏 $1$ 到 $n$ 不能在规定期限前完成的扣款数。", "outputFormat": "输出仅一行，表示小伟能赢取最多的钱。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 500$，$1 \\le m \\le 5 \\times 10^5$，$1 \\le t_i \\le n$，$1 \\le w_i \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P1231", "type": "P", "difficulty": 6, "samples": [["5 3 4\n5\n4 3\n2 2\n5 2\n5 1\n5 3\n5\n1 3\n3 1\n2 2\n3 3\n4 3\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "网络流", "洛谷原创", "洛谷月赛"], "title": "教辅的组成", "background": "滚粗了的 HansBug 在收拾旧语文书，然而他发现了什么奇妙的东西。\n", "description": "蒟蒻 HansBug 在一本语文书里面发现了一本答案，然而他却明明记得这书应该还包含一份练习题。然而出现在他眼前的书多得数不胜数，其中有书，有答案，有练习册。已知一个完整的书册均应该包含且仅包含一本书、一本练习册和一份答案，然而现在全都乱做了一团。许多书上面的字迹都已经模糊了，然而 HansBug 还是可以大致判断这是一本书还是练习册或答案，并且能够大致知道一本书和答案以及一本书和练习册的对应关系（即仅仅知道某书和某答案、某书和某练习册有可能相对应，除此以外的均不可能对应）。既然如此，HansBug 想知道在这样的情况下，最多可能同时组合成多少个完整的书册。\n\n", "inputFormat": "第一行包含三个正整数 $N_1,N_2,N_3$，分别表示书的个数、练习册的个数和答案的个数。\n\n第二行包含一个正整数 $M_1$，表示书和练习册可能的对应关系个数。\n\n接下来 $M_1$ 行每行包含两个正整数 $x,y$，表示第 $x$ 本书和第 $y$ 本练习册可能对应。（$1\\leq x \\leq N_1$，$1 \\leq y \\leq N_2$）\n\n第 $M_{1}+3$ 行包含一个正整数 $M_2$，表述书和答案可能的对应关系个数。\n\n接下来 $M_2$ 行每行包含两个正整数 $x,y$，表示第 $x$ 本书和第 $y$ 本答案可能对应。（$1 \\leq x \\leq N_1$，$1 \\leq y \\leq N_3$）\n", "outputFormat": "输出包含一个正整数，表示最多可能组成完整书册的数目。\n", "hint": "样例说明：\n\n如题，$N_1=5$，$N_2=3$，$N_3=4$，表示书有 $5$ 本、练习册有 $3$ 本、答案有 $4$ 本。\n\n$M_1=5$，表示书和练习册共有 $5$ 个可能的对应关系，分别为：书 $4$ 和练习册 $3$ 、书 $2$ 和练习册 $2$ 、书 $5$ 和练习册 $2$ 、书 $5$ 和练习册 $1$ 以及书 $5$ 和练习册 $3$。\n\n$M_2=5$，表示数和答案共有 $5$ 个可能的对应关系，分别为：书 $1$ 和答案 $3$、书 $3$ 和答案 $1$、书 $2$ 和答案 $2$、书 $3$ 和答案 $3$ 以及书 $4$ 和答案 $3$。\n\n所以，以上情况的话最多可以同时配成两个书册，分别为：书 $2$ 练习册 $2$ 答案 $2$、书 $4$ 练习册 $3$ 答案 $3$。\n\n\n数据规模：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/srj2v9um.png)\n\n对于数据点 $1,2,3$，$1\\le M_1,M_2\\leq 20$。\n\n对于数据点 $4\\sim 10$，$1\\le M_1,M_2 \\leq 20000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Composition of Study Aids", "background": "HansBug, who had been kicked out, was tidying up old Chinese textbooks when he discovered something curious.", "description": "In a Chinese textbook, HansBug found an answer key, but he clearly remembered that the book should also come with a workbook. However, there are too many items in front of him to count, including books, answer keys, and workbooks. A complete set should contain and only contain one book, one workbook, and one answer key, but everything is in a mess now. Although many labels have faded, HansBug can still roughly tell whether an item is a book, a workbook, or an answer key. He also roughly knows the possible correspondences between a book and an answer key, and between a book and a workbook (that is, he only knows which book and which answer key, and which book and which workbook could possibly correspond; all other pairs are impossible). Given this information, HansBug wants to know the maximum number of complete sets that can be formed simultaneously.", "inputFormat": "The first line contains three positive integers $N_1,N_2,N_3$, representing the numbers of books, workbooks, and answer keys respectively.\n\nThe second line contains a positive integer $M_1$, representing the number of possible correspondences between books and workbooks.\n\nEach of the next $M_1$ lines contains two positive integers $x,y$, indicating that book $x$ and workbook $y$ could correspond. ($1\\leq x \\leq N_1$, $1 \\leq y \\leq N_2$)\n\nThe next line contains a positive integer $M_2$, representing the number of possible correspondences between books and answer keys.\n\nEach of the next $M_2$ lines contains two positive integers $x,y$, indicating that book $x$ and answer key $y$ could correspond. ($1 \\leq x \\leq N_1$, $1 \\leq y \\leq N_3$)", "outputFormat": "Output a single positive integer, the maximum possible number of complete sets.", "hint": "Sample explanation:\n\nAs described, $N_1=5$, $N_2=3$, $N_3=4$, meaning there are $5$ books, $3$ workbooks, and $4$ answer keys.\n\n$M_1=5$, meaning there are $5$ possible correspondences between books and workbooks, namely: book $4$ with workbook $3$, book $2$ with workbook $2$, book $5$ with workbook $2$, book $5$ with workbook $1$, and book $5$ with workbook $3$.\n\n$M_2=5$, meaning there are $5$ possible correspondences between books and answer keys, namely: book $1$ with answer key $3$, book $3$ with answer key $1$, book $2$ with answer key $2$, book $3$ with answer key $3$, and book $4$ with answer key $3$.\n\nTherefore, at most two complete sets can be formed simultaneously in this case, namely: book $2$ + workbook $2$ + answer key $2$, and book $4$ + workbook $3$ + answer key $3$.\n\nConstraints:\n\n- For testdata points $1,2,3$, $1\\le M_1,M_2\\leq 20$.\n- For testdata points $4\\sim 10$, $1\\le M_1,M_2 \\leq 20000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "教辅的组成", "background": "滚粗了的 HansBug 在收拾旧语文书，然而他发现了什么奇妙的东西。\n", "description": "蒟蒻 HansBug 在一本语文书里面发现了一本答案，然而他却明明记得这书应该还包含一份练习题。然而出现在他眼前的书多得数不胜数，其中有书，有答案，有练习册。已知一个完整的书册均应该包含且仅包含一本书、一本练习册和一份答案，然而现在全都乱做了一团。许多书上面的字迹都已经模糊了，然而 HansBug 还是可以大致判断这是一本书还是练习册或答案，并且能够大致知道一本书和答案以及一本书和练习册的对应关系（即仅仅知道某书和某答案、某书和某练习册有可能相对应，除此以外的均不可能对应）。既然如此，HansBug 想知道在这样的情况下，最多可能同时组合成多少个完整的书册。\n\n", "inputFormat": "第一行包含三个正整数 $N_1,N_2,N_3$，分别表示书的个数、练习册的个数和答案的个数。\n\n第二行包含一个正整数 $M_1$，表示书和练习册可能的对应关系个数。\n\n接下来 $M_1$ 行每行包含两个正整数 $x,y$，表示第 $x$ 本书和第 $y$ 本练习册可能对应。（$1\\leq x \\leq N_1$，$1 \\leq y \\leq N_2$）\n\n第 $M_{1}+3$ 行包含一个正整数 $M_2$，表述书和答案可能的对应关系个数。\n\n接下来 $M_2$ 行每行包含两个正整数 $x,y$，表示第 $x$ 本书和第 $y$ 本答案可能对应。（$1 \\leq x \\leq N_1$，$1 \\leq y \\leq N_3$）\n", "outputFormat": "输出包含一个正整数，表示最多可能组成完整书册的数目。\n", "hint": "样例说明：\n\n如题，$N_1=5$，$N_2=3$，$N_3=4$，表示书有 $5$ 本、练习册有 $3$ 本、答案有 $4$ 本。\n\n$M_1=5$，表示书和练习册共有 $5$ 个可能的对应关系，分别为：书 $4$ 和练习册 $3$ 、书 $2$ 和练习册 $2$ 、书 $5$ 和练习册 $2$ 、书 $5$ 和练习册 $1$ 以及书 $5$ 和练习册 $3$。\n\n$M_2=5$，表示数和答案共有 $5$ 个可能的对应关系，分别为：书 $1$ 和答案 $3$、书 $3$ 和答案 $1$、书 $2$ 和答案 $2$、书 $3$ 和答案 $3$ 以及书 $4$ 和答案 $3$。\n\n所以，以上情况的话最多可以同时配成两个书册，分别为：书 $2$ 练习册 $2$ 答案 $2$、书 $4$ 练习册 $3$ 答案 $3$。\n\n\n数据规模：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/srj2v9um.png)\n\n对于数据点 $1,2,3$，$1\\le M_1,M_2\\leq 20$。\n\n对于数据点 $4\\sim 10$，$1\\le M_1,M_2 \\leq 20000$。\n", "locale": "zh-CN"}}}
{"pid": "P1232", "type": "P", "difficulty": 6, "samples": [["5 \n1 2 4 5 3 \n1 2 3 4 5\n", "3.500\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "2013", "NOI", "广度优先搜索 BFS", "深度优先搜索 DFS"], "title": "[NOI2013] 树的计数", "background": "", "description": "我们知道一棵有根树可以进行深度优先遍历（DFS）以及广度优先遍历（BFS）来生成这棵树的 DFS 序以及 BFS 序。两棵不同的树的 DFS 序有可能相同，并且它们的 BFS 序也有可能相同，例如下面两棵树的 DFS 序都是 `1 2 4 5 3`，BFS 序都是 `1 2 3 4 5`。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kagmha60.png)\n\n现给定一个 DFS 序和 BFS 序，我们想要知道，符合条件的有根树中，树的高度的平均值。即，假如共有 $K$ 棵不同的有根树具有这组 DFS 序和 BFS 序，且他们的高度分别是 $h_1, h_2, \\ldots, h_K$，那么请你输出：\n\n$$\n\\frac{h_1+h_2+\\ldots+h_K}K\n$$", "inputFormat": "第一行包含 $1$ 个正整数 $n$，表示树的节点个数。\n\n第二行包含 $n$ 个正整数，是一个 $1 \\ldots n$ 的排列，表示树的 DFS 序。\n\n第三行包含 $n$ 个正整数，是一个 $1 \\ldots n$ 的排列，表示树的 BFS 序。\n\n输入保证至少存在一棵树符合给定的两个序列。", "outputFormat": "输出 $1$ 个实数，四舍五入保留恰好三位小数，表示树高的平均值。", "hint": "如果输出文件的答案与标准输出的差不超过 $0.001$，则将获得该测试点上的分数，否则不得分。\n\n### 数据范围\n\n- 对于 $20\\%$ 的测试数据，满足：$n \\le 10$；\n- 对于 $40\\%$ 的测试数据，满足：$n \\le 100$；\n- 对于 $85\\%$ 的测试数据，满足：$n \\le 2 \\times 10^3$；\n- 对于 $100\\%$ 的测试数据，满足：$2 \\le n \\le 2 \\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2013] Counting Trees", "background": "", "description": "We know that a rooted tree can be traversed by depth-first search (DFS) and breadth-first search (BFS) to generate the DFS order and BFS order of the tree. Two different trees may have the same DFS order, and they may also have the same BFS order. For example, the two trees below both have DFS order `1 2 4 5 3` and BFS order `1 2 3 4 5`.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kagmha60.png)\n\nGiven a DFS order and a BFS order, we want to know the average height of all rooted trees that satisfy them. That is, suppose there are $K$ different rooted trees that have this pair of DFS and BFS orders, and their heights are $h_1, h_2, \\ldots, h_K$. Please output:\n\n$$\n\\frac{h_1+h_2+\\ldots+h_K}K\n$$", "inputFormat": "The first line contains $1$ positive integer $n$, the number of nodes of the tree.\n\nThe second line contains $n$ positive integers, a permutation of $\\,$ $1 \\ldots n$, representing the DFS order of the tree.\n\nThe third line contains $n$ positive integers, a permutation of $\\,$ $1 \\ldots n$, representing the BFS order of the tree.\n\nIt is guaranteed that there exists at least one tree consistent with the given two sequences.", "outputFormat": "Output $1$ real number, rounded to exactly three decimal places, representing the average tree height.", "hint": "If the absolute difference between your output and the standard answer does not exceed $0.001$, you will receive full credit for that test point; otherwise, you will receive no credit.\n\nConstraints\n- For $20\\%$ of the testdata: $n \\le 10$.\n- For $40\\%$ of the testdata: $n \\le 100$.\n- For $85\\%$ of the testdata: $n \\le 2 \\times 10^3$.\n- For $100\\%$ of the testdata: $2 \\le n \\le 2 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2013] 树的计数", "background": "", "description": "我们知道一棵有根树可以进行深度优先遍历（DFS）以及广度优先遍历（BFS）来生成这棵树的 DFS 序以及 BFS 序。两棵不同的树的 DFS 序有可能相同，并且它们的 BFS 序也有可能相同，例如下面两棵树的 DFS 序都是 `1 2 4 5 3`，BFS 序都是 `1 2 3 4 5`。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kagmha60.png)\n\n现给定一个 DFS 序和 BFS 序，我们想要知道，符合条件的有根树中，树的高度的平均值。即，假如共有 $K$ 棵不同的有根树具有这组 DFS 序和 BFS 序，且他们的高度分别是 $h_1, h_2, \\ldots, h_K$，那么请你输出：\n\n$$\n\\frac{h_1+h_2+\\ldots+h_K}K\n$$", "inputFormat": "第一行包含 $1$ 个正整数 $n$，表示树的节点个数。\n\n第二行包含 $n$ 个正整数，是一个 $1 \\ldots n$ 的排列，表示树的 DFS 序。\n\n第三行包含 $n$ 个正整数，是一个 $1 \\ldots n$ 的排列，表示树的 BFS 序。\n\n输入保证至少存在一棵树符合给定的两个序列。", "outputFormat": "输出 $1$ 个实数，四舍五入保留恰好三位小数，表示树高的平均值。", "hint": "如果输出文件的答案与标准输出的差不超过 $0.001$，则将获得该测试点上的分数，否则不得分。\n\n### 数据范围\n\n- 对于 $20\\%$ 的测试数据，满足：$n \\le 10$；\n- 对于 $40\\%$ 的测试数据，满足：$n \\le 100$；\n- 对于 $85\\%$ 的测试数据，满足：$n \\le 2 \\times 10^3$；\n- 对于 $100\\%$ 的测试数据，满足：$2 \\le n \\le 2 \\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P1233", "type": "P", "difficulty": 3, "samples": [["5\n4 9 5 2 2 1 3 5 1 4\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "贪心"], "title": "木棍加工", "background": "", "description": "一堆木头棍子共有 $n$ 根，每根棍子的长度和宽度都是已知的。棍子可以被一台机器一个接一个地加工。机器处理一根棍子之前需要准备时间。准备时间是这样定义的：\n\n- 第一根棍子的准备时间为 $1$ 分钟。\n- 如果刚处理完长度为 $l$，宽度为 $w$ 的棍子，那么如果下一个棍子长度为 $l_i$，宽度为 $w_i$，并且满足 $l\\ge l_i$、$w\\ge w_i$，这个棍子就不需要准备时间，否则需要 $1$ 分钟的准备时间。\n\n计算处理完 $n$ 根棍子所需要的最短准备时间。比如，你有 $5$ 根棍子，长度和宽度分别为 $(4,9),(5,2),(2,1),(3,5),(1,4)$，最短准备时间为 $2$（按 $(4,9),(3,5),(1,4),(5,2),(2,1)$ 的次序进行加工）。", "inputFormat": "第一行是一个整数 $n$（$n\\le5000$）。\n\n第二行是 $2n$ 个整数，分别是 $l_1,w_1,l_2,w_2,\\ldots,l_n,w_n$。$l$ 和 $w$ 的值均不超过 $10000$，相邻两数之间用空格分开。", "outputFormat": "仅一行，一个整数，所需要的最短准备时间。\n", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le 5000$，$1 \\le l_i, w_i \\le {10}^4$。", "locale": "zh-CN", "translations": {"en": {"title": "Stick Processing", "background": "", "description": "There are $n$ wooden sticks in total, and the length and width of each stick are known. The sticks can be processed by a machine one after another. Before processing a stick, the machine may need setup time. The setup time is defined as follows:\n\n- The setup time for the first stick is $1$ minute.\n- If the just-processed stick has length $l$ and width $w$, then for the next stick with length $l_i$ and width $w_i$, if $l \\ge l_i$ and $w \\ge w_i$, no setup time is needed; otherwise, $1$ minute of setup time is needed.\n\nCompute the minimum total setup time needed to process all $n$ sticks. For example, if you have $5$ sticks with lengths and widths $(4, 9), (5, 2), (2, 1), (3, 5), (1, 4)$, the minimum setup time is $2$ (process in the order $(4, 9), (3, 5), (1, 4), (5, 2), (2, 1)$).", "inputFormat": "The first line contains an integer $n$ ($n \\le 5000$).\n\nThe second line contains $2n$ integers: $l_1, w_1, l_2, w_2, \\ldots, l_n, w_n$. The values of $l$ and $w$ do not exceed $10000$, and adjacent numbers are separated by spaces.", "outputFormat": "A single line containing one integer: the minimum total setup time required.", "hint": "For $100 \\%$ of the testdata, $1 \\le n \\le 5000$, $1 \\le l_i, w_i \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "木棍加工", "background": "", "description": "一堆木头棍子共有 $n$ 根，每根棍子的长度和宽度都是已知的。棍子可以被一台机器一个接一个地加工。机器处理一根棍子之前需要准备时间。准备时间是这样定义的：\n\n- 第一根棍子的准备时间为 $1$ 分钟。\n- 如果刚处理完长度为 $l$，宽度为 $w$ 的棍子，那么如果下一个棍子长度为 $l_i$，宽度为 $w_i$，并且满足 $l\\ge l_i$、$w\\ge w_i$，这个棍子就不需要准备时间，否则需要 $1$ 分钟的准备时间。\n\n计算处理完 $n$ 根棍子所需要的最短准备时间。比如，你有 $5$ 根棍子，长度和宽度分别为 $(4,9),(5,2),(2,1),(3,5),(1,4)$，最短准备时间为 $2$（按 $(4,9),(3,5),(1,4),(5,2),(2,1)$ 的次序进行加工）。", "inputFormat": "第一行是一个整数 $n$（$n\\le5000$）。\n\n第二行是 $2n$ 个整数，分别是 $l_1,w_1,l_2,w_2,\\ldots,l_n,w_n$。$l$ 和 $w$ 的值均不超过 $10000$，相邻两数之间用空格分开。", "outputFormat": "仅一行，一个整数，所需要的最短准备时间。\n", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le 5000$，$1 \\le l_i, w_i \\le {10}^4$。", "locale": "zh-CN"}}}
{"pid": "P1234", "type": "P", "difficulty": 2, "samples": [["5 5\nheheh\nheheh\nheheh\nheheh\nheheh\n", "10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索"], "title": "小 A 的口头禅", "background": "", "description": "小 A 最近有了一个口头禅 “呵呵”，于是他给出了一个矩形，让你求出里面有几个 “$\\verb!hehe!$”（方向可以是向上、向下、向左、向右的直线）。\n", "inputFormat": "第一行两个数 $n, m$，表示这个矩形的大小。\n\n接下来 $n$ 行，每行 $m$ 个字符，表示这个矩形。\n", "outputFormat": "一行一个数，表示有几个 “$\\verb!hehe!$”。\n", "hint": "$1 \\leq n,m \\leq1000$。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "{{Xiao A's Catchphrase}}", "background": "{{}}", "description": "{{Xiao A recently picked up a catchphrase \"hehe\", so he gives a rectangle and asks you to count how many \"$\\verb!hehe!$\" there are inside (as straight lines in the upward, downward, leftward, or rightward directions).}}", "inputFormat": "{{The first line contains two numbers $n, m$, representing the size of the rectangle.\n\nThen follow $n$ lines, each with $m$ characters, representing the rectangle.}}", "outputFormat": "{{Output a single number on one line, representing how many \"$\\verb!hehe!$\" there are.}}", "hint": "{{$1 \\leq n, m \\leq 1000$.}}\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小 A 的口头禅", "background": "", "description": "小 A 最近有了一个口头禅 “呵呵”，于是他给出了一个矩形，让你求出里面有几个 “$\\verb!hehe!$”（方向可以是向上、向下、向左、向右的直线）。\n", "inputFormat": "第一行两个数 $n, m$，表示这个矩形的大小。\n\n接下来 $n$ 行，每行 $m$ 个字符，表示这个矩形。\n", "outputFormat": "一行一个数，表示有几个 “$\\verb!hehe!$”。\n", "hint": "$1 \\leq n,m \\leq1000$。\n\n", "locale": "zh-CN"}}}
{"pid": "P1235", "type": "P", "difficulty": 6, "samples": [["7 4                                                    \r\n4 1 2                                          \r\n5 2 3                                          \r\n6 4 5                                          \r\n7 5 6\r\n4\r\n1 2\r\n2 6\r\n7 5\r\n3 3\r\n", "0%\r\n50%\r\n81.25%\r\n100%\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "高精度"], "title": "血缘关系", "background": "", "description": "我们正在研究妖怪家族的血缘关系。每个妖怪都有相同数量的基因，但是不同的妖怪的基因可能是不同的。我们希望知道任意给定的两个妖怪之间究竟有多少相同的基因。由于基因数量相当庞大，直接检测是行不通的。但是，我们知道妖怪家族的家谱，所以我们可以根据家谱来估算两个妖怪之间相同基因的数量。\n\n妖怪之间的基因继承关系相当简单：如果妖怪 $C$ 是妖怪 $A$ 和 $B$ 的孩子，则 $C$ 的任意一个基因只能是继承 $A$ 或 $B$ 的基因，继承 $A$ 或 $B$ 的概率各占 $50\\%$。所有基因可认为是相互独立的，每个基因的继承关系不受别的基因影响。\n\n现在，我们来定义两个妖怪 $X$ 和 $Y$ 的基因相似程度。例如，有一个家族，这个家族中有两个毫无关系（没有相同基因）的妖怪 $A$ 和 $B$，及它们的孩子 $C$ 和 $D$。那么 $C$ 和 $D$ 相似程度是多少呢？因为 $C$ 和 $D$ 的基因都来自 $A$ 和 $B$，从概率来说，各占 $50\\%$。所以，依概率计算 $C$ 和 $D$ 平均有 $50\\%$ 的相同基因，$C$ 和 $D$ 的基因相似程度为 $50\\%$。需要注意的是，如果 $A$ 和 $B$ 之间存在相同基因的话，$C$ 和 $D$ 的基因相似程度就不再是 $50\\%$ 了。\n\n你的任务是写一个程序，对于给定的家谱以及成对出现的妖怪，计算它们之间的基因相似程度。", "inputFormat": "第一行两个整数 $n\\ (2 \\le n \\le 300)$ 和 $k$。表示家族中成员数，它们分别用 $1,2,\\cdots,n$ 来表示。$k\\ (0 \\le k \\le n-2)$ 表示这个家族中有父母的妖怪数量（其他的妖怪没有父母，它们之间可以认为毫无关系，即没有任何相同基因）。\n\n接下来的 $k$ 行，每行三个整数 $a,b,c$，表示妖怪 $a$ 是妖怪 $b$ 的孩子。\n\n然后是一行一个整数 $m$（$1 \\le m \\le n_2$），表示需要计算基因相似程度的妖怪对数。\n\n接下来的 $m$ 行，每行两个整数，表示需要计算基因相似程度的两个妖怪。\n\n你可以认为这里给出的家谱总是合法的。具体来说就是，没有任何的妖怪会成为自己的祖先，并且你也不必担心会存在性别错乱问题。", "outputFormat": "共 $m$ 行。可 $k$ 行表示第 $k$ 对妖怪之间的基因相似程度。你必须按百分比输出，有多少精度就输出多少，而且必须准确，但不允许出现多余的 $0$（注意，$0.001$ 的情况应输出 $\\verb!0.1%!$，而不是 $\\verb!.1%!$）。具体格式参见样例。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Blood Relationship", "background": "", "description": "We are studying the blood relationships within a family of yaoguai (妖怪, yaoguai). Each yaoguai has the same number of genes, but the genes of different yaoguai may differ. We want to know how many genes are the same between any two given yaoguai. Since the number of genes is massive, direct testing is not feasible. However, we know the family tree, so we can estimate the number of shared genes between two yaoguai based on the family tree.\n\nThe inheritance of genes among yaoguai is quite simple: if yaoguai $C$ is the child of yaoguai $A$ and $B$, then any single gene of $C$ can only be inherited from either $A$ or $B$, with a $50\\%$ probability for each. All genes are considered independent, and the inheritance of any gene is not affected by other genes.\n\nNow, we define the gene similarity between two yaoguai $X$ and $Y$. For example, consider a family with two unrelated yaoguai $A$ and $B$ (no shared genes), and their children $C$ and $D$. What is the similarity between $C$ and $D$? Since the genes of $C$ and $D$ both come from $A$ and $B$, each with a probability of $50\\%$, in expectation $C$ and $D$ share $50\\%$ of their genes, so the gene similarity between $C$ and $D$ is $50\\%$. Note that if $A$ and $B$ have shared genes, then the similarity between $C$ and $D$ will no longer be $50\\%$.\n\nYour task is to write a program that, given the family tree and several pairs of yaoguai, computes their gene similarity.", "inputFormat": "The first line contains two integers $n\\ (2 \\le n \\le 300)$ and $k$. Here $n$ is the number of members in the family, labeled $1,2,\\cdots,n$. $k\\ (0 \\le k \\le n-2)$ is the number of yaoguai in this family who have parents (the remaining yaoguai have no parents given; they can be regarded as unrelated to each other, i.e., sharing no genes).\n\nThe next $k$ lines each contain three integers $a, b, c$, meaning yaoguai $a$ is the child of yaoguai $b$ and $c$.\n\nThen a line with one integer $m$ ($1 \\le m \\le n^2$), the number of yaoguai pairs for which the gene similarity is to be computed.\n\nThe next $m$ lines each contain two integers, representing a pair of yaoguai whose gene similarity should be computed.\n\nYou may assume the given family tree is always valid. Specifically, no yaoguai will be an ancestor of themself, and you do not need to worry about gender inconsistencies.", "outputFormat": "Output $m$ lines. The $i$-th line corresponds to the gene similarity of the $i$-th pair of yaoguai. You must output it as a percentage, with as much precision as there actually is, and it must be exact, but do not print extra trailing $0$s. Also, a leading zero before the decimal point is required (note that for $0.001$ you should output $\\verb!0.1%!$, not $\\verb!.1%!$). See the sample for the exact format.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "血缘关系", "background": "", "description": "我们正在研究妖怪家族的血缘关系。每个妖怪都有相同数量的基因，但是不同的妖怪的基因可能是不同的。我们希望知道任意给定的两个妖怪之间究竟有多少相同的基因。由于基因数量相当庞大，直接检测是行不通的。但是，我们知道妖怪家族的家谱，所以我们可以根据家谱来估算两个妖怪之间相同基因的数量。\n\n妖怪之间的基因继承关系相当简单：如果妖怪 $C$ 是妖怪 $A$ 和 $B$ 的孩子，则 $C$ 的任意一个基因只能是继承 $A$ 或 $B$ 的基因，继承 $A$ 或 $B$ 的概率各占 $50\\%$。所有基因可认为是相互独立的，每个基因的继承关系不受别的基因影响。\n\n现在，我们来定义两个妖怪 $X$ 和 $Y$ 的基因相似程度。例如，有一个家族，这个家族中有两个毫无关系（没有相同基因）的妖怪 $A$ 和 $B$，及它们的孩子 $C$ 和 $D$。那么 $C$ 和 $D$ 相似程度是多少呢？因为 $C$ 和 $D$ 的基因都来自 $A$ 和 $B$，从概率来说，各占 $50\\%$。所以，依概率计算 $C$ 和 $D$ 平均有 $50\\%$ 的相同基因，$C$ 和 $D$ 的基因相似程度为 $50\\%$。需要注意的是，如果 $A$ 和 $B$ 之间存在相同基因的话，$C$ 和 $D$ 的基因相似程度就不再是 $50\\%$ 了。\n\n你的任务是写一个程序，对于给定的家谱以及成对出现的妖怪，计算它们之间的基因相似程度。", "inputFormat": "第一行两个整数 $n\\ (2 \\le n \\le 300)$ 和 $k$。表示家族中成员数，它们分别用 $1,2,\\cdots,n$ 来表示。$k\\ (0 \\le k \\le n-2)$ 表示这个家族中有父母的妖怪数量（其他的妖怪没有父母，它们之间可以认为毫无关系，即没有任何相同基因）。\n\n接下来的 $k$ 行，每行三个整数 $a,b,c$，表示妖怪 $a$ 是妖怪 $b$ 的孩子。\n\n然后是一行一个整数 $m$（$1 \\le m \\le n_2$），表示需要计算基因相似程度的妖怪对数。\n\n接下来的 $m$ 行，每行两个整数，表示需要计算基因相似程度的两个妖怪。\n\n你可以认为这里给出的家谱总是合法的。具体来说就是，没有任何的妖怪会成为自己的祖先，并且你也不必担心会存在性别错乱问题。", "outputFormat": "共 $m$ 行。可 $k$ 行表示第 $k$ 对妖怪之间的基因相似程度。你必须按百分比输出，有多少精度就输出多少，而且必须准确，但不允许出现多余的 $0$（注意，$0.001$ 的情况应输出 $\\verb!0.1%!$，而不是 $\\verb!.1%!$）。具体格式参见样例。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1236", "type": "P", "difficulty": 4, "samples": [["1 2 3 7\n", "2+1=3\n7*3=21\n21+3=24\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "递归", "Special Judge", "枚举"], "title": "算24点", "background": null, "description": "几十年前全世界就流行一种数字游戏，至今仍有人乐此不疲．在中国我们把这种游戏称为“算 $24$ 点”。您作为游戏者将得到 $4$ 个 $1 \\sim 9$ 之间的自然数作为操作数，而您的任务是对这 $4$ 个操作数进行适当的算术运算，要求运算结果等于 $24$。\n\n您可以使用的运算只有：$\\verb!+!,\\verb!-!,\\verb!*!,\\verb!/!$，您还可以使用 $\\verb!()!$ 来改变运算顺序。注意：所有的中间结果须是整数，所以一些除法运算是不允许的（例如，$(2\\times 2)/4$ 是合法的，$2\\times (2/4)$ 是不合法的）。下面我们给出一个游戏的具体例子：\n\n若给出的 $4$ 个操作数是：$1$、$2$、$3$、$7$，则一种可能的解答是 $1+2+3\\times 7=24$。", "inputFormat": "只有一行，四个 $1$ 到 $9$ 之间的自然数。", "outputFormat": "如果有解的话，只要输出一个解。输出的是三行数据，分别表示运算的步骤。\n\n- 其中第一行是输入的两个数和一个运算符和运算后的结果；\n- 第二行是第一行的结果和一个输入的数据、运算符、运算后的结果，或者是另外两个数的输出结果；\n- 第三行是前面的结果第二行的结果或者剩下的一个数字、运算符和 $\\verb!=24!$。如果两个操作数有大小的话则先输出大的。\n\n如果没有解则输出 `No answer!`。\n\n如果有多重合法解，输出任意一种即可。\n\n注：所有运算结果均为正整数。", "hint": "感谢 chenyy 提供 special judge\n\n---\n\n$\\text{upd 2022.8.1}$：新增加一组 Hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "24 Game", "background": "", "description": "Decades ago, a number game became popular worldwide and is still enjoyed today. In China, we call this game \"24 Game\". As a player, you are given 4 natural numbers between $1$ and $9$ as operands. Your task is to perform arithmetic operations on these 4 operands so that the result equals $24$.\n\nYou may use only the operations $\\verb!+!, \\verb!-!, \\verb!*!,$ and $\\verb!/!$. You may also use $\\verb!()!$ to change the order of operations. Note: all intermediate results must be integers, so some divisions are not allowed (for example, $(2\\times 2)/4$ is valid, while $2\\times (2/4)$ is invalid). Here is a concrete example of the game:\n\nIf the 4 operands are $1$, $2$, $3$, and $7$, then one possible answer is $1+2+3\\times 7=24$.", "inputFormat": "A single line containing four natural numbers between $1$ and $9$ (inclusive).", "outputFormat": "If a solution exists, output any one solution. The output consists of three lines, each describing one computation step.\n\n- The first line is two input numbers, an operator, and the result after the operation.\n- The second line is the result from the first line combined with one remaining input number, an operator, and the new result, or the result of applying an operator to the other two input numbers.\n- The third line combines the previous result, the second line’s result or the remaining number, an operator, and $\\verb!=24!$. If two operands are different, output the larger one first.\n\nIf there is no solution, output `No answer!`.\n\nIf multiple valid solutions exist, output any one of them.\n\nNote: all operation results must be positive integers.", "hint": "Thanks to chenyy for the special judge.\n\n---\n\n$\\text{upd 2022.8.1}$: Added a new set of hack testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "算24点", "background": null, "description": "几十年前全世界就流行一种数字游戏，至今仍有人乐此不疲．在中国我们把这种游戏称为“算 $24$ 点”。您作为游戏者将得到 $4$ 个 $1 \\sim 9$ 之间的自然数作为操作数，而您的任务是对这 $4$ 个操作数进行适当的算术运算，要求运算结果等于 $24$。\n\n您可以使用的运算只有：$\\verb!+!,\\verb!-!,\\verb!*!,\\verb!/!$，您还可以使用 $\\verb!()!$ 来改变运算顺序。注意：所有的中间结果须是整数，所以一些除法运算是不允许的（例如，$(2\\times 2)/4$ 是合法的，$2\\times (2/4)$ 是不合法的）。下面我们给出一个游戏的具体例子：\n\n若给出的 $4$ 个操作数是：$1$、$2$、$3$、$7$，则一种可能的解答是 $1+2+3\\times 7=24$。", "inputFormat": "只有一行，四个 $1$ 到 $9$ 之间的自然数。", "outputFormat": "如果有解的话，只要输出一个解。输出的是三行数据，分别表示运算的步骤。\n\n- 其中第一行是输入的两个数和一个运算符和运算后的结果；\n- 第二行是第一行的结果和一个输入的数据、运算符、运算后的结果，或者是另外两个数的输出结果；\n- 第三行是前面的结果第二行的结果或者剩下的一个数字、运算符和 $\\verb!=24!$。如果两个操作数有大小的话则先输出大的。\n\n如果没有解则输出 `No answer!`。\n\n如果有多重合法解，输出任意一种即可。\n\n注：所有运算结果均为正整数。", "hint": "感谢 chenyy 提供 special judge\n\n---\n\n$\\text{upd 2022.8.1}$：新增加一组 Hack 数据。", "locale": "zh-CN"}}}
{"pid": "P1237", "type": "P", "difficulty": 5, "samples": [["3\nA->BD\nBD->C\nA->C\n", "FD 3 is redundant using FDs: 1 2\n"], ["6\nP->RST\nVRT->SQP\nPS->T\nQ->TR\nQS->P\nSR->V\n", "FD 3 is redundant using FDs: 1\nFD 5 is redundant using FDs: 4 6 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "数学"], "title": "冗余依赖", "background": "", "description": "在设计关系数据库的表格时，术语“函数依赖”（FD）被用来表示不同域之间的关系。函数依赖是描述一个集合中的域的值与另一个集合中的域的值之间的关系。记号 $X \\to Y$ 被用来表示当集合 $X$ 中的域被赋值后，集合 $Y$ 的域就可以确定相应的值。例如，一个数据表格包含“社会治安编号”（$S$）、“姓名”（$N$）、“地址”（$A$）、“电话”（$P$）的域，并且每个人都与某个特定的互不相同的 $S$ 值相对应，根据域 $S$ 就可以确定域 $N$ 、 $A$ 、 $P$ 的值。这就记作 $S \\to \\{N,A,P\\}$。\n\n写一个程序以找出一组依赖中所有的冗余依赖。一个依赖是冗余的是指它可以通过组里的其他依赖得到。例如，如果组里包括依赖 $A \\to B$ 、 $B \\to C$ 和 $A \\to C$，那么第三个依赖是冗余的，因为域 $C$ 可以用前两个依赖得到（域 $A$ 确定了域 $B$ 的值，同样域 $B$ 确定了域 $C$ 的值）。在 $A \\to B$ 、 $B \\to C$ 、 $C \\to A$ 、 $A \\to C$ 、 $C \\to B$ 和 $B \\to A$ 中，所有的依赖都是冗余的。\n\n现在要求你编写一个程序，从给定的依赖关系中找出冗余的。", "inputFormat": "第一行是一个不超过 $100$ 的整数 $n$，它表示文件中函数依赖的个数。\n\n从第二行起每一行是一个函数依赖且互不重复，每行包含用字符 $\\verb!-!$ 和 $\\verb!>!$ 隔开的非空域列表。列表月包含大写的字母，函数依赖的数据行中不包括空格和制表符，不会出现“平凡”冗余依赖（如 $A \\to A$）。虽然文件中没有对函数依赖编号，但其顺序就是编号 $1$ 到 $n$。", "outputFormat": "每一行输出一个冗余依赖，以及其他依赖的一个序列以说明该依赖是冗余的。格式为 $\\texttt{FD}\\ x\\ \\texttt{is redundant using FDs:}\\ p_1\\ p_2 \\cdots p_k$。其中 $x$ 是冗余的依赖的编号，$p_1,p_2,\\cdots,p_k$ 是用来证明 $x$ 是冗余依赖的依赖序列。\n\n如果许多函数依赖的序列都能被用来说明一个依赖是冗余的，则输出其中最短的证明序列。\n\n如果这些函数依赖中不包含冗余依赖，则输出 `No redundant FDs`。\n", "hint": "### 样例 1 解释\n\n依赖关系 $3$ 是冗余的。因为 $A\\to C$ 可以使用前两个依赖关系 $A\\to \\{B,D\\}$ 和 $\\{B, D\\}\\to C$ 得到。", "locale": "zh-CN", "translations": {"en": {"title": "Redundant Dependencies", "background": "", "description": "When designing tables in a relational database, the term \"functional dependency\" (FD) is used to describe relationships between attributes. A functional dependency describes the relationship between the values of attributes in one set and those in another set. The notation $X \\to Y$ is used to mean that once the attributes in set $X$ are assigned values, the attributes in set $Y$ are determined. For example, in a data table with attributes \"Social Security Number\" ($S$), \"Name\" ($N$), \"Address\" ($A$), and \"Phone\" ($P$), where each person has a unique value of $S$, the attributes $N$, $A$, and $P$ are determined by $S$. This is written as $S \\to \\{N, A, P\\}$.\n\nWrite a program to find all redundant dependencies in a set of dependencies. A dependency is redundant if it can be derived from the other dependencies in the set. For example, if the set includes $A \\to B$, $B \\to C$, and $A \\to C$, then the third dependency is redundant because $C$ can be derived from the first two dependencies ($A$ determines $B$, and $B$ determines $C$). Among $A \\to B$, $B \\to C$, $C \\to A$, $A \\to C$, $C \\to B$, and $B \\to A$, all dependencies are redundant.\n\nYou are required to write a program to identify the redundant dependencies from the given set.", "inputFormat": "The first line contains an integer $n$ not exceeding $100$, which is the number of functional dependencies in the file.\n\nFrom the second line onward, each line contains one functional dependency, and all dependencies are distinct. Each line consists of two non-empty attribute lists separated by the characters $\\verb!-!$ and $\\verb!>!$. Each list consists solely of uppercase letters. There are no spaces or tabs in any FD line. No trivial dependencies (such as $A \\to A$) will appear. Although the FDs are not explicitly numbered in the file, their order corresponds to indices $1$ through $n$.", "outputFormat": "Output each redundant dependency on its own line, along with a sequence of other dependencies that shows it is redundant. The format is $\\texttt{FD}\\ x\\ \\texttt{is redundant using FDs:}\\ p_1\\ p_2 \\cdots p_k$ where $x$ is the index of the redundant dependency, and $p_1, p_2, \\cdots, p_k$ is a sequence of dependency indices that proves $x$ is redundant.\n\nIf multiple sequences of functional dependencies can be used to show a dependency is redundant, output the shortest proof sequence.\n\nIf no redundant dependencies are present among the given FDs, output `No redundant FDs`.", "hint": "### Explanation for Sample 1\n\nDependency $3$ is redundant because $A \\to C$ can be derived from the first two dependencies $A \\to \\{B, D\\}$ and $\\{B, D\\} \\to C$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "冗余依赖", "background": "", "description": "在设计关系数据库的表格时，术语“函数依赖”（FD）被用来表示不同域之间的关系。函数依赖是描述一个集合中的域的值与另一个集合中的域的值之间的关系。记号 $X \\to Y$ 被用来表示当集合 $X$ 中的域被赋值后，集合 $Y$ 的域就可以确定相应的值。例如，一个数据表格包含“社会治安编号”（$S$）、“姓名”（$N$）、“地址”（$A$）、“电话”（$P$）的域，并且每个人都与某个特定的互不相同的 $S$ 值相对应，根据域 $S$ 就可以确定域 $N$ 、 $A$ 、 $P$ 的值。这就记作 $S \\to \\{N,A,P\\}$。\n\n写一个程序以找出一组依赖中所有的冗余依赖。一个依赖是冗余的是指它可以通过组里的其他依赖得到。例如，如果组里包括依赖 $A \\to B$ 、 $B \\to C$ 和 $A \\to C$，那么第三个依赖是冗余的，因为域 $C$ 可以用前两个依赖得到（域 $A$ 确定了域 $B$ 的值，同样域 $B$ 确定了域 $C$ 的值）。在 $A \\to B$ 、 $B \\to C$ 、 $C \\to A$ 、 $A \\to C$ 、 $C \\to B$ 和 $B \\to A$ 中，所有的依赖都是冗余的。\n\n现在要求你编写一个程序，从给定的依赖关系中找出冗余的。", "inputFormat": "第一行是一个不超过 $100$ 的整数 $n$，它表示文件中函数依赖的个数。\n\n从第二行起每一行是一个函数依赖且互不重复，每行包含用字符 $\\verb!-!$ 和 $\\verb!>!$ 隔开的非空域列表。列表月包含大写的字母，函数依赖的数据行中不包括空格和制表符，不会出现“平凡”冗余依赖（如 $A \\to A$）。虽然文件中没有对函数依赖编号，但其顺序就是编号 $1$ 到 $n$。", "outputFormat": "每一行输出一个冗余依赖，以及其他依赖的一个序列以说明该依赖是冗余的。格式为 $\\texttt{FD}\\ x\\ \\texttt{is redundant using FDs:}\\ p_1\\ p_2 \\cdots p_k$。其中 $x$ 是冗余的依赖的编号，$p_1,p_2,\\cdots,p_k$ 是用来证明 $x$ 是冗余依赖的依赖序列。\n\n如果许多函数依赖的序列都能被用来说明一个依赖是冗余的，则输出其中最短的证明序列。\n\n如果这些函数依赖中不包含冗余依赖，则输出 `No redundant FDs`。\n", "hint": "### 样例 1 解释\n\n依赖关系 $3$ 是冗余的。因为 $A\\to C$ 可以使用前两个依赖关系 $A\\to \\{B,D\\}$ 和 $\\{B, D\\}\\to C$ 得到。", "locale": "zh-CN"}}}
{"pid": "P1238", "type": "P", "difficulty": 3, "samples": [["5 6\n1 0 0 1 0 1\n1 1 1 1 1 1\n0 0 1 1 1 0\n1 1 1 1 1 0\n1 1 1 0 1 1\n1 1\n5 6", "(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(3,4)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(3,4)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索"], "title": "走迷宫", "background": "", "description": "有一个 $m\\times n$ 格的迷宫(表示有 $m$ 行、$n$ 列)，其中有可走的也有不可走的，如果用 $1$ 表示可以走，$0$ 表示不可以走，文件读入这 $m\\times n$ 个数据和起始点、结束点（起始点和结束点都是用两个数据来描述的，分别表示这个点的行号和列号）。现在要你编程找出所有可行的道路，要求所走的路中没有重复的点，走时只能是上下左右四个方向。如果一条路都不可行，则输出相应信息（用 $-1$ 表示无路）。\n\n优先顺序：左上右下。**数据保证随机生成。**\n", "inputFormat": "第一行是两个数 $m,n(1<m,n<15)$，接下来是 $m$ 行 $n$ 列由 $1$ 和 $0$ 组成的数据，最后两行是起始点和结束点。\n", "outputFormat": "所有可行的路径，描述一个点时用 $(x,y)$ 的形式，除开始点外，其他的都要用 `->` 表示方向。\n\n如果没有一条可行的路则输出 $-1$。\n", "hint": "数据保证随机生成。事实上，如果 $n=m=14$ 且每个位置都是 $1$ 的话，有 $69450664761521361664274701548907358996488$ 种路径。", "locale": "zh-CN", "translations": {"en": {"title": "Maze Pathfinding", "background": "", "description": "There is an $m \\times n$ grid maze (meaning $m$ rows and $n$ columns), with some cells passable and others not. Use $1$ for passable and $0$ for impassable. The input provides these $m \\times n$ values and the start and end points (each point is described by two numbers: its row index and column index). Your task is to write a program to find all feasible paths such that no cell is visited more than once, and movement is allowed only in the four directions: up, down, left, and right. If no path is feasible, output the corresponding information ($-1$ means no path).\n\nPriority order: left, up, right, down. **The testdata are guaranteed to be randomly generated.**", "inputFormat": "The first line contains two integers $m, n$ ($1 < m, n < 15$). Then follow $m$ rows and $n$ columns of data consisting of $1$ and $0$. The last two lines are the start point and the end point.", "outputFormat": "Output all feasible paths. When describing a point, use the form $(x, y)$. Except for the starting point, connect consecutive points using `->` to indicate direction.\n\nIf there is no feasible path, output $-1$.", "hint": "The testdata are guaranteed to be randomly generated. In fact, if $n = m = 14$ and every cell is $1$, there are $69450664761521361664274701548907358996488$ paths.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "走迷宫", "background": "", "description": "有一个 $m\\times n$ 格的迷宫(表示有 $m$ 行、$n$ 列)，其中有可走的也有不可走的，如果用 $1$ 表示可以走，$0$ 表示不可以走，文件读入这 $m\\times n$ 个数据和起始点、结束点（起始点和结束点都是用两个数据来描述的，分别表示这个点的行号和列号）。现在要你编程找出所有可行的道路，要求所走的路中没有重复的点，走时只能是上下左右四个方向。如果一条路都不可行，则输出相应信息（用 $-1$ 表示无路）。\n\n优先顺序：左上右下。**数据保证随机生成。**\n", "inputFormat": "第一行是两个数 $m,n(1<m,n<15)$，接下来是 $m$ 行 $n$ 列由 $1$ 和 $0$ 组成的数据，最后两行是起始点和结束点。\n", "outputFormat": "所有可行的路径，描述一个点时用 $(x,y)$ 的形式，除开始点外，其他的都要用 `->` 表示方向。\n\n如果没有一条可行的路则输出 $-1$。\n", "hint": "数据保证随机生成。事实上，如果 $n=m=14$ 且每个位置都是 $1$ 的话，有 $69450664761521361664274701548907358996488$ 种路径。", "locale": "zh-CN"}}}
{"pid": "P1239", "type": "P", "difficulty": 4, "samples": [["11", "1\n4\n1\n1\n1\n1\n1\n1\n1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["递推"], "title": "计数器", "background": "", "description": "一本书的页数为 $n$，页码从 $1$ 开始编起，请你求出全部页码中，用了多少个 $0,1,2\\cdots 9$。每个页码不含前导 $0$，如 $n=1234$ 时第 $5$ 页不是 $0005$，只是 $5$。\n", "inputFormat": "一个正整数 $n$，表示总的页码。\n", "outputFormat": "输出共十行，其中第 $k$ 行为数字 $k-1$ 的个数。\n", "hint": "对于 $100\\%$ 数据，满足 $1\\le n\\le 10^9$。\n\n---\n\n$2022.7.4$：新添加三组 $\\text{Hack}$ 数据。", "locale": "zh-CN", "translations": {"en": {"title": "Counter", "background": "", "description": "A book has $n$ pages, with page numbers starting from $1$. Please find how many times each of the digits $0,1,2\\cdots 9$ appears in all page numbers. No page number has leading zeros; for example, when $n=1234$, page $5$ is not 0005, but just $5$.", "inputFormat": "A single positive integer $n$, the total number of pages.", "outputFormat": "Output ten lines in total, where the $k$-th line is the count of digit $k-1$.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 10^9$.\n\n---\n\n$2022.7.4$: Three new groups of $\\text{Hack}$ testdata were added.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "计数器", "background": "", "description": "一本书的页数为 $n$，页码从 $1$ 开始编起，请你求出全部页码中，用了多少个 $0,1,2\\cdots 9$。每个页码不含前导 $0$，如 $n=1234$ 时第 $5$ 页不是 $0005$，只是 $5$。\n", "inputFormat": "一个正整数 $n$，表示总的页码。\n", "outputFormat": "输出共十行，其中第 $k$ 行为数字 $k-1$ 的个数。\n", "hint": "对于 $100\\%$ 数据，满足 $1\\le n\\le 10^9$。\n\n---\n\n$2022.7.4$：新添加三组 $\\text{Hack}$ 数据。", "locale": "zh-CN"}}}
{"pid": "P1240", "type": "P", "difficulty": 4, "samples": [["2 2\r\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推"], "title": "诸侯安置", "background": "", "description": "很久以前，有一个强大的帝国，它的国土成正方形状，如图所示。\n\n这个国家有若干诸侯。由于这些诸侯都曾立下赫赫战功，国王准备给他们每人一块封地（正方形中的一格）。但是，这些诸侯又非常好战，当两个诸侯位于同一行或同一列时，他们就会开战。如下图为 $n＝3$ 时的国土，阴影部分表示诸侯所处的位置。前两幅图中的诸侯可以互相攻击，第三幅则不可以。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7h9ptqlv.png)\n\n国王自然不愿意看到他的诸侯们互相开战，致使国家动荡不安。  因此，他希望通过合理的安排诸侯所处的位置，使他们两两之间都不能攻击。\n\n现在，给出正方形的边长 $n$，以及需要封地的诸侯数量 $k$，要求你求出所有可能的安置方案数。（满足 $n\\le100$，$k\\le2n^2-2n+1$）\n\n由于方案数可能很多，你只需要输出方案数除以 $504$ 的余数即可。\n", "inputFormat": "仅一行，两个整数 $n$ 和 $k$，中间用一空格隔开。\n", "outputFormat": "一个整数，表示方案数除以 $504$ 的余数。\n", "hint": "注意：镜面和旋转的情况属于不同的方案。", "locale": "zh-CN", "translations": {"en": {"title": "Placement of Feudal Lords", "background": "", "description": "A long time ago, there was a powerful empire whose territory was square-shaped, as shown in the figure.\n\nThe country has several feudal lords. Since these lords had made great contributions, the king planned to grant each of them a fief (one cell in the square grid). However, these lords are very warlike: if two lords are in the same row or the same column, they will go to war. The following figure shows the territory when $n=3$, where the shaded cells indicate the lords’ positions. In the first two figures, the lords can attack each other; in the third figure, they cannot.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7h9ptqlv.png)\n\nNaturally, the king does not want to see his lords fighting each other and causing unrest. Therefore, he hopes to arrange their positions so that no two lords can attack each other.\n\nNow, given the side length $n$ of the square and the number of lords $k$ to be placed, find the total number of valid arrangements. (You only need to output the remainder when the number of arrangements is divided by $504$.)\n\nConstraints: $n \\le 100$, $k \\le 2n^2 - 2n + 1$.", "inputFormat": "A single line containing two integers $n$ and $k$, separated by a space.", "outputFormat": "A single integer, the remainder when the number of valid arrangements is divided by $504$.", "hint": "Note: Mirror images and rotations are considered different solutions.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "诸侯安置", "background": "", "description": "很久以前，有一个强大的帝国，它的国土成正方形状，如图所示。\n\n这个国家有若干诸侯。由于这些诸侯都曾立下赫赫战功，国王准备给他们每人一块封地（正方形中的一格）。但是，这些诸侯又非常好战，当两个诸侯位于同一行或同一列时，他们就会开战。如下图为 $n＝3$ 时的国土，阴影部分表示诸侯所处的位置。前两幅图中的诸侯可以互相攻击，第三幅则不可以。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7h9ptqlv.png)\n\n国王自然不愿意看到他的诸侯们互相开战，致使国家动荡不安。  因此，他希望通过合理的安排诸侯所处的位置，使他们两两之间都不能攻击。\n\n现在，给出正方形的边长 $n$，以及需要封地的诸侯数量 $k$，要求你求出所有可能的安置方案数。（满足 $n\\le100$，$k\\le2n^2-2n+1$）\n\n由于方案数可能很多，你只需要输出方案数除以 $504$ 的余数即可。\n", "inputFormat": "仅一行，两个整数 $n$ 和 $k$，中间用一空格隔开。\n", "outputFormat": "一个整数，表示方案数除以 $504$ 的余数。\n", "hint": "注意：镜面和旋转的情况属于不同的方案。", "locale": "zh-CN"}}}
{"pid": "P1241", "type": "P", "difficulty": 2, "samples": [["([()\n", "()[]()\n"], ["([)", "()[]()"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化", "栈"], "title": "括号序列", "background": "", "description": "定义如下规则：\n\n1. 空串是「平衡括号序列」\n2. 若字符串 $S$ 是「平衡括号序列」，那么 $\\texttt{[}S\\texttt]$ 和 $\\texttt{(}S\\texttt)$ 也都是「平衡括号序列」\n3. 若字符串 $A$ 和 $B$ 都是「平衡括号序列」，那么 $AB$（两字符串拼接起来）也是「平衡括号序列」。\n\n\n例如，下面的字符串都是平衡括号序列：\n\n\n- `()`，`[]`，`(())`，`([])`，`()[]`，`()[()]`\n\n\n而以下几个则不是：\n\n\n- `(`，`[`，`]`，`)(`，`())`，`([()`\n\n\n现在，给定一个仅由 `(`，`)`，`[`，`]`构成的字符串 $s$，请你按照如下的方式给字符串中每个字符配对：\n1. 从左到右扫描整个字符串。\n2. 对于当前的字符，如果它是一个右括号，考察它与它左侧离它**最近**的**未匹配**的的左括号。如果该括号与之对应（即小括号匹配小括号，中括号匹配中括号），则将二者配对。如果左侧未匹配的左括号不存在或与之不对应，则其配对失败。\n\n配对结束后，对于 $s$ 中全部未配对的括号，请你在其旁边添加一个字符，使得该括号和新加的括号匹配。", "inputFormat": "输入只有一行一个字符串，表示 $s$。", "outputFormat": "输出一行一个字符串表示你的答案。", "hint": "### 数据规模与约定\n\n对于全部的测试点，保证 $s$ 的长度不超过 $100$，且只含  `(`，`)`，`[`，`]` 四种字符。", "locale": "zh-CN", "translations": {"en": {"title": "Bracket Sequence", "background": "", "description": "Define the following rules:\n1. The empty string is a \"balanced bracket sequence\".\n2. If string $S$ is a \"balanced bracket sequence\", then $\\texttt{[}S\\texttt{]}$ and $\\texttt{(}S\\texttt{)}$ are also \"balanced bracket sequences\".\n3. If strings $A$ and $B$ are both \"balanced bracket sequences\", then $AB$ (the concatenation of the two strings) is also a \"balanced bracket sequence\".\n\nFor example, the following strings are balanced bracket sequences:\n- `()`, `[]`, `(())`, `([])`, `()[]`, `()[()]`.\n\nThe following are not:\n- `(`, `[`, `]`, `)(`, `())`, `([()`.\n\nNow, given a string $s$ consisting only of `(`, `)`, `[`, `]`, please pair the characters in the string as follows:\n1. Scan the string from left to right.\n2. For the current character, if it is a right bracket, look at the nearest unmatched left bracket to its left. If they correspond (parenthesis matches parenthesis, square bracket matches square bracket), then pair them. If there is no unmatched left bracket to its left or they do not correspond, then pairing fails.\n\nAfter pairing ends, for every unmatched bracket in $s$, add one character next to it so that this bracket matches with the newly added one.", "inputFormat": "The input contains a single line with the string $s$.", "outputFormat": "Output a single line with the resulting string.", "hint": "Constraints\n\nFor all test points, it is guaranteed that the length of $s$ does not exceed $100$, and $s$ contains only the four characters `(`, `)`, `[`, `]`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "括号序列", "background": "", "description": "定义如下规则：\n\n1. 空串是「平衡括号序列」\n2. 若字符串 $S$ 是「平衡括号序列」，那么 $\\texttt{[}S\\texttt]$ 和 $\\texttt{(}S\\texttt)$ 也都是「平衡括号序列」\n3. 若字符串 $A$ 和 $B$ 都是「平衡括号序列」，那么 $AB$（两字符串拼接起来）也是「平衡括号序列」。\n\n\n例如，下面的字符串都是平衡括号序列：\n\n\n- `()`，`[]`，`(())`，`([])`，`()[]`，`()[()]`\n\n\n而以下几个则不是：\n\n\n- `(`，`[`，`]`，`)(`，`())`，`([()`\n\n\n现在，给定一个仅由 `(`，`)`，`[`，`]`构成的字符串 $s$，请你按照如下的方式给字符串中每个字符配对：\n1. 从左到右扫描整个字符串。\n2. 对于当前的字符，如果它是一个右括号，考察它与它左侧离它**最近**的**未匹配**的的左括号。如果该括号与之对应（即小括号匹配小括号，中括号匹配中括号），则将二者配对。如果左侧未匹配的左括号不存在或与之不对应，则其配对失败。\n\n配对结束后，对于 $s$ 中全部未配对的括号，请你在其旁边添加一个字符，使得该括号和新加的括号匹配。", "inputFormat": "输入只有一行一个字符串，表示 $s$。", "outputFormat": "输出一行一个字符串表示你的答案。", "hint": "### 数据规模与约定\n\n对于全部的测试点，保证 $s$ 的长度不超过 $100$，且只含  `(`，`)`，`[`，`]` 四种字符。", "locale": "zh-CN"}}}
{"pid": "P1242", "type": "P", "difficulty": 5, "samples": [["5\n3 3 2 1\n2 5 4\n0\n1 2\n3 5 4 3\n1 1", "move 1 from A to B\nmove 2 from A to C\nmove 1 from B to C\nmove 3 from A to B\nmove 1 from C to B\nmove 2 from C to A\nmove 1 from B to C\n7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递归", "枚举"], "title": "新汉诺塔", "background": "", "description": "\n设有 $n$ 个大小不等的中空圆盘，按从小到大的顺序从 $1$ 到 $n$ 编号。将这 $n$ 个圆盘任意的迭套在三根立柱上，立柱的编号分别为 $A,B,C$，这个状态称为初始状态。\n\n现在要求找到一种步数最少的移动方案，使得从初始状态转变为目标状态。\n\n移动时有如下要求：\n\n- 一次只能移一个盘；\n- 不允许把大盘移到小盘上面。", "inputFormat": "\n第一行一个整数，状态中圆盘总数 $n$。\n\n接下来三行每行若干个整数，分别代表初始状态下 $A$ , $B$ , $C$ 柱子上的圆盘从上到下的编号，如果只有一个数 $0$ 就代表这根柱子上没有数。\n\n接下来三行每行若干个整数，分别代表目标状态下 $A$ , $B$ , $C$ 柱子上的圆盘从上到下的编号，如果只有一个数 $0$ 就代表这根柱子上没有数。", "outputFormat": "若干行每行一个字符串，格式为 `move I from P to Q` ，代表一个移动的操作。\n\n接下来一行一个整数，代表从初始状态到目标状态的最少步数。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 45$ ，$1 \\le $ 每个圆盘的编号 $\\le n$ 。\n\n每行的圆盘描述是从下到上的圆盘编号。", "locale": "zh-CN", "translations": {"en": {"title": "New Tower of Hanoi", "background": "", "description": "There are $n$ hollow circular disks of distinct sizes, labeled from $1$ to $n$ in ascending order by size. These $n$ disks are arbitrarily nested on three pegs labeled $A$, $B$, $C$. This configuration is called the initial state.\n\nYour task is to find a shortest sequence of moves that transforms the initial state into the target state.\n\nThe move rules are as follows:\n- Only one disk may be moved at a time.\n- A larger disk may not be placed on top of a smaller disk.", "inputFormat": "The first line contains an integer $n$, the total number of disks present in the states.\n\nThe next three lines each contain several integers, describing the disks on pegs $A$, $B$, $C$ in the initial state, listed from bottom to top. If a line contains only the single number $0$, that peg has no disk.\n\nThe following three lines each contain several integers, describing the disks on pegs $A$, $B$, $C$ in the target state, listed from bottom to top. If a line contains only the single number $0$, that peg has no disk.", "outputFormat": "Several lines, each containing a string in the format `move I from P to Q`, representing a single move.\n\nThen output one line with one integer, the minimum number of moves from the initial state to the target state.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le n \\le 45$, and $1 \\le$ each disk's index $\\le n$.\n\nEach line’s disk description is listed from bottom to top.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "新汉诺塔", "background": "", "description": "\n设有 $n$ 个大小不等的中空圆盘，按从小到大的顺序从 $1$ 到 $n$ 编号。将这 $n$ 个圆盘任意的迭套在三根立柱上，立柱的编号分别为 $A,B,C$，这个状态称为初始状态。\n\n现在要求找到一种步数最少的移动方案，使得从初始状态转变为目标状态。\n\n移动时有如下要求：\n\n- 一次只能移一个盘；\n- 不允许把大盘移到小盘上面。", "inputFormat": "\n第一行一个整数，状态中圆盘总数 $n$。\n\n接下来三行每行若干个整数，分别代表初始状态下 $A$ , $B$ , $C$ 柱子上的圆盘从上到下的编号，如果只有一个数 $0$ 就代表这根柱子上没有数。\n\n接下来三行每行若干个整数，分别代表目标状态下 $A$ , $B$ , $C$ 柱子上的圆盘从上到下的编号，如果只有一个数 $0$ 就代表这根柱子上没有数。", "outputFormat": "若干行每行一个字符串，格式为 `move I from P to Q` ，代表一个移动的操作。\n\n接下来一行一个整数，代表从初始状态到目标状态的最少步数。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 45$ ，$1 \\le $ 每个圆盘的编号 $\\le n$ 。\n\n每行的圆盘描述是从下到上的圆盘编号。", "locale": "zh-CN"}}}
{"pid": "P1243", "type": "P", "difficulty": 3, "samples": [["3 4\n", "1 2 3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推"], "title": "排序集合", "background": "", "description": "对于集合 $N=\\{1,2,\\cdots,n\\}$ 的子集，定义一个称之为“小于”的关系：\n\n设 $S1=\\{X_1,X_2,\\cdots,X_i\\}$，$(X_1<X_2<\\cdots<X_i)$，$S2=\\{Y_1,Y_2,\\cdots,Y_j\\}$，$(Y_1<Y_2<\\cdots<Y_j)$，如果存在一个 $k$，$(0\\leq k\\leq\\min(i,j))$，使得 $X_1=Y_1,\\cdots,X_k=Y_k$，且 $k=i$ 或 $X_{k+1}<Y_{k+1}$，则称 $S1$ “小于” $S2$。\n\n你的任务是，对于任意的 $n(n\\leq31)$ 及 $k(k<2^n)$，求出第 $k$ 小的子集。", "inputFormat": "输入文件仅一行，包含两个用空格隔开的自然数，$n$ 和 $k$。", "outputFormat": "输出文件仅一行，使该子集的元素，由小到大排列。空集输出 $0$。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Sorting Subsets", "background": "", "description": "For subsets of $N=\\{1,2,\\cdots,n\\}$, define a relation called \"less than\":\n\nLet $S1=\\{X_1,X_2,\\cdots,X_i\\}$, $(X_1<X_2<\\cdots<X_i)$, $S2=\\{Y_1,Y_2,\\cdots,Y_j\\}$, $(Y_1<Y_2<\\cdots<Y_j)$. If there exists a $k$, $(0\\leq k\\leq\\min(i,j))$, such that $X_1=Y_1,\\cdots,X_k=Y_k$, and $k=i$ or $X_{k+1}<Y_{k+1}$, then $S1$ is said to be \"less than\" $S2$.\n\nYour task is, for any $n$ $(n\\leq31)$ and $k$ $(k<2^n)$, to find the $k$-th smallest subset.", "inputFormat": "The input file contains a single line with two natural numbers, $n$ and $k$, separated by a space.", "outputFormat": "Output a single line listing the elements of the subset in increasing order. Output $0$ for the empty set.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "排序集合", "background": "", "description": "对于集合 $N=\\{1,2,\\cdots,n\\}$ 的子集，定义一个称之为“小于”的关系：\n\n设 $S1=\\{X_1,X_2,\\cdots,X_i\\}$，$(X_1<X_2<\\cdots<X_i)$，$S2=\\{Y_1,Y_2,\\cdots,Y_j\\}$，$(Y_1<Y_2<\\cdots<Y_j)$，如果存在一个 $k$，$(0\\leq k\\leq\\min(i,j))$，使得 $X_1=Y_1,\\cdots,X_k=Y_k$，且 $k=i$ 或 $X_{k+1}<Y_{k+1}$，则称 $S1$ “小于” $S2$。\n\n你的任务是，对于任意的 $n(n\\leq31)$ 及 $k(k<2^n)$，求出第 $k$ 小的子集。", "inputFormat": "输入文件仅一行，包含两个用空格隔开的自然数，$n$ 和 $k$。", "outputFormat": "输出文件仅一行，使该子集的元素，由小到大排列。空集输出 $0$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1244", "type": "P", "difficulty": 2, "samples": [["1 1\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2000", "NOI"], "title": "[NOI2000] 青蛙过河", "background": "", "description": "**大小各不相同**的一队青蛙站在河左岸的石墩（记为 A）上，要过到对岸的石墩（记为 D）上去。河心有几片荷叶（分别记为 $Y_1 \\dots Y_m$）和几个石墩（分别记为 $S_1\\dots S_n$）。图示如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0u3st8yt.png)\n\n青蛙的站队和移动方法规则如下：\n\n- 每只青蛙只能站在荷叶、石墩，或者**仅比它大一号**的青蛙背上（统称为合法的落脚点）；\n- 一只青蛙只有背上没有其它青蛙的时候才能够从一个落脚点跳到另一个落脚点；\n- 青蛙允许从左岸 A 直接跳到河心的石墩、荷叶和右岸的石墩 D 上，允许从河心的石墩和荷叶跳到右岸的石墩 D 上；\n- 青蛙在河心的石墩之间、荷叶之间以及石墩和荷叶之间可以来回跳动；\n- 青蛙在离开左岸石墩后，不能再返回左岸；到达右岸后，不能再跳回；\n- 假定石墩承重能力很大，允许无论多少只青蛙都可呆在上面。但是，由于石墩的面积不大，至多只能有一只青蛙直接站在上面，而其他的青蛙只能依规则 1 落在比它大一号的青蛙的背上。\n- 荷叶不仅面积不大，而且负重能力也有限，至多只能有一只青蛙站在上面。\n- 每一步只能移动一只青蛙，并且移动后需要满足站队规则；\n- 在一开始的时候，青蛙均站在 A 上，最大的一只青蛙直接站在石墩上，而其它的青蛙依规则 6 站在比其大一号的青蛙的背上。\n\n青蛙希望最终能够全部移动到 D 上，并完成站队。\n\n设河心有 $m$ 片荷叶和 $n$ 个石墩，请求出这队青蛙至多有多少只，在满足站队和移动规则的前提下，能从 A 过到 D。\n\n你的任务是对于给出的 $n,m$，计算并输出最多能有多少只青蛙可以根据以上规则顺利过河。", "inputFormat": "输入两个整数 $n,m$。", "outputFormat": "一个整数，表示最多能有多少只青蛙可以根据以上规则顺利过河。\n", "hint": "$n \\leq 20$，$m \\leq 10^3$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2000] Frogs Crossing the River", "background": "", "description": "A line of frogs of different sizes stands on the stone post on the left bank (denoted as A) and wants to cross to the stone post on the right bank (denoted as D). There are several lily pads in the middle of the river (denoted as $Y_1 \\dots Y_m$) and several stone posts (denoted as $S_1\\dots S_n$). The illustration is as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0u3st8yt.png)\n\nThe lineup and movement rules for the frogs are as follows:\n\n- Each frog may stand only on a lily pad, a stone post, or on the back of a frog that is only one size larger than itself (collectively called valid landing spots).\n- A frog can jump from one landing spot to another only when there is no other frog on its back.\n- A frog is allowed to jump directly from the left bank A to stone posts or lily pads in the river center, as well as directly to the right-bank stone post D; a frog is also allowed to jump from stone posts or lily pads in the river center to the right-bank stone post D.\n- Frogs may jump back and forth among stone posts, among lily pads, and between stone posts and lily pads in the river center.\n- After leaving the left bank stone post, a frog cannot return to the left bank; after reaching the right bank, it cannot jump back.\n- Stone posts have very large load capacity and can hold any number of frogs; however, because their area is small, at most one frog may stand directly on a stone post, and any other frogs must, per Rule 1, stand on the back of a frog that is one size larger.\n- Lily pads not only have small area but also limited load capacity; at most one frog may stand on a lily pad.\n- At each step, only one frog may move, and after the move the lineup rules must be satisfied.\n- Initially, all frogs stand on A: the largest frog stands directly on the stone post, and all other frogs, per Rule 6, stand on the back of a frog that is one size larger.\n\nThe frogs hope that they can all eventually move onto D and complete the lineup.\n\nGiven that the river center has $m$ lily pads and $n$ stone posts, determine the maximum possible number of frogs that, under the lineup and movement rules, can move from A to D.\n\nYour task is: given $n, m$, compute and output the maximum number of frogs that can cross the river under the rules above.", "inputFormat": "Two integers $n, m$.", "outputFormat": "One integer, the maximum number of frogs that can, under the rules above, cross the river from A to D.", "hint": "Constraints: $n \\leq 20$, $m \\leq 10^3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2000] 青蛙过河", "background": "", "description": "**大小各不相同**的一队青蛙站在河左岸的石墩（记为 A）上，要过到对岸的石墩（记为 D）上去。河心有几片荷叶（分别记为 $Y_1 \\dots Y_m$）和几个石墩（分别记为 $S_1\\dots S_n$）。图示如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0u3st8yt.png)\n\n青蛙的站队和移动方法规则如下：\n\n- 每只青蛙只能站在荷叶、石墩，或者**仅比它大一号**的青蛙背上（统称为合法的落脚点）；\n- 一只青蛙只有背上没有其它青蛙的时候才能够从一个落脚点跳到另一个落脚点；\n- 青蛙允许从左岸 A 直接跳到河心的石墩、荷叶和右岸的石墩 D 上，允许从河心的石墩和荷叶跳到右岸的石墩 D 上；\n- 青蛙在河心的石墩之间、荷叶之间以及石墩和荷叶之间可以来回跳动；\n- 青蛙在离开左岸石墩后，不能再返回左岸；到达右岸后，不能再跳回；\n- 假定石墩承重能力很大，允许无论多少只青蛙都可呆在上面。但是，由于石墩的面积不大，至多只能有一只青蛙直接站在上面，而其他的青蛙只能依规则 1 落在比它大一号的青蛙的背上。\n- 荷叶不仅面积不大，而且负重能力也有限，至多只能有一只青蛙站在上面。\n- 每一步只能移动一只青蛙，并且移动后需要满足站队规则；\n- 在一开始的时候，青蛙均站在 A 上，最大的一只青蛙直接站在石墩上，而其它的青蛙依规则 6 站在比其大一号的青蛙的背上。\n\n青蛙希望最终能够全部移动到 D 上，并完成站队。\n\n设河心有 $m$ 片荷叶和 $n$ 个石墩，请求出这队青蛙至多有多少只，在满足站队和移动规则的前提下，能从 A 过到 D。\n\n你的任务是对于给出的 $n,m$，计算并输出最多能有多少只青蛙可以根据以上规则顺利过河。", "inputFormat": "输入两个整数 $n,m$。", "outputFormat": "一个整数，表示最多能有多少只青蛙可以根据以上规则顺利过河。\n", "hint": "$n \\leq 20$，$m \\leq 10^3$。", "locale": "zh-CN"}}}
{"pid": "P1245", "type": "P", "difficulty": 5, "samples": [["8\n73373711664\nthi\nshs\nthis\nis\nb\na\nboo\nk", "thi shs b boo k"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "Special Judge"], "title": "电话号码", "background": "", "description": "电话机上每一个数字下面都写了若干个英文字母。分布如下：\n\n- $1\\leftrightarrow \\verb!a!,\\verb!b!,\\verb!c!$；\n- $2\\leftrightarrow \\verb!d!,\\verb!e!,\\verb!f!$；\n- $3\\leftrightarrow \\verb!g!,\\verb!h!,\\verb!i!$；\n- $4\\leftrightarrow \\verb!j!,\\verb!k!,\\verb!l!$；\n- $5\\leftrightarrow \\verb!m!,\\verb!n!$；\n- $6\\leftrightarrow \\verb!o!,\\verb!p!,\\verb!q!$；\n- $7\\leftrightarrow \\verb!r!,\\verb!s!,\\verb!t!$；\n- $8\\leftrightarrow \\verb!u!,\\verb!v!,\\verb!w!$；\n- $9\\leftrightarrow \\verb!x!,\\verb!y!,\\verb!z!$。\n\n现在给定一个单词表和一串数字密码，请你用单词表中的单词翻译这个密码。\n", "inputFormat": "第一行为一个正整数 $N$ 表示单词表中单词的个数 $(N≤100)$；\n\n第二行为一个长度不超过 $100$ 的数字串，表示密码；\n\n接下来的 $N$ 行，每行一个长度不超过 $20$ 的单词，表示单词表。\n", "outputFormat": "仅一行，表示翻译后的原文，如果密码无法翻译，则输出 `No Solutions!`，如果密码有多种翻译方式，则输出任意一种即可。\n", "hint": "由 @zhouyonglong 提供SPJ\n", "locale": "zh-CN", "translations": {"en": {"title": "Phone Number", "background": "", "description": "On a telephone keypad, several English letters are written under each digit. The mapping is as follows:\n- $1\\leftrightarrow \\verb!a!,\\verb!b!,\\verb!c!$.\n- $2\\leftrightarrow \\verb!d!,\\verb!e!,\\verb!f!$.\n- $3\\leftrightarrow \\verb!g!,\\verb!h!,\\verb!i!$.\n- $4\\leftrightarrow \\verb!j!,\\verb!k!,\\verb!l!$.\n- $5\\leftrightarrow \\verb!m!,\\verb!n!$.\n- $6\\leftrightarrow \\verb!o!,\\verb!p!,\\verb!q!$.\n- $7\\leftrightarrow \\verb!r!,\\verb!s!,\\verb!t!$.\n- $8\\leftrightarrow \\verb!u!,\\verb!v!,\\verb!w!$.\n- $9\\leftrightarrow \\verb!x!,\\verb!y!,\\verb!z!$.\n\nNow, given a word list and a sequence of digits (a numeric code), please translate the code using words from the list.", "inputFormat": "The first line contains a positive integer $N$ indicating the number of words in the list $(N \\le 100)$.\n\nThe second line contains a digit string of length at most $100$, representing the code.\n\nThe next $N$ lines each contain one word of length at most $20$, representing the word list.", "outputFormat": "Output a single line: the decoded original text. If the code cannot be translated, output `No Solutions!`. If there are multiple valid translations, output any one of them.", "hint": "SPJ provided by @zhouyonglong.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "电话号码", "background": "", "description": "电话机上每一个数字下面都写了若干个英文字母。分布如下：\n\n- $1\\leftrightarrow \\verb!a!,\\verb!b!,\\verb!c!$；\n- $2\\leftrightarrow \\verb!d!,\\verb!e!,\\verb!f!$；\n- $3\\leftrightarrow \\verb!g!,\\verb!h!,\\verb!i!$；\n- $4\\leftrightarrow \\verb!j!,\\verb!k!,\\verb!l!$；\n- $5\\leftrightarrow \\verb!m!,\\verb!n!$；\n- $6\\leftrightarrow \\verb!o!,\\verb!p!,\\verb!q!$；\n- $7\\leftrightarrow \\verb!r!,\\verb!s!,\\verb!t!$；\n- $8\\leftrightarrow \\verb!u!,\\verb!v!,\\verb!w!$；\n- $9\\leftrightarrow \\verb!x!,\\verb!y!,\\verb!z!$。\n\n现在给定一个单词表和一串数字密码，请你用单词表中的单词翻译这个密码。\n", "inputFormat": "第一行为一个正整数 $N$ 表示单词表中单词的个数 $(N≤100)$；\n\n第二行为一个长度不超过 $100$ 的数字串，表示密码；\n\n接下来的 $N$ 行，每行一个长度不超过 $20$ 的单词，表示单词表。\n", "outputFormat": "仅一行，表示翻译后的原文，如果密码无法翻译，则输出 `No Solutions!`，如果密码有多种翻译方式，则输出任意一种即可。\n", "hint": "由 @zhouyonglong 提供SPJ\n", "locale": "zh-CN"}}}
{"pid": "P1246", "type": "P", "difficulty": 3, "samples": [["ab\r\n", "27\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "递归", "线性递推"], "title": "编码", "background": "", "description": "编码工作常被运用于密文或压缩传输。这里我们用一种最简单的编码方式进行编码：把一些有规律的单词编成数字。\n\n字母表中共有 $26$ 个字母 $\\mathtt{a,b,c,\\cdots,z}$，这些特殊的单词长度不超过 $6$ 且字母按升序排列。把所有这样的单词放在一起，按字典顺序排列，一个单词的编码就对应着它在字典中的位置。\n\n例如：\n\n- $\\verb!a! \\to 1$；\n- $\\verb!b! \\to 2$；\n- $\\verb!z! \\to 26$；\n- $\\verb!ab! \\to 27$；\n- $\\verb!ac! \\to 28$。\n\n你的任务就是对于所给的单词，求出它的编码。\n", "inputFormat": "仅一行，被编码的单词。\n", "outputFormat": "仅一行，对应的编码。如果单词不在字母表中，输出 $0$。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Encoding", "background": "", "description": "Encoding is often used for ciphertext or compressed transmission. Here we use one of the simplest methods: map some structured words to numbers.\n\nThere are $26$ letters in the alphabet, $\\mathtt{a,b,c,\\cdots,z}$. These special words have length at most $6$, and their letters are in strictly increasing order. Put all such words together and sort them in lexicographic order. The code of a word is the position of that word in this dictionary.\n\nFor example:\n- $\\verb!a! \\to 1$.\n- $\\verb!b! \\to 2$.\n- $\\verb!z! \\to 26$.\n- $\\verb!ab! \\to 27$.\n- $\\verb!ac! \\to 28$.\n\nYour task is to compute the code of the given word.", "inputFormat": "A single line containing the word to be encoded.", "outputFormat": "A single line containing the corresponding code. If the word is not in this dictionary, output $0$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "编码", "background": "", "description": "编码工作常被运用于密文或压缩传输。这里我们用一种最简单的编码方式进行编码：把一些有规律的单词编成数字。\n\n字母表中共有 $26$ 个字母 $\\mathtt{a,b,c,\\cdots,z}$，这些特殊的单词长度不超过 $6$ 且字母按升序排列。把所有这样的单词放在一起，按字典顺序排列，一个单词的编码就对应着它在字典中的位置。\n\n例如：\n\n- $\\verb!a! \\to 1$；\n- $\\verb!b! \\to 2$；\n- $\\verb!z! \\to 26$；\n- $\\verb!ab! \\to 27$；\n- $\\verb!ac! \\to 28$。\n\n你的任务就是对于所给的单词，求出它的编码。\n", "inputFormat": "仅一行，被编码的单词。\n", "outputFormat": "仅一行，对应的编码。如果单词不在字母表中，输出 $0$。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1247", "type": "P", "difficulty": 4, "samples": [["3\n3 6 9\n", "4 3\n3 6 5\n"], ["4\n15 22 19 10", "lose"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["博弈论"], "title": "取火柴游戏", "background": "", "description": "输入 $k$ 及 $k$ 个整数 $n_1,n_2,\\cdots,n_k$，表示有 $k$ 堆火柴棒，第 $i$ 堆火柴棒的根数为 $n_i$；接着便是你和计算机取火柴棒的对弈游戏。取的规则如下：每次可以从一堆中取走若干根火柴，也可以一堆全部取走，但不允许跨堆取，也不允许不取。\n\n谁取走最后一根火柴为胜利者。\n\n例如：$k=2$，$n_1=n_2=2$，A 代表你，P 代表计算机，若决定 A 先取：\n\n- A：$(2,2) \\rightarrow (1,2)$，即从第一堆中取一根。\n- P：$(1,2) \\rightarrow (1,1)$，即从第二堆中取一根。\n- A：$(1,1) \\rightarrow (1,0)$。\n- P：$(1,0) \\rightarrow (0,0)$。P 胜利。\n\n如果决定 $A$ 后取：\n\n- P：$(2,2) \\rightarrow (2,0)$。\n- A：$(2,0) \\rightarrow (0,0)$。A 胜利。\n\n又如 $k=3$，$n_1=1$，$n_2=2$，$n_3=3$，$A$ 决定后取：\n\n- P：$(1,2,3) \\rightarrow (0,2,3)$。\n- A：$(0,2,3) \\rightarrow (0,2,2)$。\n- A 已将游戏归结为 $(2,2)$ 的情况，不管 P 如何取 A 都必胜。\n\n编一个程序，在给出初始状态之后，判断是先取必胜还是先取必败，如果是先取必胜，请输出第一次该如何取。如果是先取必败，则输出 `lose`。", "inputFormat": "第一行，一个正整数 $k$。\n\n第二行，$k$ 个整数 $n_1,n_2,\\cdots,n_k$。", "outputFormat": "如果是先取必胜，请在第一行输出两个整数 $a,b$，表示第一次从第 $b$ 堆取出 $a$ 个。第二行为第一次取火柴后的状态。如果有多种答案，则输出 $\\lang b,a\\rang$ 字典序最小的答案（ 即 $b$ 最小的前提下，使 $a$ 最小）。\n\n如果是先取必败，则输出 `lose`。", "hint": "### 数据范围及约定\n\n对于全部数据，$k \\le 500000$，$n_i \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "Matchstick Game", "background": "", "description": "Given $k$ and $k$ integers $n_1, n_2, \\cdots, n_k$, there are $k$ piles of matchsticks, where the $i$-th pile contains $n_i$ sticks. You will then play a matchstick-taking game against the computer. The rules are as follows: on each turn, you may take any positive number of matchsticks from exactly one pile, possibly taking the entire pile, but you may not take from multiple piles in a single move, and you may not pass.\n\nWhoever takes the last matchstick wins.\n\nFor example: $k = 2$, $n_1 = n_2 = 2$. Let A denote you, and P denote the computer. If A moves first:\n\n- A: $(2, 2) \\rightarrow (1, 2)$, that is, take one from the first pile.\n- P: $(1, 2) \\rightarrow (1, 1)$, that is, take one from the second pile.\n- A: $(1, 1) \\rightarrow (1, 0)$.\n- P: $(1, 0) \\rightarrow (0, 0)$. P wins.\n\nIf A moves second:\n\n- P: $(2, 2) \\rightarrow (2, 0)$.\n- A: $(2, 0) \\rightarrow (0, 0)$. A wins.\n\nAnother example: $k = 3$, $n_1 = 1$, $n_2 = 2$, $n_3 = 3$, and A moves second:\n\n- P: $(1, 2, 3) \\rightarrow (0, 2, 3)$.\n- A: $(0, 2, 3) \\rightarrow (0, 2, 2)$.\n- A has reduced the game to the $(2, 2)$ case; no matter how P moves, A will surely win.\n\nWrite a program that, given the initial state, determines whether the first player has a forced win or a forced loss. If the first player has a forced win, output how to make the first move. If the first player has a forced loss, output `lose`.", "inputFormat": "The first line contains a positive integer $k$.\n\nThe second line contains $k$ integers $n_1, n_2, \\cdots, n_k$.", "outputFormat": "If the first player has a forced win, output two integers $a, b$ on the first line, meaning that on the first move you take $a$ matchsticks from pile $b$. The second line should be the state after the first move.\n\nIf there are multiple valid answers, output the lexicographically smallest answer by the pair $\\langle b, a \\rangle$ (that is, with the smallest $b$, and under that, the smallest $a$).\n\nIf the first player has a forced loss, output `lose`.", "hint": "### Constraints\n\nFor all testdata, $k \\le 500000$, $n_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "取火柴游戏", "background": "", "description": "输入 $k$ 及 $k$ 个整数 $n_1,n_2,\\cdots,n_k$，表示有 $k$ 堆火柴棒，第 $i$ 堆火柴棒的根数为 $n_i$；接着便是你和计算机取火柴棒的对弈游戏。取的规则如下：每次可以从一堆中取走若干根火柴，也可以一堆全部取走，但不允许跨堆取，也不允许不取。\n\n谁取走最后一根火柴为胜利者。\n\n例如：$k=2$，$n_1=n_2=2$，A 代表你，P 代表计算机，若决定 A 先取：\n\n- A：$(2,2) \\rightarrow (1,2)$，即从第一堆中取一根。\n- P：$(1,2) \\rightarrow (1,1)$，即从第二堆中取一根。\n- A：$(1,1) \\rightarrow (1,0)$。\n- P：$(1,0) \\rightarrow (0,0)$。P 胜利。\n\n如果决定 $A$ 后取：\n\n- P：$(2,2) \\rightarrow (2,0)$。\n- A：$(2,0) \\rightarrow (0,0)$。A 胜利。\n\n又如 $k=3$，$n_1=1$，$n_2=2$，$n_3=3$，$A$ 决定后取：\n\n- P：$(1,2,3) \\rightarrow (0,2,3)$。\n- A：$(0,2,3) \\rightarrow (0,2,2)$。\n- A 已将游戏归结为 $(2,2)$ 的情况，不管 P 如何取 A 都必胜。\n\n编一个程序，在给出初始状态之后，判断是先取必胜还是先取必败，如果是先取必胜，请输出第一次该如何取。如果是先取必败，则输出 `lose`。", "inputFormat": "第一行，一个正整数 $k$。\n\n第二行，$k$ 个整数 $n_1,n_2,\\cdots,n_k$。", "outputFormat": "如果是先取必胜，请在第一行输出两个整数 $a,b$，表示第一次从第 $b$ 堆取出 $a$ 个。第二行为第一次取火柴后的状态。如果有多种答案，则输出 $\\lang b,a\\rang$ 字典序最小的答案（ 即 $b$ 最小的前提下，使 $a$ 最小）。\n\n如果是先取必败，则输出 `lose`。", "hint": "### 数据范围及约定\n\n对于全部数据，$k \\le 500000$，$n_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P1248", "type": "P", "difficulty": 6, "samples": [["5\n3 5 8 7 10\n6 2 1 4 9\n", "34\n1 5 4 2 3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "Special Judge"], "title": "加工生产调度", "background": null, "description": "某工厂收到了 $n$ 个产品的订单，这 $n$ 个产品分别在 A、B 两个车间加工，并且必须先在 A 车间加工后才可以到 B 车间加工。一个车间在同一时刻只能加工一个产品。\n\n某个产品 $i$ 在 A、B 两车间加工的时间分别为 $A_i,B_i$。怎样安排这 $n$ 个产品的加工顺序，才能使总的加工时间最短。\n\n这里所说的加工时间是指：从开始加工第一个产品到最后所有的产品都已在 A、B 两车间加工完毕的时间。", "inputFormat": "第一行仅—个整数 $n$，表示产品的数量。\n\n接下来一行 $n$ 个整数是表示这 $n$ 个产品在 A 车间加工各自所要的时间。\n\n最后的 $n$ 个整数是表示这 $n$ 个产品在 B 车间加工各自所要的时间。", "outputFormat": "第一行一个整数，表示最少的加工时间。\n\n第二行是一种最小加工时间的加工顺序。", "hint": "$1\\leq n\\leq 1000$，$1\\leq A_i,B_i\\leq 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Two-Workshop Manufacturing Scheduling", "background": "", "description": "A factory has received orders for $n$ products. Each product must be processed in workshop A first and then in workshop B. At any moment, each workshop can process at most one product.\n\nFor product $i$, its processing times in workshops A and B are $A_i$ and $B_i$, respectively. Determine an order to process the $n$ products that minimizes the total processing time.\n\nThe total processing time is defined as the time from starting the first product until all products have finished processing in both workshops A and B.", "inputFormat": "- The first line contains a single integer $n$, the number of products.\n- The second line contains $n$ integers, the processing times of the $n$ products in workshop A.\n- The third line contains $n$ integers, the processing times of the $n$ products in workshop B.", "outputFormat": "- The first line contains one integer, the minimal total processing time.\n- The second line contains one processing order that achieves the minimal total processing time. Output the product indices (from $1$ to $n$) separated by spaces.", "hint": "Constraints: $1 \\leq n \\leq 1000$, $1 \\leq A_i, B_i \\leq 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "加工生产调度", "background": null, "description": "某工厂收到了 $n$ 个产品的订单，这 $n$ 个产品分别在 A、B 两个车间加工，并且必须先在 A 车间加工后才可以到 B 车间加工。一个车间在同一时刻只能加工一个产品。\n\n某个产品 $i$ 在 A、B 两车间加工的时间分别为 $A_i,B_i$。怎样安排这 $n$ 个产品的加工顺序，才能使总的加工时间最短。\n\n这里所说的加工时间是指：从开始加工第一个产品到最后所有的产品都已在 A、B 两车间加工完毕的时间。", "inputFormat": "第一行仅—个整数 $n$，表示产品的数量。\n\n接下来一行 $n$ 个整数是表示这 $n$ 个产品在 A 车间加工各自所要的时间。\n\n最后的 $n$ 个整数是表示这 $n$ 个产品在 B 车间加工各自所要的时间。", "outputFormat": "第一行一个整数，表示最少的加工时间。\n\n第二行是一种最小加工时间的加工顺序。", "hint": "$1\\leq n\\leq 1000$，$1\\leq A_i,B_i\\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P1249", "type": "P", "difficulty": 3, "samples": [["10\n", "2 3 5\n30"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "高精度"], "title": "最大乘积", "background": null, "description": "一个正整数一般可以分为几个互不相同的自然数的和，如 $3=1+2$，$4=1+3$，$5=1+4=2+3$，$6=1+5=2+4$。\n\n现在你的任务是将指定的正整数 $n$ 分解成若干个互不相同的自然数（也可以不分解，就是这个数字本身）的和，且使这些自然数的乘积最大。", "inputFormat": "只有一个正整数 $n$，（$3 \\leq n \\leq 10000$）。", "outputFormat": "第一行是分解方案，相邻的数之间用一个空格分开，并且按由小到大的顺序。\n\n第二行是最大的乘积。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Maximum Product", "background": "", "description": "A positive integer can generally be written as a sum of several pairwise distinct positive integers, such as $3=1+2$, $4=1+3$, $5=1+4=2+3$, $6=1+5=2+4$.\n\nYour task is to decompose the given positive integer $n$ into a sum of several pairwise distinct positive integers (you may also choose not to decompose it and use the number itself), such that the product of these integers is maximized.", "inputFormat": "A single positive integer $n$ ($3 \\leq n \\leq 10000$).", "outputFormat": "The first line contains the decomposition, with adjacent numbers separated by a single space, in nondecreasing order.\n\nThe second line contains the maximum product.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最大乘积", "background": null, "description": "一个正整数一般可以分为几个互不相同的自然数的和，如 $3=1+2$，$4=1+3$，$5=1+4=2+3$，$6=1+5=2+4$。\n\n现在你的任务是将指定的正整数 $n$ 分解成若干个互不相同的自然数（也可以不分解，就是这个数字本身）的和，且使这些自然数的乘积最大。", "inputFormat": "只有一个正整数 $n$，（$3 \\leq n \\leq 10000$）。", "outputFormat": "第一行是分解方案，相邻的数之间用一个空格分开，并且按由小到大的顺序。\n\n第二行是最大的乘积。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1250", "type": "P", "difficulty": 3, "samples": [["9\n4\n1 4 2\n4 6 2\n8 9 2\n3 5 2", "5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "排序", "差分约束"], "title": "种树", "background": "一条街的一边有几座房子，因为环保原因居民想要在路边种些树。", "description": "路边的地区被分割成块，并被编号成 $1, 2, \\ldots,n$。每个部分为一个单位尺寸大小并最多可种一棵树。\n\n每个居民都想在门前种些树，并指定了三个号码 $b$，$e$，$t$。这三个数表示该居民想在地区 $b$ 和 $e$ 之间（包括 $b$ 和 $e$）种至少 $t$ 棵树。\n\n居民们想种树的各自区域可以交叉。你的任务是求出能满足所有要求的最少的树的数量。", "inputFormat": "输入的第一行是一个整数，代表区域的个数 $n$。\n\n输入的第二行是一个整数，代表房子个数 $h$。\n\n第 $3$ 到第 $(h + 2)$ 行，每行三个整数，第 $(i + 2)$ 行的整数依次为 $b_i, e_i, t_i$，代表第 $i$ 个居民想在 $b_i$ 和 $e_i$ 之间种至少 $t_i$ 棵树。", "outputFormat": "输出一行一个整数，代表最少的树木个数。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n\n- $1 \\leq n \\leq 3 \\times 10^4$，$1 \\leq h \\leq 5 \\times 10^3$。\n- $1 \\leq b_i \\leq e_i \\leq n$，$1 \\leq t_i \\leq e_i - b_i + 1$。", "locale": "zh-CN", "translations": {"en": {"title": "Planting Trees", "background": "On one side of a street there are several houses. For environmental reasons, the residents want to plant some trees along the roadside.", "description": "The roadside area is divided into blocks and numbered $1, 2, \\ldots,n$. Each block has unit size and can contain at most one tree.\n\nEach resident wants to plant some trees in front of their house and specifies three numbers $b$, $e$, $t$. These numbers mean that the resident wants at least $t$ trees in the area between $b$ and $e$ (inclusive of $b$ and $e$).\n\nDifferent residents’ desired intervals may overlap. Your task is to find the minimum number of trees that can satisfy all requirements.", "inputFormat": "The first line contains an integer, the number of areas $n$.\n\nThe second line contains an integer, the number of houses $h$.\n\nLines $3$ to $(h + 2)$ each contain three integers. On line $(i + 2)$, the integers are $b_i, e_i, t_i$, meaning the $i$-th resident wants at least $t_i$ trees between $b_i$ and $e_i$.", "outputFormat": "Output a single integer, the minimum number of trees.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that:\n\n- $1 \\leq n \\leq 3 \\times 10^4$，$1 \\leq h \\leq 5 \\times 10^3$。\n- $1 \\leq b_i \\leq e_i \\leq n$，$1 \\leq t_i \\leq e_i - b_i + 1$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "种树", "background": "一条街的一边有几座房子，因为环保原因居民想要在路边种些树。", "description": "路边的地区被分割成块，并被编号成 $1, 2, \\ldots,n$。每个部分为一个单位尺寸大小并最多可种一棵树。\n\n每个居民都想在门前种些树，并指定了三个号码 $b$，$e$，$t$。这三个数表示该居民想在地区 $b$ 和 $e$ 之间（包括 $b$ 和 $e$）种至少 $t$ 棵树。\n\n居民们想种树的各自区域可以交叉。你的任务是求出能满足所有要求的最少的树的数量。", "inputFormat": "输入的第一行是一个整数，代表区域的个数 $n$。\n\n输入的第二行是一个整数，代表房子个数 $h$。\n\n第 $3$ 到第 $(h + 2)$ 行，每行三个整数，第 $(i + 2)$ 行的整数依次为 $b_i, e_i, t_i$，代表第 $i$ 个居民想在 $b_i$ 和 $e_i$ 之间种至少 $t_i$ 棵树。", "outputFormat": "输出一行一个整数，代表最少的树木个数。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n\n- $1 \\leq n \\leq 3 \\times 10^4$，$1 \\leq h \\leq 5 \\times 10^3$。\n- $1 \\leq b_i \\leq e_i \\leq n$，$1 \\leq t_i \\leq e_i - b_i + 1$。", "locale": "zh-CN"}}}
