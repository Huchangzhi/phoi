{"pid": "P13415", "type": "P", "difficulty": 2, "samples": [["5 5\n../.\\\n.....\n.C...\n...C.\n\\.../\n3 3 ", "U\n17"], ["5 5\n....\\\n\\..\\.\n./\\..\n\\../C\n.\\../\n1 1", "D\n12"], ["5 7\n/.....\\\n../..\\.\n\\...../\n/.....\\\n\\.\\.../\n3 3 ", "R\nVoyager"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["2012", "枚举", "COCI（克罗地亚）"], "title": "[COCI 2012/2013 #4] VOYAGER", "background": "", "description": "The Voyager 1 space probe (not to be confused with the Intrepid-class starship) was launched a long time ago, in 1977, and is currently on the verge of leaving our Solar System. As it travels further through space, it has been programmed to leave a radio signal message in any star system it stumbles upon, to mark the probe's path for as long as possible.\n\nLet us assume that a star system can be represented by a rectangular grid with $N$ rows and $M$ columns, dividing the space into $N$ by $M$ equal cells. Each cell can contain a single planet, black hole, or be empty. The probe broadcasts the signal from a pre-determined empty cell, in one of the four axis-aligned directions (\"U\"-up, \"R\"-right, \"D\"-down, \"L\"-left).\n\nUpon being broadcast, the signal propagates in a straight line along the same row/column until it reaches a planet, where it is deflected by 90 degrees in another direction. There are two kinds of planets, which we will denote by \"/\" and \"\\\\\". The deflection rules are shown in the image below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zoyosa0s.png)\n\nThe signal permanently leaves the system upon either entering a cell containing a black hole, or propagating outside the edges of the rectangular grid. It is also known that the signal needs one second to propagate from the current cell to a neighboring one.\n\nWrite a program to determine the direction in which the probe needs to broadcast the signal so that it remains within the system for as long as possible, outputting the optimal direction as well as the resulting longest time. If it is possible for the signal to remain in the system indefinitely, output the message \"Voyager\" instead of the required time.", "inputFormat": "The first line of input contains two positive integers, $N$ ($1 \\leq N \\leq 500$) and $M$ ($1 \\leq M \\leq 500$).\n\nEach of the following $N$ lines contains $M$ characters from the set `/, \\, C, .`, where \"/\" and \"\\\\\" represent the two kinds of planets, “C” represents a black hole, and “.” represents an empty cell.\n\nThe last line of input contains two positive integers, ${PR}$ ($1 \\leq PR \\leq N$) and ${PC}$ ($1 \\leq {PC} \\leq {M}$), the row and column number, respectively, of the cell where the probe is situated.\n", "outputFormat": "The first line of output must contain the required optimal broadcast direction (\"U\", \"R\", \"D\", or \"L\"). If the solution is not unique, select the first optimal one in the following priority order: first \"U\", then \"R\", then \"D\", and finally \"L\".\n\nThe second line of output must contain the required longest time (or message).", "hint": "In test data worth at least 50% of total points, the signal will not be able to remain in the system indefinitely. \n\nClarification of the first example (\"*\" represents the path of the singal): \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5b6kat2r.png)", "locale": "en", "translations": {"en": {"title": "[COCI 2012/2013 #4] VOYAGER", "background": "", "description": "The Voyager 1 space probe (not to be confused with the Intrepid-class starship) was launched a long time ago, in 1977, and is currently on the verge of leaving our Solar System. As it travels further through space, it has been programmed to leave a radio signal message in any star system it stumbles upon, to mark the probe's path for as long as possible.\n\nLet us assume that a star system can be represented by a rectangular grid with $N$ rows and $M$ columns, dividing the space into $N$ by $M$ equal cells. Each cell can contain a single planet, black hole, or be empty. The probe broadcasts the signal from a pre-determined empty cell, in one of the four axis-aligned directions (\"U\"-up, \"R\"-right, \"D\"-down, \"L\"-left).\n\nUpon being broadcast, the signal propagates in a straight line along the same row/column until it reaches a planet, where it is deflected by 90 degrees in another direction. There are two kinds of planets, which we will denote by \"/\" and \"\\\\\". The deflection rules are shown in the image below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zoyosa0s.png)\n\nThe signal permanently leaves the system upon either entering a cell containing a black hole, or propagating outside the edges of the rectangular grid. It is also known that the signal needs one second to propagate from the current cell to a neighboring one.\n\nWrite a program to determine the direction in which the probe needs to broadcast the signal so that it remains within the system for as long as possible, outputting the optimal direction as well as the resulting longest time. If it is possible for the signal to remain in the system indefinitely, output the message \"Voyager\" instead of the required time.", "inputFormat": "The first line of input contains two positive integers, $N$ ($1 \\leq N \\leq 500$) and $M$ ($1 \\leq M \\leq 500$).\n\nEach of the following $N$ lines contains $M$ characters from the set `/, \\, C, .`, where \"/\" and \"\\\\\" represent the two kinds of planets, “C” represents a black hole, and “.” represents an empty cell.\n\nThe last line of input contains two positive integers, ${PR}$ ($1 \\leq PR \\leq N$) and ${PC}$ ($1 \\leq {PC} \\leq {M}$), the row and column number, respectively, of the cell where the probe is situated.\n", "outputFormat": "The first line of output must contain the required optimal broadcast direction (\"U\", \"R\", \"D\", or \"L\"). If the solution is not unique, select the first optimal one in the following priority order: first \"U\", then \"R\", then \"D\", and finally \"L\".\n\nThe second line of output must contain the required longest time (or message).", "hint": "In test data worth at least 50% of total points, the signal will not be able to remain in the system indefinitely. \n\nClarification of the first example (\"*\" represents the path of the singal): \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5b6kat2r.png)", "locale": "en"}, "zh-CN": {"title": "[COCI 2012/2013 #4] VOYAGER", "background": "", "description": "旅行者一号（Voyager 1）探测器（不要与 Intrepid 级星舰混淆）早在 1977 年就被发射升空，如今正接近离开我们的太阳系。在它不断穿梭于太空的旅途中，它被编程为在遇到的每一个恒星系统中留下无线电信号标记，以尽可能长时间地标记探测器的轨迹。\n\n我们假设一个恒星系统可以用一个 $N$ 行 $M$ 列的矩形网格表示，将空间划分为 $N \\times M$ 个相等的格子。每个格子可以包含一个行星、黑洞，或者为空。探测器会从一个预定的空格子中，以某个轴对齐的方向（\"U\"-上，\"R\"-右，\"D\"-下，\"L\"-左）发出信号。\n\n信号发射后，会沿当前行/列的直线方向传播，直到遇到行星，此时信号会被偏转 $90$ 度，转向另一个方向。有两种类型的行星，分别用 \"/\" 和 \"\\\\\" 表示。偏转规则如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zoyosa0s.png)\n\n当信号进入黑洞格子，或离开矩形网格边界时，信号会永久离开该系统。已知信号从当前格子传播到相邻格子需要 $1$ 秒。\n\n请编写程序，确定探测器应以哪个方向发射信号，才能使信号在系统中停留的时间最长，并输出最佳方向以及最长停留时间。如果信号可以在系统内无限循环，请输出 \"Voyager\" 替代时间。\n", "inputFormat": "第一行输入两个正整数 $N$（$1 \\leq N \\leq 500$）和 $M$（$1 \\leq M \\leq 500$）。\n\n接下来 $N$ 行，每行 $M$ 个字符，字符集为 `/, \\, C, .`，其中 \"/\" 和 \"\\\\\" 表示两种类型的行星，\"C\" 表示黑洞，\".\" 表示空格子。\n\n最后一行输入两个正整数 ${PR}$（$1 \\leq PR \\leq N$）和 ${PC}$（$1 \\leq {PC} \\leq {M}$），分别表示探测器所在格子的行号和列号。\n", "outputFormat": "输出两行。\n\n第一行输出最佳发射方向（\"U\"、\"R\"、\"D\"、\"L\"）。如果有多种方案，按以下优先顺序输出：先 \"U\"，再 \"R\"，然后 \"D\"，最后 \"L\"。\n\n第二行输出最长停留时间（或 \"Voyager\"）。\n", "hint": "在价值至少 50% 分数的测试数据中，信号不可能在系统内无限循环。\n\n第一个样例的说明（\"*\" 表示信号的路径）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5b6kat2r.png)\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13416", "type": "P", "difficulty": 3, "samples": [["5 2\n-3 -2 3 8 6", "7"], ["6 2\n-5 8 10 1 13 -1", "13"], ["6 3\n10 2 8 17 2 17", "6"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["数学", "贪心", "2012", "单调队列", "排序", "差分", "COCI（克罗地亚）"], "title": "[COCI 2012/2013 #4] RAZLIKA", "background": "", "description": "Mirko's newest math homework assignment is a very difficult one! Given a sequence, $V$, of $N$ integers, remove exactly $K$ of them from the sequence. Let $M$ be the largest difference of any two remaining numbers in the sequence, and $m$ the smallest such difference. Select the $K$ integers to be removed from $V$ in such a way that the sum $M + m$ is the smallest possible. Mirko isn't very good at math, so he has asked you to help him!\n", "inputFormat": "The first line of input contains two positive integers, $N$ ($3 \\leq N \\leq 1\\,000\\,000$) and $K$ ($1 \\leq K \\leq N - 2$).\n\nThe second line of input contains $N$ space-separated positive integers – the sequence $V$ ($-5\\,000\\,000 \\leq V_i \\leq 5\\,000\\,000$).", "outputFormat": "The first and only line of output must contain the smallest possible sum $M + m$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[COCI 2012/2013 #4] RAZLIKA", "background": "", "description": "Mirko's newest math homework assignment is a very difficult one! Given a sequence, $V$, of $N$ integers, remove exactly $K$ of them from the sequence. Let $M$ be the largest difference of any two remaining numbers in the sequence, and $m$ the smallest such difference. Select the $K$ integers to be removed from $V$ in such a way that the sum $M + m$ is the smallest possible. Mirko isn't very good at math, so he has asked you to help him!\n", "inputFormat": "The first line of input contains two positive integers, $N$ ($3 \\leq N \\leq 1\\,000\\,000$) and $K$ ($1 \\leq K \\leq N - 2$).\n\nThe second line of input contains $N$ space-separated positive integers – the sequence $V$ ($-5\\,000\\,000 \\leq V_i \\leq 5\\,000\\,000$).", "outputFormat": "The first and only line of output must contain the smallest possible sum $M + m$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[COCI 2012/2013 #4] RAZLIKA", "background": "", "description": "Mirko 最新的数学作业非常难！给定一个长度为 $N$ 的整数序列 $V$，你需要从中**恰好**移除 $K$ 个数。设 $M$ 为剩下所有数中任意两数的**最大差值**，$m$ 为**最小差值**。请你选择要移除的 $K$ 个数，使得 $M + m$ 的值尽可能小。Mirko 数学不太好，所以他请求你帮忙！\n", "inputFormat": "第一行输入两个正整数 $N$（$3 \\leq N \\leq 1\\,000\\,000$）和 $K$（$1 \\leq K \\leq N - 2$）。\n\n第二行输入 $N$ 个用空格分隔的整数，表示序列 $V$（$-5\\,000\\,000 \\leq V_i \\leq 5\\,000\\,000$）。\n", "outputFormat": "输出一行，表示最小可能的 $M + m$。", "hint": "翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13417", "type": "P", "difficulty": 3, "samples": [["1 100 3\n1 2 3 ", "1 2 3"], ["2 100 3\n1 2 3", "1 2 3 4 6 9"], ["10 101 2\n5 50", "36 44 57 65"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["动态规划 DP", "数学", "递推", "2012", "倍增", "递归", "矩阵加速", "COCI（克罗地亚）"], "title": "[COCI 2012/2013 #4] DLAKAVAC", "background": "", "description": "In the faraway city of Xanadu, a flu epidemic has broken out, caused by a strain known as hairy flu. There are $M$ people living in the city, each resident having a unique personal ID number from the range of $0$ to $M - 1$, inclusive. Infection with this strain lasts exactly one day, and a person can catch it multiple times per season (since it mutates too quickly for lasting immunity).\n\nOn the first day of the epidemic, the flu was brought from another faraway country by a group of residents nicknamed \"init-patients\", whose ID numbers are known. The flu's spread is based on them. Each following day, a resident with ID number $p$ will catch the flu iff there exists a resident with ID $a$ who was infected the previous day, as well as an init-patient with ID $b$, such that:\n\n$$\n(a \\times b) \\bmod M = p.\n$$\n\nThe numbers $a$ and $b$ need not be distinct. For example, consider a case where there are $101$ people in the town, and the init-patients are $5$ and $50$. On the first day, the init-patients are infected by definition. On the second day, the residents infected are $25$, $48$ ($250 \\mod 101$), and $76$ ($2500 \\mod 101$). On the third day, one of the infected patients is $77$, since $(48 \\times 50) \\mod 101 = 77$.\n\nWho will catch the flu on the $K$-th day?", "inputFormat": "The first line of input contains three positive integers, $K$, $M$, and $N$ ($1 \\leq K \\leq 10^{18}$, $3 \\leq M \\leq 1500$, $N < M$).\n\nThe second line of input contains $N$ space-separated nonnegative integers, the personal ID numbers of residents who were infected on the first day (the init-patients). These numbers are unique, increasing, and do not exceed $M - 1$.\n", "outputFormat": "The first and only line of output must contain the personal ID numbers of residents infected with flu on the $K$-th day, given space-separated and in increasing order.", "hint": "", "locale": "en", "translations": {"en": {"title": "[COCI 2012/2013 #4] DLAKAVAC", "background": "", "description": "In the faraway city of Xanadu, a flu epidemic has broken out, caused by a strain known as hairy flu. There are $M$ people living in the city, each resident having a unique personal ID number from the range of $0$ to $M - 1$, inclusive. Infection with this strain lasts exactly one day, and a person can catch it multiple times per season (since it mutates too quickly for lasting immunity).\n\nOn the first day of the epidemic, the flu was brought from another faraway country by a group of residents nicknamed \"init-patients\", whose ID numbers are known. The flu's spread is based on them. Each following day, a resident with ID number $p$ will catch the flu iff there exists a resident with ID $a$ who was infected the previous day, as well as an init-patient with ID $b$, such that:\n\n$$\n(a \\times b) \\bmod M = p.\n$$\n\nThe numbers $a$ and $b$ need not be distinct. For example, consider a case where there are $101$ people in the town, and the init-patients are $5$ and $50$. On the first day, the init-patients are infected by definition. On the second day, the residents infected are $25$, $48$ ($250 \\mod 101$), and $76$ ($2500 \\mod 101$). On the third day, one of the infected patients is $77$, since $(48 \\times 50) \\mod 101 = 77$.\n\nWho will catch the flu on the $K$-th day?", "inputFormat": "The first line of input contains three positive integers, $K$, $M$, and $N$ ($1 \\leq K \\leq 10^{18}$, $3 \\leq M \\leq 1500$, $N < M$).\n\nThe second line of input contains $N$ space-separated nonnegative integers, the personal ID numbers of residents who were infected on the first day (the init-patients). These numbers are unique, increasing, and do not exceed $M - 1$.\n", "outputFormat": "The first and only line of output must contain the personal ID numbers of residents infected with flu on the $K$-th day, given space-separated and in increasing order.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[COCI 2012/2013 #4] DLAKAVAC", "background": "", "description": "在遥远的 Xanadu 城市，一场由“毛流感”病毒引发的流感疫情爆发了。该市共有 $M$ 位居民，每位居民都有一个唯一的个人编号，编号范围为 $0$ 到 $M-1$。感染这种流感后会持续恰好一天，而且由于病毒变异极快，居民在同一季节内可以多次感染（不会获得持久免疫）。\n\n疫情爆发的第一天，流感由一批被称为“初始病人”（init-patients）的居民从另一个遥远国家带入，他们的编号是已知的。流感的传播以这些初始病人为基础。之后的每一天，编号为 $p$ 的居民会在且仅在存在编号为 $a$ 的居民在前一天感染，并且存在编号为 $b$ 的初始病人，使得：\n\n$$\n(a \\times b) \\bmod M = p\n$$\n\n其中 $a$ 和 $b$ 可以相同，也可以不同。例如，假设镇上有 $101$ 人，初始病人编号为 $5$ 和 $50$。第一天，初始病人自然感染。第二天，感染者为 $25$、$48$（$250 \\bmod 101$）、$76$（$2500 \\bmod 101$）。第三天，感染者之一为 $77$，因为 $(48 \\times 50) \\bmod 101 = 77$。\n\n请问第 $K$ 天会有哪些人感染流感？", "inputFormat": "第一行输入三个正整数 $K$、$M$ 和 $N$（$1 \\leq K \\leq 10^{18}$，$3 \\leq M \\leq 1500$，$N < M$）。\n\n第二行输入 $N$ 个两两不同、递增、且不超过 $M-1$ 的非负整数，表示初始病人的编号。", "outputFormat": "输出一行，按升序输出第 $K$ 天感染流感的所有居民编号，用空格分隔。\n", "hint": "翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13418", "type": "P", "difficulty": 4, "samples": [["3 2\n20 20 20\nQ 20\nQ 30", "0.000\n20.000 "], ["3 5\n0 2 0\nQ 2\nU 1 1\nQ 1\nU 1 10\nQ 5", "2.000\n1.000\n2.500"], ["7 7\n0 2 1 3 2 1 0\nQ 1\nQ 2\nQ 3\nU 3 0\nQ 1\nQ 2\nQ 3 ", "0.750\n3.750\n9.000\n1.500\n6.000\n12.000 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2012", "Special Judge", "COCI（克罗地亚）"], "title": "[COCI 2012/2013 #4] AKVARIJ", "background": "", "description": "Mirko has recently installed a new screensaver. If he is away from the keyboard for five minutes, the screen shows a picture of an aquarium with animated fish. The screensaver has settings for customizing the shape of the (virtual, sandy) aquarium bottom, as well as the water level.\n\nThe aquarium can be represented in a 2D Cartesian coordinate system as a shape $N - 1$ columns wide, where $N$ is a positive integer. The left wall of the aquarium has the x-coordinate of $0$, and the right wall has the x-coordinate of $N - 1$. Each integer-valued x-coordinate of the aquarium bottom (let us denote it by $i$) from $0$ to $N - 1$ has a separately adjustable height of $H_i$. Between any two adjacent integer-valued x-coordinates $i$ and $i + 1$, the bottom can be described by a line segment between points $(i, H_i)$ and $(i + 1, H_{i+1})$.\n\nIf the water level is set to $h$, the water fills the area between the line $y = h$ and the aquarium bottom. If a part of the aquarium bottom is above the water level $h$, it forms an island and is not submerged.\n\nFor different shapes of the aquarium bottom, Mirko would like to know the total area of his screen covered by water. Help Mirko find answers to his questions (other than 42).", "inputFormat": "The first line of input contains two positive integers, $N$ ($3 \\leq N \\leq 100\\,000$, the length of the bottom) and $M$ ($1 \\leq M \\leq 100\\,000$, the number of queries).\n\nThe second line of input contains $N$ space-separated nonnegative integers $H_i$ ($0 \\leq H_i \\leq 1000$), the starting bottom heights.\n\nEach of the following $M$ lines contains a single query with one of the following two types:\n\n- Q $h$ – if the water level is set to $h$ ($0 \\leq h \\leq 1000$), assuming the current bottom shape, what is the total screen area covered by water?\n- U $i$ $h$ – Mirko has decided to change the bottom height at x-coordinate $i$ ($0 \\leq i \\leq N - 1$) to $h$ ($0 \\leq h \\leq 1000$); in other words, set $H_i = h$.", "outputFormat": "For each query with type Q, output a single line containing the required area, rounded to exactly three decimals. The area given is allowed to differ by at most $0.001$ from the official solution.", "hint": "Clarification of the third example: The left image below shows the situation before, and the right one after the U-type query, for water level $h = 2$ (query Q 2). In the first image, the submerged area equals $3.75$, and in the second image it is $6$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uxkico56.png)", "locale": "en", "translations": {"en": {"title": "[COCI 2012/2013 #4] AKVARIJ", "background": "", "description": "Mirko has recently installed a new screensaver. If he is away from the keyboard for five minutes, the screen shows a picture of an aquarium with animated fish. The screensaver has settings for customizing the shape of the (virtual, sandy) aquarium bottom, as well as the water level.\n\nThe aquarium can be represented in a 2D Cartesian coordinate system as a shape $N - 1$ columns wide, where $N$ is a positive integer. The left wall of the aquarium has the x-coordinate of $0$, and the right wall has the x-coordinate of $N - 1$. Each integer-valued x-coordinate of the aquarium bottom (let us denote it by $i$) from $0$ to $N - 1$ has a separately adjustable height of $H_i$. Between any two adjacent integer-valued x-coordinates $i$ and $i + 1$, the bottom can be described by a line segment between points $(i, H_i)$ and $(i + 1, H_{i+1})$.\n\nIf the water level is set to $h$, the water fills the area between the line $y = h$ and the aquarium bottom. If a part of the aquarium bottom is above the water level $h$, it forms an island and is not submerged.\n\nFor different shapes of the aquarium bottom, Mirko would like to know the total area of his screen covered by water. Help Mirko find answers to his questions (other than 42).", "inputFormat": "The first line of input contains two positive integers, $N$ ($3 \\leq N \\leq 100\\,000$, the length of the bottom) and $M$ ($1 \\leq M \\leq 100\\,000$, the number of queries).\n\nThe second line of input contains $N$ space-separated nonnegative integers $H_i$ ($0 \\leq H_i \\leq 1000$), the starting bottom heights.\n\nEach of the following $M$ lines contains a single query with one of the following two types:\n\n- Q $h$ – if the water level is set to $h$ ($0 \\leq h \\leq 1000$), assuming the current bottom shape, what is the total screen area covered by water?\n- U $i$ $h$ – Mirko has decided to change the bottom height at x-coordinate $i$ ($0 \\leq i \\leq N - 1$) to $h$ ($0 \\leq h \\leq 1000$); in other words, set $H_i = h$.", "outputFormat": "For each query with type Q, output a single line containing the required area, rounded to exactly three decimals. The area given is allowed to differ by at most $0.001$ from the official solution.", "hint": "Clarification of the third example: The left image below shows the situation before, and the right one after the U-type query, for water level $h = 2$ (query Q 2). In the first image, the submerged area equals $3.75$, and in the second image it is $6$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uxkico56.png)", "locale": "en"}, "zh-CN": {"title": "[COCI 2012/2013 #4] AKVARIJ", "background": "", "description": "Mirko 最近安装了一个新的屏保。如果他离开键盘五分钟，屏幕上就会显示一幅有动画鱼的水族箱图片。这个屏保可以自定义（虚拟的、带沙底的）水族箱底部的形状以及水位高度。\n\n这个水族箱可以用二维直角坐标系来表示，宽度为 $N-1$ 列，其中 $N$ 是正整数。水族箱的左侧壁的 $x$ 坐标为 $0$，右侧壁的 $x$ 坐标为 $N-1$。水族箱底部每一个整数 $x$ 坐标（记为 $i$，$0 \\leq i \\leq N-1$）都有一个可以单独调整的高度 $H_i$。对于任意相邻的整数坐标 $i$ 和 $i+1$，底部由 $(i, H_i)$ 到 $(i+1, H_{i+1})$ 的线段描述。\n\n如果水位设为 $h$，水会填满 $y = h$ 与水族箱底部之间的区域。若某些底部高于水位 $h$，则这些部分会形成“岛屿”，不会被水淹没。\n\n对于不同的水族箱底部形状，Mirko 想知道屏幕上被水覆盖的总面积。请帮 Mirko 解答这个问题（除了 42 以外的答案）。\n", "inputFormat": "第一行输入两个正整数 $N$（$3 \\leq N \\leq 100\\,000$，底部长度）和 $M$（$1 \\leq M \\leq 100\\,000$，询问数量）。\n\n第二行输入 $N$ 个非负整数 $H_i$（$0 \\leq H_i \\leq 1000$），表示初始底部的高度。\n\n接下来的 $M$ 行，每行一个询问，格式如下两种之一：\n\n- Q $h$ —— 若水位为 $h$（$0 \\leq h \\leq 1000$），在当前底部形状下，被水覆盖的总面积是多少？\n- U $i$ $h$ —— Mirko 决定将 $x$ 坐标为 $i$（$0 \\leq i \\leq N-1$）处的底部高度改为 $h$（$0 \\leq h \\leq 1000$），即 $H_i = h$。\n", "outputFormat": "对于每个 Q 类型的询问，输出一行，表示所求面积，四舍五入保留三位小数。答案与官方标准答案的误差不超过 $0.001$ 即可。\n", "hint": "第三个样例的说明：下图左侧是修改前，右侧是 U 类型操作后，水位 $h=2$（Q 2 询问）的情形。左图淹没面积为 $3.75$，右图为 $6$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uxkico56.png)\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13419", "type": "P", "difficulty": 1, "samples": [["WA", "13"], ["UNUCIC", "36"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["字符串", "2012", "枚举", "COCI（克罗地亚）"], "title": "[COCI 2012/2013 #6] BAKA", "background": "", "description": "Mirko's grandma still uses an ancient pulse dial telephone with a rotary dial as shown in the following picture:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/44fn1zm8.png)\n\nFor each digit that we want to dial, we need to turn the rotary dial clockwise until the chosen digit reaches the finger stop (metal fin). Then we let go of the dial and wait for it to return to its original position before we can dial another digit. In our modern, instant gratification world, the dial return often lasts much longer than our patience. More precisely, dialling the digit $1$ takes a total of two seconds, while dialling any larger digit takes an additional second for each additional finger circle counting from $1$ to the dialled digit (as shown in the picture).\n\nMirko's grandma remembers phone numbers by memorizing a corresponding word which, when dialled, results in the correct number being dialled. When dialling a word, for each letter, we dial the digit which has that letter written next to it on the dial (for example, the digit $7$ for the letter S). For example, the word UNUCIC$^{1}$ corresponds to the number $868242$. Your task is determining, for a given word, the total time required to dial that word.\n\n$^{1}$: 'Little grandson' in Croatian.", "inputFormat": "The first and only line of input contains a single word consisting of between $2$ and $15$ (inclusive) uppercase English letters.", "outputFormat": "The first and only line of output must contain the required dialling time.", "hint": "Clarification of the first example: The corresponding phone number is $92$, which needs $10 + 3$ seconds to dial.", "locale": "en", "translations": {"en": {"title": "[COCI 2012/2013 #6] BAKA", "background": "", "description": "Mirko's grandma still uses an ancient pulse dial telephone with a rotary dial as shown in the following picture:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/44fn1zm8.png)\n\nFor each digit that we want to dial, we need to turn the rotary dial clockwise until the chosen digit reaches the finger stop (metal fin). Then we let go of the dial and wait for it to return to its original position before we can dial another digit. In our modern, instant gratification world, the dial return often lasts much longer than our patience. More precisely, dialling the digit $1$ takes a total of two seconds, while dialling any larger digit takes an additional second for each additional finger circle counting from $1$ to the dialled digit (as shown in the picture).\n\nMirko's grandma remembers phone numbers by memorizing a corresponding word which, when dialled, results in the correct number being dialled. When dialling a word, for each letter, we dial the digit which has that letter written next to it on the dial (for example, the digit $7$ for the letter S). For example, the word UNUCIC$^{1}$ corresponds to the number $868242$. Your task is determining, for a given word, the total time required to dial that word.\n\n$^{1}$: 'Little grandson' in Croatian.", "inputFormat": "The first and only line of input contains a single word consisting of between $2$ and $15$ (inclusive) uppercase English letters.", "outputFormat": "The first and only line of output must contain the required dialling time.", "hint": "Clarification of the first example: The corresponding phone number is $92$, which needs $10 + 3$ seconds to dial.", "locale": "en"}, "zh-CN": {"title": "[COCI 2012/2013 #6] BAKA", "background": "", "description": "Mirko 的奶奶至今仍在使用一部古老的脉冲拨号电话机，其拨号盘如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/44fn1zm8.png)\n\n每当我们要拨一个数字时，需要顺时针旋转拨号盘，直到选中的数字到达金属挡片（指停）。然后松开拨号盘，等待其返回原位后，才能拨下一个数字。在我们这个追求即时满足的现代社会里，这个拨号盘的回弹时间往往比我们的耐心还要长。更具体地说，拨数字 $1$ 需要 $2$ 秒，拨更大的数字则每增加一个数字（从 $1$ 到所拨数字），总时间再增加 $1$ 秒（如上图所示）。\n\nMirko 的奶奶通过记忆单词来记住电话号码，每个字母对应拨号盘上写有该字母的数字。例如，字母 S 对应数字 $7$。比如，单词 **UNUCIC**$^{1}$ 对应的号码是 $868242$。你的任务是，对于给定的单词，计算拨完该单词所需的总时间。\n\n$^{1}$：在克罗地亚语中意为“小孙子”。", "inputFormat": "输入的第一行包含一个单词，由 $2$ 到 $15$ 个（含）大写英文字母组成。\n", "outputFormat": "输出一行，表示拨完该单词所需的总时间。", "hint": "第一个样例说明：对应的电话号码为 $92$，拨号总时间为 $10 + 3 = 13$ 秒。\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13420", "type": "P", "difficulty": 2, "samples": [["2\n0 2\n2 0", "1 1"], ["4\n0 3 6 7\n3 0 5 6\n6 5 0 9\n7 6 9 0", "2 1 4 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["模拟", "数学", "2012", "COCI（克罗地亚）"], "title": "[COCI 2012/2013 #6] SUME", "background": "", "description": "Once upon a time, there existed a sequence A consisting of $N$ positive integers. You don't know the sequence itself, but you do know the sum of every two elements of the sequence. Find the sequence $A$!", "inputFormat": "The first line of input contains the positive integer $N$ ($2 \\leq N \\leq 1000$).\n\nEach of the following $N$ lines contains $N$ positive integers smaller than or equal to $100\\,000$, forming the table S. The following relations hold: $S(i, j) = A[i] + A[j]$ for $i \\neq j$, and $S(i, j) = 0$ for $i = j$. Here $S(i, j)$ denotes the number in the $i^{th}$ row and $j^{th}$ column of the table, and $A[i]$ denotes the $i^{th}$ element of the sequence A.\n\nIt is guaranteed that for any input data set there exists a unique sequence of positive integers A with the given properties.", "outputFormat": "The first and only line of output must contain the required sequence A (in the form of $N$ space-separated positive integers).", "hint": "", "locale": "en", "translations": {"en": {"title": "[COCI 2012/2013 #6] SUME", "background": "", "description": "Once upon a time, there existed a sequence A consisting of $N$ positive integers. You don't know the sequence itself, but you do know the sum of every two elements of the sequence. Find the sequence $A$!", "inputFormat": "The first line of input contains the positive integer $N$ ($2 \\leq N \\leq 1000$).\n\nEach of the following $N$ lines contains $N$ positive integers smaller than or equal to $100\\,000$, forming the table S. The following relations hold: $S(i, j) = A[i] + A[j]$ for $i \\neq j$, and $S(i, j) = 0$ for $i = j$. Here $S(i, j)$ denotes the number in the $i^{th}$ row and $j^{th}$ column of the table, and $A[i]$ denotes the $i^{th}$ element of the sequence A.\n\nIt is guaranteed that for any input data set there exists a unique sequence of positive integers A with the given properties.", "outputFormat": "The first and only line of output must contain the required sequence A (in the form of $N$ space-separated positive integers).", "hint": "", "locale": "en"}, "zh-CN": {"title": "[COCI 2012/2013 #6] SUME", "background": "", "description": "很久很久以前，存在一个长度为 $N$ 的正整数序列 $A$。你并不知道这个序列的具体内容，但你知道该序列任意两个元素之和的值。请你求出序列 $A$！\n", "inputFormat": "输入的第一行包含一个正整数 $N$（$2 \\leq N \\leq 1000$）。\n\n接下来的 $N$ 行，每行包含 $N$ 个不超过 $100\\,000$ 的正整数，组成了一个表 $S$。满足以下关系：当 $i \\neq j$ 时，$S(i, j) = A[i] + A[j]$；当 $i = j$ 时，$S(i, j) = 0$。其中 $S(i, j)$ 表示表格第 $i$ 行第 $j$ 列的数，$A[i]$ 表示序列 $A$ 的第 $i$ 个元素。\n\n保证对于任意输入数据，都存在且仅存在一个满足条件的正整数序列 $A$。", "outputFormat": "输出一行，包含所求序列 $A$，以 $N$ 个正整数、空格分隔的形式给出。\n", "hint": "翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13421", "type": "P", "difficulty": 2, "samples": [["2\n1 3", "1"], ["6\n1 2 3 5 7 10", "4"], ["3\n-1 2 0", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["数学", "2012", "枚举", "COCI（克罗地亚）"], "title": "[COCI 2012/2013 #6] DOBRI", "background": "", "description": "You are given a sequence A consisting of $N$ integers (not to be confused with the sequence from the previous task). We will call the $i^{th}$ sequence element good if it equals the sum of some three elements in positions strictly smaller than $i$ (an element can be used more than once in the sum).\n\nHow many good elements does the sequence contain?", "inputFormat": "The first line of input contains the positive integer $N$ ($1 \\leq N \\leq 5000$), the length of the sequence A.\n\nThe second line of input contains $N$ space-separated integers representing the sequence A ($-100\\,000 \\leq A_i \\leq 100\\,000$).", "outputFormat": "The first and only line of output must contain the number of good elements in the sequence.", "hint": "In test data worth at least $40\\%$ of total points, $N \\leq 50$.\n\nIn test data worth at least $70\\%$ of total points, $N \\leq 500$.", "locale": "en", "translations": {"en": {"title": "[COCI 2012/2013 #6] DOBRI", "background": "", "description": "You are given a sequence A consisting of $N$ integers (not to be confused with the sequence from the previous task). We will call the $i^{th}$ sequence element good if it equals the sum of some three elements in positions strictly smaller than $i$ (an element can be used more than once in the sum).\n\nHow many good elements does the sequence contain?", "inputFormat": "The first line of input contains the positive integer $N$ ($1 \\leq N \\leq 5000$), the length of the sequence A.\n\nThe second line of input contains $N$ space-separated integers representing the sequence A ($-100\\,000 \\leq A_i \\leq 100\\,000$).", "outputFormat": "The first and only line of output must contain the number of good elements in the sequence.", "hint": "In test data worth at least $40\\%$ of total points, $N \\leq 50$.\n\nIn test data worth at least $70\\%$ of total points, $N \\leq 500$.", "locale": "en"}, "zh-CN": {"title": "[COCI 2012/2013 #6] DOBRI", "background": "", "description": "给定一个长度为 $N$ 的整数序列 $A$（不要与上一题的序列混淆）。如果第 $i$ 个元素等于序列中编号严格小于 $i$ 的某三个元素之和（同一个元素可以在和中多次使用），我们称第 $i$ 个元素是**好元素**。\n\n请问这个序列中有多少个好元素？", "inputFormat": "第一行输入一个正整数 $N$（$1 \\leq N \\leq 5000$），表示序列 $A$ 的长度。\n\n第二行输入 $N$ 个用空格分隔的整数，表示序列 $A$（$-100\\,000 \\leq A_i \\leq 100\\,000$）。", "outputFormat": "输出一行，表示序列中好元素的个数。", "hint": "在至少 $40\\%$ 分数的测试数据中，$N \\leq 50$。\n\n在至少 $70\\%$ 分数的测试数据中，$N \\leq 500$。\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13422", "type": "P", "difficulty": 2, "samples": [["5\n2 6\n1 6\n0 6\n6 6\n5 6", "2\n6 6 2 0 0"], ["5\n4 5\n2 7\n5 5\n0 10\n7 9", "3\n0 0 0 10 8"], ["8\n2 6\n3 4\n1 1\n9 10\n0 10\n4 5\n6 8\n3 9\n", "5\n0 0 0 9 10 0 0 9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2019", "Special Judge", "排序", "COCI（克罗地亚）"], "title": "[COCI 2019/2020 #4] Pod starim krovovima", "background": "", "description": "Setting: Legendary Zagrebian Inn called Kod Žnidaršića.\n\nTime: The year 1936.\n\nPlot summary: Franjo and his friends are discussing the current events in Abyssinia while enjoying a couple of drinks at the bar. His son, little Perica, is sitting at a small table in the corner of the bar. In front of Perica there are $N$ glasses conveniently numbered from $1$ to $N$. The volume (in nanoliters) of each glass is known as well as the amount of liquid that is currently inside it.\n\nProblem: Little Perica wants to know what is the largest possible number of glasses that can be emptied by pouring the liquid between glasses. He can freely pour any integer number of nanoliters from one glass to another, as many times as he wants, as long as no liquid is spilled over.\n\nYour task is to output the number of empty glasses along with one possible configuration of liquid in all glasses. If there are multiple configurations that yield the same number of empty glasses, output any of them. Note that it is not necessary to minimize the number of times liquid was poured between two glasses.", "inputFormat": "The first line contains an integer $N$ ($1 \\leq N \\leq 1\\,000$) from the task description.\n\nEach of the next $N$ lines contains two integers $T_i$ ($0 \\leq T_i \\leq 10^9$) and $Z_i$ ($1 \\leq Z_i \\leq 10^9$) which, in that order, represent the current amount of liquid in the $i$-th glass and its volume. Both quantities are given in nanoliters and the current amount of liquid cannot be greater than the volume of the glass, i.e. $T_i \\leq Z_i$ holds.", "outputFormat": "In the first line you should output the largest number of glasses that can be emptied by pouring the liquid between glasses.", "hint": "Clarification of the second example: One of the possible pouring configurations is the following:\n1. pour everything from glass 1 into glass 2.\n2. pour everything from glass 2 into glass 4.\n3. pour four nanoliters from glass 3 into glass 4. pour one nanoliter from glass 3 into glass 5.\nGlasses numbered 1, 2 and 3 are now empty.", "locale": "en", "translations": {"en": {"title": "[COCI 2019/2020 #4] Pod starim krovovima", "background": "", "description": "Setting: Legendary Zagrebian Inn called Kod Žnidaršića.\n\nTime: The year 1936.\n\nPlot summary: Franjo and his friends are discussing the current events in Abyssinia while enjoying a couple of drinks at the bar. His son, little Perica, is sitting at a small table in the corner of the bar. In front of Perica there are $N$ glasses conveniently numbered from $1$ to $N$. The volume (in nanoliters) of each glass is known as well as the amount of liquid that is currently inside it.\n\nProblem: Little Perica wants to know what is the largest possible number of glasses that can be emptied by pouring the liquid between glasses. He can freely pour any integer number of nanoliters from one glass to another, as many times as he wants, as long as no liquid is spilled over.\n\nYour task is to output the number of empty glasses along with one possible configuration of liquid in all glasses. If there are multiple configurations that yield the same number of empty glasses, output any of them. Note that it is not necessary to minimize the number of times liquid was poured between two glasses.", "inputFormat": "The first line contains an integer $N$ ($1 \\leq N \\leq 1\\,000$) from the task description.\n\nEach of the next $N$ lines contains two integers $T_i$ ($0 \\leq T_i \\leq 10^9$) and $Z_i$ ($1 \\leq Z_i \\leq 10^9$) which, in that order, represent the current amount of liquid in the $i$-th glass and its volume. Both quantities are given in nanoliters and the current amount of liquid cannot be greater than the volume of the glass, i.e. $T_i \\leq Z_i$ holds.", "outputFormat": "In the first line you should output the largest number of glasses that can be emptied by pouring the liquid between glasses.", "hint": "Clarification of the second example: One of the possible pouring configurations is the following:\n1. pour everything from glass 1 into glass 2.\n2. pour everything from glass 2 into glass 4.\n3. pour four nanoliters from glass 3 into glass 4. pour one nanoliter from glass 3 into glass 5.\nGlasses numbered 1, 2 and 3 are now empty.", "locale": "en"}, "zh-CN": {"title": "[COCI 2019/2020 #4] Pod starim krovovima", "background": "", "description": "背景：传奇的萨格勒布小酒馆 Kod Žnidaršića。\n\n时间：1936 年。\n\n剧情简介：Franjo 和朋友们正在酒吧里一边喝酒一边讨论阿比西尼亚的时事。他的儿子，小 Perica，坐在酒吧角落的一张小桌子旁。在 Perica 面前，有 $N$ 个玻璃杯，编号为 $1$ 到 $N$。每个玻璃杯的容量（单位为纳升）已知，杯中当前的液体量也已知。\n\n问题：小 Perica 想知道，通过在玻璃杯之间相互倒液体，最多能让多少个玻璃杯变空。他可以任意多次将任意整数纳升的液体从一个杯子倒到另一个杯子，只要没有液体溢出即可。\n\n你的任务是输出最多能变空的玻璃杯数量，以及一种可能的所有玻璃杯中液体的分布方案。如果有多种分布方案能达到相同数量的空杯，输出任意一种即可。注意，不要求最小化倒液体的次数。\n", "inputFormat": "第一行包含一个整数 $N$（$1 \\leq N \\leq 1\\,000$），表示玻璃杯的数量。\n\n接下来的 $N$ 行，每行包含两个整数 $T_i$（$0 \\leq T_i \\leq 10^9$）和 $Z_i$（$1 \\leq Z_i \\leq 10^9$），分别表示第 $i$ 个玻璃杯当前的液体量和容量（单位均为纳升）。保证 $T_i \\leq Z_i$。\n", "outputFormat": "第一行输出最多能变空的玻璃杯数量。\n\n第二行输出 $N$ 个整数，表示操作后每个玻璃杯中的液体量（顺序与输入一致）。如果有多种方案，输出任意一种即可。\n", "hint": "对第二个样例的说明：一种可能的倒液体方案如下：\n1. 把第 1 个杯子的液体全部倒入第 2 个杯子。\n2. 把第 2 个杯子的液体全部倒入第 4 个杯子。\n3. 把第 3 个杯子的 4 纳升液体倒入第 4 个杯子，把第 3 个杯子的 1 纳升倒入第 5 个杯子。\n此时，第 1、2、3 号杯子都为空。\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13423", "type": "P", "difficulty": 3, "samples": [["2 1\n5 5", "0 0"], ["6 3\n4 3 12 6 8 2", "0 4 0 0 0 0"], ["5 1\n1 3 5 7 2", "4 1 1 2 0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2019", "枚举", "COCI（克罗地亚）"], "title": "[COCI 2019/2020 #4] Spiderman", "background": "", "description": "Little Ivan likes to play Yamb and read Marvel superhero comics. His favorite superhero is spider-man, a friendly neighbourhood teenager named Peter Parker who got his superpowers via a radioactive spider bite. Ivan fantasizes that one day he will be able to jump from one skyscraper to another, just like spider-man does in the comics. During one such fantasy, he fell asleep.\n\nIn his dream he was no longer named Ivan, his name was Peter Parkour$^{1}$ and, you guessed it, he was able to use his parkour skills to jump between skyscrapers. He quickly realized that there are exactly $N$ skyscrapers in his surroundings and he somehow knew that $i$-th of those skyscrapers is $h_i$ meters tall. He knows that he is able to jump from the $i$-th skyscraper to the $j$-th skyscraper if the remainder when dividing $h_i$ with $h_j$ is equal to $K$. Help Ivan determine, for every skyscraper, the number of other skyscrapers he can jump to.\n", "inputFormat": "The first line contains two integers $N$ ($1 \\leq N \\leq 300\\,000$) and $K$ ($0 \\leq K < 10^6$) from the task description.\n\nThe next line contains $N$ integers $h_i$ ($1 \\leq h_i \\leq 10^6$) from the task description.", "outputFormat": "In a single line you should output $N$ space-separated integers such that the $i$-th of those integers represents the number of different skyscrapers on which Peter Parkour can jump on if he jumps from the $i$-th skyscraper.\n", "hint": "Clarification of the third example:\n- From the first skyscraper of height 1 Peter can jump on any other skyscraper.\n- From the second skyscraper of height 3 Peter can jump only on a skyscraper of height 2.\n- From the third skyscraper of height 5 Peter can jump only on a skyscraper of height 2.\n- From the fourth skyscraper of height 7 Peter can jump on skyscrapers of heights 2 and 3.\n- From the fifth skyscraper of height 2 Peter cannot jump on any other skyscraper.\n\n### Scoring\n\n- In test cases worth a total of $14$ points, it will hold $1 \\leq N \\leq 2\\,000$\n- In test cases worth an additional $14$ points, there will be at most $2\\,000$ skyscrapers of different heights.\n- In test cases worth an additional $14$ points, it will hold $K = 0$.", "locale": "en", "translations": {"en": {"title": "[COCI 2019/2020 #4] Spiderman", "background": "", "description": "Little Ivan likes to play Yamb and read Marvel superhero comics. His favorite superhero is spider-man, a friendly neighbourhood teenager named Peter Parker who got his superpowers via a radioactive spider bite. Ivan fantasizes that one day he will be able to jump from one skyscraper to another, just like spider-man does in the comics. During one such fantasy, he fell asleep.\n\nIn his dream he was no longer named Ivan, his name was Peter Parkour$^{1}$ and, you guessed it, he was able to use his parkour skills to jump between skyscrapers. He quickly realized that there are exactly $N$ skyscrapers in his surroundings and he somehow knew that $i$-th of those skyscrapers is $h_i$ meters tall. He knows that he is able to jump from the $i$-th skyscraper to the $j$-th skyscraper if the remainder when dividing $h_i$ with $h_j$ is equal to $K$. Help Ivan determine, for every skyscraper, the number of other skyscrapers he can jump to.\n", "inputFormat": "The first line contains two integers $N$ ($1 \\leq N \\leq 300\\,000$) and $K$ ($0 \\leq K < 10^6$) from the task description.\n\nThe next line contains $N$ integers $h_i$ ($1 \\leq h_i \\leq 10^6$) from the task description.", "outputFormat": "In a single line you should output $N$ space-separated integers such that the $i$-th of those integers represents the number of different skyscrapers on which Peter Parkour can jump on if he jumps from the $i$-th skyscraper.\n", "hint": "Clarification of the third example:\n- From the first skyscraper of height 1 Peter can jump on any other skyscraper.\n- From the second skyscraper of height 3 Peter can jump only on a skyscraper of height 2.\n- From the third skyscraper of height 5 Peter can jump only on a skyscraper of height 2.\n- From the fourth skyscraper of height 7 Peter can jump on skyscrapers of heights 2 and 3.\n- From the fifth skyscraper of height 2 Peter cannot jump on any other skyscraper.\n\n### Scoring\n\n- In test cases worth a total of $14$ points, it will hold $1 \\leq N \\leq 2\\,000$\n- In test cases worth an additional $14$ points, there will be at most $2\\,000$ skyscrapers of different heights.\n- In test cases worth an additional $14$ points, it will hold $K = 0$.", "locale": "en"}, "zh-CN": {"title": "[COCI 2019/2020 #4] Spiderman", "background": "", "description": "小 Ivan 喜欢玩 Yamb 游戏，也喜欢阅读 Marvel 超级英雄漫画。他最喜欢的超级英雄是蜘蛛侠——那位因被放射性蜘蛛咬伤而获得超能力的邻家少年 Peter Parker。Ivan 总幻想有一天自己也能像漫画里的蜘蛛侠一样，在摩天大楼之间跳来跳去。在一次这样的幻想中，他睡着了。\n\n在梦中，他不再叫 Ivan，而是叫 **Peter Parkour**$^{1}$，你猜对了，他能够利用自己的跑酷技巧在摩天大楼之间跳跃。他很快发现，周围正好有 $N$ 座摩天大楼，并且他莫名其妙地知道第 $i$ 座大楼的高度是 $h_i$ 米。他知道：如果 $h_i \\bmod h_j = K$，他就可以从第 $i$ 座大楼跳到第 $j$ 座大楼。请你帮 Ivan 计算，对于每一座大楼，他能跳到多少其他大楼上。\n\n$^{1}$：“Parkour”意为“跑酷”。", "inputFormat": "第一行输入两个整数 $N$（$1 \\leq N \\leq 300\\,000$）和 $K$（$0 \\leq K < 10^6$）。\n\n第二行输入 $N$ 个整数 $h_i$（$1 \\leq h_i \\leq 10^6$），表示每座大楼的高度。", "outputFormat": "输出一行，包含 $N$ 个用空格分隔的整数，第 $i$ 个数表示 Peter Parkour 从第 $i$ 座大楼出发，可以跳到多少其他大楼上。\n", "hint": "对第三个样例的说明：\n- 从高度为 $1$ 的大楼出发，可以跳到任意其他大楼。\n- 从高度为 $3$ 的大楼出发，只能跳到高度为 $2$ 的大楼。\n- 从高度为 $5$ 的大楼出发，只能跳到高度为 $2$ 的大楼。\n- 从高度为 $7$ 的大楼出发，可以跳到高度为 $2$ 和 $3$ 的大楼。\n- 从高度为 $2$ 的大楼出发，无法跳到任何其他大楼。\n\n### 评分说明\n\n- 在价值 $14$ 分的测试点中，$1 \\leq N \\leq 2\\,000$。\n- 在额外 $14$ 分的测试点中，不同高度的大楼数量不超过 $2\\,000$。\n- 在额外 $14$ 分的测试点中，$K = 0$。\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13424", "type": "P", "difficulty": 2, "samples": [["6 6\n..>>>v\n.o^..v\n.v.<.v\n.>>^.v\n.x<<<<\n......", ":)\nE"], ["5 5\nv<<<<\n>v.>^\nv<.o.\n>>v>v\n..>>x", ":)\nS"], ["3 3\nx>.\n.o^\n^<.", ":("]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2020", "枚举", "COCI（克罗地亚）"], "title": "[COCI 2020/2021 #1] Patkice", "background": "", "description": "Not so long ago, in a distant tropical land, there lived three rubber ducks. One hot summer day while they were lying on the beach, the ducks decided to travel to a nearby island. Since the ducks like adventures, they decided to travel carried by ocean currents in an old black umbrella.\n\nSince the ducks are experienced ocean explorers, before the voyage they will check out a map of ocean currents. On the map, the island where the ducks live is marked by a letter 'o'. The ducks can start their voyage in any of the four directions: north - $N$, east - $E$, west - $W$ and south - $S$.\n\nOcean currents in these seas move in one of the four directions, and are marked on the map in the following way: west-east '<', east-west '>', north-south 'v' and south-north '^'. When the ducks are located on a cell with a current, they will move one cell in the direction of the current. Ocean currents in these seas are special, as they never lead outside of the map and they don't form vortexes (places where the ducks would move in circles if they followed the current).\n\nCalm sea is marked by a dot '.'. If the currents bring the ducks to a cell with calm sea or back to the starting island, they won't be able to continue the voyage. The island that the ducks want to visit is marked by a letter 'x'.\n\nThe ducks don't want to stop their beach party. They kindly ask you to tell them if it's possible for them to get to the other island, and if it is, in which direction should they start their voyage. Since one of the ducks gets very seasick, they ask you to choose the direction that will make the voyage as short as possible. If there are multiple directions that yield the same minimal travel time, you should choose the one that is alphabetically first.", "inputFormat": "The first line contains integers $r$ and $s$ ($3 \\leq r, s \\leq 100$), the number of rows and columns of the map.\n\nEach of the next $r$ lines contains $s$ characters from the set 'o<>v^\\.x', that represent the map of ocean currents. There will always be exactly one character 'o' and exactly one character 'x' on the map. The character 'o' will never be located in the first or last row nor column.\n\n", "outputFormat": "If the ducks can't reach the other island, print :(. \n\nOtherwise, print :) in the first line. In the second line, print the start direction (N for north, E for east, W for west or S for south).\n\n", "hint": "Clarification of the first two examples:\n\n- In the first example, if the ducks start their voyage in any direction but east, they will end up in calm sea and won’t reach the other island.\n- In the second example, the ducks will reach the other island if they start by going north or south. They choose the south way, since it’s shorter.\n\n### Scoring\n\nIn test cases worth $30$ points the valid start direction will be unique if it exists.", "locale": "en", "translations": {"en": {"title": "[COCI 2020/2021 #1] Patkice", "background": "", "description": "Not so long ago, in a distant tropical land, there lived three rubber ducks. One hot summer day while they were lying on the beach, the ducks decided to travel to a nearby island. Since the ducks like adventures, they decided to travel carried by ocean currents in an old black umbrella.\n\nSince the ducks are experienced ocean explorers, before the voyage they will check out a map of ocean currents. On the map, the island where the ducks live is marked by a letter 'o'. The ducks can start their voyage in any of the four directions: north - $N$, east - $E$, west - $W$ and south - $S$.\n\nOcean currents in these seas move in one of the four directions, and are marked on the map in the following way: west-east '<', east-west '>', north-south 'v' and south-north '^'. When the ducks are located on a cell with a current, they will move one cell in the direction of the current. Ocean currents in these seas are special, as they never lead outside of the map and they don't form vortexes (places where the ducks would move in circles if they followed the current).\n\nCalm sea is marked by a dot '.'. If the currents bring the ducks to a cell with calm sea or back to the starting island, they won't be able to continue the voyage. The island that the ducks want to visit is marked by a letter 'x'.\n\nThe ducks don't want to stop their beach party. They kindly ask you to tell them if it's possible for them to get to the other island, and if it is, in which direction should they start their voyage. Since one of the ducks gets very seasick, they ask you to choose the direction that will make the voyage as short as possible. If there are multiple directions that yield the same minimal travel time, you should choose the one that is alphabetically first.", "inputFormat": "The first line contains integers $r$ and $s$ ($3 \\leq r, s \\leq 100$), the number of rows and columns of the map.\n\nEach of the next $r$ lines contains $s$ characters from the set 'o<>v^\\.x', that represent the map of ocean currents. There will always be exactly one character 'o' and exactly one character 'x' on the map. The character 'o' will never be located in the first or last row nor column.\n\n", "outputFormat": "If the ducks can't reach the other island, print :(. \n\nOtherwise, print :) in the first line. In the second line, print the start direction (N for north, E for east, W for west or S for south).\n\n", "hint": "Clarification of the first two examples:\n\n- In the first example, if the ducks start their voyage in any direction but east, they will end up in calm sea and won’t reach the other island.\n- In the second example, the ducks will reach the other island if they start by going north or south. They choose the south way, since it’s shorter.\n\n### Scoring\n\nIn test cases worth $30$ points the valid start direction will be unique if it exists.", "locale": "en"}, "zh-CN": {"title": "[COCI 2020/2021 #1] Patkice", "background": "", "description": "不久前，在一个遥远的热带国度，住着三只橡皮鸭。炎炎夏日，当它们在沙滩上休憩时，决定乘着一把黑色的旧雨伞，顺着洋流去附近的一个小岛冒险。\n\n由于这几只鸭子都是经验丰富的海洋探险家，出发前它们会先查看一张洋流地图。地图上，鸭子们所在的岛屿用字母 'o' 标记。它们可以选择朝四个方向之一出发：北（N）、东（E）、西（W）、南（S）。\n\n海域中的洋流总是朝某一个方向流动，在地图上用如下符号表示：西向东用 '<'，东向西用 '>'，北向南用 'v'，南向北用 '^'。当鸭子们处于有洋流的格子上时，会被洋流带到下一个格子，方向与洋流一致。这片海域的洋流有个特点：不会把鸭子带出地图边界，也不会形成漩涡（即不会让鸭子陷入循环）。\n\n风平浪静的海面用 '.' 表示。如果鸭子们被洋流带到平静的海面，或者回到了起始岛屿，它们就无法继续航行。鸭子们要去的目标小岛用字母 'x' 标记。\n\n鸭子们可不想耽误沙滩派对，于是请求你帮忙判断：它们是否有可能到达目标小岛？如果可以，应该从哪个方向出发？由于其中一只鸭子容易晕船，请你选择能让航程最短的方向。如果有多个方向航程相同，请选择字典序最小的那个方向。\n", "inputFormat": "第一行输入两个整数 $r$ 和 $s$（$3 \\leq r, s \\leq 100$），表示地图的行数和列数。\n\n接下来 $r$ 行，每行 $s$ 个字符，字符集为 'o<>v^\\.x'，表示洋流地图。地图上恰好有一个 'o' 和一个 'x'。'o' 不会出现在第一行、最后一行、第一列或最后一列。\n", "outputFormat": "如果鸭子们无法到达目标小岛，输出一行 :(。\n\n否则，第一行输出 :)，第二行输出出发方向（N、E、W、S）。", "hint": "对前两个样例的说明：\n\n- 第一个样例中，只有朝东（E）出发才能到达目标岛屿，其他方向都会停在风平浪静的海面上。\n- 第二个样例中，朝北或朝南出发都能到达目标岛屿，但南（S）方向更短，应选择南。\n\n### 评分\n\n在价值 $30$ 分的测试点中，若存在合法出发方向，则唯一。\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13425", "type": "P", "difficulty": 3, "samples": [["2 2\nwa\nac", "-1"], ["7 7\nmonolog\nnogolom", "10"], ["14 5\nniskoobrazovan\nboook", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "动态规划 DP", "2020", "深度优先搜索 DFS", "记忆化搜索", "COCI（克罗地亚）"], "title": "[COCI 2020/2021 #1] Bajka", "background": "", "description": "Little Fabijan got bored with picture books, so he decided to read his first fairytale. Unfortunately, Fabijan often encounters a word that scares him. To overcome his fear, he will play a game he invented.\n\nThe scary word can be represented as an array of $n$ lowercase letters. To start the game, Fabijan puts his finger on some position of the array and writes the letter from that position on a piece of paper. He then performs one of the following moves an arbitrary number of times:\n\n- He moves the finger to a position that is one place to the left or to the right of the current position, if that position exists. Also, Fabijan will then write the letter from the new position on the paper, after the last written letter.\n- He moves the finger to any position with the same letter as the current one. Fabijan will not write anything on the paper in this case.\n\nIt takes him $|x - y|$ seconds to move the finger from position $x$ to position $y$.\n\nFabijan will overcome his fear of the word if, at the end of the game, his favourite word is written on the paper. He wants to finish the fairytale as soon as possible, so he asks you to tell him the minimum number of seconds it will take him to overcome his fear of the given scary word.", "inputFormat": "The first line contains integers $n$ and $m$ ($1 \\leq n, m \\leq 300$).\n\nThe second line contains $n$ lowercase letters, the word that scares Fabijan.\n\nThe third line contains $m$ lowercase letters, Fabijan's favourite word.", "outputFormat": "Print the shortest possible time in seconds Fabijan needs to write his favourite word on the paper, or $-1$ if that is not possible.", "hint": "Clarification of the third example:\n\nFabijan will first put his finger on position 7 and write down the letter 'b'. He will then move the finger two times to the left, and each time write down the letter 'o'. In the next step, he will move the finger to position 6 using the second type of move. Finally, he will again move the finger two times to the left, and write down the letters 'o' and 'k'. It took him five seconds in total, one second per move.\n\n### Scoring\n\nIn test cases worth $20$ points, letters in the word that scares Fabijan will be pairwise distinct.", "locale": "en", "translations": {"en": {"title": "[COCI 2020/2021 #1] Bajka", "background": "", "description": "Little Fabijan got bored with picture books, so he decided to read his first fairytale. Unfortunately, Fabijan often encounters a word that scares him. To overcome his fear, he will play a game he invented.\n\nThe scary word can be represented as an array of $n$ lowercase letters. To start the game, Fabijan puts his finger on some position of the array and writes the letter from that position on a piece of paper. He then performs one of the following moves an arbitrary number of times:\n\n- He moves the finger to a position that is one place to the left or to the right of the current position, if that position exists. Also, Fabijan will then write the letter from the new position on the paper, after the last written letter.\n- He moves the finger to any position with the same letter as the current one. Fabijan will not write anything on the paper in this case.\n\nIt takes him $|x - y|$ seconds to move the finger from position $x$ to position $y$.\n\nFabijan will overcome his fear of the word if, at the end of the game, his favourite word is written on the paper. He wants to finish the fairytale as soon as possible, so he asks you to tell him the minimum number of seconds it will take him to overcome his fear of the given scary word.", "inputFormat": "The first line contains integers $n$ and $m$ ($1 \\leq n, m \\leq 300$).\n\nThe second line contains $n$ lowercase letters, the word that scares Fabijan.\n\nThe third line contains $m$ lowercase letters, Fabijan's favourite word.", "outputFormat": "Print the shortest possible time in seconds Fabijan needs to write his favourite word on the paper, or $-1$ if that is not possible.", "hint": "Clarification of the third example:\n\nFabijan will first put his finger on position 7 and write down the letter 'b'. He will then move the finger two times to the left, and each time write down the letter 'o'. In the next step, he will move the finger to position 6 using the second type of move. Finally, he will again move the finger two times to the left, and write down the letters 'o' and 'k'. It took him five seconds in total, one second per move.\n\n### Scoring\n\nIn test cases worth $20$ points, letters in the word that scares Fabijan will be pairwise distinct.", "locale": "en"}, "zh-CN": {"title": "[COCI 2020/2021 #1] Bajka", "background": "", "description": "小 Fabijan 看腻了图画书，于是他决定读他的第一本童话故事。不幸的是，Fabijan 经常遇到一个让他害怕的单词。为了克服恐惧，他发明了一个小游戏。\n\n这个可怕的单词可以表示为一个长度为 $n$ 的小写字母数组。游戏开始时，Fabijan 将手指放在数组的某个位置，并把该位置的字母写在纸上。随后，他可以任意次数地执行以下两种操作中的一种：\n\n- 他可以将手指移动到当前左边或右边相邻的位置（如果该位置存在），并把新位置上的字母写在纸上，写在最后一个字母之后。\n- 他可以将手指移动到任意一个与当前位置字母相同的位置。在这种情况下，Fabijan 不会在纸上写任何字母。\n\n从位置 $x$ 移动到位置 $y$ 需要 $|x-y|$ 秒。\n\n如果游戏结束时，纸上写下了他最喜欢的单词，那么 Fabijan 就能克服对这个单词的恐惧。他希望尽快完成童话故事，因此请你告诉他，最少需要多少秒才能在纸上写下他最喜欢的单词。\n", "inputFormat": "第一行输入两个整数 $n$ 和 $m$（$1 \\leq n, m \\leq 300$）。\n\n第二行输入一个长度为 $n$ 的小写字母串，表示让 Fabijan 害怕的单词。\n\n第三行输入一个长度为 $m$ 的小写字母串，表示 Fabijan 最喜欢的单词。", "outputFormat": "输出 Fabijan 最快能在纸上写下他最喜欢的单词所需的最短时间（秒数）。如果无法完成，输出 $-1$。\n", "hint": "第三个样例说明：\n\nFabijan 首先将手指放在第 $7$ 个位置，并写下字母 'b'。接着，他向左移动两次，每次都写下字母 'o'。下一步，他用第二种操作将手指移动到第 $6$ 个位置。最后，他再向左移动两次，分别写下字母 'o' 和 'k'。总共用了 $5$ 秒，每次移动耗时 $1$ 秒。\n\n### 评分\n\n在价值 $20$ 分的测试数据中，让 Fabijan 害怕的单词中的字母两两不同。\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13426", "type": "P", "difficulty": 2, "samples": [["7\n++---==", "./\\....\n/..\\...\n....\\__"], ["5\n+=+=+", "..._/\n._/..\n/...."], ["4\n--=+", "\\...\n.\\_/"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "字符串", "2020", "COCI（克罗地亚）"], "title": "[COCI 2020/2021 #2] Crtanje", "background": "", "description": "Josip used to code in Logo. He loved to draw pictures, but those days are sadly over. Nostalgic, he decided to draw a line that represents the net worth of his company over a period of $n$ days.\n\nFor each of the $n$ days, he knows if the net worth of his company increased by one unit (represented by '+'), decreased by one unit (represented by '-'), or remained the same (represented by '=') during that day. Before the first day, the net worth was equal to zero.\n\nJosip will draw the line in a big infinite matrix of characters. Indices of matrix rows grow upwards, and indices of columns grow to the right. For the $i$-th day he will draw some character in the $i$-th column. The character and the index of the row are decided by the following rules:\n\n- If the net worth increased during the $i$-th day, he will draw '/' in the row with index equal to the net worth at the beginning of the day.\n- If the net worth decreased during the $i$-th day, he will draw '\\\\' in the row with index equal to the net worth at the end of the day.\n- If the net worth didn't change during the $i$-th day, he will draw '_' in the row with index equal to the net worth during the day.\n\nAll other cells are filled with '.'.\n\nYour task is to output the minimal matrix that contains the whole line, i.e. contains all characters '/', '\\\\' and '_' that Josip drew.", "inputFormat": "The first line contains an integer $n$ ($1 \\leq n \\leq 100$), the number of days.\n\nThe second line contains a string of $n$ characters '+', '-' and '=' that represents how the company's net worth changed over the given period.", "outputFormat": "Output the described matrix.", "hint": "In test cases worth $20$ points the input won't contain the character '-'.", "locale": "en", "translations": {"en": {"title": "[COCI 2020/2021 #2] Crtanje", "background": "", "description": "Josip used to code in Logo. He loved to draw pictures, but those days are sadly over. Nostalgic, he decided to draw a line that represents the net worth of his company over a period of $n$ days.\n\nFor each of the $n$ days, he knows if the net worth of his company increased by one unit (represented by '+'), decreased by one unit (represented by '-'), or remained the same (represented by '=') during that day. Before the first day, the net worth was equal to zero.\n\nJosip will draw the line in a big infinite matrix of characters. Indices of matrix rows grow upwards, and indices of columns grow to the right. For the $i$-th day he will draw some character in the $i$-th column. The character and the index of the row are decided by the following rules:\n\n- If the net worth increased during the $i$-th day, he will draw '/' in the row with index equal to the net worth at the beginning of the day.\n- If the net worth decreased during the $i$-th day, he will draw '\\\\' in the row with index equal to the net worth at the end of the day.\n- If the net worth didn't change during the $i$-th day, he will draw '_' in the row with index equal to the net worth during the day.\n\nAll other cells are filled with '.'.\n\nYour task is to output the minimal matrix that contains the whole line, i.e. contains all characters '/', '\\\\' and '_' that Josip drew.", "inputFormat": "The first line contains an integer $n$ ($1 \\leq n \\leq 100$), the number of days.\n\nThe second line contains a string of $n$ characters '+', '-' and '=' that represents how the company's net worth changed over the given period.", "outputFormat": "Output the described matrix.", "hint": "In test cases worth $20$ points the input won't contain the character '-'.", "locale": "en"}, "zh-CN": {"title": "[COCI 2020/2021 #2] Crtanje", "background": "", "description": "Josip 以前经常用 Logo 语言编程。他喜欢画图，但那段日子已经一去不复返了。怀旧之情涌上心头，他决定画一条曲线，表示他公司在 $n$ 天内的净资产变化。\n\n对于这 $n$ 天的每一天，他都知道公司净资产是增加了 $1$ 单位（用 '+' 表示）、减少了 $1$ 单位（用 '-' 表示），还是保持不变（用 '=' 表示）。在第一天之前，公司的净资产为 $0$。\n\nJosip 会在一个无限大的字符矩阵中画这条曲线。矩阵的行索引向上递增，列索引向右递增。对于第 $i$ 天，他会在第 $i$ 列画一个字符。字符和所在行的索引由以下规则决定：\n\n- 如果第 $i$ 天净资产增加，他会在净资产为当天开始时的行画上字符 '/'。\n- 如果第 $i$ 天净资产减少，他会在净资产为当天结束时的行画上字符 '\\\\'。\n- 如果第 $i$ 天净资产未变，他会在净资产为当天的行画上字符 '_'。\n\n所有其他位置都填充为 '.'。\n\n你的任务是输出包含整条曲线的最小矩阵，也就是说，输出的矩阵应包含 Josip 画下的所有 '/', '\\\\' 和 '_' 字符。\n", "inputFormat": "第一行输入一个整数 $n$（$1 \\leq n \\leq 100$），表示天数。\n\n第二行输入一个长度为 $n$ 的字符串，仅包含字符 '+'、'-' 和 '='，表示公司净资产的每日变化。\n", "outputFormat": "输出符合描述的矩阵。", "hint": "在价值 $20$ 分的测试数据中，输入不会包含字符 '-'。\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13427", "type": "P", "difficulty": 3, "samples": [["2\n1 1\n2 2", "0.7071068"], ["7\n2 3\n3 4\n4 5\n0 1\n3 1\n4 2\n1 5", "1.4142135"], ["4\n2020 20\n20 2020\n2020 2020\n20 20", "1000.0000000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "二分", "并查集", "Special Judge", "生成树", "连通块", "COCI（克罗地亚）"], "title": "[COCI 2020/2021 #2] Odasiljaci", "background": "", "description": "Sadly, this is the last time Sean will play James Bond.\n\nHis mission is to network $n$ antennas that are scattered across a vast desert, which can be represented as a 2D plane. He will set the transmission radius of each antenna to be the same non negative real number $r$. The range of an antenna is defined as the set of all points whose distance to the antenna is at most $r$. If ranges of two antennas have a common point, those antennas can directly communicate. Also, if antennas $A$ and $B$ can communicate, as well as antennas $B$ and $C$, then antennas $A$ and $C$ are also able to communicate, through antenna $B$.\n\nSean wants to network the antennas, i.e. make possible for every two antennas to communicate. Since $M$ has limited his spending for this mission, and larger radii require more money, Sean will choose the smallest possible radius $r$. Help him solve this problem!", "inputFormat": "The first line contains an integer $n$ ($1 \\leq n \\leq 1000$), the number of antennas.\n\nEach of the following $n$ lines contains integers $x_i$ and $y_i$ ($0 \\leq x_i, y_i \\leq 10^9$), coordinates of the $i$-th antenna.", "outputFormat": "Output the minimal radius.\n\nYour answer will be considered correct if its absolute or relative error doesn't exceed $10^{-6}$.", "hint": "Clarification of the second example:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dxxoyzwk.png)", "locale": "en", "translations": {"en": {"title": "[COCI 2020/2021 #2] Odasiljaci", "background": "", "description": "Sadly, this is the last time Sean will play James Bond.\n\nHis mission is to network $n$ antennas that are scattered across a vast desert, which can be represented as a 2D plane. He will set the transmission radius of each antenna to be the same non negative real number $r$. The range of an antenna is defined as the set of all points whose distance to the antenna is at most $r$. If ranges of two antennas have a common point, those antennas can directly communicate. Also, if antennas $A$ and $B$ can communicate, as well as antennas $B$ and $C$, then antennas $A$ and $C$ are also able to communicate, through antenna $B$.\n\nSean wants to network the antennas, i.e. make possible for every two antennas to communicate. Since $M$ has limited his spending for this mission, and larger radii require more money, Sean will choose the smallest possible radius $r$. Help him solve this problem!", "inputFormat": "The first line contains an integer $n$ ($1 \\leq n \\leq 1000$), the number of antennas.\n\nEach of the following $n$ lines contains integers $x_i$ and $y_i$ ($0 \\leq x_i, y_i \\leq 10^9$), coordinates of the $i$-th antenna.", "outputFormat": "Output the minimal radius.\n\nYour answer will be considered correct if its absolute or relative error doesn't exceed $10^{-6}$.", "hint": "Clarification of the second example:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dxxoyzwk.png)", "locale": "en"}, "zh-CN": {"title": "[COCI 2020/2021 #2] Odasiljaci", "background": "", "description": "遗憾的是，这将是 Sean 最后一次扮演 James Bond。\n\n他的任务是在一片广阔的沙漠中组网 $n$ 个分散的天线。这片沙漠可以看作一个二维平面。Sean 会将每个天线的发射半径都设置为同一个非负实数 $r$。天线的覆盖范围被定义为：到该天线的距离不超过 $r$ 的所有点的集合。如果两个天线的覆盖范围有公共点，则这两个天线可以直接通信。此外，如果天线 $A$ 能与 $B$ 通信，$B$ 能与 $C$ 通信，那么 $A$ 也可以通过 $B$ 与 $C$ 通信。\n\nSean 想要让所有天线连成一个网络，即使任意两个天线都可以通信。由于 $M$ 限制了他的花费，而更大的半径意味着更高的成本，Sean 会选择尽可能小的半径 $r$。请你帮他解决这个问题！\n", "inputFormat": "第一行输入一个整数 $n$（$1 \\leq n \\leq 1000$），表示天线的数量。\n\n接下来的 $n$ 行，每行输入两个整数 $x_i$ 和 $y_i$（$0 \\leq x_i, y_i \\leq 10^9$），表示第 $i$ 个天线的坐标。\n", "outputFormat": "输出最小所需半径 $r$。\n\n只要你的答案的绝对误差或相对误差不超过 $10^{-6}$，就会被视为正确。\n", "hint": "第二个样例的示意图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dxxoyzwk.png)\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13428", "type": "P", "difficulty": 2, "samples": [["3 5 4\nabc\nbca\ndac\ndbc\ncba\n(ab)(bc)(ca)\nabc\n(abc)(abc)(abc)\n(zyx)bc", "Case #1: 2\nCase #2: 1\nCase #3: 3\nCase #4: 0"]], "limits": {"time": [2000, 2000], "memory": [1048576, 1048576]}, "tags": ["模拟", "2009", "Google Code Jam"], "title": "[GCJ 2009 Qualification] Alien Language", "background": "", "description": "After years of study, scientists at Google Labs have discovered an alien language transmitted from a faraway planet. The alien language is very unique in that every word consists of exactly $L$ lowercase letters. Also, there are exactly $D$ words in this language.\n\nOnce the dictionary of all the words in the alien language was built, the next breakthrough was to discover that the aliens have been transmitting messages to Earth for the past decade. Unfortunately, these signals are weakened due to the distance between our two planets and some of the words may be misinterpreted. In order to help them decipher these messages, the scientists have asked you to devise an algorithm that will determine the number of possible interpretations for a given pattern.\n\nA pattern consists of exactly $L$ tokens. Each token is either a single lowercase letter (the scientists are very sure that this is the letter) or a group of unique lowercase letters surrounded by parenthesis ( and ). For example: (ab)d(dc) means the first letter is either a or b, the second letter is definitely d and the last letter is either d or c. Therefore, the pattern (ab)d(dc) can stand for either one of these 4 possibilities: add, adc, bdd, bdc.\n", "inputFormat": "The first line of input contains 3 integers, $L$, $D$ and $N$ separated by a space. $D$ lines follow, each containing one word of length $L$. These are the words that are known to exist in the alien language. $N$ test cases then follow, each on its own line and each consisting of a pattern as described above. You may assume that all known words provided are unique.\n", "outputFormat": "For each test case, output\n\nCase #$X$: $K$\n\nwhere $X$ is the test case number, starting from 1, and $K$ indicates how many words in the alien language match the pattern.", "hint": "**Limits**\n\n**Small dataset(10 Pts)**\n\n- $1 \\leq L \\leq 10$\n- $1 \\leq D \\leq 25$\n- $1 \\leq N \\leq 10$\n\n**Large dataset(23 Pts)**\n\n- $1 \\leq L \\leq 15$\n- $1 \\leq D \\leq 5000$\n- $1 \\leq N \\leq 500$", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 Qualification] Alien Language", "background": "", "description": "After years of study, scientists at Google Labs have discovered an alien language transmitted from a faraway planet. The alien language is very unique in that every word consists of exactly $L$ lowercase letters. Also, there are exactly $D$ words in this language.\n\nOnce the dictionary of all the words in the alien language was built, the next breakthrough was to discover that the aliens have been transmitting messages to Earth for the past decade. Unfortunately, these signals are weakened due to the distance between our two planets and some of the words may be misinterpreted. In order to help them decipher these messages, the scientists have asked you to devise an algorithm that will determine the number of possible interpretations for a given pattern.\n\nA pattern consists of exactly $L$ tokens. Each token is either a single lowercase letter (the scientists are very sure that this is the letter) or a group of unique lowercase letters surrounded by parenthesis ( and ). For example: (ab)d(dc) means the first letter is either a or b, the second letter is definitely d and the last letter is either d or c. Therefore, the pattern (ab)d(dc) can stand for either one of these 4 possibilities: add, adc, bdd, bdc.\n", "inputFormat": "The first line of input contains 3 integers, $L$, $D$ and $N$ separated by a space. $D$ lines follow, each containing one word of length $L$. These are the words that are known to exist in the alien language. $N$ test cases then follow, each on its own line and each consisting of a pattern as described above. You may assume that all known words provided are unique.\n", "outputFormat": "For each test case, output\n\nCase #$X$: $K$\n\nwhere $X$ is the test case number, starting from 1, and $K$ indicates how many words in the alien language match the pattern.", "hint": "**Limits**\n\n**Small dataset(10 Pts)**\n\n- $1 \\leq L \\leq 10$\n- $1 \\leq D \\leq 25$\n- $1 \\leq N \\leq 10$\n\n**Large dataset(23 Pts)**\n\n- $1 \\leq L \\leq 15$\n- $1 \\leq D \\leq 5000$\n- $1 \\leq N \\leq 500$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 Qualification] Alien Language", "background": "", "description": "经过多年的研究，Google Labs 的科学家们发现了一种来自遥远星球的外星语言。这种外星语言非常独特，每个单词恰好由 $L$ 个小写字母组成。此外，这种语言中恰好有 $D$ 个单词。\n\n在建立了该外星语言所有单词的字典后，科学家们的下一个重大突破是发现，外星人在过去十年间一直在向地球发送信息。不幸的是，由于两颗星球之间的距离遥远，这些信号在传输过程中被削弱，导致部分单词可能被误解。为了帮助科学家们解读这些信息，他们请你设计一个算法，能够判断给定模式下可能的解释数量。\n\n一个模式恰好由 $L$ 个**符号**组成。每个符号要么是一个小写字母（科学家们非常确定这就是那个字母），要么是由圆括号括起来的一组互不相同的小写字母。例如：(ab)d(dc) 表示第一个字母可以是 a 或 b，第二个字母一定是 d，第三个字母可以是 d 或 c。因此，模式 (ab)d(dc) 可能代表以下 4 种情况之一：add、adc、bdd、bdc。\n", "inputFormat": "输入的第一行包含 3 个整数 $L$、$D$ 和 $N$，以空格分隔。接下来的 $D$ 行，每行一个长度为 $L$ 的单词，表示该外星语言已知的单词。所有已知单词保证互不相同。接下来有 $N$ 个测试用例，每个测试用例一行，均为如上描述的模式。\n", "outputFormat": "对于每个测试用例，输出\n\nCase #$X$: $K$\n\n其中 $X$ 表示测试用例编号（从 1 开始），$K$ 表示有多少个外星语言中的单词与该模式匹配。", "hint": "**限制条件**\n\n**小数据集（10 分）**\n\n- $1 \\leq L \\leq 10$\n- $1 \\leq D \\leq 25$\n- $1 \\leq N \\leq 10$\n\n**大数据集（23 分）**\n\n- $1 \\leq L \\leq 15$\n- $1 \\leq D \\leq 5000$\n- $1 \\leq N \\leq 500$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13429", "type": "P", "difficulty": 2, "samples": [["4\n3 3\n9 6 3\n5 9 6\n3 5 9\n1 10\n0 1 2 3 4 5 6 7 8 7\n2 3\n7 6 7\n7 6 7\n5 5\n1 2 3 4 5\n2 9 3 9 6\n3 3 0 8 7\n4 9 8 9 8\n5 6 7 8 9", "Case #1:\na b b\na a b\na a a\nCase #2:\na a a a a a a a a b\nCase #3:\na a a\nb b b\nCase #4:\na a a a a\na a b b a\na b b b a\na b b b a\na a a a a"]], "limits": {"time": [2000, 3000], "memory": [1048576, 1048576]}, "tags": ["模拟", "搜索", "2009", "Google Code Jam"], "title": "[GCJ 2009 Qualification] Watersheds", "background": "", "description": "Geologists sometimes divide an area of land into different regions based on where rainfall flows down to. These regions are called drainage basins.\n\nGiven an elevation map (a 2-dimensional array of altitudes), label the map such that locations in the same drainage basin have the same label, subject to the following rules.\n\n- From each cell, water flows down to at most one of its 4 neighboring cells.\n- For each cell, if none of its 4 neighboring cells has a lower altitude than the current cell's, then the water does not flow, and the current cell is called a sink.\n- Otherwise, water flows from the current cell to the neighbor with the lowest altitude.\n- In case of a tie, water will choose the first direction with the lowest altitude from this list: North, West, East, South.\n\nEvery cell that drains directly or indirectly to the same sink is part of the same drainage basin. Each basin is labeled by a unique lower-case letter, in such a way that, when the rows of the map are concatenated from top to bottom, the resulting string is lexicographically smallest. (In particular, the basin of the most North-Western cell is always labeled 'a'.)", "inputFormat": "The first line of the input file will contain the number of maps, $T$. $T$ maps will follow, each starting with two integers on a line -- $H$ and $W$ -- the height and width of the map, in cells. The next $H$ lines will each contain a row of the map, from north to south, each containing $W$ integers, from west to east, specifying the altitudes of the cells.\n", "outputFormat": "For each test case, output $1 + H$ lines. The first line must be of the form\n\nCase #$X$:\n\nwhere $X$ is the test case number, starting from 1. The next $H$ lines must list the basin labels for each of the cells, in the same order as they appear in the input.", "hint": "**Sample Explanation**\n\nIn Case #1, the upper-right and lower-left corners are sinks. Water from the diagonal flows towards the lower-left because of the lower altitude (5 versus 6).\n\n**Limits**\n\n- $T \\leq 100$\n\n**Small dataset(10 Pts)**\n\n- Time limit: ~~25~~ 2 seconds.\n- $1 \\leq H, W \\leq 10$;\n- $0 \\leq \\text{altitudes} < 10$;\n- There will be at most two basins.\n\n**Large dataset(23 Pts)**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leq H, W \\leq 100$;\n- $0 \\leq \\text{altitudes} < 10,000$.\n- There will be at most 26 basins.", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 Qualification] Watersheds", "background": "", "description": "Geologists sometimes divide an area of land into different regions based on where rainfall flows down to. These regions are called drainage basins.\n\nGiven an elevation map (a 2-dimensional array of altitudes), label the map such that locations in the same drainage basin have the same label, subject to the following rules.\n\n- From each cell, water flows down to at most one of its 4 neighboring cells.\n- For each cell, if none of its 4 neighboring cells has a lower altitude than the current cell's, then the water does not flow, and the current cell is called a sink.\n- Otherwise, water flows from the current cell to the neighbor with the lowest altitude.\n- In case of a tie, water will choose the first direction with the lowest altitude from this list: North, West, East, South.\n\nEvery cell that drains directly or indirectly to the same sink is part of the same drainage basin. Each basin is labeled by a unique lower-case letter, in such a way that, when the rows of the map are concatenated from top to bottom, the resulting string is lexicographically smallest. (In particular, the basin of the most North-Western cell is always labeled 'a'.)", "inputFormat": "The first line of the input file will contain the number of maps, $T$. $T$ maps will follow, each starting with two integers on a line -- $H$ and $W$ -- the height and width of the map, in cells. The next $H$ lines will each contain a row of the map, from north to south, each containing $W$ integers, from west to east, specifying the altitudes of the cells.\n", "outputFormat": "For each test case, output $1 + H$ lines. The first line must be of the form\n\nCase #$X$:\n\nwhere $X$ is the test case number, starting from 1. The next $H$ lines must list the basin labels for each of the cells, in the same order as they appear in the input.", "hint": "**Sample Explanation**\n\nIn Case #1, the upper-right and lower-left corners are sinks. Water from the diagonal flows towards the lower-left because of the lower altitude (5 versus 6).\n\n**Limits**\n\n- $T \\leq 100$\n\n**Small dataset(10 Pts)**\n\n- Time limit: ~~25~~ 2 seconds.\n- $1 \\leq H, W \\leq 10$;\n- $0 \\leq \\text{altitudes} < 10$;\n- There will be at most two basins.\n\n**Large dataset(23 Pts)**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leq H, W \\leq 100$;\n- $0 \\leq \\text{altitudes} < 10,000$.\n- There will be at most 26 basins.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 Qualification] Watersheds", "background": "", "description": "地质学家有时会根据降雨流向将一片区域划分为不同的区域，这些区域被称为**流域**。\n\n给定一张高程图（即一个二维的高度数组），请对地图进行标记，使得同属一个流域的区域具有相同的标记，并满足以下规则：\n\n- 从每个格子出发，水最多只能流向其四个相邻格子中的一个。\n- 对于每个格子，如果它的四个邻居中没有任何一个高度低于它自身，则水不会流动，该格子被称为**汇**。\n- 否则，水会从该格子流向高度最低的邻居。\n- 如果有多个邻居高度同为最低，则水会选择以下顺序中第一个最低的方向：北、 西、 东、 南。\n\n所有直接或间接流向同一个汇的格子都属于同一个流域。每个流域应分配一个独特的小写字母作为标记，并且要保证：当将地图的所有行自上而下拼接成一个字符串时，所得字符串的字典序最小（特别地，最西北角的格子的流域标记总是 'a'）。\n", "inputFormat": "输入的第一行包含地图的数量 $T$。接下来有 $T$ 个地图，每个地图的第一行为两个整数 $H$ 和 $W$，分别表示地图的高和宽（单位为格子数）。接下来的 $H$ 行，每行包含 $W$ 个整数，表示从北到南的每一行，从西到东的每一列，对应格子的高度。\n", "outputFormat": "对于每组测试数据，输出 $1+H$ 行。第一行格式如下：\n\nCase #$X$:\n\n其中 $X$ 是测试编号，从 1 开始。接下来的 $H$ 行，输出每个格子的流域标记，顺序与输入一致。", "hint": "**样例说明**\n\n在第 1 组数据中，右上角和左下角是汇。对角线上的水会流向左下角，因为那里高度较低（5 比 6 小）。\n\n**限制条件**\n\n- $T \\leq 100$\n\n**小数据集（10 分）**\n\n- 时间限制：2 秒。\n- $1 \\leq H, W \\leq 10$；\n- $0 \\leq \\text{高度} < 10$；\n- 最多有 2 个流域。\n\n**大数据集（23 分）**\n\n- 时间限制：3 秒。\n- $1 \\leq H, W \\leq 100$；\n- $0 \\leq \\text{高度} < 10,000$。\n- 最多有 26 个流域。\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13430", "type": "P", "difficulty": 3, "samples": [["3\nelcomew elcome to code jam\nwweellccoommee to code qps jam\nwelcome to codejam", "Case #1: 0001\nCase #2: 0256\nCase #3: 0000"]], "limits": {"time": [2000, 2000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2009", "Google Code Jam"], "title": "[GCJ 2009 Qualification] Welcome to Code Jam", "background": "", "description": "So you've registered. We sent you a welcoming email, to welcome you to code jam. But it's possible that you still don't feel welcomed to code jam. That's why we decided to name a problem \"welcome to code jam.\" After solving this problem, we hope that you'll feel very welcome. Very welcome, that is, to code jam.\n\nIf you read the previous paragraph, you're probably wondering why it's there. But if you read it very carefully, you might notice that we have written the words \"welcome to code jam\" several times: 400263727 times in total. After all, it's easy to look through the paragraph and find a 'w'; then find an 'e' later in the paragraph; then find an 'l' after that, and so on. Your task is to write a program that can take any text and print out how many times that text contains the phrase \"welcome to code jam\".\n\nTo be more precise, given a text string, you are to determine how many times the string \"welcome to code jam\" appears as a sub-sequence of that string. In other words, find a sequence s of increasing indices into the input string such that the concatenation of input[s[0]], input[s[1]], ..., input[s[18]] is the string \"welcome to code jam\".\n\nThe result of your calculation might be huge, so for convenience we would only like you to find the last 4 digits.", "inputFormat": "The first line of input gives the number of test cases, $N$. The next $N$ lines of input contain one test case each. Each test case is a single line of text, containing only lower-case letters and spaces. No line will start with a space, and no line will end with a space.\n", "outputFormat": "For each test case, \"Case #$x$: $dddd$\", where $x$ is the case number, and $dddd$ is the last four digits of the answer. If the answer has fewer than 4 digits, please add zeroes at the front of your answer to make it exactly 4 digits long.", "hint": "**Limits**\n\n- $1 \\leq N \\leq 100$\n\n**Small dataset(10 Pts)**\n\n- Each line will be no longer than $30$ characters.\n\n**Large dataset(23 Pts)**\n\n- Each line will be no longer than $500$ characters.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 Qualification] Welcome to Code Jam", "background": "", "description": "So you've registered. We sent you a welcoming email, to welcome you to code jam. But it's possible that you still don't feel welcomed to code jam. That's why we decided to name a problem \"welcome to code jam.\" After solving this problem, we hope that you'll feel very welcome. Very welcome, that is, to code jam.\n\nIf you read the previous paragraph, you're probably wondering why it's there. But if you read it very carefully, you might notice that we have written the words \"welcome to code jam\" several times: 400263727 times in total. After all, it's easy to look through the paragraph and find a 'w'; then find an 'e' later in the paragraph; then find an 'l' after that, and so on. Your task is to write a program that can take any text and print out how many times that text contains the phrase \"welcome to code jam\".\n\nTo be more precise, given a text string, you are to determine how many times the string \"welcome to code jam\" appears as a sub-sequence of that string. In other words, find a sequence s of increasing indices into the input string such that the concatenation of input[s[0]], input[s[1]], ..., input[s[18]] is the string \"welcome to code jam\".\n\nThe result of your calculation might be huge, so for convenience we would only like you to find the last 4 digits.", "inputFormat": "The first line of input gives the number of test cases, $N$. The next $N$ lines of input contain one test case each. Each test case is a single line of text, containing only lower-case letters and spaces. No line will start with a space, and no line will end with a space.\n", "outputFormat": "For each test case, \"Case #$x$: $dddd$\", where $x$ is the case number, and $dddd$ is the last four digits of the answer. If the answer has fewer than 4 digits, please add zeroes at the front of your answer to make it exactly 4 digits long.", "hint": "**Limits**\n\n- $1 \\leq N \\leq 100$\n\n**Small dataset(10 Pts)**\n\n- Each line will be no longer than $30$ characters.\n\n**Large dataset(23 Pts)**\n\n- Each line will be no longer than $500$ characters.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 Qualification] Welcome to Code Jam", "background": "", "description": "你已经注册了。我们给你发了一封欢迎邮件，欢迎你来到 code jam。但也许你还没有真正感受到 code jam 的欢迎氛围。这就是为什么我们决定将本题命名为“welcome to code jam”。解决了这道题后，我们希望你能感受到真正的欢迎。真正的欢迎，当然，是来自 code jam。\n\n如果你读了上面这段话，你可能会疑惑它为什么会出现在这里。但如果你非常仔细地阅读，你会发现我们已经多次写下了“welcome to code jam”这句话：总共 400263727 次。毕竟，在这段话中，你完全可以先找到一个 'w'，再找到后面的一个 'e'，再找到后面的一个 'l'，如此下去。你的任务是编写一个程序，统计任意给定文本中，子序列“welcome to code jam”出现了多少次。\n\n更准确地说，给定一个文本字符串，请你确定字符串“welcome to code jam”作为**子序列**在该字符串中出现了多少次。换句话说，找到一个严格递增的下标序列 $s$，使得 input[s[0]]、input[s[1]]、……、input[s[18]] 拼接起来恰好是“welcome to code jam”。\n\n由于结果可能非常大，为了方便，只需要输出答案的最后四位数字。", "inputFormat": "输入的第一行是测试用例数 $N$。接下来的 $N$ 行，每行一个测试用例。每个测试用例是一行文本，仅包含小写字母和空格。每一行都不会以空格开头或结尾。\n", "outputFormat": "对于每个测试用例，输出一行 \"Case #$x$: $dddd$\"，其中 $x$ 是测试编号，$dddd$ 是答案的后四位数字。如果答案不足四位，请在前面补零，使其恰好为四位。\n", "hint": "**限制条件**\n\n- $1 \\leq N \\leq 100$\n\n**小数据集（10 分）**\n\n- 每行长度不超过 $30$ 个字符。\n\n**大数据集（23 分）**\n\n- 每行长度不超过 $500$ 个字符。\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13431", "type": "P", "difficulty": 4, "samples": [["3\n2 3\n2 3 7\n9 10", "Case #1: 3\nCase #2: 143\nCase #3: 91"]], "limits": {"time": [20000, 20000], "memory": [1048576, 1048576]}, "tags": ["模拟", "2009", "记忆化搜索", "Google Code Jam"], "title": "[GCJ 2009 #1A] Multi-base happiness", "background": "", "description": "Given an integer $N$, replace it by the sum of the squares of its digits. A happy number is a number where, if you apply this process repeatedly, it eventually results in the number $1$. For example, if you start with $82$:\n\n```\n8*8 + 2*2       = 64 + 4    = 68,  repeat:\n6*6 + 8*8       = 36 + 64   = 100, repeat:\n1*1 + 0*0 + 0*0 = 1 + 0 + 0 = 1 (happy! :)\n```\n\nSince this process resulted in $1$, $82$ is a happy number.\n\nNotice that a number might be happy in some bases, but not happy in others. For instance, the base $10$ number $82$ is not a happy number when written in base $3$ (as $10001$).\n\nYou are one of the world's top number detectives. Some of the bases got together (yes, they are organized!) and hired you for an important task: find out what's the smallest integer number that's greater than $1$ and is happy in all the given bases.", "inputFormat": "The first line of input gives the number of cases $T$. $T$ test cases follow. Each case consists of a single line. Each line contains a space separated list of distinct integers, representing the bases. The list of bases is always in increasing order.\n", "outputFormat": "For each test case, output:\n\nCase #$X$: $K$\n\nwhere $X$ is the test case number, starting from 1, and $K$ is the decimal representation of the smallest integer (greater than 1) which is happy in all of the given bases.", "hint": "**Limits**\n\n- $2 \\leq \\text{all possible input bases} \\leq 10$\n\n**Small dataset(9 Pts)**\n\n- $1 \\leq T \\leq 42$\n- $2 \\leq \\text{number of bases on each test case} \\leq 3$\n\n**Large dataset(18 Pts)**\n\n- $1 \\leq T \\leq 500$\n- $2 \\leq \\text{number of bases on each test case} \\leq 9$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 #1A] Multi-base happiness", "background": "", "description": "Given an integer $N$, replace it by the sum of the squares of its digits. A happy number is a number where, if you apply this process repeatedly, it eventually results in the number $1$. For example, if you start with $82$:\n\n```\n8*8 + 2*2       = 64 + 4    = 68,  repeat:\n6*6 + 8*8       = 36 + 64   = 100, repeat:\n1*1 + 0*0 + 0*0 = 1 + 0 + 0 = 1 (happy! :)\n```\n\nSince this process resulted in $1$, $82$ is a happy number.\n\nNotice that a number might be happy in some bases, but not happy in others. For instance, the base $10$ number $82$ is not a happy number when written in base $3$ (as $10001$).\n\nYou are one of the world's top number detectives. Some of the bases got together (yes, they are organized!) and hired you for an important task: find out what's the smallest integer number that's greater than $1$ and is happy in all the given bases.", "inputFormat": "The first line of input gives the number of cases $T$. $T$ test cases follow. Each case consists of a single line. Each line contains a space separated list of distinct integers, representing the bases. The list of bases is always in increasing order.\n", "outputFormat": "For each test case, output:\n\nCase #$X$: $K$\n\nwhere $X$ is the test case number, starting from 1, and $K$ is the decimal representation of the smallest integer (greater than 1) which is happy in all of the given bases.", "hint": "**Limits**\n\n- $2 \\leq \\text{all possible input bases} \\leq 10$\n\n**Small dataset(9 Pts)**\n\n- $1 \\leq T \\leq 42$\n- $2 \\leq \\text{number of bases on each test case} \\leq 3$\n\n**Large dataset(18 Pts)**\n\n- $1 \\leq T \\leq 500$\n- $2 \\leq \\text{number of bases on each test case} \\leq 9$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 #1A] Multi-base happiness", "background": "", "description": "给定一个整数 $N$，将其替换为各位数字的平方和。**若不断重复此过程，最终能得到 $1$，则称该数为“快乐数”。** 例如，若从 $82$ 开始：\n\n```\n8*8 + 2*2       = 64 + 4    = 68，重复：\n6*6 + 8*8       = 36 + 64   = 100，重复：\n1*1 + 0*0 + 0*0 = 1 + 0 + 0 = 1（快乐！:)\n```\n\n由于最终结果为 $1$，所以 $82$ 是一个快乐数。\n\n注意，一个数在某些进制下可能是快乐数，而在其他进制下则不是。例如，十进制下的 $82$ 在三进制下写作 $10001$，但它在三进制下不是快乐数。\n\n你是世界顶级的数字侦探。一些进制联合起来（没错，它们有组织！）雇佣你完成一项重要任务：**找出大于 $1$ 的最小整数，使其在所有给定进制下都是快乐数。**\n", "inputFormat": "第一行输入测试用例数 $T$。接下来有 $T$ 个测试用例。每个用例为一行，包含若干个不同的正整数，表示进制。进制总是升序排列。\n", "outputFormat": "对于每个测试用例，输出：\n\nCase #$X$: $K$\n\n其中 $X$ 表示测试编号（从 $1$ 开始），$K$ 表示十进制下大于 $1$ 且在所有给定进制下都是快乐数的最小整数。", "hint": "**限制条件**\n\n- $2 \\leq$ 所有可能出现的进制 $\\leq 10$\n\n**小数据集（9 分）**\n\n- $1 \\leq T \\leq 42$\n- 每组测试用例所含进制数 $2 \\leq \\text{数量} \\leq 3$\n\n**大数据集（18 分）**\n\n- $1 \\leq T \\leq 500$\n- 每组测试用例所含进制数 $2 \\leq \\text{数量} \\leq 9$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13432", "type": "P", "difficulty": 4, "samples": [["2\n1 1\n3 2 10\n1 2\n1 5 3 1 5 2", "Case #1: 4\nCase #2: 7"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["图论", "2009", "最短路", "Google Code Jam"], "title": "[GCJ 2009 #1A] Crossing the Road", "background": "", "description": "Where roads intersect, there are often traffic lights that tell pedestrians (people walking) when they should cross the street. A clever pedestrian may try to optimize her path through a city based on when those lights turn green.\n\nThe city in this problem is a grid, $N$ rows tall by $M$ columns wide. Our pedestrian wants to get from the northeast corner of the southwest block to the southwest corner of the northeast block. Your objective is to help her find her way from corner to corner in the fastest way possible.\n\nThe pedestrian can cross a street in 1 minute, but only if the traffic light is green for the entire crossing. The pedestrian can move between two streets, along one edge of a block, in 2 minutes. The pedestrian can only move along the edges of the block; she cannot move diagonally from one corner of a block to the opposite corner.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r3glgje2.png)\n\nTraffic lights follow the following pattern: at intersection $i$, the north-south lights stay green for $S_i$ minutes, while the east-west lights stay red. Then the north-south lights turn red, the east-west lights turn green, and they stay that way for $W_i$ minutes. Then they start the same cycle again. The pedestrian starts moving at $t=0$ minutes; traffic light $i$ starts a cycle by turning green in the north-south direction at $t=T_i$ minutes. There are cycles before $t=T_i$ as well.\n\nFor example, intersection 0 could have the following values:\n\n$S_0 = 3$, $W_0 = 2$, $T_0 = 0$\n\nThe north-south direction turns green after 0 minutes. That lasts 3 minutes, during which time the pedestrian can cross in the north-south direction and not the east-west direction. Then the lights switch, and for the next 2 minutes the pedestrian can cross in the east-west direction and not the north-south direction. Then, 5 minutes after it started, the cycle starts again. This is exactly the same as the following configuration:\n\n$S_0 = 3$, $W_0 = 2$, $T_0 = 10$", "inputFormat": "The first line in the input contains the number of test cases, $C$. This is followed by $C$ test cases in the following format:\n\nA single line containing \"N M\", where $N$ and $M$ are the number of horizontal roads (rows) and vertical roads (columns), as above. This is followed by $N$ lines. The $i$th of those lines contains information about intersections on the $i$th row, where the 0th row is the northmost. Each of those lines will contain $3M$ integers, separated by spaces, in the following form:\n\n$S_{i,0}$ $W_{i,0}$ $T_{i,0}$ $S_{i,1}$ $W_{i,1}$ $T_{i,1}$ $\\dots$ $S_{i,M-1}$ $W_{i,M-1}$ $T_{i,M-1}$\n\n$S_{i,j}$, $W_{i,j}$ and $T_{i,j}$ all refer to the intersection in the $i$th row from the north and the $j$th column from the west.", "outputFormat": "For each test case, output a single line containing the text \"Case #x: t\", where $x$ is the number of the test case and $t$ is the minimum number of minutes it takes the pedestrian to get from the southwest corner to the northeast corner.", "hint": "**Sample Explanation**\n\nThe first case is described above. The pedestrian crosses to the North ($1$ minute), waits $2$ minutes and then crosses to the East ($1$ minute), for a total of $4$ minutes.\n\nThe second case is depicted in the diagram below. The pedestrian crosses to the East ($1$ minute), waits $2$ minutes and crosses to the North ($1$ minute). Then she walks east a block ($2$ minutes) and crosses to the East ($1$ minute) for a total of $7$ minutes.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7nd6n0zh.png)\n\n**Limits**\n\n- $C$, $N$, $M$, $S_{i,j}$, $W_{i,j}$, $T_{i,j}$ are all non-negative integers.\n- $C \\leq 100$\n\n**Small Input(13 Pts)**\n\n- $1 \\leq N, M \\leq 3$\n- $0 < S_{i,j}, W_{i,j} \\leq 10$\n- $0 \\leq T_{i,j} \\leq 20$\n\n**Large Input(20 Pts)**\n\n- $1 \\leq N, M \\leq 20$\n- $0 < S_{i,j}, W_{i,j} \\leq 10^7$\n- $0 \\leq T_{i,j} \\leq 10^8$", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 #1A] Crossing the Road", "background": "", "description": "Where roads intersect, there are often traffic lights that tell pedestrians (people walking) when they should cross the street. A clever pedestrian may try to optimize her path through a city based on when those lights turn green.\n\nThe city in this problem is a grid, $N$ rows tall by $M$ columns wide. Our pedestrian wants to get from the northeast corner of the southwest block to the southwest corner of the northeast block. Your objective is to help her find her way from corner to corner in the fastest way possible.\n\nThe pedestrian can cross a street in 1 minute, but only if the traffic light is green for the entire crossing. The pedestrian can move between two streets, along one edge of a block, in 2 minutes. The pedestrian can only move along the edges of the block; she cannot move diagonally from one corner of a block to the opposite corner.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r3glgje2.png)\n\nTraffic lights follow the following pattern: at intersection $i$, the north-south lights stay green for $S_i$ minutes, while the east-west lights stay red. Then the north-south lights turn red, the east-west lights turn green, and they stay that way for $W_i$ minutes. Then they start the same cycle again. The pedestrian starts moving at $t=0$ minutes; traffic light $i$ starts a cycle by turning green in the north-south direction at $t=T_i$ minutes. There are cycles before $t=T_i$ as well.\n\nFor example, intersection 0 could have the following values:\n\n$S_0 = 3$, $W_0 = 2$, $T_0 = 0$\n\nThe north-south direction turns green after 0 minutes. That lasts 3 minutes, during which time the pedestrian can cross in the north-south direction and not the east-west direction. Then the lights switch, and for the next 2 minutes the pedestrian can cross in the east-west direction and not the north-south direction. Then, 5 minutes after it started, the cycle starts again. This is exactly the same as the following configuration:\n\n$S_0 = 3$, $W_0 = 2$, $T_0 = 10$", "inputFormat": "The first line in the input contains the number of test cases, $C$. This is followed by $C$ test cases in the following format:\n\nA single line containing \"N M\", where $N$ and $M$ are the number of horizontal roads (rows) and vertical roads (columns), as above. This is followed by $N$ lines. The $i$th of those lines contains information about intersections on the $i$th row, where the 0th row is the northmost. Each of those lines will contain $3M$ integers, separated by spaces, in the following form:\n\n$S_{i,0}$ $W_{i,0}$ $T_{i,0}$ $S_{i,1}$ $W_{i,1}$ $T_{i,1}$ $\\dots$ $S_{i,M-1}$ $W_{i,M-1}$ $T_{i,M-1}$\n\n$S_{i,j}$, $W_{i,j}$ and $T_{i,j}$ all refer to the intersection in the $i$th row from the north and the $j$th column from the west.", "outputFormat": "For each test case, output a single line containing the text \"Case #x: t\", where $x$ is the number of the test case and $t$ is the minimum number of minutes it takes the pedestrian to get from the southwest corner to the northeast corner.", "hint": "**Sample Explanation**\n\nThe first case is described above. The pedestrian crosses to the North ($1$ minute), waits $2$ minutes and then crosses to the East ($1$ minute), for a total of $4$ minutes.\n\nThe second case is depicted in the diagram below. The pedestrian crosses to the East ($1$ minute), waits $2$ minutes and crosses to the North ($1$ minute). Then she walks east a block ($2$ minutes) and crosses to the East ($1$ minute) for a total of $7$ minutes.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7nd6n0zh.png)\n\n**Limits**\n\n- $C$, $N$, $M$, $S_{i,j}$, $W_{i,j}$, $T_{i,j}$ are all non-negative integers.\n- $C \\leq 100$\n\n**Small Input(13 Pts)**\n\n- $1 \\leq N, M \\leq 3$\n- $0 < S_{i,j}, W_{i,j} \\leq 10$\n- $0 \\leq T_{i,j} \\leq 20$\n\n**Large Input(20 Pts)**\n\n- $1 \\leq N, M \\leq 20$\n- $0 < S_{i,j}, W_{i,j} \\leq 10^7$\n- $0 \\leq T_{i,j} \\leq 10^8$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 #1A] Crossing the Road", "background": "", "description": "在道路交叉口，通常会有交通信号灯指示行人（步行的人）何时可以过马路。一位聪明的行人可能会根据信号灯变绿的时间来优化她穿越城市的路线。\n\n本题中的城市是一张网格，高 $N$ 行、宽 $M$ 列。我们的行人希望从西南角的东北顶点出发，前往东北角的西南顶点。你的目标是帮助她用尽可能快的方式，从一个角落到另一个角落。\n\n行人可以在信号灯全程为绿灯时横穿马路，每次穿越用时 $1$ 分钟。行人也可以沿着一个街区的边，从一条街道走到另一条街道，这样的移动需要 $2$ 分钟。行人只能沿着街区的边移动，不能从一个街区的角直接斜向穿越到对角线的角。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r3glgje2.png)\n\n交通信号灯的变换模式如下：在第 $i$ 个路口，南北方向的信号灯会保持绿灯 $S_i$ 分钟，此时东西方向为红灯。然后南北方向变为红灯，东西方向变为绿灯，持续 $W_i$ 分钟。之后，信号灯再次开始同样的循环。行人在 $t=0$ 分钟时开始移动；第 $i$ 个路口的信号灯在 $t=T_i$ 分钟时以南北方向绿灯开始一个循环。$t=T_i$ 之前也有信号灯的循环。\n\n例如，编号为 0 的路口可能有以下数值：\n\n$S_0 = 3$，$W_0 = 2$，$T_0 = 0$\n\n南北方向在 0 分钟后变为绿灯，持续 $3$ 分钟，在此期间行人可以南北方向过马路，东西方向为红灯。然后信号灯切换，接下来的 $2$ 分钟行人可以东西方向过马路，南北方向为红灯。然后，信号灯在 $5$ 分钟后重新开始循环。这与如下配置完全等价：\n\n$S_0 = 3$，$W_0 = 2$，$T_0 = 10$", "inputFormat": "输入的第一行包含测试用例数 $C$。接下来是 $C$ 组测试数据，每组格式如下：\n\n第一行包含 \"N M\"，分别表示水平方向道路（行）数 $N$ 和垂直方向道路（列）数 $M$。接下来 $N$ 行，每行描述该行上的所有路口信息，第 $i$ 行（$i$ 从 $0$ 开始，最北为 $0$ 行）包含 $3M$ 个整数，依次为：\n\n$S_{i,0}$ $W_{i,0}$ $T_{i,0}$ $S_{i,1}$ $W_{i,1}$ $T_{i,1}$ $\\dots$ $S_{i,M-1}$ $W_{i,M-1}$ $T_{i,M-1}$\n\n$S_{i,j}$、$W_{i,j}$ 和 $T_{i,j}$ 分别表示从北到南第 $i$ 行、从西到东第 $j$ 列的路口的信号灯参数。", "outputFormat": "对于每组测试数据，输出一行 \"Case #x: t\"，其中 $x$ 是测试编号，$t$ 是行人从西南角到东北角所需的最短时间（分钟数）。\n", "hint": "**样例说明**\n\n第一个样例如上所述。行人先向北穿越（$1$ 分钟），等待 $2$ 分钟后再向东穿越（$1$ 分钟），总共 $4$ 分钟。\n\n第二个样例见下图。行人先向东穿越（$1$ 分钟），等待 $2$ 分钟后再向北穿越（$1$ 分钟），然后向东走一个街区（$2$ 分钟），再向东穿越（$1$ 分钟），总共 $7$ 分钟。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7nd6n0zh.png)\n\n**限制条件**\n\n- $C$、$N$、$M$、$S_{i,j}$、$W_{i,j}$、$T_{i,j}$ 均为非负整数。\n- $C \\leq 100$\n\n**小数据集（13 分）**\n\n- $1 \\leq N, M \\leq 3$\n- $0 < S_{i,j}, W_{i,j} \\leq 10$\n- $0 \\leq T_{i,j} \\leq 20$\n\n**大数据集（20 分）**\n\n- $1 \\leq N, M \\leq 20$\n- $0 < S_{i,j}, W_{i,j} \\leq 10^7$\n- $0 \\leq T_{i,j} \\leq 10^8$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13433", "type": "P", "difficulty": 5, "samples": [["2\n2 1\n3 2", "Case #1: 3.0000000\nCase #2: 2.5000000"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2009", "Special Judge", "概率论", "Google Code Jam"], "title": "[GCJ 2009 #1A] Collecting Cards", "background": "", "description": "You've become addicted to the latest craze in collectible card games, PokeCraft: The Gathering. You've mastered the rules! You've crafted balanced, offensive, and defensive decks! You argue the merits of various cards on Internet forums! You compete in tournaments! And now, as they just announced their huge new set of cards coming in the year 2010, you've decided you'd like to collect every last one of them! Fortunately, the one remaining sane part of your brain is wondering: how much will this cost?\n\nThere are $C$ kinds of card in the coming set. The cards are going to be sold in \"booster packs\", each of which contains $N$ cards of different kinds. There are many possible combinations for a booster pack where no card is repeated. When you pay for one pack, you will get any of the possible combinations with equal probability. You buy packs one by one, until you own all the $C$ kinds. What is the expected (average) number of booster packs you will need to buy?\n", "inputFormat": "The first line of input gives the number of cases, $T$. $T$ test cases follow, each consisting of a line containing $C$ and $N$.\n", "outputFormat": "For each test case, output one line in the form\n\nCase #$x$: $E$\n\nwhere $x$ is the case number, starting from 1, and $E$ is the expected number of booster packs you will need to buy. Any answer with a relative or absolute error at most $10^{-5}$ will be accepted.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$\n\n**Small dataset(10 Pts)**\n\n- $1 \\leq N \\leq C \\leq 10$\n\n**Large dataset(30 Pts)**\n\n- $1 \\leq N \\leq C \\leq 40$", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 #1A] Collecting Cards", "background": "", "description": "You've become addicted to the latest craze in collectible card games, PokeCraft: The Gathering. You've mastered the rules! You've crafted balanced, offensive, and defensive decks! You argue the merits of various cards on Internet forums! You compete in tournaments! And now, as they just announced their huge new set of cards coming in the year 2010, you've decided you'd like to collect every last one of them! Fortunately, the one remaining sane part of your brain is wondering: how much will this cost?\n\nThere are $C$ kinds of card in the coming set. The cards are going to be sold in \"booster packs\", each of which contains $N$ cards of different kinds. There are many possible combinations for a booster pack where no card is repeated. When you pay for one pack, you will get any of the possible combinations with equal probability. You buy packs one by one, until you own all the $C$ kinds. What is the expected (average) number of booster packs you will need to buy?\n", "inputFormat": "The first line of input gives the number of cases, $T$. $T$ test cases follow, each consisting of a line containing $C$ and $N$.\n", "outputFormat": "For each test case, output one line in the form\n\nCase #$x$: $E$\n\nwhere $x$ is the case number, starting from 1, and $E$ is the expected number of booster packs you will need to buy. Any answer with a relative or absolute error at most $10^{-5}$ will be accepted.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$\n\n**Small dataset(10 Pts)**\n\n- $1 \\leq N \\leq C \\leq 10$\n\n**Large dataset(30 Pts)**\n\n- $1 \\leq N \\leq C \\leq 40$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 #1A] Collecting Cards", "background": "", "description": "你已经迷上了最新流行的集换式卡牌游戏——**PokeCraft：The Gathering**。你已经掌握了所有规则！你组建了均衡、进攻型和防御型的套牌！你在网络论坛上激烈争论各种卡牌的优劣！你参加了各种锦标赛！现在，随着官方刚刚宣布将在 2010 年推出一套巨大的新卡包，你决定要收集齐所有新卡！幸运的是，你头脑中仅存的理智还在思考：这究竟要花多少钱？\n\n新卡包中共有 $C$ 种不同的卡牌。卡牌将以“补充包”的形式出售，每个补充包包含 $N$ 张不同种类的卡牌。补充包的组合方式有很多种，每包内不会有重复卡牌。每次你购买一个补充包，你会以等概率获得所有可能的组合之一。你会一包一包地买，直到你拥有所有 $C$ 种卡牌为止。你想知道，**平均而言，你需要买多少包补充包才能集齐所有卡牌？**", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试数据，每组一行，包含两个整数 $C$ 和 $N$。\n", "outputFormat": "对于每组测试数据，输出一行，格式如下：\n\nCase #$x$: $E$\n\n其中 $x$ 为测试编号（从 1 开始），$E$ 为你期望需要购买的补充包数量。只要你的答案的绝对误差或相对误差不超过 $10^{-5}$，就会被接受。\n", "hint": "**限制条件**\n\n- $1\\leq T\\leq 100$\n\n**小数据集（10 分）**\n\n- $1\\leq N\\leq C\\leq 10$\n\n**大数据集（20 分）**\n\n- $1\\leq N\\leq C\\leq 40$", "locale": "zh-CN"}}}
{"pid": "P13434", "type": "P", "difficulty": 4, "samples": [["1\n3\n(0.5 cool\n  ( 1.000)\n  (0.5 ))\n2\nanteater 1 cool\ncockroach 0", "Case #1:\n0.5000000\n0.2500000"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["树形数据结构", "2009", "Special Judge", "深度优先搜索 DFS", "Google Code Jam"], "title": "[GCJ 2009 #1B] Decision Tree", "background": "", "description": "Decision trees -- in particular, a type called classification trees -- are data structures that are used to classify items into categories using features of those items. For example, each animal is either \"cute\" or not. For any given animal, we can decide whether it is cute by looking at the animal's features and using the following decision tree.\n\n```\n(0.2 furry\n  (0.81 fast\n    (0.3)\n    (0.2)\n  )\n  (0.1 fishy\n    (0.3 freshwater\n      (0.01)\n      (0.01)\n    )\n    (0.1)\n  )\n)\n```\nA decision tree is defined recursively. It always has a root node and a weight. It also, optionally, has a feature name and two sub-trees, which are themselves decision trees.\n\nMore formally, a decision tree is defined using the following grammar.\n\n```\ntree ::= (weight [feature tree tree])\nweight is a real number between 0 and 1, inclusive\nfeature is a string of 1 or more lower case English letters\n```\n\nThe part inside the square brackets, [], is optional. The parentheses, (), weight and feature are tokens. There will be at least one whitespace character between any two tokens, except (possibly) after an open-bracket '(' or before a close-bracket ')'. Whitespace characters are space (' ') and endline ('\\n').\n\nTo figure out how likely the animal is to be cute, we start at the root of the tree with probability $p$ set to 1. At each node, we multiply $p$ by the weight of the node. If the node is a leaf (has no sub-trees), then we stop, and the value of $p$ is the probability that our animal is cute. Otherwise, we look at the feature associated with the node. If our animal has this feature, we move down into the first sub-tree and continue recursively. If it does not have this feature, then we move down into the second sub-tree and continue in the same way.\n\nFor example, a beaver is an animal that has two features: *furry* and *freshwater*. We start at the root with $p$ equal to $1$. We multiply $p$ by $0.2$, the weight of the root and move into the first sub-tree because the beaver has the *furry* feature. There, we multiply $p$ by $0.81$, which makes $p$ equal to $0.162$. From there we move further down into the second sub-tree because the beaver does not have the *fast* feature. Finally, we multiply $p$ by $0.2$ and end up with $0.0324$ -- the probability that the beaver is cute.\n\nYou will be given a decision tree and a list of animals with their features. For each item, you need to return the probability that the animal is cute.\n", "inputFormat": "The first line of input contains a single integer, $N$, the number of test cases. $N$ test cases follow.\n\nEach test case description will start with a line that contains an integer $L$ -- the number of lines that describe a decision tree. The next $L$ lines will contain a decision tree in the format described above. The line after that will contain $A$ -- the number of animals. The next $A$ lines will each contain the description of one animal in the following format.\n\n$\\text{animal}\\ n\\ \\text{feature}_1 \\ \\text{feature}_2 \\ \\dots \\text{feature}_n$", "outputFormat": "For each test case, output one line containing \"Case #x:\" followed by exactly $A$ lines, one per animal, in the same order as they appear in the input. Each line should contain the probability that the animal is cute. Answers that are precise to within an absolute or relative error of $10^{-6}$ will be considered correct.", "hint": "**Limits**\n\n- $1 \\leq N \\leq 100$\n- All weights will be between 0 and 1, inclusive.\n- All weights will consist of only digits with at most one decimal point.\n- The weights will not start or end with a decimal point.\n- The weights will not have more than one 0 before a decimal point.\n- All animals and features will consist of between 1 and 10 lower case English letters.\n- All animal names within a test case will be distinct.\n- All feature names for a single animal will be distinct.\n- Each of the $L$ lines in a decision tree definition will have at most 80 characters, not including the endlines.\n\n**Small dataset(10 Pts)**\n\n- $1 \\leq L \\leq 10$\n- $1 \\leq A \\leq 10$\n- $0 \\leq n \\leq 5$\n\n**Large dataset(11 Pts)**\n\n- $1 \\leq L \\leq 100$\n- $1 \\leq A \\leq 100$\n- $0 \\leq n \\leq 100$", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 #1B] Decision Tree", "background": "", "description": "Decision trees -- in particular, a type called classification trees -- are data structures that are used to classify items into categories using features of those items. For example, each animal is either \"cute\" or not. For any given animal, we can decide whether it is cute by looking at the animal's features and using the following decision tree.\n\n```\n(0.2 furry\n  (0.81 fast\n    (0.3)\n    (0.2)\n  )\n  (0.1 fishy\n    (0.3 freshwater\n      (0.01)\n      (0.01)\n    )\n    (0.1)\n  )\n)\n```\nA decision tree is defined recursively. It always has a root node and a weight. It also, optionally, has a feature name and two sub-trees, which are themselves decision trees.\n\nMore formally, a decision tree is defined using the following grammar.\n\n```\ntree ::= (weight [feature tree tree])\nweight is a real number between 0 and 1, inclusive\nfeature is a string of 1 or more lower case English letters\n```\n\nThe part inside the square brackets, [], is optional. The parentheses, (), weight and feature are tokens. There will be at least one whitespace character between any two tokens, except (possibly) after an open-bracket '(' or before a close-bracket ')'. Whitespace characters are space (' ') and endline ('\\n').\n\nTo figure out how likely the animal is to be cute, we start at the root of the tree with probability $p$ set to 1. At each node, we multiply $p$ by the weight of the node. If the node is a leaf (has no sub-trees), then we stop, and the value of $p$ is the probability that our animal is cute. Otherwise, we look at the feature associated with the node. If our animal has this feature, we move down into the first sub-tree and continue recursively. If it does not have this feature, then we move down into the second sub-tree and continue in the same way.\n\nFor example, a beaver is an animal that has two features: *furry* and *freshwater*. We start at the root with $p$ equal to $1$. We multiply $p$ by $0.2$, the weight of the root and move into the first sub-tree because the beaver has the *furry* feature. There, we multiply $p$ by $0.81$, which makes $p$ equal to $0.162$. From there we move further down into the second sub-tree because the beaver does not have the *fast* feature. Finally, we multiply $p$ by $0.2$ and end up with $0.0324$ -- the probability that the beaver is cute.\n\nYou will be given a decision tree and a list of animals with their features. For each item, you need to return the probability that the animal is cute.\n", "inputFormat": "The first line of input contains a single integer, $N$, the number of test cases. $N$ test cases follow.\n\nEach test case description will start with a line that contains an integer $L$ -- the number of lines that describe a decision tree. The next $L$ lines will contain a decision tree in the format described above. The line after that will contain $A$ -- the number of animals. The next $A$ lines will each contain the description of one animal in the following format.\n\n$\\text{animal}\\ n\\ \\text{feature}_1 \\ \\text{feature}_2 \\ \\dots \\text{feature}_n$", "outputFormat": "For each test case, output one line containing \"Case #x:\" followed by exactly $A$ lines, one per animal, in the same order as they appear in the input. Each line should contain the probability that the animal is cute. Answers that are precise to within an absolute or relative error of $10^{-6}$ will be considered correct.", "hint": "**Limits**\n\n- $1 \\leq N \\leq 100$\n- All weights will be between 0 and 1, inclusive.\n- All weights will consist of only digits with at most one decimal point.\n- The weights will not start or end with a decimal point.\n- The weights will not have more than one 0 before a decimal point.\n- All animals and features will consist of between 1 and 10 lower case English letters.\n- All animal names within a test case will be distinct.\n- All feature names for a single animal will be distinct.\n- Each of the $L$ lines in a decision tree definition will have at most 80 characters, not including the endlines.\n\n**Small dataset(10 Pts)**\n\n- $1 \\leq L \\leq 10$\n- $1 \\leq A \\leq 10$\n- $0 \\leq n \\leq 5$\n\n**Large dataset(11 Pts)**\n\n- $1 \\leq L \\leq 100$\n- $1 \\leq A \\leq 100$\n- $0 \\leq n \\leq 100$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 #1B] Decision Tree", "background": "", "description": "决策树——尤其是一种被称为分类树（**classification trees**）的类型——是一种用于根据物品的特征将其分类的数据结构。例如，每只动物要么“可爱”，要么不可爱。对于任意一只动物，我们可以通过观察其特征，并使用如下决策树来判断它是否可爱。\n\n```\n(0.2 furry\n  (0.81 fast\n    (0.3)\n    (0.2)\n  )\n  (0.1 fishy\n    (0.3 freshwater\n      (0.01)\n      (0.01)\n    )\n    (0.1)\n  )\n)\n```\n\n决策树以递归方式定义。它总是有一个根节点和一个权重。它还可以**选择性地**拥有一个特征名和两棵子树（这两棵子树本身也是决策树）。\n\n更正式地说，决策树使用如下语法定义：\n\n```\ntree ::= (weight [feature tree tree])\nweight 是一个在 0 到 1 之间（含 0 和 1）的实数\nfeature 是由一个或多个小写英文字母组成的字符串\n```\n\n方括号 [] 内的部分为可选项。圆括号 ()、权重和特征都是**标记**。任意两个标记之间至少有一个空白字符（空格 `' '` 或换行符 `'\\n'`），但在左括号 '(' 后或右括号 ')' 前可能没有空白。每一行的长度（不包括换行符）不会超过 80 个字符。\n\n为了判断一只动物有多大概率是可爱的，我们从树的根节点开始，初始概率 $p=1$。在每个节点，我们将 $p$ 乘以该节点的权重。如果该节点是叶子节点（没有子树），则停止，当前 $p$ 的值即为该动物可爱的概率。否则，查看该节点关联的特征。如果动物具有该特征，则进入第一棵子树递归处理；否则进入第二棵子树递归处理。\n\n例如，河狸（beaver）有两个特征：**furry** 和 **freshwater**。我们从根节点开始，$p=1$，乘以根节点的权重 $0.2$，进入第一棵子树（因为河狸有 furry 特征）。在该子树中，再乘以 $0.81$，$p$ 变为 $0.162$。接着，因为河狸没有 fast 特征，进入第二棵子树。再乘以 $0.2$，最终得到 $0.0324$，这就是河狸“可爱”的概率。\n\n你将获得一棵决策树和若干动物及其特征。对于每个动物，你需要输出其被判定为“可爱”的概率。", "inputFormat": "输入的第一行为一个整数 $N$，表示测试用例数。接下来是 $N$ 组测试数据。\n\n每组测试数据的开头是一行，包含整数 $L$，表示描述决策树的行数。接下来的 $L$ 行给出决策树的定义，格式如上所述。再下一行是整数 $A$，表示动物的数量。接下来 $A$ 行，每行描述一种动物，格式如下：\n\n$\\text{animal}\\ n\\ \\text{feature}_1 \\ \\text{feature}_2 \\ \\dots \\text{feature}_n$", "outputFormat": "对于每组测试数据，输出一行 \"Case #x:\"，接着输出 $A$ 行，每行一个概率，顺序与输入动物顺序一致。每个概率保留至少 7 位小数。只要你的答案的绝对误差或相对误差不超过 $10^{-6}$，即视为正确。\n", "hint": "**限制条件**\n\n- $1 \\leq N \\leq 100$\n- 所有权重均为 $[0, 1]$ 区间内的实数。\n- 权重仅包含数字和最多一个小数点。\n- 权重不会以小数点开头或结尾。\n- 权重在小数点前不会有超过一个 0。\n- 所有动物名和特征名均为 1 到 10 个小写英文字母。\n- 每组测试数据内所有动物名互不相同。\n- 单个动物的所有特征互不相同。\n- 决策树定义的每一行长度不超过 80 个字符（不含换行符）。\n\n**小数据集（10 分）**\n\n- $1 \\leq L \\leq 10$\n- $1 \\leq A \\leq 10$\n- $0 \\leq n \\leq 5$\n\n**大数据集（11 分）**\n\n- $1 \\leq L \\leq 100$\n- $1 \\leq A \\leq 100$\n- $0 \\leq n \\leq 100$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
