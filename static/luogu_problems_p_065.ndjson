{"pid": "P2313", "type": "P", "difficulty": 3, "samples": [["3 4 \nr 1.015 0.750 5.000 4.000\nc 6.000 5.000 2.020\nr 6.500 7.200 7.800 9.200\n3.500 2.500\n4.995 3.990\n2.300 8.150\n6.900 8.000\n", "1\n2\n0\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2005", "各省省选", "湖南", "枚举"], "title": "[HNOI2005] 汤姆的游戏", "background": null, "description": "汤姆是个好动的孩子，今天他突然对圆规和直尺来了兴趣。于是他开始在一张很大很大的白纸上画很多很多的矩形和圆。画着画着，一不小心将他的爆米花弄撒了，于是白纸上就多了好多好多的爆米花。汤姆发现爆米花在白纸上看起来就像一个个点，有些点落在矩形或圆内部，而有些则在外面。于是汤姆开始数每个点在多少个矩形或圆内部。毕竟汤姆还只是个孩子，而且点、矩形和圆又非常多。所以汤姆数了好一会都数不清，于是就向聪明的你求助了。你的任务是：在给定平面上 $N$ 个图形（矩形或圆）以及 $M$ 个点后，请你求出每个点在多少个矩形或圆内部（这里假设矩形的边都平行于坐标轴）。", "inputFormat": "第一行为两个正整数 $N$ 和 $M$，其中 $N$ 表示有多少个图形（矩形或圆），$M$ 表示有多少个点。接下来的 $N$ 行是对每个图形的描述，具体来说，第 $i+1$ 行表示第 $i$ 个图形。先是一个字母,若该字母为 `r`，则表示该图形是一个矩形,这时后面将有 $4$ 个实数 $x1,y1,x2,y2$，表示该矩形的一对对角顶点的坐标分别为 $(x1,y1)$ 和  $(x2,y2)$；若该字母为 `c`，则表示该图形是一个圆，这时后面将有 $3$ 个实数 $x,y,r$，表示该圆以 $(x,y)$ 为圆心并以 $r$ 为半径。最后 $M$ 行是对每个点的描述，其中每行将有两个实数 $x,y$，表示一个坐标为 $(x,y)$ 的点。", "outputFormat": "包含 $M$ 行，每行是一个整数，其中第 $i$ 行的整数表示第 $i$ 个点在多少个图形内部（当某点在一个图形的边界上时，我们认为该点不在这个图形的内部）。", "hint": "对于 $100\\%$ 的数据，$N,M\\le 500$。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2005] Tom's Game", "background": "", "description": "Tom is an energetic child, and today he becomes interested in a compass and a straightedge. He starts drawing many rectangles and circles on a very large sheet of white paper. While drawing, he accidentally spills his popcorn, and now there are many popcorn pieces on the paper. Tom notices that the popcorn looks like points on the plane: some points fall inside rectangles or circles, while others fall outside. He begins counting how many rectangles or circles each point lies inside. Since Tom is still a child and there are many points, rectangles, and circles, he cannot finish counting and asks you for help.\n\nYour task is: given $N$ shapes (rectangles or circles) and $M$ points on the plane, determine for each point how many rectangles or circles contain it. Assume that each rectangle has sides parallel to the coordinate axes.", "inputFormat": "The first line contains two positive integers $N$ and $M$, where $N$ is the number of shapes (rectangles or circles) and $M$ is the number of points.\n\nThe next $N$ lines describe the shapes. Specifically, the $(i+1)$-th line describes the $i$-th shape. It starts with a letter: if the letter is `r`, the shape is a rectangle, followed by $4$ real numbers $x1,y1,x2,y2$, which are the coordinates of a pair of opposite vertices $(x1,y1)$ and $(x2,y2)$; if the letter is `c`, the shape is a circle, followed by $3$ real numbers $x,y,r$, meaning the circle is centered at $(x,y)$ with radius $r$.\n\nThe last $M$ lines describe the points. Each of these lines contains two real numbers $x,y$, representing a point at coordinates $(x,y)$.", "outputFormat": "Output $M$ lines. The integer on the $i$-th line is the number of shapes that contain the $i$-th point. If a point lies on the boundary of a shape, it is considered not inside that shape.", "hint": "For $100\\%$ of the testdata, $N, M \\le 500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2005] 汤姆的游戏", "background": null, "description": "汤姆是个好动的孩子，今天他突然对圆规和直尺来了兴趣。于是他开始在一张很大很大的白纸上画很多很多的矩形和圆。画着画着，一不小心将他的爆米花弄撒了，于是白纸上就多了好多好多的爆米花。汤姆发现爆米花在白纸上看起来就像一个个点，有些点落在矩形或圆内部，而有些则在外面。于是汤姆开始数每个点在多少个矩形或圆内部。毕竟汤姆还只是个孩子，而且点、矩形和圆又非常多。所以汤姆数了好一会都数不清，于是就向聪明的你求助了。你的任务是：在给定平面上 $N$ 个图形（矩形或圆）以及 $M$ 个点后，请你求出每个点在多少个矩形或圆内部（这里假设矩形的边都平行于坐标轴）。", "inputFormat": "第一行为两个正整数 $N$ 和 $M$，其中 $N$ 表示有多少个图形（矩形或圆），$M$ 表示有多少个点。接下来的 $N$ 行是对每个图形的描述，具体来说，第 $i+1$ 行表示第 $i$ 个图形。先是一个字母,若该字母为 `r`，则表示该图形是一个矩形,这时后面将有 $4$ 个实数 $x1,y1,x2,y2$，表示该矩形的一对对角顶点的坐标分别为 $(x1,y1)$ 和  $(x2,y2)$；若该字母为 `c`，则表示该图形是一个圆，这时后面将有 $3$ 个实数 $x,y,r$，表示该圆以 $(x,y)$ 为圆心并以 $r$ 为半径。最后 $M$ 行是对每个点的描述，其中每行将有两个实数 $x,y$，表示一个坐标为 $(x,y)$ 的点。", "outputFormat": "包含 $M$ 行，每行是一个整数，其中第 $i$ 行的整数表示第 $i$ 个点在多少个图形内部（当某点在一个图形的边界上时，我们认为该点不在这个图形的内部）。", "hint": "对于 $100\\%$ 的数据，$N,M\\le 500$。", "locale": "zh-CN"}}}
{"pid": "P2314", "type": "P", "difficulty": 6, "samples": [["9 \r\n4 4 6 5 4 2 3 3 5\r\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "各省省选", "湖南"], "title": "[HNOI2005] 木梳", "background": null, "description": "$%![](https://cdn.luogu.com.cn/upload/pic/1353.png)$\n\n$%![](https://cdn.luogu.com.cn/upload/pic/1354.png)$\n\n艾艺从小酷爱艺术，他梦想成为一名伟大的艺术家。最近他获得了一块材质不错的木板，其下侧为直线段，长为 $L$，平均分为 $L$ 段，从左到右编号为 $1$、$2$、……、$L$。木板的上侧为锯齿形，高度为整数，第 $i$ 段的高度为 $A_i$，$A_i \\ge 2$（如下图所示）。\n\n```plain\n              *                                    \n                                                   \n              *     *                             *\n                                                   \n  *     *     *     *     *                       *\n                                                   \n  *     *     *     *     *           *     *     *\n                                                   \n  *     *     *     *     *     *     *     *     *\n                                                   \n  *     *     *     *     *     *     *     *     *\n                                                   \n  4     4     6     5     4     2     3     3     5\n```\n\n这么好的一段材料浪费了怪可惜的，艾艺决定好好加工一番做成一件艺术品。但他不是纯艺术家，他觉得每件艺术品都应有实用价值（否则只是华而不实），具有实用性的艺术品是他设计的理念。\n\n根据这块木板的锯齿状，艾艺想到了每天起床后都要用到的一件日用品，“对，就把它做成梳子！”他的设想是：用刻刀将某些上端的格子挖掉（如果把某个格子挖掉，那么这个格子上方的格子也必须被挖掉，但不能把一列中的格子全都挖掉）。使得剩下的木板构成“规则锯齿形”（这样才好梳头）。\n\n例如，对上图，挖掉第 $3$、$7$、$8$ 列最上面的 $1$ 个格子和第 $5$ 列最上面的 $2$ 个格子后，剩下的区域就构成“规则锯齿形”（如下图所示）。\n\n```plain\n              .                                      \n            +---------+                         +--->\n            | *     * |                         | *  \n------------+         |                         |    \n  *     *     *     * |   .                     | *  \n                      |                         |    \n  *     *     *     * |   .           .     .   | *  \n                      +-------------------------+    \n  *     *     *     *     *     *     *     *     *  \n                                                     \n  *     *     *     *     *     *     *     *     *  \n                                                     \n  4     4     5     5     2     2     2     2     5  \n```\n\n一个锯齿形称为“规则锯齿形”当且仅当它的边界（右图中红色曲线所示）的拐点序列不包含 `010` 或者 `101`。右图中曲线的拐点序列为 `011001`，其中 `0` 代表左拐，`1` 代表右拐，沿着曲线的最左端往右走，先左拐，再右拐，接着右拐，然后左拐，继续左拐，最后右拐。\n\n为了最大限度地减少浪费，艾艺希望做出来的梳子面积最大。", "inputFormat": "第一行一个整数 $L$，表示木板下侧直线段的长。\n\n第二行为 $L$ 个正整数 $A_1 \\sim A_L$，表示每段的高度。", "outputFormat": "一个整数，表示为使梳子面积最大，需要从木板上挖掉的格子数。", "hint": "对于 $50\\%$ 的数据，$L \\le 10^4$。\n\n对于 $100\\%$ 的数据，$4 \\le L \\le 10^5$，$2 \\le A_i \\le 10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2005] Wooden Comb", "background": "", "description": "$%![](https://cdn.luogu.com.cn/upload/pic/1353.png)$\n\n$%![](https://cdn.luogu.com.cn/upload/pic/1354.png)$\n\nAi Yi has loved art since childhood and dreams of becoming a great artist. Recently, he got a nice wooden board whose bottom side is a straight segment of length $L$, evenly divided into $L$ segments, numbered $1, 2, \\ldots, L$ from left to right. The top side is a sawtooth shape with integer heights: the height of the $i$-th segment is $A_i$, where $A_i \\ge 2$ (see the figure below).\n\n```plain\n              *                                    \n                                                   \n              *     *                             *\n                                                   \n  *     *     *     *     *                       *\n                                                   \n  *     *     *     *     *           *     *     *\n                                                   \n  *     *     *     *     *     *     *     *     *\n                                                   \n  *     *     *     *     *     *     *     *     *\n                                                   \n  4     4     6     5     4     2     3     3     5\n```\n\nIt would be a pity to waste such good material, so Ai Yi decides to craft it into a piece of art. But he is not a pure artist; he believes every artwork should be practical (otherwise it is merely flashy). Practicality is his design philosophy.\n\nInspired by the sawtooth shape of the board, Ai Yi thought of an everyday item used after getting up: “Yes, let’s make it into a comb!” His idea is to chisel away some cells at the top ends of columns (if a cell is removed, then all cells above it must also be removed, but you cannot remove all cells in any column), so that the remaining board forms a “regular sawtooth shape” (which is suitable for combing).\n\nFor example, for the figure above, if you remove the top $1$ cell from columns $3$, $7$, and $8$, and remove the top $2$ cells from column $5$, the remaining region forms a “regular sawtooth shape” (as shown below).\n\n```plain\n              .                                      \n            +---------+                         +--->\n            | *     * |                         | *  \n------------+         |                         |    \n  *     *     *     * |   .                     | *  \n                      |                         |    \n  *     *     *     * |   .           .     .   | *  \n                      +-------------------------+    \n  *     *     *     *     *     *     *     *     *  \n                                                     \n  *     *     *     *     *     *     *     *     *  \n                                                     \n  4     4     5     5     2     2     2     2     5  \n```\n\nA sawtooth shape is called “regular” if and only if the turning sequence of its boundary (the red curve in the right figure) does not contain `010` or `101`. In the right figure, the curve’s turning sequence is `011001`, where `0` denotes a left turn and `1` denotes a right turn. Walking along the curve from the leftmost end to the right, you first turn left, then right, then right, then left, then left, and finally right.\n\nTo minimize waste, Ai Yi wants the comb’s area to be as large as possible.", "inputFormat": "The first line contains an integer $L$, the length of the bottom straight segment of the board.\n\nThe second line contains $L$ positive integers $A_1 \\sim A_L$, the heights of each segment.", "outputFormat": "Output a single integer: the number of cells that must be removed from the board so that the comb’s area is maximized.", "hint": "For $50\\%$ of the testdata, $L \\le 10^4$.\n\nFor $100\\%$ of the testdata, $4 \\le L \\le 10^5$, $2 \\le A_i \\le 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2005] 木梳", "background": null, "description": "$%![](https://cdn.luogu.com.cn/upload/pic/1353.png)$\n\n$%![](https://cdn.luogu.com.cn/upload/pic/1354.png)$\n\n艾艺从小酷爱艺术，他梦想成为一名伟大的艺术家。最近他获得了一块材质不错的木板，其下侧为直线段，长为 $L$，平均分为 $L$ 段，从左到右编号为 $1$、$2$、……、$L$。木板的上侧为锯齿形，高度为整数，第 $i$ 段的高度为 $A_i$，$A_i \\ge 2$（如下图所示）。\n\n```plain\n              *                                    \n                                                   \n              *     *                             *\n                                                   \n  *     *     *     *     *                       *\n                                                   \n  *     *     *     *     *           *     *     *\n                                                   \n  *     *     *     *     *     *     *     *     *\n                                                   \n  *     *     *     *     *     *     *     *     *\n                                                   \n  4     4     6     5     4     2     3     3     5\n```\n\n这么好的一段材料浪费了怪可惜的，艾艺决定好好加工一番做成一件艺术品。但他不是纯艺术家，他觉得每件艺术品都应有实用价值（否则只是华而不实），具有实用性的艺术品是他设计的理念。\n\n根据这块木板的锯齿状，艾艺想到了每天起床后都要用到的一件日用品，“对，就把它做成梳子！”他的设想是：用刻刀将某些上端的格子挖掉（如果把某个格子挖掉，那么这个格子上方的格子也必须被挖掉，但不能把一列中的格子全都挖掉）。使得剩下的木板构成“规则锯齿形”（这样才好梳头）。\n\n例如，对上图，挖掉第 $3$、$7$、$8$ 列最上面的 $1$ 个格子和第 $5$ 列最上面的 $2$ 个格子后，剩下的区域就构成“规则锯齿形”（如下图所示）。\n\n```plain\n              .                                      \n            +---------+                         +--->\n            | *     * |                         | *  \n------------+         |                         |    \n  *     *     *     * |   .                     | *  \n                      |                         |    \n  *     *     *     * |   .           .     .   | *  \n                      +-------------------------+    \n  *     *     *     *     *     *     *     *     *  \n                                                     \n  *     *     *     *     *     *     *     *     *  \n                                                     \n  4     4     5     5     2     2     2     2     5  \n```\n\n一个锯齿形称为“规则锯齿形”当且仅当它的边界（右图中红色曲线所示）的拐点序列不包含 `010` 或者 `101`。右图中曲线的拐点序列为 `011001`，其中 `0` 代表左拐，`1` 代表右拐，沿着曲线的最左端往右走，先左拐，再右拐，接着右拐，然后左拐，继续左拐，最后右拐。\n\n为了最大限度地减少浪费，艾艺希望做出来的梳子面积最大。", "inputFormat": "第一行一个整数 $L$，表示木板下侧直线段的长。\n\n第二行为 $L$ 个正整数 $A_1 \\sim A_L$，表示每段的高度。", "outputFormat": "一个整数，表示为使梳子面积最大，需要从木板上挖掉的格子数。", "hint": "对于 $50\\%$ 的数据，$L \\le 10^4$。\n\n对于 $100\\%$ 的数据，$4 \\le L \\le 10^5$，$2 \\le A_i \\le 10^8$。", "locale": "zh-CN"}}}
{"pid": "P2315", "type": "P", "difficulty": 6, "samples": [["5\r\n1 1 1\r\n1 1 0 1 1 0\r\n1 1 1 1 1 1 1 0 1\r\n1 0 1 1 1 1 0 1 1 1 1 1\r\n0 1 1 1 1 1 0 1 1 1 1 1 0 1 1\r\n", "19"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "各省省选", "树状数组", "湖南", "枚举"], "title": "[HNOI2005] 数三角形", "background": null, "description": "$%![](https://cdn.luogu.com.cn/upload/pic/1355.png)$\n\n小苏看到一个这样的等边三角形：该等边三角形每边的长度为 $ n $ 且被分成 $ n $ 等份，于是每条边就有 $ n-1 $ 个等分点。而整个三角形被连接两个不同边的等分点且平行于三角形的第三边的线段分成了 $ n^2 $ 个单位等边三角形（边长为 $ 1 $）。下图左是 $ n=5 $ 的情形：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5bu420q9.png)\n\n小苏想知道，删除其中的一些短边后，剩下的边一共组成多少个三角形（包括所有边长为 $ m $ 的三角形（$ 1 \\leq m < n $），正立的和倒立的都算，只要三角形的 $ 3m $ 条短边都没有被删除就算是组成一个三角形）。例如，上图右就存在 $ 19 $ 个三角形。", "inputFormat": "$%![](https://cdn.luogu.com.cn/upload/pic/1356.png)$\n\n大三角形的所有短边可以看成由 $\\dfrac{n(n+1)}{2}$ 个单位三角形的边界组成，如下图的灰色三角形所示。其中第 $1$ 排有 $1$ 个灰色三角形，第 $2$ 排有 $2$ 个灰色三角形，……，第 $n$ 排有 $n$ 个灰色三角形。所以输入格式是这样规定的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kw2g07pf.png)\n\n第一行为正整数 $n\\ (1 \\le n \\le 1000)$，表示大三角形每边的长度。\n\n接下来的 $n$ 行，第 $i+1$ 行有 $i$ 组数，从左到右每组数描述一个三角形，每组数都有 $3$ 个数，这 $3$ 个数非 $0$ 即 $1$，表示对应的短边是否被删除，$0$ 表示已被删除，$1$ 表示未被删除，依次按照三角形的左、右、下边的顺序来描述。所以第 $i+1$ 行有 $3i$ 个数，每个数是 $0$ 或 $1$。", "outputFormat": "仅一个整数 $T$，表示有多少个三角形的边界都没有被删除。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2005] Counting Triangles", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1355.png)\n\nXiao Su sees an equilateral triangle: each side of the equilateral triangle has length $n$ and is divided into $n$ equal parts, so each side has $n-1$ division points. The whole triangle is divided into $n^2$ unit equilateral triangles (with side length $1$) by segments that connect division points on two different sides and are parallel to the third side. The figure on the left below shows the case $n=5$:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5bu420q9.png)\n\nXiao Su wants to know, after deleting some of the short edges, how many triangles are formed by the remaining edges (including all triangles with side length $m$ ($1 \\le m < n$), counting both upright and inverted ones). A triangle is counted if all its $3m$ short edges have not been deleted. For example, in the figure on the right above, there are $19$ triangles.", "inputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1356.png)\n\nAll short edges of the large triangle can be regarded as the boundaries of $\\dfrac{n(n+1)}{2}$ unit triangles, as shown by the gray triangles in the figure below. There is $1$ gray triangle in the $1$st row, $2$ gray triangles in the $2$nd row, …, and $n$ gray triangles in the $n$th row. Therefore, the input format is specified as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kw2g07pf.png)\n\nThe first line contains a positive integer $n$ ($1 \\le n \\le 1000$), which is the side length of the large triangle.\n\nThe next $n$ lines: on the $(i+1)$-th line there are $i$ groups of numbers. From left to right, each group describes one triangle. Each group contains $3$ numbers, each either $0$ or $1$, indicating whether the corresponding short edge is deleted. $0$ means deleted, $1$ means not deleted. The three numbers describe, in order, the left, right, and bottom edges of the triangle. Therefore, the $(i+1)$-th line contains $3i$ numbers, each being $0$ or $1$.", "outputFormat": "Output a single integer $T$, the number of triangles whose boundaries have not been deleted.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2005] 数三角形", "background": null, "description": "$%![](https://cdn.luogu.com.cn/upload/pic/1355.png)$\n\n小苏看到一个这样的等边三角形：该等边三角形每边的长度为 $ n $ 且被分成 $ n $ 等份，于是每条边就有 $ n-1 $ 个等分点。而整个三角形被连接两个不同边的等分点且平行于三角形的第三边的线段分成了 $ n^2 $ 个单位等边三角形（边长为 $ 1 $）。下图左是 $ n=5 $ 的情形：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5bu420q9.png)\n\n小苏想知道，删除其中的一些短边后，剩下的边一共组成多少个三角形（包括所有边长为 $ m $ 的三角形（$ 1 \\leq m < n $），正立的和倒立的都算，只要三角形的 $ 3m $ 条短边都没有被删除就算是组成一个三角形）。例如，上图右就存在 $ 19 $ 个三角形。", "inputFormat": "$%![](https://cdn.luogu.com.cn/upload/pic/1356.png)$\n\n大三角形的所有短边可以看成由 $\\dfrac{n(n+1)}{2}$ 个单位三角形的边界组成，如下图的灰色三角形所示。其中第 $1$ 排有 $1$ 个灰色三角形，第 $2$ 排有 $2$ 个灰色三角形，……，第 $n$ 排有 $n$ 个灰色三角形。所以输入格式是这样规定的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kw2g07pf.png)\n\n第一行为正整数 $n\\ (1 \\le n \\le 1000)$，表示大三角形每边的长度。\n\n接下来的 $n$ 行，第 $i+1$ 行有 $i$ 组数，从左到右每组数描述一个三角形，每组数都有 $3$ 个数，这 $3$ 个数非 $0$ 即 $1$，表示对应的短边是否被删除，$0$ 表示已被删除，$1$ 表示未被删除，依次按照三角形的左、右、下边的顺序来描述。所以第 $i+1$ 行有 $3i$ 个数，每个数是 $0$ 或 $1$。", "outputFormat": "仅一个整数 $T$，表示有多少个三角形的边界都没有被删除。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2316", "type": "P", "difficulty": 6, "samples": [["1 3 3\r\n50000\r\n0 0 0 0\r\n150000 0 1 1\r\n0 150000 1 1\r\n3 5.497787 \t  2 2.356194\r\n3 1.570796 \t  2 0.0\r\n3 0.0         2 1.570796\r\n", "175000\r\n150000\r\n200000\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "并查集", "各省省选", "湖南", "前缀和"], "title": "[HNOI2005] 分形", "background": null, "description": "$%![](https://cdn.luogu.com.cn/upload/pic/1357.png)$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ueifmd4d.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7pwzb01g.png)\n\n分形是分数维的，介于 $2$ 维与 $3$ 维之间。完整的分形图往往具有有界的面积和无限的周长。为了探寻分形的奥秘，King 执着地进行着与众不同的研究。\n\n首先他研究简单分形：平面上有一个半径为 $R_0$（$R_0 = 10^5$）的圆，圆心处于坐标原点，它与若干个半径为 $R_1$ 的圆外切，每个半径为 $R_1$ 的圆与若干个半径为 $R_2$ 的圆外切，……，每个半径为 $R_i$ 的圆与若干个半径为 $R_{i+1}$ 的圆外切。任意两圆不相交、不重叠、不内含、不内切。半径为 $R_i$ 的圆只可能与半径为 $R_{i-1}$ 或 $R_{i+1}$ 的圆外切，$i > 0$ 时恰与 1 个半径为 $R_{i-1}$ 的圆外切。\n\n作为基础，他先研究有限层的简单分形，即只由半径为 $R_0 \\sim R_n$ 的圆构成的 $n + 1$ 层分形。图 $1$ 是一个 $5$ 层简单分形。由于只有有限层，所以此图的边界为有限长。\n\nKing 在边界上找出了与分形图的性质有关的若干个点对（$P_i, Q_i$），从 $P_i$ 到 $Q_i$，最短的光滑路径的长度是多少（如图 $1$ 中的加粗曲线）。\n\n光滑路径是指：路径在两圆公切点拐弯时切线方向保持不变。图 $2$ 中左边两段（加粗）路径是光滑的，而右边的（加粗）路径不光滑。", "inputFormat": "$%![](https://cdn.luogu.com.cn/upload/pic/1358.png)$\n\n第一行为 $3$ 个整数 $n, m, t$。其中 $m$ 表示圆的个数（并且圆的编号为 $1 \\sim m$），$t$ 为特殊点对数。\n\n第二行为 $n$ 个正整数 $R_1 \\sim R_n$。\n\n接下来的 $m$ 行表示各个圆，每行有 $4$ 个数 $X_i, Y_i, S_i, F_i$, $(X_i, Y_i)$ 是圆 $i$ 的圆心位置，圆 $i$ 的半径是 $R_{S_i}$，与圆 $i$ 相切的尺寸更大的圆的编号是 $F_i$，$X_i$ 和 $Y_i$ 可能是实数。\n\n再接下来的 $t$ 行表示各个特殊点对，每行有 $4$ 个数 $P_{i,tW}, P_{i,tA}, Q_{i,tW},Q_{i,tA}$，用于描述一个特殊点对 $(P_i, Q_i)$ 的位置：\n\n- $P_{i,tW}$ 表示点 $P_i$ 处于 $P_{i,tW}$ 这个圆上，并且以此圆圆心为原点的幅角为 $P_{i,tA}$。\n- $Q_{i,tW}$ 表示点 $Q_i$ 处于 $Q_{i,tW}$ 这个圆上，并且以此圆圆心为原点的幅角为 $Q_{i,tA}$。", "outputFormat": "$%![](https://cdn.luogu.com.cn/upload/pic/1359.png)$\n\n对于每个特殊点对，输出一行一个整数，表示最短长度除以 $\\pi$ 后四舍五入保留整数的结果。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/1360.png)\n\n对于 $50\\%$ 的数据：\n\n- $m \\le 300$。\n- $t \\le 1000$。\n\n对于 $100\\%$ 的数据：\n\n- $1 \\le n < m \\le 3000$。\n- $1 \\le t \\le 10^5$。\n- $2 \\le R_n < R_{n-1} < \\ldots < R_1 < R_0$。\n- $R_{i-1} - R_i \\ge 2$。\n- $R_0 = 10^5$。\n- $S_0 = -1$。\n- $X_1 = Y_1 = F_1 = S_1 = 0$。\n- $-3 \\times 10^8 \\le X_i, Y_i \\le 3 \\times 10^8$。\n- $0 \\le S_i \\le n$。\n- $1 \\le F_i \\le m$。\n- $F_i \\ne i$。\n- $S_{F_i} = S_i-1$。\n- $1 \\le P_{i,tW},Q_{i,tW} \\le m$。\n- $P_{i,tW} \\ne Q_{i,tW}$。\n- $0 \\le  P_{i,tA},Q_{i,tA} < 2\\pi$。\n- 所有的圆之间要么外切要么相离。\n- 所有特殊点都不是切点。\n- 一个圆最多与 $10$ 个圆外切。\n- 所有实数最多保留 $6$ 位小数。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2005] Fractal", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1357.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ueifmd4d.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7pwzb01g.png)\n\nA fractal has a fractional dimension, between $2$ and $3$. A complete fractal picture often has a bounded area and an infinite perimeter. To explore the secrets of fractals, King persistently conducts an unconventional study.\n\nHe first studies a simple fractal: In the plane, there is a circle of radius $R_0$ ($R_0 = 10^5$) centered at the origin. It is externally tangent to several circles of radius $R_1$. Each circle of radius $R_1$ is externally tangent to several circles of radius $R_2$, …, and each circle of radius $R_i$ is externally tangent to several circles of radius $R_{i+1}$. Any two circles do not intersect, do not overlap, are not contained one in another, and are not internally tangent. A circle of radius $R_i$ can only be externally tangent to circles of radius $R_{i-1}$ or $R_{i+1}$, and for $i > 0$ it is externally tangent to exactly one circle of radius $R_{i-1}$.\n\nAs a foundation, he first studies a finite-layer simple fractal, that is, an $(n + 1)$-layer fractal composed only of circles with radii $R_0$ through $R_n$. Figure 1 shows a $5$-layer simple fractal. Since there are only finitely many layers, the boundary length is finite.\n\nOn the boundary, King identifies several pairs of points $(P_i, Q_i)$ related to the properties of the fractal picture. From $P_i$ to $Q_i$, what is the length of the shortest smooth path (see the bold curve in Figure 1).\n\nA smooth path means: at a common tangent point of two circles, when the path turns, its tangent direction remains unchanged. In Figure 2, the two bold paths on the left are smooth, while the bold path on the right is not smooth.", "inputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1358.png)\n\nThe first line contains $3$ integers $n, m, t$. Here $m$ is the number of circles (and the circles are numbered $1$ through $m$), and $t$ is the number of special point pairs.\n\nThe second line contains $n$ positive integers $R_1$ through $R_n$.\n\nEach of the next $m$ lines describes a circle. Each line contains $4$ numbers $X_i, Y_i, S_i, F_i$. $(X_i, Y_i)$ is the center of circle $i$. The radius of circle $i$ is $R_{S_i}$. The index of the larger circle tangent to circle $i$ is $F_i$. $X_i$ and $Y_i$ may be real numbers.\n\nEach of the next $t$ lines describes a special pair of points. Each line contains $4$ numbers $P_{i,tW}, P_{i,tA}, Q_{i,tW}, Q_{i,tA}$, which specify the locations of a special pair $(P_i, Q_i)$:\n- $P_{i,tW}$ means point $P_i$ lies on circle $P_{i,tW}$, and with the center of this circle as the origin, its argument (angle) is $P_{i,tA}$.\n- $Q_{i,tW}$ means point $Q_i$ lies on circle $Q_{i,tW}$, and with the center of this circle as the origin, its argument (angle) is $Q_{i,tA}$.", "outputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1359.png)\n\nFor each special pair, output one line containing one integer, which is the shortest length divided by $\\pi$, rounded to the nearest integer.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/1360.png)\n\nFor $50\\%$ of the testdata:\n- $m \\le 300$.\n- $t \\le 1000$.\n\nFor $100\\%$ of the testdata:\n- $1 \\le n < m \\le 3000$.\n- $1 \\le t \\le 10^5$.\n- $2 \\le R_n < R_{n-1} < \\ldots < R_1 < R_0$.\n- $R_{i-1} - R_i \\ge 2$.\n- $R_0 = 10^5$.\n- $S_0 = -1$.\n- $X_1 = Y_1 = F_1 = S_1 = 0$.\n- $-3 \\times 10^8 \\le X_i, Y_i \\le 3 \\times 10^8$.\n- $0 \\le S_i \\le n$.\n- $1 \\le F_i \\le m$.\n- $F_i \\ne i$.\n- $S_{F_i} = S_i - 1$.\n- $1 \\le P_{i,tW}, Q_{i,tW} \\le m$.\n- $P_{i,tW} \\ne Q_{i,tW}$.\n- $0 \\le P_{i,tA}, Q_{i,tA} < 2\\pi$.\n- Any two circles are either externally tangent or disjoint.\n- All special points are not points of tangency.\n- Each circle is externally tangent to at most $10$ circles.\n- All real numbers have at most $6$ decimal places.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2005] 分形", "background": null, "description": "$%![](https://cdn.luogu.com.cn/upload/pic/1357.png)$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ueifmd4d.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7pwzb01g.png)\n\n分形是分数维的，介于 $2$ 维与 $3$ 维之间。完整的分形图往往具有有界的面积和无限的周长。为了探寻分形的奥秘，King 执着地进行着与众不同的研究。\n\n首先他研究简单分形：平面上有一个半径为 $R_0$（$R_0 = 10^5$）的圆，圆心处于坐标原点，它与若干个半径为 $R_1$ 的圆外切，每个半径为 $R_1$ 的圆与若干个半径为 $R_2$ 的圆外切，……，每个半径为 $R_i$ 的圆与若干个半径为 $R_{i+1}$ 的圆外切。任意两圆不相交、不重叠、不内含、不内切。半径为 $R_i$ 的圆只可能与半径为 $R_{i-1}$ 或 $R_{i+1}$ 的圆外切，$i > 0$ 时恰与 1 个半径为 $R_{i-1}$ 的圆外切。\n\n作为基础，他先研究有限层的简单分形，即只由半径为 $R_0 \\sim R_n$ 的圆构成的 $n + 1$ 层分形。图 $1$ 是一个 $5$ 层简单分形。由于只有有限层，所以此图的边界为有限长。\n\nKing 在边界上找出了与分形图的性质有关的若干个点对（$P_i, Q_i$），从 $P_i$ 到 $Q_i$，最短的光滑路径的长度是多少（如图 $1$ 中的加粗曲线）。\n\n光滑路径是指：路径在两圆公切点拐弯时切线方向保持不变。图 $2$ 中左边两段（加粗）路径是光滑的，而右边的（加粗）路径不光滑。", "inputFormat": "$%![](https://cdn.luogu.com.cn/upload/pic/1358.png)$\n\n第一行为 $3$ 个整数 $n, m, t$。其中 $m$ 表示圆的个数（并且圆的编号为 $1 \\sim m$），$t$ 为特殊点对数。\n\n第二行为 $n$ 个正整数 $R_1 \\sim R_n$。\n\n接下来的 $m$ 行表示各个圆，每行有 $4$ 个数 $X_i, Y_i, S_i, F_i$, $(X_i, Y_i)$ 是圆 $i$ 的圆心位置，圆 $i$ 的半径是 $R_{S_i}$，与圆 $i$ 相切的尺寸更大的圆的编号是 $F_i$，$X_i$ 和 $Y_i$ 可能是实数。\n\n再接下来的 $t$ 行表示各个特殊点对，每行有 $4$ 个数 $P_{i,tW}, P_{i,tA}, Q_{i,tW},Q_{i,tA}$，用于描述一个特殊点对 $(P_i, Q_i)$ 的位置：\n\n- $P_{i,tW}$ 表示点 $P_i$ 处于 $P_{i,tW}$ 这个圆上，并且以此圆圆心为原点的幅角为 $P_{i,tA}$。\n- $Q_{i,tW}$ 表示点 $Q_i$ 处于 $Q_{i,tW}$ 这个圆上，并且以此圆圆心为原点的幅角为 $Q_{i,tA}$。", "outputFormat": "$%![](https://cdn.luogu.com.cn/upload/pic/1359.png)$\n\n对于每个特殊点对，输出一行一个整数，表示最短长度除以 $\\pi$ 后四舍五入保留整数的结果。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/1360.png)\n\n对于 $50\\%$ 的数据：\n\n- $m \\le 300$。\n- $t \\le 1000$。\n\n对于 $100\\%$ 的数据：\n\n- $1 \\le n < m \\le 3000$。\n- $1 \\le t \\le 10^5$。\n- $2 \\le R_n < R_{n-1} < \\ldots < R_1 < R_0$。\n- $R_{i-1} - R_i \\ge 2$。\n- $R_0 = 10^5$。\n- $S_0 = -1$。\n- $X_1 = Y_1 = F_1 = S_1 = 0$。\n- $-3 \\times 10^8 \\le X_i, Y_i \\le 3 \\times 10^8$。\n- $0 \\le S_i \\le n$。\n- $1 \\le F_i \\le m$。\n- $F_i \\ne i$。\n- $S_{F_i} = S_i-1$。\n- $1 \\le P_{i,tW},Q_{i,tW} \\le m$。\n- $P_{i,tW} \\ne Q_{i,tW}$。\n- $0 \\le  P_{i,tA},Q_{i,tA} < 2\\pi$。\n- 所有的圆之间要么外切要么相离。\n- 所有特殊点都不是切点。\n- 一个圆最多与 $10$ 个圆外切。\n- 所有实数最多保留 $6$ 位小数。", "locale": "zh-CN"}}}
{"pid": "P2317", "type": "P", "difficulty": 6, "samples": [["6 3 10 4\n1 2 1 1 1\n1 2 2 2 1\n1 2 3 9 1\n1 1 4 0 1\n1 1 5 0 1\n1 1 6 1 1\n", "6 2"], ["6 3 2 4\n1 2 1 1 1\n1 2 2 2 1\n1 2 3 0 1\n1 1 4 0 1\n1 1 5 0 1\n1 1 6 1 1\n", "Poor Coke!"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2005", "各省省选", "湖南", "最短路"], "title": "[HNOI2005] 星际贸易", "background": "", "description": "$\\text{Coke}$ 是一个精明的小商人。这次他想大胆地做一次星际贸易。于是他选定了银河贸易交通局所给定的一条贸易路线，从地球出发，依次经过 $Star_1,Star_2,\\cdots,Star_N$ 。贸易路线在 $Star_N$ 结束（$\\text{Coke}$ 最后要在 $Star_N$ 上观光旅游）。\n\n银河系中各个星球实行计划经济。在一个星球上出售商品，必须获得那个星球的许可证。$\\text{Coke}$ 手中的许可证允许他在 $Star_i$ 上出售指定配额量 $A_i (1\\leq A_i\\leq100)$ 吨的商品(而且既不多也不能少，当然他可以不在 $Star_i$；上出售任何商品)，出售后能够获得 $B_i(0 \\leq B_i \\leq 50000)$ 的收入。由于 $\\text{Coke}$ 的私人飞船载重有限，这个精明的小商人不得不好好计划一下他应该向哪些星球出售商品。\n\n飞船采用反物质推进系统行驶，需要反物质燃料。反物质燃料不是用来维持平常飞行的(宇宙间没有阻力)，而是用于飞船从星球出发时加速以及飞船到达星球时减速所需的消耗。每次加速和减速各消耗一个单位的反物质燃料。\n\n另外，作如此长距离的飞行，飞船显然要在中途停靠并在某些星球上补充反物质燃料以及对飞船定期进行一些维护(维护只能在星球上进行)。由于各星球之间科技发展水平不等，在各个星球上反物质燃料的售价以及维护飞船的费用是不同的。\n\n此外，银河贸易交通局正在举办小商人贸易竞赛，对于贸易额(即总贸易收入)得到冠军的商人有丰厚的奖赏，因此 $\\text{Coke}$ 决定不惜血本，要使自己的贸易额达到最大。当然，在贸易额最大的同时，作为一个商人，他还是希望净利润尽可能大(净利润=贸易额-燃料费用-维护费用)。\n\n假设从地球出发时飞船刚刚维护过并装满了燃料，并且飞船每次停靠一个星球出售商品或补充反物质燃料或在终点站观光旅游时就会在那里做一次维护。$\\text{Coke}$ 希望你给他制定一个方案满足他的要求。", "inputFormat": "从文件 input.txt 中读入数据，文件的第 $1$ 行为 $4$ 个正整数 $N,M,R,L_0$。\n\n$N(1 \\le N \\le 2000)$ 表示 Coke 这次要行经的星球数。$M(1 \\le M \\le 2000)$ 表示飞船最大的载重量，$R(0 \\le R \\le 10000000)$ 表示飞船最多能携带的燃料数。$L_0(1 \\le L_0 \\le 100)$ 表示飞船不做维护所能飞行的最大距离。\n\n文件的第 $2 \\cdots N+1$ 行是对每个星球的描述。其中第 $i+1$ 行有 $5$ 个非负整数 $A_i,B_i,L_i,P_i,F_i$，$L_i(1 \\le L_i \\le 100)$ 表示从地球依次经 $Star_1,Star_2,\\cdots,Star_{i-1}$ 最后到达 $Star_i$ 的距离。$P_i(0 \\le P_i \\le 1000)$ 为星球 $Star_i$ 上一个单位反物质的价格，若 $P_i$ 为 $0$ ，则说明这个星球还没有制造反物质的技术。$F_i(0 \\le F_i \\le 10000)$ 表示飞船在 $Star_i$ 上做维护所需要的费用。\n\n假设输入数据满足：对于 $i < j$ 一定有 $L_i < L_j$，并使得只有一种获得最大贸易额的方法。", "outputFormat": "如果可以找到这样的方案，那么输出文件 output.txt 中包含两个整数 $X$ 和 $Y$。$X$ 表示贸易额，$Y$ 表示净利润并且两个数字之间用一个空格隔开。如果不能完成这次星际贸易，那么输出文件 output.txt 中包含 “Poor Coke!”（不包括引号）。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2005] Interstellar Trade", "background": "", "description": "$\\text{Coke}$ is a shrewd small merchant. This time he wants to boldly engage in interstellar trade. He chooses a trade route specified by the Galactic Trade and Traffic Authority, starting from Earth and passing in order through $Star_1, Star_2, \\cdots, Star_N$. The route ends at $Star_N$ (where $\\text{Coke}$ will go sightseeing).\n\nThe planets in the galaxy operate under a planned economy. To sell goods on a planet, you must have that planet’s license. The licenses $\\text{Coke}$ holds allow him to sell exactly the quota amount $A_i$ tons of goods on $Star_i$ with $1 \\le A_i \\le 100$ (neither more nor less; of course, he may choose not to sell anything on $Star_i$). After selling, he can obtain income $B_i$ with $0 \\le B_i \\le 50000$. Because his private spaceship has limited payload, this shrewd merchant must carefully plan which planets to sell on.\n\nThe spaceship uses an antimatter propulsion system and requires antimatter fuel. Antimatter fuel is not used to maintain ordinary flight (there is no drag in space); it is used for acceleration when leaving a planet and deceleration when arriving at a planet. Each acceleration and each deceleration consumes one unit of antimatter fuel.\n\nFurthermore, for such a long trip, the spaceship must stop en route at some planets to replenish antimatter fuel and to perform regular maintenance (maintenance can only be done on planets). Due to different levels of technological development, the price of antimatter fuel and the maintenance cost vary from planet to planet.\n\nIn addition, the Galactic Trade and Traffic Authority is hosting a small-merchant trade competition, with generous rewards for the merchant with the highest trade revenue (i.e., total trade income). Therefore, $\\text{Coke}$ decides to spare no expense to maximize his trade revenue. Of course, while maximizing trade revenue, as a merchant he still hopes the net profit is as large as possible (net profit = trade revenue − fuel cost − maintenance cost).\n\nAssume that when departing from Earth, the spaceship has just been maintained and its fuel tank is full. Whenever the spaceship stops at a planet to sell goods or to refuel, or when it arrives at the terminal for sightseeing, it will undergo maintenance there once. $\\text{Coke}$ wants you to devise a plan that meets his requirements.", "inputFormat": "The first line contains four positive integers $N, M, R, L_0$.\n\n- $N$ ($1 \\le N \\le 2000$) is the number of planets on the route this time.  \n- $M$ ($1 \\le M \\le 2000$) is the spaceship’s maximum cargo capacity.  \n- $R$ ($0 \\le R \\le 10000000$) is the maximum amount of fuel the spaceship can carry.  \n- $L_0$ ($1 \\le L_0 \\le 100$) is the maximum distance the spaceship can fly without maintenance.\n\nThe next $N$ lines (lines $2$ to $N+1$) each describe a planet. Line $i+1$ contains five non-negative integers $A_i, B_i, L_i, P_i, F_i$:\n\n- $A_i$ ($1 \\le A_i \\le 100$) is the sale quota (tons) on $Star_i$.  \n- $B_i$ ($0 \\le B_i \\le 50000$) is the income from selling on $Star_i$.  \n- $L_i$ ($1 \\le L_i \\le 100$) is the distance from Earth to $Star_i$ along the route $Earth \\to Star_1 \\to Star_2 \\to \\cdots \\to Star_i$.  \n- $P_i$ ($0 \\le P_i \\le 1000$) is the price per unit of antimatter on $Star_i$. If $P_i = 0$, this planet does not yet have antimatter manufacturing technology.  \n- $F_i$ ($0 \\le F_i \\le 10000$) is the maintenance cost on $Star_i$.\n\nAssume the input satisfies: for $i < j$, it always holds that $L_i < L_j$, and there is exactly one way to achieve the maximum trade revenue.", "outputFormat": "If such a plan exists, output two integers $X$ and $Y$ separated by a space. $X$ is the maximum trade revenue, and $Y$ is the net profit. If the trip cannot be completed, output “Poor Coke!”.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2005] 星际贸易", "background": "", "description": "$\\text{Coke}$ 是一个精明的小商人。这次他想大胆地做一次星际贸易。于是他选定了银河贸易交通局所给定的一条贸易路线，从地球出发，依次经过 $Star_1,Star_2,\\cdots,Star_N$ 。贸易路线在 $Star_N$ 结束（$\\text{Coke}$ 最后要在 $Star_N$ 上观光旅游）。\n\n银河系中各个星球实行计划经济。在一个星球上出售商品，必须获得那个星球的许可证。$\\text{Coke}$ 手中的许可证允许他在 $Star_i$ 上出售指定配额量 $A_i (1\\leq A_i\\leq100)$ 吨的商品(而且既不多也不能少，当然他可以不在 $Star_i$；上出售任何商品)，出售后能够获得 $B_i(0 \\leq B_i \\leq 50000)$ 的收入。由于 $\\text{Coke}$ 的私人飞船载重有限，这个精明的小商人不得不好好计划一下他应该向哪些星球出售商品。\n\n飞船采用反物质推进系统行驶，需要反物质燃料。反物质燃料不是用来维持平常飞行的(宇宙间没有阻力)，而是用于飞船从星球出发时加速以及飞船到达星球时减速所需的消耗。每次加速和减速各消耗一个单位的反物质燃料。\n\n另外，作如此长距离的飞行，飞船显然要在中途停靠并在某些星球上补充反物质燃料以及对飞船定期进行一些维护(维护只能在星球上进行)。由于各星球之间科技发展水平不等，在各个星球上反物质燃料的售价以及维护飞船的费用是不同的。\n\n此外，银河贸易交通局正在举办小商人贸易竞赛，对于贸易额(即总贸易收入)得到冠军的商人有丰厚的奖赏，因此 $\\text{Coke}$ 决定不惜血本，要使自己的贸易额达到最大。当然，在贸易额最大的同时，作为一个商人，他还是希望净利润尽可能大(净利润=贸易额-燃料费用-维护费用)。\n\n假设从地球出发时飞船刚刚维护过并装满了燃料，并且飞船每次停靠一个星球出售商品或补充反物质燃料或在终点站观光旅游时就会在那里做一次维护。$\\text{Coke}$ 希望你给他制定一个方案满足他的要求。", "inputFormat": "从文件 input.txt 中读入数据，文件的第 $1$ 行为 $4$ 个正整数 $N,M,R,L_0$。\n\n$N(1 \\le N \\le 2000)$ 表示 Coke 这次要行经的星球数。$M(1 \\le M \\le 2000)$ 表示飞船最大的载重量，$R(0 \\le R \\le 10000000)$ 表示飞船最多能携带的燃料数。$L_0(1 \\le L_0 \\le 100)$ 表示飞船不做维护所能飞行的最大距离。\n\n文件的第 $2 \\cdots N+1$ 行是对每个星球的描述。其中第 $i+1$ 行有 $5$ 个非负整数 $A_i,B_i,L_i,P_i,F_i$，$L_i(1 \\le L_i \\le 100)$ 表示从地球依次经 $Star_1,Star_2,\\cdots,Star_{i-1}$ 最后到达 $Star_i$ 的距离。$P_i(0 \\le P_i \\le 1000)$ 为星球 $Star_i$ 上一个单位反物质的价格，若 $P_i$ 为 $0$ ，则说明这个星球还没有制造反物质的技术。$F_i(0 \\le F_i \\le 10000)$ 表示飞船在 $Star_i$ 上做维护所需要的费用。\n\n假设输入数据满足：对于 $i < j$ 一定有 $L_i < L_j$，并使得只有一种获得最大贸易额的方法。", "outputFormat": "如果可以找到这样的方案，那么输出文件 output.txt 中包含两个整数 $X$ 和 $Y$。$X$ 表示贸易额，$Y$ 表示净利润并且两个数字之间用一个空格隔开。如果不能完成这次星际贸易，那么输出文件 output.txt 中包含 “Poor Coke!”（不包括引号）。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2318", "type": "P", "difficulty": 4, "samples": [["3 8 \r\n1\r\n1\r\n2\r\n3\r\n4\r\n2\r\n5\r\n4\r\n", "1"]], "limits": {"time": [1000, 1000, 1000, 3000, 4000, 5000, 5000, 5000, 5000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2005", "各省省选", "离散化", "湖南", "哈希 hashing"], "title": "[HNOI2005] 虚拟内存", "background": "", "description": "操作系统中一种重要的存储管理技术就是虚拟内存技术。操作系统中允许进程同时运行，也就是并行。每个进程都有其相对独立的数据块（进程运行的过程中将对其进行读写操作）。理想的情况下，这些数据块都应该存放在内存中，这样才能实现高效的读写操作。但事实上，内存的容量有限，每个进程只能把一部分数据放在内存中，为了解决这个矛盾，提出了虚拟内存技术。\n\n虚拟内存技术的基本原理是：对进程而言，内存空间是无限大的，进程可以随意地读写数据，而对操作系统内部而言，利用外存来模拟扩充的内存空间，进程要求访问某个内存单元时，交由操作系统处理，操作系统首先在内存中查找该单元是否存在，如果存在，查找成功，否则转入外存查找（一定存在于外存中）。\n\n就存储介质的物理性质而言，内存的访问速度相对于外存要快得多，因此对于每个进程来说操作系统应该把那些访问次数较多的数据存放在内存中，而把那些访问次数很少的数据放在外存中。如何选择内存中暂留的数据是一个很值得研究的问题，下面介绍一个内存管理中比较常用的算法：\n\n内存中的数据以页为基本存储单位，进程的读写操作都针对页来进行。实际内存空间被分割成 $n$ 页，虚拟内存空间的页数往往要多得多。某一时刻，进程需要访问虚存编号为 $P$ 的页，该算法的执行步骤如下：\n\n- a. 首先在内存中查找，如果该页位于内存中，查找成功，转 d，否则继续下面的操作；\n\n- b. 寻找内存中是否存在空页（即没有装载任何数据页的页面），若有，则从外存中读入要查找页，并将该页送至内存中的空页进行存储，然后转 d，否则继续下面的操作；\n\n- c. 在内存中寻找一个访问次数最少的页面（如果存在多个页面的访问次数同时为最少，则选取最早读入数据进入内存的那个页面），从外存中读入要查找页，替换该页；\n\n- d. 结束。\n\n所谓访问次数是指从当前页面进入内存到该时刻被访问的次数，如果该页面以前进入过内存并被其它页面替换，那么前面的访问次数不应计入这个时刻的访问次数中。\n\n你的任务是设计一个程序实现上述算法。\n\n测试数据将会提供 $m$ 条读写内存的命令，每条命题提供要求访问的虚拟内存页的编号 $P$ 。你的程序要求能够模拟整个 $m$ 条命令的全部执行过程，所有的命令是按照输入的先后执行的，最开始的时候内存中的 $n$ 页全为空。", "inputFormat": "输入共 $m+1$ 行，第 $1$ 行为 $n (n \\le 10^4)$ 和 $m (m \\le 10^6)$ ，分别表示内存页数和读写内存命令条数。接下来有 $m$ 行，其中第 $i+1$ 行有一个正整数 $P_i (P_i \\le 10^9)$ ，表示第 $i$ 条读写内存命令需要访问的虚拟内存页的编号。", "outputFormat": "输出中仅包含一个正整数，表示在整个模拟过程中，在内存中直接查找成功的次数（即上面的算法只执行步骤 a 的次数）。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2005] Virtual Memory", "background": "# Description\n\nVirtual memory is an important storage management technique in operating systems. Operating systems allow processes to run at the same time, i.e., in parallel. Each process has its own relatively independent block of data (which is read and written during execution). Ideally, all these data blocks should be in memory to support efficient read and write operations. In reality, memory capacity is limited, and each process can only keep part of its data in memory. To address this, virtual memory was introduced.\n\nThe basic idea of virtual memory is: from the process’s point of view, the memory space is unlimited, and the process can read and write data freely. Internally, the OS uses external storage to simulate an expanded memory space. When a process requests access to some memory unit, the OS handles it: it first checks whether the unit exists in memory. If it is found, the lookup succeeds; otherwise, it switches to external storage to find it (it certainly exists there).\n\nSince memory is much faster than external storage, the OS should keep frequently accessed data in memory and place infrequently accessed data on external storage. How to choose which data remains in memory is worth studying. Below is a commonly used algorithm in memory management:\n\nData in memory is managed in units of pages, and read/write operations are performed on pages. The physical memory is divided into $n$ pages, while the number of pages in virtual memory is usually much larger. At some moment, when a process needs to access the virtual page with number $P$, the algorithm proceeds as follows:\n\na. First, look it up in memory. If the page is in memory, the lookup succeeds; go to d. Otherwise, continue with the steps below.\n\nb. Check whether there is a free page frame in memory (i.e., a frame that does not store any data page). If there is, read the requested page from external storage and place it into the free frame in memory, then go to d. Otherwise, continue with the next step.\n\nc. In memory, find a page with the least number of accesses (if multiple pages tie for the minimum, choose the one that was loaded into memory the earliest), then read the requested page from external storage and replace that page.\n\nd. End.\n\nThe access count of a page is the number of times it has been accessed since it was loaded into memory this time. If the page had been in memory before and was evicted, its previous access count must not be counted for the current stay.\n\nYour task is to implement the above algorithm.\n\nThe testdata will provide $m$ memory access commands. Each command gives the virtual page number $P$ to be accessed. Your program must simulate the entire execution of all $m$ commands in input order. Initially, all $n$ memory pages are empty.", "description": "Virtual memory is an important storage management technique in operating systems. Operating systems allow processes to run at the same time, i.e., in parallel. Each process has its own relatively independent block of data (which is read and written during execution). Ideally, all these data blocks should be in memory to support efficient read and write operations. In reality, memory capacity is limited, and each process can only keep part of its data in memory. To address this, virtual memory was introduced.\n\nThe basic idea of virtual memory is: from the process’s point of view, the memory space is unlimited, and the process can read and write data freely. Internally, the OS uses external storage to simulate an expanded memory space. When a process requests access to some memory unit, the OS handles it: it first checks whether the unit exists in memory. If it is found, the lookup succeeds; otherwise, it switches to external storage to find it (it certainly exists there).\n\nSince memory is much faster than external storage, the OS should keep frequently accessed data in memory and place infrequently accessed data on external storage. How to choose which data remains in memory is worth studying. Below is a commonly used algorithm in memory management:\n\nData in memory is managed in units of pages, and read/write operations are performed on pages. The physical memory is divided into $n$ pages, while the number of pages in virtual memory is usually much larger. At some moment, when a process needs to access the virtual page with number $P$, the algorithm proceeds as follows:\n\na. First, look it up in memory. If the page is in memory, the lookup succeeds; go to d. Otherwise, continue with the steps below.\n\nb. Check whether there is a free page frame in memory (i.e., a frame that does not store any data page). If there is, read the requested page from external storage and place it into the free frame in memory, then go to d. Otherwise, continue with the next step.\n\nc. In memory, find a page with the least number of accesses (if multiple pages tie for the minimum, choose the one that was loaded into memory the earliest), then read the requested page from external storage and replace that page.\n\nd. End.\n\nThe access count of a page is the number of times it has been accessed since it was loaded into memory this time. If the page had been in memory before and was evicted, its previous access count must not be counted for the current stay.\n\nYour task is to implement the above algorithm.\n\nThe testdata will provide $m$ memory access commands. Each command gives the virtual page number $P$ to be accessed. Your program must simulate the entire execution of all $m$ commands in input order. Initially, all $n$ memory pages are empty.\n\n# Description", "inputFormat": "There are $m + 1$ lines of input.  \nThe first line contains $n$ and $m$ ($n \\le 10000$, $m \\le 1000000$), the number of memory page frames and the number of memory access commands, respectively.  \nEach of the next $m$ lines contains a positive integer $P_i$ ($P_i \\le 10^9$), the virtual page number to be accessed by the $i$-th command (the $(i + 1)$-th line).", "outputFormat": "Output a single integer: the number of times the page was found directly in memory during the simulation (i.e., the number of requests for which the algorithm executed only step a).", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2005] 虚拟内存", "background": "", "description": "操作系统中一种重要的存储管理技术就是虚拟内存技术。操作系统中允许进程同时运行，也就是并行。每个进程都有其相对独立的数据块（进程运行的过程中将对其进行读写操作）。理想的情况下，这些数据块都应该存放在内存中，这样才能实现高效的读写操作。但事实上，内存的容量有限，每个进程只能把一部分数据放在内存中，为了解决这个矛盾，提出了虚拟内存技术。\n\n虚拟内存技术的基本原理是：对进程而言，内存空间是无限大的，进程可以随意地读写数据，而对操作系统内部而言，利用外存来模拟扩充的内存空间，进程要求访问某个内存单元时，交由操作系统处理，操作系统首先在内存中查找该单元是否存在，如果存在，查找成功，否则转入外存查找（一定存在于外存中）。\n\n就存储介质的物理性质而言，内存的访问速度相对于外存要快得多，因此对于每个进程来说操作系统应该把那些访问次数较多的数据存放在内存中，而把那些访问次数很少的数据放在外存中。如何选择内存中暂留的数据是一个很值得研究的问题，下面介绍一个内存管理中比较常用的算法：\n\n内存中的数据以页为基本存储单位，进程的读写操作都针对页来进行。实际内存空间被分割成 $n$ 页，虚拟内存空间的页数往往要多得多。某一时刻，进程需要访问虚存编号为 $P$ 的页，该算法的执行步骤如下：\n\n- a. 首先在内存中查找，如果该页位于内存中，查找成功，转 d，否则继续下面的操作；\n\n- b. 寻找内存中是否存在空页（即没有装载任何数据页的页面），若有，则从外存中读入要查找页，并将该页送至内存中的空页进行存储，然后转 d，否则继续下面的操作；\n\n- c. 在内存中寻找一个访问次数最少的页面（如果存在多个页面的访问次数同时为最少，则选取最早读入数据进入内存的那个页面），从外存中读入要查找页，替换该页；\n\n- d. 结束。\n\n所谓访问次数是指从当前页面进入内存到该时刻被访问的次数，如果该页面以前进入过内存并被其它页面替换，那么前面的访问次数不应计入这个时刻的访问次数中。\n\n你的任务是设计一个程序实现上述算法。\n\n测试数据将会提供 $m$ 条读写内存的命令，每条命题提供要求访问的虚拟内存页的编号 $P$ 。你的程序要求能够模拟整个 $m$ 条命令的全部执行过程，所有的命令是按照输入的先后执行的，最开始的时候内存中的 $n$ 页全为空。", "inputFormat": "输入共 $m+1$ 行，第 $1$ 行为 $n (n \\le 10^4)$ 和 $m (m \\le 10^6)$ ，分别表示内存页数和读写内存命令条数。接下来有 $m$ 行，其中第 $i+1$ 行有一个正整数 $P_i (P_i \\le 10^9)$ ，表示第 $i$ 条读写内存命令需要访问的虚拟内存页的编号。", "outputFormat": "输出中仅包含一个正整数，表示在整个模拟过程中，在内存中直接查找成功的次数（即上面的算法只执行步骤 a 的次数）。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2319", "type": "P", "difficulty": 4, "samples": [["5 6\n3 2\n2 0\n0 3\n0 4\n3 2\n3 2", "4\n3\n2\n0\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "各省省选", "湖南", "Special Judge", "二分图"], "title": "[HNOI2006] 超级英雄", "background": null, "description": "现在电视台有一种节目叫做超级英雄，大概的流程就是每位选手到台上回答主持人的几个问题，然后根据回答问题的多少获得不同数目的奖品或奖金。主持人问题准备了若干道题目，只有当选手正确回答一道题后，才能进入下一题，否则就被淘汰。为了增加节目的趣味性并适当降低难度，主持人总提供给选手几个“锦囊妙计”，比如求助现场观众，或者去掉若干个错误答案（选择题）等等。\n\n这里，我们把规则稍微改变一下。假设主持人总共有 $m$ 道题，选手有 $n$ 种不同的“锦囊妙计”。\n\n主持人规定，每道题都可以从两种“锦囊妙计”中选择一种，而每种“锦囊妙计”只能用一次。\n\n我们又假设一道题使用了它允许的锦囊妙计后，就一定能正确回答，顺利进入下一题。\n\n现在我来到了节目现场，可是我实在是太笨了，以至于一道题也不会做，每道题只好借助使用“锦囊妙计”来通过。\n\n如果我事先就知道了每道题能够使用哪两种“锦囊妙计”，那么你能告诉我怎样选择才能通过最多的题数吗？", "inputFormat": "输入的第一行是两个正整数 $n,m\\ (1 \\le n,m \\le 1000)$，表示总共有 $n$ 种“锦囊妙计”，编号为 $0\\sim n-1$，总共有 $m$ 个问题。\n\n\n以下的 $m$ 行，每行两个数，分别表示第 $m$ 个问题可以使用的“锦囊妙计”的编号。\n\n**注意：**每种编号的“锦囊妙计”只能使用一次，但同一个问题的两个“锦囊妙计”可能一样。", "outputFormat": "输出的第一行为最多能通过的题数 $p$，接下来 $p$ 行，每行为一个整数，第 $i$ 行表示第 $i$ 题使用的“锦囊妙计”的编号。\n\n\n如果有多种答案，那么任意输出一种，本题使用 Special Judge 评判答案。", "hint": "感谢 @zhouyonglong 提供 Special Judge", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2006] Super Hero", "background": "", "description": "There is a TV show called \"Super Hero\". The general process is: each contestant goes on stage to answer several questions from the host, and receives different amounts of prizes or money based on how many questions are answered correctly. The host prepares several questions, and only when a contestant answers a question correctly can they proceed to the next one; otherwise, they are eliminated. To make the show more entertaining and slightly easier, the host provides contestants with several \"lifelines\", such as asking the audience or removing several wrong options (for multiple-choice questions), etc.\n\nHere, we slightly change the rules. Suppose the host has $m$ questions in total, and the contestant has $n$ different \"lifelines\".\n\nThe host stipulates that for each question, you may choose one from two specified \"lifelines\", and each \"lifeline\" can be used at most once.\n\nWe also assume that once a question uses one of its allowed \"lifelines\", it will definitely be answered correctly, and the contestant proceeds to the next question.\n\nNow I am on the show, but I am so bad that I cannot solve any question on my own, so I have to rely on using a \"lifeline\" for every question.\n\nIf I already know which two \"lifelines\" are available for each question, can you tell me how to choose them to pass as many questions as possible?", "inputFormat": "The first line contains two positive integers $n, m\\ (1 \\le n, m \\le 1000)$, indicating there are $n$ kinds of \"lifelines\" numbered $0 \\sim n-1$, and there are $m$ questions in total.\n\nThe next $m$ lines each contain two integers, indicating the IDs of the two \"lifelines\" available for the $i$-th question.\n\nNote: Each \"lifeline\" ID can be used at most once, but the two \"lifelines\" for the same question may be identical.", "outputFormat": "Output the first line as the maximum number of questions $p$ that can be passed. Then output $p$ lines, where the $i$-th line is the ID of the \"lifeline\" used for the $i$-th question.\n\nIf there are multiple valid answers, output any one of them. This problem uses Special Judge.", "hint": "Thanks to @zhouyonglong for providing the Special Judge.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2006] 超级英雄", "background": null, "description": "现在电视台有一种节目叫做超级英雄，大概的流程就是每位选手到台上回答主持人的几个问题，然后根据回答问题的多少获得不同数目的奖品或奖金。主持人问题准备了若干道题目，只有当选手正确回答一道题后，才能进入下一题，否则就被淘汰。为了增加节目的趣味性并适当降低难度，主持人总提供给选手几个“锦囊妙计”，比如求助现场观众，或者去掉若干个错误答案（选择题）等等。\n\n这里，我们把规则稍微改变一下。假设主持人总共有 $m$ 道题，选手有 $n$ 种不同的“锦囊妙计”。\n\n主持人规定，每道题都可以从两种“锦囊妙计”中选择一种，而每种“锦囊妙计”只能用一次。\n\n我们又假设一道题使用了它允许的锦囊妙计后，就一定能正确回答，顺利进入下一题。\n\n现在我来到了节目现场，可是我实在是太笨了，以至于一道题也不会做，每道题只好借助使用“锦囊妙计”来通过。\n\n如果我事先就知道了每道题能够使用哪两种“锦囊妙计”，那么你能告诉我怎样选择才能通过最多的题数吗？", "inputFormat": "输入的第一行是两个正整数 $n,m\\ (1 \\le n,m \\le 1000)$，表示总共有 $n$ 种“锦囊妙计”，编号为 $0\\sim n-1$，总共有 $m$ 个问题。\n\n\n以下的 $m$ 行，每行两个数，分别表示第 $m$ 个问题可以使用的“锦囊妙计”的编号。\n\n**注意：**每种编号的“锦囊妙计”只能使用一次，但同一个问题的两个“锦囊妙计”可能一样。", "outputFormat": "输出的第一行为最多能通过的题数 $p$，接下来 $p$ 行，每行为一个整数，第 $i$ 行表示第 $i$ 题使用的“锦囊妙计”的编号。\n\n\n如果有多种答案，那么任意输出一种，本题使用 Special Judge 评判答案。", "hint": "感谢 @zhouyonglong 提供 Special Judge", "locale": "zh-CN"}}}
{"pid": "P2320", "type": "P", "difficulty": 4, "samples": [["3\n", "2\n1 2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "各省省选", "湖南", "Special Judge", "进制"], "title": "[HNOI2006] 鬼谷子的钱袋", "background": "", "description": "鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯的特派员前来向他咨询时政。\n\n有一天，他在咸阳游历的时候，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。\n\n但是，他的行程安排得很满，他已经买好了去邯郸的长途马车票，不巧的是出发时间是在拍卖会快要结束的时候。于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。\n\n鬼谷子也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，并且不有两个钱袋装有相同的大于 $1$ 的金币数。假设他有 $m$ 个金币，你能猜到他会用多少个钱袋，并且每个钱袋装多少个金币吗？", "inputFormat": "包含一个整数，表示鬼谷子现有的总的金币数目 $m$。其中，$1 \\le m \\le {10}^9$。", "outputFormat": "两行，第一行一个整数 $h$，表示所用钱袋个数。\n\n第二行表示每个钱袋所装的金币个数，由小到大输出，空格隔开。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2006] Guiguzi's Money Bags", "background": "", "description": "Guiguzi is very clever. Because of this, he is very busy, and envoys from various feudal lords often come to consult him on current affairs.\n\nOne day, while he was traveling in Xianyang, a friend told him that the largest auction house in Xianyang (Jubao Trading House) was about to hold an auction. One of the treasures caught his great interest: the Wordless Heavenly Book.\n\nHowever, his schedule was very tight. He had already bought a long-distance carriage ticket to Handan, and unfortunately the departure time was just as the auction would be ending. Therefore, he decided to prepare in advance: count his gold coins and seal them into small money bags, so that within the limit of his current total coins, he could pay any number of coins by selecting a combination of these sealed small bags.\n\nGuiguzi is also very frugal. He tries to minimize the number of money bags while satisfying the above requirement, and no two bags contain the same number of coins greater than $1$. Suppose he has $m$ gold coins. Can you figure out how many money bags he will use, and how many coins each bag will contain?", "inputFormat": "Contains one integer, representing Guiguzi’s total number of gold coins $m$. Where $1 \\le m \\le 10^9$.", "outputFormat": "Two lines. The first line contains an integer $h$, the number of money bags used.\n\nThe second line contains the number of coins in each bag, output in increasing order and separated by spaces.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2006] 鬼谷子的钱袋", "background": "", "description": "鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯的特派员前来向他咨询时政。\n\n有一天，他在咸阳游历的时候，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。\n\n但是，他的行程安排得很满，他已经买好了去邯郸的长途马车票，不巧的是出发时间是在拍卖会快要结束的时候。于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。\n\n鬼谷子也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，并且不有两个钱袋装有相同的大于 $1$ 的金币数。假设他有 $m$ 个金币，你能猜到他会用多少个钱袋，并且每个钱袋装多少个金币吗？", "inputFormat": "包含一个整数，表示鬼谷子现有的总的金币数目 $m$。其中，$1 \\le m \\le {10}^9$。", "outputFormat": "两行，第一行一个整数 $h$，表示所用钱袋个数。\n\n第二行表示每个钱袋所装的金币个数，由小到大输出，空格隔开。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2321", "type": "P", "difficulty": 6, "samples": [["4\n1  1\n0\n0  0\n2  1\n0\n1  1\n0  0\n3  1\n0\n1  1\n2  2\n0  0\n4  1\n0\n1  1\n2  2\n3  3\n0  0", "3"], ["3\n1  1\n0\n0  0\n3  1\n0\n0  1\n2  0\n1  2\n9  1\n0\n0  1\n2  3\n4  5\n6  7\n8  0\n1  2\n3  4\n5  6\n7  8", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2006", "各省省选", "湖南", "广度优先搜索 BFS", "Tarjan"], "title": "[HNOI2006] 潘多拉的宝盒", "background": null, "description": "传说中，有个神奇的潘多拉宝盒。如果谁能打开，便可以拥有幸福、财富、爱情。可是知道真的打开，才发现与之相岁的还有灾难、不幸。\n\n其实，在潘多拉制造这个宝盒的时候，设置了一些咒语来封锁住灾难与不幸。然而，直到科技高度发达的今天，人们才有希望弄懂这些咒语。所以说，上千年来，人们只得忍受着各种各样的疾病和死亡的痛苦。\n\n然而，人类的命运从此改变了。经过数十年的研究，NOI 组织在最近终于弄清楚了潘多拉咒语的原理。\n\n咒语是由一个叫做咒语机的机器产生的。用现在的名词来解释，咒语机其实就是一个二进制产生器，它产生的一个二进制字符串（这个字符串叫做咒语源）经加密后就形成了咒语。二进制产生器的结构是这样的：\n\n它由 $n$ 个元件组成，不妨设这 $n$ 个元件的标号为 $0$ 到 $n-1$。在每个时刻，都有且仅有一个信号，它停留在某个元件上。一个信号就是一个二进制字符串。最开始，有一个空串信号停留在元件 $0$ 上。在某个时刻，如果有一个信号 $s$ 停留在元件 $i$ 上，那么，这时元件 $i$ 可以将信号后面加一个 $0$，然后把信号传给元件 $p_{i,0}$，也可以将信号后面加一个 $1$，然后传给元件 $p_{i,1}$。也就是说，下一个时刻有可能是一个信号 $S0$（表示字串 $S$ 后面加一个 $0$ 形成的子串）停留在元件 $p_{i,0}$ 上，也可能是有一个信号 $S1$ 停留在元件 $p_{i,1}$ 上。\n\n有的元件可以将停留在它上面的信号输出，而输出的信号就成为了咒语源，这样的元件叫做咒语源输出元。\n\n不难发现，有些咒语源是可能由一个咒语机产生的，而另一些咒语源则不行。\n\n例如，下图的咒语机能产生 $1,11,111,1111,\\dots$ 等咒语源，但是不能产生 $0,10,101$ 等咒语源。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jix6w0lh.png)\n\n在这个盒子上，有 $k$ 个咒语机，不放将这些咒语机从 $0$ 到 $k-1$ 标号。可能有这种情况，一个咒语机 $i$ 能够产生的咒语源，咒语机 $j$ 都能产生。这时，我们称咒语机 $j$ 是咒语机 $i$ 的升级。而衡量这个例子的复杂程度的一种办法是：看这个盒子上升级次数最多的一个咒语机。即：找到一个最长的升级序列 $a_1,a_2,\\dots,a_t$。该升级序列满足：序列中任意两个咒语机的标号都不同，且都是 $0$ 到 $k-1$（包含 $0$ 和 $k-1$）之间的整数，且咒语机 $a_2$ 是咒语机 $a_1$ 的升级，咒语机 $a_3$ 是咒语机 $a_2$ 的升级，……，咒语机 $a_t$ 是咒语机 $a_{t-1}$ 的升级。\n\n你想远离灾难与不幸吗？你想从今以后沐浴幸福的阳光吗？请打开你的潘多拉之盒吧。不过在拱形它之前，你得先计算一下宝盒上最长的升级序列。", "inputFormat": "第一行是一个正整数 $k(1 \\le k \\le 50)$ 表示宝盒上咒语机的个数。\n\n接下来分为 $k$ 个部分：\n\n每个部分第一行是两个正整数 $n,m(1 \\le n,m \\le 50)$，分别表示该咒语机中元件的个数、咒语源输出元的个数。\n\n接下来一行 $m$ 个数，表示 $m$ 个咒语源输出元的标号。\n\n接下来 $n$ 行，第 $i$ 行有两个在 $0$ 到 $n-1$ 之间的正整数 $p_{i,0},p_{i,1}$。", "outputFormat": "输出一行一个数$t$，表示最长升级序列的长度。", "hint": "对于样例 $1$ 的宝盒，有 $4$ 个咒语机，不难发现，第 $i(i=0,1,2,3)$ 个咒语机产生的所有咒语源的长度都是 $(i+1)$ 的倍数。\n\n对于样例 $2$ 的宝盒，有 $3$ 个咒语机，第 $0$ 个能产生所有的咒语源，第 $1$ 个能产生所有化成二进制后是 $3$ 的倍数的咒语源，第 $2$ 个能产生所有化成二进制数后是 $9$ 的倍数的咒语源。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2006] Pandora's Box", "background": "", "description": "Legend has it that there is a magical Pandora's box. Whoever opens it will gain happiness, wealth, and love. However, only after truly opening it did people realize that disaster and misfortune come along with it.\n\nIn fact, when Pandora made this box, she set up some spells to seal away disaster and misfortune. Yet, only in today’s highly advanced scientific age do people have hope of understanding these spells. So for thousands of years, people had no choice but to endure various diseases and the pain of death.\n\nHowever, humanity’s fate has since changed. After decades of research, the NOI organization has finally uncovered the principles behind Pandora’s spells.\n\nThe spells are produced by a machine called a spell machine. In modern terms, a spell machine is essentially a binary generator. The binary string it generates (this string is called a spell source), once encrypted, becomes a spell. The binary generator has the following structure:\n\nIt consists of $n$ components, numbered from $0$ to $n - 1$. At any moment, there is exactly one signal, and it stays at some component. A signal is a binary string. Initially, an empty-string signal stays at component $0$. At some moment, if a signal $s$ is staying at component $i$, then component $i$ may append a 0 to the end of the signal and pass it to component $p_{i,0}$, or append a 1 and pass it to component $p_{i,1}$. That is, at the next moment, either a signal S0 (meaning the string S with a 0 appended) stays at component $p_{i,0}$, or a signal S1 stays at component $p_{i,1}$.\n\nSome components can output the signal staying on them, and the output signal becomes a spell source. Such components are called spell-source output units.\n\nIt is not hard to see that some spell sources can be produced by a given spell machine, while others cannot.\n\nFor example, the spell machine in the figure below can produce spell sources such as 1, 11, 111, 1111, …, but cannot produce 0, 10, 101, etc.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jix6w0lh.png)\n\nOn this box, there are $k$ spell machines, labeled from $0$ to $k - 1$. It may happen that every spell source producible by spell machine $i$ can also be produced by spell machine $j$. In that case, we say machine $j$ is an upgrade of machine $i$. One way to measure the complexity of this instance is to consider the maximum number of upgrades of any spell machine on the box. That is, find a longest upgrade sequence $a_1, a_2, \\dots, a_t$. This upgrade sequence must satisfy: all machine indices in the sequence are distinct, each is an integer between $0$ and $k - 1$ (inclusive), machine $a_2$ is an upgrade of machine $a_1$, machine $a_3$ is an upgrade of machine $a_2$, …, and machine $a_t$ is an upgrade of machine $a_{t-1}$.\n\nDo you want to stay away from disaster and misfortune? Do you want to bask in the sunshine of happiness from now on? Please open your Pandora’s box. But before opening it, you need to compute the longest upgrade sequence on the box.", "inputFormat": "The first line contains a positive integer $k$ $(1 \\le k \\le 50)$, the number of spell machines on the box.\n\nThen follow $k$ parts, one for each machine:\n\n- The first line of each part contains two positive integers $n, m$ $(1 \\le n, m \\le 50)$, the number of components in this spell machine and the number of spell-source output units, respectively.\n- The next line contains $m$ integers, the indices of the $m$ spell-source output units.\n- The next $n$ lines describe transitions. In the $i$-th line, there are two integers $p_{i,0}, p_{i,1}$ between $0$ and $n - 1$ (inclusive).", "outputFormat": "Output one line with a single integer $t$, the length of the longest upgrade sequence.", "hint": "For the first sample’s box, there are $4$ spell machines. It is not hard to see that for the $i$-th ($i = 0, 1, 2, 3$) spell machine, all producible spell sources have lengths that are multiples of $(i + 1)$.\n\nFor the second sample’s box, there are $3$ spell machines: machine $0$ can produce all spell sources; machine $1$ can produce all spell sources whose values, when interpreted as binary, are multiples of $3$; machine $2$ can produce all spell sources whose values, when interpreted as binary, are multiples of $9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2006] 潘多拉的宝盒", "background": null, "description": "传说中，有个神奇的潘多拉宝盒。如果谁能打开，便可以拥有幸福、财富、爱情。可是知道真的打开，才发现与之相岁的还有灾难、不幸。\n\n其实，在潘多拉制造这个宝盒的时候，设置了一些咒语来封锁住灾难与不幸。然而，直到科技高度发达的今天，人们才有希望弄懂这些咒语。所以说，上千年来，人们只得忍受着各种各样的疾病和死亡的痛苦。\n\n然而，人类的命运从此改变了。经过数十年的研究，NOI 组织在最近终于弄清楚了潘多拉咒语的原理。\n\n咒语是由一个叫做咒语机的机器产生的。用现在的名词来解释，咒语机其实就是一个二进制产生器，它产生的一个二进制字符串（这个字符串叫做咒语源）经加密后就形成了咒语。二进制产生器的结构是这样的：\n\n它由 $n$ 个元件组成，不妨设这 $n$ 个元件的标号为 $0$ 到 $n-1$。在每个时刻，都有且仅有一个信号，它停留在某个元件上。一个信号就是一个二进制字符串。最开始，有一个空串信号停留在元件 $0$ 上。在某个时刻，如果有一个信号 $s$ 停留在元件 $i$ 上，那么，这时元件 $i$ 可以将信号后面加一个 $0$，然后把信号传给元件 $p_{i,0}$，也可以将信号后面加一个 $1$，然后传给元件 $p_{i,1}$。也就是说，下一个时刻有可能是一个信号 $S0$（表示字串 $S$ 后面加一个 $0$ 形成的子串）停留在元件 $p_{i,0}$ 上，也可能是有一个信号 $S1$ 停留在元件 $p_{i,1}$ 上。\n\n有的元件可以将停留在它上面的信号输出，而输出的信号就成为了咒语源，这样的元件叫做咒语源输出元。\n\n不难发现，有些咒语源是可能由一个咒语机产生的，而另一些咒语源则不行。\n\n例如，下图的咒语机能产生 $1,11,111,1111,\\dots$ 等咒语源，但是不能产生 $0,10,101$ 等咒语源。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jix6w0lh.png)\n\n在这个盒子上，有 $k$ 个咒语机，不放将这些咒语机从 $0$ 到 $k-1$ 标号。可能有这种情况，一个咒语机 $i$ 能够产生的咒语源，咒语机 $j$ 都能产生。这时，我们称咒语机 $j$ 是咒语机 $i$ 的升级。而衡量这个例子的复杂程度的一种办法是：看这个盒子上升级次数最多的一个咒语机。即：找到一个最长的升级序列 $a_1,a_2,\\dots,a_t$。该升级序列满足：序列中任意两个咒语机的标号都不同，且都是 $0$ 到 $k-1$（包含 $0$ 和 $k-1$）之间的整数，且咒语机 $a_2$ 是咒语机 $a_1$ 的升级，咒语机 $a_3$ 是咒语机 $a_2$ 的升级，……，咒语机 $a_t$ 是咒语机 $a_{t-1}$ 的升级。\n\n你想远离灾难与不幸吗？你想从今以后沐浴幸福的阳光吗？请打开你的潘多拉之盒吧。不过在拱形它之前，你得先计算一下宝盒上最长的升级序列。", "inputFormat": "第一行是一个正整数 $k(1 \\le k \\le 50)$ 表示宝盒上咒语机的个数。\n\n接下来分为 $k$ 个部分：\n\n每个部分第一行是两个正整数 $n,m(1 \\le n,m \\le 50)$，分别表示该咒语机中元件的个数、咒语源输出元的个数。\n\n接下来一行 $m$ 个数，表示 $m$ 个咒语源输出元的标号。\n\n接下来 $n$ 行，第 $i$ 行有两个在 $0$ 到 $n-1$ 之间的正整数 $p_{i,0},p_{i,1}$。", "outputFormat": "输出一行一个数$t$，表示最长升级序列的长度。", "hint": "对于样例 $1$ 的宝盒，有 $4$ 个咒语机，不难发现，第 $i(i=0,1,2,3)$ 个咒语机产生的所有咒语源的长度都是 $(i+1)$ 的倍数。\n\n对于样例 $2$ 的宝盒，有 $3$ 个咒语机，第 $0$ 个能产生所有的咒语源，第 $1$ 个能产生所有化成二进制后是 $3$ 的倍数的咒语源，第 $2$ 个能产生所有化成二进制数后是 $9$ 的倍数的咒语源。", "locale": "zh-CN"}}}
{"pid": "P2322", "type": "P", "difficulty": 5, "samples": [["2\r\nABCD\r\nBCDABC", "ABCDABC"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["字符串", "2006", "各省省选", "湖南", "广度优先搜索 BFS", "AC 自动机", "状压 DP"], "title": "[HNOI2006] 最短母串问题", "background": null, "description": "给定 $n$ 个字符串 $(S_1,S_2,\\dots,S_n)$，要求找到一个最短的字符串 $T$，使得这 $n$ 个字符串 $(S_1,S_2,\\dots,S_n)$ 都是 $T$ 的子串。", "inputFormat": "输入文件第一行是一个整数 $n$，表示给定的字符串个数。接下来 $n$ 行，每行有一个全由大写字母组成的字符串。", "outputFormat": "输出文件只有一行，为找到的最短的字符串 $T$。在保证最短的前提下，如果有多个字符串都满足要求，那么必须输出按字典序排列的第一个。", "hint": "对于 $100\\%$ 的数据，$n\\leq 12$，每个字符串的长度不超过 $50$。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2006] Shortest Superstring Problem", "background": "", "description": "Given $n$ strings $(S_1, S_2, \\dots, S_n)$, find the shortest string $T$ such that all $n$ strings $(S_1, S_2, \\dots, S_n)$ are substrings of $T$.", "inputFormat": "The first line contains an integer $n$, the number of given strings. The next $n$ lines each contain a string consisting only of uppercase letters.", "outputFormat": "Output a single line containing the shortest string $T$. Among all shortest candidates, if there are multiple strings that satisfy the requirement, output the lexicographically smallest one.", "hint": "For $100\\%$ of the testdata, $n \\leq 12$, and the length of each string does not exceed $50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2006] 最短母串问题", "background": null, "description": "给定 $n$ 个字符串 $(S_1,S_2,\\dots,S_n)$，要求找到一个最短的字符串 $T$，使得这 $n$ 个字符串 $(S_1,S_2,\\dots,S_n)$ 都是 $T$ 的子串。", "inputFormat": "输入文件第一行是一个整数 $n$，表示给定的字符串个数。接下来 $n$ 行，每行有一个全由大写字母组成的字符串。", "outputFormat": "输出文件只有一行，为找到的最短的字符串 $T$。在保证最短的前提下，如果有多个字符串都满足要求，那么必须输出按字典序排列的第一个。", "hint": "对于 $100\\%$ 的数据，$n\\leq 12$，每个字符串的长度不超过 $50$。", "locale": "zh-CN"}}}
{"pid": "P2323", "type": "P", "difficulty": 4, "samples": [["4 2 5 \n1 2 6 5\n1 3 3 1\n2 3 9 4\n2 4 6 1", "6 \n1 1 \n2 1 \n4 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "二分", "并查集", "各省省选", "湖南", "Special Judge", "生成树"], "title": "[HNOI2006] 公路修建问题", "background": null, "description": "OI island 是一个非常漂亮的岛屿，自开发以来，到这儿来旅游的人很多。然而，由于该岛屿刚刚开发不久，所以那里的交通情况还是很糟糕。所以，OIER Association组织成立了，旨在建立 OI island 的交通系统。\n\nOI island 有 $n$ 个旅游景点，不妨将它们从 $1$ 到 $n$ 标号。现在，OIER Association 需要修公路将这些景点连接起来。一条公路连接两个景点。公路有两种类型，不妨称它们为一级公路和二级公路。一级公路上的车速快，但是修路的花费要大一些。\n\nOIER Association 打算修 $n-1$ 条公路将这些景点连接起来（使得任意两个景点之间都会有一条路径）。为了保证公路系统的效率，OIER Association 希望在这 $n-1$ 条公路之中，至少有 $k(0\\le k\\le n-1)$ 条一级公路。OIER Association 也不希望为一条公路花费太多的钱。所以，他们希望在满足上述条件的情况下，花费最多的一条公路的花费尽可能的少。而你的任务就是，在给定一些可能修建的公路的情况下，选择 $n-1$ 条公路，满足上面的条件。", "inputFormat": "文件第一行有三个数 $n(1 \\le n \\le 10000)$、$k(0 \\le k \\le n-1)$、$m(n-1 \\le m \\le 20000)$，这些数之间用空格分开。$n$ 和 $k$ 如前所述，$m$ 表示有 $m$ 对景点之间可以修公路。\n\n以下的 $m-1$ 行，每一行有 $4$ 个正整数 $a,b,c_1,c_2$，（$1 \\le a,b \\le n,a \\ne b,1 \\le c_2 \\le c_1 \\le 30000$），表示在景点 $a$ 与 $b$ 之间可以修公路，如果修一级公路，则需要 $c_1$ 的花费，如果修二级公路，则需要 $c_2$ 的花费。\n\n**在实际评测时，将只会有 $m-1$ 行公路**", "outputFormat": "输出第一行有一个数据，表示花费最大的公路的花费。\n\n接下来的 $n-1$ 行，每行有两个正整数 $t$ 和 $p$，$t$ 和 $p$ 表示在输入的第 $t$ 对（按照输入的顺序，从 $1$ 开始标号）景点之间修建 $p$ 级公路。\n\n$n-1$ 条公路的输出必须按 $t$ 的大小递增，如果有多个方案使花费最大的公路花费最小，那么输出任意一个都可以。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2006] Highway Construction Problem", "background": "", "description": "OI island is a very beautiful island, and since its development, many people have come to travel here. However, because the island has only recently been developed, its transportation system is still poor. Therefore, the OIER Association was founded to build the transportation system of OI island.\n\nOI island has $n$ tourist attractions, labeled from $1$ to $n$. Now, the OIER Association needs to build roads to connect these attractions. A road connects two attractions. There are two types of roads, which we call Type 1 roads and Type 2 roads. Cars travel faster on Type 1 roads, but they cost more to build.\n\nThe OIER Association plans to build $n-1$ roads to connect all attractions (so that there is a path between any two attractions). To ensure the efficiency of the road system, the OIER Association wants at least $k$ ($0 \\le k \\le n-1$) of these $n-1$ roads to be Type 1 roads. The OIER Association also does not want any single road to be too expensive. Therefore, under the above conditions, they want the cost of the most expensive road to be as small as possible. Your task is, given some candidate roads, to choose $n-1$ roads that satisfy the above conditions.", "inputFormat": "- The first line contains three numbers $n$ ($1 \\le n \\le 10000$), $k$ ($0 \\le k \\le n-1$), and $m$ ($n-1 \\le m \\le 20000$), separated by spaces. Here $n$ and $k$ are as described above, and $m$ means there are $m$ pairs of attractions between which a road can be built.\n- The following $m-1$ lines each contain four positive integers $a, b, c_1, c_2$ ($1 \\le a, b \\le n$, $a \\ne b$, $1 \\le c_2 \\le c_1 \\le 30000$), indicating that a road can be built between attractions $a$ and $b$. If a Type 1 road is built, the cost is $c_1$; if a Type 2 road is built, the cost is $c_2$.\n- In actual judging, there will be only $m-1$ road entries.", "outputFormat": "- The first line contains a single number, which is the cost of the most expensive road among the chosen roads.\n- The next $n-1$ lines each contain two positive integers $t$ and $p$. Here $t$ and $p$ indicate that on the $t$-th pair of attractions in the input (indexed from $1$ in input order), a Type $p$ road is built.\n- The $n-1$ lines must be output in increasing order of $t$. If multiple solutions achieve the minimal value of the maximum road cost, output any one of them.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2006] 公路修建问题", "background": null, "description": "OI island 是一个非常漂亮的岛屿，自开发以来，到这儿来旅游的人很多。然而，由于该岛屿刚刚开发不久，所以那里的交通情况还是很糟糕。所以，OIER Association组织成立了，旨在建立 OI island 的交通系统。\n\nOI island 有 $n$ 个旅游景点，不妨将它们从 $1$ 到 $n$ 标号。现在，OIER Association 需要修公路将这些景点连接起来。一条公路连接两个景点。公路有两种类型，不妨称它们为一级公路和二级公路。一级公路上的车速快，但是修路的花费要大一些。\n\nOIER Association 打算修 $n-1$ 条公路将这些景点连接起来（使得任意两个景点之间都会有一条路径）。为了保证公路系统的效率，OIER Association 希望在这 $n-1$ 条公路之中，至少有 $k(0\\le k\\le n-1)$ 条一级公路。OIER Association 也不希望为一条公路花费太多的钱。所以，他们希望在满足上述条件的情况下，花费最多的一条公路的花费尽可能的少。而你的任务就是，在给定一些可能修建的公路的情况下，选择 $n-1$ 条公路，满足上面的条件。", "inputFormat": "文件第一行有三个数 $n(1 \\le n \\le 10000)$、$k(0 \\le k \\le n-1)$、$m(n-1 \\le m \\le 20000)$，这些数之间用空格分开。$n$ 和 $k$ 如前所述，$m$ 表示有 $m$ 对景点之间可以修公路。\n\n以下的 $m-1$ 行，每一行有 $4$ 个正整数 $a,b,c_1,c_2$，（$1 \\le a,b \\le n,a \\ne b,1 \\le c_2 \\le c_1 \\le 30000$），表示在景点 $a$ 与 $b$ 之间可以修公路，如果修一级公路，则需要 $c_1$ 的花费，如果修二级公路，则需要 $c_2$ 的花费。\n\n**在实际评测时，将只会有 $m-1$ 行公路**", "outputFormat": "输出第一行有一个数据，表示花费最大的公路的花费。\n\n接下来的 $n-1$ 行，每行有两个正整数 $t$ 和 $p$，$t$ 和 $p$ 表示在输入的第 $t$ 对（按照输入的顺序，从 $1$ 开始标号）景点之间修建 $p$ 级公路。\n\n$n-1$ 条公路的输出必须按 $t$ 的大小递增，如果有多个方案使花费最大的公路花费最小，那么输出任意一个都可以。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2324", "type": "P", "difficulty": 5, "samples": [["2\n10110\n01*11\n10111\n01001\n00000\n01011\n110*1\n01110\n01010\n00100\n", "7\n-1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "2005", "四川", "各省省选", "广度优先搜索 BFS", "启发式搜索", "启发式迭代加深搜索 IDA*", "A*  算法", "折半搜索 meet in the middle"], "title": "[SCOI2005] 骑士精神", "background": null, "description": "在一个 $5\\times 5$ 的棋盘上有 $12$ 个白色的骑士和 $12$ 个黑色的骑士，且有一个空位。在任何时候一个骑士都能按照骑士的走法（它可以走到和他横坐标相差为 $1$，纵坐标相差为 $2$ 或者横坐标相差为 $2$，纵坐标相差为 $1$ 的格子）移动到空位上。\n\n给定一个初始的棋盘，怎样才能经过移动变成如下目标棋盘\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z44a397y.png)\n\n为了体现出骑士精神，他们必须以最小的步数完成任务。", "inputFormat": "第一行有一个正整数 $T$（$T \\le 10$），表示一共有 $T$ 组数据。\n\n接下来有 $T$ 个 $5 \\times 5$ 的矩阵，`0` 表示白色骑士，`1` 表示黑色骑士，`*` 表示空位。两组数据之间没有空行。", "outputFormat": "对于每组数据都输出一行。如果能在 $15$ 步以内（包括 $15$ 步）到达目标状态，则输出步数，否则输出 `-1`。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/1390.png)", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2005] Knight's Spirit", "background": "", "description": "On a $5 \\times 5$ board there are $12$ white knights and $12$ black knights, plus one empty cell. At any time, a knight may move into the empty cell following the knight's move (it can move to a cell where the x-coordinate differs by $1$ and the y-coordinate differs by $2$, or the x-coordinate differs by $2$ and the y-coordinate differs by $1$).\n\nGiven an initial board, how can it be transformed, via moves, into the following target board:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z44a397y.png)\n\nTo embody the \"knight's spirit\", they must finish in the minimal number of moves.", "inputFormat": "The first line contains a positive integer $T$ ($T \\le 10$), indicating there are $T$ test cases.\n\nThen follow $T$ matrices of size $5 \\times 5$, where `0` denotes a white knight, `1` denotes a black knight, and `*` denotes the empty cell. There is no blank line between two test cases.", "outputFormat": "For each test case, output one line. If the target state can be reached within $15$ moves (inclusive), output the minimal number of moves; otherwise, output `-1`.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/1390.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2005] 骑士精神", "background": null, "description": "在一个 $5\\times 5$ 的棋盘上有 $12$ 个白色的骑士和 $12$ 个黑色的骑士，且有一个空位。在任何时候一个骑士都能按照骑士的走法（它可以走到和他横坐标相差为 $1$，纵坐标相差为 $2$ 或者横坐标相差为 $2$，纵坐标相差为 $1$ 的格子）移动到空位上。\n\n给定一个初始的棋盘，怎样才能经过移动变成如下目标棋盘\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z44a397y.png)\n\n为了体现出骑士精神，他们必须以最小的步数完成任务。", "inputFormat": "第一行有一个正整数 $T$（$T \\le 10$），表示一共有 $T$ 组数据。\n\n接下来有 $T$ 个 $5 \\times 5$ 的矩阵，`0` 表示白色骑士，`1` 表示黑色骑士，`*` 表示空位。两组数据之间没有空行。", "outputFormat": "对于每组数据都输出一行。如果能在 $15$ 步以内（包括 $15$ 步）到达目标状态，则输出步数，否则输出 `-1`。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/1390.png)", "locale": "zh-CN"}}}
{"pid": "P2325", "type": "P", "difficulty": 5, "samples": [["8 2 \n1 2 \n2 3 \n1 8 \n8 7 \n8 6 \n4 6 \n6 5 \n", "3 \n2 1 1 3 3 3 3 2 \n2 1 8 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "2005", "四川", "各省省选", "Special Judge", "深度优先搜索 DFS", "栈"], "title": "[SCOI2005] 王室联邦", "background": null, "description": "“余”人国的国王想重新编制他的国家。他想把他的国家划分成若干个省，每个省都由他们王室联邦的一个成员来管理。\n\n他的国家有 $N$ 个城市，编号为 $1\\ldots N$。\n\n一些城市之间有道路相连，任意两个不同的城市之间有且仅有一条直接或间接的道路。\n\n为了防止管理太过分散，每个省至少要有 $B$ 个城市。\n\n为了能有效的管理，每个省最多只有 $3\\times B$ 个城市。\n\n每个省必须有一个省会，这个省会可以位于省内，也可以在该省外。\n\n但是该省的任意一个城市到达省会所经过的道路上的城市（除了最后一个城市，即该省省会）都必须属于该省。\n\n一个城市可以作为多个省的省会。\n\n聪明的你快帮帮这个国王吧！", "inputFormat": "第一行包含两个数 $N,B$。\n\n接下来 $N－1$ 行，每行描述一条边，包含两个数，即这条边连接的两个城市的编号。", "outputFormat": "如果无法满足国王的要求，输出 $0$。\n\n否则第一行输出数 $K$，表示你给出的划分方案中省的个数。\n\n第二行输出 $N$ 个数，第 $I$ 个数表示编号为 $I$ 的城市属于的省的编号。要求城市属于的省的编号在 $[1,K]$ 范围内。\n\n第三行输出 $K$ 个数，表示这 $K$ 个省的省会的城市编号。\n\n如果有多种方案，你可以输出任意一种。", "hint": "对于 $100\\%$ 的数据，$1\\le B\\leq N\\le 10^3$。\n\n感谢 @[FlierKing](/user/9433) 提供 spj。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2005] Royal Federation", "background": "", "description": "The king of the country of the “Yu” people (Yu) plans to reorganize his nation. He wants to divide the country into several provinces, each governed by a member of their royal federation.\n\nThere are $N$ cities, numbered $1\\ldots N$.\n\nSome cities are connected by roads. Between any two distinct cities, there is exactly one simple path (direct or indirect).\n\nTo avoid overly fragmented management, each province must contain at least $B$ cities.\n\nFor effective governance, each province may contain at most $3\\times B$ cities.\n\nEach province must have a capital. The capital may be located inside the province or outside it.\n\nHowever, for any city in the province, all cities on the path to the capital (except the last city, i.e., the capital itself) must belong to that province.\n\nA city may serve as the capital for multiple provinces.\n\nPlease help the king.", "inputFormat": "The first line contains two integers $N,B$.\n\nThe next $N-1$ lines each describe an edge, with two integers giving the indices of the two cities connected by this road.", "outputFormat": "If it is impossible to satisfy the king’s requirements, output $0$.\n\nOtherwise, on the first line output an integer $K$, the number of provinces in your partition.\n\nOn the second line, output $N$ integers. The $I$-th number is the index of the province to which city $I$ belongs. Each index must be in $[1,K]$.\n\nOn the third line, output $K$ integers, the city indices of the capitals of these $K$ provinces.\n\nIf multiple solutions exist, you may output any of them.", "hint": "For $100\\%$ of the testdata, $1\\le B\\leq N\\le 10^3$.\n\nThanks to @[FlierKing](/user/9433) for providing the spj.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2005] 王室联邦", "background": null, "description": "“余”人国的国王想重新编制他的国家。他想把他的国家划分成若干个省，每个省都由他们王室联邦的一个成员来管理。\n\n他的国家有 $N$ 个城市，编号为 $1\\ldots N$。\n\n一些城市之间有道路相连，任意两个不同的城市之间有且仅有一条直接或间接的道路。\n\n为了防止管理太过分散，每个省至少要有 $B$ 个城市。\n\n为了能有效的管理，每个省最多只有 $3\\times B$ 个城市。\n\n每个省必须有一个省会，这个省会可以位于省内，也可以在该省外。\n\n但是该省的任意一个城市到达省会所经过的道路上的城市（除了最后一个城市，即该省省会）都必须属于该省。\n\n一个城市可以作为多个省的省会。\n\n聪明的你快帮帮这个国王吧！", "inputFormat": "第一行包含两个数 $N,B$。\n\n接下来 $N－1$ 行，每行描述一条边，包含两个数，即这条边连接的两个城市的编号。", "outputFormat": "如果无法满足国王的要求，输出 $0$。\n\n否则第一行输出数 $K$，表示你给出的划分方案中省的个数。\n\n第二行输出 $N$ 个数，第 $I$ 个数表示编号为 $I$ 的城市属于的省的编号。要求城市属于的省的编号在 $[1,K]$ 范围内。\n\n第三行输出 $K$ 个数，表示这 $K$ 个省的省会的城市编号。\n\n如果有多种方案，你可以输出任意一种。", "hint": "对于 $100\\%$ 的数据，$1\\le B\\leq N\\le 10^3$。\n\n感谢 @[FlierKing](/user/9433) 提供 spj。", "locale": "zh-CN"}}}
{"pid": "P2326", "type": "P", "difficulty": 4, "samples": [["3\n4\n1 3 5 7\n10\n32 54 21 52 14 25 92 75 14 27\n21\n1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768 65536 131072 262144 524288 1048576\n", "Case #1: 5 \nCase #2: 72\nCase #3: 0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "洛谷原创"], "title": "AKN’s PPAP", "background": null, "description": "> I have a pen, I have an apple. Eh, Apple-Pen!\\\n> I have a pen, I have pineapple. En, Pineapple-Pen!\\\n> Apple-Pen, Pineapple-Pen. Eh, Pen-Pineapple-Apple-Pen!\n\nAkn 最近中毒于一首音乐，于是他买来了一堆苹果来学习这首音乐。Akn 发现，只要边唱这首歌，边做把两个完整的苹果碰在一起的动作，两个苹果就会融合成一个新的大苹果，但是大苹果却不能再融合，因为他的细胞内部结构已经改变。Akn 还发现，当两个苹果融合的时候，苹果的质量会发生一些玄妙的改变，就是与运算（$a \\operatorname{and} b$）。但是，最近他的同学找他要一个苹果吃，Akn 出于好心，准备把他学习 ppap 用的苹果融合成的大苹果给同学吃，好让同学一起中毒于 ppap，而且 Akn 还想让大苹果的质量最大，那么请问 Akn 能给同学吃的苹果质量最大是多少？", "inputFormat": "第一行包含一个整数 $t$，表示数据组数；\n\n接下来 $t$ 组数据，每组数据第一行包含一个整数 $n$，表示 $n$ 个苹果；\n\n第二行包含 $n$ 个整数 $w_i$，表示第 $i$ 个小苹果重 $w_i\\ \\text{kg}$。", "outputFormat": "每组数据输出一行一个整数大苹果最大的质量，注意格式，`Case #x: ans`，`Case` 和 `#` 间有空格，`:` 和 `ans` 之间有空格", "hint": "由于数据包大小限制，故只上传部分数据（第 $1,2,3,4,5,6,7,8,10,11,12,13,16,19,20$ 点）\n\n第一组数据解释：\n\n```plain\n1(2)=1\n3(2)=11\n5(2)=101\n7(2)=111\n```\n选取 $5$ 和 $7$ 进行融合最终得到答案 $5$。\n\n数据范围：\n\n- $10\\%$ 的数据保证，$n \\le 5000, t \\le 1$；\n- 另有 $10\\%$ 的数据保证，$n \\le 2000, t \\le 6$；\n- 另有 $20\\%$ 的数据保证，$a \\le 2^{10}$；\n- 另有 $5\\%$ 的数据保证，$n \\le 10^5, a \\le 2^{20}$，最大的两个数相等；\n- 另有 $20\\%$ 的数据保证，$n \\le 10^4, a \\le 2^{15}$；\n- 另有 $15\\%$ 的数据保证，$n \\le 10^5, a \\le 2^{20}, t \\le 6$；\n- 另有 $15\\%$ 的数据保证，$n \\le 10^5, a \\le 2^{20}, t \\le 12$；\n- $100\\%$ 的数据保证，$n \\le 10^5, a \\le 2^{20}, t \\le 20$。\n\nBy: worcher", "locale": "zh-CN", "translations": {"en": {"title": "AKN’s PPAP", "background": "", "description": "> I have a pen, I have an apple. Eh, Apple-Pen!\\\n> I have a pen, I have pineapple. En, Pineapple-Pen!\\\n> Apple-Pen, Pineapple-Pen. Eh, Pen-Pineapple-Apple-Pen!\n\nAkn has recently become obsessed with a song, so he bought a bunch of apples to learn it. He discovered that as long as he sings the song while making the gesture of bumping two whole apples together, the two apples will fuse into one new big apple. However, the big apple can no longer fuse again because its internal cellular structure has changed. Akn also found that when two apples fuse, the mass of the resulting apple is the bitwise AND operation ($a \\operatorname{and} b$). Recently, one of his classmates asked him for an apple to eat. Out of kindness, Akn plans to give his classmate the big apple formed by fusing the apples he used to learn PPAP, so that the classmate can also get into PPAP. Moreover, Akn wants the mass of the big apple to be as large as possible. What is the maximum mass of the big apple that Akn can give to his classmate?", "inputFormat": "The first line contains an integer $t$, the number of test cases.\n\nFor each of the next $t$ test cases, the first line contains an integer $n$, the number of apples.\n\nThe second line contains $n$ integers $w_i$, where the $i$-th small apple weighs $w_i\\ \\text{kg}$.", "outputFormat": "For each test case, output one line with a single integer, the maximum mass of the big apple. Note the format: `Case #x: ans`. There is a space between `Case` and `#`, and a space between `:` and `ans`.", "hint": "Due to testdata package size limits, only part of the testdata is uploaded (points $1,2,3,4,5,6,7,8,10,11,12,13,16,19,20$).\n\nExplanation for the first test set:\n\n```plain\n1(2)=1\n3(2)=11\n5(2)=101\n7(2)=111\n```\nChoose $5$ and $7$ to fuse, and the final answer is $5$.\n\nConstraints:\n\n- For $10\\%$ of the testdata, $n \\le 5000, t \\le 1$.\n- For another $10\\%$ of the testdata, $n \\le 2000, t \\le 6$.\n- For another $20\\%$ of the testdata, $a \\le 2^{10}$.\n- For another $5\\%$ of the testdata, $n \\le 10^5, a \\le 2^{20}$, and the two largest numbers are equal.\n- For another $20\\%$ of the testdata, $n \\le 10^4, a \\le 2^{15}$.\n- For another $15\\%$ of the testdata, $n \\le 10^5, a \\le 2^{20}, t \\le 6$.\n- For another $15\\%$ of the testdata, $n \\le 10^5, a \\le 2^{20}, t \\le 12$.\n- For $100\\%$ of the testdata, $n \\le 10^5, a \\le 2^{20}, t \\le 20$.\n\nBy: worcher\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "AKN’s PPAP", "background": null, "description": "> I have a pen, I have an apple. Eh, Apple-Pen!\\\n> I have a pen, I have pineapple. En, Pineapple-Pen!\\\n> Apple-Pen, Pineapple-Pen. Eh, Pen-Pineapple-Apple-Pen!\n\nAkn 最近中毒于一首音乐，于是他买来了一堆苹果来学习这首音乐。Akn 发现，只要边唱这首歌，边做把两个完整的苹果碰在一起的动作，两个苹果就会融合成一个新的大苹果，但是大苹果却不能再融合，因为他的细胞内部结构已经改变。Akn 还发现，当两个苹果融合的时候，苹果的质量会发生一些玄妙的改变，就是与运算（$a \\operatorname{and} b$）。但是，最近他的同学找他要一个苹果吃，Akn 出于好心，准备把他学习 ppap 用的苹果融合成的大苹果给同学吃，好让同学一起中毒于 ppap，而且 Akn 还想让大苹果的质量最大，那么请问 Akn 能给同学吃的苹果质量最大是多少？", "inputFormat": "第一行包含一个整数 $t$，表示数据组数；\n\n接下来 $t$ 组数据，每组数据第一行包含一个整数 $n$，表示 $n$ 个苹果；\n\n第二行包含 $n$ 个整数 $w_i$，表示第 $i$ 个小苹果重 $w_i\\ \\text{kg}$。", "outputFormat": "每组数据输出一行一个整数大苹果最大的质量，注意格式，`Case #x: ans`，`Case` 和 `#` 间有空格，`:` 和 `ans` 之间有空格", "hint": "由于数据包大小限制，故只上传部分数据（第 $1,2,3,4,5,6,7,8,10,11,12,13,16,19,20$ 点）\n\n第一组数据解释：\n\n```plain\n1(2)=1\n3(2)=11\n5(2)=101\n7(2)=111\n```\n选取 $5$ 和 $7$ 进行融合最终得到答案 $5$。\n\n数据范围：\n\n- $10\\%$ 的数据保证，$n \\le 5000, t \\le 1$；\n- 另有 $10\\%$ 的数据保证，$n \\le 2000, t \\le 6$；\n- 另有 $20\\%$ 的数据保证，$a \\le 2^{10}$；\n- 另有 $5\\%$ 的数据保证，$n \\le 10^5, a \\le 2^{20}$，最大的两个数相等；\n- 另有 $20\\%$ 的数据保证，$n \\le 10^4, a \\le 2^{15}$；\n- 另有 $15\\%$ 的数据保证，$n \\le 10^5, a \\le 2^{20}, t \\le 6$；\n- 另有 $15\\%$ 的数据保证，$n \\le 10^5, a \\le 2^{20}, t \\le 12$；\n- $100\\%$ 的数据保证，$n \\le 10^5, a \\le 2^{20}, t \\le 20$。\n\nBy: worcher", "locale": "zh-CN"}}}
{"pid": "P2327", "type": "P", "difficulty": 3, "samples": [["2\n1  1", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2005", "四川", "各省省选"], "title": "[SCOI2005] 扫雷", "background": "", "description": "\n相信大家都玩过扫雷的游戏。那是在一个 $n\\times m$ 的矩阵里面有一些雷，要你根据一些信息找出雷来。万圣节到了，“余”人国流行起了一种简单的扫雷游戏，这个游戏规则和扫雷一样，如果某个格子没有雷，那么它里面的数字表示和它 $8$ 连通的格子里面雷的数目。现在棋盘是 $n\\times 2$ 的，第一列里面某些格子是雷，而第二列没有雷，如下图：\n\n![](https://cdn.luogu.com.cn/upload/pic/17825.png )\n\n由于第一列的雷可能有多种方案满足第二列的数的限制，你的任务即根据第二列的信息确定第一列雷有多少种摆放方案。\n\n", "inputFormat": "\n第一行为 $N$，第二行有 $N$ 个数，依次为第二列的格子中的数。（$1\\le N\\le10000$）", "outputFormat": "一个数，即第一列中雷的摆放方案数。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2005] Minesweeper", "background": "", "description": "Most people have played the game Minesweeper. In an $n \\times m$ grid, some cells contain mines. If a cell does not contain a mine, the number in it indicates the number of mines among its $8$-connected neighboring cells. Now the board is $n \\times 2$: some cells in the first column contain mines, and the second column contains no mines, as shown in the figure:\n\n![](https://cdn.luogu.com.cn/upload/pic/17825.png )\n\nSince there may be multiple mine configurations in the first column that satisfy the numbers in the second column, your task is to determine, based on the second column, how many valid configurations there are.", "inputFormat": "The first line contains $N$. The second line contains $N$ integers, in order, which are the numbers in the cells of the second column. $(1 \\le N \\le 10000)$.", "outputFormat": "Output a single integer: the number of valid configurations of mines in the first column.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2005] 扫雷", "background": "", "description": "\n相信大家都玩过扫雷的游戏。那是在一个 $n\\times m$ 的矩阵里面有一些雷，要你根据一些信息找出雷来。万圣节到了，“余”人国流行起了一种简单的扫雷游戏，这个游戏规则和扫雷一样，如果某个格子没有雷，那么它里面的数字表示和它 $8$ 连通的格子里面雷的数目。现在棋盘是 $n\\times 2$ 的，第一列里面某些格子是雷，而第二列没有雷，如下图：\n\n![](https://cdn.luogu.com.cn/upload/pic/17825.png )\n\n由于第一列的雷可能有多种方案满足第二列的数的限制，你的任务即根据第二列的信息确定第一列雷有多少种摆放方案。\n\n", "inputFormat": "\n第一行为 $N$，第二行有 $N$ 个数，依次为第二列的格子中的数。（$1\\le N\\le10000$）", "outputFormat": "一个数，即第一列中雷的摆放方案数。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2328", "type": "P", "difficulty": 5, "samples": [["2  2", "00\n01\n11\n10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "四川", "各省省选", "Special Judge", "枚举", "进制"], "title": "[SCOI2005] 超级格雷码", "background": null, "description": "![](https://cdn.luogu.com.cn/upload/pic/1392.png)", "inputFormat": "只有一行，为两个整数 $n$ 和 $B$。", "outputFormat": "一共 $B^n$ 个行，每行一个 $B$ 进制数，表示你所求得的符合条件的排列。", "hint": "感谢@Night_Aurora 提供SPJ", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2005] Super Gray Code", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1392.png)", "inputFormat": "Only one line, containing two integers $n$ and $B$.", "outputFormat": "A total of $B^n$ lines, each line is a base-$B$ number, representing the ordering that meets the required conditions.", "hint": "Thanks to @Night_Aurora for the SPJ.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2005] 超级格雷码", "background": null, "description": "![](https://cdn.luogu.com.cn/upload/pic/1392.png)", "inputFormat": "只有一行，为两个整数 $n$ 和 $B$。", "outputFormat": "一共 $B^n$ 个行，每行一个 $B$ 进制数，表示你所求得的符合条件的排列。", "hint": "感谢@Night_Aurora 提供SPJ", "locale": "zh-CN"}}}
{"pid": "P2329", "type": "P", "difficulty": 4, "samples": [["4\n30\n40\n50\n25\n10\n15\n16\n17\n18\n19\n20\n21\n25\n24\n30\n", "7"], ["3\n20\n10\n10\n9\n3\n3\n3\n5\n5\n7\n8\n8\n9\n", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2005", "四川", "各省省选", "深度优先搜索 DFS", "剪枝"], "title": "[SCOI2005] 栅栏", "background": "", "description": "\n农夫约翰打算建立一个栅栏将他的牧场给围起来，因此他需要一些特定规格的木材。于是农夫约翰到木材店购买木材。可是木材店老板说他这里只剩下少部分大规格的木板了。不过约翰可以购买这些木板，然后切割成他所需要的规格。而且约翰有一把神奇的锯子，用它来锯木板，不会产生任何损失，也就是说长度为 $10$ 的木板可以切成长度为 $8$ 和 $2$ 的两个木板。\n\n你的任务：给你约翰所需要的木板的规格，还有木材店老板能够给出的木材的规格，求约翰最多能够得到多少他所需要的木板。", "inputFormat": "第一行为整数 $m(m\\leq50)$ 表示木材店老板可以提供多少块木材给约翰。紧跟着 $m$ 行为老板提供的每一块木板的长度。\n\n接下来一行（即第 $m+2$ 行）为整数 $n(n\\leq1000)$，表示约翰需要多少木材。\n\n接下来 $n$ 行表示他所需要的每一块木板的长度。木材的规格小于 $32767$。（对于店老板提供的和约翰需要的每块木板，你只能使用一次）。", "outputFormat": "只有一行，为约翰最多能够得到的符合条件的木板的个数。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2005] Fence", "background": "", "description": "Farmer John plans to build a fence to enclose his pasture, so he needs boards of certain lengths. He goes to a lumber store, but the owner has only a small number of large boards left. John may buy these boards and cut them into the lengths he needs. John has a magic saw that produces no waste; for example, a board of length $10$ can be cut into boards of length $8$ and $2$.\n\nYour task: Given the lengths of the boards John needs and the lengths of the boards available at the store, compute the maximum number of required boards John can obtain.", "inputFormat": "- The first line contains an integer $m$ ($m \\leq 50$), the number of boards the store owner can provide. The next $m$ lines each contain the length of one available board.\n- The next line contains an integer $n$ ($n \\leq 1000$), the number of boards John needs.\n- The next $n$ lines each contain the length of one required board. Each length is less than $32767$. Each available board can be used at most once, and each required board can be fulfilled at most once.", "outputFormat": "Output a single line with the maximum number of boards that meet John's requirements.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2005] 栅栏", "background": "", "description": "\n农夫约翰打算建立一个栅栏将他的牧场给围起来，因此他需要一些特定规格的木材。于是农夫约翰到木材店购买木材。可是木材店老板说他这里只剩下少部分大规格的木板了。不过约翰可以购买这些木板，然后切割成他所需要的规格。而且约翰有一把神奇的锯子，用它来锯木板，不会产生任何损失，也就是说长度为 $10$ 的木板可以切成长度为 $8$ 和 $2$ 的两个木板。\n\n你的任务：给你约翰所需要的木板的规格，还有木材店老板能够给出的木材的规格，求约翰最多能够得到多少他所需要的木板。", "inputFormat": "第一行为整数 $m(m\\leq50)$ 表示木材店老板可以提供多少块木材给约翰。紧跟着 $m$ 行为老板提供的每一块木板的长度。\n\n接下来一行（即第 $m+2$ 行）为整数 $n(n\\leq1000)$，表示约翰需要多少木材。\n\n接下来 $n$ 行表示他所需要的每一块木板的长度。木材的规格小于 $32767$。（对于店老板提供的和约翰需要的每块木板，你只能使用一次）。", "outputFormat": "只有一行，为约翰最多能够得到的符合条件的木板的个数。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2330", "type": "P", "difficulty": 3, "samples": [["4 5\n1 2 3\n1 4 5\n2 4 7\n2 3 6\n3 4 8\n", "3 6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2005", "四川", "并查集", "各省省选", "生成树"], "title": "[SCOI2005] 繁忙的都市", "background": "", "description": "城市 C 是一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造。城市 C 的道路是这样分布的：城市中有 $n$ 个交叉路口，有些交叉路口之间有道路相连，两个交叉路口之间最多有一条道路相连接。这些道路是双向的，且把所有的交叉路口直接或间接的连接起来了。每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造。但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求：\n\n1. 改造的那些道路能够把所有的交叉路口直接或间接的连通起来。\n1. 在满足要求 1 的情况下，改造的道路尽量少。\n1. 在满足要求 1、2 的情况下，改造的那些道路中分值最大的道路分值尽量小。\n\n任务：作为市规划局的你，应当作出最佳的决策，选择哪些道路应当被修建。", "inputFormat": "第一行有两个整数 $n,m$ 表示城市有 $n$ 个交叉路口，$m$ 条道路。\n\n接下来 $m$ 行是对每条道路的描述，$u, v, c$ 表示交叉路口 $u$ 和 $v$ 之间有道路相连，分值为 $c$。", "outputFormat": "两个整数 $s, \\mathit{max}$，表示你选出了几条道路，分值最大的那条道路的分值是多少。", "hint": "### 数据范围及约定\n\n对于全部数据，满足 $1\\le n\\le 300$，$1\\le c\\le 10^4$，$1 \\le m \\le 8000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2005] Busy City", "background": "", "description": "City C is a very busy metropolis, and its roads are heavily congested. The mayor decides to renovate some of the roads. The road network in city C is as follows: there are $n$ intersections in the city. Some pairs of intersections are connected by roads, and there is at most one road between any pair of intersections. These roads are bidirectional and connect all intersections directly or indirectly. Each road has a score $c$: the smaller the score, the more congested the road is and the more it needs renovation. However, the budget is limited, so the mayor wants to renovate as few roads as possible. The requirements are:\n\n1. The renovated roads must connect all intersections directly or indirectly.\n2. Subject to requirement 1, the number of renovated roads should be as small as possible.\n3. Subject to requirements 1 and 2, among the renovated roads, the maximum score should be as small as possible.\n\nTask: As the city planning bureau, you should make the best decision and choose which roads should be renovated.", "inputFormat": "The first line contains two integers $n, m$, meaning there are $n$ intersections and $m$ roads.\n\nEach of the next $m$ lines describes a road with three integers $u, v, c$, meaning there is a road between intersections $u$ and $v$ with score $c$.", "outputFormat": "Output two integers $s, \\mathit{max}$, meaning you selected $s$ roads, and the maximum score among the selected roads is $\\mathit{max}$.", "hint": "Constraints\n\nFor all testdata, $1 \\le n \\le 300$, $1 \\le c \\le 10^4$, $1 \\le m \\le 8000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2005] 繁忙的都市", "background": "", "description": "城市 C 是一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造。城市 C 的道路是这样分布的：城市中有 $n$ 个交叉路口，有些交叉路口之间有道路相连，两个交叉路口之间最多有一条道路相连接。这些道路是双向的，且把所有的交叉路口直接或间接的连接起来了。每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造。但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求：\n\n1. 改造的那些道路能够把所有的交叉路口直接或间接的连通起来。\n1. 在满足要求 1 的情况下，改造的道路尽量少。\n1. 在满足要求 1、2 的情况下，改造的那些道路中分值最大的道路分值尽量小。\n\n任务：作为市规划局的你，应当作出最佳的决策，选择哪些道路应当被修建。", "inputFormat": "第一行有两个整数 $n,m$ 表示城市有 $n$ 个交叉路口，$m$ 条道路。\n\n接下来 $m$ 行是对每条道路的描述，$u, v, c$ 表示交叉路口 $u$ 和 $v$ 之间有道路相连，分值为 $c$。", "outputFormat": "两个整数 $s, \\mathit{max}$，表示你选出了几条道路，分值最大的那条道路的分值是多少。", "hint": "### 数据范围及约定\n\n对于全部数据，满足 $1\\le n\\le 300$，$1\\le c\\le 10^4$，$1 \\le m \\le 8000$。", "locale": "zh-CN"}}}
{"pid": "P2331", "type": "P", "difficulty": 5, "samples": [["3 2 2\r\n1 -3\r\n2 3\r\n-2 3\r\n", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2005", "四川", "各省省选", "前缀和"], "title": "[SCOI2005] 最大子矩阵", "background": "", "description": "这里有一个 $n \\times m$ 的矩阵，请你选出其中 $k$ 个子矩阵，使得这个 $k$ 个子矩阵分值之和最大。\n\n注意：选出的 $k$ 个子矩阵不能相互重叠。", "inputFormat": "第一行为 $n,m,k$，接下来 $n$ 行描述矩阵每行中的每个元素的分值（每个元素的分值的绝对值不超过 $32767$）。", "outputFormat": "只有一行为 $k$ 个子矩阵分值之和最大为多少。", "hint": "对于 $100 \\%$ 的数据，$1 \\leq n \\leq 100$，$1 \\leq m \\leq 2$，$1 \\leq k \\leq 10$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2005] Maximum Submatrix", "background": "", "description": "There is an $n \\times m$ matrix. Please choose $k$ submatrices so that the sum of their scores is maximized. \n\nNote: The chosen $k$ submatrices must be pairwise non-overlapping (no two share any cell).", "inputFormat": "The first line contains $n, m, k$. Each of the next $n$ lines contains $m$ integers, the scores of the elements in the matrix. The absolute value of each element’s score does not exceed $32767$.", "outputFormat": "Output a single line containing the maximum possible sum of the scores of the $k$ submatrices.", "hint": "For $100\\%$ of the testdata, $1 \\leq n \\leq 100$, $1 \\leq m \\leq 2$, $1 \\leq k \\leq 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2005] 最大子矩阵", "background": "", "description": "这里有一个 $n \\times m$ 的矩阵，请你选出其中 $k$ 个子矩阵，使得这个 $k$ 个子矩阵分值之和最大。\n\n注意：选出的 $k$ 个子矩阵不能相互重叠。", "inputFormat": "第一行为 $n,m,k$，接下来 $n$ 行描述矩阵每行中的每个元素的分值（每个元素的分值的绝对值不超过 $32767$）。", "outputFormat": "只有一行为 $k$ 个子矩阵分值之和最大为多少。", "hint": "对于 $100 \\%$ 的数据，$1 \\leq n \\leq 100$，$1 \\leq m \\leq 2$，$1 \\leq k \\leq 10$。", "locale": "zh-CN"}}}
{"pid": "P2332", "type": "P", "difficulty": 5, "samples": [["2 5\n1 2\n3 4\n5 6\n7 8\n", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "四川", "各省省选"], "title": "[SCOI2006] 数字立方体", "background": "", "description": "有一个立方体被分成 $n\\times n\\times n$ 的单位，坐标用 $(X,Y,Z)$ 表示 $(1\\le X,Y,Z\\le n)$。每个单位立方体内有一个绝对值不超过 $10^9$ 的整数。统计有多少个子立方体的所有数之和是 $m$ 的倍数。子立方体即满足 $x_1\\le X\\le x_2$，$y_1\\le Y\\le y_2$，$z_1\\le Z\\le z_2$ 的所有单位立方体集合，其中 $1\\le x_1,x_2,y_1,y_2,z_1,z_2\\le n$。\n", "inputFormat": "第一行有两个整数 $n, m$，表示立方体的边长和作除数的正整数。\n\n以下 $n\\times n$ 行，每行有 $n$ 个整数。首先是 $X=1, Y=1$ 的 $n$ 个单位立方体，然后是 $X=1, Y=2$ 的 $n$ 个…最后是 $X=n, Y=n-1$ 的 $n$ 个和 $X=n$ 和 $Y=n$ 的 $n$ 个，共 $n^3$ 个整数。\n", "outputFormat": "输出仅包含一个数，即所有整数和为 $m$ 的倍数的子立方体的个数。\n", "hint": "### 数据范围及约定\n\n- $30\\%$ 的数据满足 $1\\le n\\le 10$。\n- $100\\%$ 的数据满足 $1\\le n\\le 40$。\n\n对于所有的数据满足 $1\\le m\\le 10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2006] Number Cube", "background": "", "description": "A cube is partitioned into $n\\times n\\times n$ unit cubes, with coordinates denoted by $(X, Y, Z)$ where $1\\le X, Y, Z\\le n$. Each unit cube contains an integer whose absolute value does not exceed $10^9$. Count how many subcubes have the sum of all numbers being a multiple of $m$. A subcube is the set of all unit cubes satisfying $x_1\\le X\\le x_2$, $y_1\\le Y\\le y_2$, $z_1\\le Z\\le z_2$, where $1\\le x_1, x_2, y_1, y_2, z_1, z_2\\le n$.", "inputFormat": "The first line contains two integers $n, m$, representing the edge length of the cube and the positive integer divisor.\n\nThe following $n\\times n$ lines each contain $n$ integers. First come the $n$ unit cubes with $X=1, Y=1$ (i.e., $Z=1,2,\\dots,n$), then $X=1, Y=2$, …, and finally $X=n, Y=n-1$ and $X=n, Y=n$, for a total of $n^3$ integers.", "outputFormat": "Output a single number: the number of subcubes whose sum of integers is a multiple of $m$.", "hint": "### Constraints and Conventions\n\n- $30\\%$ of the testdata satisfies $1\\le n\\le 10$.\n- $100\\%$ of the testdata satisfies $1\\le n\\le 40$.\n\nFor all testdata, $1\\le m\\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2006] 数字立方体", "background": "", "description": "有一个立方体被分成 $n\\times n\\times n$ 的单位，坐标用 $(X,Y,Z)$ 表示 $(1\\le X,Y,Z\\le n)$。每个单位立方体内有一个绝对值不超过 $10^9$ 的整数。统计有多少个子立方体的所有数之和是 $m$ 的倍数。子立方体即满足 $x_1\\le X\\le x_2$，$y_1\\le Y\\le y_2$，$z_1\\le Z\\le z_2$ 的所有单位立方体集合，其中 $1\\le x_1,x_2,y_1,y_2,z_1,z_2\\le n$。\n", "inputFormat": "第一行有两个整数 $n, m$，表示立方体的边长和作除数的正整数。\n\n以下 $n\\times n$ 行，每行有 $n$ 个整数。首先是 $X=1, Y=1$ 的 $n$ 个单位立方体，然后是 $X=1, Y=2$ 的 $n$ 个…最后是 $X=n, Y=n-1$ 的 $n$ 个和 $X=n$ 和 $Y=n$ 的 $n$ 个，共 $n^3$ 个整数。\n", "outputFormat": "输出仅包含一个数，即所有整数和为 $m$ 的倍数的子立方体的个数。\n", "hint": "### 数据范围及约定\n\n- $30\\%$ 的数据满足 $1\\le n\\le 10$。\n- $100\\%$ 的数据满足 $1\\le n\\le 40$。\n\n对于所有的数据满足 $1\\le m\\le 10^6$。\n", "locale": "zh-CN"}}}
