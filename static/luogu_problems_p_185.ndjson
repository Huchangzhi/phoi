{"pid": "P4741", "type": "P", "difficulty": 5, "samples": [["8 65\n-1\n36\n21\n97\n-65\n17\n1\n43", "2"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["素数判断,质数,筛法", "栈"], "title": "[Wind Festival] Finding RhFe", "background": "$[Morning - 8:00 A.M.]$\n\n热衷于结交老铁的 gyx 小哥哥听说了风筝节的举办，一大早就来到了现场，现在他已经迫不及待见到来玩的同学们啦~", "description": "gyx 的人格魅力是无限哒~\n\n已知风筝节上有 $N$（$1\\le N\\le 10^6$）个同学（来玩的人真的很多），每个同学都对 gyx 有一个兴趣程度 $c_i$（$ |c_i|\\le 10^9$），因为 gyx 的性格特点太明显啦，不存在对 gyx 兴趣程度为 $0$ 的同学，对于每个同学，都可以和 gyx 结交为老铁，gyx 的高兴程度就是所有结！交！过！成为老铁的同学对 gyx 兴趣程度之和。gyx 不愿意做令自己伤心的事情，所以如果所有同学对 gyx 感到反感（即兴趣程度为负）gyx 就会直接离开风筝节。\n\ngyx 可以选择其中的 $k$（$1\\le k\\le N$）个同学来结交，但一旦选择好，gyx 的结交顺序就不可以变化了。\n\n因为来风筝节的人实在是太多啦，gyx 不愿意记住所有的老铁太长的时间，但是 gyx 的脑子里记着与越早结交的老铁的点点滴滴越多，也越难忘记，gyx 忘记每个人的条件是当且仅当，在 gyx 还记着的老铁里当前的这个老铁是最后结交的。\n\n但是由于 gyx 希望与更多不同性格的同学结交，gyx 与每一个同学只愿意结交一次，即使遗忘以后也不会再次结交。\n\n当风筝节上 gyx 选择的同学都结交结束后，随着时间的流逝，gyx 也会渐渐地把所有同学都忘掉，遗忘方式与之前相同，直到最后忘记了自己结交过的所有老铁，再出发前往新的征程。\n\n由于不同的交友并遗忘的顺序可能会发生有趣的事情，gyx 想知道在保证自己高兴程度最大时选择好结交范围和结交顺序的情况下，gyx 可以有多少种不同的交友并遗忘的顺序呢？\n\n由于来风筝节的人实在是太多了，gyx 只想知道不同顺序的方案数的值对 $P$（$0<P\\le 10^9$）取模后的结果。", "inputFormat": "第一行是两个数 $N$ 和 $P$，分别表示来风筝节的同学人数和方案数要对P取模；\n\n接下来的 $N$ 行每行一个 $c_i$ 的值，表示第 $i$ 个同学对 gyx 的兴趣程度；", "outputFormat": "如果所有人对 gyx 都感到讨厌输出 `Terrible Place`；\n\n其他情况输出对 $P$ 取模后不同的顺序的方案数的值；", "hint": "对于 $30\\%$ 的数据保证：$1\\le N\\le 30$；\n\n对于 $70\\%$ 的数据保证：$1\\le N\\le 500$；\n\n对于 $100\\%$ 的数据保证：$1\\le N\\le 10^6$，$0<P\\le 10^9$，$|c_i|\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[Wind Festival] Finding RhFe", "background": "$[Morning - 8:00 A.M.]$\n\nThe sociable guy gyx heard that the kite festival was being held and arrived early in the morning. He can’t wait to meet the students who came to have fun.", "description": "The personal charm of gyx is limitless.\n\nAt the kite festival, there are $N$ students ($1 \\le N \\le 10^6$). Each student has an interest level $c_i$ in gyx ($|c_i| \\le 10^9$). Because gyx’s personality is very distinctive, no student has an interest level of $0$. For each student, gyx can befriend them as a \"laotie\". gyx’s happiness is the sum of the interest levels of all the classmates he has befriended as \"laotie\". gyx does not want to do anything that makes him sad, so if all classmates dislike him (i.e., their interest levels are negative), gyx will leave the festival immediately.\n\ngyx may choose $k$ classmates to befriend ($1 \\le k \\le N$), but once the set is chosen, the befriending order must follow their original order.\n\nBecause there are so many people at the festival, gyx does not want to remember all \"laotie\" for too long. He remembers more about those befriended earlier, and they are harder to forget. The condition for gyx to forget someone is if and only if, among the \"laotie\" he still remembers, the current one is the most recently befriended.\n\nHowever, since gyx wants to befriend more classmates with different personalities, he is willing to befriend each classmate at most once. Even after forgetting, he will not befriend them again.\n\nAfter all the students chosen by gyx have been befriended, as time passes, gyx will gradually forget all of them in the same manner as above, until he has forgotten every \"laotie\" he befriended, and then sets off on a new journey.\n\nBecause different sequences of befriending and forgetting may lead to interesting situations, gyx wants to know, while ensuring his happiness is maximized by choosing whom to befriend (thus fixing the order to their original order), how many different sequences of befriending and forgetting are possible.\n\nBecause there are so many people at the festival, gyx only wants the number of different sequences modulo $P$ ($0 < P \\le 10^9$).", "inputFormat": "The first line contains two integers $N$ and $P$, representing the number of students at the festival and the modulus $P$ for the answer.\n\nThe next $N$ lines each contain one value $c_i$, representing the interest level of the $i$-th student in gyx.", "outputFormat": "If everyone dislikes gyx, output `Terrible Place`.\n\nOtherwise, output the number of different sequences modulo $P$.", "hint": "For $30\\%$ of the testdata: $1 \\le N \\le 30$.\n\nFor $70\\%$ of the testdata: $1 \\le N \\le 500$.\n\nFor $100\\%$ of the testdata: $1 \\le N \\le 10^6$, $0 < P \\le 10^9$, $|c_i| \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Wind Festival] Finding RhFe", "background": "$[Morning - 8:00 A.M.]$\n\n热衷于结交老铁的 gyx 小哥哥听说了风筝节的举办，一大早就来到了现场，现在他已经迫不及待见到来玩的同学们啦~", "description": "gyx 的人格魅力是无限哒~\n\n已知风筝节上有 $N$（$1\\le N\\le 10^6$）个同学（来玩的人真的很多），每个同学都对 gyx 有一个兴趣程度 $c_i$（$ |c_i|\\le 10^9$），因为 gyx 的性格特点太明显啦，不存在对 gyx 兴趣程度为 $0$ 的同学，对于每个同学，都可以和 gyx 结交为老铁，gyx 的高兴程度就是所有结！交！过！成为老铁的同学对 gyx 兴趣程度之和。gyx 不愿意做令自己伤心的事情，所以如果所有同学对 gyx 感到反感（即兴趣程度为负）gyx 就会直接离开风筝节。\n\ngyx 可以选择其中的 $k$（$1\\le k\\le N$）个同学来结交，但一旦选择好，gyx 的结交顺序就不可以变化了。\n\n因为来风筝节的人实在是太多啦，gyx 不愿意记住所有的老铁太长的时间，但是 gyx 的脑子里记着与越早结交的老铁的点点滴滴越多，也越难忘记，gyx 忘记每个人的条件是当且仅当，在 gyx 还记着的老铁里当前的这个老铁是最后结交的。\n\n但是由于 gyx 希望与更多不同性格的同学结交，gyx 与每一个同学只愿意结交一次，即使遗忘以后也不会再次结交。\n\n当风筝节上 gyx 选择的同学都结交结束后，随着时间的流逝，gyx 也会渐渐地把所有同学都忘掉，遗忘方式与之前相同，直到最后忘记了自己结交过的所有老铁，再出发前往新的征程。\n\n由于不同的交友并遗忘的顺序可能会发生有趣的事情，gyx 想知道在保证自己高兴程度最大时选择好结交范围和结交顺序的情况下，gyx 可以有多少种不同的交友并遗忘的顺序呢？\n\n由于来风筝节的人实在是太多了，gyx 只想知道不同顺序的方案数的值对 $P$（$0<P\\le 10^9$）取模后的结果。", "inputFormat": "第一行是两个数 $N$ 和 $P$，分别表示来风筝节的同学人数和方案数要对P取模；\n\n接下来的 $N$ 行每行一个 $c_i$ 的值，表示第 $i$ 个同学对 gyx 的兴趣程度；", "outputFormat": "如果所有人对 gyx 都感到讨厌输出 `Terrible Place`；\n\n其他情况输出对 $P$ 取模后不同的顺序的方案数的值；", "hint": "对于 $30\\%$ 的数据保证：$1\\le N\\le 30$；\n\n对于 $70\\%$ 的数据保证：$1\\le N\\le 500$；\n\n对于 $100\\%$ 的数据保证：$1\\le N\\le 10^6$，$0<P\\le 10^9$，$|c_i|\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4742", "type": "P", "difficulty": 4, "samples": [["5 5\n8 9 11 6 7\n1 2\n2 3\n2 4\n4 5\n5 2", "41 11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论建模", "拓扑排序", "强连通分量"], "title": "[Wind Festival] Running In The Sky", "background": "$[Night - 20:02$ $P.M.]$\n\n夜空真美啊……但是……快要结束了呢……", "description": "一天的活动过后，所有学生都停下来欣赏夜空下点亮的风筝。$Curtis$ $Nishikino$想要以更近的视角感受一下，所以她跑到空中的风筝上去了(这对于一个妹子来说有点匪夷所思)! 每只风筝上的灯光都有一个亮度 $k_i$. 由于风的作用，一些风筝缠在了一起。但是这并不会破坏美妙的气氛，缠在一起的风筝会将灯光汇聚起来，形成更亮的光源！\n\n$Curtis$ $Nishikino$已经知道了一些风筝间的关系，比如给出一对风筝$(a,b)$, 这意味着她可以从 $a$ 跑到 $b$ 上去，但是不能返回。\n\n现在，请帮她找到一条路径(她可以到达一只风筝多次，但只在第一次到达时她会去感受上面的灯光), 使得她可以感受到最多的光亮。同时请告诉她这条路径上单只风筝的最大亮度，如果有多条符合条件的路径，输出能产生最大单只风筝亮度的答案。", "inputFormat": "第一行两个整数 $n$ 和 $m$. $n$ 是风筝的数量, $m$ 是风筝间关系对的数量. \n\n接下来一行 $n$ 个整数 $k_i$.\n\n接下来 $m$ 行, 每行两个整数 $a$ 和 $b$, 即$Curtis$可以从 $a$ 跑到 $b$.", "outputFormat": "一行两个整数。$Curtis$在计算出的路径上感受到的亮度和，这条路径上的单只风筝最大亮度.", "hint": "对于 $20\\%$ 的数据, $0<n \\le 5\\times10^3, \\ 0 < m \\le 10^4$.\n\n对于 $80\\%$ 的数据, $0 < n \\le 10^5, \\ 0 < m \\le 3\\times10^5$.\n\n对于 $100\\%$ 的数据, $0<n\\le2\\times10^5,\\ 0<m\\le5\\times10^5,\\ 0<k\\le200$.\n", "locale": "zh-CN", "translations": {"en": {"title": "[Wind Festival] Running In The Sky", "background": "[Night - 20:02 P.M.]\n\nThe night sky is so beautiful... but... it is about to end soon....", "description": "After a day of activities, all the students stop to admire the kites lit up under the night sky. Curtis Nishikino wants to experience it from a closer view, so she runs onto the kites in the sky (which is a bit unbelievable for a girl)! Each kite’s light has a brightness $k_i$. Because of the wind, some kites get tangled together. This does not ruin the mood—tangled kites pool their lights to form a brighter light source.\n\nCurtis Nishikino already knows some relations between the kites: for a given pair of kites $(a, b)$, she can run from $a$ to $b$, but she cannot return.\n\nNow, please help her find a path (she may reach a kite multiple times, but only the first arrival counts toward the light she experiences) so that she experiences the maximum total brightness. Also tell her the maximum brightness of a single kite on this path. If there are multiple paths that achieve the same total brightness, output the answer that yields the maximum single-kite brightness.", "inputFormat": "The first line contains two integers $n$ and $m$. Here, $n$ is the number of kites, and $m$ is the number of relation pairs.\n\nThe next line contains $n$ integers $k_i$.\n\nEach of the next $m$ lines contains two integers $a$ and $b$, meaning Curtis can run from $a$ to $b$.", "outputFormat": "Output one line with two integers: the total brightness Curtis experiences along the computed path, and the maximum brightness of a single kite on that path.", "hint": "For $20\\%$ of the testdata, $0<n \\le 5\\times10^3, \\ 0 < m \\le 10^4$.\n\nFor $80\\%$ of the testdata, $0 < n \\le 10^5, \\ 0 < m \\le 3\\times10^5$.\n\nFor $100\\%$ of the testdata, $0<n\\le2\\times10^5,\\ 0<m\\le5\\times10^5,\\ 0<k_i\\le200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Wind Festival] Running In The Sky", "background": "$[Night - 20:02$ $P.M.]$\n\n夜空真美啊……但是……快要结束了呢……", "description": "一天的活动过后，所有学生都停下来欣赏夜空下点亮的风筝。$Curtis$ $Nishikino$想要以更近的视角感受一下，所以她跑到空中的风筝上去了(这对于一个妹子来说有点匪夷所思)! 每只风筝上的灯光都有一个亮度 $k_i$. 由于风的作用，一些风筝缠在了一起。但是这并不会破坏美妙的气氛，缠在一起的风筝会将灯光汇聚起来，形成更亮的光源！\n\n$Curtis$ $Nishikino$已经知道了一些风筝间的关系，比如给出一对风筝$(a,b)$, 这意味着她可以从 $a$ 跑到 $b$ 上去，但是不能返回。\n\n现在，请帮她找到一条路径(她可以到达一只风筝多次，但只在第一次到达时她会去感受上面的灯光), 使得她可以感受到最多的光亮。同时请告诉她这条路径上单只风筝的最大亮度，如果有多条符合条件的路径，输出能产生最大单只风筝亮度的答案。", "inputFormat": "第一行两个整数 $n$ 和 $m$. $n$ 是风筝的数量, $m$ 是风筝间关系对的数量. \n\n接下来一行 $n$ 个整数 $k_i$.\n\n接下来 $m$ 行, 每行两个整数 $a$ 和 $b$, 即$Curtis$可以从 $a$ 跑到 $b$.", "outputFormat": "一行两个整数。$Curtis$在计算出的路径上感受到的亮度和，这条路径上的单只风筝最大亮度.", "hint": "对于 $20\\%$ 的数据, $0<n \\le 5\\times10^3, \\ 0 < m \\le 10^4$.\n\n对于 $80\\%$ 的数据, $0 < n \\le 10^5, \\ 0 < m \\le 3\\times10^5$.\n\n对于 $100\\%$ 的数据, $0<n\\le2\\times10^5,\\ 0<m\\le5\\times10^5,\\ 0<k\\le200$.\n", "locale": "zh-CN"}}}
{"pid": "P4743", "type": "P", "difficulty": 6, "samples": [["4 4\n4 0 1 1 2 2 2 3 1\n2 0 1 2 1\n0\n2 1 2 3 1\n5\nQA\nI 2 \n2 1 1 3 2\nQS 2 4\nQA\nQS 1 1", "4\n1 1 1 2\n5\n1 2 2 1\nend"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["平衡树", "树状数组", "O2优化", "枚举"], "title": "[Wind Festival] Energy Center", "background": "$[Noon - 12:13$ $P.M.]$\n\n$Curtis$ $Nishikino$看到大家为晚会准备地如此认真，~~可爱的~~她也做起了志愿者！", "description": "$Curtis$ $Nishikino$来到了风筝节的能源中心，大家正在为晚会做准备. 这里共有 $N$ 台设备. 当然，由于计划的调整，可能会随时发生增删设备的操作. 但设备的总数不会超过$10^4$. 随时记录设备的数量也是志愿者的工作之一.\n\n每台设备都有一些属性，比如设备$i$, 对于她拥有的每个属性, 比如属性$j$, 都会有一个给定的值, 记为$value_{ij}$.但属性是共有的, 这意味着即便一台设备没有某个属性, 也只会使她这个属性的值为$0$. 属性的数量是$M$. 注意属性的编号是从$0$到$M-1$.\n\n现在志愿者们正尝试将一部分相邻设备联系在一起，效果如下：\n\n- 对于从$j$到$k$的设备, 最终效果$i$的值为 $\\sum_{p=j}^{k}value_{pi}$.\n\n志愿者需要$Curtis$帮忙，但做计算太麻烦了，$Curtis$ $Nishikino$也希望你能帮帮她.", "inputFormat": "第一行两个整数 $n$ 和 $m$.\n\n接下来 $n$ 行, 第一个整数 $k_i$,这意味着设备 $i$ 有 $k_i$ 个属性. 后面是 $2\\times k$ 个整数, $x_j$ 和 $y_j$, 这意味着 $value_{ix_j}=y_j$.\n\n下面是一个整数 $q$, 即 $q$ 个操作. 每项操作都是如下之一:\n\n$I$ $x$ :在设备 $x$ 后插入一台设备, 下面有一行描述信息，像初始化一样.\n\n$D$ $x$:丢弃第 $x$ 台设备.\n\n$QA$ :询问设备总数.\n\n$QS$ $l$ $r$: 询问连接设备 $l$ 到 $r$ 的效果.\n\n输入数据保证合法.", "outputFormat": "对于每个 $QA$, 输出一行一个整数.\n\n对于每个 $QS$, 输出一行 $m$ 个整数, 如果属性 $i$ 的值是 $0$, 在那个位置输出 $0$ 即可.\n\n###### 注意！\n\n请在完成所有操作后输出一行额外的 \"end\" (不包含双引号).", "hint": "对于 $15\\%$ 的数据, $0 < N \\le 10^3\\ , \\ 0<M \\le 10\\ , \\ 0 < q \\le 10^3$.\n\n对于额外的 $5\\%$ 数据, $0<N \\le 10^4\\ , \\ 0<M \\le 200\\ , \\ 0 < q \\le 10^4$, 保证没有 $QS$ 操作.\n\n对于 $100\\%$ 的数据, $0<N \\le 10^4\\ ,\\ 0<M \\le 200\\ , \\ 0<q\\le10^4$.", "locale": "zh-CN", "translations": {"en": {"title": "[Wind Festival] Energy Center", "background": "$[Noon - 12:13$ $P.M.]$\n\n$Curtis$ $Nishikino$ saw everyone preparing so seriously for the party, so this ~~cute~~ girl also became a volunteer!", "description": "$Curtis$ $Nishikino$ came to the energy center of the kite festival, where everyone is preparing for the party. There are a total of $N$ devices here. Of course, due to changes in the plan, devices may be added or removed at any time. However, the total number of devices will not exceed $10^4$. Keeping track of the number of devices at any time is also one of the volunteer's jobs.\n\nEach device has some attributes. For example, for device $i$, for each attribute it has (say attribute $j$), there is a given value, denoted as $value_{ij}$. But attributes are shared, which means that even if a device does not have a certain attribute, it only makes its value for that attribute equal to $0$. The number of attributes is $M$. Note that the attribute indices range from $0$ to $M-1$.\n\nNow the volunteers are trying to connect a consecutive segment of devices together, with the following effect:\n\n- For devices from $j$ to $k$, the final value of attribute $i$ is $\\sum_{p=j}^{k}value_{pi}$.\n\nThe volunteers need $Curtis$'s help, but doing the calculations is too troublesome. $Curtis$ $Nishikino$ also hopes you can help her.", "inputFormat": "The first line contains two integers $n$ and $m$.\n\nIn the next $n$ lines, the first integer is $k_i$, meaning device $i$ has $k_i$ attributes. Then there are $2\\times k$ integers, $x_j$ and $y_j$, meaning $value_{ix_j}=y_j$.\n\nThen there is an integer $q$, meaning there are $q$ operations. Each operation is one of the following:\n\n$I$ $x$: Insert a device after device $x$. The next line contains its description, the same as initialization.\n\n$D$ $x$: Discard the $x$-th device.\n\n$QA$: Query the total number of devices.\n\n$QS$ $l$ $r$: Query the effect of connecting devices $l$ to $r$.\n\nThe input is guaranteed to be valid.", "outputFormat": "For each $QA$, output one integer on a single line.\n\nFor each $QS$, output $m$ integers on one line. If the value of attribute $i$ is $0$, output $0$ at that position.\n\n###### Note！\n\nAfter completing all operations, please output one extra line: \"end\" (without the double quotes).", "hint": "For $15\\%$ of the testdata, $0 < N \\le 10^3\\ , \\ 0<M \\le 10\\ , \\ 0 < q \\le 10^3$.\n\nFor an additional $5\\%$ of the testdata, $0<N \\le 10^4\\ , \\ 0<M \\le 200\\ , \\ 0 < q \\le 10^4$, and it is guaranteed that there are no $QS$ operations.\n\nFor $100\\%$ of the testdata, $0<N \\le 10^4\\ ,\\ 0<M \\le 200\\ , \\ 0<q\\le10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Wind Festival] Energy Center", "background": "$[Noon - 12:13$ $P.M.]$\n\n$Curtis$ $Nishikino$看到大家为晚会准备地如此认真，~~可爱的~~她也做起了志愿者！", "description": "$Curtis$ $Nishikino$来到了风筝节的能源中心，大家正在为晚会做准备. 这里共有 $N$ 台设备. 当然，由于计划的调整，可能会随时发生增删设备的操作. 但设备的总数不会超过$10^4$. 随时记录设备的数量也是志愿者的工作之一.\n\n每台设备都有一些属性，比如设备$i$, 对于她拥有的每个属性, 比如属性$j$, 都会有一个给定的值, 记为$value_{ij}$.但属性是共有的, 这意味着即便一台设备没有某个属性, 也只会使她这个属性的值为$0$. 属性的数量是$M$. 注意属性的编号是从$0$到$M-1$.\n\n现在志愿者们正尝试将一部分相邻设备联系在一起，效果如下：\n\n- 对于从$j$到$k$的设备, 最终效果$i$的值为 $\\sum_{p=j}^{k}value_{pi}$.\n\n志愿者需要$Curtis$帮忙，但做计算太麻烦了，$Curtis$ $Nishikino$也希望你能帮帮她.", "inputFormat": "第一行两个整数 $n$ 和 $m$.\n\n接下来 $n$ 行, 第一个整数 $k_i$,这意味着设备 $i$ 有 $k_i$ 个属性. 后面是 $2\\times k$ 个整数, $x_j$ 和 $y_j$, 这意味着 $value_{ix_j}=y_j$.\n\n下面是一个整数 $q$, 即 $q$ 个操作. 每项操作都是如下之一:\n\n$I$ $x$ :在设备 $x$ 后插入一台设备, 下面有一行描述信息，像初始化一样.\n\n$D$ $x$:丢弃第 $x$ 台设备.\n\n$QA$ :询问设备总数.\n\n$QS$ $l$ $r$: 询问连接设备 $l$ 到 $r$ 的效果.\n\n输入数据保证合法.", "outputFormat": "对于每个 $QA$, 输出一行一个整数.\n\n对于每个 $QS$, 输出一行 $m$ 个整数, 如果属性 $i$ 的值是 $0$, 在那个位置输出 $0$ 即可.\n\n###### 注意！\n\n请在完成所有操作后输出一行额外的 \"end\" (不包含双引号).", "hint": "对于 $15\\%$ 的数据, $0 < N \\le 10^3\\ , \\ 0<M \\le 10\\ , \\ 0 < q \\le 10^3$.\n\n对于额外的 $5\\%$ 数据, $0<N \\le 10^4\\ , \\ 0<M \\le 200\\ , \\ 0 < q \\le 10^4$, 保证没有 $QS$ 操作.\n\n对于 $100\\%$ 的数据, $0<N \\le 10^4\\ ,\\ 0<M \\le 200\\ , \\ 0<q\\le10^4$.", "locale": "zh-CN"}}}
{"pid": "P4744", "type": "P", "difficulty": 6, "samples": [["6 2\n2 -4 3 -1 2 3\n", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "单调队列"], "title": "[Wind Festival] Iron Man", "background": "[Midnight - 23:59]\n\n在风筝节上交到了老铁(并不是 Nishikino)，接触了 OI，gyx 全身的热情都被点燃啦！！为了更好地参与到下一届风筝节的工作中去，gyx 准备开始为期一年的学习。\n", "description": "gyx 想用全部的时间学(tui)OI(fei)!!!\n\ngyx 为了合理的利用所有时间学 OI，他开始规划自己的学习计划。\n\n首先，gyx 的眼里每年有 $n$ 天，因为 gyx 实在是太想学习啦，所以他并没有留下玩耍的时间（每天都全部用来学 OI 或者文化课），gyx 划分天数的原则是，在每一天中，gyx 对 OI 的感兴趣程度相同。但是，未免 gyx 也会因生活琐事而没法静心学习，所以某些天 gyx 对 OI 的兴趣程度有可能是负的。\n\n然后，gyx 开始安排学习 OI 的时间，gyx 统计出他要学习的OI 知识有 $k$ 种。因为 gyx 是一个追求完美的人，他认为对于每一种 OI 知识，知识体系的完整性是必要的，某一个部分的 OI 知识学习过程中一旦停下来会影响自己的学习效果，所以他会用连续的一些天来学习一个部分的知识，期间不能停下来学习文化课，也不会穿插着进行几种知识的学习。\n\n但是注意，gyx 在进行每部分 OI 知识的学习之间可以留出一些时间段用来学文化课。并且，gyx 并不介意各个部分 OI 知识间学习的顺序，因为他对每一部分的 OI 知识兴趣程度是相同的。\n\n现在，gyx 想知道他总共用于学 OI 的日子兴趣值之和是多少，因为 gyx 还没有学习过高级的规划算法，所以 gyx 将他学习计划的规划交给你，你可以选择任意一个小于等于 $n$ 的一个正整数 $i$，使他从第 $i$ 天开始，进行长 $n$ 天的学习（不一定一开始就必须学 OI），但在这一年中他一定要把清单中所有的知识都学完，gyx 相信你一定能给出兴趣值之和最高的方法。\n\n", "inputFormat": "两个正整数 $n,k$，分别代表 gyx 眼中一年有 $n$ 天，gyx 要学习的知识有 $k$ 种。\n\n接下来一行有 $n$ 个整数，第 $i$ 个数 $a_i$ 代表 gyx 第 $i$ 天对 OI 的兴趣程度。", "outputFormat": "输出一个整数，代表他总共学 OI 的所有日子兴趣值之和最大是多少。", "hint": "### 样例解释\n\n从第 $3$ 个时间段开始学习，那么他学 OI 的这一年兴趣程度的序列便为：\n\n- $[3,-1,2,3,2,-4]$。\n\n用于学习两个知识的时间段分别是新序列的第 $1$ 个和第 $3,4,5$ 个，于是 $ans=3+(2+3+2)=10$。\n\n### 数据范围\n\n- 对于 $10\\%$ 的数据，满足 $k=1$；\n- 对于另 $30\\%$ 的数据，满足 $k=2$；\n- 对于$100\\%$ 的数据，满足：$1\\le k\\le50$，$k\\le n\\le10^5$，$|a_i|\\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[Wind Festival] Iron Man", "background": "[Midnight - 23:59]\n\nAt the kite festival, gyx made some good buddies (not Nishikino), got in touch with OI, and all of his passion was ignited!! To better take part in the work for the next kite festival, gyx is ready to start a one-year study plan.", "description": "gyx wants to use all his time to study (slack off on) OI (waste time)!!!\n\nTo use all his time reasonably to study OI, he starts planning his study schedule.\n\nFirst, in gyx's eyes, each year has $n$ days. Because gyx really wants to study, he does not leave any time for entertainment (every day is fully used for studying OI or cultural courses). His rule for dividing days is: within each day, gyx's level of interest in OI is the same. However, since gyx may be unable to focus due to trivial life matters, on some days his interest in OI may be negative.\n\nThen, gyx starts arranging the time for studying OI. He counts that there are $k$ types of OI knowledge he needs to learn. Because gyx pursues perfection, he believes that for each type of OI knowledge, the completeness of the knowledge system is necessary. If he stops in the middle of learning a part of OI knowledge, it will affect his learning results. Therefore, he will use several consecutive days to learn one part of knowledge. During this period, he cannot stop to study cultural courses, and he will not mix learning multiple types of knowledge.\n\nNote that between learning different parts of OI knowledge, gyx can leave some time periods to study cultural courses. Also, gyx does not care about the order of learning different parts of OI knowledge, because his interest level is the same for each part of OI knowledge.\n\nNow, gyx wants to know the sum of interest values over all days he spends studying OI. Since gyx has not learned advanced planning algorithms, he hands the planning of his study schedule to you. You may choose any positive integer $i \\le n$ so that he starts from day $i$ and studies for $n$ days (he does not have to study OI at the beginning). However, within this year, he must finish learning all the knowledge on the list. gyx believes you can surely give a plan with the maximum possible sum of interest values.", "inputFormat": "Two positive integers $n, k$, representing that in gyx's eyes a year has $n$ days, and there are $k$ types of knowledge he needs to learn.\n\nThe next line contains $n$ integers. The $i$-th number $a_i$ represents gyx's interest level in OI on day $i$.", "outputFormat": "Output one integer, representing the maximum possible sum of interest values over all days he studies OI.", "hint": "### Sample Explanation\n\nStarting to study from the $3$-rd time period, the interest sequence for that year of studying OI becomes:\n\n- $[3,-1,2,3,2,-4]$.\n\nThe time periods used to learn the two types of knowledge are the $1$-st, and the $3, 4, 5$-th elements of the new sequence, so $ans = 3 + (2 + 3 + 2) = 10$.\n\n### Constraints\n\n- For $10\\%$ of the testdata, $k = 1$ holds.\n- For another $30\\%$ of the testdata, $k = 2$ holds.\n- For $100\\%$ of the testdata: $1 \\le k \\le 50$, $k \\le n \\le 10^5$, $|a_i| \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Wind Festival] Iron Man", "background": "[Midnight - 23:59]\n\n在风筝节上交到了老铁(并不是 Nishikino)，接触了 OI，gyx 全身的热情都被点燃啦！！为了更好地参与到下一届风筝节的工作中去，gyx 准备开始为期一年的学习。\n", "description": "gyx 想用全部的时间学(tui)OI(fei)!!!\n\ngyx 为了合理的利用所有时间学 OI，他开始规划自己的学习计划。\n\n首先，gyx 的眼里每年有 $n$ 天，因为 gyx 实在是太想学习啦，所以他并没有留下玩耍的时间（每天都全部用来学 OI 或者文化课），gyx 划分天数的原则是，在每一天中，gyx 对 OI 的感兴趣程度相同。但是，未免 gyx 也会因生活琐事而没法静心学习，所以某些天 gyx 对 OI 的兴趣程度有可能是负的。\n\n然后，gyx 开始安排学习 OI 的时间，gyx 统计出他要学习的OI 知识有 $k$ 种。因为 gyx 是一个追求完美的人，他认为对于每一种 OI 知识，知识体系的完整性是必要的，某一个部分的 OI 知识学习过程中一旦停下来会影响自己的学习效果，所以他会用连续的一些天来学习一个部分的知识，期间不能停下来学习文化课，也不会穿插着进行几种知识的学习。\n\n但是注意，gyx 在进行每部分 OI 知识的学习之间可以留出一些时间段用来学文化课。并且，gyx 并不介意各个部分 OI 知识间学习的顺序，因为他对每一部分的 OI 知识兴趣程度是相同的。\n\n现在，gyx 想知道他总共用于学 OI 的日子兴趣值之和是多少，因为 gyx 还没有学习过高级的规划算法，所以 gyx 将他学习计划的规划交给你，你可以选择任意一个小于等于 $n$ 的一个正整数 $i$，使他从第 $i$ 天开始，进行长 $n$ 天的学习（不一定一开始就必须学 OI），但在这一年中他一定要把清单中所有的知识都学完，gyx 相信你一定能给出兴趣值之和最高的方法。\n\n", "inputFormat": "两个正整数 $n,k$，分别代表 gyx 眼中一年有 $n$ 天，gyx 要学习的知识有 $k$ 种。\n\n接下来一行有 $n$ 个整数，第 $i$ 个数 $a_i$ 代表 gyx 第 $i$ 天对 OI 的兴趣程度。", "outputFormat": "输出一个整数，代表他总共学 OI 的所有日子兴趣值之和最大是多少。", "hint": "### 样例解释\n\n从第 $3$ 个时间段开始学习，那么他学 OI 的这一年兴趣程度的序列便为：\n\n- $[3,-1,2,3,2,-4]$。\n\n用于学习两个知识的时间段分别是新序列的第 $1$ 个和第 $3,4,5$ 个，于是 $ans=3+(2+3+2)=10$。\n\n### 数据范围\n\n- 对于 $10\\%$ 的数据，满足 $k=1$；\n- 对于另 $30\\%$ 的数据，满足 $k=2$；\n- 对于$100\\%$ 的数据，满足：$1\\le k\\le50$，$k\\le n\\le10^5$，$|a_i|\\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P4745", "type": "P", "difficulty": 6, "samples": [["4 4\n1 2\n1 3\n2 4\n3 4", "3.0000000000"], ["5 8\n1 2\n1 3\n1 4\n2 3\n2 4\n3 5\n5 4\n2 5", "4.1111111111\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "Special Judge", "ICPC", "CERC"], "title": "[CERC2017] Gambling Guide", "background": "", "description": "A railroad network in a nearby country consists of $n$ cities numbered $1$ through $n$, and $m$ two-way railroad tracks each connecting two different cities. Tickets can only be purchased at automated machines installed at every city. Unfortunately, hackers have tampered with the ticket machines and now they all work as follows: when a single coin is inserted in the machine installed at city $a$, the machine dispenses a single one-way ticket from $a$ to a random neighboring city. More precisely, the destination city is chosen uniformly at random among all cities directly connected to a with a railroad track. Destinations on different tickets originating in the same city are independent.\n\nA computer science student needs to travel from city $1$ (where she lives) to city $n$ (where a regional programming contest has already started). She knows how the machines work (but of course cannot predict the random choices) and has a map of the railway network. In each city, when she purchases a ticket, she can either immediately use it and travel to the destination city on the ticket, or discard the ticket and purchase a new one. She can keep purchasing tickets indefinitely. The trip is finished as soon as she reaches city $n$.\n\nAfter doing some calculations, she has devised a traveling strategy with the following properties:\n  - The probability that the trip will eventually finish is $1$.\n  - The expected number of coins spent on the trip is the smallest possible.\n\nFind the expected number of coins she will spend on the trip.", "inputFormat": "The first line contains two integers $n$ and $m(1 \\le n,m \\le 300 000)$ — the number of cities and the number of railroad tracks. Each of the following $m$ lines contains two different integers $a$ and $b(1 \\le a, b \\le n)$ which describe a railroad track connecting cities $a$ and $b$. \n\nThere will be at most one railroad track between each pair of cities. It will be possible to reach city $n$ starting from city $1$.", "outputFormat": "Output a single number — the expected number of coins spent. The solution will be accepted if the absolute or the relative difference from the judges solution is less than $10^{-6}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2017] Gambling Guide", "background": "", "description": "A railroad network in a nearby country consists of $n$ cities numbered $1$ through $n$, and $m$ two-way railroad tracks each connecting two different cities. Tickets can only be purchased at automated machines installed at every city. Unfortunately, hackers have tampered with the ticket machines and now they all work as follows: when a single coin is inserted in the machine installed at city $a$, the machine dispenses a single one-way ticket from $a$ to a random neighboring city. More precisely, the destination city is chosen uniformly at random among all cities directly connected to a with a railroad track. Destinations on different tickets originating in the same city are independent.\n\nA computer science student needs to travel from city $1$ (where she lives) to city $n$ (where a regional programming contest has already started). She knows how the machines work (but of course cannot predict the random choices) and has a map of the railway network. In each city, when she purchases a ticket, she can either immediately use it and travel to the destination city on the ticket, or discard the ticket and purchase a new one. She can keep purchasing tickets indefinitely. The trip is finished as soon as she reaches city $n$.\n\nAfter doing some calculations, she has devised a traveling strategy with the following properties:\n  - The probability that the trip will eventually finish is $1$.\n  - The expected number of coins spent on the trip is the smallest possible.\n\nFind the expected number of coins she will spend on the trip.", "inputFormat": "The first line contains two integers $n$ and $m(1 \\le n,m \\le 300 000)$ — the number of cities and the number of railroad tracks. Each of the following $m$ lines contains two different integers $a$ and $b(1 \\le a, b \\le n)$ which describe a railroad track connecting cities $a$ and $b$. \n\nThere will be at most one railroad track between each pair of cities. It will be possible to reach city $n$ starting from city $1$.", "outputFormat": "Output a single number — the expected number of coins spent. The solution will be accepted if the absolute or the relative difference from the judges solution is less than $10^{-6}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Gambling Guide", "background": "", "description": "一个铁路系统由 $n$ 个城市和 $m$ 条双向铁路组成。铁路票只能在安装在每个城市的自动售票机购买。不幸的是，黑客们已经篡改了这些售票机，现在它们有下面的规则：\n\n当 $a$ 市的售票机有一个硬币投入时，机器会发一张从 $a$ 市到随机一个邻市的单程票。\n\n你需要从城市 $1$ 到城市 $n$。你知道机器是怎么工作的并且有一份铁路系统的地图。在每一个城市，当你买了一张票时，你可以选择立即使用它后到达目的地，或者是丢掉它并买一张新票。你可以无限制的购买的票。当你到达城市 $n$，旅行就会结束。\n\n你需要确定一个满足以下条件的策略：\n\n- 旅行最终到达终点的概率为 $1$。\n\n- 花在旅行上的硬币的期望值越少越好。\n\n输出这个期望值。", "inputFormat": "第一行包含两个整数 $n$ 和 $m(1 \\le n,m \\le 300000)$。\n\n接下来 $m$ 行每行包含了两个不同的整数 $a$ 和 $b(1 \\le a,b \\le n)$，描述了一条连接 $a$ 市和 $b$ 市的双向铁路。\n\n两个城市之间最多只会有一条铁路，输入保证有一条从城市 $1$ 到 $n$ 的路径。", "outputFormat": "输出一个数，为期望值。此输出只要与正解的相对差或绝对差小于 $10^{−6}$ 就可以通过。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4746", "type": "P", "difficulty": 3, "samples": [["9\n/sys/kernel/notes 100\n/cerc/problems/a/testdata/in 1000000\n/cerc/problems/a/testdata/out 8\n/cerc/problems/a/luka.cc 500\n/cerc/problems/a/zuza.cc 5000\n/cerc/problems/b/testdata/in 15\n/cerc/problems/b/testdata/out 4\n/cerc/problems/b/kale.cc 100\n/cerc/documents/rules.pdf 4000\n10000", "- / 1009727\n- /cerc/ 1009627\n/cerc/documents/ 4000\n- /cerc/problems/ 1005627\n- /cerc/problems/a/ 1005508\n/cerc/problems/a/testdata/ 1000008\n+ /cerc/problems/b/ 119\n+ /sys/ 100\n"], ["8\n/b/test/in.a 100\n/b/test/in.b 1\n/c/test/in.a 100\n/c/test/in.b 1\n/c/test/pic/in.a.svg 10\n/c/test/pic/in.b.svg 10\n/a/test/in.a 99\n/a/test/in.b 1\n101\n", "- / 322\n+ /a/ 100\n- /b/ 101\n/b/test/ 101\n- /c/ 121\n+ /c/test/ 121"], ["2\n/a/a/a 100\n/b.txt 99\n200\n", "+ / 199\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "ICPC", "CERC"], "title": "[CERC2017] Hidden Hierarchy", "background": "", "description": "You are working on the user interface for a simple text-based file explorer. One of your tasks is to build a navigation pane displaying the directory hierarchy. As usual, the filesystem consists of directories which may contain files and other directories, which may, in turn, again contain files and other directories etc. Hence, the directories form a hierarchical tree structure. The top-most directoryin the hierarchy is called the root directory. If directory $d$ directly contains directory $e$ we will say that $d$ is the parent directory of $e$ while $e$ is a subdirectory od $d$. Each file has a size expressed in bytes. The directory size is simply the total size of all files directly or indirectly contained inside that directory.\n\nAll files and all directories except the root directory have a name — a string that always starts with a letter and consists of only lowercase letters and “``.``” (dot) characters. All items (files and directories) directly inside the same parent directory must have unique names. Each item (file and directory) can be uniquely described by its path — a string built according to the following rules:\n   - Path of the root directory is simply “``/``” (forward slash).\n   - For a directory $d$, its path is obtained by concatenating the directory names top to bottom along the hierarchy from the root directory to $d$, preceding each name with the “``/``” character and placing another “``/``” character at the end of the path.\n   - For a file $f$ , its path is the concatenation of the parent directory path and the name of file $f$ .\n\nWe display the directory hierarchy by printing the root directory. We print a directory $d$ by outputting a line of the form “$m_d \\ p_d \\ s_d$” where $p_d$ and $s_d$ are the path and size of directory $d$ respectively, while $m_d$ is its expansion marker explained shortly. If $d$ contains other directories we must choose either to collapse it or to expand it. If we choose to expand $d$ we print (using the same rules) all of its subdirectories in lexicographical order by name. If we choose to collapse directory $d$, we simply ignore its contents.\n\nThe expansion marker $m_d$ is a single blank character when $d$ does not have any subdirectories, “``+``” (plus) character when we choose to collapse $d$ or a “``-``” (minus) character when we choose expand $d$.\n\nGiven a list of files in the filesystem and a threshold integer $t$, display the directory hierarchy ensuring that each directory of size at least $t$ is printed. Additionally, the total number of directories printed should be minimal. Assume there are no empty directories in the filesystem — the entire hierarchy can be deduced from the provided file paths. Note that the root directory has to be printed regardless of its size. Also note that a directory of size at least $t$ only has to be printed, but not necessarily expanded.\n", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 1 000)$ — the number of files. Each of the following $n$ lines contains a string $f$ and an integer $s(1 \\le s \\le 10^6)$ — the path and the size of a single file. Each path is at most $100$ characters long and is a valid file path according to the rules above. All paths will be different.\n\nThe following line contains an integer $t(1 \\le t \\le 10^9)$ — the threshold directory size.", "outputFormat": "Output the minimal display of the filesystem hierarchy for the given threshold as described above.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2017] Hidden Hierarchy", "background": "", "description": "You are working on the user interface for a simple text-based file explorer. One of your tasks is to build a navigation pane displaying the directory hierarchy. As usual, the filesystem consists of directories which may contain files and other directories, which may, in turn, again contain files and other directories etc. Hence, the directories form a hierarchical tree structure. The top-most directoryin the hierarchy is called the root directory. If directory $d$ directly contains directory $e$ we will say that $d$ is the parent directory of $e$ while $e$ is a subdirectory od $d$. Each file has a size expressed in bytes. The directory size is simply the total size of all files directly or indirectly contained inside that directory.\n\nAll files and all directories except the root directory have a name — a string that always starts with a letter and consists of only lowercase letters and “``.``” (dot) characters. All items (files and directories) directly inside the same parent directory must have unique names. Each item (file and directory) can be uniquely described by its path — a string built according to the following rules:\n   - Path of the root directory is simply “``/``” (forward slash).\n   - For a directory $d$, its path is obtained by concatenating the directory names top to bottom along the hierarchy from the root directory to $d$, preceding each name with the “``/``” character and placing another “``/``” character at the end of the path.\n   - For a file $f$ , its path is the concatenation of the parent directory path and the name of file $f$ .\n\nWe display the directory hierarchy by printing the root directory. We print a directory $d$ by outputting a line of the form “$m_d \\ p_d \\ s_d$” where $p_d$ and $s_d$ are the path and size of directory $d$ respectively, while $m_d$ is its expansion marker explained shortly. If $d$ contains other directories we must choose either to collapse it or to expand it. If we choose to expand $d$ we print (using the same rules) all of its subdirectories in lexicographical order by name. If we choose to collapse directory $d$, we simply ignore its contents.\n\nThe expansion marker $m_d$ is a single blank character when $d$ does not have any subdirectories, “``+``” (plus) character when we choose to collapse $d$ or a “``-``” (minus) character when we choose expand $d$.\n\nGiven a list of files in the filesystem and a threshold integer $t$, display the directory hierarchy ensuring that each directory of size at least $t$ is printed. Additionally, the total number of directories printed should be minimal. Assume there are no empty directories in the filesystem — the entire hierarchy can be deduced from the provided file paths. Note that the root directory has to be printed regardless of its size. Also note that a directory of size at least $t$ only has to be printed, but not necessarily expanded.\n", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 1 000)$ — the number of files. Each of the following $n$ lines contains a string $f$ and an integer $s(1 \\le s \\le 10^6)$ — the path and the size of a single file. Each path is at most $100$ characters long and is a valid file path according to the rules above. All paths will be different.\n\nThe following line contains an integer $t(1 \\le t \\le 10^9)$ — the threshold directory size.", "outputFormat": "Output the minimal display of the filesystem hierarchy for the given threshold as described above.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Hidden Hierarchy", "background": "", "description": "假设你正在开发一个简单的以输入文字为基础的文件夹浏览器。你的工作之一就是要构建一个导航目录来显示这些文件夹的上下关系。通常而言，这些文件夹很可能是互相嵌套的——比如，某个文件夹下还有一个文件夹，当然也可能会包含某些文件。因此，这些文件夹会形成一种树状结构。在这个目录中，最顶端的那个文件夹称之为根目录。如果文件夹d中直接含有文件夹e，那么我们称之为文件夹d是文件夹e的父文件夹，而文件夹e是文件夹d的子文件夹。每个文件都有一个用字节数来表示的大小。一个文件夹的大小是被直接或不直接包含于其中的所有文件的大小之和。\n\n所有的文件和文件夹（除根目录外）都有一个名字——一个只由小写字符和点（“.\"）组成并且只由小写字母开头的字符串。包含于同一个父目录下的文件或文件夹的名字必定各不相同。而且，路径与文件是一一对应的。生成路径的规则如下：\n\n- 根目录路径是“/”\n- 文件夹d的路径是从根目录开始，沿着文件夹的父子关系，顺次往下，在每个文件夹名字前添加一个“/”，相互连接，并在路径的最末尾添加一个“/”。\n- 文件f的路径是由它的父文件夹的路径加上文件名得到的。\n\n通过打印根目录，我们能够显示文件夹的上下父子关系。打印文件夹d时，我们输出一个“md pd sd”形式的字符串。其中，pd是文件夹d的路径，sd是文件夹d的大小，md是文件夹d的扩展标记。如果文件夹d包含其他文件夹，我们可以选择是否展开它。如果我们要展开文件夹d，我们就要以字典序打印它里面包含的所有文件和文件夹。如果我们不打开文件夹d，那么我们就可以忽略其中的内容。\n\n如果d是一个空文件夹（即没有包含任何文件或文件夹），那么md就仅仅是一个空字符。当我们要展开这个文件夹的时候，md是一个“-”，而如果我们不展开这个文件夹的是md是一个“+”。\n\n现在，输入一列文件和一个限制性整数t。请你打印（按照前述展开打印方法）所有的大小不小于t的文件夹。并且，打印的文件夹总数一定是最小的。保证不存在空文件夹即整个文件夹上下关系都可从输入的文件路径中推断得出。注意，大小不小于t的文件夹必须要被打印，但不一定要展开。根目录不论多大都要被打印。", "inputFormat": "第一行输入包含一个整数n（1<=n<=1000）表示文件的总数。之后的n行中，每行包含一个字符串f和一个整数s（1<=s<=10^6）。其中，f表示文件路径和单个文件的大小。每个路径最多含有100个字符并保证是一个合法路径。所有的路径保证各不相同。\n\n之后的一行包含限制性整数t（1<=t<=10^9）。", "outputFormat": "按照前述方法输出最少的展开文件的方法。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4747", "type": "P", "difficulty": 6, "samples": [["7\n3 1 7 5 6 4 2\n3\n3 6\n7 7\n1 3\n", "3 6\n7 7 \n1 7"], ["10\n2 1 4 3 5 6 7 10 8 9\n5\n2 3\n3 7\n4 7\n4 8\n7 8\n", "1 4\n3 7\n3 7\n3 10\n7 10\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "ICPC", "CERC"], "title": "[CERC2017] Intrinsic Interval", "background": "", "description": "Given a permutation $\\pi$ of integers $1$ through $n$, an interval in $\\pi$ is a consecutive subsequence consisting of consecutive numbers. More precisely, for indices $a$ and $b$ where $1 \\le a \\le b \\le n$, the subsequence $\\pi^b_a = (\\pi_a, \\pi_{a+1}, . . . ,\\pi_b)$ is an interval if sorting it would yield a sequence of consecutive integers.\n\nFor example, in permutation $\\pi = (3, 1, 7, 5, 6, 4, 2)$, the subsequence $\\pi^6_3$ is an interval (it contains the numbers $4$ through $7$) while $\\pi^3_1$ is not.\n\nFor a subsequence $\\pi^y_x$ its intrinsic interval is any interval $\\pi^b_a$ that contains the given subsequence $(a \\le x \\le y \\le b)$ and that is, additionally, as short as possible. Of course, the length of an interval is defined as the number of elements it contains.\n\nGiven a permutation $\\pi$ and $m$ of its subsequences, find some intrinsic interval for each subsequence.", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 100 000)$ — the size of the permutation $\\pi$. The following line contains $n$ different integers $\\pi_1, \\pi_2, . . . , \\pi_n (1 \\le \\pi_j \\le n)$ — the permutation itself.\n\nThe following line contains an integer $m(1 \\le m \\le 100 000)$ — the number of subsequences. The $j-th$ of the following $m$ lines contains integers $x_j$ and $y_j(1 \\le x_j \\le y_j \\le n)$ — the endpoints of the $j-th$ subsequence.\n", "outputFormat": "Output $m$ lines. The $j-th$ line should contain two integers $a_j$ and $b_j$ where $1 \\le a_j \\le b_j \\le n$ — the endpoints of some intrinsic interval of the $j-th$ subsequence $\\pi^{y_j}_{x_j}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2017] Intrinsic Interval", "background": "", "description": "Given a permutation $\\pi$ of integers $1$ through $n$, an interval in $\\pi$ is a consecutive subsequence consisting of consecutive numbers. More precisely, for indices $a$ and $b$ where $1 \\le a \\le b \\le n$, the subsequence $\\pi^b_a = (\\pi_a, \\pi_{a+1}, . . . ,\\pi_b)$ is an interval if sorting it would yield a sequence of consecutive integers.\n\nFor example, in permutation $\\pi = (3, 1, 7, 5, 6, 4, 2)$, the subsequence $\\pi^6_3$ is an interval (it contains the numbers $4$ through $7$) while $\\pi^3_1$ is not.\n\nFor a subsequence $\\pi^y_x$ its intrinsic interval is any interval $\\pi^b_a$ that contains the given subsequence $(a \\le x \\le y \\le b)$ and that is, additionally, as short as possible. Of course, the length of an interval is defined as the number of elements it contains.\n\nGiven a permutation $\\pi$ and $m$ of its subsequences, find some intrinsic interval for each subsequence.", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 100 000)$ — the size of the permutation $\\pi$. The following line contains $n$ different integers $\\pi_1, \\pi_2, . . . , \\pi_n (1 \\le \\pi_j \\le n)$ — the permutation itself.\n\nThe following line contains an integer $m(1 \\le m \\le 100 000)$ — the number of subsequences. The $j-th$ of the following $m$ lines contains integers $x_j$ and $y_j(1 \\le x_j \\le y_j \\le n)$ — the endpoints of the $j-th$ subsequence.\n", "outputFormat": "Output $m$ lines. The $j-th$ line should contain two integers $a_j$ and $b_j$ where $1 \\le a_j \\le b_j \\le n$ — the endpoints of some intrinsic interval of the $j-th$ subsequence $\\pi^{y_j}_{x_j}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Intrinsic Interval", "background": "", "description": "对于正整数 $1,2,3 \\cdots n$ 的一个排列 $\\pi$，若它的一个子串 $\\pi[a..b]$ 排序后是连续正整数，则称 $\\pi[a..b]$ 是一个“区间”。例如对排列 $pi={3,1,7,5,6,4,2}$，子串 $\\pi[3..6]$ 是一个“区间”（因为它包含 $4,5,6,7$），$\\pi[1..3]$ 则不是。\n\n一个子串的“本征区间”是包含该子串的最短区间。“包含”是指：若 $\\pi[x..y]$ 的本征区间是 $\\pi[a..b]$，则 $a \\le x \\le y \\le b$。\n\n给定一个排列 $\\pi$ 及其 $m$ 个子串，求每个子串的“本征区间”。", "inputFormat": "第一行一个整数 $n(1 \\le n \\le 100000)$。\n\n第二行 $n$ 个整数，代表排列 $\\pi$。\n\n第三行一个整数 $m(1 \\le m \\le 100000)$。\n\n此后 $m$ 行，每行两个整数 $x,y(1 \\le x \\le y \\le n)$，代表子串 $\\pi[x..y]$。", "outputFormat": "输出 $m$ 行，每行两个整数 $a,b(1 \\le a \\le b \\le n)$，代表子串对应的本征区间 $\\pi[a..b]$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4748", "type": "P", "difficulty": 5, "samples": [["8\n1 2\n2 3\n1 4\n4 5\n6 7\n8 3\n7 3", "1 3 7"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "ICPC", "CERC"], "title": "[CERC2017] Justified Jungle", "background": "", "description": "As you probably know, a tree is a graph consisting of $n$ nodes and $n - 1$ undirected edges in which any two nodes are connected by exactly one path. A forest is a graph consisting of one or more trees.\n\nIn other words, a graph is a forest if every connected component is a tree. A forest is justified if all connected components have the same number of nodes.\n\nGiven a tree $G$ consisting of n nodes, find all positive integers $k$ such that a justified forest can be obtained by erasing exactly $k$ edges from $G$. Note that erasing an edge never erases any nodes. In particular when we erase all $n - 1$ edges from $G$, we obtain a justified forest consisting of $n$ one-node components.\n", "inputFormat": "The first line contains an integer $n(2 \\le n \\le 1 000 000)$ — the number of nodes in $G$. The $k-th$ of the following $n - 1$ lines contains two different integers $a_k$ and $b_k(1 \\le a_k, b_k \\le n)$ — the endpoints of the $k-th$ edge.\n", "outputFormat": "The first line should contain all wanted integers $k$, in increasing order.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2017] Justified Jungle", "background": "", "description": "As you probably know, a tree is a graph consisting of $n$ nodes and $n - 1$ undirected edges in which any two nodes are connected by exactly one path. A forest is a graph consisting of one or more trees.\n\nIn other words, a graph is a forest if every connected component is a tree. A forest is justified if all connected components have the same number of nodes.\n\nGiven a tree $G$ consisting of n nodes, find all positive integers $k$ such that a justified forest can be obtained by erasing exactly $k$ edges from $G$. Note that erasing an edge never erases any nodes. In particular when we erase all $n - 1$ edges from $G$, we obtain a justified forest consisting of $n$ one-node components.\n", "inputFormat": "The first line contains an integer $n(2 \\le n \\le 1 000 000)$ — the number of nodes in $G$. The $k-th$ of the following $n - 1$ lines contains two different integers $a_k$ and $b_k(1 \\le a_k, b_k \\le n)$ — the endpoints of the $k-th$ edge.\n", "outputFormat": "The first line should contain all wanted integers $k$, in increasing order.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Justified Jungle", "background": "", "description": "给你一棵包含 $ N $ 个节点的树 $ (N \\leq 10^6) $，求可以通过删除树上的多少条边，使得得到的森林满足其中所有的树都包含相同数量的节点。输出所有合法的删边数量。\r\n\r\n合法的删边数量 $ k $ 指的是存在至少一种方案，删去了恰好 $ k $ 条边，得到的森林满足其中所有的树都包含相同数量的节点。", "inputFormat": "第一行有一个正整数 $ N $ ，表示树的点数。  \r\n接下来 $ N - 1 $ 行，每行两个正整数 $ a , b $ ，表示一条连接点 $ a $ 与点 $ b $ 的无向边。", "outputFormat": "输出一行，包含若干个以空格分隔的正整数，表示所有合法的删边数量。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4749", "type": "P", "difficulty": 6, "samples": [["6\n9689331\n1758824\n3546327\n5682494\n9128291\n9443696\n", "3\n"], ["7\n5941186\n3871463\n8156346\n9925977\n8836125\n9999999\n5987743\n", "2\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "差分", "ICPC", "CERC"], "title": "[CERC2017] Kitchen Knobs", "background": "", "description": "You are cooking on a gigantic stove at a large fast-food restaurant. The stove contains $n$ heating elements arranged in a line and numbered with integers $1$ through $n$ left to right. Each element is operated by its control knob. The knobs are a bit unusual: each knob is marked with seven non-zero digits evenly distributed around a circle. The power of the heating element is equal to the positive integer obtained by reading the digits on its control knob clockwise starting from the top of the knob.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p2wyrucc.png)\n\nIn a single step, you can rotate one or more consecutive knobs by any number of positions in any direction. However, all knobs rotated in one step need to be rotated by the same number of positions in the same direction.\n\nFind the smallest number of steps needed to set all the heating elements to maximal possible power.", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 501)$ — the number of heating elements. The $j-th$ of the following $n$ lines contains an integer $x_j$ — the initial power of the $j-th$ heating element. Each $x_j$ consists of exactly seven non-zero digits.\n", "outputFormat": "Output a single integer — the minimal number of steps needed.", "hint": "In the first example, one of the ways to achieve maximal possible power is: rotate knobs $2$ through $3$ by $3$ positions in the counterclockwise direction, rotate knob $3$ by $3$ positions in the counterclockwise direction, and rotate knobs $4$ through $6$ by $2$ positions in the clockwise direction.\n", "locale": "en", "translations": {"en": {"title": "[CERC2017] Kitchen Knobs", "background": "", "description": "You are cooking on a gigantic stove at a large fast-food restaurant. The stove contains $n$ heating elements arranged in a line and numbered with integers $1$ through $n$ left to right. Each element is operated by its control knob. The knobs are a bit unusual: each knob is marked with seven non-zero digits evenly distributed around a circle. The power of the heating element is equal to the positive integer obtained by reading the digits on its control knob clockwise starting from the top of the knob.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p2wyrucc.png)\n\nIn a single step, you can rotate one or more consecutive knobs by any number of positions in any direction. However, all knobs rotated in one step need to be rotated by the same number of positions in the same direction.\n\nFind the smallest number of steps needed to set all the heating elements to maximal possible power.", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 501)$ — the number of heating elements. The $j-th$ of the following $n$ lines contains an integer $x_j$ — the initial power of the $j-th$ heating element. Each $x_j$ consists of exactly seven non-zero digits.\n", "outputFormat": "Output a single integer — the minimal number of steps needed.", "hint": "In the first example, one of the ways to achieve maximal possible power is: rotate knobs $2$ through $3$ by $3$ positions in the counterclockwise direction, rotate knob $3$ by $3$ positions in the counterclockwise direction, and rotate knobs $4$ through $6$ by $2$ positions in the clockwise direction.\n", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Kitchen Knobs", "background": "", "description": "你在一家大型快餐店的巨型灶台上烹饪。该灶台包含 $n$ 个加热元件，这些元件排成一行，从左到右用整数 $1$ 到 $n$ 编号。每个元件由一个控制旋钮操作。这些旋钮有些特殊：每个旋钮上标有七个非零数字，这些数字均匀分布在一个圆周上。加热元件的功率等于从其旋钮顶部开始顺时针读取数字所得到的正整数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p2wyrucc.png)\n\n在单步操作中，你可以将**一个或多个连续**的旋钮沿任意方向旋转任意数量的位置。然而，**在同一操作中旋转的所有旋钮必须沿相同方向旋转相同的位数**。\n\n请求出将所有加热元件设置为**最大可能功率**所需的最少步数。", "inputFormat": "第一行包含一个整数 $n(1 \\le n \\le 501)$ —— 表示加热元件的数量。  \n接下来的 $n$ 行中，第 $j$ 行包含一个整数 $x_j$ —— 表示第 $j$ 个加热元件的初始功率。每个 $x_j$ 恰好由七个非零数字组成。\n", "outputFormat": "输出一个整数 —— 表示所需的最少步数。\n", "hint": "在第一个样例中，一种达到最大可能功率的方法是：将旋钮 $2$ 到 $3$ 沿逆时针方向旋转 $3$ 个位置，将旋钮 $3$ 沿逆时针方向旋转 $3$ 个位置，再将旋钮 $4$ 到 $6$ 沿顺时针方向旋转 $2$ 个位置。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P4750", "type": "P", "difficulty": 6, "samples": [["2\nA 0 0 2\nB 1 0 2", "5.00"], ["8\nA -7 10 4\nB 3 10 8\nA -6 6 6\nA -2 5 8\nB 3 -1 8\nB -7 -4 8\nA 3 9 2\nB 8 6 6\n", "205.50"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "ICPC", "CERC"], "title": "[CERC2017] Lunar Landscape", "background": "", "description": "A satellite is surveying a possible rover landing area on the moon. The landing area is modeled as a square grid embedded in the standard coordinate system.\n\nThe satellite has taken $n$ photos, each capturing a square area of the surface. Careful camera calibration has ensured that all photos are aligned with the grid — all four vertices have integer coordinates. Due to the satellite’s changing orbit there are two types of photos:\n   - Photos of type ``A`` have sides that are parallel to coordinate axes. Such a photo is specified by giving the integer coordinates $(x, y)$ of the square’s middle point and the length of its side $a$ — always an even integer.\n   - Photos of type ``B`` have sides at a $45^{\\circ}$ angle to the coordinate axes. Such a photo is specified by giving the integer coordinates $(x, y)$ of the square’s middle point and the length of its diagonal $d$ — always an even integer.\n\nFind the total surface area captured in the satellite photos.\n", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 200 000)$ — the number of photos. The $j-th$ of the following $n$ lines is either of the form “$A \\ x_j \\ y_j  \\ a_j$” or “$B \\ x_j \\ y_j \\ d_j$” representing a photo of type ``A`` or ``B``,respectively.\n\nThe $x_j$ and $y_j$ are the integer coordinates of the middle point of the photo $(-1 000 \\le x_j, y_j \\le 1 000)$. The $a_j$ and $d_j$ are even integers $(2 \\le a_j, d_j \\le 1 000)$ — the side length and the diagonal length, respectively.", "outputFormat": "Output a number with exactly two digits after the decimal point — the total area of the surface. The answer has to exactly correspond to the judge’s solution (no rounding errors are tolerated).", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2017] Lunar Landscape", "background": "", "description": "A satellite is surveying a possible rover landing area on the moon. The landing area is modeled as a square grid embedded in the standard coordinate system.\n\nThe satellite has taken $n$ photos, each capturing a square area of the surface. Careful camera calibration has ensured that all photos are aligned with the grid — all four vertices have integer coordinates. Due to the satellite’s changing orbit there are two types of photos:\n   - Photos of type ``A`` have sides that are parallel to coordinate axes. Such a photo is specified by giving the integer coordinates $(x, y)$ of the square’s middle point and the length of its side $a$ — always an even integer.\n   - Photos of type ``B`` have sides at a $45^{\\circ}$ angle to the coordinate axes. Such a photo is specified by giving the integer coordinates $(x, y)$ of the square’s middle point and the length of its diagonal $d$ — always an even integer.\n\nFind the total surface area captured in the satellite photos.\n", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 200 000)$ — the number of photos. The $j-th$ of the following $n$ lines is either of the form “$A \\ x_j \\ y_j  \\ a_j$” or “$B \\ x_j \\ y_j \\ d_j$” representing a photo of type ``A`` or ``B``,respectively.\n\nThe $x_j$ and $y_j$ are the integer coordinates of the middle point of the photo $(-1 000 \\le x_j, y_j \\le 1 000)$. The $a_j$ and $d_j$ are even integers $(2 \\le a_j, d_j \\le 1 000)$ — the side length and the diagonal length, respectively.", "outputFormat": "Output a number with exactly two digits after the decimal point — the total area of the surface. The answer has to exactly correspond to the judge’s solution (no rounding errors are tolerated).", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Lunar Landscape", "background": null, "description": "一个卫星正在为探测车在月球上寻找一个合适的降落区。降落区被看做在平面直角坐标系中的一个方形区域。\n\n这颗卫星已经照了 $n$ 张照片，每张照片都涵盖了月球表面的一块正方形区域。经过对相机的精细校准，可以保证所有照片涵盖的区域都和坐标对齐——正方形四个角的坐标都为整数。由于卫星的轨道一直在变化，所以照片有两种形式：\n\n- A 类照片的边缘和坐标轴平行。对于这样的照片，题目将会给出它中心的坐标 $(x,y)$ 和它的边长 $a$（$a$ 为偶数）。\n\n- B 类照片的边缘和坐标轴呈 $45\\degree$ 角。对于这样的照片，题目将会给出它中心的坐标 $(x,y)$ 和它对角线的长度 $d$（$d$ 为偶数）。\n\n求出卫星图片拍摄到平面的总大小。", "inputFormat": "第一行有一个整数 $n$ 表示照片的数量。接下来 $n$ 行中第 $j$ 行的格式是 `A xj yj aj` 或 `B xj yj dj`，分别表示这张照片的类型是 A 或 B。\n\n$x_j$ 和 $y_j$ 是这张图片中心的坐标。$a_j$ 和 $d_j$ 为偶数，分别表示正方形的边长和对角线长度。", "outputFormat": "输出平面总的大小，保留两位小数。答案必须和标准答案严格相等（精度问题零容忍↖(^ω^)↗）。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 2 \\cdot 10^5$，$-1 000 \\le x_j, y_j \\le 1 000$，$2 \\le a_j \\le d_j \\le 10^3$，保证所有 $a_j, d_j$ 均为偶数。", "locale": "zh-CN"}}}
{"pid": "P4751", "type": "P", "difficulty": 6, "samples": [["10 10\n-11 80 -99 -76 56 38 92 -51 -34 47\n2 1\n3 1\n4 3\n5 2\n6 2\n7 1\n8 2\n9 4\n10 7\n9 -44\n184 -17\n184 98\n185 -58\n153 48\n190 99\n296 -61\n253 76\n329 14\n264 93\n", "186\n186\n190\n145\n189\n288\n244\n320\n258\n304"]], "limits": {"time": [3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "线段树", "O2优化", "树链剖分", "动态树 LCT", "动态 DP", "全局平衡二叉树", "模板题"], "title": "【模板】动态 DP（加强版）", "background": "树剖常数小！跑不满！\n\nshadowice1984 为了向你证明他能卡树剖并且会卡树剖从而出了这道毒瘤题。\n\n保证答案均在 `int` 范围内。\n\n然后就被离线算法针对了……\n\n因此这道题变成了强制在线。\n", "description": "同 [P4719](https://www.luogu.com.cn/problem/P4719)。\n\n给定一个 $n$ 个点的带点权树，进行 $m$ 次修改点权的操作。\n\n你需要在每次修改之后输出树上最大带权独立集的权值之和。", "inputFormat": "同 [P4719](https://www.luogu.com.cn/problem/P4719)。\n\n第一行两个正整数 $n$，$m$ 表示树的点数和总操作个数\n\n第二行 $n$ 个整数 $V_1,\\dots,V_n$ 表示每个点的点权。\n\n接下来 $(n - 1)$ 行，每行两个整数 $u, v$，表示存在一条连接 $u$ 与 $v$ 的边。\n\n接下来 $m$ 行每行两个整数 $x$，$y$ 表示将 $x$ 的点权修改为 $y$。\n\n对于第 $1$ 行，$x$ 即为被操作的点的编号。\n\n对于第 $2$ 到 $m$ 行，被操作的点的编号 $=x\\oplus lastans$。\n\n其中 $lastans$ 是上一次操作后输出的答案，$\\oplus$ 表示按位异或操作。", "outputFormat": "输出 $m$ 行，第 $i$ 行表示表示第 $i$ 次操作之后树上最大带权独立集的权值和。", "hint": "数据范围 $n \\leq 1 \\times 10^6$，$m \\leq 3 \\times 10^6$。保证任意时刻各点点权的绝对值 $\\leq 100$。\n\n时限为标程的二倍，如果卡常数的话请使用 `int` 类型。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Dynamic DP (Enhanced Version)", "background": "Tree decomposition has small constants! It cannot reach full performance!\n\nshadowice1984 made this nasty problem to prove to you that he can hack tree decomposition and knows how to do it.\n\nIt is guaranteed that all answers fit in the `int` range.\n\nThen it got targeted by offline algorithms...\n\nSo this problem becomes forced online.", "description": "Same as [P4719](https://www.luogu.com.cn/problem/P4719).\n\nGiven a tree with $n$ nodes and node weights, perform $m$ operations that modify node weights.\n\nAfter each modification, you need to output the maximum total weight of a maximum weight independent set on the tree.", "inputFormat": "Same as [P4719](https://www.luogu.com.cn/problem/P4719).\n\nThe first line contains two positive integers $n$, $m$, representing the number of nodes in the tree and the total number of operations.\n\nThe second line contains $n$ integers $V_1,\\dots,V_n$, representing the weight of each node.\n\nThe next $(n - 1)$ lines each contain two integers $u, v$, indicating that there is an edge connecting $u$ and $v$.\n\nThe next $m$ lines each contain two integers $x$, $y$, indicating that the weight of node $x$ is modified to $y$.\n\nFor the 1st operation, $x$ is the index of the modified node.\n\nFor the 2nd to the $m$-th operations, the index of the modified node is $x\\oplus lastans$.\n\nHere, $lastans$ is the answer output after the previous operation, and $\\oplus$ denotes the bitwise XOR operation.", "outputFormat": "Output $m$ lines. The $i$-th line is the total weight of the maximum weight independent set on the tree after the $i$-th operation.", "hint": "Constraints: $n \\leq 1 \\times 10^6$, $m \\leq 3 \\times 10^6$. It is guaranteed that at any time, the absolute value of each node weight is $\\leq 100$.\n\nThe time limit is twice that of the reference solution. If you need to optimize constants, please use the `int` type.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】动态 DP（加强版）", "background": "树剖常数小！跑不满！\n\nshadowice1984 为了向你证明他能卡树剖并且会卡树剖从而出了这道毒瘤题。\n\n保证答案均在 `int` 范围内。\n\n然后就被离线算法针对了……\n\n因此这道题变成了强制在线。\n", "description": "同 [P4719](https://www.luogu.com.cn/problem/P4719)。\n\n给定一个 $n$ 个点的带点权树，进行 $m$ 次修改点权的操作。\n\n你需要在每次修改之后输出树上最大带权独立集的权值之和。", "inputFormat": "同 [P4719](https://www.luogu.com.cn/problem/P4719)。\n\n第一行两个正整数 $n$，$m$ 表示树的点数和总操作个数\n\n第二行 $n$ 个整数 $V_1,\\dots,V_n$ 表示每个点的点权。\n\n接下来 $(n - 1)$ 行，每行两个整数 $u, v$，表示存在一条连接 $u$ 与 $v$ 的边。\n\n接下来 $m$ 行每行两个整数 $x$，$y$ 表示将 $x$ 的点权修改为 $y$。\n\n对于第 $1$ 行，$x$ 即为被操作的点的编号。\n\n对于第 $2$ 到 $m$ 行，被操作的点的编号 $=x\\oplus lastans$。\n\n其中 $lastans$ 是上一次操作后输出的答案，$\\oplus$ 表示按位异或操作。", "outputFormat": "输出 $m$ 行，第 $i$ 行表示表示第 $i$ 次操作之后树上最大带权独立集的权值和。", "hint": "数据范围 $n \\leq 1 \\times 10^6$，$m \\leq 3 \\times 10^6$。保证任意时刻各点点权的绝对值 $\\leq 100$。\n\n时限为标程的二倍，如果卡常数的话请使用 `int` 类型。", "locale": "zh-CN"}}}
{"pid": "P4752", "type": "P", "difficulty": 4, "samples": [["2\n3 2\n5 7 7\n5 7\n4 2\n5 7 7 7\n5 7", "YES\nNO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化", "排序", "素数判断,质数,筛法", "洛谷月赛"], "title": "Divided Prime", "background": null, "description": "给定一个数字 $A$，这个 $A$ 由 $a_1,a_2,\\cdots,a_N$ 相乘得到。\n\n给定一个数字 $B$，这个 $B$ 由 $b_1,b_2,\\cdots,b_M$ 相乘得到。\n\n如果 $\\frac{A}{B}$ 是一个质数，请输出 `YES`，否则输出 `NO`。", "inputFormat": "每个测试点包含多组数据，第一行读入一个整数 $T$ 表示数据组数，对于每组数据：\n\n第一行输入两个整数 $N,M$，分别表示 $A$ 由 $N$ 个数字相乘得到，$B$ 由 $M$ 个数字相乘得到。\n\n第二行输入 $N$ 个整数，分别表示组成 $A$ 的 $N$ 个数字。\n\n第三行输入 $M$ 个整数，分别表示组成 $B$ 的 $M$ 个数字。\n\n保证对于一个数字，其在 ${b_i}$ 中出现的次数不多于在 ${a_i}$ 中出现的次数。", "outputFormat": "对于每组数据：\n如果 $\\frac{A}{B}$ 是一个质数，请输出 `YES`，否则输出 `NO`。\n在输出 `YES` 或 `NO` 后输出一个换行符。", "hint": "对于所有数据，有 $1 \\le N \\le 10^5, 0 \\le M \\le N, 1 \\le a_i,b_i \\le 10^{12}, 1 \\le T \\le 10, \\sum N \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Divided Prime", "background": "", "description": "Given a number $A$, where $A$ is obtained by multiplying $a_1, a_2, \\cdots, a_N$.\n\nGiven a number $B$, where $B$ is obtained by multiplying $b_1, b_2, \\cdots, b_M$.\n\nIf $\\frac{A}{B}$ is a prime number, output `YES`; otherwise, output `NO`.", "inputFormat": "Each test point contains multiple test cases. The first line contains an integer $T$, which denotes the number of test cases. For each test case:\n\nThe first line contains two integers $N, M$, indicating that $A$ is obtained by multiplying $N$ numbers, and $B$ is obtained by multiplying $M$ numbers.\n\nThe second line contains $N$ integers, which are the $N$ numbers that make up $A$.\n\nThe third line contains $M$ integers, which are the $M$ numbers that make up $B$.\n\nIt is guaranteed that, for any number, the number of times it appears in ${b_i}$ is no more than the number of times it appears in ${a_i}$.", "outputFormat": "For each test case:\n\nIf $\\frac{A}{B}$ is a prime number, output `YES`; otherwise, output `NO`.\n\nAfter outputting `YES` or `NO`, output a newline character.", "hint": "For all testdata, $1 \\le N \\le 10^5$, $0 \\le M \\le N$, $1 \\le a_i, b_i \\le 10^{12}$, $1 \\le T \\le 10$, and $\\sum N \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Divided Prime", "background": null, "description": "给定一个数字 $A$，这个 $A$ 由 $a_1,a_2,\\cdots,a_N$ 相乘得到。\n\n给定一个数字 $B$，这个 $B$ 由 $b_1,b_2,\\cdots,b_M$ 相乘得到。\n\n如果 $\\frac{A}{B}$ 是一个质数，请输出 `YES`，否则输出 `NO`。", "inputFormat": "每个测试点包含多组数据，第一行读入一个整数 $T$ 表示数据组数，对于每组数据：\n\n第一行输入两个整数 $N,M$，分别表示 $A$ 由 $N$ 个数字相乘得到，$B$ 由 $M$ 个数字相乘得到。\n\n第二行输入 $N$ 个整数，分别表示组成 $A$ 的 $N$ 个数字。\n\n第三行输入 $M$ 个整数，分别表示组成 $B$ 的 $M$ 个数字。\n\n保证对于一个数字，其在 ${b_i}$ 中出现的次数不多于在 ${a_i}$ 中出现的次数。", "outputFormat": "对于每组数据：\n如果 $\\frac{A}{B}$ 是一个质数，请输出 `YES`，否则输出 `NO`。\n在输出 `YES` 或 `NO` 后输出一个换行符。", "hint": "对于所有数据，有 $1 \\le N \\le 10^5, 0 \\le M \\le N, 1 \\le a_i,b_i \\le 10^{12}, 1 \\le T \\le 10, \\sum N \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4753", "type": "P", "difficulty": 5, "samples": [["6 1 3\n3", "YES\n1 2 0"], ["6 2 2\n2 4", "YES\n2 3 1 0"], ["5 2 3\n2 3", "NO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "贪心", "Special Judge", "O2优化", "洛谷月赛"], "title": "River Jumping", "background": "", "description": "有一条宽度为 $N$ 的河上，小 D 位于坐标为 $0$ 的河岸上，他想到达坐标为 $N$ 的河岸上后再回到坐标为 $0$ 的位置。在到达坐标为 $N$ 的河岸之前小 D 只能向坐标更大的位置跳跃，在到达坐标为 $N$ 的河岸之后小 D 只能向坐标更小的位置跳跃。在河的中间有 $M$ 个岩石，小 D 希望能跳到每个岩石上恰好一次。由于小 D 的跳跃能力太强，小 D 的跳跃长度有个下限 $S$，但没有上限。现在请你判断他是否能够完成他的目标。", "inputFormat": "第一行输入两个整数 $N,M,S$，分别表示河的宽度，岩石的数量和跳跃长度的下限。\n\n第二行输入 $M$ 个整数，分别表示 $M$ 个岩石的坐标 $w_1,w_2,\\cdots,w_N$。保证 $\\{w_i\\}$ 为递增序列。", "outputFormat": "如果小D可以完成他的目标，第一行输出 `YES`，第二行输出 $M+2$ 个数，依次表示小D跳到的石头编号。特殊的，坐标为 $0$ 的河岸编号为 $0$，坐标为$N$的河岸标号为 $M+1$ 。如果有多种解法，允许输出任意一种。\n\n如果小 D 不能完成他的目标，第一行输出 `NO`。", "hint": "对于全部数据，保证 $1 \\le N,S \\le 100000$，$0 \\le M < N$，$1 \\le w_i < N$。", "locale": "zh-CN", "translations": {"en": {"title": "River Jumping", "background": "", "description": "There is a river of width $N$. Little D is on the bank at coordinate $0$. He wants to reach the bank at coordinate $N$ and then return to coordinate $0$. Before reaching the bank at coordinate $N$, Little D can only jump to positions with larger coordinates. After reaching the bank at coordinate $N$, Little D can only jump to positions with smaller coordinates. There are $M$ rocks in the river. Little D hopes to land on each rock exactly once. Because Little D can jump very far, his jump length has a lower bound $S$ but no upper bound. Now determine whether he can achieve his goal.", "inputFormat": "The first line contains three integers $N, M, S$, representing the width of the river, the number of rocks, and the lower bound of the jump length.\n\nThe second line contains $M$ integers, representing the coordinates of the $M$ rocks: $w_1, w_2, \\cdots, w_N$. It is guaranteed that $\\{w_i\\}$ is a strictly increasing sequence.", "outputFormat": "If Little D can achieve his goal, output `YES` on the first line, and output $M + 2$ numbers on the second line, in order, representing the indices of the stones that Little D lands on. In particular, the bank at coordinate $0$ has index $0$, and the bank at coordinate $N$ has index $M + 1$. If there are multiple solutions, you may output any one of them.\n\nIf Little D cannot achieve his goal, output `NO` on the first line.", "hint": "For all testdata, it is guaranteed that $1 \\le N, S \\le 100000$, $0 \\le M < N$, and $1 \\le w_i < N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "River Jumping", "background": "", "description": "有一条宽度为 $N$ 的河上，小 D 位于坐标为 $0$ 的河岸上，他想到达坐标为 $N$ 的河岸上后再回到坐标为 $0$ 的位置。在到达坐标为 $N$ 的河岸之前小 D 只能向坐标更大的位置跳跃，在到达坐标为 $N$ 的河岸之后小 D 只能向坐标更小的位置跳跃。在河的中间有 $M$ 个岩石，小 D 希望能跳到每个岩石上恰好一次。由于小 D 的跳跃能力太强，小 D 的跳跃长度有个下限 $S$，但没有上限。现在请你判断他是否能够完成他的目标。", "inputFormat": "第一行输入两个整数 $N,M,S$，分别表示河的宽度，岩石的数量和跳跃长度的下限。\n\n第二行输入 $M$ 个整数，分别表示 $M$ 个岩石的坐标 $w_1,w_2,\\cdots,w_N$。保证 $\\{w_i\\}$ 为递增序列。", "outputFormat": "如果小D可以完成他的目标，第一行输出 `YES`，第二行输出 $M+2$ 个数，依次表示小D跳到的石头编号。特殊的，坐标为 $0$ 的河岸编号为 $0$，坐标为$N$的河岸标号为 $M+1$ 。如果有多种解法，允许输出任意一种。\n\n如果小 D 不能完成他的目标，第一行输出 `NO`。", "hint": "对于全部数据，保证 $1 \\le N,S \\le 100000$，$0 \\le M < N$，$1 \\le w_i < N$。", "locale": "zh-CN"}}}
{"pid": "P4754", "type": "P", "difficulty": 5, "samples": [["6 1 3 2\n0 0 0 0 0 0\n1 2\n2 1 1", "3"], ["6 1 3 2\n1 0 0 0 0 0\n1 2\n2 1 1", "2"], ["6 1 6 2\n0 0 0 0 0 0\n1 2\n2 1 1", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心", "O2优化", "洛谷月赛"], "title": "True Vegetable", "background": "", "description": "小A现在有$N$道题，编号为$1,2,\\cdots,N$。每道题的起始毒瘤程度为$0$或$1$。在每回合，小A可以将编号连续的$K$道题的毒瘤程度+1。但小B因为本身比较菜，不是很愿意小A出毒瘤题，所以在$w_i$回合开始时可以向第$x_i$题传播$v_i$点的菜气，使得第$x_i$的毒瘤程度减少$v_i$点（减后可以为负）。这里我们假定菜是有限的，在释放了$v_i$点的菜气后，小B需要至少$r_{v_i}$个回合不能释放菜气。现在小A知道了小B释放菜气的计划，他想知道他至少需要多少个回合可以使得每道题的毒瘤程度至少为$1$。", "inputFormat": "第一行输入四个整数，$N,M,K,L$，分别为题目的数量，小B的操作数量，每次连续增加毒瘤程度题目的数量和释放菜气的最大值。\n\n第二行输入$N$个整数$a_1,a_2,\\cdots,a_N$，分别为$N$个题目的毒瘤程度。\n\n第三行输入$L$个整数$r_1,r_2,\\cdots,r_L$，分别为释放$1$到$L$点菜气的冷却回合数。\n\n接下来有$M$行，每行输入三个整数$w_i,x_i,v_i$，表示小B在第$w_i$回合开始时向第$x_i$题释放了$v_i$点的菜气。保证$\\{w_i\\}$为递增序列。", "outputFormat": "请输出小A将每道题的毒瘤程度加到至少为$1$最少需要的回合数。", "hint": "$1 \\le N,M \\le 5 \\times 10^5$\n\n$1 \\le K \\le N$\n\n$1 \\le L \\le 100$\n\n$a[i] \\in \\{0,1\\}$\n\n$1 = r_1 < r_2 < \\cdots < r_L \\le 2 \\times L$\n\n$1 \\le w_i \\le N+L$\n\n$w_i+r_{v_i} \\le w_{i+1}$\n\n$1 \\le x_i \\le N$\n\n$1 \\le v_i \\le L$", "locale": "zh-CN", "translations": {"en": {"title": "True Vegetable", "background": "", "description": "Little A now has $N$ problems, numbered $1,2,\\cdots,N$. The initial “toxicity level” of each problem is $0$ or $1$. In each round, Little A can increase the toxicity level of $K$ problems with consecutive indices by $1$.\n\nHowever, Little B is not very strong and does not really want Little A to create toxic problems. At the start of round $w_i$, Little B can spread $v_i$ points of “noob gas” to problem $x_i$, which decreases the toxicity level of problem $x_i$ by $v_i$ points (it may become negative after decreasing). We assume the amount of “noob gas” is limited: after releasing $v_i$ points of noob gas, Little B must wait at least $r_{v_i}$ rounds before being able to release noob gas again.\n\nNow Little A knows Little B’s plan for releasing noob gas, and he wants to know the minimum number of rounds needed to make the toxicity level of every problem at least $1$.", "inputFormat": "The first line contains four integers $N,M,K,L$, representing the number of problems, the number of Little B’s operations, the number of consecutive problems increased each time, and the maximum value of noob gas that can be released.\n\nThe second line contains $N$ integers $a_1,a_2,\\cdots,a_N$, representing the toxicity levels of the $N$ problems.\n\nThe third line contains $L$ integers $r_1,r_2,\\cdots,r_L$, representing the cooldown rounds for releasing $1$ to $L$ points of noob gas.\n\nThe next $M$ lines each contain three integers $w_i,x_i,v_i$, meaning that at the start of round $w_i$, Little B releases $v_i$ points of noob gas to problem $x_i$. It is guaranteed that $\\{w_i\\}$ is a strictly increasing sequence.", "outputFormat": "Output the minimum number of rounds Little A needs to make the toxicity level of every problem at least $1$.", "hint": "Constraints\n\n$1 \\le N,M \\le 5 \\times 10^5$.\n\n$1 \\le K \\le N$.\n\n$1 \\le L \\le 100$.\n\n$a[i] \\in \\{0,1\\}$.\n\n$1 = r_1 < r_2 < \\cdots < r_L \\le 2 \\times L$.\n\n$1 \\le w_i \\le N+L$.\n\n$w_i+r_{v_i} \\le w_{i+1}$.\n\n$1 \\le x_i \\le N$.\n\n$1 \\le v_i \\le L$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "True Vegetable", "background": "", "description": "小A现在有$N$道题，编号为$1,2,\\cdots,N$。每道题的起始毒瘤程度为$0$或$1$。在每回合，小A可以将编号连续的$K$道题的毒瘤程度+1。但小B因为本身比较菜，不是很愿意小A出毒瘤题，所以在$w_i$回合开始时可以向第$x_i$题传播$v_i$点的菜气，使得第$x_i$的毒瘤程度减少$v_i$点（减后可以为负）。这里我们假定菜是有限的，在释放了$v_i$点的菜气后，小B需要至少$r_{v_i}$个回合不能释放菜气。现在小A知道了小B释放菜气的计划，他想知道他至少需要多少个回合可以使得每道题的毒瘤程度至少为$1$。", "inputFormat": "第一行输入四个整数，$N,M,K,L$，分别为题目的数量，小B的操作数量，每次连续增加毒瘤程度题目的数量和释放菜气的最大值。\n\n第二行输入$N$个整数$a_1,a_2,\\cdots,a_N$，分别为$N$个题目的毒瘤程度。\n\n第三行输入$L$个整数$r_1,r_2,\\cdots,r_L$，分别为释放$1$到$L$点菜气的冷却回合数。\n\n接下来有$M$行，每行输入三个整数$w_i,x_i,v_i$，表示小B在第$w_i$回合开始时向第$x_i$题释放了$v_i$点的菜气。保证$\\{w_i\\}$为递增序列。", "outputFormat": "请输出小A将每道题的毒瘤程度加到至少为$1$最少需要的回合数。", "hint": "$1 \\le N,M \\le 5 \\times 10^5$\n\n$1 \\le K \\le N$\n\n$1 \\le L \\le 100$\n\n$a[i] \\in \\{0,1\\}$\n\n$1 = r_1 < r_2 < \\cdots < r_L \\le 2 \\times L$\n\n$1 \\le w_i \\le N+L$\n\n$w_i+r_{v_i} \\le w_{i+1}$\n\n$1 \\le x_i \\le N$\n\n$1 \\le v_i \\le L$", "locale": "zh-CN"}}}
{"pid": "P4755", "type": "P", "difficulty": 6, "samples": [["4\n1 3 9 3\n", "5\n"], ["5\n1 1 2 1 1\n", "14\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化", "枚举", "分治", "可持久化线段树", "洛谷月赛", "笛卡尔树", "启发式合并"], "title": "Beautiful Pair", "background": "", "description": "小 D 有个数列 $\\{a\\}$，当一个数对 $(i,j)$（$i \\le j$）满足 $a_i$ 和 $a_j$ 的积不大于 $a_i, a_{i+1}, \\ldots, a_j$ 中的最大值时，小 D 认为这个数对是美丽的。请你求出美丽的数对的数量。", "inputFormat": "第一行输入一个整数 $n$，表示元素个数。\n第二行输入 $n$ 个整数 $a_1,a_2,a_3,\\ldots,a_n$，为所给的数列。\n", "outputFormat": "输出一个整数，为美丽的数字对数。", "hint": "**【样例解释 #1】**\n\n五种可行的数对为 $(1,1), (1,2), (1,3), (1,4), (2,4)$。\n\n**【样例解释 #2】**\n\n只有数对 $(3,3)$ 不可行。\n\n**【数据范围】**\n\n对于 $100 \\%$ 的数据，$1\\le n\\le{10}^5$，$1\\le a_i\\le{10}^9$。", "locale": "zh-CN", "translations": {"en": {"title": "Beautiful Pair", "background": "", "description": "Xiao D has a sequence $\\{a\\}$. For a pair $(i, j)$ ($i \\le j$), if the product of $a_i$ and $a_j$ is not greater than the maximum value among $a_i, a_{i+1}, \\ldots, a_j$, then Xiao D considers this pair to be beautiful. Please find the number of beautiful pairs.", "inputFormat": "The first line contains an integer $n$, representing the number of elements.  \nThe second line contains $n$ integers $a_1, a_2, a_3, \\ldots, a_n$, representing the given sequence.", "outputFormat": "Output one integer, the number of beautiful pairs.", "hint": "**[Sample Explanation #1]**\n\nThe five valid pairs are $(1,1), (1,2), (1,3), (1,4), (2,4)$.\n\n**[Sample Explanation #2]**\n\nOnly the pair $(3,3)$ is invalid.\n\n**[Constraints]**\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^5$, and $1 \\le a_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Beautiful Pair", "background": "", "description": "小 D 有个数列 $\\{a\\}$，当一个数对 $(i,j)$（$i \\le j$）满足 $a_i$ 和 $a_j$ 的积不大于 $a_i, a_{i+1}, \\ldots, a_j$ 中的最大值时，小 D 认为这个数对是美丽的。请你求出美丽的数对的数量。", "inputFormat": "第一行输入一个整数 $n$，表示元素个数。\n第二行输入 $n$ 个整数 $a_1,a_2,a_3,\\ldots,a_n$，为所给的数列。\n", "outputFormat": "输出一个整数，为美丽的数字对数。", "hint": "**【样例解释 #1】**\n\n五种可行的数对为 $(1,1), (1,2), (1,3), (1,4), (2,4)$。\n\n**【样例解释 #2】**\n\n只有数对 $(3,3)$ 不可行。\n\n**【数据范围】**\n\n对于 $100 \\%$ 的数据，$1\\le n\\le{10}^5$，$1\\le a_i\\le{10}^9$。", "locale": "zh-CN"}}}
{"pid": "P4756", "type": "P", "difficulty": 6, "samples": [["4 4\n4 5 6 7\n1\n15\n0\n12", "6\n6\n14\n26\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化", "前缀和", "凸包", "洛谷月赛"], "title": "Added Sequence", "background": "", "description": "小$L$发明了一种新的数据结构，并将其命名为$L$数组。$L$数组的作用是可以在$O(1)$时间内将整个数组加上或减去一个数。现在给你一个长度为$N$的数组$a$，他想用$L$数组来挑战你的计算能力。\n\n定义$f(i,j)=|\\sum_{p=i}^{j} a_p|$其中$|x|$表示$x$的绝对值。\n\n定义一个数组的美丽度为$\\max_{1 \\le i \\le j \\le N} f(i,j)$，每当他将整个数组加上$x$ ，请你回答此时的美丽度。\n\n注意，你的算法必须为在线的。", "inputFormat": "第一行输入两个整数$N,M$，分别表示数组长度和询问数量。\n\n第二行输入$N$个整数，表示起始的数组$a$。\n\n接下来$M$行，每行一个整数$x_i$，设前面一次回答的答案为$pre$，那么表示第$i$次询问时在起始数组的基础上整个数组加上$[(x_i+pre)\\%(4n+1)-2n]$。其中$\\%$表示求余运算，第一次回答时$pre=0$。", "outputFormat": "输出$M$行，第$i$行为在起始数组的基础上整个数组加上$x_i$时的美丽度。", "hint": "四次加上的数字分别为-7，-4，-2，1。\n\n$1 \\le N,M \\le 200000$\n\n$|a_i| \\le 200000$\n\n$0 \\le x_i \\le 800000$", "locale": "zh-CN", "translations": {"en": {"title": "Added Sequence", "background": "　　", "description": "Xiao $L$ invented a new data structure and named it the $L$ array. An $L$ array can add or subtract a number to the entire array in $O(1)$ time. Now you are given an array $a$ of length $N$. He wants to use the $L$ array to challenge your computing ability.\n\nDefine $f(i,j)=|\\sum_{p=i}^{j} a_p|$, where $|x|$ denotes the absolute value of $x$.\n\nDefine the beauty of an array as $\\max_{1 \\le i \\le j \\le N} f(i,j)$. Each time he adds $x$ to the entire array, you need to answer the beauty at that moment.\n\nNote that your algorithm must be online.", "inputFormat": "The first line contains two integers $N,M$, representing the array length and the number of queries.\n\nThe second line contains $N$ integers, representing the initial array $a$.\n\nThe next $M$ lines each contain one integer $x_i$. Let the previous answer be $pre$. Then for the $i$-th query, it means adding $[(x_i+pre)\\%(4n+1)-2n]$ to the entire array based on the initial array. Here $\\%$ denotes the modulo operation. For the first answer, $pre=0$.", "outputFormat": "Output $M$ lines. The $i$-th line is the beauty of the array after adding $x_i$ to the entire array based on the initial array.", "hint": "The four added numbers are $-7$, $-4$, $-2$, and $1$.\n\nConstraints:\n\n$1 \\le N,M \\le 200000$.\n\n$|a_i| \\le 200000$.\n\n$0 \\le x_i \\le 800000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Added Sequence", "background": "", "description": "小$L$发明了一种新的数据结构，并将其命名为$L$数组。$L$数组的作用是可以在$O(1)$时间内将整个数组加上或减去一个数。现在给你一个长度为$N$的数组$a$，他想用$L$数组来挑战你的计算能力。\n\n定义$f(i,j)=|\\sum_{p=i}^{j} a_p|$其中$|x|$表示$x$的绝对值。\n\n定义一个数组的美丽度为$\\max_{1 \\le i \\le j \\le N} f(i,j)$，每当他将整个数组加上$x$ ，请你回答此时的美丽度。\n\n注意，你的算法必须为在线的。", "inputFormat": "第一行输入两个整数$N,M$，分别表示数组长度和询问数量。\n\n第二行输入$N$个整数，表示起始的数组$a$。\n\n接下来$M$行，每行一个整数$x_i$，设前面一次回答的答案为$pre$，那么表示第$i$次询问时在起始数组的基础上整个数组加上$[(x_i+pre)\\%(4n+1)-2n]$。其中$\\%$表示求余运算，第一次回答时$pre=0$。", "outputFormat": "输出$M$行，第$i$行为在起始数组的基础上整个数组加上$x_i$时的美丽度。", "hint": "四次加上的数字分别为-7，-4，-2，1。\n\n$1 \\le N,M \\le 200000$\n\n$|a_i| \\le 200000$\n\n$0 \\le x_i \\le 800000$", "locale": "zh-CN"}}}
{"pid": "P4757", "type": "P", "difficulty": 6, "samples": [["1\n6\n1 2\n2 3\n3 4\n3 5\n3 6\n4\n1 3\n4 5\n5 6\n6 4", "2"]], "limits": {"time": [1500, 1500], "memory": [128000, 128000]}, "tags": ["2014", "ICPC", "CERC"], "title": "[CERC2014] Parades", "background": "", "description": "In The City of Eternal Festivities, there are $n$ street junctions and $n-1$ bidirectional streets,each street connecting two of the junctions. Between every two junctions, there is exactly one (direct or indirect) path connecting them. No junction is an endpoint for more than 10 streets.\n\nEvery 13th of September (the 256th day of the year), there are many festivities going on in The City. In particular, the citizens want to organize $m$ parades. The parade number $i$ starts at junction $u_i$ and ends at $v_i$, following the unique path between the endpoints.\n\nAs the mayor of The City, you are responsible for citizens’ safety. Therefore you decreed that no two parades are ever allowed to use the same street, though they can have common junctions,or even common endpoints.\n\nTo appease your citizens, try to organize as many parades as possible, without breaking the safety regulations.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe first line of each test case contains a single integer: the number of junctions $n(2 \\le n \\le 1000)$. Each of the next $n - 1$ lines contains two integers $a, b(1 \\le a ≠ b \\le n)$, denoting that junctions $a$ and $b$ are connected by a street. Each junction has at most $10$ streets leaving it.\n\nThe next line contains a single integer: the number of planned parades $m, 0 \\le m \\le (_2^n)$.\n\nEach of the next $m$ lines contains two integers $u_i, v_i (1 \\le u_i ≠ v_i \\le n)$,meaning that a parade is planned to start at junction $u_i$, and finish at junction $v_i$. No two parades share both endpoints.", "outputFormat": "For each test case, output one line containing the largest number of parades that can be organized with no street used by more than one parade.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2014] Parades", "background": "", "description": "In The City of Eternal Festivities, there are $n$ street junctions and $n-1$ bidirectional streets,each street connecting two of the junctions. Between every two junctions, there is exactly one (direct or indirect) path connecting them. No junction is an endpoint for more than 10 streets.\n\nEvery 13th of September (the 256th day of the year), there are many festivities going on in The City. In particular, the citizens want to organize $m$ parades. The parade number $i$ starts at junction $u_i$ and ends at $v_i$, following the unique path between the endpoints.\n\nAs the mayor of The City, you are responsible for citizens’ safety. Therefore you decreed that no two parades are ever allowed to use the same street, though they can have common junctions,or even common endpoints.\n\nTo appease your citizens, try to organize as many parades as possible, without breaking the safety regulations.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe first line of each test case contains a single integer: the number of junctions $n(2 \\le n \\le 1000)$. Each of the next $n - 1$ lines contains two integers $a, b(1 \\le a ≠ b \\le n)$, denoting that junctions $a$ and $b$ are connected by a street. Each junction has at most $10$ streets leaving it.\n\nThe next line contains a single integer: the number of planned parades $m, 0 \\le m \\le (_2^n)$.\n\nEach of the next $m$ lines contains two integers $u_i, v_i (1 \\le u_i ≠ v_i \\le n)$,meaning that a parade is planned to start at junction $u_i$, and finish at junction $v_i$. No two parades share both endpoints.", "outputFormat": "For each test case, output one line containing the largest number of parades that can be organized with no street used by more than one parade.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2014] Parades", "background": "", "description": "在永恒节日之城，有 $n$ 个街道交叉口和 $n-1$ 条双向街道，每条街道连接两个交叉口。每两个交叉口之间，恰好有一条（直接或间接）路径连接它们。没有交叉口是超过 10 条街道的端点。\n\n每年 9 月 13 日（即一年中的第 256 天），永恒节日之城会举行许多庆祝活动。特别是，市民们想要组织 $m$ 场游行。第 $i$ 场游行从交叉口 $u_i$ 开始，到交叉口 $v_i$ 结束，沿着端点之间的唯一路径进行。\n\n作为城市的市长，你负责市民的安全。因此，你规定任何两场游行都不允许使用相同的街道，尽管它们可以有共同的交叉口，甚至是共同的端点。\n\n为了安抚市民，尽量组织尽可能多的游行，同时不违反安全规定。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来的每个测试用例描述如下：\n\n每个测试用例的第一行包含一个整数：交叉口的数量 $n(2 \\le n \\le 1000)$。接下来的 $n - 1$ 行中的每一行包含两个整数 $a, b(1 \\le a \neq b \\le n)$，表示交叉口 $a$ 和 $b$ 由一条街道连接。每个交叉口最多有 10 条街道离开。\n\n下一行包含一个整数：计划的游行数量 $m, 0 \\le m \\le \\binom{n}{2}$。\n\n接下来的 $m$ 行中的每一行包含两个整数 $u_i, v_i (1 \\le u_i \neq v_i \\le n)$，表示计划从交叉口 $u_i$ 开始，并在交叉口 $v_i$ 结束的游行。没有两场游行共享两个端点。", "outputFormat": "对于每个测试用例，输出一行，包含在不超过一条街道被多场游行使用的情况下可以组织的最大游行数量。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4758", "type": "P", "difficulty": 6, "samples": [["2\n8\n0 0\n3 7\n6 2\n9 4\n11 2\n13 3\n17 13\n20 7\n7\n0 2\n1 2\n3 1\n4 0\n5 2\n6 1\n7 3", "0 3 6 5 6 0 0\n6 4 4 0 6 0"]], "limits": {"time": [5000, 5000, 5000, 5000], "memory": [128000, 128000, 128000, 128000]}, "tags": ["2014", "ICPC", "CERC"], "title": "[CERC2014] Mountainous landscape", "background": "", "description": "You travel through a scenic landscape consisting mostly of mountains – there are $n$ landmarks (peaks and valleys) on your path. You pause for breath and wonder: which mountain are you currently seeing on the horizon?\n\n![0](https://cdn.luogu.com.cn/upload/pic/23379.png)\n\nFormally: you are given a polygonal chain $P_1,P_2,\\cdots,P_n$ in the plane. The $x$ coordinates of the points are in strictly increasing order. For each segment $P_i P_{i+1}$ of this chain, find the smallest index $j > i$, for which any point of $P_j P_{j+1}$ is visible from $P_i P_{i+1}$ (lies **strictly above** the ray $P_i \\ P^{\\rightarrow}_{i+1}$).\n\n", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe first line of each test case contains an integer $n(2 \\le n \\le 100 000)$ – the number of vertices on the chain.\n\nEach of the following $n$ lines contains integer coordinates $x_i, y_i$ of the vertex $P_i (0 \\le x_1 < x_2 < \\cdots < x_n \\le 10^9, 0 \\le y_i \\le 10^9)$.\n", "outputFormat": "For each test case, output a single line containing $n-1$ space-separated integers. These should be the smallest indices of chain segments visible to the right, or $0$ when no such segment exists.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2014] Mountainous landscape", "background": "", "description": "You travel through a scenic landscape consisting mostly of mountains – there are $n$ landmarks (peaks and valleys) on your path. You pause for breath and wonder: which mountain are you currently seeing on the horizon?\n\n![0](https://cdn.luogu.com.cn/upload/pic/23379.png)\n\nFormally: you are given a polygonal chain $P_1,P_2,\\cdots,P_n$ in the plane. The $x$ coordinates of the points are in strictly increasing order. For each segment $P_i P_{i+1}$ of this chain, find the smallest index $j > i$, for which any point of $P_j P_{j+1}$ is visible from $P_i P_{i+1}$ (lies **strictly above** the ray $P_i \\ P^{\\rightarrow}_{i+1}$).\n\n", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe first line of each test case contains an integer $n(2 \\le n \\le 100 000)$ – the number of vertices on the chain.\n\nEach of the following $n$ lines contains integer coordinates $x_i, y_i$ of the vertex $P_i (0 \\le x_1 < x_2 < \\cdots < x_n \\le 10^9, 0 \\le y_i \\le 10^9)$.\n", "outputFormat": "For each test case, output a single line containing $n-1$ space-separated integers. These should be the smallest indices of chain segments visible to the right, or $0$ when no such segment exists.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2014] Mountainous landscape", "background": null, "description": "你正在穿越一个以山脉为主的风景区——在你的路径上有 $n$ 个地标（山峰和山谷）。你停下来喘口气，想知道：你现在在地平线上看到的是哪座山？\n\n正式地说：给定一个平面上的多边形链 $P_1,P_2,\\cdots,P_n$。这些点的 $x$ 坐标是严格递增的。对于这条链的每一段 $P_i P_{i+1}$，找出最小的索引 $j > i$，使得 $P_j P_{j+1}$ 上的至少一个点从 $P_i P_{i+1}$ 可见（严格位于射线 $P_i \\ P^{\\rightarrow}_{i+1}$ 之上）。\n\n![0](https://cdn.luogu.com.cn/upload/pic/23379.png)", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来的部分是测试用例的描述：\n\n每个测试用例的第一行包含一个整数 $n(2 \\le n \\le 100 000)$——链上的顶点数量。\n\n接下来的 $n$ 行中的每一行包含顶点 $P_i$ 的整数坐标 $x_i, y_i (0 \\le x_1 < x_2 < \\cdots < x_n \\le 10^9, 0 \\le y_i \\le 10^9)$。", "outputFormat": "对于每个测试用例，输出一行包含 $n-1$ 个以空格分隔的整数。这些应该是向右可见的链段的最小索引，或者当不存在这样的链段时为 $0$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4759", "type": "P", "difficulty": 3, "samples": [["3\n8\n10\n24\n", "IMPOSSIBLE\n10 = 1 + 2 + 3 + 4\n24 = 7 + 8 + 9\n"]], "limits": {"time": [2000, 2000], "memory": [128000, 128000]}, "tags": ["2014", "枚举", "ICPC", "CERC"], "title": "[CERC2014] Sums", "background": "", "description": "Given an integer $N$, express it as the sum of at least two consecutive positive integers. For example:\n   \n   - $10 = 1 + 2 + 3 + 4$\n   - $24 = 7 + 8 + 9$\n\nIf there are multiple solutions, output the one with the smallest possible number of summands.\n", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case consists of one line containing an integer $N(1 \\le N \\le 10^9)$.", "outputFormat": "For each test case, output a single line containing the equation in the format:\n``N = a + (a+1) + ... + b`` as in the example. If there is no solution, output a single word ``IMPOSSIBLE`` instead.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2014] Sums", "background": "", "description": "Given an integer $N$, express it as the sum of at least two consecutive positive integers. For example:\n   \n   - $10 = 1 + 2 + 3 + 4$\n   - $24 = 7 + 8 + 9$\n\nIf there are multiple solutions, output the one with the smallest possible number of summands.\n", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case consists of one line containing an integer $N(1 \\le N \\le 10^9)$.", "outputFormat": "For each test case, output a single line containing the equation in the format:\n``N = a + (a+1) + ... + b`` as in the example. If there is no solution, output a single word ``IMPOSSIBLE`` instead.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2014] Sums", "background": "", "description": "## 题目大意\n\n一共有 $T$ 组数据，每组数据给定一个数 $N$，请将 $N$ 分解为几个连续正整数的和，如果有多种情况，请输出最小数最大的情况。", "inputFormat": "第一行，一个整数 $T$，表示数据组数。\n\n第 $2$ 行至第 $T+1$ 行，每行一个整数 $N$，表示要拆分的数字。", "outputFormat": "$T$ 行，每行一个式子，表示拆分结果。\n\n如果无解，请输出 `IMPOSSIBLE`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4760", "type": "P", "difficulty": 3, "samples": [["1\n5\n0 0 6\n6 8 4\n-9 0 3\n6 16 4\n0 -11 4\n", "1 clockwise\n3/2 counterclockwise\n2 counterclockwise\n3/2 clockwise\nnot moving"]], "limits": {"time": [1000, 1000], "memory": [128000, 128000]}, "tags": ["数学", "2014", "ICPC", "CERC"], "title": "[CERC2014] Wheels", "background": "", "description": "A very important and complicated machine consists of $n$ wheels, numbered $1, 2, . . . , n$. They are actually cogwheels, but the cogs are so small that we can model them as circles on the plane.\n\nEvery wheel can spin around its center.\n\nTwo wheels cannot overlap (they do not have common interior points), but they can touch.\n\nIf two wheels touch each other and one of them rotates, the other one spins as well, as their micro-cogs are locked together.\n\nA force is put to wheel $1$ (and to no other wheel), making it rotate at the rate of exactly one turn per minute, clockwise. Compute the rates of other wheels’ movement. You may assume that the machine is not jammed (the movement is physically possible).\n", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case consists of one line containing the number of wheels $n(1 \\le n \\le 1000)$ . \n\nEach of the following lines contain three integers $x, y$ and $r(-10 000 \\le x, y \\le 10 000, 1 \\le r \\le 10 000)$ where $(x, y)$ denote the Cartesian coordinates of the wheel’s center and $r$ is its radius.", "outputFormat": "For each test case, output $n$ lines, each describing the movement of one wheel, in the same order as in the input. For every wheel, output either ``p/q clockwise`` or ``p/q counterclockwise``,where the irreducible fraction $p/q$ is the number of wheel turns per minute. If $q$ is $1$, output just $p$ as an integer. If a wheel is standing still, output ``not moving``.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2014] Wheels", "background": "", "description": "A very important and complicated machine consists of $n$ wheels, numbered $1, 2, . . . , n$. They are actually cogwheels, but the cogs are so small that we can model them as circles on the plane.\n\nEvery wheel can spin around its center.\n\nTwo wheels cannot overlap (they do not have common interior points), but they can touch.\n\nIf two wheels touch each other and one of them rotates, the other one spins as well, as their micro-cogs are locked together.\n\nA force is put to wheel $1$ (and to no other wheel), making it rotate at the rate of exactly one turn per minute, clockwise. Compute the rates of other wheels’ movement. You may assume that the machine is not jammed (the movement is physically possible).\n", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nEach test case consists of one line containing the number of wheels $n(1 \\le n \\le 1000)$ . \n\nEach of the following lines contain three integers $x, y$ and $r(-10 000 \\le x, y \\le 10 000, 1 \\le r \\le 10 000)$ where $(x, y)$ denote the Cartesian coordinates of the wheel’s center and $r$ is its radius.", "outputFormat": "For each test case, output $n$ lines, each describing the movement of one wheel, in the same order as in the input. For every wheel, output either ``p/q clockwise`` or ``p/q counterclockwise``,where the irreducible fraction $p/q$ is the number of wheel turns per minute. If $q$ is $1$, output just $p$ as an integer. If a wheel is standing still, output ``not moving``.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2014] Wheels", "background": "", "description": "一个非常重要和复杂的机器由$n$个轮子组成，编号为$1,2,…,n$。它们其实是齿轮，但是齿太小了，我们可以把它们近似看成成平面上的圆。\r\n\r\n每一个齿轮都能围绕它的中心旋转。\r\n\r\n两个齿轮不会重叠（因为它们内部没有共同的点），但它们可以互相接触。\r\n\r\n如果两个齿轮相互接触，其中一个齿轮转动，另一个齿轮也随之转动，因为它们的齿被卡在一起。\r\n\r\n一个力作用于齿轮1（并且力没有作用于其他齿轮），使它以每分钟转一圈的速度顺时针旋转。计算其他齿轮的运动速度。你可以假设机器没有卡住（运动在物理理论上是可以的）。", "inputFormat": "输入包括多组数据，第一行为组数$T$；\r\n\r\n对于每组数据如下：\r\n\r\n第一行包括一个齿轮数$n,(1 \\le n \\le 1000)$。\r\n\r\n接下来$n$行每行包含三个整数$x,y,r,(10000≤x,y≤10000,1≤r≤10000)$，其中$(x,y)$表示齿轮中心的笛卡尔坐标（直角坐标），$r$是其半径。", "outputFormat": "对于每组数据，输出$n$行，第$i$行为第$i$个齿轮的运动状态。对于每个齿轮，输出或`p/q clockwise`或`p/q counterclockwise`，其中最简分数`p/q`是每分钟齿轮转数。如果$q$为$1$，则输出整数$p$。如果齿轮静止不动，则输出`not moving`。", "hint": "", "locale": "zh-CN"}}}
