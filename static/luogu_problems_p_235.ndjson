{"pid": "P5752", "type": "P", "difficulty": 4, "samples": [["3\n1 1 1 1 1 1 1 3\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 0\n1 1 1 1 1 1 0 3\n", "1.633\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "1999", "NOI", "Special Judge", "记忆化搜索", "区间 DP"], "title": "[NOI1999] 棋盘分割", "background": "", "description": "将一个 8 $\\times$ 8 的棋盘进行如下分割：将原棋盘割下一块矩形棋盘并使剩下部分也是矩形，再将剩下的部分继续如此分割，这样割了 $(n-1)$ 次后，连同最后剩下的矩形棋盘共有 $n$ 块矩形棋盘。 (每次切割都只能沿着棋盘格子的边进行)\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ivf3ggl3.png)\n\n\n原棋盘上每一格有一个分值，一块矩形棋盘的总分为其所含各格分值之和。现在需要把棋盘按上述规则分割成 $n$ 块矩形棋盘，并使各矩形棋盘总分的均方差最小。\n\n\n均方差 $\\sigma = \\sqrt{ \\frac{ \\sum_{i=1}^n (x_i - \\bar x)^2 } { n }}$                ，其中平均值 $\\bar x = \\frac{\\sum_{i=1}^n x_i}{n}$ ,  $x_i$ 为第 $i$ 块矩形棋盘的分。\n\n\n请编程对给出的棋盘及 $n$ ，求出 $\\sigma$ 的最小值。\n", "inputFormat": "第一行为一个整数 $n$ ($ 1 < n< 15 $)。\n\n\n第二行至第九行每行为 $8$ 个小于 $100$ 的非负整数，表示棋盘上相应格子的分值。每行相邻两数之间用一个空格分隔。\n", "outputFormat": "仅一个数，为 $\\sigma$ （四舍五入精确到小数点后三位）。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[NOI1999] Chessboard Partition", "background": "", "description": "Partition an $8 \\times 8$ chessboard as follows: cut off a rectangular piece from the original board such that the remaining part is also a rectangle, then continue partitioning the remaining part in the same way. After cutting $(n-1)$ times, together with the final remaining rectangle, there are a total of $n$ rectangular pieces. (Each cut can only be made along the edges of the grid cells.)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ivf3ggl3.png)\n\nEach cell on the original board has a score. The total score of a rectangular piece is the sum of the scores of all cells it contains. Now you need to partition the board into $n$ rectangular pieces according to the rule above, and minimize the standard deviation of the total scores of all rectangular pieces.\n\nThe standard deviation is\n$$\\sigma = \\sqrt{ \\frac{ \\sum_{i=1}^n (x_i - \\bar x)^2 } { n }}$$\nwhere the average is\n$$\\bar x = \\frac{\\sum_{i=1}^n x_i}{n}$$\nand $x_i$ is the score of the $i$-th rectangular piece.\n\nGiven the board and $n$, compute the minimum possible value of $\\sigma$.", "inputFormat": "The first line contains an integer $n$ ($1 < n < 15$).\n\nLines 2 to 9 each contain $8$ non-negative integers less than $100$, representing the scores of the corresponding cells on the board. Adjacent numbers in each line are separated by one space.", "outputFormat": "Output only one number, $\\sigma$, rounded to three digits after the decimal point.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI1999] 棋盘分割", "background": "", "description": "将一个 8 $\\times$ 8 的棋盘进行如下分割：将原棋盘割下一块矩形棋盘并使剩下部分也是矩形，再将剩下的部分继续如此分割，这样割了 $(n-1)$ 次后，连同最后剩下的矩形棋盘共有 $n$ 块矩形棋盘。 (每次切割都只能沿着棋盘格子的边进行)\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ivf3ggl3.png)\n\n\n原棋盘上每一格有一个分值，一块矩形棋盘的总分为其所含各格分值之和。现在需要把棋盘按上述规则分割成 $n$ 块矩形棋盘，并使各矩形棋盘总分的均方差最小。\n\n\n均方差 $\\sigma = \\sqrt{ \\frac{ \\sum_{i=1}^n (x_i - \\bar x)^2 } { n }}$                ，其中平均值 $\\bar x = \\frac{\\sum_{i=1}^n x_i}{n}$ ,  $x_i$ 为第 $i$ 块矩形棋盘的分。\n\n\n请编程对给出的棋盘及 $n$ ，求出 $\\sigma$ 的最小值。\n", "inputFormat": "第一行为一个整数 $n$ ($ 1 < n< 15 $)。\n\n\n第二行至第九行每行为 $8$ 个小于 $100$ 的非负整数，表示棋盘上相应格子的分值。每行相邻两数之间用一个空格分隔。\n", "outputFormat": "仅一个数，为 $\\sigma$ （四舍五入精确到小数点后三位）。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5753", "type": "P", "difficulty": 2, "samples": [["48\n7\n", "3\n"], ["8\n5\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2000", "NOI"], "title": "[NOI2000] 瓷片项链", "background": "", "description": "原始部落用一种稀有的泥土烧制直径相同的圆瓷片并串成项链，串的时候沿瓷片的直径方向顺次连接，瓷片之间没有空隙也不重叠，一条项链至少由一个瓷片构成。\n\n下图示出四片同样大小的瓷片串接所成的项链，其总长为单个瓷片直径的四倍。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/palmhlro.png)\n\n\n每个烧制的瓷片厚度是一定的，直径 $D$ 和所用泥土的体积 $V$ 有以下关系：\n\n$$D = \\begin{cases}\n0.3\\sqrt{V-V_0} & V > V_0 \\cr\n0 & V \\le V_0\n\\end{cases}$$\n\n\n其中 $V_0$ 为烧制每一片的损耗，单位与 $V$ 相同。当用料小于等于 $V_0$ 时，不能烧制成瓷片。\n例： $V_总 = 10，V_0 = 1 $，若烧制成一片瓷片，$ V = V_总= 10，D = 0.9 $。如果把泥土均分成 $2$ 份，每份泥土的体积为 $V = \\frac{V_总}{2} = 5 $，单个瓷片的直径为 $ D' = 0.3 \\times \\sqrt{5-1} =0.6 $ ,串起来的总长为 $1.2$ 。\n\n给定了泥土的总体积和烧制单个瓷片的损耗，烧制的瓷片数不同，能够得到的项链总长度也不相同，请计算烧制多少个瓷片能使所得到的项链最长。\n", "inputFormat": "共两行，每一行仅包含一个整数。\n\n第一行的数字为泥土总体积 $ V_总$ ( $ 0 < V_总 < 60000 $ )，第二行为烧制单个瓷片的损耗 $V_0$ ($ 0 <  V_0 < 600 $)。", "outputFormat": "共一行，一个整数。\n\n该整数为能获得最长项链而烧制的瓷片数。如果不能烧制成瓷片或者最优解不唯一（存在两个或者两个以上方案均能获得最长项链），输出 `0`。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2000] Porcelain Disc Necklace", "background": "", "description": "A primitive tribe uses a rare kind of clay to fire circular porcelain discs of the same thickness and string them into a necklace. When stringing, the discs are connected in order along their diameters. There are no gaps and no overlaps between adjacent discs. A necklace consists of at least one disc.\n\nThe figure below shows a necklace made by stringing four discs of the same size. Its total length is four times the diameter of a single disc.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/palmhlro.png)\n\nFor each fired disc, the thickness is fixed, and the diameter $D$ and the volume of clay used $V$ satisfy:\n\n$$D = \\begin{cases}\n0.3\\sqrt{V-V_0} & V > V_0 \\cr\n0 & V \\le V_0\n\\end{cases}$$\n\nHere $V_0$ is the loss (waste) incurred when firing each disc, with the same unit as $V$. If the amount of clay used is less than or equal to $V_0$, a disc cannot be produced.\n\nExample: $V_总 = 10，V_0 = 1$.\nIf you fire one disc, $V = V_总 = 10$, so $D = 0.9$.\nIf you divide the clay evenly into $2$ parts, each part has volume $V = \\frac{V_总}{2} = 5$, and the diameter of one disc is $D' = 0.3 \\times \\sqrt{5-1} = 0.6$. Then the total length when strung is $1.2$.\n\nGiven the total volume of clay and the loss for firing a single disc, different numbers of discs lead to different total necklace lengths. Compute how many discs should be fired to make the necklace as long as possible.", "inputFormat": "Two lines in total, each line contains one integer.\n\nThe first line is the total volume of clay $V_总$ ($0 < V_总 < 60000$). The second line is the loss per disc $V_0$ ($0 < V_0 < 600$).", "outputFormat": "One line containing one integer.\n\nThis integer is the number of discs to fire in order to obtain the longest necklace. If it is impossible to fire any disc, or if the optimal solution is not unique (there exist two or more choices that all achieve the maximum necklace length), output `0`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2000] 瓷片项链", "background": "", "description": "原始部落用一种稀有的泥土烧制直径相同的圆瓷片并串成项链，串的时候沿瓷片的直径方向顺次连接，瓷片之间没有空隙也不重叠，一条项链至少由一个瓷片构成。\n\n下图示出四片同样大小的瓷片串接所成的项链，其总长为单个瓷片直径的四倍。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/palmhlro.png)\n\n\n每个烧制的瓷片厚度是一定的，直径 $D$ 和所用泥土的体积 $V$ 有以下关系：\n\n$$D = \\begin{cases}\n0.3\\sqrt{V-V_0} & V > V_0 \\cr\n0 & V \\le V_0\n\\end{cases}$$\n\n\n其中 $V_0$ 为烧制每一片的损耗，单位与 $V$ 相同。当用料小于等于 $V_0$ 时，不能烧制成瓷片。\n例： $V_总 = 10，V_0 = 1 $，若烧制成一片瓷片，$ V = V_总= 10，D = 0.9 $。如果把泥土均分成 $2$ 份，每份泥土的体积为 $V = \\frac{V_总}{2} = 5 $，单个瓷片的直径为 $ D' = 0.3 \\times \\sqrt{5-1} =0.6 $ ,串起来的总长为 $1.2$ 。\n\n给定了泥土的总体积和烧制单个瓷片的损耗，烧制的瓷片数不同，能够得到的项链总长度也不相同，请计算烧制多少个瓷片能使所得到的项链最长。\n", "inputFormat": "共两行，每一行仅包含一个整数。\n\n第一行的数字为泥土总体积 $ V_总$ ( $ 0 < V_总 < 60000 $ )，第二行为烧制单个瓷片的损耗 $V_0$ ($ 0 <  V_0 < 600 $)。", "outputFormat": "共一行，一个整数。\n\n该整数为能获得最长项链而烧制的瓷片数。如果不能烧制成瓷片或者最优解不唯一（存在两个或者两个以上方案均能获得最长项链），输出 `0`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5754", "type": "P", "difficulty": 3, "samples": [["4\n3 0 2 2", "3 1 2 4\n4 1 3 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "各省省选", "江苏"], "title": "[JSOI2010] 排名", "background": "在植树节那天，小 L，小 H，小 X 却要面对繁忙的考试。\n\n考完后，按照惯例，他们讨论起了成绩。小 L 非常八卦，他向全班 $N$ 个同学问了他们的成绩情况。当然，就如你想象的那样，每个人也不愿意透露太多信息，每个人只说了他的分数比哪一个同学低，也有些人没说任何信息。\n\n勤奋的小 H 和爱偷懒的小 X 对于班上所有同学的成绩排名都有一个“心理期望”，也就是说，小 H 可能认为 XX 会排第 $1$，YY 会排第 $2$……但小 X 却会认为 XX 应该排最后 $1$ 名，YY 会排倒数第 $2$ 名。\n\n不过理想和现实总是有差距的，通过小 L 打探到的情报， XX 不能排在第 $1$ 了，但是，小 H 仍然觉得 XX 应该排在尽可能前。\n\n小 L 由此想到了一个问题，他想知道小 H 和小 X 知道他打探到的情报之后，对班上同学的心里排名是什么样的。\n\n每个同学的编号即为小 H 的心理排名，也就是说，小 H 希望编号越靠前的同学排名也尽量靠前，而小 X 希望希望编号越靠前的同学排名尽量靠后。（注意不是越后面的同学排名越靠前）", "description": "给定一个长度为 $N$ 的数列 $A$，其中 $A_i$ 表示第 $i$ 个同学的分数比第 $A_i$ 个同学的分数低（或者说，第 $i$ 个同学的排名在第 $A_i$ 个同学之后）。当然，$A_i$ 有可能等于 $0$，则表明没有关于第 $i$ 个同学的信息。\n\n你需要得到一个长度为 $N$ 的数列 $H$，表示班上同学的排名。这个排名要求是满足所有 $A_i$ 构成的约束的排名中字典序最小的哪一个。\n\n同时，你还需要得到一个数列 $X$，表示班上同学的排名。这个排名要求是满足所有 $A_i$ 构成的约束的排名中字典序最大的哪一个。", "inputFormat": "第 $1$ 行一个正整数 $N$，表示班上同学的个数。\n\n第 $2$ 行包含 $N$ 个用空格隔开的非负整数，第 $i$ 个数表示 $A_i$。", "outputFormat": "两行，每行 $N$ 个正整数，用空格隔开。其中，第 $1$ 行为小 L 的心理排名，第 $2$ 行为小 X 的心理排名。", "hint": "### 样例解释\n\n共有 $3$ 种排名满足大小关系：\n\n```plain\n4 1 3 2\n4 1 2 3\n3 1 2 4\n```\n\n其中，`3 1 2 4` 字典序最小，`4 1 3 2` 字典序最大。\n\n### 数据范围\n\n对于 $10\\%$ 的数据，$N\\leq 10$。\n\n对于 $20\\%$ 的数据，$N\\leq 20$。\n\n对于 $40\\%$ 的数据，$N\\leq 2\\times 10^3$。\n\n对于 $100\\%$ 的数据，$1 \\leq N\\leq 2\\times 10^5,A_i\\leq N$。其中，第 $5$ 组数据保证 $N=1.2\\times 10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JSOI2010] 排名", "background": "在植树节那天，小 L，小 H，小 X 却要面对繁忙的考试。\n\n考完后，按照惯例，他们讨论起了成绩。小 L 非常八卦，他向全班 $N$ 个同学问了他们的成绩情况。当然，就如你想象的那样，每个人也不愿意透露太多信息，每个人只说了他的分数比哪一个同学低，也有些人没说任何信息。\n\n勤奋的小 H 和爱偷懒的小 X 对于班上所有同学的成绩排名都有一个“心理期望”，也就是说，小 H 可能认为 XX 会排第 $1$，YY 会排第 $2$……但小 X 却会认为 XX 应该排最后 $1$ 名，YY 会排倒数第 $2$ 名。\n\n不过理想和现实总是有差距的，通过小 L 打探到的情报， XX 不能排在第 $1$ 了，但是，小 H 仍然觉得 XX 应该排在尽可能前。\n\n小 L 由此想到了一个问题，他想知道小 H 和小 X 知道他打探到的情报之后，对班上同学的心里排名是什么样的。\n\n每个同学的编号即为小 H 的心理排名，也就是说，小 H 希望编号越靠前的同学排名也尽量靠前，而小 X 希望希望编号越靠前的同学排名尽量靠后。（注意不是越后面的同学排名越靠前）", "description": "给定一个长度为 $N$ 的数列 $A$，其中 $A_i$ 表示第 $i$ 个同学的分数比第 $A_i$ 个同学的分数低（或者说，第 $i$ 个同学的排名在第 $A_i$ 个同学之后）。当然，$A_i$ 有可能等于 $0$，则表明没有关于第 $i$ 个同学的信息。\n\n你需要得到一个长度为 $N$ 的数列 $H$，表示班上同学的排名。这个排名要求是满足所有 $A_i$ 构成的约束的排名中字典序最小的哪一个。\n\n同时，你还需要得到一个数列 $X$，表示班上同学的排名。这个排名要求是满足所有 $A_i$ 构成的约束的排名中字典序最大的哪一个。", "inputFormat": "第 $1$ 行一个正整数 $N$，表示班上同学的个数。\n\n第 $2$ 行包含 $N$ 个用空格隔开的非负整数，第 $i$ 个数表示 $A_i$。", "outputFormat": "两行，每行 $N$ 个正整数，用空格隔开。其中，第 $1$ 行为小 L 的心理排名，第 $2$ 行为小 X 的心理排名。", "hint": "### 样例解释\n\n共有 $3$ 种排名满足大小关系：\n\n```plain\n4 1 3 2\n4 1 2 3\n3 1 2 4\n```\n\n其中，`3 1 2 4` 字典序最小，`4 1 3 2` 字典序最大。\n\n### 数据范围\n\n对于 $10\\%$ 的数据，$N\\leq 10$。\n\n对于 $20\\%$ 的数据，$N\\leq 20$。\n\n对于 $40\\%$ 的数据，$N\\leq 2\\times 10^3$。\n\n对于 $100\\%$ 的数据，$1 \\leq N\\leq 2\\times 10^5,A_i\\leq N$。其中，第 $5$ 组数据保证 $N=1.2\\times 10^4$。", "locale": "zh-CN"}}}
{"pid": "P5755", "type": "P", "difficulty": 3, "samples": [["A\nAN\nASP\nAS\nASC\nASCII\nBAS\nBASIC\n", "13\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2000", "NOI", "字典树 Trie"], "title": "[NOI2000] 单词查找树", "background": "", "description": "在进行文法分析的时候，通常需要检测一个单词是否在我们的单词列表里。为了提高查找和定位的速度，通常都要画出与单词列表所对应的单词查找树，其特点如下：\n-\t根节点不包含字母，除根节点外每一个节点都仅包含一个大写英文字母；\n-\t从根节点到某一节点，路径上经过的字母依次连起来所构成的字母序列，称为该节点对应的单词。单词列表中的每个词，都是该单词查找树某个节点所对应的单词；\n-\t在满足上述条件下，该单词查找树的节点数最少。\n\n\n例：图一的单词列表对应图二的单词查找树\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zolscsb0.png)\n\n对一个确定的单词列表，请统计对应的单词查找树的节点数（包括根节点）\n", "inputFormat": "一个单词列表，每一行仅包含一个单词。每个单词仅由大写的英文字符组成，长度不超过 $63$ 个字符。文件总长度不超过 32K，至少有一行数据。", "outputFormat": "仅包含一个整数。该整数为单词列表对应的单词查找树的节点数。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2000] Word Lookup Tree.", "background": "", "description": "When doing grammar analysis, we usually need to check whether a word is in our word list. To improve the speed of searching and locating, we often build a word lookup tree corresponding to the word list, with the following features:\n\n- The root node contains no letter. Every node except the root contains exactly one uppercase English letter.\n- For any node, the sequence of letters along the path from the root to that node, concatenated in order, is called the word corresponding to that node. Every word in the word list is the word corresponding to some node in the word lookup tree.\n- Under the above conditions, the word lookup tree has the minimum possible number of nodes.\n\nExample: the word list in Figure 1 corresponds to the word lookup tree in Figure 2.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zolscsb0.png)\n\nFor a given word list, count the number of nodes in the corresponding word lookup tree (including the root node).", "inputFormat": "A word list, one word per line. Each word consists only of uppercase English letters and has length at most $63$. The total file length does not exceed 32K. There is at least one line of data.", "outputFormat": "Output a single integer. This integer is the number of nodes in the word lookup tree corresponding to the word list.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2000] 单词查找树", "background": "", "description": "在进行文法分析的时候，通常需要检测一个单词是否在我们的单词列表里。为了提高查找和定位的速度，通常都要画出与单词列表所对应的单词查找树，其特点如下：\n-\t根节点不包含字母，除根节点外每一个节点都仅包含一个大写英文字母；\n-\t从根节点到某一节点，路径上经过的字母依次连起来所构成的字母序列，称为该节点对应的单词。单词列表中的每个词，都是该单词查找树某个节点所对应的单词；\n-\t在满足上述条件下，该单词查找树的节点数最少。\n\n\n例：图一的单词列表对应图二的单词查找树\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zolscsb0.png)\n\n对一个确定的单词列表，请统计对应的单词查找树的节点数（包括根节点）\n", "inputFormat": "一个单词列表，每一行仅包含一个单词。每个单词仅由大写的英文字符组成，长度不超过 $63$ 个字符。文件总长度不超过 32K，至少有一行数据。", "outputFormat": "仅包含一个整数。该整数为单词列表对应的单词查找树的节点数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5756", "type": "P", "difficulty": 4, "samples": [["10 A+1\n20 IF A=5 GO 60\n60 END\n30 A+2\n40 A?\n50 GO 20\n", "11\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2000", "NOI"], "title": "[NOI2000] 程序分析器", "background": "", "description": "Tiny Basm语言(简称为TB语言)的巴科斯-瑙尔范式(BNF)为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/37ipxplt.png)\n\n错误语句示例(在输入文件中不会出现任何错误语句)：\n\n- `10 A+1.5`（不符合累加语句的定义，所加的不是整数）\n- `20 A ?`（不符合输出语句的定义，多加了一个空格）\n- `30 IF A=B GO 10`（不符合条件语句的定义，不应变量=变量）\n\n$\\\\$\n\nTB程序的执行：\n-\t程序从行号最小的一条语句开始执行，在未遇到条件语句时按行号由小至大顺序执行。\n-\t所有变量在程序执行前被自动初始化为 $0$。\n-\t累加语句将语句中变量的值加上语句中的整数送回该变量。\n-\t输出语句将语句中变量的值在监视器上显示出来。\n-\t执行条件语句时，当且仅当该语句中的变量与紧跟在等号后面的整数值相等，后面的转移语句才被执行。该语句中的所有整数值至多为 $4$ 位。\n-\t转移语句被执行后，程序将转去执行 $\\tt GO$ 后面指定的行号的语句。\n-\t当程序执行结束语句后，结束整个程序的执行。\n-\t假设该系统能处理任意大小的整数，而不会发生溢出。\n\n\n请编程，对于给定的 TB 语言程序 $P$，求该程序所执行的语句数（执行条件语句不论是否成功转移，仅记为执行一条语句）。", "inputFormat": "- 为一个TB语言程序 $P$ ，语句数不超过 $100$ 行。\n- $P$ 中每条语句的长度不超过 $20$ 个字符。\n- $P$ 中转移语句里 $\\tt GO$ 后面的行号一定有对应的语句。\n- $P$ 中可能有多个不同行号的结束语句。\n- $P$ 中行号最大的语句一定是结束语句。\n- $P$ 中的行号都不大于 $3000$。\n- 输入文件不一定是按行号递增顺序给出 $P$ 的。\n", "outputFormat": "-\t有且仅有一行：\n\n如果程序能够正常结束，输出该程序所执行的语句数；\n\n如果程序不能正常结束，输出 $-1$。\n", "hint": "**样例说明**\n\n执行语句行号按顺序为 $10→20→30→40→50→20→30→40→50→20→60$。\n\n共 $11$ 条语句被执行。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2000] Program Analyzer", "background": "", "description": "The Backus–Naur Form (BNF) of the Tiny Basm language (abbreviated as TB) is:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/37ipxplt.png)\n\nExamples of incorrect statements (no incorrect statements will appear in the input file):\n\n- `10 A+1.5` (does not match the definition of an addition statement, because the added value is not an integer)\n- `20 A ?` (does not match the definition of an output statement, because there is an extra space)\n- `30 IF A=B GO 10` (does not match the definition of a conditional statement; it should not be variable $=$ variable)\n\n$\\\\$\n\nExecution of a TB program:\n\n- The program starts executing from the statement with the smallest line number. Before encountering any conditional statement, it executes statements in increasing order of line number.\n- All variables are automatically initialized to $0$ before execution.\n- An addition statement adds the integer in the statement to the value of the variable, and stores the result back into that variable.\n- An output statement displays the value of the variable in the statement on the monitor.\n- When executing a conditional statement, the following jump statement is executed if and only if the variable in the statement is equal to the integer value immediately after the equals sign. All integer values in this statement are at most $4$ digits.\n- After a jump statement is executed, the program jumps to the statement with the line number specified after $\\tt GO$.\n- When the program executes an end statement, the entire program terminates.\n- Assume the system can handle integers of any size without overflow.\n\nPlease write a program that, for a given TB program $P$, computes the number of statements executed by the program (for a conditional statement, regardless of whether the jump succeeds, it is counted as executing exactly one statement).", "inputFormat": "- The input is a TB program $P$, with no more than $100$ statements (lines).\n- The length of each statement in $P$ does not exceed $20$ characters.\n- For every jump statement in $P$, the line number after $\\tt GO$ definitely has a corresponding statement.\n- $P$ may contain multiple end statements with different line numbers.\n- The statement with the largest line number in $P$ is definitely an end statement.\n- All line numbers in $P$ are no greater than $3000$.\n- The input file does not necessarily list $P$ in increasing order of line numbers.", "outputFormat": "- There is exactly one line:\n\nIf the program can terminate normally, output the number of statements executed;\n\nif the program cannot terminate normally, output $-1$.", "hint": "**Sample Explanation**\n\nThe executed line numbers in order are $10→20→30→40→50→20→30→40→50→20→60$.\n\nA total of $11$ statements are executed.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2000] 程序分析器", "background": "", "description": "Tiny Basm语言(简称为TB语言)的巴科斯-瑙尔范式(BNF)为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/37ipxplt.png)\n\n错误语句示例(在输入文件中不会出现任何错误语句)：\n\n- `10 A+1.5`（不符合累加语句的定义，所加的不是整数）\n- `20 A ?`（不符合输出语句的定义，多加了一个空格）\n- `30 IF A=B GO 10`（不符合条件语句的定义，不应变量=变量）\n\n$\\\\$\n\nTB程序的执行：\n-\t程序从行号最小的一条语句开始执行，在未遇到条件语句时按行号由小至大顺序执行。\n-\t所有变量在程序执行前被自动初始化为 $0$。\n-\t累加语句将语句中变量的值加上语句中的整数送回该变量。\n-\t输出语句将语句中变量的值在监视器上显示出来。\n-\t执行条件语句时，当且仅当该语句中的变量与紧跟在等号后面的整数值相等，后面的转移语句才被执行。该语句中的所有整数值至多为 $4$ 位。\n-\t转移语句被执行后，程序将转去执行 $\\tt GO$ 后面指定的行号的语句。\n-\t当程序执行结束语句后，结束整个程序的执行。\n-\t假设该系统能处理任意大小的整数，而不会发生溢出。\n\n\n请编程，对于给定的 TB 语言程序 $P$，求该程序所执行的语句数（执行条件语句不论是否成功转移，仅记为执行一条语句）。", "inputFormat": "- 为一个TB语言程序 $P$ ，语句数不超过 $100$ 行。\n- $P$ 中每条语句的长度不超过 $20$ 个字符。\n- $P$ 中转移语句里 $\\tt GO$ 后面的行号一定有对应的语句。\n- $P$ 中可能有多个不同行号的结束语句。\n- $P$ 中行号最大的语句一定是结束语句。\n- $P$ 中的行号都不大于 $3000$。\n- 输入文件不一定是按行号递增顺序给出 $P$ 的。\n", "outputFormat": "-\t有且仅有一行：\n\n如果程序能够正常结束，输出该程序所执行的语句数；\n\n如果程序不能正常结束，输出 $-1$。\n", "hint": "**样例说明**\n\n执行语句行号按顺序为 $10→20→30→40→50→20→30→40→50→20→60$。\n\n共 $11$ 条语句被执行。\n", "locale": "zh-CN"}}}
{"pid": "P5757", "type": "P", "difficulty": 6, "samples": [["11\nn.table\nn.baleine\na.silly\nn.snoopy\nn.sillysnoopy\nv.is\nv.isnot\nn.kick\nv.kick\na.big\nv.cry\nsillysnoopyisnotbigtablebaleinekicksnoopysillycry.\n", "2\n9\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2000", "NOI"], "title": "[NOI2000] 古城之谜", "background": "", "description": "著名的考古学家石教授在云梦高原上发现了一处古代城市遗址。让教授欣喜的是在这个他称为冰峰城 (Ice-Peak City) 的城市中有 $12$ 块巨大石碑，上面刻着用某种文字书写的资料，他称这种文字为冰峰文。然而当教授试图再次找到冰峰城时，却屡屡无功而返。\n\n幸好当时教授把石碑上的文字都拍摄了下来，为了解开冰峰城的秘密，教授和他的助手牛博士开始研究冰峰文，发现冰峰文只有陈述句这一种句型和名词 (n) 、动词 (v) 、辅词 (a) 这三类单词，且其文法很简单：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fj2tbbqd.png)\n\n在研究了大量资料后，他们总结了一部冰峰文词典，由于冰峰文恰好有 $26$ 个字母，为了研究方便，用字母 $a$ 到 $z$ 表示它们。\n\n冰峰文在句子和句子之间以及单词和单词之间没有任何分隔符，因此划分单词和句子令石教授和牛博士感到非常麻烦，于是他们想到了使用计算机来帮助解决这个问题。假设你接受了这份工作，你的第一个任务是写一个程序，将一篇冰峰文文章划分为最少的句子，在这个前提下，将文章划分为最少的单词。\n", "inputFormat": "-\t第 $1$ 行为词典中的单词数 $n$ （$ n \\le 1000 $）。\n-\t第 $2$ 行至第 $(n+1)$ 行每行表示一个单词，形为 $\"α.mot\"$ ，$α$ 表示词性，可能是 n (名词), v（动词）, a（辅词）中的一个， $mot$ 为单词，单词的长度不超过 $20$ 。拼写相同而词性不同的单词视为不同的单词，如输入示例中的 n.kick 与 v.kick 是两个不同的单词。\n-\t输入文件第 $(n+2)$ 行为需要划分的文章，以 \".\" 结束。\n-\t输入文件中的文章确保为冰峰文。文章是由有限个句子组成的，每个句子只包含有限个单词。文章长度不超过 5KB。\n", "outputFormat": "-\t为两行，每行一个整数。\n-\t第 $1$ 行为划分出来的句子数。\n-\t第 $2$ 行为划分出来的单词数。\n", "hint": "**样例说明**\n\n（为了阅读方便，划分的单词用空格分隔，在单词的右上角标出它的词性，每行写一个句子，用句号表示句子结束。）\n\n输出对应的划分：\n\n$ sillysnoopy^n \\quad isnot^v \\quad big^a \\quad table^n. \\\\\nbaleine^n \\quad kick^v \\quad snoopy^n \\quad silly^a \\quad cry^v. $\n\n如果用下面的划分：\n\n$ silly^a \\quad snoopy^n \\quad isnot^v \\quad big^a \\quad table^n. \\\\\nbaleine^n \\quad kick^v \\quad snoopy^n \\quad silly^a \\quad cry^v.$\n\n则划分的句子数仍为 $2$ 个，但单词数却多了 $1$ 个，为 $10$ 个，显然应该按前者而不是后者划分。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2000] Mystery of the Ancient City", "background": "", "description": "The famous archaeologist Professor Shi discovered an ancient city ruin on the Yunmeng Plateau. To his delight, in this city that he called Ice-Peak City, there were $12$ huge stone tablets, engraved with information written in some kind of script, which he named the Ice-Peak script. However, when Professor Shi tried to find Ice-Peak City again, he failed again and again.\n\nFortunately, he had photographed all the text on the tablets. In order to uncover the secrets of Ice-Peak City, Professor Shi and his assistant Dr. Niu began to study the Ice-Peak script. They found that the Ice-Peak script has only one sentence type: declarative sentences, and only three categories of words: nouns (n), verbs (v), and auxiliary words (a). Its grammar is very simple:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fj2tbbqd.png)\n\nAfter studying a large amount of material, they summarized an Ice-Peak dictionary. Since the Ice-Peak script happens to have $26$ letters, for convenience they use the letters $a$ to $z$ to represent them.\n\nIn the Ice-Peak script, there are no separators between sentences, nor between words. So splitting words and sentences is very troublesome for Professor Shi and Dr. Niu. They decided to use a computer to help solve this problem. Suppose you accept this job. Your first task is to write a program that splits an Ice-Peak article into the minimum number of sentences, and under this premise, splits the article into the minimum number of words.", "inputFormat": "- Line $1$ contains the number of words in the dictionary $n$ ($n \\le 1000$).\n- Lines $2$ to $(n+1)$ each describe one word, in the form $\"α.mot\"$. Here $α$ is the part of speech, which can be one of n (noun), v (verb), a (auxiliary word), and $mot$ is the word. The word length does not exceed $20$. Words with the same spelling but different parts of speech are considered different words. For example, n.kick and v.kick in the sample input are two different words.\n- Line $(n+2)$ of the input file is the article to be split, ending with \".\".\n- The article in the input file is guaranteed to be in the Ice-Peak script. The article consists of finitely many sentences, and each sentence contains only finitely many words. The article length does not exceed 5 KB.", "outputFormat": "- Output two lines, each containing one integer.\n- Line $1$ is the number of sentences after splitting.\n- Line $2$ is the number of words after splitting.", "hint": "**Sample Explanation**\n\n(For easier reading, the split words are separated by spaces, the part of speech is marked at the upper right of each word, one sentence per line, and a period indicates the end of a sentence.)\n\nThe output corresponds to the following splitting:\n\n$ sillysnoopy^n \\quad isnot^v \\quad big^a \\quad table^n. \\\\\nbaleine^n \\quad kick^v \\quad snoopy^n \\quad silly^a \\quad cry^v. $\n\nIf the following splitting is used:\n\n$ silly^a \\quad snoopy^n \\quad isnot^v \\quad big^a \\quad table^n. \\\\\nbaleine^n \\quad kick^v \\quad snoopy^n \\quad silly^a \\quad cry^v.$\n\nthen the number of sentences is still $2$, but the number of words increases by $1$ to $10$. Clearly, the former splitting should be chosen rather than the latter.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2000] 古城之谜", "background": "", "description": "著名的考古学家石教授在云梦高原上发现了一处古代城市遗址。让教授欣喜的是在这个他称为冰峰城 (Ice-Peak City) 的城市中有 $12$ 块巨大石碑，上面刻着用某种文字书写的资料，他称这种文字为冰峰文。然而当教授试图再次找到冰峰城时，却屡屡无功而返。\n\n幸好当时教授把石碑上的文字都拍摄了下来，为了解开冰峰城的秘密，教授和他的助手牛博士开始研究冰峰文，发现冰峰文只有陈述句这一种句型和名词 (n) 、动词 (v) 、辅词 (a) 这三类单词，且其文法很简单：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fj2tbbqd.png)\n\n在研究了大量资料后，他们总结了一部冰峰文词典，由于冰峰文恰好有 $26$ 个字母，为了研究方便，用字母 $a$ 到 $z$ 表示它们。\n\n冰峰文在句子和句子之间以及单词和单词之间没有任何分隔符，因此划分单词和句子令石教授和牛博士感到非常麻烦，于是他们想到了使用计算机来帮助解决这个问题。假设你接受了这份工作，你的第一个任务是写一个程序，将一篇冰峰文文章划分为最少的句子，在这个前提下，将文章划分为最少的单词。\n", "inputFormat": "-\t第 $1$ 行为词典中的单词数 $n$ （$ n \\le 1000 $）。\n-\t第 $2$ 行至第 $(n+1)$ 行每行表示一个单词，形为 $\"α.mot\"$ ，$α$ 表示词性，可能是 n (名词), v（动词）, a（辅词）中的一个， $mot$ 为单词，单词的长度不超过 $20$ 。拼写相同而词性不同的单词视为不同的单词，如输入示例中的 n.kick 与 v.kick 是两个不同的单词。\n-\t输入文件第 $(n+2)$ 行为需要划分的文章，以 \".\" 结束。\n-\t输入文件中的文章确保为冰峰文。文章是由有限个句子组成的，每个句子只包含有限个单词。文章长度不超过 5KB。\n", "outputFormat": "-\t为两行，每行一个整数。\n-\t第 $1$ 行为划分出来的句子数。\n-\t第 $2$ 行为划分出来的单词数。\n", "hint": "**样例说明**\n\n（为了阅读方便，划分的单词用空格分隔，在单词的右上角标出它的词性，每行写一个句子，用句号表示句子结束。）\n\n输出对应的划分：\n\n$ sillysnoopy^n \\quad isnot^v \\quad big^a \\quad table^n. \\\\\nbaleine^n \\quad kick^v \\quad snoopy^n \\quad silly^a \\quad cry^v. $\n\n如果用下面的划分：\n\n$ silly^a \\quad snoopy^n \\quad isnot^v \\quad big^a \\quad table^n. \\\\\nbaleine^n \\quad kick^v \\quad snoopy^n \\quad silly^a \\quad cry^v.$\n\n则划分的句子数仍为 $2$ 个，但单词数却多了 $1$ 个，为 $10$ 个，显然应该按前者而不是后者划分。\n", "locale": "zh-CN"}}}
{"pid": "P5758", "type": "P", "difficulty": 7, "samples": [["2\nabcdec\ncdefe\n", "a6\nb*\nd=\nf+\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2000", "NOI"], "title": "[NOI2000] 算符破译", "background": "", "description": "考古学发现，几千年前古梅文明时期的数学非常的发达，他们懂得多位数的加法和乘法，其表达式和运算规则等都与现在通常所用的方式完全相同（如整数是十进制，左边是高位，最高位不能为零；表达式为中缀运算，先乘后加等），唯一的区别是其符号的写法与现在不同。有充分的证据表明，古梅文明的数学文字一共有 $13$ 个符号，与 \n $0,1,2,3,4,5,6,7,8,9,+,*,=$ 这 $13$ 个数字和符号（称为现代算符）一一对应。为了便于标记，我们用 $13$ 个小写英文字母 $a,b,…m$ 代替这些符号（称为古梅算符）。但是，还没有人知道这些古梅算符和现代算符之间的具体对应关系。\n\n在一个石壁上，考古学家发现了一组用古梅算符表示的等式，根据推断，每行有且仅有一个等号，等号左右两边为运算表达式（只含有数字和符号），并且等号两边的计算结果相等。\n\n假设这组等式是成立的，请编程序破译古梅算符和现代算符之间的对应关系。\n", "inputFormat": "-\t第一行为等式的个数 $N$ （$ 1 \\le N \\le 1000 $），以下 $N$ 行每行为一个等式。\n-\t每个等式的长度为 $5$ 个字符到 $11$ 个字符。\n", "outputFormat": "-\t如果不存在对应关系能够满足这组等式，输出`noway`。\n-\t如果有对应关系能够满足这组等式，输出所有能够确定的古梅算符和现代算符的对应关系。每一行有两个字符，其中第一个字符是古梅算符，第二个字符是对应的现代算符。输出按照字典顺序排序。", "hint": "**样例说明**\n\n在上例中，可能对应的现代表达式为 $ \\{6*2=12，2=1+1 \\}， \\{6*4=24，4=2+2 \\}，\\{ 6*8=48，8=4+4 \\} $。可见，能够确定的对应关系只有 $a$ 对应 $6$ ，$b$ 对应 $*$ ，$d$ 对应 $=$，$f$ 对应 $+$ ，应该输出；而 ${c,e}$ 虽然能够找到对应的现代算符使得等式成立，但没有唯一的对应关系，不能输出。其他古梅算符 ${g,h…m}$ 完全不能确定，也不能输出。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2000] Operator Decoding", "background": "", "description": "Archaeological discoveries show that several thousand years ago, during the ancient Gumei civilization, mathematics was very advanced. They knew multi-digit addition and multiplication, and their expressions and calculation rules were exactly the same as those commonly used today (for example, integers are in decimal, the left side is the higher digit, the highest digit cannot be zero; expressions use infix notation, multiplication before addition, etc.). The only difference is that their symbols were written differently.\n\nThere is strong evidence that the mathematical writing system of the ancient Gumei civilization had a total of $13$ symbols, which correspond one-to-one to the $13$ digits and symbols $0,1,2,3,4,5,6,7,8,9,+,*,=$ (called modern operators). For convenience, we use $13$ lowercase English letters $a,b,\\ldots,m$ to represent these symbols (called Gumei operators). However, nobody knows the exact correspondence between the Gumei operators and the modern operators.\n\nOn a stone wall, archaeologists found a set of equations written using Gumei operators. According to inference, each line contains exactly one equals sign, and the left and right sides of the equals sign are arithmetic expressions (containing only digits and symbols), and the computed results on both sides are equal.\n\nAssuming this set of equations is correct, write a program to decode the correspondence between Gumei operators and modern operators.", "inputFormat": "- The first line contains the number of equations $N$ ($1 \\le N \\le 1000$). The following $N$ lines each contain one equation.\n- The length of each equation is from $5$ characters to $11$ characters.", "outputFormat": "- If there is no correspondence that can satisfy this set of equations, output `noway`.\n- If there exists a correspondence that can satisfy this set of equations, output all correspondences between Gumei operators and modern operators that can be determined. Each line contains two characters: the first character is a Gumei operator, and the second character is the corresponding modern operator. Output them in lexicographical order.", "hint": "**Sample Explanation**\n\nIn the example above, possible corresponding modern expressions could be $\\{6*2=12, 2=1+1\\}$, $\\{6*4=24, 4=2+2\\}$, $\\{6*8=48, 8=4+4\\}$. It can be seen that the only correspondences that can be determined are: $a$ corresponds to $6$, $b$ corresponds to $*$, $d$ corresponds to $=$, and $f$ corresponds to $+$. These should be output. However, although ${c,e}$ can be matched with modern operators to make the equations valid, there is no unique correspondence, so they should not be output. The other Gumei operators ${g,h,\\ldots,m}$ cannot be determined at all and also should not be output.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2000] 算符破译", "background": "", "description": "考古学发现，几千年前古梅文明时期的数学非常的发达，他们懂得多位数的加法和乘法，其表达式和运算规则等都与现在通常所用的方式完全相同（如整数是十进制，左边是高位，最高位不能为零；表达式为中缀运算，先乘后加等），唯一的区别是其符号的写法与现在不同。有充分的证据表明，古梅文明的数学文字一共有 $13$ 个符号，与 \n $0,1,2,3,4,5,6,7,8,9,+,*,=$ 这 $13$ 个数字和符号（称为现代算符）一一对应。为了便于标记，我们用 $13$ 个小写英文字母 $a,b,…m$ 代替这些符号（称为古梅算符）。但是，还没有人知道这些古梅算符和现代算符之间的具体对应关系。\n\n在一个石壁上，考古学家发现了一组用古梅算符表示的等式，根据推断，每行有且仅有一个等号，等号左右两边为运算表达式（只含有数字和符号），并且等号两边的计算结果相等。\n\n假设这组等式是成立的，请编程序破译古梅算符和现代算符之间的对应关系。\n", "inputFormat": "-\t第一行为等式的个数 $N$ （$ 1 \\le N \\le 1000 $），以下 $N$ 行每行为一个等式。\n-\t每个等式的长度为 $5$ 个字符到 $11$ 个字符。\n", "outputFormat": "-\t如果不存在对应关系能够满足这组等式，输出`noway`。\n-\t如果有对应关系能够满足这组等式，输出所有能够确定的古梅算符和现代算符的对应关系。每一行有两个字符，其中第一个字符是古梅算符，第二个字符是对应的现代算符。输出按照字典顺序排序。", "hint": "**样例说明**\n\n在上例中，可能对应的现代表达式为 $ \\{6*2=12，2=1+1 \\}， \\{6*4=24，4=2+2 \\}，\\{ 6*8=48，8=4+4 \\} $。可见，能够确定的对应关系只有 $a$ 对应 $6$ ，$b$ 对应 $*$ ，$d$ 对应 $=$，$f$ 对应 $+$ ，应该输出；而 ${c,e}$ 虽然能够找到对应的现代算符使得等式成立，但没有唯一的对应关系，不能输出。其他古梅算符 ${g,h…m}$ 完全不能确定，也不能输出。\n", "locale": "zh-CN"}}}
{"pid": "P5759", "type": "P", "difficulty": 3, "samples": [["3\n72 82 73 68 95 86 82 90\n72 90 50 60 80 70 65 80\n72 82 73 68 95 86 82 90\n", "1\n3\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["1997", "NOI"], "title": "[NOI1997] 竞赛排名", "background": "", "description": "某市组织了一次中学生科技全能竞赛，每个选手要参加数学、物理、化学、天文、地理、生物、计算机和英语共八项竞赛,最后综合八项竞赛的成绩排出总名次。\n\n选手编号依次为： $1,2,\\dots,N$（$N$ 为参赛总人数）。设 $x_{i, j}$（$1 \\le i \\le N, 1 \\le j \\le 8$）分别表示编号为 $i$ 的选手第 $j$ 项竞赛的成绩。其它指标如下：\n\n- 第 $j$（$1 \\le j \\le 8$）项竞赛的平均分 $avg_j = \\frac{1}{N} \\sum_{i=1}^N x_{i, j}$\n- 选手 $i$（$1 \\le i \\le N$）的总分 $sumx_i = \\sum_{j=1}^8 x_{i, j}$\n- 选手 $i$（$1 \\le i \\le N$）第 $j$（$1 \\le j \\le 8$）项竞赛的位置分\n\n$$\ny_{i, j}= \\begin{cases} 0 & \\left(\\sum_{i = 1} ^ N |x_{i, j} - avg_j| = 0\\right) \\\\ \\frac{x_{i, j} - avg_j}{\\frac{1}{N} \\sum_{i = 1} ^ N |x_{i ,j} - agv_j|} & \\left(\\sum_{i = 1} ^ N |x_{i, j} - avg_j| \\ne 0\\right)\\end{cases}\n$$\n\n- 选手 $i$（$1 \\le i \\le N$）的总位置分 $sumy_i = \\sum_{j=1}^3 y_{i, j} + 0.8 \\sum_{j=4}^8 y_{i, j}$\n\n排名规则如下:\n1. 总位置分高的选手名次在前；\n2. 若两个或两个以上的选手总位置分相同，则总分高的选手名次在前；\n3. 若两个或两个以上的选手总位置分和总分均相同，则编号在前的选手名次在前。\n\n请你为竞赛组委会编一程序，计算本次全能竞赛的总排名情况。", "inputFormat": "第一行为参赛总人数 $N$，从第二行到第 $N$ 行依次为编号为 $1$ 到编号为 $N$ 的选手的成绩，每行有 $8$ 个 $0 \\sim 100$ 之间的整数，代表该选手的 $8$ 项竞赛成绩 。同一行相邻两个数之间用一个空格符隔开。", "outputFormat": "有 $N$ 行，从第 $1$ 行到第 $N$ 行依次为排名第 $1$ 的选手的编号，排名第 $2$ 的选手的编号，……，排名第 $N$ 的选手的编号。", "hint": "#### 数据范围\n\n对于所有测试数据，满足 $1 \\le N \\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI1997] Contest Ranking", "background": "", "description": "A city organized an all-round science and technology contest for middle school students. Each participant takes part in eight contests: Mathematics, Physics, Chemistry, Astronomy, Geography, Biology, Computer Science, and English. In the end, the overall ranking is determined based on the combined results of these eight contests.\n\nThe contestant IDs are $1,2,\\dots,N$ ($N$ is the total number of participants). Let $x_{i, j}$ ($1 \\le i \\le N, 1 \\le j \\le 8$) denote the score of contestant $i$ in contest $j$. Other indicators are defined as follows:\n\n- The average score of contest $j$ ($1 \\le j \\le 8$): $avg_j = \\frac{1}{N} \\sum_{i=1}^N x_{i, j}$\n- The total score of contestant $i$ ($1 \\le i \\le N$): $sumx_i = \\sum_{j=1}^8 x_{i, j}$\n- The positional score of contestant $i$ ($1 \\le i \\le N$) in contest $j$ ($1 \\le j \\le 8$):\n\n$$\ny_{i, j}= \\begin{cases} 0 & \\left(\\sum_{i = 1} ^ N |x_{i, j} - avg_j| = 0\\right) \\\\ \\frac{x_{i, j} - avg_j}{\\frac{1}{N} \\sum_{i = 1} ^ N |x_{i ,j} - agv_j|} & \\left(\\sum_{i = 1} ^ N |x_{i, j} - avg_j| \\ne 0\\right)\\end{cases}\n$$\n\n- The total positional score of contestant $i$ ($1 \\le i \\le N$): $sumy_i = \\sum_{j=1}^3 y_{i, j} + 0.8 \\sum_{j=4}^8 y_{i, j}$\n\nThe ranking rules are as follows:\n1. Contestants with higher total positional scores rank earlier.\n2. If two or more contestants have the same total positional score, the one with the higher total score ranks earlier.\n3. If two or more contestants have the same total positional score and the same total score, the one with the smaller ID ranks earlier.\n\nPlease write a program for the contest committee to compute the overall ranking for this all-round contest.", "inputFormat": "The first line contains the total number of participants $N$. From the second line to the $N$-th line, the scores of contestants with IDs from $1$ to $N$ are given in order. Each line contains $8$ integers between $0$ and $100$, representing the contestant’s scores in the 8 contests. Adjacent numbers on the same line are separated by one space.", "outputFormat": "Output $N$ lines. From line 1 to line $N$, output the ID of the contestant ranked 1st, the ID of the contestant ranked 2nd, $\\dots$, and the ID of the contestant ranked $N$-th.", "hint": "#### Constraints\n\nFor all testdata, $1 \\le N \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI1997] 竞赛排名", "background": "", "description": "某市组织了一次中学生科技全能竞赛，每个选手要参加数学、物理、化学、天文、地理、生物、计算机和英语共八项竞赛,最后综合八项竞赛的成绩排出总名次。\n\n选手编号依次为： $1,2,\\dots,N$（$N$ 为参赛总人数）。设 $x_{i, j}$（$1 \\le i \\le N, 1 \\le j \\le 8$）分别表示编号为 $i$ 的选手第 $j$ 项竞赛的成绩。其它指标如下：\n\n- 第 $j$（$1 \\le j \\le 8$）项竞赛的平均分 $avg_j = \\frac{1}{N} \\sum_{i=1}^N x_{i, j}$\n- 选手 $i$（$1 \\le i \\le N$）的总分 $sumx_i = \\sum_{j=1}^8 x_{i, j}$\n- 选手 $i$（$1 \\le i \\le N$）第 $j$（$1 \\le j \\le 8$）项竞赛的位置分\n\n$$\ny_{i, j}= \\begin{cases} 0 & \\left(\\sum_{i = 1} ^ N |x_{i, j} - avg_j| = 0\\right) \\\\ \\frac{x_{i, j} - avg_j}{\\frac{1}{N} \\sum_{i = 1} ^ N |x_{i ,j} - agv_j|} & \\left(\\sum_{i = 1} ^ N |x_{i, j} - avg_j| \\ne 0\\right)\\end{cases}\n$$\n\n- 选手 $i$（$1 \\le i \\le N$）的总位置分 $sumy_i = \\sum_{j=1}^3 y_{i, j} + 0.8 \\sum_{j=4}^8 y_{i, j}$\n\n排名规则如下:\n1. 总位置分高的选手名次在前；\n2. 若两个或两个以上的选手总位置分相同，则总分高的选手名次在前；\n3. 若两个或两个以上的选手总位置分和总分均相同，则编号在前的选手名次在前。\n\n请你为竞赛组委会编一程序，计算本次全能竞赛的总排名情况。", "inputFormat": "第一行为参赛总人数 $N$，从第二行到第 $N$ 行依次为编号为 $1$ 到编号为 $N$ 的选手的成绩，每行有 $8$ 个 $0 \\sim 100$ 之间的整数，代表该选手的 $8$ 项竞赛成绩 。同一行相邻两个数之间用一个空格符隔开。", "outputFormat": "有 $N$ 行，从第 $1$ 行到第 $N$ 行依次为排名第 $1$ 的选手的编号，排名第 $2$ 的选手的编号，……，排名第 $N$ 的选手的编号。", "hint": "#### 数据范围\n\n对于所有测试数据，满足 $1 \\le N \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P5760", "type": "P", "difficulty": 4, "samples": [["4 2\n10 5 5\n8 7 7\n2 2 2\n6 6 6\n", "24\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["1997", "NOI"], "title": "[NOI1997] 积木游戏", "background": "", "description": "SERCOI 最近设计了一种积木游戏。每个游戏者有 $N$ 块编号依次为 $1 ，2，…，N$ 的长方体积木。对于每块积木,它的三条不同的边分别称为\"a 边\"、\"b 边\"和\"c 边\"，如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jfd5li1k.png)\n\n游戏规则如下：\n1. 从 $N$ 块积木中选出若干块，并将它们分成 $M$ （$ 1 \\le M \\le N $） 堆，称为第 $1$ 堆，第 $2$ 堆…，第 $M$ 堆。每堆至少有 $1$ 块积木，并且第 $K$ 堆中任意一块积木的编号要大于第 $K+1$ 堆中任意一块积木的编号($ 2 \\le K \\le M $)。\n\n2.  对于每一堆积木,游戏者要将它们垂直摞成一根柱子,并要求满足下面两个条件：\n\n$\\qquad$ 1)除最顶上的一块积木外，任意一块积木的上表面同且仅同另一块积木的下表面接触，并且要求下面的积木的上表面能包含上面的积木的下表面，也就是说，要求下面的积木的上表面的两对边的长度分别大于等于上面的积木的两对边的长度。\n\n$\\qquad$ 2)对于任意两块上下表面相接触的积木，下面的积木的编号要小于上面的积木的编号。\n\n最后，根据每人所摞成的 $M$ 根柱子的高度之和来决出胜负。\n\n请你编一程序，寻找一种摞积木的方案，使得你所摞成的 $M$ 根柱子的高度之和最大。\n", "inputFormat": "一行有两个正整数 $N$ 和 $M$ （$ 1 \\le M \\le N \\le 100 $），分别表\n示积木总数和要求摞成的柱子数。这两个数之间用一个空格符隔开。\n\n接下来 $N$ 行依次是编号从 $1$ 到 $N$ 的 $N$ 个积木的尺寸，每行有三个 $1$ 至 $1000$ 之间的整数，分别表示该积木 a 边, b 边和  c 边的长度。\n同一行相邻两个数之间用一个空格符隔开。\n", "outputFormat": "只有一行，为一个整数，表示 $M$ 根柱子的高度之和的最大值。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[NOI1997] Block Game", "background": "", "description": "SERCOI has recently designed a block game. Each player has $N$ rectangular blocks numbered $1, 2, \\ldots, N$. For each block, its three different edges are called the \"a edge\", \"b edge\", and \"c edge\", as shown in the figure below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jfd5li1k.png)\n\nThe rules are as follows:\n\n1. Choose some blocks from the $N$ blocks and divide them into $M$ ($1 \\le M \\le N$) piles, called pile $1$, pile $2$, $\\ldots$, pile $M$. Each pile must contain at least $1$ block, and for pile $K$, the number of any block in pile $K$ must be greater than the number of any block in pile $K+1$ ($2 \\le K \\le M$).\n\n2. For each pile, the player stacks the blocks vertically into a single column, and it must satisfy the following two conditions:\n\n$\\qquad$ 1) Except for the top block, the top face of any block must touch one and only one other block’s bottom face. Also, the top face of the lower block must be able to contain the bottom face of the upper block. That is, the lengths of the two pairs of edges on the top face of the lower block must each be greater than or equal to the corresponding two pairs of edges on the bottom face of the upper block.\n\n$\\qquad$ 2) For any two blocks whose top and bottom faces are in contact, the number of the lower block must be smaller than the number of the upper block.\n\nFinally, the winner is determined by the sum of the heights of the $M$ columns.\n\nPlease write a program to find a stacking plan such that the sum of the heights of the $M$ columns is maximized.", "inputFormat": "The first line contains two positive integers $N$ and $M$ ($1 \\le M \\le N \\le 100$), representing the total number of blocks and the required number of columns. The two numbers are separated by a space.\n\nThe next $N$ lines give the sizes of the $N$ blocks numbered from $1$ to $N$ in order. Each line contains three integers between $1$ and $1000$, representing the lengths of the a edge, b edge, and c edge of that block. Adjacent numbers on the same line are separated by a space.", "outputFormat": "Only one line containing one integer, which is the maximum possible sum of the heights of the $M$ columns.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI1997] 积木游戏", "background": "", "description": "SERCOI 最近设计了一种积木游戏。每个游戏者有 $N$ 块编号依次为 $1 ，2，…，N$ 的长方体积木。对于每块积木,它的三条不同的边分别称为\"a 边\"、\"b 边\"和\"c 边\"，如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jfd5li1k.png)\n\n游戏规则如下：\n1. 从 $N$ 块积木中选出若干块，并将它们分成 $M$ （$ 1 \\le M \\le N $） 堆，称为第 $1$ 堆，第 $2$ 堆…，第 $M$ 堆。每堆至少有 $1$ 块积木，并且第 $K$ 堆中任意一块积木的编号要大于第 $K+1$ 堆中任意一块积木的编号($ 2 \\le K \\le M $)。\n\n2.  对于每一堆积木,游戏者要将它们垂直摞成一根柱子,并要求满足下面两个条件：\n\n$\\qquad$ 1)除最顶上的一块积木外，任意一块积木的上表面同且仅同另一块积木的下表面接触，并且要求下面的积木的上表面能包含上面的积木的下表面，也就是说，要求下面的积木的上表面的两对边的长度分别大于等于上面的积木的两对边的长度。\n\n$\\qquad$ 2)对于任意两块上下表面相接触的积木，下面的积木的编号要小于上面的积木的编号。\n\n最后，根据每人所摞成的 $M$ 根柱子的高度之和来决出胜负。\n\n请你编一程序，寻找一种摞积木的方案，使得你所摞成的 $M$ 根柱子的高度之和最大。\n", "inputFormat": "一行有两个正整数 $N$ 和 $M$ （$ 1 \\le M \\le N \\le 100 $），分别表\n示积木总数和要求摞成的柱子数。这两个数之间用一个空格符隔开。\n\n接下来 $N$ 行依次是编号从 $1$ 到 $N$ 的 $N$ 个积木的尺寸，每行有三个 $1$ 至 $1000$ 之间的整数，分别表示该积木 a 边, b 边和  c 边的长度。\n同一行相邻两个数之间用一个空格符隔开。\n", "outputFormat": "只有一行，为一个整数，表示 $M$ 根柱子的高度之和的最大值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5761", "type": "P", "difficulty": 3, "samples": [["3 6\n-50 -47 -36 -30 -23\n17 -19 34 -13 -8\n-42 -3 -43 34 -45", "82"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["1997", "NOI"], "title": "[NOI1997] 最佳游览", "background": "", "description": "有一座旅游城，它的街道成网格状（如图）．其中东西向的街道是“风景线\"、两旁分布着许多景观：南北向的街道都是\"林萌道\"，两旁没有任何建筑物。由于游客众多，\" 风景线”被规定为单行道，游客在风景线上只能从西走到东，林荫道上则可以任意行走。\n\n一名游客将到这座旅游城旅游。他根据自己对景观的喜好给所有的风景线打了分，分值是从 $-100$ 到 $+100$ 的整数，分值越大表示我们的旅游者越喜欢这条风景线上的景致。显然这位游客不可能给这座旅游城的所有风景线都打负分。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/62qfloek.png)\n\n游客可以从旅游城的任一个十字路口开始游览，在任一个十字路口结束游览。我们的旅游者希望一路上游览的所有风景线的分值之和能够尽可能地大。请你写一个程序，帮助这位游客寻找一条最佳的游览路线。\n", "inputFormat": "第一行是两个整数 $M$ 和 $N$ ，之间用一个空格符隔开， $M$ 表示旅游城南北向林萌道的段数， $N$ 表示东西向风景线的段数，($ 1 \\le M \\le 100$，$1 \\le N \\le 20001 $)。\n\n接下来的 $M$ 行依次给出了由北向南各条风景线的分值信息。每行有 $N-1$ 个整数，依次表示了自西向东每段风景线的分值。同一行相邻两个数之间用一个空格隔开。\n", "outputFormat": "只有一行，含一个整数，表示你的程序所找到的最佳游览路线的总分值。\n", "hint": "**样例解释**\n\n路径为 $17 \\to -3 \\to 34 \\to 34$，答案为 $82$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI1997] Best Tour", "background": "", "description": "There is a tourist city whose streets form a grid (as shown in the figure). The streets running west to east are “scenic roads”, with many sights along both sides. The streets running north to south are “tree-lined roads”, with no buildings on either side. Because there are many tourists, the “scenic roads” are designated as one-way streets: on a scenic road, tourists can only walk from west to east. On tree-lined roads, they can walk freely in any direction.\n\nA tourist is going to visit this city. Based on how much they like the sights, they assign a score to every scenic road segment. The score is an integer from $-100$ to $+100$. A larger score means the tourist likes the scenery on that scenic road segment more. Obviously, this tourist cannot give negative scores to all scenic road segments in the whole city.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/62qfloek.png)\n\nThe tourist may start the tour at any intersection and end at any intersection. They want the sum of the scores of all scenic road segments traveled along the way to be as large as possible. Please write a program to help the tourist find an optimal tour route.", "inputFormat": "The first line contains two integers $M$ and $N$, separated by a space. $M$ is the number of segments of the north-south tree-lined roads, and $N$ is the number of segments of the west-east scenic roads ($1 \\le M \\le 100$, $1 \\le N \\le 20001$).\n\nThe next $M$ lines give the score information of the scenic roads from north to south. Each line contains $N - 1$ integers, describing the scores of each scenic road segment from west to east. Adjacent numbers in the same line are separated by a single space.", "outputFormat": "Only one line containing one integer, which is the total score of the optimal tour route found by your program.", "hint": "**Explanation of the sample**\n\nThe path is $17 \\to -3 \\to 34 \\to 34$, and the answer is $82$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI1997] 最佳游览", "background": "", "description": "有一座旅游城，它的街道成网格状（如图）．其中东西向的街道是“风景线\"、两旁分布着许多景观：南北向的街道都是\"林萌道\"，两旁没有任何建筑物。由于游客众多，\" 风景线”被规定为单行道，游客在风景线上只能从西走到东，林荫道上则可以任意行走。\n\n一名游客将到这座旅游城旅游。他根据自己对景观的喜好给所有的风景线打了分，分值是从 $-100$ 到 $+100$ 的整数，分值越大表示我们的旅游者越喜欢这条风景线上的景致。显然这位游客不可能给这座旅游城的所有风景线都打负分。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/62qfloek.png)\n\n游客可以从旅游城的任一个十字路口开始游览，在任一个十字路口结束游览。我们的旅游者希望一路上游览的所有风景线的分值之和能够尽可能地大。请你写一个程序，帮助这位游客寻找一条最佳的游览路线。\n", "inputFormat": "第一行是两个整数 $M$ 和 $N$ ，之间用一个空格符隔开， $M$ 表示旅游城南北向林萌道的段数， $N$ 表示东西向风景线的段数，($ 1 \\le M \\le 100$，$1 \\le N \\le 20001 $)。\n\n接下来的 $M$ 行依次给出了由北向南各条风景线的分值信息。每行有 $N-1$ 个整数，依次表示了自西向东每段风景线的分值。同一行相邻两个数之间用一个空格隔开。\n", "outputFormat": "只有一行，含一个整数，表示你的程序所找到的最佳游览路线的总分值。\n", "hint": "**样例解释**\n\n路径为 $17 \\to -3 \\to 34 \\to 34$，答案为 $82$。", "locale": "zh-CN"}}}
{"pid": "P5762", "type": "P", "difficulty": 5, "samples": [["3\n0 0 0 3\n1 -1 0 1\n19 3 5 6\n", "1944\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["1997", "NOI"], "title": "[NOI1997] 卫星覆盖", "background": "", "description": "SERCOI（Space-Earth Resource Cover-Observe lnstitute） 是一个致力于利用卫星技术对空间和地球资源进行覆盖观测的组织。现在他们研制成功一种新型资源观测卫星 -SERCOI-308。这种卫星可以覆盖空间直角坐标系中一定大小的立方体空间，卫星处于该立方体的中心。\n    其中 $（x,y,z）$ 为立方体的中心点坐标， $r$ 为此中心点到立方体各个面的距离（即 $r$ 为立方体高的一半）．立方体的各条边均平行于相应的坐标轴。我们可以用一个四元组 $(x,y,z,r)$ 描述一颗卫星的状态，它所能覆盖的空间体积 。\n由于一颗卫星所能覆盖的空间体积是有限的，因此空间中可能有若干颗卫星协同工作。它们所覆盖的空间区域可能有重叠的地方，如下图所示（阴影部分表示重叠的区域）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yeajeuoh.png)\n\n写一个程序，根据给定的卫星分布情况，计算它们所覆盖的总体积。\n", "inputFormat": "第一行是一个正整数 $N$ （$ 1 \\le N \\le 100 $）：表示空间中的卫星总数。接下来的 $N$ 行每行给出了一颗卫星的状态，用空格隔开的四个正整数 $x,y,z,r$ 依次表示了该卫星所能覆盖的立方体空间的中心点坐标和半高，其中 ($ -1000 \\le x,y,z \\le 1000$，$1 \\le r \\le 200 )$。", "outputFormat": "只有一行,包括一个正整数，表示所有这些卫星所覆盖的空间总体积。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[NOI1997] Satellite Coverage", "background": "", "description": "SERCOI (Space-Earth Resource Cover-Observe Institute) is an organization dedicated to using satellite technology to observe and cover space and Earth resources. They have successfully developed a new type of resource-observation satellite, SERCOI-308. This satellite can cover a cube-shaped region of a certain size in a 3D Cartesian coordinate system, with the satellite located at the center of the cube.\n\nHere, $(x,y,z)$ is the coordinate of the cube’s center point, and $r$ is the distance from the center to each face of the cube (that is, $r$ is half of the cube’s height). All edges of the cube are parallel to the corresponding coordinate axes. We can use a 4-tuple $(x,y,z,r)$ to describe the state of a satellite, and the volume of space it can cover.\n\nSince the volume that a single satellite can cover is limited, there may be several satellites working together in space. The regions they cover may overlap, as shown in the figure below (the shaded part indicates the overlapping region).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yeajeuoh.png)\n\nWrite a program that, given the distribution of the satellites, computes the total volume covered by all of them.", "inputFormat": "The first line contains a positive integer $N$ ($1 \\le N \\le 100$), which represents the total number of satellites in space. The next $N$ lines each give the state of one satellite: four positive integers $x,y,z,r$ separated by spaces, representing the coordinates of the center of the cube it can cover and its half-height. Here, $-1000 \\le x,y,z \\le 1000$ and $1 \\le r \\le 200$.", "outputFormat": "Only one line, containing a positive integer, which represents the total volume of space covered by all these satellites.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI1997] 卫星覆盖", "background": "", "description": "SERCOI（Space-Earth Resource Cover-Observe lnstitute） 是一个致力于利用卫星技术对空间和地球资源进行覆盖观测的组织。现在他们研制成功一种新型资源观测卫星 -SERCOI-308。这种卫星可以覆盖空间直角坐标系中一定大小的立方体空间，卫星处于该立方体的中心。\n    其中 $（x,y,z）$ 为立方体的中心点坐标， $r$ 为此中心点到立方体各个面的距离（即 $r$ 为立方体高的一半）．立方体的各条边均平行于相应的坐标轴。我们可以用一个四元组 $(x,y,z,r)$ 描述一颗卫星的状态，它所能覆盖的空间体积 。\n由于一颗卫星所能覆盖的空间体积是有限的，因此空间中可能有若干颗卫星协同工作。它们所覆盖的空间区域可能有重叠的地方，如下图所示（阴影部分表示重叠的区域）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yeajeuoh.png)\n\n写一个程序，根据给定的卫星分布情况，计算它们所覆盖的总体积。\n", "inputFormat": "第一行是一个正整数 $N$ （$ 1 \\le N \\le 100 $）：表示空间中的卫星总数。接下来的 $N$ 行每行给出了一颗卫星的状态，用空格隔开的四个正整数 $x,y,z,r$ 依次表示了该卫星所能覆盖的立方体空间的中心点坐标和半高，其中 ($ -1000 \\le x,y,z \\le 1000$，$1 \\le r \\le 200 )$。", "outputFormat": "只有一行,包括一个正整数，表示所有这些卫星所覆盖的空间总体积。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5763", "type": "P", "difficulty": 4, "samples": [["10\n1 3 10\n2 4 3\n3 4 4\n4 1 4\n5 3 4\n0 0 0\n", "12\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "1999", "线段树", "二分", "平衡树", "NOI"], "title": "[NOI1999] 内存分配", "background": null, "description": "内存是计算机重要的资源之一，程序运行的过程中必须对内存进行分配。\n\n经典的内存分配过程是这样进行的：\n1. 内存以内存单元为基本单位，每个内存单元用一个固定的整数作为标识，称为地址。地址从 $0$ 开始连续排列，地址相邻的内存单元被认为是逻辑上连续的。我们把从地址 $i$ 开始的 $s$ 个连续的内存单元称为首地址为 $i$ 长度为 $s$ 的地址片。 \n2. 运行过程中有若干进程需要占用内存，对于每个进程有一个申请时刻 $T$ ，需要内存单元数 $M$ 及运行时间 $P$。在运行时间 $P$ 内（即 $T$ 时刻开始，$T+P$ 时刻结束），这 $M$ 个被占用的内存单元不能再被其他进程使用。 \n3. 假设在 $T$ 时刻有一个进程申请 $M$ 个单元，且运行时间为 $P$ ，则：\n\n$\\qquad$ 1)\t若 $T$ 时刻内存中存在长度为 $M$ 的空闲地址片，则系统将这 $M$ 个空闲单元分配给该进程。若存在多个长度为 $M$ 个空闲地址片，则系统将首地址最小的那个空闲地址片分配给该进程。 \n\n$\\qquad$ 2)    如果 $T$ 时刻不存在长度为 $M$ 的空闲地址片，则该进程被放入一个等待队列。对于处于等待队列队头的进程，只要在任一时刻，存在长度为 $M$ 的空闲地址片，系统马上将该进程取出队列，并为它分配内存单元。注意，在进行内存分配处理过程中，处于等待队列队头的进程的处理优先级最高，队列中的其它进程不能先于队头进程被处理。 \n\n现在给出一系列描述进程的数据，请编写一程序模拟系统分配内存的过程。", "inputFormat": "第一行是一个数 $N$ ，表示总内存单元数（即地址范围从 $0$ 到 $N-1$ ）\n从第二行开始每行描述一个进程的三个整数 $T、M、P$ （$ M \\le N$）。\n\n**数据已按 $T$ 从小到大排序。**\n\n最后一行用`0 0 0`表示结束。\n\n输入文件最多 $10000$ 行，且所有数据都小于 $10^9$。\n\n输入文件中同一行相邻两项之间用一个或多个空格隔开。", "outputFormat": "共两行。\n\n第一行是全部进程都运行完毕的时刻。\n\n第二行是被放入过等待队列的进程总数。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[NOI1999] Memory Allocation", "background": "", "description": "Memory is one of the important resources of a computer. During program execution, memory must be allocated.\n\nA classic memory allocation process works as follows:\n\n1. Memory is divided into memory units as the basic unit. Each memory unit is identified by a fixed integer, called its address. Addresses start from $0$ and are arranged consecutively. Memory units with adjacent addresses are considered logically consecutive. We call the $s$ consecutive memory units starting from address $i$ an address segment with starting address $i$ and length $s$.\n2. During execution, several processes need to occupy memory. For each process, there is a request time $T$, a required number of memory units $M$, and a running time $P$. During the running time $P$ (i.e., starting at time $T$ and ending at time $T+P$), these $M$ occupied memory units cannot be used by other processes.\n3. Suppose that at time $T$ a process requests $M$ units and has running time $P$. Then:\n\n$\\qquad$ 1) If at time $T$ there exists a free address segment of length $M$ in memory, the system allocates these $M$ free units to the process. If there are multiple free address segments of length $M$, the system allocates the one with the smallest starting address to the process.\n\n$\\qquad$ 2) If at time $T$ there is no free address segment of length $M$, the process is put into a waiting queue. For the process at the head of the waiting queue, as long as at any moment there exists a free address segment of length $M$, the system immediately removes it from the queue and allocates memory units to it. Note that during the memory allocation procedure, the process at the head of the waiting queue has the highest priority. Other processes in the queue cannot be processed before the head process.\n\nNow you are given a sequence of data describing processes. Please write a program to simulate the system's memory allocation process.", "inputFormat": "The first line contains an integer $N$, which is the total number of memory units (i.e., the address range is from $0$ to $N-1$).\n\nStarting from the second line, each line describes a process with three integers $T, M, P$ ($M \\le N$).\n\n**The data are already sorted in increasing order of $T$.**\n\nThe last line is `0 0 0`, indicating the end.\n\nThe input file has at most $10000$ lines, and all data are less than $10^9$.\n\nAdjacent items on the same line in the input file are separated by one or more spaces.", "outputFormat": "There are two lines in total.\n\nThe first line is the time when all processes have finished running.\n\nThe second line is the total number of processes that have ever been put into the waiting queue.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI1999] 内存分配", "background": null, "description": "内存是计算机重要的资源之一，程序运行的过程中必须对内存进行分配。\n\n经典的内存分配过程是这样进行的：\n1. 内存以内存单元为基本单位，每个内存单元用一个固定的整数作为标识，称为地址。地址从 $0$ 开始连续排列，地址相邻的内存单元被认为是逻辑上连续的。我们把从地址 $i$ 开始的 $s$ 个连续的内存单元称为首地址为 $i$ 长度为 $s$ 的地址片。 \n2. 运行过程中有若干进程需要占用内存，对于每个进程有一个申请时刻 $T$ ，需要内存单元数 $M$ 及运行时间 $P$。在运行时间 $P$ 内（即 $T$ 时刻开始，$T+P$ 时刻结束），这 $M$ 个被占用的内存单元不能再被其他进程使用。 \n3. 假设在 $T$ 时刻有一个进程申请 $M$ 个单元，且运行时间为 $P$ ，则：\n\n$\\qquad$ 1)\t若 $T$ 时刻内存中存在长度为 $M$ 的空闲地址片，则系统将这 $M$ 个空闲单元分配给该进程。若存在多个长度为 $M$ 个空闲地址片，则系统将首地址最小的那个空闲地址片分配给该进程。 \n\n$\\qquad$ 2)    如果 $T$ 时刻不存在长度为 $M$ 的空闲地址片，则该进程被放入一个等待队列。对于处于等待队列队头的进程，只要在任一时刻，存在长度为 $M$ 的空闲地址片，系统马上将该进程取出队列，并为它分配内存单元。注意，在进行内存分配处理过程中，处于等待队列队头的进程的处理优先级最高，队列中的其它进程不能先于队头进程被处理。 \n\n现在给出一系列描述进程的数据，请编写一程序模拟系统分配内存的过程。", "inputFormat": "第一行是一个数 $N$ ，表示总内存单元数（即地址范围从 $0$ 到 $N-1$ ）\n从第二行开始每行描述一个进程的三个整数 $T、M、P$ （$ M \\le N$）。\n\n**数据已按 $T$ 从小到大排序。**\n\n最后一行用`0 0 0`表示结束。\n\n输入文件最多 $10000$ 行，且所有数据都小于 $10^9$。\n\n输入文件中同一行相邻两项之间用一个或多个空格隔开。", "outputFormat": "共两行。\n\n第一行是全部进程都运行完毕的时刻。\n\n第二行是被放入过等待队列的进程总数。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P5764", "type": "P", "difficulty": 3, "samples": [["6 6\n2 3 4 5 6\n1 2 8\n2 3 3\n3 4 4\n4 5 5\n5 6 2\n1 6 7", "21\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "重庆", "各省省选", "最短路"], "title": "[CQOI2005] 新年好", "background": "", "description": "重庆城里有 $n$ 个车站，$m$ 条双向公路连接其中的某些车站。每两个车站最多用一条公路连接，从任何一个车站出发都可以经过一条或者多条公路到达其他车站，但不同的路径需要花费的时间可能不同。在一条路径上花费的时间等于路径上所有公路需要的时间之和。\n\n佳佳的家在车站 $1$，他有五个亲戚，分别住在车站 $a,b,c,d,e$。过年了，他需要从自己的家出发，拜访每个亲戚（顺序任意），给他们送去节日的祝福。怎样走，才需要最少的时间？", "inputFormat": "第一行：$n,m$，分别为车站数目和公路的数目。\n\n第二行：$a,b,c,d,e$，分别为五个亲戚所在车站编号。\n\n以下 $m$ 行，每行三个整数 $x,y,t$，为公路连接的两个车站编号和时间。", "outputFormat": "仅一行，包含一个整数 $T$，为最少的总时间。保证 $T\\le 10^9$。", "hint": "对于 $40\\%$ 的数据，有 $1≤n≤500$，$1≤m≤2000$。\n\n对于 $100\\%$ 的数据，有 $1≤n≤50000$，$1≤m≤100000$，$1\\le a,b,c,d,e≤n$，$1≤x,y≤n$，$1≤t≤10000$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2005] Happy New Year", "background": "", "description": "There are $n$ stations in Chongqing City, and $m$ bidirectional roads connect some of them. Between any two stations, there is at most one road. Starting from any station, you can reach any other station by taking one or more roads, but different paths may take different amounts of time. The time spent on a path equals the sum of the times of all roads on that path.\n\nJiajia’s home is at station $1$. He has five relatives who live at stations $a,b,c,d,e$. During the Spring Festival, he needs to start from home and visit each relative (in any order) to send them holiday greetings. How should he travel to spend the least total time?", "inputFormat": "The first line contains $n,m$, the number of stations and the number of roads.\n\nThe second line contains $a,b,c,d,e$, the station numbers where the five relatives live.\n\nThe next $m$ lines each contain three integers $x,y,t$, representing the two stations connected by a road and the time of that road.", "outputFormat": "Output only one line containing an integer $T$, the minimum total time. It is guaranteed that $T\\le 10^9$.", "hint": "For $40\\%$ of the testdata, $1\\le n\\le 500$ and $1\\le m\\le 2000$.\n\nFor $100\\%$ of the testdata, $1\\le n\\le 50000$, $1\\le m\\le 100000$, $1\\le a,b,c,d,e\\le n$, $1\\le x,y\\le n$, and $1\\le t\\le 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2005] 新年好", "background": "", "description": "重庆城里有 $n$ 个车站，$m$ 条双向公路连接其中的某些车站。每两个车站最多用一条公路连接，从任何一个车站出发都可以经过一条或者多条公路到达其他车站，但不同的路径需要花费的时间可能不同。在一条路径上花费的时间等于路径上所有公路需要的时间之和。\n\n佳佳的家在车站 $1$，他有五个亲戚，分别住在车站 $a,b,c,d,e$。过年了，他需要从自己的家出发，拜访每个亲戚（顺序任意），给他们送去节日的祝福。怎样走，才需要最少的时间？", "inputFormat": "第一行：$n,m$，分别为车站数目和公路的数目。\n\n第二行：$a,b,c,d,e$，分别为五个亲戚所在车站编号。\n\n以下 $m$ 行，每行三个整数 $x,y,t$，为公路连接的两个车站编号和时间。", "outputFormat": "仅一行，包含一个整数 $T$，为最少的总时间。保证 $T\\le 10^9$。", "hint": "对于 $40\\%$ 的数据，有 $1≤n≤500$，$1≤m≤2000$。\n\n对于 $100\\%$ 的数据，有 $1≤n≤50000$，$1≤m≤100000$，$1\\le a,b,c,d,e≤n$，$1≤x,y≤n$，$1≤t≤10000$。", "locale": "zh-CN"}}}
{"pid": "P5765", "type": "P", "difficulty": 4, "samples": [["8  \n1 2 \n1 3\n1 4\n1 5\n5 6\n5 7\n5 8", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["2005", "重庆", "各省省选", "树形 DP"], "title": "[CQOI2005] 珠宝", "background": "", "description": "有一棵 $n$ 个结点的树，给每个点安排一个正整数编号，使得相邻点具有不同的编号，编号的总和尽量小。", "inputFormat": "第一行一个整数 $n$。\n\n以下 $n-1$ 行，每行两个数 $u,v(1\\le u,v\\le n)$，表示 $u$ 和 $v$ 间有一条边。", "outputFormat": "仅一行，为最小编号和。", "hint": "对于 $20\\%$ 的数据，$n\\le 10$；\n\n对于 $40\\%$ 的数据，$n\\le 1000$；\n\n对于 $100\\%$ 的数据，$1\\le n\\le 50000$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2005] Jewelry", "background": "", "description": "There is a tree with $n$ nodes. Assign a positive integer label to each node so that adjacent nodes have different labels, and the total sum of labels is as small as possible.", "inputFormat": "The first line contains an integer $n$.  \n\nThe following $n-1$ lines each contain two integers $u, v \\ (1\\le u, v\\le n)$, indicating that there is an edge between $u$ and $v$.", "outputFormat": "Only one line, the minimum possible sum of labels.", "hint": "For $20\\%$ of the testdata, $n\\le 10$.  \n\nFor $40\\%$ of the testdata, $n\\le 1000$.  \n\nFor $100\\%$ of the testdata, $1\\le n\\le 50000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2005] 珠宝", "background": "", "description": "有一棵 $n$ 个结点的树，给每个点安排一个正整数编号，使得相邻点具有不同的编号，编号的总和尽量小。", "inputFormat": "第一行一个整数 $n$。\n\n以下 $n-1$ 行，每行两个数 $u,v(1\\le u,v\\le n)$，表示 $u$ 和 $v$ 间有一条边。", "outputFormat": "仅一行，为最小编号和。", "hint": "对于 $20\\%$ 的数据，$n\\le 10$；\n\n对于 $40\\%$ 的数据，$n\\le 1000$；\n\n对于 $100\\%$ 的数据，$1\\le n\\le 50000$。", "locale": "zh-CN"}}}
{"pid": "P5766", "type": "P", "difficulty": 3, "samples": [["5\n0 0 -2\n0 1 1\n1 0 1\n0 -1 1\n-1 0 1\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["1999", "NOI"], "title": "[NOI1999] 最优联通子集", "background": "", "description": "众所周知，我们可以通过直角坐标系把平面上的任何一个点 $P$ 用一个有序数对 $(x,y)$ 来唯一表示，如果 $x,y$ 都是整数，我们就把点 $P$ 称为整点，否则点 $P$ 称为非整点。我们把平面上所有整点构成的集合记为 $W$。\n\n定义 1 ：两个整点 $P_1(x_1,y_1),P_2(x_2,y_2)$，若 $|x_1-x_2|+|y_1-y_2|=1$，则称 $P_1,P_2$ 相邻，记作 $P_1$~$P_2$ ，否则称 $P_1,P_2$ 不相邻。\n\n定义 2 ：设点集 $S$ 是 $W$ 的一个有限子集，即 $S$=$\\{P_1,P_2,…,P_n\\}$ $(n \\ge 1)$，其中 $P_i (1 \\le i \\le n)$ 属于 $W$，我们把 $S$ 称为整点集。\n\n定义 3 ：设 $S$ 是一个整点集，若点 $R$,$T$ 属于 $S$ ，且存在一个有限的点序列 $Q_1,Q_2,…,Q_k$ 满足: \n1. $Q_i$ 属于 $S$ （$ 1 \\le i \\le k $）;\n2. $Q_1$ = $R$,$Q_k$ = $T$;\n3. $Q_i$~$Q_{i+1} (1 \\le i \\le k-1)$，即 $Q_i$ 与 \n $Q_{i+1}$ 相邻;\n4. 对于任何 $1 \\le i<j \\le k$ 有 $Q_i≠Q_j$;\n\n我们则称点 $R$ 与点 $T$ 在整点集 $S$ 上连通，把点序列 $Q_1,Q_2,…,Q_k$ 称为整点集 $S$ 中连接点 $R$ 与点 $T$ 的一条道路。\n\n定义 4 ：若整点集 $V$ 满足：对于 $V$ 中的任何两个整点， $V$ 中有且仅有一条连接这两点的道路，则 $V$ 称为单整点集。\n\n定义 5 ：对于平面上的每一个整点，我们可以赋予它一个整数，作为该点的权，于是我们把一个整点集中所有点的权的总和称为该整点集的权和。\n\n我们希望对于给定的一个单整点集 $V$ ，求出一个 $V$ 的最优连通子集 $B$ ，满足：\n1. $B$ 是 $V$ 的子集\n2. 对于 $B$ 中的任何两个整点，在 $B$ 中连通；\n3. $B$ 是满足条件 (1) 和 (2) 的所有整点集中权和最大的。\n", "inputFormat": "第一行是一个整数 $N$ ，表示单整点集 $V$ 中点的个数；\n\n以下 $N$ 行中，第 $i$ 行 $(1 \\le i \\le N) $ 有三个整数，$X_i,Y_i,C_i$ 依次表示第 $i$ 个点的横坐标，纵坐标和权。同一行相邻两数之间用一个空格分隔。\n", "outputFormat": "仅一个整数，表示所求最优连通集的权和。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[NOI1999] Optimal Connected Subset", "background": "", "description": "As is well known, we can use the Cartesian coordinate system to uniquely represent any point $P$ on the plane by an ordered pair $(x,y)$. If both $x,y$ are integers, then we call point $P$ a lattice point; otherwise, point $P$ is a non-lattice point. Let the set of all lattice points on the plane be denoted by $W$.\n\nDefinition 1: For two lattice points $P_1(x_1,y_1),P_2(x_2,y_2)$, if $|x_1-x_2|+|y_1-y_2|=1$, then $P_1$ and $P_2$ are said to be adjacent, denoted by $P_1$~$P_2$. Otherwise, they are said to be non-adjacent.\n\nDefinition 2: Let a point set $S$ be a finite subset of $W$, that is, $S=\\{P_1,P_2,\\ldots,P_n\\}$ $(n \\ge 1)$, where $P_i$ $(1 \\le i \\le n)$ belongs to $W$. We call $S$ a lattice point set.\n\nDefinition 3: Let $S$ be a lattice point set. If points $R$ and $T$ belong to $S$, and there exists a finite point sequence $Q_1,Q_2,\\ldots,Q_k$ satisfying:\n1. $Q_i$ belongs to $S$ ($1 \\le i \\le k$);\n2. $Q_1=R$, $Q_k=T$;\n3. $Q_i$~$Q_{i+1}$ $(1 \\le i \\le k-1)$, i.e. $Q_i$ and $Q_{i+1}$ are adjacent;\n4. For any $1 \\le i<j \\le k$, $Q_i \\ne Q_j$;\n\nthen we say point $R$ and point $T$ are connected in the lattice point set $S$. The point sequence $Q_1,Q_2,\\ldots,Q_k$ is called a path in $S$ connecting $R$ and $T$.\n\nDefinition 4: If a lattice point set $V$ satisfies that for any two lattice points in $V$, there exists one and only one path in $V$ connecting these two points, then $V$ is called a single lattice point set.\n\nDefinition 5: For each lattice point on the plane, we can assign it an integer as the weight of that point. The sum of the weights of all points in a lattice point set is called the weight sum of that set.\n\nFor a given single lattice point set $V$, we want to find an optimal connected subset $B$ of $V$ such that:\n1. $B$ is a subset of $V$.\n2. Any two lattice points in $B$ are connected within $B$.\n3. Among all lattice point sets satisfying conditions (1) and (2), $B$ has the maximum weight sum.", "inputFormat": "The first line contains an integer $N$, indicating the number of points in the single lattice point set $V$.\n\nIn the next $N$ lines, the $i$-th line $(1 \\le i \\le N)$ contains three integers $X_i,Y_i,C_i$, which represent the $x$-coordinate, $y$-coordinate, and weight of the $i$-th point, respectively. Adjacent numbers on the same line are separated by one space.", "outputFormat": "Output one integer, the weight sum of the required optimal connected set.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI1999] 最优联通子集", "background": "", "description": "众所周知，我们可以通过直角坐标系把平面上的任何一个点 $P$ 用一个有序数对 $(x,y)$ 来唯一表示，如果 $x,y$ 都是整数，我们就把点 $P$ 称为整点，否则点 $P$ 称为非整点。我们把平面上所有整点构成的集合记为 $W$。\n\n定义 1 ：两个整点 $P_1(x_1,y_1),P_2(x_2,y_2)$，若 $|x_1-x_2|+|y_1-y_2|=1$，则称 $P_1,P_2$ 相邻，记作 $P_1$~$P_2$ ，否则称 $P_1,P_2$ 不相邻。\n\n定义 2 ：设点集 $S$ 是 $W$ 的一个有限子集，即 $S$=$\\{P_1,P_2,…,P_n\\}$ $(n \\ge 1)$，其中 $P_i (1 \\le i \\le n)$ 属于 $W$，我们把 $S$ 称为整点集。\n\n定义 3 ：设 $S$ 是一个整点集，若点 $R$,$T$ 属于 $S$ ，且存在一个有限的点序列 $Q_1,Q_2,…,Q_k$ 满足: \n1. $Q_i$ 属于 $S$ （$ 1 \\le i \\le k $）;\n2. $Q_1$ = $R$,$Q_k$ = $T$;\n3. $Q_i$~$Q_{i+1} (1 \\le i \\le k-1)$，即 $Q_i$ 与 \n $Q_{i+1}$ 相邻;\n4. 对于任何 $1 \\le i<j \\le k$ 有 $Q_i≠Q_j$;\n\n我们则称点 $R$ 与点 $T$ 在整点集 $S$ 上连通，把点序列 $Q_1,Q_2,…,Q_k$ 称为整点集 $S$ 中连接点 $R$ 与点 $T$ 的一条道路。\n\n定义 4 ：若整点集 $V$ 满足：对于 $V$ 中的任何两个整点， $V$ 中有且仅有一条连接这两点的道路，则 $V$ 称为单整点集。\n\n定义 5 ：对于平面上的每一个整点，我们可以赋予它一个整数，作为该点的权，于是我们把一个整点集中所有点的权的总和称为该整点集的权和。\n\n我们希望对于给定的一个单整点集 $V$ ，求出一个 $V$ 的最优连通子集 $B$ ，满足：\n1. $B$ 是 $V$ 的子集\n2. 对于 $B$ 中的任何两个整点，在 $B$ 中连通；\n3. $B$ 是满足条件 (1) 和 (2) 的所有整点集中权和最大的。\n", "inputFormat": "第一行是一个整数 $N$ ，表示单整点集 $V$ 中点的个数；\n\n以下 $N$ 行中，第 $i$ 行 $(1 \\le i \\le N) $ 有三个整数，$X_i,Y_i,C_i$ 依次表示第 $i$ 个点的横坐标，纵坐标和权。同一行相邻两数之间用一个空格分隔。\n", "outputFormat": "仅一个整数，表示所求最优连通集的权和。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5767", "type": "P", "difficulty": 3, "samples": [["3 7\n6 7\n4 7 3 6\n2 1 3 5\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "1997", "NOI", "最短路"], "title": "[NOI1997] 最优乘车", "background": "", "description": "H 城是一个旅游胜地，每年都有成千上万的人前来观光。为方便游客，巴士公司在各个旅游景点及宾馆，饭店等地都设置了巴士站并开通了一些单程巴士线路。每条单程巴士线路从某个巴士站出发，依次途经若干个巴士站，最终到达终点巴士站。\n\n一名旅客最近到 H 城旅游，他很想去 S 公园游玩，但如果从他所在的饭店没有一路巴士可以直接到达 S 公园，则他可能要先乘某一路巴士坐几站，再下来换乘同一站台的另一路巴士，这样换乘几次后到达 S 公园。\n\n现在用整数 $1 , 2 , … , N$ 给 H 城的所有的巴士站编号，约定这名旅客所在饭店的巴士站编号为 $1$，S 公园巴士站的编号为 $N$。\n\n写一个程序，帮助这名旅客寻找一个最优乘车方案，使他在从饭店乘车到 S 公园的过程中换车的次数最少。\n\n", "inputFormat": "第一行有两个数字 $M$ 和 $N$（$ 1 \\le M \\le 100$，$ 1 < N \\le 500 $），表示开通了 $M$ 条单程巴士线路，总共有 $N$ 个车站。\n\n从第二行到第 $M+1$ 行依次给出了第 $1$ 条到第 $M$ 条巴士线路的信息。其中第 $i+1$ 行给出的是第 $i$ 条巴士线路的信息，从左至右按运行顺序依次给出了该线路上的所有站号相邻两个站号之间用一个空格隔开。\n\n", "outputFormat": "只有一行。如果无法乘巴士从饭店到达 S公园，则输出 `NO` ；\n\n否则输出你的程序所找到的最少换车次数，换车次数为 $0$ 表示不需换车即可到达。\n\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[NOI1997] Optimal Bus Transfer", "background": "", "description": "City H is a tourist city, and every year tens of thousands of people come to visit. To make it convenient for tourists, the bus company has set up bus stops at various attractions, hotels, restaurants, and other places, and has opened some one-way bus routes. Each one-way bus route starts from a bus stop, passes through several bus stops in order, and finally arrives at the terminal bus stop.\n\nA traveler is recently visiting City H and wants to go to Park S. However, if there is no bus that can take him directly from the stop near his hotel to Park S, he may need to take one bus for several stops, get off, and transfer to another bus at the same stop. After transferring several times, he can reach Park S.\n\nNow all bus stops in City H are numbered with integers $1, 2, \\dots, N$. By convention, the bus stop near the traveler’s hotel is numbered $1$, and the bus stop for Park S is numbered $N$.\n\nWrite a program to help this traveler find an optimal travel plan, so that the number of transfers during the trip from the hotel to Park S is minimized.", "inputFormat": "The first line contains two numbers $M$ and $N$ ($1 \\le M \\le 100$, $1 < N \\le 500$), meaning there are $M$ one-way bus routes in service and a total of $N$ bus stops.\n\nLines $2$ to $M + 1$ give the information for bus routes $1$ to $M$ in order. Line $i + 1$ gives the information for route $i$. From left to right, it lists all stop numbers on this route in the running order, and adjacent stop numbers are separated by one space.", "outputFormat": "Only one line.\n\nIf it is impossible to reach Park S by bus from the hotel, output `NO`.\n\nOtherwise, output the minimum number of transfers found by your program. A transfer count of $0$ means that it can be reached without any transfer.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI1997] 最优乘车", "background": "", "description": "H 城是一个旅游胜地，每年都有成千上万的人前来观光。为方便游客，巴士公司在各个旅游景点及宾馆，饭店等地都设置了巴士站并开通了一些单程巴士线路。每条单程巴士线路从某个巴士站出发，依次途经若干个巴士站，最终到达终点巴士站。\n\n一名旅客最近到 H 城旅游，他很想去 S 公园游玩，但如果从他所在的饭店没有一路巴士可以直接到达 S 公园，则他可能要先乘某一路巴士坐几站，再下来换乘同一站台的另一路巴士，这样换乘几次后到达 S 公园。\n\n现在用整数 $1 , 2 , … , N$ 给 H 城的所有的巴士站编号，约定这名旅客所在饭店的巴士站编号为 $1$，S 公园巴士站的编号为 $N$。\n\n写一个程序，帮助这名旅客寻找一个最优乘车方案，使他在从饭店乘车到 S 公园的过程中换车的次数最少。\n\n", "inputFormat": "第一行有两个数字 $M$ 和 $N$（$ 1 \\le M \\le 100$，$ 1 < N \\le 500 $），表示开通了 $M$ 条单程巴士线路，总共有 $N$ 个车站。\n\n从第二行到第 $M+1$ 行依次给出了第 $1$ 条到第 $M$ 条巴士线路的信息。其中第 $i+1$ 行给出的是第 $i$ 条巴士线路的信息，从左至右按运行顺序依次给出了该线路上的所有站号相邻两个站号之间用一个空格隔开。\n\n", "outputFormat": "只有一行。如果无法乘巴士从饭店到达 S公园，则输出 `NO` ；\n\n否则输出你的程序所找到的最少换车次数，换车次数为 $0$ 表示不需换车即可到达。\n\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5768", "type": "P", "difficulty": 6, "samples": [["47\nA 128.0.0.0/1\nA 128.0.0.0/4\nA 100.200.20.0/23\nA 241.170.96.0/20\nA 74.128.0.0/17\nA 193.24.0.0/14\nA 128.0.0.0/19\nA 128.0.0.0/13\nA 128.0.0.0/5\nA 128.0.0.0/11\nA 128.0.0.0/12\nA 192.0.0.0/7\nQ 192.0.0.13 1 8\nA 128.0.0.0/8\nQ 128.0.0.15 1 8\nA 74.0.0.0/8\nA 96.0.0.0/4\nA 193.24.0.0/23\nA 100.192.0.0/11\nA 128.0.0.0/18\nA 128.0.0.0/20\nQ 128.0.0.4 1 13\nA 192.0.0.0/8\nA 192.0.0.0/22\nQ 128.0.0.7 1 14\nA 128.0.0.0/23\nA 74.128.0.0/14\nA 128.0.0.0/14\nA 128.0.0.0/25\nA 74.128.0.0/12\nQ 128.0.0.9 2 17\nA 96.0.0.0/11\nA 64.0.0.0/2\nA 74.0.0.0/26\nA 100.192.0.0/18\nA 128.0.0.0/27\nA 193.24.0.0/18\nQ 128.0.0.3 4 21\nQ 74.128.0.12 3 24\nA 128.0.0.0/9\nA 193.24.0.0/22\nQ 128.0.0.7 4 24\nA 192.0.0.0/10\nQ 128.0.0.3 2 23\nA 100.192.0.0/10\nQ 241.170.96.2 1 26\nQ 100.192.0.4 4 24\n", "1\n3\n3\n3\n2\n2\n1\n3\n4\n2\n2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2016", "重庆", "各省省选"], "title": "[CQOI2016] 路由表", "background": "", "description": "路由表查找是路由器在转发 IP 报文时的重要环节。通常路由表中的表项由目的地址、掩码、下一跳（Next Hop）地址和其他辅助信息组成。例如：\n| 目的地址 | 掩码长度 | 下一跳 |\n| :----------: | :----------: | :----------: |\n| 0.0.0.0 | /1 | 192.168.1.1 |\n| 128.0.0.0 | /1 | 192.168.1.1 |\n| 8.8.8.0 | /24 | 192.168.1.1 |\n| 8.8.8.8 | /32 | 192.168.1.253 |\n\n\n当路由器收到一个 IP 报文时，会将报文中的目的 IP 地址与路由表中的表项逐条进行比较，选择匹配且**最明确**的表项，将报文转发给该表项中指定的下一跳。\n\n匹配的过程是将报文中的目的地址和表项中的目的地址分别转为二进制串，再查看表项中的掩码长度，若掩码长度为 $x$ ，则将两个二进制串的前 $x$ 位进行比较，如果相同则认为匹配。\n\n所谓**最明确**是指在有多个表项匹配时，掩码长度最大的表项。也可以理解为匹配的二进制位最多的项。\n\nIP 地址转为二进制串的操作是把地址中 $4$ 个整数（一定在 $0$ 到 $255$ 的范围内）分别转为 $8$ 位二进制数，再顺序拼接起来，得到一个  位的二进制串。例如，$192.168.1.253$ 转为二进制串后为 $11000000 $ $10101000$ $00000001$ $11111101$。\n\n我们以报文的目的地址为 $8.8.8.8$ 为例，说明其在上述路由表的匹配过程。\n\n\n| 8.8.8.8 | 00001000 00001000 00001000 00001000 |\n| :----------: | :----------: |\n| 0.0.0.0/1 | $\\color{red}{0}$0000000 00000000 00000000 00000000 |\n| 128.0.0.0/1 | $\\color{red}{1}$0000000 00000000 00000000 00000000 |\n| 8.8.8.0/24 | $\\color{red}{00001000}$ $\\color{red}{00001000 }$ $\\color{red}{00001000}$ 00000000 |\n| 8.8.8.8/32 | $\\color{red}{00001000}$ $\\color{red}{00001000 }$ $\\color{red}{00001000}$ $\\color{red}{00001000}$  |\n\n\n上表将地址均转为二进制串，并用红色标记出待比较的位（由掩码长度决定）。将红色部分与报文中的目的地址比较，可知 $0.0.0.0/1$、$8.8.8.0/24$、$8.8.8.8/32$ 均能够匹配。路由器从中选取掩码长度最长（/32）的表项 $8.8.8.8/32$，将报文转发给其对应的下一跳地址 $192.168.1.253$。\n\n在实际的核心路由器中，路由表通常较大（现在互联网的全局路由表已经接近 $60$\n 万条记录），并且会随着新接入设备不断扩张。为了分析路由表变化对转发产生的影响，网络工程师想要知道一段时间内某个 IP 地址的路由表项选择发生了多少次变化（变化是指由于最明确匹配等因素选择了不同的表项，不考虑下一跳地址）。", "inputFormat": "第一行为整数 $M$，表示共有 $M$ 次操作。接下来 $M$ 行，每行描述一次操作。操作有两种：\n\n`A <D>/<L>`\n\n其中 $D$ 为一个 IP 地址，$L$ 为整数 ($1 \\le L \\le 32 $)。添加一条表项至路由表，其目的地址为 $D$，掩码长度为 $L$。下一跳地址由于没有用到，故省略。\n\n`Q <D> <a> <b>`\n\n其中 $D$ 为一个 IP 地址，$a,b$ 为正整数($a \\le b$) 。查询从第 $a$ 次至第 $b$ 次添加表项期间（含 $a,b$），目的地址 $D$ 的路由表项选择发生了多少次变化。保证查询时表中至少有 $b$ 个表项。", "outputFormat": "包含若干行，每行仅有一个整数，依次对应每个查询操作。", "hint": "对于一次查询的一种理解方式是：无视其它所有查询操作，只看添加操作。先清空路由表，然后执行第 $1$ 到 $a-1$ 次添加操作。之后再统计第 $a$ 到 $b$ 次添加操作过程中匹配改变的次数。\n\n--------\n\n对于 $30\\%$ 的数据，$M \\le 10^3$；\n\n对于 $100\\%$ 的数据，$M \\le 10^6$。\n\n设一条表项的掩码长度为 $L$，数据保证将目的地址转为二进制串后，末尾的 $32-L$ 位均为 $0$。另外，保证不会重复添加目的地址和掩码长度都相同的表项。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2016] Routing Table", "background": "", "description": "Routing table lookup is an important step when a router forwards IP packets. Usually, each routing table entry consists of a destination address, a mask, a Next Hop address, and other auxiliary information. For example:\n\n| Destination Address | Mask Length | Next Hop |\n| :----------: | :----------: | :----------: |\n| 0.0.0.0 | /1 | 192.168.1.1 |\n| 128.0.0.0 | /1 | 192.168.1.1 |\n| 8.8.8.0 | /24 | 192.168.1.1 |\n| 8.8.8.8 | /32 | 192.168.1.253 |\n\nWhen a router receives an IP packet, it compares the destination IP address in the packet with the entries in the routing table one by one, chooses an entry that matches and is **most specific**, and forwards the packet to the Next Hop specified by that entry.\n\nThe matching process is: convert the destination address in the packet and the destination address in an entry into binary strings, then check the mask length of the entry. If the mask length is $x$, compare the first $x$ bits of the two binary strings. If they are the same, it is considered a match.\n\n**Most specific** means: if multiple entries match, choose the one with the largest mask length. It can also be understood as the entry that matches the most bits.\n\nThe operation of converting an IP address into a binary string is: convert the $4$ integers in the address (each must be in the range $0$ to $255$) into $8$-bit binary numbers, and then concatenate them in order to obtain a $32$-bit binary string. For example, after converting $192.168.1.253$ into a binary string, we get $11000000$ $10101000$ $00000001$ $11111101$.\n\nWe use the packet destination address $8.8.8.8$ as an example to illustrate the matching process in the routing table above.\n\n| 8.8.8.8 | 00001000 00001000 00001000 00001000 |\n| :----------: | :----------: |\n| 0.0.0.0/1 | $\\color{red}{0}$0000000 00000000 00000000 00000000 |\n| 128.0.0.0/1 | $\\color{red}{1}$0000000 00000000 00000000 00000000 |\n| 8.8.8.0/24 | $\\color{red}{00001000}$ $\\color{red}{00001000 }$ $\\color{red}{00001000}$ 00000000 |\n| 8.8.8.8/32 | $\\color{red}{00001000}$ $\\color{red}{00001000 }$ $\\color{red}{00001000}$ $\\color{red}{00001000}$ |\n\nIn the table above, all addresses are converted to binary strings, and the bits to be compared (determined by the mask length) are marked in red. By comparing the red parts with the destination address in the packet, we can see that $0.0.0.0/1$, $8.8.8.0/24$, and $8.8.8.8/32$ can all match. The router chooses the entry with the longest mask length (/32), i.e. $8.8.8.8/32$, and forwards the packet to its corresponding Next Hop address $192.168.1.253$.\n\nIn real core routers, routing tables are usually large (the global Internet routing table is now close to $60$万 entries), and they keep expanding as new devices join. To analyze how routing table changes affect forwarding, a network engineer wants to know, over a period of time, how many times the selected routing table entry for a certain IP address changes (a change means that a different entry is chosen due to factors such as most specific match; the Next Hop address is not considered).", "inputFormat": "The first line contains an integer $M$, indicating that there are $M$ operations in total. The next $M$ lines each describe one operation. There are two types of operations:\n\n`A <D>/<L>`\n\nHere $D$ is an IP address, and $L$ is an integer ($1 \\le L \\le 32$). Add an entry to the routing table, with destination address $D$ and mask length $L$. The Next Hop address is omitted because it is not used.\n\n`Q <D> <a> <b>`\n\nHere $D$ is an IP address, and $a,b$ are positive integers ($a \\le b$). Query, during the period from the $a$-th to the $b$-th added entry (including $a$ and $b$), how many times the selected routing table entry for destination address $D$ changes. It is guaranteed that at the time of the query, the table contains at least $b$ entries.", "outputFormat": "Contains several lines. Each line has only one integer, corresponding to each query operation in order.", "hint": "One way to understand a query is: ignore all other query operations and consider only the add operations. First clear the routing table, then perform the $1$-st to the $(a-1)$-th add operations. After that, count the number of times the match selection changes during the $a$-th to the $b$-th add operations.\n\n--------\n\nFor $30\\%$ of the testdata, $M \\le 10^3$.\n\nFor $100\\%$ of the testdata, $M \\le 10^6$.\n\nFor an entry with mask length $L$, the testdata guarantees that after converting the destination address into a binary string, the last $32-L$ bits are all $0$. In addition, it is guaranteed that no two added entries have both the same destination address and the same mask length.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2016] 路由表", "background": "", "description": "路由表查找是路由器在转发 IP 报文时的重要环节。通常路由表中的表项由目的地址、掩码、下一跳（Next Hop）地址和其他辅助信息组成。例如：\n| 目的地址 | 掩码长度 | 下一跳 |\n| :----------: | :----------: | :----------: |\n| 0.0.0.0 | /1 | 192.168.1.1 |\n| 128.0.0.0 | /1 | 192.168.1.1 |\n| 8.8.8.0 | /24 | 192.168.1.1 |\n| 8.8.8.8 | /32 | 192.168.1.253 |\n\n\n当路由器收到一个 IP 报文时，会将报文中的目的 IP 地址与路由表中的表项逐条进行比较，选择匹配且**最明确**的表项，将报文转发给该表项中指定的下一跳。\n\n匹配的过程是将报文中的目的地址和表项中的目的地址分别转为二进制串，再查看表项中的掩码长度，若掩码长度为 $x$ ，则将两个二进制串的前 $x$ 位进行比较，如果相同则认为匹配。\n\n所谓**最明确**是指在有多个表项匹配时，掩码长度最大的表项。也可以理解为匹配的二进制位最多的项。\n\nIP 地址转为二进制串的操作是把地址中 $4$ 个整数（一定在 $0$ 到 $255$ 的范围内）分别转为 $8$ 位二进制数，再顺序拼接起来，得到一个  位的二进制串。例如，$192.168.1.253$ 转为二进制串后为 $11000000 $ $10101000$ $00000001$ $11111101$。\n\n我们以报文的目的地址为 $8.8.8.8$ 为例，说明其在上述路由表的匹配过程。\n\n\n| 8.8.8.8 | 00001000 00001000 00001000 00001000 |\n| :----------: | :----------: |\n| 0.0.0.0/1 | $\\color{red}{0}$0000000 00000000 00000000 00000000 |\n| 128.0.0.0/1 | $\\color{red}{1}$0000000 00000000 00000000 00000000 |\n| 8.8.8.0/24 | $\\color{red}{00001000}$ $\\color{red}{00001000 }$ $\\color{red}{00001000}$ 00000000 |\n| 8.8.8.8/32 | $\\color{red}{00001000}$ $\\color{red}{00001000 }$ $\\color{red}{00001000}$ $\\color{red}{00001000}$  |\n\n\n上表将地址均转为二进制串，并用红色标记出待比较的位（由掩码长度决定）。将红色部分与报文中的目的地址比较，可知 $0.0.0.0/1$、$8.8.8.0/24$、$8.8.8.8/32$ 均能够匹配。路由器从中选取掩码长度最长（/32）的表项 $8.8.8.8/32$，将报文转发给其对应的下一跳地址 $192.168.1.253$。\n\n在实际的核心路由器中，路由表通常较大（现在互联网的全局路由表已经接近 $60$\n 万条记录），并且会随着新接入设备不断扩张。为了分析路由表变化对转发产生的影响，网络工程师想要知道一段时间内某个 IP 地址的路由表项选择发生了多少次变化（变化是指由于最明确匹配等因素选择了不同的表项，不考虑下一跳地址）。", "inputFormat": "第一行为整数 $M$，表示共有 $M$ 次操作。接下来 $M$ 行，每行描述一次操作。操作有两种：\n\n`A <D>/<L>`\n\n其中 $D$ 为一个 IP 地址，$L$ 为整数 ($1 \\le L \\le 32 $)。添加一条表项至路由表，其目的地址为 $D$，掩码长度为 $L$。下一跳地址由于没有用到，故省略。\n\n`Q <D> <a> <b>`\n\n其中 $D$ 为一个 IP 地址，$a,b$ 为正整数($a \\le b$) 。查询从第 $a$ 次至第 $b$ 次添加表项期间（含 $a,b$），目的地址 $D$ 的路由表项选择发生了多少次变化。保证查询时表中至少有 $b$ 个表项。", "outputFormat": "包含若干行，每行仅有一个整数，依次对应每个查询操作。", "hint": "对于一次查询的一种理解方式是：无视其它所有查询操作，只看添加操作。先清空路由表，然后执行第 $1$ 到 $a-1$ 次添加操作。之后再统计第 $a$ 到 $b$ 次添加操作过程中匹配改变的次数。\n\n--------\n\n对于 $30\\%$ 的数据，$M \\le 10^3$；\n\n对于 $100\\%$ 的数据，$M \\le 10^6$。\n\n设一条表项的掩码长度为 $L$，数据保证将目的地址转为二进制串后，末尾的 $32-L$ 位均为 $0$。另外，保证不会重复添加目的地址和掩码长度都相同的表项。", "locale": "zh-CN"}}}
{"pid": "P5769", "type": "P", "difficulty": 6, "samples": [["3 3\n100 1 1\n0 1 1\n1 0 5\n2 1 0\n1 2 1\n2 1 1\n3 1 9\n", "2\n"], ["3 3\n100 1 1\n0 1 1\n1 0 5\n2 1 0\n1 2 1\n2 1 1\n3 1 8\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2016", "各省省选", "江苏"], "title": "[JSOI2016] 飞机调度", "background": "", "description": "JSOI 王国里有 $N$ 个机场，编号为 $1$ 到 $N$。从 $i$ 号机场到 $j$ 号机场需要飞行 $T_{i,j}$ 的时间。由于风向，地理位置和航空管制的因素，$T_{i,j}$  和 $T_{j,i}$ 并不一定相同。\n\n此外，由于飞机降落之后需要例行维修和加油。当一架飞机降落 $k$ 号机场时，需要花费 $P_k$​​ 的维护时间才能再次起飞。\n\nJS Airways 一共运营 $M$ 条航线，其中第 $i$ 条直飞航线需要在 $D_i$ 时刻从 $X_i$ 机场起飞，不经停，飞往 $Y_i$ 机场。\n\n为了简化问题，我们假设 JS Airway 可以在 $0$ 时刻在任意机场布置任意多架加油维护完毕的飞机；为了减少飞机的使用数，我们允许 JS Airways 增开任意多条临时航线以满足飞机的调度需求。\n\nJYY 想知道，理论上 JS Airways 最少需要多少架飞机才能完成所有这 $M$ 个航班。", "inputFormat": "第一行包含两个正整数 $N$,$M$；\n\n接下来一行包含 $N$ 个正整数表示每一个机场的飞机维护时间；\n\n接下来 $N$ 行，每行 $N$ 个非负整数，其中第 $i$ 行第 $j$ 个非负整数为 $T_{i,j}$，表示从 $i$ 号机场飞往 $j$ 号机场所需要花费的时间。数据保证 $T_{i,i}=0$；\n\n接下来 $M$ 行，每行三个正整数，其中第 $i$ 行为 $X_i,Y_i,D_i$，表示第 $i$ 条航线的起飞机场，降落机场，以及起飞时间。数据保证 $X_i \\neq Y_i$。", "outputFormat": "一行一个正整数，表示 JS Airways 理论上最少需要的飞机数。", "hint": "**样例说明1**\n\n在第一个样例中，JS Airways 可以在 $0$ 时刻在 $2$ 号机场安排一架飞机并执飞第 $2$ 条航线（$2→1$）。此外还需要在 $0$ 时刻在 $1$ 号机场安排一架飞机，这架飞机首先执飞第 $1$ 条航线（$1→2$），然后通过临时新增一条航线从 $2$ 号机场起飞飞往 $3$ 号机场，降落 $3$ 号机场之后执飞第 $3$ 条航线（$3→1$）。\n\n**样例说明2**\n\n在第二个样例中，执行完第 $1$ 条航线的飞机无法赶上第 $3$ 条航线的起飞时间，因此 JS Airways 必须使用 $3$ 架不同的飞机才能完成所有的航班。\n\n------------\n\n**数据范围**\n\n对于 $30\\%$ 的数据，满足 $N,M \\le 10$；\n\n对于 $60\\%$ 的数据，满足 $N,M \\le 100$；\n\n对于全部数据，满足 $1 \\le N,M \\le 500$，$0 \\le P_i,T_{i,j} \\le 10^6$，$1 \\le D_i \\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2016] Aircraft Scheduling", "background": "", "description": "In the JSOI Kingdom, there are $N$ airports, numbered from $1$ to $N$. Flying from airport $i$ to airport $j$ takes time $T_{i,j}$. Due to wind direction, geographic location, and air traffic control, $T_{i,j}$ and $T_{j,i}$ are not necessarily the same.\n\nAlso, after an aircraft lands, it needs routine maintenance and refueling. When an aircraft lands at airport $k$, it must spend $P_k$ time on maintenance before it can take off again.\n\nJS Airways operates a total of $M$ routes. For the $i$-th direct flight, it must take off from airport $X_i$ at time $D_i$ and fly non-stop to airport $Y_i$.\n\nTo simplify the problem, we assume JS Airways can place any number of fully maintained and refueled aircraft at any airport at time $0$. To reduce the number of aircraft used, we also allow JS Airways to add any number of temporary flights to satisfy scheduling needs.\n\nJYY wants to know: in theory, what is the minimum number of aircraft JS Airways needs to complete all these $M$ flights.", "inputFormat": "The first line contains two positive integers $N, M$.\n\nThe next line contains $N$ positive integers, representing the aircraft maintenance time for each airport.\n\nThe next $N$ lines each contain $N$ non-negative integers. The $j$-th non-negative integer in the $i$-th line is $T_{i,j}$, meaning the time required to fly from airport $i$ to airport $j$. The data guarantees $T_{i,i} = 0$.\n\nThe next $M$ lines each contain three positive integers. The $i$-th line is $X_i, Y_i, D_i$, representing the departure airport, the arrival airport, and the departure time of the $i$-th route. The data guarantees $X_i \\neq Y_i$.", "outputFormat": "Output one positive integer in a single line, representing the theoretical minimum number of aircraft JS Airways needs.", "hint": "**Sample Explanation 1**\n\nIn the first sample, JS Airways can arrange one aircraft at airport $2$ at time $0$ and use it to operate flight $2$ ($2 \\to 1$). In addition, it needs to arrange one aircraft at airport $1$ at time $0$. This aircraft first operates flight $1$ ($1 \\to 2$), then takes a newly added temporary flight from airport $2$ to airport $3$, and after landing at airport $3$, it operates flight $3$ ($3 \\to 1$).\n\n**Sample Explanation 2**\n\nIn the second sample, the aircraft that finishes flight $1$ cannot catch the departure time of flight $3$. Therefore, JS Airways must use $3$ different aircraft to complete all flights.\n\n------------\n\n**Constraints**\n\nFor $30\\%$ of the testdata, $N, M \\le 10$.\n\nFor $60\\%$ of the testdata, $N, M \\le 100$.\n\nFor all testdata, $1 \\le N, M \\le 500$, $0 \\le P_i, T_{i,j} \\le 10^6$, $1 \\le D_i \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2016] 飞机调度", "background": "", "description": "JSOI 王国里有 $N$ 个机场，编号为 $1$ 到 $N$。从 $i$ 号机场到 $j$ 号机场需要飞行 $T_{i,j}$ 的时间。由于风向，地理位置和航空管制的因素，$T_{i,j}$  和 $T_{j,i}$ 并不一定相同。\n\n此外，由于飞机降落之后需要例行维修和加油。当一架飞机降落 $k$ 号机场时，需要花费 $P_k$​​ 的维护时间才能再次起飞。\n\nJS Airways 一共运营 $M$ 条航线，其中第 $i$ 条直飞航线需要在 $D_i$ 时刻从 $X_i$ 机场起飞，不经停，飞往 $Y_i$ 机场。\n\n为了简化问题，我们假设 JS Airway 可以在 $0$ 时刻在任意机场布置任意多架加油维护完毕的飞机；为了减少飞机的使用数，我们允许 JS Airways 增开任意多条临时航线以满足飞机的调度需求。\n\nJYY 想知道，理论上 JS Airways 最少需要多少架飞机才能完成所有这 $M$ 个航班。", "inputFormat": "第一行包含两个正整数 $N$,$M$；\n\n接下来一行包含 $N$ 个正整数表示每一个机场的飞机维护时间；\n\n接下来 $N$ 行，每行 $N$ 个非负整数，其中第 $i$ 行第 $j$ 个非负整数为 $T_{i,j}$，表示从 $i$ 号机场飞往 $j$ 号机场所需要花费的时间。数据保证 $T_{i,i}=0$；\n\n接下来 $M$ 行，每行三个正整数，其中第 $i$ 行为 $X_i,Y_i,D_i$，表示第 $i$ 条航线的起飞机场，降落机场，以及起飞时间。数据保证 $X_i \\neq Y_i$。", "outputFormat": "一行一个正整数，表示 JS Airways 理论上最少需要的飞机数。", "hint": "**样例说明1**\n\n在第一个样例中，JS Airways 可以在 $0$ 时刻在 $2$ 号机场安排一架飞机并执飞第 $2$ 条航线（$2→1$）。此外还需要在 $0$ 时刻在 $1$ 号机场安排一架飞机，这架飞机首先执飞第 $1$ 条航线（$1→2$），然后通过临时新增一条航线从 $2$ 号机场起飞飞往 $3$ 号机场，降落 $3$ 号机场之后执飞第 $3$ 条航线（$3→1$）。\n\n**样例说明2**\n\n在第二个样例中，执行完第 $1$ 条航线的飞机无法赶上第 $3$ 条航线的起飞时间，因此 JS Airways 必须使用 $3$ 架不同的飞机才能完成所有的航班。\n\n------------\n\n**数据范围**\n\n对于 $30\\%$ 的数据，满足 $N,M \\le 10$；\n\n对于 $60\\%$ 的数据，满足 $N,M \\le 100$；\n\n对于全部数据，满足 $1 \\le N,M \\le 500$，$0 \\le P_i,T_{i,j} \\le 10^6$，$1 \\le D_i \\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P5770", "type": "P", "difficulty": 5, "samples": [["5\n5 1\n5 2\n5 3\n5 4\n5 5\n", "12\naaaab\n12\naaabb\n12\naabab\n12\naabbb\n12\nababb\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2016", "各省省选", "江苏", "容斥原理", "KMP 算法"], "title": "[JSOI2016] 无界单词", "background": "", "description": "对于一个单词 $S$ ，如果存在一个长度 $l$，满足 $0 < l < |S|$，并且使得 $S$ 长度为 $l$ 的前缀与 $S$ 长度为 $l$ 的后缀相同，JYY 则称 $S$ 是有界的。比如 `aabaa` 和 `ababab` 就都是有界的字符串。如果一个单词不存在这样的 $l$ ，则 JYY 称之为无界单词。\n\n现在考虑所有仅由字母 `a` 和 `b` 组成的长度为 $N$ 的字符串，JYY想知道：\n\n1. 一共有多少个无界单词？\n2. 这些无界单词中，按字典序排列第 $K$ 小的单词是哪一个？", "inputFormat": "**本题有多组数据。**\n\n第一行包含一个正整数 $T$，表示测试数据的组数；\n\n接下来 $T$ 行，每行包含两个正整数 $N$ 和 $K$，表示一组测试数据。", "outputFormat": "对于每一个测试数据，输出两行。\n\n其中第一行包含一个整数，表示长度为 $N$ 的无界单词的数量；\n\n其中第二行包含一个长度为 $N$ 的字符串，表示第 $K$ 小的无界单词。", "hint": "对于 $20\\%$ 的数据，满足 $N \\le 20 $；\n\n对于全部数据，满足 $1 \\le T \\le 5$，$1 \\le N \\le 64$，并且保证对于任意测试数据，总存在第 $K$ 小的无界单词。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2016] Unbordered Words", "background": "", "description": "For a word $S$, if there exists a length $l$ such that $0 < l < |S|$, and the prefix of $S$ with length $l$ is the same as the suffix of $S$ with length $l$, then JYY calls $S$ *bordered*. For example, `aabaa` and `ababab` are both bordered strings. If a word does not have such an $l$, then JYY calls it an *unbordered word*.\n\nNow consider all strings of length $N$ that consist only of the letters `a` and `b`. JYY wants to know:\n\n1. How many unbordered words are there in total?\n2. Among these unbordered words, when sorted in lexicographical order, what is the $K$-th smallest word?", "inputFormat": "**This problem contains multiple test cases.**\n\nThe first line contains a positive integer $T$, the number of test cases.\n\nThe next $T$ lines each contain two positive integers $N$ and $K$, describing one test case.", "outputFormat": "For each test case, output two lines.\n\nThe first line contains an integer, the number of unbordered words of length $N$.\n\nThe second line contains a string of length $N$, representing the $K$-th smallest unbordered word.", "hint": "For $20\\%$ of the testdata, $N \\le 20$.\n\nFor all testdata, $1 \\le T \\le 5$, $1 \\le N \\le 64$, and it is guaranteed that for every test case, the $K$-th smallest unbordered word always exists.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2016] 无界单词", "background": "", "description": "对于一个单词 $S$ ，如果存在一个长度 $l$，满足 $0 < l < |S|$，并且使得 $S$ 长度为 $l$ 的前缀与 $S$ 长度为 $l$ 的后缀相同，JYY 则称 $S$ 是有界的。比如 `aabaa` 和 `ababab` 就都是有界的字符串。如果一个单词不存在这样的 $l$ ，则 JYY 称之为无界单词。\n\n现在考虑所有仅由字母 `a` 和 `b` 组成的长度为 $N$ 的字符串，JYY想知道：\n\n1. 一共有多少个无界单词？\n2. 这些无界单词中，按字典序排列第 $K$ 小的单词是哪一个？", "inputFormat": "**本题有多组数据。**\n\n第一行包含一个正整数 $T$，表示测试数据的组数；\n\n接下来 $T$ 行，每行包含两个正整数 $N$ 和 $K$，表示一组测试数据。", "outputFormat": "对于每一个测试数据，输出两行。\n\n其中第一行包含一个整数，表示长度为 $N$ 的无界单词的数量；\n\n其中第二行包含一个长度为 $N$ 的字符串，表示第 $K$ 小的无界单词。", "hint": "对于 $20\\%$ 的数据，满足 $N \\le 20 $；\n\n对于全部数据，满足 $1 \\le T \\le 5$，$1 \\le N \\le 64$，并且保证对于任意测试数据，总存在第 $K$ 小的无界单词。", "locale": "zh-CN"}}}
{"pid": "P5771", "type": "P", "difficulty": 5, "samples": [["6\n1 2 2 3 4 10\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2016", "各省省选", "江苏"], "title": "[JSOI2016] 反质数序列", "background": "", "description": "对于一个长度为 $L \\ge 2$ 的序列 $X:\\{x_1,x_2,...,x_L\\}$，如果满足对于任意 $1 \\le i < j \\le L$，均有 $x_i+x_j$ 不为质数，则 JYY 认为序列 $X$ 是一个「反质数序列」。\n\nJYY 有一个长度为 $N$ 的序列 $A:\\{a_1,a_2,...,a_N\\}$，他希望从中选出一个包含元素最多的**子序列**，使得这个子序列是一个反质数序列。", "inputFormat": "输入第一行包含一个正整数 $N$；\n\n接下来一行包含 $N$ 个正整数，依次描述 $a_1,a_2,...,a_N$。", "outputFormat": "输出一行一个整数，表示最长反质数子序列的长度。输入保证存在反质数子序列。", "hint": "对于 $10\\%$ 的数据，满足 $N \\le 10$；\n\n对于 $40\\%$ 的数据，满足 $N \\le 150$；\n\n对于 $80\\%$ 的数据，满足 $N \\le 1000$；\n\n对于 $100\\%$ 的数据，满足 $2 \\le N \\le 3000$，$1 \\le a_i \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2016] Anti-prime Sequence", "background": "", "description": "For a sequence $X:\\{x_1,x_2,...,x_L\\}$ of length $L \\ge 2$, if for any $1 \\le i < j \\le L$, $x_i + x_j$ is not a prime number, then JYY considers the sequence $X$ to be an “anti-prime sequence”.\n\nJYY has a sequence $A:\\{a_1,a_2,...,a_N\\}$ of length $N$. He wants to choose a **subsequence** with as many elements as possible such that this subsequence is an anti-prime sequence.", "inputFormat": "The first line contains a positive integer $N$.\n\nThe next line contains $N$ positive integers, describing $a_1,a_2,...,a_N$ in order.", "outputFormat": "Output one integer in a single line, representing the length of the longest anti-prime subsequence. The input guarantees that an anti-prime subsequence exists.", "hint": "For $10\\%$ of the testdata, $N \\le 10$.\n\nFor $40\\%$ of the testdata, $N \\le 150$.\n\nFor $80\\%$ of the testdata, $N \\le 1000$.\n\nFor $100\\%$ of the testdata, $2 \\le N \\le 3000$, $1 \\le a_i \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2016] 反质数序列", "background": "", "description": "对于一个长度为 $L \\ge 2$ 的序列 $X:\\{x_1,x_2,...,x_L\\}$，如果满足对于任意 $1 \\le i < j \\le L$，均有 $x_i+x_j$ 不为质数，则 JYY 认为序列 $X$ 是一个「反质数序列」。\n\nJYY 有一个长度为 $N$ 的序列 $A:\\{a_1,a_2,...,a_N\\}$，他希望从中选出一个包含元素最多的**子序列**，使得这个子序列是一个反质数序列。", "inputFormat": "输入第一行包含一个正整数 $N$；\n\n接下来一行包含 $N$ 个正整数，依次描述 $a_1,a_2,...,a_N$。", "outputFormat": "输出一行一个整数，表示最长反质数子序列的长度。输入保证存在反质数子序列。", "hint": "对于 $10\\%$ 的数据，满足 $N \\le 10$；\n\n对于 $40\\%$ 的数据，满足 $N \\le 150$；\n\n对于 $80\\%$ 的数据，满足 $N \\le 1000$；\n\n对于 $100\\%$ 的数据，满足 $2 \\le N \\le 3000$，$1 \\le a_i \\le 10^5$。", "locale": "zh-CN"}}}
