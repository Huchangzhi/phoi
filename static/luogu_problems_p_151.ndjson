{"pid": "P4058", "type": "P", "difficulty": 3, "samples": [["3 74 51\n2 5 2\n2 7 9\n", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["二分", "O2优化", "优先队列", "Code+"], "title": "[Code+#1] 木材", "background": "", "description": "有 $n$ 棵树，初始时每棵树的高度为 $H_i$，第 $i$ 棵树每月都会长高 $A_i$。现在有个木料长度总量为 $S$ 的订单，客户要求每块木料的长度不能小于  $L$，而且木料必须是整棵树（即不能为树的一部分）。现在问你最少需要等多少个月才能满足订单。\n", "inputFormat": "第一行 $3$ 个用空格隔开的非负整数 $n,S,L$，表示树的数量、订单总量和单块木料长度限制。\n\n第二行 $n$ 个用空格隔开的非负整数，依次为 $H_1,H_2, ... ,H_n$。\n\n第三行 $n$ 个用空格隔开的非负整数，依次为 $A_1,A_2, ... ,A_n$。\n", "outputFormat": "输出一行一个整数表示答案。\n", "hint": "对于样例，在六个月后，各棵树的高度分别为 $14,47,56$，此时无法完成订单。\n\n在七个月后，各棵树的高度分别为 $16,54,65$，此时可以砍下第 $2$ 和第 $3$ 棵树完成订单了。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12821.png) \n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/郑林楷 命题/郑林楷 验题/王聿中\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#1] Timber", "background": "", "description": "There are $n$ trees. Initially, the $i$-th tree has height $H_i$, and every month the $i$-th tree grows by $A_i$. There is an order for a total timber length of $S$. The client requires each piece of timber to have length at least $L$, and each piece must be a whole tree (i.e., you cannot take only part of a tree). What is the minimum number of months you need to wait to fulfill the order?", "inputFormat": "The first line contains $3$ non-negative integers $n$, $S$, $L$ separated by spaces, denoting the number of trees, the total required length, and the minimum length for a single piece, respectively.\n\nThe second line contains $n$ non-negative integers $H_1, H_2, \\ldots, H_n$.\n\nThe third line contains $n$ non-negative integers $A_1, A_2, \\ldots, A_n$.", "outputFormat": "Output a single integer on one line representing the answer.", "hint": "For the sample, after six months, the heights of the trees are $14$, $47$, $56$, and the order cannot be fulfilled.\n\nAfter seven months, the heights are $16$, $54$, $65$. You can then cut down the $2$-nd and $3$-rd trees to fulfill the order.\n\n![](https://cdn.luogu.com.cn/upload/pic/12821.png)\n\nFrom CodePlus 2017 November Contest, proudly presented by the Student Association for Algorithms and Competitions, Department of Computer Science and Technology, Tsinghua University.\n\nCredit: idea/Zheng Linkai, problem setter/Zheng Linkai, tester/Wang Yuzhong.\n\nGit Repo: https://git.thusaac.org/publish/CodePlus201711\n\nThanks to Tencent for supporting this contest.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#1] 木材", "background": "", "description": "有 $n$ 棵树，初始时每棵树的高度为 $H_i$，第 $i$ 棵树每月都会长高 $A_i$。现在有个木料长度总量为 $S$ 的订单，客户要求每块木料的长度不能小于  $L$，而且木料必须是整棵树（即不能为树的一部分）。现在问你最少需要等多少个月才能满足订单。\n", "inputFormat": "第一行 $3$ 个用空格隔开的非负整数 $n,S,L$，表示树的数量、订单总量和单块木料长度限制。\n\n第二行 $n$ 个用空格隔开的非负整数，依次为 $H_1,H_2, ... ,H_n$。\n\n第三行 $n$ 个用空格隔开的非负整数，依次为 $A_1,A_2, ... ,A_n$。\n", "outputFormat": "输出一行一个整数表示答案。\n", "hint": "对于样例，在六个月后，各棵树的高度分别为 $14,47,56$，此时无法完成订单。\n\n在七个月后，各棵树的高度分别为 $16,54,65$，此时可以砍下第 $2$ 和第 $3$ 棵树完成订单了。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12821.png) \n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/郑林楷 命题/郑林楷 验题/王聿中\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。\n", "locale": "zh-CN"}}}
{"pid": "P4059", "type": "P", "difficulty": 4, "samples": [["ATGG\nATCC\n5 -4 -4 -4 \n-4 5 -4 -4 \n-4 -4 5 -4 \n-4 -4 -4 5 \n2 1", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "递推", "O2优化", "Code+"], "title": "[Code+#1] 找爸爸", "background": null, "description": "小 A 最近一直在找自己的爸爸，用什么办法呢，就是 DNA 比对。\n\n小 A 有一套自己的 DNA 序列比较方法，其最终目标是最大化两个 DNA 序列的相似程度，具体步骤如下：\n\n\n1. 给出两个 DNA 序列，第一个长度为 $n$，第二个长度为 $m$。\n\n2. 在两个序列的任意位置插入任意多的空格，使得两个字符串长度相同\n\n3. 逐位进行匹配，**如果两个序列相同位置上的字符都不是空格**，假设第一个是 $x$，第二个是 $y$，那么他们的相似程度由 $d(x,y)$ 定义。对于两个序列中任意一段极长的长度为 $k$ 的连续空格，我们定义这段空格的相似程度为 $g(k)=-A-B(k-1)$。\n\n\n那么最终两个序列的相似程度就是所有的 $d(x,y)$ 加上所有的极长空格段的相似程度之和。\n\n现在小 A 通过某种奥妙重重的方式得到了小 B 的 DNA 序列中的一段，他想请你帮他算一下小 A 的 DNA 序列和小 B 的 DNA 序列的最大相似程度。", "inputFormat": "输入第 $1$ 行一个字符串，表示小 A 的 DNA 序列。\n\n输入第 $2$ 行一个字符串，表示小 B 的 DNA 序列。\n\n接下来 $4$ 行，每行 $4$ 个整数，用空格隔开，表示 $d$ 数组，具体顺序如下所示。\n\n```plain\nd(A,A) d(A,T) d(A,G) d(A,C)\nd(T,A) d(T,T) d(T,G) d(T,C)\nd(G,A) d(G,T) d(G,G) d(G,C)\nd(C,A) d(C,T) d(C,G) d(C,C)\n```\n最后一行两个用空格隔开的正整数 $A,B$，意义如题中所述。", "outputFormat": "输出共一行，表示两个序列的最大相似程度。", "hint": "### 样例解释\n\n首先，将序列补成如下形式（\"-\"代表空格）\n\n```cpp\nATGG--\nAT--CC\n```\n然后所有 $d(x,y)$ 的和为 $d(A,A)+d(T,T)=10$\n\n所有极长连续空格段的相似程度之和为 $g(2)+g(2)=-6$\n\n总和为 $4$，可以验证，这是相似程度最大的情况。\n\n对于所有测试点，有 $0< B<A \\le 1000, -1000\\le d(x,y)\\le 1000,d(x,y)=d(y,x)$，序列只包含${A,T,G,C}$四种字符。\n\n::cute-table{tuack}\n\n|测试点编号|$n+m$ 的范围|特殊约定|\n|:-:|:-:|:-:|\n|$1$|$n=m=1$|无特殊要求|\n|$2$|$n+m\\le15$|^|\n|$3$|$n+m\\le300$|^|\n|$4$|^|^|\n|$5$|$n+m\\le3000$|序列中只包含一个字符|\n|$6$|^|无特殊要求|\n|$7$|^|^|\n|$8$|^|^|\n|$9$|^|^|\n|$10$|^|^|\n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/卢政荣 命题/卢政荣 验题/何昊天\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#1] Find Dad", "background": "", "description": "Xiao A has been looking for his own father recently. How? By DNA matching.\n\nXiao A has his own method for comparing DNA sequences. The goal is to maximize the similarity score between two DNA sequences. The steps are as follows:\n\n1. Given two DNA sequences, the first of length $n$ and the second of length $m$.\n2. Insert any number of gaps at any positions in the two sequences so that the two strings have the same length.\n3. Match position by position. If at a position neither character is a gap, let the first be $x$ and the second be $y$, then their similarity is defined as $d(x, y)$. For any maximal contiguous block of gaps of length $k$ in either sequence, we define its similarity as $g(k) = -A - B(k-1)$.\n\nThe final similarity score of the two sequences is the sum of all $d(x, y)$ values plus the similarity of all maximal gap blocks.\n\nNow Xiao A has, by some mysterious means, obtained a segment of Xiao B’s DNA sequence. He asks you to compute the maximum similarity score between Xiao A’s DNA sequence and Xiao B’s DNA sequence.", "inputFormat": "The first line contains a string representing Xiao A’s DNA sequence.\nThe second line contains a string representing Xiao B’s DNA sequence.\nThe next $4$ lines each contain $4$ integers separated by spaces, representing the $d$ array in the following order.\n\n```plain\nd(A,A) d(A,T) d(A,G) d(A,C)\nd(T,A) d(T,T) d(T,G) d(T,C)\nd(G,A) d(G,T) d(G,G) d(G,C)\nd(C,A) d(C,T) d(C,G) d(C,C)\n```\n\nThe last line contains two positive integers $A, B$ separated by spaces, as described above.", "outputFormat": "Output a single line: the maximum similarity score of the two sequences.", "hint": "Sample explanation.\n\nFirst, pad the sequences as follows (“-” denotes a gap):\n\n```cpp\nATGG--\nAT--CC\n```\n\nThen the sum of all $d(x, y)$ is $d(A, A) + d(T, T) = 10$.\nThe sum of the similarity of all maximal contiguous gap blocks is $g(2) + g(2) = -6$.\nThe total is $4$, which can be verified to be the maximum similarity.\n\nFor all test points, $0 < B < A \\le 1000$, $-1000 \\le d(x, y) \\le 1000$, $d(x, y) = d(y, x)$, and each sequence contains only the four characters $\\{A, T, G, C\\}$.\n\n| Test point ID | $n+m$ range     | Special notes                    |\n|:-:|:-:|:-:|\n| $1$  | $n = m = 1$       | No special requirements.          |\n| $2$  | $n+m \\le 15$      | ^                                 |\n| $3$  | $n+m \\le 300$     | ^                                 |\n| $4$  | ^                 | ^                                 |\n| $5$  | $n+m \\le 3000$    | Sequences contain only one type of character. |\n| $6$  | ^                 | No special requirements.          |\n| $7$  | ^                 | ^                                 |\n| $8$  | ^                 | ^                                 |\n| $9$  | ^                 | ^                                 |\n| $10$ | ^                 | ^                                 |\n\nFrom CodePlus 2017 November Contest, proudly presented by the Student Algorithm and Competition Association, Department of Computer Science and Technology, Tsinghua University.\n\nCredit: Idea/Lu Zhengrong; Problem setter/Lu Zhengrong; Tester/He Haotian.\n\nGit Repo: https://git.thusaac.org/publish/CodePlus201711\n\nThanks to Tencent for supporting this contest.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#1] 找爸爸", "background": null, "description": "小 A 最近一直在找自己的爸爸，用什么办法呢，就是 DNA 比对。\n\n小 A 有一套自己的 DNA 序列比较方法，其最终目标是最大化两个 DNA 序列的相似程度，具体步骤如下：\n\n\n1. 给出两个 DNA 序列，第一个长度为 $n$，第二个长度为 $m$。\n\n2. 在两个序列的任意位置插入任意多的空格，使得两个字符串长度相同\n\n3. 逐位进行匹配，**如果两个序列相同位置上的字符都不是空格**，假设第一个是 $x$，第二个是 $y$，那么他们的相似程度由 $d(x,y)$ 定义。对于两个序列中任意一段极长的长度为 $k$ 的连续空格，我们定义这段空格的相似程度为 $g(k)=-A-B(k-1)$。\n\n\n那么最终两个序列的相似程度就是所有的 $d(x,y)$ 加上所有的极长空格段的相似程度之和。\n\n现在小 A 通过某种奥妙重重的方式得到了小 B 的 DNA 序列中的一段，他想请你帮他算一下小 A 的 DNA 序列和小 B 的 DNA 序列的最大相似程度。", "inputFormat": "输入第 $1$ 行一个字符串，表示小 A 的 DNA 序列。\n\n输入第 $2$ 行一个字符串，表示小 B 的 DNA 序列。\n\n接下来 $4$ 行，每行 $4$ 个整数，用空格隔开，表示 $d$ 数组，具体顺序如下所示。\n\n```plain\nd(A,A) d(A,T) d(A,G) d(A,C)\nd(T,A) d(T,T) d(T,G) d(T,C)\nd(G,A) d(G,T) d(G,G) d(G,C)\nd(C,A) d(C,T) d(C,G) d(C,C)\n```\n最后一行两个用空格隔开的正整数 $A,B$，意义如题中所述。", "outputFormat": "输出共一行，表示两个序列的最大相似程度。", "hint": "### 样例解释\n\n首先，将序列补成如下形式（\"-\"代表空格）\n\n```cpp\nATGG--\nAT--CC\n```\n然后所有 $d(x,y)$ 的和为 $d(A,A)+d(T,T)=10$\n\n所有极长连续空格段的相似程度之和为 $g(2)+g(2)=-6$\n\n总和为 $4$，可以验证，这是相似程度最大的情况。\n\n对于所有测试点，有 $0< B<A \\le 1000, -1000\\le d(x,y)\\le 1000,d(x,y)=d(y,x)$，序列只包含${A,T,G,C}$四种字符。\n\n::cute-table{tuack}\n\n|测试点编号|$n+m$ 的范围|特殊约定|\n|:-:|:-:|:-:|\n|$1$|$n=m=1$|无特殊要求|\n|$2$|$n+m\\le15$|^|\n|$3$|$n+m\\le300$|^|\n|$4$|^|^|\n|$5$|$n+m\\le3000$|序列中只包含一个字符|\n|$6$|^|无特殊要求|\n|$7$|^|^|\n|$8$|^|^|\n|$9$|^|^|\n|$10$|^|^|\n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/卢政荣 命题/卢政荣 验题/何昊天\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN"}}}
{"pid": "P4060", "type": "P", "difficulty": 5, "samples": [["5 3\n4 0\n3 7\n5 0", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "递推", "O2优化", "枚举", "前缀和", "位运算", "Code+"], "title": "[Code+#1] 可做题", "background": "", "description": "qmqmqm 希望给 sublinekelzrip 出一道可做题。于是他想到了这么一道题目：给一个长度为 $n$ 的非负整数序列 $a_i$，你需要计算其异或前缀和 $b_i$，满足条件 $b_1=a_1,b_i=b_{i-1}\\operatorname{xor}a_i(i \\geq 2)$。\n\n但是由于数据生成器出现了问题，他生成的序列 $a$ 的长度特别长，并且由于内存空间不足，一部分 $a_i$ 已经丢失了，只剩余 $m$ 个位置的元素已知。现在 qmqmqm 找到你，希望你根据剩余的 $a_i$，计算出所有可能的 $a$ 序列对应的 $b$ 序列中 $\\sum_{i=1}^n b_i$ 的最小值。", "inputFormat": "输入第一行两个非负整数 $n,m$，分别表示原始序列 $a$ 的长度及剩余元素的个数。\n\n之后 $m$ 行，每行 $2$ 个数 $i,a_i$，表示一个剩余元素的位置和数值。", "outputFormat": "输出一个整数表示可能的最小值。", "hint": "### 样例解释\n\n已知的 $a$ 序列为：$X,X,7,0,0$，其中 $X$ 表示这个位置丢失了。一种可能的 $a$ 序列为 $0,7,7,0,0$，对应的 $b$ 序列为 $0,7,0,0,0$，和最小为 $7$。可以证明不存在和更小的情况。\n\n::cute-table{tuack}\n\n|测试点编号|$n$|$m$|已知的 $a_i$|\n|:-:|:-:|:-:|:-:|\n|$1$|$n=2$|$m=1$|$0\\le a_i\\le 10^9$|\n|$2$|$1\\le n\\le10^9$|$m=0$|^|\n|$3$|$1\\le n\\le10^5$|$m=n$|^|\n|$4$|$1\\le n\\le5$|$0\\le m\\le n$|$0\\le a_i\\le 5$|\n|$5$|^|^|^|\n|$6$|$1\\le n\\le10^5$|^|$0\\le a_i\\le1$|\n|$7$|^|^|^|\n|$8$|^|^|$0\\le a_i\\le10$|\n|$9$|^|^|^|\n|$10$|^|^|^|\n|$11$|$1\\le n\\le10^9$|$0\\le m\\le\\min\\{n,10^5\\}$|$0\\le a_i\\le1$|\n|$12$|^|^|^|\n|$13$|^|^|$0\\le a_i\\le10$|\n|$14$|^|^|^|\n|$16$|$1\\le n\\le10^6$|^|$0\\le a_i\\le10^9$|\n|$17$|^|^|^|\n|$18$|$1\\le n\\le10^9$|^|^|\n|$19$|^|^|^|\n|$20$|^|^|^|\n\n\n\n注意未知的 $a_i$ 可以超过已知 $a_i$ 的范围。\n\n保证输入中所有的 $i$ 不同，且满足 $1 \\leq i \\leq n$。\n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/卢政荣 命题/卢政荣 验题/何昊天\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#1] Doable Problem", "background": "", "description": "qmqmqm wants to give sublinekelzrip a doable problem. So he came up with this: given a non-negative integer sequence $a_i$ of length $n$, you need to compute its prefix XOR $b_i$, defined by $b_1=a_1,b_i=b_{i-1}\\operatorname{xor}a_i(i \\geq 2)$.\n\nHowever, due to a bug in the data generator, the sequence $a$ is very long, and because of insufficient memory, some $a_i$ were lost; only the elements at $m$ positions are known. Now qmqmqm asks you to, based on the remaining $a_i$, compute the minimum possible value of $\\sum_{i=1}^n b_i$ among the $b$ sequences corresponding to all possible sequences $a$ consistent with the known entries.", "inputFormat": "The first line contains two non-negative integers $n, m$, denoting the length of the original sequence $a$ and the number of remaining known elements.\n\nThen follow $m$ lines. Each line contains two numbers $i, a_i$, indicating the position and value of a known element.", "outputFormat": "Output a single integer denoting the minimum possible value.", "hint": "### Sample Explanation\n\nThe known $a$ sequence is $X,X,7,0,0$, where $X$ means the entry is missing. One possible $a$ is $0,7,7,0,0$, whose corresponding $b$ is $0,7,0,0,0$, and the minimum sum is $7$. It can be proven that there is no smaller case.\n\n| Test point ID | $n$ | $m$ | Known $a_i$ |\n|:-:|:-:|:-:|:-:|\n| $1$ | $n=2$ | $m=1$ | $0\\le a_i\\le 10^9$ |\n| $2$ | $1\\le n\\le10^9$ | $m=0$ | ^ |\n| $3$ | $1\\le n\\le10^5$ | $m=n$ | ^ |\n| $4$ | $1\\le n\\le5$ | $0\\le m\\le n$ | $0\\le a_i\\le 5$ |\n| $5$ | ^ | ^ | ^ |\n| $6$ | $1\\le n\\le10^5$ | ^ | $0\\le a_i\\le1$ |\n| $7$ | ^ | ^ | ^ |\n| $8$ | ^ | ^ | $0\\le a_i\\le10$ |\n| $9$ | ^ | ^ | ^ |\n| $10$ | ^ | ^ | ^ |\n| $11$ | $1\\le n\\le10^9$ | $0\\le m\\le\\min\\{n,10^5\\}$ | $0\\le a_i\\le1$ |\n| $12$ | ^ | ^ | ^ |\n| $13$ | ^ | ^ | $0\\le a_i\\le10$ |\n| $14$ | ^ | ^ | ^ |\n| $16$ | $1\\le n\\le10^6$ | ^ | $0\\le a_i\\le10^9$ |\n| $17$ | ^ | ^ | ^ |\n| $18$ | $1\\le n\\le10^9$ | ^ | ^ |\n| $19$ | ^ | ^ | ^ |\n| $20$ | ^ | ^ | ^ |\n\nNote that unknown $a_i$ can exceed the range of the known $a_i$.\n\nIt is guaranteed that all $i$ in the input are distinct and satisfy $1 \\le i \\le n$.\n\nFrom CodePlus 2017 November Contest, produced with honor by the Tsinghua University Department of Computer Science and Technology Student Algorithm and Competition Association.\n\nCredit: idea/Lu Zhengrong, problem setter/Lu Zhengrong, tester/He Haotian.\n\nGit Repo: https://git.thusaac.org/publish/CodePlus201711.\n\nThanks to Tencent for supporting this contest.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#1] 可做题", "background": "", "description": "qmqmqm 希望给 sublinekelzrip 出一道可做题。于是他想到了这么一道题目：给一个长度为 $n$ 的非负整数序列 $a_i$，你需要计算其异或前缀和 $b_i$，满足条件 $b_1=a_1,b_i=b_{i-1}\\operatorname{xor}a_i(i \\geq 2)$。\n\n但是由于数据生成器出现了问题，他生成的序列 $a$ 的长度特别长，并且由于内存空间不足，一部分 $a_i$ 已经丢失了，只剩余 $m$ 个位置的元素已知。现在 qmqmqm 找到你，希望你根据剩余的 $a_i$，计算出所有可能的 $a$ 序列对应的 $b$ 序列中 $\\sum_{i=1}^n b_i$ 的最小值。", "inputFormat": "输入第一行两个非负整数 $n,m$，分别表示原始序列 $a$ 的长度及剩余元素的个数。\n\n之后 $m$ 行，每行 $2$ 个数 $i,a_i$，表示一个剩余元素的位置和数值。", "outputFormat": "输出一个整数表示可能的最小值。", "hint": "### 样例解释\n\n已知的 $a$ 序列为：$X,X,7,0,0$，其中 $X$ 表示这个位置丢失了。一种可能的 $a$ 序列为 $0,7,7,0,0$，对应的 $b$ 序列为 $0,7,0,0,0$，和最小为 $7$。可以证明不存在和更小的情况。\n\n::cute-table{tuack}\n\n|测试点编号|$n$|$m$|已知的 $a_i$|\n|:-:|:-:|:-:|:-:|\n|$1$|$n=2$|$m=1$|$0\\le a_i\\le 10^9$|\n|$2$|$1\\le n\\le10^9$|$m=0$|^|\n|$3$|$1\\le n\\le10^5$|$m=n$|^|\n|$4$|$1\\le n\\le5$|$0\\le m\\le n$|$0\\le a_i\\le 5$|\n|$5$|^|^|^|\n|$6$|$1\\le n\\le10^5$|^|$0\\le a_i\\le1$|\n|$7$|^|^|^|\n|$8$|^|^|$0\\le a_i\\le10$|\n|$9$|^|^|^|\n|$10$|^|^|^|\n|$11$|$1\\le n\\le10^9$|$0\\le m\\le\\min\\{n,10^5\\}$|$0\\le a_i\\le1$|\n|$12$|^|^|^|\n|$13$|^|^|$0\\le a_i\\le10$|\n|$14$|^|^|^|\n|$16$|$1\\le n\\le10^6$|^|$0\\le a_i\\le10^9$|\n|$17$|^|^|^|\n|$18$|$1\\le n\\le10^9$|^|^|\n|$19$|^|^|^|\n|$20$|^|^|^|\n\n\n\n注意未知的 $a_i$ 可以超过已知 $a_i$ 的范围。\n\n保证输入中所有的 $i$ 不同，且满足 $1 \\leq i \\leq n$。\n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/卢政荣 命题/卢政荣 验题/何昊天\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN"}}}
{"pid": "P4061", "type": "P", "difficulty": 6, "samples": [["7 7 1 7\n1 2 2\n2 4 2\n4 6 2\n6 7 2\n1 3 2\n3 5 4\n5 7 2", "6"], ["5 5 1 4\n1 2 1\n1 3 1\n2 4 1\n3 4 1\n4 5 1", "3"], ["6 7 1 4\n1 2 1\n1 3 1\n2 4 1\n3 4 1\n4 5 1\n1 6 2\n6 4 2", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["动态规划 DP", "图论", "O2优化", "枚举", "最短路", "Code+"], "title": "[Code+#1] 大吉大利，晚上吃鸡！", "background": "最近《绝地求生：大逃杀》风靡全球，皮皮和毛毛也迷上了这款游戏，他们经常组队玩这款游戏。\n\n在游戏中，皮皮和毛毛最喜欢做的事情就是堵桥，每每有一个好时机都能收到不少的快递。\n\n当然，有些时候并不能堵桥，皮皮和毛毛会选择在其他的必经之路上蹲点。\n\nK博士作为一个老年人，外加有心脏病，自然是不能玩这款游戏的，但是这并不能妨碍他对这款游戏进行一些理论分析，比如最近他就对皮皮和毛毛的战术很感兴趣。", "description": "游戏的地图可以抽象为一张 $n$ 个点 $m$ 条无向边的图，节点编号为 $1$ 到 $n$ ，每条边具有一个正整数的长度。\n\n\n\n**假定大魔王都会从** $S$ **点出发到达** $T$ **点（** $S$ **和** $T$ **已知），并且只会走最短路** ，皮皮和毛毛会在 $A$ 点和 $B$ 点埋伏大魔王。\n\n为了保证一定能埋伏到大魔王，同时又想留大魔王一条生路，皮皮和毛毛约定 $A$ 点和 $B$ 点必须满足：\n\n- 大魔王所有可能路径中，必定会经过 $A$ 点和 $B$ 点中的任意一点\n\n- 大魔王所有可能路径中，不存在一条路径同时经过 $A$ 点和 $B$ 点\n\nK博士想知道，满足上面两个条件的 $A,B$ 点对有多少个，交换 $A,B$ 的顺序算相同的方案。", "inputFormat": "第一行输入四个整数 $n,m,S,T(1 \\le n \\le 5 \\times 10^{4}, 1 \\le m \\le 5 \\times 10^{4}, 1 \\le S,T \\le n)$ ，含义见题目描述。\n\n接下来输入 $m$ 行，每行输入三个整数 $u,v,w(1 \\le u,v \\le n, 1 \\le w \\le 10^{9})$ 表示存在一条长度为 $w$ 的边链接 $u$ 和 $v$ 。", "outputFormat": "输出一行表示答案。", "hint": "### 样例1解释\n\n合法的方案为$<2,3>,<2,4>,<4,3>,<4,5>,<6,3>,<6,5>$ 。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12824.png) \n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/陈宇 命题/陈宇 验题/邢健开\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#1] Winner Winner, Chicken Dinner Tonight!", "background": "Recently, PlayerUnknown’s Battlegrounds (PUBG) has taken the world by storm. Pipi and Maomao have become obsessed with the game and often team up to play.\n\nIn the game, their favorite tactic is camping at bridges, where they can often secure lots of loot when the timing is right.\n\nOf course, sometimes camping a bridge isn’t possible, so Pipi and Maomao will instead camp on other chokepoints.\n\nDr. K, being older and having a heart condition, naturally can’t play this game, but that doesn’t stop him from doing some theoretical analysis. Lately, he has been very interested in Pipi and Maomao’s tactics.", "description": "The game map can be abstracted as an undirected graph with $n$ nodes and $m$ edges, numbered from $1$ to $n$. Each edge has a positive integer length.\n\nAssume the “Da Mowang” will start from $S$ and reach $T$ (both $S$ and $T$ are known), and will only take shortest paths. Pipi and Maomao will ambush at points $A$ and $B$.\n\nTo ensure they can always ambush the Da Mowang while still leaving him a way out, $A$ and $B$ must satisfy:\n\n- Among all possible shortest paths, the Da Mowang must pass through at least one of $A$ or $B$.\n- Among all possible shortest paths, there does not exist a path that passes through both $A$ and $B$.\n\nDr. K wants to know how many pairs $(A, B)$ satisfy the two conditions above. Swapping $A$ and $B$ counts as the same plan.", "inputFormat": "The first line contains four integers $n, m, S, T$ $(1 \\le n \\le 5 \\times 10^{4}, 1 \\le m \\le 5 \\times 10^{4}, 1 \\le S, T \\le n)$, as described above.\n\nThe next $m$ lines each contain three integers $u, v, w$ $(1 \\le u, v \\le n, 1 \\le w \\le 10^{9})$, indicating there is an edge of length $w$ connecting $u$ and $v$.", "outputFormat": "Output a single line containing the answer.", "hint": "Explanation for Sample 1:\n\nThe valid pairs are $<2,3>,<2,4>,<4,3>,<4,5>,<6,3>,<6,5>$.\n\n![](https://cdn.luogu.com.cn/upload/pic/12824.png)\n\nFrom CodePlus November 2017, proudly presented by the Tsinghua University Student Association of Computer Science and Technology Algorithms and Programming Contest.\n\nCredit: idea/Chen Yu, problem setting/Chen Yu, verification/Xing Jiankai.\n\nGit Repo: https://git.thusaac.org/publish/CodePlus201711\n\nThanks to Tencent for supporting this contest.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#1] 大吉大利，晚上吃鸡！", "background": "最近《绝地求生：大逃杀》风靡全球，皮皮和毛毛也迷上了这款游戏，他们经常组队玩这款游戏。\n\n在游戏中，皮皮和毛毛最喜欢做的事情就是堵桥，每每有一个好时机都能收到不少的快递。\n\n当然，有些时候并不能堵桥，皮皮和毛毛会选择在其他的必经之路上蹲点。\n\nK博士作为一个老年人，外加有心脏病，自然是不能玩这款游戏的，但是这并不能妨碍他对这款游戏进行一些理论分析，比如最近他就对皮皮和毛毛的战术很感兴趣。", "description": "游戏的地图可以抽象为一张 $n$ 个点 $m$ 条无向边的图，节点编号为 $1$ 到 $n$ ，每条边具有一个正整数的长度。\n\n\n\n**假定大魔王都会从** $S$ **点出发到达** $T$ **点（** $S$ **和** $T$ **已知），并且只会走最短路** ，皮皮和毛毛会在 $A$ 点和 $B$ 点埋伏大魔王。\n\n为了保证一定能埋伏到大魔王，同时又想留大魔王一条生路，皮皮和毛毛约定 $A$ 点和 $B$ 点必须满足：\n\n- 大魔王所有可能路径中，必定会经过 $A$ 点和 $B$ 点中的任意一点\n\n- 大魔王所有可能路径中，不存在一条路径同时经过 $A$ 点和 $B$ 点\n\nK博士想知道，满足上面两个条件的 $A,B$ 点对有多少个，交换 $A,B$ 的顺序算相同的方案。", "inputFormat": "第一行输入四个整数 $n,m,S,T(1 \\le n \\le 5 \\times 10^{4}, 1 \\le m \\le 5 \\times 10^{4}, 1 \\le S,T \\le n)$ ，含义见题目描述。\n\n接下来输入 $m$ 行，每行输入三个整数 $u,v,w(1 \\le u,v \\le n, 1 \\le w \\le 10^{9})$ 表示存在一条长度为 $w$ 的边链接 $u$ 和 $v$ 。", "outputFormat": "输出一行表示答案。", "hint": "### 样例1解释\n\n合法的方案为$<2,3>,<2,4>,<4,3>,<4,5>,<6,3>,<6,5>$ 。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12824.png) \n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/陈宇 命题/陈宇 验题/邢健开\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN"}}}
{"pid": "P4062", "type": "P", "difficulty": 6, "samples": [["5 0\n1 1 2 2 3", "10"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["线段树", "递归", "O2优化", "前缀和", "根号分治", "Code+"], "title": "[Code+#1] Yazid 的新生舞会", "background": "这道题是没有舞伴的 Yazid 用新生舞会的时间出的。\n", "description": "Yazid 有一个长度为 $n$ 的序列 $A$，下标从 $1$ 至 $n$。显然地，这个序列共有 $\\frac{n\\left( n+1\\right)}{2}$ 个子区间。\n\n对于任意一个子区间 $[l,r]$，如果该子区间内的众数在该子区间的出现次数严格大于 $\\frac{r-l+1}{2}$（即该子区间长度的一半），那么 Yazid 就说这个子区间是“新生舞会的”。\n\n所谓众数，即为该子区间内出现次数最多的数。特别地，如果出现次数最多的数有多个，我们规定值最小的数为众数。\n\n现在，Yazid 想知道，共有多少个子区间是“新生舞会的”。\n", "inputFormat": "第一行两个用空格隔开的非负整数 $n, type$，表示序列的长度和**数据类型**。数据类型的作用将在「子任务」中说明。\n\n第二行 $n$ 个用空格隔开的非负整数，依次为 $A_1,A_2,...,A_n$，描述这个序列。\n", "outputFormat": "输出一行一个整数，表示答案。\n", "hint": "**【样例解释 #1】**\n\n“新生舞会的”子区间有 $[1,1],[1,2],[1,3],[2,2],[2,4],[3,3],[3,4],[3,5],[4,4],[5,5]$ 共 $10$ 个。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12825.png) \n\n对于所有数据，保证 $0\\leq A_i\\leq n-1$。\n\n对于 $type=0$ 的数据，没有任何特殊约定。\n\n对于 $type=1$ 的数据，保证 $A_i\\in \\{ 0, 1 \\}$。\n\n对于 $type=2$ 的数据，保证序列 $A$ 的众数在整个序列中的出现次数不超过 $15$。\n\n对于 $type=3$ 的数据，保证 $A_i\\leq 7$。\n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/郑林楷 命题/王聿中 验题/郑林楷\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#1] Yazid's Freshman Ball", "background": "This problem was created by Yazid during the time of the freshman ball, when he had no dance partner.", "description": "Yazid has a sequence $A$ of length $n$, indexed from $1$ to $n$. Obviously, this sequence has $\\frac{n\\left( n+1\\right)}{2}$ subarrays.\n\nFor any subarray $[l,r]$, if the mode in this subarray has a frequency strictly greater than $\\frac{r-l+1}{2}$ (that is, more than half of the subarray's length), then Yazid calls this subarray \"Freshman Ball\".\n\nThe mode is the value that appears most frequently in the subarray. In particular, if multiple values tie for the highest frequency, we define the smallest value as the mode.\n\nNow Yazid wants to know how many subarrays are \"Freshman Ball\".", "inputFormat": "The first line contains two space-separated nonnegative integers $n, type$, representing the length of the sequence and the data type. The role of the data type will be explained in the Hint.\n\nThe second line contains $n$ space-separated nonnegative integers, namely $A_1, A_2, ..., A_n$, describing the sequence.", "outputFormat": "Output a single integer on one line, representing the answer.", "hint": "【Sample Explanation #1】\n\nThe \"Freshman Ball\" subarrays are $[1,1],[1,2],[1,3],[2,2],[2,4],[3,3],[3,4],[3,5],[4,4],[5,5]$, for a total of $10$.\n\n ![](https://cdn.luogu.com.cn/upload/pic/12825.png) \n\nConstraints:\n\nFor all testdata, it is guaranteed that $0\\leq A_i\\leq n-1$.\n\nFor $type=0$ testdata, there is no special stipulation.\n\nFor $type=1$ testdata, it is guaranteed that $A_i\\in \\{ 0, 1 \\}$.\n\nFor $type=2$ testdata, it is guaranteed that the mode of sequence $A$ appears at most $15$ times in the entire sequence.\n\nFor $type=3$ testdata, it is guaranteed that $A_i\\leq 7$.\n\nFrom CodePlus 2017 November Contest, produced by the Student Algorithms and Competitions Association, Department of Computer Science and Technology, Tsinghua University.\n\nCredit: idea/Zheng Linkai, problem setting/Wang Yuzhong, problem checking/Zheng Linkai.\n\nGit Repo: https://git.thusaac.org/publish/CodePlus201711\n\nThanks to Tencent for supporting this contest.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#1] Yazid 的新生舞会", "background": "这道题是没有舞伴的 Yazid 用新生舞会的时间出的。\n", "description": "Yazid 有一个长度为 $n$ 的序列 $A$，下标从 $1$ 至 $n$。显然地，这个序列共有 $\\frac{n\\left( n+1\\right)}{2}$ 个子区间。\n\n对于任意一个子区间 $[l,r]$，如果该子区间内的众数在该子区间的出现次数严格大于 $\\frac{r-l+1}{2}$（即该子区间长度的一半），那么 Yazid 就说这个子区间是“新生舞会的”。\n\n所谓众数，即为该子区间内出现次数最多的数。特别地，如果出现次数最多的数有多个，我们规定值最小的数为众数。\n\n现在，Yazid 想知道，共有多少个子区间是“新生舞会的”。\n", "inputFormat": "第一行两个用空格隔开的非负整数 $n, type$，表示序列的长度和**数据类型**。数据类型的作用将在「子任务」中说明。\n\n第二行 $n$ 个用空格隔开的非负整数，依次为 $A_1,A_2,...,A_n$，描述这个序列。\n", "outputFormat": "输出一行一个整数，表示答案。\n", "hint": "**【样例解释 #1】**\n\n“新生舞会的”子区间有 $[1,1],[1,2],[1,3],[2,2],[2,4],[3,3],[3,4],[3,5],[4,4],[5,5]$ 共 $10$ 个。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12825.png) \n\n对于所有数据，保证 $0\\leq A_i\\leq n-1$。\n\n对于 $type=0$ 的数据，没有任何特殊约定。\n\n对于 $type=1$ 的数据，保证 $A_i\\in \\{ 0, 1 \\}$。\n\n对于 $type=2$ 的数据，保证序列 $A$ 的众数在整个序列中的出现次数不超过 $15$。\n\n对于 $type=3$ 的数据，保证 $A_i\\leq 7$。\n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/郑林楷 命题/王聿中 验题/郑林楷\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。\n", "locale": "zh-CN"}}}
{"pid": "P4063", "type": "P", "difficulty": 6, "samples": [["3\n2 2 2", "6"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "各省省选", "江西"], "title": "[JXOI2017] 数列", "background": null, "description": "九条可怜手上有一个长度为 $n$ 的整数数列 $r_i$，她现在想要构造一个长度为 $n$ 的，满足如下条件的整数数列 $A$ ：\n\n- $1 \\le A_i \\le r_i$\n\n- 对于任意 $3 \\le i \\le n$ ，令 $R$ 为 $A_1$ 至 $A_{i-2}$ 中大于等于 $A_{i-1}$ 的最小值，$L$ 为 $A_1$ 至 $A_{i-2}$ 中小于等于 $A_{i-1}$ 的最大值。$A_i$ 必须满足 $L \\le A_i \\le R$ 。如果不存在大于等于 $A_{i-1}$ 的，那么 $R=+\\infty$ ；如果不存在小于等于 $A_{i-1} $ 的，那么 $L = -\\infty$ 。\n\n现在可怜想要知道共有多少不同的数列满足这个条件。两个数列 $A$ 和 $B$ 是不同的当且仅当至少存在一个位置 $i$ 满足 $A_i \\neq B_i$ 。", "inputFormat": "第一行输入一个整数 $n$ ，第二行输入 $n$ 个整数 $r_i$。", "outputFormat": "输出一个整数表示方案数，答案可能很大，对 $998244353$ 取模后输出。\n## 说明\n满足条件的序列有 $[1, 1, 1], [1, 2, 1], [1, 2, 2], [2, 1, 1], [2, 1, 2], [2, 2, 2]$", "hint": "| 测试点编号 | $n$ | $r_i$ |\n| :----------: | :----------: | :----------: |\n| $1,2$ | $n\\le7$ | $r_i\\le7$ |\n| $3,4$ | $n\\le50$ | $r_i\\le10$ |\n| $5,6$ | $n\\le50$ | $r_i\\le16$ |\n| $7,8$ | $n\\le50$ | $r_i\\le50$ |\n| $9,10$ | $n\\le50$ | $r_i\\le150$ |", "locale": "zh-CN", "translations": {"en": {"title": "[JXOI2017] Sequence", "background": "", "description": "Jiutiao Kelian (pinyin) has an integer sequence $r_i$ of length $n$. She now wants to construct an integer sequence $A$ of length $n$ that satisfies the following:\n\n- $1 \\le A_i \\le r_i$.\n\n- For any $3 \\le i \\le n$, let $R$ be the minimum among $A_1$ through $A_{i-2}$ that are greater than or equal to $A_{i-1}$, and let $L$ be the maximum among $A_1$ through $A_{i-2}$ that are less than or equal to $A_{i-1}$. Then $A_i$ must satisfy $L \\le A_i \\le R$. If there is no number greater than or equal to $A_{i-1}$, then $R = +\\infty$; if there is no number less than or equal to $A_{i-1}$, then $L = -\\infty$.\n\nNow she wants to know how many different sequences satisfy these conditions. Two sequences $A$ and $B$ are different if and only if there exists at least one position $i$ such that $A_i \\ne B_i$.", "inputFormat": "The first line contains an integer $n$, and the second line contains $n$ integers $r_i$.", "outputFormat": "Output a single integer denoting the number of valid sequences. The answer can be large; output it modulo $998244353$.", "hint": "For example, when $n = 3$ and $r_i = 2$ for all $i$, the valid sequences are $[1, 1, 1], [1, 2, 1], [1, 2, 2], [2, 1, 1], [2, 1, 2], [2, 2, 2]$.\n\nConstraints:\n\n| Test point ID | $n$ | $r_i$ |\n| :----------: | :----------: | :----------: |\n| $1, 2$ | $n \\le 7$ | $r_i \\le 7$ |\n| $3, 4$ | $n \\le 50$ | $r_i \\le 10$ |\n| $5, 6$ | $n \\le 50$ | $r_i \\le 16$ |\n| $7, 8$ | $n \\le 50$ | $r_i \\le 50$ |\n| $9, 10$ | $n \\le 50$ | $r_i \\le 150$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JXOI2017] 数列", "background": null, "description": "九条可怜手上有一个长度为 $n$ 的整数数列 $r_i$，她现在想要构造一个长度为 $n$ 的，满足如下条件的整数数列 $A$ ：\n\n- $1 \\le A_i \\le r_i$\n\n- 对于任意 $3 \\le i \\le n$ ，令 $R$ 为 $A_1$ 至 $A_{i-2}$ 中大于等于 $A_{i-1}$ 的最小值，$L$ 为 $A_1$ 至 $A_{i-2}$ 中小于等于 $A_{i-1}$ 的最大值。$A_i$ 必须满足 $L \\le A_i \\le R$ 。如果不存在大于等于 $A_{i-1}$ 的，那么 $R=+\\infty$ ；如果不存在小于等于 $A_{i-1} $ 的，那么 $L = -\\infty$ 。\n\n现在可怜想要知道共有多少不同的数列满足这个条件。两个数列 $A$ 和 $B$ 是不同的当且仅当至少存在一个位置 $i$ 满足 $A_i \\neq B_i$ 。", "inputFormat": "第一行输入一个整数 $n$ ，第二行输入 $n$ 个整数 $r_i$。", "outputFormat": "输出一个整数表示方案数，答案可能很大，对 $998244353$ 取模后输出。\n## 说明\n满足条件的序列有 $[1, 1, 1], [1, 2, 1], [1, 2, 2], [2, 1, 1], [2, 1, 2], [2, 2, 2]$", "hint": "| 测试点编号 | $n$ | $r_i$ |\n| :----------: | :----------: | :----------: |\n| $1,2$ | $n\\le7$ | $r_i\\le7$ |\n| $3,4$ | $n\\le50$ | $r_i\\le10$ |\n| $5,6$ | $n\\le50$ | $r_i\\le16$ |\n| $7,8$ | $n\\le50$ | $r_i\\le50$ |\n| $9,10$ | $n\\le50$ | $r_i\\le150$ |", "locale": "zh-CN"}}}
{"pid": "P4064", "type": "P", "difficulty": 5, "samples": [["1 \n3 3 2 1\n1 3 2\n1 1\n1 3\n3 3", "3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["贪心", "2017", "二分", "各省省选", "树状数组", "优先队列", "江西"], "title": "[JXOI2017] 加法", "background": "", "description": "可怜有一个长度为 $n$ 的正整数序列 $A$，但是她觉得 $A$ 中的数字太小了，这让她很不开心。\n\n于是她选择了 $m$ 个区间 $[l_i,r_i]$ 和两个正整数 $a,k$。她打算从这 $m$ 个区间里选出恰好 $k$ 个区间，并对每个区间执行一次区间加 $a$ 的操作。（每个区间最多只能选择一次）。\n\n对区间 $[l,r]$ 进行一次加 $a$ 操作可以定义为对于所有 $i$ ∈ $[l,r]$，将 $A_i$ 变成 $A_i+a$。现在可怜想要知道怎么选择区间才能让操作后的序列的最小值尽可能的大，即最大化 $\\min\\{A_i\\}$。", "inputFormat": "第一行输入一个整数表示数据组数。\n\n对于每组数据第一行输入四个整数 $n,m,k,a$。\n\n第二行输入 $n$ 个整数描述序列 $A$。\n\n接下来 $m$ 行每行两个整数 $l_i,r_i$ 描述每一个区间。数据保证所有区间两两不同。", "outputFormat": "对于每组数据输出一个整数表示操作后序列最小值的最大值。\n", "hint": "选择给区间 $[1,1]$ 和 $[1,3]$ 加 $1$。\n\n对于 $100\\%$ 的数据，保证 $1\\leq\\sum n,\\sum m\\leq 2\\times 10^5$，$1\\leq T\\leq 2\\times 10^5$，$1\\le k\\le m$，$1\\le a\\le 100$，$1\\le A_i\\le 10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "[JXOI2017] Addition", "background": "", "description": "Kelian has a positive integer sequence $A$ of length $n$, but she feels the numbers in $A$ are too small, which makes her unhappy.\n\nSo she chooses $m$ intervals $[l_i,r_i]$ and two positive integers $a,k$. She plans to select exactly $k$ intervals from these $m$ intervals, and perform one range add $a$ operation on each selected interval. (Each interval can be selected at most once).\n\nPerforming a +$a$ operation on a range $[l,r]$ is defined as: for all $i$ ∈ $[l,r]$, set $A_i$ to $A_i+a$. Now Kelian wants to know how to choose the intervals so that the minimum value of the sequence after the operations is as large as possible, i.e., maximize $\\min\\{A_i\\}$.", "inputFormat": "The first line contains an integer indicating the number of test cases.\n\nFor each test case, the first line contains four integers $n,m,k,a$.\n\nThe second line contains $n$ integers describing the sequence $A$.\n\nThe next $m$ lines each contain two integers $l_i,r_i$ describing each interval. It is guaranteed that all intervals are pairwise distinct.", "outputFormat": "For each test case, output one integer representing the maximum possible minimum value of the sequence after the operations.", "hint": "Choose to add $1$ to intervals $[1,1]$ and $[1,3]$.\n\nFor $100\\%$ of the testdata, it is guaranteed that $1\\leq\\sum n,\\sum m\\leq 2\\times 10^5$, $1\\leq T\\leq 2\\times 10^5$, $1\\le k\\le m$, $1\\le a\\le 100$, $1\\le A_i\\le 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JXOI2017] 加法", "background": "", "description": "可怜有一个长度为 $n$ 的正整数序列 $A$，但是她觉得 $A$ 中的数字太小了，这让她很不开心。\n\n于是她选择了 $m$ 个区间 $[l_i,r_i]$ 和两个正整数 $a,k$。她打算从这 $m$ 个区间里选出恰好 $k$ 个区间，并对每个区间执行一次区间加 $a$ 的操作。（每个区间最多只能选择一次）。\n\n对区间 $[l,r]$ 进行一次加 $a$ 操作可以定义为对于所有 $i$ ∈ $[l,r]$，将 $A_i$ 变成 $A_i+a$。现在可怜想要知道怎么选择区间才能让操作后的序列的最小值尽可能的大，即最大化 $\\min\\{A_i\\}$。", "inputFormat": "第一行输入一个整数表示数据组数。\n\n对于每组数据第一行输入四个整数 $n,m,k,a$。\n\n第二行输入 $n$ 个整数描述序列 $A$。\n\n接下来 $m$ 行每行两个整数 $l_i,r_i$ 描述每一个区间。数据保证所有区间两两不同。", "outputFormat": "对于每组数据输出一个整数表示操作后序列最小值的最大值。\n", "hint": "选择给区间 $[1,1]$ 和 $[1,3]$ 加 $1$。\n\n对于 $100\\%$ 的数据，保证 $1\\leq\\sum n,\\sum m\\leq 2\\times 10^5$，$1\\leq T\\leq 2\\times 10^5$，$1\\le k\\le m$，$1\\le a\\le 100$，$1\\le A_i\\le 10^8$。", "locale": "zh-CN"}}}
{"pid": "P4065", "type": "P", "difficulty": 6, "samples": [["1\n5\n1 3 2 4 3", "6"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "线段树", "各省省选", "枚举", "江西", "哈希 hashing", "随机化"], "title": "[JXOI2017] 颜色", "background": "", "description": "可怜有一个长度为 $n$ 的正整数序列 $A_i$，其中相同的正整数代表着相同的颜色。\n\n现在可怜觉得这个序列太长了，于是她决定选择一些颜色把这些颜色的所有位置都删去。\n\n删除颜色 $i$ 可以定义为把所有满足 $A_j = i$ 的位置 $j$ 都从序列中删去。\n\n然而有些时候删去之后，整个序列变成了好几段，可怜不喜欢这样，于是她想要知道有多少种删去颜色的方案使得最后剩下来的序列非空且连续。\n\n例如颜色序列 $\\{1, 2, 3, 4, 5\\}$，删除颜色 $3$ 后序列变成了 $\\{1, 2\\}$ 和 $\\{4, 5\\}$ 两段，不满足条件。而删除颜色 $1$ 后序列变成了 $\\{2, 3, 4, 5\\}$，满足条件。\n\n两个方案不同当且仅当至少存在一个颜色 $i$ 只在其中一个方案中被删去。\n", "inputFormat": "第一行输入一个整数 $T$ 表示数据组数。\n\n每组数据第一行，输入一个整数 $n$ 表示数列长度；第二行输入 $n$ 个整数描述颜色序列。\n", "outputFormat": "对于每组数据输出一个整数表示答案。", "hint": "满足条件的删颜色方案有 $\\{1\\}, \\{1, 3\\}, \\{1, 2, 3\\}, \\{1, 3, 4\\}, \\{2, 3, 4\\}, \\varnothing$。\n\n对于 $20\\%$ 的数据，保证 $1 \\le \\sum n \\le  20$。\n\n对于 $40\\%$ 的数据，保证 $1 \\le \\sum n \\le  500$。\n\n对于 $60\\%$ 的数据，保证 $1 \\le \\sum n \\le  10^4$。\n\n对于 $100\\%$ 的数据，保证 $1 \\le  T,\\sum n \\le  3 \\times 10^5, 1 \\le  A_i \\le  n$。\n\n$\\text{Statement fixed by @Starrykiller.}$", "locale": "zh-CN", "translations": {"en": {"title": "[JXOI2017] Colors", "background": "", "description": "Kelian has a sequence of positive integers of length $n$, denoted by $A_i$, where equal integers represent the same color.\n\nKelian thinks the sequence is too long, so she decides to choose some colors and delete all positions of those colors.\n\nDeleting color $i$ is defined as removing from the sequence all positions $j$ such that $A_j = i$.\n\nHowever, sometimes after deletions, the entire sequence breaks into several segments. Kelian does not like that, so she wants to know how many ways to delete colors will make the remaining sequence non-empty and contiguous.\n\nFor example, for the color sequence $\\{1, 2, 3, 4, 5\\}$, after deleting color $3$, the sequence becomes two segments $\\{1, 2\\}$ and $\\{4, 5\\}$, which does not satisfy the requirement. After deleting color $1$, the sequence becomes $\\{2, 3, 4, 5\\}$, which satisfies the requirement.\n\nTwo schemes are different if and only if there exists at least one color $i$ that is deleted in exactly one of them.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nFor each test case, the first line contains an integer $n$, the length of the sequence; the second line contains $n$ integers describing the color sequence.", "outputFormat": "For each test case, output a single integer denoting the answer.", "hint": "The valid deletion schemes are $\\{1\\}, \\{1, 3\\}, \\{1, 2, 3\\}, \\{1, 3, 4\\}, \\{2, 3, 4\\}, \\varnothing$.\n\nFor $20\\%$ of the testdata, it is guaranteed that $1 \\le \\sum n \\le 20$.\n\nFor $40\\%$ of the testdata, it is guaranteed that $1 \\le \\sum n \\le 500$.\n\nFor $60\\%$ of the testdata, it is guaranteed that $1 \\le \\sum n \\le 10^4$.\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\le T, \\sum n \\le 3 \\times 10^5, 1 \\le A_i \\le n$.\n\n$\\text{Statement fixed by @Starrykiller.}$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JXOI2017] 颜色", "background": "", "description": "可怜有一个长度为 $n$ 的正整数序列 $A_i$，其中相同的正整数代表着相同的颜色。\n\n现在可怜觉得这个序列太长了，于是她决定选择一些颜色把这些颜色的所有位置都删去。\n\n删除颜色 $i$ 可以定义为把所有满足 $A_j = i$ 的位置 $j$ 都从序列中删去。\n\n然而有些时候删去之后，整个序列变成了好几段，可怜不喜欢这样，于是她想要知道有多少种删去颜色的方案使得最后剩下来的序列非空且连续。\n\n例如颜色序列 $\\{1, 2, 3, 4, 5\\}$，删除颜色 $3$ 后序列变成了 $\\{1, 2\\}$ 和 $\\{4, 5\\}$ 两段，不满足条件。而删除颜色 $1$ 后序列变成了 $\\{2, 3, 4, 5\\}$，满足条件。\n\n两个方案不同当且仅当至少存在一个颜色 $i$ 只在其中一个方案中被删去。\n", "inputFormat": "第一行输入一个整数 $T$ 表示数据组数。\n\n每组数据第一行，输入一个整数 $n$ 表示数列长度；第二行输入 $n$ 个整数描述颜色序列。\n", "outputFormat": "对于每组数据输出一个整数表示答案。", "hint": "满足条件的删颜色方案有 $\\{1\\}, \\{1, 3\\}, \\{1, 2, 3\\}, \\{1, 3, 4\\}, \\{2, 3, 4\\}, \\varnothing$。\n\n对于 $20\\%$ 的数据，保证 $1 \\le \\sum n \\le  20$。\n\n对于 $40\\%$ 的数据，保证 $1 \\le \\sum n \\le  500$。\n\n对于 $60\\%$ 的数据，保证 $1 \\le \\sum n \\le  10^4$。\n\n对于 $100\\%$ 的数据，保证 $1 \\le  T,\\sum n \\le  3 \\times 10^5, 1 \\le  A_i \\le  n$。\n\n$\\text{Statement fixed by @Starrykiller.}$", "locale": "zh-CN"}}}
{"pid": "P4066", "type": "P", "difficulty": 6, "samples": [["8 \n8 1 \n1 5\n5 7 \n2 2 \n7 8 \n4 6 \n3 3 \n6 4", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2003", "各省省选", "上海", "剪枝"], "title": "[SHOI2003] 吃豆豆", "background": "", "description": "两个 PACMAN 吃豆豆。一开始的时候，PACMAN 都在坐标原点的左下方，豆豆都在右上方。PACMAN 走到豆豆处就会吃掉它。  \nPACMAN 行走的路线很奇怪，只能向右走或者向上走，他们行走的路线可以有交点但不能互相穿过。  \n请你帮这两个 PACMAN 计算一下，他们俩加起来最多能吃掉多少豆豆。\n", "inputFormat": "第一行为一个整数 $N$，表示豆豆的数目。 接下来 $N$ 行，每行一对正整数，表示第 $i$ 个豆豆的坐标。任意两个豆豆的坐标都不会重合。\n", "outputFormat": "仅有一行包含一个整数，即两个 PACMAN 加起来最多能吃掉的豆豆数量\n", "hint": "对于 $100\\%$ 的数据，$N \\leq 2000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2003] Eating Beans", "background": "", "description": "Two PACMAN eat beans. At the beginning, both PACMAN are to the lower-left of the origin, and all beans are to the upper-right. A PACMAN eats a bean when it reaches its location.\nThe PACMAN move in a strange way: they can only move right or up. Their paths may have intersection points but cannot cross each other.\nPlease help the two PACMAN compute the maximum total number of beans they can eat together.", "inputFormat": "The first line contains an integer $N$, denoting the number of beans. The next $N$ lines each contain a pair of positive integers, representing the coordinates of the $i$-th bean. The coordinates of any two beans are distinct.", "outputFormat": "Output a single line containing one integer: the maximum total number of beans the two PACMAN can eat.", "hint": "For 100% of the testdata, $N \\leq 2000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2003] 吃豆豆", "background": "", "description": "两个 PACMAN 吃豆豆。一开始的时候，PACMAN 都在坐标原点的左下方，豆豆都在右上方。PACMAN 走到豆豆处就会吃掉它。  \nPACMAN 行走的路线很奇怪，只能向右走或者向上走，他们行走的路线可以有交点但不能互相穿过。  \n请你帮这两个 PACMAN 计算一下，他们俩加起来最多能吃掉多少豆豆。\n", "inputFormat": "第一行为一个整数 $N$，表示豆豆的数目。 接下来 $N$ 行，每行一对正整数，表示第 $i$ 个豆豆的坐标。任意两个豆豆的坐标都不会重合。\n", "outputFormat": "仅有一行包含一个整数，即两个 PACMAN 加起来最多能吃掉的豆豆数量\n", "hint": "对于 $100\\%$ 的数据，$N \\leq 2000$。", "locale": "zh-CN"}}}
{"pid": "P4067", "type": "P", "difficulty": 6, "samples": [["3\n2 2 0 100\n3 3 0 100\n3 3 1 100", "2\n12\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "各省省选", "山东", "数位 DP"], "title": "[SDOI2016] 储能表", "background": "", "description": "有一个 $n$ 行 $m$ 列的表格，**行从 $0$ 到 $n-1$ 编号，列从 $0$ 到 $m-1$ 编号**。每个格子都储存着能量。最初，第 $i$ 行第 $j$ 列的格子储存着 $(i \\oplus j)$ 点能量（$\\oplus$ 表示**按位异或**）。所以，整个表格储存的总能量是\n\n$$\\sum_{i=0}^{n-1} \\sum_{j=0}^{m-1} i \\oplus j$$\n\n随着时间的推移，格子中的能量会渐渐减少。每经过一个时间单位，每个格子中的能量都会减少 $1$。显然，**一个格子的能量减少到 $0$ 之后就不会再减少了。**\n\n也就是说，$k$ 个时间单位后，整个表格储存的总能量是\n\n$$\\sum_{i=0}^{n-1} \\sum_{j=0}^{m-1} \\max((i \\oplus j)-k,0)$$\n\n给出一个表格，求 $k$ 个时间单位后它储存的总能量。\n\n由于总能量可能较大，输出时对 $p$ 取模。", "inputFormat": "第一行一个整数 $T$，表示数据组数。接下来 $T$ 行，每行四个整数 $n,m,k,p$。\n", "outputFormat": "共 $T$ 行，每行一个数，表示总能量对 $p$ 取模后的结果。\n", "hint": "对于 $100\\%$ 的数据，保证 $1\\le T\\le 5000$，$1\\le p\\le 10^9$，$1\\le n,m\\le 10^{18}，0\\le k\\le 10^{18}$。\n\n| 测试点编号 | $T=$ | $n\\le$ | $m\\le$ | $k\\le$ | $p\\le$ |\n| :--: | :--: | :--: | :--: | :--: | :--: |\n| $1,2$ | $5000$ | $100$ | $100$ | $100$ | $10^9$ |\n| $3$ | $5000$ | $10^{18}$ | $10^{18}$ | $0$ | $10^9$ |\n| $4$ | $5000$ | $10^{18}$ | $10^{18}$ | $1$ | $10^9$ |\n| $5$ | $5000$ | $10$ | $10^{18}$ | $10$ | $10^9$ |\n| $6$ | $1$ | $10^5$ | $10^{18}$ | $10^5$ | $10^9$ |\n| $7$ | $1$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |\n| $8$ | $100$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |\n| $9,10$ | $5000$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |\n\n$\\texttt{Statement fixed by Starrykiller.}$", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] Energy Storage Table", "background": "", "description": "There is a table with $n$ rows and $m$ columns, with rows numbered from $0$ to $n-1$ and columns numbered from $0$ to $m-1$. Each cell stores energy. Initially, the cell in row $i$ and column $j$ stores $(i \\oplus j)$ units of energy (where $\\oplus$ denotes bitwise XOR). Therefore, the total energy stored in the whole table is\n$$\\sum_{i=0}^{n-1} \\sum_{j=0}^{m-1} i \\oplus j.$$\n\nAs time passes, the energy in the cells gradually decreases. After each unit of time, the energy in every cell decreases by $1$. Obviously, once a cell’s energy decreases to $0$, it will not decrease any further.\n\nThat is, after $k$ units of time, the total energy stored in the whole table is\n$$\\sum_{i=0}^{n-1} \\sum_{j=0}^{m-1} \\max((i \\oplus j)-k,0).$$\n\nGiven the table, find the total energy it stores after $k$ units of time.\n\nSince the total energy may be large, output it modulo $p$.", "inputFormat": "The first line contains an integer $T$, the number of test cases. Then $T$ lines follow, each containing four integers $n, m, k, p$.", "outputFormat": "Output $T$ lines, each containing one number: the result of the total energy modulo $p$.", "hint": "For $100\\%$ of the testdata, it is guaranteed that $1 \\le T \\le 5000$, $1 \\le p \\le 10^9$, $1 \\le n,m \\le 10^{18}$, $0 \\le k \\le 10^{18}$.\n\n| 测试点编号 | $T=$ | $n\\le$ | $m\\le$ | $k\\le$ | $p\\le$ |\n| :--: | :--: | :--: | :--: | :--: | :--: |\n| $1,2$ | $5000$ | $100$ | $100$ | $100$ | $10^9$ |\n| $3$ | $5000$ | $10^{18}$ | $10^{18}$ | $0$ | $10^9$ |\n| $4$ | $5000$ | $10^{18}$ | $10^{18}$ | $1$ | $10^9$ |\n| $5$ | $5000$ | $10$ | $10^{18}$ | $10$ | $10^9$ |\n| $6$ | $1$ | $10^5$ | $10^{18}$ | $10^5$ | $10^9$ |\n| $7$ | $1$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |\n| $8$ | $100$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |\n| $9,10$ | $5000$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |\n\n$\\texttt{Statement fixed by Starrykiller.}$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 储能表", "background": "", "description": "有一个 $n$ 行 $m$ 列的表格，**行从 $0$ 到 $n-1$ 编号，列从 $0$ 到 $m-1$ 编号**。每个格子都储存着能量。最初，第 $i$ 行第 $j$ 列的格子储存着 $(i \\oplus j)$ 点能量（$\\oplus$ 表示**按位异或**）。所以，整个表格储存的总能量是\n\n$$\\sum_{i=0}^{n-1} \\sum_{j=0}^{m-1} i \\oplus j$$\n\n随着时间的推移，格子中的能量会渐渐减少。每经过一个时间单位，每个格子中的能量都会减少 $1$。显然，**一个格子的能量减少到 $0$ 之后就不会再减少了。**\n\n也就是说，$k$ 个时间单位后，整个表格储存的总能量是\n\n$$\\sum_{i=0}^{n-1} \\sum_{j=0}^{m-1} \\max((i \\oplus j)-k,0)$$\n\n给出一个表格，求 $k$ 个时间单位后它储存的总能量。\n\n由于总能量可能较大，输出时对 $p$ 取模。", "inputFormat": "第一行一个整数 $T$，表示数据组数。接下来 $T$ 行，每行四个整数 $n,m,k,p$。\n", "outputFormat": "共 $T$ 行，每行一个数，表示总能量对 $p$ 取模后的结果。\n", "hint": "对于 $100\\%$ 的数据，保证 $1\\le T\\le 5000$，$1\\le p\\le 10^9$，$1\\le n,m\\le 10^{18}，0\\le k\\le 10^{18}$。\n\n| 测试点编号 | $T=$ | $n\\le$ | $m\\le$ | $k\\le$ | $p\\le$ |\n| :--: | :--: | :--: | :--: | :--: | :--: |\n| $1,2$ | $5000$ | $100$ | $100$ | $100$ | $10^9$ |\n| $3$ | $5000$ | $10^{18}$ | $10^{18}$ | $0$ | $10^9$ |\n| $4$ | $5000$ | $10^{18}$ | $10^{18}$ | $1$ | $10^9$ |\n| $5$ | $5000$ | $10$ | $10^{18}$ | $10$ | $10^9$ |\n| $6$ | $1$ | $10^5$ | $10^{18}$ | $10^5$ | $10^9$ |\n| $7$ | $1$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |\n| $8$ | $100$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |\n| $9,10$ | $5000$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |\n\n$\\texttt{Statement fixed by Starrykiller.}$", "locale": "zh-CN"}}}
{"pid": "P4068", "type": "P", "difficulty": 6, "samples": [["3\n2 4 8\n2 200 7\n-1 -2 1\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2016", "各省省选", "网络流", "山东", "二分图", "素数判断,质数,筛法"], "title": "[SDOI2016] 数字配对", "background": "", "description": "有 $n$ 种数字，第 $i$ 种数字是 $a_i$、有 $b_i$ 个，权值是 $c_i$。\n\n若两个数字 $a_i$、$a_j$ 满足，$a_i$ 是 $a_j$ 的倍数，且 $a_i/a_j$ 是一个质数，\n\n那么这两个数字可以配对，并获得 $c_i \\times c_j$ 的价值。\n\n一个数字只能参与一次配对，可以不参与配对。\n\n在获得的价值总和不小于 $0$ 的前提下，求最多进行多少次配对。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个整数 $a_1,a_2,\\cdots,a_n$。\n\n第三行 $n$ 个整数 $b_1,b_2,\\cdots,b_n$。\n\n第四行 $n$ 个整数 $c_1,c_2,\\cdots,c_n$。", "outputFormat": "一行一个数，最多进行多少次配对。", "hint": "测试点 $1 \\sim 3$： $n \\leq 10 $， $a_i \\leq 10 ^ 9 $ ， $b_i = 1 $，$ | c_i | \\leq 10 ^ 5$；   \n\n测试点 $4 \\sim 5$： $n \\leq 200 $， $a_i \\leq 10 ^ 9 $ ， $b_i \\leq 10 ^ 5  $，$c_i = 0$；\n\n测试点 $6 \\sim 10$： $n \\leq 200 $， $a_i \\leq 10 ^ 9 $ ， $b_i \\leq 10 ^ 5$ ，$ | c_i | \\leq 10 ^ 5$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] Number Pairing", "background": "", "description": "There are $n$ types of numbers. For the $i$-th type, the number is $a_i$, there are $b_i$ copies of it, and its weight is $c_i$.\n\nIf two numbers $a_i$ and $a_j$ satisfy that $a_i$ is a multiple of $a_j$, and $a_i / a_j$ is a prime number, then these two numbers can be paired, gaining a value of $c_i \\times c_j$.\n\nEach number can participate in at most one pairing, and it is allowed to remain unpaired.\n\nUnder the condition that the total gained value is at least $0$, find the maximum possible number of pairings.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains $n$ integers $a_1,a_2,\\cdots,a_n$.\n\nThe third line contains $n$ integers $b_1,b_2,\\cdots,b_n$.\n\nThe fourth line contains $n$ integers $c_1,c_2,\\cdots,c_n$.", "outputFormat": "Output a single integer on one line: the maximum number of pairings.", "hint": "Test points $1 \\sim 3$: $n \\leq 10$, $a_i \\leq 10^9$, $b_i = 1$, $|c_i| \\leq 10^5$.  \nTest points $4 \\sim 5$: $n \\leq 200$, $a_i \\leq 10^9$, $b_i \\leq 10^5$, $c_i = 0$.  \nTest points $6 \\sim 10$: $n \\leq 200$, $a_i \\leq 10^9$, $b_i \\leq 10^5$, $|c_i| \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 数字配对", "background": "", "description": "有 $n$ 种数字，第 $i$ 种数字是 $a_i$、有 $b_i$ 个，权值是 $c_i$。\n\n若两个数字 $a_i$、$a_j$ 满足，$a_i$ 是 $a_j$ 的倍数，且 $a_i/a_j$ 是一个质数，\n\n那么这两个数字可以配对，并获得 $c_i \\times c_j$ 的价值。\n\n一个数字只能参与一次配对，可以不参与配对。\n\n在获得的价值总和不小于 $0$ 的前提下，求最多进行多少次配对。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个整数 $a_1,a_2,\\cdots,a_n$。\n\n第三行 $n$ 个整数 $b_1,b_2,\\cdots,b_n$。\n\n第四行 $n$ 个整数 $c_1,c_2,\\cdots,c_n$。", "outputFormat": "一行一个数，最多进行多少次配对。", "hint": "测试点 $1 \\sim 3$： $n \\leq 10 $， $a_i \\leq 10 ^ 9 $ ， $b_i = 1 $，$ | c_i | \\leq 10 ^ 5$；   \n\n测试点 $4 \\sim 5$： $n \\leq 200 $， $a_i \\leq 10 ^ 9 $ ， $b_i \\leq 10 ^ 5  $，$c_i = 0$；\n\n测试点 $6 \\sim 10$： $n \\leq 200 $， $a_i \\leq 10 ^ 9 $ ， $b_i \\leq 10 ^ 5$ ，$ | c_i | \\leq 10 ^ 5$。", "locale": "zh-CN"}}}
{"pid": "P4069", "type": "P", "difficulty": 6, "samples": [["3 5\n1 2 10\n2 3 20\n2 1 3\n1 2 3 5 6\n2 2 3\n1 2 3 -5 -6\n2 2 3", "123456789123456789\n6\n-106"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2016", "线段树", "各省省选", "山东", "最近公共祖先 LCA", "树链剖分", "李超线段树"], "title": "[SDOI2016] 游戏", "background": "", "description": "Alice 和 Bob 在玩一个游戏。\n\n游戏在一棵有 $n$ 个点的树上进行。最初，每个点上都只有一个数字，那个数字是 $123456789123456789$。\n\n有时，Alice 会选择一条从 $s$ 到 $t$ 的路径，在这条路径上的每一个点上都添加一个数字。对于路径上的一个点 $r$，若 $r$ 与 $s$ 的距离是 $dis$，那么 Alice 在点 $r$ 上添加的数字是 $a\\times dis+b$。\n\n有时，Bob 会选择一条从 $s$ 到 $t$ 的路径。他需要先从这条路径上选择一个点，再从那个点上选择一个数字。\n\nBob 选择的数字越小越好，但大量的数字让 Bob 眼花缭乱。Bob 需要你帮他找出他能够选择的最小的数字。\n", "inputFormat": "第一行两个数字 $n,m$，表示树的点数和进行的操作数。\n\n接下来 $n-1$ 行，每行三个数字 $u,v,w$，表示树上有一条连接 $u,v$ 的边，长度是 $w$。\n\n接下来 $m$ 行。每行第一个数字是 $1$ 或 $2$。\n\n若第一个数是 $1$，表示 Alice 进行操作，接下来四个数字 $s,t,a,b$。\n\n若第一个数是 $2$，表示 Bob 进行操作，接下来两个数字 $s,t$。\n", "outputFormat": "每当 Bob 进行操作，输出一行一个数，表示他能够选择的最小的数字\n", "hint": "测试点 1 ~ 2：$ n \\leq 10 $，$ m \\leq 10 $，$ | a | \\leq 10000 $；\n\n测试点 3 ~ 4：$ n \\leq 1000 $，$ m \\leq 1000 $，$ | a | \\leq 10000 $；\n\n测试点 5：$ n \\leq 100000 $，$ m \\leq 100000 $，$ a = 0 $，树是一条链；\n\n测试点 6 ~ 7：$ n \\leq 100000 $，$ m \\leq 100000 $，$ a = 0 $；\n\n测试点 8：$ n \\leq 100000 $，$ m \\leq 100000 $，$ a = 1 $，树是一条链；\n\n测试点 9 ~ 10：$ n \\leq 100000 $，$ m \\leq 100000 $，$ a = 1 $；\n\n测试点 11 ~ 13：$ n \\leq 100000 $，$ m \\leq 100000 $，$ | a | \\leq 10000 $，树是一条链；\n\n测试点 14 ~ 20：$ n \\leq 100000 $，$ m \\leq 100000 $，$ | a | \\leq 10000 $。\n\n对于所有数据，$0\\le w, |b|\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] Game", "background": "", "description": "Alice and Bob are playing a game.\n\nThe game is played on a tree with $n$ vertices. Initially, each vertex contains exactly one number, which is $123456789123456789$.\n\nSometimes, Alice chooses the path from $s$ to $t$ and adds a number to every vertex on this path. For a vertex $r$ on the path, if the distance between $r$ and $s$ is $dis$, then the number Alice adds to $r$ is $a \\times dis + b$.\n\nSometimes, Bob chooses the path from $s$ to $t$. He must first choose a vertex on this path, and then choose one number stored at that vertex.\n\nBob wants the chosen number to be as small as possible, but the large amount of numbers makes him dazzled. He needs your help to find the smallest number he can choose.", "inputFormat": "The first line contains two integers $n, m$, the number of vertices of the tree and the number of operations.\n\nThe next $n - 1$ lines each contain three integers $u, v, w$, indicating there is an edge connecting $u$ and $v$ with length $w$.\n\nThe next $m$ lines each begin with an integer $1$ or $2$.\n\nIf the first integer is $1$, it denotes Alice’s operation, followed by four integers $s, t, a, b$.\n\nIf the first integer is $2$, it denotes Bob’s operation, followed by two integers $s, t$.", "outputFormat": "Each time Bob performs an operation, output one line with a single integer, representing the smallest number he can choose.", "hint": "Test points 1–2: $n \\leq 10$, $m \\leq 10$, $|a| \\leq 10000$.\n\nTest points 3–4: $n \\leq 1000$, $m \\leq 1000$, $|a| \\leq 10000$.\n\nTest point 5: $n \\leq 100000$, $m \\leq 100000$, $a = 0$, the tree is a path.\n\nTest points 6–7: $n \\leq 100000$, $m \\leq 100000$, $a = 0$.\n\nTest point 8: $n \\leq 100000$, $m \\leq 100000$, $a = 1$, the tree is a path.\n\nTest points 9–10: $n \\leq 100000$, $m \\leq 100000$, $a = 1$.\n\nTest points 11–13: $n \\leq 100000$, $m \\leq 100000$, $|a| \\leq 10000$, the tree is a path.\n\nTest points 14–20: $n \\leq 100000$, $m \\leq 100000$, $|a| \\leq 10000$.\n\nFor all testdata, $0 \\le w, |b| \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 游戏", "background": "", "description": "Alice 和 Bob 在玩一个游戏。\n\n游戏在一棵有 $n$ 个点的树上进行。最初，每个点上都只有一个数字，那个数字是 $123456789123456789$。\n\n有时，Alice 会选择一条从 $s$ 到 $t$ 的路径，在这条路径上的每一个点上都添加一个数字。对于路径上的一个点 $r$，若 $r$ 与 $s$ 的距离是 $dis$，那么 Alice 在点 $r$ 上添加的数字是 $a\\times dis+b$。\n\n有时，Bob 会选择一条从 $s$ 到 $t$ 的路径。他需要先从这条路径上选择一个点，再从那个点上选择一个数字。\n\nBob 选择的数字越小越好，但大量的数字让 Bob 眼花缭乱。Bob 需要你帮他找出他能够选择的最小的数字。\n", "inputFormat": "第一行两个数字 $n,m$，表示树的点数和进行的操作数。\n\n接下来 $n-1$ 行，每行三个数字 $u,v,w$，表示树上有一条连接 $u,v$ 的边，长度是 $w$。\n\n接下来 $m$ 行。每行第一个数字是 $1$ 或 $2$。\n\n若第一个数是 $1$，表示 Alice 进行操作，接下来四个数字 $s,t,a,b$。\n\n若第一个数是 $2$，表示 Bob 进行操作，接下来两个数字 $s,t$。\n", "outputFormat": "每当 Bob 进行操作，输出一行一个数，表示他能够选择的最小的数字\n", "hint": "测试点 1 ~ 2：$ n \\leq 10 $，$ m \\leq 10 $，$ | a | \\leq 10000 $；\n\n测试点 3 ~ 4：$ n \\leq 1000 $，$ m \\leq 1000 $，$ | a | \\leq 10000 $；\n\n测试点 5：$ n \\leq 100000 $，$ m \\leq 100000 $，$ a = 0 $，树是一条链；\n\n测试点 6 ~ 7：$ n \\leq 100000 $，$ m \\leq 100000 $，$ a = 0 $；\n\n测试点 8：$ n \\leq 100000 $，$ m \\leq 100000 $，$ a = 1 $，树是一条链；\n\n测试点 9 ~ 10：$ n \\leq 100000 $，$ m \\leq 100000 $，$ a = 1 $；\n\n测试点 11 ~ 13：$ n \\leq 100000 $，$ m \\leq 100000 $，$ | a | \\leq 10000 $，树是一条链；\n\n测试点 14 ~ 20：$ n \\leq 100000 $，$ m \\leq 100000 $，$ | a | \\leq 10000 $。\n\n对于所有数据，$0\\le w, |b|\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4070", "type": "P", "difficulty": 6, "samples": [["7\n1 2 3 3 3 1 2", "1\n3\n6\n9\n12\n17\n22"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2016", "各省省选", "平衡树", "山东", "后缀自动机 SAM", "后缀数组 SA"], "title": "[SDOI2016] 生成魔咒", "background": null, "description": "魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 $1,2$ 拼凑起来形成一个魔咒串 $[1,2]$。\n\n一个魔咒串 $S$ 的非空子串被称为魔咒串 $S$ 的生成魔咒。\n\n例如 $S=[1,2,1]$ 时，它的生成魔咒有 $[1],[2],[1,2],[2,1],[1,2,1]$ 五种。$S=[1,1,1]$ 时，它的生成魔咒有 $[1],[1,1],[1,1,1]$ 三种，最初 S 为空串。  \n\n共进行 $n$ 次操作，每次操作是在 $S$ 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 $S$ 共有多少种生成魔咒。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个数，第 $i$ 个数表示第 $i$ 次操作加入的魔咒字符 $x_i$。", "outputFormat": "输出 $n$ 行，每行一个数。  \n第 $i$ 行的数表示第 $i$ 次操作后 $S$ 的生成魔咒数量。", "hint": "#### 数据规模与约定   \n对于 $10\\%$ 的数据，保证 $1 \\le n \\le 10$；  \n对于 $30\\%$ 的数据，保证 $1 \\le n \\le 100$；  \n对于 $60\\%$ 的数据，保证 $1 \\le n \\le 10^3$；   \n对于 $100\\%$ 的数据，保证 $1 \\le n \\le 10^5$，$1 \\leq x_i \\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] Generating Spell", "background": "", "description": "A spell string consists of many spell characters, and a spell character can be represented by a number. For example, we can piece together spell characters $1,2$ to form a spell string $[1,2]$.\n\nA non-empty substring of a spell string $S$ is called a generating spell of $S$.\n\nFor example, when $S = [1,2,1]$, its generating spells are $[1],[2],[1,2],[2,1],[1,2,1]$, five in total. When $S = [1,1,1]$, its generating spells are $[1],[1,1],[1,1,1]$, three in total. Initially, $S$ is an empty string.\n\nThere are $n$ operations in total. In each operation, one spell character is appended to the end of $S$. After each operation, you need to determine how many distinct generating spells the current spell string $S$ has.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains $n$ numbers. The $i$-th number denotes the spell character $x_i$ appended in the $i$-th operation.", "outputFormat": "Output $n$ lines, one number per line.  \nThe number on the $i$-th line denotes the number of distinct generating spells after the $i$-th operation.", "hint": "Constraints  \nFor 10% of the testdata, it is guaranteed that $1 \\le n \\le 10$.  \nFor 30% of the testdata, it is guaranteed that $1 \\le n \\le 100$.  \nFor 60% of the testdata, it is guaranteed that $1 \\le n \\le 10^3$.  \nFor 100% of the testdata, it is guaranteed that $1 \\le n \\le 10^5$, $1 \\leq x_i \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 生成魔咒", "background": null, "description": "魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 $1,2$ 拼凑起来形成一个魔咒串 $[1,2]$。\n\n一个魔咒串 $S$ 的非空子串被称为魔咒串 $S$ 的生成魔咒。\n\n例如 $S=[1,2,1]$ 时，它的生成魔咒有 $[1],[2],[1,2],[2,1],[1,2,1]$ 五种。$S=[1,1,1]$ 时，它的生成魔咒有 $[1],[1,1],[1,1,1]$ 三种，最初 S 为空串。  \n\n共进行 $n$ 次操作，每次操作是在 $S$ 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 $S$ 共有多少种生成魔咒。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个数，第 $i$ 个数表示第 $i$ 次操作加入的魔咒字符 $x_i$。", "outputFormat": "输出 $n$ 行，每行一个数。  \n第 $i$ 行的数表示第 $i$ 次操作后 $S$ 的生成魔咒数量。", "hint": "#### 数据规模与约定   \n对于 $10\\%$ 的数据，保证 $1 \\le n \\le 10$；  \n对于 $30\\%$ 的数据，保证 $1 \\le n \\le 100$；  \n对于 $60\\%$ 的数据，保证 $1 \\le n \\le 10^3$；   \n对于 $100\\%$ 的数据，保证 $1 \\le n \\le 10^5$，$1 \\leq x_i \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4071", "type": "P", "difficulty": 4, "samples": [["5\n1 0\n1 1\n5 2\n100 50\n10000 5000", "0\n1\n20\n578028887\n60695423"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "2016", "各省省选", "山东", "枚举", "线性递推", "逆元"], "title": "[SDOI2016] 排列计数", "background": "", "description": "求有多少种 $1$ 到 $n$ 的排列 $a$，满足序列恰好有 $m$ 个位置 $i$，使得 $a_i = i$。\n\n答案对 $10^9 + 7$ 取模。", "inputFormat": "**本题单测试点内有多组数据**。\n\n输入的第一行是一个整数 $T$，代表测试数据的组数。\n\n以下 $T$ 行，每行描述一组测试数据。\n\n对于每组测试数据，每行输入两个整数，依次代表 $n$ 和 $m$。", "outputFormat": "共输出 $T$ 行，对于每组测试数据，输出一行一个整数代表答案。", "hint": "#### 数据规模与约定\n\n本题共 20 个测试点，各测试点等分，其数据规模如下表。\n\n| 测试点编号 | $T =$  | $n, m \\leq$ |  测试点编号  |      $T =$      | $n, m \\leq$ |\n| :--------: | :----: | :---------: | :----------: | :-------------: | :---------: |\n| $1\\sim 3$  | $10^3$ |     $8$     | $10 \\sim 12$ |     $10^3$      |   $10^3$    |\n| $4 \\sim 6$ | $10^3$ |    $12$     | $13 \\sim 14$ | $5 \\times 10^5$ |   $10^3$    |\n| $7 \\sim 9$ | $10^3$ |    $100$    | $15 \\sim 20$ | $5 \\times 10^5$ |   $10^6$    |\n\n对于全部的测试点，保证 $1 \\leq T \\leq 5 \\times 10^5$，$1 \\leq n \\leq 10^6$，$0 \\leq m \\leq 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] Permutation Counting", "background": "", "description": "Count the number of permutations $a$ of $1$ to $n$ such that there are exactly $m$ positions $i$ with $a_i = i$.\n\nOutput the answer modulo $10^9 + 7$.", "inputFormat": "**There are multiple test cases in a single test file.**\n\nThe first line contains an integer $T$, representing the number of test cases.\n\nThe following $T$ lines each describe one test case.\n\nFor each test case, a single line contains two integers $n$ and $m$, in that order.", "outputFormat": "Output $T$ lines. For each test case, output one integer representing the answer.", "hint": "#### Constraints\n\nThis problem contains 20 test points, evenly divided. The constraints for each test point are shown in the table below.\n\n| Test point ID | $T =$  | $n, m \\leq$ |  Test point ID  |      $T =$      | $n, m \\leq$ |\n| :-----------: | :----: | :---------: | :-------------: | :-------------: | :---------: |\n|  $1 \\sim 3$   | $10^3$ |     $8$     |  $10 \\sim 12$   |     $10^3$      |   $10^3$    |\n|  $4 \\sim 6$   | $10^3$ |    $12$     |  $13 \\sim 14$   | $5 \\times 10^5$ |   $10^3$    |\n|  $7 \\sim 9$   | $10^3$ |    $100$    |  $15 \\sim 20$   | $5 \\times 10^5$ |   $10^6$    |\n\nFor all test points, it is guaranteed that $1 \\leq T \\leq 5 \\times 10^5$, $1 \\leq n \\leq 10^6$, $0 \\leq m \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 排列计数", "background": "", "description": "求有多少种 $1$ 到 $n$ 的排列 $a$，满足序列恰好有 $m$ 个位置 $i$，使得 $a_i = i$。\n\n答案对 $10^9 + 7$ 取模。", "inputFormat": "**本题单测试点内有多组数据**。\n\n输入的第一行是一个整数 $T$，代表测试数据的组数。\n\n以下 $T$ 行，每行描述一组测试数据。\n\n对于每组测试数据，每行输入两个整数，依次代表 $n$ 和 $m$。", "outputFormat": "共输出 $T$ 行，对于每组测试数据，输出一行一个整数代表答案。", "hint": "#### 数据规模与约定\n\n本题共 20 个测试点，各测试点等分，其数据规模如下表。\n\n| 测试点编号 | $T =$  | $n, m \\leq$ |  测试点编号  |      $T =$      | $n, m \\leq$ |\n| :--------: | :----: | :---------: | :----------: | :-------------: | :---------: |\n| $1\\sim 3$  | $10^3$ |     $8$     | $10 \\sim 12$ |     $10^3$      |   $10^3$    |\n| $4 \\sim 6$ | $10^3$ |    $12$     | $13 \\sim 14$ | $5 \\times 10^5$ |   $10^3$    |\n| $7 \\sim 9$ | $10^3$ |    $100$    | $15 \\sim 20$ | $5 \\times 10^5$ |   $10^6$    |\n\n对于全部的测试点，保证 $1 \\leq T \\leq 5 \\times 10^5$，$1 \\leq n \\leq 10^6$，$0 \\leq m \\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4072", "type": "P", "difficulty": 6, "samples": [["5 2\n1 2 5 8 6", "36"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "各省省选", "单调队列", "山东", "O2优化", "斜率优化", "前缀和", "凸包"], "title": "[SDOI2016] 征途", "background": null, "description": "Pine 开始了从 $S$ 地到 $T$ 地的征途。\n\n从 $S$ 地到 $T$ 地的路可以划分成 $n$ 段，相邻两段路的分界点设有休息站。\n\nPine 计划用 $m$ 天到达 $T$ 地。除第 $m$ 天外，每一天晚上 Pine 都必须在休息站过夜。所以，一段路必须在同一天中走完。\n\nPine 希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。\n\n帮助 Pine 求出最小方差是多少。\n\n设方差是 $v$，可以证明，$v\\times m^2$ 是一个整数。为了避免精度误差，输出结果时输出 $v\\times m^2$。", "inputFormat": "第一行两个数 $n, m$。\n\n第二行 $n$ 个数，表示 $n$ 段路的长度。", "outputFormat": "一个数，最小方差乘以 $m^2$ 后的值。", "hint": "### 数据范围及约定\n\n- 对于 $30\\%$ 的数据，$1 \\le n \\le 10$；\n- 对于 $60\\%$ 的数据，$1 \\le n \\le 100$；\n- 对于 $100\\%$ 的数据，$1 \\le n \\le 3000$。\n\n保证从 $S$ 到 $T$ 的总路程不超过 $3\\times 10^4$。\n\n$2 \\leq m \\leq n$，每段路的长度为不超过 $3 \\times 10^4$ 的**正整数**。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] The Journey", "background": "", "description": "Pine starts a journey from $S$ to $T$.\n\nThe road from $S$ to $T$ can be divided into $n$ segments, and there is a rest station at the boundary point between each pair of adjacent segments.\n\nPine plans to reach $T$ in $m$ days. Except for day $m$, Pine must spend each night at a rest station. Therefore, each segment must be completed within a single day.\n\nPine wants the daily distances to be as similar as possible, so he wants the variance of the daily distances to be as small as possible.\n\nHelp Pine find the minimum possible variance.\n\nLet the variance be $v$. It can be proven that $v \\times m^2$ is an integer. To avoid precision errors, output $v \\times m^2$.", "inputFormat": "The first line contains two integers $n, m$.\n\nThe second line contains $n$ integers, representing the lengths of the $n$ segments.", "outputFormat": "Output a single integer: the minimum variance multiplied by $m^2$.", "hint": "- Constraints and Conventions\n  - For $30\\%$ of the testdata, $1 \\le n \\le 10$;\n  - For $60\\%$ of the testdata, $1 \\le n \\le 100$;\n  - For $100\\%$ of the testdata, $1 \\le n \\le 3000$.\n\nThe total distance from $S$ to $T$ does not exceed $3 \\times 10^4$.\n\n$2 \\le m \\le n$, and each segment length is a positive integer not exceeding $3 \\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 征途", "background": null, "description": "Pine 开始了从 $S$ 地到 $T$ 地的征途。\n\n从 $S$ 地到 $T$ 地的路可以划分成 $n$ 段，相邻两段路的分界点设有休息站。\n\nPine 计划用 $m$ 天到达 $T$ 地。除第 $m$ 天外，每一天晚上 Pine 都必须在休息站过夜。所以，一段路必须在同一天中走完。\n\nPine 希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。\n\n帮助 Pine 求出最小方差是多少。\n\n设方差是 $v$，可以证明，$v\\times m^2$ 是一个整数。为了避免精度误差，输出结果时输出 $v\\times m^2$。", "inputFormat": "第一行两个数 $n, m$。\n\n第二行 $n$ 个数，表示 $n$ 段路的长度。", "outputFormat": "一个数，最小方差乘以 $m^2$ 后的值。", "hint": "### 数据范围及约定\n\n- 对于 $30\\%$ 的数据，$1 \\le n \\le 10$；\n- 对于 $60\\%$ 的数据，$1 \\le n \\le 100$；\n- 对于 $100\\%$ 的数据，$1 \\le n \\le 3000$。\n\n保证从 $S$ 到 $T$ 的总路程不超过 $3\\times 10^4$。\n\n$2 \\leq m \\leq n$，每段路的长度为不超过 $3 \\times 10^4$ 的**正整数**。", "locale": "zh-CN"}}}
{"pid": "P4073", "type": "P", "difficulty": 7, "samples": [["9 12\n1 1\n1 2\n1 3\n2 1\n2 2\n2 3\n3 1\n3 2\n3 3\n1 2 10\n2 3 10\n3 6 10\n6 9 10\n9 8 10\n8 7 10\n7 4 10\n4 1 10\n2 5 3\n5 8 2\n5 6 4\n4 5 1\n3\n1.5 1.5 2.5 2.5\n1.5 2.5 2.5 1.5\n0.5 0.5 1.5 1.5", "2\n3\n-1"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["图论", "计算几何", "2013", "倍增", "平衡树", "枚举", "生成树", "WC"], "title": "[WC2013] 平面图", "background": "", "description": "在一个平面中有 $n$ 个顶点和 $m$ 条直线段，第 $i$ 个顶点的坐标为 $(x_i, y_i)$， 第 $j$ 条直线段连接顶点 $u_j$ 和顶点 $v_j$，权值为 $h_j$， 除顶点 $u_j$ 和 $v_j$ 外直线段 $j$ 不经过其他的顶点。任意两条直线段如果存在公共点，则该公共点一定是一个顶点，此时这两条直线段都会连接这个顶点。对于任意的两个顶点 $x$ 和 $y$，总是可以找到一顶点序列 $a_1,a_2,\\cdots,a_k$ 使得 $a_1=x$，$a_k=y$ 且对于任意 $1\\le i< k$ 满足 $a_i$ 和 $a_{i+1}$ 被一条直线段直接连接。\n\n这 $m$ 条直线段将整个平面分成了若干个区域，其中只有一个区域是无穷大的，其余均是有界的，我们称无穷大的区域为禁区。\n\n现在给出 $q$ 次询问，每次给定平面中的任意两个不是顶点且分别不在任意一条直线段上的点 $A$ 和 $B$，请画一条曲线连接 $A$ 和 $B$，要求曲线不能经过禁区以及任何顶点，并使得穿过的直线段中权值最大的尽可能小。你需要对每次询问回答这个值最小为多少。\n", "inputFormat": "第一行有两个正整数 $n,m$，分别表示顶点数和直线段数。\n\n接下来 $n$ 行，每行两个整数，这部分中第 $i$ 行（总第 $i+1$ 行）的两个整数 $x_i,y_i$ 为顶点 $i$ 的坐标。\n\n接下来 $m$ 行，每行三个正整数 $u,v,h$，表示有一条直线段连接顶点 $u$ 和顶点 $v$，权值为 $h$。其中 $u\\neq v$。\n\n接下来的一行，有一个正整数 $q$，表示询问数量。\n\n接下来 $q$ 行，每行四个实数 $A_x,A_y,B_x,B_y$， 表示一组两个点的坐标分别为 $(A_x, A_y)$ 和 $(B_x, B_y)$ 的询问。\n", "outputFormat": "输出 $q$ 行，每行一个正整数，依次表示每个询问的答案。特别的，若不需要跨过任何一条边即可到达，请输出 $0$；若不存在合法的曲线，请输出 $-1$。\n", "hint": "【样例说明】\n\n![QQ20180112214336.png](https://cdn.luogu.com.cn/upload/image_hosting/228djzaq.png)\n\n【数据规模与约定】\n\n本题共设有 $10$ 个测试点，每个测试点的规模与特征如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2l8u3hkb.png)\n\n对于全部数据，均满足 $5$ ≤ $n$, $m$, $q$ ≤ $100,000$，所有直线段的权值不会超过 $10^9$。所有询问坐标均为不超过 $10^7$ 的实数，且保证是 $0.5$ 的整数倍。\n", "locale": "zh-CN", "translations": {"en": {"title": "[WC2013] Planar Graph", "background": "", "description": "In a plane, there are $n$ vertices and $m$ line segments. The $i$-th vertex has coordinates $(x_i, y_i)$. The $j$-th line segment connects vertex $u_j$ and vertex $v_j$ and has weight $h_j$. Except for its endpoints $u_j$ and $v_j$, segment $j$ does not pass through any other vertex. If any two segments have a common point, that point must be a vertex, and in that case both segments connect to this vertex. For any two vertices $x$ and $y$, there always exists a sequence of vertices $a_1, a_2, \\cdots, a_k$ such that $a_1 = x$, $a_k = y$, and for every $1 \\le i < k$, $a_i$ and $a_{i+1}$ are directly connected by a segment.\n\nThese $m$ segments divide the plane into several regions. Exactly one region is unbounded and the others are bounded. We call the unbounded region the forbidden region.\n\nYou are given $q$ queries. In each query, two arbitrary points $A$ and $B$ in the plane are given; neither is a vertex and neither lies on any segment. Draw a curve connecting $A$ and $B$ that does not pass through the forbidden region or any vertex, and minimize the maximum weight among all segments crossed by the curve. For each query, you need to output this minimal possible value.", "inputFormat": "The first line contains two positive integers $n, m$, denoting the number of vertices and the number of line segments.\n\nThe next $n$ lines each contain two integers. In this part, the $i$-th line (the $(i+1)$-th line overall) contains two integers $x_i, y_i$, the coordinates of vertex $i$.\n\nThe next $m$ lines each contain three positive integers $u, v, h$, indicating there is a line segment connecting vertex $u$ and vertex $v$ with weight $h$. Here $u \\ne v$.\n\nThe next line contains a single positive integer $q$, the number of queries.\n\nThe next $q$ lines each contain four real numbers $A_x, A_y, B_x, B_y$, representing one query whose two points are $(A_x, A_y)$ and $(B_x, B_y)$.", "outputFormat": "Output $q$ lines, each containing an integer, which is the answer for each query in order. If $A$ can reach $B$ without crossing any segment, output $0$. If no valid curve exists, output $-1$.", "hint": "Sample explanation:\n\n![QQ20180112214336.png](https://cdn.luogu.com.cn/upload/image_hosting/228djzaq.png)\n\nConstraints and notes:\n\nThis problem has $10$ test points. The scale and features of each test point are as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2l8u3hkb.png)\n\nFor all data, it holds that $5 \\le n, m, q \\le 100000$. All segment weights do not exceed $10^9$. All query coordinates are real numbers not exceeding $10^7$, and are guaranteed to be multiples of $0.5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2013] 平面图", "background": "", "description": "在一个平面中有 $n$ 个顶点和 $m$ 条直线段，第 $i$ 个顶点的坐标为 $(x_i, y_i)$， 第 $j$ 条直线段连接顶点 $u_j$ 和顶点 $v_j$，权值为 $h_j$， 除顶点 $u_j$ 和 $v_j$ 外直线段 $j$ 不经过其他的顶点。任意两条直线段如果存在公共点，则该公共点一定是一个顶点，此时这两条直线段都会连接这个顶点。对于任意的两个顶点 $x$ 和 $y$，总是可以找到一顶点序列 $a_1,a_2,\\cdots,a_k$ 使得 $a_1=x$，$a_k=y$ 且对于任意 $1\\le i< k$ 满足 $a_i$ 和 $a_{i+1}$ 被一条直线段直接连接。\n\n这 $m$ 条直线段将整个平面分成了若干个区域，其中只有一个区域是无穷大的，其余均是有界的，我们称无穷大的区域为禁区。\n\n现在给出 $q$ 次询问，每次给定平面中的任意两个不是顶点且分别不在任意一条直线段上的点 $A$ 和 $B$，请画一条曲线连接 $A$ 和 $B$，要求曲线不能经过禁区以及任何顶点，并使得穿过的直线段中权值最大的尽可能小。你需要对每次询问回答这个值最小为多少。\n", "inputFormat": "第一行有两个正整数 $n,m$，分别表示顶点数和直线段数。\n\n接下来 $n$ 行，每行两个整数，这部分中第 $i$ 行（总第 $i+1$ 行）的两个整数 $x_i,y_i$ 为顶点 $i$ 的坐标。\n\n接下来 $m$ 行，每行三个正整数 $u,v,h$，表示有一条直线段连接顶点 $u$ 和顶点 $v$，权值为 $h$。其中 $u\\neq v$。\n\n接下来的一行，有一个正整数 $q$，表示询问数量。\n\n接下来 $q$ 行，每行四个实数 $A_x,A_y,B_x,B_y$， 表示一组两个点的坐标分别为 $(A_x, A_y)$ 和 $(B_x, B_y)$ 的询问。\n", "outputFormat": "输出 $q$ 行，每行一个正整数，依次表示每个询问的答案。特别的，若不需要跨过任何一条边即可到达，请输出 $0$；若不存在合法的曲线，请输出 $-1$。\n", "hint": "【样例说明】\n\n![QQ20180112214336.png](https://cdn.luogu.com.cn/upload/image_hosting/228djzaq.png)\n\n【数据规模与约定】\n\n本题共设有 $10$ 个测试点，每个测试点的规模与特征如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2l8u3hkb.png)\n\n对于全部数据，均满足 $5$ ≤ $n$, $m$, $q$ ≤ $100,000$，所有直线段的权值不会超过 $10^9$。所有询问坐标均为不超过 $10^7$ 的实数，且保证是 $0.5$ 的整数倍。\n", "locale": "zh-CN"}}}
{"pid": "P4074", "type": "P", "difficulty": 6, "samples": [["4 3 5\n1 9 2\n7 6 5 1\n2 3\n3 1\n3 4\n1 2 3 2\n1 1 2\n1 4 2\n0 2 1\n1 1 2\n1 4 2", "84\n131\n27\n84"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2013", "莫队", "最近公共祖先 LCA", "分块", "WC"], "title": "[WC2013] 糖果公园", "background": "", "description": "Candyland 有一座糖果公园，公园里不仅有美丽的风景、好玩的游乐项目，还有许多免费糖果的发放点，这引来了许多贪吃的小朋友来糖果公园游玩。\n\n糖果公园的结构十分奇特，它由 $n$ 个游览点构成，每个游览点都有一个糖果发放处，我们可以依次将游览点编号为 $1$ 至 $n$。有 $n - 1$ 条双向道路连接着这些游览点，并且整个糖果公园都是连通的，即从任何一个游览点出发都可以通过这些道路到达公园里的所有其它游览点。\n\n糖果公园所发放的糖果种类非常丰富，总共有 $m$ 种，它们的编号依次为 $1$ 至 $m$。每一个糖果发放处都只发放某种特定的糖果，我们用 $C_i$ 来表示 $i$ 号游览点的糖果。\n\n来到公园里游玩的游客都不喜欢走回头路，他们总是从某个特定的游览点出发前往另一个特定的游览点，并游览途中的景点，这条路线一定是唯一的。他们经过每个游览点，都可以品尝到一颗对应种类的糖果。\n\n大家对不同类型糖果的喜爱程度都不尽相同。 根据游客们的反馈打分，我们得到了糖果的美味指数， 第 $i$ 种糖果的美味指数为 $V_i$。另外，如果一位游客反复地品尝同一种类的糖果，他肯定会觉得有一些腻。根据量化统计，我们得到了游客第 $i$ 次品尝某类糖果的新奇指数 $W_i$。如果一位游客第 $i$ 次品尝第 $j$ 种糖果，那么他的愉悦指数 $H$ 将会增加对应的美味指数与新奇指数的乘积，即 $V_j \\times W_i$。这位游客游览公园的愉悦指数最终将是这些乘积的和。\n\n当然，公园中每个糖果发放点所发放的糖果种类不一定是一成不变的。有时，一些糖果点所发放的糖果种类可能会更改（也只会是 $m$ 种中的一种），这样的目的是能够让游客们总是感受到惊喜。\n\n糖果公园的工作人员小 A 接到了一个任务，那就是根据公园最近的数据统计出每位游客游玩公园的愉悦指数。但数学不好的小 A 一看到密密麻麻的数字就觉得头晕，作为小 A 最好的朋友，你决定帮他一把。\n", "inputFormat": "\n第一行包含三个正整数 $n, m, q$， 分别表示游览点个数、 糖果种类数和操作次数。\n\n第二行包含 $m$ 个正整数 $V_1, V_2, \\ldots, V_m$。\n\n第三行包含 $n$ 个正整数 $W_1, W_2, \\ldots, W_n$。\n\n第四行到第 $n + 2$ 行，每行包含两个正整数 $A_i, B_i$，表示这两个游览点之间有路径可以直接到达。\n\n第 $n + 3$ 行包含 $n$ 个正整数 $C_1, C_2, \\ldots, C_n$。\n\n接下来 $q$ 行， 每行包含三个整数 $Type, x, y$，表示一次操作：\n\n- 若 $Type$ 为 $0$，则 $1 \\leq x \\leq n$， $1 \\leq y \\leq m$，表示将编号为 $x$ 的游览点发放的糖果类型改为 $y$；\n- 若 $Type$ 为 $1$，则 $1 \\leq x, y \\leq n$，表示对出发点为 $x$，终止点为 $y$ 的路线询问愉悦指数。\n", "outputFormat": "按照输入的先后顺序，对于每个 $Type$ 为 $1$ 的操作输出一行，用一个正整数表示答案。\n", "hint": "【样例解释】\n\n我们分别用\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/isw3ib3u.png)\n\n代表 $C_i$ 为 $1$、 $2$、 $3$ 的节点，在修改之前：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ttkzii1u.png)\n\n在将 $C_2$ 修改为 $1$ 之后：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/izro364w.png)\n\n【数据规模与约定】\n\n对于所有的数据： $1 \\leq V_i, W_i \\leq 10^6$，$1 \\leq A_i, B_i \\leq n$， $1 \\leq C_i \\leq m$， $W_1, W_2, \\ldots, W_n$ 是非递增序列，即对任意 $1 < i \\leq n$， 满足 $W_i \\le W_{i-1}$。\n\n其它的限制条件如下表所示：\n\n![QQ20180113072014.png](https://cdn.luogu.com.cn/upload/image_hosting/g6884nx1.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "[WC2013] Candy Park", "background": "", "description": "Candyland has a Candy Park. Besides beautiful scenery and fun rides, there are many free candy distribution points, which attracts many candy-loving children to visit.\n\nThe structure of the Candy Park is peculiar. It consists of $n$ sightseeing spots, and each spot has a candy station. We number the spots from $1$ to $n$. There are $n - 1$ bidirectional roads connecting these spots, and the entire park is connected, meaning that starting from any spot, one can reach all other spots in the park via these roads.\n\nThere are $m$ types of candies in total, numbered from $1$ to $m$. Each candy station only distributes a specific type of candy. We use $C_i$ to denote the candy type at spot $i$.\n\nVisitors do not like to retrace their steps. They always travel from a particular starting spot to a particular ending spot, visiting the spots along the way. This route is unique. When they pass each spot, they can taste one candy of the corresponding type.\n\nPeople have different preferences for different types of candies. Based on visitor ratings, we obtained the tastiness index of candies: the tastiness index of the $i$-th type of candy is $V_i$. In addition, if a visitor repeatedly tastes the same type of candy, they will feel a bit bored. According to quantitative statistics, the novelty index for the $i$-th time tasting a certain type of candy is $W_i$. If a visitor tastes the $j$-th type of candy for the $i$-th time, their happiness index $H$ increases by the product of the corresponding tastiness index and novelty index, i.e., $V_j \\times W_i$. The visitor’s final happiness index is the sum of these products.\n\nOf course, the candy type distributed at each station may change from time to time (but always to one of the $m$ types), so that visitors can always feel surprised.\n\nStaff member A received a task to compute each visitor’s happiness index based on recent park data. But A is not good at math and feels dizzy when seeing rows of numbers. As A’s best friend, you decide to help.", "inputFormat": "The first line contains three positive integers $n, m, q$, representing the number of spots, the number of candy types, and the number of operations.\n\nThe second line contains $m$ positive integers $V_1, V_2, \\ldots, V_m$.\n\nThe third line contains $n$ positive integers $W_1, W_2, \\ldots, W_n$.\n\nFrom the 4th line to the $(n + 2)$-th line, each line contains two positive integers $A_i, B_i$, indicating that there is a road directly connecting these two spots.\n\nThe $(n + 3)$-th line contains $n$ positive integers $C_1, C_2, \\ldots, C_n$.\n\nThen there are $q$ lines. Each line contains three integers $Type, x, y$, representing an operation:\n- If $Type$ is $0$, then $1 \\le x \\le n$, $1 \\le y \\le m$, meaning that the candy type at spot $x$ is changed to $y$.\n- If $Type$ is $1$, then $1 \\le x, y \\le n$, meaning a query for the happiness index along the path from $x$ to $y$.", "outputFormat": "In the order of the input, for each operation with $Type = 1$, output one line with a single positive integer representing the answer.", "hint": "[Sample explanation]\n\nWe use\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/isw3ib3u.png)\n\nto denote nodes with $C_i$ equal to $1$, $2$, $3$. Before modification:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ttkzii1u.png)\n\nAfter changing $C_2$ to $1$:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/izro364w.png)\n\n[Constraints]\n\nFor all testdata: $1 \\le V_i, W_i \\le 10^6$, $1 \\le A_i, B_i \\le n$, $1 \\le C_i \\le m$, and $W_1, W_2, \\ldots, W_n$ is a non-increasing sequence, i.e., for any $1 < i \\le n$, it holds that $W_i \\le W_{i-1}$.\n\nOther constraint conditions are as shown in the table below:\n\n![QQ20180113072014.png](https://cdn.luogu.com.cn/upload/image_hosting/g6884nx1.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2013] 糖果公园", "background": "", "description": "Candyland 有一座糖果公园，公园里不仅有美丽的风景、好玩的游乐项目，还有许多免费糖果的发放点，这引来了许多贪吃的小朋友来糖果公园游玩。\n\n糖果公园的结构十分奇特，它由 $n$ 个游览点构成，每个游览点都有一个糖果发放处，我们可以依次将游览点编号为 $1$ 至 $n$。有 $n - 1$ 条双向道路连接着这些游览点，并且整个糖果公园都是连通的，即从任何一个游览点出发都可以通过这些道路到达公园里的所有其它游览点。\n\n糖果公园所发放的糖果种类非常丰富，总共有 $m$ 种，它们的编号依次为 $1$ 至 $m$。每一个糖果发放处都只发放某种特定的糖果，我们用 $C_i$ 来表示 $i$ 号游览点的糖果。\n\n来到公园里游玩的游客都不喜欢走回头路，他们总是从某个特定的游览点出发前往另一个特定的游览点，并游览途中的景点，这条路线一定是唯一的。他们经过每个游览点，都可以品尝到一颗对应种类的糖果。\n\n大家对不同类型糖果的喜爱程度都不尽相同。 根据游客们的反馈打分，我们得到了糖果的美味指数， 第 $i$ 种糖果的美味指数为 $V_i$。另外，如果一位游客反复地品尝同一种类的糖果，他肯定会觉得有一些腻。根据量化统计，我们得到了游客第 $i$ 次品尝某类糖果的新奇指数 $W_i$。如果一位游客第 $i$ 次品尝第 $j$ 种糖果，那么他的愉悦指数 $H$ 将会增加对应的美味指数与新奇指数的乘积，即 $V_j \\times W_i$。这位游客游览公园的愉悦指数最终将是这些乘积的和。\n\n当然，公园中每个糖果发放点所发放的糖果种类不一定是一成不变的。有时，一些糖果点所发放的糖果种类可能会更改（也只会是 $m$ 种中的一种），这样的目的是能够让游客们总是感受到惊喜。\n\n糖果公园的工作人员小 A 接到了一个任务，那就是根据公园最近的数据统计出每位游客游玩公园的愉悦指数。但数学不好的小 A 一看到密密麻麻的数字就觉得头晕，作为小 A 最好的朋友，你决定帮他一把。\n", "inputFormat": "\n第一行包含三个正整数 $n, m, q$， 分别表示游览点个数、 糖果种类数和操作次数。\n\n第二行包含 $m$ 个正整数 $V_1, V_2, \\ldots, V_m$。\n\n第三行包含 $n$ 个正整数 $W_1, W_2, \\ldots, W_n$。\n\n第四行到第 $n + 2$ 行，每行包含两个正整数 $A_i, B_i$，表示这两个游览点之间有路径可以直接到达。\n\n第 $n + 3$ 行包含 $n$ 个正整数 $C_1, C_2, \\ldots, C_n$。\n\n接下来 $q$ 行， 每行包含三个整数 $Type, x, y$，表示一次操作：\n\n- 若 $Type$ 为 $0$，则 $1 \\leq x \\leq n$， $1 \\leq y \\leq m$，表示将编号为 $x$ 的游览点发放的糖果类型改为 $y$；\n- 若 $Type$ 为 $1$，则 $1 \\leq x, y \\leq n$，表示对出发点为 $x$，终止点为 $y$ 的路线询问愉悦指数。\n", "outputFormat": "按照输入的先后顺序，对于每个 $Type$ 为 $1$ 的操作输出一行，用一个正整数表示答案。\n", "hint": "【样例解释】\n\n我们分别用\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/isw3ib3u.png)\n\n代表 $C_i$ 为 $1$、 $2$、 $3$ 的节点，在修改之前：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ttkzii1u.png)\n\n在将 $C_2$ 修改为 $1$ 之后：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/izro364w.png)\n\n【数据规模与约定】\n\n对于所有的数据： $1 \\leq V_i, W_i \\leq 10^6$，$1 \\leq A_i, B_i \\leq n$， $1 \\leq C_i \\leq m$， $W_1, W_2, \\ldots, W_n$ 是非递增序列，即对任意 $1 < i \\leq n$， 满足 $W_i \\le W_{i-1}$。\n\n其它的限制条件如下表所示：\n\n![QQ20180113072014.png](https://cdn.luogu.com.cn/upload/image_hosting/g6884nx1.png)\n", "locale": "zh-CN"}}}
{"pid": "P4075", "type": "P", "difficulty": 7, "samples": [["1\n11 4\nIODSSDSOIOI\n1 2\n2 3\n3 4\n1 5\n5 6\n6 7\n3 8\n8 9\n6 10\n10 11\nSDOI", "5"]], "limits": {"time": [2000, 2000, 2000], "memory": [128000, 128000, 128000]}, "tags": ["字符串", "2016", "各省省选", "点分治", "山东", "分治"], "title": "[SDOI2016] 模式字符串", "background": "", "description": "给出 $n$ 个结点的树 $T$，其中每一个结点上有一个字符，这里我们所说的字符只考虑大写字母 A 到 Z，再给出长度为 $m$ 的模式串 $S$，其中每一位仍然是 A 到 Z 的大写字母。\n\nAlice 希望知道，有多少对结点 $(u,v)$ 满足 $T$ 上从 $u$ 到 $v$ 的最短路径形成的字符串可以由模式串 $S$ 重复若干次得到l。\n\n这里结点对 $(u,v)$ 是有序的，也就是说 $(u,v)$ 和 $(v,u)$ 需要被区分。\n\n所谓模式串的重复，是将若干个模式串 $s$ 依次相接（不能重叠)。例如当 $S=$ `PLUS`的时候，重复两次会得到 `PLUSPLUS`，重复三次会得到 `PLUSPLUSPLUS`，同时要注意，重复必须是整数次的。例如当 $S= $ `XYXY` 时，因为必须重复整数次，所以 `XYXYXY` 不能看作是 $S$ 重复若干次得到的。", "inputFormat": "每一个数据有多组测试，\n\n第一行输入一个整数 $C$，表示总的测试个数。\n\n对于每一组测试来说：\n\n第一行输入两个整数，分别表示树 $T$ 的结点个数 $n$ 与模式长度 $m$。结点被依次编号为 $1$ 到 $n$。\n\n之后一行，依次给出了 $n$ 个大写字母（以一个长度为n的字符串的形式给出），依次对应树上每一个结点上的字符（第 $i$ 个字符对应了第 $i$ 个结点)。\n\n之后 $n-1$ 行，每行有两个整数 $u$ 和 $v$ 表示树上的一条无向边，之后一行给定一个长度为 $m$ 的由大写字母组成的字符串，为模式串 $S$。", "outputFormat": "\n给出 $C$ 行，对应 $C$ 组测试。\n\n每一行输出一个整数，表示有多少对节点 $(u,v)$ 满足从 $u$ 到 $v$ 的路径形成的字符串恰好是模式串的若干次重复。", "hint": "$1\\leq C\\leq 10$，$3\\leq \\sum N\\leq 10^6$，$3\\leq \\sum M\\leq 10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] Pattern String", "background": "", "description": "You are given a tree $T$ with $n$ nodes, where each node has a character. The characters are uppercase letters A to Z. You are also given a pattern string $S$ of length $m$, where each character is also an uppercase letter A to Z.\n\nAlice wants to know how many ordered pairs of nodes $(u,v)$ satisfy that the string formed by the shortest path from $u$ to $v$ in $T$ can be obtained by repeating the pattern string $S$ some number of times.\n\nHere the pair $(u,v)$ is ordered, meaning $(u,v)$ and $(v,u)$ are considered different.\n\nRepeating a pattern string means concatenating several copies of the pattern string $s$ one after another (without overlap). For example, when $S=$ `PLUS`, repeating it twice yields `PLUSPLUS`, repeating it three times yields `PLUSPLUSPLUS`. Note that the number of repetitions must be an integer. For example, when $S= $ `XYXY`, since repetitions must be an integer number, `XYXYXY` cannot be regarded as obtained by repeating $S$ some number of times.", "inputFormat": "There are multiple test cases.\n\nThe first line contains an integer $C$, the total number of test cases.\n\nFor each test case:\n\n- The first line contains two integers, the number of nodes $n$ of the tree $T$ and the pattern length $m$. Nodes are numbered from $1$ to $n$.\n- The next line gives $n$ uppercase letters (as a string of length $n$), where the $i$-th character corresponds to the $i$-th node on the tree.\n- The next $n-1$ lines each contain two integers $u$ and $v$, indicating an undirected edge of the tree.\n- The last line gives the pattern string $S$, which is a string of length $m$ consisting of uppercase letters.", "outputFormat": "Output $C$ lines, one for each test case.\n\nEach line should contain one integer, the number of ordered pairs $(u,v)$ such that the string formed by the path from $u$ to $v$ is exactly an integer number of repetitions of the pattern string $S$.", "hint": "$1 \\leq C \\leq 10$, $3 \\leq \\sum n \\leq 10^6$, $3 \\leq \\sum m \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 模式字符串", "background": "", "description": "给出 $n$ 个结点的树 $T$，其中每一个结点上有一个字符，这里我们所说的字符只考虑大写字母 A 到 Z，再给出长度为 $m$ 的模式串 $S$，其中每一位仍然是 A 到 Z 的大写字母。\n\nAlice 希望知道，有多少对结点 $(u,v)$ 满足 $T$ 上从 $u$ 到 $v$ 的最短路径形成的字符串可以由模式串 $S$ 重复若干次得到l。\n\n这里结点对 $(u,v)$ 是有序的，也就是说 $(u,v)$ 和 $(v,u)$ 需要被区分。\n\n所谓模式串的重复，是将若干个模式串 $s$ 依次相接（不能重叠)。例如当 $S=$ `PLUS`的时候，重复两次会得到 `PLUSPLUS`，重复三次会得到 `PLUSPLUSPLUS`，同时要注意，重复必须是整数次的。例如当 $S= $ `XYXY` 时，因为必须重复整数次，所以 `XYXYXY` 不能看作是 $S$ 重复若干次得到的。", "inputFormat": "每一个数据有多组测试，\n\n第一行输入一个整数 $C$，表示总的测试个数。\n\n对于每一组测试来说：\n\n第一行输入两个整数，分别表示树 $T$ 的结点个数 $n$ 与模式长度 $m$。结点被依次编号为 $1$ 到 $n$。\n\n之后一行，依次给出了 $n$ 个大写字母（以一个长度为n的字符串的形式给出），依次对应树上每一个结点上的字符（第 $i$ 个字符对应了第 $i$ 个结点)。\n\n之后 $n-1$ 行，每行有两个整数 $u$ 和 $v$ 表示树上的一条无向边，之后一行给定一个长度为 $m$ 的由大写字母组成的字符串，为模式串 $S$。", "outputFormat": "\n给出 $C$ 行，对应 $C$ 组测试。\n\n每一行输出一个整数，表示有多少对节点 $(u,v)$ 满足从 $u$ 到 $v$ 的路径形成的字符串恰好是模式串的若干次重复。", "hint": "$1\\leq C\\leq 10$，$3\\leq \\sum N\\leq 10^6$，$3\\leq \\sum M\\leq 10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P4076", "type": "P", "difficulty": 7, "samples": [["1\n2 10\n0 0\n0 0 0 0 0 0 0 0 0 0 \nADA_JARVIS\nADA_SIVRAJ", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "各省省选", "山东"], "title": "[SDOI2016] 墙上的句子", "background": "", "description": "考古学家发现了一堵写有未知语言的白色墙壁，上面有一个 $n$ 行 $m$ 列的格子，其中有些格子内被填入了某个 `A` 至 `Z` 的大写字母，还有些格子是空白的。\n\n一直横着或竖着的连续若干个字母会形成一个单词，且每一行的阅读顺序可能是从左向右或从右向左，每一列的阅读顺序可能是从下往上或从上往下。也就是说对于每一行来说，从左向右可以被看做是若干个单词形成的句子，相邻两个单词被一个或多个空白格子分割开来；也有可能是从右向左被看成是一个句子，竖直方向类似。\n\n遗憾的是，我们并不完全知道每一行每一列的阅读顺序是怎样的。但可以猜测，有些单词会满足反转过来也是一个单词。例如单词 `BOY`，翻转过来的 `YOB` 也是一个英文单词。\n\n此外观察者发现，对每一行（列）来说，按照确定后的阅读顺序读出的所有单词同时满足“自己的字典序不小于翻转后的字典序”，或同时满足“自己的字典序不大于翻转后的字典序”。\n\n在确定了所有行列的阅读顺序之后，我们可以构造出关于这种未知语言的字典。\n\n请问字典中出现的“翻转过来也是一个单词”的单词最少有多少种请注意，如果一个单词翻转后是不同的另外一个单词，它们需要被分别计入；而对于本身是回文的单词则不需要重复计入\n", "inputFormat": "第一行一个整数 $T$，表示 $T$ 组测试数据。\n\n对于每一组数据来说：第一行输入两个整数 $n,m$。\n\n第二行给出了 $n$ 个数字，对应 $n$ 行，其中若第 $i$ 个数字为 `1`，则表示第 $i$ 行的阅读顺序从左往右；若为 `-1` 则为从右向左；若为 `0` 则表示无法确定。\n\n第三行给出了 $m$ 个数字，对应 $n$ 行，其中若第 $i$ 个数字为 `1`，则表示第 $i$ 列的阅读顺序从上往下；若为 `-1` 则为从下向上；若为 `0` 则表示无法确定\n\n之后 $n$ 行，每行给出了长度为 $m$ 的字符串，由 `A` ~ `Z` 和下划线组成，对应了每个格子的符号，其中下划线表示格子为空。\n", "outputFormat": "输出 $T$ 行。每一组数据输出一行一个整数，表示最少有多少个单词，满足翻转后依然是单词。\n\n注意，如果一个单词是回文，那么它一定满足“翻转后依旧是单词”\n", "hint": "对于 $100\\%$ 的数据，$1\\leq n,m\\leq 72$，$T\\leq 64$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] Sentences on the Wall", "background": "", "description": "Archaeologists found a white wall written in an unknown language. On it there is an $n$-by-$m$ grid. Some cells contain an uppercase letter from `A` to `Z`, and some cells are blank.\n\nA contiguous run of letters strictly horizontally or vertically forms a word. Each row may be read either left to right or right to left, and each column may be read either bottom to top or top to bottom. That is, for each row, reading from left to right can be regarded as a sentence formed by several words, where adjacent words are separated by one or more blank cells; or it may be a sentence read from right to left. The vertical direction is analogous.\n\nUnfortunately, we do not completely know the reading order of each row and each column. However, it is plausible that some words satisfy that their reversed form is also a word. For example, the word `BOY` and its reversal `YOB` are both English words.\n\nFurthermore, observers found that for each row (column), under its finalized reading order, all words read in that row (column) simultaneously satisfy either “their own lexicographic order is not less than that of their reversed form,” or simultaneously satisfy “their own lexicographic order is not greater than that of their reversed form.”\n\nAfter determining the reading order of all rows and columns, we can construct a dictionary for this unknown language.\n\nWhat is the minimum possible number of distinct words in the dictionary whose reversed form is also a word? Please note that if a word and its reversed form are two different words, they must be counted separately; a word that is itself a palindrome should not be counted twice.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nFor each test case:\n- The first line contains two integers $n, m$.\n- The second line contains $n$ numbers, corresponding to the $n$ rows. If the $i$-th number is `1`, the $i$-th row is read left to right; if it is `-1`, it is read right to left; if it is `0`, the direction is undetermined.\n- The third line contains $m$ numbers, corresponding to the $m$ columns. If the $i$-th number is `1`, the $i$-th column is read top to bottom; if it is `-1`, it is read bottom to top; if it is `0`, the direction is undetermined.\n- Then follow $n$ lines. Each line is a string of length $m$, consisting of uppercase letters `A` to `Z` and underscores. An underscore denotes an empty cell.", "outputFormat": "Output $T$ lines. For each test case, output a single integer: the minimum number of words such that their reversed form is also a word.\n\nNote that if a word is a palindrome, it certainly satisfies “its reversal is also a word.”", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\leq n, m \\leq 72$, $T \\leq 64$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 墙上的句子", "background": "", "description": "考古学家发现了一堵写有未知语言的白色墙壁，上面有一个 $n$ 行 $m$ 列的格子，其中有些格子内被填入了某个 `A` 至 `Z` 的大写字母，还有些格子是空白的。\n\n一直横着或竖着的连续若干个字母会形成一个单词，且每一行的阅读顺序可能是从左向右或从右向左，每一列的阅读顺序可能是从下往上或从上往下。也就是说对于每一行来说，从左向右可以被看做是若干个单词形成的句子，相邻两个单词被一个或多个空白格子分割开来；也有可能是从右向左被看成是一个句子，竖直方向类似。\n\n遗憾的是，我们并不完全知道每一行每一列的阅读顺序是怎样的。但可以猜测，有些单词会满足反转过来也是一个单词。例如单词 `BOY`，翻转过来的 `YOB` 也是一个英文单词。\n\n此外观察者发现，对每一行（列）来说，按照确定后的阅读顺序读出的所有单词同时满足“自己的字典序不小于翻转后的字典序”，或同时满足“自己的字典序不大于翻转后的字典序”。\n\n在确定了所有行列的阅读顺序之后，我们可以构造出关于这种未知语言的字典。\n\n请问字典中出现的“翻转过来也是一个单词”的单词最少有多少种请注意，如果一个单词翻转后是不同的另外一个单词，它们需要被分别计入；而对于本身是回文的单词则不需要重复计入\n", "inputFormat": "第一行一个整数 $T$，表示 $T$ 组测试数据。\n\n对于每一组数据来说：第一行输入两个整数 $n,m$。\n\n第二行给出了 $n$ 个数字，对应 $n$ 行，其中若第 $i$ 个数字为 `1`，则表示第 $i$ 行的阅读顺序从左往右；若为 `-1` 则为从右向左；若为 `0` 则表示无法确定。\n\n第三行给出了 $m$ 个数字，对应 $n$ 行，其中若第 $i$ 个数字为 `1`，则表示第 $i$ 列的阅读顺序从上往下；若为 `-1` 则为从下向上；若为 `0` 则表示无法确定\n\n之后 $n$ 行，每行给出了长度为 $m$ 的字符串，由 `A` ~ `Z` 和下划线组成，对应了每个格子的符号，其中下划线表示格子为空。\n", "outputFormat": "输出 $T$ 行。每一组数据输出一行一个整数，表示最少有多少个单词，满足翻转后依然是单词。\n\n注意，如果一个单词是回文，那么它一定满足“翻转后依旧是单词”\n", "hint": "对于 $100\\%$ 的数据，$1\\leq n,m\\leq 72$，$T\\leq 64$。", "locale": "zh-CN"}}}
{"pid": "P4077", "type": "P", "difficulty": 6, "samples": [["6\n16 14\n1 0 0 1 0 0 0 0 1 0 0 0 1 0 1 1\n16 14\n0 1 0 0 0 1 1 1 1 1 1 0 1 0 0 1\n16 11\n0 1 0 0 0 1 1 1 0 1 0 0 0 1 0 1\n16 12\n1 1 1 1 1 1 1 1 0 0 1 1 0 1 1 0\n16 4\n1 0 0 1 0 0 1 0 0 0 0 1 0 1 1 0\n16 20\n0 0 0 0 1 0 1 0 0 0 1 0 0 1 0 0", "win\nlose\nwin\nlose\nwin\nwin"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "各省省选", "山东"], "title": "[SDOI2016] 硬币游戏", "background": "", "description": "Alice 和 Bob 现在在玩的游戏，主角是依次编号为 $1$ 到 $n$ 的 $n$ 枚硬币。每一枚硬币都有两面，我们分别称之为正面和反面。一开始的时候，有些硬币是正面向上的，有些是反面朝上的。Alice 和 Bob 将轮流对这些硬币进行翻转操作，且 Alice 总是先手。\n\n\n具体来说每次玩家可以选择一枚编号为 $x$，要求这枚硬币此刻是反面朝上的。对于编号 $x$ 来说，我们总可以将 $x$ 写成 $ c\\cdot 2^a \\cdot 3^b$ ，其中 $a$ 和 $b$ 是非负整数，$c$ 是与 $2,3$ 都互质的非负整数，然后有两种选择：\n\n\n选择整数 $p,q$ 满足 $a \\ge pq , p \\ge 1$ 且 $1 \\leq q \\leq \\text{MAXQ}$，然后同时翻转所有编号为 $c \\cdot 2^{a-pj} \\cdot 3^b$  的硬币，其中 $j = 0, 1, 2, \\ldots ,q$。\n\n选择整数 $p,q$ 满足 $b \\ge pq, p \\ge 1$  且 $1 \\leq q \\leq \\text{MAXQ}$，然后同时翻转所有编号为 $c \\cdot 2^a \\cdot 3^{b-pj}$ 的硬币，其中 $j = 0, 1, 2, \\ldots, q$。\n\n可以发现这个游戏不能无限进行下去，当某位玩家无法继续操作上述操作时，便输掉了游戏。作为先手的 Alice，总是希望可以在比赛开始之前就知道自己能否获胜。她知道自己和 Bob 都是充分聪明的，所以在游戏过程中，两人都会最优化自己的策略并尽量保证自己处于不败的情形中。\n", "inputFormat": "\n本题有多组测试数据，第一行输入一个整数 $T$，表示总的数据组数。之后给出 $T$ 组数据。\n\n每组数据第一行输入两个整数 $n,\\text{MAXQ}$。\n\n第二行输入 $n$ 个整数，第 $i$ 个数表示第 $i$ 个硬币的初始状态，$0$ 表示反面朝上，$1$ 表示正面朝上。", "outputFormat": "输出共有 $T$ 行。对于每一组数据来说，如果 Alice 先手必胜，则输出 `win`，否则输出 `lose`。\n", "hint": "对于 $100\\%$ 的数据 $1\\le n \\le 30000,1 \\le \\text{MAXQ} \\le 20,t\\le 100$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] Coin Game", "background": "", "description": "Alice and Bob are playing a game with $n$ coins numbered from $1$ to $n$. Each coin has two sides, called heads and tails. Initially, some coins are heads up and some are tails up. Alice and Bob alternate performing flip operations on these coins, and Alice always moves first.\n\nSpecifically, on each turn, the player may choose an index $x$ such that the coin $x$ is currently tails up. For the index $x$, we can always write $x = c \\cdot 2^a \\cdot 3^b$, where $a$ and $b$ are non-negative integers, and $c$ is a non-negative integer that is coprime to both $2$ and $3$. Then there are two choices:\n\n- Choose integers $p, q$ satisfying $a \\ge pq$, $p \\ge 1$, and $1 \\leq q \\leq \\text{MAXQ}$, then simultaneously flip all coins with indices $c \\cdot 2^{a - pj} \\cdot 3^b$, where $j = 0, 1, 2, \\ldots, q$.\n\n- Choose integers $p, q$ satisfying $b \\ge pq$, $p \\ge 1$, and $1 \\leq q \\leq \\text{MAXQ}$, then simultaneously flip all coins with indices $c \\cdot 2^a \\cdot 3^{b - pj}$, where $j = 0, 1, 2, \\ldots, q$.\n\nIt can be seen that the game cannot continue indefinitely. When a player cannot make a move as described above, they lose the game. As the first player, Alice wants to know beforehand whether she can win. She assumes that both she and Bob are perfectly rational, so during the game both will optimize their strategies and try to avoid losing.", "inputFormat": "There are multiple test cases. The first line contains an integer $T$, the number of test cases. Then $T$ test cases follow.\n\nFor each test case, the first line contains two integers $n, \\text{MAXQ}$.\n\nThe second line contains $n$ integers. The $i$-th number denotes the initial state of the $i$-th coin: $0$ means tails up, and $1$ means heads up.", "outputFormat": "Output $T$ lines. For each test case, if Alice has a winning strategy as the first player, print `win`; otherwise print `lose`.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 30000$, $1 \\le \\text{MAXQ} \\le 20$, $T \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 硬币游戏", "background": "", "description": "Alice 和 Bob 现在在玩的游戏，主角是依次编号为 $1$ 到 $n$ 的 $n$ 枚硬币。每一枚硬币都有两面，我们分别称之为正面和反面。一开始的时候，有些硬币是正面向上的，有些是反面朝上的。Alice 和 Bob 将轮流对这些硬币进行翻转操作，且 Alice 总是先手。\n\n\n具体来说每次玩家可以选择一枚编号为 $x$，要求这枚硬币此刻是反面朝上的。对于编号 $x$ 来说，我们总可以将 $x$ 写成 $ c\\cdot 2^a \\cdot 3^b$ ，其中 $a$ 和 $b$ 是非负整数，$c$ 是与 $2,3$ 都互质的非负整数，然后有两种选择：\n\n\n选择整数 $p,q$ 满足 $a \\ge pq , p \\ge 1$ 且 $1 \\leq q \\leq \\text{MAXQ}$，然后同时翻转所有编号为 $c \\cdot 2^{a-pj} \\cdot 3^b$  的硬币，其中 $j = 0, 1, 2, \\ldots ,q$。\n\n选择整数 $p,q$ 满足 $b \\ge pq, p \\ge 1$  且 $1 \\leq q \\leq \\text{MAXQ}$，然后同时翻转所有编号为 $c \\cdot 2^a \\cdot 3^{b-pj}$ 的硬币，其中 $j = 0, 1, 2, \\ldots, q$。\n\n可以发现这个游戏不能无限进行下去，当某位玩家无法继续操作上述操作时，便输掉了游戏。作为先手的 Alice，总是希望可以在比赛开始之前就知道自己能否获胜。她知道自己和 Bob 都是充分聪明的，所以在游戏过程中，两人都会最优化自己的策略并尽量保证自己处于不败的情形中。\n", "inputFormat": "\n本题有多组测试数据，第一行输入一个整数 $T$，表示总的数据组数。之后给出 $T$ 组数据。\n\n每组数据第一行输入两个整数 $n,\\text{MAXQ}$。\n\n第二行输入 $n$ 个整数，第 $i$ 个数表示第 $i$ 个硬币的初始状态，$0$ 表示反面朝上，$1$ 表示正面朝上。", "outputFormat": "输出共有 $T$ 行。对于每一组数据来说，如果 Alice 先手必胜，则输出 `win`，否则输出 `lose`。\n", "hint": "对于 $100\\%$ 的数据 $1\\le n \\le 30000,1 \\le \\text{MAXQ} \\le 20,t\\le 100$。\n", "locale": "zh-CN"}}}
