{"pid": "P10380", "type": "P", "difficulty": 4, "samples": [["3 2 37", "18"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化"], "title": "「ALFR Round 1」D 小山的元力", "background": "", "description": "小山有 $n$ 个相同的元素，他想将这 $n$ 个元素分为 $m$ 堆，显然有很多种分法。对于每种分法，定义 $a_i$ 为第 $i$ 堆的元素数量，$b_i=i!\\times a_i$（其中 $i!$ 表示 $i$ 的阶乘），以及 $c=\\sum\\limits_{i=1}^mb_i$。而小山的元力为所有分法的 $c$ 值之和。小山想知道他的元力是多少，由于答案可能很大，所以最终答案应对 $p$ 取模（保证 $p$ 为质数）。", "inputFormat": "一行三个整数 $n,m,p$，含义见**题目描述**。", "outputFormat": "一个数表示小山的元力。", "hint": "### 样例解释\n\n将 $3$ 个元素分为 $2$ 堆的方案为：\n\n1. `0 3`\n2. `1 2`\n3. `2 1`\n4. `3 0`\n\n小山的元力为：$(1!\\times0+2!\\times3)+(1!\\times1+2!\\times2)+(1!\\times2+2!\\times1)+(1!\\times3+2!\\times0)=18$。\n\n### 数据范围\n| 子任务 | 分值 | 限制 |\n| :----------: | :----------: | :----------: |\n| $0$ | $20$ | $n,m\\le5$ |\n| $1$ | $80$ | - |\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le10^6$，$1\\le p\\le10^7$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「ALFR Round 1」D 小山的元力", "background": "", "description": "小山有 $n$ 个相同的元素，他想将这 $n$ 个元素分为 $m$ 堆，显然有很多种分法。对于每种分法，定义 $a_i$ 为第 $i$ 堆的元素数量，$b_i=i!\\times a_i$（其中 $i!$ 表示 $i$ 的阶乘），以及 $c=\\sum\\limits_{i=1}^mb_i$。而小山的元力为所有分法的 $c$ 值之和。小山想知道他的元力是多少，由于答案可能很大，所以最终答案应对 $p$ 取模（保证 $p$ 为质数）。", "inputFormat": "一行三个整数 $n,m,p$，含义见**题目描述**。", "outputFormat": "一个数表示小山的元力。", "hint": "### 样例解释\n\n将 $3$ 个元素分为 $2$ 堆的方案为：\n\n1. `0 3`\n2. `1 2`\n3. `2 1`\n4. `3 0`\n\n小山的元力为：$(1!\\times0+2!\\times3)+(1!\\times1+2!\\times2)+(1!\\times2+2!\\times1)+(1!\\times3+2!\\times0)=18$。\n\n### 数据范围\n| 子任务 | 分值 | 限制 |\n| :----------: | :----------: | :----------: |\n| $0$ | $20$ | $n,m\\le5$ |\n| $1$ | $80$ | - |\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le10^6$，$1\\le p\\le10^7$。", "locale": "zh-CN"}}}
{"pid": "P10381", "type": "P", "difficulty": 5, "samples": [["3\n2\n1 2\n5\n2 4 5 0 1\n4\n0 4 4 4\n", "2\n9\n0\n"], ["1\n10\n1 1 4 5 1 4 1 9 1 9", "26\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "线段树", "并查集", "堆", "2024", "O2优化", "洛谷比赛"], "title": "「HOI R1」杂赛选比", "background": "你说得对，但是小 $\\iiint$ 在打 CF 时将 Earn or Unlock 错看成了下面的鬼畜样子，痛失 2h 遗憾离场，希望大家引以为戒。", "description": "给定一个长度为 $n$ 的数组 $a$，初始只有 $a_1$ 是已被解锁的。现在有一个整数 $i$，初始值为 $1$。现在小 $\\iiint$ 在对这个数组进行一个游戏：\n\n- 如果 $a_i$ 未被解锁，游戏结束。\n- 否则他可以将 $a_{i+1\\sim i+a_i}$ 设置成已被解锁的，或是获得 $a_i$ 个金币（如果 $a_i=0$ 则无法解锁任何元素），然后将 $i$ 加 $1$。\n\n请你求出游戏结束后你能获得的最大金币数量。", "inputFormat": "**本题有多组测试数据。**\n\n第一行一个整数 $T$，表示测试数据组数。\n\n对于每一组数据，第一行一个正整数 $n$。\n\n接下来一行 $n$ 个非负整数 $a_{1\\sim n}$。", "outputFormat": "对于每一组数据，一行一个数，表示答案。", "hint": "#### 【样例 1 解释】\n\n对于第一组数据，你可以解锁 $a_2$，再获得 $a_2$ 个金币。而对于第三组数据，你无法解锁 $a_2$，因此只能获得 $0$ 个金币。\n\n对于第二组数据，你可以解锁 $a_2,a_3$，并获得 $9$ 个金币。\n\n#### 【样例 2 解释】\n\n将第 $1,2,3,6$ 个位置用于解锁为最优方案。\n\n#### 【数据范围】\n\n对于 $100\\%$ 的数据，$1\\le n\\le10^5$，$0\\le a_i\\le10^5$，$T\\le 5$。\n\n|测试点编号|$n\\leq$|$a_i\\leq$|$T=$|特殊性质|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$10$|$0$|$1$|/|\n|$2\\sim3$|$10$|$5$|$1$|/|\n|$4\\sim5$|$600$|$600$|$1$|/|\n|$6\\sim8$|$5000$|$5000$|$1$|/|\n|$9\\sim10$|$10^5$|$5$|$5$|/|\n|$11\\sim12$|$5\\times10^4$|$10^5$|$5$|$a_i>n$|\n|$13\\sim20$|$10^5$|$10^5$|$5$|/|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「HOI R1」杂赛选比", "background": "你说得对，但是小 $\\iiint$ 在打 CF 时将 Earn or Unlock 错看成了下面的鬼畜样子，痛失 2h 遗憾离场，希望大家引以为戒。", "description": "给定一个长度为 $n$ 的数组 $a$，初始只有 $a_1$ 是已被解锁的。现在有一个整数 $i$，初始值为 $1$。现在小 $\\iiint$ 在对这个数组进行一个游戏：\n\n- 如果 $a_i$ 未被解锁，游戏结束。\n- 否则他可以将 $a_{i+1\\sim i+a_i}$ 设置成已被解锁的，或是获得 $a_i$ 个金币（如果 $a_i=0$ 则无法解锁任何元素），然后将 $i$ 加 $1$。\n\n请你求出游戏结束后你能获得的最大金币数量。", "inputFormat": "**本题有多组测试数据。**\n\n第一行一个整数 $T$，表示测试数据组数。\n\n对于每一组数据，第一行一个正整数 $n$。\n\n接下来一行 $n$ 个非负整数 $a_{1\\sim n}$。", "outputFormat": "对于每一组数据，一行一个数，表示答案。", "hint": "#### 【样例 1 解释】\n\n对于第一组数据，你可以解锁 $a_2$，再获得 $a_2$ 个金币。而对于第三组数据，你无法解锁 $a_2$，因此只能获得 $0$ 个金币。\n\n对于第二组数据，你可以解锁 $a_2,a_3$，并获得 $9$ 个金币。\n\n#### 【样例 2 解释】\n\n将第 $1,2,3,6$ 个位置用于解锁为最优方案。\n\n#### 【数据范围】\n\n对于 $100\\%$ 的数据，$1\\le n\\le10^5$，$0\\le a_i\\le10^5$，$T\\le 5$。\n\n|测试点编号|$n\\leq$|$a_i\\leq$|$T=$|特殊性质|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$10$|$0$|$1$|/|\n|$2\\sim3$|$10$|$5$|$1$|/|\n|$4\\sim5$|$600$|$600$|$1$|/|\n|$6\\sim8$|$5000$|$5000$|$1$|/|\n|$9\\sim10$|$10^5$|$5$|$5$|/|\n|$11\\sim12$|$5\\times10^4$|$10^5$|$5$|$a_i>n$|\n|$13\\sim20$|$10^5$|$10^5$|$5$|/|", "locale": "zh-CN"}}}
{"pid": "P10382", "type": "P", "difficulty": 7, "samples": [["6 -6\n-1 -1 -1 0 0 0", "-1 -1 -1 -1 -1 -1"], ["6 14\n0 1 4 0 1 4", "-1 1 4 5 1 4"], ["6 10\n0 0 0 0 0 0", "-1 -1 4 5 -1 4"], ["6 6\n1 1 0 0 0 0", "Rick"], ["6 40\n0 0 0 0 0 0", "Rick"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "Special Judge", "O2优化", "构造", "Ad-hoc", "分类讨论", "洛谷比赛"], "title": "「HOI R1」杂造选构", "background": "小 $\\iiint$ 跟这个烦人的构造没有任何关系。", "description": "若一个序列 $a$ 满足以下要求：\n\n- $a_i=-1$ 或 $a_i\\in [1,n]$。\n- 对于每个 $a_i\\not=-1$，将 $a_i\\to i$ 连边而形成的图不存在环。\n\n则称这个序列是合法的。\n\n现给定整数 $x$ 与序列 $a$，满足序列 $a$ 所有元素是 $[-1,n]$ 范围内的整数。请你将所有 $a_i=0$ 的位置替换成其他整数，使得 $\\sum\\limits ^{n} _{i=1} a_i = x$ 且 $a$ 是合法的。若不存在这样一种方案，则报告无解。", "inputFormat": "第一行两个整数 $n$ 和 $x$。\n\n第二行 $n$ 个整数，表示 $a$ 序列。保证 $\\forall a_i \\in [-1,n]$。", "outputFormat": "若无解，则说明你被骗了，因此输出一个字符串 `Rick`。否则输出 $n$ 个整数，表示替换完所有为 $0$ 的元素后的 $a$ 序列。", "hint": "**本题开启捆绑测试。**\n\n| Subtask | 分值 | $n \\le$ | $x \\le$ |特殊性质 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| #0 | $13$ | $15$ | $225$|无|\n| #1 | $24$ | $10^3$ | $10^9$|无|\n| #2 | $27$ | $10^5$ | $10^{18}$|有|\n| #3 | $36$ | $10^5$ | $10^{18}$|无|\n\n*特殊性质：保证 $\\forall a_i =0$。\n\n对于所有数据，满足 $1 \\le n \\le 10^5,-10^{18} \\le x \\le 10^{18}$。\n\n***\n\n**Special Judge 返回值对应表**\n\n- `Accepted.` 答案正确。\n- `Oops, your answer is wrong. 1` 答案为无解，选手代码输出有解。\n- `Oops, your answer is wrong. 2` 选手输出的 $\\sum a_i \\not = x$。\n- `Oops, your answer is wrong. 3` 选手输出中含有 $0$。\n- `Oops, your answer is wrong. 4` 选手输出中含有环。\n- `Oops, your answer is wrong. 5` 选手输出在填空的同时将输入的 $a_i \\not=0$ 的位置改动了。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「HOI R1」杂造选构", "background": "小 $\\iiint$ 跟这个烦人的构造没有任何关系。", "description": "若一个序列 $a$ 满足以下要求：\n\n- $a_i=-1$ 或 $a_i\\in [1,n]$。\n- 对于每个 $a_i\\not=-1$，将 $a_i\\to i$ 连边而形成的图不存在环。\n\n则称这个序列是合法的。\n\n现给定整数 $x$ 与序列 $a$，满足序列 $a$ 所有元素是 $[-1,n]$ 范围内的整数。请你将所有 $a_i=0$ 的位置替换成其他整数，使得 $\\sum\\limits ^{n} _{i=1} a_i = x$ 且 $a$ 是合法的。若不存在这样一种方案，则报告无解。", "inputFormat": "第一行两个整数 $n$ 和 $x$。\n\n第二行 $n$ 个整数，表示 $a$ 序列。保证 $\\forall a_i \\in [-1,n]$。", "outputFormat": "若无解，则说明你被骗了，因此输出一个字符串 `Rick`。否则输出 $n$ 个整数，表示替换完所有为 $0$ 的元素后的 $a$ 序列。", "hint": "**本题开启捆绑测试。**\n\n| Subtask | 分值 | $n \\le$ | $x \\le$ |特殊性质 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| #0 | $13$ | $15$ | $225$|无|\n| #1 | $24$ | $10^3$ | $10^9$|无|\n| #2 | $27$ | $10^5$ | $10^{18}$|有|\n| #3 | $36$ | $10^5$ | $10^{18}$|无|\n\n*特殊性质：保证 $\\forall a_i =0$。\n\n对于所有数据，满足 $1 \\le n \\le 10^5,-10^{18} \\le x \\le 10^{18}$。\n\n***\n\n**Special Judge 返回值对应表**\n\n- `Accepted.` 答案正确。\n- `Oops, your answer is wrong. 1` 答案为无解，选手代码输出有解。\n- `Oops, your answer is wrong. 2` 选手输出的 $\\sum a_i \\not = x$。\n- `Oops, your answer is wrong. 3` 选手输出中含有 $0$。\n- `Oops, your answer is wrong. 4` 选手输出中含有环。\n- `Oops, your answer is wrong. 5` 选手输出在填空的同时将输入的 $a_i \\not=0$ 的位置改动了。", "locale": "zh-CN"}}}
{"pid": "P10383", "type": "P", "difficulty": 6, "samples": [["6 8 0\n540000 350000 110000 130000 170000 970000\n2000 5000 1000 1000 97000 17000 143000 210000", "9 10"]], "limits": {"time": [200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "O2优化", "洛谷比赛"], "title": "「HOI R1」杂分选约", "background": "**请注意本题并不寻常的时间限制。**\n\n由于 python 自带对于高精度乘法的实现，并且运行效率较高，导致其编写的暴力程序，在一般的时间限制下可以通过绝大部分点。故本题时限开到 $200\\text{ms}$。\n***\n\n黄总是一名计算很强的数学老师，以黄氏约分而闻名。现在他请小 $\\iiint$ A 了这道题。但小 $\\iiint$ **似乎**有点菜，所以求助于你。", "description": "把\n$$\\dfrac{\\displaystyle\\prod_{i=1}^n\na_i}{\\displaystyle\\prod_{j=1}^m b_j}$$\n表示为*最简分数 $^{[1]}$* $\\dfrac{p}{q}$，求 $p$ 和 $q$。\n\n好心的同学还给了小 $\\iiint$ 一个整数 $C$，即数据点所在的 Subtask。", "inputFormat": "第一行三个整数 $n,m$ 和 $C$。\n\n第二行 $n$ 个整数 $a_{1\\dots n}$。\n\n第三行 $m$ 个整数 $b_{1\\dots m}$。", "outputFormat": "第一行两个数 $p$ 和 $q$。", "hint": "**注释**\n\n$[1]$：[百度百科](https://baike.baidu.com/item/%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/2821376?fr=ge_ala)：最简分数，是分子、分母只有公因数 $1$ 的分数，或者说分子和分母互质的分数，又称既约分数。如：二分之一，三分之二，九分之八，八分之三等等。\n***\n**样例解释**\n\n$\\dfrac{540000\\times350000\\times110000\\times130000\\times170000\\times970000}{2000\\times5000\\times1000\\times1000\\times97000\\times17000\\times143000\\times210000}=\\dfrac{9}{10}$，$\\gcd(9,10)=1$\n***\n**数据规模与约定**\n\n**本题采用捆绑测试。**\n\n|Subtask|分值|数据范围|\n|-|-|-|\n|#0|0|同样例|\n|#1|$5$|$1\\le n,m\\le500$，$1\\le a_i,b_i\\le9\\times10^{18}$，$1\\le p,q\\le3\\times10^9$|\n|#2|$5$|$1\\le n,m\\le25000$，$1\\le a_i,b_i\\le9\\times10^{18}$，$1\\le p,q\\le10$|\n|#3|$10$|$1\\le n,m\\le5000$，$1\\le a_i,b_i\\le3\\times10^9$，$1\\le p,q\\le3\\times10^9$|\n|#4|$15$|$1\\le n,m\\le10000$，$1\\le a_i,b_i\\le9\\times10^{18}$，$1\\le p,q\\le3\\times10^9$|\n|#5|$20$|$1\\le n,m\\le25000$，$1\\le a_i,b_i\\le9\\times10^{18}$，$1\\le p\\le3\\times10^9$，$q=1$|\n|#6|$10$|$1\\le n,m\\le25000$，$1\\le a_i,b_i\\le9\\times10^{18}$，$1\\le p\\le3\\times10^9$,$1\\le q \\le25000$|\n|#7|$20$|$1\\le n,m\\le25000$，$1\\le a_i,b_i\\le9\\times10^{18}$，$1\\le p,q\\le3\\times10^9$|\n|#8|$10$|$1\\le n,m\\le10^6$，$1\\le a_i,b_i\\le10^6$，$1\\le p,q\\le3\\times10^9$|\n|#9|$5$|$1\\le n,m\\le10^6$，$1\\le a_i,b_i\\le9\\times10^{18}$，$1\\le p,q\\le3\\times10^9$|\n***\n**提示**\n\n~~高精度狗都不写。~~\n\n本题时限较小且输入量较大，若你认为自己的算法复杂度正确，请尝试优化读写速度。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「HOI R1」杂分选约", "background": "**请注意本题并不寻常的时间限制。**\n\n由于 python 自带对于高精度乘法的实现，并且运行效率较高，导致其编写的暴力程序，在一般的时间限制下可以通过绝大部分点。故本题时限开到 $200\\text{ms}$。\n***\n\n黄总是一名计算很强的数学老师，以黄氏约分而闻名。现在他请小 $\\iiint$ A 了这道题。但小 $\\iiint$ **似乎**有点菜，所以求助于你。", "description": "把\n$$\\dfrac{\\displaystyle\\prod_{i=1}^n\na_i}{\\displaystyle\\prod_{j=1}^m b_j}$$\n表示为*最简分数 $^{[1]}$* $\\dfrac{p}{q}$，求 $p$ 和 $q$。\n\n好心的同学还给了小 $\\iiint$ 一个整数 $C$，即数据点所在的 Subtask。", "inputFormat": "第一行三个整数 $n,m$ 和 $C$。\n\n第二行 $n$ 个整数 $a_{1\\dots n}$。\n\n第三行 $m$ 个整数 $b_{1\\dots m}$。", "outputFormat": "第一行两个数 $p$ 和 $q$。", "hint": "**注释**\n\n$[1]$：[百度百科](https://baike.baidu.com/item/%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/2821376?fr=ge_ala)：最简分数，是分子、分母只有公因数 $1$ 的分数，或者说分子和分母互质的分数，又称既约分数。如：二分之一，三分之二，九分之八，八分之三等等。\n***\n**样例解释**\n\n$\\dfrac{540000\\times350000\\times110000\\times130000\\times170000\\times970000}{2000\\times5000\\times1000\\times1000\\times97000\\times17000\\times143000\\times210000}=\\dfrac{9}{10}$，$\\gcd(9,10)=1$\n***\n**数据规模与约定**\n\n**本题采用捆绑测试。**\n\n|Subtask|分值|数据范围|\n|-|-|-|\n|#0|0|同样例|\n|#1|$5$|$1\\le n,m\\le500$，$1\\le a_i,b_i\\le9\\times10^{18}$，$1\\le p,q\\le3\\times10^9$|\n|#2|$5$|$1\\le n,m\\le25000$，$1\\le a_i,b_i\\le9\\times10^{18}$，$1\\le p,q\\le10$|\n|#3|$10$|$1\\le n,m\\le5000$，$1\\le a_i,b_i\\le3\\times10^9$，$1\\le p,q\\le3\\times10^9$|\n|#4|$15$|$1\\le n,m\\le10000$，$1\\le a_i,b_i\\le9\\times10^{18}$，$1\\le p,q\\le3\\times10^9$|\n|#5|$20$|$1\\le n,m\\le25000$，$1\\le a_i,b_i\\le9\\times10^{18}$，$1\\le p\\le3\\times10^9$，$q=1$|\n|#6|$10$|$1\\le n,m\\le25000$，$1\\le a_i,b_i\\le9\\times10^{18}$，$1\\le p\\le3\\times10^9$,$1\\le q \\le25000$|\n|#7|$20$|$1\\le n,m\\le25000$，$1\\le a_i,b_i\\le9\\times10^{18}$，$1\\le p,q\\le3\\times10^9$|\n|#8|$10$|$1\\le n,m\\le10^6$，$1\\le a_i,b_i\\le10^6$，$1\\le p,q\\le3\\times10^9$|\n|#9|$5$|$1\\le n,m\\le10^6$，$1\\le a_i,b_i\\le9\\times10^{18}$，$1\\le p,q\\le3\\times10^9$|\n***\n**提示**\n\n~~高精度狗都不写。~~\n\n本题时限较小且输入量较大，若你认为自己的算法复杂度正确，请尝试优化读写速度。", "locale": "zh-CN"}}}
{"pid": "P10384", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "交互题", "Special Judge", "概率论", "洛谷比赛"], "title": "「HOI R1」杂交选种", "background": "$\\clubsuit$ 星球盛产“代马”，其优越的速度与耗能使得它风靡整个银河系。可小 $\\iiint$ 并不满足于此，他想培育出更好的“代马”，并取代掉还在用传统能源的落后四足兽。于是，他开始研究基因技术……\n\n**本题仅支持 C++ 语言提交。**\n\n**由于技术限制，请勿使用 C++14 (GCC 9) 语言提交，否则将会得到 Compile Error 的结果。**\n\n你的代码中需如下进行 `query` 和 `cross` 函数的声明：\n\n```cpp\nchar query(int k);\nvoid cross(int i, int j);\n```\n\n调用 $10^6$ 次 `query` 与 `cross` 函数的时间不超过 50 毫秒，除这两个函数所占用的时间外，交互库运行所占用的时间不超过 100 毫秒。", "description": "#### 【形式化题意】\n\n**这是一道交互题。**\n\n定义 **基因** 为一个字符，其内容为 $\\verb!A!$ 或 $\\verb!a!$。定义 **基因型** 为由两个基因组成，且大写字母在小写字母之前的字符串。也即 $\\{\\verb!aa!,\\verb!Aa!,\\verb!AA!\\}$ 中的一种。一个基因型的 **表现** 如下：\n\n- 若基因型中含有 $\\verb!A!$，则表现为 $\\verb!A!$。\n- 否则，表现为 $\\verb!a!$。\n\n两个基因型可以相互 **杂交**，其定义如下：\n\n- 在两个基因型中各均匀随机取一个基因，并将两个基因组合成基因型作为结果输出。\n\n小 $\\iiint$ 有 $n$ 个基因型，编号为 $1,2,\\cdots,n$。每次询问可以给交互库两个不同的编号 $i,j$。若当前是第 $k$ 次杂交，交互库会新建一个编号为 $n+k$ 的基因型，其基因型为 $i,j$ 杂交后的结果。\n\n你可以在时限范围内任意次查询编号为 $x$ 的种子的表现。你需要在 $4.5\\times10^5$ 次杂交内，求出初始给定的 $n$ 个基因型。\n\n### 实现细节\n\n**你不需要，也不应该实现主函数。** 你需要实现下面的函数：\n\n```cpp\nvector<string> guess(int n)\n```\n\n- $n$ 表示初始基因型个数。\n- 该函数应当返回一个长度恰好为 $n$ 的数组，数组中的每一个元素是一个长度为二的字符串，表示你所求出的基因型。**你需要保证大写字母在小写字母的前面**。\n- 对于每个测试点，该函数被恰好调用一次。\n\n该函数可调用以下函数：\n\n```cpp\nchar query(int k)\n```\n\n- $k$ 表示你要查询的基因型的编号。**你需要保证这个编号对应的基因型存在**。\n- 该函数将返回该基因型的表现。\n- 该函数可以在时限内被调用任意次。\n\n```cpp\nvoid cross(int i, int j)\n```\n\n- $i,j$ 代表你要杂交的两个基因的编号。**你需要保证 $i\\not=j$ 且对应的基因型存在**。\n- 若是第 $k$ 次调用该函数，该函数会新建一个编号为 $n+k$ 的基因型，其基因型为 $i,j$ 杂交后的结果。保证杂交过程为均匀随机。\n- 你最多可以调用该函数 $4.5\\times10^5$ 次。\n- 评测程序不是适应性的。也就是说，所有初始元素的基因型在 `guess` 函数被调用前已经确定。", "inputFormat": "", "outputFormat": "", "hint": "#### 【交互示例】\n\n以下为 $n=2$，基因型为 $\\{\\verb!Aa!,\\verb!AA!\\}$ 时一种可能的交互过程。\n\n|选手程序|交互库|\n|:-:|:-:|\n||`guess(2)`|\n|`cross(1,2)`||\n||$\\{\\verb!Aa!,\\verb!AA!,\\verb!Aa!\\}$|\n|`cross(1,3)`||\n||$\\{\\verb!Aa!,\\verb!AA!,\\verb!Aa!,\\verb!aa!\\}$|\n|`query(4)`||\n||$\\verb!a!$|\n|$\\{\\verb!Aa!,\\verb!AA!\\}$||\n||`Ok,accepted.`|\n\n#### 【约束条件】\n\n+ $2\\le n\\le 2\\times10^4$，$n$ 为偶数。\n+ 每次程序运行时将恰好调用一次 `guess()` 函数。\n+ 保证交互库是非自适应性的，即所有初始元素的基因型不在交互过程中发生改变。\n\n#### 【子任务】\n\n|Subtask|分值|$n\\le$|特殊性质|\n|:-:|:-:|:-:|:-:|\n|$0$|$0$|$2$|无|\n|$1$|$5$|$2\\times10^4$|保证不存在 $\\verb!Aa!$|\n|$2$|$15$|$500$|无|\n|$3$|$20$|$2\\times10^4$|保证至少存在一个 $\\verb!aa!$|\n|$4$|$25$|$5\\times10^3$|无|\n|$5$|$35$|$2\\times10^4$|无|\n\n对于所有数据，$2\\le n\\le 2\\times10^4$，保证 $n$ 为偶数。\n\n由于本题涉及概率与期望，如果你确定你的算法无误，可以尝试多交几发。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「HOI R1」杂交选种", "background": "$\\clubsuit$ 星球盛产“代马”，其优越的速度与耗能使得它风靡整个银河系。可小 $\\iiint$ 并不满足于此，他想培育出更好的“代马”，并取代掉还在用传统能源的落后四足兽。于是，他开始研究基因技术……\n\n**本题仅支持 C++ 语言提交。**\n\n**由于技术限制，请勿使用 C++14 (GCC 9) 语言提交，否则将会得到 Compile Error 的结果。**\n\n你的代码中需如下进行 `query` 和 `cross` 函数的声明：\n\n```cpp\nchar query(int k);\nvoid cross(int i, int j);\n```\n\n调用 $10^6$ 次 `query` 与 `cross` 函数的时间不超过 50 毫秒，除这两个函数所占用的时间外，交互库运行所占用的时间不超过 100 毫秒。", "description": "#### 【形式化题意】\n\n**这是一道交互题。**\n\n定义 **基因** 为一个字符，其内容为 $\\verb!A!$ 或 $\\verb!a!$。定义 **基因型** 为由两个基因组成，且大写字母在小写字母之前的字符串。也即 $\\{\\verb!aa!,\\verb!Aa!,\\verb!AA!\\}$ 中的一种。一个基因型的 **表现** 如下：\n\n- 若基因型中含有 $\\verb!A!$，则表现为 $\\verb!A!$。\n- 否则，表现为 $\\verb!a!$。\n\n两个基因型可以相互 **杂交**，其定义如下：\n\n- 在两个基因型中各均匀随机取一个基因，并将两个基因组合成基因型作为结果输出。\n\n小 $\\iiint$ 有 $n$ 个基因型，编号为 $1,2,\\cdots,n$。每次询问可以给交互库两个不同的编号 $i,j$。若当前是第 $k$ 次杂交，交互库会新建一个编号为 $n+k$ 的基因型，其基因型为 $i,j$ 杂交后的结果。\n\n你可以在时限范围内任意次查询编号为 $x$ 的种子的表现。你需要在 $4.5\\times10^5$ 次杂交内，求出初始给定的 $n$ 个基因型。\n\n### 实现细节\n\n**你不需要，也不应该实现主函数。** 你需要实现下面的函数：\n\n```cpp\nvector<string> guess(int n)\n```\n\n- $n$ 表示初始基因型个数。\n- 该函数应当返回一个长度恰好为 $n$ 的数组，数组中的每一个元素是一个长度为二的字符串，表示你所求出的基因型。**你需要保证大写字母在小写字母的前面**。\n- 对于每个测试点，该函数被恰好调用一次。\n\n该函数可调用以下函数：\n\n```cpp\nchar query(int k)\n```\n\n- $k$ 表示你要查询的基因型的编号。**你需要保证这个编号对应的基因型存在**。\n- 该函数将返回该基因型的表现。\n- 该函数可以在时限内被调用任意次。\n\n```cpp\nvoid cross(int i, int j)\n```\n\n- $i,j$ 代表你要杂交的两个基因的编号。**你需要保证 $i\\not=j$ 且对应的基因型存在**。\n- 若是第 $k$ 次调用该函数，该函数会新建一个编号为 $n+k$ 的基因型，其基因型为 $i,j$ 杂交后的结果。保证杂交过程为均匀随机。\n- 你最多可以调用该函数 $4.5\\times10^5$ 次。\n- 评测程序不是适应性的。也就是说，所有初始元素的基因型在 `guess` 函数被调用前已经确定。", "inputFormat": "", "outputFormat": "", "hint": "#### 【交互示例】\n\n以下为 $n=2$，基因型为 $\\{\\verb!Aa!,\\verb!AA!\\}$ 时一种可能的交互过程。\n\n|选手程序|交互库|\n|:-:|:-:|\n||`guess(2)`|\n|`cross(1,2)`||\n||$\\{\\verb!Aa!,\\verb!AA!,\\verb!Aa!\\}$|\n|`cross(1,3)`||\n||$\\{\\verb!Aa!,\\verb!AA!,\\verb!Aa!,\\verb!aa!\\}$|\n|`query(4)`||\n||$\\verb!a!$|\n|$\\{\\verb!Aa!,\\verb!AA!\\}$||\n||`Ok,accepted.`|\n\n#### 【约束条件】\n\n+ $2\\le n\\le 2\\times10^4$，$n$ 为偶数。\n+ 每次程序运行时将恰好调用一次 `guess()` 函数。\n+ 保证交互库是非自适应性的，即所有初始元素的基因型不在交互过程中发生改变。\n\n#### 【子任务】\n\n|Subtask|分值|$n\\le$|特殊性质|\n|:-:|:-:|:-:|:-:|\n|$0$|$0$|$2$|无|\n|$1$|$5$|$2\\times10^4$|保证不存在 $\\verb!Aa!$|\n|$2$|$15$|$500$|无|\n|$3$|$20$|$2\\times10^4$|保证至少存在一个 $\\verb!aa!$|\n|$4$|$25$|$5\\times10^3$|无|\n|$5$|$35$|$2\\times10^4$|无|\n\n对于所有数据，$2\\le n\\le 2\\times10^4$，保证 $n$ 为偶数。\n\n由于本题涉及概率与期望，如果你确定你的算法无误，可以尝试多交几发。", "locale": "zh-CN"}}}
{"pid": "P10385", "type": "P", "difficulty": 1, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["模拟", "2024", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 A] 艺术与篮球", "background": "", "description": "小蓝出生在一个艺术与运动并重的家庭中。  \n妈妈是位书法家，她希望小蓝能通过练习书法，继承她的艺术天赋，并练就一手好字。爸爸是一名篮球教练，他希望小蓝能通过篮球锻炼身体，培养运\n动的激情和团队合作的精神。  \n为了既满足妈妈的期望，又不辜负爸爸的心意，小蓝决定根据日期的笔画数来安排自己的练习。首先，他会将当天的日期按照 `YYYYMMDD` 的格式\n转换成一个 $8$ 位数，然后将这 $8$ 位数对应到汉字上，计算这些汉字的总笔画数。如果总笔画数超过 $50$，他就去练习篮球；如果总笔画数不超过 $50$，他就去练习书法。  \n例如，在 $2024$ 年 $1$ 月 $1$ 日这天，日期可表示为一个 $8$ 位数字 $20240101$，其转换为汉字是“二零二四零一零一”。日期的总笔画数为 $2 + 13 + 2 + 5 + 13 +\n1 + 13 + 1 = 50$，因此在这天，小蓝会去练习书法。  \n以下是汉字的笔画数对照表：\n\n|汉字|笔画数|汉字|笔画数|\n| -----------: | -----------: | -----------: | -----------: |\n|零 |$13 $|五 |$4$|\n|一 |$1$|  六 |$4$|\n|二 |$2$|  七 |$2$|\n|三 |$3$|  八 |$2$|\n|四 |$5$| 九 |$2$|\n\n现在，请你帮助小蓝统计一下，在 $2000$ 年 $1$ 月 $1$ 日到 $2024$ 年 $4$ 月 $13$ 日\n这段时间内，小蓝有多少天是在练习篮球？", "inputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "outputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 A] 艺术与篮球", "background": "", "description": "小蓝出生在一个艺术与运动并重的家庭中。  \n妈妈是位书法家，她希望小蓝能通过练习书法，继承她的艺术天赋，并练就一手好字。爸爸是一名篮球教练，他希望小蓝能通过篮球锻炼身体，培养运\n动的激情和团队合作的精神。  \n为了既满足妈妈的期望，又不辜负爸爸的心意，小蓝决定根据日期的笔画数来安排自己的练习。首先，他会将当天的日期按照 `YYYYMMDD` 的格式\n转换成一个 $8$ 位数，然后将这 $8$ 位数对应到汉字上，计算这些汉字的总笔画数。如果总笔画数超过 $50$，他就去练习篮球；如果总笔画数不超过 $50$，他就去练习书法。  \n例如，在 $2024$ 年 $1$ 月 $1$ 日这天，日期可表示为一个 $8$ 位数字 $20240101$，其转换为汉字是“二零二四零一零一”。日期的总笔画数为 $2 + 13 + 2 + 5 + 13 +\n1 + 13 + 1 = 50$，因此在这天，小蓝会去练习书法。  \n以下是汉字的笔画数对照表：\n\n|汉字|笔画数|汉字|笔画数|\n| -----------: | -----------: | -----------: | -----------: |\n|零 |$13 $|五 |$4$|\n|一 |$1$|  六 |$4$|\n|二 |$2$|  七 |$2$|\n|三 |$3$|  八 |$2$|\n|四 |$5$| 九 |$2$|\n\n现在，请你帮助小蓝统计一下，在 $2000$ 年 $1$ 月 $1$ 日到 $2024$ 年 $4$ 月 $13$ 日\n这段时间内，小蓝有多少天是在练习篮球？", "inputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "outputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10386", "type": "P", "difficulty": 3, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["2024", "深度优先搜索 DFS", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 A] 五子棋对弈", "background": "", "description": "“在五子棋的对弈中，友谊的小船说翻就翻？” 不！对小蓝和小桥来说，五子棋不仅是棋盘上的较量，更是心与心之间的沟通。这两位挚友秉承着 “友谊第一，比赛第二” 的宗旨，决定在一块 $5 × 5$ 的棋盘上，用黑白两色的棋子来决出胜负。但他们又都不忍心让对方失落，于是决定用一场**和棋（平局）** 作为彼此友谊的见证。\n比赛遵循以下规则：\n1. 棋盘规模：比赛在一个 $5 × 5$ 的方格棋盘上进行，共有 $25$ 个格子供下棋使用。\n2. 棋子类型：两种棋子，黑棋与白棋，代表双方。小蓝持白棋，小桥持黑棋。\n3. 先手规则：白棋（小蓝）具有先手优势，即在棋盘空白时率先落子（下棋）。\n4. 轮流落子：玩家们交替在棋盘上放置各自的棋子，每次仅放置一枚。\n5. 胜利条件：率先在横线、竖线或斜线上形成连续的五个同色棋子的一方获胜。\n6. 平局条件：当所有 $25$ 个棋盘格都被下满棋子，而未决出胜负时，游戏以平局告终。\n\n在这一设定下，小蓝和小桥想知道，有多少种不同的棋局情况（终局不同看成不同情况，终局相同而落子顺序不同看成同一种情况），既确保棋盘下满又保证比赛结果为平局。", "inputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。\n\n", "outputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。\n\n", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 A] 五子棋对弈", "background": "", "description": "“在五子棋的对弈中，友谊的小船说翻就翻？” 不！对小蓝和小桥来说，五子棋不仅是棋盘上的较量，更是心与心之间的沟通。这两位挚友秉承着 “友谊第一，比赛第二” 的宗旨，决定在一块 $5 × 5$ 的棋盘上，用黑白两色的棋子来决出胜负。但他们又都不忍心让对方失落，于是决定用一场**和棋（平局）** 作为彼此友谊的见证。\n比赛遵循以下规则：\n1. 棋盘规模：比赛在一个 $5 × 5$ 的方格棋盘上进行，共有 $25$ 个格子供下棋使用。\n2. 棋子类型：两种棋子，黑棋与白棋，代表双方。小蓝持白棋，小桥持黑棋。\n3. 先手规则：白棋（小蓝）具有先手优势，即在棋盘空白时率先落子（下棋）。\n4. 轮流落子：玩家们交替在棋盘上放置各自的棋子，每次仅放置一枚。\n5. 胜利条件：率先在横线、竖线或斜线上形成连续的五个同色棋子的一方获胜。\n6. 平局条件：当所有 $25$ 个棋盘格都被下满棋子，而未决出胜负时，游戏以平局告终。\n\n在这一设定下，小蓝和小桥想知道，有多少种不同的棋局情况（终局不同看成不同情况，终局相同而落子顺序不同看成同一种情况），既确保棋盘下满又保证比赛结果为平局。", "inputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。\n\n", "outputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。\n\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10387", "type": "P", "difficulty": 2, "samples": [["3 6\n5 2\n2 4\n3 2", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2024", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 A] 训练士兵", "background": "", "description": "在蓝桥王国中，有 $n$ 名士兵，这些士兵需要接受一系列特殊的训练，以提升他们的战斗技能。对于第 $i$ 名士兵来说，进行一次训练所需的成本为 $p_i$ 枚金币，而要想成为顶尖战士，他至少需要进行 $c_i$ 次训练。  \n为了确保训练的高效性，王国推出了一种组团训练的方案。该方案包含每位士兵所需的一次训练，且总共只需支付 $S$ 枚金币（组团训练方案可以多次购买，即士兵可以进行多次组团训练）。  \n作为训练指挥官，请你计算出最少需要花费多少金币，才能使得所有的士兵都成为顶尖战士？", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $S $，用一个空格分隔，表示士兵的数量和进行一次组团训练所需的金币数。  \n接下来的 $n$ 行，每行包含两个整数 $p_i$ 和 $c_i$，用一个空格分隔，表示第 $i$ 名士兵进行一次训练的金币成本和要成为顶尖战士所需的训练次数。", "outputFormat": "输出一行包含一个整数，表示使所有士兵成为顶尖战士所需的最少金币数。", "hint": "花费金币最少的训练方式为：进行 $2$ 次组团训练，花费 $2 × 6 = 12$ 枚金币，此时士兵 $1, 3$ 已成为顶尖战士；再花费 $4$ 枚金币，让士兵 $2$ 进行两次训练，成为顶尖战士。总花费为 $12 + 4 = 16$。\n\n对于 $40\\%$ 的评测用例，$1 ≤ n ≤ 10^3，1 ≤ p_i\n, c_i ≤ 10^5，1 ≤ S ≤ 10^7$。\n\n对于所有评测用例，$1 ≤ n ≤ 10^5，1 ≤ p_i\n, c_i ≤ 10^6，1 ≤ S ≤ 10^{10}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 A] 训练士兵", "background": "", "description": "在蓝桥王国中，有 $n$ 名士兵，这些士兵需要接受一系列特殊的训练，以提升他们的战斗技能。对于第 $i$ 名士兵来说，进行一次训练所需的成本为 $p_i$ 枚金币，而要想成为顶尖战士，他至少需要进行 $c_i$ 次训练。  \n为了确保训练的高效性，王国推出了一种组团训练的方案。该方案包含每位士兵所需的一次训练，且总共只需支付 $S$ 枚金币（组团训练方案可以多次购买，即士兵可以进行多次组团训练）。  \n作为训练指挥官，请你计算出最少需要花费多少金币，才能使得所有的士兵都成为顶尖战士？", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $S $，用一个空格分隔，表示士兵的数量和进行一次组团训练所需的金币数。  \n接下来的 $n$ 行，每行包含两个整数 $p_i$ 和 $c_i$，用一个空格分隔，表示第 $i$ 名士兵进行一次训练的金币成本和要成为顶尖战士所需的训练次数。", "outputFormat": "输出一行包含一个整数，表示使所有士兵成为顶尖战士所需的最少金币数。", "hint": "花费金币最少的训练方式为：进行 $2$ 次组团训练，花费 $2 × 6 = 12$ 枚金币，此时士兵 $1, 3$ 已成为顶尖战士；再花费 $4$ 枚金币，让士兵 $2$ 进行两次训练，成为顶尖战士。总花费为 $12 + 4 = 16$。\n\n对于 $40\\%$ 的评测用例，$1 ≤ n ≤ 10^3，1 ≤ p_i\n, c_i ≤ 10^5，1 ≤ S ≤ 10^7$。\n\n对于所有评测用例，$1 ≤ n ≤ 10^5，1 ≤ p_i\n, c_i ≤ 10^6，1 ≤ S ≤ 10^{10}$。", "locale": "zh-CN"}}}
{"pid": "P10388", "type": "P", "difficulty": 4, "samples": [["2 2\n10 20\n10 30\n1 2\n2 1", "1"], ["5 4\n10 20 30 40 50\n10 40 20 30\n1 2\n1 3\n2 4\n3 5\n1 2\n1 3\n3 4", "2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2024", "哈希 hashing", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 A] 团建", "background": "", "description": "小蓝正在和朋友们团建，有一个游戏项目需要两人合作，两个人分别拿到一棵大小为 $n$ 和 $m$ 的树，树上的每个结点上有一个正整数权值。  \n两个人需要从各自树的根结点 $1$ 出发走向某个叶结点，从根到这个叶结点的路径上经过的所有结点上的权值构成了一个正整数序列，两人的序列的最长公共前缀即为他们的得分。给出两棵树，请计算两个人最多的得分是多少。", "inputFormat": "输入的第一行包含两个正整数 $n, m $，用一个空格分隔。  \n第二行包含 $n$ 个正整数 $c_1, c_2,\\cdots , c_n $，相邻整数之间使用一个空格分隔，其中 $c_i$ 表示第一棵树结点 $i$ 上的权值。  \n第三行包含 $m$ 个正整数 $d_1, d_2,\\cdots, d_m$，相邻整数之间使用一个空格分隔，其中 $d_i$ 表示第二棵树结点 $i$ 上的权值。  \n接下来 $n - 1$ 行，每行包含两个正整数 $u_i\n, v_i$ 表示第一棵树中包含一条 $u_i$ 和\n$v_i$ 之间的边。  \n接下来 $m - 1$ 行，每行包含两个正整数 $p_i\n, q_i$ 表示第二棵树中包含一条 $p_i$\n和 $q_i$ 之间的边。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "对于 $20\\%$ 的评测用例，$1 ≤ n, m ≤ 500 $；  \n对于所有评测用例，$1 ≤ n, m ≤ 2 × 10^5，1 ≤ c_i\n, d_i ≤ 10^8 ，1 ≤ u_i\n, v_i ≤ n ，\n1 ≤ p_i\n, q_i ≤ m $，对于任意结点，其儿子结点的权重互不相同。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 A] 团建", "background": "", "description": "小蓝正在和朋友们团建，有一个游戏项目需要两人合作，两个人分别拿到一棵大小为 $n$ 和 $m$ 的树，树上的每个结点上有一个正整数权值。  \n两个人需要从各自树的根结点 $1$ 出发走向某个叶结点，从根到这个叶结点的路径上经过的所有结点上的权值构成了一个正整数序列，两人的序列的最长公共前缀即为他们的得分。给出两棵树，请计算两个人最多的得分是多少。", "inputFormat": "输入的第一行包含两个正整数 $n, m $，用一个空格分隔。  \n第二行包含 $n$ 个正整数 $c_1, c_2,\\cdots , c_n $，相邻整数之间使用一个空格分隔，其中 $c_i$ 表示第一棵树结点 $i$ 上的权值。  \n第三行包含 $m$ 个正整数 $d_1, d_2,\\cdots, d_m$，相邻整数之间使用一个空格分隔，其中 $d_i$ 表示第二棵树结点 $i$ 上的权值。  \n接下来 $n - 1$ 行，每行包含两个正整数 $u_i\n, v_i$ 表示第一棵树中包含一条 $u_i$ 和\n$v_i$ 之间的边。  \n接下来 $m - 1$ 行，每行包含两个正整数 $p_i\n, q_i$ 表示第二棵树中包含一条 $p_i$\n和 $q_i$ 之间的边。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "对于 $20\\%$ 的评测用例，$1 ≤ n, m ≤ 500 $；  \n对于所有评测用例，$1 ≤ n, m ≤ 2 × 10^5，1 ≤ c_i\n, d_i ≤ 10^8 ，1 ≤ u_i\n, v_i ≤ n ，\n1 ≤ p_i\n, q_i ≤ m $，对于任意结点，其儿子结点的权重互不相同。", "locale": "zh-CN"}}}
{"pid": "P10389", "type": "P", "difficulty": 4, "samples": [["5 3 1\n3 2 5 2 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "二分", "2024", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 A] 成绩统计", "background": "", "description": "小蓝的班上有 $n$ 个人，一次考试之后小蓝想统计同学们的成绩，第 $i$ 名同学的成绩为 $a_i$。当小蓝统计完前 $x$ 名同学的成绩后，他可以从 $1 \\sim x$ 中选出任意 $k$ 名同学的成绩，计算出这 $k$ 个成绩的方差。小蓝至少要检查多少个人的成\n绩，才有可能选出 $k$ 名同学，他们的方差小于一个给定的值 $T$？\n提示：$k$ 个数 $v_1, v_2, \\cdots , v_k$ 的方差 $\\sigma^2$ 定义为：$\\sigma^2=\\dfrac  {\\sum_{i=1}^k(v_i-\\bar v)^2} k$，其中 $\\bar v$ 表示\n$v_i$ 的平均值，$\\bar v = \\dfrac {\\sum_{i=1}^k v_i} k$。", "inputFormat": "输入的第一行包含三个正整数 $n, k, T $，相邻整数之间使用一个空格分隔。\n\n第二行包含 $n$ 个正整数 $a_1, a2, \\cdots, a_n$ ，相邻整数之间使用一个空格分隔。", "outputFormat": "输出一行包含一个整数表示答案。如果不能满足条件，输出 $-1$ 。", "hint": "检查完前三名同学的成绩后，只能选出 $3, 2, 5 $，方差为 $1.56 $；\n\n检查完前四名同学的成绩后，可以选出 $3, 2, 2 $，方差为 $0.22 < 1 $，所以答案为 $4 $。\n\n对于 $10\\%$ 的评测用例，保证 $1 ≤ n, k ≤ 10^2$；  \n对于 $30\\%$ 的评测用例，保证 $1 ≤ n, k ≤ 10^3$ ；  \n对于所有评测用例，保证 $1 ≤ n, k ≤ 10^5 $，$1 ≤ T ≤ 2\n^{31} -1 $，$1 ≤ a_i ≤ n $。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 A] 成绩统计", "background": "", "description": "小蓝的班上有 $n$ 个人，一次考试之后小蓝想统计同学们的成绩，第 $i$ 名同学的成绩为 $a_i$。当小蓝统计完前 $x$ 名同学的成绩后，他可以从 $1 \\sim x$ 中选出任意 $k$ 名同学的成绩，计算出这 $k$ 个成绩的方差。小蓝至少要检查多少个人的成\n绩，才有可能选出 $k$ 名同学，他们的方差小于一个给定的值 $T$？\n提示：$k$ 个数 $v_1, v_2, \\cdots , v_k$ 的方差 $\\sigma^2$ 定义为：$\\sigma^2=\\dfrac  {\\sum_{i=1}^k(v_i-\\bar v)^2} k$，其中 $\\bar v$ 表示\n$v_i$ 的平均值，$\\bar v = \\dfrac {\\sum_{i=1}^k v_i} k$。", "inputFormat": "输入的第一行包含三个正整数 $n, k, T $，相邻整数之间使用一个空格分隔。\n\n第二行包含 $n$ 个正整数 $a_1, a2, \\cdots, a_n$ ，相邻整数之间使用一个空格分隔。", "outputFormat": "输出一行包含一个整数表示答案。如果不能满足条件，输出 $-1$ 。", "hint": "检查完前三名同学的成绩后，只能选出 $3, 2, 5 $，方差为 $1.56 $；\n\n检查完前四名同学的成绩后，可以选出 $3, 2, 2 $，方差为 $0.22 < 1 $，所以答案为 $4 $。\n\n对于 $10\\%$ 的评测用例，保证 $1 ≤ n, k ≤ 10^2$；  \n对于 $30\\%$ 的评测用例，保证 $1 ≤ n, k ≤ 10^3$ ；  \n对于所有评测用例，保证 $1 ≤ n, k ≤ 10^5 $，$1 ≤ T ≤ 2\n^{31} -1 $，$1 ≤ a_i ≤ n $。", "locale": "zh-CN"}}}
{"pid": "P10390", "type": "P", "difficulty": 5, "samples": [["5\n3 6 2 2 7", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["高精度", "2024", "容斥原理", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 A] 因数计数", "background": "", "description": "小蓝随手写出了含有 $n$ 个正整数的数组 $\\{a_1, a_2,\\cdots, a_n\\}$，他发现可以轻松地算出有多少个有序二元组 $(i, j)$ 满足 $a_j$ 是 $a_i$ 的一个因数。因此他定义一个整数对 $(x_1, y_1)$ 是一个整数对 $(x_2, y_2)$ 的“因数”当且仅当 $x_1$ 和 $y_1$ 分别是 $x_2$ 和 $y_2$ 的因数。他想知道有多少个有序四元组 $(i, j, k, l)$ 满足 $(a_i\n, a_j)$ 是 $(a_k, a_l)$ 的因数，其中 $i, j, k, l$ 互不相等。", "inputFormat": "输入的第一行包含一个正整数 $n$。  \n第二行包含 $n$ 个正整数 $a_1, a_2,\\cdots, a_n $，相邻整数之间使用一个空格分隔。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "四元组 $(1, 4, 2, 3) $：$(3, 2)$ 为 $(6, 2)$ 的因子；  \n四元组 $(1, 3, 2, 4) $：$(3, 2)$ 为 $(6, 2)$ 的因子；  \n四元组 $(4, 1, 3, 2) $：$(2, 3)$ 为 $(2, 6)$ 的因子；  \n四元组 $(3, 1, 4, 2) $：$(2, 3)$ 为 $(2, 6)$ 的因子。\n\n对于 $20\\%$ 的评测用例，$n ≤ 50 $；  \n对于 $40\\%$ 的评测用例，$n ≤ 10^4$；  \n对于所有评测用例，$1 ≤ n ≤ 10^5 ，1 ≤ a_i ≤ 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 A] 因数计数", "background": "", "description": "小蓝随手写出了含有 $n$ 个正整数的数组 $\\{a_1, a_2,\\cdots, a_n\\}$，他发现可以轻松地算出有多少个有序二元组 $(i, j)$ 满足 $a_j$ 是 $a_i$ 的一个因数。因此他定义一个整数对 $(x_1, y_1)$ 是一个整数对 $(x_2, y_2)$ 的“因数”当且仅当 $x_1$ 和 $y_1$ 分别是 $x_2$ 和 $y_2$ 的因数。他想知道有多少个有序四元组 $(i, j, k, l)$ 满足 $(a_i\n, a_j)$ 是 $(a_k, a_l)$ 的因数，其中 $i, j, k, l$ 互不相等。", "inputFormat": "输入的第一行包含一个正整数 $n$。  \n第二行包含 $n$ 个正整数 $a_1, a_2,\\cdots, a_n $，相邻整数之间使用一个空格分隔。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "四元组 $(1, 4, 2, 3) $：$(3, 2)$ 为 $(6, 2)$ 的因子；  \n四元组 $(1, 3, 2, 4) $：$(3, 2)$ 为 $(6, 2)$ 的因子；  \n四元组 $(4, 1, 3, 2) $：$(2, 3)$ 为 $(2, 6)$ 的因子；  \n四元组 $(3, 1, 4, 2) $：$(2, 3)$ 为 $(2, 6)$ 的因子。\n\n对于 $20\\%$ 的评测用例，$n ≤ 50 $；  \n对于 $40\\%$ 的评测用例，$n ≤ 10^4$；  \n对于所有评测用例，$1 ≤ n ≤ 10^5 ，1 ≤ a_i ≤ 10^5$。", "locale": "zh-CN"}}}
{"pid": "P10391", "type": "P", "difficulty": 4, "samples": [["4 2\n1 2 3 1\n1 2\n1 3\n2 4\n4 3\n1 4", "3\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "最近公共祖先 LCA", "蓝桥杯省赛", "状压 DP"], "title": "[蓝桥杯 2024 省 A] 零食采购", "background": "", "description": "小蓝准备去星际旅行，出发前想在本星系采购一些零食，星系内有 $n$ 颗星球，由 $n-1$ 条航路连接为连通图，第 $i$ 颗星球卖第 $c_i$ 种零食特产。小蓝想出了 $q$ 个采购方案，第 $i$ 个方案的起点为星球 $s_i$ ，终点为星球 $t_i$ ，对于每种采购方案，小蓝将从起点走最短的航路到终点，并且可以购买所有经过的星球上的零食（包括起点终点），请计算每种采购方案最多能买多少种不同的零食。", "inputFormat": "输入的第一行包含两个正整数 $n$，$q$，用一个空格分隔。  \n第二行包含 $n$ 个整数 $c_1,c_2,\\cdots, c_n$，相邻整数之间使用一个空格分隔。  \n接下来 $n - 1$ 行，第 $i$ 行包含两个整数 $u_i,v_i$，用一个空格分隔，表示一条\n航路将星球 $u_i$ 与 $v_i$ 相连。  \n接下来 $q$ 行，第 $i$ 行包含两个整数 $s_i\n, t_i $，用一个空格分隔，表示一个采购方案。", "outputFormat": "输出 $q$ 行，每行包含一个整数，依次表示每个采购方案的答案。", "hint": "第一个方案路线为 $\\{4, 2, 1, 3\\}$，可以买到第 $1, 2, 3$ 种零食；  \n第二个方案路线为 $\\{1, 2, 4\\}$，可以买到第 $1, 2$ 种零食。\n\n对于 20% 的评测用例，$1 ≤ n, q ≤ 5000 $；    \n对于所有评测用例，$1 ≤ n, q ≤ 10^5，1 ≤ c_i ≤ 20，1 ≤ u_i\n, v_i ≤ n，1 ≤ s_i\n, t_i ≤ n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 A] 零食采购", "background": "", "description": "小蓝准备去星际旅行，出发前想在本星系采购一些零食，星系内有 $n$ 颗星球，由 $n-1$ 条航路连接为连通图，第 $i$ 颗星球卖第 $c_i$ 种零食特产。小蓝想出了 $q$ 个采购方案，第 $i$ 个方案的起点为星球 $s_i$ ，终点为星球 $t_i$ ，对于每种采购方案，小蓝将从起点走最短的航路到终点，并且可以购买所有经过的星球上的零食（包括起点终点），请计算每种采购方案最多能买多少种不同的零食。", "inputFormat": "输入的第一行包含两个正整数 $n$，$q$，用一个空格分隔。  \n第二行包含 $n$ 个整数 $c_1,c_2,\\cdots, c_n$，相邻整数之间使用一个空格分隔。  \n接下来 $n - 1$ 行，第 $i$ 行包含两个整数 $u_i,v_i$，用一个空格分隔，表示一条\n航路将星球 $u_i$ 与 $v_i$ 相连。  \n接下来 $q$ 行，第 $i$ 行包含两个整数 $s_i\n, t_i $，用一个空格分隔，表示一个采购方案。", "outputFormat": "输出 $q$ 行，每行包含一个整数，依次表示每个采购方案的答案。", "hint": "第一个方案路线为 $\\{4, 2, 1, 3\\}$，可以买到第 $1, 2, 3$ 种零食；  \n第二个方案路线为 $\\{1, 2, 4\\}$，可以买到第 $1, 2$ 种零食。\n\n对于 20% 的评测用例，$1 ≤ n, q ≤ 5000 $；    \n对于所有评测用例，$1 ≤ n, q ≤ 10^5，1 ≤ c_i ≤ 20，1 ≤ u_i\n, v_i ≤ n，1 ≤ s_i\n, t_i ≤ n$。", "locale": "zh-CN"}}}
{"pid": "P10392", "type": "P", "difficulty": 5, "samples": [["3 3\n1 3 2", "3 2 -1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "线段树", "2024", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 A] 封印宝石", "background": "", "description": "在一次探险中，勇者小蓝发现了 $n$ 颗闪烁着奇异光芒的宝石，每颗宝石都蕴含着魔法能量，分别记作 $a_1, a_2,\\cdots, a_n$。小蓝计划用 $n$ 个特制的魔法盒子来封\n印这些宝石，防止其魔法能量被滥用。  \n封印宝石会消耗小蓝的体力，具体地，将第 $i$ 颗宝石放入第 $j$ 个盒子会消耗小蓝 $i - j$ 点体力（注：需满足 $j ≤ i$ 才能将第 $i$ 颗宝石放入第 $j$ 个盒子进行有效的封印）。小蓝也可以选择将魔法盒留空，以保存体力供后续使用。  \n此外，为了避免魔力相冲，每个盒子最多存放一颗宝石（每个宝石也只能放进一个盒子），且任意两个相邻盒子不能存放魔力值相同的宝石，相邻的盒子允许同时为空。  \n小蓝初始的体力值为 $k$。在不超出体力限制的条件下，小蓝希望找出一种宝石的放置方法，使得宝石的魔力值在这 $n$ 个盒子中的排列顺序具有最大的字典序（注：未放置宝石的盒子在此序列中记为 $-1$）。  \n作为勇者小蓝的追随者，请你帮他找出这一放置宝石的方法。  \n\n**字典序的解释**： 在本题中，字典序的大小是按照宝石的魔力值进行比较的。对于两个长度同为 $L$ 的魔力值序列 $a$ 和 $b$，如果存在一个位置 $i$，使得 $a_j = b_j$ 对所有 $1 ≤ j < i$ 成立，但是 $a_i < b_i$，则序列 $a$ 在字典序上小于序列 $b$。  \n反之，如果 $a_i > b_i$，则序列 $a$ 在字典序上大于序列 $b$。如果不存在这样的 $i$，则序列 $a$ 和序列 $b$ 的字典序相等。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $k $，用一个空格分隔，分别表示宝石的数量和小蓝的初始体力值。  \n第二行包含 $n$ 个整数 $a_1, a_2,\\cdots , a_n $，相邻整数之间使用一个空格分隔，分别表示每颗宝石的魔法能量值。", "outputFormat": "输出一行包含 $n$ 个整数，相邻整数之间使用一个空格分隔，表示每个魔法盒中宝石的魔法能量值。如果某个魔法盒为空，则对应位置输出 $-1$。", "hint": "在开始放置宝石之前，体力为 $3$，宝石在盒子中的排列为 $[-1, -1, -1]$。  \n1. 将第 $2$ 个宝石放进第 $1$ 个盒子，得到 $[3, -1, -1]$，体力剩余 $2$。\n2. 将第 $3$ 个宝石放进第 $2$ 个盒子，得到 $[3, 2, -1]$，体力剩余 $1$。  \n\n最后宝石在盒子中的排列为 $[3, 2, −1]$。显然，没有比这更优的放置方法。\n\n对于 $20\\%$ 的评测用例，$1 ≤ n ≤ 5 × 10^3 ，0 ≤ k ≤ 3 × 10^6 ，1 ≤ a_i ≤ 10^5$。  \n对于所有评测用例，$1 ≤ n ≤ 10^5 ，0 ≤ k ≤ 10^9 ，1 ≤ a_i ≤ 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 A] 封印宝石", "background": "", "description": "在一次探险中，勇者小蓝发现了 $n$ 颗闪烁着奇异光芒的宝石，每颗宝石都蕴含着魔法能量，分别记作 $a_1, a_2,\\cdots, a_n$。小蓝计划用 $n$ 个特制的魔法盒子来封\n印这些宝石，防止其魔法能量被滥用。  \n封印宝石会消耗小蓝的体力，具体地，将第 $i$ 颗宝石放入第 $j$ 个盒子会消耗小蓝 $i - j$ 点体力（注：需满足 $j ≤ i$ 才能将第 $i$ 颗宝石放入第 $j$ 个盒子进行有效的封印）。小蓝也可以选择将魔法盒留空，以保存体力供后续使用。  \n此外，为了避免魔力相冲，每个盒子最多存放一颗宝石（每个宝石也只能放进一个盒子），且任意两个相邻盒子不能存放魔力值相同的宝石，相邻的盒子允许同时为空。  \n小蓝初始的体力值为 $k$。在不超出体力限制的条件下，小蓝希望找出一种宝石的放置方法，使得宝石的魔力值在这 $n$ 个盒子中的排列顺序具有最大的字典序（注：未放置宝石的盒子在此序列中记为 $-1$）。  \n作为勇者小蓝的追随者，请你帮他找出这一放置宝石的方法。  \n\n**字典序的解释**： 在本题中，字典序的大小是按照宝石的魔力值进行比较的。对于两个长度同为 $L$ 的魔力值序列 $a$ 和 $b$，如果存在一个位置 $i$，使得 $a_j = b_j$ 对所有 $1 ≤ j < i$ 成立，但是 $a_i < b_i$，则序列 $a$ 在字典序上小于序列 $b$。  \n反之，如果 $a_i > b_i$，则序列 $a$ 在字典序上大于序列 $b$。如果不存在这样的 $i$，则序列 $a$ 和序列 $b$ 的字典序相等。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $k $，用一个空格分隔，分别表示宝石的数量和小蓝的初始体力值。  \n第二行包含 $n$ 个整数 $a_1, a_2,\\cdots , a_n $，相邻整数之间使用一个空格分隔，分别表示每颗宝石的魔法能量值。", "outputFormat": "输出一行包含 $n$ 个整数，相邻整数之间使用一个空格分隔，表示每个魔法盒中宝石的魔法能量值。如果某个魔法盒为空，则对应位置输出 $-1$。", "hint": "在开始放置宝石之前，体力为 $3$，宝石在盒子中的排列为 $[-1, -1, -1]$。  \n1. 将第 $2$ 个宝石放进第 $1$ 个盒子，得到 $[3, -1, -1]$，体力剩余 $2$。\n2. 将第 $3$ 个宝石放进第 $2$ 个盒子，得到 $[3, 2, -1]$，体力剩余 $1$。  \n\n最后宝石在盒子中的排列为 $[3, 2, −1]$。显然，没有比这更优的放置方法。\n\n对于 $20\\%$ 的评测用例，$1 ≤ n ≤ 5 × 10^3 ，0 ≤ k ≤ 3 × 10^6 ，1 ≤ a_i ≤ 10^5$。  \n对于所有评测用例，$1 ≤ n ≤ 10^5 ，0 ≤ k ≤ 10^9 ，1 ≤ a_i ≤ 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10393", "type": "P", "difficulty": 2, "samples": [["3\n0 0 0", "0 0 0 \n0 0 0"], ["5\n1 1 1 1 -1", "1 1 1 -1 1 \n1 1 -1 1 1"], ["3\n1 2 3", "3 1 2\n2 3 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "洛谷原创", "Special Judge", "O2优化", "洛谷月赛"], "title": "无限循环？", "background": "你是一只小青蛙。\n\n你被关进了塞拉飞舞监狱。\n\n生活有点压抑，小青蛙幻想自己走出了塞拉飞舞监狱。\n\n生活过于压抑，小青蛙开始反抗塞拉飞舞监狱。\n\n小青蛙孤立无援，又被关进了塞拉飞舞监狱。\n\n……\n\n循环不是无限的。如此往复，总有一天，他会将塞拉飞舞这黑暗的牢笼冲破！", "description": "小青蛙暂时被困在了循环里，这个循环可以看作一个有 $n$ 个点的环（$n$ 为奇数），每个点 $i$ 有点权 $a_i$。\n\n对于所有的 $1 \\leq i < n$，点 $i$ 和点 $i+1$ 之间有一条边，边权为 $w_i$；点 $1$ 和点 $n$ 之间有一条边，边权为 $w_n$。\n\n这个环的边权和点权有奇妙的关系：对于任意一条边 $i$，其边权 $w_i$ 都必然满足关系 $w_i=\\dfrac12(a_i+a_{i+1})$，其中 $w_n=\\dfrac12(a_1+a_{n})$，当环中任意一条边的边权改变的时候，它的所有点点权会**随之改变**，直到所有点权都能与边权满足上述关系。\n\n现在青蛙掌握了 $w_1\\sim w_n$ 的值，而且他可以交换其中任意两条边的权值任意次（即任意打乱边权）。现在青蛙需要给出两组安排 $w_1\\sim w_n$ 的方案，分别使得 $1$ 号点点权**在所有的排列方案中最大** / **最小**。\n\n然而由于青蛙陷入了无限循环，他的脑子十分混乱，于是他向你寻求帮助，你需要帮他构造这样两组方案。\n\n**题目保证 $\\boldsymbol n$ 为奇数**。", "inputFormat": "第一行一个整数 $n$ 。\n\n第二行共 $n$ 个整数，第 $i$ 个数 $w_i$ 表示第 $i$ 条边的权值。", "outputFormat": "两行，每行 $n$ 个整数表示答案。\n\n第一行 $n$ 个整数从 $w_1'\\sim w_n'$ 表示一组方案使得 $1$ 号点权值最大。\n\n第二行 $n$ 个整数从 $w_1''\\sim w_n''$ 表示一组方案使得 $1$ 号点权值最小。\n\n本题采用 `special judge` 评测，也就是说，如果有多种可能的答案，你可以输出任意一种。\n", "hint": "**【样例 #1 解释】**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j7x81nq5.png)\n\n其中红色数字表示点权，黑色数字表示边权，蓝色数字表示点的编号。\n\n可以证明，这种方案下的 $1$ 号点权既最小，又最大。\n\n**【样例 #2 解释】**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ku8797x8.png)\n\n其中红色表示点权，黑色表示边权，蓝色表示点的号码。\n\n可以证明，这两种方案下的 $1$ 号点权分别取到最大和最小。需要注意的是，这**不一定**是**唯一解**。\n\n---\n\n**【数据规模与约定】**\n\n**本题开启捆绑测试。**\n\n| $\\text{Subtask}$ | 数据范围 | 分数 | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $n=3$ | $20$ | $\\rm A$ |\n| $2$ | $n=3$ | $20$ | 无 |\n| $3$ | $n\\leq 10^6$ | $20$ | $\\rm B$ |\n| $4$ | $n\\leq 10^6$ | $20$ | $\\rm C$ |\n| $5$ | $n\\leq 10^6$ | $20$ | 无 |\n\n- 特殊性质 $\\rm A$ ：保证 $\\{w\\}$ 是由 $\\{-1,0,1\\}$ 任意打乱之后得到的一个序列。\n- 特殊性质 $\\rm B$ ：保证 $n \\ge 3$，且对于所有 $i\\in [2,n]$，有 $w_i$ 相同。\n- 特殊性质 $\\rm C$ ：保证 $n\\ge 3$，且对于所有 $i\\in [3,n]$，有 $w_i$ 相同。\n- 对于 $100\\%$ 的数据， $1\\leq n\\leq 10^6$ 且为奇数， $|w_i|\\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "无限循环？", "background": "你是一只小青蛙。\n\n你被关进了塞拉飞舞监狱。\n\n生活有点压抑，小青蛙幻想自己走出了塞拉飞舞监狱。\n\n生活过于压抑，小青蛙开始反抗塞拉飞舞监狱。\n\n小青蛙孤立无援，又被关进了塞拉飞舞监狱。\n\n……\n\n循环不是无限的。如此往复，总有一天，他会将塞拉飞舞这黑暗的牢笼冲破！", "description": "小青蛙暂时被困在了循环里，这个循环可以看作一个有 $n$ 个点的环（$n$ 为奇数），每个点 $i$ 有点权 $a_i$。\n\n对于所有的 $1 \\leq i < n$，点 $i$ 和点 $i+1$ 之间有一条边，边权为 $w_i$；点 $1$ 和点 $n$ 之间有一条边，边权为 $w_n$。\n\n这个环的边权和点权有奇妙的关系：对于任意一条边 $i$，其边权 $w_i$ 都必然满足关系 $w_i=\\dfrac12(a_i+a_{i+1})$，其中 $w_n=\\dfrac12(a_1+a_{n})$，当环中任意一条边的边权改变的时候，它的所有点点权会**随之改变**，直到所有点权都能与边权满足上述关系。\n\n现在青蛙掌握了 $w_1\\sim w_n$ 的值，而且他可以交换其中任意两条边的权值任意次（即任意打乱边权）。现在青蛙需要给出两组安排 $w_1\\sim w_n$ 的方案，分别使得 $1$ 号点点权**在所有的排列方案中最大** / **最小**。\n\n然而由于青蛙陷入了无限循环，他的脑子十分混乱，于是他向你寻求帮助，你需要帮他构造这样两组方案。\n\n**题目保证 $\\boldsymbol n$ 为奇数**。", "inputFormat": "第一行一个整数 $n$ 。\n\n第二行共 $n$ 个整数，第 $i$ 个数 $w_i$ 表示第 $i$ 条边的权值。", "outputFormat": "两行，每行 $n$ 个整数表示答案。\n\n第一行 $n$ 个整数从 $w_1'\\sim w_n'$ 表示一组方案使得 $1$ 号点权值最大。\n\n第二行 $n$ 个整数从 $w_1''\\sim w_n''$ 表示一组方案使得 $1$ 号点权值最小。\n\n本题采用 `special judge` 评测，也就是说，如果有多种可能的答案，你可以输出任意一种。\n", "hint": "**【样例 #1 解释】**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j7x81nq5.png)\n\n其中红色数字表示点权，黑色数字表示边权，蓝色数字表示点的编号。\n\n可以证明，这种方案下的 $1$ 号点权既最小，又最大。\n\n**【样例 #2 解释】**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ku8797x8.png)\n\n其中红色表示点权，黑色表示边权，蓝色表示点的号码。\n\n可以证明，这两种方案下的 $1$ 号点权分别取到最大和最小。需要注意的是，这**不一定**是**唯一解**。\n\n---\n\n**【数据规模与约定】**\n\n**本题开启捆绑测试。**\n\n| $\\text{Subtask}$ | 数据范围 | 分数 | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $n=3$ | $20$ | $\\rm A$ |\n| $2$ | $n=3$ | $20$ | 无 |\n| $3$ | $n\\leq 10^6$ | $20$ | $\\rm B$ |\n| $4$ | $n\\leq 10^6$ | $20$ | $\\rm C$ |\n| $5$ | $n\\leq 10^6$ | $20$ | 无 |\n\n- 特殊性质 $\\rm A$ ：保证 $\\{w\\}$ 是由 $\\{-1,0,1\\}$ 任意打乱之后得到的一个序列。\n- 特殊性质 $\\rm B$ ：保证 $n \\ge 3$，且对于所有 $i\\in [2,n]$，有 $w_i$ 相同。\n- 特殊性质 $\\rm C$ ：保证 $n\\ge 3$，且对于所有 $i\\in [3,n]$，有 $w_i$ 相同。\n- 对于 $100\\%$ 的数据， $1\\leq n\\leq 10^6$ 且为奇数， $|w_i|\\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10394", "type": "P", "difficulty": 4, "samples": [["3\n3 2\n4 4\n5 5", "1\n3\n2\n"], ["5\n4 3\n4 4\n4 5\n4 6\n4 7", "2\n3\n3\n4\n4\n"], ["3\n1145 1499\n12344 123456\n114514 1919810", "2\n41\n17"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "洛谷原创", "O2优化", "洛谷月赛"], "title": "接连不断！", "background": "小青蛙被关进了监狱的小黑屋里，他遭受了接连不断的折磨，无论是肉体上还是精神上。\n\n他的精神萎靡不振，他的身体行动迟缓。\n\n有些东西被暂时的压制了，但这些东西越是被压制，它反弹时威力就越大。\n\n他需要一个契机。", "description": "青蛙有 $m+1$ 个无向图，编号为 $0\\sim m$。每个图的点集都是 $V$，点集 $V$ 包含 $n$ 个点，编号为 $0\\sim n-1$。起初所有的图都没有边存在。\n\n接下来，在编号为 $x$ 的图中，对于所有在 $[0, n - 1]$ 中的编号 $i$，青蛙会将编号为 $i$ 的点与编号为 $(i\\cdot x)\\bmod n$ 的点连一条无向边。\n\n他想知道这 $m+1$ 个图中有多少个图是**连通的**，这个问题交给你来回答。\n\n注：\n1. $\\bmod$ 表示取模，$a\\bmod b$ 表示 $a$ 除以 $b$ 得到的余数。\n2. 在一张图中，若在点集内任意两个不同的点 $x, y$ 之间存在至少一条路径，则我们称这个图是**连通的**。", "inputFormat": "**本题有多组数据**。\n\n第一行一个整数 $T$，表示数据组数。\n\n接下来 $T$ 行，每行两个整数 $n,m$，含义同上。", "outputFormat": "共 $T$ 行，每行一个整数表示答案。", "hint": "**【样例 #1 解释】**\n\n询问 1：\n\n| 图的编号 | 边集 | 图是否连通 |\n| :------: | :-----------------: | :--------: |\n|   $0$    | $(0,0),(1,0),(2,0)$ |     是     |\n|   $1$    | $(0,0),(1,1),(2,2)$ |     否     |\n|   $2$    | $(0,0),(1,2),(2,1)$ |     否     |\n\n询问 2：\n\n| 图的编号 |    边集    | 图是否连通 |\n| :------: | :-----------------------: | :--------: |\n|   $0$    | $(0,0),(1,0),(2,0),(3,0)$ |     是     |\n|   $1$    | $(0,0),(1,1),(2,2),(3,3)$ |     否     |\n|   $2$    | $(0,0),(1,2),(2,0),(3,2)$ |     是     |\n|   $3$    | $(0,0),(1,3),(2,2),(3,1)$ |     否     |\n|   $4$    | $(0,0),(1,0),(2,0),(3,0)$ |     是     |\n\n询问 3：\n\n| 图的编号 |   边集    | 图是否连通 |\n| :------: | :-----------------------: | :--------: |\n|   $0$    | $(0,0),(1,0),(2,0),(3,0),(4,0)$ |     是     |\n|   $1$    | $(0,0),(1,1),(2,2),(3,3),(4,4)$ |     否     |\n|   $2$    | $(0,0),(1,2),(2,4),(3,1),(4,3)$ |     否     |\n|   $3$    | $(0,0),(1,3),(2,1),(3,4),(4,2)$ |     否     |\n|   $4$    | $(0,0),(1,4),(2,3),(3,2),(4,1)$ |     否     |\n|   $5$    | $(0,0),(1,0),(2,0),(3,0),(4,0)$ |     是     |\n\n所以答案分别为 $1, 3, 2$。\n\n---\n\n**【数据规模与约定】**\n\n**本题开启捆绑测试。**\n\n| $\\text{Subtask}$ | 数据范围 | 分数 |\n| :---: | :---: | :---: |\n| $1$ | $n,m\\le 200$ | $15$ |\n| $2$ | $n,m\\le 3000$ | $30$ |\n| $3$ | $n,m\\le 10^7$ | $15$ |\n| $4$ | $n\\le 3000,m \\le10^{14}$ | $15$ |\n| $5$ | $n,m\\le 10^{14}$ | $25$ |\n\n- 对于 $100\\%$ 的数据，保证 $1\\le T\\le 5,1\\le n,m\\le 10^{14}$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "接连不断！", "background": "小青蛙被关进了监狱的小黑屋里，他遭受了接连不断的折磨，无论是肉体上还是精神上。\n\n他的精神萎靡不振，他的身体行动迟缓。\n\n有些东西被暂时的压制了，但这些东西越是被压制，它反弹时威力就越大。\n\n他需要一个契机。", "description": "青蛙有 $m+1$ 个无向图，编号为 $0\\sim m$。每个图的点集都是 $V$，点集 $V$ 包含 $n$ 个点，编号为 $0\\sim n-1$。起初所有的图都没有边存在。\n\n接下来，在编号为 $x$ 的图中，对于所有在 $[0, n - 1]$ 中的编号 $i$，青蛙会将编号为 $i$ 的点与编号为 $(i\\cdot x)\\bmod n$ 的点连一条无向边。\n\n他想知道这 $m+1$ 个图中有多少个图是**连通的**，这个问题交给你来回答。\n\n注：\n1. $\\bmod$ 表示取模，$a\\bmod b$ 表示 $a$ 除以 $b$ 得到的余数。\n2. 在一张图中，若在点集内任意两个不同的点 $x, y$ 之间存在至少一条路径，则我们称这个图是**连通的**。", "inputFormat": "**本题有多组数据**。\n\n第一行一个整数 $T$，表示数据组数。\n\n接下来 $T$ 行，每行两个整数 $n,m$，含义同上。", "outputFormat": "共 $T$ 行，每行一个整数表示答案。", "hint": "**【样例 #1 解释】**\n\n询问 1：\n\n| 图的编号 | 边集 | 图是否连通 |\n| :------: | :-----------------: | :--------: |\n|   $0$    | $(0,0),(1,0),(2,0)$ |     是     |\n|   $1$    | $(0,0),(1,1),(2,2)$ |     否     |\n|   $2$    | $(0,0),(1,2),(2,1)$ |     否     |\n\n询问 2：\n\n| 图的编号 |    边集    | 图是否连通 |\n| :------: | :-----------------------: | :--------: |\n|   $0$    | $(0,0),(1,0),(2,0),(3,0)$ |     是     |\n|   $1$    | $(0,0),(1,1),(2,2),(3,3)$ |     否     |\n|   $2$    | $(0,0),(1,2),(2,0),(3,2)$ |     是     |\n|   $3$    | $(0,0),(1,3),(2,2),(3,1)$ |     否     |\n|   $4$    | $(0,0),(1,0),(2,0),(3,0)$ |     是     |\n\n询问 3：\n\n| 图的编号 |   边集    | 图是否连通 |\n| :------: | :-----------------------: | :--------: |\n|   $0$    | $(0,0),(1,0),(2,0),(3,0),(4,0)$ |     是     |\n|   $1$    | $(0,0),(1,1),(2,2),(3,3),(4,4)$ |     否     |\n|   $2$    | $(0,0),(1,2),(2,4),(3,1),(4,3)$ |     否     |\n|   $3$    | $(0,0),(1,3),(2,1),(3,4),(4,2)$ |     否     |\n|   $4$    | $(0,0),(1,4),(2,3),(3,2),(4,1)$ |     否     |\n|   $5$    | $(0,0),(1,0),(2,0),(3,0),(4,0)$ |     是     |\n\n所以答案分别为 $1, 3, 2$。\n\n---\n\n**【数据规模与约定】**\n\n**本题开启捆绑测试。**\n\n| $\\text{Subtask}$ | 数据范围 | 分数 |\n| :---: | :---: | :---: |\n| $1$ | $n,m\\le 200$ | $15$ |\n| $2$ | $n,m\\le 3000$ | $30$ |\n| $3$ | $n,m\\le 10^7$ | $15$ |\n| $4$ | $n\\le 3000,m \\le10^{14}$ | $15$ |\n| $5$ | $n,m\\le 10^{14}$ | $25$ |\n\n- 对于 $100\\%$ 的数据，保证 $1\\le T\\le 5,1\\le n,m\\le 10^{14}$。\n", "locale": "zh-CN"}}}
{"pid": "P10395", "type": "P", "difficulty": 5, "samples": [["3 4\n1 2 3\n1 3 2 2", "2"], ["5 5\n1 2 3 4 4\n1 2 3 3 3", "1"], ["5 10\n1 2 3 4 5\n1 2 2 3 2 2 2 4 5 4", "3"], ["10 2\n1 2 1 2 2 2 2 2 2 2\n2 2", "-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "洛谷原创", "O2优化", "洛谷月赛"], "title": "青蛙寻青。", "background": "数次失败后，小青蛙的思想开始发生变化。\n\n他开始寻找自己为青蛙之本。\n\n他开始寻找其他青蛙帮忙。\n\n他在发生蜕变。\n\n他在升华。\n\n他，将变成光！\n\n他给自己取了新名字 —— 青蛙青（qwq），因为名字很可爱。", "description": "白色光可以被分解成青色光还有很多其他颜色的光。\n\n$\\{a\\}$ 是一个长度为 $n$，有 $k$ 种不同颜色的序列，第 $i$ 个元素颜色为 $a_i$（保证颜色 $1\\sim k$ 都在 $a$ 中出现过）。\n\n$\\{b\\}$ 是一个长度为 $m$ 的序列，第 $i$ 个元素颜色为 $b_i$（保证每个 $b_i$ 都是 $k$ 种颜色中的一种，但不保证 $k$ 种颜色都在 $b$ 中出现过）。我们可以修改 $b$ 中若干个位置的颜色，得到一个长度仍为 $m$ 的序列 $b'$。\n\n我们对 $b'$ 与 $a$ 中颜色相同的点连这种颜色的一条线段。\n\n如 $n=3,m=4,k=3,a=\\{1,2,3\\},b'=\\{1,3,2,2\\}$，它们之间的连线是这样的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kmi8og83.png)\n\n要求**不同颜色的线段两两不交**，**且 $k$ 种颜色都要在 $b$ 中出现**，请问最少修改次数是多少？\n\n形式化的，设你修改后的符合要求的序列为 $b'$，那么你需要最小化：\n\n$$\n\\sum_{i=1}^{m}[b_i\\ne b'_i]\n$$\n\n对于上述 $a=\\{1,2,3\\},b'=\\{1,3,2,2\\}$ 的情况，它们之间的连线（红色的 $2$ 与紫色 $3$ 之间）出现了相交。\n\n但如果我们把 $b$ 修改成 $\\{1,2,3,3\\}$，它们之间的连线没有相交，满足上述条件：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9a1ljv02.png)\n\n注意：\n\n- $b' = \\{1,1,4,5\\}$ 的情况连线也没有相交，但是 $b'$ 包含了 $k$ 种颜色之外的颜色（有 $4$ 和 $5$），因此这个 $b'$ 不合法。\n- $b' = \\{1,1,1,1\\}$ 的情况连线也没有相交，但是 $b'$ 中没有包含 $1\\sim k$ 中所有的颜色（没有 $2$ 和 $3$），因此这个 $b'$ 也不合法。\n\n特别的，如果无论怎样修改都无法满足要求，请输出 `-1`。", "inputFormat": "第一行共两个整数 $n,m$，分别表示序列 $a,b$ 的元素个数。\n\n第二行共 $n$ 个整数，第 $i$ 个整数表示 $a_i$。\n\n第三行共 $m$ 个整数，第 $i$ 个整数表示 $b_i$。", "outputFormat": "一行，一个整数，表示满足要求的最小修改次数。\n\n如果无论怎样修改都无法满足要求，请输出 `-1`。", "hint": "**【样例 #1 解释】**\n\n将 $\\{1,3,2,2\\}$ 修改为 $\\{1,2,2,3\\}$。\n\n可以证明这是修改次数最少的方式。\n\n**【样例 #2 解释】**\n\n将 $\\{1,2,3,3,3\\}$ 修改为 $\\{1,2,3,3,4\\}$。\n\n可以证明这是修改次数最少的方式。\n\n---\n\n**本题开启捆绑测试以及子任务依赖。**\n\n**本题时限 2s。**\n\n|$\\text{Subtask}$| $n,m\\le$ | 分数 | 子任务依赖 |\n|:---:|:---:|:---:|:---:|\n| $1$ | $5$ | $5$ | 无 |\n| $2$ | $5000$| $35$ | $1$ |\n| $3$ | $10^5$| $30$ | $1,2$ |\n| $4$ | $2\\times 10^6$| $30$ | $1,2,3$ |\n\n- 对于 $100\\%$ 的数据，保证 $1\\le n,m\\le 2\\times 10^6$，$1\\le a_i,b_i \\le n$。设 $\\max\\limits_{i=1}^n{a_i} = k$，保证 $1\\sim k$ 均在 $a$ 中出现过，且 $1\\le k \\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "青蛙寻青。", "background": "数次失败后，小青蛙的思想开始发生变化。\n\n他开始寻找自己为青蛙之本。\n\n他开始寻找其他青蛙帮忙。\n\n他在发生蜕变。\n\n他在升华。\n\n他，将变成光！\n\n他给自己取了新名字 —— 青蛙青（qwq），因为名字很可爱。", "description": "白色光可以被分解成青色光还有很多其他颜色的光。\n\n$\\{a\\}$ 是一个长度为 $n$，有 $k$ 种不同颜色的序列，第 $i$ 个元素颜色为 $a_i$（保证颜色 $1\\sim k$ 都在 $a$ 中出现过）。\n\n$\\{b\\}$ 是一个长度为 $m$ 的序列，第 $i$ 个元素颜色为 $b_i$（保证每个 $b_i$ 都是 $k$ 种颜色中的一种，但不保证 $k$ 种颜色都在 $b$ 中出现过）。我们可以修改 $b$ 中若干个位置的颜色，得到一个长度仍为 $m$ 的序列 $b'$。\n\n我们对 $b'$ 与 $a$ 中颜色相同的点连这种颜色的一条线段。\n\n如 $n=3,m=4,k=3,a=\\{1,2,3\\},b'=\\{1,3,2,2\\}$，它们之间的连线是这样的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kmi8og83.png)\n\n要求**不同颜色的线段两两不交**，**且 $k$ 种颜色都要在 $b$ 中出现**，请问最少修改次数是多少？\n\n形式化的，设你修改后的符合要求的序列为 $b'$，那么你需要最小化：\n\n$$\n\\sum_{i=1}^{m}[b_i\\ne b'_i]\n$$\n\n对于上述 $a=\\{1,2,3\\},b'=\\{1,3,2,2\\}$ 的情况，它们之间的连线（红色的 $2$ 与紫色 $3$ 之间）出现了相交。\n\n但如果我们把 $b$ 修改成 $\\{1,2,3,3\\}$，它们之间的连线没有相交，满足上述条件：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9a1ljv02.png)\n\n注意：\n\n- $b' = \\{1,1,4,5\\}$ 的情况连线也没有相交，但是 $b'$ 包含了 $k$ 种颜色之外的颜色（有 $4$ 和 $5$），因此这个 $b'$ 不合法。\n- $b' = \\{1,1,1,1\\}$ 的情况连线也没有相交，但是 $b'$ 中没有包含 $1\\sim k$ 中所有的颜色（没有 $2$ 和 $3$），因此这个 $b'$ 也不合法。\n\n特别的，如果无论怎样修改都无法满足要求，请输出 `-1`。", "inputFormat": "第一行共两个整数 $n,m$，分别表示序列 $a,b$ 的元素个数。\n\n第二行共 $n$ 个整数，第 $i$ 个整数表示 $a_i$。\n\n第三行共 $m$ 个整数，第 $i$ 个整数表示 $b_i$。", "outputFormat": "一行，一个整数，表示满足要求的最小修改次数。\n\n如果无论怎样修改都无法满足要求，请输出 `-1`。", "hint": "**【样例 #1 解释】**\n\n将 $\\{1,3,2,2\\}$ 修改为 $\\{1,2,2,3\\}$。\n\n可以证明这是修改次数最少的方式。\n\n**【样例 #2 解释】**\n\n将 $\\{1,2,3,3,3\\}$ 修改为 $\\{1,2,3,3,4\\}$。\n\n可以证明这是修改次数最少的方式。\n\n---\n\n**本题开启捆绑测试以及子任务依赖。**\n\n**本题时限 2s。**\n\n|$\\text{Subtask}$| $n,m\\le$ | 分数 | 子任务依赖 |\n|:---:|:---:|:---:|:---:|\n| $1$ | $5$ | $5$ | 无 |\n| $2$ | $5000$| $35$ | $1$ |\n| $3$ | $10^5$| $30$ | $1,2$ |\n| $4$ | $2\\times 10^6$| $30$ | $1,2,3$ |\n\n- 对于 $100\\%$ 的数据，保证 $1\\le n,m\\le 2\\times 10^6$，$1\\le a_i,b_i \\le n$。设 $\\max\\limits_{i=1}^n{a_i} = k$，保证 $1\\sim k$ 均在 $a$ 中出现过，且 $1\\le k \\le n$。", "locale": "zh-CN"}}}
{"pid": "P10396", "type": "P", "difficulty": 7, "samples": [["", "2 3\n4\n1 1 i R\n1 2 c 1 2 R D\n1 3 + 2 L\n2 2 o 1 2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "洛谷原创", "提交答案", "Special Judge", "O2优化", "洛谷月赛"], "title": "健将青蛙……", "background": "小青蛙在打破监狱后，注重身体的锻炼。\n\n他成为了一只运动**健将**。\n\n他的故事还在继续……", "description": "**这是一道提交答案题。**\n\n你的大脑需要被锻炼。\n\n你是一个 bot。你有一个大小为 $300$ 的内存条（下标为 $1\\sim 300$），初始时全为 $0$。每个内存条中存储着一个 $32$ 位整数（即 C++ 中的 `int`）。\n\n你需要构造一个网格图，某些网格上的节点有一个指令，机器人根据指令进行操作和移动。\n\n下文把有指令的节点称作特殊节点。\n\n节点上的指令有如下几种：\n\n- 增减：将内存条某个位置上的整数增、减 $1$，并向指定的方向移动一步；\n- 比较：比较内存条中下标为 $i,j$ 的数的大小，并根据大小向指定方向移动一步；\n- 输入：机器人将从这里出发，并向指定方向移动一步，**该节点不应被重复经过**；\n- 输出：机器人到达该节点时结束行动并输出指定位置的值。\n\n**其中输入、输出节点必须存在且唯一。**\n\n任务：\n\n1. 在初始内存条下标 $1,2$ 位置中读入 $a,b$，输出 $a+b$。保证 $0\\leq a,b\\leq 100$。\n2. 在初始内存条下标 $1$ 位置中读入 $a$，输出 $2^a$。保证 $0\\leq a\\leq 20$。\n3. 在初始内存条下标 $1$ 位置中读入 $a$，输出 $a^2$。保证 $1\\leq a\\leq 1000$。\n4. 在初始内存条下标 $1,2$ 位置中读入 $a,b$，输出 $a\\oplus b$。保证 $0\\leq a,b<2^{19}$。\n5. 在初始内存条下标 $1\\sim 51$ 位置中读入 $n=50,a_1,a_2\\dotsc,a_n$，输出升序排序后的 $a_1\\sim a_n$。保证 $0\\leq a_i\\leq100$。\n6. 在初始内存条下标 $1\\sim 59$ 位置中读入 $n=30,u_1,v_1\\dotsc,u_{n-1},v_{n-1}$，表示由 $n$ 个节点，$n-1$ 条边 $u_i,v_i$ 组成的树，要求输出给定树的直径长度（定义为树上最长的简单路径所包含的边数），保证 $1\\leq u_i,v_i\\leq n$。\n\n你需要保证机器人从输入节点出发能到达输出节点，并且中途不会访问到非特殊节点，且移动次数 $\\leq 5\\times 10^7$。", "inputFormat": "", "outputFormat": "**本题使用 `Special Judge` 判定答案正误。**\n\n针对题目给定的 $6$ 个任务，你需要分别提交你的输出文件 `robot1.out~robot6.out`。\n\n对于每个文件，你的输出应为以下格式：\n\n第一行输出两个正整数 $n,m$ 表示网格大小为 $n$ 行 $m$ 列。你需要保证 $n\\times m\\leq 10^7$。\n\n第二行输出一个正整数 $k$ 表示特殊节点数量。其中 $1\\leq k \\leq n \\times m$。\n\n接下来 $k$ 行每行格式如下：\n\n前两个输出的整数 $x,y$ 表示特殊节点所在位置为第 $x$ 行第 $y$ 列，其中 $1\\leq x\\leq n,1\\leq y\\leq m$，且所有 $(x,y)$ 互不相同，接下来按照节点类型输出不同内容：\n\n- 若为自增节点，则输出 `+`，自减节点输出 `-`，并输出一个整数表示自增/自减的内存下标 $i$，其中 $1\\leq i\\leq 300$，最后输出一个 `LRUD` 中的字符表示移动方向（分别对应左右上下，下同）。\n- 若为比较节点，则输出 `c`，接下来两个整数 $i,j$ 表示比较的下标，你需要保证 $1\\leq i,j\\leq 300$。最后输出两个 `LRUD` 中的字符分别表示 $i$ 下标中的数大于 $j$ 下标中的数时的移动方向和 $i$ 下标中的数小于等于 $j$ 下标中的数时的移动方向。\n- 若为输入节点则输出 `i`，并输出一个 `LRUD` 中的字符表示移动方向。\n- 若为输出节点则输出 `o`，并输出一个整数 $p$ 表示输出大小，接下来 $p$ 个 **互不相同的整数** $a_1\\sim a_p$ 表示你要输出的内存条中的下标，你需要保证 $1\\leq p,a_i\\leq 300$。\n\n**你需要保证给出的特殊节点中输入、输出节点必须存在且唯一。**", "hint": "上述样例给出了一个读入 $a,b$，输出 $\\max(a,b)$ 的程序。\n\n------------\n\n\n评分方式：若你的输出格式错误或给出结果错误，则获得 $0$ 分。否则对于每个测试点，你的得分与 $n\\times m$ 的大小有关。每个测试点有 $2$ 个评分参数 $c_1,c_2$，若你的 $n\\times m\\leq c_1$ 则获得该测试点满分，否则若 $c_1< n\\times m\\leq c_2$ 则获得该测试点 $60\\%$ 分数，否则获得 $40\\%$ 的分数。\n\n| Task Id | $c_1 =$ | $c_2 =$ | pts |\n| :----------: | :----------: | :----------: | :----------: |\n| 1 | $6$ | $9$ | $10$ |\n| 2 | $9$ | $12$ | $15$ |\n| 3 | $9$ | $10$ | $15$ |\n| 4 | $35$ | $48$ | $20$ |\n| 5 | $499$ | $999$ | $20$ |\n| 6 | $3\\times 10^3$ | $3\\times 10^5$ | $20$ |\n\n\n\n------------\n\n本题下发 `附件.zip` 中含有对解题有帮助的文件。\n\n- `./checker/checker.cpp`，其实现与评测时使用的 `Special Judge` 大致相同，\n- `./toy/index.html` 可在浏览器中使用。其为本题的网页版可视化工具，使用方法参见内部的 `instruction`。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "健将青蛙……", "background": "小青蛙在打破监狱后，注重身体的锻炼。\n\n他成为了一只运动**健将**。\n\n他的故事还在继续……", "description": "**这是一道提交答案题。**\n\n你的大脑需要被锻炼。\n\n你是一个 bot。你有一个大小为 $300$ 的内存条（下标为 $1\\sim 300$），初始时全为 $0$。每个内存条中存储着一个 $32$ 位整数（即 C++ 中的 `int`）。\n\n你需要构造一个网格图，某些网格上的节点有一个指令，机器人根据指令进行操作和移动。\n\n下文把有指令的节点称作特殊节点。\n\n节点上的指令有如下几种：\n\n- 增减：将内存条某个位置上的整数增、减 $1$，并向指定的方向移动一步；\n- 比较：比较内存条中下标为 $i,j$ 的数的大小，并根据大小向指定方向移动一步；\n- 输入：机器人将从这里出发，并向指定方向移动一步，**该节点不应被重复经过**；\n- 输出：机器人到达该节点时结束行动并输出指定位置的值。\n\n**其中输入、输出节点必须存在且唯一。**\n\n任务：\n\n1. 在初始内存条下标 $1,2$ 位置中读入 $a,b$，输出 $a+b$。保证 $0\\leq a,b\\leq 100$。\n2. 在初始内存条下标 $1$ 位置中读入 $a$，输出 $2^a$。保证 $0\\leq a\\leq 20$。\n3. 在初始内存条下标 $1$ 位置中读入 $a$，输出 $a^2$。保证 $1\\leq a\\leq 1000$。\n4. 在初始内存条下标 $1,2$ 位置中读入 $a,b$，输出 $a\\oplus b$。保证 $0\\leq a,b<2^{19}$。\n5. 在初始内存条下标 $1\\sim 51$ 位置中读入 $n=50,a_1,a_2\\dotsc,a_n$，输出升序排序后的 $a_1\\sim a_n$。保证 $0\\leq a_i\\leq100$。\n6. 在初始内存条下标 $1\\sim 59$ 位置中读入 $n=30,u_1,v_1\\dotsc,u_{n-1},v_{n-1}$，表示由 $n$ 个节点，$n-1$ 条边 $u_i,v_i$ 组成的树，要求输出给定树的直径长度（定义为树上最长的简单路径所包含的边数），保证 $1\\leq u_i,v_i\\leq n$。\n\n你需要保证机器人从输入节点出发能到达输出节点，并且中途不会访问到非特殊节点，且移动次数 $\\leq 5\\times 10^7$。", "inputFormat": "", "outputFormat": "**本题使用 `Special Judge` 判定答案正误。**\n\n针对题目给定的 $6$ 个任务，你需要分别提交你的输出文件 `robot1.out~robot6.out`。\n\n对于每个文件，你的输出应为以下格式：\n\n第一行输出两个正整数 $n,m$ 表示网格大小为 $n$ 行 $m$ 列。你需要保证 $n\\times m\\leq 10^7$。\n\n第二行输出一个正整数 $k$ 表示特殊节点数量。其中 $1\\leq k \\leq n \\times m$。\n\n接下来 $k$ 行每行格式如下：\n\n前两个输出的整数 $x,y$ 表示特殊节点所在位置为第 $x$ 行第 $y$ 列，其中 $1\\leq x\\leq n,1\\leq y\\leq m$，且所有 $(x,y)$ 互不相同，接下来按照节点类型输出不同内容：\n\n- 若为自增节点，则输出 `+`，自减节点输出 `-`，并输出一个整数表示自增/自减的内存下标 $i$，其中 $1\\leq i\\leq 300$，最后输出一个 `LRUD` 中的字符表示移动方向（分别对应左右上下，下同）。\n- 若为比较节点，则输出 `c`，接下来两个整数 $i,j$ 表示比较的下标，你需要保证 $1\\leq i,j\\leq 300$。最后输出两个 `LRUD` 中的字符分别表示 $i$ 下标中的数大于 $j$ 下标中的数时的移动方向和 $i$ 下标中的数小于等于 $j$ 下标中的数时的移动方向。\n- 若为输入节点则输出 `i`，并输出一个 `LRUD` 中的字符表示移动方向。\n- 若为输出节点则输出 `o`，并输出一个整数 $p$ 表示输出大小，接下来 $p$ 个 **互不相同的整数** $a_1\\sim a_p$ 表示你要输出的内存条中的下标，你需要保证 $1\\leq p,a_i\\leq 300$。\n\n**你需要保证给出的特殊节点中输入、输出节点必须存在且唯一。**", "hint": "上述样例给出了一个读入 $a,b$，输出 $\\max(a,b)$ 的程序。\n\n------------\n\n\n评分方式：若你的输出格式错误或给出结果错误，则获得 $0$ 分。否则对于每个测试点，你的得分与 $n\\times m$ 的大小有关。每个测试点有 $2$ 个评分参数 $c_1,c_2$，若你的 $n\\times m\\leq c_1$ 则获得该测试点满分，否则若 $c_1< n\\times m\\leq c_2$ 则获得该测试点 $60\\%$ 分数，否则获得 $40\\%$ 的分数。\n\n| Task Id | $c_1 =$ | $c_2 =$ | pts |\n| :----------: | :----------: | :----------: | :----------: |\n| 1 | $6$ | $9$ | $10$ |\n| 2 | $9$ | $12$ | $15$ |\n| 3 | $9$ | $10$ | $15$ |\n| 4 | $35$ | $48$ | $20$ |\n| 5 | $499$ | $999$ | $20$ |\n| 6 | $3\\times 10^3$ | $3\\times 10^5$ | $20$ |\n\n\n\n------------\n\n本题下发 `附件.zip` 中含有对解题有帮助的文件。\n\n- `./checker/checker.cpp`，其实现与评测时使用的 `Special Judge` 大致相同，\n- `./toy/index.html` 可在浏览器中使用。其为本题的网页版可视化工具，使用方法参见内部的 `instruction`。", "locale": "zh-CN"}}}
{"pid": "P10397", "type": "P", "difficulty": 1, "samples": [["9\nstd::freopen(\"5k.sync.closer\",\"r\",stdin);\nstd::freopen(\"5k.sync.closer\",\"r\",stdout);\nstd::freopen(\"5k.sync.closer\",\"r\",stderr);\nstd::freopen(\"5k.sync.closer\",\"w\",stdin);\nstd::freopen(\"5k.sync.closer\",\"w\",stdout);\nstd::freopen(\"5k.sync.closer\",\"w\",stderr);\nstd::freopen(\"5k.sync.closer\",\"a\",stdin);\nstd::freopen(\"5k.sync.closer\",\"a\",stdout);\nstd::freopen(\"5k.sync.closer\",\"a\",stderr);\n", "5k.sync.closer\n5k.sync.closer\n5k.sync.closer\n5k.sync.closer\n5k.sync.closer\n5k.sync.closer\n5k.sync.closer\n5k.sync.closer\n5k.sync.closer\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "O2优化"], "title": "『STA - R5』5k.sync.closer", "background": "", "description": "给定一条 [`std::freopen`](https://zh.cppreference.com/w/cpp/io/c/freopen) 语句，输出其操作的文件名称。\n\n形式化地，[`std::freopen`](https://zh.cppreference.com/w/cpp/io/c/freopen) 语句都应该恰好是\n\n```cpp\nstd::freopen(\"<title>\",\"<mode>\",<stream>);\n```\n\n其中 `<title>` 为其操作的文件名称。其至少包含一个字符，并且只可能包含下列几种字符：\n- 大写英文字符；\n- 小写英文字符；\n- 阿拉伯数字；\n- 英文半角句点 `.`。\n\n`<mode>` 为文件访问标记，其只可能为 `r`、`w`、`a` 中的一种。`<stream>` 为文件流，其只可能为 `stdin`、`stdout`、`stderr` 中的一种。\n\t\n你需要回答 $T$ 次询问。", "inputFormat": "**本题单个测试点内含有多组询问。**\n\n第一行一个正整数 $T$，代表询问次数。\n\n对于每组询问：一行一个字符串，代表一条 [`std::freopen`](https://zh.cppreference.com/w/cpp/io/c/freopen) 语句。", "outputFormat": "对于每组询问，输出一行一个字符串，代表其操作的文件名称。", "hint": "**本题采用捆绑测试。**\n\n对于 $100\\%$ 的数据：\n\n- $1 \\le T \\le 1000$。\n- 每条语句的长度均不超过 $1000$。\n\n具体部分分分配如下：\n\n- Subtask 1 (30pts)：保证文件名为 `5k.sync.closer`。\n- Subtask 2 (30pts)：保证文件名长度为 $1$。\n- Subtask 3 (40pts)：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『STA - R5』5k.sync.closer", "background": "", "description": "给定一条 [`std::freopen`](https://zh.cppreference.com/w/cpp/io/c/freopen) 语句，输出其操作的文件名称。\n\n形式化地，[`std::freopen`](https://zh.cppreference.com/w/cpp/io/c/freopen) 语句都应该恰好是\n\n```cpp\nstd::freopen(\"<title>\",\"<mode>\",<stream>);\n```\n\n其中 `<title>` 为其操作的文件名称。其至少包含一个字符，并且只可能包含下列几种字符：\n- 大写英文字符；\n- 小写英文字符；\n- 阿拉伯数字；\n- 英文半角句点 `.`。\n\n`<mode>` 为文件访问标记，其只可能为 `r`、`w`、`a` 中的一种。`<stream>` 为文件流，其只可能为 `stdin`、`stdout`、`stderr` 中的一种。\n\t\n你需要回答 $T$ 次询问。", "inputFormat": "**本题单个测试点内含有多组询问。**\n\n第一行一个正整数 $T$，代表询问次数。\n\n对于每组询问：一行一个字符串，代表一条 [`std::freopen`](https://zh.cppreference.com/w/cpp/io/c/freopen) 语句。", "outputFormat": "对于每组询问，输出一行一个字符串，代表其操作的文件名称。", "hint": "**本题采用捆绑测试。**\n\n对于 $100\\%$ 的数据：\n\n- $1 \\le T \\le 1000$。\n- 每条语句的长度均不超过 $1000$。\n\n具体部分分分配如下：\n\n- Subtask 1 (30pts)：保证文件名为 `5k.sync.closer`。\n- Subtask 2 (30pts)：保证文件名长度为 $1$。\n- Subtask 3 (40pts)：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P10398", "type": "P", "difficulty": 5, "samples": [["3\n1\n7\n3\n6 7 3\n4\n2 8 5 6\n", "Alice\nBob\nAlice\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "博弈论", "O2优化"], "title": "『STA - R5』Remove and Decrease Game", "background": "", "description": "给定 $n$ 堆石子，第 $i$ 堆有 $a_i$ 个，**保证 $\\bm{a_i}$ 互不相同**。\n\nAlice 和 Bob 轮流执行以下两种操作中的一种，并在操作后移除石子数为 $0$ 的石子堆。Alice 先手，不能执行操作的人判负。\n\n- 对于每堆石子均取走一个石子。\n- 移除石子数量最小的一堆石子。\n\n在两人均采取最优策略的情况下，问谁可以获胜。你需要回答 $T$ 次询问。", "inputFormat": "**本题单个测试点内含有多组询问。**\n\n第一行一个正整数 $T$，代表询问次数。\n\n对于每组询问：第一行一个正整数 $n$，代表石子堆数。第二行 $n$ 个正整数，第 $i$ 个正整数代表 $a_i$。", "outputFormat": "对于每组询问，输出一行 `Alice` 或 `Bob`，表示谁会获胜。", "hint": "**本题采用捆绑测试。**\n\n对于 $100\\%$ 的数据：\n\n- $1 \\le T \\le 2 \\times 10^5$；\n- $1 \\le n \\le 2 \\times 10^5$；\n- $1 \\le a_i \\le 10^9$；\n- $a_i$ 互不相同；\n- $\\sum n \\le 2 \\times 10^5$。\n\n具体部分分分配如下：\n\n|Subtask 编号|数据范围|分值|\n|:--------:|:--------:|:--------:|\n|1|$n \\le 2$|$3$|\n|2|$a_i \\le 1000$, $\\sum n \\le 10^4$|$23$|\n|3|$\\sum n^2 \\le 2 \\times 10^6$|$23$|\n|4|$10^8 \\le a_i \\le 10^9$|$23$|\n|5|无特殊限制|$28$|\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『STA - R5』Remove and Decrease Game", "background": "", "description": "给定 $n$ 堆石子，第 $i$ 堆有 $a_i$ 个，**保证 $\\bm{a_i}$ 互不相同**。\n\nAlice 和 Bob 轮流执行以下两种操作中的一种，并在操作后移除石子数为 $0$ 的石子堆。Alice 先手，不能执行操作的人判负。\n\n- 对于每堆石子均取走一个石子。\n- 移除石子数量最小的一堆石子。\n\n在两人均采取最优策略的情况下，问谁可以获胜。你需要回答 $T$ 次询问。", "inputFormat": "**本题单个测试点内含有多组询问。**\n\n第一行一个正整数 $T$，代表询问次数。\n\n对于每组询问：第一行一个正整数 $n$，代表石子堆数。第二行 $n$ 个正整数，第 $i$ 个正整数代表 $a_i$。", "outputFormat": "对于每组询问，输出一行 `Alice` 或 `Bob`，表示谁会获胜。", "hint": "**本题采用捆绑测试。**\n\n对于 $100\\%$ 的数据：\n\n- $1 \\le T \\le 2 \\times 10^5$；\n- $1 \\le n \\le 2 \\times 10^5$；\n- $1 \\le a_i \\le 10^9$；\n- $a_i$ 互不相同；\n- $\\sum n \\le 2 \\times 10^5$。\n\n具体部分分分配如下：\n\n|Subtask 编号|数据范围|分值|\n|:--------:|:--------:|:--------:|\n|1|$n \\le 2$|$3$|\n|2|$a_i \\le 1000$, $\\sum n \\le 10^4$|$23$|\n|3|$\\sum n^2 \\le 2 \\times 10^6$|$23$|\n|4|$10^8 \\le a_i \\le 10^9$|$23$|\n|5|无特殊限制|$28$|\n", "locale": "zh-CN"}}}
{"pid": "P10399", "type": "P", "difficulty": 6, "samples": [["5 4\n48 52 8 27 34 \n3 4 3 2 2 \n2 2 3\n2 1 5\n1 1 34 4\n2 1 3\n", "72\n133333711\n333333468"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化"], "title": "『STA - R5』ReLyna", "background": "![](https://pic.imgdb.cn/item/661a29dd68eb93571321ac89.webp)", "description": "你手中有一个数字 $x$。走到位置 $i$ 时你可以将手中的数字变为 $x+a_i$ 或 $x\\times b_i$。\n\n有 $m$ 次操作。\n\n- `1 x y z`，执行 $a_x\\gets y$，$b_x\\gets z$。\n\n- `2 l r`，查询若你从 $[l,r]$ 的所有子区间中等概率选择一个子区间 $[l',r']$，则你从 $l'$ 走到 $r'$ 后手中的数的最大值的期望是多少？答案对 $10^9+7$ 取模。每次行动开始前你手中的数字都会归零。\n\n如果你不知道有理数如何取模，可以参考 [P2613 有理数取余](https://www.luogu.com.cn/problem/P2613)。\n\n可参考样例解释理解题意。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数，第 $i$ 个整数代表 $a_i$。\n\n第三行 $n$ 个整数，第 $i$ 个整数代表 $b_i$。\n\n后 $m$ 行每行描述一次操作，格式见题目描述。", "outputFormat": "对于每个询问，输出对应的期望。答案对 $10^9+7$ 取模。", "hint": "**样例解释**\n\n对于第一次询问，令 $f(i,j)$ 为你从 $i$ 开始顺次走到 $j$ 后手中的数的最大值，则答案为 $\\frac{1}{3}[f(2,2)+f(2,3)+f(3,3)]=\\frac{1}{3}(52+156+8)=72$。\n\n**数据范围**\n\n| 子任务编号 | $n$ | $m$ | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| Subtask #1 | $50$ | $50$ | 无 | 5 |\n| Subtask #2 | $500$ | $500$ | 无 | 5 |\n| Subtask #3 | $10^5$ | $10^5$ | 保证任何时刻 $a_i=1$ | 25 |\n| Subtask #4 | $10^5$ | $50$ | 无 | 25 |\n| Subtask #5 | $10^5$ | $10^5$ | 没有修改操作 | 25 |\n| Subtask #6 | $10^5$ | $10^5$ | 无 | 15 |\n\n对于所有数据，$1\\le n,m\\le 10^5$，$0<a_i<10^9+7$，$1<b_i<10^9+7$，保证操作合法，保证所有输入均为整数。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『STA - R5』ReLyna", "background": "![](https://pic.imgdb.cn/item/661a29dd68eb93571321ac89.webp)", "description": "你手中有一个数字 $x$。走到位置 $i$ 时你可以将手中的数字变为 $x+a_i$ 或 $x\\times b_i$。\n\n有 $m$ 次操作。\n\n- `1 x y z`，执行 $a_x\\gets y$，$b_x\\gets z$。\n\n- `2 l r`，查询若你从 $[l,r]$ 的所有子区间中等概率选择一个子区间 $[l',r']$，则你从 $l'$ 走到 $r'$ 后手中的数的最大值的期望是多少？答案对 $10^9+7$ 取模。每次行动开始前你手中的数字都会归零。\n\n如果你不知道有理数如何取模，可以参考 [P2613 有理数取余](https://www.luogu.com.cn/problem/P2613)。\n\n可参考样例解释理解题意。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数，第 $i$ 个整数代表 $a_i$。\n\n第三行 $n$ 个整数，第 $i$ 个整数代表 $b_i$。\n\n后 $m$ 行每行描述一次操作，格式见题目描述。", "outputFormat": "对于每个询问，输出对应的期望。答案对 $10^9+7$ 取模。", "hint": "**样例解释**\n\n对于第一次询问，令 $f(i,j)$ 为你从 $i$ 开始顺次走到 $j$ 后手中的数的最大值，则答案为 $\\frac{1}{3}[f(2,2)+f(2,3)+f(3,3)]=\\frac{1}{3}(52+156+8)=72$。\n\n**数据范围**\n\n| 子任务编号 | $n$ | $m$ | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| Subtask #1 | $50$ | $50$ | 无 | 5 |\n| Subtask #2 | $500$ | $500$ | 无 | 5 |\n| Subtask #3 | $10^5$ | $10^5$ | 保证任何时刻 $a_i=1$ | 25 |\n| Subtask #4 | $10^5$ | $50$ | 无 | 25 |\n| Subtask #5 | $10^5$ | $10^5$ | 没有修改操作 | 25 |\n| Subtask #6 | $10^5$ | $10^5$ | 无 | 15 |\n\n对于所有数据，$1\\le n,m\\le 10^5$，$0<a_i<10^9+7$，$1<b_i<10^9+7$，保证操作合法，保证所有输入均为整数。", "locale": "zh-CN"}}}
{"pid": "P10400", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["提交答案", "Special Judge", "O2优化"], "title": "『STA - R5』消失的计算机", "background": "", "description": "**本题为提交答案题。**\n\n后台有一个正整数 $n$（你不知道 $n$ 具体的值）。\n\n你有 $10^3$ 个变量 $p_1,p_2,\\cdots,p_{10^3}$，初始 $p_1=n$，$p_2=p_3=\\cdots=p_{10^3}=0$。\n\n你需要写一个程序完成一些任务，程序包含下面几种语句可供使用：\n- `new x`，令 $n\\gets n+1$，$p_x\\gets n$。\n- `dec x`，令 $p_x\\gets p_x-1$。\n- `assign x y`，令 $p_x\\gets p_y$。\n- `iftry x goto l`，如果 $p_x \\ge 0$，跳转到第 $l$ 条语句。\n- `ifeq x y goto l`，如果 $p_x = p_y$，跳转到第 $l$ 条语句。\n- `ifneq x y goto l`，如果 $p_x\\neq p_y$，跳转到第 $l$ 条语句。\n\n对于后三种语句，**如果当前语句是第 $\\bm{l_0}$ 条，那么要求 $\\bm{l<l_0}$。**\n\n你不得使用超过 $1000$ 条语句或是标号超过 $1000$ 的变量。你的程序实际语句运行次数不得超过 $10^5$。\n\n令程序执行前的 $n$ 值为程序的输入，程序执行后的 $n$ 值为程序的输出，你需要分别完成下面 $10$ 个任务：\n\n1. 输入 $n$，输出 $2n$。\n1. 输入 $n$，输出 $\\binom n2$。\n1. 输入 $n$，输出 $600$。\n1. 输入 $n$，输出 $n + 1$。\n1. 输入 $n$，输出 $n^2 - 1$。\n1. 输入 $n$，输出 $n + 2000$。\n1. 输入 $n$，输出 $n + \\lfloor \\log_2 n\\rfloor$。\n1. 输入 $n$，输出 $n + \\left(n \\bmod 2\\right) + 1$。\n1. 输入 $n$，输出 $n+\\gcd(n, n - 4) + 1$。\n1. 输入 $n$，输出一个满足 $|x-n\\ln n|\\le 30$ 的正整数 $x$。\n\n**注：子任务按长度排序，与难度无关。**", "inputFormat": "该题为提交答案型试题，每个测试点对应的任务见【题目描述】。", "outputFormat": "针对给定的 $10$ 个任务，你需要分别提交你的输出文件 ``1.out`` ~ ``10.out``。\n\n每个文件需要输出若干行。\n\n第一行一个非负整数 $L$，代表你使用的语句数量。\n\n接下来 $L$ 行，每行一个语句。", "hint": "**评分标准**\n\n对于每个测试点，其内部会评测若干组测试数据。\n\n若你的输出出现下列情况，那么该测试点不得分：\n\n- 输出与要求不符。\n- 实际语句运行次数大于 $10^5$。\n- 出现无法识别或不合法的语句。\n- 使用超过 $1000$ 条语句或是标号超过 $1000$ 的变量。\n\n否则设对应子任务的评分标准为 $L_0$，那么你的得分为：\n\n$$\\mathrm{score}=\\begin{cases}11&L_0>L\\\\\\Big\\lfloor\\frac{10}{\\exp\\left(1-\\frac {L_0}L\\right)}\\Big\\rfloor&\\text{otherwise.}\\end{cases}$$\n\n下面给出各个任务对应的评分标准 $L_0$:\n\n| 编号 | $1$ | $2$ | $3$ | $4$ | $5$| $6$ | $7$ | $8$ | $9$ | $10$ |\n| :-: | :-: | :-: | :-: | :-: | :-: |  :-: | :-: | :-: | :-: | :-: |\n| $L_0$ | $3$ | $9$ | $233$ | $1$ | $10$| $29$ | $14$ | $7$ | $18$ | $14$ |\n\n**数据范围**\n\n保证 $5 \\le n \\le 100$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『STA - R5』消失的计算机", "background": "", "description": "**本题为提交答案题。**\n\n后台有一个正整数 $n$（你不知道 $n$ 具体的值）。\n\n你有 $10^3$ 个变量 $p_1,p_2,\\cdots,p_{10^3}$，初始 $p_1=n$，$p_2=p_3=\\cdots=p_{10^3}=0$。\n\n你需要写一个程序完成一些任务，程序包含下面几种语句可供使用：\n- `new x`，令 $n\\gets n+1$，$p_x\\gets n$。\n- `dec x`，令 $p_x\\gets p_x-1$。\n- `assign x y`，令 $p_x\\gets p_y$。\n- `iftry x goto l`，如果 $p_x \\ge 0$，跳转到第 $l$ 条语句。\n- `ifeq x y goto l`，如果 $p_x = p_y$，跳转到第 $l$ 条语句。\n- `ifneq x y goto l`，如果 $p_x\\neq p_y$，跳转到第 $l$ 条语句。\n\n对于后三种语句，**如果当前语句是第 $\\bm{l_0}$ 条，那么要求 $\\bm{l<l_0}$。**\n\n你不得使用超过 $1000$ 条语句或是标号超过 $1000$ 的变量。你的程序实际语句运行次数不得超过 $10^5$。\n\n令程序执行前的 $n$ 值为程序的输入，程序执行后的 $n$ 值为程序的输出，你需要分别完成下面 $10$ 个任务：\n\n1. 输入 $n$，输出 $2n$。\n1. 输入 $n$，输出 $\\binom n2$。\n1. 输入 $n$，输出 $600$。\n1. 输入 $n$，输出 $n + 1$。\n1. 输入 $n$，输出 $n^2 - 1$。\n1. 输入 $n$，输出 $n + 2000$。\n1. 输入 $n$，输出 $n + \\lfloor \\log_2 n\\rfloor$。\n1. 输入 $n$，输出 $n + \\left(n \\bmod 2\\right) + 1$。\n1. 输入 $n$，输出 $n+\\gcd(n, n - 4) + 1$。\n1. 输入 $n$，输出一个满足 $|x-n\\ln n|\\le 30$ 的正整数 $x$。\n\n**注：子任务按长度排序，与难度无关。**", "inputFormat": "该题为提交答案型试题，每个测试点对应的任务见【题目描述】。", "outputFormat": "针对给定的 $10$ 个任务，你需要分别提交你的输出文件 ``1.out`` ~ ``10.out``。\n\n每个文件需要输出若干行。\n\n第一行一个非负整数 $L$，代表你使用的语句数量。\n\n接下来 $L$ 行，每行一个语句。", "hint": "**评分标准**\n\n对于每个测试点，其内部会评测若干组测试数据。\n\n若你的输出出现下列情况，那么该测试点不得分：\n\n- 输出与要求不符。\n- 实际语句运行次数大于 $10^5$。\n- 出现无法识别或不合法的语句。\n- 使用超过 $1000$ 条语句或是标号超过 $1000$ 的变量。\n\n否则设对应子任务的评分标准为 $L_0$，那么你的得分为：\n\n$$\\mathrm{score}=\\begin{cases}11&L_0>L\\\\\\Big\\lfloor\\frac{10}{\\exp\\left(1-\\frac {L_0}L\\right)}\\Big\\rfloor&\\text{otherwise.}\\end{cases}$$\n\n下面给出各个任务对应的评分标准 $L_0$:\n\n| 编号 | $1$ | $2$ | $3$ | $4$ | $5$| $6$ | $7$ | $8$ | $9$ | $10$ |\n| :-: | :-: | :-: | :-: | :-: | :-: |  :-: | :-: | :-: | :-: | :-: |\n| $L_0$ | $3$ | $9$ | $233$ | $1$ | $10$| $29$ | $14$ | $7$ | $18$ | $14$ |\n\n**数据范围**\n\n保证 $5 \\le n \\le 100$。", "locale": "zh-CN"}}}
{"pid": "P10401", "type": "P", "difficulty": 3, "samples": [["6 1\n1 1 4 5 1 4\n1 6", "18"], ["7 10\n1 9 1 9 8 1 0\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 6\n3 5\n4 7\n2 7", "11\n0\n20\n8\n21\n8\n23\n25\n24\n11"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["洛谷原创", "O2优化", "枚举", "前缀和", "离线处理"], "title": "「XSOI-R1」区间操作 (opt)", "background": "小 A 喜欢区间操作问题。", "description": "小 A 给你了一个长度为 $n$ 的序列 $a$，并给你了 $q$ 组询问。\n\n对于每组询问，小 A 会给你两个正整数 $l,r$，你需要求出 $(a_l) \\oplus (a_l+a_{l+1}) \\oplus (a_l+a_{l+1}+a_{l+2}) \\oplus \\dots \\oplus (a_l + a_{l+1} + a_{l+2} + \\dots + a_r)$ 的值。\n\n其中 $\\oplus$ 表示异或运算。", "inputFormat": "第一行两个正整数 $n,q$，\n\n之后一行 $n$ 个整数 $a_i$，\n\n之后 $q$ 行每行两个正整数 $l,r$。", "outputFormat": "共 $q$ 行，\n\n每行一个整数表示你的答案。", "hint": "**【样例解释 #1】**\n\n$1 \\oplus (1 + 1) \\oplus (1 + 1 + 4) \\oplus (1 + 1 + 4 + 5) \\oplus (1 + 1 + 4 + 5 + 1) \\oplus (1 + 1 + 4 + 5 + 1 + 4) = 18$。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 0（13 pts）：保证 $n,q \\le 10^2$。\n\n- Subtask 1（28 pts）：保证 $n,q \\le 10^4$。\n\n- Subtask 2（19 pts）：保证 $a_i \\le 10^4$。\n\n- Subtask 3（7 pts）：保证 $n \\le 10^2$。\n\n- Subtask 4（17 pts）：保证 $a_i$ 均为 $2$ 的非负整数次幂。\n\n- Subtask 5（16 pts）：无特殊限制。\n\n对于所有测试数据，$1 \\le l \\le r \\le n \\le 10^4$，$1 \\le q \\le 10^6$，$0 \\le a_i \\le 10^{10}$。\n\nupd（2024.7.3）：添加一组 hack 数据，减少一组数据。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「XSOI-R1」区间操作 (opt)", "background": "小 A 喜欢区间操作问题。", "description": "小 A 给你了一个长度为 $n$ 的序列 $a$，并给你了 $q$ 组询问。\n\n对于每组询问，小 A 会给你两个正整数 $l,r$，你需要求出 $(a_l) \\oplus (a_l+a_{l+1}) \\oplus (a_l+a_{l+1}+a_{l+2}) \\oplus \\dots \\oplus (a_l + a_{l+1} + a_{l+2} + \\dots + a_r)$ 的值。\n\n其中 $\\oplus$ 表示异或运算。", "inputFormat": "第一行两个正整数 $n,q$，\n\n之后一行 $n$ 个整数 $a_i$，\n\n之后 $q$ 行每行两个正整数 $l,r$。", "outputFormat": "共 $q$ 行，\n\n每行一个整数表示你的答案。", "hint": "**【样例解释 #1】**\n\n$1 \\oplus (1 + 1) \\oplus (1 + 1 + 4) \\oplus (1 + 1 + 4 + 5) \\oplus (1 + 1 + 4 + 5 + 1) \\oplus (1 + 1 + 4 + 5 + 1 + 4) = 18$。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 0（13 pts）：保证 $n,q \\le 10^2$。\n\n- Subtask 1（28 pts）：保证 $n,q \\le 10^4$。\n\n- Subtask 2（19 pts）：保证 $a_i \\le 10^4$。\n\n- Subtask 3（7 pts）：保证 $n \\le 10^2$。\n\n- Subtask 4（17 pts）：保证 $a_i$ 均为 $2$ 的非负整数次幂。\n\n- Subtask 5（16 pts）：无特殊限制。\n\n对于所有测试数据，$1 \\le l \\le r \\le n \\le 10^4$，$1 \\le q \\le 10^6$，$0 \\le a_i \\le 10^{10}$。\n\nupd（2024.7.3）：添加一组 hack 数据，减少一组数据。", "locale": "zh-CN"}}}
{"pid": "P10402", "type": "P", "difficulty": 3, "samples": [["5 25 3\n3 3 3 3 3", "5\nadd 1\nadd 2\nsub 3\nsub 4\nadd 5\n"], ["3 9 3\n1 3 3", "5\nsqrt 2\nsqrt 3\nadd 1\nmul 2\nmul 3\n"], ["3 9 77\n4 5 4", "4\nadd 1\nadd 2\npow 2\nsub 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "二分", "洛谷原创", "Special Judge", "O2优化", "构造"], "title": "「XSOI-R1」凑点", "background": "", "description": "小 T 会给你一个长度为 $n$ 的整数数列，你手上有一个数 $x$，初始为 $0$，你可以执行以下操作，使得最终 $x$ 与 $c$ 的差小于 $10^{-4}$。\n\n你可以对 $x$ 进行至多 $k$ 次操作：\n\n- `add i`，对计数器 $x$ 加上 $a_i$，然后 $a_i$ 不能再进行任何操作。\n\n- `sub i`，对计数器 $x$ 减上 $a_i$，然后 $a_i$ 不能再进行任何操作。\n\n- `mul i`，对计数器 $x$ 乘上 $a_i$，然后 $a_i$ 不能再进行任何操作。\n\n- `sqrt i`，将 $a_i$ 赋值为 $\\sqrt {a_i}$，每个 $a_i$ 只能开方一次。\n\n- `pow f`，将计数器 $x$ 变为 $x^f$，$f$ 可以为浮点数。\n\n所有 $a_i$ 都必须给 $x$ 进行一次加或减或乘操作。\n\n在运算过程中，$a_i$ 和 $x$ 的值均不能超过 $10^{10}$。题目保证有解，如有多种方案，输出一种即可。\n\n本题精度要求较大，请提高算法的精度。", "inputFormat": "第一行三个整数 $n$，$k$，$c$。\n\n第二行 $n$ 个整数，表示序列 $a$。", "outputFormat": "第一行一个整数表示总操作数 $g$。\n\n接下来 $g$ 行为你的操作序列。", "hint": "**【样例解释 #1】**\n\n- $x$ 加上 $a_1$，此时 $x$ 为 $3$。\n\n- $x$ 加上 $a_2$，此时 $x$ 为 $6$。\n\n- $x$ 减去 $a_3$，此时 $x$ 为 $3$。\n\n- $x$ 减去 $a_4$，此时 $x$ 为 $0$。\n\n- $x$ 加上 $a_5$，此时 $x$ 为 $3$。\n\n**【样例解释 #2】**\n\n- 将 $a_2$ 开根号，此时 $a=[1,\\sqrt3,3]$。\n\n- 将 $a_3$ 开根号，此时 $a=[1,\\sqrt3,\\sqrt3]$。\n\n- $x$ 加上 $a_1$，此时 $x$ 为 $1$。\n\n- $x$ 乘上 $a_2$，此时 $x$ 为 $\\sqrt3$。\n\n- $x$ 乘上 $a_3$，此时 $x$ 为 $3$。\n\n**【样例解释 #3】**\n\n- $x$ 加上 $a_1$，此时 $x$ 为 $4$。\n\n- $x$ 加上 $a_2$，此时 $x$ 为 $9$。\n\n- 将 $x$ 变为 $x^2$，此时 $x$ 为 $81$。\n\n- 将 $x$ 减去 $a_3$，此时 $x$ 为 $77$。\n\n### 数据规模与约定\n\n\n**本题采用捆绑测试。**\n\n- subtask 0（10 pts）：$n\\leq 5$，$k=n^2$，保证可以使用加与减的运算得到解。\n\n- subtask 1（20 pts）：$n \\leq 5$，$k=n^2$，保证可以可以使用加、减、乘、开方运算得到解。\n\n- subtask 2（15 pts）：$n \\leq 10$，$a_i \\leq 2$，$k=n+1$。\n\n- subtask 3（55 pts）：$k=n+1$。\n\n对于所有数据：$0 \\leq n \\leq 10^{5}$，$\\sum_{i=1}^{n}{a_i} \\le 10^{10}$，$0 \\leq c\\leq 10^{10}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「XSOI-R1」凑点", "background": "", "description": "小 T 会给你一个长度为 $n$ 的整数数列，你手上有一个数 $x$，初始为 $0$，你可以执行以下操作，使得最终 $x$ 与 $c$ 的差小于 $10^{-4}$。\n\n你可以对 $x$ 进行至多 $k$ 次操作：\n\n- `add i`，对计数器 $x$ 加上 $a_i$，然后 $a_i$ 不能再进行任何操作。\n\n- `sub i`，对计数器 $x$ 减上 $a_i$，然后 $a_i$ 不能再进行任何操作。\n\n- `mul i`，对计数器 $x$ 乘上 $a_i$，然后 $a_i$ 不能再进行任何操作。\n\n- `sqrt i`，将 $a_i$ 赋值为 $\\sqrt {a_i}$，每个 $a_i$ 只能开方一次。\n\n- `pow f`，将计数器 $x$ 变为 $x^f$，$f$ 可以为浮点数。\n\n所有 $a_i$ 都必须给 $x$ 进行一次加或减或乘操作。\n\n在运算过程中，$a_i$ 和 $x$ 的值均不能超过 $10^{10}$。题目保证有解，如有多种方案，输出一种即可。\n\n本题精度要求较大，请提高算法的精度。", "inputFormat": "第一行三个整数 $n$，$k$，$c$。\n\n第二行 $n$ 个整数，表示序列 $a$。", "outputFormat": "第一行一个整数表示总操作数 $g$。\n\n接下来 $g$ 行为你的操作序列。", "hint": "**【样例解释 #1】**\n\n- $x$ 加上 $a_1$，此时 $x$ 为 $3$。\n\n- $x$ 加上 $a_2$，此时 $x$ 为 $6$。\n\n- $x$ 减去 $a_3$，此时 $x$ 为 $3$。\n\n- $x$ 减去 $a_4$，此时 $x$ 为 $0$。\n\n- $x$ 加上 $a_5$，此时 $x$ 为 $3$。\n\n**【样例解释 #2】**\n\n- 将 $a_2$ 开根号，此时 $a=[1,\\sqrt3,3]$。\n\n- 将 $a_3$ 开根号，此时 $a=[1,\\sqrt3,\\sqrt3]$。\n\n- $x$ 加上 $a_1$，此时 $x$ 为 $1$。\n\n- $x$ 乘上 $a_2$，此时 $x$ 为 $\\sqrt3$。\n\n- $x$ 乘上 $a_3$，此时 $x$ 为 $3$。\n\n**【样例解释 #3】**\n\n- $x$ 加上 $a_1$，此时 $x$ 为 $4$。\n\n- $x$ 加上 $a_2$，此时 $x$ 为 $9$。\n\n- 将 $x$ 变为 $x^2$，此时 $x$ 为 $81$。\n\n- 将 $x$ 减去 $a_3$，此时 $x$ 为 $77$。\n\n### 数据规模与约定\n\n\n**本题采用捆绑测试。**\n\n- subtask 0（10 pts）：$n\\leq 5$，$k=n^2$，保证可以使用加与减的运算得到解。\n\n- subtask 1（20 pts）：$n \\leq 5$，$k=n^2$，保证可以可以使用加、减、乘、开方运算得到解。\n\n- subtask 2（15 pts）：$n \\leq 10$，$a_i \\leq 2$，$k=n+1$。\n\n- subtask 3（55 pts）：$k=n+1$。\n\n对于所有数据：$0 \\leq n \\leq 10^{5}$，$\\sum_{i=1}^{n}{a_i} \\le 10^{10}$，$0 \\leq c\\leq 10^{10}$。", "locale": "zh-CN"}}}
{"pid": "P10403", "type": "P", "difficulty": 4, "samples": [["5\n2 3 6 3 9", "8"], ["5\n2 2 2 2 2", "16"], ["9\n6 2 3 6 4 6 8 2 5", "19"]], "limits": {"time": [750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["线段树", "二分", "2024", "洛谷原创", "O2优化", "枚举", "ST 表", "双指针 two-pointer"], "title": "「XSOI-R1」跳跃游戏", "background": "本来可怜的 $\\texttt{MhxMa}$ 想出这道题，但是已经被 $\\texttt{Ferm\\_Tawn}$ 抢了，此时 $\\texttt{MhxMa}$ 坐在电脑面前，看着马上要造好的数据，想象着自己的题难倒一大片选手的梦想破灭了。", "description": "这是一个跳跃游戏。在游戏中你可以跳到任意位置，其中有 $n$ 个点：$1 , 2 , 3, \\cdots , n$，跳到那里会有奖励分数 $a_1 , a_2 , \\cdots , a_n$。\n\n显然，这个游戏很简单，$\\texttt{MhxMa}$ 没过多久就获得了所有分数，于是改进了代码，添加了经验值这个参数。\n\n对于有奖励分数的 $n$ 个点，若从点 $x$ 跳到点 $y$，会获得经验值 $\\operatorname{score}_{x , y}(1\\le x\\le y\\le n)$：\n\n$$\\operatorname{score}_{x,y}=\\begin{cases}\\operatorname{len}  & \\operatorname{gcd}(a_x , a_{x+1} , \\dots , a_y)=2 , \\operatorname{len \\ mod} 2 = 0  \\\\ \\operatorname{len} &\\gcd(a_x , a_{x + 1} , \\dots , a_y)=3 , \\operatorname{len \\ mod} 2 = 1\\\\ 0 & \\operatorname{others} \\end{cases}$$\n\n其中，$\\operatorname {len}$ 表示区间的长度，即 $y-x+1$。\n\n**对于每一对位置 $(x,y)$，多次跳跃只会获得一次经验值。**\n\n为了向 $\\texttt{MhxMa}$ 展现你的编程实力，你决定写一个代码算出这个游戏能刷到的最大经验值。", "inputFormat": "输入共两行。\n\n输入第一行包含一个整数 $n$。\n\n第二行包含 $n$ 个整数 $a_i$。", "outputFormat": "输出一个整数，表示答案。", "hint": "**请使用较快的读入方式。**\n\n### 样例解释 #1\n\n$\\operatorname{score_{2 , 2}}= 1$。\n\n$\\operatorname{score_{2 , 4}}= 3$。\n\n$\\operatorname{score_{3 , 5}}= 3$。\n\n$\\operatorname{score_{4 , 4}}= 1$。\n\n$1+3+3+1=8$。\n\n### 样例解释 #2\n\n$\\operatorname{score_{1 , 2}}= 2$。\n\n$\\operatorname{score_{1 , 4}}= 4$。\n\n$\\operatorname{score_{2 , 3}}= 2$。\n\n$\\operatorname{score_{2 , 5}}= 4$。\n\n$\\operatorname{score_{3 , 4}}= 2$。\n\n$\\operatorname{score_{4 , 5}}= 2$。\n\n$2+ 4 + 2 + 4 + 2 + 2 = 16$。\n\n------------\n### 数据规模与约定\n\n**本题采用捆绑测试**。\n\n- Subtask 0（20 pts）：$n \\le 10^2$。 \n\n- Subtask 1（10 pts）：$n \\le 2 \\times 10^3$。\n\n- Subtask 2（20 pts）：$n \\le 10^4$。\n\n- Subtask 3（50 pts）：$n \\le 6 \\times 10^5 $。\n\n\n对于所有测试数据，$1 \\le n \\le 6 \\times 10^5$，$1 \\le a_i \\le 10^7$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「XSOI-R1」跳跃游戏", "background": "本来可怜的 $\\texttt{MhxMa}$ 想出这道题，但是已经被 $\\texttt{Ferm\\_Tawn}$ 抢了，此时 $\\texttt{MhxMa}$ 坐在电脑面前，看着马上要造好的数据，想象着自己的题难倒一大片选手的梦想破灭了。", "description": "这是一个跳跃游戏。在游戏中你可以跳到任意位置，其中有 $n$ 个点：$1 , 2 , 3, \\cdots , n$，跳到那里会有奖励分数 $a_1 , a_2 , \\cdots , a_n$。\n\n显然，这个游戏很简单，$\\texttt{MhxMa}$ 没过多久就获得了所有分数，于是改进了代码，添加了经验值这个参数。\n\n对于有奖励分数的 $n$ 个点，若从点 $x$ 跳到点 $y$，会获得经验值 $\\operatorname{score}_{x , y}(1\\le x\\le y\\le n)$：\n\n$$\\operatorname{score}_{x,y}=\\begin{cases}\\operatorname{len}  & \\operatorname{gcd}(a_x , a_{x+1} , \\dots , a_y)=2 , \\operatorname{len \\ mod} 2 = 0  \\\\ \\operatorname{len} &\\gcd(a_x , a_{x + 1} , \\dots , a_y)=3 , \\operatorname{len \\ mod} 2 = 1\\\\ 0 & \\operatorname{others} \\end{cases}$$\n\n其中，$\\operatorname {len}$ 表示区间的长度，即 $y-x+1$。\n\n**对于每一对位置 $(x,y)$，多次跳跃只会获得一次经验值。**\n\n为了向 $\\texttt{MhxMa}$ 展现你的编程实力，你决定写一个代码算出这个游戏能刷到的最大经验值。", "inputFormat": "输入共两行。\n\n输入第一行包含一个整数 $n$。\n\n第二行包含 $n$ 个整数 $a_i$。", "outputFormat": "输出一个整数，表示答案。", "hint": "**请使用较快的读入方式。**\n\n### 样例解释 #1\n\n$\\operatorname{score_{2 , 2}}= 1$。\n\n$\\operatorname{score_{2 , 4}}= 3$。\n\n$\\operatorname{score_{3 , 5}}= 3$。\n\n$\\operatorname{score_{4 , 4}}= 1$。\n\n$1+3+3+1=8$。\n\n### 样例解释 #2\n\n$\\operatorname{score_{1 , 2}}= 2$。\n\n$\\operatorname{score_{1 , 4}}= 4$。\n\n$\\operatorname{score_{2 , 3}}= 2$。\n\n$\\operatorname{score_{2 , 5}}= 4$。\n\n$\\operatorname{score_{3 , 4}}= 2$。\n\n$\\operatorname{score_{4 , 5}}= 2$。\n\n$2+ 4 + 2 + 4 + 2 + 2 = 16$。\n\n------------\n### 数据规模与约定\n\n**本题采用捆绑测试**。\n\n- Subtask 0（20 pts）：$n \\le 10^2$。 \n\n- Subtask 1（10 pts）：$n \\le 2 \\times 10^3$。\n\n- Subtask 2（20 pts）：$n \\le 10^4$。\n\n- Subtask 3（50 pts）：$n \\le 6 \\times 10^5 $。\n\n\n对于所有测试数据，$1 \\le n \\le 6 \\times 10^5$，$1 \\le a_i \\le 10^7$。", "locale": "zh-CN"}}}
{"pid": "P10404", "type": "P", "difficulty": 4, "samples": [["4\n45 66\n100 140\n2 90\n114514 1919810", "4\n6\n23\n13321"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["洛谷原创", "O2优化", "素数判断,质数,筛法"], "title": "「XSOI-R1」原神数", "background": "", "description": "原神数 $x$ 需要同时满足以下条件：\n\n- $x$ 为质数。\n\n- $x$ 的十进制位两两不同。\n\n比如 $131$ 不是原神数，因为他的百位和个位相等；$42$ 也不是，因为不是质数；$17$ 就是一个原神数。\n\n有 $q$ 次询问，现在要你求出 $l$ 到 $r$ 之间的原神数数量。", "inputFormat": "第一行一个正整数 $q$。\n\n接下来 $q$ 行每行两个正整数 $l$，$r$。", "outputFormat": "$q$ 行 $q$ 个正整数，表示答案。", "hint": "**【样例解释 #1】**\n\n在 $100 \\sim 140$ 之间的原神数有 $103,107,109,127,137,139$，共 $6$ 个。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- subtask 0（15 pts）：$1 \\le l \\le r \\le 10^2$。\n\n- subtask 1（15 pts）：$1 \\le l \\le r \\le 10^4$。\n\n- subtask 2（35 pts）：$1 \\le l \\le r \\le 10^7$。\n\n- subtask 3（35 pts）：$1 \\le l \\le r \\le 10^{18}$。\n\n对于所有数据，保证 $1 \\leq l \\leq r \\leq 10^{18}$，$1 \\leq q\\leq 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「XSOI-R1」原神数", "background": "", "description": "原神数 $x$ 需要同时满足以下条件：\n\n- $x$ 为质数。\n\n- $x$ 的十进制位两两不同。\n\n比如 $131$ 不是原神数，因为他的百位和个位相等；$42$ 也不是，因为不是质数；$17$ 就是一个原神数。\n\n有 $q$ 次询问，现在要你求出 $l$ 到 $r$ 之间的原神数数量。", "inputFormat": "第一行一个正整数 $q$。\n\n接下来 $q$ 行每行两个正整数 $l$，$r$。", "outputFormat": "$q$ 行 $q$ 个正整数，表示答案。", "hint": "**【样例解释 #1】**\n\n在 $100 \\sim 140$ 之间的原神数有 $103,107,109,127,137,139$，共 $6$ 个。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- subtask 0（15 pts）：$1 \\le l \\le r \\le 10^2$。\n\n- subtask 1（15 pts）：$1 \\le l \\le r \\le 10^4$。\n\n- subtask 2（35 pts）：$1 \\le l \\le r \\le 10^7$。\n\n- subtask 3（35 pts）：$1 \\le l \\le r \\le 10^{18}$。\n\n对于所有数据，保证 $1 \\leq l \\leq r \\leq 10^{18}$，$1 \\leq q\\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P10405", "type": "P", "difficulty": 2, "samples": [["3\n1\n5\n10", "1\n5\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": [], "title": "「SMOI-R1」Queue", "background": "签到题……", "description": "有一个人数为 $n$ 的队伍，队伍中第 $i$ 个人编号为 $i$。\n\n从第一个人依次给后面的那个人传一个数，直到传到第 $n$ 个人。给后面的那个人传数的规则为：\n\n- 第一个人的数为 $1$。\n- 如果这个人的编号为奇数，那么给后面的人传的数是他现在的数**按位与**上后面那个人的编号。\n- 如果这个人的编号为偶数，那么给后面的人传的数是他现在的数**按位异或**上后面那个人的编号。\n\n求出传给第 $n$ 个人的数字。但是求一个的太好求了，所以你要求 $t$ 种情况的。", "inputFormat": "**本题有多组数据**。\n\n第一行一个整数 $t$，表示数据组数。\n\n对于每组数据：\n\n只有一个数 $n$，代表队伍人数。", "outputFormat": "对于每组数据，输出一个数，代表传给第 $n$ 个人的数字。", "hint": "### 样例解释\n\n对于第二组数据：\n\n- 第一个人向下一个人传的数是 $1\\operatorname{and}2=0$。\n- 第二个人向下一个人传的数是 $0\\operatorname{xor}3=3$。\n- 第三个人向下一个人传的数是 $3\\operatorname{and}4=0$。\n- 第四个人向下一个人传的数是 $0\\operatorname{xor}5=5$。\n\n所以答案是 $5$。\n\n### 数据范围\n**本题采用捆绑测试**。\n\nsubtask 编号|$t\\leq$| $n\\leq$| 分值\n-|-|-|-\n$1$|$10^2$|$10^5$|$20$\n$2$|$10^6$|$10^7$|$20$\n$3$|$10^6$|$10^{18}$|$60$\n\n对于 $100\\%$ 的数据,保证 $1\\le t\\le10^6,1\\le n\\le 10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「SMOI-R1」Queue", "background": "签到题……", "description": "有一个人数为 $n$ 的队伍，队伍中第 $i$ 个人编号为 $i$。\n\n从第一个人依次给后面的那个人传一个数，直到传到第 $n$ 个人。给后面的那个人传数的规则为：\n\n- 第一个人的数为 $1$。\n- 如果这个人的编号为奇数，那么给后面的人传的数是他现在的数**按位与**上后面那个人的编号。\n- 如果这个人的编号为偶数，那么给后面的人传的数是他现在的数**按位异或**上后面那个人的编号。\n\n求出传给第 $n$ 个人的数字。但是求一个的太好求了，所以你要求 $t$ 种情况的。", "inputFormat": "**本题有多组数据**。\n\n第一行一个整数 $t$，表示数据组数。\n\n对于每组数据：\n\n只有一个数 $n$，代表队伍人数。", "outputFormat": "对于每组数据，输出一个数，代表传给第 $n$ 个人的数字。", "hint": "### 样例解释\n\n对于第二组数据：\n\n- 第一个人向下一个人传的数是 $1\\operatorname{and}2=0$。\n- 第二个人向下一个人传的数是 $0\\operatorname{xor}3=3$。\n- 第三个人向下一个人传的数是 $3\\operatorname{and}4=0$。\n- 第四个人向下一个人传的数是 $0\\operatorname{xor}5=5$。\n\n所以答案是 $5$。\n\n### 数据范围\n**本题采用捆绑测试**。\n\nsubtask 编号|$t\\leq$| $n\\leq$| 分值\n-|-|-|-\n$1$|$10^2$|$10^5$|$20$\n$2$|$10^6$|$10^7$|$20$\n$3$|$10^6$|$10^{18}$|$60$\n\n对于 $100\\%$ 的数据,保证 $1\\le t\\le10^6,1\\le n\\le 10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P10406", "type": "P", "difficulty": 5, "samples": [["3\n3 1 1\n3 1 2\n4 1 2 1\n2 3", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["树形 DP"], "title": "「SMOI-R1」Company", "background": "LAR 被老板炒了，下面都是他的梦。", "description": "城市中有 $n$ 所公司，第 $i$ 所公司有 $m_i$ 个人。\n\n一所公司可以用一棵**根为 $1$ 的**树来表示，**最初时**节点 $1$ 是老板，每个节点的子节点都是他的下属，每个节点的父节点都是他的上司。第 $i$ 棵树的大小为 $m_i$，节点从 $1$ 到 $m_i$ 编号。\n\n公司很多，政府管理起来非常麻烦，所以政府想让 LAR 把这些公司合并起来。两所公司要合并起来，需要**一所**公司的一名**最初没有下属**的人（员工或**老板**）成为**另一所**公司现在的**老板的上司**。当两个公司合并完，两所公司就是**一所公司**了。\n\n只有**互为上司和下属**的两个人才认识。\n\nmyz 是第 $1$ 棵树的节点 $x$，ljs 是第 $2$ 棵树的节点 $y$。因为 myz 和 ljs 性格十分不相符（他们不认识），所以 LAR 想让他们的**关系越远越好**。\n\n互相认识的人距离为 $1$，**两人的关系**定义为两人的人际关系网上的最短距离（可以简单认为是最终形成的树中两点的最短距离）。例如，$1$ 认识 $2$，$2$ 认识 $3$，那么 $1$ 和 $3$ 的关系就是 $2$。", "inputFormat": "第一行有一个整数 $n$，代表公司数量。\n\n第二行到第 $n+1$ 行中，第 $i + 1$ 行第一个整数是 $m_i$，代表第 $i$ 所公司的人的数量。接下来有 $m_i - 1$ 个整数，第 $j$ 个数代表这棵树中节点 $j+1$ 的上司。\n\n第 $n+2$ 行有两个整数 $x$ 和 $y$，代表 myz 是第 $1$ 棵树的节点 $x$，ljs 是第 $2$ 棵树的节点 $y$。", "outputFormat": "输出一个整数，代表 myz 和 ljs 关系的最大值。", "hint": "### 样例解释\n在还没有进行合并操作时，城市中公司如下（括号中的数是节点**初始时**所在的公司）：\n![](https://cdn.luogu.com.cn/upload/image_hosting/1g1uvci4.png)\n\n想要让关系值最大，可以让最终的公司形成下图的样子：\n![](https://cdn.luogu.com.cn/upload/image_hosting/cj518ep6.png)\n\n答案为 $8$。\n### 数据范围\n**本题采用捆绑测试**。\n\nsubtask编号|$n\\leq$|$\\sum m \\leq$|特殊情况|分值\n-|-|-|-|-\n$1$|$2$|$10^3$|无|$20$\n$2$|$10^5$|$10^6$|$x = 1$，$y=1$|$20$\n$3$|$10^5$|$10^6$|所有树都是随机树|$20$\n$4$|$10^5$|$10^6$|无|$40$\n\n**随机树产生规则**：对于节点 $i$ （$2 \\le i \\le m$）的上司从 $1$ 到 $i - 1$ 中**等概率**产生。\n\n对于 $100\\%$ 的数据，$2\\leq n\\leq 10^5$，$1 \\le m_i$，$\\sum m \\leq 10^6$，$1\\leq x\\leq m_1$，$1\\leq y\\leq m_2$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「SMOI-R1」Company", "background": "LAR 被老板炒了，下面都是他的梦。", "description": "城市中有 $n$ 所公司，第 $i$ 所公司有 $m_i$ 个人。\n\n一所公司可以用一棵**根为 $1$ 的**树来表示，**最初时**节点 $1$ 是老板，每个节点的子节点都是他的下属，每个节点的父节点都是他的上司。第 $i$ 棵树的大小为 $m_i$，节点从 $1$ 到 $m_i$ 编号。\n\n公司很多，政府管理起来非常麻烦，所以政府想让 LAR 把这些公司合并起来。两所公司要合并起来，需要**一所**公司的一名**最初没有下属**的人（员工或**老板**）成为**另一所**公司现在的**老板的上司**。当两个公司合并完，两所公司就是**一所公司**了。\n\n只有**互为上司和下属**的两个人才认识。\n\nmyz 是第 $1$ 棵树的节点 $x$，ljs 是第 $2$ 棵树的节点 $y$。因为 myz 和 ljs 性格十分不相符（他们不认识），所以 LAR 想让他们的**关系越远越好**。\n\n互相认识的人距离为 $1$，**两人的关系**定义为两人的人际关系网上的最短距离（可以简单认为是最终形成的树中两点的最短距离）。例如，$1$ 认识 $2$，$2$ 认识 $3$，那么 $1$ 和 $3$ 的关系就是 $2$。", "inputFormat": "第一行有一个整数 $n$，代表公司数量。\n\n第二行到第 $n+1$ 行中，第 $i + 1$ 行第一个整数是 $m_i$，代表第 $i$ 所公司的人的数量。接下来有 $m_i - 1$ 个整数，第 $j$ 个数代表这棵树中节点 $j+1$ 的上司。\n\n第 $n+2$ 行有两个整数 $x$ 和 $y$，代表 myz 是第 $1$ 棵树的节点 $x$，ljs 是第 $2$ 棵树的节点 $y$。", "outputFormat": "输出一个整数，代表 myz 和 ljs 关系的最大值。", "hint": "### 样例解释\n在还没有进行合并操作时，城市中公司如下（括号中的数是节点**初始时**所在的公司）：\n![](https://cdn.luogu.com.cn/upload/image_hosting/1g1uvci4.png)\n\n想要让关系值最大，可以让最终的公司形成下图的样子：\n![](https://cdn.luogu.com.cn/upload/image_hosting/cj518ep6.png)\n\n答案为 $8$。\n### 数据范围\n**本题采用捆绑测试**。\n\nsubtask编号|$n\\leq$|$\\sum m \\leq$|特殊情况|分值\n-|-|-|-|-\n$1$|$2$|$10^3$|无|$20$\n$2$|$10^5$|$10^6$|$x = 1$，$y=1$|$20$\n$3$|$10^5$|$10^6$|所有树都是随机树|$20$\n$4$|$10^5$|$10^6$|无|$40$\n\n**随机树产生规则**：对于节点 $i$ （$2 \\le i \\le m$）的上司从 $1$ 到 $i - 1$ 中**等概率**产生。\n\n对于 $100\\%$ 的数据，$2\\leq n\\leq 10^5$，$1 \\le m_i$，$\\sum m \\leq 10^6$，$1\\leq x\\leq m_1$，$1\\leq y\\leq m_2$。", "locale": "zh-CN"}}}
{"pid": "P10407", "type": "P", "difficulty": 5, "samples": [["2\n2 3", "33"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "单调队列"], "title": "「SMOI-R1」Game", "background": "myz 很喜欢玩一款病毒游戏。", "description": "在这个游戏里，一开始有 $n$ 个病毒，每个病毒的危害值为 $1$。\n\n每隔一段时间，病毒就会变异，会分裂成两个病毒，右边的病毒会比左边的病毒危害值多 $1$，变异过的病毒不会再变异。\n\n每个病毒有个变异极限 $b_i$，当这个病毒变异到 $b_i$ 时，这个病毒就会停止变异。也就是说，第 $i$ 个病毒最后都会分裂成一个危害值为 $\\{1,2,3,\\ldots,b_i\\}$ 的病毒序列，当所有病毒变异完时，游戏开始，最终变异完的序列是 $\\{1,2,3,\\ldots,b_1,1,2,3,\\ldots,b_2,\\ldots,1,2,3,\\ldots,b_n\\}$。\n\n每次游戏，系统会选择一个区间，myz 需要把这个区间的病毒全部杀死，如果这个区间内的病毒的危害值的最大值是 $x$，那么 myz 需要花费 $x$ 的能量才能消灭它们。\n\n因为不知道系统会选择哪个区间，myz 想知道每个区间需要消耗的**能量值之和**。\n\n由于答案太大了，myz 想让你把答案对 $998244353$ 取模。", "inputFormat": "第一行有一个整数 $n$，表示最开始有 $n$ 个病毒。\n\n第二行有 $n$ 个整数，第 $i$ 个整数是 $b_i$，表示第 $i$ 个病毒的变异上限。", "outputFormat": "一个整数，表示 myz 需要消耗的能量值之和，答案对 $998244353$ 取模。", "hint": "### 样例解释\n第一个样例，病毒最后分裂成 $\\{1,2,1,2,3\\}$，区间  $[1,1],[1,2],[1,3],[1,4],[1,5],[2,2],[2,3],[2,4],[2,5],[3,3],[3,4],[3,5],[4,4],[4,5],[5,5]$ 的最小代价和就是 $1+2+2+2+3+2+2+2+3+1+2+3+2+3+3=33$。\n\n### 数据范围\n**本题采用捆绑测试**。\n\nsubtask 编号|$n\\leq$|$b_i\\leq$|特殊性质|分值\n-|-|-|-|-\n$1$|$10^2$|$10^2$|无|$20$\n$2$|$10^4$|$10^2$|无|$20$\n$3$|$10^6$|$10^9$|A|$20$\n$4$|$10^6$|$10^9$|无|$40$\n\n**特殊性质 A**： $b_1 \\leq b_2 \\leq \\ldots \\leq b_n$。\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le10^6$，$1\\le b_i\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「SMOI-R1」Game", "background": "myz 很喜欢玩一款病毒游戏。", "description": "在这个游戏里，一开始有 $n$ 个病毒，每个病毒的危害值为 $1$。\n\n每隔一段时间，病毒就会变异，会分裂成两个病毒，右边的病毒会比左边的病毒危害值多 $1$，变异过的病毒不会再变异。\n\n每个病毒有个变异极限 $b_i$，当这个病毒变异到 $b_i$ 时，这个病毒就会停止变异。也就是说，第 $i$ 个病毒最后都会分裂成一个危害值为 $\\{1,2,3,\\ldots,b_i\\}$ 的病毒序列，当所有病毒变异完时，游戏开始，最终变异完的序列是 $\\{1,2,3,\\ldots,b_1,1,2,3,\\ldots,b_2,\\ldots,1,2,3,\\ldots,b_n\\}$。\n\n每次游戏，系统会选择一个区间，myz 需要把这个区间的病毒全部杀死，如果这个区间内的病毒的危害值的最大值是 $x$，那么 myz 需要花费 $x$ 的能量才能消灭它们。\n\n因为不知道系统会选择哪个区间，myz 想知道每个区间需要消耗的**能量值之和**。\n\n由于答案太大了，myz 想让你把答案对 $998244353$ 取模。", "inputFormat": "第一行有一个整数 $n$，表示最开始有 $n$ 个病毒。\n\n第二行有 $n$ 个整数，第 $i$ 个整数是 $b_i$，表示第 $i$ 个病毒的变异上限。", "outputFormat": "一个整数，表示 myz 需要消耗的能量值之和，答案对 $998244353$ 取模。", "hint": "### 样例解释\n第一个样例，病毒最后分裂成 $\\{1,2,1,2,3\\}$，区间  $[1,1],[1,2],[1,3],[1,4],[1,5],[2,2],[2,3],[2,4],[2,5],[3,3],[3,4],[3,5],[4,4],[4,5],[5,5]$ 的最小代价和就是 $1+2+2+2+3+2+2+2+3+1+2+3+2+3+3=33$。\n\n### 数据范围\n**本题采用捆绑测试**。\n\nsubtask 编号|$n\\leq$|$b_i\\leq$|特殊性质|分值\n-|-|-|-|-\n$1$|$10^2$|$10^2$|无|$20$\n$2$|$10^4$|$10^2$|无|$20$\n$3$|$10^6$|$10^9$|A|$20$\n$4$|$10^6$|$10^9$|无|$40$\n\n**特殊性质 A**： $b_1 \\leq b_2 \\leq \\ldots \\leq b_n$。\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le10^6$，$1\\le b_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10408", "type": "P", "difficulty": 5, "samples": [["2 5\n1 2 3 2\n1 2\n2 0 4\n1 2\n2 3 1\n1 3", "4\n7\n10"]], "limits": {"time": [680, 680, 680, 680, 680, 680, 680, 680, 680, 680], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "根号分治"], "title": "「SMOI-R1」Apple", "background": "**为了卡掉错误算法，我们把时限改为 680ms。**", "description": "LAR 有 $2^n$ 个苹果，苹果用 $0$ 到 $2^n - 1$ 编号，编号为 $i$ 的苹果的价值是 $v_i$。\n\n如果 $A\\operatorname{or}B=A$，那么可以说 $A$ 包含 $B$（$\\operatorname{or}$ 是按位或）。\n\n因为 LAR 的苹果太多了，所以他不知道如何挑选苹果。他想进行一些操作，方便他吃苹果。\n\n总共有两种操作，共 $q$ 个操作：\n\n- $1\\ S$ ，询问所有编号被 $S$ 包含的苹果的价值总和。\n- $2\\ S\\ A$ ，改变编号为 $S$ 的苹果的价值为 $A$（将 $v_S$ 改为 $A$）。", "inputFormat": "第一行有两个整数 $n$ 和 $q$。$q$ 代表操作次数。\n\n第二行有 $2^n$ 个数，第 $i$ 个数代表 $v_{i-1}$ 的值。\n\n接下来有 $q$ 行，每行代表 LAR 要进行的一个操作，详细见上文。", "outputFormat": "对于每个操作 $1$，输出一个数，代表这个询问的答案。", "hint": "### 样例解释\n初始时 $v=[1,2,3,2]$。\n\n第一个操作时询问所有编号被 $2$ 包含的苹果的价值总和。被 $2$ 包含的数为 $0,2$，所以答案为 $v_0 + v_2=4$。\n\n第二个操作是把 $v_0$ 改为 $4$，此时 $v=[4,2,3,2]$。\n\n第三个操作时询问所有编号被 $2$ 包含的苹果的价值总和。被 $2$ 包含的数为 $0,2$，所以答案为 $v_0 + v_2=7$。\n\n第四个操作是把 $v_3$ 改为 $1$，此时 $v=[4,2,3,1]$。\n\n第五个操作时询问所有编号被 $3$ 包含的苹果的价值总和。被 $3$ 包含的数为 $0,1,2,3$，所以答案为 $v_0 + v_1 + v_2 + v_3=10$。\n### 数据范围\n**本题采用捆绑测试**。\n\nsubtask 编号|$n\\leq$|$q\\leq$|特殊性质|分值\n-|-|-|-|-\n$1$|$10$|$10^4$|无|$10$\n$2$|$16$|$3\\times 10^5$|无|$20$\n$3$|$20$|$3\\times10^5$|只有操作 1|$10$\n$4$|$20$|$10^5$|无|$20$\n$5$|$20$|$3\\times10^5$|无|$40$\n\n对于 $100\\%$ 的数据，保证 $1\\le n \\leq 20$ ，$1 \\le q\\leq3\\times10^5$，$0\\leq v_i\\leq 2^{31}-1$ 。\n\n**提示**：本题输入量较大，请使用快读。请注意代码**常数**。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「SMOI-R1」Apple", "background": "**为了卡掉错误算法，我们把时限改为 680ms。**", "description": "LAR 有 $2^n$ 个苹果，苹果用 $0$ 到 $2^n - 1$ 编号，编号为 $i$ 的苹果的价值是 $v_i$。\n\n如果 $A\\operatorname{or}B=A$，那么可以说 $A$ 包含 $B$（$\\operatorname{or}$ 是按位或）。\n\n因为 LAR 的苹果太多了，所以他不知道如何挑选苹果。他想进行一些操作，方便他吃苹果。\n\n总共有两种操作，共 $q$ 个操作：\n\n- $1\\ S$ ，询问所有编号被 $S$ 包含的苹果的价值总和。\n- $2\\ S\\ A$ ，改变编号为 $S$ 的苹果的价值为 $A$（将 $v_S$ 改为 $A$）。", "inputFormat": "第一行有两个整数 $n$ 和 $q$。$q$ 代表操作次数。\n\n第二行有 $2^n$ 个数，第 $i$ 个数代表 $v_{i-1}$ 的值。\n\n接下来有 $q$ 行，每行代表 LAR 要进行的一个操作，详细见上文。", "outputFormat": "对于每个操作 $1$，输出一个数，代表这个询问的答案。", "hint": "### 样例解释\n初始时 $v=[1,2,3,2]$。\n\n第一个操作时询问所有编号被 $2$ 包含的苹果的价值总和。被 $2$ 包含的数为 $0,2$，所以答案为 $v_0 + v_2=4$。\n\n第二个操作是把 $v_0$ 改为 $4$，此时 $v=[4,2,3,2]$。\n\n第三个操作时询问所有编号被 $2$ 包含的苹果的价值总和。被 $2$ 包含的数为 $0,2$，所以答案为 $v_0 + v_2=7$。\n\n第四个操作是把 $v_3$ 改为 $1$，此时 $v=[4,2,3,1]$。\n\n第五个操作时询问所有编号被 $3$ 包含的苹果的价值总和。被 $3$ 包含的数为 $0,1,2,3$，所以答案为 $v_0 + v_1 + v_2 + v_3=10$。\n### 数据范围\n**本题采用捆绑测试**。\n\nsubtask 编号|$n\\leq$|$q\\leq$|特殊性质|分值\n-|-|-|-|-\n$1$|$10$|$10^4$|无|$10$\n$2$|$16$|$3\\times 10^5$|无|$20$\n$3$|$20$|$3\\times10^5$|只有操作 1|$10$\n$4$|$20$|$10^5$|无|$20$\n$5$|$20$|$3\\times10^5$|无|$40$\n\n对于 $100\\%$ 的数据，保证 $1\\le n \\leq 20$ ，$1 \\le q\\leq3\\times10^5$，$0\\leq v_i\\leq 2^{31}-1$ 。\n\n**提示**：本题输入量较大，请使用快读。请注意代码**常数**。", "locale": "zh-CN"}}}
{"pid": "P10409", "type": "P", "difficulty": 1, "samples": [["14:00", "14:00"], ["09:07", "09:07"], ["03:22", "27:22"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "字符串", "洛谷原创", "O2优化", "洛谷月赛"], "title": "「QFOI R2」水落溪流浅浅", "background": "", "description": "小 R 是一个可爱的女孩子，某天晚上 $23$ 点她在提交作业时，发现截止时间是当天凌晨 $0$ 点。为了避免悲剧再次发生，她向你介绍“$30$ 小时制”。\n\n$30$ 小时制的一天长度依然为 $24$ 小时，只是每天的时间范围从 $00:00\\sim 23:59$ 变成了 $06:00\\sim 29:59$。其中，对于 $24$ 小时制下在 $06:00\\sim 23:59$ 之间的时间，其表示方式不变，而到了次日 $00:00$ 以后，保持日期不变，时间的小时部分继续增加，直到到达次日 $06:00$。\n\n例如，下表是一些时间的对应关系：\n\n|$24$ 小时制|$30$ 小时制|\n|:-:|:-:|\n|$2024$ 年 $2$ 月 $13$ 日 $06:00$|$2024$ 年 $2$ 月 $13$ 日 $06:00$|\n|$2024$ 年 $2$ 月 $13$ 日 $12:00$|$2024$ 年 $2$ 月 $13$ 日 $12:00$|\n|$2024$ 年 $2$ 月 $13$ 日 $18:00$|$2024$ 年 $2$ 月 $13$ 日 $18:00$|\n|$2024$ 年 $2$ 月 $14$ 日 $00:00$|$2024$ 年 $2$ 月 $13$ 日 $24:00$|\n|$2024$ 年 $2$ 月 $14$ 日 $05:59$|$2024$ 年 $2$ 月 $13$ 日 $29:59$|\n|$2024$ 年 $2$ 月 $14$ 日 $06:00$|$2024$ 年 $2$ 月 $14$ 日 $06:00$|\n\n现给定一个 $24$ 小时制时间，请将其转化为 $30$ 小时制。\n\n由于小 R 也认为闰年处理很烦，因此你不需要告诉她日期，只需要告诉她时间即可。", "inputFormat": "一行一个字符串，格式为 `hh:mm`，表示一个 $24$ 小时制时间。特别地，若小时和分钟不足两位数，会补前导零至两位。", "outputFormat": "一行一个字符串，格式为 `hh:mm`，表示对应的 $30$ 小时制时间。若小时和分钟不足两位数，你同样需要补前导零至两位。你不需要考虑日期是否变化。", "hint": "**样例 $1$ 解释**\n\n$14:00$ 属于 $06:00\\sim 23:59$ 的范围，因此表示方式不变。\n\n---\n\n**数据范围**\n\n本题不采用捆绑测试。\n\n对于全部数据：保证输入为【输入格式】中约定合法的 $24$ 小时制时间。\n\n---\n\n**提示**\n\n【题目描述】部分的表格提供了更多可供使用的样例。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「QFOI R2」水落溪流浅浅", "background": "", "description": "小 R 是一个可爱的女孩子，某天晚上 $23$ 点她在提交作业时，发现截止时间是当天凌晨 $0$ 点。为了避免悲剧再次发生，她向你介绍“$30$ 小时制”。\n\n$30$ 小时制的一天长度依然为 $24$ 小时，只是每天的时间范围从 $00:00\\sim 23:59$ 变成了 $06:00\\sim 29:59$。其中，对于 $24$ 小时制下在 $06:00\\sim 23:59$ 之间的时间，其表示方式不变，而到了次日 $00:00$ 以后，保持日期不变，时间的小时部分继续增加，直到到达次日 $06:00$。\n\n例如，下表是一些时间的对应关系：\n\n|$24$ 小时制|$30$ 小时制|\n|:-:|:-:|\n|$2024$ 年 $2$ 月 $13$ 日 $06:00$|$2024$ 年 $2$ 月 $13$ 日 $06:00$|\n|$2024$ 年 $2$ 月 $13$ 日 $12:00$|$2024$ 年 $2$ 月 $13$ 日 $12:00$|\n|$2024$ 年 $2$ 月 $13$ 日 $18:00$|$2024$ 年 $2$ 月 $13$ 日 $18:00$|\n|$2024$ 年 $2$ 月 $14$ 日 $00:00$|$2024$ 年 $2$ 月 $13$ 日 $24:00$|\n|$2024$ 年 $2$ 月 $14$ 日 $05:59$|$2024$ 年 $2$ 月 $13$ 日 $29:59$|\n|$2024$ 年 $2$ 月 $14$ 日 $06:00$|$2024$ 年 $2$ 月 $14$ 日 $06:00$|\n\n现给定一个 $24$ 小时制时间，请将其转化为 $30$ 小时制。\n\n由于小 R 也认为闰年处理很烦，因此你不需要告诉她日期，只需要告诉她时间即可。", "inputFormat": "一行一个字符串，格式为 `hh:mm`，表示一个 $24$ 小时制时间。特别地，若小时和分钟不足两位数，会补前导零至两位。", "outputFormat": "一行一个字符串，格式为 `hh:mm`，表示对应的 $30$ 小时制时间。若小时和分钟不足两位数，你同样需要补前导零至两位。你不需要考虑日期是否变化。", "hint": "**样例 $1$ 解释**\n\n$14:00$ 属于 $06:00\\sim 23:59$ 的范围，因此表示方式不变。\n\n---\n\n**数据范围**\n\n本题不采用捆绑测试。\n\n对于全部数据：保证输入为【输入格式】中约定合法的 $24$ 小时制时间。\n\n---\n\n**提示**\n\n【题目描述】部分的表格提供了更多可供使用的样例。", "locale": "zh-CN"}}}
{"pid": "P10410", "type": "P", "difficulty": 2, "samples": [["0.40 0.60 0.00 0.00 4.00 0.00 1.00 5.00", "2.500000000000"], ["0.20 0.40 0.00 0.00 4.00 0.00 1.00 5.00", "2.800000000000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "洛谷原创", "Special Judge", "O2优化", "洛谷月赛"], "title": "「QFOI R2」寺秋山霭苍苍", "background": "本题可能用到的公式：\n\n两点间的距离公式：$(x_1,y_1),(x_2,y_2)$ 之间的距离为 $\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。\n\n海伦公式：若三角形三边长为 $a,b,c$，设半周长 $p=\\frac{a+b+c}{2}$，则三角形面积为 $S=\\sqrt{p(p-a)(p-b)(p-c)}$。", "description": "小 R 是一个可爱的女孩子，她的几何太差了，于是她向你求助这道几何题。\n\n在平面直角坐标系中，有一个 $\\triangle\\textrm{ABC}$，其顶点坐标为 $\\textrm{A}(x_1,y_1),\\textrm{B}(x_2,y_2),\\textrm{C}(x_3,y_3)$。\n\n对于**实数** $p\\in(0,1)$，在 $\\textrm{BC},\\textrm{CA},\\textrm{AB}$ 边上分别取点 $\\textrm{D},\\textrm{E},\\textrm{F}$，使得 $\\frac{|\\textrm{AF}|}{|\\textrm{AB}|}=\\frac{|\\textrm{BD}|}{|\\textrm{BC}|}=\\frac{|\\textrm{CE}|}{|\\textrm{CA}|}=p$，则称 $\\triangle\\textrm{DEF}$ 为 $\\triangle\\textrm{ABC}$ 的“$p$ 比例三角形”。\n\n请在 $[l,r]$ 范围内选择实数 $p$，使得 $\\triangle\\textrm{ABC}$ 的“$p$ 比例三角形”的面积最小。你需要求出这个面积。", "inputFormat": "一行八个**实数** $l,r,x_1,y_1,x_2,y_2,x_3,y_3$。", "outputFormat": "一行一个**实数** $S_{\\min}$，表示最小面积。\n\n你的输出被认为是正确的，当且仅当其与标准答案的绝对或相对误差不超过 $10^{-4}$。\n", "hint": "**样例 $1$ 解释**\n\n可以证明，当 $p=0.5$ 时面积最小，为 $2.5$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/stzw0bwl.png)\n\n---\n\n**样例 $2$ 解释**\n\n可以证明，当 $p=0.4$ 时面积最小，为 $2.8$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hf4xj9tc.png)\n\n---\n\n**评分方式**\n\n本题采用自定义校验器（Special Judge）进行评测。\n\n你的输出被认为是正确的，当且仅当其与标准答案的绝对或相对误差不超过 $10^{-4}$。\n\n---\n\n**数据范围**\n\n**本题采用捆绑测试。只有通过子任务中所有测试点以及所有依赖的子任务，才能获得相应的分数。**\n\n对于全部数据：$0 < l < r < 1$，$0\\le x_1,y_1,x_2,y_2,x_3,y_3\\le 10^5$，保证输入构成三角形，所有实数的小数点后位数不超过 $2$。\n\n- 子任务一（$20$ 分）：$l=0.10,r=0.90$。\n- 子任务二（$20$ 分）：$x_1=y_1=y_2=x_3=0.00$。\n- 子任务三（$20$ 分）：$x_1=y_1=y_2=0.00$。依赖子任务二。\n- 子任务四（$40$ 分）：无特殊限制。依赖子任务一、二、三。\n\n---\n\n**提示**\n\n本题可能用到的公式：\n\n两点间的距离公式：$(x_1,y_1),(x_2,y_2)$ 之间的距离为 $\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。\n\n海伦公式：若三角形三边长为 $a,b,c$，设半周长 $p=\\frac{a+b+c}{2}$，则三角形面积为 $S=\\sqrt{p(p-a)(p-b)(p-c)}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「QFOI R2」寺秋山霭苍苍", "background": "本题可能用到的公式：\n\n两点间的距离公式：$(x_1,y_1),(x_2,y_2)$ 之间的距离为 $\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。\n\n海伦公式：若三角形三边长为 $a,b,c$，设半周长 $p=\\frac{a+b+c}{2}$，则三角形面积为 $S=\\sqrt{p(p-a)(p-b)(p-c)}$。", "description": "小 R 是一个可爱的女孩子，她的几何太差了，于是她向你求助这道几何题。\n\n在平面直角坐标系中，有一个 $\\triangle\\textrm{ABC}$，其顶点坐标为 $\\textrm{A}(x_1,y_1),\\textrm{B}(x_2,y_2),\\textrm{C}(x_3,y_3)$。\n\n对于**实数** $p\\in(0,1)$，在 $\\textrm{BC},\\textrm{CA},\\textrm{AB}$ 边上分别取点 $\\textrm{D},\\textrm{E},\\textrm{F}$，使得 $\\frac{|\\textrm{AF}|}{|\\textrm{AB}|}=\\frac{|\\textrm{BD}|}{|\\textrm{BC}|}=\\frac{|\\textrm{CE}|}{|\\textrm{CA}|}=p$，则称 $\\triangle\\textrm{DEF}$ 为 $\\triangle\\textrm{ABC}$ 的“$p$ 比例三角形”。\n\n请在 $[l,r]$ 范围内选择实数 $p$，使得 $\\triangle\\textrm{ABC}$ 的“$p$ 比例三角形”的面积最小。你需要求出这个面积。", "inputFormat": "一行八个**实数** $l,r,x_1,y_1,x_2,y_2,x_3,y_3$。", "outputFormat": "一行一个**实数** $S_{\\min}$，表示最小面积。\n\n你的输出被认为是正确的，当且仅当其与标准答案的绝对或相对误差不超过 $10^{-4}$。\n", "hint": "**样例 $1$ 解释**\n\n可以证明，当 $p=0.5$ 时面积最小，为 $2.5$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/stzw0bwl.png)\n\n---\n\n**样例 $2$ 解释**\n\n可以证明，当 $p=0.4$ 时面积最小，为 $2.8$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hf4xj9tc.png)\n\n---\n\n**评分方式**\n\n本题采用自定义校验器（Special Judge）进行评测。\n\n你的输出被认为是正确的，当且仅当其与标准答案的绝对或相对误差不超过 $10^{-4}$。\n\n---\n\n**数据范围**\n\n**本题采用捆绑测试。只有通过子任务中所有测试点以及所有依赖的子任务，才能获得相应的分数。**\n\n对于全部数据：$0 < l < r < 1$，$0\\le x_1,y_1,x_2,y_2,x_3,y_3\\le 10^5$，保证输入构成三角形，所有实数的小数点后位数不超过 $2$。\n\n- 子任务一（$20$ 分）：$l=0.10,r=0.90$。\n- 子任务二（$20$ 分）：$x_1=y_1=y_2=x_3=0.00$。\n- 子任务三（$20$ 分）：$x_1=y_1=y_2=0.00$。依赖子任务二。\n- 子任务四（$40$ 分）：无特殊限制。依赖子任务一、二、三。\n\n---\n\n**提示**\n\n本题可能用到的公式：\n\n两点间的距离公式：$(x_1,y_1),(x_2,y_2)$ 之间的距离为 $\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。\n\n海伦公式：若三角形三边长为 $a,b,c$，设半周长 $p=\\frac{a+b+c}{2}$，则三角形面积为 $S=\\sqrt{p(p-a)(p-b)(p-c)}$。", "locale": "zh-CN"}}}
{"pid": "P10411", "type": "P", "difficulty": 3, "samples": [["9", "9"], ["120", "1"], ["2310", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "贪心", "数论", "洛谷原创", "O2优化", "洛谷月赛"], "title": "「QFOI R2」树色尤含残雨", "background": "", "description": "小 R 是一个可爱的女孩子，她喜欢分解质因数。\n\n她有一个正整数 $x$。每次操作可以选择 $p_1,\\alpha_1,p_2,\\alpha_2$ 满足 $p_1,p_2$ 为两不同质数且 $\\alpha_1,\\alpha_2$ 为正整数，若 $x$ 是 $p_1^{\\alpha_1}p_2^{\\alpha_2}$ 的整数倍，就将 $x$ 除以 $p_1^{\\alpha_1}p_2^{\\alpha_2}$，否则操作无效。\n\n请你求出通过若干次操作可以得到的最小的 $x$。", "inputFormat": "一行一个整数 $x$。", "outputFormat": "一个整数，表示可以得到的最小的 $x$。", "hint": "**样例 $1$ 解释**\n\n无法进行任何有效操作。\n\n---\n\n**样例 $2$ 解释**\n\n可以进行以下两次操作：\n\n- 令 $p_1=2,\\alpha_1=1,p_2=3,\\alpha_2=1$，将 $x$ 除以 $p_1^{\\alpha_1}p_2^{\\alpha_2}=2^13^1=6$，得到 $x=20$。\n- 令 $p_1=2,\\alpha_1=2,p_2=5,\\alpha_2=1$，将 $x$ 除以 $p_1^{\\alpha_1}p_2^{\\alpha_2}=2^25^1=20$，得到 $x=1$。\n\n---\n\n**数据范围**\n\n**本题采用捆绑测试。只有通过子任务中所有测试点以及所有依赖的子任务，才能获得相应的分数。**\n\n对于全部数据：$2\\le x\\le 10^9$。\n\n- 子任务一（$10$ 分）：$x\\le 10$。\n- 子任务二（$20$ 分）：$x$ 为“无平方因子数”$^\\dagger$。\n- 子任务三（$20$ 分）：$x$ 为一个质数的正整数次幂。\n- 子任务四（$20$ 分）：$x\\le 10^5$。依赖子任务一。\n- 子任务五（$30$ 分）：无特殊限制。依赖子任务一、二、三、四。\n\n$\\dagger$ 称一个数 $x$ 为“无平方因子数”，当且仅当不存在大于一的整数 $k$，使得 $x$ 是 $k^2$ 的整数倍。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「QFOI R2」树色尤含残雨", "background": "", "description": "小 R 是一个可爱的女孩子，她喜欢分解质因数。\n\n她有一个正整数 $x$。每次操作可以选择 $p_1,\\alpha_1,p_2,\\alpha_2$ 满足 $p_1,p_2$ 为两不同质数且 $\\alpha_1,\\alpha_2$ 为正整数，若 $x$ 是 $p_1^{\\alpha_1}p_2^{\\alpha_2}$ 的整数倍，就将 $x$ 除以 $p_1^{\\alpha_1}p_2^{\\alpha_2}$，否则操作无效。\n\n请你求出通过若干次操作可以得到的最小的 $x$。", "inputFormat": "一行一个整数 $x$。", "outputFormat": "一个整数，表示可以得到的最小的 $x$。", "hint": "**样例 $1$ 解释**\n\n无法进行任何有效操作。\n\n---\n\n**样例 $2$ 解释**\n\n可以进行以下两次操作：\n\n- 令 $p_1=2,\\alpha_1=1,p_2=3,\\alpha_2=1$，将 $x$ 除以 $p_1^{\\alpha_1}p_2^{\\alpha_2}=2^13^1=6$，得到 $x=20$。\n- 令 $p_1=2,\\alpha_1=2,p_2=5,\\alpha_2=1$，将 $x$ 除以 $p_1^{\\alpha_1}p_2^{\\alpha_2}=2^25^1=20$，得到 $x=1$。\n\n---\n\n**数据范围**\n\n**本题采用捆绑测试。只有通过子任务中所有测试点以及所有依赖的子任务，才能获得相应的分数。**\n\n对于全部数据：$2\\le x\\le 10^9$。\n\n- 子任务一（$10$ 分）：$x\\le 10$。\n- 子任务二（$20$ 分）：$x$ 为“无平方因子数”$^\\dagger$。\n- 子任务三（$20$ 分）：$x$ 为一个质数的正整数次幂。\n- 子任务四（$20$ 分）：$x\\le 10^5$。依赖子任务一。\n- 子任务五（$30$ 分）：无特殊限制。依赖子任务一、二、三、四。\n\n$\\dagger$ 称一个数 $x$ 为“无平方因子数”，当且仅当不存在大于一的整数 $k$，使得 $x$ 是 $k^2$ 的整数倍。", "locale": "zh-CN"}}}
{"pid": "P10412", "type": "P", "difficulty": 4, "samples": [["5 1 2 5\n2 -2 3 -3 -1", "1"], ["5 2 1 5\n2 -2 3 -3 -1", "1"], ["5 1 1 1\n0 1 2 3 4", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "洛谷原创", "O2优化", "前缀和", "差分", "洛谷月赛"], "title": "「QFOI R2」钟声远带斜阳", "background": "", "description": "**注意：本题中的所有数列下标从 $0$ 开始。**\n\n小 R 是一个可爱的女孩子，她喜欢研究无穷数列。\n\n她称一个无穷数列 $b$ 是美妙的，当且仅当存在自然数 $k_0$，使得对于所有 $k\\ge k_0$，都满足 $b$ 中下标在区间 $[k_0,k]$ 内的所有数的和非负（即 $\\sum_{i=k_0}^kb_i\\ge 0$）。例如，数列 $\\alpha_i=i-5$ 是美妙的，取 $k_0=5$ 符合要求；但 $\\beta_i=-i$ 不是美妙的。\n\n她目前只有一个长度为 $n$ 的有穷数列 $a$，可以进行任意次以下三种操作：\n\n1. 花费 $p$ 的代价，选择一个整数 $i$（$0\\le i < n$），将 $a_i$ 增加一。\n1. 花费 $q$ 的代价，选择一个整数 $i$（$0\\le i < n$），将 $a_i$ 删除，同时更新 $n$ 为新的数列长度。**不能将数列删空。**\n1. 花费 $r$ 的代价，选择两个整数 $i,j$（$0\\le i < j < n$），交换 $a_i$ 与 $a_j$。\n\n她希望在若干次操作后，用无限个有穷数列 $a$ 依次相接得到无穷数列 $b$（即 $b_i=a_{i\\bmod n}$），使得 $b$ 是美妙的。请你求出最小的代价。", "inputFormat": "第一行四个整数 $n,p,q,r$。\n\n第二行 $n$ 个整数，表示数列 $a$。", "outputFormat": "一行，一个整数，表示最小代价。", "hint": "**样例 $1$ 解释**\n\n花费 $p=1$ 的代价将 $a_3$ 增加一，得到数列 $b=[2,-2,3,-2,-1,2,-2,3,-2,-1,\\cdots]$ 是美妙的，取 $k_0=2$ 符合要求。\n\n可以证明不存在代价更小的方案。\n\n---\n\n**样例 $2$ 解释**\n\n花费 $q=1$ 的代价将 $a_1$ 删除，得到数列 $b=[2,3,-3,-1,2,3,-3,-1,\\cdots]$ 是美妙的，取 $k_0=0$ 符合要求。\n\n可以证明不存在代价更小的方案。\n\n---\n\n**数据范围**\n\n**本题采用捆绑测试。只有通过子任务中所有测试点以及所有依赖的子任务，才能获得相应的分数。**\n\n对于全部数据：$1\\le n\\le 10^5$，$1\\le p,q,r\\le 10^9$，$|a_i|\\le 10^9$。\n\n- 子任务一（$10$ 分）：$n=1$。\n- 子任务二（$10$ 分）：$n\\le 10$。依赖子任务一。\n- 子任务三（$20$ 分）：$|a_i|\\le 1$。\n- 子任务四（$20$ 分）：$\\sum|a_i|\\le 10^5$。依赖子任务三。\n- 子任务五（$40$ 分）：无特殊限制。依赖子任务一、二、三、四。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「QFOI R2」钟声远带斜阳", "background": "", "description": "**注意：本题中的所有数列下标从 $0$ 开始。**\n\n小 R 是一个可爱的女孩子，她喜欢研究无穷数列。\n\n她称一个无穷数列 $b$ 是美妙的，当且仅当存在自然数 $k_0$，使得对于所有 $k\\ge k_0$，都满足 $b$ 中下标在区间 $[k_0,k]$ 内的所有数的和非负（即 $\\sum_{i=k_0}^kb_i\\ge 0$）。例如，数列 $\\alpha_i=i-5$ 是美妙的，取 $k_0=5$ 符合要求；但 $\\beta_i=-i$ 不是美妙的。\n\n她目前只有一个长度为 $n$ 的有穷数列 $a$，可以进行任意次以下三种操作：\n\n1. 花费 $p$ 的代价，选择一个整数 $i$（$0\\le i < n$），将 $a_i$ 增加一。\n1. 花费 $q$ 的代价，选择一个整数 $i$（$0\\le i < n$），将 $a_i$ 删除，同时更新 $n$ 为新的数列长度。**不能将数列删空。**\n1. 花费 $r$ 的代价，选择两个整数 $i,j$（$0\\le i < j < n$），交换 $a_i$ 与 $a_j$。\n\n她希望在若干次操作后，用无限个有穷数列 $a$ 依次相接得到无穷数列 $b$（即 $b_i=a_{i\\bmod n}$），使得 $b$ 是美妙的。请你求出最小的代价。", "inputFormat": "第一行四个整数 $n,p,q,r$。\n\n第二行 $n$ 个整数，表示数列 $a$。", "outputFormat": "一行，一个整数，表示最小代价。", "hint": "**样例 $1$ 解释**\n\n花费 $p=1$ 的代价将 $a_3$ 增加一，得到数列 $b=[2,-2,3,-2,-1,2,-2,3,-2,-1,\\cdots]$ 是美妙的，取 $k_0=2$ 符合要求。\n\n可以证明不存在代价更小的方案。\n\n---\n\n**样例 $2$ 解释**\n\n花费 $q=1$ 的代价将 $a_1$ 删除，得到数列 $b=[2,3,-3,-1,2,3,-3,-1,\\cdots]$ 是美妙的，取 $k_0=0$ 符合要求。\n\n可以证明不存在代价更小的方案。\n\n---\n\n**数据范围**\n\n**本题采用捆绑测试。只有通过子任务中所有测试点以及所有依赖的子任务，才能获得相应的分数。**\n\n对于全部数据：$1\\le n\\le 10^5$，$1\\le p,q,r\\le 10^9$，$|a_i|\\le 10^9$。\n\n- 子任务一（$10$ 分）：$n=1$。\n- 子任务二（$10$ 分）：$n\\le 10$。依赖子任务一。\n- 子任务三（$20$ 分）：$|a_i|\\le 1$。\n- 子任务四（$20$ 分）：$\\sum|a_i|\\le 10^5$。依赖子任务三。\n- 子任务五（$40$ 分）：无特殊限制。依赖子任务一、二、三、四。", "locale": "zh-CN"}}}
{"pid": "P10413", "type": "P", "difficulty": 3, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["数学", "2023", "提交答案", "Catalan 数", "蓝桥杯国赛"], "title": "[蓝桥杯 2023 国 A] 圆上的连线", "background": "", "description": "给定一个圆，圆上有 $n=2023$ 个点从 $1$ 到 $n$ 依次编号。\n\n问有多少种不同的连线方式，使得完全没有连线相交。当两个方案连线的数量不同或任何一个点连接的点在另一个方案中编号不同时，两个方案视为不同。\n\n答案可能很大，请将答案对 $2023$ 求余后提交。", "inputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。\n", "outputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。\n", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2023 国 A] 圆上的连线", "background": "", "description": "给定一个圆，圆上有 $n=2023$ 个点从 $1$ 到 $n$ 依次编号。\n\n问有多少种不同的连线方式，使得完全没有连线相交。当两个方案连线的数量不同或任何一个点连接的点在另一个方案中编号不同时，两个方案视为不同。\n\n答案可能很大，请将答案对 $2023$ 求余后提交。", "inputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。\n", "outputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10414", "type": "P", "difficulty": 4, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["2023", "蓝桥杯国赛", "欧拉降幂"], "title": "[蓝桥杯 2023 国 A] 2023 次方", "background": null, "description": "求 $2^{(3^{(4^{(\\ldots ^{2023})})})}$ 的值对 $2023$ 取模的结果。\n\n注: 上式都是指数，可写为 $2** (3**(4**(\\ldots 2023\\ldots))$ 其中 $**$ 表示指数。\n\n这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "inputFormat": null, "outputFormat": null, "hint": null, "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2023 国 A] 2023 次方", "background": null, "description": "求 $2^{(3^{(4^{(\\ldots ^{2023})})})}$ 的值对 $2023$ 取模的结果。\n\n注: 上式都是指数，可写为 $2** (3**(4**(\\ldots 2023\\ldots))$ 其中 $**$ 表示指数。\n\n这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "inputFormat": null, "outputFormat": null, "hint": null, "locale": "zh-CN"}}}
{"pid": "P10415", "type": "P", "difficulty": 2, "samples": [["10 20", "50"], ["6 9", "6"], ["8 13", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2023", "数论", "蓝桥杯国赛"], "title": "[蓝桥杯 2023 国 A] 切割", "background": "数据提供：<https://www.luogu.com.cn/discuss/838792>", "description": "给定一个 $W\\times H$ 的长方形，两边长度均为整数。小蓝想把它切割为很多个边长为整数的小正方形。假设切割没有任何损耗，正方形的边长至少为 $2$，不允许出现余料，要求所有正方形的大小相等，请问最多能切割出多少个?", "inputFormat": "输入一行，包含两个整数 $W, H$，用一个空格分隔。", "outputFormat": "输出一行包含一个整数表示答案。如果不存在满足要求的方案，输出 $0$。", "hint": "**【样例解释 1】**\n\n切割成 $5\\times 10=50$ 个边长为 $2$ 的正方形。\n\n**【评测用例规模与约定】**\n\n对于 $30\\%$ 的评测用例，$1\\le W,H\\le 1000$；  \n对于 $60\\%$ 的评测用例，$1\\le W,H\\le 10^6$；  \n对于所有评测用例，$1\\le W,H\\le 10^9$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2023 国 A] 切割", "background": "数据提供：<https://www.luogu.com.cn/discuss/838792>", "description": "给定一个 $W\\times H$ 的长方形，两边长度均为整数。小蓝想把它切割为很多个边长为整数的小正方形。假设切割没有任何损耗，正方形的边长至少为 $2$，不允许出现余料，要求所有正方形的大小相等，请问最多能切割出多少个?", "inputFormat": "输入一行，包含两个整数 $W, H$，用一个空格分隔。", "outputFormat": "输出一行包含一个整数表示答案。如果不存在满足要求的方案，输出 $0$。", "hint": "**【样例解释 1】**\n\n切割成 $5\\times 10=50$ 个边长为 $2$ 的正方形。\n\n**【评测用例规模与约定】**\n\n对于 $30\\%$ 的评测用例，$1\\le W,H\\le 1000$；  \n对于 $60\\%$ 的评测用例，$1\\le W,H\\le 10^6$；  \n对于所有评测用例，$1\\le W,H\\le 10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P10416", "type": "P", "difficulty": 3, "samples": [["2\n1 3\n1 4", "3\n6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "2023", "蓝桥杯国赛"], "title": "[蓝桥杯 2023 国 A] XYZ", "background": "", "description": "给定一个区间 $[L,R]$，请求出有多少组 $X,Y,Z$ 满足 $X+Y=Z$ 且 $L\\le X,Y,Z\\le R$。", "inputFormat": "本题包含多组询问。\n\n输入的第一行包含一个整数 $T$ 表示询问组数。\n\n接下来 $T$ 行，每行包含两个整数 $L_i,R_i$，用一个空格分隔，表示一组询问。", "outputFormat": "输出 $T$ 行，每行包含一个整数，表示满足条件的 $X,Y,Z$ 的组数。", "hint": "**【样例解释 1】**\n\n$1+1=2$  \n$1+2=3$  \n$2+1=3$  \n$1+3=4$  \n$2+2=4$  \n$3+1=4$\n\n**【评测用例规模与约定】**\n\n对于 $30\\%$ 的评测用例，$T\\le 1000$，$L_i,R_i\\le 100$。  \n对于所有评测用例，$1\\le T\\le 100000$，$1\\le L_i\\le R_i\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2023 国 A] XYZ", "background": "", "description": "给定一个区间 $[L,R]$，请求出有多少组 $X,Y,Z$ 满足 $X+Y=Z$ 且 $L\\le X,Y,Z\\le R$。", "inputFormat": "本题包含多组询问。\n\n输入的第一行包含一个整数 $T$ 表示询问组数。\n\n接下来 $T$ 行，每行包含两个整数 $L_i,R_i$，用一个空格分隔，表示一组询问。", "outputFormat": "输出 $T$ 行，每行包含一个整数，表示满足条件的 $X,Y,Z$ 的组数。", "hint": "**【样例解释 1】**\n\n$1+1=2$  \n$1+2=3$  \n$2+1=3$  \n$1+3=4$  \n$2+2=4$  \n$3+1=4$\n\n**【评测用例规模与约定】**\n\n对于 $30\\%$ 的评测用例，$T\\le 1000$，$L_i,R_i\\le 100$。  \n对于所有评测用例，$1\\le T\\le 100000$，$1\\le L_i\\le R_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10417", "type": "P", "difficulty": 3, "samples": [["3 4 5\n1 3 4\n2 3 5 6\n", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["二分", "2023", "蓝桥杯国赛"], "title": "[蓝桥杯 2023 国 A] 第 K 小的和", "background": "", "description": "给定两个序列 $A,B$，长度分别为 $n,m$。\n\n设另有一个序列 $C$ 中包含了 $A,B$ 中的数两两相加的结果 ($C$ 中共有 $n\\times m$ 个数)。问 $C$ 中第 $K$ 小的数是多少。请注意重复的数需要计算多次。例如 $1,1,2,3$ 中，最小和次小都是 $1$，而 $3$ 是第 $4$ 小。", "inputFormat": "输入的第一行包含三个整数 $n,m,K$，相邻两个整数之间使用一个空格分隔。\n\n第二行包含 $n$ 个整数，分别表示 $A_1,A_2,\\ldots,A_n$，相邻两个整数之间使用一个空格分隔。\n\n第三行包含 $m$ 个整数，分别表示 $B_1,B_2,\\ldots,B_m$，相邻两个整数之间使用一个空格分隔。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "**【评测用例规模与约定】**\n\n\n- 对于 $40\\%$ 的评测用例，$n,m\\le 5000$，$A_i,B_i\\le 1000$;\n- 对于所有评测用例，$1\\le n,m\\le 10^5$，$1\\le A_i,B_i\\le 10^9$，$1\\le K\\le n\\times m$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2023 国 A] 第 K 小的和", "background": "", "description": "给定两个序列 $A,B$，长度分别为 $n,m$。\n\n设另有一个序列 $C$ 中包含了 $A,B$ 中的数两两相加的结果 ($C$ 中共有 $n\\times m$ 个数)。问 $C$ 中第 $K$ 小的数是多少。请注意重复的数需要计算多次。例如 $1,1,2,3$ 中，最小和次小都是 $1$，而 $3$ 是第 $4$ 小。", "inputFormat": "输入的第一行包含三个整数 $n,m,K$，相邻两个整数之间使用一个空格分隔。\n\n第二行包含 $n$ 个整数，分别表示 $A_1,A_2,\\ldots,A_n$，相邻两个整数之间使用一个空格分隔。\n\n第三行包含 $m$ 个整数，分别表示 $B_1,B_2,\\ldots,B_m$，相邻两个整数之间使用一个空格分隔。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "**【评测用例规模与约定】**\n\n\n- 对于 $40\\%$ 的评测用例，$n,m\\le 5000$，$A_i,B_i\\le 1000$;\n- 对于所有评测用例，$1\\le n,m\\le 10^5$，$1\\le A_i,B_i\\le 10^9$，$1\\le K\\le n\\times m$。\n", "locale": "zh-CN"}}}
{"pid": "P10418", "type": "P", "difficulty": 4, "samples": [["5\n1 1\n2 1\n3 7\n1 10\n", "12\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "树的遍历", "蓝桥杯国赛"], "title": "[蓝桥杯 2023 国 A] 相连的边", "background": "", "description": "给定一棵包含 $n$ 个结点的树，找出 $3$ 条边使得这三条边的端点仅经过这三条边即可互相到达且三条边的长度和尽可能大。", "inputFormat": "输入第一行包含一个整数 $n$ 表示树的结点数。\n\n接下来 $n−1$ 行，每行包含两个整数，用一个空格分隔。其中第 $i$ 行的两个数 $x_i,y_i$，表示编号为 $i+1$ 和 $x_i$ 的结点之间有一条长度为 $y_i$ 的边。", "outputFormat": "输出一行，包含一个整数表示满足要求的三条边的长度之和的最大值。", "hint": "**【样例解释 1】**\n\n结点 $2$ 和结点 $1$ 的边长为 $1$，结点 $3$ 和结点 $2$ 的边长为 $1$，结点 $4$ 和结点 $3$ 的边长为 $7$，结点 $5$ 和结点 $1$ 的边长为 $10$。\n\n**【评测用例规模与约定】**\n\n对于 $20\\%$ 的评测用例，$4\\le n\\le 300$；  \n对于 $40\\%$ 的评测用例，$4\\le n\\le 5000$；  \n对于所有评测用例，$4\\le n\\le 2\\times 10^5$，$1\\le x_i<i$，$1\\le y_i\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2023 国 A] 相连的边", "background": "", "description": "给定一棵包含 $n$ 个结点的树，找出 $3$ 条边使得这三条边的端点仅经过这三条边即可互相到达且三条边的长度和尽可能大。", "inputFormat": "输入第一行包含一个整数 $n$ 表示树的结点数。\n\n接下来 $n−1$ 行，每行包含两个整数，用一个空格分隔。其中第 $i$ 行的两个数 $x_i,y_i$，表示编号为 $i+1$ 和 $x_i$ 的结点之间有一条长度为 $y_i$ 的边。", "outputFormat": "输出一行，包含一个整数表示满足要求的三条边的长度之和的最大值。", "hint": "**【样例解释 1】**\n\n结点 $2$ 和结点 $1$ 的边长为 $1$，结点 $3$ 和结点 $2$ 的边长为 $1$，结点 $4$ 和结点 $3$ 的边长为 $7$，结点 $5$ 和结点 $1$ 的边长为 $10$。\n\n**【评测用例规模与约定】**\n\n对于 $20\\%$ 的评测用例，$4\\le n\\le 300$；  \n对于 $40\\%$ 的评测用例，$4\\le n\\le 5000$；  \n对于所有评测用例，$4\\le n\\le 2\\times 10^5$，$1\\le x_i<i$，$1\\le y_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10419", "type": "P", "difficulty": 4, "samples": [["6\n_0____\n____01\n__1__1\n__1_0_\n______\n__1___\n", "100110\n010101\n001011\n101100\n110010\n011001\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2023", "深度优先搜索 DFS", "剪枝", "蓝桥杯国赛"], "title": "[蓝桥杯 2023 国 A] 01 游戏", "background": "", "description": "小蓝最近玩上了 $01$ 游戏，这是一款带有二进制思想的棋子游戏，具体来说游戏在一个大小为 $N\\times N$ 的棋盘上进行，棋盘上每个位置都需要放置一位数字 $0$ 或者数字 $1$，初始情况下，棋盘上有一部分位置已经被放置好了固定的数字，玩家不可以再进行更改。玩家需要在其他所有的空白位置放置数字，并使得最终结果满足以下条件：\n\n1. 所有的空白位置都需要放置一个数字 $0/1$；\n2. 在水平或者垂直方向上，相同的数字不可以连续出现大于两次；\n3. 每一行和每一列上，数字 $0$ 和数字 $1$ 的数量必须是相等的 (例如 $N=4$，则表示每一行/列中都需要有 $2$ 个 $0$ 和 $2$ 个 $1$)；\n4. 每一行都是唯一的，因此每一行都不会和另一行完全相同；同理每一列也都是唯一的，每一列都不会和另一列完全相同。\n\n现在请你和小蓝一起解决 $01$ 游戏吧！题目保证所有的测试数据都拥有一个唯一的答案。", "inputFormat": "输入的第一行包含一个整数 $N$ 表示棋盘大小。\n\n接下来 $N$ 行每行包含 $N$ 个字符，字符只可能是 `0`、`1`、`_` 中的其中一个 (ASCII 码分别为 $48$，$49$，$95$)，`0` 表示这个位置数字固定为 $0$，`1` 表示这个位置数字固定为 $1$，`_` 表示这是一个空白位置，由玩家填充。", "outputFormat": "输出 $N$ 行每行包含 $N$ 个字符表示题目的解，其中的字符只能是 `0` 或者 `1`。", "hint": "**【评测用例规模与约定】**\n\n对于 $60\\%$ 的评测用例，$2\\le N\\le 6$;  \n对于所有评测用例，$2\\le N\\le 10$，$N$ 为偶数。\n\n感谢 @rui_er 提供测试数据。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2023 国 A] 01 游戏", "background": "", "description": "小蓝最近玩上了 $01$ 游戏，这是一款带有二进制思想的棋子游戏，具体来说游戏在一个大小为 $N\\times N$ 的棋盘上进行，棋盘上每个位置都需要放置一位数字 $0$ 或者数字 $1$，初始情况下，棋盘上有一部分位置已经被放置好了固定的数字，玩家不可以再进行更改。玩家需要在其他所有的空白位置放置数字，并使得最终结果满足以下条件：\n\n1. 所有的空白位置都需要放置一个数字 $0/1$；\n2. 在水平或者垂直方向上，相同的数字不可以连续出现大于两次；\n3. 每一行和每一列上，数字 $0$ 和数字 $1$ 的数量必须是相等的 (例如 $N=4$，则表示每一行/列中都需要有 $2$ 个 $0$ 和 $2$ 个 $1$)；\n4. 每一行都是唯一的，因此每一行都不会和另一行完全相同；同理每一列也都是唯一的，每一列都不会和另一列完全相同。\n\n现在请你和小蓝一起解决 $01$ 游戏吧！题目保证所有的测试数据都拥有一个唯一的答案。", "inputFormat": "输入的第一行包含一个整数 $N$ 表示棋盘大小。\n\n接下来 $N$ 行每行包含 $N$ 个字符，字符只可能是 `0`、`1`、`_` 中的其中一个 (ASCII 码分别为 $48$，$49$，$95$)，`0` 表示这个位置数字固定为 $0$，`1` 表示这个位置数字固定为 $1$，`_` 表示这是一个空白位置，由玩家填充。", "outputFormat": "输出 $N$ 行每行包含 $N$ 个字符表示题目的解，其中的字符只能是 `0` 或者 `1`。", "hint": "**【评测用例规模与约定】**\n\n对于 $60\\%$ 的评测用例，$2\\le N\\le 6$;  \n对于所有评测用例，$2\\le N\\le 10$，$N$ 为偶数。\n\n感谢 @rui_er 提供测试数据。", "locale": "zh-CN"}}}
{"pid": "P10420", "type": "P", "difficulty": 6, "samples": [["abb\n", "4\n1\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "后缀自动机 SAM", "蓝桥杯国赛"], "title": "[蓝桥杯 2023 国 A] 子串", "background": "", "description": "给定一个仅含小写英文字母组成的字符串 $S$，问有多少个不同的字符串在 $S$ 中出现 $1\\sim |S|$ 次。当两个字符串的长度或任意位置的字符不同时，我们认为这两个字符串是不同的。", "inputFormat": "输入一行包含一个字符串 $S$，由小写英文字母组成。", "outputFormat": "输出 $|S|$ 行，每行包含一个整数，其中第 $i$ 行的整数表示在 $|S|$ 中正好出现 $i$ 次的字符串的数量。", "hint": "**【样例解释 1】**\n\n`a`，`ab`，`bb`，`abb` 出现了一次，`b` 出现了两次。\n\n**【评测用例规模与约定】**\n\n对于 $20\\%$ 的评测用例，$|S|\\le 300$；  \n对于 $40\\%$ 的评测用例，$|S|\\le 5000$；  \n对于所有评测用例，$1\\le |S|\\le 10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2023 国 A] 子串", "background": "", "description": "给定一个仅含小写英文字母组成的字符串 $S$，问有多少个不同的字符串在 $S$ 中出现 $1\\sim |S|$ 次。当两个字符串的长度或任意位置的字符不同时，我们认为这两个字符串是不同的。", "inputFormat": "输入一行包含一个字符串 $S$，由小写英文字母组成。", "outputFormat": "输出 $|S|$ 行，每行包含一个整数，其中第 $i$ 行的整数表示在 $|S|$ 中正好出现 $i$ 次的字符串的数量。", "hint": "**【样例解释 1】**\n\n`a`，`ab`，`bb`，`abb` 出现了一次，`b` 出现了两次。\n\n**【评测用例规模与约定】**\n\n对于 $20\\%$ 的评测用例，$|S|\\le 300$；  \n对于 $40\\%$ 的评测用例，$|S|\\le 5000$；  \n对于所有评测用例，$1\\le |S|\\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P10421", "type": "P", "difficulty": 5, "samples": [["4 2 3\n1\n1\n3\n", "7"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "点分治", "树状数组", "2023", "分治", "容斥原理", "蓝桥杯国赛"], "title": "[蓝桥杯 2023 国 A] 树上的路径", "background": "", "description": "给定一棵包含 $n$ 个结点的树，树的每条边的长度均为 $1$。求这棵树的所有长度在 $L\\sim R$ 之间的路径的长度之和。两条路径经过的边集完全相同时视作同一条路径。\n\n也就是求 $\\sum\\limits_{i=1}^n{\\sum\\limits_{j=i+1}^{n}{dis(i,j)\\cdot[L \\le dis(i,j) \\le R]}}$，其中 $dis(i,j)$ 表示结点 $i$ 和结点 $j$ 之间的距离，$[C]$ 表示条件 $C$ 满足时取 $1$，不满足时取 $0$。", "inputFormat": "输入的第一行包含三个整数 $n, L, R$，相邻两个整数之间使用一个空格分隔。\n\n接下来 $n−1$ 行，每行包含一个整数，其中第 $i$ 行的整数 $F_i$ 表示第 $i+1$ 个结点在树上的父亲结点。结点 $1$ 是根结点，没有父亲结点。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "**【评测用例规模与约定】**\n\n对于 $40\\%$ 的评测用例，$n\\le 2000$；  \n对于所有评测用例，$1\\le L\\le R\\le n\\le 10^6$，$1\\le F_i\\le i$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2023 国 A] 树上的路径", "background": "", "description": "给定一棵包含 $n$ 个结点的树，树的每条边的长度均为 $1$。求这棵树的所有长度在 $L\\sim R$ 之间的路径的长度之和。两条路径经过的边集完全相同时视作同一条路径。\n\n也就是求 $\\sum\\limits_{i=1}^n{\\sum\\limits_{j=i+1}^{n}{dis(i,j)\\cdot[L \\le dis(i,j) \\le R]}}$，其中 $dis(i,j)$ 表示结点 $i$ 和结点 $j$ 之间的距离，$[C]$ 表示条件 $C$ 满足时取 $1$，不满足时取 $0$。", "inputFormat": "输入的第一行包含三个整数 $n, L, R$，相邻两个整数之间使用一个空格分隔。\n\n接下来 $n−1$ 行，每行包含一个整数，其中第 $i$ 行的整数 $F_i$ 表示第 $i+1$ 个结点在树上的父亲结点。结点 $1$ 是根结点，没有父亲结点。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "**【评测用例规模与约定】**\n\n对于 $40\\%$ 的评测用例，$n\\le 2000$；  \n对于所有评测用例，$1\\le L\\le R\\le n\\le 10^6$，$1\\le F_i\\le i$。", "locale": "zh-CN"}}}
{"pid": "P10422", "type": "P", "difficulty": 5, "samples": [["3 2 10\n2 10 5\n0 1 1\n1 2 2\n", "5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "最短路", "蓝桥杯国赛", "状压 DP"], "title": "[蓝桥杯 2023 国 A] 迷宫探险", "background": null, "description": "勇士小蓝准备去遥远的 LQ 迷宫探险，拿到迷宫中的宝藏。迷宫可以看做是一个具有 $N$ 个顶点(顶点编号为 $0\\sim N-1$) 和 $M$ 条边的无向图，其中每个顶点上都有一只怪物，每只怪物都具有一定的攻击力，每条边都具有一个权重 $w$ 表示小蓝经过边时消耗的时间。\n\n想要拿到迷宫宝藏，小蓝需要从 $0$ 号顶点出发对地图进行探险，在经过顶点时可以对怪物进行击杀，小蓝具有必杀技，能保证一招就击败怪物，但在小蓝对某个怪物进行击杀时，与这个怪物所在结点相邻接的结点上仍存活着的怪物会对小蓝发起一次攻击(注意，不包括小蓝正在击杀的怪物)，小蓝会减少对应攻击力大小的血量。当小蓝击杀完所有怪物并且到达顶点 $N-1$，并且此时小蓝的血量大于 $0$，那么小蓝才可以获得迷宫宝藏。\n\n注意，小蓝的必杀技很快，因此在击杀怪物时可以视为不消耗时间；一个怪物只需要被击杀一次就会消失，只有在小蓝击杀怪物时，与其相邻接的结点上的怪物才会对小蓝发起一次攻击。\n\n如果小蓝可以获得迷宫宝藏，请你输出所需要的最小时间。否则输出 $-1$ 即可。", "inputFormat": "输入的第一行包含三个整数 $N, M, HP$，相邻的整数之间使用一个空格分隔，分别表示顶点数、无向边数以及小蓝初始时侯的血量。\n\n第二行包含 $N$ 个整数，相邻的整数之间使用一个空格分隔，其中第 $i(0\\le i\\le N-1)$ 个整数表示编号为 $i$ 的顶点上的怪物的攻击力大小;\n\n接下来 $M$ 行，每行包含三个整数 $u, v, w$ 表示在顶点 $u$ 和 $v$ 之间存在一条权重为 $w$ 的无向边。", "outputFormat": "输出一行包含一个整数表示答案，若小蓝无论如何也无法获得迷宫宝藏，则输出 $-1$。", "hint": "**【样例解释 1】**\n\n小蓝初始在 $0$ 号点，下一步移动到 $1$ 号点，耗费时间 $1$。\n\n击杀 $1$ 号点的怪物，将会受到 $0$、$2$ 号怪物的攻击，血量减少 $7$，剩余血量为 $3$。\n\n移动到 $0$ 号点，耗费时间 $1$，接着击杀 $0$ 号怪物，不会受到攻击。\n\n移动到 $1$ 号点，再继续移动到 $2$ 号点，耗费时间 $3$，此时击杀 $2$ 号怪物，不会受到攻击，击杀完毕后小蓝剩余 $3$ 血量，满足题目要求，总计耗费时间为 $5$。\n\n**【评测用例规模与约定】**\n\n对于 $40\\%$ 的评测用例，$1\\le N\\le 10$；  \n对于所有评测用例，$1\\le N\\le 15$，$1\\le M\\le N^2$，$1\\le HP\\le 100$，$1\\le \\text{怪物攻击力} \\le 10$，$1\\le w\\le 10$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2023 国 A] 迷宫探险", "background": null, "description": "勇士小蓝准备去遥远的 LQ 迷宫探险，拿到迷宫中的宝藏。迷宫可以看做是一个具有 $N$ 个顶点(顶点编号为 $0\\sim N-1$) 和 $M$ 条边的无向图，其中每个顶点上都有一只怪物，每只怪物都具有一定的攻击力，每条边都具有一个权重 $w$ 表示小蓝经过边时消耗的时间。\n\n想要拿到迷宫宝藏，小蓝需要从 $0$ 号顶点出发对地图进行探险，在经过顶点时可以对怪物进行击杀，小蓝具有必杀技，能保证一招就击败怪物，但在小蓝对某个怪物进行击杀时，与这个怪物所在结点相邻接的结点上仍存活着的怪物会对小蓝发起一次攻击(注意，不包括小蓝正在击杀的怪物)，小蓝会减少对应攻击力大小的血量。当小蓝击杀完所有怪物并且到达顶点 $N-1$，并且此时小蓝的血量大于 $0$，那么小蓝才可以获得迷宫宝藏。\n\n注意，小蓝的必杀技很快，因此在击杀怪物时可以视为不消耗时间；一个怪物只需要被击杀一次就会消失，只有在小蓝击杀怪物时，与其相邻接的结点上的怪物才会对小蓝发起一次攻击。\n\n如果小蓝可以获得迷宫宝藏，请你输出所需要的最小时间。否则输出 $-1$ 即可。", "inputFormat": "输入的第一行包含三个整数 $N, M, HP$，相邻的整数之间使用一个空格分隔，分别表示顶点数、无向边数以及小蓝初始时侯的血量。\n\n第二行包含 $N$ 个整数，相邻的整数之间使用一个空格分隔，其中第 $i(0\\le i\\le N-1)$ 个整数表示编号为 $i$ 的顶点上的怪物的攻击力大小;\n\n接下来 $M$ 行，每行包含三个整数 $u, v, w$ 表示在顶点 $u$ 和 $v$ 之间存在一条权重为 $w$ 的无向边。", "outputFormat": "输出一行包含一个整数表示答案，若小蓝无论如何也无法获得迷宫宝藏，则输出 $-1$。", "hint": "**【样例解释 1】**\n\n小蓝初始在 $0$ 号点，下一步移动到 $1$ 号点，耗费时间 $1$。\n\n击杀 $1$ 号点的怪物，将会受到 $0$、$2$ 号怪物的攻击，血量减少 $7$，剩余血量为 $3$。\n\n移动到 $0$ 号点，耗费时间 $1$，接着击杀 $0$ 号怪物，不会受到攻击。\n\n移动到 $1$ 号点，再继续移动到 $2$ 号点，耗费时间 $3$，此时击杀 $2$ 号怪物，不会受到攻击，击杀完毕后小蓝剩余 $3$ 血量，满足题目要求，总计耗费时间为 $5$。\n\n**【评测用例规模与约定】**\n\n对于 $40\\%$ 的评测用例，$1\\le N\\le 10$；  \n对于所有评测用例，$1\\le N\\le 15$，$1\\le M\\le N^2$，$1\\le HP\\le 100$，$1\\le \\text{怪物攻击力} \\le 10$，$1\\le w\\le 10$。", "locale": "zh-CN"}}}
{"pid": "P10423", "type": "P", "difficulty": 2, "samples": [], "limits": {"time": [1000, 1000], "memory": [524288, 524288]}, "tags": ["数学", "2024", "提交答案", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 B] 填空问题", "background": "", "description": "## 试题 A: 握手问题\n\n### 【问题描述】\n小蓝组织了一场算法交流会议，总共有 $50$ 人参加了本次会议。在会议上，大家进行了握手交流。按照惯例他们每个人都要与除自己以外的其他所有人进行一次握手（且仅有一次）。但有 $7$ 个人，这 $7$ 人彼此之间没有进行握手（但这 $7$ 人与除这 $7$ 人以外的所有人进行了握手）。请问这些人之间一共进行了多少次握手？\n\n注意 $A$ 和 $B$ 握手的同时也意味着 $B$ 和 $A$ 握手了，所以算作是一次握手。\n\n### 【答案提交】\n这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。\n\n## 试题 B: 小球反弹\n\n### 【问题描述】\n有一长方形，长为 $343720$ 单位长度，宽为 $233333$ 单位长度。在其内部左上角顶点有一小球（无视其体积），其初速度如图所示且保持运动速率不变，分解到长宽两个方向上的速率之比为 $dx : dy = 15 : 17$。小球碰到长方形的边框时会发生反弹，每次反弹的入射角与反射角相等，因此小球会改变方向且保持速\n率不变（如果小球刚好射向角落，则按入射方向原路返回）。从小球出发到其第一次回到左上角顶点这段时间里，小球运动的路程为多少单位长度？答案四舍五入保留两位小数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i4u1r2zv.png)\n\n### 【答案提交】\n这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个小数，在提交答案时只填写这个小数，填写多余的内容将无法得分。", "inputFormat": "输入一个大写字母，表示第几个问题。", "outputFormat": "根据所输入的问题编号，输出对应问题的答案。", "hint": "答题模板，可供参考。\n```cpp\n#include<iostream>\nusing namespace std;\nint main() {\n    string ans [] = {\n        \"The answer of task A\", // 双引号中替换为 A 题的答案\n        \"The answer of task B\", // 双引号中替换为 B 题的答案\n    };\n    char T;\n    cin >> T;\n    cout << ans[T - 'A'] << endl;\n    return 0;\n}\n```", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 B] 填空问题", "background": "", "description": "## 试题 A: 握手问题\n\n### 【问题描述】\n小蓝组织了一场算法交流会议，总共有 $50$ 人参加了本次会议。在会议上，大家进行了握手交流。按照惯例他们每个人都要与除自己以外的其他所有人进行一次握手（且仅有一次）。但有 $7$ 个人，这 $7$ 人彼此之间没有进行握手（但这 $7$ 人与除这 $7$ 人以外的所有人进行了握手）。请问这些人之间一共进行了多少次握手？\n\n注意 $A$ 和 $B$ 握手的同时也意味着 $B$ 和 $A$ 握手了，所以算作是一次握手。\n\n### 【答案提交】\n这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。\n\n## 试题 B: 小球反弹\n\n### 【问题描述】\n有一长方形，长为 $343720$ 单位长度，宽为 $233333$ 单位长度。在其内部左上角顶点有一小球（无视其体积），其初速度如图所示且保持运动速率不变，分解到长宽两个方向上的速率之比为 $dx : dy = 15 : 17$。小球碰到长方形的边框时会发生反弹，每次反弹的入射角与反射角相等，因此小球会改变方向且保持速\n率不变（如果小球刚好射向角落，则按入射方向原路返回）。从小球出发到其第一次回到左上角顶点这段时间里，小球运动的路程为多少单位长度？答案四舍五入保留两位小数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i4u1r2zv.png)\n\n### 【答案提交】\n这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个小数，在提交答案时只填写这个小数，填写多余的内容将无法得分。", "inputFormat": "输入一个大写字母，表示第几个问题。", "outputFormat": "根据所输入的问题编号，输出对应问题的答案。", "hint": "答题模板，可供参考。\n```cpp\n#include<iostream>\nusing namespace std;\nint main() {\n    string ans [] = {\n        \"The answer of task A\", // 双引号中替换为 A 题的答案\n        \"The answer of task B\", // 双引号中替换为 B 题的答案\n    };\n    char T;\n    cin >> T;\n    cout << ans[T - 'A'] << endl;\n    return 0;\n}\n```", "locale": "zh-CN"}}}
{"pid": "P10424", "type": "P", "difficulty": 2, "samples": [["24\n", "7"], ["2024\n", "150"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2024", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 B] 好数", "background": "", "description": "一个整数如果按从低位到高位的顺序，奇数位（个位、百位、万位……）上的数字是奇数，偶数位（十位、千位、十万位……）上的数字是偶数，我们就称之为“好数”。\n\n给定一个正整数 $N$，请计算从 $1$ 到 $N$ 一共有多少个好数。", "inputFormat": "一个整数 $N$。", "outputFormat": "一个整数代表答案。", "hint": "### 样例 1 解释\n\n$24$ 以内的好数有 $1,3,5,7,9,21,23$，一共 $7$ 个。\n\n### 数据规模与约定\n\n- 对于 $10\\%$ 的测试数据，$1 \\leq N \\le 100$。\n- 对于全部的测试数据，$1 \\le N \\leq 10^7$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 B] 好数", "background": "", "description": "一个整数如果按从低位到高位的顺序，奇数位（个位、百位、万位……）上的数字是奇数，偶数位（十位、千位、十万位……）上的数字是偶数，我们就称之为“好数”。\n\n给定一个正整数 $N$，请计算从 $1$ 到 $N$ 一共有多少个好数。", "inputFormat": "一个整数 $N$。", "outputFormat": "一个整数代表答案。", "hint": "### 样例 1 解释\n\n$24$ 以内的好数有 $1,3,5,7,9,21,23$，一共 $7$ 个。\n\n### 数据规模与约定\n\n- 对于 $10\\%$ 的测试数据，$1 \\leq N \\le 100$。\n- 对于全部的测试数据，$1 \\le N \\leq 10^7$。", "locale": "zh-CN"}}}
{"pid": "P10425", "type": "P", "difficulty": 3, "samples": [["2 3.14", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 B] R 格式", "background": "", "description": "小蓝最近在研究一种浮点数的表示方法：$R$ 格式。对于一个大于 $0$ 的浮点数 $d$，可以用 $R$ 格式的整数来表示。给定一个转换参数 $n$，将浮点数转换为 $R$ 格式整数的做法是：\n1. 将浮点数乘以 $2^n$。\n2. 四舍五入到最接近的整数。", "inputFormat": "一行一个整数 $n$ 和一个浮点数 $d$。", "outputFormat": "一行一个整数表示 $d$ 用 $R$ 格式表示出的值。", "hint": "### 样例 1 解释\n\n$3.14 \\times 2^2 = 12.56$，四舍五入后为 $13$。\n\n### 数据规模与约定\n\n用 $t$ 表示将 $d$ 视为字符串时的长度。\n\n- 对于 $50\\%$ 的数据，保证 $n \\le 10$，$t \\le 15$。\n- 对于全部的测试数据，保证 $1 \\le n \\le 1000$，$1 \\le t \\le 1024$，保证 $d$ 是小数，即包含小数点。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 B] R 格式", "background": "", "description": "小蓝最近在研究一种浮点数的表示方法：$R$ 格式。对于一个大于 $0$ 的浮点数 $d$，可以用 $R$ 格式的整数来表示。给定一个转换参数 $n$，将浮点数转换为 $R$ 格式整数的做法是：\n1. 将浮点数乘以 $2^n$。\n2. 四舍五入到最接近的整数。", "inputFormat": "一行一个整数 $n$ 和一个浮点数 $d$。", "outputFormat": "一行一个整数表示 $d$ 用 $R$ 格式表示出的值。", "hint": "### 样例 1 解释\n\n$3.14 \\times 2^2 = 12.56$，四舍五入后为 $13$。\n\n### 数据规模与约定\n\n用 $t$ 表示将 $d$ 视为字符串时的长度。\n\n- 对于 $50\\%$ 的数据，保证 $n \\le 10$，$t \\le 15$。\n- 对于全部的测试数据，保证 $1 \\le n \\le 1000$，$1 \\le t \\le 1024$，保证 $d$ 是小数，即包含小数点。", "locale": "zh-CN"}}}
{"pid": "P10426", "type": "P", "difficulty": 3, "samples": [["5\n1 2 3 4 9\n", "1 2 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 B] 宝石组合", "background": "", "description": "\n在一个神秘的森林里，住着一个小精灵名叫小蓝。有一天，他偶然发现了一个隐藏在树洞里的宝藏，里面装满了闪烁着美丽光芒的宝石。这些宝石都有着不同的颜色和形状，但最引人注目的是它们各自独特的 “闪亮度” 属性。每颗宝石都有一个与生俱来的特殊能力，可以发出不同强度的闪光。小蓝共找到了 $n$ 枚宝石，第 $i$ 枚宝石的 “闪亮度” 属性值为 $H_i$，小蓝将会从这 $n$ 枚宝石中选出三枚进行组合，组合之后的精美程度 $S$ 可以用以下公式来衡量：\n\n$$\nS = H_a H_b H_c \\cdot \\frac{\\operatorname{LCM}(H_a, H_b, H_c)}{\\operatorname{LCM}(H_a, H_b) \\cdot\\operatorname{LCM}(H_a, H_c) \\operatorname{LCM}(H_b, H_c)}\n$$\n\n其中 $\\operatorname{LCM}$ 表示的是最小公倍数函数。\n\n小蓝想要使得三枚宝石组合后的精美程度 $S$ 尽可能的高，请你帮他找出精美程度最高的方案。如果存在多个方案 $S$ 值相同，优先选择按照 $H$ 值升序排列后字典序最小的方案。\n", "inputFormat": "\n第一行一个整数 $n$ 表示宝石个数。  \n第二行有 $n$ 个整数 $H_1, H_2, \\dots H_n$ 表示每个宝石的闪亮度。\n", "outputFormat": "\n输出一行包含三个整数表示满足条件的三枚宝石的 “闪亮度”。", "hint": "### 数据规模与约定\n\n- 对 $30\\%$ 的数据，$n \\leq 100$，$H_i \\leq 10^3$。\n- 对 $60\\%$ 的数据，$n \\leq 2 \\times 10^3$。\n- 对全部的测试数据，保证 $3 \\leq n \\leq 10^5$，$1 \\leq H_i \\leq 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 B] 宝石组合", "background": "", "description": "\n在一个神秘的森林里，住着一个小精灵名叫小蓝。有一天，他偶然发现了一个隐藏在树洞里的宝藏，里面装满了闪烁着美丽光芒的宝石。这些宝石都有着不同的颜色和形状，但最引人注目的是它们各自独特的 “闪亮度” 属性。每颗宝石都有一个与生俱来的特殊能力，可以发出不同强度的闪光。小蓝共找到了 $n$ 枚宝石，第 $i$ 枚宝石的 “闪亮度” 属性值为 $H_i$，小蓝将会从这 $n$ 枚宝石中选出三枚进行组合，组合之后的精美程度 $S$ 可以用以下公式来衡量：\n\n$$\nS = H_a H_b H_c \\cdot \\frac{\\operatorname{LCM}(H_a, H_b, H_c)}{\\operatorname{LCM}(H_a, H_b) \\cdot\\operatorname{LCM}(H_a, H_c) \\operatorname{LCM}(H_b, H_c)}\n$$\n\n其中 $\\operatorname{LCM}$ 表示的是最小公倍数函数。\n\n小蓝想要使得三枚宝石组合后的精美程度 $S$ 尽可能的高，请你帮他找出精美程度最高的方案。如果存在多个方案 $S$ 值相同，优先选择按照 $H$ 值升序排列后字典序最小的方案。\n", "inputFormat": "\n第一行一个整数 $n$ 表示宝石个数。  \n第二行有 $n$ 个整数 $H_1, H_2, \\dots H_n$ 表示每个宝石的闪亮度。\n", "outputFormat": "\n输出一行包含三个整数表示满足条件的三枚宝石的 “闪亮度”。", "hint": "### 数据规模与约定\n\n- 对 $30\\%$ 的数据，$n \\leq 100$，$H_i \\leq 10^3$。\n- 对 $60\\%$ 的数据，$n \\leq 2 \\times 10^3$。\n- 对全部的测试数据，保证 $3 \\leq n \\leq 10^5$，$1 \\leq H_i \\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P10429", "type": "P", "difficulty": 4, "samples": [["5\n10 9 8 12 14\n", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "枚举", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 B] 拔河", "background": null, "description": "小明是学校里的一名老师，他带的班级共有 $n$ 名同学，第 $i$ 名同学力量值为 $a_i$。在闲暇之余，小明决定在班级里组织一场拔河比赛。\n\n为了保证比赛的双方实力尽可能相近，需要在这 $n$ 名同学中挑选出两个队伍，队伍内的同学编号连续 $\\{{a_{l_1}}, a_{l_1 + 1}, \\dots, a_{r_1 - 1}, a_{r_1}\\}$ 和 $\\{{a_{l_2}}, a_{l_2 + 1}, \\dots, a_{r_2 - 1}, a_{r_2}\\}$，其中 $l_1 \\le r_1<l_2 \\le r_2$。\n\n两个队伍的人数不必相同，但是需要让队伍内的同学们的力量值之和尽可能相近。请计算出力量值之和差距最小的挑选队伍的方式。", "inputFormat": "输入共两行。\n第一行为一个正整数 $n$。  \n第二行为 $n$ 个正整数 $a_1, a_2, \\dots ,a_n$。", "outputFormat": "输出共一行，一个非负整数，表示两个队伍力量值之和的最小差距。", "hint": "### 样例 1 解释\n\n其中一种最优选择方式：\n\n队伍 $1$：$\\{a_1, a_2, a_3\\}$，队伍 $2$：$\\{a_4, a_5\\}$，力量值和分别为 $10 + 9 + 8 = 27$，$12 + 14 = 26$，差距为 $|27 − 26| = 1$。\n\n### 数据规模与约定\n\n- 对 $20\\%$ 的数据，$n \\leq 50$。\n- 对全部的测试数据，保证 $1 \\leq n \\leq 10^3$，$1 \\leq a_i \\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 B] 拔河", "background": null, "description": "小明是学校里的一名老师，他带的班级共有 $n$ 名同学，第 $i$ 名同学力量值为 $a_i$。在闲暇之余，小明决定在班级里组织一场拔河比赛。\n\n为了保证比赛的双方实力尽可能相近，需要在这 $n$ 名同学中挑选出两个队伍，队伍内的同学编号连续 $\\{{a_{l_1}}, a_{l_1 + 1}, \\dots, a_{r_1 - 1}, a_{r_1}\\}$ 和 $\\{{a_{l_2}}, a_{l_2 + 1}, \\dots, a_{r_2 - 1}, a_{r_2}\\}$，其中 $l_1 \\le r_1<l_2 \\le r_2$。\n\n两个队伍的人数不必相同，但是需要让队伍内的同学们的力量值之和尽可能相近。请计算出力量值之和差距最小的挑选队伍的方式。", "inputFormat": "输入共两行。\n第一行为一个正整数 $n$。  \n第二行为 $n$ 个正整数 $a_1, a_2, \\dots ,a_n$。", "outputFormat": "输出共一行，一个非负整数，表示两个队伍力量值之和的最小差距。", "hint": "### 样例 1 解释\n\n其中一种最优选择方式：\n\n队伍 $1$：$\\{a_1, a_2, a_3\\}$，队伍 $2$：$\\{a_4, a_5\\}$，力量值和分别为 $10 + 9 + 8 = 27$，$12 + 14 = 26$，差距为 $|27 − 26| = 1$。\n\n### 数据规模与约定\n\n- 对 $20\\%$ 的数据，$n \\leq 50$。\n- 对全部的测试数据，保证 $1 \\leq n \\leq 10^3$，$1 \\leq a_i \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10430", "type": "P", "difficulty": 6, "samples": [["4 2\n3 1 2 1\n1\n1 3", "1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] 鱼 3 / Fish 3", "background": "", "description": "JOI 君在一个大水缸中饲养着 $ N $ 条鱼，每条鱼的编号从 $ 1 $ 到 $ N $。\n\nJOI 君有两种类型的鱼食，$ A $ 和 $ B $，两种都有足够的数量。当往水族箱中添加一块食物时，恰好有一条鱼吃掉它（任何鱼都可以吃掉它），并且根据食物的类型以及吃掉它的鱼的情况，鱼的智力变化如下：\n\n- 当第 $ k $ 条鱼（$ 1 \\leq k \\leq N $）吃掉一块 $ A $ 型食物时，第 $ k $ 条鱼的智力恰好增加 $ D $。\n- 当第 $ k $ 条鱼（$ 1 \\leq k \\leq N $）吃掉一块 $ B $ 型食物时，编号大于等于 $ k $ 的所有鱼的智力都恰好增加 $ 1 $。\n\n目前，所有鱼的智力都为 $ 0 $。JOI 君希望使第 $ i $ 条鱼（$ 1 \\leq i \\leq N $）的智力等于其理想智力 $ C_i $，但这并不总是可能的。\n\n因此，他考虑了 $ Q $ 个问题。第 $ j $ 个问题（$ 1 \\leq j \\leq Q $）如下：\n\n- 从所有鱼的智力都为 0 的状态开始，通过重复将食物放入水族箱零次或多次的动作，是否可能达到所有鱼 $ L_j , L_j + 1 ,..., R_j $ 都拥有其精确的理想智力值的状态？此外，如果可能，需要放入水族箱的 A 型食物的最小数量是多少？\n\n编写一个程序，给定有关 JOI 君的鱼的信息以及有关问题的信息，回答他的问题。\n", "inputFormat": "从标准输入读取以下数据：\n\n- $ N,D $\n- $ C_1,C_2,...,C_N $\n- $ Q $\n- $ L_1,R_1 $\n- $ L_2,R_2 $\n- ...\n- $ L_Q,R_Q $", "outputFormat": "输出共 $Q$ 行。在第 $j$ 行（$ 1 \\leq j \\leq Q $）中，如果可以达到所有鱼 $ L_j $，$ L_j + 1 $，...，$ R_j $ 拥有其精确的理想智力值的状态，则输出需要放入水族箱的 $A$ 型食物的最小数量。否则，输出 $-1$。", "hint": "#### 样例解释 1\n\n\n例如，在以下情况下，所有鱼 $1,2,3$ 最终都达到了其精确的理想智力值，且放入水族箱的 $A$ 型食物的数量为 $1$。\n\n- 起初，鱼 $1,2,3,4$ 的智力分别为 $0,0,0,0$。\n- 接下来，JOI 君将一块 $B$ 型食物放入水族箱，被鱼 $3$ 吃掉。结果，鱼 $1,2,3,4$ 的智力分别变为 $0,0,1,1$。\n- 然后，JOI 君将一块 $A$ 型食物放入水族箱，被鱼 $1$ 吃掉。结果，鱼 $1,2,3,4$ 的智力分别变为 $2,0,1,1$。\n- 最后，JOI 君将一块 $B$ 型食物放入水族箱，被鱼 $1$ 吃掉。结果，鱼 $1,2,3,4$ 的智力分别变为 $3,1,2,2$。\n- 由于不放入任何 $A$ 型食物就无法达到所有鱼 $1,2,3$ 的精确理想智力值的状态，输出 $1$。\n\n这个样例满足子任务 $1$ 和 $5$ 的约束条件。\n\n### 约束条件\n\n- $ 1 \\leq N \\leq 300,000 $。\n- $ 1 \\leq Q \\leq 300,000 $。\n- $ 1 \\leq D \\leq 10^{12} $。\n- $ 0 \\leq C_i \\leq 10^{12} $（$ 1 \\leq i \\leq N $）。\n- $ 1 \\leq L_j \\leq R_j \\leq N $（$ 1 \\leq j \\leq Q $）。\n- 给定值均为整数。\n\n### 子任务\n\n- （9 分）$ N \\leq 3,000 $，$ Q \\leq 3,000 $。\n- （7 分）$ C_i \\leq 1 $（$ 1 \\leq i \\leq N $）。\n- （28 分）$ D = 1 $。\n- （20 分）$ C_i \\geq C_{i+1} $（$ 1 \\leq i \\leq N - 1 $）。\n- （36 分）无额外约束。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2024] 鱼 3 / Fish 3", "background": "", "description": "JOI 君在一个大水缸中饲养着 $ N $ 条鱼，每条鱼的编号从 $ 1 $ 到 $ N $。\n\nJOI 君有两种类型的鱼食，$ A $ 和 $ B $，两种都有足够的数量。当往水族箱中添加一块食物时，恰好有一条鱼吃掉它（任何鱼都可以吃掉它），并且根据食物的类型以及吃掉它的鱼的情况，鱼的智力变化如下：\n\n- 当第 $ k $ 条鱼（$ 1 \\leq k \\leq N $）吃掉一块 $ A $ 型食物时，第 $ k $ 条鱼的智力恰好增加 $ D $。\n- 当第 $ k $ 条鱼（$ 1 \\leq k \\leq N $）吃掉一块 $ B $ 型食物时，编号大于等于 $ k $ 的所有鱼的智力都恰好增加 $ 1 $。\n\n目前，所有鱼的智力都为 $ 0 $。JOI 君希望使第 $ i $ 条鱼（$ 1 \\leq i \\leq N $）的智力等于其理想智力 $ C_i $，但这并不总是可能的。\n\n因此，他考虑了 $ Q $ 个问题。第 $ j $ 个问题（$ 1 \\leq j \\leq Q $）如下：\n\n- 从所有鱼的智力都为 0 的状态开始，通过重复将食物放入水族箱零次或多次的动作，是否可能达到所有鱼 $ L_j , L_j + 1 ,..., R_j $ 都拥有其精确的理想智力值的状态？此外，如果可能，需要放入水族箱的 A 型食物的最小数量是多少？\n\n编写一个程序，给定有关 JOI 君的鱼的信息以及有关问题的信息，回答他的问题。\n", "inputFormat": "从标准输入读取以下数据：\n\n- $ N,D $\n- $ C_1,C_2,...,C_N $\n- $ Q $\n- $ L_1,R_1 $\n- $ L_2,R_2 $\n- ...\n- $ L_Q,R_Q $", "outputFormat": "输出共 $Q$ 行。在第 $j$ 行（$ 1 \\leq j \\leq Q $）中，如果可以达到所有鱼 $ L_j $，$ L_j + 1 $，...，$ R_j $ 拥有其精确的理想智力值的状态，则输出需要放入水族箱的 $A$ 型食物的最小数量。否则，输出 $-1$。", "hint": "#### 样例解释 1\n\n\n例如，在以下情况下，所有鱼 $1,2,3$ 最终都达到了其精确的理想智力值，且放入水族箱的 $A$ 型食物的数量为 $1$。\n\n- 起初，鱼 $1,2,3,4$ 的智力分别为 $0,0,0,0$。\n- 接下来，JOI 君将一块 $B$ 型食物放入水族箱，被鱼 $3$ 吃掉。结果，鱼 $1,2,3,4$ 的智力分别变为 $0,0,1,1$。\n- 然后，JOI 君将一块 $A$ 型食物放入水族箱，被鱼 $1$ 吃掉。结果，鱼 $1,2,3,4$ 的智力分别变为 $2,0,1,1$。\n- 最后，JOI 君将一块 $B$ 型食物放入水族箱，被鱼 $1$ 吃掉。结果，鱼 $1,2,3,4$ 的智力分别变为 $3,1,2,2$。\n- 由于不放入任何 $A$ 型食物就无法达到所有鱼 $1,2,3$ 的精确理想智力值的状态，输出 $1$。\n\n这个样例满足子任务 $1$ 和 $5$ 的约束条件。\n\n### 约束条件\n\n- $ 1 \\leq N \\leq 300,000 $。\n- $ 1 \\leq Q \\leq 300,000 $。\n- $ 1 \\leq D \\leq 10^{12} $。\n- $ 0 \\leq C_i \\leq 10^{12} $（$ 1 \\leq i \\leq N $）。\n- $ 1 \\leq L_j \\leq R_j \\leq N $（$ 1 \\leq j \\leq Q $）。\n- 给定值均为整数。\n\n### 子任务\n\n- （9 分）$ N \\leq 3,000 $，$ Q \\leq 3,000 $。\n- （7 分）$ C_i \\leq 1 $（$ 1 \\leq i \\leq N $）。\n- （28 分）$ D = 1 $。\n- （20 分）$ C_i \\geq C_{i+1} $（$ 1 \\leq i \\leq N - 1 $）。\n- （36 分）无额外约束。\n", "locale": "zh-CN"}}}
{"pid": "P10431", "type": "P", "difficulty": 7, "samples": [["8\nRGGBRBBG\n2\n3 1", ""]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "交互题", "Special Judge", "通信题", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] 三色灯 / Tricolor Lights", "background": "\n在本题中，你需要将两个文件合并成一个文件提交。**不要引入任何头文件**。", "description": "\n 在一场游戏中，擅长博弈的 Anna 和 Bruno 将与发牌人 Dealer D-taro 对战。游戏进行时，Anna 和 Bruno 被隔离在不同的房间内，只能通过 Dealer D-taro 进行交流。\n\n在这场游戏中，他们使用一行共 $N$ 盏灯。这些灯自左向右编号为 $1$ 到 $N$，每盏灯都可以被点亮为三种颜色之一：红、绿或蓝。\n\n在游戏开始时，Anna 将每盏灯点亮为红、绿或蓝中的一种。同时，Dealer D-taro 为每盏灯指定一种**禁用颜色**，用一个长度为 $N$ 的字符串 $S$ 表示。令 $S_i$ 表示 $S$ 的第 $i$ 个字符（$1 \\le i \\le N$）。若 $S_i$ 为 ‘R’，则第 $i$ 盏灯的禁用颜色为红；若为 ‘G’，则禁用颜色为绿；若为 ‘B’，则禁用颜色为蓝。Anna 不能把第 $i$ 盏灯点亮成其禁用颜色。例如，若 $S_i$ 为 ‘R’，则 Anna 不能把第 $i$ 盏灯点成红色。Dealer D-taro 会把每盏灯的禁用颜色信息告知 Anna，但不会告知 Bruno。\n\n在点亮完每盏灯后，Anna 选择一个整数 $l$，满足 $1 \\le l \\le \\min(N, 130)$，并告知 Dealer D-taro。随后 Dealer D-taro 会把灯的总数 $N$ 以及 Anna 选择的整数 $l$ 告知 Bruno。接下来，他们按如下方式进行 $Q$ 轮：\n\n1. Dealer D-taro 选择一个整数 $a_j$，介于 $1$ 与 $N - l + 1$ 之间，并把第 $a_j, a_j+1, \\ldots, a_j+l-1$ 盏灯被点亮的颜色序列展示给 Bruno。\n2. Bruno 根据所见的颜色序列，向 Dealer D-taro 回复一个整数。若该整数等于 $a_j$，则 Anna 和 Bruno 赢得本轮。\n\n然而，Dealer D-taro 可以根据 Anna 点亮灯的方式以及所选整数 $l$ 来改变对 $a_1, a_2, \\ldots, a_Q$ 的选择。\n\n你的任务是实现一个程序，使得 Anna 和 Bruno 能在所有 $Q$ 轮中获胜。\n\n### 实现细节\n\n你需要提交 $2$ 个文件。\n\n第一个文件为 `Anna.cpp`，用于实现 Anna 的策略。它应实现以下函数，并通过预处理指令 `#include` 包含 `Anna.h`。\n\n* `std::pair<std::string, int> anna(int N, std::string S)`  \n  该函数在开始时被调用一次。\n  * 参数 $N$ 为灯的数量。\n  * 参数 $S$ 为长度为 $N$ 的字符串，表示 Dealer D-taro 指定的禁用颜色。\n  * 返回值为一对：字符串 $t$ 表示 Anna 为每盏灯点亮的颜色，以及整数 $l$ 表示 Anna 选择的整数。令 $t_i$ 表示 $t$ 的第 $i$ 个字符（$1 \\le i \\le N$）。$t_i$ 表示 Anna 将第 $i$ 盏灯点亮为颜色 $t_i$。若 $t_i$ 为 ‘R’，则该灯被点为红；若为 ‘G’，则为绿；若为 ‘B’，则为蓝。\n  * 字符串 $t$ 的长度必须为 $N$，否则判定为 **Wrong Answer [1]**。\n  * 字符串 $t$ 的每个字符必须为 ‘R’、‘G’ 或 ‘B’，否则判定为 **Wrong Answer [2]**。\n  * 每个 $t_i$ 必须与 $S$ 中对应字符不同，否则判定为 **Wrong Answer [3]**。\n  * $l$ 必须满足 $1 \\le l \\le \\min(N, 130)$，否则判定为 **Wrong Answer [4]**。\n\n第二个文件为 `Bruno.cpp`，用于实现 Bruno 的策略。它应实现以下函数，并通过预处理指令 `#include` 包含 `Bruno.h`。\n\n* `void init(int N, int l)`  \n  该函数在开始时被调用一次。\n  * 参数 $N$ 为灯的数量。\n  * 参数 $l$ 为 Anna 选择的整数。\n* `int bruno(std::string u)`  \n  在调用 `init` 之后，该函数会被调用 $Q$ 次，对应游戏中每一轮的步骤 $1$ 和 $2$。\n  * 参数 $u$ 为长度为 $l$ 的字符串，由 ‘R’、‘G’、‘B’ 组成，表示第 $a_j, a_j+1, \\ldots, a_j+l-1$ 盏灯被点亮的颜色序列。\n  * 令 $u_k$ 表示 $u$ 的第 $k$ 个字符（$1 \\le k \\le l$）。若 $u_k$ 为 ‘R’，则第 $a_j+k-1$ 盏灯被点为红；若为 ‘G’，则为绿；若为 ‘B’，则为蓝。\n  * 返回值为 Bruno 回复的整数。\n  * 返回值必须等于 $a_j$，否则判定为 **Wrong Answer [5]**。\n\n### 重要注意事项\n\n* 你的程序可以实现其他供内部使用的函数，或使用全局变量。提交的文件将与评测器一同编译，合成为一个可执行文件。所有全局变量与内部函数都应声明在匿名命名空间中，以避免与其他文件冲突。实际评测时，Anna 进程与 Bruno 进程会分别运行，两个进程不能共享全局变量。\n* 你的程序不得使用标准输入与标准输出。你的程序不得通过任何方式与其他文件通信。但你可以向标准错误输出调试信息。\n\n### 编译与试运行\n\n你可以从竞赛网页下载包含样例评测器的归档文件，用于本地测试你的程序。\n\n样例评测器文件为 `grader.cpp`。为进行测试，请将 `grader.cpp`、`Anna.cpp`、`Bruno.cpp`、`Anna.h`、`Bruno.h` 置于同一目录，并运行如下命令进行编译。或者，你也可以运行归档文件中的 `compile.sh`。\n\n```cpp\ng++ -std=gnu++20 -O2 -o grader grader.cpp Anna.cpp Bruno.cpp\n```\n\n编译成功后，会生成名为 `grader` 的可执行文件。\n\n请注意，实际评测器不同于样例评测器。样例评测器以单进程方式运行，从标准输入读取输入数据，并向标准输出与标准错误输出写出结果。\n\n### 评分相关\n\n实际评测程序会根据 Anna 点灯的方式以及所选整数 $l$ 来决定 $a_1, a_2, \\ldots, a_Q$。但 Bruno 的回答并不会影响 $a_1, a_2, \\ldots, a_Q$ 的选择。\n", "inputFormat": "\n样例评测器从标准输入读取如下数据。\n\n> $N$\\\n> $S$\\\n> $Q$\\\n> $a_1$ $a_2$ $\\cdots$ $a_Q$\n\n**与实际评测不同的是**，样例评测器必须有固定答案。$a_j$（$1 \\le j \\le Q$）表示第 $j$ 轮中 Dealer D-taro 选择的整数。在你的程序中，对于 Anna 选择的整数 $l$，必须满足 $1 \\le a_j \\le N - l + 1$。\n", "outputFormat": "\n样例评测器会向标准输出与标准错误输出如下输出（引号仅为说明）：\n\n* 若答案正确，输出 “$\\texttt{Accepted: l}$”，其中 $l$ 为 Anna 选择的整数。\n* 若答案错误，则输出出错类型，例如 “Wrong Answer [1]”。\n\n如果你的程序同时满足多类 Wrong Answer 的条件，样例评测器只会报告其中一种。", "hint": "\n#### 约束条件\n\n* $1 \\le N \\le 500\\,000$。\n* $1 \\le Q \\le 10\\,000$。\n* $S$ 为长度为 $N$ 的字符串，仅由 ‘R’、‘G’、‘B’ 组成。\n* $N$ 与 $Q$ 为整数。\n\n#### 子任务\n\n1.（5 分）$N \\le 131$。  \n2.（5 分）$N \\le 250$。  \n3.（5 分）$N \\le 380$。  \n4.（15 分）$N \\le 7\\,000$。  \n5.（70 分）无额外限制。在该子任务中，得分规则如下：\n   * 令 $l^*$ 表示该子任务所有测试用例中 Anna 选择的 $l$ 的最大值。\n   * 若该子任务中任意一个测试用例被判定为 **Wrong Answer [1]** ～ **[5]**（见实现细节），或超时、超内存、发生运行时错误，则本子任务得分为 $0$ 分。\n   * 若该子任务所有测试用例均正确，则得分如下所示：\n\n   | the value of $l^*$ | score |\n   | :----------------- | :---- |\n   | $61 < l^* \\le 130$ | 10 points |\n   | $41 < l^* \\le 61$  | 20 points |\n   | $34 < l^* \\le 41$  | 25 + 3 x $(41 - l^*)$ points |\n   | $28 < l^* \\le 34$  | 46 + 4 x $(34 - l^*)$ points |\n   | $l^* \\le 28$       | 70 points |\n\n### 通信示例\n\n下面给出样例评测器的一个输入，以及相应的函数调用过程。\n\n#### 样例函数调用\n\n| Sample Input 1 | 调用                     | 返回值              |\n| - | :---------------------- | :---------------- |\n| $\\texttt{8}\\\\\\texttt{RGGBRBBG}\\\\\\texttt{2}\\\\\\texttt{3 1}$ | `anna(8, \"RGGBRBBG\")` | `(\"BBRGBGRR\", 5)` |\n| ^ | `init(8, 5)`            |                    |\n| ^ | `bruno(\"RGBGR\")`        | `3`                |\n| ^ | `bruno(\"BBRGB\")`        | `1`                |\n\n在该示例中，Anna 接收到灯的数量 $N = 8$ 与禁用颜色字符串 $S = \\text{\"RGGBRBBC\"}$。Anna 选择用字符串 $t = \\text{\"BBRGBGRR\"}$ 点亮每盏灯，并选择整数 $l = 5$，并将其告知 Dealer D-taro。随后，Dealer D-taro 将 $N = 8$ 与 $l = 5$ 告知 Bruno。\n\n在第一轮中，Dealer D-taro 选择 $a_1 = 3$。Bruno 收到表示第 $3,4,5,6,7$ 盏灯颜色的字符串 $u = \\text{\"RGBGR\"}$，并回复整数 $3$，与 $a_1$ 相同。输入样例 $1$ 满足所有子任务的全部约束。可从竞赛网站下载的文件 `sample-01-in.txt` 与输入样例 $1$ 相对应。\n", "locale": "zh-CN", "translations": {"en": {"title": "[JOIST 2024] Tricolor Lights", "background": "", "description": "\nAnna and Bruno, experts in gambling, are about to compete against Dealer D-taro in a game. During the game, Anna and Bruno are isolated in separate rooms and can only communicate through Dealer D-taro.\n\nIn this game, they use a row of $N$ lights. These lights are numbered from 1 to $N$ from left to right and can be illuminated in one of three colors: red, green, or blue.\n\nAt the beginning of the game, Anna illuminates each of these lights in either red, green, or blue. Additionally, Dealer D-taro specifies one **prohibited color** for each light, represented by a string $S$ of length $N$. Let $S_i$ denote the $i$-th character of $S$ ($1 \\le i \\le N$). If $S_i$ is 'R', the prohibited color for light $i$ is red; if $S_i$ is 'G', it's green; and if $S_i$ is 'B', it's blue. Anna cannot illuminate light $i$ in its prohibited color. For example, if $S_i$ is 'R', Anna cannot illuminate light $i$ in red. Dealer D-taro conveys the information of the prohibited color for each light to Anna but not to Bruno.\n\nAfter illuminating each light, Anna selects an integer $l$ satisfying $1 \\le l \\le \\min(N, 130)$ and informs Dealer D-taro. Dealer D-taro then informs Bruno of the total number of lights $N$ and the integer $l$ chosen by Anna. Subsequently, they proceed with $Q$ rounds as follows:\n\n1.  Dealer D-taro selects an integer $a_j$ between 1 and $N - l + 1$ and shows Bruno the sequence of colors illuminated for lights $a_j, a_j+1, \\ldots, a_j+l-1$.\n2.  Bruno responds with a single integer to Dealer D-taro based on the sequence of colors shown. If the integer matches $a_j$, Anna and Bruno win the round.\n\nHowever, Dealer D-taro may vary the selection of $a_1, a_2, \\ldots, a_Q$ based on the sequence of colors illuminated by Anna and the chosen integer $l$.\n\nYou are required to implement a program that allows Anna and Bruno to win all $Q$ rounds.\n\n### Implementation Details\n\nYou need to submit 2 files.\n\nThe first file is `Anna.cpp`. It should implement Anna's strategy. It should implement the following functions. The program should include `Anna.h` using the preprocessing directive `#include`.\n\n*   `std::pair<std::string, int> anna(int N, std::string S)`\n    This function is called once initially.\n    *   The parameter $N$ is the number of lights.\n    *   The parameter $S$ is a string of length $N$ representing the prohibited colors specified by Dealer D-taro.\n    *   The return value is a pair consisting of a string $t$ representing the colors Anna illuminates for each light and an integer $l$ chosen by Anna. Let $t_i$ denote the $i$-th character of $t$ ($1 \\le i \\le N$). $t_i$ signifies Anna illuminating the $i$-th lamp with color $t_i$. If $t_i$ is 'R', the prohibited color for light $i$ is red; if $t_i$ is 'G', it's green; and if $t_i$ is 'B', it's blue.\n    *   The length of string $t$ must be $N$. Otherwise, it will be judged as **Wrong Answer [1]**.\n    *   Each character in string $t$ must be 'R', 'G', or 'B'. Otherwise, it will be judged as **Wrong Answer [2]**.\n    *   Each character $t_i$ must be different from the corresponding character in $S$. Otherwise, it will be judged as **Wrong Answer [3]**.\n    *   $l$ must be between 1 and $\\min(N, 130)$. Otherwise, it will be judged as **Wrong Answer [4]**.\n\nThe second file is `Bruno.cpp`. It should implement Bruno's strategy. It should implement the following functions. The program should include `Bruno.h` using the preprocessing directive `#include`.\n\n*   `void init(int N, int l)`\n    This function is called once initially.\n    *   The parameter $N$ is the number of lights.\n    *   The parameter $l$ is the integer chosen by Anna.\n*   `int bruno(std::string u)`\n    This function is called $Q$ times after function `init` is called and corresponds to steps 1 and 2 of each round in the game.\n    *   The argument $u$ is a string of length $l$ consisting of 'R', 'G', 'B', representing the sequence of colors illuminated for lights $a_j, a_j+1, \\ldots, a_j+l-1$.\n    *   Let $u_k$ denote the $k$-th character of $u$ ($1 \\le k \\le l$). If $u_k$ is 'R', the color of $a_j+k-1$-th light that Anna illuminated is red; if $u_k$ is 'G', it's green; and if $u_k$ is 'B', it's blue.\n    *   The return value is the integer Bruno responds with.\n    *   The return value must match $a_j$. Otherwise, it will be judged as **Wrong Answer [5]**.\n\n### Important Notices\n\n*   Your program can implement other functions for internal use, or use global variables. Submitted files will be compiled with the grader, and become a single executable file. All global variables and internal functions should be declared in an unnamed namespace to avoid confliction with other files. When it is graded, it will be executed as two processes of Anna and Bruno. The process of Anna and the process of Bruno cannot share global variables.\n*   Your program must not use the standard input and the standard output. Your program must not communicate with other files by any methods. However, your program may output debugging information to the standard error.\n\n### Compilation and Test Run\n\nYou can download an archive file from the contest webpage which contains the sample grader to test your program.\n\nThe sample grader is the file `grader.cpp`. In order to test your program, put `grader.cpp`, `Anna.cpp`, `Bruno.cpp`, `Anna.h`, `Bruno.h` in the same directory, and run the following command to compile your programs. Instead, you may run `compile.sh` contained in the archive file.\n\n```cpp\ng++ -std=gnu++20 -O2 -o grader grader.cpp Anna.cpp Bruno.cpp\n```\n\nWhen the compilation succeeds, the executable file `grader` is generated.\n\nNote that the actual grader is different from the sample grader. The sample grader will be executed as a single process, which will read input data from the standard input and write the results to the standard output and the standard error output.\n\n\n### Grading Considerations\n\nThe actual grading program determines $a_1, a_2, \\ldots, a_Q$ based on the sequence of colors illuminated by Anna and the chosen integer $l$. But Bruno's response does not affect the selection of $a_1, a_2, \\ldots, a_Q$.\n", "inputFormat": "\nThe sample grader reads the following data from the standard input.\n\n\n> $N$\\\n> $S$\\\n> $Q$\\\n> $a_1$ $a_2$ $\\cdots$ $a_Q$\n\n**Unlike the actual grading program**, the sample grading program must have fixed answers. $a_j$ ($1 \\le j \\le Q$) represents the integer $a_j$ chosen by Dealer D-taro in the $j$-th round. In your program, $a_j$ must satisfy $1 \\le a_j \\le N - l + 1$ for the integer $l$ chosen by Anna.\n", "outputFormat": "\nThe sample grader outputs the following information to the standard output and the standard error output (quotes for clarity).\n\n*   For correct answers, “$\\texttt{Accepted: l}$” is output for the integer $l$ chosen by Anna.\n*   For wrong answers, the type of wrongness is output, such as “Wrong Answer [1]”.\n\nIf your program meets the conditions of several types of Wrong Answer, the sample grader reports only one of them.", "hint": "\n### Constraints\n\n*   $1 \\le N \\le 500\\,000$.\n*   $1 \\le Q \\le 10\\,000$.\n*   $S$ is a string of length $N$ consisting of 'R', 'G', or 'B'.\n*   $N$ and $Q$ are integers.\n\n### Subtasks\n\n1.  (5 points) $N \\le 131$.\n2.  (5 points) $N \\le 250$.\n3.  (5 points) $N \\le 380$.\n4.  (15 points) $N \\le 7\\,000$.\n5.  (70 points) No additional constraints. In this subtask, points are awarded as follows:\n    *   Let $l^*$ denote the maximum value of $l$ chosen by Anna in all test cases of this subtask.\n    *   If any test case in this subtask is judged as **Wrong Answer [1]** ~ **[5]** (see implementation details) or exceeds the time limit, memory limit, or encounters a runtime error, the subtask score is 0 points.\n    *   If all test cases in this subtask are correct, the subtask score is determined as follows:\n\n    | the value of $l^*$ | score |\n    | :----------------- | :---- |\n    | $61 < l^* \\le 130$ | 10 points |\n    | $41 < l^* \\le 61$  | 20 points |\n    | $34 < l^* \\le 41$  | 25 + 3 x $(41 - l^*)$ points |\n    | $28 < l^* \\le 34$  | 46 + 4 x $(34 - l^*)$ points |\n    | $l^* \\le 28$       | 70 points |\n\n### Sample Communication\n\nHere is a sample input for the sample grader and corresponding function calls.\n\n ### Sample Function Calls\n\n| Sample Input 1| Call                    | Return value      |\n|-| :---------------------- | :---------------- |\n| $\\texttt{8}\\\\\\texttt{RGGBRBBG}\\\\\\texttt{2}\\\\\\texttt{3 1}$ | `anna(8, \"RGGBRBBG\")`   | `(\"BBRGBGRR\", 5)` |\n| ^| `init(8, 5)`            |                   |\n|^| `bruno(\"RGBGR\")`        | `3`               |\n|^| `bruno(\"BBRGB\")`        | `1`               |\n\n\nIn this example, Anna receives the number of lights $N = 8$ and the string representing prohibited colors $S = \\text{\"RGGBRBBC\"}$. Anna chooses to illuminate each light with the string $t$ representing colors $\\text{\"BBRGBGRR\"}$ and selects the integer $l$ as 5, which she communicates to Dealer D-taro. Then, Dealer D-taro informs Bruno of the numbers $N = 8$ and $l = 5$.\n\nIn the first round, Dealer D-taro chooses $a_1 = 3$. Bruno receives the sequence of colors illuminated for lights 3, 4, 5, 6, and 7, represented by the string $u = \\text{\"RGBGR\"}$, and responds with the integer 3, which matches $a_1$. Input example 1 satisfies all constraints for all subtasks. The file `sample-01-in.txt` downloadable from the contest site corresponds to input example 1.\n\n", "locale": "en"}, "zh-CN": {"title": "[JOIST 2024] 三色灯 / Tricolor Lights", "background": "\n在本题中，你需要将两个文件合并成一个文件提交。**不要引入任何头文件**。", "description": "\n 在一场游戏中，擅长博弈的 Anna 和 Bruno 将与发牌人 Dealer D-taro 对战。游戏进行时，Anna 和 Bruno 被隔离在不同的房间内，只能通过 Dealer D-taro 进行交流。\n\n在这场游戏中，他们使用一行共 $N$ 盏灯。这些灯自左向右编号为 $1$ 到 $N$，每盏灯都可以被点亮为三种颜色之一：红、绿或蓝。\n\n在游戏开始时，Anna 将每盏灯点亮为红、绿或蓝中的一种。同时，Dealer D-taro 为每盏灯指定一种**禁用颜色**，用一个长度为 $N$ 的字符串 $S$ 表示。令 $S_i$ 表示 $S$ 的第 $i$ 个字符（$1 \\le i \\le N$）。若 $S_i$ 为 ‘R’，则第 $i$ 盏灯的禁用颜色为红；若为 ‘G’，则禁用颜色为绿；若为 ‘B’，则禁用颜色为蓝。Anna 不能把第 $i$ 盏灯点亮成其禁用颜色。例如，若 $S_i$ 为 ‘R’，则 Anna 不能把第 $i$ 盏灯点成红色。Dealer D-taro 会把每盏灯的禁用颜色信息告知 Anna，但不会告知 Bruno。\n\n在点亮完每盏灯后，Anna 选择一个整数 $l$，满足 $1 \\le l \\le \\min(N, 130)$，并告知 Dealer D-taro。随后 Dealer D-taro 会把灯的总数 $N$ 以及 Anna 选择的整数 $l$ 告知 Bruno。接下来，他们按如下方式进行 $Q$ 轮：\n\n1. Dealer D-taro 选择一个整数 $a_j$，介于 $1$ 与 $N - l + 1$ 之间，并把第 $a_j, a_j+1, \\ldots, a_j+l-1$ 盏灯被点亮的颜色序列展示给 Bruno。\n2. Bruno 根据所见的颜色序列，向 Dealer D-taro 回复一个整数。若该整数等于 $a_j$，则 Anna 和 Bruno 赢得本轮。\n\n然而，Dealer D-taro 可以根据 Anna 点亮灯的方式以及所选整数 $l$ 来改变对 $a_1, a_2, \\ldots, a_Q$ 的选择。\n\n你的任务是实现一个程序，使得 Anna 和 Bruno 能在所有 $Q$ 轮中获胜。\n\n### 实现细节\n\n你需要提交 $2$ 个文件。\n\n第一个文件为 `Anna.cpp`，用于实现 Anna 的策略。它应实现以下函数，并通过预处理指令 `#include` 包含 `Anna.h`。\n\n* `std::pair<std::string, int> anna(int N, std::string S)`  \n  该函数在开始时被调用一次。\n  * 参数 $N$ 为灯的数量。\n  * 参数 $S$ 为长度为 $N$ 的字符串，表示 Dealer D-taro 指定的禁用颜色。\n  * 返回值为一对：字符串 $t$ 表示 Anna 为每盏灯点亮的颜色，以及整数 $l$ 表示 Anna 选择的整数。令 $t_i$ 表示 $t$ 的第 $i$ 个字符（$1 \\le i \\le N$）。$t_i$ 表示 Anna 将第 $i$ 盏灯点亮为颜色 $t_i$。若 $t_i$ 为 ‘R’，则该灯被点为红；若为 ‘G’，则为绿；若为 ‘B’，则为蓝。\n  * 字符串 $t$ 的长度必须为 $N$，否则判定为 **Wrong Answer [1]**。\n  * 字符串 $t$ 的每个字符必须为 ‘R’、‘G’ 或 ‘B’，否则判定为 **Wrong Answer [2]**。\n  * 每个 $t_i$ 必须与 $S$ 中对应字符不同，否则判定为 **Wrong Answer [3]**。\n  * $l$ 必须满足 $1 \\le l \\le \\min(N, 130)$，否则判定为 **Wrong Answer [4]**。\n\n第二个文件为 `Bruno.cpp`，用于实现 Bruno 的策略。它应实现以下函数，并通过预处理指令 `#include` 包含 `Bruno.h`。\n\n* `void init(int N, int l)`  \n  该函数在开始时被调用一次。\n  * 参数 $N$ 为灯的数量。\n  * 参数 $l$ 为 Anna 选择的整数。\n* `int bruno(std::string u)`  \n  在调用 `init` 之后，该函数会被调用 $Q$ 次，对应游戏中每一轮的步骤 $1$ 和 $2$。\n  * 参数 $u$ 为长度为 $l$ 的字符串，由 ‘R’、‘G’、‘B’ 组成，表示第 $a_j, a_j+1, \\ldots, a_j+l-1$ 盏灯被点亮的颜色序列。\n  * 令 $u_k$ 表示 $u$ 的第 $k$ 个字符（$1 \\le k \\le l$）。若 $u_k$ 为 ‘R’，则第 $a_j+k-1$ 盏灯被点为红；若为 ‘G’，则为绿；若为 ‘B’，则为蓝。\n  * 返回值为 Bruno 回复的整数。\n  * 返回值必须等于 $a_j$，否则判定为 **Wrong Answer [5]**。\n\n### 重要注意事项\n\n* 你的程序可以实现其他供内部使用的函数，或使用全局变量。提交的文件将与评测器一同编译，合成为一个可执行文件。所有全局变量与内部函数都应声明在匿名命名空间中，以避免与其他文件冲突。实际评测时，Anna 进程与 Bruno 进程会分别运行，两个进程不能共享全局变量。\n* 你的程序不得使用标准输入与标准输出。你的程序不得通过任何方式与其他文件通信。但你可以向标准错误输出调试信息。\n\n### 编译与试运行\n\n你可以从竞赛网页下载包含样例评测器的归档文件，用于本地测试你的程序。\n\n样例评测器文件为 `grader.cpp`。为进行测试，请将 `grader.cpp`、`Anna.cpp`、`Bruno.cpp`、`Anna.h`、`Bruno.h` 置于同一目录，并运行如下命令进行编译。或者，你也可以运行归档文件中的 `compile.sh`。\n\n```cpp\ng++ -std=gnu++20 -O2 -o grader grader.cpp Anna.cpp Bruno.cpp\n```\n\n编译成功后，会生成名为 `grader` 的可执行文件。\n\n请注意，实际评测器不同于样例评测器。样例评测器以单进程方式运行，从标准输入读取输入数据，并向标准输出与标准错误输出写出结果。\n\n### 评分相关\n\n实际评测程序会根据 Anna 点灯的方式以及所选整数 $l$ 来决定 $a_1, a_2, \\ldots, a_Q$。但 Bruno 的回答并不会影响 $a_1, a_2, \\ldots, a_Q$ 的选择。\n", "inputFormat": "\n样例评测器从标准输入读取如下数据。\n\n> $N$\\\n> $S$\\\n> $Q$\\\n> $a_1$ $a_2$ $\\cdots$ $a_Q$\n\n**与实际评测不同的是**，样例评测器必须有固定答案。$a_j$（$1 \\le j \\le Q$）表示第 $j$ 轮中 Dealer D-taro 选择的整数。在你的程序中，对于 Anna 选择的整数 $l$，必须满足 $1 \\le a_j \\le N - l + 1$。\n", "outputFormat": "\n样例评测器会向标准输出与标准错误输出如下输出（引号仅为说明）：\n\n* 若答案正确，输出 “$\\texttt{Accepted: l}$”，其中 $l$ 为 Anna 选择的整数。\n* 若答案错误，则输出出错类型，例如 “Wrong Answer [1]”。\n\n如果你的程序同时满足多类 Wrong Answer 的条件，样例评测器只会报告其中一种。", "hint": "\n#### 约束条件\n\n* $1 \\le N \\le 500\\,000$。\n* $1 \\le Q \\le 10\\,000$。\n* $S$ 为长度为 $N$ 的字符串，仅由 ‘R’、‘G’、‘B’ 组成。\n* $N$ 与 $Q$ 为整数。\n\n#### 子任务\n\n1.（5 分）$N \\le 131$。  \n2.（5 分）$N \\le 250$。  \n3.（5 分）$N \\le 380$。  \n4.（15 分）$N \\le 7\\,000$。  \n5.（70 分）无额外限制。在该子任务中，得分规则如下：\n   * 令 $l^*$ 表示该子任务所有测试用例中 Anna 选择的 $l$ 的最大值。\n   * 若该子任务中任意一个测试用例被判定为 **Wrong Answer [1]** ～ **[5]**（见实现细节），或超时、超内存、发生运行时错误，则本子任务得分为 $0$ 分。\n   * 若该子任务所有测试用例均正确，则得分如下所示：\n\n   | the value of $l^*$ | score |\n   | :----------------- | :---- |\n   | $61 < l^* \\le 130$ | 10 points |\n   | $41 < l^* \\le 61$  | 20 points |\n   | $34 < l^* \\le 41$  | 25 + 3 x $(41 - l^*)$ points |\n   | $28 < l^* \\le 34$  | 46 + 4 x $(34 - l^*)$ points |\n   | $l^* \\le 28$       | 70 points |\n\n### 通信示例\n\n下面给出样例评测器的一个输入，以及相应的函数调用过程。\n\n#### 样例函数调用\n\n| Sample Input 1 | 调用                     | 返回值              |\n| - | :---------------------- | :---------------- |\n| $\\texttt{8}\\\\\\texttt{RGGBRBBG}\\\\\\texttt{2}\\\\\\texttt{3 1}$ | `anna(8, \"RGGBRBBG\")` | `(\"BBRGBGRR\", 5)` |\n| ^ | `init(8, 5)`            |                    |\n| ^ | `bruno(\"RGBGR\")`        | `3`                |\n| ^ | `bruno(\"BBRGB\")`        | `1`                |\n\n在该示例中，Anna 接收到灯的数量 $N = 8$ 与禁用颜色字符串 $S = \\text{\"RGGBRBBC\"}$。Anna 选择用字符串 $t = \\text{\"BBRGBGRR\"}$ 点亮每盏灯，并选择整数 $l = 5$，并将其告知 Dealer D-taro。随后，Dealer D-taro 将 $N = 8$ 与 $l = 5$ 告知 Bruno。\n\n在第一轮中，Dealer D-taro 选择 $a_1 = 3$。Bruno 收到表示第 $3,4,5,6,7$ 盏灯颜色的字符串 $u = \\text{\"RGBGR\"}$，并回复整数 $3$，与 $a_1$ 相同。输入样例 $1$ 满足所有子任务的全部约束。可从竞赛网站下载的文件 `sample-01-in.txt` 与输入样例 $1$ 相对应。\n", "locale": "zh-CN"}}}
{"pid": "P10432", "type": "P", "difficulty": 6, "samples": [["5 2\n0 6\n1 1\n0 5\n2 1\n1 2", "8"], ["5 100000\n0 6\n1 1\n0 5\n2 1\n1 2", "100010"], ["8 8\n0 36\n1 47\n2 95\n0 59\n1 54\n0 95\n1 87\n2 92", "108"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] 滑雪 2 / Ski 2", "background": "", "description": "JOI 先生管理着 IOI 高原上一家著名的滑雪度假村，他决定为滑雪度假村开业 15 周年庆祝活动而在相邻的 KOI 高原上建造一家新的滑雪度假村。\n\nKOI 高原有 $N$ 个点，编号从 $1$ 到 $N$。目前，第 $i$ 个点（$1 \\leq i \\leq N$）的海拔高度为 $H_i$ 米，并且高原上的每个点都没有连接起来的滑道。此外，每个点都配备了一个未使用的连接设施。\n\nJOI 先生的目标是在高原上的一个点上建造 KOI 酒店，然后建造一些滑道连接高原上的每个点，以便人们可以从任何一个点滑雪到酒店。具体来说，JOI 先生将按照以下步骤建造滑雪度假村：\n\n1. 进行以下筑堤工作任意次数（可能为零）：选择一个点 $i$，将点 $i$ 的海拔高度增加 1 米。此工作的成本为每次操作 $K$。\n\n2. 从 $N$ 个点中选择一个点，并在那里建造 KOI 酒店。\n\n3. 进行以下扩展工作任意次数（可能为零）：选择一个点 $i$，在点 $i$ 建造一个连接设施。此工作的成本为每次操作 $C_i$。\n\n4. 对于除了 KOI 酒店所在点之外的剩余 $N - 1$ 个点，执行以下构建：设 $i$ 为该点的编号。选择另一个海拔严格较低的点 $j$，并使用点 $j$ 的一个未使用的连接设施，从点 $i$ 向点 $j$ 构建单向滑道。注意，如果没有海拔严格较低且有未使用连接设施的点 $j$，则无法实现目标。\n\n滑雪度假村的建造成本是进行堤岸工作和扩展工作的成本之和。\n\n编写一个程序，给定 KOI 高原上每个点的信息和每次筑堤工作的成本 $K$，找到建造滑雪度假村的最小成本。\n", "inputFormat": "从标准输入中读取以下数据：\n\n- $N$ $K$\n- $H_1$ $C_1$\n- $H_2$ $C_2$\n- ...\n- $H_N$ $C_N$\n", "outputFormat": "\n输出一行，构建滑雪度假村的最小成本。", "hint": "#### 样例解释 1\n\n例如，可以按以下方式建造滑雪度假村：\n\n1. 在点 $1$ 进行两次筑堤工作，在点 $5$ 进行一次。这些筑堤工作的总成本为 $2 \\times (2 + 1) = 6$。每个点的海拔高度变为 $2, 1, 0, 2, 2$ 米。\n2. 在点 $3$ 建造 KOI 酒店。\n3. 在点 $2$ 进行两次扩展工作。这些扩展工作的总成本为 $1 \\times 2 = 2$。结果，从点 $1$ 开始，每个点的连接设施数量变为 $1, 3, 1, 1, 1$。\n4. 构建 $4$ 条滑道：一条从点 $1$ 到点 $2$，一条从点 $2$ 到点 $3$，一条从点 $4$ 到点 $2$，一条从点 $5$ 到点 $2$。\n\n因此，构建滑雪度假村的成本为 $6 + 2 = 8$。由于无法以不超过 $7$ 的成本建造滑雪度假村，因此输出 $8$。\n\n此样例输入满足子任务 $3,4,5,6$ 的约束条件。\n\n#### 样例解释 2\n\n这个样例输入与示例输入 1 的唯一区别在于 $K$ 的值。\n\n这个样例输入满足子任务 $1, 3, 4, 5, 6$ 的约束条件。\n\n#### 样例解释 3\n\n此示例输入满足子任务 $2, 3, 4, 5, 6$ 的约束条件。\n\n### 约束条件\n\n- $1 \\leq N \\leq 300$\n- $1 \\leq K \\leq 10^9$\n- $0 \\leq H_i \\leq 10^9$（$1 \\leq i \\leq N$）\n- $1 \\leq C_i \\leq 10^9$（$1 \\leq i \\leq N$）\n- 给定的值均为整数。\n\n### 子任务\n\n- (5 分) $K \\geq 100,000$，$H_i \\leq 300$，$C_i \\leq 100$（$1 \\leq i \\leq N$）\n- (12 分) $H_1 \\leq H_i$，$C_1 \\leq C_i$，$H_i \\leq 300$（$1 \\leq i \\leq N$）\n- (9 分) $N \\leq 10$，$H_i \\leq 10$（$1 \\leq i \\leq N$）\n- (33 分) $N \\leq 40$，$H_i \\leq 40$（$1 \\leq i \\leq N$）\n- (27 分) $H_i \\leq 300$（$1 \\leq i \\leq N$）\n- (14 分) 无额外约束。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2024] 滑雪 2 / Ski 2", "background": "", "description": "JOI 先生管理着 IOI 高原上一家著名的滑雪度假村，他决定为滑雪度假村开业 15 周年庆祝活动而在相邻的 KOI 高原上建造一家新的滑雪度假村。\n\nKOI 高原有 $N$ 个点，编号从 $1$ 到 $N$。目前，第 $i$ 个点（$1 \\leq i \\leq N$）的海拔高度为 $H_i$ 米，并且高原上的每个点都没有连接起来的滑道。此外，每个点都配备了一个未使用的连接设施。\n\nJOI 先生的目标是在高原上的一个点上建造 KOI 酒店，然后建造一些滑道连接高原上的每个点，以便人们可以从任何一个点滑雪到酒店。具体来说，JOI 先生将按照以下步骤建造滑雪度假村：\n\n1. 进行以下筑堤工作任意次数（可能为零）：选择一个点 $i$，将点 $i$ 的海拔高度增加 1 米。此工作的成本为每次操作 $K$。\n\n2. 从 $N$ 个点中选择一个点，并在那里建造 KOI 酒店。\n\n3. 进行以下扩展工作任意次数（可能为零）：选择一个点 $i$，在点 $i$ 建造一个连接设施。此工作的成本为每次操作 $C_i$。\n\n4. 对于除了 KOI 酒店所在点之外的剩余 $N - 1$ 个点，执行以下构建：设 $i$ 为该点的编号。选择另一个海拔严格较低的点 $j$，并使用点 $j$ 的一个未使用的连接设施，从点 $i$ 向点 $j$ 构建单向滑道。注意，如果没有海拔严格较低且有未使用连接设施的点 $j$，则无法实现目标。\n\n滑雪度假村的建造成本是进行堤岸工作和扩展工作的成本之和。\n\n编写一个程序，给定 KOI 高原上每个点的信息和每次筑堤工作的成本 $K$，找到建造滑雪度假村的最小成本。\n", "inputFormat": "从标准输入中读取以下数据：\n\n- $N$ $K$\n- $H_1$ $C_1$\n- $H_2$ $C_2$\n- ...\n- $H_N$ $C_N$\n", "outputFormat": "\n输出一行，构建滑雪度假村的最小成本。", "hint": "#### 样例解释 1\n\n例如，可以按以下方式建造滑雪度假村：\n\n1. 在点 $1$ 进行两次筑堤工作，在点 $5$ 进行一次。这些筑堤工作的总成本为 $2 \\times (2 + 1) = 6$。每个点的海拔高度变为 $2, 1, 0, 2, 2$ 米。\n2. 在点 $3$ 建造 KOI 酒店。\n3. 在点 $2$ 进行两次扩展工作。这些扩展工作的总成本为 $1 \\times 2 = 2$。结果，从点 $1$ 开始，每个点的连接设施数量变为 $1, 3, 1, 1, 1$。\n4. 构建 $4$ 条滑道：一条从点 $1$ 到点 $2$，一条从点 $2$ 到点 $3$，一条从点 $4$ 到点 $2$，一条从点 $5$ 到点 $2$。\n\n因此，构建滑雪度假村的成本为 $6 + 2 = 8$。由于无法以不超过 $7$ 的成本建造滑雪度假村，因此输出 $8$。\n\n此样例输入满足子任务 $3,4,5,6$ 的约束条件。\n\n#### 样例解释 2\n\n这个样例输入与示例输入 1 的唯一区别在于 $K$ 的值。\n\n这个样例输入满足子任务 $1, 3, 4, 5, 6$ 的约束条件。\n\n#### 样例解释 3\n\n此示例输入满足子任务 $2, 3, 4, 5, 6$ 的约束条件。\n\n### 约束条件\n\n- $1 \\leq N \\leq 300$\n- $1 \\leq K \\leq 10^9$\n- $0 \\leq H_i \\leq 10^9$（$1 \\leq i \\leq N$）\n- $1 \\leq C_i \\leq 10^9$（$1 \\leq i \\leq N$）\n- 给定的值均为整数。\n\n### 子任务\n\n- (5 分) $K \\geq 100,000$，$H_i \\leq 300$，$C_i \\leq 100$（$1 \\leq i \\leq N$）\n- (12 分) $H_1 \\leq H_i$，$C_1 \\leq C_i$，$H_i \\leq 300$（$1 \\leq i \\leq N$）\n- (9 分) $N \\leq 10$，$H_i \\leq 10$（$1 \\leq i \\leq N$）\n- (33 分) $N \\leq 40$，$H_i \\leq 40$（$1 \\leq i \\leq N$）\n- (27 分) $H_i \\leq 300$（$1 \\leq i \\leq N$）\n- (14 分) 无额外约束。", "locale": "zh-CN"}}}
{"pid": "P10433", "type": "P", "difficulty": 7, "samples": [["5 5 2\n1 2\n2 3\n2 4\n3 5\n4 5\n00000\n1 5", "0\n1\n2\n2\n3"], ["5 5 2\n1 2\n2 3\n2 4\n3 5\n4 5\n01000\n1 5", "0\n1\n4\n4\n5"], ["5 5 2\n1 2\n2 3\n2 4\n3 5\n4 5\n01100\n1 5\n", "0\n1\n3\n3\n4"], ["8 7 5\n1 3\n5 7\n4 6\n2 6\n2 3\n7 8\n1 5\n10011010\n4 6 4 7 1", "4\n2\n3\n0\n10\n1\n17\n24"], ["12 13 3\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n8 9\n9 10\n1 10\n2 9\n7 12\n11 12\n110000011101\n1 9 11\n", "0\n1\n4\n5\n6\n7\n8\n8\n4\n1\n13\n9"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["图论", "2024", "最短路", "凸包", "Ad-hoc", "根号分治", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] 棋盘游戏 / Board Game", "background": "", "description": "有一个供 $K$ 个玩家玩的棋盘游戏。该游戏的棋盘由 $N$ 个编号从 1 到 $N$ 的单元格和 $M$ 条编号从 1 到 $M$ 的路径组成，其中路径 $j$（$1 ≤ j ≤ M$）双向连接着单元格 $U_j$ 和 $V_j$。\n\n棋盘上有两种类型的单元格：重新激活单元格和停止单元格。\n\n这些信息由长度为 $N$ 的字符串 $S$ 给出，$S$ 由 $0$ 和 $1$ 组成，其中 $S$ 的第 $i$ 个字符（$1 ≤ i ≤ N$）是 '0' 表示单元格 $i$ 是重新激活单元格，是 '1' 表示单元格 $i$ 是停止单元格。\n\n这个棋盘游戏由编号从 $1$ 到 $K$ 的 $K$ 个玩家进行。每个玩家都有自己的棋子，游戏从每个玩家将其棋子放在特定的单元格上开始。一开始，玩家 $p$（$1 \\leq p \\leq K$）将其棋子放在单元格 $X_p$ 上。注意，多个玩家的棋子可以放在同一个单元格上。\n\n游戏随着每个玩家轮流进行而进行，从玩家 1 开始，按数字顺序进行。在玩家 $p$ 完成其回合后，玩家 $p + 1$ 开始回合（如果 $p = K$，则玩家 1 开始回合）。每个玩家在其回合上执行以下操作：\n\n1. 选择与其棋子所在的单元格通过一条路径相连的一个单元格，并将其棋子移动到所选择的单元格上。\n2. 如果目标单元格是重新激活单元格，则重复步骤 1 并继续其回合。如果目标单元格是停止单元格，则结束其回合。\n\n代表日本参加这个棋盘游戏的包括 JOI 君在内的由 $K$ 名成员组成的团队，正在研究协作策略，以快速征服这个游戏。他们目前正在研究以下问题：\n\n为了将玩家 1 的棋子放置在单元格 $T$ 上，$K$ 名玩家需要的最小总移动次数是多少？即使在回合中途，如果玩家 1 的棋子被放置在单元格 $T$ 上，也认为满足条件。\n\n给定关于游戏棋盘和每个玩家棋子的初始放置位置的信息，编写一个程序来计算每个 $T = 1, 2, \\ldots, N$ 对应的问题的答案。", "inputFormat": "从标准输入中读取以下数据：\n\n- $N$ $M$ $K$\n- $U_1$ $V_1$\n- $U_2$ $V_2$\n- ...\n- $U_M$ $V_M$\n- $S$\n- $X_1,X_2,...,X_K$\n", "outputFormat": "输出 $N$ 行。在第 $T$ 行（$1 ≤ T ≤ N$）上，输出 $K$ 个玩家将玩家 1 的棋子放在单元格 $T$ 上所需的最小总移动次数。\n", "hint": "#### 样例解释 1\n\n由于玩家 $1$ 的棋子从单元格 $1$ 开始，所以 $T = 1$ 的答案是 $0$。\n\n对于 $T = 2$，在第一步中，玩家 $1$ 可以将他的棋子从单元格 $1$ 移动到单元格 $2$。因此，$T = 2$ 的答案是 $1$。\n\n对于 $T = 3$，他们可以通过以下 $2$ 步将玩家 $1$ 的棋子放置在单元格 $3$ 上：\n\n- 在第一步中，玩家 $1$ 将他的棋子从单元格 $1$ 移动到单元格 $2$。由于单元格 $2$ 是一个激活单元格，因此玩家 $1$ 的回合继续。\n- 在第二步中，玩家 $1$ 将他的棋子从单元格 $2$ 移动到单元格 $3$。\n\n由于他们无法在 $1$ 步或更少的步骤中将玩家 $1$ 的棋子放置在单元格 $3$ 上，所以 $T = 3$ 的答案是 $2$。\n\n类似地，可以验证 $T = 4$ 的答案为 $2$，$T = 5$ 的答案为 $3$。\n\n这个样例输入满足子任务 $1,4,5,6,7,8$ 的约束。\n\n\n\n#### 样例解释 2\n\n对于 $T = 3$，他们可以通过以下 4 步将玩家 $1$ 的棋子放置在单元格 $3$ 上：\n\n- 在第一步中，玩家 $1$ 将他的棋子从单元格 $1$ 移动到单元格 $2$。由于单元格 $2$ 是一个停止单元格，接下来轮到玩家 $2$。\n- 在第二步中，玩家 $2$ 将他的棋子从单元格 $5$ 移动到单元格 $3$。由于单元格 $3$ 是一个激活单元格，玩家 $2$ 的回合继续。\n- 在第三步中，玩家 $2$ 将他的棋子从单元格 $3$ 移动到单元格 $2$。由于单元格 $2$ 是一个停止单元格，接下来轮到玩家 $1$。\n- 在第四步中，玩家 $1$ 将他的棋子从单元格 $2$ 移动到单元格 $3$。\n\n由于他们无法在 $3$ 步或更少的步骤中将玩家 $1$ 的棋子放置在单元格 $3$ 上，所以 $T = 3$ 的答案是 $4$。\n\n这个样例输入满足子任务 $2,4,5,6,7,8$ 的约束。\n\n#### 样例解释 3\n\n这个样例输入满足子任务 $3, 4, 5, 6, 7,8$ 的约束。\n\n#### 样例解释 4\n\n这个样例输入满足子任务 $4, 6, 7,8$ 的约束。\n\n#### 样例解释 5\n\n这个样例输入满足子任务 $4, 6, 7,8$ 的约束。\n\n### 约束条件\n\n- $2 \\leq N \\leq 50,000$\n- $1 \\leq M \\leq 50,000$\n- $2 \\leq K \\leq 50,000$\n- $1 \\leq U_j < V_j \\leq N$（$1 \\leq j \\leq M$）\n- $(U_j, V_j)$，$(U_k, V_k)$（$1 \\leq j < k \\leq M$）\n- 可以通过经过多条路径从任何单元格到达任何其他单元格。\n- $S$ 是长度为 $N$ 的由 '0' 和 '1' 组成的字符串。\n- $1 \\leq X_p \\leq N$（$1 \\leq p \\leq K$）\n- $N$、$M$ 和 $K$ 都是整数。\n- $U_j$ 和 $V_j$ 是整数（$1 \\leq j \\leq M$）。\n- $X_p$ 是整数（$1 \\leq p \\leq K$）。\n\n### 子任务\n\n1. (3 分) 没有终止单元格。\n2. (7 分) 恰好有一个终止单元格。\n3. (7 分) 恰好有两个终止单元格。\n4. (19 分) $N \\leq 3,000$，$M \\leq 3,000$，$K \\leq 3,000$\n5. (23 分) $K = 2$\n6. (9 分) $K \\leq 100$\n7. (23 分) $N \\leq 30,000$，$M \\leq 30,000$，$K \\leq 30,000$\n8. (9 分) 没有额外的约束。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2024] 棋盘游戏 / Board Game", "background": "", "description": "有一个供 $K$ 个玩家玩的棋盘游戏。该游戏的棋盘由 $N$ 个编号从 1 到 $N$ 的单元格和 $M$ 条编号从 1 到 $M$ 的路径组成，其中路径 $j$（$1 ≤ j ≤ M$）双向连接着单元格 $U_j$ 和 $V_j$。\n\n棋盘上有两种类型的单元格：重新激活单元格和停止单元格。\n\n这些信息由长度为 $N$ 的字符串 $S$ 给出，$S$ 由 $0$ 和 $1$ 组成，其中 $S$ 的第 $i$ 个字符（$1 ≤ i ≤ N$）是 '0' 表示单元格 $i$ 是重新激活单元格，是 '1' 表示单元格 $i$ 是停止单元格。\n\n这个棋盘游戏由编号从 $1$ 到 $K$ 的 $K$ 个玩家进行。每个玩家都有自己的棋子，游戏从每个玩家将其棋子放在特定的单元格上开始。一开始，玩家 $p$（$1 \\leq p \\leq K$）将其棋子放在单元格 $X_p$ 上。注意，多个玩家的棋子可以放在同一个单元格上。\n\n游戏随着每个玩家轮流进行而进行，从玩家 1 开始，按数字顺序进行。在玩家 $p$ 完成其回合后，玩家 $p + 1$ 开始回合（如果 $p = K$，则玩家 1 开始回合）。每个玩家在其回合上执行以下操作：\n\n1. 选择与其棋子所在的单元格通过一条路径相连的一个单元格，并将其棋子移动到所选择的单元格上。\n2. 如果目标单元格是重新激活单元格，则重复步骤 1 并继续其回合。如果目标单元格是停止单元格，则结束其回合。\n\n代表日本参加这个棋盘游戏的包括 JOI 君在内的由 $K$ 名成员组成的团队，正在研究协作策略，以快速征服这个游戏。他们目前正在研究以下问题：\n\n为了将玩家 1 的棋子放置在单元格 $T$ 上，$K$ 名玩家需要的最小总移动次数是多少？即使在回合中途，如果玩家 1 的棋子被放置在单元格 $T$ 上，也认为满足条件。\n\n给定关于游戏棋盘和每个玩家棋子的初始放置位置的信息，编写一个程序来计算每个 $T = 1, 2, \\ldots, N$ 对应的问题的答案。", "inputFormat": "从标准输入中读取以下数据：\n\n- $N$ $M$ $K$\n- $U_1$ $V_1$\n- $U_2$ $V_2$\n- ...\n- $U_M$ $V_M$\n- $S$\n- $X_1,X_2,...,X_K$\n", "outputFormat": "输出 $N$ 行。在第 $T$ 行（$1 ≤ T ≤ N$）上，输出 $K$ 个玩家将玩家 1 的棋子放在单元格 $T$ 上所需的最小总移动次数。\n", "hint": "#### 样例解释 1\n\n由于玩家 $1$ 的棋子从单元格 $1$ 开始，所以 $T = 1$ 的答案是 $0$。\n\n对于 $T = 2$，在第一步中，玩家 $1$ 可以将他的棋子从单元格 $1$ 移动到单元格 $2$。因此，$T = 2$ 的答案是 $1$。\n\n对于 $T = 3$，他们可以通过以下 $2$ 步将玩家 $1$ 的棋子放置在单元格 $3$ 上：\n\n- 在第一步中，玩家 $1$ 将他的棋子从单元格 $1$ 移动到单元格 $2$。由于单元格 $2$ 是一个激活单元格，因此玩家 $1$ 的回合继续。\n- 在第二步中，玩家 $1$ 将他的棋子从单元格 $2$ 移动到单元格 $3$。\n\n由于他们无法在 $1$ 步或更少的步骤中将玩家 $1$ 的棋子放置在单元格 $3$ 上，所以 $T = 3$ 的答案是 $2$。\n\n类似地，可以验证 $T = 4$ 的答案为 $2$，$T = 5$ 的答案为 $3$。\n\n这个样例输入满足子任务 $1,4,5,6,7,8$ 的约束。\n\n\n\n#### 样例解释 2\n\n对于 $T = 3$，他们可以通过以下 4 步将玩家 $1$ 的棋子放置在单元格 $3$ 上：\n\n- 在第一步中，玩家 $1$ 将他的棋子从单元格 $1$ 移动到单元格 $2$。由于单元格 $2$ 是一个停止单元格，接下来轮到玩家 $2$。\n- 在第二步中，玩家 $2$ 将他的棋子从单元格 $5$ 移动到单元格 $3$。由于单元格 $3$ 是一个激活单元格，玩家 $2$ 的回合继续。\n- 在第三步中，玩家 $2$ 将他的棋子从单元格 $3$ 移动到单元格 $2$。由于单元格 $2$ 是一个停止单元格，接下来轮到玩家 $1$。\n- 在第四步中，玩家 $1$ 将他的棋子从单元格 $2$ 移动到单元格 $3$。\n\n由于他们无法在 $3$ 步或更少的步骤中将玩家 $1$ 的棋子放置在单元格 $3$ 上，所以 $T = 3$ 的答案是 $4$。\n\n这个样例输入满足子任务 $2,4,5,6,7,8$ 的约束。\n\n#### 样例解释 3\n\n这个样例输入满足子任务 $3, 4, 5, 6, 7,8$ 的约束。\n\n#### 样例解释 4\n\n这个样例输入满足子任务 $4, 6, 7,8$ 的约束。\n\n#### 样例解释 5\n\n这个样例输入满足子任务 $4, 6, 7,8$ 的约束。\n\n### 约束条件\n\n- $2 \\leq N \\leq 50,000$\n- $1 \\leq M \\leq 50,000$\n- $2 \\leq K \\leq 50,000$\n- $1 \\leq U_j < V_j \\leq N$（$1 \\leq j \\leq M$）\n- $(U_j, V_j)$，$(U_k, V_k)$（$1 \\leq j < k \\leq M$）\n- 可以通过经过多条路径从任何单元格到达任何其他单元格。\n- $S$ 是长度为 $N$ 的由 '0' 和 '1' 组成的字符串。\n- $1 \\leq X_p \\leq N$（$1 \\leq p \\leq K$）\n- $N$、$M$ 和 $K$ 都是整数。\n- $U_j$ 和 $V_j$ 是整数（$1 \\leq j \\leq M$）。\n- $X_p$ 是整数（$1 \\leq p \\leq K$）。\n\n### 子任务\n\n1. (3 分) 没有终止单元格。\n2. (7 分) 恰好有一个终止单元格。\n3. (7 分) 恰好有两个终止单元格。\n4. (19 分) $N \\leq 3,000$，$M \\leq 3,000$，$K \\leq 3,000$\n5. (23 分) $K = 2$\n6. (9 分) $K \\leq 100$\n7. (23 分) $N \\leq 30,000$，$M \\leq 30,000$，$K \\leq 30,000$\n8. (9 分) 没有额外的约束。\n\n", "locale": "zh-CN"}}}
{"pid": "P10434", "type": "P", "difficulty": 7, "samples": [["3 3\n1 2 1\n0 2 2\n0 1 3\n2\n2 1\n2\n0 1", ""]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "交互题", "Special Judge", "最短路", "虚树", "Catalan 数", "通信题", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] 间谍 3 / Spy 3", "background": "在本题中，你需要将两个文件合并成一个文件提交。\n\n**不要引入任何头文件**，并在文件头加入如下的内容：\n\n```cpp\n#include <vector>\nvoid answer(const std::vector<int> &);\n```", "description": "\n\n Aoi 和 Bitaro 是 JOI 国 国家情报局的间谍。这次他们的任务是对 IOI 国 进行潜入调查。Bitaro 潜入 IOI 国，而 Aoi 在 JOI 国 向 Bitaro 发出指示。\n\n潜入前，Aoi 和 Bitaro 得到了 IOI 国 的一张地图。IOI 国 有 $N$ 个城市，编号为 $0$ 到 $N-1$。此外，IOI 国 有 $M$ 条道路，编号为 $0$ 到 $M-1$。第 $i$ 条道路（$0 \\le i \\le M-1$）双向连接城市 $A_i$ 和城市 $B_i$，长度为 $C_i$。通过若干条道路可以在任意两座城市之间往来。Bitaro 在 IOI 国 内通过这些道路在城市间移动。另外，共有 $Q$ 个调查计划。第 $j$ 个计划（$0 \\le j \\le Q-1$）要调查 IOI 国 的城市 $T_j$。\n\n以上信息最初同时告知了 Aoi 和 Bitaro。随后，Bitaro 开始潜入 IOI 国。\n\nBitaro 设法甩开了无数追兵，击败了刺客，最终成功潜入 IOI 国 的城市 $0$。然而，由于潜入行动极其艰难，Bitaro 遗失了关于 IOI 国 的部分信息。具体而言，Bitaro 丢失了 $K$ 条道路的长度信息，即道路 $X_0, X_1, \\dots, X_{K-1}$。换言之，Bitaro 已不知道 $C_{X_0}, C_{X_1}, \\dots, C_{X_{K-1}}$ 的数值。注意，尽管 Bitaro 丢失了这些信息，Aoi 仍然掌握它们。\n\nBitaro 立刻向 Aoi 报告了他所遗失的道路长度信息是哪些。\n\n为了完成任务，Bitaro 希望从城市 $0$ 出发，分别找到到每个被 $Q$ 个调查计划锁定的城市的最短路径。\n\nAoi 将向 Bitaro 发送一个只包含字符 ‘0’ 或 ‘1’ 的字符串以协助他。由于存在被截获的风险，Aoi 希望尽量减少发送的内容。\n\n给定关于 IOI 国 的信息、调查计划以及 Bitaro 所遗失信息的道路，请编写程序实现 Aoi 的发送策略；同时，编写程序实现 Bitaro 在其掌握的信息与 Aoi 发送的字符串下寻找最短路径的策略。\n\n### 实现细节\n\n你需要提交 $2$ 个文件。\n\n第一个文件为 `Aoi.cpp`。该文件用于实现 Aoi 的策略，并应实现以下函数。程序需通过预处理指令 `#include` 包含 `Aoi.h`。\n\n* `std::string aoi(int N, int M, int Q, int K, std::vector<int> A, std::vector<int> B, std::vector<long long> C, std::vector<int> T, std::vector<int> X)`\n\n此函数在每个测试用例中只被调用一次。\n* 参数 $N$ 是 IOI 国 中的城市数量。\n* 参数 $M$ 是 IOI 国 中的道路数量。\n* 参数 $Q$ 是调查计划的数量。\n* 参数 $K$ 是 Bitaro 遗失长度信息的道路条数。\n* 参数 $A, B, C$ 为长度为 $M$ 的数组。表示第 $i$ 条道路（$0 \\le i \\le M-1$）双向连接城市 $A[i]$ 与城市 $B[i]$，长度为 $C[i]$。\n* 参数 $T$ 为长度为 $Q$ 的数组。表示第 $j$ 个计划（$0 \\le j \\le Q-1$）要调查的城市为 $T[j]$。\n* 参数 $X$ 为长度为 $K$ 的数组。表示 Bitaro 遗失长度信息的道路为 $X[0], X[1], \\dots, X[K-1]$。\n* 返回值为 Aoi 向 Bitaro 发送的字符串 $s$。\n* 字符串 $s$ 的每个字符必须是 ‘0’ 或 ‘1’。若不满足此条件，你的程序将被判定为 **Wrong Answer [1]**。\n* 字符串 $s$ 的长度最多为 $12000$。若不满足此条件，你的程序将被判定为 **Wrong Answer [2]**。\n\n第二个文件为 `Bitaro.cpp`。该文件用于实现 Bitaro 的策略，并应实现以下函数。程序需通过预处理指令 `#include` 包含 `Bitaro.h`。\n\n* `void bitaro(int N, int M, int Q, int K, std::vector<int> A, std::vector<int> B, std::vector<long long> C, std::vector<int> T, std::vector<int> X, std::string s)`\n\n此函数会在 `aoi` 函数被调用之后且仅被调用一次。\n* 参数 $N$ 是 IOI 国 中的城市数量。\n* 参数 $M$ 是 IOI 国 中的道路数量。\n* 参数 $Q$ 是调查计划的数量。\n* 参数 $K$ 是 Bitaro 遗失长度信息的道路条数。\n* 参数 $A, B, C$ 为长度为 $M$ 的数组。表示第 $i$ 条道路（$0 \\le i \\le M-1$）双向连接城市 $A[i]$ 与城市 $B[i]$，长度为 $C[i]$。\n* 参数 $T$ 为长度为 $Q$ 的数组。表示第 $j$ 个计划（$0 \\le j \\le Q-1$）要调查的城市为 $T[j]$。\n* 参数 $X$ 为长度为 $K$ 的数组。表示 Bitaro 遗失长度信息的道路为 $X[0], X[1], \\dots, X[K-1]$。\n* 参数 $s$ 是一个每个字符均为 ‘0’ 或 ‘1’ 的字符串，表示 Aoi 发送给 Bitaro 的字符串。\n\n在 `Bitaro.cpp` 中，你的程序可以调用如下函数。\n\n```cpp\nvoid answer(const std::vector<int> &e)\n```\n\n* 在第 $(j+1)$ 次调用（$0 \\le j \\le Q-1$）该函数时，你需要回答从城市 $0$ 到第 $j$ 个调查计划目标城市 $T_j$ 的最短路径。\n* 参数 `e` 是一个数组，表示从城市 $0$ 到城市 $T_j$ 的最短路径所经过的道路序列。\n* 设数组 `e` 的长度为 $n$。元素 `e[0], e[1], \\ldots, e[n-1]` 是该最短路径上按行进顺序经过的道路的编号。\n* 若存在多条最短路径，任选其一作为答案即可。\n* 参数 `e` 的每个元素必须在 $0$ 到 $M-1$ 之间。若不满足此条件，你的程序将被判定为 **Wrong Answer [3]**。\n* 参数 `e` 所指示的道路序列必须构成一条从城市 $0$ 到城市 $T_j$ 的路径。更正式地，它必须满足以下条件。\n    * 存在一列数字 $u_0, u_1, \\ldots, u_n$ 使得\n        * $u_0 = 0$。\n        * $u_n = T_j$。\n        * 道路 $e[k]$（$0 \\le k \\le n-1$）连接城市 $u_k$ 与城市 $u_{k+1}$。\n    * 若不满足这些条件，你的程序将被判定为 **Wrong Answer [4]**。\n* 若参数 `e` 指示的道路序列并非所有从城市 $0$ 到城市 $T_j$ 的路径中长度最短的一条，你的程序将被判定为 **Wrong Answer [5]**。这里，路径长度定义为所用道路长度之和。\n* 函数 `answer` 必须被调用恰好 $Q$ 次。若在 `bitaro` 函数结束时，对 `answer` 的调用次数不等于 $Q$，你的程序将被判定为 **Wrong Answer [6]**。\n\n### 重要注意事项\n\n* 你的程序可以为内部使用实现其他函数，或使用全局变量。提交的文件将与评测程序一起编译，形成单个可执行文件。所有全局变量与内部函数应声明在未命名命名空间中，以避免与其他文件冲突。评测时会分别以 Aoi 进程与 Bitaro 进程运行。Aoi 进程与 Bitaro 进程不能共享全局变量。\n* 你的程序不得使用标准输入与标准输出。你的程序不得以任何方式与其他文件通信。但你可以向标准错误输出调试信息。\n\n### 编译与测试运行\n\n你可以从比赛网页下载包含样例评测器的压缩包，用于本地测试。压缩包中也包含你程序的样例源文件。\n\n样例评测器文件为 `grader.cpp`。为测试你的程序，请将 `grader.cpp`、`Aoi.cpp`、`Bitaro.cpp`、`Aoi.h`、`Bitaro.h` 放在同一目录下，并运行以下命令进行编译。你也可以运行压缩包内的 `compile.sh`。\n\n```bash\ng++ -std=gnu++20 -O2 -o grader grader.cpp Aoi.cpp Bitaro.cpp\n```\n\n当编译成功时，将生成可执行文件 `grader`。\n\n注意，实际评测器不同于样例评测器。样例评测器作为单进程执行，从标准输入读取数据，并向标准输出与标准错误输出写出结果。\n", "inputFormat": "\n样例评测器从标准输入读取如下数据。\n\n> $N$ $M$\\\n> $A_0$ $B_0$ $C_0$\\\n> $A_1$ $B_1$ $C_1$\\\n> $A_{M-1}$ $B_{M-1}$ $C_{M-1}$\\\n> $Q$\\\n> $T_0$ $T_1$ $\\cdots$ $T_{Q-1}$\\\n> $K$\\\n> $X_0$ $X_1$ $\\cdots$ $X_{K-1}$\n", "outputFormat": "\n样例评测器向标准输出与标准错误输出输出如下信息（引号仅为说明）。\n\n* 若你的程序被判为 **Wrong Answer [1], [2], [3], [4], 或 [6]**，样例评测器会在标准错误输出写出其类型，如 “Wrong Answer [1]”。标准输出不会输出任何内容。\n* 否则，`aoi` 函数返回的字符串 $s$ 的长度会以 “Accepted: 2024” 的格式输出到标准错误输出。此外，在第 $(j+1)$ 次（$0 \\le j \\le Q-1$）对 `answer` 的调用中，路径长度会输出到标准输出的第 $(j+1)$ 行。样例评测程序 **不会检查** 该路径是否最短。\n\n若你的程序同时满足多种 Wrong Answer 的条件，样例评测器仅报告其中一种。", "hint": "\n### 示例通信\n\n下面给出一个样例评测器的输入及相应的函数调用。\n\n| 样例输入 1 | 调用 | 返回值 |\n|---|---|---|\n| $$\\texttt{3 3}\\\\ \\texttt{1 2 1} \\\\ \\texttt{0 2 2} \\\\ \\texttt{0 1 3} \\\\ \\texttt{2} \\\\ \\texttt{2 1} \\\\ \\texttt{2} \\\\ \\texttt{0 1}$$ | `aoi(3, 3, 2, 2, [1, 0, 0], [2, 2, 1], [1, 2, 3], [2, 1], [0, 1])` |  |\n| ^ | | `\"101001\"` |\n| ^ | `bitaro(3, 3, 2, 2, [1, 0, 0], [2, 2, 1], [-1, -1, 3], [2, 1], [0, 1], \"101001\")` | |\n| ^ | `answer([1])` | |\n| ^ | `answer([1, 0])` | |\n\n从城市 $0$ 到城市 $1$ 的最短路径，可以按顺序经过道路 $1$ 和 $0$，或者仅经过道路 $2$。因此，在本样例的第二次对 `answer` 的调用中，调用 `answer([2])` 也是可以接受的。\n\n从比赛网站下载的文件 `sample-01-in.txt` 与输入样例 $1$ 相对应。压缩包中的 `sample-01-in.txt` 与 `sample-02-in.txt` 可作为样例评测器的输入。\n\n### 约束\n\n所有输入数据均满足以下条件：\n\n* $2 \\le N \\le 10000$。\n* $1 \\le M \\le 20000$。\n* $1 \\le Q \\le 16$。\n* $1 \\le K \\le 300$。\n* $0 \\le A_i < B_i \\le N-1$（$0 \\le i \\le M-1$）。\n* $(A_i, B_i) \\ne (A_j, B_j)$（$0 \\le i < j \\le M-1$）。\n* $1 \\le C_i \\le 10^{12}$（$0 \\le i \\le M-1$）。\n* $1 \\le T_j \\le N-1$（$0 \\le j \\le Q-1$）。\n* $T_j \\ne T_k$（$0 \\le j < k \\le Q-1$）。\n* $0 \\le X_k \\le M-1$（$0 \\le k \\le K-1$）。\n* $X_k \\ne X_l$（$0 \\le k < l \\le K-1$）。\n* 通过若干条道路可以在任意两座城市之间往来。\n* 所有输入值均为整数。\n\n### 评分\n\n若你的程序在任意测试用例中被判定为 **Wrong Answer [1] - [6]**（见实现细节）或出现任意类型的运行时错误（TLE、MLE、异常结束等），你的得分为 $0$ 分。\n\n否则，评分依据为在本题所有测试用例中，函数 `aoi` 返回的字符串 $s$ 的最大长度 $L$。\n\n* 若 $1561 \\le L \\le 12000$，得分为 $\\left\\lfloor \\dfrac{100\\,000}{L-560} \\right\\rfloor$。\n* 若 $0 \\le L \\le 1560$，得分为 $100$ 分。\n\n其中，$\\lfloor x \\rfloor$ 表示不超过 $x$ 的最大整数。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[JOIST 2024] Spy 3", "background": "", "description": "\nAoi and Bitaro are spies belonging to the National Information Bureau of JOI country. Their mission this time is to conduct undercover investigation into the IOI country. Bitaro infiltrates into the IOI country, while Aoi gives instructions to Bitaro from the JOI country.\n\nBefore the infiltration, Aoi and Bitaro obtained a map of the IOI country. The IOI country has $N$ cities, numbered from $0$ to $N-1$. Moreover, there are $M$ roads in the IOI country, numbered from $0$ to $M-1$. Road $i$ ($0 \\le i \\le M-1$) connects city $A_i$ and city $B_i$ bidirectionally, with a length of $C_i$. It is possible to travel between any pair of cities by passing some roads. Bitaro moves between cities in the IOI country by passing these roads. Additionally, there are $Q$ investigation plans. The $j$-th plan ($0 \\le j \\le Q-1$) involves investigating city $T_j$ in the IOI country.\n\nAll the information above were first given to both Aoi and Bitaro. Then, Bitaro proceeded with the infiltration into the IOI country.\n\nBitaro successfully evaded numerous pursuers, defeated assassins, and finally managed to infiltrate into city $0$ of the IOI country. However, due to the extremely difficult nature of the infiltration operation, Bitaro lost some of the information about the IOI country. Specifically, Bitaro lost information about the length of $K$ roads, namely the roads $X_0, X_1, \\dots, X_{K-1}$. In other words, Bitaro no longer knows the values of $C_{X_0}, C_{X_1}, \\dots, C_{X_{K-1}}$. Note that while Bitaro lost this information, Aoi still retains it.\n\nBitaro immediately reported to Aoi which road lengths' information he had lost.\n\nTo accomplish the mission, Bitaro wants to find a shortest path from city $0$ to each of the cities targeted by the $Q$ investigation plans.\n\nAoi will send Bitaro a string where each character is either '0' or '1' to assist him. Due to the risk of interception, Aoi wants to minimize the content sent to Bitaro.\n\nWrite a program to implement Aoi's strategy for sending a string to Bitaro, given the information about the IOI country, the investigation plans, and the roads Bitaro lost information about. Also, write a program to implement Bitaro's strategy for finding the shortest paths given the information he possesses and the string sent by Aoi.\n\n### Implementation Details\n\nYou should submit $2$ files.\n\nThe first file is `Aoi.cpp`. This file is intended to implement Aoi's strategy and should implement the following functions. The program should include `Aoi.h` using the preprocessor directive `#include`.\n\n*   `std::string aoi(int N, int M, int Q, int K, std::vector<int> A, std::vector<int> B, std::vector<long long> C, std::vector<int> T, std::vector<int> X)`\n\nThis function is called only once for each test case.\n*   The parameter $N$ is the number of cities in IOI Kingdom $N$.\n*   The parameter $M$ is the number of roads in IOI Kingdom $M$.\n*   The parameter $Q$ is the number of investigation plans $Q$.\n*   The parameter $K$ is the number of roads that Bitaro lost the length information of, denoted by $K$.\n*   The parameters $A, B, C$ are arrays of length $M$. They mean the road $i$ ($0 \\le i \\le M-1$) connects the city $A[i]$ and the city $B[i]$ bidirectionally, with a length of $C[i]$.\n*   The parameter $T$ is an array of length $Q$. It means the $j$-th plan ($0 \\le j \\le Q-1$) involves investigating city $T[j]$.\n*   The parameter $X$ is an array of length $K$. It indicates that Bitaro lost the length information of roads $X[0], X[1], \\dots, X[K-1]$.\n*   The return value is the string $s$ that Aoi sends to Bitaro.\n*   Each character of the string $s$ must be either '0' or '1'. If this condition is not met, your program will be judged as **Wrong Answer [1]**.\n*   The length of string $s$ must be at most $12000$. If this condition is not met, your program will be judged as **Wrong Answer [2]**.\n\nThe second file is `Bitaro.cpp`. This file is intended to implement Bitaro's strategy and should implement the following functions. The program should include `Bitaro.h` using the preprocessor directive `#include`.\n\n*   `void bitaro(int N, int M, int Q, int K, std::vector<int> A, std::vector<int> B, std::vector<long long> C, std::vector<int> T, std::vector<int> X, std::string s)`\n\nThis function is called only once after the function `aoi` is called.\n*   The parameter $N$ is the number of cities in IOI Kingdom $N$.\n*   The parameter $M$ is the number of roads in IOI Kingdom $M$.\n*   The parameter $Q$ is the number of investigation plans $Q$.\n*   The parameter $K$ is the number of roads that Bitaro lost the length information of, denoted by $K$.\n*   The parameters $A, B, C$ are arrays of length $M$. They mean the road $i$ ($0 \\le i \\le M-1$) connects the city $A[i]$ and the city $B[i]$ bidirectionally, with a length of $C[i]$.\n*   The parameter $T$ is an array of length $Q$. It means the $j$-th plan ($0 \\le j \\le Q-1$) involves investigating city $T[j]$.\n*   The parameter $X$ is an array of length $K$. It indicates that Bitaro lost the length information of roads $X[0], X[1], \\dots, X[K-1]$.\n*   The argument $s$ is a string where each character is either '0' or '1', representing the string sent by Aoi to Bitaro.\n\n Within Bitaro.cpp, your program can call the following function.\n\n```cpp\nvoid answer(const std::vector<int> &e)\n```\n\n* In the $(j+1)$-th call ($0 \\le j \\le Q-1$) to this function, you have to answer the shortest path from city 0 to city $T_j$, which is the target of the $j$-th investigation plan.\n* The parameter `e` is an array that represents the shortest path from city 0 to city $T_j$.\n* Let $n$ be the length of the array `e`. The elements $e[0], e[1], \\ldots, e[n-1]$ are the indices of roads in the shortest path from city 0 to city $T_j$, in the order of traversal.\n* If there are multiple possible shortest paths, any of them can be chosen as the answer.\n* Each element of the parameter `e` must be between 0 and $M-1$. If this condition is not met, your program will be judged as **Wrong Answer [3]**.\n* The sequence of roads indicated by the argument `e` must form a path from city 0 to city $T_j$. More formally, it must satisfy the following conditions.\n    * There exists a sequence of numbers $u_0, u_1, \\ldots, u_n$ such that\n        * $u_0 = 0$.\n        * $u_n = T_j$.\n        * The road $e[k]$ (where $0 \\le k \\le n-1$) connects city $u_k$ and city $u_{k+1}$.\n    * If these conditions are not met, your program will be judged as **Wrong Answer [4]**.\n* If the sequence of roads indicated by the argument `e` is not the shortest path from city 0 to city $T_j$ among all paths starting from city 0 and ending at city $T_j$, your program will be judged as **Wrong Answer [5]**. Here, the length of the path is defined as the sum of the lengths of the roads used.\n* The function `answer` must be called exactly $Q$ times. If the number of calls to the function `answer` is not equal to $Q$ at the end of the execution of the function `bitaro`, your program will be judged as **Wrong Answer [6]**.\n\n### Important Notices\n\n* Your program can implement other functions for internal use, or use global variables. Submitted files will be compiled with the grader, and become a single executable file. All global variables and internal functions should be declared in an unnamed namespace to avoid confliction with other files. When it is graded, it will be executed as two processes of Aoi and Bitaro. The process of Aoi and the process of Bitaro cannot share global variables.\n* Your program must not use the standard input and the standard output. Your program must not communicate with other files by any methods. However, your program may output debugging information to the standard error.\n\n### Compilation and Test Run\n\nYou can download an archive file from the contest webpage which contains the sample grader to test your program. The archive file also contains a sample source file of your program.\n\nThe sample grader is the file `grader.cpp`. In order to test your program, put `grader.cpp`, `Aoi.cpp`, `Bitaro.cpp`, `Aoi.h`, `Bitaro.h` in the same directory, and run the following command to compile your programs. Instead, you may run `compile.sh` contained in the archive file.\n\n```bash\ng++ -std=gnu++20 -O2 -o grader grader.cpp Aoi.cpp Bitaro.cpp\n```\n\nWhen the compilation succeeds, the executable file `grader` is generated.\n\nNote that the actual grader is different from the sample grader. The sample grader will be executed as a single process, which will read input data from the standard input and write the results to the standard output and the standard error output.\n", "inputFormat": "\nThe sample grader reads the following data from the standard input.\n\n\n> $N$ $M$\\\n> $A_0$ $B_0$ $C_0$\\\n> $A_1$ $B_1$ $C_1$\\\n> $A_{M-1}$ $B_{M-1}$ $C_{M-1}$\\\n> $Q$\\\n> $T_0$ $T_1$ $\\cdots$ $T_{Q-1}$\\\n> $K$\\\n> $X_0$ $X_1$ $\\cdots$ $X_{K-1}$\n", "outputFormat": "\nThe sample grader outputs the following information to the standard output and the standard error output (quotes for clarity).\n\n* If your program is judged as **Wrong Answer [1], [2], [3], [4], or [6]**, the sample grader writes its type as \"Wrong Answer [1]\" in the standard error output. Nothing will be output to the standard output.\n* If not, the length of the returned string $s$ from the function `aoi` will be output to the standard error output in the format \"Accepted: 2024\". Additionally, the length of the path in the $(j+1)$-th call ($0 \\le j \\le Q-1$) to the `answer` function will be output to $(j+1)$-th line of the standard output. The sample grading program **does not check** whether the path is the shortest.\n\nIf your program meets the conditions of several types of Wrong Answer, the sample grader reports only one of them.\n", "hint": "### Sample Communication\n\nHere is a sample input for the sample grader and corresponding function calls.\n\n| Sample Input 1 | Call | Return value |\n|---|---|---|\n| $$\\texttt{3 3}\\\\ \\texttt{1 2 1} \\\\ \\texttt{0 2 2} \\\\ \\texttt{0 1 3} \\\\ \\texttt{2} \\\\ \\texttt{2 1} \\\\ \\texttt{2} \\\\ \\texttt{0 1}$$ | `aoi(3, 3, 2, 2, [1, 0, 0], [2, 2, 1], [1, 2, 3], [2, 1], [0, 1])` |  |\n| ^ | | `\"101001\"` |\n| ^ | `bitaro(3, 3, 2, 2, [1, 0, 0], [2, 2, 1], [-1, -1, 3], [2, 1], [0, 1], \"101001\")` | |\n| ^ | `answer([1])` | |\n| ^| `answer([1, 0])` | |\n\nThe shortest path from city 0 to city 1, is achieved either by traversing roads 1 and 0 in this order, or simply passing through road 2. Therefore, for the second call to the `answer` function in this sample, it is also acceptable to call `answer([2])`.\n\nThe file that can be downloaded from the contest site, `sample-01-in.txt`, corresponds to input example 1.\nThe files `sample-01-in.txt` and `sample-02-in.txt` included in the downloadable files from the contest site can be used as input for the sample grader.\n\n\n### Constraints\n\nAll input data satisfies the following conditions:\n\n* $2 \\le N \\le 10000$.\n* $1 \\le M \\le 20000$.\n* $1 \\le Q \\le 16$.\n* $1 \\le K \\le 300$.\n* $0 \\le A_i < B_i \\le N-1$ ($0 \\le i \\le M-1$).\n* $(A_i, B_i) \\ne (A_j, B_j)$ ($0 \\le i < j \\le M-1$).\n* $1 \\le C_i \\le 10^{12}$ ($0 \\le i \\le M-1$).\n* $1 \\le T_j \\le N-1$ ($0 \\le j \\le Q-1$).\n* $T_j \\ne T_k$ ($0 \\le j < k \\le Q-1$).\n* $0 \\le X_k \\le M-1$ ($0 \\le k \\le K-1$).\n* $X_k \\ne X_l$ ($0 \\le k < l \\le K-1$).\n* You can travel from any city to any other city by traversing some roads.\n* All input values are integers.\n\n### Grading\n\nIf your program is judged as any type of **Wrong Answer [1] - [6]** (see Implementation Details) or any type of runtime errors (TLE (Time Limit Exceeded), MLE (Memory Limit Exceeded), Abnormal End, etc.) in any of the test cases, your score is 0 points.\n\nOtherwise, the grading is based on the maximum length of the returned string $s$ from the function `aoi`, denoted as $L$, across all test cases for this task.\n\n* If $1561 \\le L \\le 12000$, the score is $\\left\\lfloor \\frac{100\\,000}{L-560} \\right\\rfloor$ points.\n* If $0 \\le L \\le 1560$, the score is 100 points.\n\nHere, $\\lfloor x \\rfloor$ represents the largest integer that is not greater than $x$.\n\n", "locale": "en"}, "zh-CN": {"title": "[JOIST 2024] 间谍 3 / Spy 3", "background": "在本题中，你需要将两个文件合并成一个文件提交。\n\n**不要引入任何头文件**，并在文件头加入如下的内容：\n\n```cpp\n#include <vector>\nvoid answer(const std::vector<int> &);\n```", "description": "\n\n Aoi 和 Bitaro 是 JOI 国 国家情报局的间谍。这次他们的任务是对 IOI 国 进行潜入调查。Bitaro 潜入 IOI 国，而 Aoi 在 JOI 国 向 Bitaro 发出指示。\n\n潜入前，Aoi 和 Bitaro 得到了 IOI 国 的一张地图。IOI 国 有 $N$ 个城市，编号为 $0$ 到 $N-1$。此外，IOI 国 有 $M$ 条道路，编号为 $0$ 到 $M-1$。第 $i$ 条道路（$0 \\le i \\le M-1$）双向连接城市 $A_i$ 和城市 $B_i$，长度为 $C_i$。通过若干条道路可以在任意两座城市之间往来。Bitaro 在 IOI 国 内通过这些道路在城市间移动。另外，共有 $Q$ 个调查计划。第 $j$ 个计划（$0 \\le j \\le Q-1$）要调查 IOI 国 的城市 $T_j$。\n\n以上信息最初同时告知了 Aoi 和 Bitaro。随后，Bitaro 开始潜入 IOI 国。\n\nBitaro 设法甩开了无数追兵，击败了刺客，最终成功潜入 IOI 国 的城市 $0$。然而，由于潜入行动极其艰难，Bitaro 遗失了关于 IOI 国 的部分信息。具体而言，Bitaro 丢失了 $K$ 条道路的长度信息，即道路 $X_0, X_1, \\dots, X_{K-1}$。换言之，Bitaro 已不知道 $C_{X_0}, C_{X_1}, \\dots, C_{X_{K-1}}$ 的数值。注意，尽管 Bitaro 丢失了这些信息，Aoi 仍然掌握它们。\n\nBitaro 立刻向 Aoi 报告了他所遗失的道路长度信息是哪些。\n\n为了完成任务，Bitaro 希望从城市 $0$ 出发，分别找到到每个被 $Q$ 个调查计划锁定的城市的最短路径。\n\nAoi 将向 Bitaro 发送一个只包含字符 ‘0’ 或 ‘1’ 的字符串以协助他。由于存在被截获的风险，Aoi 希望尽量减少发送的内容。\n\n给定关于 IOI 国 的信息、调查计划以及 Bitaro 所遗失信息的道路，请编写程序实现 Aoi 的发送策略；同时，编写程序实现 Bitaro 在其掌握的信息与 Aoi 发送的字符串下寻找最短路径的策略。\n\n### 实现细节\n\n你需要提交 $2$ 个文件。\n\n第一个文件为 `Aoi.cpp`。该文件用于实现 Aoi 的策略，并应实现以下函数。程序需通过预处理指令 `#include` 包含 `Aoi.h`。\n\n* `std::string aoi(int N, int M, int Q, int K, std::vector<int> A, std::vector<int> B, std::vector<long long> C, std::vector<int> T, std::vector<int> X)`\n\n此函数在每个测试用例中只被调用一次。\n* 参数 $N$ 是 IOI 国 中的城市数量。\n* 参数 $M$ 是 IOI 国 中的道路数量。\n* 参数 $Q$ 是调查计划的数量。\n* 参数 $K$ 是 Bitaro 遗失长度信息的道路条数。\n* 参数 $A, B, C$ 为长度为 $M$ 的数组。表示第 $i$ 条道路（$0 \\le i \\le M-1$）双向连接城市 $A[i]$ 与城市 $B[i]$，长度为 $C[i]$。\n* 参数 $T$ 为长度为 $Q$ 的数组。表示第 $j$ 个计划（$0 \\le j \\le Q-1$）要调查的城市为 $T[j]$。\n* 参数 $X$ 为长度为 $K$ 的数组。表示 Bitaro 遗失长度信息的道路为 $X[0], X[1], \\dots, X[K-1]$。\n* 返回值为 Aoi 向 Bitaro 发送的字符串 $s$。\n* 字符串 $s$ 的每个字符必须是 ‘0’ 或 ‘1’。若不满足此条件，你的程序将被判定为 **Wrong Answer [1]**。\n* 字符串 $s$ 的长度最多为 $12000$。若不满足此条件，你的程序将被判定为 **Wrong Answer [2]**。\n\n第二个文件为 `Bitaro.cpp`。该文件用于实现 Bitaro 的策略，并应实现以下函数。程序需通过预处理指令 `#include` 包含 `Bitaro.h`。\n\n* `void bitaro(int N, int M, int Q, int K, std::vector<int> A, std::vector<int> B, std::vector<long long> C, std::vector<int> T, std::vector<int> X, std::string s)`\n\n此函数会在 `aoi` 函数被调用之后且仅被调用一次。\n* 参数 $N$ 是 IOI 国 中的城市数量。\n* 参数 $M$ 是 IOI 国 中的道路数量。\n* 参数 $Q$ 是调查计划的数量。\n* 参数 $K$ 是 Bitaro 遗失长度信息的道路条数。\n* 参数 $A, B, C$ 为长度为 $M$ 的数组。表示第 $i$ 条道路（$0 \\le i \\le M-1$）双向连接城市 $A[i]$ 与城市 $B[i]$，长度为 $C[i]$。\n* 参数 $T$ 为长度为 $Q$ 的数组。表示第 $j$ 个计划（$0 \\le j \\le Q-1$）要调查的城市为 $T[j]$。\n* 参数 $X$ 为长度为 $K$ 的数组。表示 Bitaro 遗失长度信息的道路为 $X[0], X[1], \\dots, X[K-1]$。\n* 参数 $s$ 是一个每个字符均为 ‘0’ 或 ‘1’ 的字符串，表示 Aoi 发送给 Bitaro 的字符串。\n\n在 `Bitaro.cpp` 中，你的程序可以调用如下函数。\n\n```cpp\nvoid answer(const std::vector<int> &e)\n```\n\n* 在第 $(j+1)$ 次调用（$0 \\le j \\le Q-1$）该函数时，你需要回答从城市 $0$ 到第 $j$ 个调查计划目标城市 $T_j$ 的最短路径。\n* 参数 `e` 是一个数组，表示从城市 $0$ 到城市 $T_j$ 的最短路径所经过的道路序列。\n* 设数组 `e` 的长度为 $n$。元素 `e[0], e[1], \\ldots, e[n-1]` 是该最短路径上按行进顺序经过的道路的编号。\n* 若存在多条最短路径，任选其一作为答案即可。\n* 参数 `e` 的每个元素必须在 $0$ 到 $M-1$ 之间。若不满足此条件，你的程序将被判定为 **Wrong Answer [3]**。\n* 参数 `e` 所指示的道路序列必须构成一条从城市 $0$ 到城市 $T_j$ 的路径。更正式地，它必须满足以下条件。\n    * 存在一列数字 $u_0, u_1, \\ldots, u_n$ 使得\n        * $u_0 = 0$。\n        * $u_n = T_j$。\n        * 道路 $e[k]$（$0 \\le k \\le n-1$）连接城市 $u_k$ 与城市 $u_{k+1}$。\n    * 若不满足这些条件，你的程序将被判定为 **Wrong Answer [4]**。\n* 若参数 `e` 指示的道路序列并非所有从城市 $0$ 到城市 $T_j$ 的路径中长度最短的一条，你的程序将被判定为 **Wrong Answer [5]**。这里，路径长度定义为所用道路长度之和。\n* 函数 `answer` 必须被调用恰好 $Q$ 次。若在 `bitaro` 函数结束时，对 `answer` 的调用次数不等于 $Q$，你的程序将被判定为 **Wrong Answer [6]**。\n\n### 重要注意事项\n\n* 你的程序可以为内部使用实现其他函数，或使用全局变量。提交的文件将与评测程序一起编译，形成单个可执行文件。所有全局变量与内部函数应声明在未命名命名空间中，以避免与其他文件冲突。评测时会分别以 Aoi 进程与 Bitaro 进程运行。Aoi 进程与 Bitaro 进程不能共享全局变量。\n* 你的程序不得使用标准输入与标准输出。你的程序不得以任何方式与其他文件通信。但你可以向标准错误输出调试信息。\n\n### 编译与测试运行\n\n你可以从比赛网页下载包含样例评测器的压缩包，用于本地测试。压缩包中也包含你程序的样例源文件。\n\n样例评测器文件为 `grader.cpp`。为测试你的程序，请将 `grader.cpp`、`Aoi.cpp`、`Bitaro.cpp`、`Aoi.h`、`Bitaro.h` 放在同一目录下，并运行以下命令进行编译。你也可以运行压缩包内的 `compile.sh`。\n\n```bash\ng++ -std=gnu++20 -O2 -o grader grader.cpp Aoi.cpp Bitaro.cpp\n```\n\n当编译成功时，将生成可执行文件 `grader`。\n\n注意，实际评测器不同于样例评测器。样例评测器作为单进程执行，从标准输入读取数据，并向标准输出与标准错误输出写出结果。\n", "inputFormat": "\n样例评测器从标准输入读取如下数据。\n\n> $N$ $M$\\\n> $A_0$ $B_0$ $C_0$\\\n> $A_1$ $B_1$ $C_1$\\\n> $A_{M-1}$ $B_{M-1}$ $C_{M-1}$\\\n> $Q$\\\n> $T_0$ $T_1$ $\\cdots$ $T_{Q-1}$\\\n> $K$\\\n> $X_0$ $X_1$ $\\cdots$ $X_{K-1}$\n", "outputFormat": "\n样例评测器向标准输出与标准错误输出输出如下信息（引号仅为说明）。\n\n* 若你的程序被判为 **Wrong Answer [1], [2], [3], [4], 或 [6]**，样例评测器会在标准错误输出写出其类型，如 “Wrong Answer [1]”。标准输出不会输出任何内容。\n* 否则，`aoi` 函数返回的字符串 $s$ 的长度会以 “Accepted: 2024” 的格式输出到标准错误输出。此外，在第 $(j+1)$ 次（$0 \\le j \\le Q-1$）对 `answer` 的调用中，路径长度会输出到标准输出的第 $(j+1)$ 行。样例评测程序 **不会检查** 该路径是否最短。\n\n若你的程序同时满足多种 Wrong Answer 的条件，样例评测器仅报告其中一种。", "hint": "\n### 示例通信\n\n下面给出一个样例评测器的输入及相应的函数调用。\n\n| 样例输入 1 | 调用 | 返回值 |\n|---|---|---|\n| $$\\texttt{3 3}\\\\ \\texttt{1 2 1} \\\\ \\texttt{0 2 2} \\\\ \\texttt{0 1 3} \\\\ \\texttt{2} \\\\ \\texttt{2 1} \\\\ \\texttt{2} \\\\ \\texttt{0 1}$$ | `aoi(3, 3, 2, 2, [1, 0, 0], [2, 2, 1], [1, 2, 3], [2, 1], [0, 1])` |  |\n| ^ | | `\"101001\"` |\n| ^ | `bitaro(3, 3, 2, 2, [1, 0, 0], [2, 2, 1], [-1, -1, 3], [2, 1], [0, 1], \"101001\")` | |\n| ^ | `answer([1])` | |\n| ^ | `answer([1, 0])` | |\n\n从城市 $0$ 到城市 $1$ 的最短路径，可以按顺序经过道路 $1$ 和 $0$，或者仅经过道路 $2$。因此，在本样例的第二次对 `answer` 的调用中，调用 `answer([2])` 也是可以接受的。\n\n从比赛网站下载的文件 `sample-01-in.txt` 与输入样例 $1$ 相对应。压缩包中的 `sample-01-in.txt` 与 `sample-02-in.txt` 可作为样例评测器的输入。\n\n### 约束\n\n所有输入数据均满足以下条件：\n\n* $2 \\le N \\le 10000$。\n* $1 \\le M \\le 20000$。\n* $1 \\le Q \\le 16$。\n* $1 \\le K \\le 300$。\n* $0 \\le A_i < B_i \\le N-1$（$0 \\le i \\le M-1$）。\n* $(A_i, B_i) \\ne (A_j, B_j)$（$0 \\le i < j \\le M-1$）。\n* $1 \\le C_i \\le 10^{12}$（$0 \\le i \\le M-1$）。\n* $1 \\le T_j \\le N-1$（$0 \\le j \\le Q-1$）。\n* $T_j \\ne T_k$（$0 \\le j < k \\le Q-1$）。\n* $0 \\le X_k \\le M-1$（$0 \\le k \\le K-1$）。\n* $X_k \\ne X_l$（$0 \\le k < l \\le K-1$）。\n* 通过若干条道路可以在任意两座城市之间往来。\n* 所有输入值均为整数。\n\n### 评分\n\n若你的程序在任意测试用例中被判定为 **Wrong Answer [1] - [6]**（见实现细节）或出现任意类型的运行时错误（TLE、MLE、异常结束等），你的得分为 $0$ 分。\n\n否则，评分依据为在本题所有测试用例中，函数 `aoi` 返回的字符串 $s$ 的最大长度 $L$。\n\n* 若 $1561 \\le L \\le 12000$，得分为 $\\left\\lfloor \\dfrac{100\\,000}{L-560} \\right\\rfloor$。\n* 若 $0 \\le L \\le 1560$，得分为 $100$ 分。\n\n其中，$\\lfloor x \\rfloor$ 表示不超过 $x$ 的最大整数。\n\n", "locale": "zh-CN"}}}
{"pid": "P10435", "type": "P", "difficulty": 7, "samples": [["2\n1 2 6 3\n2 5\n4 3", "2"], ["9\n1 2 3 4 5 6 7 8 9 18 17 16 15 14 13 12 11 10\n2 7 4 1 7 6 4 10 6\n6 8 9 3 7 1 9 5 4\n", "8"], ["7\n13 16 18 18 21 22 22 23 23 21 19 17 15 14\n14 14 20 19 22 17 25\n24 15 18 25 24 19 11", "3"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] 有趣的家庭菜园 5 / Growing Vegetables is Fun 5", "background": "", "description": "Bitaro，一个多年来一直热衷于园艺的人，计划从今年春天开始种植一种名为 Bita-radish 的植物。 \n\nBitaro 已经准备好了 $2N$ 个 Bita-radish 幼苗。这些幼苗从 $1$ 到 $2N$ 编号，Bitaro 计划按照这个顺序进行栽培。第 $i$ 个幼苗（$1 \\leq i \\leq 2N$）的大小为 $A_i$。Bitaro 希望每个幼苗都能得到足够的阳光，因此幼苗的大小满足以下条件：\n\n- $A_1 \\leq A_2 \\leq \\cdots \\leq A_N \\leq A_{N+1}$. \n- $A_{N+1} \\geq A_{N+2} \\geq \\cdots \\geq A_{2N-1} \\geq A_{2N} \\geq A_1$. \n\n注意，幼苗 $1$ 最小，幼苗 $N+1$ 最大。\n\nBitaro 还准备了 $N$ 个红色花盆和 $N$ 个蓝色花盆，每个花盆也有一定大小。第 $j$ 个（$1 \\leq j \\leq N$）红色花盆的大小是 $B_j$，第 $k$ 个（$1 \\leq k \\leq N$）蓝色花盆的大小是 $C_k$。Bitaro 在这总共 $2N$ 个花盆中各种植一株 Bita-radish 幼苗，并按某种顺序排列花盆，使幼苗按 $1,2,...,2N$ 顺序依次放入花盆中。\n\n考虑到外观，这 $2N$ 个花盆必须被安排在一个美观的顺序中。这里，美观的顺序意味着花盆的排列使得存在连续的 $N$ 个花盆颜色相同。更确切地说，一个花盆排列被称为是美观的，当且仅当存在一个整数 $l$，满足 $1 \\leq l \\leq N+1$，使得种植了幼苗 $l, l+1, \\ldots, l+N-1$ 的花盆颜色都相同。\n\n当尺寸为 $y$ 的幼苗种植在尺寸为 $x$ 的花盆中时，该对的栽培难度是绝对值 $|x-y|$。Bitaro 种植 Bita-radish 的工作量是 $2N$ 对花盆和幼苗中的**最大**栽培难度。编写一个程序，给定 Bita-radish 幼苗和花盆的信息，找到种植幼苗的最小可能 Bitaro 工作量值，并且花盆需要按美观的顺序排列。", "inputFormat": "从标准输入中读取以下数据：\n\n- $N$\n- $A_1$ $A_2$ ... $A_{2N}$\n- $B_1$ $B_2$ ... $B_N$\n- $C_1$ $C_2$ ... $C_N$", "outputFormat": "输出一个值，种植幼苗以使花盆按美观顺序排列时 Bitaro 工作量的最小可能值。\n", "hint": "#### 样例解释 1\n\n在这个样例输入中，Bitaro 可以通过以下方式种植幼苗来实现工作量为 $2$：\n\n- 将幼苗 $1$ 种植在第一个红色花盆中。这对的栽培难度是 $|2 - 1| = 1$。\n- 将幼苗 $2$ 种植在第二个蓝色花盆中。这对的栽培难度是 $|3 - 2| = 1$。\n- 将幼苗 $3$ 种植在第一个蓝色花盆中。这对的栽培难度是 $|4 - 6| = 2$。\n- 将幼苗 $4$ 种植在第二个红色花盆中。这对的栽培难度是 $|5 - 3| = 2$。\n\n种植了幼苗 $2$ 和 $3$ 的花盆的颜色都是蓝色，因此花盆是按美观顺序排列的。\n\n当种植幼苗以使花盆按美观顺序排列时，无法实现工作量小于 $2$。因此，输出为 $2$。\n\n这个样例输入满足所有子任务的约束条件。\n\n\n#### 样例解释 2\n\n这个样例输入满足子任务 $2,3,4,5$ 的约束条件。\n\n#### 样例解释 3\n\n这个样例输入满足子任务 $2,3,5$ 的约束条件。\n\n### 约束条件\n\n- $1 \\leq N \\leq 300,000$.\n- $1 \\leq A_i \\leq 10^9$ （$1 \\leq i \\leq 2N$）.\n- $1 \\leq B_j \\leq 10^9$ （$1 \\leq j \\leq N$）.\n- $1 \\leq C_k \\leq 10^9$ （$1 \\leq k \\leq N$）.\n- $A_1 \\leq A_2 \\leq \\cdots \\leq A_N \\leq A_{N+1}$.\n- $A_{N+1} \\geq A_{N+2} \\geq \\cdots \\geq A_{2N-1} \\geq A_{2N} \\geq A_1$.\n- 所有输入值都是整数。\n\n### 子任务\n\n1. (4 分) $N \\leq 5$。\n2. (5 分) $N \\leq 10$。\n3. (21 分) $N \\leq 2,000$。\n4. (37 分) 所有的 $A_i$ 的值都是不同的。另外，满足 $A_N < A_{2N}$。\n5. (33 分) 没有额外的约束条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2024] 有趣的家庭菜园 5 / Growing Vegetables is Fun 5", "background": "", "description": "Bitaro，一个多年来一直热衷于园艺的人，计划从今年春天开始种植一种名为 Bita-radish 的植物。 \n\nBitaro 已经准备好了 $2N$ 个 Bita-radish 幼苗。这些幼苗从 $1$ 到 $2N$ 编号，Bitaro 计划按照这个顺序进行栽培。第 $i$ 个幼苗（$1 \\leq i \\leq 2N$）的大小为 $A_i$。Bitaro 希望每个幼苗都能得到足够的阳光，因此幼苗的大小满足以下条件：\n\n- $A_1 \\leq A_2 \\leq \\cdots \\leq A_N \\leq A_{N+1}$. \n- $A_{N+1} \\geq A_{N+2} \\geq \\cdots \\geq A_{2N-1} \\geq A_{2N} \\geq A_1$. \n\n注意，幼苗 $1$ 最小，幼苗 $N+1$ 最大。\n\nBitaro 还准备了 $N$ 个红色花盆和 $N$ 个蓝色花盆，每个花盆也有一定大小。第 $j$ 个（$1 \\leq j \\leq N$）红色花盆的大小是 $B_j$，第 $k$ 个（$1 \\leq k \\leq N$）蓝色花盆的大小是 $C_k$。Bitaro 在这总共 $2N$ 个花盆中各种植一株 Bita-radish 幼苗，并按某种顺序排列花盆，使幼苗按 $1,2,...,2N$ 顺序依次放入花盆中。\n\n考虑到外观，这 $2N$ 个花盆必须被安排在一个美观的顺序中。这里，美观的顺序意味着花盆的排列使得存在连续的 $N$ 个花盆颜色相同。更确切地说，一个花盆排列被称为是美观的，当且仅当存在一个整数 $l$，满足 $1 \\leq l \\leq N+1$，使得种植了幼苗 $l, l+1, \\ldots, l+N-1$ 的花盆颜色都相同。\n\n当尺寸为 $y$ 的幼苗种植在尺寸为 $x$ 的花盆中时，该对的栽培难度是绝对值 $|x-y|$。Bitaro 种植 Bita-radish 的工作量是 $2N$ 对花盆和幼苗中的**最大**栽培难度。编写一个程序，给定 Bita-radish 幼苗和花盆的信息，找到种植幼苗的最小可能 Bitaro 工作量值，并且花盆需要按美观的顺序排列。", "inputFormat": "从标准输入中读取以下数据：\n\n- $N$\n- $A_1$ $A_2$ ... $A_{2N}$\n- $B_1$ $B_2$ ... $B_N$\n- $C_1$ $C_2$ ... $C_N$", "outputFormat": "输出一个值，种植幼苗以使花盆按美观顺序排列时 Bitaro 工作量的最小可能值。\n", "hint": "#### 样例解释 1\n\n在这个样例输入中，Bitaro 可以通过以下方式种植幼苗来实现工作量为 $2$：\n\n- 将幼苗 $1$ 种植在第一个红色花盆中。这对的栽培难度是 $|2 - 1| = 1$。\n- 将幼苗 $2$ 种植在第二个蓝色花盆中。这对的栽培难度是 $|3 - 2| = 1$。\n- 将幼苗 $3$ 种植在第一个蓝色花盆中。这对的栽培难度是 $|4 - 6| = 2$。\n- 将幼苗 $4$ 种植在第二个红色花盆中。这对的栽培难度是 $|5 - 3| = 2$。\n\n种植了幼苗 $2$ 和 $3$ 的花盆的颜色都是蓝色，因此花盆是按美观顺序排列的。\n\n当种植幼苗以使花盆按美观顺序排列时，无法实现工作量小于 $2$。因此，输出为 $2$。\n\n这个样例输入满足所有子任务的约束条件。\n\n\n#### 样例解释 2\n\n这个样例输入满足子任务 $2,3,4,5$ 的约束条件。\n\n#### 样例解释 3\n\n这个样例输入满足子任务 $2,3,5$ 的约束条件。\n\n### 约束条件\n\n- $1 \\leq N \\leq 300,000$.\n- $1 \\leq A_i \\leq 10^9$ （$1 \\leq i \\leq 2N$）.\n- $1 \\leq B_j \\leq 10^9$ （$1 \\leq j \\leq N$）.\n- $1 \\leq C_k \\leq 10^9$ （$1 \\leq k \\leq N$）.\n- $A_1 \\leq A_2 \\leq \\cdots \\leq A_N \\leq A_{N+1}$.\n- $A_{N+1} \\geq A_{N+2} \\geq \\cdots \\geq A_{2N-1} \\geq A_{2N} \\geq A_1$.\n- 所有输入值都是整数。\n\n### 子任务\n\n1. (4 分) $N \\leq 5$。\n2. (5 分) $N \\leq 10$。\n3. (21 分) $N \\leq 2,000$。\n4. (37 分) 所有的 $A_i$ 的值都是不同的。另外，满足 $A_N < A_{2N}$。\n5. (33 分) 没有额外的约束条件。", "locale": "zh-CN"}}}
{"pid": "P10436", "type": "P", "difficulty": 7, "samples": [["5 3\n1 3\n2 2\n4 4\n1 3\n1 1\n2 3\n2 1\n4 4", "1 3"], ["2 2\n1 1\n2 2\n1 2\n2 1\n", ""], ["8 8\n5 2\n4 4\n1 3\n7 8\n3 1\n8 7\n6 5\n2 6\n1 4\n7 2\n8 8\n3 1\n5 6\n2 7\n6 3\n2 5", "3 4 5 8"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] 卡牌收集 / Card Collection", "background": "", "description": "JOI 君对一款卡牌游戏中的卡牌收集充满热情。卡牌游戏中的每张卡牌都有两个整数，代表其强度和成本。为了获得一张新卡牌，JOI 君将 $N$ 张卡牌带到一个卡牌交换处。每张卡牌编号从 $1$ 到 $N$。第 $i$ 张卡牌（$1 \\leq i \\leq N$）的强度是 $S_i$，成本是 $V_i$。\n\n卡牌交换处有两台机器可供使用。如果你将两张卡牌 $A$ 和 $B$ 插入其中一台机器，你将能够获得满足以下条件的卡牌 $C$：\n\n- 如果你使用第一台机器，那么 $C$ 的强度等于 $A$ 和 $B$ 的强度中的最大值，并且 $C$ 的成本等于 $A$ 和 $B$ 的成本中的最大值。\n- 如果你使用第二台机器，那么 $C$ 的强度等于 $A$ 和 $B$ 的强度中的最小值，并且 $C$ 的成本等于 $A$ 和 $B$ 的成本中的最小值。\n\nJOI 君计划使用这些机器正好 $N - 1$ 次以获得一张新卡牌。为此，他将 $N$ 张卡牌按卡牌 $1$ 到卡牌 $N$ 的顺序依次排列。然后，他重复以下操作 $N - 1$ 次：\n\n- 选择两张相邻的卡牌，使用其中一台机器来得到一张新卡牌，并将新卡牌放在操作前所选两张卡牌的位置。\n\n在执行 $N-1$ 次操作后，JOI 君将只剩下一张卡牌。这张卡牌的强度和成本将取决于他执行的操作。\n\nJOI 君有一个希望在执行 $N-1$ 次操作后获得的卡牌列表。第 $j$ 张卡牌（$1 \\leq j \\leq M$）由一对整数 $(T_j, W_j)$ 表示，其中 $T_j$ 是第 $j$ 张卡牌的强度，$W_j$ 是第 $j$ 张卡牌的成本。编写一个程序，给定有关 JOI 君卡牌的信息以及他想获得的卡牌列表，确定在执行 $N-1$ 次操作后他可以获得的列表中的哪些卡牌。\n", "inputFormat": "从标准输入读取以下数据。\n\n- $N$ $M$\n- $S_1$ $V_1$\n- $S_2$ $V_2$\n- ...\n- $S_N$ $V_N$\n- $T_1$ $W_1$\n- $T_2$ $W_2$\n- ...\n- $T_M$ $W_M$", "outputFormat": "向标准输出写入一行，输出应按升序包含 JOI 君可以在执行 $N-1$ 次操作后获得的列表中所有卡牌的编号。\n", "hint": "#### 样例解释 1\n\n例如，JOI 君可以通过以下方式获得一张强度为 2，成本为 3 的卡牌：\n\n- 交出卡牌 4 和卡牌 5，获得一张强度为 1，成本为 1 的卡牌。\n- 交出卡牌 3 和第一次操作中获得的卡牌，获得一张强度为 1，成本为 1 的卡牌。\n- 交出卡牌 1 和卡牌 2，获得一张强度为 2，成本为 3 的卡牌。\n- 交出第二次和第三次操作中获得的卡牌，获得一张强度为 2，成本为 3 的卡牌。\n\n请注意，即使在第三次操作中获得了一张强度为 2，成本为 3 的卡牌，JOI 君仍需要执行最后一次操作。即使在某些操作后获得了某张卡牌，也可能在执行 $N-1$ 次操作后无法获得它。\n\n这个样例输入满足所有子任务的约束条件。\n\n#### 样例解释 2\n\n与此样例输出一样，如果在执行 $N-1$ 次操作后无法获得列表中的任何卡牌，则应输出一个空行。\n\n这个样例输入满足所有子任务的约束条件。\n\n#### 样例解释 3\n\n这个样例输入满足所有子任务的约束条件。\n\n\n### 约束条件\n\n- $2 \\leq N \\leq 200,000$．\n- $1 \\leq M \\leq 200,000$．\n- $1 \\leq S_i \\leq 10^9$ ($1 \\leq i \\leq N$)．\n- $1 \\leq V_i \\leq 10^9$ ($1 \\leq i \\leq N$)．\n- $1 \\leq T_j \\leq 10^9$ ($1 \\leq j \\leq M$)．\n- $1 \\leq W_j \\leq 10^9$ ($1 \\leq j \\leq M$)．\n- 给定的值均为整数。\n\n### 子任务\n\n1. (11 分) $N \\leq 20$，$M \\leq 10$．\n2. (38 分) $N \\leq 2,000$，$M \\leq 10$．\n3. (22 分) $M \\leq 10$．\n4. (29 分) 无额外约束。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2024] 卡牌收集 / Card Collection", "background": "", "description": "JOI 君对一款卡牌游戏中的卡牌收集充满热情。卡牌游戏中的每张卡牌都有两个整数，代表其强度和成本。为了获得一张新卡牌，JOI 君将 $N$ 张卡牌带到一个卡牌交换处。每张卡牌编号从 $1$ 到 $N$。第 $i$ 张卡牌（$1 \\leq i \\leq N$）的强度是 $S_i$，成本是 $V_i$。\n\n卡牌交换处有两台机器可供使用。如果你将两张卡牌 $A$ 和 $B$ 插入其中一台机器，你将能够获得满足以下条件的卡牌 $C$：\n\n- 如果你使用第一台机器，那么 $C$ 的强度等于 $A$ 和 $B$ 的强度中的最大值，并且 $C$ 的成本等于 $A$ 和 $B$ 的成本中的最大值。\n- 如果你使用第二台机器，那么 $C$ 的强度等于 $A$ 和 $B$ 的强度中的最小值，并且 $C$ 的成本等于 $A$ 和 $B$ 的成本中的最小值。\n\nJOI 君计划使用这些机器正好 $N - 1$ 次以获得一张新卡牌。为此，他将 $N$ 张卡牌按卡牌 $1$ 到卡牌 $N$ 的顺序依次排列。然后，他重复以下操作 $N - 1$ 次：\n\n- 选择两张相邻的卡牌，使用其中一台机器来得到一张新卡牌，并将新卡牌放在操作前所选两张卡牌的位置。\n\n在执行 $N-1$ 次操作后，JOI 君将只剩下一张卡牌。这张卡牌的强度和成本将取决于他执行的操作。\n\nJOI 君有一个希望在执行 $N-1$ 次操作后获得的卡牌列表。第 $j$ 张卡牌（$1 \\leq j \\leq M$）由一对整数 $(T_j, W_j)$ 表示，其中 $T_j$ 是第 $j$ 张卡牌的强度，$W_j$ 是第 $j$ 张卡牌的成本。编写一个程序，给定有关 JOI 君卡牌的信息以及他想获得的卡牌列表，确定在执行 $N-1$ 次操作后他可以获得的列表中的哪些卡牌。\n", "inputFormat": "从标准输入读取以下数据。\n\n- $N$ $M$\n- $S_1$ $V_1$\n- $S_2$ $V_2$\n- ...\n- $S_N$ $V_N$\n- $T_1$ $W_1$\n- $T_2$ $W_2$\n- ...\n- $T_M$ $W_M$", "outputFormat": "向标准输出写入一行，输出应按升序包含 JOI 君可以在执行 $N-1$ 次操作后获得的列表中所有卡牌的编号。\n", "hint": "#### 样例解释 1\n\n例如，JOI 君可以通过以下方式获得一张强度为 2，成本为 3 的卡牌：\n\n- 交出卡牌 4 和卡牌 5，获得一张强度为 1，成本为 1 的卡牌。\n- 交出卡牌 3 和第一次操作中获得的卡牌，获得一张强度为 1，成本为 1 的卡牌。\n- 交出卡牌 1 和卡牌 2，获得一张强度为 2，成本为 3 的卡牌。\n- 交出第二次和第三次操作中获得的卡牌，获得一张强度为 2，成本为 3 的卡牌。\n\n请注意，即使在第三次操作中获得了一张强度为 2，成本为 3 的卡牌，JOI 君仍需要执行最后一次操作。即使在某些操作后获得了某张卡牌，也可能在执行 $N-1$ 次操作后无法获得它。\n\n这个样例输入满足所有子任务的约束条件。\n\n#### 样例解释 2\n\n与此样例输出一样，如果在执行 $N-1$ 次操作后无法获得列表中的任何卡牌，则应输出一个空行。\n\n这个样例输入满足所有子任务的约束条件。\n\n#### 样例解释 3\n\n这个样例输入满足所有子任务的约束条件。\n\n\n### 约束条件\n\n- $2 \\leq N \\leq 200,000$．\n- $1 \\leq M \\leq 200,000$．\n- $1 \\leq S_i \\leq 10^9$ ($1 \\leq i \\leq N$)．\n- $1 \\leq V_i \\leq 10^9$ ($1 \\leq i \\leq N$)．\n- $1 \\leq T_j \\leq 10^9$ ($1 \\leq j \\leq M$)．\n- $1 \\leq W_j \\leq 10^9$ ($1 \\leq j \\leq M$)．\n- 给定的值均为整数。\n\n### 子任务\n\n1. (11 分) $N \\leq 20$，$M \\leq 10$．\n2. (38 分) $N \\leq 2,000$，$M \\leq 10$．\n3. (22 分) $M \\leq 10$．\n4. (29 分) 无额外约束。", "locale": "zh-CN"}}}
{"pid": "P10437", "type": "P", "difficulty": 6, "samples": [["3\n0 1 2\n0 1\n1 2\n0", "1"], ["3\n0 1 2\n0 1\n1 2\n2\n2 0\n0 2", "1\n0\n1"], ["7\n1 0 2 2 0 1 0\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n7\n0 0\n1 1\n2 0\n3 0\n4 2\n5 2\n6 2", "3\n0\n4\n4\n0\n4\n5\n5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "2024", "交互题", "O2优化", "树链剖分", "动态 DP", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] JOI 之旅 / JOI Tour", "background": "提交时请不要引用 `joitour.h`。\n\n请不要使用 C++14 (GCC 9) 提交。", "description": "在 IOI 国，有 $N$ 个城市，编号为 $0$ 到 $N-1$，有 $N-1$ 条道路，编号为 $0$ 到 $N-2$。路 $j\\ (0\\le j\\le N-2)$ 双向连接城市 $U_j$ 和城市 $V_j$。你可以通过道路从一个城市到达另一其他城市。\n\nIOI 国的每个城市都有一家餐厅。在城市 $i\\ (0\\le i\\le N-1)$ 的餐厅类型用 $F_i$ 表示，具体来说：\n\n- $F_i=0$：果汁店\n- $F_i=1$：日式煎蛋卷店\n- $F_i=2$：冰淇淋店\n\n理惠女士是 IOI 国的导游，她正在规划一个叫做 **JOI 之旅**的观光计划。JOI 之旅中计划按如下顺序前往 $3$ 种餐厅：\n\n1. 选择有果汁店的城市 $i_0\\ (0\\le i_0\\le N-1)$，并从城市 $i_0$ 开始旅行。\n2. 前往城市 $i_0$ 的果汁店。\n3. 选择有日式煎蛋卷店的城市 $i_1\\ (0\\le i_1\\le N-1)$，并从城市 $i_0$ 出发乘公交车沿最短路径前往城市 $i_1$。\n4. 前往城市 $i_1$ 的日式煎蛋卷店。\n5. 选择有冰淇淋店的城市 $i_2\\ (0\\le i_2\\le N-1)$，并从城市 $i_1$ 出发乘公交车沿最短路径前往城市 $i_2$​。\n6. 前往城市 $i_2$​ 的冰淇淋店。\n7. 在城市 $i_2$ 结束行程。\n\n为了避免游客无聊，理惠女士决定选择三个城市 $i_0,i_1,i_2$ 满足它们不会经过相同的道路两次。我们称这样的 JOI 之旅是好的。为了帮助她找到理想的旅行计划，你被要求计算好的 JOI 之旅的数量。换句话说，你需要找到满足所有如下条件的三元组 $(i_0,i_1,i_2)$ 的个数：\n\n- 城市 $i_0$ 中的餐厅是果汁店。\n- 城市 $i_1$ 中的餐厅是日式煎蛋卷店。\n- 城市 $i_2$ 中的餐厅是冰淇淋店。\n- 当我们沿最短路径从城市 $i_0$ 移动到 $i_1$ 再移动到 $i_2$ 的过程中，不会经过相同的道路两次。\n\n在 IOI 国，会有 $Q$ 次餐厅类型改变的事件。当第 $(k+1)\\ (0\\le k\\le Q-1)$ 个事件发生时，会给出两个整数 $X_k$ 和 $Y_k$，满足 $0\\le X_k\\le N-1$ 且 $0\\le Y_k\\le 2$。然后，在城市 $X_k$ 的餐厅类型会变为 $Y_k$。也就是说，当 $Y_k=0,1,2$ 时，餐厅类型会分别变为果汁店，日式煎蛋卷店和冰淇淋店。在每个事件过后，你应该立即计算最新的好的 JOI 之旅的数量并告诉理惠女士。\n\n给定道路和餐厅信息，在每次类型改变事件发生之后计算好的 JOI 之旅的数量。\n\n### 实现细节\n\n你需要实现如下函数。\n\n- `void init(int N, std::vector<int> F, std::vector<int> U, std::vector<int> V, int Q)`\n  - 使用此函数给出道路和餐厅信息。\n  - 这个函数仅在程序开始时调用一次。\n  - 参数 `N` 是城市个数 $N$。\n  - 参数 `F` 是长为 $N$ 的数组。`F[i]` （$0\\le i\\le N-1$）表示城市 $i$ 中餐厅的类别，也就是 $F_i$。\n  - 参数 `U` 和 `V` 是长为 $N-1$ 的数组。`U[j]` 和 `V[j]`（$0\\le j\\le N-2$）是被路 $j$ 连接的两个城市 $U_j$ 和 $V_j$。\n  - 参数 `Q` 是餐厅类型改变事件的个数 $Q$。\n- `void change(int X, int Y)`\n  - 使用此函数给出餐厅类型改变事件。\n  - 这个函数被调用 $Q$ 次。\n  - 第 $(k+1)\\ (0\\le k\\le Q-1)$ 次调用中，参数 `X` 是餐厅类型改变发生的城市编号，也就是 $X_k$。\n  - 第 $(k+1)\\ (0\\le k\\le Q-1)$ 次调用中，参数 `Y` 是餐厅的新类型，也就是 $Y_k$。保证新类型与原类型不同。\n- `long long num_tours()`\n  - 这个函数在如下场景被调用，共 $Q+1$ 次。\n    - 在执行完函数 `init` 后。\n    - 在执行完函数 `change` 后。\n  - 这个函数应返回最新的好 JOI 之旅数。", "inputFormat": "**以下为下发 grader 的输入格式，你不应该从标准输入中读入任何信息。**\n\n第一行一个整数 $N$。\n\n第二行 $N$ 个整数 $F_0,\\ldots,F_{N-1}$。\n\n接下来 $N-1$ 行，每行两个整数 $U_j,V_j$。\n\n接下来一行一个整数 $Q$。\n\n接下来 $Q$ 行，每行两个整数 $X_k,Y_k$。", "outputFormat": "**以下为下发 grader 的输出格式，你不应该向标准输出中打印任何信息。**\n\n下发 grader 会在每次调用 `num_tours` 函数后输出一行一个整数，表示这个函数的返回值。", "hint": "#### 样例解释 1\n\n|                函数调用                 | 返回值 |\n| :-------------------------------------: | :----: |\n| `init(3, [0, 1, 2], [0, 1], [1, 2], 0)` |        |\n|              `num_tours()`              |  $1$   |\n\n只有一个好的 JOI 之旅，表示为 $(i_0,i_1,i_2)=(0,1,2)$。下面是对于它满足是好的 JOI 之旅条件的解释。\n\n- $F_0=0$，在城市 $0$ 的餐厅是果汁店。\n- $F_1=1$，在城市 $1$ 的餐厅是日式煎蛋卷店。\n- $F_2=2$，在城市 $2$ 的餐厅是冰淇淋店。\n- 当我们沿最短路径从城市 $0$ 移动到 $1$，然后从 $1$ 移动到 $2$ 时，我们没有经过相同的道路两次。\n\n因此，第一次 `num_tours()` 函数的调用返回值为 $1$。\n\n该样例满足子任务 $1,2,3,4,6,7$ 的限制。\n\n#### 样例解释 2\n\n|                函数调用                 | 返回值 |\n| :-------------------------------------: | :----: |\n| `init(3, [0, 1, 2], [0, 1], [1, 2], 2)` |        |\n|              `num_tours()`              |  $1$   |\n|             `change(2, 0)`              |        |\n|              `num_tours()`              |  $0$   |\n|             `change(0, 2)`              |        |\n|              `num_tours()`              |  $1$   |\n\n最初有一个好的 JOI 之旅，表示为 $(i_0,i_1,i_2)=(0,1,2)$。因此，第一次 `num_tours()` 函数的调用返回值为 $1$。\n\n在第一个事件中，在城市 $2$ 的餐厅从冰淇淋店变成了果汁店。在这次变化后，冰淇淋店从 IOI 国消失了，好的 JOI 之旅也没有了。因此，第二次 `num_tours()` 函数的调用返回值为 $0$。\n\n在第二个事件中，在城市 $0$ 的餐厅从果汁店变成了冰淇淋店。在这次变化后，有一个好的 JOI 之旅，表示为 $(i_0,i_1,i_2)=(2,1,0)$。因此，第三次 `num_tours()` 函数的调用返回值为 $1$。\n\n该样例满足子任务 $1,2,4,6,7$ 的限制。\n\n#### 样例解释 3\n\n这组样例满足子任务 $1,2,5,6,7$ 的限制。\n\n### 重要提示\n\n- 你的程序可以实现其它函数供内部使用，或者使用全局变量。\n- 你的程序禁止使用标准输入输出。你的程序禁止与其他文件通过任何方式交互。然而，你的程序可以使用标准错误输出输出调试信息。\n\n### 编译和测试运行\n\n你可以在「文件 - 附加文件」中下载样例交互器来测试你的程序。附加文件中还包含一个样例程序。\n\n样例交互器是文件 `grader.cpp`。为了测试你的程序，请将 `grader.cpp`，`joitour.cpp` 和 `joitour.h` 放在同一目录下，并且执行如下命令编译程序。此外你也可以运行 `compile.sh` 来编译你的程序。\n\n```bash\ng++ -std=gnu++20 -O2 -o grader grader.cpp joitour.cpp\n```\n\n当编译成功时，会生成可执行文件 `grader`。\n\n注意测评时使用的交互器与样例交互器不同。样例交互器会以单进程的形式执行，它会从标准输入中读入数据，输出结果到标准输出。\n\n### 约束条件\n\n- $3\\le N\\le 2\\times 10^5$。\n- $0\\le F_i\\le 2\\ (0\\le i\\le N-1)$。\n- $0\\le U_j<V_j\\le N-1\\ (0\\le j\\le N-2)$。\n- 可以通过道路从一个城市前往任意其他城市。\n- $0\\le Q\\le 5\\times 10^4$。\n- $0\\le X_k\\le N-1\\ (0\\le k\\le Q-1)$。\n- $0\\le Y_k\\le 2\\ (0\\le k\\le Q-1)$。\n- 对于每次调用函数 `change`，新类型不同于原类型。\n\n### 子任务\n\n- （6 分）$N\\le 400$，$Q\\le 100$。\n- （8 分）$N\\le 4\\,000$，$Q\\le 1\\,000$。\n- （6 分）$Q=0$。\n- （16 分）$U_j=j,V_j=j+1\\ (0\\le j\\le N-2)$。\n- （16 分）$U_j=\\lfloor\\frac{j}{2}\\rfloor,V_j=j+1\\ (0\\le j\\le N-2)$。\n- （34 分）$N\\le 10^5$，$Q\\le 2.5\\times 10^4$。\n- （14 分）无额外约束。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2024] JOI 之旅 / JOI Tour", "background": "提交时请不要引用 `joitour.h`。\n\n请不要使用 C++14 (GCC 9) 提交。", "description": "在 IOI 国，有 $N$ 个城市，编号为 $0$ 到 $N-1$，有 $N-1$ 条道路，编号为 $0$ 到 $N-2$。路 $j\\ (0\\le j\\le N-2)$ 双向连接城市 $U_j$ 和城市 $V_j$。你可以通过道路从一个城市到达另一其他城市。\n\nIOI 国的每个城市都有一家餐厅。在城市 $i\\ (0\\le i\\le N-1)$ 的餐厅类型用 $F_i$ 表示，具体来说：\n\n- $F_i=0$：果汁店\n- $F_i=1$：日式煎蛋卷店\n- $F_i=2$：冰淇淋店\n\n理惠女士是 IOI 国的导游，她正在规划一个叫做 **JOI 之旅**的观光计划。JOI 之旅中计划按如下顺序前往 $3$ 种餐厅：\n\n1. 选择有果汁店的城市 $i_0\\ (0\\le i_0\\le N-1)$，并从城市 $i_0$ 开始旅行。\n2. 前往城市 $i_0$ 的果汁店。\n3. 选择有日式煎蛋卷店的城市 $i_1\\ (0\\le i_1\\le N-1)$，并从城市 $i_0$ 出发乘公交车沿最短路径前往城市 $i_1$。\n4. 前往城市 $i_1$ 的日式煎蛋卷店。\n5. 选择有冰淇淋店的城市 $i_2\\ (0\\le i_2\\le N-1)$，并从城市 $i_1$ 出发乘公交车沿最短路径前往城市 $i_2$​。\n6. 前往城市 $i_2$​ 的冰淇淋店。\n7. 在城市 $i_2$ 结束行程。\n\n为了避免游客无聊，理惠女士决定选择三个城市 $i_0,i_1,i_2$ 满足它们不会经过相同的道路两次。我们称这样的 JOI 之旅是好的。为了帮助她找到理想的旅行计划，你被要求计算好的 JOI 之旅的数量。换句话说，你需要找到满足所有如下条件的三元组 $(i_0,i_1,i_2)$ 的个数：\n\n- 城市 $i_0$ 中的餐厅是果汁店。\n- 城市 $i_1$ 中的餐厅是日式煎蛋卷店。\n- 城市 $i_2$ 中的餐厅是冰淇淋店。\n- 当我们沿最短路径从城市 $i_0$ 移动到 $i_1$ 再移动到 $i_2$ 的过程中，不会经过相同的道路两次。\n\n在 IOI 国，会有 $Q$ 次餐厅类型改变的事件。当第 $(k+1)\\ (0\\le k\\le Q-1)$ 个事件发生时，会给出两个整数 $X_k$ 和 $Y_k$，满足 $0\\le X_k\\le N-1$ 且 $0\\le Y_k\\le 2$。然后，在城市 $X_k$ 的餐厅类型会变为 $Y_k$。也就是说，当 $Y_k=0,1,2$ 时，餐厅类型会分别变为果汁店，日式煎蛋卷店和冰淇淋店。在每个事件过后，你应该立即计算最新的好的 JOI 之旅的数量并告诉理惠女士。\n\n给定道路和餐厅信息，在每次类型改变事件发生之后计算好的 JOI 之旅的数量。\n\n### 实现细节\n\n你需要实现如下函数。\n\n- `void init(int N, std::vector<int> F, std::vector<int> U, std::vector<int> V, int Q)`\n  - 使用此函数给出道路和餐厅信息。\n  - 这个函数仅在程序开始时调用一次。\n  - 参数 `N` 是城市个数 $N$。\n  - 参数 `F` 是长为 $N$ 的数组。`F[i]` （$0\\le i\\le N-1$）表示城市 $i$ 中餐厅的类别，也就是 $F_i$。\n  - 参数 `U` 和 `V` 是长为 $N-1$ 的数组。`U[j]` 和 `V[j]`（$0\\le j\\le N-2$）是被路 $j$ 连接的两个城市 $U_j$ 和 $V_j$。\n  - 参数 `Q` 是餐厅类型改变事件的个数 $Q$。\n- `void change(int X, int Y)`\n  - 使用此函数给出餐厅类型改变事件。\n  - 这个函数被调用 $Q$ 次。\n  - 第 $(k+1)\\ (0\\le k\\le Q-1)$ 次调用中，参数 `X` 是餐厅类型改变发生的城市编号，也就是 $X_k$。\n  - 第 $(k+1)\\ (0\\le k\\le Q-1)$ 次调用中，参数 `Y` 是餐厅的新类型，也就是 $Y_k$。保证新类型与原类型不同。\n- `long long num_tours()`\n  - 这个函数在如下场景被调用，共 $Q+1$ 次。\n    - 在执行完函数 `init` 后。\n    - 在执行完函数 `change` 后。\n  - 这个函数应返回最新的好 JOI 之旅数。", "inputFormat": "**以下为下发 grader 的输入格式，你不应该从标准输入中读入任何信息。**\n\n第一行一个整数 $N$。\n\n第二行 $N$ 个整数 $F_0,\\ldots,F_{N-1}$。\n\n接下来 $N-1$ 行，每行两个整数 $U_j,V_j$。\n\n接下来一行一个整数 $Q$。\n\n接下来 $Q$ 行，每行两个整数 $X_k,Y_k$。", "outputFormat": "**以下为下发 grader 的输出格式，你不应该向标准输出中打印任何信息。**\n\n下发 grader 会在每次调用 `num_tours` 函数后输出一行一个整数，表示这个函数的返回值。", "hint": "#### 样例解释 1\n\n|                函数调用                 | 返回值 |\n| :-------------------------------------: | :----: |\n| `init(3, [0, 1, 2], [0, 1], [1, 2], 0)` |        |\n|              `num_tours()`              |  $1$   |\n\n只有一个好的 JOI 之旅，表示为 $(i_0,i_1,i_2)=(0,1,2)$。下面是对于它满足是好的 JOI 之旅条件的解释。\n\n- $F_0=0$，在城市 $0$ 的餐厅是果汁店。\n- $F_1=1$，在城市 $1$ 的餐厅是日式煎蛋卷店。\n- $F_2=2$，在城市 $2$ 的餐厅是冰淇淋店。\n- 当我们沿最短路径从城市 $0$ 移动到 $1$，然后从 $1$ 移动到 $2$ 时，我们没有经过相同的道路两次。\n\n因此，第一次 `num_tours()` 函数的调用返回值为 $1$。\n\n该样例满足子任务 $1,2,3,4,6,7$ 的限制。\n\n#### 样例解释 2\n\n|                函数调用                 | 返回值 |\n| :-------------------------------------: | :----: |\n| `init(3, [0, 1, 2], [0, 1], [1, 2], 2)` |        |\n|              `num_tours()`              |  $1$   |\n|             `change(2, 0)`              |        |\n|              `num_tours()`              |  $0$   |\n|             `change(0, 2)`              |        |\n|              `num_tours()`              |  $1$   |\n\n最初有一个好的 JOI 之旅，表示为 $(i_0,i_1,i_2)=(0,1,2)$。因此，第一次 `num_tours()` 函数的调用返回值为 $1$。\n\n在第一个事件中，在城市 $2$ 的餐厅从冰淇淋店变成了果汁店。在这次变化后，冰淇淋店从 IOI 国消失了，好的 JOI 之旅也没有了。因此，第二次 `num_tours()` 函数的调用返回值为 $0$。\n\n在第二个事件中，在城市 $0$ 的餐厅从果汁店变成了冰淇淋店。在这次变化后，有一个好的 JOI 之旅，表示为 $(i_0,i_1,i_2)=(2,1,0)$。因此，第三次 `num_tours()` 函数的调用返回值为 $1$。\n\n该样例满足子任务 $1,2,4,6,7$ 的限制。\n\n#### 样例解释 3\n\n这组样例满足子任务 $1,2,5,6,7$ 的限制。\n\n### 重要提示\n\n- 你的程序可以实现其它函数供内部使用，或者使用全局变量。\n- 你的程序禁止使用标准输入输出。你的程序禁止与其他文件通过任何方式交互。然而，你的程序可以使用标准错误输出输出调试信息。\n\n### 编译和测试运行\n\n你可以在「文件 - 附加文件」中下载样例交互器来测试你的程序。附加文件中还包含一个样例程序。\n\n样例交互器是文件 `grader.cpp`。为了测试你的程序，请将 `grader.cpp`，`joitour.cpp` 和 `joitour.h` 放在同一目录下，并且执行如下命令编译程序。此外你也可以运行 `compile.sh` 来编译你的程序。\n\n```bash\ng++ -std=gnu++20 -O2 -o grader grader.cpp joitour.cpp\n```\n\n当编译成功时，会生成可执行文件 `grader`。\n\n注意测评时使用的交互器与样例交互器不同。样例交互器会以单进程的形式执行，它会从标准输入中读入数据，输出结果到标准输出。\n\n### 约束条件\n\n- $3\\le N\\le 2\\times 10^5$。\n- $0\\le F_i\\le 2\\ (0\\le i\\le N-1)$。\n- $0\\le U_j<V_j\\le N-1\\ (0\\le j\\le N-2)$。\n- 可以通过道路从一个城市前往任意其他城市。\n- $0\\le Q\\le 5\\times 10^4$。\n- $0\\le X_k\\le N-1\\ (0\\le k\\le Q-1)$。\n- $0\\le Y_k\\le 2\\ (0\\le k\\le Q-1)$。\n- 对于每次调用函数 `change`，新类型不同于原类型。\n\n### 子任务\n\n- （6 分）$N\\le 400$，$Q\\le 100$。\n- （8 分）$N\\le 4\\,000$，$Q\\le 1\\,000$。\n- （6 分）$Q=0$。\n- （16 分）$U_j=j,V_j=j+1\\ (0\\le j\\le N-2)$。\n- （16 分）$U_j=\\lfloor\\frac{j}{2}\\rfloor,V_j=j+1\\ (0\\le j\\le N-2)$。\n- （34 分）$N\\le 10^5$，$Q\\le 2.5\\times 10^4$。\n- （14 分）无额外约束。", "locale": "zh-CN"}}}
{"pid": "P10438", "type": "P", "difficulty": 6, "samples": [["3 1\n4 10 35\n4 5\n10 12\n14 14\n13", "120"], ["5 10\n10 1 9\n7 11\n25 32\n37 38\n43 44\n50 52\n6\n12\n18\n24\n30\n36\n42\n48\n54\n60", "6\n11\n17\n22\n-1\n33\n-1\n44\n-1\n55"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] 塔楼 / Tower", "background": "", "description": "IOI Tower 是一座极其高的塔楼，配备了一条用于上升的楼梯。这个楼梯由 $10^{100}$ 个台阶组成，从底部开始依次编号为第 $0$ 级、第 $1$ 级，依此类推。JOI 君目前在第 $0$ 级，并打算爬楼梯。JOI 君可以通过以下两种方式上楼，禁止下楼。\n\n- 上升 $1$ 级。这个动作需要 $A$ 秒。\n- 从当前级别跳到上方 $D$ 级，跳过中间的台阶。这个动作需要 $B$ 秒。\n\n目前，楼梯的几个位置正在进行施工，正在施工的台阶不能踩上去。具体来说，有 $N$ 处正在进行施工，第 $i$ 处施工（$1 \\leq i \\leq N$）正在进行的台阶为 $L_i$ 到 $R_i$。\n\nIOI Tower 有 $Q$ 个房间，编号从 $1$ 到 $Q$。人们可以从楼梯的第 $X_j$ 级进入第 $j$ 个房间（$1 \\leq j \\leq Q$）。因此，JOI 君决定确定他是否可以到达每个房间，如果可能的话，以最短时间需要多少秒到达。\n\n给出关于 JOI 君、施工和房间的信息，创建一个程序，确定 JOI 君是否可以到达第 $j$ 个房间（$1 \\leq j \\leq Q$），如果可能的话，计算需要的最短时间。\n", "inputFormat": "从标准输入读取以下数据。\n\n- $N$ $Q$\n- $D$ $A$ $B$\n- $L_1$ $R_1$\n- $L_2$ $R_2$\n- ...\n- $L_N$ $R_N$\n- $X_1$\n- $X_2$\n- ...\n- $X_Q$\n", "outputFormat": "输出 $Q$ 行，在第 $j$ 行（$1 \\leq j \\leq Q$）输出 JOI 君到达第 $X_j$ 级台阶所需的最少秒数；如果无法到达，则输出 $-1$。\n", "hint": "#### 样例解释 1\n\nJOI 君可以按照以下步骤在 $120$ 秒内到达楼梯的第 $13$ 阶：\n\n- 从第 $0$ 阶到第 $1$ 阶上升。此操作需要 $10$ 秒。\n- 从第 $1$ 阶到第 $2$ 阶上升。此操作需要 $10$ 秒。\n- 从第 $2$ 阶到第 $3$ 阶上升。此操作需要 $10$ 秒。\n- 从第 $3$ 阶跳到第 $7$ 阶，跳过中间的台阶。此操作需要 $35$ 秒。\n- 从第 $7$ 阶到第 $8$ 阶上升。此操作需要 $10$ 秒。\n- 从第 $8$ 阶到第 $9$ 阶上升。此操作需要 $10$ 秒。\n- 从第 $9$ 阶跳到第 $13$ 阶，跳过中间的台阶。此操作需要 $35$ 秒。\n\n由于无法在小于 $120$ 秒内到达第 $13$ 阶楼梯，输出为 $120$。\n\n这个样例输入满足子任务 $1,2,4$ 的约束条件。\n\n#### 样例解释 2\n\n这个样例输入满足子任务 $1,2,4$ 的约束条件。\n\n### 约束条件\n\n- $1 \\leq N \\leq 200,000$\n- $1 \\leq Q \\leq 200,000$\n- $1 \\leq D \\leq 10^{12}$\n- $1 \\leq A \\leq 1,000,000$\n- $1 \\leq B \\leq 1,000,000$\n- $1 \\leq L_i \\leq R_i \\leq 10^{12}$（$1 \\leq i \\leq N$）\n- $R_{i}+1 < L_{i+1}$（$1 \\leq i \\leq N-1$）\n- $1 \\leq X_j \\leq 10^{12}$（$1 \\leq j \\leq Q$）\n- 给定值均为整数。\n\n### 子任务\n\n1. （5 分）$R_i \\leq 1,000,000$（$1 \\leq i \\leq N$），$X_j \\leq 1,000,000$（$1 \\leq j \\leq Q$）\n2. （38 分）$N \\leq 2,000$，$Q \\leq 2,000$\n3. （25 分）$A = 1$，$B = D$\n4. （32 分）无额外约束。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2024] 塔楼 / Tower", "background": "", "description": "IOI Tower 是一座极其高的塔楼，配备了一条用于上升的楼梯。这个楼梯由 $10^{100}$ 个台阶组成，从底部开始依次编号为第 $0$ 级、第 $1$ 级，依此类推。JOI 君目前在第 $0$ 级，并打算爬楼梯。JOI 君可以通过以下两种方式上楼，禁止下楼。\n\n- 上升 $1$ 级。这个动作需要 $A$ 秒。\n- 从当前级别跳到上方 $D$ 级，跳过中间的台阶。这个动作需要 $B$ 秒。\n\n目前，楼梯的几个位置正在进行施工，正在施工的台阶不能踩上去。具体来说，有 $N$ 处正在进行施工，第 $i$ 处施工（$1 \\leq i \\leq N$）正在进行的台阶为 $L_i$ 到 $R_i$。\n\nIOI Tower 有 $Q$ 个房间，编号从 $1$ 到 $Q$。人们可以从楼梯的第 $X_j$ 级进入第 $j$ 个房间（$1 \\leq j \\leq Q$）。因此，JOI 君决定确定他是否可以到达每个房间，如果可能的话，以最短时间需要多少秒到达。\n\n给出关于 JOI 君、施工和房间的信息，创建一个程序，确定 JOI 君是否可以到达第 $j$ 个房间（$1 \\leq j \\leq Q$），如果可能的话，计算需要的最短时间。\n", "inputFormat": "从标准输入读取以下数据。\n\n- $N$ $Q$\n- $D$ $A$ $B$\n- $L_1$ $R_1$\n- $L_2$ $R_2$\n- ...\n- $L_N$ $R_N$\n- $X_1$\n- $X_2$\n- ...\n- $X_Q$\n", "outputFormat": "输出 $Q$ 行，在第 $j$ 行（$1 \\leq j \\leq Q$）输出 JOI 君到达第 $X_j$ 级台阶所需的最少秒数；如果无法到达，则输出 $-1$。\n", "hint": "#### 样例解释 1\n\nJOI 君可以按照以下步骤在 $120$ 秒内到达楼梯的第 $13$ 阶：\n\n- 从第 $0$ 阶到第 $1$ 阶上升。此操作需要 $10$ 秒。\n- 从第 $1$ 阶到第 $2$ 阶上升。此操作需要 $10$ 秒。\n- 从第 $2$ 阶到第 $3$ 阶上升。此操作需要 $10$ 秒。\n- 从第 $3$ 阶跳到第 $7$ 阶，跳过中间的台阶。此操作需要 $35$ 秒。\n- 从第 $7$ 阶到第 $8$ 阶上升。此操作需要 $10$ 秒。\n- 从第 $8$ 阶到第 $9$ 阶上升。此操作需要 $10$ 秒。\n- 从第 $9$ 阶跳到第 $13$ 阶，跳过中间的台阶。此操作需要 $35$ 秒。\n\n由于无法在小于 $120$ 秒内到达第 $13$ 阶楼梯，输出为 $120$。\n\n这个样例输入满足子任务 $1,2,4$ 的约束条件。\n\n#### 样例解释 2\n\n这个样例输入满足子任务 $1,2,4$ 的约束条件。\n\n### 约束条件\n\n- $1 \\leq N \\leq 200,000$\n- $1 \\leq Q \\leq 200,000$\n- $1 \\leq D \\leq 10^{12}$\n- $1 \\leq A \\leq 1,000,000$\n- $1 \\leq B \\leq 1,000,000$\n- $1 \\leq L_i \\leq R_i \\leq 10^{12}$（$1 \\leq i \\leq N$）\n- $R_{i}+1 < L_{i+1}$（$1 \\leq i \\leq N-1$）\n- $1 \\leq X_j \\leq 10^{12}$（$1 \\leq j \\leq Q$）\n- 给定值均为整数。\n\n### 子任务\n\n1. （5 分）$R_i \\leq 1,000,000$（$1 \\leq i \\leq N$），$X_j \\leq 1,000,000$（$1 \\leq j \\leq Q$）\n2. （38 分）$N \\leq 2,000$，$Q \\leq 2,000$\n3. （25 分）$A = 1$，$B = D$\n4. （32 分）无额外约束。", "locale": "zh-CN"}}}
{"pid": "P10439", "type": "P", "difficulty": 6, "samples": [["4 10000\n1\n100 300\n2\n200 400\n300 600\n1\n500 600\n3\n1 3\n2 4\n1 4", "500\n400\n10500"], ["6 10000\n1\n100 300\n1\n400 700\n1\n500 600\n1\n300 900\n1\n200 800\n1\n1 6\n", "30700"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] 逃生路线 2 / Escape Route 2", "background": "", "description": "IOI 王国由从西向东排列的 $N$ 座城市组成，城市按照从西向东的顺序从 $1$ 到 $N$ 编号。\n\n在 IOI 王国，他们使用 Byou 作为时间单位。IOI 王国的一天被分为 $T$ 个时间单位。从某一天开始后的 $x$ 个 Byous（$0 \\leq x < T$）被称为时间 $x$。因此，当从某一天的时间 $T - 1$ 开始经过 $1$ 个 Byou 时，将成为下一天的时间 $0$。\n\nJOI 组织是 IOI 王国的秘密教派之一。由于它是一个秘密教派，成员必须绕过国家的检查站。因此，JOI 组织成员只能使用 JOY 航空公司运营的航班进行城市间旅行。\n\nJOY 航空公司在城市 $i$（$1 \\leq i \\leq N - 1$）提供 $M_i$ 趟航班。第 $j$ 趟航班（$1 \\leq j \\leq M_i$）每天从城市 $i$ 在时间 $A_{i,j}$ 起飞，于当天的时间 $B_{i,j}$ 到达城市 $i + 1$。这里，满足 $A_{i,j} < B_{i,j}$。\n\n这些航班提供了便捷的转机服务，也可以在抵达后立即起飞或在公司的机场过夜。\n\nJOI 组织有 $Q$ 名成员，编号从 $1$ 到 $Q$。成员 $k$（$1 \\leq k \\leq Q$）将他们的运营基地设在城市 $L_k$，生活基地设在城市 $R_k$。因此，他们想知道通过选择从城市 $L_k$ 出发的时间和适当的航班进行，从城市 $L_k$ 出发到城市 $R_k$ 的最短时间。\n\n给定 JOY 航空公司运营的航班和 JOI 组织成员的信息，编写一个程序，找到每个成员 $k$ 从城市 $L_k$ 到城市 $R_k$ 的最短时间。", "inputFormat": "从标准输入中读取以下数据。\n\n- $N$ $T$\n- $M_1$\n- $A_{1,1}$ $B_{1,1}$\n- $A_{1,2}$ $B_{1,2}$\n- ...\n- $A_{1,M_1}$ $B_{1,M_1}$\n- $M_2$\n- $A_{2,1}$ $B_{2,1}$\n- $A_{2,2}$ $B_{2,2}$\n- ...\n- $A_{2,M_2}$ $B_{2,M_2}$\n- ...\n- $M_{N-1}$\n- $A_{N-1,1}$ $B_{N-1,1}$\n- $A_{N-1,2}$ $B_{N-1,2}$\n- ...\n- $A_{N-1,M_{N-1}}$ $B_{N-1,M_{N-1}}$\n- $Q$\n- $L_1$ $R_1$\n- $L_2$ $R_2$\n- ...\n- $L_Q$ $R_Q$\n", "outputFormat": "输出 $Q$ 行到标准输出。在第 $k$ 行（$1 \\leq k \\leq Q$），输出成员 $k$ 从城市 $L_k$ 到城市 $R_k$ 所需的最短时间。\n", "hint": "#### 样例解释 1\n\n作为演示，让我们将成员 $k$ 从城市 $L_k$ 出发的第一天称为第 $1$ 天。成员 $1$ 可以按照以下行动在 $500$ Byou 内从城市 $1$ 前往城市 $3$：\n\n1. 第 $1$ 天时刻 $100$ 从城市 $1$ 出发，并在第 $1$ 天时刻 $300$ 到达城市 $2$。\n2. 第 $1$ 天时刻 $300$ 从城市 $2$ 出发，并在第 $1$ 天时刻 $600$ 到达城市 $3$。\n\n由于没有更快的旅行方式，所以在第 $1$ 行输出 $500$。\n\n成员 $2$ 可以按照以下行动在 $400$ Byou 内从城市 $2$ 前往城市 $4$：\n\n1. 第 $1$ 天时刻 $200$ 从城市 $2$ 出发，并在第 $1$ 天时刻 $400$ 到达城市 $3$。\n2. 第 $1$ 天时刻 $500$ 从城市 $3$ 出发，并在第 $1$ 天时刻 $600$ 到达城市 $4$。\n\n由于没有更快的旅行方式，所以在第 $2$ 行输出 $400$。\n\n成员 $3$ 可以按照以下行动在 $10500$ Byou 内从城市 $1$ 前往城市 $4$：\n\n1. 第 $1$ 天时刻 $100$ 从城市 $1$ 出发，并在第 $1$ 天时刻 $300$ 到达城市 $2$。\n2. 第 $1$ 天时刻 $300$ 从城市 $2$ 出发，并在第 $1$ 天时刻 $600$ 到达城市 $3$。\n3. 第 $2$ 天时刻 $500$ 从城市 $3$ 出发，并在第 $2$ 天时刻 $600$ 到达城市 $4$。\n\n由于没有更快的旅行方式，所以在第 $3$ 行输出 $10500$。\n\n这个样例输入满足子任务 $2,4,5,6$ 的限制条件。\n\n\n#### 样例解释 2\n\n这个样例输入满足所有子任务的约束条件。\n\n### 约束条件\n\n- $2 \\leq N \\leq 100,000$\n- $2 \\leq T \\leq 10^9$\n- $M_i \\geq 1$（$1 \\leq i \\leq N - 1$）\n- $M_1 + M_2 + \\cdots + M_{N-1} \\leq 100,000$\n- $0 \\leq A_{i,j} < B_{i,j} < T$（$1 \\leq i \\leq N - 1, 1 \\leq j \\leq M_i$）\n- $1 \\leq Q \\leq 300,000$\n- $1 \\leq L_k < R_k \\leq N$（$1 \\leq k \\leq Q$）\n- 给定值均为整数。\n\n### 子任务\n\n1. (6 分) $N \\leq 2,000$，$M_i = 1$（$1 \\leq i \\leq N - 1$）\n2. (8 分) $N \\leq 2,000$，$M_i \\leq 5$（$1 \\leq i \\leq N - 1$）\n3. (17 分) $M_i = 1$（$1 \\leq i \\leq N - 1$）\n4. (23 分) $M_i \\leq 5$（$1 \\leq i \\leq N - 1$）\n5. (36 分) $N \\leq 90,000$，$Q \\leq 90,000$，$M_1 + M_2 + \\cdots + M_{N-1} \\leq 90,000$\n6. (10 分) 无额外约束条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2024] 逃生路线 2 / Escape Route 2", "background": "", "description": "IOI 王国由从西向东排列的 $N$ 座城市组成，城市按照从西向东的顺序从 $1$ 到 $N$ 编号。\n\n在 IOI 王国，他们使用 Byou 作为时间单位。IOI 王国的一天被分为 $T$ 个时间单位。从某一天开始后的 $x$ 个 Byous（$0 \\leq x < T$）被称为时间 $x$。因此，当从某一天的时间 $T - 1$ 开始经过 $1$ 个 Byou 时，将成为下一天的时间 $0$。\n\nJOI 组织是 IOI 王国的秘密教派之一。由于它是一个秘密教派，成员必须绕过国家的检查站。因此，JOI 组织成员只能使用 JOY 航空公司运营的航班进行城市间旅行。\n\nJOY 航空公司在城市 $i$（$1 \\leq i \\leq N - 1$）提供 $M_i$ 趟航班。第 $j$ 趟航班（$1 \\leq j \\leq M_i$）每天从城市 $i$ 在时间 $A_{i,j}$ 起飞，于当天的时间 $B_{i,j}$ 到达城市 $i + 1$。这里，满足 $A_{i,j} < B_{i,j}$。\n\n这些航班提供了便捷的转机服务，也可以在抵达后立即起飞或在公司的机场过夜。\n\nJOI 组织有 $Q$ 名成员，编号从 $1$ 到 $Q$。成员 $k$（$1 \\leq k \\leq Q$）将他们的运营基地设在城市 $L_k$，生活基地设在城市 $R_k$。因此，他们想知道通过选择从城市 $L_k$ 出发的时间和适当的航班进行，从城市 $L_k$ 出发到城市 $R_k$ 的最短时间。\n\n给定 JOY 航空公司运营的航班和 JOI 组织成员的信息，编写一个程序，找到每个成员 $k$ 从城市 $L_k$ 到城市 $R_k$ 的最短时间。", "inputFormat": "从标准输入中读取以下数据。\n\n- $N$ $T$\n- $M_1$\n- $A_{1,1}$ $B_{1,1}$\n- $A_{1,2}$ $B_{1,2}$\n- ...\n- $A_{1,M_1}$ $B_{1,M_1}$\n- $M_2$\n- $A_{2,1}$ $B_{2,1}$\n- $A_{2,2}$ $B_{2,2}$\n- ...\n- $A_{2,M_2}$ $B_{2,M_2}$\n- ...\n- $M_{N-1}$\n- $A_{N-1,1}$ $B_{N-1,1}$\n- $A_{N-1,2}$ $B_{N-1,2}$\n- ...\n- $A_{N-1,M_{N-1}}$ $B_{N-1,M_{N-1}}$\n- $Q$\n- $L_1$ $R_1$\n- $L_2$ $R_2$\n- ...\n- $L_Q$ $R_Q$\n", "outputFormat": "输出 $Q$ 行到标准输出。在第 $k$ 行（$1 \\leq k \\leq Q$），输出成员 $k$ 从城市 $L_k$ 到城市 $R_k$ 所需的最短时间。\n", "hint": "#### 样例解释 1\n\n作为演示，让我们将成员 $k$ 从城市 $L_k$ 出发的第一天称为第 $1$ 天。成员 $1$ 可以按照以下行动在 $500$ Byou 内从城市 $1$ 前往城市 $3$：\n\n1. 第 $1$ 天时刻 $100$ 从城市 $1$ 出发，并在第 $1$ 天时刻 $300$ 到达城市 $2$。\n2. 第 $1$ 天时刻 $300$ 从城市 $2$ 出发，并在第 $1$ 天时刻 $600$ 到达城市 $3$。\n\n由于没有更快的旅行方式，所以在第 $1$ 行输出 $500$。\n\n成员 $2$ 可以按照以下行动在 $400$ Byou 内从城市 $2$ 前往城市 $4$：\n\n1. 第 $1$ 天时刻 $200$ 从城市 $2$ 出发，并在第 $1$ 天时刻 $400$ 到达城市 $3$。\n2. 第 $1$ 天时刻 $500$ 从城市 $3$ 出发，并在第 $1$ 天时刻 $600$ 到达城市 $4$。\n\n由于没有更快的旅行方式，所以在第 $2$ 行输出 $400$。\n\n成员 $3$ 可以按照以下行动在 $10500$ Byou 内从城市 $1$ 前往城市 $4$：\n\n1. 第 $1$ 天时刻 $100$ 从城市 $1$ 出发，并在第 $1$ 天时刻 $300$ 到达城市 $2$。\n2. 第 $1$ 天时刻 $300$ 从城市 $2$ 出发，并在第 $1$ 天时刻 $600$ 到达城市 $3$。\n3. 第 $2$ 天时刻 $500$ 从城市 $3$ 出发，并在第 $2$ 天时刻 $600$ 到达城市 $4$。\n\n由于没有更快的旅行方式，所以在第 $3$ 行输出 $10500$。\n\n这个样例输入满足子任务 $2,4,5,6$ 的限制条件。\n\n\n#### 样例解释 2\n\n这个样例输入满足所有子任务的约束条件。\n\n### 约束条件\n\n- $2 \\leq N \\leq 100,000$\n- $2 \\leq T \\leq 10^9$\n- $M_i \\geq 1$（$1 \\leq i \\leq N - 1$）\n- $M_1 + M_2 + \\cdots + M_{N-1} \\leq 100,000$\n- $0 \\leq A_{i,j} < B_{i,j} < T$（$1 \\leq i \\leq N - 1, 1 \\leq j \\leq M_i$）\n- $1 \\leq Q \\leq 300,000$\n- $1 \\leq L_k < R_k \\leq N$（$1 \\leq k \\leq Q$）\n- 给定值均为整数。\n\n### 子任务\n\n1. (6 分) $N \\leq 2,000$，$M_i = 1$（$1 \\leq i \\leq N - 1$）\n2. (8 分) $N \\leq 2,000$，$M_i \\leq 5$（$1 \\leq i \\leq N - 1$）\n3. (17 分) $M_i = 1$（$1 \\leq i \\leq N - 1$）\n4. (23 分) $M_i \\leq 5$（$1 \\leq i \\leq N - 1$）\n5. (36 分) $N \\leq 90,000$，$Q \\leq 90,000$，$M_1 + M_2 + \\cdots + M_{N-1} \\leq 90,000$\n6. (10 分) 无额外约束条件。", "locale": "zh-CN"}}}
{"pid": "P10440", "type": "P", "difficulty": 6, "samples": [["4 16\n1 2\n2 4\n4 3", ""], ["5 25\n5 2\n3 1\n1 4\n1 5", ""]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "交互题", "Special Judge", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] 环岛旅行 / Island Hopping", "background": "**由于部分 BUG，使用 C++14 (GCC9) 提交会产生编译错误，请使用 C++14 等语言进行提交。**\n\n**题目译自 [JOISC 2024](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/index.html) Day4 T2 「[島巡り](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/contest4/island.pdf) / [Island Hopping](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/contest4/island-en.pdf)」**。翻译来源 LOJ。\n\n**不要引入 `island.h`**。你应该在文件头添加以下声明：\n\n```\nint query(int, int);\nvoid answer(int, int);\n```\n\n交互文件可在 [JOI 官网](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/index.html)下载。", "description": "**这是一道交互题。本题交互库是非自适应的。**\n\nJOI 国有 $N$ 座岛屿，编号为 $1$ 到 $N$。有 $N-1$ 条航线，编号为 $1$ 到 $N-1$。航线 $j\\ (1\\le j\\le N-1)$ 双向连接岛屿 $A_j$ 和 $B_j$。可以从一座岛屿出发，通过一些航线到达任意另一个岛屿。\n\n葵准备在 JOI 国旅行。然而她不知道 JOI 国的航线。她准备向 JOI 国居住的 Bitaro 按下面的方式提一些问题：\n\n1. 葵告诉 Bitaro 两个整数 $v$ 和 $k$，其中 $1\\le v\\le N,1\\le k\\le N-1$。\n2. Bitaro 会告诉她除了 $v$ 之外的其他 $N-1$ 座岛屿中，距离 $v$ 第 $k$ 近的岛屿编号。更确切地说，他会告诉她一个整数 $i$，满足 $\\text{dist}(v,i)\\times N+i\\ (1\\le i\\le N,i\\neq v)$ 是第 $k$ 小的，其中 $\\text{dist}(v,i)$ 是从岛屿 $v$ 到 $i$ 所经过的最小航线数。\n\n葵想通过提问知道所有 JOI 国的航线。因为葵不想花费太多时间，所以她最多只能向 Bitaro 问 $L$ 个问题。\n\n给定 JOI 国的岛屿数和提问限制数，写一个程序模拟葵的提问策略，以找出所有的航线。\n\n### 实现细节\n\n你需要在程序开头引入库 `island.h`。\n\n你需要实现如下函数。\n\n- `void solve(int N, int L)`\n\n  此函数在每个测试点中只被调用一次\n\n  - 参数 `N` 是岛屿数 $N$\n  - 参数 `L` 是提问次数限制 $L$。\n\n在程序中，你可以调用如下函数。\n\n- `int query(int v, int k)`\n\n  葵使用此函数向 Bitaro 提问\n\n  - 参数 `v` 必须在 $1$ 到 $N$ 之间。如果不是，你的程序会被判为 **Wrong Answer [1]**。\n  - 参数 `k` 必须在 $1$ 到 $N-1$​ 之间。如果不是，你的程序会被判为 **Wrong Answer [2]**。\n  - 返回值表示除 $v$ 之外的其他 $N-1$ 个岛屿中，距离 $v$ 第 $k$ 近的岛屿编号。参考题目描述获得更详细的定义。\n  - 你不能调用 `query` 函数超过 $L$ 次，否则你的程序会被判为 **Wrong Answer [3]**。\n\n- `void answer(int x, int y)`\n\n  使用此函数回答 JOI 国的一条航线\n\n  - 参数 `x` 和 `y` 表示被一条航线连接的两座岛屿。\n  - 参数 `x` 和 `y` 必须在 $1$ 到 $N$ 之间。如果不是，你的程序会被判为 **Wrong Answer [4]**。\n  - 必须存在一条连接岛屿 `x` 和 `y` 的航线。换句话说，必须存在一个整数 $j\\ (1\\le j\\le N-1)$ 满足 $x=A_j,y=B_j$ 或 $x=B_j,y=A_j$。否则，你的程序会被判为 **Wrong Answer [5]**。\n  - 你的程序不能回答相同的航线两次或以上。否则，你的程序会被判为 **Wrong Answer [6]**。\n  - 函数 `answer` 必须被调用恰好 $N-1$ 次。如果 `solve` 函数运行结束后此函数调用次数不是 $N-1$，你的程序会被判为 **Wrong Answer [7]**。\n  \n### 注意事项\n\n- 你的程序可以实现其它函数供内部使用，或者使用全局变量。\n- 你的程序禁止使用标准输入输出。你的程序禁止与其他文件通过任何方式交互。然而，你的程序可以使用标准错误输出输出调试信息。\n- 测评中使用的交互器**不是**自适应性的。这意味着每组测试点的答案是提前确定好的。\n\n### 编译运行\n\n你可以在附件中下载样例交互器来测试你的程序。附加文件中还包含一个样例程序。\n\n样例交互器是文件 `grader.cpp`。为了测试你的程序，请将 `grader.cpp`，`island.cpp` 和 `island.h` 放在同一目录下，并且执行如下命令编译程序。此外你也可以运行 `compile.sh` 来编译你的程序。\n\n```bash\ng++ -std=gnu++20 -O2 -o grader grader.cpp island.cpp\n```\n\n当编译成功时，会生成可执行文件 `grader`。\n\n注意测评时使用的交互器与样例交互器不同。样例交互器会以单进程的形式执行，它会从标准输入中读入数据，输出结果到标准输出。", "inputFormat": "Sample Grader 输入格式如下：\n\n第一行两个整数 $N,L$。\n\n接下来 $N-1$ 行，每行两个整数 $A_j,B_j$。", "outputFormat": "样例交互器将向标准输出中输出如下信息：\n\n\n- 如果你的程序被判为正确，它会报告调用 `query` 的次数，如：`Accepted: 2024`。\n- 如果你的程序被判为某种 Wrong Answer，样例交互程序会输出它的类别，如：`Wrong Answer [4]`。\n\n如果你的程序满足多种 Wrong Answer 的类别，样例交互器只会报告其中一个。", "hint": "### 样例交互\n\n#### 样例交互 $1$\n\n样例调用过程如下表所示。\n\n|      调用      |      调用      | 返回值 |\n| :------------: | :------------: | :----: |\n| `solve(4, 16)` |               |        |\n|                | `query(2, 1)`  |  $1$   |\n|                | `query(3, 1)`  |  $4$   |\n|                | `answer(2, 4)` |        |\n|                | `query(2, 2)`  |  $4$   |\n|                | `answer(2, 1)` |        |\n|                | `query(3, 2)`  |  $2$   |\n|                | `query(2, 1)`  |  $1$   |\n|                | `answer(3, 4)` |        |\n\n从岛屿 $2$ 到岛屿 $1,3,4$ 的最小经过航线数分别为 $1,2,1$。例如，从岛屿 $2$ 到岛屿 $3$，我们可以使用航线 $2$ 后使用航线 $3$。\n\n将岛屿按 $\\text{dist}(2,i)\\times N+i\\ (i\\neq 2)$ 递增的顺序排序，结果是岛屿 $1,4,3$。因此，`query(2, 1)` 的返回值为 $1$，`query(2, 2)` 的返回值为 $4$。\n\n样例 $1$ 满足子任务 $2,6$ 的限制。\n\n#### 样例交互 $2$\n\n\n样例调用过程如下表所示。\n\n|      调用      |      调用      | 返回值 |\n| :------------: | :------------: | :----: |\n| `solve(5, 25)` |            |        |\n|                | `query(1, 3)`  |  $5$   |\n|                | `query(1, 4)`  |  $2$   |\n|                | `answer(3, 1)` |        |\n|                | `query(2, 4)`  |  $4$   |\n|                | `query(3, 1)`  |  $1$   |\n|                | `query(3, 2)`  |  $4$   |\n|                | `answer(1, 5)` |        |\n|                | `answer(4, 1)` |      |\n|                | `answer(2, 5)`  |        |\n\n从岛屿 $1$ 到岛屿 $2,3,4,5$ 的最小经过航线数分别为 $2,1,1,1$。例如，从岛屿 $1$ 到岛屿 $2$，我们可以使用航线 $4$ 后使用航线 $1$。\n\n将岛屿按 $\\text{dist}(1,i)\\times N+i\\ (i\\neq 1)$ 递增的顺序排序，结果是岛屿 $3,4,5,2$。因此，`query(1, 3)` 的返回值为 $5$，`query(1, 4)` 的返回值为 $2$。\n\n样例 $2$ 满足子任务 $4,6$ 的限制。\n\n### 数据范围\n\n- $3\\le N\\le 300$\n- $1\\le A_j,B_j\\le N\\ (1\\le j\\le N-1)$\n- $A_j\\neq B_j\\ (1\\le j\\le N-1)$\n- 可以通过航线，从一个岛屿到达任意其他岛屿\n\n### 子任务\n\n| 子任务 |                           附加限制                           | 分值 |\n| :----: | :----------------------------------------------------------: | :--: |\n|  $1$   |                          $N=3,L=9$                           | $2$  |\n|  $2$   |             $L=N^2$，每座岛屿最多有两条航线连接              | $4$  |\n|  $3$   |              $L=2N$，每座岛屿最多有两条航线连接              | $7$  |\n|  $4$   | $L=N^2$，岛屿 $1$ 有三条航线连接，其他每座岛屿最多有两条航线连接 | $9$  |\n|  $5$   | $L=3N$，岛屿 $1$ 有三条航线连接，其他每座岛屿最多有两条航线连接 | $13$ |\n|  $6$   |                           $L=N^2$                            | $15$ |\n|  $7$   |                            $L=3N$                            | $22$ |\n|  $8$   |                            $L=2N$                            | $28$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2024] 环岛旅行 / Island Hopping", "background": "**由于部分 BUG，使用 C++14 (GCC9) 提交会产生编译错误，请使用 C++14 等语言进行提交。**\n\n**题目译自 [JOISC 2024](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/index.html) Day4 T2 「[島巡り](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/contest4/island.pdf) / [Island Hopping](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/contest4/island-en.pdf)」**。翻译来源 LOJ。\n\n**不要引入 `island.h`**。你应该在文件头添加以下声明：\n\n```\nint query(int, int);\nvoid answer(int, int);\n```\n\n交互文件可在 [JOI 官网](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/index.html)下载。", "description": "**这是一道交互题。本题交互库是非自适应的。**\n\nJOI 国有 $N$ 座岛屿，编号为 $1$ 到 $N$。有 $N-1$ 条航线，编号为 $1$ 到 $N-1$。航线 $j\\ (1\\le j\\le N-1)$ 双向连接岛屿 $A_j$ 和 $B_j$。可以从一座岛屿出发，通过一些航线到达任意另一个岛屿。\n\n葵准备在 JOI 国旅行。然而她不知道 JOI 国的航线。她准备向 JOI 国居住的 Bitaro 按下面的方式提一些问题：\n\n1. 葵告诉 Bitaro 两个整数 $v$ 和 $k$，其中 $1\\le v\\le N,1\\le k\\le N-1$。\n2. Bitaro 会告诉她除了 $v$ 之外的其他 $N-1$ 座岛屿中，距离 $v$ 第 $k$ 近的岛屿编号。更确切地说，他会告诉她一个整数 $i$，满足 $\\text{dist}(v,i)\\times N+i\\ (1\\le i\\le N,i\\neq v)$ 是第 $k$ 小的，其中 $\\text{dist}(v,i)$ 是从岛屿 $v$ 到 $i$ 所经过的最小航线数。\n\n葵想通过提问知道所有 JOI 国的航线。因为葵不想花费太多时间，所以她最多只能向 Bitaro 问 $L$ 个问题。\n\n给定 JOI 国的岛屿数和提问限制数，写一个程序模拟葵的提问策略，以找出所有的航线。\n\n### 实现细节\n\n你需要在程序开头引入库 `island.h`。\n\n你需要实现如下函数。\n\n- `void solve(int N, int L)`\n\n  此函数在每个测试点中只被调用一次\n\n  - 参数 `N` 是岛屿数 $N$\n  - 参数 `L` 是提问次数限制 $L$。\n\n在程序中，你可以调用如下函数。\n\n- `int query(int v, int k)`\n\n  葵使用此函数向 Bitaro 提问\n\n  - 参数 `v` 必须在 $1$ 到 $N$ 之间。如果不是，你的程序会被判为 **Wrong Answer [1]**。\n  - 参数 `k` 必须在 $1$ 到 $N-1$​ 之间。如果不是，你的程序会被判为 **Wrong Answer [2]**。\n  - 返回值表示除 $v$ 之外的其他 $N-1$ 个岛屿中，距离 $v$ 第 $k$ 近的岛屿编号。参考题目描述获得更详细的定义。\n  - 你不能调用 `query` 函数超过 $L$ 次，否则你的程序会被判为 **Wrong Answer [3]**。\n\n- `void answer(int x, int y)`\n\n  使用此函数回答 JOI 国的一条航线\n\n  - 参数 `x` 和 `y` 表示被一条航线连接的两座岛屿。\n  - 参数 `x` 和 `y` 必须在 $1$ 到 $N$ 之间。如果不是，你的程序会被判为 **Wrong Answer [4]**。\n  - 必须存在一条连接岛屿 `x` 和 `y` 的航线。换句话说，必须存在一个整数 $j\\ (1\\le j\\le N-1)$ 满足 $x=A_j,y=B_j$ 或 $x=B_j,y=A_j$。否则，你的程序会被判为 **Wrong Answer [5]**。\n  - 你的程序不能回答相同的航线两次或以上。否则，你的程序会被判为 **Wrong Answer [6]**。\n  - 函数 `answer` 必须被调用恰好 $N-1$ 次。如果 `solve` 函数运行结束后此函数调用次数不是 $N-1$，你的程序会被判为 **Wrong Answer [7]**。\n  \n### 注意事项\n\n- 你的程序可以实现其它函数供内部使用，或者使用全局变量。\n- 你的程序禁止使用标准输入输出。你的程序禁止与其他文件通过任何方式交互。然而，你的程序可以使用标准错误输出输出调试信息。\n- 测评中使用的交互器**不是**自适应性的。这意味着每组测试点的答案是提前确定好的。\n\n### 编译运行\n\n你可以在附件中下载样例交互器来测试你的程序。附加文件中还包含一个样例程序。\n\n样例交互器是文件 `grader.cpp`。为了测试你的程序，请将 `grader.cpp`，`island.cpp` 和 `island.h` 放在同一目录下，并且执行如下命令编译程序。此外你也可以运行 `compile.sh` 来编译你的程序。\n\n```bash\ng++ -std=gnu++20 -O2 -o grader grader.cpp island.cpp\n```\n\n当编译成功时，会生成可执行文件 `grader`。\n\n注意测评时使用的交互器与样例交互器不同。样例交互器会以单进程的形式执行，它会从标准输入中读入数据，输出结果到标准输出。", "inputFormat": "Sample Grader 输入格式如下：\n\n第一行两个整数 $N,L$。\n\n接下来 $N-1$ 行，每行两个整数 $A_j,B_j$。", "outputFormat": "样例交互器将向标准输出中输出如下信息：\n\n\n- 如果你的程序被判为正确，它会报告调用 `query` 的次数，如：`Accepted: 2024`。\n- 如果你的程序被判为某种 Wrong Answer，样例交互程序会输出它的类别，如：`Wrong Answer [4]`。\n\n如果你的程序满足多种 Wrong Answer 的类别，样例交互器只会报告其中一个。", "hint": "### 样例交互\n\n#### 样例交互 $1$\n\n样例调用过程如下表所示。\n\n|      调用      |      调用      | 返回值 |\n| :------------: | :------------: | :----: |\n| `solve(4, 16)` |               |        |\n|                | `query(2, 1)`  |  $1$   |\n|                | `query(3, 1)`  |  $4$   |\n|                | `answer(2, 4)` |        |\n|                | `query(2, 2)`  |  $4$   |\n|                | `answer(2, 1)` |        |\n|                | `query(3, 2)`  |  $2$   |\n|                | `query(2, 1)`  |  $1$   |\n|                | `answer(3, 4)` |        |\n\n从岛屿 $2$ 到岛屿 $1,3,4$ 的最小经过航线数分别为 $1,2,1$。例如，从岛屿 $2$ 到岛屿 $3$，我们可以使用航线 $2$ 后使用航线 $3$。\n\n将岛屿按 $\\text{dist}(2,i)\\times N+i\\ (i\\neq 2)$ 递增的顺序排序，结果是岛屿 $1,4,3$。因此，`query(2, 1)` 的返回值为 $1$，`query(2, 2)` 的返回值为 $4$。\n\n样例 $1$ 满足子任务 $2,6$ 的限制。\n\n#### 样例交互 $2$\n\n\n样例调用过程如下表所示。\n\n|      调用      |      调用      | 返回值 |\n| :------------: | :------------: | :----: |\n| `solve(5, 25)` |            |        |\n|                | `query(1, 3)`  |  $5$   |\n|                | `query(1, 4)`  |  $2$   |\n|                | `answer(3, 1)` |        |\n|                | `query(2, 4)`  |  $4$   |\n|                | `query(3, 1)`  |  $1$   |\n|                | `query(3, 2)`  |  $4$   |\n|                | `answer(1, 5)` |        |\n|                | `answer(4, 1)` |      |\n|                | `answer(2, 5)`  |        |\n\n从岛屿 $1$ 到岛屿 $2,3,4,5$ 的最小经过航线数分别为 $2,1,1,1$。例如，从岛屿 $1$ 到岛屿 $2$，我们可以使用航线 $4$ 后使用航线 $1$。\n\n将岛屿按 $\\text{dist}(1,i)\\times N+i\\ (i\\neq 1)$ 递增的顺序排序，结果是岛屿 $3,4,5,2$。因此，`query(1, 3)` 的返回值为 $5$，`query(1, 4)` 的返回值为 $2$。\n\n样例 $2$ 满足子任务 $4,6$ 的限制。\n\n### 数据范围\n\n- $3\\le N\\le 300$\n- $1\\le A_j,B_j\\le N\\ (1\\le j\\le N-1)$\n- $A_j\\neq B_j\\ (1\\le j\\le N-1)$\n- 可以通过航线，从一个岛屿到达任意其他岛屿\n\n### 子任务\n\n| 子任务 |                           附加限制                           | 分值 |\n| :----: | :----------------------------------------------------------: | :--: |\n|  $1$   |                          $N=3,L=9$                           | $2$  |\n|  $2$   |             $L=N^2$，每座岛屿最多有两条航线连接              | $4$  |\n|  $3$   |              $L=2N$，每座岛屿最多有两条航线连接              | $7$  |\n|  $4$   | $L=N^2$，岛屿 $1$ 有三条航线连接，其他每座岛屿最多有两条航线连接 | $9$  |\n|  $5$   | $L=3N$，岛屿 $1$ 有三条航线连接，其他每座岛屿最多有两条航线连接 | $13$ |\n|  $6$   |                           $L=N^2$                            | $15$ |\n|  $7$   |                            $L=3N$                            | $22$ |\n|  $8$   |                            $L=2N$                            | $28$ |", "locale": "zh-CN"}}}
{"pid": "P10441", "type": "P", "difficulty": 7, "samples": [["2\n3 1\n4 4", "Yes\n0\n10\nNo"], ["1\n5 3", "Yes\n0\n11\n001\n0101"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] 乒乓球 / Table Tennis", "background": "", "description": "在 JOI 王国举办了一场乒乓球比赛。 $N$ 只编号从 $1$ 到 $N$ 的海狸参加了这场比赛，并进行了一场循环赛。\n\n你从 Bitaro 那里得知了关于比赛结果的以下信息。\n\n-  没有平局比赛。\n- 正好有 $M$ 种选择 $3$ 只海狸形成“三元悖论”。请注意，只有当以下两个条件之一恰好满足时，$3$ 只海狸 $i, j, k$（$1 \\leq i < j < k \\leq N$）才形成“三元悖论”。\n- - 海狸 $i$ 击败了海狸 $j$，海狸 $j$ 击败了海狸 $k$，海狸 $k$ 又击败了海狸 $i$。\n- - 海狸 $i$ 击败了海狸 $k$，海狸 $k$ 击败了海狸 $j$，海狸 $j$ 又击败了海狸 $i$。\n\n你不确定 Bitaro 提供的信息是否正确，所以你决定思考是否有任何与 Bitaro 提供的信息相符的比赛结果。编写一个程序，根据 Bitaro 提供的信息判断是否有任何比赛结果与信息相符，如果有，找出其中任意一种比赛结果。", "inputFormat": "一个测试案例包括 $Q$ 个场景，编号从 $1$ 到 $Q$。每个场景指定以下数值。\n\n- 参加比赛的海狸数量 $N$。\n- 选择 $3$ 只形成“三元悖论”的海狸的方式数量 $M$。\n\n输入数据的格式如下。\n\n- $Q$\n\n每个场景的输入数据格式如下。\n\n- $N$ $M$", "outputFormat": "对应各个场景，按照以下顺序将答案写入标准输出。\n\n在某些场景中，如果有任何与信息相符的比赛结果，请按照以下方式输出。\n\n- Yes\n- $S_2$\n- $S_3$\n- ...\n- $S_N$\n\n这里，$S_i$（$2 \\leq i \\leq N$）是一个字符为 '0' 或 '1'，长度为 $i-1$ 的字符串。$S_i$ 的第 $j$ 个字符为 '0' 表示海狸 $i$ 被海狸 $j$ 打败，为 '1' 表示海狸 $i$ 打败了海狸 $j$。如果存在多个结果，可以输出任何一个。\n\n在某些场景中，如果没有任何与信息相符的比赛结果，请输出 No。", "hint": "#### 样例解释 1\n\n有 $Q = 2$ 个场景。\n\n在这个示例输出中，场景 $1$ 的结果是，海狸 $1$ 打败了海狸 $2$，海狸 $2$ 打败了海狸 $3$，海狸 $3$ 打败了海狸 $1$。因此，海狸 $1$、$2$、$3$ 形成了“三元悖论”。没有其他方式选择 $3$ 只海狸，所以有确切地 $1$ 种方式选择 $3$ 只形成“三元悖论”的海狸。\n\n对应场景 $1$ 的另一个输出如下。\n\n```\nYes\n1\n01\n```\n\n在场景 $2$ 中，没有任何与信息相符的比赛结果。因此，输出 No。\n\n这个示例输入满足子任务 $2,3,4,5,6$ 的约束条件。\n\n#### 样例解释 2\n\n在这个示例输出中，场景 $1$ 的结果是，海狸 $1$ 打败了海狸 $4$，海狸 $4$ 打败了海狸 $3$，海狸 $3$ 打败了海狸 $1$。因此，海狸 $1,3,4$ 形成了“三元悖论”。还有两种其他方式选择 $3$ 只形成“三元悖论”的海狸：选择海狸 $2,3,4$ 和选择海狸 $3,4,5$。因此，有确切地 $3$ 种方式选择 $3$ 只形成“三元悖论”的海狸。\n\n这个示例输入满足所有子任务的约束条件。\n\n\n### 约束条件\n\n- $1 \\leq Q$．\n- $3 \\leq N \\leq 5000$．\n- $0 \\leq M \\leq \\frac{1}{6} N(N - 1)(N - 2)$．\n- $Q$ 个场景中 $N$ 的总和不超过 5000\n- 给定值均为整数。\n\n### 子任务\n\n1. (5 分) $M \\leq N - 2$．\n2. (4 分) $Q$ 个场景中 $N$ 的总和不超过 7。\n3. (23 分) $Q$ 个场景中 $N$ 的总和不超过 20。\n4. (30 分) $Q$ 个场景中 $N$ 的总和不超过 150。\n5. (15 分) $Q$ 个场景中 $N$ 的总和不超过 600。\n6. (23 分) 无额外约束。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2024] 乒乓球 / Table Tennis", "background": "", "description": "在 JOI 王国举办了一场乒乓球比赛。 $N$ 只编号从 $1$ 到 $N$ 的海狸参加了这场比赛，并进行了一场循环赛。\n\n你从 Bitaro 那里得知了关于比赛结果的以下信息。\n\n-  没有平局比赛。\n- 正好有 $M$ 种选择 $3$ 只海狸形成“三元悖论”。请注意，只有当以下两个条件之一恰好满足时，$3$ 只海狸 $i, j, k$（$1 \\leq i < j < k \\leq N$）才形成“三元悖论”。\n- - 海狸 $i$ 击败了海狸 $j$，海狸 $j$ 击败了海狸 $k$，海狸 $k$ 又击败了海狸 $i$。\n- - 海狸 $i$ 击败了海狸 $k$，海狸 $k$ 击败了海狸 $j$，海狸 $j$ 又击败了海狸 $i$。\n\n你不确定 Bitaro 提供的信息是否正确，所以你决定思考是否有任何与 Bitaro 提供的信息相符的比赛结果。编写一个程序，根据 Bitaro 提供的信息判断是否有任何比赛结果与信息相符，如果有，找出其中任意一种比赛结果。", "inputFormat": "一个测试案例包括 $Q$ 个场景，编号从 $1$ 到 $Q$。每个场景指定以下数值。\n\n- 参加比赛的海狸数量 $N$。\n- 选择 $3$ 只形成“三元悖论”的海狸的方式数量 $M$。\n\n输入数据的格式如下。\n\n- $Q$\n\n每个场景的输入数据格式如下。\n\n- $N$ $M$", "outputFormat": "对应各个场景，按照以下顺序将答案写入标准输出。\n\n在某些场景中，如果有任何与信息相符的比赛结果，请按照以下方式输出。\n\n- Yes\n- $S_2$\n- $S_3$\n- ...\n- $S_N$\n\n这里，$S_i$（$2 \\leq i \\leq N$）是一个字符为 '0' 或 '1'，长度为 $i-1$ 的字符串。$S_i$ 的第 $j$ 个字符为 '0' 表示海狸 $i$ 被海狸 $j$ 打败，为 '1' 表示海狸 $i$ 打败了海狸 $j$。如果存在多个结果，可以输出任何一个。\n\n在某些场景中，如果没有任何与信息相符的比赛结果，请输出 No。", "hint": "#### 样例解释 1\n\n有 $Q = 2$ 个场景。\n\n在这个示例输出中，场景 $1$ 的结果是，海狸 $1$ 打败了海狸 $2$，海狸 $2$ 打败了海狸 $3$，海狸 $3$ 打败了海狸 $1$。因此，海狸 $1$、$2$、$3$ 形成了“三元悖论”。没有其他方式选择 $3$ 只海狸，所以有确切地 $1$ 种方式选择 $3$ 只形成“三元悖论”的海狸。\n\n对应场景 $1$ 的另一个输出如下。\n\n```\nYes\n1\n01\n```\n\n在场景 $2$ 中，没有任何与信息相符的比赛结果。因此，输出 No。\n\n这个示例输入满足子任务 $2,3,4,5,6$ 的约束条件。\n\n#### 样例解释 2\n\n在这个示例输出中，场景 $1$ 的结果是，海狸 $1$ 打败了海狸 $4$，海狸 $4$ 打败了海狸 $3$，海狸 $3$ 打败了海狸 $1$。因此，海狸 $1,3,4$ 形成了“三元悖论”。还有两种其他方式选择 $3$ 只形成“三元悖论”的海狸：选择海狸 $2,3,4$ 和选择海狸 $3,4,5$。因此，有确切地 $3$ 种方式选择 $3$ 只形成“三元悖论”的海狸。\n\n这个示例输入满足所有子任务的约束条件。\n\n\n### 约束条件\n\n- $1 \\leq Q$．\n- $3 \\leq N \\leq 5000$．\n- $0 \\leq M \\leq \\frac{1}{6} N(N - 1)(N - 2)$．\n- $Q$ 个场景中 $N$ 的总和不超过 5000\n- 给定值均为整数。\n\n### 子任务\n\n1. (5 分) $M \\leq N - 2$．\n2. (4 分) $Q$ 个场景中 $N$ 的总和不超过 7。\n3. (23 分) $Q$ 个场景中 $N$ 的总和不超过 20。\n4. (30 分) $Q$ 个场景中 $N$ 的总和不超过 150。\n5. (15 分) $Q$ 个场景中 $N$ 的总和不超过 600。\n6. (23 分) 无额外约束。", "locale": "zh-CN"}}}
{"pid": "P10442", "type": "P", "difficulty": 1, "samples": [["abc\nbc", "2"], ["aaaaa\nbbbbb", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "字符串", "洛谷原创", "O2优化", "洛谷月赛"], "title": "「MYOI-R3」字符串", "background": "", "description": "给定字符串 $s,t$。\n\n现在你要在 $s,t$ 中删除一些字符并将它们重新排列使 $s=t$。\n\n问操作后的 $|s|$（即字符串 $s$ 的长度）最大是多少？", "inputFormat": "第一行一个字符串 $s$。\n\n第二行一个字符串 $t$。\n", "outputFormat": "一行一个整数，表示操作后的 $|s|$ 的最大值。", "hint": "在第一个样例中，将 `a` 删除，留下 `bc`。\n\n此时 $|s|=2$，可以证明这是最优解。\n\n在第二个样例中，将 `aaaaa` 删除，留下空串。\n将 `bbbbb` 删除，留下空串。\n\n此时 $|s|=0$，可以证明这是最优解。\n\n**本题采用捆绑测试**。\n\n记 $n=\\max(|s|,|t|)$。\n\n| $\\text{Subtask}$ | $n\\le $|  特殊性质 |总分值 |\n| :--------------: | :-----: |:-----:|:--------: |\n|       $1$        |  $10$ |  无  | $25$ |\n$2$        | $10^5$  | $\\text{A}$|  $25$ |\n|       $3$        | $10^5$  | $\\text{B}$ | $25$ |\n|       $4$        | $10^5$ |     无     | $25$ |\n\n\n对于 $100\\%$ 的数据，$1  \\le |s|,|t| \\le 10^5$，字符串均由小写字母组成。\n\n特殊性质 $\\text{A}$：$s$ 是一个 $\\text{a}\\sim\\text{z}$ 的排列。\n\n特殊性质 $\\text{B}$：保证 $s_i,t_i\\in\\{\\text{a},\\text{b} \\}$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「MYOI-R3」字符串", "background": "", "description": "给定字符串 $s,t$。\n\n现在你要在 $s,t$ 中删除一些字符并将它们重新排列使 $s=t$。\n\n问操作后的 $|s|$（即字符串 $s$ 的长度）最大是多少？", "inputFormat": "第一行一个字符串 $s$。\n\n第二行一个字符串 $t$。\n", "outputFormat": "一行一个整数，表示操作后的 $|s|$ 的最大值。", "hint": "在第一个样例中，将 `a` 删除，留下 `bc`。\n\n此时 $|s|=2$，可以证明这是最优解。\n\n在第二个样例中，将 `aaaaa` 删除，留下空串。\n将 `bbbbb` 删除，留下空串。\n\n此时 $|s|=0$，可以证明这是最优解。\n\n**本题采用捆绑测试**。\n\n记 $n=\\max(|s|,|t|)$。\n\n| $\\text{Subtask}$ | $n\\le $|  特殊性质 |总分值 |\n| :--------------: | :-----: |:-----:|:--------: |\n|       $1$        |  $10$ |  无  | $25$ |\n$2$        | $10^5$  | $\\text{A}$|  $25$ |\n|       $3$        | $10^5$  | $\\text{B}$ | $25$ |\n|       $4$        | $10^5$ |     无     | $25$ |\n\n\n对于 $100\\%$ 的数据，$1  \\le |s|,|t| \\le 10^5$，字符串均由小写字母组成。\n\n特殊性质 $\\text{A}$：$s$ 是一个 $\\text{a}\\sim\\text{z}$ 的排列。\n\n特殊性质 $\\text{B}$：保证 $s_i,t_i\\in\\{\\text{a},\\text{b} \\}$。\n", "locale": "zh-CN"}}}
{"pid": "P10443", "type": "P", "difficulty": 3, "samples": [["2\n3\n1 2 3\n3\n1 2 4", "Yes\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "O2优化", "最大公约数 gcd", "洛谷月赛"], "title": "「MYOI-R3」消消乐", "background": "**upd 2024/5/12 18:14：增加了两组 Hack 数据，位于 Subtask 1，分值为 $0$ 分。**\n\n**upd 2024/5/12 21:27：增加了一组 Hack 数据，位于 Subtask 1，分值为 $0$ 分。**", "description": "给定一个长度为 $n$ 的数列 $a$。\n\n定义一次操作为选择三个整数 $x,y,z\\in[1,n]$，满足 $\\gcd(a_x,a_y)=a_z$ 且 $x,y,z$ 两两不同，接着消除 $a_z$（即之后的操作中不能再选择 $a_z$ 了）。\n\n问经过若干次操作后可否消除数列 $a_1\\sim a_n$ 中的 $n-2$ 个数？", "inputFormat": "第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据，\n\n第一行一个正整数 $n$。\n\n第二行 $n$ 个正整数 $a_i$。", "outputFormat": "对于每组数据，一行一个字符串 `Yes` 或 `No`。", "hint": "### 样例解释：\n\n- 对于第一组数据，可以通过 $(2,3)$ 消除 $1$。\n- 对于第二组数据，可以证明无解。\n\n### 数据范围：\n\n本题共有 $20$ 个测试点，每个测试点的分值均为 $5$ 分。\n\n对于 $100\\%$ 的数据，$1\\le T\\le 10^5$，$2\\leq n \\leq 10^6$，$2 \\le \\sum n\\le 10^6$，$1\\le a_i\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「MYOI-R3」消消乐", "background": "**upd 2024/5/12 18:14：增加了两组 Hack 数据，位于 Subtask 1，分值为 $0$ 分。**\n\n**upd 2024/5/12 21:27：增加了一组 Hack 数据，位于 Subtask 1，分值为 $0$ 分。**", "description": "给定一个长度为 $n$ 的数列 $a$。\n\n定义一次操作为选择三个整数 $x,y,z\\in[1,n]$，满足 $\\gcd(a_x,a_y)=a_z$ 且 $x,y,z$ 两两不同，接着消除 $a_z$（即之后的操作中不能再选择 $a_z$ 了）。\n\n问经过若干次操作后可否消除数列 $a_1\\sim a_n$ 中的 $n-2$ 个数？", "inputFormat": "第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据，\n\n第一行一个正整数 $n$。\n\n第二行 $n$ 个正整数 $a_i$。", "outputFormat": "对于每组数据，一行一个字符串 `Yes` 或 `No`。", "hint": "### 样例解释：\n\n- 对于第一组数据，可以通过 $(2,3)$ 消除 $1$。\n- 对于第二组数据，可以证明无解。\n\n### 数据范围：\n\n本题共有 $20$ 个测试点，每个测试点的分值均为 $5$ 分。\n\n对于 $100\\%$ 的数据，$1\\le T\\le 10^5$，$2\\leq n \\leq 10^6$，$2 \\le \\sum n\\le 10^6$，$1\\le a_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10444", "type": "P", "difficulty": 3, "samples": [["2 1\n6\n1 1 4 5 1 4\n7\n1 9 1 9 8 1 0", "No\nYes"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "二分", "洛谷原创", "O2优化", "洛谷月赛", "双指针 two-pointer", "Ad-hoc"], "title": "「MYOI-R3」极差", "background": "", "description": "对于一个序列 $c$ ，定义 $c$ 的极差为 $c$ 中最大值与最小值之差。现在给定一个长度为 $n$ 的序列 $a$，问是否能将其分成至少两个长度大于 $1$ 的子序列，使得每个子序列的极差都相等（注意，所有元素都必须分配且每个元素仅能分配到一个子序列中）。", "inputFormat": "**本题包含多组数据**。\n\n第一行两个整数 $T,id$，表示数据组数和子任务编号。\n\n对于每组数据，\n\n第一行一个正整数 $n$，表示数组长度。\n\n第二行 $n$ 个整数表示序列 $a$。", "outputFormat": "\n对于每组数据，输出一行一个字符串 `Yes` 或 `No`。", "hint": "### 样例 $\\small\\text{1}$ 解释\n\n样例符合子任务 1 的约束，$id=1$。\n\n\n询问一：\n\n可以证明，没有任何方案满足条件。\n\n询问二：\n\n合法分配的一种子序列集合如下：\n- $\\{1,9\\}$。\n- $\\{1,9\\}$。\n- $\\{8,1,0\\}$。\n\n答案不唯一。\n\n### 数据规模与约定\n\n**本题采用捆绑测试**。\n\n- Subtask 1（20 points）：$4\\le \\sum n\\le 20,a_i\\ge 0$。\n- Subtask 2（20 points）：$4\\le \\sum n\\le 100,a_i\\ge 0$。\n- Subtask 3（20 points）：$4\\le \\sum n\\le 10^3,a_i\\ge 0$。\n- Subtask 4（10 points）：$a$ 数组中元素相等。\n- Subtask 5（30 points）：无特殊限制。\n\n\n对于 $100\\%$ 的数据，$4\\le \\sum n\\le 10^6,0\\le |a_i|\\le 10^9,1\\le T\\le 300$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「MYOI-R3」极差", "background": "", "description": "对于一个序列 $c$ ，定义 $c$ 的极差为 $c$ 中最大值与最小值之差。现在给定一个长度为 $n$ 的序列 $a$，问是否能将其分成至少两个长度大于 $1$ 的子序列，使得每个子序列的极差都相等（注意，所有元素都必须分配且每个元素仅能分配到一个子序列中）。", "inputFormat": "**本题包含多组数据**。\n\n第一行两个整数 $T,id$，表示数据组数和子任务编号。\n\n对于每组数据，\n\n第一行一个正整数 $n$，表示数组长度。\n\n第二行 $n$ 个整数表示序列 $a$。", "outputFormat": "\n对于每组数据，输出一行一个字符串 `Yes` 或 `No`。", "hint": "### 样例 $\\small\\text{1}$ 解释\n\n样例符合子任务 1 的约束，$id=1$。\n\n\n询问一：\n\n可以证明，没有任何方案满足条件。\n\n询问二：\n\n合法分配的一种子序列集合如下：\n- $\\{1,9\\}$。\n- $\\{1,9\\}$。\n- $\\{8,1,0\\}$。\n\n答案不唯一。\n\n### 数据规模与约定\n\n**本题采用捆绑测试**。\n\n- Subtask 1（20 points）：$4\\le \\sum n\\le 20,a_i\\ge 0$。\n- Subtask 2（20 points）：$4\\le \\sum n\\le 100,a_i\\ge 0$。\n- Subtask 3（20 points）：$4\\le \\sum n\\le 10^3,a_i\\ge 0$。\n- Subtask 4（10 points）：$a$ 数组中元素相等。\n- Subtask 5（30 points）：无特殊限制。\n\n\n对于 $100\\%$ 的数据，$4\\le \\sum n\\le 10^6,0\\le |a_i|\\le 10^9,1\\le T\\le 300$。\n", "locale": "zh-CN"}}}
{"pid": "P10445", "type": "P", "difficulty": 4, "samples": [["3 11 3\n1 -3 4 ", "3\n1 2 3"], ["5 15 3\n-5 -10 0 5 10 ", "3\n2 1 3 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "二分", "洛谷原创", "Special Judge", "O2优化", "洛谷月赛", "双指针 two-pointer"], "title": "「MYOI-R3」签到", "background": "Updated on 2024/5/12：新增两组 hack 数据，位于 Subtask #5 的 #31 和 #32。\n\nUpdated on 2024/5/13：由于争议过大，目前难度已降绿。暂时不考虑再次变动本题难度。", "description": "这一场比赛为了选手顺利完成签到题，设置有 $n$ 个签到处，你和它们都在一条笔直的公路上，我们不妨把这条笔直的公路看作成一条数轴，你现在在数轴原点的位置上（即坐标为 $0$），第 $i$ 个签到处在坐标为 $x_i$ 的地方，你在每个时间单位内**最多**可以移动 $1$ 个单位长度。\n\n你需要去**尽量多**的签到处签到，然后在 $m$ 个时间单位内回到数轴原点。签到的时间可以**忽略不计**，而且你可能在同一地点瞬间完成**位于同一位置的多个不同签到处**的签到。\n\n出题人为了让各位选手们更方便、更顺利地签到，还在场上第 $p$ 个签到处放置了签到礼物。如果选手在这里**签过到**，那么回到原点的时间限制可以被**推迟到** $m+5$ 个单位时间。注：你可以在第 $m$ 个时刻后才获得礼物，但你必须在 $m+5$ 个单位时间前回到原点。\n\n求选手**最多**可以在多少个不同的签到处签到，并在此前提下**最小化**签过到的签到处的编号的集合的字典序（如果有多解，输出任意一个方案即可）。\n\n注：集合的字典序等价于把集合内的元素从小到大排序之后的序列的字典序。", "inputFormat": "第一行，三个整数 $n,m,p$。\n\n第二行，一共 $n$ 个整数，第 $i$ 个整数表示 $x_i$。", "outputFormat": "第一行，一个整数 $ans$，表示你最多能去签到的签到处的数量。\n\n第二行，输出 $ans$ 个正整数，表示**依次要去签到**的签到处的编号。\n\n**本题采用 Special Judge，如果有多解，输出任意一个即可。**", "hint": "### 样例 $\\small\\text{1}$ 解释\n\n\n很显然，可以去所有的签到处签到，输出一个耗时不超过 $16$ 的行动方案即可。\n\n### 样例 $\\small\\text{2}$ 解释\n\n要去 $3$ 个签到处签到一共有 $3$ 种不同的选择方案：$1$ $2$ $3$、$1$ $3$ $4$、$3$ $4$ $5$，显然，第一种选择最优，选择以下四种行动方案 $1$ $2$ $3$、$2$ $1$ $3$、$3$ $1$ $2$、$3$ $2$ $1$ 皆可。\n\n### 数据规模与约定\n\n**本题采用捆绑测试**。\n\n**本题采用「Special Judge」。**\n\n|$\\textbf{Subtask}$ | $\\textbf{Special conditions}$ |$\\textbf{Points}$ |\n| :----------: | :----------: | :----------: | \n| $0$ | 是样例 | $0$ |\n| $1$ | $n\\leq 15$ | $10$ |\n| $2$ | $n\\leq 300$ | $15$ |\n| $3$ | $n\\leq 7\\times 10^3$ | $20$ |\n| $4$ | $n\\leq 10^5$ | $25$ |\n| $5$ | 无 | $30$ |\n\n**请注意大量数据的输入输出对程序效率的影响。**\n\n**保证本题的时间限制足够长。**\n\n对于 $100\\%$ 的数据，$1\\leq p\\leq n\\leq 10^6$，$0\\leq m\\leq 10^{18}$，$-10^{18}\\leq x_i\\leq 10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「MYOI-R3」签到", "background": "Updated on 2024/5/12：新增两组 hack 数据，位于 Subtask #5 的 #31 和 #32。\n\nUpdated on 2024/5/13：由于争议过大，目前难度已降绿。暂时不考虑再次变动本题难度。", "description": "这一场比赛为了选手顺利完成签到题，设置有 $n$ 个签到处，你和它们都在一条笔直的公路上，我们不妨把这条笔直的公路看作成一条数轴，你现在在数轴原点的位置上（即坐标为 $0$），第 $i$ 个签到处在坐标为 $x_i$ 的地方，你在每个时间单位内**最多**可以移动 $1$ 个单位长度。\n\n你需要去**尽量多**的签到处签到，然后在 $m$ 个时间单位内回到数轴原点。签到的时间可以**忽略不计**，而且你可能在同一地点瞬间完成**位于同一位置的多个不同签到处**的签到。\n\n出题人为了让各位选手们更方便、更顺利地签到，还在场上第 $p$ 个签到处放置了签到礼物。如果选手在这里**签过到**，那么回到原点的时间限制可以被**推迟到** $m+5$ 个单位时间。注：你可以在第 $m$ 个时刻后才获得礼物，但你必须在 $m+5$ 个单位时间前回到原点。\n\n求选手**最多**可以在多少个不同的签到处签到，并在此前提下**最小化**签过到的签到处的编号的集合的字典序（如果有多解，输出任意一个方案即可）。\n\n注：集合的字典序等价于把集合内的元素从小到大排序之后的序列的字典序。", "inputFormat": "第一行，三个整数 $n,m,p$。\n\n第二行，一共 $n$ 个整数，第 $i$ 个整数表示 $x_i$。", "outputFormat": "第一行，一个整数 $ans$，表示你最多能去签到的签到处的数量。\n\n第二行，输出 $ans$ 个正整数，表示**依次要去签到**的签到处的编号。\n\n**本题采用 Special Judge，如果有多解，输出任意一个即可。**", "hint": "### 样例 $\\small\\text{1}$ 解释\n\n\n很显然，可以去所有的签到处签到，输出一个耗时不超过 $16$ 的行动方案即可。\n\n### 样例 $\\small\\text{2}$ 解释\n\n要去 $3$ 个签到处签到一共有 $3$ 种不同的选择方案：$1$ $2$ $3$、$1$ $3$ $4$、$3$ $4$ $5$，显然，第一种选择最优，选择以下四种行动方案 $1$ $2$ $3$、$2$ $1$ $3$、$3$ $1$ $2$、$3$ $2$ $1$ 皆可。\n\n### 数据规模与约定\n\n**本题采用捆绑测试**。\n\n**本题采用「Special Judge」。**\n\n|$\\textbf{Subtask}$ | $\\textbf{Special conditions}$ |$\\textbf{Points}$ |\n| :----------: | :----------: | :----------: | \n| $0$ | 是样例 | $0$ |\n| $1$ | $n\\leq 15$ | $10$ |\n| $2$ | $n\\leq 300$ | $15$ |\n| $3$ | $n\\leq 7\\times 10^3$ | $20$ |\n| $4$ | $n\\leq 10^5$ | $25$ |\n| $5$ | 无 | $30$ |\n\n**请注意大量数据的输入输出对程序效率的影响。**\n\n**保证本题的时间限制足够长。**\n\n对于 $100\\%$ 的数据，$1\\leq p\\leq n\\leq 10^6$，$0\\leq m\\leq 10^{18}$，$-10^{18}\\leq x_i\\leq 10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P10446", "type": "P", "difficulty": 2, "samples": [["3\n4\n5", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": [], "title": "64位整数乘法", "background": "", "description": "求 $a$ 乘 $b$ 对 $p$ 取模的值。", "inputFormat": "第一行输入整数 $a$，第二行输入整数 $b$，第三行输入整数 $p$。", "outputFormat": "输出一个整数，表示 `a*b mod p` 的值。", "hint": "$1 \\le a,b,p \\le 10^{18}$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "64位整数乘法", "background": "", "description": "求 $a$ 乘 $b$ 对 $p$ 取模的值。", "inputFormat": "第一行输入整数 $a$，第二行输入整数 $b$，第三行输入整数 $p$。", "outputFormat": "输出一个整数，表示 `a*b mod p` 的值。", "hint": "$1 \\le a,b,p \\le 10^{18}$", "locale": "zh-CN"}}}
{"pid": "P10447", "type": "P", "difficulty": 4, "samples": [["5\n0 2 4 5 1\n2 0 6 5 3\n4 6 0 8 3\n5 5 8 0 5\n1 3 3 5 0", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["状压 DP"], "title": "最短 Hamilton 路径", "background": "", "description": "给定一张 $n$ 个点的带权无向图，点从 $0 \\sim n-1$ 标号，求起点 $0$ 到终点 $n-1$ 的最短 Hamilton 路径。 \n\nHamilton 路径的定义是从 $0$ 到 $n-1$ 不重不漏地经过每个点恰好一次。", "inputFormat": "第一行输入整数 $n$。\n\n接下来 $n$ 行每行 $n$ 个整数，其中第 $i$ 行第 $j$ 个整数表示点 $i-1$ 到 $j-1$ 的距离（记为 $a[i-1,j-1]$）。\n\n对于任意的 $x,y,z$，数据保证 $a[x,x]=0，a[x,y]=a[y,x]$ 并且 $a[x,y]+a[y,z] \\ge a[x,z]$。", "outputFormat": "输出一个整数，表示最短 Hamilton 路径的长度。", "hint": "对于所有测试数据满足 $1 \\le n \\le 20$，$0 \\le a[i,j] \\le 10^7$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "最短 Hamilton 路径", "background": "", "description": "给定一张 $n$ 个点的带权无向图，点从 $0 \\sim n-1$ 标号，求起点 $0$ 到终点 $n-1$ 的最短 Hamilton 路径。 \n\nHamilton 路径的定义是从 $0$ 到 $n-1$ 不重不漏地经过每个点恰好一次。", "inputFormat": "第一行输入整数 $n$。\n\n接下来 $n$ 行每行 $n$ 个整数，其中第 $i$ 行第 $j$ 个整数表示点 $i-1$ 到 $j-1$ 的距离（记为 $a[i-1,j-1]$）。\n\n对于任意的 $x,y,z$，数据保证 $a[x,x]=0，a[x,y]=a[y,x]$ 并且 $a[x,y]+a[y,z] \\ge a[x,z]$。", "outputFormat": "输出一个整数，表示最短 Hamilton 路径的长度。", "hint": "对于所有测试数据满足 $1 \\le n \\le 20$，$0 \\le a[i,j] \\le 10^7$", "locale": "zh-CN"}}}
{"pid": "P10448", "type": "P", "difficulty": 2, "samples": [["5 3", "1 2 3 \n1 2 4 \n1 2 5 \n1 3 4 \n1 3 5 \n1 4 5 \n2 3 4 \n2 3 5 \n2 4 5 \n3 4 5 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["深度优先搜索 DFS"], "title": "组合型枚举", "background": "", "description": "从 $1 \\sim n$ 这 $n$ 个整数中随机选出 $m$ 个，输出所有可能的选择方案。", "inputFormat": "两个整数 $n, m$ ,在同一行用空格隔开。", "outputFormat": "按照从小到大的顺序输出所有方案，每行 $1$ 个。\n\n首先，同一行内的数升序排列，相邻两个数用一个空格隔开。\n\n其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 `1 3 5 7` 排在 `1 3 6 8` 前面）。", "hint": "对于所有测试数据满足 $0 \\le m \\le n$ ,  $ n+(n-m) \\le 25 $。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "组合型枚举", "background": "", "description": "从 $1 \\sim n$ 这 $n$ 个整数中随机选出 $m$ 个，输出所有可能的选择方案。", "inputFormat": "两个整数 $n, m$ ,在同一行用空格隔开。", "outputFormat": "按照从小到大的顺序输出所有方案，每行 $1$ 个。\n\n首先，同一行内的数升序排列，相邻两个数用一个空格隔开。\n\n其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 `1 3 5 7` 排在 `1 3 6 8` 前面）。", "hint": "对于所有测试数据满足 $0 \\le m \\le n$ ,  $ n+(n-m) \\le 25 $。", "locale": "zh-CN"}}}
{"pid": "P10449", "type": "P", "difficulty": 4, "samples": [["3\n00111\n01011\n10001\n11010\n11100\n\n11101\n11101\n11110\n11111\n11111\n\n01111\n11111\n11111\n11111\n11111", "3\n2\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "深度优先搜索 DFS", "状压 DP"], "title": "费解的开关", "background": "", "description": "你玩过“拉灯”游戏吗？\n\n$25$ 盏灯排成一个 $5 \\times 5$ 的方形。\n\n每一个灯都有一个开关，游戏者可以改变它的状态。\n\n每一步，游戏者可以改变某一个灯的状态。\n\n游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。\n\n我们用数字 $1$ 表示一盏开着的灯，用数字 $0$ 表示关着的灯。\n\n下面这种状态\n\n    10111\n    01101\n    10111\n    10000\n    11011\n\n\n在改变了最左上角的灯的状态后将变成：\n\n    01111\n    11101\n    10111\n    10000\n    11011\n\n\n再改变它正中间的灯后状态将变成：\n\n    01111\n    11001\n    11001\n    10100\n    11011\n\n\n给定一些游戏的初始状态，编写程序判断游戏者是否可能在 $6$ 步以内使所有的灯都变亮。", "inputFormat": "第一行输入正整数 $n$，代表数据中共有 $n$ 个待解决的游戏初始状态。\n\n以下若干行数据分为 $n$ 组，每组数据有 $5$ 行，每行 $5$ 个字符。\n\n每组数据描述了一个游戏的初始状态。\n\n各组数据间用一个空行分隔。", "outputFormat": "一共输出 $n$ 行数据，每行有一个小于等于 $6$ 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。\n\n对于某一个游戏初始状态，若 $6$ 步以内无法使所有灯变亮，则输出 `-1`。", "hint": "测试数据满足 $0 < n \\le 500$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "费解的开关", "background": "", "description": "你玩过“拉灯”游戏吗？\n\n$25$ 盏灯排成一个 $5 \\times 5$ 的方形。\n\n每一个灯都有一个开关，游戏者可以改变它的状态。\n\n每一步，游戏者可以改变某一个灯的状态。\n\n游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。\n\n我们用数字 $1$ 表示一盏开着的灯，用数字 $0$ 表示关着的灯。\n\n下面这种状态\n\n    10111\n    01101\n    10111\n    10000\n    11011\n\n\n在改变了最左上角的灯的状态后将变成：\n\n    01111\n    11101\n    10111\n    10000\n    11011\n\n\n再改变它正中间的灯后状态将变成：\n\n    01111\n    11001\n    11001\n    10100\n    11011\n\n\n给定一些游戏的初始状态，编写程序判断游戏者是否可能在 $6$ 步以内使所有的灯都变亮。", "inputFormat": "第一行输入正整数 $n$，代表数据中共有 $n$ 个待解决的游戏初始状态。\n\n以下若干行数据分为 $n$ 组，每组数据有 $5$ 行，每行 $5$ 个字符。\n\n每组数据描述了一个游戏的初始状态。\n\n各组数据间用一个空行分隔。", "outputFormat": "一共输出 $n$ 行数据，每行有一个小于等于 $6$ 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。\n\n对于某一个游戏初始状态，若 $6$ 步以内无法使所有灯变亮，则输出 `-1`。", "hint": "测试数据满足 $0 < n \\le 500$。", "locale": "zh-CN"}}}
{"pid": "P10450", "type": "P", "difficulty": 3, "samples": [["10 6\n6 4 2 10 3 8 5 9 4 1", "6500"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2003", "二分", "USACO", "单调队列", "前缀和"], "title": "[USACO03MAR] Best Cow Fences G", "background": "", "description": "**原题来自：USACO 2003 Mar. Green**\n\n给定一个长度为 $n$ 的非负整数序列 $A$ ，求一个平均数最大的，长度不小于 $L$ 的子段。", "inputFormat": "第一行用空格分隔的两个整数 $n$ 和 $L$；\n\n第二行为 $n$ 个用空格隔开的非负整数，表示 $A_i$。", "outputFormat": "输出一个整数，表示这个平均数的 $1000$ 倍。不用四舍五入，直接输出。", "hint": "$1 \\leq n \\leq 10^5,0 \\leq A_i \\leq 2000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO03MAR] Best Cow Fences G", "background": "", "description": "**原题来自：USACO 2003 Mar. Green**\n\n给定一个长度为 $n$ 的非负整数序列 $A$ ，求一个平均数最大的，长度不小于 $L$ 的子段。", "inputFormat": "第一行用空格分隔的两个整数 $n$ 和 $L$；\n\n第二行为 $n$ 个用空格隔开的非负整数，表示 $A_i$。", "outputFormat": "输出一个整数，表示这个平均数的 $1000$ 倍。不用四舍五入，直接输出。", "hint": "$1 \\leq n \\leq 10^5,0 \\leq A_i \\leq 2000$。", "locale": "zh-CN"}}}
{"pid": "P10451", "type": "P", "difficulty": 3, "samples": [["3\n\n1\n\n0\n\n0", "? 1 2\n\n? 1 3\n\n? 2 3\n\n! 3 1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["交互题", "Special Judge", "O2优化"], "title": "Innovative Business", "background": "", "description": "有 $N$ 个元素，编号 $1,2,\\dots,N$，每一对元素之间的大小关系是确定的，关系具有反对称性，但不具有传递性。\n\n**注意**：不存在两个元素大小相等的情况。\n\n也就是说，元素的大小关系是 $N$ 个点与 $\\frac{N \\times (N-1)}{2}$ 条有向边构成的任意有向图。\n\n然而，这是一道交互式试题，这些关系不能一次性得知，你必须通过不超过 $10000$ 次提问来获取信息，每次提问只能了解某两个元素之间的关系。\n\n现在请你把这 $N$ 个元素排成一行，使得每个元素都小于右边与它相邻的元素。\n\n你可以通过我们预设的 bool 函数 compare 来获得两个元素之间的大小关系。\n\n例如，编号为 $a$ 和 $b$ 的两个元素，如果元素 $a$ 小于元素 $b$，则 compare(a,b) 返回 true，否则返回 false。\n\n将 $N$ 个元素排好序后，把他们的编号以数组的形式输出，如果答案不唯一，则输出任意一个均可。\n\n---\n\n为了适配 OJ，本题交互格式进行修改。改为 I/O 交互。\n\n```cpp\nbool compare(int a, int b)\n{\n    cout << \"? \" << a << ' ' << b << endl;\n    bool t;\n    cin >> t;\n    return t;\n}\n```\n\n请在代码里填写此函数。**擅自修改内容后果自负。**", "inputFormat": "交互库会先给出一个正整数 $N$ 表示元素数量。\n\n之后的每次回答，交互库会返回 $1$ 或 $0$ 表示大小关系。$1$ 代表 $\\text{true}$，$0$ 代表 $\\text{false}$。", "outputFormat": "你可以使用题面中的 `compare` 函数进行提问。如要自己编写询问，询问格式为 `? a b`。\n\n输出答案之前请先给出一个感叹号 `!`。之后用空格分割这 $n$ 个编号。具体见样例 #1.", "hint": "测试数据满足 $1 \\le N \\le 1000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Innovative Business", "background": "", "description": "有 $N$ 个元素，编号 $1,2,\\dots,N$，每一对元素之间的大小关系是确定的，关系具有反对称性，但不具有传递性。\n\n**注意**：不存在两个元素大小相等的情况。\n\n也就是说，元素的大小关系是 $N$ 个点与 $\\frac{N \\times (N-1)}{2}$ 条有向边构成的任意有向图。\n\n然而，这是一道交互式试题，这些关系不能一次性得知，你必须通过不超过 $10000$ 次提问来获取信息，每次提问只能了解某两个元素之间的关系。\n\n现在请你把这 $N$ 个元素排成一行，使得每个元素都小于右边与它相邻的元素。\n\n你可以通过我们预设的 bool 函数 compare 来获得两个元素之间的大小关系。\n\n例如，编号为 $a$ 和 $b$ 的两个元素，如果元素 $a$ 小于元素 $b$，则 compare(a,b) 返回 true，否则返回 false。\n\n将 $N$ 个元素排好序后，把他们的编号以数组的形式输出，如果答案不唯一，则输出任意一个均可。\n\n---\n\n为了适配 OJ，本题交互格式进行修改。改为 I/O 交互。\n\n```cpp\nbool compare(int a, int b)\n{\n    cout << \"? \" << a << ' ' << b << endl;\n    bool t;\n    cin >> t;\n    return t;\n}\n```\n\n请在代码里填写此函数。**擅自修改内容后果自负。**", "inputFormat": "交互库会先给出一个正整数 $N$ 表示元素数量。\n\n之后的每次回答，交互库会返回 $1$ 或 $0$ 表示大小关系。$1$ 代表 $\\text{true}$，$0$ 代表 $\\text{false}$。", "outputFormat": "你可以使用题面中的 `compare` 函数进行提问。如要自己编写询问，询问格式为 `? a b`。\n\n输出答案之前请先给出一个感叹号 `!`。之后用空格分割这 $n$ 个编号。具体见样例 #1.", "hint": "测试数据满足 $1 \\le N \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P10452", "type": "P", "difficulty": 2, "samples": [["4\n6 2 9 1", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "排序"], "title": "货仓选址", "background": null, "description": "在一条数轴上有 $N$ 家商店，它们的坐标分别为 $A_1 \\sim A_N$。\n\n现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。\n\n为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。", "inputFormat": "第一行输入整数 $N$。\n\n第二行 $N$ 个整数 $A_1 \\sim A_N$。", "outputFormat": "输出一个整数，表示距离之和的最小值。", "hint": "数据保证，$1 \\le N \\le 10^5$，$0 \\le A_i \\le 40000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "货仓选址", "background": null, "description": "在一条数轴上有 $N$ 家商店，它们的坐标分别为 $A_1 \\sim A_N$。\n\n现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。\n\n为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。", "inputFormat": "第一行输入整数 $N$。\n\n第二行 $N$ 个整数 $A_1 \\sim A_N$。", "outputFormat": "输出一个整数，表示距离之和的最小值。", "hint": "数据保证，$1 \\le N \\le 10^5$，$0 \\le A_i \\le 40000$。", "locale": "zh-CN"}}}
{"pid": "P10453", "type": "P", "difficulty": 5, "samples": [["2 3 4\n1 3\n2 1\n2 2\n2 3", "row 1"], ["3 3 3\n1 3\n2 2\n2 3", "both 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "前缀和"], "title": "七夕祭", "background": "", "description": "七夕节因牛郎织女的传说而被扣上了「情人节」的帽子。\n\n于是 TYVJ 今年举办了一次线下七夕祭。\n\nVani 同学今年成功邀请到了 cl 同学陪他来共度七夕，于是他们决定去 TYVJ 七夕祭游玩。\n\nTYVJ 七夕祭和 11 区的夏祭的形式很像。\n\n矩形的祭典会场由 $N$ 排 $M$ 列共计 $N \\times M$ 个摊点组成。\n\n虽然摊点种类繁多，不过 cl 只对其中的一部分摊点感兴趣，比如章鱼烧、苹果糖、棉花糖、射的屋……什么的。\n\nVani 预先联系了七夕祭的负责人 zhq，希望能够通过恰当地布置会场，使得各行中 cl 感兴趣的摊点数一样多，并且各列中 cl 感兴趣的摊点数也一样多。\n\n不过 zhq 告诉 Vani，摊点已经随意布置完毕了，如果想满足 cl 的要求，唯一的调整方式就是交换两个相邻的摊点。\n\n两个摊点相邻，当且仅当他们处在同一行或者同一列的相邻位置上。\n\n由于 zhq 率领的 TYVJ 开发小组成功地扭曲了空间，每一行或每一列的第一个位置和最后一个位置也算作相邻。\n\n现在 Vani 想知道他的两个要求最多能满足多少个。\n\n在此前提下，至少需要交换多少次摊点。", "inputFormat": "第一行包含三个整数 $N$ 和 $M$ 和 $T$，$T$ 表示 cl 对多少个摊点感兴趣。\n\n接下来 $T$ 行，每行两个整数 $x, y$，表示 cl 对处在第 $x$ 行第 $y$ 列的摊点感兴趣。\n", "outputFormat": "首先输出一个字符串。\n\n如果能满足 Vani 的全部两个要求，输出 `both`；\n\n如果通过调整只能使得各行中 cl 感兴趣的摊点数一样多，输出 `row`；\n\n如果只能使各列中 cl 感兴趣的摊点数一样多，输出 `column`；\n\n如果均不能满足，输出 `impossible`。\n\n如果输出的字符串不是 `impossible`， 接下来输出最小交换次数，与字符串之间用一个空格隔开。", "hint": "对于 $30\\%$ 的数据，$N,M \\le 100$。\n\n对于 $70\\%$ 的数据，$N,M \\le 1000$。\n\n对于 $100\\%$ 的数据，$1 \\le N,M \\le 100000$，$0 \\le T \\le \\min(N\\times M,100000)$，$1 \\le x \\le N$，$1 \\le y \\le M$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "七夕祭", "background": "", "description": "七夕节因牛郎织女的传说而被扣上了「情人节」的帽子。\n\n于是 TYVJ 今年举办了一次线下七夕祭。\n\nVani 同学今年成功邀请到了 cl 同学陪他来共度七夕，于是他们决定去 TYVJ 七夕祭游玩。\n\nTYVJ 七夕祭和 11 区的夏祭的形式很像。\n\n矩形的祭典会场由 $N$ 排 $M$ 列共计 $N \\times M$ 个摊点组成。\n\n虽然摊点种类繁多，不过 cl 只对其中的一部分摊点感兴趣，比如章鱼烧、苹果糖、棉花糖、射的屋……什么的。\n\nVani 预先联系了七夕祭的负责人 zhq，希望能够通过恰当地布置会场，使得各行中 cl 感兴趣的摊点数一样多，并且各列中 cl 感兴趣的摊点数也一样多。\n\n不过 zhq 告诉 Vani，摊点已经随意布置完毕了，如果想满足 cl 的要求，唯一的调整方式就是交换两个相邻的摊点。\n\n两个摊点相邻，当且仅当他们处在同一行或者同一列的相邻位置上。\n\n由于 zhq 率领的 TYVJ 开发小组成功地扭曲了空间，每一行或每一列的第一个位置和最后一个位置也算作相邻。\n\n现在 Vani 想知道他的两个要求最多能满足多少个。\n\n在此前提下，至少需要交换多少次摊点。", "inputFormat": "第一行包含三个整数 $N$ 和 $M$ 和 $T$，$T$ 表示 cl 对多少个摊点感兴趣。\n\n接下来 $T$ 行，每行两个整数 $x, y$，表示 cl 对处在第 $x$ 行第 $y$ 列的摊点感兴趣。\n", "outputFormat": "首先输出一个字符串。\n\n如果能满足 Vani 的全部两个要求，输出 `both`；\n\n如果通过调整只能使得各行中 cl 感兴趣的摊点数一样多，输出 `row`；\n\n如果只能使各列中 cl 感兴趣的摊点数一样多，输出 `column`；\n\n如果均不能满足，输出 `impossible`。\n\n如果输出的字符串不是 `impossible`， 接下来输出最小交换次数，与字符串之间用一个空格隔开。", "hint": "对于 $30\\%$ 的数据，$N,M \\le 100$。\n\n对于 $70\\%$ 的数据，$N,M \\le 1000$。\n\n对于 $100\\%$ 的数据，$1 \\le N,M \\le 100000$，$0 \\le T \\le \\min(N\\times M,100000)$，$1 \\le x \\le N$，$1 \\le y \\le M$。", "locale": "zh-CN"}}}
{"pid": "P10454", "type": "P", "difficulty": 5, "samples": [["3\n1 2 3\n0 4 6\n7 5 8\n1 2 3\n4 5 6\n7 8 0\n1\n0\n0", "TAK\nTAK"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["树状数组", "排序"], "title": "奇数码问题", "background": "", "description": "你一定玩过八数码游戏，它实际上是在一个 $3 \\times 3$ 的网格中进行的，$1$ 个空格和 $1 \\sim 8$ 这 $8$ 个数字恰好不重不漏地分布在这 $3 \\times 3$ 的网格中。\n\n例如：\n\n    5 2 8\n    1 3 _\n    4 6 7\n    \n\n在游戏过程中，可以把空格与其上、下、左、右四个方向之一的数字交换（如果存在）。\n\n例如在上例中，空格可与左、上、下面的数字交换，分别变成：\n\n    5 2 8       5 2 _      5 2 8\n    1 _ 3       1 3 8      1 3 7\n    4 6 7       4 6 7      4 6 _\n    \n\n奇数码游戏是它的一个扩展，在一个 $n \\times n$ 的网格中进行，其中 $n$ 为奇数，$1$ 个空格和 $1 \\sim n^2-1$ 这 $n^2-1$ 个数恰好不重不漏地分布在 $n \\times n$ 的网格中。\n\n空格移动的规则与八数码游戏相同，实际上，八数码就是一个 $n=3$ 的奇数码游戏。\n\n现在给定两个奇数码游戏的局面，请判断是否存在一种移动空格的方式，使得其中一个局面可以变化到另一个局面。", "inputFormat": "多组数据，对于每组数据：\n\n第 $1$ 行输入一个整数 $n$，$n$ 为奇数。\n\n接下来 $n$ 行每行 $n$ 个整数，表示第一个局面。\n\n再接下来 $n$ 行每行 $n$ 个整数，表示第二个局面。\n\n局面中每个整数都是 $0 \\sim n^2-1$ 之一，其中用 $0$ 代表空格，其余数值与奇数码游戏中的意义相同，保证这些整数的分布不重不漏。", "outputFormat": "对于每组数据，若两个局面可达，输出 `TAK`，否则输出 `NIE`。\n", "hint": "$1 \\le n < 500$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "奇数码问题", "background": "", "description": "你一定玩过八数码游戏，它实际上是在一个 $3 \\times 3$ 的网格中进行的，$1$ 个空格和 $1 \\sim 8$ 这 $8$ 个数字恰好不重不漏地分布在这 $3 \\times 3$ 的网格中。\n\n例如：\n\n    5 2 8\n    1 3 _\n    4 6 7\n    \n\n在游戏过程中，可以把空格与其上、下、左、右四个方向之一的数字交换（如果存在）。\n\n例如在上例中，空格可与左、上、下面的数字交换，分别变成：\n\n    5 2 8       5 2 _      5 2 8\n    1 _ 3       1 3 8      1 3 7\n    4 6 7       4 6 7      4 6 _\n    \n\n奇数码游戏是它的一个扩展，在一个 $n \\times n$ 的网格中进行，其中 $n$ 为奇数，$1$ 个空格和 $1 \\sim n^2-1$ 这 $n^2-1$ 个数恰好不重不漏地分布在 $n \\times n$ 的网格中。\n\n空格移动的规则与八数码游戏相同，实际上，八数码就是一个 $n=3$ 的奇数码游戏。\n\n现在给定两个奇数码游戏的局面，请判断是否存在一种移动空格的方式，使得其中一个局面可以变化到另一个局面。", "inputFormat": "多组数据，对于每组数据：\n\n第 $1$ 行输入一个整数 $n$，$n$ 为奇数。\n\n接下来 $n$ 行每行 $n$ 个整数，表示第一个局面。\n\n再接下来 $n$ 行每行 $n$ 个整数，表示第二个局面。\n\n局面中每个整数都是 $0 \\sim n^2-1$ 之一，其中用 $0$ 代表空格，其余数值与奇数码游戏中的意义相同，保证这些整数的分布不重不漏。", "outputFormat": "对于每组数据，若两个局面可达，输出 `TAK`，否则输出 `NIE`。\n", "hint": "$1 \\le n < 500$", "locale": "zh-CN"}}}
{"pid": "P10455", "type": "P", "difficulty": 5, "samples": [["2\n5 1 49\n8 2 1 7 9\n5 1 64\n8 2 1 7 9", "2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "倍增"], "title": "Genius Acm", "background": "", "description": "Advanced CPU Manufacturer (ACM) is one of the best CPU manufacturers in the world. 每天，该公司生产 $n$ 台 CPU 并销售到世界各地。\n\nACM 公司的质检部门会对生产出的 CPU 进行成组测试，对一组（若干个）CPU 进行测试的方法如下：\n\n1. 随机从该组 CPU 中选取 $m$ 对（即 $2m$ 台），若总数不足 $2m$ 台，则选取尽量多对。\n\n2. 对于每一对 CPU，测量它们之间的 Relative Performance Difference (RPD)，并把第 $i$ 对的 RPD 记为 $D_i$。RPD 的计算方法在后面给出。\n\n3. 该组 CPU 的 Sqared Performance Difference (SPD） 由以下公式给出：\n\n$SPD=\\sum _i D^2_i$\n\n\n4. 该组 CPU 通过质检，当且仅当 $SPD \\le k,$ 其中 $k$ 是给定常数。\n\nACM 公司生产的 CPU 性能很好，而质检部门制定的标准更是过于严格。通常他们把 $n$ 台 CPU 作为一整组进行测试，这导致一些性能良好的 CPU 无法通过测试，生产部门对此颇有微词。作为质检部门的领导，小 S 在不更改质检测试流程的前提下，想出了这样一个主意：如果能够把 $n$ 台 CPU 恰当地分成连续的若干段，使得每段 CPU 都能够通过成组测试，就可以解决当下的问题。\n\n现在，小 S 已经知道了 $n$ 台各自的性能表现 $P_1,\\cdots ,P_n$，两台 CPU 的 RPD 被定义为它们性能表现的差的绝对值。请你帮忙计算一下，至少把这些 CPU 分成多少段，才能使得每一段都能通过成组测试。", "inputFormat": "每个测试点包含多组数据，第一行整数 $T$ 给出数据组数。\n\n对于每组数据，第一行三个整数 $n,m,k$，第二行 $n$ 个整数 $P_1,\\cdots ,P_n$。", "outputFormat": "对于每组数据，输出一个整表示答案。", "hint": "对于 $20 \\%$ 的数据，$1 \\leq n \\leq 10^2$ 。  \n对于 $40 \\%$ 的数据， $1 \\leq n \\leq 10^3$ 。  \n对于另外 $10 \\%$ 的数据，$k=0$ 。  \n对于另外 $10 \\%$ 的数据，$0 \\leq k \\leq 1$ 。  \n对于另外 $10 \\%$ 的数据， $m=1$ 。  \n对于另外 $10 \\%$ 的数据，$1 \\leq m \\leq 2$ 。  \n对于 $90 \\%$ 的数据，$0 \\leq k \\leq 10^{12}$ 。  \n对于 $100 \\%$ 的数据，$T \\leq 12,1 \\leq n, m \\leq 5 \\cdot 10^5, 0 \\leq k \\leq 10^{18}, 0 \\leq P_i \\leq 2^{20}$ 。  ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Genius Acm", "background": "", "description": "Advanced CPU Manufacturer (ACM) is one of the best CPU manufacturers in the world. 每天，该公司生产 $n$ 台 CPU 并销售到世界各地。\n\nACM 公司的质检部门会对生产出的 CPU 进行成组测试，对一组（若干个）CPU 进行测试的方法如下：\n\n1. 随机从该组 CPU 中选取 $m$ 对（即 $2m$ 台），若总数不足 $2m$ 台，则选取尽量多对。\n\n2. 对于每一对 CPU，测量它们之间的 Relative Performance Difference (RPD)，并把第 $i$ 对的 RPD 记为 $D_i$。RPD 的计算方法在后面给出。\n\n3. 该组 CPU 的 Sqared Performance Difference (SPD） 由以下公式给出：\n\n$SPD=\\sum _i D^2_i$\n\n\n4. 该组 CPU 通过质检，当且仅当 $SPD \\le k,$ 其中 $k$ 是给定常数。\n\nACM 公司生产的 CPU 性能很好，而质检部门制定的标准更是过于严格。通常他们把 $n$ 台 CPU 作为一整组进行测试，这导致一些性能良好的 CPU 无法通过测试，生产部门对此颇有微词。作为质检部门的领导，小 S 在不更改质检测试流程的前提下，想出了这样一个主意：如果能够把 $n$ 台 CPU 恰当地分成连续的若干段，使得每段 CPU 都能够通过成组测试，就可以解决当下的问题。\n\n现在，小 S 已经知道了 $n$ 台各自的性能表现 $P_1,\\cdots ,P_n$，两台 CPU 的 RPD 被定义为它们性能表现的差的绝对值。请你帮忙计算一下，至少把这些 CPU 分成多少段，才能使得每一段都能通过成组测试。", "inputFormat": "每个测试点包含多组数据，第一行整数 $T$ 给出数据组数。\n\n对于每组数据，第一行三个整数 $n,m,k$，第二行 $n$ 个整数 $P_1,\\cdots ,P_n$。", "outputFormat": "对于每组数据，输出一个整表示答案。", "hint": "对于 $20 \\%$ 的数据，$1 \\leq n \\leq 10^2$ 。  \n对于 $40 \\%$ 的数据， $1 \\leq n \\leq 10^3$ 。  \n对于另外 $10 \\%$ 的数据，$k=0$ 。  \n对于另外 $10 \\%$ 的数据，$0 \\leq k \\leq 1$ 。  \n对于另外 $10 \\%$ 的数据， $m=1$ 。  \n对于另外 $10 \\%$ 的数据，$1 \\leq m \\leq 2$ 。  \n对于 $90 \\%$ 的数据，$0 \\leq k \\leq 10^{12}$ 。  \n对于 $100 \\%$ 的数据，$T \\leq 12,1 \\leq n, m \\leq 5 \\cdot 10^5, 0 \\leq k \\leq 10^{18}, 0 \\leq P_i \\leq 2^{20}$ 。  ", "locale": "zh-CN"}}}
{"pid": "P10456", "type": "P", "difficulty": 4, "samples": [["-+--\n----\n----\n-+--", "6 \n1 1 \n1 3 \n1 4 \n4 1 \n4 3 \n4 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2004", "Special Judge", "ICPC"], "title": "The Pilots Brothers' refrigerator", "background": "", "description": "The game “The Pilots Brothers: following the stripy elephant” has a quest where a player needs to open a refrigerator.\n\nThere are $16$ handles on the refrigerator door. Every handle can be in one of two states: open or closed. The refrigerator is open only when all handles are open. The handles are represented as a matrix $4\\times4$. You can change the state of a handle in any location $[i, j] (1 \\leq i, j \\leq 4)$. However, this also changes states of all handles in row $i$ and all handles in column $j$.\n\nThe task is to determine the minimum number of handle switching necessary to open the refrigerator.", "inputFormat": "The input contains four lines. Each of the four lines contains four characters describing the initial state of appropriate handles. A symbol “+” means that the handle is in closed state, whereas the symbol “−” means “open”. At least one of the handles is initially closed.", "outputFormat": "The first line of the input contains $N$ – the minimum number of switching. The rest $N$ lines describe switching sequence. Each of the lines contains a row number and a column number of the matrix separated by one or more spaces. If there are several solutions, you may give any one of them.", "hint": "", "locale": "en", "translations": {"en": {"title": "The Pilots Brothers' refrigerator", "background": "", "description": "The game “The Pilots Brothers: following the stripy elephant” has a quest where a player needs to open a refrigerator.\n\nThere are $16$ handles on the refrigerator door. Every handle can be in one of two states: open or closed. The refrigerator is open only when all handles are open. The handles are represented as a matrix $4\\times4$. You can change the state of a handle in any location $[i, j] (1 \\leq i, j \\leq 4)$. However, this also changes states of all handles in row $i$ and all handles in column $j$.\n\nThe task is to determine the minimum number of handle switching necessary to open the refrigerator.", "inputFormat": "The input contains four lines. Each of the four lines contains four characters describing the initial state of appropriate handles. A symbol “+” means that the handle is in closed state, whereas the symbol “−” means “open”. At least one of the handles is initially closed.", "outputFormat": "The first line of the input contains $N$ – the minimum number of switching. The rest $N$ lines describe switching sequence. Each of the lines contains a row number and a column number of the matrix separated by one or more spaces. If there are several solutions, you may give any one of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "The Pilots Brothers' refrigerator", "background": "", "description": "游戏《飞行员兄弟：追寻条纹大象》中有一个任务，玩家需要打开一个冰箱。\n\n冰箱门上有 $16$ 个手柄。每个手柄可以处于两种状态之一：打开或关闭。只有当所有手柄都打开时，冰箱才会打开。手柄被表示为一个 $4\\times4$ 的矩阵。你可以改变任何位置 $[i, j] (1 \\leq i, j \\leq 4)$ 处手柄的状态。但是，这也会改变第 $i$ 行和第 $j$ 列中所有手柄的状态。\n\n任务是确定打开冰箱所需的最小切换次数。", "inputFormat": "输入包含四行。每一行都包含四个字符，描述相应手柄的初始状态。符号 “+” 表示手柄处于关闭状态，而符号 “−” 表示 “打开”状态。至少有一个手柄最初是关闭的。", "outputFormat": "输入的第一行包含 $N$ - 最小切换次数。接下来的 $N$ 行描述切换序列。每行包含一个矩阵的行号和列号，用一个或多个空格分隔开。如果存在多个解决方案，则可以提供任何一个解决方案。\n\n翻译来自于：ChatGPT。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10457", "type": "P", "difficulty": 2, "samples": [["8 5 A A\nK 5 3 2\n9 6 0 6\n3 4 3 4\n3 4 4 5\n5 6 7 6\n8 7 7 7\n9 9 8 8\n9 0 0 0\nK J J J\nQ A Q K\nJ Q 2 2\nA K Q 2", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "队列"], "title": "占卜DIY", "background": null, "description": "lyd 学会了使用扑克 DIY 占卜。方法如下：一副去掉大小王的扑克共 $52$ 张，打乱后均分为 $13$ 堆，编号 $1\\sim 13$，每堆 $4$ 张，其中第 $13$ 堆称作“生命牌”，也就是说你有 $4$ 条命。这里边，$4$ 张 $K$ 被称作死神。\n\n初始状态下，所有的牌背面朝上扣下。\n\n流程如下：\n\n- 抽取生命牌中的最上面一张（第一张）。\n- 把这张牌翻开，正面朝上，放到牌上的数字所对应编号的堆的最上边。（例如抽到 $2$，正面朝上放到第 $2$ 堆牌最上面，又比如抽到 $J$，放到第 $11$ 堆牌最上边，注意是正面朝上放）\n- 从刚放了牌的那一堆最底下（最后一张）抽取一张牌，重复第 $2$ 步。（例如你上次抽了 $2$，放到了第二堆顶部，现在抽第二堆最后一张发现是 $8$，又放到第 $8$ 堆顶部……）\n- 在抽牌过程中如果抽到 $K$，则称死了一条命，就扔掉 $K$ 再从第 $1$ 步开始。\n- 当发现四条命都死了以后，统计现在每堆牌上边正面朝上的牌的数目，只要同一数字的牌出现 $4$ 张正面朝上的牌（比如 $4$ 个 $A$），则称“开了一对”，当然 $4$ 个 $K$ 是不算的。\n- 统计一共开了多少对，开了 $0$ 对称作“极凶”，$1\\sim 2$ 对为“大凶”，$3$ 对为“凶”，$4\\sim 5$ 对为“小凶”，$6$ 对为“中庸”，$7\\sim 8$ 对“小吉”，$9$ 对为“吉”，$10\\sim11$ 对为“大吉”，$12$ 对为“满堂开花，极吉”。\n\n如果还不明白，请参考样例。", "inputFormat": "一共 $13$ 行，为每堆牌的具体牌是什么（不区分花色只区分数字），每堆输入的顺序为从上到下。\n\n为了便于读入，用 $0$ 代表 $10$。", "outputFormat": "输出一共开了多少对。", "hint": "注解：第一条命死后前 $12$ 堆牌变成了这个样子：\n```\nA A A 8\nK 5 3 2\n3 9 6 0\n4 4 3 4\n5 5 3 4\n6 6 5 6\n7 7 7 7 \n8 8 8 9\n9 9 0 0\n0 K J J\nJ Q A Q//抽到这里的K死掉了\nJ Q 2 2\n```\n第二条命由于 $K$ 在生命牌中，所以直接死掉，不变。\n\n第三条命死后前 $12$ 堆牌变成了这个样子：\n```\nA A A A\n2 2 2 K\n3 3 3 3\n4 4 4 4\n5 5 5 5\n6 6 6 6\n7 7 7 7 \n8 8 8 8\n9 9 9 9\n0 0 0 0//抽到这里的K死掉了\nJ J J Q\nQ Q J Q\n```\n第四条命死后前 $12$ 堆牌变成了这个样子：\n```\nA A A A\n2 2 2 2//抽到这里的K死掉了\n3 3 3 3\n4 4 4 4\n5 5 5 5\n6 6 6 6\n7 7 7 7 \n8 8 8 8\n9 9 9 9\n0 0 0 0\nJ J J Q\nQ Q J Q\n```\n最后发现在所有已经正面朝上的牌中，$A\\ 2\\ 3\\ 4\\ 5\\ 6\\ 7\\ 8\\ 10$ 这 $9$ 对牌“开”了，（注意，第 $9$ 堆牌中的最后一张虽然也是 $9$，但是并没有被翻开！所以不能算）因此输出 $9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "占卜DIY", "background": null, "description": "lyd 学会了使用扑克 DIY 占卜。方法如下：一副去掉大小王的扑克共 $52$ 张，打乱后均分为 $13$ 堆，编号 $1\\sim 13$，每堆 $4$ 张，其中第 $13$ 堆称作“生命牌”，也就是说你有 $4$ 条命。这里边，$4$ 张 $K$ 被称作死神。\n\n初始状态下，所有的牌背面朝上扣下。\n\n流程如下：\n\n- 抽取生命牌中的最上面一张（第一张）。\n- 把这张牌翻开，正面朝上，放到牌上的数字所对应编号的堆的最上边。（例如抽到 $2$，正面朝上放到第 $2$ 堆牌最上面，又比如抽到 $J$，放到第 $11$ 堆牌最上边，注意是正面朝上放）\n- 从刚放了牌的那一堆最底下（最后一张）抽取一张牌，重复第 $2$ 步。（例如你上次抽了 $2$，放到了第二堆顶部，现在抽第二堆最后一张发现是 $8$，又放到第 $8$ 堆顶部……）\n- 在抽牌过程中如果抽到 $K$，则称死了一条命，就扔掉 $K$ 再从第 $1$ 步开始。\n- 当发现四条命都死了以后，统计现在每堆牌上边正面朝上的牌的数目，只要同一数字的牌出现 $4$ 张正面朝上的牌（比如 $4$ 个 $A$），则称“开了一对”，当然 $4$ 个 $K$ 是不算的。\n- 统计一共开了多少对，开了 $0$ 对称作“极凶”，$1\\sim 2$ 对为“大凶”，$3$ 对为“凶”，$4\\sim 5$ 对为“小凶”，$6$ 对为“中庸”，$7\\sim 8$ 对“小吉”，$9$ 对为“吉”，$10\\sim11$ 对为“大吉”，$12$ 对为“满堂开花，极吉”。\n\n如果还不明白，请参考样例。", "inputFormat": "一共 $13$ 行，为每堆牌的具体牌是什么（不区分花色只区分数字），每堆输入的顺序为从上到下。\n\n为了便于读入，用 $0$ 代表 $10$。", "outputFormat": "输出一共开了多少对。", "hint": "注解：第一条命死后前 $12$ 堆牌变成了这个样子：\n```\nA A A 8\nK 5 3 2\n3 9 6 0\n4 4 3 4\n5 5 3 4\n6 6 5 6\n7 7 7 7 \n8 8 8 9\n9 9 0 0\n0 K J J\nJ Q A Q//抽到这里的K死掉了\nJ Q 2 2\n```\n第二条命由于 $K$ 在生命牌中，所以直接死掉，不变。\n\n第三条命死后前 $12$ 堆牌变成了这个样子：\n```\nA A A A\n2 2 2 K\n3 3 3 3\n4 4 4 4\n5 5 5 5\n6 6 6 6\n7 7 7 7 \n8 8 8 8\n9 9 9 9\n0 0 0 0//抽到这里的K死掉了\nJ J J Q\nQ Q J Q\n```\n第四条命死后前 $12$ 堆牌变成了这个样子：\n```\nA A A A\n2 2 2 2//抽到这里的K死掉了\n3 3 3 3\n4 4 4 4\n5 5 5 5\n6 6 6 6\n7 7 7 7 \n8 8 8 8\n9 9 9 9\n0 0 0 0\nJ J J Q\nQ Q J Q\n```\n最后发现在所有已经正面朝上的牌中，$A\\ 2\\ 3\\ 4\\ 5\\ 6\\ 7\\ 8\\ 10$ 这 $9$ 对牌“开”了，（注意，第 $9$ 堆牌中的最后一张虽然也是 $9$，但是并没有被翻开！所以不能算）因此输出 $9$。", "locale": "zh-CN"}}}
{"pid": "P10458", "type": "P", "difficulty": 2, "samples": [["1\n2\n3 \n4 \n-1", "X\n-\nX X\n X \nX X\n-\nX X   X X\n X     X \nX X   X X\n   X X   \n    X    \n   X X   \nX X   X X\n X     X \nX X   X X\n-\nX X   X X         X X   X X\n X     X           X     X \nX X   X X         X X   X X\n   X X               X X   \n    X                 X    \n   X X               X X   \nX X   X X         X X   X X\n X     X           X     X \nX X   X X         X X   X X\n         X X   X X         \n          X     X          \n         X X   X X         \n            X X            \n             X             \n            X X            \n         X X   X X         \n          X     X          \n         X X   X X         \nX X   X X         X X   X X\n X     X           X     X \nX X   X X         X X   X X\n   X X               X X   \n    X                 X    \n   X X               X X   \nX X   X X         X X   X X\n X     X           X     X \nX X   X X         X X   X X\n-\n"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["递归"], "title": "Fractal", "background": "", "description": "A fractal is an object or quantity that displays self-similarity, in a somewhat technical sense, on all scales. The object need not exhibit exactly the same structure at all scales, but the same \"type\" of structures must appear on all scales.\n\nA box fractal is defined as below :\n\n-  A box fractal of degree $1$ is simply X\n-  A box fractal of degree $2$ is\n```\nX X\n X\nX X\n```\n- If using $B(n - 1)$ to represent the box fractal of degree $n - 1$, then a box fractal of degree $n$ is defined recursively as following\n```\nB(n - 1) B(n - 1)\n     B(n - 1)\nB(n - 1) B(n - 1)\n```\nYour task is to draw a box fractal of degree $n$.", "inputFormat": "The input consists of several test cases. Each line of the input contains a positive integer $n$ which is no greater than $7$. The last line of input is a negative integer $-1$ indicating the end of input.", "outputFormat": "For each test case, output the box fractal using the 'X' notation. Please notice that 'X' is an uppercase letter. Print a line with only a single dash after each test case.", "hint": "", "locale": "en", "translations": {"en": {"title": "Fractal", "background": "", "description": "A fractal is an object or quantity that displays self-similarity, in a somewhat technical sense, on all scales. The object need not exhibit exactly the same structure at all scales, but the same \"type\" of structures must appear on all scales.\n\nA box fractal is defined as below :\n\n-  A box fractal of degree $1$ is simply X\n-  A box fractal of degree $2$ is\n```\nX X\n X\nX X\n```\n- If using $B(n - 1)$ to represent the box fractal of degree $n - 1$, then a box fractal of degree $n$ is defined recursively as following\n```\nB(n - 1) B(n - 1)\n     B(n - 1)\nB(n - 1) B(n - 1)\n```\nYour task is to draw a box fractal of degree $n$.", "inputFormat": "The input consists of several test cases. Each line of the input contains a positive integer $n$ which is no greater than $7$. The last line of input is a negative integer $-1$ indicating the end of input.", "outputFormat": "For each test case, output the box fractal using the 'X' notation. Please notice that 'X' is an uppercase letter. Print a line with only a single dash after each test case.", "hint": "", "locale": "en"}, "zh-CN": {"title": "Fractal", "background": "", "description": "分形是在各种尺度上以某种技术意义上显示自相似性的对象或数量。对象不需要在所有尺度上展现完全相同的结构，但在所有尺度上必须出现相同的“类型”结构。\n\n盒子分形定义如下：\n\n- 度为 $1$ 的盒子分形简单地是 X\n- 度为 $2$ 的盒子分形是\n```\nX X\n X\nX X\n```\n- 如果用 $B(n - 1)$ 表示度为 $n - 1$ 的盒子分形，那么度为 $n$ 的盒子分形可以递归地定义如下\n```\nB(n - 1) B(n - 1)\n     B(n - 1)\nB(n - 1) B(n - 1)\n```\n你的任务是绘制度为 $n$ 的盒子分形。", "inputFormat": "输入包含多个测试用例。输入的每一行包含一个不大于 $7$ 的正整数 $n$。输入的最后一行是一个负整数 $-1$，表示输入的结束。", "outputFormat": "对于每个测试用例，使用 'X' 符号输出盒子分形。请注意，'X' 是一个大写字母。在每个测试用例之后打印一行仅包含单个破折号。\n\n翻译来自于：ChatGPT。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10459", "type": "P", "difficulty": 7, "samples": [["2\n4 \n0 0 \n0 1 \n1 0 \n1 1 \n2 2 \n2 3 \n3 2 \n3 3 \n4 \n0 0 \n0 0 \n0 0 \n0 0 \n0 0 \n0 0 \n0 0 \n0 0", "1.414\n0.000"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["计算几何", "分治", "凸包"], "title": "Raid", "background": "", "description": "After successive failures in the battles against the Union, the Empire retreated to its last stronghold. Depending on its powerful defense system, the Empire repelled the six waves of Union's attack. After several sleepless nights of thinking, Arthur, General of the Union, noticed that the only weakness of the defense system was its energy supply. The system was charged by $N$ nuclear power stations and breaking down any of them would disable the system.\n\nThe general soon started a raid to the stations by $N$ special agents who were paradroped into the stronghold. Unfortunately they failed to land at the expected positions due to the attack by the Empire Air Force. As an experienced general, Arthur soon realized that he needed to rearrange the plan. The first thing he wants to know now is that which agent is the nearest to any power station. Could you, the chief officer, help the general to calculate the minimum distance between an agent and a station?\n", "inputFormat": "The first line is a integer T representing the number of test cases.\n\nEach test case begins with an integer $N (1 \\leq N \\leq 100000)$.\n\nThe next $N$ lines describe the positions of the stations. Each line consists of two integers $X (0 \\leq X \\leq 10^9)$ and $Y (0 \\leq Y \\leq 10^9)$ indicating the positions of the station.\n\nThe next following N lines describe the positions of the agents. Each line consists of two integers $X (0 \\leq X \\leq 10^9)$ and $Y (0 \\leq Y \\leq 10^9)$ indicating the positions of the agent.", "outputFormat": "For each test case output the minimum distance with precision of three decimal placed in a separate line.", "hint": "", "locale": "en", "translations": {"en": {"title": "Raid", "background": "", "description": "After successive failures in the battles against the Union, the Empire retreated to its last stronghold. Depending on its powerful defense system, the Empire repelled the six waves of Union's attack. After several sleepless nights of thinking, Arthur, General of the Union, noticed that the only weakness of the defense system was its energy supply. The system was charged by $N$ nuclear power stations and breaking down any of them would disable the system.\n\nThe general soon started a raid to the stations by $N$ special agents who were paradroped into the stronghold. Unfortunately they failed to land at the expected positions due to the attack by the Empire Air Force. As an experienced general, Arthur soon realized that he needed to rearrange the plan. The first thing he wants to know now is that which agent is the nearest to any power station. Could you, the chief officer, help the general to calculate the minimum distance between an agent and a station?\n", "inputFormat": "The first line is a integer T representing the number of test cases.\n\nEach test case begins with an integer $N (1 \\leq N \\leq 100000)$.\n\nThe next $N$ lines describe the positions of the stations. Each line consists of two integers $X (0 \\leq X \\leq 10^9)$ and $Y (0 \\leq Y \\leq 10^9)$ indicating the positions of the station.\n\nThe next following N lines describe the positions of the agents. Each line consists of two integers $X (0 \\leq X \\leq 10^9)$ and $Y (0 \\leq Y \\leq 10^9)$ indicating the positions of the agent.", "outputFormat": "For each test case output the minimum distance with precision of three decimal placed in a separate line.", "hint": "", "locale": "en"}, "zh-CN": {"title": "Raid", "background": "《算法竞赛进阶指南》给出参考代码可以在本题获得 Subtask1 中的 44 分，在部分边界条件 $n=1,2$ 下会失分。该参考代码会被特意构造的数据卡掉，无法通过所有测试点。", "description": "在连续的对抗联盟失败后，帝国撤退到了最后的要塞。依靠其强大的防御系统，帝国击退了联盟的六波攻击。经过几个不眠之夜的思考，联盟将军亚瑟注意到防御系统唯一的弱点是其能源供应。该系统由 $N$ 个核电站供电，破坏其中任何一个都会使系统失效。\n\n将军很快派出了 $N$ 名特工突袭这些电站，他们被空投到了要塞内。不幸的是，由于帝国空军的袭击，他们未能着陆到预期的位置。作为一名经验丰富的将军，亚瑟很快意识到他需要重新安排计划。他现在想知道的第一件事是，哪个特工距离任何一个电站最近。作为首席官员，你能帮助将军计算特工与电站之间的最小距离吗？", "inputFormat": "第一行是一个整数 $T(1\\leq T\\leq 10^5)$，表示测试用例的数量。\n\n每个测试用例以一个整数 $N (1 \\leq N \\leq 10^5)$ 开始。\n\n接下来的 $N$ 行描述了电站的位置。每行包含两个整数 $X (0 \\leq X \\leq 10^9)$ 和 $Y (0 \\leq Y \\leq 10^9)$，表示电站的位置。\n\n接下来的 $N$ 行描述了特工的位置。每行包含两个整数 $X (0 \\leq X \\leq 10^9)$ 和 $Y (0 \\leq Y \\leq 10^9)$，表示特工的位置。\n\n保证在一个测试点中，$\\sum N\\leq 10^5$。", "outputFormat": "对于每个测试用例，输出距离最小值，保留三位小数，单独占一行。", "hint": "翻译来自 ChatGPT。", "locale": "zh-CN"}}}
{"pid": "P10460", "type": "P", "difficulty": 3, "samples": [["3\n2\n1 10 1 \n2 10 1 \n2\n1 10 1 \n1 10 1 \n4\n1 10 1 \n4 4 1 \n1 5 1 \n6 10 1\n", "1 1\nThere's no weakness. \n4 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["二分", "前缀和", "位运算"], "title": "防线", "background": "", "description": "lsp 学习数学竞赛的时候受尽了同仁们的鄙视，终于有一天……受尽屈辱的 lsp 黑化成为了黑暗英雄 Lord lsp。就如同中二漫画的情节一样，Lord lsp 打算毁掉这个世界。数学竞赛界的精英 lqr 打算阻止 Lord lsp 的阴谋，于是她集合了一支由数学竞赛选手组成的超级行动队。由于队员们个个都智商超群，很快，行动队便来到了 Lord lsp 的黑暗城堡的下方。\n\n但是，同样强大的 Lord lsp 在城堡周围布置了一条“不可越过”的坚固防线。防线由很多防具组成，这些防具分成了 $N$ 组。我们可以认为防线是一维的，那么每一组防具都分布在防线的某一段上，并且同一组防具是等距离排列的。也就是说，我们可以用三个整数 $S$，$E$ 和 $D$ 来描述一组防具，即这一组防具布置在防线的 $S,S + D,S + 2D，\\dots，S + KD$（$K\\in \\Z，S + KD\\leq E，S + (K + 1)D>E$） 位置上。\n\n黑化的 Lord lsp 设计的防线极其精良。如果防线的某个位置有偶数个防具，那么这个位置就是毫无破绽的（包括这个位置一个防具也没有的情况，因为 $0$ 也是偶数）。只有有奇数个防具的位置有破绽，但是整条防线上也最多只有一个位置有奇数个防具。作为行动队的队长，lqr 要找到防线的破绽以策划下一步的行动。但是，由于防具的数量太多，她实在是不能看出哪里有破绽。作为 lqr 可以信任的学弟学们，你们要帮助她解决这个问题。", "inputFormat": "输入文件的第一行是一个整数 $T$，表示有 $T$ 组互相独立的测试数据。 \n\n每组数据的第一行是一个整数 $N$。\n\n之后 $N$ 行，每行三个整数 $S_i$，$E_i$，$D_i$，代表第 $i$ 组防具的三个参数。", "outputFormat": "对于每组测试数据，如果防线没有破绽，即所有的位置都有偶数个防具，输出一行 `There's no weakness.`。\n\n否则在一行内输出两个空格分隔的整数 $P$ 和 $C$，表示在位置 $P$ 有 $C$ 个防具。当然 $C$ 应该是一个奇数。", "hint": "对于 $30\\%$ 的数据，满足防具总数不多于 $10  ^ {7}$。\n\n对于 $100\\%$ 的数据，满足防具总数不多于 $10  ^ {8}$，$S_{i}\\le E_{i} $，$1\\le T \\le 5$，$N \\le 200000$，$0 \\le S_{i}$ ，$E_{i}$ ，$D_{i} \\le 2^{31} - 1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "防线", "background": "", "description": "lsp 学习数学竞赛的时候受尽了同仁们的鄙视，终于有一天……受尽屈辱的 lsp 黑化成为了黑暗英雄 Lord lsp。就如同中二漫画的情节一样，Lord lsp 打算毁掉这个世界。数学竞赛界的精英 lqr 打算阻止 Lord lsp 的阴谋，于是她集合了一支由数学竞赛选手组成的超级行动队。由于队员们个个都智商超群，很快，行动队便来到了 Lord lsp 的黑暗城堡的下方。\n\n但是，同样强大的 Lord lsp 在城堡周围布置了一条“不可越过”的坚固防线。防线由很多防具组成，这些防具分成了 $N$ 组。我们可以认为防线是一维的，那么每一组防具都分布在防线的某一段上，并且同一组防具是等距离排列的。也就是说，我们可以用三个整数 $S$，$E$ 和 $D$ 来描述一组防具，即这一组防具布置在防线的 $S,S + D,S + 2D，\\dots，S + KD$（$K\\in \\Z，S + KD\\leq E，S + (K + 1)D>E$） 位置上。\n\n黑化的 Lord lsp 设计的防线极其精良。如果防线的某个位置有偶数个防具，那么这个位置就是毫无破绽的（包括这个位置一个防具也没有的情况，因为 $0$ 也是偶数）。只有有奇数个防具的位置有破绽，但是整条防线上也最多只有一个位置有奇数个防具。作为行动队的队长，lqr 要找到防线的破绽以策划下一步的行动。但是，由于防具的数量太多，她实在是不能看出哪里有破绽。作为 lqr 可以信任的学弟学们，你们要帮助她解决这个问题。", "inputFormat": "输入文件的第一行是一个整数 $T$，表示有 $T$ 组互相独立的测试数据。 \n\n每组数据的第一行是一个整数 $N$。\n\n之后 $N$ 行，每行三个整数 $S_i$，$E_i$，$D_i$，代表第 $i$ 组防具的三个参数。", "outputFormat": "对于每组测试数据，如果防线没有破绽，即所有的位置都有偶数个防具，输出一行 `There's no weakness.`。\n\n否则在一行内输出两个空格分隔的整数 $P$ 和 $C$，表示在位置 $P$ 有 $C$ 个防具。当然 $C$ 应该是一个奇数。", "hint": "对于 $30\\%$ 的数据，满足防具总数不多于 $10  ^ {7}$。\n\n对于 $100\\%$ 的数据，满足防具总数不多于 $10  ^ {8}$，$S_{i}\\le E_{i} $，$1\\le T \\le 5$，$N \\le 200000$，$0 \\le S_{i}$ ，$E_{i}$ ，$D_{i} \\le 2^{31} - 1$。", "locale": "zh-CN"}}}
{"pid": "P10461", "type": "P", "difficulty": 7, "samples": [["2\n0 1 2 3\n2 1 1", "2 1 2 7"], ["4\n0 8 3 2 7 3 9 0 0 1 8 2 3 7 0 2\n1 0 4 8 2", "1 0 0 192 0 448 168 8824 0 0 0 536 0 248 520 26560 "]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["快速沃尔什变换 FWT", "快速莫比乌斯变换 FMT", "集合幂级数，子集卷积", "模板题"], "title": "【模板】多项式复合集合幂级数", "background": "", "description": "给定一个集合幂级数 $F(x)$ 和一个多项式 $G(x)$，保证 $[x^{\\varnothing}]F(x)=0$。定义 $x$ 的乘法为子集卷积，你需要对 $S\\subseteq\\{1,2,\\cdots,n\\}$ 求出 $[x^S]G(F(x))$ 对 $998244353$ 取模后的值。\n\n如果你仍不清楚题意，可以阅读题面最后的提示部分。", "inputFormat": "第一行一个正整数 $n$。\n\n接下来一行 $2^n$ 个非负整数，第 $i$ 个整数表示 $[x^S]F(x)$，其中 $a\\in S$ 当且仅当 $(i-1)$ 二进制下从低到高第 $a$ 位为 $1$。\n\n接下来一行 $n+1$ 个非负整数，第 $i$ 个整数表示 $[x^{i-1}]G(x)$。", "outputFormat": "输出一行 $2^n$ 个非负整数，第 $i$ 个整数表示 $[x^S]G(F(x))$ 对 $998244353$ 取模后的值，其中 $a\\in S$ 当且仅当 $(i-1)$ 二进制下从低到高第 $a$ 位为 $1$。", "hint": "#### 【数据范围】\n\n对于所有数据，保证 $1\\le n\\le 20$，$[x^S]F(x),[x^n]G(x)\\in[0,998244353)\\cap\\mathbb Z$。\n\n本题有 $20$ 个测试点，第 $i$ 个测试点满足 $n=i$。\n\n#### 【提示】\n\n假设 $F(x)=\\displaystyle \\sum_S f_Sx^S$，那么 $[x^S]F(x)=f_S$。\n\n在本题中，$x$ 的乘法被定义为子集卷积，即：\n$$x^S\\cdot x^T=\\begin{cases}0&S\\cap T\\neq\\varnothing\\\\x^{S\\cup T}&\\text{otherwise}\\end{cases}$$\n\n**请注意内存访问连续性带来的效率差异。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【模板】多项式复合集合幂级数", "background": "", "description": "给定一个集合幂级数 $F(x)$ 和一个多项式 $G(x)$，保证 $[x^{\\varnothing}]F(x)=0$。定义 $x$ 的乘法为子集卷积，你需要对 $S\\subseteq\\{1,2,\\cdots,n\\}$ 求出 $[x^S]G(F(x))$ 对 $998244353$ 取模后的值。\n\n如果你仍不清楚题意，可以阅读题面最后的提示部分。", "inputFormat": "第一行一个正整数 $n$。\n\n接下来一行 $2^n$ 个非负整数，第 $i$ 个整数表示 $[x^S]F(x)$，其中 $a\\in S$ 当且仅当 $(i-1)$ 二进制下从低到高第 $a$ 位为 $1$。\n\n接下来一行 $n+1$ 个非负整数，第 $i$ 个整数表示 $[x^{i-1}]G(x)$。", "outputFormat": "输出一行 $2^n$ 个非负整数，第 $i$ 个整数表示 $[x^S]G(F(x))$ 对 $998244353$ 取模后的值，其中 $a\\in S$ 当且仅当 $(i-1)$ 二进制下从低到高第 $a$ 位为 $1$。", "hint": "#### 【数据范围】\n\n对于所有数据，保证 $1\\le n\\le 20$，$[x^S]F(x),[x^n]G(x)\\in[0,998244353)\\cap\\mathbb Z$。\n\n本题有 $20$ 个测试点，第 $i$ 个测试点满足 $n=i$。\n\n#### 【提示】\n\n假设 $F(x)=\\displaystyle \\sum_S f_Sx^S$，那么 $[x^S]F(x)=f_S$。\n\n在本题中，$x$ 的乘法被定义为子集卷积，即：\n$$x^S\\cdot x^T=\\begin{cases}0&S\\cap T\\neq\\varnothing\\\\x^{S\\cup T}&\\text{otherwise}\\end{cases}$$\n\n**请注意内存访问连续性带来的效率差异。**", "locale": "zh-CN"}}}
{"pid": "P10462", "type": "P", "difficulty": 2, "samples": [["8\n62 2 abcdefghiz\n10 16 1234567890123456789012345678901234567890\n16 35 3A0C92075C0DBF3B8ACBC5F96CE3F0AD2\n35 23 333YMHOUE8JPLT7OX6K9FYCQ8A\n23 49 946B9AA02MI37E3D3MMJ4G7BL2F05\n49 61 1VbDkSIMJL3JjRgAdlUfcaWj\n61 5 dl9MDSWqwHjDnToKcsWE1S\n5 10 42104444441001414401221302402201233340311104212022133030", "62 abcdefghiz\n2 11011100000100010111110010010110011111001001100011010010001\n\n10 1234567890123456789012345678901234567890\n16 3A0C92075C0DBF3B8ACBC5F96CE3F0AD2\n\n16 3A0C92075C0DBF3B8ACBC5F96CE3F0AD2\n35 333YMHOUE8JPLT7OX6K9FYCQ8A\n\n35 333YMHOUE8JPLT7OX6K9FYCQ8A\n23 946B9AA02MI37E3D3MMJ4G7BL2F05\n\n23 946B9AA02MI37E3D3MMJ4G7BL2F05\n49 1VbDkSIMJL3JjRgAdlUfcaWj\n\n49 1VbDkSIMJL3JjRgAdlUfcaWj\n61 dl9MDSWqwHjDnToKcsWE1S\n\n61 dl9MDSWqwHjDnToKcsWE1S\n5 42104444441001414401221302402201233340311104212022133030\n\n5 42104444441001414401221302402201233340311104212022133030\n10 1234567890123456789012345678901234567890"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["模拟", "2002", "ICPC"], "title": "Number Base Conversion", "background": "", "description": "Write a program to convert numbers in one base to numbers in a second base. There are $62$ different digits:\n\n$\\{ 0\\sim 9, A\\sim Z,a\\sim z \\}$\n\nHINT: If you make a sequence of base conversions using the output of one conversion as the input to the next, when you get back to the original base, you should get the original number.\n", "inputFormat": "The first line of input contains a single positive integer. This is the number of lines that follow. Each of the following lines will have a (decimal) input base followed by a (decimal) output base followed by a number expressed in the input base. Both the input base and the output base will be in the range from $2$ to $62$. That is (in decimal) $A = 10, B = 11, \\dots, Z = 35, a = 36, b = 37, \\dots, z = 61$ ($0\\sim 9$ have their usual meanings).", "outputFormat": "The output of the program should consist of three lines of output for each base conversion performed. The first line should be the input base in decimal followed by a space then the input number (as given expressed in the input base). The second output line should be the output base followed by a space then the input number (as expressed in the output base). The third output line is blank.", "hint": "题目保证 $1\\le T\\le 100$，要转换的数字是不超过 $10^{110}$ 的自然数。", "locale": "en", "translations": {"en": {"title": "Number Base Conversion", "background": "", "description": "Write a program to convert numbers in one base to numbers in a second base. There are $62$ different digits:\n\n$\\{ 0\\sim 9, A\\sim Z,a\\sim z \\}$\n\nHINT: If you make a sequence of base conversions using the output of one conversion as the input to the next, when you get back to the original base, you should get the original number.\n", "inputFormat": "The first line of input contains a single positive integer. This is the number of lines that follow. Each of the following lines will have a (decimal) input base followed by a (decimal) output base followed by a number expressed in the input base. Both the input base and the output base will be in the range from $2$ to $62$. That is (in decimal) $A = 10, B = 11, \\dots, Z = 35, a = 36, b = 37, \\dots, z = 61$ ($0\\sim 9$ have their usual meanings).", "outputFormat": "The output of the program should consist of three lines of output for each base conversion performed. The first line should be the input base in decimal followed by a space then the input number (as given expressed in the input base). The second output line should be the output base followed by a space then the input number (as expressed in the output base). The third output line is blank.", "hint": "题目保证 $1\\le T\\le 100$，要转换的数字是不超过 $10^{110}$ 的自然数。", "locale": "en"}, "zh-CN": {"title": "Number Base Conversion", "background": "", "description": "编写一个程序，将一个进制中的数字转换为另一个进制中的数字。有 $62$ 个不同的数字：\n\n${ 0\\sim 9, A\\sim Z,a\\sim z }$\n\n提示：如果你连续进行一系列的进制转换，将一个转换的输出作为下一个转换的输入，当你回到原始的进制时，你应该得到原始的数字。", "inputFormat": "输入的第一行包含一个正整数，表示接下来有多少行输入。接下来的每一行都包含一个输入进制（十进制表示）和一个输出进制（十进制表示），然后是以输入进制表示的数字。输入进制和输出进制都将在 $2$ 到 $62$ 的范围内。也就是说（十进制表示）$A = 10, B = 11, \\dots, Z = 35, a = 36, b = 37, \\dots, z = 61$，（$0\\sim 9$ 的意思与平常一样）。", "outputFormat": "程序的输出应该包括每次进制转换的三行输出。第一行应该是以十进制表示的输入进制，然后是一个空格，接着是以输入进制表示的输入数字。第二行输出是输出进制，然后是一个空格，接着是以输出进制表示的输入数字。第三行输出是空白行。\n\n翻译来自于：ChatGPT。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10463", "type": "P", "difficulty": 5, "samples": [["5 5\n1 3 5 7 9\nQ 1 5\nC 1 5 1\nQ 1 5\nC 3 3 6\nQ 2 4", "1\n2\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "最大公约数 gcd"], "title": "Interval GCD", "background": null, "description": "给定一个长度为 $N$ 的数列 $a$，以及 $M$ 条指令，每条指令可能是以下两种之一：\n\n1. `C l r d`，表示把 $a_l,a_{l+1},…,a_r$ 都加上 $d$。\n2. `Q l r`，表示询问 $a_l,a_{l+1},…,a_r$ 的最大公约数（$\\gcd$）。\n\n对于每个询问，输出一个整数表示答案。", "inputFormat": "第一行两个整数 $N,M$。\n\n第二行 $N$ 个整数，分别表示 $a_1,a_2,\\dots,a_N$。\n\n接下来 $M$ 行表示 $M$ 条指令，每条指令的格式如题目描述所示。", "outputFormat": "对于每个询问，输出一个整数表示答案，每个答案占一行。", "hint": "对于 $100\\%$ 的测试数据，$N \\le 5\\times10^5$，$M \\le 10^5$，$1 \\le a_i \\le 10^{18}$，$|d| \\le 10^{18}$，保证数据在计算过程中不会超过 long long 范围。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Interval GCD", "background": null, "description": "给定一个长度为 $N$ 的数列 $a$，以及 $M$ 条指令，每条指令可能是以下两种之一：\n\n1. `C l r d`，表示把 $a_l,a_{l+1},…,a_r$ 都加上 $d$。\n2. `Q l r`，表示询问 $a_l,a_{l+1},…,a_r$ 的最大公约数（$\\gcd$）。\n\n对于每个询问，输出一个整数表示答案。", "inputFormat": "第一行两个整数 $N,M$。\n\n第二行 $N$ 个整数，分别表示 $a_1,a_2,\\dots,a_N$。\n\n接下来 $M$ 行表示 $M$ 条指令，每条指令的格式如题目描述所示。", "outputFormat": "对于每个询问，输出一个整数表示答案，每个答案占一行。", "hint": "对于 $100\\%$ 的测试数据，$N \\le 5\\times10^5$，$M \\le 10^5$，$1 \\le a_i \\le 10^{18}$，$|d| \\le 10^{18}$，保证数据在计算过程中不会超过 long long 范围。", "locale": "zh-CN"}}}
{"pid": "P10464", "type": "P", "difficulty": 3, "samples": [["1 2 \n100 3 \n100 2 \n100 1", "1 50004"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心"], "title": "Task", "background": "", "description": "Today the company has $m$ tasks to complete. The $i-$th task need $x_i$ minutes to complete. Meanwhile, this task has a difficulty level $y_i$. The machine whose level below this task’s level $y_i$ cannot complete this task. If the company completes this task, they will get $(500\\times x_i+2\\times y_i)$ dollars.\n\nThe company has $n$ machines. Each machine has a maximum working time and a level. If the time for the task is more than the maximum working time of the machine, the machine can not complete this task. Each machine can only complete a task one day. Each task can only be completed by one machine.\n\nThe company hopes to maximize the number of the tasks which they can complete today. If there are multiple solutions, they hopes to make the money maximum.", "inputFormat": "The input contains several test cases.\n\nThe first line contains two integers $N$ and $M$. $N$ is the number of the machines.M is the number of tasks $(1 \\leq N \\leq 100000, 1\\leq M\\leq 100000)$.\n\nThe following $N$ lines each contains two integers $x_i(0<x_i<1440),y_i(0\\leq yi\\leq 100)$. $x_i$ is the maximum time the machine can work. $y_i$ is the level of the machine. \n\nThe following $M$ lines each contains two integers $x_i(0<x_i<1440),y_i(0\\leq y_i\\leq 100)$. $x_i$ is the time we need to complete the task. $y_i$ is the level of the task.", "outputFormat": "For each test case, output two integers, the maximum number of the tasks which the company can complete today and the money they will get.", "hint": "", "locale": "en", "translations": {"en": {"title": "Task", "background": "", "description": "Today the company has $m$ tasks to complete. The $i-$th task need $x_i$ minutes to complete. Meanwhile, this task has a difficulty level $y_i$. The machine whose level below this task’s level $y_i$ cannot complete this task. If the company completes this task, they will get $(500\\times x_i+2\\times y_i)$ dollars.\n\nThe company has $n$ machines. Each machine has a maximum working time and a level. If the time for the task is more than the maximum working time of the machine, the machine can not complete this task. Each machine can only complete a task one day. Each task can only be completed by one machine.\n\nThe company hopes to maximize the number of the tasks which they can complete today. If there are multiple solutions, they hopes to make the money maximum.", "inputFormat": "The input contains several test cases.\n\nThe first line contains two integers $N$ and $M$. $N$ is the number of the machines.M is the number of tasks $(1 \\leq N \\leq 100000, 1\\leq M\\leq 100000)$.\n\nThe following $N$ lines each contains two integers $x_i(0<x_i<1440),y_i(0\\leq yi\\leq 100)$. $x_i$ is the maximum time the machine can work. $y_i$ is the level of the machine. \n\nThe following $M$ lines each contains two integers $x_i(0<x_i<1440),y_i(0\\leq y_i\\leq 100)$. $x_i$ is the time we need to complete the task. $y_i$ is the level of the task.", "outputFormat": "For each test case, output two integers, the maximum number of the tasks which the company can complete today and the money they will get.", "hint": "", "locale": "en"}, "zh-CN": {"title": "Task", "background": "", "description": "今天公司有 $m$ 项任务要完成。第 $i$ 项任务需要 $x_i$ 分钟来完成。同时，这个任务有一个困难级别 $y_i$。级别低于该任务级别 $y_i$ 的机器无法完成这项任务。如果公司完成了这项任务，他们将获得 $(500\\times x_i+2\\times y_i)$ 美元。\n\n公司有 $n$ 台机器。每台机器都有最大工作时间和一个级别。如果任务的时间超过机器的最大工作时间，则该机器无法完成这个任务。每台机器一天只能完成一项任务。每项任务只能由一台机器完成。\n\n公司希望最大化今天他们可以完成的任务数量。如果存在多个解决方案，他们希望使收益最大化。", "inputFormat": "第一行包含两个整数 $N$ 和 $M$。$N$ 是机器的数量。$M$ 是任务的数量 $(1 \\leq N \\leq 100000, 1\\leq M\\leq 100000)$。\n\n接下来的 $N$ 行每行包含两个整数 $x_i(0<x_i<1440),y_i(0\\leq y_i\\leq 100)$。$x_i$ 是机器可以工作的最长时间。$y_i$ 是机器的级别。\n\n接下来的 $M$ 行每行包含两个整数 $x_i(0<x_i<1440),y_i(0\\leq y_i\\leq 100)$。$x_i$ 是完成任务所需的时间。$y_i$ 是任务的级别。", "outputFormat": "对于每个测试用例，输出两个整数，分别是公司今天可以完成的最大任务数量和他们将获得的收益。\n\n翻译来自于：ChatGPT。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10465", "type": "P", "difficulty": 5, "samples": [["6\n3\n6\n0\n9\n6\n3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["Ad-hoc"], "title": "双端队列", "background": "", "description": "Sherry 现在碰到了一个棘手的问题，有 $N(1 \\le N \\le 200000)$ 个整数需要排序。\n\nSherry 手头能用的工具就是若干个双端队列。\n\n她从 $1$ 到 $N$ 需要依次处理这 $N$ 个数，对于每个数，Sherry 能做以下两件事：\n\n1．新建一个双端队列，并将当前数作为这个队列中的唯一的数；\n\n2．将当前数放入已有的队列的头之前或者尾之后。\n\n对所有的数处理完成之后，Sherry 将这些队列按一定的顺序连接起来后就可以得到一个非降的序列。\n\n请你求出最少需要多少个双端序列。", "inputFormat": "第一行输入整数 $N$，代表整数的个数。\n\n接下来 $N$ 行，每行包括一个整数 $D_i$，代表所需处理的整数。", "outputFormat": "输出一个整数，代表最少需要的双端队列数。\n", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "双端队列", "background": "", "description": "Sherry 现在碰到了一个棘手的问题，有 $N(1 \\le N \\le 200000)$ 个整数需要排序。\n\nSherry 手头能用的工具就是若干个双端队列。\n\n她从 $1$ 到 $N$ 需要依次处理这 $N$ 个数，对于每个数，Sherry 能做以下两件事：\n\n1．新建一个双端队列，并将当前数作为这个队列中的唯一的数；\n\n2．将当前数放入已有的队列的头之前或者尾之后。\n\n对所有的数处理完成之后，Sherry 将这些队列按一定的顺序连接起来后就可以得到一个非降的序列。\n\n请你求出最少需要多少个双端序列。", "inputFormat": "第一行输入整数 $N$，代表整数的个数。\n\n接下来 $N$ 行，每行包括一个整数 $D_i$，代表所需处理的整数。", "outputFormat": "输出一个整数，代表最少需要的双端队列数。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10466", "type": "P", "difficulty": 3, "samples": [["3\n1 5 3", "4 1\n2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["链表"], "title": "邻值查找", "background": "", "description": "给定一个长度为 $n$ 的序列 $A$，$A$ 中的数各不相同。\n\n对于 $A$ 中的每一个数 $A_i$，求：\n\n$\\min_{1 \\le j <i}|A_i-A_j|$\n\n以及令上式取到最小值的 $j$（记为 $P_i$）。若最小值点不唯一，则选择使 $A_j$ 较小的那个。", "inputFormat": "第一行输入整数 $n$，代表序列长度。\n\n第二行输入 $n$ 个整数 $A_1 \\sim A_n$，代表序列的具体数值，数值之间用空格隔开。", "outputFormat": "输出共 $n-1$ 行，每行输出两个整数，数值之间用空格隔开。\n\n分别表示当 $i$ 取 $2 \\sim n$ 时，对应的 $\\min_{1 \\le j <i}|A_i-A_j|$ 和 $P_i$ 的值。", "hint": "对于 $30\\%$ 的数据 $n \\le 100$。\n\n对于 $70\\%$ 的数据 $n \\le 10^4$。\n\n对于 $100\\%$ 的数据 $n \\le 10^5,|A_i| \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "邻值查找", "background": "", "description": "给定一个长度为 $n$ 的序列 $A$，$A$ 中的数各不相同。\n\n对于 $A$ 中的每一个数 $A_i$，求：\n\n$\\min_{1 \\le j <i}|A_i-A_j|$\n\n以及令上式取到最小值的 $j$（记为 $P_i$）。若最小值点不唯一，则选择使 $A_j$ 较小的那个。", "inputFormat": "第一行输入整数 $n$，代表序列长度。\n\n第二行输入 $n$ 个整数 $A_1 \\sim A_n$，代表序列的具体数值，数值之间用空格隔开。", "outputFormat": "输出共 $n-1$ 行，每行输出两个整数，数值之间用空格隔开。\n\n分别表示当 $i$ 取 $2 \\sim n$ 时，对应的 $\\min_{1 \\le j <i}|A_i-A_j|$ 和 $P_i$ 的值。", "hint": "对于 $30\\%$ 的数据 $n \\le 100$。\n\n对于 $70\\%$ 的数据 $n \\le 10^4$。\n\n对于 $100\\%$ 的数据 $n \\le 10^5,|A_i| \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10467", "type": "P", "difficulty": 3, "samples": [["2 \n1 2 3 4 5 6 \n4 3 2 1 6 5", "Twin snowflakes found."]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2007", "CCC（加拿大）", "哈希 hashing"], "title": "[CCC 2007] Snowflake Snow Snowflakes", "background": "", "description": "You may have heard that no two snowflakes are alike. Your task is to write a program to determine whether this is really true. Your program will read information about a collection of snowflakes, and search for a pair that may be identical. Each snowflake has six arms. For each snowflake, your program will be provided with a measurement of the length of each of the six arms. Any pair of snowflakes which have the same lengths of corresponding arms should be flagged by your program as possibly identical.", "inputFormat": "The first line of input will contain a single integer $n$, $0 < n \\le 100000$ , the number of snowflakes to follow. This will be followed by $n$ lines, each describing a snowflake. Each snowflake will be described by a line containing six integers (each integer is at least $0$ and less than $10000000$) , the lengths of the arms of the snow ake. The lengths of the arms will be given in order around the snowflake (either clockwise or counterclockwise), but they may begin with any of the six arms. For example, the same snowflake could be described as $1 2 3 4 5 6$ or $4 3 2 1 6 5$ . ", "outputFormat": "If all of the snowflakes are distinct, your program should print the message:\n\n`No two snowflakes are alike.`\n\nIf there is a pair of possibly identical snow akes, your program should print the message:\n\n`Twin snowflakes found.`", "hint": "", "locale": "en", "translations": {"en": {"title": "[CCC 2007] Snowflake Snow Snowflakes", "background": "", "description": "You may have heard that no two snowflakes are alike. Your task is to write a program to determine whether this is really true. Your program will read information about a collection of snowflakes, and search for a pair that may be identical. Each snowflake has six arms. For each snowflake, your program will be provided with a measurement of the length of each of the six arms. Any pair of snowflakes which have the same lengths of corresponding arms should be flagged by your program as possibly identical.", "inputFormat": "The first line of input will contain a single integer $n$, $0 < n \\le 100000$ , the number of snowflakes to follow. This will be followed by $n$ lines, each describing a snowflake. Each snowflake will be described by a line containing six integers (each integer is at least $0$ and less than $10000000$) , the lengths of the arms of the snow ake. The lengths of the arms will be given in order around the snowflake (either clockwise or counterclockwise), but they may begin with any of the six arms. For example, the same snowflake could be described as $1 2 3 4 5 6$ or $4 3 2 1 6 5$ . ", "outputFormat": "If all of the snowflakes are distinct, your program should print the message:\n\n`No two snowflakes are alike.`\n\nIf there is a pair of possibly identical snow akes, your program should print the message:\n\n`Twin snowflakes found.`", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CCC 2007] Snowflake Snow Snowflakes", "background": "", "description": "你可能听说过没有两片雪花是相同的。你的任务是编写一个程序来确定这是否真的是正确的。你的程序将读取关于一组雪花的信息，并搜索可能相同的一对雪花。每片雪花有六条“角”。对于每片雪花，你的程序将提供每条角的长度测量。任何一对长度对应的角相同的雪花都应该被你的程序标记为可能相同。", "inputFormat": "输入的第一行包含一个整数 $n$，$0 < n \\le 100000$，表示接下来的雪花数量。接下来的 $n$ 行描述每片雪花。每片雪花由包含六个整数的一行描述（每个整数至少为 $0$ 且小于 $10000000$），表示雪花的六条角的长度。角的长度将按顺序围绕着雪花给出（顺时针或逆时针），但它们可以从六个角中的任何一条开始。例如，同一片雪花可以描述为 $1\\ 2\\ 3\\ 4\\ 5\\ 6$ 或 $4\\ 3\\ 2\\ 1\\ 6\\ 5$。", "outputFormat": "如果所有的雪花都是不同的，你的程序应该打印消息：\n\n`No two snowflakes are alike.`\n\n如果有一对可能相同的雪花，你的程序应该打印消息：\n\n`Twin snowflakes found.`\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10468", "type": "P", "difficulty": 3, "samples": [["aabbaabb\n3\n1 3 5 7\n1 3 6 8\n1 2 1 2", "Yes\nNo\nYes"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["哈希 hashing"], "title": "兔子与兔子", "background": null, "description": "很久很久以前，森林里住着一群兔子。\n\n有一天，兔子们想要研究自己的 DNA 序列。\n\n我们首先选取一个好长好长的 DNA 序列（小兔子是外星生物，DNA 序列可能包含 $26$ 个小写英文字母）。\n\n然后我们每次选择两个区间，询问如果用两个区间里的 DNA 序列分别生产出来两只兔子，这两个兔子是否一模一样。\n\n注意两个兔子一模一样只可能是他们的 DNA 序列一模一样。", "inputFormat": "第一行输入一个 DNA 字符串 $S$。\n\n第二行一个数字 $m$，表示 $m$ 次询问。\n\n接下来 $m$ 行，每行四个数字 $l_1, r_1, l_2, r_2$，分别表示此次询问的两个区间，注意字符串的位置从 $1$ 开始编号。", "outputFormat": "对于每次询问，输出一行表示结果。\n\n如果两只兔子完全相同输出 `Yes`，否则输出 `No`（注意大小写）。", "hint": "数据保证，$1 \\le |S|,m \\le 10^6$。其中，$|S|$ 为字符串 $S$ 的长度。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "兔子与兔子", "background": null, "description": "很久很久以前，森林里住着一群兔子。\n\n有一天，兔子们想要研究自己的 DNA 序列。\n\n我们首先选取一个好长好长的 DNA 序列（小兔子是外星生物，DNA 序列可能包含 $26$ 个小写英文字母）。\n\n然后我们每次选择两个区间，询问如果用两个区间里的 DNA 序列分别生产出来两只兔子，这两个兔子是否一模一样。\n\n注意两个兔子一模一样只可能是他们的 DNA 序列一模一样。", "inputFormat": "第一行输入一个 DNA 字符串 $S$。\n\n第二行一个数字 $m$，表示 $m$ 次询问。\n\n接下来 $m$ 行，每行四个数字 $l_1, r_1, l_2, r_2$，分别表示此次询问的两个区间，注意字符串的位置从 $1$ 开始编号。", "outputFormat": "对于每次询问，输出一行表示结果。\n\n如果两只兔子完全相同输出 `Yes`，否则输出 `No`（注意大小写）。", "hint": "数据保证，$1 \\le |S|,m \\le 10^6$。其中，$|S|$ 为字符串 $S$ 的长度。", "locale": "zh-CN"}}}
{"pid": "P10469", "type": "P", "difficulty": 4, "samples": [["ponoiiipoi", "9 4 5 6 2 8 3 1 7 0\n0 1 2 1 0 0 2 1 0 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "倍增", "二分", "排序", "哈希 hashing"], "title": "后缀数组", "background": "", "description": "后缀数组 (SA) 是一种重要的数据结构，通常使用倍增或者 DC3 算法实现，这超出了我们的讨论范围。\n\n在本题中，我们希望使用快排、Hash 与二分实现一个简单的 $O(n\\log^2n)$ 的后缀数组求法。\n\n详细地说，给定一个长度为 $n$ 的字符串 $S$（下标 $0 \\sim n-1$），我们可以用整数 $k(0 \\le k < n)$ 表示字符串 $S$ 的后缀 $S(k \\sim n-1)$。\n\n把字符串 $S$ 的所有后缀按照字典序排列，排名为 $i$ 的后缀记为 SA[i]。\n\n额外地，我们考虑排名为 $i$ 的后缀与排名为 $i-1$ 的后缀，把二者的最长公共前缀的长度记为 Height[i]。\n\n我们的任务就是求出 SA 与 Height 这两个数组。", "inputFormat": "输入一个字符串，其长度不超过 $30$ 万。\n\n字符串由小写字母构成。", "outputFormat": "第一行为数组 SA，相邻两个整数用 $1$ 个空格隔开。\n\n第二行为数组 Height，相邻两个整数用 $1$ 个空格隔开，我们规定 Height[1]=0。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "后缀数组", "background": "", "description": "后缀数组 (SA) 是一种重要的数据结构，通常使用倍增或者 DC3 算法实现，这超出了我们的讨论范围。\n\n在本题中，我们希望使用快排、Hash 与二分实现一个简单的 $O(n\\log^2n)$ 的后缀数组求法。\n\n详细地说，给定一个长度为 $n$ 的字符串 $S$（下标 $0 \\sim n-1$），我们可以用整数 $k(0 \\le k < n)$ 表示字符串 $S$ 的后缀 $S(k \\sim n-1)$。\n\n把字符串 $S$ 的所有后缀按照字典序排列，排名为 $i$ 的后缀记为 SA[i]。\n\n额外地，我们考虑排名为 $i$ 的后缀与排名为 $i-1$ 的后缀，把二者的最长公共前缀的长度记为 Height[i]。\n\n我们的任务就是求出 SA 与 Height 这两个数组。", "inputFormat": "输入一个字符串，其长度不超过 $30$ 万。\n\n字符串由小写字母构成。", "outputFormat": "第一行为数组 SA，相邻两个整数用 $1$ 个空格隔开。\n\n第二行为数组 Height，相邻两个整数用 $1$ 个空格隔开，我们规定 Height[1]=0。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10470", "type": "P", "difficulty": 3, "samples": [["3 2\nab\nbc\nabc\nabc\nefg", "2\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["字典树 Trie"], "title": "前缀统计", "background": null, "description": "给定 $N$ 个字符串 $S_1,S_2,\\cdots,S_N$，接下来进行 $M$ 次询问，每次询问给定一个字符串 $T$，求 $S_1 \\sim S_N$ 中有多少个字符串是 $T$ 的前缀。\n\n输入字符串的总长度不超过 $10^6$，仅包含小写字母。", "inputFormat": "第一行输入两个整数 $N,M$。\n\n接下来 $N$ 行每行输入一个字符串 $S_i$。\n\n接下来 $M$ 行每行一个字符串 $T$ 用以询问。", "outputFormat": "对于每个询问，输出一个整数表示答案。\n\n每个答案占一行。", "hint": "数据范围满足 $1 \\le N,M \\le 10^5$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "前缀统计", "background": null, "description": "给定 $N$ 个字符串 $S_1,S_2,\\cdots,S_N$，接下来进行 $M$ 次询问，每次询问给定一个字符串 $T$，求 $S_1 \\sim S_N$ 中有多少个字符串是 $T$ 的前缀。\n\n输入字符串的总长度不超过 $10^6$，仅包含小写字母。", "inputFormat": "第一行输入两个整数 $N,M$。\n\n接下来 $N$ 行每行输入一个字符串 $S_i$。\n\n接下来 $M$ 行每行一个字符串 $T$ 用以询问。", "outputFormat": "对于每个询问，输出一个整数表示答案。\n\n每个答案占一行。", "hint": "数据范围满足 $1 \\le N,M \\le 10^5$", "locale": "zh-CN"}}}
{"pid": "P10471", "type": "P", "difficulty": 3, "samples": [["3\n1 2 3", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["字典树 Trie"], "title": "最大异或对 The XOR Largest Pair", "background": null, "description": "给定 $N$ 个整数 $A_1.A_2, \\cdots, A_N$ 中选出两个进行异或计算，得到的结果最大是多少？", "inputFormat": "第一行一个整数 $N$，第二行 $N$ 个整数 $A_1.A_2, \\cdots, A_N$。", "outputFormat": "一个整数表示答案。", "hint": "对于所有测试数据，$1 \\le N \\le 10^5$，保证 $0\\le A_i<2^{31}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "最大异或对 The XOR Largest Pair", "background": null, "description": "给定 $N$ 个整数 $A_1.A_2, \\cdots, A_N$ 中选出两个进行异或计算，得到的结果最大是多少？", "inputFormat": "第一行一个整数 $N$，第二行 $N$ 个整数 $A_1.A_2, \\cdots, A_N$。", "outputFormat": "一个整数表示答案。", "hint": "对于所有测试数据，$1 \\le N \\le 10^5$，保证 $0\\le A_i<2^{31}$。", "locale": "zh-CN"}}}
{"pid": "P10472", "type": "P", "difficulty": 2, "samples": [["({({(({()}})}{())})})[){{{([)()((()]]}])[{)]}{[}{)", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "栈"], "title": "括号画家", "background": null, "description": "Candela 是一名漫画家，她有一个奇特的爱好，就是在纸上画括号。这一天，刚刚起床的 Candela 画了一排括号序列，其中包含小括号 `()`、中括号 `[]` 和大括号 `{}`，总长度为 $N$。这排随意绘制的括号序列显得杂乱无章，于是 Candela 定义了什么样的括号序列是美观的：\n\n1. 空的括号序列是美观的；\n2. 若括号序列 A 是美观的，则括号序列 `(A)`、`[A]`、`{A}` 也是美观的；\n3. 若括号序列 A、B 都是美观的，则括号序列 `AB` 也是美观的；\n\n例如 `[(){}]()` 是美观的括号序列，而 `)({)[}](` 则不是。\n\n现在 Candela 想在她绘制的括号序列中，找出其中连续的一段，满足这段子序列是美观的，并且长度尽量大。你能帮帮她吗？", "inputFormat": "第一行一个长度为 $N$ 的括号序列。", "outputFormat": "一个整数，表示最长的美观的连续子序列的长度。", "hint": "数据保证，$5\\leq N \\leq 10^4$，其中各个测试点的 $N$ 的大小分别为：$5,10,50,100,100,1000,1000,10000,10000,10000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "括号画家", "background": null, "description": "Candela 是一名漫画家，她有一个奇特的爱好，就是在纸上画括号。这一天，刚刚起床的 Candela 画了一排括号序列，其中包含小括号 `()`、中括号 `[]` 和大括号 `{}`，总长度为 $N$。这排随意绘制的括号序列显得杂乱无章，于是 Candela 定义了什么样的括号序列是美观的：\n\n1. 空的括号序列是美观的；\n2. 若括号序列 A 是美观的，则括号序列 `(A)`、`[A]`、`{A}` 也是美观的；\n3. 若括号序列 A、B 都是美观的，则括号序列 `AB` 也是美观的；\n\n例如 `[(){}]()` 是美观的括号序列，而 `)({)[}](` 则不是。\n\n现在 Candela 想在她绘制的括号序列中，找出其中连续的一段，满足这段子序列是美观的，并且长度尽量大。你能帮帮她吗？", "inputFormat": "第一行一个长度为 $N$ 的括号序列。", "outputFormat": "一个整数，表示最长的美观的连续子序列的长度。", "hint": "数据保证，$5\\leq N \\leq 10^4$，其中各个测试点的 $N$ 的大小分别为：$5,10,50,100,100,1000,1000,10000,10000,10000$。", "locale": "zh-CN"}}}
{"pid": "P10473", "type": "P", "difficulty": 4, "samples": [["(2+2)^(1+1)", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "O2优化", "栈"], "title": "表达式计算4", "background": "", "description": "给出一个表达式，其中运算符仅包含 +，-，*，/，^，要求求出表达式的最终值。\n\n数据可能会出现括号情况，还有可能出现多余括号情况。\n\n数据保证不会出现超过 int 范围的数据，数据可能会出现负数情况。", "inputFormat": "仅一行一个字符串，即为表达式。\n", "outputFormat": "仅一行，既为表达式算出的结果。", "hint": "表达式总长度不超过 $30$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "表达式计算4", "background": "", "description": "给出一个表达式，其中运算符仅包含 +，-，*，/，^，要求求出表达式的最终值。\n\n数据可能会出现括号情况，还有可能出现多余括号情况。\n\n数据保证不会出现超过 int 范围的数据，数据可能会出现负数情况。", "inputFormat": "仅一行一个字符串，即为表达式。\n", "outputFormat": "仅一行，既为表达式算出的结果。", "hint": "表达式总长度不超过 $30$。", "locale": "zh-CN"}}}
{"pid": "P10474", "type": "P", "difficulty": 4, "samples": [["3 3 2 2\n111\n000\n111\n3\n11\n00\n11\n11\n00\n11", "1\n0\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2011", "北京", "哈希 hashing", "ICPC"], "title": "[ICPC-Beijing 2011] Matrix 矩阵哈希", "background": null, "description": "给定一个 $M$ 行 $N$ 列的 $01$ 矩阵，以及 $Q$ 个 $A$ 行 $B$ 列的 $01$ 矩阵，你需要求出这 $Q$ 个矩阵哪些在原矩阵中出现过。 \n\n所谓 $01$ 矩阵，就是矩阵中所有元素不是 $0$ 就是 $1$。", "inputFormat": "输入文件的第一行为 $M,N,A,B$，参见题目描述。 \n\n接下来 $M$ 行，每行 $N$ 个字符，非 $0$ 即 $1$ ，描述原矩阵。 \n\n接下来一行为你要处理的询问数 $Q$。\n\n接下来 $Q$ 个矩阵，一共 $Q\\times A$ 行，每行 $B$ 个字符，描述 $Q$ 个 $01$ 矩阵。", "outputFormat": "你需要输出 $Q$ 行，每行为 $0$ 或者 $1$，表示这个矩阵是否出现过，$0$ 表示没有出现过，$1$ 表示出现过。", "hint": "对于 $100\\%$ 的实际测试数据，$1\\leq M,N \\leq 1000$，$Q = 1000$。 \n\n对于 $40\\%$ 的数据，$A = 1$。\n\n对于 $80\\%$ 的数据，$A \\leq 10$。\n\n对于 $100\\%$ 的数据，$A \\leq 100$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC-Beijing 2011] Matrix 矩阵哈希", "background": null, "description": "给定一个 $M$ 行 $N$ 列的 $01$ 矩阵，以及 $Q$ 个 $A$ 行 $B$ 列的 $01$ 矩阵，你需要求出这 $Q$ 个矩阵哪些在原矩阵中出现过。 \n\n所谓 $01$ 矩阵，就是矩阵中所有元素不是 $0$ 就是 $1$。", "inputFormat": "输入文件的第一行为 $M,N,A,B$，参见题目描述。 \n\n接下来 $M$ 行，每行 $N$ 个字符，非 $0$ 即 $1$ ，描述原矩阵。 \n\n接下来一行为你要处理的询问数 $Q$。\n\n接下来 $Q$ 个矩阵，一共 $Q\\times A$ 行，每行 $B$ 个字符，描述 $Q$ 个 $01$ 矩阵。", "outputFormat": "你需要输出 $Q$ 行，每行为 $0$ 或者 $1$，表示这个矩阵是否出现过，$0$ 表示没有出现过，$1$ 表示出现过。", "hint": "对于 $100\\%$ 的实际测试数据，$1\\leq M,N \\leq 1000$，$Q = 1000$。 \n\n对于 $40\\%$ 的数据，$A = 1$。\n\n对于 $80\\%$ 的数据，$A \\leq 10$。\n\n对于 $100\\%$ 的数据，$A \\leq 100$。", "locale": "zh-CN"}}}
{"pid": "P10475", "type": "P", "difficulty": 4, "samples": [["2 5 \nABABA \nABABA\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["USACO", "哈希 hashing", "KMP 算法"], "title": "[USACO03FALL] Milking Grid（数据加强版）", "background": "", "description": "Every morning when they are milked, the Farmer John's cows form a rectangular grid that is $R (1 \\leq R \\leq 10,000)$ rows by $C (1 \\leq C \\leq 75)$ columns. As we all know, Farmer John is quite the expert on cow behavior, and is currently writing a book about feeding behavior in cows. He notices that if each cow is labeled with an uppercase letter indicating its breed, the two-dimensional pattern formed by his cows during milking sometimes seems to be made from smaller repeating rectangular patterns.\n\nHelp FJ find the rectangular unit of smallest area that can be repetitively tiled to make up the entire milking grid. Note that the dimensions of the small rectangular unit do not necessarily need to divide evenly the dimensions of the entire milking grid, as indicated in the sample input below.", "inputFormat": "- Line $1$: Two space-separated integers: $R$ and $C$\n\n- Lines $2\\dots R+1$: The grid that the cows form, with an uppercase letter denoting each cow's breed. Each of the $R$ input lines has $C$ characters with no space or other intervening character.", "outputFormat": "- Line 1: The area of the smallest unit from which the grid is formed", "hint": "The entire milking grid can be constructed from repetitions of the pattern `AB`.", "locale": "en", "translations": {"en": {"title": "[USACO03FALL] Milking Grid（数据加强版）", "background": "", "description": "Every morning when they are milked, the Farmer John's cows form a rectangular grid that is $R (1 \\leq R \\leq 10,000)$ rows by $C (1 \\leq C \\leq 75)$ columns. As we all know, Farmer John is quite the expert on cow behavior, and is currently writing a book about feeding behavior in cows. He notices that if each cow is labeled with an uppercase letter indicating its breed, the two-dimensional pattern formed by his cows during milking sometimes seems to be made from smaller repeating rectangular patterns.\n\nHelp FJ find the rectangular unit of smallest area that can be repetitively tiled to make up the entire milking grid. Note that the dimensions of the small rectangular unit do not necessarily need to divide evenly the dimensions of the entire milking grid, as indicated in the sample input below.", "inputFormat": "- Line $1$: Two space-separated integers: $R$ and $C$\n\n- Lines $2\\dots R+1$: The grid that the cows form, with an uppercase letter denoting each cow's breed. Each of the $R$ input lines has $C$ characters with no space or other intervening character.", "outputFormat": "- Line 1: The area of the smallest unit from which the grid is formed", "hint": "The entire milking grid can be constructed from repetitions of the pattern `AB`.", "locale": "en"}, "zh-CN": {"title": "[USACO03FALL] Milking Grid（数据加强版）", "background": null, "description": "每天早上挤奶时，农夫约翰的奶牛们排成一个 $R (1 \\leq R \\leq 10,000)$ 行乘 $C (1 \\leq C \\leq 75)$ 列的矩形网格。众所周知，农夫约翰是一个相当擅长牛行为的专家，目前正在撰写一本关于奶牛饲养行为的书。他注意到，如果每头奶牛都标有一个表示其品种的大写字母，那么奶牛在挤奶时形成的二维图案有时似乎是由更小的重复矩形图案组成的。\n\n帮助农夫约翰找到可以重复铺设以组成整个挤奶网格的最小面积的矩形单元。请注意，小矩形单元的尺寸不一定需要完全整除整个挤奶网格的尺寸，如下面的示例输入所示。", "inputFormat": "- 第一行：两个用空格分隔的整数：$R$ 和 $C$。\n- 第 $2\\dots R+1$ 行：奶牛形成的网格，每个奶牛的品种用大写字母表示。每个 $R$ 输入行有 $C$ 个字符，没有空格或其他间隔字符。", "outputFormat": "第一行：形成网格的最小单位的面积。", "hint": "整个挤奶网格可以由图案 AB 的重复构建。\n\n翻译来自于：ChatGPT。", "locale": "zh-CN"}}}
{"pid": "P10476", "type": "P", "difficulty": 5, "samples": [["2234342423 \n2423223434", "Yes\n2234342423"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["哈希 hashing", "双指针 two-pointer"], "title": "Necklace", "background": "", "description": "有一天，袁同学绵了一条价值连城宝石项链，但是，一个严重的问题是，他竟然忘记了项链的主人是谁！在得知此事后，很多人向同学发来了很多邮件，都说项链是自己的，要求他归还（显然其中最多只有一个人说了真话）。袁同学要求每个人都写了一段关于自己项链的描述：\n\n项链上的宝石用数字 $0$ 至 $9$ 来表示。一个对于项链的表示就是从项链的某个宝石开始：顺指针绕一圈，沿途记下经过的宝石，比如如下项链：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/57501u19.png)\n\n它的可能的四种表示是 $0123$、$1230$、$2301$、$3012$。\n\n袁同学现在心急如焚，于是他找到了你，希望你能够编一个程序，判断两个给定的描述是否代表同一个项链（注意，项链是不会翻转的）。", "inputFormat": "输入文件只有两行，每行一个由 $0$ 至 $9$ 组成的字符串，描述一个项链的表示（保证项链的长度是相等的）。", "outputFormat": "如果两条项链不可能同构，那么输出 `No`，否则的话，第一行输出一个 `Yes` 第二行输出该项链的字典序最小的表示。", "hint": "设 $L =$ 项链长度，则 $1\\leq L \\leq 1000000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Necklace", "background": "", "description": "有一天，袁同学绵了一条价值连城宝石项链，但是，一个严重的问题是，他竟然忘记了项链的主人是谁！在得知此事后，很多人向同学发来了很多邮件，都说项链是自己的，要求他归还（显然其中最多只有一个人说了真话）。袁同学要求每个人都写了一段关于自己项链的描述：\n\n项链上的宝石用数字 $0$ 至 $9$ 来表示。一个对于项链的表示就是从项链的某个宝石开始：顺指针绕一圈，沿途记下经过的宝石，比如如下项链：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/57501u19.png)\n\n它的可能的四种表示是 $0123$、$1230$、$2301$、$3012$。\n\n袁同学现在心急如焚，于是他找到了你，希望你能够编一个程序，判断两个给定的描述是否代表同一个项链（注意，项链是不会翻转的）。", "inputFormat": "输入文件只有两行，每行一个由 $0$ 至 $9$ 组成的字符串，描述一个项链的表示（保证项链的长度是相等的）。", "outputFormat": "如果两条项链不可能同构，那么输出 `No`，否则的话，第一行输出一个 `Yes` 第二行输出该项链的字典序最小的表示。", "hint": "设 $L =$ 项链长度，则 $1\\leq L \\leq 1000000$。", "locale": "zh-CN"}}}
{"pid": "P10477", "type": "P", "difficulty": 3, "samples": [["2\n0010011101001011\n0100011011001011\n0100101100100111\n0011000111010101", "same\ndifferent"]], "limits": {"time": [1000, 1000], "memory": [524288, 524288]}, "tags": ["2003", "深度优先搜索 DFS", "图遍历", "树的遍历", "ICPC"], "title": "[NWERC 2003] Subway tree systems", "background": null, "description": "Some major cities have subway systems in the form of a tree, i.e. between any pair of stations, there is one and only one way of going by subway. Moreover, most of these cities have a unique central station. Imagine you are a tourist in one of these cities and you want to explore all of the subway system. You start at the central station and pick a subway line at random and jump aboard the subway car. Every time you arrive at a station, you pick one of the subway lines you have not yet travelled on. If there is none left to explore at your current station, you take the subway line back on which you first came to the station, until you eventually have travelled along all of the lines twice,once for each direction. At that point you are back at the central station. Afterwards, all you remember of the order of your exploration is whether you went further away from the central station or back towards it at any given time, i.e. you could encode your tour as a binary string, where 0 encodes taking a subway line getting you one station further away from the central station, and 1 encodes getting you one station closer to the central station.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/57sf9gvq.png)", "inputFormat": "On the first line of input is a single positive integer n, telling the number of test scenarios to follow.Each test scenario consists of two lines, each containing a string of the characters '0' and '1' of length at most 3000, both describing a correct exploration tour of a subway tree system.", "outputFormat": "exploration tours of the same subway tree system, or the text \"different\" if the two strings cannot be exploration tours of the same subway tree system.", "hint": null, "locale": "en", "translations": {"en": {"title": "[NWERC 2003] Subway tree systems", "background": null, "description": "Some major cities have subway systems in the form of a tree, i.e. between any pair of stations, there is one and only one way of going by subway. Moreover, most of these cities have a unique central station. Imagine you are a tourist in one of these cities and you want to explore all of the subway system. You start at the central station and pick a subway line at random and jump aboard the subway car. Every time you arrive at a station, you pick one of the subway lines you have not yet travelled on. If there is none left to explore at your current station, you take the subway line back on which you first came to the station, until you eventually have travelled along all of the lines twice,once for each direction. At that point you are back at the central station. Afterwards, all you remember of the order of your exploration is whether you went further away from the central station or back towards it at any given time, i.e. you could encode your tour as a binary string, where 0 encodes taking a subway line getting you one station further away from the central station, and 1 encodes getting you one station closer to the central station.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/57sf9gvq.png)", "inputFormat": "On the first line of input is a single positive integer n, telling the number of test scenarios to follow.Each test scenario consists of two lines, each containing a string of the characters '0' and '1' of length at most 3000, both describing a correct exploration tour of a subway tree system.", "outputFormat": "exploration tours of the same subway tree system, or the text \"different\" if the two strings cannot be exploration tours of the same subway tree system.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[NWERC 2003] Subway tree systems", "background": null, "description": "一些主要城市的地铁系统采用树状结构，即在任何两个车站之间，只有一条且仅有一条地铁线路。此外，大多数这些城市都有一个独特的中央车站。想象一下，你是这些城市中的一名游客，你想要探索整个地铁系统。你从中央车站出发，随机选择一条地铁线路，跳上地铁列车。每当你到达一个车站，你就会选择一条你尚未乘坐过的地铁线路。如果在当前车站没有其他要探索的地铁线路了，你就会乘坐第一次到达该车站的地铁线路返回，直到最终你沿着所有的线路都行驶了两次，即每个方向都行驶了一次。在那时，你回到了中央车站。之后，你所记得的探索顺序只是在任何给定时间是否向中央车站更远或更近，也就是说，你可以将你的旅程编码为一个二进制字符串，其中 0 表示乘坐一条地铁线路使你离中央车站更远一站，而 1 表示使你离中央车站更近一站。", "inputFormat": "输入的第一行是一个正整数 $n$，表示接下来要跟随的测试方案的数量。每个测试方案包括两行，每行包含一个长度最多为 $3000$ 的由字符 '0' 和 '1' 组成的字符串，描述了地铁树系统的正确探索旅程。", "outputFormat": "对于每个测试方案，如果两个字符串可以表示相同地铁树系统的探索旅程，则输出 \"same\"；如果两个字符串不能表示相同地铁树系统的探索旅程，则输出 \"different\"。\n\n翻译来自于：ChatGPT。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P10478", "type": "P", "difficulty": 5, "samples": [["5 2\n2 1 -2 3 -2", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "优先队列", "反悔贪心"], "title": "生日礼物", "background": "", "description": "ftiasch 18 岁生日的时候，lqp18_31 给她看了一个神奇的序列 $A _ 1$, $A _ 2$, ..., $A _ N$。 她被允许选择不超过 $M$ 个连续的部分作为自己的生日礼物。\n\n自然地，ftiasch 想要知道选择元素之和的最大值。你能帮助她吗?", "inputFormat": "第 1 行，两个整数 $N$ ($1 \\le  N \\le 10 ^ {5}$ ) 和 $M$ ($0 \\le M \\le 10 ^ 5$)，表示序列的长度和可以选择的部分。 \n\n第 2 行， $N$ 个整数 $A_1$, $A_2$, ..., $A_N$ ($0 \\le \\mid A_i\\mid \\le 10^4$)，表示序列。\n", "outputFormat": "一个整数，表示最大的和。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "生日礼物", "background": "", "description": "ftiasch 18 岁生日的时候，lqp18_31 给她看了一个神奇的序列 $A _ 1$, $A _ 2$, ..., $A _ N$。 她被允许选择不超过 $M$ 个连续的部分作为自己的生日礼物。\n\n自然地，ftiasch 想要知道选择元素之和的最大值。你能帮助她吗?", "inputFormat": "第 1 行，两个整数 $N$ ($1 \\le  N \\le 10 ^ {5}$ ) 和 $M$ ($0 \\le M \\le 10 ^ 5$)，表示序列的长度和可以选择的部分。 \n\n第 2 行， $N$ 个整数 $A_1$, $A_2$, ..., $A_N$ ($0 \\le \\mid A_i\\mid \\le 10^4$)，表示序列。\n", "outputFormat": "一个整数，表示最大的和。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10479", "type": "P", "difficulty": 3, "samples": [["6 2 5\naabcde\nab\n0\n1\n2\n3\n4", "4\n1\n1\n0\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "哈希 hashing"], "title": "匹配统计", "background": "", "description": "阿轩在纸上写了两个字符串，分别记为 $A$ 和 $B$。利用在数据结构与算法课上学到的知识，他很容易地求出了\"字符串 $A$ 从任意位置开始的后缀子串“与“字符串 $B$”匹配的长度。\n\n不过阿轩是一个勤学好问的同学，他向你提出了 $Q$ 个问题：在每个问题中，他给定你一个整数 $X$，请你告诉他有多少个位置，满足“字符串 $A$ 从该位置开始的后缀子串\"与 $B$ 匹配的长度恰好为 $X$。\n\n例如：A=aabcde，B=ab，则 $A$ 有 aabcde、abcde、bcde、cde、de、e 这 $6$ 个后缀子串，它们与 $B=ab$ 的匹配长度分别是 $1,2,0,0,0,0$。因此 $A$ 有 $4$ 个位置与 $B$ 的匹配长度恰好为 $0$，有 $1$ 个位置的匹配长度恰好为 $1$，有 $1$ 个位置的匹配长度恰好为 $2$。", "inputFormat": "第一行三个整数 $N,M,Q$，表示 $A$ 串长度、$B$ 串长度、问题个数。\n\n第二行是字符串 $A$，第三行是字符串 $B$。\n\n接下来 $Q$ 行每行 $1$ 个整数 $x$，表示一个问题。\n\n", "outputFormat": "共 $Q$ 行，依次表示每个问题的答案。", "hint": "数据保证，$1\\leq N,M,Q,X\\leq 200000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "匹配统计", "background": "", "description": "阿轩在纸上写了两个字符串，分别记为 $A$ 和 $B$。利用在数据结构与算法课上学到的知识，他很容易地求出了\"字符串 $A$ 从任意位置开始的后缀子串“与“字符串 $B$”匹配的长度。\n\n不过阿轩是一个勤学好问的同学，他向你提出了 $Q$ 个问题：在每个问题中，他给定你一个整数 $X$，请你告诉他有多少个位置，满足“字符串 $A$ 从该位置开始的后缀子串\"与 $B$ 匹配的长度恰好为 $X$。\n\n例如：A=aabcde，B=ab，则 $A$ 有 aabcde、abcde、bcde、cde、de、e 这 $6$ 个后缀子串，它们与 $B=ab$ 的匹配长度分别是 $1,2,0,0,0,0$。因此 $A$ 有 $4$ 个位置与 $B$ 的匹配长度恰好为 $0$，有 $1$ 个位置的匹配长度恰好为 $1$，有 $1$ 个位置的匹配长度恰好为 $2$。", "inputFormat": "第一行三个整数 $N,M,Q$，表示 $A$ 串长度、$B$ 串长度、问题个数。\n\n第二行是字符串 $A$，第三行是字符串 $B$。\n\n接下来 $Q$ 行每行 $1$ 个整数 $x$，表示一个问题。\n\n", "outputFormat": "共 $Q$ 行，依次表示每个问题的答案。", "hint": "数据保证，$1\\leq N,M,Q,X\\leq 200000$。", "locale": "zh-CN"}}}
{"pid": "P10480", "type": "P", "difficulty": 3, "samples": [["10 10\n3 8\n2 3\n2 5\n5 9\n5 9\n2 3\n3 9\n4 8\n2 10\n4 9", "1\n6\n3\n3\n2\n1\n1\n1\n1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["拓扑排序", "位运算", "bitset"], "title": "可达性统计", "background": "", "description": "给定一张 $N$ 个点 $M$ 条边的有向无环图，分别统计从每个点出发能够到达的点的数量。", "inputFormat": "第一行两个整数 $N,M$，接下来 $M$ 行每行两个整数 $x,y$，表示从 $x$ 到 $y$ 的一条有向边。", "outputFormat": "输出共 $N$ 行，表示每个点能够到达的点的数量。", "hint": "测试数据满足 $1 \\le N,M \\le 30000$，$1 \\le x,y \\le N$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "可达性统计", "background": "", "description": "给定一张 $N$ 个点 $M$ 条边的有向无环图，分别统计从每个点出发能够到达的点的数量。", "inputFormat": "第一行两个整数 $N,M$，接下来 $M$ 行每行两个整数 $x,y$，表示从 $x$ 到 $y$ 的一条有向边。", "outputFormat": "输出共 $N$ 行，表示每个点能够到达的点的数量。", "hint": "测试数据满足 $1 \\le N,M \\le 30000$，$1 \\le x,y \\le N$。", "locale": "zh-CN"}}}
{"pid": "P10481", "type": "P", "difficulty": 4, "samples": [["1\n103000509\n002109400\n000704000\n300502006\n060000050\n700803004\n000401000\n009205800\n804000107\n", "143628579\n572139468\n986754231\n391542786\n468917352\n725863914\n237481695\n619275843\n854396127\n"]], "limits": {"time": [2000], "memory": [524288]}, "tags": ["2005", "Special Judge", "深度优先搜索 DFS", "Dancing Links", "ICPC", "SEERC"], "title": "[SEERC 2005] Sudoku", "background": null, "description": "Sudoku is a very simple task. A square table with 9 rows and 9 columns is divided to 9 smaller squares 3x3 as shown on the Figure. in some of the cells arewriten decimal digits ftom 1 to 9. The other cels are empty. The goal is to fill the empty cels with decimal digis from 1 to 9, one digit per cell, in such waythat in each rowy, in each column and in each marked 3x3 subsquare, allthe digits from 1 to 9 to appear. Write a program to solve a given Sudoku-task.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3zh25t4g.png)", "inputFormat": "The input data will start with the number ofthe test cases. For each test case,9 lines follow, corresponding to the rows ofthe table. On each line a string ofexactly 9 decimal digits is given, corresponding to the cells in this line. If a cell is empty it is represented by 0.", "outputFormat": "For each test case your program should print the solution in the same format as the input data. The empty cells have to be filled according to the rules. lf solutions is not unique, then the program may print any one of them.", "hint": null, "locale": "en", "translations": {"en": {"title": "[SEERC 2005] Sudoku", "background": null, "description": "Sudoku is a very simple task. A square table with 9 rows and 9 columns is divided to 9 smaller squares 3x3 as shown on the Figure. in some of the cells arewriten decimal digits ftom 1 to 9. The other cels are empty. The goal is to fill the empty cels with decimal digis from 1 to 9, one digit per cell, in such waythat in each rowy, in each column and in each marked 3x3 subsquare, allthe digits from 1 to 9 to appear. Write a program to solve a given Sudoku-task.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3zh25t4g.png)", "inputFormat": "The input data will start with the number ofthe test cases. For each test case,9 lines follow, corresponding to the rows ofthe table. On each line a string ofexactly 9 decimal digits is given, corresponding to the cells in this line. If a cell is empty it is represented by 0.", "outputFormat": "For each test case your program should print the solution in the same format as the input data. The empty cells have to be filled according to the rules. lf solutions is not unique, then the program may print any one of them.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[SEERC 2005] Sudoku", "background": null, "description": "数独是一个非常简单的任务。一个包含 9 行和 9 列的正方形表格被分成了 9 个小的 3x3 方块，如图所示。一些单元格中写有从 1 到 9 的十进制数字。其他单元格为空。目标是以从 1 到 9 的十进制数字填充空单元格，每个单元格一个数字，使得每行、每列和每个标记的 3x3 子方块中都出现从 1 到 9 的所有数字。编写一个程序来解决给定的数独任务。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3zh25t4g.png)", "inputFormat": "输入数据将以测试用例的数量开始。对于每个测试用例，将跟随 9 行，对应于表格的行。在每一行上，给出一个正好包含 9 个十进制数字的字符串，对应于该行中的单元格。如果一个单元格为空，则用 0 表示。", "outputFormat": "对于每个测试用例，你的程序应该以与输入数据相同的格式打印解决方案。空单元格必须按照规则填充。如果解不唯一，则程序可以打印其中任何一个。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": null, "locale": "zh-CN"}}}
{"pid": "P10482", "type": "P", "difficulty": 5, "samples": [[".2738..1..1...6735.......293.5692.8...........6.1745.364.......9518...7..8..6534.\n......52..8.4......3...9...5.1...6..2..7........3.....6...1..........7.4.......3.\nend", "527389416819426735436751829375692184194538267268174593643217958951843672782965341\n416837529982465371735129468571298643293746185864351297647913852359682714128574936"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["剪枝", "Dancing Links"], "title": "Sudoku 2", "background": "", "description": "In the game of Sudoku, you are given a large 9 × 9 grid divided into smaller 3 × 3 subgrids. For example,\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/acjiq3ud.png)\n\nGiven some of the numbers in the grid, your goal is to determine the remaining numbers such that the numbers 1 through 9 appear exactly once in (1) each of nine 3 × 3 subgrids, (2) each of the nine rows, and (3) each of the nine columns.", "inputFormat": "The input test file will contain multiple cases. Each test case consists of a single line containing 81 characters, which represent the 81 squares of the Sudoku grid, given one row at a time. Each character is either a digit (from 1 to 9) or a period (used to indicate an unfilled square). You may assume that each puzzle in the input will have exactly one solution. The end-of-file is denoted by a single line containing the word “end”.", "outputFormat": "For each test case, print a line representing the completed Sudoku puzzle.", "hint": "", "locale": "en", "translations": {"en": {"title": "Sudoku 2", "background": "", "description": "In the game of Sudoku, you are given a large 9 × 9 grid divided into smaller 3 × 3 subgrids. For example,\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/acjiq3ud.png)\n\nGiven some of the numbers in the grid, your goal is to determine the remaining numbers such that the numbers 1 through 9 appear exactly once in (1) each of nine 3 × 3 subgrids, (2) each of the nine rows, and (3) each of the nine columns.", "inputFormat": "The input test file will contain multiple cases. Each test case consists of a single line containing 81 characters, which represent the 81 squares of the Sudoku grid, given one row at a time. Each character is either a digit (from 1 to 9) or a period (used to indicate an unfilled square). You may assume that each puzzle in the input will have exactly one solution. The end-of-file is denoted by a single line containing the word “end”.", "outputFormat": "For each test case, print a line representing the completed Sudoku puzzle.", "hint": "", "locale": "en"}, "zh-CN": {"title": "Sudoku 2", "background": "", "description": "在数独游戏中，给定一个大的 9 × 9 网格，分成了较小的 3 × 3 子网格。例如，\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/acjiq3ud.png)\n\n在给定网格中的一些数字后，你的目标是确定剩余的数字，使得数字 1 到 9 恰好出现在以下位置：(1) 九个 3 × 3 子网格中的每一个，(2) 九行中的每一个，以及 (3) 九列中的每一个。", "inputFormat": "输入测试文件将包含多个案例。每个测试案例由一行组成，其中包含 81 个字符，这些字符代表数独网格的 81 个方格，逐行给出。每个字符可以是一个数字（从 1 到 9）或一个句点（用于表示未填充的方格）。你可以假设输入中的每个谜题都有唯一解。文件的结尾由一行包含单词“end”表示。", "outputFormat": "对于每个测试案例，打印一行表示完成的数独谜题。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10483", "type": "P", "difficulty": 2, "samples": [["5 1996\n1\n2\n1994\n12\n29", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["深度优先搜索 DFS"], "title": "小猫爬山", "background": "", "description": "Freda 和 rainbow 饲养了 $N(N\\le 18)$ 只小猫，这天，小猫们要去爬山。经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了\n\nFreda 和 rainbow 只好花钱让它们坐索道下山。索道上的缆车最大承重量为 $W$，而 $N$ 只小猫的重量分别是 $C_1,C_2,\\dots C_N$。当然，每辆缆车上的小猫的重量之和不能超过 $W(1\\le C_i,W \\le 10^8)$。每租用一辆缆车，Freda 和 rainbow 就要付 $1$ 美元，所以他们想知道，最少需要付多少美元才能把这 $N$ 只小猫都运送下山？", "inputFormat": "第一行包含两个用空格隔开的整数，$N$ 和 $W$。\n接下来 $N$ 行每行一个整数，其中第 $i+1$ 行的整数表示第 $i$ 只小猫的重量 $C_i$。", "outputFormat": "输出一个整数，最少需要多少美元，也就是最少需要多少辆缆车。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "小猫爬山", "background": "", "description": "Freda 和 rainbow 饲养了 $N(N\\le 18)$ 只小猫，这天，小猫们要去爬山。经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了\n\nFreda 和 rainbow 只好花钱让它们坐索道下山。索道上的缆车最大承重量为 $W$，而 $N$ 只小猫的重量分别是 $C_1,C_2,\\dots C_N$。当然，每辆缆车上的小猫的重量之和不能超过 $W(1\\le C_i,W \\le 10^8)$。每租用一辆缆车，Freda 和 rainbow 就要付 $1$ 美元，所以他们想知道，最少需要付多少美元才能把这 $N$ 只小猫都运送下山？", "inputFormat": "第一行包含两个用空格隔开的整数，$N$ 和 $W$。\n接下来 $N$ 行每行一个整数，其中第 $i+1$ 行的整数表示第 $i$ 只小猫的重量 $C_i$。", "outputFormat": "输出一个整数，最少需要多少美元，也就是最少需要多少辆缆车。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10484", "type": "P", "difficulty": 4, "samples": [["20 5\n7\n5\n4\n18\n1", "19"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["折半搜索 meet in the middle"], "title": "送礼物", "background": "", "description": "作为惩罚，GY 被遣送去帮助某神牛给女生送礼物 (GY：貌似是个好差事）但是在 GY 看到礼物之后，他就不这么认为了。某神牛有 $N$ 个礼物，且异常沉重，但是 GY 的力气也异常的大 (-_-b)，他一次可以搬动重量和在 $w$ 以下的任意多个物品。GY 希望一次搬掉尽量重的一些物品，请你告诉他在他的力气范围内一次性能搬动的最大重量是多少。", "inputFormat": "第一行两个整数，分别代表 $W$ 和 $N$。\n\n以后 $N$ 行，每行一个正整数表示 $G_i$。", "outputFormat": "仅一个整数，表示 GY 在他的力气范围内一次性能搬动的最大重量。", "hint": "对于所有测试数据，$1 \\le N \\le 46$, $1 \\le W,G[i] \\le 2^{31}-1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "送礼物", "background": "", "description": "作为惩罚，GY 被遣送去帮助某神牛给女生送礼物 (GY：貌似是个好差事）但是在 GY 看到礼物之后，他就不这么认为了。某神牛有 $N$ 个礼物，且异常沉重，但是 GY 的力气也异常的大 (-_-b)，他一次可以搬动重量和在 $w$ 以下的任意多个物品。GY 希望一次搬掉尽量重的一些物品，请你告诉他在他的力气范围内一次性能搬动的最大重量是多少。", "inputFormat": "第一行两个整数，分别代表 $W$ 和 $N$。\n\n以后 $N$ 行，每行一个正整数表示 $G_i$。", "outputFormat": "仅一个整数，表示 GY 在他的力气范围内一次性能搬动的最大重量。", "hint": "对于所有测试数据，$1 \\le N \\le 46$, $1 \\le W,G[i] \\le 2^{31}-1$。", "locale": "zh-CN"}}}
{"pid": "P10485", "type": "P", "difficulty": 4, "samples": [["7 7\n#######\n#..X###\n#..##O#\n#....E#\n#....E#\n#.....#\n#######\n0 0", "10"]], "limits": {"time": [1000, 1000], "memory": [524288, 524288]}, "tags": ["广度优先搜索 BFS"], "title": "Bloxorz I", "background": "", "description": "Little Tom loves playing games. One day he downloads a little computer game called 'Bloxorz' which makes him excited. It's a game about rolling a box to a specific position on a special plane. Precisely, the plane, which is composed of several unit cells, is a rectangle shaped area. And the box, consisting of two perfectly aligned unit cube, may either lies down and occupies two neighbouring cells or stands up and occupies one single cell. One may move the box by picking one of the four edges of the box on the ground and rolling the box 90 degrees around that edge, which is counted as one move. There are three kinds of cells, rigid cells, easily broken cells and empty cells. A rigid cell can support full weight of the box, so it can be either one of the two cells that the box lies on or the cell that the box fully stands on. A easily broken cells can only support half the weight of the box, so it cannot be the only cell that the box stands on. An empty cell cannot support anything, so there cannot be any part of the box on that cell. The target of the game is to roll the box standing onto the only target cell on the plane with minimum moves.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0byqnwkj.png)\n\nThe box stands on a single cell\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q3gn2fd8.png)\n\nThe box lies on two neighbouring cells, horizontally\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9vtkwepc.png)\n\nThe box lies on two neighbouring cells, vertically\n\nAfter Little Tom passes several stages of the game, he finds it much harder than he expected. So he turns to your help.", "inputFormat": "Input contains multiple test cases. Each test case is one single stage of the game. It starts with two integers R and C(3 ≤ R, C ≤ 500) which stands for number of rows and columns of the plane. That follows the plane, which contains R lines and C characters for each line, with 'O' (Oh) for target cell, 'X' for initial position of the box, '.' for a rigid cell, '#' for a empty cell and 'E' for a easily broken cell. A test cases starts with two zeros ends the input.\n\nIt guarantees that\n\n- There's only one 'O' in a plane.\n- There's either one 'X' or neighbouring two 'X's in a plane.\n- The first(and last) row(and column) must be '#'(empty cell).\n- Cells covered by 'O' and 'X' are all rigid cells.", "outputFormat": "For each test cases output one line with the minimum number of moves or \"Impossible\" (without quote) when there's no way to achieve the target cell. 　", "hint": "", "locale": "en", "translations": {"en": {"title": "Bloxorz I", "background": "", "description": "Little Tom loves playing games. One day he downloads a little computer game called 'Bloxorz' which makes him excited. It's a game about rolling a box to a specific position on a special plane. Precisely, the plane, which is composed of several unit cells, is a rectangle shaped area. And the box, consisting of two perfectly aligned unit cube, may either lies down and occupies two neighbouring cells or stands up and occupies one single cell. One may move the box by picking one of the four edges of the box on the ground and rolling the box 90 degrees around that edge, which is counted as one move. There are three kinds of cells, rigid cells, easily broken cells and empty cells. A rigid cell can support full weight of the box, so it can be either one of the two cells that the box lies on or the cell that the box fully stands on. A easily broken cells can only support half the weight of the box, so it cannot be the only cell that the box stands on. An empty cell cannot support anything, so there cannot be any part of the box on that cell. The target of the game is to roll the box standing onto the only target cell on the plane with minimum moves.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0byqnwkj.png)\n\nThe box stands on a single cell\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q3gn2fd8.png)\n\nThe box lies on two neighbouring cells, horizontally\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9vtkwepc.png)\n\nThe box lies on two neighbouring cells, vertically\n\nAfter Little Tom passes several stages of the game, he finds it much harder than he expected. So he turns to your help.", "inputFormat": "Input contains multiple test cases. Each test case is one single stage of the game. It starts with two integers R and C(3 ≤ R, C ≤ 500) which stands for number of rows and columns of the plane. That follows the plane, which contains R lines and C characters for each line, with 'O' (Oh) for target cell, 'X' for initial position of the box, '.' for a rigid cell, '#' for a empty cell and 'E' for a easily broken cell. A test cases starts with two zeros ends the input.\n\nIt guarantees that\n\n- There's only one 'O' in a plane.\n- There's either one 'X' or neighbouring two 'X's in a plane.\n- The first(and last) row(and column) must be '#'(empty cell).\n- Cells covered by 'O' and 'X' are all rigid cells.", "outputFormat": "For each test cases output one line with the minimum number of moves or \"Impossible\" (without quote) when there's no way to achieve the target cell. 　", "hint": "", "locale": "en"}, "zh-CN": {"title": "Bloxorz I", "background": "小汤姆喜欢玩游戏。有一天，他下载了一个叫做“Bloxorz”的小电脑游戏，让他非常兴奋。", "description": "这是一个关于将一个方块滚动到特定位置的游戏。准确地说，这个平面由几个单位单元格组成，是一个矩形形状的区域。而方块由两个完美对齐的单位立方体组成，可以躺下并占据两个相邻的单元格，也可以站立并占据一个单独的单元格。\n\n你可以通过选择方块在地面上的四条边之一，并围绕该边旋转 90 度来移动方块，每次旋转算作一步。有三种类型的单元格，刚性单元格、易碎单元格和空单元格。\n\n- 刚性单元格可以支撑方块的全部重量，因此可以是方块所占据的两个单元格中的任意一个，也可以是方块完全站立在上面的单元格。\n- 易碎单元格只能支撑方块重量的一半，因此不能是方块完全站立在上面的唯一单元格。\n- 空单元格无法支撑任何东西，因此方块不可能部分位于该单元格上。\n\n游戏的目标是以最少的步数将站立的方块滚动到平面上唯一的目标单元格。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0byqnwkj.png)\n\n方块站在单个单元格上。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q3gn2fd8.png)\n\n方块横躺在两个相邻的单元格上。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9vtkwepc.png)\n\n方块纵躺在两个相邻的单元格上。\n\n在小汤姆通过游戏的几个阶段后，他发现比他预期的要难得多。因此，他求助于你的帮助。", "inputFormat": "**输入包含多个测试案例。**\n\n每个测试案例都是游戏的一个阶段。它以两个整数 $R$ 和 $C$ 开头，表示平面的行数和列数。\n\n接下来是平面，其中包含 $R$ 行和每行的 $C$ 个字符，其中 `O` 表示目标单元格，`X` 表示方块的初始位置，`.` 表示刚性单元格，`#` 表示空单元格，`E` 表示易碎单元格。一个测试案例以两个 `0` 结束输入。\n\n输入保证：\n\n- 平面上只有一个 `O`。\n- 平面上要么有一个 `X`，要么有相邻的两个 `X`。\n- 第一行（和最后一行）（以及第一列和最后一列）必须是 `#`（空单元格）。\n- `O` 和 `X` 覆盖的单元格都是刚性单元格。", "outputFormat": "对于每个测试案例，输出一行表示移动的最小次数，或在无法达到目标单元格时输出 `Impossible`。", "hint": "### 数据范围\n\n对于所有的数据：$3 ≤ R，C ≤ 500$。\n\n### 翻译\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "locale": "zh-CN"}}}
{"pid": "P10486", "type": "P", "difficulty": 3, "samples": [["1\nbasic_info\n4 3\nname sid grade\nFusu 001 1\nMaxmilite 002 2\nExpect2004 003 2\n2\nselect name from basic_info where grade=1\nselect sid,name from basic_info where grade=2\n", "Fusu\n002 Maxmilite\n003 Expect2004\n"], ["2\nbasic_info\n4 3\nname sid grade\nFusu 001 1\nMaxmilite 002 2\nExpect2004 003 2\nGPA\n2 2\nsid GPA\n001 77.88\n1\nselect GPA from GPA where sid=001\n", "77.88\n"], ["2\nshow_corner\n3 2\nh1 h2\n1 2\n1 2\nshow_corner2\n3 1\nh0\n1\n1\n2\nselect h1,h2 from show_corner where h1=1\nselect h0 from show_corner2 where h0=1\n", "1 2\n1 2\n1\n1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2024", "语言月赛"], "title": "[入门赛 #25] sql", "background": "sql 是一种强大的数据库查询语言。在本题中，你需要实现一个部分功能的 sql 解析器。", "description": "一个数据库可以看作若干张二维表的合集。\n\n例如，一个学生信息管理系统的数据库可能会有如下两张二维表：\n\n`basic_info`：\n\n| name | sid | grade| \n| :-: | :-: | :-: |\n| Fusu | 001 | 1 |\n| Maxmilite| 002 | 2|\n| Expect2004 | 003 | 2 |\n\n`GPA`:\n\n| sid | GPA |\n| :-: | :-: |\n| 001 | 77.88|\n| 002| 99.9 |\n| 003| 99.7 |\n\n上述表的第一行称作**表头**，接下来每一行表示表的一组信息。例如，`basic_info` 的第二行表示存在一名学生的姓名（`name`）是 $\\texttt{Fusu}$，学号 (`sid`) 为 $\\texttt{001}$，年级（`grade`）为 $\\texttt{1}$\n\n一个正式的 sql 语言应该支持跨表查询，但是在本题中，你只需要支持在单个表内的查询。我们认为表内的一切属性都以字符串的形式给出。\n\n你需要支持如下格式的查询语句：\n\n```sql\nselect [columns] from [table_name] where [header]=x\n```\n\n上式中，`columns` 是若干个**表头**，`table_name` 是**表名**，`header` 是**表头**，$x$ 是给出的条件。它表示在 `table_name` 这个表里查询 `header` 这一列为 $x$ 的所有行的所有 `columns` 列里的信息。\n\n例如，如果对上述例子里的表执行如下语句：\n\n```sql\nselect name from basic_info where grade=1\n```\n表示在 `basic_info` 表里查询 `grade` 列为 $1$ 的所有行，并输出它们的 `name` 列，因此结果为：\n\n```plain\nFusu\n```\n\n如果执行\n\n```sql\nselect name,sid,grade from basic_info where grade=2\n```\n\n那么就找到 `basic_info` 表里所有 `grade` 为 `2` 的行，并依次输出它们的 `name`、`sid`、`grade`。结果为：\n\n```plain\nMaxmilite 002 2\nExpect2004 003 2\n```\n\n可以看到，`select` 语句的第一组参数 `columns` 可以是多个表头名称，此时应该按照 `columns` 给出的顺序输出每个对应的列信息。通过 `where` 后面的条件可以查询到多行满足要求的行时，应按照表的输入顺序（即从上到下）输出每行要求的信息。\n\n你需要实现这个 sql 语句解析器，给出 sql 查询结果。注意，我们保证了在查询语句里表名只有一个，且 `where` 后面的条件有且仅有一个等式。", "inputFormat": "输入的第一行是一个整数 $n$，表示数据库中表的个数。\n\n接下来依次给出每张表的信息：  \n第一行是一个字符串 `table_name`，表示表的名称。  \n第二行有两个整数 $x,y$，表示这张表的大小为 $x$ 行 $y$ 列。\n第三行有 $y$ 个字符串，表示这张表的表头。\n接下来 $x - 1$ 行，每行 $y$ 个字符串，给出这张表上每一行的信息。\n\n接下来是一个整数 $m$，表示 sql 语句的数量。\n\n接下来 $m$ 行，每行一个 sql 语句，格式一定是\n\n```sql\nselect [columns] from [table_name] where [header]=x\n```\n\n保证 `columns`、`table_name`、`header`、`x` 这四个参数内部没有空格。\n\n数据保证查询语句合法，即 `columns`、`table_name`、`header` 这三个参数所提供的表头、表名都是存在的，且给出的查询条件一定能找到至少一行符合，即查询结果非空。\n\n保证 `columns` 里没有重复的表头名。", "outputFormat": "对于每个查询，输出若干行，依次表示查询结果。\n\n一行查询结果里，如果有若干个列的信息要输出，输出字符串之间用一个空格隔开。", "hint": "### 样例 3 解释\n\n输入的表单可能有若干行是重复的，你无需对这些行做特殊处理，可以认为它们是不同的。每次查询需要输出所有符合要求的行。例如，在第一条 sql 中，`1 2` 这一行出现了两次且符合要求，因此输出了两次 `1 2`。\n\n### 数据规模与约定\n\n| 测试点编号 | 表的数量为 $1$ | 表头数量为 1 |  columns 里仅有一列表头 | \n| :-: | :-: | :-: | :-:|\n| 1, 2 | $\\checkmark$ | $\\checkmark$ | $\\checkmark$ |\n| 3, 4 | $\\checkmark$ | $\\times$ | $\\checkmark$ |\n| 5, 6 | $\\times$ | $\\checkmark$ |$\\checkmark$ |\n| 7, 8 | $\\times$ | $\\times$ | $\\checkmark$ |\n|9, 10 | $\\times$ | $\\times$ | $\\times$ |\n\n对全部的测试数据，保证：\n\n- $1 \\leq n \\leq 10$。\n- $1 \\leq x\\leq 100$，$1 \\leq y \\leq 10$。\n- $1 \\leq m \\leq 1000$。\n- 表头 `table_name` 长度不超过 $100$。\n- 表的内容和表头的字符串长度不超过 $10$，`columns` 的长度不超过 $100$。\n- 除了 `columns` 信息以外，输入的字符串均不含有逗号 `,`。\n- 输入字符串均为可见字符，ASCII 范围为 $33\\sim 126$（含两端），且不含符号 `=`。\n\n### 提示\n\n请注意大量数据输出对程序效率造成的影响，选择合适的输出方式，避免超时。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[入门赛 #25] sql", "background": "sql 是一种强大的数据库查询语言。在本题中，你需要实现一个部分功能的 sql 解析器。", "description": "一个数据库可以看作若干张二维表的合集。\n\n例如，一个学生信息管理系统的数据库可能会有如下两张二维表：\n\n`basic_info`：\n\n| name | sid | grade| \n| :-: | :-: | :-: |\n| Fusu | 001 | 1 |\n| Maxmilite| 002 | 2|\n| Expect2004 | 003 | 2 |\n\n`GPA`:\n\n| sid | GPA |\n| :-: | :-: |\n| 001 | 77.88|\n| 002| 99.9 |\n| 003| 99.7 |\n\n上述表的第一行称作**表头**，接下来每一行表示表的一组信息。例如，`basic_info` 的第二行表示存在一名学生的姓名（`name`）是 $\\texttt{Fusu}$，学号 (`sid`) 为 $\\texttt{001}$，年级（`grade`）为 $\\texttt{1}$\n\n一个正式的 sql 语言应该支持跨表查询，但是在本题中，你只需要支持在单个表内的查询。我们认为表内的一切属性都以字符串的形式给出。\n\n你需要支持如下格式的查询语句：\n\n```sql\nselect [columns] from [table_name] where [header]=x\n```\n\n上式中，`columns` 是若干个**表头**，`table_name` 是**表名**，`header` 是**表头**，$x$ 是给出的条件。它表示在 `table_name` 这个表里查询 `header` 这一列为 $x$ 的所有行的所有 `columns` 列里的信息。\n\n例如，如果对上述例子里的表执行如下语句：\n\n```sql\nselect name from basic_info where grade=1\n```\n表示在 `basic_info` 表里查询 `grade` 列为 $1$ 的所有行，并输出它们的 `name` 列，因此结果为：\n\n```plain\nFusu\n```\n\n如果执行\n\n```sql\nselect name,sid,grade from basic_info where grade=2\n```\n\n那么就找到 `basic_info` 表里所有 `grade` 为 `2` 的行，并依次输出它们的 `name`、`sid`、`grade`。结果为：\n\n```plain\nMaxmilite 002 2\nExpect2004 003 2\n```\n\n可以看到，`select` 语句的第一组参数 `columns` 可以是多个表头名称，此时应该按照 `columns` 给出的顺序输出每个对应的列信息。通过 `where` 后面的条件可以查询到多行满足要求的行时，应按照表的输入顺序（即从上到下）输出每行要求的信息。\n\n你需要实现这个 sql 语句解析器，给出 sql 查询结果。注意，我们保证了在查询语句里表名只有一个，且 `where` 后面的条件有且仅有一个等式。", "inputFormat": "输入的第一行是一个整数 $n$，表示数据库中表的个数。\n\n接下来依次给出每张表的信息：  \n第一行是一个字符串 `table_name`，表示表的名称。  \n第二行有两个整数 $x,y$，表示这张表的大小为 $x$ 行 $y$ 列。\n第三行有 $y$ 个字符串，表示这张表的表头。\n接下来 $x - 1$ 行，每行 $y$ 个字符串，给出这张表上每一行的信息。\n\n接下来是一个整数 $m$，表示 sql 语句的数量。\n\n接下来 $m$ 行，每行一个 sql 语句，格式一定是\n\n```sql\nselect [columns] from [table_name] where [header]=x\n```\n\n保证 `columns`、`table_name`、`header`、`x` 这四个参数内部没有空格。\n\n数据保证查询语句合法，即 `columns`、`table_name`、`header` 这三个参数所提供的表头、表名都是存在的，且给出的查询条件一定能找到至少一行符合，即查询结果非空。\n\n保证 `columns` 里没有重复的表头名。", "outputFormat": "对于每个查询，输出若干行，依次表示查询结果。\n\n一行查询结果里，如果有若干个列的信息要输出，输出字符串之间用一个空格隔开。", "hint": "### 样例 3 解释\n\n输入的表单可能有若干行是重复的，你无需对这些行做特殊处理，可以认为它们是不同的。每次查询需要输出所有符合要求的行。例如，在第一条 sql 中，`1 2` 这一行出现了两次且符合要求，因此输出了两次 `1 2`。\n\n### 数据规模与约定\n\n| 测试点编号 | 表的数量为 $1$ | 表头数量为 1 |  columns 里仅有一列表头 | \n| :-: | :-: | :-: | :-:|\n| 1, 2 | $\\checkmark$ | $\\checkmark$ | $\\checkmark$ |\n| 3, 4 | $\\checkmark$ | $\\times$ | $\\checkmark$ |\n| 5, 6 | $\\times$ | $\\checkmark$ |$\\checkmark$ |\n| 7, 8 | $\\times$ | $\\times$ | $\\checkmark$ |\n|9, 10 | $\\times$ | $\\times$ | $\\times$ |\n\n对全部的测试数据，保证：\n\n- $1 \\leq n \\leq 10$。\n- $1 \\leq x\\leq 100$，$1 \\leq y \\leq 10$。\n- $1 \\leq m \\leq 1000$。\n- 表头 `table_name` 长度不超过 $100$。\n- 表的内容和表头的字符串长度不超过 $10$，`columns` 的长度不超过 $100$。\n- 除了 `columns` 信息以外，输入的字符串均不含有逗号 `,`。\n- 输入字符串均为可见字符，ASCII 范围为 $33\\sim 126$（含两端），且不含符号 `=`。\n\n### 提示\n\n请注意大量数据输出对程序效率造成的影响，选择合适的输出方式，避免超时。", "locale": "zh-CN"}}}
{"pid": "P10487", "type": "P", "difficulty": 4, "samples": [["3\n5 6\nXXXXXX\nXZ..ZX\nXXXXXX\nM.G...\n......\n5 6\nXXXXXX\nXZZ..X\nXXXXXX\nM.....\n..G...\n10 10\n..........\n..X.......\n..M.X...X.\nX.........\n.X..X.X.X.\n.........X\n..XX....X.\nX....G...X\n...ZX.X...\n...Z..X..X", "1\n1\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["广度优先搜索 BFS"], "title": "Nightmare II", "background": "", "description": "Last night, little erriyue had a horrible nightmare. He dreamed that he and his girl friend were trapped in a big maze separately. More terribly, there are two ghosts in the maze. They will kill the people. Now little erriyue wants to know if he could find his girl friend before the ghosts find them.\n\nYou may suppose that little erriyue and his girl friend can move in 4 directions. In each second, little erriyue can move 3 steps and his girl friend can move 1 step. The ghosts are evil, every second they will divide into several parts to occupy the grids within 2 steps to them until they occupy the whole maze. You can suppose that at every second the ghosts divide firstly then the little erriyue and his girl friend start to move, and if little erriyue or his girl friend arrive at a grid with a ghost, they will die.\nNote: the new ghosts also can devide as the original ghost.", "inputFormat": "The input starts with an integer T, means the number of test cases.\n\nEach test case starts with a line contains two integers n and m, means the size of the maze. (1<n, m<800)\n\nThe next n lines describe the maze. Each line contains m characters. The characters may be:\n- ‘.’ denotes an empty place, all can walk on.\n- ‘X’ denotes a wall, only people can’t walk on.\n- ‘M’ denotes little erriyue\n- ‘G’ denotes the girl friend.\n- ‘Z’ denotes the ghosts.\n\nIt is guaranteed that will contain exactly one letter M, one letter G and two letters Z.", "outputFormat": "Output a single integer S in one line, denotes erriyue and his girlfriend will meet in the minimum time S if they can meet successfully, or output -1 denotes they failed to meet.", "hint": "", "locale": "en", "translations": {"en": {"title": "Nightmare II", "background": "", "description": "Last night, little erriyue had a horrible nightmare. He dreamed that he and his girl friend were trapped in a big maze separately. More terribly, there are two ghosts in the maze. They will kill the people. Now little erriyue wants to know if he could find his girl friend before the ghosts find them.\n\nYou may suppose that little erriyue and his girl friend can move in 4 directions. In each second, little erriyue can move 3 steps and his girl friend can move 1 step. The ghosts are evil, every second they will divide into several parts to occupy the grids within 2 steps to them until they occupy the whole maze. You can suppose that at every second the ghosts divide firstly then the little erriyue and his girl friend start to move, and if little erriyue or his girl friend arrive at a grid with a ghost, they will die.\nNote: the new ghosts also can devide as the original ghost.", "inputFormat": "The input starts with an integer T, means the number of test cases.\n\nEach test case starts with a line contains two integers n and m, means the size of the maze. (1<n, m<800)\n\nThe next n lines describe the maze. Each line contains m characters. The characters may be:\n- ‘.’ denotes an empty place, all can walk on.\n- ‘X’ denotes a wall, only people can’t walk on.\n- ‘M’ denotes little erriyue\n- ‘G’ denotes the girl friend.\n- ‘Z’ denotes the ghosts.\n\nIt is guaranteed that will contain exactly one letter M, one letter G and two letters Z.", "outputFormat": "Output a single integer S in one line, denotes erriyue and his girlfriend will meet in the minimum time S if they can meet successfully, or output -1 denotes they failed to meet.", "hint": "", "locale": "en"}, "zh-CN": {"title": "Nightmare II", "background": null, "description": "昨晚，小 erriyue 做了一个可怕的噩梦。他梦到自己和女朋友被困在一个大迷宫里。更可怕的是，迷宫里有两个鬼魂。它们会杀人。现在小 erriyue 想知道在鬼魂找到他们之前，他是否能找到他的女朋友。\n\n假设小 erriyue 和他的女朋友可以向四个方向移动。在每一秒中，小 erriyue 可以移动 $3$ 步，而他的女朋友只能移动 $1$ 步。鬼魂是邪恶的，每一秒它们都会分裂成几部分，占领距离它们两步以内的网格，直到它们占领整个迷宫。你可以假设在每一秒钟，鬼魂首先分裂，然后小 erriyue 和他的女朋友开始移动，如果小 erriyue 或者他的女朋友到达一个有鬼魂的网格，他们就会死亡。\n\n注意：新的鬼魂也可以像原来的鬼魂一样分裂。", "inputFormat": "输入以一个整数 $T(1 \\le T \\le 3)$ 开始，表示测试案例的数量。\n\n每个测试案例以一行开头，包含两个整数 $n$ 和 $m$，表示迷宫的大小。$(1 < n, m < 800)$\n\n接下来的 $n$ 行描述了迷宫。每行包含 $m$ 个字符。字符可能是：\n- `.` 表示空地，所有人都可以走。\n- `X` 表示墙，只有人类无法行走。\n- `M` 表示小 erriyue。\n- `G` 表示女朋友。\n- `Z` 表示鬼魂。\n\n保证迷宫中恰好有一个字母 `M`、一个字母 `G` 和两个字母 `Z`。", "outputFormat": "在一行中输出一个整数 $S$，表示如果他们能成功相遇，小 erriyue 和他的女朋友将在最短时间 $S$ 内相遇，或者输出 $-1$ 表示他们未能相遇。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": null, "locale": "zh-CN"}}}
{"pid": "P10488", "type": "P", "difficulty": 4, "samples": [["3\n6\n1 3 4 6 2 5\n5\n5 4 3 2 1\n10\n6 8 5 3 4 7 2 9 1 10", "2\n3\n5 or more"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "2006", "广度优先搜索 BFS", "启发式迭代加深搜索 IDA*", "ICPC"], "title": "[BAPC 2006 资格赛] Booksort", "background": null, "description": "给定 $n$ 本书，编号为 $1 \\sim n$。\n\n在初始状态下，书是任意排列的。\n\n在每一次操作中，可以抽取其中连续的一段，再把这段插入到其他某个位置。\n\n我们的目标状态是把书按照 $1 \\sim n$ 的顺序依次排列。\n\n求最少需要多少次操作。", "inputFormat": "第一行包含整数 $T$，表示共有 $T$ 组测试数据。\n\n每组数据包含两行，第一行为整数 $n$，表示书的数量。\n\n第二行为 $n$ 个整数，表示 $1 \\sim n$ 的一种任意排列。\n\n同行数之间用空格隔开。", "outputFormat": "每组数据输出一个最少操作次数。\n\n如果最少操作次数大于或等于 $5$ 次，则输出 `5 or more`。\n\n每个结果占一行。", "hint": "$1 \\le n \\le 15$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BAPC 2006 资格赛] Booksort", "background": null, "description": "给定 $n$ 本书，编号为 $1 \\sim n$。\n\n在初始状态下，书是任意排列的。\n\n在每一次操作中，可以抽取其中连续的一段，再把这段插入到其他某个位置。\n\n我们的目标状态是把书按照 $1 \\sim n$ 的顺序依次排列。\n\n求最少需要多少次操作。", "inputFormat": "第一行包含整数 $T$，表示共有 $T$ 组测试数据。\n\n每组数据包含两行，第一行为整数 $n$，表示书的数量。\n\n第二行为 $n$ 个整数，表示 $1 \\sim n$ 的一种任意排列。\n\n同行数之间用空格隔开。", "outputFormat": "每组数据输出一个最少操作次数。\n\n如果最少操作次数大于或等于 $5$ 次，则输出 `5 or more`。\n\n每个结果占一行。", "hint": "$1 \\le n \\le 15$。", "locale": "zh-CN"}}}
{"pid": "P10489", "type": "P", "difficulty": 4, "samples": [["17\n0 3 5 13 13 15 21 26 27 29 37 39 39 45 51 52 53", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["IOI", "O2优化", "深度优先搜索 DFS", "剪枝", "迭代加深搜索"], "title": "[IOI 1994] The Buses", "background": "0x29 搜索 总结与练习", "description": "A man arrives at a bus stop at 12:00. He remains there during 12:00-12:59. The bus stop is used by a number of bus routes. The man notes the times of arriving buses. The times when buses arrive are given.\n\n-  Buses on the same route arrive at regular intervals from 12:00 to 12:59 throughout the entire hour.\n- Times are given in whole minutes from 0 to 59.\n- Each bus route stops at least 2 times.\n- The number of bus routes in the test examples will be <=17.\n- Buses from different routes may arrive at the same time.\n- Several bus routes can have the same time of first arrival and/or time interval. If two bus routes have the same starting time and interval, they are distinct and are both to be presented.\n\nFind the schedule with the fewest number of bus routes that must stop at the bus stop to satisfy the input data. For each bus route, output the starting time and the interval.\n", "inputFormat": "Your program is to read from standard input. The input contains a number n (n <= 300) telling how many arriving buses have been noted, followed by the arrival times in ascending order.", "outputFormat": "Your program is to write to standard output. The output contains one integer, which is the fewest number of bus routes.", "hint": "", "locale": "en", "translations": {"en": {"title": "[IOI 1994] The Buses", "background": "0x29 搜索 总结与练习", "description": "A man arrives at a bus stop at 12:00. He remains there during 12:00-12:59. The bus stop is used by a number of bus routes. The man notes the times of arriving buses. The times when buses arrive are given.\n\n-  Buses on the same route arrive at regular intervals from 12:00 to 12:59 throughout the entire hour.\n- Times are given in whole minutes from 0 to 59.\n- Each bus route stops at least 2 times.\n- The number of bus routes in the test examples will be <=17.\n- Buses from different routes may arrive at the same time.\n- Several bus routes can have the same time of first arrival and/or time interval. If two bus routes have the same starting time and interval, they are distinct and are both to be presented.\n\nFind the schedule with the fewest number of bus routes that must stop at the bus stop to satisfy the input data. For each bus route, output the starting time and the interval.\n", "inputFormat": "Your program is to read from standard input. The input contains a number n (n <= 300) telling how many arriving buses have been noted, followed by the arrival times in ascending order.", "outputFormat": "Your program is to write to standard output. The output contains one integer, which is the fewest number of bus routes.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[IOI 1994] The Buses", "background": "", "description": "一个人在 12:00 到达一个公交车站。他在 12:00 到 12:59 期间一直待在那里。这个公交车站被多条公交线路使用。这个人记录了公交车到达的时间。给出了公交车到达的时间。\n\n- 同一条路线的公交车在整个小时内从 12:00 到 12:59 以固定的时间间隔到达。\n- 时间以整分钟给出，从 0 到 59。\n- 每条公交线路至少停靠 2 次。\n- 测试示例中的公交线路数量将 $\\leq 17$。\n- 不同路线的公交车可能同时到达。\n- 几条公交线路的首次到达时间和/或时间间隔可能相同。如果两条公交线路的起始时间和间隔相同，则它们是不同的，并且都需要呈现。\n\n找出满足输入数据的必须停靠在公交车站的公交线路数量最少的时间表。对于每条公交线路，输出起始时间和间隔。", "inputFormat": "你的程序需要从标准输入中读取。输入包含一个数字 $n$（$n \\leq 300$），表示已经记录的到达公交车的数量，后跟按升序排列的到达时间。", "outputFormat": "你的程序需要写入标准输出。输出包含一个整数，即最少的公交线路数量。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10490", "type": "P", "difficulty": 3, "samples": [["5 \n3 5 2 4 1 \n0", "2"]], "limits": {"time": [2000], "memory": [524288]}, "tags": ["搜索", "O2优化", "深度优先搜索 DFS", "剪枝"], "title": "Missile Defence System", "background": "", "description": "To play against the threats of malicious countries nearby, Country R has updated their missile defence system. The new type system can bring down a series of missiles as long as they are coming in ascending order by altitude or descending order by altitude.\n\nGiven the heights of a sequence of coming missiles, the general wants to know how many sets of the new type systems are needed to bring down all of them.", "inputFormat": "The input consists of several test cases. The first line of each test case contains an integer $n (1 \\le n \\le 50)$. The next line contains n different integers indicating the heights.", "outputFormat": "For each test case output a single line containing the number of systems needed.For each test case output a single line containing the number of systems needed.", "hint": "Two sets of systems are needed for the sample. One brings down 3, 4 and the other brings down 5, 2, 1.", "locale": "en", "translations": {"en": {"title": "Missile Defence System", "background": "", "description": "To play against the threats of malicious countries nearby, Country R has updated their missile defence system. The new type system can bring down a series of missiles as long as they are coming in ascending order by altitude or descending order by altitude.\n\nGiven the heights of a sequence of coming missiles, the general wants to know how many sets of the new type systems are needed to bring down all of them.", "inputFormat": "The input consists of several test cases. The first line of each test case contains an integer $n (1 \\le n \\le 50)$. The next line contains n different integers indicating the heights.", "outputFormat": "For each test case output a single line containing the number of systems needed.For each test case output a single line containing the number of systems needed.", "hint": "Two sets of systems are needed for the sample. One brings down 3, 4 and the other brings down 5, 2, 1.", "locale": "en"}, "zh-CN": {"title": "Missile Defence System", "background": "", "description": "为了对抗附近恶意国家的威胁，R 国更新了他们的导弹防御系统。\n\n一套防御系统的导弹拦截高度要么一直严格单调上升要么一直严格单调下降。\n\n例如，一套系统先后拦截了高度为 $3$ 和高度为 $4$ 的两发导弹，那么接下来该系统就只能拦截高度大于 $4$ 的导弹。\n\n给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，就可以将它们全部击落。", "inputFormat": "输入包含多组测试用例。\n\n对于每个测试用例，第一行包含整数 $n$，表示来袭导弹数量。\n\n第二行包含 $n$ 个不同的整数，表示每个导弹的高度。\n\n当输入测试用例 $n=0$ 时，表示输入终止，且该用例无需处理。", "outputFormat": "对于每个测试用例，输出一行，一个整数，表示所需的防御系统数量。", "hint": "#### 样例解释\n对于样例，需要两套系统。一套击落 $3,4$ 号导弹，另一套击落 $5,2,1$ 号导弹。\n\n#### 数据规模与约定\n$1 \\leq n \\leq 50$。", "locale": "zh-CN"}}}
{"pid": "P10491", "type": "P", "difficulty": 2, "samples": [["10 11\n..........\n....*.....\n..........\n...*.*....\n.......*..\n..*..*...H\n*.........\n...*...*..\n.K........\n...*.....*\n..*....*..", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2009", "USACO", "O2优化", "广度优先搜索 BFS"], "title": "[USACO09NOV] The Chivalrous Cow B", "background": "农民 John 有很多牛，他想交易其中一头被 Don 称为 The Knight 的牛。这头牛有一个独一无二的超能力，在农场里像 Knight 一样地跳（就是我们熟悉的象棋中马的走法）。虽然这头神奇的牛不能跳到树上和石头上，但是它可以在牧场上随意跳，我们把牧场用一个 $x,y$ 的坐标图来表示。", "description": "这头神奇的牛像其它牛一样喜欢吃草，给你一张地图，上面标注了 The Knight 的开始位置，树、灌木、石头以及其它障碍的位置，除此之外还有一捆草。现在你的任务是，确定 The Knight 要想吃到草，至少需要跳多少次。The Knight 的位置用 `K` 来标记，障碍的位置用 `*` 来标记，草的位置用 `H` 来标记。\n\n这里有一个地图的例子：\n```\n             11 | . . . . . . . . . .\n             10 | . . . . * . . . . . \n              9 | . . . . . . . . . . \n              8 | . . . * . * . . . . \n              7 | . . . . . . . * . . \n              6 | . . * . . * . . . H \n              5 | * . . . . . . . . . \n              4 | . . . * . . . * . . \n              3 | . K . . . . . . . . \n              2 | . . . * . . . . . * \n              1 | . . * . . . . * . . \n              0 ----------------------\n                                    1 \n                0 1 2 3 4 5 6 7 8 9 0 \n```\nThe Knight 可以按照下图中的 $A,B,C,D\\dots$ 这条路径用 $5$ 次跳到草的地方（有可能其它路线的长度也是 $5$）：\n```\n             11 | . . . . . . . . . .\n             10 | . . . . * . . . . .\n              9 | . . . . . . . . . .\n              8 | . . . * . * . . . .\n              7 | . . . . . . . * . .\n              6 | . . * . . * . . . F<\n              5 | * . B . . . . . . .\n              4 | . . . * C . . * E .\n              3 | .>A . . . . D . . .\n              2 | . . . * . . . . . *\n              1 | . . * . . . . * . .\n              0 ----------------------\n                                    1\n                0 1 2 3 4 5 6 7 8 9 0\n                ```", "inputFormat": "第一行：两个数，表示农场的列数（$\\le 150$）和行数 （$\\le 150$）。\n\n第二行：结尾：如题目描述的图。", "outputFormat": "一个数，表示跳跃的最小次数。", "hint": "Hint：这类问题可以用一个简单的先进先出表（队列）来解决。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO09NOV] The Chivalrous Cow B", "background": "农民 John 有很多牛，他想交易其中一头被 Don 称为 The Knight 的牛。这头牛有一个独一无二的超能力，在农场里像 Knight 一样地跳（就是我们熟悉的象棋中马的走法）。虽然这头神奇的牛不能跳到树上和石头上，但是它可以在牧场上随意跳，我们把牧场用一个 $x,y$ 的坐标图来表示。", "description": "这头神奇的牛像其它牛一样喜欢吃草，给你一张地图，上面标注了 The Knight 的开始位置，树、灌木、石头以及其它障碍的位置，除此之外还有一捆草。现在你的任务是，确定 The Knight 要想吃到草，至少需要跳多少次。The Knight 的位置用 `K` 来标记，障碍的位置用 `*` 来标记，草的位置用 `H` 来标记。\n\n这里有一个地图的例子：\n```\n             11 | . . . . . . . . . .\n             10 | . . . . * . . . . . \n              9 | . . . . . . . . . . \n              8 | . . . * . * . . . . \n              7 | . . . . . . . * . . \n              6 | . . * . . * . . . H \n              5 | * . . . . . . . . . \n              4 | . . . * . . . * . . \n              3 | . K . . . . . . . . \n              2 | . . . * . . . . . * \n              1 | . . * . . . . * . . \n              0 ----------------------\n                                    1 \n                0 1 2 3 4 5 6 7 8 9 0 \n```\nThe Knight 可以按照下图中的 $A,B,C,D\\dots$ 这条路径用 $5$ 次跳到草的地方（有可能其它路线的长度也是 $5$）：\n```\n             11 | . . . . . . . . . .\n             10 | . . . . * . . . . .\n              9 | . . . . . . . . . .\n              8 | . . . * . * . . . .\n              7 | . . . . . . . * . .\n              6 | . . * . . * . . . F<\n              5 | * . B . . . . . . .\n              4 | . . . * C . . * E .\n              3 | .>A . . . . D . . .\n              2 | . . . * . . . . . *\n              1 | . . * . . . . * . .\n              0 ----------------------\n                                    1\n                0 1 2 3 4 5 6 7 8 9 0\n                ```", "inputFormat": "第一行：两个数，表示农场的列数（$\\le 150$）和行数 （$\\le 150$）。\n\n第二行：结尾：如题目描述的图。", "outputFormat": "一个数，表示跳跃的最小次数。", "hint": "Hint：这类问题可以用一个简单的先进先出表（队列）来解决。", "locale": "zh-CN"}}}
{"pid": "P10492", "type": "P", "difficulty": 4, "samples": [["1 \n0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 \n7\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 1 0 0 0 0 1 1 0 0 1 \n0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 1 \n0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 \n0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 \n1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 \n0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 \n7 \n0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 \n0 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0 \n0 0 0 1 0 0 0 0 0 0 1 0 1 0 0 0 \n0 1 0 0 0 0 0 1 0 0 0 0 1 0 0 0 \n0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 \n0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 1 \n0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0\n15 \n0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 \n0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 \n0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 \n0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0  \n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0  \n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 \n0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 \n0 0 1 1 0 0 0 0 0 1 0 0 0 0 0 0 \n1 1 0 0 0 0 0 0 0 0 1 0 0 1 0 0 \n0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0  \n0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 \n1 0 0 1 1 0 0 0 0 1 0 1 0 0 0 0 \n0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 \n0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0  \n0", "0\n1\n0\n1"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["2003", "广度优先搜索 BFS", "深度优先搜索 DFS", "剪枝", "记忆化搜索", "ICPC"], "title": "[ICPC-Aizu 2003] Weather Forecast", "background": null, "description": "You are the God of Wind.\n\nBy moving a big cloud around, you can decide the weather: it invariably rains under the cloud, and the sun shines everywhere else.\n\nBut you are a benign God: your goal is to give enough rain to every field in the countryside, and sun to markets and festivals. Small humans, in their poor vocabulary, only describe this as \"weather forecast\".\n\nYou are in charge of a small country, called Paccimc. This country is constituted of 4 x 4 square areas, denoted by their numbers.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tuq65kcj.png)\n\nYour cloud is of size 2 x 2, and may not cross the borders of the country.\n\nYou are given the schedule of markets and festivals in each area for a period of time.\n\nOn the first day of the period, it is raining in the central areas (6-7-10-11), independently of the schedule.\n\nOn each of the following days, you may move your cloud by 1 or 2 squares in one of the four cardinal directions (North, West, South, and East), or leave it in the same position. Diagonal moves are not allowed. All moves occur at the beginning of the day.\n\nYou should not leave an area without rain for a full week (that is, you are allowed at most 6 consecutive days without rain). You don't have to care about rain on days outside the period you were given: i.e. you can assume it rains on the whole country the day before the period, and the day after it finishes.", "inputFormat": "The input is a sequence of data sets, followed by a terminating line containing only a zero.\n\nA data set gives the number N of days (no more than 365) in the period on a single line, followed by N lines giving the schedule for markets and festivals. The i-th line gives the schedule for the i-th day. It is composed of 16 numbers, either 0 or 1, 0 standing for a normal day, and 1 a market or festival day. The numbers are separated by one or more spaces.", "outputFormat": "The answer is a 0 or 1 on a single line for each data set, 1 if you can satisfy everybody, 0 if there is no way to do it.", "hint": null, "locale": "en", "translations": {"en": {"title": "[ICPC-Aizu 2003] Weather Forecast", "background": null, "description": "You are the God of Wind.\n\nBy moving a big cloud around, you can decide the weather: it invariably rains under the cloud, and the sun shines everywhere else.\n\nBut you are a benign God: your goal is to give enough rain to every field in the countryside, and sun to markets and festivals. Small humans, in their poor vocabulary, only describe this as \"weather forecast\".\n\nYou are in charge of a small country, called Paccimc. This country is constituted of 4 x 4 square areas, denoted by their numbers.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tuq65kcj.png)\n\nYour cloud is of size 2 x 2, and may not cross the borders of the country.\n\nYou are given the schedule of markets and festivals in each area for a period of time.\n\nOn the first day of the period, it is raining in the central areas (6-7-10-11), independently of the schedule.\n\nOn each of the following days, you may move your cloud by 1 or 2 squares in one of the four cardinal directions (North, West, South, and East), or leave it in the same position. Diagonal moves are not allowed. All moves occur at the beginning of the day.\n\nYou should not leave an area without rain for a full week (that is, you are allowed at most 6 consecutive days without rain). You don't have to care about rain on days outside the period you were given: i.e. you can assume it rains on the whole country the day before the period, and the day after it finishes.", "inputFormat": "The input is a sequence of data sets, followed by a terminating line containing only a zero.\n\nA data set gives the number N of days (no more than 365) in the period on a single line, followed by N lines giving the schedule for markets and festivals. The i-th line gives the schedule for the i-th day. It is composed of 16 numbers, either 0 or 1, 0 standing for a normal day, and 1 a market or festival day. The numbers are separated by one or more spaces.", "outputFormat": "The answer is a 0 or 1 on a single line for each data set, 1 if you can satisfy everybody, 0 if there is no way to do it.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[ICPC-Aizu 2003] Weather Forecast", "background": null, "description": "你是风之神。\n\n通过移动一朵大云，你可以决定天气：云下必定下雨，其他地方阳光普照。\n\n但你是一个仁慈的神：你的目标是给乡间的每个田地带来足够的雨水，给市场和节日带来阳光。小人类用他们贫乏的词汇，只能将这称为“天气预报”。\n\n你负责管理一个名为 Paccimc 的小国家。这个国家由 $4 \\times 4$ 的方块区域组成，用它们的编号表示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tuq65kcj.png)\n\n你的云的大小为 $2 \\times 2$，不得越过国家的边界。\n\n给出了一段时间内每个区域的市场和节日的安排。\n\n在该时段的第一天，无论安排如何，在中心区域（6-7-10-11）都会下雨。\n\n在接下来的每一天，你可以将你的云向四个基本方向之一（北、西、南和东）移动 $1$ 或 $2$ 个方格，也可以将其保持在原位。不允许对角线移动。所有移动均发生在一天开始时。\n\n你不应该让一个区域连续一周没有雨水（也就是说，你允许最多连续 $6$ 天没有雨）。你不必在你获得的时间段之外的日子里考虑雨水：也就是说，你可以假设在时间段之前的整个国家都下雨，在它结束后的一天也是如此。", "inputFormat": "输入一个数据集序列，后跟一个仅包含零的终止行。\n\n一个数据集在单独的一行上给出了期间中的天数 $N$（不超过 $365$），然后是 $N$ 行，给出了市场和节日的安排。第 $i$ 行给出了第 $i$ 天的安排。它由 $16$ 个数字组成，要么是 $0$ 要么是 $1$，$0$ 表示正常日，$1$ 表示市场或节日。数字之间用一个或多个空格分隔。", "outputFormat": "对每个数据集的单行输出，如果你能满足每个人，则输出 $1$，否则输出 $0$。\n\n**【样例解释】**\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": null, "locale": "zh-CN"}}}
{"pid": "P10493", "type": "P", "difficulty": 4, "samples": [["U 0 0\nH 0 0 \nV 1 0", "0\n4\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "广度优先搜索 BFS"], "title": "Bloxorz II", "background": "", "description": "由于大灾难的发生，科学院已经连续有很多年没有新生了(这个世界中的科学院其实也 有大学的职能)。于是这一年的新生测试就有里程碑一样的意义。作为科学院的顶级信息专 家，这一任务自然落到了你的头上。思来想去，你决定出这样的一个题，那就是 Bloxorz 游戏。\n\n所谓 Bloxorz 游戏，如下图所示，就是在一个平台上有一个作为目标的 1×1 的洞，以 及一个大小为 2×1×1 的长方体。长方体可以沿着边在平台上滚动，但是不能与平台失去接触面。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z5kdhsry.png)\n\n下面这张图反映了上图中的长方体向右滚动之后的局面。\n![](https://cdn.luogu.com.cn/upload/image_hosting/6kgp8841.png)\n\n而下面这张图就反映了向前方滚动之后的局面。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4rgnopmu.png)\n\n任务就是让长方体进入目标洞。当然，这时长方体应该是竖立的。\n\n滚动一次叫做一步。你的题目就是对于一个给定的局面，计算至少需要多少步才能把长 方体滚到目标洞里面去。自然，对于新生来说这个题是一个很难的题。\n\n  被你虐了的新生感到很不服气。于是他们想了一个更难的题来让你做:\n  \n有一个无限大的平台以及一个建立在上面的坐标系。现在目标洞在(0, 0)处，长方体的 位置和状态(竖立、与 x 轴平行还是与 y 轴平行)给定，计算至少需要多少步才能使长方体 进洞。\n\n  作为顶级信息专家......这当然难不倒你了。", "inputFormat": "输入文件包含多组测试数据。\n\n每组测试数据在一行内，格式为 C x y。其中 C 为一个字母，x 和 y 是两个整数。 这表示长方体覆盖住了平台上的格子(x, y)，且其状态为 C。\n\n若 C 为字母 U，表明长方体是竖立的。\n\n若 C 为字母 V，表明长方体与 x 轴平行，且其覆盖的另一个格子为(x + 1, y)。\n\n若 C 为字母 H，表明长方体与 y 轴平行，且其覆盖的另一个格子为(x, y + 1)。 输入文件以 EOF 结束。\n", "outputFormat": " 对于每组测试数据，在单独的一行内输出答案。", "hint": "对于 20% 的数据，$ \\mid x \\mid , \\mid y \\mid \\le 100$。\n对于 100% 的数据，$\\mid x\\mid , \\mid y\\mid \\le 10^9$，输入数据不超过 100 组。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Bloxorz II", "background": "", "description": "由于大灾难的发生，科学院已经连续有很多年没有新生了(这个世界中的科学院其实也 有大学的职能)。于是这一年的新生测试就有里程碑一样的意义。作为科学院的顶级信息专 家，这一任务自然落到了你的头上。思来想去，你决定出这样的一个题，那就是 Bloxorz 游戏。\n\n所谓 Bloxorz 游戏，如下图所示，就是在一个平台上有一个作为目标的 1×1 的洞，以 及一个大小为 2×1×1 的长方体。长方体可以沿着边在平台上滚动，但是不能与平台失去接触面。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z5kdhsry.png)\n\n下面这张图反映了上图中的长方体向右滚动之后的局面。\n![](https://cdn.luogu.com.cn/upload/image_hosting/6kgp8841.png)\n\n而下面这张图就反映了向前方滚动之后的局面。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4rgnopmu.png)\n\n任务就是让长方体进入目标洞。当然，这时长方体应该是竖立的。\n\n滚动一次叫做一步。你的题目就是对于一个给定的局面，计算至少需要多少步才能把长 方体滚到目标洞里面去。自然，对于新生来说这个题是一个很难的题。\n\n  被你虐了的新生感到很不服气。于是他们想了一个更难的题来让你做:\n  \n有一个无限大的平台以及一个建立在上面的坐标系。现在目标洞在(0, 0)处，长方体的 位置和状态(竖立、与 x 轴平行还是与 y 轴平行)给定，计算至少需要多少步才能使长方体 进洞。\n\n  作为顶级信息专家......这当然难不倒你了。", "inputFormat": "输入文件包含多组测试数据。\n\n每组测试数据在一行内，格式为 C x y。其中 C 为一个字母，x 和 y 是两个整数。 这表示长方体覆盖住了平台上的格子(x, y)，且其状态为 C。\n\n若 C 为字母 U，表明长方体是竖立的。\n\n若 C 为字母 V，表明长方体与 x 轴平行，且其覆盖的另一个格子为(x + 1, y)。\n\n若 C 为字母 H，表明长方体与 y 轴平行，且其覆盖的另一个格子为(x, y + 1)。 输入文件以 EOF 结束。\n", "outputFormat": " 对于每组测试数据，在单独的一行内输出答案。", "hint": "对于 20% 的数据，$ \\mid x \\mid , \\mid y \\mid \\le 100$。\n对于 100% 的数据，$\\mid x\\mid , \\mid y\\mid \\le 10^9$，输入数据不超过 100 组。", "locale": "zh-CN"}}}
{"pid": "P10494", "type": "P", "difficulty": 5, "samples": [["31", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2002", "USACO", "O2优化", "广度优先搜索 BFS", "剪枝", "迭代加深搜索", "启发式迭代加深搜索 IDA*"], "title": "[USACO02FEB] Power Hungry Cows", "background": "", "description": "FJ's cows would like to be able to compute integer powers P (1 <= P <= 20,000) of numbers very quickly, but need your help. Because they're going to be computing powers of very large numbers, they can only keep around two work variables for intermediate results.\n\nThe first of those work variables is initialized to the number (denoted x) for which they are calculating the power; the other is initialized to 1. The cows can both multiply and divide any pair of the work variables and store the result in any work variable, but all results are stored as integers.\n\nFor example, if they want to compute x^31, one way to perform the calculation is:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bfbznh12.png)\n\nThus, x^31 can computed in six operations. Given the power to be computed and the the number of work variables, find the minimum number of operations to calculate the power.", "inputFormat": "A single line with one integer: P.", "outputFormat": "A single line with a single integer that is the minimum number of operations it requires to compute the pow", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO02FEB] Power Hungry Cows", "background": "", "description": "FJ's cows would like to be able to compute integer powers P (1 <= P <= 20,000) of numbers very quickly, but need your help. Because they're going to be computing powers of very large numbers, they can only keep around two work variables for intermediate results.\n\nThe first of those work variables is initialized to the number (denoted x) for which they are calculating the power; the other is initialized to 1. The cows can both multiply and divide any pair of the work variables and store the result in any work variable, but all results are stored as integers.\n\nFor example, if they want to compute x^31, one way to perform the calculation is:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bfbznh12.png)\n\nThus, x^31 can computed in six operations. Given the power to be computed and the the number of work variables, find the minimum number of operations to calculate the power.", "inputFormat": "A single line with one integer: P.", "outputFormat": "A single line with a single integer that is the minimum number of operations it requires to compute the pow", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO02FEB] Power Hungry Cows", "background": "", "description": "FJ 的奶牛们希望能够快速计算整数幂 $P$（$1 \\leq P \\leq 20000$），但她们需要你的帮助。因为她们将要计算非常大的数的幂，所以她们只能保留两个工作变量来存储中间结果。\n\n这两个工作变量中的第一个被初始化为正在计算幂的数字（表示为 $x$）；另一个被初始化为 $1$。奶牛们可以对任意一对工作变量进行乘法和除法运算，并将结果存储在任意一个工作变量中，但所有结果都存储为整数。\n\n例如，如果她们想要计算 $x^{31}$，一种进行计算的方法是：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bfbznh12.png)\n\n因此，$x^{31}$ 可以在六次操作中计算出来。给定要计算的幂和工作变量的数量，找出计算该幂所需的最少操作数。", "inputFormat": "一行，一个整数：$P$。", "outputFormat": "一行，一个整数，表示计算幂所需的最小操作数。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10495", "type": "P", "difficulty": 2, "samples": [["5", "2 3\n3 1\n5 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["素数判断,质数,筛法"], "title": "阶乘分解", "background": "", "description": "给定整数 $N (3 \\le N \\le 10^6)$，试把阶乘 $N!$ 分解质因数，按照算术基本定理的形式输出分解结果中的 $p_i$ 和 $c_i$ 即可。\n", "inputFormat": "一个整数 $N$。\n", "outputFormat": "$N!$ 分解质因数后的结果，共若干行，每行一对 $p_i, c_i$，表示含有 $p_i^{c_i}$ 项。按照 $p_i$ 从小到大的顺序输出。\n", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "阶乘分解", "background": "", "description": "给定整数 $N (3 \\le N \\le 10^6)$，试把阶乘 $N!$ 分解质因数，按照算术基本定理的形式输出分解结果中的 $p_i$ 和 $c_i$ 即可。\n", "inputFormat": "一个整数 $N$。\n", "outputFormat": "$N!$ 分解质因数后的结果，共若干行，每行一对 $p_i, c_i$，表示含有 $p_i^{c_i}$ 项。按照 $p_i$ 从小到大的顺序输出。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10496", "type": "P", "difficulty": 5, "samples": [["8\n11\n16\n0", "Case 1: 1\nCase 2: 2\nCase 3: 0"]], "limits": {"time": [1000, 1000, 1000], "memory": [524288, 524288, 524288]}, "tags": ["2008", "数论", "最大公约数 gcd", "ICPC", "欧拉函数"], "title": "[ICPC-Hefei 2008 Online] The Luckiest Number", "background": null, "description": "Chinese people think of '8' as the lucky digit. Bob also likes digit '8'. Moreover, Bob has his own lucky number L. Now he wants to construct his luckiest number which is the minimum among all positive integers that are a multiple of L and consist of only digit '8'.", "inputFormat": "The input consists of multiple test cases. Each test case contains exactly one line containing L(1 ≤ L ≤ 2,000,000,000).\n\nThe last test case is followed by a line containing a zero.", "outputFormat": "For each test case, print a line containing the test case number( beginning with 1) followed by a integer which is the length of Bob's luckiest number. If Bob can't construct his luckiest number, print a zero.", "hint": null, "locale": "en", "translations": {"en": {"title": "[ICPC-Hefei 2008 Online] The Luckiest Number", "background": null, "description": "Chinese people think of '8' as the lucky digit. Bob also likes digit '8'. Moreover, Bob has his own lucky number L. Now he wants to construct his luckiest number which is the minimum among all positive integers that are a multiple of L and consist of only digit '8'.", "inputFormat": "The input consists of multiple test cases. Each test case contains exactly one line containing L(1 ≤ L ≤ 2,000,000,000).\n\nThe last test case is followed by a line containing a zero.", "outputFormat": "For each test case, print a line containing the test case number( beginning with 1) followed by a integer which is the length of Bob's luckiest number. If Bob can't construct his luckiest number, print a zero.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[ICPC-Hefei 2008 Online] The Luckiest Number", "background": null, "description": "中国人认为“8”是幸运数字。Bob 也喜欢数字“8”。此外，Bob 有自己的幸运数字 $L$。现在，他想构造出自己的最幸运的数字，即所有仅由数字“8”组成且是 $L$ 的倍数的正整数中的最小值。", "inputFormat": "多个测试用例组成（不超过 $10$ 组）。每个测试用例包含一行，其中包含 $L$（$1 ≤ L ≤ 2,000,000,000$）。\n\n最后一个测试用例后跟着一行，其中包含零。", "outputFormat": "对于每个测试用例，输出一行，包含测试用例编号（从 $1$ 开始），后跟一个整数，该整数是 Bob 最幸运的数字的长度。如果 Bob 无法构造他最幸运的数字，则输出零。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": null, "locale": "zh-CN"}}}
{"pid": "P10497", "type": "P", "difficulty": 2, "samples": [["5\n1\n2\n1\n0", "2\n4\n5\n3\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2003", "线段树", "USACO", "树状数组"], "title": "[USACO03OPEN] Lost Cows", "background": null, "description": "N (2 <= N <= 8,000) cows have unique brands in the range 1..N. In a spectacular display of poor judgment, they visited the neighborhood 'watering hole' and drank a few too many beers before dinner. When it was time to line up for their evening meal, they did not line up in the required ascending numerical order of their brands.Regrettably, FJ does not have a way to sort them. \n\nFurthermore, he's not very good at observing problems. Instead of writing down each cow's brand, he determined a rather silly statistic: For each cow in line, he knows the number of cows that precede that cow in line that do, in fact, have smaller brands than that cow.Given this data, tell FJ the exact ordering of the cows.", "inputFormat": "Line 1: A single integer, N\n\nLines 2..N: These N-1 lines describe the number of cows that precede a given cow in line and have brands smaller than that cow. Of course, no cows precede the first cow in line, so she is not listed. Line 2 of the input describes the number of preceding cows whose brands are smaller than the cow in slot #2; line 3 describes the number of preceding cows whose brands are smaller than the cow in slot #3; and so on.", "outputFormat": "Lines 1..N: Each of the N lines of output tells the brand of a cow in line. Line #1 of the output tells the brand of the first cow in line; line 2 tells the brand of the second cow; and so on.", "hint": null, "locale": "en", "translations": {"en": {"title": "[USACO03OPEN] Lost Cows", "background": null, "description": "N (2 <= N <= 8,000) cows have unique brands in the range 1..N. In a spectacular display of poor judgment, they visited the neighborhood 'watering hole' and drank a few too many beers before dinner. When it was time to line up for their evening meal, they did not line up in the required ascending numerical order of their brands.Regrettably, FJ does not have a way to sort them. \n\nFurthermore, he's not very good at observing problems. Instead of writing down each cow's brand, he determined a rather silly statistic: For each cow in line, he knows the number of cows that precede that cow in line that do, in fact, have smaller brands than that cow.Given this data, tell FJ the exact ordering of the cows.", "inputFormat": "Line 1: A single integer, N\n\nLines 2..N: These N-1 lines describe the number of cows that precede a given cow in line and have brands smaller than that cow. Of course, no cows precede the first cow in line, so she is not listed. Line 2 of the input describes the number of preceding cows whose brands are smaller than the cow in slot #2; line 3 describes the number of preceding cows whose brands are smaller than the cow in slot #3; and so on.", "outputFormat": "Lines 1..N: Each of the N lines of output tells the brand of a cow in line. Line #1 of the output tells the brand of the first cow in line; line 2 tells the brand of the second cow; and so on.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO03OPEN] Lost Cows", "background": null, "description": "有 $N (2 \\leq N \\leq 8000)$ 头奶牛，它们在编号范围 $[1,N]$ 内具有唯一的标号。在一个极其糟糕的判断展示中，它们去了附近的“水坑”，在晚饭前喝了太多啤酒。到了排队吃晚饭的时候，它们没有按照编号升序的顺序排队。可惜的是，FJ 没有办法对它们进行排序。\n\n此外，他在观察问题方面也不太擅长。他没有记下每头奶牛的编号，而是得到了一个相当愚蠢的统计数据：对于队伍中的每一头奶牛，他知道在这头奶牛之前，有多少头奶牛的编号确实比它小。给定这些数据，请告诉 FJ 奶牛的精确排列顺序。", "inputFormat": "第 1 行，一个整数 $N$。\n\n第 2 到第 $N$ 行，这 $N-1$ 行描述了在队伍中某头奶牛之前有多少头奶牛的编号比她小。\n\n当然，没有奶牛排在第 1 头奶牛前面，所以她没有被列出。第 2 行描述了排在第 2 个位置的奶牛之前，有多少奶牛的编号比她小；第 3 行描述了排在第 3 个位置的奶牛之前，有多少奶牛的编号比她小；依此类推。", "outputFormat": "第 1 到第 $N$ 行，输出的这 $N$ 行中的每一行表示排队中的一头奶牛的编号。输出的第 1 行表示排在队伍第 1 个位置的奶牛的编号；第 2 行表示排在第 2 个位置的奶牛的编号；依此类推。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P10498", "type": "P", "difficulty": 5, "samples": [["1 6 10 3\n011112\n1E\nE\n0", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["矩阵加速"], "title": "石头游戏", "background": "", "description": "石头游戏在一个 $n$ 行 $m$ 列的网格上进行，每个格子对应一种操作序列，操作序列至多有 $10$ 种，分别用 $0 \\sim 9$ 这 $10$ 个数字指明。\n\n操作序列是一个长度不超过 $6$ 且循环执行、每秒执行一个字符的字符串。\n\n每秒钟，所有格子同时执行各自操作序列里的下一个字符。\n\n序列中的每个字符是以下格式之一：\n\n  1. 数字 $0 \\sim 9$：表示拿 $0 \\sim 9$ 个石头到该格子。\n  2. `NWSE`：表示把这个格子内所有的石头推到相邻的格子，`N` 表示上方，`W` 表示左方，`S` 表示下方，`E` 表示右方。\n  3. `D`：表示拿走这个格子的所有石头。\n\n给定每种操作序列对应的字符串，以及网格中每个格子对应的操作序列，求石头游戏进行了 $t$ 秒之后，石头最多的格子里有多少个石头。\n\n在游戏开始时，网格是空的。", "inputFormat": "第一行 $4$ 个整数 $n, m, t, act$。\n\n接下来 $n$ 行，每行 $m$ 个字符，表示每个格子对应的操作序列。\n\n最后 $act$ 行，每行一个字符串，表示从 $0$ 开始的每个操作序列。", "outputFormat": "一个整数：游戏进行了 $t$ 秒之后，所有方格中石头最多的格子有多少个石头。\n", "hint": "对于所有的测试数据， 满足 $1 \\le m,n \\le 8$，$1 \\le t \\le 10^8$，$1 \\le act \\le 10$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "石头游戏", "background": "", "description": "石头游戏在一个 $n$ 行 $m$ 列的网格上进行，每个格子对应一种操作序列，操作序列至多有 $10$ 种，分别用 $0 \\sim 9$ 这 $10$ 个数字指明。\n\n操作序列是一个长度不超过 $6$ 且循环执行、每秒执行一个字符的字符串。\n\n每秒钟，所有格子同时执行各自操作序列里的下一个字符。\n\n序列中的每个字符是以下格式之一：\n\n  1. 数字 $0 \\sim 9$：表示拿 $0 \\sim 9$ 个石头到该格子。\n  2. `NWSE`：表示把这个格子内所有的石头推到相邻的格子，`N` 表示上方，`W` 表示左方，`S` 表示下方，`E` 表示右方。\n  3. `D`：表示拿走这个格子的所有石头。\n\n给定每种操作序列对应的字符串，以及网格中每个格子对应的操作序列，求石头游戏进行了 $t$ 秒之后，石头最多的格子里有多少个石头。\n\n在游戏开始时，网格是空的。", "inputFormat": "第一行 $4$ 个整数 $n, m, t, act$。\n\n接下来 $n$ 行，每行 $m$ 个字符，表示每个格子对应的操作序列。\n\n最后 $act$ 行，每行一个字符串，表示从 $0$ 开始的每个操作序列。", "outputFormat": "一个整数：游戏进行了 $t$ 秒之后，所有方格中石头最多的格子有多少个石头。\n", "hint": "对于所有的测试数据， 满足 $1 \\le m,n \\le 8$，$1 \\le t \\le 10^8$，$1 \\le act \\le 10$。", "locale": "zh-CN"}}}
{"pid": "P10499", "type": "P", "difficulty": 5, "samples": [["2\n3\n0 0 0\n1 1 1\n1 2\n1 3\n2 1\n2 3\n3 1\n3 2\n0 0\n3\n0 0 0\n1 0 1\n1 2\n2 1\n0 0", "4\nOh,it's impossible~!!"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["高斯消元"], "title": "开关问题", "background": "", "description": "有 $N$ 个相同的开关，每个开关都与某些开关有着联系，每当你打开或者关闭某个开关的时候，其他的与此开关相关联的开关也会相应地发生变化，即这些相联系的开关的状态如果原来为开就变为关，如果为关就变为开。\n\n你的目标是经过若干次开关操作后使得最后 $N$ 个开关达到一个特定的状态。\n\n对于任意一个开关，最多只能进行一次开关操作。\n\n你的任务是，计算有多少种可以达到指定状态的方法。（不计开关操作的顺序）", "inputFormat": "输入第一行有一个数 $K$，表示以下有 $K$ 组测试数据。 \n\n每组测试数据的格式如下： \n\n第一行：一个数 $N$。\n\n第二行：$N$ 个 $0$ 或者 $1$ 的数，表示开始时 $N$ 个开关状态。\n\n第三行：$N$ 个 $0$ 或者 $1$ 的数，表示操作结束后 $N$ 个开关的状态。\n\n接下来每行两个数 $I,J$，表示如果操作第 $I$ 个开关，第 $J$ 个开关的状态也会变化。\n\n每组数据以 `0 0` 结束。", "outputFormat": "每组数据输出占一行。\n\n如果有可行方法，输出总数，否则输出 `Oh,it's impossible~!!` 。", "hint": "对于所有测试数据，满足 $1 \\le K \\le 10$，$0 < N < 29$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "开关问题", "background": "", "description": "有 $N$ 个相同的开关，每个开关都与某些开关有着联系，每当你打开或者关闭某个开关的时候，其他的与此开关相关联的开关也会相应地发生变化，即这些相联系的开关的状态如果原来为开就变为关，如果为关就变为开。\n\n你的目标是经过若干次开关操作后使得最后 $N$ 个开关达到一个特定的状态。\n\n对于任意一个开关，最多只能进行一次开关操作。\n\n你的任务是，计算有多少种可以达到指定状态的方法。（不计开关操作的顺序）", "inputFormat": "输入第一行有一个数 $K$，表示以下有 $K$ 组测试数据。 \n\n每组测试数据的格式如下： \n\n第一行：一个数 $N$。\n\n第二行：$N$ 个 $0$ 或者 $1$ 的数，表示开始时 $N$ 个开关状态。\n\n第三行：$N$ 个 $0$ 或者 $1$ 的数，表示操作结束后 $N$ 个开关的状态。\n\n接下来每行两个数 $I,J$，表示如果操作第 $I$ 个开关，第 $J$ 个开关的状态也会变化。\n\n每组数据以 `0 0` 结束。", "outputFormat": "每组数据输出占一行。\n\n如果有可行方法，输出总数，否则输出 `Oh,it's impossible~!!` 。", "hint": "对于所有测试数据，满足 $1 \\le K \\le 10$，$0 < N < 29$。", "locale": "zh-CN"}}}
{"pid": "P10500", "type": "P", "difficulty": 4, "samples": [["2\n4 5", "2.750 4.250 4.750\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "期望"], "title": "Rainbow 的信号", "background": null, "description": "Freda 发明了传呼机之后，Rainbow 进一步改进了传呼机发送信息所使用的信号。\n\n由于现在是数字、信息时代，Rainbow 发明的信号用 $N$ 个自然数表示。\n\n为了避免两个人的对话被大坏蛋 VariantF 偷听，Rainbow 把对话分成 $A、B、C$ 三部分，分别用 $a、b、c$ 三个密码加密。\n\n现在 Freda 接到了 Rainbow 的信息，她的首要工作就是解密。\n\nFreda 了解到，这三部分的密码计算方式如下：\n\n在 $1 \\sim N$ 这 $N$ 个数中，等概率地选取两个数 $l、r$，如果 $l>r$，则交换 $l、r$。\n\n把信号中的第 $l$ 个数到第 $r$ 个数取出来，构成一个数列 $P$。\n\n$A$ 部分对话的密码是数列 $P$ 的 $\\operatorname{xor}$ 和的数学期望值，$\\operatorname{xor}$ 和就是数列 $P$ 中各个数异或之后得到的数； $\\operatorname{xor}$ 和的期望就是对于所有可能选取的 $l、r$，所得到的数列的 $\\operatorname{xor}$ 和的平均数。\n\n$B$ 部分对话的密码是数列 $P$ 的 $\\operatorname{and}$ 和的期望，定义类似于 $\\operatorname{xor}$ 和。\n\n$C$ 部分对话的密码是数列 $P$ 的 $\\operatorname{or}$ 和的期望，定义类似于 $\\operatorname{xor}$ 和。\n\n请你帮忙计算这三个密码。", "inputFormat": "第一行一个正整数 $N$。\n\n第二行 $N$ 个自然数，表示 Freda 接到的信号。", "outputFormat": "一行三个实数，分别表示 $\\operatorname{xor}$ 和、$\\operatorname{and}$ 和、$\\operatorname{or}$ 和的期望，四舍五入保留 $3$ 位小数，相邻两个实数之间用一个空格隔开。", "hint": "### 样例解释\n\n样例 1 共包含四种可能的 $l,r$：\n\n|$l, r$ | $\\operatorname{xor}$ 和 | $\\operatorname{and}$ 和 | $\\operatorname{or}$ 和 |\n|-|-|-|-|\n| $1,1$ | $4$ | $4$ | $4$ |\n| $1,2$ | $1$ | $4$ | $5$ |\n| $2,1$ | $1$ | $4$ | $5$ |\n| $2,2$ | $5$ | $5$ | $5$ |\n\n以上每一对 $l,r$ 出现的概率均相同, 因此分别对 $\\operatorname{xor}$ 和、$\\operatorname{and}$ 和、$\\operatorname{or}$ 和取平均数就是数学期望值。\n\n## 数据范围与约定\n\n对于 $20 \\%$ 的数据， $1 \\le N \\le 100$ 。  \n对于 $40 \\%$ 的数据， $1 \\le N \\le 1000$ 。  \n对于另外 $30 \\%$ 的数据, $N$ 个数为 $0$ 或 $1$ 。  \n对于 $100 \\%$ 的数据, $1 \\le N \\le 100000$，$N$ 个自然数均不超过 $10^9$ 。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Rainbow 的信号", "background": null, "description": "Freda 发明了传呼机之后，Rainbow 进一步改进了传呼机发送信息所使用的信号。\n\n由于现在是数字、信息时代，Rainbow 发明的信号用 $N$ 个自然数表示。\n\n为了避免两个人的对话被大坏蛋 VariantF 偷听，Rainbow 把对话分成 $A、B、C$ 三部分，分别用 $a、b、c$ 三个密码加密。\n\n现在 Freda 接到了 Rainbow 的信息，她的首要工作就是解密。\n\nFreda 了解到，这三部分的密码计算方式如下：\n\n在 $1 \\sim N$ 这 $N$ 个数中，等概率地选取两个数 $l、r$，如果 $l>r$，则交换 $l、r$。\n\n把信号中的第 $l$ 个数到第 $r$ 个数取出来，构成一个数列 $P$。\n\n$A$ 部分对话的密码是数列 $P$ 的 $\\operatorname{xor}$ 和的数学期望值，$\\operatorname{xor}$ 和就是数列 $P$ 中各个数异或之后得到的数； $\\operatorname{xor}$ 和的期望就是对于所有可能选取的 $l、r$，所得到的数列的 $\\operatorname{xor}$ 和的平均数。\n\n$B$ 部分对话的密码是数列 $P$ 的 $\\operatorname{and}$ 和的期望，定义类似于 $\\operatorname{xor}$ 和。\n\n$C$ 部分对话的密码是数列 $P$ 的 $\\operatorname{or}$ 和的期望，定义类似于 $\\operatorname{xor}$ 和。\n\n请你帮忙计算这三个密码。", "inputFormat": "第一行一个正整数 $N$。\n\n第二行 $N$ 个自然数，表示 Freda 接到的信号。", "outputFormat": "一行三个实数，分别表示 $\\operatorname{xor}$ 和、$\\operatorname{and}$ 和、$\\operatorname{or}$ 和的期望，四舍五入保留 $3$ 位小数，相邻两个实数之间用一个空格隔开。", "hint": "### 样例解释\n\n样例 1 共包含四种可能的 $l,r$：\n\n|$l, r$ | $\\operatorname{xor}$ 和 | $\\operatorname{and}$ 和 | $\\operatorname{or}$ 和 |\n|-|-|-|-|\n| $1,1$ | $4$ | $4$ | $4$ |\n| $1,2$ | $1$ | $4$ | $5$ |\n| $2,1$ | $1$ | $4$ | $5$ |\n| $2,2$ | $5$ | $5$ | $5$ |\n\n以上每一对 $l,r$ 出现的概率均相同, 因此分别对 $\\operatorname{xor}$ 和、$\\operatorname{and}$ 和、$\\operatorname{or}$ 和取平均数就是数学期望值。\n\n## 数据范围与约定\n\n对于 $20 \\%$ 的数据， $1 \\le N \\le 100$ 。  \n对于 $40 \\%$ 的数据， $1 \\le N \\le 1000$ 。  \n对于另外 $30 \\%$ 的数据, $N$ 个数为 $0$ 或 $1$ 。  \n对于 $100 \\%$ 的数据, $1 \\le N \\le 100000$，$N$ 个自然数均不超过 $10^9$ 。", "locale": "zh-CN"}}}
{"pid": "P10501", "type": "P", "difficulty": 5, "samples": [["2 2\n3 2\n4 2", "LOSE\nLOSE\nWIN"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["博弈论", "SG 函数"], "title": "Cutting Game", "background": "", "description": "Urej loves to play various types of dull games. He usually asks other people to play with him. He says that playing those games can show his extraordinary wit. Recently Urej takes a great interest in a new game, and Erif Nezorf becomes the victim. To get away from suffering playing such a dull game, Erif Nezorf requests your help. The game uses a rectangular paper that consists of $W \\times H$ grids. Two players cut the paper into two pieces of rectangular sections in turn. In each turn the player can cut either horizontally or vertically, keeping every grids unbroken. After $N$ turns the paper will be broken into $N+1$ pieces, and in the later turn the players can choose any piece to cut. If one player cuts out a piece of paper with a single grid, he wins the game. If these two people are both quite clear, you should write a problem to tell whether the one who cut first can win or not. ", "inputFormat": "The input contains multiple test cases. Each test case contains only two integers $W$ and $H (2 \\le W , H \\le 200)$ in one line, which are the width and height of the original paper.", "outputFormat": "For each test case, only one line should be printed. If the one who cut first can win the game, print \"WIN\", otherwise, print \"LOSE\".", "hint": "", "locale": "en", "translations": {"en": {"title": "Cutting Game", "background": "", "description": "Urej loves to play various types of dull games. He usually asks other people to play with him. He says that playing those games can show his extraordinary wit. Recently Urej takes a great interest in a new game, and Erif Nezorf becomes the victim. To get away from suffering playing such a dull game, Erif Nezorf requests your help. The game uses a rectangular paper that consists of $W \\times H$ grids. Two players cut the paper into two pieces of rectangular sections in turn. In each turn the player can cut either horizontally or vertically, keeping every grids unbroken. After $N$ turns the paper will be broken into $N+1$ pieces, and in the later turn the players can choose any piece to cut. If one player cuts out a piece of paper with a single grid, he wins the game. If these two people are both quite clear, you should write a problem to tell whether the one who cut first can win or not. ", "inputFormat": "The input contains multiple test cases. Each test case contains only two integers $W$ and $H (2 \\le W , H \\le 200)$ in one line, which are the width and height of the original paper.", "outputFormat": "For each test case, only one line should be printed. If the one who cut first can win the game, print \"WIN\", otherwise, print \"LOSE\".", "hint": "", "locale": "en"}, "zh-CN": {"title": "Cutting Game", "background": null, "description": "Urej 喜欢玩各种类型的沉闷游戏。他通常会邀请其他人和他一起玩。他说，玩这些游戏可以展现他的非凡智慧。最近，Urej 对一个新游戏产生了极大兴趣，而 Erif Nezorf 成为了牺牲品。为了摆脱玩这样一个沉闷游戏的痛苦，Erif Nezorf 请求你的帮助。这个游戏使用一个由 $W \\times H$ 格网组成的矩形纸张。两名玩家轮流将纸张切割成两个矩形部分。在每个回合中，玩家可以横向或纵向切割，保持每个格网完整。经过 $N$ 轮后，纸张将被切割成 $N+1$ 片，然后在后续的回合中，玩家可以选择任意一片进行切割。如果一名玩家切割出一个只有一个格网的纸片，他就赢得了游戏。如果这两个人都非常聪明，你应该写一个问题来告诉是否先手的玩家能赢得游戏。", "inputFormat": "输入包含多个测试用例。每个测试用例在一行中只包含两个整数 $W$ 和 $H (2 \\le W , H \\le 200)$，分别表示原始纸张的宽度和高度。", "outputFormat": "对于每个测试用例，应该只输出一行。如果先手的玩家能赢得游戏，则输出 \"WIN\"，否则输出 \"LOSE\"。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": null, "locale": "zh-CN"}}}
{"pid": "P10502", "type": "P", "difficulty": 5, "samples": [["2 2 4 \n0 1 \n1 1", "1 2\n2 3"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288]}, "tags": ["O2优化", "矩阵加速"], "title": "Matrix Power Series", "background": "", "description": "Givena $n×n$ matrix $A$ and apositive integer $k$，find the sum $S=A+A^2 +A^3 +...+A^k$.", "inputFormat": "The input contains exactly one test case. The first line of input contains three positive integers $n$ ($n \\le 30$), $k$ ($k \\le 10^9$) and $m$ ($m < 10^4$). Then follow n lines each containing $n$ non negative integers below 32,768, giving $A$’s elements in row-major order.", "outputFormat": "Output the elements of $S$ modulo $m$ in the same way as $A$ is given.", "hint": "", "locale": "en", "translations": {"en": {"title": "Matrix Power Series", "background": "", "description": "Givena $n×n$ matrix $A$ and apositive integer $k$，find the sum $S=A+A^2 +A^3 +...+A^k$.", "inputFormat": "The input contains exactly one test case. The first line of input contains three positive integers $n$ ($n \\le 30$), $k$ ($k \\le 10^9$) and $m$ ($m < 10^4$). Then follow n lines each containing $n$ non negative integers below 32,768, giving $A$’s elements in row-major order.", "outputFormat": "Output the elements of $S$ modulo $m$ in the same way as $A$ is given.", "hint": "", "locale": "en"}, "zh-CN": {"title": "Matrix Power Series", "background": "", "description": "给定一个 $n×n$ 矩阵 $A$ 和一个正整数 $k$，找出和 $S=A+A^2 +A^3 +...+A^k$。", "inputFormat": "输入包含一个测试用例。输入的第一行包含三个正整数 $n$（$n \\le 30$）、$k$（$k \\le 10^9$）和 $m$（$m < 10^4$）。接下来的 $n$ 行每行包含 $n$ 个小于 32,768 的非负整数，按行主序给出 $A$ 的元素。", "outputFormat": "以与给定 $A$ 相同的方式输出 $S$ 的元素对 $m$ 取模。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10503", "type": "P", "difficulty": 4, "samples": [["1 1\n1\n2 2\n0 0\n3 7\n23 47 16", "234\n2799\n72937"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "矩阵加速"], "title": "233 Matrix", "background": "", "description": "In our daily life we often use 233 to express our feelings. Actually, we may say 2333, 23333, or 233333 ... in the same meaning. And here is the question: Suppose we have a matrix called 233 matrix. In the first line, it would be 233, 2333, 23333... (it means $a _ {0,1} = 233$, $a_{0,2} = 2333$, $a_{0,3} = 23333$...) Besides, in 233 matrix, we got $a_{i,j} = a_{i-1,j} +a_{i,j-1}( i,j \\neq 0)$. Now you have known $a_{1,0},a_{2,0},\\dots,a_{n,0}$, could you tell me $a_{n,m}$ in the 233 matrix?", "inputFormat": "There are multiple test cases. Please process till EOF.\n\nFor each case, the first line contains two postive integers $n,m(n \\le 10,m \\le 10^9)$. The second line contains n integers, $a_{1,0},a_{2,0},...,a_{n,0}$ ($0 \\le a_{i,0} < 2^{31}$).", "outputFormat": "For each case, output $a_{n,m}$ mod 10000007.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/ndjcn0l1.png)", "locale": "en", "translations": {"en": {"title": "233 Matrix", "background": "", "description": "In our daily life we often use 233 to express our feelings. Actually, we may say 2333, 23333, or 233333 ... in the same meaning. And here is the question: Suppose we have a matrix called 233 matrix. In the first line, it would be 233, 2333, 23333... (it means $a _ {0,1} = 233$, $a_{0,2} = 2333$, $a_{0,3} = 23333$...) Besides, in 233 matrix, we got $a_{i,j} = a_{i-1,j} +a_{i,j-1}( i,j \\neq 0)$. Now you have known $a_{1,0},a_{2,0},\\dots,a_{n,0}$, could you tell me $a_{n,m}$ in the 233 matrix?", "inputFormat": "There are multiple test cases. Please process till EOF.\n\nFor each case, the first line contains two postive integers $n,m(n \\le 10,m \\le 10^9)$. The second line contains n integers, $a_{1,0},a_{2,0},...,a_{n,0}$ ($0 \\le a_{i,0} < 2^{31}$).", "outputFormat": "For each case, output $a_{n,m}$ mod 10000007.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/ndjcn0l1.png)", "locale": "en"}, "zh-CN": {"title": "233 Matrix", "background": "", "description": "在我们的日常生活中，我们经常用 233 来表达我们的情感。实际上，我们可能会说 2333、23333 或者 233333... 都表示同样的意思。现在有一个问题：假设我们有一个称为 233 矩阵。在第一行，它是 233、2333、23333...（表示 $a _ {0,1} = 233$，$a_{0,2} = 2333$，$a_{0,3} = 23333$...）。此外，在 233 矩阵中，我们有 $a_{i,j} = a_{i-1,j} +a_{i,j-1}( i,j \\neq 0)$。现在已知 $a_{1,0},a_{2,0},\\dots,a_{n,0}$，你能告诉我 233 矩阵中的 $a_{n,m}$ 吗？", "inputFormat": "有多个测试用例，请处理直到 EOF。\n\n对于每个案例，第一行包含两个正整数 $n,m(n \\le 10,m \\le 10^9)$。第二行包含 n 个整数，$a_{1,0},a_{2,0},...,a_{n,0}$（$0 \\le a_{i,0} < 2^{31}$）。", "outputFormat": "对于每个案例，输出 $a_{n,m}$ 模 10000007。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10504", "type": "P", "difficulty": 4, "samples": [["3 1 0\n10 20 30\n-1 -1 2", "0.300000\n"], ["5 1 2\n36 44 13 83 63\n-1 2 -1 2 1", "0.980387"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "O2优化", "期望"], "title": "守卫者的挑战", "background": "", "description": "打开了黑魔法师 Vani 的大门，队员们在迷宫般的路上漫无目的地搜寻着关押 applepi 的监狱的所在地。突然，眼前一道亮光闪过。“我，Nizem，是黑魔法圣殿的守卫者。如果你能通过我的挑战，那么你可以带走黑魔法圣殿的地图……”瞬间，队员们被传送到了一个擂台上，最初身边有一个容量为 $K$ 的包包。\n  \n擂台赛一共有 $N$ 项挑战，各项挑战依次进行。第 $i$ 项挑战有一个属性 $a_i$，如果 $a_i\\geq 0$，表示这次挑战成功后可以再获得一个容量为 $a_i$ 的包包；如果 $a_i=-1$，则表示这次挑战成功后可以得到一个大小为 $1$ 的地图残片。地图残片必须装在包包里才能带出擂台，包包没有必要全部装满，但是队员们必须把 【获得的所有的】地图残片都带走（没有得到的不用考虑，只需要完成所有N项挑战后背包容量足够容纳地图残片即可），才能拼出完整的地图。并且他们至少要挑战成功 $L$ 次才能离开擂台。\n  \n队员们一筹莫展之时，善良的守卫者 Nizem 帮忙预估出了每项挑战成功的概率，其中第 $i$ 项挑战成功的概率为 $p_i\\%$。现在，请你帮忙预测一下，队员们能够带上他们获得的地图残片离开擂台的概率。", "inputFormat": "第一行三个整数 $N,L,K$。\n  \n第二行 $N$ 个实数，第 $i$ 个实数 $p_i$ 表示第 $i$ 项挑战成功的百分比。\n  \n第三行 $N$ 个整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 项挑战的属性值.", "outputFormat": "一个整数，表示所求概率，四舍五入保留 $6$ 位小数。", "hint": "在第一个样例中，若第三项挑战成功，如果前两场中某场胜利，队员们就有空间来容纳得到的地图残片，如果挑战失败，根本就没有获得地图残片，不用考虑是否能装下；若第三项挑战失败，如果前两场有胜利，没有包来装地图残片，如果前两场都失败，不满足至少挑战成功1次的要求。因此所求概率就是第三场挑战获胜的概率。\n\n对于 $100\\%$ 的数据，保证 $0\\leq K\\leq 2000$，$0\\leq N\\leq 200$，$-1\\leq a_i\\leq 1000$，$0\\leq L\\leq N$，$0\\leq p_i\\leq 100$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "守卫者的挑战", "background": "", "description": "打开了黑魔法师 Vani 的大门，队员们在迷宫般的路上漫无目的地搜寻着关押 applepi 的监狱的所在地。突然，眼前一道亮光闪过。“我，Nizem，是黑魔法圣殿的守卫者。如果你能通过我的挑战，那么你可以带走黑魔法圣殿的地图……”瞬间，队员们被传送到了一个擂台上，最初身边有一个容量为 $K$ 的包包。\n  \n擂台赛一共有 $N$ 项挑战，各项挑战依次进行。第 $i$ 项挑战有一个属性 $a_i$，如果 $a_i\\geq 0$，表示这次挑战成功后可以再获得一个容量为 $a_i$ 的包包；如果 $a_i=-1$，则表示这次挑战成功后可以得到一个大小为 $1$ 的地图残片。地图残片必须装在包包里才能带出擂台，包包没有必要全部装满，但是队员们必须把 【获得的所有的】地图残片都带走（没有得到的不用考虑，只需要完成所有N项挑战后背包容量足够容纳地图残片即可），才能拼出完整的地图。并且他们至少要挑战成功 $L$ 次才能离开擂台。\n  \n队员们一筹莫展之时，善良的守卫者 Nizem 帮忙预估出了每项挑战成功的概率，其中第 $i$ 项挑战成功的概率为 $p_i\\%$。现在，请你帮忙预测一下，队员们能够带上他们获得的地图残片离开擂台的概率。", "inputFormat": "第一行三个整数 $N,L,K$。\n  \n第二行 $N$ 个实数，第 $i$ 个实数 $p_i$ 表示第 $i$ 项挑战成功的百分比。\n  \n第三行 $N$ 个整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 项挑战的属性值.", "outputFormat": "一个整数，表示所求概率，四舍五入保留 $6$ 位小数。", "hint": "在第一个样例中，若第三项挑战成功，如果前两场中某场胜利，队员们就有空间来容纳得到的地图残片，如果挑战失败，根本就没有获得地图残片，不用考虑是否能装下；若第三项挑战失败，如果前两场有胜利，没有包来装地图残片，如果前两场都失败，不满足至少挑战成功1次的要求。因此所求概率就是第三场挑战获胜的概率。\n\n对于 $100\\%$ 的数据，保证 $0\\leq K\\leq 2000$，$0\\leq N\\leq 200$，$-1\\leq a_i\\leq 1000$，$0\\leq L\\leq N$，$0\\leq p_i\\leq 100$。", "locale": "zh-CN"}}}
{"pid": "P10505", "type": "P", "difficulty": 3, "samples": [["3 1\n5 0 2\n5 1 6\n4 2\n1 2 7 9\n5 6 7 9\n0 0", "83\n100"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["二分", "O2优化", "分数规划"], "title": "Dropping Test", "background": null, "description": "在某个课程中，你需要进行 $n$ 次测试。 \n\n如果你在共计 $b_i$ 道题的测试 $i$ 上的答对题目数量为 $a_i$，你的累积平均成绩就被定义为\n\n$$100\\times \\dfrac{\\displaystyle \\sum_{i=1}^n a_i}{\\displaystyle \\sum_{i=1}^n b_i}$$\n\n给定您的考试成绩和一个正整数 $k$，如果您被允许放弃任何 $k$ 门考试成绩，您的累积平均成绩的可能最大值是多少。\n\n假设您进行了 $3$ 次测试，成绩分别为 $5/5,0/1$ 和 $2/6$。\n\n在不放弃任何测试成绩的情况下，您的累积平均成绩是\n\n$$100\\times \\frac{5+0+2}{5+1+6} \\approx 58.33 \\approx 58$$\n\n然而，如果你放弃第三门成绩，则您的累积平均成绩就变成了\n\n$$100\\times \\frac{5+0}{5+1}\\approx 83.33\\approx 83$$", "inputFormat": "输入包含多组测试用例，每个测试用例包含三行。\n\n对于每组测试用例，第一行包含两个整数 $n$ 和 $k$。\n\n第二行包含 $n$ 个整数，表示所有的 $a_i$。\n\n第三行包含 $n$ 个整数，表示所有的 $b_i$。\n\n当输入用例 $n=k=0$ 时，表示输入终止，且该用例无需处理。", "outputFormat": "对于每个测试用例，输出一行结果，表示在放弃 $k$ 门成绩的情况下，可能的累积平均成绩最大值。\n\n结果应四舍五入到最接近的整数。", "hint": "数据范围 $1 \\le n \\le 1000$, $0 \\le k < n$, $0 \\le a_i \\le b_i \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Dropping Test", "background": null, "description": "在某个课程中，你需要进行 $n$ 次测试。 \n\n如果你在共计 $b_i$ 道题的测试 $i$ 上的答对题目数量为 $a_i$，你的累积平均成绩就被定义为\n\n$$100\\times \\dfrac{\\displaystyle \\sum_{i=1}^n a_i}{\\displaystyle \\sum_{i=1}^n b_i}$$\n\n给定您的考试成绩和一个正整数 $k$，如果您被允许放弃任何 $k$ 门考试成绩，您的累积平均成绩的可能最大值是多少。\n\n假设您进行了 $3$ 次测试，成绩分别为 $5/5,0/1$ 和 $2/6$。\n\n在不放弃任何测试成绩的情况下，您的累积平均成绩是\n\n$$100\\times \\frac{5+0+2}{5+1+6} \\approx 58.33 \\approx 58$$\n\n然而，如果你放弃第三门成绩，则您的累积平均成绩就变成了\n\n$$100\\times \\frac{5+0}{5+1}\\approx 83.33\\approx 83$$", "inputFormat": "输入包含多组测试用例，每个测试用例包含三行。\n\n对于每组测试用例，第一行包含两个整数 $n$ 和 $k$。\n\n第二行包含 $n$ 个整数，表示所有的 $a_i$。\n\n第三行包含 $n$ 个整数，表示所有的 $b_i$。\n\n当输入用例 $n=k=0$ 时，表示输入终止，且该用例无需处理。", "outputFormat": "对于每个测试用例，输出一行结果，表示在放弃 $k$ 门成绩的情况下，可能的累积平均成绩最大值。\n\n结果应四舍五入到最接近的整数。", "hint": "数据范围 $1 \\le n \\le 1000$, $0 \\le k < n$, $0 \\le a_i \\le b_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10506", "type": "P", "difficulty": 5, "samples": [["3\n2 2 2\n3\n1 3 5", "freda\nrainbow"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["博弈论"], "title": "魔法珠", "background": "", "description": "Freda 和 rainbow 是超自然之界学校（Preternatural Kingdom University，简称 PKU）魔法学院的学生。为了展示新学的魔法，Ta 们决定进行一场对弈~~~\n\n起初 Freda 面前有 $n$ 堆魔法珠，其中第 $i$ 堆有 $a_i$ 颗。 Freda 和 rainbow 可以轮流进行以下操作：\n\n1.选择 $n$ 堆中魔法珠数量大于 $1$ 的任意一堆。记该堆魔法珠的数量为 $p$，$p$ 有 $b_1,b_2 \\cdots b_m$ 这 $m$ 个小于 $p$ 的约数。\n\n2.施展魔法把这一堆魔法珠变成 $m$ 堆，每堆各有 $b_1$、$b_2 \\cdots b_m$ 颗魔法珠。\n\n3.选择这m堆中的一堆魔法珠，施展魔法令其消失。\n\n注意一次操作过后，魔法珠的堆数会增加m-2，各堆中魔法珠数量的总和可能会发生变化。\n\n当轮到某人操作时，如果每堆中魔法珠的数量均为1，那么ta就输了。\n\nFreda 和 rainbow 都采取最好的策略，从 Freda 开始。请你预测一下，谁能获胜呢？", "inputFormat": "本题仅有一个测试点，包含多组数据，以 EOF 结尾。\n\n每组数据的第一行包含一个整数 $n$。\n\n第二行包含 $n$ 个整数 $a_i$。", "outputFormat": "对于每组数据，在两人均采取最佳策略的前提下，若 Freda 能获胜，输出 freda；若 Rainbow 能获胜，输出 rainbow。", "hint": "对于所有测试数据满足 $1\\le n\\le100$，$1\\le a_i\\le 1000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "魔法珠", "background": "", "description": "Freda 和 rainbow 是超自然之界学校（Preternatural Kingdom University，简称 PKU）魔法学院的学生。为了展示新学的魔法，Ta 们决定进行一场对弈~~~\n\n起初 Freda 面前有 $n$ 堆魔法珠，其中第 $i$ 堆有 $a_i$ 颗。 Freda 和 rainbow 可以轮流进行以下操作：\n\n1.选择 $n$ 堆中魔法珠数量大于 $1$ 的任意一堆。记该堆魔法珠的数量为 $p$，$p$ 有 $b_1,b_2 \\cdots b_m$ 这 $m$ 个小于 $p$ 的约数。\n\n2.施展魔法把这一堆魔法珠变成 $m$ 堆，每堆各有 $b_1$、$b_2 \\cdots b_m$ 颗魔法珠。\n\n3.选择这m堆中的一堆魔法珠，施展魔法令其消失。\n\n注意一次操作过后，魔法珠的堆数会增加m-2，各堆中魔法珠数量的总和可能会发生变化。\n\n当轮到某人操作时，如果每堆中魔法珠的数量均为1，那么ta就输了。\n\nFreda 和 rainbow 都采取最好的策略，从 Freda 开始。请你预测一下，谁能获胜呢？", "inputFormat": "本题仅有一个测试点，包含多组数据，以 EOF 结尾。\n\n每组数据的第一行包含一个整数 $n$。\n\n第二行包含 $n$ 个整数 $a_i$。", "outputFormat": "对于每组数据，在两人均采取最佳策略的前提下，若 Freda 能获胜，输出 freda；若 Rainbow 能获胜，输出 rainbow。", "hint": "对于所有测试数据满足 $1\\le n\\le100$，$1\\le a_i\\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P10507", "type": "P", "difficulty": 5, "samples": [["2\n3\n1 2 3\n8\n1 5 6 7 9 12 14 17", "Bob will win\nGeorgia will win"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["博弈论"], "title": "Georgia and Bob", "background": "", "description": "Georgia and Bob decide to play a self-invented game. They draw a row of grids on paper, number the grids from left to right by $1 , 2 , 3 , \\cdots ,$ and place $N$ chessmen on different grids, as shown in the following figure for example:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tti7635d.png)\n\nGeorgia and Bob move the chessmen in turn. Every time a player will choose a chessman, and move it to the left without going over any other chessmen or across the left edge. The player can freely choose number of steps the chessman moves, with the constraint that the chessman must be moved at least ONE step and one grid can at most contains ONE single chessman. The player who cannot make a move loses the game.\n\nGeorgia always plays first since \"Lady first\". Suppose that Georgia and Bob both do their best in the game, i.e., if one of them knows a way to win the game, he or she will be able to carry it out.\n\nGiven the initial positions of the $n$ chessmen, can you predict who will finally win the game? ", "inputFormat": "The first line of the input contains a single integer $T (1 \\leq T \\leq 20)$, the number of test cases. Then $T$ cases follow. Each test case contains two lines. The first line consists of one integer $N (1 \\leq N \\leq 1000)$, indicating the number of chessmen. The second line contains $N$ different integers $P_1, P_2 \\dots P_n (1 \\leq P_i \\leq 10000)$, which are the initial positions of the $n$ chessmen.", "outputFormat": "For each test case, prints a single line, \"Georgia will win\", if Georgia will win the game; \"Bob will win\", if Bob will win the game; otherwise 'Not sure'.", "hint": "", "locale": "en", "translations": {"en": {"title": "Georgia and Bob", "background": "", "description": "Georgia and Bob decide to play a self-invented game. They draw a row of grids on paper, number the grids from left to right by $1 , 2 , 3 , \\cdots ,$ and place $N$ chessmen on different grids, as shown in the following figure for example:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tti7635d.png)\n\nGeorgia and Bob move the chessmen in turn. Every time a player will choose a chessman, and move it to the left without going over any other chessmen or across the left edge. The player can freely choose number of steps the chessman moves, with the constraint that the chessman must be moved at least ONE step and one grid can at most contains ONE single chessman. The player who cannot make a move loses the game.\n\nGeorgia always plays first since \"Lady first\". Suppose that Georgia and Bob both do their best in the game, i.e., if one of them knows a way to win the game, he or she will be able to carry it out.\n\nGiven the initial positions of the $n$ chessmen, can you predict who will finally win the game? ", "inputFormat": "The first line of the input contains a single integer $T (1 \\leq T \\leq 20)$, the number of test cases. Then $T$ cases follow. Each test case contains two lines. The first line consists of one integer $N (1 \\leq N \\leq 1000)$, indicating the number of chessmen. The second line contains $N$ different integers $P_1, P_2 \\dots P_n (1 \\leq P_i \\leq 10000)$, which are the initial positions of the $n$ chessmen.", "outputFormat": "For each test case, prints a single line, \"Georgia will win\", if Georgia will win the game; \"Bob will win\", if Bob will win the game; otherwise 'Not sure'.", "hint": "", "locale": "en"}, "zh-CN": {"title": "Georgia and Bob", "background": "", "description": "有一个无限长的棋盘，从左到右编号为 $1,2,3,\\cdots$。有 $n$ 个棋子在棋盘上，定义一次操作为把一枚棋子向左移动至少一格，不可以逾越其他棋子，不可与其他棋子重合，不可移出棋盘。\n\n告诉你这 $n$ 个棋子的位置（不保证顺序且保证没有棋子重合），Georgia 和 Bob 轮流进行操作，Georgia 先手，谁无法操作谁输。问最后谁会赢？\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tti7635d.png)", "inputFormat": "**本题有多组数据**。\n\n第一行一个整数 $T$（$1\\leq T\\leq 20$），表示数据组数。\n\n对于每组数据：\n\n第一行一个整数 $n$（$1\\leq n\\leq 1000$）。  \n\n接下来一行 $n$ 个整数，表示每个棋子的位置 $P_i$（$1\\leq P_i\\leq 10000$）。", "outputFormat": "对于每组数据，若 Georgia 胜输出 `Georgia will win`，若 Bob 胜输出 `Bob will win`，若平局则输出 `Not sure`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10508", "type": "P", "difficulty": 2, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["数论", "洛谷原创", "提交答案", "O2优化", "洛谷月赛"], "title": "质因子", "background": "你所提交的代码长度不应低于 10 字节。", "description": "给定 [numlist.txt](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/rxuwd604?contestId=170180)，请求出文件中的 $1000$ 个数的乘积的质因子 $2$ 出现的次数。", "inputFormat": "无", "outputFormat": "输出答案即可。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "质因子", "background": "你所提交的代码长度不应低于 10 字节。", "description": "给定 [numlist.txt](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/rxuwd604?contestId=170180)，请求出文件中的 $1000$ 个数的乘积的质因子 $2$ 出现的次数。", "inputFormat": "无", "outputFormat": "输出答案即可。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10509", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["洛谷原创", "提交答案", "O2优化", "洛谷月赛", "Ad-hoc"], "title": "停车场", "background": "", "description": "你有一片空地。这片空地可以视作一个一个 $n\\times n$ 的正方形。空地外一圈为墙壁，你无法拆除它们。\n\n现在你要在这片空地上规划停车位，使之成为一个停车场。你希望空地的左下角是停车场的出入口。出入口不能规划为停车位。空地和停车位都是 $1\\times 1$ 的正方形，且正方形的每条边与墙壁平行或者垂直。\n\n每个停车位都应该与至少一个空地四连通（即：停车场的上、下、左、右方至少有一个空地），且这个空地应当能通过若干次向上、下、左、右的移动，在不经过任何停车位的情况下到达出入口。\n\n下图为 $n=4$ 时停车位数最多的放置方法之一，其中红色为车位，蓝色为出口，白色为空地。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r3qljdsr.png)\n\n请问 $n=2023$ 下最多能安排多少个停车位？", "inputFormat": "", "outputFormat": "一个正整数，表示你的答案。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "停车场", "background": "", "description": "你有一片空地。这片空地可以视作一个一个 $n\\times n$ 的正方形。空地外一圈为墙壁，你无法拆除它们。\n\n现在你要在这片空地上规划停车位，使之成为一个停车场。你希望空地的左下角是停车场的出入口。出入口不能规划为停车位。空地和停车位都是 $1\\times 1$ 的正方形，且正方形的每条边与墙壁平行或者垂直。\n\n每个停车位都应该与至少一个空地四连通（即：停车场的上、下、左、右方至少有一个空地），且这个空地应当能通过若干次向上、下、左、右的移动，在不经过任何停车位的情况下到达出入口。\n\n下图为 $n=4$ 时停车位数最多的放置方法之一，其中红色为车位，蓝色为出口，白色为空地。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r3qljdsr.png)\n\n请问 $n=2023$ 下最多能安排多少个停车位？", "inputFormat": "", "outputFormat": "一个正整数，表示你的答案。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10510", "type": "P", "difficulty": 2, "samples": [["4 3\n1 1\n2 0\n1 2", "7\n6\n15\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "洛谷原创", "O2优化", "进制", "洛谷月赛"], "title": "进制", "background": "为了提供更加良好的区分度，相较于蓝桥杯国赛，本场比赛的所有程序设计题添加了额外样例，请在附件处下载。\n\n其中，后缀名为 $\\bf{.in}$ 的文件为输入文件，$\\bf{.out}$ 的文件为输出文件。您可以使用这些额外样例检验自己的程序正确性。但我们不保证通过额外样例一定能取得您期望的分数。\n\n此外，我们提供了相较蓝桥杯国赛更多档的部分分，以确保分数分布更为科学合理。", "description": "小洛正在学习三进制。他定义三进制数为每一位只包括 $0,1,2$ 三种数的**无穷长的**数字串 $a$。\n\n与一般的三进制数不同的是，小洛的三进制数从左往右书写。例如，在常规表述下，$4$ 的三进制表示为 $(0000\\ 0011)_3$，而在小洛的三进制数表示下为 $(1100\\ 0000 \\cdots)_3$。\n\n小洛特别喜欢从 $0$ 开始计数，因此他规定三进制的第 $0$ 位为最左侧的那一数位。\n\n下表给出了小洛的三进制数表示下，数字 $37$ 的最低的 $8$ 位数位以及位权：\n\n| 三进制数表示 | $1$ | $0$ | $1$ | $1$ | $0$ | $0$ | $0$ | $0$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| 位数 | $0$ | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ |\n| 位权 | $3^0$ | $3^1$ | $3^2$ | $3^3$ | $3^4$ | $3^5$ | $3^6$ | $3^7$ |\n\n现在小洛有一个十进制正整数 $V$（显然，需要将其转化为小洛的三进制数表示），并且给定三种操作：\n\n- 操作一，将第 $i$ 位上的数进行操作：$0$ 变为 $1$，$1$ 变为 $2$，$2$ 变为 $0$。\n- 操作二，将第 $i$ 位上的数进行操作：$0$ 变为 $2$，$1$ 变为 $0$，$2$ 变为 $1$。\n- 操作三，将第 $i$ 位上的数进行操作：$1$ 变为 $2$，$2$ 变为 $1$，$0$ 不变。\n\n小洛一共要进行 $q$ 次操作。每次操作后，小洛需要得到三进制串代表的数值。请你告诉他。\n\n如果对题意有不清晰之处，请查看样例解释。", "inputFormat": "第一行输入两个正整数 $V,q$。\n\n接下来 $q$ 行，每行一个操作，形如 `op i`。\n\n请注意，你需要将 $V$ 转化为三进制串并作为初始的三进制串。", "outputFormat": "输出共 $q$ 行，第 $i$ 行表示第 $i$ 个操作后的答案。", "hint": "**【样例解释】**\n\n初始时，$V=4$，转化为小洛的三进制数为 $\\texttt{1100 0000} \\cdots$，接下来进行了 $3$ 次操作：\n\n- 将第 $1$ 位上的数位从 $1$ 变为 $2$，三进制数变为 $\\texttt{1200 0000} \\cdots$，十进制下为 $7$。\n- 将第 $0$ 位上的数位从 $1$ 变为 $0$，三进制数变为 $\\texttt{0200 0000} \\cdots$，十进制下为 $6$。\n- 将第 $2$ 位上的数位从 $0$ 变为 $1$，三进制数变为 $\\texttt{0210 0000} \\cdots$，十进制下为 $15$。\n\n**【数据范围】**\n\n- 对于 $30\\%$ 的数据，保证 $V\\leq 10^9$。\n- 对于另外 $30\\%$ 的数据，保证不含操作三。\n\n对于所有数据，保证 $0\\leq V\\leq 10^{18}$，$1\\leq q\\leq 10^5$，任意获取到的答案不超过 $2\\times 10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "进制", "background": "为了提供更加良好的区分度，相较于蓝桥杯国赛，本场比赛的所有程序设计题添加了额外样例，请在附件处下载。\n\n其中，后缀名为 $\\bf{.in}$ 的文件为输入文件，$\\bf{.out}$ 的文件为输出文件。您可以使用这些额外样例检验自己的程序正确性。但我们不保证通过额外样例一定能取得您期望的分数。\n\n此外，我们提供了相较蓝桥杯国赛更多档的部分分，以确保分数分布更为科学合理。", "description": "小洛正在学习三进制。他定义三进制数为每一位只包括 $0,1,2$ 三种数的**无穷长的**数字串 $a$。\n\n与一般的三进制数不同的是，小洛的三进制数从左往右书写。例如，在常规表述下，$4$ 的三进制表示为 $(0000\\ 0011)_3$，而在小洛的三进制数表示下为 $(1100\\ 0000 \\cdots)_3$。\n\n小洛特别喜欢从 $0$ 开始计数，因此他规定三进制的第 $0$ 位为最左侧的那一数位。\n\n下表给出了小洛的三进制数表示下，数字 $37$ 的最低的 $8$ 位数位以及位权：\n\n| 三进制数表示 | $1$ | $0$ | $1$ | $1$ | $0$ | $0$ | $0$ | $0$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| 位数 | $0$ | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ |\n| 位权 | $3^0$ | $3^1$ | $3^2$ | $3^3$ | $3^4$ | $3^5$ | $3^6$ | $3^7$ |\n\n现在小洛有一个十进制正整数 $V$（显然，需要将其转化为小洛的三进制数表示），并且给定三种操作：\n\n- 操作一，将第 $i$ 位上的数进行操作：$0$ 变为 $1$，$1$ 变为 $2$，$2$ 变为 $0$。\n- 操作二，将第 $i$ 位上的数进行操作：$0$ 变为 $2$，$1$ 变为 $0$，$2$ 变为 $1$。\n- 操作三，将第 $i$ 位上的数进行操作：$1$ 变为 $2$，$2$ 变为 $1$，$0$ 不变。\n\n小洛一共要进行 $q$ 次操作。每次操作后，小洛需要得到三进制串代表的数值。请你告诉他。\n\n如果对题意有不清晰之处，请查看样例解释。", "inputFormat": "第一行输入两个正整数 $V,q$。\n\n接下来 $q$ 行，每行一个操作，形如 `op i`。\n\n请注意，你需要将 $V$ 转化为三进制串并作为初始的三进制串。", "outputFormat": "输出共 $q$ 行，第 $i$ 行表示第 $i$ 个操作后的答案。", "hint": "**【样例解释】**\n\n初始时，$V=4$，转化为小洛的三进制数为 $\\texttt{1100 0000} \\cdots$，接下来进行了 $3$ 次操作：\n\n- 将第 $1$ 位上的数位从 $1$ 变为 $2$，三进制数变为 $\\texttt{1200 0000} \\cdots$，十进制下为 $7$。\n- 将第 $0$ 位上的数位从 $1$ 变为 $0$，三进制数变为 $\\texttt{0200 0000} \\cdots$，十进制下为 $6$。\n- 将第 $2$ 位上的数位从 $0$ 变为 $1$，三进制数变为 $\\texttt{0210 0000} \\cdots$，十进制下为 $15$。\n\n**【数据范围】**\n\n- 对于 $30\\%$ 的数据，保证 $V\\leq 10^9$。\n- 对于另外 $30\\%$ 的数据，保证不含操作三。\n\n对于所有数据，保证 $0\\leq V\\leq 10^{18}$，$1\\leq q\\leq 10^5$，任意获取到的答案不超过 $2\\times 10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P10511", "type": "P", "difficulty": 4, "samples": [["5 3 15\n1 1 5\n2 2 7\n3 5 8\n1 1\n1 2\n1 3\n1 4\n1 5\n2 2\n2 3\n2 4\n2 5\n3 3\n3 4\n3 5\n4 4\n4 5\n5 5", "0\n4\n14\n24\n34\n0\n1\n2\n3\n0\n0\n0\n0\n0\n0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "二分", "洛谷原创", "O2优化", "前缀和", "洛谷月赛"], "title": "方差", "background": "定义一个长度为 $n$ 的序列 $a$ 的方差为：\n\n$$s^2=\\frac{1}{n} \\sum_{i=1}^n (a_i-\\overline{a})^2$$\n\n其中：$\\sum$ 为累加求和符号，例如 $\\sum_{i=1}^5 a_i=a_1+a_2+a_3+a_4+a_5$。$\\overline{a}$ 为序列 $a$ 的平均数。\n\n例如对于序列 $\\{3,5,1,4,2\\}$，$\\overline{a}=3$，此时 $s^2=\\frac{1}{n} \\sum_{i=1}^n (a_i-\\overline{a})^2=\\frac{1}{5}[(3-3)^2+(5-3)^2+(1-3)^2+(4-3)^2+(2-3)^2]=2$。", "description": "小 S 认为数学很简单，于是小 R 想要考考她。\n\n小 R 给了小 S 一个序列 $a$，这个序列由 $m$ 段构成，第 $i$ 段被表示为 `l r b`，表示 $a_l,a_{l+1},\\ldots,a_r$ 为 $b$，保证给出的任意两个区间不相交。\n\n现在，小 R 有 $q$ 个问题。形如 `l r`，想让你查询区间 $[l,r]$ 的方差 $s^2$（需要注意：$l$ 可能等于 $r$，此时该段方差为 $0$）。\n\n由于这个数字可能是个小数，小 R 不方便对答案，所以他想要小 S 求出 $(r-l+1)^2\\cdot s^2\\bmod 998244353$。可以证明 $(r-l+1)^2\\cdot s^2$ 一定是整数。\n\n作为小 S 的好朋友，你能帮帮她吗？", "inputFormat": "第一行三个正整数 $n,m,q$，表示序列的长度，序列的段数和问题的个数。\n\n接下来 $m$ 行，每行三个正整数，分别表示 $l_i,r_i,b_i$。\n\n接下来 $q$ 行，每行两个正整数 $x,y$。你需要回答 $[x,y]$ 的方差。", "outputFormat": "对于每个询问，输出一行一个整数，表示你的答案。", "hint": "**【样例解释】**\n\n序列 $a$ 为 $\\{ 5, 7, 8, 8, 8 \\}$。对于第 $12$ 组询问，区间 $[3, 5]$ 的平均数 $\\overline{a} = 8$，方差 $s^2 = \\frac{1}{3} [(8 - 8)^2 + (8 - 8)^2 + (8 - 8)^2] = 0$。\n\n**【数据范围】**\n\n- 对于 $20\\%$ 的数据，保证 $n,q\\leq 100$。\n- 对于 $50\\%$ 的数据，保证 $n\\leq 10^6$，$m\\leq 10^3$。\n- 对于另外 $10\\%$ 的数据，保证 $r_i-l_i\\leq 1000$，$q \\leq 10^4$。\n- 对于另外 $10\\%$ 的数据，保证 $m\\leq 10^3$。\n\n对于所有数据，保证：\n- $1\\leq l_i\\leq r_i\\leq n\\leq 10^{18}$，$1\\leq m\\leq \\min(n,2\\times 10^5)$，$1\\leq q\\leq 2\\times 10^5$，$1\\leq x\\leq y\\leq n$，$1\\leq b_i\\leq 10^{18}$。\n- 数据保证对于任意 $i<j$，$l_i<l_j$，且 $[l_i,r_i]$ 与 $[l_j,r_j]$ 不存在交集，即 $[l_i,r_i]\\cap[l_j,r_j]=\\varnothing$。\n- 数据保证，若将所有的 $[l_i,r_i]$ 取并集，则其覆盖了 $[1,n]$ 上所有的正整数。即：$\\bigcup_{i=1}^n[l_i,r_i] \\cap \\Z=[1,n] \\cap \\Z$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "方差", "background": "定义一个长度为 $n$ 的序列 $a$ 的方差为：\n\n$$s^2=\\frac{1}{n} \\sum_{i=1}^n (a_i-\\overline{a})^2$$\n\n其中：$\\sum$ 为累加求和符号，例如 $\\sum_{i=1}^5 a_i=a_1+a_2+a_3+a_4+a_5$。$\\overline{a}$ 为序列 $a$ 的平均数。\n\n例如对于序列 $\\{3,5,1,4,2\\}$，$\\overline{a}=3$，此时 $s^2=\\frac{1}{n} \\sum_{i=1}^n (a_i-\\overline{a})^2=\\frac{1}{5}[(3-3)^2+(5-3)^2+(1-3)^2+(4-3)^2+(2-3)^2]=2$。", "description": "小 S 认为数学很简单，于是小 R 想要考考她。\n\n小 R 给了小 S 一个序列 $a$，这个序列由 $m$ 段构成，第 $i$ 段被表示为 `l r b`，表示 $a_l,a_{l+1},\\ldots,a_r$ 为 $b$，保证给出的任意两个区间不相交。\n\n现在，小 R 有 $q$ 个问题。形如 `l r`，想让你查询区间 $[l,r]$ 的方差 $s^2$（需要注意：$l$ 可能等于 $r$，此时该段方差为 $0$）。\n\n由于这个数字可能是个小数，小 R 不方便对答案，所以他想要小 S 求出 $(r-l+1)^2\\cdot s^2\\bmod 998244353$。可以证明 $(r-l+1)^2\\cdot s^2$ 一定是整数。\n\n作为小 S 的好朋友，你能帮帮她吗？", "inputFormat": "第一行三个正整数 $n,m,q$，表示序列的长度，序列的段数和问题的个数。\n\n接下来 $m$ 行，每行三个正整数，分别表示 $l_i,r_i,b_i$。\n\n接下来 $q$ 行，每行两个正整数 $x,y$。你需要回答 $[x,y]$ 的方差。", "outputFormat": "对于每个询问，输出一行一个整数，表示你的答案。", "hint": "**【样例解释】**\n\n序列 $a$ 为 $\\{ 5, 7, 8, 8, 8 \\}$。对于第 $12$ 组询问，区间 $[3, 5]$ 的平均数 $\\overline{a} = 8$，方差 $s^2 = \\frac{1}{3} [(8 - 8)^2 + (8 - 8)^2 + (8 - 8)^2] = 0$。\n\n**【数据范围】**\n\n- 对于 $20\\%$ 的数据，保证 $n,q\\leq 100$。\n- 对于 $50\\%$ 的数据，保证 $n\\leq 10^6$，$m\\leq 10^3$。\n- 对于另外 $10\\%$ 的数据，保证 $r_i-l_i\\leq 1000$，$q \\leq 10^4$。\n- 对于另外 $10\\%$ 的数据，保证 $m\\leq 10^3$。\n\n对于所有数据，保证：\n- $1\\leq l_i\\leq r_i\\leq n\\leq 10^{18}$，$1\\leq m\\leq \\min(n,2\\times 10^5)$，$1\\leq q\\leq 2\\times 10^5$，$1\\leq x\\leq y\\leq n$，$1\\leq b_i\\leq 10^{18}$。\n- 数据保证对于任意 $i<j$，$l_i<l_j$，且 $[l_i,r_i]$ 与 $[l_j,r_j]$ 不存在交集，即 $[l_i,r_i]\\cap[l_j,r_j]=\\varnothing$。\n- 数据保证，若将所有的 $[l_i,r_i]$ 取并集，则其覆盖了 $[1,n]$ 上所有的正整数。即：$\\bigcup_{i=1}^n[l_i,r_i] \\cap \\Z=[1,n] \\cap \\Z$。", "locale": "zh-CN"}}}
{"pid": "P10512", "type": "P", "difficulty": 4, "samples": [["5 2\n2 1 2 3 1", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "洛谷原创", "O2优化", "位运算", "洛谷月赛"], "title": "序列合并", "background": "", "description": "给定一个长度为 $n$ 的非负整数序列 $\\{a_n\\}$，你可以进行 $k$ 次操作，每次操作你选择两个相邻的数，把它们合并成它们的按位或。\n\n形式化地，一次操作中，你选择一个下标 $i$（$1 \\le i < n$），然后把原序列变成 $\\{a_1,a_2,\\cdots,a_i \\operatorname{or} a_{i+1},a_{i+2},\\cdots,a_n\\}$。\n\n求 $k$ 次操作后所有数按位与的最大值。", "inputFormat": "第一行包含两个正整数 $n,k$。\n\n第二行包含 $n$ 个非负整数，其中第 $i$ 个非负整数为 $a_i$。", "outputFormat": "输出一行，包含一个正整数，代表答案。", "hint": "**【样例解释】**\n\n一种合法的方案：\n\n- 第一次操作，选择第一个数和第二个数合并，序列变为 $\\{3,2,3,1\\}$。\n- 第二次操作，选择第三个数和第四个数合并，序列变为 $\\{3,2,3\\}$。\n\n最终所有数的按位与为 $2$。可以证明不存在更优的方案。\n\n**【数据范围】**\n\n- 对于 $25\\%$ 的数据，$n \\le 20$。\n- 对于另外 $25\\%$ 的数据，$k=n-2$。\n\n对于所有数据，保证 $1 \\le k<n \\le 2 \\times 10^5$，$0 \\le a_i < 2^{30}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "序列合并", "background": "", "description": "给定一个长度为 $n$ 的非负整数序列 $\\{a_n\\}$，你可以进行 $k$ 次操作，每次操作你选择两个相邻的数，把它们合并成它们的按位或。\n\n形式化地，一次操作中，你选择一个下标 $i$（$1 \\le i < n$），然后把原序列变成 $\\{a_1,a_2,\\cdots,a_i \\operatorname{or} a_{i+1},a_{i+2},\\cdots,a_n\\}$。\n\n求 $k$ 次操作后所有数按位与的最大值。", "inputFormat": "第一行包含两个正整数 $n,k$。\n\n第二行包含 $n$ 个非负整数，其中第 $i$ 个非负整数为 $a_i$。", "outputFormat": "输出一行，包含一个正整数，代表答案。", "hint": "**【样例解释】**\n\n一种合法的方案：\n\n- 第一次操作，选择第一个数和第二个数合并，序列变为 $\\{3,2,3,1\\}$。\n- 第二次操作，选择第三个数和第四个数合并，序列变为 $\\{3,2,3\\}$。\n\n最终所有数的按位与为 $2$。可以证明不存在更优的方案。\n\n**【数据范围】**\n\n- 对于 $25\\%$ 的数据，$n \\le 20$。\n- 对于另外 $25\\%$ 的数据，$k=n-2$。\n\n对于所有数据，保证 $1 \\le k<n \\le 2 \\times 10^5$，$0 \\le a_i < 2^{30}$。", "locale": "zh-CN"}}}
{"pid": "P10513", "type": "P", "difficulty": 5, "samples": [["6\n(()())\n5\n2 2 3\n1 1 3\n2 2 3\n2 4 6\n2 3 6", "1\n0\n1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "洛谷原创", "O2优化", "洛谷月赛"], "title": "括号", "background": "", "description": "圆给了你一个长度为 $n$ 的字符串 $S$，$S$ 仅由 ```(``` 和 ```)``` 构成。\n\n她会对其做 $m$ 次操作，操作有两种类型：\n\n1. ```1 l r```，她会翻转 $l$ 到 $r$ 的括号，即 ```(``` 变 ```)```，```)``` 变 ```(```。\n1. ```2 l r```，她想知道区间 $\\left[ l,r\\right]$ 中最长合法括号子序列的长度除以 $2$ 的答案。\n\n\n圆认为以下的括号序列是合法的：\n\n1. 空序列是一个合法序列。\n\n1. 如果 ```A``` 是一个合法序列，则 ```(A)```  也是一个合法序列。\n\n1. 如果 ```A``` 和 ```B``` 都是合法序列，则 ```AB``` 也是一个合法序列。\n\n圆认为，序列 $a$ 的子序列是满足 $1\\le i_1<i_2<···<i_k \\le n$ 的序列 $[a_{i_1},a_{i_2},...a_{i_k}]$。\n\n由于操作太多了，她算不过来，请你帮帮她吧。\n", "inputFormat": "第一行一个整数 $n$。\n\n第二行一个长度为 $n$ 的字符串 $S$，保证仅由 ```(``` 和 ```)``` 构成 。\n\n第三行一行一个整数 $m$。\n\n接下来 $m$ 行，每行三个数 $op$，$l$，$r$，对应上面的两种操作。", "outputFormat": "对于每一个 $op=2$ 的操作，输出一行一个整数，表示答案。", "hint": "**【样例解释】**\n\n- 第一次截取的字符串是 ```()```，答案为 $1$。\n- 翻转后字符串变为 ```))(())```。\n- 第二次截取的字符串是 ```)(```，答案为 $0$。\n- 第三次截取的字符串是 ```())```，答案为 $1$。\n- 第四次截取的字符串是 ```(())```，答案为 $2$。\n\n**【数据范围】**\n\n- 对于 $10\\%$ 的数据，$1 \\leq n,m \\leq 500$；\n- 对于 $20\\%$ 的数据，$1 \\leq n,m \\leq 5000$；\n- 对于 $40\\%$ 的数据，$1 \\leq n,m \\leq 2\\times 10^5$；\n- 另有 $10\\%$ 的数据，满足 $op=2$ 且数据随机生成；\n- 另有 $15\\%$ 的数据，满足 $op=2$ 但不保证数据随机生成；\n\n对于所有数据，保证 $1\\le n \\le 5\\times 10^5$，$1\\le m \\le 5 \\times 10^5$，$1 \\le l \\le r \\le n$，$op \\in \\{1,2\\}$。数据有梯度。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "括号", "background": "", "description": "圆给了你一个长度为 $n$ 的字符串 $S$，$S$ 仅由 ```(``` 和 ```)``` 构成。\n\n她会对其做 $m$ 次操作，操作有两种类型：\n\n1. ```1 l r```，她会翻转 $l$ 到 $r$ 的括号，即 ```(``` 变 ```)```，```)``` 变 ```(```。\n1. ```2 l r```，她想知道区间 $\\left[ l,r\\right]$ 中最长合法括号子序列的长度除以 $2$ 的答案。\n\n\n圆认为以下的括号序列是合法的：\n\n1. 空序列是一个合法序列。\n\n1. 如果 ```A``` 是一个合法序列，则 ```(A)```  也是一个合法序列。\n\n1. 如果 ```A``` 和 ```B``` 都是合法序列，则 ```AB``` 也是一个合法序列。\n\n圆认为，序列 $a$ 的子序列是满足 $1\\le i_1<i_2<···<i_k \\le n$ 的序列 $[a_{i_1},a_{i_2},...a_{i_k}]$。\n\n由于操作太多了，她算不过来，请你帮帮她吧。\n", "inputFormat": "第一行一个整数 $n$。\n\n第二行一个长度为 $n$ 的字符串 $S$，保证仅由 ```(``` 和 ```)``` 构成 。\n\n第三行一行一个整数 $m$。\n\n接下来 $m$ 行，每行三个数 $op$，$l$，$r$，对应上面的两种操作。", "outputFormat": "对于每一个 $op=2$ 的操作，输出一行一个整数，表示答案。", "hint": "**【样例解释】**\n\n- 第一次截取的字符串是 ```()```，答案为 $1$。\n- 翻转后字符串变为 ```))(())```。\n- 第二次截取的字符串是 ```)(```，答案为 $0$。\n- 第三次截取的字符串是 ```())```，答案为 $1$。\n- 第四次截取的字符串是 ```(())```，答案为 $2$。\n\n**【数据范围】**\n\n- 对于 $10\\%$ 的数据，$1 \\leq n,m \\leq 500$；\n- 对于 $20\\%$ 的数据，$1 \\leq n,m \\leq 5000$；\n- 对于 $40\\%$ 的数据，$1 \\leq n,m \\leq 2\\times 10^5$；\n- 另有 $10\\%$ 的数据，满足 $op=2$ 且数据随机生成；\n- 另有 $15\\%$ 的数据，满足 $op=2$ 但不保证数据随机生成；\n\n对于所有数据，保证 $1\\le n \\le 5\\times 10^5$，$1\\le m \\le 5 \\times 10^5$，$1 \\le l \\le r \\le n$，$op \\in \\{1,2\\}$。数据有梯度。", "locale": "zh-CN"}}}
{"pid": "P10514", "type": "P", "difficulty": 4, "samples": [["5 5 2\n1 2 1 2 2", "793364682"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "O2优化", "概率论", "洛谷月赛"], "title": "考试", "background": "人生有梦，各自精彩。", "description": "有 $n$ 名同学去参加考试，考试有 $m$ 道题。\n\n每个学生的实力是相同的，但是每道题的难度可能不同。第 $i$ 道题会有随机的 $a_i$ 名同学做错。\n\n考试结束后，随机选出 $k$ 名同学，求出这些同学全部做对的概率。答案对 $998244353$ 取模。", "inputFormat": "第一行三个整数 $n,m,k$。\n\n第二行 $m$ 个整数，第 $i$ 个数表示 $a_i$。", "outputFormat": "一个整数，表示答案取模后的结果。", "hint": "**【样例解释】**\n\n随机选出 $2$ 名同学全部做对的概率为 $\\frac{243}{25000}$，对 $998244353$ 取模后答案为 $793364682$。\n\n可以证明答案一定为有理数。若不了解有理数取模，可以参照[【模板】有理数取余](https://www.luogu.com.cn/problem/P2613)。\n\n**【数据范围】**\n\n- 对于 $30\\%$ 的数据，$1\\leq n,m \\leq 10$；\n- 另外有 $10\\%$ 的数据，$k=0$；\n- 另外有 $20\\%$ 的数据，$1 \\leq n \\leq 1000$，$1\\leq m \\leq 10^5$；\n\n对于所有数据，保证 $1\\leq n,m\\leq 10^5$，$0\\leq k,a_i\\leq n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "考试", "background": "人生有梦，各自精彩。", "description": "有 $n$ 名同学去参加考试，考试有 $m$ 道题。\n\n每个学生的实力是相同的，但是每道题的难度可能不同。第 $i$ 道题会有随机的 $a_i$ 名同学做错。\n\n考试结束后，随机选出 $k$ 名同学，求出这些同学全部做对的概率。答案对 $998244353$ 取模。", "inputFormat": "第一行三个整数 $n,m,k$。\n\n第二行 $m$ 个整数，第 $i$ 个数表示 $a_i$。", "outputFormat": "一个整数，表示答案取模后的结果。", "hint": "**【样例解释】**\n\n随机选出 $2$ 名同学全部做对的概率为 $\\frac{243}{25000}$，对 $998244353$ 取模后答案为 $793364682$。\n\n可以证明答案一定为有理数。若不了解有理数取模，可以参照[【模板】有理数取余](https://www.luogu.com.cn/problem/P2613)。\n\n**【数据范围】**\n\n- 对于 $30\\%$ 的数据，$1\\leq n,m \\leq 10$；\n- 另外有 $10\\%$ 的数据，$k=0$；\n- 另外有 $20\\%$ 的数据，$1 \\leq n \\leq 1000$，$1\\leq m \\leq 10^5$；\n\n对于所有数据，保证 $1\\leq n,m\\leq 10^5$，$0\\leq k,a_i\\leq n$。", "locale": "zh-CN"}}}
{"pid": "P10515", "type": "P", "difficulty": 5, "samples": [["6\n5 2\n11 10\n17 12\n23 8\n31 12\n9999901 114514", "4\n2\n4\n11\n30\n16260"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["原根", "洛谷原创", "O2优化", "洛谷月赛"], "title": "转圈", "background": "", "description": "小 $\\delta$ 喜欢转圈圈。\n\n他有一个圈，被均匀分成了 $n$ 个格子，神奇的是，$n$ 是一个质数。第 $i$ 个格子上写着一个数 $i \\times m$，他现在站在第一个格子上。\n\n接下来他会看看脚下踩着的数是多少，然后向前走这么多格。他会一直反复这么做。\n\n求最终被小 $\\delta$ 踩到过的格子的数量。由于小 $\\delta$ 有很多圈圈，所以他会问你很多次。", "inputFormat": "第一行包含一个正整数 $T$，代表询问次数。\n\n对于每组询问，输入一行两个正整数 $n,m$。", "outputFormat": "对于每次询问，输出一行一个正整数，代表被踩到的格子的数量。", "hint": "**【样例解释】**\n\n以第一次询问为例，小 $\\delta$ 依次经过的格子编号为 $1 \\to 3 \\to 4 \\to 2 \\to 1 \\to \\cdots$，因此被踩到过的格子个数为 $4$。\n\n**【数据范围】**\n\n- 对于 $20\\%$ 的数据，$n \\le 10^3$，$T \\le 2 \\times 10^3$。\n- 对于另外 $40\\%$ 的数据，$T \\le 3 \\times 10^3$。\n- 对于另外 $40\\%$ 的数据，无特殊性质。\n\n对于所有数据，$1 \\le m < n \\le 10^7$，$1 \\le T \\le 4 \\times 10^5$。保证 $n$ 是质数。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "转圈", "background": "", "description": "小 $\\delta$ 喜欢转圈圈。\n\n他有一个圈，被均匀分成了 $n$ 个格子，神奇的是，$n$ 是一个质数。第 $i$ 个格子上写着一个数 $i \\times m$，他现在站在第一个格子上。\n\n接下来他会看看脚下踩着的数是多少，然后向前走这么多格。他会一直反复这么做。\n\n求最终被小 $\\delta$ 踩到过的格子的数量。由于小 $\\delta$ 有很多圈圈，所以他会问你很多次。", "inputFormat": "第一行包含一个正整数 $T$，代表询问次数。\n\n对于每组询问，输入一行两个正整数 $n,m$。", "outputFormat": "对于每次询问，输出一行一个正整数，代表被踩到的格子的数量。", "hint": "**【样例解释】**\n\n以第一次询问为例，小 $\\delta$ 依次经过的格子编号为 $1 \\to 3 \\to 4 \\to 2 \\to 1 \\to \\cdots$，因此被踩到过的格子个数为 $4$。\n\n**【数据范围】**\n\n- 对于 $20\\%$ 的数据，$n \\le 10^3$，$T \\le 2 \\times 10^3$。\n- 对于另外 $40\\%$ 的数据，$T \\le 3 \\times 10^3$。\n- 对于另外 $40\\%$ 的数据，无特殊性质。\n\n对于所有数据，$1 \\le m < n \\le 10^7$，$1 \\le T \\le 4 \\times 10^5$。保证 $n$ 是质数。\n", "locale": "zh-CN"}}}
{"pid": "P10516", "type": "P", "difficulty": 5, "samples": [["5 5\n23 4 3 3 7\n54 29 7 1 2\n1 1 5 114 1\n2 2 7 9\n3 1 5\n3 1 2\n3 3 4", "122\n93\n18"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "洛谷原创", "O2优化", "洛谷月赛"], "title": "数据结构", "background": "小 M 很喜欢数据结构。但是很遗憾，他没有进入省队。\n\n人生有梦，各自精彩。", "description": "给定两个长度为 $n$ 的序列 $a_i$ 和 $b_i$。有以下三种操作：\n\n1. 给定区间 $[l,r]$ 以及参数 $k,t$，把区间内满足 $a_i\\times b_i\\leq k$ 的位置的 $a_i$ 和 $b_i$ 分别加上 $t$。\n2. 给定 $i$ 和 $x,y$，将 $a_i$ 改为 $x$，$b_i$ 改为 $y$。\n3. 查询区间内每个位置 $a_i+b_i$ 的和。", "inputFormat": "第一行包含两个整数 $n,m$，分别表示该数列数字的个数和操作的总个数。\n\n第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示 $a_i$。\n\n第三行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示 $b_i$。\n\n接下来 $m$ 行每行包含 $3$ 到 $5$ 个整数，表示一个操作，具体如下：\n\n1. `1 l r k t`：将区间 $[l,r]$ 进行一操作。\n2. `2 i x y`：将 $a_i$ 改为 $x$，$b_i$ 改为 $y$。\n3. `3 l r`：输出区间 $[l,r]$ 内每个数的和。\n", "outputFormat": "若干行，每行表示操作 $3$ 的答案。", "hint": "**【样例解释】**\n\n第一次修改后，序列 $a_i$ 为：$\\left\\{23,4,4,4,8\\right\\}$；序列 $b_i$ 为 $\\left\\{54,29,8,2,3\\right\\}$。\n\n第二次修改后，序列 $a_i$ 为：$\\left\\{23,7,4,4,8\\right\\}$；序列 $b_i$ 为 $\\left\\{54,9,8,2,3\\right\\}$。\n\n**【数据范围】**\n\n- 对于 $5\\%$ 的数据，$n,m\\le 5$；\n- 对于 $10\\%$ 的数据，$n,m\\leq 100$；\n- 对于 $25\\%$ 的数据，$n,m\\leq 5000$；\n- 对于另外 $5\\%$ 的数据，没有前两种操作；\n- 对于另外 $10\\%$ 的数据，没有第一种操作；\n- 对于另外 $20\\%$ 的数据，没有第二种操作；\n\n对于所有数据，$1\\leq n,m\\leq 10^5$，$0\\leq a_i,b_i,k,t,x,y\\leq10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "数据结构", "background": "小 M 很喜欢数据结构。但是很遗憾，他没有进入省队。\n\n人生有梦，各自精彩。", "description": "给定两个长度为 $n$ 的序列 $a_i$ 和 $b_i$。有以下三种操作：\n\n1. 给定区间 $[l,r]$ 以及参数 $k,t$，把区间内满足 $a_i\\times b_i\\leq k$ 的位置的 $a_i$ 和 $b_i$ 分别加上 $t$。\n2. 给定 $i$ 和 $x,y$，将 $a_i$ 改为 $x$，$b_i$ 改为 $y$。\n3. 查询区间内每个位置 $a_i+b_i$ 的和。", "inputFormat": "第一行包含两个整数 $n,m$，分别表示该数列数字的个数和操作的总个数。\n\n第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示 $a_i$。\n\n第三行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示 $b_i$。\n\n接下来 $m$ 行每行包含 $3$ 到 $5$ 个整数，表示一个操作，具体如下：\n\n1. `1 l r k t`：将区间 $[l,r]$ 进行一操作。\n2. `2 i x y`：将 $a_i$ 改为 $x$，$b_i$ 改为 $y$。\n3. `3 l r`：输出区间 $[l,r]$ 内每个数的和。\n", "outputFormat": "若干行，每行表示操作 $3$ 的答案。", "hint": "**【样例解释】**\n\n第一次修改后，序列 $a_i$ 为：$\\left\\{23,4,4,4,8\\right\\}$；序列 $b_i$ 为 $\\left\\{54,29,8,2,3\\right\\}$。\n\n第二次修改后，序列 $a_i$ 为：$\\left\\{23,7,4,4,8\\right\\}$；序列 $b_i$ 为 $\\left\\{54,9,8,2,3\\right\\}$。\n\n**【数据范围】**\n\n- 对于 $5\\%$ 的数据，$n,m\\le 5$；\n- 对于 $10\\%$ 的数据，$n,m\\leq 100$；\n- 对于 $25\\%$ 的数据，$n,m\\leq 5000$；\n- 对于另外 $5\\%$ 的数据，没有前两种操作；\n- 对于另外 $10\\%$ 的数据，没有第一种操作；\n- 对于另外 $20\\%$ 的数据，没有第二种操作；\n\n对于所有数据，$1\\leq n,m\\leq 10^5$，$0\\leq a_i,b_i,k,t,x,y\\leq10^5$。", "locale": "zh-CN"}}}
{"pid": "P10517", "type": "P", "difficulty": 6, "samples": [["4 4 6\n1 2\n2 3\n3 1\n3 4\n1\n3\n3\n4\n4\n1", "3\n2\n3\n1\n3\n4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "O2优化", "洛谷月赛", "圆方树"], "title": "国土规划", "background": "", "description": "一个国家的领土中，有 $n$ 座城市和 $m$ 条道路。这 $m$ 条道路将 $n$ 座城市连通，即任意两座城市存在道路直接或间接可达。两座城市之间可能有多条道路，但不存在一条道路两端连通同一座城市。\n\n该国家要选定一些城市，重点发展。具体而言，每个城市有一个重要值 $a_i$，其中 $a_i=0$ 表示城市不需要重点发展，如果 $a_i=1$ 表示城市需要重点发展。初始时所有 $a_i=0$。\n\n该国家有 $q$ 次规划，每次规划会选定一个城市 $x$，令 $a_x \\gets 1-a_x$。\n\n每次规划后，作为首席规划师的你要求出这样的城市 $p$ 的数量，使得 $a_p=0$，且城市 $p$ 消失（连带与城市 $p$ 直接相连的道路一起消失）后，任意满足 $a_u=a_v=1$ 的两个城市 $u,v$ 均存在道路直接或间接可达。\n\n需要注意，规划只是在纸面上假想的，并不会真的删去任何城市。", "inputFormat": "输入的第一行包含由空格隔开的三个正整数 $n,m,q$。\n\n接下来的 $m$ 行，每行包含两个正整数 $u,v$，描述一条连接 $u,v$ 两座城市的双向道路。\n\n接下来的 $q$ 行，每行包含一个正整数 $x$，描述一次规划。", "outputFormat": "输出 $q$ 行，每行包含一个非负整数，代表每次修改后问题的答案。", "hint": "**【样例解释】**\n\n以第四次规划为例，此时需要重点发展的城市为 $1$ 和 $4$，那么 $a_p=0$ 的城市只有 $2$ 和 $3$。如果城市 $2$ 消失，那么存在路径 $1-3-4$。如果城市 $3$ 消失，那么 $1$ 和 $4$ 互相不可到达。所以满足条件的城市只有 $2$，答案为 $1$。\n\n**【数据范围】**\n\n- 对于 $15\\%$ 的数据，$n,q \\le 300$，$m \\le 500$。\n- 对于另外 $15\\%$ 的数据，$m=n-1$，且对于所有道路，$v=u+1$。\n- 对于另外 $20\\%$ 的数据，$m=n-1$。\n\n对于所有数据，$2 \\le n \\le 10^5$，$n-1\\le m \\le 2 \\times 10^5$，$1 \\le q \\le 2 \\times 10^5$，$1 \\le u,v,x \\le n$，$u \\neq v$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "国土规划", "background": "", "description": "一个国家的领土中，有 $n$ 座城市和 $m$ 条道路。这 $m$ 条道路将 $n$ 座城市连通，即任意两座城市存在道路直接或间接可达。两座城市之间可能有多条道路，但不存在一条道路两端连通同一座城市。\n\n该国家要选定一些城市，重点发展。具体而言，每个城市有一个重要值 $a_i$，其中 $a_i=0$ 表示城市不需要重点发展，如果 $a_i=1$ 表示城市需要重点发展。初始时所有 $a_i=0$。\n\n该国家有 $q$ 次规划，每次规划会选定一个城市 $x$，令 $a_x \\gets 1-a_x$。\n\n每次规划后，作为首席规划师的你要求出这样的城市 $p$ 的数量，使得 $a_p=0$，且城市 $p$ 消失（连带与城市 $p$ 直接相连的道路一起消失）后，任意满足 $a_u=a_v=1$ 的两个城市 $u,v$ 均存在道路直接或间接可达。\n\n需要注意，规划只是在纸面上假想的，并不会真的删去任何城市。", "inputFormat": "输入的第一行包含由空格隔开的三个正整数 $n,m,q$。\n\n接下来的 $m$ 行，每行包含两个正整数 $u,v$，描述一条连接 $u,v$ 两座城市的双向道路。\n\n接下来的 $q$ 行，每行包含一个正整数 $x$，描述一次规划。", "outputFormat": "输出 $q$ 行，每行包含一个非负整数，代表每次修改后问题的答案。", "hint": "**【样例解释】**\n\n以第四次规划为例，此时需要重点发展的城市为 $1$ 和 $4$，那么 $a_p=0$ 的城市只有 $2$ 和 $3$。如果城市 $2$ 消失，那么存在路径 $1-3-4$。如果城市 $3$ 消失，那么 $1$ 和 $4$ 互相不可到达。所以满足条件的城市只有 $2$，答案为 $1$。\n\n**【数据范围】**\n\n- 对于 $15\\%$ 的数据，$n,q \\le 300$，$m \\le 500$。\n- 对于另外 $15\\%$ 的数据，$m=n-1$，且对于所有道路，$v=u+1$。\n- 对于另外 $20\\%$ 的数据，$m=n-1$。\n\n对于所有数据，$2 \\le n \\le 10^5$，$n-1\\le m \\le 2 \\times 10^5$，$1 \\le q \\le 2 \\times 10^5$，$1 \\le u,v,x \\le n$，$u \\neq v$。", "locale": "zh-CN"}}}
{"pid": "P10518", "type": "P", "difficulty": 1, "samples": [["27 2 15 95\n", "344\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2024", "O2优化", "高校校赛"], "title": "[XJTUPC 2024] 交小西的礼物", "background": "小西给参加这场比赛的大家都准备了精美的礼物！\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qjzqxmt1.png)", "description": "小西准备给 $a$ 名志愿者，$b$ 支单挑队，$c$ 支双人队，$d$ 支三人队的**每个人**恰好发一份奖品，她想知道一共要发几份奖品？\n", "inputFormat": "输入数据共一行四个整数 $a,b,c,d$ ($0 \\leq a, b, c, d \\leq 200$)，含义如上所述。", "outputFormat": "输出数据共一行一个整数，表示总共要发的奖品数。", "hint": "聪慧美丽善良的交小西想提升大家的参赛体验，她提示你：ABC 题都是简单题，**后面的题目是并不保证难度递增的**。当你在某一道题卡住时，不妨看看排行榜上其他队伍在做什么题，一般来说通过人数较多的题目会更简单哦～", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[XJTUPC 2024] 交小西的礼物", "background": "小西给参加这场比赛的大家都准备了精美的礼物！\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qjzqxmt1.png)", "description": "小西准备给 $a$ 名志愿者，$b$ 支单挑队，$c$ 支双人队，$d$ 支三人队的**每个人**恰好发一份奖品，她想知道一共要发几份奖品？\n", "inputFormat": "输入数据共一行四个整数 $a,b,c,d$ ($0 \\leq a, b, c, d \\leq 200$)，含义如上所述。", "outputFormat": "输出数据共一行一个整数，表示总共要发的奖品数。", "hint": "聪慧美丽善良的交小西想提升大家的参赛体验，她提示你：ABC 题都是简单题，**后面的题目是并不保证难度递增的**。当你在某一道题卡住时，不妨看看排行榜上其他队伍在做什么题，一般来说通过人数较多的题目会更简单哦～", "locale": "zh-CN"}}}
{"pid": "P10519", "type": "P", "difficulty": 2, "samples": [["-1 0\n11\n0.5\n", "2.0000000000\n"], ["-1 0\n10\n0.5\n", "0.0000000000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2024", "Special Judge", "O2优化", "高校校赛"], "title": "[XJTUPC 2024] 转呀转", "background": "乐奈：灯，你听我说\n\n乐奈：洗衣机好有趣的\n\n灯：诶……洗衣机……？\n\n乐奈：衣服一直转呀转，观察那个好有意思\n\n乐奈：灯也可以去试试\n\n灯：诶……？好的……！\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3mkfdq00.png)\n\n  \"一直转呀转好有意思！\"\n", "description": "rana 和 tomorin 在观察洗衣机里的衣服的时候，发现衣服做匀速圆周运动。她们知道衣服的初始位置，观察时间以及洗衣机转速，希望你能帮她们求出初始位置到观察结束时位置的位移长度。衣服可以看成质点。\n", "inputFormat": "输入共三行。\n\n第一行两个整数 $x,y$ ($-1000 \\leq x, y \\leq 1000$)，表示衣服的初始位置**在以洗衣机中心为坐标原点的平面直角坐标系下的**坐标，单位是单位长度。\n\n第二行一个实数 $t$ ($0 \\leq t \\leq 100$)，表示观察时间，单位是单位时间。\n\n第三行一个实数 $v$ ($0 \\leq v \\leq 100$)，表示洗衣机转速，单位是**圈**每单位时间。", "outputFormat": "输出仅一行。\n\n输出一个实数表示答案，与标准答案的绝对误差或相对误差不超过 $10^{-6}$ 的答案视为正确。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[XJTUPC 2024] 转呀转", "background": "乐奈：灯，你听我说\n\n乐奈：洗衣机好有趣的\n\n灯：诶……洗衣机……？\n\n乐奈：衣服一直转呀转，观察那个好有意思\n\n乐奈：灯也可以去试试\n\n灯：诶……？好的……！\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3mkfdq00.png)\n\n  \"一直转呀转好有意思！\"\n", "description": "rana 和 tomorin 在观察洗衣机里的衣服的时候，发现衣服做匀速圆周运动。她们知道衣服的初始位置，观察时间以及洗衣机转速，希望你能帮她们求出初始位置到观察结束时位置的位移长度。衣服可以看成质点。\n", "inputFormat": "输入共三行。\n\n第一行两个整数 $x,y$ ($-1000 \\leq x, y \\leq 1000$)，表示衣服的初始位置**在以洗衣机中心为坐标原点的平面直角坐标系下的**坐标，单位是单位长度。\n\n第二行一个实数 $t$ ($0 \\leq t \\leq 100$)，表示观察时间，单位是单位时间。\n\n第三行一个实数 $v$ ($0 \\leq v \\leq 100$)，表示洗衣机转速，单位是**圈**每单位时间。", "outputFormat": "输出仅一行。\n\n输出一个实数表示答案，与标准答案的绝对误差或相对误差不超过 $10^{-6}$ 的答案视为正确。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10520", "type": "P", "difficulty": 1, "samples": [["114 514\n", "314.000000 -346.410162"], ["0 0\n", "0.000000 0.000000"], ["1000000 -1000000\n", "0.000000 1732050.807569"], ["3 5\n", "4.000000 -1.732051"], ["-19 23\n", "2.000000 -36.373067"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2024", "Special Judge", "O2优化", "高校校赛"], "title": "[XJTUPC 2024] 榕树之心", "background": "你说的对，但是《榕树之心》是一款由 Corycle, HCCH, MCPlayer542, Veritas, wh 在游戏设计与开发课上研发的策略性多人对战游戏，游戏发生在一个热带雨林，在这里，你将扮演一棵榕树的「核心」，与其他榕树竞争养分和生存空间……\n\n", "description": "游戏地图由若干正六边形构成，玩家可以控制榕树核心从一个六边形的**中心**移动的另一个相邻六边形的**中心**从而加固树枝、清理害虫、长出新枝条或者摧毁其他榕树。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g6dpzmiq.png)\n\n平面的正六边形网格可以看做若干立方体堆叠出的立体图形的正等轴测图（如图），每个立方体的投影都是一个正六边形，于是立方体的空间坐标可以用来表示正六边形坐标。我们规定某一立方体中心位于原点，所有正方体中心坐标 $(x,y,z)$ 都满足 $x+y+z=0$，所以可以省略一维，用 $(x,y)$ 来描述其对应正六边形的中心。这种坐标系统叫做**纵向坐标**。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4s74ssjt.png)\n\n游戏使用**纵向坐标**描绘六边形的位置，为了让玩家直观地看到核心的位置，Veritas 需要将其转化为**平面直角坐标**以便在屏幕上显示，**请你帮助他将纵向坐标转换成平面直角坐标**。\n\n纵向坐标 $(x,y)$ 到平面直角坐标 $(x^\\prime,y^\\prime)$ 的转换公式为：\n\n$$x^{\\prime} = \\frac{1}{2} x + \\frac{1}{2} y$$\n\n$$y^{\\prime} = \\frac{\\sqrt{3}}{2} x - \\frac{\\sqrt{3}}{2} y $$\n\n", "inputFormat": "仅一行，有两个用空格隔开的整数 $x,y$，表示纵向坐标 $(x,y)$ ($-10^6\\le x\\le 10^6,-10^6\\le y\\le 10^6$)。", "outputFormat": "一行两个实数 $x^{\\prime}$ 和 $y^{\\prime}$，用空格隔开，表示转换得到的平面直角坐标 $(x^\\prime,y^\\prime)$。\n\n当你输出的两个实数与答案的相对误差或者绝对误差的较小者不超过 $10^{-6}$ 时视为正确。", "hint": "《榕树之心》游戏链接（线下参赛队伍赛时无法访问该链接）：[core-of-banyan.github.io](https://core-of-banyan.github.io/)。\n\n欢迎大家（在赛后）游玩。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[XJTUPC 2024] 榕树之心", "background": "你说的对，但是《榕树之心》是一款由 Corycle, HCCH, MCPlayer542, Veritas, wh 在游戏设计与开发课上研发的策略性多人对战游戏，游戏发生在一个热带雨林，在这里，你将扮演一棵榕树的「核心」，与其他榕树竞争养分和生存空间……\n\n", "description": "游戏地图由若干正六边形构成，玩家可以控制榕树核心从一个六边形的**中心**移动的另一个相邻六边形的**中心**从而加固树枝、清理害虫、长出新枝条或者摧毁其他榕树。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g6dpzmiq.png)\n\n平面的正六边形网格可以看做若干立方体堆叠出的立体图形的正等轴测图（如图），每个立方体的投影都是一个正六边形，于是立方体的空间坐标可以用来表示正六边形坐标。我们规定某一立方体中心位于原点，所有正方体中心坐标 $(x,y,z)$ 都满足 $x+y+z=0$，所以可以省略一维，用 $(x,y)$ 来描述其对应正六边形的中心。这种坐标系统叫做**纵向坐标**。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4s74ssjt.png)\n\n游戏使用**纵向坐标**描绘六边形的位置，为了让玩家直观地看到核心的位置，Veritas 需要将其转化为**平面直角坐标**以便在屏幕上显示，**请你帮助他将纵向坐标转换成平面直角坐标**。\n\n纵向坐标 $(x,y)$ 到平面直角坐标 $(x^\\prime,y^\\prime)$ 的转换公式为：\n\n$$x^{\\prime} = \\frac{1}{2} x + \\frac{1}{2} y$$\n\n$$y^{\\prime} = \\frac{\\sqrt{3}}{2} x - \\frac{\\sqrt{3}}{2} y $$\n\n", "inputFormat": "仅一行，有两个用空格隔开的整数 $x,y$，表示纵向坐标 $(x,y)$ ($-10^6\\le x\\le 10^6,-10^6\\le y\\le 10^6$)。", "outputFormat": "一行两个实数 $x^{\\prime}$ 和 $y^{\\prime}$，用空格隔开，表示转换得到的平面直角坐标 $(x^\\prime,y^\\prime)$。\n\n当你输出的两个实数与答案的相对误差或者绝对误差的较小者不超过 $10^{-6}$ 时视为正确。", "hint": "《榕树之心》游戏链接（线下参赛队伍赛时无法访问该链接）：[core-of-banyan.github.io](https://core-of-banyan.github.io/)。\n\n欢迎大家（在赛后）游玩。", "locale": "zh-CN"}}}
{"pid": "P10521", "type": "P", "difficulty": 2, "samples": [["5 5\n3 1\n2 3\n1 3\n2 4\n3 5\n", "2 3 0 3 3 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "Special Judge", "O2优化", "高校校赛"], "title": "[XJTUPC 2024] 瑟莉姆的宴会", "background": "欢迎来到瑟莉姆大人的享乐宴会！\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6kmpy10b.png)", "description": "宴会中一共有 $n$ 个访客，编号 $1\\sim n$。为了更好地控制影的力量，瑟莉姆要求有 $n-1$ 个访客都恰好受到另一个访客的支配，而剩下的那个人成为总支配者，支配其他 $n-1$ 名访客。访客间的**直接支配关系**构成了一棵有根树。\n\n对于这棵树来说，若结点 $a$ 的父结点是 $b$，那么称 $b$ 支配了 $a$，同时称 $b$ 是 $a$ 的**直接支配者**。同时，支配的关系具有**传递性**，即若 $a$ 支配 $b$，$b$ 支配 $c$，那么 $a$ 也就支配了 $c$。\n\n另外有 $m$ 个支配条件，一个支配条件是一个有序二元组 $(x,y)$ ($1 \\le x,y \\le n$，$x\\neq y$)，若访客 $x$ 支配 $y$，那么影的力量会增加 $1$ 点；若 $y$ 支配 $x$ ，那么影的力量会减少 $1$ 点。若两者互不支配，那么影的力量不变。初始的影的力量是 $0$。\n\n作为贴心仆人的松雀需要组织一场宴会，那么需要为宴会中的每个人安排支配关系。由于瑟莉姆大人不需要关心影的力量能够达到多大，只需要让影的力量保持非负，你能够帮助她构造最终的支配关系吗？\n\n若存在多个解，你只需要输出任意一个。保证对于任何合法输入，均存在解。", "inputFormat": "第一行输入两个正整数 $n,m$ ($1\\le n \\le 1\\times 10^5,\\ 1 \\le m \\le 2\\times 10^5$)，表示访客数量和支配条件数，用空格隔开。\n\n接下来 $m$ 行，每行两个用空格分隔的正整数 $x,y$ ($1 \\le x,y \\le n,\\ x\\neq y$)，表示一个支配条件的二元组 $(x,y)$。支配条件可能会重复，也可能会出现相反的支配条件，即既出现了 $(x,y)$，也出现了 $(y,x)$。支配条件两两互不影响。", "outputFormat": "输出一行 $n$ 个数，第 $i$ 个数表示编号为 $i$ 的访客的直接支配者编号。总支配者的直接支配者编号为 $0$。", "hint": "样例中最终影的力量是 $1-1-1+0+1=0$，符合非负条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[XJTUPC 2024] 瑟莉姆的宴会", "background": "欢迎来到瑟莉姆大人的享乐宴会！\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6kmpy10b.png)", "description": "宴会中一共有 $n$ 个访客，编号 $1\\sim n$。为了更好地控制影的力量，瑟莉姆要求有 $n-1$ 个访客都恰好受到另一个访客的支配，而剩下的那个人成为总支配者，支配其他 $n-1$ 名访客。访客间的**直接支配关系**构成了一棵有根树。\n\n对于这棵树来说，若结点 $a$ 的父结点是 $b$，那么称 $b$ 支配了 $a$，同时称 $b$ 是 $a$ 的**直接支配者**。同时，支配的关系具有**传递性**，即若 $a$ 支配 $b$，$b$ 支配 $c$，那么 $a$ 也就支配了 $c$。\n\n另外有 $m$ 个支配条件，一个支配条件是一个有序二元组 $(x,y)$ ($1 \\le x,y \\le n$，$x\\neq y$)，若访客 $x$ 支配 $y$，那么影的力量会增加 $1$ 点；若 $y$ 支配 $x$ ，那么影的力量会减少 $1$ 点。若两者互不支配，那么影的力量不变。初始的影的力量是 $0$。\n\n作为贴心仆人的松雀需要组织一场宴会，那么需要为宴会中的每个人安排支配关系。由于瑟莉姆大人不需要关心影的力量能够达到多大，只需要让影的力量保持非负，你能够帮助她构造最终的支配关系吗？\n\n若存在多个解，你只需要输出任意一个。保证对于任何合法输入，均存在解。", "inputFormat": "第一行输入两个正整数 $n,m$ ($1\\le n \\le 1\\times 10^5,\\ 1 \\le m \\le 2\\times 10^5$)，表示访客数量和支配条件数，用空格隔开。\n\n接下来 $m$ 行，每行两个用空格分隔的正整数 $x,y$ ($1 \\le x,y \\le n,\\ x\\neq y$)，表示一个支配条件的二元组 $(x,y)$。支配条件可能会重复，也可能会出现相反的支配条件，即既出现了 $(x,y)$，也出现了 $(y,x)$。支配条件两两互不影响。", "outputFormat": "输出一行 $n$ 个数，第 $i$ 个数表示编号为 $i$ 的访客的直接支配者编号。总支配者的直接支配者编号为 $0$。", "hint": "样例中最终影的力量是 $1-1-1+0+1=0$，符合非负条件。", "locale": "zh-CN"}}}
{"pid": "P10522", "type": "P", "difficulty": 3, "samples": [["5\n0 0 0 0 2\n", "4 3 2 5 1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["搜索", "图论", "2024", "O2优化", "深度优先搜索 DFS", "拓扑排序", "链表", "高校校赛"], "title": "[XJTUPC 2024] 雪中楼", "background": "", "description": "西安交通大学下雪了，所有楼顶都被积雪覆盖。\n\n在梧桐道上有 $n$ 座房子，自南向北第 $i$ 座房子的标号是 $i$，所有房子的高度互不相同。LNC 从南向北，依次登上每栋楼楼顶，然后他会回头观察他已经到达过的房子，并记录下这些房子中，比当前他所在房子矮的所有房子中，最高的房子的编号，记为 $a_i$。特殊的，当没有房子比当前房子矮的时候，$a_i=0$。\n\n现在给你所有的 $a_i$，要求你还原出所有楼的大小关系。由于高度的具体值未知，你只需要按照高度从低到高，输出房子编号。\n\n可以证明对于任何合法的输入，均存在唯一解。", "inputFormat": "输入第一行一个正整数 $n$ ($1\\le n \\le 2\\times 10^5$)，代表房子个数。\n\n接下来一行 $n$ 个非负整数 $a_i$，满足 $0\\le a_i <i$，两两之间用空格隔开。", "outputFormat": "输出一行 $n$ 个正整数构成的排列，用空格隔开，表示最终的答案。", "hint": "假设高度是一个 $1\\sim n$ 的排列，那么可以发现高度为 $5, 3, 2, 1, 4$ 是唯一的解，按照高度排名输出得到 $4, 3, 2, 5, 1$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[XJTUPC 2024] 雪中楼", "background": "", "description": "西安交通大学下雪了，所有楼顶都被积雪覆盖。\n\n在梧桐道上有 $n$ 座房子，自南向北第 $i$ 座房子的标号是 $i$，所有房子的高度互不相同。LNC 从南向北，依次登上每栋楼楼顶，然后他会回头观察他已经到达过的房子，并记录下这些房子中，比当前他所在房子矮的所有房子中，最高的房子的编号，记为 $a_i$。特殊的，当没有房子比当前房子矮的时候，$a_i=0$。\n\n现在给你所有的 $a_i$，要求你还原出所有楼的大小关系。由于高度的具体值未知，你只需要按照高度从低到高，输出房子编号。\n\n可以证明对于任何合法的输入，均存在唯一解。", "inputFormat": "输入第一行一个正整数 $n$ ($1\\le n \\le 2\\times 10^5$)，代表房子个数。\n\n接下来一行 $n$ 个非负整数 $a_i$，满足 $0\\le a_i <i$，两两之间用空格隔开。", "outputFormat": "输出一行 $n$ 个正整数构成的排列，用空格隔开，表示最终的答案。", "hint": "假设高度是一个 $1\\sim n$ 的排列，那么可以发现高度为 $5, 3, 2, 1, 4$ 是唯一的解，按照高度排名输出得到 $4, 3, 2, 5, 1$。\n", "locale": "zh-CN"}}}
{"pid": "P10523", "type": "P", "difficulty": 2, "samples": [["9 3\n1 1 2 2 3 3 3 2 1\n1 2\n2 3\n3 1\n", "180\n270\n216\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2024", "O2优化", "高校校赛"], "title": "[XJTUPC 2024] Everyone's ALL IN", "background": "", "description": "\n女士们，先生们。\n\n早上好，中午好，以及晚上好。\n\n欢迎来到“好得不能再好了！泰拉大师投资课”，我是你们的坎老师。\n\n不要 10000，不要 5000，只需要 999 源石锭，一对一指导，手把手教学，从入门到精通，让你：\n\n\n——**每选必赢，每投必中**，快速实现财富自由，富甲一方！\n\n今天我们来到的地点是——**卡西米尔骑士锦标赛**。\n\n本次的赛事有点不同，首先， $N$ 位骑士将自行组成骑士团，其中第 $i$ 号骑士将进入第 $a_i$ 号骑士团；\n\n然后接下来的 $M$ 天里，每天将指定两个不同的骑士团 $x$ 和 $y$ ，接下来每一位 $x$ 骑士团里的成员都和每一位 $y$ 骑士团里的成员进行一次比试。\n\n我们每一次比试将会下注，如果两位骑士的编号分别为 $a$ 和 $b$，那么如果你下注成功了，你将获得你的本金和 $a\\times b$ 的源石锭。\n\n当然了，每次下注你需要压上你的**所有本金**！\n\n那么请问，接下来的 $M$ 天里，在我的指导下你每天分别可以获得多少源石锭？\n\n**数据保证答案不超过 64 位有符号整型能表达的范围。**\n\n**赌博有风险，投资需谨慎！**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gof3mumx.png)", "inputFormat": "输入第一行两个正整数 $N$ ($1\\le N \\le 2\\times 10^5$) 和 $M$ ($1\\le M \\le 2\\times 10^5$)，由空格隔开。\n\n接下来一行有 $N$ 个由空格隔开的正整数 $a_i$ ($1\\le a_i \\le 1\\times 10^6$) ，表示编号为 $i$ 的骑士所在的骑士团的编号。\n\n接下来 $M$ 行，每行两个由空格隔开的正整数 $x_i,y_i$ ($x_i \\neq y_i$)，保证 $x_i,y_i$ 出现在 $a_1 \\sim a_n$ 中。", "outputFormat": "输出共 $M$ 行，每行一个正整数，第 $i$ 行表示第 $i$ 天可以获得的最大收益。\n\n**数据保证答案不超过 64 位有符号整型能表达的范围。**", "hint": "骑士团 $1$ 的成员有 $\\{1,2,9\\}$，骑士团 $2$ 的成员有 $\\{3,4,8\\}$，骑士团 $3$ 的成员有 $\\{5,6,7\\}$。\n\n\n第一天，骑士团 $1$ 和骑士团 $2$ 进行比赛。\n\n获得的收益为：$1\\times 3+1\\times 4+1\\times 8+2\\times 3+2\\times 4+2\\times 8+9\\times 3+9\\times 4+9\\times 8=180$。\n\n第二天，骑士团 $2$ 和骑士团 $3$ 进行比赛。\n\n获得的收益为：$3\\times 5+3\\times 6+3\\times 7+4\\times 5+4\\times 6+4\\times 7+8\\times 5+8\\times 6+8\\times 7=270$。\n\n第三天，骑士团 $1$ 和骑士团 $3$ 进行比赛。\n\n获得的收益为：$1\\times 5+1\\times 6+1\\times 7+2\\times 5+2\\times 6+2\\times 7+9\\times 5+9\\times 6+9\\times 7=216$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[XJTUPC 2024] Everyone's ALL IN", "background": "", "description": "\n女士们，先生们。\n\n早上好，中午好，以及晚上好。\n\n欢迎来到“好得不能再好了！泰拉大师投资课”，我是你们的坎老师。\n\n不要 10000，不要 5000，只需要 999 源石锭，一对一指导，手把手教学，从入门到精通，让你：\n\n\n——**每选必赢，每投必中**，快速实现财富自由，富甲一方！\n\n今天我们来到的地点是——**卡西米尔骑士锦标赛**。\n\n本次的赛事有点不同，首先， $N$ 位骑士将自行组成骑士团，其中第 $i$ 号骑士将进入第 $a_i$ 号骑士团；\n\n然后接下来的 $M$ 天里，每天将指定两个不同的骑士团 $x$ 和 $y$ ，接下来每一位 $x$ 骑士团里的成员都和每一位 $y$ 骑士团里的成员进行一次比试。\n\n我们每一次比试将会下注，如果两位骑士的编号分别为 $a$ 和 $b$，那么如果你下注成功了，你将获得你的本金和 $a\\times b$ 的源石锭。\n\n当然了，每次下注你需要压上你的**所有本金**！\n\n那么请问，接下来的 $M$ 天里，在我的指导下你每天分别可以获得多少源石锭？\n\n**数据保证答案不超过 64 位有符号整型能表达的范围。**\n\n**赌博有风险，投资需谨慎！**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gof3mumx.png)", "inputFormat": "输入第一行两个正整数 $N$ ($1\\le N \\le 2\\times 10^5$) 和 $M$ ($1\\le M \\le 2\\times 10^5$)，由空格隔开。\n\n接下来一行有 $N$ 个由空格隔开的正整数 $a_i$ ($1\\le a_i \\le 1\\times 10^6$) ，表示编号为 $i$ 的骑士所在的骑士团的编号。\n\n接下来 $M$ 行，每行两个由空格隔开的正整数 $x_i,y_i$ ($x_i \\neq y_i$)，保证 $x_i,y_i$ 出现在 $a_1 \\sim a_n$ 中。", "outputFormat": "输出共 $M$ 行，每行一个正整数，第 $i$ 行表示第 $i$ 天可以获得的最大收益。\n\n**数据保证答案不超过 64 位有符号整型能表达的范围。**", "hint": "骑士团 $1$ 的成员有 $\\{1,2,9\\}$，骑士团 $2$ 的成员有 $\\{3,4,8\\}$，骑士团 $3$ 的成员有 $\\{5,6,7\\}$。\n\n\n第一天，骑士团 $1$ 和骑士团 $2$ 进行比赛。\n\n获得的收益为：$1\\times 3+1\\times 4+1\\times 8+2\\times 3+2\\times 4+2\\times 8+9\\times 3+9\\times 4+9\\times 8=180$。\n\n第二天，骑士团 $2$ 和骑士团 $3$ 进行比赛。\n\n获得的收益为：$3\\times 5+3\\times 6+3\\times 7+4\\times 5+4\\times 6+4\\times 7+8\\times 5+8\\times 6+8\\times 7=270$。\n\n第三天，骑士团 $1$ 和骑士团 $3$ 进行比赛。\n\n获得的收益为：$1\\times 5+1\\times 6+1\\times 7+2\\times 5+2\\times 6+2\\times 7+9\\times 5+9\\times 6+9\\times 7=216$。", "locale": "zh-CN"}}}
{"pid": "P10524", "type": "P", "difficulty": 6, "samples": [["2\n1 3 2 2\n", "8 5 11\n"], ["4\n1 1 4 5 1 4 1 9 1 9 8 1 0 0 0 0\n", "149 41 157\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2024", "O2优化", "高校校赛"], "title": "[XJTUPC 2024] 循环移位", "background": "", "description": "给定长度为 $2^n$ 的数组 $a_i$ ($0 \\leq i < 2^n$)，你可以进行任意次循环移位。\n\n求 $\\sum_{i=0}^{2^n-1} a_i \\oplus i$， $\\sum_{i=0}^{2^n-1} a_i \\& i$，$\\sum_{i=0}^{2^n-1} a_i | i$ 的最大值。其中 $\\oplus, \\&, |$ 分别代表按位异或，按位与，按位或。\n\n对于一个长度为 $m$ 的数组 $x_i$ ($0 \\leq i < m$)，其进行循环移位的结果 $x'_i$ 为:\n\n$$x'_i = \\left\\{\n\t\\begin{array}{ll}\n\t\tx_{i - 1} & i \\neq 0 \\\\\n\t\tx_{m - 1} & i = 0\n\t\\end{array}\\right.$$", "inputFormat": "输入第一行包含一个整数 $n$ ($1 \\leq n \\leq 20$)，含义如题意所述。\n\n接下来一行包含 $2^n$ 个整数 $a_i$ ($0 \\leq a_i < 2^n$)，为给定的数组。", "outputFormat": "输出一行三个整数，由空格隔开，为 $\\sum_{i=0}^{2^n-1} a_i \\oplus i$，$\\sum_{i=0}^{2^n-1} a_i \\& i$，$\\sum_{i=0}^{2^n-1} a_i | i$ 的最大值。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[XJTUPC 2024] 循环移位", "background": "", "description": "给定长度为 $2^n$ 的数组 $a_i$ ($0 \\leq i < 2^n$)，你可以进行任意次循环移位。\n\n求 $\\sum_{i=0}^{2^n-1} a_i \\oplus i$， $\\sum_{i=0}^{2^n-1} a_i \\& i$，$\\sum_{i=0}^{2^n-1} a_i | i$ 的最大值。其中 $\\oplus, \\&, |$ 分别代表按位异或，按位与，按位或。\n\n对于一个长度为 $m$ 的数组 $x_i$ ($0 \\leq i < m$)，其进行循环移位的结果 $x'_i$ 为:\n\n$$x'_i = \\left\\{\n\t\\begin{array}{ll}\n\t\tx_{i - 1} & i \\neq 0 \\\\\n\t\tx_{m - 1} & i = 0\n\t\\end{array}\\right.$$", "inputFormat": "输入第一行包含一个整数 $n$ ($1 \\leq n \\leq 20$)，含义如题意所述。\n\n接下来一行包含 $2^n$ 个整数 $a_i$ ($0 \\leq a_i < 2^n$)，为给定的数组。", "outputFormat": "输出一行三个整数，由空格隔开，为 $\\sum_{i=0}^{2^n-1} a_i \\oplus i$，$\\sum_{i=0}^{2^n-1} a_i \\& i$，$\\sum_{i=0}^{2^n-1} a_i | i$ 的最大值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10525", "type": "P", "difficulty": 6, "samples": [["3 3 4\n1 2 3\n2 3 4\n1 3 5\n3 1\n3 2\n1 2\n2 3\n", "44\n36\n20\n20\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "O2优化", "高校校赛"], "title": "[XJTUPC 2024] 图上操作", "background": "", "description": "你有一张 $n$ 个点 $m$ 条边的**有向图**，点的下标为 $1\\sim n$。每条边有一个正整数边权 $d_i$。特殊的，$1\\le d_i \\le 100$。\n\n现在定义点 $i$ 的瓶颈路大小为：所有从点 $1$ 到点 $i$ 的有向路径中，最小边权的最大值。特殊的，若 $i$ 不能从 $1$ 出发到达，则其瓶颈路权值为 $0$。\n\n有 $q$ 次修改，每次修改会指定一条边，将这条边的边权降低，保证降低后依然是正整数。\n\n现在要求每次修改后，输出编号为 $2\\sim n$ 的点的瓶颈路大小。注意，每次修改是在前面修改的基础上进行操作，并不是相互独立的。\n\n由于输出数据量过于巨大，设每次修改完后点 $i$ 的瓶颈路大小为 $ans_i$，你只需要输出 $(\\sum_{i=2}^n ans_i \\times 2^i)\\bmod 998244353$。", "inputFormat": "第一行三个正整数 $n,m,q$ ($2\\le n\\le 1\\times 10^5$，$1\\le m \\le 2\\times 10^5$，$1\\le q\\le 2\\times 10^5$) 由空格隔开，含义如题所述。\n\n后面 $m$ 行每行两个正整数 $s_i,t_i,d_i$ ($1\\le s_i,t_i\\le n$，$s_i\\neq t_i$，$1\\le d_i \\le 100$) 由空格隔开，表示存在一条 $s_i$ 到 $t_i$ 的有向边，边权为 $d_i$，这条边的编号为 $i$。保证无自环，但可能会有重边。\n\n再后面 $q$ 行每行两个正整数 $x,y$ ($1\\le x\\le m$，$1\\le y < d_x$) 由空格隔开，表示将编号为 $x$ 的边的权值下调 $y$，且保证下调以后大于 $0$。", "outputFormat": "输出 $q$ 行每行一个非负整数，表示你求得的答案。", "hint": "第一次修改后，$2$ 号点的瓶颈路大小为 $3$，$3$ 号点的瓶颈路大小为 $4$。\n\n第二次修改后，$2$ 号点的瓶颈路大小为 $3$，$3$ 号点的瓶颈路大小为 $3$。\n\n第三次修改后，$2$ 号点的瓶颈路大小为 $1$，$3$ 号点的瓶颈路大小为 $2$。\n\n第四次修改后，$2$ 号点的瓶颈路大小为 $1$，$3$ 号点的瓶颈路大小为 $2$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[XJTUPC 2024] 图上操作", "background": "", "description": "你有一张 $n$ 个点 $m$ 条边的**有向图**，点的下标为 $1\\sim n$。每条边有一个正整数边权 $d_i$。特殊的，$1\\le d_i \\le 100$。\n\n现在定义点 $i$ 的瓶颈路大小为：所有从点 $1$ 到点 $i$ 的有向路径中，最小边权的最大值。特殊的，若 $i$ 不能从 $1$ 出发到达，则其瓶颈路权值为 $0$。\n\n有 $q$ 次修改，每次修改会指定一条边，将这条边的边权降低，保证降低后依然是正整数。\n\n现在要求每次修改后，输出编号为 $2\\sim n$ 的点的瓶颈路大小。注意，每次修改是在前面修改的基础上进行操作，并不是相互独立的。\n\n由于输出数据量过于巨大，设每次修改完后点 $i$ 的瓶颈路大小为 $ans_i$，你只需要输出 $(\\sum_{i=2}^n ans_i \\times 2^i)\\bmod 998244353$。", "inputFormat": "第一行三个正整数 $n,m,q$ ($2\\le n\\le 1\\times 10^5$，$1\\le m \\le 2\\times 10^5$，$1\\le q\\le 2\\times 10^5$) 由空格隔开，含义如题所述。\n\n后面 $m$ 行每行两个正整数 $s_i,t_i,d_i$ ($1\\le s_i,t_i\\le n$，$s_i\\neq t_i$，$1\\le d_i \\le 100$) 由空格隔开，表示存在一条 $s_i$ 到 $t_i$ 的有向边，边权为 $d_i$，这条边的编号为 $i$。保证无自环，但可能会有重边。\n\n再后面 $q$ 行每行两个正整数 $x,y$ ($1\\le x\\le m$，$1\\le y < d_x$) 由空格隔开，表示将编号为 $x$ 的边的权值下调 $y$，且保证下调以后大于 $0$。", "outputFormat": "输出 $q$ 行每行一个非负整数，表示你求得的答案。", "hint": "第一次修改后，$2$ 号点的瓶颈路大小为 $3$，$3$ 号点的瓶颈路大小为 $4$。\n\n第二次修改后，$2$ 号点的瓶颈路大小为 $3$，$3$ 号点的瓶颈路大小为 $3$。\n\n第三次修改后，$2$ 号点的瓶颈路大小为 $1$，$3$ 号点的瓶颈路大小为 $2$。\n\n第四次修改后，$2$ 号点的瓶颈路大小为 $1$，$3$ 号点的瓶颈路大小为 $2$。", "locale": "zh-CN"}}}
{"pid": "P10526", "type": "P", "difficulty": 4, "samples": [["7 40\nkill\nkillall\nrm\nrmdir\nifconfig\nifdown\nll\nkTBlEkTaTEiTcBdTElTExjtuTExjtuBBBBBrTdTE\n", "1 2 6 7 -1 4 "]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "O2优化", "高校校赛"], "title": "[XJTUPC 2024] 命令行", "background": "", "description": "有 $n$ 个两两互不相同的仅由小写字符构成的命令字符串 $t_i$ ($1 \\leq i \\leq n$)，你需要实现一个支持命令补全的命令行。\n\n你的输入区是一个字符串 $s$，他可以接受小写字母 $\\text{'a'-'z'}$ 和 $\\text{Tab}$ 键 (以 $\\text{'T'}$ 表示)，$\\text{Enter}$ 键 (以 $\\text{'E'}$ 表示)，$\\text{Backspace}$ 键 (以 $\\text{'B'}$ 表示)。规则如下所述:\n\n1. 当你接受小写字符 $c$，将把 $c$ 追加到输入区字符串 $s$ 的末尾。\n\n1. 当你接受 $\\text{Backspace}$ 键，将尝试删除最后一个字符:\n   - 如果输入区字符串 $s$ 为空，则不进行任何操作。\n   - 如果输入区字符串 $s$ 非空，则丢弃 $s$ 末尾的字符。\n1. 当你接受 $\\text{Tab}$ 键，将会对 $s$ 进行一次智能补全，补全规则如下: \n\t- 设以 $s$ 为前缀的命令字符串集合为 $T$。\n   - 如果 $T$ 为空，则不进行任何操作。\n   - 如果 $T$ 非空，则把 $s$ 置为 $\\text{lcp}(T)$。这里 $\\text{lcp}$ 代表最长公共前缀，含义是最长的，是 $T$ 中每一个字符串前缀的字符串。\n\n1. 当你接受 $\\text{Enter}$ 键，将会试图执行命令 $s$: \n\t- 如果存在命令字符串 $t_i = s$，则输出命令编号 $i$。\n   - 如果不存在命令字符串 $t_i = s$，则输出 $-1$。\n   - 无论是否执行成功，清空输入区 $s$。\n   \n给定你接受到的输入串 $p$，你需要输出每个 $\\text{Enter}$ 键执行的结果。", "inputFormat": "输入第一行为两个整数 $n$ 和 $m$ ($1 \\leq n \\leq 10^5, 1 \\leq m \\leq 5 \\times 10^6$)，为命令字符串的个数和输入串的长度，由空格隔开。\n\n接下来 $n$ 行，每行一个仅由小写字符构成的字符串 $t_i$，为命令串。保证有 $\\sum_{i=1}^{n} |t_i| \\leq 10^6$ 且命令串互不相同。\n\n最后一行为字符串 $p$ ($|p|=m$)，为输入串。保证 $p$ 仅由 $\\text{\\{'a'-'z', 'T', 'B', 'E'\\}}$ 组成。", "outputFormat": "给定你接受到的输入串 $p$，你需要输出每个 $\\text{Enter}$ 键执行的结果。", "hint": "初始时，输入区字符串$s=\"\"$。\n\n输入 $\\text{'k'}$ 后，输入区字符串$s=\"k\"$。\n\n输入 $\\text{'T'}$ 后，进行智能匹配。此时 $T=\\{\"kill\",\"killall\"\\}$，$\\text{lcp}(T)=\"kill\"$。故输入区字符串$s=\"kill\"$。\n\n输入 $\\text{'B'}$ 后，输入区字符串$s=\"kil\"$。\n\n输入 $\\text{'l'}$ 后，输入区字符串$s=\"kill\"$。\n\n输入 $\\text{'E'}$ 后，因为 $t_1=s$，所以应该输出 $1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[XJTUPC 2024] 命令行", "background": "", "description": "有 $n$ 个两两互不相同的仅由小写字符构成的命令字符串 $t_i$ ($1 \\leq i \\leq n$)，你需要实现一个支持命令补全的命令行。\n\n你的输入区是一个字符串 $s$，他可以接受小写字母 $\\text{'a'-'z'}$ 和 $\\text{Tab}$ 键 (以 $\\text{'T'}$ 表示)，$\\text{Enter}$ 键 (以 $\\text{'E'}$ 表示)，$\\text{Backspace}$ 键 (以 $\\text{'B'}$ 表示)。规则如下所述:\n\n1. 当你接受小写字符 $c$，将把 $c$ 追加到输入区字符串 $s$ 的末尾。\n\n1. 当你接受 $\\text{Backspace}$ 键，将尝试删除最后一个字符:\n   - 如果输入区字符串 $s$ 为空，则不进行任何操作。\n   - 如果输入区字符串 $s$ 非空，则丢弃 $s$ 末尾的字符。\n1. 当你接受 $\\text{Tab}$ 键，将会对 $s$ 进行一次智能补全，补全规则如下: \n\t- 设以 $s$ 为前缀的命令字符串集合为 $T$。\n   - 如果 $T$ 为空，则不进行任何操作。\n   - 如果 $T$ 非空，则把 $s$ 置为 $\\text{lcp}(T)$。这里 $\\text{lcp}$ 代表最长公共前缀，含义是最长的，是 $T$ 中每一个字符串前缀的字符串。\n\n1. 当你接受 $\\text{Enter}$ 键，将会试图执行命令 $s$: \n\t- 如果存在命令字符串 $t_i = s$，则输出命令编号 $i$。\n   - 如果不存在命令字符串 $t_i = s$，则输出 $-1$。\n   - 无论是否执行成功，清空输入区 $s$。\n   \n给定你接受到的输入串 $p$，你需要输出每个 $\\text{Enter}$ 键执行的结果。", "inputFormat": "输入第一行为两个整数 $n$ 和 $m$ ($1 \\leq n \\leq 10^5, 1 \\leq m \\leq 5 \\times 10^6$)，为命令字符串的个数和输入串的长度，由空格隔开。\n\n接下来 $n$ 行，每行一个仅由小写字符构成的字符串 $t_i$，为命令串。保证有 $\\sum_{i=1}^{n} |t_i| \\leq 10^6$ 且命令串互不相同。\n\n最后一行为字符串 $p$ ($|p|=m$)，为输入串。保证 $p$ 仅由 $\\text{\\{'a'-'z', 'T', 'B', 'E'\\}}$ 组成。", "outputFormat": "给定你接受到的输入串 $p$，你需要输出每个 $\\text{Enter}$ 键执行的结果。", "hint": "初始时，输入区字符串$s=\"\"$。\n\n输入 $\\text{'k'}$ 后，输入区字符串$s=\"k\"$。\n\n输入 $\\text{'T'}$ 后，进行智能匹配。此时 $T=\\{\"kill\",\"killall\"\\}$，$\\text{lcp}(T)=\"kill\"$。故输入区字符串$s=\"kill\"$。\n\n输入 $\\text{'B'}$ 后，输入区字符串$s=\"kil\"$。\n\n输入 $\\text{'l'}$ 后，输入区字符串$s=\"kill\"$。\n\n输入 $\\text{'E'}$ 后，因为 $t_1=s$，所以应该输出 $1$。", "locale": "zh-CN"}}}
{"pid": "P10527", "type": "P", "difficulty": 5, "samples": [["6\n2 7 4 1 8 1\n", "1\n"], ["5\n31 26 33 21 40\n", "5\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2024", "O2优化", "高校校赛"], "title": "[XJTUPC 2024] 最后一块石头的重量", "background": "", "description": "有一堆石头，用整数数组 $a$ 表示。其中 $a_i$ 表示第 $i$ 块石头的重量。\n\n每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 $x$ 和 $y$，且 $x \\le y$。那么粉碎的可能结果如下：\n\n- 如果 $x = y$，那么两块石头都会被完全粉碎；\n- 如果 $x \\neq y$，那么重量为 $x$ 的石头将会完全粉碎，而重量为 $y$ 的石头新重量为 $y-x$。\n\n最后，**最多只会剩下一块**石头。输出此石头**最小的可能重量**。如果没有石头剩下，就输出 $0$。", "inputFormat": "输入数据共两行。\n\n第一行输入一个整数 $n$ ($1 \\leq n \\leq 10000$)，表示石子的数量；\n\n第二行输入 $n$ 个整数 $a_i$ ($1 \\leq a_i \\leq 5000$)，表示第 $i$ 块石头的重量。", "outputFormat": "输出数据共一行。\n\n第一行输出一个整数表示答案。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[XJTUPC 2024] 最后一块石头的重量", "background": "", "description": "有一堆石头，用整数数组 $a$ 表示。其中 $a_i$ 表示第 $i$ 块石头的重量。\n\n每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 $x$ 和 $y$，且 $x \\le y$。那么粉碎的可能结果如下：\n\n- 如果 $x = y$，那么两块石头都会被完全粉碎；\n- 如果 $x \\neq y$，那么重量为 $x$ 的石头将会完全粉碎，而重量为 $y$ 的石头新重量为 $y-x$。\n\n最后，**最多只会剩下一块**石头。输出此石头**最小的可能重量**。如果没有石头剩下，就输出 $0$。", "inputFormat": "输入数据共两行。\n\n第一行输入一个整数 $n$ ($1 \\leq n \\leq 10000$)，表示石子的数量；\n\n第二行输入 $n$ 个整数 $a_i$ ($1 \\leq a_i \\leq 5000$)，表示第 $i$ 块石头的重量。", "outputFormat": "输出数据共一行。\n\n第一行输出一个整数表示答案。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10528", "type": "P", "difficulty": 4, "samples": [["12 1\n2 3 2 1\n", "1\n"], ["8 5\n2 1 1 3\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2024", "O2优化", "高校校赛"], "title": "[XJTUPC 2024] 崩坏：星穹铁道", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/7urblttd.png)\n\nCorycle 喜欢玩一个由米哈游自主研发的一款回合制战斗游戏------《崩坏：星穹铁道》。这片银河中有名为「星神」的存在，他们造就现实，抹消星辰，在无数「世界」中留下他们的痕迹。你将由此探索新的文明，结识新的伙伴，在无数光怪陆离的「世界」与「世界」之间展开新的冒险。所有你想知道的，都将在群星中找到答案。\n", "description": "在游戏《崩坏：星穹铁道》中，你的队伍里会有四名角色轮流行动，所有角色共享用于施放战技的战技点。当战斗开始时，你会获得 $k$ 个战技点，且战技点的上限为 $5$ 个。每个角色行动时可选择进行普通攻击或者施放战技，进行普通攻击时会为全队增加一个战技点，当战技点达到上限时也可以进行普通攻击，但是此时不回复战技点。角色施放战技需要消耗一个战技点，当没有战技点时只能进行普通攻击而不可释放技能。\n\nCorycle 想成为星穹铁道高手，为此他需要对自己的配队了如指掌。由于角色有多种职业，同时为了方便对角色类型进行定位，他把角色的行动模式分为了三种类型：\n\n1. 当角色行动时，只会进行普通攻击。\n\n2. 当角色行动时，若有战技点不少于 $1$ 则必定释放技能，否则进行普通攻击。\n\n3. 不对角色的行动进行限制。\n\n现在 Corycle 开始了一场战斗，他想知道当队伍中的四名角色一共行动 $n$ 次时，可能会有多少种不同的行动方案。我们称两个行动方案不同，当且仅当存在至少一个回合中，两个方案里角色行为不同。这个答案可能是一个很大的数，所以请将答案对 $998244353$ 取模。", "inputFormat": "输入第一行有两个正整数 $n$ 和 $k$ ($1\\le n\\le 1\\times 10^{18},0\\le k\\le 5$)，表示总行动次数与初始战技点数，用空格隔开。\n\n第二行有四个用空格隔开的正整数 $a_1,a_2,a_3,a_4$ ($1 \\le a_1,a_2,a_3,a_4 \\le 3$)，表示四名角色的行动模式类型。\n", "outputFormat": "输出仅一个整数，表示不同的行动方案数。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[XJTUPC 2024] 崩坏：星穹铁道", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/7urblttd.png)\n\nCorycle 喜欢玩一个由米哈游自主研发的一款回合制战斗游戏------《崩坏：星穹铁道》。这片银河中有名为「星神」的存在，他们造就现实，抹消星辰，在无数「世界」中留下他们的痕迹。你将由此探索新的文明，结识新的伙伴，在无数光怪陆离的「世界」与「世界」之间展开新的冒险。所有你想知道的，都将在群星中找到答案。\n", "description": "在游戏《崩坏：星穹铁道》中，你的队伍里会有四名角色轮流行动，所有角色共享用于施放战技的战技点。当战斗开始时，你会获得 $k$ 个战技点，且战技点的上限为 $5$ 个。每个角色行动时可选择进行普通攻击或者施放战技，进行普通攻击时会为全队增加一个战技点，当战技点达到上限时也可以进行普通攻击，但是此时不回复战技点。角色施放战技需要消耗一个战技点，当没有战技点时只能进行普通攻击而不可释放技能。\n\nCorycle 想成为星穹铁道高手，为此他需要对自己的配队了如指掌。由于角色有多种职业，同时为了方便对角色类型进行定位，他把角色的行动模式分为了三种类型：\n\n1. 当角色行动时，只会进行普通攻击。\n\n2. 当角色行动时，若有战技点不少于 $1$ 则必定释放技能，否则进行普通攻击。\n\n3. 不对角色的行动进行限制。\n\n现在 Corycle 开始了一场战斗，他想知道当队伍中的四名角色一共行动 $n$ 次时，可能会有多少种不同的行动方案。我们称两个行动方案不同，当且仅当存在至少一个回合中，两个方案里角色行为不同。这个答案可能是一个很大的数，所以请将答案对 $998244353$ 取模。", "inputFormat": "输入第一行有两个正整数 $n$ 和 $k$ ($1\\le n\\le 1\\times 10^{18},0\\le k\\le 5$)，表示总行动次数与初始战技点数，用空格隔开。\n\n第二行有四个用空格隔开的正整数 $a_1,a_2,a_3,a_4$ ($1 \\le a_1,a_2,a_3,a_4 \\le 3$)，表示四名角色的行动模式类型。\n", "outputFormat": "输出仅一个整数，表示不同的行动方案数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10529", "type": "P", "difficulty": 6, "samples": [["1 25 14\n14\n12\n", "882.000000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2024", "Special Judge", "O2优化", "高校校赛"], "title": "[XJTUPC 2024] 勘探队", "background": "", "description": "一支勘探队从 $(0,0)$ 出发，终点是 $(0,y)$，携带着从 $1$ 号到 $n$ 号设备，每个设备的重量为 $m_i$，且必须安放在横坐标为 $x_i$ 的任意位置上（纵坐标可以是任意实数）。必须按照顺序安放所有设备，在较小编号的设备被全部放置之前，即使横坐标位置满足，也不能放置。\n\n当勘探队身上的设备总重量为 $m$ 时，其移动一单位长度的代价是 $m+M$。问勘探队完成所有设备安装并到达终点的最小代价。\n\n同一个坐标位置可以放置多台设备。", "inputFormat": "输入第一行三个正整数 $n$ ($1\\le n \\le 1\\times 10^4$)，$M$ ($0< M \\le 30$) 和 $y$ ($0<y\\le 2\\times 10^5$)，代表设备个数、移动的基本代价和最终终点的纵坐标。\n\n第二行给出 $n$ 个非负整数 $m_i$ ($0< m_i\\le 30$)，表示第 $i$ 台设备的重量。两两之间用空格隔开。\n\n第三行给出 $n$ 个整数 $x_i$ ($|x_i|\\le 1\\times 10^4$)，表示第 $i$ 台机器坐标的要求。", "outputFormat": "输出一行一个正实数代表最终代价。如果你的答案是 $a$，我们给出的标准答案是 $b$，你的答案正确当且仅当 $\\frac{|a - b|}{\\max{(1, |b|)}} \\le 10^{-6}$。", "hint": "走直线走到 $(12,5)$，距离 $13$，然后走直线走到 $(0,14)$，距离 $15$，总代价 $13\\times (25+14)+15\\times 25=882$。不存在一个比这个更优的解。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[XJTUPC 2024] 勘探队", "background": "", "description": "一支勘探队从 $(0,0)$ 出发，终点是 $(0,y)$，携带着从 $1$ 号到 $n$ 号设备，每个设备的重量为 $m_i$，且必须安放在横坐标为 $x_i$ 的任意位置上（纵坐标可以是任意实数）。必须按照顺序安放所有设备，在较小编号的设备被全部放置之前，即使横坐标位置满足，也不能放置。\n\n当勘探队身上的设备总重量为 $m$ 时，其移动一单位长度的代价是 $m+M$。问勘探队完成所有设备安装并到达终点的最小代价。\n\n同一个坐标位置可以放置多台设备。", "inputFormat": "输入第一行三个正整数 $n$ ($1\\le n \\le 1\\times 10^4$)，$M$ ($0< M \\le 30$) 和 $y$ ($0<y\\le 2\\times 10^5$)，代表设备个数、移动的基本代价和最终终点的纵坐标。\n\n第二行给出 $n$ 个非负整数 $m_i$ ($0< m_i\\le 30$)，表示第 $i$ 台设备的重量。两两之间用空格隔开。\n\n第三行给出 $n$ 个整数 $x_i$ ($|x_i|\\le 1\\times 10^4$)，表示第 $i$ 台机器坐标的要求。", "outputFormat": "输出一行一个正实数代表最终代价。如果你的答案是 $a$，我们给出的标准答案是 $b$，你的答案正确当且仅当 $\\frac{|a - b|}{\\max{(1, |b|)}} \\le 10^{-6}$。", "hint": "走直线走到 $(12,5)$，距离 $13$，然后走直线走到 $(0,14)$，距离 $15$，总代价 $13\\times (25+14)+15\\times 25=882$。不存在一个比这个更优的解。", "locale": "zh-CN"}}}
{"pid": "P10530", "type": "P", "difficulty": 3, "samples": [["3 1\n1 2\n2 3\n", "1\n"], ["4 2\n1 2\n2 3\n3 4\n", "2\n"], ["10 3\n1 2\n2 3\n9 4\n3 5\n5 6\n6 7\n3 9\n5 8\n5 10\n", "5\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2024", "O2优化", "高校校赛"], "title": "[XJTUPC 2024] 生命游戏", "background": "在著名的生命游戏中，二维方格中每个细胞死或活的状态由它周围的八个细胞（上、下、左、右、左上、左下、右上、右下）所决定。\n\n具体规则如下：\n\n孤单死亡：如果细胞的邻居小于等于 1 个，则该细胞在下一次状态将死亡；\n\n拥挤死亡：如果细胞的邻居在 4 个及以上，则该细胞在下一次状态将死亡；\n\n稳定：如果细胞的邻居为 2 个或 3 个，则下一次状态为稳定存活；\n\n复活：如果某位置原无细胞存活，而该位置的邻居为 3 个，则该位置将复活一个细胞。\n\n在此规则下也出现了很多有趣的图形，比如说下图就是\"轻量级飞船\"连续的五个回合的情况：它的周期是 4，每 2 个回合会向右边走一格。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/28o5txyh.png)", "description": "现在我们将在树上进行简化版的生命游戏，首先将给出一棵含有 $n$ 个点，$n-1$ 条边的树和一个整数 $k$。\n\n在每回合时，当前剩余的度数为 $k$ 的点及与其连接的边会瞬间同时被删去。\n\n形式化的，每回合都将按顺序进行如下操作：\n\n   -  统计当前剩余每个点的度数（一个点的度数定义为为，这个点当前连接的边的条数）。\n   - 将所有度数**恰好**为 $k$ 的点标记。\n   - 将上一步标记的点及其连接的边全部删去。\n\n我们希望知道在无穷多回合后，这棵树将被分为多少个连通块。若最终两个点能够直接或间接的通过若干条边相连，则认为这两个点属于同一个连通块。", "inputFormat": "第一行两个整数 $n,k$ ($0\\le k < n \\le 10^6$)，用空格隔开。\n\n接下来 $n-1$ 行，每行两个用空格隔开的正整数 $u_i,v_i$ ($1\\le u_i, v_i \\le n$) 表示 $u_i$ 和 $v_i$ 之间有一条边。\n\n输入的数据量较大，建议使用快速的读入方式。", "outputFormat": "共一行一个整数，表示无穷多回合之后剩余的连通块个数。\n", "hint": "\n对于样例 1:\n\n这棵树的初始形态为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g5x6u2fx.png)\n\n其中三个点的度数依次为 $1,2,1$。\n\n在一回合过后，点 $1,3$ 被删除。\n\n这棵树变为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5x6vo3it.png)\n\n容易发现之后这棵树的形态将不会变化，所以最终的连通块个数是 $1$。\n\n对于样例 2：\n\n初始形态为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hdq30nrf.png)\n\n一回合之后变为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/td8lj616.png)\n\n之后保持不变，最终连通块个数为 $2$。\n\n对于样例 3：\n\n初始形态：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tfu21fc0.png)\n\n一回合之后变为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ad1bwnz.png)\n\n再过一回合之后变为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2ax9h1tt.png)\n\n之后保持不变，最终连通块个数为 $5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[XJTUPC 2024] 生命游戏", "background": "在著名的生命游戏中，二维方格中每个细胞死或活的状态由它周围的八个细胞（上、下、左、右、左上、左下、右上、右下）所决定。\n\n具体规则如下：\n\n孤单死亡：如果细胞的邻居小于等于 1 个，则该细胞在下一次状态将死亡；\n\n拥挤死亡：如果细胞的邻居在 4 个及以上，则该细胞在下一次状态将死亡；\n\n稳定：如果细胞的邻居为 2 个或 3 个，则下一次状态为稳定存活；\n\n复活：如果某位置原无细胞存活，而该位置的邻居为 3 个，则该位置将复活一个细胞。\n\n在此规则下也出现了很多有趣的图形，比如说下图就是\"轻量级飞船\"连续的五个回合的情况：它的周期是 4，每 2 个回合会向右边走一格。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/28o5txyh.png)", "description": "现在我们将在树上进行简化版的生命游戏，首先将给出一棵含有 $n$ 个点，$n-1$ 条边的树和一个整数 $k$。\n\n在每回合时，当前剩余的度数为 $k$ 的点及与其连接的边会瞬间同时被删去。\n\n形式化的，每回合都将按顺序进行如下操作：\n\n   -  统计当前剩余每个点的度数（一个点的度数定义为为，这个点当前连接的边的条数）。\n   - 将所有度数**恰好**为 $k$ 的点标记。\n   - 将上一步标记的点及其连接的边全部删去。\n\n我们希望知道在无穷多回合后，这棵树将被分为多少个连通块。若最终两个点能够直接或间接的通过若干条边相连，则认为这两个点属于同一个连通块。", "inputFormat": "第一行两个整数 $n,k$ ($0\\le k < n \\le 10^6$)，用空格隔开。\n\n接下来 $n-1$ 行，每行两个用空格隔开的正整数 $u_i,v_i$ ($1\\le u_i, v_i \\le n$) 表示 $u_i$ 和 $v_i$ 之间有一条边。\n\n输入的数据量较大，建议使用快速的读入方式。", "outputFormat": "共一行一个整数，表示无穷多回合之后剩余的连通块个数。\n", "hint": "\n对于样例 1:\n\n这棵树的初始形态为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g5x6u2fx.png)\n\n其中三个点的度数依次为 $1,2,1$。\n\n在一回合过后，点 $1,3$ 被删除。\n\n这棵树变为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5x6vo3it.png)\n\n容易发现之后这棵树的形态将不会变化，所以最终的连通块个数是 $1$。\n\n对于样例 2：\n\n初始形态为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hdq30nrf.png)\n\n一回合之后变为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/td8lj616.png)\n\n之后保持不变，最终连通块个数为 $2$。\n\n对于样例 3：\n\n初始形态：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tfu21fc0.png)\n\n一回合之后变为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ad1bwnz.png)\n\n再过一回合之后变为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2ax9h1tt.png)\n\n之后保持不变，最终连通块个数为 $5$。", "locale": "zh-CN"}}}
{"pid": "P10531", "type": "P", "difficulty": 5, "samples": [["4 2\n1 2 3 4\n1 2\n1 3\n1 4\n", "1\n"], ["4 2\n1 2 3 4\n1 2\n2 3\n3 4\n", "2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2024", "O2优化", "高校校赛"], "title": "[XJTUPC 2024] 圣诞树", "background": "", "description": "有一棵 $n$ 个点的树，点的编号为 $1\\sim n$，每个树的结点都有一个颜色，用 $col_i$ 表示。不同的 $col_i$ 代表不同的颜色。\n\n小 L 要用这棵树制作很多棵圣诞树。一棵树能够被制作成圣诞树，当且仅当它有至少 $k$ ​种不同的颜色。小 L 要把树分成若干互不相交的联通块，并且取出满足条件的联通块制作圣诞树。\n\n在给出这棵树的形态后，问最多能制作出多少棵圣诞树？", "inputFormat": "输入第一行两个正整数 $n,k$ ($1\\le k \\le n \\le 2\\times 10^5$)，用空格隔开。\n\n第二行 $n$ 个正整数 $col_i$ ($1\\le col_i \\le n$)，代表结点 $i$ 的颜色，两两之间用空格隔开。\n\n接下来 $n-1$ 行，每行两个正整数 $x,y$ ($1\\le x,y \\le n$，$x \\neq y$)，代表树上一条边的两个端点，用空格隔开。", "outputFormat": "输出一行一个整数，表示你的答案。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[XJTUPC 2024] 圣诞树", "background": "", "description": "有一棵 $n$ 个点的树，点的编号为 $1\\sim n$，每个树的结点都有一个颜色，用 $col_i$ 表示。不同的 $col_i$ 代表不同的颜色。\n\n小 L 要用这棵树制作很多棵圣诞树。一棵树能够被制作成圣诞树，当且仅当它有至少 $k$ ​种不同的颜色。小 L 要把树分成若干互不相交的联通块，并且取出满足条件的联通块制作圣诞树。\n\n在给出这棵树的形态后，问最多能制作出多少棵圣诞树？", "inputFormat": "输入第一行两个正整数 $n,k$ ($1\\le k \\le n \\le 2\\times 10^5$)，用空格隔开。\n\n第二行 $n$ 个正整数 $col_i$ ($1\\le col_i \\le n$)，代表结点 $i$ 的颜色，两两之间用空格隔开。\n\n接下来 $n-1$ 行，每行两个正整数 $x,y$ ($1\\le x,y \\le n$，$x \\neq y$)，代表树上一条边的两个端点，用空格隔开。", "outputFormat": "输出一行一个整数，表示你的答案。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10532", "type": "P", "difficulty": 4, "samples": [["2", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "2024", "O2优化", "高校校赛"], "title": "[XJTUPC 2024] 筛法", "background": "", "description": "在算法竞赛的数论知识中，我们接触过埃拉托斯特尼筛法、线性筛法、莫比乌斯反演、杜教筛、Powerful Number 筛、Min\\_25 筛、洲阁筛等算法来帮助我们优化一些求和/连乘的复杂度，那么现在问题来了，今天这道题将会使用到上述的哪个算法呢？\n\n现在给定正整数 $n$，需要你求 \n\n$$\n\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^n\\lfloor \\dfrac{n}{\\max(i,j)}\\rfloor [i \\perp j]\n$$\n\n其中 $[i \\perp j]$ 表示 $i,j$ 是否互素，即当 $\\gcd(i,j)=1$ 时，$[i \\perp j]$ 的值为 $1$，其余情况其值为 $0$。 ", "inputFormat": "输入一行一个正整数 $n$ ($1\\le n \\le 10^9$)。", "outputFormat": "输出一行一个整数，表示这个和式的结果。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[XJTUPC 2024] 筛法", "background": "", "description": "在算法竞赛的数论知识中，我们接触过埃拉托斯特尼筛法、线性筛法、莫比乌斯反演、杜教筛、Powerful Number 筛、Min\\_25 筛、洲阁筛等算法来帮助我们优化一些求和/连乘的复杂度，那么现在问题来了，今天这道题将会使用到上述的哪个算法呢？\n\n现在给定正整数 $n$，需要你求 \n\n$$\n\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^n\\lfloor \\dfrac{n}{\\max(i,j)}\\rfloor [i \\perp j]\n$$\n\n其中 $[i \\perp j]$ 表示 $i,j$ 是否互素，即当 $\\gcd(i,j)=1$ 时，$[i \\perp j]$ 的值为 $1$，其余情况其值为 $0$。 ", "inputFormat": "输入一行一个正整数 $n$ ($1\\le n \\le 10^9$)。", "outputFormat": "输出一行一个整数，表示这个和式的结果。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10533", "type": "P", "difficulty": 3, "samples": [["4\n-1 -1\n1 0\n1 -2\n-2 2", "Yes"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "搜索", "贪心", "O2优化"], "title": "[Opoi 2024] 热核武器", "background": "\n\n跳蚤国与蛐蛐国正在激战！\n\n![level](https://tse3-mm.cn.bing.net/th/id/OIP-C.ewEm2cQO23KvtiSwFQMFGQHaE8?w=293&h=195&c=7&r=0&o=5&pid=1.7)\n\n上面是战术核显卡，与题目没有关联。", "description": "跳蚤国的国土可以看作平面直角坐标系。\n\n跳蚤国有 $N+1$ 座城市，有 $1$ 座是首都，位于 $(0,0)$，另 $N$ 座是普通城市，在这里假设首都为 $0$ 号城市，其他城市编号为 $1$ 至 $N$，对于每一座普通城市，位于 $(x_i,y_i)$。\n\n\n由于跳蚤国财力有限，对于每一个不是首都的城市 $i$，它会选择一个城市 $j$ 修建一条双向公路。令 $dis(x,y)$ 为 $x$，$y$ 城市的欧几里得距离，**则对于每一个不是首都的城市 $i$，它所对应的 $j$ 则是满足 $dis(j,0) \\le dis(i,0)$ ，$j \\ne i$ 的所有点中 $dis(i,j)$ 最小的点，如有多个合法 $j$，取其中编号最小的一个。**\n\n定义一座城市的 $\\gamma$ 值为这个城市走到首都所需要的最小道路数 $+1$，**如果走不到首都，设 $\\gamma$ 值为 $0$。**\n\n蛐蛐国要对跳蚤国进行战术核显卡打击，这次行动分为两个组：洛伦兹组和安培组。每个组都要对跳蚤国的部分城市进行打击，其中两个组需要恰好把跳蚤国每个城市打击一遍。\n\n对于这两个组来说，名利是最重要的，而蛐蛐国的评功标准是按照本次行动所打击城市的 $\\gamma$ 值和。所以你需要求出：有没有一种划分方式使得洛伦兹组和安培组分别的打击城市的 $\\gamma$ 值和相等，可以，输出 ```Yes```，否则输出 ```No``` 。", "inputFormat": "第 $1$ 行输入一个整数 $N$，表示跳蚤国普通城市的数目。\n\n接下来第 $2 \\sim N+1$ 行，第 $i+1$ 行输入两个整数，表示第 $i$ 座城市的横纵坐标 $(x_i,y_i)$。", "outputFormat": "一行一个字符串，```Yes``` 或者 ```No```。表示是否会有一种方法使得洛伦兹组和安培组分别的打击城市的 $\\gamma$ 值和相等。", "hint": "### 样例解释\n\n这幅图是长这样的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dasec5pr.png)\n\n对于 $C1$，$C0$ 和 $C2$ 满足 $dis(j,0) \\le dis(C1,0)$，但是 $C0$ 离 $C1$ 距离更近，添加边 $(C1,C0)$。\n\n对于 $C2$，只有 $C0$ 满足 $dis(j,0) \\le dis(C2,0)$，添加边 $(C2,C0)$。\n\n对于 $C3$，$C0$，$C1$ 和 $C2$ 满足 $dis(j,0) \\le dis(C3,0)$，但是 $C2$ 离 $C3$ 距离最近，因此添加边 $(C3,C2)$。**注意这里是因为在 $C3$ 处考虑时，最优点为 $C2$，所以 $C3$ 才向 $C2$ 修建了一条公路，和公路 $(C2,C0)$ 完全独立。**\n\n对于 $C4$，其他所有点都满足 $dis(j,0) \\le dis(C4,0)$，但是 $C0$ 离 $C4$ 距离最近，添加边 $(C4,C0)$。\n\n得到下面的表：\n\n| 城市编号 | $\\gamma$ 值 |\n| :-----------: | :-----------: |\n| 0 | 1 |\n| 1 | 2 |\n| 2 | 2 |\n| 3 | 3 |\n| 4 | 2 |\n\n所以把 $0,1,2$ 分给洛伦兹组，$3,4$ 分给安培组即可。\n\n### 数据范围\n\n$1 \\le N \\le 500$，$-10^6 \\le x_i,y_i \\le 10^6$。\n\n### 特殊说明\n\n由于本题输出只有 ```Yes``` 和 ```No```，所以本题采用最小分值评测法，即取所有测试点的得分最小值作为结果。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Opoi 2024] 热核武器", "background": "\n\n跳蚤国与蛐蛐国正在激战！\n\n![level](https://tse3-mm.cn.bing.net/th/id/OIP-C.ewEm2cQO23KvtiSwFQMFGQHaE8?w=293&h=195&c=7&r=0&o=5&pid=1.7)\n\n上面是战术核显卡，与题目没有关联。", "description": "跳蚤国的国土可以看作平面直角坐标系。\n\n跳蚤国有 $N+1$ 座城市，有 $1$ 座是首都，位于 $(0,0)$，另 $N$ 座是普通城市，在这里假设首都为 $0$ 号城市，其他城市编号为 $1$ 至 $N$，对于每一座普通城市，位于 $(x_i,y_i)$。\n\n\n由于跳蚤国财力有限，对于每一个不是首都的城市 $i$，它会选择一个城市 $j$ 修建一条双向公路。令 $dis(x,y)$ 为 $x$，$y$ 城市的欧几里得距离，**则对于每一个不是首都的城市 $i$，它所对应的 $j$ 则是满足 $dis(j,0) \\le dis(i,0)$ ，$j \\ne i$ 的所有点中 $dis(i,j)$ 最小的点，如有多个合法 $j$，取其中编号最小的一个。**\n\n定义一座城市的 $\\gamma$ 值为这个城市走到首都所需要的最小道路数 $+1$，**如果走不到首都，设 $\\gamma$ 值为 $0$。**\n\n蛐蛐国要对跳蚤国进行战术核显卡打击，这次行动分为两个组：洛伦兹组和安培组。每个组都要对跳蚤国的部分城市进行打击，其中两个组需要恰好把跳蚤国每个城市打击一遍。\n\n对于这两个组来说，名利是最重要的，而蛐蛐国的评功标准是按照本次行动所打击城市的 $\\gamma$ 值和。所以你需要求出：有没有一种划分方式使得洛伦兹组和安培组分别的打击城市的 $\\gamma$ 值和相等，可以，输出 ```Yes```，否则输出 ```No``` 。", "inputFormat": "第 $1$ 行输入一个整数 $N$，表示跳蚤国普通城市的数目。\n\n接下来第 $2 \\sim N+1$ 行，第 $i+1$ 行输入两个整数，表示第 $i$ 座城市的横纵坐标 $(x_i,y_i)$。", "outputFormat": "一行一个字符串，```Yes``` 或者 ```No```。表示是否会有一种方法使得洛伦兹组和安培组分别的打击城市的 $\\gamma$ 值和相等。", "hint": "### 样例解释\n\n这幅图是长这样的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dasec5pr.png)\n\n对于 $C1$，$C0$ 和 $C2$ 满足 $dis(j,0) \\le dis(C1,0)$，但是 $C0$ 离 $C1$ 距离更近，添加边 $(C1,C0)$。\n\n对于 $C2$，只有 $C0$ 满足 $dis(j,0) \\le dis(C2,0)$，添加边 $(C2,C0)$。\n\n对于 $C3$，$C0$，$C1$ 和 $C2$ 满足 $dis(j,0) \\le dis(C3,0)$，但是 $C2$ 离 $C3$ 距离最近，因此添加边 $(C3,C2)$。**注意这里是因为在 $C3$ 处考虑时，最优点为 $C2$，所以 $C3$ 才向 $C2$ 修建了一条公路，和公路 $(C2,C0)$ 完全独立。**\n\n对于 $C4$，其他所有点都满足 $dis(j,0) \\le dis(C4,0)$，但是 $C0$ 离 $C4$ 距离最近，添加边 $(C4,C0)$。\n\n得到下面的表：\n\n| 城市编号 | $\\gamma$ 值 |\n| :-----------: | :-----------: |\n| 0 | 1 |\n| 1 | 2 |\n| 2 | 2 |\n| 3 | 3 |\n| 4 | 2 |\n\n所以把 $0,1,2$ 分给洛伦兹组，$3,4$ 分给安培组即可。\n\n### 数据范围\n\n$1 \\le N \\le 500$，$-10^6 \\le x_i,y_i \\le 10^6$。\n\n### 特殊说明\n\n由于本题输出只有 ```Yes``` 和 ```No```，所以本题采用最小分值评测法，即取所有测试点的得分最小值作为结果。\n", "locale": "zh-CN"}}}
{"pid": "P10534", "type": "P", "difficulty": 4, "samples": [["3\n3\n131011\n1\n5\n3\n2011\n", "Yes\nNo\nYes"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "O2优化"], "title": "[Opoi 2024] 简谐振动", "background": "你说得对，但是简谐振动十分优美。\n\n![pic](https://ts1.cn.mm.bing.net/th?id=OIP-C.uGsZxikgYriy7OYxJsbm0AHaD1&w=174&h=150&c=8&rs=1&qlt=90&o=6&pid=3.1&rm=2)\n\n![cip](https://tse4-mm.cn.bing.net/th/id/OIP-C.yNecd9xmljOtND3V6b4gcAHaEW?w=278&h=180&c=7&r=0&o=5&pid=1.7)\n\n![jzp](https://tse2-mm.cn.bing.net/th/id/OIP-C.GSxOJQ3KlXRC9V_y_crpigHaFj?w=230&h=180&c=7&r=0&o=5&pid=1.7)\n\n但是我们不出多边形下海，所以你不需要维护一个质点的简谐振动。", "description": "已知一个数字串 $S$，请你判断是否存在一种长度为 $n$ **且 $n$ 为奇数**的整数序列 $A_i$，使得 $A_1+A_2,A_2+A_3,\\dots,A_{n-1}+A_n,A_n+A_1$ 的值按顺序依次拼接起来可以得到 $S$。\n\n特别的，如果存在一种方案使得拼接的时候两项中间用 $[0,\\infty)$ 个 $0$ 分隔仍然可以得到 $S$，该方案仍然合法。**所有数据保证最前面没有前导 $0$。**", "inputFormat": "第一行一个整数，表示数据组数 $T$。\n\n接下来每组数据：\n\n第一行一个整数 $n$。\n\n第二行一个字符串 $S$。", "outputFormat": "对于每组数据，如果有解，输出 `Yes`，否则输出 `No`，用换行符分隔。", "hint": "### 样例解释\n第一组样例解释：\n\n$\\begin{matrix}\n7&6&4\\cr\n+&+&+\\cr\n6&4&7\\cr\n||&||&||\\cr\n13&10&11\\end{matrix}$\n\n当然，你也可以说：\n\n$\\begin{matrix}\n71&60&-60\\cr\n+&+&+\\cr\n60&-60&71\\cr\n||&||&||\\cr\n131&0&11\\end{matrix}$\n\n构造方法不唯一。\n\n第二组样例解释：\n\n如果有解，$A_1=2.5$，而题目说了 $A$ 为整数序列，故无解。\n\n第三组样例解释：\n\n$\\begin{matrix}\n1&&1&0\\cr\n+&&+&+\\cr\n1&&0&1\\cr\n||&&||&||\\cr\n2&0&1&1\\end{matrix}$\n\n> 该方案中间用了 $1 \\in [0,\\infty)$ 个 $0$ 分隔，符合要求，输出 `Yes`。\n\n---\n### 数据范围\n对于 $50\\%$ 的数据，$1\\le T \\le 10$，$1\\le |S| \\le 10$，$1 \\le n \\le 3$。\n\n对于 $100\\%$ 的数据，$1\\le T \\le 100$。保证 $\\sum n\\le 10^6$ 且 $\\sum|S|\\le 10^6$，${\\tt 0} \\le S_i \\le {\\tt 9}$，**且 $n$ 为奇数**。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Opoi 2024] 简谐振动", "background": "你说得对，但是简谐振动十分优美。\n\n![pic](https://ts1.cn.mm.bing.net/th?id=OIP-C.uGsZxikgYriy7OYxJsbm0AHaD1&w=174&h=150&c=8&rs=1&qlt=90&o=6&pid=3.1&rm=2)\n\n![cip](https://tse4-mm.cn.bing.net/th/id/OIP-C.yNecd9xmljOtND3V6b4gcAHaEW?w=278&h=180&c=7&r=0&o=5&pid=1.7)\n\n![jzp](https://tse2-mm.cn.bing.net/th/id/OIP-C.GSxOJQ3KlXRC9V_y_crpigHaFj?w=230&h=180&c=7&r=0&o=5&pid=1.7)\n\n但是我们不出多边形下海，所以你不需要维护一个质点的简谐振动。", "description": "已知一个数字串 $S$，请你判断是否存在一种长度为 $n$ **且 $n$ 为奇数**的整数序列 $A_i$，使得 $A_1+A_2,A_2+A_3,\\dots,A_{n-1}+A_n,A_n+A_1$ 的值按顺序依次拼接起来可以得到 $S$。\n\n特别的，如果存在一种方案使得拼接的时候两项中间用 $[0,\\infty)$ 个 $0$ 分隔仍然可以得到 $S$，该方案仍然合法。**所有数据保证最前面没有前导 $0$。**", "inputFormat": "第一行一个整数，表示数据组数 $T$。\n\n接下来每组数据：\n\n第一行一个整数 $n$。\n\n第二行一个字符串 $S$。", "outputFormat": "对于每组数据，如果有解，输出 `Yes`，否则输出 `No`，用换行符分隔。", "hint": "### 样例解释\n第一组样例解释：\n\n$\\begin{matrix}\n7&6&4\\cr\n+&+&+\\cr\n6&4&7\\cr\n||&||&||\\cr\n13&10&11\\end{matrix}$\n\n当然，你也可以说：\n\n$\\begin{matrix}\n71&60&-60\\cr\n+&+&+\\cr\n60&-60&71\\cr\n||&||&||\\cr\n131&0&11\\end{matrix}$\n\n构造方法不唯一。\n\n第二组样例解释：\n\n如果有解，$A_1=2.5$，而题目说了 $A$ 为整数序列，故无解。\n\n第三组样例解释：\n\n$\\begin{matrix}\n1&&1&0\\cr\n+&&+&+\\cr\n1&&0&1\\cr\n||&&||&||\\cr\n2&0&1&1\\end{matrix}$\n\n> 该方案中间用了 $1 \\in [0,\\infty)$ 个 $0$ 分隔，符合要求，输出 `Yes`。\n\n---\n### 数据范围\n对于 $50\\%$ 的数据，$1\\le T \\le 10$，$1\\le |S| \\le 10$，$1 \\le n \\le 3$。\n\n对于 $100\\%$ 的数据，$1\\le T \\le 100$。保证 $\\sum n\\le 10^6$ 且 $\\sum|S|\\le 10^6$，${\\tt 0} \\le S_i \\le {\\tt 9}$，**且 $n$ 为奇数**。", "locale": "zh-CN"}}}
{"pid": "P10535", "type": "P", "difficulty": 3, "samples": [["4 4\n5 8 10\n7 8 2\n2 3 1\n5 6 5\n1 4", "8"], ["4 1\n2 3 1\n1 8", "I have no idea how to solve it."], ["4 1\n2 3 1\n1 5", "0"], ["5 10\n1 2 603124134\n2 3 373980902\n2 4 6578324\n3 5 936364479\n4 6 182080546\n4 7 340293479\n6 8 753053273\n1 9 274129271\n3 10 616764767\n4 6 255802600\n1 2", "3673658542"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "最短路"], "title": "[Opoi 2024] 数据转换", "background": "![](data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAsJCQcJCQcJCQkJCwkJCQkJCQsJCwsMCwsLDA0QDBEODQ4MEhkSJRodJR0ZHxwpKRYlNzU2GioyPi0pMBk7IRP/2wBDAQcICAsJCxULCxUsHRkdLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCz/wAARCAC0AKsDASIAAhEBAxEB/8QAHAAAAQQDAQAAAAAAAAAAAAAAAAEEBgcCAwUI/8QAPBAAAgEDAgQEBAIGCgMAAAAAAQIDAAQRBSEGEjFBE1FhcSKBkaEUMgcjQlKx0RUkQ1NicpLB8PFjgqL/xAAYAQEBAQEBAAAAAAAAAAAAAAAAAQIDBP/EAB0RAQEAAgMBAQEAAAAAAAAAAAABAhEhMUESA1H/2gAMAwEAAhEDEQA/ALY3pDS4oxUGplzXPvLKOdGVlyCCK6pFYMuRQVFxLwasniTW6Ybc4AquJ4LzTpuWRWGDscHBr0xcWySKwIFQniDhi2u0kIjGTnoKCCcN8VXulzo8Uh5TgSRk/C49qunROINO1uAPbvyzKB4sLH41PmPSvPWqaPeaVMxCsYg2zYO3vTrR9cu7KaOSCZoplIwwOPlQek80VFeGuK7bWI0guGSO9AHfAl9h51KqBaKKKAzRRRQJS0UUBRRRQFFFFAUUUUCUUZooCkxS0UGtlBprNArgginprBgKCGaxokNykmYwcg5yNjVTa7w3c6fJJcWysYQSWUdU9R6V6DmhDA7VHtR0xJQ/wjv260FHadqk1vIhDsroQVYEggirj4W41ivhFZ6iyrNgLFcZ+F+wEnr61X3EPCboZLqwjwwy0kKjr6p/Kota309s4UllKt6ggig9TAgjIOe9FVJoX6Q5bG1MN7EbtEjzCRII2THZ3bO1day/SZDJJD+L01/w0rY8WxZpmjHmyEAke1BY1Fa4Z4LiGK4gkWSCVBJHIp+FkIzneswysAykMp3BUgg+xFAtFFFAUUUUBRRRQFFFFA1tLu2vbeG5tpFkhmUOjKe3kfUd6c1S3CfFU+lSrHITJp8zL48WSWjJ28WL1Hcd/erjgnhuIopoZEkilRZIpEOVdW3BBoN1FFFAUlLRQa2XNNZoQwO1PK1sOtBHL2xDZIXeq84m4Vhnjub62CxXEMck0oxhJVRSx9mq3JowQdq4t9ZxukqOuUkV43HmrAqRQeeFk3UPkxruV7MR0zXTtLyQyr4hCxMvIkagBFHYttW7iHh680W4bKl7SWTFvMBsQRnkbyYVygCERh5DmqiTrLcJALaOWUWwYv8AhxI/hc56sEzy5+VdbReJNX0R/wCqS89sWzJaz5aFj3wM5B9R96jFldhlWJz8Q2UnuPKn+N8j/uoq6dD4r0bW+SJH/DXxG9rORlj/AOJ+jfx9KkFed1O4IyCpBG+CCOhBFWBw1xw0fh2OuSFk2SG+bdk7BbjuR/i+vmCLIorFWV1V1ZWV1DKykFWUjIII2xWVAUUUUBRRRQeWrW4kgkMcmQVOCDsQRVl8F8TJYSLYXcmLC5cGJ2Pw207bZP8Agb9ryO/c1HOL+Hnt3a+t0/Kf1yqO37386j9hcZHIx9MHp7Vdj0ypBxWdVzwvxpp8FlHY6zcSI9vyx20/hyyh4MbLIUBOV6Zx0x5VP7a6tbyCK5tZopoJV5o5YWDIw6bEfeoN9JS0hoCsTisqSg0suaY3EfMDXQYVokXNBDdbsY7qGSGaNXiYZZWGRkbgj1Haqg1C3W0vby2XPLFKVXm68pAIzV+XcCuCMdqqXjPSJLS+N+gJguuVZB/dyqoXf0bGR86CGhijH93O3pXVtL3okjeXK3+xrlHqfekVipyvQdR8uooJLnODn2IpSeUZYgAdScAfU1ybe6YhYy7AE4yoBI7Y3/lT1VDnmSEyN1D3DHHuAcn7VVS7hrjW50do7WZZrvTMgGNBl7fJ3aFnIGPNc49j1t20u7S+t4bq1lSWCZeaN0Ox9COoI7ivOpbflecsT/Z2w+xIyfuK7fD2varoFwXtIlNrMwN3b3ErETAbcw5c4fyOffI2qIvaiudpOsadrNqt1ZSZAws0T4EsDn9mRR9j0NdGgWiiigimq2CXCOpUHmBUgjYg7YqidQjjs9T1G1tG/VxXU0au2DgIxUn+OK9HzpkE+W49xVF8RaNaWvEGrQKzGF3W6jVMqEEw5zESR+ySRt/09HIS5jaIW4Se6blw5QYG++7VM/0f6++k6l/R1148Om6jnBuW54oLsAckgkHQN+Vs+h7VGooYoVCRqFX0z9yazyaovmDWtCubhbS31OxmuWzyxwzo5bAyQpBwT6A10a88RSyxSRyxOySxOskboSHR1OVZSO47VPdN/SLcxIkeq2PjsuAbi1ZYnb1eJ/gz7MPaoLKpKY6XqthrNnFfWTsYXZ0ZZAFkjkQ4ZJFBOCPfuD0NPqDE1qYZrca1kUDKZMg1H9a0yG/tZ4JEDB1I9fcevlUndc0zmjzmg876np1zpt1LBMpwCfDfGzrnr7+dMB1Py/hVz8ScPw6hC5CfGBkEdQfMVUd9p9zYTPFKp6nlbGzAeVA1GQcjr/GnkFyo5VcFkBOVJOxPpTOgZBBXqfpQd78TbxqMMgUjYAAfYU3k1NF2jUsfNtvsKY2ttJeXcNqssMckzciNO/hRc5/KrOQQM9ATtv8AMTKw4Bm5j/Sdx4RU4aGHdgeu7Hapcpj21Jb0jllr2uWFzHeWF08E0fTk5eR16lJUxgqe4NeiNIvZNR0rR9QkRI5L7T7S7kRM8qPNEshC53xvtVZT8E6DJCIo/HtpgCFnRzIckYBdGPKR9PerG0OMWukaNZ+IkjWVhaWkjR55S8MSxkgNvg42qTKXouNjrUtYA0taZNJRs2SqjBLMxwqqBkknyFU1xFqtnrOpPdWYP4WKJLWCRwQ0yRlj4hB6A5OB5Y71c7Kr5jbdZAY2z3DjkP8AGvPAQ2l3d2TEERyyLGc7EKxXb6U9Un4lmx4VvK4/efljX3HNvj5Umb99s28QPTAaRv8A6wPtTnHl7/KkKhgFIzuNvWqG/wCHkfPi3EzjoVVgiZ9kxSeDHb4kiBCrtKoJPMh74Pcda2xlvjVHRuViMFdjv15h9+tZqyONiCcDmXIOM9jiglXBOuf0XqiWs0mLHVHjgck/DFck8sMvsc8je4/dq3815yReXngboBmPtmM7YyPLp9KufhDXTrGloJ35r+wKW14Sfil2/V3B/wA46+oNESasSKM0VBgwpu6ZzToitbLQc2aIHIIqI8QcPwX0UhCDmxnbrnzBFTh0zTSWIEHIoPPuo6bc2MzI6nlyeVugPofX+NMgOlXLrmhQXkUh5ASQcjHWqt1PS7jT5W5lYxk7Meo9GoGlkM31uM4Pix4PqCKuWyuwsccNxzGEKBHIoLSW/sBuU8x1Hb9009pkTyanZoqli0yYA8gck1a8IwAPQCuP6umDtGF/gGYeRlDxyFv1boejIy5yP+dq2RzPayq0MvPjZ8KVjb2Db/amFrO8R8Ir4lvIxJizysjn9uJjnB/eGMH33rVq2tafostnb3MUklxeRvNBHGVEYUOUBllfOCTnACHp9eWMt6btnqZWl3FcrldnH5kPUeo9Kd5FQWy1Fry3kuHha3mjdFtRaMzyLKVY55nIHL55wMdqm6Z5E5sFuVeYjYE43OK9EycrGh25Cp8mB+hzVAcRxPbaxqY5Sr22o3gx5oZmYfLer8lGc1VH6QrAx31vqKp8F2ggmIG3ixLgE+64/wBNa9RGkcSIki9CM/XtSODysAM59cZHlmmto5Rnt27fHGT3U08LIBuQPc1oa8MBGwTBX4eVcH4PKtgHpjO5Hr61pe7to85dflvTWTVIh+RSfegfSoWCMuBJG2Vz0IOxU+hH/Nq6+hau+h6nb3w5jbkeBfRruZLVyCSB5psy+2P2qiL6ncN+UBa1+NcyfnkfB7DYUHpyOSORUkjdXjkVXjdDlXRhzKykdiNxW0GolwFO83Cuhc7EtElzb5J35YbmVFHyGKlgqIyrEisxRig0staHTNOyKwZKDmSwgg7bVHNX0OK7R8IMkHtUwaPNamhBHQVBTk3Dd1a3CzQK6SRuGR0JBUjuKkljcTSKqXChZwMNgYV/Vf5VMp7KNwcqD8q5Fxpig8yrgjfasZTbUumiFSzqASCdgVxkH0yCPtXA4rgluL7TeYPJ4dlglsFsmeRtsY6dq7yq6MBIHKg8x5CwbC77cu9P5YrG7lSTwS5WNUXxD4cYAJOcAFu9c8ZY1ld9ORo8JexZ8A+DOuVOQXdk8NVXHU5OMevpVghhgZOD3HlXGtLSGN45Pg/V5aKKJAkSORjnI3JbGwJPeunzV0xmuWL/AASDY1G+ItMTVNPu7Ugc7rzQsf2Jk+JD9dj6GpO42phcJkEVtHny5SaMId454JGhcEbjqCCPQiue8lw7cpZmJ7Dv9Km/G+mmzvDdIuIb0q7EdBOuzD5jB+tcbhOa3t9fsZJ0Dp+sTlYAg8wKkEHbcZx64pvhXMtdF1i9I8C1mcHvyED6tipDY8A6tOf6zcWdoOUuRPL8fICASqqMnqO1WVqt3pOhwi6vHeO0Z0SJoIWl5jIvOgwuAMjuSK5ml8S6Jrd5Pa2kNwskEPjJLcLHiReYIwXkzgjbYtv8t+f3bGvlx7bgHS48GW8NyuSOeD4Y2Kkg8pIz6V0peDNBezlgW3aIsMxzqW5klx8JJOxHmK7l4Lx7W5jsphb3bRkW8xVWEb9RkMCMHodu9R/TdG4rjv7fUdW4hkuXhDgwIHkjdHGDHmQhQD6J2rO7fWtOzwNFNZ6GllOvLPZ6hqdvKN93Wctn55GKmCGuHZPySlDsspyNsESAY3PqB9vWu2g2FdZdxzs03rWVIgrKtITFIRWVFBqK1gUpxiseUVA2Mee1aJLcEHauhyigoKio/NY56CtUdpIpqQmMeVazCPKmjZnBEVG9OeX0raI8VnyVUIwzTaVOtPSK1Ouaoh/E2jJqun3Fucq/wyROACUdDkHB+YPvVUx6TeWOoQNJHIY45lLsqkELn8w9utX7JECDtXAvtOikLHkGfas1SWYg1LTmsrmKOY24VgkyLIjw5yuVYEfCenuKyiiiiURxxJGg25Y0VFGPILgUwhluNOEs0KB5baOQpG5IWVWHLytjfHQ/KuM11x7fzOY2itYeb4Vt4UiPLjqZGy+fnXn1y6y8JYUZVLvhEA/PKwRfL8zYFc661rQLJWefUYSVblKWoa4fOcYxGCv3rirwtqN24k1C/kkY/vu8zdc4zIf9qfpw7oNqB47hz3Ejjf8A9R/KunOtM/RjccbWCRSvY6deXDRhmJndLcLyn83KgZtuvWrIt3EsUMn95HG/+pQ1RGO00vw3jtLBZSyMowiIhyMfE0mNvlUosVeK2tInKl44Io3K/l5lUA8vpWsZpm3boL0rPtWCmsxXRktFFFAmKMUtFAmKMUtFBjikIrLFFBjilxS4paDGsSKzpDQaHWmcsQOdq6JUVqaPPapRGbyBkLOgHNgjB6H3rlXGrX0YwkMS422y38dvtUwmtQ4O1cefSY3YkjrWdKiUuoarcEgyyBTkYQlRv/lwPtWUFvduQcOfepTHpMCf2Yp7HZIuMKPpTQ5unQTpy8w2qRQKcDNa44AvQU8jTFaiNi1sFYqKzqgpaBRQFJS0UCUUtFAlFFFAUUtFAlFFFAlJWVGKDWVFaGiBPSnNJiga+EKyEYrfyilxQawnStgGKXFLQAFLRRQLRRRQFFJS0BRSUtAUUlFAtFFJQLgUUUVQUYoooDAo5RRRQGBSYFFFAuBRRRQFFFFAUUUUBRRRQFFFFAUUUUBRRRQf/9k=)\n\n![](https://tse2-mm.cn.bing.net/th/id/OIP-C.ojcWO_62WQhtFFaZSdmbgAHaEo?w=244&h=180&c=7&r=0&o=5&pid=1.7)\n\nArrda 家里面有很多五花八门的用电器和数据线，而且很多用电器的插头种类都不一样，这导致每次 Arrda 想要共享两个用电器的数据时都要一半天用来买到合适的数据线，而且有的时候数据线很贵！\n\n于是 Arrda 想让你求出花钱最少的数据转换方案。", "description": "Arrda 家中有 $n$ 类，$2n$ 种数据线接头，每一类插头有 $2$ 种不同接头，种类分别为 $i$ 和 $n+i$，**有且只有同一类的不同接头可以互相连接（你可以理解为 $i$ 是凸出的接头，$n + i$ 是凹的接头，可以连接可以理解为插上）**。\n\n商城里售卖着 $m$ 种双向数据线，每根双向数据线两端各有一个接头，种类分别为为 $u_i,v_i$。同时，第 $i$ 种双向数据线有一个购买价格 $w_i$，每种数据线可以购买无限条。\n\nArrda 想要交换两个用电器的数据，其中两个用电器的接头种类编号为 $S,T$，求能使这两个用电器能直接或由若干条数据线相连的最小总价格（毕竟买数据线需要钱），如果无解，输出 `I have no idea how to solve it.`，注意，**两个用电器的接口不能直接连接数据线，因为它们在用电器上，而非数据线两端！**", "inputFormat": "第一行两个整数 $n,m$，意义见题面。\n\n接下来 $m$ 行，每行三个整数 $u_i,v_i,w_i$。\n\n接下来一行两个整数 $S,T$。", "outputFormat": "一个非负整数表示能使这两个用电器能直接或由若干条数据线相连的最小总价格。\n\n若无解，请输出 `I have no idea how to solve it.`。", "hint": "### 样例 1 解释：\n\n![picture](https://cdn.luogu.com.cn/upload/image_hosting/4j95t4xl.png)\n\n```\n1=5->6=2->3=7->8=4\n```\n\n可以证明，没有总代价更小的方案。\n\n### 样例 4 解释\n\n![222](https://cdn.luogu.com.cn/upload/image_hosting/k88cjz1t.png)\n\n```\n1=6->8=3->5=10->3=8->6=1->9=4->7=2\n```\n`4->6` 有两种数据线，我们选择代价为 $182080546$ 的那一根，因为其代价更小。\n\n可以证明，没有总代价更小的方案。\n\n### 数据范围\n\n对于 $100\\%$ 的数据，$1\\le n,m \\le 10^5$，$1\\le u_i,v_i,s,t \\le 2 \\times n$，$1\\le w_i \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Opoi 2024] 数据转换", "background": "![](data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAsJCQcJCQcJCQkJCwkJCQkJCQsJCwsMCwsLDA0QDBEODQ4MEhkSJRodJR0ZHxwpKRYlNzU2GioyPi0pMBk7IRP/2wBDAQcICAsJCxULCxUsHRkdLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCz/wAARCAC0AKsDASIAAhEBAxEB/8QAHAAAAQQDAQAAAAAAAAAAAAAAAAEEBgcCAwUI/8QAPBAAAgEDAgQEBAIGCgMAAAAAAQIDAAQRBSEGEjFBE1FhcSKBkaEUMgcjQlKx0RUkQ1NicpLB8PFjgqL/xAAYAQEBAQEBAAAAAAAAAAAAAAAAAQIDBP/EAB0RAQEAAgMBAQEAAAAAAAAAAAABAhEhMUESA1H/2gAMAwEAAhEDEQA/ALY3pDS4oxUGplzXPvLKOdGVlyCCK6pFYMuRQVFxLwasniTW6Ybc4AquJ4LzTpuWRWGDscHBr0xcWySKwIFQniDhi2u0kIjGTnoKCCcN8VXulzo8Uh5TgSRk/C49qunROINO1uAPbvyzKB4sLH41PmPSvPWqaPeaVMxCsYg2zYO3vTrR9cu7KaOSCZoplIwwOPlQek80VFeGuK7bWI0guGSO9AHfAl9h51KqBaKKKAzRRRQJS0UUBRRRQFFFFAUUUUCUUZooCkxS0UGtlBprNArgginprBgKCGaxokNykmYwcg5yNjVTa7w3c6fJJcWysYQSWUdU9R6V6DmhDA7VHtR0xJQ/wjv260FHadqk1vIhDsroQVYEggirj4W41ivhFZ6iyrNgLFcZ+F+wEnr61X3EPCboZLqwjwwy0kKjr6p/Kota309s4UllKt6ggig9TAgjIOe9FVJoX6Q5bG1MN7EbtEjzCRII2THZ3bO1day/SZDJJD+L01/w0rY8WxZpmjHmyEAke1BY1Fa4Z4LiGK4gkWSCVBJHIp+FkIzneswysAykMp3BUgg+xFAtFFFAUUUUBRRRQFFFFA1tLu2vbeG5tpFkhmUOjKe3kfUd6c1S3CfFU+lSrHITJp8zL48WSWjJ28WL1Hcd/erjgnhuIopoZEkilRZIpEOVdW3BBoN1FFFAUlLRQa2XNNZoQwO1PK1sOtBHL2xDZIXeq84m4Vhnjub62CxXEMck0oxhJVRSx9mq3JowQdq4t9ZxukqOuUkV43HmrAqRQeeFk3UPkxruV7MR0zXTtLyQyr4hCxMvIkagBFHYttW7iHh680W4bKl7SWTFvMBsQRnkbyYVygCERh5DmqiTrLcJALaOWUWwYv8AhxI/hc56sEzy5+VdbReJNX0R/wCqS89sWzJaz5aFj3wM5B9R96jFldhlWJz8Q2UnuPKn+N8j/uoq6dD4r0bW+SJH/DXxG9rORlj/AOJ+jfx9KkFed1O4IyCpBG+CCOhBFWBw1xw0fh2OuSFk2SG+bdk7BbjuR/i+vmCLIorFWV1V1ZWV1DKykFWUjIII2xWVAUUUUBRRRQeWrW4kgkMcmQVOCDsQRVl8F8TJYSLYXcmLC5cGJ2Pw207bZP8Agb9ryO/c1HOL+Hnt3a+t0/Kf1yqO37386j9hcZHIx9MHp7Vdj0ypBxWdVzwvxpp8FlHY6zcSI9vyx20/hyyh4MbLIUBOV6Zx0x5VP7a6tbyCK5tZopoJV5o5YWDIw6bEfeoN9JS0hoCsTisqSg0suaY3EfMDXQYVokXNBDdbsY7qGSGaNXiYZZWGRkbgj1Haqg1C3W0vby2XPLFKVXm68pAIzV+XcCuCMdqqXjPSJLS+N+gJguuVZB/dyqoXf0bGR86CGhijH93O3pXVtL3okjeXK3+xrlHqfekVipyvQdR8uooJLnODn2IpSeUZYgAdScAfU1ybe6YhYy7AE4yoBI7Y3/lT1VDnmSEyN1D3DHHuAcn7VVS7hrjW50do7WZZrvTMgGNBl7fJ3aFnIGPNc49j1t20u7S+t4bq1lSWCZeaN0Ox9COoI7ivOpbflecsT/Z2w+xIyfuK7fD2varoFwXtIlNrMwN3b3ErETAbcw5c4fyOffI2qIvaiudpOsadrNqt1ZSZAws0T4EsDn9mRR9j0NdGgWiiigimq2CXCOpUHmBUgjYg7YqidQjjs9T1G1tG/VxXU0au2DgIxUn+OK9HzpkE+W49xVF8RaNaWvEGrQKzGF3W6jVMqEEw5zESR+ySRt/09HIS5jaIW4Se6blw5QYG++7VM/0f6++k6l/R1148Om6jnBuW54oLsAckgkHQN+Vs+h7VGooYoVCRqFX0z9yazyaovmDWtCubhbS31OxmuWzyxwzo5bAyQpBwT6A10a88RSyxSRyxOySxOskboSHR1OVZSO47VPdN/SLcxIkeq2PjsuAbi1ZYnb1eJ/gz7MPaoLKpKY6XqthrNnFfWTsYXZ0ZZAFkjkQ4ZJFBOCPfuD0NPqDE1qYZrca1kUDKZMg1H9a0yG/tZ4JEDB1I9fcevlUndc0zmjzmg876np1zpt1LBMpwCfDfGzrnr7+dMB1Py/hVz8ScPw6hC5CfGBkEdQfMVUd9p9zYTPFKp6nlbGzAeVA1GQcjr/GnkFyo5VcFkBOVJOxPpTOgZBBXqfpQd78TbxqMMgUjYAAfYU3k1NF2jUsfNtvsKY2ttJeXcNqssMckzciNO/hRc5/KrOQQM9ATtv8AMTKw4Bm5j/Sdx4RU4aGHdgeu7Hapcpj21Jb0jllr2uWFzHeWF08E0fTk5eR16lJUxgqe4NeiNIvZNR0rR9QkRI5L7T7S7kRM8qPNEshC53xvtVZT8E6DJCIo/HtpgCFnRzIckYBdGPKR9PerG0OMWukaNZ+IkjWVhaWkjR55S8MSxkgNvg42qTKXouNjrUtYA0taZNJRs2SqjBLMxwqqBkknyFU1xFqtnrOpPdWYP4WKJLWCRwQ0yRlj4hB6A5OB5Y71c7Kr5jbdZAY2z3DjkP8AGvPAQ2l3d2TEERyyLGc7EKxXb6U9Un4lmx4VvK4/efljX3HNvj5Umb99s28QPTAaRv8A6wPtTnHl7/KkKhgFIzuNvWqG/wCHkfPi3EzjoVVgiZ9kxSeDHb4kiBCrtKoJPMh74Pcda2xlvjVHRuViMFdjv15h9+tZqyONiCcDmXIOM9jiglXBOuf0XqiWs0mLHVHjgck/DFck8sMvsc8je4/dq3815yReXngboBmPtmM7YyPLp9KufhDXTrGloJ35r+wKW14Sfil2/V3B/wA46+oNESasSKM0VBgwpu6ZzToitbLQc2aIHIIqI8QcPwX0UhCDmxnbrnzBFTh0zTSWIEHIoPPuo6bc2MzI6nlyeVugPofX+NMgOlXLrmhQXkUh5ASQcjHWqt1PS7jT5W5lYxk7Meo9GoGlkM31uM4Pix4PqCKuWyuwsccNxzGEKBHIoLSW/sBuU8x1Hb9009pkTyanZoqli0yYA8gck1a8IwAPQCuP6umDtGF/gGYeRlDxyFv1boejIy5yP+dq2RzPayq0MvPjZ8KVjb2Db/amFrO8R8Ir4lvIxJizysjn9uJjnB/eGMH33rVq2tafostnb3MUklxeRvNBHGVEYUOUBllfOCTnACHp9eWMt6btnqZWl3FcrldnH5kPUeo9Kd5FQWy1Fry3kuHha3mjdFtRaMzyLKVY55nIHL55wMdqm6Z5E5sFuVeYjYE43OK9EycrGh25Cp8mB+hzVAcRxPbaxqY5Sr22o3gx5oZmYfLer8lGc1VH6QrAx31vqKp8F2ggmIG3ixLgE+64/wBNa9RGkcSIki9CM/XtSODysAM59cZHlmmto5Rnt27fHGT3U08LIBuQPc1oa8MBGwTBX4eVcH4PKtgHpjO5Hr61pe7to85dflvTWTVIh+RSfegfSoWCMuBJG2Vz0IOxU+hH/Nq6+hau+h6nb3w5jbkeBfRruZLVyCSB5psy+2P2qiL6ncN+UBa1+NcyfnkfB7DYUHpyOSORUkjdXjkVXjdDlXRhzKykdiNxW0GolwFO83Cuhc7EtElzb5J35YbmVFHyGKlgqIyrEisxRig0staHTNOyKwZKDmSwgg7bVHNX0OK7R8IMkHtUwaPNamhBHQVBTk3Dd1a3CzQK6SRuGR0JBUjuKkljcTSKqXChZwMNgYV/Vf5VMp7KNwcqD8q5Fxpig8yrgjfasZTbUumiFSzqASCdgVxkH0yCPtXA4rgluL7TeYPJ4dlglsFsmeRtsY6dq7yq6MBIHKg8x5CwbC77cu9P5YrG7lSTwS5WNUXxD4cYAJOcAFu9c8ZY1ld9ORo8JexZ8A+DOuVOQXdk8NVXHU5OMevpVghhgZOD3HlXGtLSGN45Pg/V5aKKJAkSORjnI3JbGwJPeunzV0xmuWL/AASDY1G+ItMTVNPu7Ugc7rzQsf2Jk+JD9dj6GpO42phcJkEVtHny5SaMId454JGhcEbjqCCPQiue8lw7cpZmJ7Dv9Km/G+mmzvDdIuIb0q7EdBOuzD5jB+tcbhOa3t9fsZJ0Dp+sTlYAg8wKkEHbcZx64pvhXMtdF1i9I8C1mcHvyED6tipDY8A6tOf6zcWdoOUuRPL8fICASqqMnqO1WVqt3pOhwi6vHeO0Z0SJoIWl5jIvOgwuAMjuSK5ml8S6Jrd5Pa2kNwskEPjJLcLHiReYIwXkzgjbYtv8t+f3bGvlx7bgHS48GW8NyuSOeD4Y2Kkg8pIz6V0peDNBezlgW3aIsMxzqW5klx8JJOxHmK7l4Lx7W5jsphb3bRkW8xVWEb9RkMCMHodu9R/TdG4rjv7fUdW4hkuXhDgwIHkjdHGDHmQhQD6J2rO7fWtOzwNFNZ6GllOvLPZ6hqdvKN93Wctn55GKmCGuHZPySlDsspyNsESAY3PqB9vWu2g2FdZdxzs03rWVIgrKtITFIRWVFBqK1gUpxiseUVA2Mee1aJLcEHauhyigoKio/NY56CtUdpIpqQmMeVazCPKmjZnBEVG9OeX0raI8VnyVUIwzTaVOtPSK1Ouaoh/E2jJqun3Fucq/wyROACUdDkHB+YPvVUx6TeWOoQNJHIY45lLsqkELn8w9utX7JECDtXAvtOikLHkGfas1SWYg1LTmsrmKOY24VgkyLIjw5yuVYEfCenuKyiiiiURxxJGg25Y0VFGPILgUwhluNOEs0KB5baOQpG5IWVWHLytjfHQ/KuM11x7fzOY2itYeb4Vt4UiPLjqZGy+fnXn1y6y8JYUZVLvhEA/PKwRfL8zYFc661rQLJWefUYSVblKWoa4fOcYxGCv3rirwtqN24k1C/kkY/vu8zdc4zIf9qfpw7oNqB47hz3Ejjf8A9R/KunOtM/RjccbWCRSvY6deXDRhmJndLcLyn83KgZtuvWrIt3EsUMn95HG/+pQ1RGO00vw3jtLBZSyMowiIhyMfE0mNvlUosVeK2tInKl44Io3K/l5lUA8vpWsZpm3boL0rPtWCmsxXRktFFFAmKMUtFAmKMUtFBjikIrLFFBjilxS4paDGsSKzpDQaHWmcsQOdq6JUVqaPPapRGbyBkLOgHNgjB6H3rlXGrX0YwkMS422y38dvtUwmtQ4O1cefSY3YkjrWdKiUuoarcEgyyBTkYQlRv/lwPtWUFvduQcOfepTHpMCf2Yp7HZIuMKPpTQ5unQTpy8w2qRQKcDNa44AvQU8jTFaiNi1sFYqKzqgpaBRQFJS0UCUUtFAlFFFAUUtFAlFFFAlJWVGKDWVFaGiBPSnNJiga+EKyEYrfyilxQawnStgGKXFLQAFLRRQLRRRQFFJS0BRSUtAUUlFAtFFJQLgUUUVQUYoooDAo5RRRQGBSYFFFAuBRRRQFFFFAUUUUBRRRQFFFFAUUUUBRRRQf/9k=)\n\n![](https://tse2-mm.cn.bing.net/th/id/OIP-C.ojcWO_62WQhtFFaZSdmbgAHaEo?w=244&h=180&c=7&r=0&o=5&pid=1.7)\n\nArrda 家里面有很多五花八门的用电器和数据线，而且很多用电器的插头种类都不一样，这导致每次 Arrda 想要共享两个用电器的数据时都要一半天用来买到合适的数据线，而且有的时候数据线很贵！\n\n于是 Arrda 想让你求出花钱最少的数据转换方案。", "description": "Arrda 家中有 $n$ 类，$2n$ 种数据线接头，每一类插头有 $2$ 种不同接头，种类分别为 $i$ 和 $n+i$，**有且只有同一类的不同接头可以互相连接（你可以理解为 $i$ 是凸出的接头，$n + i$ 是凹的接头，可以连接可以理解为插上）**。\n\n商城里售卖着 $m$ 种双向数据线，每根双向数据线两端各有一个接头，种类分别为为 $u_i,v_i$。同时，第 $i$ 种双向数据线有一个购买价格 $w_i$，每种数据线可以购买无限条。\n\nArrda 想要交换两个用电器的数据，其中两个用电器的接头种类编号为 $S,T$，求能使这两个用电器能直接或由若干条数据线相连的最小总价格（毕竟买数据线需要钱），如果无解，输出 `I have no idea how to solve it.`，注意，**两个用电器的接口不能直接连接数据线，因为它们在用电器上，而非数据线两端！**", "inputFormat": "第一行两个整数 $n,m$，意义见题面。\n\n接下来 $m$ 行，每行三个整数 $u_i,v_i,w_i$。\n\n接下来一行两个整数 $S,T$。", "outputFormat": "一个非负整数表示能使这两个用电器能直接或由若干条数据线相连的最小总价格。\n\n若无解，请输出 `I have no idea how to solve it.`。", "hint": "### 样例 1 解释：\n\n![picture](https://cdn.luogu.com.cn/upload/image_hosting/4j95t4xl.png)\n\n```\n1=5->6=2->3=7->8=4\n```\n\n可以证明，没有总代价更小的方案。\n\n### 样例 4 解释\n\n![222](https://cdn.luogu.com.cn/upload/image_hosting/k88cjz1t.png)\n\n```\n1=6->8=3->5=10->3=8->6=1->9=4->7=2\n```\n`4->6` 有两种数据线，我们选择代价为 $182080546$ 的那一根，因为其代价更小。\n\n可以证明，没有总代价更小的方案。\n\n### 数据范围\n\n对于 $100\\%$ 的数据，$1\\le n,m \\le 10^5$，$1\\le u_i,v_i,s,t \\le 2 \\times n$，$1\\le w_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10536", "type": "P", "difficulty": 6, "samples": [["7\n2 1 1 9 8 5 1\nzzabcad\n1 2\n2 3\n3 4\n3 5\n5 6\n5 7", "3\n3\n3\n1\n1\n1\n1\n"], ["12\n1 2 2 4 1 3 4 3 1 4 3 1 \nbaabbbbbbbaa\n4 6\n5 7\n1 2\n12 10\n8 2\n10 11\n5 9\n10 3\n2 3\n4 3\n4 5\n", "5\n4\n3\n1\n2\n1\n1\n1\n1\n1\n1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "树上启发式合并", "O2优化", "树链剖分", "单调栈"], "title": "[Opoi 2024] 二十六点", "background": "二十六点：\n\n> 。 。 。 。 。 。 。 。 。 。 。 。 。\n>\n> 。 。 。 。 。 。 。 。 。 。 。 。 。\n\n凑二十六点真好玩，而为了凑四道题，就有了这道权值只有 $26$ 种的凑数题。", "description": "\n给你一棵有 $n$ 个结点的以 $1$ 为根的树 $T$，第 $i$ 个结点有一个颜色 $c_i$，${\\tt a} \\le c_i \\le {\\tt z}$，和一个值 $P_i$。\n\n对于每一个点 $x$，**从它到它子树中每一个点**（注意顺序是从它本身到子树中的点）都有一条路径，一共有子树的大小条路径。\n\n现在忽略掉这些路径中的第 $2$ 到第 $P_x$ 个的点，特别地，若 $P_x = 1$ 则不忽略任何点。将忽略后的路径当作一个序列，序列中每个点的权值为路径上点的 $c_i$，求**每一个点的所有序列最长不下降子序列长度的最大值**。\n\n注: 若有路径 $j$ 上的节点数 $len_j < P_x$，则相当于忽略这条路径上除第一个点外的所有点。\n", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个整数 $P_i$。\n\n第三行 $n$ 个小写字母 $c_i$，**字符与字符间没有空格**。\n\n接下来 $n - 1$ 行，描述树 $T$，每行两个整数 $u,v$，表示 $u,v$ 存在一条边。\n\n行末可能有多余空格（慎用 `getchar()`）。", "outputFormat": "输出 $n$ 行，表示每一个点的答案，按照编号从小到大输出。", "hint": "\n\n### 样例一解释：\n\n样例中树的形态：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6vbio7vo.png?x-oss-process=image/resize,h_450,m_lfit)\n\n对于 $1$ 号节点：\n$P_1=2$。\n\n|  序列| 权值 | 最长不下降子序列长度 | 最长不下降子序列 |\n| :----------: | :----------: | :----------: | :----------: |\n| 1 | z | 1 | z |\n| 1 3 | za | 1 |  z |\n| 1 3 4 |  zab | 2  | ab |\n| 1 3 5  |  zac | 2 |  ac   |\n| 1 3 5 6 |  zaca | 2  | ac |\n| 1 3 5 7 | zacd| 3 | acd  |\n\n长度最长的最长不降子序列：acd。\n\n$2$ 号节点和 $1$ 号节点同理。\n\n对于 $3$ 号节点：\n$P_3=1$。\n\n|  序列| 权值 | 最长不下降子序列长度 | 最长不下降子序列 |\n| :----------: | :----------: | :----------: | :----------: |\n| 3 | a | 1 | a |\n| 3 4 | ab | 1 |  ab |\n| 3 5  |  ac | 2  | ac |\n| 3 5 6  |  aca | 2 |  ac   |\n|3 5 7   |  acd | 3  |acd |\n\n长度最长的最长不降子序列：acd。\n\n对于 $4,5,6,7$，它的所有序列中都只有它自己一个点，所以输出 $1$。\n### 数据范围\n\n本题采用 Subtask 计分。\n\n| Subtask | Limit | Pts |\n| :-----------: | :-----------: | :-----------: |\n| 0 | $n \\le 100$ | 5 |\n| 1 | $n \\le 2000$ | 15 |\n| 2 | $\\forall 1 \\le i \\le n \\quad P_i=1$ | 30 |\n| 3 | Empty | 50 |\n\n对于 $100\\%$ 的数据：\n\n$1 \\le n \\le 10^5$。\n\n$\\forall 1 \\le i \\le n$， $c_i$ 为小写字母，$1 \\le P_i \\le n$。\n\n给出的树连通且合法。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Opoi 2024] 二十六点", "background": "二十六点：\n\n> 。 。 。 。 。 。 。 。 。 。 。 。 。\n>\n> 。 。 。 。 。 。 。 。 。 。 。 。 。\n\n凑二十六点真好玩，而为了凑四道题，就有了这道权值只有 $26$ 种的凑数题。", "description": "\n给你一棵有 $n$ 个结点的以 $1$ 为根的树 $T$，第 $i$ 个结点有一个颜色 $c_i$，${\\tt a} \\le c_i \\le {\\tt z}$，和一个值 $P_i$。\n\n对于每一个点 $x$，**从它到它子树中每一个点**（注意顺序是从它本身到子树中的点）都有一条路径，一共有子树的大小条路径。\n\n现在忽略掉这些路径中的第 $2$ 到第 $P_x$ 个的点，特别地，若 $P_x = 1$ 则不忽略任何点。将忽略后的路径当作一个序列，序列中每个点的权值为路径上点的 $c_i$，求**每一个点的所有序列最长不下降子序列长度的最大值**。\n\n注: 若有路径 $j$ 上的节点数 $len_j < P_x$，则相当于忽略这条路径上除第一个点外的所有点。\n", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个整数 $P_i$。\n\n第三行 $n$ 个小写字母 $c_i$，**字符与字符间没有空格**。\n\n接下来 $n - 1$ 行，描述树 $T$，每行两个整数 $u,v$，表示 $u,v$ 存在一条边。\n\n行末可能有多余空格（慎用 `getchar()`）。", "outputFormat": "输出 $n$ 行，表示每一个点的答案，按照编号从小到大输出。", "hint": "\n\n### 样例一解释：\n\n样例中树的形态：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6vbio7vo.png?x-oss-process=image/resize,h_450,m_lfit)\n\n对于 $1$ 号节点：\n$P_1=2$。\n\n|  序列| 权值 | 最长不下降子序列长度 | 最长不下降子序列 |\n| :----------: | :----------: | :----------: | :----------: |\n| 1 | z | 1 | z |\n| 1 3 | za | 1 |  z |\n| 1 3 4 |  zab | 2  | ab |\n| 1 3 5  |  zac | 2 |  ac   |\n| 1 3 5 6 |  zaca | 2  | ac |\n| 1 3 5 7 | zacd| 3 | acd  |\n\n长度最长的最长不降子序列：acd。\n\n$2$ 号节点和 $1$ 号节点同理。\n\n对于 $3$ 号节点：\n$P_3=1$。\n\n|  序列| 权值 | 最长不下降子序列长度 | 最长不下降子序列 |\n| :----------: | :----------: | :----------: | :----------: |\n| 3 | a | 1 | a |\n| 3 4 | ab | 1 |  ab |\n| 3 5  |  ac | 2  | ac |\n| 3 5 6  |  aca | 2 |  ac   |\n|3 5 7   |  acd | 3  |acd |\n\n长度最长的最长不降子序列：acd。\n\n对于 $4,5,6,7$，它的所有序列中都只有它自己一个点，所以输出 $1$。\n### 数据范围\n\n本题采用 Subtask 计分。\n\n| Subtask | Limit | Pts |\n| :-----------: | :-----------: | :-----------: |\n| 0 | $n \\le 100$ | 5 |\n| 1 | $n \\le 2000$ | 15 |\n| 2 | $\\forall 1 \\le i \\le n \\quad P_i=1$ | 30 |\n| 3 | Empty | 50 |\n\n对于 $100\\%$ 的数据：\n\n$1 \\le n \\le 10^5$。\n\n$\\forall 1 \\le i \\le n$， $c_i$ 为小写字母，$1 \\le P_i \\le n$。\n\n给出的树连通且合法。", "locale": "zh-CN"}}}
{"pid": "P10537", "type": "P", "difficulty": 4, "samples": [["1\n3 1\n0 0\n1 2", "2"], ["1\n5 2\n0 0 1 1 \n1 2 3 4\n4 1 2 3", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["贪心", "2024", "APIO", "交互题"], "title": "[APIO2024] 九月", "background": "## 请勿使用 C++14(GCC9) 提交\n\n你无需在程序开头引入库 `september.h`。", "description": "杭州市的中心广场有一棵著名的古树。这棵古树可以看作一棵 $N$ 个节点的有根树，节点编号从 $0$ 到 $N - 1$，其中 $0$ 号节点是根节点。\n\n称没有孩子的节点为叶子节点。古树每次落叶时，会选择一个当前的叶子节点删去。每一天中，古树可能会多次落叶。\n\n有 $M$ 位志愿者（编号从 $0$ 到 $M - 1$）负责看护古树。每一位志愿者将各自按照如下方式独立记录今年的落叶的情况：\n\n每一天，收集所有新的落叶的编号（即当天删除的节点的编号），然后将它们按任意顺序写在先前的落叶编号之后。\n\n例如：第一天，叶子 $3$ 和 $4$ 落下，于是他们写下 $3, 4$ 或 $4, 3$。第二天，叶子 $1$ 和 $2$ 落下，于是他们继续写下 $1, 2$ 或 $2, 1$。最终的记录可能为 $(3, 4, 1, 2)$，$(4, 3, 1, 2)$，$(3, 4, 2, 1)$ 或 $(4, 3, 2, 1)$ 中的任意一个。\n\n这个过程持续了 $K$ 天，每天都有新的叶子掉落，直到只剩根节点为止。\n\n你在旅途过程中经过了杭州。此刻已是寒冬，仰望古树光秃秃的枝干，你不禁想起落叶纷飞的美丽景象。\n\n你很想知道今年有几天能看见落叶，但你只能找到 $M$ 位志愿者的记录。尝试根据这些记录推断出 $K$ 可能的最大值。\n\n### 交互方式\n\n你只需要实现以下函数：\n\n```cpp\nint solve(int N, int M, std::vector<int> F,\n            std::vector<std::vector<int>> S);\n```\n\n+   $N$：古树的节点数量。\n+   $M$：志愿者的数量。\n+   $F$：一个长度为 $N$ 的数组。对于 $1 \\le i \\le N - 1$，$F[i]$ 表示节点 $i$ 的父亲节点的编号。$F[0]$ 始终为 $-1$。\n+   $S$：一个长度为 $M$ 的数组。$S$ 中的每个元素是一个长度为 $N - 1$ 的数组。$S[i][j]$ 表示志愿者 $i$ 记录的第 $j$ 个节点编号（从 $0$ 开始）。\n+   该函数必须返回一个整数，表示根据如上规则的 $K$ 可能的最大值（即，最大可能的落叶天数）。\n+   对于每个测试点，交互库可能调用该函数多于一次。每次调用都应该作为新的情况分别处理。\n\n注意：由于函数调用可能会发生多次，选手需要注意之前调用的残余数据对于后续调用的影响，尤其是全局变量的状态。", "inputFormat": "评测程序示例读取如下格式的输入：\n\n+   第 1 行：$T$\n\n对于接下来 $T$ 组数据中的每一组：\n\n+   第 $1$ 行：$N\\ M$\n+   第 $2$ 行：$F[1]\\ F[2]\\ \\ldots\\  F[N - 1]$\n+   第 $3 + i\\ (0 \\le i \\le M - 1)$ 行：$S[i][0]\\ S[i][1]\\ S[i][2]\\ \\ldots\\ S[i][N - 2]$", "outputFormat": "评测程序示例按照如下格式打印你的答案：\n\n对于每组测试数据：\n\n+   第 1 行：函数 `solve` 的返回值", "hint": "### 样例解释\n\n对于样例一，考虑如下调用：\n\n```cpp\nsolve(3, 1, {-1, 0, 0}, {{1, 2}});\n```\n\n对应的树如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i2lup6cf.png)\n\n叶子 $1$ 和 $2$ 可能在同一天落下，或者叶子 $1$ 在第一天先落下，然后叶子 $2$ 在第二天落下。落叶天数不超过 $2$。\n\n因此，程序应当返回 $2$。\n\n对于样例二，考虑如下调用：\n\n```cpp\nsolve(5, 2, {-1, 0, 0, 1, 1}, {{1, 2, 3, 4}, {4, 1, 2, 3}});\n```\n\n对应的树如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l50142xn.png)\n\n假设至少有 $2$ 天落叶，根据志愿者的记录，叶子 $4$ 将在不同的日子（第一天和最后一天）落下，这是矛盾的。\n\n因此，程序应当返回 $1$。\n\n### 数据范围\n\n+   $2 \\le N \\le 10^5$\n+   $1 \\le M \\le 5$\n+   $\\sum NM \\le 8 \\times 10^5$\n+   $F[0] = -1$ 且对于 $1 \\le i \\le N - 1$, $0 \\le F[i] \\le i - 1$\n+   对于 $1 \\le i \\le M - 1$, 数组 $S[i]$ 是一个 $1, 2, \\ldots , N - 1$ 的排列\n+   保证 $F$ 描述的是一棵以节点 $0$ 为根的有根树\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :---: | :---: | :---: |\n| 1 | $M=1,N\\le 10,\\sum N\\le 30$ | $11$ |\n| 2 | $N\\le 10,\\sum N\\le 30$ | $14$ |\n| 3 | $M=1,N\\le 1\\,000,\\sum N\\le 2\\,000,F[i]=i-1$ | $5$ |\n| 4 | $M=1,N\\le 1\\,000,\\sum N\\le 2\\,000$ | $9$ |\n| 5 | $N\\le 1\\,000,\\sum N\\le 2\\,000,F[i]=i-1$ | $5$ |\n| 6 | $N\\le 1\\,000,\\sum N\\le 2\\,000$ | $11$ |\n| 7 | $M=1,F[i]=i-1$ | $9$ |\n| 8 | $M=1$ | $11$ |\n| 9 | $F[i]=i-1$ | $9$ |\n| 10 | 没有额外的约束条件 | $16$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[APIO2024] 九月", "background": "## 请勿使用 C++14(GCC9) 提交\n\n你无需在程序开头引入库 `september.h`。", "description": "杭州市的中心广场有一棵著名的古树。这棵古树可以看作一棵 $N$ 个节点的有根树，节点编号从 $0$ 到 $N - 1$，其中 $0$ 号节点是根节点。\n\n称没有孩子的节点为叶子节点。古树每次落叶时，会选择一个当前的叶子节点删去。每一天中，古树可能会多次落叶。\n\n有 $M$ 位志愿者（编号从 $0$ 到 $M - 1$）负责看护古树。每一位志愿者将各自按照如下方式独立记录今年的落叶的情况：\n\n每一天，收集所有新的落叶的编号（即当天删除的节点的编号），然后将它们按任意顺序写在先前的落叶编号之后。\n\n例如：第一天，叶子 $3$ 和 $4$ 落下，于是他们写下 $3, 4$ 或 $4, 3$。第二天，叶子 $1$ 和 $2$ 落下，于是他们继续写下 $1, 2$ 或 $2, 1$。最终的记录可能为 $(3, 4, 1, 2)$，$(4, 3, 1, 2)$，$(3, 4, 2, 1)$ 或 $(4, 3, 2, 1)$ 中的任意一个。\n\n这个过程持续了 $K$ 天，每天都有新的叶子掉落，直到只剩根节点为止。\n\n你在旅途过程中经过了杭州。此刻已是寒冬，仰望古树光秃秃的枝干，你不禁想起落叶纷飞的美丽景象。\n\n你很想知道今年有几天能看见落叶，但你只能找到 $M$ 位志愿者的记录。尝试根据这些记录推断出 $K$ 可能的最大值。\n\n### 交互方式\n\n你只需要实现以下函数：\n\n```cpp\nint solve(int N, int M, std::vector<int> F,\n            std::vector<std::vector<int>> S);\n```\n\n+   $N$：古树的节点数量。\n+   $M$：志愿者的数量。\n+   $F$：一个长度为 $N$ 的数组。对于 $1 \\le i \\le N - 1$，$F[i]$ 表示节点 $i$ 的父亲节点的编号。$F[0]$ 始终为 $-1$。\n+   $S$：一个长度为 $M$ 的数组。$S$ 中的每个元素是一个长度为 $N - 1$ 的数组。$S[i][j]$ 表示志愿者 $i$ 记录的第 $j$ 个节点编号（从 $0$ 开始）。\n+   该函数必须返回一个整数，表示根据如上规则的 $K$ 可能的最大值（即，最大可能的落叶天数）。\n+   对于每个测试点，交互库可能调用该函数多于一次。每次调用都应该作为新的情况分别处理。\n\n注意：由于函数调用可能会发生多次，选手需要注意之前调用的残余数据对于后续调用的影响，尤其是全局变量的状态。", "inputFormat": "评测程序示例读取如下格式的输入：\n\n+   第 1 行：$T$\n\n对于接下来 $T$ 组数据中的每一组：\n\n+   第 $1$ 行：$N\\ M$\n+   第 $2$ 行：$F[1]\\ F[2]\\ \\ldots\\  F[N - 1]$\n+   第 $3 + i\\ (0 \\le i \\le M - 1)$ 行：$S[i][0]\\ S[i][1]\\ S[i][2]\\ \\ldots\\ S[i][N - 2]$", "outputFormat": "评测程序示例按照如下格式打印你的答案：\n\n对于每组测试数据：\n\n+   第 1 行：函数 `solve` 的返回值", "hint": "### 样例解释\n\n对于样例一，考虑如下调用：\n\n```cpp\nsolve(3, 1, {-1, 0, 0}, {{1, 2}});\n```\n\n对应的树如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i2lup6cf.png)\n\n叶子 $1$ 和 $2$ 可能在同一天落下，或者叶子 $1$ 在第一天先落下，然后叶子 $2$ 在第二天落下。落叶天数不超过 $2$。\n\n因此，程序应当返回 $2$。\n\n对于样例二，考虑如下调用：\n\n```cpp\nsolve(5, 2, {-1, 0, 0, 1, 1}, {{1, 2, 3, 4}, {4, 1, 2, 3}});\n```\n\n对应的树如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l50142xn.png)\n\n假设至少有 $2$ 天落叶，根据志愿者的记录，叶子 $4$ 将在不同的日子（第一天和最后一天）落下，这是矛盾的。\n\n因此，程序应当返回 $1$。\n\n### 数据范围\n\n+   $2 \\le N \\le 10^5$\n+   $1 \\le M \\le 5$\n+   $\\sum NM \\le 8 \\times 10^5$\n+   $F[0] = -1$ 且对于 $1 \\le i \\le N - 1$, $0 \\le F[i] \\le i - 1$\n+   对于 $1 \\le i \\le M - 1$, 数组 $S[i]$ 是一个 $1, 2, \\ldots , N - 1$ 的排列\n+   保证 $F$ 描述的是一棵以节点 $0$ 为根的有根树\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :---: | :---: | :---: |\n| 1 | $M=1,N\\le 10,\\sum N\\le 30$ | $11$ |\n| 2 | $N\\le 10,\\sum N\\le 30$ | $14$ |\n| 3 | $M=1,N\\le 1\\,000,\\sum N\\le 2\\,000,F[i]=i-1$ | $5$ |\n| 4 | $M=1,N\\le 1\\,000,\\sum N\\le 2\\,000$ | $9$ |\n| 5 | $N\\le 1\\,000,\\sum N\\le 2\\,000,F[i]=i-1$ | $5$ |\n| 6 | $N\\le 1\\,000,\\sum N\\le 2\\,000$ | $11$ |\n| 7 | $M=1,F[i]=i-1$ | $9$ |\n| 8 | $M=1$ | $11$ |\n| 9 | $F[i]=i-1$ | $9$ |\n| 10 | 没有额外的约束条件 | $16$ |", "locale": "zh-CN"}}}
{"pid": "P10538", "type": "P", "difficulty": 6, "samples": [["3 3 1 \n20 30 40\n0 1 1 15 10\n1 2 20 30 5\n0 2 18 40 40\n16 19", "40"], ["3 5 6\n30 38 33\n0 2 12 16 38\n1 0 48 50 6\n0 1 26 28 23\n0 2 6 7 94\n1 2 49 54 50\n32 36\n14 14\n42 45\n37 40\n2 5\n4 5", "197"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["动态规划 DP", "2024", "APIO", "交互题", "动态规划优化"], "title": "[APIO2024] 星际列车", "background": null, "description": "**请勿使用 C++14 (GCC 9) 提交。**\n\n在 2992 年，机器人已经取代了人类的大部分工作，大家都有着大量的空闲时间。因此你和家人决定利用这些时间来一场星际旅行。\n\n有 $N$ 个人类已经可以到达的行星，编号为 $0$ 到 $N - 1$，以及 $M$ 种不同的星际列车路线。第 $i$ 种列车路线 ($0 \\le i < M$) 在时间 $A[i]$ 从行星 $X[i]$ 出发，在时间 $B[i]$ 到达行星 $Y[i]$，票价为 $C[i]$。在行星之间，这些星际列车是仅有的交通方式。对于你搭乘的一列星际列车，你只能在它的终点站下车，并且你搭乘的下一趟列车的起点站必须和这趟列车的终点站相同（这里认为换乘不耗时）。形式化地，你可以依次乘坐第 $q[0], q[1], \\ldots, q[P]$ 次列车，当且仅当对任意 $1 \\le k \\le P$ 都有 $Y[q[k - 1]] = X[q[k]]$，$B[q[k - 1]] \\le A[q[k]]$。\n\n在不同行星之间移动是非常耗时的，所以除了车票钱，餐费支出也不可忽视。列车上免费提供不限量的食物，也就是在列车上吃饭不花钱：如果你决定乘坐第 $i$ 种星际列车，则在任何 $A[i]$ 到 $B[i]$ 之间的时刻（包括端点）你都可以免费吃任意多顿饭。但如果你决定在行星 $i$ 吃饭，每顿饭都需要 $T[i]$ 元。\n\n你和家人在旅途中总共需要吃 $W$ 顿饭，第 $i\\ (0 \\le i < W)$ 顿饭可以在 $L[i]$ 到 $R[i]$（包括端点）的任何时刻吃，吃饭不耗费时间。吃饭没有顺序要求，例如允许在吃完第 $1$ 顿饭后再吃第 $0$ 顿饭（见样例 $2$）。\n\n现在是 $0$ 时刻，你和家人正在 $0$ 号行星上。你需要求出到达 $N - 1$ 号行星的最小花费，花费定义为车票价格和餐费之和。如果无法到达 $N - 1$ 号行星，最小花费定义为 $-1$。\n\n### 实现细节\n\n你无需在程序开头引入库 `train.h`。\n\n你只需要实现以下函数：\n\n```cpp\nlong long solve(int N, int M, int W, std::vector<int> T,\n                std::vector<int> X, std::vector<int> Y,\n                std::vector<int> A, std::vector<int> B, std::vector<int> C,\n                std::vector<int> L, std::vector<int> R);\n```\n\n+   $N$：行星数量。\n+  $ M$：星际列车路线数量。\n+   $W$：需要用餐的次数。\n+   $T$：一个长度为 $N$ 的数组。$T[i]$ 表示在行星 $i$ 每次用餐的花费。\n+   $X, Y, A, B, C$：五个长为 $M$ 的数组。$(X[i], Y[i], A[i], B[i], C[i])$ 描述了第 $i$ 条列车路线。\n+   $L, R$：两个长为 $W$ 的数组。$(L[i], R[i])$ 描述了第 $i$ 顿饭的用餐时间。\n+   你需要返回从行星 $0$ 到达行星 $N - 1$ 的最小花费。如果行星 $N - 1$ 不可达，返回 $-1$。\n+   每个测试点中，该函数恰好被调用一次。", "inputFormat": "评测程序示例读取如下格式的输入：\n\n+   第 $1$ 行：$N\\ M\\ W$\n+   第 $2$ 行：$T[0]\\ T[1]\\ T[2]\\ \\ldots\\ T[N - 1]$\n+   第 $3 + i\\ (0 \\le i < M)$ 行：$X[i]\\ Y[i]\\ A[i]\\ B[i]\\ C[i]$\n+   第 $3 + M + i\\ (0 \\le i < W)$ 行：$L[i]\\ R[i]$", "outputFormat": "评测程序示例按照如下格式打印你的答案：\n\n+   第 $1$ 行：函数 `solve` 的返回值", "hint": "### 样例解释\n\n对于样例一，考虑如下调用：\n\n```cpp\nsolve(3, 3, 1, {20, 30, 40}, {0, 1, 0}, {1, 2, 2},\n        {1, 20, 18}, {15, 30, 40}, {10, 5, 40}, {16}, {19});\n```\n\n一种可行的方案是依次乘坐第 $0, 1$ 次列车，花费为 $45$，具体流程如下：\n\n| 时刻 | 你的行动 | 花费 |\n| :---: | :---: | :---: |\n| $1$ | 乘坐第 $0$ 次列车从 $0$ 号行星出发 | $10$ |\n| $15$ | 到达 $1$ 号行星 |  |\n| $16$ | 在 $1$ 号行星吃第 $0$ 顿饭 | $30$ |\n| $20$ | 乘坐第 $1$ 次列车从 $1$ 号行星出发 | $5$ |\n| $30$ | 到达 $2$ 号行星 |  |\n\n一种更优的方案是乘坐第 $2$ 次列车，花费为 $40$，具体流程如下：\n\n| 时刻 | 你的行动 | 花费 |\n| :---: | :---: | :---: |\n| $18$ | 乘坐第 $2$ 次列车从 $0$ 号行星出发 | $40$ |\n| $19$ | 在第 $2$ 次列车上吃第 $0$ 顿饭 |  |\n| $40$ | 到达 $2$ 号行星 |  |\n\n在这种方案中，在时刻 $18$ 在第 $2$ 次列车上吃第 $0$ 顿饭也是合法的。\n\n因此函数应该返回 $40$。\n\n对于样例二，考虑如下调用：\n\n```cpp\nsolve(3, 5, 6, {30, 38, 33}, {0, 1, 0, 0, 1}, {2, 0, 1, 2, 2},\n        {12, 48, 26, 6, 49}, {16, 50, 28, 7, 54}, {38, 6, 23, 94, 50},\n        {32, 14, 42, 37, 2, 4}, {36, 14, 45, 40, 5, 5});\n```\n\n最优解是：乘坐第 $0$ 次列车，车费为 $38$。在第 $0$ 次列车上免费吃第 $1$ 顿饭。第 $0, 2, 3$ 顿饭在行星 $2$ 上吃 ，花费 $33 \\times 3 = 99$。 第 $4, 5$ 顿饭在行星 $0$ 上吃，花费 $30 \\times 2 = 60$。总花费为 $38 + 99 + 60 = 197$。\n\n因此函数应该返回 $197$。\n\n### 数据范围\n\n+   $2 \\le N \\le 10^5$\n+   $0 \\le M, W \\le 10^5$\n+   $0 \\le X[i], Y [i] < N, X[i] \\neq Y[i]$\n+   $1 \\le A[i] < B[i] \\le 10^9$\n+   $1 \\le T[i], C[i] \\le 10^9$\n+   $1 \\le L[i] \\le R[i] \\le 10^9$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :---: | :---: | :---: |\n| $1$ | $N, M, A[i], B[i], L[i], R[i] \\le 10^3, W \\le 10$ | $5$ |\n| $2$ | $W = 0$ | $5$\n| $3$ | 每顿饭的用餐时间两两不交。形式化地，对于任何时刻 $z$ 满足 $1 \\le z \\le 10^9$，至多存在一个 $i\\ (0 \\le i < W)$ 使得 $L[i] \\le z \\le R[i]$。 | $30$ |\n| $4$ | 没有额外的约束条件 | $60$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[APIO2024] 星际列车", "background": null, "description": "**请勿使用 C++14 (GCC 9) 提交。**\n\n在 2992 年，机器人已经取代了人类的大部分工作，大家都有着大量的空闲时间。因此你和家人决定利用这些时间来一场星际旅行。\n\n有 $N$ 个人类已经可以到达的行星，编号为 $0$ 到 $N - 1$，以及 $M$ 种不同的星际列车路线。第 $i$ 种列车路线 ($0 \\le i < M$) 在时间 $A[i]$ 从行星 $X[i]$ 出发，在时间 $B[i]$ 到达行星 $Y[i]$，票价为 $C[i]$。在行星之间，这些星际列车是仅有的交通方式。对于你搭乘的一列星际列车，你只能在它的终点站下车，并且你搭乘的下一趟列车的起点站必须和这趟列车的终点站相同（这里认为换乘不耗时）。形式化地，你可以依次乘坐第 $q[0], q[1], \\ldots, q[P]$ 次列车，当且仅当对任意 $1 \\le k \\le P$ 都有 $Y[q[k - 1]] = X[q[k]]$，$B[q[k - 1]] \\le A[q[k]]$。\n\n在不同行星之间移动是非常耗时的，所以除了车票钱，餐费支出也不可忽视。列车上免费提供不限量的食物，也就是在列车上吃饭不花钱：如果你决定乘坐第 $i$ 种星际列车，则在任何 $A[i]$ 到 $B[i]$ 之间的时刻（包括端点）你都可以免费吃任意多顿饭。但如果你决定在行星 $i$ 吃饭，每顿饭都需要 $T[i]$ 元。\n\n你和家人在旅途中总共需要吃 $W$ 顿饭，第 $i\\ (0 \\le i < W)$ 顿饭可以在 $L[i]$ 到 $R[i]$（包括端点）的任何时刻吃，吃饭不耗费时间。吃饭没有顺序要求，例如允许在吃完第 $1$ 顿饭后再吃第 $0$ 顿饭（见样例 $2$）。\n\n现在是 $0$ 时刻，你和家人正在 $0$ 号行星上。你需要求出到达 $N - 1$ 号行星的最小花费，花费定义为车票价格和餐费之和。如果无法到达 $N - 1$ 号行星，最小花费定义为 $-1$。\n\n### 实现细节\n\n你无需在程序开头引入库 `train.h`。\n\n你只需要实现以下函数：\n\n```cpp\nlong long solve(int N, int M, int W, std::vector<int> T,\n                std::vector<int> X, std::vector<int> Y,\n                std::vector<int> A, std::vector<int> B, std::vector<int> C,\n                std::vector<int> L, std::vector<int> R);\n```\n\n+   $N$：行星数量。\n+  $ M$：星际列车路线数量。\n+   $W$：需要用餐的次数。\n+   $T$：一个长度为 $N$ 的数组。$T[i]$ 表示在行星 $i$ 每次用餐的花费。\n+   $X, Y, A, B, C$：五个长为 $M$ 的数组。$(X[i], Y[i], A[i], B[i], C[i])$ 描述了第 $i$ 条列车路线。\n+   $L, R$：两个长为 $W$ 的数组。$(L[i], R[i])$ 描述了第 $i$ 顿饭的用餐时间。\n+   你需要返回从行星 $0$ 到达行星 $N - 1$ 的最小花费。如果行星 $N - 1$ 不可达，返回 $-1$。\n+   每个测试点中，该函数恰好被调用一次。", "inputFormat": "评测程序示例读取如下格式的输入：\n\n+   第 $1$ 行：$N\\ M\\ W$\n+   第 $2$ 行：$T[0]\\ T[1]\\ T[2]\\ \\ldots\\ T[N - 1]$\n+   第 $3 + i\\ (0 \\le i < M)$ 行：$X[i]\\ Y[i]\\ A[i]\\ B[i]\\ C[i]$\n+   第 $3 + M + i\\ (0 \\le i < W)$ 行：$L[i]\\ R[i]$", "outputFormat": "评测程序示例按照如下格式打印你的答案：\n\n+   第 $1$ 行：函数 `solve` 的返回值", "hint": "### 样例解释\n\n对于样例一，考虑如下调用：\n\n```cpp\nsolve(3, 3, 1, {20, 30, 40}, {0, 1, 0}, {1, 2, 2},\n        {1, 20, 18}, {15, 30, 40}, {10, 5, 40}, {16}, {19});\n```\n\n一种可行的方案是依次乘坐第 $0, 1$ 次列车，花费为 $45$，具体流程如下：\n\n| 时刻 | 你的行动 | 花费 |\n| :---: | :---: | :---: |\n| $1$ | 乘坐第 $0$ 次列车从 $0$ 号行星出发 | $10$ |\n| $15$ | 到达 $1$ 号行星 |  |\n| $16$ | 在 $1$ 号行星吃第 $0$ 顿饭 | $30$ |\n| $20$ | 乘坐第 $1$ 次列车从 $1$ 号行星出发 | $5$ |\n| $30$ | 到达 $2$ 号行星 |  |\n\n一种更优的方案是乘坐第 $2$ 次列车，花费为 $40$，具体流程如下：\n\n| 时刻 | 你的行动 | 花费 |\n| :---: | :---: | :---: |\n| $18$ | 乘坐第 $2$ 次列车从 $0$ 号行星出发 | $40$ |\n| $19$ | 在第 $2$ 次列车上吃第 $0$ 顿饭 |  |\n| $40$ | 到达 $2$ 号行星 |  |\n\n在这种方案中，在时刻 $18$ 在第 $2$ 次列车上吃第 $0$ 顿饭也是合法的。\n\n因此函数应该返回 $40$。\n\n对于样例二，考虑如下调用：\n\n```cpp\nsolve(3, 5, 6, {30, 38, 33}, {0, 1, 0, 0, 1}, {2, 0, 1, 2, 2},\n        {12, 48, 26, 6, 49}, {16, 50, 28, 7, 54}, {38, 6, 23, 94, 50},\n        {32, 14, 42, 37, 2, 4}, {36, 14, 45, 40, 5, 5});\n```\n\n最优解是：乘坐第 $0$ 次列车，车费为 $38$。在第 $0$ 次列车上免费吃第 $1$ 顿饭。第 $0, 2, 3$ 顿饭在行星 $2$ 上吃 ，花费 $33 \\times 3 = 99$。 第 $4, 5$ 顿饭在行星 $0$ 上吃，花费 $30 \\times 2 = 60$。总花费为 $38 + 99 + 60 = 197$。\n\n因此函数应该返回 $197$。\n\n### 数据范围\n\n+   $2 \\le N \\le 10^5$\n+   $0 \\le M, W \\le 10^5$\n+   $0 \\le X[i], Y [i] < N, X[i] \\neq Y[i]$\n+   $1 \\le A[i] < B[i] \\le 10^9$\n+   $1 \\le T[i], C[i] \\le 10^9$\n+   $1 \\le L[i] \\le R[i] \\le 10^9$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :---: | :---: | :---: |\n| $1$ | $N, M, A[i], B[i], L[i], R[i] \\le 10^3, W \\le 10$ | $5$ |\n| $2$ | $W = 0$ | $5$\n| $3$ | 每顿饭的用餐时间两两不交。形式化地，对于任何时刻 $z$ 满足 $1 \\le z \\le 10^9$，至多存在一个 $i\\ (0 \\le i < W)$ 使得 $L[i] \\le z \\le R[i]$。 | $30$ |\n| $4$ | 没有额外的约束条件 | $60$ |", "locale": "zh-CN"}}}
{"pid": "P10539", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "APIO", "交互题", "Special Judge", "通信题"], "title": "[APIO2024] 魔术表演", "background": "在洛谷上提交时，只需要提交一个文件。\n\n不要引入 `alice.h` 和 `bob.h`。在文件头加入以下内容：\n\n```cpp\nlong long setN(int n);\n```\n\n只支持 C++17 / C++20 提交。", "description": "Alice 和 Bob 是著名的魔术师。Catherine 是一位富豪，她非常喜欢观看 Alice 和 Bob 的魔术。某一天，Catherine 决定向 Alice 和 Bob 发出挑战：只要他们能成功表演如下的魔术，Catherine 就将向他们提供巨额奖金！这个魔术的表演过程如下：\n\n- 步骤 $1$：Bob 进⼊⼀个密室中，在魔术的全程中，他只能与 Catherine 交流。接下来，Alice 告诉 Catherine ⼀个在 $2$ 到 $5000$ 之间的整数 $n$。\n- 步骤 $2$：Catherine 告诉 Alice ⼀个在 $1$ 到 $10^{18}$ 之间的整数 $X$。\n- 步骤 $3$：Alice 生成⼀个具有 $n$ 个节点的树，并告诉 Catherine。\n- 步骤 $4$：Catherine 删除树中的⼀些边（至多 $\\left\\lfloor\\dfrac{n-2}{2}\\right\\rfloor$ 条），并将剩余的边告诉 Bob。\n- 步骤 $5$：Bob 根据 Catherine 给出的信息，猜出 Catherine 告诉 Alice 的数是多少。\n\n然⽽，Alice 和 Bob 被这个魔术难倒了，于是他们不得不寻求你的帮助。请你写一段程序，实现 Alice 和 Bob 的策略，以帮助他们赢得 Catherine 的挑战。\n\n通信方式：\n\n你需要实现两个函数\n\n1. `std::vector<std::pair<int, int>> Alice();`\n- 对于每组测试数据，这个函数只会被调用⼀次。\n- 函数应当返回⼀个含有 `pair<int, int>` 类型的 `vector`，表示 Alice 在魔术的步骤 3 中生成的树的边集。\n  - 注意树中的节点应当从 1 开始编号。\n  - 你需要确保函数返回的树是符合规范的，也就是说，树中应当恰好包含 n − 1 条边，且所有节点彼此连通。\n  \n函数 `Alice()` 应当调用如下函数**恰好⼀次**：\n\n`long long setN(int n);`\n\n- 这个函数表示，在魔术的步骤 1 中，Alice 选择⼀个数 $n$ 告诉 Catherine。\n- 函数返回⼀个数 $X$，表示 Catherine 在魔术的步骤 2 中告诉 Alice 的数。\n---\n2. `long long Bob(std::vector<std::pair<int, int>> V);`\n\n- 对于每组测试数据，这个函数只会被调用⼀次，且⼀定是在调用 `Alice()` 之后。\n- $V$ 表⽰在魔术的步骤 4 中，Catherine 告诉 Bob 的边集。\n- 上述边集是有序的，具体而言：\n  - 对于⼀条边的两个端点而言，编号较⼩的端点靠前；\n  - 所有的边按照第⼀个端点为第⼀关键字、第⼆个端点为第⼆关键字的顺序升序排序。\n- 函数应当返回⼀个整数 $X$，表⽰ Bob 在魔术的步骤 5 中给出的回答。", "inputFormat": "无", "outputFormat": "无", "hint": "### 例子\n\n考虑下面的调用：\n调用函数| 返回值\n:-:|:-:\n`Alice()`|\n`setN(4)`| $3$\n||$\\{\\{1, 2\\}, \\{2, 3\\}, \\{2, 4\\}\\}$\n`Bob({{1,2},{2,4}})`| $3$\n该样例代表了以下场景：\n- 步骤 1：最开始，Alice 将数字 $4$ 告诉 Catherine。\n- 步骤 2：Catherine 将数字 $3$ 告诉 Alice。\n- 步骤 3：Alice 生成了⼀棵具有 $4$ 个节点的树，其边集为 $\\{\\{1, 2\\}, \\{2, 3\\}, \\{2, 4\\}\\}$，将这棵树告诉 Catherine。\n- 步骤 4：Catherine 删去了树中连接节点 $2$ 和 $3$ 的边，并把剩余的边 $\\{\\{1, 2\\}, \\{2, 4\\}\\}$ 告诉 Bob。\n- 步骤 5：Bob 给出数字 $3$ 作为回答。由于他给出了正确答案，他们的魔术表演⼤获成功。\n\n\n### 子任务\n\n1. (5 分)：$X\\leq 5, 000$。\n2. (30 分)：$X\\leq25, 000, 000$。\n3. (65 分)：没有特殊限制。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[APIO2024] 魔术表演", "background": "在洛谷上提交时，只需要提交一个文件。\n\n不要引入 `alice.h` 和 `bob.h`。在文件头加入以下内容：\n\n```cpp\nlong long setN(int n);\n```\n\n只支持 C++17 / C++20 提交。", "description": "Alice 和 Bob 是著名的魔术师。Catherine 是一位富豪，她非常喜欢观看 Alice 和 Bob 的魔术。某一天，Catherine 决定向 Alice 和 Bob 发出挑战：只要他们能成功表演如下的魔术，Catherine 就将向他们提供巨额奖金！这个魔术的表演过程如下：\n\n- 步骤 $1$：Bob 进⼊⼀个密室中，在魔术的全程中，他只能与 Catherine 交流。接下来，Alice 告诉 Catherine ⼀个在 $2$ 到 $5000$ 之间的整数 $n$。\n- 步骤 $2$：Catherine 告诉 Alice ⼀个在 $1$ 到 $10^{18}$ 之间的整数 $X$。\n- 步骤 $3$：Alice 生成⼀个具有 $n$ 个节点的树，并告诉 Catherine。\n- 步骤 $4$：Catherine 删除树中的⼀些边（至多 $\\left\\lfloor\\dfrac{n-2}{2}\\right\\rfloor$ 条），并将剩余的边告诉 Bob。\n- 步骤 $5$：Bob 根据 Catherine 给出的信息，猜出 Catherine 告诉 Alice 的数是多少。\n\n然⽽，Alice 和 Bob 被这个魔术难倒了，于是他们不得不寻求你的帮助。请你写一段程序，实现 Alice 和 Bob 的策略，以帮助他们赢得 Catherine 的挑战。\n\n通信方式：\n\n你需要实现两个函数\n\n1. `std::vector<std::pair<int, int>> Alice();`\n- 对于每组测试数据，这个函数只会被调用⼀次。\n- 函数应当返回⼀个含有 `pair<int, int>` 类型的 `vector`，表示 Alice 在魔术的步骤 3 中生成的树的边集。\n  - 注意树中的节点应当从 1 开始编号。\n  - 你需要确保函数返回的树是符合规范的，也就是说，树中应当恰好包含 n − 1 条边，且所有节点彼此连通。\n  \n函数 `Alice()` 应当调用如下函数**恰好⼀次**：\n\n`long long setN(int n);`\n\n- 这个函数表示，在魔术的步骤 1 中，Alice 选择⼀个数 $n$ 告诉 Catherine。\n- 函数返回⼀个数 $X$，表示 Catherine 在魔术的步骤 2 中告诉 Alice 的数。\n---\n2. `long long Bob(std::vector<std::pair<int, int>> V);`\n\n- 对于每组测试数据，这个函数只会被调用⼀次，且⼀定是在调用 `Alice()` 之后。\n- $V$ 表⽰在魔术的步骤 4 中，Catherine 告诉 Bob 的边集。\n- 上述边集是有序的，具体而言：\n  - 对于⼀条边的两个端点而言，编号较⼩的端点靠前；\n  - 所有的边按照第⼀个端点为第⼀关键字、第⼆个端点为第⼆关键字的顺序升序排序。\n- 函数应当返回⼀个整数 $X$，表⽰ Bob 在魔术的步骤 5 中给出的回答。", "inputFormat": "无", "outputFormat": "无", "hint": "### 例子\n\n考虑下面的调用：\n调用函数| 返回值\n:-:|:-:\n`Alice()`|\n`setN(4)`| $3$\n||$\\{\\{1, 2\\}, \\{2, 3\\}, \\{2, 4\\}\\}$\n`Bob({{1,2},{2,4}})`| $3$\n该样例代表了以下场景：\n- 步骤 1：最开始，Alice 将数字 $4$ 告诉 Catherine。\n- 步骤 2：Catherine 将数字 $3$ 告诉 Alice。\n- 步骤 3：Alice 生成了⼀棵具有 $4$ 个节点的树，其边集为 $\\{\\{1, 2\\}, \\{2, 3\\}, \\{2, 4\\}\\}$，将这棵树告诉 Catherine。\n- 步骤 4：Catherine 删去了树中连接节点 $2$ 和 $3$ 的边，并把剩余的边 $\\{\\{1, 2\\}, \\{2, 4\\}\\}$ 告诉 Bob。\n- 步骤 5：Bob 给出数字 $3$ 作为回答。由于他给出了正确答案，他们的魔术表演⼤获成功。\n\n\n### 子任务\n\n1. (5 分)：$X\\leq 5, 000$。\n2. (30 分)：$X\\leq25, 000, 000$。\n3. (65 分)：没有特殊限制。\n", "locale": "zh-CN"}}}
{"pid": "P10540", "type": "P", "difficulty": 7, "samples": [["6 5\n6 4\n2 6\n5 -5\n3 6\n1 2\n3 6\n1 6\n1 6\n2 6\n2 6\n5 6\n", "19\n19\n15\n15\n8\n"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "THUPC"], "title": "[THUPC 2024 决赛] 古明地枣的袜子", "background": "", "description": "你需要维护一个序列 $a_1,\\dots,a_n$ 。\n\n给定一个操作序列 $(x_1,y_1),\\dots,(x_n,y_n)$ ，操作 $(x,y)$ 表示将 $a_1,\\dots,a_x$ 的值加上 $y$ 。\n\n共 $m$ 次查询，每次查询给出 $l,r$ ，问对初始值为 $0$ 的序列 $a$ 依次执行操作 $(x_l,y_l),\\dots,(x_r,y_r)$ ，最后 $\\max\\limits_{i=1}^n a_i$ 的值。", "inputFormat": "第一行两个整数 $n,m$ （$1\\le n,m\\le 5\\times 10^5$）；\n\n接下来 $n$ 行每行两个整数 $x_i,y_i$（$1\\le x_i\\le n, |y_i|\\le n$）；\n\n接下来 $m$ 行，每行两个整数 $l,r$（$1\\le l\\le r\\le n$）。", "outputFormat": "输出 $m$ 行，每行一个整数，表示每次查询的答案。\n\n", "hint": "**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 古明地枣的袜子", "background": "", "description": "你需要维护一个序列 $a_1,\\dots,a_n$ 。\n\n给定一个操作序列 $(x_1,y_1),\\dots,(x_n,y_n)$ ，操作 $(x,y)$ 表示将 $a_1,\\dots,a_x$ 的值加上 $y$ 。\n\n共 $m$ 次查询，每次查询给出 $l,r$ ，问对初始值为 $0$ 的序列 $a$ 依次执行操作 $(x_l,y_l),\\dots,(x_r,y_r)$ ，最后 $\\max\\limits_{i=1}^n a_i$ 的值。", "inputFormat": "第一行两个整数 $n,m$ （$1\\le n,m\\le 5\\times 10^5$）；\n\n接下来 $n$ 行每行两个整数 $x_i,y_i$（$1\\le x_i\\le n, |y_i|\\le n$）；\n\n接下来 $m$ 行，每行两个整数 $l,r$（$1\\le l\\le r\\le n$）。", "outputFormat": "输出 $m$ 行，每行一个整数，表示每次查询的答案。\n\n", "hint": "**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
{"pid": "P10541", "type": "P", "difficulty": 6, "samples": [["4 5 5 3\n2 10 6 7\n1 7 5 3\n2 2 3 8 8\n1 1\n2 2\n2 3\n3 4\n4 5\n1 2\n2 3\n3 4", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "2024", "网络流", "图论建模", "THUPC"], "title": "[THUPC 2024 决赛] 研发计划", "background": "", "description": "看到近期若干家大模型创业公司获得高额融资，作为炼丹大师的你心痒难耐，决定入局，亲自下场搞产品。\n\n经过一段时间的梳理，你发现当前共有 $m$ 种产品推出后将会大卖，其中第 $i$ 个产品推出之后预期获得 $g_i$ 的收益。这 $m$ 种产品涉及 $n$ 种技术：共有 $p$ 条技术-产品依赖关系 $(u,v)$ ，表示第 $u$ 个技术是第 $v$ 个产品的前置技术。对于每个产品，你必须获得它的全部前置技术之后才能推出。\n\n对于第 $j$ 个技术，你可以选择花费 $f_j$ 的代价直接从其他公司购买获得，或者花费 $h_j$ 的代价通过研发获得。研发需要一定的条件：给出 $q$ 条技术-技术依赖关系 $(a,b)$ ，表示第 $a$ 个技术是第 $b$ 个技术的前置技术，那么必须在获得了技术 $j$ 的所有前置技术后才能通过研发获得技术 $j$ 。若某个技术没有前置技术，那么你可以直接通过研发获得。保证技术-技术依赖关系构成一个有向无环图，即不会发生循环依赖（自然不会有自环）。\n\n一个方案的收益为推出的产品的收益总和减去获得的技术的代价总和。现在，作为一个商人，你希望研究一些技术、推出一些产品，最大化你获得的收益。为简单起见，你只要输出最大的收益值。", "inputFormat": "输入的第一行包含四个正整数 $n,m,p,q$，保证 $2 \\le n \\le 100, 1 \\le m \\le 100, 1 \\le p\\leq nm, 1 \\le q\\leq \\frac{n(n-1)}{2}$ ，分别表示技术总数、产品总数、技术-产品依赖关系总数以及技术-技术依赖关系总数。\n\n接下来一行 $n$ 个整数 $f_i$ ，表示直接购买第 $i$ 个技术的代价。\n\n接下来一行 $n$ 个整数 $h_i$ ，表示在前置技术基础上研究第 $i$ 个技术的代价。\n\n接下来一行 $m$ 个整数 $g_i$，表示第 $i$ 个产品推出之后获得的收益。\n\n接下来 $p$ 行，第 $i$ 行两个整数 $u_i,v_i$ ，表示技术-产品依赖关系 $(u_i,v_i)$，保证 $1 \\le u_i \\le n$，$1 \\le v_i \\le m$，输入的所有 $(u_i,v_i)$ 两两不同。\n\n接下来 $q$ 行，第 $i$ 行两个整数 $a_i,b_i$ ，表示技术-技术依赖关系 $(a_i,b_i)$，保证 $1 \\le a_i \\ne b_i \\le n$，输入的所有 $(a_i,b_i)$ 两两不同，且不构成循环依赖。\n\n保证所有输入数字均为不超过 $10^9$ 的非负整数。", "outputFormat": "输出一个整数表示收益最大方案的收益。\n", "hint": "最优方案是依次研究技术 1，购买技术 3，研究技术 4，这时我们就能推出产品 1、4、5 了。此时收益为 $(2+8+8)-(1+6+3)=8$。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 研发计划", "background": "", "description": "看到近期若干家大模型创业公司获得高额融资，作为炼丹大师的你心痒难耐，决定入局，亲自下场搞产品。\n\n经过一段时间的梳理，你发现当前共有 $m$ 种产品推出后将会大卖，其中第 $i$ 个产品推出之后预期获得 $g_i$ 的收益。这 $m$ 种产品涉及 $n$ 种技术：共有 $p$ 条技术-产品依赖关系 $(u,v)$ ，表示第 $u$ 个技术是第 $v$ 个产品的前置技术。对于每个产品，你必须获得它的全部前置技术之后才能推出。\n\n对于第 $j$ 个技术，你可以选择花费 $f_j$ 的代价直接从其他公司购买获得，或者花费 $h_j$ 的代价通过研发获得。研发需要一定的条件：给出 $q$ 条技术-技术依赖关系 $(a,b)$ ，表示第 $a$ 个技术是第 $b$ 个技术的前置技术，那么必须在获得了技术 $j$ 的所有前置技术后才能通过研发获得技术 $j$ 。若某个技术没有前置技术，那么你可以直接通过研发获得。保证技术-技术依赖关系构成一个有向无环图，即不会发生循环依赖（自然不会有自环）。\n\n一个方案的收益为推出的产品的收益总和减去获得的技术的代价总和。现在，作为一个商人，你希望研究一些技术、推出一些产品，最大化你获得的收益。为简单起见，你只要输出最大的收益值。", "inputFormat": "输入的第一行包含四个正整数 $n,m,p,q$，保证 $2 \\le n \\le 100, 1 \\le m \\le 100, 1 \\le p\\leq nm, 1 \\le q\\leq \\frac{n(n-1)}{2}$ ，分别表示技术总数、产品总数、技术-产品依赖关系总数以及技术-技术依赖关系总数。\n\n接下来一行 $n$ 个整数 $f_i$ ，表示直接购买第 $i$ 个技术的代价。\n\n接下来一行 $n$ 个整数 $h_i$ ，表示在前置技术基础上研究第 $i$ 个技术的代价。\n\n接下来一行 $m$ 个整数 $g_i$，表示第 $i$ 个产品推出之后获得的收益。\n\n接下来 $p$ 行，第 $i$ 行两个整数 $u_i,v_i$ ，表示技术-产品依赖关系 $(u_i,v_i)$，保证 $1 \\le u_i \\le n$，$1 \\le v_i \\le m$，输入的所有 $(u_i,v_i)$ 两两不同。\n\n接下来 $q$ 行，第 $i$ 行两个整数 $a_i,b_i$ ，表示技术-技术依赖关系 $(a_i,b_i)$，保证 $1 \\le a_i \\ne b_i \\le n$，输入的所有 $(a_i,b_i)$ 两两不同，且不构成循环依赖。\n\n保证所有输入数字均为不超过 $10^9$ 的非负整数。", "outputFormat": "输出一个整数表示收益最大方案的收益。\n", "hint": "最优方案是依次研究技术 1，购买技术 3，研究技术 4，这时我们就能推出产品 1、4、5 了。此时收益为 $(2+8+8)-(1+6+3)=8$。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
{"pid": "P10542", "type": "P", "difficulty": 5, "samples": [["4 1 2 2\n10 1\n2 1\n1 1\n1 2\n2 2\n2 2 1000000000\n", "1000000002\n"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "THUPC"], "title": "[THUPC 2024 决赛] RPG", "background": "", "description": "小 I 正在打一款回合制 RPG 的最终 boss 战。这一战中，主角和 TA 的 $(n-1)$ 个队友（也就是总共 $n$ 个人）会按照固定的顺序依次行动，目标是对 boss 产生尽可能高的总伤害。\n\n游戏设定中共有 $x$ 种攻击模式，第 $i (1 \\le i \\le x)$ 种攻击模式会对 boss 产生 $d_i$ 的基础伤害。\n\n在行动过程中可以对 boss 附着异常状态。异常状态共 $y$ 种，同一时刻 boss 不会陷入两种异常状态。当 boss 陷入特定的异常状态时，使用特定的攻击模式会触发暴击，产生更大的伤害。暴击的规则由 $m$ 个三元组 $(p_j, q_j, c_j)$ 给出，表示在附着第 $p_j (1 \\le p_j \\le y)$ 种异常状态时使用第 $q_j (1 \\le q_j \\le x)$ 种攻击模式会**额外**产生 $c_j$ 的伤害。\n\n对战开始时，boss 没有陷入任何的异常状态。按照行动顺序，第 $i (1 \\le i \\le n)$ 个人可以进行以下三种行动：\n\n- 使用法术使 boss 陷入第 $a_i$ 种异常状态，若 boss 之前陷入了其他异常状态，则之前的异常状态被移除。\n- 使用第 $b_i$ 种攻击模式对 boss 进行攻击，无论是否触发暴击，在产生伤害之后 **boss 的异常状态被移除**。\n- 摸鱼，即什么都不做，此时 boss 的异常状态被保留。\n\n作为剧情党，小 I 自然是不想自己算最优策略，于是他把问题丢给了你。于是你需要求出 $n$ 次行动内总共能产生最多多少伤害。\n", "inputFormat": "输入的第一行四个整数 $n, m, x, y (1 \\le n, m, x, y \\le 2 \\times 10^5)$，分别表示行动次数、暴击规则数、攻击模式种类数和异常状态种类数。\n\n第二行 $x$ 个整数 $d_1,d_2,\\cdots,d_x (1 \\le d_i \\le 10^9)$，依次描述每种攻击模式对 boss 产生的基础伤害量。\n\n接下来 $n$ 行第 $i$ 行两个整数 $a_i, b_i (1 \\le a_i \\le y, 1 \\le b_i \\le x)$，按照行动次序描述第 $i$ 个人的行动。\n\n接下来 $m$ 行第 $j$ 行三个整数 $p_j, q_j, c_j (1 \\le p_j \\le y, 1 \\le q_j \\le x, 1 \\le c_j \\le 10^9)$，描述第 $j$ 条暴击规则。保证 $(p_j, q_j)$ 两两不同。", "outputFormat": "输出一行一个整数，表示 $n$ 次行动对 boss 产生的伤害量总和的最大值。\n", "hint": "样例中共有两种攻击模式和两种异常状态，其中第一种攻击模式会造成 $10$ 的基础伤害，第二种攻击模式会造成 $1$ 的基础伤害。暴击规则仅有一条：在第二种异常状态下进行第二种攻击会额外造成 $10^9$ 的伤害。\n\n最优的行动策略如下：\n\n- 第一个人使用法术使 boss 陷入第二种异常状态；\n- 第二个人摸鱼，boss 仍然陷入第二种异常状态；\n- 第三个人使用第二种攻击模式，产生 $1$ 的基础伤害和 $10^9$ 的暴击伤害，boss 的异常状态被清除；\n- 第四个人使用第二种攻击模式，产生 $1$ 的基础伤害。\n\n总伤害量为 $1 + 10^9 + 1 = 10^9+2$。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] RPG", "background": "", "description": "小 I 正在打一款回合制 RPG 的最终 boss 战。这一战中，主角和 TA 的 $(n-1)$ 个队友（也就是总共 $n$ 个人）会按照固定的顺序依次行动，目标是对 boss 产生尽可能高的总伤害。\n\n游戏设定中共有 $x$ 种攻击模式，第 $i (1 \\le i \\le x)$ 种攻击模式会对 boss 产生 $d_i$ 的基础伤害。\n\n在行动过程中可以对 boss 附着异常状态。异常状态共 $y$ 种，同一时刻 boss 不会陷入两种异常状态。当 boss 陷入特定的异常状态时，使用特定的攻击模式会触发暴击，产生更大的伤害。暴击的规则由 $m$ 个三元组 $(p_j, q_j, c_j)$ 给出，表示在附着第 $p_j (1 \\le p_j \\le y)$ 种异常状态时使用第 $q_j (1 \\le q_j \\le x)$ 种攻击模式会**额外**产生 $c_j$ 的伤害。\n\n对战开始时，boss 没有陷入任何的异常状态。按照行动顺序，第 $i (1 \\le i \\le n)$ 个人可以进行以下三种行动：\n\n- 使用法术使 boss 陷入第 $a_i$ 种异常状态，若 boss 之前陷入了其他异常状态，则之前的异常状态被移除。\n- 使用第 $b_i$ 种攻击模式对 boss 进行攻击，无论是否触发暴击，在产生伤害之后 **boss 的异常状态被移除**。\n- 摸鱼，即什么都不做，此时 boss 的异常状态被保留。\n\n作为剧情党，小 I 自然是不想自己算最优策略，于是他把问题丢给了你。于是你需要求出 $n$ 次行动内总共能产生最多多少伤害。\n", "inputFormat": "输入的第一行四个整数 $n, m, x, y (1 \\le n, m, x, y \\le 2 \\times 10^5)$，分别表示行动次数、暴击规则数、攻击模式种类数和异常状态种类数。\n\n第二行 $x$ 个整数 $d_1,d_2,\\cdots,d_x (1 \\le d_i \\le 10^9)$，依次描述每种攻击模式对 boss 产生的基础伤害量。\n\n接下来 $n$ 行第 $i$ 行两个整数 $a_i, b_i (1 \\le a_i \\le y, 1 \\le b_i \\le x)$，按照行动次序描述第 $i$ 个人的行动。\n\n接下来 $m$ 行第 $j$ 行三个整数 $p_j, q_j, c_j (1 \\le p_j \\le y, 1 \\le q_j \\le x, 1 \\le c_j \\le 10^9)$，描述第 $j$ 条暴击规则。保证 $(p_j, q_j)$ 两两不同。", "outputFormat": "输出一行一个整数，表示 $n$ 次行动对 boss 产生的伤害量总和的最大值。\n", "hint": "样例中共有两种攻击模式和两种异常状态，其中第一种攻击模式会造成 $10$ 的基础伤害，第二种攻击模式会造成 $1$ 的基础伤害。暴击规则仅有一条：在第二种异常状态下进行第二种攻击会额外造成 $10^9$ 的伤害。\n\n最优的行动策略如下：\n\n- 第一个人使用法术使 boss 陷入第二种异常状态；\n- 第二个人摸鱼，boss 仍然陷入第二种异常状态；\n- 第三个人使用第二种攻击模式，产生 $1$ 的基础伤害和 $10^9$ 的暴击伤害，boss 的异常状态被清除；\n- 第四个人使用第二种攻击模式，产生 $1$ 的基础伤害。\n\n总伤害量为 $1 + 10^9 + 1 = 10^9+2$。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
{"pid": "P10543", "type": "P", "difficulty": 4, "samples": [["2\n2 2\nWB\nWW\n2 2\nWW\nWW\n", "J\nI\n"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["博弈论", "2024", "广度优先搜索 BFS", "最短路", "THUPC"], "title": "[THUPC 2024 决赛] 黑白", "background": "", "description": "小 I 和小 J 又在玩游戏。\n\n游戏在一个 $n \\times m$ 的网格上进行，我们用二元组 $(x,y)$ 描述第 $x$ 行第 $y$ 列的格子，其中 $1 \\le x \\le n, 1 \\le y \\le m$。初始时，网格上有至少一个格子是白色的，其他格子是黑色的。\n\n小 I 和小 J 轮流操作，小 I 先手。每次操作时，操作方必须选择恰好一个白色的格子并将其染黑。\n\n称两个格子相邻当且仅当它们共用一条边。若某次操作后，格子 $(1,1)$ 不是白的，或者格子 $(n,m)$ 不是白的，或者无法从 $(1,1)$ 出发，每次经过相邻的白色格子，最终到达 $(n,m)$（即 $(1,1)$ 和 $(n,m)$ 不在同一个白色格子构成的四连通块内），则当前操作方输，另一方胜利。\n\n你作为游戏的观众，想知道在小 I 和小 J 绝顶聪明的情况下，谁会获胜。", "inputFormat": "**本题有多组测试数据。** 输入的第一行一个整数 $T (1 \\le T \\le 100)$ 表示测试数据组数，接下来依次输入每组测试数据。对于每组测试数据，\n\n- 第一行两个整数 $n, m (2 \\le n, m \\le 1000)$，表示网格的大小。\n- 接下来 $n$ 行每行一个长度为 $m$、字符集为 `BW` 的字符串，描述网格初始时的染色情况。其中第 $i$ 行第 $j$ 个字符为 `B` 表示 $(i,j)$ 初始为黑色，否则为 `W` 表示 $(i,j)$ 初始为白色。保证初始棋盘上至少有一个白色格子。\n\n保证单个测试点中所有测试数据的 $n \\times m$ 的和不超过 $5 \\times 10^6$。", "outputFormat": "对于每组测试数据输出一行一个字符，若小 I 必胜输出 `I`，否则若小 J 必胜输出 `J`。\n", "hint": "\n对于第一组测试数据，小 I 只能染黑 $(2,1)$，但染黑 $(2,1)$ 会导致无法仅通过每次移动到相邻的白色格子从 $(1,1)$ 移动到 $(2,2)$，因此无论小 I 如何操作都将失败，故输出 `J`。\n\n对于第二组测试数据，小 I 可以染黑 $(1,2)$，然后无论小 J 如何操作都将失败，故输出 `I`。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 黑白", "background": "", "description": "小 I 和小 J 又在玩游戏。\n\n游戏在一个 $n \\times m$ 的网格上进行，我们用二元组 $(x,y)$ 描述第 $x$ 行第 $y$ 列的格子，其中 $1 \\le x \\le n, 1 \\le y \\le m$。初始时，网格上有至少一个格子是白色的，其他格子是黑色的。\n\n小 I 和小 J 轮流操作，小 I 先手。每次操作时，操作方必须选择恰好一个白色的格子并将其染黑。\n\n称两个格子相邻当且仅当它们共用一条边。若某次操作后，格子 $(1,1)$ 不是白的，或者格子 $(n,m)$ 不是白的，或者无法从 $(1,1)$ 出发，每次经过相邻的白色格子，最终到达 $(n,m)$（即 $(1,1)$ 和 $(n,m)$ 不在同一个白色格子构成的四连通块内），则当前操作方输，另一方胜利。\n\n你作为游戏的观众，想知道在小 I 和小 J 绝顶聪明的情况下，谁会获胜。", "inputFormat": "**本题有多组测试数据。** 输入的第一行一个整数 $T (1 \\le T \\le 100)$ 表示测试数据组数，接下来依次输入每组测试数据。对于每组测试数据，\n\n- 第一行两个整数 $n, m (2 \\le n, m \\le 1000)$，表示网格的大小。\n- 接下来 $n$ 行每行一个长度为 $m$、字符集为 `BW` 的字符串，描述网格初始时的染色情况。其中第 $i$ 行第 $j$ 个字符为 `B` 表示 $(i,j)$ 初始为黑色，否则为 `W` 表示 $(i,j)$ 初始为白色。保证初始棋盘上至少有一个白色格子。\n\n保证单个测试点中所有测试数据的 $n \\times m$ 的和不超过 $5 \\times 10^6$。", "outputFormat": "对于每组测试数据输出一行一个字符，若小 I 必胜输出 `I`，否则若小 J 必胜输出 `J`。\n", "hint": "\n对于第一组测试数据，小 I 只能染黑 $(2,1)$，但染黑 $(2,1)$ 会导致无法仅通过每次移动到相邻的白色格子从 $(1,1)$ 移动到 $(2,2)$，因此无论小 I 如何操作都将失败，故输出 `J`。\n\n对于第二组测试数据，小 I 可以染黑 $(1,2)$，然后无论小 J 如何操作都将失败，故输出 `I`。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
{"pid": "P10544", "type": "P", "difficulty": 6, "samples": [["4 4\n1 0 0 0\n1 2 2 4\n1 1 3\n2 1 4\n3 1 4\n", "1\n1\n1\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2024", "Tarjan", "THUPC"], "title": "[THUPC 2024 决赛] 转化", "background": "", "description": "有 $n$ 种物品和 $m$ 种转化方式。第 $i$ 种转化方式可以将一个第 $a_i$ 种物品转化成 $k_i$ 个互不相同的物品，其中第 $j$ 个的种类是 $b_{i,j}$。同一种转化方式可以使用任意多次。\n\n你有一些物品。你想知道，对于每一种特定的物品 $d$，你用这些你所拥有的物品可以分别转化出最多多少个该种物品。\n", "inputFormat": "第一行两个正整数 $n,m$。\n\n第二行 $n$ 个非负整数，其中第 $i$ 个为 $c_i$，表示你拥有的第 $i$ 种物品的数量。\n\n接下来 $m$ 行，其中第 $i$ 行表示第 $i$ 种转化方式。\n\n转化方式的格式为：一行 $k_i+2$ 个正整数，其中第一个为 $a_i$，第二个为 $k_i$，之后为 $k_i$ 个互不相同的正整数 $b_{i,1},b_{i,2},\\cdots,b_{i,k_i}$​​。\n\n保证 $1\\le n \\le 100$，$1\\le m \\le 1000$。\n\n保证 $1\\le a_i,k_i,b_{i,j} \\le n$。\n\n保证 $0\\le c_i \\le 1000$。", "outputFormat": "输出 $n$ 行，其中第 $d$ 行表示第 $d$ 种物品最多能有多少个。如果可以任意多，即对于任意的 $N$ 都存在一种方案使得有超过 $N$ 个第 $d$ 种物品，输出 `infinity`。\n", "hint": "不使用任何转化方式，可以得到一个物品 $1$。\n\n使用一次第一种转化方式，可以把物品 $1$ 变成物品 $2$ 和物品 $4$。这样可以得到一个物品 $2$。\n\n使用一次第二种转化方式，可以把物品 $1$ 变成物品 $3$。这样可以得到一个物品 $3$。\n\n使用一次第一种转化方式，可以把物品 $1$ 变成物品 $2$ 和物品 $4$。然后再使用一次第三种转化方式，可以把物品 $2$ 变成物品 $4$。这样可以得到两个物品 $4$。\n\n可以证明这四种方案分别是当 $d=1,2,3,4$ 时的最优方案。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 转化", "background": "", "description": "有 $n$ 种物品和 $m$ 种转化方式。第 $i$ 种转化方式可以将一个第 $a_i$ 种物品转化成 $k_i$ 个互不相同的物品，其中第 $j$ 个的种类是 $b_{i,j}$。同一种转化方式可以使用任意多次。\n\n你有一些物品。你想知道，对于每一种特定的物品 $d$，你用这些你所拥有的物品可以分别转化出最多多少个该种物品。\n", "inputFormat": "第一行两个正整数 $n,m$。\n\n第二行 $n$ 个非负整数，其中第 $i$ 个为 $c_i$，表示你拥有的第 $i$ 种物品的数量。\n\n接下来 $m$ 行，其中第 $i$ 行表示第 $i$ 种转化方式。\n\n转化方式的格式为：一行 $k_i+2$ 个正整数，其中第一个为 $a_i$，第二个为 $k_i$，之后为 $k_i$ 个互不相同的正整数 $b_{i,1},b_{i,2},\\cdots,b_{i,k_i}$​​。\n\n保证 $1\\le n \\le 100$，$1\\le m \\le 1000$。\n\n保证 $1\\le a_i,k_i,b_{i,j} \\le n$。\n\n保证 $0\\le c_i \\le 1000$。", "outputFormat": "输出 $n$ 行，其中第 $d$ 行表示第 $d$ 种物品最多能有多少个。如果可以任意多，即对于任意的 $N$ 都存在一种方案使得有超过 $N$ 个第 $d$ 种物品，输出 `infinity`。\n", "hint": "不使用任何转化方式，可以得到一个物品 $1$。\n\n使用一次第一种转化方式，可以把物品 $1$ 变成物品 $2$ 和物品 $4$。这样可以得到一个物品 $2$。\n\n使用一次第二种转化方式，可以把物品 $1$ 变成物品 $3$。这样可以得到一个物品 $3$。\n\n使用一次第一种转化方式，可以把物品 $1$ 变成物品 $2$ 和物品 $4$。然后再使用一次第三种转化方式，可以把物品 $2$ 变成物品 $4$。这样可以得到两个物品 $4$。\n\n可以证明这四种方案分别是当 $d=1,2,3,4$ 时的最优方案。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
{"pid": "P10545", "type": "P", "difficulty": 7, "samples": [["4 7\n1 3\n2 0\n3 0\n2 1\nSWAP 1 0 2\nSWAP 0 1 3\nSWAP 1 2 0\nMOVE 0 0 2\nSWAP 1 0 2\nSWAP 0 2 3\nMOVE 3 0 3\n", "MOVE 0 1\nSWAP\nTRIGGER SWAP: SWAP\nSWAP\n"], ["4 7\n1 2\n2 3\n3 1\n0 2\nTOGGLETRIGGERREPLACE 0 1\nSLACKOFF 3\nMOVE 0 1 3\nSWAP 1 2 3\nTOGGLETRIGGERREPLACE 3 2\nSLACKOFF 2\nSLACKOFF 3\n", "TOGGLETRIGGERREPLACE 0 MOVE MOVE 1 1\nTRIGGER SLACKOFF: SWAP\nTRIGGER SWAP: TOGGLETRIGGERREPLACE 1 TOGGLETRIGGERREPLACE SLACKOFF\nSLACKOFF\n"], ["4 4\n2 1\n1 2\n0 3\n1 3\nSLACKOFF 0\nSLACKOFF 1\nSLACKOFF 2\nSLACKOFF 3\n", "SLACKOFF\nTRIGGER SLACKOFF: SLACKOFF\nTRIGGER SLACKOFF: SLACKOFF\nTRIGGER TRIGGER: SLACKOFF\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["模拟", "2024", "Special Judge", "2-SAT", "THUPC"], "title": "[THUPC 2024 决赛] 机器人", "background": "注意本题的指令含义与初赛的略有不同。\n", "description": "有 $n$ 个机器人围成一圈，编号按照逆时针顺序分别为 $0\\sim n-1$。\n\n每个机器人有两只手。编号为 $i$ 的机器人初始「左手」指向编号 $l_i$ 的机器人，「右手」指向编号 $r_i$ 的机器人。\n\n所有的机器人内部都写有一条「指令」，「指令」有以下这些形式：\n\n### 指令\n\n下面介绍这些「指令」的格式以及它们被「执行」时的效果。文中的“自己”一词均指拥有这条「指令」的机器人。\n\n- `SLACKOFF`：**「摸鱼」**，即什么也不做。\n- `MOVE h z`：将第 $h$ 只手向逆时针方向 **「移动」** $z$ 个机器人的位置。当 $h=0$ 时表示「左手」，当 $h=1$ 时表示「右手」，下同。\n- `SWAP`：**「交换」** 双手指向的机器人的「指令」。\n- `TRIGGER <COMMANDNAME>: <COMMAND>`：其中 `<COMMANDNAME>` 为 `SLACKOFF`、`MOVE`、`SWAP`、`TRIGGER`、`TOGGLETRIGGERREPLACE` 之一；`<COMMAND>` 表示一条完整的非 `TRIGGER` 「指令」。`TRIGGER` 指令本身不会被「执行」，但是，当一个**其他**机器人「执行」完一条「指令」之后，且「右手」指向自己的时候，自己满足如下条件的 `TRIGGER` 指令（如果有）就会被 **「触发」**——「执行」一次对应的 `<COMMAND>`：\n  - `<COMMANDNAME>` 不为 `TRIGGER` 时，刚刚「执行」完毕的「指令」为 `<COMMANDNAME>` 指令；\n  - `<COMMANDNAME>` 为 `TRIGGER` 时，刚刚「执行」完毕的「指令」是一条 `TRIGGER` 指令被「触发」时，「执行」的 `<COMMAND>` 部分。\n- `TOGGLETRIGGERREPLACE h <COMMANDNAME> <NEWCOMMAND>`：如果第 $h$ 只手指向的机器人的「指令」是 `TRIGGER` 指令，则将其 **「切换」** 为该「指令」的 `<COMMAND>` 部分，即删去前面的 `TRIGGER` 及条件部分；如果这条「指令」不是 `TRIGGER` 指令，假设是 `<COMMAND>`，则将其「切换」为 `TRIGGER <COMMANDNAME>: <COMMAND>`。其中 `<COMMANDNAME>` 为 `SLACKOFF`、`MOVE`、`SWAP`、`TRIGGER`、`TOGGLETRIGGERREPLACE` 之一。然后将自己的「指令」（注意这可能不仅仅包含正在「执行」的那部分「指令」）修改为 `<NEWCOMMAND>`。其中，`<NEWCOMMAND>` 是一条完整的「指令」。\n\n机器人「执行」各「指令」时的输出格式如下：\n\n- 「摸鱼」时输出 `Robot <id> slacks off.`。其中 `<id>` 为一个整数，表示「执行」当前「指令」的机器人编号，下同。\n- 「移动」时输出 `Robot <id> moves its <side> hand towards Robot <id2>.`。其中 `<side>` 为 `left` 或 `right`，表示移动了哪只手（`left` 表示「左手」，`right` 表示「右手」）；`<id2>` 为一个整数，表示移动之后这只手指向的机器人的编号。\n- 「交换」时输出 `Robot <id> swaps the commands of Robot <id2> and Robot <id3>.`。其中 `<id2>` 和 `<id3>` 为整数，表示被「交换」「指令」的机器人编号，这两个数可以按任意顺序输出。\n- 「切换」时输出 `Robot <id> toggles the trigger property of the command of Robot <id2>`。\n- `TRIGGER` 指令不会被「执行」，但当它们被「触发」时，会按照上面的格式输出对应的「指令」被「执行」的信息。\n\n你按照一定顺序选择了一些机器人（可能重复选择）并「执行」了对应机器人的「指令」，得到了「执行」的**完整**输出，也就是说，在「执行」完输出中最后一条「指令」之后，没有其他「指令」被「触发」。但是，你忘记了你选择机器人的顺序，也忘了每个机器人开始时有什么「指令」。你只记得机器人的总数以及开始时每个机器人的手指向什么位置。\n\n你想通过已知的所有信息还原出最初所有机器人的「指令」都是什么。", "inputFormat": "第一行两个正整数 $n,k$，其中 $k$ 表示输出的总行数。\n\n接下来 $n$ 行，每行两个整数 $l_i,r_i$，按编号从小到大的顺序输入。\n\n接下来 $k$ 行，每行一条「执行」「指令」的输出信息。\n\n为了减轻处理输入的负担，输出信息被简化如下（没有特殊声明的参数信息含义同上）：\n\n- 「摸鱼」时输出 `SLACKOFF <id>`。\n- 「移动」时输出 `MOVE <id> <side> <id2>`。其中 `<side>` 为 `0` 或 `1`，表示移动了哪只手（`0` 表示「左手」，`1` 表示「右手」）。\n- 「交换」时输出 `SWAP <id> <id2> <id3>`。\n- 「切换」时输出 `TOGGLETRIGGERREPLACE <id> <id2>`。\n- `TRIGGER` 指令不会被「执行」，但当它们被「触发」时，会按照上面的格式输出对应的「指令」被「执行」的信息。\n\n输入保证存在一组初始的「指令」，使得存在一种选择机器人的方式，能够得到对应的输出。\n\n保证 $1\\le n,k \\le 500000$。\n\n保证 $0\\le l_i,r_i<n$。", "outputFormat": "输出 $n$ 行，按编号从小到大输出机器人最初的「指令」，每条一行。\n\n你需要保证「指令」格式正确，且 $0\\le z < n$。\n\n你需要保证你的输出文件不能过大。若你的输出文件大小不超过 $100\\texttt{MB}$，则一定能保证 Special Judge 能够正确返回结果。\n\n此外任何能够得到输入中 $k$ 行输出的答案均算作正确。", "hint": "**样例解释 1**\n\n选择机器人的顺序为 $1,1,0,1,3$，其中第二、六条被「执行」的「指令」是「触发」`TRIGGER` 指令之后被「执行」的。\n\n注意 `TRIGGER` 指令「触发」的时机是在「执行」上一条「指令」之后，所以第一次「交换」之后由于 $1$ 号机器人的「右手」指向了写有 `TRIGGER SWAP: SWAP` 的 $0$ 号机器人，所以这条 `TRIGGER` 指令能被「触发」。\n\n**样例解释 2**\n\n选择机器人的顺序为 $0,3,0,1,3$，其中第五、六条被「执行」的「指令」是「触发」`TRIGGER` 指令之后被「执行」的。\n\n第一次「执行」会使 $1$ 号机器人的「指令」变为 `SWAP`，$0$ 号机器人的「指令」变为 `MOVE 1 1`。\n\n第五次「执行」会使 $2$ 号机器人的「指令」由 `SLACKOFF` 变为 \n```\nTRIGGER TOGGLETRIGGERREPLACE: SLACKOFF\n```\n，$3$ 号机器人的「指令」由\n```\nTRIGGER SWAP: TOGGLETRIGGERREPLACE 1 TOGGLETRIGGERREPLACE SLACKOFF\n```\n会变为 `SLACKOFF` 而不是 `TRIGGER SWAP: SLACKOFF`。\n\n**样例解释 3**\n\n选择机器人的顺序为 $0$，其中第二、三、四条被「执行」的「指令」是「触发」`TRIGGER` 指令之后被「执行」的。\n\n注意 $3$ 号机器人「执行」完「指令」后不会接着「触发」自己的 `TRIGGER` 「指令」，即使它的「右手」指向了自己。\n\n另外，选择一个写有 `TRIGGER` 指令的机器人不会产生任何输出，所以这么做没有意义。\n\n**样例解释 4**\n\n见题目目录下的 *4.in*。该样例不提供样例输出。\n\n**样例解释 5**\n\n见题目目录下的 *5.in*。该样例不提供样例输出。\n\n**提示**\n\n我们会下发一个可执行文件 `checker` 来帮助你检查你的输出是否正确。使用方式为在该文件所在目录下使用如下指令：\n\n```\n./checker <输入文件路径> <你的输出文件路径>\n```\n\n若你的输出正确，程序会输出 `Accepted.`；否则会提示「执行」结果与输入文件最早一次不匹配的地方。\n\n注意，若你使用的输入文件不是样例输入，该程序不会检查是否存在一组初始的「指令」，使得存在一种选择机器人的方式，能够得到对应的「执行」结果。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 机器人", "background": "注意本题的指令含义与初赛的略有不同。\n", "description": "有 $n$ 个机器人围成一圈，编号按照逆时针顺序分别为 $0\\sim n-1$。\n\n每个机器人有两只手。编号为 $i$ 的机器人初始「左手」指向编号 $l_i$ 的机器人，「右手」指向编号 $r_i$ 的机器人。\n\n所有的机器人内部都写有一条「指令」，「指令」有以下这些形式：\n\n### 指令\n\n下面介绍这些「指令」的格式以及它们被「执行」时的效果。文中的“自己”一词均指拥有这条「指令」的机器人。\n\n- `SLACKOFF`：**「摸鱼」**，即什么也不做。\n- `MOVE h z`：将第 $h$ 只手向逆时针方向 **「移动」** $z$ 个机器人的位置。当 $h=0$ 时表示「左手」，当 $h=1$ 时表示「右手」，下同。\n- `SWAP`：**「交换」** 双手指向的机器人的「指令」。\n- `TRIGGER <COMMANDNAME>: <COMMAND>`：其中 `<COMMANDNAME>` 为 `SLACKOFF`、`MOVE`、`SWAP`、`TRIGGER`、`TOGGLETRIGGERREPLACE` 之一；`<COMMAND>` 表示一条完整的非 `TRIGGER` 「指令」。`TRIGGER` 指令本身不会被「执行」，但是，当一个**其他**机器人「执行」完一条「指令」之后，且「右手」指向自己的时候，自己满足如下条件的 `TRIGGER` 指令（如果有）就会被 **「触发」**——「执行」一次对应的 `<COMMAND>`：\n  - `<COMMANDNAME>` 不为 `TRIGGER` 时，刚刚「执行」完毕的「指令」为 `<COMMANDNAME>` 指令；\n  - `<COMMANDNAME>` 为 `TRIGGER` 时，刚刚「执行」完毕的「指令」是一条 `TRIGGER` 指令被「触发」时，「执行」的 `<COMMAND>` 部分。\n- `TOGGLETRIGGERREPLACE h <COMMANDNAME> <NEWCOMMAND>`：如果第 $h$ 只手指向的机器人的「指令」是 `TRIGGER` 指令，则将其 **「切换」** 为该「指令」的 `<COMMAND>` 部分，即删去前面的 `TRIGGER` 及条件部分；如果这条「指令」不是 `TRIGGER` 指令，假设是 `<COMMAND>`，则将其「切换」为 `TRIGGER <COMMANDNAME>: <COMMAND>`。其中 `<COMMANDNAME>` 为 `SLACKOFF`、`MOVE`、`SWAP`、`TRIGGER`、`TOGGLETRIGGERREPLACE` 之一。然后将自己的「指令」（注意这可能不仅仅包含正在「执行」的那部分「指令」）修改为 `<NEWCOMMAND>`。其中，`<NEWCOMMAND>` 是一条完整的「指令」。\n\n机器人「执行」各「指令」时的输出格式如下：\n\n- 「摸鱼」时输出 `Robot <id> slacks off.`。其中 `<id>` 为一个整数，表示「执行」当前「指令」的机器人编号，下同。\n- 「移动」时输出 `Robot <id> moves its <side> hand towards Robot <id2>.`。其中 `<side>` 为 `left` 或 `right`，表示移动了哪只手（`left` 表示「左手」，`right` 表示「右手」）；`<id2>` 为一个整数，表示移动之后这只手指向的机器人的编号。\n- 「交换」时输出 `Robot <id> swaps the commands of Robot <id2> and Robot <id3>.`。其中 `<id2>` 和 `<id3>` 为整数，表示被「交换」「指令」的机器人编号，这两个数可以按任意顺序输出。\n- 「切换」时输出 `Robot <id> toggles the trigger property of the command of Robot <id2>`。\n- `TRIGGER` 指令不会被「执行」，但当它们被「触发」时，会按照上面的格式输出对应的「指令」被「执行」的信息。\n\n你按照一定顺序选择了一些机器人（可能重复选择）并「执行」了对应机器人的「指令」，得到了「执行」的**完整**输出，也就是说，在「执行」完输出中最后一条「指令」之后，没有其他「指令」被「触发」。但是，你忘记了你选择机器人的顺序，也忘了每个机器人开始时有什么「指令」。你只记得机器人的总数以及开始时每个机器人的手指向什么位置。\n\n你想通过已知的所有信息还原出最初所有机器人的「指令」都是什么。", "inputFormat": "第一行两个正整数 $n,k$，其中 $k$ 表示输出的总行数。\n\n接下来 $n$ 行，每行两个整数 $l_i,r_i$，按编号从小到大的顺序输入。\n\n接下来 $k$ 行，每行一条「执行」「指令」的输出信息。\n\n为了减轻处理输入的负担，输出信息被简化如下（没有特殊声明的参数信息含义同上）：\n\n- 「摸鱼」时输出 `SLACKOFF <id>`。\n- 「移动」时输出 `MOVE <id> <side> <id2>`。其中 `<side>` 为 `0` 或 `1`，表示移动了哪只手（`0` 表示「左手」，`1` 表示「右手」）。\n- 「交换」时输出 `SWAP <id> <id2> <id3>`。\n- 「切换」时输出 `TOGGLETRIGGERREPLACE <id> <id2>`。\n- `TRIGGER` 指令不会被「执行」，但当它们被「触发」时，会按照上面的格式输出对应的「指令」被「执行」的信息。\n\n输入保证存在一组初始的「指令」，使得存在一种选择机器人的方式，能够得到对应的输出。\n\n保证 $1\\le n,k \\le 500000$。\n\n保证 $0\\le l_i,r_i<n$。", "outputFormat": "输出 $n$ 行，按编号从小到大输出机器人最初的「指令」，每条一行。\n\n你需要保证「指令」格式正确，且 $0\\le z < n$。\n\n你需要保证你的输出文件不能过大。若你的输出文件大小不超过 $100\\texttt{MB}$，则一定能保证 Special Judge 能够正确返回结果。\n\n此外任何能够得到输入中 $k$ 行输出的答案均算作正确。", "hint": "**样例解释 1**\n\n选择机器人的顺序为 $1,1,0,1,3$，其中第二、六条被「执行」的「指令」是「触发」`TRIGGER` 指令之后被「执行」的。\n\n注意 `TRIGGER` 指令「触发」的时机是在「执行」上一条「指令」之后，所以第一次「交换」之后由于 $1$ 号机器人的「右手」指向了写有 `TRIGGER SWAP: SWAP` 的 $0$ 号机器人，所以这条 `TRIGGER` 指令能被「触发」。\n\n**样例解释 2**\n\n选择机器人的顺序为 $0,3,0,1,3$，其中第五、六条被「执行」的「指令」是「触发」`TRIGGER` 指令之后被「执行」的。\n\n第一次「执行」会使 $1$ 号机器人的「指令」变为 `SWAP`，$0$ 号机器人的「指令」变为 `MOVE 1 1`。\n\n第五次「执行」会使 $2$ 号机器人的「指令」由 `SLACKOFF` 变为 \n```\nTRIGGER TOGGLETRIGGERREPLACE: SLACKOFF\n```\n，$3$ 号机器人的「指令」由\n```\nTRIGGER SWAP: TOGGLETRIGGERREPLACE 1 TOGGLETRIGGERREPLACE SLACKOFF\n```\n会变为 `SLACKOFF` 而不是 `TRIGGER SWAP: SLACKOFF`。\n\n**样例解释 3**\n\n选择机器人的顺序为 $0$，其中第二、三、四条被「执行」的「指令」是「触发」`TRIGGER` 指令之后被「执行」的。\n\n注意 $3$ 号机器人「执行」完「指令」后不会接着「触发」自己的 `TRIGGER` 「指令」，即使它的「右手」指向了自己。\n\n另外，选择一个写有 `TRIGGER` 指令的机器人不会产生任何输出，所以这么做没有意义。\n\n**样例解释 4**\n\n见题目目录下的 *4.in*。该样例不提供样例输出。\n\n**样例解释 5**\n\n见题目目录下的 *5.in*。该样例不提供样例输出。\n\n**提示**\n\n我们会下发一个可执行文件 `checker` 来帮助你检查你的输出是否正确。使用方式为在该文件所在目录下使用如下指令：\n\n```\n./checker <输入文件路径> <你的输出文件路径>\n```\n\n若你的输出正确，程序会输出 `Accepted.`；否则会提示「执行」结果与输入文件最早一次不匹配的地方。\n\n注意，若你使用的输入文件不是样例输入，该程序不会检查是否存在一组初始的「指令」，使得存在一种选择机器人的方式，能够得到对应的「执行」结果。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>\n", "locale": "zh-CN"}}}
{"pid": "P10546", "type": "P", "difficulty": 7, "samples": [["5\n\n1 4 1 2 3\n\n1 1 2 3 4", "\n? 0110\n\n? 0000\n\n! 1 4 2 3 2 4 4 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2024", "交互题", "Special Judge", "随机化", "构造", "THUPC"], "title": "[THUPC 2024 决赛] 采矿", "background": "在精心地规划完工人的移动路线，执行完所有计划之后，你终于有钱了。你承包下了一个更大的矿坑，并购买了更先进的设备。\n\n但是开始运行了你才发现，一部分运输矿物的通道居然装反了！还好它们本来就是可以反向的，并且中控的系统可以让你轻易地操作。\n\n然而，现在最大的问题是，你刚刚接手这个矿坑，你甚至连它长什么样都不知道，也就更不知道每个开关是对应哪一条运输通道的。\n\n时间就是金钱，你想要尽快摸清整个矿坑的结构以及所有开关与通道的对应关系。", "description": "**这是一道交互题。**\n\n已知你的矿坑有 $n$ 个节点，编号为 $1\\sim n$。它们通过 $n-1$ 条运输通道连成一个树形结构。\n\n运输通道都是单向的。对于一条从节点 $u$ 到节点 $v$ 的运输通道，可以将所有由节点 $u$ 产出的矿或运送到节点 $u$ 的矿以较快的速度运送到节点 $v$。如果一个节点有多条以其为起点的运输通道，那么会把这些矿平均分配给这些运输通道。\n\n中控的系统包含 $n-1$ 个开关和一个监视器。开关的编号为 $1\\sim n-1$，每个开关可以拨到 $0$ 或 $1$ 的位置。$n-1$ 个开关和 $n-1$ 条运输通道一一对应，但你并不知道它们的对应关系。你只知道，假设编号为 $i$ 的开关对应的运输通道在被装上去时是从 $u_i$ 到 $v_i$ 的，那么当开关拨到 $0$ 的时候，它的运输方向和它被装上去时相同；当开关拨到 $1$ 的时候，它的运输方向会变成从 $v_i$ 到 $u_i$。你的监视器可以监控到达每个节点的矿分别来自多少个不同的节点，也就是说，有多少个节点（包括其本身）能够通过运输通道把矿运输到这个节点。\n\n当你调整完开关的位置后，需要等一段时间，监视器的结果才会趋于稳定，这时你的读数才是有意义的。所以为了避免浪费太多时间，你希望在 $50$ 次读数之内确定你想知道的所有信息。", "inputFormat": "开始时你需要输入一个正整数 $n$。保证 $2\\le n \\le 10000$。\n\n之后的输入会基于你的输出生成读数。你的读数结果是一行 $n$ 个正整数，其中第 $i$ 个表示到达节点 $i$ 的矿来自多少个不同的节点。\n\n每个测试点中，矿坑的连接方式和所有运输通道刚装上去时的方向都是固定的，也就是说，这些不会因为你的输出而动态修改为另外一种符合之前所有回答的方案。", "outputFormat": "当你需要调整开关并等待读数时，输出一行 `? s`，其中 `s` 为一个长为 $n-1$ 的 `01` 串，其中第 $i$ 位表示编号为 $i$ 的开关拨到的位置。然后交互库会在你的标准输入中给出监视器趋于稳定之后的读数结果。你最多只能读数 $50$ 次。\n\n当你已经知道了所有通道的信息时，输出一行 `! u1 v1 ... un-1 vn-1`，其中 $u_i,v_i$ 表示编号为 $i$ 的开关对应的运输通道被装上去时的方向是从节点 $u_i$ 到节点 $v_i$ 的。\n\n在输出一行之后，你需要刷新输出缓冲区，否则评测结果可能会变成 `TLE`。刷新输出缓冲区的方式为：\n\n- C：`fflush(stdout);`\n\n- C++：`fflush(stdout);` 或 `std::cout.flush();` 或使用 `std::endl` 换行\n\n- Java：`System.out.flush();`\n\n- Python：`sys.stdout.flush()`\n", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/fuc2u4d1.png)\n\n通道的初始方向如上图所示。通道上的数字代表和通道对应的开关的编号。\n\n样例只是用来说明输入输出格式和读数结果，并不意味着这次读数能够推出答案。\n\n\n交互库的运行时间和内存不计入时间和内存限制。\n\n若超出读数次数限制、最后的回答错误或输出格式错误，评测结果均为 `WA`。\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 采矿", "background": "在精心地规划完工人的移动路线，执行完所有计划之后，你终于有钱了。你承包下了一个更大的矿坑，并购买了更先进的设备。\n\n但是开始运行了你才发现，一部分运输矿物的通道居然装反了！还好它们本来就是可以反向的，并且中控的系统可以让你轻易地操作。\n\n然而，现在最大的问题是，你刚刚接手这个矿坑，你甚至连它长什么样都不知道，也就更不知道每个开关是对应哪一条运输通道的。\n\n时间就是金钱，你想要尽快摸清整个矿坑的结构以及所有开关与通道的对应关系。", "description": "**这是一道交互题。**\n\n已知你的矿坑有 $n$ 个节点，编号为 $1\\sim n$。它们通过 $n-1$ 条运输通道连成一个树形结构。\n\n运输通道都是单向的。对于一条从节点 $u$ 到节点 $v$ 的运输通道，可以将所有由节点 $u$ 产出的矿或运送到节点 $u$ 的矿以较快的速度运送到节点 $v$。如果一个节点有多条以其为起点的运输通道，那么会把这些矿平均分配给这些运输通道。\n\n中控的系统包含 $n-1$ 个开关和一个监视器。开关的编号为 $1\\sim n-1$，每个开关可以拨到 $0$ 或 $1$ 的位置。$n-1$ 个开关和 $n-1$ 条运输通道一一对应，但你并不知道它们的对应关系。你只知道，假设编号为 $i$ 的开关对应的运输通道在被装上去时是从 $u_i$ 到 $v_i$ 的，那么当开关拨到 $0$ 的时候，它的运输方向和它被装上去时相同；当开关拨到 $1$ 的时候，它的运输方向会变成从 $v_i$ 到 $u_i$。你的监视器可以监控到达每个节点的矿分别来自多少个不同的节点，也就是说，有多少个节点（包括其本身）能够通过运输通道把矿运输到这个节点。\n\n当你调整完开关的位置后，需要等一段时间，监视器的结果才会趋于稳定，这时你的读数才是有意义的。所以为了避免浪费太多时间，你希望在 $50$ 次读数之内确定你想知道的所有信息。", "inputFormat": "开始时你需要输入一个正整数 $n$。保证 $2\\le n \\le 10000$。\n\n之后的输入会基于你的输出生成读数。你的读数结果是一行 $n$ 个正整数，其中第 $i$ 个表示到达节点 $i$ 的矿来自多少个不同的节点。\n\n每个测试点中，矿坑的连接方式和所有运输通道刚装上去时的方向都是固定的，也就是说，这些不会因为你的输出而动态修改为另外一种符合之前所有回答的方案。", "outputFormat": "当你需要调整开关并等待读数时，输出一行 `? s`，其中 `s` 为一个长为 $n-1$ 的 `01` 串，其中第 $i$ 位表示编号为 $i$ 的开关拨到的位置。然后交互库会在你的标准输入中给出监视器趋于稳定之后的读数结果。你最多只能读数 $50$ 次。\n\n当你已经知道了所有通道的信息时，输出一行 `! u1 v1 ... un-1 vn-1`，其中 $u_i,v_i$ 表示编号为 $i$ 的开关对应的运输通道被装上去时的方向是从节点 $u_i$ 到节点 $v_i$ 的。\n\n在输出一行之后，你需要刷新输出缓冲区，否则评测结果可能会变成 `TLE`。刷新输出缓冲区的方式为：\n\n- C：`fflush(stdout);`\n\n- C++：`fflush(stdout);` 或 `std::cout.flush();` 或使用 `std::endl` 换行\n\n- Java：`System.out.flush();`\n\n- Python：`sys.stdout.flush()`\n", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/fuc2u4d1.png)\n\n通道的初始方向如上图所示。通道上的数字代表和通道对应的开关的编号。\n\n样例只是用来说明输入输出格式和读数结果，并不意味着这次读数能够推出答案。\n\n\n交互库的运行时间和内存不计入时间和内存限制。\n\n若超出读数次数限制、最后的回答错误或输出格式错误，评测结果均为 `WA`。\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>\n\n", "locale": "zh-CN"}}}
{"pid": "P10547", "type": "P", "difficulty": 6, "samples": [["6\n2 1\n3 1\n5 2\n7 5\n10 20\n15 24\n", "1\n2\n7\n331\n1570446\n73880648\n"]], "limits": {"time": [3500, 3500, 3500, 3500, 3500, 3500], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "THUPC"], "title": "[THUPC 2024 决赛] 排列游戏", "background": "提供了额外的 1 秒时限。", "description": "有 $n$ 个格子排成一行，从左到右依次编号为 $1,2,\\cdots,n$，每个格子上有一个数字卡片，初始状态下，格子 $i$ 上的卡片数字为 $i$。\n\n打乱者会进行 $n$ 次交换操作来排列这些卡片：每次选择两个格子 $i,j$（$i\\ne j$），然后交换格子 $i$ 和格子 $j$ 上的卡片。$n$ 次交换操作结束后，就完成了对卡片的排列。\n\n然后轮到玩家行动，玩家同样需要用交换操作，每次交换两张卡片，目标是将这些卡片的顺序还原到初始状态。\n\n交换格子 $i$ 和格子 $j$ 上的卡片所需的时间为 $|i-j|$，玩家打算用最短的时间还原该排列。问：有多少种可能的排列，玩家可以用不超过 $m$ 的总时间完成还原？两种排列不同，当且仅当至少有一张数字卡片在两种排列中所在的格子不同。", "inputFormat": "每个测试点由多组数据组成。\n\n第一行包含一个正整数 $T$，表示数据组数。保证 $T\\le1,000$。\n\n之后 $T$ 行，每行一组数据，包含两个正整数 $n$，$m$。保证 $2\\le n\\le500$，$m\\le5,000$。\n", "outputFormat": "每组数据输出一行，一个整数表示答案。\n\n由于答案可能很大，请输出答案对 $1,000,000,007$ 取模的结果。\n", "hint": "在第 $1$ 组数据中，打乱者的 $2$ 次操作均只可能是交换格子 $1$ 和格子 $2$ 上的卡片，只有 $1$ 种可能的排列，也就是初始状态 $[1,2]$。\n\n在第 $2$ 组数据中，有 $2$ 种可能的排列：$[1,3,2]$ 和 $[2,1,3]$。注意初始状态 $[1,2,3]$ 不是一种可能的排列，因为打乱者进行前 $2$ 次交换之后，所有卡片要么仍在初始状态（前 $2$ 次交换的是同一对卡片），要么均不在初始位置上（前 $2$ 次交换的不是同一对卡片），第 $3$ 次交换后不可能回到初始状态。\n\n在第 $3$ 组数据中，有 $7$ 种可能的排列：$[1,2,3,5,4]$，$[1,2,4,3,5]$，$[1,2,5,4,3]$，$[1,3,2,4,5]$，$[1,4,3,2,5]$，$[2,1,3,4,5]$，$[3,2,1,4,5]$。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 排列游戏", "background": "提供了额外的 1 秒时限。", "description": "有 $n$ 个格子排成一行，从左到右依次编号为 $1,2,\\cdots,n$，每个格子上有一个数字卡片，初始状态下，格子 $i$ 上的卡片数字为 $i$。\n\n打乱者会进行 $n$ 次交换操作来排列这些卡片：每次选择两个格子 $i,j$（$i\\ne j$），然后交换格子 $i$ 和格子 $j$ 上的卡片。$n$ 次交换操作结束后，就完成了对卡片的排列。\n\n然后轮到玩家行动，玩家同样需要用交换操作，每次交换两张卡片，目标是将这些卡片的顺序还原到初始状态。\n\n交换格子 $i$ 和格子 $j$ 上的卡片所需的时间为 $|i-j|$，玩家打算用最短的时间还原该排列。问：有多少种可能的排列，玩家可以用不超过 $m$ 的总时间完成还原？两种排列不同，当且仅当至少有一张数字卡片在两种排列中所在的格子不同。", "inputFormat": "每个测试点由多组数据组成。\n\n第一行包含一个正整数 $T$，表示数据组数。保证 $T\\le1,000$。\n\n之后 $T$ 行，每行一组数据，包含两个正整数 $n$，$m$。保证 $2\\le n\\le500$，$m\\le5,000$。\n", "outputFormat": "每组数据输出一行，一个整数表示答案。\n\n由于答案可能很大，请输出答案对 $1,000,000,007$ 取模的结果。\n", "hint": "在第 $1$ 组数据中，打乱者的 $2$ 次操作均只可能是交换格子 $1$ 和格子 $2$ 上的卡片，只有 $1$ 种可能的排列，也就是初始状态 $[1,2]$。\n\n在第 $2$ 组数据中，有 $2$ 种可能的排列：$[1,3,2]$ 和 $[2,1,3]$。注意初始状态 $[1,2,3]$ 不是一种可能的排列，因为打乱者进行前 $2$ 次交换之后，所有卡片要么仍在初始状态（前 $2$ 次交换的是同一对卡片），要么均不在初始位置上（前 $2$ 次交换的不是同一对卡片），第 $3$ 次交换后不可能回到初始状态。\n\n在第 $3$ 组数据中，有 $7$ 种可能的排列：$[1,2,3,5,4]$，$[1,2,4,3,5]$，$[1,2,5,4,3]$，$[1,3,2,4,5]$，$[1,4,3,2,5]$，$[2,1,3,4,5]$，$[3,2,1,4,5]$。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
{"pid": "P10548", "type": "P", "difficulty": 6, "samples": [["2\n3 4\n5\n", "833333340\n"], ["3\n4 5 6\n7 8\n", "300000004\n"], ["4\n4 6 8 24\n20 22 1207\n", "250000119\n"], ["9\n88 225 365 687 4333 10759 30685 60189 90560\n306 241 336 406 342 86884 86885 86886\n", "94380764\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "THUPC"], "title": "[THUPC 2024 决赛] 朔望", "background": "Syzygy，中文译作朔望，表示三个或三个以上的天体大致位于同一直线上。本题中主要探讨母恒星与至少两颗行星位于同一直线上的情况。\n", "description": "在一个理想的行星系中，所有行星在同一平面内围绕共同的单一母恒星作匀速圆周的公转运动，且公转方向相同（如同为逆时针）。我们定义这样的行星系的 Syzygy 指数为平均每年发生的所有（含母恒星的）朔望的稀有程度之和，其中单次朔望的稀有程度是与产生连线的**行星**数量 $x$ 有关的常数 $w_x$；如果在行星系中同时发生多个朔望但不位于同一直线上，则对每条直线上的行星分别统计稀有程度。\n\n现有一理想的包含 $n$ 颗行星的行星系，其中从内到外第 $i$ 颗行星绕母恒星公转周期为 $t_i$ 年（根据开普勒第三定律可知 $t_i$ 单调递增）。假设存在某一时刻，所有 $n$ 颗行星位于同一条以母恒星为端点的射线上。请求出该系统的 Syzygy  指数。", "inputFormat": "第一行输入一个正整数 $n$（$2\\le n\\le 20$），表示该单星系统中行星的数量。\n\n第二行输入 $n$ 个正整数 $t_1, t_2, \\cdots, t_n$，分别表示公转轨道从内到外各行星的公转周期。保证 $1\\le t_1 < t_2 < \\cdots < t_n\\le 10^9$。\n\n第三行输入 $(n-1)$ 个正整数 $w_2, w_3, \\cdots, w_n$（$1\\le w_i\\le 10^9$），分别表示发生不同数量的行星参与的朔望的稀有程度。", "outputFormat": "输出该行星系的 Syzygy 指数。显然 Syzygy 指数是一个有理数；不妨假设其化为最简分式后的形式为 $p/q$（即其中 $p, q$ 互质），请输出 $x$ 使得 $qx\\equiv p \\pmod{10^9 + 7}$ 且 $0\\le x<10^9 + 7$。可以证明，在本题数据范围下，$x$ 存在且唯一。\n", "hint": "**样例解释 1**\n\n不妨假设 $T=0$ 时刻两颗行星位于同一以母恒星为端点的射线上。由于两颗行星的公转周期的最小公倍数为 $12$ 年，且两颗行星的会合周期也恰为 $\\displaystyle\\frac{1}{\\displaystyle\\left|\\frac{1}{3}-\\frac{1}{4}\\right|}=12$ 年，故可取 $T\\in[0, 12)$ 年的行星系的运行情况作为研究对象。$T$ 取 $[0, 12)$ 中整数值时，行星系的运行情况分别如下各图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/okkdl28r.png)\n\n可以证明，在 $12$ 年的周期内，两颗行星仅发生如上图所示的 $2$ 次朔望（分别为 $T=0$ 时的内行星凌/外行星冲及 $T=6$ 年的合）。因此，该行星系的 Syzygy 指数为\n\n$$\n\\frac{2\\times 5}{12} = \\frac{5}{6} \\equiv 833333340 \\pmod{10^9 +7}.\n$$\n\n**样例解释 2**\n\n同理设 $T=0$ 时刻三颗行星位于同一以母恒星为端点的射线上。由 $\\mathrm{lcm}(4, 5, 6)=60$，可取 $T\\in[0,60)$ 年的行星系的运行情况作为研究对象。在这段时间内，发生的所有含母恒星的朔望如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/df7frwd2.png)\n\n\n因此，该行星系的 Syzygy 指数为\n\n$$\n\\frac{14\\times 7+2\\times 8}{60}=\\frac{19}{10}\\equiv300000004 \\pmod{10^9+7}.\n$$\n\n**样例解释 3**\n\n同理设 $T=0$ 时刻四颗行星位于同一以母恒星为端点的射线上。由 $\\mathrm{lcm}(4, 6, 8, 24)=24$，可取 $T\\in[0,24)$ 年的行星系的运行情况作为研究对象。在这段时间内，发生的所有含母恒星的朔望如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5930jff7.png)\n\n因此，该行星系的 Syzygy 指数为\n\n$$\n\\frac{20\\times 20+0\\times22+2\\times 1207}{24}=\\frac{1407}{12}\\equiv250000119 \\pmod{10^9+7}.\n$$\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 朔望", "background": "Syzygy，中文译作朔望，表示三个或三个以上的天体大致位于同一直线上。本题中主要探讨母恒星与至少两颗行星位于同一直线上的情况。\n", "description": "在一个理想的行星系中，所有行星在同一平面内围绕共同的单一母恒星作匀速圆周的公转运动，且公转方向相同（如同为逆时针）。我们定义这样的行星系的 Syzygy 指数为平均每年发生的所有（含母恒星的）朔望的稀有程度之和，其中单次朔望的稀有程度是与产生连线的**行星**数量 $x$ 有关的常数 $w_x$；如果在行星系中同时发生多个朔望但不位于同一直线上，则对每条直线上的行星分别统计稀有程度。\n\n现有一理想的包含 $n$ 颗行星的行星系，其中从内到外第 $i$ 颗行星绕母恒星公转周期为 $t_i$ 年（根据开普勒第三定律可知 $t_i$ 单调递增）。假设存在某一时刻，所有 $n$ 颗行星位于同一条以母恒星为端点的射线上。请求出该系统的 Syzygy  指数。", "inputFormat": "第一行输入一个正整数 $n$（$2\\le n\\le 20$），表示该单星系统中行星的数量。\n\n第二行输入 $n$ 个正整数 $t_1, t_2, \\cdots, t_n$，分别表示公转轨道从内到外各行星的公转周期。保证 $1\\le t_1 < t_2 < \\cdots < t_n\\le 10^9$。\n\n第三行输入 $(n-1)$ 个正整数 $w_2, w_3, \\cdots, w_n$（$1\\le w_i\\le 10^9$），分别表示发生不同数量的行星参与的朔望的稀有程度。", "outputFormat": "输出该行星系的 Syzygy 指数。显然 Syzygy 指数是一个有理数；不妨假设其化为最简分式后的形式为 $p/q$（即其中 $p, q$ 互质），请输出 $x$ 使得 $qx\\equiv p \\pmod{10^9 + 7}$ 且 $0\\le x<10^9 + 7$。可以证明，在本题数据范围下，$x$ 存在且唯一。\n", "hint": "**样例解释 1**\n\n不妨假设 $T=0$ 时刻两颗行星位于同一以母恒星为端点的射线上。由于两颗行星的公转周期的最小公倍数为 $12$ 年，且两颗行星的会合周期也恰为 $\\displaystyle\\frac{1}{\\displaystyle\\left|\\frac{1}{3}-\\frac{1}{4}\\right|}=12$ 年，故可取 $T\\in[0, 12)$ 年的行星系的运行情况作为研究对象。$T$ 取 $[0, 12)$ 中整数值时，行星系的运行情况分别如下各图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/okkdl28r.png)\n\n可以证明，在 $12$ 年的周期内，两颗行星仅发生如上图所示的 $2$ 次朔望（分别为 $T=0$ 时的内行星凌/外行星冲及 $T=6$ 年的合）。因此，该行星系的 Syzygy 指数为\n\n$$\n\\frac{2\\times 5}{12} = \\frac{5}{6} \\equiv 833333340 \\pmod{10^9 +7}.\n$$\n\n**样例解释 2**\n\n同理设 $T=0$ 时刻三颗行星位于同一以母恒星为端点的射线上。由 $\\mathrm{lcm}(4, 5, 6)=60$，可取 $T\\in[0,60)$ 年的行星系的运行情况作为研究对象。在这段时间内，发生的所有含母恒星的朔望如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/df7frwd2.png)\n\n\n因此，该行星系的 Syzygy 指数为\n\n$$\n\\frac{14\\times 7+2\\times 8}{60}=\\frac{19}{10}\\equiv300000004 \\pmod{10^9+7}.\n$$\n\n**样例解释 3**\n\n同理设 $T=0$ 时刻四颗行星位于同一以母恒星为端点的射线上。由 $\\mathrm{lcm}(4, 6, 8, 24)=24$，可取 $T\\in[0,24)$ 年的行星系的运行情况作为研究对象。在这段时间内，发生的所有含母恒星的朔望如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5930jff7.png)\n\n因此，该行星系的 Syzygy 指数为\n\n$$\n\\frac{20\\times 20+0\\times22+2\\times 1207}{24}=\\frac{1407}{12}\\equiv250000119 \\pmod{10^9+7}.\n$$\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
{"pid": "P10549", "type": "P", "difficulty": 5, "samples": [["1\n2 3\n1 1\n2 1\n2 2\n", "OvO"], ["1\n4 4\n1 1\n1 2\n4 2\n", "QAQ"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "THUPC"], "title": "[THUPC 2024 决赛] 简单博弈", "background": "", "description": "有 $k$ 个棋盘。每个棋盘大小为 $n\\times m$ ，上面有 $3$ 个位置是 $0$，其他是 $1$。\n\n现在 A 和 B 轮流操作，每次操作需要指定一个棋盘，在该棋盘上选定一行或者选定一列或者选定一行一列，将其全部变成 $0$。但是要保证操作前后棋盘至少一个格子数字变了。\n\n不能操作就输了。问是否先手必胜。\n", "inputFormat": "输入的第一行包含一个正整数 $k$ 表示棋盘总数，保证 $1 \\le k \\le 10^5$。\n\n接下来 $k$ 组数据，第 $i$ 组数据共 4 行，描述第 $i$ 张棋盘的样子：\n\n* 第 1 行用空格隔开的两个正整数 $n,m$ 分别表示棋盘的行数和列数，保证 $1\\le n,m \\le 500$。\n* 第 2-4 行，每行用空格隔开的两个正整数 $x,y$ 表示该棋盘上为 $0$ 的位置，保证互不相同且 $1\\leq x\\leq n, 1\\leq y\\leq m$ 。", "outputFormat": "如果先手必胜，输出一个字符串 `OvO`，否则输出一个字符串 `QAQ`。\n", "hint": "一开始棋盘为：\n\n```\n011\n001\n```\n\n先手只需要选中第 1 行第 2 列即可全部清零，从而后手无法操作，先手获胜。\n\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 简单博弈", "background": "", "description": "有 $k$ 个棋盘。每个棋盘大小为 $n\\times m$ ，上面有 $3$ 个位置是 $0$，其他是 $1$。\n\n现在 A 和 B 轮流操作，每次操作需要指定一个棋盘，在该棋盘上选定一行或者选定一列或者选定一行一列，将其全部变成 $0$。但是要保证操作前后棋盘至少一个格子数字变了。\n\n不能操作就输了。问是否先手必胜。\n", "inputFormat": "输入的第一行包含一个正整数 $k$ 表示棋盘总数，保证 $1 \\le k \\le 10^5$。\n\n接下来 $k$ 组数据，第 $i$ 组数据共 4 行，描述第 $i$ 张棋盘的样子：\n\n* 第 1 行用空格隔开的两个正整数 $n,m$ 分别表示棋盘的行数和列数，保证 $1\\le n,m \\le 500$。\n* 第 2-4 行，每行用空格隔开的两个正整数 $x,y$ 表示该棋盘上为 $0$ 的位置，保证互不相同且 $1\\leq x\\leq n, 1\\leq y\\leq m$ 。", "outputFormat": "如果先手必胜，输出一个字符串 `OvO`，否则输出一个字符串 `QAQ`。\n", "hint": "一开始棋盘为：\n\n```\n011\n001\n```\n\n先手只需要选中第 1 行第 2 列即可全部清零，从而后手无法操作，先手获胜。\n\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
{"pid": "P10550", "type": "P", "difficulty": 5, "samples": [["10 5\n1 1 0 0 0 0 0 1 1 1 \n1 1 1 1 1 1 1 1 1 1 \n4 6\n2 4\n2 6\n7 10\n4 7\n", "0\n0\n0\n1\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "THUPC"], "title": "[THUPC 2024 决赛] 贸易", "background": "", "description": "小 Z 生活的学校就像是一条链，直径很长，宽度很窄。\n\n具体来说，这里有一个长度为 $n$ 的序列，每个位置有一个属性 $a_i\\in \\{0/1\\}$ 和一个类型 $c_i$，在这里有一些贸易事件会发生。\n\n小 Z 从左往右通过这个序列，若当前遇到一个 $0$ 属性的节点，则小 Z 可以购入至多一个 $c_i$ 类型的物品，若当前遇到一个 $1$ 属性的节点，则小 Z 可以卖出至多一个 $c_i$ 类型的物品，显然，在小 Z 没有这种类型的物品时是不能卖出的。\n\n一次合法的交易定义为从某个节点买入，并在某个节点卖出，注意，你需要保证在最后小 Z 手里不存在任何东西。\n\n给出 $q$ 次询问，每次小 Z 从 $l_i$ 顺序走到 $r_i$，问：最大合法交易次数是多少。", "inputFormat": "第一行两个正整数 $n,q$。\n\n接下来一行 $n$ 个数，第 $i$ 个表示 $a_i$。\n\n接下来一行 $n$ 个数，第 $i$ 个表示 $c_i$。\n\n接下来 $q$ 行，每行两个数表示 $l_i,r_i$。\n", "outputFormat": "输出共 $q$ 行，每行一个数表示当前这个询问中的最大合法交易次数。", "hint": "对于所有数据，满足 $1\\le n,q\\le5\\times 10^5,1\\le c_i\\le n,1\\le l_i\\le r_i\\le n,a_i\\in\\{0,1\\}$。\n\n请注意输入输出效率。\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 贸易", "background": "", "description": "小 Z 生活的学校就像是一条链，直径很长，宽度很窄。\n\n具体来说，这里有一个长度为 $n$ 的序列，每个位置有一个属性 $a_i\\in \\{0/1\\}$ 和一个类型 $c_i$，在这里有一些贸易事件会发生。\n\n小 Z 从左往右通过这个序列，若当前遇到一个 $0$ 属性的节点，则小 Z 可以购入至多一个 $c_i$ 类型的物品，若当前遇到一个 $1$ 属性的节点，则小 Z 可以卖出至多一个 $c_i$ 类型的物品，显然，在小 Z 没有这种类型的物品时是不能卖出的。\n\n一次合法的交易定义为从某个节点买入，并在某个节点卖出，注意，你需要保证在最后小 Z 手里不存在任何东西。\n\n给出 $q$ 次询问，每次小 Z 从 $l_i$ 顺序走到 $r_i$，问：最大合法交易次数是多少。", "inputFormat": "第一行两个正整数 $n,q$。\n\n接下来一行 $n$ 个数，第 $i$ 个表示 $a_i$。\n\n接下来一行 $n$ 个数，第 $i$ 个表示 $c_i$。\n\n接下来 $q$ 行，每行两个数表示 $l_i,r_i$。\n", "outputFormat": "输出共 $q$ 行，每行一个数表示当前这个询问中的最大合法交易次数。", "hint": "对于所有数据，满足 $1\\le n,q\\le5\\times 10^5,1\\le c_i\\le n,1\\le l_i\\le r_i\\le n,a_i\\in\\{0,1\\}$。\n\n请注意输入输出效率。\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
{"pid": "P10551", "type": "P", "difficulty": 7, "samples": [["5\n3 4\n2 5\n1 6\n2 240117\n3 378140683\n", "280\n0\n4\n451142875\n980338319\n"]], "limits": {"time": [1000, 1000], "memory": [524288, 524288]}, "tags": ["2024", "THUPC"], "title": "[THUPC 2024 决赛] 连向未来", "background": "1 是烟消云散的过去。\n\n2 是转瞬即逝的现在。\n\n3 是遥不可及的未来。\n\n过去的迷惘和烦恼连向了现在。如果梦想的热度至今不曾改变，那么不妨将迷惘和烦恼作为宝贵的经验。\n\n现在也终将连向未来。通往未来的大门必定藏在世界上的某个角落。虽然可能无法简单寻得，但若不向前伸出双手，就无从触及。\n\n想要创造从现在开始的崭新的时间，就需要将大家相连。1、2 和 3，缺一不可。只身一人所无法实现的目标，集齐众人的力量就必能跨过。就算形单影只时已足够努力奋斗，如果连在一起时都能各自加倍拼搏，那么不妨同舟共济，同音共律。", "description": "给定一个 $N\\times M$ 的网格。求在每个格子中分别填入 $1$，$2$ 或 $3$ 的方案数，使得填入后存在至少一种将具有公共边的格子分别相连的方案，满足：\n\n- 每个填有 $1$ 或 $3$ 的格子**恰好**与相邻的任意一个填有 $2$ 的格子相连；\n\n- 每个填有 $2$ 的格子**恰好**与相邻的任意一个填有 $1$ 的格子及任意一个填有 $3$ 的格子分别相连。", "inputFormat": "输入第一行包括一个正整数 $T$，表示该测试点中的数据组数。保证 $1\\le T\\le 100$。\n\n接下来 $T$ 行，每行包含两个由空格隔开的正整数 $N$ 和 $M$，表示网格的大小。保证 $1\\le N\\le 3$，$1\\le M\\le 10^9$。", "outputFormat": "对每组数据输出一行，每行包括一个非负整数，表示填数方案数对 $998,244,353$ 取模之后的结果。", "hint": "不是相遇会带来离别，而是离别会指引新的相遇。\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 连向未来", "background": "1 是烟消云散的过去。\n\n2 是转瞬即逝的现在。\n\n3 是遥不可及的未来。\n\n过去的迷惘和烦恼连向了现在。如果梦想的热度至今不曾改变，那么不妨将迷惘和烦恼作为宝贵的经验。\n\n现在也终将连向未来。通往未来的大门必定藏在世界上的某个角落。虽然可能无法简单寻得，但若不向前伸出双手，就无从触及。\n\n想要创造从现在开始的崭新的时间，就需要将大家相连。1、2 和 3，缺一不可。只身一人所无法实现的目标，集齐众人的力量就必能跨过。就算形单影只时已足够努力奋斗，如果连在一起时都能各自加倍拼搏，那么不妨同舟共济，同音共律。", "description": "给定一个 $N\\times M$ 的网格。求在每个格子中分别填入 $1$，$2$ 或 $3$ 的方案数，使得填入后存在至少一种将具有公共边的格子分别相连的方案，满足：\n\n- 每个填有 $1$ 或 $3$ 的格子**恰好**与相邻的任意一个填有 $2$ 的格子相连；\n\n- 每个填有 $2$ 的格子**恰好**与相邻的任意一个填有 $1$ 的格子及任意一个填有 $3$ 的格子分别相连。", "inputFormat": "输入第一行包括一个正整数 $T$，表示该测试点中的数据组数。保证 $1\\le T\\le 100$。\n\n接下来 $T$ 行，每行包含两个由空格隔开的正整数 $N$ 和 $M$，表示网格的大小。保证 $1\\le N\\le 3$，$1\\le M\\le 10^9$。", "outputFormat": "对每组数据输出一行，每行包括一个非负整数，表示填数方案数对 $998,244,353$ 取模之后的结果。", "hint": "不是相遇会带来离别，而是离别会指引新的相遇。\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
{"pid": "P10552", "type": "P", "difficulty": 0, "samples": [], "limits": {"time": [1000], "memory": [1048576]}, "tags": ["2024", "THUPC"], "title": "[THUPC 2024 决赛] 警钟长鸣", "background": "", "description": "一年两度的 THUPC 又到来了，小 Z 也掏出了他的传统艺能——压轴的整活签到题。对于往年来说，签到题总是能被选手们在刚开场便迅速通过，而这次，小 Z 决定整点不一样的——”如果我把签到题刻意搞得很谜语人，让选手刚开场抓耳挠腮哪怕一小会，岂不是很爽？“\n\n说干就干，小 Z 精心设计了一套花里胡哨的障眼大法，望着最终的成品题目，小 Z 内心充满了得意。他甚至都开始想象起来，开场不久后选手们望着这道题毫无头绪，现场鸦雀无声，排行榜上一片沉寂的样子……\n\n带着这种丰收的喜悦，小 Z 来到了比赛当日的赛场上。然而，随着开考声音的响起，赛场上却呈现出此起彼伏的窃窃私语声，小 Z 走上前去，只听得大家讨论的语气和情绪决不是正常讨论题目应当有的，许多人甚至忍不住笑出了声。\n\n“奇怪，难道我的题目出了什么问题？”小 Z 疑惑地打开排行榜，只见此题的通过人数正在飞速上升，比以往的签到题还要快得多！“不，这不可能！”小 Z 双手颤抖地点开题目，在各个页面之间来回切换。突然，映入眼帘的内容使他瞬间呆住了。\n\n是的你没猜错，小 Z 在这道题的命题环节中出现了严重的失误，使得选手可以轻而易举地通过此题！小 Z 从发现自己命题失误的震惊中稍稍缓和了过来，决定立即着手修复失误。然而，冷静思考后的小 Z 突然意识到了一个五雷轰顶的事实：他已经犯下了无法弥补的错误！\n\n坦率而言，题目出现失误在比赛中并不罕见。大部分常见失误，如涉及到题面、评测数据、评测配置等环节，都可以通过赛时及时的修复来弥补，将损失降低至最小化。然而，小 Z 的失误恰恰是戳中了最致命的要害：选手已经获取到了本不应当获取到的、足以使他们轻松通过此题的信息，此时一切晚矣，一切努力都无法掩盖小 Z 已经捅了大篓子的事实。\n\n“啊~”小 Z 感到一阵天旋地转，几近昏厥。\n\n后续发生的一切，怎么处理的这一套烂摊子，在小 Z 的记忆中已变得模糊不清。时至今日，这一段传奇故事的细节早已散佚。而小 Z 在这过后沉寂了很久，终于决定痛定思痛，将这段往事进行艺术加工后向世人讲述，以示警钟长鸣。", "inputFormat": "无输入。", "outputFormat": "输出本题应当输出的内容。请注意，本题的输出是唯一且确定性的。", "hint": "因为本题是直接输出答案，输出样例可以直接通过此题，所以并未在题面里渲染样例。\n\n请工作人员在赛前仔细检查，不要把样例错发给选手。\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 警钟长鸣", "background": "", "description": "一年两度的 THUPC 又到来了，小 Z 也掏出了他的传统艺能——压轴的整活签到题。对于往年来说，签到题总是能被选手们在刚开场便迅速通过，而这次，小 Z 决定整点不一样的——”如果我把签到题刻意搞得很谜语人，让选手刚开场抓耳挠腮哪怕一小会，岂不是很爽？“\n\n说干就干，小 Z 精心设计了一套花里胡哨的障眼大法，望着最终的成品题目，小 Z 内心充满了得意。他甚至都开始想象起来，开场不久后选手们望着这道题毫无头绪，现场鸦雀无声，排行榜上一片沉寂的样子……\n\n带着这种丰收的喜悦，小 Z 来到了比赛当日的赛场上。然而，随着开考声音的响起，赛场上却呈现出此起彼伏的窃窃私语声，小 Z 走上前去，只听得大家讨论的语气和情绪决不是正常讨论题目应当有的，许多人甚至忍不住笑出了声。\n\n“奇怪，难道我的题目出了什么问题？”小 Z 疑惑地打开排行榜，只见此题的通过人数正在飞速上升，比以往的签到题还要快得多！“不，这不可能！”小 Z 双手颤抖地点开题目，在各个页面之间来回切换。突然，映入眼帘的内容使他瞬间呆住了。\n\n是的你没猜错，小 Z 在这道题的命题环节中出现了严重的失误，使得选手可以轻而易举地通过此题！小 Z 从发现自己命题失误的震惊中稍稍缓和了过来，决定立即着手修复失误。然而，冷静思考后的小 Z 突然意识到了一个五雷轰顶的事实：他已经犯下了无法弥补的错误！\n\n坦率而言，题目出现失误在比赛中并不罕见。大部分常见失误，如涉及到题面、评测数据、评测配置等环节，都可以通过赛时及时的修复来弥补，将损失降低至最小化。然而，小 Z 的失误恰恰是戳中了最致命的要害：选手已经获取到了本不应当获取到的、足以使他们轻松通过此题的信息，此时一切晚矣，一切努力都无法掩盖小 Z 已经捅了大篓子的事实。\n\n“啊~”小 Z 感到一阵天旋地转，几近昏厥。\n\n后续发生的一切，怎么处理的这一套烂摊子，在小 Z 的记忆中已变得模糊不清。时至今日，这一段传奇故事的细节早已散佚。而小 Z 在这过后沉寂了很久，终于决定痛定思痛，将这段往事进行艺术加工后向世人讲述，以示警钟长鸣。", "inputFormat": "无输入。", "outputFormat": "输出本题应当输出的内容。请注意，本题的输出是唯一且确定性的。", "hint": "因为本题是直接输出答案，输出样例可以直接通过此题，所以并未在题面里渲染样例。\n\n请工作人员在赛前仔细检查，不要把样例错发给选手。\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
{"pid": "P10553", "type": "P", "difficulty": 5, "samples": [["2\n\n3\n\n3\n\n3", "\n? 1 2\n\n? 2 3\n\n? 1 3\n\n! 3 3 -1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "交互题", "Special Judge", "O2优化", "ICPC", "西安"], "title": "[ICPC 2024 Xi'an I] Guess The Tree", "background": "", "description": "There is a full binary tree with $n$ levels(so it has exactly $2^n-1$ nodes). Each node has an integer ID from $1$ to $2^n-1$, and the $2^n-1$ IDs form an arrangement from $1$ to $2^n-1$, but you don't know.\n\nYou need to find the IDs of the $2^n-1$ nodes using at most $4800$ queries.", "inputFormat": "The first line contains one integer $n(1\\leq n\\leq 10)$, the levels of the full binary tree.\n\nTo ask a query, you need to pick two nodes with IDs $u,v(1\\leq u,v\\leq 2^n-1)$, and print the line of the following form:\n\n> \"? u v\"\n\nAfter that, you will receive:\n\n> \"t\"\n\nThe lowest common ancestor's ID of $u$ and $v$.\n\nYou can ask at most $4800$ queries.\n\nIf you have found the structure of the tree, print a line of the following form:\n\n\"! $f_1\\ f_2\\ f_3\\ f_4$ ... $f_{2^n-1}$\"\n\n$f_i$ means the i-th node's father's ID. If it has no father, then $f_i=-1$.\n\nAfter printing a query or the answer for a test case, do not forget to output the end of line and flush the output. Otherwise, you will get the verdict 'Idleness Limit Exceeded'. To do this, use:\n\n`fflush(stdout)` or `cout.flush()` in C++;\n\n`System.out.flush()` in Java;\n\n`stdout.flush()` in Python.\n\nThe interactor in this task is not adaptive.", "outputFormat": "", "hint": "In this case, the tree's root is $3$, it's two sons are $1$ and $2$.\n\nFor any query \"? a b\",if $a\\neq b$, the jury will return answer $3$.\n\nSo we found the tree's root is $3$ .", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Xi'an I] Guess The Tree", "background": "", "description": "There is a full binary tree with $n$ levels(so it has exactly $2^n-1$ nodes). Each node has an integer ID from $1$ to $2^n-1$, and the $2^n-1$ IDs form an arrangement from $1$ to $2^n-1$, but you don't know.\n\nYou need to find the IDs of the $2^n-1$ nodes using at most $4800$ queries.", "inputFormat": "The first line contains one integer $n(1\\leq n\\leq 10)$, the levels of the full binary tree.\n\nTo ask a query, you need to pick two nodes with IDs $u,v(1\\leq u,v\\leq 2^n-1)$, and print the line of the following form:\n\n> \"? u v\"\n\nAfter that, you will receive:\n\n> \"t\"\n\nThe lowest common ancestor's ID of $u$ and $v$.\n\nYou can ask at most $4800$ queries.\n\nIf you have found the structure of the tree, print a line of the following form:\n\n\"! $f_1\\ f_2\\ f_3\\ f_4$ ... $f_{2^n-1}$\"\n\n$f_i$ means the i-th node's father's ID. If it has no father, then $f_i=-1$.\n\nAfter printing a query or the answer for a test case, do not forget to output the end of line and flush the output. Otherwise, you will get the verdict 'Idleness Limit Exceeded'. To do this, use:\n\n`fflush(stdout)` or `cout.flush()` in C++;\n\n`System.out.flush()` in Java;\n\n`stdout.flush()` in Python.\n\nThe interactor in this task is not adaptive.", "outputFormat": "", "hint": "In this case, the tree's root is $3$, it's two sons are $1$ and $2$.\n\nFor any query \"? a b\",if $a\\neq b$, the jury will return answer $3$.\n\nSo we found the tree's root is $3$ .", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Xi'an I] Guess The Tree", "background": "", "description": "有一个满二叉树，具有 $n$ 层（因此它恰好有 $2^n-1$ 个节点）。每个节点都有一个从 $1$ 到 $2^n-1$ 的整数 ID，这 $2^n-1$ 个 ID 形成一个从 $1$ 到 $2^n-1$ 的排列，但你并不知道具体的排列。\n\n你需要通过最多 $4800$ 次查询找到这 $2^n-1$ 个节点的 ID。", "inputFormat": "第一行包含一个整数 $n(1\\leq n\\leq 10)$，表示满二叉树的层数。\n\n为了进行一次查询，你需要选择两个节点，其 ID 为 $u,v(1\\leq u,v\\leq 2^n-1)$，并输出如下格式的一行：\n\n> \"? u v\"\n\n之后，你将收到：\n\n> \"t\"\n\n即 $u$ 和 $v$ 的最近公共祖先的 ID。\n\n你最多可以进行 $4800$ 次查询。\n\n如果你已经找到了树的结构，输出如下格式的一行：\n\n\"! $f_1\\ f_2\\ f_3\\ f_4$ ... $f_{2^n-1}$\"\n\n其中 $f_i$ 表示第 $i$ 个节点的父节点的 ID。如果没有父节点，则 $f_i=-1$。\n\n在打印查询或测试用例的答案后，不要忘记输出行尾并刷新输出。否则，你将得到「Idleness Limit Exceeded」的判定。为此，请使用：\n\n`fflush(stdout)` 或 `cout.flush()` 在 C++ 中；\n\n`System.out.flush()` 在 Java 中；\n\n`stdout.flush()` 在 Python 中。\n\n此任务中的交互器不是自适应的。", "outputFormat": "", "hint": "在这个例子中，树的根是 $3$，它的两个儿子是 $1$ 和 $2$。\n\n对于任何查询 \"? a b\"，如果 $a\neq b$，评测系统将返回答案 $3$。\n\n因此我们找到了树的根是 $3$。（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P10554", "type": "P", "difficulty": 5, "samples": [["2 0\n0 1\n1 0", "2\n0 2\n2 0"], ["3 1\n1 0 0\n0 1 0\n0 0 1", "-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "Special Judge", "O2优化", "ICPC", "西安"], "title": "[ICPC 2024 Xi'an I] Turn Off The Lights", "background": "", "description": "Kitty has $n^2$ lights, which form an $n\\times n$ matrix.\n\nOne day, Kitty found that some of these lights were on, and some were off. Kitty wants to turn them all off.\n\nTo achieve her goal, Kitty can perform three types of operations:\n\n- (1) Choose a row, reverse the state of this row. It means if a light of this row is on, after this operation, it is now off. If a light of this row is off, after this operation, it is now on.\n\n- (2) Choose a column, reverse the state of this column. It means if a light of this column is on, after this operation, it is now off. If a light of this column is off, after this operation, it is now on.\n\n- (3) Choose exactly one light, reverse the state of this light. **This operation can only be performed not more than $k$ times.**\n\nFor the current state, help Kitty achieve her goal within $3n$ operations.", "inputFormat": "The first line contains two integers $n(1\\leq n\\leq 1000),k(0\\leq k < n)$, indicating as described above.\n\nThen $n$ lines follow, each line has exactly $n$ numbers, $0$ represents that the light is turned off at this time, while $1$ represents the opposite.\n\nThe $y$-th number of the $(x+1)$-th line in input means the light at coordinate $(x,y)$.", "outputFormat": "If Kitty can not achieve her goal,print $-1$ in a single line.\n\nOtherwise, print $M(0\\leq M\\leq 3n)$ in the first line, indicating the number of operations she needs to perform.\n\nThe next $M$ lines, each line contains $2$ integers $x,y$, separated by white space.\n\nIf $1\\leq x\\leq n,1\\leq y\\leq n$, it means Kitty will reverse the light at coordinate $(x,y)$.\n\nIf $x=0,1\\leq y\\leq n$, it means Kitty will reverse all lights at coordinates $(z,y)1\\leq z\\leq n$.\n\nIf $1\\leq x\\leq n,y=0$, it means Kitty will reverse all lights at coordinates $(x,z)1\\leq z\\leq n$.\n\nIf there are multiple answers, print any of them.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Xi'an I] Turn Off The Lights", "background": "", "description": "Kitty has $n^2$ lights, which form an $n\\times n$ matrix.\n\nOne day, Kitty found that some of these lights were on, and some were off. Kitty wants to turn them all off.\n\nTo achieve her goal, Kitty can perform three types of operations:\n\n- (1) Choose a row, reverse the state of this row. It means if a light of this row is on, after this operation, it is now off. If a light of this row is off, after this operation, it is now on.\n\n- (2) Choose a column, reverse the state of this column. It means if a light of this column is on, after this operation, it is now off. If a light of this column is off, after this operation, it is now on.\n\n- (3) Choose exactly one light, reverse the state of this light. **This operation can only be performed not more than $k$ times.**\n\nFor the current state, help Kitty achieve her goal within $3n$ operations.", "inputFormat": "The first line contains two integers $n(1\\leq n\\leq 1000),k(0\\leq k < n)$, indicating as described above.\n\nThen $n$ lines follow, each line has exactly $n$ numbers, $0$ represents that the light is turned off at this time, while $1$ represents the opposite.\n\nThe $y$-th number of the $(x+1)$-th line in input means the light at coordinate $(x,y)$.", "outputFormat": "If Kitty can not achieve her goal,print $-1$ in a single line.\n\nOtherwise, print $M(0\\leq M\\leq 3n)$ in the first line, indicating the number of operations she needs to perform.\n\nThe next $M$ lines, each line contains $2$ integers $x,y$, separated by white space.\n\nIf $1\\leq x\\leq n,1\\leq y\\leq n$, it means Kitty will reverse the light at coordinate $(x,y)$.\n\nIf $x=0,1\\leq y\\leq n$, it means Kitty will reverse all lights at coordinates $(z,y)1\\leq z\\leq n$.\n\nIf $1\\leq x\\leq n,y=0$, it means Kitty will reverse all lights at coordinates $(x,z)1\\leq z\\leq n$.\n\nIf there are multiple answers, print any of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Xi'an I] Turn Off The Lights", "background": "", "description": "Kitty 有 $n^2$ 个灯泡，这些灯泡组成了一个 $n\\times n$ 的矩阵。\n\n有一天，Kitty 发现这些灯泡中有些是亮的，有些是灭的。Kitty 想要把它们全部关闭。\n\n为了实现她的目标，Kitty 可以执行三种类型的操作：\n\n- (1) 选择一行，反转这一行的状态。这意味着如果这一行的灯泡是亮的，经过此操作后，它将变为灭的。如果这一行的灯泡是灭的，经过此操作后，它将变为亮的。\n\n- (2) 选择一列，反转这一列的状态。这意味着如果这一列的灯泡是亮的，经过此操作后，它将变为灭的。如果这一列的灯泡是灭的，经过此操作后，它将变为亮的。\n\n- (3) 选择一个灯泡，反转这个灯泡的状态。**这种操作最多只能执行 $k$ 次。**\n\n对于当前状态，帮助 Kitty 在 $3n$ 次操作内实现她的目标。", "inputFormat": "第一行包含两个整数 $n(1\\leq n\\leq 1000),k(0\\leq k < n)$，如上所述。\n\n接下来有 $n$ 行，每行有正好 $n$ 个数字，$0$ 表示此时灯泡是灭的，而 $1$ 表示相反。\n\n输入中第 $(x+1)$ 行的第 $y$ 个数字表示坐标 $(x,y)$ 处的灯泡。", "outputFormat": "如果 Kitty 无法实现她的目标，输出 $-1$ 在一行中。\n\n否则，第一行输出 $M(0\\leq M\\leq 3n)$，表示她需要执行的操作次数。\n\n接下来的 $M$ 行中，每行包含 $2$ 个整数 $x,y$，用空格分隔。\n\n如果 $1\\leq x\\leq n,1\\leq y\\leq n$，表示 Kitty 将反转坐标 $(x,y)$ 处的灯泡。\n\n如果 $x=0,1\\leq y\\leq n$，表示 Kitty 将反转所有坐标为 $(z,y)1\\leq z\\leq n$ 的灯泡。\n\n如果 $1\\leq x\\leq n,y=0$，表示 Kitty 将反转所有坐标为 $(x,z)1\\leq z\\leq n$ 的灯泡。\n\n如果有多个答案，输出其中任意一个。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P10555", "type": "P", "difficulty": 5, "samples": [["6\n1 1 1 1 1 1\n1 2\n1 3\n1 4\n2 5\n2 6", "4 4 0 0 0 0"], ["4\n1 2 3 4\n1 2\n1 3\n1 4", "12 0 0 0"], ["7\n1 2 3 4 5 6 7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7", "5 12 16 0 0 0 0"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "O2优化", "ICPC", "西安"], "title": "[ICPC 2024 Xi'an I] Fix the Tree", "background": "", "description": "You are given a tree consisting of $n$ vertices. Each vertex $i$ of this tree has a value $w_i$ assigned to it.\n\nNow the vertex $u$ will be broken. Once it's broken, vertex $u$ and all edges with one end at vertex $u$ will be removed from the tree.\n\nTo make the tree connected, you can do the following operation any number of times(possibly zero) in any order:\n\n- First choose two vertices $u$ and $v$ from the tree;\n- Then pay $w_u+w_v$ coins, and add an edge between vertices $u$ and $v$;\n- At last, replace $w_u+1$ with $w_u$, replace $w_v+1$ with $w_v$.\n\nYour task is to calculate the minimum number of coins to be paid.\n\nBut you don't know which vertex $u$ is, so you need to find the answer for each $1\\le u\\le n$. Please answer all the queries independently.", "inputFormat": "The first line contains a single integer $n(2\\le n\\le 10^6)$ --- the number of vertices in this tree.\n\nThe next line contains $n$ numbers, the $i$ -th number is $w_i(1\\le w_i\\le n)$.\n\nThe next $n-1$ lines contain a description of the tree's edges. The $i$ -th of these lines contains two integers $u_i$ and $v_i(1\\le u_i,v_i\\le n) $ --- the numbers of vertices connected by the $i$ -th edge.\n\nIt is guaranteed that the given edges form a tree.", "outputFormat": "Print $n$ integers, the $i$ -th integer is the answer when $u=i$.", "hint": "给定一个有 $n$ 个点组成的树，每个点有一个权值 $w_i$。  \n点 $u$ 和相邻的边被删除。  \n你可以进行以下操作任意次数（可以为 $0$）,让树重新成为连通图：\n1. 选择两个点 $u$、$v$；\n2. 花费 $w_u + w_v$ 的代价连接一条边 $(u,v)$；\n3. $w_u \\leftarrow w_u+1,w_v \\leftarrow w_v+1$。\n\n对于每个 $u$ 计算最小代价。", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Xi'an I] Fix the Tree", "background": "", "description": "You are given a tree consisting of $n$ vertices. Each vertex $i$ of this tree has a value $w_i$ assigned to it.\n\nNow the vertex $u$ will be broken. Once it's broken, vertex $u$ and all edges with one end at vertex $u$ will be removed from the tree.\n\nTo make the tree connected, you can do the following operation any number of times(possibly zero) in any order:\n\n- First choose two vertices $u$ and $v$ from the tree;\n- Then pay $w_u+w_v$ coins, and add an edge between vertices $u$ and $v$;\n- At last, replace $w_u+1$ with $w_u$, replace $w_v+1$ with $w_v$.\n\nYour task is to calculate the minimum number of coins to be paid.\n\nBut you don't know which vertex $u$ is, so you need to find the answer for each $1\\le u\\le n$. Please answer all the queries independently.", "inputFormat": "The first line contains a single integer $n(2\\le n\\le 10^6)$ --- the number of vertices in this tree.\n\nThe next line contains $n$ numbers, the $i$ -th number is $w_i(1\\le w_i\\le n)$.\n\nThe next $n-1$ lines contain a description of the tree's edges. The $i$ -th of these lines contains two integers $u_i$ and $v_i(1\\le u_i,v_i\\le n) $ --- the numbers of vertices connected by the $i$ -th edge.\n\nIt is guaranteed that the given edges form a tree.", "outputFormat": "Print $n$ integers, the $i$ -th integer is the answer when $u=i$.", "hint": "给定一个有 $n$ 个点组成的树，每个点有一个权值 $w_i$。  \n点 $u$ 和相邻的边被删除。  \n你可以进行以下操作任意次数（可以为 $0$）,让树重新成为连通图：\n1. 选择两个点 $u$、$v$；\n2. 花费 $w_u + w_v$ 的代价连接一条边 $(u,v)$；\n3. $w_u \\leftarrow w_u+1,w_v \\leftarrow w_v+1$。\n\n对于每个 $u$ 计算最小代价。", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Xi'an I] Fix the Tree", "background": "", "description": "给定一棵由 $n$ 个顶点组成的树。树中每个顶点 $i$ 都有一个值 $w_i$。\n\n现在顶点 $u$ 将被破坏。一旦被破坏，顶点 $u$ 和所有以 $u$ 为一端的边将从树中移除。\n\n为了使树重新连通，你可以执行以下操作任意次（可能为零次），顺序不限：\n\n- 首先从树中选择两个顶点 $u$ 和 $v$；\n- 然后支付 $w_u + w_v$ 个硬币，并在顶点 $u$ 和 $v$ 之间添加一条边；\n- 最后，将 $w_u + 1$ 替换为 $w_u$，将 $w_v + 1$ 替换为 $w_v$。\n\n你的任务是计算需要支付的最小硬币数。\n\n但你不知道哪个顶点是 $u$，所以你需要为每个 $1 \\le u \\le n$ 找到答案。请独立回答所有查询。", "inputFormat": "第一行包含一个整数 $n(2 \\le n \\le 10^6)$ —— 这棵树的顶点数。\n\n接下来的一行包含 $n$ 个数，第 $i$ 个数是 $w_i(1 \\le w_i \\le n)$。\n\n接下来的 $n-1$ 行包含树的边的描述。这些行中的第 $i$ 行包含两个整数 $u_i$ 和 $v_i(1 \\le u_i, v_i \\le n)$ —— 由第 $i$ 条边连接的顶点的编号。\n\n保证给定的边构成一棵树。", "outputFormat": "输出 $n$ 个整数，第 $i$ 个整数是当 $u=i$ 时的答案。", "hint": "给定一个有 $n$ 个点组成的树，每个点有一个权值 $w_i$。\n点 $u$ 和相邻的边被删除。\n你可以进行以下操作任意次数（可以为 $0$），让树重新成为连通图：\n1. 选择两个点 $u$、$v$；\n2. 花费 $w_u + w_v$ 的代价连接一条边 $(u,v)$；\n3. $w_u \\leftarrow w_u+1, w_v \\leftarrow w_v+1$。\n\n对于每个 $u$ 计算最小代价。（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P10556", "type": "P", "difficulty": 4, "samples": [["5\n1 4 3 2 5\n1 1 1 1 1", "2"], ["5\n1 4 3 2 5\n1 9 1 1 1", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "O2优化", "枚举", "ICPC", "调和级数", "西安"], "title": "[ICPC 2024 Xi'an I] Make Them Straight", "background": "", "description": "There is a sequence $a$ of non-negative integers of length $n$, the $i$-th element of it is $a_i(1\\leq i\\leq n)$.\n\nA sequence is defined as 'good' if and only if there exists a non negative integer $k(0\\leq k\\leq 10^6)$ that satisfies the following condition:\n\n$a_{i}=a_{1}+(i-1)k$ for all $1\\leq i\\leq n$.\n\nTo make this sequence 'good', for each $i(1\\leq i\\leq n)$, you can do nothing, or pay $b_i$ coin to replace $a_i$ with any non-negative integer.\n\nThe question is, what is the minimum cost to make this sequence 'good'.", "inputFormat": "The first line contains an integer $n(1\\leq n\\leq 2\\times 10^5)$, described in the statement.\n\nThe second line contains $n$ integers $a_1,...,a_n(0\\leq a_i\\leq 10^6)$.\n\nThe third line contains $n$ integers $b_1,...,b_n(0\\leq b_i\\leq 10^6)$.", "outputFormat": "One integer, the answer.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Xi'an I] Make Them Straight", "background": "", "description": "There is a sequence $a$ of non-negative integers of length $n$, the $i$-th element of it is $a_i(1\\leq i\\leq n)$.\n\nA sequence is defined as 'good' if and only if there exists a non negative integer $k(0\\leq k\\leq 10^6)$ that satisfies the following condition:\n\n$a_{i}=a_{1}+(i-1)k$ for all $1\\leq i\\leq n$.\n\nTo make this sequence 'good', for each $i(1\\leq i\\leq n)$, you can do nothing, or pay $b_i$ coin to replace $a_i$ with any non-negative integer.\n\nThe question is, what is the minimum cost to make this sequence 'good'.", "inputFormat": "The first line contains an integer $n(1\\leq n\\leq 2\\times 10^5)$, described in the statement.\n\nThe second line contains $n$ integers $a_1,...,a_n(0\\leq a_i\\leq 10^6)$.\n\nThe third line contains $n$ integers $b_1,...,b_n(0\\leq b_i\\leq 10^6)$.", "outputFormat": "One integer, the answer.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Xi'an I] Make Them Straight", "background": "", "description": "有一个长度为 $n$ 的非负整数序列 $a$，其中第 $i$ 个元素为 $a_i(1\\leq i\\leq n)$。\n\n如果存在一个非负整数 $k(0\\leq k\\leq 10^6)$ 满足以下条件，则该序列被定义为「好」序列：\n\n对于所有 $1\\leq i\\leq n$，都有 $a_{i}=a_{1}+(i-1)k$。\n\n为了使这个序列成为「好」序列，对于每个 $i(1\\leq i\\leq n)$，你可以选择不做任何操作，或者支付 $b_i$ 个硬币将 $a_i$ 替换为任意非负整数。\n\n问题是，使这个序列成为「好」序列的最小代价是多少。", "inputFormat": "第一行包含一个整数 $n(1\\leq n\\leq 2\\times 10^5)$，如题述。\n\n第二行包含 $n$ 个整数 $a_1,...,a_n(0\\leq a_i\\leq 10^6)$。\n\n第三行包含 $n$ 个整数 $b_1,...,b_n(0\\leq b_i\\leq 10^6)$。", "outputFormat": "一个整数，表示答案。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P10557", "type": "P", "difficulty": 5, "samples": [["1\n1 1 1\n -1 2 1\n0 -3 2\n0.1 0.6 0.3", "0.748252"], ["8\n1 3 -2\n0 0 2\n-2 2 1\n0.1 0.3 0.6\n0 0 1\n0.5 0.2 0.3\n0 0 1\n1 0 0\n0 0 1 \n0.33 0.33 0.34\n0.16 0.16 0.68", "0.111111"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "Special Judge", "O2优化", "ICPC", "西安"], "title": "[ICPC 2024 Xi'an I] Dumb Robot", "background": "", "description": "You have a dumb robot, and you are going to let it play games with $n$ robots.\n\nThere is a matrix $A$ with three rows and three columns in the game. We call the number of row $i$ and column $j$ of this matrix $A_{i,j}$. The game goes like this:\n\nTwo players each choose an integer from $[1,3]$ at the same time. We call the number your robot chooses $i$, and the number the other robot chooses $j$.\nThe score is $A_{i,j}$.\nIn game $i$, your robot will play this game with the $i$ -th robot. The $i$ -th robot has a probability of choosing $1$ as $p_{i,1}$, a probability of choosing $2$ as $p_{i,2}$, and a probability of choosing $3$ as $p_{i,3}$.\n\nYour goal is to make the expected value of the score not negative in each game. But your robot is very dumb, so it will choose $1$ with probability $q_1$, $2$ with probability $q_2$, and $3$ with probability $q_3$, and you don't know the value of $q_1,q_2,q_3$.\n\nWe all know that $q_1+q_2+q_3=1$. If $q_1,q_2,q_3$ are chosen uniformly at random from a set of all possible cases, please calculate the probability that you will reach your goal.", "inputFormat": "The first line contains one integer $n$($1\\le n\\le10^4$).\n\nEach of the next $3$ lines contains $3$ integers, the $j$ -th integer in the $i$ -th of these lines is $A_{i,j}$($-20\\le A_{i,j}\\le20$).\n\nEach of the next $n$ lines contains $3$ real numbers, the $j$ -th number in the $i$ -th of these lines is $p_{i,j}$. It is guaranteed that $p_{i,1}+p_{i,2}+p_{i,3}=1$ and $0\\le p_{i,j}$.", "outputFormat": "Output the answer to the problem. It is guaranteed that the answer will never be $0$.\n\nYour answer is considered correct if its absolute or relative error does not exceed $10^{-2}$. Formally, let your answer be $a$, and the jury's answer be $b$. Your answer is accepted if and only if $\\frac{|a-b|}{max(1,|b|)} \\leq 10^{-2}$.\n\n", "hint": "In example $1$, for example, $(q_1=1,q_2=0,q_3=0)$ is ok. In this case, Your robot will always choose $1$, so no matter what number will robot $1$ choose, the score will always be $1$, which is enough to reach your goal.", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Xi'an I] Dumb Robot", "background": "", "description": "You have a dumb robot, and you are going to let it play games with $n$ robots.\n\nThere is a matrix $A$ with three rows and three columns in the game. We call the number of row $i$ and column $j$ of this matrix $A_{i,j}$. The game goes like this:\n\nTwo players each choose an integer from $[1,3]$ at the same time. We call the number your robot chooses $i$, and the number the other robot chooses $j$.\nThe score is $A_{i,j}$.\nIn game $i$, your robot will play this game with the $i$ -th robot. The $i$ -th robot has a probability of choosing $1$ as $p_{i,1}$, a probability of choosing $2$ as $p_{i,2}$, and a probability of choosing $3$ as $p_{i,3}$.\n\nYour goal is to make the expected value of the score not negative in each game. But your robot is very dumb, so it will choose $1$ with probability $q_1$, $2$ with probability $q_2$, and $3$ with probability $q_3$, and you don't know the value of $q_1,q_2,q_3$.\n\nWe all know that $q_1+q_2+q_3=1$. If $q_1,q_2,q_3$ are chosen uniformly at random from a set of all possible cases, please calculate the probability that you will reach your goal.", "inputFormat": "The first line contains one integer $n$($1\\le n\\le10^4$).\n\nEach of the next $3$ lines contains $3$ integers, the $j$ -th integer in the $i$ -th of these lines is $A_{i,j}$($-20\\le A_{i,j}\\le20$).\n\nEach of the next $n$ lines contains $3$ real numbers, the $j$ -th number in the $i$ -th of these lines is $p_{i,j}$. It is guaranteed that $p_{i,1}+p_{i,2}+p_{i,3}=1$ and $0\\le p_{i,j}$.", "outputFormat": "Output the answer to the problem. It is guaranteed that the answer will never be $0$.\n\nYour answer is considered correct if its absolute or relative error does not exceed $10^{-2}$. Formally, let your answer be $a$, and the jury's answer be $b$. Your answer is accepted if and only if $\\frac{|a-b|}{max(1,|b|)} \\leq 10^{-2}$.\n\n", "hint": "In example $1$, for example, $(q_1=1,q_2=0,q_3=0)$ is ok. In this case, Your robot will always choose $1$, so no matter what number will robot $1$ choose, the score will always be $1$, which is enough to reach your goal.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Xi'an I] Dumb Robot", "background": "", "description": "你有一个笨机器人，你打算让它与 $n$ 个机器人玩游戏。\n\n在游戏中有一个 $3 \\times 3$ 的矩阵 $A$。我们称矩阵中第 $i$ 行第 $j$ 列的数为 $A_{i,j}$。游戏规则如下：\n\n两个玩家同时从 $[1,3]$ 中各选择一个整数。我们称你的机器人选择的数为 $i$，另一个机器人选择的数为 $j$。\n得分为 $A_{i,j}$。\n在第 $i$ 局游戏中，你的机器人将与第 $i$ 个机器人进行游戏。第 $i$ 个机器人选择 $1$ 的概率为 $p_{i,1}$，选择 $2$ 的概率为 $p_{i,2}$，选择 $3$ 的概率为 $p_{i,3}$。\n\n你的目标是在每局游戏中使得得分的期望值不为负。但你的机器人非常笨，所以它选择 $1$ 的概率为 $q_1$，选择 $2$ 的概率为 $q_2$，选择 $3$ 的概率为 $q_3$，而你不知道 $q_1,q_2,q_3$ 的值。\n\n我们都知道 $q_1+q_2+q_3=1$。如果 $q_1,q_2,q_3$ 是从所有可能的情况下均匀随机选择的，请计算你达到目标的概率。", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 10^4$）。\n\n接下来的 $3$ 行每行包含 $3$ 个整数，这些行中的第 $i$ 行的第 $j$ 个整数为 $A_{i,j}$（$-20 \\le A_{i,j} \\le 20$）。\n\n接下来的 $n$ 行每行包含 $3$ 个实数，这些行中的第 $i$ 行的第 $j$ 个数为 $p_{i,j}$。保证 $p_{i,1}+p_{i,2}+p_{i,3}=1$ 且 $0 \\le p_{i,j}$。", "outputFormat": "输出问题的答案。保证答案永远不会是 $0$。\n\n如果你的答案的绝对误差或相对误差不超过 $10^{-2}$，则认为你的答案是正确的。形式上，设你的答案为 $a$，评测系统的答案为 $b$。当且仅当 $\\frac{|a-b|}{\\max(1,|b|)} \\leq 10^{-2}$ 时，你的答案被接受。\n\n", "hint": "在例子 $1$ 中，例如，$(q_1=1,q_2=0,q_3=0)$ 是可以的。在这种情况下，你的机器人将始终选择 $1$，所以无论机器人 $1$ 选择什么数字，得分总是 $1$，这足以达到你的目标。（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P10558", "type": "P", "difficulty": 4, "samples": [["1 0\n3", "1"], ["2 0\n2 1", "11"], ["2 0\n2 2", "00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["博弈论", "2024", "O2优化", "ICPC", "西安"], "title": "[ICPC 2024 Xi'an I] XOR Game", "background": "# statement updated:\n$z$ is the number of numbers whose values are $0$.", "description": "Alice and Bob are playing a game against each other.\n\nIn front of them are a multiset $\\{a_i\\}$ of non-negative integers and a single integer $x$. Each number in $a$ is $0$ or $2^i(0\\le i<k)$ before the game.\n\nThis game will be a turn-based game, and Alice will go first. In one person's turn, he or she will choose an integer from $a$. Let this number be $p$. Then this person will choose whether or not to make $x\\gets x\\oplus p$, then remove $p$ from $a$. Here, operation $\\oplus$ means bitwise xor.\n\nAlice wants to make $x$ as big as possible, and Bob wants to make $x$ as small as possible.\n\nYou are a bystander who wants to know the final value of $x$. However, the size of $a$ is a huge number. Formally, there are $b_i$ numbers whose values are $2^i$ in $a$ for all $0\\le i<k$, and $z$ numbers whose values are $0$. But you still want to challenge this impossible problem.\n\nIf Alice and Bob are smart enough, please output the final value of $x$.", "inputFormat": "The first line contains two integers $k,z(1\\le k\\le10^5,0\\le z\\le 10^9)$.\n\nThe next line contains $k$ integers, the $i$ -th integer is $b_{i-1}(0\\le b_{i-1}\\le10^9)$.", "outputFormat": "Output the answer in binary format. Note that you should output exactly $k$ digit from high to low even though this number has leading $0$s.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Xi'an I] XOR Game", "background": "# statement updated:\n$z$ is the number of numbers whose values are $0$.", "description": "Alice and Bob are playing a game against each other.\n\nIn front of them are a multiset $\\{a_i\\}$ of non-negative integers and a single integer $x$. Each number in $a$ is $0$ or $2^i(0\\le i<k)$ before the game.\n\nThis game will be a turn-based game, and Alice will go first. In one person's turn, he or she will choose an integer from $a$. Let this number be $p$. Then this person will choose whether or not to make $x\\gets x\\oplus p$, then remove $p$ from $a$. Here, operation $\\oplus$ means bitwise xor.\n\nAlice wants to make $x$ as big as possible, and Bob wants to make $x$ as small as possible.\n\nYou are a bystander who wants to know the final value of $x$. However, the size of $a$ is a huge number. Formally, there are $b_i$ numbers whose values are $2^i$ in $a$ for all $0\\le i<k$, and $z$ numbers whose values are $0$. But you still want to challenge this impossible problem.\n\nIf Alice and Bob are smart enough, please output the final value of $x$.", "inputFormat": "The first line contains two integers $k,z(1\\le k\\le10^5,0\\le z\\le 10^9)$.\n\nThe next line contains $k$ integers, the $i$ -th integer is $b_{i-1}(0\\le b_{i-1}\\le10^9)$.", "outputFormat": "Output the answer in binary format. Note that you should output exactly $k$ digit from high to low even though this number has leading $0$s.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Xi'an I] XOR Game", "background": "", "description": "Alice 和 Bob 正在进行一场游戏。\n\n在他们面前有一个多重集 $\\{a_i\\}$，其中包含非负整数，还有一个整数 $x$。在游戏开始前，$a$ 中的每个数字都是 $0$ 或 $2^i(0\\le i<k)$。\n\n这是一场回合制游戏，Alice 先开始。在一个人的回合中，他或她将从 $a$ 中选择一个整数。设这个数为 $p$。然后这个人可以选择是否执行 $x\\gets x\\oplus p$，接着从 $a$ 中移除 $p$。这里，操作 $\\oplus$ 表示按位异或。\n\nAlice 想让 $x$ 尽可能大，而 Bob 想让 $x$ 尽可能小。\n\n你是一个旁观者，想知道最终的 $x$ 值。然而，$a$ 的大小是一个巨大的数字。形式上，对于所有 $0\\le i<k$，有 $b_i$ 个数在 $a$ 中的值为 $2^i$，并且有 $z$ 个数的值为 $0$。但你仍然想挑战这个不可能的问题。\n\n如果 Alice 和 Bob 足够聪明，请输出最终的 $x$ 值。", "inputFormat": "第一行包含两个整数 $k,z(1\\le k\\le10^5,0\\le z\\le 10^9)$。\n\n下一行包含 $k$ 个整数，第 $i$ 个整数是 $b_{i-1}(0\\le b_{i-1}\\le10^9)$。", "outputFormat": "以二进制格式输出答案。注意，即使这个数字有前导 $0$，你也应该从高位到低位输出恰好 $k$ 位。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P10559", "type": "P", "difficulty": 6, "samples": [["4 6 10\n2 4\n2 3\n4 3\n3 1\n4 1\n2 1\n0\n7\n1\n6\n2 4\n2 2\n1 3 3\n2 1\n1 1 9\n2 4\n2 2\n1 3 6\n2 4\n2 2", "8\n7\n17\n20\n19\n26\n25"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "O2优化", "ICPC", "西安"], "title": "[ICPC 2024 Xi'an I] The Last Cumulonimbus Cloud", "background": "", "description": "Every April, the city is always shrouded under cumulonimbus clouds.\n\nThis city is connected by $n$ buildings and $m$ two-way streets. In order to facilitate people's travel, any two buildings can directly or indirectly reach each other through the streets. At the same time, no street connects the same building, and there is at most one street that connects each pair of buildings.\n\nThe pace of life in this city is very slow because the city layout is not very bulky.\n\nSpecifically,if we consider this city as an undirected graph $G$ ,it is guaranteed that for any non empty subgraph in this graph,there is at least one building inside it that connects up to 10 streets within the subgraph.\n\nThe rain is not stopping, and the number of cumulonimbus clouds is constantly increasing. At the beginning, there are $a_i$ cumulonimbus clouds above the $i$ -th building, but in the following $q$ days, one of the following two events will occur every day:\n\n- $\\text{1 x v}$ $v$ cumulonimbus clouds have been added over the $x$ -th building.\n- $\\text{2 x}$ you need to report how many cumulonimbus clouds are in total over all buildings directly connected to building $x$.", "inputFormat": "The first line contains three integers $n,m,q(1\\le n\\le 3\\times 10^5,1\\leq m\\leq 3\\times 10^6, 1\\leq q\\leq 2\\times 10^6)$.\n\nEach of the next $m$ lines contains two integers $x,y(1\\leq x,y\\leq n,x\\neq y)$, which represents a street connecting the $x$ -th and $y$ -th buildings.\n\nEach of the next $n$ lines contains an integer $a_i(0\\leq a_i\\leq 100)$.\n\nEach of the next $q$ lines contains two or three integers, if the first integer is $1$, it represents a first type of event, and the next two integers represent $x,v(0\\leq v\\leq 100)$. If the first integer is $2$, it represents a second type of event, the next integer represents $x$.", "outputFormat": "Several rows, each representing a query result for a second type of event.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Xi'an I] The Last Cumulonimbus Cloud", "background": "", "description": "Every April, the city is always shrouded under cumulonimbus clouds.\n\nThis city is connected by $n$ buildings and $m$ two-way streets. In order to facilitate people's travel, any two buildings can directly or indirectly reach each other through the streets. At the same time, no street connects the same building, and there is at most one street that connects each pair of buildings.\n\nThe pace of life in this city is very slow because the city layout is not very bulky.\n\nSpecifically,if we consider this city as an undirected graph $G$ ,it is guaranteed that for any non empty subgraph in this graph,there is at least one building inside it that connects up to 10 streets within the subgraph.\n\nThe rain is not stopping, and the number of cumulonimbus clouds is constantly increasing. At the beginning, there are $a_i$ cumulonimbus clouds above the $i$ -th building, but in the following $q$ days, one of the following two events will occur every day:\n\n- $\\text{1 x v}$ $v$ cumulonimbus clouds have been added over the $x$ -th building.\n- $\\text{2 x}$ you need to report how many cumulonimbus clouds are in total over all buildings directly connected to building $x$.", "inputFormat": "The first line contains three integers $n,m,q(1\\le n\\le 3\\times 10^5,1\\leq m\\leq 3\\times 10^6, 1\\leq q\\leq 2\\times 10^6)$.\n\nEach of the next $m$ lines contains two integers $x,y(1\\leq x,y\\leq n,x\\neq y)$, which represents a street connecting the $x$ -th and $y$ -th buildings.\n\nEach of the next $n$ lines contains an integer $a_i(0\\leq a_i\\leq 100)$.\n\nEach of the next $q$ lines contains two or three integers, if the first integer is $1$, it represents a first type of event, and the next two integers represent $x,v(0\\leq v\\leq 100)$. If the first integer is $2$, it represents a second type of event, the next integer represents $x$.", "outputFormat": "Several rows, each representing a query result for a second type of event.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Xi'an I] The Last Cumulonimbus Cloud", "background": null, "description": "每年四月，这座城市总是被积雨云笼罩。\n\n这座城市由 $n$ 座建筑和 $m$ 条双向街道连接。为了方便人们出行，任何两座建筑都可以通过街道直接或间接到达。同时，没有街道连接同一座建筑，并且每对建筑之间最多有一条街道连接。\n\n由于城市布局不太庞大，这座城市的生活节奏非常缓慢。\n\n具体来说，如果我们将这座城市视为无向图 $G$，则保证在该图的任何非空子图中，至少有一座建筑在子图内连接了最多 10 条街道。\n\n雨不停地下，积雨云的数量不断增加。起初，第 $i$ 座建筑上方有 $a_i$ 个积雨云，但在接下来的 $q$ 天中，每天会发生以下两种事件之一：\n\n- $\\text{1 x v}$ 表示在第 $x$ 座建筑上方增加了 $v$ 个积雨云。\n- $\\text{2 x}$ 表示需要报告直接连接到建筑 $x$ 的所有建筑上方的积雨云总数。", "inputFormat": "第一行包含三个整数 $n,m,q(1\\le n\\le 3\\times 10^5,1\\leq m\\leq 3\\times 10^6, 1\\leq q\\leq 2\\times 10^6)$。\n\n接下来的 $m$ 行中的每一行包含两个整数 $x,y(1\\leq x,y\\leq n,x \\neq y)$，表示连接第 $x$ 座和第 $y$ 座建筑的街道。\n\n接下来的 $n$ 行中的每一行包含一个整数 $a_i(0\\leq a_i\\leq 100)$。\n\n接下来的 $q$ 行中的每一行包含两个或三个整数，如果第一个整数是 $1$，则表示第一种类型的事件，接下来的两个整数表示 $x,v(0\\leq v\\leq 100)$。如果第一个整数是 $2$，则表示第二种类型的事件，接下来的整数表示 $x$。", "outputFormat": "多行，每行表示第二种类型事件的查询结果。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P10560", "type": "P", "difficulty": 6, "samples": [["5\n3 1 5 4 2\n1 2\n2 3\n3 4\n4 5\n", "3 1 5 4 2"], ["9\n9 2 6 3 5 7 1 4 8\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n4 8\n4 9\n", "9 2 1 3 6 4 8 5 7"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "O2优化", "ICPC", "西安"], "title": "[ICPC 2024 Xi'an I] Holes and Balls", "background": "", "description": "You are given $n$ balls, the $i$ -th ball's value is $p_i$. It's guaranteed that $p_1,p_2,\\dots,p_n$ is a permutation of $1,2,3\\dots,n$.\n    \n    \n    \nThere is also a rooted tree of $n$ vertices, each of the vertices is a hole, and each hole can only hold one ball.\n    \n    \n    \nThe tree's root is the first vertex.\n    \n    \n    \nNow you need to fill the holes with the balls.\n    \nYou need to throw each ball in order of $1$ to $n$ in the following steps:\n\n1. Throw the ball into vertex $1$.\n2. Let the vertex where the ball is be $p$.\n3. If the $p$ -th vertex has already been filled with other balls, you need to choose a vertex $x$ and throw the ball into the $x$ -th vertex, then return to step $2$. You need to guarantee that the $x$ -th vertex is the $p$ -th vertex's son and at least one vertex in the subtree of the $x$ -th vertex is not filled.\n4. Otherwise, the ball will fill the $p$ -th vertex.\n\nAfter throwing all the balls, let $a_i$ express the value of the ball in the $i$ -th vertex.\n    \n    \n    \nYou need to find the minimum lexicographical order of $\\{a_n\\}$.\n    \n    \n    \nWe define $dep_i$ as the number of vertices on the path from the $i$ -th vertex to the tree's root(the first vertex).\n    \n    \n    \nSpecially, for any two vertices $x<y$, it's guaranteed that $dep_x\\le dep_y$.\n", "inputFormat": "    \nThe first line contains a single integer $n(1\\le n\\le 5\\times 10^5)$ - the number of vertices in this tree.\n    \n    \n    \nThe next line contains $n$ numbers, the $i$ -th number is $p_i(1\\le p_i\\le n)$. It's guaranteed that $p_1,p_2,\\dots,p_n$ is a permutation of $1,2,3\\dots,n$.\n    \n    \n    \nThe next $n-1$ lines contain a description of the tree's edges. The $i$ -th of these lines contains two integers $u_i$ and $v_i(1\\le u_i,v_i\\le n) $ - the numbers of vertices connected by the $i$ -th edge.\n    \n    \n    \nIt is guaranteed that the given edges form a tree.\n    \n    \n    \nAnd for any vertices $x<y$, it's guaranteed that $dep_x\\le dep_y$.", "outputFormat": "\nOutput $n$ integers, the minimum lexicographical order of $\\{a_n\\}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Xi'an I] Holes and Balls", "background": "", "description": "You are given $n$ balls, the $i$ -th ball's value is $p_i$. It's guaranteed that $p_1,p_2,\\dots,p_n$ is a permutation of $1,2,3\\dots,n$.\n    \n    \n    \nThere is also a rooted tree of $n$ vertices, each of the vertices is a hole, and each hole can only hold one ball.\n    \n    \n    \nThe tree's root is the first vertex.\n    \n    \n    \nNow you need to fill the holes with the balls.\n    \nYou need to throw each ball in order of $1$ to $n$ in the following steps:\n\n1. Throw the ball into vertex $1$.\n2. Let the vertex where the ball is be $p$.\n3. If the $p$ -th vertex has already been filled with other balls, you need to choose a vertex $x$ and throw the ball into the $x$ -th vertex, then return to step $2$. You need to guarantee that the $x$ -th vertex is the $p$ -th vertex's son and at least one vertex in the subtree of the $x$ -th vertex is not filled.\n4. Otherwise, the ball will fill the $p$ -th vertex.\n\nAfter throwing all the balls, let $a_i$ express the value of the ball in the $i$ -th vertex.\n    \n    \n    \nYou need to find the minimum lexicographical order of $\\{a_n\\}$.\n    \n    \n    \nWe define $dep_i$ as the number of vertices on the path from the $i$ -th vertex to the tree's root(the first vertex).\n    \n    \n    \nSpecially, for any two vertices $x<y$, it's guaranteed that $dep_x\\le dep_y$.\n", "inputFormat": "    \nThe first line contains a single integer $n(1\\le n\\le 5\\times 10^5)$ - the number of vertices in this tree.\n    \n    \n    \nThe next line contains $n$ numbers, the $i$ -th number is $p_i(1\\le p_i\\le n)$. It's guaranteed that $p_1,p_2,\\dots,p_n$ is a permutation of $1,2,3\\dots,n$.\n    \n    \n    \nThe next $n-1$ lines contain a description of the tree's edges. The $i$ -th of these lines contains two integers $u_i$ and $v_i(1\\le u_i,v_i\\le n) $ - the numbers of vertices connected by the $i$ -th edge.\n    \n    \n    \nIt is guaranteed that the given edges form a tree.\n    \n    \n    \nAnd for any vertices $x<y$, it's guaranteed that $dep_x\\le dep_y$.", "outputFormat": "\nOutput $n$ integers, the minimum lexicographical order of $\\{a_n\\}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Xi'an I] Holes and Balls", "background": "", "description": "给定 $n$ 个球，第 $i$ 个球的值为 $p_i$。保证 $p_1,p_2,\\dots,p_n$ 是 $1,2,3\\dots,n$ 的一个排列。\n\n有一棵有根树，包含 $n$ 个顶点，每个顶点是一个洞，每个洞只能容纳一个球。\n\n树的根是第一个顶点。\n\n现在你需要用这些球填满洞。\n\n你需要按 $1$ 到 $n$ 的顺序依次投掷每个球，步骤如下：\n\n1. 将球投到顶点 $1$。\n2. 设球所在的顶点为 $p$。\n3. 如果第 $p$ 个顶点已经被其他球填满，你需要选择一个顶点 $x$，将球投到第 $x$ 个顶点，然后返回步骤 $2$。你需要保证第 $x$ 个顶点是第 $p$ 个顶点的子节点，并且第 $x$ 个顶点的子树中至少有一个顶点未被填满。\n4. 否则，球将填满第 $p$ 个顶点。\n\n投完所有球后，用 $a_i$ 表示第 $i$ 个顶点中球的值。\n\n你需要找到 $\\{a_n\\}$ 的最小字典序。\n\n我们定义 $dep_i$ 为从第 $i$ 个顶点到树根（第一个顶点）的路径上的顶点数。\n\n特别地，对于任意两个顶点 $x<y$，保证 $dep_x\\le dep_y$。\n", "inputFormat": "第一行包含一个整数 $n(1\\le n\\le 5\\times 10^5)$，表示这棵树的顶点数。\n\n接下来一行包含 $n$ 个数字，第 $i$ 个数字是 $p_i(1\\le p_i\\le n)$。保证 $p_1,p_2,\\dots,p_n$ 是 $1,2,3\\dots,n$ 的一个排列。\n\n接下来的 $n-1$ 行描述了树的边。第 $i$ 行包含两个整数 $u_i$ 和 $v_i(1\\le u_i,v_i\\le n)$，表示第 $i$ 条边连接的顶点编号。\n\n保证给定的边构成一棵树。\n\n并且对于任意顶点 $x<y$，保证 $dep_x\\le dep_y$。", "outputFormat": "输出 $n$ 个整数，表示 $\\{a_n\\}$ 的最小字典序。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P10561", "type": "P", "difficulty": 4, "samples": [["4 4 3\n1 2\n3 4\n1 4", "10"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "O2优化", "ICPC", "状压 DP", "西安"], "title": "[ICPC 2024 Xi'an I] Smart Quality Inspector", "background": "", "description": "    \nElla has a factory. One day, her factory is facing a product quality inspection.\n    \n    \n    \nHer factory has $N$ production lines. Among the $N$ production lines, $N-K$ of them are qualified, and the other $K$ lines are unqualified. The fine of the $i$ -th$(1\\leq i\\leq K)$ unqualified line is $i$ Yuan.\n    \n    \n    \nThere are $M$ quality inspectors here. For the $j$ -th$(1\\leq j\\leq M)$ quality inspector, he will inspect from the $l_i$ -th line to the $r_i$ -th line and find the unqualified production line with the largest fine among them, then impose this fine on Ella.\n    \n    \n    \nElla does not want to receive so many fines, so she decides to renumber the $N$ production lines to receive the least amount of fines. Please help her.\n    \n    \n    \nIn simple terms:\n    \n    \n    \nYou have a sequence $A$ of length $N$, $A=[1,2,3,...,K,0,0,0,...,0]$. Here $N,K$ are given.\n    \n    \n    \nThere are $M$ pairs of integers, each pair consists of two numbers $l_i,r_i$.\n    \n    \n    \nYou need to rearrange sequence $A$ to minimize the following:\n    \n    \n    \n$$\\sum_{i=1}^M \\max_{j=l_i}^{r_i} (A_{j})$$", "inputFormat": "\n    \nThe first line contains three integers $N,K,M(1\\leq K\\leq N\\leq 20,1\\leq M\\leq 10^5)$, described in the statement.\n    \n    \n    \nThen $M$ lines, the $i$ -th line of them contains two integers $l_i,r_i(1\\leq l_i\\leq r_i\\leq N)$.\n    ", "outputFormat": "\n    \nAn integer indicates the answer.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Xi'an I] Smart Quality Inspector", "background": "", "description": "    \nElla has a factory. One day, her factory is facing a product quality inspection.\n    \n    \n    \nHer factory has $N$ production lines. Among the $N$ production lines, $N-K$ of them are qualified, and the other $K$ lines are unqualified. The fine of the $i$ -th$(1\\leq i\\leq K)$ unqualified line is $i$ Yuan.\n    \n    \n    \nThere are $M$ quality inspectors here. For the $j$ -th$(1\\leq j\\leq M)$ quality inspector, he will inspect from the $l_i$ -th line to the $r_i$ -th line and find the unqualified production line with the largest fine among them, then impose this fine on Ella.\n    \n    \n    \nElla does not want to receive so many fines, so she decides to renumber the $N$ production lines to receive the least amount of fines. Please help her.\n    \n    \n    \nIn simple terms:\n    \n    \n    \nYou have a sequence $A$ of length $N$, $A=[1,2,3,...,K,0,0,0,...,0]$. Here $N,K$ are given.\n    \n    \n    \nThere are $M$ pairs of integers, each pair consists of two numbers $l_i,r_i$.\n    \n    \n    \nYou need to rearrange sequence $A$ to minimize the following:\n    \n    \n    \n$$\\sum_{i=1}^M \\max_{j=l_i}^{r_i} (A_{j})$$", "inputFormat": "\n    \nThe first line contains three integers $N,K,M(1\\leq K\\leq N\\leq 20,1\\leq M\\leq 10^5)$, described in the statement.\n    \n    \n    \nThen $M$ lines, the $i$ -th line of them contains two integers $l_i,r_i(1\\leq l_i\\leq r_i\\leq N)$.\n    ", "outputFormat": "\n    \nAn integer indicates the answer.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Xi'an I] Smart Quality Inspector", "background": "", "description": "Ella 有一家工厂。一天，她的工厂面临产品质量检查。  她的工厂有 $N$ 条生产线。在这 $N$ 条生产线中，有 $N-K$ 条是合格的，另外 $K$ 条是不合格的。第 $i$ 条（$1\\leq i\\leq K$）不合格生产线的罚款为 $i$ 元。  这里有 $M$ 名质量检查员。对于第 $j$ 名（$1\\leq j\\leq M$）质量检查员，他将检查从第 $l_i$ 条到第 $r_i$ 条的生产线，并在其中找到罚款最高的不合格生产线，然后将此罚款施加给 Ella。  Ella 不想收到太多罚款，所以她决定重新编号这 $N$ 条生产线以使收到的罚款最少。请帮助她。  简单来说：  你有一个长度为 $N$ 的序列 $A$，$A=[1,2,3,...,K,0,0,0,...,0]$。这里 $N,K$ 已知。  有 $M$ 对整数，每对由两个数字 $l_i,r_i$ 组成。  你需要重新排列序列 $A$ 以最小化以下值：  $$\\sum_{i=1}^M \\max_{j=l_i}^{r_i} (A_{j})$$", "inputFormat": "第一行包含三个整数 $N,K,M(1\\leq K\\leq N\\leq 20,1\\leq M\\leq 10^5)$，如题所述。  接下来 $M$ 行，每行包含两个整数 $l_i,r_i(1\\leq l_i\\leq r_i\\leq N)$。", "outputFormat": "一个整数，表示答案。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P10562", "type": "P", "difficulty": 3, "samples": [["6 8", "24"], ["5 5\n", "15"], ["1 999999", "500000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "O2优化", "ICPC", "西安"], "title": "[ICPC 2024 Xi'an I] Triangle", "background": "", "description": "There are three points $A(a, 0)$, $B(0, b)$, $C(0, 0)$ in the plane rectangular coordinate system. Define the size of triangle $ABC$ as the number of squares that belong to it.\n    \n    \n    \nFor integers $x,y$, one square is defined by four points $(x, y)$, $(x + 1, y)$, $(x, y + 1)$, $(x + 1, y + 1)$. We consider a square to belong to a triangle if half or more of it is inside the triangle.\n    \n    \n    \nFor example, when $a = 8, b = 6$, the size of triangle $ABC$ will be $24$. The image below shows which squares are counted in the triangle.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3fnqi74y.png)", "inputFormat": "\n    \nThe first and only line contains two integers $a\\ (1\\le a\\le 10^6)$ and $b\\ (1\\le b\\le 10^6)$.", "outputFormat": "\nPrint an integer: the size of triangle $ABC$.\n    ", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Xi'an I] Triangle", "background": "", "description": "There are three points $A(a, 0)$, $B(0, b)$, $C(0, 0)$ in the plane rectangular coordinate system. Define the size of triangle $ABC$ as the number of squares that belong to it.\n    \n    \n    \nFor integers $x,y$, one square is defined by four points $(x, y)$, $(x + 1, y)$, $(x, y + 1)$, $(x + 1, y + 1)$. We consider a square to belong to a triangle if half or more of it is inside the triangle.\n    \n    \n    \nFor example, when $a = 8, b = 6$, the size of triangle $ABC$ will be $24$. The image below shows which squares are counted in the triangle.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3fnqi74y.png)", "inputFormat": "\n    \nThe first and only line contains two integers $a\\ (1\\le a\\le 10^6)$ and $b\\ (1\\le b\\le 10^6)$.", "outputFormat": "\nPrint an integer: the size of triangle $ABC$.\n    ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Xi'an I] Triangle", "background": "", "description": "在平面直角坐标系中有三个点 $A(a, 0)$、$B(0, b)$、$C(0, 0)$。定义三角形 $ABC$ 的大小为属于它的正方形的数量。\n\n对于整数 $x, y$，一个正方形由四个点 $(x, y)$、$(x + 1, y)$、$(x, y + 1)$、$(x + 1, y + 1)$ 定义。如果一个正方形有一半或更多的部分在三角形内，我们认为它属于三角形。\n\n例如，当 $a = 8, b = 6$ 时，三角形 $ABC$ 的大小为 $24$。下图显示了哪些正方形被计入三角形中。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3fnqi74y.png)", "inputFormat": "第一行包含两个整数 $a\\ (1\\le a\\le 10^6)$ 和 $b\\ (1\\le b\\le 10^6)$。", "outputFormat": "输出一个整数：三角形 $ABC$ 的大小。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P10563", "type": "P", "difficulty": 7, "samples": [["10\n1 1\n1 2\n2 2\n4 4\n3 3\n5 5\n1 8\n20 20\n100 100\n500 500", "0\n1\n10\n241456\n964\n200419152\n448\n985051144\n370696900\n357517517"]], "limits": {"time": [3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288]}, "tags": ["2024", "O2优化", "ICPC", "西安"], "title": "[ICPC 2024 Xi'an I] Yet Another Maximum Matching Counting Problem", "background": "", "description": "There is a two-dimensional plane.\n    \n    \n    \nYou have a set of points $\\{(x_i,y_i)\\}$ that satisfies $1\\le x_i\\le n, 1\\le y_i\\le m$ (Both $x_i$ and $y_i$ are integers), and there are no two points with the same coordinates.\n    \n    \n    \nIf two points have the same horizontal or vertical coordinates, we will connect an edge between these two points. This forms a graph.\n    \n    \n    \nYou need to find the sum of the maximum number of matches in the graphs formed by all possible $2^{nm}-1$ non empty sets, and output the result modulo $998244353$.\n    \n    \n    \nHere, the maximum number of matches in a graph is defined as: selecting the most edges so that there are no common vertices between any two edges.", "inputFormat": "\nThere are multiple testcases in this problem.\n    \n    \n    \nThe first line contains an integer $T(1\\le T\\le 100)$, which represents the number of testcases.\n    \n    \n    \nEach of the testcases contains two integers $n,m(1\\leq n,m\\leq 500)$.", "outputFormat": " \nFor each of the testcases, print an integer representing the result modulo $998244353$.\n    ", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Xi'an I] Yet Another Maximum Matching Counting Problem", "background": "", "description": "There is a two-dimensional plane.\n    \n    \n    \nYou have a set of points $\\{(x_i,y_i)\\}$ that satisfies $1\\le x_i\\le n, 1\\le y_i\\le m$ (Both $x_i$ and $y_i$ are integers), and there are no two points with the same coordinates.\n    \n    \n    \nIf two points have the same horizontal or vertical coordinates, we will connect an edge between these two points. This forms a graph.\n    \n    \n    \nYou need to find the sum of the maximum number of matches in the graphs formed by all possible $2^{nm}-1$ non empty sets, and output the result modulo $998244353$.\n    \n    \n    \nHere, the maximum number of matches in a graph is defined as: selecting the most edges so that there are no common vertices between any two edges.", "inputFormat": "\nThere are multiple testcases in this problem.\n    \n    \n    \nThe first line contains an integer $T(1\\le T\\le 100)$, which represents the number of testcases.\n    \n    \n    \nEach of the testcases contains two integers $n,m(1\\leq n,m\\leq 500)$.", "outputFormat": " \nFor each of the testcases, print an integer representing the result modulo $998244353$.\n    ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Xi'an I] Yet Another Maximum Matching Counting Problem", "background": "", "description": "在一个二维平面上，\n\n你有一组点 $\\{(x_i,y_i)\\}$，满足 $1\\le x_i\\le n, 1\\le y_i\\le m$（$x_i$ 和 $y_i$ 都是整数），并且没有两个点具有相同的坐标。\n\n如果两个点具有相同的水平或垂直坐标，我们将在这两个点之间连接一条边。这将形成一个图。\n\n你需要找到由所有可能的 $2^{nm}-1$ 个非空集合形成的图中的最大匹配数之和，并输出结果对 $998244353$ 取模。\n\n在这里，图中的最大匹配数定义为：选择最多的边，使得任何两条边之间没有公共顶点。", "inputFormat": "\n这个问题有多个测试用例。\n\n第一行包含一个整数 $T(1\\le T\\le 100)$，表示测试用例的数量。\n\n每个测试用例包含两个整数 $n,m(1\\leq n,m\\leq 500)$。", "outputFormat": "\n对于每个测试用例，输出一个整数，表示结果对 $998244353$ 取模。\n", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P10564", "type": "P", "difficulty": 4, "samples": [["4\n1 aaa 1\n2 aa\n1 ab 2\n2 bb", "1\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "O2优化", "ICPC", "西安"], "title": "[ICPC 2024 Xi'an I] Rubbish Sorting", "background": "", "description": "\nBob has many pieces of rubbish. One day, he wants to sort them.\n    \n    \n    \nFor every piece of rubbish, its type is expressed as a positive integer.\n    \n    \n    \nHe has $q$ operations. For each operation, it is one of the following two operations.\n\n- `1 s x` He tells you that the piece of rubbish named $s$ has a type of $x$.\n- `2 s` He wants to ask you the type of rubbish $s$.\n\n\n    \nBut his memories are not always accurate.\n    \n    \n    \nFor each operation $2$, $s$ may not have appeared in the previous operation $1$s.\n    \n    \n    \nWe define the similarity of two strings $s_1$ and $s_2$ as $\\sum_{i=1}^{\\min\\{|s_1|,|s_2|\\}} [s_{1,i}=s_{2,i}]$.\n    \n    \n    \nHere all the strings' indexes start at $1$.\n    \n    \n    \nFor a string $s$, its type is the type of string which has the maximum similarity to $s$ among all the strings that have appeared in the previous operations $1$s. Note that if there are multiple strings that all have the maximum similarity to $s$, the type of $s$ is the minimum type of these strings' type.\n    \n    \n    \nNow, he wants you to solve this problem.\n    ", "inputFormat": "\nThe first line contains an integer $q(1\\le q\\le 3\\times 10^5)$, which is the number of operations.\n    \n    \n    \nNext $q$ lines contain operations, one per line. They correspond to the description given in the statement.\n    \n    \n    \nIt is guaranteed that for every operation $2$ there is at least one operation $1$ before it.\n    \n    \n    \nBut some pieces of rubbish will have more than one type, you can consider it as the minimum type you have read.\n    \n    \n    \nThe rubbish's names only consist of lowercase Latin letters.\n    \n    \n    \n$1 \\le |s| \\le 5, 1 \\le x \\le 10^9$", "outputFormat": "\n    \nFor every operation $2$, you should print an integer in a single line that is the rubbish $s$'s type.\n    ", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Xi'an I] Rubbish Sorting", "background": "", "description": "\nBob has many pieces of rubbish. One day, he wants to sort them.\n    \n    \n    \nFor every piece of rubbish, its type is expressed as a positive integer.\n    \n    \n    \nHe has $q$ operations. For each operation, it is one of the following two operations.\n\n- `1 s x` He tells you that the piece of rubbish named $s$ has a type of $x$.\n- `2 s` He wants to ask you the type of rubbish $s$.\n\n\n    \nBut his memories are not always accurate.\n    \n    \n    \nFor each operation $2$, $s$ may not have appeared in the previous operation $1$s.\n    \n    \n    \nWe define the similarity of two strings $s_1$ and $s_2$ as $\\sum_{i=1}^{\\min\\{|s_1|,|s_2|\\}} [s_{1,i}=s_{2,i}]$.\n    \n    \n    \nHere all the strings' indexes start at $1$.\n    \n    \n    \nFor a string $s$, its type is the type of string which has the maximum similarity to $s$ among all the strings that have appeared in the previous operations $1$s. Note that if there are multiple strings that all have the maximum similarity to $s$, the type of $s$ is the minimum type of these strings' type.\n    \n    \n    \nNow, he wants you to solve this problem.\n    ", "inputFormat": "\nThe first line contains an integer $q(1\\le q\\le 3\\times 10^5)$, which is the number of operations.\n    \n    \n    \nNext $q$ lines contain operations, one per line. They correspond to the description given in the statement.\n    \n    \n    \nIt is guaranteed that for every operation $2$ there is at least one operation $1$ before it.\n    \n    \n    \nBut some pieces of rubbish will have more than one type, you can consider it as the minimum type you have read.\n    \n    \n    \nThe rubbish's names only consist of lowercase Latin letters.\n    \n    \n    \n$1 \\le |s| \\le 5, 1 \\le x \\le 10^9$", "outputFormat": "\n    \nFor every operation $2$, you should print an integer in a single line that is the rubbish $s$'s type.\n    ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Xi'an I] Rubbish Sorting", "background": null, "description": "Bob 有很多垃圾。有一天，他想要对它们进行分类。\n\n对于每一件垃圾，其类型用一个正整数表示。\n\n他有 $q$ 个操作。对于每个操作，可能是以下两种操作之一。\n\n- `1 s x` 他告诉你，名为 $s$ 的垃圾类型为 $x$。\n- `2 s` 他想询问你垃圾 $s$ 的类型。\n\n但他的记忆并不总是准确的。\n\n对于每个操作 $2$，$s$ 可能没有在之前的操作 $1$ 中出现过。\n\n我们定义两个字符串 $s_1$ 和 $s_2$ 的相似度为 $\\sum_{i=1}^{\\min\\{|s_1|,|s_2|\\}} [s_{1,i}=s_{2,i}]$。\n\n这里所有字符串的索引从 $1$ 开始。\n\n对于一个字符串 $s$，其类型是与 $s$ 相似度最大的字符串的类型，在所有之前操作 $1$ 中出现过的字符串中。如果有多个字符串与 $s$ 的相似度都最大，那么 $s$ 的类型是这些字符串类型中的最小值。\n\n现在，他希望你解决这个问题。", "inputFormat": "第一行包含一个整数 $q(1\\le q\\le 3\\times 10^5)$，表示操作的数量。\n\n接下来的 $q$ 行包含操作，每行一个。它们对应于题目中给出的描述。\n\n保证对于每个操作 $2$，在它之前至少有一个操作 $1$。\n\n但有些垃圾会有多种类型，你可以将其视为你读到的最小类型。\n\n垃圾的名称仅由小写拉丁字母组成。\n\n$1 \\le |s| \\le 5, 1 \\le x \\le 10^9$。", "outputFormat": "对于每个操作 $2$，你应该在单独的一行中输出一个整数，即垃圾 $s$ 的类型。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P10565", "type": "P", "difficulty": 2, "samples": [["2\n1 1\n3 2", "YES\nNO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "O2优化", "ICPC", "西安"], "title": "[ICPC 2024 Xi'an I] Chained Lights", "background": "", "description": "\nYou have $n$ lights in a row. Initially, they are all off.\n    \n    \n    \nYou are going to press these $n$ lights one by one. When you press light $i$, light $i$ will switch its state, which means it will turn on if it's off and turn off if it's on, and then for every $j$ satisfied $i|j,i< j\\le n$, press light $j$ once.\n    \n    \n    \nFor example, if $n=4$, when you press light $1$, light $1$ will turn on, and then you will press light $2,3,4$. Since you pressed light $2$, light $2$ will turn on and you will press light $4$, which will cause light 4 to turn on. After all the operations, lights $1,2,3$ will be turned on and light $4$ is still off.\n    \n    \n    \nYou will press these $n$ lights and do the operations as mentioned above one by one. After all the operations, you want to know whether light $k$ is on or off.\n    \n    \n    \nYou can also use the following code to understand the meaning of the problem:\n\n```cpp\nvoid press(int x)\n{\n    light[x]^=1;\n    for (int y=x+x;y<=n;y+=x) press(y);\n}\nfor (int i=1;i<=n;i++) press(i);\n```", "inputFormat": "\nThere are multiple testcases.\n    \n    \n    \nThe first line contains an integer $T(1\\le T\\le10^5)$, which represents the number of testcases.\n    \n    \n    \nEach of the testcases contains two integers $n,k(1\\le k\\le n\\le10^6)$ in a single line.", "outputFormat": "    \n    \nFor each testcase, if light $k$ is turned on in the end, output $\\text{YES}$, otherwise output $\\text{NO}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Xi'an I] Chained Lights", "background": "", "description": "\nYou have $n$ lights in a row. Initially, they are all off.\n    \n    \n    \nYou are going to press these $n$ lights one by one. When you press light $i$, light $i$ will switch its state, which means it will turn on if it's off and turn off if it's on, and then for every $j$ satisfied $i|j,i< j\\le n$, press light $j$ once.\n    \n    \n    \nFor example, if $n=4$, when you press light $1$, light $1$ will turn on, and then you will press light $2,3,4$. Since you pressed light $2$, light $2$ will turn on and you will press light $4$, which will cause light 4 to turn on. After all the operations, lights $1,2,3$ will be turned on and light $4$ is still off.\n    \n    \n    \nYou will press these $n$ lights and do the operations as mentioned above one by one. After all the operations, you want to know whether light $k$ is on or off.\n    \n    \n    \nYou can also use the following code to understand the meaning of the problem:\n\n```cpp\nvoid press(int x)\n{\n    light[x]^=1;\n    for (int y=x+x;y<=n;y+=x) press(y);\n}\nfor (int i=1;i<=n;i++) press(i);\n```", "inputFormat": "\nThere are multiple testcases.\n    \n    \n    \nThe first line contains an integer $T(1\\le T\\le10^5)$, which represents the number of testcases.\n    \n    \n    \nEach of the testcases contains two integers $n,k(1\\le k\\le n\\le10^6)$ in a single line.", "outputFormat": "    \n    \nFor each testcase, if light $k$ is turned on in the end, output $\\text{YES}$, otherwise output $\\text{NO}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Xi'an I] Chained Lights", "background": null, "description": "你有 $n$ 盏灯排成一行。最初，它们都是关闭的。  你将逐个按下这 $n$ 盏灯。当你按下灯 $i$ 时，灯 $i$ 将切换其状态，这意味着如果它是关闭的，它将打开；如果它是打开的，它将关闭。然后对于每个满足 $i|j, i < j \\le n$ 的 $j$，按下灯 $j$ 一次。  例如，如果 $n=4$，当你按下灯 $1$ 时，灯 $1$ 将打开，然后你将按下灯 $2,3,4$。由于你按下了灯 $2$，灯 $2$ 将打开，你将按下灯 $4$，这将导致灯 $4$ 打开。经过所有操作后，灯 $1,2,3$ 将打开，而灯 $4$ 仍然关闭。  你将逐个按下这 $n$ 盏灯并进行上述操作。经过所有操作后，你想知道灯 $k$ 是开着还是关着的。  你也可以使用以下代码来理解问题的含义： \n```cpp \nvoid press(int x) {\n    light[x]^=1;\n    for (int y=x+x; y<=n; y+=x) press(y);\n}\nfor (int i=1; i<=n; i++) press(i);\n```", "inputFormat": "有多个测试用例。  第一行包含一个整数 $T(1 \\le T \\le 10^5)$，表示测试用例的数量。  每个测试用例包含两个整数 $n, k(1 \\le k \\le n \\le 10^6)$，在一行中。", "outputFormat": "对于每个测试用例，如果灯 $k$ 最终是打开的，输出 `YES`，否则输出 `NO`。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P10566", "type": "P", "difficulty": 1, "samples": [["AA0aa", "31"], ["3kyOu", "89"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "O2优化", "洛谷月赛"], "title": "「Daily OI Round 4」Analysis", "background": "", "description": "小 C 的信息技术老师给小 C 布置了一项作业，作业内容如下：\n\n> 有一个字符串，包含大小写字母和数字。你可以把任意一个字符变成另外一个字符，设变化之前字符的 ASCII 码为 $a$，变化之后字符的 ASCII 码为 $b$，则这次变化消耗 $|a-b|$ 的时间。你需要把整个字符串变成只包含大写字母的字符串。\n\n小 C 还有语文数学英语等很多其他重要作业要做，为了节省时间，你需要计算小 C 最少需要多久才能令字符串只包含大写字母。", "inputFormat": "一行一个字符串 $s$ 表示老师给的字符串。", "outputFormat": "一行一个非负整数 $t$，表示令字符串只包含大写字母最少花费多少时间。", "hint": "#### 【样例解释】\n\n对于第一组样例，最好的办法是变成 $\\texttt{AAAZZ}$，这样的话消耗就为 $0+0+|48-65|+|97-90|+|97-90|=31$，容易证明不存在更优的解法。\n\n其中 $48$ 是字符 $\\texttt{0}$ 的 ASCII 码，$65$ 是字符 $\\texttt{A}$ 的 ASCII 码，$90$ 是字符 $\\texttt{Z}$ 的 ASCII 码，$97$ 是字符 $\\texttt{a}$ 的 ASCII 码。\n\n#### 【数据范围】\n\n**本题开启捆绑测试。**\n\n设 $len$ 为字符串 $s$ 的长度。\n\n| $\\text{Subtask}$ | 分值 | $len \\le$ |\n| :-----------: | :-----------: | :-----------: |\n| $0$ | $10$ | $3$ |\n| $1$ | $30$ | $10$ |\n| $2$ | $60$ | $10^5$ |\n\n对于全部数据，保证：$1 \\le len \\le 10^5$，且 $s$ 中只包含大小写字母和数字。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「Daily OI Round 4」Analysis", "background": "", "description": "小 C 的信息技术老师给小 C 布置了一项作业，作业内容如下：\n\n> 有一个字符串，包含大小写字母和数字。你可以把任意一个字符变成另外一个字符，设变化之前字符的 ASCII 码为 $a$，变化之后字符的 ASCII 码为 $b$，则这次变化消耗 $|a-b|$ 的时间。你需要把整个字符串变成只包含大写字母的字符串。\n\n小 C 还有语文数学英语等很多其他重要作业要做，为了节省时间，你需要计算小 C 最少需要多久才能令字符串只包含大写字母。", "inputFormat": "一行一个字符串 $s$ 表示老师给的字符串。", "outputFormat": "一行一个非负整数 $t$，表示令字符串只包含大写字母最少花费多少时间。", "hint": "#### 【样例解释】\n\n对于第一组样例，最好的办法是变成 $\\texttt{AAAZZ}$，这样的话消耗就为 $0+0+|48-65|+|97-90|+|97-90|=31$，容易证明不存在更优的解法。\n\n其中 $48$ 是字符 $\\texttt{0}$ 的 ASCII 码，$65$ 是字符 $\\texttt{A}$ 的 ASCII 码，$90$ 是字符 $\\texttt{Z}$ 的 ASCII 码，$97$ 是字符 $\\texttt{a}$ 的 ASCII 码。\n\n#### 【数据范围】\n\n**本题开启捆绑测试。**\n\n设 $len$ 为字符串 $s$ 的长度。\n\n| $\\text{Subtask}$ | 分值 | $len \\le$ |\n| :-----------: | :-----------: | :-----------: |\n| $0$ | $10$ | $3$ |\n| $1$ | $30$ | $10$ |\n| $2$ | $60$ | $10^5$ |\n\n对于全部数据，保证：$1 \\le len \\le 10^5$，且 $s$ 中只包含大小写字母和数字。", "locale": "zh-CN"}}}
{"pid": "P10567", "type": "P", "difficulty": 2, "samples": [["2", "Yes"], ["755689", "No"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "洛谷原创", "O2优化", "洛谷月赛", "Ad-hoc"], "title": "「Daily OI Round 4」Square", "background": "", "description": "小 A 给了你一个边长为 $n$ 的正方形网格，你需要把 $1 \\sim n \\times n$ 这些编号填入这个网格里面，满足每一行的编号加起来都是奇数，每一列的编号加起来都是偶数。\n\n在填之前，你想知道是否有任何一种解法满足上述条件，如果可以，输出 `Yes`；否则，输出 `No`。", "inputFormat": "一行一个正整数 $n$，表示正方形网格的边长。", "outputFormat": "一行一个字符串，`Yes` 或 `No`。", "hint": "#### 【样例解释】\n\n对于第一组样例，设 $A$ 表示正方形网格，则有 $A_{1,1}=1,A_{1,2}=2,A_{2,1}=3,A_{2,2}=4$ 的解法。\n\n对于第二组样例，可以证明无解。\n\n#### 【数据范围】\n  \n**本题开启捆绑测试。**\n\n|$\\text{Subtask}$|分值|$n \\le$|\n| :-----------: | :-------------:|:-----------: |\n|$0$|$10$|$10$|\n|$1$|$20$|$10^6$|\n|$2$|$70$|$10^{18}$|\n\n对于全部数据，保证：$1 \\le n \\le 10^{18}$。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「Daily OI Round 4」Square", "background": "", "description": "小 A 给了你一个边长为 $n$ 的正方形网格，你需要把 $1 \\sim n \\times n$ 这些编号填入这个网格里面，满足每一行的编号加起来都是奇数，每一列的编号加起来都是偶数。\n\n在填之前，你想知道是否有任何一种解法满足上述条件，如果可以，输出 `Yes`；否则，输出 `No`。", "inputFormat": "一行一个正整数 $n$，表示正方形网格的边长。", "outputFormat": "一行一个字符串，`Yes` 或 `No`。", "hint": "#### 【样例解释】\n\n对于第一组样例，设 $A$ 表示正方形网格，则有 $A_{1,1}=1,A_{1,2}=2,A_{2,1}=3,A_{2,2}=4$ 的解法。\n\n对于第二组样例，可以证明无解。\n\n#### 【数据范围】\n  \n**本题开启捆绑测试。**\n\n|$\\text{Subtask}$|分值|$n \\le$|\n| :-----------: | :-------------:|:-----------: |\n|$0$|$10$|$10$|\n|$1$|$20$|$10^6$|\n|$2$|$70$|$10^{18}$|\n\n对于全部数据，保证：$1 \\le n \\le 10^{18}$。\n\n", "locale": "zh-CN"}}}
{"pid": "P10569", "type": "P", "difficulty": 4, "samples": [["3\n5\n2 3 1 4 5\n6 \n6 6 6 6 6 6\n6\n1 1 4 5 1 4", "7\n6\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "洛谷原创", "O2优化", "洛谷月赛"], "title": "「Daily OI Round 4」Snow", "background": "", "description": "下雪了，小 Y 堆了 $n$ 个雪柱排成一排，调皮的小 X 打算推倒这 $n$ 个雪柱，他想在最少的时间内推倒所有雪柱，于是他请你来为他出谋划策。\n\n小 Y 堆的每个雪柱高 $a_i$ 单位，推倒一个雪柱的时间为该雪柱的高度。小 X 只能从这一排雪柱的两端推雪柱 \\*，次数不限，小 X 移动的时间可以忽略不计。这样就可以使一个雪柱倒向其他雪柱，从而击倒另一个雪柱（击倒的时间忽略不计），然后发生连锁反应，更加节省时间 \\*\\*。\n\n设初始的势能为当前手动推倒的雪柱 $k$ 的高度 $p=a_k$，则此轮连锁反应中第 $i$ 个雪柱倒向第 $j$ 个雪柱时：\n\n- 若 $p\\ge a_j$，则使第 $j$ 个雪柱也被击倒，并令 $p \\gets a_j$。\n- 若 $p< a_j$，则第 $j$ 个雪柱的高度减少（不被击倒），终止整个连锁反应，令 $a_j \\gets a_j-p$。\n\n请你求出推倒所有雪柱的最短时间。\n\n\\*：每一次要么从左边推最左边的雪柱，要么从右边推最右边的雪柱。\n\n\\*\\*：雪柱的倒塌方向取决于推雪柱的方向，如果从左边推，雪柱就会向右依次倒塌（第 $i$ 个雪柱倒塌向第 $i+1$ 个雪柱），反之同理。", "inputFormat": "**本题有多组测试数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n \n第一行一个整数 $n$，表示雪柱的数量。\n\n第二行 $n$ 个整数，分别表示每个雪柱的高度。", "outputFormat": "对于每组数据：输出一行一个整数，表示推倒所有雪柱的最短时间。", "hint": "#### 【样例解释】\n\n- **对于第一组数据：**\n\n> 第一次从左边推，耗费 $2$ 点时间，使得 $5$ 个雪柱 的高度分别变为：$0,1,1,4,5$。 \n>\n> 第二次从右边推，耗费 $5$ 点时间，使得所有雪柱都被击倒。 \n>\n> 共耗费 $7$ 点时间。\n\n- **对于第二组数据：**\n\n> 从左边或者右边都可以一次性推完，共耗费 $6$ 点时间。\n\n- **对于第三组数据：**\n\n> 第一次从右边推，耗费 $4$ 点时间，使得 $6$ 个雪柱的高度分别变为：$1,1,4,4,0,0$。  \n>\n> 第二次从右边推，耗费 $4$ 点时间，使得所有雪柱都被击倒。\n>\n> 共耗费 $8$ 点时间。\n\n#### 【数据范围】\n  \n**本题采用捆绑测试。**\n\n|$\\text{Subtask}$|分值|$n \\le$|\n| :-----------: | :-------------:|:-----------: |\n|$0$|$10$|$20$|\n|$1$|$15$|$100$|\n|$2$|$25$|$1000$|\n|$3$|$50$|$10^5$|\n\n对于全部数据，保证：$1 \\le T \\le 10$，$1 \\le n \\le 10^5$，$1 \\le a_i \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「Daily OI Round 4」Snow", "background": "", "description": "下雪了，小 Y 堆了 $n$ 个雪柱排成一排，调皮的小 X 打算推倒这 $n$ 个雪柱，他想在最少的时间内推倒所有雪柱，于是他请你来为他出谋划策。\n\n小 Y 堆的每个雪柱高 $a_i$ 单位，推倒一个雪柱的时间为该雪柱的高度。小 X 只能从这一排雪柱的两端推雪柱 \\*，次数不限，小 X 移动的时间可以忽略不计。这样就可以使一个雪柱倒向其他雪柱，从而击倒另一个雪柱（击倒的时间忽略不计），然后发生连锁反应，更加节省时间 \\*\\*。\n\n设初始的势能为当前手动推倒的雪柱 $k$ 的高度 $p=a_k$，则此轮连锁反应中第 $i$ 个雪柱倒向第 $j$ 个雪柱时：\n\n- 若 $p\\ge a_j$，则使第 $j$ 个雪柱也被击倒，并令 $p \\gets a_j$。\n- 若 $p< a_j$，则第 $j$ 个雪柱的高度减少（不被击倒），终止整个连锁反应，令 $a_j \\gets a_j-p$。\n\n请你求出推倒所有雪柱的最短时间。\n\n\\*：每一次要么从左边推最左边的雪柱，要么从右边推最右边的雪柱。\n\n\\*\\*：雪柱的倒塌方向取决于推雪柱的方向，如果从左边推，雪柱就会向右依次倒塌（第 $i$ 个雪柱倒塌向第 $i+1$ 个雪柱），反之同理。", "inputFormat": "**本题有多组测试数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n \n第一行一个整数 $n$，表示雪柱的数量。\n\n第二行 $n$ 个整数，分别表示每个雪柱的高度。", "outputFormat": "对于每组数据：输出一行一个整数，表示推倒所有雪柱的最短时间。", "hint": "#### 【样例解释】\n\n- **对于第一组数据：**\n\n> 第一次从左边推，耗费 $2$ 点时间，使得 $5$ 个雪柱 的高度分别变为：$0,1,1,4,5$。 \n>\n> 第二次从右边推，耗费 $5$ 点时间，使得所有雪柱都被击倒。 \n>\n> 共耗费 $7$ 点时间。\n\n- **对于第二组数据：**\n\n> 从左边或者右边都可以一次性推完，共耗费 $6$ 点时间。\n\n- **对于第三组数据：**\n\n> 第一次从右边推，耗费 $4$ 点时间，使得 $6$ 个雪柱的高度分别变为：$1,1,4,4,0,0$。  \n>\n> 第二次从右边推，耗费 $4$ 点时间，使得所有雪柱都被击倒。\n>\n> 共耗费 $8$ 点时间。\n\n#### 【数据范围】\n  \n**本题采用捆绑测试。**\n\n|$\\text{Subtask}$|分值|$n \\le$|\n| :-----------: | :-------------:|:-----------: |\n|$0$|$10$|$20$|\n|$1$|$15$|$100$|\n|$2$|$25$|$1000$|\n|$3$|$50$|$10^5$|\n\n对于全部数据，保证：$1 \\le T \\le 10$，$1 \\le n \\le 10^5$，$1 \\le a_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10570", "type": "P", "difficulty": 2, "samples": [["3\n2 3 4\n4 8 5\n5 2 8\n", "10\n15\n28\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2024", "洛谷原创", "O2优化", "洛谷月赛"], "title": "[JRKSJ R8] 网球", "background": "~~垒球是橙色的~~ 网球是绿色的。~~网球是上升的，网球是下落的~~。\n\n> And you never meet the people, you never shake their hands, you never hear their story or tell yours.  \n> But somehow in the act of making something with a great deal of care and love, something's transmitted there.", "description": "你有两个啮合在一起的齿轮，你希望齿轮 A 每转 $a$ 圈齿轮 B 都能转恰好 $b$ 圈。\n\n由于精细度要求，每个齿轮都必须有**不少于** $c$ 个齿，求齿轮 A 和齿轮 B 的总齿数和的最小值。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$ 描述数据组数。对于每组数据：\n\n- 仅一行，三个整数 $a, b, c$。", "outputFormat": "对于每组数据，一行一个整数表示答案。", "hint": "### 样例解释\n\n- 对于第一组数据，最优方案为齿轮 A 有 $6$ 个齿，齿轮 B 有 $4$ 个齿，答案为 $4 + 6 = 10$；\n- 对于第二组数据，最优方案为齿轮 A 有 $10$ 个齿，齿轮 B 有 $5$ 个齿，答案为 $10 + 5 = 15$；\n- 对于第三组数据，最优方案为齿轮 A 有 $8$ 个齿，齿轮 B 有 $20$ 个齿，答案为 $8 + 20 = 28$。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n令 $v = \\max(a, b, c)$。\n\n- Subtask 0（13 pts）：$v \\leq 20$；\n- Subtask 1（13 pts）：$v \\leq 5000$；\n- Subtask 2（20 pts）：$v \\leq 10^6$；\n- Subtask 3（54 pts）：无特殊限制。\n\n对于所有数据，保证 $1 \\leq T \\leq 8\\times 10^3$，$1 \\leq a, b, c \\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JRKSJ R8] 网球", "background": "~~垒球是橙色的~~ 网球是绿色的。~~网球是上升的，网球是下落的~~。\n\n> And you never meet the people, you never shake their hands, you never hear their story or tell yours.  \n> But somehow in the act of making something with a great deal of care and love, something's transmitted there.", "description": "你有两个啮合在一起的齿轮，你希望齿轮 A 每转 $a$ 圈齿轮 B 都能转恰好 $b$ 圈。\n\n由于精细度要求，每个齿轮都必须有**不少于** $c$ 个齿，求齿轮 A 和齿轮 B 的总齿数和的最小值。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$ 描述数据组数。对于每组数据：\n\n- 仅一行，三个整数 $a, b, c$。", "outputFormat": "对于每组数据，一行一个整数表示答案。", "hint": "### 样例解释\n\n- 对于第一组数据，最优方案为齿轮 A 有 $6$ 个齿，齿轮 B 有 $4$ 个齿，答案为 $4 + 6 = 10$；\n- 对于第二组数据，最优方案为齿轮 A 有 $10$ 个齿，齿轮 B 有 $5$ 个齿，答案为 $10 + 5 = 15$；\n- 对于第三组数据，最优方案为齿轮 A 有 $8$ 个齿，齿轮 B 有 $20$ 个齿，答案为 $8 + 20 = 28$。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n令 $v = \\max(a, b, c)$。\n\n- Subtask 0（13 pts）：$v \\leq 20$；\n- Subtask 1（13 pts）：$v \\leq 5000$；\n- Subtask 2（20 pts）：$v \\leq 10^6$；\n- Subtask 3（54 pts）：无特殊限制。\n\n对于所有数据，保证 $1 \\leq T \\leq 8\\times 10^3$，$1 \\leq a, b, c \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10571", "type": "P", "difficulty": 3, "samples": [["2468", "3"], ["164", "2"], ["65535", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "洛谷原创", "O2优化", "洛谷月赛", "Ad-hoc"], "title": "[JRKSJ R8] 三七二十一", "background": "", "description": "给你一个由 $1\\sim 9$ 的数字组成的数字串 $s$。定义一个数字串 $s$ 表示的数为将其看作十进制数得到的数。形式化地说，长为 $n$ 的数字串 $s$ 表示的数是 $\\sum_{i=1}^n  10^{n-i}s_i$。\n\n你可以对这个数字串执行若干次操作，每次操作中你可以选定一个位置 $1\\le p\\le n$ 并将 $s_p$ 修改为任意 $1\\sim 9$ 中的数字。你需要使该数字串**不存在**任何一个非空子串满足这个子串表示的数字是 $2^k(k\\in \\N)$ 即 $2$ 的任意**非负整数**次幂，请你求出最少的操作次数。", "inputFormat": "一行一个数字串 $s$。", "outputFormat": "一行一个整数表示答案。", "hint": "### 样例解释\n\n对于样例 $1$，满足表示的数是 $2$ 的非负整数次幂的 $s$ 的非空子串有 $2,4,8$，将 $s$ 修改为 $5963$ 是最优解之一。\n\n对于样例 $2$，满足表示的数是 $2$ 的非负整数次幂的 $s$ 的非空子串有 $1,4,16,64$，将 $s$ 修改为 $666$ 是最优解之一。\n\n\n### 数据规模与约定\n**本题采用捆绑测试。**\n\n令 $n=|s|$。\n\n| $\\text{Subtask}$ | $n\\le $ | 分值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $4$ | $10$ |\n| $2$ | $8$ | $10$ |\n| $3$ | $17$ | $20$ |\n| $4$ | $10^3$ | $20$ |\n| $5$ | $10^6$ | $40$ |\n\n对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$s$ 由 $1\\sim 9$ 的数字组成。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JRKSJ R8] 三七二十一", "background": "", "description": "给你一个由 $1\\sim 9$ 的数字组成的数字串 $s$。定义一个数字串 $s$ 表示的数为将其看作十进制数得到的数。形式化地说，长为 $n$ 的数字串 $s$ 表示的数是 $\\sum_{i=1}^n  10^{n-i}s_i$。\n\n你可以对这个数字串执行若干次操作，每次操作中你可以选定一个位置 $1\\le p\\le n$ 并将 $s_p$ 修改为任意 $1\\sim 9$ 中的数字。你需要使该数字串**不存在**任何一个非空子串满足这个子串表示的数字是 $2^k(k\\in \\N)$ 即 $2$ 的任意**非负整数**次幂，请你求出最少的操作次数。", "inputFormat": "一行一个数字串 $s$。", "outputFormat": "一行一个整数表示答案。", "hint": "### 样例解释\n\n对于样例 $1$，满足表示的数是 $2$ 的非负整数次幂的 $s$ 的非空子串有 $2,4,8$，将 $s$ 修改为 $5963$ 是最优解之一。\n\n对于样例 $2$，满足表示的数是 $2$ 的非负整数次幂的 $s$ 的非空子串有 $1,4,16,64$，将 $s$ 修改为 $666$ 是最优解之一。\n\n\n### 数据规模与约定\n**本题采用捆绑测试。**\n\n令 $n=|s|$。\n\n| $\\text{Subtask}$ | $n\\le $ | 分值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $4$ | $10$ |\n| $2$ | $8$ | $10$ |\n| $3$ | $17$ | $20$ |\n| $4$ | $10^3$ | $20$ |\n| $5$ | $10^6$ | $40$ |\n\n对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$s$ 由 $1\\sim 9$ 的数字组成。", "locale": "zh-CN"}}}
{"pid": "P10572", "type": "P", "difficulty": 5, "samples": [["5 6 5\n((())\n1 2\n1 3\n2 3\n3 4\n4 5\n2 4\n\n1 2\n3 4\n1 4\n1 5\n2 5\n", "01111"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "洛谷原创", "O2优化", "二分图", "洛谷月赛"], "title": "[JRKSJ R8] +1-1", "background": "", "description": "给你 $n$ 个点 $m$ 条边的无向图，每个结点上有一个字符 `(` 或者 `)`。\n\n有 $q$ 次查询，每次查询给出 $x,y$，你需要判断是否存在一条从 $x$ 到 $y$ 的路径（不需要保证是简单路径）满足将路径上的点上的字符顺次写下来得到的字符串是合法括号串。", "inputFormat": "第一行三个整数 $n,m,q$。\n\n第二行一个只包含 `(` 和 `)` 的长度为 $n$ 的字符串表示结点 $1\\dots n$ 上的字符。\n\n下面 $m$ 行，每行两个整数 $u,v$ 表示图上的一条边。\n\n下面 $q$ 行，每行两个整数 $x,y$。", "outputFormat": "一个长度为 $q$ 的 01 串，第 $i$ 个字符表示第 $i$ 次询问的答案，1 表示存在这样的路径，0 表示不存在这样的路径。", "hint": "合法括号串的定义：\n\n* 空字符串是合法括号串\n* 若 $A,B$ 是合法括号串，则 $AB$ 是合法括号串\n* 若 $A$ 是合法括号串，则 $(A)$ 是合法括号串\n* 除此之外的其他字符串均不是合法括号串\n\n如 `()`、`(()())` 是合法括号串，`(()`、`())(` 不是合法括号串。\n\n### 样例解释\n\n**为了方便观察，输入的边和询问之间有一个换行。但数据中并不存在这个换行。**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x2lp3c7m.png)\n\n其中 $1,2,3$ 号点的字符是 `(`，$4,5$ 号点的字符是 `)`。\n\n$1\\to 2$：显然，合法括号串不可能以 `(` 结尾。\\\n$3\\to 4$：路径 $3\\to 4$ 表示的字符串是 `()`。\\\n$1\\to 4$：路径 $1\\to 3\\to 2\\to 4\\to 5\\to 4$ 表示的字符串是 `((()))`。\\\n$1\\to 5$：路径 $1\\to 2\\to 4\\to 5$ 表示的字符串是 `(())`。\\\n$2\\to 5$：路径 $2\\to 3\\to 4\\to 5$ 表示的字符串是 `(())`。\n\n### 数据规模与约定\n\n本题采用捆绑测试。\n\n- Subtask 1（20 pts）：$n,q\\leq 500$，$m \\leq 800$；\n- Subtask 2（30 pts）：图是森林；\n- Subtask 3（20 pts）：$q\\le 10$；\n- Subtask 4（30 pts）：无特殊限制。\n\n对于所有数据，满足 $1\\le n,q\\le 5\\times 10^5$，$0\\le m\\le \\min(\\frac{n\\times(n-1)}{2},5\\times 10^5)$，$1\\le u,v,x,y\\le n$，保证给出的图无重边、无自环。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JRKSJ R8] +1-1", "background": "", "description": "给你 $n$ 个点 $m$ 条边的无向图，每个结点上有一个字符 `(` 或者 `)`。\n\n有 $q$ 次查询，每次查询给出 $x,y$，你需要判断是否存在一条从 $x$ 到 $y$ 的路径（不需要保证是简单路径）满足将路径上的点上的字符顺次写下来得到的字符串是合法括号串。", "inputFormat": "第一行三个整数 $n,m,q$。\n\n第二行一个只包含 `(` 和 `)` 的长度为 $n$ 的字符串表示结点 $1\\dots n$ 上的字符。\n\n下面 $m$ 行，每行两个整数 $u,v$ 表示图上的一条边。\n\n下面 $q$ 行，每行两个整数 $x,y$。", "outputFormat": "一个长度为 $q$ 的 01 串，第 $i$ 个字符表示第 $i$ 次询问的答案，1 表示存在这样的路径，0 表示不存在这样的路径。", "hint": "合法括号串的定义：\n\n* 空字符串是合法括号串\n* 若 $A,B$ 是合法括号串，则 $AB$ 是合法括号串\n* 若 $A$ 是合法括号串，则 $(A)$ 是合法括号串\n* 除此之外的其他字符串均不是合法括号串\n\n如 `()`、`(()())` 是合法括号串，`(()`、`())(` 不是合法括号串。\n\n### 样例解释\n\n**为了方便观察，输入的边和询问之间有一个换行。但数据中并不存在这个换行。**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x2lp3c7m.png)\n\n其中 $1,2,3$ 号点的字符是 `(`，$4,5$ 号点的字符是 `)`。\n\n$1\\to 2$：显然，合法括号串不可能以 `(` 结尾。\\\n$3\\to 4$：路径 $3\\to 4$ 表示的字符串是 `()`。\\\n$1\\to 4$：路径 $1\\to 3\\to 2\\to 4\\to 5\\to 4$ 表示的字符串是 `((()))`。\\\n$1\\to 5$：路径 $1\\to 2\\to 4\\to 5$ 表示的字符串是 `(())`。\\\n$2\\to 5$：路径 $2\\to 3\\to 4\\to 5$ 表示的字符串是 `(())`。\n\n### 数据规模与约定\n\n本题采用捆绑测试。\n\n- Subtask 1（20 pts）：$n,q\\leq 500$，$m \\leq 800$；\n- Subtask 2（30 pts）：图是森林；\n- Subtask 3（20 pts）：$q\\le 10$；\n- Subtask 4（30 pts）：无特殊限制。\n\n对于所有数据，满足 $1\\le n,q\\le 5\\times 10^5$，$0\\le m\\le \\min(\\frac{n\\times(n-1)}{2},5\\times 10^5)$，$1\\le u,v,x,y\\le n$，保证给出的图无重边、无自环。", "locale": "zh-CN"}}}
{"pid": "P10573", "type": "P", "difficulty": 6, "samples": [["5 6 1\n1 2\n1 3\n1 5\n2 3\n2 4\n4 5", "3 3 5 5 5\n"], ["8 10 1\n1 3\n1 4\n1 5\n2 3\n2 7\n3 6\n4 6\n5 8\n6 7\n7 8\n", "8 8 7 7 5 4 3 3\n"], ["14 19 2\n1 3\n1 4\n1 9\n2 5\n2 14\n3 7\n4 5\n4 6\n4 7\n4 8\n5 6\n5 11\n6 8\n7 9\n8 10\n8 12\n9 10\n10 11\n11 12\n", "2 1 2 4 1 4 2 4 2 5 1 5 1 1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "2024", "洛谷原创", "O2优化", "连通块", "洛谷月赛"], "title": "[JRKSJ R8] C0mp0nents", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/m71eooc6.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b626ra6r.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/it3ulcpz.png)", "description": "小 I 有一张 $n$ 个点、$m$ 条边的无向图，保证图无重边、无自环。初始时第 $i$ 个点的点权 $a_i = i$。小 I 有一个额外的常量 $k$。\n\n小 R 可以进行很多很多次操作。每次操作，她选择图上两个相邻的节点 $x, y$ 满足 $\\lvert a_x - a_y \\rvert = k$，随后小 I 会将 $a_x$ 设为 $a_y$。\n\n对每个 $1 \\leq s \\leq n$，**如果在过程中不修改 $\\bm{a_x = s}$ 的节点 $\\bm x$ 的权值**，小 I 想知道：若干次操作后，图上最多有多少个点满足 $a_i = s$。", "inputFormat": "第一行三个整数 $n, m, k$。\n\n接下来 $m$ 行，每行两个整数 $u, v$，依次表示一条连接 $u, v$ 的边。", "outputFormat": "一行 $n$ 个整数，第 $i$ 个整数表示 $s = i$ 时的答案。", "hint": "### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 0（0 pts）：样例；\n- Subtask 1（5 pts）：$n \\leq 200$，$m \\leq 400$；\n- Subtask 2（20 pts）：$n \\leq 5000$，$m \\leq 10^4$；\n- Subtask 3（25 pts）：$n \\leq 10^5$，$m \\leq 3\\times 10^5$；\n- Subtask 4（50 pts）：无特殊限制。\n\n对于所有数据，满足 $1 \\leq k \\leq n \\leq 4\\times 10^5$，$1 \\leq u, v \\leq n$，$0 \\leq m \\leq 10^6$，保证图无重边、无自环。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JRKSJ R8] C0mp0nents", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/m71eooc6.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b626ra6r.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/it3ulcpz.png)", "description": "小 I 有一张 $n$ 个点、$m$ 条边的无向图，保证图无重边、无自环。初始时第 $i$ 个点的点权 $a_i = i$。小 I 有一个额外的常量 $k$。\n\n小 R 可以进行很多很多次操作。每次操作，她选择图上两个相邻的节点 $x, y$ 满足 $\\lvert a_x - a_y \\rvert = k$，随后小 I 会将 $a_x$ 设为 $a_y$。\n\n对每个 $1 \\leq s \\leq n$，**如果在过程中不修改 $\\bm{a_x = s}$ 的节点 $\\bm x$ 的权值**，小 I 想知道：若干次操作后，图上最多有多少个点满足 $a_i = s$。", "inputFormat": "第一行三个整数 $n, m, k$。\n\n接下来 $m$ 行，每行两个整数 $u, v$，依次表示一条连接 $u, v$ 的边。", "outputFormat": "一行 $n$ 个整数，第 $i$ 个整数表示 $s = i$ 时的答案。", "hint": "### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 0（0 pts）：样例；\n- Subtask 1（5 pts）：$n \\leq 200$，$m \\leq 400$；\n- Subtask 2（20 pts）：$n \\leq 5000$，$m \\leq 10^4$；\n- Subtask 3（25 pts）：$n \\leq 10^5$，$m \\leq 3\\times 10^5$；\n- Subtask 4（50 pts）：无特殊限制。\n\n对于所有数据，满足 $1 \\leq k \\leq n \\leq 4\\times 10^5$，$1 \\leq u, v \\leq n$，$0 \\leq m \\leq 10^6$，保证图无重边、无自环。", "locale": "zh-CN"}}}
{"pid": "P10574", "type": "P", "difficulty": 7, "samples": [["5 7\n1 1 1 4\n2 1 5\n4 2 1\n3 4 1\n2 5 5\n2 4 5\n4 4 4\n3 2 2", "0\n6\n14\n0\n0\n6\n10"], ["6 10\n1 1 1 1 2\n6 4 1\n3 1 1\n1 1 1\n3 4 1\n5 2 1\n3 3 1\n3 4 1\n2 2 1\n2 5 1\n3 1 1", "12\n13\n13\n18\n22\n28\n36\n38\n46\n48"], ["8 10\n1 1 2 1 3 3 3\n7 3 1\n2 4 1\n5 2 1\n5 2 1\n3 1 1\n6 2 1\n1 4 1\n8 4 1\n6 4 1\n3 2 1", "9\n14\n18\n22\n23\n27\n27\n35\n47\n47"]], "limits": {"time": [1000, 1000, 1000, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "洛谷原创", "O2优化", "洛谷月赛"], "title": "[JRKSJ R8] 暴风雪", "background": "![]( https://cdn.luogu.com.cn/upload/image_hosting/ok3qwkac.png)", "description": "层叠都市可以被抽象为一棵树。于是给你一棵带点权 $v_i$ 的树，树以 $1$ 为根。初始点权 $v_i$ 均为 $0$。\n\n定义 $\\text{dis}(x,y)$ 为树上 $x,y$ 之间的距离，即 $x\\to y$ 的简单路径上的边数。\n\n设 $\\text{subtree}(x)$ 为树上以 $x$ 为根的子树，定义 $f(x)=\\max_{d\\ge 0} \\sum_{y\\in\\text{subtree}(x)} v_y[\\text{dis}(x,y)=d]$。也就是说，$f(x)$ 表示 $x$ 子树中的每一层的点权和的最大值。\n\n现在给出 $m$ 次操作，每次操作中给出 $x,w,y$，先令 $v_x\\gets v_x+w$，然后求 $\\sum_{i\\in \\text{subtree}(y)} f(i)$。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n-1$ 个整数 $f_{2\\dots n}$，依次表示结点 $2,3,\\dots ,n$ 的父亲。\n\n接下来 $m$ 行，每行三个整数 $x,w,y$。", "outputFormat": "输出共 $m$ 行，每行一个整数表示答案。", "hint": "### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n| $\\text{Subtask}$ | $n,m\\le$ |  特殊性质 |  $\\text{Score}$ | 时间限制|\n| :----------: | :----------: | :----------: | :----------: |  :----------: |  \n| $1$ | $100$ |  | $5$ | 1s |\n| $2$ | $5000$ |  | $15$ | 1s |\n| $3$ | $3\\times10^5$ | $f_i=i-1$ | $10$ | 4.5s |\n| $4$ | $7\\times 10^4$ |  | $20$ | 4.5s |\n| $5$ | $3\\times10^5$ |  | $50$ | 4.5s |\n\n对于所有数据，$1\\le n,m\\le3\\times 10^5$，$1\\le x,y\\le n$，$1\\le w \\le 10^8$，$1\\le f_i\\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JRKSJ R8] 暴风雪", "background": "![]( https://cdn.luogu.com.cn/upload/image_hosting/ok3qwkac.png)", "description": "层叠都市可以被抽象为一棵树。于是给你一棵带点权 $v_i$ 的树，树以 $1$ 为根。初始点权 $v_i$ 均为 $0$。\n\n定义 $\\text{dis}(x,y)$ 为树上 $x,y$ 之间的距离，即 $x\\to y$ 的简单路径上的边数。\n\n设 $\\text{subtree}(x)$ 为树上以 $x$ 为根的子树，定义 $f(x)=\\max_{d\\ge 0} \\sum_{y\\in\\text{subtree}(x)} v_y[\\text{dis}(x,y)=d]$。也就是说，$f(x)$ 表示 $x$ 子树中的每一层的点权和的最大值。\n\n现在给出 $m$ 次操作，每次操作中给出 $x,w,y$，先令 $v_x\\gets v_x+w$，然后求 $\\sum_{i\\in \\text{subtree}(y)} f(i)$。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n-1$ 个整数 $f_{2\\dots n}$，依次表示结点 $2,3,\\dots ,n$ 的父亲。\n\n接下来 $m$ 行，每行三个整数 $x,w,y$。", "outputFormat": "输出共 $m$ 行，每行一个整数表示答案。", "hint": "### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n| $\\text{Subtask}$ | $n,m\\le$ |  特殊性质 |  $\\text{Score}$ | 时间限制|\n| :----------: | :----------: | :----------: | :----------: |  :----------: |  \n| $1$ | $100$ |  | $5$ | 1s |\n| $2$ | $5000$ |  | $15$ | 1s |\n| $3$ | $3\\times10^5$ | $f_i=i-1$ | $10$ | 4.5s |\n| $4$ | $7\\times 10^4$ |  | $20$ | 4.5s |\n| $5$ | $3\\times10^5$ |  | $50$ | 4.5s |\n\n对于所有数据，$1\\le n,m\\le3\\times 10^5$，$1\\le x,y\\le n$，$1\\le w \\le 10^8$，$1\\le f_i\\le n$。", "locale": "zh-CN"}}}
{"pid": "P10575", "type": "P", "difficulty": 1, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["2024", "蓝桥杯国赛"], "title": "[蓝桥杯 2024 国 A] 下一次相遇", "background": "", "description": "2024 年 6 月 1 日，这一天显得格外特别，因为欢乐的儿童节与星期六巧合地相遇了，这无疑为孩子们增添了诸多喜悦，让孩子们可以尽情地沉浸在这愉快的周末与浓厚的节日氛围当中。\n\n不过，这也不禁引人思索，下一次的 6 月 1 日儿童节再度与星期六相遇，将会是在哪一年呢？请你以四位整数的格式给出答案。", "inputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "outputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国 A] 下一次相遇", "background": "", "description": "2024 年 6 月 1 日，这一天显得格外特别，因为欢乐的儿童节与星期六巧合地相遇了，这无疑为孩子们增添了诸多喜悦，让孩子们可以尽情地沉浸在这愉快的周末与浓厚的节日氛围当中。\n\n不过，这也不禁引人思索，下一次的 6 月 1 日儿童节再度与星期六相遇，将会是在哪一年呢？请你以四位整数的格式给出答案。", "inputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "outputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10576", "type": "P", "difficulty": 2, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["2024", "数论", "蓝桥杯国赛"], "title": "[蓝桥杯 2024 国 A] 儿童节快乐", "background": "", "description": "五彩斑斓的气球在蓝天下悠然飘荡，轻快的音乐在耳边持续回荡，小朋友们手牵着手一同畅快欢笑。在这样一片安乐祥和的氛围下，六一来了。\n\n今天是六一儿童节，小蓝老师为了让大家在节日里享受解题的乐趣，特地准备了一道有趣的题目。\n\n题目内容为：求出所有满足以下条件的整数 $n$ 的总和：\n\n1. $(n+10120300500)$ 是一个完全平方数。\n2. $(n-10120300500)$ 也是一个完全平方数。\n\n一个数如果可以表示为另一个整数的平方，那么这个数就叫做完全平方数。例如，$4$ 可以表示为 $2$ 的平方，$9$ 可以表示为 $3$ 的平方，因此 $4$ 和 $9$ 都是完全平方数。\n\n请大家用心仔细地思考，求出答案。同时祝大家儿童节快乐，解题过程开心顺遂！", "inputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "outputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国 A] 儿童节快乐", "background": "", "description": "五彩斑斓的气球在蓝天下悠然飘荡，轻快的音乐在耳边持续回荡，小朋友们手牵着手一同畅快欢笑。在这样一片安乐祥和的氛围下，六一来了。\n\n今天是六一儿童节，小蓝老师为了让大家在节日里享受解题的乐趣，特地准备了一道有趣的题目。\n\n题目内容为：求出所有满足以下条件的整数 $n$ 的总和：\n\n1. $(n+10120300500)$ 是一个完全平方数。\n2. $(n-10120300500)$ 也是一个完全平方数。\n\n一个数如果可以表示为另一个整数的平方，那么这个数就叫做完全平方数。例如，$4$ 可以表示为 $2$ 的平方，$9$ 可以表示为 $3$ 的平方，因此 $4$ 和 $9$ 都是完全平方数。\n\n请大家用心仔细地思考，求出答案。同时祝大家儿童节快乐，解题过程开心顺遂！", "inputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "outputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10577", "type": "P", "difficulty": 3, "samples": [["5\n2 5 7 9 1", "1 6 6 6 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["并查集", "2024", "排序", "蓝桥杯国赛"], "title": "[蓝桥杯 2024 国 A] 兔子集结", "background": "", "description": "在森林幽静的一隅，有一村落居住着 $n$ 只兔子。\n\n某个月光皎洁的夜晚，这些兔子列成一队，准备开始一场集结跳跃活动。村落中的每只兔子都占据一个位置，对于第 $i$ 只兔子，其位置为 $p_i$。我们称位置较小的为左边，位置较大的为右边。\n\n按照兔子村落的习俗，每只兔子都会选择距离自己最近的兔子作为同伴，并向同伴所在的方向进行跳跃。如果一只兔子左边和右边的兔子距离它一样近，那么它会选择左边的兔子作为同伴。\n\n兔子的每次跳跃，只能向左或向右移动一个单位距离。也就是说，如果一只兔子当前位于 $x$ 的位置，那么它下一次跳跃后会到达 $x-1$ 或者 $x+1$ 的位置。\n\n当两只相互靠近的兔子之间的距离为 $1$ 时，左边的兔子会停在原地，而右边的兔子会跳到左边兔子的位置上，完成集结。\n\n兔子们会一直跳跃，直到与自己最初选择的同伴完成集结后停下。\n\n请问，当所有兔子都完成集结后，每只兔子都分别位于哪个位置上？", "inputFormat": "输入的第一行包含一个整数 $n$，表示兔子的数量。\n第二行包含 $n$ 个整数 $p_1,p_2,\\cdots, p_n$，相邻整数之间使用一个空格分隔，表示每只兔子的初始位置。", "outputFormat": "输出一行包含 $n$ 个整数，表示每只兔子完成集结后的位置。", "hint": "**【样例说明】**\n\n兔子 $1$ 选择的同伴为兔子 $5$，兔子 $5$ 选择的同伴为兔子 $1$。由于它们彼此间的距离为 $1$，因此兔子 $5$ 会停在原地，而兔子 $1$ 会跳到位置 $1$ 上，与兔子 $5$完成集结。\n\n兔子 $2$ 选择的同伴为兔子 $3$，兔子 $4$ 选择的同伴也为兔子3。对于兔子 $3$ 来说，兔子 $2$ 和兔子 $4$ 与它的距离相同，所以它会选择左边的兔子 $2$ 作为同伴。兔子 $2$ 会向右跳一个位置，兔子 $3$ 会向左跳一个位置，兔子 $4$ 会向左跳一个位置。此时，兔子 $2$ 和兔子 $3$ 均位于位置 $6$，完成集结（停止跳跃）。兔子 $4$ 会继续向左跳跃，直到跳到位置 $6$ 后与兔子 $3$ 完成集结。\n\n**【评测用例规模与约定】**\n\n对于 $40\\%$ 的评测用例，$2\\le n\\le 500$，$1\\le p_i\\le 10^5$，$p_1,p_2,\\cdots,p_n$ 各不相同。  \n对于所有评测用例，$2\\le n \\le 10^5$，$1 \\le p_i \\le 10^9$，$p_1,p_2,\\cdots,p_n$ 各不相同。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国 A] 兔子集结", "background": "", "description": "在森林幽静的一隅，有一村落居住着 $n$ 只兔子。\n\n某个月光皎洁的夜晚，这些兔子列成一队，准备开始一场集结跳跃活动。村落中的每只兔子都占据一个位置，对于第 $i$ 只兔子，其位置为 $p_i$。我们称位置较小的为左边，位置较大的为右边。\n\n按照兔子村落的习俗，每只兔子都会选择距离自己最近的兔子作为同伴，并向同伴所在的方向进行跳跃。如果一只兔子左边和右边的兔子距离它一样近，那么它会选择左边的兔子作为同伴。\n\n兔子的每次跳跃，只能向左或向右移动一个单位距离。也就是说，如果一只兔子当前位于 $x$ 的位置，那么它下一次跳跃后会到达 $x-1$ 或者 $x+1$ 的位置。\n\n当两只相互靠近的兔子之间的距离为 $1$ 时，左边的兔子会停在原地，而右边的兔子会跳到左边兔子的位置上，完成集结。\n\n兔子们会一直跳跃，直到与自己最初选择的同伴完成集结后停下。\n\n请问，当所有兔子都完成集结后，每只兔子都分别位于哪个位置上？", "inputFormat": "输入的第一行包含一个整数 $n$，表示兔子的数量。\n第二行包含 $n$ 个整数 $p_1,p_2,\\cdots, p_n$，相邻整数之间使用一个空格分隔，表示每只兔子的初始位置。", "outputFormat": "输出一行包含 $n$ 个整数，表示每只兔子完成集结后的位置。", "hint": "**【样例说明】**\n\n兔子 $1$ 选择的同伴为兔子 $5$，兔子 $5$ 选择的同伴为兔子 $1$。由于它们彼此间的距离为 $1$，因此兔子 $5$ 会停在原地，而兔子 $1$ 会跳到位置 $1$ 上，与兔子 $5$完成集结。\n\n兔子 $2$ 选择的同伴为兔子 $3$，兔子 $4$ 选择的同伴也为兔子3。对于兔子 $3$ 来说，兔子 $2$ 和兔子 $4$ 与它的距离相同，所以它会选择左边的兔子 $2$ 作为同伴。兔子 $2$ 会向右跳一个位置，兔子 $3$ 会向左跳一个位置，兔子 $4$ 会向左跳一个位置。此时，兔子 $2$ 和兔子 $3$ 均位于位置 $6$，完成集结（停止跳跃）。兔子 $4$ 会继续向左跳跃，直到跳到位置 $6$ 后与兔子 $3$ 完成集结。\n\n**【评测用例规模与约定】**\n\n对于 $40\\%$ 的评测用例，$2\\le n\\le 500$，$1\\le p_i\\le 10^5$，$p_1,p_2,\\cdots,p_n$ 各不相同。  \n对于所有评测用例，$2\\le n \\le 10^5$，$1 \\le p_i \\le 10^9$，$p_1,p_2,\\cdots,p_n$ 各不相同。", "locale": "zh-CN"}}}
{"pid": "P10578", "type": "P", "difficulty": 3, "samples": [["2\n1 2 3\n4 5 6\n7 8 9\n1 5 2\n4 6 3\n7 8 9", "0\n3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["搜索", "2024", "广度优先搜索 BFS", "蓝桥杯国赛"], "title": "[蓝桥杯 2024 国 A] 旋转九宫格", "background": "", "description": "给定一个 $3\\times 3$ 的九宫格，每个格子内分别含有一个数字，每个格子里的数字互不相同。每步我们可以选择任意一个 $2\\times 2$ 的区域将其顺时针旋转，例如：\n\n例如\n\n```plain\n1 2 3\n4 5 6\n7 8 9\n```\n\n将其旋转右上角，可得：\n\n```plain\n1 5 2\n4 6 3\n7 8 9\n```\n\n问最少需要几步才能将给定的状态旋转为\n\n```plain\n1 2 3\n4 5 6\n7 8 9\n```", "inputFormat": "输入的第一行包含一个整数 $T$ 表示询问的组数。\n\n接下来依次输入每组询问。\n\n每组询问包含三行，每行包含三个数，表示询问的九宫格的状态。", "outputFormat": "输出 $T$ 行，每行包含一个整数表示本次询问的答案。", "hint": "对于 $60\\%$ 的评测用例，$T=1$;  \n对于所有评测用例，$T\\le 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国 A] 旋转九宫格", "background": "", "description": "给定一个 $3\\times 3$ 的九宫格，每个格子内分别含有一个数字，每个格子里的数字互不相同。每步我们可以选择任意一个 $2\\times 2$ 的区域将其顺时针旋转，例如：\n\n例如\n\n```plain\n1 2 3\n4 5 6\n7 8 9\n```\n\n将其旋转右上角，可得：\n\n```plain\n1 5 2\n4 6 3\n7 8 9\n```\n\n问最少需要几步才能将给定的状态旋转为\n\n```plain\n1 2 3\n4 5 6\n7 8 9\n```", "inputFormat": "输入的第一行包含一个整数 $T$ 表示询问的组数。\n\n接下来依次输入每组询问。\n\n每组询问包含三行，每行包含三个数，表示询问的九宫格的状态。", "outputFormat": "输出 $T$ 行，每行包含一个整数表示本次询问的答案。", "hint": "对于 $60\\%$ 的评测用例，$T=1$;  \n对于所有评测用例，$T\\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P10579", "type": "P", "difficulty": 3, "samples": [["4 1 5 6\n1 2 3 4", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["二分", "2024", "前缀和", "蓝桥杯国赛"], "title": "[蓝桥杯 2024 国 A] 最长子段", "background": "", "description": "给定一个长度为 $n$ 的序列 $(s_1,s_2,\\cdots,s_n)$ 和三个数 $a,b,c$，你需要找出一对 $L,R$ 满足如下式子：\n\n$$\n\\sum\\limits_{i=L}^Rs_i>a(bR-cL),1 \\le L \\le R \\le n\n$$\n\n即，序列中的第 $L$ 至 $R$ 项之和大于 $a\\cdot (b\\cdot R - c \\cdot L)$，求出满足条件的 $L,R$ 中 $R - L + 1$ 的最大值。\n\n测试数据保证存在这样的一对 $L$ 和 $R$。", "inputFormat": "输入的第一行包含四个整数 $n,a,b,c$，相邻整数之间使用一个空格分隔。\n\n第二行包含 $n$ 个整数 $s_1,s_2,\\cdots,s_n$，相邻整数之间使用一个空格分隔。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "对于 $60\\%$ 的评测用例，$n\\le 5000$；  \n对于所有评测用例，$1\\le n\\le 3 \\times 10^5$，$1\\le a,b,c\\le 1000$，$|s_i| \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国 A] 最长子段", "background": "", "description": "给定一个长度为 $n$ 的序列 $(s_1,s_2,\\cdots,s_n)$ 和三个数 $a,b,c$，你需要找出一对 $L,R$ 满足如下式子：\n\n$$\n\\sum\\limits_{i=L}^Rs_i>a(bR-cL),1 \\le L \\le R \\le n\n$$\n\n即，序列中的第 $L$ 至 $R$ 项之和大于 $a\\cdot (b\\cdot R - c \\cdot L)$，求出满足条件的 $L,R$ 中 $R - L + 1$ 的最大值。\n\n测试数据保证存在这样的一对 $L$ 和 $R$。", "inputFormat": "输入的第一行包含四个整数 $n,a,b,c$，相邻整数之间使用一个空格分隔。\n\n第二行包含 $n$ 个整数 $s_1,s_2,\\cdots,s_n$，相邻整数之间使用一个空格分隔。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "对于 $60\\%$ 的评测用例，$n\\le 5000$；  \n对于所有评测用例，$1\\le n\\le 3 \\times 10^5$，$1\\le a,b,c\\le 1000$，$|s_i| \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10580", "type": "P", "difficulty": 4, "samples": [["3\n3 6 2\n12 144 3\n233 251640 10", "2\n72\n905954656"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2024", "容斥原理", "蓝桥杯国赛"], "title": "[蓝桥杯 2024 国 A] gcd 与 lcm", "background": "", "description": "给定两个数 $x,y$，求有多少种不同的长度为 $n$ 的序列 $(a_1,a_2,\\cdots,a_n)$，其所有元素的最大公约数为 $x$ 且最小公倍数为 $y$。\n\n两个序列 $(a_1,a_2,\\cdots,a_n)$ 与 $(b_1,b_2,\\cdots,b_n)$ 不同，是指存在至少一个位置 $i$ 满足 $a_i\\neq b_i$。\n\n由于答案可能很大，请输出答案对 $998\\ 244\\ 353$ 取模后的结果。", "inputFormat": "输入的第一行包含一个整数 $Q$ 表示询问次数。\n\n接下来 $Q$ 行，每行包含三个整数 $x,y,n$ 表示一组询问，相邻整数之间使用一个空格分隔。对于每个询问，保证至少存在一个满足条件的序列。\n", "outputFormat": "输出 $Q$ 行，每行包含一个整数，依次表示每个询问的答案。", "hint": "对于 $40\\%$ 的评测用例，$n\\le 30$；  \n对于 $70\\%$ 的评测用例，$n\\le 5000$；  \n对于所有评测用例，$1\\le Q\\le 100$，$2\\le n\\le 10^5$，$1\\le x,y\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国 A] gcd 与 lcm", "background": "", "description": "给定两个数 $x,y$，求有多少种不同的长度为 $n$ 的序列 $(a_1,a_2,\\cdots,a_n)$，其所有元素的最大公约数为 $x$ 且最小公倍数为 $y$。\n\n两个序列 $(a_1,a_2,\\cdots,a_n)$ 与 $(b_1,b_2,\\cdots,b_n)$ 不同，是指存在至少一个位置 $i$ 满足 $a_i\\neq b_i$。\n\n由于答案可能很大，请输出答案对 $998\\ 244\\ 353$ 取模后的结果。", "inputFormat": "输入的第一行包含一个整数 $Q$ 表示询问次数。\n\n接下来 $Q$ 行，每行包含三个整数 $x,y,n$ 表示一组询问，相邻整数之间使用一个空格分隔。对于每个询问，保证至少存在一个满足条件的序列。\n", "outputFormat": "输出 $Q$ 行，每行包含一个整数，依次表示每个询问的答案。", "hint": "对于 $40\\%$ 的评测用例，$n\\le 30$；  \n对于 $70\\%$ 的评测用例，$n\\le 5000$；  \n对于所有评测用例，$1\\le Q\\le 100$，$2\\le n\\le 10^5$，$1\\le x,y\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10581", "type": "P", "difficulty": 5, "samples": [["aba 6", "53"], ["aba 10", "77907666"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "矩阵加速", "KMP 算法", "蓝桥杯国赛"], "title": "[蓝桥杯 2024 国 A] 重复的串", "background": "", "description": "给定一个仅含小写字母的字符串 $S$，问有多少个长度为 $n$ 的仅含小写字母的字符串中恰好出现了两次 $S$。答案对 $998\\ 244\\ 353$ 取模。", "inputFormat": "输入一行包含一个字符串 $S$ 和一个整数 $n$，用一个空格分隔。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "对于 $40\\%$ 的评测用例，$n \\le 20$，$|S| \\le 6$；  \n另有 $10\\%$ 的评测用例，$n\\le 500$，$|S| \\le 2$；  \n对于 $70\\%$ 的评测用例，$n\\le 10^5$；  \n对于所有评测用例，$1\\le n\\le 10^9$，$1 \\le |S| \\le 30$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国 A] 重复的串", "background": "", "description": "给定一个仅含小写字母的字符串 $S$，问有多少个长度为 $n$ 的仅含小写字母的字符串中恰好出现了两次 $S$。答案对 $998\\ 244\\ 353$ 取模。", "inputFormat": "输入一行包含一个字符串 $S$ 和一个整数 $n$，用一个空格分隔。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "对于 $40\\%$ 的评测用例，$n \\le 20$，$|S| \\le 6$；  \n另有 $10\\%$ 的评测用例，$n\\le 500$，$|S| \\le 2$；  \n对于 $70\\%$ 的评测用例，$n\\le 10^5$；  \n对于所有评测用例，$1\\le n\\le 10^9$，$1 \\le |S| \\le 30$。", "locale": "zh-CN"}}}
{"pid": "P10582", "type": "P", "difficulty": 4, "samples": [["2\n2\n5", "3\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["博弈论", "二分", "2024", "蓝桥杯国赛"], "title": "[蓝桥杯 2024 国 A] 最强策略家", "background": "", "description": "在一场智力对弈的游戏中，两位玩家小蓝和小乔需要对一个初始值均为 $0$、大小为 $n \\times n$ 的矩阵进行操作，以展现他们的智慧和谋略，并确定谁才是最强的策略家。\n\n操作规则如下：\n\n- 小蓝拥有先手操作权，完成操作后轮到小乔，然后再轮到小蓝，依此规律交替进行。\n- 在小蓝的每个回合中，他可以选择矩阵中的 $2$ 个元素，并将这些元素的值变更为 $1$。\n- 在小乔的第 $1$ 个回合中，他可以选择一个大小为 $1\\times 1$ 的子矩阵，并将该子矩阵内的所有元素的值重置为 $0$。在小乔的第 $2$ 个回合中，他可以选择一个 $2\\times 2$ 的子矩阵，并将该子矩阵内的所有元素的值重置为 $0$。以此类推，在小乔的第 $i$ 个回合中，他可以选择一个大小为 $i\\times i$ 的子矩阵，并将该子矩阵内所有元素的值重置为 $0$。\n- 在双方各进行了 $n$ 次操作后，游戏结束。\n\n设在整个游戏过程中，矩阵中值为 $1$ 的元素的数量最多时为 $X$。\n\n小蓝致力于最大化 $X$ 的值，小乔致力于最小化 $X$ 的值。\n\n假设两位玩家都具有完美的逻辑推理能力，并总是采取最佳策略。请问，$X$ 的值会是多少（即在整个游戏过程中，矩阵中值为 $1$ 的元素的数量最多时是多少）？", "inputFormat": "输入的第一行包含一个整数 $T$，表示数据的组数。\n\n接下来 $T$ 行，每行包含一个整数 $n$，表示矩阵的大小。", "outputFormat": "对于每组数据，输出一行包含一个整数，表示答案。", "hint": "**【样例说明】**\n\n在第一个样例中，小蓝和小乔需要轮流操作一个 $2\\times 2$ 的矩阵。\n\n**初始矩阵状态：**\n\n$$\n\\begin{bmatrix}\n0 & 0 \\\\\n0 & 0\n\\end{bmatrix}\n$$\n\n**小蓝的第 $1$ 个回合：** 将两个值为 $0$ 的元素变更为 $1$。可能的状态为：\n\n$$\n\\begin{bmatrix}\n1 & 1 \\\\\n0 & 0\n\\end{bmatrix}\n$$\n\n**小乔的第 $1$ 个回合：** 小乔只能选择一个 $1\\times 1$ 的子矩阵将元素重置为 $0$。为了最小化值为 $1$ 的元素数量，小乔需要将已经是 $1$ 的一个元素重置为 $0$。可能的状态为：\n\n$$\n\\begin{bmatrix}\n0 & 1 \\\\\n0 & 0\n\\end{bmatrix}\n$$\n\n**小蓝的第 $2$ 个回合：** 小蓝再次将两个元素值为 $0$ 的元素变更 $1$。可能的状态为：\n\n$$\n\\begin{bmatrix}\n1 & 1 \\\\\n1 & 0\n\\end{bmatrix}\n$$\n\n**小乔的第 $2$ 个回合：** 小乔可以选择一个 $2\\times 2$ 的子矩阵（即整个矩阵），并且把所有值重置为 $0$。\n\n$$\n\\begin{bmatrix}\n0 & 0 \\\\\n0 & 0\n\\end{bmatrix}\n$$\n\n因此，在双方都采取最佳策略下，矩阵中值为 $1$ 的元素最多时能达到 $3$ 个。\n\n**【评测用例规模与约定】**\n\n对于 $30\\%$ 的评测用例，$1 \\le T \\le 10^3$，$1 \\le n \\le 10^3$。  \n对于所有评测用例，$1 \\le T \\le 10^5$，$1 \\le n \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国 A] 最强策略家", "background": "", "description": "在一场智力对弈的游戏中，两位玩家小蓝和小乔需要对一个初始值均为 $0$、大小为 $n \\times n$ 的矩阵进行操作，以展现他们的智慧和谋略，并确定谁才是最强的策略家。\n\n操作规则如下：\n\n- 小蓝拥有先手操作权，完成操作后轮到小乔，然后再轮到小蓝，依此规律交替进行。\n- 在小蓝的每个回合中，他可以选择矩阵中的 $2$ 个元素，并将这些元素的值变更为 $1$。\n- 在小乔的第 $1$ 个回合中，他可以选择一个大小为 $1\\times 1$ 的子矩阵，并将该子矩阵内的所有元素的值重置为 $0$。在小乔的第 $2$ 个回合中，他可以选择一个 $2\\times 2$ 的子矩阵，并将该子矩阵内的所有元素的值重置为 $0$。以此类推，在小乔的第 $i$ 个回合中，他可以选择一个大小为 $i\\times i$ 的子矩阵，并将该子矩阵内所有元素的值重置为 $0$。\n- 在双方各进行了 $n$ 次操作后，游戏结束。\n\n设在整个游戏过程中，矩阵中值为 $1$ 的元素的数量最多时为 $X$。\n\n小蓝致力于最大化 $X$ 的值，小乔致力于最小化 $X$ 的值。\n\n假设两位玩家都具有完美的逻辑推理能力，并总是采取最佳策略。请问，$X$ 的值会是多少（即在整个游戏过程中，矩阵中值为 $1$ 的元素的数量最多时是多少）？", "inputFormat": "输入的第一行包含一个整数 $T$，表示数据的组数。\n\n接下来 $T$ 行，每行包含一个整数 $n$，表示矩阵的大小。", "outputFormat": "对于每组数据，输出一行包含一个整数，表示答案。", "hint": "**【样例说明】**\n\n在第一个样例中，小蓝和小乔需要轮流操作一个 $2\\times 2$ 的矩阵。\n\n**初始矩阵状态：**\n\n$$\n\\begin{bmatrix}\n0 & 0 \\\\\n0 & 0\n\\end{bmatrix}\n$$\n\n**小蓝的第 $1$ 个回合：** 将两个值为 $0$ 的元素变更为 $1$。可能的状态为：\n\n$$\n\\begin{bmatrix}\n1 & 1 \\\\\n0 & 0\n\\end{bmatrix}\n$$\n\n**小乔的第 $1$ 个回合：** 小乔只能选择一个 $1\\times 1$ 的子矩阵将元素重置为 $0$。为了最小化值为 $1$ 的元素数量，小乔需要将已经是 $1$ 的一个元素重置为 $0$。可能的状态为：\n\n$$\n\\begin{bmatrix}\n0 & 1 \\\\\n0 & 0\n\\end{bmatrix}\n$$\n\n**小蓝的第 $2$ 个回合：** 小蓝再次将两个元素值为 $0$ 的元素变更 $1$。可能的状态为：\n\n$$\n\\begin{bmatrix}\n1 & 1 \\\\\n1 & 0\n\\end{bmatrix}\n$$\n\n**小乔的第 $2$ 个回合：** 小乔可以选择一个 $2\\times 2$ 的子矩阵（即整个矩阵），并且把所有值重置为 $0$。\n\n$$\n\\begin{bmatrix}\n0 & 0 \\\\\n0 & 0\n\\end{bmatrix}\n$$\n\n因此，在双方都采取最佳策略下，矩阵中值为 $1$ 的元素最多时能达到 $3$ 个。\n\n**【评测用例规模与约定】**\n\n对于 $30\\%$ 的评测用例，$1 \\le T \\le 10^3$，$1 \\le n \\le 10^3$。  \n对于所有评测用例，$1 \\le T \\le 10^5$，$1 \\le n \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10583", "type": "P", "difficulty": 6, "samples": [["5", "36"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "分块", "字典树 Trie", "快速沃尔什变换 FWT", "蓝桥杯国赛", "根号分治"], "title": "[蓝桥杯 2024 国 A] 异或路径", "background": "", "description": "给定一棵有 $n$ 个结点的树，结点 $1$ 至 $n$ 编号。编号为 $x > 1$ 的结点与编号为 $\\lfloor \\sqrt x \\rfloor$\n 的结点有一条权值为 $x-\\lfloor \\sqrt x \\rfloor ^ 2$ 的边。\n \n定义一条路径的价值为这条路径上的所有边的权值的异或和。如果两条路径包含不同的边，则认为这两条路径不同。求这棵树的所有本质不同的简单路的价值的乘积（价值为 $0$ 的除外），答案对 $998\\ 244\\ 353$ 取模。", "inputFormat": "输入一行包含一个整数 $n$。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "对于 $40\\%$ 的评测用例，$n\\le 10^3$；  \n对于 $70\\%$ 的评测用例，$n\\le 10^6$；  \n对于所有评测用例，$1\\le n\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国 A] 异或路径", "background": "", "description": "给定一棵有 $n$ 个结点的树，结点 $1$ 至 $n$ 编号。编号为 $x > 1$ 的结点与编号为 $\\lfloor \\sqrt x \\rfloor$\n 的结点有一条权值为 $x-\\lfloor \\sqrt x \\rfloor ^ 2$ 的边。\n \n定义一条路径的价值为这条路径上的所有边的权值的异或和。如果两条路径包含不同的边，则认为这两条路径不同。求这棵树的所有本质不同的简单路的价值的乘积（价值为 $0$ 的除外），答案对 $998\\ 244\\ 353$ 取模。", "inputFormat": "输入一行包含一个整数 $n$。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "对于 $40\\%$ 的评测用例，$n\\le 10^3$；  \n对于 $70\\%$ 的评测用例，$n\\le 10^6$；  \n对于所有评测用例，$1\\le n\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10584", "type": "P", "difficulty": 6, "samples": [["2 3", "2"], ["1000000000 1000000000", "12735999860"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2024", "蓝桥杯国赛", "整除分块", "杜教筛"], "title": "[蓝桥杯 2024 国 A] 数学题", "background": "", "description": "求 $\\sum\\limits_{i=1}^n{\\sum\\limits_{j=1}^m{|f(ij)|}}$，其中 $|f(x)|$ 当 $x$ 是完全平方数时为 $1$，否则为 $0$。", "inputFormat": "输入一行包含两个正整数，用一个空格分隔，表示题目描述中的 $n$ 和 $m$。\n\n", "outputFormat": "输出一行包含一个正整数表示答案。\n\n提示：数据保证答案不会超出 `unsigned long long` 表示范围。", "hint": "对于 $15\\%$ 的评测用例，$n,m \\le 10^5$；  \n对于 $30\\%$ 的评测用例，$n \\le 10^7$，$m \\le 10^9$；  \n对于 $50\\%$ 的评测用例，$n,m \\le 10^{11}$；  \n对于 $70\\%$ 的评测用例，$n,m \\le 10^{15}$；  \n对于所有评测用例，$1 \\le n,m \\le 1.5 \\times 10^{16}$。\n\n感谢 @[ACaCaca_](https://www.luogu.com.cn/user/320423) 提供数据。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 国 A] 数学题", "background": "", "description": "求 $\\sum\\limits_{i=1}^n{\\sum\\limits_{j=1}^m{|f(ij)|}}$，其中 $|f(x)|$ 当 $x$ 是完全平方数时为 $1$，否则为 $0$。", "inputFormat": "输入一行包含两个正整数，用一个空格分隔，表示题目描述中的 $n$ 和 $m$。\n\n", "outputFormat": "输出一行包含一个正整数表示答案。\n\n提示：数据保证答案不会超出 `unsigned long long` 表示范围。", "hint": "对于 $15\\%$ 的评测用例，$n,m \\le 10^5$；  \n对于 $30\\%$ 的评测用例，$n \\le 10^7$，$m \\le 10^9$；  \n对于 $50\\%$ 的评测用例，$n,m \\le 10^{11}$；  \n对于 $70\\%$ 的评测用例，$n,m \\le 10^{15}$；  \n对于所有评测用例，$1 \\le n,m \\le 1.5 \\times 10^{16}$。\n\n感谢 @[ACaCaca_](https://www.luogu.com.cn/user/320423) 提供数据。", "locale": "zh-CN"}}}
{"pid": "P10585", "type": "P", "difficulty": 3, "samples": [["4 2 5", "1 3 4 15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "Special Judge", "O2优化", "构造"], "title": "「ALFR Round 2」A Sum", "background": "", "description": "给定三个整数 $n,p,q$，你需要构造一个 $n$ 个数的序列 $a$，满足：\n\n- $\\forall 1\\leq i\\leq n:1 \\leq a_i\\leq 10^7,a_i\\in\\mathbb{Z}$；\n\n- $(\\sum\\limits_{1\\leq i<j\\leq n}[a_i+a_j\\leq q])=p$。\n\n通俗地说，每个数都是正整数且在 $[1, 10^7]$ 之间，且这 $n$ 个数无序选两个不同位置的数构成的 $\\dfrac{n(n-1)}{2}$ 个加和中有恰好 $p$ 个和不大于 $q$。你只需要给出一种方案即可。", "inputFormat": "一行三个整数 $n,p,q$。", "outputFormat": "一行 $n$ 个数，表示构造的序列。", "hint": "### 数据范围\n\n| 子任务 | 分值 | 限制 |\n| :----------: | :----------: | :----------: |\n| $0$ | $20$ | $p=0$ |\n| $1$ | $80$ | - |\n\n对于 $100\\%$ 的数据，$4\\leq n\\leq10^6$，$0\\leq p\\leq\\dfrac{n(n-1)}{2}$，$4\\leq q\\leq10^7$。\n\nUpdate 2024.7.1：根据[此贴](https://www.luogu.com.cn/discuss/836854)添加了一组 hack 数据进入子任务 $2$，分数为 $0$ 分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「ALFR Round 2」A Sum", "background": "", "description": "给定三个整数 $n,p,q$，你需要构造一个 $n$ 个数的序列 $a$，满足：\n\n- $\\forall 1\\leq i\\leq n:1 \\leq a_i\\leq 10^7,a_i\\in\\mathbb{Z}$；\n\n- $(\\sum\\limits_{1\\leq i<j\\leq n}[a_i+a_j\\leq q])=p$。\n\n通俗地说，每个数都是正整数且在 $[1, 10^7]$ 之间，且这 $n$ 个数无序选两个不同位置的数构成的 $\\dfrac{n(n-1)}{2}$ 个加和中有恰好 $p$ 个和不大于 $q$。你只需要给出一种方案即可。", "inputFormat": "一行三个整数 $n,p,q$。", "outputFormat": "一行 $n$ 个数，表示构造的序列。", "hint": "### 数据范围\n\n| 子任务 | 分值 | 限制 |\n| :----------: | :----------: | :----------: |\n| $0$ | $20$ | $p=0$ |\n| $1$ | $80$ | - |\n\n对于 $100\\%$ 的数据，$4\\leq n\\leq10^6$，$0\\leq p\\leq\\dfrac{n(n-1)}{2}$，$4\\leq q\\leq10^7$。\n\nUpdate 2024.7.1：根据[此贴](https://www.luogu.com.cn/discuss/836854)添加了一组 hack 数据进入子任务 $2$，分数为 $0$ 分。", "locale": "zh-CN"}}}
{"pid": "P10586", "type": "P", "difficulty": 5, "samples": [["4 3 3\n598946612 898419918 499122177\n998244308 79 998244317 5", "319837492"]], "limits": {"time": [1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "O2优化", "矩阵乘法"], "title": "「ALFR Round 2」B 篮球比赛", "background": "![](https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2023%2F0820%2F075e9bccj00rzoph900wkd000t200i6p.jpg&thumbnail=660x2147483647&quality=80&type=jpg)", "description": "小山即将参加 $n$ 场篮球比赛，他有一个多项式函数 $f(x)=a_0+a_1x^1+a_2x^2+\\dots+a_kx^k$ 与 $m$ 个和为 $1$ 的数 $p_1,p_2,p_3,\\dots,p_m$。\n\n他所在的球队有 $\\dfrac{f(i)}{\\sum_{j=1}^n f(j)}$ 的概率在第 $i$ 场比赛中取得**第一次**胜利，这意味着前面的 $i-1$ 场都输了。\n\n接下来，如果第 $i$ 场比赛中小山所在球队取得了胜利，则对于 $1\\le j\\le m$，他们有 $p_j$ 的概率在第 $i+j$ 场比赛取得下一次胜利，这意味着如果 $j\\gt1$，第 $i+1$ 场到第 $i+j-1$ 场都输了（若 $i+j>n$，则之后的比赛都输，没有再胜利）。\n\n小山想知道他所在球队的期望胜利场数，你能帮帮他吗？\n\n注意：在计算时，如果遇到分数（比如 $\\dfrac{f(i)}{\\sum_{j=1}^n f(j)}$），应使用分数取模形式。如果不知道什么是分数取模形式，参见 [P2613 【模板】有理数取余](https://www.luogu.com.cn/problem/P2613)。\n\n为了方便你的计算，输入数据将直接给出 $p_i,a_i$ 对 $998244353$ 取模的结果。", "inputFormat": "第一行 $3$ 个整数 $n, m, k$，含义如上所述。\n\n第二行 $m$ 个整数，第 $i$ 个整数表示 $p_i$ 模 $998244353$ 的值。\n\n第三行 $k + 1$ 个整数，第 $i$ 个整数表示 $a_{i - 1}$ 模 $998244353$ 的值。\n\n**注意是先输入 $p$ 再输入 $a$。**", "outputFormat": "一行一个数，表示答案模 $998244353$ 的值。", "hint": "### 样例解释\n\n在第一组样例中：$p_1=0.2,p_2=0.3,p_3=0.5$；$f(1)=3,f(2)=9,f(3)=3,f(4)=15$。胜利场数期望为 $1.2988$。\n\n### 数据范围\n\n| 子任务 | 分值 | 限制 |\n| :----------: | :----------: | :----------: |\n| $0$ | $10$ | $n=1$ |\n| $1$ | $30$ | $n\\le10^6$ |\n| $2$ | $60$ | - |\n\n对于 $100\\%$ 的数据，$1\\le n\\le 10^{18}$，$1\\le m,k \\le 50$，保证 $\\sum_{j=1}^n f(j)$ 不被 $998244353$ 整除。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「ALFR Round 2」B 篮球比赛", "background": "![](https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2023%2F0820%2F075e9bccj00rzoph900wkd000t200i6p.jpg&thumbnail=660x2147483647&quality=80&type=jpg)", "description": "小山即将参加 $n$ 场篮球比赛，他有一个多项式函数 $f(x)=a_0+a_1x^1+a_2x^2+\\dots+a_kx^k$ 与 $m$ 个和为 $1$ 的数 $p_1,p_2,p_3,\\dots,p_m$。\n\n他所在的球队有 $\\dfrac{f(i)}{\\sum_{j=1}^n f(j)}$ 的概率在第 $i$ 场比赛中取得**第一次**胜利，这意味着前面的 $i-1$ 场都输了。\n\n接下来，如果第 $i$ 场比赛中小山所在球队取得了胜利，则对于 $1\\le j\\le m$，他们有 $p_j$ 的概率在第 $i+j$ 场比赛取得下一次胜利，这意味着如果 $j\\gt1$，第 $i+1$ 场到第 $i+j-1$ 场都输了（若 $i+j>n$，则之后的比赛都输，没有再胜利）。\n\n小山想知道他所在球队的期望胜利场数，你能帮帮他吗？\n\n注意：在计算时，如果遇到分数（比如 $\\dfrac{f(i)}{\\sum_{j=1}^n f(j)}$），应使用分数取模形式。如果不知道什么是分数取模形式，参见 [P2613 【模板】有理数取余](https://www.luogu.com.cn/problem/P2613)。\n\n为了方便你的计算，输入数据将直接给出 $p_i,a_i$ 对 $998244353$ 取模的结果。", "inputFormat": "第一行 $3$ 个整数 $n, m, k$，含义如上所述。\n\n第二行 $m$ 个整数，第 $i$ 个整数表示 $p_i$ 模 $998244353$ 的值。\n\n第三行 $k + 1$ 个整数，第 $i$ 个整数表示 $a_{i - 1}$ 模 $998244353$ 的值。\n\n**注意是先输入 $p$ 再输入 $a$。**", "outputFormat": "一行一个数，表示答案模 $998244353$ 的值。", "hint": "### 样例解释\n\n在第一组样例中：$p_1=0.2,p_2=0.3,p_3=0.5$；$f(1)=3,f(2)=9,f(3)=3,f(4)=15$。胜利场数期望为 $1.2988$。\n\n### 数据范围\n\n| 子任务 | 分值 | 限制 |\n| :----------: | :----------: | :----------: |\n| $0$ | $10$ | $n=1$ |\n| $1$ | $30$ | $n\\le10^6$ |\n| $2$ | $60$ | - |\n\n对于 $100\\%$ 的数据，$1\\le n\\le 10^{18}$，$1\\le m,k \\le 50$，保证 $\\sum_{j=1}^n f(j)$ 不被 $998244353$ 整除。", "locale": "zh-CN"}}}
{"pid": "P10587", "type": "P", "difficulty": 6, "samples": [["8 8\n41 42 43 44 45 46 47 47\n4 1 8\n1 1 8 377\n4 1 8\n2 1 1 100\n1 1 8 624\n4 1 7\n3 1 8 424242\n4 1 5", "1\n2\n1\n5"]], "limits": {"time": [700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["线段树", "O2优化"], "title": "「ALFR Round 2」C 小 Y 的数", "background": "", "description": "小 Y 非常喜欢 $42$ 这个数，于是他也喜欢以 $42$ 为初始数，然后往后面依次拼接 $4,2$ 的数，如 $42,424,4242,\\cdots$。小 Y 给了你一个大小为 $n$ 的整数序列 $a$，小 Y 有 $m$ 次操作，操作有四种：\n\n- `1 l r x` 将 $l\\sim r$ 中的数加上 $x$。\n\n- `2 l r x` 将 $l\\sim r$ 中的数乘上 $x$。\n\n- `3 l r x` 将 $l\\sim r$ 中的数修改为 $x$。\n\n- `4 l r` 询问 $l\\sim r$ 中有多少个小 Y 喜欢的数。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数 $a_1,a_2,a_3\\cdots a_n$。\n\n接下来 $m$ 行，每行 $3$ 或 $4$ 个整数描述一次操作。", "outputFormat": "每行一个操作 $4$ 的答案。", "hint": "### 样例解释\n\n第 $1$ 次操作为询问区间 $1\\sim8$ 中有多少个小 Y 喜欢的数，共 $1$ 个，为 $a_2$。\n\n第 $2$ 次操作为将区间 $1\\sim8$ 中的数加上 $377$，数列 $a$ 变为 $418,419,420,421,422,423,424,424$。\n\n第 $3$ 次操作为询问区间 $1\\sim8$ 中有多少个小 Y 喜欢的数，共 $2$ 个，为 $a_7,a_8$。\n\n第 $4$ 次操作为将区间 $1\\sim1$ 中的数乘上 $100$，数列 $a$ 变为 $41800,419,420,421,422,423,424,424$。\n\n第 $5$ 次操作为将区间 $1\\sim8$ 中的数加上 $624$，数列 $a$ 变为 $42424,1043,1044,1045,1046,1047,1048,1048$。\n\n第 $6$ 次操作为询问区间 $1\\sim7$ 中有多少个小 Y 喜欢的数，共 $1$ 个，为 $a_1$。\n\n第 $7$ 次操作为将区间 $1\\sim8$ 中的数修改为 $424242$，数列 $a$ 变为 $424242,424242,424242,424242,424242,424242,424242,424242$。\n\n第 $8$ 次操作为询问区间 $1\\sim5$ 中有多少个小 Y 喜欢的数，共 $5$ 个，为 $a_1,a_2,a_3,a_4,a_5$。\n\n### 数据范围\n\n| 子任务 | 分值 | 限制 |\n| :----------: | :----------: | :----------: |\n| $0$ | $20$ | $n,m\\le10^4$ |\n| $1$ | $80$ | - |\n\n对于 $100\\%$ 的数据，$1\\le n,m,a_i,x\\le5\\times10^5$，$1\\le l,r\\le n$。\n\n保证每次操作后 $1\\le a_i\\le5\\times10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「ALFR Round 2」C 小 Y 的数", "background": "", "description": "小 Y 非常喜欢 $42$ 这个数，于是他也喜欢以 $42$ 为初始数，然后往后面依次拼接 $4,2$ 的数，如 $42,424,4242,\\cdots$。小 Y 给了你一个大小为 $n$ 的整数序列 $a$，小 Y 有 $m$ 次操作，操作有四种：\n\n- `1 l r x` 将 $l\\sim r$ 中的数加上 $x$。\n\n- `2 l r x` 将 $l\\sim r$ 中的数乘上 $x$。\n\n- `3 l r x` 将 $l\\sim r$ 中的数修改为 $x$。\n\n- `4 l r` 询问 $l\\sim r$ 中有多少个小 Y 喜欢的数。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数 $a_1,a_2,a_3\\cdots a_n$。\n\n接下来 $m$ 行，每行 $3$ 或 $4$ 个整数描述一次操作。", "outputFormat": "每行一个操作 $4$ 的答案。", "hint": "### 样例解释\n\n第 $1$ 次操作为询问区间 $1\\sim8$ 中有多少个小 Y 喜欢的数，共 $1$ 个，为 $a_2$。\n\n第 $2$ 次操作为将区间 $1\\sim8$ 中的数加上 $377$，数列 $a$ 变为 $418,419,420,421,422,423,424,424$。\n\n第 $3$ 次操作为询问区间 $1\\sim8$ 中有多少个小 Y 喜欢的数，共 $2$ 个，为 $a_7,a_8$。\n\n第 $4$ 次操作为将区间 $1\\sim1$ 中的数乘上 $100$，数列 $a$ 变为 $41800,419,420,421,422,423,424,424$。\n\n第 $5$ 次操作为将区间 $1\\sim8$ 中的数加上 $624$，数列 $a$ 变为 $42424,1043,1044,1045,1046,1047,1048,1048$。\n\n第 $6$ 次操作为询问区间 $1\\sim7$ 中有多少个小 Y 喜欢的数，共 $1$ 个，为 $a_1$。\n\n第 $7$ 次操作为将区间 $1\\sim8$ 中的数修改为 $424242$，数列 $a$ 变为 $424242,424242,424242,424242,424242,424242,424242,424242$。\n\n第 $8$ 次操作为询问区间 $1\\sim5$ 中有多少个小 Y 喜欢的数，共 $5$ 个，为 $a_1,a_2,a_3,a_4,a_5$。\n\n### 数据范围\n\n| 子任务 | 分值 | 限制 |\n| :----------: | :----------: | :----------: |\n| $0$ | $20$ | $n,m\\le10^4$ |\n| $1$ | $80$ | - |\n\n对于 $100\\%$ 的数据，$1\\le n,m,a_i,x\\le5\\times10^5$，$1\\le l,r\\le n$。\n\n保证每次操作后 $1\\le a_i\\le5\\times10^5$。", "locale": "zh-CN"}}}
{"pid": "P10588", "type": "P", "difficulty": 6, "samples": [["5\n3 3 1\n3 4 0\n114 514 86\n19198 10101 7211\n604800 4089470473293004800 443520 ", "7\n21\n191637399\n939162608\n305624040"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "O2优化", "组合数学", "生成函数"], "title": "「ALFR Round 2」D 超立方体", "background": ">  映入眼帘的是一棵硕大的樱花树。   \n>\n> 树下站着一个少女，她正抬头仰望着那棵樱花树。  \n> 我想：她是位新生吧，大概和我一样也是溜出来的。  \n> 我也抬着头望了望那棵樱花树。模模糊糊的花色遮住了天空。  \n> 刮起一阵风，飘舞着的樱花花瓣将少女裹住。  \n> 少女也看到了我……", "description": "那是你与米尔嘉最初的邂逅。  \n\n一如既往，米尔嘉又给你出了一道数列题。  \n洁白的信封上留着柑橘的芳香，  \n你小心翼翼地拆开信封阅读。\n\n------------\n\n在三维中，我们有三维立方体。  \n它的 $2^3$ 个点的坐标都可以写成 $(x,y,z)$ 的形式。  \n\n同理在 $n$ 维中，我们有 $n$ 维超立方体，它有 $2^n$ 个点。  \n其棱长为 $1$，且所有顶点的各维坐标都是非负整数。\n\n我们从点 $(0,0,\\dots,0)$ 出发，走过 $m$ 条棱，求到达点 $(1,1,\\dots,0)$ 的方案总数。\n\n其中要到达的点的坐标中有 $l$ 个数字 $1$。\n\n由于答案可能很大，你只需要输出方案数对 $998244353$ 取模后的结果就可以了。", "inputFormat": "第一行为一个整数 $T$，表示数据组数。\n\n接下来 $T$ 行，每行三个非负整数 $n,m,l$。", "outputFormat": "对于每组数据，输出一行一个整数答案。", "hint": "### 样例解释\n\n第一个例子中的 $7$ 种方案分别是：\n\n- $(0,0,0) \\to (1,0,0) \\to (0,0,0) \\to (1,0,0)$\n- $(0,0,0) \\to (0,1,0) \\to (0,0,0) \\to (1,0,0)$\n- $(0,0,0) \\to (0,0,1) \\to (0,0,0) \\to (1,0,0)$\n- $(0,0,0) \\to (1,0,0) \\to (1,1,0) \\to (1,0,0)$\n- $(0,0,0) \\to (1,0,0) \\to (1,0,1) \\to (1,0,0)$\n- $(0,0,0) \\to (0,1,0) \\to (1,1,0) \\to (1,0,0)$\n- $(0,0,0) \\to (0,0,1) \\to (1,0,1) \\to (1,0,0)$\n\n### 数据范围\n\n| 子任务 | 分值 | 限制 |\n| :----------: | :----------: | :----------: |\n| $0$ | $10$ | $\\sum nm\\le2^{26}$，$n\\le2^{13}$ |\n| $1$ | $20$ | $l=0$ |\n| $2$ | $30$ | $\\sum n^2\\le2^{26}$ |\n| $3$ | $40$ | - |\n\n对于 $100\\%$ 数据，$1\\le T\\le600$，$\\sum n\\log_2 n\\le2^{25}$，$n\\in[1,2^{21}]$，$m\\in[0,2^{64}-1]$，$l\\in[0,n]$。\n\n---\n\n你翻到背面，发现一行小字：\n\n请不要忘记考虑特殊情形。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「ALFR Round 2」D 超立方体", "background": ">  映入眼帘的是一棵硕大的樱花树。   \n>\n> 树下站着一个少女，她正抬头仰望着那棵樱花树。  \n> 我想：她是位新生吧，大概和我一样也是溜出来的。  \n> 我也抬着头望了望那棵樱花树。模模糊糊的花色遮住了天空。  \n> 刮起一阵风，飘舞着的樱花花瓣将少女裹住。  \n> 少女也看到了我……", "description": "那是你与米尔嘉最初的邂逅。  \n\n一如既往，米尔嘉又给你出了一道数列题。  \n洁白的信封上留着柑橘的芳香，  \n你小心翼翼地拆开信封阅读。\n\n------------\n\n在三维中，我们有三维立方体。  \n它的 $2^3$ 个点的坐标都可以写成 $(x,y,z)$ 的形式。  \n\n同理在 $n$ 维中，我们有 $n$ 维超立方体，它有 $2^n$ 个点。  \n其棱长为 $1$，且所有顶点的各维坐标都是非负整数。\n\n我们从点 $(0,0,\\dots,0)$ 出发，走过 $m$ 条棱，求到达点 $(1,1,\\dots,0)$ 的方案总数。\n\n其中要到达的点的坐标中有 $l$ 个数字 $1$。\n\n由于答案可能很大，你只需要输出方案数对 $998244353$ 取模后的结果就可以了。", "inputFormat": "第一行为一个整数 $T$，表示数据组数。\n\n接下来 $T$ 行，每行三个非负整数 $n,m,l$。", "outputFormat": "对于每组数据，输出一行一个整数答案。", "hint": "### 样例解释\n\n第一个例子中的 $7$ 种方案分别是：\n\n- $(0,0,0) \\to (1,0,0) \\to (0,0,0) \\to (1,0,0)$\n- $(0,0,0) \\to (0,1,0) \\to (0,0,0) \\to (1,0,0)$\n- $(0,0,0) \\to (0,0,1) \\to (0,0,0) \\to (1,0,0)$\n- $(0,0,0) \\to (1,0,0) \\to (1,1,0) \\to (1,0,0)$\n- $(0,0,0) \\to (1,0,0) \\to (1,0,1) \\to (1,0,0)$\n- $(0,0,0) \\to (0,1,0) \\to (1,1,0) \\to (1,0,0)$\n- $(0,0,0) \\to (0,0,1) \\to (1,0,1) \\to (1,0,0)$\n\n### 数据范围\n\n| 子任务 | 分值 | 限制 |\n| :----------: | :----------: | :----------: |\n| $0$ | $10$ | $\\sum nm\\le2^{26}$，$n\\le2^{13}$ |\n| $1$ | $20$ | $l=0$ |\n| $2$ | $30$ | $\\sum n^2\\le2^{26}$ |\n| $3$ | $40$ | - |\n\n对于 $100\\%$ 数据，$1\\le T\\le600$，$\\sum n\\log_2 n\\le2^{25}$，$n\\in[1,2^{21}]$，$m\\in[0,2^{64}-1]$，$l\\in[0,n]$。\n\n---\n\n你翻到背面，发现一行小字：\n\n请不要忘记考虑特殊情形。", "locale": "zh-CN"}}}
{"pid": "P10589", "type": "P", "difficulty": 4, "samples": [["5\n1 5 3 2 4", "3 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["树状数组"], "title": "楼兰图腾", "background": null, "description": "在完成了分配任务之后，西部 314 来到了楼兰古城的西部。相传很久以前这片土地上（比楼兰古城还早）生活着两个部落，一个部落崇拜尖刀（`V`），一个部落崇拜铁锹（`∧`），他们分别用 `V` 和 `∧` 的形状来代表各自部落的图腾。\n\n西部 314 在楼兰古城的下面发现了一幅巨大的壁画，壁画上被标记出了 $n$ 个点，经测量发现这 $n$ 个点的水平位置和竖直位置是两两不同的。西部 314 认为这幅壁画所包含的信息与这 $n$ 个点的相对位置有关，因此不妨设坐标分别为 $(1,y_1),(2,y_2),\\cdots,(n,y_n)$，其中 $y_1\\sim y_n$ 是 $1$ 到 $n$ 的一个排列。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/u8z4ffl9.png)\n\n如图，图中的 $y_1=1$，$y_2=5$，$y_3=3$，$y_4=2$，$y_5=4$。\n\n西部 314 打算研究这幅壁画中包含着多少个图腾，其中 `V` 图腾的定义如下（注意：图腾的形式只和这三个纵坐标的相对大小排列顺序有关）$1\\le i<j<k\\le n$ 且 $y_i>y_j$, $y_j<y_k$；\n\n而崇拜 `∧` 的部落的图腾被定义为 $1\\le i<j<k\\le n$ 且 $y_i<y_j$，$y_j>y_k$；\n\n西部 314 想知道，这 $n$ 个点中两个部落图腾的数目。因此，你需要编写一个程序来求出 `V` 的个数和 `∧` 的个数。", "inputFormat": "第一行一个正整数 $n$；\n\n第二行是 $n$ 个正整数，分别代表 $y_1,y_2,\\cdots,y_n$。", "outputFormat": "输出两个数，中间用空格隔开，依次为 `V` 的个数和 `∧` 的个数", "hint": "数据范围约定\n\n- 对于 $10\\%$ 的数据 $n\\le 600$；\n- 对于 $40\\%$ 的数据 $n\\le 5000$；\n- 对于 $100\\%$ 的数据 $n\\le 200000$，答案不超过 $2^{63} - 1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "楼兰图腾", "background": null, "description": "在完成了分配任务之后，西部 314 来到了楼兰古城的西部。相传很久以前这片土地上（比楼兰古城还早）生活着两个部落，一个部落崇拜尖刀（`V`），一个部落崇拜铁锹（`∧`），他们分别用 `V` 和 `∧` 的形状来代表各自部落的图腾。\n\n西部 314 在楼兰古城的下面发现了一幅巨大的壁画，壁画上被标记出了 $n$ 个点，经测量发现这 $n$ 个点的水平位置和竖直位置是两两不同的。西部 314 认为这幅壁画所包含的信息与这 $n$ 个点的相对位置有关，因此不妨设坐标分别为 $(1,y_1),(2,y_2),\\cdots,(n,y_n)$，其中 $y_1\\sim y_n$ 是 $1$ 到 $n$ 的一个排列。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/u8z4ffl9.png)\n\n如图，图中的 $y_1=1$，$y_2=5$，$y_3=3$，$y_4=2$，$y_5=4$。\n\n西部 314 打算研究这幅壁画中包含着多少个图腾，其中 `V` 图腾的定义如下（注意：图腾的形式只和这三个纵坐标的相对大小排列顺序有关）$1\\le i<j<k\\le n$ 且 $y_i>y_j$, $y_j<y_k$；\n\n而崇拜 `∧` 的部落的图腾被定义为 $1\\le i<j<k\\le n$ 且 $y_i<y_j$，$y_j>y_k$；\n\n西部 314 想知道，这 $n$ 个点中两个部落图腾的数目。因此，你需要编写一个程序来求出 `V` 的个数和 `∧` 的个数。", "inputFormat": "第一行一个正整数 $n$；\n\n第二行是 $n$ 个正整数，分别代表 $y_1,y_2,\\cdots,y_n$。", "outputFormat": "输出两个数，中间用空格隔开，依次为 `V` 的个数和 `∧` 的个数", "hint": "数据范围约定\n\n- 对于 $10\\%$ 的数据 $n\\le 600$；\n- 对于 $40\\%$ 的数据 $n\\le 5000$；\n- 对于 $100\\%$ 的数据 $n\\le 200000$，答案不超过 $2^{63} - 1$。", "locale": "zh-CN"}}}
{"pid": "P10590", "type": "P", "difficulty": 6, "samples": [["0 0 5 10 5\n5 4 7 11 5\n-7 1 4 7 8\n0 2 13 5 6\n2 -3 9 3 4\n13 5 1 9 9", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "广度优先搜索 BFS", "队列", "分块"], "title": "磁力块", "background": "", "description": "在一片广袤无垠的原野上，散落着 $N$ 块磁石。\n\n每个磁石的性质可以用一个五元组 $(x,y,m,p,r)$ 描述，其中 $x,y$ 表示其坐标，$m$ 是磁石的质量，$p$ 是磁力，$r$ 是吸引半径。\n\n若磁石 $A$ 与磁石 $B$ 的距离不大于磁石 $A$ 的吸引半径，并且磁石 $B$ 的质量不大于磁石 $A$ 的磁力，那么 $A$ 可以吸引 $B$。\n\n小取酒带着一块自己的磁石 $L$ 来到了这片原野的 $(x_0,y_0)$ 处，我们可以视磁石 $L$ 的坐标为 $(x_0,y_0)$。\n\n小取酒手持磁石 $L$ 并保持原地不动，所有可以被 $L$ 吸引的磁石将会被吸引过来。\n\n在每个时刻，他可以选择更换任意一块自己已经获得的磁石（当然也可以是自己最初携带的 $L$ 磁石）在 $(x_0,y_0)$ 处吸引更多的磁石。\n\n小取酒想知道，他最多能获得多少块磁石呢？", "inputFormat": "第一行五个整数 $x_0,y_0,p_L,r_L,N$，表示小取酒所在的位置，磁石 $L$ 磁力、吸引半径和原野上散落磁石的个数。\n\n接下来 $N$ 行每行五个整数 $x,y,m,p,r$，描述一块磁石的性质。", "outputFormat": "输出一个整数，表示最多可以获得的散落磁石个数（不包含最初携带的磁石 $L$）。\n", "hint": "对于 $30\\%$ 的数据，$1 \\le N \\le 1000$。\n\n对于另外 $30\\%$ 的数据，$p=r$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 250000$，$-10^9 \\le x,y \\le 10^9$，$1 \\le m,p,r \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "磁力块", "background": "", "description": "在一片广袤无垠的原野上，散落着 $N$ 块磁石。\n\n每个磁石的性质可以用一个五元组 $(x,y,m,p,r)$ 描述，其中 $x,y$ 表示其坐标，$m$ 是磁石的质量，$p$ 是磁力，$r$ 是吸引半径。\n\n若磁石 $A$ 与磁石 $B$ 的距离不大于磁石 $A$ 的吸引半径，并且磁石 $B$ 的质量不大于磁石 $A$ 的磁力，那么 $A$ 可以吸引 $B$。\n\n小取酒带着一块自己的磁石 $L$ 来到了这片原野的 $(x_0,y_0)$ 处，我们可以视磁石 $L$ 的坐标为 $(x_0,y_0)$。\n\n小取酒手持磁石 $L$ 并保持原地不动，所有可以被 $L$ 吸引的磁石将会被吸引过来。\n\n在每个时刻，他可以选择更换任意一块自己已经获得的磁石（当然也可以是自己最初携带的 $L$ 磁石）在 $(x_0,y_0)$ 处吸引更多的磁石。\n\n小取酒想知道，他最多能获得多少块磁石呢？", "inputFormat": "第一行五个整数 $x_0,y_0,p_L,r_L,N$，表示小取酒所在的位置，磁石 $L$ 磁力、吸引半径和原野上散落磁石的个数。\n\n接下来 $N$ 行每行五个整数 $x,y,m,p,r$，描述一块磁石的性质。", "outputFormat": "输出一个整数，表示最多可以获得的散落磁石个数（不包含最初携带的磁石 $L$）。\n", "hint": "对于 $30\\%$ 的数据，$1 \\le N \\le 1000$。\n\n对于另外 $30\\%$ 的数据，$p=r$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 250000$，$-10^9 \\le x,y \\le 10^9$，$1 \\le m,p,r \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10591", "type": "P", "difficulty": 6, "samples": [["3 \n1 \n1 \n0", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "容斥原理", "线性基"], "title": "BZOJ4671 异或图", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。", "description": "定义两个结点数相同的图 $G_1$ 与图 $G_2$ 的异或为一个新的图 $G$，其中如果 $(u,v)$ 在 $G_1$ 与 $G_2$ 中的出现之和为 $1$，那么边 $(u,v)$ 在 $G$ 中，否则这条边不在 $G$ 中。\n\n现在给定 $s$ 个结点数相同的图 $G_{1\\sim s}$，$S=\\{G_1,G_2,\\dots,G_s\\}$，请问 $S$ 有多少个子集的异或为一个连通图？", "inputFormat": "第一行为一个整数 $s$，表示图的个数。\n\n接下来每一行一个二进制串，第 $i$ 行的二进制串为 $g_i$，其中 $g_i$ 是原图通过以下伪代码转化得到的。图的结点从 $1$ 开始编号，下面设结点数为 $n$。\n\n```\nAlgorithm 1 Print a graph G = (V, E)\n\nfor i = 1 to n do\n    for j = i + 1 to n do\n        if G contains edge (i, j) then\n            print 1\n        else\n            print 0\n        end if\n    end for\nend for\n```", "outputFormat": "输出一行一个整数，表示方案数。", "hint": "对于 $100\\%$ 的数据，$2\\leq n\\leq 10$，$1\\leq s\\leq 60$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "BZOJ4671 异或图", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。", "description": "定义两个结点数相同的图 $G_1$ 与图 $G_2$ 的异或为一个新的图 $G$，其中如果 $(u,v)$ 在 $G_1$ 与 $G_2$ 中的出现之和为 $1$，那么边 $(u,v)$ 在 $G$ 中，否则这条边不在 $G$ 中。\n\n现在给定 $s$ 个结点数相同的图 $G_{1\\sim s}$，$S=\\{G_1,G_2,\\dots,G_s\\}$，请问 $S$ 有多少个子集的异或为一个连通图？", "inputFormat": "第一行为一个整数 $s$，表示图的个数。\n\n接下来每一行一个二进制串，第 $i$ 行的二进制串为 $g_i$，其中 $g_i$ 是原图通过以下伪代码转化得到的。图的结点从 $1$ 开始编号，下面设结点数为 $n$。\n\n```\nAlgorithm 1 Print a graph G = (V, E)\n\nfor i = 1 to n do\n    for j = i + 1 to n do\n        if G contains edge (i, j) then\n            print 1\n        else\n            print 0\n        end if\n    end for\nend for\n```", "outputFormat": "输出一行一个整数，表示方案数。", "hint": "对于 $100\\%$ 的数据，$2\\leq n\\leq 10$，$1\\leq s\\leq 60$。", "locale": "zh-CN"}}}
{"pid": "P10592", "type": "P", "difficulty": 6, "samples": [["4\n1 7 5 3", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "树状数组", "O2优化", "容斥原理"], "title": "BZOJ4361 isn", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。", "description": "给出一个长度为 $n$ 的序列 $a_1,a_2,\\dots a_n$。如果序列 $a$ 不是非降的，你必须从中删去一个数。\n\n这一操作将被不断执行，直到 $A$ 非降为止。求有多少种不同的操作方案。操作方案不同当且仅当删除的顺序或次数不同。答案对 $10^9+7$ 取模。", "inputFormat": "第一行输入一个正整数 $n$，表示序列长度。\n\n第二行输入 $n$ 个非负整数 $a_i$，表示序列。", "outputFormat": "一行一个整数，表示答案对 $10^9+7$ 取模的值。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 2\\times 10^3$，$0\\leq a_i \\leq 2^{31}-1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "BZOJ4361 isn", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。", "description": "给出一个长度为 $n$ 的序列 $a_1,a_2,\\dots a_n$。如果序列 $a$ 不是非降的，你必须从中删去一个数。\n\n这一操作将被不断执行，直到 $A$ 非降为止。求有多少种不同的操作方案。操作方案不同当且仅当删除的顺序或次数不同。答案对 $10^9+7$ 取模。", "inputFormat": "第一行输入一个正整数 $n$，表示序列长度。\n\n第二行输入 $n$ 个非负整数 $a_i$，表示序列。", "outputFormat": "一行一个整数，表示答案对 $10^9+7$ 取模的值。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 2\\times 10^3$，$0\\leq a_i \\leq 2^{31}-1$。", "locale": "zh-CN"}}}
{"pid": "P10593", "type": "P", "difficulty": 4, "samples": [["5 2\nXXXXX", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "O2优化"], "title": "BZOJ2958 序列染色", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。", "description": "给出一个长度为 $n$，由 $\\tt B,W,X$ 三种字符组成的字符串 $S$，你需要把每一个 $\\tt X$ 染成 $\\tt B$ 或 $\\tt W$ 中的一个。\n\n对于给出的 $k$，问由多少种染色方式，使得存在整数 $a,b,c,d$ 满足：\n- $1\\leq a\\leq b<c\\leq d\\leq n$；\n- $b=a+k-1$，$d=c+k-1$;\n- $S_a=S_{a+1}=\\dots=S_b=\\tt B$；\n- $S_c=S_{c+1}=\\dots=S_d=\\tt W$；\n\n由于方法可能很多，你只需输出最后的答案对 $10^9+7$ 取模的结果。", "inputFormat": "第一行输入两个正整数 $n,k$；\n\n第二行输出一个长度为 $n$ 的字符串 $S$。", "outputFormat": "输出一行，包含一个整数，表示答案。", "hint": "对于 $20\\%$ 的数据，$1\\leq n\\leq 20$；\n\n对于 $50\\%$ 的数据，$1\\leq n\\leq 2000$；\n\n对于 $100\\%$ 的数据，$1\\leq n,k\\leq 10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "BZOJ2958 序列染色", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。", "description": "给出一个长度为 $n$，由 $\\tt B,W,X$ 三种字符组成的字符串 $S$，你需要把每一个 $\\tt X$ 染成 $\\tt B$ 或 $\\tt W$ 中的一个。\n\n对于给出的 $k$，问由多少种染色方式，使得存在整数 $a,b,c,d$ 满足：\n- $1\\leq a\\leq b<c\\leq d\\leq n$；\n- $b=a+k-1$，$d=c+k-1$;\n- $S_a=S_{a+1}=\\dots=S_b=\\tt B$；\n- $S_c=S_{c+1}=\\dots=S_d=\\tt W$；\n\n由于方法可能很多，你只需输出最后的答案对 $10^9+7$ 取模的结果。", "inputFormat": "第一行输入两个正整数 $n,k$；\n\n第二行输出一个长度为 $n$ 的字符串 $S$。", "outputFormat": "输出一行，包含一个整数，表示答案。", "hint": "对于 $20\\%$ 的数据，$1\\leq n\\leq 20$；\n\n对于 $50\\%$ 的数据，$1\\leq n\\leq 2000$；\n\n对于 $100\\%$ 的数据，$1\\leq n,k\\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P10594", "type": "P", "difficulty": 6, "samples": [["1\n4 2", "32"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "中国剩余定理 CRT", "Lucas 定理"], "title": "BZOJ2445 最大团", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。", "description": "一个 $n$ 个点的无向图被叫做是一个 symmetric labeled cliquer，当且仅当该图的任意一个极大连通子图拥有相同的点数，并且任意一个极大连通子图都是完全图。\n\n现有 $m$ 种颜色和所有含有 $n$ 个点且节点有标号的 symmetric labeled cliquer。我们需要将每个 symmetric labeled cliquer 都染上一种颜色，两个不同的 symmetric labeled cliquer 可以染相同颜色，求方案数对 $10^9-401$ 取模的结果。", "inputFormat": "第一行读入一个正整数 $T$，表示数据组数。\n\n接下来每行包含两个正整数 $n,m$，含义如题所述。", "outputFormat": "输出包含 $T$ 行，每行输出答案。", "hint": "数据保证，$1\\leq T\\leq 2$，$1\\leq n,m\\leq 2\\times 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "BZOJ2445 最大团", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。", "description": "一个 $n$ 个点的无向图被叫做是一个 symmetric labeled cliquer，当且仅当该图的任意一个极大连通子图拥有相同的点数，并且任意一个极大连通子图都是完全图。\n\n现有 $m$ 种颜色和所有含有 $n$ 个点且节点有标号的 symmetric labeled cliquer。我们需要将每个 symmetric labeled cliquer 都染上一种颜色，两个不同的 symmetric labeled cliquer 可以染相同颜色，求方案数对 $10^9-401$ 取模的结果。", "inputFormat": "第一行读入一个正整数 $T$，表示数据组数。\n\n接下来每行包含两个正整数 $n,m$，含义如题所述。", "outputFormat": "输出包含 $T$ 行，每行输出答案。", "hint": "数据保证，$1\\leq T\\leq 2$，$1\\leq n,m\\leq 2\\times 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10595", "type": "P", "difficulty": 7, "samples": [["3\n3 3\n1 2 3\n5 4\n1 3 5 6 7\n10 3\n1 2 3 4 5 6 7 8 9 10", "Case #1:\n6: 1\n\nCase #2:\n15: 1\n16: 1\n17: 1\n19: 1\n21: 1\n\nCase #3:\n6: 1\n7: 1\n8: 2\n9: 3\n10: 4\n11: 5\n12: 7\n13: 8\n14: 9\n15: 10\n16: 10\n17: 10\n18: 10\n19: 9\n20: 8\n21: 7\n22: 5\n23: 4\n24: 3\n25: 2\n26: 1\n27: 1"]], "limits": {"time": [10000], "memory": [524288]}, "tags": ["2011", "上海", "O2优化", "生成函数", "快速傅里叶变换 FFT", "ICPC"], "title": "[ICPC-Shanghai 2011] Xavier is Learning to Count", "background": null, "description": "Xavier, a 9-year-old student, loves playing many kinds of puzzles. One of his favourites is the following:\n\nXerier, his classmate, has made many cards. She writes down a single positive number on each of them. No numbers written on different cards are the same. After that she writes down an equation, whose right side is a single positive number chosen by her, and the left side is the sum of $p$ integers:\n\nThen she asks Xavier put $p$ cards on the corresponding $X_i$’s position to make this equation correct, with an additional condition that $X_i$ should be ordered from smaller to bigger, i.e.\n\nEvery time Xavier immediately comes up with many solutions. Now he wants to know how many solutions in total are there for any $n$ given by Xerier.", "inputFormat": "There are multiple test cases. The number of them is given in the beginning of the input. Then a series of input block comes one by one.\n \nFor each test case:\n\nThe first line contains two space-separated integers $m$ and $p (1\\leq p\\leq 5)$. The second line contains $m$ distinct positive integers - the numbers written on each of the cards. None of these integers exceeds $13000$.\n\nThere are about $120$ test cases in total, but $90\\%$ of them are relatively small. More precisely, all numbers are less than or equal to $100$ in $90\\%$ of the test cases.", "outputFormat": "For each test case:\n\nFor each positive integer, output the number of ways in a single line. To keep the output finite, only numbers with positive ways should be outputted.\n\nOutput a blank line after each test case. See sample for more format details.", "hint": null, "locale": "en", "translations": {"en": {"title": "[ICPC-Shanghai 2011] Xavier is Learning to Count", "background": null, "description": "Xavier, a 9-year-old student, loves playing many kinds of puzzles. One of his favourites is the following:\n\nXerier, his classmate, has made many cards. She writes down a single positive number on each of them. No numbers written on different cards are the same. After that she writes down an equation, whose right side is a single positive number chosen by her, and the left side is the sum of $p$ integers:\n\nThen she asks Xavier put $p$ cards on the corresponding $X_i$’s position to make this equation correct, with an additional condition that $X_i$ should be ordered from smaller to bigger, i.e.\n\nEvery time Xavier immediately comes up with many solutions. Now he wants to know how many solutions in total are there for any $n$ given by Xerier.", "inputFormat": "There are multiple test cases. The number of them is given in the beginning of the input. Then a series of input block comes one by one.\n \nFor each test case:\n\nThe first line contains two space-separated integers $m$ and $p (1\\leq p\\leq 5)$. The second line contains $m$ distinct positive integers - the numbers written on each of the cards. None of these integers exceeds $13000$.\n\nThere are about $120$ test cases in total, but $90\\%$ of them are relatively small. More precisely, all numbers are less than or equal to $100$ in $90\\%$ of the test cases.", "outputFormat": "For each test case:\n\nFor each positive integer, output the number of ways in a single line. To keep the output finite, only numbers with positive ways should be outputted.\n\nOutput a blank line after each test case. See sample for more format details.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[ICPC-Shanghai 2011] Xavier is Learning to Count", "background": null, "description": "集合 $S$ 内有 $m$ 个互异整数。请对于任意整数 $i$ 求出 $S$ 内满足大小为 $p$ 且元素和为 $i$ 的子集数量。", "inputFormat": null, "outputFormat": null, "hint": null, "locale": "zh-CN"}}}
{"pid": "P10596", "type": "P", "difficulty": 5, "samples": [["3 2", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "容斥原理"], "title": "BZOJ2839 集合计数", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。", "description": "一个有 $N$ 个元素的集合有 $2^N$ 个不同子集（包含空集），现在要在这 $2^N$ 个集合中取出若干集合（至少一个），使得它们的交集的元素个数为 $K$，求取法的方案数，答案模 $10^9+7$。", "inputFormat": "一行两个整数 $N,K$。", "outputFormat": "一行一个整数表示答案。", "hint": "**【样例解释】**\n\n假设原集合为 $\\{A,B,C\\}$，则满足条件的方案为：$\\{AB,ABC\\}$，$\\{AC,ABC\\}$，$\\{BC,ABC\\}$，$\\{AB\\}$，$\\{AC\\}$，$\\{BC\\}$\n\n**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\leq N\\leq 1000000$，$0\\leq K\\leq N$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "BZOJ2839 集合计数", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。", "description": "一个有 $N$ 个元素的集合有 $2^N$ 个不同子集（包含空集），现在要在这 $2^N$ 个集合中取出若干集合（至少一个），使得它们的交集的元素个数为 $K$，求取法的方案数，答案模 $10^9+7$。", "inputFormat": "一行两个整数 $N,K$。", "outputFormat": "一行一个整数表示答案。", "hint": "**【样例解释】**\n\n假设原集合为 $\\{A,B,C\\}$，则满足条件的方案为：$\\{AB,ABC\\}$，$\\{AC,ABC\\}$，$\\{BC,ABC\\}$，$\\{AB\\}$，$\\{AC\\}$，$\\{BC\\}$\n\n**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\leq N\\leq 1000000$，$0\\leq K\\leq N$。", "locale": "zh-CN"}}}
{"pid": "P10597", "type": "P", "difficulty": 5, "samples": [["6\n1\n1\n2\n2\n3\n3", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "O2优化", "容斥原理"], "title": "BZOJ4665 小 w 的喜糖", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。\n\n---\n\n废话不多说，反正小 w 要发喜糖啦！！", "description": "小 w 一共买了 $n$ 块喜糖，发给了 $n$ 个人，每个喜糖有一个种类。这时，小 w 突发奇想，如果这 $n$ 个人相互交换手中的糖，那会有多少种方案使得每个人手中的糖的种类都与原来不同。\n\n两个方案不同当且仅当，存在一个人，他手中的糖的种类在两个方案中不一样。", "inputFormat": "第一行，一个正整数 $n$。\n\n接下来 $n$ 行，每行一个正整数，第 $i$ 个整数 $A_i$ 表示开始时第 $i$ 个人手中的糖的种类。\n", "outputFormat": "一行一个整数，表示方案数。答案对 $10^9+9$ 取模。", "hint": "对于所有数据，$1\\leq A_i \\leq n \\leq 2000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "BZOJ4665 小 w 的喜糖", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。\n\n---\n\n废话不多说，反正小 w 要发喜糖啦！！", "description": "小 w 一共买了 $n$ 块喜糖，发给了 $n$ 个人，每个喜糖有一个种类。这时，小 w 突发奇想，如果这 $n$ 个人相互交换手中的糖，那会有多少种方案使得每个人手中的糖的种类都与原来不同。\n\n两个方案不同当且仅当，存在一个人，他手中的糖的种类在两个方案中不一样。", "inputFormat": "第一行，一个正整数 $n$。\n\n接下来 $n$ 行，每行一个正整数，第 $i$ 个整数 $A_i$ 表示开始时第 $i$ 个人手中的糖的种类。\n", "outputFormat": "一行一个整数，表示方案数。答案对 $10^9+9$ 取模。", "hint": "对于所有数据，$1\\leq A_i \\leq n \\leq 2000$。", "locale": "zh-CN"}}}
{"pid": "P10598", "type": "P", "difficulty": 6, "samples": [["3 2 \n4\n1 1\n1 2\n2 1\n2 2", "2 2\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "二分图", "容斥原理"], "title": "BZOJ2162 男生女生", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。\n\n---\n\n雨荨的班主任安远老师是一个非常严厉的老师。到了大学，男生和女生之间难免会出现一些暧昧关系，但这样显然是影响学习的。所以作为艾利斯顿的一块招牌，安远老师当然要拒绝这种现象的出现以及繁衍。\n\n所以每当安远老师发现一个男生和一个女生放学走在一起或者男女生之间互相传纸条等，他就会立马制止并且通知家长。他也要求所有男女生晚上八点之后必须关手机，并且不定期打电话检查。于是安远老师的学生都感慨：这货不是大学，不是大学。", "description": "安远老师的学生里，一共有 $n$ 个男生和 $n$ 个女生，编号都以 $1\\sim n$ 编号。有 $m$ 对男女生之间有暧昧关系。现在安远老师想找出这样一个男女生群体，每个男生都和每个女生之间有暧昧关系，并且男女生总数最大。注意，男生数目或者女生数目可以为 $0$。\n\n如果有多个这样的群体，安远老师会选择男生最多的那个群体，因为他觉得男生会很不安分。如果这样的群体依然不唯一，他会选择任意一个。\n\n接下来，安远老师从选出的这个群体的所有暧昧关系中，选出 $k$ 个进行调查，使得这个群体的所有男生和女生，都至少和其中的一对暧昧关系有关系（即是这个暧昧关系的男/女主人公）。安远老师想让你告诉他总方案数除以 $19921228$ 的余数是多少。", "inputFormat": "输入的第一行包含两个正整数 $n$ 和 $k$，分别代表男生女生的个数，以及安远老师要选择的暧昧关系个数。\n\n第二行为一个正整数 $m$，代表暧昧关系总个数。接下来 $m$ 行，每行两个整数，代表一对有暧昧关系的男女生编号。", "outputFormat": "第一行有两个空格隔开的整数，代表选择的团体内男生和女生的个数。第二行有一个整数，代表选法除以 $19921228$ 的余数。", "hint": "对于所有数据，$1\\leq n \\leq 50$，$1\\leq m,k \\leq 2500$。同一对暧昧关系不会在输入中出现多次。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "BZOJ2162 男生女生", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。\n\n---\n\n雨荨的班主任安远老师是一个非常严厉的老师。到了大学，男生和女生之间难免会出现一些暧昧关系，但这样显然是影响学习的。所以作为艾利斯顿的一块招牌，安远老师当然要拒绝这种现象的出现以及繁衍。\n\n所以每当安远老师发现一个男生和一个女生放学走在一起或者男女生之间互相传纸条等，他就会立马制止并且通知家长。他也要求所有男女生晚上八点之后必须关手机，并且不定期打电话检查。于是安远老师的学生都感慨：这货不是大学，不是大学。", "description": "安远老师的学生里，一共有 $n$ 个男生和 $n$ 个女生，编号都以 $1\\sim n$ 编号。有 $m$ 对男女生之间有暧昧关系。现在安远老师想找出这样一个男女生群体，每个男生都和每个女生之间有暧昧关系，并且男女生总数最大。注意，男生数目或者女生数目可以为 $0$。\n\n如果有多个这样的群体，安远老师会选择男生最多的那个群体，因为他觉得男生会很不安分。如果这样的群体依然不唯一，他会选择任意一个。\n\n接下来，安远老师从选出的这个群体的所有暧昧关系中，选出 $k$ 个进行调查，使得这个群体的所有男生和女生，都至少和其中的一对暧昧关系有关系（即是这个暧昧关系的男/女主人公）。安远老师想让你告诉他总方案数除以 $19921228$ 的余数是多少。", "inputFormat": "输入的第一行包含两个正整数 $n$ 和 $k$，分别代表男生女生的个数，以及安远老师要选择的暧昧关系个数。\n\n第二行为一个正整数 $m$，代表暧昧关系总个数。接下来 $m$ 行，每行两个整数，代表一对有暧昧关系的男女生编号。", "outputFormat": "第一行有两个空格隔开的整数，代表选择的团体内男生和女生的个数。第二行有一个整数，代表选法除以 $19921228$ 的余数。", "hint": "对于所有数据，$1\\leq n \\leq 50$，$1\\leq m,k \\leq 2500$。同一对暧昧关系不会在输入中出现多次。", "locale": "zh-CN"}}}
{"pid": "P10599", "type": "P", "difficulty": 6, "samples": [["10 5 1 2 10\n1 1 3 3 4 4 6 6 9\n4\n1 6 3\n1 9 1\n0 1\n1 1 1", "11\n9\n12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "线段树", "背包 DP", "树链剖分"], "title": "BZOJ2164 采矿", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。", "description": "浩浩荡荡的 cg 大军发现了一座矿产资源极其丰富的城市，他们打算在这座城市实施新的采矿战略。\n\n这个城市可以看成一棵有 $n$ 个节点的有根树，我们把每个节点用 $1$ 到 $n$ 的整数编号。为了方便起见，对于任何一个非根节点 $v$，它任何一个祖先的编号都严格小于 $v$。树上的每个节点表示一个矿点，每条边表示一条街道。\n\n作为 cg 大军的一个小队长，你拥有 $m$ 个部下。你有一张二维的动态信息表，用 $T_{i,j}$ 表示第 $i$ 行第 $j$ 列的数据。当你被允许开采某个区域时，你可以将你的部下分配至各个矿点。在第 $i$ 个矿点安排 $j$ 个人可以获得 $T_{i,j}$ 单位的矿产。\n\n允许开采的区域是这样描述的：给你一对矿点 $(u,v)$，保证 $v$ 是 $u$ 的祖先（这里定义祖先包括 $u$ 本身）；$u$ 为你控制的区域，可以在以 $u$ 为根的子树上任意分配部下；$u$ 到 $v$ 的简单路径（不包括 $u$ 但包括 $v$，若 $u=v$ 则包括 $u$）为探险路径，在该路径上你可以选择至多一个矿点安排部下。你这次开采的收益为安排有部下的矿点的收益之和。", "inputFormat": "输入的第一行包含 $5$ 个正整数 $n,m,A,B,Q$。其中 $n$ 为矿点的个数，$m$ 为部下的数量。$A,B,Q$ 是与动态信息表有关的数据。\n\n第二行包含 $n-1$ 个正整数，第 $i$ 个数为 $F_{i+1}$，表示节点 $i+1$ 的父亲。\n\n接下来需要你用下文的方法依次生成 $n$ 组数据，每组数据共 $m$ 个。其中第 $i$ 组的 $m$ 个数据为信息表中第 $i$ 行的 $m$ 个数据。紧接着一行包含一个正整数 $C$，表示事件的数量。\n\n最后给出 $C$ 行，每行描述一个事件。每个事件会先给出一个 $0$ 或 $1$ 的整数。如果该数为 $0$，则后面有一个正整数 $p$，表示动态信息表有更新，你需要生成一组 $m$ 个数据，来替换信息表中第 $p$ 行的 $m$ 个数据。如果该数为$1$，则后面有两个正整数 $u,v$，表示出现了一个你可以开采的区域，你需要回答这次开采的收益。同一行的各个数之间均用一个空格隔开，没有多余的空格和换行。\n\n数据的生成方法如下：每次生成一组 $m$ 个从小到大排列的数据，替换动态信息表的一行。其中，从小到大第 $j$ 个数替换信息表中第 $j$ 列的数。调用以下代码 $m$ 次并排序得到一组数据。（注意可能会出现重复的数）\n\n```\nFunction GetInt \n\nA←((A xor B)+(B div X)+(B * X))and Y \nB←((A xor B)+(A div X)+(A * X))and Y \n\nreturn (A xor B)mod Q \n```\n\n其中 $A,B,Q$ 均用 $32$ 位有符号整数保存（C/C++ 的 signed long int 类型，pascal 的 longint 类型），$X=2^{16}$，$Y=2^{31}-1$，xor 为位异或运算，div 为整除运算，and 为位且运算，mod 为取余运算。由于只保留了低 $31$ 位，易得我们不用考虑数据的溢出问题。注意每次 $A$ 和 $B$ 都会被改变）", "outputFormat": "对于每个开采事件（开头为 $1$ 的事件），输出一行一个整数，为每次的收益。", "hint": "**【样例解释】**\n\n最初的信息表如下：\n\n| 0 | 1 | 1 | 2 | 2 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| 0 | 5 | 7 | 7 | 9 |\n| 1 | 2 | 3 | 4 | 5 |\n| 0 | 1 | 2 | 4 | 5 |\n| 2 | 4 | 7 | 8 | 8 |\n| 0 | 2 | 3 | 8 | 9 |\n| 1 | 3 | 5 | 6 | 8 |\n| 3 | 3 | 3 | 7 | 8 |\n| 0 | 1 | 2 | 3 | 9 |\n| 0 | 0 | 1 | 4 | 4 |\n\n变化后的第 $1$ 行，为：\n```\n1 1 1 4 7\n```\n第一次开采可以在矿点 $6,8,9,10$ 任意安排，可以在矿点 $3$ 或 $4$ 中选取一个安排开采。一种最优安排是在矿点 $6$ 安排 $4$人，在矿点 $8$ 安排 $1$ 人。第二次开采可以在矿点 $9$ 安排，可以在矿点 $6,4,3,1$ 中选择一个安排。一种最优安排是在矿点 $9$ 安排 $1$ 人，在矿点 $6$ 安排 $4$ 人。\n\n**【数据范围】**\n\n有 $50\\%$ 的数据，对于满足 $2\\leq i\\leq n$ 的整数 $i$，$F_i=i-1$。这些数据中有 $40\\%$ 的数据（即所有数据的 $20\\%$）满足 $n\\leq 500，m\\leq 20，C\\leq 500$。\n\n除上述数据，另有 $40\\%$ 的数据满足 $n\\leq 500$，$m\\leq 20$，$C\\leq 500$。\n\n对于 $100\\%$ 的数据 $1\\leq n\\leq 20000$，$1\\leq m\\leq 50$，$1\\leq C\\leq 2000$。对于满足 $2\\leq i\\leq n$ 的整数 $i$，$1\\leq F_i<i$。$1\\leq A,B\\leq 2^{31}-1$，$1\\leq Q\\leq 10000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "BZOJ2164 采矿", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。", "description": "浩浩荡荡的 cg 大军发现了一座矿产资源极其丰富的城市，他们打算在这座城市实施新的采矿战略。\n\n这个城市可以看成一棵有 $n$ 个节点的有根树，我们把每个节点用 $1$ 到 $n$ 的整数编号。为了方便起见，对于任何一个非根节点 $v$，它任何一个祖先的编号都严格小于 $v$。树上的每个节点表示一个矿点，每条边表示一条街道。\n\n作为 cg 大军的一个小队长，你拥有 $m$ 个部下。你有一张二维的动态信息表，用 $T_{i,j}$ 表示第 $i$ 行第 $j$ 列的数据。当你被允许开采某个区域时，你可以将你的部下分配至各个矿点。在第 $i$ 个矿点安排 $j$ 个人可以获得 $T_{i,j}$ 单位的矿产。\n\n允许开采的区域是这样描述的：给你一对矿点 $(u,v)$，保证 $v$ 是 $u$ 的祖先（这里定义祖先包括 $u$ 本身）；$u$ 为你控制的区域，可以在以 $u$ 为根的子树上任意分配部下；$u$ 到 $v$ 的简单路径（不包括 $u$ 但包括 $v$，若 $u=v$ 则包括 $u$）为探险路径，在该路径上你可以选择至多一个矿点安排部下。你这次开采的收益为安排有部下的矿点的收益之和。", "inputFormat": "输入的第一行包含 $5$ 个正整数 $n,m,A,B,Q$。其中 $n$ 为矿点的个数，$m$ 为部下的数量。$A,B,Q$ 是与动态信息表有关的数据。\n\n第二行包含 $n-1$ 个正整数，第 $i$ 个数为 $F_{i+1}$，表示节点 $i+1$ 的父亲。\n\n接下来需要你用下文的方法依次生成 $n$ 组数据，每组数据共 $m$ 个。其中第 $i$ 组的 $m$ 个数据为信息表中第 $i$ 行的 $m$ 个数据。紧接着一行包含一个正整数 $C$，表示事件的数量。\n\n最后给出 $C$ 行，每行描述一个事件。每个事件会先给出一个 $0$ 或 $1$ 的整数。如果该数为 $0$，则后面有一个正整数 $p$，表示动态信息表有更新，你需要生成一组 $m$ 个数据，来替换信息表中第 $p$ 行的 $m$ 个数据。如果该数为$1$，则后面有两个正整数 $u,v$，表示出现了一个你可以开采的区域，你需要回答这次开采的收益。同一行的各个数之间均用一个空格隔开，没有多余的空格和换行。\n\n数据的生成方法如下：每次生成一组 $m$ 个从小到大排列的数据，替换动态信息表的一行。其中，从小到大第 $j$ 个数替换信息表中第 $j$ 列的数。调用以下代码 $m$ 次并排序得到一组数据。（注意可能会出现重复的数）\n\n```\nFunction GetInt \n\nA←((A xor B)+(B div X)+(B * X))and Y \nB←((A xor B)+(A div X)+(A * X))and Y \n\nreturn (A xor B)mod Q \n```\n\n其中 $A,B,Q$ 均用 $32$ 位有符号整数保存（C/C++ 的 signed long int 类型，pascal 的 longint 类型），$X=2^{16}$，$Y=2^{31}-1$，xor 为位异或运算，div 为整除运算，and 为位且运算，mod 为取余运算。由于只保留了低 $31$ 位，易得我们不用考虑数据的溢出问题。注意每次 $A$ 和 $B$ 都会被改变）", "outputFormat": "对于每个开采事件（开头为 $1$ 的事件），输出一行一个整数，为每次的收益。", "hint": "**【样例解释】**\n\n最初的信息表如下：\n\n| 0 | 1 | 1 | 2 | 2 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| 0 | 5 | 7 | 7 | 9 |\n| 1 | 2 | 3 | 4 | 5 |\n| 0 | 1 | 2 | 4 | 5 |\n| 2 | 4 | 7 | 8 | 8 |\n| 0 | 2 | 3 | 8 | 9 |\n| 1 | 3 | 5 | 6 | 8 |\n| 3 | 3 | 3 | 7 | 8 |\n| 0 | 1 | 2 | 3 | 9 |\n| 0 | 0 | 1 | 4 | 4 |\n\n变化后的第 $1$ 行，为：\n```\n1 1 1 4 7\n```\n第一次开采可以在矿点 $6,8,9,10$ 任意安排，可以在矿点 $3$ 或 $4$ 中选取一个安排开采。一种最优安排是在矿点 $6$ 安排 $4$人，在矿点 $8$ 安排 $1$ 人。第二次开采可以在矿点 $9$ 安排，可以在矿点 $6,4,3,1$ 中选择一个安排。一种最优安排是在矿点 $9$ 安排 $1$ 人，在矿点 $6$ 安排 $4$ 人。\n\n**【数据范围】**\n\n有 $50\\%$ 的数据，对于满足 $2\\leq i\\leq n$ 的整数 $i$，$F_i=i-1$。这些数据中有 $40\\%$ 的数据（即所有数据的 $20\\%$）满足 $n\\leq 500，m\\leq 20，C\\leq 500$。\n\n除上述数据，另有 $40\\%$ 的数据满足 $n\\leq 500$，$m\\leq 20$，$C\\leq 500$。\n\n对于 $100\\%$ 的数据 $1\\leq n\\leq 20000$，$1\\leq m\\leq 50$，$1\\leq C\\leq 2000$。对于满足 $2\\leq i\\leq n$ 的整数 $i$，$1\\leq F_i<i$。$1\\leq A,B\\leq 2^{31}-1$，$1\\leq Q\\leq 10000$。", "locale": "zh-CN"}}}
{"pid": "P10600", "type": "P", "difficulty": 5, "samples": [["5\n1 0\n5 0\n3 2\n1 2\n2 3\n3 2\n2 1\n2 3\n3 3\n1 2\n2 3\n3 1", "1\n42\n1\n2\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "O2优化", "区间 DP"], "title": "BZOJ4350 括号序列再战猪猪侠", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。", "description": "括号序列是一个仅由 `()` 构成的序列。以下的括号序列是合法的：\n1. `()` 是一个合法序列。\n2. 如果 `A` 是一个合法序列，则 `(A)`  也是一个合法序列。\n3. 如果 `A` 和 `B` 都是合法序列，则 `AB` 也是一个合法序列。\n\n定义 $match_i$ 表示从左往右数第 $i$ 个左括号所对应的是第几个右括号。\n\n现在得到了一个长度为 $2n$ 的括号序列，提供 $m$ 个信息，第 $i$ 个信息形如 $a_i,b_i$，表示 $match_{a_i}<match_{b_i}$。\n\n现问，若根据这些信息还原出合法括号序列的方案数一共有多少？答案对 $998244353$ 取模。", "inputFormat": "第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据，第一行两个正整数 $n,m$。其中 $n$ 表示有几个左括号，$m$ 表示信息数。\n\n接下来 $m$ 行，每行两个正整数 $a_i,b_i$。", "outputFormat": "对于每组数据，输出一个数表示答案。", "hint": "对于所有数据，保证 $1\\leq T\\leq 5$，$1\\leq n\\leq 300$，$1\\leq a_i,b_i\\leq n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "BZOJ4350 括号序列再战猪猪侠", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。", "description": "括号序列是一个仅由 `()` 构成的序列。以下的括号序列是合法的：\n1. `()` 是一个合法序列。\n2. 如果 `A` 是一个合法序列，则 `(A)`  也是一个合法序列。\n3. 如果 `A` 和 `B` 都是合法序列，则 `AB` 也是一个合法序列。\n\n定义 $match_i$ 表示从左往右数第 $i$ 个左括号所对应的是第几个右括号。\n\n现在得到了一个长度为 $2n$ 的括号序列，提供 $m$ 个信息，第 $i$ 个信息形如 $a_i,b_i$，表示 $match_{a_i}<match_{b_i}$。\n\n现问，若根据这些信息还原出合法括号序列的方案数一共有多少？答案对 $998244353$ 取模。", "inputFormat": "第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据，第一行两个正整数 $n,m$。其中 $n$ 表示有几个左括号，$m$ 表示信息数。\n\n接下来 $m$ 行，每行两个正整数 $a_i,b_i$。", "outputFormat": "对于每组数据，输出一个数表示答案。", "hint": "对于所有数据，保证 $1\\leq T\\leq 5$，$1\\leq n\\leq 300$，$1\\leq a_i,b_i\\leq n$。", "locale": "zh-CN"}}}
{"pid": "P10601", "type": "P", "difficulty": 6, "samples": [["10 15\nstockholm\namsterdam\nlondon\nberlin\ncopenhagen\noslo\nhelsinki\ndublin\nreykjavik\nbrussels\noslo stockholm 415\nstockholm helsinki 396\noslo london 1153\noslo copenhagen 485\nstockholm copenhagen 522\ncopenhagen berlin 354\ncopenhagen amsterdam 622\nhelsinki berlin 1107\nlondon amsterdam 356\nberlin amsterdam 575\nlondon dublin 463\nreykjavik dublin 1498\nreykjavik oslo 1748\nlondon brussels 318\nbrussels amsterdam 173\nstockholm amsterdam\noslo london\nreykjavik dublin\nbrussels helsinki", "3907"], ["2 1\nfirst\nsecond\nfirst second 10\nfirst first\nfirst first\nsecond first\nfirst first", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2006", "O2优化", "ICPC", "状压 DP"], "title": "[NWERC 2006] Ticket to Ride", "background": "", "description": "给一张地图，地图上有一些城市，城市之间可能有线路连通，我们用一个无向图来表示以简化概念，每条边有个权值，表示选择这条边需要花费的费用。给定 $4$ 对顶点（可能重复），求一个权值最小的边集，使得任意一对顶点可以由选出的边集中的边相连。", "inputFormat": "第一行输入 $2$ 个整数，$n$ 和 $m$，分别表示城市的个数和边的个数。\n\n接下来 $n$ 行，每行一个字符串，表示每个城市的名字。城市的名字为一个不超过 $20$ 个字符，由小写字母构成的字符串。\n\n再接下来 $m$ 行，每行给出 $s_1,s_2,w$，其中 $s_1,s_2$ 为城市的名字，$w$ 为他们之间边的权值。\n\n最后，给出 $4$ 行，每行给出两个字符串，分别为要求的一对城市的名字。", "outputFormat": "输出一行，输出最小的花费。", "hint": "数据保证，$1\\leq n\\leq 30$，$0\\leq m\\leq 1000$，$1\\leq w\\leq 10000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NWERC 2006] Ticket to Ride", "background": "", "description": "给一张地图，地图上有一些城市，城市之间可能有线路连通，我们用一个无向图来表示以简化概念，每条边有个权值，表示选择这条边需要花费的费用。给定 $4$ 对顶点（可能重复），求一个权值最小的边集，使得任意一对顶点可以由选出的边集中的边相连。", "inputFormat": "第一行输入 $2$ 个整数，$n$ 和 $m$，分别表示城市的个数和边的个数。\n\n接下来 $n$ 行，每行一个字符串，表示每个城市的名字。城市的名字为一个不超过 $20$ 个字符，由小写字母构成的字符串。\n\n再接下来 $m$ 行，每行给出 $s_1,s_2,w$，其中 $s_1,s_2$ 为城市的名字，$w$ 为他们之间边的权值。\n\n最后，给出 $4$ 行，每行给出两个字符串，分别为要求的一对城市的名字。", "outputFormat": "输出一行，输出最小的花费。", "hint": "数据保证，$1\\leq n\\leq 30$，$0\\leq m\\leq 1000$，$1\\leq w\\leq 10000$。", "locale": "zh-CN"}}}
{"pid": "P10602", "type": "P", "difficulty": 6, "samples": [["5\n1 2 20\n2 3 12\n2 4 1\n4 5 3\n26 9\n1 10\n500 2\n2 30", "206 321 542 328"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2009", "二分", "O2优化", "CEOI（中欧）", "斜率优化", "单调栈"], "title": "[CEOI 2009] Harbingers", "background": "", "description": "给定一颗树，树中每个结点有一个邮递员，每个邮递员要沿着唯一的路径走向 capital（$1$ 号结点），每到一个城市他可以有两种选择：\n\n1. 继续走到下个城市；\n2. 让这个城市的邮递员替他出发。\n\n每个邮递员出发需要一个准备时间 $W_i$，他们的速度是 $V_i$，表示走一公里需要多少分钟。现在要你求出每个城市的邮递员到 capital 的最少时间（不一定是他自己到 capital，可以是别人帮他）？", "inputFormat": "第一行一个正整数 $N$；\n\n接下来 $N-1$ 行，每行三个正整数 $A,B,C$，表示结点 $A$ 和 $B$ 之间有一条长度为 $C$ 的边；\n\n再接下来 $N-1$ 行，每行 $2$ 个整数 $W_i,V_i$。", "outputFormat": "输出每个城市的邮递员到 capital 的最少时间。", "hint": "对于 $20\\%$ 的数据，$N\\leq 2500$；\n\n对于 $50\\%$ 的数据，树是一条链；\n\n对于所有数据，$3\\leq N\\leq 10^5$，$0\\leq W_i,V_i\\leq 10^9$，每条边长度不超过 $10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2009] Harbingers", "background": "", "description": "给定一颗树，树中每个结点有一个邮递员，每个邮递员要沿着唯一的路径走向 capital（$1$ 号结点），每到一个城市他可以有两种选择：\n\n1. 继续走到下个城市；\n2. 让这个城市的邮递员替他出发。\n\n每个邮递员出发需要一个准备时间 $W_i$，他们的速度是 $V_i$，表示走一公里需要多少分钟。现在要你求出每个城市的邮递员到 capital 的最少时间（不一定是他自己到 capital，可以是别人帮他）？", "inputFormat": "第一行一个正整数 $N$；\n\n接下来 $N-1$ 行，每行三个正整数 $A,B,C$，表示结点 $A$ 和 $B$ 之间有一条长度为 $C$ 的边；\n\n再接下来 $N-1$ 行，每行 $2$ 个整数 $W_i,V_i$。", "outputFormat": "输出每个城市的邮递员到 capital 的最少时间。", "hint": "对于 $20\\%$ 的数据，$N\\leq 2500$；\n\n对于 $50\\%$ 的数据，树是一条链；\n\n对于所有数据，$3\\leq N\\leq 10^5$，$0\\leq W_i,V_i\\leq 10^9$，每条边长度不超过 $10^4$。", "locale": "zh-CN"}}}
{"pid": "P10603", "type": "P", "difficulty": 6, "samples": [["7 6\n1 2\n1 4\n1 5\n2 3\n2 7\n5 6\nM 1 1 2\nQ 5\nM 2 2 3\nQ 3\nM 1 2 1\nQ 2", "2\n3\n6"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "树状数组", "O2优化", "动态树分治"], "title": "BZOJ4372 烁烁的游戏", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。\n\n---\n\n烁烁很喜欢爬树，这吓坏了树上的皮皮鼠。\n\n给定一颗 $n$ 个节点的树，边权均为 $1$，初始树上没有皮皮鼠。\n\n烁烁他每次会跳到一个节点 $u$ ，把周围与他距离不超过 $d$ 的节点各吸引出 $w$ 只皮皮鼠。皮皮鼠会被烁烁吸引，所以会一直待在节点上不动。\n\n烁烁很好奇，在当前时刻，节点 $u$ 有多少个他的好朋友——皮皮鼠。", "description": "题目背景可以被抽象成这个问题：\n\n给一棵 $n$ 个结点的树，边权均为 $1$，初始点权均为 $0$。进行 $m$ 次操作：\n- $\\text{Q x}$：询问结点 $x$ 的点权。\n- $\\text{M x d w}$：将树上与结点 $x$ 距离不超过 $d$ 的节点的点权均加上 $w$。", "inputFormat": "第一行两个正整数 $n,m$。\n\n接下来的 $n-1$ 行，每行三个正整数 $u,v$，代表 $u,v$ 之间有一条边。\n\n接下来的 $m$ 行，每行给出上述两种操作中的一种。", "outputFormat": "对于每个 $Q$ 操作，输出当前 $x$ 结点的点权。", "hint": "对于所有数据，保证 $1\\leq n,m\\leq 10^5$，$|w|\\leq 10^4$。注意：$w$ 不一定为正整数，", "locale": "zh-CN", "translations": {"zh-CN": {"title": "BZOJ4372 烁烁的游戏", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。\n\n---\n\n烁烁很喜欢爬树，这吓坏了树上的皮皮鼠。\n\n给定一颗 $n$ 个节点的树，边权均为 $1$，初始树上没有皮皮鼠。\n\n烁烁他每次会跳到一个节点 $u$ ，把周围与他距离不超过 $d$ 的节点各吸引出 $w$ 只皮皮鼠。皮皮鼠会被烁烁吸引，所以会一直待在节点上不动。\n\n烁烁很好奇，在当前时刻，节点 $u$ 有多少个他的好朋友——皮皮鼠。", "description": "题目背景可以被抽象成这个问题：\n\n给一棵 $n$ 个结点的树，边权均为 $1$，初始点权均为 $0$。进行 $m$ 次操作：\n- $\\text{Q x}$：询问结点 $x$ 的点权。\n- $\\text{M x d w}$：将树上与结点 $x$ 距离不超过 $d$ 的节点的点权均加上 $w$。", "inputFormat": "第一行两个正整数 $n,m$。\n\n接下来的 $n-1$ 行，每行三个正整数 $u,v$，代表 $u,v$ 之间有一条边。\n\n接下来的 $m$ 行，每行给出上述两种操作中的一种。", "outputFormat": "对于每个 $Q$ 操作，输出当前 $x$ 结点的点权。", "hint": "对于所有数据，保证 $1\\leq n,m\\leq 10^5$，$|w|\\leq 10^4$。注意：$w$ 不一定为正整数，", "locale": "zh-CN"}}}
{"pid": "P10604", "type": "P", "difficulty": 6, "samples": [["5 2\n1 5 2\n1 2 4\n2 3 6\n2 4 5", "4\n5\n10\n9\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["平衡树", "O2优化", "动态树分治"], "title": "BZOJ4317 Atm 的树", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。\n\n---\n\nAtm 有一段时间在虐 qtree 的题目，于是，他满脑子都是 tree，tree，tree……", "description": "于是，一天晚上他梦到自己被关在了一个有根树中，每条路径都有边权，一个神秘的声音告诉他，每个点到其他的点有一个距离，他需要对于每个点回答：从这个点出发的第 $k$ 小距离是多少；\n\n如果 atm 不能回答出来，那么明天 4019 的闹钟将不会响，4019 全寝可能就迟到了，所以 atm 希望你帮帮他。", "inputFormat": "第一行两个整数 $n,k$，表述询问的树的结点个数，以及题目中的 $k$。\n\n接下来 $n-1$ 行，每行三个正整数 $u,v,w$，表示从结点 $u$ 到 $v$ 有一条边权为 $w$ 的边。", "outputFormat": "共 $n$ 行，第 $i$ 行表示从结点 $i$ 出发的第 $k$ 小距离为多少。", "hint": "对于所有数据，$1\\leq n\\leq 15000$，$1\\leq k\\leq 5000$，$1\\leq w\\leq 10$。树的根为结点 $1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "BZOJ4317 Atm 的树", "background": "题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。\n\n---\n\nAtm 有一段时间在虐 qtree 的题目，于是，他满脑子都是 tree，tree，tree……", "description": "于是，一天晚上他梦到自己被关在了一个有根树中，每条路径都有边权，一个神秘的声音告诉他，每个点到其他的点有一个距离，他需要对于每个点回答：从这个点出发的第 $k$ 小距离是多少；\n\n如果 atm 不能回答出来，那么明天 4019 的闹钟将不会响，4019 全寝可能就迟到了，所以 atm 希望你帮帮他。", "inputFormat": "第一行两个整数 $n,k$，表述询问的树的结点个数，以及题目中的 $k$。\n\n接下来 $n-1$ 行，每行三个正整数 $u,v,w$，表示从结点 $u$ 到 $v$ 有一条边权为 $w$ 的边。", "outputFormat": "共 $n$ 行，第 $i$ 行表示从结点 $i$ 出发的第 $k$ 小距离为多少。", "hint": "对于所有数据，$1\\leq n\\leq 15000$，$1\\leq k\\leq 5000$，$1\\leq w\\leq 10$。树的根为结点 $1$。", "locale": "zh-CN"}}}
{"pid": "P10605", "type": "P", "difficulty": 1, "samples": [["2 1\n2 3\n4", "7"], ["3 3\n1 1 1\n1 5 6", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "洛谷原创", "O2优化", "洛谷月赛"], "title": "下头论文", "background": "莲子一直在苦恼关于论文的灵感。她为此花了太多时间，以至于没有时间理会她的伙伴梅莉。", "description": "一天，莲子发现了一个绝妙的点子，并希望通过实验等过程将其完善。具体来说，**她需要依次完成 $n$ 项任务**，其中第 $i$ 项任务需要连续的 $a_i$ 天来完成。也就是说，假设她在第 $x$ 天开始该任务，那么她会在第 $x+a_i-1$ 天结束后完成该任务，她需要保证这些天里她都是空闲的。\n\n不幸的是，她有 $m$ 天有各种事要去做，这些非空闲的日子会以一个单调递增序列 $b$ 的形式给出。即，对于任意的 $i(1\\leq i<m)$，满足 $b_i<b_{i+1}$。\n\n莲子希望完成任务的时间越短越好。例如：不妨假设，莲子要完成 $2$ 项任务，第一项耗时 $2$ 天，第二项耗时 $3$ 天，而第 $4$ 天莲子有事情要去做。则下图呈现了一种方案，使得莲子完成任务的时间尽可能短，为 $7$ 天：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bdiupoc1.png)\n\n她想要知道，在最好情况下，她能在第几天结束后完成所有任务。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个正整数描述序列 $a$。\n\n第三行 $m$ 个正整数描述序列 $b$。保证 $b$ 为单调递增序列。", "outputFormat": "一行一个整数，表示莲子最快能在第几天结束后完成所有任务。", "hint": "### 样例解释\n\n#### 样例 \\#1\n\n即在题面中提及的情况。莲子在第 $1$ 天开始第一项任务，在第 $2$ 天结束后完成第一项任务。由于第 $4$ 天有事，她不能从第 $3$ 天开始第二项任务，于是她只好从第 $5$ 天开始该任务，在第 $7$ 天结束时完成全部任务。\n\n注意到该样例符合 $\\textbf{Subtask 2}$ 的特殊性质。\n#### 样例 \\#2\n\n莲子在第 $2$ 至第 $4$ 天**依次**完成了所有任务。\n\n### 数据范围\n\n**本题采用捆绑测试。每一个 Subtask 内的测试点均需通过才能获得该 Subtask 的分数。**\n\n简记：$\\sum a_i$ 为所有 $a_i$ 的和，即 $a_1+a_2+\\dots+a_n$。其他试题中若无特殊说明也以此解释为准。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{\\textsf{分值}} & \\bm{n,m\\le } & \\bm{\\sum a_i\\le} & \\bm{b_i\\le} & \\textbf{\\textsf{特殊性质}}&\\textbf{Subtask \\textsf{依赖}}\\cr\\hline\n1 & 20 & 10 & 100 & 100 & - &-\\cr\\hline\n2 & 20 & 10^5 & 10^8 & 10^8 & m=1&- \\cr\\hline\n3 & 20 & 10^3 & 10^8 & 10^8 & \\mathbf{-}&-  \\cr\\hline\n4 & 40 & 10^5 & 10^8 &  10^8& -&1,2,3 \\cr\\hline\n\\end{array}\n$$\n\n对于所有数据满足：$1\\le n,m\\le 10^5$，$1\\le a_i \\le \\sum a_i\\le 10^8$, $1\\le b_i\\le 10^8$，$b$ 为单调递增序列。", "locale": "zh-CN", "translations": {"en": {"title": "Frustrating Paper", "background": "Renko has been struggling with inspiration for her paper. She has spent so much time on it that she hasn't had time to interact with her partner Merry.", "description": "One day, Renko discovered an excellent idea and wanted to refine it through experiments. Specifically, **she needs to complete $n$ tasks sequentially**, where the $i$-th task requires $a_i$ consecutive days to complete. This means if she starts the task on day $x$, she will finish it after day $x + a_i - 1$. She must ensure she is free on all those days.\n\nUnfortunately, she has $m$ days with prior commitments, given as a monotonically increasing sequence $b$. That is, for any $i$ ($1 \\leq i < m$), $b_i < b_{i+1}$.\n\nRenko wants to minimize the total time taken to complete all tasks. For example: suppose she needs to complete 2 tasks, where the first takes 2 days and the second 3 days, and she has a commitment on day 4. The figure below shows a scenario where Renko finishes all tasks in the shortest possible time of 7 days:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bdiupoc1.png)\n\n- Green: be in progress\n- Red: be busy\n- Blank: spare time\n\nShe wants to determine the earliest day she can complete all tasks under optimal conditions.\n", "inputFormat": "- The first line contains two integers $n$ and $m$.\n- The second line contains $n$ positive integers describing sequence $a$.\n- The third line contains $m$ positive integers describing sequence $b$, which is guaranteed to be monotonically increasing.", "outputFormat": "Output one integer: the earliest day Renko can finish all tasks.", "hint": "### Sample #1\n\nThis matches the scenario described in the problem. Renko starts the first task on day 1 and finishes it after day 2. Due to her commitment on day 4, she cannot start the second task on day 3. Instead, she starts it on day 5 and completes it after day 7.\n\nThis sample satisfies the special property of **Subtask 2**.\n\n### Sample #2\n\nRenko completes all tasks **consecutively** from day 2 to day 4.\n\n### Constraints\n\n**Bundled testing is used. All test cases in a Subtask must be passed to receive its points.**\n\nNote: $\\sum a_i$ denotes the sum of all $a_i$ (i.e., $a_1 + a_2 + \\dots + a_n$). The same applies to other problems unless stated otherwise.\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{Points} & \\bm{n,m \\leq} & \\bm{\\sum a_i \\leq} & \\bm{b_i \\leq} & \\textbf{Special Property} & \\textbf{Subtask Dependencies} \\cr\\hline\n1 & 20 & 10 & 100 & 100 & - & - \\cr\\hline\n2 & 20 & 10^5 & 10^8 & 10^8 & m=1 & - \\cr\\hline\n3 & 20 & 10^3 & 10^8 & 10^8 & \\text{None} & - \\cr\\hline\n4 & 40 & 10^5 & 10^8 & 10^8 & \\text{None} & 1,2,3 \\cr\\hline\n\\end{array}\n$$\n\nFor all data: $1 \\leq n, m \\leq 10^5$, $1 \\leq a_i \\leq \\sum a_i \\leq 10^8$, $1 \\leq b_i \\leq 10^8$, and $b$ is monotonically increasing.\n\n---\n\nTranslated by DeepSeek R1", "locale": "en"}, "zh-CN": {"title": "下头论文", "background": "莲子一直在苦恼关于论文的灵感。她为此花了太多时间，以至于没有时间理会她的伙伴梅莉。", "description": "一天，莲子发现了一个绝妙的点子，并希望通过实验等过程将其完善。具体来说，**她需要依次完成 $n$ 项任务**，其中第 $i$ 项任务需要连续的 $a_i$ 天来完成。也就是说，假设她在第 $x$ 天开始该任务，那么她会在第 $x+a_i-1$ 天结束后完成该任务，她需要保证这些天里她都是空闲的。\n\n不幸的是，她有 $m$ 天有各种事要去做，这些非空闲的日子会以一个单调递增序列 $b$ 的形式给出。即，对于任意的 $i(1\\leq i<m)$，满足 $b_i<b_{i+1}$。\n\n莲子希望完成任务的时间越短越好。例如：不妨假设，莲子要完成 $2$ 项任务，第一项耗时 $2$ 天，第二项耗时 $3$ 天，而第 $4$ 天莲子有事情要去做。则下图呈现了一种方案，使得莲子完成任务的时间尽可能短，为 $7$ 天：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bdiupoc1.png)\n\n她想要知道，在最好情况下，她能在第几天结束后完成所有任务。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个正整数描述序列 $a$。\n\n第三行 $m$ 个正整数描述序列 $b$。保证 $b$ 为单调递增序列。", "outputFormat": "一行一个整数，表示莲子最快能在第几天结束后完成所有任务。", "hint": "### 样例解释\n\n#### 样例 \\#1\n\n即在题面中提及的情况。莲子在第 $1$ 天开始第一项任务，在第 $2$ 天结束后完成第一项任务。由于第 $4$ 天有事，她不能从第 $3$ 天开始第二项任务，于是她只好从第 $5$ 天开始该任务，在第 $7$ 天结束时完成全部任务。\n\n注意到该样例符合 $\\textbf{Subtask 2}$ 的特殊性质。\n#### 样例 \\#2\n\n莲子在第 $2$ 至第 $4$ 天**依次**完成了所有任务。\n\n### 数据范围\n\n**本题采用捆绑测试。每一个 Subtask 内的测试点均需通过才能获得该 Subtask 的分数。**\n\n简记：$\\sum a_i$ 为所有 $a_i$ 的和，即 $a_1+a_2+\\dots+a_n$。其他试题中若无特殊说明也以此解释为准。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{\\textsf{分值}} & \\bm{n,m\\le } & \\bm{\\sum a_i\\le} & \\bm{b_i\\le} & \\textbf{\\textsf{特殊性质}}&\\textbf{Subtask \\textsf{依赖}}\\cr\\hline\n1 & 20 & 10 & 100 & 100 & - &-\\cr\\hline\n2 & 20 & 10^5 & 10^8 & 10^8 & m=1&- \\cr\\hline\n3 & 20 & 10^3 & 10^8 & 10^8 & \\mathbf{-}&-  \\cr\\hline\n4 & 40 & 10^5 & 10^8 &  10^8& -&1,2,3 \\cr\\hline\n\\end{array}\n$$\n\n对于所有数据满足：$1\\le n,m\\le 10^5$，$1\\le a_i \\le \\sum a_i\\le 10^8$, $1\\le b_i\\le 10^8$，$b$ 为单调递增序列。", "locale": "zh-CN"}}}
{"pid": "P10606", "type": "P", "difficulty": 1, "samples": [["3 1\n1 2 3\n2 1", "2"], ["5 3\n5 2 3 4 5\n2 1\n3 2\n3 1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "洛谷原创", "O2优化", "洛谷月赛"], "title": "物理实验 (easy)", "background": "莲子为了完善她的论文，决定研究一些物体的物理性质。由于工作实在是太多，她邀请你帮忙完成其中的一个小实验。", "description": "**这是该题的简单版本，两个版本之间的区别在于小球需要满足的条件不同。该题的满分为 50 分。**\n\n莲子有一个初始在数轴 $0$ 点并向数轴正方向移动的小球。她在数轴的 $1$ 到 $n$ 这 $n$ 个点上设置了装置，当小球经过点 $i$ 时，她可以花费 $a_i$ 的代价让其改变移动方向（从数轴正方向切换为负方向，或者相反）。\n\n莲子有 $m$ 个需要满足的条件，第 $i$ 个条件形如“小球需要从点 $x_i$ 移动到点 $y_i$ 至少一次”，**其中** $x_i$ **大于** $y_i$。更详细的说，该条件即要求小球的移动路径形如 $\\ldots \\to x_i\\to\\ldots\\to y_i\\to\\ldots$。\n\n莲子想要知道她至少要花费多少代价才能满足所有条件。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个正整数描述序列 $a$。\n\n接下来 $m$ 行中，第 $i$ 行依次给出两个正整数表示 $x_i$ 和 $y_i$。", "outputFormat": "一行一个整数，表示莲子至少要花费多少代价才能满足所有条件。", "hint": "### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bu9fbcw9.png)\n\n如图所示给出了两个样例的移动路线。数轴上方的是在每个点转向的代价，下方的是坐标。\n\n#### 样例 \\#1\n\n莲子让小球在经过点 $2$ 时反转方向恰好能满足所有条件，总花费代价为 $2$。\n#### 样例 \\#2\n\n莲子让小球在经过点 $3$ 时反转方向恰好能满足所有条件，总花费代价为 $3$。\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{\\textsf{分值}} & \\bm{n,m\\le } & \\bm{a_i\\le} & \\bm{x_i,y_i\\le} & \\textbf{\\textsf{特殊性质}}&\\textbf{Subtask \\textsf{依赖}}\\cr\\hline\n1 & 10 & 10 & 100 & 10 & - &-\\cr\\hline\n2 & 10 & 10^3 & 10^8 & 10^3 & -&1 \\cr\\hline\n3 & 30 & 2\\times 10^5 & 10^8 & 2\\times 10^5 & -&1,2  \\cr\\hline\n\\end{array}\n$$\n\n对于所有数据满足：$1\\le n,m\\le 2\\times 10^5$，$1\\le a_i\\le 10^8$，$1\\le y_i< x_i \\le n\\le 2\\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Physics Experiment (Easy)", "background": "To refine her paper, Renko decides to study the physical properties of objects. Due to the overwhelming workload, she invites you to assist with a small experiment.", "description": "**This is the easy version of the problem. The difference between the two versions lies in the conditions the ball must satisfy. The full score for this version is 50 points.**\n\nRenko has a small ball initially at position $0$ on the number line and moving in the positive direction. She sets up devices at points $1$ to $n$ on the number line. When the ball passes through point $i$, she can pay a cost of $a_i$ to reverse its direction (from positive to negative, or vice versa).\n\nRenko has $m$ conditions to satisfy. The $i$-th condition states that \"the ball must move from point $x_i$ to point $y_i$ at least once,\" **where** $x_i$ **is greater than** $y_i$. More precisely, this condition requires the ball's path to include a segment like $\\ldots \\to x_i \\to \\ldots \\to y_i \\to \\ldots$.\n\nRenko wants to determine the minimum total cost required to satisfy all conditions.", "inputFormat": "- The first line contains two integers $n$ and $m$.\n- The second line contains $n$ positive integers describing the sequence $a$.\n- The next $m$ lines each contain two positive integers $x_i$ and $y_i$.", "outputFormat": "Output one integer: the minimum total cost required to satisfy all conditions.", "hint": "### Explanation\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bu9fbcw9.png)\n\nThe figure above illustrates the movement paths for both samples. The numbers above the number line represent the reversal costs at each point, and the numbers below are coordinates.\n\n#### Sample #1\n\nRenko reverses the ball's direction when it passes point $2$, satisfying all conditions with a total cost of $2$.\n\n#### Sample #2\n\nRenko reverses the ball's direction when it passes point $3$, satisfying all conditions with a total cost of $3$.\n\n### Constraints\n\n**Bundled testing is used.**\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{Points} & \\bm{n,m \\leq} & \\bm{a_i \\leq} & \\bm{x_i,y_i \\leq} & \\textbf{Special Property} & \\textbf{Subtask Dependencies} \\cr\\hline\n1 & 10 & 10 & 100 & 10 & - & - \\cr\\hline\n2 & 10 & 10^3 & 10^8 & 10^3 & - & 1 \\cr\\hline\n3 & 30 & 2 \\times 10^5 & 10^8 & 2 \\times 10^5 & - & 1,2 \\cr\\hline\n\\end{array}\n$$\n\nFor all data: $1 \\leq n, m \\leq 2 \\times 10^5$, $1 \\leq a_i \\leq 10^8$, $1 \\leq y_i < x_i \\leq n \\leq 2 \\times 10^5$.\n\n---\n\nTranslated by DeepSeek R1", "locale": "en"}, "zh-CN": {"title": "物理实验 (easy)", "background": "莲子为了完善她的论文，决定研究一些物体的物理性质。由于工作实在是太多，她邀请你帮忙完成其中的一个小实验。", "description": "**这是该题的简单版本，两个版本之间的区别在于小球需要满足的条件不同。该题的满分为 50 分。**\n\n莲子有一个初始在数轴 $0$ 点并向数轴正方向移动的小球。她在数轴的 $1$ 到 $n$ 这 $n$ 个点上设置了装置，当小球经过点 $i$ 时，她可以花费 $a_i$ 的代价让其改变移动方向（从数轴正方向切换为负方向，或者相反）。\n\n莲子有 $m$ 个需要满足的条件，第 $i$ 个条件形如“小球需要从点 $x_i$ 移动到点 $y_i$ 至少一次”，**其中** $x_i$ **大于** $y_i$。更详细的说，该条件即要求小球的移动路径形如 $\\ldots \\to x_i\\to\\ldots\\to y_i\\to\\ldots$。\n\n莲子想要知道她至少要花费多少代价才能满足所有条件。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个正整数描述序列 $a$。\n\n接下来 $m$ 行中，第 $i$ 行依次给出两个正整数表示 $x_i$ 和 $y_i$。", "outputFormat": "一行一个整数，表示莲子至少要花费多少代价才能满足所有条件。", "hint": "### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bu9fbcw9.png)\n\n如图所示给出了两个样例的移动路线。数轴上方的是在每个点转向的代价，下方的是坐标。\n\n#### 样例 \\#1\n\n莲子让小球在经过点 $2$ 时反转方向恰好能满足所有条件，总花费代价为 $2$。\n#### 样例 \\#2\n\n莲子让小球在经过点 $3$ 时反转方向恰好能满足所有条件，总花费代价为 $3$。\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{\\textsf{分值}} & \\bm{n,m\\le } & \\bm{a_i\\le} & \\bm{x_i,y_i\\le} & \\textbf{\\textsf{特殊性质}}&\\textbf{Subtask \\textsf{依赖}}\\cr\\hline\n1 & 10 & 10 & 100 & 10 & - &-\\cr\\hline\n2 & 10 & 10^3 & 10^8 & 10^3 & -&1 \\cr\\hline\n3 & 30 & 2\\times 10^5 & 10^8 & 2\\times 10^5 & -&1,2  \\cr\\hline\n\\end{array}\n$$\n\n对于所有数据满足：$1\\le n,m\\le 2\\times 10^5$，$1\\le a_i\\le 10^8$，$1\\le y_i< x_i \\le n\\le 2\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P10607", "type": "P", "difficulty": 3, "samples": [["3 1\n1 2 3\n2 1 3", "8"], ["5 3\n5 2 3 4 5\n2 1 1\n3 2 2\n3 1 1", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "洛谷原创", "O2优化", "洛谷月赛"], "title": "物理实验 (hard)", "background": "莲子为了完善她的论文，决定研究一些物体的物理性质。由于工作实在是太多，她邀请你帮忙完成其中的一个小实验。不过，这次的略微困难一些。", "description": "**这是该题的困难版本，两个版本之间的区别在于小球需要满足的条件不同。该题的满分为 50 分。**\n\n莲子有一个初始在数轴 $0$ 点并向数轴正方向移动的小球。莲子在数轴的 $1$ 到 $n$ 这 $n$ 个点上设置了装置，当小球经过点 $i$ 时，她可以花费 $a_i$ 的代价让其改变移动方向（从数轴正方向切换为负方向，或者相反）。\n\n莲子有 $m$ 个需要满足的条件，第 $i$ 个条件形如“小球需要从点 $x_i$ 移动到点 $y_i$ 至少 $k_i$ 次”，**其中** $x_i$ **大于** $y_i$。更详细的说，该条件即要求小球的移动路径形如 $\\ldots\\to x_i\\to\\ldots\\to y_i\\to\\ldots\\to x_i\\to\\ldots\\to y_i\\to\\ldots$，其中从 $x_i$ 移动到 $y_i$ 的过程重复至少 $k_i$ 次。\n\n莲子想要知道她至少要花费多少代价才能满足所有条件。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个正整数描述序列 $a$。\n\n接下来 $m$ 行中，第 $i$ 行依次给出三个正整数表示 $x_i$, $y_i$ 和 $k_i$。", "outputFormat": "一行一个整数，表示莲子至少要花费多少代价才能满足所有条件。", "hint": "### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x2aotk1i.png)\n\n上图画出了样例 1 和样例 2 的具体构造方案，可供参考。\n\n#### 样例 \\#1\n\n莲子让小球在经过点 $2$ 时反转方向，然后让其经过点 $1$ 时再反转方向。重复上述操作两次，最后再在点 $2$ 反转方向恰好能满足所有条件。总花费代价为 $8$。\n\n注意到该样例符合特殊性质 $\\mathbf{A}$。\n#### 样例 \\#2\n\n莲子让小球依次在经过点 $3$、点 $2$、点 $3$ 时反转方向。总花费代价为 $8$。\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{\\textsf{分值}} & \\bm{n,m\\le } & \\bm{a_i\\le} & \\bm{x_i,y_i\\le} & \\bm{k_i\\le} & \\textbf{\\textsf{特殊性质}}&\\textbf{Subtask \\textsf{依赖}}\\cr\\hline\n1 & 10 & 10 & 100 & 10 & 10 & - &-\\cr\\hline\n2 & 5 & 2\\times 10^5 & 10^8 & 2\\times 10^5 & 10^8 & \\mathbf{A}&- \\cr\\hline\n3 & 15 & 10^3 & 10^8 & 10^3 & 10^5 & -&1 \\cr\\hline\n4 & 20 & 2\\times 10^5 & 10^8 & 2\\times 10^5 & 10^8 & -&1,2,3  \\cr\\hline\n\\end{array}\n$$\n\n特殊性质 $\\mathbf{A}$：所有的 $k_i$ 均相等。\n\n对于所有数据满足：$1\\le n,m\\le 2\\times 10^5$，$1\\le a_i\\le 10^8$，$1\\le y_i< x_i \\le n\\le 2\\times 10^5$，$1\\le k_i\\le 10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "Physics Experiment (Hard)", "background": "To refine her paper, Renko decides to study the physical properties of objects. Due to the overwhelming workload, she invites you to assist with a small experiment. However, this one is slightly more challenging.", "description": "**This is the hard version of the problem. The difference between the two versions lies in the conditions the ball must satisfy. The full score for this version is 50 points.**\n\nRenko has a small ball initially at position $0$ on the number line and moving in the positive direction. She sets up devices at points $1$ to $n$ on the number line. When the ball passes through point $i$, she can pay a cost of $a_i$ to reverse its direction (from positive to negative, or vice versa).\n\nRenko has $m$ conditions to satisfy. The $i$-th condition states that \"the ball must move from point $x_i$ to point $y_i$ at least $k_i$ times,\" **where** $x_i$ **is greater than** $y_i$. More precisely, this condition requires the ball's path to include segments like $\\ldots \\to x_i \\to \\ldots \\to y_i \\to \\ldots \\to x_i \\to \\ldots \\to y_i \\to \\ldots$, with the movement from $x_i$ to $y_i$ repeated at least $k_i$ times.\n\nRenko wants to determine the minimum total cost required to satisfy all conditions.", "inputFormat": "- The first line contains two integers $n$ and $m$.\n- The second line contains $n$ positive integers describing the sequence $a$.\n- The next $m$ lines each contain three positive integers $x_i$, $y_i$, and $k_i$.", "outputFormat": "Output one integer: the minimum total cost required to satisfy all conditions.", "hint": "### Explanation\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x2aotk1i.png)\n\nThe figure above illustrates the movement paths for both samples. Refer to it for specific construction details.\n\n#### Sample #1\n\nRenko reverses the ball's direction when it passes point $2$, then reverses it again at point $1$. Repeating this operation twice and finally reversing at point $2$ satisfies all conditions. The total cost is $8$.\n\nThis sample satisfies **Special Property A**.\n\n#### Sample #2\n\nRenko reverses the ball's direction sequentially at points $3$, $2$, and $3$. The total cost is $8$.\n\n### Constraints\n\n**Bundled testing is used.**\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{Points} & \\bm{n,m \\leq} & \\bm{a_i \\leq} & \\bm{x_i,y_i \\leq} & \\bm{k_i \\leq} & \\textbf{Special Property} & \\textbf{Subtask Dependencies} \\cr\\hline\n1 & 10 & 10 & 100 & 10 & 10 & - & - \\cr\\hline\n2 & 5 & 2 \\times 10^5 & 10^8 & 2 \\times 10^5 & 10^8 & \\mathbf{A} & - \\cr\\hline\n3 & 15 & 10^3 & 10^8 & 10^3 & 10^5 & - & 1 \\cr\\hline\n4 & 20 & 2 \\times 10^5 & 10^8 & 2 \\times 10^5 & 10^8 & - & 1,2,3 \\cr\\hline\n\\end{array}\n$$\n\n**Special Property A**: All $k_i$ are equal.\n\nFor all data: $1 \\leq n, m \\leq 2 \\times 10^5$, $1 \\leq a_i \\leq 10^8$, $1 \\leq y_i < x_i \\leq n \\leq 2 \\times 10^5$, $1 \\leq k_i \\leq 10^8$.\n\n---\n\nTranslated by DeepSeek R1", "locale": "en"}, "zh-CN": {"title": "物理实验 (hard)", "background": "莲子为了完善她的论文，决定研究一些物体的物理性质。由于工作实在是太多，她邀请你帮忙完成其中的一个小实验。不过，这次的略微困难一些。", "description": "**这是该题的困难版本，两个版本之间的区别在于小球需要满足的条件不同。该题的满分为 50 分。**\n\n莲子有一个初始在数轴 $0$ 点并向数轴正方向移动的小球。莲子在数轴的 $1$ 到 $n$ 这 $n$ 个点上设置了装置，当小球经过点 $i$ 时，她可以花费 $a_i$ 的代价让其改变移动方向（从数轴正方向切换为负方向，或者相反）。\n\n莲子有 $m$ 个需要满足的条件，第 $i$ 个条件形如“小球需要从点 $x_i$ 移动到点 $y_i$ 至少 $k_i$ 次”，**其中** $x_i$ **大于** $y_i$。更详细的说，该条件即要求小球的移动路径形如 $\\ldots\\to x_i\\to\\ldots\\to y_i\\to\\ldots\\to x_i\\to\\ldots\\to y_i\\to\\ldots$，其中从 $x_i$ 移动到 $y_i$ 的过程重复至少 $k_i$ 次。\n\n莲子想要知道她至少要花费多少代价才能满足所有条件。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个正整数描述序列 $a$。\n\n接下来 $m$ 行中，第 $i$ 行依次给出三个正整数表示 $x_i$, $y_i$ 和 $k_i$。", "outputFormat": "一行一个整数，表示莲子至少要花费多少代价才能满足所有条件。", "hint": "### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x2aotk1i.png)\n\n上图画出了样例 1 和样例 2 的具体构造方案，可供参考。\n\n#### 样例 \\#1\n\n莲子让小球在经过点 $2$ 时反转方向，然后让其经过点 $1$ 时再反转方向。重复上述操作两次，最后再在点 $2$ 反转方向恰好能满足所有条件。总花费代价为 $8$。\n\n注意到该样例符合特殊性质 $\\mathbf{A}$。\n#### 样例 \\#2\n\n莲子让小球依次在经过点 $3$、点 $2$、点 $3$ 时反转方向。总花费代价为 $8$。\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{\\textsf{分值}} & \\bm{n,m\\le } & \\bm{a_i\\le} & \\bm{x_i,y_i\\le} & \\bm{k_i\\le} & \\textbf{\\textsf{特殊性质}}&\\textbf{Subtask \\textsf{依赖}}\\cr\\hline\n1 & 10 & 10 & 100 & 10 & 10 & - &-\\cr\\hline\n2 & 5 & 2\\times 10^5 & 10^8 & 2\\times 10^5 & 10^8 & \\mathbf{A}&- \\cr\\hline\n3 & 15 & 10^3 & 10^8 & 10^3 & 10^5 & -&1 \\cr\\hline\n4 & 20 & 2\\times 10^5 & 10^8 & 2\\times 10^5 & 10^8 & -&1,2,3  \\cr\\hline\n\\end{array}\n$$\n\n特殊性质 $\\mathbf{A}$：所有的 $k_i$ 均相等。\n\n对于所有数据满足：$1\\le n,m\\le 2\\times 10^5$，$1\\le a_i\\le 10^8$，$1\\le y_i< x_i \\le n\\le 2\\times 10^5$，$1\\le k_i\\le 10^8$。", "locale": "zh-CN"}}}
{"pid": "P10608", "type": "P", "difficulty": 4, "samples": [["3 2\nB__\nR 3\nM 2", "2\n"], ["3 3\n___\nR 1 \nR 3\nM 2", "2"], ["5 2\nBW__B\nR 4\nR 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["博弈论", "洛谷原创", "O2优化", "洛谷月赛"], "title": "双人游戏", "background": "写完论文的莲子终于意识到了这么多天埋头写论文而不理会梅莉的错误，并打算约梅莉出来玩。为此，她构思了一个有趣的双人游戏。", "description": "莲子构思了一个双人游戏，不妨令游戏的两个玩家为小 R 和小 M，规则如下：\n\n有一个 $1\\times n$ 的棋盘。初始时，棋盘上有一些黑色棋子，一些白色棋子，和 $m$ 个空格子。我们可以用一个长度为 $n$ 的字符串 $s$ 来描述初始时的棋盘，若 $s_i$ 为 `B` 则代表该位置为黑棋子，为 `W` 则代表白棋子，为 `_` 则代表空格子。**请注意，棋盘上可能没有空格子。**\n\n游戏开始前，除了棋盘的初始状态，两人还会获得一个操作序列 $O=[\\lang c_1,x_1\\rang, \\lang c_2,x_2\\rang, \\cdots,\\lang c_m,x_m\\rang]$，其中二元组 $\\lang c_i,x_i\\rang$ 满足 $c_i\\in\\{\\mathtt{R}, \\mathtt{M}\\}$ 且 $x_i$ 位置此时是一个空格子，表示在第 $i$ 步，玩家小 $c_i$ 应该在 $x_i$ 位置放上一个黑色棋子或者白色棋子。序列 $O$ 对双方公开，也就是说双方均知道每一步是由谁在哪个位置放上一枚棋子。\n\n游戏过程中，双方会按照该操作序列进行操作。第 $i$ 轮时小 $c_i$ 在 $x_i$ 位置放置一枚棋子，棋子的颜色由该玩家决定。在游戏结束时所有格子都被放上了恰好一枚棋子。\n\n小 R 希望游戏结束后棋子组成的**极长同色连续段数**$^*$尽可能多，而小 M 则希望其尽可能少。试着求出两人都以最优方式摆放棋子的话最后的连续段数为几。容易证明答案是一个定值。\n\n注：一个棋子的极长同色连续段被定义为一个二元组 $(l,r)$ 满足 $l\\le r$，且从左至右数第 $l$ 个棋子到第 $r$ 个棋子颜色相同，且第 $l-1$ 个和第 $r+1$ 个棋子要么不存在，要么与前面所说的棋子颜色不同。", "inputFormat": "第一行两个整数 $n,m$，其中 $m$ 代表棋盘上的空格子数量。\n\n第二行一个长度为 $n$ 的字符串 $s$，描述棋盘的每个格子的状态。\n\n对于接下来的 $m$ 行：第 $i$ 行一个字符 $c_i$ 和一个正整数 $x_i$，描述第 $i$ 回合操作的玩家和她放置棋子的位置。", "outputFormat": "输出一行一个整数，表示两人都以最优方式摆放棋子的话最后的连续段数为几。", "hint": "### 样例解释\n\n#### 样例 \\#1\n\n最终的棋子摆放结果为 `BWW`，可以证明两人这样摆均为最优。极长连续段数为 $2$。\n#### 样例 \\#2\n\n为了让连续段数尽可能大，先手摆放两个空格子的小 R 一定会让两个格子的棋子颜色不同。然后小 M 会放置一个任意颜色的棋子。有多种可能的最终摆放结果，其中一种为 `BWW`，极长连续段数为 $2$。\n\n注意到该样例符合特殊性质 $\\mathbf{B}$。\n#### 样例 \\#3\n\n最终的棋子摆放结果为 `BWBWB`，极长连续段数为 $5$。\n\n注意到该样例符合特殊性质 $\\mathbf{A}$。\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{\\textsf{分值}} & \\bm{n,m\\le } & \\textbf{\\textsf{特殊性质}}&\\textbf{Subtask \\textsf{依赖}}\\cr\\hline\n1 & 10 & 20 & - &-\\cr\\hline\n2 & 10 & 2\\times 10^5 & \\mathbf{A}&- \\cr\\hline\n3 & 20 & 2\\times 10^5 & \\mathbf{B}&- \\cr\\hline\n4 & 20 & 10^3 & -&1  \\cr\\hline\n5 & 40 & 2\\times 10^5 & -&1,2,3,4  \\cr\\hline\n\\end{array}\n$$\n\n特殊性质 $\\mathbf{A}$：保证要么 $c_i$ 均为 $\\tt R$，要么 $c_i$ 均为 $\\tt M$。\\\n特殊性质 $\\mathbf{B}$：保证 $s$ 中所有字母均为 $\\tt \\_$。\n\n对于所有数据满足：$\\red0\\le m\\le 2\\times 10^5 $，$1\\le n\\le 2\\times 10^5$，且有 $m\\le n$，$s_i\\in \\{\\tt{B,W,\\_}\\}$。", "locale": "zh-CN", "translations": {"en": {"title": "Two-Player Game", "background": "After finishing her paper, Renko finally realizes her mistake of burying herself in work and ignoring Merry for so long. She decides to invite Merry out and devises an interesting two-player game.", "description": "Renko has designed a two-player game with two players, Little R and Little M, following these rules:\n\nThere is a $1 \\times n$ chessboard. Initially, the board has some black pieces, white pieces, and $m$ empty cells. The initial state of the board is described by a string $s$ of length $n$, where:\n- `B` indicates a black piece,\n- `W` indicates a white piece,\n- `_` indicates an empty cell.  \n**Note: The board may have no empty cells.**\n\nBefore the game starts, both players receive an operation sequence $O = [\\langle c_1, x_1 \\rangle, \\langle c_2, x_2 \\rangle, \\ldots, \\langle c_m, x_m \\rangle]$, where each pair $\\langle c_i, x_i \\rangle$ satisfies:\n- $c_i \\in \\{\\mathtt{R}, \\mathtt{M}\\}$,\n- $x_i$ is an empty cell at step $i$.  \n\nThis sequence is public, meaning both players know who will place a piece and where at each step.\n\nDuring the game, players follow the operation sequence. In the $i$-th step, player $c_i$ places a piece (black or white, chosen by the player) at position $x_i$. By the end of the game, every cell will have exactly one piece.\n\nLittle R aims to **maximize** the number of **maximal consecutive monochromatic segments**$^*$, while Little M aims to **minimize** it. Determine the final number of segments when both play optimally. It can be proven that the answer is unique.\n\n**Definition**: A maximal consecutive monochromatic segment is a pair $(l, r)$ where $l \\leq r$, such that:\n- All pieces from the $l$-th to $r$-th position are the same color.\n- The $(l-1)$-th piece (if exists) and the $(r+1)$-th piece (if exists) are of a different color.", "inputFormat": "- The first line contains two integers $n$ and $m$, where $m$ is the number of empty cells.\n- The second line contains a string $s$ of length $n$, describing the initial board state.\n- The next $m$ lines each contain a character $c_i$ and an integer $x_i$, describing the player and the position for the $i$-th step.", "outputFormat": "Output one integer: the number of maximal consecutive monochromatic segments when both players act optimally.", "hint": "### Explanation\n\n#### Sample #1\n\nThe final board is `BWW`, which is optimal for both players. The number of segments is $2$.\n\n#### Sample #2\n\nLittle R (controlling the first two steps) will place different colors to maximize segments. Little M then places any color. One possible final state is `BWW` with $2$ segments.  \nThis sample satisfies **Special Property B**.\n\n#### Sample #3\n\nThe final board is `BWBWB` with $5$ segments.  \nThis sample satisfies **Special Property A**.\n\n### Constraints\n\n**Bundled testing is used.**\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{Points} & \\bm{n,m \\leq} & \\textbf{Special Property} & \\textbf{Subtask Dependencies} \\cr\\hline\n1 & 10 & 20 & - & - \\cr\\hline\n2 & 10 & 2 \\times 10^5 & \\mathbf{A} & - \\cr\\hline\n3 & 20 & 2 \\times 10^5 & \\mathbf{B} & - \\cr\\hline\n4 & 20 & 10^3 & - & 1 \\cr\\hline\n5 & 40 & 2 \\times 10^5 & - & 1,2,3,4 \\cr\\hline\n\\end{array}\n$$\n\n**Special Properties**:\n- **A**: All $c_i$ are either `R` or `M`.\n- **B**: All characters in $s$ are `_`.\n\nFor all data: $0 \\leq m \\leq 2 \\times 10^5$, $1 \\leq n \\leq 2 \\times 10^5$, $m \\leq n$, and $s_i \\in \\{\\mathtt{B}, \\mathtt{W}, \\mathtt{\\_}\\}$.\n\n---\n\nTranslated by DeepSeek R1", "locale": "en"}, "zh-CN": {"title": "双人游戏", "background": "写完论文的莲子终于意识到了这么多天埋头写论文而不理会梅莉的错误，并打算约梅莉出来玩。为此，她构思了一个有趣的双人游戏。", "description": "莲子构思了一个双人游戏，不妨令游戏的两个玩家为小 R 和小 M，规则如下：\n\n有一个 $1\\times n$ 的棋盘。初始时，棋盘上有一些黑色棋子，一些白色棋子，和 $m$ 个空格子。我们可以用一个长度为 $n$ 的字符串 $s$ 来描述初始时的棋盘，若 $s_i$ 为 `B` 则代表该位置为黑棋子，为 `W` 则代表白棋子，为 `_` 则代表空格子。**请注意，棋盘上可能没有空格子。**\n\n游戏开始前，除了棋盘的初始状态，两人还会获得一个操作序列 $O=[\\lang c_1,x_1\\rang, \\lang c_2,x_2\\rang, \\cdots,\\lang c_m,x_m\\rang]$，其中二元组 $\\lang c_i,x_i\\rang$ 满足 $c_i\\in\\{\\mathtt{R}, \\mathtt{M}\\}$ 且 $x_i$ 位置此时是一个空格子，表示在第 $i$ 步，玩家小 $c_i$ 应该在 $x_i$ 位置放上一个黑色棋子或者白色棋子。序列 $O$ 对双方公开，也就是说双方均知道每一步是由谁在哪个位置放上一枚棋子。\n\n游戏过程中，双方会按照该操作序列进行操作。第 $i$ 轮时小 $c_i$ 在 $x_i$ 位置放置一枚棋子，棋子的颜色由该玩家决定。在游戏结束时所有格子都被放上了恰好一枚棋子。\n\n小 R 希望游戏结束后棋子组成的**极长同色连续段数**$^*$尽可能多，而小 M 则希望其尽可能少。试着求出两人都以最优方式摆放棋子的话最后的连续段数为几。容易证明答案是一个定值。\n\n注：一个棋子的极长同色连续段被定义为一个二元组 $(l,r)$ 满足 $l\\le r$，且从左至右数第 $l$ 个棋子到第 $r$ 个棋子颜色相同，且第 $l-1$ 个和第 $r+1$ 个棋子要么不存在，要么与前面所说的棋子颜色不同。", "inputFormat": "第一行两个整数 $n,m$，其中 $m$ 代表棋盘上的空格子数量。\n\n第二行一个长度为 $n$ 的字符串 $s$，描述棋盘的每个格子的状态。\n\n对于接下来的 $m$ 行：第 $i$ 行一个字符 $c_i$ 和一个正整数 $x_i$，描述第 $i$ 回合操作的玩家和她放置棋子的位置。", "outputFormat": "输出一行一个整数，表示两人都以最优方式摆放棋子的话最后的连续段数为几。", "hint": "### 样例解释\n\n#### 样例 \\#1\n\n最终的棋子摆放结果为 `BWW`，可以证明两人这样摆均为最优。极长连续段数为 $2$。\n#### 样例 \\#2\n\n为了让连续段数尽可能大，先手摆放两个空格子的小 R 一定会让两个格子的棋子颜色不同。然后小 M 会放置一个任意颜色的棋子。有多种可能的最终摆放结果，其中一种为 `BWW`，极长连续段数为 $2$。\n\n注意到该样例符合特殊性质 $\\mathbf{B}$。\n#### 样例 \\#3\n\n最终的棋子摆放结果为 `BWBWB`，极长连续段数为 $5$。\n\n注意到该样例符合特殊性质 $\\mathbf{A}$。\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{\\textsf{分值}} & \\bm{n,m\\le } & \\textbf{\\textsf{特殊性质}}&\\textbf{Subtask \\textsf{依赖}}\\cr\\hline\n1 & 10 & 20 & - &-\\cr\\hline\n2 & 10 & 2\\times 10^5 & \\mathbf{A}&- \\cr\\hline\n3 & 20 & 2\\times 10^5 & \\mathbf{B}&- \\cr\\hline\n4 & 20 & 10^3 & -&1  \\cr\\hline\n5 & 40 & 2\\times 10^5 & -&1,2,3,4  \\cr\\hline\n\\end{array}\n$$\n\n特殊性质 $\\mathbf{A}$：保证要么 $c_i$ 均为 $\\tt R$，要么 $c_i$ 均为 $\\tt M$。\\\n特殊性质 $\\mathbf{B}$：保证 $s$ 中所有字母均为 $\\tt \\_$。\n\n对于所有数据满足：$\\red0\\le m\\le 2\\times 10^5 $，$1\\le n\\le 2\\times 10^5$，且有 $m\\le n$，$s_i\\in \\{\\tt{B,W,\\_}\\}$。", "locale": "zh-CN"}}}
{"pid": "P10609", "type": "P", "difficulty": 5, "samples": [["2 2 0\n1 0\n1 1\n1 1\n1 1\n\n2\n0", "\n\n\n\n\n1"], ["2 2 0\n2 3\n3 4\n1 1\n1 1\n\n2\n0", "\n\n\n\n\n1\n"], ["2 3 1\n1 -2\n-1 2\n1 2\n2 1\n1\n\n2\n\n0\n", "\n\n\n\n\n\n1\n\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "博弈论", "洛谷原创", "交互题", "Special Judge", "O2优化", "洛谷月赛"], "title": "排除干扰", "background": "其实，莲子有所不知的是，梅莉早在几周前就瞒着她一个人去探险，至今未归。得知了此事的莲子后悔万分。\n\n为了找到失踪的梅莉，莲子独自前去梅莉家寻找线索，但她翻箱倒柜却仍一无所获。\n\n“该怎么办啊！要是能排除干扰，找到有用的线索就好了。对了，那就以梅莉的视角想想吧！”", "description": "**这是一道交互题。**\n\n为了同时从两者的角度思考，莲子在内心构想了一场博弈，而主角则仍是小 R 与小 M，规则如下：\n\n小 R 和小 M 初始均有 $m$ 张牌，牌共有 $n$ 类，编号为 $1$ 到 $n$。**保证她们初始拥有每类牌至少一张**。她们可以互相看见手牌。\n\n小 R 和小 M 轮流弃牌，**其中小 R 为先手**。每回合她们都要丢弃恰好一张牌。当她们均把牌弃到只剩一张时，假设小 R 的牌为 $u$，小 M 的牌为 $v$，那么小 R 获得的分数为 $a_{u,v}$，小 M 获得的分数为 $-a_{u,v}$。她们都希望自己的得分尽可能高。\n\n现在，你需要和交互库模拟一局游戏，若 $c=0$，你将扮演小 R；若 $c=1$，你将扮演小 M。你取得的分数至少需要达到双方均以最优策略决策时所得到的分数。", "inputFormat": "第一行三个整数 $n,m,c$，它们的含义都与题目描述相同。\n\n接下来的 $n$ 行，每行 $n$ 个整数，描述矩阵 $a$。第 $i$ 行第 $j$ 列的元素为 $a_{i,j}$。\n\n接下来共两行，每行 $n$ 个整数。对于第一行，其中第 $i$ 个整数 $R_i$ 代表小 R 初始拥有多少张第 $i$ 类的牌。对于第二行，第 $i$ 个整数 $M_i$ 代表小 M 初始拥有多少张第 $i$ 类的牌。保证有 $\\sum R_i=\\sum M_i=m$。\n\n接下来进入交互过程：\n\n1. 如果轮到对手（交互库）操作，你可以读入一个正整数 $x$，代表对手该回合丢弃了一张第 $x$ 类的牌。\n2. 如果轮到你操作，你需要输出一个正整数 $y$，代表你该回合丢弃了一张第 $y$ 类的牌。\n3. 如果游戏结束（两人均只剩一张牌）且你取得的分数不是最优/你进行了不合法的操作，你需要读入一个 `-1` 后退出程序。\n4. 如果游戏结束且你取得的分数是最优，你需要读入一个 `0` 后退出程序。\n\n**注意：在交互过程中，你需要在输出后刷新缓存区，下面是一些常见语言的刷新缓存区方式：**\n\n- C++：`fflush(stdout)` 或 `cout.flush()`。\n- C: `fflush(stdout)`。\n- Java: `System.out.flush()`。\n- Python: `stdout.flush()`。\n- Pascal: `flush(output)`。\n- 其他语言：请参考对应语言的帮助文档。", "outputFormat": "见「输入格式」。", "hint": "### 样例解释\n\n#### 样例 \\#1\n\n你将扮演小 R（先手）游玩。假设你丢弃一张 $1$ 类牌，对手丢弃一张 $2$ 类牌，最终你的得分即为 $1$。可以证明，得分 $1$ 即为最优得分。\n\n注意到该样例同时符合特殊性质 $\\mathbf{B}$ 和 $\\mathbf{C}$。\n#### 样例 \\#2\n\n你将扮演小 R（先手）游玩。可以证明，最终小 R 的得分 $3$ 即为最优得分。\n\n注意到该样例符合特殊性质 $\\mathbf{A}$。\n#### 样例 \\#3\n\n你将扮演小 M（后手）游玩。可以证明，最终小 M 的得分 $1$ 即为最优得分。\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{\\textsf{分值}} & \\bm{n\\le} & \\bm{m\\le} & \\textbf{\\textsf{特殊性质}}&\\textbf{Subtask \\textsf{依赖}}\\cr\\hline\n1 & 20 & 5 & 5 & - &-\\cr\\hline\n2 & 15 & 10^3 & 10^4 & \\mathbf{A}&- \\cr\\hline\n3 & 20 & 10^3 & 10^4 & \\mathbf{B}&- \\cr\\hline\n4 & 20 & 10^3 & 10^3 & \\mathbf C&-  \\cr\\hline\n5 & 25 & 10^3 & 10^4 & -&1,2,3,4  \\cr\\hline\n\\end{array}\n$$\n\n特殊性质 $\\mathbf{A}$：保证 $a_{i,j}=i+j$。\\\n特殊性质 $\\mathbf{B}$：保证 $a$ 中只出现 $0$ 和 $1$。\\\n特殊性质 $\\mathbf{C}$：保证每人初始拥有每类牌恰好一张。\n\n对于所有数据满足：$1\\le n\\le 10^3$，$1\\le m\\le 10^4$，$0\\le |a_{i,j}|\\le 10^8$，$1\\le R_i,M_i \\le m$ 且 $\\sum R_i = \\sum M_i = m$。保证交互库进行的操作均合法。", "locale": "zh-CN", "translations": {"en": {"title": "Eliminate Interference", "background": "Unbeknownst to Renko, Merry had secretly gone on an adventure weeks ago and had not returned. Upon learning this, Renko was filled with regret.\n\nTo find the missing Merry, Renko searched for clues at Merry's house but found nothing.  \n\"What should I do? If only I could eliminate the interference and find useful clues. Maybe I should think from Merry's perspective!\"", "description": "**This is an interactive problem.**\n\nTo analyze from both perspectives, Renko imagines a game between Little R and Little M, with the following rules:\n\nBoth Little R and Little M initially have $m$ cards, categorized into $n$ types numbered $1$ to $n$. **Each type has at least one card initially for both players.** They can see each other's cards.\n\nThey take turns discarding cards, **with Little R going first**. Each turn, they discard exactly one card. When both are left with one card each—suppose Little R's card is $u$ and Little M's is $v$—Little R's score is $a_{u,v}$, and Little M's score is $-a_{u,v}$. Both aim to maximize their own scores.\n\nYou will simulate a game with the interactor. If $c=0$, you play as Little R; if $c=1$, you play as Little M. Your score must meet or exceed the optimal score when both play optimally.", "inputFormat": "- The first line contains three integers $n$, $m$, $c$, as described.\n- The next $n$ lines each contain $n$ integers, representing matrix $a$. The $i$-th row and $j$-th column is $a_{i,j}$.\n- The next two lines each contain $n$ integers:  \n  - The first line: $R_i$ denotes Little R's initial count of type $i$ cards.  \n  - The second line: $M_i$ denotes Little M's initial count of type $i$ cards.  \n  It is guaranteed that $\\sum R_i = \\sum M_i = m$.\n\n**Interaction Process**:\n\n1. If it is the opponent's turn (interactor's move), read an integer $x$, indicating they discarded a type $x$ card.\n2. If it is your turn, output an integer $y$, indicating you discard a type $y$ card.\n3. If the game ends (both have one card left) and your score is suboptimal/your move is invalid, read `-1` and exit.\n4. If the game ends and your score is optimal, read `0` and exit.\n\n**Note: After each output, flush the buffer. Common methods include**:\n- C++: `fflush(stdout)` or `cout.flush()`.\n- C: `fflush(stdout)`.\n- Java: `System.out.flush()`.\n- Python: `stdout.flush()`.\n- Pascal: `flush(output)`.\n- Others: Refer to documentation.", "outputFormat": "Follow the interaction rules described above.\n", "hint": "### Explanation\n\n#### Sample #1\n\nYou play as Little R (first to act). If you discard a type $1$ card and the opponent discards type $2$, your score is $1$, which is optimal.  \nThis sample satisfies **Special Properties B and C**.\n\n#### Sample #2\n\nAs Little R, the optimal score is $3$.  \nThis sample satisfies **Special Property A**.\n\n#### Sample #3\n\nYou play as Little M (second to act). The optimal score for Little M is $1$.\n\n### Constraints\n\n**Bundled testing is used.**\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{Points} & \\bm{n \\leq} & \\bm{m \\leq} & \\textbf{Special Property} & \\textbf{Subtask Dependencies} \\cr\\hline\n1 & 20 & 5 & 5 & - & - \\cr\\hline\n2 & 15 & 10^3 & 10^4 & \\mathbf{A} & - \\cr\\hline\n3 & 20 & 10^3 & 10^4 & \\mathbf{B} & - \\cr\\hline\n4 & 20 & 10^3 & 10^3 & \\mathbf{C} & - \\cr\\hline\n5 & 25 & 10^3 & 10^4 & - & 1,2,3,4 \\cr\\hline\n\\end{array}\n$$\n\n**Special Properties**:\n- **A**: $a_{i,j} = i + j$.\n- **B**: $a$ contains only $0$ and $1$.\n- **C**: Each player initially has exactly one card per type.\n\nFor all data:  \n$1 \\leq n \\leq 10^3$, $1 \\leq m \\leq 10^4$, $|a_{i,j}| \\leq 10^8$, $1 \\leq R_i, M_i \\leq m$, $\\sum R_i = \\sum M_i = m$. The interactor's moves are guaranteed valid.\n\n---\n\nTranslated by DeepSeek R1", "locale": "en"}, "zh-CN": {"title": "排除干扰", "background": "其实，莲子有所不知的是，梅莉早在几周前就瞒着她一个人去探险，至今未归。得知了此事的莲子后悔万分。\n\n为了找到失踪的梅莉，莲子独自前去梅莉家寻找线索，但她翻箱倒柜却仍一无所获。\n\n“该怎么办啊！要是能排除干扰，找到有用的线索就好了。对了，那就以梅莉的视角想想吧！”", "description": "**这是一道交互题。**\n\n为了同时从两者的角度思考，莲子在内心构想了一场博弈，而主角则仍是小 R 与小 M，规则如下：\n\n小 R 和小 M 初始均有 $m$ 张牌，牌共有 $n$ 类，编号为 $1$ 到 $n$。**保证她们初始拥有每类牌至少一张**。她们可以互相看见手牌。\n\n小 R 和小 M 轮流弃牌，**其中小 R 为先手**。每回合她们都要丢弃恰好一张牌。当她们均把牌弃到只剩一张时，假设小 R 的牌为 $u$，小 M 的牌为 $v$，那么小 R 获得的分数为 $a_{u,v}$，小 M 获得的分数为 $-a_{u,v}$。她们都希望自己的得分尽可能高。\n\n现在，你需要和交互库模拟一局游戏，若 $c=0$，你将扮演小 R；若 $c=1$，你将扮演小 M。你取得的分数至少需要达到双方均以最优策略决策时所得到的分数。", "inputFormat": "第一行三个整数 $n,m,c$，它们的含义都与题目描述相同。\n\n接下来的 $n$ 行，每行 $n$ 个整数，描述矩阵 $a$。第 $i$ 行第 $j$ 列的元素为 $a_{i,j}$。\n\n接下来共两行，每行 $n$ 个整数。对于第一行，其中第 $i$ 个整数 $R_i$ 代表小 R 初始拥有多少张第 $i$ 类的牌。对于第二行，第 $i$ 个整数 $M_i$ 代表小 M 初始拥有多少张第 $i$ 类的牌。保证有 $\\sum R_i=\\sum M_i=m$。\n\n接下来进入交互过程：\n\n1. 如果轮到对手（交互库）操作，你可以读入一个正整数 $x$，代表对手该回合丢弃了一张第 $x$ 类的牌。\n2. 如果轮到你操作，你需要输出一个正整数 $y$，代表你该回合丢弃了一张第 $y$ 类的牌。\n3. 如果游戏结束（两人均只剩一张牌）且你取得的分数不是最优/你进行了不合法的操作，你需要读入一个 `-1` 后退出程序。\n4. 如果游戏结束且你取得的分数是最优，你需要读入一个 `0` 后退出程序。\n\n**注意：在交互过程中，你需要在输出后刷新缓存区，下面是一些常见语言的刷新缓存区方式：**\n\n- C++：`fflush(stdout)` 或 `cout.flush()`。\n- C: `fflush(stdout)`。\n- Java: `System.out.flush()`。\n- Python: `stdout.flush()`。\n- Pascal: `flush(output)`。\n- 其他语言：请参考对应语言的帮助文档。", "outputFormat": "见「输入格式」。", "hint": "### 样例解释\n\n#### 样例 \\#1\n\n你将扮演小 R（先手）游玩。假设你丢弃一张 $1$ 类牌，对手丢弃一张 $2$ 类牌，最终你的得分即为 $1$。可以证明，得分 $1$ 即为最优得分。\n\n注意到该样例同时符合特殊性质 $\\mathbf{B}$ 和 $\\mathbf{C}$。\n#### 样例 \\#2\n\n你将扮演小 R（先手）游玩。可以证明，最终小 R 的得分 $3$ 即为最优得分。\n\n注意到该样例符合特殊性质 $\\mathbf{A}$。\n#### 样例 \\#3\n\n你将扮演小 M（后手）游玩。可以证明，最终小 M 的得分 $1$ 即为最优得分。\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{\\textsf{分值}} & \\bm{n\\le} & \\bm{m\\le} & \\textbf{\\textsf{特殊性质}}&\\textbf{Subtask \\textsf{依赖}}\\cr\\hline\n1 & 20 & 5 & 5 & - &-\\cr\\hline\n2 & 15 & 10^3 & 10^4 & \\mathbf{A}&- \\cr\\hline\n3 & 20 & 10^3 & 10^4 & \\mathbf{B}&- \\cr\\hline\n4 & 20 & 10^3 & 10^3 & \\mathbf C&-  \\cr\\hline\n5 & 25 & 10^3 & 10^4 & -&1,2,3,4  \\cr\\hline\n\\end{array}\n$$\n\n特殊性质 $\\mathbf{A}$：保证 $a_{i,j}=i+j$。\\\n特殊性质 $\\mathbf{B}$：保证 $a$ 中只出现 $0$ 和 $1$。\\\n特殊性质 $\\mathbf{C}$：保证每人初始拥有每类牌恰好一张。\n\n对于所有数据满足：$1\\le n\\le 10^3$，$1\\le m\\le 10^4$，$0\\le |a_{i,j}|\\le 10^8$，$1\\le R_i,M_i \\le m$ 且 $\\sum R_i = \\sum M_i = m$。保证交互库进行的操作均合法。", "locale": "zh-CN"}}}
{"pid": "P10610", "type": "P", "difficulty": 6, "samples": [["4\n0 1\n1 2\n2 3\n3 4\n1 3 5 9", "3\n3 4 2\n1 2 3 4"], ["5\n0 1\n1 -1\n1 -1\n2 3\n3 4\n1 0 3 0 3", "3\n2 5 3\n1 2 4 3 5"], ["4\n0 1\n1 2\n1 3\n1 4\n1 4 3 3", "1\n2\n1 4 2 3"], ["5\n0 1\n1 1\n1 1\n2 1\n3 1\n1 2 2 2 3", "4\n2 4 5 3\n1 3 5 2 4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "Special Judge", "O2优化", "二分图", "洛谷月赛"], "title": "异界之门", "background": "跟随着线索，莲子来到了七夕坂。无暇欣赏此处的风景，高速运转着大脑的莲子，不断寻找异界的线索。翻转的地藏、奇异的裂缝、被隐匿的第五个季节……这个禁忌之中的世界，正向她揭晓着自己的秘密。\n\n但莲子第一时间看到的只有梅莉，来不及思考，她一把抓住了梅莉的手——", "description": "嗅觉敏锐的莲子察觉到，进入异界的方法一定和这些特别的地藏有所联系。她发现它们恰好构成了一棵形状特殊的树。\n\n给定一棵 $n$ 个点的带点权的**有根**树，其根为 $1$，且点 $i$ 的点权为 $w_i$。**其满足对于任意两个深度相同的结点，它们的儿子数也相同**。\n\n为了进入异界，莲子进行了一些操作来改变这棵树的点权：\n\n1. 选择一条边，假设它连接了两点 $(u,v)$，设其中深度更高者为 $u$（即 $u$ 是 $v$ 的儿子），将 $w_u$ 加上 $w_v$。\n2. 上述操作可以被执行任意多次，但是**不能重复选择同一条边**。\n\n经过操作后，莲子求出了树的某个 [DFS 序列](https://oi-wiki.org/graph/dfs/)，并记录下了这个 DFS 序列所对应的点权序列 $c$（具体来说，$c_i$ 为 DFS 序过程中遍历到的第 $i$ 个点的点权）。\n\n不幸的是，她突然忘记了她进行过哪些操作，也忘记了如何 DFS 这棵树，她希望你能还原出任意一组合法的操作方案与 DFS 序列。", "inputFormat": "第一行一个整数 $n$。\n\n对于接下来 $n$ 行：第 $i$ 行两个整数 $f_i,w_i$，其中 $f_i$ 代表点 $i$ 的父节点（特别的，$f_1=0$，对于其余节点有 $1\\le f_i<i$），$w_i$ 代表点 $i$ 的权值。\n\n接下来一行 $n$ 个整数描述序列 $c$，代表莲子的 DFS 序列所对应的点权序列 $c$。保证一定存在一种合法的操作方式和操作后的 DFS 方式得到序列 $c$。", "outputFormat": "第一行一个整数 $m$，表示你进行的操作数。\n\n接下来一行 $m$ 个数，第 $i$ 个数 $x_i$ 代表你在第 $i$ 次操作选择连接节点 $x_i$ 和其父节点 $f_{x_i}$ 的边进行操作。\n\n接下来一行 $n$ 个数描述一个排列 $p$，其中 $p_i$ 代表你构造的 DFS 序列中遍历到的第 $i$ 个节点为点 $p_i$。", "hint": "### 样例解释\n\n#### 样例 \\#1\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ihq8vqnc.png)\n\n其中一种可行的方案是依次操作边 $(2,3),(3,4),(1,2)$，操作后的树的点权序列为 $\\{1,3,5,9\\}$，选出的 DFS 序列为 $\\{1,2,3,4\\}$。\n\n注意到该样例符合特殊性质 $\\mathbf{A}$。\n\n#### 样例 \\#2\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z14j0aeu.png)\n\n其中一种可行的方案是依次操作边 $(1,2),(3,5),(1,3)$，操作后的树的点权序列为 $\\{1,0,0,3,3\\}$，选出的 DFS 序列为 $\\{1,2,4,3,5\\}$。\n#### 样例 \\#3\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7livbzzu.png)\n\n其中一种可行的方案是依次操作边 $(1,2)$，操作后的树的点权序列为 $\\{1,3,3,4\\}$，选出的 DFS 序列为 $\\{1,4,2,3\\}$。\n\n注意到该样例符合特殊性质 $\\mathbf{B}$。\n#### 样例 \\#4\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9bopbeh3.png)\n\n其中一种可行的方案是依次操作边 $(1,2),(2,4),(3,5),(1,3)$，操作后的树的点权序列为 $\\{1,2,3,2,2\\}$，选出的 DFS 序列为 $\\{1,3,5,2,4\\}$。\n\n注意到该样例符合特殊性质 $\\mathbf{C}$。\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{\\textsf{分值}} & \\bm{n\\le } & \\textbf{\\textsf{特殊性质}}&\\textbf{Subtask \\textsf{依赖}}\\cr\\hline\n1 & 10 & 6 & - &-\\cr\\hline\n2 & 10 & 100 & \\mathbf{A}&- \\cr\\hline\n3 & 10 & 100 & \\mathbf{B}&- \\cr\\hline\n4 & 15 & 2\\times 10^3 & \\mathbf{C}&-  \\cr\\hline\n5 & 15 & 2\\times 10^3 & \\mathbf{D}&-  \\cr\\hline\n6 & 15 & 100 & -&1,2,3  \\cr\\hline\n7 & 25 & 2\\times 10^3 & -&1,2,3,4,5,6  \\cr\\hline\n\\end{array}\n$$\n\n特殊性质 $\\mathbf{A}$：保证给出的树满足 $f_i=i-1$ ($i\\ne 1$)。\\\n特殊性质 $\\mathbf{B}$：保证给出的树满足 $f_i=1$ ($i\\ne 1$)。\\\n特殊性质 $\\mathbf{C}$：保证给出的树满足 $w_i=1$。\\\n特殊性质 $\\mathbf{D}$：保证给出的树满足所有非叶节点儿子数不超过 $2$。\n\n对于所有数据满足：$1\\le n\\le 2000$，$-10^8\\le w_i\\le 10^8$，$-10^{14}\\le c_i\\le 10^{14}$。", "locale": "zh-CN", "translations": {"en": {"title": "Gate to Another World", "background": "Following the clues, Renko arrived at Tanabatazaka. With no time to admire the scenery, her mind raced as she searched for traces of another world. Flipped Jizō statues, strange fissures, a hidden fifth season... This forbidden realm was revealing its secrets to her.\n\nBut the first thing Renko saw was Merry. Without hesitation, she grabbed Merry's hand—", "description": "With keen intuition, Renko realized the method to enter this otherworld must be linked to these special Jizō statues. She discovered they formed a uniquely structured tree.\n\nGiven a **rooted** tree with $n$ nodes, where the root is node $1$, and each node $i$ has a weight $w_i$. **For any two nodes at the same depth, they have the same number of children.**\n\nTo enter the otherworld, Renko performed operations to modify the tree's node weights:\n\n1. Select an edge connecting nodes $(u,v)$, where $u$ is the deeper node (i.e., $u$ is $v$'s child). Add $w_v$ to $w_u$.\n2. This operation can be performed any number of times, but **the same edge cannot be selected more than once**.\n\nAfter these operations, Renko derived a [DFS sequence](https://oi-wiki.org/graph/dfs/) of the tree and recorded the corresponding weight sequence $c$ (specifically, $c_i$ is the weight of the $i$-th node visited in the DFS order).\n\nUnfortunately, she forgot which operations she performed and how the DFS was conducted. Your task is to reconstruct any valid set of operations and DFS sequence.", "inputFormat": "- The first line contains an integer $n$.\n- The next $n$ lines each contain two integers $f_i$ and $w_i$:  \n  - $f_i$ is the parent of node $i$ (note: $f_1=0$, and for other nodes, $1 \\leq f_i < i$).  \n  - $w_i$ is the initial weight of node $i$.  \n- The next line contains $n$ integers describing the target weight sequence $c$. It is guaranteed that there exists a valid set of operations and DFS order to achieve $c$.", "outputFormat": "- The first line contains an integer $m$, the number of operations performed.\n- The second line contains $m$ integers $x_1, x_2, \\ldots, x_m$, where $x_i$ represents the edge between node $x_i$ and its parent $f_{x_i}$ chosen in the $i$-th operation.\n- The third line contains a permutation $p$ of $n$ integers, where $p_i$ is the $i$-th node visited in your constructed DFS sequence.", "hint": "### Sample Explanations\n\n#### Sample #1\n\nOne valid solution is to operate edges $(2,3)$, $(3,4)$, $(1,2)$ in order. The final weights are $\\{1,3,5,9\\}$, and the DFS sequence is $1,2,3,4$.  \nThis sample satisfies **Special Property A**.\n\n#### Sample #2\n\nOne valid solution is to operate edges $(1,2)$, $(3,5)$, $(1,3)$. The final weights are $\\{1,0,0,3,3\\}$, and the DFS sequence is $1,2,4,3,5$.\n\n#### Sample #3\n\nOne valid solution is to operate edge $(1,2)$. The final weights are $\\{1,3,3,4\\}$, and the DFS sequence is $1,4,2,3$.  \nThis sample satisfies **Special Property B**.\n\n#### Sample #4\n\nOne valid solution is to operate edges $(1,2)$, $(2,4)$, $(3,5)$, $(1,3)$. The final weights are $\\{1,2,3,2,2\\}$, and the DFS sequence is $1,3,5,2,4$.  \nThis sample satisfies **Special Property C**.\n\n### Constraints\n\n**Bundled testing is used.**\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{Points} & \\bm{n \\leq} & \\textbf{Special Property} & \\textbf{Subtask Dependencies} \\cr\\hline\n1 & 10 & 6 & - & - \\cr\\hline\n2 & 10 & 100 & \\mathbf{A} & - \\cr\\hline\n3 & 10 & 100 & \\mathbf{B} & - \\cr\\hline\n4 & 15 & 2 \\times 10^3 & \\mathbf{C} & - \\cr\\hline\n5 & 15 & 2 \\times 10^3 & \\mathbf{D} & - \\cr\\hline\n6 & 15 & 100 & - & 1,2,3 \\cr\\hline\n7 & 25 & 2 \\times 10^3 & - & 1,2,3,4,5,6 \\cr\\hline\n\\end{array}\n$$\n\n**Special Properties**:\n- **A**: The tree satisfies $f_i = i-1$ for $i \\neq 1$.\n- **B**: The tree satisfies $f_i = 1$ for $i \\neq 1$.\n- **C**: All nodes have $w_i = 1$.\n- **D**: All non-leaf nodes have at most 2 children.\n\nFor all data:  \n$1 \\leq n \\leq 2000$, $-10^8 \\leq w_i \\leq 10^8$, $-10^{14} \\leq c_i \\leq 10^{14}$.\n\n---\n\nTranslated by DeepSeek R1", "locale": "en"}, "zh-CN": {"title": "异界之门", "background": "跟随着线索，莲子来到了七夕坂。无暇欣赏此处的风景，高速运转着大脑的莲子，不断寻找异界的线索。翻转的地藏、奇异的裂缝、被隐匿的第五个季节……这个禁忌之中的世界，正向她揭晓着自己的秘密。\n\n但莲子第一时间看到的只有梅莉，来不及思考，她一把抓住了梅莉的手——", "description": "嗅觉敏锐的莲子察觉到，进入异界的方法一定和这些特别的地藏有所联系。她发现它们恰好构成了一棵形状特殊的树。\n\n给定一棵 $n$ 个点的带点权的**有根**树，其根为 $1$，且点 $i$ 的点权为 $w_i$。**其满足对于任意两个深度相同的结点，它们的儿子数也相同**。\n\n为了进入异界，莲子进行了一些操作来改变这棵树的点权：\n\n1. 选择一条边，假设它连接了两点 $(u,v)$，设其中深度更高者为 $u$（即 $u$ 是 $v$ 的儿子），将 $w_u$ 加上 $w_v$。\n2. 上述操作可以被执行任意多次，但是**不能重复选择同一条边**。\n\n经过操作后，莲子求出了树的某个 [DFS 序列](https://oi-wiki.org/graph/dfs/)，并记录下了这个 DFS 序列所对应的点权序列 $c$（具体来说，$c_i$ 为 DFS 序过程中遍历到的第 $i$ 个点的点权）。\n\n不幸的是，她突然忘记了她进行过哪些操作，也忘记了如何 DFS 这棵树，她希望你能还原出任意一组合法的操作方案与 DFS 序列。", "inputFormat": "第一行一个整数 $n$。\n\n对于接下来 $n$ 行：第 $i$ 行两个整数 $f_i,w_i$，其中 $f_i$ 代表点 $i$ 的父节点（特别的，$f_1=0$，对于其余节点有 $1\\le f_i<i$），$w_i$ 代表点 $i$ 的权值。\n\n接下来一行 $n$ 个整数描述序列 $c$，代表莲子的 DFS 序列所对应的点权序列 $c$。保证一定存在一种合法的操作方式和操作后的 DFS 方式得到序列 $c$。", "outputFormat": "第一行一个整数 $m$，表示你进行的操作数。\n\n接下来一行 $m$ 个数，第 $i$ 个数 $x_i$ 代表你在第 $i$ 次操作选择连接节点 $x_i$ 和其父节点 $f_{x_i}$ 的边进行操作。\n\n接下来一行 $n$ 个数描述一个排列 $p$，其中 $p_i$ 代表你构造的 DFS 序列中遍历到的第 $i$ 个节点为点 $p_i$。", "hint": "### 样例解释\n\n#### 样例 \\#1\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ihq8vqnc.png)\n\n其中一种可行的方案是依次操作边 $(2,3),(3,4),(1,2)$，操作后的树的点权序列为 $\\{1,3,5,9\\}$，选出的 DFS 序列为 $\\{1,2,3,4\\}$。\n\n注意到该样例符合特殊性质 $\\mathbf{A}$。\n\n#### 样例 \\#2\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z14j0aeu.png)\n\n其中一种可行的方案是依次操作边 $(1,2),(3,5),(1,3)$，操作后的树的点权序列为 $\\{1,0,0,3,3\\}$，选出的 DFS 序列为 $\\{1,2,4,3,5\\}$。\n#### 样例 \\#3\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7livbzzu.png)\n\n其中一种可行的方案是依次操作边 $(1,2)$，操作后的树的点权序列为 $\\{1,3,3,4\\}$，选出的 DFS 序列为 $\\{1,4,2,3\\}$。\n\n注意到该样例符合特殊性质 $\\mathbf{B}$。\n#### 样例 \\#4\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9bopbeh3.png)\n\n其中一种可行的方案是依次操作边 $(1,2),(2,4),(3,5),(1,3)$，操作后的树的点权序列为 $\\{1,2,3,2,2\\}$，选出的 DFS 序列为 $\\{1,3,5,2,4\\}$。\n\n注意到该样例符合特殊性质 $\\mathbf{C}$。\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{\\textsf{分值}} & \\bm{n\\le } & \\textbf{\\textsf{特殊性质}}&\\textbf{Subtask \\textsf{依赖}}\\cr\\hline\n1 & 10 & 6 & - &-\\cr\\hline\n2 & 10 & 100 & \\mathbf{A}&- \\cr\\hline\n3 & 10 & 100 & \\mathbf{B}&- \\cr\\hline\n4 & 15 & 2\\times 10^3 & \\mathbf{C}&-  \\cr\\hline\n5 & 15 & 2\\times 10^3 & \\mathbf{D}&-  \\cr\\hline\n6 & 15 & 100 & -&1,2,3  \\cr\\hline\n7 & 25 & 2\\times 10^3 & -&1,2,3,4,5,6  \\cr\\hline\n\\end{array}\n$$\n\n特殊性质 $\\mathbf{A}$：保证给出的树满足 $f_i=i-1$ ($i\\ne 1$)。\\\n特殊性质 $\\mathbf{B}$：保证给出的树满足 $f_i=1$ ($i\\ne 1$)。\\\n特殊性质 $\\mathbf{C}$：保证给出的树满足 $w_i=1$。\\\n特殊性质 $\\mathbf{D}$：保证给出的树满足所有非叶节点儿子数不超过 $2$。\n\n对于所有数据满足：$1\\le n\\le 2000$，$-10^8\\le w_i\\le 10^8$，$-10^{14}\\le c_i\\le 10^{14}$。", "locale": "zh-CN"}}}
{"pid": "P10611", "type": "P", "difficulty": 7, "samples": [["5 5 20\n3 2 1 1 1 \n1 2 2 1 2\n2 2 4 3 4\n1 2 4 5 6\n1 1 3 4 4\n1 1 5 5 4\n1 3 4 3 1\n1 1 2 4 2\n1 5 5 5 8\n2 2 4 2 5\n2 1 5 3 5\n2 3 5 1 3\n1 1 4 2 6\n2 1 1 1 3\n1 2 4 4 10\n2 2 5 3 4\n2 1 4 1 4\n2 4 5 4 5\n1 2 2 2 5\n1 4 4 4 9\n1 2 5 3 6\n", "0\n4\n8\n12\n4\n10\n20\n10\n"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "颜色段均摊（珂朵莉树 ODT）", "洛谷原创", "O2优化", "分治", "扫描线", "洛谷月赛"], "title": "故事结局", "background": "莲子最终有惊无险的救下了梅莉，虽然梅莉本人似乎对此不以为意，而且还对莲子的观点有很多看法……不过她们很快就和好如初，然后一起度过了一段甜蜜的时光。\n\n但是你既不是莲子也不是梅莉，所以在故事的结尾，你需要做一道数据结构题。", "description": "你需要维护一个大小为 $n \\times m$ 的矩阵 $A$，初始时其所有元素均为 $0$。题目还给出了一个长度为 $m$ 的序列 $b$。\n\n共有 $q$ 次操作，分为两种：\n\n- `1 l r x v`，对于 $l \\le i \\le r$，将 $A_{x,i}$ 修改为 $v$。\n\n- `2 l r x y`，查询 $\\max\\limits_{i=l}^r \\max\\limits_{j=x}^y (A_{i,j} \\times b_j)$。", "inputFormat": "第一行三个整数 $n,m,q$。\n\n第二行 $m$ 个整数描述序列 $b$。\n\n接下来 $q$ 行，每行描述一次操作，要么格式为 `1 l r x v`，要么格式为 `2 l r x y`。", "outputFormat": "对于每次 `2` 操作，输出一行一个整数表示查询的结果。", "hint": "### 数据范围\n\n**本题采用捆绑测试。**\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{\\textsf{分值}} & \\bm{n,q\\le } & \\textbf{\\textsf{特殊性质}}&\\textbf{Subtask \\textsf{依赖}}\\cr\\hline\n1 & 5 & 100 & - &-\\cr\\hline\n2 & 5 & 5000 & -&- \\cr\\hline\n3 & 20 & 2 \\times 10^5 & \\mathbf{A}&- \\cr\\hline\n4 & 10 & 2 \\times 10^5 & \\mathbf{B}&- \\cr\\hline\n5 & 10 & 2\\times 10^5 & \\mathbf{C}&-  \\cr\\hline\n6 & 10 & 2\\times 10^5 & \\mathbf{D}&-  \\cr\\hline\n7 & 20 & 2\\times 10^5 & -&1,2,3,4,5,6  \\cr\\hline\n8 & 20 & 4\\times 10^5 & -&7  \\cr\\hline\n\\end{array}\n$$\n\n特殊性质 $\\mathbf{A}$：保证所有修改在查询之前。\\\n特殊性质 $\\mathbf{B}$：对于修改操作保证 $l=r$。\\\n特殊性质 $\\mathbf{C}$：保证数据随机（随机方法见下）。\\\n特殊性质 $\\mathbf{D}$：保证 $b$ 序列满足所有 $b_i=1$。\n\n对于所有数据满足：$1 \\le n,m,q \\le 4 \\times 10^5$。$1 \\le b_i \\le 10^9$。\n\n**在所有 $q$ 次操作中，修改操作出现不超过 $\\dfrac{q}{4}$ 次。**\n\n对于一操作，$1 \\le l \\le r \\le m,1 \\le x \\le n,1 \\le v \\le  10^9$。\n\n对于二操作，$1 \\le l \\le r \\le n,1 \\le x \\le y \\le m$。\n\n数据随机的方式：$n,m,q$ 事先选定，不是随机的。然后均匀随机取 $\\left \\lfloor \\dfrac{q}{4} \\right \\rfloor$ 次操作为修改操作，剩下的为查询操作。对于操作的所有参数以及 $b$ 序列在其限制范围内等概率随机。", "locale": "zh-CN", "translations": {"en": {"title": "The End of the Story", "background": "In the end, Renko managed to rescue Merry without major mishaps. Though Merry herself seemed unfazed and had many opinions about Renko's approach... they quickly reconciled and spent a sweet time together.\n\nBut you are neither Renko nor Merry. So at the story's conclusion, you must solve a data structure problem.", "description": "You need to maintain an $n \\times m$ matrix $A$ where all elements are initially $0$. A sequence $b$ of length $m$ is also given.\n\nThere are $q$ operations of two types:\n\n- `1 l r x v`: For $l \\le i \\le r$, set $A_{x,i}$ to $v$.\n- `2 l r x y`: Query $\\max\\limits_{i=l}^r \\max\\limits_{j=x}^y (A_{i,j} \\times b_j)$.", "inputFormat": "- The first line contains three integers $n$, $m$, $q$.\n- The second line contains $m$ integers describing sequence $b$.\n- The next $q$ lines describe operations, each in the format `1 l r x v` or `2 l r x y`.", "outputFormat": "For each `2` operation, output a single integer representing the query result.", "hint": "### Constraints\n\n**Bundled testing is used.**\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{Points} & \\bm{n,q \\leq} & \\textbf{Special Property} & \\textbf{Subtask Dependencies} \\cr\\hline\n1 & 5 & 100 & - & - \\cr\\hline\n2 & 5 & 5000 & - & - \\cr\\hline\n3 & 20 & 2 \\times 10^5 & \\mathbf{A} & - \\cr\\hline\n4 & 10 & 2 \\times 10^5 & \\mathbf{B} & - \\cr\\hline\n5 & 10 & 2 \\times 10^5 & \\mathbf{C} & - \\cr\\hline\n6 & 10 & 2 \\times 10^5 & \\mathbf{D} & - \\cr\\hline\n7 & 20 & 2 \\times 10^5 & - & 1,2,3,4,5,6 \\cr\\hline\n8 & 20 & 4 \\times 10^5 & - & 7 \\cr\\hline\n\\end{array}\n$$\n\n**Special Properties**:\n- **A**: All modifications occur before queries.\n- **B**: For modify operations, $l = r$.\n- **C**: Data is randomly generated (see details below).\n- **D**: All $b_i = 1$.\n\n**For all data**:\n- $1 \\leq n, m, q \\leq 4 \\times 10^5$.\n- $1 \\leq b_i \\leq 10^9$.\n- **At most $\\dfrac{q}{4}$ of the operations are modify operations**.\n- For modify operations: $1 \\leq l \\leq r \\leq m$, $1 \\leq x \\leq n$, $1 \\leq v \\leq 10^9$.\n- For query operations: $1 \\leq l \\leq r \\leq n$, $1 \\leq x \\leq y \\leq m$.\n\n**Data randomization method**:\n- $n$, $m$, and $q$ are predetermined (not random).\n- Exactly $\\left\\lfloor \\dfrac{q}{4} \\right\\rfloor$ operations are uniformly randomly selected as modify operations, with the rest as queries.\n- All parameters for operations and the $b$ sequence are randomly sampled within their constraints with equal probability.\n\n---\n\nTranslated by DeepSeek R1", "locale": "en"}, "zh-CN": {"title": "故事结局", "background": "莲子最终有惊无险的救下了梅莉，虽然梅莉本人似乎对此不以为意，而且还对莲子的观点有很多看法……不过她们很快就和好如初，然后一起度过了一段甜蜜的时光。\n\n但是你既不是莲子也不是梅莉，所以在故事的结尾，你需要做一道数据结构题。", "description": "你需要维护一个大小为 $n \\times m$ 的矩阵 $A$，初始时其所有元素均为 $0$。题目还给出了一个长度为 $m$ 的序列 $b$。\n\n共有 $q$ 次操作，分为两种：\n\n- `1 l r x v`，对于 $l \\le i \\le r$，将 $A_{x,i}$ 修改为 $v$。\n\n- `2 l r x y`，查询 $\\max\\limits_{i=l}^r \\max\\limits_{j=x}^y (A_{i,j} \\times b_j)$。", "inputFormat": "第一行三个整数 $n,m,q$。\n\n第二行 $m$ 个整数描述序列 $b$。\n\n接下来 $q$ 行，每行描述一次操作，要么格式为 `1 l r x v`，要么格式为 `2 l r x y`。", "outputFormat": "对于每次 `2` 操作，输出一行一个整数表示查询的结果。", "hint": "### 数据范围\n\n**本题采用捆绑测试。**\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\textbf{\\textsf{分值}} & \\bm{n,q\\le } & \\textbf{\\textsf{特殊性质}}&\\textbf{Subtask \\textsf{依赖}}\\cr\\hline\n1 & 5 & 100 & - &-\\cr\\hline\n2 & 5 & 5000 & -&- \\cr\\hline\n3 & 20 & 2 \\times 10^5 & \\mathbf{A}&- \\cr\\hline\n4 & 10 & 2 \\times 10^5 & \\mathbf{B}&- \\cr\\hline\n5 & 10 & 2\\times 10^5 & \\mathbf{C}&-  \\cr\\hline\n6 & 10 & 2\\times 10^5 & \\mathbf{D}&-  \\cr\\hline\n7 & 20 & 2\\times 10^5 & -&1,2,3,4,5,6  \\cr\\hline\n8 & 20 & 4\\times 10^5 & -&7  \\cr\\hline\n\\end{array}\n$$\n\n特殊性质 $\\mathbf{A}$：保证所有修改在查询之前。\\\n特殊性质 $\\mathbf{B}$：对于修改操作保证 $l=r$。\\\n特殊性质 $\\mathbf{C}$：保证数据随机（随机方法见下）。\\\n特殊性质 $\\mathbf{D}$：保证 $b$ 序列满足所有 $b_i=1$。\n\n对于所有数据满足：$1 \\le n,m,q \\le 4 \\times 10^5$。$1 \\le b_i \\le 10^9$。\n\n**在所有 $q$ 次操作中，修改操作出现不超过 $\\dfrac{q}{4}$ 次。**\n\n对于一操作，$1 \\le l \\le r \\le m,1 \\le x \\le n,1 \\le v \\le  10^9$。\n\n对于二操作，$1 \\le l \\le r \\le n,1 \\le x \\le y \\le m$。\n\n数据随机的方式：$n,m,q$ 事先选定，不是随机的。然后均匀随机取 $\\left \\lfloor \\dfrac{q}{4} \\right \\rfloor$ 次操作为修改操作，剩下的为查询操作。对于操作的所有参数以及 $b$ 序列在其限制范围内等概率随机。", "locale": "zh-CN"}}}
{"pid": "P10612", "type": "P", "difficulty": 6, "samples": [["2 3\n9\n7\n10\n8\n6\n5\n2\n4\n1\n3", "0 1 0\n0 1 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2001", "Special Judge", "构造", "BalticOI（波罗的海）", "Ad-hoc"], "title": "[BalticOI 2001] Box of Mirrors", "background": "", "description": "数学家 Andris 有一个小盒子，其底部是 $n\\times m$ 的格子，每个格子可以放一面 $45$ 度朝向的镜子。\n\n在盒子的边界，每行每列的两端，有一些孔，光线可以从中射入盒子，也可以射出。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i5gnsp7v.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1xl9wkfz.png)\n\n如上图所示，从孔 $2$ 射进盒子的光线经过两次反射后又从孔 $7$ 射出。\n\nAndris 想请你设计一个盒子，使得从每个孔射入的光线都会从指定的孔射出。\n\n例如，如果他希望从 $10$ 个孔里射入的光线分别由孔 $9,7,10,8,6,5,2,4,1,3$ 射出，则上图也是一个满足要求的盒子。\n\n注意，孔的编号如图从 $1$ 到 $2\\times (n+m)$ 编号。", "inputFormat": "第一行两个整数 $n,m$，表示盒子的大小。\n\n接下来 $2\\times (n+m)$ 行，第 $i+1$ 行一个整数 $a_i$，表示从第 $i$ 个孔射入的光线要从第 $a_i$ 个孔中射出。", "outputFormat": "输出一个 $n\\times m$ 的矩阵，对于每个位置，$0$ 表示不放镜子，$1$ 表示放镜子，需要满足对应的要求。数据保证一定有解。", "hint": "对于 $100\\%$ 的数据，$1\\leq n,m\\leq 100$，$1\\leq a_i\\leq 2\\times (n+m)$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2001] Box of Mirrors", "background": "", "description": "数学家 Andris 有一个小盒子，其底部是 $n\\times m$ 的格子，每个格子可以放一面 $45$ 度朝向的镜子。\n\n在盒子的边界，每行每列的两端，有一些孔，光线可以从中射入盒子，也可以射出。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i5gnsp7v.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1xl9wkfz.png)\n\n如上图所示，从孔 $2$ 射进盒子的光线经过两次反射后又从孔 $7$ 射出。\n\nAndris 想请你设计一个盒子，使得从每个孔射入的光线都会从指定的孔射出。\n\n例如，如果他希望从 $10$ 个孔里射入的光线分别由孔 $9,7,10,8,6,5,2,4,1,3$ 射出，则上图也是一个满足要求的盒子。\n\n注意，孔的编号如图从 $1$ 到 $2\\times (n+m)$ 编号。", "inputFormat": "第一行两个整数 $n,m$，表示盒子的大小。\n\n接下来 $2\\times (n+m)$ 行，第 $i+1$ 行一个整数 $a_i$，表示从第 $i$ 个孔射入的光线要从第 $a_i$ 个孔中射出。", "outputFormat": "输出一个 $n\\times m$ 的矩阵，对于每个位置，$0$ 表示不放镜子，$1$ 表示放镜子，需要满足对应的要求。数据保证一定有解。", "hint": "对于 $100\\%$ 的数据，$1\\leq n,m\\leq 100$，$1\\leq a_i\\leq 2\\times (n+m)$。", "locale": "zh-CN"}}}
{"pid": "P10613", "type": "P", "difficulty": 6, "samples": [["3 2", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2008", "O2优化", "背包 DP", "根号分治", "PA（波兰）"], "title": "[PA 2008] Cliquers", "background": "", "description": "统计结点个数为 $n$，且每一个连通分量都是完全图的本质不同的图的个数 $x$。\n\n求 $m^x \\bmod P$，其中 $P=10^9-401$ 为一个质数。", "inputFormat": "一行两个整数，分别为 $n,m$。", "outputFormat": "一行一个整数，表示所求的结果。", "hint": "**【样例解释】**\n\n当 $n=3$ 时，$3$ 种情况如下图所示。注意您应当输出的是 $m^x \\bmod P=2^3 \\bmod (10^9-401)$ 的值。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oeqoqluo.png)\n\n**【数据范围】**\n\n对于所有数据，$1\\leq n,m\\leq 2\\times 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2008] Cliquers", "background": "", "description": "统计结点个数为 $n$，且每一个连通分量都是完全图的本质不同的图的个数 $x$。\n\n求 $m^x \\bmod P$，其中 $P=10^9-401$ 为一个质数。", "inputFormat": "一行两个整数，分别为 $n,m$。", "outputFormat": "一行一个整数，表示所求的结果。", "hint": "**【样例解释】**\n\n当 $n=3$ 时，$3$ 种情况如下图所示。注意您应当输出的是 $m^x \\bmod P=2^3 \\bmod (10^9-401)$ 的值。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oeqoqluo.png)\n\n**【数据范围】**\n\n对于所有数据，$1\\leq n,m\\leq 2\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P10614", "type": "P", "difficulty": 6, "samples": [["1\nGTC\n10", "1\n22783\n528340\n497452"]], "limits": {"time": [3000], "memory": [524288]}, "tags": ["字符串", "O2优化", "有限状态自动机", "DP 套 DP"], "title": "BZOJ3864 Hero meet devil", "background": "", "description": "给定一个字符集为 `ACGT` 的字符串 $S$。定义 $\\text{LCS}(S,T)$ 为两个字符串 $S,T$ 的最长公共子序列。\n\n对于每个 $0\\leq i \\leq |S|$，求有多少个长度为 $m$，字符集 `ACGT` 的字符串 $T$，满足 $|\\text{LCS}(S,T)|=i$，答案对 $10^9+7$ 取模。", "inputFormat": "第一行一个整数 $T$ 表示数据组数。\n\n对于每组数据，第一行一个字符串 $S$，第二行一个整数 $m$。", "outputFormat": "对于每组数据，输出 $i=0,1,\\dots,|S|$ 时的答案，每个占一行。", "hint": "对于 $100\\%$ 的数据，保证 $1\\leq T\\leq 5$，$1\\leq |S| \\leq 15$，$1\\leq m\\leq 1000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "BZOJ3864 Hero meet devil", "background": "", "description": "给定一个字符集为 `ACGT` 的字符串 $S$。定义 $\\text{LCS}(S,T)$ 为两个字符串 $S,T$ 的最长公共子序列。\n\n对于每个 $0\\leq i \\leq |S|$，求有多少个长度为 $m$，字符集 `ACGT` 的字符串 $T$，满足 $|\\text{LCS}(S,T)|=i$，答案对 $10^9+7$ 取模。", "inputFormat": "第一行一个整数 $T$ 表示数据组数。\n\n对于每组数据，第一行一个字符串 $S$，第二行一个整数 $m$。", "outputFormat": "对于每组数据，输出 $i=0,1,\\dots,|S|$ 时的答案，每个占一行。", "hint": "对于 $100\\%$ 的数据，保证 $1\\leq T\\leq 5$，$1\\leq |S| \\leq 15$，$1\\leq m\\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P10615", "type": "P", "difficulty": 3, "samples": [["3\nA+00A+A+ 00B+D+A- B-C+00C+", "bounded"], ["1\nK+K-Q+Q", "unbounded"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "并查集", "O2优化", "深度优先搜索 DFS", "图论建模", "ICPC", "Floyd 算法", "WF"], "title": "[ICPC 2013 WF] Self-Assembly", "background": "", "description": "Automatic Chemical Manufacturing is experimenting with a process called self-assembly. In this process, molecules with natural affinity for each other are mixed together in a solution and allowed to spontaneously assemble themselves into larger structures. But there is one problem: sometimes molecules assemble themselves into a structure of unbounded size, which gums up the machinery.\n\nYou must write a program to decide whether a given collection of molecules can be assembled into a structure of unbounded size. You should make two simplifying assumptions: 1) the problem is restricted to two dimensions, and 2) each molecule in the collection is represented as a square. The four edges of the square represent the surfaces on which the molecule can connect to other compatible molecules.\n\nIn each test case, you will be given a set of molecule descriptions. Each type of molecule is described by four two-character *connector labels* that indicate how its edges can connect to the edges of other molecules. There are two types of connector labels:\n\n- An uppercase letter $(A, \\dots , Z)$ followed by $+$ or $−$. Two edges are compatible if their labels have the same letter but different signs. For example, $A+$ is compatible with $A-$ but is not compatible with $A+$ or $B-$.\n- Two zero digits $00$. An edge with this label is not compatible with any edge (not even with another edge labeled $00$).\n\nAssume there is an unlimited supply of molecules of each type, which may be rotated and reflected. As the molecules assemble themselves into larger structures, the edges of two molecules may be adjacent to each other only if they are compatible. It is permitted for an edge, regardless of its connector label, to be connected to nothing (no adjacent molecule on that edge).\n\nFigure A.1 shows an example of three molecule types and a structure of bounded size that can be assembled from them (other bounded structures are also possible with this set of molecules).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kjmni4to.png)", "inputFormat": "The input consists of a single test case. A test case consists of two lines. The first contains an integer $n(1 \\leq n \\leq 40 000)$ indicating the number of molecule types. The second line contains $n$ eight-character strings, each describing a single type of molecule, separated by single spaces. Each string consists of four two-character connector labels representing the four edges of the molecule in clockwise order.", "outputFormat": "Display the word `unbounded` if the set of molecule types can generate a structure of unbounded size.\nOtherwise, display the word `bounded`.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Self-Assembly", "background": "", "description": "Automatic Chemical Manufacturing is experimenting with a process called self-assembly. In this process, molecules with natural affinity for each other are mixed together in a solution and allowed to spontaneously assemble themselves into larger structures. But there is one problem: sometimes molecules assemble themselves into a structure of unbounded size, which gums up the machinery.\n\nYou must write a program to decide whether a given collection of molecules can be assembled into a structure of unbounded size. You should make two simplifying assumptions: 1) the problem is restricted to two dimensions, and 2) each molecule in the collection is represented as a square. The four edges of the square represent the surfaces on which the molecule can connect to other compatible molecules.\n\nIn each test case, you will be given a set of molecule descriptions. Each type of molecule is described by four two-character *connector labels* that indicate how its edges can connect to the edges of other molecules. There are two types of connector labels:\n\n- An uppercase letter $(A, \\dots , Z)$ followed by $+$ or $−$. Two edges are compatible if their labels have the same letter but different signs. For example, $A+$ is compatible with $A-$ but is not compatible with $A+$ or $B-$.\n- Two zero digits $00$. An edge with this label is not compatible with any edge (not even with another edge labeled $00$).\n\nAssume there is an unlimited supply of molecules of each type, which may be rotated and reflected. As the molecules assemble themselves into larger structures, the edges of two molecules may be adjacent to each other only if they are compatible. It is permitted for an edge, regardless of its connector label, to be connected to nothing (no adjacent molecule on that edge).\n\nFigure A.1 shows an example of three molecule types and a structure of bounded size that can be assembled from them (other bounded structures are also possible with this set of molecules).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kjmni4to.png)", "inputFormat": "The input consists of a single test case. A test case consists of two lines. The first contains an integer $n(1 \\leq n \\leq 40 000)$ indicating the number of molecule types. The second line contains $n$ eight-character strings, each describing a single type of molecule, separated by single spaces. Each string consists of four two-character connector labels representing the four edges of the molecule in clockwise order.", "outputFormat": "Display the word `unbounded` if the set of molecule types can generate a structure of unbounded size.\nOtherwise, display the word `bounded`.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Self-Assembly", "background": "", "description": "自动化化学制造正在试验一种称为自组装的过程。在这个过程中，具有天然亲和力的分子被混合在一起，并允许它们自发地组装成更大的结构。但有一个问题：有时分子会自组装成无限大的结构，导致设备故障。\n\n你必须编写一个程序来决定给定的分子集合是否可以组装成一个无限大的结构。你应该做两个简化假设：1）问题仅限于二维，2）集合中的每个分子表示为一个正方形。正方形的四个边代表分子可以连接到其他兼容分子的表面。\n\n在每个测试用例中，你将得到一组分子描述。每种类型的分子由四个两个字符的*连接标签*描述，指示其边缘如何连接到其他分子的边缘。有两种类型的连接标签：\n\n- 一个大写字母 $(A, \\dots , Z)$ 后跟 $+$ 或 $−$。如果两个边的标签具有相同的字母但符号不同，则它们是兼容的。例如，$A+$ 与 $A-$ 兼容，但与 $A+$ 或 $B-$ 不兼容。\n- 两个数字 $00$。带有此标签的边与任何边都不兼容（即使是另一个标记为 $00$ 的边也不兼容）。\n\n假设每种类型的分子都有无限供应，并且可以旋转和反射。随着分子自组装成更大的结构，两个分子的边只有在兼容时才可以相邻。允许边缘（无论其连接标签如何）不连接到任何东西（该边没有相邻分子）。\n\n图 A.1 显示了三种分子类型的示例以及可以从中组装的有限大小结构（使用该分子集也可以组装其他有限结构）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kjmni4to.png)", "inputFormat": "输入由一个测试用例组成。一个测试用例由两行组成。第一行包含一个整数 $n(1 \\leq n \\leq 40 000)$，表示分子类型的数量。第二行包含 $n$ 个八字符的字符串，每个字符串描述一种分子的类型，单个空格分隔。每个字符串由四个两个字符的连接标签组成，按顺时针顺序表示分子的四个边。", "outputFormat": "如果这组分子类型可以生成一个无限大的结构，则显示单词 `unbounded`。否则，显示单词 `bounded`。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10616", "type": "P", "difficulty": 6, "samples": [["0 49.9", "0.0"], ["50 49.85", "7.10178453"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "Special Judge", "O2优化", "ICPC", "WF"], "title": "[ICPC 2013 WF] Hey, Better Bettor", "background": "> “In the casino, the cardinal rule is to keep them playing and to keep them coming back. The\nlonger they play, the more they lose, and in the end, we get it all.”  \n> (from the 1995 film *Casino*)", "description": "Recent recessions have not been kind to entertainment venues, including the gambling industry. Competition is fierce among casinos to attract players with lots of money, and some have begun to offer especially sweet deals. One casino is offering the following: you can gamble as much as you want at the casino. After you are finished, if you are down by any amount from when you started, the casino will refund $x\\%$ of your losses to you. Obviously, if you are ahead, you can keep all of your winnings. There is no time limit or money limit on this offer, but you can redeem it only once.\n\nFor simplicity, assume all bets cost $1$ dollar and pay out $2$ dollars. Now suppose $x$ is $20$. If you make $10$ bets in total before quitting and only $3$ of them pay out, your total loss is $3.2$ dollars. If $6$ of them pay out, you have gained $2$ dollars.\n\nGiven $x$ and the percentage probability $p$ of winning any individual bet, write a program to determine the maximum expected profit you can make from betting at this casino, using any gambling strategy.", "inputFormat": "The input consists of a single test case. A test case consists of the refund percentage $x (0 \\leq x < 100)$ followed by the winning probability percentage $p (0 \\leq p < 50)$. Both $x$ and $p$ have at most two digits after the decimal point.", "outputFormat": "Display the maximum expected profit with an absolute error of at most $10^{-3}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Hey, Better Bettor", "background": "> “In the casino, the cardinal rule is to keep them playing and to keep them coming back. The\nlonger they play, the more they lose, and in the end, we get it all.”  \n> (from the 1995 film *Casino*)", "description": "Recent recessions have not been kind to entertainment venues, including the gambling industry. Competition is fierce among casinos to attract players with lots of money, and some have begun to offer especially sweet deals. One casino is offering the following: you can gamble as much as you want at the casino. After you are finished, if you are down by any amount from when you started, the casino will refund $x\\%$ of your losses to you. Obviously, if you are ahead, you can keep all of your winnings. There is no time limit or money limit on this offer, but you can redeem it only once.\n\nFor simplicity, assume all bets cost $1$ dollar and pay out $2$ dollars. Now suppose $x$ is $20$. If you make $10$ bets in total before quitting and only $3$ of them pay out, your total loss is $3.2$ dollars. If $6$ of them pay out, you have gained $2$ dollars.\n\nGiven $x$ and the percentage probability $p$ of winning any individual bet, write a program to determine the maximum expected profit you can make from betting at this casino, using any gambling strategy.", "inputFormat": "The input consists of a single test case. A test case consists of the refund percentage $x (0 \\leq x < 100)$ followed by the winning probability percentage $p (0 \\leq p < 50)$. Both $x$ and $p$ have at most two digits after the decimal point.", "outputFormat": "Display the maximum expected profit with an absolute error of at most $10^{-3}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Hey, Better Bettor", "background": "", "description": "> “在赌场里，首要规则是让他们继续玩，让他们不断回来。他们玩得越久，输得越多，最终，我们会赢得一切。”  \n> （摘自 1995 年电影《赌场》）\n\n最近的经济衰退对包括赌博业在内的娱乐场所并不友好。赌场之间竞争激烈，以吸引有钱的玩家，一些赌场开始提供特别优厚的优惠。其中一个赌场提供以下优惠：你可以在赌场里随意赌博。当你结束时，如果你比开始时输了任何金额，赌场将退还你损失的 $x\\%$。显然，如果你赢钱了，你可以保留所有的奖金。此优惠没有时间限制或金额限制，但你只能兑现一次。\n\n为了简化，假设所有赌注的成本为 $1$ 美元，并支付 $2$ 美元。现在假设 $x$ 是 $20$。如果你在退出前总共下注 $10$ 次，只有 $3$ 次获胜，你的总损失是 $3.2$ 美元。如果 $6$ 次获胜，你就赚了 $2$ 美元。\n\n给定 $x$ 和赢得任何单个赌注的概率百分比 $p$，编写一个程序来确定你在这个赌场下注所能获得的最大期望利润，使用任何赌博策略。\n\n输入由一个单一的测试用例组成。测试用例包含退款百分比 $x (0 \\leq x < 100)$，随后是赢得概率百分比 $p (0 \\leq p < 50)$。$x$ 和 $p$ 的小数点后最多有两位数字。\n\n显示最大期望利润，绝对误差不超过 $10^{-3}$。", "inputFormat": "输入由一个单一的测试用例组成。测试用例包含退款百分比 $x (0 \\leq x < 100)$，随后是赢得概率百分比 $p (0 \\leq p < 50)$。$x$ 和 $p$ 的小数点后最多有两位数字。", "outputFormat": "输出最大期望利润，绝对误差不超过 $10^{-3}$。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10617", "type": "P", "difficulty": 0, "samples": [["3 3 2\n1 2 42\n2 3 1\n2 3 1\n2 3", "2"], ["4 4 5\n1 2 5\n1 3 4\n4 2 5\n4 3 6\n4 4 4 4 1", "3"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "O2优化", "ICPC", "WF"], "title": "[ICPC 2013 WF] Surely You Congest", "background": "", "description": "You are in charge of designing an advanced centralized traffic management system for smart cars. The goal is to use global information to instruct morning commuters, who must drive downtown from the suburbs, how best to get to the city center while avoiding traffic jams.\n\nUnfortunately, since commuters know the city and are selfish, you cannot simply tell them to travel routes that take longer than normal (otherwise they will just ignore your directions). You can only convince them to change to different routes that are equally fast.\n\nThe city’s network of roads consists of intersections that are connected by bidirectional roads of various travel times. Each commuter starts at some intersection, which may vary from commuter to commuter. All commuters end their journeys at the same place, which is downtown at intersection 1. If two commuters attempt to start travelling along the same road in the same direction at the same time, there will be congestion; you must avoid this. However, it is fine if two commuters pass through the same intersection simultaneously or if they take the same road starting at different times.\n\nDetermine the maximum number of commuters who can drive downtown without congestion, subject to all commuters starting their journeys at exactly the same time and without any of them taking a suboptimal route.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/74bo2ud4.png)\n\nIn Figure C.1, cars are shown in their original locations. One car is already downtown. Of the cars at intersection 4, one can go along the dotted route through intersection 3, and another along the dashed route through intersection 2. But the remaining two cars cannot reach downtown while avoiding congestion. So a maximum of 3 cars can reach downtown with no congestion.", "inputFormat": "The input consists of a single test case. The first line contains three integers $n, m,$ and $c$, where $n (1 \\leq n \\leq 25 000)$ is the number of intersections, $m (0 \\leq m \\leq 50 000)$ is the number of roads, and $c (0 \\leq c \\leq 1 000)$ is the number of commuters. Each of the next $m$ lines contains three integers $x_i, y_i$, and $t_i$ describing one road, where $x_i$ and $y_i (1 \\leq x_i, y_i \\leq n)$ are the distinct intersections the road connects, and $t_i (1 \\leq t_i \\leq 10 000)$ is the time it takes to travel along that road in either direction. You may assume that downtown is reachable from every intersection. The last line contains $c$ integers listing the starting intersections of the commuters.", "outputFormat": "Display the maximum number of commuters who can reach downtown without congestion.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Surely You Congest", "background": "", "description": "You are in charge of designing an advanced centralized traffic management system for smart cars. The goal is to use global information to instruct morning commuters, who must drive downtown from the suburbs, how best to get to the city center while avoiding traffic jams.\n\nUnfortunately, since commuters know the city and are selfish, you cannot simply tell them to travel routes that take longer than normal (otherwise they will just ignore your directions). You can only convince them to change to different routes that are equally fast.\n\nThe city’s network of roads consists of intersections that are connected by bidirectional roads of various travel times. Each commuter starts at some intersection, which may vary from commuter to commuter. All commuters end their journeys at the same place, which is downtown at intersection 1. If two commuters attempt to start travelling along the same road in the same direction at the same time, there will be congestion; you must avoid this. However, it is fine if two commuters pass through the same intersection simultaneously or if they take the same road starting at different times.\n\nDetermine the maximum number of commuters who can drive downtown without congestion, subject to all commuters starting their journeys at exactly the same time and without any of them taking a suboptimal route.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/74bo2ud4.png)\n\nIn Figure C.1, cars are shown in their original locations. One car is already downtown. Of the cars at intersection 4, one can go along the dotted route through intersection 3, and another along the dashed route through intersection 2. But the remaining two cars cannot reach downtown while avoiding congestion. So a maximum of 3 cars can reach downtown with no congestion.", "inputFormat": "The input consists of a single test case. The first line contains three integers $n, m,$ and $c$, where $n (1 \\leq n \\leq 25 000)$ is the number of intersections, $m (0 \\leq m \\leq 50 000)$ is the number of roads, and $c (0 \\leq c \\leq 1 000)$ is the number of commuters. Each of the next $m$ lines contains three integers $x_i, y_i$, and $t_i$ describing one road, where $x_i$ and $y_i (1 \\leq x_i, y_i \\leq n)$ are the distinct intersections the road connects, and $t_i (1 \\leq t_i \\leq 10 000)$ is the time it takes to travel along that road in either direction. You may assume that downtown is reachable from every intersection. The last line contains $c$ integers listing the starting intersections of the commuters.", "outputFormat": "Display the maximum number of commuters who can reach downtown without congestion.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Surely You Congest", "background": "", "description": "你负责设计一个先进的集中交通管理系统，以便为智能汽车提供服务。目标是利用全局信息指导早晨从郊区驾车前往市中心的通勤者，帮助他们避免交通拥堵。\n\n不幸的是，由于通勤者了解城市且自私，你不能简单地让他们走比平时更慢的路线（否则他们会忽略你的指示）。你只能说服他们改变到同样快的不同路线。\n\n城市的道路网络由连接双向道路的交叉口组成，各条道路的行驶时间不同。每个通勤者从某个交叉口出发，这些交叉口因人而异。所有通勤者的行程终点都是市中心的 1 号交叉口。如果两名通勤者同时在同一方向上行驶在同一条道路上，会造成拥堵；你必须避免这种情况。然而，如果两名通勤者同时经过同一个交叉口或者在不同时间使用同一条道路，这是允许的。\n\n确定在所有通勤者同时开始旅程且没有任何人走次优路线的情况下，最多有多少通勤者可以在不拥堵的情况下开车到市中心。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/74bo2ud4.png)", "inputFormat": "输入由一个单独的测试用例组成。第一行包含三个整数 $n, m, c$，其中 $n (1 \\leq n \\leq 25 000)$ 表示交叉口的数量，$m (0 \\leq m \\leq 50 000)$ 表示道路的数量，$c (0 \\leq c \\leq 1 000)$ 表示通勤者的数量。接下来的 $m$ 行中的每一行包含三个整数 $x_i, y_i, t_i$，描述了一条道路，其中 $x_i$ 和 $y_i (1 \\leq x_i, y_i \\leq n)$ 是道路连接的不同交叉口，$t_i (1 \\leq t_i \\leq 10 000)$ 是沿该道路行驶的时间。最后一行包含 $c$ 个整数，列出了通勤者的起始交叉口。", "outputFormat": "显示最多有多少通勤者可以在不拥堵的情况下到达市中心。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10618", "type": "P", "difficulty": 5, "samples": [["1\n2\n3\n105", "1 2\n2 6\n3 12\n105 720"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "2013", "O2优化", "剪枝", "ICPC", "WF"], "title": "[ICPC 2013 WF] Factors", "background": "", "description": "The fundamental theorem of arithmetic states that every integer greater than $1$ can be uniquely represented as a product of one or more primes. While unique, several arrangements of the prime factors may be possible. For example:\n\n- $10=2\\times 5=5\\times 2$；\n- $20=2\\times 2\\times 5=2\\times 5\\times 2=5\\times 2\\times 2$；\n\nLet $f(k)$ be the number of different arrangements of the prime factors of $k$. So $f(10) = 2$ and $f(20) = 3$.\n\nGiven a positive number $n$, there always exists at least one number $k$ such that $f(k) = n$. We want to know the smallest such $k$.", "inputFormat": "The input consists of at most $1 000$ test cases, each on a separate line. Each test case is a positive integer $n < 2^{63}$.", "outputFormat": "For each test case, display its number $n$ and the smallest number $k > 1$ such that $f(k) = n$. The numbers in the input are chosen such that $k < 2^{63}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Factors", "background": "", "description": "The fundamental theorem of arithmetic states that every integer greater than $1$ can be uniquely represented as a product of one or more primes. While unique, several arrangements of the prime factors may be possible. For example:\n\n- $10=2\\times 5=5\\times 2$；\n- $20=2\\times 2\\times 5=2\\times 5\\times 2=5\\times 2\\times 2$；\n\nLet $f(k)$ be the number of different arrangements of the prime factors of $k$. So $f(10) = 2$ and $f(20) = 3$.\n\nGiven a positive number $n$, there always exists at least one number $k$ such that $f(k) = n$. We want to know the smallest such $k$.", "inputFormat": "The input consists of at most $1 000$ test cases, each on a separate line. Each test case is a positive integer $n < 2^{63}$.", "outputFormat": "For each test case, display its number $n$ and the smallest number $k > 1$ such that $f(k) = n$. The numbers in the input are chosen such that $k < 2^{63}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Factors", "background": "", "description": "算术基本定理指出，每个大于 $1$ 的整数都可以唯一表示为一个或多个素数的乘积。虽然表示是唯一的，但素数因子的排列可能有多种。例如：\n\n- $10=2\\times 5=5\\times 2$；\n- $20=2\\times 2\\times 5=2\\times 5\\times 2=5\\times 2\\times 2$；\n\n令 $f(k)$ 为 $k$ 的素数因子不同排列的数量。因此，$f(10) = 2$ 且 $f(20) = 3$。\n\n给定一个正整数 $n$，总是至少存在一个数字 $k$ 使得 $f(k) = n$。我们想知道最小的这样的 $k$。", "inputFormat": "输入包含最多 $1 000$ 个测试用例，每个测试用例占一行。每个测试用例是一个正整数 $n < 2^{63}$。", "outputFormat": "对于每个测试用例，输出其数字 $n$ 以及最小的 $k > 1$ 使得 $f(k) = n$。输入中的数字选择使得 $k < 2^{63}$。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10619", "type": "P", "difficulty": 0, "samples": [["1 2\nV1 V2 V1 V1 V2", "5"], ["2 1\nV1 V2 V1 V1 V2", "6"], ["1 2\nR10 V1 V2 V1 E", "30"], ["4 1\nV1 R2 V2 V4 R2 V1 E V3 E", "17"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "O2优化", "ICPC", "WF"], "title": "[ICPC 2013 WF] Harvard", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/hb9vxjp8.png)", "description": "The term “Harvard architecture” applies to a computer that has physically separate memories for instructions and data. The term originated with the Harvard Mark I computer, delivered by IBM in 1944, which used paper tape for instructions and relays for data.\n\nSome modern microcontrollers use the Harvard architecture – but not paper tape and relays! Data memory is organized in banks, each containing the same number of data items. Each data-referencing instruction has a byte offset $f$ to a bank, and a bit $a$ that is used to select the bank to be referenced. If $a$ is $0$, then bank $0$ is referenced. If $a$ is $1$, then the value in a *bank select register* (BSR) identifies the bank to be used. Assume each instruction takes the same time to execute, and there is an instruction that can set the BSR’s value.\n\nFor example, suppose there are $4$ banks of $8$ bytes each. To access location $5$, either use a single instruction with $a = 0$ and $f = 5$, or set the BSR to $0$ in one instruction and then use an instruction with $a = 1$ and $f = 5$. The first approach is faster since it does not require setting the BSR.\n\nNow suppose (with the same memory) the location to access is $20$. Only one approach will work here: execute an instruction that sets the BSR to $2$ (unless the BSR already has the value $2$) and then use an instruction with $a = 1$ and $f = 4$.\n\nA program is a sequence of operations. Each operation is either\n\n- a variable reference, written as V$i$, where $i$ is a positive integer, or\n- a repetition, written as R$n$ `<program>` E, where $n$ is a positive integer and `<program>` is an arbitrary program. This operation is equivalent to n sequential occurrences of `<program>`.\n\nYour problem is to determine the minimum running time of programs. In particular, given the number and size of the memory banks and a program to be executed, find the minimum number of instructions (which reference memory location and possibly set the BSR) that must be executed to run the program. To do this you must identify a mapping of variables to memory banks that yields the smallest execution time, and report that execution time – that is, the number of memory references and BSR register settings required. The BSR’s value is initially undefined, and changes only when an instruction explicitly sets its value.", "inputFormat": "The input consists of a single test case. A test case consists of two lines. The first line contains two integers $b$ and $s$, where $1 \\leq b \\leq 13$ is the number of memory banks and $1 \\leq s \\leq 13$ is the number of variables that can be stored in each memory bank. The second line contains a non-empty program with at most $1 000$ space-separated elements (each R$n$, V$i$, and E counts as one element).\n\nYou may assume the following:\n- In a repetition R$n$, the number of repetitions satisfies $1 \\leq n \\leq 10^6$.\n- In a loop operation R$n$ `<program>` E, the loop body `<program>` is not empty.\n- In a variable reference V$i$, the variable index satisfies $1 \\leq i \\leq \\min(b \\times s, 13)$.\n- The total number of variable references performed by an execution of the program is at most $10^{12}$.", "outputFormat": "Display the minimum number of instructions that must be executed to complete the program.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Harvard", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/hb9vxjp8.png)", "description": "The term “Harvard architecture” applies to a computer that has physically separate memories for instructions and data. The term originated with the Harvard Mark I computer, delivered by IBM in 1944, which used paper tape for instructions and relays for data.\n\nSome modern microcontrollers use the Harvard architecture – but not paper tape and relays! Data memory is organized in banks, each containing the same number of data items. Each data-referencing instruction has a byte offset $f$ to a bank, and a bit $a$ that is used to select the bank to be referenced. If $a$ is $0$, then bank $0$ is referenced. If $a$ is $1$, then the value in a *bank select register* (BSR) identifies the bank to be used. Assume each instruction takes the same time to execute, and there is an instruction that can set the BSR’s value.\n\nFor example, suppose there are $4$ banks of $8$ bytes each. To access location $5$, either use a single instruction with $a = 0$ and $f = 5$, or set the BSR to $0$ in one instruction and then use an instruction with $a = 1$ and $f = 5$. The first approach is faster since it does not require setting the BSR.\n\nNow suppose (with the same memory) the location to access is $20$. Only one approach will work here: execute an instruction that sets the BSR to $2$ (unless the BSR already has the value $2$) and then use an instruction with $a = 1$ and $f = 4$.\n\nA program is a sequence of operations. Each operation is either\n\n- a variable reference, written as V$i$, where $i$ is a positive integer, or\n- a repetition, written as R$n$ `<program>` E, where $n$ is a positive integer and `<program>` is an arbitrary program. This operation is equivalent to n sequential occurrences of `<program>`.\n\nYour problem is to determine the minimum running time of programs. In particular, given the number and size of the memory banks and a program to be executed, find the minimum number of instructions (which reference memory location and possibly set the BSR) that must be executed to run the program. To do this you must identify a mapping of variables to memory banks that yields the smallest execution time, and report that execution time – that is, the number of memory references and BSR register settings required. The BSR’s value is initially undefined, and changes only when an instruction explicitly sets its value.", "inputFormat": "The input consists of a single test case. A test case consists of two lines. The first line contains two integers $b$ and $s$, where $1 \\leq b \\leq 13$ is the number of memory banks and $1 \\leq s \\leq 13$ is the number of variables that can be stored in each memory bank. The second line contains a non-empty program with at most $1 000$ space-separated elements (each R$n$, V$i$, and E counts as one element).\n\nYou may assume the following:\n- In a repetition R$n$, the number of repetitions satisfies $1 \\leq n \\leq 10^6$.\n- In a loop operation R$n$ `<program>` E, the loop body `<program>` is not empty.\n- In a variable reference V$i$, the variable index satisfies $1 \\leq i \\leq \\min(b \\times s, 13)$.\n- The total number of variable references performed by an execution of the program is at most $10^{12}$.", "outputFormat": "Display the minimum number of instructions that must be executed to complete the program.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Harvard", "background": "", "description": "“哈佛架构”一词适用于指令和数据具有物理上分开的存储器的计算机。该术语起源于哈佛 Mark I 计算机，由 IBM 于 1944 年交付，该计算机使用纸带作为指令，使用继电器作为数据。\n\n一些现代微控制器使用哈佛架构——但不使用纸带和继电器！数据存储器被组织成多个存储区（bank），每个存储区包含相同数量的数据项。每条引用数据的指令都有一个字节偏移量 $f$ 和一个位 $a$，用于选择要引用的存储区。如果 $a$ 为 $0$，则引用存储区 $0$。如果 $a$ 为 $1$，则在*存储区选择寄存器*（BSR）中的值标识要使用的存储区。假设每条指令执行时间相同，并且存在可以设置 BSR 值的指令。\n\n例如，假设有 $4$ 个存储区，每个存储区有 $8$ 个字节。要访问位置 $5$，可以使用 $a = 0$ 和 $f = 5$ 的单条指令，或者在一条指令中将 BSR 设置为 $0$，然后使用 $a = 1$ 和 $f = 5$ 的指令。第一种方法更快，因为它不需要设置 BSR。\n\n现在假设（使用相同的存储器）要访问的位置是 $20$。这里只能使用一种方法：执行一条指令将 BSR 设置为 $2$（除非 BSR 已经是 $2$），然后使用 $a = 1$ 和 $f = 4$ 的指令。\n\n程序是操作的序列。每个操作可以是\n\n- 变量引用，写作 V$i$，其中 $i$ 是正整数，或\n- 重复，写作 R$n$ `<program>` E，其中 $n$ 是正整数，`<program>` 是任意程序。此操作相当于 `<program>` 的 n 次连续出现。\n\n你的任务是确定程序的最小运行时间。具体来说，给定内存存储区的数量和大小以及要执行的程序，找出必须执行的最小指令数（引用内存位置和可能设置 BSR），以运行程序。为此，你必须确定将变量映射到存储区的方式，以产生最小的执行时间，并报告该执行时间——即完成程序所需的内存引用和 BSR 寄存器设置的数量。BSR 的值最初未定义，仅在指令显式设置其值时更改。", "inputFormat": "输入包含一个测试用例。测试用例包含两行。第一行包含两个整数 $b$ 和 $s$，其中 $1 \\leq b \\leq 13$ 是存储区的数量，$1 \\leq s \\leq 13$ 是每个存储区可以存储的变量数。第二行包含一个非空程序，最多包含 $1 000$ 个用空格分隔的元素（每个 R$n$, V$i$ 和 E 都算作一个元素）。\n\n你可以假设以下几点：\n- 在重复 R$n$ 中，重复次数满足 $1 \\leq n \\leq 10^6$。\n- 在循环操作 R$n$ `<program>` E 中，循环体 `<program>` 不为空。\n- 在变量引用 V$i$ 中，变量索引满足 $1 \\leq i \\leq \\min(b \\times s, 13)$。\n- 程序执行的总变量引用数最多为 $10^{12}$。", "outputFormat": "显示完成程序所需执行的最小指令数。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10620", "type": "P", "difficulty": 4, "samples": [["2 3\n1 2 3 4 5 6 7 8 9 10 11 12", "1"], ["2 2\n3 1 3 3 3 3 3 3", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "二分", "O2优化", "ICPC", "WF"], "title": "[ICPC 2013 WF] Low Power", "background": "", "description": "You are building advanced chips for machines. Making the chips is easy, but the power supply turns out to be an issue since the available batteries have varied power outputs.\n\nConsider the problem of $n$ machines, each with two chips, where each chip is powered by $k$ batteries. Surprisingly, it does not matter how much power each chip gets, but a machine works best when its two chips have power outputs as close as possible. The power output of a chip is simply the smallest power output of its $k$ batteries.\n\nYou have a stockpile of 2nk batteries that you want to assign to the chips. It might not be possible to allocate the batteries so that in every machine both chips have equal power outputs, but you want to allocate them so that the differences are as small as possible. To be precise, you want to tell your customers that in all machines the difference of power outputs of the two chips is at most $d$, and you want to make $d$ as small as possible. To do this you must determine an optimal allocation of the batteries to the machines.\n\nConsider Sample Input $1$. There are $2$ machines, each requiring $3$ batteries per chip, and a supply of batteries with power outputs $1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12$. You can, for instance, assign the batteries with power outputs $1, 3, 5$ to one chip, those with power $2, 4, 12$ to the other chip of the same machine, those with power $6, 8, 9$ to the third chip, and those with power $7, 10, 11$ to the fourth. The power outputs of the chips are $1, 2, 6,$ and $7$, respectively, and the difference between power outputs is $1$ in both machines. Note that there are many other ways to achieve this result.", "inputFormat": "The input consists of a single test case. A test case consists of two lines. The first line contains two positive integers: the number of machines $n$ and the number of batteries per chip $k (2nk \\leq 10^6)$. The second line contains $2nk$ integers $p_i$ specifying the power outputs of the batteries $(1 \\leq p_i \\leq 10^9)$.", "outputFormat": "Display the smallest number $d$ such that you can allocate the batteries so that the difference of power outputs of the two chips in each machine is at most $d$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Low Power", "background": "", "description": "You are building advanced chips for machines. Making the chips is easy, but the power supply turns out to be an issue since the available batteries have varied power outputs.\n\nConsider the problem of $n$ machines, each with two chips, where each chip is powered by $k$ batteries. Surprisingly, it does not matter how much power each chip gets, but a machine works best when its two chips have power outputs as close as possible. The power output of a chip is simply the smallest power output of its $k$ batteries.\n\nYou have a stockpile of 2nk batteries that you want to assign to the chips. It might not be possible to allocate the batteries so that in every machine both chips have equal power outputs, but you want to allocate them so that the differences are as small as possible. To be precise, you want to tell your customers that in all machines the difference of power outputs of the two chips is at most $d$, and you want to make $d$ as small as possible. To do this you must determine an optimal allocation of the batteries to the machines.\n\nConsider Sample Input $1$. There are $2$ machines, each requiring $3$ batteries per chip, and a supply of batteries with power outputs $1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12$. You can, for instance, assign the batteries with power outputs $1, 3, 5$ to one chip, those with power $2, 4, 12$ to the other chip of the same machine, those with power $6, 8, 9$ to the third chip, and those with power $7, 10, 11$ to the fourth. The power outputs of the chips are $1, 2, 6,$ and $7$, respectively, and the difference between power outputs is $1$ in both machines. Note that there are many other ways to achieve this result.", "inputFormat": "The input consists of a single test case. A test case consists of two lines. The first line contains two positive integers: the number of machines $n$ and the number of batteries per chip $k (2nk \\leq 10^6)$. The second line contains $2nk$ integers $p_i$ specifying the power outputs of the batteries $(1 \\leq p_i \\leq 10^9)$.", "outputFormat": "Display the smallest number $d$ such that you can allocate the batteries so that the difference of power outputs of the two chips in each machine is at most $d$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Low Power", "background": "", "description": "你正在为机器制造先进的芯片。制造芯片很容易，但电源供应却成为了一个问题，因为现有电池的输出功率各不相同。\n\n考虑 $n$ 台机器的问题，每台机器有两个芯片，每个芯片由 $k$ 块电池供电。出人意料的是，每个芯片获得的电量多少并不重要，但机器在两个芯片的功率输出尽可能接近时工作效果最佳。芯片的功率输出仅为其 $k$ 块电池中输出功率最小的那块电池的输出。\n\n你有一堆共 $2nk$ 块电池，你需要将它们分配给这些芯片。可能无法分配这些电池使得每台机器的两个芯片的功率输出都相等，但你希望尽量减小它们之间的差异。具体来说，你希望告诉客户，所有机器中两个芯片的功率输出差异至多为 $d$，并且你希望使 $d$ 尽可能小。为此，你必须确定电池分配给机器的最优方案。\n\n考虑样例输入 $1$。有 $2$ 台机器，每个芯片需要 $3$ 块电池，有一组功率输出为 $1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12$ 的电池。你可以例如将输出功率为 $1, 3, 5$ 的电池分配给一个芯片，将输出功率为 $2, 4, 12$ 的电池分配给同一机器的另一个芯片，将输出功率为 $6, 8, 9$ 的电池分配给第三个芯片，将输出功率为 $7, 10, 11$ 的电池分配给第四个芯片。芯片的功率输出分别为 $1, 2, 6, 7$，两台机器中功率输出的差异分别为 $1$。注意，还有许多其他方式可以实现这一结果。", "inputFormat": "输入包含一个测试用例。测试用例包含两行。第一行包含两个正整数：机器的数量 $n$ 和每个芯片所需的电池数 $k$ $(2nk \\leq 10^6)$。第二行包含 $2nk$ 个整数 $p_i$，指定电池的功率输出 $(1 \\leq p_i \\leq 10^9)$。", "outputFormat": "输出一个最小的数字 $d$，使你可以分配这些电池，使每台机器中两个芯片的功率输出差异至多为 $d$。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10621", "type": "P", "difficulty": 7, "samples": [["12 9 9\n1 8\n1 16\n6 16\n9 29\n19 31\n23 24\n30 23\n29 18\n20 12\n22 8\n14 0\n14 8", "10"], ["4 5 7\n10 10\n15 10\n15 17\n10 17", "1"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "O2优化", "ICPC", "WF"], "title": "[ICPC 2013 WF] Map Tiles", "background": "", "description": "Publishing maps is not an easy task. First you need some appropriate transformation to display the earth’s spherical shape in a two-dimensional plane. Then another issue arises – most high-quality maps are too large to be printed on a single page of paper. To cope with that, map publishers often split maps into several rectangular tiles, and print each tile on one page. In this problem, you will examine this “tiling” process.\n\nThe International Cartographic Publishing Company (ICPC) needs to cut their printing costs by minimizing the number of tiles used for their maps. Even with a fixed tile size (determined by the page size) and map scale, you can still optimize the situation by adjusting the tile grid.\nThe left side of Figure G.1 shows 14 map tiles covering a region. The right side shows how you can cover the same region with only 10 tiles, without changing the tile sizes or orientation.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a9a9dj7t.png)\n\nYour task is to help the ICPC find the minimum number of tiles needed to cover a given region. For simplicity, the region will be given as a closed polygon that does not intersect itself. \n\nNote that the tiles must be part of a rectangular grid aligned with the $x$-axis and $y$-axis. That is, they touch each other only with their whole sides and cannot be rotated. Also note that although all input coordinates are integers, tiles may be located at non-integer coordinates.\n\nThe polygon may touch the edges of marginal lines (as in Sample Input 2). However, to avoid floatingpoint issues, you may assume the optimal answer will not change even if the polygon is allowed to go outside the map tiles by a distance of $10^{-6}$.", "inputFormat": "The input consists of a single test case. The first line of a test case contains three integers: $n, x_s$, and $y_s$. The number of polygon vertices is $n (3 \\leq n \\leq 50)$, and $x_s$ and $y_s (1 \\leq x_s, y_s \\leq 100)$ are the dimensions of each tile. Each of the next $n$ lines contains two integers $x$ and $y (0 \\leq x \\leq 10x_s, 0 \\leq y \\leq 10y_s)$, specifying the vertices of the polygon representing the region (in either clockwise or counter-clockwise order).", "outputFormat": "Display the minimal number of tiles necessary to cover the whole interior of the polygon.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Map Tiles", "background": "", "description": "Publishing maps is not an easy task. First you need some appropriate transformation to display the earth’s spherical shape in a two-dimensional plane. Then another issue arises – most high-quality maps are too large to be printed on a single page of paper. To cope with that, map publishers often split maps into several rectangular tiles, and print each tile on one page. In this problem, you will examine this “tiling” process.\n\nThe International Cartographic Publishing Company (ICPC) needs to cut their printing costs by minimizing the number of tiles used for their maps. Even with a fixed tile size (determined by the page size) and map scale, you can still optimize the situation by adjusting the tile grid.\nThe left side of Figure G.1 shows 14 map tiles covering a region. The right side shows how you can cover the same region with only 10 tiles, without changing the tile sizes or orientation.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a9a9dj7t.png)\n\nYour task is to help the ICPC find the minimum number of tiles needed to cover a given region. For simplicity, the region will be given as a closed polygon that does not intersect itself. \n\nNote that the tiles must be part of a rectangular grid aligned with the $x$-axis and $y$-axis. That is, they touch each other only with their whole sides and cannot be rotated. Also note that although all input coordinates are integers, tiles may be located at non-integer coordinates.\n\nThe polygon may touch the edges of marginal lines (as in Sample Input 2). However, to avoid floatingpoint issues, you may assume the optimal answer will not change even if the polygon is allowed to go outside the map tiles by a distance of $10^{-6}$.", "inputFormat": "The input consists of a single test case. The first line of a test case contains three integers: $n, x_s$, and $y_s$. The number of polygon vertices is $n (3 \\leq n \\leq 50)$, and $x_s$ and $y_s (1 \\leq x_s, y_s \\leq 100)$ are the dimensions of each tile. Each of the next $n$ lines contains two integers $x$ and $y (0 \\leq x \\leq 10x_s, 0 \\leq y \\leq 10y_s)$, specifying the vertices of the polygon representing the region (in either clockwise or counter-clockwise order).", "outputFormat": "Display the minimal number of tiles necessary to cover the whole interior of the polygon.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Map Tiles", "background": "", "description": "出版地图并非易事。首先，你需要进行适当的变换，以在二维平面上显示地球的球形形状。接着出现另一个问题——大多数高质量的地图都太大，无法印在一页纸上。为了解决这个问题，地图出版商通常将地图分割成若干个矩形块，并在每页上打印一个块。在这个问题中，你将研究这种“瓦片化”过程。\n\n国际制图出版公司（ICPC）需要通过最小化用于其地图的瓦片数量来削减印刷成本。即使固定了瓦片大小（由页面大小决定）和地图比例，你仍然可以通过调整瓦片网格来优化情况。图 G.1 的左侧显示了覆盖一个区域的 14 个地图瓦片。右侧显示了如何在不改变瓦片大小或方向的情况下，仅用 10 个瓦片覆盖相同的区域。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a9a9dj7t.png)\n\n你的任务是帮助 ICPC 找出覆盖给定区域所需的最少瓦片数量。为简化起见，该区域将给出为不自相交的闭合多边形。\n\n请注意，瓦片必须是与 $x$ 轴和 $y$ 轴对齐的矩形网格的一部分。也就是说，它们只能用完整的边接触，不能旋转。另外，尽管所有输入坐标都是整数，瓦片的位置可以是非整数坐标。\n\n多边形可能接触边界线的边缘（如样例输入 2 中所示）。但是，为避免浮点数问题，可以假设即使允许多边形超出地图瓦片的距离为 $10^{-6}$，最优答案也不会改变。", "inputFormat": "输入包含一个测试用例。测试用例的第一行包含三个整数：$n, x_s$ 和 $y_s$。多边形的顶点数为 $n (3 \\leq n \\leq 50)$，$x_s$ 和 $y_s (1 \\leq x_s, y_s \\leq 100)$ 是每个瓦片的尺寸。接下来的 $n$ 行中的每一行包含两个整数 $x$ 和 $y (0 \\leq x \\leq 10x_s, 0 \\leq y \\leq 10y_s)$，指定表示区域的多边形的顶点（按顺时针或逆时针顺序）。", "outputFormat": "输出覆盖多边形的整个内部所需的最少瓦片数量。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10622", "type": "P", "difficulty": 6, "samples": [["7\n1 2 1 2 4 3 3", "Impossible"], ["7\n1 2 3 2 4 1 3\n", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "O2优化", "ICPC", "WF"], "title": "[ICPC 2013 WF] Matryoshka", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/tsc2hi05.png)", "description": "Matryoshkas are sets of traditional Russian wooden dolls of decreasing size placed one inside the other. A matryoshka doll can be opened to reveal a smaller figure of the same sort inside, which has, in turn, another figure inside, and so on.\n\nThe Russian Matryoshka Museum recently exhibited a collection of similarly designed matryoshka sets, differing only in the number of nested dolls in each set. Unfortunately, some over-zealous (and obviously unsupervised) children separated these sets, placing all the individual dolls in a row. There are $n$ dolls in the row, each with an integer size. You need to reassemble the matryoshka sets, knowing neither the number of sets nor the number of dolls in each set. You know only that every complete set consists of dolls with consecutive sizes from $1$ to some number $m$, which may vary between the different sets.\n\nWhen reassembling the sets, you must follow these rules:\n- You can put a doll or a nested group of dolls only inside a larger doll.\n- You can combine two groups of dolls only if they are adjacent in the row.\n- Once a doll becomes a member of a group, it cannot be transferred to another group or permanently separated from the group. It can be temporarily separated only when combining two groups.\n\nYour time is valuable, and you want to do this reassembly process as quickly as possible. The only time-consuming part of this task is opening and subsequently closing a doll, so you want to minimize how often you do this. For example, the minimum number of openings (and subsequent closings) when combining group $[1, 2, 6]$ with the group $[4]$ is two, since you have to open the dolls with sizes $6$ and $4$. When combining group $[1, 2, 5]$ with the group $[3, 4]$, you need to perform three openings.\n\nWrite a program to calculate the minimum number of openings required to combine all disassembled matryoshka sets.", "inputFormat": "The input consists of a single test case. A test case consists of two lines. The first line contains one integer $n (1 \\leq n \\leq 500)$ representing the number of individual dolls in the row. The second line contains $n$ positive integers specifying the sizes of the dolls in the order they appear in the row. Each size is between $1$ and $500$ inclusive.", "outputFormat": "Display the minimum number of openings required when reassembling the matryoshka sets. If reassembling cannot be done (some of the kids might have been excessively zealous and taken some dolls), display the word `Impossible`.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Matryoshka", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/tsc2hi05.png)", "description": "Matryoshkas are sets of traditional Russian wooden dolls of decreasing size placed one inside the other. A matryoshka doll can be opened to reveal a smaller figure of the same sort inside, which has, in turn, another figure inside, and so on.\n\nThe Russian Matryoshka Museum recently exhibited a collection of similarly designed matryoshka sets, differing only in the number of nested dolls in each set. Unfortunately, some over-zealous (and obviously unsupervised) children separated these sets, placing all the individual dolls in a row. There are $n$ dolls in the row, each with an integer size. You need to reassemble the matryoshka sets, knowing neither the number of sets nor the number of dolls in each set. You know only that every complete set consists of dolls with consecutive sizes from $1$ to some number $m$, which may vary between the different sets.\n\nWhen reassembling the sets, you must follow these rules:\n- You can put a doll or a nested group of dolls only inside a larger doll.\n- You can combine two groups of dolls only if they are adjacent in the row.\n- Once a doll becomes a member of a group, it cannot be transferred to another group or permanently separated from the group. It can be temporarily separated only when combining two groups.\n\nYour time is valuable, and you want to do this reassembly process as quickly as possible. The only time-consuming part of this task is opening and subsequently closing a doll, so you want to minimize how often you do this. For example, the minimum number of openings (and subsequent closings) when combining group $[1, 2, 6]$ with the group $[4]$ is two, since you have to open the dolls with sizes $6$ and $4$. When combining group $[1, 2, 5]$ with the group $[3, 4]$, you need to perform three openings.\n\nWrite a program to calculate the minimum number of openings required to combine all disassembled matryoshka sets.", "inputFormat": "The input consists of a single test case. A test case consists of two lines. The first line contains one integer $n (1 \\leq n \\leq 500)$ representing the number of individual dolls in the row. The second line contains $n$ positive integers specifying the sizes of the dolls in the order they appear in the row. Each size is between $1$ and $500$ inclusive.", "outputFormat": "Display the minimum number of openings required when reassembling the matryoshka sets. If reassembling cannot be done (some of the kids might have been excessively zealous and taken some dolls), display the word `Impossible`.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Matryoshka", "background": "", "description": "套娃是俄罗斯传统木制玩具，由一组逐渐变小的娃娃组成，依次放置在另一个娃娃内部。一个套娃可以打开，露出一个更小的类似玩偶，而这个玩偶内部又有另一个玩偶，以此类推。\n\n俄罗斯套娃博物馆最近展出了一系列设计相似的套娃，不同之处仅在于每套娃娃中嵌套的数量不同。不幸的是，一些过于热心（显然没有得到监督）的孩子把这些套娃拆散了，并将所有的单个娃娃排成一行。现在这一行中有 $n$ 个娃娃，每个都有一个整数大小。你需要重新组装这些套娃，既不知道套娃的数量，也不知道每套娃娃中娃娃的数量。你只知道每套完整的套娃由大小从 $1$ 到某个数字 $m$ 的连续大小的娃娃组成，而这个数字 $m$ 在不同的套娃中可能有所不同。\n\n在重新组装套娃时，你必须遵循以下规则：\n- 你只能将一个娃娃或一个嵌套的娃娃组放入一个更大的娃娃中。\n- 你只能合并两个在行中相邻的娃娃组。\n- 一旦一个娃娃成为一个组的成员，它不能被转移到另一个组或永久地从组中分离。它只能在合并两个组时暂时分离。\n\n你的时间非常宝贵，你希望尽快完成这个重新组装过程。这个任务中唯一耗时的部分是打开和随后关闭一个娃娃，因此你希望尽量减少这样的操作次数。例如，当将组 $[1, 2, 6]$ 与组 $[4]$ 合并时，最少需要进行两次开关操作，因为你必须打开大小为 $6$ 和 $4$ 的娃娃。而当将组 $[1, 2, 5]$ 与组 $[3, 4]$ 合并时，需要进行三次开关操作。\n\n编写一个程序计算重新组装所有拆散的套娃所需的最少开关次数。", "inputFormat": "输入包含一个测试用例。测试用例由两行组成。第一行包含一个整数 $n (1 \\leq n \\leq 500)$，表示行中单个娃娃的数量。第二行包含 $n$ 个正整数，按照它们在行中出现的顺序指定娃娃的大小。每个大小在 $1$ 到 $500$ 之间（包括 $1$ 和 $500$）。", "outputFormat": "输出重新组装套娃所需的最少开关次数。如果重新组装无法完成（可能有些孩子过于热心，带走了一些娃娃），则输出 `Impossible`。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10623", "type": "P", "difficulty": 0, "samples": [["3 1 2 3\n2 1 1\n2 2 1", "4"], ["4 1 1 5\n2 0 2 2 2", "12"], ["2 3 3 5\n2 2 2 2 2\n2 2 2 2 2\n2 2 2 2 2", "18"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "O2优化", "ICPC", "WF"], "title": "[ICPC 2013 WF] Pirate Chest", "background": "", "description": "Pirate Dick finally had enough of fighting, marauding, theft, and making life miserable for many on the open seas. So he decided to retire, and he found the perfect island to spend the rest of his days on, provided he does not run out of money. He has plenty of gold coins now, and he wants to store them in a chest (he is a pirate after all). Dick can construct a rectangular chest with integer dimensions of any size up to a specified maximum size for the top but with an arbitrary integer height. Now he needs a place to hide the chest. While exploring the island, he found the perfect solution.\n\nDick will hide his chest by submerging it in a murky pond. The pond has a rectangular surface, and it completely fills the bottom of a valley that has high vertical rocky walls. Dick surveyed the pond and knows its depth for each of the squares of a Cartesian coordinate grid system placed on the pond surface. When Dick submerges the chest, it will sink as far as possible until it touches the bottom. The top of the chest will remain parallel to the pond’s surface and the chest will be aligned with the grid squares. The water displaced by the submerged chest will raise the level of the pond’s surface (this will occur even if there is no space around the chest for the displaced water to rise). The walls of the valley are high enough that the water can never splash out of the valley. Of course, since the chest must be invisible, its top must be strictly below the surface of the pond. Your job is to find the volume of the largest chest that\nPirate Dick can hide this way.\n\nIn Figure I.1, the leftmost image shows a pond, the middle image shows a possible placement of a chest of volume 3, and the rightmost image shows a placement of a chest of volume 4, which is the maximum possible volume. Note that if the second chest were made one unit taller, its top would be visible because it would be at exactly the same height as the surface of the water.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6hz0e4z8.png)", "inputFormat": "The input consists of a single test case. A test case starts with a line containing four integers $a, b, m$, and $n (1 \\leq a, b, m, n \\leq 500)$. The pond’s surface dimensions are $m \\times n$ and the maximum size of the top (and bottom) of the chest is $a \\times b$. In addition, $a$ and $b$ are small enough that it is not possible to cover the entire pond with a chest with top size $a \\times b$. Each of the remaining $m$ lines in a test case contains $n$ integers $d_{i,j}$ specifying the pond’s depth at grid square $(i, j)$, where $0 \\leq d_{i,j} ≤ 10^9$ for each $1 \\leq i \\leq m$ and $1 \\leq j \\leq n$.", "outputFormat": "Display the maximum volume of a rectangular chest with integer dimensions (where one of the dimensions of the top is bounded by $a$ and the other is bounded by $b$) that can be completely submerged below the surface of the pond. If no chest can be hidden in the pond, display $0$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Pirate Chest", "background": "", "description": "Pirate Dick finally had enough of fighting, marauding, theft, and making life miserable for many on the open seas. So he decided to retire, and he found the perfect island to spend the rest of his days on, provided he does not run out of money. He has plenty of gold coins now, and he wants to store them in a chest (he is a pirate after all). Dick can construct a rectangular chest with integer dimensions of any size up to a specified maximum size for the top but with an arbitrary integer height. Now he needs a place to hide the chest. While exploring the island, he found the perfect solution.\n\nDick will hide his chest by submerging it in a murky pond. The pond has a rectangular surface, and it completely fills the bottom of a valley that has high vertical rocky walls. Dick surveyed the pond and knows its depth for each of the squares of a Cartesian coordinate grid system placed on the pond surface. When Dick submerges the chest, it will sink as far as possible until it touches the bottom. The top of the chest will remain parallel to the pond’s surface and the chest will be aligned with the grid squares. The water displaced by the submerged chest will raise the level of the pond’s surface (this will occur even if there is no space around the chest for the displaced water to rise). The walls of the valley are high enough that the water can never splash out of the valley. Of course, since the chest must be invisible, its top must be strictly below the surface of the pond. Your job is to find the volume of the largest chest that\nPirate Dick can hide this way.\n\nIn Figure I.1, the leftmost image shows a pond, the middle image shows a possible placement of a chest of volume 3, and the rightmost image shows a placement of a chest of volume 4, which is the maximum possible volume. Note that if the second chest were made one unit taller, its top would be visible because it would be at exactly the same height as the surface of the water.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6hz0e4z8.png)", "inputFormat": "The input consists of a single test case. A test case starts with a line containing four integers $a, b, m$, and $n (1 \\leq a, b, m, n \\leq 500)$. The pond’s surface dimensions are $m \\times n$ and the maximum size of the top (and bottom) of the chest is $a \\times b$. In addition, $a$ and $b$ are small enough that it is not possible to cover the entire pond with a chest with top size $a \\times b$. Each of the remaining $m$ lines in a test case contains $n$ integers $d_{i,j}$ specifying the pond’s depth at grid square $(i, j)$, where $0 \\leq d_{i,j} ≤ 10^9$ for each $1 \\leq i \\leq m$ and $1 \\leq j \\leq n$.", "outputFormat": "Display the maximum volume of a rectangular chest with integer dimensions (where one of the dimensions of the top is bounded by $a$ and the other is bounded by $b$) that can be completely submerged below the surface of the pond. If no chest can be hidden in the pond, display $0$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Pirate Chest", "background": "", "description": "海盗迪克终于厌倦了战斗、抢劫、偷窃，以及在开阔海域上给许多人带来的痛苦。因此，他决定退休，并找到了一个完美的岛屿，打算在那里度过余生，只要他不用尽光金币就行。他现在有大量的金币，想要把它们存放在一个箱子里（毕竟他是海盗）。迪克可以制造一个整数尺寸的矩形箱子，顶部尺寸的大小可以高达指定的最大尺寸，但高度可以是任意整数。现在他需要一个地方来隐藏这个箱子。在探索岛屿时，他找到了一个完美的解决方案。\n\n迪克将把他的箱子藏在一个混浊的池塘中。池塘有一个矩形的表面，并完全填满了一个有高垂直岩壁的山谷底部。迪克调查了池塘，并了解到每个笛卡尔坐标网格系统方格的深度。当迪克将箱子浸入水中时，它将尽可能沉入，直到触及底部。箱子的顶部将保持与池塘表面平行，并且箱子将与网格方格对齐。被浸入水中的箱子所排开的水将抬高池塘表面的水平（即使周围没有空间供排开的水升起）。山谷的岩壁足够高，以至于水永远不会溅出山谷。当然，由于箱子必须看不见，它的顶部必须严格低于池塘表面。你的任务是找出海盗迪克能够用这种方式隐藏的最大箱子的容积。\n\n在图 I.1 中，最左边的图像显示了一个池塘，中间的图像显示了一个容积为 3 的箱子的可能摆放方式，最右边的图像显示了容积为 4 的箱子的摆放方式，这是可能的最大容积。请注意，如果第二个箱子的高度再增加一个单位，它的顶部将会可见，因为它的高度与水表面正好相同。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6hz0e4z8.png)", "inputFormat": "输入包含一个测试用例。测试用例以一行四个整数 $a, b, m, n (1 \\leq a, b, m, n \\leq 500)$ 开始。池塘表面的尺寸为 $m \\times n$，箱子顶部（和底部）的最大尺寸为 $a \\times b$。此外，$a$ 和 $b$ 足够小，不能用顶部尺寸为 $a \\times b$ 的箱子覆盖整个池塘。在测试用例的其余部分，每个深度的 $m$ 行中包含 $n$ 个整数 $d_{i,j}$，指定网格方格 $(i, j)$ 处的池塘深度，其中对于每个 $1 \\leq i \\leq m$ 和 $1 \\leq j \\leq n$，$0 \\leq d_{i,j} \\leq 10^9$。", "outputFormat": "显示能够完全浸入池塘表面以下的最大矩形箱子的容积。如果无法在池塘中隐藏箱子，则显示 $0$。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10624", "type": "P", "difficulty": 6, "samples": [["6 10\n-8 2\n8 2\n8 14\n0 14\n0 6\n-8 14", "101.576437872"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["计算几何", "2013", "Special Judge", "O2优化", "积分", "定积分", "线段相交", "扫描线", "ICPC", "WF"], "title": "[ICPC 2013 WF] Pollution Solution", "background": "", "description": "As an employee of Aqueous Contaminate Management, you must monitor the pollution that gets dumped (sometimes accidentally, sometimes purposefully) into rivers, lakes and oceans. One of your jobs is to measure the impact of the pollution on various ecosystems in the water such as coral reefs, spawning grounds, and so on.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k4nih8sh.png)\n\nThe model you use in your analysis is illustrated in Figure J.1. The shoreline (the horizontal line in the figure) lies on the $x$-axis with the source of the pollution located at the origin $(0,0)$. The spread of the pollution into the water is represented by the semicircle, and the polygon represents the ecosystem of concern. You must determine the area of the ecosystem that is contaminated, represented by the dark blue region in the figure.", "inputFormat": "The input consists of a single test case. A test case starts with a line containing two integers n and $r$, where $3 \\leq n \\leq 100$ is the number of vertices in the polygon and $1 \\leq r \\leq 1 000$ is the radius of the pollution field. This is followed by $n$ lines, each containing two integers $x_i, y_i$, giving the coordinates of the polygon vertices in counter-clockwise order, where $-1 500 \\leq x_i \\leq 1 500$ and $0 \\leq y_i \\leq 1 500$. The polygon does not self-intersect or touch itself. No vertex lies on the circle boundary.", "outputFormat": "Display the area of the polygon that falls within the semicircle centered at the origin with radius $r$. Give the result with an absolute error of at most $10^{-3}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Pollution Solution", "background": "", "description": "As an employee of Aqueous Contaminate Management, you must monitor the pollution that gets dumped (sometimes accidentally, sometimes purposefully) into rivers, lakes and oceans. One of your jobs is to measure the impact of the pollution on various ecosystems in the water such as coral reefs, spawning grounds, and so on.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k4nih8sh.png)\n\nThe model you use in your analysis is illustrated in Figure J.1. The shoreline (the horizontal line in the figure) lies on the $x$-axis with the source of the pollution located at the origin $(0,0)$. The spread of the pollution into the water is represented by the semicircle, and the polygon represents the ecosystem of concern. You must determine the area of the ecosystem that is contaminated, represented by the dark blue region in the figure.", "inputFormat": "The input consists of a single test case. A test case starts with a line containing two integers n and $r$, where $3 \\leq n \\leq 100$ is the number of vertices in the polygon and $1 \\leq r \\leq 1 000$ is the radius of the pollution field. This is followed by $n$ lines, each containing two integers $x_i, y_i$, giving the coordinates of the polygon vertices in counter-clockwise order, where $-1 500 \\leq x_i \\leq 1 500$ and $0 \\leq y_i \\leq 1 500$. The polygon does not self-intersect or touch itself. No vertex lies on the circle boundary.", "outputFormat": "Display the area of the polygon that falls within the semicircle centered at the origin with radius $r$. Give the result with an absolute error of at most $10^{-3}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Pollution Solution", "background": "", "description": "作为水污染管理公司的员工，你必须监测被排放到河流、湖泊和海洋中的污染物（有时是意外的，有时是故意的）。你的工作之一是测量污染对水中各种生态系统的影响，如珊瑚礁、产卵场所等。\n\n![Illustration](https://cdn.luogu.com.cn/upload/image_hosting/k4nih8sh.png)\n\n你在分析中使用的模型如图 J.1 所示。岸线（图中的水平线）位于 $x$ 轴上，污染源位于原点 $(0,0)$ 处。污染物在水中的扩散由半圆表示，多边形表示了关注的生态系统。你需要确定被污染的生态系统区域的面积，即图中的深蓝色区域。", "inputFormat": "输入包含一个测试用例。测试用例以一行两个整数 $n$ 和 $r$ 开始，其中 $3 \\leq n \\leq 100$ 是多边形顶点的数量，$1 \\leq r \\leq 1,000$ 是污染场的半径。接下来的 $n$ 行，每行包含两个整数 $x_i, y_i$，表示多边形顶点的坐标，顺时针给出，其中 $-1,500 \\leq x_i \\leq 1,500$ 且 $0 \\leq y_i \\leq 1,500$。多边形不自相交或自交。没有顶点位于半圆边界上。", "outputFormat": "显示位于以原点为中心、半径为 $r$ 的半圆内的多边形的面积。结果的绝对误差不超过 $10^{-3}$。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10625", "type": "P", "difficulty": 0, "samples": [["HFBIGEDCJA\nBIGEDCJFAH\nBIGEDCJFAH", "Pre Post In Post In Pre\nHFBJCDEGIA\nBIGEDCJFAH\nIGEDCJBAFH"], ["BNLFAGHPEDOCMJIK\nNLBGAPHCODEIJMKF\nNLFAGHPEDOCMJIKB", "In Pre In Post Post Pre\nBLNFKMEHAGPCODIJ\nNLBAGHPEODCMIJKF\nNLGAPHDOCEJIMKFB\nPost Pre In In Post Pre\nBLNFKICPGAHEODMJ\nNLBGAPHCODEIJMKF\nNLAGHPDOECJMIKFB"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "O2优化", "ICPC", "WF"], "title": "[ICPC 2013 WF] Up a Tree", "background": "", "description": "Anatoly Cheng McDougal is a typical student in many ways. Whenever possible he tries to cut and paste code instead of writing it from scratch. Unavoidably this approach causes him problems. For example, when he first learned about preorder, inorder and postorder traversals of trees, and was given code for a preorder print of a tree (shown on the left below), he simply cut and pasted the code, then moved the print statement to the correct location and renamed the procedure. However, he forgot to rename the procedure calls inside the code, resulting in the defective inorder print and postorder print code shown below.\n\n```cpp\nvoid prePrint(TNode t)\n{\n    output(t.value);\n    if (t.left != null)\n        prePrint(t.left);\n    if (t.right != null)\n        prePrint(t.right);\n}\nvoid inPrint(TNode t)\n{\n    if (t.left != null)\n        prePrint(t.left);\n    output(t.value);\n    if (t.right != null)\n        prePrint(t.right);\n}\nvoid postPrint(TNode t)\n{\n    if (t.left != null)\n        prePrint(t.left);\n    if (t.right != null)\n        prePrint(t.right);\n    output(t.value);\n}\n```\n\nAt this point, Anatoly did not behave like a typical student. He actually tested his code! Unfortunately, when the results were not correct, he reverted back to typical student behavior. He panicked and started randomly changing calls in all three procedures, hoping to get things right. Needless to say, the situation became even worse now than when he started.\n\nAnatoly’s professor tested the code on a random tree of characters. When she looked at the output of his three print routines, she correctly guessed what had happened. However, instead of going directly to his code, she decided to try to reconstruct Anatoly’s code just by observing the output. In order to do this, she correctly made the following assumptions:\n\n1. The output statement in each print routine is in the correct location (for example, between the two recursive calls in the inPrint routine).\n2. Among the six recursive calls made by the three routines, exactly two calls are to prePrint, exactly two are to inPrint, and exactly two are to postPrint, though potentially in the wrong routines.\n\nSoon the professor realized that reconstructing Anatoly’s code and the test tree from his output was not a simple task and that the result might be ambiguous. You will have to help her find all possible reconstructions of Anatoly’s code. In addition, for each such reconstruction, you are to find the alphabetically first tree (as described in the output section) giving the observed output.", "inputFormat": "The input consists of a single test case. A test case consists of three strings on three separate lines: the observed output of Anatoly’s `prePrint`, `inPrint` and `postPrint` routines (in that order) on some test tree. Each of these strings consists of $n$ uppercase letters $(4 \\leq n \\leq 26)$, with no repeated letters in any string. The test case is guaranteed to have at least one solution.", "outputFormat": "Display all possible reconstructions for the test case, ordered as described in the last paragraph below. The output for each reconstruction consists of two parts. The first part is a single line and describes the six calls in Anatoly’s routines: first the two (recursive) calls in Anatoly’s `prePrint` routine, followed by the calls in his `inPrint` routine, and finally the calls in his `postPrint` routine. The calls are described by the words `Pre`, `In`, and `Post`, separated by spaces. For example, if Anatoly’s routines were correct, the resulting output of the first part of the reconstruction would be `Pre Pre In In Post Post`.\n\nThe second part consists of three lines and describes the first test tree that could have generated the observed outputs. The first line is the *correct* preorder print of the tree, and the second and third lines contain the correct inorder and postorder prints, respectively. The first tree is the one with the alphabetically first preorder print. If there are multiple such trees, the first of these is the one with the alphabetically first inorder print.\n\nEvery reconstruction is a sequence of $6$ tokens chosen from `Pre`, `In`, and `Post`. The ordering of reconstructions is lexicographic with respect to the following ordering of tokens: Pre < In < Post.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2013 WF] Up a Tree", "background": "", "description": "Anatoly Cheng McDougal is a typical student in many ways. Whenever possible he tries to cut and paste code instead of writing it from scratch. Unavoidably this approach causes him problems. For example, when he first learned about preorder, inorder and postorder traversals of trees, and was given code for a preorder print of a tree (shown on the left below), he simply cut and pasted the code, then moved the print statement to the correct location and renamed the procedure. However, he forgot to rename the procedure calls inside the code, resulting in the defective inorder print and postorder print code shown below.\n\n```cpp\nvoid prePrint(TNode t)\n{\n    output(t.value);\n    if (t.left != null)\n        prePrint(t.left);\n    if (t.right != null)\n        prePrint(t.right);\n}\nvoid inPrint(TNode t)\n{\n    if (t.left != null)\n        prePrint(t.left);\n    output(t.value);\n    if (t.right != null)\n        prePrint(t.right);\n}\nvoid postPrint(TNode t)\n{\n    if (t.left != null)\n        prePrint(t.left);\n    if (t.right != null)\n        prePrint(t.right);\n    output(t.value);\n}\n```\n\nAt this point, Anatoly did not behave like a typical student. He actually tested his code! Unfortunately, when the results were not correct, he reverted back to typical student behavior. He panicked and started randomly changing calls in all three procedures, hoping to get things right. Needless to say, the situation became even worse now than when he started.\n\nAnatoly’s professor tested the code on a random tree of characters. When she looked at the output of his three print routines, she correctly guessed what had happened. However, instead of going directly to his code, she decided to try to reconstruct Anatoly’s code just by observing the output. In order to do this, she correctly made the following assumptions:\n\n1. The output statement in each print routine is in the correct location (for example, between the two recursive calls in the inPrint routine).\n2. Among the six recursive calls made by the three routines, exactly two calls are to prePrint, exactly two are to inPrint, and exactly two are to postPrint, though potentially in the wrong routines.\n\nSoon the professor realized that reconstructing Anatoly’s code and the test tree from his output was not a simple task and that the result might be ambiguous. You will have to help her find all possible reconstructions of Anatoly’s code. In addition, for each such reconstruction, you are to find the alphabetically first tree (as described in the output section) giving the observed output.", "inputFormat": "The input consists of a single test case. A test case consists of three strings on three separate lines: the observed output of Anatoly’s `prePrint`, `inPrint` and `postPrint` routines (in that order) on some test tree. Each of these strings consists of $n$ uppercase letters $(4 \\leq n \\leq 26)$, with no repeated letters in any string. The test case is guaranteed to have at least one solution.", "outputFormat": "Display all possible reconstructions for the test case, ordered as described in the last paragraph below. The output for each reconstruction consists of two parts. The first part is a single line and describes the six calls in Anatoly’s routines: first the two (recursive) calls in Anatoly’s `prePrint` routine, followed by the calls in his `inPrint` routine, and finally the calls in his `postPrint` routine. The calls are described by the words `Pre`, `In`, and `Post`, separated by spaces. For example, if Anatoly’s routines were correct, the resulting output of the first part of the reconstruction would be `Pre Pre In In Post Post`.\n\nThe second part consists of three lines and describes the first test tree that could have generated the observed outputs. The first line is the *correct* preorder print of the tree, and the second and third lines contain the correct inorder and postorder prints, respectively. The first tree is the one with the alphabetically first preorder print. If there are multiple such trees, the first of these is the one with the alphabetically first inorder print.\n\nEvery reconstruction is a sequence of $6$ tokens chosen from `Pre`, `In`, and `Post`. The ordering of reconstructions is lexicographic with respect to the following ordering of tokens: Pre < In < Post.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2013 WF] Up a Tree", "background": "", "description": "Anatoly Cheng McDougal 在许多方面都是典型的学生。每当可能时，他都会尝试剪切和粘贴代码，而不是从头开始编写。不可避免地，这种方法给他带来了问题。例如，当他第一次学习树的前序、中序和后序遍历，并获得了前序打印树的代码（如下面左侧所示），他只是简单地剪切和粘贴代码，然后将打印语句移动到正确的位置并重命名过程。然而，他忘记了在代码内部重命名过程调用，导致了下面有缺陷的中序打印和后序打印代码。\n\n```cpp\nvoid prePrint(TNode t)\n{\n    output(t.value);\n    if (t.left != null)\n        prePrint(t.left);\n    if (t.right != null)\n        prePrint(t.right);\n}\nvoid inPrint(TNode t)\n{\n    if (t.left != null)\n        prePrint(t.left);\n    output(t.value);\n    if (t.right != null)\n        prePrint(t.right);\n}\nvoid postPrint(TNode t)\n{\n    if (t.left != null)\n        prePrint(t.left);\n    if (t.right != null)\n        prePrint(t.right);\n    output(t.value);\n}\n```\n\n此时，Anatoly 不像典型的学生那样行事。他实际上测试了他的代码！不幸的是，当结果不正确时，他又恢复了典型的学生行为。他慌乱了，开始随机更改所有三个过程中的调用，希望能弄对。不用说，现在的情况比他刚开始时更糟糕了。\n\nAnatoly 的教授在一个随机的字符树上测试了代码。当她查看他三个打印例程的输出时，她正确猜测到发生了什么。然而，她没有直接查看他的代码，而是决定仅通过观察输出来重建Anatoly的代码。为了做到这一点，她正确地做出了以下假设：\n\n1. 每个打印例程中的输出语句在正确的位置（例如，在 `inPrint` 例程中的两个递归调用之间）。\n2. 在三个例程中进行的六次递归调用中，恰好有两次调用 `prePrint`，两次调用 `inPrint` 和两次调用 `postPrint`，尽管它们可能在错误的例程中。\n\n不久，教授意识到从Anatoly的输出重建代码和测试树并不是一件简单的任务，结果可能是模棱两可的。你需要帮助她找出所有可能的Anatoly代码重建方式。此外，对于每种重建方式，你需要找出字母顺序最早的树（如下面输出部分所描述的）。", "inputFormat": "输入包含一个测试用例。一个测试用例由三行字符串组成：Anatoly 的 `prePrint`、`inPrint` 和 `postPrint` 例程在某个测试树上的观察输出（按顺序）。每个字符串由 $n$ 个大写字母组成（$4 \\leq n \\leq 26$），每个字符串中没有重复的字母。保证测试用例至少有一种解决方案。", "outputFormat": "显示测试用例的所有可能重建方式，按照以下最后一段中描述的顺序排序。每种重建方式的输出分为两部分。第一部分是单行描述Anatoly例程中的六次调用：首先是Anatoly的 `prePrint` 例程中的两次（递归）调用，然后是 `inPrint` 例程中的调用，最后是 `postPrint` 例程中的调用。调用由单词 `Pre`、`In` 和 `Post` 描述，用空格分隔。例如，如果Anatoly的例程是正确的，则重建方式的第一部分的输出将是 `Pre Pre In In Post Post`。\n\n第二部分包括三行，描述能够生成观察输出的第一棵树。第一行是树的正确前序遍历打印，第二行和第三行分别包含正确的中序遍历和后序遍历打印。第一棵树是按字母顺序最早的前序打印树。如果有多棵这样的树，则选择其中前序打印字母顺序最早的树。\n\n每种重建方式都是从 `Pre`、`In` 和 `Post` 中选择的六个标记的序列。重建方式的排序是按照以下标记的词法顺序：`Pre` < `In` < `Post`。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10626", "type": "P", "difficulty": 6, "samples": [["15 5\n(![2]|[3])&![4]\n1\n2\n3\n4\n5", "True\nFalse\nTrue\nFalse\nFalse"], ["20 4\n(!![23])^((([116])))\n54\n1\n200\n89", "True\nFalse\nFalse\nTrue"], ["32 4\n[2]|[5]&[1]|(([1000000000])|[7])\n4\n10\n6\n1", "True\nTrue\nTrue\nFalse"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "线段树", "树上启发式合并", "2024", "树链剖分", "动态树 LCT", "JOI（日本）"], "title": "[JOI Open 2024] 考试 2 / Examination 2", "background": null, "description": "JOI 君在 IOI 高中上学，期末考试即将来临。考试的内容是计算 **IOI 函数**。IOI 函数是将 $[1,10^9]$ 之间的整数映射到布尔值（即 $\\texttt{True}/\\texttt{False}$）的函数。IOI 函数可以从以下六条 IOI 高中规定的规则中构造：\n\n1. 设 $a$ 为 $[1,10^9]$ 之间的整数，则 $\\texttt{[a]}$ 是一个 IOI 函数。它将不小于 $a$ 的整数映射成 $\\texttt{True}$，将小于 $a$ 的整数映射成 $\\texttt{False}$。\n\n2. 记 $\\texttt{f}$ 为 IOI 函数，则 $\\texttt{(f)}$ 是一个 IOI 函数，它的映射规则与 $\\texttt{f}$ 的映射规则相同。\n\n3. 记 $\\texttt{f}$ 为 IOI 函数，则 $\\texttt{!f}$ 是一个 IOI 函数。设 $x$ 为整数，若 $\\texttt{f}$ 将 $x$ 映射为 $\\texttt{True}$，则 $\\texttt{!f}$ 将 $x$ 映射为 $\\texttt{False}$；否则 $\\texttt{!f}$ 将 $x$ 映射为 $\\texttt{True}$。\n\n4. 记 $\\texttt{f},\\texttt{g}$ 为 IOI 函数，则 $\\texttt{f\\&g}$ 也是一个 IOI 函数。设 $x$ 为整数，则 $\\texttt{f\\&g}$ 将 $x$ 映射为 $\\texttt{True}$，当且仅当 $\\texttt{f},\\texttt{g}$ 都将 $x$ 映射为 $\\texttt{True}$。\n\n5. 记 $\\texttt{f},\\texttt{g}$ 为 IOI 函数，则 $\\texttt{f\\^ g}$ 也是一个 IOI 函数。设 $x$ 为整数，则 $\\texttt{f\\^ g}$ 将 $x$ 映射为 $\\texttt{True}$，当且仅当 $\\texttt{f},\\texttt{g}$ 中恰好有一个将 $x$ 映射为 $\\texttt{True}$。\n\n6. 记 $\\texttt{f},\\texttt{g}$ 为 IOI 函数，则 $\\texttt{f|g}$ 也是一个 IOI 函数。设 $x$ 为整数，则 $\\texttt{f|g}$ 将 $x$ 映射为 $\\texttt{True}$，当且仅当 $\\texttt{f},\\texttt{g}$ 中至少有一个将 $x$ 映射为 $\\texttt{True}$。\n\n如果某个 IOI 函数用多条规则构造出，数字更大的规则将决定函数值。例如，对于 $\\texttt{[1]\\&[2]|[3]}$ 应当应用规则 6，其中 $\\texttt{f} = \\texttt{[1]\\&[2]},\\texttt{g} = \\texttt{[3]}$（而非应用规则 4，其中 $\\texttt{f} = \\texttt{[1]},\\texttt{g} = \\texttt{[2]|[3]}$）。额外地，对于规则 4，5，6，应当最大化 $\\texttt{f}$ 的长度。例如，对于 $\\texttt{[4]ˆ[5]ˆ[6]}$，应当在 $\\texttt{f} = \\texttt{[4]ˆ[5]},\\texttt{g} = \\texttt{[6]}$ 上应用规则 5（而非 $\\texttt{f} = \\texttt{[4]},\\texttt{g} = \\texttt{[5]ˆ[6]}$）。\n\n为备战期末考试，JOI 君准备好了一个长度为 $N$ 的 IOI 函数 $S$。他打算用 $Q$ 个整数 $X_1,X_2,\\cdots,X_Q$ 来练习他的计算技能。于是他找来了你——能够熟练处理 IOI 函数的人，来解决这个问题。\n\n你需要写一个程序。给定 $N,Q,S$ 以及 $X_1,X_2,\\cdots,X_Q$，对于 $i=1,2=\\cdots,Q$，回答 IOI 函数 $S$ 会将 $X_i$ 映射成 $\\texttt{True}$ 还是 $\\texttt{False}$。", "inputFormat": "输入格式如下所示：\n\n> $N$ $Q$\\\n> $S$\\\n> $X_1$\\\n> $X_2$\\\n> $\\vdots$\\\n> $X_Q$", "outputFormat": "输出 $Q$ 行，第 $i$ 行为 $\\texttt{True}$ 或者 $\\texttt{False}$，即 $X_i$ 被 $S$ 映射成的值。", "hint": "### 样例解释\n\n样例 $1$ 解释如下：\n\n| $X_i$ | $\\texttt{![2]}$ | $\\texttt{[3]}$ | $\\texttt{![2]\\char124[3]}$ | $\\texttt{![4]}$ | $\\texttt{(![2]\\char124[3])\\&![4]}$ |\n| :--: | :--: | :--: | :--: | :--: | :--: |\n| $1$ | $\\texttt{True}$ | $\\texttt{False}$ | $\\texttt{True}$ | $\\texttt{True}$ | $\\texttt{True}$ |\n| $2$ | $\\texttt{False}$ | $\\texttt{False}$ | $\\texttt{False}$ | $\\texttt{True}$ | $\\texttt{False}$ |\n| $3$ |  $\\texttt{False}$ | $\\texttt{True}$ | $\\texttt{True}$ | $\\texttt{True}$ | $\\texttt{True}$ |\n| $4$ | $\\texttt{False}$ | $\\texttt{True}$ | $\\texttt{True}$ | $\\texttt{False}$ | $\\texttt{False}$ |\n| $5$ |  $\\texttt{False}$ | $\\texttt{True}$ | $\\texttt{True}$ | $\\texttt{False}$ | $\\texttt{False}$ |\n\n样例 $1$ 满足子任务 $3,6,7$ 的条件。\n\n样例 $2$ 满足子任务 $1,3,5\\sim 7$ 的条件。\n\n样例 $3$ 满足子任务 $3,4,6,7$ 的条件。\t\n\n### 数据范围\n\n- $1 \\le N \\le 1\\,000\\,000$；\n- $1 \\le Q \\le 200\\,000$；\n- $S$ 为长度为 $N$ 的 IOI 函数；\n- $1 \\le X_i \\le 10^9$（$1 \\le i \\le Q$）；\n- $N, Q, X_i$（$1 \\le i \\le Q$）均为整数。\n\n### 子任务\n\n1. （$5$ points）$S$ 中不含 $\\texttt{\\&}$ 和 $\\texttt{|}$；\n2. （$20$ points）$Q = 1$；\n3. （$10$ points）$N \\le 10\\,000$；\n4. （$6$ points）$S$ 中不含 $\\texttt{!}$ 和 $\\texttt{ˆ}$；\n5. （$12$ points）当应用规则 4 或 6 来构造 $S$ 时，$\\texttt{f}$ 和 $\\texttt{g}$ 中至少有一个是用规则 1 得到的；\n6. （$20$ points）$N \\le 400\\, 000$；\n7. （$27$ points）无额外约束。\n\n*赛时公告：如果你复制题面中的 LaTeX，可能会得到 `ˆ`，但实际上是 `^`。请特别注意。\n\n由 Starrykiller 根据英文题面翻译。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI Open 2024] 考试 2 / Examination 2", "background": null, "description": "JOI 君在 IOI 高中上学，期末考试即将来临。考试的内容是计算 **IOI 函数**。IOI 函数是将 $[1,10^9]$ 之间的整数映射到布尔值（即 $\\texttt{True}/\\texttt{False}$）的函数。IOI 函数可以从以下六条 IOI 高中规定的规则中构造：\n\n1. 设 $a$ 为 $[1,10^9]$ 之间的整数，则 $\\texttt{[a]}$ 是一个 IOI 函数。它将不小于 $a$ 的整数映射成 $\\texttt{True}$，将小于 $a$ 的整数映射成 $\\texttt{False}$。\n\n2. 记 $\\texttt{f}$ 为 IOI 函数，则 $\\texttt{(f)}$ 是一个 IOI 函数，它的映射规则与 $\\texttt{f}$ 的映射规则相同。\n\n3. 记 $\\texttt{f}$ 为 IOI 函数，则 $\\texttt{!f}$ 是一个 IOI 函数。设 $x$ 为整数，若 $\\texttt{f}$ 将 $x$ 映射为 $\\texttt{True}$，则 $\\texttt{!f}$ 将 $x$ 映射为 $\\texttt{False}$；否则 $\\texttt{!f}$ 将 $x$ 映射为 $\\texttt{True}$。\n\n4. 记 $\\texttt{f},\\texttt{g}$ 为 IOI 函数，则 $\\texttt{f\\&g}$ 也是一个 IOI 函数。设 $x$ 为整数，则 $\\texttt{f\\&g}$ 将 $x$ 映射为 $\\texttt{True}$，当且仅当 $\\texttt{f},\\texttt{g}$ 都将 $x$ 映射为 $\\texttt{True}$。\n\n5. 记 $\\texttt{f},\\texttt{g}$ 为 IOI 函数，则 $\\texttt{f\\^ g}$ 也是一个 IOI 函数。设 $x$ 为整数，则 $\\texttt{f\\^ g}$ 将 $x$ 映射为 $\\texttt{True}$，当且仅当 $\\texttt{f},\\texttt{g}$ 中恰好有一个将 $x$ 映射为 $\\texttt{True}$。\n\n6. 记 $\\texttt{f},\\texttt{g}$ 为 IOI 函数，则 $\\texttt{f|g}$ 也是一个 IOI 函数。设 $x$ 为整数，则 $\\texttt{f|g}$ 将 $x$ 映射为 $\\texttt{True}$，当且仅当 $\\texttt{f},\\texttt{g}$ 中至少有一个将 $x$ 映射为 $\\texttt{True}$。\n\n如果某个 IOI 函数用多条规则构造出，数字更大的规则将决定函数值。例如，对于 $\\texttt{[1]\\&[2]|[3]}$ 应当应用规则 6，其中 $\\texttt{f} = \\texttt{[1]\\&[2]},\\texttt{g} = \\texttt{[3]}$（而非应用规则 4，其中 $\\texttt{f} = \\texttt{[1]},\\texttt{g} = \\texttt{[2]|[3]}$）。额外地，对于规则 4，5，6，应当最大化 $\\texttt{f}$ 的长度。例如，对于 $\\texttt{[4]ˆ[5]ˆ[6]}$，应当在 $\\texttt{f} = \\texttt{[4]ˆ[5]},\\texttt{g} = \\texttt{[6]}$ 上应用规则 5（而非 $\\texttt{f} = \\texttt{[4]},\\texttt{g} = \\texttt{[5]ˆ[6]}$）。\n\n为备战期末考试，JOI 君准备好了一个长度为 $N$ 的 IOI 函数 $S$。他打算用 $Q$ 个整数 $X_1,X_2,\\cdots,X_Q$ 来练习他的计算技能。于是他找来了你——能够熟练处理 IOI 函数的人，来解决这个问题。\n\n你需要写一个程序。给定 $N,Q,S$ 以及 $X_1,X_2,\\cdots,X_Q$，对于 $i=1,2=\\cdots,Q$，回答 IOI 函数 $S$ 会将 $X_i$ 映射成 $\\texttt{True}$ 还是 $\\texttt{False}$。", "inputFormat": "输入格式如下所示：\n\n> $N$ $Q$\\\n> $S$\\\n> $X_1$\\\n> $X_2$\\\n> $\\vdots$\\\n> $X_Q$", "outputFormat": "输出 $Q$ 行，第 $i$ 行为 $\\texttt{True}$ 或者 $\\texttt{False}$，即 $X_i$ 被 $S$ 映射成的值。", "hint": "### 样例解释\n\n样例 $1$ 解释如下：\n\n| $X_i$ | $\\texttt{![2]}$ | $\\texttt{[3]}$ | $\\texttt{![2]\\char124[3]}$ | $\\texttt{![4]}$ | $\\texttt{(![2]\\char124[3])\\&![4]}$ |\n| :--: | :--: | :--: | :--: | :--: | :--: |\n| $1$ | $\\texttt{True}$ | $\\texttt{False}$ | $\\texttt{True}$ | $\\texttt{True}$ | $\\texttt{True}$ |\n| $2$ | $\\texttt{False}$ | $\\texttt{False}$ | $\\texttt{False}$ | $\\texttt{True}$ | $\\texttt{False}$ |\n| $3$ |  $\\texttt{False}$ | $\\texttt{True}$ | $\\texttt{True}$ | $\\texttt{True}$ | $\\texttt{True}$ |\n| $4$ | $\\texttt{False}$ | $\\texttt{True}$ | $\\texttt{True}$ | $\\texttt{False}$ | $\\texttt{False}$ |\n| $5$ |  $\\texttt{False}$ | $\\texttt{True}$ | $\\texttt{True}$ | $\\texttt{False}$ | $\\texttt{False}$ |\n\n样例 $1$ 满足子任务 $3,6,7$ 的条件。\n\n样例 $2$ 满足子任务 $1,3,5\\sim 7$ 的条件。\n\n样例 $3$ 满足子任务 $3,4,6,7$ 的条件。\t\n\n### 数据范围\n\n- $1 \\le N \\le 1\\,000\\,000$；\n- $1 \\le Q \\le 200\\,000$；\n- $S$ 为长度为 $N$ 的 IOI 函数；\n- $1 \\le X_i \\le 10^9$（$1 \\le i \\le Q$）；\n- $N, Q, X_i$（$1 \\le i \\le Q$）均为整数。\n\n### 子任务\n\n1. （$5$ points）$S$ 中不含 $\\texttt{\\&}$ 和 $\\texttt{|}$；\n2. （$20$ points）$Q = 1$；\n3. （$10$ points）$N \\le 10\\,000$；\n4. （$6$ points）$S$ 中不含 $\\texttt{!}$ 和 $\\texttt{ˆ}$；\n5. （$12$ points）当应用规则 4 或 6 来构造 $S$ 时，$\\texttt{f}$ 和 $\\texttt{g}$ 中至少有一个是用规则 1 得到的；\n6. （$20$ points）$N \\le 400\\, 000$；\n7. （$27$ points）无额外约束。\n\n*赛时公告：如果你复制题面中的 LaTeX，可能会得到 `ˆ`，但实际上是 `^`。请特别注意。\n\n由 Starrykiller 根据英文题面翻译。", "locale": "zh-CN"}}}
{"pid": "P10627", "type": "P", "difficulty": 7, "samples": [["3\n1 1 1\n3\n1 2 2", "1"], ["6\n1 1 1 1 1 1\n7\n1 3 5 4 2 2 3", "3"], ["6\n4000 1 1 0 4000 1\n5\n1 1 2 3 5", "1"], ["5\n1 2 2 2 1\n8\n2 3 2 1 4 1 2 3", "2"], ["10\n2 2 2 2 2 2 2 2 2 2\n18\n1 3 5 7 9 2 4 6 8 1 3 5 7 9 2 4 6 8", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "JOI（日本）"], "title": "[JOI Open 2024] 中暑 / Heat Stroke", "background": "", "description": "JOI 岛由 $L$ 个区组成，从西到东依次编号为 $1$ 到 $L$。岛上有 $(L-1)$ 条路，编号为 $1$ 到 $L-1$。第 $i$ 条路（$1\\le i\\le L-1$）双向连接着区 $i$ 和区 $i+1$。\n\n现在，IOI 20XX 计划在 JOI 岛上举行！然而，令人担心的是，JOI 岛以其“火炉”称号而闻名于世。在岛上中暑风险较高，尤其是对于不适应 JOI 岛炎热气候的外国人。所以，IOI 的组织者决定采取以下措施：\n\n- 对于每一个 $1\\le i\\le L$，在区 $i$ 上有一个容量为 $C_i$ 人的医院。注意，$C_i$ 可以为 $0$。\n\n- 在 IOI 活动中，当有人在第 $x$ 条路（$1\\le x\\le L-1$）上中暑时，中暑者将以以下的程序送医：\n    - 将中暑者送往区 $x$ 或者区 $x+1$ 上的未满员的医院。如果两个区上的医院都未满员，则送往哪一个医院都可以。如果两个医院都满员了，用直升机将中暑者送往岛外的医院。\n\n由于动用直升机花销不小，组织者们想要估计可能的需要动用直升机的病人数量的**最大值**。他们考虑如下的情境：\n\n- 在 IOI 活动之前，医院中没有病人；\n- 在 IOI 活动中，有 $N$ 个人会依次中暑。第 $j$ 个（$1\\le j\\le N$）人在第 $X_j$ 条路上中暑；\n- 对于任意 $1\\le j\\le N-1$，当第 $(j+1)$ 个人中暑时，第 $1,2,\\cdots,j$ 个人已经送达医院。由于中暑症状较为严重，在 IOI 活动中无人出院。\n\n你需要写一个程序。给定区的数量，医院的信息和中暑者的信息，在上述情境下，计算可能的需要动用直升机的病人数量的最大值。\n", "inputFormat": "输入格式如下所示：\n> $L$\\\n> $C_1$ $C_2$ $\\cdots$ $C_L$ \\\n> $N$\\\n> $X_1$ $X_2$ $\\cdots$ $X_N$", "outputFormat": "输出一行一个数，即可能的需要动用直升机的病人数量的最大值。", "hint": "### 样例解释\n\n对于样例 $1$，考虑如下的情况：\n\n- 将第一个中暑者送往区 $2$ 上的医院。此时，三个区上的医院的病人数量分别为 $0,1,0$；\n- 将第二个中暑者送往区 $3$ 上的医院。此时，三个区上的医院的病人数量分别为 $0,1,1$；\n- 对于第三个中暑者，由于区 $2,3$ 上的医院均已满员，所以只能用直升机送出岛。\n\n此时共有 $1$ 人动用直升机送出岛。可以证明这是最大值。\n\n对于样例 $2$，考虑如下的情况：\n\n- 将第一个中暑者送往区 $2$ 上的医院。此时，六个区上的医院的病人数量分别为 $0,1,0,0,0,0$；\n- 将第二个中暑者送往区 $4$ 上的医院。此时，六个区上的医院的病人数量分别为 $0,1,0,1,0,0$；\n- 将第三个中暑者送往区 $5$ 上的医院。此时，六个区上的医院的病人数量分别为 $0,1,0,1,1,0$；\n- 对于第四个中暑者，由于区 $4,5$ 上的医院均已满员，所以只能用直升机送出岛。\n- 将第五个中暑者送往区 $3$ 上的医院。此时，六个区上的医院的病人数量分别为 $0,1,1,1,1,0$；\n- 对于第六个中暑者，由于区 $2,3$ 上的医院均已满员，所以只能用直升机送出岛。\n- 对于第七个中暑者，由于区 $3,4$ 上的医院均已满员，所以只能用直升机送出岛。\n\n此时共有 $3$ 人动用直升机送出岛。可以证明这是最大值。\n\n样例 $1$ 满足子任务 $1\\sim 8$ 的条件。\n\n样例 $2$ 满足子任务 $2\\sim 8$ 的条件。\n\n样例 $3$ 满足子任务 $1,5\\sim 8$ 的条件。\n\n样例 $4,5$ 满足子任务 $5\\sim 8$ 的条件。\n\n### 数据范围\n\n- $2 \\le L \\le 8\\,000$；\n- $0 \\le C_i \\le 8\\,000$（$1 \\le i \\le L$）；\n- $1 \\le N \\le 8\\,000$；\n- $1 \\le X_j \\le L − 1$（$1 \\le j \\le N$）；\n- 输入数字全为整数。\n\n【子任务】\n\n1. （$6 $ points）$X_1 \\le X_2 \\le\\cdots\\le X_N$；\n2. （$7 $ points）$L \\le 18, N \\le 18, C_i = 1 $（$1 \\le i \\le L$）；\n3. （$7 $ points）$L \\le 18, N \\le 100, C_i = 1 $（$1 \\le i \\le L$）；\n4. （$25$  points）$L \\le 100, N \\le 100, C_i = 1$ （$1 \\le i \\le L$）；\n5. （$25$  points）$L \\le 100, N \\le 100$；\n6. （$10$  points）$L \\le 600, N \\le 600$；\n7. （$15$  points）$L \\le 3\\,500, N \\le 3\\,500$；\n8. （$5 $ points）无额外约束。\n\n由 Starrykiller 根据英文题面翻译。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI Open 2024] 中暑 / Heat Stroke", "background": "", "description": "JOI 岛由 $L$ 个区组成，从西到东依次编号为 $1$ 到 $L$。岛上有 $(L-1)$ 条路，编号为 $1$ 到 $L-1$。第 $i$ 条路（$1\\le i\\le L-1$）双向连接着区 $i$ 和区 $i+1$。\n\n现在，IOI 20XX 计划在 JOI 岛上举行！然而，令人担心的是，JOI 岛以其“火炉”称号而闻名于世。在岛上中暑风险较高，尤其是对于不适应 JOI 岛炎热气候的外国人。所以，IOI 的组织者决定采取以下措施：\n\n- 对于每一个 $1\\le i\\le L$，在区 $i$ 上有一个容量为 $C_i$ 人的医院。注意，$C_i$ 可以为 $0$。\n\n- 在 IOI 活动中，当有人在第 $x$ 条路（$1\\le x\\le L-1$）上中暑时，中暑者将以以下的程序送医：\n    - 将中暑者送往区 $x$ 或者区 $x+1$ 上的未满员的医院。如果两个区上的医院都未满员，则送往哪一个医院都可以。如果两个医院都满员了，用直升机将中暑者送往岛外的医院。\n\n由于动用直升机花销不小，组织者们想要估计可能的需要动用直升机的病人数量的**最大值**。他们考虑如下的情境：\n\n- 在 IOI 活动之前，医院中没有病人；\n- 在 IOI 活动中，有 $N$ 个人会依次中暑。第 $j$ 个（$1\\le j\\le N$）人在第 $X_j$ 条路上中暑；\n- 对于任意 $1\\le j\\le N-1$，当第 $(j+1)$ 个人中暑时，第 $1,2,\\cdots,j$ 个人已经送达医院。由于中暑症状较为严重，在 IOI 活动中无人出院。\n\n你需要写一个程序。给定区的数量，医院的信息和中暑者的信息，在上述情境下，计算可能的需要动用直升机的病人数量的最大值。\n", "inputFormat": "输入格式如下所示：\n> $L$\\\n> $C_1$ $C_2$ $\\cdots$ $C_L$ \\\n> $N$\\\n> $X_1$ $X_2$ $\\cdots$ $X_N$", "outputFormat": "输出一行一个数，即可能的需要动用直升机的病人数量的最大值。", "hint": "### 样例解释\n\n对于样例 $1$，考虑如下的情况：\n\n- 将第一个中暑者送往区 $2$ 上的医院。此时，三个区上的医院的病人数量分别为 $0,1,0$；\n- 将第二个中暑者送往区 $3$ 上的医院。此时，三个区上的医院的病人数量分别为 $0,1,1$；\n- 对于第三个中暑者，由于区 $2,3$ 上的医院均已满员，所以只能用直升机送出岛。\n\n此时共有 $1$ 人动用直升机送出岛。可以证明这是最大值。\n\n对于样例 $2$，考虑如下的情况：\n\n- 将第一个中暑者送往区 $2$ 上的医院。此时，六个区上的医院的病人数量分别为 $0,1,0,0,0,0$；\n- 将第二个中暑者送往区 $4$ 上的医院。此时，六个区上的医院的病人数量分别为 $0,1,0,1,0,0$；\n- 将第三个中暑者送往区 $5$ 上的医院。此时，六个区上的医院的病人数量分别为 $0,1,0,1,1,0$；\n- 对于第四个中暑者，由于区 $4,5$ 上的医院均已满员，所以只能用直升机送出岛。\n- 将第五个中暑者送往区 $3$ 上的医院。此时，六个区上的医院的病人数量分别为 $0,1,1,1,1,0$；\n- 对于第六个中暑者，由于区 $2,3$ 上的医院均已满员，所以只能用直升机送出岛。\n- 对于第七个中暑者，由于区 $3,4$ 上的医院均已满员，所以只能用直升机送出岛。\n\n此时共有 $3$ 人动用直升机送出岛。可以证明这是最大值。\n\n样例 $1$ 满足子任务 $1\\sim 8$ 的条件。\n\n样例 $2$ 满足子任务 $2\\sim 8$ 的条件。\n\n样例 $3$ 满足子任务 $1,5\\sim 8$ 的条件。\n\n样例 $4,5$ 满足子任务 $5\\sim 8$ 的条件。\n\n### 数据范围\n\n- $2 \\le L \\le 8\\,000$；\n- $0 \\le C_i \\le 8\\,000$（$1 \\le i \\le L$）；\n- $1 \\le N \\le 8\\,000$；\n- $1 \\le X_j \\le L − 1$（$1 \\le j \\le N$）；\n- 输入数字全为整数。\n\n【子任务】\n\n1. （$6 $ points）$X_1 \\le X_2 \\le\\cdots\\le X_N$；\n2. （$7 $ points）$L \\le 18, N \\le 18, C_i = 1 $（$1 \\le i \\le L$）；\n3. （$7 $ points）$L \\le 18, N \\le 100, C_i = 1 $（$1 \\le i \\le L$）；\n4. （$25$  points）$L \\le 100, N \\le 100, C_i = 1$ （$1 \\le i \\le L$）；\n5. （$25$  points）$L \\le 100, N \\le 100$；\n6. （$10$  points）$L \\le 600, N \\le 600$；\n7. （$15$  points）$L \\le 3\\,500, N \\le 3\\,500$；\n8. （$5 $ points）无额外约束。\n\n由 Starrykiller 根据英文题面翻译。", "locale": "zh-CN"}}}
{"pid": "P10628", "type": "P", "difficulty": 6, "samples": [["4\n2 0 3 1", ""]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["二分", "2024", "交互题", "Special Judge", "置换", "JOI（日本）"], "title": "[JOI Open 2024] 图书馆 3 / Library 3", "background": "由于洛谷评测系统的限制，实际提交时，不需要引入 $\\texttt{library3.h}$。你需要在代码中添加：\n\n```cpp\nvoid answer(std::vector<int>);\nint query(std::vector<int>);\n```\n\n请使用 C++ 20 提交，不保证使用其他标准提交能够通过。", "description": "几百年的时光弹指一瞬，JOI 城已然是一片废墟。IOI 酱——一个探险家，正在探索图书馆的故址。由探索结果得知：\n\n- JOI 城的图书馆中有一个水平的书架，上面有 $N$ 个**位置**来放书，从左到右依次编号为 $0\\sim N-1$。一个位置只能放一本书。\n- 有 $N$ 本书放在书架上，编号为 $0\\sim N-1$。\n- 定义 $N$ 本书的一个**摆放**为一种将 $N$ 本书放在 $N$ 个位置上的方式。\n- 存在 $N$ 本书的一个**正确摆放**，其中第 $B_i$（$0\\le i\\le N-1$）本书放在位置 $i$ 上，其中 $B_i$ 两两不同。\n\n书的摆放总会改变，而这个图书馆是通过不断重复以下步骤来将书还原成正确摆放的：\n\n> **操作** 令 $x$ 是最左边的书，满足 $x$ 的位置与它在正确摆放中的位置不同。令 $y$ 为 $x$ 正确位置上的书，交换 $x,y$。\n\n尽管 IOI 酱找到了许多旧书，她无法得知书的正确摆放。然而，她发现了一台旧机器，可以执行上面的操作。如果指定一个摆放并向机器发起询问，机器就会回答从当前摆放到正确摆放，需要重复执行多少次操作。IOI 酱想要利用这台机器，获得书的正确摆放。由于机器过于老旧，她最多只能询问 $5\\, 000$ 次。\n\n你需要写一个程序。给定书架的信息，通过最多 $5\\,000$ 次询问，找出书的正确摆放。\n\n【实现细节】\n\n**这是一道交互题，你只需要提交一个文件（`library3.cpp`）。**\n\n你需要在文件中引入 `library3.h`，并实现以下函数：\n\n- `void solve(int N)`\\\n该函数在每个测试点中被调用恰好一次。\n    - 参数 $N$ 代表书的数量。\n\n在 `library3.cpp` 中，你可以调用以下函数：\n\n- `int query(const std::vector<int> a)`\\\nIOI 酱用这个函数向机器发起询问。\n    - 参数 `a` 为一个长度为 $N$ 的数组，即要询问的摆放。也就是说，在指定的摆放中，第 `a[i]` 本书（$0\\le i\\le N-1$）被放在位置 $i$。\n    - 返回值为一个整数，即从指定的摆放到正确摆放，需要重复执行多少次操作。\n    - 参数中，数组 `a` 的长度必须为 $N$。如果不满足这个条件，你的程序将被判为 **Wrong Answer[1]**。\n    - 参数中，数组 `a` 中的每个元素都必须在 $0$ 到 $N-1$ 之间。如果不满足这个条件，你的程序将被判为 **Wrong Answer[2]**。\n    - 参数中，数组 `a` 中的元素必须两两不同。如果不满足这个条件，你的程序将被判为 **Wrong Answer[3]**。\n    - 该函数最多只能被调用 $5\\,000$ 次。如果超出调用次数，你的程序将被判为 **Wrong Answer[4]**。\n\n- `void answer(std::vector<int> b)`\\\n你的程序用这个函数回答正确摆放。\n    - 参数 `b` 为一个长度为 $N$ 的数组，即正确摆放。也就是说，在正确摆放中，第 `b[i]` 本书（$0\\le i\\le N-1$）被放在位置 $i$。\n    - 参数中，数组 `b` 的长度必须为 $N$。如果不满足这个条件，你的程序将被判为 **Wrong Answer[5]**。\n    - 参数中，数组 `b` 中的每个元素都必须在 $0$ 到 $N-1$ 之间。如果不满足这个条件，你的程序将被判为 **Wrong Answer[6]**。\n    - 参数中，数组 `b` 中的元素必须两两不同。如果不满足这个条件，你的程序将被判为 **Wrong Answer[7]**。\n    - 如果你回答的摆放并不是正确摆放，你的程序将被判为 **Wrong Answer[8]**。\n    - 该函数必须被调用恰好一次。如果超出调用次数，你的程序将被判为 **Wrong Answer[9]**。如果未调用，你的程序将被判为 **Wrong Answer[10]**。\n\n【注意事项】\n\n你的程序可以定义其他函数，也可以使用全局变量。\n\n你的程序不得使用标准输入输出流，不得以任何形式读写其他文件。但是，你的程序可以使用标准错误流来输出调试信息。\n\n【编译运行】\n\n可以从附件中获取 sample grader。Sample grader 即为文件 `grader.cpp`。将 `grader.cpp`，`library3.cpp`，`library3.h` 放置在同一目录下，运行以下命令即可编译你的程序。你也可以运行文件 `compile.sh` 来编译程序。\n\n> 编译命令：`g++ -std=gnu++20 -O2 -o grader grader.cpp library3.cpp`\n\n编译成功的话，会生成可执行文件 `grader`。注意，实际评测时用的 grader 与 sample grader 是不同的。Sample grader 会以单进程方式执行，从标准输入流中读取数据，输出结果到标准输出流。\n\n*赛时公告：Sample grader 是非适应性的。实际评测时使用的 grader 是否适应是未知的。\n\n", "inputFormat": "Sample grader 按照以下方式读取输入：\n\n> $N$\\\n> $B_0$ $B_1$ $\\cdots$ $B_{N-1}$\n\n在正确摆放中，第 $B_i$（$0\\le i\\le N-1$）本书放在位置 $i$ 上。", "outputFormat": "Sample grader 会输出以下结果：\n\n- 如果你的程序被评为正确的，返回调用 `query` 函数的次数。例如：`Accepted: 3000`。\n- 否则，如果你的程序满足任一形式的错误，则按照题目描述中的错误类型输出。例如：`Wrong Answer[3]`。\n\n如果你的程序同时满足多种错误的条件，只会输出一种错误。", "hint": "\n\n如下是一种可能的交互过程：\n\n| 调用 | 调用 | 返回值 |\n| :--: | :--:| :--: |\n| `solve(4)` | | |\n| | `query([0, 1, 2, 3])` | `3` |\n| | `query([1, 3, 0, 2])` | `2` |\n| | `query([3, 0, 1, 2])` | `2` |\n| | `query([2, 0, 3, 1])` | `0` |\n| | `answer([2, 0, 3, 1])` | |\n\n\n考虑调用 `query([0, 1, 2, 3])`。操作将会按照如下方式进行：\n\n- 交换第 $0$ 本书和第 $1$ 本书的位置。于是，第 $1,0,2,3$ 本书分别被放在位置 $0,1,2,3$ 上。\n- 交换第 $1$ 本书和第 $3$ 本书的位置。于是，第 $3,0,2,1$ 本书分别被放在位置 $0,1,2,3$ 上。\n- 交换第 $3$ 本书和第 $2$ 本书的位置。于是，第 $2,0,3,1$ 本书分别被放在位置 $0,1,2,3$ 上。\n\n在 $3$ 次操作后，将指定的摆放还原成了正确的摆放，所以返回值为 `3`。\n\n样例满足所有子任务的限制条件。\n\n### 数据范围\n\n- $2 \\le N \\le 500$；\n- $0 \\le B_i \\le N - 1$（$0 \\le i \\le N - 1$）；\n- $B_i\\neq B_j$（$0 \\le i < j \\le N - 1$）；\n- 输入数字全为整数。\n\n### 子任务\n\n1. （$2 $ points）$N \\le 6$；\n2. （$19$ points）$N \\le 100$；\n3. （$79$ points）无额外约束。\n\n由 Starrykiller 根据英文题面翻译。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI Open 2024] 图书馆 3 / Library 3", "background": "由于洛谷评测系统的限制，实际提交时，不需要引入 $\\texttt{library3.h}$。你需要在代码中添加：\n\n```cpp\nvoid answer(std::vector<int>);\nint query(std::vector<int>);\n```\n\n请使用 C++ 20 提交，不保证使用其他标准提交能够通过。", "description": "几百年的时光弹指一瞬，JOI 城已然是一片废墟。IOI 酱——一个探险家，正在探索图书馆的故址。由探索结果得知：\n\n- JOI 城的图书馆中有一个水平的书架，上面有 $N$ 个**位置**来放书，从左到右依次编号为 $0\\sim N-1$。一个位置只能放一本书。\n- 有 $N$ 本书放在书架上，编号为 $0\\sim N-1$。\n- 定义 $N$ 本书的一个**摆放**为一种将 $N$ 本书放在 $N$ 个位置上的方式。\n- 存在 $N$ 本书的一个**正确摆放**，其中第 $B_i$（$0\\le i\\le N-1$）本书放在位置 $i$ 上，其中 $B_i$ 两两不同。\n\n书的摆放总会改变，而这个图书馆是通过不断重复以下步骤来将书还原成正确摆放的：\n\n> **操作** 令 $x$ 是最左边的书，满足 $x$ 的位置与它在正确摆放中的位置不同。令 $y$ 为 $x$ 正确位置上的书，交换 $x,y$。\n\n尽管 IOI 酱找到了许多旧书，她无法得知书的正确摆放。然而，她发现了一台旧机器，可以执行上面的操作。如果指定一个摆放并向机器发起询问，机器就会回答从当前摆放到正确摆放，需要重复执行多少次操作。IOI 酱想要利用这台机器，获得书的正确摆放。由于机器过于老旧，她最多只能询问 $5\\, 000$ 次。\n\n你需要写一个程序。给定书架的信息，通过最多 $5\\,000$ 次询问，找出书的正确摆放。\n\n【实现细节】\n\n**这是一道交互题，你只需要提交一个文件（`library3.cpp`）。**\n\n你需要在文件中引入 `library3.h`，并实现以下函数：\n\n- `void solve(int N)`\\\n该函数在每个测试点中被调用恰好一次。\n    - 参数 $N$ 代表书的数量。\n\n在 `library3.cpp` 中，你可以调用以下函数：\n\n- `int query(const std::vector<int> a)`\\\nIOI 酱用这个函数向机器发起询问。\n    - 参数 `a` 为一个长度为 $N$ 的数组，即要询问的摆放。也就是说，在指定的摆放中，第 `a[i]` 本书（$0\\le i\\le N-1$）被放在位置 $i$。\n    - 返回值为一个整数，即从指定的摆放到正确摆放，需要重复执行多少次操作。\n    - 参数中，数组 `a` 的长度必须为 $N$。如果不满足这个条件，你的程序将被判为 **Wrong Answer[1]**。\n    - 参数中，数组 `a` 中的每个元素都必须在 $0$ 到 $N-1$ 之间。如果不满足这个条件，你的程序将被判为 **Wrong Answer[2]**。\n    - 参数中，数组 `a` 中的元素必须两两不同。如果不满足这个条件，你的程序将被判为 **Wrong Answer[3]**。\n    - 该函数最多只能被调用 $5\\,000$ 次。如果超出调用次数，你的程序将被判为 **Wrong Answer[4]**。\n\n- `void answer(std::vector<int> b)`\\\n你的程序用这个函数回答正确摆放。\n    - 参数 `b` 为一个长度为 $N$ 的数组，即正确摆放。也就是说，在正确摆放中，第 `b[i]` 本书（$0\\le i\\le N-1$）被放在位置 $i$。\n    - 参数中，数组 `b` 的长度必须为 $N$。如果不满足这个条件，你的程序将被判为 **Wrong Answer[5]**。\n    - 参数中，数组 `b` 中的每个元素都必须在 $0$ 到 $N-1$ 之间。如果不满足这个条件，你的程序将被判为 **Wrong Answer[6]**。\n    - 参数中，数组 `b` 中的元素必须两两不同。如果不满足这个条件，你的程序将被判为 **Wrong Answer[7]**。\n    - 如果你回答的摆放并不是正确摆放，你的程序将被判为 **Wrong Answer[8]**。\n    - 该函数必须被调用恰好一次。如果超出调用次数，你的程序将被判为 **Wrong Answer[9]**。如果未调用，你的程序将被判为 **Wrong Answer[10]**。\n\n【注意事项】\n\n你的程序可以定义其他函数，也可以使用全局变量。\n\n你的程序不得使用标准输入输出流，不得以任何形式读写其他文件。但是，你的程序可以使用标准错误流来输出调试信息。\n\n【编译运行】\n\n可以从附件中获取 sample grader。Sample grader 即为文件 `grader.cpp`。将 `grader.cpp`，`library3.cpp`，`library3.h` 放置在同一目录下，运行以下命令即可编译你的程序。你也可以运行文件 `compile.sh` 来编译程序。\n\n> 编译命令：`g++ -std=gnu++20 -O2 -o grader grader.cpp library3.cpp`\n\n编译成功的话，会生成可执行文件 `grader`。注意，实际评测时用的 grader 与 sample grader 是不同的。Sample grader 会以单进程方式执行，从标准输入流中读取数据，输出结果到标准输出流。\n\n*赛时公告：Sample grader 是非适应性的。实际评测时使用的 grader 是否适应是未知的。\n\n", "inputFormat": "Sample grader 按照以下方式读取输入：\n\n> $N$\\\n> $B_0$ $B_1$ $\\cdots$ $B_{N-1}$\n\n在正确摆放中，第 $B_i$（$0\\le i\\le N-1$）本书放在位置 $i$ 上。", "outputFormat": "Sample grader 会输出以下结果：\n\n- 如果你的程序被评为正确的，返回调用 `query` 函数的次数。例如：`Accepted: 3000`。\n- 否则，如果你的程序满足任一形式的错误，则按照题目描述中的错误类型输出。例如：`Wrong Answer[3]`。\n\n如果你的程序同时满足多种错误的条件，只会输出一种错误。", "hint": "\n\n如下是一种可能的交互过程：\n\n| 调用 | 调用 | 返回值 |\n| :--: | :--:| :--: |\n| `solve(4)` | | |\n| | `query([0, 1, 2, 3])` | `3` |\n| | `query([1, 3, 0, 2])` | `2` |\n| | `query([3, 0, 1, 2])` | `2` |\n| | `query([2, 0, 3, 1])` | `0` |\n| | `answer([2, 0, 3, 1])` | |\n\n\n考虑调用 `query([0, 1, 2, 3])`。操作将会按照如下方式进行：\n\n- 交换第 $0$ 本书和第 $1$ 本书的位置。于是，第 $1,0,2,3$ 本书分别被放在位置 $0,1,2,3$ 上。\n- 交换第 $1$ 本书和第 $3$ 本书的位置。于是，第 $3,0,2,1$ 本书分别被放在位置 $0,1,2,3$ 上。\n- 交换第 $3$ 本书和第 $2$ 本书的位置。于是，第 $2,0,3,1$ 本书分别被放在位置 $0,1,2,3$ 上。\n\n在 $3$ 次操作后，将指定的摆放还原成了正确的摆放，所以返回值为 `3`。\n\n样例满足所有子任务的限制条件。\n\n### 数据范围\n\n- $2 \\le N \\le 500$；\n- $0 \\le B_i \\le N - 1$（$0 \\le i \\le N - 1$）；\n- $B_i\\neq B_j$（$0 \\le i < j \\le N - 1$）；\n- 输入数字全为整数。\n\n### 子任务\n\n1. （$2 $ points）$N \\le 6$；\n2. （$19$ points）$N \\le 100$；\n3. （$79$ points）无额外约束。\n\n由 Starrykiller 根据英文题面翻译。", "locale": "zh-CN"}}}
{"pid": "P10630", "type": "P", "difficulty": 6, "samples": [["5\n-5 5 -2\n2 5 10\n1 4 -2\n4 -5 4\n-2 2 7", "19"], ["6\n0 0 6\n1 0 -2\n2 0 8\n0 1 -2\n1 1 5\n2 1 -2", "15"], ["5\n0 0 2\n4 0 2\n3 2 -1\n1 2 2\n1 1 -1", "5"], ["2\n0 0 -1\n1 0 -1", "0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "JOI（日本）"], "title": "[JOI Open 2017] 推土机 / Bulldozer", "background": "", "description": "**译自 [JOI Open 2017](https://contests.ioi-jp.org/open-2017/index.html) T2 「ブルドーザー / Bulldozer」**\n\n平面上有 $N$ 个点，点 $i\\:(1≤i≤N)$ 位于 $(X_i, Y_i)$，点 $i\\:(1≤i≤N)$ 的权值为非零整数 $W_i$（可能为负数）。  \n在平面上画两条平行线，所得的总价值为平行线之间（压线也算）所有点的权值之和。求总价值至多不超过多少。", "inputFormat": "第一行包含一个整数 $N$。  \n在接下来的 $N$ 行中，第 $i$ 行包含三个用空格分隔的整数 $X_i,Y_i,W_i$。", "outputFormat": "一行，一个整数，表示最大总价值。", "hint": "**样例解释 1**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rk2miemg.png)\n\n选择点 $2, 3, 4, 5$。\n\n**样例解释 2**\n\n注意，点 $1,2,3$ 共线。点 $4,5,6$ 共线。\n\n**样例解释 3**\n\n这组样例中没有三点共线。选择的平行线一条过点 $1,2$，另一条过点 $3,4$。\n\n#### 数据范围\n\n所有输入数据都满足以下条件。\n\n $1≤N≤2000, |X_i|,|Y_i|≤10^9,1 ≤|W_i|≤10^9(1≤i≤N)$ 。$(X_i,Y_i)≠(X_j,Y_j)\\:(1≤i<j≤N)$ 。\n\n|子任务|分值|$N≤100$|无三点共线|设 $L$ 是在平面上通过两个不同点的一条线，$L'$ 是在平面上另一条通过两个不同点的线，那么 $L$ 和 $L'$ **不**相互平行|其他条件|\n|:---------:|:------------:|:-------------:|:---------------:|:-:|:------------:|\n|$1$     |$5$    |√            |×                 |×|所有点都在 $x$ 轴上|\n|$2$     |$20$  |√          |√               |√|无|\n|$3$     |$35$  |×          |√                |√|无|\n|$4$     |$20$  |×          |√                |×|无|\n|$5$     |$20$  |×          |×                |×|无|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI Open 2017] 推土机 / Bulldozer", "background": "", "description": "**译自 [JOI Open 2017](https://contests.ioi-jp.org/open-2017/index.html) T2 「ブルドーザー / Bulldozer」**\n\n平面上有 $N$ 个点，点 $i\\:(1≤i≤N)$ 位于 $(X_i, Y_i)$，点 $i\\:(1≤i≤N)$ 的权值为非零整数 $W_i$（可能为负数）。  \n在平面上画两条平行线，所得的总价值为平行线之间（压线也算）所有点的权值之和。求总价值至多不超过多少。", "inputFormat": "第一行包含一个整数 $N$。  \n在接下来的 $N$ 行中，第 $i$ 行包含三个用空格分隔的整数 $X_i,Y_i,W_i$。", "outputFormat": "一行，一个整数，表示最大总价值。", "hint": "**样例解释 1**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rk2miemg.png)\n\n选择点 $2, 3, 4, 5$。\n\n**样例解释 2**\n\n注意，点 $1,2,3$ 共线。点 $4,5,6$ 共线。\n\n**样例解释 3**\n\n这组样例中没有三点共线。选择的平行线一条过点 $1,2$，另一条过点 $3,4$。\n\n#### 数据范围\n\n所有输入数据都满足以下条件。\n\n $1≤N≤2000, |X_i|,|Y_i|≤10^9,1 ≤|W_i|≤10^9(1≤i≤N)$ 。$(X_i,Y_i)≠(X_j,Y_j)\\:(1≤i<j≤N)$ 。\n\n|子任务|分值|$N≤100$|无三点共线|设 $L$ 是在平面上通过两个不同点的一条线，$L'$ 是在平面上另一条通过两个不同点的线，那么 $L$ 和 $L'$ **不**相互平行|其他条件|\n|:---------:|:------------:|:-------------:|:---------------:|:-:|:------------:|\n|$1$     |$5$    |√            |×                 |×|所有点都在 $x$ 轴上|\n|$2$     |$20$  |√          |√               |√|无|\n|$3$     |$35$  |×          |√                |√|无|\n|$4$     |$20$  |×          |√                |×|无|\n|$5$     |$20$  |×          |×                |×|无|", "locale": "zh-CN"}}}
{"pid": "P10631", "type": "P", "difficulty": 6, "samples": [["3 5 8 6\n1\n5 6 2 8", "3"], ["1 1 1 10\n3\n5 6 2 8\n1 2 2 3\n8 10 3 5", "1"], ["20 68 85 74\n5\n30 70 14 100\n5 24 15 67\n75 86 75 79\n75 90 19 62\n93 98 26 58", "4"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2017", "线段树", "广度优先搜索 BFS", "扫描线", "JOI（日本）"], "title": "[JOI Open 2017] 高尔夫 / Golf", "background": "", "description": "**译自 [JOI Open 2017](https://contests.ioi-jp.org/open-2017/index.html) T3 「ゴルフ / Golf」**\n\n平面的第一象限上有 $N$ 个矩形障碍，矩形的两组对边分别平行于 $x$ 轴和 $y$ 轴。矩形 $i(1\\le i\\le N)$ 的左下角是 $(A_i, C_i)$，右上角是 $(B_i, D_i)$。任意两个矩形（包括边界）不相交。  \nJOI 君需要将一个高尔夫球从 $(S,T)$ 打到 $(U,V)$，保证这两点不同，保证这两点不在障碍内或障碍的边界上。  \nJOI 君只能朝平行于 $x$ 轴或平行与 $y$ 轴的方向击球（JOI 君可以跟着移动）。球可以经过边界，但不能进入障碍物内部。球撞进障碍物后会停下（JOI 君仍然可以朝远离障碍物的方向击球）。  \n求最少要击球多少次，才能将高尔夫球打进 $(U,V)$。", "inputFormat": "第一行有四个整数 $S, T, U, V$。  \n第二行有一个整数 $N$。  \n在接下来的 $N$ 行中，每行有四个整数 $A_i, B_i, C_i, D_i$。", "outputFormat": "输出一行，一个整数，表示最少击球次数。", "hint": "**样例解释 1**\n\n$(3,5) → (3,2) → (8,2) → (8,6)$\n\n\n#### 数据范围\n\n$1\\le S, T, U, V\\le 10^9, 1\\le N\\le 10^5, 1\\le A_i<B_i\\le 10^9, 1\\le C_i<D_i\\le 10^9,$ $(S,T)≠(U,V)$。  \n\n- 子任务 #1（10 分）：$S, T, U, V, N, B_i, D_i\\le 1000$；  \n- 子任务 #2（20 分）：$N\\le 1000$；  \n- 子任务 #3（70 分）：没有额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI Open 2017] 高尔夫 / Golf", "background": "", "description": "**译自 [JOI Open 2017](https://contests.ioi-jp.org/open-2017/index.html) T3 「ゴルフ / Golf」**\n\n平面的第一象限上有 $N$ 个矩形障碍，矩形的两组对边分别平行于 $x$ 轴和 $y$ 轴。矩形 $i(1\\le i\\le N)$ 的左下角是 $(A_i, C_i)$，右上角是 $(B_i, D_i)$。任意两个矩形（包括边界）不相交。  \nJOI 君需要将一个高尔夫球从 $(S,T)$ 打到 $(U,V)$，保证这两点不同，保证这两点不在障碍内或障碍的边界上。  \nJOI 君只能朝平行于 $x$ 轴或平行与 $y$ 轴的方向击球（JOI 君可以跟着移动）。球可以经过边界，但不能进入障碍物内部。球撞进障碍物后会停下（JOI 君仍然可以朝远离障碍物的方向击球）。  \n求最少要击球多少次，才能将高尔夫球打进 $(U,V)$。", "inputFormat": "第一行有四个整数 $S, T, U, V$。  \n第二行有一个整数 $N$。  \n在接下来的 $N$ 行中，每行有四个整数 $A_i, B_i, C_i, D_i$。", "outputFormat": "输出一行，一个整数，表示最少击球次数。", "hint": "**样例解释 1**\n\n$(3,5) → (3,2) → (8,2) → (8,6)$\n\n\n#### 数据范围\n\n$1\\le S, T, U, V\\le 10^9, 1\\le N\\le 10^5, 1\\le A_i<B_i\\le 10^9, 1\\le C_i<D_i\\le 10^9,$ $(S,T)≠(U,V)$。  \n\n- 子任务 #1（10 分）：$S, T, U, V, N, B_i, D_i\\le 1000$；  \n- 子任务 #2（20 分）：$N\\le 1000$；  \n- 子任务 #3（70 分）：没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P10632", "type": "P", "difficulty": 7, "samples": [["3\n0 1\n1 2", "5.6667"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "点分治", "多项式", "Special Judge", "O2优化", "期望", "快速数论变换 NTT"], "title": "Normal", "background": "", "description": "某天 WJMZBMR 学习了一个神奇的算法：树的点分治！\n\n这个算法的核心是这样的：\n\n```cpp\ntime = 0\nSolve(Tree a) {\n  time += a.size;\n  if (a.size == 1) return;\n  else {\n    select x in a;\n    delete a[x];\n  }\n}\n```\n\n```\n消耗时间 = 0\nSolve(树 a)\n  消耗时间 += a 的大小\n  如果 a 中 只有 1 个点\n    退出\n  否则\n    在 a 中选一个点x\n    在 a 中删除点x\n```\n\n那么 $a$ 变成了几个小一点的树，对每个小树递归调用 `Solve`。\n\n我们注意到的这个算法的时间复杂度跟选择的点 $x$ 是密切相关的，如果 $x$ 是树的重心，那么时间复杂度就是 $O(n \\log n)$。\n\nWJMZBMR 决定随机在 $a$ 中选择一个点作为 $x$，Sevenkplus 告诉他这样做的最坏复杂度是 $O(n^2)$，但是 WJMZBMR 就是不信，于是 Sevenkplus 花了几分钟写了一个程序证明了这一点，你也试试看吧。\n\n现在给你一颗树，你能告诉 WJMZBMR 他的算法需要的期望消耗时间吗（以给出的 `Solve` 函数中的为标准）？", "inputFormat": "第一行一个整数 $n$，表示树的大小；接下来 $n-1$ 行每行两个整数 $a,b$，表示 $a$ 和 $b$ 之间有一条边。\n\n树的结点从 $0$ 开始编号。", "outputFormat": "一行一个浮点数表示答案，并四舍五入到小数点后 $4$ 位。", "hint": "对于所有的数据，保证 $1\\leq n\\leq 30000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Normal", "background": "", "description": "某天 WJMZBMR 学习了一个神奇的算法：树的点分治！\n\n这个算法的核心是这样的：\n\n```cpp\ntime = 0\nSolve(Tree a) {\n  time += a.size;\n  if (a.size == 1) return;\n  else {\n    select x in a;\n    delete a[x];\n  }\n}\n```\n\n```\n消耗时间 = 0\nSolve(树 a)\n  消耗时间 += a 的大小\n  如果 a 中 只有 1 个点\n    退出\n  否则\n    在 a 中选一个点x\n    在 a 中删除点x\n```\n\n那么 $a$ 变成了几个小一点的树，对每个小树递归调用 `Solve`。\n\n我们注意到的这个算法的时间复杂度跟选择的点 $x$ 是密切相关的，如果 $x$ 是树的重心，那么时间复杂度就是 $O(n \\log n)$。\n\nWJMZBMR 决定随机在 $a$ 中选择一个点作为 $x$，Sevenkplus 告诉他这样做的最坏复杂度是 $O(n^2)$，但是 WJMZBMR 就是不信，于是 Sevenkplus 花了几分钟写了一个程序证明了这一点，你也试试看吧。\n\n现在给你一颗树，你能告诉 WJMZBMR 他的算法需要的期望消耗时间吗（以给出的 `Solve` 函数中的为标准）？", "inputFormat": "第一行一个整数 $n$，表示树的大小；接下来 $n-1$ 行每行两个整数 $a,b$，表示 $a$ 和 $b$ 之间有一条边。\n\n树的结点从 $0$ 开始编号。", "outputFormat": "一行一个浮点数表示答案，并四舍五入到小数点后 $4$ 位。", "hint": "对于所有的数据，保证 $1\\leq n\\leq 30000$。", "locale": "zh-CN"}}}
{"pid": "P10633", "type": "P", "difficulty": 5, "samples": [["3 5\n2 4 3\nQuery 2 2\nModify 1 3\nQuery 2 2\nModify 1 2\nQuery 1 1", "2\n3\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["树状数组", "cdq 分治", "O2优化"], "title": "BZOJ2989 数列/BZOJ4170 极光", "background": "", "description": "给定一个长度为 $n$ 的正整数数列 $a_i$，两个位置的 $\\text{graze}$ 值为两者位置差与数值差的和：$\\text{graze}(x,y)=|x-y|+|a_x-a_y|$。\n\n你必须支持两种操作（$k$ 都是正整数）：\n- `Modify x k`，表示将第 $x$ 个数的值修改为 $k$；\n- `Query x k`，表示询问有几个 $i$ 满足 $\\text{graze}(x,i) \\leq k$；\n\n询问不仅要考虑当前数列，还要考虑任意历史版本，即统计任意位置上出现过的任意数值与当前的 $a_x$ 的 $\\text{graze}$ 值 $\\leq k$ 的对数。（某位置多次修改为同样的数值，按多次统计。）", "inputFormat": "第一行两个整数 $n,q$，表示数列长度与操作数；\n\n第二行 $n$ 个正整数，代表初始数列。\n\n第 $3\\sim q+2$ 行，每行一个操作。", "outputFormat": "对于每次询问操作，输出一个非负整数表示答案。", "hint": "对于所有数据，保证 $1\\leq n\\leq 6\\times 10^4$，$1\\leq$ 修改操作数 $\\leq 5\\times 10^4$，$1\\leq$ 询问次数 $\\leq 6\\times 10^4$，$1\\leq a_i$ 的所有历史版本的最大值 $\\leq 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "BZOJ2989 数列/BZOJ4170 极光", "background": "", "description": "给定一个长度为 $n$ 的正整数数列 $a_i$，两个位置的 $\\text{graze}$ 值为两者位置差与数值差的和：$\\text{graze}(x,y)=|x-y|+|a_x-a_y|$。\n\n你必须支持两种操作（$k$ 都是正整数）：\n- `Modify x k`，表示将第 $x$ 个数的值修改为 $k$；\n- `Query x k`，表示询问有几个 $i$ 满足 $\\text{graze}(x,i) \\leq k$；\n\n询问不仅要考虑当前数列，还要考虑任意历史版本，即统计任意位置上出现过的任意数值与当前的 $a_x$ 的 $\\text{graze}$ 值 $\\leq k$ 的对数。（某位置多次修改为同样的数值，按多次统计。）", "inputFormat": "第一行两个整数 $n,q$，表示数列长度与操作数；\n\n第二行 $n$ 个正整数，代表初始数列。\n\n第 $3\\sim q+2$ 行，每行一个操作。", "outputFormat": "对于每次询问操作，输出一个非负整数表示答案。", "hint": "对于所有数据，保证 $1\\leq n\\leq 6\\times 10^4$，$1\\leq$ 修改操作数 $\\leq 5\\times 10^4$，$1\\leq$ 询问次数 $\\leq 6\\times 10^4$，$1\\leq a_i$ 的所有历史版本的最大值 $\\leq 10^5$。", "locale": "zh-CN"}}}
