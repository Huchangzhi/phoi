{"pid": "P9599", "type": "P", "difficulty": 5, "samples": [], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "交互题", "Special Judge", "O2优化", "JOI（日本）"], "title": "[JOI Open 2018] 木琴 / Xylophone", "background": "**特别提醒，由于洛谷交互机制的特殊性，你不能在程序中引用 `xylophone.h`，而需要把 `xylophone.h` 中的内容加入文件的开头。即，在程序中 `solve` 函数的前面加入以下几行语句：**\n\n```cpp\nvoid solve(int N);\nint query(int s, int t);\nvoid answer(int i, int a);\n```\n\n**同时不建议使用 C++14(GCC 9) 提交本题，建议选择 C++17 或者更高的语言版本提交。**", "description": "木琴是一种乐器，人可以通过敲击木条来演奏它。单个木条总是发出同样音高的音，因此一个木琴包含不同种音高的木条。\n\nJOI 君买了一个有 $N$ 个木条的木琴。这 $N$ 个木条排成一排，从左到右编号为 $1$ 到 $N$。编号为 $i\\ (1\\le i\\le N)$ 的木条能发出音高为 $A_i\\ (1\\le A_i\\le N)$ 的音。不同的木条发出不同音高的音。他知道音高最低的木条要比音高最高的编号小。\n\n因为 JOI 君不知道每个木条的音高是什么，他决定研究这些木条的音高。\n\nJOI 有一种独特的音感，当他连续听到多个音时，他能分辨出最高音和最低音差多少。他可以一次敲击一些木条，然后听它们发出的声音。也就是说，对于两个整数 $s$ 和 $t\\ (1\\le s\\le t\\le N)$，他可以连续敲击编号从 $s$ 到 $t$​ 的木条，以知道 $A_s,A_{s+1},\\ldots ,A_t$​ 中最大值与最小值的差。\n\n他想在 $10\\ 000$ 次敲击之内知道每个木条的音高。\n\n---\n\n**【实现细节】**\n\n你需要实现函数 `solve` 以求出每个木条的音高。\n\n- `solve(N)`\n\n  - $N$：木条的数量。\n  - 这个函数每个测试点调用恰好一次。\n\n你的程序可以调用评分器实现的如下函数。\n\n- `query(s, t)`\n\n  这个函数返回在给定区间中木条音高最大值与最小值的差。\n\n  - $s, t$：$s$ 是要敲击的木条区间中第一个数，$t$ 是最后一个数。也就是说，你需要敲击编号在 $[s,t]$ 区间内的所有木条。\n  - 必须保证 $1\\le s\\le t\\le N$。\n  - 你不能调用 `query` 函数超过 $10\\ 000$ 次。\n  - 如果上述条件不满足，你的程序会被判为 **Wrong Answer**。\n\n- `answer(i, a)`\n\n  你的程序应当用这个函数回答每个木条的音高。\n\n  - $i, a$：这意味着你回答了 $A_i$ 的值为 $a$，其中 $A_i$ 指木条 $i$ 的音高。\n  - 必须保证 $1\\le i\\le N$。\n  - 你不能对于相同的 $\\texttt i$ 调用超过一次这个函数。\n  - 你必须在函数 $\\texttt{solve}$ 结束前调用恰好 $N$ 次此函数。\n  - 如果上述条件不满足，你的程序会被判为 **Wrong Answer**。\n  - 如果你的回答与实际音高有不同，你的程序会被判为 **Wrong Answer**。\n\n暂不支持 Java 与 Pascal 提交的测评。", "inputFormat": "", "outputFormat": "", "hint": "**【样例交互】**\n\n一个对于 $N=5,(A_1,A_2,A_3,A_4,A_5)=(2,1,5,3,4)$ 的样例交互过程如下。\n\n|          调用           |   返回值   |\n| :---------------------: | :--------: |\n| $\\texttt{query(1, 5)}$  |            |\n|                         |    $4$     |\n| $\\texttt{answer(1, 2)}$ |            |\n| $\\texttt{query(3, 5)}$  |  |\n|                         |    $2$     |\n| $\\texttt{answer(2, 1)}$​ |            |\n| $\\texttt{answer(3, 5)}$​ |  |\n| $\\texttt{answer(5, 4)}$​ |            |\n| $\\texttt{answer(4, 3)}$​ |  |\n\n**【数据范围】**\n\n所有子任务满足以下限制：\n\n- $1\\le A_i\\le N\\ (1\\le i\\le N)$\n- $A_i\\neq A_j\\ (1\\le i<j\\le N)$\n- 对于满足 $A_i=1,A_j=N$ 的 $i$ 和 $j$，满足 $i<j$​。\n\n本题有三个子任务。子任务分值及附加限制如下表所示：\n\n| 子任务编号 | 分值 |        $N$         |\n| :--------: | :--: | :----------------: |\n|    $1$     | $11$ |  $2\\le N\\le 100$   |\n|    $2$     | $36$ | $2\\le N\\le 1\\ 000$ |\n|    $3$     | $53$ | $2\\le N\\le 5\\ 000$ |\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI Open 2018] 木琴 / Xylophone", "background": "**特别提醒，由于洛谷交互机制的特殊性，你不能在程序中引用 `xylophone.h`，而需要把 `xylophone.h` 中的内容加入文件的开头。即，在程序中 `solve` 函数的前面加入以下几行语句：**\n\n```cpp\nvoid solve(int N);\nint query(int s, int t);\nvoid answer(int i, int a);\n```\n\n**同时不建议使用 C++14(GCC 9) 提交本题，建议选择 C++17 或者更高的语言版本提交。**", "description": "木琴是一种乐器，人可以通过敲击木条来演奏它。单个木条总是发出同样音高的音，因此一个木琴包含不同种音高的木条。\n\nJOI 君买了一个有 $N$ 个木条的木琴。这 $N$ 个木条排成一排，从左到右编号为 $1$ 到 $N$。编号为 $i\\ (1\\le i\\le N)$ 的木条能发出音高为 $A_i\\ (1\\le A_i\\le N)$ 的音。不同的木条发出不同音高的音。他知道音高最低的木条要比音高最高的编号小。\n\n因为 JOI 君不知道每个木条的音高是什么，他决定研究这些木条的音高。\n\nJOI 有一种独特的音感，当他连续听到多个音时，他能分辨出最高音和最低音差多少。他可以一次敲击一些木条，然后听它们发出的声音。也就是说，对于两个整数 $s$ 和 $t\\ (1\\le s\\le t\\le N)$，他可以连续敲击编号从 $s$ 到 $t$​ 的木条，以知道 $A_s,A_{s+1},\\ldots ,A_t$​ 中最大值与最小值的差。\n\n他想在 $10\\ 000$ 次敲击之内知道每个木条的音高。\n\n---\n\n**【实现细节】**\n\n你需要实现函数 `solve` 以求出每个木条的音高。\n\n- `solve(N)`\n\n  - $N$：木条的数量。\n  - 这个函数每个测试点调用恰好一次。\n\n你的程序可以调用评分器实现的如下函数。\n\n- `query(s, t)`\n\n  这个函数返回在给定区间中木条音高最大值与最小值的差。\n\n  - $s, t$：$s$ 是要敲击的木条区间中第一个数，$t$ 是最后一个数。也就是说，你需要敲击编号在 $[s,t]$ 区间内的所有木条。\n  - 必须保证 $1\\le s\\le t\\le N$。\n  - 你不能调用 `query` 函数超过 $10\\ 000$ 次。\n  - 如果上述条件不满足，你的程序会被判为 **Wrong Answer**。\n\n- `answer(i, a)`\n\n  你的程序应当用这个函数回答每个木条的音高。\n\n  - $i, a$：这意味着你回答了 $A_i$ 的值为 $a$，其中 $A_i$ 指木条 $i$ 的音高。\n  - 必须保证 $1\\le i\\le N$。\n  - 你不能对于相同的 $\\texttt i$ 调用超过一次这个函数。\n  - 你必须在函数 $\\texttt{solve}$ 结束前调用恰好 $N$ 次此函数。\n  - 如果上述条件不满足，你的程序会被判为 **Wrong Answer**。\n  - 如果你的回答与实际音高有不同，你的程序会被判为 **Wrong Answer**。\n\n暂不支持 Java 与 Pascal 提交的测评。", "inputFormat": "", "outputFormat": "", "hint": "**【样例交互】**\n\n一个对于 $N=5,(A_1,A_2,A_3,A_4,A_5)=(2,1,5,3,4)$ 的样例交互过程如下。\n\n|          调用           |   返回值   |\n| :---------------------: | :--------: |\n| $\\texttt{query(1, 5)}$  |            |\n|                         |    $4$     |\n| $\\texttt{answer(1, 2)}$ |            |\n| $\\texttt{query(3, 5)}$  |  |\n|                         |    $2$     |\n| $\\texttt{answer(2, 1)}$​ |            |\n| $\\texttt{answer(3, 5)}$​ |  |\n| $\\texttt{answer(5, 4)}$​ |            |\n| $\\texttt{answer(4, 3)}$​ |  |\n\n**【数据范围】**\n\n所有子任务满足以下限制：\n\n- $1\\le A_i\\le N\\ (1\\le i\\le N)$\n- $A_i\\neq A_j\\ (1\\le i<j\\le N)$\n- 对于满足 $A_i=1,A_j=N$ 的 $i$ 和 $j$，满足 $i<j$​。\n\n本题有三个子任务。子任务分值及附加限制如下表所示：\n\n| 子任务编号 | 分值 |        $N$         |\n| :--------: | :--: | :----------------: |\n|    $1$     | $11$ |  $2\\le N\\le 100$   |\n|    $2$     | $36$ | $2\\le N\\le 1\\ 000$ |\n|    $3$     | $53$ | $2\\le N\\le 5\\ 000$ |\n\n", "locale": "zh-CN"}}}
{"pid": "P9600", "type": "P", "difficulty": 6, "samples": [["2\n7 0 2 10\n0 1 2\n0 3 3\n1 2 4\n2 4 2\n2 5 5\n5 6 3\n4 0 3 20\n0 1 18\n1 2 1\n2 3 19\n", "6\n3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2023", "IOI", "交互题", "O2优化"], "title": "[IOI 2023] 封锁时刻", "background": "这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。\n\n本题仅支持 C++ 语言提交。", "description": "匈牙利有 $N$ 个城市，编号依次为 $0$ 到 $N - 1$。\n\n这些城市之间由 $N - 1$ 条双向道路连接，编号为 $0$ 至 $N - 2$。对每个 $j$（$0 \\le j \\le N - 2$），第 $j$ 条道路连接城市 $U[j]$ 和城市 $V[j]$，其长度为 $W[j]$，表示这两个城市之间的交通时间为 $W[j]$ 个时间单位。每条道路连接两个不同的城市，且每两个城市之间最多由一条道路连接。\n\n两个不同城市 $a$ 和 $b$ 之间的一条**路径**是一个由不同城市组成的序列 $p_0, p_1, \\ldots, p_t$，满足以下条件：\n * $p_0 = a$， \n * $p_t = b$， \n * 对每个 $i$（$0 \\le i \\lt t$），存在一条道路连接 $p_i$ 和 $p_{i + 1}$。\n\n利用这些道路从任意一个城市到任意一个其他的城市都是有可能的。换言之，任意两个不同城市之间都存在路径。  \n可以证明两个不同城市之间的路径是唯一的。\n\n一条路径 $p_0, p_1, \\ldots, p_t$ 的**长度**是这条路径上连接相邻城市的 $t$ 条道路的长度之和。\n\n在匈牙利，很多人都会在建国日去参加在两个主要城市举行的庆祝活动。当庆祝活动结束时，他们会回家。政府为了防止人群干扰当地人，所以决定在特定时刻封锁城市。每个城市被政府分配一个非负的**封锁时刻**。政府决定所有城市的封锁时刻总和不得超过 $K$。具体来说，对每个 $i$（$0 \\leq i \\leq N - 1$），分配给城市 $i$ 的封锁时刻是一个非负整数  $c[i]$。所有  $c[i]$ 之和不超过 $K$。\n\n考虑一个城市 $a$ 和某个封锁时刻的分配方案，我们说城市 $b$ 是从城市 $a$ 可达的当且仅当以下两种情况中的任意一种情况成立。\n\n情况 1：$b = a$。\n\n情况 2：这两个城市之间的路径  $p_0, \\ldots, p_t$ （$p_0 = a$ 且 $p_t = b$）满足以下条件：\n* 路径 $p_0, p_1$ 的长度最多为 $c[p_1]$，并且\n* 路径 $p_0, p_1, p_2$ 的长度最多为 $c[p_2]$，并且\n* $\\ldots$\n* 路径 $p_0, p_1, p_2, \\ldots, p_t$ 的长度最长为  $c[p_t]$。\n\n今年，两个主要的庆祝地点位于城市 $X$ 和 $Y$。  \n对于每一个封锁时刻的分配方案，可以定义一个**便利分数**，其定义为下面两个数字之和：\n- 从城市 $X$ 可达的城市个数。\n- 从城市 $Y$ 可达的城市个数。\n\n注意如果一个城市既能从城市 $X$ 可达也能从城市 $Y$ 可达，那么它在计算便利分数时计算两次。\n\n你的任务是计算能被某个封锁时刻分配方案实现的最大便利分数。", "inputFormat": "令 $C$ 表示场景数，即调用 `max_score` 的次数。\n评测程序实例按以下格式读取输入：\n\n* 第 $1$ 行：$C$\n\n以下是 $C$ 个场景的描述。\n\n评测程序实例按以下格式读取每个场景的描述：\n\n* 第 $1$ 行：$N \\; X \\; Y \\; K$\n* 第 $2 + j$ 行（$0 \\le j \\le N - 2$）：$U[j] \\; V[j] \\; W[j]$", "outputFormat": "评测程序实例按以下格式为每个场景打印单独一行\n\n* 第 $1$ 行： `max_score` 的返回值", "hint": "#### 【实现细节】\n\n你要实现以下函数。\n\n```\nint max_score(int N, int X, int Y, int64 K, int[] U, int[] V, int[] W)\n```\n\n* $N$：城市的个数\n* $X$，$Y$：两个主要庆祝城市\n* $K$：封锁时刻总和的上界\n* $U$，$V$： 长度为 $N - 1$ 的描述道路连接情况的数组\n* $W$：长度为 $N - 1$ 的描述道路长度的数组\n* 该函数要返回能被某个封锁时刻分配方案实现的最大便利分数\n* 每个测试用例可以多次调用该函数\n\n\n\n#### 【例子】\n\n\n考虑以下调用：\n\n```\nmax_score(7, 0, 2, 10,\n          [0, 0, 1, 2, 2, 5], [1, 3, 2, 4, 5, 6], [2, 3, 4, 2, 5, 3])\n```\n\n\n\n这对应以下道路网络：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wf5uw4qd.png)\n\n\n\n假设封锁时刻如下分配：\n\n| **城市**         | $0$ | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ |\n|:----------------:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|\n| **封锁时刻** | $0$ | $4$ | $0$ | $3$ | $2$ | $0$ | $0$ |\n\n\n\n注意所有封锁时刻之和为 $9$，不超过 $K = 10$。城市 $0$，$1$ 和 $3$ 都是从城市 $X$（$X = 0$）可达的，而城市 $1$，$2$ 和 $4$ 都可以从城市 $Y$（$Y  = 2$）可达。 因此，便利分数为 $3+3 = 6$。不存在封锁时刻分配方案使得便利分数大于 $6$，所以该函数应该返回 $6$。\n\n\n\n考虑另外一个调用：\n\n```\nmax_score(4, 0, 3, 20, [0, 1, 2], [1, 2, 3], [18, 1, 19])\n```\n\n\n\n这对应以下道路网络：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zcw4gdi5.png)\n\n假设封锁时间如下分配：\n\n| **城市**         | $0$ | $1$ | $2$ | $3$ |\n|:----------------:|:---:|:---:|:---:|:---:|\n| **封锁时刻** | $0$ | $1$ | $19$| $0$ |\n\n\n\n城市 $0$ 从城市 $X$（$X = 0$）可达，而城市 $2$ 和 $3$ 都是可以从城市 $Y$（$Y=3$）可达的。因此，便利分数是 $1 + 2 = 3$。不存在封锁时刻分配方案使得便利分数大于 $3$，所以函数应该返回 $3$。\n\n#### 【约束条件】\n\n* $2 \\le N \\le 200\\,000$\n* $0 \\le X \\lt Y \\lt N$\n* $0 \\le K \\le 10^{18}$\n* $0 \\le U[j] \\lt V[j] \\lt N$ (对每个 $j$ 满足 $0 \\le j \\le N - 2$)\n* $1 \\le W[j] \\le 10^6$ (对每个 $j$ 满足 $0 \\le j \\le N - 2$)\n* 利用这些道路可以从任意一个城市走到任意另外一个城市。\n* $S_N \\le 200\\,000$，其中 $S_N$ 是所有调用函数 `max_score` 的  $N$ 的总和。\n\n\n#### 【子任务】\n\n\n我们说一个道路网络是**线性的**如果道路 $i$ 连接城市 $i$ 和 $i+1$（对每个$0 \\le i \\le N - 2$ 的 $i$）。\n\n1. （8 分）从城市 $X$ 到城市 $Y$ 的路径长度大于 $2K$。\n1. （9 分）$S_N \\le 50$，道路网络是线性的。\n1. （12 分）$S_N \\le 500$，道路网络是线性的。\n1. （14 分）$S_N \\le 3\\,000$，道路网络是线性的。\n1. （9 分）$S_N \\le 20$\n1. （11 分）$S_N \\le 100$\n1. （10 分）$S_N \\le 500$\n1. （10 分）$S_N \\le 3\\,000$\n1. （17 分）无额外的约束条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2023] 封锁时刻", "background": "这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。\n\n本题仅支持 C++ 语言提交。", "description": "匈牙利有 $N$ 个城市，编号依次为 $0$ 到 $N - 1$。\n\n这些城市之间由 $N - 1$ 条双向道路连接，编号为 $0$ 至 $N - 2$。对每个 $j$（$0 \\le j \\le N - 2$），第 $j$ 条道路连接城市 $U[j]$ 和城市 $V[j]$，其长度为 $W[j]$，表示这两个城市之间的交通时间为 $W[j]$ 个时间单位。每条道路连接两个不同的城市，且每两个城市之间最多由一条道路连接。\n\n两个不同城市 $a$ 和 $b$ 之间的一条**路径**是一个由不同城市组成的序列 $p_0, p_1, \\ldots, p_t$，满足以下条件：\n * $p_0 = a$， \n * $p_t = b$， \n * 对每个 $i$（$0 \\le i \\lt t$），存在一条道路连接 $p_i$ 和 $p_{i + 1}$。\n\n利用这些道路从任意一个城市到任意一个其他的城市都是有可能的。换言之，任意两个不同城市之间都存在路径。  \n可以证明两个不同城市之间的路径是唯一的。\n\n一条路径 $p_0, p_1, \\ldots, p_t$ 的**长度**是这条路径上连接相邻城市的 $t$ 条道路的长度之和。\n\n在匈牙利，很多人都会在建国日去参加在两个主要城市举行的庆祝活动。当庆祝活动结束时，他们会回家。政府为了防止人群干扰当地人，所以决定在特定时刻封锁城市。每个城市被政府分配一个非负的**封锁时刻**。政府决定所有城市的封锁时刻总和不得超过 $K$。具体来说，对每个 $i$（$0 \\leq i \\leq N - 1$），分配给城市 $i$ 的封锁时刻是一个非负整数  $c[i]$。所有  $c[i]$ 之和不超过 $K$。\n\n考虑一个城市 $a$ 和某个封锁时刻的分配方案，我们说城市 $b$ 是从城市 $a$ 可达的当且仅当以下两种情况中的任意一种情况成立。\n\n情况 1：$b = a$。\n\n情况 2：这两个城市之间的路径  $p_0, \\ldots, p_t$ （$p_0 = a$ 且 $p_t = b$）满足以下条件：\n* 路径 $p_0, p_1$ 的长度最多为 $c[p_1]$，并且\n* 路径 $p_0, p_1, p_2$ 的长度最多为 $c[p_2]$，并且\n* $\\ldots$\n* 路径 $p_0, p_1, p_2, \\ldots, p_t$ 的长度最长为  $c[p_t]$。\n\n今年，两个主要的庆祝地点位于城市 $X$ 和 $Y$。  \n对于每一个封锁时刻的分配方案，可以定义一个**便利分数**，其定义为下面两个数字之和：\n- 从城市 $X$ 可达的城市个数。\n- 从城市 $Y$ 可达的城市个数。\n\n注意如果一个城市既能从城市 $X$ 可达也能从城市 $Y$ 可达，那么它在计算便利分数时计算两次。\n\n你的任务是计算能被某个封锁时刻分配方案实现的最大便利分数。", "inputFormat": "令 $C$ 表示场景数，即调用 `max_score` 的次数。\n评测程序实例按以下格式读取输入：\n\n* 第 $1$ 行：$C$\n\n以下是 $C$ 个场景的描述。\n\n评测程序实例按以下格式读取每个场景的描述：\n\n* 第 $1$ 行：$N \\; X \\; Y \\; K$\n* 第 $2 + j$ 行（$0 \\le j \\le N - 2$）：$U[j] \\; V[j] \\; W[j]$", "outputFormat": "评测程序实例按以下格式为每个场景打印单独一行\n\n* 第 $1$ 行： `max_score` 的返回值", "hint": "#### 【实现细节】\n\n你要实现以下函数。\n\n```\nint max_score(int N, int X, int Y, int64 K, int[] U, int[] V, int[] W)\n```\n\n* $N$：城市的个数\n* $X$，$Y$：两个主要庆祝城市\n* $K$：封锁时刻总和的上界\n* $U$，$V$： 长度为 $N - 1$ 的描述道路连接情况的数组\n* $W$：长度为 $N - 1$ 的描述道路长度的数组\n* 该函数要返回能被某个封锁时刻分配方案实现的最大便利分数\n* 每个测试用例可以多次调用该函数\n\n\n\n#### 【例子】\n\n\n考虑以下调用：\n\n```\nmax_score(7, 0, 2, 10,\n          [0, 0, 1, 2, 2, 5], [1, 3, 2, 4, 5, 6], [2, 3, 4, 2, 5, 3])\n```\n\n\n\n这对应以下道路网络：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wf5uw4qd.png)\n\n\n\n假设封锁时刻如下分配：\n\n| **城市**         | $0$ | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ |\n|:----------------:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|\n| **封锁时刻** | $0$ | $4$ | $0$ | $3$ | $2$ | $0$ | $0$ |\n\n\n\n注意所有封锁时刻之和为 $9$，不超过 $K = 10$。城市 $0$，$1$ 和 $3$ 都是从城市 $X$（$X = 0$）可达的，而城市 $1$，$2$ 和 $4$ 都可以从城市 $Y$（$Y  = 2$）可达。 因此，便利分数为 $3+3 = 6$。不存在封锁时刻分配方案使得便利分数大于 $6$，所以该函数应该返回 $6$。\n\n\n\n考虑另外一个调用：\n\n```\nmax_score(4, 0, 3, 20, [0, 1, 2], [1, 2, 3], [18, 1, 19])\n```\n\n\n\n这对应以下道路网络：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zcw4gdi5.png)\n\n假设封锁时间如下分配：\n\n| **城市**         | $0$ | $1$ | $2$ | $3$ |\n|:----------------:|:---:|:---:|:---:|:---:|\n| **封锁时刻** | $0$ | $1$ | $19$| $0$ |\n\n\n\n城市 $0$ 从城市 $X$（$X = 0$）可达，而城市 $2$ 和 $3$ 都是可以从城市 $Y$（$Y=3$）可达的。因此，便利分数是 $1 + 2 = 3$。不存在封锁时刻分配方案使得便利分数大于 $3$，所以函数应该返回 $3$。\n\n#### 【约束条件】\n\n* $2 \\le N \\le 200\\,000$\n* $0 \\le X \\lt Y \\lt N$\n* $0 \\le K \\le 10^{18}$\n* $0 \\le U[j] \\lt V[j] \\lt N$ (对每个 $j$ 满足 $0 \\le j \\le N - 2$)\n* $1 \\le W[j] \\le 10^6$ (对每个 $j$ 满足 $0 \\le j \\le N - 2$)\n* 利用这些道路可以从任意一个城市走到任意另外一个城市。\n* $S_N \\le 200\\,000$，其中 $S_N$ 是所有调用函数 `max_score` 的  $N$ 的总和。\n\n\n#### 【子任务】\n\n\n我们说一个道路网络是**线性的**如果道路 $i$ 连接城市 $i$ 和 $i+1$（对每个$0 \\le i \\le N - 2$ 的 $i$）。\n\n1. （8 分）从城市 $X$ 到城市 $Y$ 的路径长度大于 $2K$。\n1. （9 分）$S_N \\le 50$，道路网络是线性的。\n1. （12 分）$S_N \\le 500$，道路网络是线性的。\n1. （14 分）$S_N \\le 3\\,000$，道路网络是线性的。\n1. （9 分）$S_N \\le 20$\n1. （11 分）$S_N \\le 100$\n1. （10 分）$S_N \\le 500$\n1. （10 分）$S_N \\le 3\\,000$\n1. （17 分）无额外的约束条件。", "locale": "zh-CN"}}}
{"pid": "P9601", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2023", "IOI", "交互题", "Special Judge", "O2优化"], "title": "[IOI 2023] 最长路程", "background": "IOI2023 D1T2\n\n**特别提醒，由于洛谷交互机制的特殊性，你不能在程序中引入头文件，而需要把头文件的内容加入文件的开头。即，在程序开头加入以下几行语句：**\n\n```\n#include <vector>\n\nstd::vector<int> longest_trip(int N, int D);\n\nbool are_connected(std::vector<int> A, std::vector<int> B);\n```", "description": "IOI 2023 组委会有大麻烦了！他们忘记计划即将到来的 Ópusztaszer 之旅了。然而，或许一切尚未为晚 ......\n\n在 Ópusztaszer 有 $N$ 个地标，编号为从 $0$ 到 $N-1$。某些地标之间连有**双向**的**道路**。任意一对地标之间至多连有一条道路。组委会**不知道**哪些地标之间有道路相连。\n\n如果对于每三个不同的地标，它们之间都至少连有 $\\delta$ 条道路，我们就称 Ópusztaszer 的路网**密度**是**至少**为 $\\delta$ 的。换言之，对所有满足 $0 \\le u \\lt v \\lt w \\lt N$ 的地标三元组 $(u, v, w)$，配对 $(u,v)$，$(v,w)$ 和 $(u,w)$ 中至少有 $\\delta$ 个配对中的地标有道路相连。\n\n组委会**已知**有某个正整数 $D$，满足路网密度至少为 $D$。注意， $D$ 的值不会大于 $3$。\n\n组委会可以**询问** Ópusztaszer 的电话接线员，以获取关于某些地标之间的道路连接信息。在每次询问时，必须给出两个非空的地标数组 $[A[0], \\ldots, A[P-1]]$ 和 $[B[0], \\ldots, B[R-1]]$。地标之间必须是两两不同的，即，\n\n* 对于满足 $0 \\le i \\lt j \\lt P$ 的所有 $i$ 和 $j$，有 $A[i] \\neq A[j]$；\n* 对于满足 $0 \\le i \\lt j \\lt R$ 的所有 $i$ 和 $j$，有 $B[i] \\neq B[j]$；\n* 对于满足 $0 \\le i \\lt P$ 且 $0\\le j \\lt R$ 的所有 $i$ 和 $j$，有 $A[i] \\neq B[j]$。\n\n对每次询问，接线员都会报告是否存在 $A$ 中的某个地标和 $B$ 中的某个地标有道路相连。更准确地说，接线员会对满足 $0 \\le i \\lt P$ 和 $0\\le j \\lt R$ 的所有配对 $i$ 和 $j$ 进行尝试。如果其中某对地标 $A[i]$ 与 $B[j]$ 之间连有道路，接线员将报告 `true`。否则，接线员将报告 `false`。\n\n一条长度为 $l$ 的**路程**，被定义为由**不同**地标 $t[0], t[1], \\ldots, t[l-1]$ 构成的序列，其中对从 $0$ 到 $l-2$（包括 $0$ 和 $l-2$）的所有 $i$，地标 $t[i]$ 和 $t[i+1]$ 之间都有道路相连。如果不存在长度至少为 $l+1$ 的路程，则长度为 $l$ 的某条路程被称为是**最长路程**。\n\n你的任务是通过询问接线员，帮助组委会在 Ópusztaszer 找一条最长路程。\n\n---\n\n**【实现细节】**\n\n你需要实现如下函数：\n\n```\nint[] longest_trip(int N, int D)\n```\n\n* $N$：Ópusztaszer 的地标数量。\n* $D$：可以保证的路网密度最小值。\n* 该函数需要返回一个表示某条最长路程的数组 $t = [t[0], t[1], \\ldots, t[l-1]]$。\n* 对于每个测试用例，该函数都可能会被调用 **多次**。\n\n上述函数可以调用如下函数：\n\n```\nbool are_connected(int[] A, int[] B)\n```\n\n* $A$：一个非空、且元素两两不同的地标数组。\n* $B$：一个非空、且元素两两不同的地标数组。\n* $A$ 和 $B$ 之间应无交集。\n* 如果存在连接 $A$ 中某个地标以及 $B$ 中某个地标的道路，该函数返回 `true`。否则该函数返回 `false`。\n* 在每次 `longest_trip` 调用中，该函数可以被至多调用 $32\\,640$ 次。该函数的累计调用总数至多为 $150\\,000$ 次。\n* 对历次调用该函数时传递的数组 $A$ 和 $B$ 长度进行累计，两个数组累计长度加起来不能超过 $1\\,500\\,000$。\n\n评测程序是**非适应性的**。每次提交都将在同一组测试用例上进行评测。换言之，在每个测试用例中，$N$ 和 $D$ 的值，以及道路所连接的地标配对，对于每次 `longest_trip` 调用都保持不变。", "inputFormat": "", "outputFormat": "", "hint": "**【例子】**\n\n**样例一**\n\n考虑某个 $N = 5$, $D = 1$ 的场景，其中道路连接情形如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h4q6u936.png)\n\n函数 `longest_trip` 被调用如下：\n\n```\nlongest_trip(5, 1)\n```\n\n该函数可以调用 `are_connected` 如下。\n\n|                调用                |  有道路连接的配对  | 返回值  |\n| :--------------------------------: | :----------------: | :-----: |\n| `are_connected([0], [1, 2, 4, 3])` | $(0,1)$ 和 $(0,2)$ | `true`  |\n|     `are_connected([2], [0])`      |      $(2,0)$       | `true`  |\n|     `are_connected([2], [3])`      |      $(2,3)$       | `true`  |\n|  `are_connected([1, 0], [4, 3])`   |         无         | `false` |\n\n在第四次调用后，可知 $(1,4)$，$(0,4)$，$(1,3)$ 和 $(0,3)$ 中**没有**哪个配对中的地标之间连有道路。由于路网的密度至少是 $D = 1$，我们由三元组 $(0, 3, 4)$ 可知，配对 $(3,4)$ 的地标之间必须连有道路。与此相似，地标 $0$ 和 $1$ 之间必须是相连的。\n\n至此，可以总结出 $t = [1, 0, 2, 3, 4]$ 是一条长度为 $5$ 的路程，而且不存在长度超过 $5$ 的路程。因此，函数 `longest_trip` 可以返回 $[1, 0, 2, 3, 4]$。\n\n考虑另一个场景， 其中 $N = 4$, $D = 1$，且地标之间的道路如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6kk0r3y9.png)\n\n函数 `longest_trip` 被调用如下：\n\n```\nlongest_trip(4, 1)\n```\n\n在这个场景中，最长路程的长度为 $2$。因此，在对函数 `are_connected` 进行少量调用后，函数 `longest_trip` 可以返回 $[0, 1]$, $[1, 0]$, $[2, 3]$ 和 $[3, 2]$ 中的任意一个.\n\n**样例 2**\n\n子任务 0 包含另一个测试用例用作示例，其中有 $N=256$ 个地标。\n\n**【数据范围】**\n\n* $3 \\le N \\le 256$\n* 对于每个测试用例，函数 `longest_trip` 的所有调用中 $N$ 的累计总和不超过 $1\\,024$。\n* $1 \\le D \\le 3$\n\n**【子任务】**\n\n1. （5 分）$D = 3$\n1. （10 分）$D = 2$\n1. （25 分）$D = 1$。令 $l^\\star$ 表示最长路程的长度。函数 `longest_trip` 不必返回长度为 $l^\\star$ 的某条路程，而应返回长度至少为 $\\left\\lceil \\frac{l^\\star}{2} \\right\\rceil$ 的某条路程。\n1. （60 分）$D = 1$\n\n在子任务 4 中，你的得分将根据 `longest_trip` 的单次调用中对函数 `are_connected` 的调用数量而定。对该子任务的所有测试用例调用 `longest_trip`，令 $q$ 为各次调用产生的函数 `are_connected` 调用次数的最大值。\n你在该子任务上的得分将按照下表进行计算：\n\n|            条件            | 得分 |\n| :------------------------: | :--: |\n| $2\\,750 \\lt q \\le 32\\,640$ | $20$ |\n|   $550 \\lt q \\le 2\\,750$   | $30$ |\n|    $400 \\lt q \\le 550$     | $45$ |\n|        $q \\le 400$         | $60$ |\n\n如果在某个测试用例上，对函数 `are_connected` 的调用没有遵守实现细节部分给出的限制条件，或者 `longest_trip` 返回的数组是错误的，你的解答在该子任务上的得分将为 $0$。\n\n**【评测程序示例】**\n\n令 $C$ 为场景数量，即调用 `longest_trip` 的次数。\n评测程序示例读取如下格式的输入数据：\n\n* 第 $1$ 行：$C$\n\n接下来是这 $C$ 个场景的描述数据。\n\n评测程序示例读取每个场景如下格式的描述数据：\n\n* 第 $1$ 行：$N \\; D$\n* 第 $1 + i$ 行（$1 \\le i \\lt N$）：$U_i[0] \\; U_i[1] \\; \\ldots \\; U_i[i-1]$\n\n这里每个 $U_i$（$1 \\le i \\lt N$）均为长度为 $i$ 的数组，以给出那些有道路相连的地标配对。对于满足 $1 \\le i \\lt N$ 且 $0 \\le j \\lt i$ 的所有 $i$ 和 $j$：\n\n* 如果地标 $j$ 和 $i$ 之间有道路相连，则 $U_i[j]$ 的值应为 $1$；\n* 如果地标 $j$ 和 $i$ 之间没有道路相连，则 $U_i[j]$ 的值应为 $0$。\n\n在每个场景中，在调用 `longest_trip` 之前，评测程序示例检查路网的密度是否至少为 $D$。如果不满足该条件，评测程序示例将输出信息 `Insufficient Density` 并中止。\n\n如果检查出违反规则的行为，评测程序示例的输出为 `Protocol Violation: <MSG>`，这里 `<MSG>` 为如下错误信息之一：\n\n* `invalid array`：在 `are_connected` 的某次调用中，数组 $A$ 和 $B$ 中至少其一\n  - 为空，或\n  - 有元素不是 $0$ 到 $N-1$ 之间（包含 $0$ 和 $N-1$）的整数，或\n  - 有重复元素。\n* `non-disjoint arrays`：在 `are_connected` 的某次调用中，数组 $A$ 和 $B$ 的交集不空。\n* `too many calls`：函数 `are_connected` 在 `longest trip` 的当前调用中的被调用次数超过了 $32\\,640$，或者其累计调用次数超过了 $150\\,000$。\n* `too many elements`：在 `are_connected` 的全部调用中，所传递的地标的累计数量超过了 $1\\,500\\,000$。\n\n否则，令 `longest_trip` 函数在某个场景中的返回数组为 $t[0], t[1], \\ldots, t[l - 1]$，这里 $l$ 为某个非负整数。评测程序示例将对该场景按照如下格式输出三行：\n\n* 第 $1$ 行：$l$\n* 第 $2$ 行：$t[0] \\; t[1] \\; \\ldots \\; t[l-1]$\n* 第 $3$ 行：在该场景中调用 `are_connected` 的次数\n\n最后，评测程序示例输出：\n\n* 第 $1 + 3 \\cdot C$ 行：在 `longest_trip` 的所有调用中，函数 `are_connected` 被调用的最多次数", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2023] 最长路程", "background": "IOI2023 D1T2\n\n**特别提醒，由于洛谷交互机制的特殊性，你不能在程序中引入头文件，而需要把头文件的内容加入文件的开头。即，在程序开头加入以下几行语句：**\n\n```\n#include <vector>\n\nstd::vector<int> longest_trip(int N, int D);\n\nbool are_connected(std::vector<int> A, std::vector<int> B);\n```", "description": "IOI 2023 组委会有大麻烦了！他们忘记计划即将到来的 Ópusztaszer 之旅了。然而，或许一切尚未为晚 ......\n\n在 Ópusztaszer 有 $N$ 个地标，编号为从 $0$ 到 $N-1$。某些地标之间连有**双向**的**道路**。任意一对地标之间至多连有一条道路。组委会**不知道**哪些地标之间有道路相连。\n\n如果对于每三个不同的地标，它们之间都至少连有 $\\delta$ 条道路，我们就称 Ópusztaszer 的路网**密度**是**至少**为 $\\delta$ 的。换言之，对所有满足 $0 \\le u \\lt v \\lt w \\lt N$ 的地标三元组 $(u, v, w)$，配对 $(u,v)$，$(v,w)$ 和 $(u,w)$ 中至少有 $\\delta$ 个配对中的地标有道路相连。\n\n组委会**已知**有某个正整数 $D$，满足路网密度至少为 $D$。注意， $D$ 的值不会大于 $3$。\n\n组委会可以**询问** Ópusztaszer 的电话接线员，以获取关于某些地标之间的道路连接信息。在每次询问时，必须给出两个非空的地标数组 $[A[0], \\ldots, A[P-1]]$ 和 $[B[0], \\ldots, B[R-1]]$。地标之间必须是两两不同的，即，\n\n* 对于满足 $0 \\le i \\lt j \\lt P$ 的所有 $i$ 和 $j$，有 $A[i] \\neq A[j]$；\n* 对于满足 $0 \\le i \\lt j \\lt R$ 的所有 $i$ 和 $j$，有 $B[i] \\neq B[j]$；\n* 对于满足 $0 \\le i \\lt P$ 且 $0\\le j \\lt R$ 的所有 $i$ 和 $j$，有 $A[i] \\neq B[j]$。\n\n对每次询问，接线员都会报告是否存在 $A$ 中的某个地标和 $B$ 中的某个地标有道路相连。更准确地说，接线员会对满足 $0 \\le i \\lt P$ 和 $0\\le j \\lt R$ 的所有配对 $i$ 和 $j$ 进行尝试。如果其中某对地标 $A[i]$ 与 $B[j]$ 之间连有道路，接线员将报告 `true`。否则，接线员将报告 `false`。\n\n一条长度为 $l$ 的**路程**，被定义为由**不同**地标 $t[0], t[1], \\ldots, t[l-1]$ 构成的序列，其中对从 $0$ 到 $l-2$（包括 $0$ 和 $l-2$）的所有 $i$，地标 $t[i]$ 和 $t[i+1]$ 之间都有道路相连。如果不存在长度至少为 $l+1$ 的路程，则长度为 $l$ 的某条路程被称为是**最长路程**。\n\n你的任务是通过询问接线员，帮助组委会在 Ópusztaszer 找一条最长路程。\n\n---\n\n**【实现细节】**\n\n你需要实现如下函数：\n\n```\nint[] longest_trip(int N, int D)\n```\n\n* $N$：Ópusztaszer 的地标数量。\n* $D$：可以保证的路网密度最小值。\n* 该函数需要返回一个表示某条最长路程的数组 $t = [t[0], t[1], \\ldots, t[l-1]]$。\n* 对于每个测试用例，该函数都可能会被调用 **多次**。\n\n上述函数可以调用如下函数：\n\n```\nbool are_connected(int[] A, int[] B)\n```\n\n* $A$：一个非空、且元素两两不同的地标数组。\n* $B$：一个非空、且元素两两不同的地标数组。\n* $A$ 和 $B$ 之间应无交集。\n* 如果存在连接 $A$ 中某个地标以及 $B$ 中某个地标的道路，该函数返回 `true`。否则该函数返回 `false`。\n* 在每次 `longest_trip` 调用中，该函数可以被至多调用 $32\\,640$ 次。该函数的累计调用总数至多为 $150\\,000$ 次。\n* 对历次调用该函数时传递的数组 $A$ 和 $B$ 长度进行累计，两个数组累计长度加起来不能超过 $1\\,500\\,000$。\n\n评测程序是**非适应性的**。每次提交都将在同一组测试用例上进行评测。换言之，在每个测试用例中，$N$ 和 $D$ 的值，以及道路所连接的地标配对，对于每次 `longest_trip` 调用都保持不变。", "inputFormat": "", "outputFormat": "", "hint": "**【例子】**\n\n**样例一**\n\n考虑某个 $N = 5$, $D = 1$ 的场景，其中道路连接情形如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h4q6u936.png)\n\n函数 `longest_trip` 被调用如下：\n\n```\nlongest_trip(5, 1)\n```\n\n该函数可以调用 `are_connected` 如下。\n\n|                调用                |  有道路连接的配对  | 返回值  |\n| :--------------------------------: | :----------------: | :-----: |\n| `are_connected([0], [1, 2, 4, 3])` | $(0,1)$ 和 $(0,2)$ | `true`  |\n|     `are_connected([2], [0])`      |      $(2,0)$       | `true`  |\n|     `are_connected([2], [3])`      |      $(2,3)$       | `true`  |\n|  `are_connected([1, 0], [4, 3])`   |         无         | `false` |\n\n在第四次调用后，可知 $(1,4)$，$(0,4)$，$(1,3)$ 和 $(0,3)$ 中**没有**哪个配对中的地标之间连有道路。由于路网的密度至少是 $D = 1$，我们由三元组 $(0, 3, 4)$ 可知，配对 $(3,4)$ 的地标之间必须连有道路。与此相似，地标 $0$ 和 $1$ 之间必须是相连的。\n\n至此，可以总结出 $t = [1, 0, 2, 3, 4]$ 是一条长度为 $5$ 的路程，而且不存在长度超过 $5$ 的路程。因此，函数 `longest_trip` 可以返回 $[1, 0, 2, 3, 4]$。\n\n考虑另一个场景， 其中 $N = 4$, $D = 1$，且地标之间的道路如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6kk0r3y9.png)\n\n函数 `longest_trip` 被调用如下：\n\n```\nlongest_trip(4, 1)\n```\n\n在这个场景中，最长路程的长度为 $2$。因此，在对函数 `are_connected` 进行少量调用后，函数 `longest_trip` 可以返回 $[0, 1]$, $[1, 0]$, $[2, 3]$ 和 $[3, 2]$ 中的任意一个.\n\n**样例 2**\n\n子任务 0 包含另一个测试用例用作示例，其中有 $N=256$ 个地标。\n\n**【数据范围】**\n\n* $3 \\le N \\le 256$\n* 对于每个测试用例，函数 `longest_trip` 的所有调用中 $N$ 的累计总和不超过 $1\\,024$。\n* $1 \\le D \\le 3$\n\n**【子任务】**\n\n1. （5 分）$D = 3$\n1. （10 分）$D = 2$\n1. （25 分）$D = 1$。令 $l^\\star$ 表示最长路程的长度。函数 `longest_trip` 不必返回长度为 $l^\\star$ 的某条路程，而应返回长度至少为 $\\left\\lceil \\frac{l^\\star}{2} \\right\\rceil$ 的某条路程。\n1. （60 分）$D = 1$\n\n在子任务 4 中，你的得分将根据 `longest_trip` 的单次调用中对函数 `are_connected` 的调用数量而定。对该子任务的所有测试用例调用 `longest_trip`，令 $q$ 为各次调用产生的函数 `are_connected` 调用次数的最大值。\n你在该子任务上的得分将按照下表进行计算：\n\n|            条件            | 得分 |\n| :------------------------: | :--: |\n| $2\\,750 \\lt q \\le 32\\,640$ | $20$ |\n|   $550 \\lt q \\le 2\\,750$   | $30$ |\n|    $400 \\lt q \\le 550$     | $45$ |\n|        $q \\le 400$         | $60$ |\n\n如果在某个测试用例上，对函数 `are_connected` 的调用没有遵守实现细节部分给出的限制条件，或者 `longest_trip` 返回的数组是错误的，你的解答在该子任务上的得分将为 $0$。\n\n**【评测程序示例】**\n\n令 $C$ 为场景数量，即调用 `longest_trip` 的次数。\n评测程序示例读取如下格式的输入数据：\n\n* 第 $1$ 行：$C$\n\n接下来是这 $C$ 个场景的描述数据。\n\n评测程序示例读取每个场景如下格式的描述数据：\n\n* 第 $1$ 行：$N \\; D$\n* 第 $1 + i$ 行（$1 \\le i \\lt N$）：$U_i[0] \\; U_i[1] \\; \\ldots \\; U_i[i-1]$\n\n这里每个 $U_i$（$1 \\le i \\lt N$）均为长度为 $i$ 的数组，以给出那些有道路相连的地标配对。对于满足 $1 \\le i \\lt N$ 且 $0 \\le j \\lt i$ 的所有 $i$ 和 $j$：\n\n* 如果地标 $j$ 和 $i$ 之间有道路相连，则 $U_i[j]$ 的值应为 $1$；\n* 如果地标 $j$ 和 $i$ 之间没有道路相连，则 $U_i[j]$ 的值应为 $0$。\n\n在每个场景中，在调用 `longest_trip` 之前，评测程序示例检查路网的密度是否至少为 $D$。如果不满足该条件，评测程序示例将输出信息 `Insufficient Density` 并中止。\n\n如果检查出违反规则的行为，评测程序示例的输出为 `Protocol Violation: <MSG>`，这里 `<MSG>` 为如下错误信息之一：\n\n* `invalid array`：在 `are_connected` 的某次调用中，数组 $A$ 和 $B$ 中至少其一\n  - 为空，或\n  - 有元素不是 $0$ 到 $N-1$ 之间（包含 $0$ 和 $N-1$）的整数，或\n  - 有重复元素。\n* `non-disjoint arrays`：在 `are_connected` 的某次调用中，数组 $A$ 和 $B$ 的交集不空。\n* `too many calls`：函数 `are_connected` 在 `longest trip` 的当前调用中的被调用次数超过了 $32\\,640$，或者其累计调用次数超过了 $150\\,000$。\n* `too many elements`：在 `are_connected` 的全部调用中，所传递的地标的累计数量超过了 $1\\,500\\,000$。\n\n否则，令 `longest_trip` 函数在某个场景中的返回数组为 $t[0], t[1], \\ldots, t[l - 1]$，这里 $l$ 为某个非负整数。评测程序示例将对该场景按照如下格式输出三行：\n\n* 第 $1$ 行：$l$\n* 第 $2$ 行：$t[0] \\; t[1] \\; \\ldots \\; t[l-1]$\n* 第 $3$ 行：在该场景中调用 `are_connected` 的次数\n\n最后，评测程序示例输出：\n\n* 第 $1 + 3 \\cdot C$ 行：在 `longest_trip` 的所有调用中，函数 `are_connected` 被调用的最多次数", "locale": "zh-CN"}}}
{"pid": "P9602", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2023", "IOI", "交互题", "Special Judge", "O2优化"], "title": "[IOI 2023] 足球场", "background": "这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。\n\n本题仅支持 C++ 语言提交。", "description": "Debrecen 市有一片正方形的森林名叫 Nagyerdő，可以看作是 $N \\times N$ 的方格。\n方格的行由北向南从 $0$ 到 $N - 1$ 编号，列由西向东从 $0$ 到 $N - 1$ 编号。\n方格中第 $r$ 行第 $c$ 列的格子被称为单元格 $(r, c)$。\n\n森林里的每个单元格要么是**空**的，要么是**有树**的。\n森林里至少有一个空单元格。\n\nDVSC 是这个城市最著名的体育俱乐部，目前正计划在森林里修建一座新的足球场。\n大小为 $s$ 的球场（这里 $s \\ge 1$）是 $s$ 个**互不相同的空**单元格 $(r_0, c_0), \\ldots, (r_{s - 1}, c_{s - 1})$ 的集合。\n形式化地说，这意味着：\n\n- 对于从 $0$ 到 $s - 1$（包含两端）的每个 $i$，单元格 $(r_i, c_i)$ 是空的；\n- 对于满足 $0 \\le i \\lt j \\lt s$ 的每组 $i$ 和 $j$，$r_i \\neq r_j$ 和 $c_i \\neq c_j$ 二者中至少有一个成立。\n\n踢球时足球在球场的单元格之间传递。\n**直传**是以下两种动作之一：\n\n* 球场包含第 $r$ 行中单元格 $(r,a)$ 和 $(r,b)$ 之间的**全部**单元格，球从单元格 $(r,a)$ 传递到单元格 $(r,b)$（$0 \\le r,a,b \\lt N, a \\ne b$）。包含关系的形式化定义为：\n  - 若 $a \\lt b$，则球场应包含满足 $a \\le k \\le b$ 的每个单元格 $(r,k)$；\n  - 若 $a \\gt b$，则球场应包含满足 $b \\le k \\le a$ 的每个单元格 $(r,k)$。\n* 球场包含第 $c$ 列中单元格 $(a,c)$ 和 $(b,c)$ 之间的**全部**单元格，球从单元格 $(a,c)$ 传递到单元格 $(b,c)$（$0 \\le c,a,b \\lt N, a \\ne b$）。包含关系的形式化定义为：\n  - 若 $a \\lt b$，则球场应包含满足 $a \\le k \\le b$ 的每个单元格 $(k, c)$；\n  - 若 $a \\gt b$，则球场应包含满足 $b \\le k \\le a$ 的每个单元格 $(k, c)$。\n\n如果可以通过至多 $2$ 次直传将球从球场的任意单元格传递到另外的任意单元格，那么称这样的球场是**规则**的。\n注意，任何大小为 $1$ 的球场都是规则的。\n\n例如，考虑一片大小为 $N = 5$ 的森林，其中单元格 $(1,0)$ 和 $(4,2)$ 有树，其余单元格均为空。\n下图显示了三个可能的球场。有树的单元格用深色表示，组成球场的单元格划有斜线。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rhrk04xf.png)\n\n左边的球场是规则的。然而，中间的球场不是规则的，原因是把球从单元格 $(4,1)$ 传递到单元格 $(4,3)$ 至少需要 $3$ 次直传。右边的球场也不是规则的，原因是无法通过直传将球从单元格 $(3,0)$ 传递到单元格 $(1,3)$。\n\n体育俱乐部希望建造尽可能大的规则球场。\n你的任务是找出最大的 $s$ 值，使得森林里可以建造大小为 $s$ 的规则球场。", "inputFormat": "你要实现以下函数：\n\n```\nint biggest_stadium(int N, int[][] F)\n```\n\n* $N$：森林的大小。\n* $F$：一个长度为 $N$ 的数组，每个元素都是长度为 $N$ 的数组，用于描述森林里的单元格。对于每组满足 $0 \\le r \\lt N$ 且 $0 \\le c \\lt N$ 的 $r$ 和 $c$，$F[r][c] = 0$ 表示单元格 $(r, c)$ 是空的，$F[r][c] = 1$ 表示该单元格是有树的。\n* 这个函数应该返回森林里可以建造的规则球场的最大大小。\n* 对于每个测试用例，这个函数恰好被调用一次。", "outputFormat": "考虑以下调用：\n\n```\nbiggest_stadium(5, [[0, 0, 0, 0, 0],  \n                    [1, 0, 0, 0, 0], \n                    [0, 0, 0, 0, 0], \n                    [0, 0, 0, 0, 0], \n                    [0, 0, 1, 0, 0]])\n```\n\n这个例子描述的森林显示在下图的左边，一个大小为 $20$ 的规则球场显示在下图的右边：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/c928srlk.png)\n\n由于不存在大小为 $21$ 或更大的规则球场，函数应该返回 $20$。", "hint": "## 约束条件\n\n* $1 \\le N \\le  2\\,000$\n* $0 \\le F[i][j] \\le 1$（对满足 $0 \\le i \\lt N$ 且 $0 \\le j \\lt N$ 的所有 $i$ 和 $j$）\n* 森林里至少存在一个空单元格。也就是说，对于某组满足 $0 \\le i \\lt N$ 且 $0 \\le j \\lt N$ 的 $i$ 和 $j$，有 $F[i][j] = 0$。\n\n## 子任务\n\n1. （6 分）至多只有一个单元格有树。\n2. （8 分）$N \\le 3$\n3. （22 分）$N \\le 7$ \n4. （18 分）$N \\le 30$ \n5. （16 分）$N \\le 500$\n6. （30 分）没有额外的约束条件。\n\n在每个子任务中，如果你的程序能够正确判定**全部**空单元格组成的集合能否构成一个规则球场，那么你将在该子任务获得 25% 的部分分。\n\n更准确地讲，对于所有空单元格组成的集合是一个规则球场的测试用例，你的解答的得分情况如下：\n\n* 如果返回正确答案（也就是所有空单元格的数量），则得满分；\n* 否则得 0 分。\n\n对于所有空单元格组成的集合**不是**一个规则球场的测试用例，你的解答的得分情况如下：\n\n* 如果返回正确答案，则得满分；\n* 如果返回所有空单元格的数量，则得 0 分；\n* 如果返回其他值，则得 25% 的分数。\n\n每个子任务的得分是这个子任务中所有测试用例得分的最低值。\n\n## 评测程序示例\n\n评测程序示例按以下格式读取输入：\n\n* 第 $1$ 行：$N$\n* 第 $2 + i$ 行（$0 \\le i \\lt N$）：$F[i][0] \\; F[i][1] \\; \\ldots \\; F[i][N - 1]$\n\n评测程序示例按以下格式打印你的答案：\n\n* 第 $1$ 行：函数 `biggest_stadium` 的返回值", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2023] 足球场", "background": "这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。\n\n本题仅支持 C++ 语言提交。", "description": "Debrecen 市有一片正方形的森林名叫 Nagyerdő，可以看作是 $N \\times N$ 的方格。\n方格的行由北向南从 $0$ 到 $N - 1$ 编号，列由西向东从 $0$ 到 $N - 1$ 编号。\n方格中第 $r$ 行第 $c$ 列的格子被称为单元格 $(r, c)$。\n\n森林里的每个单元格要么是**空**的，要么是**有树**的。\n森林里至少有一个空单元格。\n\nDVSC 是这个城市最著名的体育俱乐部，目前正计划在森林里修建一座新的足球场。\n大小为 $s$ 的球场（这里 $s \\ge 1$）是 $s$ 个**互不相同的空**单元格 $(r_0, c_0), \\ldots, (r_{s - 1}, c_{s - 1})$ 的集合。\n形式化地说，这意味着：\n\n- 对于从 $0$ 到 $s - 1$（包含两端）的每个 $i$，单元格 $(r_i, c_i)$ 是空的；\n- 对于满足 $0 \\le i \\lt j \\lt s$ 的每组 $i$ 和 $j$，$r_i \\neq r_j$ 和 $c_i \\neq c_j$ 二者中至少有一个成立。\n\n踢球时足球在球场的单元格之间传递。\n**直传**是以下两种动作之一：\n\n* 球场包含第 $r$ 行中单元格 $(r,a)$ 和 $(r,b)$ 之间的**全部**单元格，球从单元格 $(r,a)$ 传递到单元格 $(r,b)$（$0 \\le r,a,b \\lt N, a \\ne b$）。包含关系的形式化定义为：\n  - 若 $a \\lt b$，则球场应包含满足 $a \\le k \\le b$ 的每个单元格 $(r,k)$；\n  - 若 $a \\gt b$，则球场应包含满足 $b \\le k \\le a$ 的每个单元格 $(r,k)$。\n* 球场包含第 $c$ 列中单元格 $(a,c)$ 和 $(b,c)$ 之间的**全部**单元格，球从单元格 $(a,c)$ 传递到单元格 $(b,c)$（$0 \\le c,a,b \\lt N, a \\ne b$）。包含关系的形式化定义为：\n  - 若 $a \\lt b$，则球场应包含满足 $a \\le k \\le b$ 的每个单元格 $(k, c)$；\n  - 若 $a \\gt b$，则球场应包含满足 $b \\le k \\le a$ 的每个单元格 $(k, c)$。\n\n如果可以通过至多 $2$ 次直传将球从球场的任意单元格传递到另外的任意单元格，那么称这样的球场是**规则**的。\n注意，任何大小为 $1$ 的球场都是规则的。\n\n例如，考虑一片大小为 $N = 5$ 的森林，其中单元格 $(1,0)$ 和 $(4,2)$ 有树，其余单元格均为空。\n下图显示了三个可能的球场。有树的单元格用深色表示，组成球场的单元格划有斜线。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rhrk04xf.png)\n\n左边的球场是规则的。然而，中间的球场不是规则的，原因是把球从单元格 $(4,1)$ 传递到单元格 $(4,3)$ 至少需要 $3$ 次直传。右边的球场也不是规则的，原因是无法通过直传将球从单元格 $(3,0)$ 传递到单元格 $(1,3)$。\n\n体育俱乐部希望建造尽可能大的规则球场。\n你的任务是找出最大的 $s$ 值，使得森林里可以建造大小为 $s$ 的规则球场。", "inputFormat": "你要实现以下函数：\n\n```\nint biggest_stadium(int N, int[][] F)\n```\n\n* $N$：森林的大小。\n* $F$：一个长度为 $N$ 的数组，每个元素都是长度为 $N$ 的数组，用于描述森林里的单元格。对于每组满足 $0 \\le r \\lt N$ 且 $0 \\le c \\lt N$ 的 $r$ 和 $c$，$F[r][c] = 0$ 表示单元格 $(r, c)$ 是空的，$F[r][c] = 1$ 表示该单元格是有树的。\n* 这个函数应该返回森林里可以建造的规则球场的最大大小。\n* 对于每个测试用例，这个函数恰好被调用一次。", "outputFormat": "考虑以下调用：\n\n```\nbiggest_stadium(5, [[0, 0, 0, 0, 0],  \n                    [1, 0, 0, 0, 0], \n                    [0, 0, 0, 0, 0], \n                    [0, 0, 0, 0, 0], \n                    [0, 0, 1, 0, 0]])\n```\n\n这个例子描述的森林显示在下图的左边，一个大小为 $20$ 的规则球场显示在下图的右边：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/c928srlk.png)\n\n由于不存在大小为 $21$ 或更大的规则球场，函数应该返回 $20$。", "hint": "## 约束条件\n\n* $1 \\le N \\le  2\\,000$\n* $0 \\le F[i][j] \\le 1$（对满足 $0 \\le i \\lt N$ 且 $0 \\le j \\lt N$ 的所有 $i$ 和 $j$）\n* 森林里至少存在一个空单元格。也就是说，对于某组满足 $0 \\le i \\lt N$ 且 $0 \\le j \\lt N$ 的 $i$ 和 $j$，有 $F[i][j] = 0$。\n\n## 子任务\n\n1. （6 分）至多只有一个单元格有树。\n2. （8 分）$N \\le 3$\n3. （22 分）$N \\le 7$ \n4. （18 分）$N \\le 30$ \n5. （16 分）$N \\le 500$\n6. （30 分）没有额外的约束条件。\n\n在每个子任务中，如果你的程序能够正确判定**全部**空单元格组成的集合能否构成一个规则球场，那么你将在该子任务获得 25% 的部分分。\n\n更准确地讲，对于所有空单元格组成的集合是一个规则球场的测试用例，你的解答的得分情况如下：\n\n* 如果返回正确答案（也就是所有空单元格的数量），则得满分；\n* 否则得 0 分。\n\n对于所有空单元格组成的集合**不是**一个规则球场的测试用例，你的解答的得分情况如下：\n\n* 如果返回正确答案，则得满分；\n* 如果返回所有空单元格的数量，则得 0 分；\n* 如果返回其他值，则得 25% 的分数。\n\n每个子任务的得分是这个子任务中所有测试用例得分的最低值。\n\n## 评测程序示例\n\n评测程序示例按以下格式读取输入：\n\n* 第 $1$ 行：$N$\n* 第 $2 + i$ 行（$0 \\le i \\lt N$）：$F[i][0] \\; F[i][1] \\; \\ldots \\; F[i][N - 1]$\n\n评测程序示例按以下格式打印你的答案：\n\n* 第 $1$ 行：函数 `biggest_stadium` 的返回值", "locale": "zh-CN"}}}
{"pid": "P9603", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2023", "IOI", "交互题", "Special Judge", "O2优化"], "title": "[IOI 2023] 山毛榉树", "background": "这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 main 函数。\n\n本题仅支持 C++ 语言提交。", "description": "Vétyem Woods 是一片著名的缤纷多彩的森林。其中最老最高的一棵山毛榉树叫 Ős Vezér。\n\n树 Ős Vezér 可以被建模成 $N$ 个**结点**和 $N-1$ 条**边**的集合。结点的编号为从 $0$ 到 $N-1$，边的编号为从 $1$ 到 $N-1$。每条边均连接树上两个不同的结点。具体地说，边 $i$（$1 \\le i \\lt N$）从结点 $i$ 连接到结点 $P[i]$，这里 $0 \\le P[i] \\lt i$。结点 $P[i]$ 被称为是结点 $i$ 的**父结点**，而结点 $i$ 被称为是结点 $P[i]$ 的一个**子结点**。\n\n每条边都有某种颜色。一共有 $M$ 种可能的颜色，编号为从 $1$ 到 $M$。边 $i$ 的颜色为 $C[i]$。不同的边可能有相同的颜色。\n\n注意，在上面的定义中，$i = 0$ 的情形并不对应树上的边。方便起见，我们令 $P[0] = -1$ 和 $C[0] = 0$。\n\n例如，假定 Ős Vezér 有 $N = 18$ 个结点和 $M = 3$ 种可能的颜色，以及 $17$ 条边。边的描述为 $P = [-1, 0, 0, 0, 1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 10, 11, 11]$，边的颜色为 $C = [0, 1, 2, 3, 1, 2, 3, 1, 3, 3, 2, 1, 1, 2, 2, 1, 2, 3]$。这棵树如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xnxdhpz1.png)\n\nÁrpád 是一位才华横溢的护林人，他喜欢研究树上被称为**子树**的部分。\n对所有满足 $0 \\le r \\lt N$ 的  $r$，结点 $r$ 的子树是一个满足以下性质的结点集合 $T(r)$：\n\n* 结点 $r$ 属于 $T(r)$。\n* 如果某个结点 $x$ 属于 $T(r)$，则 $x$ 的所有子结点都属于$T(r)$。\n* 除了上述情况以外，其他结点都不属于 $T(r)$。\n\n集合 $T(r)$ 的大小记作 $|T(r)|$。\n\nÁrpád 最近发现了一个复杂但有趣的子树性质。Árpád 的发现需要用到大量的纸和笔做演算，他认为你需要做同样的事情才能完成理解。他还会给你几个例子，让你能够对它们做详细的分析。\n\n假设我们有某个给定的 $r$，以及子树 $T(r)$ 中结点的某个置换 $v_0, v_1, \\ldots, v_{|T(r)|-1}$。\n\n对于所有满足 $1 \\le i \\lt |T(r)|$ 的 $i$，令 $f(i)$ 为颜色 $C[v_i]$ 在长为 $i-1$ 的颜色序列 $C[v_1], C[v_2], \\ldots, C[v_{i-1}]$ 中的出现次数。\n\n（注意，$f(1)$ 必定为 $0$，原因是其定义中要考察的颜色序列是空的。）\n\n置换 $v_0, v_1, \\ldots, v_{|T(r)|-1}$ 被称为是一个**绝妙置换**，当且仅当以下性质成立：\n\n* $v_0 = r$。\n* 对于所有满足 $1 \\le i \\lt |T(r)|$ 的 $i$，结点 $v_i$ 的父结点是 $v_{f(i)}$。\n\n对于所有满足 $0 \\le r \\lt N$ 的 $r$，子树 $T(r)$ 是一棵**绝妙子树**，当且仅当 $T(r)$ 中结点存在某个绝妙置换。注意，根据定义，仅包含单独一个结点的子树都是绝妙的。\n\n考虑上面给出的树的例子。可以看到，子树 $T(0)$ 和 $T(3)$ 不是绝妙的。子树 $T(14)$ 是绝妙的，因为它仅包含一个结点。接下来，我们将要说明子树 $T(1)$ 也是绝妙的。\n\n考虑一个由不同整数构成的序列 $[v_0, v_1, v_2, v_3, v_4, v_5, v_6] = [1, 4, 5, 12, 13, 6, 14]$。这个序列是 $T(1)$ 中结点的一个置换。下图给出了这个置换。序列中每个结点旁边的数字，是该结点在置换中的索引。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ziecuezc.png)\n\n我们将要验证，这是一个**绝妙置换**。\n\n* $v_0 = 1$。\n* $f(1) = 0$，原因是 $C[v_1] = C[4] = 1$ 在序列 $[\\,]$ 中出现了 $0$ 次。\n * 相应地，$v_1$ 的父结点是 $v_0$。也就是说，$4$ 的父结点是 $1$。（形式化地，$P[4] = 1$。）\n* $f(2) = 0$，原因是 $C[v_2] = C[5] = 2$ 在序列 $[1]$ 中出现了 $0$ 次。\n * 相应地，$v_2$ 的父结点是 $v_0$。也就是说，$5$ 的父结点是 $1$。\n* $f(3) = 1$，原因是 $C[v_3] = C[12] = 1$ 在序列 $[1, 2]$ 中出现了 $1$ 次。\n * 相应地，$v_3$ 的父结点是 $v_1$。也就是说，$12$ 的父结点是 $4$。\n* $f(4) = 1$，原因是 $C[v_4] = C[13] = 2$ 在序列 $[1, 2, 1]$ 中出现了 $1$ 次。\n * 相应地，$v_4$ 的父结点是 $v_1$。也就是说，$13$ 的父结点是 4。\n* $f(5) = 0$，原因是 $C[v_5] = C[6] = 3$ 在序列 $[1, 2, 1, 2]$ 中出现了 $0$ 次。\n * 相应地，$v_5$ 的父结点是 $v_0$。也就是说，$6$ 的父结点是 $1$。\n* $f(6) = 2$，原因是 $C[v_6] = C[14] = 2$ 在序列 $[1, 2, 1, 2, 3]$ 中出现了  $2$ 次。\n * 相应地，$v_6$ 的父结点是 $v_2$。也就是说，$14$ 的父结点是 $5$。\n\n由于我们能为 $T(1)$ 中的结点找到一个**绝妙置换**，子树 $T(1)$ 因此是一棵**绝妙子树**。\n\n你的任务是，帮助 Árpád 确定 Ős Vezér 的每棵子树是否是绝妙的。", "inputFormat": "你需要实现以下函数。\n\n```\nint[] beechtree(int N, int M, int[] P, int[] C)\n```\n\n* $N$：树中的结点数量。\n* $M$：树中边的可能颜色的数量。\n* $P$，$C$：长度为 $N$ 的两个数组，以描述树中的边。\n* 该函数应当返回长度为 $N$ 的某个数组 $b$。 \n  对所有满足 $0 \\le r \\lt N$ 的 $r$，如果 $T(r)$ 是绝妙的，则 $b[r]$ 应为 $1$，否则应为 $0$。\n* 该函数在每个测试用例上恰好被调用一次。", "outputFormat": "", "hint": "\n\n### 样例\n\n#### 样例 1\n\n考虑如下调用：\n\n```\nbeechtree(4, 2, [-1, 0, 0, 0], [0, 1, 1, 2])\n```\n\n这棵树如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bcv1naft.png)\n\n$T(1)$，$T(2)$ 和 $T(3)$ 均各自包含单独一个结点，因此都是绝妙的。\n$T(0)$ 不是绝妙的。\n因此，函数应当返回 $[0, 1, 1, 1]$。\n\n#### 样例 2\n\n考虑如下调用：\n\n```\nbeechtree(18, 3, \n          [-1, 0, 0, 0, 1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 10, 11, 11],\n          [0, 1, 2, 3, 1, 2, 3, 1, 3, 3, 2, 1, 1, 2, 2, 1, 2, 3])\n```\n\n这个例子在题面中已经给出。\n\n函数应当返回 $[0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]$。\n\n#### 样例 3\n\n考虑如下调用：\n\n```\nbeechtree(7, 2, [-1, 0, 1, 1, 0, 4, 5], [0, 1, 1, 2, 2, 1, 1])\n```\n\n该例子如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cv6ljl13.png)\n\n$T(0)$ 是唯一不是绝妙的子树。函数应当返回 $[0, 1, 1, 1, 1, 1, 1]$。\n\n### 约束条件\n\n* $3 \\le N \\le 200\\,000$\n* $2 \\le M \\le 200\\,000$\n* $0 \\le P[i] \\lt i$（对于所有满足 $1 \\le i \\lt N$ 的 $i$）\n* $1 \\le C[i] \\le M$（对于所有满足 $1 \\le i \\lt N$ 的 $i$）\n* $P[0] = -1$ 且 $C[0] = 0$\n\n### 子任务\n\n1. （9 分）$N \\le 8$ 且 $M \\le 500$\n1. （5 分）边 $i$ 从结点 $i$ 连接到结点 $i-1$。也就是说，对所有满足 $1 \\le i \\lt N$ 的 $i$，都有 $P[i] = i-1$。\n1. （9 分）除了结点 $0$ 以外，其他结点要么连接到结点 $0$，要么连接到某个连接到结点 $0$ 的结点。\n    也就是说，对于所有满足 $1 \\le i \\lt N$ 的 $i$，要么有 $P[i]=0$，要么有 $P[P[i]]=0$。\n1. （8 分）对于所有满足 $1 \\le c \\le M$ 的 $c$，至多有两条边的颜色为 $c$。\n1. （14 分） $N \\le 200$ 且 $M \\le 500$\n1. （14 分） $N \\le 2\\,000$ 且 $M = 2$\n1. （12 分） $N \\le 2\\,000$\n1. （17 分） $M = 2$\n1. （12 分） 没有额外的约束条件。\n\n### 评测程序示例\n\n评测程序示例按以下格式读取输入：\n\n* 第 $1$ 行：$N \\; M$\n* 第 $2$ 行：$P[0] \\; P[1] \\; \\ldots \\; P[N-1]$\n* 第 $3$ 行：$C[0] \\; C[1] \\; \\ldots \\; C[N-1]$\n\n令 $b[0], \\; b[1], \\; \\ldots$ 表示 `beechtree` 所返回的数组中的元素。评测程序示例以如下格式，在单行中输出你的答案：\n* 第 $1$ 行：$b[0] \\; b[1] \\; \\ldots$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2023] 山毛榉树", "background": "这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 main 函数。\n\n本题仅支持 C++ 语言提交。", "description": "Vétyem Woods 是一片著名的缤纷多彩的森林。其中最老最高的一棵山毛榉树叫 Ős Vezér。\n\n树 Ős Vezér 可以被建模成 $N$ 个**结点**和 $N-1$ 条**边**的集合。结点的编号为从 $0$ 到 $N-1$，边的编号为从 $1$ 到 $N-1$。每条边均连接树上两个不同的结点。具体地说，边 $i$（$1 \\le i \\lt N$）从结点 $i$ 连接到结点 $P[i]$，这里 $0 \\le P[i] \\lt i$。结点 $P[i]$ 被称为是结点 $i$ 的**父结点**，而结点 $i$ 被称为是结点 $P[i]$ 的一个**子结点**。\n\n每条边都有某种颜色。一共有 $M$ 种可能的颜色，编号为从 $1$ 到 $M$。边 $i$ 的颜色为 $C[i]$。不同的边可能有相同的颜色。\n\n注意，在上面的定义中，$i = 0$ 的情形并不对应树上的边。方便起见，我们令 $P[0] = -1$ 和 $C[0] = 0$。\n\n例如，假定 Ős Vezér 有 $N = 18$ 个结点和 $M = 3$ 种可能的颜色，以及 $17$ 条边。边的描述为 $P = [-1, 0, 0, 0, 1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 10, 11, 11]$，边的颜色为 $C = [0, 1, 2, 3, 1, 2, 3, 1, 3, 3, 2, 1, 1, 2, 2, 1, 2, 3]$。这棵树如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xnxdhpz1.png)\n\nÁrpád 是一位才华横溢的护林人，他喜欢研究树上被称为**子树**的部分。\n对所有满足 $0 \\le r \\lt N$ 的  $r$，结点 $r$ 的子树是一个满足以下性质的结点集合 $T(r)$：\n\n* 结点 $r$ 属于 $T(r)$。\n* 如果某个结点 $x$ 属于 $T(r)$，则 $x$ 的所有子结点都属于$T(r)$。\n* 除了上述情况以外，其他结点都不属于 $T(r)$。\n\n集合 $T(r)$ 的大小记作 $|T(r)|$。\n\nÁrpád 最近发现了一个复杂但有趣的子树性质。Árpád 的发现需要用到大量的纸和笔做演算，他认为你需要做同样的事情才能完成理解。他还会给你几个例子，让你能够对它们做详细的分析。\n\n假设我们有某个给定的 $r$，以及子树 $T(r)$ 中结点的某个置换 $v_0, v_1, \\ldots, v_{|T(r)|-1}$。\n\n对于所有满足 $1 \\le i \\lt |T(r)|$ 的 $i$，令 $f(i)$ 为颜色 $C[v_i]$ 在长为 $i-1$ 的颜色序列 $C[v_1], C[v_2], \\ldots, C[v_{i-1}]$ 中的出现次数。\n\n（注意，$f(1)$ 必定为 $0$，原因是其定义中要考察的颜色序列是空的。）\n\n置换 $v_0, v_1, \\ldots, v_{|T(r)|-1}$ 被称为是一个**绝妙置换**，当且仅当以下性质成立：\n\n* $v_0 = r$。\n* 对于所有满足 $1 \\le i \\lt |T(r)|$ 的 $i$，结点 $v_i$ 的父结点是 $v_{f(i)}$。\n\n对于所有满足 $0 \\le r \\lt N$ 的 $r$，子树 $T(r)$ 是一棵**绝妙子树**，当且仅当 $T(r)$ 中结点存在某个绝妙置换。注意，根据定义，仅包含单独一个结点的子树都是绝妙的。\n\n考虑上面给出的树的例子。可以看到，子树 $T(0)$ 和 $T(3)$ 不是绝妙的。子树 $T(14)$ 是绝妙的，因为它仅包含一个结点。接下来，我们将要说明子树 $T(1)$ 也是绝妙的。\n\n考虑一个由不同整数构成的序列 $[v_0, v_1, v_2, v_3, v_4, v_5, v_6] = [1, 4, 5, 12, 13, 6, 14]$。这个序列是 $T(1)$ 中结点的一个置换。下图给出了这个置换。序列中每个结点旁边的数字，是该结点在置换中的索引。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ziecuezc.png)\n\n我们将要验证，这是一个**绝妙置换**。\n\n* $v_0 = 1$。\n* $f(1) = 0$，原因是 $C[v_1] = C[4] = 1$ 在序列 $[\\,]$ 中出现了 $0$ 次。\n * 相应地，$v_1$ 的父结点是 $v_0$。也就是说，$4$ 的父结点是 $1$。（形式化地，$P[4] = 1$。）\n* $f(2) = 0$，原因是 $C[v_2] = C[5] = 2$ 在序列 $[1]$ 中出现了 $0$ 次。\n * 相应地，$v_2$ 的父结点是 $v_0$。也就是说，$5$ 的父结点是 $1$。\n* $f(3) = 1$，原因是 $C[v_3] = C[12] = 1$ 在序列 $[1, 2]$ 中出现了 $1$ 次。\n * 相应地，$v_3$ 的父结点是 $v_1$。也就是说，$12$ 的父结点是 $4$。\n* $f(4) = 1$，原因是 $C[v_4] = C[13] = 2$ 在序列 $[1, 2, 1]$ 中出现了 $1$ 次。\n * 相应地，$v_4$ 的父结点是 $v_1$。也就是说，$13$ 的父结点是 4。\n* $f(5) = 0$，原因是 $C[v_5] = C[6] = 3$ 在序列 $[1, 2, 1, 2]$ 中出现了 $0$ 次。\n * 相应地，$v_5$ 的父结点是 $v_0$。也就是说，$6$ 的父结点是 $1$。\n* $f(6) = 2$，原因是 $C[v_6] = C[14] = 2$ 在序列 $[1, 2, 1, 2, 3]$ 中出现了  $2$ 次。\n * 相应地，$v_6$ 的父结点是 $v_2$。也就是说，$14$ 的父结点是 $5$。\n\n由于我们能为 $T(1)$ 中的结点找到一个**绝妙置换**，子树 $T(1)$ 因此是一棵**绝妙子树**。\n\n你的任务是，帮助 Árpád 确定 Ős Vezér 的每棵子树是否是绝妙的。", "inputFormat": "你需要实现以下函数。\n\n```\nint[] beechtree(int N, int M, int[] P, int[] C)\n```\n\n* $N$：树中的结点数量。\n* $M$：树中边的可能颜色的数量。\n* $P$，$C$：长度为 $N$ 的两个数组，以描述树中的边。\n* 该函数应当返回长度为 $N$ 的某个数组 $b$。 \n  对所有满足 $0 \\le r \\lt N$ 的 $r$，如果 $T(r)$ 是绝妙的，则 $b[r]$ 应为 $1$，否则应为 $0$。\n* 该函数在每个测试用例上恰好被调用一次。", "outputFormat": "", "hint": "\n\n### 样例\n\n#### 样例 1\n\n考虑如下调用：\n\n```\nbeechtree(4, 2, [-1, 0, 0, 0], [0, 1, 1, 2])\n```\n\n这棵树如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bcv1naft.png)\n\n$T(1)$，$T(2)$ 和 $T(3)$ 均各自包含单独一个结点，因此都是绝妙的。\n$T(0)$ 不是绝妙的。\n因此，函数应当返回 $[0, 1, 1, 1]$。\n\n#### 样例 2\n\n考虑如下调用：\n\n```\nbeechtree(18, 3, \n          [-1, 0, 0, 0, 1, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 10, 11, 11],\n          [0, 1, 2, 3, 1, 2, 3, 1, 3, 3, 2, 1, 1, 2, 2, 1, 2, 3])\n```\n\n这个例子在题面中已经给出。\n\n函数应当返回 $[0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]$。\n\n#### 样例 3\n\n考虑如下调用：\n\n```\nbeechtree(7, 2, [-1, 0, 1, 1, 0, 4, 5], [0, 1, 1, 2, 2, 1, 1])\n```\n\n该例子如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cv6ljl13.png)\n\n$T(0)$ 是唯一不是绝妙的子树。函数应当返回 $[0, 1, 1, 1, 1, 1, 1]$。\n\n### 约束条件\n\n* $3 \\le N \\le 200\\,000$\n* $2 \\le M \\le 200\\,000$\n* $0 \\le P[i] \\lt i$（对于所有满足 $1 \\le i \\lt N$ 的 $i$）\n* $1 \\le C[i] \\le M$（对于所有满足 $1 \\le i \\lt N$ 的 $i$）\n* $P[0] = -1$ 且 $C[0] = 0$\n\n### 子任务\n\n1. （9 分）$N \\le 8$ 且 $M \\le 500$\n1. （5 分）边 $i$ 从结点 $i$ 连接到结点 $i-1$。也就是说，对所有满足 $1 \\le i \\lt N$ 的 $i$，都有 $P[i] = i-1$。\n1. （9 分）除了结点 $0$ 以外，其他结点要么连接到结点 $0$，要么连接到某个连接到结点 $0$ 的结点。\n    也就是说，对于所有满足 $1 \\le i \\lt N$ 的 $i$，要么有 $P[i]=0$，要么有 $P[P[i]]=0$。\n1. （8 分）对于所有满足 $1 \\le c \\le M$ 的 $c$，至多有两条边的颜色为 $c$。\n1. （14 分） $N \\le 200$ 且 $M \\le 500$\n1. （14 分） $N \\le 2\\,000$ 且 $M = 2$\n1. （12 分） $N \\le 2\\,000$\n1. （17 分） $M = 2$\n1. （12 分） 没有额外的约束条件。\n\n### 评测程序示例\n\n评测程序示例按以下格式读取输入：\n\n* 第 $1$ 行：$N \\; M$\n* 第 $2$ 行：$P[0] \\; P[1] \\; \\ldots \\; P[N-1]$\n* 第 $3$ 行：$C[0] \\; C[1] \\; \\ldots \\; C[N-1]$\n\n令 $b[0], \\; b[1], \\; \\ldots$ 表示 `beechtree` 所返回的数组中的元素。评测程序示例以如下格式，在单行中输出你的答案：\n* 第 $1$ 行：$b[0] \\; b[1] \\; \\ldots$", "locale": "zh-CN"}}}
{"pid": "P9604", "type": "P", "difficulty": 6, "samples": [["6 4 10 4 2\n20 10 40 0\n5 20 20 30\n0 1 3 6\n0\n50\n", "60\n130\n"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2023", "IOI", "交互题", "O2优化"], "title": "[IOI 2023] 超车", "background": "这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。\n\n本题仅支持 C++ 语言提交。但请勿使用 C++14 (GCC 9)", "description": "从布达佩斯机场到 Forrás 酒店有一条单向单车道的公路，公路的长度为 $L$ 公里。\n\nIOI 2023 活动期间，有 $N+1$ 辆巴士在这条公路上行驶。巴士从 $0$ 到 $N$ 依次编号。巴士 $i$（$0 \\le i \\lt N$）计划在活动的第 $T[i]$ 秒从机场出发，行驶一公里用时 $W[i]$ 秒。巴士 $N$ 是备用巴士，行驶一公里用时 $X$ 秒。它从机场出发的时间 $Y$ 尚未确定。\n\n巴士在这条公路上行驶时一般不允许超车，但允许在一些被称为**调度站**的地方进行超车。公路上一共有 $M$ 个调度站（$M \\gt 1$），从 $0$ 到 $M - 1$ 依次编号，位于公路的不同位置。调度站 $j$（$0 \\le j \\lt M$）的位置在机场出发后沿公路的 $S[j]$ 公里处。调度站按照从机场开始的距离递增排列，也就是对于每个 $0 \\le j \\le M - 2$，有 $S[j] \\lt S[j+1]$。首个调度站设在机场，最后一个设在酒店。也就是说，$S[0] = 0$，$S[M-1] = L$。\n\n每辆巴士都以指定的最快速度行驶，除非它遇到前面有比它慢的巴士。在这种情况下，后面的快车会被前面的慢车压着，被迫以慢车的速度行驶。这种情况会持续到两车到达下一个调度站。在那里，快车会完成对慢车的超越。\n\n形式化地说，对于满足 $0 \\le i \\le N$ 且 $0 \\le j \\lt M$ 的每组 $i$ 和 $j$，巴士 $i$ **到达**调度站 $j$ 的时间 $t_{i,j}$（以秒为单位）定义如下：对于每个 $0 \\le i \\lt N$，有 $t_{i,0} = T[i]$。另有 $t_{N,0} = Y$。对于满足 $0 \\lt j \\lt M$ 的每个 $j$：\n\n* 定义巴士 $i$ 到达调度站 $j$ 的**期望到达时间** $e_{i,j}$（以秒为单位）为巴士 $i$ 到达调度站 $j-1$ 之后以全速行驶到达调度站 $j$ 的时间。也就是说，\n  - 对于每个 $0 \\le i \\lt N$，有 $e_{i,j} = t_{i,j-1} + W[i] \\cdot (S[j]-S[j-1])$；\n  - 另有 $e_{N,j} = t_{N,j-1} + X \\cdot (S[j]-S[j-1])$。\n* 巴士 $i$ 到达调度站 $j$ 的时间，是巴士 $i$ 到达调度站 $j$ 的期望到达时间，以及其他比巴士 $i$ 早到调度站 $j-1$ 的巴士到达调度站 $j$ 的期望到达时间中的**最大值**。形式化地说，$t_{i,j}$ 是 $e_{i,j}$ 和所有满足 $0 \\le k \\le N$ 且 $t_{k,j-1} \\lt t_{i,j-1}$ 的 $e_{k,j}$ 中的最大值。\n\nIOI 组委会想要调度备用巴士（巴士 $N$）。你的任务是回答组委会的 $Q$ 个问题，问题的形式如下：给定备用巴士从机场出发的时间 $Y$（以秒为单位），它将于何时到达酒店？", "inputFormat": "评测程序示例按以下格式读取输入：\n\n* 第 $1$ 行：$L \\; N \\; X \\; M \\; Q$\n* 第 $2$ 行：$T[0] \\; T[1] \\; \\ldots \\; T[N-1]$\n* 第 $3$ 行：$W[0] \\; W[1] \\; \\ldots \\; W[N-1]$\n* 第 $4$ 行：$S[0] \\; S[1] \\; \\ldots \\; S[M-1]$\n* 第 $5 + k$ 行（$0 \\le k \\lt Q$）：问题 $k$ 的 $Y$", "outputFormat": "评测程序示例按以下格式打印你的答案：\n\n* 第 $1 + k$ 行（$0 \\le k \\lt Q$）：问题 $k$ 中 `arrival_time` 的返回值", "hint": "**【实现细节】**\n\n你的任务是实现以下函数：\n\n```\nvoid init(int L, int N, int64[] T, int[] W, int X, int M, int[] S)\n```\n\n* $L$：公路的长度\n* $N$：常规（非备用）巴士的数量\n* $T$：长度为 $N$ 的数组，描述常规巴士计划从机场出发的时间。\n* $W$：长度为 $N$ 的数组，描述常规巴士的最大速度。\n* $X$：备用巴士行驶一公里所需的时间\n* $M$：调度站的数量\n* $S$：长度为 $M$ 的数组，描述从机场到调度站的距离。\n* 对于每个测试用例，这个函数都恰好调用一次，发生在对任何 `arrival_time` 的调用之前。\n\n```\nint64 arrival_time(int64 Y)\n```\n\n* $Y$：备用巴士（巴士 $N$）计划从机场出发的时间\n* 这个函数应该返回备用巴士到达酒店的时间。\n* 这个函数恰好调用 $Q$ 次。\n\n---\n\n**【例子】**\n\n考虑以下调用序列：\n\n```\ninit(6, 4, [20, 10, 40, 0], [5, 20, 20, 30], 10, 4, [0, 1, 3, 6])\n```\n\n忽略巴士 $4$（它还没有确定出发时间），下表列出了巴士到达每个调度站的期望时间和实际时间：\n\n| $i$ | | $t_{i,0}$ | | $e_{i,1}$ | $t_{i,1}$ | | $e_{i,2}$ | $t_{i,2}$ | | $e_{i,3}$ | $t_{i,3}$ |\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n| $0$ | | $20$ | | $25$ | $30$ | | $40$ | $40$ | | $55$ | $55$ |\n| $1$ | | $10$ | | $30$ | $30$ | | $70$ | $70$ | | $130$ | $130$ |\n| $2$ | | $40$ | | $60$ | $60$ | | $100$ | $100$ | | $160$ | $180$ |\n| $3$ | | $0$ | | $30$ | $30$ | | $90$ | $90$ | | $180$ | $180$ |\n\n巴士到达调度站 $0$ 的时间就是它计划从机场出发的时间。也就是说，对于 $0 \\le i \\le 3$，$t_{i,0} = T[i]$。\n\n到达调度站 $1$ 的期望时间和实际时间计算如下：\n\n* 调度站 $1$ 的期望到达时间：\n  - 巴士 $0$：$e_{0,1} = t_{0,0} + W[0] \\cdot (S[1]-S[0]) = 20 + 5 \\cdot 1 = 25$。\n  - 巴士 $1$：$e_{1,1} = t_{1,0} + W[1] \\cdot (S[1]-S[0]) = 10 + 20 \\cdot 1 = 30$。\n  - 巴士 $2$：$e_{2,1} = t_{2,0} + W[2] \\cdot (S[1]-S[0]) = 40 + 20 \\cdot 1 = 60$。\n  - 巴士 $3$：$e_{3,1} = t_{3,0} + W[3] \\cdot (S[1]-S[0]) = 0 + 30 \\cdot 1 = 30$。\n* 调度站 $1$ 的到达时间：\n  - 巴士 $1$ 和 $3$ 早于巴士 $0$ 到达调度站 $0$，所以 $t_{0,1} = \\max([e_{0,1},e_{1,1},e_{3,1}]) = 30$。\n  - 巴士 $3$ 早于巴士 $1$ 到达调度站 $0$，所以 $t_{1,1} = \\max([e_{1,1},e_{3,1}]) = 30$。\n  - 巴士 $0$、巴士 $1$ 和巴士 $3$ 早于巴士 $2$ 到达调度站 $0$，所以 $t_{2,1} = \\max([e_{0,1},e_{1,1},e_{2,1},e_{3,1}]) = 60$。\n  - 没有比巴士 $3$ 更早到达调度站 $0$ 的巴士，所以 $t_{3,1} = \\max([e_{3,1}]) = 30$。\n\n```\narrival_time(0)\n```\n\n巴士 $4$ 行驶一公里需要 $10$ 秒，现在计划在第 $0$ 秒从机场出发。\n这种情况下，下表列出每辆巴士的到达时间。\n常规巴士期望和实际到达时间的唯一变动用下划线标注。\n\n| $i$ | | $t_{i,0}$ | | $e_{i,1}$ | $t_{i,1}$ | | $e_{i,2}$ | $t_{i,2}$ | | $e_{i,3}$ | $t_{i,3}$ |\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-: |\n| $0$ | | $20$ | | $25$ | $30$ | | $40$ | $40$ | | $55$ | $\\underline{60}$ |\n| $1$ | | $10$ | | $30$ | $30$ | | $70$ | $70$ | | $130$ | $130$ |\n| $2$ | | $40$ | | $60$ | $60$ | | $100$ | $100$ | | $160$ | $180$ |\n| $3$ | | $0$ | | $30$ | $30$ | | $90$ | $90$ | | $180$ | $180$ |\n| $4$ | | $0$ | | $10$ | $10$ | | $30$ | $30$ | | $60$ | $60$ |\n\n由此可知巴士 $4$ 在第 $60$ 秒到达酒店。\n因此，函数应该返回 $60$。\n\n```\narrival_time(50)\n```\n\n巴士 $4$ 现在计划在第 $50$ 秒从机场出发。\n这种情况下，与初始表格相比，常规巴士的到达时间没有变化。\n下表列出了到达时间。\n\n| $i$ | | $t_{i,0}$ | | $e_{i,1}$ | $t_{i,1}$ | | $e_{i,2}$ | $t_{i,2}$ | | $e_{i,3}$ | $t_{i,3}$ |\n|:--:|:-:|:---------:|:-:|:---------:|:---------:|:-:|:---------:|:---------:|:-:|:---------:|:---------:|\n| $0$ | | $20$      | | $25$      | $30$      | | $40$      | $40$      | | $55$      | $55$ |\n| $1$ | | $10$      | | $30$      | $30$      | | $70$      | $70$      | | $130$     | $130$ |\n| $2$ | | $40$      | | $60$      | $60$      | | $100$     | $100$     | | $160$     | $180$ |\n| $3$ | | $0$       | | $30$      | $30$      | | $90$      | $90$      | | $180$     | $180$ |\n| $4$ | | $50$      | | $60$      | $60$      | | $80$      | $90$      | | $120$     | $130$ |\n\n巴士 $4$ 和较慢的巴士 $2$ 同时到达调度站 $1$，然后巴士 $4$ 超过了巴士 $2$。\n接着，巴士 $4$ 在调度站 $1$ 和 $2$ 之间行驶时被巴士 $3$ 压着，导致它到达调度站 $2$ 的时间是第 $90$ 秒，而不是第 $80$ 秒。\n在过了调度站 $2$ 之后，巴士 $4$ 被巴士 $1$ 压着，直到它们到达酒店。\n巴士 $4$ 在第 $130$ 秒到达酒店。\n因此，函数应该返回 $130$。\n\n将每辆巴士从机场出发到不同距离的时间画成折线图。\n图中 x 轴表示从机场出发的距离（以公里为单位），y 轴表示时间（以秒为单位）。\n竖的虚线标注了调度站的位置。\n不同颜色的实线（标注了巴士的编号）表示四辆常规巴士。\n黑色的点线表示备用巴士。\n\n| `arrival_time(0)` | `arrival_time(50)` |\n|:-:|:-:|\n| ![](https://cdn.luogu.com.cn/upload/image_hosting/rksq53n9.png) | ![](https://cdn.luogu.com.cn/upload/image_hosting/ua96w1x2.png) |\n\n---\n\n**【约束条件】**\n\n* $1 \\le L \\le 10^9$\n* $1 \\le N \\le 1\\,000$\n* $0 \\le T[i] \\le 10^{18}$（对于满足 $0 \\le i \\lt N$ 的每个 $i$）\n* $1 \\le W[i] \\le 10^9$（对于满足 $0 \\le i \\lt N$ 的每个 $i$）\n* $1 \\le X \\le 10^9$\n* $2 \\le M \\le 1\\,000$\n* $0 = S[0] \\lt S[1] \\lt \\cdots \\lt S[M-1] = L$\n* $1 \\le Q \\le 10^6$\n* $0 \\le Y \\le  10^{18}$\n\n---\n\n**【子任务】**\n\n1. （9 分）$N = 1, Q \\le 1\\,000$\n1. （10 分）$M = 2, Q \\le 1\\,000$\n1. （20 分）$N, M, Q \\le 100$\n1. （26 分）$Q \\le 5\\,000$\n1. （35 分）没有额外的约束条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2023] 超车", "background": "这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。\n\n本题仅支持 C++ 语言提交。但请勿使用 C++14 (GCC 9)", "description": "从布达佩斯机场到 Forrás 酒店有一条单向单车道的公路，公路的长度为 $L$ 公里。\n\nIOI 2023 活动期间，有 $N+1$ 辆巴士在这条公路上行驶。巴士从 $0$ 到 $N$ 依次编号。巴士 $i$（$0 \\le i \\lt N$）计划在活动的第 $T[i]$ 秒从机场出发，行驶一公里用时 $W[i]$ 秒。巴士 $N$ 是备用巴士，行驶一公里用时 $X$ 秒。它从机场出发的时间 $Y$ 尚未确定。\n\n巴士在这条公路上行驶时一般不允许超车，但允许在一些被称为**调度站**的地方进行超车。公路上一共有 $M$ 个调度站（$M \\gt 1$），从 $0$ 到 $M - 1$ 依次编号，位于公路的不同位置。调度站 $j$（$0 \\le j \\lt M$）的位置在机场出发后沿公路的 $S[j]$ 公里处。调度站按照从机场开始的距离递增排列，也就是对于每个 $0 \\le j \\le M - 2$，有 $S[j] \\lt S[j+1]$。首个调度站设在机场，最后一个设在酒店。也就是说，$S[0] = 0$，$S[M-1] = L$。\n\n每辆巴士都以指定的最快速度行驶，除非它遇到前面有比它慢的巴士。在这种情况下，后面的快车会被前面的慢车压着，被迫以慢车的速度行驶。这种情况会持续到两车到达下一个调度站。在那里，快车会完成对慢车的超越。\n\n形式化地说，对于满足 $0 \\le i \\le N$ 且 $0 \\le j \\lt M$ 的每组 $i$ 和 $j$，巴士 $i$ **到达**调度站 $j$ 的时间 $t_{i,j}$（以秒为单位）定义如下：对于每个 $0 \\le i \\lt N$，有 $t_{i,0} = T[i]$。另有 $t_{N,0} = Y$。对于满足 $0 \\lt j \\lt M$ 的每个 $j$：\n\n* 定义巴士 $i$ 到达调度站 $j$ 的**期望到达时间** $e_{i,j}$（以秒为单位）为巴士 $i$ 到达调度站 $j-1$ 之后以全速行驶到达调度站 $j$ 的时间。也就是说，\n  - 对于每个 $0 \\le i \\lt N$，有 $e_{i,j} = t_{i,j-1} + W[i] \\cdot (S[j]-S[j-1])$；\n  - 另有 $e_{N,j} = t_{N,j-1} + X \\cdot (S[j]-S[j-1])$。\n* 巴士 $i$ 到达调度站 $j$ 的时间，是巴士 $i$ 到达调度站 $j$ 的期望到达时间，以及其他比巴士 $i$ 早到调度站 $j-1$ 的巴士到达调度站 $j$ 的期望到达时间中的**最大值**。形式化地说，$t_{i,j}$ 是 $e_{i,j}$ 和所有满足 $0 \\le k \\le N$ 且 $t_{k,j-1} \\lt t_{i,j-1}$ 的 $e_{k,j}$ 中的最大值。\n\nIOI 组委会想要调度备用巴士（巴士 $N$）。你的任务是回答组委会的 $Q$ 个问题，问题的形式如下：给定备用巴士从机场出发的时间 $Y$（以秒为单位），它将于何时到达酒店？", "inputFormat": "评测程序示例按以下格式读取输入：\n\n* 第 $1$ 行：$L \\; N \\; X \\; M \\; Q$\n* 第 $2$ 行：$T[0] \\; T[1] \\; \\ldots \\; T[N-1]$\n* 第 $3$ 行：$W[0] \\; W[1] \\; \\ldots \\; W[N-1]$\n* 第 $4$ 行：$S[0] \\; S[1] \\; \\ldots \\; S[M-1]$\n* 第 $5 + k$ 行（$0 \\le k \\lt Q$）：问题 $k$ 的 $Y$", "outputFormat": "评测程序示例按以下格式打印你的答案：\n\n* 第 $1 + k$ 行（$0 \\le k \\lt Q$）：问题 $k$ 中 `arrival_time` 的返回值", "hint": "**【实现细节】**\n\n你的任务是实现以下函数：\n\n```\nvoid init(int L, int N, int64[] T, int[] W, int X, int M, int[] S)\n```\n\n* $L$：公路的长度\n* $N$：常规（非备用）巴士的数量\n* $T$：长度为 $N$ 的数组，描述常规巴士计划从机场出发的时间。\n* $W$：长度为 $N$ 的数组，描述常规巴士的最大速度。\n* $X$：备用巴士行驶一公里所需的时间\n* $M$：调度站的数量\n* $S$：长度为 $M$ 的数组，描述从机场到调度站的距离。\n* 对于每个测试用例，这个函数都恰好调用一次，发生在对任何 `arrival_time` 的调用之前。\n\n```\nint64 arrival_time(int64 Y)\n```\n\n* $Y$：备用巴士（巴士 $N$）计划从机场出发的时间\n* 这个函数应该返回备用巴士到达酒店的时间。\n* 这个函数恰好调用 $Q$ 次。\n\n---\n\n**【例子】**\n\n考虑以下调用序列：\n\n```\ninit(6, 4, [20, 10, 40, 0], [5, 20, 20, 30], 10, 4, [0, 1, 3, 6])\n```\n\n忽略巴士 $4$（它还没有确定出发时间），下表列出了巴士到达每个调度站的期望时间和实际时间：\n\n| $i$ | | $t_{i,0}$ | | $e_{i,1}$ | $t_{i,1}$ | | $e_{i,2}$ | $t_{i,2}$ | | $e_{i,3}$ | $t_{i,3}$ |\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n| $0$ | | $20$ | | $25$ | $30$ | | $40$ | $40$ | | $55$ | $55$ |\n| $1$ | | $10$ | | $30$ | $30$ | | $70$ | $70$ | | $130$ | $130$ |\n| $2$ | | $40$ | | $60$ | $60$ | | $100$ | $100$ | | $160$ | $180$ |\n| $3$ | | $0$ | | $30$ | $30$ | | $90$ | $90$ | | $180$ | $180$ |\n\n巴士到达调度站 $0$ 的时间就是它计划从机场出发的时间。也就是说，对于 $0 \\le i \\le 3$，$t_{i,0} = T[i]$。\n\n到达调度站 $1$ 的期望时间和实际时间计算如下：\n\n* 调度站 $1$ 的期望到达时间：\n  - 巴士 $0$：$e_{0,1} = t_{0,0} + W[0] \\cdot (S[1]-S[0]) = 20 + 5 \\cdot 1 = 25$。\n  - 巴士 $1$：$e_{1,1} = t_{1,0} + W[1] \\cdot (S[1]-S[0]) = 10 + 20 \\cdot 1 = 30$。\n  - 巴士 $2$：$e_{2,1} = t_{2,0} + W[2] \\cdot (S[1]-S[0]) = 40 + 20 \\cdot 1 = 60$。\n  - 巴士 $3$：$e_{3,1} = t_{3,0} + W[3] \\cdot (S[1]-S[0]) = 0 + 30 \\cdot 1 = 30$。\n* 调度站 $1$ 的到达时间：\n  - 巴士 $1$ 和 $3$ 早于巴士 $0$ 到达调度站 $0$，所以 $t_{0,1} = \\max([e_{0,1},e_{1,1},e_{3,1}]) = 30$。\n  - 巴士 $3$ 早于巴士 $1$ 到达调度站 $0$，所以 $t_{1,1} = \\max([e_{1,1},e_{3,1}]) = 30$。\n  - 巴士 $0$、巴士 $1$ 和巴士 $3$ 早于巴士 $2$ 到达调度站 $0$，所以 $t_{2,1} = \\max([e_{0,1},e_{1,1},e_{2,1},e_{3,1}]) = 60$。\n  - 没有比巴士 $3$ 更早到达调度站 $0$ 的巴士，所以 $t_{3,1} = \\max([e_{3,1}]) = 30$。\n\n```\narrival_time(0)\n```\n\n巴士 $4$ 行驶一公里需要 $10$ 秒，现在计划在第 $0$ 秒从机场出发。\n这种情况下，下表列出每辆巴士的到达时间。\n常规巴士期望和实际到达时间的唯一变动用下划线标注。\n\n| $i$ | | $t_{i,0}$ | | $e_{i,1}$ | $t_{i,1}$ | | $e_{i,2}$ | $t_{i,2}$ | | $e_{i,3}$ | $t_{i,3}$ |\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-: |\n| $0$ | | $20$ | | $25$ | $30$ | | $40$ | $40$ | | $55$ | $\\underline{60}$ |\n| $1$ | | $10$ | | $30$ | $30$ | | $70$ | $70$ | | $130$ | $130$ |\n| $2$ | | $40$ | | $60$ | $60$ | | $100$ | $100$ | | $160$ | $180$ |\n| $3$ | | $0$ | | $30$ | $30$ | | $90$ | $90$ | | $180$ | $180$ |\n| $4$ | | $0$ | | $10$ | $10$ | | $30$ | $30$ | | $60$ | $60$ |\n\n由此可知巴士 $4$ 在第 $60$ 秒到达酒店。\n因此，函数应该返回 $60$。\n\n```\narrival_time(50)\n```\n\n巴士 $4$ 现在计划在第 $50$ 秒从机场出发。\n这种情况下，与初始表格相比，常规巴士的到达时间没有变化。\n下表列出了到达时间。\n\n| $i$ | | $t_{i,0}$ | | $e_{i,1}$ | $t_{i,1}$ | | $e_{i,2}$ | $t_{i,2}$ | | $e_{i,3}$ | $t_{i,3}$ |\n|:--:|:-:|:---------:|:-:|:---------:|:---------:|:-:|:---------:|:---------:|:-:|:---------:|:---------:|\n| $0$ | | $20$      | | $25$      | $30$      | | $40$      | $40$      | | $55$      | $55$ |\n| $1$ | | $10$      | | $30$      | $30$      | | $70$      | $70$      | | $130$     | $130$ |\n| $2$ | | $40$      | | $60$      | $60$      | | $100$     | $100$     | | $160$     | $180$ |\n| $3$ | | $0$       | | $30$      | $30$      | | $90$      | $90$      | | $180$     | $180$ |\n| $4$ | | $50$      | | $60$      | $60$      | | $80$      | $90$      | | $120$     | $130$ |\n\n巴士 $4$ 和较慢的巴士 $2$ 同时到达调度站 $1$，然后巴士 $4$ 超过了巴士 $2$。\n接着，巴士 $4$ 在调度站 $1$ 和 $2$ 之间行驶时被巴士 $3$ 压着，导致它到达调度站 $2$ 的时间是第 $90$ 秒，而不是第 $80$ 秒。\n在过了调度站 $2$ 之后，巴士 $4$ 被巴士 $1$ 压着，直到它们到达酒店。\n巴士 $4$ 在第 $130$ 秒到达酒店。\n因此，函数应该返回 $130$。\n\n将每辆巴士从机场出发到不同距离的时间画成折线图。\n图中 x 轴表示从机场出发的距离（以公里为单位），y 轴表示时间（以秒为单位）。\n竖的虚线标注了调度站的位置。\n不同颜色的实线（标注了巴士的编号）表示四辆常规巴士。\n黑色的点线表示备用巴士。\n\n| `arrival_time(0)` | `arrival_time(50)` |\n|:-:|:-:|\n| ![](https://cdn.luogu.com.cn/upload/image_hosting/rksq53n9.png) | ![](https://cdn.luogu.com.cn/upload/image_hosting/ua96w1x2.png) |\n\n---\n\n**【约束条件】**\n\n* $1 \\le L \\le 10^9$\n* $1 \\le N \\le 1\\,000$\n* $0 \\le T[i] \\le 10^{18}$（对于满足 $0 \\le i \\lt N$ 的每个 $i$）\n* $1 \\le W[i] \\le 10^9$（对于满足 $0 \\le i \\lt N$ 的每个 $i$）\n* $1 \\le X \\le 10^9$\n* $2 \\le M \\le 1\\,000$\n* $0 = S[0] \\lt S[1] \\lt \\cdots \\lt S[M-1] = L$\n* $1 \\le Q \\le 10^6$\n* $0 \\le Y \\le  10^{18}$\n\n---\n\n**【子任务】**\n\n1. （9 分）$N = 1, Q \\le 1\\,000$\n1. （10 分）$M = 2, Q \\le 1\\,000$\n1. （20 分）$N, M, Q \\le 100$\n1. （26 分）$Q \\le 5\\,000$\n1. （35 分）没有额外的约束条件。", "locale": "zh-CN"}}}
{"pid": "P9605", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2023", "IOI", "交互题", "Special Judge", "O2优化"], "title": "[IOI 2023] 机器人比赛", "background": "这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。\n\n本题仅支持 C++ 语言提交。\n\n---\n\n由于某些技术原因，你可能需要在源代码的开头加入以下内容：\n\n```cpp\n#include <vector>\n\nvoid program_pulibot();\nvoid set_instruction(std::vector<int> S, int Z, char A);\n```", "description": "塞格德大学的人工智能研究人员正在举办一场机器人编程竞赛。\n你的朋友 Hanga 决定参加比赛。由于著名的匈牙利牧羊犬品种 Puli 非常聪明，所以该比赛的目标定为编程实现顶级的 Pulibot。\n\nPulibot 将在由 $(H+2) \\times (W+2)$ 网格组成的迷宫中进行测试。\n网格的行从北到南编号为 $-1$ 到 $H$，网格的列从西到东编号为 $-1$ 到 $W$。\n我们将位于网格的第 $r$ 行和第 $c$ 列的单元格（$-1 \\le r \\le H$, $-1 \\le c \\le W$）称为单元格 $(r,c)$。\n\n考虑一个单元格 $(r,c)$ （$0 \\le r \\lt H$，$0 \\le c \\lt W$），和它**相邻**的有 $4$ 个单元格。\n\n* 单元格 $(r,c-1)$ 被称为单元格 $(r,c)$ 的**西邻**；\n* 单元格 $(r+1,c)$ 被称为单元格 $(r,c)$ 的**南邻**；\n* 单元格 $(r,c+1)$ 被称为单元格 $(r,c)$ 的**东邻**；\n* 单元格 $(r-1,c)$ 被称为单元格 $(r,c)$ 的**北邻**。\n\n如果 $r=-1$ 或 $r=H$ 或 $c=-1$ 或 $c=W$ 成立，则单元格 $(r,c)$ 称为迷宫的**边界**。每个不是迷宫边界的单元格要么是**障碍**，要么是**空的**。\n此外，每个空单元格都有一个**颜色**，由 $0$ 和 $Z_{\\text{MAX}}$ 之间的非负整数表示，包括 $0$ 和 $Z_{\\text{MAX}}$。最初，每个空单元格的颜色为 $0$。\n\n例如，考虑一个迷宫，$H=4$， $W=5$， 包含一个障碍单元格 $(1,3)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h649yqfv.png)\n\n唯一的障碍单元格用 $\\times$ 表示。迷宫的边界单元格被阴影覆盖。\n每个空单元格中的数字表示它的颜色。\n\n从单元格 $(r_0, c_0)$ 到单元格 $(r_\\ell, c_\\ell)$ 的长度为 $\\ell$（$\\ell\\gt 0$）的**路径**\n是一个**空**单元格序列 $(r_0,c_0), (r_1, c_1), \\ldots, (r_\\ell, c_\\ell)$，序列中的空单元格两两不同。其中对于每个 $i$（$0\\le i\\lt\\ell$），单元格 $(r_i, c_i)$ 和 $(r_{i+1}, c_{i+1})$ 是相邻的。\n\n注意长度为 $\\ell$ 的路径正好包含 $\\ell+1$ 个单元格。\n\n在比赛中，研究人员设置了一个迷宫，其中至少有一条从单元格 $(0,0)$ 到单元格 $(H-1, W-1)$ 的路径。注意，这意味着单元格 $(0, 0)$ 和 $(H-1, W-1)$ 保证为空。\n\nHanga 不知道迷宫中哪些单元格是空的，哪些单元格是障碍。\n\n你的任务是帮助 Hanga 对 Pulibot 进行编程，使其能够在研究人员设置的未知迷宫中找到从单元格 $(0,0)$ 到单元格 $(H-1, W-1)$ 的**最短路径**（即长度最小的路径）。\nPulibot 的说明和比赛规则如下所述。 \n\n注意，在题面的最后一部分描述了一个显示工具，该工具可以用于可视化 Pulibot。\n\n### Pulibot 说明\n\n对每个单元格 $(r,c)$（$-1 \\le r \\le H$ ，$-1 \\le c \\le W$），其**状态**定义为一个整数，具体如下：\n* 如果单元格 $(r,c)$ 是边界，则其状态为 $-2$；\n* 如果单元格 $(r,c)$ 是障碍，则其状态为 $-1$；\n* 如果单元格 $(r,c)$ 是空的，那么它的状态就是单元格的颜色。\n\nPulibot 的程序是按一系列步骤执行的。在每一步中，Pulibot 都会识别附近单元格的状态，然后执行一条指令。它执行的指令由识别的状态决定。以下是更准确的描述。\n\n假设在当前步骤开始时，Pulibot位于单元格 $(r,c)$，这是一个空单元格。该步骤执行如下：\n\n1. 首先，Pulibot 识别当前**状态数组**，即数组 $S = [S[0], S[1], S[2], S[3], S[4]]$， 它包含单元格 $(r,c)$ 及其所有相邻单元格的状态：\n    * $S[0]$ 表示单元格 $(r,c)$ 的状态。\n    * $S[1]$ 表示西邻的状态。\n    * $S[2]$ 表示南邻的状态。\n    * $S[3]$ 表示东邻的状态。\n    * $S[4]$ 表示北邻的状态。\n1. 然后，Pulibot 确定与所识别的状态数组相对应的**指令** $(Z, A)$。\n1. 最后，Pulibot 执行这条指令：它将单元格 $(r,c)$ 的颜色设置为 $Z$，然后它执行动作 $A$, $A$ 是以下动作之一：\n    * **停留** 在单元格 $(r,c)$；\n    * **移动** 到 $4$ 个邻居之一；\n    * **终止程序**。\n\n例如，考虑下图左侧显示的场景。Pulibot 当前位于单元格$(0,0)$，颜色为$0$。\nPulibot 识别出状态数组 $S=[0, -2, 2, 2, -2]$。Pulibot 可能有一个程序，该程序根据所识别的数组，将当前单元格的颜色设置为 $Z=1$，然后向东移动，如图的中间和右侧所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pg2mek5q.png)\n\n### 机器人比赛规则\n\n* 在开始时，Pulibot 被放置在单元格 $(0,0)$ 并开始执行其程序。\n* 不允许 Pulibot 移动到非空单元格。\n* Pulibot 的程序必须在最多 $500\\,000$ 步后终止。\n* 在 Pulibot 的程序终止后，迷宫中的空单元格的着色满足以下要求：\n  - 存在从 $(0,0)$ 到 $(H-1, W-1)$ 的最短路径，路径中包括的每个单元格的颜色为 $1$。\n  - 所有其他空单元格的颜色为 $0$。\n* Pulibot 可以在任何空单元格终止其程序。 \n  \n\n例如，下图显示了一个可能的迷宫，其中$H=W=6$。左侧显示了初始配置，右侧显示了程序终止后空单元格的一种可以接受的着色：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ry81lf6s.png)", "inputFormat": "你要实现以下函数：\n\n```\nvoid program_pulibot()\n```\n\n* 这个函数应该产生 Pulibot 的程序。对于所有 $H$ 和 $W$ 的取值以及满足题目约束条件的任何迷宫，该程序应该都能正确工作。\n* 对于每个测试用例，此函数只调用一次。\n\n此函数可以调用以下函数来生成 Pulibot 的程序：\n\n```\nvoid set_instruction(int[] S, int Z, char A)\n```\n\n* $S$: 长度为 $5$ 的数组，用来描述状态数组\n* $Z$: 表示颜色的非负整数\n* $A$: 表示 Pulibot 动作的单个字符，具体如下:\n    - `H`: 停留;\n    - `W`: 移动到西邻;\n    - `S`: 移动到南邻;\n    - `E`: 移动到东邻;\n    - `N`: 移动到北邻;\n    - `T`: 终止程序。\n* 调用此函数指示 Pulibot 在识别状态数组 $S$ 时应执行指令 $(Z, A)$。  \n\n用相同的状态数组 $S$ 多次调用该函数将导致  `Output isn't correct` 的判定结果。\n\n不需要对每个可能的状态数组 $S$ 调用 `set_instruction`。 但是，如果 Pulibot 后来识别出未设置指令的状态数组，你将得到 `Output isn't correct` 的判定结果。\n\n`program_pulibot` 完成后，评测程序会在一个或多个迷宫上调用 Pulibot 的程序。\n这些调用**不**计入解决方案的时间限制。\n评测程序**不**是自适应的，也就是说，每个测试用例的迷宫集合都是预先确定的。\n\n如果 Pulibot 在终止程序之前违反了任何机器人比赛规则，你将得到 `Output isn't correct` 的判定结果。", "outputFormat": "函数 `program_pulibot` 可以调用 `set_instruction` 如下：\n\n调用                             | 对应状态数组 $S$ 的指令\n:-------------------------------------------:|:---------------------------------------:\n`set_instruction([0, -2, -1, 0, -2], 1, E)`  | 着色 $1$ 并且东移\n`set_instruction([0, 1, -1, 0, -2], 1, E)`   | 着色 $1$ 并且东移\n`set_instruction([0, 1, 0, -2, -2], 1, S)`   | 着色 $1$ 并且南移\n`set_instruction([0, -1, -2, -2, 1], 1, T)`  | 着色 $1$ 并且终止程序\n\n考虑一个场景，$H=2$， $W=3$，迷宫如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q5lifqvx.png)\n\n对于这个特定的迷宫，Pulibot 的程序分四个步骤运行。 Pulibot 识别的状态数组和它执行的指令正好依次对应上述对“set_instruction”的四次调用。 这些指令的最后一条指令终止程序。\n\n下图展示了四个步骤每一步之前的迷宫以及终止后的最终颜色。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n236hrg7.png)\n\n但是，注意这个由 $4$ 条指令构成的程序有可能在其他合法的迷宫中找不到最短路径。\n所以，如果这个程序被提交，它会收到 `Output isn't correct` 的判定结果。", "hint": "## 约束条件\n\n$Z_{\\text{MAX}} = 19$。因此，Pulibot 可以使用 0 到 19 的颜色，包含 0 和 19。\n\n对于每个用来测试Pulibot的迷宫：\n* $2 \\le H, W \\le 15$\n* 至少有一条从单元格 $(0,0)$ 到 $(H-1, W-1)$ 的路径。\n\n## 子任务\n\n1. （6 分）迷宫中没有障碍单元格。\n1. （10 分）$H = 2$\n1. （18 分）任意两个空单元格之间恰好有一条路径。\n1. （20 分）从单元格 $(0,0)$ 到 $(H-1, W-1)$ 的最短路径的长度为 $H + W - 2$。\n1. （46 分）无额外约束条件。\n\n如果在任何测试用例中，对函数 `set_instruction` 的调用或 Pulibot 程序的执行不符合“实现细节”中所描述的限制条件，则该子任务的解决方案得分将为 $0$。\n\n在每个子任务中，你可以通过生成几乎正确的着色来获得部分分数。\n\n形式化地说：\n\n* 如果空单元格的最终颜色满足机器人竞赛规则，则测试用例的解决方案是**完整**的。\n* 如果最终着色如下所示，则测试用例的解决方案是**部分**的：\n   - 存在一条从 $(0,0)$ 到 $(H-1, W-1)$ 的最短路径，路径中包含的每个单元格的颜色为 $1$。\n   - 网格中没有其他颜色为 $1$ 的空单元格。\n   - 网格中的某些空单元格的颜色既不是 $0$ 也不是 $1$。\n   \n\n如果你对某个测试用例的解决方案既不完整也不部分，则该测试用例的得分将为 $0$。\n\n在子任务 1-4 中，对每个测试用例来说，完整解决方案的计分为该子任务分数的 100%，部分解决方案的计分为该子任务分数的 50%。\n\n在子任务 5 中，你的分数取决于 Pulibot 程序中所使用颜色的数量。\n更准确地说，用 $Z^\\star$ 表示对 `set_instruction` 进行的所有调用中 $Z$ 的最大值。\n测试用例上的得分按下表计算：\n\n| 条件            | 分数 (完整)      | 分数 (部分)       |\n|:-----------------------:|:---------------------:|:---------------------:|\n| $11 \\le Z^\\star \\le 19$ | $20 + (19 - Z^\\star)$ | $12 + (19 - Z^\\star)$ |\n| $Z^\\star = 10$          | $31$                  | $23$                  |\n| $Z^\\star = 9$           | $34$                  | $26$                  |\n| $Z^\\star = 8$           | $38$                  | $29$                  |\n| $Z^\\star = 7$           | $42$                  | $32$                  |\n| $Z^\\star \\le 6$         | $46$                  | $36$                  |\n\n\n每个子任务的得分是该子任务中所有测试用例上计分的最小值。\n\n## 评测程序示例\n\n评测程序示例按照以下格式读取输入：\n* 第 $1$ 行: $H \\; W$\n* 第 $2 + r$ 行 ($0 \\le r \\lt H$): $m[r][0] \\; m[r][1] \\; \\ldots \\; m[r][W-1]$\n\n其中，$m$ 是一个 $H$ 行 $W$ 列的二维整数数组，描述迷宫中非边界单元格。\n如果单元格 $(r, c)$ 是空的，$m[r][c] = 0$；如果单元格 $(r, c)$ 是障碍， $m[r][c] = 1$。\n\n\n\n评测程序示例首先调用 `program_pulibot()`。如果评测程序示例检测到违反规则的行为，则会打印 `Protocol Violation: <MSG>` 并终止，其中 `<MSG>` 是以下错误消息之一：\n\n* `Invalid array`：$-2 \\le S[i] \\le Z_{\\text{MAX}}$ 对某些 $i$ 不成立或者 $S$ 的长度不是 $5$。\n* `Invalid color`：$0 \\le Z \\le Z_{\\text{MAX}}$ 不成立。\n* `Invalid action`：字符 $A$ 不是 `H`, `W`, `S`, `E`, `N` 或 `T`。\n* `Same state array`：用相同的 $S$ 调用 `set_instruction` 两次或以上。\n\n否则，当 `program_pulibot` 完成时，评测程序示例将在输入所描述的迷宫中执行 Pulibot 的程序。\n\n评测程序示例产生两个输出。首先，评测程序示例将 Pulibot 动作记录写入工作目录中的文件 `robot.bin` 。\n该文件用作下一节中描述的可视化工具的输入。\n\n其次，如果 Pulibot 的程序未成功终止，评测程序示例将打印以下错误消息之一：\n\n* `Unexpected state`：Pulibot 识别出一个无法调用“set_instruction”的状态数组。\n* `Invalid move`：执行一个动作，导致 Pulibot 移动到一个非空单元格。\n* `Too many steps`：Pulibot 执行了 $500\\,000$ 步没有终止程序。\n\n否则，令 $e[r][c]$ 为 Pulibot 程序终止后单元格 $(r, c)$ 的状态。\n评测程序示例按以下格式打印 $H$ 行：\n* 第 $1 + r$ 行 ($0 \\le r \\lt H$)：$e[r][0] \\; e[r][1] \\; \\ldots \\; e[r][W-1]$\n\n## 显示工具\n\n此任务的附件包含有一个名为 `display.py` 的文件。\n调用时，此 Python 脚本会显示 Pulibot 在由评测程序示例的输入所描述的迷宫中的操作。\n为此，工作目录中要有二进制文件 `robot.bin`。\n\n要调用该脚本，请执行以下命令。\n\n```\npython3 display.py\n```\n\n一个简单的图形界面将会出现，主要特性如下：\n\n* 你可以观察整个迷宫的状态。 Pulibot 的当前位置以矩形突出显示。\n* 你可以通过单击箭头按钮或按热键来浏览 Pulibot 的步骤。 你还可以跳转到特定步骤。\n* Pulibot 程序中即将进行的步骤显示在底部。\n它显示当前状态数组及将要执行的指令。\n在最后一步之后，它或者会显示评测程序的错误消息之一，或者在程序成功终止时显示 `Terminated`。\n* 对于代表颜色的每个数字，你可以指定视觉背景颜色以及显示的文本。 显示的文本是一个短字符串，应出现在每个具有那个颜色的单元格。你可以通过以下任一方式指定背景颜色和显示的文本：\n   - 单击 `Colors` 按钮后在对话框窗口中设置它们。\n   - 编辑 `colors.txt` 文件的内容。\n* 要重新加载 `robot.bin`，请使用 `Reload` 按钮。 这可以用来处理 `robot.bin` 的内容发生更改的情况。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2023] 机器人比赛", "background": "这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。\n\n本题仅支持 C++ 语言提交。\n\n---\n\n由于某些技术原因，你可能需要在源代码的开头加入以下内容：\n\n```cpp\n#include <vector>\n\nvoid program_pulibot();\nvoid set_instruction(std::vector<int> S, int Z, char A);\n```", "description": "塞格德大学的人工智能研究人员正在举办一场机器人编程竞赛。\n你的朋友 Hanga 决定参加比赛。由于著名的匈牙利牧羊犬品种 Puli 非常聪明，所以该比赛的目标定为编程实现顶级的 Pulibot。\n\nPulibot 将在由 $(H+2) \\times (W+2)$ 网格组成的迷宫中进行测试。\n网格的行从北到南编号为 $-1$ 到 $H$，网格的列从西到东编号为 $-1$ 到 $W$。\n我们将位于网格的第 $r$ 行和第 $c$ 列的单元格（$-1 \\le r \\le H$, $-1 \\le c \\le W$）称为单元格 $(r,c)$。\n\n考虑一个单元格 $(r,c)$ （$0 \\le r \\lt H$，$0 \\le c \\lt W$），和它**相邻**的有 $4$ 个单元格。\n\n* 单元格 $(r,c-1)$ 被称为单元格 $(r,c)$ 的**西邻**；\n* 单元格 $(r+1,c)$ 被称为单元格 $(r,c)$ 的**南邻**；\n* 单元格 $(r,c+1)$ 被称为单元格 $(r,c)$ 的**东邻**；\n* 单元格 $(r-1,c)$ 被称为单元格 $(r,c)$ 的**北邻**。\n\n如果 $r=-1$ 或 $r=H$ 或 $c=-1$ 或 $c=W$ 成立，则单元格 $(r,c)$ 称为迷宫的**边界**。每个不是迷宫边界的单元格要么是**障碍**，要么是**空的**。\n此外，每个空单元格都有一个**颜色**，由 $0$ 和 $Z_{\\text{MAX}}$ 之间的非负整数表示，包括 $0$ 和 $Z_{\\text{MAX}}$。最初，每个空单元格的颜色为 $0$。\n\n例如，考虑一个迷宫，$H=4$， $W=5$， 包含一个障碍单元格 $(1,3)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h649yqfv.png)\n\n唯一的障碍单元格用 $\\times$ 表示。迷宫的边界单元格被阴影覆盖。\n每个空单元格中的数字表示它的颜色。\n\n从单元格 $(r_0, c_0)$ 到单元格 $(r_\\ell, c_\\ell)$ 的长度为 $\\ell$（$\\ell\\gt 0$）的**路径**\n是一个**空**单元格序列 $(r_0,c_0), (r_1, c_1), \\ldots, (r_\\ell, c_\\ell)$，序列中的空单元格两两不同。其中对于每个 $i$（$0\\le i\\lt\\ell$），单元格 $(r_i, c_i)$ 和 $(r_{i+1}, c_{i+1})$ 是相邻的。\n\n注意长度为 $\\ell$ 的路径正好包含 $\\ell+1$ 个单元格。\n\n在比赛中，研究人员设置了一个迷宫，其中至少有一条从单元格 $(0,0)$ 到单元格 $(H-1, W-1)$ 的路径。注意，这意味着单元格 $(0, 0)$ 和 $(H-1, W-1)$ 保证为空。\n\nHanga 不知道迷宫中哪些单元格是空的，哪些单元格是障碍。\n\n你的任务是帮助 Hanga 对 Pulibot 进行编程，使其能够在研究人员设置的未知迷宫中找到从单元格 $(0,0)$ 到单元格 $(H-1, W-1)$ 的**最短路径**（即长度最小的路径）。\nPulibot 的说明和比赛规则如下所述。 \n\n注意，在题面的最后一部分描述了一个显示工具，该工具可以用于可视化 Pulibot。\n\n### Pulibot 说明\n\n对每个单元格 $(r,c)$（$-1 \\le r \\le H$ ，$-1 \\le c \\le W$），其**状态**定义为一个整数，具体如下：\n* 如果单元格 $(r,c)$ 是边界，则其状态为 $-2$；\n* 如果单元格 $(r,c)$ 是障碍，则其状态为 $-1$；\n* 如果单元格 $(r,c)$ 是空的，那么它的状态就是单元格的颜色。\n\nPulibot 的程序是按一系列步骤执行的。在每一步中，Pulibot 都会识别附近单元格的状态，然后执行一条指令。它执行的指令由识别的状态决定。以下是更准确的描述。\n\n假设在当前步骤开始时，Pulibot位于单元格 $(r,c)$，这是一个空单元格。该步骤执行如下：\n\n1. 首先，Pulibot 识别当前**状态数组**，即数组 $S = [S[0], S[1], S[2], S[3], S[4]]$， 它包含单元格 $(r,c)$ 及其所有相邻单元格的状态：\n    * $S[0]$ 表示单元格 $(r,c)$ 的状态。\n    * $S[1]$ 表示西邻的状态。\n    * $S[2]$ 表示南邻的状态。\n    * $S[3]$ 表示东邻的状态。\n    * $S[4]$ 表示北邻的状态。\n1. 然后，Pulibot 确定与所识别的状态数组相对应的**指令** $(Z, A)$。\n1. 最后，Pulibot 执行这条指令：它将单元格 $(r,c)$ 的颜色设置为 $Z$，然后它执行动作 $A$, $A$ 是以下动作之一：\n    * **停留** 在单元格 $(r,c)$；\n    * **移动** 到 $4$ 个邻居之一；\n    * **终止程序**。\n\n例如，考虑下图左侧显示的场景。Pulibot 当前位于单元格$(0,0)$，颜色为$0$。\nPulibot 识别出状态数组 $S=[0, -2, 2, 2, -2]$。Pulibot 可能有一个程序，该程序根据所识别的数组，将当前单元格的颜色设置为 $Z=1$，然后向东移动，如图的中间和右侧所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pg2mek5q.png)\n\n### 机器人比赛规则\n\n* 在开始时，Pulibot 被放置在单元格 $(0,0)$ 并开始执行其程序。\n* 不允许 Pulibot 移动到非空单元格。\n* Pulibot 的程序必须在最多 $500\\,000$ 步后终止。\n* 在 Pulibot 的程序终止后，迷宫中的空单元格的着色满足以下要求：\n  - 存在从 $(0,0)$ 到 $(H-1, W-1)$ 的最短路径，路径中包括的每个单元格的颜色为 $1$。\n  - 所有其他空单元格的颜色为 $0$。\n* Pulibot 可以在任何空单元格终止其程序。 \n  \n\n例如，下图显示了一个可能的迷宫，其中$H=W=6$。左侧显示了初始配置，右侧显示了程序终止后空单元格的一种可以接受的着色：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ry81lf6s.png)", "inputFormat": "你要实现以下函数：\n\n```\nvoid program_pulibot()\n```\n\n* 这个函数应该产生 Pulibot 的程序。对于所有 $H$ 和 $W$ 的取值以及满足题目约束条件的任何迷宫，该程序应该都能正确工作。\n* 对于每个测试用例，此函数只调用一次。\n\n此函数可以调用以下函数来生成 Pulibot 的程序：\n\n```\nvoid set_instruction(int[] S, int Z, char A)\n```\n\n* $S$: 长度为 $5$ 的数组，用来描述状态数组\n* $Z$: 表示颜色的非负整数\n* $A$: 表示 Pulibot 动作的单个字符，具体如下:\n    - `H`: 停留;\n    - `W`: 移动到西邻;\n    - `S`: 移动到南邻;\n    - `E`: 移动到东邻;\n    - `N`: 移动到北邻;\n    - `T`: 终止程序。\n* 调用此函数指示 Pulibot 在识别状态数组 $S$ 时应执行指令 $(Z, A)$。  \n\n用相同的状态数组 $S$ 多次调用该函数将导致  `Output isn't correct` 的判定结果。\n\n不需要对每个可能的状态数组 $S$ 调用 `set_instruction`。 但是，如果 Pulibot 后来识别出未设置指令的状态数组，你将得到 `Output isn't correct` 的判定结果。\n\n`program_pulibot` 完成后，评测程序会在一个或多个迷宫上调用 Pulibot 的程序。\n这些调用**不**计入解决方案的时间限制。\n评测程序**不**是自适应的，也就是说，每个测试用例的迷宫集合都是预先确定的。\n\n如果 Pulibot 在终止程序之前违反了任何机器人比赛规则，你将得到 `Output isn't correct` 的判定结果。", "outputFormat": "函数 `program_pulibot` 可以调用 `set_instruction` 如下：\n\n调用                             | 对应状态数组 $S$ 的指令\n:-------------------------------------------:|:---------------------------------------:\n`set_instruction([0, -2, -1, 0, -2], 1, E)`  | 着色 $1$ 并且东移\n`set_instruction([0, 1, -1, 0, -2], 1, E)`   | 着色 $1$ 并且东移\n`set_instruction([0, 1, 0, -2, -2], 1, S)`   | 着色 $1$ 并且南移\n`set_instruction([0, -1, -2, -2, 1], 1, T)`  | 着色 $1$ 并且终止程序\n\n考虑一个场景，$H=2$， $W=3$，迷宫如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q5lifqvx.png)\n\n对于这个特定的迷宫，Pulibot 的程序分四个步骤运行。 Pulibot 识别的状态数组和它执行的指令正好依次对应上述对“set_instruction”的四次调用。 这些指令的最后一条指令终止程序。\n\n下图展示了四个步骤每一步之前的迷宫以及终止后的最终颜色。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n236hrg7.png)\n\n但是，注意这个由 $4$ 条指令构成的程序有可能在其他合法的迷宫中找不到最短路径。\n所以，如果这个程序被提交，它会收到 `Output isn't correct` 的判定结果。", "hint": "## 约束条件\n\n$Z_{\\text{MAX}} = 19$。因此，Pulibot 可以使用 0 到 19 的颜色，包含 0 和 19。\n\n对于每个用来测试Pulibot的迷宫：\n* $2 \\le H, W \\le 15$\n* 至少有一条从单元格 $(0,0)$ 到 $(H-1, W-1)$ 的路径。\n\n## 子任务\n\n1. （6 分）迷宫中没有障碍单元格。\n1. （10 分）$H = 2$\n1. （18 分）任意两个空单元格之间恰好有一条路径。\n1. （20 分）从单元格 $(0,0)$ 到 $(H-1, W-1)$ 的最短路径的长度为 $H + W - 2$。\n1. （46 分）无额外约束条件。\n\n如果在任何测试用例中，对函数 `set_instruction` 的调用或 Pulibot 程序的执行不符合“实现细节”中所描述的限制条件，则该子任务的解决方案得分将为 $0$。\n\n在每个子任务中，你可以通过生成几乎正确的着色来获得部分分数。\n\n形式化地说：\n\n* 如果空单元格的最终颜色满足机器人竞赛规则，则测试用例的解决方案是**完整**的。\n* 如果最终着色如下所示，则测试用例的解决方案是**部分**的：\n   - 存在一条从 $(0,0)$ 到 $(H-1, W-1)$ 的最短路径，路径中包含的每个单元格的颜色为 $1$。\n   - 网格中没有其他颜色为 $1$ 的空单元格。\n   - 网格中的某些空单元格的颜色既不是 $0$ 也不是 $1$。\n   \n\n如果你对某个测试用例的解决方案既不完整也不部分，则该测试用例的得分将为 $0$。\n\n在子任务 1-4 中，对每个测试用例来说，完整解决方案的计分为该子任务分数的 100%，部分解决方案的计分为该子任务分数的 50%。\n\n在子任务 5 中，你的分数取决于 Pulibot 程序中所使用颜色的数量。\n更准确地说，用 $Z^\\star$ 表示对 `set_instruction` 进行的所有调用中 $Z$ 的最大值。\n测试用例上的得分按下表计算：\n\n| 条件            | 分数 (完整)      | 分数 (部分)       |\n|:-----------------------:|:---------------------:|:---------------------:|\n| $11 \\le Z^\\star \\le 19$ | $20 + (19 - Z^\\star)$ | $12 + (19 - Z^\\star)$ |\n| $Z^\\star = 10$          | $31$                  | $23$                  |\n| $Z^\\star = 9$           | $34$                  | $26$                  |\n| $Z^\\star = 8$           | $38$                  | $29$                  |\n| $Z^\\star = 7$           | $42$                  | $32$                  |\n| $Z^\\star \\le 6$         | $46$                  | $36$                  |\n\n\n每个子任务的得分是该子任务中所有测试用例上计分的最小值。\n\n## 评测程序示例\n\n评测程序示例按照以下格式读取输入：\n* 第 $1$ 行: $H \\; W$\n* 第 $2 + r$ 行 ($0 \\le r \\lt H$): $m[r][0] \\; m[r][1] \\; \\ldots \\; m[r][W-1]$\n\n其中，$m$ 是一个 $H$ 行 $W$ 列的二维整数数组，描述迷宫中非边界单元格。\n如果单元格 $(r, c)$ 是空的，$m[r][c] = 0$；如果单元格 $(r, c)$ 是障碍， $m[r][c] = 1$。\n\n\n\n评测程序示例首先调用 `program_pulibot()`。如果评测程序示例检测到违反规则的行为，则会打印 `Protocol Violation: <MSG>` 并终止，其中 `<MSG>` 是以下错误消息之一：\n\n* `Invalid array`：$-2 \\le S[i] \\le Z_{\\text{MAX}}$ 对某些 $i$ 不成立或者 $S$ 的长度不是 $5$。\n* `Invalid color`：$0 \\le Z \\le Z_{\\text{MAX}}$ 不成立。\n* `Invalid action`：字符 $A$ 不是 `H`, `W`, `S`, `E`, `N` 或 `T`。\n* `Same state array`：用相同的 $S$ 调用 `set_instruction` 两次或以上。\n\n否则，当 `program_pulibot` 完成时，评测程序示例将在输入所描述的迷宫中执行 Pulibot 的程序。\n\n评测程序示例产生两个输出。首先，评测程序示例将 Pulibot 动作记录写入工作目录中的文件 `robot.bin` 。\n该文件用作下一节中描述的可视化工具的输入。\n\n其次，如果 Pulibot 的程序未成功终止，评测程序示例将打印以下错误消息之一：\n\n* `Unexpected state`：Pulibot 识别出一个无法调用“set_instruction”的状态数组。\n* `Invalid move`：执行一个动作，导致 Pulibot 移动到一个非空单元格。\n* `Too many steps`：Pulibot 执行了 $500\\,000$ 步没有终止程序。\n\n否则，令 $e[r][c]$ 为 Pulibot 程序终止后单元格 $(r, c)$ 的状态。\n评测程序示例按以下格式打印 $H$ 行：\n* 第 $1 + r$ 行 ($0 \\le r \\lt H$)：$e[r][0] \\; e[r][1] \\; \\ldots \\; e[r][W-1]$\n\n## 显示工具\n\n此任务的附件包含有一个名为 `display.py` 的文件。\n调用时，此 Python 脚本会显示 Pulibot 在由评测程序示例的输入所描述的迷宫中的操作。\n为此，工作目录中要有二进制文件 `robot.bin`。\n\n要调用该脚本，请执行以下命令。\n\n```\npython3 display.py\n```\n\n一个简单的图形界面将会出现，主要特性如下：\n\n* 你可以观察整个迷宫的状态。 Pulibot 的当前位置以矩形突出显示。\n* 你可以通过单击箭头按钮或按热键来浏览 Pulibot 的步骤。 你还可以跳转到特定步骤。\n* Pulibot 程序中即将进行的步骤显示在底部。\n它显示当前状态数组及将要执行的指令。\n在最后一步之后，它或者会显示评测程序的错误消息之一，或者在程序成功终止时显示 `Terminated`。\n* 对于代表颜色的每个数字，你可以指定视觉背景颜色以及显示的文本。 显示的文本是一个短字符串，应出现在每个具有那个颜色的单元格。你可以通过以下任一方式指定背景颜色和显示的文本：\n   - 单击 `Colors` 按钮后在对话框窗口中设置它们。\n   - 编辑 `colors.txt` 文件的内容。\n* 要重新加载 `robot.bin`，请使用 `Reload` 按钮。 这可以用来处理 `robot.bin` 的内容发生更改的情况。", "locale": "zh-CN"}}}
{"pid": "P9606", "type": "P", "difficulty": 4, "samples": [["3\nabb\n", "1\n"], ["12\nrecakjenecep\n", "11\n"], ["15\nmurderforajarof\n", "6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "2019", "哈希 hashing", "KMP 算法", "Manacher 算法", "ICPC", "CERC"], "title": "[CERC2019] ABB", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[ABB](https://contest.felk.cvut.cz/19cerc/solved/abb.pdf)」**", "description": "Fernando 受雇于滑铁卢大学，负责完成该大学不久前开始的一个开发项目。在校园外，该大学希望为重要的外国游客和合作者建造具有代表性的平房街。\n\n目前，这条街只建了一部分，它从湖岸开始，一直延伸到森林尽头。Fernando 的任务是通过在森林尽头建造更多的平房来完成这条街。所有现有的平房都坐落在街道的一侧，新的平房应该建在同一侧。这些平房有各种各样的类型，漆成各种各样的颜色。\n\n在 Fernando 看来，整条街的布局有点混乱。他担心增加新平房后，它会看起来更加混乱。所以他想通过为新平房选择合适的颜色来增加一些排列顺序。当项目完成时，平房的整个颜色序列将是对称的，也就是说，从街道的两端观察时，颜色序列是相同的。\n\n在其他问题中，Fernando 想知道，在满足平房颜色限制的情况下，他最少需要用来建造和适当染色才能完成项目的新平房数量。\n\n### 简要题意\n\n求使给定小写字母字符串成为回文串需在字符串末尾加入字母的最少数量。", "inputFormat": "第一行包含一个整数 $N\\ (1\\le N\\le 4\\times 10^5)$，代表街道上现有平房的数量。\n\n第二行包含一个由 $N$ 个小写字母（从 `a` 到 `z`）组成的字符串，代表从湖岸开始的街道现有的平房颜色顺序，其中不同的字母表示不同的颜色。", "outputFormat": "输出一个整数，代表满足 Fernando 要求的新平房的最少数量。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CERC2019] ABB", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[ABB](https://contest.felk.cvut.cz/19cerc/solved/abb.pdf)」**", "description": "Fernando 受雇于滑铁卢大学，负责完成该大学不久前开始的一个开发项目。在校园外，该大学希望为重要的外国游客和合作者建造具有代表性的平房街。\n\n目前，这条街只建了一部分，它从湖岸开始，一直延伸到森林尽头。Fernando 的任务是通过在森林尽头建造更多的平房来完成这条街。所有现有的平房都坐落在街道的一侧，新的平房应该建在同一侧。这些平房有各种各样的类型，漆成各种各样的颜色。\n\n在 Fernando 看来，整条街的布局有点混乱。他担心增加新平房后，它会看起来更加混乱。所以他想通过为新平房选择合适的颜色来增加一些排列顺序。当项目完成时，平房的整个颜色序列将是对称的，也就是说，从街道的两端观察时，颜色序列是相同的。\n\n在其他问题中，Fernando 想知道，在满足平房颜色限制的情况下，他最少需要用来建造和适当染色才能完成项目的新平房数量。\n\n### 简要题意\n\n求使给定小写字母字符串成为回文串需在字符串末尾加入字母的最少数量。", "inputFormat": "第一行包含一个整数 $N\\ (1\\le N\\le 4\\times 10^5)$，代表街道上现有平房的数量。\n\n第二行包含一个由 $N$ 个小写字母（从 `a` 到 `z`）组成的字符串，代表从湖岸开始的街道现有的平房颜色顺序，其中不同的字母表示不同的颜色。", "outputFormat": "输出一个整数，代表满足 Fernando 要求的新平房的最少数量。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9607", "type": "P", "difficulty": 6, "samples": [["4\n1 2 3 4\n", "50\n"], ["5\n2 4 6 12 3\n", "457\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2019", "线段树", "倍增", "ST 表", "ICPC", "笛卡尔树", "单调栈", "CERC"], "title": "[CERC2019] Be Geeks!", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Be Geeks!](https://contest.felk.cvut.cz/19cerc/solved/begeeks.pdf)」**", "description": "音乐乐队 Be Geeks! 的名字并非偶然，因为所有成员都是真正的数学怪才。除此之外，他们喜欢研究数列的各种性质。下面是他们感兴趣的一个例子：\n- 设 $A$ 是一个非空正整数序列，$A=(a_1, a_2, \\dots, a_N)$。\n- $G(i, j)=\\gcd (a_i, a_{i+1}, \\dots, a_j)$，其中 $1\\le i\\le j\\le N$。\n- $M(i, j)=\\max (a_i, a_{i+1}, \\dots, a_j)$，其中 $1\\le i\\le j\\le N$。\n- $P(i, j)=G(i, j)\\times M(i, j)$，其中 $1\\le i\\le j\\le N$。\n- $F(A)=\\sum P(i, j)[1\\le i\\le j\\le N]$。\n\n给出一个序列 $A$，你需要求出 $F(A)\\bmod 1\\,000\\,000\\,007$ 的值。", "inputFormat": "第一行包含一个整数 $N\\ (1\\le N\\le 2\\times 10^5)$，代表序列 $A$ 的长度。\n\n第二行包含 $N$ 个整数 $a_1, a_2, \\dots, a_N\\ (1\\le a_i\\le 10^9)$，代表序列 $A$。", "outputFormat": "输出一个整数，代表 $F(A)\\bmod 1\\,000\\,000\\,007$ 的值。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CERC2019] Be Geeks!", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Be Geeks!](https://contest.felk.cvut.cz/19cerc/solved/begeeks.pdf)」**", "description": "音乐乐队 Be Geeks! 的名字并非偶然，因为所有成员都是真正的数学怪才。除此之外，他们喜欢研究数列的各种性质。下面是他们感兴趣的一个例子：\n- 设 $A$ 是一个非空正整数序列，$A=(a_1, a_2, \\dots, a_N)$。\n- $G(i, j)=\\gcd (a_i, a_{i+1}, \\dots, a_j)$，其中 $1\\le i\\le j\\le N$。\n- $M(i, j)=\\max (a_i, a_{i+1}, \\dots, a_j)$，其中 $1\\le i\\le j\\le N$。\n- $P(i, j)=G(i, j)\\times M(i, j)$，其中 $1\\le i\\le j\\le N$。\n- $F(A)=\\sum P(i, j)[1\\le i\\le j\\le N]$。\n\n给出一个序列 $A$，你需要求出 $F(A)\\bmod 1\\,000\\,000\\,007$ 的值。", "inputFormat": "第一行包含一个整数 $N\\ (1\\le N\\le 2\\times 10^5)$，代表序列 $A$ 的长度。\n\n第二行包含 $N$ 个整数 $a_1, a_2, \\dots, a_N\\ (1\\le a_i\\le 10^9)$，代表序列 $A$。", "outputFormat": "输出一个整数，代表 $F(A)\\bmod 1\\,000\\,000\\,007$ 的值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9608", "type": "P", "difficulty": 2, "samples": [["5\n4 3\n1 2\n4 5\n3 2\n", "0"], ["6\n1 3\n3 2\n3 4\n4 5\n4 6", "2"], ["7\n1 2\n2 3\n3 4\n4 5\n3 6\n6 7", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "2019", "ICPC", "CERC"], "title": "[CERC2019] Bob in Wonderland", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Bob in Wonderland](https://contest.felk.cvut.cz/19cerc/solved/bob.pdf)」**", "description": "众所周知，链条是由相连的环组成的。通常，所有环都具有相同的形状和大小。Bob 是一名铁匠学徒，他正在制作自己的第一条铱链。他遵循传统的链条制作通则。上面写着：\n- 如果没有链条，制作一个环，它将成为你链条的一部分。\n- 如果有一条链，制作一个环，并将其连接到你已有的链中的另一个环上。\n\nBob 做了第一个环。然后，每次他制作另一个环时，他都会将其连接到链条上的其他环上，就像通则告诉他的那样。\n\n当他完成时，他意识到他创造的物体根本不像一条普通的链。为了把链条拉直，他反复地拎起可能是链条两端的两个链环，并试图把它们尽可能地拉开。但在不同的地方，还有更多的“链条”从拉直的部分垂下来。\n\n很明显，Bob 的工作还没有完成，他决定把他制作的物体称为未完成的链条。经过更多的思考，Bob 得出了一个结论，他必须更谨慎地断开一些环，并将它们重新连接到未完成的链条的其余部分，以获得他想要制作的直链。在直链中，每个环最多连接两个其他环，并且直链不能在不断开链环的情况下分离成更多的部分。\n\nBob 现在更加小心了，将用简单的步骤取得进展。在一个步骤中，他将在未完成的链条上，选择一个与环 B 相连接的另一个环 A 。然后，他会将 A 与 B 分开，并将 A 重新连接到未完成的链条中的另一个环 C。除环 B 外，Bob 将在整个步骤中保持其余原先与环 A 相连的环依旧与环 A 相连。\n\nBob 获得直链所需执行的最小步骤数是多少？", "inputFormat": "第一行包含一个整数 $N\\ (1\\le N\\le 3\\times 10^5)$，代表未完成的链条中的环数。所有环标号为 $1, 2, \\dots, N$。\n\n接下来 $N-1$ 行，每行包含两个整数，代表未完成链条中两个相连环的编号，按任意顺序给出。未完成的链条保证只有一个连体（即任意两个环之间都存在路径使他们相连）。", "outputFormat": "输出一个整数，代表将 Bob 未完成的链条转化为直链的最少步骤数。", "hint": "### 样例解释\n![](https://cdn.luogu.com.cn/upload/image_hosting/541l6nqd.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CERC2019] Bob in Wonderland", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Bob in Wonderland](https://contest.felk.cvut.cz/19cerc/solved/bob.pdf)」**", "description": "众所周知，链条是由相连的环组成的。通常，所有环都具有相同的形状和大小。Bob 是一名铁匠学徒，他正在制作自己的第一条铱链。他遵循传统的链条制作通则。上面写着：\n- 如果没有链条，制作一个环，它将成为你链条的一部分。\n- 如果有一条链，制作一个环，并将其连接到你已有的链中的另一个环上。\n\nBob 做了第一个环。然后，每次他制作另一个环时，他都会将其连接到链条上的其他环上，就像通则告诉他的那样。\n\n当他完成时，他意识到他创造的物体根本不像一条普通的链。为了把链条拉直，他反复地拎起可能是链条两端的两个链环，并试图把它们尽可能地拉开。但在不同的地方，还有更多的“链条”从拉直的部分垂下来。\n\n很明显，Bob 的工作还没有完成，他决定把他制作的物体称为未完成的链条。经过更多的思考，Bob 得出了一个结论，他必须更谨慎地断开一些环，并将它们重新连接到未完成的链条的其余部分，以获得他想要制作的直链。在直链中，每个环最多连接两个其他环，并且直链不能在不断开链环的情况下分离成更多的部分。\n\nBob 现在更加小心了，将用简单的步骤取得进展。在一个步骤中，他将在未完成的链条上，选择一个与环 B 相连接的另一个环 A 。然后，他会将 A 与 B 分开，并将 A 重新连接到未完成的链条中的另一个环 C。除环 B 外，Bob 将在整个步骤中保持其余原先与环 A 相连的环依旧与环 A 相连。\n\nBob 获得直链所需执行的最小步骤数是多少？", "inputFormat": "第一行包含一个整数 $N\\ (1\\le N\\le 3\\times 10^5)$，代表未完成的链条中的环数。所有环标号为 $1, 2, \\dots, N$。\n\n接下来 $N-1$ 行，每行包含两个整数，代表未完成链条中两个相连环的编号，按任意顺序给出。未完成的链条保证只有一个连体（即任意两个环之间都存在路径使他们相连）。", "outputFormat": "输出一个整数，代表将 Bob 未完成的链条转化为直链的最少步骤数。", "hint": "### 样例解释\n![](https://cdn.luogu.com.cn/upload/image_hosting/541l6nqd.png)", "locale": "zh-CN"}}}
{"pid": "P9609", "type": "P", "difficulty": 0, "samples": [["4 6 2\n2 3\n4 4\n\nright 2\n\nyuck!\n", "\n\n\ntop 1\n\nleft 2\n"], ["3 5 1\n2 3\n\nleft 1\n\nleft 1\n\nright 1\n\nyuck!\n", "\n\npass\n\nright 1\n\ntop 1\n\nbottom 1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["博弈论", "2019", "交互题", "Special Judge", "ICPC", "CERC"], "title": "[CERC2019] Crimson Sexy Jalapeños（征集交互库/SPJ）", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Crimson Sexy Jalapeños](https://contest.felk.cvut.cz/19cerc/solved/crimson.pdf)」**", "description": "**这是一道 IO 交互题。**\n\n受污染的巧克力游戏的核心是一个经典的巧克力块，由平行于巧克力块两侧的矩形凹槽网格划分成小方块。一些小方块被极度苦涩的物质污染，（几乎）无法消化。\n\n这场比赛由两名选手轮流进行。在一个有效的动作中，一名玩家必须吃掉巧克力块的一部分。允许将当前的巧克力块沿着其中一个凹槽分成两个较小的巧克力块，然后只吃其中一个。玩家如果吃掉了至少含有一个受污染方块的巧克力块，则输掉游戏。\n\n所有被污染的方块的位置在游戏开始时都是已知的。所有其他的方块都可以安全食用。每个玩家都会尽量避免吃一个含有一个或多个受污染方块的巧克力块，因为当这种情况发生时，玩家会不由自主地做出他们个人最厌恶的鬼脸，这会给其他玩家和其他观看比赛的人带来极大的乐趣。\n\n在这个问题上，你要写一个程序来玩“受污染的巧克力”游戏。我们忽略了代码中模拟玩家扮鬼脸和吃巧克力的部分，而只关注获胜的动作。", "inputFormat": "输入的第一行包含整数 $R, C, K\\ (1\\le R, C\\le 10^4;\\ 1\\le K\\le 100)$。$R$ 是行数，$C$ 是列数，$K$ 是巧克力块中被污染的方块数。\n\n接下来 $K$ 行，每行包含两个整数 $A$ 和 $B\\ (1\\le A\\le R, 1\\le B\\le C)$，代表受污染方块的坐标。左上角正方形的坐标为 $(1, 1)$。\n\n其余的输入取决于你的输出。对于你的每一个有效动作，交互库都会给出一行输入，包含对手的有效动作描述或表示对手输掉比赛的字符串 `yuck!`。在后一种情况下，你的程序应该结束。", "outputFormat": "读入巧克力棒的描述后，你可以决定是否要开始游戏。如果你想选择后手，输出一行，包含字符串 `pass`。这个特殊的字符串只能出现在输出的第一行。\n\n在选择先后手后，对于你的每个动作，输出一行，包含有效动作的描述。如果你的程序输出了一行非有效动作的任何其他内容，那么你的程序将会判为 `Wrong Answer`。\n\n在每次输出动作的描述后，清空缓冲区。例如，你可以使用：\n- 对于 $\\text{C++}$：`fflush(stdout)` 或 `cout.flush()`；\n- 对于 $\\text{Java}$：`System.out.flush()`；\n- 对于 $\\text{Python}$：`stdout.flush()`。", "hint": "### 样例格式说明\n\n为了方便说明程序和交互库的交互顺序，样例格式填充了空行。请注意实际交互过程中不会输出空行。\n\n### 样例 $1$ 解释\n![](https://cdn.luogu.com.cn/upload/image_hosting/t8vf1vc8.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CERC2019] Crimson Sexy Jalapeños（征集交互库/SPJ）", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Crimson Sexy Jalapeños](https://contest.felk.cvut.cz/19cerc/solved/crimson.pdf)」**", "description": "**这是一道 IO 交互题。**\n\n受污染的巧克力游戏的核心是一个经典的巧克力块，由平行于巧克力块两侧的矩形凹槽网格划分成小方块。一些小方块被极度苦涩的物质污染，（几乎）无法消化。\n\n这场比赛由两名选手轮流进行。在一个有效的动作中，一名玩家必须吃掉巧克力块的一部分。允许将当前的巧克力块沿着其中一个凹槽分成两个较小的巧克力块，然后只吃其中一个。玩家如果吃掉了至少含有一个受污染方块的巧克力块，则输掉游戏。\n\n所有被污染的方块的位置在游戏开始时都是已知的。所有其他的方块都可以安全食用。每个玩家都会尽量避免吃一个含有一个或多个受污染方块的巧克力块，因为当这种情况发生时，玩家会不由自主地做出他们个人最厌恶的鬼脸，这会给其他玩家和其他观看比赛的人带来极大的乐趣。\n\n在这个问题上，你要写一个程序来玩“受污染的巧克力”游戏。我们忽略了代码中模拟玩家扮鬼脸和吃巧克力的部分，而只关注获胜的动作。", "inputFormat": "输入的第一行包含整数 $R, C, K\\ (1\\le R, C\\le 10^4;\\ 1\\le K\\le 100)$。$R$ 是行数，$C$ 是列数，$K$ 是巧克力块中被污染的方块数。\n\n接下来 $K$ 行，每行包含两个整数 $A$ 和 $B\\ (1\\le A\\le R, 1\\le B\\le C)$，代表受污染方块的坐标。左上角正方形的坐标为 $(1, 1)$。\n\n其余的输入取决于你的输出。对于你的每一个有效动作，交互库都会给出一行输入，包含对手的有效动作描述或表示对手输掉比赛的字符串 `yuck!`。在后一种情况下，你的程序应该结束。", "outputFormat": "读入巧克力棒的描述后，你可以决定是否要开始游戏。如果你想选择后手，输出一行，包含字符串 `pass`。这个特殊的字符串只能出现在输出的第一行。\n\n在选择先后手后，对于你的每个动作，输出一行，包含有效动作的描述。如果你的程序输出了一行非有效动作的任何其他内容，那么你的程序将会判为 `Wrong Answer`。\n\n在每次输出动作的描述后，清空缓冲区。例如，你可以使用：\n- 对于 $\\text{C++}$：`fflush(stdout)` 或 `cout.flush()`；\n- 对于 $\\text{Java}$：`System.out.flush()`；\n- 对于 $\\text{Python}$：`stdout.flush()`。", "hint": "### 样例格式说明\n\n为了方便说明程序和交互库的交互顺序，样例格式填充了空行。请注意实际交互过程中不会输出空行。\n\n### 样例 $1$ 解释\n![](https://cdn.luogu.com.cn/upload/image_hosting/t8vf1vc8.png)", "locale": "zh-CN"}}}
{"pid": "P9610", "type": "P", "difficulty": 0, "samples": [["7 5 0 1\n-1 -1\n1 -1\n0 0\n2 3\n3 4\n10 10\n2 12\n", "5\n"], ["3 1 1 0\n0 0\n2 0\n4 0\n", "2\n"], ["4 1 1 0\n0 0\n1 1\n1 -1\n2 0\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["计算几何", "2019", "ICPC", "CERC"], "title": "[CERC2019] Deep800080", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Deep800080](https://contest.felk.cvut.cz/19cerc/solved/deep.pdf)」**", "description": "Deep800080 的船主 Ian 今晚将在湖上烧烤。有一个狭窄的直码头，从岸边一直延伸到湖中。Ian 认为在码头的某个地点做烧烤是个好主意。\n\n他想测试一下他的新型特制烧烤炭。当它燃烧时，会产生一种独特的浓紫色烟雾，弥漫在水面上。烟雾保证会在烧烤场周围形成一个完美的圆圈。最终，云层将达到一定的最大半径，并在晚上剩下的时间里保持不变，直到更晚的时候消散。\n\n湖中离码头不同距离的位置停泊着多艘船只。Ian 想把烧烤的事通知他们的船员。由于有点懒，他希望烤肉烟雾能帮他做这项工作。Ian 希望，当云层到达一艘船时，船员们能闻到烟雾，这样他们就能立即知道附近有烧烤。\n\nIan 想最大化被警报的船员数量，因此他想在码头上选择一个可以最大化紫色烟雾到达的船只数量的地点放烧烤架。\n\n你可以认为湖面上的船只已经牢牢地固定住了，即当烟雾层在湖面上时它们不会移动。此外，一旦选择了烧烤地点，其位置在整个活动中保持不变。", "inputFormat": "第一行包含四个整数 $N, R, A, B\\ (0\\le N\\le 3\\times 10^5; 1\\le R\\le 10^6)$。$N$ 是湖面上的船只数量，$R$ 是紫色烧烤烟雾的最大半径。你可以认为桥墩又窄又长，因此可以将其视为穿过坐标为 $(0, 0)$ 和 $(A, B)$ 的两个不同点的直线。\n\n接下来 $N$ 行，每行都包含两个整数 $X$ 和 $Y$，用于描述湖上一艘船的坐标。没有两艘船的坐标相同。\n\n所有坐标都是平面中常见的 Cartesian 坐标，它们的绝对值最多为 $10^6$。", "outputFormat": "输出一个整数，代表紫色烧烤烟雾可以到达的船只的最大数量。\n\n如果船的位置在烟雾形成的圆圈内，包括其边界，则视为已到达。你可以认为将烟雾的最大半径增加 $10^{-3}$ 不会改变解决方案。", "hint": "### 样例解释\n![](https://cdn.luogu.com.cn/upload/image_hosting/y6yh53az.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CERC2019] Deep800080", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Deep800080](https://contest.felk.cvut.cz/19cerc/solved/deep.pdf)」**", "description": "Deep800080 的船主 Ian 今晚将在湖上烧烤。有一个狭窄的直码头，从岸边一直延伸到湖中。Ian 认为在码头的某个地点做烧烤是个好主意。\n\n他想测试一下他的新型特制烧烤炭。当它燃烧时，会产生一种独特的浓紫色烟雾，弥漫在水面上。烟雾保证会在烧烤场周围形成一个完美的圆圈。最终，云层将达到一定的最大半径，并在晚上剩下的时间里保持不变，直到更晚的时候消散。\n\n湖中离码头不同距离的位置停泊着多艘船只。Ian 想把烧烤的事通知他们的船员。由于有点懒，他希望烤肉烟雾能帮他做这项工作。Ian 希望，当云层到达一艘船时，船员们能闻到烟雾，这样他们就能立即知道附近有烧烤。\n\nIan 想最大化被警报的船员数量，因此他想在码头上选择一个可以最大化紫色烟雾到达的船只数量的地点放烧烤架。\n\n你可以认为湖面上的船只已经牢牢地固定住了，即当烟雾层在湖面上时它们不会移动。此外，一旦选择了烧烤地点，其位置在整个活动中保持不变。", "inputFormat": "第一行包含四个整数 $N, R, A, B\\ (0\\le N\\le 3\\times 10^5; 1\\le R\\le 10^6)$。$N$ 是湖面上的船只数量，$R$ 是紫色烧烤烟雾的最大半径。你可以认为桥墩又窄又长，因此可以将其视为穿过坐标为 $(0, 0)$ 和 $(A, B)$ 的两个不同点的直线。\n\n接下来 $N$ 行，每行都包含两个整数 $X$ 和 $Y$，用于描述湖上一艘船的坐标。没有两艘船的坐标相同。\n\n所有坐标都是平面中常见的 Cartesian 坐标，它们的绝对值最多为 $10^6$。", "outputFormat": "输出一个整数，代表紫色烧烤烟雾可以到达的船只的最大数量。\n\n如果船的位置在烟雾形成的圆圈内，包括其边界，则视为已到达。你可以认为将烟雾的最大半径增加 $10^{-3}$ 不会改变解决方案。", "hint": "### 样例解释\n![](https://cdn.luogu.com.cn/upload/image_hosting/y6yh53az.png)", "locale": "zh-CN"}}}
{"pid": "P9611", "type": "P", "difficulty": 4, "samples": [["2 5\n", "9\n"], ["12 12\n", "6\n"], ["555 666\n", "852"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "2019", "ICPC", "整除分块", "CERC"], "title": "[CERC2019] Zeldain Garden", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Zeldain Garden](https://contest.felk.cvut.cz/19cerc/solved/garden.pdf)」**", "description": "Boris 是 Rock Anywhere Transport（RAT）公司的首席执行官，该公司专门支持音乐产业。特别是，他们为许多流行的摇滚乐队提供折扣运输。这一次，Boris 不得不将大量优质的墨西哥音乐会扬声器从北海港口转移到遥远的内陆首都。由于预计收货量很大，Boris 不得不组织多辆卡车以确保运输顺畅。运送货物通过该国的众多卡车被称为车队。\n\nBoris 希望通过一个车队一次性运输所有货物，一个扬声器都不留下。欧盟的严格规定要求，在大规模运输音频技术设备的情况下，车队中的所有卡车必须携带完全相同数量的设备。\n\n为了满足所有规定，Boris 希望提前做一些计划，尽管他还不知道扬声器的确切数量，这对车队中卡车的数量和容量的选择有很大影响。为了检查各种情况，对于每个可能的容货量，Boris 计算出所谓的“可变性”，即在不违反规定的情况下，可以为该容货量创建的不同车队的数量。如果两个车队由不同数量的卡车组成，那么它们就不同了。\n\n例如，$6$ 个扬声器货物的可变性为 $4$，因为它们可以均匀地分为 $1$、$2$、$3$ 或 $6$ 辆卡车。\n\n### 简要题意\n\n给定 $l,r$，求 $l\\sim r$ 中所有数的因数个数之和。", "inputFormat": "输入包含一个文本行，包含两个整数 $N, M\\ (1\\le N\\le M\\le 10^{12})$，代表扬声器货物的最小和最大数量。", "outputFormat": "输出一个整数，代表对于 $N$ 和 $M$ 之间（含）的所有货物量的可变性之和。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CERC2019] Zeldain Garden", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Zeldain Garden](https://contest.felk.cvut.cz/19cerc/solved/garden.pdf)」**", "description": "Boris 是 Rock Anywhere Transport（RAT）公司的首席执行官，该公司专门支持音乐产业。特别是，他们为许多流行的摇滚乐队提供折扣运输。这一次，Boris 不得不将大量优质的墨西哥音乐会扬声器从北海港口转移到遥远的内陆首都。由于预计收货量很大，Boris 不得不组织多辆卡车以确保运输顺畅。运送货物通过该国的众多卡车被称为车队。\n\nBoris 希望通过一个车队一次性运输所有货物，一个扬声器都不留下。欧盟的严格规定要求，在大规模运输音频技术设备的情况下，车队中的所有卡车必须携带完全相同数量的设备。\n\n为了满足所有规定，Boris 希望提前做一些计划，尽管他还不知道扬声器的确切数量，这对车队中卡车的数量和容量的选择有很大影响。为了检查各种情况，对于每个可能的容货量，Boris 计算出所谓的“可变性”，即在不违反规定的情况下，可以为该容货量创建的不同车队的数量。如果两个车队由不同数量的卡车组成，那么它们就不同了。\n\n例如，$6$ 个扬声器货物的可变性为 $4$，因为它们可以均匀地分为 $1$、$2$、$3$ 或 $6$ 辆卡车。\n\n### 简要题意\n\n给定 $l,r$，求 $l\\sim r$ 中所有数的因数个数之和。", "inputFormat": "输入包含一个文本行，包含两个整数 $N, M\\ (1\\le N\\le M\\le 10^{12})$，代表扬声器货物的最小和最大数量。", "outputFormat": "输出一个整数，代表对于 $N$ 和 $M$ 之间（含）的所有货物量的可变性之和。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9612", "type": "P", "difficulty": 3, "samples": [["5 2\n6 15 9 666 1\n", "10\n"], ["8 4\n13 30 27 20 11 30 19 10\n", "18\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2019", "位运算", "ICPC", "CERC"], "title": "[CERC2019] Light Emitting Hindenburg", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Light Emitting Hindenburg](https://contest.felk.cvut.cz/19cerc/solved/hindenburg.pdf)」**", "description": "Lothar 正在组织他朋友的摇滚乐队的音乐会巡演。巡演将于 11 月举行，每天最多有一场音乐会。这次巡演将非常具有代表性，许多音乐家都愿意参加。巡演中的音乐家人数是严格规定的，不能改变。巡演中的每一场音乐会都必须有所有参加巡演的音乐家参加。\n\n对 Lothar 来说，好消息是，候选音乐家的数量至少与巡演中规定的音乐家数量一样多。坏消息是，一个典型的音乐家整个月都没有空，而且各种音乐家的日程安排也大不相同。\n\n很久以前，Lothar 编写了一个计算机调度系统的核心，现在他正在利用它来组织这次巡演。他反复地、有点随机地选择一组指定数量的音乐家，并让系统计算出一个可接受的巡演时间表。该系统取决于一种非常具体的数据格式。音乐家的时间表和巡演时间表用数字编码表示。11 月的日子是按月份的数字标记的：$1, 2, \\dots, 30$。\n\n对于一个给定的音乐家来说，每年 11 月的一天都会被分配一个特定的数字编码。如果音乐家当天空闲，则标签为 $L$ 的一天由整数 $2^{30-L}$ 编码。否则，日期将由 $0$ 编码。音乐家的时间表编码是他或她的所有日期编码的总和。\n\n对于一组给定的音乐家来说，每年 11 月的一天都会被分配一个特定的数字编码。如果该组中的所有音乐家当天都空闲，标签为 $L$ 的一天由整数 $2^{30-L}$ 编码。否则，日期将由 $0$ 编码。组的空闲编码是该组所有日期编码的总和。\n\n出于许多其他微妙的原因，Lothar 认为最好的巡演应该是任意一组音乐家，这组的空闲编码是可能的最大值。", "inputFormat": "第一行包含两个整数 $N, K\\ (1\\le K\\le N\\le 2\\times 10^5)$。$N$ 是可用音乐家的数量，$K$ 是参加巡演的音乐家的规定数量。\n\n第二行包含一个由 $N$ 个正整数组成的序列。序列中的每个整数表示一个音乐家的时间表编码。编码按任意顺序列出。", "outputFormat": "输出一个整数，代表 $K$ 个音乐家的空闲编码值总和的最大值。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CERC2019] Light Emitting Hindenburg", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Light Emitting Hindenburg](https://contest.felk.cvut.cz/19cerc/solved/hindenburg.pdf)」**", "description": "Lothar 正在组织他朋友的摇滚乐队的音乐会巡演。巡演将于 11 月举行，每天最多有一场音乐会。这次巡演将非常具有代表性，许多音乐家都愿意参加。巡演中的音乐家人数是严格规定的，不能改变。巡演中的每一场音乐会都必须有所有参加巡演的音乐家参加。\n\n对 Lothar 来说，好消息是，候选音乐家的数量至少与巡演中规定的音乐家数量一样多。坏消息是，一个典型的音乐家整个月都没有空，而且各种音乐家的日程安排也大不相同。\n\n很久以前，Lothar 编写了一个计算机调度系统的核心，现在他正在利用它来组织这次巡演。他反复地、有点随机地选择一组指定数量的音乐家，并让系统计算出一个可接受的巡演时间表。该系统取决于一种非常具体的数据格式。音乐家的时间表和巡演时间表用数字编码表示。11 月的日子是按月份的数字标记的：$1, 2, \\dots, 30$。\n\n对于一个给定的音乐家来说，每年 11 月的一天都会被分配一个特定的数字编码。如果音乐家当天空闲，则标签为 $L$ 的一天由整数 $2^{30-L}$ 编码。否则，日期将由 $0$ 编码。音乐家的时间表编码是他或她的所有日期编码的总和。\n\n对于一组给定的音乐家来说，每年 11 月的一天都会被分配一个特定的数字编码。如果该组中的所有音乐家当天都空闲，标签为 $L$ 的一天由整数 $2^{30-L}$ 编码。否则，日期将由 $0$ 编码。组的空闲编码是该组所有日期编码的总和。\n\n出于许多其他微妙的原因，Lothar 认为最好的巡演应该是任意一组音乐家，这组的空闲编码是可能的最大值。", "inputFormat": "第一行包含两个整数 $N, K\\ (1\\le K\\le N\\le 2\\times 10^5)$。$N$ 是可用音乐家的数量，$K$ 是参加巡演的音乐家的规定数量。\n\n第二行包含一个由 $N$ 个正整数组成的序列。序列中的每个整数表示一个音乐家的时间表编码。编码按任意顺序列出。", "outputFormat": "输出一个整数，代表 $K$ 个音乐家的空闲编码值总和的最大值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9613", "type": "P", "difficulty": 6, "samples": [["2 3\n1 a\n1 b\n1 c\n", "529\n"], ["3 3\n2 aa\n1 a\n1 a\n", "15625\n"], ["3 1\n2 ab\n", "17524\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "动态规划 DP", "2019", "矩阵加速", "矩阵乘法", "AC 自动机", "ICPC", "CERC"], "title": "[CERC2019] K==S", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[K==S](https://contest.felk.cvut.cz/19cerc/solved/kequalss.pdf)」**", "description": "渐进式硬八度摇滚曲调（所谓的“phorts”）是使用特定的音符创作的。这种摇滚风格只建立在 $13$ 个不同的音符音高上，其他音高（在其他八度中）被认为是过时的音乐基石。每个音符可以是长的，也可以是短的。因此，摇滚中正好有 $26$ 个不同的音符。\n\n你将在你朋友的生日之际创作一首 phort 曲调，并与你的乐队在主要的城市广场上表演。在创作词缀时，你需要避免使用某些音乐短语，这些短语由于大型唱片公司赞助的长期研究而受到版权保护。已经证实，这些短语非常朗朗上口，易于记忆，可以用来将听众下意识地与某个特定的音乐公司联系起来，该公司会在他们的制作中使用这些短语。\n\n曲调是一连串的音符。一个音乐短语也是一个音符序列，如果它的音符形成曲调的连续子序列，则它被认为包含在曲调中，这意味着相同的音符以相同的顺序出现在曲调中。\n\n幸运的是，到目前为止，只有少数禁用短语获得了专利。因此，你可以相对自由地创作自己的曲调。特别是，您对某些长度的可接受的曲调的数量感兴趣。可接受的曲调是指任何不包含禁用短语的曲调。曲调的长度等于它所包含的音符数。", "inputFormat": "第一行包含两个整数 $N, Q\\ (1\\le N\\le 10^9, 1\\le Q\\le 100)$。$N$ 是曲调的长度，$Q$ 是禁用音乐短语的数量。\n\n接下来 $Q$ 行，每行都描述了一个禁用短语。禁用短语的描述以一个表示其长度的正整数 $L$ 开头，后跟一个由 $L$ 个小写英文字母组成的字符串。每个字母代表一个摇滚音符，不同的字母代表不同的音符。\n\n所有禁用短语的长度总和不超过 $100$。", "outputFormat": "输出长度为 $N$ 的不同可接受曲调的数量对 $1\\,000\\,000\\,007$ 取模的值。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CERC2019] K==S", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[K==S](https://contest.felk.cvut.cz/19cerc/solved/kequalss.pdf)」**", "description": "渐进式硬八度摇滚曲调（所谓的“phorts”）是使用特定的音符创作的。这种摇滚风格只建立在 $13$ 个不同的音符音高上，其他音高（在其他八度中）被认为是过时的音乐基石。每个音符可以是长的，也可以是短的。因此，摇滚中正好有 $26$ 个不同的音符。\n\n你将在你朋友的生日之际创作一首 phort 曲调，并与你的乐队在主要的城市广场上表演。在创作词缀时，你需要避免使用某些音乐短语，这些短语由于大型唱片公司赞助的长期研究而受到版权保护。已经证实，这些短语非常朗朗上口，易于记忆，可以用来将听众下意识地与某个特定的音乐公司联系起来，该公司会在他们的制作中使用这些短语。\n\n曲调是一连串的音符。一个音乐短语也是一个音符序列，如果它的音符形成曲调的连续子序列，则它被认为包含在曲调中，这意味着相同的音符以相同的顺序出现在曲调中。\n\n幸运的是，到目前为止，只有少数禁用短语获得了专利。因此，你可以相对自由地创作自己的曲调。特别是，您对某些长度的可接受的曲调的数量感兴趣。可接受的曲调是指任何不包含禁用短语的曲调。曲调的长度等于它所包含的音符数。", "inputFormat": "第一行包含两个整数 $N, Q\\ (1\\le N\\le 10^9, 1\\le Q\\le 100)$。$N$ 是曲调的长度，$Q$ 是禁用音乐短语的数量。\n\n接下来 $Q$ 行，每行都描述了一个禁用短语。禁用短语的描述以一个表示其长度的正整数 $L$ 开头，后跟一个由 $L$ 个小写英文字母组成的字符串。每个字母代表一个摇滚音符，不同的字母代表不同的音符。\n\n所有禁用短语的长度总和不超过 $100$。", "outputFormat": "输出长度为 $N$ 的不同可接受曲调的数量对 $1\\,000\\,000\\,007$ 取模的值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9614", "type": "P", "difficulty": 5, "samples": [["CGATA\nATAGC\n", "2\n"], ["CTAGAGTCTA\nTACCGTATAG\n", "7\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2019", "图论建模", "ICPC", "CERC"], "title": "[CERC2019] Ponk Warshall", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Ponk Warshall](https://contest.felk.cvut.cz/19cerc/solved/ponk.pdf)」**", "description": "听摇滚乐会改变你的核心 DNA。这一令人震惊和难以置信的事实最近发表在地球上顶级科学期刊之一的《摇滚自然周刊》上。研究的一部分是在摇滚音乐会季前后从志愿者身上采集 DNA 样本。对样品进行处理，并从样品中分离出各种基因。对于每个人，每个基因被分离两次：摇滚季之前的变体和摇滚季之后的变体。这两个变体是配对的，在许多情况下，发现一个变体是该对中另一个变体的某种排列。\n\n研究的下一步是确定排列是如何发生的。普遍的假说认为，排列是由一系列转座组成的，即所谓的交换。交换是指基因中正好有两个核碱基在基因中交换位置的事件（其化学性质尚不完全清楚）。该基因中没有其他核碱基受到交换的影响。两个交换的核碱基的位置可能是完全任意的。\n\n为了预测和观察分子在排列过程中的运动，研究人员需要知道能够在基因中产生特定核碱基排列的理论最小交换次数。我们提醒你，核 DNA 基因是一个由胞嘧啶、鸟嘌呤、腺嘌呤和胸腺嘧啶组成的碱基序列，它们分别编码为 C、G、A 和 T。\n\n### 简要题意\n\n给定两个字符串（字符集只含 `A`、`C`、`G` 或 `T`），求把第一个字符串通过交换两个字母变为第二个字符串的最少交换次数。", "inputFormat": "输入包含两行。每行包含一个由 $N\\ (1\\le N\\le 10^6)$ 个大写字母“A”、“C”、“G”或“T”组成的字符串。这两个字符串代表一对特定的基因版本。第一行代表摇滚季之前的基因，第二行代表来自摇滚季之后同一个人的相同基因。在两个字符串中，每个核碱基的出现次数是相同的。", "outputFormat": "输出一个整数，代表将第一个基因版本转换为第二个基因版本交换的最小数量。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CERC2019] Ponk Warshall", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Ponk Warshall](https://contest.felk.cvut.cz/19cerc/solved/ponk.pdf)」**", "description": "听摇滚乐会改变你的核心 DNA。这一令人震惊和难以置信的事实最近发表在地球上顶级科学期刊之一的《摇滚自然周刊》上。研究的一部分是在摇滚音乐会季前后从志愿者身上采集 DNA 样本。对样品进行处理，并从样品中分离出各种基因。对于每个人，每个基因被分离两次：摇滚季之前的变体和摇滚季之后的变体。这两个变体是配对的，在许多情况下，发现一个变体是该对中另一个变体的某种排列。\n\n研究的下一步是确定排列是如何发生的。普遍的假说认为，排列是由一系列转座组成的，即所谓的交换。交换是指基因中正好有两个核碱基在基因中交换位置的事件（其化学性质尚不完全清楚）。该基因中没有其他核碱基受到交换的影响。两个交换的核碱基的位置可能是完全任意的。\n\n为了预测和观察分子在排列过程中的运动，研究人员需要知道能够在基因中产生特定核碱基排列的理论最小交换次数。我们提醒你，核 DNA 基因是一个由胞嘧啶、鸟嘌呤、腺嘌呤和胸腺嘧啶组成的碱基序列，它们分别编码为 C、G、A 和 T。\n\n### 简要题意\n\n给定两个字符串（字符集只含 `A`、`C`、`G` 或 `T`），求把第一个字符串通过交换两个字母变为第二个字符串的最少交换次数。", "inputFormat": "输入包含两行。每行包含一个由 $N\\ (1\\le N\\le 10^6)$ 个大写字母“A”、“C”、“G”或“T”组成的字符串。这两个字符串代表一对特定的基因版本。第一行代表摇滚季之前的基因，第二行代表来自摇滚季之后同一个人的相同基因。在两个字符串中，每个核碱基的出现次数是相同的。", "outputFormat": "输出一个整数，代表将第一个基因版本转换为第二个基因版本交换的最小数量。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9615", "type": "P", "difficulty": 0, "samples": [["4 4 3\n1 2\n3 1\n1 4\n3 4\n3 2 3 4\n1 1\n4 1 2 3 4\n", "2\n1\n1\n"], ["5 1 1\n1 2\n5 5 4 3 2 1\n", "4\n"]], "limits": {"time": [500, 500, 500, 500, 5000, 2000, 1000, 500, 500, 500, 1000, 500, 500, 500, 500, 500, 3000, 500, 500, 500, 500, 500, 500, 500, 3000, 2500, 500, 500, 3000, 3000, 3000, 3000, 1500, 500, 500, 500, 500, 500, 500, 500, 1000, 500, 500, 500, 500, 1000, 500, 500, 500, 500, 500, 2000, 2000, 2000, 2000, 2000, 500, 500, 500, 500, 3000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2019", "O2优化", "ICPC", "CERC"], "title": "[CERC2019] Saba1000kg", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Saba1000kg](https://contest.felk.cvut.cz/19cerc/solved/saba.pdf)」**", "description": "维京岩石运动中有许多不同的风格。古老的冰岛花岗岩石、中世纪丹麦尘土飞扬的维京岩石、晚期芬盖尔深绿色岩石、峡湾巨石雪崩岩石和许多其他岩石……所有受欢迎的风格的完整列表会多次溢出本页。斯堪的纳维亚高等教育部研究了各种风格之间相互影响的方式。他们目前正在计划一项大型实验，届时将有一些经过适当选择的志愿者分布在一个由无人居住的小岛组成的群岛上，研究人员希望在相对较长的一段时间内观察他们的岩石风格和偏好的相互影响。\n\n一个岛上的居民总是相互影响。一些岛对距离足够近，他们的居民可以相互影响，而其他岛对之间的距离可以防止任何直接影响。在后一种情况下，如果有一个或多个其他岛屿有人居住并传递影响，这些岛屿的居民仍然可以相互影响，但只能间接影响。\n\n关于志愿者在各岛屿之间的分配，有几个提案。对于每一种提案，该部都想知道该群岛将形成的独立居民群体的数量。两组岛屿居民，每一组都占据一个或多个岛屿，如果他们不可能相互影响，甚至不是以间接的方式，也被视为独立的（译者注：此处定义了“与其他居民群体独立的居民群体”为无法被其他居民直接或间接影响的居民的岛屿）。\n\n帮助该部评估他们的提案。", "inputFormat": "第一行包含三个整数 $N, E, P\\ (1\\le N\\le 10^5, 0\\le E\\le 10^5, 1\\le P\\le 10^5)$。$N$ 是群岛中的岛屿数量，$E$ 是允许直接影响的岛对数量，$P$ 是要评估的提案数量。这些岛被从 $1$ 到 $N$ 标号。\n\n接下来 $E$ 行指定允许直接相互影响的岛对。这些行中的每一行包含两个整数 $A$ 和 $B$，表示两个不同岛的标号。没有岛对出现超过一次。\n\n接下来 $P$ 行，每行都描述了一个提案。每行以该提案下居住的岛屿数量 $M\\ (1\\le M\\le N)$ 开始，然后包含 $M$ 个居住岛屿的成对不同标号。根据各自的提案，不会有其他岛屿居住（译者注：即只考虑每次询问的岛屿能否传递影响）。\n\n所有提案的大小之和（所有数字 $M$）不超过 $10^5$。", "outputFormat": "对于每个提案，输出一行，代表该群岛将形成的独立群体的数量。", "hint": null, "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CERC2019] Saba1000kg", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Saba1000kg](https://contest.felk.cvut.cz/19cerc/solved/saba.pdf)」**", "description": "维京岩石运动中有许多不同的风格。古老的冰岛花岗岩石、中世纪丹麦尘土飞扬的维京岩石、晚期芬盖尔深绿色岩石、峡湾巨石雪崩岩石和许多其他岩石……所有受欢迎的风格的完整列表会多次溢出本页。斯堪的纳维亚高等教育部研究了各种风格之间相互影响的方式。他们目前正在计划一项大型实验，届时将有一些经过适当选择的志愿者分布在一个由无人居住的小岛组成的群岛上，研究人员希望在相对较长的一段时间内观察他们的岩石风格和偏好的相互影响。\n\n一个岛上的居民总是相互影响。一些岛对距离足够近，他们的居民可以相互影响，而其他岛对之间的距离可以防止任何直接影响。在后一种情况下，如果有一个或多个其他岛屿有人居住并传递影响，这些岛屿的居民仍然可以相互影响，但只能间接影响。\n\n关于志愿者在各岛屿之间的分配，有几个提案。对于每一种提案，该部都想知道该群岛将形成的独立居民群体的数量。两组岛屿居民，每一组都占据一个或多个岛屿，如果他们不可能相互影响，甚至不是以间接的方式，也被视为独立的（译者注：此处定义了“与其他居民群体独立的居民群体”为无法被其他居民直接或间接影响的居民的岛屿）。\n\n帮助该部评估他们的提案。", "inputFormat": "第一行包含三个整数 $N, E, P\\ (1\\le N\\le 10^5, 0\\le E\\le 10^5, 1\\le P\\le 10^5)$。$N$ 是群岛中的岛屿数量，$E$ 是允许直接影响的岛对数量，$P$ 是要评估的提案数量。这些岛被从 $1$ 到 $N$ 标号。\n\n接下来 $E$ 行指定允许直接相互影响的岛对。这些行中的每一行包含两个整数 $A$ 和 $B$，表示两个不同岛的标号。没有岛对出现超过一次。\n\n接下来 $P$ 行，每行都描述了一个提案。每行以该提案下居住的岛屿数量 $M\\ (1\\le M\\le N)$ 开始，然后包含 $M$ 个居住岛屿的成对不同标号。根据各自的提案，不会有其他岛屿居住（译者注：即只考虑每次询问的岛屿能否传递影响）。\n\n所有提案的大小之和（所有数字 $M$）不超过 $10^5$。", "outputFormat": "对于每个提案，输出一行，代表该群岛将形成的独立群体的数量。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P9616", "type": "P", "difficulty": 0, "samples": [["4 3 0 3 4\n0 0\n4 0\n4 4\n0 4\n", "4.828427124746\n"], ["6 1 1 5 5\n0 0\n2 0\n2 4\n6 4\n6 6\n0 6\n", "6.292528739884\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2019", "Special Judge", "ICPC", "CERC"], "title": "[CERC2019] Screamers in the Storm", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Screamers in the Storm](https://contest.felk.cvut.cz/19cerc/solved/screamers.pdf)」**", "description": "你可能不知道，每天在城市里看到的“普通”城市鸽子的正式名称其实是“岩鸽”。岩鸽 Rocky Dave 爱上了 Columba Livia——一只对岩石、鸽子及相关事物有着浓厚兴趣的年轻雌性岩鸽。一个阳光明媚的秋日下午，我们恰巧发现它们同时出现在城市郊区同一栋建筑的屋顶上。\n\n为了炫耀自信的矫健步态，Rocky Dave 决定不直接飞向心仪对象，而是步行前往。这屋顶并非现代平顶，而是由斜坡组成的经典式样。由于建筑由多个较小结构连接而成，其平面布局略显复杂。因此，Dave 计划走向 Columba Livia 的“直线”，仅当从上方俯视时呈现笔直状态。Rocky Dave 可能需要攀爬屋脊、翻越顶峰、下到另一侧的天沟，然后再次上行，如此往复。\n\n我们掌握了建筑精确的平面图、屋顶斜坡角度（所有角度相同），以及两位主角在屋顶的初始位置。根据这些数据，请计算 Rocky Dave 旅程的精确长度（假设 Columba Livia 在 Rocky Dave 抵达前不会离开原位）。\n\n若路径超出建筑边界，根据 Dave 的计划，每当抵达屋顶边缘的雨水槽时，他将沿朝向 Columba Livia 的方向保持相同高度直线飞行，直至抵达建筑另一侧的雨水槽，随后继续步行旅程。\n\n为使情境明确，现提供屋顶几何模型：设 $Z$ 为 $x$-$y$ 平面上的简单多边形（简单多边形指边界为不自交封闭曲线的多边形）。可接受金字塔指底面为 $x$-$y$ 平面上轴对齐正方形、顶点位于底面中心正上方的金字塔，其高度恰好等于底面边长的一半，且底面任意部分不得超出 $Z$ 范围。需注意，可接受金字塔的底面边长和高度可能为零，此时仅包含一个顶点（即塔尖）。\n\n当且仅当某点 $X$（位于 $x$-$y$ 平面或上方）是可接受金字塔的顶点，且不存在 $X$ 正上方的点属于其他可接受金字塔的顶点时，该点被视为 $Z$ 的屋顶构成点。", "inputFormat": "第一行包含五个整数。第一个整数 $N\\ (4\\le N\\le 400)$ 代表建筑平面图边缘在 $x$-$y$ 平面上构成的多边形的角点数量。随后两个整数代表 Rocky Dave 的 $x$ 和 $y$ 坐标，最后两个代表 Columba Livia 的 $x$ 和 $y$ 坐标。\n\n接下来 $N$ 行，每行包含多边形一个角点的 $x$ 和 $y$ 坐标。所有点按逆时针方向列出。建筑的每条边均与坐标轴平行。\n\n两只鸽子均不位于给定多边形之外。所有输入坐标均为绝对值不超过 $10^5$ 的整数。", "outputFormat": "输出 Rocky Dave 旅程的长度。答案的绝对误差或相对误差需小于 $10^{-7}$。", "hint": "### 样例解释\n![](https://cdn.luogu.com.cn/upload/image_hosting/vytjjbu0.png)\n\n翻译由 DeepSeek 生成。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CERC2019] Screamers in the Storm", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Screamers in the Storm](https://contest.felk.cvut.cz/19cerc/solved/screamers.pdf)」**", "description": "你可能不知道，每天在城市里看到的“普通”城市鸽子的正式名称其实是“岩鸽”。岩鸽 Rocky Dave 爱上了 Columba Livia——一只对岩石、鸽子及相关事物有着浓厚兴趣的年轻雌性岩鸽。一个阳光明媚的秋日下午，我们恰巧发现它们同时出现在城市郊区同一栋建筑的屋顶上。\n\n为了炫耀自信的矫健步态，Rocky Dave 决定不直接飞向心仪对象，而是步行前往。这屋顶并非现代平顶，而是由斜坡组成的经典式样。由于建筑由多个较小结构连接而成，其平面布局略显复杂。因此，Dave 计划走向 Columba Livia 的“直线”，仅当从上方俯视时呈现笔直状态。Rocky Dave 可能需要攀爬屋脊、翻越顶峰、下到另一侧的天沟，然后再次上行，如此往复。\n\n我们掌握了建筑精确的平面图、屋顶斜坡角度（所有角度相同），以及两位主角在屋顶的初始位置。根据这些数据，请计算 Rocky Dave 旅程的精确长度（假设 Columba Livia 在 Rocky Dave 抵达前不会离开原位）。\n\n若路径超出建筑边界，根据 Dave 的计划，每当抵达屋顶边缘的雨水槽时，他将沿朝向 Columba Livia 的方向保持相同高度直线飞行，直至抵达建筑另一侧的雨水槽，随后继续步行旅程。\n\n为使情境明确，现提供屋顶几何模型：设 $Z$ 为 $x$-$y$ 平面上的简单多边形（简单多边形指边界为不自交封闭曲线的多边形）。可接受金字塔指底面为 $x$-$y$ 平面上轴对齐正方形、顶点位于底面中心正上方的金字塔，其高度恰好等于底面边长的一半，且底面任意部分不得超出 $Z$ 范围。需注意，可接受金字塔的底面边长和高度可能为零，此时仅包含一个顶点（即塔尖）。\n\n当且仅当某点 $X$（位于 $x$-$y$ 平面或上方）是可接受金字塔的顶点，且不存在 $X$ 正上方的点属于其他可接受金字塔的顶点时，该点被视为 $Z$ 的屋顶构成点。", "inputFormat": "第一行包含五个整数。第一个整数 $N\\ (4\\le N\\le 400)$ 代表建筑平面图边缘在 $x$-$y$ 平面上构成的多边形的角点数量。随后两个整数代表 Rocky Dave 的 $x$ 和 $y$ 坐标，最后两个代表 Columba Livia 的 $x$ 和 $y$ 坐标。\n\n接下来 $N$ 行，每行包含多边形一个角点的 $x$ 和 $y$ 坐标。所有点按逆时针方向列出。建筑的每条边均与坐标轴平行。\n\n两只鸽子均不位于给定多边形之外。所有输入坐标均为绝对值不超过 $10^5$ 的整数。", "outputFormat": "输出 Rocky Dave 旅程的长度。答案的绝对误差或相对误差需小于 $10^{-7}$。", "hint": "### 样例解释\n![](https://cdn.luogu.com.cn/upload/image_hosting/vytjjbu0.png)\n\n翻译由 DeepSeek 生成。", "locale": "zh-CN"}}}
{"pid": "P9617", "type": "P", "difficulty": 0, "samples": [["5\n1 2 3 4 5\n", "123\n"], ["6\n5 4 9 1 7 4\n", "121\n132\n211\n212\n213\n231\n312\n321\n"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 2000, 2000, 1500, 500, 500, 1000, 1500, 1000, 1000, 1500, 1500, 1500, 1000, 1000, 2000, 2000, 500, 1000, 500, 500, 1500, 1500, 1000, 2000, 2000, 1000, 1500, 1500, 2000, 1000, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 2500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2019", "O2优化", "ICPC", "CERC"], "title": "[CERC2019] The Bugs", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[The Bugs](https://contest.felk.cvut.cz/19cerc/solved/thebugs.pdf)」**", "description": "一艘涂有明亮塑料柠檬色的潜艇正在调查海洋深度，并测量水中塑料 yocto 颗粒的浓度。每个测量值（由于巧妙地选择了单位）都是一个正整数。\n\n测量系统是最新的，很少测试，容易出错。项目管理层怀疑它充满了漏洞。他们发现自己陷入了困境。Mother Mary 也怀疑里面满是漏洞。大家都喊：救命！\n\n为了发现和修复这些漏洞，他们聚集在一起，决定采用浓度的测量序列，并分析测量序列中出现的所有三元组。\n\n- 三元组是由三个整数组成的序列。\n- 每个三元组都与其特征组相关。\n- 三元组 $(x, y, z)$ 的特征组是三元组 $(\\text{sgn}(y−x) ,\\text{sgn}(z−y), \\text{sgn}(z−x))$。对于 $x$ 的负值、零值或正值，$\\text{sgn}(x)$ 函数的值分别为 $−1$、$0$ 或 $1$，即 $\\text{sgn}(x)=\\begin{cases}0&x=0\\\\\\dfrac{x}{|x|}&x\\ne 0\\end{cases}$。\n- 三元组 $(x_1, y_1, z_1)$ 小于三元组 $(x_2, y_2, z_2)$，当且仅当三元组 $(x_1-x_2, y_1-y_2, z_1-z_2)$ 中的第一个非零值为负。\n- 三元组 $T$ 的标记组是一个最小的三元组，它的值都为正，并且其特征组等于 $T$ 的特征组。\n\n一个被测三元组是作为测量序列的子序列的三元组。也就是说，这个三元组的元素以它们在三元组中出现的相同顺序出现在测量序列中，但在序列中它们不一定相互跟随。\n\n在对它们进行分析之前，被测三元组根据它们的标记组进行分组。管理层希望提前知道所有测量的三元组的标记组的集合。", "inputFormat": "第一行包含一个整数 $N\\ (3\\le N\\le 2\\times 10^5)$，代表测量序列的长度。\n\n第二行包含 $N$ 个整数 $x_1, x_2, x_N\\ (1\\le x_i\\le 10^9)$，代表测量序列。", "outputFormat": "按递增顺序输出所有被测三元组的所有不同标记组，这些标记组可以从给定的测量序列中获得，每行一个。输出标记组时，其连续元素之间不应有空格。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CERC2019] The Bugs", "background": "**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[The Bugs](https://contest.felk.cvut.cz/19cerc/solved/thebugs.pdf)」**", "description": "一艘涂有明亮塑料柠檬色的潜艇正在调查海洋深度，并测量水中塑料 yocto 颗粒的浓度。每个测量值（由于巧妙地选择了单位）都是一个正整数。\n\n测量系统是最新的，很少测试，容易出错。项目管理层怀疑它充满了漏洞。他们发现自己陷入了困境。Mother Mary 也怀疑里面满是漏洞。大家都喊：救命！\n\n为了发现和修复这些漏洞，他们聚集在一起，决定采用浓度的测量序列，并分析测量序列中出现的所有三元组。\n\n- 三元组是由三个整数组成的序列。\n- 每个三元组都与其特征组相关。\n- 三元组 $(x, y, z)$ 的特征组是三元组 $(\\text{sgn}(y−x) ,\\text{sgn}(z−y), \\text{sgn}(z−x))$。对于 $x$ 的负值、零值或正值，$\\text{sgn}(x)$ 函数的值分别为 $−1$、$0$ 或 $1$，即 $\\text{sgn}(x)=\\begin{cases}0&x=0\\\\\\dfrac{x}{|x|}&x\\ne 0\\end{cases}$。\n- 三元组 $(x_1, y_1, z_1)$ 小于三元组 $(x_2, y_2, z_2)$，当且仅当三元组 $(x_1-x_2, y_1-y_2, z_1-z_2)$ 中的第一个非零值为负。\n- 三元组 $T$ 的标记组是一个最小的三元组，它的值都为正，并且其特征组等于 $T$ 的特征组。\n\n一个被测三元组是作为测量序列的子序列的三元组。也就是说，这个三元组的元素以它们在三元组中出现的相同顺序出现在测量序列中，但在序列中它们不一定相互跟随。\n\n在对它们进行分析之前，被测三元组根据它们的标记组进行分组。管理层希望提前知道所有测量的三元组的标记组的集合。", "inputFormat": "第一行包含一个整数 $N\\ (3\\le N\\le 2\\times 10^5)$，代表测量序列的长度。\n\n第二行包含 $N$ 个整数 $x_1, x_2, x_N\\ (1\\le x_i\\le 10^9)$，代表测量序列。", "outputFormat": "按递增顺序输出所有被测三元组的所有不同标记组，这些标记组可以从给定的测量序列中获得，每行一个。输出标记组时，其连续元素之间不应有空格。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9618", "type": "P", "difficulty": 4, "samples": [["5 3 3\n5 1 2 3 4 5\n2 1 3\n3 2 4 5\n1 1 1\n3 0 2\n1 5 2\n", "4\n9\n4\n"], ["10 7 10\n10 1 2 3 4 5 6 7 8 9 10\n5 3 8 5 1 6\n2 1 6\n4 3 7 8 5\n1 1\n2 10 2\n6 8 4 7 3 1 5\n5 10 6\n17 14 0\n11 14 5\n8 8 3\n8 13 9\n11 2 9\n7 1 6\n11 11 8\n15 3 0\n0 17 4\n", "35\n153\n69\n48\n53\n57\n36\n66\n135\n0\n"], ["10 7 10\n10 1 2 3 4 5 6 7 8 9 10\n3 2 7 1\n3 5 10 9\n2 2 7\n5 4 8 1 7 2\n3 10 9 4\n4 2 1 7 8\n18 6 0\n16 11 0\n18 1 0\n14 0 0\n19 14 0\n3 2 0\n18 15 0\n5 18 0\n2 17 0\n20 10 0\n", "162\n144\n162\n126\n171\n27\n162\n45\n18\n180\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": [], "title": "地铁", "background": "> 两年级生 孤单一人\n>\n> 仰望上空 陋市苍穹\n>\n> 在宇宙这个约会室中\n>\n> Maybe 我们只是刚好没能邂逅呢", "description": "著名工程学专家 625OutContradiction 设计了一张地铁交通网 $G$．$G$ 拥有 $n$ 个站点和 $m$ 条地铁线路．\n\n第 $i$ 条地铁线路 $P_i$ 会经过交通网上的若干站点，形如 $P_i=(u_1,u_2,u_3,...,u_{k_i})(k_i>0)$：每两个相邻站点 $u_j,u_{j+1}(j<k_i)$ 之间存在一段属于线路 $i$ 的从 $u_j$ 通向 $u_{j+1}$ 的单向地铁轨道．保证一条地铁线路不重复经过同一站点．但一个站点可能被若干条地铁线路经过．\n\n丹羽和艾莉欧准备从 $1$ 号站点前往 $n$ 号站点．然而他们的自行车坏掉了，只好准备乘坐地铁．现在他们需要决定出行的方案．\n\n一种出行方案具体是这样的：从 $1$ 号站点出发，选定一条经过 $1$ 号站点的地铁线路并开始乘坐地铁．沿当前地铁线路乘坐地铁的过程中，可以选择换乘其他任意一条经过当前站点的地铁线路．要求最终到达 $n$ 号站点．乘坐地铁过程中重复经过某一站点或某段地铁轨道是被允许的．\n\n**请注意：从 $1$ 号站点出发，第一次乘坐地铁不被算作换乘．**\n\n艾莉欧提出了 $q$ 个问题．对于每个问题，艾莉欧会提供三个参数 $a, b, c$．在这次问题中，一个出行方案如果经过了 $x$ 段地铁轨道并进行了 $y$ 次换乘，那么它的疲惫值为 $ax+by$．您需要回答换乘次数不超过 $c$ 的出行方案中最小的疲惫值是多少．", "inputFormat": "第一行三个整数 $n, m, q$．\n\n接下来 $m$ 行，第 $i$ 行形如：$k_i,u_1,u_2,u_3,...,u_{k_i}$．\n表示一条地铁线路．\n\n接下来 $q$ 行，每行三个整数，表示 $a,b,c$．", "outputFormat": "$q$ 行，对应每个问题的回答．", "hint": "### 样例 #1 说明\n$1\\rightarrow 2\\rightarrow 3\\rightarrow 4\\rightarrow 5$ 是给出的第一条地铁线路，$1\\rightarrow 3$，$2\\rightarrow 4\\rightarrow 5$ 是第二三条地铁线路．\n\n对于第一二组询问，均存在一种最优的出行方案为，在 $1$ 站点搭乘第二条地铁线路到达 $3$ 站点，在 $3$ 站点换乘第一条地铁线路到达终点；共经过 $3$ 段地铁轨道，并进行了 $1$ 次换乘，故第一二组询问的答案分别为 $3\\times 1+1\\times 1=4$，$3\\times 3+1\\times 0=9$．对于第三组询问，由于换乘的代价较大，最优的方案为顺着第一条地铁线路一直通向终点，途径 $4$ 段地铁轨道，答案为 $4$．\n\n### 数据点约束\n对于所有数据满足：\n\n$1\\le n \\le 10^5$，$1\\le m \\le 10^4$，$1\\le q \\le 10^5$，$\\sum k_i \\le 3\\times 10^5$．\n\n$0 \\le a,b \\le 10^6$，$0 \\le c \\le 20$．\n\n---\n对于 $10\\%$ 的数据满足：$n \\le 20$，$\\sum k_i \\le 40$，$q \\le 30$．\n\n---\n\n对于另外 $20\\%$ 的数据满足：$c=0$．\n\n---\n\n对于另外 $30\\%$ 的数据满足：$q=1$．\n\n---\n\n题目中可能存在只经过一个地铁站的地铁线路．这种线路可以直接忽视．数据保证：对于任意一组询问，存在一条合法的路线可以到达终点．", "locale": "zh-CN", "translations": {"zh-CN": {"title": "地铁", "background": "> 两年级生 孤单一人\n>\n> 仰望上空 陋市苍穹\n>\n> 在宇宙这个约会室中\n>\n> Maybe 我们只是刚好没能邂逅呢", "description": "著名工程学专家 625OutContradiction 设计了一张地铁交通网 $G$．$G$ 拥有 $n$ 个站点和 $m$ 条地铁线路．\n\n第 $i$ 条地铁线路 $P_i$ 会经过交通网上的若干站点，形如 $P_i=(u_1,u_2,u_3,...,u_{k_i})(k_i>0)$：每两个相邻站点 $u_j,u_{j+1}(j<k_i)$ 之间存在一段属于线路 $i$ 的从 $u_j$ 通向 $u_{j+1}$ 的单向地铁轨道．保证一条地铁线路不重复经过同一站点．但一个站点可能被若干条地铁线路经过．\n\n丹羽和艾莉欧准备从 $1$ 号站点前往 $n$ 号站点．然而他们的自行车坏掉了，只好准备乘坐地铁．现在他们需要决定出行的方案．\n\n一种出行方案具体是这样的：从 $1$ 号站点出发，选定一条经过 $1$ 号站点的地铁线路并开始乘坐地铁．沿当前地铁线路乘坐地铁的过程中，可以选择换乘其他任意一条经过当前站点的地铁线路．要求最终到达 $n$ 号站点．乘坐地铁过程中重复经过某一站点或某段地铁轨道是被允许的．\n\n**请注意：从 $1$ 号站点出发，第一次乘坐地铁不被算作换乘．**\n\n艾莉欧提出了 $q$ 个问题．对于每个问题，艾莉欧会提供三个参数 $a, b, c$．在这次问题中，一个出行方案如果经过了 $x$ 段地铁轨道并进行了 $y$ 次换乘，那么它的疲惫值为 $ax+by$．您需要回答换乘次数不超过 $c$ 的出行方案中最小的疲惫值是多少．", "inputFormat": "第一行三个整数 $n, m, q$．\n\n接下来 $m$ 行，第 $i$ 行形如：$k_i,u_1,u_2,u_3,...,u_{k_i}$．\n表示一条地铁线路．\n\n接下来 $q$ 行，每行三个整数，表示 $a,b,c$．", "outputFormat": "$q$ 行，对应每个问题的回答．", "hint": "### 样例 #1 说明\n$1\\rightarrow 2\\rightarrow 3\\rightarrow 4\\rightarrow 5$ 是给出的第一条地铁线路，$1\\rightarrow 3$，$2\\rightarrow 4\\rightarrow 5$ 是第二三条地铁线路．\n\n对于第一二组询问，均存在一种最优的出行方案为，在 $1$ 站点搭乘第二条地铁线路到达 $3$ 站点，在 $3$ 站点换乘第一条地铁线路到达终点；共经过 $3$ 段地铁轨道，并进行了 $1$ 次换乘，故第一二组询问的答案分别为 $3\\times 1+1\\times 1=4$，$3\\times 3+1\\times 0=9$．对于第三组询问，由于换乘的代价较大，最优的方案为顺着第一条地铁线路一直通向终点，途径 $4$ 段地铁轨道，答案为 $4$．\n\n### 数据点约束\n对于所有数据满足：\n\n$1\\le n \\le 10^5$，$1\\le m \\le 10^4$，$1\\le q \\le 10^5$，$\\sum k_i \\le 3\\times 10^5$．\n\n$0 \\le a,b \\le 10^6$，$0 \\le c \\le 20$．\n\n---\n对于 $10\\%$ 的数据满足：$n \\le 20$，$\\sum k_i \\le 40$，$q \\le 30$．\n\n---\n\n对于另外 $20\\%$ 的数据满足：$c=0$．\n\n---\n\n对于另外 $30\\%$ 的数据满足：$q=1$．\n\n---\n\n题目中可能存在只经过一个地铁站的地铁线路．这种线路可以直接忽视．数据保证：对于任意一组询问，存在一条合法的路线可以到达终点．", "locale": "zh-CN"}}}
