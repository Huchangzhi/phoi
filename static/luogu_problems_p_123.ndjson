{"pid": "P3491", "type": "P", "difficulty": 5, "samples": [["2\n2\n1 2\n2\n2 0\n", "TAK\nNIE\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "POI（波兰）", "枚举"], "title": "[POI 2009] SLW-Words", "background": "", "description": "Let $h$ be a function acting on strings composed of the digits 0 and 1. The function $h$ transforms the string $w$ by replacing (independently and concurrently) every digit 0 with 1 and every digit 1 with the string \"10\". For example $h(\"1001\") = \"101110\"$, $h(\"\") = \"\"$ (i.e. $h$ assigns an empty string to the empty string). Note that $h$ is an injection, or a one - to - one function. By $h^k$ we denote the function $h$ composed with itself $k$ times. In particular, $h^0$ is the identity function $h^0(w)=w$.\n\nWe are interested in the strings of the form $h^k(\"0\")$ for $k = 0,1,2,3,\\cdots$. This sequence begins with the following strings:\n\n\"0\", \"1\", \"10\", \"101\", \"10110\", \"10110101\".\n\nWe call the string $x$ a substring of the string $y$ if it occurs in $y$ as a contiguous (i.e. one - block) subsequence. A sequence of integers $k_1,k_2,\\cdots,k_n$ is given. Your task is to check whether a string of the form $h^{k_1}(\"0\") \\cdot h^{k_2}(\"0\") \\cdots h^{k_n}(\"0\")$ is a substring of $h^m(\"0\")$ for some $m$.", "inputFormat": "The first line of the standard input contains a single integer $t$, $1 \\leq t \\leq 13$, denoting the number of test units. The first line of each test unit's description contains one integer $n$, $1 \\leq n \\leq 100000$. The second line of each description holds $n$ non - negative integers $k_1,k_2,\\cdots,k_n$, separated by single spaces. The sum of the numbers in the second line of any test unit description does not exceed 10000000.", "outputFormat": "Your programme should print out $t$ lines to the standard output, one for each test unit. Each line corresponding to a test unit should contain one word: TAK (yes in Polish - if $h^{k_1}(\"0\") \\cdot h^{k_2}(\"0\") \\cdots h^{k_n}(\"0\")$ is a substring of $h^m(\"0\")$ for some $m$ in that test unit, or NIE (no in Polish) otherwise. ", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] SLW-Words", "background": "", "description": "Let $h$ be a function acting on strings composed of the digits 0 and 1. The function $h$ transforms the string $w$ by replacing (independently and concurrently) every digit 0 with 1 and every digit 1 with the string \"10\". For example $h(\"1001\") = \"101110\"$, $h(\"\") = \"\"$ (i.e. $h$ assigns an empty string to the empty string). Note that $h$ is an injection, or a one - to - one function. By $h^k$ we denote the function $h$ composed with itself $k$ times. In particular, $h^0$ is the identity function $h^0(w)=w$.\n\nWe are interested in the strings of the form $h^k(\"0\")$ for $k = 0,1,2,3,\\cdots$. This sequence begins with the following strings:\n\n\"0\", \"1\", \"10\", \"101\", \"10110\", \"10110101\".\n\nWe call the string $x$ a substring of the string $y$ if it occurs in $y$ as a contiguous (i.e. one - block) subsequence. A sequence of integers $k_1,k_2,\\cdots,k_n$ is given. Your task is to check whether a string of the form $h^{k_1}(\"0\") \\cdot h^{k_2}(\"0\") \\cdots h^{k_n}(\"0\")$ is a substring of $h^m(\"0\")$ for some $m$.", "inputFormat": "The first line of the standard input contains a single integer $t$, $1 \\leq t \\leq 13$, denoting the number of test units. The first line of each test unit's description contains one integer $n$, $1 \\leq n \\leq 100000$. The second line of each description holds $n$ non - negative integers $k_1,k_2,\\cdots,k_n$, separated by single spaces. The sum of the numbers in the second line of any test unit description does not exceed 10000000.", "outputFormat": "Your programme should print out $t$ lines to the standard output, one for each test unit. Each line corresponding to a test unit should contain one word: TAK (yes in Polish - if $h^{k_1}(\"0\") \\cdot h^{k_2}(\"0\") \\cdots h^{k_n}(\"0\")$ is a substring of $h^m(\"0\")$ for some $m$ in that test unit, or NIE (no in Polish) otherwise. ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] SLW-Words", "background": "", "description": "设 $h$ 是一个作用于由数字 0 和 1 组成的字符串的函数。函数 $h$ 将字符串 $w$ 转换为：独立且同时地将每个数字 0 替换为 1，并将每个数字 1 替换为字符串 \"10\"。例如，$h(\"1001\") = \"101110\"$，$h(\"\") = \"\"$（即 $h$ 将空字符串映射为空字符串）。注意，$h$ 是一个单射，即一对一的函数。$h^k$ 表示函数 $h$ 自身复合 $k$ 次。特别地，$h^0$ 是恒等函数 $h^0(w)=w$。\n\n我们对形如 $h^k(\"0\")$ 的字符串感兴趣，其中 $k = 0,1,2,3,\\cdots$。该序列以以下字符串开始：\n\n\"0\", \"1\", \"10\", \"101\", \"10110\", \"10110101\"。\n\n如果字符串 $x$ 作为一个连续（即单块）子序列出现在字符串 $y$ 中，我们称字符串 $x$ 是字符串 $y$ 的一个子串。给定一个整数序列 $k_1,k_2,\\cdots,k_n$。你的任务是检查形如 $h^{k_1}(\"0\") \\cdot h^{k_2}(\"0\") \\cdots h^{k_n}(\"0\")$ 的字符串是否是某个 $h^m(\"0\")$ 的子串。", "inputFormat": "标准输入的第一行包含一个整数 $t$，$1 \\leq t \\leq 13$，表示测试单元的数量。每个测试单元的描述的第一行包含一个整数 $n$，$1 \\leq n \\leq 100000$。每个描述的第二行包含 $n$ 个非负整数 $k_1,k_2,\\cdots,k_n$，以单个空格分隔。任何测试单元描述的第二行中的数字之和不超过 10000000。", "outputFormat": "你的程序应输出 $t$ 行到标准输出，每行对应一个测试单元。每个对应测试单元的行应包含一个单词：TAK（波兰语中的“是”——如果 $h^{k_1}(\"0\") \\cdot h^{k_2}(\"0\") \\cdots h^{k_n}(\"0\")$ 是某个 $h^m(\"0\")$ 的子串），否则为 NIE（波兰语中的“否”）。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3492", "type": "P", "difficulty": 4, "samples": [["2\n4 3\n1 2 3\n4 5 6\n7 8 9\n10 11 12\n11 10 12\n8 7 9\n5 4 6\n2 1 3\n2 2\n1 2\n3 4\n5 6\n7 8\n", "TAK\nNIE\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2009", "POI（波兰）"], "title": "[POI 2009] TAB-Arrays", "background": "", "description": "Consider an $n \\times m$ table filled with **distinct** integers. The following operations can be performed on the table:  \n\n1. Swapping two rows.  \n2. Swapping two columns.  \n\nWe say that two tables are **similar** if, by applying some sequence of the above operations to the first table, we can obtain the second table.  \n\nWrite a program that determines for a given set of table pairs which pairs contain similar tables.  ", "inputFormat": "The first line of standard input contains a single integer $t$ ($1 \\leq t \\leq 10$), representing the number of table pairs. The subsequent lines describe the table pairs.  \n\nEach table pair description starts with a line containing two integers $n$ and $m$ ($1 \\leq n, m \\leq 1000$), separated by a single space, representing the number of rows and columns of both tables.  \n\nThe next $n$ lines contain the description of the first table. The $i$-th of these lines contains $m$ integers $a_{ij}$ ($-10^6 \\leq a_{ij} \\leq 10^6$), separated by single spaces, representing the numbers in the $i$-th row of the first table.  \n\nThe next $n$ lines contain the description of the second table. The $i$-th of these lines contains $m$ integers $b_{ij}$ ($-10^6 \\leq b_{ij} \\leq 10^6$), separated by single spaces, representing the numbers in the $i$-th row of the second table.  \n\nAll numbers in a single table are distinct.  ", "outputFormat": "Your program should print $t$ lines to standard output. The $k$-th of these lines should contain the word **\"TAK\"** if the tables in the $k$-th input pair are similar, and **\"NIE\"** otherwise.  ", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] TAB-Arrays", "background": "", "description": "Consider an $n \\times m$ table filled with **distinct** integers. The following operations can be performed on the table:  \n\n1. Swapping two rows.  \n2. Swapping two columns.  \n\nWe say that two tables are **similar** if, by applying some sequence of the above operations to the first table, we can obtain the second table.  \n\nWrite a program that determines for a given set of table pairs which pairs contain similar tables.  ", "inputFormat": "The first line of standard input contains a single integer $t$ ($1 \\leq t \\leq 10$), representing the number of table pairs. The subsequent lines describe the table pairs.  \n\nEach table pair description starts with a line containing two integers $n$ and $m$ ($1 \\leq n, m \\leq 1000$), separated by a single space, representing the number of rows and columns of both tables.  \n\nThe next $n$ lines contain the description of the first table. The $i$-th of these lines contains $m$ integers $a_{ij}$ ($-10^6 \\leq a_{ij} \\leq 10^6$), separated by single spaces, representing the numbers in the $i$-th row of the first table.  \n\nThe next $n$ lines contain the description of the second table. The $i$-th of these lines contains $m$ integers $b_{ij}$ ($-10^6 \\leq b_{ij} \\leq 10^6$), separated by single spaces, representing the numbers in the $i$-th row of the second table.  \n\nAll numbers in a single table are distinct.  ", "outputFormat": "Your program should print $t$ lines to standard output. The $k$-th of these lines should contain the word **\"TAK\"** if the tables in the $k$-th input pair are similar, and **\"NIE\"** otherwise.  ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] TAB-Arrays", "background": "", "description": "考虑一个 $n \\times m$ 的表格，其中填充了**互不相同**的整数。可以对该表执行以下操作：  \n\n1. 交换两行。  \n2. 交换两列。  \n\n如果可以通过某种操作序列将第一张表转换为第二张表，我们就称这两张表是**相似的**。  \n\n请编写一个程序，对于给定的一组表格对，判断哪些表格对包含相似的表格。  ", "inputFormat": "标准输入的第一行包含一个整数 $t$（$1 \\leq t \\leq 10$），表示表格对的数量。接下来的行描述这些表格对。  \n\n每个表格对的描述从一行开始，该行包含两个整数 $n$ 和 $m$（$1 \\leq n, m \\leq 1000$），用单个空格分隔，表示两张表格的行数和列数。  \n\n接下来的 $n$ 行描述第一张表格。第 $i$ 行包含 $m$ 个整数 $a_{ij}$（$-10^6 \\leq a_{ij} \\leq 10^6$），用空格分隔，表示第一张表格第 $i$ 行的数字。  \n\n再接下来的 $n$ 行描述第二张表格。第 $i$ 行包含 $m$ 个整数 $b_{ij}$（$-10^6 \\leq b_{ij} \\leq 10^6$），用空格分隔，表示第二张表格第 $i$ 行的数字。  \n\n在同一张表格中，所有数字都互不相同。  ", "outputFormat": "程序应在标准输出打印 $t$ 行。对于第 $k$ 对输入表格，如果它们是相似的，则输出 **\"TAK\"**，否则输出 **\"NIE\"**。  \n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3493", "type": "P", "difficulty": 6, "samples": [["6 9\n-12 -10\n-11 6\n-4 12\n6 14\n16 6\n18 -2\n3 4\n1 5\n2 6\n2 3\n4 5\n3 5\n1 3\n3 6\n1 6\n", "42.0000000000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2009", "POI（波兰）", "Special Judge", "半平面交"], "title": "[POI 2009] WSP-Island", "background": "", "description": "Byteasar is the king of Byteotia, an island in The Ocean of Happiness.\n\nThe island is a convex shape, and all the towns of Byteotia are located on the shore.\n\nOne of these towns is Byteburg, the famous capital of Byteotia.\n\nEvery pair of towns is connected by a road that goes along the line segment between the towns.\n\nSome roads that connect different pairs of towns intersect - there is a crossroad at each such intersection.\n\nBitratio, Byteasar's rival to the throne, had hatched a sordid plot.\n\nWhile Byteasar was travelling from the capital to an adjacent town, Bitratio's people seized Byteburg.\n\nNow Byteasar has to return to Byteburg as soon as possible in order to restore his rule.\n\nUnfortunately, some of the roads are controlled by Bitratio's guerrilla.\n\nByteasar cannot risk the use of such roads, he can however cross them at the crossroads.\n\nNeedless to say, he has to travel along the roads and hence turn only at the crossroads, for otherwise the journey would take far too long.\n\nByteasar's loyal servants have informed him which roads are safe.\n\nByteasar believes your loyalty, and thus entrusts you with a task to find the shortest safe route from the town he is currently in to Byteburg.\n\nByteotia岛屿是一个凸多边形。城市全都在海岸上。按顺时针编号1到n。任意两个城市之间都有一条笔直的道路相连。道路相交处可以自由穿行。有一些道路被游击队控制了，不能走，但是可以经过这条道路与未被控制的道路的交点。问从城市1到n的最短距离。\n", "inputFormat": "In the first line of the standard input two integers ![](http://main.edu.pl/images/OI16/wsp-en-tex.1.png) and ![](http://main.edu.pl/images/OI16/wsp-en-tex.2.png) are given     (![](http://main.edu.pl/images/OI16/wsp-en-tex.3.png), ![](http://main.edu.pl/images/OI16/wsp-en-tex.4.png)),     separated by a single space,     that denote respectively: the number of towns and      the number of roads controlled by Bitratio's guerrilla.\n\nLet us number the towns from ![](http://main.edu.pl/images/OI16/wsp-en-tex.5.png) to ![](http://main.edu.pl/images/OI16/wsp-en-tex.6.png) starting from Byteburg      and moving clockwise along the shore.\n\nBytesar is currently in the town no. ![](http://main.edu.pl/images/OI16/wsp-en-tex.7.png).\n\nEach of the following ![](http://main.edu.pl/images/OI16/wsp-en-tex.8.png) lines holds a pair of integers ![](http://main.edu.pl/images/OI16/wsp-en-tex.9.png) and ![](http://main.edu.pl/images/OI16/wsp-en-tex.10.png)      (![](http://main.edu.pl/images/O…\n", "outputFormat": "Your programme is to print out one floating point number     to the standard output:\n\nthe length of the shortest safe route leading from the town no. ![](http://main.edu.pl/images/OI16/wsp-en-tex.19.png)     to Byteburg.\n\nThe absolute difference between the number returned and the correct one  has to be at most ![](http://main.edu.pl/images/OI16/wsp-en-tex.20.png).\n", "hint": "spj-", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2009] WSP-Island", "background": "# Description\n\nByteasar is the king of Byteotia, an island in the Ocean of Happiness. The island is convex, and all the towns of Byteotia are located on the shore. One of these towns is Byteburg, the capital of Byteotia.\n\nEvery pair of towns is connected by a straight road that follows the line segment between the towns. If two such roads intersect, there is a crossroad at the intersection, and one may freely pass through it.\n\nSome roads are controlled by Bitratio’s guerrilla. Byteasar cannot travel along such roads, but he may cross them at crossroads. He must travel only along roads and may turn only at towns or crossroads.\n\nThe towns are numbered from $1$ to $n$ starting from Byteburg and moving clockwise along the shore. Byteasar is currently in town $s$. Find the length of the shortest safe route from town $s$ to Byteburg (town $1$).", "description": "Byteasar is the king of Byteotia, an island in the Ocean of Happiness. The island is convex, and all the towns of Byteotia are located on the shore. One of these towns is Byteburg, the capital of Byteotia.\n\nEvery pair of towns is connected by a straight road that follows the line segment between the towns. If two such roads intersect, there is a crossroad at the intersection, and one may freely pass through it.\n\nSome roads are controlled by Bitratio’s guerrilla. Byteasar cannot travel along such roads, but he may cross them at crossroads. He must travel only along roads and may turn only at towns or crossroads.\n\nThe towns are numbered from $1$ to $n$ starting from Byteburg and moving clockwise along the shore. Byteasar is currently in town $s$. Find the length of the shortest safe route from town $s$ to Byteburg (town $1$).\n\n# Description", "inputFormat": "- The first line contains two integers $n$ and $m$ — the number of towns and the number of roads controlled by the guerrilla.\n- The second line contains one integer $s$ — the index of the town where Byteasar is currently located.\n- Each of the next $m$ lines contains two integers $a_i$ and $b_i$ ($1 \\le a_i < b_i \\le n$), denoting a road between towns $a_i$ and $b_i$ that is controlled and thus cannot be used for travel (but may be crossed at crossroads).", "outputFormat": "Print a single floating-point number: the length of the shortest safe route from town $s$ to Byteburg (town $1$). The absolute error of your answer must be at most $10^{-4}$.", "hint": "Special judge.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2009] WSP-Island", "background": "", "description": "Byteasar is the king of Byteotia, an island in The Ocean of Happiness.\n\nThe island is a convex shape, and all the towns of Byteotia are located on the shore.\n\nOne of these towns is Byteburg, the famous capital of Byteotia.\n\nEvery pair of towns is connected by a road that goes along the line segment between the towns.\n\nSome roads that connect different pairs of towns intersect - there is a crossroad at each such intersection.\n\nBitratio, Byteasar's rival to the throne, had hatched a sordid plot.\n\nWhile Byteasar was travelling from the capital to an adjacent town, Bitratio's people seized Byteburg.\n\nNow Byteasar has to return to Byteburg as soon as possible in order to restore his rule.\n\nUnfortunately, some of the roads are controlled by Bitratio's guerrilla.\n\nByteasar cannot risk the use of such roads, he can however cross them at the crossroads.\n\nNeedless to say, he has to travel along the roads and hence turn only at the crossroads, for otherwise the journey would take far too long.\n\nByteasar's loyal servants have informed him which roads are safe.\n\nByteasar believes your loyalty, and thus entrusts you with a task to find the shortest safe route from the town he is currently in to Byteburg.\n\nByteotia岛屿是一个凸多边形。城市全都在海岸上。按顺时针编号1到n。任意两个城市之间都有一条笔直的道路相连。道路相交处可以自由穿行。有一些道路被游击队控制了，不能走，但是可以经过这条道路与未被控制的道路的交点。问从城市1到n的最短距离。\n", "inputFormat": "In the first line of the standard input two integers ![](http://main.edu.pl/images/OI16/wsp-en-tex.1.png) and ![](http://main.edu.pl/images/OI16/wsp-en-tex.2.png) are given     (![](http://main.edu.pl/images/OI16/wsp-en-tex.3.png), ![](http://main.edu.pl/images/OI16/wsp-en-tex.4.png)),     separated by a single space,     that denote respectively: the number of towns and      the number of roads controlled by Bitratio's guerrilla.\n\nLet us number the towns from ![](http://main.edu.pl/images/OI16/wsp-en-tex.5.png) to ![](http://main.edu.pl/images/OI16/wsp-en-tex.6.png) starting from Byteburg      and moving clockwise along the shore.\n\nBytesar is currently in the town no. ![](http://main.edu.pl/images/OI16/wsp-en-tex.7.png).\n\nEach of the following ![](http://main.edu.pl/images/OI16/wsp-en-tex.8.png) lines holds a pair of integers ![](http://main.edu.pl/images/OI16/wsp-en-tex.9.png) and ![](http://main.edu.pl/images/OI16/wsp-en-tex.10.png)      (![](http://main.edu.pl/images/O…\n", "outputFormat": "Your programme is to print out one floating point number     to the standard output:\n\nthe length of the shortest safe route leading from the town no. ![](http://main.edu.pl/images/OI16/wsp-en-tex.19.png)     to Byteburg.\n\nThe absolute difference between the number returned and the correct one  has to be at most ![](http://main.edu.pl/images/OI16/wsp-en-tex.20.png).\n", "hint": "spj-", "locale": "zh-CN"}}}
{"pid": "P3494", "type": "P", "difficulty": 6, "samples": [["21\n11XB0XBB00XB11XB0XBBB\n", "2\n4\n5\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "POI（波兰）", "深度优先搜索 DFS", "字典树 Trie"], "title": "[POI 2009] KOD-The Code", "background": "", "description": "The Byteotian Institute of Telecommunication (BIT) sets standards for data transmission in telecommunication networks all over Byteotia.\n\nByteasar, one of the engineers employed at BIT, works on prefix codes - a certain way of representing characters.\n\nFor each and every character of the Byteotian alphabet there is a corresponding sequence of bits, called the code word of that character.\n\nThe code words of all characters have the following properties:\n\nNone of the code words is a prefix (i.e. a leading       fragment) of another code word.\n\nFor example, if 010010 is the code word of the letter   A, then neither the bit sequence 0,   01, 010,  0100 nor 01001   is a code word of another letter.\n\nLikewise, 0100100, 0100101 and longer   sequences starting with 010010 are not code words.\n\nIf a given bit sequence ![](http://main.edu.pl/images/OI16/kod-en-tex.1.png) is a prefix of another code word,       but not the complete code, then each of the bit sequences       ![](http://main.edu.pl/images/OI16/kod-en-tex.2.png) and ![](http://main.edu.pl/images/OI16/kod-en-tex.3.png) (that is, ![](http://main.edu.pl/images/OI16/kod-en-tex.4.png) with zero or one       appended at the end) is a prefix of some code word, or the       complete code word.\n\nFor example, if 0100 is the prefix of the code word of the       letter A, then 01000 and 01001 each       is a prefix of some code word, or a complete code word.\n\nLet us consider the following exemplary prefix code for the alphabet consisting of the characters    A, B, C, D and E:\n\ncharactercode word    A00    B10    C11    D010    E011         Encoding a sequence of characters with a prefix code consists in concatenating the code words of its successive characters.\n\nFor example, the encoding of the sequence BACAEBABAE is 1000110001110001000011.\n\nByteasar noticed that if some leading bits are lost, the sequence may be decoded wrong, or it may even be not decoded at all.\n\nFor example, if five initial bits of the sequence given above are removed, the resulting sequence 10001110001000011 will be decoded as BACBABAE.\n\nThe last five letter (BABAE) are correct, but the first three (BAC) are not.\n\nByteasar further noticed that all the letters after the first E are decoded correct.\n\nHe concluded that whenever all the bits of the code word of E are intact, all the characters succeeding E will be decoded correct.\n\nThe same holds for every encoded sequence obtained from one that contains E.\n\nHe also noticed that the letter D shares this feature, but A, B and C do not.\n\nBecause of the properties of the code words of E and D Byteasar called them synchronising code words.\n\nHe trusted you with the task of writing a programme that finds all the synchronising code words of a given prefix code.\n\nTo save some time, he intends to present you all the code words on his binary monitor.\n\nThis interesting device has four buttons:\n\n0 - append ![](http://main.edu.pl/im…\n", "inputFormat": "In the first line of the standard input there is an integer ![](http://main.edu.pl/images/OI16/kod-en-tex.7.png)      (![](http://main.edu.pl/images/OI16/kod-en-tex.8.png)) denoting the number of buttons pressed      by Byteasar.\n\nIn the following line an ![](http://main.edu.pl/images/OI16/kod-en-tex.9.png) letters long string consisting of the      characters '0', '1', 'B' and      'X' is given; the characters correspond to the buttons,      of course.\n\nEach time the button X is pressed, a code word is      completed and another one starts.\n\nThe code words are numbered starting with 1.\n\nThe sum of lengths of all code words will not exceed ![](http://main.edu.pl/images/OI16/kod-en-tex.10.png).\n", "outputFormat": "The number ![](http://main.edu.pl/images/OI16/kod-en-tex.11.png) of synchronising code words should be printed out in the     first line of the standard output.\n\nThe following ![](http://main.edu.pl/images/OI16/kod-en-tex.12.png) lines should contain the numbers of code words that  are synchronising in increasing order, each in a separate line.\n\nIf the given prefix code contains no synchronising code words, the first  line should contain the number 0, and no more lines should follow.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] KOD-The Code", "background": "", "description": "The Byteotian Institute of Telecommunication (BIT) sets standards for data transmission in telecommunication networks all over Byteotia.\n\nByteasar, one of the engineers employed at BIT, works on prefix codes - a certain way of representing characters.\n\nFor each and every character of the Byteotian alphabet there is a corresponding sequence of bits, called the code word of that character.\n\nThe code words of all characters have the following properties:\n\nNone of the code words is a prefix (i.e. a leading       fragment) of another code word.\n\nFor example, if 010010 is the code word of the letter   A, then neither the bit sequence 0,   01, 010,  0100 nor 01001   is a code word of another letter.\n\nLikewise, 0100100, 0100101 and longer   sequences starting with 010010 are not code words.\n\nIf a given bit sequence ![](http://main.edu.pl/images/OI16/kod-en-tex.1.png) is a prefix of another code word,       but not the complete code, then each of the bit sequences       ![](http://main.edu.pl/images/OI16/kod-en-tex.2.png) and ![](http://main.edu.pl/images/OI16/kod-en-tex.3.png) (that is, ![](http://main.edu.pl/images/OI16/kod-en-tex.4.png) with zero or one       appended at the end) is a prefix of some code word, or the       complete code word.\n\nFor example, if 0100 is the prefix of the code word of the       letter A, then 01000 and 01001 each       is a prefix of some code word, or a complete code word.\n\nLet us consider the following exemplary prefix code for the alphabet consisting of the characters    A, B, C, D and E:\n\ncharactercode word    A00    B10    C11    D010    E011         Encoding a sequence of characters with a prefix code consists in concatenating the code words of its successive characters.\n\nFor example, the encoding of the sequence BACAEBABAE is 1000110001110001000011.\n\nByteasar noticed that if some leading bits are lost, the sequence may be decoded wrong, or it may even be not decoded at all.\n\nFor example, if five initial bits of the sequence given above are removed, the resulting sequence 10001110001000011 will be decoded as BACBABAE.\n\nThe last five letter (BABAE) are correct, but the first three (BAC) are not.\n\nByteasar further noticed that all the letters after the first E are decoded correct.\n\nHe concluded that whenever all the bits of the code word of E are intact, all the characters succeeding E will be decoded correct.\n\nThe same holds for every encoded sequence obtained from one that contains E.\n\nHe also noticed that the letter D shares this feature, but A, B and C do not.\n\nBecause of the properties of the code words of E and D Byteasar called them synchronising code words.\n\nHe trusted you with the task of writing a programme that finds all the synchronising code words of a given prefix code.\n\nTo save some time, he intends to present you all the code words on his binary monitor.\n\nThis interesting device has four buttons:\n\n0 - append ![](http://main.edu.pl/im…\n", "inputFormat": "In the first line of the standard input there is an integer ![](http://main.edu.pl/images/OI16/kod-en-tex.7.png)      (![](http://main.edu.pl/images/OI16/kod-en-tex.8.png)) denoting the number of buttons pressed      by Byteasar.\n\nIn the following line an ![](http://main.edu.pl/images/OI16/kod-en-tex.9.png) letters long string consisting of the      characters '0', '1', 'B' and      'X' is given; the characters correspond to the buttons,      of course.\n\nEach time the button X is pressed, a code word is      completed and another one starts.\n\nThe code words are numbered starting with 1.\n\nThe sum of lengths of all code words will not exceed ![](http://main.edu.pl/images/OI16/kod-en-tex.10.png).\n", "outputFormat": "The number ![](http://main.edu.pl/images/OI16/kod-en-tex.11.png) of synchronising code words should be printed out in the     first line of the standard output.\n\nThe following ![](http://main.edu.pl/images/OI16/kod-en-tex.12.png) lines should contain the numbers of code words that  are synchronising in increasing order, each in a separate line.\n\nIf the given prefix code contains no synchronising code words, the first  line should contain the number 0, and no more lines should follow.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] KOD-The Code", "background": "", "description": "## 题面翻译", "inputFormat": "定义对一个 $01$ 串进行解码的过程是，每次找到一个前缀，满足它对应一个字符，容易知道这样的前缀是唯一的。将这个字符加入答案，将这个前缀从原串中删掉，如果不存在这样的前缀，则解码的结果是未定义。记 $s$ 解码的结果是 $\\mathrm{decode}(s)$。\n\n设一个字符编码为 $a$，定义它是好的，当且仅当对于任意两个串 $s,t$，对于 $\\mathrm{encode}(s)$ 的任意后缀 $p$，有 $\\mathrm{decode}(p+a)$ 不是未定义，且 $\\mathrm{decode}(p+a+\\mathrm{encode}(t))=\\mathrm{decode}(p+a)+t$。求哪些字符是好的。\n\n\n第一行一个数 $n$，表示操作次数。接下来一行一个长 $n$ 的字符串，其中 `0`/`1` 表示在当前结点添加一个儿子，边权为 `0`/`1`，并移动过去；`B`表示添加一个父亲；`X`表示当前结点是一个字符的编码。保证输入是描述这棵 trie 的最短的可能输入。$n\\leq 3\\times 10^6$ ，所有字符编码的总长 $\\leq 10^8$ 。", "outputFormat": "一行一个数，表示好的字符的数量。\n\n接下来若干行，从小到大输出每个好的字符是第几个`X`生成的。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3496", "type": "P", "difficulty": 4, "samples": [["7 8\n1 2\n3 4\n5 4\n6 4\n7 4\n5 6\n5 7\n6 7", "TAK\nK\nS\nK\nS\nK\nK\nN"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "贪心", "2010", "POI（波兰）", "Special Judge", "广度优先搜索 BFS", "深度优先搜索 DFS"], "title": "[POI 2010] GIL-Guilds", "background": null, "description": "国王 Byteasar 面临一个严峻的问题。\n\n两个相互竞争的贸易组织——裁缝行会（The Tailors Guild）和缝纫行会（The Sewers Guild）同时要求获得许可，在王国每个城镇设立办事处。\n\nByteotia 有 $n$ 个城镇。\n\n其中一些城镇通过双向道路连接。\n\n每个行会都要求：\n\n- 每个城镇必须设有本行会的办事处\n\n- 或者该城镇必须直接连接到一个设有本行会办事处的城镇。\n\n然而，国王怀疑其中有诈。他担心如果存在某个城镇同时设有两个行会的办事处，可能会导致服装垄断。\n\n因此，他请求你的帮助。", "inputFormat": "标准输入的第一行包含两个整数 $n$ ($n \\leq 200000$) 和 $m$ ($m \\leq 500000$)，分别表示 Byteotia 的城镇数量和道路数量。\n\n城镇编号为 $1$ 到 $n$。\n\n接下来 $m$ 行描述道路：输入的第 $i+1$ 行描述第 $i$ 条道路；", "outputFormat": "你的程序应在标准输出的第一行输出一个单词：\n\n- `TAK`（波兰语中的\"是\"）——表示可以按照规则在城镇中设置办事处，或者\n\n- `NIE`（波兰语中的\"否\"）——表示无法满足条件。\n\n如果答案是 `TAK`，则接下来的 $n$ 行应给出一种可行的办事处设置方案。因此第 $i+1$ 行应包含：\n\n- 字母 `K` —— 表示城镇 $i$ 应设有裁缝行会（The Tailors Guild）的办事处，或\n\n- 字母 `S` —— 表示城镇 $i$ 应设有缝纫行会（The Sewers Guild）的办事处，或\n\n- 字母 `N` —— 表示城镇 $i$ 不应设有任何行会的办事处。", "hint": "题目spj贡献者@mengbierr\n\n翻译：DeepSeek-R1", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2010] GIL-Guilds", "background": null, "description": "King Byteasar faces a serious matter.\n\nTwo competing trade organisations, The Tailors Guild and The Sewers Guild asked, at the same time, for permissions to open their offices in each town of the kingdom.\n\nThere are towns in Byteotia.\n\nSome of them are connected with bidirectional roads.\n\nEach of the guilds postulate that every town should:\n\nhave an office of the guild, or be directly connected to another town that does.\n\nThe king, however, suspects foul play. He fears that if there is just a single town holding the offices of both guilds, it could lead to a clothing cartel.\n\nFor this reason he asks your help.", "inputFormat": "Two integers, n(<=200000) and m(<=500000), are given in the first line of the standard input. These denote the number of towns and roads in Byteotia, respectively.\n\nThe towns are numbered from 1 to n.\n\nThen the roads are given as follows: the input line no. i+1 describes the i-th road;", "outputFormat": "Your program should print out one word in the first line of the standard output:\n\nTAK (yes in Polish) - if the offices can be placed in towns according to these rules, or NIE (no in Polish) - in the opposite case.\n\nIf the answers is TAK, then the following n lines should give an exemplary placement of the offices. Thus the line No.i+1 $%$s$%$h$%$o$%$u$%$l$%$d$%$ hold :\n\nthe letter K if there should be an office of The Tailors Guild in the town i, or the letter S if there should be an office of The Sewers Guild in the town i, or the letter N if there should be no office in the town i.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[POI 2010] GIL-Guilds", "background": null, "description": "国王 Byteasar 面临一个严峻的问题。\n\n两个相互竞争的贸易组织——裁缝行会（The Tailors Guild）和缝纫行会（The Sewers Guild）同时要求获得许可，在王国每个城镇设立办事处。\n\nByteotia 有 $n$ 个城镇。\n\n其中一些城镇通过双向道路连接。\n\n每个行会都要求：\n\n- 每个城镇必须设有本行会的办事处\n\n- 或者该城镇必须直接连接到一个设有本行会办事处的城镇。\n\n然而，国王怀疑其中有诈。他担心如果存在某个城镇同时设有两个行会的办事处，可能会导致服装垄断。\n\n因此，他请求你的帮助。", "inputFormat": "标准输入的第一行包含两个整数 $n$ ($n \\leq 200000$) 和 $m$ ($m \\leq 500000$)，分别表示 Byteotia 的城镇数量和道路数量。\n\n城镇编号为 $1$ 到 $n$。\n\n接下来 $m$ 行描述道路：输入的第 $i+1$ 行描述第 $i$ 条道路；", "outputFormat": "你的程序应在标准输出的第一行输出一个单词：\n\n- `TAK`（波兰语中的\"是\"）——表示可以按照规则在城镇中设置办事处，或者\n\n- `NIE`（波兰语中的\"否\"）——表示无法满足条件。\n\n如果答案是 `TAK`，则接下来的 $n$ 行应给出一种可行的办事处设置方案。因此第 $i+1$ 行应包含：\n\n- 字母 `K` —— 表示城镇 $i$ 应设有裁缝行会（The Tailors Guild）的办事处，或\n\n- 字母 `S` —— 表示城镇 $i$ 应设有缝纫行会（The Sewers Guild）的办事处，或\n\n- 字母 `N` —— 表示城镇 $i$ 不应设有任何行会的办事处。", "hint": "题目spj贡献者@mengbierr\n\n翻译：DeepSeek-R1", "locale": "zh-CN"}}}
{"pid": "P3497", "type": "P", "difficulty": 6, "samples": [["4\n1 3 4 2", "TAK\n1 1 2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "线段树", "POI（波兰）", "Special Judge"], "title": "[POI 2010] KOL-Railway", "background": "", "description": "**译自 POI 2010 Stage 1.「[Kolej](https://szkopul.edu.pl/problemset/problem/TJVrS_hRC8W5Q6ZBW6mETAIm/site/?key=statement)」**\n\n一个铁路包含两个侧线 $1$ 和 $2$ ，左边由 $A$ 进入，右边由 $B$ 出去（如下图所示）。  \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bdq72qy0.png)\n\n有 $n$ 个车厢在通道 $A$ 上，编号为 $1$ 到 $n$ ，它们按照 $a_1,a_2,\\cdots ,a_n$ 的顺序进入侧线，想要按照 $1,2,\\cdots ,n$ 的顺序从通道 $B$ 出去。    \n他们可以从 $A$ 到 $1$ 或 $2$ ，然后经过一系列转移从 $B$ 出去（不用考虑容量问题）。求是否能够做到，如果可以，请找出一种方案。", "inputFormat": "第一行一个正整数 $n$ 。  \n第二行 $n$ 个空格隔开的正整数 $a_1,a_2,\\cdots a_n$ 。", "outputFormat": "第一行一个字符串，如果能够做到，输出 ```TAK``` ，否则输出 ```NIE``` 。  \n若能做到，第二行 $n$ 个空格隔开的正整数，表示每个车厢进入的侧线编号。  \n如果有多解，输出任意一种。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2448)。", "hint": "对于 $100\\%$ 的数据，有 $n \\le 1 \\times 10^5$。\n\nTranslated by Diamond_duke，来源 LOJ。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2010] KOL-Railway", "background": "", "description": "A railroad siding consists of two (dead-end) sidetracks 1 and 2.\n\nThe siding is entered by track A, and left by track B (see figure below).\n\nThere are ![](http://main.edu.pl/images/OI17/kol-en-tex.1.png) cars on track A, numbered from ![](http://main.edu.pl/images/OI17/kol-en-tex.2.png) to ![](http://main.edu.pl/images/OI17/kol-en-tex.3.png).\n\nThey are arranged in such a way that they enter the siding in the order    ![](http://main.edu.pl/images/OI17/kol-en-tex.4.png).\n\nThe cars are to be transferred to the siding, so that they leave it by track B    in the order ![](http://main.edu.pl/images/OI17/kol-en-tex.5.png).\n\nEach car is to be transferred once from track A to one of the sidetracks 1 or 2,    and later (possibly after some transfers of the remaining cars) once from that    sidetrack to the track B.\n\nThe sidetracks are long enough to store even the longest trains, so there is    no need to worry about their capacity.", "inputFormat": "The first line of the standard input holds one integer ![](http://main.edu.pl/images/OI17/kol-en-tex.6.png) (![](http://main.edu.pl/images/OI17/kol-en-tex.7.png))      that denotes the number of cars for transfer.\n\nThe second line stores the numbers ![](http://main.edu.pl/images/OI17/kol-en-tex.8.png) that are a permutation of ![](http://main.edu.pl/images/OI17/kol-en-tex.9.png)      (i.e., each ![](http://main.edu.pl/images/OI17/kol-en-tex.10.png) belongs to ![](http://main.edu.pl/images/OI17/kol-en-tex.11.png), and all these numbers are unique),      separated by single spaces.\n", "outputFormat": "The first line of the standard output should contain the word TAK      (yes in Polish) if there is a way of transferring the cars so that they      enter track B in the order ![](http://main.edu.pl/images/OI17/kol-en-tex.12.png), or the word NIE      (no in Polish) if it is impossible.\n\nIf the answer is TAK, the second line should give, separated by      single spaces, the numbers of sidetracks (1 or 2) to which successive cars      ![](http://main.edu.pl/images/OI17/kol-en-tex.13.png) are moved in a correct transfer.\n\nIf there are several ways of making the transfer, choose one arbitrarily.\n", "hint": "对于 $100\\%$ 的数据，有 $n \\le 1 \\times 10^5$。", "locale": "en"}, "zh-CN": {"title": "[POI 2010] KOL-Railway", "background": "", "description": "**译自 POI 2010 Stage 1.「[Kolej](https://szkopul.edu.pl/problemset/problem/TJVrS_hRC8W5Q6ZBW6mETAIm/site/?key=statement)」**\n\n一个铁路包含两个侧线 $1$ 和 $2$ ，左边由 $A$ 进入，右边由 $B$ 出去（如下图所示）。  \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bdq72qy0.png)\n\n有 $n$ 个车厢在通道 $A$ 上，编号为 $1$ 到 $n$ ，它们按照 $a_1,a_2,\\cdots ,a_n$ 的顺序进入侧线，想要按照 $1,2,\\cdots ,n$ 的顺序从通道 $B$ 出去。    \n他们可以从 $A$ 到 $1$ 或 $2$ ，然后经过一系列转移从 $B$ 出去（不用考虑容量问题）。求是否能够做到，如果可以，请找出一种方案。", "inputFormat": "第一行一个正整数 $n$ 。  \n第二行 $n$ 个空格隔开的正整数 $a_1,a_2,\\cdots a_n$ 。", "outputFormat": "第一行一个字符串，如果能够做到，输出 ```TAK``` ，否则输出 ```NIE``` 。  \n若能做到，第二行 $n$ 个空格隔开的正整数，表示每个车厢进入的侧线编号。  \n如果有多解，输出任意一种。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2448)。", "hint": "对于 $100\\%$ 的数据，有 $n \\le 1 \\times 10^5$。\n\nTranslated by Diamond_duke，来源 LOJ。", "locale": "zh-CN"}}}
{"pid": "P3498", "type": "P", "difficulty": 5, "samples": [["21\n1 1 1 2 2 2 3 3 3 1 2 3 3 1 2 2 1 3 3 2 1", "6 1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "POI（波兰）", "Special Judge", "枚举", "哈希 hashing"], "title": "[POI 2010] KOR-Beads", "background": "", "description": "Byteasar once decided to start manufacturing necklaces.\n\nHe subsequently bought a very long string of colourful coral beads for a bargain price.\n\nByteasar now also has a machine that, for a given ![](http://main.edu.pl/images/OI17/kor-en-tex.1.png) (![](http://main.edu.pl/images/OI17/kor-en-tex.2.png)), can cut the string    into pieces (or substrings) of ![](http://main.edu.pl/images/OI17/kor-en-tex.3.png) coral beads (i.e., the first piece consists of the beads no.\n\n![](http://main.edu.pl/images/OI17/kor-en-tex.4.png), the second of ![](http://main.edu.pl/images/OI17/kor-en-tex.5.png), etc.).\n\nIf the length of the string (measured in coral beads) is not a multiple of ![](http://main.edu.pl/images/OI17/kor-en-tex.6.png),    then the last piece is not used, as it has length smaller than ![](http://main.edu.pl/images/OI17/kor-en-tex.7.png).\n\nFrom now on we denote the colours of the beads with positive integers.\n\nByteasar, always praising diversity, wonders how he should choose the number ![](http://main.edu.pl/images/OI17/kor-en-tex.8.png)    in order to get as many different substrings as possible.\n\nThe ends of the long string that will be cut are different: there are specific    beginning and ending (rather than two interchangeable endpoints), and the machine    of course starts cutting at the beginning. On the other hand, in the substrings    obtained from cutting the endpoints are interchangeable, and so the substrings    can be reversed. In other words, the substrings ![](http://main.edu.pl/images/OI17/kor-en-tex.9.png) and ![](http://main.edu.pl/images/OI17/kor-en-tex.10.png) are    identical to us. Write a program that determines the optimum value of ![](http://main.edu.pl/images/OI17/kor-en-tex.11.png) for Byteasar.", "inputFormat": "In the first line of the standard input there is an integer ![](http://main.edu.pl/images/OI17/kor-en-tex.37.png)      (![](http://main.edu.pl/images/OI17/kor-en-tex.38.png)) denoting the length of the string to cut.\n\nIn the second line there are ![](http://main.edu.pl/images/OI17/kor-en-tex.39.png) positive integers ![](http://main.edu.pl/images/OI17/kor-en-tex.40.png)      (![](http://main.edu.pl/images/OI17/kor-en-tex.41.png)), separated by single spaces, that denote      the colours of successive beads in Byteasar's string.\n", "outputFormat": "Two integers, separated by a single space, should be printed out to the first line of the standard ouput:\n\nthe (maximum) number of different substrings that can be obtained with an optimal choice    of parameter ![](http://main.edu.pl/images/OI17/kor-en-tex.42.png), and the number ![](http://main.edu.pl/images/OI17/kor-en-tex.43.png) of such optimal values of ![](http://main.edu.pl/images/OI17/kor-en-tex.44.png).\n\nThe second line should contain ![](http://main.edu.pl/images/OI17/kor-en-tex.45.png) integers separated by single spaces:\n\nthe values of parameter ![](http://main.edu.pl/images/OI17/kor-en-tex.46.png) that yield an optimum solution;    these can be given in arbitrary order.\n\n输出两行，第一行第一个数为最多可以得到的不同子串的个数，第二个数为取到最优解时的不同的k的个数。第二行包含若干个数，为取到最优解时的不同的k 。第二行中的不同的k可以按任意位置输出。\n", "hint": "$1≤n≤2\\times 10^5$，且 $\\forall 1\\le i\\le n$，有 $1\\le a_i\\le n$", "locale": "en", "translations": {"en": {"title": "[POI 2010] KOR-Beads", "background": "", "description": "Byteasar once decided to start manufacturing necklaces.\n\nHe subsequently bought a very long string of colourful coral beads for a bargain price.\n\nByteasar now also has a machine that, for a given ![](http://main.edu.pl/images/OI17/kor-en-tex.1.png) (![](http://main.edu.pl/images/OI17/kor-en-tex.2.png)), can cut the string    into pieces (or substrings) of ![](http://main.edu.pl/images/OI17/kor-en-tex.3.png) coral beads (i.e., the first piece consists of the beads no.\n\n![](http://main.edu.pl/images/OI17/kor-en-tex.4.png), the second of ![](http://main.edu.pl/images/OI17/kor-en-tex.5.png), etc.).\n\nIf the length of the string (measured in coral beads) is not a multiple of ![](http://main.edu.pl/images/OI17/kor-en-tex.6.png),    then the last piece is not used, as it has length smaller than ![](http://main.edu.pl/images/OI17/kor-en-tex.7.png).\n\nFrom now on we denote the colours of the beads with positive integers.\n\nByteasar, always praising diversity, wonders how he should choose the number ![](http://main.edu.pl/images/OI17/kor-en-tex.8.png)    in order to get as many different substrings as possible.\n\nThe ends of the long string that will be cut are different: there are specific    beginning and ending (rather than two interchangeable endpoints), and the machine    of course starts cutting at the beginning. On the other hand, in the substrings    obtained from cutting the endpoints are interchangeable, and so the substrings    can be reversed. In other words, the substrings ![](http://main.edu.pl/images/OI17/kor-en-tex.9.png) and ![](http://main.edu.pl/images/OI17/kor-en-tex.10.png) are    identical to us. Write a program that determines the optimum value of ![](http://main.edu.pl/images/OI17/kor-en-tex.11.png) for Byteasar.", "inputFormat": "In the first line of the standard input there is an integer ![](http://main.edu.pl/images/OI17/kor-en-tex.37.png)      (![](http://main.edu.pl/images/OI17/kor-en-tex.38.png)) denoting the length of the string to cut.\n\nIn the second line there are ![](http://main.edu.pl/images/OI17/kor-en-tex.39.png) positive integers ![](http://main.edu.pl/images/OI17/kor-en-tex.40.png)      (![](http://main.edu.pl/images/OI17/kor-en-tex.41.png)), separated by single spaces, that denote      the colours of successive beads in Byteasar's string.\n", "outputFormat": "Two integers, separated by a single space, should be printed out to the first line of the standard ouput:\n\nthe (maximum) number of different substrings that can be obtained with an optimal choice    of parameter ![](http://main.edu.pl/images/OI17/kor-en-tex.42.png), and the number ![](http://main.edu.pl/images/OI17/kor-en-tex.43.png) of such optimal values of ![](http://main.edu.pl/images/OI17/kor-en-tex.44.png).\n\nThe second line should contain ![](http://main.edu.pl/images/OI17/kor-en-tex.45.png) integers separated by single spaces:\n\nthe values of parameter ![](http://main.edu.pl/images/OI17/kor-en-tex.46.png) that yield an optimum solution;    these can be given in arbitrary order.\n\n输出两行，第一行第一个数为最多可以得到的不同子串的个数，第二个数为取到最优解时的不同的k的个数。第二行包含若干个数，为取到最优解时的不同的k 。第二行中的不同的k可以按任意位置输出。\n", "hint": "$1≤n≤2\\times 10^5$，且 $\\forall 1\\le i\\le n$，有 $1\\le a_i\\le n$", "locale": "en"}, "zh-CN": {"title": "[POI 2010] KOR-Beads", "background": "", "description": "Byteasar 有 $n$ 个珠子，第 $i$ 个颜色为 $a_i$，和一台机器。\n\nByteasar 可以选定一个值 $k$，然后机器会让 $1\\sim k$ 的珠子组成项链 $b_1$，$k+1\\sim 2k$ 的珠子组成项链 $b_2$，以此类推，**最后 $n\\bmod k$ 个珠子不会组成项链，而是被丢弃**。\n\n现在让你求出一个 $k$ 值，使得在 $\\left\\lfloor\\dfrac{n}{k}\\right\\rfloor$ 个项链 $b$ 中，存在 **不同的** 项链数量最多。\n\n项链可以反转，形式化地，$b_x$ 和 $b_y$ 不同，当且仅当存在至少一个 $i$，使得 $b_{x,i}\\ne b_{y,i}$ 且 $b_{x,i} \\ne b_{y,k-i+1}$。\n\n例如 $[1,2,3]$ 和 $[3,2,1]$ 是相同的，而 $[1,2,3]$ 和 $[2,3,1]$ 是不同的。", "inputFormat": "输入两行，第一行为 $n$。\n\n第二行为 $n$ 个正整数，第 $i$ 个正整数代表 $a_i$。", "outputFormat": "输出两行。\n\n第一行两个整数，分别代表不同的项链最多的数量，以及不同的项链最多时，$k$ 的个数。\n\n第二行若干个整数，代表所有能使不同的项链最多的 $k$ 值，这可以按任意顺序输出。\n\n### 【样例解释】\n\n$a$ 为 $[1,1,1,2,2,2,3,3,3,1,2,3,3,1,2,2,1,3,3,2,1]$。\n\n- $k=1$ 的时候，我们得到 $3$ 个不同的项链 $b$：$[1],[2],[3]$。\n- $k=2$ 的时候，我们得到 $6$ 个不同的项链：$[1,1],[1,2],[2,2],[2,3],[3,3],[3,1]$。\n- $k=3$ 的时候，我们得到 $5$ 个不同的项链：$[1,1,1],[2,2,2],[3,3,3],[1,2,3],[3,1,2]$。\n- $k=4$ 的时候，我们得到 $5$ 个不同的项链：$[1,1,1,2],[2,2,3,3],[3,1,2,3],[3,1,2,2],[1,3,3,2]$。", "hint": "对于全部数据，$1\\le n\\le2\\times 10^5$，且 $\\forall 1\\le i\\le n$，有 $1\\le a_i\\le n$。", "locale": "zh-CN"}}}
{"pid": "P3499", "type": "P", "difficulty": 6, "samples": [["3\n4 3 4", "4\n1"], ["1\n6", "1\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2010", "POI（波兰）", "素数判断,质数,筛法"], "title": "[POI 2010] NAJ-Divine Divisor", "background": "POI 2010 Round I - [Divine Divisor](https://szkopul.edu.pl/problemset/problem/hOwg83Xw_OnTpfQ9SroS0OJA/site/?key=statement).", "description": "给出一个 $n$，请你找出最大的 $k$，使得存在 $d>1$，满足 $d^k\\mid n$。\n\n在此基础上，求出满足该条件的 $d$ 有多少个。", "inputFormat": "第一行一个正整数 $m$ 。  \n第二行 $m$ 个空格隔开的正整数 $a_1,a_2,\\cdots ,a_m$ ，则 $n=\\prod_{i=1}^ma_i$ 。", "outputFormat": "第一行一个正整数，表示最大的 $k$ 。  \n第二行也是一个正整数，表示满足 $d>1$ 且 $d^k\\mid n$ 的 $d$ 有多少个。\n", "hint": "对于$100\\%$的数据，$1\\le m\\le 600$，且 $\\forall 1\\le i\\le m$，有 $1\\le a_i\\le 10^{18}$。\n\n如果你输出的第一行或者第二行完全正确，可以获得 $50\\%$ 的分数。\n\n---\n\n作者：Jakub Radoszewski\n\nTranslated By diamond_duke，来自 [LOJ](https://loj.ac/p/2428)。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2010] Divine Divisor", "background": "Source: POI 2010 Round I - [Divine Divisor](https://szkopul.edu.pl/problemset/problem/hOwg83Xw_OnTpfQ9SroS0OJA/site/?key=statement).", "description": "\nAn integer $N > 1$ is given. We say that an integer $d > 1$ is a divisor of $N$ with multiplicity $k > 0$ ($k$ is integer) if $d^k \\mid N$ and $d^{k+1}$ does not divide $N$. For example, the number $N = 18 = 16 \\cdot 3$ has the following divisors: 2 with multiplicity 4, 3 with multiplicity 1, 4 with multiplicity 2, 6 with multiplicity 1, and so on.\n\nWe say that a number $d$ is a *divine divisor* of the number $N$ if $d$ is a divisor of $N$ with multiplicity $k$ and $N$ has no divisors with multiplicities greater than $k$. For example, the sole divine divisor of 48 is 2 (with multiplicity 4), and the divine divisors of 6 are: 2, 3 and 6 (each with multiplicity 1).\n\nYour task is to determine the multiplicity of divine divisors of $N$ and the number of its divine divisors.\n\n### Input\n\n### Output\n### Example\nFor the input data:\n```\n3\n4 3 4\n```\nthe correct result is:\n```\n4\n1\n```\nwhereas for the input:\n```\n1\n6\n```\nthe correct result is:\n```\n1\n3\n```\n\n### Grading\nShould your program print out the correct multiplicity $k$ of a divine divisor of $N$, but fail to print in the second line the correct number $D$ of divine divisors of $N$ (or fail to print that number at all), it will be awarded 50% of the score for that particular test, scaled accordingly if it exceeds half the time limit.\n\n", "inputFormat": "\nThe number $N$ is given on the standard input, though in a somewhat unusual way. The first line holds a single integer $n$ ($1 \\le n \\le 600$). The second line holds $n$ integers $a_i$ ($2 \\le a_i \\le 10^{18}$) separated by single spaces. These denote that $N = a_1 \\cdot a_2 \\cdot \\dots \\cdot a_n$.", "outputFormat": "\nThe first line of the standard output should hold the maximum integer $k$ such that there exists a divisor $d$ of $N$ such that $d^k \\mid N$. The second line should hold a single integer $D$ that is the number of (divine) divisors of $N$ with multiplicity $k$.\n", "hint": "\nShould your program print out the correct multiplicity $k$ of a divine divisor of $N$, but fail to print in the second line the correct number $D$ of divine divisors of $N$ (or fail to print that number at all), it will be awarded 50% of the score for that particular test.\n\nTask author: Jakub Radoszewski.", "locale": "en"}, "zh-CN": {"title": "[POI 2010] NAJ-Divine Divisor", "background": "POI 2010 Round I - [Divine Divisor](https://szkopul.edu.pl/problemset/problem/hOwg83Xw_OnTpfQ9SroS0OJA/site/?key=statement).", "description": "给出一个 $n$，请你找出最大的 $k$，使得存在 $d>1$，满足 $d^k\\mid n$。\n\n在此基础上，求出满足该条件的 $d$ 有多少个。", "inputFormat": "第一行一个正整数 $m$ 。  \n第二行 $m$ 个空格隔开的正整数 $a_1,a_2,\\cdots ,a_m$ ，则 $n=\\prod_{i=1}^ma_i$ 。", "outputFormat": "第一行一个正整数，表示最大的 $k$ 。  \n第二行也是一个正整数，表示满足 $d>1$ 且 $d^k\\mid n$ 的 $d$ 有多少个。\n", "hint": "对于$100\\%$的数据，$1\\le m\\le 600$，且 $\\forall 1\\le i\\le m$，有 $1\\le a_i\\le 10^{18}$。\n\n如果你输出的第一行或者第二行完全正确，可以获得 $50\\%$ 的分数。\n\n---\n\n作者：Jakub Radoszewski\n\nTranslated By diamond_duke，来自 [LOJ](https://loj.ac/p/2428)。", "locale": "zh-CN"}}}
{"pid": "P3500", "type": "P", "difficulty": 3, "samples": [["7\n1 5 4 5 7 8 6\n4\n5\n1 5 5 8 6\n3\n2 2 2\n3\n5 7 8\n4\n1 5 7 4", "TAK\nNIE\nTAK\nNIE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["模拟", "2010", "二分", "POI（波兰）"], "title": "[POI 2010] TES-Intelligence Test", "background": "", "description": "One of the tasks in the Byteotian Intelligence Test (BIT) is to cross out    numbers from an initial sequence in such a way that leaves as a result    certain given sequences.\n\nByteasar longs to become the IQ Master of Byteotia, but he is no good in    this kind of tasks.\n\nBut since practice makes perfect, he intends to practise a lot.\n\nSo much in fact that he asks you to write a program that will facilitate    the training by verifying his answers quickly.", "inputFormat": "The first line of the standard input contains one integer $m$ ($1\\le m\\le 1\\ 000\\ 000$).\n\nThe second line holds $m$ integers $a_1,a_2,\\cdots,a_m$ ($1\\le a_i\\le 1\\ 000\\ 000$ for $1\\le i\\le m$), separated by single spaces,      that constitute the initial sequence of the test.\n\nThe third line of the input holds one integer $n$.\n\nThe following $2n$ lines describe the sequences to be obtained by crossing out      numbers from the initial sequence.\n\nEach sequence's description takes two successive lines.\n\nThe first of these two lines contains an integer $m_i$ ($1\\le m_i\\le 1\\ 000\\ 000$).\n\nThe second contains an $m_i$-element long sequence of integers $b_{i,1},b_{i,2},\\cdots,b_{i,m_i}$($1\\le b_{i,j}\\le 1\\ 000\\ 000$ for $1\\le j\\le m_i$)separated by single spaces. You may assume that the total length on given $n$ sequences does not exceed $1\\ 000\\ 000$.", "outputFormat": "Your program should print out $n$ lines to the standard output.\n\nThe $i$-th line (for $1\\le i\\le n$) should hold one word,      \"TAK\" (yes in Polish) if the $i$-th input sequence can be obtained by      crossing out (i.e., removing) some, not necessarily contiguous, numbers from the initial sequence,      or \"NIE\" (no in Polish) otherwise. Mind you, only the words should be printed,      no quotation marks. Of course, the order of the numbers left after crossing out is important,      as can be seen in the example.", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2010] TES-Intelligence Test", "background": "", "description": "One of the tasks in the Byteotian Intelligence Test (BIT) is to cross out    numbers from an initial sequence in such a way that leaves as a result    certain given sequences.\n\nByteasar longs to become the IQ Master of Byteotia, but he is no good in    this kind of tasks.\n\nBut since practice makes perfect, he intends to practise a lot.\n\nSo much in fact that he asks you to write a program that will facilitate    the training by verifying his answers quickly.", "inputFormat": "The first line of the standard input contains one integer $m$ ($1\\le m\\le 1\\ 000\\ 000$).\n\nThe second line holds $m$ integers $a_1,a_2,\\cdots,a_m$ ($1\\le a_i\\le 1\\ 000\\ 000$ for $1\\le i\\le m$), separated by single spaces,      that constitute the initial sequence of the test.\n\nThe third line of the input holds one integer $n$.\n\nThe following $2n$ lines describe the sequences to be obtained by crossing out      numbers from the initial sequence.\n\nEach sequence's description takes two successive lines.\n\nThe first of these two lines contains an integer $m_i$ ($1\\le m_i\\le 1\\ 000\\ 000$).\n\nThe second contains an $m_i$-element long sequence of integers $b_{i,1},b_{i,2},\\cdots,b_{i,m_i}$($1\\le b_{i,j}\\le 1\\ 000\\ 000$ for $1\\le j\\le m_i$)separated by single spaces. You may assume that the total length on given $n$ sequences does not exceed $1\\ 000\\ 000$.", "outputFormat": "Your program should print out $n$ lines to the standard output.\n\nThe $i$-th line (for $1\\le i\\le n$) should hold one word,      \"TAK\" (yes in Polish) if the $i$-th input sequence can be obtained by      crossing out (i.e., removing) some, not necessarily contiguous, numbers from the initial sequence,      or \"NIE\" (no in Polish) otherwise. Mind you, only the words should be printed,      no quotation marks. Of course, the order of the numbers left after crossing out is important,      as can be seen in the example.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2010] TES-Intelligence Test", "background": "", "description": "**译自 POI 2010 Stage 1.「[Intelligence Test](https://szkopul.edu.pl/problemset/problem/Arkza0f7GKKb-m1YZJulnlMk/site/?key=statement)」**\n\n给出一个母串 $a_1,a_2,a_3,\\cdots ,a_n$ ，若干次询问，每次询问给出一个子串 $b_1,b_2,\\cdots b_m$ ，请你求出这个子串是不是母串的子序列。", "inputFormat": "第一行一个正整数 $n$ 。  \n第二行 $n$ 个空格隔开的正整数 $a_1,a_2,\\cdots ,a_n$ ，表示母串。  \n第三行一个正整数 $q$ ，表示询问次数。  \n接下来 $2 \\times q$ 行，每两行表示一次询问，其中的第一行是一个正整数 $m$ ，第二行是 $m$ 个空格隔开的正整数表示 $b_1,b_2,\\cdots ,b_m$ ，表示询问的子串。", "outputFormat": "输出共 $q$ 行，每行一个字符串。  \n若第 $i$ 次询问的串是母串的子序列，那么第 $i$ 行应为 ```TAK``` ，否则应为 ```NIE``` 。\n\n对于 $100\\%$ 的数据，有 $1\\le n,m,a_i,b_i\\le 1\\ 000\\ 000$ ，且 $\\sum m\\le 1\\ 000\\ 000$ ，这里 $\\sum m$ 表示 $q$ 组询问的 $m$ 之和。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2429)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3501", "type": "P", "difficulty": 5, "samples": [["8\n11001011", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "二分", "POI（波兰）", "哈希 hashing", "Manacher 算法"], "title": "[POI 2010] ANT-Antisymmetry", "background": "", "description": "Byteasar studies certain strings of zeroes and ones.\n\nLet ![](http://main.edu.pl/images/OI17/ant-en-tex.1.png) be such a string. By ![](http://main.edu.pl/images/OI17/ant-en-tex.2.png) we will denote the reversed (i.e., \"read backwards\") string ![](http://main.edu.pl/images/OI17/ant-en-tex.3.png),    and by ![](http://main.edu.pl/images/OI17/ant-en-tex.4.png) we will denote the string obtained from ![](http://main.edu.pl/images/OI17/ant-en-tex.5.png) by changing all the zeroes to ones and ones to zeroes.\n\nByteasar is interested in antisymmetry, while all things symmetric bore him.\n\nAntisymmetry however is not a mere lack of symmetry.\n\nWe will say that a (nonempty) string ![](http://main.edu.pl/images/OI17/ant-en-tex.6.png) is antisymmetric if, for every position ![](http://main.edu.pl/images/OI17/ant-en-tex.7.png) in ![](http://main.edu.pl/images/OI17/ant-en-tex.8.png),    the ![](http://main.edu.pl/images/OI17/ant-en-tex.9.png)-th last character is different than the ![](http://main.edu.pl/images/OI17/ant-en-tex.10.png)-th (first) character.\n\nIn particular, a string ![](http://main.edu.pl/images/OI17/ant-en-tex.11.png) consisting of zeroes and ones is antisymmetric if and only if    ![](http://main.edu.pl/images/OI17/ant-en-tex.12.png).\n\nFor example, the strings 00001111 and 010101 are antisymmetric, while 1001 is not.\n\nIn a given string consisting of zeroes and ones we would like to determine the number of contiguous    nonempty antisymmetric fragments.\n\nDifferent fragments corresponding to the same substrings should be counted multiple times.", "inputFormat": "The first line of the standard input contains an integer ![](http://main.edu.pl/images/OI17/ant-en-tex.13.png) (![](http://main.edu.pl/images/OI17/ant-en-tex.14.png)) that denotes the length of the string.\n\nThe second line gives a string of 0 and/or 1 of length ![](http://main.edu.pl/images/OI17/ant-en-tex.15.png).\n\nThere are no spaces in the string.\n", "outputFormat": "The first and only line of the standard output should contain a single integer,      namely the number of contiguous (non empty) fragments of the given string      that are antisymmetric.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2010] ANT-Antisymmetry", "background": "", "description": "Byteasar studies certain strings of zeroes and ones.\n\nLet ![](http://main.edu.pl/images/OI17/ant-en-tex.1.png) be such a string. By ![](http://main.edu.pl/images/OI17/ant-en-tex.2.png) we will denote the reversed (i.e., \"read backwards\") string ![](http://main.edu.pl/images/OI17/ant-en-tex.3.png),    and by ![](http://main.edu.pl/images/OI17/ant-en-tex.4.png) we will denote the string obtained from ![](http://main.edu.pl/images/OI17/ant-en-tex.5.png) by changing all the zeroes to ones and ones to zeroes.\n\nByteasar is interested in antisymmetry, while all things symmetric bore him.\n\nAntisymmetry however is not a mere lack of symmetry.\n\nWe will say that a (nonempty) string ![](http://main.edu.pl/images/OI17/ant-en-tex.6.png) is antisymmetric if, for every position ![](http://main.edu.pl/images/OI17/ant-en-tex.7.png) in ![](http://main.edu.pl/images/OI17/ant-en-tex.8.png),    the ![](http://main.edu.pl/images/OI17/ant-en-tex.9.png)-th last character is different than the ![](http://main.edu.pl/images/OI17/ant-en-tex.10.png)-th (first) character.\n\nIn particular, a string ![](http://main.edu.pl/images/OI17/ant-en-tex.11.png) consisting of zeroes and ones is antisymmetric if and only if    ![](http://main.edu.pl/images/OI17/ant-en-tex.12.png).\n\nFor example, the strings 00001111 and 010101 are antisymmetric, while 1001 is not.\n\nIn a given string consisting of zeroes and ones we would like to determine the number of contiguous    nonempty antisymmetric fragments.\n\nDifferent fragments corresponding to the same substrings should be counted multiple times.", "inputFormat": "The first line of the standard input contains an integer ![](http://main.edu.pl/images/OI17/ant-en-tex.13.png) (![](http://main.edu.pl/images/OI17/ant-en-tex.14.png)) that denotes the length of the string.\n\nThe second line gives a string of 0 and/or 1 of length ![](http://main.edu.pl/images/OI17/ant-en-tex.15.png).\n\nThere are no spaces in the string.\n", "outputFormat": "The first and only line of the standard output should contain a single integer,      namely the number of contiguous (non empty) fragments of the given string      that are antisymmetric.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2010] ANT-Antisymmetry", "background": "", "description": "**译自 POI 2010 Stage 2. Day 0「[Antisymmetry](https://szkopul.edu.pl/problemset/problem/EDxOyJiFZWb_PYVaYhhnhU0-/site/?key=statement)」**\n\n对于一个 $0/1$ 字符串，如果将这个字符串 $0$ 和 $1$ 取反后，再将整个串反过来和原串一样，就称作「反对称」字符串。比如 $00001111$ 和 $010101$ 就是反对称的，而 $1001$ 就不是。  \n现在给出一个长度为 $n$ 的 $0/1$ 字符串，求它有多少个子串是反对称的，注意这里相同的子串出现在不同的位置会被重复计算。", "inputFormat": "第一行一个正整数 $n$ 。  \n第二行一个长度为 $n$ 的 $0/1$ 字符串。", "outputFormat": "一行一个整数，表示原串的反对称子串个数。", "hint": "样例的 $7$ 个反对称子串分别是：$01$（出现两次），$10$（出现两次），$0101$，$1100$ 和 $001011$。\n\n对于 $100\\%$ 的数据， $1\\le n\\le 500\\ 000$ 。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2452)。", "locale": "zh-CN"}}}
{"pid": "P3502", "type": "P", "difficulty": 6, "samples": [["4 5\nmonika\ntomek\nszymon\nbernard", "23"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2010", "POI（波兰）", "矩阵加速", "AC 自动机"], "title": "[POI 2010] CHO-Hamsters", "background": "", "description": "Byteasar breeds hamsters.\n\nEach hamster has a unique name,    consisting of lower case letters of the English alphabet.\n\n    The hamsters have a vast and comfortable cage.\n\n    Byteasar intends to place a display under the cage to visualize the names of his hamsters.\n\n    This display is simply a sequence of letters, each of which can be either lit or not independently.\n\nOnly one name will be displayed simultaneously.\n\nThe lit letters forming the name have to stand next to each other,    i.e., form a contiguous subsequence.\n\nByteasar wants to be able to display the names of the hamsters on at least ![](http://main.edu.pl/images/OI17/cho-en-tex.1.png) different positions.\n\nHowever, he allows displaying the same name on multiple different positions,    and does not require to be able to display each and every hamster's name.\n\nNote that the occurrences of the names on the display can overlap.\n\nYou can assume that no hamster's name occurs (as a contiguous fragment) in any other hamster's name.\n\nBytesar asks your help in determining the minimum number of letters the display has to have.\n\nIn other words, you are to determine the minimum length of a string    (consisting of non-capital letters of the English alphabet)    that has at least ![](http://main.edu.pl/images/OI17/cho-en-tex.2.png) total occurrences of the hamsters' names (counting multiplicities).\n\n(We say that a string ![](http://main.edu.pl/images/OI17/cho-en-tex.3.png) occurs in the string ![](http://main.edu.pl/images/OI17/cho-en-tex.4.png) if ![](http://main.edu.pl/images/OI17/cho-en-tex.5.png) forms a contiguous fragment of ![](http://main.edu.pl/images/OI17/cho-en-tex.6.png).)\n\n", "inputFormat": "The first line of the standard input holds two integers ![](http://main.edu.pl/images/OI17/cho-en-tex.7.png) and ![](http://main.edu.pl/images/OI17/cho-en-tex.8.png)      (![](http://main.edu.pl/images/OI17/cho-en-tex.9.png), ![](http://main.edu.pl/images/OI17/cho-en-tex.10.png)), separated by a single space, that denote      the number of Byteasar's hamsters and the minimum number of occurrences of the hamsters' names on the display.\n\nEach of the following ![](http://main.edu.pl/images/OI17/cho-en-tex.11.png) lines contains a non-empty string of non-capital letters of the English alphabet      that is the hamster's name.\n\nThe total length of all names does not exceed ![](http://main.edu.pl/images/OI17/cho-en-tex.12.png) letters.\n", "outputFormat": "The first and only line of the standard output should hold a single integer      - the minimum number of letters the display has to have.\n", "hint": "$1\\le n\\le 200$，$1\\le m\\le 10^9$ ，所有字符串的总长 $\\le 10^5$。\n", "locale": "en", "translations": {"en": {"title": "[POI 2010] CHO-Hamsters", "background": "", "description": "Byteasar breeds hamsters.\n\nEach hamster has a unique name,    consisting of lower case letters of the English alphabet.\n\n    The hamsters have a vast and comfortable cage.\n\n    Byteasar intends to place a display under the cage to visualize the names of his hamsters.\n\n    This display is simply a sequence of letters, each of which can be either lit or not independently.\n\nOnly one name will be displayed simultaneously.\n\nThe lit letters forming the name have to stand next to each other,    i.e., form a contiguous subsequence.\n\nByteasar wants to be able to display the names of the hamsters on at least ![](http://main.edu.pl/images/OI17/cho-en-tex.1.png) different positions.\n\nHowever, he allows displaying the same name on multiple different positions,    and does not require to be able to display each and every hamster's name.\n\nNote that the occurrences of the names on the display can overlap.\n\nYou can assume that no hamster's name occurs (as a contiguous fragment) in any other hamster's name.\n\nBytesar asks your help in determining the minimum number of letters the display has to have.\n\nIn other words, you are to determine the minimum length of a string    (consisting of non-capital letters of the English alphabet)    that has at least ![](http://main.edu.pl/images/OI17/cho-en-tex.2.png) total occurrences of the hamsters' names (counting multiplicities).\n\n(We say that a string ![](http://main.edu.pl/images/OI17/cho-en-tex.3.png) occurs in the string ![](http://main.edu.pl/images/OI17/cho-en-tex.4.png) if ![](http://main.edu.pl/images/OI17/cho-en-tex.5.png) forms a contiguous fragment of ![](http://main.edu.pl/images/OI17/cho-en-tex.6.png).)\n\n", "inputFormat": "The first line of the standard input holds two integers ![](http://main.edu.pl/images/OI17/cho-en-tex.7.png) and ![](http://main.edu.pl/images/OI17/cho-en-tex.8.png)      (![](http://main.edu.pl/images/OI17/cho-en-tex.9.png), ![](http://main.edu.pl/images/OI17/cho-en-tex.10.png)), separated by a single space, that denote      the number of Byteasar's hamsters and the minimum number of occurrences of the hamsters' names on the display.\n\nEach of the following ![](http://main.edu.pl/images/OI17/cho-en-tex.11.png) lines contains a non-empty string of non-capital letters of the English alphabet      that is the hamster's name.\n\nThe total length of all names does not exceed ![](http://main.edu.pl/images/OI17/cho-en-tex.12.png) letters.\n", "outputFormat": "The first and only line of the standard output should hold a single integer      - the minimum number of letters the display has to have.\n", "hint": "$1\\le n\\le 200$，$1\\le m\\le 10^9$ ，所有字符串的总长 $\\le 10^5$。\n", "locale": "en"}, "zh-CN": {"title": "[POI 2010] CHO-Hamsters", "background": "", "description": "Byteasar 养了许多仓鼠。\n\n每只仓鼠都有一个唯一的名字，由小写英文字母组成。\n\n这些仓鼠有一个宽敞舒适的笼子。\n\nByteasar 打算在笼子下方放置一个显示器，以可视化显示他仓鼠的名字。\n\n这个显示器只是一个字母序列，每个字母可以独立地亮起或不亮起。\n\n同时只会显示一个名字。\n\n亮起的字母必须相邻，即形成一个连续的子序列。\n\nByteasar 希望能够在至少 $m$ 个不同的位置显示这些仓鼠的名字。\n\n然而，他允许在多个不同的位置显示相同的名字，并且不要求能够显示每一个仓鼠的名字。\n\n注意，名字在显示器上的出现可以重叠。\n\n可以假设没有任何仓鼠的名字会作为连续片段出现在其他仓鼠的名字中。\n\nByteasar 请求你帮助确定显示器需要的最小字母数。\n\n换句话说，你需要确定一个字符串的最小长度（由非大写英文字母组成），使得仓鼠名字的总出现次数（计入重复）至少为 $m$。\n\n（我们说字符串 $A$ 出现在字符串 $B$ 中，如果 $A$ 形成 $B$ 的一个连续片段。）", "inputFormat": "标准输入的第一行包含两个整数 $n$ 和 $m$ ($1 \\le n \\le 200$, $1 \\le m \\le 10^9$)，用一个空格分隔，表示 Byteasar 的仓鼠数量和显示器上仓鼠名字出现的最小次数。\n\n接下来的 $n$ 行中的每一行包含一个非空的非大写英文字母字符串，表示仓鼠的名字。\n\n所有名字的总长度不超过 $10^5$ 个字母。", "outputFormat": "标准输出的第一行应包含一个整数——显示器需要的最小字母数。", "hint": "$1 \\le n \\le 200$，$1 \\le m \\le 10^9$，所有字符串的总长 $\\le 10^5$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3503", "type": "P", "difficulty": 5, "samples": [["5 6\n1 2 1 1 5\n1 2 3 4 5 6", "5 5 2 1 1 0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "二分", "POI（波兰）", "前缀和", "双指针 two-pointer", "单调栈"], "title": "[POI 2010] KLO-Blocks", "background": null, "description": "Bytie has got a set of wooden blocks for his birthday.\n\nThe blocks are indistinguishable from one another, as they are all cubes of the same size.\n\n    Bytie forms piles by putting one block atop another.\n\nSoon he had a whole rank of such piles, one next to another in a straight line.\n\nOf course, the piles can have different heights.\n\nBytie's father, Byteasar, gave his son a puzzle.\n\nHe gave him a number ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.1.png)  and asked to rearrange the blocks in such a way that    the number of successive piles of height at least ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.1.png)  is maximised.\n\nHowever, Bytie is only ever allowed to pick the top block from a pile strictly    higher than ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.1.png)  and place it atop one of the piles next to it.\n\nFurther, Bytie is not allowed to form new piles, he can only move blocks    between those already existing.", "inputFormat": "In the first line of the standard input there are two integers separated by a single space:\n\n![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.4.png)  (![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.5.png)),  denoting the number of piles, and ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.6.png)  (![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.7.png)),       denoting the number of Byteasar's requests.\n\nThe piles are numbered from ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.8.png)  to ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.9.png). \n\nIn the second line there are ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.10.png)  integers ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.11.png)       separated by single spaces (![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.12.png)). \n\nThe number ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.13.png)  denotes the height of the ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.13.png)-th  pile.\n\nThe third line holds ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.15.png)  integers ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.16.png)  separated by single spaces (![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.17.png)).  These are the subsequent values of the parameter ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.18.png)  for which the puzzle is to be solved. That is, the largest number of successive piles of height at least ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.18.png)  that can be obtained by allowed moves is to be determined for each given value of the parameter ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.18.png).", "outputFormat": "Your program should print out ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.21.png)  integers, separated by single spaces,      to the standard output - the ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.22.png)-th  of which should be the answer to the puzzle      for the given initial piles set-up and the parameter ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.23.png).", "hint": "$1\\le n\\le 10^6$，$1\\le m\\le 50$，$1\\le a_i,k\\le 10^9$", "locale": "en", "translations": {"en": {"title": "[POI 2010] KLO-Blocks", "background": null, "description": "Bytie has got a set of wooden blocks for his birthday.\n\nThe blocks are indistinguishable from one another, as they are all cubes of the same size.\n\n    Bytie forms piles by putting one block atop another.\n\nSoon he had a whole rank of such piles, one next to another in a straight line.\n\nOf course, the piles can have different heights.\n\nBytie's father, Byteasar, gave his son a puzzle.\n\nHe gave him a number ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.1.png)  and asked to rearrange the blocks in such a way that    the number of successive piles of height at least ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.1.png)  is maximised.\n\nHowever, Bytie is only ever allowed to pick the top block from a pile strictly    higher than ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.1.png)  and place it atop one of the piles next to it.\n\nFurther, Bytie is not allowed to form new piles, he can only move blocks    between those already existing.", "inputFormat": "In the first line of the standard input there are two integers separated by a single space:\n\n![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.4.png)  (![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.5.png)),  denoting the number of piles, and ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.6.png)  (![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.7.png)),       denoting the number of Byteasar's requests.\n\nThe piles are numbered from ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.8.png)  to ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.9.png). \n\nIn the second line there are ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.10.png)  integers ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.11.png)       separated by single spaces (![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.12.png)). \n\nThe number ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.13.png)  denotes the height of the ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.13.png)-th  pile.\n\nThe third line holds ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.15.png)  integers ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.16.png)  separated by single spaces (![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.17.png)).  These are the subsequent values of the parameter ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.18.png)  for which the puzzle is to be solved. That is, the largest number of successive piles of height at least ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.18.png)  that can be obtained by allowed moves is to be determined for each given value of the parameter ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.18.png).", "outputFormat": "Your program should print out ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.21.png)  integers, separated by single spaces,      to the standard output - the ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.22.png)-th  of which should be the answer to the puzzle      for the given initial piles set-up and the parameter ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.23.png).", "hint": "$1\\le n\\le 10^6$，$1\\le m\\le 50$，$1\\le a_i,k\\le 10^9$", "locale": "en"}, "zh-CN": {"title": "[POI 2010] KLO-Blocks", "background": "", "description": "Bytie 在生日时收到了一套木块。这些木块彼此无法区分，因为它们都是相同大小的立方体。Bytie 通过将一个木块放在另一个木块上形成了堆。不久，他就有了一整排这样的堆，一个接一个地排成一条直线。当然，这些堆的高度可以不同。Bytie 的父亲 Byteasar 给了他一个谜题。他给了他一个数字 $k$，并要求重新排列这些木块，使得高度至少为 $k$ 的连续堆的数量最大化。然而，Bytie 只能从严格高于 $k$ 的堆中取出顶部的木块，并将其放在相邻的堆上。此外，Bytie 不允许形成新的堆，他只能在已经存在的堆之间移动木块。", "inputFormat": "标准输入的第一行有两个用空格分隔的整数：$n$ ($1 \\le n \\le 10^6$)，表示堆的数量，以及 $m$ ($1 \\le m \\le 50$)，表示 Byteasar 的请求数量。堆从 $1$ 编号到 $n$。第二行有 $n$ 个整数 $a_i$，用空格分隔 ($1 \\le a_i \\le 10^9$)。数字 $a_i$ 表示第 $i$ 个堆的高度。第三行有 $m$ 个整数 $k_j$，用空格分隔 ($1 \\le k_j \\le 10^9$)，表示每个请求的参数 $k_j$。", "outputFormat": "你的程序应输出 $m$ 个整数，用空格分隔，其中第 $j$ 个整数是给定初始堆设置和参数 $k_j$ 的谜题答案。", "hint": "$1 \\le n \\le 10^6$，$1 \\le m \\le 50$，$1 \\le a_i, k \\le 10^9$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3504", "type": "P", "difficulty": 6, "samples": [["5 4 10\n5 5\n3 0\n-1 -1\n-3 4\n1 10\n1 0\n-1 0\n1 6\n-2 5", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2010", "POI（波兰）"], "title": "[POI 2010] OWC-Sheep", "background": "", "description": "The habitants of the Byteotian Highland bred sheep for centuries.\n\nEvery sane shepherd has a fenced pasture in the shape of a convex1 polygon    for the sheep to graze on.\n\nEvery sane sheep in turn has its own favourite feeding spot on the pasture where it spends all days.\n\nSometimes however, the sheep want to play. As they play in pairs, every shepherd keeps an even number of sheep,    so that his every sheep has a partner to play with.\n\nThe shepherds are concerned about a decree recently issued by the Byteburg's High Commissioner for Agriculture.\n\nThe decree states that as of the next year the sheep can only graze on triangle-shaped pastures.\n\nThus every shepherd whose pasture is an ![](http://main.edu.pl/images/OI17/owc-en-tex.1.png)-gon for ![](http://main.edu.pl/images/OI17/owc-en-tex.2.png) is to partition it into triangles by putting ![](http://main.edu.pl/images/OI17/owc-en-tex.3.png)    fences inside.\n\nEach single new fence, of course, is going to be a segment connecting two vertices of the polygon (pasture).\n\nAdditionally, the fences can intersect only in these vertices.\n\nA shepherd who does not fulfil these requirements will no longer be subsidized.\n\nByteasar, as a shepherd, has to decide on a way of partitioning his pasture.\n\nIn fact, he is unsure how many partitions are possible. He is only interested in such partitions    that no fence is drawn through a favourite spot of any sheep, and such that every resulting triangle    contains the favourite spots of an even number of sheep, so that these sheep can play in pairs.\n\nHelp Byteasar by writing a program that calculates the number of such partitions!\n", "inputFormat": "The first line of the standard input contains three integers ![](http://main.edu.pl/images/OI17/owc-en-tex.4.png), ![](http://main.edu.pl/images/OI17/owc-en-tex.5.png) and ![](http://main.edu.pl/images/OI17/owc-en-tex.6.png)    (![](http://main.edu.pl/images/OI17/owc-en-tex.7.png), ![](http://main.edu.pl/images/OI17/owc-en-tex.8.png), ![](http://main.edu.pl/images/OI17/owc-en-tex.9.png), ![](http://main.edu.pl/images/OI17/owc-en-tex.10.png)),    separated by single spaces, that denote respectively:\n\nthe number of vertices of the polygon forming the pasture,    the number of the sheep, and a certain positive integer ![](http://main.edu.pl/images/OI17/owc-en-tex.11.png).\n\nEach of the following ![](http://main.edu.pl/images/OI17/owc-en-tex.12.png) lines contains two integers ![](http://main.edu.pl/images/OI17/owc-en-tex.13.png) and ![](http://main.edu.pl/images/OI17/owc-en-tex.14.png)    (![](http://main.edu.pl/images/OI17/owc-en-tex.15.png)), separated by a single space,    de…\n", "outputFormat": "Your program should print one integer on the standard output,    namely the remainder of division by ![](http://main.edu.pl/images/OI17/owc-en-tex.22.png) of the number of partitions of the pasture in triangles,    such that no fence is drawn through a favourite spot of any sheep, and every resulting triangle    contains the favourite spots of an even number of sheep.\n", "hint": "$4\\le n\\le 600$，$2\\le k$，$m\\le 20\\ 000$，$2\\mid k$，$-15\\ 000\\le x_i,y_i,p_i,q_i\\le 15\\ 000$ ，牧场的顶点坐标按顺时针顺序给出，保证羊严格在多边形内部。 \n", "locale": "en", "translations": {"en": {"title": "[POI 2010] OWC-Sheep", "background": "", "description": "The habitants of the Byteotian Highland bred sheep for centuries.\n\nEvery sane shepherd has a fenced pasture in the shape of a convex1 polygon    for the sheep to graze on.\n\nEvery sane sheep in turn has its own favourite feeding spot on the pasture where it spends all days.\n\nSometimes however, the sheep want to play. As they play in pairs, every shepherd keeps an even number of sheep,    so that his every sheep has a partner to play with.\n\nThe shepherds are concerned about a decree recently issued by the Byteburg's High Commissioner for Agriculture.\n\nThe decree states that as of the next year the sheep can only graze on triangle-shaped pastures.\n\nThus every shepherd whose pasture is an ![](http://main.edu.pl/images/OI17/owc-en-tex.1.png)-gon for ![](http://main.edu.pl/images/OI17/owc-en-tex.2.png) is to partition it into triangles by putting ![](http://main.edu.pl/images/OI17/owc-en-tex.3.png)    fences inside.\n\nEach single new fence, of course, is going to be a segment connecting two vertices of the polygon (pasture).\n\nAdditionally, the fences can intersect only in these vertices.\n\nA shepherd who does not fulfil these requirements will no longer be subsidized.\n\nByteasar, as a shepherd, has to decide on a way of partitioning his pasture.\n\nIn fact, he is unsure how many partitions are possible. He is only interested in such partitions    that no fence is drawn through a favourite spot of any sheep, and such that every resulting triangle    contains the favourite spots of an even number of sheep, so that these sheep can play in pairs.\n\nHelp Byteasar by writing a program that calculates the number of such partitions!\n", "inputFormat": "The first line of the standard input contains three integers ![](http://main.edu.pl/images/OI17/owc-en-tex.4.png), ![](http://main.edu.pl/images/OI17/owc-en-tex.5.png) and ![](http://main.edu.pl/images/OI17/owc-en-tex.6.png)    (![](http://main.edu.pl/images/OI17/owc-en-tex.7.png), ![](http://main.edu.pl/images/OI17/owc-en-tex.8.png), ![](http://main.edu.pl/images/OI17/owc-en-tex.9.png), ![](http://main.edu.pl/images/OI17/owc-en-tex.10.png)),    separated by single spaces, that denote respectively:\n\nthe number of vertices of the polygon forming the pasture,    the number of the sheep, and a certain positive integer ![](http://main.edu.pl/images/OI17/owc-en-tex.11.png).\n\nEach of the following ![](http://main.edu.pl/images/OI17/owc-en-tex.12.png) lines contains two integers ![](http://main.edu.pl/images/OI17/owc-en-tex.13.png) and ![](http://main.edu.pl/images/OI17/owc-en-tex.14.png)    (![](http://main.edu.pl/images/OI17/owc-en-tex.15.png)), separated by a single space,    de…\n", "outputFormat": "Your program should print one integer on the standard output,    namely the remainder of division by ![](http://main.edu.pl/images/OI17/owc-en-tex.22.png) of the number of partitions of the pasture in triangles,    such that no fence is drawn through a favourite spot of any sheep, and every resulting triangle    contains the favourite spots of an even number of sheep.\n", "hint": "$4\\le n\\le 600$，$2\\le k$，$m\\le 20\\ 000$，$2\\mid k$，$-15\\ 000\\le x_i,y_i,p_i,q_i\\le 15\\ 000$ ，牧场的顶点坐标按顺时针顺序给出，保证羊严格在多边形内部。 \n", "locale": "en"}, "zh-CN": {"title": "[POI 2010] OWC-Sheep", "background": null, "description": "**译自 POI 2010 Stage 2. Day 2「[Sheep](https://szkopul.edu.pl/problemset/problem/YjtAwdQrSiGcE_RLiEJpGiYE/site/?key=statement)」**\n\nByteasar 有一个凸多边形牧场，里面有一些羊。  \n现在 Byteasar 想要把这个凸多边形划分成若干三角形（划分线不能在牧场中相交，只能在顶点相交），使得每一个三角形里面的羊都有偶数只。  \nByteasar 想知道有多少种方案，你只要输出方案数对 $m$ 取余后的结果即可。", "inputFormat": "第一行三个空格隔开的正整数 $n,k,m$ ，分别表示牧场的顶点数，羊的个数，以及模数。  \n接下来 $n$ 行，每行两个空格隔开的正整数 $x_i,y_i$ ，表示牧场的顶点坐标。  \n接下来 $k$ 行，每行两个空格隔开的正整数 $p_i,q_i$ ，表示羊的坐标。", "outputFormat": "一行一个整数，表示方案数对 $m$ 取模的结果。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2450)。", "hint": "对于所有数据：\n- $4\\le n\\le 600$，$m\\le 20\\ 000$；\n- $2\\le k\\le 20000$，$2\\mid k$；\n- $-15\\ 000\\le x_i,y_i,p_i,q_i\\le 15\\ 000$；\n- 牧场的顶点坐标按顺时针顺序给出；\n- 保证羊严格在多边形内部。", "locale": "zh-CN"}}}
{"pid": "P3505", "type": "P", "difficulty": 6, "samples": [["10 10\n1 3\n3 5\n5 7\n7 9\n2 9\n1 4\n4 6\n6 8\n8 10\n2 10", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "POI（波兰）"], "title": "[POI 2010] TEL-Teleportation", "background": "", "description": "King Byteasar is the ruler of the whole solar system that contains $n$ planets.\n\nThis number is so large that people have abandoned the silly custom of naming the planets    and use numbers instead. The planets are thus conveniently numbered from 1 to $n$.\n\nByteasar's palace is on the planet no. 1, while his military base on the planet no. 2.\n\nA long time ago Byteasar had a teleportation portal established between these two planets,    which allows travelling from either planet to another in two hundred and fifty minutes    (slightly over four hours).\n\nNowadays the teleportation technology is more mature, and the recent teleportation devices shorten    the travel time to just a single hour. Let us note here, that all the portals, both the Byteasar's old one    and the new ones available on the market, are of course bidirectional, and that the teleportation    travel time is irrespective of the distance travelled.\n\nSome planets of the system are already connected with these new teleportation portals.\n\nIn fact, it is already possible to travel between the planets no. 1 and 2 without using the king's private portal,    though this involves several other portals and is thus no faster than the king's portal.\n\nByteasar finds this rather fortunate, as he believes that such possibility would be a security breach.\n\nThe technology itself is increasingly available, and as everyone realises its economic significance,    each pair of planets that are not currently directly connected with a portal are petitioning for establishing    such a connection. Being a wise ruler, Byteasar intends to give his consent to as many constructions as possible,    though keeping himself secure, i.e., not allowing the travel between planets 1 and 2 faster than with his private portal.\n\nHelp the king determine how many portals he can agree to.", "inputFormat": "Two integers are given in the first line of the standard input, $n$ and $m$ ($2\\le n \\le 40000,0\\le m\\le 1000000$), separated by a single space,      denoting the number of planets in Byteasar's realm and the number of new portals      that already exist.\n\nThese teleportation portals are described in the $m$ lines that follow.\n\nEach such line contains two integers $a_i$ and $b_i$ ($1\\le a_i<b_i\\le n$),      separated by a single space, denoting that there is a teleportation portal of the new kind      connecting $a_i$ and $b_i$.\n\nNo pair of numbers appears twice.\n\nYou may assume that the existing network of new portals allows travel from      planet no. 1 to planet no. 2, but in no less than 250 minutes.\n", "outputFormat": "Your program should print out just a single integer, namely the maximum number of portals      Byteasar can agree to without breaching his security.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2010] TEL-Teleportation", "background": "", "description": "King Byteasar is the ruler of the whole solar system that contains $n$ planets.\n\nThis number is so large that people have abandoned the silly custom of naming the planets    and use numbers instead. The planets are thus conveniently numbered from 1 to $n$.\n\nByteasar's palace is on the planet no. 1, while his military base on the planet no. 2.\n\nA long time ago Byteasar had a teleportation portal established between these two planets,    which allows travelling from either planet to another in two hundred and fifty minutes    (slightly over four hours).\n\nNowadays the teleportation technology is more mature, and the recent teleportation devices shorten    the travel time to just a single hour. Let us note here, that all the portals, both the Byteasar's old one    and the new ones available on the market, are of course bidirectional, and that the teleportation    travel time is irrespective of the distance travelled.\n\nSome planets of the system are already connected with these new teleportation portals.\n\nIn fact, it is already possible to travel between the planets no. 1 and 2 without using the king's private portal,    though this involves several other portals and is thus no faster than the king's portal.\n\nByteasar finds this rather fortunate, as he believes that such possibility would be a security breach.\n\nThe technology itself is increasingly available, and as everyone realises its economic significance,    each pair of planets that are not currently directly connected with a portal are petitioning for establishing    such a connection. Being a wise ruler, Byteasar intends to give his consent to as many constructions as possible,    though keeping himself secure, i.e., not allowing the travel between planets 1 and 2 faster than with his private portal.\n\nHelp the king determine how many portals he can agree to.", "inputFormat": "Two integers are given in the first line of the standard input, $n$ and $m$ ($2\\le n \\le 40000,0\\le m\\le 1000000$), separated by a single space,      denoting the number of planets in Byteasar's realm and the number of new portals      that already exist.\n\nThese teleportation portals are described in the $m$ lines that follow.\n\nEach such line contains two integers $a_i$ and $b_i$ ($1\\le a_i<b_i\\le n$),      separated by a single space, denoting that there is a teleportation portal of the new kind      connecting $a_i$ and $b_i$.\n\nNo pair of numbers appears twice.\n\nYou may assume that the existing network of new portals allows travel from      planet no. 1 to planet no. 2, but in no less than 250 minutes.\n", "outputFormat": "Your program should print out just a single integer, namely the maximum number of portals      Byteasar can agree to without breaching his security.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2010] TEL-Teleportation", "background": "", "description": "**译自 POI 2010 Stage 2. Day 2「[Teleportation](https://szkopul.edu.pl/problemset/problem/fKO3YZL0f_UM1nHQNDvw7mku/site/?key=statement)」**\n\n现在有 $n$ 个点，目前在 $1$ 号点和 $2$ 号点之间有一条无向边，长度为 $250\\min$ 。  \n除此之外，还有 $m$ 条无向边，长度都为 $1\\ \\textrm{h}$ （即 $60\\min$）， Byteasar 想知道，还能最多在添加多少条长度为 $1\\ \\textrm{h}$ 的无向边，使得新图无重边无自环，且 $1$ 号点到 $2$ 号点的最短路仍为 $250\\min$ 。", "inputFormat": "第一行两个空格隔开的正整数 $n,m$ 。  \n接下来 $m$ 行，每行两个空格隔开的正整数 $u_i,v_i$ ，描述原有的边。", "outputFormat": "一行一个整数，表示最多添加多少条边，可以使 $1$ 号点到 $2$ 号点的最短路长度保持不变。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2449)。", "hint": "数据保证，$2\\le n\\le 40\\ 000$，$0\\le m\\le 10^6$，$1\\le u_i,v_i\\le n$，保证只考虑已有的边时， $1$ 号点与 $2$ 号点联通，且最短路长度大于 $250\\min$ 。", "locale": "zh-CN"}}}
{"pid": "P3506", "type": "P", "difficulty": 6, "samples": [["7 3\n2 4 3 1 3 5 3\n< > =", "6\n2 4 3 3 5 3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2010", "线段树", "树状数组", "POI（波兰）", "Special Judge"], "title": "[POI 2010] MOT-Monotonicity 2", "background": "", "description": "This task is a harder version of task Monotonicity from the third stage of 17th Polish OI. It wasn't used in the contest itself.\n\nFor an integer sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.1.png) we define its monotonicity scheme as the sequence    ![](http://main.edu.pl/images/OI17/mot-en-tex.2.png) of symbols ![](http://main.edu.pl/images/OI17/mot-en-tex.3.png), ![](http://main.edu.pl/images/OI17/mot-en-tex.4.png) or ![](http://main.edu.pl/images/OI17/mot-en-tex.5.png).\n\nThe symbol ![](http://main.edu.pl/images/OI17/mot-en-tex.6.png) represents the relation between ![](http://main.edu.pl/images/OI17/mot-en-tex.7.png) and ![](http://main.edu.pl/images/OI17/mot-en-tex.8.png).\n\nFor example, the monotonicity scheme of the sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.9.png) is ![](http://main.edu.pl/images/OI17/mot-en-tex.10.png).\n\nWe say that an integer sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.11.png) with monotonicity scheme    ![](http://main.edu.pl/images/OI17/mot-en-tex.12.png), realizes another monotonicity scheme ![](http://main.edu.pl/images/OI17/mot-en-tex.13.png)    if for every ![](http://main.edu.pl/images/OI17/mot-en-tex.14.png) it holds that ![](http://main.edu.pl/images/OI17/mot-en-tex.15.png).\n\nIn other words, the sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.16.png) can be obtained by repeating the sequence    ![](http://main.edu.pl/images/OI17/mot-en-tex.17.png) and removing appropriate suffix from that repetition.\n\nFor example, the sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.18.png) realizes each and every one of the following schemes:\n\n![](http://main.edu.pl/images/OI17/mot-en-tex.19.png)           ![](http://main.edu.pl/images/OI17/mot-en-tex.20.png)           ![](http://main.edu.pl/images/OI17/mot-en-tex.21.png)           ![](http://main.edu.pl/images/OI17/mot-en-tex.22.png)                  as well as many others.\n\nAn integer sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.23.png) and a monotonicity scheme ![](http://main.edu.pl/images/OI17/mot-en-tex.24.png) are given.\n\nYour task is to find the longest subsequence ![](http://main.edu.pl/images/OI17/mot-en-tex.25.png) (![](http://main.edu.pl/images/OI17/mot-en-tex.26.png))    of the former that realizes the latter.", "inputFormat": "The first line of the standard input holds two integers ![](http://main.edu.pl/images/OI17/mot-en-tex.27.png) and ![](http://main.edu.pl/images/OI17/mot-en-tex.28.png) (![](http://main.edu.pl/images/OI17/mot-en-tex.29.png), ![](http://main.edu.pl/images/OI17/mot-en-tex.30.png)),    separated by a single space, denoting the lengths of the sequences ![](http://main.edu.pl/images/OI17/mot-en-tex.31.png) and monotonicity scheme ![](http://main.edu.pl/images/OI17/mot-en-tex.32.png) respectively.\n\nThe second input line gives the sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.33.png), i.e, it holds ![](http://main.edu.pl/images/OI17/mot-en-tex.34.png) integers ![](http://main.edu.pl/images/OI17/mot-en-tex.35.png) separated by single spaces (![](http://main.edu.pl/images/OI17/mot-en-tex.36.png)).\n\nFinally, the third lines gives the monotonicity scheme ![](http://main.edu.pl/images/OI17/mot-en-tex.37.png), i.e., it holds ![](http://main.edu.pl/images/OI17/mot-en-tex.38.png) s…\n", "outputFormat": "In the first line of the standard output your program should print out a single integer ![](http://main.edu.pl/images/OI17/mot-en-tex.40.png),    the maximum length of a subsequence of ![](http://main.edu.pl/images/OI17/mot-en-tex.41.png) that realizes the scheme ![](http://main.edu.pl/images/OI17/mot-en-tex.42.png).\n\nIn the second line it should print out any such subsequence ![](http://main.edu.pl/images/OI17/mot-en-tex.43.png), separating its elements by single spaces.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2010] MOT-Monotonicity 2", "background": "", "description": "This task is a harder version of task Monotonicity from the third stage of 17th Polish OI. It wasn't used in the contest itself.\n\nFor an integer sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.1.png) we define its monotonicity scheme as the sequence    ![](http://main.edu.pl/images/OI17/mot-en-tex.2.png) of symbols ![](http://main.edu.pl/images/OI17/mot-en-tex.3.png), ![](http://main.edu.pl/images/OI17/mot-en-tex.4.png) or ![](http://main.edu.pl/images/OI17/mot-en-tex.5.png).\n\nThe symbol ![](http://main.edu.pl/images/OI17/mot-en-tex.6.png) represents the relation between ![](http://main.edu.pl/images/OI17/mot-en-tex.7.png) and ![](http://main.edu.pl/images/OI17/mot-en-tex.8.png).\n\nFor example, the monotonicity scheme of the sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.9.png) is ![](http://main.edu.pl/images/OI17/mot-en-tex.10.png).\n\nWe say that an integer sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.11.png) with monotonicity scheme    ![](http://main.edu.pl/images/OI17/mot-en-tex.12.png), realizes another monotonicity scheme ![](http://main.edu.pl/images/OI17/mot-en-tex.13.png)    if for every ![](http://main.edu.pl/images/OI17/mot-en-tex.14.png) it holds that ![](http://main.edu.pl/images/OI17/mot-en-tex.15.png).\n\nIn other words, the sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.16.png) can be obtained by repeating the sequence    ![](http://main.edu.pl/images/OI17/mot-en-tex.17.png) and removing appropriate suffix from that repetition.\n\nFor example, the sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.18.png) realizes each and every one of the following schemes:\n\n![](http://main.edu.pl/images/OI17/mot-en-tex.19.png)           ![](http://main.edu.pl/images/OI17/mot-en-tex.20.png)           ![](http://main.edu.pl/images/OI17/mot-en-tex.21.png)           ![](http://main.edu.pl/images/OI17/mot-en-tex.22.png)                  as well as many others.\n\nAn integer sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.23.png) and a monotonicity scheme ![](http://main.edu.pl/images/OI17/mot-en-tex.24.png) are given.\n\nYour task is to find the longest subsequence ![](http://main.edu.pl/images/OI17/mot-en-tex.25.png) (![](http://main.edu.pl/images/OI17/mot-en-tex.26.png))    of the former that realizes the latter.", "inputFormat": "The first line of the standard input holds two integers ![](http://main.edu.pl/images/OI17/mot-en-tex.27.png) and ![](http://main.edu.pl/images/OI17/mot-en-tex.28.png) (![](http://main.edu.pl/images/OI17/mot-en-tex.29.png), ![](http://main.edu.pl/images/OI17/mot-en-tex.30.png)),    separated by a single space, denoting the lengths of the sequences ![](http://main.edu.pl/images/OI17/mot-en-tex.31.png) and monotonicity scheme ![](http://main.edu.pl/images/OI17/mot-en-tex.32.png) respectively.\n\nThe second input line gives the sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.33.png), i.e, it holds ![](http://main.edu.pl/images/OI17/mot-en-tex.34.png) integers ![](http://main.edu.pl/images/OI17/mot-en-tex.35.png) separated by single spaces (![](http://main.edu.pl/images/OI17/mot-en-tex.36.png)).\n\nFinally, the third lines gives the monotonicity scheme ![](http://main.edu.pl/images/OI17/mot-en-tex.37.png), i.e., it holds ![](http://main.edu.pl/images/OI17/mot-en-tex.38.png) s…\n", "outputFormat": "In the first line of the standard output your program should print out a single integer ![](http://main.edu.pl/images/OI17/mot-en-tex.40.png),    the maximum length of a subsequence of ![](http://main.edu.pl/images/OI17/mot-en-tex.41.png) that realizes the scheme ![](http://main.edu.pl/images/OI17/mot-en-tex.42.png).\n\nIn the second line it should print out any such subsequence ![](http://main.edu.pl/images/OI17/mot-en-tex.43.png), separating its elements by single spaces.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2010] MOT-Monotonicity 2", "background": null, "description": "本题是来自 POI 2010 第三阶段的[单调性](https://www.luogu.com.cn/problem/P3541)一题的加强版，但并没有在那次比赛中被使用。\n\n**译自 POI 2010 「[Monotonicity 2](https://szkopul.edu.pl/problemset/problem/0_pcwjQ6no8LDss0IWNLbb2_/site/?key=statement)」**\n\n对于一个整数序列 $a_1, a_2, ..., a_n$，我们定义其“单调序列\"为一个由 $<$，$>$ 和 $=$ 组成的符号序列 $s_1, s_2, ... s_{n-1}$，其中符号 $s_i$ 表示 $a_i$ 和 $a_{i+1}$ 之间的关系。例如，数列 $2, 4, 3, 3, 5, 3$ 的单调序列为 $<, >, =, <, >$。\n\n对于整数序列 $b_1, b_2, ..., b_{n+1}$ 以及其单调序列 $s_1, s_2, ..., s_n$，如果符号序列 $s_1', s_2', ..., s_k'$ 满足对所有 $1 \\le i \\le n$ 有 $s_i = s_{((i - 1) \\bmod k) + 1}'$，我们就说序列 $s_1, s_2, ..., s_n$ 「实现」了序列 $s_1', s_2', ..., s_k'$。也就是说，序列 $s_1, s_2, ..., s_n$ 可以通过重复多次 $s_1', s_2', ..., s_k'$ 序列并删除一个后缀得到。例如，整数数列 $2, 4, 3, 3, 5, 3$ 至少实现了以下符号序列：\n* $<, >, =$\n* $<, >, =, <, >$\n* $<, >, =, <, >, <, <, =$\n* $<, >, =, <, >, =, >, >$\n\n给定一个整数序列 $a_1, a_2, ..., a_n$ 以及一个单调序列 $s_1, s_2, ..., s_k$，求出原整数序列最长的子序列 $a_{i_1}, a_{i_2}, ..., a_{i_m} (1 \\le i_1 \\lt i_2 \\lt ... \\lt i_m \\le n)$ 使得前者的单调序列实现后者的符号序列。", "inputFormat": "第一行包含用空格分隔的两个整数 $n,k$，分别表示整数序列 $(a_i)$ 的长度和单调序列 $(s_j)$ 的长度。\n\n第二行包含用空格分隔的 $n$ 个整数，表示序列 $a_i$.\n\n第三行包含用空格分隔的 $k$ 个符号，表示符号序列 $s_j$.", "outputFormat": "第一行输出一个整数 $m$，表示序列 $a_1, a_2, ..., a_n$ 的最长的「实现」了单调序列 $s_1, s_2, ..., s_n$ 的子序列。\n\n第二行输出任意一个这样的子序列 $a_{i_1}, a_{i_2}, ..., a_{i_n}$，元素之间用空格分隔。", "hint": "对于 $100\\%$ 的数据， $1 \\le n \\le 500000,1 \\le k \\le 500000 , 1 \\le a_i \\le 1000000 , s_j \\in \\{<, >, =\\}$ 。\n\n感谢 [本帖](https://www.luogu.com.cn/discuss/67056) 提供的 SPJ。翻译来自于 [LibreOJ](https://loj.ac/p/3009)。", "locale": "zh-CN"}}}
{"pid": "P3507", "type": "P", "difficulty": 5, "samples": [["3\n1 3 1", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "动态规划 DP", "贪心", "2010", "POI（波兰）"], "title": "[POI 2010] GRA-The Minima Game", "background": "", "description": "Alice and Bob learned the minima game, which they like very much, recently.\n\nThe rules of the game are as follows.\n\nA certain number of cards lies on a table, each inscribed with a positive integer.\n\nThe players make alternate moves, Alice making the first one.\n\nA move consists in picking an arbitrary positive number of cards from the table.\n\nFor such move the player receives a number of points equal to the minimum    of the numbers inscribed on the cards he collected.\n\nThe game ends when the last card is removed from the table.\n\nThe goal of each player is maximizing the difference between their and their opponent's score.\n\nAlice and Bob have duly noted that there is an optimal strategy in the game.\n\nThus they are asking you to write a program that, for a given set of cards,    determines the outcome of the game when both players play optimally.", "inputFormat": "In the first line of the standard input there is one integer ![](http://main.edu.pl/images/OI17/gra-en-tex.1.png) (![](http://main.edu.pl/images/OI17/gra-en-tex.2.png)) given,      denoting the number of cards.\n\nThe second line holds ![](http://main.edu.pl/images/OI17/gra-en-tex.3.png) positive integers ![](http://main.edu.pl/images/OI17/gra-en-tex.4.png) (![](http://main.edu.pl/images/OI17/gra-en-tex.5.png)),      separated by single spaces, that are inscribed on the cards.\n", "outputFormat": "Your program should print out a single line with a single integer to the standard      output - the number of points by which Alice wins over Bob, assuming they both play optimally;      if it is Bob who has more points, the result should be negative.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2010] GRA-The Minima Game", "background": "", "description": "Alice and Bob learned the minima game, which they like very much, recently.\n\nThe rules of the game are as follows.\n\nA certain number of cards lies on a table, each inscribed with a positive integer.\n\nThe players make alternate moves, Alice making the first one.\n\nA move consists in picking an arbitrary positive number of cards from the table.\n\nFor such move the player receives a number of points equal to the minimum    of the numbers inscribed on the cards he collected.\n\nThe game ends when the last card is removed from the table.\n\nThe goal of each player is maximizing the difference between their and their opponent's score.\n\nAlice and Bob have duly noted that there is an optimal strategy in the game.\n\nThus they are asking you to write a program that, for a given set of cards,    determines the outcome of the game when both players play optimally.", "inputFormat": "In the first line of the standard input there is one integer ![](http://main.edu.pl/images/OI17/gra-en-tex.1.png) (![](http://main.edu.pl/images/OI17/gra-en-tex.2.png)) given,      denoting the number of cards.\n\nThe second line holds ![](http://main.edu.pl/images/OI17/gra-en-tex.3.png) positive integers ![](http://main.edu.pl/images/OI17/gra-en-tex.4.png) (![](http://main.edu.pl/images/OI17/gra-en-tex.5.png)),      separated by single spaces, that are inscribed on the cards.\n", "outputFormat": "Your program should print out a single line with a single integer to the standard      output - the number of points by which Alice wins over Bob, assuming they both play optimally;      if it is Bob who has more points, the result should be negative.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2010] GRA-The Minima Game", "background": "", "description": "**译自 POI 2010 Stage 3. Day 1「[The Minima Game](https://szkopul.edu.pl/problemset/problem/3buviDQZWLE83AxVhvJJurgU/site/?key=statement)」**\n\nAlice 和 Bob 玩一个游戏。Alice 先手，两人轮流进行操作，每轮一个玩家可以选择若干张牌（至少一张），并获得相当于这些牌上所写数字的最小值的分数，直到没有牌为止。两人都希望自己的分数与对方分数之差最大。若两个玩家都使用最佳策略，求游戏的最终结果。", "inputFormat": "第一行有一个整数 $n$，表示牌的数量。\n\n接下来一行有 $n$ 个正整数 $k_1, k_2, ..., k_n$，表示牌上所写的数字。", "outputFormat": "输出一行一个整数，表示最终 Alice 的分数与 Bob 分数之差。如果 Bob 的分数更多，你应该输出一个负数。\n\n### 样例解释\n\nAlice 先选择 $3$，得到 $3$ 分。Bob 拿走所有牌并得到 $1$ 分，游戏最后的比分为 $3:1$，因此 Alice 比 Bob 多两分。", "hint": "$1\\le n\\le 10^6$，$1\\le k_i\\le 10^9$。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2455)。", "locale": "zh-CN"}}}
{"pid": "P3508", "type": "P", "difficulty": 0, "samples": [["3 3\n-1 2 1 4\n-1 5 1 7\n-3 8 -2 20\n-1 1 1 2\n-1 4 1 5\n-1 7 1 10", "2\n1 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2010", "线段树", "POI（波兰）"], "title": "[POI 2010] LAT-Lamp", "background": "\n", "description": "In the middle of the night Bitratio turned on the lamp at the entrance to the building that Byteasar lives in.\n\nNow the strong light prevents Byteasar from sleeping.\n\nWhile the lamp does not shine directly on Byteasar's windows, it does so by reflecting in other windows.\n\nDeprived of sleep, Byteasar is becoming irritated.\n\nTo remedy that he tries to occupy his mind, but all he can think of is the light.\n\nThus Byteasar looked out the window and wondered if his neighbours suffer similar torture,    i.e., whether the light shines on their windows as well.\n\nNow that is an interesting question, at least in Byteasar's opinion.\n\nYou learn of the puzzle sooner than you would wish: unable to solve the problem all by himself,    thinking little of sleep now (be it his and yours), Byteasar calls you to ask for help.\n\nYou know him well enough to understand that you too will not get any sleep until you write a program    that solves his problem.\n\nByteasar lives in the building ![](http://main.edu.pl/images/OI17/lat-en-tex.1.png), which has ![](http://main.edu.pl/images/OI17/lat-en-tex.2.png) windows.\n\nThe lamp is situated on a wall at the very bottom of this building.\n\nOpposite the building ![](http://main.edu.pl/images/OI17/lat-en-tex.3.png), exactly 10 meters apart, there is another building, ![](http://main.edu.pl/images/OI17/lat-en-tex.4.png).\n\nThe wall of this ![](http://main.edu.pl/images/OI17/lat-en-tex.5.png)-windowed building is parallel to the wall of ![](http://main.edu.pl/images/OI17/lat-en-tex.6.png), the Byteasar's building.\n\nThe lamp light behaves like you would expect, i.e., in the way predicted by geometrical optics (or ray optics).\n\nNamely the light propagates along rays, and if a ray hits a window, it is reflected.\n\nDue to The Law of Reflection, the angle of the ray's reflection equals the angle of incidence.\n\nWe introduce coordinate systems on the the walls of the two buildings in the following way.\n\nBoth ![](http://main.edu.pl/images/OI17/lat-en-tex.7.png) axes are horizontal, while both ![](http://main.edu.pl/images/OI17/lat-en-tex.8.png) axes are vertical; the axes on both walls are identically oriented,    and the ![](http://main.edu.pl/images/OI17/lat-en-tex.9.png) points of the walls are opposite one another.\n\nThe windows (on either building) are simply rectangles with sides parallel to the axes of the coordinate system.\n\nA ray is reflected only in the interior of any window; it is absorbed on the window's boundary.\n\nIn each building, no two windows share any part of their interiors.\n\nThe lamp is located on the wall of the ![](http://main.edu.pl/images/OI17/lat-en-tex.10.png) building at the point ![](http://main.edu.pl/images/OI17/lat-en-tex.11.png),    which is neither inside nor at the boundary of any window.\n", "inputFormat": "In the first line of the standard input there are two integers ![](http://main.edu.pl/images/OI17/lat-en-tex.12.png) and ![](http://main.edu.pl/images/OI17/lat-en-tex.13.png) (![](http://main.edu.pl/images/OI17/lat-en-tex.14.png)),      separated by a single space, denoting the number of windows in the first and second building respectively.\n\nThe ![](http://main.edu.pl/images/OI17/lat-en-tex.15.png) lines that follow describe the windows in Byteasar's building (the ![](http://main.edu.pl/images/OI17/lat-en-tex.16.png) building), one per line.\n\nThe line no. ![](http://main.edu.pl/images/OI17/lat-en-tex.17.png) (for ![](http://main.edu.pl/images/OI17/lat-en-tex.18.png)) holds four integers ![](http://main.edu.pl/images/OI17/lat-en-tex.19.png), ![](http://main.edu.pl/images/OI17/lat-en-tex.20.png), ![](http://main.edu.pl/images/OI17/lat-en-tex.21.png), ![](http://main.edu.pl/images/OI17/lat-en-tex.22.png)      (![](http://main.edu.pl/images/OI17/lat-en-tex.23.png),      !…\n", "outputFormat": "In the first line of the standard output your program should print the number of windows in the ![](http://main.edu.pl/images/OI17/lat-en-tex.31.png) building      whose interiors are hit by some ray.\n\nYou may assume that in every test instance there will be at least one such window (the Byteasar's window).\n\nIn the second line the numbers of these windows (windows are numbered starting from 1) should be printed in increasing order,      separated by single spaces.\n", "hint": "$-1000 \\le x_{1,i} \\lt x_{2,i} \\le 1000$，$0 \\le y_{1,i} < y_{2,i} \\le 1000$\n", "locale": "en", "translations": {"en": {"title": "[POI 2010] LAT-Lamp", "background": "\n", "description": "In the middle of the night Bitratio turned on the lamp at the entrance to the building that Byteasar lives in.\n\nNow the strong light prevents Byteasar from sleeping.\n\nWhile the lamp does not shine directly on Byteasar's windows, it does so by reflecting in other windows.\n\nDeprived of sleep, Byteasar is becoming irritated.\n\nTo remedy that he tries to occupy his mind, but all he can think of is the light.\n\nThus Byteasar looked out the window and wondered if his neighbours suffer similar torture,    i.e., whether the light shines on their windows as well.\n\nNow that is an interesting question, at least in Byteasar's opinion.\n\nYou learn of the puzzle sooner than you would wish: unable to solve the problem all by himself,    thinking little of sleep now (be it his and yours), Byteasar calls you to ask for help.\n\nYou know him well enough to understand that you too will not get any sleep until you write a program    that solves his problem.\n\nByteasar lives in the building ![](http://main.edu.pl/images/OI17/lat-en-tex.1.png), which has ![](http://main.edu.pl/images/OI17/lat-en-tex.2.png) windows.\n\nThe lamp is situated on a wall at the very bottom of this building.\n\nOpposite the building ![](http://main.edu.pl/images/OI17/lat-en-tex.3.png), exactly 10 meters apart, there is another building, ![](http://main.edu.pl/images/OI17/lat-en-tex.4.png).\n\nThe wall of this ![](http://main.edu.pl/images/OI17/lat-en-tex.5.png)-windowed building is parallel to the wall of ![](http://main.edu.pl/images/OI17/lat-en-tex.6.png), the Byteasar's building.\n\nThe lamp light behaves like you would expect, i.e., in the way predicted by geometrical optics (or ray optics).\n\nNamely the light propagates along rays, and if a ray hits a window, it is reflected.\n\nDue to The Law of Reflection, the angle of the ray's reflection equals the angle of incidence.\n\nWe introduce coordinate systems on the the walls of the two buildings in the following way.\n\nBoth ![](http://main.edu.pl/images/OI17/lat-en-tex.7.png) axes are horizontal, while both ![](http://main.edu.pl/images/OI17/lat-en-tex.8.png) axes are vertical; the axes on both walls are identically oriented,    and the ![](http://main.edu.pl/images/OI17/lat-en-tex.9.png) points of the walls are opposite one another.\n\nThe windows (on either building) are simply rectangles with sides parallel to the axes of the coordinate system.\n\nA ray is reflected only in the interior of any window; it is absorbed on the window's boundary.\n\nIn each building, no two windows share any part of their interiors.\n\nThe lamp is located on the wall of the ![](http://main.edu.pl/images/OI17/lat-en-tex.10.png) building at the point ![](http://main.edu.pl/images/OI17/lat-en-tex.11.png),    which is neither inside nor at the boundary of any window.\n", "inputFormat": "In the first line of the standard input there are two integers ![](http://main.edu.pl/images/OI17/lat-en-tex.12.png) and ![](http://main.edu.pl/images/OI17/lat-en-tex.13.png) (![](http://main.edu.pl/images/OI17/lat-en-tex.14.png)),      separated by a single space, denoting the number of windows in the first and second building respectively.\n\nThe ![](http://main.edu.pl/images/OI17/lat-en-tex.15.png) lines that follow describe the windows in Byteasar's building (the ![](http://main.edu.pl/images/OI17/lat-en-tex.16.png) building), one per line.\n\nThe line no. ![](http://main.edu.pl/images/OI17/lat-en-tex.17.png) (for ![](http://main.edu.pl/images/OI17/lat-en-tex.18.png)) holds four integers ![](http://main.edu.pl/images/OI17/lat-en-tex.19.png), ![](http://main.edu.pl/images/OI17/lat-en-tex.20.png), ![](http://main.edu.pl/images/OI17/lat-en-tex.21.png), ![](http://main.edu.pl/images/OI17/lat-en-tex.22.png)      (![](http://main.edu.pl/images/OI17/lat-en-tex.23.png),      !…\n", "outputFormat": "In the first line of the standard output your program should print the number of windows in the ![](http://main.edu.pl/images/OI17/lat-en-tex.31.png) building      whose interiors are hit by some ray.\n\nYou may assume that in every test instance there will be at least one such window (the Byteasar's window).\n\nIn the second line the numbers of these windows (windows are numbered starting from 1) should be printed in increasing order,      separated by single spaces.\n", "hint": "$-1000 \\le x_{1,i} \\lt x_{2,i} \\le 1000$，$0 \\le y_{1,i} < y_{2,i} \\le 1000$\n", "locale": "en"}, "zh-CN": {"title": "[POI 2010] LAT-Lamp", "background": "", "description": "在半夜，Bitratio 打开了 Byteasar 所住楼房入口处的灯。\n\n现在强光让 Byteasar 无法入睡。\n\n虽然灯光没有直接照射到 Byteasar 的窗户上，但通过其他窗户反射到了他的窗户上。\n\n失去睡眠的 Byteasar 变得烦躁。\n\n为了缓解这种情况，他试图让自己分心，但他能想到的只有灯光。\n\n因此，Byteasar 望向窗外，想知道他的邻居们是否也遭受着类似的折磨，即灯光是否也照射到了他们的窗户上。\n\n至少在 Byteasar 看来，这是一个有趣的问题。\n\n你比预期更早地知道了这个难题：因为无法独自解决这个问题，现在（无论是他的还是你的）对睡眠不再有任何想法，Byteasar 打电话给你寻求帮助。\n\n你对他很了解，知道在你写出一个解决他问题的程序之前，你也无法入睡。\n\nByteasar 住在一栋有 ![](http://main.edu.pl/images/OI17/lat-en-tex.1.png) 个窗户的建筑中。\n\n灯位于这栋建筑的最底部的墙上。\n\n在这栋建筑的对面，正好相隔 10 米，有另一栋建筑，![](http://main.edu.pl/images/OI17/lat-en-tex.4.png)。\n\n这栋有 ![](http://main.edu.pl/images/OI17/lat-en-tex.5.png) 个窗户的建筑的墙与 Byteasar 所住建筑的墙平行。\n\n灯光的行为如你所料，即按照几何光学（或射线光学）的预测。\n\n即光沿着射线传播，如果射线击中窗户，则会被反射。\n\n根据反射定律，射线的反射角等于入射角。\n\n我们在两栋建筑的墙上引入坐标系。\n\n两个 ![](http://main.edu.pl/images/OI17/lat-en-tex.7.png) 轴是水平的，而两个 ![](http://main.edu.pl/images/OI17/lat-en-tex.8.png) 轴是垂直的；两面墙上的坐标轴方向相同，墙上的 ![](http://main.edu.pl/images/OI17/lat-en-tex.9.png) 点彼此相对。\n\n两栋建筑上的窗户都是矩形，边与坐标系的轴平行。\n\n射线仅在任何窗户的内部反射；在窗户的边界上被吸收。\n\n在每栋建筑中，没有两个窗户的内部有任何部分重叠。\n\n灯位于 ![](http://main.edu.pl/images/OI17/lat-en-tex.10.png) 建筑的墙上，位于点 ![](http://main.edu.pl/images/OI17/lat-en-tex.11.png)，既不在任何窗户的内部也不在边界上。", "inputFormat": "标准输入的第一行有两个整数 ![](http://main.edu.pl/images/OI17/lat-en-tex.12.png) 和 ![](http://main.edu.pl/images/OI17/lat-en-tex.13.png) (![](http://main.edu.pl/images/OI17/lat-en-tex.14.png))，用一个空格分隔，表示第一栋和第二栋建筑中的窗户数量。\n\n接下来的 ![](http://main.edu.pl/images/OI17/lat-en-tex.15.png) 行描述了 Byteasar 所住建筑（![](http://main.edu.pl/images/OI17/lat-en-tex.16.png) 建筑）中的窗户，每行一个。\n\n第 ![](http://main.edu.pl/images/OI17/lat-en-tex.17.png) 行（对于 ![](http://main.edu.pl/images/OI17/lat-en-tex.18.png)）包含四个整数 ![](http://main.edu.pl/images/OI17/lat-en-tex.19.png)、![](http://main.edu.pl/images/OI17/lat-en-tex.20.png)、![](http://main.edu.pl/images/OI17/lat-en-tex.21.png)、![](http://main.edu.pl/images/OI17/lat-en-tex.22.png) (![](http://main.edu.pl/images/OI17/lat-en-tex.23.png)、...", "outputFormat": "标准输出的第一行，你的程序应输出 ![](http://main.edu.pl/images/OI17/lat-en-tex.31.png) 建筑中被某些射线击中的窗户数量。\n\n你可以假设在每个测试实例中至少会有一个这样的窗户（即 Byteasar 的窗户）。\n\n在第二行，应以递增顺序打印这些窗户的编号（窗户从 1 开始编号），用单个空格分隔。", "hint": "$-1000 \\le x_{1,i} < x_{2,i} \\le 1000$，$0 \\le y_{1,i} < y_{2,i} \\le 1000$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3509", "type": "P", "difficulty": 5, "samples": [["5 2 4\n1 2 4 7 10", "1 1 3 1 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2010", "倍增", "单调队列", "POI（波兰）", "深度优先搜索 DFS"], "title": "[POI 2010] ZAB-Frog", "background": "", "description": "On the bed of one particularly long and straight Byteotian brook there lie $n$ rocks jutting above the water level. Their distances from the brook's spring are $p_1 < p_2 < \\cdots < p_n$ respectively. A small frog sitting on one of these is about to begin its leaping training. Each time the frog leaps to the rock that is the -th closest to the one it is sitting on. Specifically, if the frog is sitting on the rock at position $p_i$, then it will leap onto such $p_j$ that:\n$$\n|\\{ p_a : |p _ a - p _ i| < |p_j - p_i| \\}| \\le k \\text{ and } |\\{ p_a : |p _ a - p _ i| \\le |p_j - p_i| \\}| > k\n$$\nIf $p_j$ is not unique, then the frog chooses among them the rock that is closest to the spring. On which rock the frog will be sitting after $m$ leaps depending on the rock is started from?", "inputFormat": "The first line of the standard input holds three integers, $n$, $k$ and $m$ ($1 \\le k < n \\le 1 \\, 000 \\, 000, 1 \\le m \\le 10^{18}$), separated by single spaces, that denote respectively: the number of rocks, the parameter $k$, and the number of intended leaps. The second line holds $n$ integers $p_j$ ($1 \\le p_1 < p_2 < \\cdots < p_n \\le 10^{18}$), separated by single spaces, that denote the positions of successive rocks on the bed of the brook.", "outputFormat": "Your program should print a single line on the standard output, with $n$ integers $r_1, r_2, \\cdots, r_n$ from the interval $[1, n]$ in it, separated by single spaces. The number $r_i$ denotes the number of the rock that the frog ends on after making $m$ leaps starting from the rock no. $i$ (in the input order).", "hint": "### 样例 #1 解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yyilx2mp.png)\n\nThe figure presents where the frog leaps to (in a single leap) from each and every rock.", "locale": "en", "translations": {"en": {"title": "[POI 2010] ZAB-Frog", "background": "", "description": "On the bed of one particularly long and straight Byteotian brook there lie $n$ rocks jutting above the water level. Their distances from the brook's spring are $p_1 < p_2 < \\cdots < p_n$ respectively. A small frog sitting on one of these is about to begin its leaping training. Each time the frog leaps to the rock that is the -th closest to the one it is sitting on. Specifically, if the frog is sitting on the rock at position $p_i$, then it will leap onto such $p_j$ that:\n$$\n|\\{ p_a : |p _ a - p _ i| < |p_j - p_i| \\}| \\le k \\text{ and } |\\{ p_a : |p _ a - p _ i| \\le |p_j - p_i| \\}| > k\n$$\nIf $p_j$ is not unique, then the frog chooses among them the rock that is closest to the spring. On which rock the frog will be sitting after $m$ leaps depending on the rock is started from?", "inputFormat": "The first line of the standard input holds three integers, $n$, $k$ and $m$ ($1 \\le k < n \\le 1 \\, 000 \\, 000, 1 \\le m \\le 10^{18}$), separated by single spaces, that denote respectively: the number of rocks, the parameter $k$, and the number of intended leaps. The second line holds $n$ integers $p_j$ ($1 \\le p_1 < p_2 < \\cdots < p_n \\le 10^{18}$), separated by single spaces, that denote the positions of successive rocks on the bed of the brook.", "outputFormat": "Your program should print a single line on the standard output, with $n$ integers $r_1, r_2, \\cdots, r_n$ from the interval $[1, n]$ in it, separated by single spaces. The number $r_i$ denotes the number of the rock that the frog ends on after making $m$ leaps starting from the rock no. $i$ (in the input order).", "hint": "### 样例 #1 解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yyilx2mp.png)\n\nThe figure presents where the frog leaps to (in a single leap) from each and every rock.", "locale": "en"}, "zh-CN": {"title": "[POI 2010] ZAB-Frog", "background": null, "description": "在一个特别长且笔直的 Byteotian 小溪的河床上，有 $n$ 块石头露出水面。它们距离小溪源头的距离分别为 $p_1 < p_2 < \\cdots < p_n$。一只小青蛙正坐在其中一块石头上，准备开始它的跳跃训练。每次青蛙跳跃到距离它所在石头第 $k$ 近的石头上。具体来说，如果青蛙坐在位置 $p_i$ 的石头上，那么它将跳到这样的 $p_j$ 上，使得：\n\n$$\n|\\{ p_a : |p _ a - p _ i| < |p_j - p_i| \\}| \\le k \\text{ and } |\\{ p_a : |p _ a - p _ i| \\le |p_j - p_i| \\}| > k\n$$\n\n如果 $p_j$ 不是唯一的，那么青蛙在其中选择距离源头最近的石头。对于每一块石头分别计算，若青蛙从这块石头开始跳跃，经过 $m$ 次跳跃后最终会停留在哪一块石头上？", "inputFormat": "标准输入的第一行包含三个整数 $n$、$k$ 和 $m$（$1 \\le k < n \\le 1\\,000\\,000, 1 \\le m \\le 10^{18}$），用空格分隔，分别表示石头的数量、参数 $k$ 和计划跳跃的次数。第二行包含 $n$ 个整数 $p_j$（$1 \\le p_1 < p_2 < \\cdots < p_n \\le 10^{18}$），用空格分隔，表示小溪河床上连续石头的位置。", "outputFormat": "你的程序应在标准输出上打印一行，包含 $n$ 个整数 $r_1, r_2, \\cdots, r_n$，用空格分隔。数字 $r_i$ 表示从输入顺序中的第 $i$ 块石头开始跳跃 $m$ 次后，青蛙最终停留的石头编号。", "hint": "### 样例 #1 解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yyilx2mp.png)\n\n图中展示了青蛙从每块石头跳跃（单次跳跃）到的位置。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3510", "type": "P", "difficulty": 0, "samples": [["6\n1 1 1 1 1 1", "5\n1 1 2 1 1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "单调队列", "POI（波兰）", "哈希 hashing", "级数"], "title": "[POI 2010] JED-Ones", "background": "", "description": "Let $x$ be a sequence of zeros and ones.\n\nAn utterly forlorn one (UFO) in $x$ is the extreme (either first or last) one    that additionally does not neighbour with any other one.\n\nFor instance, the sequence 10001010 has two UFOs,    while the sequence 1101011000 has no UFO,    and the sequence 1000 has only one UFO.\n\nLet us denote the total number of UFOs in the binary representations of the numbers    from 1 to $n$ with $sks(n)$.\n\nFor example,    $sks(5)=5$, $sks(64)=59$, $sks(128)=122$, $sks(256)=249$.\n\nWe will be working with very large numbers.\n\n```plain\nTherefore, we shall represent them in a succinct way.\n```\nSuppose $x$ is a positive integer and $x_2$ is its binary representation    (starting with 1). Then the succinct representation of $x$ is the sequence    $REP(x)$ consisting of positive integers denoting the lengths of successive    blocks of the same digits.\n\nFor example:\n\n$REP(460\\ 288)=REP(1110000011000000000_2)=(3,5,2,9)$ $REP(408)=REP(110011000_2)=(2,2,2,3)$  \n\nYour task is to write a program that finds the sequence $REP(sks(n))$ given $REP(n)$.\n\n", "inputFormat": "The first line of the standard input holds one integer $k$  ($1\\le k\\le 1\\ 000\\ 000$) denoting the length of the succinct representation      of a positive integer $n$.\n\nThe second line of the standard input holds $k$ integers $x_1,x_2,\\cdots,x_k$  ($0<x_i\\le 1\\ 000\\ 000\\ 000$), separated by single spaces.\n\nThe sequence $x_1,x_2,\\cdots,x_k$ forms the succinct representation of the number $n$.\n\nYou may assume that $x_1+x_2+\\cdots+x_k\\le 1\\ 000\\ 000\\ 000$, i.e., $0<n<2^{1\\ 000\\ 000\\ 000}$.\n", "outputFormat": "Your program is to print out two lines to the standard output.\n\nThe first one should contain a single positive integer $l$.\n\nThe second line should hold $l$ positive integers $y_1,y_2,\\cdots,y_l$,      separated by single spaces.\n\nThe sequence $y_1,y_2,\\cdots,y_l$ is to form the succinct representation of $sks(n)$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2010] JED-Ones", "background": "", "description": "Let $x$ be a sequence of zeros and ones.\n\nAn utterly forlorn one (UFO) in $x$ is the extreme (either first or last) one    that additionally does not neighbour with any other one.\n\nFor instance, the sequence 10001010 has two UFOs,    while the sequence 1101011000 has no UFO,    and the sequence 1000 has only one UFO.\n\nLet us denote the total number of UFOs in the binary representations of the numbers    from 1 to $n$ with $sks(n)$.\n\nFor example,    $sks(5)=5$, $sks(64)=59$, $sks(128)=122$, $sks(256)=249$.\n\nWe will be working with very large numbers.\n\n```plain\nTherefore, we shall represent them in a succinct way.\n```\nSuppose $x$ is a positive integer and $x_2$ is its binary representation    (starting with 1). Then the succinct representation of $x$ is the sequence    $REP(x)$ consisting of positive integers denoting the lengths of successive    blocks of the same digits.\n\nFor example:\n\n$REP(460\\ 288)=REP(1110000011000000000_2)=(3,5,2,9)$ $REP(408)=REP(110011000_2)=(2,2,2,3)$  \n\nYour task is to write a program that finds the sequence $REP(sks(n))$ given $REP(n)$.\n\n", "inputFormat": "The first line of the standard input holds one integer $k$  ($1\\le k\\le 1\\ 000\\ 000$) denoting the length of the succinct representation      of a positive integer $n$.\n\nThe second line of the standard input holds $k$ integers $x_1,x_2,\\cdots,x_k$  ($0<x_i\\le 1\\ 000\\ 000\\ 000$), separated by single spaces.\n\nThe sequence $x_1,x_2,\\cdots,x_k$ forms the succinct representation of the number $n$.\n\nYou may assume that $x_1+x_2+\\cdots+x_k\\le 1\\ 000\\ 000\\ 000$, i.e., $0<n<2^{1\\ 000\\ 000\\ 000}$.\n", "outputFormat": "Your program is to print out two lines to the standard output.\n\nThe first one should contain a single positive integer $l$.\n\nThe second line should hold $l$ positive integers $y_1,y_2,\\cdots,y_l$,      separated by single spaces.\n\nThe sequence $y_1,y_2,\\cdots,y_l$ is to form the succinct representation of $sks(n)$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2010] JED-Ones", "background": "", "description": "设 $x$ 是一个由 $\\texttt{01}$ 组成的序列。一个 UFO 指的是序列中第一个 $1$ 或者最后一个 $1$ 且不和任何一个 $1$ 相邻。例如 $\\texttt{10001010}$ 有两个 UFO，$\\texttt{1101011000}$ 没有 UFO，$\\texttt{1000}$ 只有一个 UFO。\n\n设 $1$ 到 $n$ 的数的二进制表示中 UFO 的总数为 $sks(n)$。例如，$sks(5)=5, sks(64)=59, sks(128)=122, sks(256)=249$.\n\n我们需要处理非常大的数字。因此 $n$ 会用压缩的形式表示。设 $x$ 是一个正整数 $x_2$ 是其二进制表示（最高位为 $1$），则该数的压缩形式 $REP(x)$ 为一个序列，表示连续相同数位的数量。例如：\n\n$$REP(460288)=REP(1110000011000000000_2)=(3,5,2,9)$$\n\n$$REP(408)=REP(110011000_2)=(2,2,2,3)$$  \n\n已知 $REP(n)$，求 $REP(sks(n))$。", "inputFormat": "第一行有一个整数 $k$，表示一个正整数 $n$ 的压缩形式。  \n接下来一行有 $k$ 个整数 $x _ 1, x _ 2, \\cdots, x _ k$，用空格分隔，表示 $n$ 的压缩形式的序列。保证 $x _ 1 + x _ 2 + \\cdots + x _ k \\le 10 ^ 9$，也就是说 $0<n< 2 ^ {10 ^ 9}$。", "outputFormat": "输出两行，第一行有一个正整数 $l$，第二行有 $l$ 个正整数，用空格分隔，表示 $sks(n)$ 的压缩形式。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3511", "type": "P", "difficulty": 6, "samples": [["4 4\n1 2 2 4\n2 3 3 4\n3 4 4 4\n4 1 5 4", "4\n4 3 2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "二分", "POI（波兰）", "网络流", "Special Judge", "欧拉回路"], "title": "[POI 2010] MOS-Bridges", "background": "", "description": "San Bytecisco is a beautifully situated coastal town. It consists of n small, yet densely populated islands, numbered from 1 to n. Certain islands are connected with bridges, used for (bidirectional) road traffic. Each pair of islands can be connected with at most one bridge. The islands are connected in such a way that every island can be reached from every other by using the bridges only.\n\nByteasar and Bytie are going for a bike trip in San Bytecisco. The will start their ride at the island no. 1. They intend to visit every island, while passing along every bridge once and ending the trip where it began, i.e., the island no. 1. Being quite seasoned riders, they expect some serious trouble from... the wind! After all, it is very windy along the coast, and especially so on the bridges between the islands. Obviously, depending on its speed and direction, the wind makes it hard to cross the bridge in different extent for either direction. For simplicity we will assume for every bridge and direction of crossing, the opposing wind speed is constant.\n\nHelp Byteasar and Bytie to find a route as they desire that will in addition be the least tiresome. Byteasar and Bytie agreed on the maximum opposing wind speed as a measure of a route's tiresomeness.", "inputFormat": "In the first line of the standard input there are two integers separated by a single space: $n$ and $m$ ($2 \\le n \\le 1000$, $1 \\le m \\le 2000$), denoting the number of islands and the number of bridges in San Bytecisco respectively. The islands are numbered from 1 to n, while the bridges from 1 to m. The following  lines specify the bridges. The line no.($n+1$)  contains four integers $a_i,b_i,l_i,p_i$ ($1\\le l_i,p_i \\le 1000$), separated by single spaces. These denote that the bridge no. $i$ connects the islands no. $a$ and $b$. The opposing wind speeds are  when one goes moves from  to , and  if one goes from $a$ to $b$.", "outputFormat": "If there is no route satisfying the requirements of the daring two riders,   the first and only line of the standard output should hold the word NIE   (no in Polish).\n\nOtherwise, the output should have two lines, specifying the least tiresome route   over San Bytecisco.\n\nThe first line should hold the maximum opposing wind speed for that route, i.e.,   the number we wish to minimize.\n\nThe second line should hold ![](http://main.edu.pl/images/OI17/mos-en-tex.28.png) integers, separated by single spaces, giving   the numbers of successive bridges one crosses on the least tiresome route.\n\nShould there be more than one least tiresome route, your program can pick one   arbitrarily.\n", "hint": "$2 \\le n \\le 1000$，$1 \\le m \\le 2000$，$1 \\le a_i,b_i \\le n$，$a_i \\neq b_i$，$1 \\le l_i,p_i \\le 1000$\n", "locale": "en", "translations": {"en": {"title": "[POI 2010] MOS-Bridges", "background": "", "description": "San Bytecisco is a beautifully situated coastal town. It consists of n small, yet densely populated islands, numbered from 1 to n. Certain islands are connected with bridges, used for (bidirectional) road traffic. Each pair of islands can be connected with at most one bridge. The islands are connected in such a way that every island can be reached from every other by using the bridges only.\n\nByteasar and Bytie are going for a bike trip in San Bytecisco. The will start their ride at the island no. 1. They intend to visit every island, while passing along every bridge once and ending the trip where it began, i.e., the island no. 1. Being quite seasoned riders, they expect some serious trouble from... the wind! After all, it is very windy along the coast, and especially so on the bridges between the islands. Obviously, depending on its speed and direction, the wind makes it hard to cross the bridge in different extent for either direction. For simplicity we will assume for every bridge and direction of crossing, the opposing wind speed is constant.\n\nHelp Byteasar and Bytie to find a route as they desire that will in addition be the least tiresome. Byteasar and Bytie agreed on the maximum opposing wind speed as a measure of a route's tiresomeness.", "inputFormat": "In the first line of the standard input there are two integers separated by a single space: $n$ and $m$ ($2 \\le n \\le 1000$, $1 \\le m \\le 2000$), denoting the number of islands and the number of bridges in San Bytecisco respectively. The islands are numbered from 1 to n, while the bridges from 1 to m. The following  lines specify the bridges. The line no.($n+1$)  contains four integers $a_i,b_i,l_i,p_i$ ($1\\le l_i,p_i \\le 1000$), separated by single spaces. These denote that the bridge no. $i$ connects the islands no. $a$ and $b$. The opposing wind speeds are  when one goes moves from  to , and  if one goes from $a$ to $b$.", "outputFormat": "If there is no route satisfying the requirements of the daring two riders,   the first and only line of the standard output should hold the word NIE   (no in Polish).\n\nOtherwise, the output should have two lines, specifying the least tiresome route   over San Bytecisco.\n\nThe first line should hold the maximum opposing wind speed for that route, i.e.,   the number we wish to minimize.\n\nThe second line should hold ![](http://main.edu.pl/images/OI17/mos-en-tex.28.png) integers, separated by single spaces, giving   the numbers of successive bridges one crosses on the least tiresome route.\n\nShould there be more than one least tiresome route, your program can pick one   arbitrarily.\n", "hint": "$2 \\le n \\le 1000$，$1 \\le m \\le 2000$，$1 \\le a_i,b_i \\le n$，$a_i \\neq b_i$，$1 \\le l_i,p_i \\le 1000$\n", "locale": "en"}, "zh-CN": {"title": "[POI 2010] MOS-Bridges", "background": "", "description": "San Bytecisco 是一个风景优美的沿海小镇。\n\n它由一些小而人口稠密的岛屿组成，编号从 $1$ 到 $n$。\n\n某些岛屿之间通过桥梁连接，用于双向的道路交通。\n\n每对岛屿之间最多可以有一座桥。\n\n这些岛屿的连接方式使得每个岛屿都可以通过桥梁到达其他岛屿。\n\nByteasar 和 Bytie 正计划在 San Bytecisco 骑自行车旅行。\n\n他们将从 $1$ 号岛出发。\n\n他们打算访问每个岛屿，同时每座桥只经过一次，并在旅行结束时回到出发地，即 $1$ 号岛。\n\n作为经验丰富的骑手，他们预计会遇到一些严重的麻烦……风！\n\n毕竟，沿海地区风很大，尤其是在岛屿之间的桥上。显然，根据风速和方向，风会在不同程度上使得跨越桥梁变得困难。\n\n为了简单起见，我们假设每座桥和每个跨越方向的逆风速度是恒定的。\n\n帮助 Byteasar 和 Bytie 找到他们想要的路线，并且这条路线的疲劳程度最小。Byteasar 和 Bytie 同意将最大逆风速度作为路线疲劳程度的衡量标准。", "inputFormat": "标准输入的第一行有两个用空格分隔的整数：$n$ 和 $m$（$2 \\le n \\le 1000$，$1 \\le m \\le 2000$），分别表示 San Bytecisco 的岛屿数量和桥梁数量。岛屿编号从 1 到 $n$，桥梁编号从 1 到 $m$。接下来的行指定了桥梁。第 ($n+1$) 行包含四个用空格分隔的整数 $a_i,b_i,l_i,p_i$（$1 \\le l_i,p_i \\le 1000$），表示第 $i$ 号桥连接了第 $a$ 号和第 $b$ 号岛屿。当从 $a$ 到 $b$ 移动时的逆风速度为 $l_i$，而从 $b$ 到 $a$ 移动时的逆风速度为 $p_i$。", "outputFormat": "如果没有满足这两位勇敢骑手要求的路线，标准输出的第一行应为单词 NIE（波兰语中的“不”）。\n\n否则，输出应有两行，指定 San Bytecisco 上最不疲劳的路线。\n\n第一行应包含该路线的最大逆风速度，即我们希望最小化的数字。\n\n第二行应包含 $m$ 个整数，用空格分隔，给出在最不疲劳的路线中依次经过的桥梁编号。\n\n如果有多条最不疲劳的路线，程序可以任意选择一条。", "hint": "$2 \\le n \\le 1000$，$1 \\le m \\le 2000$，$1 \\le a_i,b_i \\le n$，$a_i\\neq b_i$，$1 \\le l_i,p_i \\le 1000$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
