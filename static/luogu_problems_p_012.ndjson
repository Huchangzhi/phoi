{"pid": "P4038", "type": "P", "difficulty": 4, "samples": [["1 2 1\n2 3 2\n3 1 6\n1 2 5\n2 3 3\n3 1 4\n0 0\n1 2 1\n2 3 2\n1 3 3\n2 4 4\n0 0\n0 0", "1 2 3 5 4 6\nRound trip does not exist."]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["图论", "Special Judge", "欧拉回路", "ICPC", "CERC"], "title": "[CERC 1995] John's Trip", "background": "", "description": "John 有很多朋友住在不同的街，John 想去访问每位朋友，同时希望走的路最少。因为道路很窄，John 在一条路上不能往回走。John 希望从家里出发，拜访完所有的朋友后回到自己的家，且总的路程最短。John 意识到如果可以每条道路都只走一次然后返回起点应该是最短的路径。写一个程序帮助 John 找到这样的路径。给出的每条街连接两个路口。街分别编号为 $1$ 到 $n$，路口分别编号为 $1$ 到 $m$。", "inputFormat": "多组数据。  \n\n每组数据有多行，每行由三个整数组成：$x,y,z$。$z$ 为这条街的编号，$x$ 和 $y$ 表示这条街连接的两个路口的编号。可能有自环。  \n\n对于每组数据，John 住在第一行中连接的两个顶点中编号较小的路口处。所有的街都可以连通到其他街上。`0 0` 表示一组数据的结束。  \n\n再一个`0 0`表示输入的结束。", "outputFormat": "如果能找到所有街道遍历一次的回路，输出找到的路径，两个整数之间用一个空格隔开，行末无空格。如果不存在，输出`Round trip does not exist.`。", "hint": "最多有 $1995$ 条街，最多 $44$ 个路口。", "locale": "zh-CN", "translations": {"en": {"title": "[CERC 1995] John's Trip", "background": "", "description": "John has many friends living on different streets and wants to visit each friend while traveling as little as possible. Because the streets are narrow, John cannot go back along the same street. He wants to start from his home, visit all his friends, and return home, with the minimum total distance. John realizes that if he can traverse each street exactly once and return to the starting point, that should be the shortest route. Write a program to help John find such a route. Each street connects two intersections. The streets are numbered from $1$ to $n$, and the intersections are numbered from $1$ to $m$.", "inputFormat": "Multiple testcases.  \n\nEach testcase consists of several lines, each line containing three integers: $x, y, z$. Here, $z$ is the index of the street, and $x$ and $y$ are the indices of the two intersections that the street connects. Self-loops may appear.  \n\nFor each testcase, John lives at the intersection with the smaller index among the two intersections listed on the first line. The graph is connected.  \n\nA line containing two integers `0 0` ends the current testcase. Two consecutive lines `0 0` indicate the end of input.", "outputFormat": "If there exists a circuit that traverses every street exactly once, output the route found as a sequence of street indices in the traversal order, with a single space between adjacent integers and no trailing space at the end of the line. Otherwise, output `Round trip does not exist.`.", "hint": "At most $1995$ streets and at most $44$ intersections.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC 1995] John's Trip", "background": "", "description": "John 有很多朋友住在不同的街，John 想去访问每位朋友，同时希望走的路最少。因为道路很窄，John 在一条路上不能往回走。John 希望从家里出发，拜访完所有的朋友后回到自己的家，且总的路程最短。John 意识到如果可以每条道路都只走一次然后返回起点应该是最短的路径。写一个程序帮助 John 找到这样的路径。给出的每条街连接两个路口。街分别编号为 $1$ 到 $n$，路口分别编号为 $1$ 到 $m$。", "inputFormat": "多组数据。  \n\n每组数据有多行，每行由三个整数组成：$x,y,z$。$z$ 为这条街的编号，$x$ 和 $y$ 表示这条街连接的两个路口的编号。可能有自环。  \n\n对于每组数据，John 住在第一行中连接的两个顶点中编号较小的路口处。所有的街都可以连通到其他街上。`0 0` 表示一组数据的结束。  \n\n再一个`0 0`表示输入的结束。", "outputFormat": "如果能找到所有街道遍历一次的回路，输出找到的路径，两个整数之间用一个空格隔开，行末无空格。如果不存在，输出`Round trip does not exist.`。", "hint": "最多有 $1995$ 条街，最多 $44$ 个路口。", "locale": "zh-CN"}}}
{"pid": "P4039", "type": "P", "difficulty": 7, "samples": [["1\n3 4\n4\n1001\n0000\n0010\n1001\n3\n000\n010\n000\n011\n2\n00\n10\n01\n00", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "各省省选", "江苏", "安徽"], "title": "[AHOI2014/JSOI2014] 拼图", "background": "", "description": "JYY 最近迷上了拼图游戏。作为一个计算机科学家，JYY 有一套黑白色的拼图，他希望通过合理的拼接，使得拼出的最终图案中，能包含面积最大的全白色子矩形。\n\nJYY 一共有 $S$ 块拼图，并且由 $1$ 到 $S$ 编号。编号为 $i$ 的拼图是一个 $N$ 行列的方格矩形，每个方格都为黑色或者白色。一开始 JYY 将他的这 $S$ 块拼图按照编号顺序左右相连依次放在桌上拼成了一个 $N$ 行 $M$ 列（这里 $M=\\sum_{i=1}^S W_i$）的大矩形。\n\n之后 JYY 发现，可以通过改变这 $S$ 块拼图的连接次序，使得拼成的 $N$ 行 $M$ 列的大矩形中，最大全白子矩形面积变大。\n\n现在 JYY 想知道，怎么拼才能得到最大的全白子矩形呢？请你帮助他计算出最佳的拼接方案。", "inputFormat": "第一行包含一个整数 $T$，代表测试数据的组数，接下来按顺序描述了每组测试数据。\n\n每组测试数据的第一行包含两个整数 $S$ 和 $N$。\n\n接下来 $S$ 组输入，第 $i$ 组对应编号为 $i$ 的拼图。\n\n在第 $i$ 组输入中，第一行包含一个整数 $W_i$；\n\n接下来 $N$ 行描述一个 $N$ 行 $W_i$ 列的 $0/1$ 矩形；\n\n其中第 $x$ 行 $y$ 列为 $0$ 则表示该拼图对应位置的颜色是白色，反之则为黑色。", "outputFormat": "对于每组数据输出一行包含一个整数 ans，表示最大可能的全白色子矩形的面积。", "hint": "对于 $100\\%$ 的数据满足$1\\le S,N,W \\le 10^5$，$N\\times \\sum W_i \\le10^5$，$1\\le T\\le3$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2014/JSOI2014] Puzzle", "background": "", "description": "JYY has recently become obsessed with jigsaw puzzles. As a computer scientist, JYY has a set of black-and-white puzzle pieces. He hopes that by concatenating them properly, the final assembled pattern will contain an all-white subrectangle with the largest possible area.\n\nJYY has $S$ puzzle pieces, numbered from $1$ to $S$. The piece numbered $i$ is a grid rectangle with $N$ rows and $W_i$ columns, where each cell is either black or white. At the beginning, JYY places these $S$ pieces on the table side by side from left to right in numerical order, forming a large $N$ by $M$ rectangle (where $M=\\sum_{i=1}^S W_i$).\n\nLater, JYY discovers that by changing the concatenation order of these $S$ pieces, the area of the maximum all-white subrectangle in the resulting $N$ by $M$ rectangle can be increased.\n\nNow JYY wants to know how to arrange the pieces to obtain the largest possible all-white subrectangle. Please help him compute the optimal concatenation order.", "inputFormat": "The first line contains an integer $T$, the number of test cases. The descriptions of the test cases follow.\n\nFor each test case, the first line contains two integers $S$ and $N$.\n\nThen follow $S$ groups of input, where the $i$-th group corresponds to puzzle piece $i$.\n\nIn the $i$-th group, the first line contains an integer $W_i$; then $N$ lines describe a $N$-row by $W_i$-column $0/1$ matrix; if the cell at row $x$, column $y$ is $0$, then the color at that position of the piece is white, otherwise it is black.", "outputFormat": "For each test case, output one line containing a single integer ans, which denotes the area of the largest possible all-white subrectangle.", "hint": "For $100\\%$ of the testdata, $1\\le S,N,W_i \\le 10^5$, $N \\times \\sum W_i \\le 10^5$, $1\\le T\\le 3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2014/JSOI2014] 拼图", "background": "", "description": "JYY 最近迷上了拼图游戏。作为一个计算机科学家，JYY 有一套黑白色的拼图，他希望通过合理的拼接，使得拼出的最终图案中，能包含面积最大的全白色子矩形。\n\nJYY 一共有 $S$ 块拼图，并且由 $1$ 到 $S$ 编号。编号为 $i$ 的拼图是一个 $N$ 行列的方格矩形，每个方格都为黑色或者白色。一开始 JYY 将他的这 $S$ 块拼图按照编号顺序左右相连依次放在桌上拼成了一个 $N$ 行 $M$ 列（这里 $M=\\sum_{i=1}^S W_i$）的大矩形。\n\n之后 JYY 发现，可以通过改变这 $S$ 块拼图的连接次序，使得拼成的 $N$ 行 $M$ 列的大矩形中，最大全白子矩形面积变大。\n\n现在 JYY 想知道，怎么拼才能得到最大的全白子矩形呢？请你帮助他计算出最佳的拼接方案。", "inputFormat": "第一行包含一个整数 $T$，代表测试数据的组数，接下来按顺序描述了每组测试数据。\n\n每组测试数据的第一行包含两个整数 $S$ 和 $N$。\n\n接下来 $S$ 组输入，第 $i$ 组对应编号为 $i$ 的拼图。\n\n在第 $i$ 组输入中，第一行包含一个整数 $W_i$；\n\n接下来 $N$ 行描述一个 $N$ 行 $W_i$ 列的 $0/1$ 矩形；\n\n其中第 $x$ 行 $y$ 列为 $0$ 则表示该拼图对应位置的颜色是白色，反之则为黑色。", "outputFormat": "对于每组数据输出一行包含一个整数 ans，表示最大可能的全白色子矩形的面积。", "hint": "对于 $100\\%$ 的数据满足$1\\le S,N,W \\le 10^5$，$N\\times \\sum W_i \\le10^5$，$1\\le T\\le3$。\n", "locale": "zh-CN"}}}
{"pid": "P4040", "type": "P", "difficulty": 6, "samples": [["32 5 2\n5 0\n10 2", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2014", "各省省选", "江苏", "安徽"], "title": "[AHOI2014/JSOI2014] 宅男计划", "background": "自从迷上了拼图，JYY 就变成了个彻底的宅男。为了解决温饱问题，JYY 不得不依靠叫外卖来维持生计。\n", "description": "外卖店一共有 $n$ 种食物，分别从 $1$ 到 $n$ 编号。第 $i$ 种食物有固定的价钱 $p_i$ 和保质期 $s_i$。第 $i$ 种食物会在 $s_i$ 天后过期。JYY 是不会吃过期食物的。\n\n比如 JYY 如果今天点了一份保质期为 $1$ 天的食物，那么 JYY 必须在今天或者明天把这个食物吃掉，否则这个食物就再也不能吃了。保质期可以为 $0$ 天，这样这份食物就必须在购买当天吃掉。\n\nJYY 现在有 $m$ 块钱，每一次叫外卖需要额外付给送外卖小哥外送费 $f$ 元。\n\n送外卖的小哥身强力壮，可以瞬间给 JYY 带来任意多份食物。JYY 想知道，在满足每天都能吃到至少一顿没过期的外卖的情况下，他可以最多宅多少天呢？\n", "inputFormat": "第一行包含三个整数，分别表示 $m, f, n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行两个整数，第 $(i + 1)$ 行的整数表示第 $i$ 种食物的价格 $p_i$ 和保质期 $s_i$。", "outputFormat": "输出一行一个整数，表示 JYY 可以宅的最多的天数。\n", "hint": "#### 样例输入输出 1 解释\nJYY的最佳策略是：\n- 第一天买一份食物 $1$ 和一份食物 $2$ 并且吃一份食物 $1$；\n- 第二天吃一份食物 $2$；\n- 第三天买一份食物 $1$ 并且吃掉。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 200$，$0 \\leq s_i \\leq 10^{18}$，$1 \\leq f, p_i, m \\leq10^{18}$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2014/JSOI2014] Otaku Plan", "background": "Since becoming obsessed with jigsaw puzzles, JYY has turned into a complete homebody. To make ends meet, JYY has to rely on ordering takeout to survive.", "description": "There are $n$ types of food, numbered from $1$ to $n$. The $i$-th type of food has a fixed price $p_i$ and a shelf life $s_i$. The $i$-th type expires after $s_i$ days. JYY will not eat expired food.\n\nFor example, if JYY orders a food with a shelf life of $1$ day today, then JYY must eat it today or tomorrow; otherwise, this food can no longer be eaten. The shelf life can be $0$ days, in which case the food must be eaten on the day of purchase.\n\nJYY currently has $m$ yuan. Each time he places a takeout order, he must additionally pay a delivery fee of $f$ yuan.\n\nThe delivery person is strong and can instantly bring JYY arbitrarily many portions of food in one order. JYY wants to know, while ensuring that he can eat at least one unexpired takeout meal every day, for how many days at most can he stay at home.", "inputFormat": "The first line contains three integers, representing $m, f, n$.\n\nLines $2$ to $(n + 1)$ each contain two integers; in line $(i + 1)$, the integers denote the price $p_i$ and the shelf life $s_i$ of the $i$-th type of food.", "outputFormat": "Output a single integer in one line, representing the maximum number of days JYY can stay at home.", "hint": "#### Explanation of Sample Input/Output 1\nJYY’s best strategy is:\n- On day 1, buy one portion of food $1$ and one portion of food $2$, and eat one portion of food $1$.\n- On day 2, eat one portion of food $2$.\n- On day 3, buy one portion of food $1$ and eat it.\n\n#### Constraints\nFor all test points, it is guaranteed that $1 \\leq n \\leq 200$, $0 \\leq s_i \\leq 10^{18}$, $1 \\leq f, p_i, m \\leq 10^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2014/JSOI2014] 宅男计划", "background": "自从迷上了拼图，JYY 就变成了个彻底的宅男。为了解决温饱问题，JYY 不得不依靠叫外卖来维持生计。\n", "description": "外卖店一共有 $n$ 种食物，分别从 $1$ 到 $n$ 编号。第 $i$ 种食物有固定的价钱 $p_i$ 和保质期 $s_i$。第 $i$ 种食物会在 $s_i$ 天后过期。JYY 是不会吃过期食物的。\n\n比如 JYY 如果今天点了一份保质期为 $1$ 天的食物，那么 JYY 必须在今天或者明天把这个食物吃掉，否则这个食物就再也不能吃了。保质期可以为 $0$ 天，这样这份食物就必须在购买当天吃掉。\n\nJYY 现在有 $m$ 块钱，每一次叫外卖需要额外付给送外卖小哥外送费 $f$ 元。\n\n送外卖的小哥身强力壮，可以瞬间给 JYY 带来任意多份食物。JYY 想知道，在满足每天都能吃到至少一顿没过期的外卖的情况下，他可以最多宅多少天呢？\n", "inputFormat": "第一行包含三个整数，分别表示 $m, f, n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行两个整数，第 $(i + 1)$ 行的整数表示第 $i$ 种食物的价格 $p_i$ 和保质期 $s_i$。", "outputFormat": "输出一行一个整数，表示 JYY 可以宅的最多的天数。\n", "hint": "#### 样例输入输出 1 解释\nJYY的最佳策略是：\n- 第一天买一份食物 $1$ 和一份食物 $2$ 并且吃一份食物 $1$；\n- 第二天吃一份食物 $2$；\n- 第三天买一份食物 $1$ 并且吃掉。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 200$，$0 \\leq s_i \\leq 10^{18}$，$1 \\leq f, p_i, m \\leq10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P4041", "type": "P", "difficulty": 6, "samples": [["5 1 6\n+ 5\n- 3\n* 2\n- 7\n@ 2\n3\n2\n1\n5", "5\n3\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "线段树", "各省省选", "江苏", "安徽"], "title": "[AHOI2014/JSOI2014] 奇怪的计算器", "background": "JYY 有个奇怪的计算器，有一天这个计算器坏了，JYY 希望你能帮助他写一个程序来模拟这个计算器的运算。", "description": "JYY 的计算器可以执行 $N$ 条预设好的指令。每次 JYY 向计算器输入一个正整数 $X$，计算器就会以 $X$ 作为初始值，接着依次执行预设的 $N$ 条指令，最后把最终得出的结果返回给 JYY。\n\n每一条指令可以是以下四种指令之一：（这里 $a$ 表示一个正整数。）\n\n1. $+a$：表示将当前的结果加上 $a$；\n2. $-a$：表示将当前的结果减去 $a$；\n3. $\\times a$：表示将当前的结果乘以 $a$；\n4. $@a$：表示将当前的结果加上 $a\\times X$（$X$ 是一开始 JYY 输入的数）。\n\n计算器用于记录运算结果的变量的存储范围是有限的，所以每次运算结束之后会有计算结果溢出的问题。\n\nJYY 的计算器中，存储每计算结果的变量只能存储 $L$ 到 $R$ 之间的正整数，如果一次指令执行过后，计算结果超过了 $R$，那么计算器就会自动把结果变成 $R$，然后再以 $R$ 作为当前结果继续进行之后的计算。同理，如果运算结果小于 $L$，计算器也会把结果变成 $L$，再接着计算。\n\n比如，假设计算器可以存储 $1$ 到 $6$ 之间的值，如果当前的计算结果是 $2$，那么在执行 $+5$ 操作之后，存储结果的变量中的值将会是 $6$。虽然 $2+5$ 的实际结果是 $7$，但是由于 $7$ 超过了存储范围的上界，所以结果就被自动更正成了上界的大小，也就是 $6$。\n\nJYY 一共想在计算器上输入 $Q$ 个值，他想知道这 $Q$ 个值输入计算器之后，分别会得到什么结果呢？", "inputFormat": "第一行包含三个正整数，$N$，$L$ 和 $R$。\n\n接下来 $N$ 行，每行一个指令，每个指令如题述，由一个字符和一个正整数组成，字符和正整数中间有一个空格隔开。\n\n第 $N+2$ 行包含一个整数 $Q$，表示 JYY 希望输入的数的数量。\n\n第接下来 $Q$ 行每行一个正整数，第 $k$ 个正整数 $X_k$ 表示 JYY 在第 $k$ 次输入的整数。", "outputFormat": "输出 $Q$ 行每行一个正整数，第 $k$ 行的整数表示输入 $X_k$ 后，依次经过 $N$ 个指令进行计算所得到的结果。", "hint": "### 样例解释\n\n当 JYY 输入 $2$ 时，计算器会进行 $5$ 次运算，每一次运算之后得到的结果分别是 $6$（实际计算结果为 $7$ 但是超过了上界），$3,6,1$（实际结果为 $-1$ 但是低于了下界）和 $5$（由于一开始输入的是 $2$，所以这一次计算为 $1+2 \\times 2$）。\n\n### 数据范围及约定\n\n对于所有测试数据，$1\\le N$，$Q\\le 10^5$，$1\\le L\\le X_k\\le R\\le 10^9$，$1\\le a\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2014/JSOI2014] Strange Calculator", "background": "JYY has a strange calculator. One day it broke, and JYY hopes you can help him write a program to simulate this calculator’s operations.", "description": "JYY’s calculator can execute $N$ preset instructions. Each time JYY inputs a positive integer $X$, the calculator uses $X$ as the initial value, then executes the $N$ preset instructions in order, and finally returns the resulting value to JYY.\n\nEach instruction is one of the following four types (here $a$ denotes a positive integer):\n1. $+a$: add $a$ to the current result.\n2. $-a$: subtract $a$ from the current result.\n3. $\\times a$: multiply the current result by $a$.\n4. $@a$: add $a \\times X$ to the current result (where $X$ is the number JYY initially input).\n\nThe variable that stores the computation result has a limited range, so overflow may occur after each computation.\n\nIn JYY’s calculator, the result variable can only store positive integers between $L$ and $R$. If after executing an instruction the result exceeds $R$, the calculator will automatically change it to $R$, then continue from $R$. Similarly, if the result is less than $L$, the calculator will change it to $L$, then continue computing.\n\nFor example, suppose the calculator can store values from $1$ to $6$. If the current result is $2$, then after executing $+5$, the stored value will be $6$. Although the actual result $2+5$ is $7$, since $7$ exceeds the upper bound, the result is clamped to the upper bound $6$.\n\nJYY plans to input $Q$ values into the calculator and wants to know what result each input will produce.", "inputFormat": "The first line contains three positive integers $N$, $L$, and $R$.\n\nThe next $N$ lines each contain one instruction. Each instruction, as described above, consists of one symbol and one positive integer, separated by a space.\n\nThe $(N+2)$-th line contains an integer $Q$, the number of values JYY will input.\n\nThe next $Q$ lines each contain a positive integer. The $k$-th positive integer $X_k$ is the integer JYY inputs on the $k$-th time.", "outputFormat": "Output $Q$ lines, each with a positive integer. The integer on the $k$-th line is the result obtained after inputting $X_k$ and then executing the $N$ instructions in order.", "hint": "Sample Explanation\n\nWhen JYY inputs $2$, the calculator performs $5$ operations. After each operation, the results are $6$ (the actual result is $7$ but it exceeds the upper bound), $3$, $6$, $1$ (the actual result is $-1$ but it is below the lower bound), and $5$ (since the initial input was $2$, this step computes $1 + 2 \\times 2$).\n\nConstraints\n\nFor all testdata, $1 \\le N, Q \\le 10^5$, $1 \\le L \\le X_k \\le R \\le 10^9$, $1 \\le a \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2014/JSOI2014] 奇怪的计算器", "background": "JYY 有个奇怪的计算器，有一天这个计算器坏了，JYY 希望你能帮助他写一个程序来模拟这个计算器的运算。", "description": "JYY 的计算器可以执行 $N$ 条预设好的指令。每次 JYY 向计算器输入一个正整数 $X$，计算器就会以 $X$ 作为初始值，接着依次执行预设的 $N$ 条指令，最后把最终得出的结果返回给 JYY。\n\n每一条指令可以是以下四种指令之一：（这里 $a$ 表示一个正整数。）\n\n1. $+a$：表示将当前的结果加上 $a$；\n2. $-a$：表示将当前的结果减去 $a$；\n3. $\\times a$：表示将当前的结果乘以 $a$；\n4. $@a$：表示将当前的结果加上 $a\\times X$（$X$ 是一开始 JYY 输入的数）。\n\n计算器用于记录运算结果的变量的存储范围是有限的，所以每次运算结束之后会有计算结果溢出的问题。\n\nJYY 的计算器中，存储每计算结果的变量只能存储 $L$ 到 $R$ 之间的正整数，如果一次指令执行过后，计算结果超过了 $R$，那么计算器就会自动把结果变成 $R$，然后再以 $R$ 作为当前结果继续进行之后的计算。同理，如果运算结果小于 $L$，计算器也会把结果变成 $L$，再接着计算。\n\n比如，假设计算器可以存储 $1$ 到 $6$ 之间的值，如果当前的计算结果是 $2$，那么在执行 $+5$ 操作之后，存储结果的变量中的值将会是 $6$。虽然 $2+5$ 的实际结果是 $7$，但是由于 $7$ 超过了存储范围的上界，所以结果就被自动更正成了上界的大小，也就是 $6$。\n\nJYY 一共想在计算器上输入 $Q$ 个值，他想知道这 $Q$ 个值输入计算器之后，分别会得到什么结果呢？", "inputFormat": "第一行包含三个正整数，$N$，$L$ 和 $R$。\n\n接下来 $N$ 行，每行一个指令，每个指令如题述，由一个字符和一个正整数组成，字符和正整数中间有一个空格隔开。\n\n第 $N+2$ 行包含一个整数 $Q$，表示 JYY 希望输入的数的数量。\n\n第接下来 $Q$ 行每行一个正整数，第 $k$ 个正整数 $X_k$ 表示 JYY 在第 $k$ 次输入的整数。", "outputFormat": "输出 $Q$ 行每行一个正整数，第 $k$ 行的整数表示输入 $X_k$ 后，依次经过 $N$ 个指令进行计算所得到的结果。", "hint": "### 样例解释\n\n当 JYY 输入 $2$ 时，计算器会进行 $5$ 次运算，每一次运算之后得到的结果分别是 $6$（实际计算结果为 $7$ 但是超过了上界），$3,6,1$（实际结果为 $-1$ 但是低于了下界）和 $5$（由于一开始输入的是 $2$，所以这一次计算为 $1+2 \\times 2$）。\n\n### 数据范围及约定\n\n对于所有测试数据，$1\\le N$，$Q\\le 10^5$，$1\\le L\\le X_k\\le R\\le 10^9$，$1\\le a\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4042", "type": "P", "difficulty": 5, "samples": [["4\n4 27 3 2 3 2\n3 5 1 2\n1 13 2 4 2\n5 6 1 2", "26"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "图论", "2014", "各省省选", "江苏", "安徽", "最短路"], "title": "[AHOI2014/JSOI2014] 骑士游戏", "background": "长期的宅男生活中，JYY 又挖掘出了一款 RPG 游戏。在这个游戏中 JYY 会扮演一个英勇的骑士，用他手中的长剑去杀死入侵村庄的怪兽。", "description": "在这个游戏中，JYY 一共有两种攻击方式，一种是普通攻击，一种是法术攻击。两种攻击方式都会消耗 JYY 一些体力。采用普通攻击进攻怪兽并不能把怪兽彻底杀死，怪兽的尸体可以变出其他一些新的怪兽，注意一个怪兽可能经过若干次普通攻击后变回一个或更多同样的怪兽；而采用法术攻击则可以彻底将一个怪兽杀死。当然了，一般来说，相比普通攻击，法术攻击会消耗更多的体力值（但由于游戏系统 bug，并不保证这一点）。\n\n游戏世界中一共有 $N$ 种不同的怪兽，分别由 $1$ 到 $N$ 编号，现在 $1$ 号怪兽入侵村庄了，JYY 想知道，最少花费多少体力值才能将所有村庄中的怪兽全部杀死呢？", "inputFormat": "第一行包含一个整数 $N$。\n\n接下来 $N$ 行，每行描述一个怪兽的信息；\n\n其中第 $i$ 行包含若干个整数，前三个整数为 $S_i$，$K_i$ 和 $R_i$，表示对于 $i$ 号怪兽，普通攻击需要消耗 $S_i$ 的体力，法术攻击需要消耗 $K_i$ 的体力，同时 $i$ 号怪兽死亡后会产生 $R_i$ 个新的怪兽。表示一个新出现的怪兽编号。同一编号的怪兽可以出现多个。", "outputFormat": "输出一行一个整数，表示最少需要的体力值。\n", "hint": "首先用消耗 $4$ 点体力用普通攻击，然后出现的怪兽编号是 $2$，$2$ 和 $3$。花费 $10$ 点体力用法术攻击杀死两个编号为 $2$ 的怪兽。剩下 $3$ 号怪兽花费 $1$ 点体力进行普通攻击。此时村庄里的怪兽编号是 $2$ 和 $4$。最后花费 $11$ 点体力用法术攻击将这两只怪兽彻底杀死。一共花费的体力是 $4+5+5+1+5+6=26$。\n\n对于所有数据 $2 \\le N \\le 2 \\times 10^5$，$1 \\le R_i,\\sum R_i \\le 10^6$，$1 \\le K_i,S_i \\le 5 \\times 10^{14}$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2014/JSOI2014] Knight Game", "background": "In his long homebody life, JYY dug up an RPG game. In this game, JYY plays a brave knight who uses his longsword to kill monsters invading the village.", "description": "In this game, JYY has two attack types: a normal attack and a spell attack. Both consume some of JYY’s stamina. Using a normal attack on a monster does not completely kill it; the monster’s corpse can transform into some new monsters. Note that after several normal attacks, a monster may turn into one or more monsters of the same type again. A spell attack, however, can permanently kill a monster. Of course, in general, compared with a normal attack, a spell attack consumes more stamina (but due to a game system bug, this is not guaranteed).\n\nThere are $N$ different kinds of monsters in the game world, numbered from $1$ to $N$. Now a monster of type $1$ has invaded the village. JYY wants to know the minimum stamina needed to kill all monsters in the village.", "inputFormat": "The first line contains an integer $N$.\n\nThen $N$ lines follow, each describing one monster type.\n\nThe $i$-th line contains several integers. The first three integers are $S_i$, $K_i$, and $R_i$, meaning: for monster type $i$, a normal attack costs $S_i$ stamina, a spell attack costs $K_i$ stamina, and after monster $i$ dies (by a normal attack), it spawns $R_i$ new monsters. After these three integers, there are exactly $R_i$ more integers, each giving the type number of one newly spawned monster. The same type number may appear multiple times.", "outputFormat": "Output one integer on a single line: the minimum stamina required.", "hint": "First use a normal attack costing $4$ stamina, and the spawned monster types are $2$, $2$, and $3$. Spend $10$ stamina using spell attacks to kill the two monsters of type $2$. For the remaining type $3$ monster, use a normal attack costing $1$ stamina. Now the monsters in the village are of types $2$ and $4$. Finally, spend $11$ stamina using spell attacks to permanently kill these two monsters. The total stamina spent is $4 + 5 + 5 + 1 + 5 + 6 = 26$.\n\nConstraints: For all testdata, $2 \\le N \\le 2 \\times 10^5$, $1 \\le R_i, \\sum R_i \\le 10^6$, $1 \\le K_i, S_i \\le 5 \\times 10^{14}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2014/JSOI2014] 骑士游戏", "background": "长期的宅男生活中，JYY 又挖掘出了一款 RPG 游戏。在这个游戏中 JYY 会扮演一个英勇的骑士，用他手中的长剑去杀死入侵村庄的怪兽。", "description": "在这个游戏中，JYY 一共有两种攻击方式，一种是普通攻击，一种是法术攻击。两种攻击方式都会消耗 JYY 一些体力。采用普通攻击进攻怪兽并不能把怪兽彻底杀死，怪兽的尸体可以变出其他一些新的怪兽，注意一个怪兽可能经过若干次普通攻击后变回一个或更多同样的怪兽；而采用法术攻击则可以彻底将一个怪兽杀死。当然了，一般来说，相比普通攻击，法术攻击会消耗更多的体力值（但由于游戏系统 bug，并不保证这一点）。\n\n游戏世界中一共有 $N$ 种不同的怪兽，分别由 $1$ 到 $N$ 编号，现在 $1$ 号怪兽入侵村庄了，JYY 想知道，最少花费多少体力值才能将所有村庄中的怪兽全部杀死呢？", "inputFormat": "第一行包含一个整数 $N$。\n\n接下来 $N$ 行，每行描述一个怪兽的信息；\n\n其中第 $i$ 行包含若干个整数，前三个整数为 $S_i$，$K_i$ 和 $R_i$，表示对于 $i$ 号怪兽，普通攻击需要消耗 $S_i$ 的体力，法术攻击需要消耗 $K_i$ 的体力，同时 $i$ 号怪兽死亡后会产生 $R_i$ 个新的怪兽。表示一个新出现的怪兽编号。同一编号的怪兽可以出现多个。", "outputFormat": "输出一行一个整数，表示最少需要的体力值。\n", "hint": "首先用消耗 $4$ 点体力用普通攻击，然后出现的怪兽编号是 $2$，$2$ 和 $3$。花费 $10$ 点体力用法术攻击杀死两个编号为 $2$ 的怪兽。剩下 $3$ 号怪兽花费 $1$ 点体力进行普通攻击。此时村庄里的怪兽编号是 $2$ 和 $4$。最后花费 $11$ 点体力用法术攻击将这两只怪兽彻底杀死。一共花费的体力是 $4+5+5+1+5+6=26$。\n\n对于所有数据 $2 \\le N \\le 2 \\times 10^5$，$1 \\le R_i,\\sum R_i \\le 10^6$，$1 \\le K_i,S_i \\le 5 \\times 10^{14}$。\n", "locale": "zh-CN"}}}
{"pid": "P4043", "type": "P", "difficulty": 6, "samples": [["6\n2 2 1 3 2\n2 4 3 5 4\n2 5 5 6 6\n0\n0\n0", "24"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "各省省选", "网络流", "江苏", "安徽", "上下界网络流", "费用流"], "title": "[AHOI2014/JSOI2014] 支线剧情", "background": "宅男 JYY 非常喜欢玩 RPG 游戏，比如仙剑，轩辕剑等等。不过 JYY 喜欢的并不是战斗场景，而是类似电视剧一般的充满恩怨情仇的剧情。这些游戏往往都有很多的支线剧情，现在 JYY 想花费最少的时间看完所有的支线剧情。", "description": "JYY 现在所玩的 RPG 游戏中，一共有 $N$ 个剧情点，由 $1$ 到 $N$ 编号，第 $i$ 个剧情点可以根据 JYY 的不同的选择，而经过不同的支线剧情，前往 $K_i$ 种不同的新的剧情点。当然如果为 $0$，则说明 $i$ 号剧情点是游戏的一个结局了。\n\nJYY 观看一个支线剧情需要一定的时间。JYY 一开始处在 $1$ 号剧情点，也就是游戏的开始。显然任何一个剧情点都是从 $1$ 号剧情点可达的。此外，随着游戏的进行，剧情是不可逆的。所以游戏保证从任意剧情点出发，都不能再回到这个剧情点。由于 JYY 过度使用修改器，导致游戏的“存档”和“读档”功能损坏了，\n\n所以 JYY 要想回到之前的剧情点，唯一的方法就是退出当前游戏，并开始新的游戏，也就是回到 $1$ 号剧情点。JYY 可以在任何时刻退出游戏并重新开始。不断开始新的游戏重复观看已经看过的剧情是很痛苦，JYY 希望花费最少的时间，看完所有不同的支线剧情。", "inputFormat": "输入一行包含一个正整数 $N$。\n\n接下来 $N$ 行，第 $i$ 行为 $i$ 号剧情点的信息；\n\n第一个整数为 $K_i$，接下来 $K_i$ 个整数对，$b_{i,j}$ 和 $t_{i,j}$，表示从剧情点 $i$ 可以前往剧情点 $b_{i,j}$，并且观看这段支线剧情需要花费 $t_{i,j}$ 的时间。", "outputFormat": "输出一行包含一个整数，表示 JYY 看完所有支线剧情所需要的最少时间。", "hint": "### 样例解释\n\nJYY 需要重新开始 $3$ 次游戏，加上一开始的一次游戏，$4$ 次游戏的进程是：\n\n- $1 \\to 2 \\to 4$；\n- $1 \\to 2 \\to 5$；\n- $1 \\to 3 \\to 5$；\n- $1 \\to 3 \\to 6$。\n\n对于 $100\\%$ 的数据满足 $N \\le 300$，$0 \\le K_i \\le 50$，$1 \\le T_{i,j} \\le 300$，$\\sum K_i \\le 5000$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2014/JSOI2014] Branching Storylines", "background": "Homebody JYY really enjoys playing RPGs, such as Xianjian and Xuanyuanjian. However, JYY is not fond of combat scenes, but rather the drama-like storylines full of love and hate. These games often have many branching storylines. Now JYY wants to spend the least amount of time to watch all branching storylines.", "description": "In the RPG that JYY is currently playing, there are $N$ storyline points, numbered $1$ to $N$. At the $i$-th storyline point, depending on JYY’s choices, he can go through different branching storylines to $K_i$ different new storyline points. If $K_i = 0$, then point $i$ is an ending of the game.\n\nWatching a single branching storyline takes some time. JYY starts at storyline point $1$, which is the beginning of the game. Clearly, every storyline point is reachable from point $1$. Moreover, as the game progresses, the storyline is irreversible. Therefore, the game guarantees that starting from any storyline point, you can never return to this point again.\n\nDue to JYY’s excessive use of modifiers, the game’s “save” and “load” features are broken. The only way to return to a previous storyline point is to quit the current game and start a new game, i.e., return to point $1$. JYY may quit and restart at any time. Repeatedly starting new games to rewatch already seen storylines is painful, so JYY wants to minimize the total time to watch all different branching storylines.", "inputFormat": "The first line contains a single positive integer $N$.\n\nThen follow $N$ lines. The $i$-th line describes storyline point $i$:\n\n- The first integer is $K_i$, followed by $K_i$ pairs of integers $b_{i,j}$ and $t_{i,j}$, indicating that from storyline point $i$ you can go to storyline point $b_{i,j}$, and watching this branching storyline takes $t_{i,j}$ time.", "outputFormat": "Output a single integer on one line, the minimum total time JYY needs to watch all branching storylines.", "hint": "Sample explanation:\n\nJYY needs to restart the game $3$ times. Together with the initial playthrough, the $4$ playthroughs are:\n\n- $1 \\to 2 \\to 4$.\n- $1 \\to 2 \\to 5$.\n- $1 \\to 3 \\to 5$.\n- $1 \\to 3 \\to 6$.\n\nConstraints:\n\nFor $100\\%$ of the testdata, $N \\le 300$, $0 \\le K_i \\le 50$, $1 \\le t_{i,j} \\le 300$, $\\sum K_i \\le 5000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2014/JSOI2014] 支线剧情", "background": "宅男 JYY 非常喜欢玩 RPG 游戏，比如仙剑，轩辕剑等等。不过 JYY 喜欢的并不是战斗场景，而是类似电视剧一般的充满恩怨情仇的剧情。这些游戏往往都有很多的支线剧情，现在 JYY 想花费最少的时间看完所有的支线剧情。", "description": "JYY 现在所玩的 RPG 游戏中，一共有 $N$ 个剧情点，由 $1$ 到 $N$ 编号，第 $i$ 个剧情点可以根据 JYY 的不同的选择，而经过不同的支线剧情，前往 $K_i$ 种不同的新的剧情点。当然如果为 $0$，则说明 $i$ 号剧情点是游戏的一个结局了。\n\nJYY 观看一个支线剧情需要一定的时间。JYY 一开始处在 $1$ 号剧情点，也就是游戏的开始。显然任何一个剧情点都是从 $1$ 号剧情点可达的。此外，随着游戏的进行，剧情是不可逆的。所以游戏保证从任意剧情点出发，都不能再回到这个剧情点。由于 JYY 过度使用修改器，导致游戏的“存档”和“读档”功能损坏了，\n\n所以 JYY 要想回到之前的剧情点，唯一的方法就是退出当前游戏，并开始新的游戏，也就是回到 $1$ 号剧情点。JYY 可以在任何时刻退出游戏并重新开始。不断开始新的游戏重复观看已经看过的剧情是很痛苦，JYY 希望花费最少的时间，看完所有不同的支线剧情。", "inputFormat": "输入一行包含一个正整数 $N$。\n\n接下来 $N$ 行，第 $i$ 行为 $i$ 号剧情点的信息；\n\n第一个整数为 $K_i$，接下来 $K_i$ 个整数对，$b_{i,j}$ 和 $t_{i,j}$，表示从剧情点 $i$ 可以前往剧情点 $b_{i,j}$，并且观看这段支线剧情需要花费 $t_{i,j}$ 的时间。", "outputFormat": "输出一行包含一个整数，表示 JYY 看完所有支线剧情所需要的最少时间。", "hint": "### 样例解释\n\nJYY 需要重新开始 $3$ 次游戏，加上一开始的一次游戏，$4$ 次游戏的进程是：\n\n- $1 \\to 2 \\to 4$；\n- $1 \\to 2 \\to 5$；\n- $1 \\to 3 \\to 5$；\n- $1 \\to 3 \\to 6$。\n\n对于 $100\\%$ 的数据满足 $N \\le 300$，$0 \\le K_i \\le 50$，$1 \\le T_{i,j} \\le 300$，$\\sum K_i \\le 5000$。", "locale": "zh-CN"}}}
{"pid": "P4044", "type": "P", "difficulty": 6, "samples": [["2\n5 2\n10 0\n3 7", "44"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2014", "各省省选", "江苏", "安徽", "模拟退火"], "title": "[AHOI2014/JSOI2014] 保龄球", "background": "JYY 很喜欢打保龄球，虽然技术不高，但是还是总想着的高分。这里 JYY 将向你介绍他所参加的特殊保龄球比赛的规则，然后请你帮他得到尽量多的分数。\n", "description": "一场保龄球比赛一共有 $n$ 个轮次，每一轮都会有十个木瓶放置在木板道的另一端。每一轮中，选手都有两次投球的机会来尝试击倒全部的十个木瓶。对于每一次投球机会，选手投球的得分等于这一次投球所击倒的木瓶数量。选手每一轮的得分是他两次机会击倒全部木瓶的数量。\n\n对于每一个轮次，有如下三种情况：\n\n1、 “全中”：如果选手第一次尝试就击倒了全部十个木瓶，那么这一轮就为“全中”。在一个“全中”轮中，由于所有木瓶在第一次尝试中都已经被击倒，所以选手不需要再进行第二次投球尝试。同时，在计算总分时，选手在下一轮的得分将会被乘2计入总分。\n\n2、“补中”：如果选手使用两次尝试击倒了十个木瓶，那么这一轮就称为“补中”。同时，在计算总分时，选手在下一轮中的第一次尝试的得分将会以双倍计入总分。\n\n3、“失误”：如果选手未能通过两次尝试击倒全部的木瓶，那么这一轮就被称为“失误”。同时，在计算总分时，选手在下一轮的得分会被计入总分，没有分数被翻倍。此外，如果第 $n$ 轮是“全中”，那么选手可以进行一次附加轮：也就是，如果第 $n$ 轮是“全中”，那么选手将一共进行 $n+1$ 轮比赛。显然，在这种情况下，第 $n+1$ 轮的分数一定会被加倍。\n\n附加轮的规则只执行一次。也就是说，即使第 $n+1$ 轮选手又打出了“全中”，也不会进行第 $n+2$ 轮比赛。因而，附加轮的成绩不会使得其他轮的分数翻番。最后，选手的总得分就是附加轮规则执行过，并且分数按上述规则加倍后的每一轮分数之和。\n\nJYY 刚刚进行了一场 $n$ 个轮次的保龄球比赛，但是，JYY非常不满意他的得分。JYY想出了一个办法：他可以把记分表上，他所打出的所有轮次的顺序重新排列，这样重新排列之后，由于翻倍规则的存在，JYY就可以得到更高的分数了！\n\n当然了，JYY不希望做的太假，他希望保证重新排列之后，所需要进行的轮数和重排前所进行的轮数是一致的：比如如果重排前JYY在第 $n$ 轮打出了“全中”，那么重排之后，第 $n$ 轮还得是“全中”以保证比赛一共进行 $n+1$ 轮；同样的，如果 JYY 第 $n$ 轮没有打出“全中”，那么重排过后第 $n$ 轮也不能是全中。请你帮助 JYY 计算一下，他可以得到的最高的分数。\n", "inputFormat": "第一行包含一个整数 $n$，表示保龄球比赛所需要进行的轮数。\n\n接下来包含 $n$ 或 $n+1$ 行，第i行包含两个非负整数 $x_i,y_i$，表示 JYY 在这一轮两次投球尝试所得到的分数，$x_i$ 表示第一次尝试，$y_i$ 表示第二次尝试。\n\n特别地，`10 0` 表示一轮“全中”。\n\n读入数据存在 $n+1$ 行，当且仅当 $x_n=10$ 且 $y_n=0$。\n", "outputFormat": "输出一行一个整数，表示 JYY 最大可能得到的分数。\n", "hint": "【样例说明】  \n按照输入顺序，JYY 将得到 $37$ 分。\n最佳方案是排列成如下顺序：\n```plain\n3 7\n10 0\n5 2\n```\n\n【数据范围】\n对于 $100\\%$ 的数据，$1\\le n \\le 50$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2014/JSOI2014] Bowling", "background": "JYY loves bowling. Although his skill is not high, he always wants a high score. Here JYY will introduce the rules of a special bowling contest he played, and then ask you to help him get as many points as possible.", "description": "A bowling game has $n$ frames. In each frame, ten pins are set up at the end of the lane. The player has two rolls in each frame to try to knock down all ten pins. The score of each roll equals the number of pins knocked down in that roll. The score of a frame is the total number of pins knocked down in its two rolls.\n\nFor each frame, there are three cases:\n\n1. \"Strike\": If the player knocks down all ten pins on the first roll, the frame is a \"strike\". Because all pins have fallen, there is no second roll in that frame. When computing the total score, the entire score of the next frame is counted twice (doubled).\n\n2. \"Spare\": If the player uses both rolls to knock down all ten pins, the frame is a \"spare\". When computing the total score, the score of the first roll in the next frame is counted twice.\n\n3. \"Open frame\": If the player fails to knock down all ten pins in two rolls, the frame is an \"open frame\". When computing the total score, the next frame’s score is added normally, with no doubling.\n\nIn addition, if frame $n$ is a \"strike\", the player plays one extra frame: that is, there are in total $n+1$ frames. In this case, the score of frame $n+1$ will definitely be doubled.\n\nThe extra-frame rule is applied at most once. That is, even if frame $n+1$ is also a \"strike\", there will be no frame $n+2$. Therefore, the extra frame will not cause any other frame’s score to be doubled. The final total score is the sum of all frame scores after applying the above doubling rules, including the extra frame if it exists.\n\nJYY just played a game of $n$ frames, but he is very unhappy with his score. He came up with an idea: he can reorder the sequence of all the frames on the scoresheet. After reordering, due to the doubling rules, JYY may obtain a higher total score.\n\nOf course, JYY does not want it to look too fake. He wants to keep the number of frames the same as before after reordering. For example, if the original frame $n$ was a \"strike\", then after reordering, frame $n$ must still be a \"strike\" so that there are $n+1$ frames in total. Similarly, if the original frame $n$ was not a \"strike\", then after reordering, frame $n$ must also not be a \"strike\". Please help JYY compute the maximum possible total score he can obtain.", "inputFormat": "The first line contains an integer $n$, the number of frames in the bowling game.\n\nThen there are $n$ or $n+1$ lines. The $i$-th line contains two non-negative integers $x_i, y_i$, representing JYY’s scores on the two rolls in that frame, where $x_i$ is the first roll and $y_i$ is the second roll.\n\nIn particular, `10 0` represents a \"strike\".\n\nThere are $n+1$ lines if and only if $x_n = 10$ and $y_n = 0$.", "outputFormat": "Output a single integer: the maximum total score JYY can obtain.", "hint": "[Sample explanation] According to the input order, JYY will get $37$ points.  \nThe best arrangement is:\n```plain\n3 7\n10 0\n5 2\n```\n\nConstraints  \nFor 100% of the testdata, $1 \\le n \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2014/JSOI2014] 保龄球", "background": "JYY 很喜欢打保龄球，虽然技术不高，但是还是总想着的高分。这里 JYY 将向你介绍他所参加的特殊保龄球比赛的规则，然后请你帮他得到尽量多的分数。\n", "description": "一场保龄球比赛一共有 $n$ 个轮次，每一轮都会有十个木瓶放置在木板道的另一端。每一轮中，选手都有两次投球的机会来尝试击倒全部的十个木瓶。对于每一次投球机会，选手投球的得分等于这一次投球所击倒的木瓶数量。选手每一轮的得分是他两次机会击倒全部木瓶的数量。\n\n对于每一个轮次，有如下三种情况：\n\n1、 “全中”：如果选手第一次尝试就击倒了全部十个木瓶，那么这一轮就为“全中”。在一个“全中”轮中，由于所有木瓶在第一次尝试中都已经被击倒，所以选手不需要再进行第二次投球尝试。同时，在计算总分时，选手在下一轮的得分将会被乘2计入总分。\n\n2、“补中”：如果选手使用两次尝试击倒了十个木瓶，那么这一轮就称为“补中”。同时，在计算总分时，选手在下一轮中的第一次尝试的得分将会以双倍计入总分。\n\n3、“失误”：如果选手未能通过两次尝试击倒全部的木瓶，那么这一轮就被称为“失误”。同时，在计算总分时，选手在下一轮的得分会被计入总分，没有分数被翻倍。此外，如果第 $n$ 轮是“全中”，那么选手可以进行一次附加轮：也就是，如果第 $n$ 轮是“全中”，那么选手将一共进行 $n+1$ 轮比赛。显然，在这种情况下，第 $n+1$ 轮的分数一定会被加倍。\n\n附加轮的规则只执行一次。也就是说，即使第 $n+1$ 轮选手又打出了“全中”，也不会进行第 $n+2$ 轮比赛。因而，附加轮的成绩不会使得其他轮的分数翻番。最后，选手的总得分就是附加轮规则执行过，并且分数按上述规则加倍后的每一轮分数之和。\n\nJYY 刚刚进行了一场 $n$ 个轮次的保龄球比赛，但是，JYY非常不满意他的得分。JYY想出了一个办法：他可以把记分表上，他所打出的所有轮次的顺序重新排列，这样重新排列之后，由于翻倍规则的存在，JYY就可以得到更高的分数了！\n\n当然了，JYY不希望做的太假，他希望保证重新排列之后，所需要进行的轮数和重排前所进行的轮数是一致的：比如如果重排前JYY在第 $n$ 轮打出了“全中”，那么重排之后，第 $n$ 轮还得是“全中”以保证比赛一共进行 $n+1$ 轮；同样的，如果 JYY 第 $n$ 轮没有打出“全中”，那么重排过后第 $n$ 轮也不能是全中。请你帮助 JYY 计算一下，他可以得到的最高的分数。\n", "inputFormat": "第一行包含一个整数 $n$，表示保龄球比赛所需要进行的轮数。\n\n接下来包含 $n$ 或 $n+1$ 行，第i行包含两个非负整数 $x_i,y_i$，表示 JYY 在这一轮两次投球尝试所得到的分数，$x_i$ 表示第一次尝试，$y_i$ 表示第二次尝试。\n\n特别地，`10 0` 表示一轮“全中”。\n\n读入数据存在 $n+1$ 行，当且仅当 $x_n=10$ 且 $y_n=0$。\n", "outputFormat": "输出一行一个整数，表示 JYY 最大可能得到的分数。\n", "hint": "【样例说明】  \n按照输入顺序，JYY 将得到 $37$ 分。\n最佳方案是排列成如下顺序：\n```plain\n3 7\n10 0\n5 2\n```\n\n【数据范围】\n对于 $100\\%$ 的数据，$1\\le n \\le 50$。\n", "locale": "zh-CN"}}}
{"pid": "P4045", "type": "P", "difficulty": 6, "samples": [["10 2\nhello\nworld", "2\nhelloworld\nworldhello"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2009", "各省省选", "江苏", "AC 自动机", "状压 DP"], "title": "[JSOI2009] 密码", "background": "", "description": "众所周知，密码在信息领域起到了不可估量的作用。对于普通的登陆口令以，唯一的破解方法就是暴力破解——逐个尝试所有可能的字母组合，但这是一项很耗时又容易被发现的工作。所以，为了获取对方的登陆口令，在暴力破解密码之前，必须先做大量的准备工作。经过情报的搜集，现在得到了若干有用信息，形如：\n\n> ​     “我观察到，密码中含有字符串*。”\n\n例如，对于一个 $10$ 位的密码以及观察到的字符串 `hello` 与 `world`，可能的密码组合为 `helloworld`与 `worldhello`；而对于 $6$ 位的密码以及到的字符串 `good` 与 `day`,可能的密码组合为 `gooday`。\n\n有了这些信息，就能够大大地减少尝试的次数了。请编一个程序，计算所有密码组合的可能。密码中仅可能包含 `a-z` 之间的小写字母。", "inputFormat": "输入数据首先输入两个整数 $L,N$，分别表示密码的长度与观察到子串的个数。\n\n接下来 $N$ 行，每行若干个字符，描述了每个观察到的字符串。\n", "outputFormat": "输出数据第一行为一个整数，代表了满足所有观察条件字符串的总数。\n\n若这个数字小于等于 $42$，则按字典顺序输出所有密码的可能情况，每行一个，否则，只输出满足所有观察条件字符串的总数即可。\n", "hint": "对于 $100\\%$ 的数据，$1\\leq L\\leq 25,1\\leq N\\leq 10$，每个观察到的字符串长不超过 $10$，并且保证输出结果小于 $2^{63}$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2009] Password", "background": "", "description": "It is well known that passwords play an invaluable role in the field of information. For ordinary login passwords, the only way to crack them is brute force—trying all possible letter combinations one by one—but this is time-consuming and easy to detect. Therefore, before attempting a brute-force attack, one must do a lot of preparation. After gathering intelligence, we have obtained several useful pieces of information of the form:\n\n> \"I observed that the password contains the string *.\"\n\nFor example, for a password of length $10$ and the observed substrings `hello` and `world`, possible passwords are `helloworld` and `worldhello`. For a password of length $6$ and the observed substrings `good` and `day`, a possible password is `gooday`.\n\nWith such information, the number of attempts can be greatly reduced. Please write a program to compute all possible passwords. The password may contain only lowercase letters in `a-z`.", "inputFormat": "The input begins with two integers $L, N$, denoting the password length and the number of observed substrings, respectively.\n\nThen follow $N$ lines, each containing a string that describes one observed substring.", "outputFormat": "The first line of the output contains a single integer: the total number of passwords that contain all observed substrings.\n\nIf this number is less than or equal to $42$, output all possible passwords in lexicographical order, one per line. Otherwise, output only the total count.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le L \\le 25$, $1 \\le N \\le 10$, each observed substring has length at most $10$, and it is guaranteed that the output is less than $2^{63}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2009] 密码", "background": "", "description": "众所周知，密码在信息领域起到了不可估量的作用。对于普通的登陆口令以，唯一的破解方法就是暴力破解——逐个尝试所有可能的字母组合，但这是一项很耗时又容易被发现的工作。所以，为了获取对方的登陆口令，在暴力破解密码之前，必须先做大量的准备工作。经过情报的搜集，现在得到了若干有用信息，形如：\n\n> ​     “我观察到，密码中含有字符串*。”\n\n例如，对于一个 $10$ 位的密码以及观察到的字符串 `hello` 与 `world`，可能的密码组合为 `helloworld`与 `worldhello`；而对于 $6$ 位的密码以及到的字符串 `good` 与 `day`,可能的密码组合为 `gooday`。\n\n有了这些信息，就能够大大地减少尝试的次数了。请编一个程序，计算所有密码组合的可能。密码中仅可能包含 `a-z` 之间的小写字母。", "inputFormat": "输入数据首先输入两个整数 $L,N$，分别表示密码的长度与观察到子串的个数。\n\n接下来 $N$ 行，每行若干个字符，描述了每个观察到的字符串。\n", "outputFormat": "输出数据第一行为一个整数，代表了满足所有观察条件字符串的总数。\n\n若这个数字小于等于 $42$，则按字典顺序输出所有密码的可能情况，每行一个，否则，只输出满足所有观察条件字符串的总数即可。\n", "hint": "对于 $100\\%$ 的数据，$1\\leq L\\leq 25,1\\leq N\\leq 10$，每个观察到的字符串长不超过 $10$，并且保证输出结果小于 $2^{63}$。\n", "locale": "zh-CN"}}}
{"pid": "P4046", "type": "P", "difficulty": 4, "samples": [["4 \n0 5 0 6 \n6 0 5 6 \n1 6 0 6 \n1 1 1 0 \n1 1 1 1 4 4 2 2 2 3 ", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2010", "各省省选", "江苏", "枚举"], "title": "[JSOI2010] 快递服务", "background": "", "description": "「飞奔」快递公司成立之后，已经分别与市内许多中小企业公司签订邮件收送服务契约。由于有些公司是在同一栋大楼内，所以「飞奔」公司收件的地点（收件点）最多只有 $m$ 点（$1,2,\\dots,m$），因此「飞奔」仅先行采购了三辆货车并聘用了三名司机，每天早上分别从收件地点 $1,2,3$ 出发。而在与客户的服务契约中有明确订约：「飞奔」必须在客户提出邮件寄送要求的隔天派人至该公司（地点）收件。\n\n为了能更有效率的服务客户并节省收件时间，该公司设立了收件服务登记网站，客户如有邮件需要寄送，必须在需要收件的前一天就先上网登记。为了节省油量，「飞奔」就利用晚上先行安排三位司机隔天的收件路线。每位司机至各地点收件的顺序应与各公司上网登记的顺序相符且必须能在最省油的情况下完成当天所有的收件服务。因此每位司机有可能需要在不同时间重复到同一地点收件，或不同的司机有可能需在不同的时间点前往同一地点收件。\n\n如下面范例二（收件公司地点依序为：`4 2 4 1 5 4 3 2 1`）所示，虽然司机 $1$ 一开始就已经在收件地点 $1$ 了，但是他却不能先把后面第四个登记的公司（地点 $1$）邮件先收了再前往第一、第二、或第三个登记收件地点（地点 $4,2,4$）收件。但是如果前三个登记收件的服务是由司机 $2$ 或 $3$ 来负责，则司机 $1$ 就可以在地点 $1$ 收了第四个登记的邮件后再前往后面所登记的地点收件。此外，在某些情况下，不一定每辆车都要收到货，也就是说，最佳收件方式也有可能是只需出动一或两辆车去收货。请写一个程序来帮「飞奔」公司计算每天依预约顺序至各收件地点收件的最少总耗油量。\n\n### 简要题意\n\n给定一个 $m \\times m$ 的矩阵 $D$。我们规定一个序列 $a(a_0,a_1,a_2,\\dots,a_n)$ 的花费为 $\\sum\\limits_{i=1}^{n}D_{a_{i-1},a_i}$。\n\n现在给定你一个长度 $\\leq 1000$ 的序列 $s$，请你把它分成三个子序列 $a,b,c$，并且规定 $a_0=1,b_0=2,c_0=3$，求出所有划分方案中它们的最小化费和。\n\n特殊地，矩阵 $D$ 满足三角不等式，具体见输入格式中的详细解释。\n\n（By El_destructor）", "inputFormat": "输入文件第一行有一个整数 $m$，代表「飞奔」公司收件的地点数，以 $1$ 至 $m$ 之间的整数代号来表示每个地点。\n\n接下来的 $m$ 行（第 $2$ 到第 $m+1$ 行），每行有 $m$ 个整数，代表一个矩阵 $D$。第 $i$ 行的第 $j$ 个整数 $D(i,j)$ 表示司机开车从收件点 $i$ 到收件点 $j$ 所需耗油量。最后一行是一个序列，按照顺序为前一天上网登记要求收件的公司地点代号，最多会有 $1000$ 个收件请求。\n\n输入文件中任两个相邻的整数都以一个空格隔开。\n\n注意：油量矩阵 $D$ 满足三角不等式，也就是说 $\\forall 1 \\leq i,j,k \\leq m,D(i,j) \\leq D(i,k)+D(k,j)$。因此，每辆车前往下一个收件地点时一定是直接前往，不必先绕道至其它地点再抵达下个收件地点。", "outputFormat": "输出一个整数，代表收件所需最少总耗油量。\n", "hint": "#### 样例解释\n\n到每个请求收件地点的司机分别为 `1 1 1 1 3 3 2 2 2 1`，因此司机 $1$ 只需从起使点 $1$ 移动到地点 $3$，司机 $2$ 只需停留在地点 $2$，司机 $3$ 从起始点 $3$ 移动到地点 $4$。\n\n#### 数据范围\n\n$3 \\leq m \\leq 200,1 \\leq s_i \\leq m$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2010] Courier Service", "background": "", "description": "After the “Feiben” (pinyin) courier company was founded, it signed mail pickup-and-delivery service contracts with many small and medium-sized companies in the city. Since some companies are in the same building, the pickup locations (pickup points) that “Feiben” needs to visit are at most $m$ points ($1, 2, \\dots, m$). Therefore, “Feiben” purchased three trucks and hired three drivers, who set out every morning from pickup locations $1, 2, 3$ respectively. The service contract with clients clearly states that “Feiben” must send someone to the client’s company (location) to pick up the mail on the day after the client submits the mailing request.\n\nTo serve clients more efficiently and save pickup time, the company set up a pickup service registration website. If a client needs to send mail, they must register online one day in advance. To save fuel, “Feiben” plans the next day’s pickup routes for the three drivers at night. The order in which each driver visits their assigned locations must respect the online registration order, and all pickups must be completed using the least fuel. Thus, a driver may need to visit the same location multiple times at different times, and different drivers may also go to the same location at different times.\n\nAs shown in Example 2 below (the pickup locations in order are: `4 2 4 1 5 4 3 2 1`), although driver $1$ starts at pickup location $1$, he cannot first pick up the mail for the fourth registered company (location $1$) and then go to the first, second, or third registered pickup locations (locations $4, 2, 4$). However, if the first three registered pickups are handled by driver $2$ or $3$, then driver $1$ can pick up the fourth registered mail at location $1$ and then proceed to later registered locations. In some cases, not every truck needs to pick up mail; the optimal plan may use only one or two trucks. Please write a program to compute the minimum total fuel consumption to visit all pickup locations in the registered order.\n\nBrief statement:\nGiven an $m \\times m$ matrix $D$. We define the cost of a sequence $a(a_0, a_1, a_2, \\dots, a_n)$ as $\\sum\\limits_{i=1}^{n} D_{a_{i-1}, a_i}$.\n\nNow you are given a sequence $s$ with length $\\leq 1000$. Split it into three subsequences $a, b, c$, with $a_0 = 1, b_0 = 2, c_0 = 3$. Among all such partitions, minimize the sum of their costs.\n\nIn particular, the matrix $D$ satisfies the triangle inequality; see the detailed explanation in the Input Format.\n\n(By El_destructor.)", "inputFormat": "The first line of the input file contains an integer $m$, the number of pickup locations, identified by integers from $1$ to $m$.\n\nThe next $m$ lines (lines $2$ to $m+1$) each contain $m$ integers, representing a matrix $D$. On the $i$-th line, the $j$-th integer $D(i, j)$ is the fuel required to drive from pickup point $i$ to pickup point $j$. The last line is a sequence of location IDs in the order of the requests registered online on the previous day; there are at most $1000$ pickup requests.\n\nAny two adjacent integers in the input are separated by one space.\n\nNote: The fuel matrix $D$ satisfies the triangle inequality, that is, $\\forall 1 \\leq i, j, k \\leq m, D(i, j) \\leq D(i, k) + D(k, j)$. Therefore, when a truck goes to the next assigned pickup location, it always goes directly without detouring through other locations.", "outputFormat": "Output a single integer, the minimum total fuel required for all pickups.", "hint": "Sample explanation:\nThe drivers assigned to each request, in order, are `1 1 1 1 3 3 2 2 2 1`. Therefore, driver $1$ only needs to move from starting point $1$ to location $3$, driver $2$ can stay at location $2$, and driver $3$ moves from starting point $3$ to location $4$.\n\nConstraints:\n$3 \\leq m \\leq 200, 1 \\leq s_i \\leq m$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2010] 快递服务", "background": "", "description": "「飞奔」快递公司成立之后，已经分别与市内许多中小企业公司签订邮件收送服务契约。由于有些公司是在同一栋大楼内，所以「飞奔」公司收件的地点（收件点）最多只有 $m$ 点（$1,2,\\dots,m$），因此「飞奔」仅先行采购了三辆货车并聘用了三名司机，每天早上分别从收件地点 $1,2,3$ 出发。而在与客户的服务契约中有明确订约：「飞奔」必须在客户提出邮件寄送要求的隔天派人至该公司（地点）收件。\n\n为了能更有效率的服务客户并节省收件时间，该公司设立了收件服务登记网站，客户如有邮件需要寄送，必须在需要收件的前一天就先上网登记。为了节省油量，「飞奔」就利用晚上先行安排三位司机隔天的收件路线。每位司机至各地点收件的顺序应与各公司上网登记的顺序相符且必须能在最省油的情况下完成当天所有的收件服务。因此每位司机有可能需要在不同时间重复到同一地点收件，或不同的司机有可能需在不同的时间点前往同一地点收件。\n\n如下面范例二（收件公司地点依序为：`4 2 4 1 5 4 3 2 1`）所示，虽然司机 $1$ 一开始就已经在收件地点 $1$ 了，但是他却不能先把后面第四个登记的公司（地点 $1$）邮件先收了再前往第一、第二、或第三个登记收件地点（地点 $4,2,4$）收件。但是如果前三个登记收件的服务是由司机 $2$ 或 $3$ 来负责，则司机 $1$ 就可以在地点 $1$ 收了第四个登记的邮件后再前往后面所登记的地点收件。此外，在某些情况下，不一定每辆车都要收到货，也就是说，最佳收件方式也有可能是只需出动一或两辆车去收货。请写一个程序来帮「飞奔」公司计算每天依预约顺序至各收件地点收件的最少总耗油量。\n\n### 简要题意\n\n给定一个 $m \\times m$ 的矩阵 $D$。我们规定一个序列 $a(a_0,a_1,a_2,\\dots,a_n)$ 的花费为 $\\sum\\limits_{i=1}^{n}D_{a_{i-1},a_i}$。\n\n现在给定你一个长度 $\\leq 1000$ 的序列 $s$，请你把它分成三个子序列 $a,b,c$，并且规定 $a_0=1,b_0=2,c_0=3$，求出所有划分方案中它们的最小化费和。\n\n特殊地，矩阵 $D$ 满足三角不等式，具体见输入格式中的详细解释。\n\n（By El_destructor）", "inputFormat": "输入文件第一行有一个整数 $m$，代表「飞奔」公司收件的地点数，以 $1$ 至 $m$ 之间的整数代号来表示每个地点。\n\n接下来的 $m$ 行（第 $2$ 到第 $m+1$ 行），每行有 $m$ 个整数，代表一个矩阵 $D$。第 $i$ 行的第 $j$ 个整数 $D(i,j)$ 表示司机开车从收件点 $i$ 到收件点 $j$ 所需耗油量。最后一行是一个序列，按照顺序为前一天上网登记要求收件的公司地点代号，最多会有 $1000$ 个收件请求。\n\n输入文件中任两个相邻的整数都以一个空格隔开。\n\n注意：油量矩阵 $D$ 满足三角不等式，也就是说 $\\forall 1 \\leq i,j,k \\leq m,D(i,j) \\leq D(i,k)+D(k,j)$。因此，每辆车前往下一个收件地点时一定是直接前往，不必先绕道至其它地点再抵达下个收件地点。", "outputFormat": "输出一个整数，代表收件所需最少总耗油量。\n", "hint": "#### 样例解释\n\n到每个请求收件地点的司机分别为 `1 1 1 1 3 3 2 2 2 1`，因此司机 $1$ 只需从起使点 $1$ 移动到地点 $3$，司机 $2$ 只需停留在地点 $2$，司机 $3$ 从起始点 $3$ 移动到地点 $4$。\n\n#### 数据范围\n\n$3 \\leq m \\leq 200,1 \\leq s_i \\leq m$。", "locale": "zh-CN"}}}
{"pid": "P4047", "type": "P", "difficulty": 4, "samples": [["4 2\n0 0\n0 1\n1 1\n1 0\n", "1.00\n"], ["9 3\n2 2\n2 3\n3 2\n3 3\n3 5\n3 6\n4 6\n6 2\n6 3", "2.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "二分", "并查集", "各省省选", "江苏", "生成树"], "title": "[JSOI2010] 部落划分", "background": "", "description": "聪聪研究发现，荒岛野人总是过着群居的生活，但是，并不是整个荒岛上的所有野人都属于同一个部落，野人们总是拉帮结派形成属于自己的部落，不同的部落之间则经常发生争斗。只是，这一切都成为谜团了——聪聪根本就不知道部落究竟是如何分布的。\n\n不过好消息是，聪聪得到了一份荒岛的地图。地图上标注了 $n$ 个野人居住的地点（可以看作是平面上的坐标）。我们知道，同一个部落的野人总是生活在附近。我们把两个部落的距离，定义为部落中距离最近的那两个居住点的距离。聪聪还获得了一个有意义的信息——这些野人总共被分为了 $k$ 个部落！这真是个好消息。聪聪希望从这些信息里挖掘出所有部落的详细信息。他正在尝试这样一种算法：\n\n对于任意一种部落划分的方法，都能够求出两个部落之间的距离，聪聪希望求出一种部落划分的方法，使靠得最近的两个部落尽可能远离。\n\n例如，下面的左图表示了一个好的划分，而右图则不是。请你编程帮助聪聪解决这个难题。\n\n\n![](https://cdn.luogu.com.cn/upload/pic/30573.png)", "inputFormat": "输入文件第一行包含两个整数 $n$ 和 $k$，分别代表了野人居住点的数量和部落的数量。\n\n接下来 $n$ 行，每行包含两个整数 $x$，$y$，描述了一个居住点的坐标。", "outputFormat": "输出一行一个实数，为最优划分时，最近的两个部落的距离，精确到小数点后两位。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $2 \\leq k \\leq n \\leq 10^3$，$0 \\leq  x, y \\leq 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2010] Tribe Division", "background": "", "description": "Congcong discovered that the savages on a deserted island always live in groups. However, not all savages on the island belong to the same tribe; they form their own tribes and different tribes often fight. But all of this is a mystery—Congcong does not know how the tribes are distributed.\n\nThe good news is that Congcong obtained a map of the island. The map marks $n$ dwelling locations (viewed as coordinates on a plane). We know that members of the same tribe live close to each other. We define the distance between two tribes as the distance between the closest pair of dwellings, one from each tribe. Congcong also learned an important fact—the savages are divided into $k$ tribes in total. This is great news. He wants to extract detailed information about all tribes from this data. He is trying the following approach:\n\nFor any partition of the dwellings into tribes, we can compute the distance between any two tribes. Congcong wants to find a partition such that the closest pair of tribes are as far apart as possible.\n\nFor example, the left figure below shows a good partition, while the right one does not. Please write a program to help Congcong solve this problem.\n\n![](https://cdn.luogu.com.cn/upload/pic/30573.png)", "inputFormat": "The first line contains two integers $n$ and $k$, representing the number of dwelling locations and the number of tribes.\n\nThe next $n$ lines each contain two integers $x$, $y$, giving the coordinates of a dwelling.", "outputFormat": "Output a single real number: under the optimal partition, the distance between the two closest tribes, rounded to two decimal places.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that $2 \\leq k \\leq n \\leq 10^3$, $0 \\leq x, y \\leq 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2010] 部落划分", "background": "", "description": "聪聪研究发现，荒岛野人总是过着群居的生活，但是，并不是整个荒岛上的所有野人都属于同一个部落，野人们总是拉帮结派形成属于自己的部落，不同的部落之间则经常发生争斗。只是，这一切都成为谜团了——聪聪根本就不知道部落究竟是如何分布的。\n\n不过好消息是，聪聪得到了一份荒岛的地图。地图上标注了 $n$ 个野人居住的地点（可以看作是平面上的坐标）。我们知道，同一个部落的野人总是生活在附近。我们把两个部落的距离，定义为部落中距离最近的那两个居住点的距离。聪聪还获得了一个有意义的信息——这些野人总共被分为了 $k$ 个部落！这真是个好消息。聪聪希望从这些信息里挖掘出所有部落的详细信息。他正在尝试这样一种算法：\n\n对于任意一种部落划分的方法，都能够求出两个部落之间的距离，聪聪希望求出一种部落划分的方法，使靠得最近的两个部落尽可能远离。\n\n例如，下面的左图表示了一个好的划分，而右图则不是。请你编程帮助聪聪解决这个难题。\n\n\n![](https://cdn.luogu.com.cn/upload/pic/30573.png)", "inputFormat": "输入文件第一行包含两个整数 $n$ 和 $k$，分别代表了野人居住点的数量和部落的数量。\n\n接下来 $n$ 行，每行包含两个整数 $x$，$y$，描述了一个居住点的坐标。", "outputFormat": "输出一行一个实数，为最优划分时，最近的两个部落的距离，精确到小数点后两位。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $2 \\leq k \\leq n \\leq 10^3$，$0 \\leq  x, y \\leq 10^4$。", "locale": "zh-CN"}}}
{"pid": "P4048", "type": "P", "difficulty": 6, "samples": [["2 3 1\n-100 0 100 3\n100 0 100 5\n-100 -10\n100 10\n110 11\n5 5 10", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2010", "各省省选", "江苏", "枚举"], "title": "[JSOI2010] 冷冻波", "background": "", "description": "WJJ喜欢“魔兽争霸”这个游戏。在游戏中，巫妖是一种强大的英雄，它的技能Frozen Nova每次可以杀死一个小精灵。我们认为，巫妖和小精灵都可以看成是平面上的点。\n\n当巫妖和小精灵之间的直线距离不超过R，且巫妖看到小精灵的视线没有被树木阻挡（也就是说，巫妖和小精灵的连线与任何树木都没有公共点）的话，巫妖就可以瞬间杀灭一个小精灵。\n\n在森林里有N个巫妖，每个巫妖释放Frozen Nova之后，都需要等待一段时间，才能再次施放。不同的巫妖有不同的等待时间和施法范围，但相同的是，每次施放都可以杀死一个小精灵。\n\n现在巫妖的头目想知道，若从0时刻开始计算，至少需要花费多少时间，可以杀死所有的小精灵？\n", "inputFormat": "输入文件第一行包含三个整数N、M、K(N,M,K<=200)，分别代表巫妖的数量、小精灵的数量和树木的数量。\n\n接下来N行，每行包含四个整数x, y, r, t，分别代表了每个巫妖的坐标、攻击范围和施法间隔（单位为秒）。\n\n再接下来M行，每行两个整数x, y，分别代表了每个小精灵的坐标。\n\n再接下来K行，每行三个整数x, y, r，分别代表了每个树木的坐标。\n\n输入数据中所有坐标范围绝对值不超过10000，半径和施法间隔不超过20000。\n", "outputFormat": "输出一行，为消灭所有小精灵的最短时间（以秒计算）。如果永远无法消灭所有的小精灵，则输出-1。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2010] Frozen Nova", "background": "", "description": "WJJ likes the game \"Warcraft III.\" In the game, the Lich is a powerful hero whose skill Frozen Nova can kill exactly one sprite each time. We consider both liches and sprites as points on the plane.\n\nIf the Euclidean distance between a lich and a sprite does not exceed $R$, and the lich's line of sight to that sprite is not blocked by any tree (that is, the line segment between the lich and the sprite has no common point with any tree), then the lich can instantly kill that sprite.\n\nThere are $N$ liches in the forest. After casting Frozen Nova, each lich must wait for a cooldown period before casting again. Different liches have different cooldowns and cast ranges, but each cast always kills exactly one sprite.\n\nStarting from time $0$, what is the minimum time needed to kill all the sprites?", "inputFormat": "The first line contains three integers $N$, $M$, $K$ ($N, M, K \\le 200$), representing the number of liches, sprites, and trees.\n\nThe next $N$ lines each contain four integers $x, y, r, t$, representing the coordinates, attack range, and casting interval (in seconds) of each lich.\n\nThe next $M$ lines each contain two integers $x, y$, representing the coordinates of each sprite.\n\nThe next $K$ lines each contain three integers $x, y, r$, representing the coordinates and radius of each tree.\n\nAll coordinates have absolute values at most $10000$; radii and casting intervals are at most $20000$.", "outputFormat": "Output one line: the minimum time (in seconds) needed to eliminate all sprites. If it is impossible to eliminate all sprites, output $-1$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2010] 冷冻波", "background": "", "description": "WJJ喜欢“魔兽争霸”这个游戏。在游戏中，巫妖是一种强大的英雄，它的技能Frozen Nova每次可以杀死一个小精灵。我们认为，巫妖和小精灵都可以看成是平面上的点。\n\n当巫妖和小精灵之间的直线距离不超过R，且巫妖看到小精灵的视线没有被树木阻挡（也就是说，巫妖和小精灵的连线与任何树木都没有公共点）的话，巫妖就可以瞬间杀灭一个小精灵。\n\n在森林里有N个巫妖，每个巫妖释放Frozen Nova之后，都需要等待一段时间，才能再次施放。不同的巫妖有不同的等待时间和施法范围，但相同的是，每次施放都可以杀死一个小精灵。\n\n现在巫妖的头目想知道，若从0时刻开始计算，至少需要花费多少时间，可以杀死所有的小精灵？\n", "inputFormat": "输入文件第一行包含三个整数N、M、K(N,M,K<=200)，分别代表巫妖的数量、小精灵的数量和树木的数量。\n\n接下来N行，每行包含四个整数x, y, r, t，分别代表了每个巫妖的坐标、攻击范围和施法间隔（单位为秒）。\n\n再接下来M行，每行两个整数x, y，分别代表了每个小精灵的坐标。\n\n再接下来K行，每行三个整数x, y, r，分别代表了每个树木的坐标。\n\n输入数据中所有坐标范围绝对值不超过10000，半径和施法间隔不超过20000。\n", "outputFormat": "输出一行，为消灭所有小精灵的最短时间（以秒计算）。如果永远无法消灭所有的小精灵，则输出-1。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4049", "type": "P", "difficulty": 6, "samples": [["10 10\n0.1 0.2 0.7\n0.2 0.3 0.5\n0.3 0.4 0.3\n0.4 0.5 0.1\n0.5 0.1 0.4\n0.6 0.2 0.2\n0.7 0.3 0\n0.8 0.1 0.1\n0.9 0.1 0\n1 0 0\n0.1 0.2 0.7\n0.2 0.3 0.5\n0.3 0.4 0.3\n0.4 0.5 0.1\n0.5 0.1 0.4\n0.6 0.2 0.2\n0.7 0.3 0\n0.8 0.1 0.1\n0.9 0.1 0\n1 0 0", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2007", "各省省选", "江苏", "图论建模", "最短路", "凸包"], "title": "[JSOI2007] 合金", "background": "", "description": "某公司加工一种由铁、铝、锡组成的合金。他们的工作很简单。首先进口一些铁铝锡合金原材料，不同种类的原材料中铁铝锡的比重不同。然后，将每种原材料取出一定量，经过融解、混合，得到新的合金。新的合金的铁铝锡比重为用户所需要的比重。 \n\n现在，用户给出了 $n$ 种他们需要的合金，以及每种合金中铁铝锡的比重。公司希望能够订购最少种类的原材料，并且使用这些原材料可以加工出用户需要的所有种类的合金。", "inputFormat": "第一行两个整数 $m$ 和 $n$，分别表示原材料种数和用户需要的合金种数。\n\n第 $2$ 到 $m+1$ 行，每行三个实数 $a_i, b_i, c_i$，分别表示铁铝锡在一种原材料中所占的比重。\n\n第 $m+2$ 到 $m+n+1$ 行，每行三个实数 $d_i, e_i, f_i$，分别表示铁铝锡在一种用户需要的合金中所占的比重。", "outputFormat": "一个整数，表示最少需要的原材料种数。若无解，则输出 `–1`。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，满足 $1\\le m,n\\le 500$，$0 \\leq a_i,b_i,c_i,d_i,e_i,f_i \\leq 1$，且 $a_i+b_i+c_i=1$，$d_i+e_i+f_i=1$，小数点后最多有六位数字。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2007] Alloy", "background": "", "description": "A company processes an alloy composed of iron, aluminum, and tin. Their workflow is simple. First, they import several raw materials that are iron-aluminum-tin alloys, where the proportions of iron, aluminum, and tin differ among types. Then, they take certain amounts from each raw material, melt and mix them to obtain a new alloy. The new alloy has iron, aluminum, and tin proportions equal to what the customer requires.\n\nNow, the customers provide $n$ types of alloys they need, along with the proportions of iron, aluminum, and tin for each. The company wants to order the minimum number of raw material types such that using these raw materials they can produce all the requested alloys.", "inputFormat": "The first line contains two integers $m$ and $n$, denoting the number of raw material types and the number of alloy types requested by customers, respectively.\n\nLines $2$ through $m+1$ each contain three real numbers $a_i, b_i, c_i$, representing the proportions of iron, aluminum, and tin in a raw material type, respectively.\n\nLines $m+2$ through $m+n+1$ each contain three real numbers $d_i, e_i, f_i$, representing the proportions of iron, aluminum, and tin in a requested alloy type, respectively.", "outputFormat": "Output a single integer, the minimum number of raw material types required. If there is no solution, output `-1`.", "hint": "Constraints\n\nFor all test points, it holds that $1 \\le m, n \\le 500$, $0 \\le a_i, b_i, c_i, d_i, e_i, f_i \\le 1$, and $a_i + b_i + c_i = 1$, $d_i + e_i + f_i = 1$. There are at most six digits after the decimal point.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2007] 合金", "background": "", "description": "某公司加工一种由铁、铝、锡组成的合金。他们的工作很简单。首先进口一些铁铝锡合金原材料，不同种类的原材料中铁铝锡的比重不同。然后，将每种原材料取出一定量，经过融解、混合，得到新的合金。新的合金的铁铝锡比重为用户所需要的比重。 \n\n现在，用户给出了 $n$ 种他们需要的合金，以及每种合金中铁铝锡的比重。公司希望能够订购最少种类的原材料，并且使用这些原材料可以加工出用户需要的所有种类的合金。", "inputFormat": "第一行两个整数 $m$ 和 $n$，分别表示原材料种数和用户需要的合金种数。\n\n第 $2$ 到 $m+1$ 行，每行三个实数 $a_i, b_i, c_i$，分别表示铁铝锡在一种原材料中所占的比重。\n\n第 $m+2$ 到 $m+n+1$ 行，每行三个实数 $d_i, e_i, f_i$，分别表示铁铝锡在一种用户需要的合金中所占的比重。", "outputFormat": "一个整数，表示最少需要的原材料种数。若无解，则输出 `–1`。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，满足 $1\\le m,n\\le 500$，$0 \\leq a_i,b_i,c_i,d_i,e_i,f_i \\leq 1$，且 $a_i+b_i+c_i=1$，$d_i+e_i+f_i=1$，小数点后最多有六位数字。", "locale": "zh-CN"}}}
{"pid": "P4050", "type": "P", "difficulty": 3, "samples": [["9 4\n1 1 2 2 3 3 5 5 5 7 8 8 8", "6 7 9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "江苏", "枚举"], "title": "[JSOI2007] 麻将", "background": null, "description": "麻将是中国传统的娱乐工具之一。麻将牌的牌可以分为字牌（共有东、南、西、北、中、发、白七种）和序数牌（分为条子、饼子、万子三种花色，每种花色各有一到九的九种牌），每种牌各四张。\n\n在麻将中，通常情况下一组和了的牌（即完成的牌）由十四张牌组成。十四张牌中的两张组成对子（即完全相同的两张牌），剩余的十二张组成三张一组的四组，每一组须为顺子（即同花色且序数相连的序数牌，例如条子的三、四、五）或者是刻子（即完全相同的三张牌）。一组听牌的牌是指一组十三张牌，且再加上某一张牌就可以组成和牌。那一张加上的牌可以称为等待牌。\n\n在这里，我们考虑一种特殊的麻将。在这种特殊的麻将里，没有字牌，花色也只有一种。但是，序数不被限制在一到九的范围内，而是在 $1$ 到 $n$ 的范围内。同时，也没有每一种牌四张的限制。一组和了的牌由 $3m + 2$ 张牌组成，其中两张组成对子，其余 $3m$ 张组成三张一组的 $m$ 组，每组须为顺子或刻子。现给出一组 $3m + 1$ 张的牌，要求判断该组牌是否为听牌（即还差一张就可以和牌）。如果是的话，输出所有可能的等待牌。", "inputFormat": "输入包含两行。\n\n第一行包含两个由空格隔开的整数 $n,m$（$9\\le n\\le 400, 4 \\le m\\le 1000$）。\n\n第二行包含 $3m + 1$ 个由空格隔开的整数，每个数均在范围 $1$ 到 $n$ 之内。这些数代表要求判断听牌的牌的序数。", "outputFormat": "输出为一行。如果该组牌为听牌，则输出所有的可能的等待牌的序数，数字之间用一个空格隔开。所有的序数必须按从小到大的顺序输出。如果该组牌不是听牌，则输出 ```NO```。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2007] Mahjong", "background": "", "description": "Mahjong is one of China's traditional recreational tools. Mahjong tiles can be divided into honor tiles (there are seven kinds: east, south, west, north, red, green, and white) and numbered tiles (three suits: bamboo, dots, and characters, each suit has nine ranks from one to nine), and there are four copies of each tile.\n\nIn mahjong, a typical complete hand consists of fourteen tiles. Two of the fourteen tiles form a pair (two identical tiles), and the remaining twelve tiles form four groups of three, each group being either a sequence (three consecutive ranks in the same suit, such as 3, 4, 5 of bamboo) or a triplet (three identical tiles). A ready hand is a hand of thirteen tiles such that adding one tile can form a complete hand. That added tile is called a waiting tile.\n\nHere, we consider a special kind of mahjong. In this special mahjong, there are no honor tiles, and there is only one suit. However, the ranks are not limited to the range from one to nine, but are in the range from $1$ to $n$. Also, there is no limit of four copies for each tile. A complete hand consists of $3m + 2$ tiles, of which two form a pair, and the remaining $3m$ tiles form $m$ groups of three, each group being either a sequence or a triplet. Given a set of $3m + 1$ tiles, determine whether this hand is ready (i.e., it is one tile away from a complete hand). If it is, output all possible waiting tiles.", "inputFormat": "The input contains two lines.\n\nThe first line contains two integers $n, m$ separated by a space ($9 \\le n \\le 400$, $4 \\le m \\le 1000$).\n\nThe second line contains $3m + 1$ integers separated by spaces, each in the range $1$ to $n$. These numbers represent the ranks of the tiles in the hand to be checked for readiness.", "outputFormat": "Output a single line. If the hand is ready, output all possible waiting tiles’ ranks in ascending order, separated by a single space. If the hand is not ready, output NO.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2007] 麻将", "background": null, "description": "麻将是中国传统的娱乐工具之一。麻将牌的牌可以分为字牌（共有东、南、西、北、中、发、白七种）和序数牌（分为条子、饼子、万子三种花色，每种花色各有一到九的九种牌），每种牌各四张。\n\n在麻将中，通常情况下一组和了的牌（即完成的牌）由十四张牌组成。十四张牌中的两张组成对子（即完全相同的两张牌），剩余的十二张组成三张一组的四组，每一组须为顺子（即同花色且序数相连的序数牌，例如条子的三、四、五）或者是刻子（即完全相同的三张牌）。一组听牌的牌是指一组十三张牌，且再加上某一张牌就可以组成和牌。那一张加上的牌可以称为等待牌。\n\n在这里，我们考虑一种特殊的麻将。在这种特殊的麻将里，没有字牌，花色也只有一种。但是，序数不被限制在一到九的范围内，而是在 $1$ 到 $n$ 的范围内。同时，也没有每一种牌四张的限制。一组和了的牌由 $3m + 2$ 张牌组成，其中两张组成对子，其余 $3m$ 张组成三张一组的 $m$ 组，每组须为顺子或刻子。现给出一组 $3m + 1$ 张的牌，要求判断该组牌是否为听牌（即还差一张就可以和牌）。如果是的话，输出所有可能的等待牌。", "inputFormat": "输入包含两行。\n\n第一行包含两个由空格隔开的整数 $n,m$（$9\\le n\\le 400, 4 \\le m\\le 1000$）。\n\n第二行包含 $3m + 1$ 个由空格隔开的整数，每个数均在范围 $1$ 到 $n$ 之内。这些数代表要求判断听牌的牌的序数。", "outputFormat": "输出为一行。如果该组牌为听牌，则输出所有的可能的等待牌的序数，数字之间用一个空格隔开。所有的序数必须按从小到大的顺序输出。如果该组牌不是听牌，则输出 ```NO```。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4051", "type": "P", "difficulty": 6, "samples": [["JSOI07", "I0O7SJ"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2007", "各省省选", "江苏", "后缀数组 SA"], "title": "[JSOI2007] 字符加密", "background": null, "description": "喜欢钻研问题的 JS 同学，最近又迷上了对加密方法的思考。一天，他突然想出了一种他认为是终极的加密办法：把需要加密的信息排成一圈，显然，它们有很多种不同的读法。\n\n例如‘JSOI07’，可以读作：  JSOI07 SOI07J OI07JS I07JSO 07JSOI 7JSOI0 把它们按照字符串的大小排序： 07JSOI 7JSOI0 I07JSO JSOI07 OI07JS SOI07J 读出最后一列字符：I0O7SJ，就是加密后的字符串（其实这个加密手段实在很容易破解，鉴于这是突然想出来的，那就^^）。 但是，如果想加密的字符串实在太长，你能写一个程序完成这个任务吗？", "inputFormat": "输入文件包含一行，欲加密的字符串。注意字符串的内容不一定是字母、数字，也可以是符号等。", "outputFormat": "输出一行，为加密后的字符串。", "hint": "对于 $40\\%$ 的数据字符串的长度不超过 $10^4$。\n\n对于 $100\\%$ 的数据字符串的长度不超过 $10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2007] Character Encryption", "background": "", "description": "A student JS who enjoys exploring problems has recently become fascinated with encryption methods. One day, he suddenly came up with what he thought was the ultimate encryption method: arrange the message to be encrypted in a circle; obviously, it can be read in many different ways.\n\nFor example, 'JSOI07' can be read as: JSOI07, SOI07J, OI07JS, I07JSO, 07JSOI, 7JSOI0. Sort them lexicographically: 07JSOI, 7JSOI0, I07JSO, JSOI07, OI07JS, SOI07J. Read the last column of characters: I0O7SJ, which is the encrypted string (this encryption is actually quite easy to crack, but since it was a sudden idea, just ^^). However, if the string to be encrypted is very long, can you write a program to complete this task?", "inputFormat": "The input contains one line: the string to be encrypted. Note that the string is not necessarily letters or digits; it may also contain symbols, etc.", "outputFormat": "Output one line: the encrypted string.", "hint": "For $40\\%$ of the testdata, the length of the string does not exceed $10^4$.\n\nFor $100\\%$ of the testdata, the length of the string does not exceed $10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2007] 字符加密", "background": null, "description": "喜欢钻研问题的 JS 同学，最近又迷上了对加密方法的思考。一天，他突然想出了一种他认为是终极的加密办法：把需要加密的信息排成一圈，显然，它们有很多种不同的读法。\n\n例如‘JSOI07’，可以读作：  JSOI07 SOI07J OI07JS I07JSO 07JSOI 7JSOI0 把它们按照字符串的大小排序： 07JSOI 7JSOI0 I07JSO JSOI07 OI07JS SOI07J 读出最后一列字符：I0O7SJ，就是加密后的字符串（其实这个加密手段实在很容易破解，鉴于这是突然想出来的，那就^^）。 但是，如果想加密的字符串实在太长，你能写一个程序完成这个任务吗？", "inputFormat": "输入文件包含一行，欲加密的字符串。注意字符串的内容不一定是字母、数字，也可以是符号等。", "outputFormat": "输出一行，为加密后的字符串。", "hint": "对于 $40\\%$ 的数据字符串的长度不超过 $10^4$。\n\n对于 $100\\%$ 的数据字符串的长度不超过 $10^5$。", "locale": "zh-CN"}}}
{"pid": "P4052", "type": "P", "difficulty": 6, "samples": [["2 2\nA\nB\n", "100"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2007", "各省省选", "江苏", "O2优化", "AC 自动机"], "title": "[JSOI2007] 文本生成器", "background": "", "description": "JSOI 交给队员 ZYX 一个任务，编制一个称之为“文本生成器”的电脑软件：该软件的使用者是一些低幼人群，他们现在使用的是 GW 文本生成器 v6 版。\n\n该软件可以随机生成一些文章——总是生成一篇长度固定且完全随机的文章。 也就是说，生成的文章中每个字符都是完全随机的。如果一篇文章中至少包含使用者们了解的一个单词，那么我们说这篇文章是可读的（我们称文章 $s$ 包含单词 $t$，当且仅当单词 $t$ 是文章 $s$ 的子串）。但是，即使按照这样的标准，使用者现在使用的 GW 文本生成器 v6 版所生成的文章也是几乎完全不可读的。ZYX 需要指出 GW 文本生成器 v6 生成的所有文本中，可读文本的数量，以便能够成功获得 v7 更新版。你能帮助他吗？\n\n答案对 $10^4 + 7$ 取模。", "inputFormat": "第一行有两个整数，分别表示使用者了解的单词总数 $n$ 和生成的文章长度 $m$。\n\n接下来 $n$ 行，每行一个字符串 $s_i$，表示一个使用者了解的单词。", "outputFormat": "输出一行一个整数表示答案对 $10^4 + 7$ 取模的结果。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n- $1 \\leq n \\leq 60$，$1 \\leq m \\leq 100$。\n- $1 \\leq |s_i| \\leq 100$，其中 $|s_i|$ 表示字符串 $s_i$ 的长度。\n- $s_i$ 中只含大写英文字母。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2007] Text Generator", "background": "", "description": "JSOI assigned team member ZYX a task to develop a computer program called \"Text Generator.\" The users of this software are young children, and they are currently using the GW Text Generator v6.\n\nThis software can randomly generate some text — it always generates a text with fixed length and completely random characters. That is, each character in the generated text is completely random. If a text contains at least one word known by the users, then we say the text is readable (we say a text $s$ contains a word $t$ if and only if $t$ is a substring of $s$). However, even under such a standard, the texts generated by the current GW Text Generator v6 are almost entirely unreadable. ZYX needs to determine, among all texts generated by GW Text Generator v6, how many are readable, in order to successfully obtain the v7 update. Can you help him?\n\nOutput the answer modulo $10^4 + 7$.", "inputFormat": "The first line contains two integers, denoting the total number of words known by the users $n$ and the length of the generated text $m$.\n\nThe next $n$ lines each contain a string $s_i$, representing a word known by the users.", "outputFormat": "Output a single integer: the answer modulo $10^4 + 7$.", "hint": "Constraints and Conventions\n\nFor all test points, it is guaranteed that:\n- $1 \\leq n \\leq 60$, $1 \\leq m \\leq 100$.\n- $1 \\leq |s_i| \\leq 100$, where $|s_i|$ denotes the length of string $s_i$.\n- Each $s_i$ contains only uppercase English letters.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2007] 文本生成器", "background": "", "description": "JSOI 交给队员 ZYX 一个任务，编制一个称之为“文本生成器”的电脑软件：该软件的使用者是一些低幼人群，他们现在使用的是 GW 文本生成器 v6 版。\n\n该软件可以随机生成一些文章——总是生成一篇长度固定且完全随机的文章。 也就是说，生成的文章中每个字符都是完全随机的。如果一篇文章中至少包含使用者们了解的一个单词，那么我们说这篇文章是可读的（我们称文章 $s$ 包含单词 $t$，当且仅当单词 $t$ 是文章 $s$ 的子串）。但是，即使按照这样的标准，使用者现在使用的 GW 文本生成器 v6 版所生成的文章也是几乎完全不可读的。ZYX 需要指出 GW 文本生成器 v6 生成的所有文本中，可读文本的数量，以便能够成功获得 v7 更新版。你能帮助他吗？\n\n答案对 $10^4 + 7$ 取模。", "inputFormat": "第一行有两个整数，分别表示使用者了解的单词总数 $n$ 和生成的文章长度 $m$。\n\n接下来 $n$ 行，每行一个字符串 $s_i$，表示一个使用者了解的单词。", "outputFormat": "输出一行一个整数表示答案对 $10^4 + 7$ 取模的结果。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n- $1 \\leq n \\leq 60$，$1 \\leq m \\leq 100$。\n- $1 \\leq |s_i| \\leq 100$，其中 $|s_i|$ 表示字符串 $s_i$ 的长度。\n- $s_i$ 中只含大写英文字母。", "locale": "zh-CN"}}}
{"pid": "P4053", "type": "P", "difficulty": 5, "samples": [["4\n100 200\n200 1300\n1000 1250\n2000 3200", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2007", "各省省选", "江苏", "优先队列", "反悔贪心"], "title": "[JSOI2007] 建筑抢修", "background": "", "description": "小刚在玩 JSOI 提供的一个称之为“建筑抢修”的电脑游戏：经过了一场激烈的战斗，T 部落消灭了所有 Z 部落的入侵者。但是 T 部落的基地里已经有 $N$ 个建筑设施受到了严重的损伤，如果不尽快修复的话，这些建筑设施将会完全毁坏。现在的情况是：T 部落基地里只有一个修理工人，虽然他能瞬间到达任何一个建筑，但是修复每个建筑都需要一定的时间。同时，修理工人修理完一个建筑才能修理下一个建筑，不能同时修理多个建筑。如果某个建筑在一段时间之内没有完全修理完毕，这个建筑就报废了。你的任务是帮小刚合理的制订一个修理顺序，以抢修尽可能多的建筑。\n", "inputFormat": "第一行，一个整数 $N$。\n\n接下来 $N$ 行，每行两个整数 $T_1,T_2$ 描述一个建筑：修理这个建筑需要 $T_1$ 秒，如果在 $T_2$ 秒之内还没有修理完成，这个建筑就报废了。\n", "outputFormat": "输出一个整数 $S$，表示最多可以抢修 $S$ 个建筑。\n", "hint": "对于 $100 \\%$ 的数据，$1 \\le N < 150000$，$1 \\le T_1 < T_2 < 2^{31}$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2007] Emergency Building Repair", "background": "", "description": "Xiaogang is playing a computer game provided by JSOI called \"Emergency Building Repair\": after an intense battle, the T tribe has eliminated all invaders from the Z tribe. However, $N$ buildings in the T tribe’s base have been severely damaged and will be completely destroyed if not repaired quickly. There is only one repair worker in the base. Although he can reach any building instantly, repairing each building takes a certain amount of time. The worker can repair only one building at a time and must finish repairing one building before starting the next. If a building is not fully repaired within a certain period of time, it will be scrapped. Your task is to help Xiaogang determine a repair order to repair as many buildings as possible.", "inputFormat": "The first line contains an integer $N$.\n\nThe next $N$ lines each contain two integers $T_1, T_2$ describing a building: repairing this building takes $T_1$ seconds, and if the repair is not completed within $T_2$ seconds, the building will be scrapped.", "outputFormat": "Output an integer $S$, the maximum number of buildings that can be repaired.", "hint": "Constraints: For $100 \\%$ of the testdata, $1 \\le N < 150000$, and $1 \\le T_1 < T_2 < 2^{31}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2007] 建筑抢修", "background": "", "description": "小刚在玩 JSOI 提供的一个称之为“建筑抢修”的电脑游戏：经过了一场激烈的战斗，T 部落消灭了所有 Z 部落的入侵者。但是 T 部落的基地里已经有 $N$ 个建筑设施受到了严重的损伤，如果不尽快修复的话，这些建筑设施将会完全毁坏。现在的情况是：T 部落基地里只有一个修理工人，虽然他能瞬间到达任何一个建筑，但是修复每个建筑都需要一定的时间。同时，修理工人修理完一个建筑才能修理下一个建筑，不能同时修理多个建筑。如果某个建筑在一段时间之内没有完全修理完毕，这个建筑就报废了。你的任务是帮小刚合理的制订一个修理顺序，以抢修尽可能多的建筑。\n", "inputFormat": "第一行，一个整数 $N$。\n\n接下来 $N$ 行，每行两个整数 $T_1,T_2$ 描述一个建筑：修理这个建筑需要 $T_1$ 秒，如果在 $T_2$ 秒之内还没有修理完成，这个建筑就报废了。\n", "outputFormat": "输出一个整数 $S$，表示最多可以抢修 $S$ 个建筑。\n", "hint": "对于 $100 \\%$ 的数据，$1 \\le N < 150000$，$1 \\le T_1 < T_2 < 2^{31}$。", "locale": "zh-CN"}}}
{"pid": "P4054", "type": "P", "difficulty": 5, "samples": [["3 3\n1 2 3\n3 2 1\n2 1 3\n3\n2 1 2 1 2 1\n1 2 3 2\n2 2 3 2 3 2", "1\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2009", "各省省选", "树状数组", "江苏", "前缀和"], "title": "[JSOI2009] 计数问题", "background": null, "description": "一个 $n \\times m$ 的方格，初始时每个格子有一个整数权值。接下来每次有 2 种操作：\n\n- 改变一个格子的权值；\n\n- 求一个子矩阵中某种特定权值出现的个数。", "inputFormat": "第一行有两个数 $n,m$。\n\n接下来 $n$ 行，每行 $m$ 个数，第 $i+1$ 行第 $j$ 个数表示格子 $(i,j)$ 的初始权值。\n\n接下来输入一个整数 $Q$。\n\n之后 $Q$ 行，每行描述一个操作。\n\n操作 1：输入一行四个整数 $1\\ x\\ y\\ c$，表示将格子 $(x,y)$ 的权值改成 $c$。\n\n操作 2：输入一行六个整数 $2\\ x_1\\ x_2\\ y_1\\ y_2\\ c$。表示询问所有满足格子颜色为 $c$，且满足 $x_1\\le x\\le x_2,y_1\\le y\\le y_2$ 的格子个数。", "outputFormat": "对于每个操作 2，按照在输入中出现的顺序，依次输出一行一个整数表示所求得的个数。", "hint": "【数据规模与约定】\n\n对于 $30\\%$ 的数据，满足：$n,m\\le 30$，$Q\\le 5\\times 10^4$。\n\n对于 $100\\%$ 的数据，满足：$1\\le n,m\\le 300$，$1\\le Q\\le 2\\times 10^5$。\n\n对于操作 1，保证：$1\\le x\n\\le n$，$1\\le y\\le m$，$1\\le c\\le 100$；\n\n对于操作 2，保证：$1\\le x_1≤x_2\\le n$，$1\\le y_1\\le y_2\\le m$，$1\\le c\\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2009] Counting Problem", "background": "", "description": "There is an $n \\times m$ grid. Initially, each cell has an integer weight. Then there are 2 types of operations:\n\n- Change the weight of a cell.\n- Query how many times a specified weight appears in a submatrix.", "inputFormat": "The first line contains two integers $n, m$.\n\nThen follow $n$ lines, each with $m$ integers. In the $(i+1)$-th line, the $j$-th number is the initial weight of cell $(i, j)$.\n\nThen an integer $Q$ is given.\n\nThen there are $Q$ lines, each describing an operation.\n\nOperation 1: A line with four integers $1\\ x\\ y\\ c$, meaning set the weight of cell $(x, y)$ to $c$.\n\nOperation 2: A line with six integers $2\\ x_1\\ x_2\\ y_1\\ y_2\\ c$, meaning query the number of cells whose weight is $c$ and satisfy $x_1\\le x\\le x_2, y_1\\le y\\le y_2$.", "outputFormat": "For each operation 2, output one integer per line in the order they appear, representing the required count.", "hint": "Constraints\n\nFor $30\\%$ of the testdata: $n, m\\le 30$, $Q\\le 5\\times 10^4$.\n\nFor $100\\%$ of the testdata: $1\\le n, m\\le 300$, $1\\le Q\\le 2\\times 10^5$.\n\nFor operation 1, it is guaranteed that $1\\le x\\le n$, $1\\le y\\le m$, $1\\le c\\le 100$.\n\nFor operation 2, it is guaranteed that $1\\le x_1\\le x_2\\le n$, $1\\le y_1\\le y_2\\le m$, $1\\le c\\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2009] 计数问题", "background": null, "description": "一个 $n \\times m$ 的方格，初始时每个格子有一个整数权值。接下来每次有 2 种操作：\n\n- 改变一个格子的权值；\n\n- 求一个子矩阵中某种特定权值出现的个数。", "inputFormat": "第一行有两个数 $n,m$。\n\n接下来 $n$ 行，每行 $m$ 个数，第 $i+1$ 行第 $j$ 个数表示格子 $(i,j)$ 的初始权值。\n\n接下来输入一个整数 $Q$。\n\n之后 $Q$ 行，每行描述一个操作。\n\n操作 1：输入一行四个整数 $1\\ x\\ y\\ c$，表示将格子 $(x,y)$ 的权值改成 $c$。\n\n操作 2：输入一行六个整数 $2\\ x_1\\ x_2\\ y_1\\ y_2\\ c$。表示询问所有满足格子颜色为 $c$，且满足 $x_1\\le x\\le x_2,y_1\\le y\\le y_2$ 的格子个数。", "outputFormat": "对于每个操作 2，按照在输入中出现的顺序，依次输出一行一个整数表示所求得的个数。", "hint": "【数据规模与约定】\n\n对于 $30\\%$ 的数据，满足：$n,m\\le 30$，$Q\\le 5\\times 10^4$。\n\n对于 $100\\%$ 的数据，满足：$1\\le n,m\\le 300$，$1\\le Q\\le 2\\times 10^5$。\n\n对于操作 1，保证：$1\\le x\n\\le n$，$1\\le y\\le m$，$1\\le c\\le 100$；\n\n对于操作 2，保证：$1\\le x_1≤x_2\\le n$，$1\\le y_1\\le y_2\\le m$，$1\\le c\\le 100$。", "locale": "zh-CN"}}}
{"pid": "P4055", "type": "P", "difficulty": 6, "samples": [["3 3\n.##\n...\n#.#", "WIN\n2 3\n3 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "各省省选", "网络流", "江苏", "二分图"], "title": "[JSOI2009] 游戏", "background": "", "description": "小 AA 和小 YY 得到了《喜羊羊和灰太狼》的电影票，都很想去观看，但是电影票只有一张，于是他们用智力游戏决定胜负，赢得游戏的人可以获得电影票。\n\n在 $N \\times M$ 的迷宫中有一个棋子，小 AA 首先任意选择棋子放置的位置。然后，小 YY 和小 AA 轮流将棋子移动到相邻的格子里。游戏的规则规定，在一次游戏中，同一个格子不能进入两次，且不能将棋子移动到某些格子中去。当玩家无法继续移动棋子时，游戏结束，最后一个移动棋子的玩家赢得了游戏。\n\n例如下图所示的迷宫，迷宫中 `.` 表示棋子可以经过的格子，而 `#` 表示棋子不可以经过的格子：\n\n```cpp\n                                 .##\n                                 ...\n                                 #.# \n```                                 \n若小 AA 将棋子放置在 $(1,1)$，则小 AA 则无论如何都无法赢得游戏。\n\n而若小 AA 将棋子放置在 $(3,2)$ 或 $(2,3)$，则小 AA 能够赢得游戏。例如，小 AA 将棋子放置在 $(3,2)$，小 YY 只能将它移动到 $(2,2)$，此时小 AA 再将棋子移动到 $(2,3)$，就赢得了游戏。\n\n小 AA 和小 YY 都是绝顶聪明的小朋友，且从不失误。小 AA 到底能不能赢得这场游戏，从而得到珍贵的电影票呢？", "inputFormat": "输入数据首先输入两个整数 $N,M$，表示了迷宫的边长。\n\n接下来 $N$ 行，每行 $M$ 个字符，描述了迷宫。\n", "outputFormat": "若小 AA 能够赢得游戏，则输出一行 `WIN`，然后输出所有可以赢得游戏的起始位置，按行优先顺序输出，每行一个。\n\n否则输出一行 `LOSE`。\n", "hint": "- 对 $30\\%$ 的数据，有 $n,m \\leq 5$；\n- 对 $100\\%$ 的数据，有 $1 \\leq n,m \\leq 100$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2009] Game", "background": "", "description": "Little AA and Little YY got a movie ticket for \"Pleasant Goat and Big Big Wolf\". They both want to watch it, but there is only one ticket, so they decide the winner by playing a strategy game. The winner gets the ticket.\n\nIn an $N \\times M$ maze there is a piece. Little AA first chooses any starting cell to place the piece. Then Little YY and Little AA take turns moving the piece to an adjacent cell. The rules state that in a single game, the same cell cannot be visited twice, and the piece cannot be moved into certain cells. When a player can no longer move the piece, the game ends, and the player who made the last move wins.\n\nFor example, in the maze below, `.` indicates a passable cell for the piece, and `#` indicates an impassable cell:\n\n```cpp\n                                 .##\n                                 ...\n                                 #.# \n```\nIf Little AA places the piece at $(1, 1)$, then AA cannot win no matter what.\n\nIf Little AA places the piece at $(3, 2)$ or $(2, 3)$, then AA can win. For example, if AA places the piece at $(3, 2)$, Little YY can only move it to $(2, 2)$. Then AA moves the piece to $(2, 3)$ and wins the game.\n\nLittle AA and Little YY are both extremely smart and never make mistakes. Can Little AA win this game and get the precious movie ticket?", "inputFormat": "The input begins with two integers $N, M$, representing the dimensions of the maze.\n\nThen follow $N$ lines, each with $M$ characters describing the maze.", "outputFormat": "If Little AA can win the game, output a line `WIN`, then output all winning starting positions in row-major order, one per line. For each line, print the position as two integers $r$ and $c$ (1-based).\n\nOtherwise, output a single line `LOSE`.", "hint": "Constraints:\n- For $30\\%$ of the testdata, $N, M \\leq 5$.\n- For $100\\%$ of the testdata, $1 \\leq N, M \\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2009] 游戏", "background": "", "description": "小 AA 和小 YY 得到了《喜羊羊和灰太狼》的电影票，都很想去观看，但是电影票只有一张，于是他们用智力游戏决定胜负，赢得游戏的人可以获得电影票。\n\n在 $N \\times M$ 的迷宫中有一个棋子，小 AA 首先任意选择棋子放置的位置。然后，小 YY 和小 AA 轮流将棋子移动到相邻的格子里。游戏的规则规定，在一次游戏中，同一个格子不能进入两次，且不能将棋子移动到某些格子中去。当玩家无法继续移动棋子时，游戏结束，最后一个移动棋子的玩家赢得了游戏。\n\n例如下图所示的迷宫，迷宫中 `.` 表示棋子可以经过的格子，而 `#` 表示棋子不可以经过的格子：\n\n```cpp\n                                 .##\n                                 ...\n                                 #.# \n```                                 \n若小 AA 将棋子放置在 $(1,1)$，则小 AA 则无论如何都无法赢得游戏。\n\n而若小 AA 将棋子放置在 $(3,2)$ 或 $(2,3)$，则小 AA 能够赢得游戏。例如，小 AA 将棋子放置在 $(3,2)$，小 YY 只能将它移动到 $(2,2)$，此时小 AA 再将棋子移动到 $(2,3)$，就赢得了游戏。\n\n小 AA 和小 YY 都是绝顶聪明的小朋友，且从不失误。小 AA 到底能不能赢得这场游戏，从而得到珍贵的电影票呢？", "inputFormat": "输入数据首先输入两个整数 $N,M$，表示了迷宫的边长。\n\n接下来 $N$ 行，每行 $M$ 个字符，描述了迷宫。\n", "outputFormat": "若小 AA 能够赢得游戏，则输出一行 `WIN`，然后输出所有可以赢得游戏的起始位置，按行优先顺序输出，每行一个。\n\n否则输出一行 `LOSE`。\n", "hint": "- 对 $30\\%$ 的数据，有 $n,m \\leq 5$；\n- 对 $100\\%$ 的数据，有 $1 \\leq n,m \\leq 100$。\n", "locale": "zh-CN"}}}
{"pid": "P4056", "type": "P", "difficulty": 6, "samples": [["4  10 \n1  1  20 \n10 10 10 \n3  5  60 \n5  3  30", "-4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "各省省选", "江苏", "斜率优化"], "title": "[JSOI2009] 火星藏宝图", "background": "JSOI2009第三轮二试\n", "description": "在火星游玩多日,jyy 偶然地发现了一张藏宝图。根据藏宝图上说法，宝藏被埋藏在一个巨大的湖里的 $N$ 个岛上 $(2\\le N \\le 2 \\times 10^{5})$。为了方便描述，地图把整个湖划分成 $M$ 行 $M$ 列 $(1\\le M\\le 1000)$,共 $M \\times M$ 个小块，并把所有岛按照 $1...N$ 编了号。第 $i$ 个岛位于第 $X_i$ 行 $Y_i$ 列 (设其坐标为 $(X_i,Y_i)$的格子 （ $X_i,Y_i$ 均为整数，并且满足 $1<=X_i,Y_i<=M$ ）,岛上藏有价值财富 $V_i(1\\le V_i\\le 10,000)$。湖的左上角 $(1,1)$ 和右下角 $(M,M)$ 都有岛，有桥将它们与陆地相连。\n\njyy 没费多大劲，就找到了那个湖，同时哭笑不得地发现，所谓的财富，是各个岛上出产的珍稀水果。jyy 在左上角的岛的岸边找到了一条小木船，他可以划船到其他岛上去。划船是要消耗体力的，具体地说，等于两岛 Euclidean 距离的平方(即，从 $(X_1,Y_1)$ 划船到 $(X_2,Y_2)$ 所耗费的体力为 $(X_1-X_2)^2+(Y_1-Y_2)^2$ 个单位)。jyy 可以吃水果来恢复体力，吃掉 $1$ 单位价值的水果能恢复 $1$ 单位体力。\n\n现在 jyy 打算从 $(1,1)$ 旅行到 $(M,M)$，沿途收集珍稀水果。按藏宝图上的提示，jyy 离开一个岛后，就只能去该岛右下方的区域（正下和正右方向也是允许的），否则会遭遇水怪。jyy 可以在旅行途中饿一段时间，即体力为负。但抵达终点后，只要身边有足够多的水果，他就会通过吃水果将体力恢复到旅行前的水平。\n\njyy想知道，经过一次旅行，他最多能得到多少收益，即 `jyy 收集到的水果总价值- jyy 在旅途中花的总体力` 。(如果吃完所有水果他还饿着，收益就是负数，具体的例子见样例)", "inputFormat": "第 $1$ 行：两个整数 $N,M$。第 $2...N+1$ 行：每行 $3$ 个整数，第 $i+1$ 行的 $3$ 个整数分别为 $ X_i$，$Y_i$，$V_i$。每个岛的坐标不同。保证存在坐标 $(1,1)$ 和 $(M,M)$ 的岛。", "outputFormat": "第 $1$ 行：输出一个整数，表示最大收益。", "hint": "### 样例解释\n\n$20+60+10-\\left ( \\left(3-1 \\right )^2+\\left (5-1 \\right )^2 \\right )-\\left ( \\left (10-3 \\right )^2+\\left (10-5 \\right )^2 \\right )=-4$\n\n### 数据范围\n\n对 $20\\%$ 的数据 $M\\le 200$，且 $N\\le 2\\times 10^3$。\n\n对 $50\\%$ 的数据 $M\\le 200$，且 $N\\le 2\\times 10^4$。\n\n对 $100\\%$ 的数据 $M\\le 1000$，且 $N\\le 2\\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2009] Mars Treasure Map", "background": "JSOI 2009 Round 3, second exam.", "description": "After traveling on Mars for many days, jyy accidentally discovered a treasure map. According to the map, the treasure is buried on $N$ islands $(2\\le N \\le 2 \\times 10^{5})$ in a huge lake. For convenience, the map divides the entire lake into $M$ rows and $M$ columns $(1\\le M\\le 1000)$, a total of $M \\times M$ cells, and numbers all islands from $1$ to $N$. The $i$-th island is located at row $X_i$, column $Y_i$ (that is, on the cell with coordinates $(X_i,Y_i)$, where $X_i,Y_i$ are integers satisfying $1<=X_i,Y_i<=M$), and the island contains treasure worth $V_i(1\\le V_i\\le 10,000)$. There are islands at the top-left $(1,1)$ and bottom-right $(M,M)$ corners of the lake, and there are bridges connecting them to the land.\n\njyy soon found the lake and, to his amusement, discovered that the so-called treasure is the rare fruits produced on each island. At the shore of the island at the top-left corner, jyy found a small wooden boat, with which he can row to other islands. Rowing consumes stamina equal to the square of the Euclidean distance between two islands (that is, rowing from $(X_1,Y_1)$ to $(X_2,Y_2)$ costs $(X_1-X_2)^2+(Y_1-Y_2)^2$ units of stamina). jyy can eat fruit to restore stamina; consuming 1 unit of fruit value restores 1 unit of stamina.\n\nNow jyy plans to travel from $(1,1)$ to $(M,M)$, collecting rare fruits along the way. As hinted on the treasure map, after leaving an island, he may only go to the region to its lower-right (moving directly down or directly right is also allowed); otherwise, he will encounter a water monster. jyy may travel while hungry, i.e., stamina can be negative. Upon reaching the destination, as long as he has enough fruit with him, he will eat to restore his stamina to the pre-trip level.\n\njyy wants to know, after one trip, what is the maximum net gain, defined as jyy’s total collected fruit value minus jyy’s total stamina spent during the trip. (If he is still hungry after eating all the fruit, the net gain is negative; see the sample for a specific example.)", "inputFormat": "The first line contains two integers $N,M$.  \nLines $2$ to $N+1$: each line contains $3$ integers. On line $i+1$, the $3$ integers are $X_i$, $Y_i$, and $V_i$.  \nEach island has distinct coordinates. It is guaranteed that there are islands at coordinates $(1,1)$ and $(M,M)$.", "outputFormat": "Output a single integer on the first line, representing the maximum net gain.", "hint": "Sample Explanation:\n$20+60+10-\\left ( \\left(3-1 \\right )^2+\\left (5-1 \\right )^2 \\right )-\\left ( \\left (10-3 \\right )^2+\\left (10-5 \\right )^2 \\right )=-4$\n\nConstraints:\n- For $20\\%$ of the testdata, $M\\le 200$, and $N\\le 2\\times 10^3$.\n- For $50\\%$ of the testdata, $M\\le 200$, and $N\\le 2\\times 10^4$.\n- For $100\\%$ of the testdata, $M\\le 1000$, and $N\\le 2\\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2009] 火星藏宝图", "background": "JSOI2009第三轮二试\n", "description": "在火星游玩多日,jyy 偶然地发现了一张藏宝图。根据藏宝图上说法，宝藏被埋藏在一个巨大的湖里的 $N$ 个岛上 $(2\\le N \\le 2 \\times 10^{5})$。为了方便描述，地图把整个湖划分成 $M$ 行 $M$ 列 $(1\\le M\\le 1000)$,共 $M \\times M$ 个小块，并把所有岛按照 $1...N$ 编了号。第 $i$ 个岛位于第 $X_i$ 行 $Y_i$ 列 (设其坐标为 $(X_i,Y_i)$的格子 （ $X_i,Y_i$ 均为整数，并且满足 $1<=X_i,Y_i<=M$ ）,岛上藏有价值财富 $V_i(1\\le V_i\\le 10,000)$。湖的左上角 $(1,1)$ 和右下角 $(M,M)$ 都有岛，有桥将它们与陆地相连。\n\njyy 没费多大劲，就找到了那个湖，同时哭笑不得地发现，所谓的财富，是各个岛上出产的珍稀水果。jyy 在左上角的岛的岸边找到了一条小木船，他可以划船到其他岛上去。划船是要消耗体力的，具体地说，等于两岛 Euclidean 距离的平方(即，从 $(X_1,Y_1)$ 划船到 $(X_2,Y_2)$ 所耗费的体力为 $(X_1-X_2)^2+(Y_1-Y_2)^2$ 个单位)。jyy 可以吃水果来恢复体力，吃掉 $1$ 单位价值的水果能恢复 $1$ 单位体力。\n\n现在 jyy 打算从 $(1,1)$ 旅行到 $(M,M)$，沿途收集珍稀水果。按藏宝图上的提示，jyy 离开一个岛后，就只能去该岛右下方的区域（正下和正右方向也是允许的），否则会遭遇水怪。jyy 可以在旅行途中饿一段时间，即体力为负。但抵达终点后，只要身边有足够多的水果，他就会通过吃水果将体力恢复到旅行前的水平。\n\njyy想知道，经过一次旅行，他最多能得到多少收益，即 `jyy 收集到的水果总价值- jyy 在旅途中花的总体力` 。(如果吃完所有水果他还饿着，收益就是负数，具体的例子见样例)", "inputFormat": "第 $1$ 行：两个整数 $N,M$。第 $2...N+1$ 行：每行 $3$ 个整数，第 $i+1$ 行的 $3$ 个整数分别为 $ X_i$，$Y_i$，$V_i$。每个岛的坐标不同。保证存在坐标 $(1,1)$ 和 $(M,M)$ 的岛。", "outputFormat": "第 $1$ 行：输出一个整数，表示最大收益。", "hint": "### 样例解释\n\n$20+60+10-\\left ( \\left(3-1 \\right )^2+\\left (5-1 \\right )^2 \\right )-\\left ( \\left (10-3 \\right )^2+\\left (10-5 \\right )^2 \\right )=-4$\n\n### 数据范围\n\n对 $20\\%$ 的数据 $M\\le 200$，且 $N\\le 2\\times 10^3$。\n\n对 $50\\%$ 的数据 $M\\le 200$，且 $N\\le 2\\times 10^4$。\n\n对 $100\\%$ 的数据 $M\\le 1000$，且 $N\\le 2\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4057", "type": "P", "difficulty": 2, "samples": [["2 3 5\n", "30"], ["3 4 6\n", "12"], ["10 100 1000\n", "1000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "O2优化", "最大公约数 gcd", "Code+"], "title": "[Code+#1] 晨跑", "background": null, "description": "“无体育，不清华”、“每天锻炼一小时，健康工作五十年，幸福生活一辈子”\n\n\n在清华，体育运动绝对是同学们生活中不可或缺的一部分。为了响应学校的号召，模范好学生王队长决定坚持晨跑。不过由于种种原因，每天都早起去跑步不太现实，所以王队长决定每 $a$ 天晨跑一次。换句话说，假如王队长某天早起去跑了步，之后他会休息 $a-1$ 天，然后第 $a$ 天继续去晨跑，并以此类推。\n\n\n王队长的好朋友小钦和小针深受王队长坚持锻炼的鼓舞，并决定自己也要坚持晨跑。为了适宜自己的情况，小钦决定每 $b$ 天早起跑步一次，而小针决定每 $c$ 天早起跑步一次。\n\n\n某天早晨，王队长、小钦和小针在早起跑步时相遇了，他们非常激动、相互鼓励，共同完成了一次完美的晨跑。为了表述方便，我们把三位同学相遇的这天记为第$0$天。假设三位同学每次晨跑的时间段和路线都相同，他们想知道，下一次三人在跑步时相遇是第几天。由于三位同学都不会算，所以希望由聪明的你来告诉他们答案。", "inputFormat": "输入共一行，包含三个正整数 $a,b,c$，表示王队长每隔 $a$ 天晨跑一次、小钦每隔 $b$ 天晨跑一次且小针每隔 $c$ 天晨跑一次。", "outputFormat": "输出共一行，包含一个正整数 $x$，表示三位同学下次将在第 $x$ 天相遇。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/12819.png) \n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/何昊天 命题/何昊天 验题/卢政荣\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#1] Morning Run", "background": "", "description": "\"Without sports, there is no Tsinghua.\" \"Exercise one hour a day, work healthily for fifty years, live a happy life for a lifetime.\"\n\nAt Tsinghua, sports are an indispensable part of students' lives. To respond to the school's call, model student Captain Wang decides to stick to morning runs. However, for various reasons, getting up early to run every day is not realistic, so Captain Wang decides to run once every $a$ days. In other words, if Captain Wang gets up early to run on a certain day, he will rest for $a-1$ days afterward, then run again on the $a$-th day, and so on.\n\nInspired by Captain Wang's persistence, his good friends Xiao Qin and Xiao Zhen also decide to keep up with morning runs. To suit their own situations, Xiao Qin decides to run once every $b$ days, and Xiao Zhen decides to run once every $c$ days.\n\nOne morning, Captain Wang, Xiao Qin, and Xiao Zhen meet during their early run. They are very excited, encourage each other, and complete a perfect morning run together. For convenience, we label this meeting day as day $0$. Assuming the time window and route of each morning run are the same, they want to know on which day they will meet again while running. Since none of them can do the math, they ask you to tell them the answer.", "inputFormat": "The input consists of one line containing three positive integers $a$, $b$, $c$, meaning Captain Wang runs every $a$ days, Xiao Qin runs every $b$ days, and Xiao Zhen runs every $c$ days.", "outputFormat": "Output one line containing a positive integer $x$, indicating that the next time the three students meet will be on day $x$.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/12819.png)\n\nFrom the CodePlus 2017 November Contest, presented with honor by the Student Algorithm and Programming Contest Association of the Department of Computer Science and Technology, Tsinghua University.\n\nCredit: idea/He Haotian, problem setting/He Haotian, verification/Lu Zhengrong.\n\nGit Repo: https://git.thusaac.org/publish/CodePlus201711\n\nThanks to Tencent for supporting this contest.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#1] 晨跑", "background": null, "description": "“无体育，不清华”、“每天锻炼一小时，健康工作五十年，幸福生活一辈子”\n\n\n在清华，体育运动绝对是同学们生活中不可或缺的一部分。为了响应学校的号召，模范好学生王队长决定坚持晨跑。不过由于种种原因，每天都早起去跑步不太现实，所以王队长决定每 $a$ 天晨跑一次。换句话说，假如王队长某天早起去跑了步，之后他会休息 $a-1$ 天，然后第 $a$ 天继续去晨跑，并以此类推。\n\n\n王队长的好朋友小钦和小针深受王队长坚持锻炼的鼓舞，并决定自己也要坚持晨跑。为了适宜自己的情况，小钦决定每 $b$ 天早起跑步一次，而小针决定每 $c$ 天早起跑步一次。\n\n\n某天早晨，王队长、小钦和小针在早起跑步时相遇了，他们非常激动、相互鼓励，共同完成了一次完美的晨跑。为了表述方便，我们把三位同学相遇的这天记为第$0$天。假设三位同学每次晨跑的时间段和路线都相同，他们想知道，下一次三人在跑步时相遇是第几天。由于三位同学都不会算，所以希望由聪明的你来告诉他们答案。", "inputFormat": "输入共一行，包含三个正整数 $a,b,c$，表示王队长每隔 $a$ 天晨跑一次、小钦每隔 $b$ 天晨跑一次且小针每隔 $c$ 天晨跑一次。", "outputFormat": "输出共一行，包含一个正整数 $x$，表示三位同学下次将在第 $x$ 天相遇。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/12819.png) \n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/何昊天 命题/何昊天 验题/卢政荣\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN"}}}
{"pid": "P4058", "type": "P", "difficulty": 3, "samples": [["3 74 51\n2 5 2\n2 7 9\n", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["二分", "O2优化", "优先队列", "Code+"], "title": "[Code+#1] 木材", "background": "", "description": "有 $n$ 棵树，初始时每棵树的高度为 $H_i$，第 $i$ 棵树每月都会长高 $A_i$。现在有个木料长度总量为 $S$ 的订单，客户要求每块木料的长度不能小于  $L$，而且木料必须是整棵树（即不能为树的一部分）。现在问你最少需要等多少个月才能满足订单。\n", "inputFormat": "第一行 $3$ 个用空格隔开的非负整数 $n,S,L$，表示树的数量、订单总量和单块木料长度限制。\n\n第二行 $n$ 个用空格隔开的非负整数，依次为 $H_1,H_2, ... ,H_n$。\n\n第三行 $n$ 个用空格隔开的非负整数，依次为 $A_1,A_2, ... ,A_n$。\n", "outputFormat": "输出一行一个整数表示答案。\n", "hint": "对于样例，在六个月后，各棵树的高度分别为 $14,47,56$，此时无法完成订单。\n\n在七个月后，各棵树的高度分别为 $16,54,65$，此时可以砍下第 $2$ 和第 $3$ 棵树完成订单了。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12821.png) \n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/郑林楷 命题/郑林楷 验题/王聿中\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#1] Timber", "background": "", "description": "There are $n$ trees. Initially, the $i$-th tree has height $H_i$, and every month the $i$-th tree grows by $A_i$. There is an order for a total timber length of $S$. The client requires each piece of timber to have length at least $L$, and each piece must be a whole tree (i.e., you cannot take only part of a tree). What is the minimum number of months you need to wait to fulfill the order?", "inputFormat": "The first line contains $3$ non-negative integers $n$, $S$, $L$ separated by spaces, denoting the number of trees, the total required length, and the minimum length for a single piece, respectively.\n\nThe second line contains $n$ non-negative integers $H_1, H_2, \\ldots, H_n$.\n\nThe third line contains $n$ non-negative integers $A_1, A_2, \\ldots, A_n$.", "outputFormat": "Output a single integer on one line representing the answer.", "hint": "For the sample, after six months, the heights of the trees are $14$, $47$, $56$, and the order cannot be fulfilled.\n\nAfter seven months, the heights are $16$, $54$, $65$. You can then cut down the $2$-nd and $3$-rd trees to fulfill the order.\n\n![](https://cdn.luogu.com.cn/upload/pic/12821.png)\n\nFrom CodePlus 2017 November Contest, proudly presented by the Student Association for Algorithms and Competitions, Department of Computer Science and Technology, Tsinghua University.\n\nCredit: idea/Zheng Linkai, problem setter/Zheng Linkai, tester/Wang Yuzhong.\n\nGit Repo: https://git.thusaac.org/publish/CodePlus201711\n\nThanks to Tencent for supporting this contest.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#1] 木材", "background": "", "description": "有 $n$ 棵树，初始时每棵树的高度为 $H_i$，第 $i$ 棵树每月都会长高 $A_i$。现在有个木料长度总量为 $S$ 的订单，客户要求每块木料的长度不能小于  $L$，而且木料必须是整棵树（即不能为树的一部分）。现在问你最少需要等多少个月才能满足订单。\n", "inputFormat": "第一行 $3$ 个用空格隔开的非负整数 $n,S,L$，表示树的数量、订单总量和单块木料长度限制。\n\n第二行 $n$ 个用空格隔开的非负整数，依次为 $H_1,H_2, ... ,H_n$。\n\n第三行 $n$ 个用空格隔开的非负整数，依次为 $A_1,A_2, ... ,A_n$。\n", "outputFormat": "输出一行一个整数表示答案。\n", "hint": "对于样例，在六个月后，各棵树的高度分别为 $14,47,56$，此时无法完成订单。\n\n在七个月后，各棵树的高度分别为 $16,54,65$，此时可以砍下第 $2$ 和第 $3$ 棵树完成订单了。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12821.png) \n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/郑林楷 命题/郑林楷 验题/王聿中\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。\n", "locale": "zh-CN"}}}
{"pid": "P4059", "type": "P", "difficulty": 4, "samples": [["ATGG\nATCC\n5 -4 -4 -4 \n-4 5 -4 -4 \n-4 -4 5 -4 \n-4 -4 -4 5 \n2 1", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "递推", "O2优化", "Code+"], "title": "[Code+#1] 找爸爸", "background": null, "description": "小 A 最近一直在找自己的爸爸，用什么办法呢，就是 DNA 比对。\n\n小 A 有一套自己的 DNA 序列比较方法，其最终目标是最大化两个 DNA 序列的相似程度，具体步骤如下：\n\n\n1. 给出两个 DNA 序列，第一个长度为 $n$，第二个长度为 $m$。\n\n2. 在两个序列的任意位置插入任意多的空格，使得两个字符串长度相同\n\n3. 逐位进行匹配，**如果两个序列相同位置上的字符都不是空格**，假设第一个是 $x$，第二个是 $y$，那么他们的相似程度由 $d(x,y)$ 定义。对于两个序列中任意一段极长的长度为 $k$ 的连续空格，我们定义这段空格的相似程度为 $g(k)=-A-B(k-1)$。\n\n\n那么最终两个序列的相似程度就是所有的 $d(x,y)$ 加上所有的极长空格段的相似程度之和。\n\n现在小 A 通过某种奥妙重重的方式得到了小 B 的 DNA 序列中的一段，他想请你帮他算一下小 A 的 DNA 序列和小 B 的 DNA 序列的最大相似程度。", "inputFormat": "输入第 $1$ 行一个字符串，表示小 A 的 DNA 序列。\n\n输入第 $2$ 行一个字符串，表示小 B 的 DNA 序列。\n\n接下来 $4$ 行，每行 $4$ 个整数，用空格隔开，表示 $d$ 数组，具体顺序如下所示。\n\n```plain\nd(A,A) d(A,T) d(A,G) d(A,C)\nd(T,A) d(T,T) d(T,G) d(T,C)\nd(G,A) d(G,T) d(G,G) d(G,C)\nd(C,A) d(C,T) d(C,G) d(C,C)\n```\n最后一行两个用空格隔开的正整数 $A,B$，意义如题中所述。", "outputFormat": "输出共一行，表示两个序列的最大相似程度。", "hint": "### 样例解释\n\n首先，将序列补成如下形式（\"-\"代表空格）\n\n```cpp\nATGG--\nAT--CC\n```\n然后所有 $d(x,y)$ 的和为 $d(A,A)+d(T,T)=10$\n\n所有极长连续空格段的相似程度之和为 $g(2)+g(2)=-6$\n\n总和为 $4$，可以验证，这是相似程度最大的情况。\n\n对于所有测试点，有 $0< B<A \\le 1000, -1000\\le d(x,y)\\le 1000,d(x,y)=d(y,x)$，序列只包含${A,T,G,C}$四种字符。\n\n::cute-table{tuack}\n\n|测试点编号|$n+m$ 的范围|特殊约定|\n|:-:|:-:|:-:|\n|$1$|$n=m=1$|无特殊要求|\n|$2$|$n+m\\le15$|^|\n|$3$|$n+m\\le300$|^|\n|$4$|^|^|\n|$5$|$n+m\\le3000$|序列中只包含一个字符|\n|$6$|^|无特殊要求|\n|$7$|^|^|\n|$8$|^|^|\n|$9$|^|^|\n|$10$|^|^|\n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/卢政荣 命题/卢政荣 验题/何昊天\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#1] Find Dad", "background": "", "description": "Xiao A has been looking for his own father recently. How? By DNA matching.\n\nXiao A has his own method for comparing DNA sequences. The goal is to maximize the similarity score between two DNA sequences. The steps are as follows:\n\n1. Given two DNA sequences, the first of length $n$ and the second of length $m$.\n2. Insert any number of gaps at any positions in the two sequences so that the two strings have the same length.\n3. Match position by position. If at a position neither character is a gap, let the first be $x$ and the second be $y$, then their similarity is defined as $d(x, y)$. For any maximal contiguous block of gaps of length $k$ in either sequence, we define its similarity as $g(k) = -A - B(k-1)$.\n\nThe final similarity score of the two sequences is the sum of all $d(x, y)$ values plus the similarity of all maximal gap blocks.\n\nNow Xiao A has, by some mysterious means, obtained a segment of Xiao B’s DNA sequence. He asks you to compute the maximum similarity score between Xiao A’s DNA sequence and Xiao B’s DNA sequence.", "inputFormat": "The first line contains a string representing Xiao A’s DNA sequence.\nThe second line contains a string representing Xiao B’s DNA sequence.\nThe next $4$ lines each contain $4$ integers separated by spaces, representing the $d$ array in the following order.\n\n```plain\nd(A,A) d(A,T) d(A,G) d(A,C)\nd(T,A) d(T,T) d(T,G) d(T,C)\nd(G,A) d(G,T) d(G,G) d(G,C)\nd(C,A) d(C,T) d(C,G) d(C,C)\n```\n\nThe last line contains two positive integers $A, B$ separated by spaces, as described above.", "outputFormat": "Output a single line: the maximum similarity score of the two sequences.", "hint": "Sample explanation.\n\nFirst, pad the sequences as follows (“-” denotes a gap):\n\n```cpp\nATGG--\nAT--CC\n```\n\nThen the sum of all $d(x, y)$ is $d(A, A) + d(T, T) = 10$.\nThe sum of the similarity of all maximal contiguous gap blocks is $g(2) + g(2) = -6$.\nThe total is $4$, which can be verified to be the maximum similarity.\n\nFor all test points, $0 < B < A \\le 1000$, $-1000 \\le d(x, y) \\le 1000$, $d(x, y) = d(y, x)$, and each sequence contains only the four characters $\\{A, T, G, C\\}$.\n\n| Test point ID | $n+m$ range     | Special notes                    |\n|:-:|:-:|:-:|\n| $1$  | $n = m = 1$       | No special requirements.          |\n| $2$  | $n+m \\le 15$      | ^                                 |\n| $3$  | $n+m \\le 300$     | ^                                 |\n| $4$  | ^                 | ^                                 |\n| $5$  | $n+m \\le 3000$    | Sequences contain only one type of character. |\n| $6$  | ^                 | No special requirements.          |\n| $7$  | ^                 | ^                                 |\n| $8$  | ^                 | ^                                 |\n| $9$  | ^                 | ^                                 |\n| $10$ | ^                 | ^                                 |\n\nFrom CodePlus 2017 November Contest, proudly presented by the Student Algorithm and Competition Association, Department of Computer Science and Technology, Tsinghua University.\n\nCredit: Idea/Lu Zhengrong; Problem setter/Lu Zhengrong; Tester/He Haotian.\n\nGit Repo: https://git.thusaac.org/publish/CodePlus201711\n\nThanks to Tencent for supporting this contest.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#1] 找爸爸", "background": null, "description": "小 A 最近一直在找自己的爸爸，用什么办法呢，就是 DNA 比对。\n\n小 A 有一套自己的 DNA 序列比较方法，其最终目标是最大化两个 DNA 序列的相似程度，具体步骤如下：\n\n\n1. 给出两个 DNA 序列，第一个长度为 $n$，第二个长度为 $m$。\n\n2. 在两个序列的任意位置插入任意多的空格，使得两个字符串长度相同\n\n3. 逐位进行匹配，**如果两个序列相同位置上的字符都不是空格**，假设第一个是 $x$，第二个是 $y$，那么他们的相似程度由 $d(x,y)$ 定义。对于两个序列中任意一段极长的长度为 $k$ 的连续空格，我们定义这段空格的相似程度为 $g(k)=-A-B(k-1)$。\n\n\n那么最终两个序列的相似程度就是所有的 $d(x,y)$ 加上所有的极长空格段的相似程度之和。\n\n现在小 A 通过某种奥妙重重的方式得到了小 B 的 DNA 序列中的一段，他想请你帮他算一下小 A 的 DNA 序列和小 B 的 DNA 序列的最大相似程度。", "inputFormat": "输入第 $1$ 行一个字符串，表示小 A 的 DNA 序列。\n\n输入第 $2$ 行一个字符串，表示小 B 的 DNA 序列。\n\n接下来 $4$ 行，每行 $4$ 个整数，用空格隔开，表示 $d$ 数组，具体顺序如下所示。\n\n```plain\nd(A,A) d(A,T) d(A,G) d(A,C)\nd(T,A) d(T,T) d(T,G) d(T,C)\nd(G,A) d(G,T) d(G,G) d(G,C)\nd(C,A) d(C,T) d(C,G) d(C,C)\n```\n最后一行两个用空格隔开的正整数 $A,B$，意义如题中所述。", "outputFormat": "输出共一行，表示两个序列的最大相似程度。", "hint": "### 样例解释\n\n首先，将序列补成如下形式（\"-\"代表空格）\n\n```cpp\nATGG--\nAT--CC\n```\n然后所有 $d(x,y)$ 的和为 $d(A,A)+d(T,T)=10$\n\n所有极长连续空格段的相似程度之和为 $g(2)+g(2)=-6$\n\n总和为 $4$，可以验证，这是相似程度最大的情况。\n\n对于所有测试点，有 $0< B<A \\le 1000, -1000\\le d(x,y)\\le 1000,d(x,y)=d(y,x)$，序列只包含${A,T,G,C}$四种字符。\n\n::cute-table{tuack}\n\n|测试点编号|$n+m$ 的范围|特殊约定|\n|:-:|:-:|:-:|\n|$1$|$n=m=1$|无特殊要求|\n|$2$|$n+m\\le15$|^|\n|$3$|$n+m\\le300$|^|\n|$4$|^|^|\n|$5$|$n+m\\le3000$|序列中只包含一个字符|\n|$6$|^|无特殊要求|\n|$7$|^|^|\n|$8$|^|^|\n|$9$|^|^|\n|$10$|^|^|\n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/卢政荣 命题/卢政荣 验题/何昊天\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN"}}}
{"pid": "P4060", "type": "P", "difficulty": 5, "samples": [["5 3\n4 0\n3 7\n5 0", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "递推", "O2优化", "枚举", "前缀和", "位运算", "Code+"], "title": "[Code+#1] 可做题", "background": "", "description": "qmqmqm 希望给 sublinekelzrip 出一道可做题。于是他想到了这么一道题目：给一个长度为 $n$ 的非负整数序列 $a_i$，你需要计算其异或前缀和 $b_i$，满足条件 $b_1=a_1,b_i=b_{i-1}\\operatorname{xor}a_i(i \\geq 2)$。\n\n但是由于数据生成器出现了问题，他生成的序列 $a$ 的长度特别长，并且由于内存空间不足，一部分 $a_i$ 已经丢失了，只剩余 $m$ 个位置的元素已知。现在 qmqmqm 找到你，希望你根据剩余的 $a_i$，计算出所有可能的 $a$ 序列对应的 $b$ 序列中 $\\sum_{i=1}^n b_i$ 的最小值。", "inputFormat": "输入第一行两个非负整数 $n,m$，分别表示原始序列 $a$ 的长度及剩余元素的个数。\n\n之后 $m$ 行，每行 $2$ 个数 $i,a_i$，表示一个剩余元素的位置和数值。", "outputFormat": "输出一个整数表示可能的最小值。", "hint": "### 样例解释\n\n已知的 $a$ 序列为：$X,X,7,0,0$，其中 $X$ 表示这个位置丢失了。一种可能的 $a$ 序列为 $0,7,7,0,0$，对应的 $b$ 序列为 $0,7,0,0,0$，和最小为 $7$。可以证明不存在和更小的情况。\n\n::cute-table{tuack}\n\n|测试点编号|$n$|$m$|已知的 $a_i$|\n|:-:|:-:|:-:|:-:|\n|$1$|$n=2$|$m=1$|$0\\le a_i\\le 10^9$|\n|$2$|$1\\le n\\le10^9$|$m=0$|^|\n|$3$|$1\\le n\\le10^5$|$m=n$|^|\n|$4$|$1\\le n\\le5$|$0\\le m\\le n$|$0\\le a_i\\le 5$|\n|$5$|^|^|^|\n|$6$|$1\\le n\\le10^5$|^|$0\\le a_i\\le1$|\n|$7$|^|^|^|\n|$8$|^|^|$0\\le a_i\\le10$|\n|$9$|^|^|^|\n|$10$|^|^|^|\n|$11$|$1\\le n\\le10^9$|$0\\le m\\le\\min\\{n,10^5\\}$|$0\\le a_i\\le1$|\n|$12$|^|^|^|\n|$13$|^|^|$0\\le a_i\\le10$|\n|$14$|^|^|^|\n|$16$|$1\\le n\\le10^6$|^|$0\\le a_i\\le10^9$|\n|$17$|^|^|^|\n|$18$|$1\\le n\\le10^9$|^|^|\n|$19$|^|^|^|\n|$20$|^|^|^|\n\n\n\n注意未知的 $a_i$ 可以超过已知 $a_i$ 的范围。\n\n保证输入中所有的 $i$ 不同，且满足 $1 \\leq i \\leq n$。\n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/卢政荣 命题/卢政荣 验题/何昊天\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#1] Doable Problem", "background": "", "description": "qmqmqm wants to give sublinekelzrip a doable problem. So he came up with this: given a non-negative integer sequence $a_i$ of length $n$, you need to compute its prefix XOR $b_i$, defined by $b_1=a_1,b_i=b_{i-1}\\operatorname{xor}a_i(i \\geq 2)$.\n\nHowever, due to a bug in the data generator, the sequence $a$ is very long, and because of insufficient memory, some $a_i$ were lost; only the elements at $m$ positions are known. Now qmqmqm asks you to, based on the remaining $a_i$, compute the minimum possible value of $\\sum_{i=1}^n b_i$ among the $b$ sequences corresponding to all possible sequences $a$ consistent with the known entries.", "inputFormat": "The first line contains two non-negative integers $n, m$, denoting the length of the original sequence $a$ and the number of remaining known elements.\n\nThen follow $m$ lines. Each line contains two numbers $i, a_i$, indicating the position and value of a known element.", "outputFormat": "Output a single integer denoting the minimum possible value.", "hint": "### Sample Explanation\n\nThe known $a$ sequence is $X,X,7,0,0$, where $X$ means the entry is missing. One possible $a$ is $0,7,7,0,0$, whose corresponding $b$ is $0,7,0,0,0$, and the minimum sum is $7$. It can be proven that there is no smaller case.\n\n| Test point ID | $n$ | $m$ | Known $a_i$ |\n|:-:|:-:|:-:|:-:|\n| $1$ | $n=2$ | $m=1$ | $0\\le a_i\\le 10^9$ |\n| $2$ | $1\\le n\\le10^9$ | $m=0$ | ^ |\n| $3$ | $1\\le n\\le10^5$ | $m=n$ | ^ |\n| $4$ | $1\\le n\\le5$ | $0\\le m\\le n$ | $0\\le a_i\\le 5$ |\n| $5$ | ^ | ^ | ^ |\n| $6$ | $1\\le n\\le10^5$ | ^ | $0\\le a_i\\le1$ |\n| $7$ | ^ | ^ | ^ |\n| $8$ | ^ | ^ | $0\\le a_i\\le10$ |\n| $9$ | ^ | ^ | ^ |\n| $10$ | ^ | ^ | ^ |\n| $11$ | $1\\le n\\le10^9$ | $0\\le m\\le\\min\\{n,10^5\\}$ | $0\\le a_i\\le1$ |\n| $12$ | ^ | ^ | ^ |\n| $13$ | ^ | ^ | $0\\le a_i\\le10$ |\n| $14$ | ^ | ^ | ^ |\n| $16$ | $1\\le n\\le10^6$ | ^ | $0\\le a_i\\le10^9$ |\n| $17$ | ^ | ^ | ^ |\n| $18$ | $1\\le n\\le10^9$ | ^ | ^ |\n| $19$ | ^ | ^ | ^ |\n| $20$ | ^ | ^ | ^ |\n\nNote that unknown $a_i$ can exceed the range of the known $a_i$.\n\nIt is guaranteed that all $i$ in the input are distinct and satisfy $1 \\le i \\le n$.\n\nFrom CodePlus 2017 November Contest, produced with honor by the Tsinghua University Department of Computer Science and Technology Student Algorithm and Competition Association.\n\nCredit: idea/Lu Zhengrong, problem setter/Lu Zhengrong, tester/He Haotian.\n\nGit Repo: https://git.thusaac.org/publish/CodePlus201711.\n\nThanks to Tencent for supporting this contest.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#1] 可做题", "background": "", "description": "qmqmqm 希望给 sublinekelzrip 出一道可做题。于是他想到了这么一道题目：给一个长度为 $n$ 的非负整数序列 $a_i$，你需要计算其异或前缀和 $b_i$，满足条件 $b_1=a_1,b_i=b_{i-1}\\operatorname{xor}a_i(i \\geq 2)$。\n\n但是由于数据生成器出现了问题，他生成的序列 $a$ 的长度特别长，并且由于内存空间不足，一部分 $a_i$ 已经丢失了，只剩余 $m$ 个位置的元素已知。现在 qmqmqm 找到你，希望你根据剩余的 $a_i$，计算出所有可能的 $a$ 序列对应的 $b$ 序列中 $\\sum_{i=1}^n b_i$ 的最小值。", "inputFormat": "输入第一行两个非负整数 $n,m$，分别表示原始序列 $a$ 的长度及剩余元素的个数。\n\n之后 $m$ 行，每行 $2$ 个数 $i,a_i$，表示一个剩余元素的位置和数值。", "outputFormat": "输出一个整数表示可能的最小值。", "hint": "### 样例解释\n\n已知的 $a$ 序列为：$X,X,7,0,0$，其中 $X$ 表示这个位置丢失了。一种可能的 $a$ 序列为 $0,7,7,0,0$，对应的 $b$ 序列为 $0,7,0,0,0$，和最小为 $7$。可以证明不存在和更小的情况。\n\n::cute-table{tuack}\n\n|测试点编号|$n$|$m$|已知的 $a_i$|\n|:-:|:-:|:-:|:-:|\n|$1$|$n=2$|$m=1$|$0\\le a_i\\le 10^9$|\n|$2$|$1\\le n\\le10^9$|$m=0$|^|\n|$3$|$1\\le n\\le10^5$|$m=n$|^|\n|$4$|$1\\le n\\le5$|$0\\le m\\le n$|$0\\le a_i\\le 5$|\n|$5$|^|^|^|\n|$6$|$1\\le n\\le10^5$|^|$0\\le a_i\\le1$|\n|$7$|^|^|^|\n|$8$|^|^|$0\\le a_i\\le10$|\n|$9$|^|^|^|\n|$10$|^|^|^|\n|$11$|$1\\le n\\le10^9$|$0\\le m\\le\\min\\{n,10^5\\}$|$0\\le a_i\\le1$|\n|$12$|^|^|^|\n|$13$|^|^|$0\\le a_i\\le10$|\n|$14$|^|^|^|\n|$16$|$1\\le n\\le10^6$|^|$0\\le a_i\\le10^9$|\n|$17$|^|^|^|\n|$18$|$1\\le n\\le10^9$|^|^|\n|$19$|^|^|^|\n|$20$|^|^|^|\n\n\n\n注意未知的 $a_i$ 可以超过已知 $a_i$ 的范围。\n\n保证输入中所有的 $i$ 不同，且满足 $1 \\leq i \\leq n$。\n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/卢政荣 命题/卢政荣 验题/何昊天\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN"}}}
{"pid": "P4061", "type": "P", "difficulty": 6, "samples": [["7 7 1 7\n1 2 2\n2 4 2\n4 6 2\n6 7 2\n1 3 2\n3 5 4\n5 7 2", "6"], ["5 5 1 4\n1 2 1\n1 3 1\n2 4 1\n3 4 1\n4 5 1", "3"], ["6 7 1 4\n1 2 1\n1 3 1\n2 4 1\n3 4 1\n4 5 1\n1 6 2\n6 4 2", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["动态规划 DP", "图论", "O2优化", "枚举", "最短路", "Code+"], "title": "[Code+#1] 大吉大利，晚上吃鸡！", "background": "最近《绝地求生：大逃杀》风靡全球，皮皮和毛毛也迷上了这款游戏，他们经常组队玩这款游戏。\n\n在游戏中，皮皮和毛毛最喜欢做的事情就是堵桥，每每有一个好时机都能收到不少的快递。\n\n当然，有些时候并不能堵桥，皮皮和毛毛会选择在其他的必经之路上蹲点。\n\nK博士作为一个老年人，外加有心脏病，自然是不能玩这款游戏的，但是这并不能妨碍他对这款游戏进行一些理论分析，比如最近他就对皮皮和毛毛的战术很感兴趣。", "description": "游戏的地图可以抽象为一张 $n$ 个点 $m$ 条无向边的图，节点编号为 $1$ 到 $n$ ，每条边具有一个正整数的长度。\n\n\n\n**假定大魔王都会从** $S$ **点出发到达** $T$ **点（** $S$ **和** $T$ **已知），并且只会走最短路** ，皮皮和毛毛会在 $A$ 点和 $B$ 点埋伏大魔王。\n\n为了保证一定能埋伏到大魔王，同时又想留大魔王一条生路，皮皮和毛毛约定 $A$ 点和 $B$ 点必须满足：\n\n- 大魔王所有可能路径中，必定会经过 $A$ 点和 $B$ 点中的任意一点\n\n- 大魔王所有可能路径中，不存在一条路径同时经过 $A$ 点和 $B$ 点\n\nK博士想知道，满足上面两个条件的 $A,B$ 点对有多少个，交换 $A,B$ 的顺序算相同的方案。", "inputFormat": "第一行输入四个整数 $n,m,S,T(1 \\le n \\le 5 \\times 10^{4}, 1 \\le m \\le 5 \\times 10^{4}, 1 \\le S,T \\le n)$ ，含义见题目描述。\n\n接下来输入 $m$ 行，每行输入三个整数 $u,v,w(1 \\le u,v \\le n, 1 \\le w \\le 10^{9})$ 表示存在一条长度为 $w$ 的边链接 $u$ 和 $v$ 。", "outputFormat": "输出一行表示答案。", "hint": "### 样例1解释\n\n合法的方案为$<2,3>,<2,4>,<4,3>,<4,5>,<6,3>,<6,5>$ 。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12824.png) \n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/陈宇 命题/陈宇 验题/邢健开\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#1] Winner Winner, Chicken Dinner Tonight!", "background": "Recently, PlayerUnknown’s Battlegrounds (PUBG) has taken the world by storm. Pipi and Maomao have become obsessed with the game and often team up to play.\n\nIn the game, their favorite tactic is camping at bridges, where they can often secure lots of loot when the timing is right.\n\nOf course, sometimes camping a bridge isn’t possible, so Pipi and Maomao will instead camp on other chokepoints.\n\nDr. K, being older and having a heart condition, naturally can’t play this game, but that doesn’t stop him from doing some theoretical analysis. Lately, he has been very interested in Pipi and Maomao’s tactics.", "description": "The game map can be abstracted as an undirected graph with $n$ nodes and $m$ edges, numbered from $1$ to $n$. Each edge has a positive integer length.\n\nAssume the “Da Mowang” will start from $S$ and reach $T$ (both $S$ and $T$ are known), and will only take shortest paths. Pipi and Maomao will ambush at points $A$ and $B$.\n\nTo ensure they can always ambush the Da Mowang while still leaving him a way out, $A$ and $B$ must satisfy:\n\n- Among all possible shortest paths, the Da Mowang must pass through at least one of $A$ or $B$.\n- Among all possible shortest paths, there does not exist a path that passes through both $A$ and $B$.\n\nDr. K wants to know how many pairs $(A, B)$ satisfy the two conditions above. Swapping $A$ and $B$ counts as the same plan.", "inputFormat": "The first line contains four integers $n, m, S, T$ $(1 \\le n \\le 5 \\times 10^{4}, 1 \\le m \\le 5 \\times 10^{4}, 1 \\le S, T \\le n)$, as described above.\n\nThe next $m$ lines each contain three integers $u, v, w$ $(1 \\le u, v \\le n, 1 \\le w \\le 10^{9})$, indicating there is an edge of length $w$ connecting $u$ and $v$.", "outputFormat": "Output a single line containing the answer.", "hint": "Explanation for Sample 1:\n\nThe valid pairs are $<2,3>,<2,4>,<4,3>,<4,5>,<6,3>,<6,5>$.\n\n![](https://cdn.luogu.com.cn/upload/pic/12824.png)\n\nFrom CodePlus November 2017, proudly presented by the Tsinghua University Student Association of Computer Science and Technology Algorithms and Programming Contest.\n\nCredit: idea/Chen Yu, problem setting/Chen Yu, verification/Xing Jiankai.\n\nGit Repo: https://git.thusaac.org/publish/CodePlus201711\n\nThanks to Tencent for supporting this contest.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#1] 大吉大利，晚上吃鸡！", "background": "最近《绝地求生：大逃杀》风靡全球，皮皮和毛毛也迷上了这款游戏，他们经常组队玩这款游戏。\n\n在游戏中，皮皮和毛毛最喜欢做的事情就是堵桥，每每有一个好时机都能收到不少的快递。\n\n当然，有些时候并不能堵桥，皮皮和毛毛会选择在其他的必经之路上蹲点。\n\nK博士作为一个老年人，外加有心脏病，自然是不能玩这款游戏的，但是这并不能妨碍他对这款游戏进行一些理论分析，比如最近他就对皮皮和毛毛的战术很感兴趣。", "description": "游戏的地图可以抽象为一张 $n$ 个点 $m$ 条无向边的图，节点编号为 $1$ 到 $n$ ，每条边具有一个正整数的长度。\n\n\n\n**假定大魔王都会从** $S$ **点出发到达** $T$ **点（** $S$ **和** $T$ **已知），并且只会走最短路** ，皮皮和毛毛会在 $A$ 点和 $B$ 点埋伏大魔王。\n\n为了保证一定能埋伏到大魔王，同时又想留大魔王一条生路，皮皮和毛毛约定 $A$ 点和 $B$ 点必须满足：\n\n- 大魔王所有可能路径中，必定会经过 $A$ 点和 $B$ 点中的任意一点\n\n- 大魔王所有可能路径中，不存在一条路径同时经过 $A$ 点和 $B$ 点\n\nK博士想知道，满足上面两个条件的 $A,B$ 点对有多少个，交换 $A,B$ 的顺序算相同的方案。", "inputFormat": "第一行输入四个整数 $n,m,S,T(1 \\le n \\le 5 \\times 10^{4}, 1 \\le m \\le 5 \\times 10^{4}, 1 \\le S,T \\le n)$ ，含义见题目描述。\n\n接下来输入 $m$ 行，每行输入三个整数 $u,v,w(1 \\le u,v \\le n, 1 \\le w \\le 10^{9})$ 表示存在一条长度为 $w$ 的边链接 $u$ 和 $v$ 。", "outputFormat": "输出一行表示答案。", "hint": "### 样例1解释\n\n合法的方案为$<2,3>,<2,4>,<4,3>,<4,5>,<6,3>,<6,5>$ 。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12824.png) \n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/陈宇 命题/陈宇 验题/邢健开\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN"}}}
{"pid": "P4062", "type": "P", "difficulty": 6, "samples": [["5 0\n1 1 2 2 3", "10"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["线段树", "递归", "O2优化", "前缀和", "根号分治", "Code+"], "title": "[Code+#1] Yazid 的新生舞会", "background": "这道题是没有舞伴的 Yazid 用新生舞会的时间出的。\n", "description": "Yazid 有一个长度为 $n$ 的序列 $A$，下标从 $1$ 至 $n$。显然地，这个序列共有 $\\frac{n\\left( n+1\\right)}{2}$ 个子区间。\n\n对于任意一个子区间 $[l,r]$，如果该子区间内的众数在该子区间的出现次数严格大于 $\\frac{r-l+1}{2}$（即该子区间长度的一半），那么 Yazid 就说这个子区间是“新生舞会的”。\n\n所谓众数，即为该子区间内出现次数最多的数。特别地，如果出现次数最多的数有多个，我们规定值最小的数为众数。\n\n现在，Yazid 想知道，共有多少个子区间是“新生舞会的”。\n", "inputFormat": "第一行两个用空格隔开的非负整数 $n, type$，表示序列的长度和**数据类型**。数据类型的作用将在「子任务」中说明。\n\n第二行 $n$ 个用空格隔开的非负整数，依次为 $A_1,A_2,...,A_n$，描述这个序列。\n", "outputFormat": "输出一行一个整数，表示答案。\n", "hint": "**【样例解释 #1】**\n\n“新生舞会的”子区间有 $[1,1],[1,2],[1,3],[2,2],[2,4],[3,3],[3,4],[3,5],[4,4],[5,5]$ 共 $10$ 个。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12825.png) \n\n对于所有数据，保证 $0\\leq A_i\\leq n-1$。\n\n对于 $type=0$ 的数据，没有任何特殊约定。\n\n对于 $type=1$ 的数据，保证 $A_i\\in \\{ 0, 1 \\}$。\n\n对于 $type=2$ 的数据，保证序列 $A$ 的众数在整个序列中的出现次数不超过 $15$。\n\n对于 $type=3$ 的数据，保证 $A_i\\leq 7$。\n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/郑林楷 命题/王聿中 验题/郑林楷\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#1] Yazid's Freshman Ball", "background": "This problem was created by Yazid during the time of the freshman ball, when he had no dance partner.", "description": "Yazid has a sequence $A$ of length $n$, indexed from $1$ to $n$. Obviously, this sequence has $\\frac{n\\left( n+1\\right)}{2}$ subarrays.\n\nFor any subarray $[l,r]$, if the mode in this subarray has a frequency strictly greater than $\\frac{r-l+1}{2}$ (that is, more than half of the subarray's length), then Yazid calls this subarray \"Freshman Ball\".\n\nThe mode is the value that appears most frequently in the subarray. In particular, if multiple values tie for the highest frequency, we define the smallest value as the mode.\n\nNow Yazid wants to know how many subarrays are \"Freshman Ball\".", "inputFormat": "The first line contains two space-separated nonnegative integers $n, type$, representing the length of the sequence and the data type. The role of the data type will be explained in the Hint.\n\nThe second line contains $n$ space-separated nonnegative integers, namely $A_1, A_2, ..., A_n$, describing the sequence.", "outputFormat": "Output a single integer on one line, representing the answer.", "hint": "【Sample Explanation #1】\n\nThe \"Freshman Ball\" subarrays are $[1,1],[1,2],[1,3],[2,2],[2,4],[3,3],[3,4],[3,5],[4,4],[5,5]$, for a total of $10$.\n\n ![](https://cdn.luogu.com.cn/upload/pic/12825.png) \n\nConstraints:\n\nFor all testdata, it is guaranteed that $0\\leq A_i\\leq n-1$.\n\nFor $type=0$ testdata, there is no special stipulation.\n\nFor $type=1$ testdata, it is guaranteed that $A_i\\in \\{ 0, 1 \\}$.\n\nFor $type=2$ testdata, it is guaranteed that the mode of sequence $A$ appears at most $15$ times in the entire sequence.\n\nFor $type=3$ testdata, it is guaranteed that $A_i\\leq 7$.\n\nFrom CodePlus 2017 November Contest, produced by the Student Algorithms and Competitions Association, Department of Computer Science and Technology, Tsinghua University.\n\nCredit: idea/Zheng Linkai, problem setting/Wang Yuzhong, problem checking/Zheng Linkai.\n\nGit Repo: https://git.thusaac.org/publish/CodePlus201711\n\nThanks to Tencent for supporting this contest.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#1] Yazid 的新生舞会", "background": "这道题是没有舞伴的 Yazid 用新生舞会的时间出的。\n", "description": "Yazid 有一个长度为 $n$ 的序列 $A$，下标从 $1$ 至 $n$。显然地，这个序列共有 $\\frac{n\\left( n+1\\right)}{2}$ 个子区间。\n\n对于任意一个子区间 $[l,r]$，如果该子区间内的众数在该子区间的出现次数严格大于 $\\frac{r-l+1}{2}$（即该子区间长度的一半），那么 Yazid 就说这个子区间是“新生舞会的”。\n\n所谓众数，即为该子区间内出现次数最多的数。特别地，如果出现次数最多的数有多个，我们规定值最小的数为众数。\n\n现在，Yazid 想知道，共有多少个子区间是“新生舞会的”。\n", "inputFormat": "第一行两个用空格隔开的非负整数 $n, type$，表示序列的长度和**数据类型**。数据类型的作用将在「子任务」中说明。\n\n第二行 $n$ 个用空格隔开的非负整数，依次为 $A_1,A_2,...,A_n$，描述这个序列。\n", "outputFormat": "输出一行一个整数，表示答案。\n", "hint": "**【样例解释 #1】**\n\n“新生舞会的”子区间有 $[1,1],[1,2],[1,3],[2,2],[2,4],[3,3],[3,4],[3,5],[4,4],[5,5]$ 共 $10$ 个。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12825.png) \n\n对于所有数据，保证 $0\\leq A_i\\leq n-1$。\n\n对于 $type=0$ 的数据，没有任何特殊约定。\n\n对于 $type=1$ 的数据，保证 $A_i\\in \\{ 0, 1 \\}$。\n\n对于 $type=2$ 的数据，保证序列 $A$ 的众数在整个序列中的出现次数不超过 $15$。\n\n对于 $type=3$ 的数据，保证 $A_i\\leq 7$。\n\n来自 CodePlus 2017 11 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/郑林楷 命题/王聿中 验题/郑林楷\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201711\n\n感谢腾讯公司对此次比赛的支持。\n", "locale": "zh-CN"}}}
{"pid": "P4063", "type": "P", "difficulty": 6, "samples": [["3\n2 2 2", "6"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "各省省选", "江西"], "title": "[JXOI2017] 数列", "background": null, "description": "九条可怜手上有一个长度为 $n$ 的整数数列 $r_i$，她现在想要构造一个长度为 $n$ 的，满足如下条件的整数数列 $A$ ：\n\n- $1 \\le A_i \\le r_i$\n\n- 对于任意 $3 \\le i \\le n$ ，令 $R$ 为 $A_1$ 至 $A_{i-2}$ 中大于等于 $A_{i-1}$ 的最小值，$L$ 为 $A_1$ 至 $A_{i-2}$ 中小于等于 $A_{i-1}$ 的最大值。$A_i$ 必须满足 $L \\le A_i \\le R$ 。如果不存在大于等于 $A_{i-1}$ 的，那么 $R=+\\infty$ ；如果不存在小于等于 $A_{i-1} $ 的，那么 $L = -\\infty$ 。\n\n现在可怜想要知道共有多少不同的数列满足这个条件。两个数列 $A$ 和 $B$ 是不同的当且仅当至少存在一个位置 $i$ 满足 $A_i \\neq B_i$ 。", "inputFormat": "第一行输入一个整数 $n$ ，第二行输入 $n$ 个整数 $r_i$。", "outputFormat": "输出一个整数表示方案数，答案可能很大，对 $998244353$ 取模后输出。\n## 说明\n满足条件的序列有 $[1, 1, 1], [1, 2, 1], [1, 2, 2], [2, 1, 1], [2, 1, 2], [2, 2, 2]$", "hint": "| 测试点编号 | $n$ | $r_i$ |\n| :----------: | :----------: | :----------: |\n| $1,2$ | $n\\le7$ | $r_i\\le7$ |\n| $3,4$ | $n\\le50$ | $r_i\\le10$ |\n| $5,6$ | $n\\le50$ | $r_i\\le16$ |\n| $7,8$ | $n\\le50$ | $r_i\\le50$ |\n| $9,10$ | $n\\le50$ | $r_i\\le150$ |", "locale": "zh-CN", "translations": {"en": {"title": "[JXOI2017] Sequence", "background": "", "description": "Jiutiao Kelian (pinyin) has an integer sequence $r_i$ of length $n$. She now wants to construct an integer sequence $A$ of length $n$ that satisfies the following:\n\n- $1 \\le A_i \\le r_i$.\n\n- For any $3 \\le i \\le n$, let $R$ be the minimum among $A_1$ through $A_{i-2}$ that are greater than or equal to $A_{i-1}$, and let $L$ be the maximum among $A_1$ through $A_{i-2}$ that are less than or equal to $A_{i-1}$. Then $A_i$ must satisfy $L \\le A_i \\le R$. If there is no number greater than or equal to $A_{i-1}$, then $R = +\\infty$; if there is no number less than or equal to $A_{i-1}$, then $L = -\\infty$.\n\nNow she wants to know how many different sequences satisfy these conditions. Two sequences $A$ and $B$ are different if and only if there exists at least one position $i$ such that $A_i \\ne B_i$.", "inputFormat": "The first line contains an integer $n$, and the second line contains $n$ integers $r_i$.", "outputFormat": "Output a single integer denoting the number of valid sequences. The answer can be large; output it modulo $998244353$.", "hint": "For example, when $n = 3$ and $r_i = 2$ for all $i$, the valid sequences are $[1, 1, 1], [1, 2, 1], [1, 2, 2], [2, 1, 1], [2, 1, 2], [2, 2, 2]$.\n\nConstraints:\n\n| Test point ID | $n$ | $r_i$ |\n| :----------: | :----------: | :----------: |\n| $1, 2$ | $n \\le 7$ | $r_i \\le 7$ |\n| $3, 4$ | $n \\le 50$ | $r_i \\le 10$ |\n| $5, 6$ | $n \\le 50$ | $r_i \\le 16$ |\n| $7, 8$ | $n \\le 50$ | $r_i \\le 50$ |\n| $9, 10$ | $n \\le 50$ | $r_i \\le 150$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JXOI2017] 数列", "background": null, "description": "九条可怜手上有一个长度为 $n$ 的整数数列 $r_i$，她现在想要构造一个长度为 $n$ 的，满足如下条件的整数数列 $A$ ：\n\n- $1 \\le A_i \\le r_i$\n\n- 对于任意 $3 \\le i \\le n$ ，令 $R$ 为 $A_1$ 至 $A_{i-2}$ 中大于等于 $A_{i-1}$ 的最小值，$L$ 为 $A_1$ 至 $A_{i-2}$ 中小于等于 $A_{i-1}$ 的最大值。$A_i$ 必须满足 $L \\le A_i \\le R$ 。如果不存在大于等于 $A_{i-1}$ 的，那么 $R=+\\infty$ ；如果不存在小于等于 $A_{i-1} $ 的，那么 $L = -\\infty$ 。\n\n现在可怜想要知道共有多少不同的数列满足这个条件。两个数列 $A$ 和 $B$ 是不同的当且仅当至少存在一个位置 $i$ 满足 $A_i \\neq B_i$ 。", "inputFormat": "第一行输入一个整数 $n$ ，第二行输入 $n$ 个整数 $r_i$。", "outputFormat": "输出一个整数表示方案数，答案可能很大，对 $998244353$ 取模后输出。\n## 说明\n满足条件的序列有 $[1, 1, 1], [1, 2, 1], [1, 2, 2], [2, 1, 1], [2, 1, 2], [2, 2, 2]$", "hint": "| 测试点编号 | $n$ | $r_i$ |\n| :----------: | :----------: | :----------: |\n| $1,2$ | $n\\le7$ | $r_i\\le7$ |\n| $3,4$ | $n\\le50$ | $r_i\\le10$ |\n| $5,6$ | $n\\le50$ | $r_i\\le16$ |\n| $7,8$ | $n\\le50$ | $r_i\\le50$ |\n| $9,10$ | $n\\le50$ | $r_i\\le150$ |", "locale": "zh-CN"}}}
{"pid": "P4064", "type": "P", "difficulty": 5, "samples": [["1 \n3 3 2 1\n1 3 2\n1 1\n1 3\n3 3", "3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["贪心", "2017", "二分", "各省省选", "树状数组", "优先队列", "江西"], "title": "[JXOI2017] 加法", "background": "", "description": "可怜有一个长度为 $n$ 的正整数序列 $A$，但是她觉得 $A$ 中的数字太小了，这让她很不开心。\n\n于是她选择了 $m$ 个区间 $[l_i,r_i]$ 和两个正整数 $a,k$。她打算从这 $m$ 个区间里选出恰好 $k$ 个区间，并对每个区间执行一次区间加 $a$ 的操作。（每个区间最多只能选择一次）。\n\n对区间 $[l,r]$ 进行一次加 $a$ 操作可以定义为对于所有 $i$ ∈ $[l,r]$，将 $A_i$ 变成 $A_i+a$。现在可怜想要知道怎么选择区间才能让操作后的序列的最小值尽可能的大，即最大化 $\\min\\{A_i\\}$。", "inputFormat": "第一行输入一个整数表示数据组数。\n\n对于每组数据第一行输入四个整数 $n,m,k,a$。\n\n第二行输入 $n$ 个整数描述序列 $A$。\n\n接下来 $m$ 行每行两个整数 $l_i,r_i$ 描述每一个区间。数据保证所有区间两两不同。", "outputFormat": "对于每组数据输出一个整数表示操作后序列最小值的最大值。\n", "hint": "选择给区间 $[1,1]$ 和 $[1,3]$ 加 $1$。\n\n对于 $100\\%$ 的数据，保证 $1\\leq\\sum n,\\sum m\\leq 2\\times 10^5$，$1\\leq T\\leq 2\\times 10^5$，$1\\le k\\le m$，$1\\le a\\le 100$，$1\\le A_i\\le 10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "[JXOI2017] Addition", "background": "", "description": "Kelian has a positive integer sequence $A$ of length $n$, but she feels the numbers in $A$ are too small, which makes her unhappy.\n\nSo she chooses $m$ intervals $[l_i,r_i]$ and two positive integers $a,k$. She plans to select exactly $k$ intervals from these $m$ intervals, and perform one range add $a$ operation on each selected interval. (Each interval can be selected at most once).\n\nPerforming a +$a$ operation on a range $[l,r]$ is defined as: for all $i$ ∈ $[l,r]$, set $A_i$ to $A_i+a$. Now Kelian wants to know how to choose the intervals so that the minimum value of the sequence after the operations is as large as possible, i.e., maximize $\\min\\{A_i\\}$.", "inputFormat": "The first line contains an integer indicating the number of test cases.\n\nFor each test case, the first line contains four integers $n,m,k,a$.\n\nThe second line contains $n$ integers describing the sequence $A$.\n\nThe next $m$ lines each contain two integers $l_i,r_i$ describing each interval. It is guaranteed that all intervals are pairwise distinct.", "outputFormat": "For each test case, output one integer representing the maximum possible minimum value of the sequence after the operations.", "hint": "Choose to add $1$ to intervals $[1,1]$ and $[1,3]$.\n\nFor $100\\%$ of the testdata, it is guaranteed that $1\\leq\\sum n,\\sum m\\leq 2\\times 10^5$, $1\\leq T\\leq 2\\times 10^5$, $1\\le k\\le m$, $1\\le a\\le 100$, $1\\le A_i\\le 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JXOI2017] 加法", "background": "", "description": "可怜有一个长度为 $n$ 的正整数序列 $A$，但是她觉得 $A$ 中的数字太小了，这让她很不开心。\n\n于是她选择了 $m$ 个区间 $[l_i,r_i]$ 和两个正整数 $a,k$。她打算从这 $m$ 个区间里选出恰好 $k$ 个区间，并对每个区间执行一次区间加 $a$ 的操作。（每个区间最多只能选择一次）。\n\n对区间 $[l,r]$ 进行一次加 $a$ 操作可以定义为对于所有 $i$ ∈ $[l,r]$，将 $A_i$ 变成 $A_i+a$。现在可怜想要知道怎么选择区间才能让操作后的序列的最小值尽可能的大，即最大化 $\\min\\{A_i\\}$。", "inputFormat": "第一行输入一个整数表示数据组数。\n\n对于每组数据第一行输入四个整数 $n,m,k,a$。\n\n第二行输入 $n$ 个整数描述序列 $A$。\n\n接下来 $m$ 行每行两个整数 $l_i,r_i$ 描述每一个区间。数据保证所有区间两两不同。", "outputFormat": "对于每组数据输出一个整数表示操作后序列最小值的最大值。\n", "hint": "选择给区间 $[1,1]$ 和 $[1,3]$ 加 $1$。\n\n对于 $100\\%$ 的数据，保证 $1\\leq\\sum n,\\sum m\\leq 2\\times 10^5$，$1\\leq T\\leq 2\\times 10^5$，$1\\le k\\le m$，$1\\le a\\le 100$，$1\\le A_i\\le 10^8$。", "locale": "zh-CN"}}}
{"pid": "P4065", "type": "P", "difficulty": 6, "samples": [["1\n5\n1 3 2 4 3", "6"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "线段树", "各省省选", "枚举", "江西", "哈希 hashing", "随机化"], "title": "[JXOI2017] 颜色", "background": "", "description": "可怜有一个长度为 $n$ 的正整数序列 $A_i$，其中相同的正整数代表着相同的颜色。\n\n现在可怜觉得这个序列太长了，于是她决定选择一些颜色把这些颜色的所有位置都删去。\n\n删除颜色 $i$ 可以定义为把所有满足 $A_j = i$ 的位置 $j$ 都从序列中删去。\n\n然而有些时候删去之后，整个序列变成了好几段，可怜不喜欢这样，于是她想要知道有多少种删去颜色的方案使得最后剩下来的序列非空且连续。\n\n例如颜色序列 $\\{1, 2, 3, 4, 5\\}$，删除颜色 $3$ 后序列变成了 $\\{1, 2\\}$ 和 $\\{4, 5\\}$ 两段，不满足条件。而删除颜色 $1$ 后序列变成了 $\\{2, 3, 4, 5\\}$，满足条件。\n\n两个方案不同当且仅当至少存在一个颜色 $i$ 只在其中一个方案中被删去。\n", "inputFormat": "第一行输入一个整数 $T$ 表示数据组数。\n\n每组数据第一行，输入一个整数 $n$ 表示数列长度；第二行输入 $n$ 个整数描述颜色序列。\n", "outputFormat": "对于每组数据输出一个整数表示答案。", "hint": "满足条件的删颜色方案有 $\\{1\\}, \\{1, 3\\}, \\{1, 2, 3\\}, \\{1, 3, 4\\}, \\{2, 3, 4\\}, \\varnothing$。\n\n对于 $20\\%$ 的数据，保证 $1 \\le \\sum n \\le  20$。\n\n对于 $40\\%$ 的数据，保证 $1 \\le \\sum n \\le  500$。\n\n对于 $60\\%$ 的数据，保证 $1 \\le \\sum n \\le  10^4$。\n\n对于 $100\\%$ 的数据，保证 $1 \\le  T,\\sum n \\le  3 \\times 10^5, 1 \\le  A_i \\le  n$。\n\n$\\text{Statement fixed by @Starrykiller.}$", "locale": "zh-CN", "translations": {"en": {"title": "[JXOI2017] Colors", "background": "", "description": "Kelian has a sequence of positive integers of length $n$, denoted by $A_i$, where equal integers represent the same color.\n\nKelian thinks the sequence is too long, so she decides to choose some colors and delete all positions of those colors.\n\nDeleting color $i$ is defined as removing from the sequence all positions $j$ such that $A_j = i$.\n\nHowever, sometimes after deletions, the entire sequence breaks into several segments. Kelian does not like that, so she wants to know how many ways to delete colors will make the remaining sequence non-empty and contiguous.\n\nFor example, for the color sequence $\\{1, 2, 3, 4, 5\\}$, after deleting color $3$, the sequence becomes two segments $\\{1, 2\\}$ and $\\{4, 5\\}$, which does not satisfy the requirement. After deleting color $1$, the sequence becomes $\\{2, 3, 4, 5\\}$, which satisfies the requirement.\n\nTwo schemes are different if and only if there exists at least one color $i$ that is deleted in exactly one of them.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nFor each test case, the first line contains an integer $n$, the length of the sequence; the second line contains $n$ integers describing the color sequence.", "outputFormat": "For each test case, output a single integer denoting the answer.", "hint": "The valid deletion schemes are $\\{1\\}, \\{1, 3\\}, \\{1, 2, 3\\}, \\{1, 3, 4\\}, \\{2, 3, 4\\}, \\varnothing$.\n\nFor $20\\%$ of the testdata, it is guaranteed that $1 \\le \\sum n \\le 20$.\n\nFor $40\\%$ of the testdata, it is guaranteed that $1 \\le \\sum n \\le 500$.\n\nFor $60\\%$ of the testdata, it is guaranteed that $1 \\le \\sum n \\le 10^4$.\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\le T, \\sum n \\le 3 \\times 10^5, 1 \\le A_i \\le n$.\n\n$\\text{Statement fixed by @Starrykiller.}$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JXOI2017] 颜色", "background": "", "description": "可怜有一个长度为 $n$ 的正整数序列 $A_i$，其中相同的正整数代表着相同的颜色。\n\n现在可怜觉得这个序列太长了，于是她决定选择一些颜色把这些颜色的所有位置都删去。\n\n删除颜色 $i$ 可以定义为把所有满足 $A_j = i$ 的位置 $j$ 都从序列中删去。\n\n然而有些时候删去之后，整个序列变成了好几段，可怜不喜欢这样，于是她想要知道有多少种删去颜色的方案使得最后剩下来的序列非空且连续。\n\n例如颜色序列 $\\{1, 2, 3, 4, 5\\}$，删除颜色 $3$ 后序列变成了 $\\{1, 2\\}$ 和 $\\{4, 5\\}$ 两段，不满足条件。而删除颜色 $1$ 后序列变成了 $\\{2, 3, 4, 5\\}$，满足条件。\n\n两个方案不同当且仅当至少存在一个颜色 $i$ 只在其中一个方案中被删去。\n", "inputFormat": "第一行输入一个整数 $T$ 表示数据组数。\n\n每组数据第一行，输入一个整数 $n$ 表示数列长度；第二行输入 $n$ 个整数描述颜色序列。\n", "outputFormat": "对于每组数据输出一个整数表示答案。", "hint": "满足条件的删颜色方案有 $\\{1\\}, \\{1, 3\\}, \\{1, 2, 3\\}, \\{1, 3, 4\\}, \\{2, 3, 4\\}, \\varnothing$。\n\n对于 $20\\%$ 的数据，保证 $1 \\le \\sum n \\le  20$。\n\n对于 $40\\%$ 的数据，保证 $1 \\le \\sum n \\le  500$。\n\n对于 $60\\%$ 的数据，保证 $1 \\le \\sum n \\le  10^4$。\n\n对于 $100\\%$ 的数据，保证 $1 \\le  T,\\sum n \\le  3 \\times 10^5, 1 \\le  A_i \\le  n$。\n\n$\\text{Statement fixed by @Starrykiller.}$", "locale": "zh-CN"}}}
{"pid": "P4066", "type": "P", "difficulty": 6, "samples": [["8 \n8 1 \n1 5\n5 7 \n2 2 \n7 8 \n4 6 \n3 3 \n6 4", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2003", "各省省选", "上海", "剪枝"], "title": "[SHOI2003] 吃豆豆", "background": "", "description": "两个 PACMAN 吃豆豆。一开始的时候，PACMAN 都在坐标原点的左下方，豆豆都在右上方。PACMAN 走到豆豆处就会吃掉它。  \nPACMAN 行走的路线很奇怪，只能向右走或者向上走，他们行走的路线可以有交点但不能互相穿过。  \n请你帮这两个 PACMAN 计算一下，他们俩加起来最多能吃掉多少豆豆。\n", "inputFormat": "第一行为一个整数 $N$，表示豆豆的数目。 接下来 $N$ 行，每行一对正整数，表示第 $i$ 个豆豆的坐标。任意两个豆豆的坐标都不会重合。\n", "outputFormat": "仅有一行包含一个整数，即两个 PACMAN 加起来最多能吃掉的豆豆数量\n", "hint": "对于 $100\\%$ 的数据，$N \\leq 2000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2003] Eating Beans", "background": "", "description": "Two PACMAN eat beans. At the beginning, both PACMAN are to the lower-left of the origin, and all beans are to the upper-right. A PACMAN eats a bean when it reaches its location.\nThe PACMAN move in a strange way: they can only move right or up. Their paths may have intersection points but cannot cross each other.\nPlease help the two PACMAN compute the maximum total number of beans they can eat together.", "inputFormat": "The first line contains an integer $N$, denoting the number of beans. The next $N$ lines each contain a pair of positive integers, representing the coordinates of the $i$-th bean. The coordinates of any two beans are distinct.", "outputFormat": "Output a single line containing one integer: the maximum total number of beans the two PACMAN can eat.", "hint": "For 100% of the testdata, $N \\leq 2000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2003] 吃豆豆", "background": "", "description": "两个 PACMAN 吃豆豆。一开始的时候，PACMAN 都在坐标原点的左下方，豆豆都在右上方。PACMAN 走到豆豆处就会吃掉它。  \nPACMAN 行走的路线很奇怪，只能向右走或者向上走，他们行走的路线可以有交点但不能互相穿过。  \n请你帮这两个 PACMAN 计算一下，他们俩加起来最多能吃掉多少豆豆。\n", "inputFormat": "第一行为一个整数 $N$，表示豆豆的数目。 接下来 $N$ 行，每行一对正整数，表示第 $i$ 个豆豆的坐标。任意两个豆豆的坐标都不会重合。\n", "outputFormat": "仅有一行包含一个整数，即两个 PACMAN 加起来最多能吃掉的豆豆数量\n", "hint": "对于 $100\\%$ 的数据，$N \\leq 2000$。", "locale": "zh-CN"}}}
{"pid": "P4067", "type": "P", "difficulty": 6, "samples": [["3\n2 2 0 100\n3 3 0 100\n3 3 1 100", "2\n12\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "各省省选", "山东", "数位 DP"], "title": "[SDOI2016] 储能表", "background": "", "description": "有一个 $n$ 行 $m$ 列的表格，**行从 $0$ 到 $n-1$ 编号，列从 $0$ 到 $m-1$ 编号**。每个格子都储存着能量。最初，第 $i$ 行第 $j$ 列的格子储存着 $(i \\oplus j)$ 点能量（$\\oplus$ 表示**按位异或**）。所以，整个表格储存的总能量是\n\n$$\\sum_{i=0}^{n-1} \\sum_{j=0}^{m-1} i \\oplus j$$\n\n随着时间的推移，格子中的能量会渐渐减少。每经过一个时间单位，每个格子中的能量都会减少 $1$。显然，**一个格子的能量减少到 $0$ 之后就不会再减少了。**\n\n也就是说，$k$ 个时间单位后，整个表格储存的总能量是\n\n$$\\sum_{i=0}^{n-1} \\sum_{j=0}^{m-1} \\max((i \\oplus j)-k,0)$$\n\n给出一个表格，求 $k$ 个时间单位后它储存的总能量。\n\n由于总能量可能较大，输出时对 $p$ 取模。", "inputFormat": "第一行一个整数 $T$，表示数据组数。接下来 $T$ 行，每行四个整数 $n,m,k,p$。\n", "outputFormat": "共 $T$ 行，每行一个数，表示总能量对 $p$ 取模后的结果。\n", "hint": "对于 $100\\%$ 的数据，保证 $1\\le T\\le 5000$，$1\\le p\\le 10^9$，$1\\le n,m\\le 10^{18}，0\\le k\\le 10^{18}$。\n\n| 测试点编号 | $T=$ | $n\\le$ | $m\\le$ | $k\\le$ | $p\\le$ |\n| :--: | :--: | :--: | :--: | :--: | :--: |\n| $1,2$ | $5000$ | $100$ | $100$ | $100$ | $10^9$ |\n| $3$ | $5000$ | $10^{18}$ | $10^{18}$ | $0$ | $10^9$ |\n| $4$ | $5000$ | $10^{18}$ | $10^{18}$ | $1$ | $10^9$ |\n| $5$ | $5000$ | $10$ | $10^{18}$ | $10$ | $10^9$ |\n| $6$ | $1$ | $10^5$ | $10^{18}$ | $10^5$ | $10^9$ |\n| $7$ | $1$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |\n| $8$ | $100$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |\n| $9,10$ | $5000$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |\n\n$\\texttt{Statement fixed by Starrykiller.}$", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] Energy Storage Table", "background": "", "description": "There is a table with $n$ rows and $m$ columns, with rows numbered from $0$ to $n-1$ and columns numbered from $0$ to $m-1$. Each cell stores energy. Initially, the cell in row $i$ and column $j$ stores $(i \\oplus j)$ units of energy (where $\\oplus$ denotes bitwise XOR). Therefore, the total energy stored in the whole table is\n$$\\sum_{i=0}^{n-1} \\sum_{j=0}^{m-1} i \\oplus j.$$\n\nAs time passes, the energy in the cells gradually decreases. After each unit of time, the energy in every cell decreases by $1$. Obviously, once a cell’s energy decreases to $0$, it will not decrease any further.\n\nThat is, after $k$ units of time, the total energy stored in the whole table is\n$$\\sum_{i=0}^{n-1} \\sum_{j=0}^{m-1} \\max((i \\oplus j)-k,0).$$\n\nGiven the table, find the total energy it stores after $k$ units of time.\n\nSince the total energy may be large, output it modulo $p$.", "inputFormat": "The first line contains an integer $T$, the number of test cases. Then $T$ lines follow, each containing four integers $n, m, k, p$.", "outputFormat": "Output $T$ lines, each containing one number: the result of the total energy modulo $p$.", "hint": "For $100\\%$ of the testdata, it is guaranteed that $1 \\le T \\le 5000$, $1 \\le p \\le 10^9$, $1 \\le n,m \\le 10^{18}$, $0 \\le k \\le 10^{18}$.\n\n| 测试点编号 | $T=$ | $n\\le$ | $m\\le$ | $k\\le$ | $p\\le$ |\n| :--: | :--: | :--: | :--: | :--: | :--: |\n| $1,2$ | $5000$ | $100$ | $100$ | $100$ | $10^9$ |\n| $3$ | $5000$ | $10^{18}$ | $10^{18}$ | $0$ | $10^9$ |\n| $4$ | $5000$ | $10^{18}$ | $10^{18}$ | $1$ | $10^9$ |\n| $5$ | $5000$ | $10$ | $10^{18}$ | $10$ | $10^9$ |\n| $6$ | $1$ | $10^5$ | $10^{18}$ | $10^5$ | $10^9$ |\n| $7$ | $1$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |\n| $8$ | $100$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |\n| $9,10$ | $5000$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |\n\n$\\texttt{Statement fixed by Starrykiller.}$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 储能表", "background": "", "description": "有一个 $n$ 行 $m$ 列的表格，**行从 $0$ 到 $n-1$ 编号，列从 $0$ 到 $m-1$ 编号**。每个格子都储存着能量。最初，第 $i$ 行第 $j$ 列的格子储存着 $(i \\oplus j)$ 点能量（$\\oplus$ 表示**按位异或**）。所以，整个表格储存的总能量是\n\n$$\\sum_{i=0}^{n-1} \\sum_{j=0}^{m-1} i \\oplus j$$\n\n随着时间的推移，格子中的能量会渐渐减少。每经过一个时间单位，每个格子中的能量都会减少 $1$。显然，**一个格子的能量减少到 $0$ 之后就不会再减少了。**\n\n也就是说，$k$ 个时间单位后，整个表格储存的总能量是\n\n$$\\sum_{i=0}^{n-1} \\sum_{j=0}^{m-1} \\max((i \\oplus j)-k,0)$$\n\n给出一个表格，求 $k$ 个时间单位后它储存的总能量。\n\n由于总能量可能较大，输出时对 $p$ 取模。", "inputFormat": "第一行一个整数 $T$，表示数据组数。接下来 $T$ 行，每行四个整数 $n,m,k,p$。\n", "outputFormat": "共 $T$ 行，每行一个数，表示总能量对 $p$ 取模后的结果。\n", "hint": "对于 $100\\%$ 的数据，保证 $1\\le T\\le 5000$，$1\\le p\\le 10^9$，$1\\le n,m\\le 10^{18}，0\\le k\\le 10^{18}$。\n\n| 测试点编号 | $T=$ | $n\\le$ | $m\\le$ | $k\\le$ | $p\\le$ |\n| :--: | :--: | :--: | :--: | :--: | :--: |\n| $1,2$ | $5000$ | $100$ | $100$ | $100$ | $10^9$ |\n| $3$ | $5000$ | $10^{18}$ | $10^{18}$ | $0$ | $10^9$ |\n| $4$ | $5000$ | $10^{18}$ | $10^{18}$ | $1$ | $10^9$ |\n| $5$ | $5000$ | $10$ | $10^{18}$ | $10$ | $10^9$ |\n| $6$ | $1$ | $10^5$ | $10^{18}$ | $10^5$ | $10^9$ |\n| $7$ | $1$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |\n| $8$ | $100$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |\n| $9,10$ | $5000$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |\n\n$\\texttt{Statement fixed by Starrykiller.}$", "locale": "zh-CN"}}}
{"pid": "P4068", "type": "P", "difficulty": 6, "samples": [["3\n2 4 8\n2 200 7\n-1 -2 1\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2016", "各省省选", "网络流", "山东", "二分图", "素数判断,质数,筛法"], "title": "[SDOI2016] 数字配对", "background": "", "description": "有 $n$ 种数字，第 $i$ 种数字是 $a_i$、有 $b_i$ 个，权值是 $c_i$。\n\n若两个数字 $a_i$、$a_j$ 满足，$a_i$ 是 $a_j$ 的倍数，且 $a_i/a_j$ 是一个质数，\n\n那么这两个数字可以配对，并获得 $c_i \\times c_j$ 的价值。\n\n一个数字只能参与一次配对，可以不参与配对。\n\n在获得的价值总和不小于 $0$ 的前提下，求最多进行多少次配对。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个整数 $a_1,a_2,\\cdots,a_n$。\n\n第三行 $n$ 个整数 $b_1,b_2,\\cdots,b_n$。\n\n第四行 $n$ 个整数 $c_1,c_2,\\cdots,c_n$。", "outputFormat": "一行一个数，最多进行多少次配对。", "hint": "测试点 $1 \\sim 3$： $n \\leq 10 $， $a_i \\leq 10 ^ 9 $ ， $b_i = 1 $，$ | c_i | \\leq 10 ^ 5$；   \n\n测试点 $4 \\sim 5$： $n \\leq 200 $， $a_i \\leq 10 ^ 9 $ ， $b_i \\leq 10 ^ 5  $，$c_i = 0$；\n\n测试点 $6 \\sim 10$： $n \\leq 200 $， $a_i \\leq 10 ^ 9 $ ， $b_i \\leq 10 ^ 5$ ，$ | c_i | \\leq 10 ^ 5$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] Number Pairing", "background": "", "description": "There are $n$ types of numbers. For the $i$-th type, the number is $a_i$, there are $b_i$ copies of it, and its weight is $c_i$.\n\nIf two numbers $a_i$ and $a_j$ satisfy that $a_i$ is a multiple of $a_j$, and $a_i / a_j$ is a prime number, then these two numbers can be paired, gaining a value of $c_i \\times c_j$.\n\nEach number can participate in at most one pairing, and it is allowed to remain unpaired.\n\nUnder the condition that the total gained value is at least $0$, find the maximum possible number of pairings.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains $n$ integers $a_1,a_2,\\cdots,a_n$.\n\nThe third line contains $n$ integers $b_1,b_2,\\cdots,b_n$.\n\nThe fourth line contains $n$ integers $c_1,c_2,\\cdots,c_n$.", "outputFormat": "Output a single integer on one line: the maximum number of pairings.", "hint": "Test points $1 \\sim 3$: $n \\leq 10$, $a_i \\leq 10^9$, $b_i = 1$, $|c_i| \\leq 10^5$.  \nTest points $4 \\sim 5$: $n \\leq 200$, $a_i \\leq 10^9$, $b_i \\leq 10^5$, $c_i = 0$.  \nTest points $6 \\sim 10$: $n \\leq 200$, $a_i \\leq 10^9$, $b_i \\leq 10^5$, $|c_i| \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 数字配对", "background": "", "description": "有 $n$ 种数字，第 $i$ 种数字是 $a_i$、有 $b_i$ 个，权值是 $c_i$。\n\n若两个数字 $a_i$、$a_j$ 满足，$a_i$ 是 $a_j$ 的倍数，且 $a_i/a_j$ 是一个质数，\n\n那么这两个数字可以配对，并获得 $c_i \\times c_j$ 的价值。\n\n一个数字只能参与一次配对，可以不参与配对。\n\n在获得的价值总和不小于 $0$ 的前提下，求最多进行多少次配对。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个整数 $a_1,a_2,\\cdots,a_n$。\n\n第三行 $n$ 个整数 $b_1,b_2,\\cdots,b_n$。\n\n第四行 $n$ 个整数 $c_1,c_2,\\cdots,c_n$。", "outputFormat": "一行一个数，最多进行多少次配对。", "hint": "测试点 $1 \\sim 3$： $n \\leq 10 $， $a_i \\leq 10 ^ 9 $ ， $b_i = 1 $，$ | c_i | \\leq 10 ^ 5$；   \n\n测试点 $4 \\sim 5$： $n \\leq 200 $， $a_i \\leq 10 ^ 9 $ ， $b_i \\leq 10 ^ 5  $，$c_i = 0$；\n\n测试点 $6 \\sim 10$： $n \\leq 200 $， $a_i \\leq 10 ^ 9 $ ， $b_i \\leq 10 ^ 5$ ，$ | c_i | \\leq 10 ^ 5$。", "locale": "zh-CN"}}}
{"pid": "P4069", "type": "P", "difficulty": 6, "samples": [["3 5\n1 2 10\n2 3 20\n2 1 3\n1 2 3 5 6\n2 2 3\n1 2 3 -5 -6\n2 2 3", "123456789123456789\n6\n-106"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2016", "线段树", "各省省选", "山东", "最近公共祖先 LCA", "树链剖分", "李超线段树"], "title": "[SDOI2016] 游戏", "background": "", "description": "Alice 和 Bob 在玩一个游戏。\n\n游戏在一棵有 $n$ 个点的树上进行。最初，每个点上都只有一个数字，那个数字是 $123456789123456789$。\n\n有时，Alice 会选择一条从 $s$ 到 $t$ 的路径，在这条路径上的每一个点上都添加一个数字。对于路径上的一个点 $r$，若 $r$ 与 $s$ 的距离是 $dis$，那么 Alice 在点 $r$ 上添加的数字是 $a\\times dis+b$。\n\n有时，Bob 会选择一条从 $s$ 到 $t$ 的路径。他需要先从这条路径上选择一个点，再从那个点上选择一个数字。\n\nBob 选择的数字越小越好，但大量的数字让 Bob 眼花缭乱。Bob 需要你帮他找出他能够选择的最小的数字。\n", "inputFormat": "第一行两个数字 $n,m$，表示树的点数和进行的操作数。\n\n接下来 $n-1$ 行，每行三个数字 $u,v,w$，表示树上有一条连接 $u,v$ 的边，长度是 $w$。\n\n接下来 $m$ 行。每行第一个数字是 $1$ 或 $2$。\n\n若第一个数是 $1$，表示 Alice 进行操作，接下来四个数字 $s,t,a,b$。\n\n若第一个数是 $2$，表示 Bob 进行操作，接下来两个数字 $s,t$。\n", "outputFormat": "每当 Bob 进行操作，输出一行一个数，表示他能够选择的最小的数字\n", "hint": "测试点 1 ~ 2：$ n \\leq 10 $，$ m \\leq 10 $，$ | a | \\leq 10000 $；\n\n测试点 3 ~ 4：$ n \\leq 1000 $，$ m \\leq 1000 $，$ | a | \\leq 10000 $；\n\n测试点 5：$ n \\leq 100000 $，$ m \\leq 100000 $，$ a = 0 $，树是一条链；\n\n测试点 6 ~ 7：$ n \\leq 100000 $，$ m \\leq 100000 $，$ a = 0 $；\n\n测试点 8：$ n \\leq 100000 $，$ m \\leq 100000 $，$ a = 1 $，树是一条链；\n\n测试点 9 ~ 10：$ n \\leq 100000 $，$ m \\leq 100000 $，$ a = 1 $；\n\n测试点 11 ~ 13：$ n \\leq 100000 $，$ m \\leq 100000 $，$ | a | \\leq 10000 $，树是一条链；\n\n测试点 14 ~ 20：$ n \\leq 100000 $，$ m \\leq 100000 $，$ | a | \\leq 10000 $。\n\n对于所有数据，$0\\le w, |b|\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] Game", "background": "", "description": "Alice and Bob are playing a game.\n\nThe game is played on a tree with $n$ vertices. Initially, each vertex contains exactly one number, which is $123456789123456789$.\n\nSometimes, Alice chooses the path from $s$ to $t$ and adds a number to every vertex on this path. For a vertex $r$ on the path, if the distance between $r$ and $s$ is $dis$, then the number Alice adds to $r$ is $a \\times dis + b$.\n\nSometimes, Bob chooses the path from $s$ to $t$. He must first choose a vertex on this path, and then choose one number stored at that vertex.\n\nBob wants the chosen number to be as small as possible, but the large amount of numbers makes him dazzled. He needs your help to find the smallest number he can choose.", "inputFormat": "The first line contains two integers $n, m$, the number of vertices of the tree and the number of operations.\n\nThe next $n - 1$ lines each contain three integers $u, v, w$, indicating there is an edge connecting $u$ and $v$ with length $w$.\n\nThe next $m$ lines each begin with an integer $1$ or $2$.\n\nIf the first integer is $1$, it denotes Alice’s operation, followed by four integers $s, t, a, b$.\n\nIf the first integer is $2$, it denotes Bob’s operation, followed by two integers $s, t$.", "outputFormat": "Each time Bob performs an operation, output one line with a single integer, representing the smallest number he can choose.", "hint": "Test points 1–2: $n \\leq 10$, $m \\leq 10$, $|a| \\leq 10000$.\n\nTest points 3–4: $n \\leq 1000$, $m \\leq 1000$, $|a| \\leq 10000$.\n\nTest point 5: $n \\leq 100000$, $m \\leq 100000$, $a = 0$, the tree is a path.\n\nTest points 6–7: $n \\leq 100000$, $m \\leq 100000$, $a = 0$.\n\nTest point 8: $n \\leq 100000$, $m \\leq 100000$, $a = 1$, the tree is a path.\n\nTest points 9–10: $n \\leq 100000$, $m \\leq 100000$, $a = 1$.\n\nTest points 11–13: $n \\leq 100000$, $m \\leq 100000$, $|a| \\leq 10000$, the tree is a path.\n\nTest points 14–20: $n \\leq 100000$, $m \\leq 100000$, $|a| \\leq 10000$.\n\nFor all testdata, $0 \\le w, |b| \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 游戏", "background": "", "description": "Alice 和 Bob 在玩一个游戏。\n\n游戏在一棵有 $n$ 个点的树上进行。最初，每个点上都只有一个数字，那个数字是 $123456789123456789$。\n\n有时，Alice 会选择一条从 $s$ 到 $t$ 的路径，在这条路径上的每一个点上都添加一个数字。对于路径上的一个点 $r$，若 $r$ 与 $s$ 的距离是 $dis$，那么 Alice 在点 $r$ 上添加的数字是 $a\\times dis+b$。\n\n有时，Bob 会选择一条从 $s$ 到 $t$ 的路径。他需要先从这条路径上选择一个点，再从那个点上选择一个数字。\n\nBob 选择的数字越小越好，但大量的数字让 Bob 眼花缭乱。Bob 需要你帮他找出他能够选择的最小的数字。\n", "inputFormat": "第一行两个数字 $n,m$，表示树的点数和进行的操作数。\n\n接下来 $n-1$ 行，每行三个数字 $u,v,w$，表示树上有一条连接 $u,v$ 的边，长度是 $w$。\n\n接下来 $m$ 行。每行第一个数字是 $1$ 或 $2$。\n\n若第一个数是 $1$，表示 Alice 进行操作，接下来四个数字 $s,t,a,b$。\n\n若第一个数是 $2$，表示 Bob 进行操作，接下来两个数字 $s,t$。\n", "outputFormat": "每当 Bob 进行操作，输出一行一个数，表示他能够选择的最小的数字\n", "hint": "测试点 1 ~ 2：$ n \\leq 10 $，$ m \\leq 10 $，$ | a | \\leq 10000 $；\n\n测试点 3 ~ 4：$ n \\leq 1000 $，$ m \\leq 1000 $，$ | a | \\leq 10000 $；\n\n测试点 5：$ n \\leq 100000 $，$ m \\leq 100000 $，$ a = 0 $，树是一条链；\n\n测试点 6 ~ 7：$ n \\leq 100000 $，$ m \\leq 100000 $，$ a = 0 $；\n\n测试点 8：$ n \\leq 100000 $，$ m \\leq 100000 $，$ a = 1 $，树是一条链；\n\n测试点 9 ~ 10：$ n \\leq 100000 $，$ m \\leq 100000 $，$ a = 1 $；\n\n测试点 11 ~ 13：$ n \\leq 100000 $，$ m \\leq 100000 $，$ | a | \\leq 10000 $，树是一条链；\n\n测试点 14 ~ 20：$ n \\leq 100000 $，$ m \\leq 100000 $，$ | a | \\leq 10000 $。\n\n对于所有数据，$0\\le w, |b|\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4070", "type": "P", "difficulty": 6, "samples": [["7\n1 2 3 3 3 1 2", "1\n3\n6\n9\n12\n17\n22"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2016", "各省省选", "平衡树", "山东", "后缀自动机 SAM", "后缀数组 SA"], "title": "[SDOI2016] 生成魔咒", "background": null, "description": "魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 $1,2$ 拼凑起来形成一个魔咒串 $[1,2]$。\n\n一个魔咒串 $S$ 的非空子串被称为魔咒串 $S$ 的生成魔咒。\n\n例如 $S=[1,2,1]$ 时，它的生成魔咒有 $[1],[2],[1,2],[2,1],[1,2,1]$ 五种。$S=[1,1,1]$ 时，它的生成魔咒有 $[1],[1,1],[1,1,1]$ 三种，最初 S 为空串。  \n\n共进行 $n$ 次操作，每次操作是在 $S$ 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 $S$ 共有多少种生成魔咒。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个数，第 $i$ 个数表示第 $i$ 次操作加入的魔咒字符 $x_i$。", "outputFormat": "输出 $n$ 行，每行一个数。  \n第 $i$ 行的数表示第 $i$ 次操作后 $S$ 的生成魔咒数量。", "hint": "#### 数据规模与约定   \n对于 $10\\%$ 的数据，保证 $1 \\le n \\le 10$；  \n对于 $30\\%$ 的数据，保证 $1 \\le n \\le 100$；  \n对于 $60\\%$ 的数据，保证 $1 \\le n \\le 10^3$；   \n对于 $100\\%$ 的数据，保证 $1 \\le n \\le 10^5$，$1 \\leq x_i \\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] Generating Spell", "background": "", "description": "A spell string consists of many spell characters, and a spell character can be represented by a number. For example, we can piece together spell characters $1,2$ to form a spell string $[1,2]$.\n\nA non-empty substring of a spell string $S$ is called a generating spell of $S$.\n\nFor example, when $S = [1,2,1]$, its generating spells are $[1],[2],[1,2],[2,1],[1,2,1]$, five in total. When $S = [1,1,1]$, its generating spells are $[1],[1,1],[1,1,1]$, three in total. Initially, $S$ is an empty string.\n\nThere are $n$ operations in total. In each operation, one spell character is appended to the end of $S$. After each operation, you need to determine how many distinct generating spells the current spell string $S$ has.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains $n$ numbers. The $i$-th number denotes the spell character $x_i$ appended in the $i$-th operation.", "outputFormat": "Output $n$ lines, one number per line.  \nThe number on the $i$-th line denotes the number of distinct generating spells after the $i$-th operation.", "hint": "Constraints  \nFor 10% of the testdata, it is guaranteed that $1 \\le n \\le 10$.  \nFor 30% of the testdata, it is guaranteed that $1 \\le n \\le 100$.  \nFor 60% of the testdata, it is guaranteed that $1 \\le n \\le 10^3$.  \nFor 100% of the testdata, it is guaranteed that $1 \\le n \\le 10^5$, $1 \\leq x_i \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 生成魔咒", "background": null, "description": "魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 $1,2$ 拼凑起来形成一个魔咒串 $[1,2]$。\n\n一个魔咒串 $S$ 的非空子串被称为魔咒串 $S$ 的生成魔咒。\n\n例如 $S=[1,2,1]$ 时，它的生成魔咒有 $[1],[2],[1,2],[2,1],[1,2,1]$ 五种。$S=[1,1,1]$ 时，它的生成魔咒有 $[1],[1,1],[1,1,1]$ 三种，最初 S 为空串。  \n\n共进行 $n$ 次操作，每次操作是在 $S$ 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 $S$ 共有多少种生成魔咒。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个数，第 $i$ 个数表示第 $i$ 次操作加入的魔咒字符 $x_i$。", "outputFormat": "输出 $n$ 行，每行一个数。  \n第 $i$ 行的数表示第 $i$ 次操作后 $S$ 的生成魔咒数量。", "hint": "#### 数据规模与约定   \n对于 $10\\%$ 的数据，保证 $1 \\le n \\le 10$；  \n对于 $30\\%$ 的数据，保证 $1 \\le n \\le 100$；  \n对于 $60\\%$ 的数据，保证 $1 \\le n \\le 10^3$；   \n对于 $100\\%$ 的数据，保证 $1 \\le n \\le 10^5$，$1 \\leq x_i \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4071", "type": "P", "difficulty": 4, "samples": [["5\n1 0\n1 1\n5 2\n100 50\n10000 5000", "0\n1\n20\n578028887\n60695423"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "2016", "各省省选", "山东", "枚举", "线性递推", "逆元"], "title": "[SDOI2016] 排列计数", "background": "", "description": "求有多少种 $1$ 到 $n$ 的排列 $a$，满足序列恰好有 $m$ 个位置 $i$，使得 $a_i = i$。\n\n答案对 $10^9 + 7$ 取模。", "inputFormat": "**本题单测试点内有多组数据**。\n\n输入的第一行是一个整数 $T$，代表测试数据的组数。\n\n以下 $T$ 行，每行描述一组测试数据。\n\n对于每组测试数据，每行输入两个整数，依次代表 $n$ 和 $m$。", "outputFormat": "共输出 $T$ 行，对于每组测试数据，输出一行一个整数代表答案。", "hint": "#### 数据规模与约定\n\n本题共 20 个测试点，各测试点等分，其数据规模如下表。\n\n| 测试点编号 | $T =$  | $n, m \\leq$ |  测试点编号  |      $T =$      | $n, m \\leq$ |\n| :--------: | :----: | :---------: | :----------: | :-------------: | :---------: |\n| $1\\sim 3$  | $10^3$ |     $8$     | $10 \\sim 12$ |     $10^3$      |   $10^3$    |\n| $4 \\sim 6$ | $10^3$ |    $12$     | $13 \\sim 14$ | $5 \\times 10^5$ |   $10^3$    |\n| $7 \\sim 9$ | $10^3$ |    $100$    | $15 \\sim 20$ | $5 \\times 10^5$ |   $10^6$    |\n\n对于全部的测试点，保证 $1 \\leq T \\leq 5 \\times 10^5$，$1 \\leq n \\leq 10^6$，$0 \\leq m \\leq 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] Permutation Counting", "background": "", "description": "Count the number of permutations $a$ of $1$ to $n$ such that there are exactly $m$ positions $i$ with $a_i = i$.\n\nOutput the answer modulo $10^9 + 7$.", "inputFormat": "**There are multiple test cases in a single test file.**\n\nThe first line contains an integer $T$, representing the number of test cases.\n\nThe following $T$ lines each describe one test case.\n\nFor each test case, a single line contains two integers $n$ and $m$, in that order.", "outputFormat": "Output $T$ lines. For each test case, output one integer representing the answer.", "hint": "#### Constraints\n\nThis problem contains 20 test points, evenly divided. The constraints for each test point are shown in the table below.\n\n| Test point ID | $T =$  | $n, m \\leq$ |  Test point ID  |      $T =$      | $n, m \\leq$ |\n| :-----------: | :----: | :---------: | :-------------: | :-------------: | :---------: |\n|  $1 \\sim 3$   | $10^3$ |     $8$     |  $10 \\sim 12$   |     $10^3$      |   $10^3$    |\n|  $4 \\sim 6$   | $10^3$ |    $12$     |  $13 \\sim 14$   | $5 \\times 10^5$ |   $10^3$    |\n|  $7 \\sim 9$   | $10^3$ |    $100$    |  $15 \\sim 20$   | $5 \\times 10^5$ |   $10^6$    |\n\nFor all test points, it is guaranteed that $1 \\leq T \\leq 5 \\times 10^5$, $1 \\leq n \\leq 10^6$, $0 \\leq m \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 排列计数", "background": "", "description": "求有多少种 $1$ 到 $n$ 的排列 $a$，满足序列恰好有 $m$ 个位置 $i$，使得 $a_i = i$。\n\n答案对 $10^9 + 7$ 取模。", "inputFormat": "**本题单测试点内有多组数据**。\n\n输入的第一行是一个整数 $T$，代表测试数据的组数。\n\n以下 $T$ 行，每行描述一组测试数据。\n\n对于每组测试数据，每行输入两个整数，依次代表 $n$ 和 $m$。", "outputFormat": "共输出 $T$ 行，对于每组测试数据，输出一行一个整数代表答案。", "hint": "#### 数据规模与约定\n\n本题共 20 个测试点，各测试点等分，其数据规模如下表。\n\n| 测试点编号 | $T =$  | $n, m \\leq$ |  测试点编号  |      $T =$      | $n, m \\leq$ |\n| :--------: | :----: | :---------: | :----------: | :-------------: | :---------: |\n| $1\\sim 3$  | $10^3$ |     $8$     | $10 \\sim 12$ |     $10^3$      |   $10^3$    |\n| $4 \\sim 6$ | $10^3$ |    $12$     | $13 \\sim 14$ | $5 \\times 10^5$ |   $10^3$    |\n| $7 \\sim 9$ | $10^3$ |    $100$    | $15 \\sim 20$ | $5 \\times 10^5$ |   $10^6$    |\n\n对于全部的测试点，保证 $1 \\leq T \\leq 5 \\times 10^5$，$1 \\leq n \\leq 10^6$，$0 \\leq m \\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4072", "type": "P", "difficulty": 6, "samples": [["5 2\n1 2 5 8 6", "36"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "各省省选", "单调队列", "山东", "O2优化", "斜率优化", "前缀和", "凸包"], "title": "[SDOI2016] 征途", "background": null, "description": "Pine 开始了从 $S$ 地到 $T$ 地的征途。\n\n从 $S$ 地到 $T$ 地的路可以划分成 $n$ 段，相邻两段路的分界点设有休息站。\n\nPine 计划用 $m$ 天到达 $T$ 地。除第 $m$ 天外，每一天晚上 Pine 都必须在休息站过夜。所以，一段路必须在同一天中走完。\n\nPine 希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。\n\n帮助 Pine 求出最小方差是多少。\n\n设方差是 $v$，可以证明，$v\\times m^2$ 是一个整数。为了避免精度误差，输出结果时输出 $v\\times m^2$。", "inputFormat": "第一行两个数 $n, m$。\n\n第二行 $n$ 个数，表示 $n$ 段路的长度。", "outputFormat": "一个数，最小方差乘以 $m^2$ 后的值。", "hint": "### 数据范围及约定\n\n- 对于 $30\\%$ 的数据，$1 \\le n \\le 10$；\n- 对于 $60\\%$ 的数据，$1 \\le n \\le 100$；\n- 对于 $100\\%$ 的数据，$1 \\le n \\le 3000$。\n\n保证从 $S$ 到 $T$ 的总路程不超过 $3\\times 10^4$。\n\n$2 \\leq m \\leq n$，每段路的长度为不超过 $3 \\times 10^4$ 的**正整数**。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] The Journey", "background": "", "description": "Pine starts a journey from $S$ to $T$.\n\nThe road from $S$ to $T$ can be divided into $n$ segments, and there is a rest station at the boundary point between each pair of adjacent segments.\n\nPine plans to reach $T$ in $m$ days. Except for day $m$, Pine must spend each night at a rest station. Therefore, each segment must be completed within a single day.\n\nPine wants the daily distances to be as similar as possible, so he wants the variance of the daily distances to be as small as possible.\n\nHelp Pine find the minimum possible variance.\n\nLet the variance be $v$. It can be proven that $v \\times m^2$ is an integer. To avoid precision errors, output $v \\times m^2$.", "inputFormat": "The first line contains two integers $n, m$.\n\nThe second line contains $n$ integers, representing the lengths of the $n$ segments.", "outputFormat": "Output a single integer: the minimum variance multiplied by $m^2$.", "hint": "- Constraints and Conventions\n  - For $30\\%$ of the testdata, $1 \\le n \\le 10$;\n  - For $60\\%$ of the testdata, $1 \\le n \\le 100$;\n  - For $100\\%$ of the testdata, $1 \\le n \\le 3000$.\n\nThe total distance from $S$ to $T$ does not exceed $3 \\times 10^4$.\n\n$2 \\le m \\le n$, and each segment length is a positive integer not exceeding $3 \\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 征途", "background": null, "description": "Pine 开始了从 $S$ 地到 $T$ 地的征途。\n\n从 $S$ 地到 $T$ 地的路可以划分成 $n$ 段，相邻两段路的分界点设有休息站。\n\nPine 计划用 $m$ 天到达 $T$ 地。除第 $m$ 天外，每一天晚上 Pine 都必须在休息站过夜。所以，一段路必须在同一天中走完。\n\nPine 希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。\n\n帮助 Pine 求出最小方差是多少。\n\n设方差是 $v$，可以证明，$v\\times m^2$ 是一个整数。为了避免精度误差，输出结果时输出 $v\\times m^2$。", "inputFormat": "第一行两个数 $n, m$。\n\n第二行 $n$ 个数，表示 $n$ 段路的长度。", "outputFormat": "一个数，最小方差乘以 $m^2$ 后的值。", "hint": "### 数据范围及约定\n\n- 对于 $30\\%$ 的数据，$1 \\le n \\le 10$；\n- 对于 $60\\%$ 的数据，$1 \\le n \\le 100$；\n- 对于 $100\\%$ 的数据，$1 \\le n \\le 3000$。\n\n保证从 $S$ 到 $T$ 的总路程不超过 $3\\times 10^4$。\n\n$2 \\leq m \\leq n$，每段路的长度为不超过 $3 \\times 10^4$ 的**正整数**。", "locale": "zh-CN"}}}
{"pid": "P4073", "type": "P", "difficulty": 7, "samples": [["9 12\n1 1\n1 2\n1 3\n2 1\n2 2\n2 3\n3 1\n3 2\n3 3\n1 2 10\n2 3 10\n3 6 10\n6 9 10\n9 8 10\n8 7 10\n7 4 10\n4 1 10\n2 5 3\n5 8 2\n5 6 4\n4 5 1\n3\n1.5 1.5 2.5 2.5\n1.5 2.5 2.5 1.5\n0.5 0.5 1.5 1.5", "2\n3\n-1"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["图论", "计算几何", "2013", "倍增", "平衡树", "枚举", "生成树", "WC"], "title": "[WC2013] 平面图", "background": "", "description": "在一个平面中有 $n$ 个顶点和 $m$ 条直线段，第 $i$ 个顶点的坐标为 $(x_i, y_i)$， 第 $j$ 条直线段连接顶点 $u_j$ 和顶点 $v_j$，权值为 $h_j$， 除顶点 $u_j$ 和 $v_j$ 外直线段 $j$ 不经过其他的顶点。任意两条直线段如果存在公共点，则该公共点一定是一个顶点，此时这两条直线段都会连接这个顶点。对于任意的两个顶点 $x$ 和 $y$，总是可以找到一顶点序列 $a_1,a_2,\\cdots,a_k$ 使得 $a_1=x$，$a_k=y$ 且对于任意 $1\\le i< k$ 满足 $a_i$ 和 $a_{i+1}$ 被一条直线段直接连接。\n\n这 $m$ 条直线段将整个平面分成了若干个区域，其中只有一个区域是无穷大的，其余均是有界的，我们称无穷大的区域为禁区。\n\n现在给出 $q$ 次询问，每次给定平面中的任意两个不是顶点且分别不在任意一条直线段上的点 $A$ 和 $B$，请画一条曲线连接 $A$ 和 $B$，要求曲线不能经过禁区以及任何顶点，并使得穿过的直线段中权值最大的尽可能小。你需要对每次询问回答这个值最小为多少。\n", "inputFormat": "第一行有两个正整数 $n,m$，分别表示顶点数和直线段数。\n\n接下来 $n$ 行，每行两个整数，这部分中第 $i$ 行（总第 $i+1$ 行）的两个整数 $x_i,y_i$ 为顶点 $i$ 的坐标。\n\n接下来 $m$ 行，每行三个正整数 $u,v,h$，表示有一条直线段连接顶点 $u$ 和顶点 $v$，权值为 $h$。其中 $u\\neq v$。\n\n接下来的一行，有一个正整数 $q$，表示询问数量。\n\n接下来 $q$ 行，每行四个实数 $A_x,A_y,B_x,B_y$， 表示一组两个点的坐标分别为 $(A_x, A_y)$ 和 $(B_x, B_y)$ 的询问。\n", "outputFormat": "输出 $q$ 行，每行一个正整数，依次表示每个询问的答案。特别的，若不需要跨过任何一条边即可到达，请输出 $0$；若不存在合法的曲线，请输出 $-1$。\n", "hint": "【样例说明】\n\n![QQ20180112214336.png](https://cdn.luogu.com.cn/upload/image_hosting/228djzaq.png)\n\n【数据规模与约定】\n\n本题共设有 $10$ 个测试点，每个测试点的规模与特征如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2l8u3hkb.png)\n\n对于全部数据，均满足 $5$ ≤ $n$, $m$, $q$ ≤ $100,000$，所有直线段的权值不会超过 $10^9$。所有询问坐标均为不超过 $10^7$ 的实数，且保证是 $0.5$ 的整数倍。\n", "locale": "zh-CN", "translations": {"en": {"title": "[WC2013] Planar Graph", "background": "", "description": "In a plane, there are $n$ vertices and $m$ line segments. The $i$-th vertex has coordinates $(x_i, y_i)$. The $j$-th line segment connects vertex $u_j$ and vertex $v_j$ and has weight $h_j$. Except for its endpoints $u_j$ and $v_j$, segment $j$ does not pass through any other vertex. If any two segments have a common point, that point must be a vertex, and in that case both segments connect to this vertex. For any two vertices $x$ and $y$, there always exists a sequence of vertices $a_1, a_2, \\cdots, a_k$ such that $a_1 = x$, $a_k = y$, and for every $1 \\le i < k$, $a_i$ and $a_{i+1}$ are directly connected by a segment.\n\nThese $m$ segments divide the plane into several regions. Exactly one region is unbounded and the others are bounded. We call the unbounded region the forbidden region.\n\nYou are given $q$ queries. In each query, two arbitrary points $A$ and $B$ in the plane are given; neither is a vertex and neither lies on any segment. Draw a curve connecting $A$ and $B$ that does not pass through the forbidden region or any vertex, and minimize the maximum weight among all segments crossed by the curve. For each query, you need to output this minimal possible value.", "inputFormat": "The first line contains two positive integers $n, m$, denoting the number of vertices and the number of line segments.\n\nThe next $n$ lines each contain two integers. In this part, the $i$-th line (the $(i+1)$-th line overall) contains two integers $x_i, y_i$, the coordinates of vertex $i$.\n\nThe next $m$ lines each contain three positive integers $u, v, h$, indicating there is a line segment connecting vertex $u$ and vertex $v$ with weight $h$. Here $u \\ne v$.\n\nThe next line contains a single positive integer $q$, the number of queries.\n\nThe next $q$ lines each contain four real numbers $A_x, A_y, B_x, B_y$, representing one query whose two points are $(A_x, A_y)$ and $(B_x, B_y)$.", "outputFormat": "Output $q$ lines, each containing an integer, which is the answer for each query in order. If $A$ can reach $B$ without crossing any segment, output $0$. If no valid curve exists, output $-1$.", "hint": "Sample explanation:\n\n![QQ20180112214336.png](https://cdn.luogu.com.cn/upload/image_hosting/228djzaq.png)\n\nConstraints and notes:\n\nThis problem has $10$ test points. The scale and features of each test point are as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2l8u3hkb.png)\n\nFor all data, it holds that $5 \\le n, m, q \\le 100000$. All segment weights do not exceed $10^9$. All query coordinates are real numbers not exceeding $10^7$, and are guaranteed to be multiples of $0.5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2013] 平面图", "background": "", "description": "在一个平面中有 $n$ 个顶点和 $m$ 条直线段，第 $i$ 个顶点的坐标为 $(x_i, y_i)$， 第 $j$ 条直线段连接顶点 $u_j$ 和顶点 $v_j$，权值为 $h_j$， 除顶点 $u_j$ 和 $v_j$ 外直线段 $j$ 不经过其他的顶点。任意两条直线段如果存在公共点，则该公共点一定是一个顶点，此时这两条直线段都会连接这个顶点。对于任意的两个顶点 $x$ 和 $y$，总是可以找到一顶点序列 $a_1,a_2,\\cdots,a_k$ 使得 $a_1=x$，$a_k=y$ 且对于任意 $1\\le i< k$ 满足 $a_i$ 和 $a_{i+1}$ 被一条直线段直接连接。\n\n这 $m$ 条直线段将整个平面分成了若干个区域，其中只有一个区域是无穷大的，其余均是有界的，我们称无穷大的区域为禁区。\n\n现在给出 $q$ 次询问，每次给定平面中的任意两个不是顶点且分别不在任意一条直线段上的点 $A$ 和 $B$，请画一条曲线连接 $A$ 和 $B$，要求曲线不能经过禁区以及任何顶点，并使得穿过的直线段中权值最大的尽可能小。你需要对每次询问回答这个值最小为多少。\n", "inputFormat": "第一行有两个正整数 $n,m$，分别表示顶点数和直线段数。\n\n接下来 $n$ 行，每行两个整数，这部分中第 $i$ 行（总第 $i+1$ 行）的两个整数 $x_i,y_i$ 为顶点 $i$ 的坐标。\n\n接下来 $m$ 行，每行三个正整数 $u,v,h$，表示有一条直线段连接顶点 $u$ 和顶点 $v$，权值为 $h$。其中 $u\\neq v$。\n\n接下来的一行，有一个正整数 $q$，表示询问数量。\n\n接下来 $q$ 行，每行四个实数 $A_x,A_y,B_x,B_y$， 表示一组两个点的坐标分别为 $(A_x, A_y)$ 和 $(B_x, B_y)$ 的询问。\n", "outputFormat": "输出 $q$ 行，每行一个正整数，依次表示每个询问的答案。特别的，若不需要跨过任何一条边即可到达，请输出 $0$；若不存在合法的曲线，请输出 $-1$。\n", "hint": "【样例说明】\n\n![QQ20180112214336.png](https://cdn.luogu.com.cn/upload/image_hosting/228djzaq.png)\n\n【数据规模与约定】\n\n本题共设有 $10$ 个测试点，每个测试点的规模与特征如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2l8u3hkb.png)\n\n对于全部数据，均满足 $5$ ≤ $n$, $m$, $q$ ≤ $100,000$，所有直线段的权值不会超过 $10^9$。所有询问坐标均为不超过 $10^7$ 的实数，且保证是 $0.5$ 的整数倍。\n", "locale": "zh-CN"}}}
{"pid": "P4074", "type": "P", "difficulty": 6, "samples": [["4 3 5\n1 9 2\n7 6 5 1\n2 3\n3 1\n3 4\n1 2 3 2\n1 1 2\n1 4 2\n0 2 1\n1 1 2\n1 4 2", "84\n131\n27\n84"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2013", "莫队", "最近公共祖先 LCA", "分块", "WC"], "title": "[WC2013] 糖果公园", "background": "", "description": "Candyland 有一座糖果公园，公园里不仅有美丽的风景、好玩的游乐项目，还有许多免费糖果的发放点，这引来了许多贪吃的小朋友来糖果公园游玩。\n\n糖果公园的结构十分奇特，它由 $n$ 个游览点构成，每个游览点都有一个糖果发放处，我们可以依次将游览点编号为 $1$ 至 $n$。有 $n - 1$ 条双向道路连接着这些游览点，并且整个糖果公园都是连通的，即从任何一个游览点出发都可以通过这些道路到达公园里的所有其它游览点。\n\n糖果公园所发放的糖果种类非常丰富，总共有 $m$ 种，它们的编号依次为 $1$ 至 $m$。每一个糖果发放处都只发放某种特定的糖果，我们用 $C_i$ 来表示 $i$ 号游览点的糖果。\n\n来到公园里游玩的游客都不喜欢走回头路，他们总是从某个特定的游览点出发前往另一个特定的游览点，并游览途中的景点，这条路线一定是唯一的。他们经过每个游览点，都可以品尝到一颗对应种类的糖果。\n\n大家对不同类型糖果的喜爱程度都不尽相同。 根据游客们的反馈打分，我们得到了糖果的美味指数， 第 $i$ 种糖果的美味指数为 $V_i$。另外，如果一位游客反复地品尝同一种类的糖果，他肯定会觉得有一些腻。根据量化统计，我们得到了游客第 $i$ 次品尝某类糖果的新奇指数 $W_i$。如果一位游客第 $i$ 次品尝第 $j$ 种糖果，那么他的愉悦指数 $H$ 将会增加对应的美味指数与新奇指数的乘积，即 $V_j \\times W_i$。这位游客游览公园的愉悦指数最终将是这些乘积的和。\n\n当然，公园中每个糖果发放点所发放的糖果种类不一定是一成不变的。有时，一些糖果点所发放的糖果种类可能会更改（也只会是 $m$ 种中的一种），这样的目的是能够让游客们总是感受到惊喜。\n\n糖果公园的工作人员小 A 接到了一个任务，那就是根据公园最近的数据统计出每位游客游玩公园的愉悦指数。但数学不好的小 A 一看到密密麻麻的数字就觉得头晕，作为小 A 最好的朋友，你决定帮他一把。\n", "inputFormat": "\n第一行包含三个正整数 $n, m, q$， 分别表示游览点个数、 糖果种类数和操作次数。\n\n第二行包含 $m$ 个正整数 $V_1, V_2, \\ldots, V_m$。\n\n第三行包含 $n$ 个正整数 $W_1, W_2, \\ldots, W_n$。\n\n第四行到第 $n + 2$ 行，每行包含两个正整数 $A_i, B_i$，表示这两个游览点之间有路径可以直接到达。\n\n第 $n + 3$ 行包含 $n$ 个正整数 $C_1, C_2, \\ldots, C_n$。\n\n接下来 $q$ 行， 每行包含三个整数 $Type, x, y$，表示一次操作：\n\n- 若 $Type$ 为 $0$，则 $1 \\leq x \\leq n$， $1 \\leq y \\leq m$，表示将编号为 $x$ 的游览点发放的糖果类型改为 $y$；\n- 若 $Type$ 为 $1$，则 $1 \\leq x, y \\leq n$，表示对出发点为 $x$，终止点为 $y$ 的路线询问愉悦指数。\n", "outputFormat": "按照输入的先后顺序，对于每个 $Type$ 为 $1$ 的操作输出一行，用一个正整数表示答案。\n", "hint": "【样例解释】\n\n我们分别用\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/isw3ib3u.png)\n\n代表 $C_i$ 为 $1$、 $2$、 $3$ 的节点，在修改之前：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ttkzii1u.png)\n\n在将 $C_2$ 修改为 $1$ 之后：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/izro364w.png)\n\n【数据规模与约定】\n\n对于所有的数据： $1 \\leq V_i, W_i \\leq 10^6$，$1 \\leq A_i, B_i \\leq n$， $1 \\leq C_i \\leq m$， $W_1, W_2, \\ldots, W_n$ 是非递增序列，即对任意 $1 < i \\leq n$， 满足 $W_i \\le W_{i-1}$。\n\n其它的限制条件如下表所示：\n\n![QQ20180113072014.png](https://cdn.luogu.com.cn/upload/image_hosting/g6884nx1.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "[WC2013] Candy Park", "background": "", "description": "Candyland has a Candy Park. Besides beautiful scenery and fun rides, there are many free candy distribution points, which attracts many candy-loving children to visit.\n\nThe structure of the Candy Park is peculiar. It consists of $n$ sightseeing spots, and each spot has a candy station. We number the spots from $1$ to $n$. There are $n - 1$ bidirectional roads connecting these spots, and the entire park is connected, meaning that starting from any spot, one can reach all other spots in the park via these roads.\n\nThere are $m$ types of candies in total, numbered from $1$ to $m$. Each candy station only distributes a specific type of candy. We use $C_i$ to denote the candy type at spot $i$.\n\nVisitors do not like to retrace their steps. They always travel from a particular starting spot to a particular ending spot, visiting the spots along the way. This route is unique. When they pass each spot, they can taste one candy of the corresponding type.\n\nPeople have different preferences for different types of candies. Based on visitor ratings, we obtained the tastiness index of candies: the tastiness index of the $i$-th type of candy is $V_i$. In addition, if a visitor repeatedly tastes the same type of candy, they will feel a bit bored. According to quantitative statistics, the novelty index for the $i$-th time tasting a certain type of candy is $W_i$. If a visitor tastes the $j$-th type of candy for the $i$-th time, their happiness index $H$ increases by the product of the corresponding tastiness index and novelty index, i.e., $V_j \\times W_i$. The visitor’s final happiness index is the sum of these products.\n\nOf course, the candy type distributed at each station may change from time to time (but always to one of the $m$ types), so that visitors can always feel surprised.\n\nStaff member A received a task to compute each visitor’s happiness index based on recent park data. But A is not good at math and feels dizzy when seeing rows of numbers. As A’s best friend, you decide to help.", "inputFormat": "The first line contains three positive integers $n, m, q$, representing the number of spots, the number of candy types, and the number of operations.\n\nThe second line contains $m$ positive integers $V_1, V_2, \\ldots, V_m$.\n\nThe third line contains $n$ positive integers $W_1, W_2, \\ldots, W_n$.\n\nFrom the 4th line to the $(n + 2)$-th line, each line contains two positive integers $A_i, B_i$, indicating that there is a road directly connecting these two spots.\n\nThe $(n + 3)$-th line contains $n$ positive integers $C_1, C_2, \\ldots, C_n$.\n\nThen there are $q$ lines. Each line contains three integers $Type, x, y$, representing an operation:\n- If $Type$ is $0$, then $1 \\le x \\le n$, $1 \\le y \\le m$, meaning that the candy type at spot $x$ is changed to $y$.\n- If $Type$ is $1$, then $1 \\le x, y \\le n$, meaning a query for the happiness index along the path from $x$ to $y$.", "outputFormat": "In the order of the input, for each operation with $Type = 1$, output one line with a single positive integer representing the answer.", "hint": "[Sample explanation]\n\nWe use\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/isw3ib3u.png)\n\nto denote nodes with $C_i$ equal to $1$, $2$, $3$. Before modification:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ttkzii1u.png)\n\nAfter changing $C_2$ to $1$:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/izro364w.png)\n\n[Constraints]\n\nFor all testdata: $1 \\le V_i, W_i \\le 10^6$, $1 \\le A_i, B_i \\le n$, $1 \\le C_i \\le m$, and $W_1, W_2, \\ldots, W_n$ is a non-increasing sequence, i.e., for any $1 < i \\le n$, it holds that $W_i \\le W_{i-1}$.\n\nOther constraint conditions are as shown in the table below:\n\n![QQ20180113072014.png](https://cdn.luogu.com.cn/upload/image_hosting/g6884nx1.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2013] 糖果公园", "background": "", "description": "Candyland 有一座糖果公园，公园里不仅有美丽的风景、好玩的游乐项目，还有许多免费糖果的发放点，这引来了许多贪吃的小朋友来糖果公园游玩。\n\n糖果公园的结构十分奇特，它由 $n$ 个游览点构成，每个游览点都有一个糖果发放处，我们可以依次将游览点编号为 $1$ 至 $n$。有 $n - 1$ 条双向道路连接着这些游览点，并且整个糖果公园都是连通的，即从任何一个游览点出发都可以通过这些道路到达公园里的所有其它游览点。\n\n糖果公园所发放的糖果种类非常丰富，总共有 $m$ 种，它们的编号依次为 $1$ 至 $m$。每一个糖果发放处都只发放某种特定的糖果，我们用 $C_i$ 来表示 $i$ 号游览点的糖果。\n\n来到公园里游玩的游客都不喜欢走回头路，他们总是从某个特定的游览点出发前往另一个特定的游览点，并游览途中的景点，这条路线一定是唯一的。他们经过每个游览点，都可以品尝到一颗对应种类的糖果。\n\n大家对不同类型糖果的喜爱程度都不尽相同。 根据游客们的反馈打分，我们得到了糖果的美味指数， 第 $i$ 种糖果的美味指数为 $V_i$。另外，如果一位游客反复地品尝同一种类的糖果，他肯定会觉得有一些腻。根据量化统计，我们得到了游客第 $i$ 次品尝某类糖果的新奇指数 $W_i$。如果一位游客第 $i$ 次品尝第 $j$ 种糖果，那么他的愉悦指数 $H$ 将会增加对应的美味指数与新奇指数的乘积，即 $V_j \\times W_i$。这位游客游览公园的愉悦指数最终将是这些乘积的和。\n\n当然，公园中每个糖果发放点所发放的糖果种类不一定是一成不变的。有时，一些糖果点所发放的糖果种类可能会更改（也只会是 $m$ 种中的一种），这样的目的是能够让游客们总是感受到惊喜。\n\n糖果公园的工作人员小 A 接到了一个任务，那就是根据公园最近的数据统计出每位游客游玩公园的愉悦指数。但数学不好的小 A 一看到密密麻麻的数字就觉得头晕，作为小 A 最好的朋友，你决定帮他一把。\n", "inputFormat": "\n第一行包含三个正整数 $n, m, q$， 分别表示游览点个数、 糖果种类数和操作次数。\n\n第二行包含 $m$ 个正整数 $V_1, V_2, \\ldots, V_m$。\n\n第三行包含 $n$ 个正整数 $W_1, W_2, \\ldots, W_n$。\n\n第四行到第 $n + 2$ 行，每行包含两个正整数 $A_i, B_i$，表示这两个游览点之间有路径可以直接到达。\n\n第 $n + 3$ 行包含 $n$ 个正整数 $C_1, C_2, \\ldots, C_n$。\n\n接下来 $q$ 行， 每行包含三个整数 $Type, x, y$，表示一次操作：\n\n- 若 $Type$ 为 $0$，则 $1 \\leq x \\leq n$， $1 \\leq y \\leq m$，表示将编号为 $x$ 的游览点发放的糖果类型改为 $y$；\n- 若 $Type$ 为 $1$，则 $1 \\leq x, y \\leq n$，表示对出发点为 $x$，终止点为 $y$ 的路线询问愉悦指数。\n", "outputFormat": "按照输入的先后顺序，对于每个 $Type$ 为 $1$ 的操作输出一行，用一个正整数表示答案。\n", "hint": "【样例解释】\n\n我们分别用\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/isw3ib3u.png)\n\n代表 $C_i$ 为 $1$、 $2$、 $3$ 的节点，在修改之前：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ttkzii1u.png)\n\n在将 $C_2$ 修改为 $1$ 之后：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/izro364w.png)\n\n【数据规模与约定】\n\n对于所有的数据： $1 \\leq V_i, W_i \\leq 10^6$，$1 \\leq A_i, B_i \\leq n$， $1 \\leq C_i \\leq m$， $W_1, W_2, \\ldots, W_n$ 是非递增序列，即对任意 $1 < i \\leq n$， 满足 $W_i \\le W_{i-1}$。\n\n其它的限制条件如下表所示：\n\n![QQ20180113072014.png](https://cdn.luogu.com.cn/upload/image_hosting/g6884nx1.png)\n", "locale": "zh-CN"}}}
{"pid": "P4075", "type": "P", "difficulty": 7, "samples": [["1\n11 4\nIODSSDSOIOI\n1 2\n2 3\n3 4\n1 5\n5 6\n6 7\n3 8\n8 9\n6 10\n10 11\nSDOI", "5"]], "limits": {"time": [2000, 2000, 2000], "memory": [128000, 128000, 128000]}, "tags": ["字符串", "2016", "各省省选", "点分治", "山东", "分治"], "title": "[SDOI2016] 模式字符串", "background": "", "description": "给出 $n$ 个结点的树 $T$，其中每一个结点上有一个字符，这里我们所说的字符只考虑大写字母 A 到 Z，再给出长度为 $m$ 的模式串 $S$，其中每一位仍然是 A 到 Z 的大写字母。\n\nAlice 希望知道，有多少对结点 $(u,v)$ 满足 $T$ 上从 $u$ 到 $v$ 的最短路径形成的字符串可以由模式串 $S$ 重复若干次得到l。\n\n这里结点对 $(u,v)$ 是有序的，也就是说 $(u,v)$ 和 $(v,u)$ 需要被区分。\n\n所谓模式串的重复，是将若干个模式串 $s$ 依次相接（不能重叠)。例如当 $S=$ `PLUS`的时候，重复两次会得到 `PLUSPLUS`，重复三次会得到 `PLUSPLUSPLUS`，同时要注意，重复必须是整数次的。例如当 $S= $ `XYXY` 时，因为必须重复整数次，所以 `XYXYXY` 不能看作是 $S$ 重复若干次得到的。", "inputFormat": "每一个数据有多组测试，\n\n第一行输入一个整数 $C$，表示总的测试个数。\n\n对于每一组测试来说：\n\n第一行输入两个整数，分别表示树 $T$ 的结点个数 $n$ 与模式长度 $m$。结点被依次编号为 $1$ 到 $n$。\n\n之后一行，依次给出了 $n$ 个大写字母（以一个长度为n的字符串的形式给出），依次对应树上每一个结点上的字符（第 $i$ 个字符对应了第 $i$ 个结点)。\n\n之后 $n-1$ 行，每行有两个整数 $u$ 和 $v$ 表示树上的一条无向边，之后一行给定一个长度为 $m$ 的由大写字母组成的字符串，为模式串 $S$。", "outputFormat": "\n给出 $C$ 行，对应 $C$ 组测试。\n\n每一行输出一个整数，表示有多少对节点 $(u,v)$ 满足从 $u$ 到 $v$ 的路径形成的字符串恰好是模式串的若干次重复。", "hint": "$1\\leq C\\leq 10$，$3\\leq \\sum N\\leq 10^6$，$3\\leq \\sum M\\leq 10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] Pattern String", "background": "", "description": "You are given a tree $T$ with $n$ nodes, where each node has a character. The characters are uppercase letters A to Z. You are also given a pattern string $S$ of length $m$, where each character is also an uppercase letter A to Z.\n\nAlice wants to know how many ordered pairs of nodes $(u,v)$ satisfy that the string formed by the shortest path from $u$ to $v$ in $T$ can be obtained by repeating the pattern string $S$ some number of times.\n\nHere the pair $(u,v)$ is ordered, meaning $(u,v)$ and $(v,u)$ are considered different.\n\nRepeating a pattern string means concatenating several copies of the pattern string $s$ one after another (without overlap). For example, when $S=$ `PLUS`, repeating it twice yields `PLUSPLUS`, repeating it three times yields `PLUSPLUSPLUS`. Note that the number of repetitions must be an integer. For example, when $S= $ `XYXY`, since repetitions must be an integer number, `XYXYXY` cannot be regarded as obtained by repeating $S$ some number of times.", "inputFormat": "There are multiple test cases.\n\nThe first line contains an integer $C$, the total number of test cases.\n\nFor each test case:\n\n- The first line contains two integers, the number of nodes $n$ of the tree $T$ and the pattern length $m$. Nodes are numbered from $1$ to $n$.\n- The next line gives $n$ uppercase letters (as a string of length $n$), where the $i$-th character corresponds to the $i$-th node on the tree.\n- The next $n-1$ lines each contain two integers $u$ and $v$, indicating an undirected edge of the tree.\n- The last line gives the pattern string $S$, which is a string of length $m$ consisting of uppercase letters.", "outputFormat": "Output $C$ lines, one for each test case.\n\nEach line should contain one integer, the number of ordered pairs $(u,v)$ such that the string formed by the path from $u$ to $v$ is exactly an integer number of repetitions of the pattern string $S$.", "hint": "$1 \\leq C \\leq 10$, $3 \\leq \\sum n \\leq 10^6$, $3 \\leq \\sum m \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 模式字符串", "background": "", "description": "给出 $n$ 个结点的树 $T$，其中每一个结点上有一个字符，这里我们所说的字符只考虑大写字母 A 到 Z，再给出长度为 $m$ 的模式串 $S$，其中每一位仍然是 A 到 Z 的大写字母。\n\nAlice 希望知道，有多少对结点 $(u,v)$ 满足 $T$ 上从 $u$ 到 $v$ 的最短路径形成的字符串可以由模式串 $S$ 重复若干次得到l。\n\n这里结点对 $(u,v)$ 是有序的，也就是说 $(u,v)$ 和 $(v,u)$ 需要被区分。\n\n所谓模式串的重复，是将若干个模式串 $s$ 依次相接（不能重叠)。例如当 $S=$ `PLUS`的时候，重复两次会得到 `PLUSPLUS`，重复三次会得到 `PLUSPLUSPLUS`，同时要注意，重复必须是整数次的。例如当 $S= $ `XYXY` 时，因为必须重复整数次，所以 `XYXYXY` 不能看作是 $S$ 重复若干次得到的。", "inputFormat": "每一个数据有多组测试，\n\n第一行输入一个整数 $C$，表示总的测试个数。\n\n对于每一组测试来说：\n\n第一行输入两个整数，分别表示树 $T$ 的结点个数 $n$ 与模式长度 $m$。结点被依次编号为 $1$ 到 $n$。\n\n之后一行，依次给出了 $n$ 个大写字母（以一个长度为n的字符串的形式给出），依次对应树上每一个结点上的字符（第 $i$ 个字符对应了第 $i$ 个结点)。\n\n之后 $n-1$ 行，每行有两个整数 $u$ 和 $v$ 表示树上的一条无向边，之后一行给定一个长度为 $m$ 的由大写字母组成的字符串，为模式串 $S$。", "outputFormat": "\n给出 $C$ 行，对应 $C$ 组测试。\n\n每一行输出一个整数，表示有多少对节点 $(u,v)$ 满足从 $u$ 到 $v$ 的路径形成的字符串恰好是模式串的若干次重复。", "hint": "$1\\leq C\\leq 10$，$3\\leq \\sum N\\leq 10^6$，$3\\leq \\sum M\\leq 10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P4076", "type": "P", "difficulty": 7, "samples": [["1\n2 10\n0 0\n0 0 0 0 0 0 0 0 0 0 \nADA_JARVIS\nADA_SIVRAJ", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "各省省选", "山东"], "title": "[SDOI2016] 墙上的句子", "background": "", "description": "考古学家发现了一堵写有未知语言的白色墙壁，上面有一个 $n$ 行 $m$ 列的格子，其中有些格子内被填入了某个 `A` 至 `Z` 的大写字母，还有些格子是空白的。\n\n一直横着或竖着的连续若干个字母会形成一个单词，且每一行的阅读顺序可能是从左向右或从右向左，每一列的阅读顺序可能是从下往上或从上往下。也就是说对于每一行来说，从左向右可以被看做是若干个单词形成的句子，相邻两个单词被一个或多个空白格子分割开来；也有可能是从右向左被看成是一个句子，竖直方向类似。\n\n遗憾的是，我们并不完全知道每一行每一列的阅读顺序是怎样的。但可以猜测，有些单词会满足反转过来也是一个单词。例如单词 `BOY`，翻转过来的 `YOB` 也是一个英文单词。\n\n此外观察者发现，对每一行（列）来说，按照确定后的阅读顺序读出的所有单词同时满足“自己的字典序不小于翻转后的字典序”，或同时满足“自己的字典序不大于翻转后的字典序”。\n\n在确定了所有行列的阅读顺序之后，我们可以构造出关于这种未知语言的字典。\n\n请问字典中出现的“翻转过来也是一个单词”的单词最少有多少种请注意，如果一个单词翻转后是不同的另外一个单词，它们需要被分别计入；而对于本身是回文的单词则不需要重复计入\n", "inputFormat": "第一行一个整数 $T$，表示 $T$ 组测试数据。\n\n对于每一组数据来说：第一行输入两个整数 $n,m$。\n\n第二行给出了 $n$ 个数字，对应 $n$ 行，其中若第 $i$ 个数字为 `1`，则表示第 $i$ 行的阅读顺序从左往右；若为 `-1` 则为从右向左；若为 `0` 则表示无法确定。\n\n第三行给出了 $m$ 个数字，对应 $n$ 行，其中若第 $i$ 个数字为 `1`，则表示第 $i$ 列的阅读顺序从上往下；若为 `-1` 则为从下向上；若为 `0` 则表示无法确定\n\n之后 $n$ 行，每行给出了长度为 $m$ 的字符串，由 `A` ~ `Z` 和下划线组成，对应了每个格子的符号，其中下划线表示格子为空。\n", "outputFormat": "输出 $T$ 行。每一组数据输出一行一个整数，表示最少有多少个单词，满足翻转后依然是单词。\n\n注意，如果一个单词是回文，那么它一定满足“翻转后依旧是单词”\n", "hint": "对于 $100\\%$ 的数据，$1\\leq n,m\\leq 72$，$T\\leq 64$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] Sentences on the Wall", "background": "", "description": "Archaeologists found a white wall written in an unknown language. On it there is an $n$-by-$m$ grid. Some cells contain an uppercase letter from `A` to `Z`, and some cells are blank.\n\nA contiguous run of letters strictly horizontally or vertically forms a word. Each row may be read either left to right or right to left, and each column may be read either bottom to top or top to bottom. That is, for each row, reading from left to right can be regarded as a sentence formed by several words, where adjacent words are separated by one or more blank cells; or it may be a sentence read from right to left. The vertical direction is analogous.\n\nUnfortunately, we do not completely know the reading order of each row and each column. However, it is plausible that some words satisfy that their reversed form is also a word. For example, the word `BOY` and its reversal `YOB` are both English words.\n\nFurthermore, observers found that for each row (column), under its finalized reading order, all words read in that row (column) simultaneously satisfy either “their own lexicographic order is not less than that of their reversed form,” or simultaneously satisfy “their own lexicographic order is not greater than that of their reversed form.”\n\nAfter determining the reading order of all rows and columns, we can construct a dictionary for this unknown language.\n\nWhat is the minimum possible number of distinct words in the dictionary whose reversed form is also a word? Please note that if a word and its reversed form are two different words, they must be counted separately; a word that is itself a palindrome should not be counted twice.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nFor each test case:\n- The first line contains two integers $n, m$.\n- The second line contains $n$ numbers, corresponding to the $n$ rows. If the $i$-th number is `1`, the $i$-th row is read left to right; if it is `-1`, it is read right to left; if it is `0`, the direction is undetermined.\n- The third line contains $m$ numbers, corresponding to the $m$ columns. If the $i$-th number is `1`, the $i$-th column is read top to bottom; if it is `-1`, it is read bottom to top; if it is `0`, the direction is undetermined.\n- Then follow $n$ lines. Each line is a string of length $m$, consisting of uppercase letters `A` to `Z` and underscores. An underscore denotes an empty cell.", "outputFormat": "Output $T$ lines. For each test case, output a single integer: the minimum number of words such that their reversed form is also a word.\n\nNote that if a word is a palindrome, it certainly satisfies “its reversal is also a word.”", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\leq n, m \\leq 72$, $T \\leq 64$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 墙上的句子", "background": "", "description": "考古学家发现了一堵写有未知语言的白色墙壁，上面有一个 $n$ 行 $m$ 列的格子，其中有些格子内被填入了某个 `A` 至 `Z` 的大写字母，还有些格子是空白的。\n\n一直横着或竖着的连续若干个字母会形成一个单词，且每一行的阅读顺序可能是从左向右或从右向左，每一列的阅读顺序可能是从下往上或从上往下。也就是说对于每一行来说，从左向右可以被看做是若干个单词形成的句子，相邻两个单词被一个或多个空白格子分割开来；也有可能是从右向左被看成是一个句子，竖直方向类似。\n\n遗憾的是，我们并不完全知道每一行每一列的阅读顺序是怎样的。但可以猜测，有些单词会满足反转过来也是一个单词。例如单词 `BOY`，翻转过来的 `YOB` 也是一个英文单词。\n\n此外观察者发现，对每一行（列）来说，按照确定后的阅读顺序读出的所有单词同时满足“自己的字典序不小于翻转后的字典序”，或同时满足“自己的字典序不大于翻转后的字典序”。\n\n在确定了所有行列的阅读顺序之后，我们可以构造出关于这种未知语言的字典。\n\n请问字典中出现的“翻转过来也是一个单词”的单词最少有多少种请注意，如果一个单词翻转后是不同的另外一个单词，它们需要被分别计入；而对于本身是回文的单词则不需要重复计入\n", "inputFormat": "第一行一个整数 $T$，表示 $T$ 组测试数据。\n\n对于每一组数据来说：第一行输入两个整数 $n,m$。\n\n第二行给出了 $n$ 个数字，对应 $n$ 行，其中若第 $i$ 个数字为 `1`，则表示第 $i$ 行的阅读顺序从左往右；若为 `-1` 则为从右向左；若为 `0` 则表示无法确定。\n\n第三行给出了 $m$ 个数字，对应 $n$ 行，其中若第 $i$ 个数字为 `1`，则表示第 $i$ 列的阅读顺序从上往下；若为 `-1` 则为从下向上；若为 `0` 则表示无法确定\n\n之后 $n$ 行，每行给出了长度为 $m$ 的字符串，由 `A` ~ `Z` 和下划线组成，对应了每个格子的符号，其中下划线表示格子为空。\n", "outputFormat": "输出 $T$ 行。每一组数据输出一行一个整数，表示最少有多少个单词，满足翻转后依然是单词。\n\n注意，如果一个单词是回文，那么它一定满足“翻转后依旧是单词”\n", "hint": "对于 $100\\%$ 的数据，$1\\leq n,m\\leq 72$，$T\\leq 64$。", "locale": "zh-CN"}}}
{"pid": "P4077", "type": "P", "difficulty": 6, "samples": [["6\n16 14\n1 0 0 1 0 0 0 0 1 0 0 0 1 0 1 1\n16 14\n0 1 0 0 0 1 1 1 1 1 1 0 1 0 0 1\n16 11\n0 1 0 0 0 1 1 1 0 1 0 0 0 1 0 1\n16 12\n1 1 1 1 1 1 1 1 0 0 1 1 0 1 1 0\n16 4\n1 0 0 1 0 0 1 0 0 0 0 1 0 1 1 0\n16 20\n0 0 0 0 1 0 1 0 0 0 1 0 0 1 0 0", "win\nlose\nwin\nlose\nwin\nwin"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "各省省选", "山东"], "title": "[SDOI2016] 硬币游戏", "background": "", "description": "Alice 和 Bob 现在在玩的游戏，主角是依次编号为 $1$ 到 $n$ 的 $n$ 枚硬币。每一枚硬币都有两面，我们分别称之为正面和反面。一开始的时候，有些硬币是正面向上的，有些是反面朝上的。Alice 和 Bob 将轮流对这些硬币进行翻转操作，且 Alice 总是先手。\n\n\n具体来说每次玩家可以选择一枚编号为 $x$，要求这枚硬币此刻是反面朝上的。对于编号 $x$ 来说，我们总可以将 $x$ 写成 $ c\\cdot 2^a \\cdot 3^b$ ，其中 $a$ 和 $b$ 是非负整数，$c$ 是与 $2,3$ 都互质的非负整数，然后有两种选择：\n\n\n选择整数 $p,q$ 满足 $a \\ge pq , p \\ge 1$ 且 $1 \\leq q \\leq \\text{MAXQ}$，然后同时翻转所有编号为 $c \\cdot 2^{a-pj} \\cdot 3^b$  的硬币，其中 $j = 0, 1, 2, \\ldots ,q$。\n\n选择整数 $p,q$ 满足 $b \\ge pq, p \\ge 1$  且 $1 \\leq q \\leq \\text{MAXQ}$，然后同时翻转所有编号为 $c \\cdot 2^a \\cdot 3^{b-pj}$ 的硬币，其中 $j = 0, 1, 2, \\ldots, q$。\n\n可以发现这个游戏不能无限进行下去，当某位玩家无法继续操作上述操作时，便输掉了游戏。作为先手的 Alice，总是希望可以在比赛开始之前就知道自己能否获胜。她知道自己和 Bob 都是充分聪明的，所以在游戏过程中，两人都会最优化自己的策略并尽量保证自己处于不败的情形中。\n", "inputFormat": "\n本题有多组测试数据，第一行输入一个整数 $T$，表示总的数据组数。之后给出 $T$ 组数据。\n\n每组数据第一行输入两个整数 $n,\\text{MAXQ}$。\n\n第二行输入 $n$ 个整数，第 $i$ 个数表示第 $i$ 个硬币的初始状态，$0$ 表示反面朝上，$1$ 表示正面朝上。", "outputFormat": "输出共有 $T$ 行。对于每一组数据来说，如果 Alice 先手必胜，则输出 `win`，否则输出 `lose`。\n", "hint": "对于 $100\\%$ 的数据 $1\\le n \\le 30000,1 \\le \\text{MAXQ} \\le 20,t\\le 100$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] Coin Game", "background": "", "description": "Alice and Bob are playing a game with $n$ coins numbered from $1$ to $n$. Each coin has two sides, called heads and tails. Initially, some coins are heads up and some are tails up. Alice and Bob alternate performing flip operations on these coins, and Alice always moves first.\n\nSpecifically, on each turn, the player may choose an index $x$ such that the coin $x$ is currently tails up. For the index $x$, we can always write $x = c \\cdot 2^a \\cdot 3^b$, where $a$ and $b$ are non-negative integers, and $c$ is a non-negative integer that is coprime to both $2$ and $3$. Then there are two choices:\n\n- Choose integers $p, q$ satisfying $a \\ge pq$, $p \\ge 1$, and $1 \\leq q \\leq \\text{MAXQ}$, then simultaneously flip all coins with indices $c \\cdot 2^{a - pj} \\cdot 3^b$, where $j = 0, 1, 2, \\ldots, q$.\n\n- Choose integers $p, q$ satisfying $b \\ge pq$, $p \\ge 1$, and $1 \\leq q \\leq \\text{MAXQ}$, then simultaneously flip all coins with indices $c \\cdot 2^a \\cdot 3^{b - pj}$, where $j = 0, 1, 2, \\ldots, q$.\n\nIt can be seen that the game cannot continue indefinitely. When a player cannot make a move as described above, they lose the game. As the first player, Alice wants to know beforehand whether she can win. She assumes that both she and Bob are perfectly rational, so during the game both will optimize their strategies and try to avoid losing.", "inputFormat": "There are multiple test cases. The first line contains an integer $T$, the number of test cases. Then $T$ test cases follow.\n\nFor each test case, the first line contains two integers $n, \\text{MAXQ}$.\n\nThe second line contains $n$ integers. The $i$-th number denotes the initial state of the $i$-th coin: $0$ means tails up, and $1$ means heads up.", "outputFormat": "Output $T$ lines. For each test case, if Alice has a winning strategy as the first player, print `win`; otherwise print `lose`.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 30000$, $1 \\le \\text{MAXQ} \\le 20$, $T \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 硬币游戏", "background": "", "description": "Alice 和 Bob 现在在玩的游戏，主角是依次编号为 $1$ 到 $n$ 的 $n$ 枚硬币。每一枚硬币都有两面，我们分别称之为正面和反面。一开始的时候，有些硬币是正面向上的，有些是反面朝上的。Alice 和 Bob 将轮流对这些硬币进行翻转操作，且 Alice 总是先手。\n\n\n具体来说每次玩家可以选择一枚编号为 $x$，要求这枚硬币此刻是反面朝上的。对于编号 $x$ 来说，我们总可以将 $x$ 写成 $ c\\cdot 2^a \\cdot 3^b$ ，其中 $a$ 和 $b$ 是非负整数，$c$ 是与 $2,3$ 都互质的非负整数，然后有两种选择：\n\n\n选择整数 $p,q$ 满足 $a \\ge pq , p \\ge 1$ 且 $1 \\leq q \\leq \\text{MAXQ}$，然后同时翻转所有编号为 $c \\cdot 2^{a-pj} \\cdot 3^b$  的硬币，其中 $j = 0, 1, 2, \\ldots ,q$。\n\n选择整数 $p,q$ 满足 $b \\ge pq, p \\ge 1$  且 $1 \\leq q \\leq \\text{MAXQ}$，然后同时翻转所有编号为 $c \\cdot 2^a \\cdot 3^{b-pj}$ 的硬币，其中 $j = 0, 1, 2, \\ldots, q$。\n\n可以发现这个游戏不能无限进行下去，当某位玩家无法继续操作上述操作时，便输掉了游戏。作为先手的 Alice，总是希望可以在比赛开始之前就知道自己能否获胜。她知道自己和 Bob 都是充分聪明的，所以在游戏过程中，两人都会最优化自己的策略并尽量保证自己处于不败的情形中。\n", "inputFormat": "\n本题有多组测试数据，第一行输入一个整数 $T$，表示总的数据组数。之后给出 $T$ 组数据。\n\n每组数据第一行输入两个整数 $n,\\text{MAXQ}$。\n\n第二行输入 $n$ 个整数，第 $i$ 个数表示第 $i$ 个硬币的初始状态，$0$ 表示反面朝上，$1$ 表示正面朝上。", "outputFormat": "输出共有 $T$ 行。对于每一组数据来说，如果 Alice 先手必胜，则输出 `win`，否则输出 `lose`。\n", "hint": "对于 $100\\%$ 的数据 $1\\le n \\le 30000,1 \\le \\text{MAXQ} \\le 20,t\\le 100$。\n", "locale": "zh-CN"}}}
{"pid": "P4078", "type": "P", "difficulty": 6, "samples": [["10 10\n+1 +1 +1 +1 +1 -1 -1 -1 -1 -1\n-1 -1 +1 +1 +1 -1 -1 -1 -1 -1\n-1 -1 +1 +1 +1 +1 +1 +1 +1 +1\n+1 +1 +1 +1 -1 -1 -1 -1 -1 +1\n+1 -1 -1 +1 -1 -1 -1 -1 -1 +1\n+1 +1 +1 +1 -1 -1 -1 -1 -1 +1\n+1 +1 +1 +1 +1 +1 +1 +1 +1 +1\n+1 -1 -1 -1 -1 -1 -1 -1 -1 -1\n+1 +1 +1 +1 -1 +1 +1 +1 +1 +1\n-1 -1 -1 +1 +1 +1 -1 -1 -1 +1", "53"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "各省省选", "山东"], "title": "[SDOI2016] 探险路线", "background": "", "description": "你所面对的丛林，可以被刻画为n行m列的格点图，其中第i行第j列的格子代表了一块区域，每个格子有整数权值v(i,j)（可能为负），表明了访问这一块区域的收益或代价。每一个格子最多只能被访问一次，且不可走出地图的边界，你被要求从第一行第一列出发，到第n行第m列结束，你的目标是最大化途经的所有格子的权值和。\n\n因为一些缘故，你的探险路线受到了一些限制。起初你在起点，之后每一天的行动中，首先你需要选择上下左右中的某一个方向，沿着这个方向走0步（也就是不走）或任意步；之后重新选择一个方向（可以与原来方向相同，也可以是不同的方向），沿着这个方向一直走下去，走到地图的某个边界位置结束这一天的探险。探险可以有任意多天，每一天探险结束的边界位置就是第二天的起点位置，除非这一天就是探险的结束。注意，因为每一块格子只能被访问一次，且你最终的结束点必须是第n行第m列的位置，所以你需要谨慎计划每一天的路线。\n\n你希望知道最优方案下，整个探险之旅的收益有多大，即你可以获得的权值和最大是多少。\n", "inputFormat": "第一行输入两个整数，分别表示总行数n与总列数m。之后n行，每行有m个整数，。其中第i行第j列的整数对应了访问第i行第j列区域的收益或代价。\n", "outputFormat": "输出一个整数，表示最优探险路线中所有被访问格子的权值和。\n", "hint": "对于所有数据3<=n<=800且3<=m<=800，保证收益代价绝对值在100000以内\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] Expedition Route", "background": "", "description": "The jungle you face can be modeled as a grid with $n$ rows and $m$ columns. The cell in row $i$ and column $j$ represents a region. Each cell has an integer weight $v(i,j)$ (possibly negative), representing the gain or cost of visiting that region. Each cell can be visited at most once, and you may not go outside the grid. You are required to start from the cell in the first row and first column, and finish at the cell in the $n$-th row and $m$-th column. Your goal is to maximize the sum of the weights of all visited cells.\n\nBecause of certain reasons, your expedition route is subject to some restrictions. Initially you are at the start. Then, on each day, you must first choose one direction among up, down, left, and right, and move $0$ steps (i.e., do not move) or any number of steps along this direction; after that, choose a direction again (it can be the same as before or different), and keep moving along that direction until you reach some boundary position of the grid, ending that day's expedition. The expedition can last for any number of days. The boundary position where a day's expedition ends will be the starting position of the next day, unless that day is the end of the expedition. Note that, because each cell can be visited at most once and your final ending point must be at position $(n,m)$, you need to plan each day's route carefully.\n\nYou want to know, under the optimal plan, how large the total gain of the entire expedition can be, that is, the maximum possible sum of the weights of all visited cells.", "inputFormat": "The first line contains two integers, representing the total number of rows $n$ and the total number of columns $m$. Then follow $n$ lines, each containing $m$ integers. The integer in row $i$ and column $j$ corresponds to the gain or cost of visiting the region at row $i$ and column $j$.", "outputFormat": "Output a single integer, the sum of the weights of all visited cells in an optimal expedition route.", "hint": "Constraints: For all testdata, $3 \\le n \\le 800$ and $3 \\le m \\le 800$. The absolute value of each gain or cost is at most $100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 探险路线", "background": "", "description": "你所面对的丛林，可以被刻画为n行m列的格点图，其中第i行第j列的格子代表了一块区域，每个格子有整数权值v(i,j)（可能为负），表明了访问这一块区域的收益或代价。每一个格子最多只能被访问一次，且不可走出地图的边界，你被要求从第一行第一列出发，到第n行第m列结束，你的目标是最大化途经的所有格子的权值和。\n\n因为一些缘故，你的探险路线受到了一些限制。起初你在起点，之后每一天的行动中，首先你需要选择上下左右中的某一个方向，沿着这个方向走0步（也就是不走）或任意步；之后重新选择一个方向（可以与原来方向相同，也可以是不同的方向），沿着这个方向一直走下去，走到地图的某个边界位置结束这一天的探险。探险可以有任意多天，每一天探险结束的边界位置就是第二天的起点位置，除非这一天就是探险的结束。注意，因为每一块格子只能被访问一次，且你最终的结束点必须是第n行第m列的位置，所以你需要谨慎计划每一天的路线。\n\n你希望知道最优方案下，整个探险之旅的收益有多大，即你可以获得的权值和最大是多少。\n", "inputFormat": "第一行输入两个整数，分别表示总行数n与总列数m。之后n行，每行有m个整数，。其中第i行第j列的整数对应了访问第i行第j列区域的收益或代价。\n", "outputFormat": "输出一个整数，表示最优探险路线中所有被访问格子的权值和。\n", "hint": "对于所有数据3<=n<=800且3<=m<=800，保证收益代价绝对值在100000以内\n", "locale": "zh-CN"}}}
{"pid": "P4079", "type": "P", "difficulty": 5, "samples": [["2\n3 3\n1 2 3 5\n2 3 5 -7\n1 3 3 -7\n3 3\n1 2 3 5\n2 3 5 -7\n1 3 3 7", "Case #1: Yes\nCase #2: No"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2016", "并查集", "各省省选", "山东", "逆元"], "title": "[SDOI2016] 齿轮", "background": null, "description": "现有一个传动系统，包含了 $N$ 个组合齿轮和 $M$ 个链条。每一个链条连接了两个组合齿轮 $u$ 和 $v$，并提供了一个传动比 $x:y$，即如果只考虑这两个组合齿轮，编号为 $u$ 的齿轮转动 $x$ 圈，编号为 $v$ 的齿轮会转动 $y$ 圈。传动比为正表示若编号为 $u$ 的齿轮顺时针转动，则编号为 $v$ 的齿轮也顺时针转动。传动比为负表示若编号为 $u$ 的齿轮顺时针转动，则编号为 $v$ 的齿轮会逆时针转动。若不同链条的传动比不相容，则有些齿轮无法转动。我们希望知道，系统中的这 $N$ 个组合齿轮能否同时转动。\n\n**这个传动系统可能不连通。** 也就是说，不保证任意两个齿轮都被链条直接或间接地连接。", "inputFormat": "有多组数据。\n\n第一行给定整数 $T$，表示总的数据组数，之后依次给出 $T$ 组数据。\n\n每一组数据的第一行给定整数 $N$ 和 $M$，表示齿轮总数和链条总数。\n\n之后有 $M$ 行，依次描述了每一个链条，其中每一行给定四个整数 $u,v,x,y$，表示只考虑这一组联动关系的情况下，编号为 $u$ 的齿轮转动 $x$ 圈，编号为 $v$ 的齿轮会转动 $y$ 圈。保证 $x$ 为正整数，而 $y$ 为非零整数。**请注意 $y$ 有可能为负数。**", "outputFormat": "输出 $T$ 行，每行对应一组数据。首先应该输出标识这是第几组数据，参见样例输出。之后输出判定结果，如果 $N$ 个组合齿轮可以同时正常运行，则输出 `Yes`，否则输出 `No`。", "hint": "### 数据范围\n\n* $1\\leq T\\leq 32$；\n* $1\\leq N\\leq 1000$；\n* $1\\leq M\\leq 10^4$；\n* $1\\leq x,|y|\\leq 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] Gears", "background": "", "description": "There is a transmission system consisting of $N$ compound gears and $M$ chains. Each chain connects two compound gears $u$ and $v$, and provides a transmission ratio $x:y$, meaning that if we consider only these two gears, when gear $u$ turns $x$ turns, gear $v$ will turn $y$ turns. A positive ratio means that if gear $u$ turns clockwise, then gear $v$ also turns clockwise. A negative ratio means that if gear $u$ turns clockwise, then gear $v$ turns counterclockwise. If the transmission ratios provided by different chains are incompatible, some gears cannot turn. We want to know whether all $N$ compound gears in the system can rotate simultaneously.\n\n**This transmission system might be disconnected.** That is, it is not guaranteed that any two gears are connected directly or indirectly by chains.", "inputFormat": "There are multiple test cases.\n\nThe first line contains an integer $T$, the total number of test cases, followed by $T$ test cases.\n\nFor each test case, the first line contains two integers $N$ and $M$, the number of gears and the number of chains.\n\nThen there are $M$ lines, each describing one chain. Each line contains four integers $u, v, x, y$, meaning that, considering only this linkage, when gear $u$ turns $x$ turns, gear $v$ will turn $y$ turns. It is guaranteed that $x$ is a positive integer and $y$ is a nonzero integer. **Note that $y$ can be negative.**", "outputFormat": "Output $T$ lines, one for each test case. First, output an identifier indicating the test case index, as shown in the sample output. Then output the decision: if all $N$ compound gears can run simultaneously, output `Yes`; otherwise, output `No`.", "hint": "Constraints\n\n- $1\\leq T\\leq 32$.\n- $1\\leq N\\leq 1000$.\n- $1\\leq M\\leq 10^4$.\n- $1\\leq x,|y|\\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 齿轮", "background": null, "description": "现有一个传动系统，包含了 $N$ 个组合齿轮和 $M$ 个链条。每一个链条连接了两个组合齿轮 $u$ 和 $v$，并提供了一个传动比 $x:y$，即如果只考虑这两个组合齿轮，编号为 $u$ 的齿轮转动 $x$ 圈，编号为 $v$ 的齿轮会转动 $y$ 圈。传动比为正表示若编号为 $u$ 的齿轮顺时针转动，则编号为 $v$ 的齿轮也顺时针转动。传动比为负表示若编号为 $u$ 的齿轮顺时针转动，则编号为 $v$ 的齿轮会逆时针转动。若不同链条的传动比不相容，则有些齿轮无法转动。我们希望知道，系统中的这 $N$ 个组合齿轮能否同时转动。\n\n**这个传动系统可能不连通。** 也就是说，不保证任意两个齿轮都被链条直接或间接地连接。", "inputFormat": "有多组数据。\n\n第一行给定整数 $T$，表示总的数据组数，之后依次给出 $T$ 组数据。\n\n每一组数据的第一行给定整数 $N$ 和 $M$，表示齿轮总数和链条总数。\n\n之后有 $M$ 行，依次描述了每一个链条，其中每一行给定四个整数 $u,v,x,y$，表示只考虑这一组联动关系的情况下，编号为 $u$ 的齿轮转动 $x$ 圈，编号为 $v$ 的齿轮会转动 $y$ 圈。保证 $x$ 为正整数，而 $y$ 为非零整数。**请注意 $y$ 有可能为负数。**", "outputFormat": "输出 $T$ 行，每行对应一组数据。首先应该输出标识这是第几组数据，参见样例输出。之后输出判定结果，如果 $N$ 个组合齿轮可以同时正常运行，则输出 `Yes`，否则输出 `No`。", "hint": "### 数据范围\n\n* $1\\leq T\\leq 32$；\n* $1\\leq N\\leq 1000$；\n* $1\\leq M\\leq 10^4$；\n* $1\\leq x,|y|\\leq 100$。", "locale": "zh-CN"}}}
{"pid": "P4080", "type": "P", "difficulty": 7, "samples": [["8 6\n1 0 0\n1 1 0\n1 0 1\n1 1 1\n0 0 0\n0 1 0\n0 0 1\n0 1 1\n4 1 2 4 3\n4 2 6 8 4\n4 6 5 7 8\n4 5 1 3 7\n4 3 4 8 7\n4 1 5 6 2", "0.1666667\n0.1666667\n0.1666667\n0.1666667\n0.1666667\n0.1666667"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "各省省选", "山东", "向量"], "title": "[SDOI2016] 平凡的骰子", "background": "", "description": "这是一枚平凡的骰子。它是一个均质凸多面体，表面有n个端点，有f个面，每一面是一个凸多边形，且任意两面不共面。将这枚骰子抛向空中，骰子落地的时候不会发生二次弹跳（这是一种非常理想的情况）。\n\n你希望知道最终每一面着地的概率。每一面着地的概率可以用如下的方法计算：我们假设O为骰子的重心，并以O为球心，做半径为1的单位球面（记为S）。\n\n我们知道S的表面积即单位球的表面积，为4\\*pi，这里pi为圆周率。对于骰子的某一面C来说，球面S上存在一块区域T满足：当下落时若骰子所受重力方向与S的交点落在T中，则C就是最终着地的一面。那么C着地的概率为区域T的面积除以4\\*pi。\n\n为了能更好地辅助计算球面上一块区域的面积，我们给出单位球面S上三角形的面积计算公式。考虑单位球面S上的三个两两相交的大圆，交点依次为A，B和C。则曲面三角形ABC的面积为 $\\text{Area}(ABC)=\\alpha+\\beta+\\gamma-\\pi$，其中 $\\alpha,\\beta , \\gamma$ 分别对应了三个二面角的大小。如下图所示。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12756.png) \n\n我们保证：每一面着地的时候，重心的垂心都恰好在这一面内。也就是说不会出现摆不稳的情况。\n", "inputFormat": "第一行输入两个整数，分别表示端点总数n与表面总数f，分别从1开始编号。\n\n之后n行，每行有三个浮点数x，y和z，给出了每一个端点的坐标。\n\n之后f行依次描述了每一块表面，首先给出不小于3的整数d，表示这一面的端点个数，之后d个整数按照逆时针方向（视角在骰子的外面）给出了每一个端点的编号。\n", "outputFormat": "输出f行，第i行有一个浮点数，表示第i个面着地的概率。本题中您的输出应该保留距离答案最近的7位小数，即在需要保留7位小数的前提之下与标准答案最接近。数据保证可以避免对小数点后第八位四舍五入后产生的精度误差\n", "hint": "对于所有数据，4<=n<=50且4<=m<=50，所有坐标的绝对值都在10000以内\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2016] Ordinary Die", "background": "# Description\n\nThis is an ordinary die. It is a homogeneous convex polyhedron with $n$ vertices and $f$ faces. Each face is a convex polygon, and any two faces are not coplanar. When the die is thrown into the air, it will not bounce a second time upon landing (an idealized assumption).\n\nYou want to know the probability that each face ends up on the ground. The probability for each face can be computed as follows: let $O$ be the center of mass of the die, and let $S$ be the unit sphere of radius $1$ centered at $O$.\n\nThe surface area of $S$ is the surface area of the unit sphere, namely $4\\pi$, where $\\pi$ is the circle constant. For a face $C$ of the die, there exists a region $T$ on the sphere $S$ such that: when the die falls, if the direction of gravity intersects $S$ at a point within $T$, then $C$ is the face that ultimately lands on the ground. Therefore, the probability that $C$ lands is the area of region $T$ divided by $4\\pi$.\n\nTo better assist in computing areas of regions on the sphere, we provide the area formula for a spherical triangle on the unit sphere $S$. Consider three pairwise intersecting great circles on $S$, with intersection points $A$, $B$, and $C$ in order. Then the area of the spherical triangle $ABC$ is $\\text{Area}(ABC)=\\alpha+\\beta+\\gamma-\\pi$, where $\\alpha,\\beta , \\gamma$ are the three angles. See the figure below.\n\n![](https://cdn.luogu.com.cn/upload/pic/12756.png)\n\nWe guarantee that whenever a face lands on the ground, the orthogonal projection of the center of mass onto that face lies strictly inside the face. In other words, the die will not wobble unstably.", "description": "This is an ordinary die. It is a homogeneous convex polyhedron with $n$ vertices and $f$ faces. Each face is a convex polygon, and any two faces are not coplanar. When the die is thrown into the air, it will not bounce a second time upon landing (an idealized assumption).\n\nYou want to know the probability that each face ends up on the ground. The probability for each face can be computed as follows: let $O$ be the center of mass of the die, and let $S$ be the unit sphere of radius $1$ centered at $O$.\n\nThe surface area of $S$ is the surface area of the unit sphere, namely $4\\pi$, where $\\pi$ is the circle constant. For a face $C$ of the die, there exists a region $T$ on the sphere $S$ such that: when the die falls, if the direction of gravity intersects $S$ at a point within $T$, then $C$ is the face that ultimately lands on the ground. Therefore, the probability that $C$ lands is the area of region $T$ divided by $4\\pi$.\n\nTo better assist in computing areas of regions on the sphere, we provide the area formula for a spherical triangle on the unit sphere $S$. Consider three pairwise intersecting great circles on $S$, with intersection points $A$, $B$, and $C$ in order. Then the area of the spherical triangle $ABC$ is $\\text{Area}(ABC)=\\alpha+\\beta+\\gamma-\\pi$, where $\\alpha,\\beta , \\gamma$ are the three angles. See the figure below.\n\n![](https://cdn.luogu.com.cn/upload/pic/12756.png)\n\nWe guarantee that whenever a face lands on the ground, the orthogonal projection of the center of mass onto that face lies strictly inside the face. In other words, the die will not wobble unstably.\n\n# Description", "inputFormat": "The first line contains two integers, the total number of vertices $n$ and the total number of faces $f$. Vertex indices are $1$-indexed.\n\nThe next $n$ lines each contain three floating-point numbers $x$, $y$, and $z$, giving the coordinates of each vertex.\n\nThe next $f$ lines each describe one face. Each line begins with an integer $d \\ge 3$ indicating the number of vertices on that face, followed by $d$ integers giving, in counterclockwise order as seen from outside the die, the indices of the vertices.", "outputFormat": "Output $f$ lines. The $i$-th line contains a floating-point number, which is the probability that the $i$-th face lands on the ground. Your output should keep 7 digits after the decimal and be the value closest to the reference answer under the constraint of keeping 7 decimal places. The testdata guarantees that there is no precision ambiguity caused by rounding at the 8th decimal place.", "hint": "Constraints:\n- For all testdata, $4 \\le n \\le 50$ and $4 \\le f \\le 50$.\n- The absolute value of each coordinate is at most $10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2016] 平凡的骰子", "background": "", "description": "这是一枚平凡的骰子。它是一个均质凸多面体，表面有n个端点，有f个面，每一面是一个凸多边形，且任意两面不共面。将这枚骰子抛向空中，骰子落地的时候不会发生二次弹跳（这是一种非常理想的情况）。\n\n你希望知道最终每一面着地的概率。每一面着地的概率可以用如下的方法计算：我们假设O为骰子的重心，并以O为球心，做半径为1的单位球面（记为S）。\n\n我们知道S的表面积即单位球的表面积，为4\\*pi，这里pi为圆周率。对于骰子的某一面C来说，球面S上存在一块区域T满足：当下落时若骰子所受重力方向与S的交点落在T中，则C就是最终着地的一面。那么C着地的概率为区域T的面积除以4\\*pi。\n\n为了能更好地辅助计算球面上一块区域的面积，我们给出单位球面S上三角形的面积计算公式。考虑单位球面S上的三个两两相交的大圆，交点依次为A，B和C。则曲面三角形ABC的面积为 $\\text{Area}(ABC)=\\alpha+\\beta+\\gamma-\\pi$，其中 $\\alpha,\\beta , \\gamma$ 分别对应了三个二面角的大小。如下图所示。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12756.png) \n\n我们保证：每一面着地的时候，重心的垂心都恰好在这一面内。也就是说不会出现摆不稳的情况。\n", "inputFormat": "第一行输入两个整数，分别表示端点总数n与表面总数f，分别从1开始编号。\n\n之后n行，每行有三个浮点数x，y和z，给出了每一个端点的坐标。\n\n之后f行依次描述了每一块表面，首先给出不小于3的整数d，表示这一面的端点个数，之后d个整数按照逆时针方向（视角在骰子的外面）给出了每一个端点的编号。\n", "outputFormat": "输出f行，第i行有一个浮点数，表示第i个面着地的概率。本题中您的输出应该保留距离答案最近的7位小数，即在需要保留7位小数的前提之下与标准答案最接近。数据保证可以避免对小数点后第八位四舍五入后产生的精度误差\n", "hint": "对于所有数据，4<=n<=50且4<=m<=50，所有坐标的绝对值都在10000以内\n", "locale": "zh-CN"}}}
{"pid": "P4081", "type": "P", "difficulty": 6, "samples": [["3\namy\ntommy\nbessie", "3\n11\n19"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2017", "USACO", "后缀自动机 SAM", "后缀数组 SA"], "title": "[USACO17DEC] Standing Out from the Herd P", "background": "", "description": "Just like humans, cows often appreciate feeling they are unique in some way. Since Farmer John's cows all come from the same breed and look quite similar, they want to measure uniqueness in their names.\n\nEach cow's name has some number of substrings. For example, \"amy\" has substrings {a, m, y, am, my, amy}, and \"tommy\" would have the following substrings: {t, o, m, y, to, om, mm, my, tom, omm, mmy, tomm, ommy, tommy}.\n\nA cow name has a \"uniqueness factor\" which is the number of substrings of that name not shared with any other cow. For example, If amy was in a herd by herself, her uniqueness factor would be 6. If tommy was in a herd by himself, his uniqueness factor would be 14. If they were in a herd together, however, amy's uniqueness factor would be 3 and tommy's would be 11.\n\nGiven a herd of cows, please determine each cow's uniqueness factor.", "inputFormat": "The first line of input will contain $N$ ($1 \\le N \\le 10^5$). The following $N$ lines will each contain the name of a cow in the herd. Each name will contain only lowercase characters a-z. The total length of all names will not exceed $10^5$.\n", "outputFormat": "Output $N$ numbers, one per line, describing the uniqueness factor of each cow.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17DEC] Standing Out from the Herd P", "background": "", "description": "Just like humans, cows often appreciate feeling they are unique in some way. Since Farmer John's cows all come from the same breed and look quite similar, they want to measure uniqueness in their names.\n\nEach cow's name has some number of substrings. For example, \"amy\" has substrings {a, m, y, am, my, amy}, and \"tommy\" would have the following substrings: {t, o, m, y, to, om, mm, my, tom, omm, mmy, tomm, ommy, tommy}.\n\nA cow name has a \"uniqueness factor\" which is the number of substrings of that name not shared with any other cow. For example, If amy was in a herd by herself, her uniqueness factor would be 6. If tommy was in a herd by himself, his uniqueness factor would be 14. If they were in a herd together, however, amy's uniqueness factor would be 3 and tommy's would be 11.\n\nGiven a herd of cows, please determine each cow's uniqueness factor.", "inputFormat": "The first line of input will contain $N$ ($1 \\le N \\le 10^5$). The following $N$ lines will each contain the name of a cow in the herd. Each name will contain only lowercase characters a-z. The total length of all names will not exceed $10^5$.\n", "outputFormat": "Output $N$ numbers, one per line, describing the uniqueness factor of each cow.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17DEC] Standing Out from the Herd P", "background": "", "description": "就像人类一样，奶牛也常常希望在某些方面感到自己与众不同。由于 Farmer John 的奶牛都来自同一品种且外观非常相似，它们希望通过名字来衡量独特性。\n\n每头奶牛的名字都有一些子字符串。例如，\"amy\" 的子字符串为 {a, m, y, am, my, amy}，而 \"tommy\" 的子字符串为 {t, o, m, y, to, om, mm, my, tom, omm, mmy, tomm, ommy, tommy}。\n\n一头奶牛的名字有一个“独特性因子”，即该名字中不与任何其他奶牛共享的子字符串的数量。例如，如果 amy 独自在一个牛群中，她的独特性因子为 6。如果 tommy 独自在一个牛群中，他的独特性因子为 14。然而，如果它们在一个牛群中，amy 的独特性因子为 3，而 tommy 的独特性因子为 11。\n\n给定一个牛群，请计算每头奶牛的独特性因子。", "inputFormat": "输入的第一行包含 $N$（$1 \\le N \\le 10^5$）。接下来的 $N$ 行每行包含牛群中一头奶牛的名字。每个名字仅包含小写字母 a-z。所有名字的总长度不超过 $10^5$。", "outputFormat": "输出 $N$ 个数字，每行一个，表示每头奶牛的独特性因子。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4082", "type": "P", "difficulty": 7, "samples": [["5 5 4\n##.##\n##.##\nA.B..\n##.##\n##.##\n3 2\n3 5\n1 3\n5 3", "NO\nYES\nNO\nNO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "USACO", "广度优先搜索 BFS", "深度优先搜索 DFS"], "title": "[USACO17DEC] Push a Box P", "background": null, "description": "**题目译自 [USACO 2017 December Contest, Platinum](http://usaco.org/index.php?page=dec17results) Problem 2. [Push a Box](http://usaco.org/index.php?page=viewproblem2&cpid=769)**\n\n一个谷仓是一个 $N \\times M$ 的矩形网格，有一些网格里有干草。 Bessie 站在其中一个格子内，还有一个格子里有一个大木箱。 Bessie 不能和大木箱在一个格子里，也不能和干草在一个格子里。\n\n如果她不与干草在同一个格子，她就可以往自己旁边的四个方向（东西南北）移动，如果她想移动到有木箱的格子里，那个木箱就会被她推一格（只要木箱的那个方向还有空间），如果没有空间，那 Bessie 就不能移动了。\n\n给你谷仓的布局（空格子，干草以及木箱位置）以及 Bessie 的出发位置和箱子要被推到的位置，请你帮忙计算 Bessie 能不能把木箱推到指定位置。", "inputFormat": "第一行有三个数 $N,M,Q$，其中 $N$ 是谷仓的行数，$M$ 是列数，$Q$ 是询问数。\n\n接下来 $N$ 行是谷仓的初始布局，其中 `.` 代表空格子， `#` 代表干草格子， `A` 代表 Bessie 的初始位置， `B` 是木箱的初始位置。\n\n接下来 $Q$ 行，每行一个坐标 $(R,C)$ ，代表第 $R$ 行第 $C$ 列。对于每行，你要输出 Bessie 是否有可能把箱子推到这个位置。", "outputFormat": "$Q$ 行，每行一个答案，如果 Bessie 能走到，输出 `YES` ，否则输出 `NO` 。", "hint": "对于 $100\\%$ 的数据，保证 $1\\leq N,M \\leq 1500$，$1\\leq Q\\leq 50000$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO17DEC] Push a Box P", "background": "", "description": "Translated from [USACO 2017 December Contest, Platinum](http://usaco.org/index.php?page=dec17results) Problem 2: [Push a Box](http://usaco.org/index.php?page=viewproblem2&cpid=769).\n\nA barn is an $N \\times M$ rectangular grid, and some cells contain hay bales. Bessie stands in one cell, and a large crate occupies another cell. Bessie cannot be in the same cell as the crate, nor in the same cell as a hay bale.\n\nFrom any empty cell, she may move to any of its four orthogonally adjacent cells (north, south, east, west). If she attempts to move into the cell containing the crate, the crate is pushed one cell further in the same direction, provided the next cell in that direction is within bounds and empty (i.e., not a hay bale or outside the grid); otherwise, the move is not allowed. After a successful push, Bessie occupies the crate’s previous cell.\n\nGiven the barn layout (empty cells, hay bales, and the crate), along with Bessie’s starting position and the target positions for the crate, determine whether Bessie can push the crate to each specified target cell.", "inputFormat": "The first line contains three integers $N, M, Q$, where $N$ is the number of rows, $M$ is the number of columns, and $Q$ is the number of queries.\n\nThe next $N$ lines describe the initial layout of the barn, where `.` denotes an empty cell, `#` denotes a hay bale, `A` denotes Bessie’s initial position, and `B` denotes the crate’s initial position.\n\nThe next $Q$ lines each contain a coordinate $(R, C)$, representing row $R$ and column $C$. For each line, determine whether Bessie can push the crate to this cell.", "outputFormat": "Output $Q$ lines. For each query, print `YES` if Bessie can push the crate to the specified cell; otherwise, print `NO`.", "hint": "For $100\\%$ of the testdata, it is guaranteed that $1 \\leq N, M \\leq 1500$ and $1 \\leq Q \\leq 50000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO17DEC] Push a Box P", "background": null, "description": "**题目译自 [USACO 2017 December Contest, Platinum](http://usaco.org/index.php?page=dec17results) Problem 2. [Push a Box](http://usaco.org/index.php?page=viewproblem2&cpid=769)**\n\n一个谷仓是一个 $N \\times M$ 的矩形网格，有一些网格里有干草。 Bessie 站在其中一个格子内，还有一个格子里有一个大木箱。 Bessie 不能和大木箱在一个格子里，也不能和干草在一个格子里。\n\n如果她不与干草在同一个格子，她就可以往自己旁边的四个方向（东西南北）移动，如果她想移动到有木箱的格子里，那个木箱就会被她推一格（只要木箱的那个方向还有空间），如果没有空间，那 Bessie 就不能移动了。\n\n给你谷仓的布局（空格子，干草以及木箱位置）以及 Bessie 的出发位置和箱子要被推到的位置，请你帮忙计算 Bessie 能不能把木箱推到指定位置。", "inputFormat": "第一行有三个数 $N,M,Q$，其中 $N$ 是谷仓的行数，$M$ 是列数，$Q$ 是询问数。\n\n接下来 $N$ 行是谷仓的初始布局，其中 `.` 代表空格子， `#` 代表干草格子， `A` 代表 Bessie 的初始位置， `B` 是木箱的初始位置。\n\n接下来 $Q$ 行，每行一个坐标 $(R,C)$ ，代表第 $R$ 行第 $C$ 列。对于每行，你要输出 Bessie 是否有可能把箱子推到这个位置。", "outputFormat": "$Q$ 行，每行一个答案，如果 Bessie 能走到，输出 `YES` ，否则输出 `NO` 。", "hint": "对于 $100\\%$ 的数据，保证 $1\\leq N,M \\leq 1500$，$1\\leq Q\\leq 50000$。", "locale": "zh-CN"}}}
{"pid": "P4083", "type": "P", "difficulty": 6, "samples": [["2 1\n1 1\n5 0\n4 2\n1 4", "3\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "二分", "USACO", "并查集", "图论建模", "最短路"], "title": "[USACO17DEC] A Pie for a Pie G", "background": "", "description": "Bessie and Elsie have each baked $N$ pies ($1 \\leq N \\leq 10^5$). Each of the $2N$ pies has a tastiness value according to Bessie and a (possibly different) tastiness value according to Elsie.\n\nBessie is thinking about giving one of her pies to Elsie. If Elsie receives a pie from Bessie, she will feel obligated to give one of her pies to Bessie. So as to not appear stingy nor flamboyant, Elsie will try to pick a pie that is at least as tasty (in Elsie's eyes) as the pie she received, but no more than $D$ units tastier ($0 \\leq D \\leq 10^9$). Such a pie may not exist, in which case Elsie will adopt a pseudonym and exile herself to Japan.\n\n\nBut if Elsie does give Bessie a pie in return, Bessie will similarly try to give Elsie a pie which is at least as tasty but no more than $D$ units tastier (in Bessie's eyes) as the pie Elsie just gave her. Should this be impossible, Bessie too will exile herself. Otherwise she will give her chosen pie to Elsie. This cycle will continue until one of the cows is exiled, an unhappy outcome, or one of the cows receives a pie which she accords a tastiness value of $0$, in which case the gift exchange will end and both cows will be happy.\n\n\nNote that a pie may not be gifted twice, nor can either cow return a pie gifted to her.\n\n\nFor each of the $N$ pies Bessie could select as her initial gift to Elsie, determine the minimum number of pies that could possibly be gifted in the resulting exchange before the cows are happy.\n", "inputFormat": "The first line contains the two integers $N$ and $D$.\n\nThe next $2N$ lines contain two space-separated integers each, respectively denoting the value of a particular pie according to Bessie, and the value of that pie according to Elsie.\n\n\nThe first $N$ lines refer to Bessie's pies, and the remaining $N$ lines refer to Elsie's pies.\n\n\nIt is guaranteed that all tastiness values are in the range $[0,10^9]$.\n", "outputFormat": "There should be $N$ lines in the output. Line $i$ should contain a single integer: the minimum number of pies that could be gifted in a happy gift exchange started with Bessie's pie $i$. If no gift exchange starting with pie $i$ is happy, then line $i$ should contain the single integer $-1$ instead.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17DEC] A Pie for a Pie G", "background": "", "description": "Bessie and Elsie have each baked $N$ pies ($1 \\leq N \\leq 10^5$). Each of the $2N$ pies has a tastiness value according to Bessie and a (possibly different) tastiness value according to Elsie.\n\nBessie is thinking about giving one of her pies to Elsie. If Elsie receives a pie from Bessie, she will feel obligated to give one of her pies to Bessie. So as to not appear stingy nor flamboyant, Elsie will try to pick a pie that is at least as tasty (in Elsie's eyes) as the pie she received, but no more than $D$ units tastier ($0 \\leq D \\leq 10^9$). Such a pie may not exist, in which case Elsie will adopt a pseudonym and exile herself to Japan.\n\n\nBut if Elsie does give Bessie a pie in return, Bessie will similarly try to give Elsie a pie which is at least as tasty but no more than $D$ units tastier (in Bessie's eyes) as the pie Elsie just gave her. Should this be impossible, Bessie too will exile herself. Otherwise she will give her chosen pie to Elsie. This cycle will continue until one of the cows is exiled, an unhappy outcome, or one of the cows receives a pie which she accords a tastiness value of $0$, in which case the gift exchange will end and both cows will be happy.\n\n\nNote that a pie may not be gifted twice, nor can either cow return a pie gifted to her.\n\n\nFor each of the $N$ pies Bessie could select as her initial gift to Elsie, determine the minimum number of pies that could possibly be gifted in the resulting exchange before the cows are happy.\n", "inputFormat": "The first line contains the two integers $N$ and $D$.\n\nThe next $2N$ lines contain two space-separated integers each, respectively denoting the value of a particular pie according to Bessie, and the value of that pie according to Elsie.\n\n\nThe first $N$ lines refer to Bessie's pies, and the remaining $N$ lines refer to Elsie's pies.\n\n\nIt is guaranteed that all tastiness values are in the range $[0,10^9]$.\n", "outputFormat": "There should be $N$ lines in the output. Line $i$ should contain a single integer: the minimum number of pies that could be gifted in a happy gift exchange started with Bessie's pie $i$. If no gift exchange starting with pie $i$ is happy, then line $i$ should contain the single integer $-1$ instead.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17DEC] A Pie for a Pie G", "background": "", "description": "Bessie 和 Elsie 各自烤了 $N$ 个派（$1 \\leq N \\leq 10^5$）。这 $2N$ 个派中的每一个都有一个由 Bessie 评定的美味值和一个（可能不同的）由 Elsie 评定的美味值。\n\nBessie 正在考虑将她的一只派送给 Elsie。如果 Elsie 收到了 Bessie 的派，她会觉得有义务回赠 Bessie 一只派。为了既不显得吝啬也不显得炫耀，Elsie 会尝试选择一只在她看来至少与收到的派一样美味，但不超过 $D$ 单位更美味的派（$0 \\leq D \\leq 10^9$）。如果这样的派不存在，Elsie 将采用一个化名并自我流放到日本。\n\n但如果 Elsie 确实回赠了 Bessie 一只派，Bessie 也会类似地尝试送给 Elsie 一只在她看来至少与 Elsie 刚送给她的派一样美味，但不超过 $D$ 单位更美味的派。如果这不可能，Bessie 也会自我流放。否则，她会将她选择的派送给 Elsie。这个循环将继续，直到其中一头奶牛被流放（一个不愉快的结果），或者其中一头奶牛收到一只她评定美味值为 $0$ 的派，在这种情况下，礼物交换将结束，两头奶牛都会感到高兴。\n\n请注意，一只派不能被赠送两次，任何一头奶牛也不能回赠她收到的派。\n\n对于 Bessie 可以选择作为初始礼物送给 Elsie 的每一只派，确定在奶牛们感到高兴之前，可能被赠送的派的最小数量。", "inputFormat": "第一行包含两个整数 $N$ 和 $D$。\n\n接下来的 $2N$ 行每行包含两个用空格分隔的整数，分别表示某只派由 Bessie 评定的美味值和由 Elsie 评定的美味值。\n\n前 $N$ 行描述 Bessie 的派，剩下的 $N$ 行描述 Elsie 的派。\n\n保证所有美味值都在 $[0,10^9]$ 范围内。", "outputFormat": "输出应包含 $N$ 行。第 $i$ 行应包含一个整数：如果以 Bessie 的第 $i$ 只派开始的礼物交换是高兴的，则输出可能被赠送的派的最小数量；否则输出 $-1$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4084", "type": "P", "difficulty": 4, "samples": [["4 1\n1 2\n1 3\n1 4\n4 3", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2017", "USACO", "树形 DP"], "title": "[USACO17DEC] Barn Painting G", "background": "", "description": "Farmer John has a large farm with $N$ barns ($1 \\le N \\le 10^5$), some of which are already painted and some not yet painted. Farmer John wants to paint these remaining barns so that all the barns are painted, but he only has three paint colors available. Moreover, his prize cow Bessie becomes confused if two barns that are directly reachable from one another are the same color, so he wants to make sure this situation does not happen.\n\nIt is guaranteed that the connections between the $N$ barns do not form any 'cycles'. That is, between any two barns, there is at most one sequence of connections that will lead from one to the other.\n\n\nHow many ways can Farmer John paint the remaining yet-uncolored barns?\n", "inputFormat": "The first line contains two integers $N$ and $K$ ($0 \\le K \\le N$), respectively the number of barns on the farm and the number of barns that have already been painted.\n\n\nThe next $N-1$ lines each contain two integers $x$ and $y$ ($1 \\le x, y \\le N, x \\neq y$) describing a path directly connecting barns $x$ and $y$.\n\n\nThe next $K$ lines each contain two integers $b$ and $c$ ($1 \\le b \\le N$, $1 \\le c \\le 3$) indicating that barn $b$ is painted with color $c$.\n", "outputFormat": "Compute the number of valid ways to paint the remaining barns, modulo $10^9 + 7$, such that no two barns which are directly connected are the same color.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17DEC] Barn Painting G", "background": "", "description": "Farmer John has a large farm with $N$ barns ($1 \\le N \\le 10^5$), some of which are already painted and some not yet painted. Farmer John wants to paint these remaining barns so that all the barns are painted, but he only has three paint colors available. Moreover, his prize cow Bessie becomes confused if two barns that are directly reachable from one another are the same color, so he wants to make sure this situation does not happen.\n\nIt is guaranteed that the connections between the $N$ barns do not form any 'cycles'. That is, between any two barns, there is at most one sequence of connections that will lead from one to the other.\n\n\nHow many ways can Farmer John paint the remaining yet-uncolored barns?\n", "inputFormat": "The first line contains two integers $N$ and $K$ ($0 \\le K \\le N$), respectively the number of barns on the farm and the number of barns that have already been painted.\n\n\nThe next $N-1$ lines each contain two integers $x$ and $y$ ($1 \\le x, y \\le N, x \\neq y$) describing a path directly connecting barns $x$ and $y$.\n\n\nThe next $K$ lines each contain two integers $b$ and $c$ ($1 \\le b \\le N$, $1 \\le c \\le 3$) indicating that barn $b$ is painted with color $c$.\n", "outputFormat": "Compute the number of valid ways to paint the remaining barns, modulo $10^9 + 7$, such that no two barns which are directly connected are the same color.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17DEC] Barn Painting G", "background": "", "description": "Farmer John 有一个大农场，农场上有 $N$ 个谷仓（$1 \\le N \\le 10^5$），其中一些已经涂色，另一些尚未涂色。Farmer John 想要为这些剩余的谷仓涂色，使得所有谷仓都被涂色，但他只有三种可用的油漆颜色。此外，他的获奖奶牛 Bessie 如果发现两个直接相连的谷仓颜色相同，会感到困惑，因此他希望确保这种情况不会发生。\n\n保证 $N$ 个谷仓之间的连接不会形成任何“环”。也就是说，任意两个谷仓之间最多只有一条连接路径。\n\nFarmer John 有多少种方式可以为剩余的未涂色谷仓涂色？", "inputFormat": "第一行包含两个整数 $N$ 和 $K$（$0 \\le K \\le N$），分别表示农场上的谷仓数量和已经涂色的谷仓数量。\n\n接下来的 $N-1$ 行每行包含两个整数 $x$ 和 $y$（$1 \\le x, y \\le N, x \\neq y$），描述直接连接谷仓 $x$ 和 $y$ 的路径。\n\n接下来的 $K$ 行每行包含两个整数 $b$ 和 $c$（$1 \\le b \\le N$, $1 \\le c \\le 3$），表示谷仓 $b$ 已经被涂成颜色 $c$。", "outputFormat": "计算为剩余谷仓涂色的有效方式数量，模 $10^9 + 7$，要求任何两个直接相连的谷仓颜色不同。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4085", "type": "P", "difficulty": 3, "samples": [["5 10\n4 10\n6 15\n3 5\n4 9\n3 6", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "线段树", "二分", "USACO", "单调队列", "前缀和", "ST 表", "双指针 two-pointer", "单调栈"], "title": "[USACO17DEC] Haybale Feast G", "background": "", "description": "Farmer John is preparing a delicious meal for his cows! In his barn, he has $N$ haybales ($1 \\le N \\le 100,000$). The $i$th haybale has a certain flavor $F_i$ ($1 \\le F_i \\le 10^9$) and a certain spiciness $S_i$ ($1 \\le S_i \\le 10^9$).\n\nThe meal will consist of a single course, being a contiguous interval containing one or more consecutive haybales (Farmer John cannot change the order of the haybales). The total flavor of the meal is the sum of the flavors in the interval. The spiciness of the meal is the maximum spiciness of all haybales in the interval.\n\n\nFarmer John would like to determine the minimum spiciness his single-course meal could achieve, given that it must have a total flavor of at least $M$ ($1 \\le M \\le 10^{18}$).\n", "inputFormat": "The first line contains the integers $N$ and $M$, the number of haybales and the minimum total flavor the meal must have, respectively. The next $N$ lines describe the $N$ haybales with two integers per line, first the flavor $F$ and then the spiciness $S$.\n", "outputFormat": "Please output the minimum spiciness in a single course meal that satisfies the minimum flavor requirement. There will always be at least one single-course meal that satisfies the flavor requirement.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17DEC] Haybale Feast G", "background": "", "description": "Farmer John is preparing a delicious meal for his cows! In his barn, he has $N$ haybales ($1 \\le N \\le 100,000$). The $i$th haybale has a certain flavor $F_i$ ($1 \\le F_i \\le 10^9$) and a certain spiciness $S_i$ ($1 \\le S_i \\le 10^9$).\n\nThe meal will consist of a single course, being a contiguous interval containing one or more consecutive haybales (Farmer John cannot change the order of the haybales). The total flavor of the meal is the sum of the flavors in the interval. The spiciness of the meal is the maximum spiciness of all haybales in the interval.\n\n\nFarmer John would like to determine the minimum spiciness his single-course meal could achieve, given that it must have a total flavor of at least $M$ ($1 \\le M \\le 10^{18}$).\n", "inputFormat": "The first line contains the integers $N$ and $M$, the number of haybales and the minimum total flavor the meal must have, respectively. The next $N$ lines describe the $N$ haybales with two integers per line, first the flavor $F$ and then the spiciness $S$.\n", "outputFormat": "Please output the minimum spiciness in a single course meal that satisfies the minimum flavor requirement. There will always be at least one single-course meal that satisfies the flavor requirement.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17DEC] Haybale Feast G", "background": "", "description": "农夫约翰正在为他的奶牛准备一顿美味的晚餐！在他的谷仓里，他有 $N$ 个干草捆 $(1 \\le N \\le 10^5)$ 。第 $i$ 个干草捆有一定的风味 $F_i(1 \\le F_i \\le 10^9)$ 和一定的辣度 $S_i(1 \\le S_i \\le 10^9)$ 。\n\n这顿饭将由一道菜组成，是一个连续的区间，包含一个或多个连续的干草捆(农夫约翰不能改变干草捆的顺序)。这顿饭的总体的风味是这段区间里风味的总和。这顿饭的总体辣度是区间中所有草包的最大辣度。\n\n农夫约翰想确定他的这道菜所能达到的最小辣度，但是这道菜的总风味必须至少为 $M(1 \\le M \\le 10^{18})$ 。", "inputFormat": "第一行包含两个整数 $N$ 和 $M$ ，分别是干草包的数量和这顿饭必须有的最小风味之和。\n\n接下来的 $N$ 行，每行两个整数描述这 $N$ 个草包，首先是风味 $F_i$，然后是辣度 $S_i$。", "outputFormat": "请输出这道菜中在满足最低风味时的最低辣度。保证至少有一顿单道菜的饭能满足风味的要求。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4086", "type": "P", "difficulty": 3, "samples": [["5\n3 1 9 2 7", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "2017", "线段树", "USACO", "枚举", "前缀和"], "title": "[USACO17DEC] My Cow Ate My Homework S", "background": "", "description": "In your bovine history class, you have been given a rather long homework assignment with $N$ questions ($3 \\leq N \\leq 100,000$), each graded with an integer score in the range 0...10,000. As is often customary, your teacher plans to assign a final grade by discarding a question on which you received the lowest score and then averaging the remaining scores together. Unfortunately, your pet cow Bessie has just eaten your answers to the first $K$ questions! ($K$ could be as small as 1 or as large as $N-2$).\n\nAfter copious explanation, your teacher finally believes your story, and agrees to grade the remaining non-eaten part of the assignment the same way as before -- by removing the lowest-scoring question (or one such question, in the event of a tie) and averaging the rest.\n\n\nPlease output all values of $K$ which would have earned you the maximum possible score according to this grading scheme, in sorted order.\n\n", "inputFormat": "The first line of input contains $N$, and the next line contains the scores on the $N$ homework questions.\n", "outputFormat": "Please output, one value per line, all values of $K$ which would have earned you the maximum possible score.\n", "hint": "If Bessie eats the first two questions, then the remaining scores are 9, 2, and 7. Removing the minimum and averaging, we get a final grade of 8, which is the highest possible.\n", "locale": "en", "translations": {"en": {"title": "[USACO17DEC] My Cow Ate My Homework S", "background": "", "description": "In your bovine history class, you have been given a rather long homework assignment with $N$ questions ($3 \\leq N \\leq 100,000$), each graded with an integer score in the range 0...10,000. As is often customary, your teacher plans to assign a final grade by discarding a question on which you received the lowest score and then averaging the remaining scores together. Unfortunately, your pet cow Bessie has just eaten your answers to the first $K$ questions! ($K$ could be as small as 1 or as large as $N-2$).\n\nAfter copious explanation, your teacher finally believes your story, and agrees to grade the remaining non-eaten part of the assignment the same way as before -- by removing the lowest-scoring question (or one such question, in the event of a tie) and averaging the rest.\n\n\nPlease output all values of $K$ which would have earned you the maximum possible score according to this grading scheme, in sorted order.\n\n", "inputFormat": "The first line of input contains $N$, and the next line contains the scores on the $N$ homework questions.\n", "outputFormat": "Please output, one value per line, all values of $K$ which would have earned you the maximum possible score.\n", "hint": "If Bessie eats the first two questions, then the remaining scores are 9, 2, and 7. Removing the minimum and averaging, we get a final grade of 8, which is the highest possible.\n", "locale": "en"}, "zh-CN": {"title": "[USACO17DEC] My Cow Ate My Homework S", "background": null, "description": "在你的牛历史课上，你被布置了一份相当长的作业，包含 $N$ 个问题（$3 \\leq N \\leq 100,000$），每个问题的得分是一个在 0 到 10,000 之间的整数。按照惯例，你的老师计划通过去掉你得分最低的一个问题，然后对剩余问题的得分取平均来给出最终成绩。不幸的是，你的宠物奶牛 Bessie 刚刚吃掉了你前 $K$ 个问题的答案！（$K$ 可能小到 $1$，也可能大到 $N-2$）。\n\n经过多次解释，你的老师终于相信了你的说法，并同意按照之前的方式对剩余的未被吃掉的部分作业进行评分——即去掉得分最低的问题（或在得分相同的情况下去掉其中一个），然后对剩余问题取平均。\n\n请输出所有能够使你获得最高可能成绩的 $K$ 值，并按升序排列。", "inputFormat": "输入的第一行包含 $N$，第二行包含 $N$ 个作业问题的得分。", "outputFormat": "请逐行输出所有能够使你获得最高可能成绩的 $K$ 值。", "hint": "如果 Bessie 吃掉了前两个问题，那么剩余的得分是 $9$、$2$ 和 $7$。去掉最低分并取平均后，最终成绩为 $8$，这是可能的最高成绩。", "locale": "zh-CN"}}}
{"pid": "P4087", "type": "P", "difficulty": 5, "samples": [["4 10\n7 3 +3\n4 2 -1\n9 3 -1\n1 1 +2", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "线段树", "USACO", "离散化"], "title": "[USACO17DEC] Milk Measurement S", "background": "", "description": "Each of Farmer John's cows initially produces $G$ gallons of milk per day ($1 \\leq G \\leq 10^9$). Since the milk output of a cow is known to potentially change over time, Farmer John decides to take periodic measurements of milk output and write these down in a log book. Entries in his log look like this:\n\n35 1234 -2\n\n14 2345 +3\n\nThe first entry indicates that on day 35, cow #1234's milk output was 2 gallons lower than it was when last measured. The next entry indicates that on day 14, cow #2345's milk output increased by 3 gallons from when it was last measured. Farmer John has only enough time to make at most one measurement on any given day. Unfortunately, he is a bit disorganized, and doesn't necessarily write down his measurements in chronological order.\n\n\nTo keep his cows motivated, Farmer John proudly displays on the wall of his barn the picture of whichever cow currently has the highest milk output (if several cows tie for the highest milk output, he displays all of their pictures). Please determine the number of days on which Farmer John would have needed to change this display.\n\n\nNote that Farmer John has a very large herd of cows, so although some of them are noted in his log book as changing their milk production, there are always plenty of other cows around whose milk output level remains at $G$ gallons.", "inputFormat": "The first line of input contains the number of measurements $N$ that Farmer John makes ($1 \\leq N \\leq 100,000$), followed by $G$. Each of the next $N$ lines contains one measurement, in the format above, specifying a day (an integer in the range $1 \\ldots 10^6$), the integer ID of a cow (in the range $1 \\ldots 10^9$), and the change in her milk output since it was last measured (a nonzero integer). Each cow's milk output will always be in the range $0 \\ldots 10^9$.", "outputFormat": "Please output the number of days on which Farmer John needs to adjust his motivational display.", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17DEC] Milk Measurement S", "background": "", "description": "Each of Farmer John's cows initially produces $G$ gallons of milk per day ($1 \\leq G \\leq 10^9$). Since the milk output of a cow is known to potentially change over time, Farmer John decides to take periodic measurements of milk output and write these down in a log book. Entries in his log look like this:\n\n35 1234 -2\n\n14 2345 +3\n\nThe first entry indicates that on day 35, cow #1234's milk output was 2 gallons lower than it was when last measured. The next entry indicates that on day 14, cow #2345's milk output increased by 3 gallons from when it was last measured. Farmer John has only enough time to make at most one measurement on any given day. Unfortunately, he is a bit disorganized, and doesn't necessarily write down his measurements in chronological order.\n\n\nTo keep his cows motivated, Farmer John proudly displays on the wall of his barn the picture of whichever cow currently has the highest milk output (if several cows tie for the highest milk output, he displays all of their pictures). Please determine the number of days on which Farmer John would have needed to change this display.\n\n\nNote that Farmer John has a very large herd of cows, so although some of them are noted in his log book as changing their milk production, there are always plenty of other cows around whose milk output level remains at $G$ gallons.", "inputFormat": "The first line of input contains the number of measurements $N$ that Farmer John makes ($1 \\leq N \\leq 100,000$), followed by $G$. Each of the next $N$ lines contains one measurement, in the format above, specifying a day (an integer in the range $1 \\ldots 10^6$), the integer ID of a cow (in the range $1 \\ldots 10^9$), and the change in her milk output since it was last measured (a nonzero integer). Each cow's milk output will always be in the range $0 \\ldots 10^9$.", "outputFormat": "Please output the number of days on which Farmer John needs to adjust his motivational display.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17DEC] Milk Measurement S", "background": "", "description": "Farmer John 的每头奶牛最初每天生产 $G$ 加仑牛奶（$1 \\leq G \\leq 10^9$）。由于奶牛的产奶量可能会随时间变化，Farmer John 决定定期测量产奶量并将这些记录在日志中。日志中的条目如下所示：\n\n```\n35 1234 -2  \n14 2345 +3  \n```\n\n第一条记录表示在第 35 天，奶牛 #1234 的产奶量比上次测量时减少了 2 加仑。第二条记录表示在第 14 天，奶牛 #2345 的产奶量比上次测量时增加了 3 加仑。Farmer John 每天最多只能进行一次测量。不幸的是，他有点混乱，记录的测量结果不一定按时间顺序排列。\n\n为了激励他的奶牛，Farmer John 自豪地在谷仓的墙上展示当前产奶量最高的奶牛的照片（如果有多头奶牛产奶量并列最高，他会展示所有奶牛的照片）。请确定 Farmer John 需要更改展示的天数。\n\n请注意，Farmer John 的牛群非常庞大，因此尽管日志中记录了一些奶牛产奶量的变化，但总有许多其他奶牛的产奶量保持在 $G$ 加仑不变。", "inputFormat": "输入的第一行包含 Farmer John 进行的测量次数 $N$（$1 \\leq N \\leq 100,000$）和初始产奶量 $G$。接下来的 $N$ 行每行包含一条测量记录，格式如上所述，指定一个天数（范围为 $1 \\ldots 10^6$）、奶牛的整数 ID（范围为 $1 \\ldots 10^9$）以及自上次测量以来产奶量的变化量（一个非零整数）。每头奶牛的产奶量始终在 $0 \\ldots 10^9$ 范围内。", "outputFormat": "请输出 Farmer John 需要调整激励展示的天数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4088", "type": "P", "difficulty": 6, "samples": [["2 3\n0 10 1\n13 8 2\n1 12\n5 2\n20 7", "4\n3\n10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "线段树", "USACO", "枚举", "树套树"], "title": "[USACO18FEB] Slingshot P", "background": "", "description": "One of the farming chores Farmer John dislikes the most is hauling around lots of cow manure. In order to streamline this process, he comes up with an intriguing idea: instead of hauling manure between two points in a cart behind his tractor, why not shoot it through the air with a giant manure slingshot? (indeed, what could possibly go wrong...)\nFarmer John's farm is built along a single long straight road, so any location on his farm can be described simply using its position along this road (effectively a point on the number line). FJ builds $N$ slingshots ($1 \\leq N \\leq 10^5$), where the $i$th slingshot is described by three integers $x_i$, $y_i$, and $t_i$, specifying that this slingshot can shoot manure from position $x_i$ to position $y_i$ in only $t_i$ total units of time.\n\nFJ has $M$ piles of manure to transport ($1 \\leq M \\leq 10^5$). The $j$th such pile needs to be moved from position $a_j$ to position $b_j$. Hauling manure with the tractor for a distance of $d$ takes $d$ units of time. FJ is hoping to reduce this by allowing up to one use of any slingshot for transporting each pile of manure. Time FJ spends moving his tractor without manure in it does not count.\n\nFor each of the $M$ manure piles, please help FJ determine the minimum possible transportation time, given that FJ can use up to one slingshot during the process.", "inputFormat": "The first line of input contains $N$ and $M$. The next $N$ lines each describe a single slingshot in terms of integers $x_i$, $y_i$, and $t_i$ ($0 \\leq x_i, y_i, t_i \\leq 10^9$). The final $M$ lines describe piles of manure that need to be moved, in terms of integers $a_j$ and $b_j$.", "outputFormat": "Print $M$ lines of output, one for each manure pile, indicating the minimum time needed to transport it.", "hint": "Here, the first pile of manure needs to move from position 1 to position 12. Without using an slingshot, this would take 11 units of time. However, using the first slingshot, it takes 1 unit of time to move to position 0 (the slingshot source), 1 unit of time to fling the manure through the air to land at position 10 (the slingshot destination), and then 2 units of time to move the manure to position 12. The second pile of manure is best moved without any slingshot, and the third pile of manure should be moved using the second slingshot.\n\nProblem credits: Brian Dean", "locale": "en", "translations": {"en": {"title": "[USACO18FEB] Slingshot P", "background": "", "description": "One of the farming chores Farmer John dislikes the most is hauling around lots of cow manure. In order to streamline this process, he comes up with an intriguing idea: instead of hauling manure between two points in a cart behind his tractor, why not shoot it through the air with a giant manure slingshot? (indeed, what could possibly go wrong...)\nFarmer John's farm is built along a single long straight road, so any location on his farm can be described simply using its position along this road (effectively a point on the number line). FJ builds $N$ slingshots ($1 \\leq N \\leq 10^5$), where the $i$th slingshot is described by three integers $x_i$, $y_i$, and $t_i$, specifying that this slingshot can shoot manure from position $x_i$ to position $y_i$ in only $t_i$ total units of time.\n\nFJ has $M$ piles of manure to transport ($1 \\leq M \\leq 10^5$). The $j$th such pile needs to be moved from position $a_j$ to position $b_j$. Hauling manure with the tractor for a distance of $d$ takes $d$ units of time. FJ is hoping to reduce this by allowing up to one use of any slingshot for transporting each pile of manure. Time FJ spends moving his tractor without manure in it does not count.\n\nFor each of the $M$ manure piles, please help FJ determine the minimum possible transportation time, given that FJ can use up to one slingshot during the process.", "inputFormat": "The first line of input contains $N$ and $M$. The next $N$ lines each describe a single slingshot in terms of integers $x_i$, $y_i$, and $t_i$ ($0 \\leq x_i, y_i, t_i \\leq 10^9$). The final $M$ lines describe piles of manure that need to be moved, in terms of integers $a_j$ and $b_j$.", "outputFormat": "Print $M$ lines of output, one for each manure pile, indicating the minimum time needed to transport it.", "hint": "Here, the first pile of manure needs to move from position 1 to position 12. Without using an slingshot, this would take 11 units of time. However, using the first slingshot, it takes 1 unit of time to move to position 0 (the slingshot source), 1 unit of time to fling the manure through the air to land at position 10 (the slingshot destination), and then 2 units of time to move the manure to position 12. The second pile of manure is best moved without any slingshot, and the third pile of manure should be moved using the second slingshot.\n\nProblem credits: Brian Dean", "locale": "en"}, "zh-CN": {"title": "[USACO18FEB] Slingshot P", "background": "", "description": "Farmer John 最不喜欢的农活之一就是到处搬运牛粪。为了简化这一过程，他想出了一个有趣的主意：与其用拖拉机后面的拖车搬运牛粪，为什么不通过一个巨大的牛粪弹弓将其射到空中呢？（确实，可能会出什么问题呢……）\n\nFarmer John 的农场建在一条笔直的长路上，因此农场上的任何位置都可以简单地用其在这条路上的位置来描述（实际上就是数轴上的一个点）。FJ 建造了 $N$ 个弹弓（$1 \\leq N \\leq 10^5$），其中第 $i$ 个弹弓由三个整数 $x_i$、$y_i$ 和 $t_i$ 描述，表示这个弹弓可以将牛粪从位置 $x_i$ 射到位置 $y_i$，仅需 $t_i$ 个单位时间。\n\nFJ 有 $M$ 堆牛粪需要搬运（$1 \\leq M \\leq 10^5$）。第 $j$ 堆牛粪需要从位置 $a_j$ 搬运到位置 $b_j$。用拖拉机搬运牛粪，每移动距离 $d$ 需要 $d$ 个单位时间。FJ 希望通过允许每堆牛粪最多使用一次弹弓来减少搬运时间。FJ 在没有牛粪的情况下移动拖拉机的时间不计入搬运时间。\n\n对于每堆牛粪，请帮助 FJ 确定在最多使用一次弹弓的情况下，搬运所需的最少时间。", "inputFormat": "输入的第一行包含 $N$ 和 $M$。接下来的 $N$ 行每行描述一个弹弓，包含三个整数 $x_i$、$y_i$ 和 $t_i$（$0 \\leq x_i, y_i, t_i \\leq 10^9$）。最后的 $M$ 行描述需要搬运的牛粪堆，每行包含两个整数 $a_j$ 和 $b_j$。", "outputFormat": "输出 $M$ 行，每行对应一堆牛粪，表示搬运所需的最少时间。", "hint": "在这里，第一堆牛粪需要从位置 $1$ 搬运到位置 $12$。如果不使用弹弓，这将花费 $11$ 个单位时间。然而，使用第一个弹弓，花费 $1$ 个单位时间将牛粪移动到位置 $0$（弹弓的起点），$1$ 个单位时间将牛粪射到位置 $10$（弹弓的终点），然后花费 $2$ 个单位时间将牛粪移动到位置 $12$。第二堆牛粪最好不使用弹弓搬运，而第三堆牛粪应使用第二个弹弓搬运。\n\n题目来源：Brian Dean", "locale": "zh-CN"}}}
{"pid": "P4089", "type": "P", "difficulty": 3, "samples": [["4\n3 2 1 3", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "USACO", "拓扑排序"], "title": "[USACO17DEC] The Bovine Shuffle S", "background": "", "description": "Convinced that happy cows generate more milk, Farmer John has installed a giant disco ball in his barn and plans to teach his cows to dance!\n\nLooking up popular cow dances, Farmer John decides to teach his cows the \"Bovine Shuffle\". The Bovine Shuffle consists of his $N$ cows ($1 \\leq N \\leq 100,000$) lining up in a row in some order, then performing successive \"shuffles\", each of which potentially re-orders the cows. To make it easier for his cows to locate themselves, Farmer John marks the locations for his line of cows with positions $1 \\ldots N$, so the first cow in the lineup will be in position 1, the next in position 2, and so on, up to position $N$.\n\n\nA shuffle is described with $N$ numbers, $a_1 \\ldots a_N$, where a cow in position $i$ moves to position $a_i$ during the shuffle (and so, each $a_i$ is in the range $1 \\ldots N$). Every cow moves to its new location during the shuffle. Unfortunately, all the $a_i$'s are not necessarily distinct, so multiple cows might try to move to the same position during a shuffle, after which they will move together for all remaining shuffles.\n\n\nFarmer John notices that some positions in his lineup contain cows in them no matter how many shuffles take place. Please help him count the number of such positions.\n\n", "inputFormat": "The first line of input contains $N$, the number of cows. The next line contains the $N$ integers $a_1 \\ldots a_N$.\n", "outputFormat": "Please output the number of positions that will always contain cows, no matter how many shuffles take place.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17DEC] The Bovine Shuffle S", "background": "", "description": "Convinced that happy cows generate more milk, Farmer John has installed a giant disco ball in his barn and plans to teach his cows to dance!\n\nLooking up popular cow dances, Farmer John decides to teach his cows the \"Bovine Shuffle\". The Bovine Shuffle consists of his $N$ cows ($1 \\leq N \\leq 100,000$) lining up in a row in some order, then performing successive \"shuffles\", each of which potentially re-orders the cows. To make it easier for his cows to locate themselves, Farmer John marks the locations for his line of cows with positions $1 \\ldots N$, so the first cow in the lineup will be in position 1, the next in position 2, and so on, up to position $N$.\n\n\nA shuffle is described with $N$ numbers, $a_1 \\ldots a_N$, where a cow in position $i$ moves to position $a_i$ during the shuffle (and so, each $a_i$ is in the range $1 \\ldots N$). Every cow moves to its new location during the shuffle. Unfortunately, all the $a_i$'s are not necessarily distinct, so multiple cows might try to move to the same position during a shuffle, after which they will move together for all remaining shuffles.\n\n\nFarmer John notices that some positions in his lineup contain cows in them no matter how many shuffles take place. Please help him count the number of such positions.\n\n", "inputFormat": "The first line of input contains $N$, the number of cows. The next line contains the $N$ integers $a_1 \\ldots a_N$.\n", "outputFormat": "Please output the number of positions that will always contain cows, no matter how many shuffles take place.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17DEC] The Bovine Shuffle S", "background": "", "description": "Farmer John 坚信快乐的奶牛能产更多的奶，因此他在谷仓里安装了一个巨大的迪斯科球，并计划教他的奶牛跳舞！\n\n在查阅了流行的奶牛舞蹈后，Farmer John 决定教他的奶牛“Bovine Shuffle”。Bovine Shuffle 包括他的 $N$ 头奶牛（$1 \\leq N \\leq 100,000$）以某种顺序排成一行，然后进行连续的“洗牌”，每次洗牌可能会重新排列奶牛的顺序。为了让奶牛更容易找到自己的位置，Farmer John 为他的奶牛队伍标记了位置 $1 \\ldots N$，因此队伍中的第一头奶牛位于位置 1，第二头位于位置 2，依此类推，直到位置 $N$。\n\n一次洗牌由 $N$ 个数字 $a_1 \\ldots a_N$ 描述，其中位于位置 $i$ 的奶牛在洗牌期间移动到位置 $a_i$（因此，每个 $a_i$ 都在 $1 \\ldots N$ 范围内）。每头奶牛在洗牌期间都会移动到它的新位置。不幸的是，所有的 $a_i$ 不一定互不相同，因此多只奶牛可能会在洗牌期间尝试移动到同一位置，之后它们将在所有剩余的洗牌中一起移动。\n\nFarmer John 注意到，无论进行多少次洗牌，他的队伍中某些位置始终会有奶牛。请帮助他计算这样的位置数量。", "inputFormat": "输入的第一行包含 $N$，表示奶牛的数量。第二行包含 $N$ 个整数 $a_1 \\ldots a_N$。", "outputFormat": "请输出无论进行多少次洗牌，始终会有奶牛的位置数量。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4090", "type": "P", "difficulty": 5, "samples": [["3\n1 2 0", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2017", "二分", "USACO"], "title": "[USACO17DEC] Greedy Gift Takers P", "background": "", "description": "Farmer John's nemesis, Farmer Nhoj, has $N$ cows ($1 \\leq N \\leq 10^5$), conveniently numbered $1 \\dots N$. They have unexpectedly turned up at Farmer John's farm, so the unfailingly polite Farmer John is attempting to give them gifts.\n\nTo this end, Farmer John has brought out his infinite supply of gifts, and Nhoj's cows have queued up in front of him, with cow $1$ at the head of the queue and cow $N$ at the tail. Farmer John was expecting that at every timestep, the cow at the head of the queue would take a gift from Farmer John and go to the tail of the queue. However, he has just realized that Nhoj's cows are not that polite! After receiving her gift, each cow may not go to the tail of the queue, but rather may cut some number of cows at the tail, and insert herself in front of them. Specifically, cow $i$ will always cut exactly $c_i$ cows ($0 \\leq c_i \\leq N-1$).\n\n\nFarmer John knows that some cows might receive multiple gifts; as he has an infinite supply, this does not worry him. But he is worried that some cows might become unhappy if they do not get any gifts.\n\n\nHelp Farmer John find the number of cows who never receive any gifts, no matter how many gifts are handed out.", "inputFormat": "The first line contains a single integer, $N$.\n\nThe second line contains $N$ space-separated integers $c_1, c_2, \\dots, c_N$.\n", "outputFormat": "Please output the number of cows who cannot receive any gifts.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17DEC] Greedy Gift Takers P", "background": "", "description": "Farmer John's nemesis, Farmer Nhoj, has $N$ cows ($1 \\leq N \\leq 10^5$), conveniently numbered $1 \\dots N$. They have unexpectedly turned up at Farmer John's farm, so the unfailingly polite Farmer John is attempting to give them gifts.\n\nTo this end, Farmer John has brought out his infinite supply of gifts, and Nhoj's cows have queued up in front of him, with cow $1$ at the head of the queue and cow $N$ at the tail. Farmer John was expecting that at every timestep, the cow at the head of the queue would take a gift from Farmer John and go to the tail of the queue. However, he has just realized that Nhoj's cows are not that polite! After receiving her gift, each cow may not go to the tail of the queue, but rather may cut some number of cows at the tail, and insert herself in front of them. Specifically, cow $i$ will always cut exactly $c_i$ cows ($0 \\leq c_i \\leq N-1$).\n\n\nFarmer John knows that some cows might receive multiple gifts; as he has an infinite supply, this does not worry him. But he is worried that some cows might become unhappy if they do not get any gifts.\n\n\nHelp Farmer John find the number of cows who never receive any gifts, no matter how many gifts are handed out.", "inputFormat": "The first line contains a single integer, $N$.\n\nThe second line contains $N$ space-separated integers $c_1, c_2, \\dots, c_N$.\n", "outputFormat": "Please output the number of cows who cannot receive any gifts.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17DEC] Greedy Gift Takers P", "background": "", "description": "Farmer John 的死对头 Farmer Nhoj 有 $N$ 头奶牛（$1 \\leq N \\leq 10^5$），编号为 $1 \\dots N$。它们意外地出现在 Farmer John 的农场，因此一贯礼貌的 Farmer John 试图给它们送礼物。\n\n为此，Farmer John 拿出了他无限的礼物供应，Nhoj 的奶牛在他面前排成一队，奶牛 $1$ 在队首，奶牛 $N$ 在队尾。Farmer John 原本以为，在每一时刻，队首的奶牛会从 Farmer John 那里拿走一份礼物，然后走到队尾。然而，他刚刚意识到 Nhoj 的奶牛并不那么礼貌！每头奶牛在收到礼物后，可能不会走到队尾，而是可能会插队到队尾的某些奶牛前面。具体来说，奶牛 $i$ 总是会插队到恰好 $c_i$ 头奶牛前面（$0 \\leq c_i \\leq N-1$）。\n\nFarmer John 知道有些奶牛可能会收到多份礼物；由于他有无限的礼物供应，这并不让他担心。但他担心的是，如果有些奶牛没有收到任何礼物，它们可能会变得不开心。\n\n请帮助 Farmer John 找出无论送出多少礼物，都无法收到任何礼物的奶牛数量。", "inputFormat": "第一行包含一个整数 $N$。\n\n第二行包含 $N$ 个用空格分隔的整数 $c_1, c_2, \\dots, c_N$。", "outputFormat": "请输出无法收到任何礼物的奶牛数量。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4091", "type": "P", "difficulty": 6, "samples": [["3", "87"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2016", "各省省选", "河北", "枚举", "容斥原理", "快速傅里叶变换 FFT", "快速数论变换 NTT", "天津"], "title": "[HEOI2016/TJOI2016] 求和", "background": "", "description": "在2016年，佳媛姐姐刚刚学习了第二类斯特林数，非常开心。\n\n现在他想计算这样一个函数的值:\n\n$$f(n)=\\sum_{i=0}^n\\sum_{j=0}^i S(i,j)\\times 2^j \\times (j!)$$\n\nS(i, j)表示第二类斯特林数，递推公式为:\n\n$S(i, j) = j \\times S(i - 1, j) + S(i - 1, j - 1), 1 \\le j \\le i - 1$。\n\n边界条件为：$S(i, i) = 1(0 \\le i), S(i, 0) = 0(1 \\le i)$\n\n你能帮帮他吗?\n", "inputFormat": "输入只有一个正整数 $n$。", "outputFormat": "输出 $f(n)$。由于结果会很大，输出 $f(n)$ 对 998244353 ($7 \\times 17 \\times 2^{23} + 1$) 取模的结果即可。\n", "hint": "对于 $50\\%$ 的数据，$1\\leq n \\leq5\\times10^3$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2016/TJOI2016] Summation", "background": "", "description": "In 2016, Sister Jiayuan had just learned about the Stirling numbers of the second kind and was very happy.\n\nNow she wants to compute the value of the following function:\n\n$$f(n)=\\sum_{i=0}^n\\sum_{j=0}^i S(i,j)\\times 2^j \\times (j!)$$\n\n$S(i, j)$ denotes the Stirling numbers of the second kind, with the recurrence:\n$S(i, j) = j \\times S(i - 1, j) + S(i - 1, j - 1), 1 \\le j \\le i - 1$.\n\nBoundary conditions: $S(i, i) = 1 (0 \\le i)$, $S(i, 0) = 0 (1 \\le i)$.\n\nCan you help her?", "inputFormat": "The input contains a single positive integer $n$.", "outputFormat": "Output $f(n)$. Since the result can be large, output $f(n)$ modulo 998244353 ($7 \\times 17 \\times 2^{23} + 1$).", "hint": "For 50% of the testdata, $1 \\le n \\le 5 \\times 10^3$.\nFor 100% of the testdata, $1 \\le n \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2016/TJOI2016] 求和", "background": "", "description": "在2016年，佳媛姐姐刚刚学习了第二类斯特林数，非常开心。\n\n现在他想计算这样一个函数的值:\n\n$$f(n)=\\sum_{i=0}^n\\sum_{j=0}^i S(i,j)\\times 2^j \\times (j!)$$\n\nS(i, j)表示第二类斯特林数，递推公式为:\n\n$S(i, j) = j \\times S(i - 1, j) + S(i - 1, j - 1), 1 \\le j \\le i - 1$。\n\n边界条件为：$S(i, i) = 1(0 \\le i), S(i, 0) = 0(1 \\le i)$\n\n你能帮帮他吗?\n", "inputFormat": "输入只有一个正整数 $n$。", "outputFormat": "输出 $f(n)$。由于结果会很大，输出 $f(n)$ 对 998244353 ($7 \\times 17 \\times 2^{23} + 1$) 取模的结果即可。\n", "hint": "对于 $50\\%$ 的数据，$1\\leq n \\leq5\\times10^3$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P4092", "type": "P", "difficulty": 5, "samples": [["5 5 \n1 2 \n1 3 \n2 4 \n2 5 \nQ 2 \nC 2 \nQ 2 \nQ 5 \nQ 3", "1\n2\n2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "2016", "线段树", "并查集", "各省省选", "河北", "树链剖分", "天津"], "title": "[HEOI2016/TJOI2016] 树", "background": null, "description": "在 2016 年，佳媛姐姐刚刚学习了树，非常开心。现在她想解决这样一个问题：给定一颗有根树，根为 $1$，有以下两种操作：\n\n1. 标记操作：对某个结点打上标记。（在最开始，只有结点 $1$ 有标记，其他结点均无标记，而且对于某个结点，可以打多次标记。）\n\n2. 询问操作：询问某个结点最近的一个打了标记的祖先（这个结点本身也算自己的祖先）。\n\n你能帮帮她吗？", "inputFormat": "第一行两个正整数 $N$ 和 $Q$ 分别表示节点个数和操作次数。\n\n接下来 $N-1$ 行，每行两个正整数 $u,v$（$1 \\leqslant u,v \\leqslant n$）表示 $u$ 到 $v$ 有一条有向边。\n\n接下来 $Q$ 行，形如 `oper num`，`oper` 为 `C` 时表示这是一个标记操作，`oper` 为 `Q` 时表示这是一个询问操作。", "outputFormat": "对于每个询问操作，输出一行，一个正整数，表示结果。", "hint": "- $30\\%$ 的数据，$1 \\leqslant N, Q \\leqslant 1000$；\n\n- $70\\%$ 的数据，$1 \\leqslant N, Q \\leqslant 10000$；\n\n- $100\\%$ 的数据，$1 \\leqslant N, Q \\leqslant 100000$。", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2016/TJOI2016] Tree", "background": "", "description": "In 2016, Jiayuan jiejie had just learned about trees and was very happy. Now she wants to solve the following problem: given a rooted tree with root $1$, there are two types of operations:\n\n1. Mark operation: put a mark on some node. (At the very beginning, only node $1$ is marked, and all other nodes are unmarked. You may mark the same node multiple times.)\n\n2. Query operation: ask for the nearest marked ancestor of some node (the node itself also counts as its own ancestor).\n\nCan you help her?", "inputFormat": "The first line contains two positive integers $N$ and $Q$, denoting the number of nodes and the number of operations.\n\nThe next $N-1$ lines each contain two positive integers $u, v$ ($1 \\leqslant u, v \\leqslant N$) indicating a directed edge from $u$ to $v$. These edges form a rooted tree with root $1$, and edges are directed from parent to child.\n\nThe next $Q$ lines are of the form `oper num`. When `oper` is `C`, it denotes a mark operation on node `num`. When `oper` is `Q`, it denotes a query operation on node `num`.", "outputFormat": "For each query operation, output one integer: the nearest marked ancestor of the given node (including the node itself). Print each answer on its own line.", "hint": "- 30% of the testdata: $1 \\leqslant N, Q \\leqslant 1000$.\n- 70% of the testdata: $1 \\leqslant N, Q \\leqslant 10000$.\n- 100% of the testdata: $1 \\leqslant N, Q \\leqslant 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2016/TJOI2016] 树", "background": null, "description": "在 2016 年，佳媛姐姐刚刚学习了树，非常开心。现在她想解决这样一个问题：给定一颗有根树，根为 $1$，有以下两种操作：\n\n1. 标记操作：对某个结点打上标记。（在最开始，只有结点 $1$ 有标记，其他结点均无标记，而且对于某个结点，可以打多次标记。）\n\n2. 询问操作：询问某个结点最近的一个打了标记的祖先（这个结点本身也算自己的祖先）。\n\n你能帮帮她吗？", "inputFormat": "第一行两个正整数 $N$ 和 $Q$ 分别表示节点个数和操作次数。\n\n接下来 $N-1$ 行，每行两个正整数 $u,v$（$1 \\leqslant u,v \\leqslant n$）表示 $u$ 到 $v$ 有一条有向边。\n\n接下来 $Q$ 行，形如 `oper num`，`oper` 为 `C` 时表示这是一个标记操作，`oper` 为 `Q` 时表示这是一个询问操作。", "outputFormat": "对于每个询问操作，输出一行，一个正整数，表示结果。", "hint": "- $30\\%$ 的数据，$1 \\leqslant N, Q \\leqslant 1000$；\n\n- $70\\%$ 的数据，$1 \\leqslant N, Q \\leqslant 10000$；\n\n- $100\\%$ 的数据，$1 \\leqslant N, Q \\leqslant 100000$。", "locale": "zh-CN"}}}
{"pid": "P4093", "type": "P", "difficulty": 6, "samples": [["3 4 \n1 2 3 \n1 2 \n2 3 \n2 1 \n3 4", "3\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2016", "线段树", "各省省选", "河北", "cdq 分治", "O2优化", "树套树", "天津"], "title": "[HEOI2016/TJOI2016] 序列", "background": null, "description": "佳媛姐姐过生日的时候，她的小伙伴从某宝上买了一个有趣的玩具送给她。\n\n玩具上有一个数列，数列中某些项的值可能会变化，但同一个时刻最多只有一个值发生变化。现在佳媛姐姐已经研究出了所有变化的可能性，她想请教你，能否选出一个子序列，使得在**任意一种变化和原序列**中，这个子序列都是不降的？请你告诉她这个子序列的最长长度即可。", "inputFormat": "输入的第一行有两个正整数 $n,m$，分别表示序列的长度和变化的个数。\n\n接下来一行有 $n$ 个整数，表示这个数列原始的状态。\n\n接下来 $m$ 行，每行有 $2$ 个整数 $x,y$，表示数列的第 $x$ 项可以变化成 $y$ 这个值。", "outputFormat": "输出一个整数，表示对应的答案。", "hint": "注意：每种变化最多只有一个值发生变化。\n\n在样例输入中，所有的变化是：\n```plain\n1 2 3\n2 2 3\n1 3 3\n1 1 3\n1 2 4\n```\n选择子序列为原序列，即在任意一种变化中均为不降子序列。\n\n对于 $20\\%$ 数据，所有数均为正整数，且小于等于 $300$。\n\n对于 $50\\%$ 数据，所有数均为正整数，且小于等于 $3000$。\n\n对于 $100\\%$ 数据，所有数均为正整数，且小于等于 $10^5$。$1\\le x\\le n$。", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2016/TJOI2016] Sequence", "background": "", "description": "On Jiayuan’s birthday, her friend bought an interesting toy from an online marketplace and gave it to her.\n\nThere is a sequence on the toy. The values of some elements in the sequence may change, but at any time at most one value changes. Jiayuan has already figured out all possible changes. She wants to ask you whether it is possible to choose a subsequence that is nondecreasing in the original sequence and under any single change. Please tell her the maximum possible length of such a subsequence.", "inputFormat": "The first line contains two positive integers $n, m$, representing the length of the sequence and the number of changes.\n\nThe next line contains $n$ integers, representing the original state of the sequence.\n\nThe next $m$ lines each contain $2$ integers $x, y$, meaning the $x$-th element of the sequence can change to the value $y$.", "outputFormat": "Output a single integer, representing the answer.", "hint": "Note: In each scenario, at most one value changes.\n\nIn the sample input, all changed sequences are:\n```plain\n1 2 3\n2 2 3\n1 3 3\n1 1 3\n1 2 4\n```\nChoosing the entire original sequence as the subsequence works; it remains nondecreasing under any single change.\n\nFor $20\\%$ of the testdata, all numbers are positive integers and at most $300$.\n\nFor $50\\%$ of the testdata, all numbers are positive integers and at most $3000$.\n\nFor $100\\%$ of the testdata, all numbers are positive integers and at most $10^5$. $1 \\le x \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2016/TJOI2016] 序列", "background": null, "description": "佳媛姐姐过生日的时候，她的小伙伴从某宝上买了一个有趣的玩具送给她。\n\n玩具上有一个数列，数列中某些项的值可能会变化，但同一个时刻最多只有一个值发生变化。现在佳媛姐姐已经研究出了所有变化的可能性，她想请教你，能否选出一个子序列，使得在**任意一种变化和原序列**中，这个子序列都是不降的？请你告诉她这个子序列的最长长度即可。", "inputFormat": "输入的第一行有两个正整数 $n,m$，分别表示序列的长度和变化的个数。\n\n接下来一行有 $n$ 个整数，表示这个数列原始的状态。\n\n接下来 $m$ 行，每行有 $2$ 个整数 $x,y$，表示数列的第 $x$ 项可以变化成 $y$ 这个值。", "outputFormat": "输出一个整数，表示对应的答案。", "hint": "注意：每种变化最多只有一个值发生变化。\n\n在样例输入中，所有的变化是：\n```plain\n1 2 3\n2 2 3\n1 3 3\n1 1 3\n1 2 4\n```\n选择子序列为原序列，即在任意一种变化中均为不降子序列。\n\n对于 $20\\%$ 数据，所有数均为正整数，且小于等于 $300$。\n\n对于 $50\\%$ 数据，所有数均为正整数，且小于等于 $3000$。\n\n对于 $100\\%$ 数据，所有数均为正整数，且小于等于 $10^5$。$1\\le x\\le n$。", "locale": "zh-CN"}}}
{"pid": "P4094", "type": "P", "difficulty": 7, "samples": [["5 5\naaaaa\n1 1 1 5\n1 5 1 1\n2 3 2 3\n2 4 2 3\n2 3 2 4", "1\n1\n2\n2\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "线段树", "二分", "各省省选", "河北", "后缀自动机 SAM", "O2优化", "可持久化线段树", "后缀数组 SA", "天津"], "title": "[HEOI2016/TJOI2016] 字符串", "background": "", "description": "佳媛姐姐过生日的时候，她的小伙伴从某东上买了一个生日礼物。生日礼物放在一个神奇的箱子中。箱子外边写了一个长为 $n$ 的字符串 $s$，和 $m$ 个问题。佳媛姐姐必须正确回答这 $m$ 个问题，才能打开箱子拿到礼物，升职加薪，出任 CEO，嫁给高富帅，走上人生巅峰。\n\n每个问题均有 $a,b,c,d$ 四个参数，问你子串 $s[a..b]$ 的所有子串和 $s[c..d]$ 的最长公共前缀的长度的最大值是多少？佳媛姐姐并不擅长做这样的问题，所以她向你求助，你该如何帮助她呢？\n", "inputFormat": "输入的第一行有两个正整数 $n,m$，分别表示字符串的长度和询问的个数。\n\n接下来一行是一个长为 $n$ 的字符串。接下来 $m$ 行，每行有 $4$ 个数 $a,b,c,d$，表示询问 $s[a..b]$ 的所有子串和 $s[c..d]$ 的最长公共前缀的最大值。\n", "outputFormat": "对于每一次询问，输出答案。\n", "hint": "对于 $10\\%$ 的数据，$1\\le n,m\\le 300$。\n\n对于 $40\\%$ 的数据，$1\\le n,m\\le 3,000$，字符串中仅有 `a`,`b`。\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 100,000$，字符串中仅有小写英文字母，$a\\le b$，$c\\le d$，$1\\le a,b,c,d\\le n$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2016/TJOI2016] String", "background": "", "description": "On Jiayuan’s birthday, her friends bought her a birthday gift from an online store. The gift is placed in a magic box. On the outside of the box there is a string $s$ of length $n$, and $m$ questions. Jiayuan must answer these $m$ questions correctly to open the box and get the gift, get promoted and receive a raise, become the CEO, marry a rich and handsome man, and reach the pinnacle of life.\n\nEach question has four parameters $a,b,c,d$. Among all substrings of $s[a..b]$, what is the maximum possible length of the longest common prefix with $s[c..d]$? Jiayuan is not good at such problems, so she asks you for help. How would you help her?", "inputFormat": "The first line contains two positive integers $n,m$, denoting the length of the string and the number of queries.\n\nThe next line contains a string of length $n$. Then there are $m$ lines, each containing four integers $a,b,c,d$, representing a query asking for the maximum length of the longest common prefix between any substring of $s[a..b]$ and $s[c..d]$.", "outputFormat": "For each query, output the answer.", "hint": "For $10\\%$ of the testdata, $1 \\le n,m \\le 300$.\n\nFor $40\\%$ of the testdata, $1 \\le n,m \\le 3{,}000$, and the string contains only `a`, `b`.\n\nFor $100\\%$ of the testdata, $1 \\le n,m \\le 100{,}000$, the string contains only lowercase English letters, $a \\le b$, $c \\le d$, and $1 \\le a,b,c,d \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2016/TJOI2016] 字符串", "background": "", "description": "佳媛姐姐过生日的时候，她的小伙伴从某东上买了一个生日礼物。生日礼物放在一个神奇的箱子中。箱子外边写了一个长为 $n$ 的字符串 $s$，和 $m$ 个问题。佳媛姐姐必须正确回答这 $m$ 个问题，才能打开箱子拿到礼物，升职加薪，出任 CEO，嫁给高富帅，走上人生巅峰。\n\n每个问题均有 $a,b,c,d$ 四个参数，问你子串 $s[a..b]$ 的所有子串和 $s[c..d]$ 的最长公共前缀的长度的最大值是多少？佳媛姐姐并不擅长做这样的问题，所以她向你求助，你该如何帮助她呢？\n", "inputFormat": "输入的第一行有两个正整数 $n,m$，分别表示字符串的长度和询问的个数。\n\n接下来一行是一个长为 $n$ 的字符串。接下来 $m$ 行，每行有 $4$ 个数 $a,b,c,d$，表示询问 $s[a..b]$ 的所有子串和 $s[c..d]$ 的最长公共前缀的最大值。\n", "outputFormat": "对于每一次询问，输出答案。\n", "hint": "对于 $10\\%$ 的数据，$1\\le n,m\\le 300$。\n\n对于 $40\\%$ 的数据，$1\\le n,m\\le 3,000$，字符串中仅有 `a`,`b`。\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 100,000$，字符串中仅有小写英文字母，$a\\le b$，$c\\le d$，$1\\le a,b,c,d\\le n$。\n", "locale": "zh-CN"}}}
{"pid": "P4095", "type": "P", "difficulty": 5, "samples": [["5 \n2 3 4 \n1 2 1 \n4 1 2 \n2 1 1 \n3 2 3 \n5 \n1 10 \n2 7 \n3 4 \n4 8 \n0 5", "13 \n11 \n6 \n12 \n4 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "各省省选", "河北", "枚举", "背包 DP", "进制"], "title": "[HEOI2013] Eden 的新背包问题", "background": "“ 寄 没 有 地 址 的 信 ，这 样 的 情 绪 有 种 距 离 ，你 放 着 谁 的 歌 曲 ，是 怎 样 的 心 情 。 能 不 能 说 给 我 听 。”", "description": "失忆的 Eden 总想努力地回忆起过去，然而总是只能清晰地记得那种思念的感觉，却不能回忆起她的音容笑貌。\n\n记忆中，她总是喜欢给 Eden 出谜题：在 valentine's day 的夜晚，两人在闹市中闲逛时，望着礼品店里精巧玲珑的各式玩偶，她突发奇想，问了 Eden 这样的一个问题：有 $n$ 个玩偶，每个玩偶有对应的价值、价钱，每个玩偶都可以被买有限次，在携带的价钱 $m$ 固定的情况下，如何选择买哪些玩偶以及每个玩偶买多少个，才能使得选择的玩偶总价钱不超过 $m$，且价值和最大。\n\n众所周知的，这是一个很经典的多重背包问题，Eden 很快解决了，不过她似乎因为自己的问题被飞快解决感到了一丝不高兴，于是她希望把问题加难：多次询问，每次询问都将给出新的总价钱，并且会去掉某个玩偶（即这个玩偶不能被选择），再问此时的多重背包的答案（即前一段所叙述的问题）。\n\n这下 Eden 犯难了，不过 Eden 不希望自己被难住，你能帮帮他么？", "inputFormat": "第一行有一个整数，代表玩偶的个数 $n$，玩偶从 $0$ 开始编号。\n\n第二行开始后面的 $n$ 行，每行三个整数，第 $(i + 2)$ 行的整数  $a_i, b_i, c_i$，分别表示买一个第 $i$ 个玩偶需要的价钱，获得的价值以及第 $i$ 个玩偶的限购次数。\n\n接下来的一行有一个整数 $q$，表示询问次数。\n\n接下来 $q$ 行，每行两个整数 $d_i, e_i$，表示每个询问去掉的是哪个玩偶（注意玩偶从 $0$ 开始编号）以及该询问对应的新的总价钱数。（去掉操作不保留，即不同询问互相独立）。", "outputFormat": "输出 $q$ 行，第 $i$ 行输出对于第 $i$ 个询问的答案。", "hint": "#### 样例解释\n\n一共五种玩偶，分别的价钱价值和限购次数为 $(2,3,4)$， $(1,2,1)$， $(4,1,2)$， $(2,1,1)$， $(3,2,3)$。\n\n五个询问，以第一个询问为例。\n\n第一个询问表示的是去掉编号为 $1$ 的玩偶， 且拥有的钱数为 $10$ 时可以获得的最大价值，则此时剩余玩偶为 $(2,3,4$)，$(4,1,2)$， $(2,1,1)$，$(3,2,3)$，若把编号为 $0$ 的玩偶买 $4$ 个（即全买了），然后编号为 $3$ 的玩偶 买一个，则刚好把 $10$ 元全部花完，且总价值为 $13$。可以证明没有更优的方案了。\n\n注意买某种玩偶不一定要买光。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $10\\%$ 的数据，保证 $n \\leq 10$。\n- 另外存在 $20\\%$ 的数据，保证  $n \\leq 100$，$c_i = 1$，$q \\leq 100$。\n- 另外存在 $20\\%$ 的数据，保证 $n \\leq 100$，$q \\leq 100$。\n- 另外存在 $30\\%$ 的数据，保证 $c_i = 1$。\n- 对于 $100\\%$ 的数据，保证  $1 \\leq n \\leq 1000$，$1 \\leq q \\leq 3\\times 10^5$， $1 \\leq a_i,b_i,c_i \\leq 100$，$0 \\leq d_i < n$，$0 \\leq e_i \\leq 1000$。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2013] Eden's New Knapsack Problem", "background": "\"Sending a letter without an address, such a feeling has a kind of distance; whose song are you playing, and what mood is it? Could you tell me?\".", "description": "The amnesiac Eden keeps trying to recall the past, yet he can only clearly remember the feeling of longing, not her face or smile.\n\nIn his memory, she always liked giving Eden puzzles. On Valentine's Day night, while the two were strolling through a bustling street and gazing at the delicate dolls in a gift shop, she suddenly asked Eden a question: there are $n$ dolls. Each doll has a cost and a value, and each doll can be bought a limited number of times. With a fixed budget $m$, how should one choose which dolls to buy and how many copies of each, so that the total cost does not exceed $m$ and the total value is maximized.\n\nAs is well known, this is a classic multiple knapsack problem. Eden solved it quickly, but she seemed a bit unhappy that her problem was answered so fast. So she made it harder: there will be multiple queries. In each query, a new budget is given and one doll is removed (i.e., that doll cannot be chosen). Then the answer to the multiple knapsack under this condition is asked (i.e., the problem described above).\n\nNow Eden is in trouble, but he does not want to be stumped. Can you help him?.", "inputFormat": "- The first line contains an integer $n$, the number of dolls. Dolls are indexed starting from $0$.\n- The next $n$ lines, each line contains three integers. On line $i + 2$, the integers $a_i, b_i, c_i$ denote the cost of one copy of doll $i$, the value obtained, and the purchase limit of doll $i$, respectively.\n- The next line contains an integer $q$, the number of queries.\n- The next $q$ lines, each contains two integers $d_i, e_i$, indicating which doll is removed (note that dolls are indexed from $0$) and the new budget for this query. The removal does not persist, i.e., different queries are independent.", "outputFormat": "Output $q$ lines. On the $i$-th line, output the answer for the $i$-th query.", "hint": "Sample Explanation.\n\nThere are five types of dolls. Their costs, values, and purchase limits are $(2,3,4)$, $(1,2,1)$, $(4,1,2)$, $(2,1,1)$, $(3,2,3)$.\n\nThere are five queries. Take the first query as an example.\n\nThe first query removes the doll with index $1$, and asks for the maximum value when the budget is $10$. The remaining dolls are $(2,3,4)$, $(4,1,2)$, $(2,1,1)$, $(3,2,3)$. If you buy $4$ copies of doll $0$ (i.e., all of them), and then buy one copy of doll $3$, you spend exactly $10$ and the total value is $13$. It can be proved that there is no better solution.\n\nNote that you do not have to buy all available copies of a doll.\n\nConstraints.\n\n- For $10\\%$ of the testdata, it is guaranteed that $n \\leq 10$.\n- Additionally, for $20\\%$ of the testdata, it is guaranteed that $n \\leq 100$, $c_i = 1$, $q \\leq 100$.\n- Additionally, for $20\\%$ of the testdata, it is guaranteed that $n \\leq 100$, $q \\leq 100$.\n- Additionally, for $30\\%$ of the testdata, it is guaranteed that $c_i = 1$.\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 1000$, $1 \\leq q \\leq 3\\times 10^5$, $1 \\leq a_i,b_i,c_i \\leq 100$, $0 \\leq d_i < n$, $0 \\leq e_i \\leq 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2013] Eden 的新背包问题", "background": "“ 寄 没 有 地 址 的 信 ，这 样 的 情 绪 有 种 距 离 ，你 放 着 谁 的 歌 曲 ，是 怎 样 的 心 情 。 能 不 能 说 给 我 听 。”", "description": "失忆的 Eden 总想努力地回忆起过去，然而总是只能清晰地记得那种思念的感觉，却不能回忆起她的音容笑貌。\n\n记忆中，她总是喜欢给 Eden 出谜题：在 valentine's day 的夜晚，两人在闹市中闲逛时，望着礼品店里精巧玲珑的各式玩偶，她突发奇想，问了 Eden 这样的一个问题：有 $n$ 个玩偶，每个玩偶有对应的价值、价钱，每个玩偶都可以被买有限次，在携带的价钱 $m$ 固定的情况下，如何选择买哪些玩偶以及每个玩偶买多少个，才能使得选择的玩偶总价钱不超过 $m$，且价值和最大。\n\n众所周知的，这是一个很经典的多重背包问题，Eden 很快解决了，不过她似乎因为自己的问题被飞快解决感到了一丝不高兴，于是她希望把问题加难：多次询问，每次询问都将给出新的总价钱，并且会去掉某个玩偶（即这个玩偶不能被选择），再问此时的多重背包的答案（即前一段所叙述的问题）。\n\n这下 Eden 犯难了，不过 Eden 不希望自己被难住，你能帮帮他么？", "inputFormat": "第一行有一个整数，代表玩偶的个数 $n$，玩偶从 $0$ 开始编号。\n\n第二行开始后面的 $n$ 行，每行三个整数，第 $(i + 2)$ 行的整数  $a_i, b_i, c_i$，分别表示买一个第 $i$ 个玩偶需要的价钱，获得的价值以及第 $i$ 个玩偶的限购次数。\n\n接下来的一行有一个整数 $q$，表示询问次数。\n\n接下来 $q$ 行，每行两个整数 $d_i, e_i$，表示每个询问去掉的是哪个玩偶（注意玩偶从 $0$ 开始编号）以及该询问对应的新的总价钱数。（去掉操作不保留，即不同询问互相独立）。", "outputFormat": "输出 $q$ 行，第 $i$ 行输出对于第 $i$ 个询问的答案。", "hint": "#### 样例解释\n\n一共五种玩偶，分别的价钱价值和限购次数为 $(2,3,4)$， $(1,2,1)$， $(4,1,2)$， $(2,1,1)$， $(3,2,3)$。\n\n五个询问，以第一个询问为例。\n\n第一个询问表示的是去掉编号为 $1$ 的玩偶， 且拥有的钱数为 $10$ 时可以获得的最大价值，则此时剩余玩偶为 $(2,3,4$)，$(4,1,2)$， $(2,1,1)$，$(3,2,3)$，若把编号为 $0$ 的玩偶买 $4$ 个（即全买了），然后编号为 $3$ 的玩偶 买一个，则刚好把 $10$ 元全部花完，且总价值为 $13$。可以证明没有更优的方案了。\n\n注意买某种玩偶不一定要买光。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $10\\%$ 的数据，保证 $n \\leq 10$。\n- 另外存在 $20\\%$ 的数据，保证  $n \\leq 100$，$c_i = 1$，$q \\leq 100$。\n- 另外存在 $20\\%$ 的数据，保证 $n \\leq 100$，$q \\leq 100$。\n- 另外存在 $30\\%$ 的数据，保证 $c_i = 1$。\n- 对于 $100\\%$ 的数据，保证  $1 \\leq n \\leq 1000$，$1 \\leq q \\leq 3\\times 10^5$， $1 \\leq a_i,b_i,c_i \\leq 100$，$0 \\leq d_i < n$，$0 \\leq e_i \\leq 1000$。\n\n", "locale": "zh-CN"}}}
{"pid": "P4096", "type": "P", "difficulty": 5, "samples": [["7 \n1 \n1 \n2 \n2 \n3 \n3", "4 4 0 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "博弈论", "2013", "各省省选", "河北", "博弈树"], "title": "[HEOI2013] Eden 的博弈树", "background": "", "description": "对于有两个玩家的，状态透明且状态转移确定的博弈游戏，博弈树是常用的分析工具。博弈树是一棵有根树，其中的节点为游戏的状态。若节点 B 的父亲是 A，则说明状态 A 能通过一次决策转移到状态 B。每个状态都有一个唯一的决策方，即这个状态下应该由哪一方做出决策。我们规定双方在任何时候都是轮流做出决策的，即树上相邻节点的决策方总是不相同的。\n\n在这个问题中，我们只关心两个玩家的胜负情况，且规定游戏不会出现平局。\n\n我们称两个玩家分别为黑方和白方，其中根节点的决策方为黑方。显然每个节点只有两个状态：黑方胜和白方胜。若某内节点（即存在后继节点的节点）的决策方为黑方，则该节点为黑方胜的充要条件为它的儿子中存在黑方胜的节点，反之亦然。求解博弈树即为判明博弈树根节点的状态。\n\n如果我们得知了所有叶节点（即无后继节点的节点）的状态，那么博弈树就很容易求解了。但是现在的情况是所有叶节点的状态均为未知的，需要进一步的计算。对于一个由叶节点构成的集合 $S$，如果 $S$ 中的节点均被判明为黑方胜，就可以断言根节点为黑方胜的话，则称 $S$ 为一个黑方胜集合。对于黑方胜集合 $S$， 如果对于任意的黑方胜集合 $S'$ 均满足 $|S| \\le |S'|$（$|S|$ 表示集合 $S$ 中的元素数目）， 则称 $S$ 为一个最小黑方胜集合。同样地，也可以定义白方胜集合和最小白方胜集合。\n\nEden 最近在研究博弈树问题。他发现，如果一个叶节点既属于某一个最小黑方胜集合，又属于一个最小白方胜集合，那么求解这个节点的状态显然最有益于求解根节点的状态。像这样的叶节点就称之为关键叶节点。对于一棵给定的博弈树，Eden 想要知道哪些叶节点是关键叶节点。\n", "inputFormat": "每个测试点包含一组测试数据。\n\n测试数据的第一行包含一个正整数 $n$，表示博弈树的节点数目。节点从 $1$ 到 $n$ 编号，且 $1$ 号节点为根节点。\n\n之后 $n - 1$ 行，每行包含一个正整数。第 $i$ 行的正整数表示节点 $i$ 的父节点的编号。\n", "outputFormat": "在一行内输出三个空格分隔的正整数，分别是编号最小的关键叶节点的编号，关键叶节点的数目和所有关键叶节点的编号的异或和。\n", "hint": "【样例说明】\n\n  ![](https://cdn.luogu.com.cn/upload/pic/13130.png) \n\n如图所示，黑色节点表示决策方为黑方的节点，反之亦然\n\n所有的最小黑方胜集合为 $\\{4, 5\\}$ 和 $\\{6, 7\\}$。\n\n所有的最小白方胜集合为 $\\{4, 6\\}$，$\\{4, 7\\}$，$\\{5, 6\\}$ 和 $\\{5, 7\\}$。\n\n所以关键叶节点的集合为 $\\{4, 5, 6, 7\\}$。\n\n- 对于 $30\\%$ 的数据，$n \\le 100$；\n- 对于 $40\\%$ 的数据，$n \\le 1000$；\n- 对于 $50\\%$ 的数据，$n \\le 10 ^ 4$，且树是随机生成的；\n- 对于 $100\\%$ 的数据，$1 \\le n \\le 2\\times 10 ^ 5$，且对于节点 $i$（$i \\ne 1$），其父节点的编号小于 $i$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2013] Eden's Game Tree", "background": "# Description\n\nFor a two-player, perfect-information, deterministic game, a game tree is a common analysis tool. A game tree is a rooted tree whose nodes are game states. If node B’s parent is A, then state A can transition to state B with a single decision. Each state has a unique player to move, i.e., exactly one side should make the move at that state. We assume the two players alternate moves at all times, meaning adjacent nodes in the tree always have different players to move.\n\nIn this problem, we only care about which player wins, and we assume the game cannot end in a draw.\n\nWe call the two players Black and White, and the root’s player to move is Black. Clearly, each node has exactly two possible outcomes: Black wins or White wins. If an internal node (i.e., a node that has children) is a Black-to-move node, then this node is winning for Black if and only if at least one of its children is winning for Black; conversely for a White-to-move node. Solving the game tree means determining the outcome at the root.\n\nIf we already knew the outcomes of all leaves (nodes without children), the game tree would be easy to solve. However, here the outcomes of all leaves are unknown and need further computation. For a set of leaves $S$, if knowing that every node in $S$ is a win for Black is sufficient to assert that the root is a win for Black, then $S$ is called a Black-winning set. Among Black-winning sets $S$, if for any other Black-winning set $S'$ it holds that $|S| \\le |S'|$ (where $|S|$ denotes the number of elements in $S$), then $S$ is a minimal Black-winning set. Similarly, we can define White-winning sets and minimal White-winning sets.\n\nEden is studying game trees. He noticed that if a leaf belongs to some minimal Black-winning set and also to some minimal White-winning set, then determining this leaf’s outcome is clearly most helpful for determining the root’s outcome. Such leaves are called critical leaf nodes. For a given game tree, Eden wants to know which leaves are critical leaf nodes.", "description": "", "inputFormat": "", "outputFormat": "Print three space-separated positive integers on a single line: the index of the critical leaf node with the smallest index, the number of critical leaf nodes, and the bitwise XOR of the indices of all critical leaf nodes.", "hint": "[Sample explanation]\n\n  ![](https://cdn.luogu.com.cn/upload/pic/13130.png) \n\nAs shown, black nodes indicate Black-to-move nodes, and white nodes indicate White-to-move nodes.\n\nAll minimal Black-winning sets are $\\{4, 5\\}$ and $\\{6, 7\\}$.\n\nAll minimal White-winning sets are $\\{4, 6\\}$, $\\{4, 7\\}$, $\\{5, 6\\}$, and $\\{5, 7\\}$.\n\nTherefore, the set of critical leaf nodes is $\\{4, 5, 6, 7\\}$.\n\n- For $30\\%$ of the testdata, $n \\le 100$.\n- For $40\\%$ of the testdata, $n \\le 1000$.\n- For $50\\%$ of the testdata, $n \\le 10 ^ 4$, and the tree is randomly generated.\n- For $100\\%$ of the testdata, $1 \\le n \\le 2\\times 10 ^ 5$, and for node $i$ ($i \\ne 1$), the index of its parent is less than $i$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2013] Eden 的博弈树", "background": "", "description": "对于有两个玩家的，状态透明且状态转移确定的博弈游戏，博弈树是常用的分析工具。博弈树是一棵有根树，其中的节点为游戏的状态。若节点 B 的父亲是 A，则说明状态 A 能通过一次决策转移到状态 B。每个状态都有一个唯一的决策方，即这个状态下应该由哪一方做出决策。我们规定双方在任何时候都是轮流做出决策的，即树上相邻节点的决策方总是不相同的。\n\n在这个问题中，我们只关心两个玩家的胜负情况，且规定游戏不会出现平局。\n\n我们称两个玩家分别为黑方和白方，其中根节点的决策方为黑方。显然每个节点只有两个状态：黑方胜和白方胜。若某内节点（即存在后继节点的节点）的决策方为黑方，则该节点为黑方胜的充要条件为它的儿子中存在黑方胜的节点，反之亦然。求解博弈树即为判明博弈树根节点的状态。\n\n如果我们得知了所有叶节点（即无后继节点的节点）的状态，那么博弈树就很容易求解了。但是现在的情况是所有叶节点的状态均为未知的，需要进一步的计算。对于一个由叶节点构成的集合 $S$，如果 $S$ 中的节点均被判明为黑方胜，就可以断言根节点为黑方胜的话，则称 $S$ 为一个黑方胜集合。对于黑方胜集合 $S$， 如果对于任意的黑方胜集合 $S'$ 均满足 $|S| \\le |S'|$（$|S|$ 表示集合 $S$ 中的元素数目）， 则称 $S$ 为一个最小黑方胜集合。同样地，也可以定义白方胜集合和最小白方胜集合。\n\nEden 最近在研究博弈树问题。他发现，如果一个叶节点既属于某一个最小黑方胜集合，又属于一个最小白方胜集合，那么求解这个节点的状态显然最有益于求解根节点的状态。像这样的叶节点就称之为关键叶节点。对于一棵给定的博弈树，Eden 想要知道哪些叶节点是关键叶节点。\n", "inputFormat": "每个测试点包含一组测试数据。\n\n测试数据的第一行包含一个正整数 $n$，表示博弈树的节点数目。节点从 $1$ 到 $n$ 编号，且 $1$ 号节点为根节点。\n\n之后 $n - 1$ 行，每行包含一个正整数。第 $i$ 行的正整数表示节点 $i$ 的父节点的编号。\n", "outputFormat": "在一行内输出三个空格分隔的正整数，分别是编号最小的关键叶节点的编号，关键叶节点的数目和所有关键叶节点的编号的异或和。\n", "hint": "【样例说明】\n\n  ![](https://cdn.luogu.com.cn/upload/pic/13130.png) \n\n如图所示，黑色节点表示决策方为黑方的节点，反之亦然\n\n所有的最小黑方胜集合为 $\\{4, 5\\}$ 和 $\\{6, 7\\}$。\n\n所有的最小白方胜集合为 $\\{4, 6\\}$，$\\{4, 7\\}$，$\\{5, 6\\}$ 和 $\\{5, 7\\}$。\n\n所以关键叶节点的集合为 $\\{4, 5, 6, 7\\}$。\n\n- 对于 $30\\%$ 的数据，$n \\le 100$；\n- 对于 $40\\%$ 的数据，$n \\le 1000$；\n- 对于 $50\\%$ 的数据，$n \\le 10 ^ 4$，且树是随机生成的；\n- 对于 $100\\%$ 的数据，$1 \\le n \\le 2\\times 10 ^ 5$，且对于节点 $i$（$i \\ne 1$），其父节点的编号小于 $i$。\n", "locale": "zh-CN"}}}
{"pid": "P4097", "type": "P", "difficulty": 6, "samples": [["6 \n1 8 5 10 8 \n1 6 7 2 6 \n0 2 \n0 9 \n1 4 7 6 7 \n0 5", "2 \n0 \n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2013", "线段树", "各省省选", "递归", "河北", "李超线段树", "模板题"], "title": "【模板】李超线段树 / [HEOI2013] Segment", "background": "", "description": "要求在平面直角坐标系下维护两个操作：\n\n1. 在平面上加入一条线段。记第 $i$ 条被插入的线段的标号为 $i$。\n2. 给定一个数 $k$，询问与直线 $x = k$ 相交的线段中，交点纵坐标最大的线段的编号。", "inputFormat": "**本题输入强制在线**。\n\n输入的第一行是一个整数 $n$，代表操作的个数。\n\n接下来 $n$ 行，每行若干个用空格隔开的整数，第 $i + 1$ 行的第一个整数为 $op$，代表第 $i$ 次操作的类型。\n\n若 $op = 0$，则后跟一个整数 $k$，代表本次操作为查询所所有与直线 $x = (k + lastans - 1) \\bmod 39989 + 1$ 相交的线段中，交点纵坐标最大的线段编号。\n\n若 $op = 1$，则后跟四个整数 $x_0, y_0, x_1, y_1$，记 $x_i' = (x_i + lastans - 1) \\bmod 39989 + 1$，$y_i' = (y_i + lastans - 1) \\bmod 10^9 + 1$。本次操作为插入一条两端点分别为 $(x_0', y_0')$，$(x_1',y_1')$ 的线段。\n\n其中 $lastans$ 为上次询问的答案，初始时，$lastans = 0$。", "outputFormat": "对于每次查询，输出一行一个整数，代表交点纵坐标最大的线段的编号。若不存在任何一条线段与查询直线有交，则输出 $0$；若有多条线段与查询直线的交点纵坐标都是最大的，则输出编号最小的线段，同时 $lastans$ 也应更新为编号最小的一条线段。", "hint": "### 样例 $1$ 解释\n\n对于第一次操作，解密后为 `1 8 5 10 8`。\n\n对于第二次操作，解密后为 `1 6 7 2 6`。\n\n对于第三次操作，解密后为 `0 2`，此时 $lastans$ 被更新为 $2$。\n\n对于第四次操作，解密后为 `0 11`，此时 $lastans$ 被更新为 $0$。\n\n对于第五次操作，解密后为 `1 4 7 6 7`。\n\n对于第六次操作，解密后为 `0 5`。\n\n### 数据范围与约定\n\n对于 $30\\%$ 的数据，保证 $n \\leq 10^3$。\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^5$，$1 \\leq k, x_0, x_1 \\leq 39989$，$1 \\leq y_0, y_1 \\leq 10^9$。\n\n### 提示\n\n不保证 $x_0 \\neq x_1$。对于一条 $x_0' = x_1'$ 的线段，认为其与 $x = x_0'$ 的交点为其两端点中纵坐标较大的端点。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Li Chao Segment Tree / [HEOI2013] Segment", "background": "", "description": "Maintain two operations in the 2D Cartesian coordinate system:\n\n1. Insert a line segment into the plane. The index of the i-th inserted segment is $i$.\n2. Given a number $k$, query among all segments that intersect the line $x = k$, and return the index of the segment whose intersection point has the largest $y$-coordinate.", "inputFormat": "This problem enforces online input.\n\nThe first line contains an integer $n$, the number of operations.\n\nThen $n$ lines follow. On each line there are several integers separated by spaces. On the $(i + 1)$-th line, the first integer is $op$, indicating the type of the $i$-th operation.\n\n- If $op = 0$, then it is followed by an integer $k$. This operation queries among all segments that intersect the line $x = (k + lastans - 1) \\bmod 39989 + 1$, and returns the index of the segment whose intersection point has the largest $y$-coordinate.\n- If $op = 1$, then it is followed by four integers $x_0, y_0, x_1, y_1$. Define $x_i' = (x_i + lastans - 1) \\bmod 39989 + 1$, $y_i' = (y_i + lastans - 1) \\bmod 10^9 + 1$. This operation inserts a segment with endpoints $(x_0', y_0')$ and $(x_1', y_1')$.\n\nHere $lastans$ is the answer to the previous query. Initially, $lastans = 0$.", "outputFormat": "For each query, output one line containing a single integer: the index of the segment whose intersection point has the largest $y$-coordinate. If no segment intersects the query line, output $0$. If multiple segments have the same maximum intersection $y$-coordinate, output the smallest index among them, and $lastans$ should also be updated to this smallest index.", "hint": "### Explanation for Sample $1$\n\nFor the first operation, after decoding it becomes `1 8 5 10 8`.\n\nFor the second operation, after decoding it becomes `1 6 7 2 6`.\n\nFor the third operation, after decoding it becomes `0 2`, and $lastans$ is updated to $2$.\n\nFor the fourth operation, after decoding it becomes `0 11`, and $lastans$ is updated to $0$.\n\nFor the fifth operation, after decoding it becomes `1 4 7 6 7`.\n\nFor the sixth operation, after decoding it becomes `0 5`.\n\n### Constraints\n\nFor $30\\%$ of the testdata, $n \\leq 10^3$ is guaranteed.\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 10^5$, $1 \\leq k, x_0, x_1 \\leq 39989$, $1 \\leq y_0, y_1 \\leq 10^9$.\n\n### Notes\n\nIt is not guaranteed that $x_0 \\neq x_1$. For a segment with $x_0' = x_1'$, its intersection with $x = x_0'$ is defined to be the endpoint with the larger $y$-coordinate.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】李超线段树 / [HEOI2013] Segment", "background": "", "description": "要求在平面直角坐标系下维护两个操作：\n\n1. 在平面上加入一条线段。记第 $i$ 条被插入的线段的标号为 $i$。\n2. 给定一个数 $k$，询问与直线 $x = k$ 相交的线段中，交点纵坐标最大的线段的编号。", "inputFormat": "**本题输入强制在线**。\n\n输入的第一行是一个整数 $n$，代表操作的个数。\n\n接下来 $n$ 行，每行若干个用空格隔开的整数，第 $i + 1$ 行的第一个整数为 $op$，代表第 $i$ 次操作的类型。\n\n若 $op = 0$，则后跟一个整数 $k$，代表本次操作为查询所所有与直线 $x = (k + lastans - 1) \\bmod 39989 + 1$ 相交的线段中，交点纵坐标最大的线段编号。\n\n若 $op = 1$，则后跟四个整数 $x_0, y_0, x_1, y_1$，记 $x_i' = (x_i + lastans - 1) \\bmod 39989 + 1$，$y_i' = (y_i + lastans - 1) \\bmod 10^9 + 1$。本次操作为插入一条两端点分别为 $(x_0', y_0')$，$(x_1',y_1')$ 的线段。\n\n其中 $lastans$ 为上次询问的答案，初始时，$lastans = 0$。", "outputFormat": "对于每次查询，输出一行一个整数，代表交点纵坐标最大的线段的编号。若不存在任何一条线段与查询直线有交，则输出 $0$；若有多条线段与查询直线的交点纵坐标都是最大的，则输出编号最小的线段，同时 $lastans$ 也应更新为编号最小的一条线段。", "hint": "### 样例 $1$ 解释\n\n对于第一次操作，解密后为 `1 8 5 10 8`。\n\n对于第二次操作，解密后为 `1 6 7 2 6`。\n\n对于第三次操作，解密后为 `0 2`，此时 $lastans$ 被更新为 $2$。\n\n对于第四次操作，解密后为 `0 11`，此时 $lastans$ 被更新为 $0$。\n\n对于第五次操作，解密后为 `1 4 7 6 7`。\n\n对于第六次操作，解密后为 `0 5`。\n\n### 数据范围与约定\n\n对于 $30\\%$ 的数据，保证 $n \\leq 10^3$。\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^5$，$1 \\leq k, x_0, x_1 \\leq 39989$，$1 \\leq y_0, y_1 \\leq 10^9$。\n\n### 提示\n\n不保证 $x_0 \\neq x_1$。对于一条 $x_0' = x_1'$ 的线段，认为其与 $x = x_0'$ 的交点为其两端点中纵坐标较大的端点。", "locale": "zh-CN"}}}
{"pid": "P4098", "type": "P", "difficulty": 6, "samples": [["5 \n9 2 1 4 7", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2013", "各省省选", "河北", "枚举", "可持久化", "字典树 Trie"], "title": "[HEOI2013] ALO", "background": "", "description": "Welcome to ALO (Arithmetic and Logistic Online）。这是一个 VR MMORPG，如名字所见，到处充满了数学的谜题。\n\n现在你拥有 $n$ 颗宝石，第 $i$ 颗宝石有一个能量密度，记为 $a_i$，这些宝石的能量密度**两两不同**。现在你可以选取**连续**的一些宝石（必须多于一个）进行融合，设他们的能量密度为 $a_i,a_{i+1},\\cdots,a_j$，则融合而成的宝石的能量密度为这些宝石中能量密度的次大值与其他任意一颗宝石的能量密度按位异或的值的最大值。即，假设该段宝石能量密度次大值为 $k$，则生成的宝石的能量密度为 $\\max\\{k\\oplus a_p\\mid a_p\\ne k, i\\le p\\le j\\}$。\n\n现在你需要知道你怎么选取需要融合的宝石，才能使生成的宝石能量密度最大。", "inputFormat": "第一行，一个整数 $n$，表示宝石个数。\n\n第二行，$n$ 个整数，分别表示 $a_1$ 至 $a_n$，表示每颗宝石的能量密度，保证对于 $i\\ne j$ 有 $a_i\\ne a_j$。", "outputFormat": "输出一行一个整数，表示最大能生成的宝石能量密度。\n", "hint": "### 样例解释\n\n选择区间 $[1,5]$，最大值为 $7\\oplus 9 = 14$。\n\n### 数据规模与约定\n\n- 对于 $20\\%$ 的数据有 $n\\le 100$；\n- 对于 $50\\%$ 的数据有 $n\\le 2000$；\n- 对于 $100\\%$ 的数据有 $1\\le n\\le 50000$，$0\\le a_i\\le 10^9$。\n\n2023.4.28：添加两组 hack 数据，不计分。", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2013] ALO", "background": "", "description": "Welcome to ALO (Arithmetic and Logistic Online). This is a VR MMORPG. As the name suggests, it is full of math puzzles.\n\nYou have $n$ gems. The $i$-th gem has an energy density $a_i$, and all energy densities are pairwise distinct. You may select a contiguous segment of gems (with at least two gems) to fuse. Suppose their energy densities are $a_i, a_{i+1}, \\cdots, a_j$. The fused gem’s energy density is the maximum value of the bitwise XOR between the second largest energy density in this segment and any other gem in the same segment. That is, if the second largest in this segment is $k$, the generated energy density equals $\\max\\{k \\oplus a_p \\mid a_p \\ne k,\\ i \\le p \\le j\\}$.\n\nFind how to choose the segment to maximize the fused gem’s energy density.", "inputFormat": "The first line contains an integer $n$, the number of gems.\n\nThe second line contains $n$ integers, $a_1$ through $a_n$, the energy density of each gem. It is guaranteed that for $i \\ne j$ we have $a_i \\ne a_j$.", "outputFormat": "Output one integer, the maximum possible fused gem energy density.", "hint": "### Sample Explanation\n\nChoose the segment $[1, 5]$. The maximum is $7 \\oplus 9 = 14$.\n\n### Constraints\n\n- For $20\\%$ of the testdata, $n \\le 100$.\n- For $50\\%$ of the testdata, $n \\le 2000$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 50000$, $0 \\le a_i \\le 10^9$.\n\n2023-04-28: Added two hack testdata, not scored.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2013] ALO", "background": "", "description": "Welcome to ALO (Arithmetic and Logistic Online）。这是一个 VR MMORPG，如名字所见，到处充满了数学的谜题。\n\n现在你拥有 $n$ 颗宝石，第 $i$ 颗宝石有一个能量密度，记为 $a_i$，这些宝石的能量密度**两两不同**。现在你可以选取**连续**的一些宝石（必须多于一个）进行融合，设他们的能量密度为 $a_i,a_{i+1},\\cdots,a_j$，则融合而成的宝石的能量密度为这些宝石中能量密度的次大值与其他任意一颗宝石的能量密度按位异或的值的最大值。即，假设该段宝石能量密度次大值为 $k$，则生成的宝石的能量密度为 $\\max\\{k\\oplus a_p\\mid a_p\\ne k, i\\le p\\le j\\}$。\n\n现在你需要知道你怎么选取需要融合的宝石，才能使生成的宝石能量密度最大。", "inputFormat": "第一行，一个整数 $n$，表示宝石个数。\n\n第二行，$n$ 个整数，分别表示 $a_1$ 至 $a_n$，表示每颗宝石的能量密度，保证对于 $i\\ne j$ 有 $a_i\\ne a_j$。", "outputFormat": "输出一行一个整数，表示最大能生成的宝石能量密度。\n", "hint": "### 样例解释\n\n选择区间 $[1,5]$，最大值为 $7\\oplus 9 = 14$。\n\n### 数据规模与约定\n\n- 对于 $20\\%$ 的数据有 $n\\le 100$；\n- 对于 $50\\%$ 的数据有 $n\\le 2000$；\n- 对于 $100\\%$ 的数据有 $1\\le n\\le 50000$，$0\\le a_i\\le 10^9$。\n\n2023.4.28：添加两组 hack 数据，不计分。", "locale": "zh-CN"}}}
{"pid": "P4099", "type": "P", "difficulty": 6, "samples": [["2 \n5 \n0 < 2 \n1 < 2 \n2 < 3 \n2 < 4 \n4 \n0 < 1 \n0 < 2 \n0 < 3", "4 \n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2013", "各省省选", "河北", "枚举", "拓扑排序", "前缀和"], "title": "[HEOI2013] SAO", "background": null, "description": "Welcome to SAO ( Strange and Abnormal Online)。这是一个 VR MMORPG， 含有 $n$ 个关卡。但是，挑战不同关卡的顺序是一个很大的问题。\n\n某款游戏有 $n-1$ 个对于挑战关卡的限制，诸如第 $i$ 个关卡必须在第 $j$ 个关卡前挑战，或者完成了第 $k$ 个关卡才能挑战第 $l$ 个关卡。并且，如果不考虑限制的方向性，那么在这 $n-1$ 个限制的情况下，任何两个关卡都存在某种程度的关联性。即，我们不能把所有关卡分成两个非空且不相交的子集，使得这两个子集之间没有任何限制。", "inputFormat": "第一行，一个整数 $T$，表示数据组数。\n\n对于每组数据，第一行一个整数 $n$，表示关卡数。接下来 $n - 1$ 行，每行为 $i \\text{ sign } j$，其中 $0 \\leq i, j \\leq n - 1$ 且 $i \\neq j$，$\\text{sign}$ 为 $\\tt{<}$ 或者 $\\tt{>}$，表示第 $i$ 个关卡必须在第 $j$ 个关卡前或后完成。", "outputFormat": "对于每个数据，输出一行一个整数，为攻克关卡的顺序方案个数，$\\bmod (10^9+7)$ 输出。", "hint": "对于 $20\\%$ 的数据有 $n \\le 10$。\n\n对于 $40\\%$ 的数据有 $n \\le 100$。\n\n对于另外 $20\\%$ 的数据有，保证数据中 sign 只会是 <，并且 $i<j$。\n\n对于 $100\\%$ 的数据有 $T \\le 5$，$1 \\le n \\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2013] SAO", "background": "", "description": "Welcome to SAO (Strange and Abnormal Online). This is a VR MMORPG with $n$ levels. However, deciding the order to challenge the levels is a big problem.\n\nThe game imposes $n-1$ constraints on the order of levels, such as level $i$ must be challenged before level $j$, or you can attempt level $l$ only after finishing level $k$. Moreover, if we ignore the directions of the constraints, then under these $n-1$ constraints, any two levels are connected in some way. That is, we cannot partition all levels into two nonempty disjoint subsets such that there is no constraint between the two subsets.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nFor each test case, the first line contains an integer $n$, the number of levels. Then follow $n - 1$ lines, each in the form $i \\text{ sign } j$, where $0 \\leq i, j \\leq n - 1$ and $i \\neq j$, and $\\text{sign}$ is $\\tt{<}$ or $\\tt{>}$, meaning level $i$ must be completed before (if $\\text{sign}$ is $\\tt{<}$) or after (如果 $\\text{sign}$ is $\\tt{>}$) level $j$.", "outputFormat": "For each test case, output one integer on a single line: the number of valid orders to conquer the levels, output $\\bmod (10^9+7)$.", "hint": "- For $20\\%$ of the testdata, $n \\le 10$.\n- For $40\\%$ of the testdata, $n \\le 100$.\n- For another $20\\%$ of the testdata, it is guaranteed that $\\text{sign}$ is only $\\tt{<}$ and $i<j$.\n- For $100\\%$ of the testdata, $T \\le 5$ and $1 \\le n \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2013] SAO", "background": null, "description": "Welcome to SAO ( Strange and Abnormal Online)。这是一个 VR MMORPG， 含有 $n$ 个关卡。但是，挑战不同关卡的顺序是一个很大的问题。\n\n某款游戏有 $n-1$ 个对于挑战关卡的限制，诸如第 $i$ 个关卡必须在第 $j$ 个关卡前挑战，或者完成了第 $k$ 个关卡才能挑战第 $l$ 个关卡。并且，如果不考虑限制的方向性，那么在这 $n-1$ 个限制的情况下，任何两个关卡都存在某种程度的关联性。即，我们不能把所有关卡分成两个非空且不相交的子集，使得这两个子集之间没有任何限制。", "inputFormat": "第一行，一个整数 $T$，表示数据组数。\n\n对于每组数据，第一行一个整数 $n$，表示关卡数。接下来 $n - 1$ 行，每行为 $i \\text{ sign } j$，其中 $0 \\leq i, j \\leq n - 1$ 且 $i \\neq j$，$\\text{sign}$ 为 $\\tt{<}$ 或者 $\\tt{>}$，表示第 $i$ 个关卡必须在第 $j$ 个关卡前或后完成。", "outputFormat": "对于每个数据，输出一行一个整数，为攻克关卡的顺序方案个数，$\\bmod (10^9+7)$ 输出。", "hint": "对于 $20\\%$ 的数据有 $n \\le 10$。\n\n对于 $40\\%$ 的数据有 $n \\le 100$。\n\n对于另外 $20\\%$ 的数据有，保证数据中 sign 只会是 <，并且 $i<j$。\n\n对于 $100\\%$ 的数据有 $T \\le 5$，$1 \\le n \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P4100", "type": "P", "difficulty": 7, "samples": [["3 \n1 0 0 \n0 1 0 \n0 0 1 \n2 3 0 \n0 7 8 \n0 0 9", "TAK \n1 \n2 \n3"], ["4 \n2 0 1 3 \n0 1 0 4 \n1 9 9 4 \n0 4 1 7 \n1 10 9 8 \n1 13 10 11 \n1 2 1 5 \n2 1 1 7", "TAK \n3 \n4 \n1 \n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "各省省选", "河北"], "title": "[HEOI2013] 钙铁锌硒维生素", "background": "", "description": "银河队选手名单出来了！小林，作为特聘的营养师，将负责银河队选手参加宇宙比赛的饮食。\n\n众所周知，前往宇宙的某个星球，通常要花费好长好长的时间，人体情况在这之间会发生变化，因此，需要根据每天的情况搭配伙食，来保证营养。\n\n小林把人体需要的营养分成了 $n$ 种，这些营养包括但不限于铁，钙。他准备 了 $2$ 套厨师机器人，一套厨师机器人有 $n$ 个，每个厨师机器人只会做一道菜，这道菜一斤能提供第 $i$ 种营养 $x_i$ 微克。想要吃这道菜的时候，只要输入一个数，就 能吃到对应数量的这道菜了。为防止摄入过量对身体造成的伤害，每个机器人还有防过量摄入药，只要输入一个数，就能生成一定剂量的药，吃了这些药，就能 减少相当于食用对应数目的这道菜提供的营养。\n\n小林之所以准备 $2$ 套厨师机器人，正是因为旅途漫漫，难以预计，也许某一 个厨师机器人在途中坏掉，要是影响了银河队选手的身体，就不好了。因此，第 $2$ 套厨师机器人被用来做第 $1$ 套的备用。小林需要为每一个第 $1$ 套厨师机器人选 一个第 $2$ 套厨师机器人作备份，使得当这个机器人坏掉时，用备份顶替，整套厨师机器人仍然能搭配出任何营养需求，而且，每个第 $2$ 套厨师机器人只能当一个第 $1$ 套厨师机器人的备份。\n", "inputFormat": "输入文件的第一行包含一个正整数 $n$。接下来 $n$ 行，每行 $n$ 个整数，表示第 $1$ 套厨师机器人做的菜每一斤提供的每种营养。再接下来 $n$ 行，每行 $n$ 个整数， 表示第 $2$ 套厨师机器人做的菜每一斤提供的每种营养。\n", "outputFormat": "输出文件的第一行是一个字符串，如果无法完成任务，输出 `NIE`，否则输出 `TAK`，并跟着 $n$ 行，第 $i$ 行表示第 $i$ 个第 $1$ 套机器人的备份是哪一个第 $2$ 套机器人。\n\n为了避免麻烦，如果有多种可能的答案，请给出字典序最小的那一组。", "hint": "- 对于 $10\\%$ 的数据，$n = 2$；\n- 对于 $20\\%$ 的数据，$n \\leq 10$；\n- 对于 $40\\%$ 的数据，$n \\leq 30$；\n- 对于 $60\\%$ 的数据，$n \\leq 50$；\n- 对于 $80\\%$ 的数据，$n \\leq 100$；\n- 对于 $100\\%$ 的数据，$1 \\leq n \\leq 300$，所有出现的整数均非负，且不超过 $10\\,000$。", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2013] Calcium, Iron, Zinc, Selenium, Vitamins", "background": "", "description": "The Galaxy Team roster is out. As a specially hired nutritionist, Kobayashi will take charge of the team’s diet for the interstellar competition.\n\nAs we all know, traveling to a certain planet usually takes a very long time. The human body changes during the journey, so meals must be adjusted daily to ensure adequate nutrition.\n\nKobayashi divides the required nutrients into $n$ kinds, including but not limited to iron and calcium. He prepares $2$ sets of chef robots, with $n$ robots in each set. Each robot can cook exactly one dish, and this dish provides $x_i$ micrograms of the $i$-th nutrient per jin (jin). Whenever you want to eat this dish, you can enter a number to get the corresponding amount of this dish. To prevent harm from overdosing, each robot also has anti-overdose medicine. By entering a number, it generates a certain dose of medicine; after taking it, it reduces the nutrients by the same amount as eating the corresponding amount of this dish would provide.\n\nKobayashi prepares $2$ sets precisely because the journey is long and uncertain; a robot may fail during the trip, and it would be bad if that affected the Galaxy Team’s health. Therefore, the second set is used as a backup for the first set. Kobayashi needs to choose, for each robot in the first set, one robot from the second set as its backup, so that if a robot fails, replacing it with its backup still allows the entire set of chef robots to meet any nutritional requirement. Moreover, each robot in the second set can serve as the backup for at most one robot in the first set.", "inputFormat": "The first line contains a positive integer $n$. The next $n$ lines each contain $n$ integers, describing how much of each nutrient is provided per jin by the dishes made by the first set of chef robots. The following $n$ lines each contain $n$ integers, describing the same for the second set of chef robots.", "outputFormat": "The first line contains a string. If the task is impossible, output `NIE`. Otherwise, output `TAK`, followed by $n$ lines; the $i$-th line indicates which robot in the second set is the backup for the $i$-th robot in the first set.\n\nTo avoid trouble, if there are multiple possible answers, output the lexicographically smallest one.", "hint": "- For $10\\%$ of the testdata, $n = 2$.\n- For $20\\%$ of the testdata, $n \\leq 10$.\n- For $40\\%$ of the testdata, $n \\leq 30$.\n- For $60\\%$ of the testdata, $n \\leq 50$.\n- For $80\\%$ of the testdata, $n \\leq 100$.\n- For $100\\%$ of the testdata, $1 \\leq n \\leq 300$. All integers that appear are non-negative and do not exceed $10\\,000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2013] 钙铁锌硒维生素", "background": "", "description": "银河队选手名单出来了！小林，作为特聘的营养师，将负责银河队选手参加宇宙比赛的饮食。\n\n众所周知，前往宇宙的某个星球，通常要花费好长好长的时间，人体情况在这之间会发生变化，因此，需要根据每天的情况搭配伙食，来保证营养。\n\n小林把人体需要的营养分成了 $n$ 种，这些营养包括但不限于铁，钙。他准备 了 $2$ 套厨师机器人，一套厨师机器人有 $n$ 个，每个厨师机器人只会做一道菜，这道菜一斤能提供第 $i$ 种营养 $x_i$ 微克。想要吃这道菜的时候，只要输入一个数，就 能吃到对应数量的这道菜了。为防止摄入过量对身体造成的伤害，每个机器人还有防过量摄入药，只要输入一个数，就能生成一定剂量的药，吃了这些药，就能 减少相当于食用对应数目的这道菜提供的营养。\n\n小林之所以准备 $2$ 套厨师机器人，正是因为旅途漫漫，难以预计，也许某一 个厨师机器人在途中坏掉，要是影响了银河队选手的身体，就不好了。因此，第 $2$ 套厨师机器人被用来做第 $1$ 套的备用。小林需要为每一个第 $1$ 套厨师机器人选 一个第 $2$ 套厨师机器人作备份，使得当这个机器人坏掉时，用备份顶替，整套厨师机器人仍然能搭配出任何营养需求，而且，每个第 $2$ 套厨师机器人只能当一个第 $1$ 套厨师机器人的备份。\n", "inputFormat": "输入文件的第一行包含一个正整数 $n$。接下来 $n$ 行，每行 $n$ 个整数，表示第 $1$ 套厨师机器人做的菜每一斤提供的每种营养。再接下来 $n$ 行，每行 $n$ 个整数， 表示第 $2$ 套厨师机器人做的菜每一斤提供的每种营养。\n", "outputFormat": "输出文件的第一行是一个字符串，如果无法完成任务，输出 `NIE`，否则输出 `TAK`，并跟着 $n$ 行，第 $i$ 行表示第 $i$ 个第 $1$ 套机器人的备份是哪一个第 $2$ 套机器人。\n\n为了避免麻烦，如果有多种可能的答案，请给出字典序最小的那一组。", "hint": "- 对于 $10\\%$ 的数据，$n = 2$；\n- 对于 $20\\%$ 的数据，$n \\leq 10$；\n- 对于 $40\\%$ 的数据，$n \\leq 30$；\n- 对于 $60\\%$ 的数据，$n \\leq 50$；\n- 对于 $80\\%$ 的数据，$n \\leq 100$；\n- 对于 $100\\%$ 的数据，$1 \\leq n \\leq 300$，所有出现的整数均非负，且不超过 $10\\,000$。", "locale": "zh-CN"}}}
{"pid": "P4101", "type": "P", "difficulty": 5, "samples": [["5\n7 3\n1 5\n4 3\n6 1\n2 2", "1\n1\n1\n1\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["博弈论", "2014", "各省省选", "河北"], "title": "[HEOI2014] 人人尽说江南好", "background": "", "description": "小 Z 是一个不折不扣的 ZRP（Zealot Round-game Player，回合制游戏狂热玩家），最近他想起了小时候在江南玩过的一个游戏。\n\n在过去，人们是要边玩游戏边填词的，比如这首《菩萨蛮》就是当年韦庄在玩游戏时填的：人 人 尽 说 江 南 好， 游 人 只 合 江 南 老。\n\n然而我们今天不太关心人们填的词是什么，我们只关心小 Z 那时玩过的游戏。游戏的规则是这样的，给定 $n$ 堆石子，每堆石子一开始只有 $1$ 个。小 Z 和他的小伙伴轮流操作，小 Z 先行操作。操作可以将任意两堆石子合并成为一堆，当谁不再能操作的时候，谁就输掉了。\n\n不过，当一堆石子堆的太高时可能发生危险，因此小 Z 和他的小伙伴规定，任何时刻任意一堆石子的数量不能超过 $m$。即假如现在有两堆石子分别有 $a$ 个和 $b$ 个，而且 $a + b > m$，那么这两堆石子就不能合成一堆。\n\n小 Z 和他的小伙伴都是很聪明的，所以他们总是会选择对自己最有利的策略。现在小 Z 想要知道，在这种情况下，对于一个给定的 $n$ 和 $m$，到底是谁能够获得胜利呢？\n", "inputFormat": "本题包括多组数据  数据第一行为一个数 $T$，为数据组数。\n\n以下 $T$ 行，每行两个正整数 $n,m$。\n", "outputFormat": "输出 $T$ 行，每行为 $0$ 或 $1$，如果为 $0$ 意为小 Z（即先手）会取得胜利，为 $1$ 则为后手会取得胜利。\n", "hint": "对于 $10 \\%$ 的数据，$m \\ge n$；  \n对于 $20 \\%$ 的数据，$n, m \\le 10$；  \n对于 $30 \\%$ 的数据，$n, m \\le 50$，$2 \\cdot m \\ge n$；  \n对于 $50 \\%$ 的数据，$n, m \\le 100$；  \n对于 $70 \\%$ 的数据，$n, m \\le {10}^6$；  \n对于 $100 \\%$ 的数据，$1 \\le n, m \\le {10}^9$，$1 \\le T \\le 100$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2014] Everyone Says Jiangnan Is Good", "background": "", "description": "Xiao Z is a hardcore ZRP (Zealot Round-game Player), and he recently recalled a game he played in Jiangnan when he was a child.\n\nIn the past, people would compose lyrics while playing games. For example, this piece “Pusaman (Púsà Mán)” was written by Wei Zhuang while playing: 人 人 尽 说 江 南 好， 游 人 只 合 江 南 老。\n\nHowever, today we are not very concerned about what people wrote. We only care about the game that Xiao Z played. The rules are as follows: there are $n$ piles of stones, each initially having $1$ stone. Xiao Z and his friend take turns, and Xiao Z moves first. A move can merge any two piles into one pile. Whoever cannot move loses.\n\nHowever, if a pile becomes too high, it might be dangerous. Therefore, they agreed that at any time, the number of stones in any pile cannot exceed $m$. That is, if there are two piles with $a$ and $b$ stones and $a + b > m$, then these two piles cannot be merged.\n\nXiao Z and his friend are very smart, so they always choose optimal strategies. Now Xiao Z wants to know, given $n$ and $m$, who will win.", "inputFormat": "This problem contains multiple test cases. The first line contains a single integer $T$, the number of test cases.\n\nEach of the following $T$ lines contains two positive integers $n, m$.", "outputFormat": "Output $T$ lines, each being $0$ or $1$. If it is $0$, it means Xiao Z (the first player) will win. If it is $1$, it means the second player will win.", "hint": "For $10 \\%$ of the testdata, $m \\ge n$.  \nFor $20 \\%$ of the testdata, $n, m \\le 10$.  \nFor $30 \\%$ of the testdata, $n, m \\le 50$, $2 \\cdot m \\ge n$.  \nFor $50 \\%$ of the testdata, $n, m \\le 100$.  \nFor $70 \\%$ of the testdata, $n, m \\le {10}^6$.  \nFor $100 \\%$ of the testdata, $1 \\le n, m \\le {10}^9$, $1 \\le T \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2014] 人人尽说江南好", "background": "", "description": "小 Z 是一个不折不扣的 ZRP（Zealot Round-game Player，回合制游戏狂热玩家），最近他想起了小时候在江南玩过的一个游戏。\n\n在过去，人们是要边玩游戏边填词的，比如这首《菩萨蛮》就是当年韦庄在玩游戏时填的：人 人 尽 说 江 南 好， 游 人 只 合 江 南 老。\n\n然而我们今天不太关心人们填的词是什么，我们只关心小 Z 那时玩过的游戏。游戏的规则是这样的，给定 $n$ 堆石子，每堆石子一开始只有 $1$ 个。小 Z 和他的小伙伴轮流操作，小 Z 先行操作。操作可以将任意两堆石子合并成为一堆，当谁不再能操作的时候，谁就输掉了。\n\n不过，当一堆石子堆的太高时可能发生危险，因此小 Z 和他的小伙伴规定，任何时刻任意一堆石子的数量不能超过 $m$。即假如现在有两堆石子分别有 $a$ 个和 $b$ 个，而且 $a + b > m$，那么这两堆石子就不能合成一堆。\n\n小 Z 和他的小伙伴都是很聪明的，所以他们总是会选择对自己最有利的策略。现在小 Z 想要知道，在这种情况下，对于一个给定的 $n$ 和 $m$，到底是谁能够获得胜利呢？\n", "inputFormat": "本题包括多组数据  数据第一行为一个数 $T$，为数据组数。\n\n以下 $T$ 行，每行两个正整数 $n,m$。\n", "outputFormat": "输出 $T$ 行，每行为 $0$ 或 $1$，如果为 $0$ 意为小 Z（即先手）会取得胜利，为 $1$ 则为后手会取得胜利。\n", "hint": "对于 $10 \\%$ 的数据，$m \\ge n$；  \n对于 $20 \\%$ 的数据，$n, m \\le 10$；  \n对于 $30 \\%$ 的数据，$n, m \\le 50$，$2 \\cdot m \\ge n$；  \n对于 $50 \\%$ 的数据，$n, m \\le 100$；  \n对于 $70 \\%$ 的数据，$n, m \\le {10}^6$；  \n对于 $100 \\%$ 的数据，$1 \\le n, m \\le {10}^9$，$1 \\le T \\le 100$。\n", "locale": "zh-CN"}}}
{"pid": "P4102", "type": "P", "difficulty": 7, "samples": [["2 0 1 1 \n1 2", "0"], ["2 2 2 1 \n1 2 \n2 1 \n1 1", "4"], ["2 2 100 1 \n1 2 \n2 1 \n1 2", "166650"], ["2 3 100 2 \n1 2 \n1 2 \n2 1 \n2 2 \n2 1", "632506153\n518794755"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "各省省选", "河北"], "title": "[HEOI2014] 林中路径", "background": "", "description": "Alice 和 Marisa 都住在一个巨大的由 $N$ 个路口与 $M$ 条单向小道构成的森林中。Marisa 非常喜欢到 Alice 家里去玩，但是 Alice 并不喜欢这位鲁莽的来客。Alice 非常擅长观察， 因此每当她发现 Marisa 走了一条与之前完全相同的路径来到她家时，她就会装作不在家， Marisa 就只好败兴而归。Marisa 发现了这个秘密，因此她决定每次走不同的路径到 Alice 家。\n\nMarisa 体力有限，她不想走超过 K 条边到达 Alice 家，并且，每当她走 $t$（ $t$ $\\leq$ $K$ ）条边 到达 Alice 家时，她需要付出 $t^2$ 的体力。Marisa 想知道，在 Alice 无论如何都不想接见她之前（即 Marisa 无法走一条长度不超过 $K$ 的与之前不同的路径），她会消耗多少体力。\n\n现在 Marisa 拿到了一张森林的地图，但因为 Marisa 非常笨，她并不知道自己的家和 Alice 的家在哪一个路口，因此她会给询问你 $Q$ 次，每次询问假如 Marisa 的家的位置在 $S$ 而 Alice 的家的位置在 $T$ 时的答案。\n\n一条路径 $A$ 的定义是指一个长度为 $P$（$P$ 可以为任意正整数或零）的边的序列 $A_{m_0},A_{m_1},A_{m_2},…,A_{m_{T-1}}$，其中对于任意 $1 \\leq i ＜ P$，有 $A_{m_{i-1}}$ 的结束节点是 $Am_i$ 的起始节点。\n\n两条路径 $A$ 和 $B$ 完全相同是指两条路径的长度均为 T 并且对任意 $0\\leq i＜P$，有 $A_{m_i} = B_{m_i}$。", "inputFormat": "输入数据第一行包含四个整数 $N$ , $M$ , $K$ , $Q$ ，含义如题所述。\n\n接下来 $M$ 行，每行两个整数 $X$ , $Y$ ，表示从第 $X$ 个路口到第 $Y$ 个路口有一条单向小道。路口的标号为 $1,2,3,…,N$ ，在输入数据第 $i+1$ 行的边的标号为 $i$。  接下来 $Q$ 行，每行两个整数 $S$ 和 $T$，含义如题所述。", "outputFormat": "对于每个询问，输出一行，表示这次询问的答案。由于 Marisa 接受不了非常大的数， 你只需要输出答案模 $10^9+7$ 的值。", "hint": "对于 $20\\%$ 的数据，$N\\leq  5$，$M\\leq 10$，$K\\leq 3$，$Q\\leq 10$。\n\n对于 $40\\%$ 的数据，$N\\leq  30$，$M\\leq 900$，$K\\leq 100$，$Q\\leq 100$。\n\n对于 $60\\%$ 的数据，$N\\leq  50$，$M\\leq 2,500$，$K\\leq 10,000,000$，$Q\\leq 1,000$。\n\n对于 $100\\%$ 的数据，$2\\leq  N\\leq 100$，$0\\leq M\\leq 100,000$，$0\\leq K\\leq 1,000,000,000$，$0\\leq Q\\leq 10,000$，$1\\leq X,Y,S,T\\leq N$。\n\n```cpp\ng++ paths.cpp –o paths –Wl,--stack=268435456 –O2 \n```\n样例一解释 从 $S$ 到 $T$ 不存在路径\n\n \n样例二解释 Marisa 可以重复经过一个路口，即使这个路口就是 Alice 的家或 Marisa 的家\n", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2014] Paths in the Forest", "background": "", "description": "Alice and Marisa both live in a huge forest consisting of $N$ vertices and $M$ directed edges. Marisa loves visiting Alice, but Alice does not like this reckless guest. Alice is very observant, so whenever she notices that Marisa has taken a path to her home that is exactly the same as a previous one, she pretends not to be at home, and Marisa has to go back disappointed. Marisa has discovered this secret, so she decides to take a different path to Alice’s home each time.\n\nMarisa has limited stamina. She does not want to walk more than $K$ edges to reach Alice’s home, and each time she reaches Alice’s home after walking $t$ edges (where $t \\le K$), she must spend $t^2$ stamina. Marisa wants to know how much total stamina she will spend before Alice refuses to see her no matter what (that is, when Marisa can no longer find a path of length at most $K$ that is different from all the previous ones).\n\nNow Marisa has a map of the forest, but because she is very clumsy, she does not know which vertices are her home and Alice’s home. Therefore, she will ask you $Q$ times; in each query, you are asked to determine the answer if Marisa’s home is at $S$ and Alice’s home is at $T$.\n\nA path $A$ of length $P$ (where $P$ can be any nonnegative integer) is defined as a sequence of edges $A_{m_0}, A_{m_1}, A_{m_2}, \\dots, A_{m_{P-1}}$, such that for any $1 \\le i < P$, the ending vertex of $A_{m_{i-1}}$ is the starting vertex of $A_{m_i}$.\n\nTwo paths $A$ and $B$ are exactly the same if both have length $P$ and, for any $0 \\le i < P$, $A_{m_i} = B_{m_i}$.", "inputFormat": "The first line contains four integers $N$, $M$, $K$, $Q$, as described above.\n\nThe next $M$ lines each contain two integers $X$, $Y$, indicating a directed edge from vertex $X$ to vertex $Y$. Vertices are numbered $1, 2, 3, \\dots, N$. The edge on the $(i+1)$-th line has index $i$. The following $Q$ lines each contain two integers $S$ and $T$, as described above.", "outputFormat": "For each query, output one line with the answer. Since Marisa cannot accept very large numbers, you only need to output the answer modulo $10^9+7$.", "hint": "For $20\\%$ of the testdata, $N \\le 5$, $M \\le 10$, $K \\le 3$, $Q \\le 10$.\n\nFor $40\\%$ of the testdata, $N \\le 30$, $M \\le 900$, $K \\le 100$, $Q \\le 100$.\n\nFor $60\\%$ of the testdata, $N \\le 50$, $M \\le 2,500$, $K \\le 10,000,000$, $Q \\le 1,000$.\n\nFor $100\\%$ of the testdata, $2 \\le N \\le 100$, $0 \\le M \\le 100,000$, $0 \\le K \\le 1,000,000,000$, $0 \\le Q \\le 10,000$, $1 \\le X, Y, S, T \\le N$.\n\n```cpp\ng++ paths.cpp –o paths –Wl,--stack=268435456 –O2 \n```\nExplanation for Sample 1: There is no path from $S$ to $T$.\n\nExplanation for Sample 2: Marisa may pass through a vertex multiple times, even if that vertex is Alice’s home or Marisa’s home.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2014] 林中路径", "background": "", "description": "Alice 和 Marisa 都住在一个巨大的由 $N$ 个路口与 $M$ 条单向小道构成的森林中。Marisa 非常喜欢到 Alice 家里去玩，但是 Alice 并不喜欢这位鲁莽的来客。Alice 非常擅长观察， 因此每当她发现 Marisa 走了一条与之前完全相同的路径来到她家时，她就会装作不在家， Marisa 就只好败兴而归。Marisa 发现了这个秘密，因此她决定每次走不同的路径到 Alice 家。\n\nMarisa 体力有限，她不想走超过 K 条边到达 Alice 家，并且，每当她走 $t$（ $t$ $\\leq$ $K$ ）条边 到达 Alice 家时，她需要付出 $t^2$ 的体力。Marisa 想知道，在 Alice 无论如何都不想接见她之前（即 Marisa 无法走一条长度不超过 $K$ 的与之前不同的路径），她会消耗多少体力。\n\n现在 Marisa 拿到了一张森林的地图，但因为 Marisa 非常笨，她并不知道自己的家和 Alice 的家在哪一个路口，因此她会给询问你 $Q$ 次，每次询问假如 Marisa 的家的位置在 $S$ 而 Alice 的家的位置在 $T$ 时的答案。\n\n一条路径 $A$ 的定义是指一个长度为 $P$（$P$ 可以为任意正整数或零）的边的序列 $A_{m_0},A_{m_1},A_{m_2},…,A_{m_{T-1}}$，其中对于任意 $1 \\leq i ＜ P$，有 $A_{m_{i-1}}$ 的结束节点是 $Am_i$ 的起始节点。\n\n两条路径 $A$ 和 $B$ 完全相同是指两条路径的长度均为 T 并且对任意 $0\\leq i＜P$，有 $A_{m_i} = B_{m_i}$。", "inputFormat": "输入数据第一行包含四个整数 $N$ , $M$ , $K$ , $Q$ ，含义如题所述。\n\n接下来 $M$ 行，每行两个整数 $X$ , $Y$ ，表示从第 $X$ 个路口到第 $Y$ 个路口有一条单向小道。路口的标号为 $1,2,3,…,N$ ，在输入数据第 $i+1$ 行的边的标号为 $i$。  接下来 $Q$ 行，每行两个整数 $S$ 和 $T$，含义如题所述。", "outputFormat": "对于每个询问，输出一行，表示这次询问的答案。由于 Marisa 接受不了非常大的数， 你只需要输出答案模 $10^9+7$ 的值。", "hint": "对于 $20\\%$ 的数据，$N\\leq  5$，$M\\leq 10$，$K\\leq 3$，$Q\\leq 10$。\n\n对于 $40\\%$ 的数据，$N\\leq  30$，$M\\leq 900$，$K\\leq 100$，$Q\\leq 100$。\n\n对于 $60\\%$ 的数据，$N\\leq  50$，$M\\leq 2,500$，$K\\leq 10,000,000$，$Q\\leq 1,000$。\n\n对于 $100\\%$ 的数据，$2\\leq  N\\leq 100$，$0\\leq M\\leq 100,000$，$0\\leq K\\leq 1,000,000,000$，$0\\leq Q\\leq 10,000$，$1\\leq X,Y,S,T\\leq N$。\n\n```cpp\ng++ paths.cpp –o paths –Wl,--stack=268435456 –O2 \n```\n样例一解释 从 $S$ 到 $T$ 不存在路径\n\n \n样例二解释 Marisa 可以重复经过一个路口，即使这个路口就是 Alice 的家或 Marisa 的家\n", "locale": "zh-CN"}}}
{"pid": "P4103", "type": "P", "difficulty": 6, "samples": [["10 \n2 1 \n3 2 \n4 1 \n5 2 \n6 4 \n7 5 \n8 6 \n9 7 \n10 9 \n5 \n2 \n5 4 \n2\n10 4 \n2 \n5 2 \n2\n6 1 \n2 \n6 1", "3 3 3 \n6 6 6 \n1 1 1 \n2 2 2 \n2 2 2"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2014", "倍增", "各省省选", "河北", "虚树", "栈"], "title": "[HEOI2014] 大工程", "background": null, "description": "国家有一个大工程，要给一个非常大的交通网络里建一些新的通道。\n\n我们这个国家位置非常特殊，可以看成是一个单位边权的树，城市位于顶点上。\n\n在 $2$ 个国家 $a,b$ 之间建一条新通道需要的代价为树上 $a,b$ 的最短路径的长度。\n\n现在国家有很多个计划，每个计划都是这样，我们选中了 $k$ 个点，然后在它们两两之间 新建 $\\dbinom{k}{2}$ 条新通道（任意两点间都新建 $1$ 条）。\n\n现在对于每个计划，我们想知道： \n1. 这些新通道的代价和。\n2. 这些新通道中代价最小的是多少。\n3. 这些新通道中代价最大的是多少。", "inputFormat": "第一行 $n$ 表示点数。\n\n接下来 $n-1$ 行，每行两个数 $a,b$ 表示 $a$ 和 $b$ 之间有一条边。点从 $1$ 开始标号。\n\n接下来一行 $q$ 表示计划数。对每个计划有 $2$ 行，第一行 $k$ 表示这个计划选中了几个点。\n\n第二行用空格隔开的 $k$ 个互不相同的数表示选了哪 $k$ 个点。", "outputFormat": "输出 $q$ 行，每行三个数分别表示代价和，最小代价，最大代价。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^6,1\\le q\\le 5\\times 10^4,\\sum k\\le 2\\times n$。\n\n每个测试点的具体限制见下表：\n\n| 测试点编号 | $n$ | 特殊性质 |\n| :-----------: | :-----------: | :-----------: |\n| $1\\sim 2$ | $\\le 10^4$ |  |\n|$3\\sim 5$  | $\\le 10^5$ | 树的形态是链 |\n| $6\\sim 7$ | $\\le 10^5$ |  |\n| $8\\sim 10$ | $\\le 10^6$ |  |", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2014] Major Project", "background": "", "description": "The country is undertaking a major project to build some new channels in a very large transportation network.\n\nOur country has a very special layout. It can be regarded as a tree with unit edge weights, with cities at the vertices.\n\nThe cost of building a new channel between two cities $a,b$ is the length of the shortest path between $a,b$ on the tree.\n\nThere are many plans. In each plan, we select $k$ vertices, and then build $\\dbinom{k}{2}$ new channels between every pair of them (exactly one between any two vertices).\n\nFor each plan, we want to know:\n1. The sum of the costs of these new channels.\n2. The minimum cost among these new channels.\n3. The maximum cost among these new channels.", "inputFormat": "The first line contains $n$, the number of vertices.\n\nThe next $n-1$ lines each contain two integers $a,b$, indicating there is an edge between $a$ and $b$. Vertices are numbered starting from $1$.\n\nThe next line contains $q$, the number of plans. For each plan, there are $2$ lines. The first line contains $k$, the number of selected vertices in this plan.\n\nThe second line contains $k$ distinct integers separated by spaces, indicating which $k$ vertices are selected.", "outputFormat": "Output $q$ lines. Each line contains three numbers: the sum of costs, the minimum cost, and the maximum cost.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 10^6, 1 \\le q \\le 5 \\times 10^4, \\sum k \\le 2 \\times n$.\n\nThe specific limits for each test point are shown in the table below:\n\n| Test point ID | $n$ | Special property |\n| :-----------: | :-----------: | :-----------: |\n| $1\\sim 2$ | $\\le 10^4$ |  |\n| $3\\sim 5$ | $\\le 10^5$ | The tree is a chain |\n| $6\\sim 7$ | $\\le 10^5$ |  |\n| $8\\sim 10$ | $\\le 10^6$ |  |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2014] 大工程", "background": null, "description": "国家有一个大工程，要给一个非常大的交通网络里建一些新的通道。\n\n我们这个国家位置非常特殊，可以看成是一个单位边权的树，城市位于顶点上。\n\n在 $2$ 个国家 $a,b$ 之间建一条新通道需要的代价为树上 $a,b$ 的最短路径的长度。\n\n现在国家有很多个计划，每个计划都是这样，我们选中了 $k$ 个点，然后在它们两两之间 新建 $\\dbinom{k}{2}$ 条新通道（任意两点间都新建 $1$ 条）。\n\n现在对于每个计划，我们想知道： \n1. 这些新通道的代价和。\n2. 这些新通道中代价最小的是多少。\n3. 这些新通道中代价最大的是多少。", "inputFormat": "第一行 $n$ 表示点数。\n\n接下来 $n-1$ 行，每行两个数 $a,b$ 表示 $a$ 和 $b$ 之间有一条边。点从 $1$ 开始标号。\n\n接下来一行 $q$ 表示计划数。对每个计划有 $2$ 行，第一行 $k$ 表示这个计划选中了几个点。\n\n第二行用空格隔开的 $k$ 个互不相同的数表示选了哪 $k$ 个点。", "outputFormat": "输出 $q$ 行，每行三个数分别表示代价和，最小代价，最大代价。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^6,1\\le q\\le 5\\times 10^4,\\sum k\\le 2\\times n$。\n\n每个测试点的具体限制见下表：\n\n| 测试点编号 | $n$ | 特殊性质 |\n| :-----------: | :-----------: | :-----------: |\n| $1\\sim 2$ | $\\le 10^4$ |  |\n|$3\\sim 5$  | $\\le 10^5$ | 树的形态是链 |\n| $6\\sim 7$ | $\\le 10^5$ |  |\n| $8\\sim 10$ | $\\le 10^6$ |  |", "locale": "zh-CN"}}}
{"pid": "P4104", "type": "P", "difficulty": 6, "samples": [["10\n6 5 10000  \n4 1 10000 \n9 6 10000 \n4 6 10000 \n5 1 10000 \n8318 10 9973 \n9862 9 9973 \n8234 9 9973 \n9424 9 9973 \n9324 9 9973", "73\n1\n920\n8\n1\n4421\n2565\n0\n446\n2549"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "各省省选", "河北"], "title": "[HEOI2014] 平衡", "background": "", "description": "下课了，露露、花花和萱萱在课桌上用正三棱柱教具和尺子摆起了一个“跷跷板”。\n\n这个“跷跷板”的结构是这样的：底部是一个侧面平行于地平面的正三棱柱教具，上面 摆着一个尺子，尺子上摆着若干个相同的橡皮。尺子有 2n + 1 条等距的刻度线，第 n + 1 条 刻度线恰好在尺子的中心，且与正三棱柱的不在课桌上的棱完全重合。\n\n露露发现这个“跷跷板”是不平衡的（尺子不平行于地平面）。于是，她又在尺子上放 了几个橡皮，并移动了一些橡皮的位置，使得尺子的 2n + 1 条刻度线上都恰有一块相同质 量的橡皮。“跷跷板”平衡了，露露感到很高兴。\n\n花花觉得这样太没有意思，于是从尺子上随意拿走了 k 个橡皮。令她惊讶的事情发生了： 尺子依然保持着平衡！     萱萱是一个善于思考的孩子，她当然不对尺子依然保持平衡感到吃惊，因为这只是一个 偶然的事件罢了。令她感兴趣的是，花花有多少种拿走 k 个橡皮的方法，使得尺子依然保 持平衡？当然，为了简化问题，她不得不做一些牺牲——假设所有橡皮都是拥有相同质量的 质点。但即使是这样，她也没能计算出这个数目。放学后，她把这个问题交给了她的哥哥/ 姐姐——Hibarigasaki 学园学生会会长，也就是你。当然，由于这个问题的答案也许会过于 庞大，你只需要告诉她答案 mod p 的值。\n", "inputFormat": "第一行，一个正整数，表示数据组数 T（萱萱向你询问的次数）。\n\n接下来 T 行，每行 3 个正整数 n, k, p。\n", "outputFormat": "共 T 行，每行一个正整数，代表你得出的对应问题的答案。\n", "hint": "10%的数据满足：n <= 10。\n\n30%的数据满足：n <= 50。\n\n50%的数据满足：n <= 1000。\n\n另有 10%的数据满足：k = 3。\n\n在此基础上，另有 10%的数据满足：p = 2。\n\n100%的数据满足：T <= 20，1 <= n <= 10000，1 <= k <= 10，2 <= p <= 10000，且 k <= 2n+1。\n", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2014] Balance", "background": "", "description": "After class, Lulu, Huahua, and Xuanxuan set up a “seesaw” on the desk using a regular triangular prism teaching aid and a ruler.\n\nThe structure of this “seesaw” is as follows: at the bottom is a regular triangular prism with one of its lateral faces parallel to the ground, and on top lies a ruler. Several identical erasers are placed on the ruler. The ruler has $2n+1$ equally spaced tick marks; the $(n+1)$-th tick is exactly at the center of the ruler and exactly coincides with the edge of the regular triangular prism that is not on the desk.\n\nLulu notices that the “seesaw” is unbalanced (the ruler is not parallel to the ground). So she adds a few more erasers and moves some erasers so that each of the $2n+1$ tick marks on the ruler has exactly one eraser of the same mass. The “seesaw” becomes balanced, and Lulu is happy.\n\nHuahua thinks this is too boring, so she randomly removes $k$ erasers from the ruler. To her surprise, the ruler remains balanced!\n\nXuanxuan is a thoughtful child, so she is not surprised that the ruler remains balanced, as this is merely a coincidence. What interests her is: in how many ways can Huahua remove $k$ erasers so that the ruler remains balanced? Of course, to simplify the problem, she has to make some sacrifices—assume all erasers are point masses with equal mass. Even so, she cannot compute this number. After school, she brings this problem to her older brother/sister—the student council president of Hibarigasaki Academy, that is, you. Since the answer may be too large, you only need to tell her the value modulo $p$.", "inputFormat": "The first line contains a positive integer $T$ (the number of times Xuanxuan asks you).\n\nEach of the next $T$ lines contains three positive integers $n$, $k$, and $p$.", "outputFormat": "Output $T$ lines, each containing one positive integer, the answer for the corresponding query.", "hint": "- 10% of the testdata satisfy $n \\le 10$.\n- 30% of the testdata satisfy $n \\le 50$.\n- 50% of the testdata satisfy $n \\le 1000$.\n- Additionally, 10% of the testdata satisfy $k = 3$.\n- Additionally, 10% of the testdata satisfy $p = 2$.\n- 100% of the testdata satisfy $T \\le 20$, $1 \\le n \\le 10000$, $1 \\le k \\le 10$, $2 \\le p \\le 10000$, and $k \\le 2n+1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2014] 平衡", "background": "", "description": "下课了，露露、花花和萱萱在课桌上用正三棱柱教具和尺子摆起了一个“跷跷板”。\n\n这个“跷跷板”的结构是这样的：底部是一个侧面平行于地平面的正三棱柱教具，上面 摆着一个尺子，尺子上摆着若干个相同的橡皮。尺子有 2n + 1 条等距的刻度线，第 n + 1 条 刻度线恰好在尺子的中心，且与正三棱柱的不在课桌上的棱完全重合。\n\n露露发现这个“跷跷板”是不平衡的（尺子不平行于地平面）。于是，她又在尺子上放 了几个橡皮，并移动了一些橡皮的位置，使得尺子的 2n + 1 条刻度线上都恰有一块相同质 量的橡皮。“跷跷板”平衡了，露露感到很高兴。\n\n花花觉得这样太没有意思，于是从尺子上随意拿走了 k 个橡皮。令她惊讶的事情发生了： 尺子依然保持着平衡！     萱萱是一个善于思考的孩子，她当然不对尺子依然保持平衡感到吃惊，因为这只是一个 偶然的事件罢了。令她感兴趣的是，花花有多少种拿走 k 个橡皮的方法，使得尺子依然保 持平衡？当然，为了简化问题，她不得不做一些牺牲——假设所有橡皮都是拥有相同质量的 质点。但即使是这样，她也没能计算出这个数目。放学后，她把这个问题交给了她的哥哥/ 姐姐——Hibarigasaki 学园学生会会长，也就是你。当然，由于这个问题的答案也许会过于 庞大，你只需要告诉她答案 mod p 的值。\n", "inputFormat": "第一行，一个正整数，表示数据组数 T（萱萱向你询问的次数）。\n\n接下来 T 行，每行 3 个正整数 n, k, p。\n", "outputFormat": "共 T 行，每行一个正整数，代表你得出的对应问题的答案。\n", "hint": "10%的数据满足：n <= 10。\n\n30%的数据满足：n <= 50。\n\n50%的数据满足：n <= 1000。\n\n另有 10%的数据满足：k = 3。\n\n在此基础上，另有 10%的数据满足：p = 2。\n\n100%的数据满足：T <= 20，1 <= n <= 10000，1 <= k <= 10，2 <= p <= 10000，且 k <= 2n+1。\n", "locale": "zh-CN"}}}
{"pid": "P4105", "type": "P", "difficulty": 3, "samples": [["3 815 6901 3839 178 199 10007 ", "1334"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["模拟", "贪心", "2014", "二分", "各省省选", "河北"], "title": "[HEOI2014] 南园满地堆轻絮", "background": null, "description": "小 Z 是 ZRP（Zombies’ Republic of Poetry，僵尸诗歌共和国）的一名诗歌爱好者，最近他研究起了诗词音律的问题。\n\n在过去，诗词是需要编成曲子唱出来的，比如下面这首《菩萨蛮》，唱出来的话其对应的音符就是这样的：\n\n```\n 南  园  满 地 堆 轻 絮， 愁 闻 一 霎 清 明 雨   \n 1   1  5 5 6 6 5  4 4 3 3 2 2 1  \n```\n因而可以发现，`1 1 5 5 6 6 5 4 4 3 3 2 2 1` 这串音符就成为了研究音律的关键。\n\n小 Z 翻阅了众多史料发现，过去的一首曲子的音调是不下降的。小 Z 想要知道对于一首给定的曲子，如何通过提高音调或者降低音调，将它的音调修改的不下降，而且使得修改幅度最大的那个音符的修改幅度尽量小。即如果把一个包含 $n$ 个音符的曲子看做是一个正整数数列 $A_1 \\cdots A_n$，那么目标是求另一个正整数数列 $B_1 \\cdots B_n$，使得对于任意的 $1 \\leq i<n$ 有 $B_i \\leq B_{i+1}$，而且使得 $\\texttt{Ans} = \\max\\{\\lvert A_j-B_j\\rvert,1\\leq j\\leq n\\}$ 尽量小。\n\n小 Z 很快就想清楚了做法，但是鉴于他还忙着写诗，所以这个任务就交给了你。", "inputFormat": "由于数据规模可能较大，因此采用如下方式生成数据。\n\n每个数据包含 $7$ 个数：$n,S_a,S_b,S_c,S_d,A_1,\\texttt{Mod}$，即共有 $n$ 个音符，第一个音符为 $A_1$。\n\n生成规则如下：定义生成函数 $F(x) = S_a\\times x^3 + S_b\\times x^2 + S_c\\times x + S_d$；那么给出递推公式 $A_i =( F(A_{i-1}) + F(A_{i-2}) )\\bmod \\texttt{Mod}$，此处规定 $A_0 = 0$。由于中间过程的数可能会特别大，所以要求每一步与 $A$ 中的每个数都对一个给定的数 $\\texttt{Mod}$ 取模。", "outputFormat": "输出一行，包含一个正整数 $\\texttt{Ans}$。", "hint": "【数据范围】\n\n对于 $10\\%$ 的数据，$n\\leq3$\n\n对于 $20\\%$ 的数据，$n\\leq10$\n\n对于 $30\\%$ 的数据，$n\\leq10^2$\n\n对于 $50\\%$ 的数据，$n\\leq10^3$\n\n对于 $70\\%$ 的数据，$n\\leq10^5$\n\n对于 $100\\%$ 的数据，$2<n\\leq 5 \\times 10^6$，$S_a,S_b,S_c,S_d,A_1 \\leq \\min\\{10^4,\\texttt{Mod}\\}$，$1 < \\texttt{Mod}\\leq 10^9+7$，所有输入的数都是正整数。\n\n【友情提示】\n\n样例中生成的数列为：$199,4568,1901$，此时将 $4568$ 修改为 $3234$，$1901$ 也修改为 $3234$ 即可，代价为 $1334$。", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2014] Light Catkins Piled All Over the Southern Garden", "background": "", "description": "Xiao Z is a poetry enthusiast in the ZRP (Zombies’ Republic of Poetry). Recently, he has been studying the prosody of classical poetry.\n\nIn the past, poems were meant to be sung to melodies. For example, consider the following tune of “Bodhisattva Man.” When sung, the corresponding notes are:\n\n```\n 南  园  满 地 堆 轻 絮， 愁 闻 一 霎 清 明 雨   \n 1   1  5 5 6 6 5  4 4 3 3 2 2 1  \n```\nTherefore, one can see that the sequence of notes `1 1 5 5 6 6 5 4 4 3 3 2 2 1` becomes the key to studying prosody.\n\nFrom many historical sources, Xiao Z found that the pitch of an ancient tune is non-decreasing. He wants to know, for a given piece, how to raise or lower its notes to make the sequence non-decreasing, while making the largest adjustment among all notes as small as possible. That is, if a piece with $n$ notes is viewed as a positive integer sequence $A_1 \\cdots A_n$, the goal is to find another positive integer sequence $B_1 \\cdots B_n$ such that for every $1 \\leq i < n$ we have $B_i \\leq B_{i+1}$, and $\\texttt{Ans} = \\max\\{\\lvert A_j - B_j \\rvert, 1 \\leq j \\leq n\\}$ is minimized.\n\nXiao Z quickly figured out a method, but since he is busy writing poetry, the task is handed over to you.", "inputFormat": "Since the testdata size may be large, the data are generated as follows.\n\nEach test consists of $7$ numbers: $n, S_a, S_b, S_c, S_d, A_1, \\texttt{Mod}$, meaning there are $n$ notes and the first note is $A_1$.\n\nThe generation rules are: define $F(x) = S_a \\times x^3 + S_b \\times x^2 + S_c \\times x + S_d$; then the recurrence is\n$A_i = \\bigl( F(A_{i-1}) + F(A_{i-2}) \\bigr) \\bmod \\texttt{Mod}$, with $A_0 = 0$. Since intermediate values may be very large, at each step and for every number in $A$, take modulo $\\texttt{Mod}$.", "outputFormat": "Output one line containing a positive integer $\\texttt{Ans}$.", "hint": "Constraints\n\n- For $10\\%$ of the testdata, $n \\leq 3$.\n- For $20\\%$ of the testdata, $n \\leq 10$.\n- For $30\\%$ of the testdata, $n \\leq 10^2$.\n- For $50\\%$ of the testdata, $n \\leq 10^3$.\n- For $70\\%$ of the testdata, $n \\leq 10^5$.\n- For $100\\%$ of the testdata, $2 < n \\leq 5 \\times 10^6$, $S_a, S_b, S_c, S_d, A_1 \\leq \\min\\{10^4, \\texttt{Mod}\\}$, $1 < \\texttt{Mod} \\leq 10^9 + 7$, and all input numbers are positive integers.\n\nFriendly hint\n\nIn the sample, the generated sequence is $199, 4568, 1901$. If you change $4568$ to $3234$ and also change $1901$ to $3234$, the cost is $1334$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2014] 南园满地堆轻絮", "background": null, "description": "小 Z 是 ZRP（Zombies’ Republic of Poetry，僵尸诗歌共和国）的一名诗歌爱好者，最近他研究起了诗词音律的问题。\n\n在过去，诗词是需要编成曲子唱出来的，比如下面这首《菩萨蛮》，唱出来的话其对应的音符就是这样的：\n\n```\n 南  园  满 地 堆 轻 絮， 愁 闻 一 霎 清 明 雨   \n 1   1  5 5 6 6 5  4 4 3 3 2 2 1  \n```\n因而可以发现，`1 1 5 5 6 6 5 4 4 3 3 2 2 1` 这串音符就成为了研究音律的关键。\n\n小 Z 翻阅了众多史料发现，过去的一首曲子的音调是不下降的。小 Z 想要知道对于一首给定的曲子，如何通过提高音调或者降低音调，将它的音调修改的不下降，而且使得修改幅度最大的那个音符的修改幅度尽量小。即如果把一个包含 $n$ 个音符的曲子看做是一个正整数数列 $A_1 \\cdots A_n$，那么目标是求另一个正整数数列 $B_1 \\cdots B_n$，使得对于任意的 $1 \\leq i<n$ 有 $B_i \\leq B_{i+1}$，而且使得 $\\texttt{Ans} = \\max\\{\\lvert A_j-B_j\\rvert,1\\leq j\\leq n\\}$ 尽量小。\n\n小 Z 很快就想清楚了做法，但是鉴于他还忙着写诗，所以这个任务就交给了你。", "inputFormat": "由于数据规模可能较大，因此采用如下方式生成数据。\n\n每个数据包含 $7$ 个数：$n,S_a,S_b,S_c,S_d,A_1,\\texttt{Mod}$，即共有 $n$ 个音符，第一个音符为 $A_1$。\n\n生成规则如下：定义生成函数 $F(x) = S_a\\times x^3 + S_b\\times x^2 + S_c\\times x + S_d$；那么给出递推公式 $A_i =( F(A_{i-1}) + F(A_{i-2}) )\\bmod \\texttt{Mod}$，此处规定 $A_0 = 0$。由于中间过程的数可能会特别大，所以要求每一步与 $A$ 中的每个数都对一个给定的数 $\\texttt{Mod}$ 取模。", "outputFormat": "输出一行，包含一个正整数 $\\texttt{Ans}$。", "hint": "【数据范围】\n\n对于 $10\\%$ 的数据，$n\\leq3$\n\n对于 $20\\%$ 的数据，$n\\leq10$\n\n对于 $30\\%$ 的数据，$n\\leq10^2$\n\n对于 $50\\%$ 的数据，$n\\leq10^3$\n\n对于 $70\\%$ 的数据，$n\\leq10^5$\n\n对于 $100\\%$ 的数据，$2<n\\leq 5 \\times 10^6$，$S_a,S_b,S_c,S_d,A_1 \\leq \\min\\{10^4,\\texttt{Mod}\\}$，$1 < \\texttt{Mod}\\leq 10^9+7$，所有输入的数都是正整数。\n\n【友情提示】\n\n样例中生成的数列为：$199,4568,1901$，此时将 $4568$ 修改为 $3234$，$1901$ 也修改为 $3234$ 即可，代价为 $1334$。", "locale": "zh-CN"}}}
{"pid": "P4106", "type": "P", "difficulty": 5, "samples": [["2 \n++ 0 \n+- 1 \n-+ 2 \n-- 3 \n \n", "3/2 \n-1 x1 \n-1/2 x2 "], ["3 \n--- -1.0\n-++ -1.0\n+-+ -1.0\n++- -1.0\n--+ 1.0\n-+- 1.0\n+-- 1.0\n+++ 1.0\n", "1 x1x2x3"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [17000, 17000, 17000, 17000, 17000, 17000, 17000]}, "tags": ["2014", "各省省选", "河北"], "title": "[HEOI2014] 逻辑翻译", "background": null, "description": "在人类的神经系统中，每个信号都可以用 $−1$ 或 $+1$ 来表示。这些信号组合起来最后形成了喜怒哀乐，酸甜苦辣，红黄绿蓝等各种各样的复杂信息。纳米探测科技的突破让生物学家可以测量大脑中特定区域的完整逻辑功能。然而超大数据的处理一直是令 H 教授头疼的问题。\n\n假设一个逻辑单元接受 $N$ 个信号输入，并产生一个代表某种意义的实数值 $r$ 。那么总共可能的情况有 $2^N$ 种。通过长时间的累积测量， H 教授可以准确地获得输入信号与 $r$ 的关系表：\n\n$$f :\\{-1,1\\}^N \\to \\mathbb{R} $$\n\n然而进一步研究发现，神经元的运算方式可以被建模为人们熟知的多项式。由于一个输入信号值的平方一定为 $1$，所以我们可以用不含幂的 $2^N$ 项的多项式来唯一表示任何一个逻辑 $f$。\n\n例如\n$x_1=+1; x_2=+1 \\to 0$\n\n$x_1=+1; x_2=-1 \\to 1$\n\n$x_1=-1; x_2=+1 \\to 2$\n\n$x_1=-1; x_2=-1 \\to 3$\n\n可以写成\n\n$$f(x_1,x_2)=1.5-0.5x_2-x_1$$\n\n研究一个逻辑单元的多项式形式对了解大脑工作十分有意义，于是小 M 决定帮 H 教授把测量出的逻辑关系表全部转换成多项式的形式。这么简单的工作一定难不倒编程能手小 M 的吧？", "inputFormat": "第一行是 $N$ ($1\\le N \\le20$)，接下来共 $2^N$ 行，每一行是一组逻辑输入和一个对应值，代表 $x_1...x_N$ 的符号以及对应的 $r$。详见样例。数据保证所有逻辑值的绝对值不超过 $100$，且不包含超过 $2$ 位小数。保证所有逻辑的输入串都互不相同。", "outputFormat": "最多 $2^N$ 行，代表多项式每一项的系数，如果答案为整数，输出整数形式。否则输出最简分数形式。如果系数恰好为 $0$，则省略整行。变量和系数用空格隔开，常数项不用加空格。\n\n顺序按多项式的字典序：\n\n1. 常数项优先；\n\n2. 没有常数项时，最小 $x$ 下标更小的项优先；\n\n3. 当两项含有相同最小下标时，按除掉最小下标 $x$ 以后，以同样规则递归比较。\n\n例：$1$，$x1$，$x1x2$，$x1x2x3$，$x1x3$，$x2$，$x2x3$，$x3$。详见样例。", "hint": "本题共有 $10$ 个测试数据。\n\n对于第 $1$ 个数据， $N\\le3$;\n\n对于第 $2$ 个数据， $N\\le8$;\n\n对于第 $3$，$4$ 个数据，$N\\le11$;\n\n对于第 $5$，$6$ 个数据， 答案多项式中只有一个非零项，如样例#2。\n\n对于第 $7$，$8$ 个数据， 答案多项式中最多有 $5$ 个非零项。\n\n对于 $100\\%$ 的数据， $1 \\le N \\le 20,|r| \\le 100, 100r\\in \\mathbb{Z} $\n\n友情提示\n\n请注意输入输出的效率。", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2014] Logic Translation", "background": "", "description": "In the human nervous system, each signal can be represented by $−1$ or $+1$. These signals combine to eventually form complex information such as joy, anger, sorrow, and happiness; sour, sweet, bitter, and spicy; red, yellow, green, and blue. Breakthroughs in nano-probing technology have enabled biologists to measure the complete logical function of specific regions of the brain. However, processing ultra-large data has always been a headache for Professor H.\n\nSuppose a logical unit accepts $N$ signal inputs and produces a real value $r$ representing some meaning. Then there are $2^N$ possible cases in total. Through long-term cumulative measurements, Professor H can accurately obtain the mapping between input signals and $r$:\n\n$$f :\\{-1,1\\}^N \\to \\mathbb{R} $$\n\nFurther research has found that the neuron’s computation can be modeled as a well-known polynomial. Since the square of an input signal value is always $1$, we can uniquely represent any logic $f$ by a polynomial without powers consisting of $2^N$ terms.\n\nFor example\nx1=+1; x2=+1 -> 0\n\nx1=+1; x2=-1 -> 1\n\nx1=-1; x2=+1 -> 2\n\nx1=-1; x2=-1 -> 3\n\ncan be written as\n\n$$f(x_1,x_2)=1.5-0.5x_2-x_1$$\n\nStudying the polynomial form of a logical unit is very meaningful for understanding how the brain works, so Xiao M decided to help Professor H convert all measured logic tables into polynomial form. Such a simple task should be no problem for the coding ace Xiao M, right?", "inputFormat": "The first line is $N$ ($1\\le N \\le20$). Then there are $2^N$ lines. Each line contains one set of logical inputs and one corresponding value, representing the signs of $x_1...x_N$ and the corresponding $r$. See the sample. The testdata guarantees that the absolute value of every logical value does not exceed $100$, and it contains no more than $2$ decimal places. All logical input strings are guaranteed to be pairwise distinct.", "outputFormat": "Up to $2^N$ lines, representing the coefficient of each term in the polynomial. If a coefficient is an integer, output it in integer form; otherwise, output it as an irreducible fraction. If a coefficient is exactly $0$, omit the entire line. Separate variables and the coefficient with a space; the constant term should not have a space.\n\nOrder by the polynomial’s lexicographic order:\n\n1. The constant term comes first.\n\n2. Among non-constant terms, the term with the smaller smallest $x$ index comes first.\n\n3. If two terms share the same smallest index, remove that smallest-indexed $x$ and compare recursively using the same rule.\n\nExample: $1$, $x1$, $x1x2$, $x1x2x3$, $x1x3$, $x2$, $x2x3$, $x3$. See the sample.", "hint": "This problem has $10$ testdata.\n\nFor the $1$st testdata, $N\\le3$;\nfor the $2$nd testdata, $N\\le8$;\nfor the $3$rd and $4$th testdata, $N\\le11$;\nfor the $5$th and $6$th testdata, the answer polynomial has only one nonzero term, as in Sample #2;\nfor the $7$th and $8$th testdata, the answer polynomial has at most $5$ nonzero terms.\n\nFor $100\\%$ of the testdata, $1 \\le N \\le 20, |r| \\le 100, 100r\\in \\mathbb{Z}$.\n\nFriendly reminder\n\nPlease pay attention to input and output efficiency.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2014] 逻辑翻译", "background": null, "description": "在人类的神经系统中，每个信号都可以用 $−1$ 或 $+1$ 来表示。这些信号组合起来最后形成了喜怒哀乐，酸甜苦辣，红黄绿蓝等各种各样的复杂信息。纳米探测科技的突破让生物学家可以测量大脑中特定区域的完整逻辑功能。然而超大数据的处理一直是令 H 教授头疼的问题。\n\n假设一个逻辑单元接受 $N$ 个信号输入，并产生一个代表某种意义的实数值 $r$ 。那么总共可能的情况有 $2^N$ 种。通过长时间的累积测量， H 教授可以准确地获得输入信号与 $r$ 的关系表：\n\n$$f :\\{-1,1\\}^N \\to \\mathbb{R} $$\n\n然而进一步研究发现，神经元的运算方式可以被建模为人们熟知的多项式。由于一个输入信号值的平方一定为 $1$，所以我们可以用不含幂的 $2^N$ 项的多项式来唯一表示任何一个逻辑 $f$。\n\n例如\n$x_1=+1; x_2=+1 \\to 0$\n\n$x_1=+1; x_2=-1 \\to 1$\n\n$x_1=-1; x_2=+1 \\to 2$\n\n$x_1=-1; x_2=-1 \\to 3$\n\n可以写成\n\n$$f(x_1,x_2)=1.5-0.5x_2-x_1$$\n\n研究一个逻辑单元的多项式形式对了解大脑工作十分有意义，于是小 M 决定帮 H 教授把测量出的逻辑关系表全部转换成多项式的形式。这么简单的工作一定难不倒编程能手小 M 的吧？", "inputFormat": "第一行是 $N$ ($1\\le N \\le20$)，接下来共 $2^N$ 行，每一行是一组逻辑输入和一个对应值，代表 $x_1...x_N$ 的符号以及对应的 $r$。详见样例。数据保证所有逻辑值的绝对值不超过 $100$，且不包含超过 $2$ 位小数。保证所有逻辑的输入串都互不相同。", "outputFormat": "最多 $2^N$ 行，代表多项式每一项的系数，如果答案为整数，输出整数形式。否则输出最简分数形式。如果系数恰好为 $0$，则省略整行。变量和系数用空格隔开，常数项不用加空格。\n\n顺序按多项式的字典序：\n\n1. 常数项优先；\n\n2. 没有常数项时，最小 $x$ 下标更小的项优先；\n\n3. 当两项含有相同最小下标时，按除掉最小下标 $x$ 以后，以同样规则递归比较。\n\n例：$1$，$x1$，$x1x2$，$x1x2x3$，$x1x3$，$x2$，$x2x3$，$x3$。详见样例。", "hint": "本题共有 $10$ 个测试数据。\n\n对于第 $1$ 个数据， $N\\le3$;\n\n对于第 $2$ 个数据， $N\\le8$;\n\n对于第 $3$，$4$ 个数据，$N\\le11$;\n\n对于第 $5$，$6$ 个数据， 答案多项式中只有一个非零项，如样例#2。\n\n对于第 $7$，$8$ 个数据， 答案多项式中最多有 $5$ 个非零项。\n\n对于 $100\\%$ 的数据， $1 \\le N \\le 20,|r| \\le 100, 100r\\in \\mathbb{Z} $\n\n友情提示\n\n请注意输入输出的效率。", "locale": "zh-CN"}}}
{"pid": "P4107", "type": "P", "difficulty": 6, "samples": [["10 4\n0 2 2 2 4 1 0 4 1 1\n3 6 2 3\n1 9\n1 8\n1 1\n0\n0\n2 7 4\n0\n1 5\n0", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2015", "各省省选", "河北"], "title": "[HEOI2015] 兔子与樱花", "background": "", "description": "很久很久之前，森林里住着一群兔子。有一天，兔子们突然决定要去看樱花。\n\n兔子们所在森林里的樱花树很特殊。樱花树由 $n$ 个树枝分叉点组成，编号从 $0$ 到 $n-1$，这 $n$ 个分叉点由 $n-1$ 个树枝连接，我们可以把它看成一个有根树结构，其中 $0$ 号节点是根节点。\n\n这个树的每个节点上都会有一些樱花，其中第 $i$ 个节点有 $c_i$ 朵樱花。樱花树的每一个节点都有最大的载重 $m$，对于每一个节点 $i$，它的儿子节点的个数和 $i$ 节点上樱花个数之和不能超过 $m$，即 $son(i) + c_i \\leq m$，其中 $son(i)$ 表示 $i$ 的儿子的个数，如果 $i$ 为叶子节点，则 $son(i) = 0$。\n\n现在兔子们觉得樱花树上节点太多，希望去掉一些节点。当一个节点被去掉之后，这个节点上的樱花和它的儿子节点都被连到删掉节点的父节点上。如果父节点也被删除，那么就会继续向上连接，直到第一个没有被删除的节点为止。\n\n现在兔子们希望计算在不违背最大载重的情况下，最多能删除多少节点。\n\n注意根节点不能被删除，被删除的节点不被计入载重。", "inputFormat": "第一行输入两个正整数，$n$ 和 $m$ 分别表示节点个数和最大载重。\n\n第二行 $n$ 个整数 $c_i$，表示第 $i$ 个节点上的樱花个数。\n\n接下来 $n$ 行，每行第一个数 $k_i$ 表示这个节点的儿子个数，接下来 $k_i$ 个整数表示这个节点儿子的编号。", "outputFormat": "一行一个整数，表示最多能删除多少节点。\n", "hint": "- 对于 $30\\%$ 的数据，$n \\leq 5 \\times 10^3$，$m \\leq 100$，$c_i \\leq 100$；\n- 对于 $70\\%$ 的数据，$n \\leq 2 \\times 10^5$，$m \\leq 2 \\times 10^3$，$c_i \\leq 10^3$；\n- 对于 $100\\%$ 的数据，$1 \\leq n \\leq 2 \\times 10^6$，$1 \\leq m \\leq 10^5$，$0 \\leq c_i \\leq 10^3$，保证初始时，每个节点樱花数与儿子节点个数之和大于 $0$ 且不超过 $m$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2015] Rabbits and Sakura", "background": "", "description": "A long time ago, a group of rabbits lived in a forest. One day, they suddenly decided to go see sakura.\n\nThe sakura tree in their forest is special. It consists of $n$ branch fork points, numbered from $0$ to $n-1$. These $n$ fork points are connected by $n-1$ branches, and we can regard it as a rooted tree where node $0$ is the root.\n\nEach node of the tree has some cherry blossoms; specifically, node $i$ has $c_i$ blossoms. Every node of the sakura tree has a maximum load $m$. For each node $i$, the sum of the number of its children and the number of blossoms on node $i$ must not exceed $m$, i.e., $son(i) + c_i \\leq m$, where $son(i)$ denotes the number of children of $i$. If $i$ is a leaf, then $son(i) = 0$.\n\nNow the rabbits think there are too many nodes on the sakura tree and want to remove some nodes. When a node is removed, the blossoms on this node and all its children are attached to the parent of the removed node. If the parent is also removed, they continue to attach upward until the first node that is not removed.\n\nThe rabbits want to compute the maximum number of nodes that can be removed without violating the maximum load.\n\nNote that the root cannot be removed, and deleted nodes are not counted toward the load.", "inputFormat": "The first line contains two positive integers, $n$ and $m$, denoting the number of nodes and the maximum load.\n\nThe second line contains $n$ integers $c_i$, where $c_i$ is the number of blossoms on node $i$.\n\nThen follow $n$ lines. In each line, the first number $k_i$ is the number of children of this node, followed by $k_i$ integers giving the indices of its children.", "outputFormat": "Output a single integer: the maximum number of nodes that can be removed.", "hint": "- For $30\\%$ of the testdata, $n \\leq 5 \\times 10^3$, $m \\leq 100$, $c_i \\leq 100$.\n- For $70\\%$ of the testdata, $n \\leq 2 \\times 10^5$, $m \\leq 2 \\times 10^3$, $c_i \\leq 10^3$.\n- For $100\\%$ of the testdata, $1 \\leq n \\leq 2 \\times 10^6$, $1 \\leq m \\leq 10^5$, $0 \\leq c_i \\leq 10^3$. It is guaranteed that initially, for every node, the sum of its number of blossoms and its number of children is greater than $0$ and does not exceed $m$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2015] 兔子与樱花", "background": "", "description": "很久很久之前，森林里住着一群兔子。有一天，兔子们突然决定要去看樱花。\n\n兔子们所在森林里的樱花树很特殊。樱花树由 $n$ 个树枝分叉点组成，编号从 $0$ 到 $n-1$，这 $n$ 个分叉点由 $n-1$ 个树枝连接，我们可以把它看成一个有根树结构，其中 $0$ 号节点是根节点。\n\n这个树的每个节点上都会有一些樱花，其中第 $i$ 个节点有 $c_i$ 朵樱花。樱花树的每一个节点都有最大的载重 $m$，对于每一个节点 $i$，它的儿子节点的个数和 $i$ 节点上樱花个数之和不能超过 $m$，即 $son(i) + c_i \\leq m$，其中 $son(i)$ 表示 $i$ 的儿子的个数，如果 $i$ 为叶子节点，则 $son(i) = 0$。\n\n现在兔子们觉得樱花树上节点太多，希望去掉一些节点。当一个节点被去掉之后，这个节点上的樱花和它的儿子节点都被连到删掉节点的父节点上。如果父节点也被删除，那么就会继续向上连接，直到第一个没有被删除的节点为止。\n\n现在兔子们希望计算在不违背最大载重的情况下，最多能删除多少节点。\n\n注意根节点不能被删除，被删除的节点不被计入载重。", "inputFormat": "第一行输入两个正整数，$n$ 和 $m$ 分别表示节点个数和最大载重。\n\n第二行 $n$ 个整数 $c_i$，表示第 $i$ 个节点上的樱花个数。\n\n接下来 $n$ 行，每行第一个数 $k_i$ 表示这个节点的儿子个数，接下来 $k_i$ 个整数表示这个节点儿子的编号。", "outputFormat": "一行一个整数，表示最多能删除多少节点。\n", "hint": "- 对于 $30\\%$ 的数据，$n \\leq 5 \\times 10^3$，$m \\leq 100$，$c_i \\leq 100$；\n- 对于 $70\\%$ 的数据，$n \\leq 2 \\times 10^5$，$m \\leq 2 \\times 10^3$，$c_i \\leq 10^3$；\n- 对于 $100\\%$ 的数据，$1 \\leq n \\leq 2 \\times 10^6$，$1 \\leq m \\leq 10^5$，$0 \\leq c_i \\leq 10^3$，保证初始时，每个节点樱花数与儿子节点个数之和大于 $0$ 且不超过 $m$。\n", "locale": "zh-CN"}}}
{"pid": "P4108", "type": "P", "difficulty": 6, "samples": [["10\n1353600 5821200 10752000 1670400 3729600 6844320 12544000 117600 59400 640\n10\nMODIFY 7 20321280\nQUERY 162343680\nQUERY 1832232960000\nMODIFY 0 92160\nQUERY 1234567\nQUERY 3989856000\nQUERY 833018560\nMODIFY 3 8600\nMODIFY 5 5306112\nQUERY 148900352", "6\n0\nno\n2\n8\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "各省省选", "数论", "河北", "枚举", "分块"], "title": "[HEOI2015] 公约数数列", "background": "", "description": "设计一个数据结构. 给定一个正整数数列 $a_0, a_1, \\cdots, a_{n - 1}$，你需要支持以下两种操作：\n\n\n1. $\\text{\\texttt{MODIFY} \\textit{id} \\textit{x}}$：将 $a_{id}$ 修改为 $x$；\n2. $\\text{\\texttt{QUERY} \\textit{x}}$：求最小的整数 $p \\ (0 \\le p < n)$，使得 $\\gcd(a_0, a_1, \\cdots, a_p) \\times  \\operatorname{xor}(a_0, a_1, \\cdots, a_p) = x$。其中 $\\operatorname{xor}(a_0, a_1, \\cdots, a_p)$ 代表 $a_0, a_1, \\cdots, a_p$ 的异或和，$\\gcd$ 表示最大公约数。\n", "inputFormat": "第一行包含一个正整数 $n$。\n\n接下来一行包含 $n$ 个正整数 $a_0,a_1,\\cdots,a_{n-1}$。\n\n之后一行包含一个正整数 $q$，表示询问的个数。\n\n之后 $q$ 行，每行包含一个询问。格式如题目中所述。", "outputFormat": "对于每个 $\\texttt{QUERY}$ 询问，在单独的一行中输出结果。如果不存在这样的 $p$，输出 `no`。", "hint": "### 数据范围及约定\n\n- 对于 $30\\%$ 的数据，$n\\le10^4$，$q\\le 1000$。\n- 对于 $100\\%$ 的数据，$n\\le10^5$，$q\\le 10000$，$1\\le a_i\\le 10^9$，询问操作中 $x \\le 10^{18}$，修改操作中 $0\\le id<n$，$1\\le x\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2015] Common Divisor Sequence", "background": "", "description": "Design a data structure. Given a sequence of positive integers $a_0, a_1, \\cdots, a_{n - 1}$, you need to support the following two operations:\n1. $\\text{\\texttt{MODIFY} \\textit{id} \\textit{x}}$: set $a_{id}$ to $x$.\n2. $\\text{\\texttt{QUERY} \\textit{x}}$: find the smallest integer $p$ ($0 \\le p < n$) such that $\\gcd(a_0, a_1, \\cdots, a_p) \\times \\operatorname{xor}(a_0, a_1, \\cdots, a_p) = x$. Here $\\operatorname{xor}(a_0, a_1, \\cdots, a_p)$ denotes the xor-sum of $a_0, a_1, \\cdots, a_p$, and $\\gcd$ denotes the greatest common divisor.", "inputFormat": "The first line contains a positive integer $n$.\nThe next line contains $n$ positive integers $a_0, a_1, \\cdots, a_{n - 1}$.\nThe next line contains a positive integer $q$, the number of queries.\nEach of the next $q$ lines contains one query, in the format described above.", "outputFormat": "For each $\\texttt{QUERY}$, output the result on a separate line. If no such $p$ exists, output `no`.", "hint": "Constraints\n- For 30% of the testdata, $n \\le 10^4$, $q \\le 1000$.\n- For 100% of the testdata, $n \\le 10^5$, $q \\le 10000$, $1 \\le a_i \\le 10^9$, in $\\texttt{QUERY}$ operations $x \\le 10^{18}$, in modify operations $0 \\le id < n$, $1 \\le x \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2015] 公约数数列", "background": "", "description": "设计一个数据结构. 给定一个正整数数列 $a_0, a_1, \\cdots, a_{n - 1}$，你需要支持以下两种操作：\n\n\n1. $\\text{\\texttt{MODIFY} \\textit{id} \\textit{x}}$：将 $a_{id}$ 修改为 $x$；\n2. $\\text{\\texttt{QUERY} \\textit{x}}$：求最小的整数 $p \\ (0 \\le p < n)$，使得 $\\gcd(a_0, a_1, \\cdots, a_p) \\times  \\operatorname{xor}(a_0, a_1, \\cdots, a_p) = x$。其中 $\\operatorname{xor}(a_0, a_1, \\cdots, a_p)$ 代表 $a_0, a_1, \\cdots, a_p$ 的异或和，$\\gcd$ 表示最大公约数。\n", "inputFormat": "第一行包含一个正整数 $n$。\n\n接下来一行包含 $n$ 个正整数 $a_0,a_1,\\cdots,a_{n-1}$。\n\n之后一行包含一个正整数 $q$，表示询问的个数。\n\n之后 $q$ 行，每行包含一个询问。格式如题目中所述。", "outputFormat": "对于每个 $\\texttt{QUERY}$ 询问，在单独的一行中输出结果。如果不存在这样的 $p$，输出 `no`。", "hint": "### 数据范围及约定\n\n- 对于 $30\\%$ 的数据，$n\\le10^4$，$q\\le 1000$。\n- 对于 $100\\%$ 的数据，$n\\le10^5$，$q\\le 10000$，$1\\le a_i\\le 10^9$，询问操作中 $x \\le 10^{18}$，修改操作中 $0\\le id<n$，$1\\le x\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4109", "type": "P", "difficulty": 3, "samples": [["3\n998 1002\n998 2002\n4000 6000", "1000\n1000\n5000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "各省省选", "河北", "枚举", "分块"], "title": "[HEOI2015] 定价", "background": "", "description": "在市场上有很多商品的定价类似于 999 元、4999 元、8999 元这样。它们和 1000 元、5000 元和 9000 元并没有什么本质区别，但是在心理学上会让人感觉便宜很多，因此也是商家常用的价格策略。不过在你看来，这种价格十分荒谬。于是你如此计算一个价格 $p$（$p$ 为正整数）的荒谬程度：\n\n1. 首先将 $p$ 看做一个由数字组成的字符串（不带前导 $0$）；\n2. 然后，如果 $p$ 的最后一个字符是 $0$，就去掉它。重复这一过程，直到 $p$ 的最后一个字符不是 $0$；\n3. 记 $p$ 的长度为 $a$，如果此时 $p$ 的最后一位是 $5$，则荒谬程度为 $2a - 1$；否则为 $2a$。\n\n例如，$850$ 的荒谬程度为 $3$，而 $880$ 则为 $4$，$9999$ 的荒谬程度为 $8$。\n\n现在，你要出售一样闲置物品，你能接受的定价在 $[L, R]$ 范围内，你想要给出一个荒谬度最低的价格。", "inputFormat": "输入文件的第一行包含一个正整数 $T$，表示测试数据的数目。\n\n每个测试数据占单独的一行，包含两个空格分隔的正整数 $L, R$，表示定价的区间。", "outputFormat": "对于每个测试数据，在单独的一行内输出结果。如果荒谬度最低的价格不唯一，输出最小的那个。", "hint": "- 对于 $20\\%$ 的数据，$L, R \\leq 2000$；\n- 对于 $100\\%$ 的数据，$T \\leq 100$，$1 \\leq L \\leq R \\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2015] Pricing", "background": "", "description": "In the market, many goods are priced like 999 yuan, 4999 yuan, 8999 yuan. They are essentially no different from 1000 yuan, 5000 yuan, and 9000 yuan, but psychologically they make people feel much cheaper, so this is a common pricing strategy used by merchants. However, in your view, such prices are absurd. Therefore, you define the absurdity of a price $p$ ($p$ is a positive integer) as follows:\n\n1. First, treat $p$ as a string of digits (without leading $0$).\n2. Then, if the last character of $p$ is $0$, remove it. Repeat this process until the last character of $p$ is not $0$.\n3. Let the length of $p$ be $a$. If the last digit is $5$, the absurdity is $2a - 1$; otherwise, it is $2a$.\n\nFor example, the absurdity of 850 is 3, for 880 it is 4, and the absurdity of 9999 is 8.\n\nNow, you want to sell an idle item. The acceptable price is within the range $[L, R]$. You want to choose a price with the lowest absurdity.", "inputFormat": "The first line of input contains a positive integer $T$, indicating the number of testdata.\n\nEach test case is on a separate line and contains two space-separated positive integers $L, R$, indicating the pricing interval.", "outputFormat": "For each test case, output the result on a separate line. If the price with the lowest absurdity is not unique, output the smallest one.", "hint": "- For $20\\%$ of the testdata, $L, R \\leq 2000$.\n- For $100\\%$ of the testdata, $T \\leq 100$, $1 \\leq L \\leq R \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2015] 定价", "background": "", "description": "在市场上有很多商品的定价类似于 999 元、4999 元、8999 元这样。它们和 1000 元、5000 元和 9000 元并没有什么本质区别，但是在心理学上会让人感觉便宜很多，因此也是商家常用的价格策略。不过在你看来，这种价格十分荒谬。于是你如此计算一个价格 $p$（$p$ 为正整数）的荒谬程度：\n\n1. 首先将 $p$ 看做一个由数字组成的字符串（不带前导 $0$）；\n2. 然后，如果 $p$ 的最后一个字符是 $0$，就去掉它。重复这一过程，直到 $p$ 的最后一个字符不是 $0$；\n3. 记 $p$ 的长度为 $a$，如果此时 $p$ 的最后一位是 $5$，则荒谬程度为 $2a - 1$；否则为 $2a$。\n\n例如，$850$ 的荒谬程度为 $3$，而 $880$ 则为 $4$，$9999$ 的荒谬程度为 $8$。\n\n现在，你要出售一样闲置物品，你能接受的定价在 $[L, R]$ 范围内，你想要给出一个荒谬度最低的价格。", "inputFormat": "输入文件的第一行包含一个正整数 $T$，表示测试数据的数目。\n\n每个测试数据占单独的一行，包含两个空格分隔的正整数 $L, R$，表示定价的区间。", "outputFormat": "对于每个测试数据，在单独的一行内输出结果。如果荒谬度最低的价格不唯一，输出最小的那个。", "hint": "- 对于 $20\\%$ 的数据，$L, R \\leq 2000$；\n- 对于 $100\\%$ 的数据，$T \\leq 100$，$1 \\leq L \\leq R \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4110", "type": "P", "difficulty": 6, "samples": [["3\n1 2\n0/1 3\n1 2\n1/1 3\n1 2\n1/2 3", "0.000000\n0.000000\n0.250000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "各省省选", "河北"], "title": "[HEOI2015] 小L的白日梦", "background": null, "description": "在某一天，你有了一个女性朋友。\n\n你打算利用 $k$ 天时间陪她，每天有很多种娱乐方式可供选择，你需要从中选择一种进行（一天只能进行一个项目），比如说一起去看电影、一起去主题公园，一起去逛街等等，一共 $n$ 种项目。当然每个项目重复太多次你都会觉得无聊，因此第 $i$ 个项目最多进行 $c_i$ 次。\n\n你虽然智商很高，但是情商堪忧，即使这些你准备的活动都是希望让她开心的，不过由于你笨拙的语言表达和过于理智的行动，可能使这些活动出现意外。经过你悉心的计算，你发现如果某一天进行了第 $i$ 个项目，如果一切顺利的话她应该是很高兴的，但她会有一定概率不高兴。如果她本来是很高兴的，但突然今天你让她不高兴了，她就会觉得很失落，并且对你的好感度大大下降。你希望尽可能避免这种情况发生，因此你要安排这 $k$ 天之内每天进行的项目，最小化她感到失落的期望次数。\n\n你的女性朋友十分在意你，所以她的心情只会因为你发生改变。第一天之前，因为你没有邀请她进行任何活动，所以她是不高兴的。", "inputFormat": "第一行有一个非负整数 $t$，表示一共有 $t$ 组数据。\n\n对于每组数据，第一行有两个非负整数 $n,k$，分别表示你准备的项目个数和你用来陪她的天数。$(1 \\le n \\le 10^5,1 \\le k \\le 10^9)$\n\n接下来 $n$ 行，每一行描述一个项目，形如 `x/y c` 且三个数均为非负整数，表示进行完这个项目之后她有 $\\dfrac{x_i}{y_i}$ 的概率不高兴，并且这个项目只能进行不超过 $c_i$ 次。$(x_i,y_i \\le 10^4,c_i \\le 10^9)$", "outputFormat": "一共 $t$ 行，对于每组数据输出使她感到失落的最小期望次数，四舍五入保留 $6$ 位小数。", "hint": "【样例说明】\n\n考虑第三组数据，因为只有一个项目所以只好每天都安排这个。\n\n在第一天之前她总是不高兴的，一共有：\n\n第一天不高兴，第二天也不高兴、\n\n第一天高兴，第二天不高兴、\n\n第一天不高兴，第二天高兴、\n\n第一天高兴，第二天也高兴。\n\n这四种情况，又因为每天的项目让她高兴或者是不高兴的概率都是 $50\\%$，因此这四种情况是等概率发生的。\n\n只有在第二种情况下，她会感到失落一次。\n\n因此答案是 $\\dfrac{0+1+0+0}{4}=0.25$。\n\n【数据规模与约定】\n\n对于前10%的数据，$n,k \\le 5$。\n\n对于前30%的数据，$n,k \\le 7$。\n\n对于前40%的数据，$n,k \\le 10$。\n\n对于前60%的数据，$n \\le 10^3,k \\le 10^5$。\n\n对于100%的数据，$1 \\le n \\le 10^5,1 \\le k \\le 10^9，1 \\le t \\le 10$，数据保证分数有意义并且 $\\sum\\limits_{i=1}^nc_i \\ge k$。", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2015] Xiao L's Daydream", "background": "", "description": "One day, you made a female friend.\n\nYou plan to spend $k$ days with her. Each day there are many types of activities to choose from, and you must choose exactly one to do that day (only one activity per day), such as going to the movies, going to a theme park, going shopping, and so on, for a total of $n$ activities. Of course, repeating the same activity too many times will feel boring to you, so the $i$-th activity can be done at most $c_i$ times.\n\nAlthough you have a high IQ, your EQ leaves much to be desired. Even though these activities are meant to make her happy, your awkward words and overly rational behavior may cause mishaps. After careful calculation, you find that if on some day you do the $i$-th activity, she should be happy if everything goes well, but there is a certain probability that she will be unhappy. If she would otherwise be happy but you make her unhappy today, she will feel very let down, and her favorable impression of you will drop sharply. You want to avoid this as much as possible, so you must schedule which activity to do each of the $k$ days to minimize the expected number of times she feels let down.\n\nShe cares a lot about you, so her mood changes only because of you. Before day 1, since you have not invited her to do any activity, she is unhappy.", "inputFormat": "The first line contains a non-negative integer $t$, the number of test cases.\n\nFor each test case, the first line contains two non-negative integers $n, k$, representing the number of activities you prepared and the number of days you will spend with her. $(1 \\le n \\le 10^5, 1 \\le k \\le 10^9)$\n\nThen follow $n$ lines, each describing one activity, in the form `x/y c`, where all three numbers are non-negative integers. It means that after doing this activity, she will be unhappy with probability $\\dfrac{x_i}{y_i}$, and this activity can be done at most $c_i$ times. $(x_i, y_i \\le 10^4, c_i \\le 10^9)$", "outputFormat": "Output $t$ lines. For each test case, print the minimal expected number of times she feels let down, rounded to 6 decimal places.", "hint": "[Sample Explanation]\n\nConsider the third test case. Since there is only one activity, you have to schedule it every day.\n\nBefore day 1 she is always unhappy. There are four cases:\nunhappy on day 1 and unhappy on day 2, happy on day 1 and unhappy on day 2, unhappy on day 1 and happy on day 2, happy on day 1 and happy on day 2. These four cases are equally likely because the activity makes her happy or unhappy each day with probability $50\\%$.\n\nOnly in the second case does she feel let down once.\n\nTherefore the answer is $\\dfrac{0+1+0+0}{4}=0.25$.\n\n[Constraints and Conventions]\n\nFor the first 10% of the testdata, $n, k \\le 5$.\n\nFor the first 30% of the testdata, $n, k \\le 7$.\n\nFor the first 40% of the testdata, $n, k \\le 10$.\n\nFor the first 60% of the testdata, $n \\le 10^3, k \\le 10^5$.\n\nFor 100% of the testdata, $1 \\le n \\le 10^5, 1 \\le k \\le 10^9, 1 \\le t \\le 10$. The testdata guarantees the fractions are meaningful and $\\sum\\limits_{i=1}^n c_i \\ge k$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2015] 小L的白日梦", "background": null, "description": "在某一天，你有了一个女性朋友。\n\n你打算利用 $k$ 天时间陪她，每天有很多种娱乐方式可供选择，你需要从中选择一种进行（一天只能进行一个项目），比如说一起去看电影、一起去主题公园，一起去逛街等等，一共 $n$ 种项目。当然每个项目重复太多次你都会觉得无聊，因此第 $i$ 个项目最多进行 $c_i$ 次。\n\n你虽然智商很高，但是情商堪忧，即使这些你准备的活动都是希望让她开心的，不过由于你笨拙的语言表达和过于理智的行动，可能使这些活动出现意外。经过你悉心的计算，你发现如果某一天进行了第 $i$ 个项目，如果一切顺利的话她应该是很高兴的，但她会有一定概率不高兴。如果她本来是很高兴的，但突然今天你让她不高兴了，她就会觉得很失落，并且对你的好感度大大下降。你希望尽可能避免这种情况发生，因此你要安排这 $k$ 天之内每天进行的项目，最小化她感到失落的期望次数。\n\n你的女性朋友十分在意你，所以她的心情只会因为你发生改变。第一天之前，因为你没有邀请她进行任何活动，所以她是不高兴的。", "inputFormat": "第一行有一个非负整数 $t$，表示一共有 $t$ 组数据。\n\n对于每组数据，第一行有两个非负整数 $n,k$，分别表示你准备的项目个数和你用来陪她的天数。$(1 \\le n \\le 10^5,1 \\le k \\le 10^9)$\n\n接下来 $n$ 行，每一行描述一个项目，形如 `x/y c` 且三个数均为非负整数，表示进行完这个项目之后她有 $\\dfrac{x_i}{y_i}$ 的概率不高兴，并且这个项目只能进行不超过 $c_i$ 次。$(x_i,y_i \\le 10^4,c_i \\le 10^9)$", "outputFormat": "一共 $t$ 行，对于每组数据输出使她感到失落的最小期望次数，四舍五入保留 $6$ 位小数。", "hint": "【样例说明】\n\n考虑第三组数据，因为只有一个项目所以只好每天都安排这个。\n\n在第一天之前她总是不高兴的，一共有：\n\n第一天不高兴，第二天也不高兴、\n\n第一天高兴，第二天不高兴、\n\n第一天不高兴，第二天高兴、\n\n第一天高兴，第二天也高兴。\n\n这四种情况，又因为每天的项目让她高兴或者是不高兴的概率都是 $50\\%$，因此这四种情况是等概率发生的。\n\n只有在第二种情况下，她会感到失落一次。\n\n因此答案是 $\\dfrac{0+1+0+0}{4}=0.25$。\n\n【数据规模与约定】\n\n对于前10%的数据，$n,k \\le 5$。\n\n对于前30%的数据，$n,k \\le 7$。\n\n对于前40%的数据，$n,k \\le 10$。\n\n对于前60%的数据，$n \\le 10^3,k \\le 10^5$。\n\n对于100%的数据，$1 \\le n \\le 10^5,1 \\le k \\le 10^9，1 \\le t \\le 10$，数据保证分数有意义并且 $\\sum\\limits_{i=1}^nc_i \\ge k$。", "locale": "zh-CN"}}}
{"pid": "P4111", "type": "P", "difficulty": 6, "samples": [["2 2\n..\n..\n", "4\n"], ["2 2\n*.\n.*\n", "0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "各省省选", "矩阵树定理", "河北", "生成树", "素数判断,质数,筛法", "高斯消元"], "title": "[HEOI2015] 小 Z 的房间", "background": "", "description": "你突然有了一个大房子，房子里面有一些房间。事实上，你的房子可以看做是一个包含 $n\\times m$ 个格子的格状矩形，每个格子是一个房间或者是一个柱子。在一开始的时候，相邻的格子之间都有墙隔着。\n\n你想要打通一些相邻房间的墙，使得所有房间能够互相到达。在此过程中，你不能把房子给打穿，或者打通柱子（以及柱子旁边的墙）。同时，你不希望在房子中有小偷的时候会很难抓，所以你希望任意两个房间之间都只有一条通路。现在，你希望统计一共有多少种可行的方案，答案对 $10^9$ 取模。\n", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来 $n$ 行，每行 $m$ 个字符 `.` 或 `*`，其中 `.` 代表房间，`*` 代表柱子。\n", "outputFormat": "一行一个整数，表示合法的方案数对 $10^9$ 取模后的值。", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，$n,m \\le 3$。\n- 对于 $50\\%$ 的数据，$n,m \\le 5$。\n- 有 $40\\%$ 的数据，$\\min(n,m) \\le 3$。\n- 有 $30\\%$ 的数据，不存在柱子。\n- 对于 $100\\%$ 的数据，$1 \\le n,m \\le 9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2015] Xiao Z's Room", "background": "", "description": "You suddenly have a big house, which contains some rooms. In fact, your house can be regarded as a grid rectangle with $n\\times m$ cells, where each cell is either a room or a pillar. Initially, there is a wall between every pair of adjacent cells.\n\nYou want to knock down some walls between adjacent rooms so that all rooms become mutually reachable. During this process, you must not break through the house boundary, nor open a pillar (as well as the walls next to a pillar). Meanwhile, you do not want it to be hard to catch thieves, so you require that there be exactly one path between any two rooms. Now, count how many feasible plans there are; output the answer modulo $10^9$.", "inputFormat": "The first line contains two integers $n,m$.\n\nThen follow $n$ lines, each containing $m$ characters `.` or `*`, where `.` denotes a room and `*` denotes a pillar.", "outputFormat": "Output a single integer, the number of valid plans modulo $10^9$.", "hint": "Constraints\n\n- For $20\\%$ of the testdata, $n,m \\le 3$.\n- For $50\\%$ of the testdata, $n,m \\le 5$.\n- For $40\\%$ of the testdata, $\\min(n,m) \\le 3$.\n- For $30\\%$ of the testdata, there are no pillars.\n- For $100\\%$ of the testdata, $1 \\le n,m \\le 9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2015] 小 Z 的房间", "background": "", "description": "你突然有了一个大房子，房子里面有一些房间。事实上，你的房子可以看做是一个包含 $n\\times m$ 个格子的格状矩形，每个格子是一个房间或者是一个柱子。在一开始的时候，相邻的格子之间都有墙隔着。\n\n你想要打通一些相邻房间的墙，使得所有房间能够互相到达。在此过程中，你不能把房子给打穿，或者打通柱子（以及柱子旁边的墙）。同时，你不希望在房子中有小偷的时候会很难抓，所以你希望任意两个房间之间都只有一条通路。现在，你希望统计一共有多少种可行的方案，答案对 $10^9$ 取模。\n", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来 $n$ 行，每行 $m$ 个字符 `.` 或 `*`，其中 `.` 代表房间，`*` 代表柱子。\n", "outputFormat": "一行一个整数，表示合法的方案数对 $10^9$ 取模后的值。", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，$n,m \\le 3$。\n- 对于 $50\\%$ 的数据，$n,m \\le 5$。\n- 有 $40\\%$ 的数据，$\\min(n,m) \\le 3$。\n- 有 $30\\%$ 的数据，不存在柱子。\n- 对于 $100\\%$ 的数据，$1 \\le n,m \\le 9$。\n", "locale": "zh-CN"}}}
{"pid": "P4112", "type": "P", "difficulty": 6, "samples": [["aabbcc\nabcabc", "2\n4\n2\n4"], ["aabbcc\naabbcc", "-1\n-1\n2\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "各省省选", "河北", "后缀自动机 SAM", "O2优化", "广度优先搜索 BFS", "后缀数组 SA"], "title": "[HEOI2015] 最短不公共子串", "background": null, "description": "在虐各种最长公共子串、子序列的题虐的不耐烦了之后，你决定反其道而行之。\n\n下面给出一些定义：\n\n- 一个串的“子串”指的是它的连续的一段，例如 `bcd` 是 `abcdef` 的子串，但 `bde` 不是。\n- 一个串的“子序列”指的是它的可以不连续的一段，例如 `bde` 是 `abcdef` 的子序列，但 `bdd` 不是。\n\n下面，给两个小写字母串 $a, b$，请你计算：\n\n1. $a$ 的一个最短的子串，它不是 $b$ 的子串。\n2. $a$ 的一个最短的子串，它不是 $b$ 的子序列。\n3. $a$ 的一个最短的子序列，它不是 $b$ 的子串。\n4. $a$ 的一个最短的子序列，它不是 $b$ 的子序列。", "inputFormat": "有两行，每行一个小写字母组成的字符串，分别代表 $a$ 和 $b$。", "outputFormat": "输出 $4$ 行，每行一个整数，依次表示以上 $4$ 个问题的答案的长度。如果没有符合要求的答案，输出 $-1$。", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $20$。\n- 对于 $50\\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $500$。\n- 对于 $100\\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $2000$。", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2015] Shortest Uncommon Substring", "background": "", "description": "Tired of problems about the longest common substrings and subsequences, you decide to go the other way.\n\nDefinitions:\n- A \"substring\" of a string is a contiguous segment of it. For example, `bcd` is a substring of `abcdef`, but `bde` is not.\n- A \"subsequence\" of a string is a segment that does not need to be contiguous. For example, `bde` is a subsequence of `abcdef`, but `bdd` is not.\n\nGiven two lowercase strings $a, b$, please compute:\n1. A shortest substring of $a$ that is not a substring of $b$.\n2. A shortest substring of $a$ that is not a subsequence of $b$.\n3. A shortest subsequence of $a$ that is not a substring of $b$.\n4. A shortest subsequence of $a$ that is not a subsequence of $b$.", "inputFormat": "There are two lines, each containing a string of lowercase letters, representing $a$ and $b$ respectively.", "outputFormat": "Output $4$ lines, each containing one integer, representing the lengths of the answers to the above $4$ questions in order. If there is no valid answer, output $-1$.", "hint": "Constraints:\n- For $20\\%$ of the testdata, the lengths of $a$ and $b$ do not exceed $20$.\n- For $50\\%$ of the testdata, the lengths of $a$ and $b$ do not exceed $500$.\n- For $100\\%$ of the testdata, the lengths of $a$ and $b$ do not exceed $2000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2015] 最短不公共子串", "background": null, "description": "在虐各种最长公共子串、子序列的题虐的不耐烦了之后，你决定反其道而行之。\n\n下面给出一些定义：\n\n- 一个串的“子串”指的是它的连续的一段，例如 `bcd` 是 `abcdef` 的子串，但 `bde` 不是。\n- 一个串的“子序列”指的是它的可以不连续的一段，例如 `bde` 是 `abcdef` 的子序列，但 `bdd` 不是。\n\n下面，给两个小写字母串 $a, b$，请你计算：\n\n1. $a$ 的一个最短的子串，它不是 $b$ 的子串。\n2. $a$ 的一个最短的子串，它不是 $b$ 的子序列。\n3. $a$ 的一个最短的子序列，它不是 $b$ 的子串。\n4. $a$ 的一个最短的子序列，它不是 $b$ 的子序列。", "inputFormat": "有两行，每行一个小写字母组成的字符串，分别代表 $a$ 和 $b$。", "outputFormat": "输出 $4$ 行，每行一个整数，依次表示以上 $4$ 个问题的答案的长度。如果没有符合要求的答案，输出 $-1$。", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $20$。\n- 对于 $50\\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $500$。\n- 对于 $100\\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $2000$。", "locale": "zh-CN"}}}
{"pid": "P4113", "type": "P", "difficulty": 5, "samples": [["5 3 5\n1 2 2 3 1\n1 5\n1 2\n2 2\n2 3\n3 5", "2\n0\n0\n1\n0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2012", "线段树", "各省省选", "树状数组", "河北", "排序", "前缀和", "扫描线", "离线处理"], "title": "[HEOI2012] 采花", "background": "", "description": "萧薰儿是古国的公主，平时的一大爱好是采花。\n\n今天天气晴朗，阳光明媚，公主清晨便去了皇宫中新建的花园采花。\n\n花园足够大，容纳了 $n$ 朵花，共有 $c$ 种颜色，用整数 $1 \\sim c$ 表示。且花是排成一排的，以便于公主采花。公主每次采花后会统计采到的花的颜色数，颜色数越多她会越高兴。同时，她有一癖好，她不允许最后自己采到的花中，某一颜色的花只有一朵。为此，公主每采一朵花，要么此前已采到此颜色的花，要么有相当正确的直觉告诉她，她必能再次采到此颜色的花。\n\n由于时间关系，公主只能走过花园连续的一段进行采花，便让女仆福涵洁安排行程。福涵洁综合各种因素拟定了 $m$ 个行程，然后一一向你询问公主能采到的花共有几种不同的颜色。", "inputFormat": "输入的第一行是三个用空格隔开的整数，分别代表花的个数 $n$，花的颜色数 $c$，以及行程数 $m$。\n\n输入的第二行是 $n$ 个用空格隔开的整数，第 $i$ 个整数代表第 $i$ 朵花的颜色 $x_i$。\n\n第 $3$ 行到第 $(m + 2)$ 行，每行两个整数 $l, r$，第 $(i + 2)$ 行的数字代表第 $i$ 次行程为第 $l$ 到第 $r$ 朵花。", "outputFormat": "共输出 $m$ 行，每行一个整数。第 $i$ 行的整数代表第 $i$ 次行程公主能采到的花共有几种不同的颜色。", "hint": "#### 输入输出样例 $1$ 解释\n\n共有五朵花，颜色分别为 $1,~2,~2,~3,~1$。\n\n对于第一次行程，公主采花的区间为 $[1, 5]$，可以采位置 $1,~2,~3,~5$ 处的花，共有 $1$ 和 $2$ 两种不同的颜色。\n\n对于第二次行程，公主采花的区间为 $[1, 2]$，但是颜色为 $1$ 和 $2$ 的花都只出现了一次，因此公主无花可采。\n\n对于第三次行程，公主采花的区间为 $[2, 2]$，但是颜色为 $2$ 的花只出现了一次，公主无花可采。\n\n对于第四次行程，公主采花的区间为 $[2, 3]$，可以采 $2,~3$ 位置的花，只有 $2$ 这一种颜色。\n\n对于第五次行程，公主采花的区间为 $[3,5]$，但是颜色为 $1, 2, 3$ 的花都只出现了一次，因此公主无花可采。\n\n#### 数据范围与约定\n\n**本题采用多测试点捆绑测试，共有两个子任务**。\n\n对于子任务 $1$，分值为 $100$ 分，保证 $1 \\leq n, c, m \\leq 3 \\times 10^5$。\n\n对于子任务 $2$，分值为 $100$ 分，保证 $1 \\leq n, c, m \\leq 2 \\times 10^6$。\n\n对于全部的测试点，保证 $1 \\leq x_i \\leq c$，$1 \\leq l \\leq r \\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "[HEOI2012] Picking Flowers", "background": "", "description": "Xiao Xun'er is the princess of an ancient kingdom, and one of her hobbies is picking flowers.\n\nToday the weather is fine and sunny, so the princess went to the newly built palace garden in the morning to pick flowers.\n\nThe garden is large enough to hold $n$ flowers in total, with $c$ colors labeled by integers $1 \\sim c$. The flowers are arranged in a single row to make it convenient for the princess to pick. After each picking session, the princess counts how many different colors she has collected; the more colors, the happier she is. At the same time, she has a quirk: she does not allow that, among the flowers she finally picks, any color appears only once. For this reason, every time she picks a flower, either she has already picked a flower of that color before, or her accurate intuition tells her she will be able to pick that color again.\n\nDue to time constraints, the princess can only walk through one continuous segment of the garden to pick flowers, so the maid Fuhan Jie arranged $m$ trips after considering various factors. For each trip, you are asked how many different colors the princess can collect.", "inputFormat": "The first line contains three space-separated integers, representing the number of flowers $n$, the number of colors $c$, and the number of trips $m$.\n\nThe second line contains $n$ space-separated integers. The $i$-th integer is the color $x_i$ of the $i$-th flower.\n\nFrom line $3$ to line $(m + 2)$, each line contains two integers $l, r$. On line $(i + 2)$, the numbers represent that the $i$-th trip covers flowers from the $l$-th to the $r$-th.", "outputFormat": "Output $m$ lines, one integer per line. The integer on the $i$-th line is the number of different colors the princess can collect on the $i$-th trip.", "hint": "Explanation for Sample 1:\n\nThere are five flowers, and their colors are $1,~2,~2,~3,~1$.\n\nFor the first trip, the picking interval is $[1, 5]$. She can pick the flowers at positions $1,~2,~3,~5$, so there are two different colors, $1$ and $2$.\n\nFor the second trip, the picking interval is $[1, 2]$, but the flowers of colors $1$ and $2$ each appear only once, so the princess cannot pick any flower.\n\nFor the third trip, the picking interval is $[2, 2]$, but color $2$ appears only once, so the princess cannot pick any flower.\n\nFor the fourth trip, the picking interval is $[2, 3]$. She can pick the flowers at positions $2,~3$, and there is only one color, $2$.\n\nFor the fifth trip, the picking interval is $[3,5]$, but colors $1, 2, 3$ each appear only once, so the princess cannot pick any flower.\n\nConstraints:\n\nThis problem uses bundled multi-test-point evaluation and has two subtasks.\n\nFor subtask $1$ (worth $100$ points), it is guaranteed that $1 \\leq n, c, m \\leq 3 \\times 10^5$.\n\nFor subtask $2$ (worth $100$ points), it is guaranteed that $1 \\leq n, c, m \\leq 2 \\times 10^6$.\n\nFor all test points, it is guaranteed that $1 \\leq x_i \\leq c$, $1 \\leq l \\leq r \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HEOI2012] 采花", "background": "", "description": "萧薰儿是古国的公主，平时的一大爱好是采花。\n\n今天天气晴朗，阳光明媚，公主清晨便去了皇宫中新建的花园采花。\n\n花园足够大，容纳了 $n$ 朵花，共有 $c$ 种颜色，用整数 $1 \\sim c$ 表示。且花是排成一排的，以便于公主采花。公主每次采花后会统计采到的花的颜色数，颜色数越多她会越高兴。同时，她有一癖好，她不允许最后自己采到的花中，某一颜色的花只有一朵。为此，公主每采一朵花，要么此前已采到此颜色的花，要么有相当正确的直觉告诉她，她必能再次采到此颜色的花。\n\n由于时间关系，公主只能走过花园连续的一段进行采花，便让女仆福涵洁安排行程。福涵洁综合各种因素拟定了 $m$ 个行程，然后一一向你询问公主能采到的花共有几种不同的颜色。", "inputFormat": "输入的第一行是三个用空格隔开的整数，分别代表花的个数 $n$，花的颜色数 $c$，以及行程数 $m$。\n\n输入的第二行是 $n$ 个用空格隔开的整数，第 $i$ 个整数代表第 $i$ 朵花的颜色 $x_i$。\n\n第 $3$ 行到第 $(m + 2)$ 行，每行两个整数 $l, r$，第 $(i + 2)$ 行的数字代表第 $i$ 次行程为第 $l$ 到第 $r$ 朵花。", "outputFormat": "共输出 $m$ 行，每行一个整数。第 $i$ 行的整数代表第 $i$ 次行程公主能采到的花共有几种不同的颜色。", "hint": "#### 输入输出样例 $1$ 解释\n\n共有五朵花，颜色分别为 $1,~2,~2,~3,~1$。\n\n对于第一次行程，公主采花的区间为 $[1, 5]$，可以采位置 $1,~2,~3,~5$ 处的花，共有 $1$ 和 $2$ 两种不同的颜色。\n\n对于第二次行程，公主采花的区间为 $[1, 2]$，但是颜色为 $1$ 和 $2$ 的花都只出现了一次，因此公主无花可采。\n\n对于第三次行程，公主采花的区间为 $[2, 2]$，但是颜色为 $2$ 的花只出现了一次，公主无花可采。\n\n对于第四次行程，公主采花的区间为 $[2, 3]$，可以采 $2,~3$ 位置的花，只有 $2$ 这一种颜色。\n\n对于第五次行程，公主采花的区间为 $[3,5]$，但是颜色为 $1, 2, 3$ 的花都只出现了一次，因此公主无花可采。\n\n#### 数据范围与约定\n\n**本题采用多测试点捆绑测试，共有两个子任务**。\n\n对于子任务 $1$，分值为 $100$ 分，保证 $1 \\leq n, c, m \\leq 3 \\times 10^5$。\n\n对于子任务 $2$，分值为 $100$ 分，保证 $1 \\leq n, c, m \\leq 2 \\times 10^6$。\n\n对于全部的测试点，保证 $1 \\leq x_i \\leq c$，$1 \\leq l \\leq r \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P4114", "type": "P", "difficulty": 5, "samples": [["3\n1 2 1\n2 3 2\nQUERY 1 2\nCHANGE 1 3\nQUERY 1 2\nDONE", "1\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["线段树", "树链剖分"], "title": "Qtree1", "background": "**数据规模和 spoj 上有所不同**。", "description": "给定一棵 $n$ 个节点的树，有两种操作：  \n- `CHANGE i t` 把第 $i$ 条边的边权变成 $t$  \n- `QUERY a b` 输出从 $a$ 到 $b$ 的路径上最大的边权。当 $a=b$ 时，输出 $0$  ", "inputFormat": "第一行是一个整数 $n$，表示节点个数。  \n第二行到第 $n$ 行每行输入三个整数 $u,v,w$ ，分别表示 $u$ 与 $v$ 有一条边，边权是 $w$。  \n第 $n+1$ 行开始，一共有不定数量行，每一行先包含一个字符串，分别有以下三种可能：  \n\n- `CHANGE`  接下来包含两个整数 $x, t$ ，表示一次修改操作。  \n- `QUERY`  接下来包含两个正整数 $a, b$ ， 表示一次查询操作。  \n- `DONE`  表示输入结束。\n", "outputFormat": "对于每个 `QUERY` 操作，输出一行一个数，表示 $a,b$ 的路径上最大的边权。  ", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n- $1 \\leq n \\leq 10^5$。\n- $1 \\leq u, v, a, b \\leq n$，$1 \\leq x < n$。\n- $1 \\leq w, t \\leq 2^{31} - 1$。\n- 操作次数不大于 $3 \\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Qtree1", "background": "The constraints differ from those on SPOJ.", "description": "Given a tree with $n$ nodes, there are two operations:\n- `CHANGE i t` set the weight of the $i$-th edge to $t$.\n- `QUERY a b` output the maximum edge weight on the path from $a$ to $b$. When $a = b$, output $0$.", "inputFormat": "The first line contains an integer $n$, the number of nodes.\nLines $2$ through $n$ each contain three integers $u, v, w$, indicating that there is an edge between $u$ and $v$ with weight $w$.\nStarting from line $n + 1$, there are an unspecified number of lines. Each line starts with a string, which can be one of:\n- `CHANGE` followed by two integers $x, t$, indicating an update operation.\n- `QUERY` followed by two positive integers $a, b$, indicating a query operation.\n- `DONE` indicating the end of input.", "outputFormat": "For each `QUERY` operation, output one line with a single number: the maximum edge weight on the path between $a$ and $b$.", "hint": "Constraints\n\nFor all test points, it is guaranteed that:\n- $1 \\leq n \\leq 10^5$.\n- $1 \\leq u, v, a, b \\leq n$, $1 \\leq x < n$.\n- $1 \\leq w, t \\leq 2^{31} - 1$.\n- The number of operations does not exceed $3 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Qtree1", "background": "**数据规模和 spoj 上有所不同**。", "description": "给定一棵 $n$ 个节点的树，有两种操作：  \n- `CHANGE i t` 把第 $i$ 条边的边权变成 $t$  \n- `QUERY a b` 输出从 $a$ 到 $b$ 的路径上最大的边权。当 $a=b$ 时，输出 $0$  ", "inputFormat": "第一行是一个整数 $n$，表示节点个数。  \n第二行到第 $n$ 行每行输入三个整数 $u,v,w$ ，分别表示 $u$ 与 $v$ 有一条边，边权是 $w$。  \n第 $n+1$ 行开始，一共有不定数量行，每一行先包含一个字符串，分别有以下三种可能：  \n\n- `CHANGE`  接下来包含两个整数 $x, t$ ，表示一次修改操作。  \n- `QUERY`  接下来包含两个正整数 $a, b$ ， 表示一次查询操作。  \n- `DONE`  表示输入结束。\n", "outputFormat": "对于每个 `QUERY` 操作，输出一行一个数，表示 $a,b$ 的路径上最大的边权。  ", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n- $1 \\leq n \\leq 10^5$。\n- $1 \\leq u, v, a, b \\leq n$，$1 \\leq x < n$。\n- $1 \\leq w, t \\leq 2^{31} - 1$。\n- 操作次数不大于 $3 \\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4115", "type": "P", "difficulty": 6, "samples": [["3\n1 2 1\n1 3 1\n7\nA\nC 1\nA\nC 2\nA\nC 3\nA", "2\n2\n0\nThey have disappeared."]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["点分治", "堆", "O2优化", "分治", "树链剖分"], "title": "Qtree4", "background": "数据范围和 SPOJ 略有不同。", "description": "给出一棵边带权的节点数量为 $n$ 的树，初始树上所有节点都是白色。有两种操作：\n\n- `C x`，改变节点 $x$ 的颜色，即白变黑，黑变白。\n\n- `A`，询问树中最远的两个白色节点的距离，这两个白色节点可以重合（此时距离为 $0$）。", "inputFormat": "第一行，输入一个正整数 $n\\ (n \\le {10}^5$)。\n\n接下来 $n-1$ 行，每行有 $3$ 个整数 $a,b,c$，代表节点 $a$ 和节点 $b$ 之间连一条边权为 $c\\ (|c|\\le{10}^3)$ 的边。\n\n接下来一行，一个正整数 $q\\ (q\\le 2\\times 10^5)$，表示操作的数量。\n\n接下来 $q$ 行，每行一次操作。", "outputFormat": "对于每次 `A` 操作，如果树上不存在白点，输出一行一个字符串 `They have disappeared.`，否则输出一行一个整数代表树上最远的两个白色节点的距离。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Qtree4", "background": "The Constraints here differ slightly from SPOJ.", "description": "You are given a tree with $n$ nodes, where each edge has a weight. Initially, all nodes are white. There are two types of operations:\n- `C x`: toggle the color of node $x$; white becomes black, and black becomes white.\n- `A`: query the distance between the farthest two white nodes in the tree. These two white nodes may coincide (in which case the distance is $0$).", "inputFormat": "The first line contains a positive integer $n$ ($n \\le 10^5$).\n\nEach of the next $n-1$ lines contains three integers $a$, $b$, $c$, representing an edge between nodes $a$ and $b$ with weight $c$ ($|c| \\le 10^3$).\n\nThe next line contains a positive integer $q$ ($q \\le 2\\times 10^5$), the number of operations.\n\nEach of the next $q$ lines contains one operation.", "outputFormat": "For each `A` operation, if there are no white nodes in the tree, output a line with the string `They have disappeared.`. Otherwise, output a line with one integer, the distance between the farthest two white nodes in the tree.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Qtree4", "background": "数据范围和 SPOJ 略有不同。", "description": "给出一棵边带权的节点数量为 $n$ 的树，初始树上所有节点都是白色。有两种操作：\n\n- `C x`，改变节点 $x$ 的颜色，即白变黑，黑变白。\n\n- `A`，询问树中最远的两个白色节点的距离，这两个白色节点可以重合（此时距离为 $0$）。", "inputFormat": "第一行，输入一个正整数 $n\\ (n \\le {10}^5$)。\n\n接下来 $n-1$ 行，每行有 $3$ 个整数 $a,b,c$，代表节点 $a$ 和节点 $b$ 之间连一条边权为 $c\\ (|c|\\le{10}^3)$ 的边。\n\n接下来一行，一个正整数 $q\\ (q\\le 2\\times 10^5)$，表示操作的数量。\n\n接下来 $q$ 行，每行一次操作。", "outputFormat": "对于每次 `A` 操作，如果树上不存在白点，输出一行一个字符串 `They have disappeared.`，否则输出一行一个整数代表树上最远的两个白色节点的距离。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4116", "type": "P", "difficulty": 5, "samples": [["9 8\n1 2\n1 3\n2 4\n2 9\n5 9\n7 9\n8 9\n6 8\n1 3\n0 8\n1 6\n1 7\n0 2\n1 9\n0 2\n1 9 ", "-1\n8\n-1\n2\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "树状数组", "O2优化", "枚举", "树链剖分", "动态树 LCT", "分块"], "title": "Qtree3", "background": "", "description": "给出 $N$ 个点的一棵树（$N-1$ 条边），节点有白有黑，初始全为白。\n\n有两种操作：\n\n`0 i`：改变某点的颜色（原来是黑的变白，原来是白的变黑）。\n\n`1 v`：询问 $1$ 到 $v$ 的路径上的第一个黑点，若无，输出 $-1$。", "inputFormat": "第一行 $N$，$Q$，表示 $N$ 个点和 $Q$ 个操作。\n\n第二行到第 $N$ 行 $N-1$ 条无向边。\n\n再之后 $Q$ 行，每行一个操作 `0 i` 或者 `1 v`。", "outputFormat": "对每个 `1 v` 操作输出结果\n", "hint": "对于 $1/3$ 的数据有 $N=5000,Q=400000$。\n\n对于 $1/3$ 的数据有 $N=10000,Q=300000$。\n\n对于 $1/3$ 的数据有 $N=100000, Q=100000$。\n\n此外，有$1 \\le i,v \\le N$。", "locale": "zh-CN", "translations": {"en": {"title": "Qtree3", "background": "", "description": "Given a tree with $N$ nodes ($N-1$ edges). Each node is either white or black, and initially all nodes are white.\n\nThere are two operations:\n\n`0 i`: Toggle the color of a node (black becomes white, white becomes black).\n\n`1 v`: Query the first black node on the path from $1$ to $v$; if none, output -1.", "inputFormat": "The first line contains $N$ and $Q$, the number of nodes and the number of operations.\n\nLines $2$ through $N$ contain the $N-1$ undirected edges.\n\nThen $Q$ lines follow, each containing one operation `0 i` or `1 v`.", "outputFormat": "For each `1 v` operation, output the result.", "hint": "For $1/3$ of the testdata, $N=5000,Q=400000$.\n\nFor $1/3$ of the testdata, $N=10000,Q=300000$.\n\nFor $1/3$ of the testdata, $N=100000, Q=100000$.\n\nIn addition, $1 \\le i,v \\le N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Qtree3", "background": "", "description": "给出 $N$ 个点的一棵树（$N-1$ 条边），节点有白有黑，初始全为白。\n\n有两种操作：\n\n`0 i`：改变某点的颜色（原来是黑的变白，原来是白的变黑）。\n\n`1 v`：询问 $1$ 到 $v$ 的路径上的第一个黑点，若无，输出 $-1$。", "inputFormat": "第一行 $N$，$Q$，表示 $N$ 个点和 $Q$ 个操作。\n\n第二行到第 $N$ 行 $N-1$ 条无向边。\n\n再之后 $Q$ 行，每行一个操作 `0 i` 或者 `1 v`。", "outputFormat": "对每个 `1 v` 操作输出结果\n", "hint": "对于 $1/3$ 的数据有 $N=5000,Q=400000$。\n\n对于 $1/3$ 的数据有 $N=10000,Q=300000$。\n\n对于 $1/3$ 的数据有 $N=100000, Q=100000$。\n\n此外，有$1 \\le i,v \\le N$。", "locale": "zh-CN"}}}
{"pid": "P4117", "type": "P", "difficulty": 7, "samples": [["5 6\n1 5 5 5 8\n2 2 5 5\n1 2 4 3\n2 2 5 2\n2 2 5 5\n1 3 5 1\n2 1 5 1", "3\n3\n0\n3"]], "limits": {"time": [7500, 7500, 7500, 7500, 7500, 7500, 7500, 7500, 7500, 7500, 7500, 7500, 7500, 7500, 7500], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2018", "并查集", "O2优化", "分块", "Ynoi"], "title": "[Ynoi2018] 五彩斑斓的世界", "background": "……羽毛\n\n从天而降的羽毛\n\n如雪一般的纯白，\n\n在海风中摇曳，\n\n在凉风中舞动，\n\n仿佛要将谁的心带走一样——神仙的羽毛。\n\n……\n\n“求求你”\n\n谁这样说到\n\n“求求你了”\n\n“救救我们”\n\n……梦\n\n我知道的，这是一场梦\n\n随即，那个人又说话了，在我这纯白的梦里\n\n“我们会一直在这里等着的……”\n\n于是，我踏上了漫长的旅途\n\n我有着非去不可的地方\n\n为了实现那个人的愿望\n\n所以我想，如果……\n\n如果，我的愿望能够实现的话。\n\n那样的话，或许，我和你……\n \n![](https://cdn.luogu.com.cn/upload/pic/13166.png) \n\n……世界终结了\n\n已经终结了\n\n我没赶上，不管什么，所有的事情……\n\n……可憎\n\n不可原谅\n\n我……\n\n……我、绝对、不会原谅你\n\n现在、就出发……\n\n我一定……一定要，把你……！\n\n![](https://cdn.luogu.com.cn/upload/pic/13167.png) \n\n手……牵着手，就能连着心\n\n……我的左手，没有牵着任何人的，我的手\n\n ![](https://cdn.luogu.com.cn/upload/image_hosting/of3qws6f.png)\n\n实现愿望。\n\n只留下这个事实，然后我们两人就会分别。\n\n就是希望着这一点，我们才会两个人一起走到今天。\n\n是这样吧？\n\n![](https://cdn.luogu.com.cn/upload/pic/13168.png) \n\n来，出发吧，去选择那独一无二的明天\n\n![](https://cdn.luogu.com.cn/upload/pic/13169.png)\n", "description": "二阶堂真红给了你一个长为 $n$ 的序列 $a$，有 $m$ 次操作\n\n1. 把区间 $[l,r]$ 中大于 $x$ 的数减去 $x$。\n2. 查询区间 $[l,r]$ 中 $x$ 的出现次数。\n", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数表示序列 $a$。\n\n接下来 $m$ 行，每行四个整数：\n\n- `1 l r x`：把区间 $[l,r]$ 所有大于 $x$ 的数减去 $x$。\n- `2 l r x`：查询区间 $[l,r]$ 内的 $x$ 的出现次数。\n", "outputFormat": "对于每个询问，输出一个整数表示答案。\n", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477\n\n对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$1\\le m\\le 5\\times 10^5$，$1\\le l\\le r \\le n$，$0 \\le a_i,x \\le 10^5+1$。\n\nBy nzhtl1477\n", "locale": "zh-CN", "translations": {"en": {"title": "[Ynoi2018] The Colorful World", "background": "...Feathers.\n\nFeathers falling from the sky.\n\nPure white, like snow,\n\nswaying in the sea breeze,\n\ndancing in the cool wind,\n\nas if trying to carry away someone's heart—divine feathers.\n\n...\n\n\"Please.\"\n\nWho said that?\n\n\"Please.\"\n\n\"Save us.\"\n\n...A dream.\n\nI know this is a dream.\n\nThen, that person spoke again, in my pure white dream:\n\n\"We will always be waiting here...\"\n\nSo, I set off on a long journey.\n\nThere is a place I must go.\n\nTo fulfill that person's wish.\n\nSo I think, if...\n\nif my wish could come true,\n\nthen maybe, you and I...\n\n![](https://cdn.luogu.com.cn/upload/pic/13166.png)\n\n...The world has ended.\n\nIt has already ended.\n\nI was too late—no matter what, everything...\n\n...Hateful.\n\nUnforgivable.\n\nI...\n\n...I will absolutely never forgive you.\n\nNow, set out...\n\nI will... I will definitely... take you...!\n\n![](https://cdn.luogu.com.cn/upload/pic/13167.png)\n\nHand... hand in hand, and hearts can be connected.\n\n...My left hand is not holding anyone. It is my hand.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/of3qws6f.png)\n\nGrant the wish.\n\nOnly this fact will remain, and then the two of us will part.\n\nIt was in hope of this that the two of us walked together until today.\n\nIs that so?\n\n![](https://cdn.luogu.com.cn/upload/pic/13168.png)\n\nCome, let's set out, to choose that one-and-only tomorrow.\n\n![](https://cdn.luogu.com.cn/upload/pic/13169.png)", "description": "Erjiedang Zhenhong gives you a sequence $a$ of length $n$, with $m$ operations.\n\n1. For every number greater than $x$ in the interval $[l,r]$, subtract $x$ from it.\n2. Query the number of occurrences of $x$ in the interval $[l,r]$.", "inputFormat": "The first line contains two integers $n$ and $m$.\n\nThe second line contains $n$ integers representing the sequence $a$.\n\nThen follow $m$ lines, each containing four integers:\n\n- `1 l r x`: For all numbers greater than $x$ in $[l,r]$, subtract $x$.\n- `2 l r x`: Query the number of occurrences of $x$ in $[l,r]`.", "outputFormat": "For each type-2 query, output one integer representing the answer.", "hint": "Idea: nzhtl1477, Solution: nzhtl1477, Code: nzhtl1477, Data: nzhtl1477.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^6$, $1 \\le m \\le 5 \\times 10^5$, $1 \\le l \\le r \\le n$, $0 \\le a_i, x \\le 10^5 + 1$.\n\nBy nzhtl1477.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Ynoi2018] 五彩斑斓的世界", "background": "……羽毛\n\n从天而降的羽毛\n\n如雪一般的纯白，\n\n在海风中摇曳，\n\n在凉风中舞动，\n\n仿佛要将谁的心带走一样——神仙的羽毛。\n\n……\n\n“求求你”\n\n谁这样说到\n\n“求求你了”\n\n“救救我们”\n\n……梦\n\n我知道的，这是一场梦\n\n随即，那个人又说话了，在我这纯白的梦里\n\n“我们会一直在这里等着的……”\n\n于是，我踏上了漫长的旅途\n\n我有着非去不可的地方\n\n为了实现那个人的愿望\n\n所以我想，如果……\n\n如果，我的愿望能够实现的话。\n\n那样的话，或许，我和你……\n \n![](https://cdn.luogu.com.cn/upload/pic/13166.png) \n\n……世界终结了\n\n已经终结了\n\n我没赶上，不管什么，所有的事情……\n\n……可憎\n\n不可原谅\n\n我……\n\n……我、绝对、不会原谅你\n\n现在、就出发……\n\n我一定……一定要，把你……！\n\n![](https://cdn.luogu.com.cn/upload/pic/13167.png) \n\n手……牵着手，就能连着心\n\n……我的左手，没有牵着任何人的，我的手\n\n ![](https://cdn.luogu.com.cn/upload/image_hosting/of3qws6f.png)\n\n实现愿望。\n\n只留下这个事实，然后我们两人就会分别。\n\n就是希望着这一点，我们才会两个人一起走到今天。\n\n是这样吧？\n\n![](https://cdn.luogu.com.cn/upload/pic/13168.png) \n\n来，出发吧，去选择那独一无二的明天\n\n![](https://cdn.luogu.com.cn/upload/pic/13169.png)\n", "description": "二阶堂真红给了你一个长为 $n$ 的序列 $a$，有 $m$ 次操作\n\n1. 把区间 $[l,r]$ 中大于 $x$ 的数减去 $x$。\n2. 查询区间 $[l,r]$ 中 $x$ 的出现次数。\n", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数表示序列 $a$。\n\n接下来 $m$ 行，每行四个整数：\n\n- `1 l r x`：把区间 $[l,r]$ 所有大于 $x$ 的数减去 $x$。\n- `2 l r x`：查询区间 $[l,r]$ 内的 $x$ 的出现次数。\n", "outputFormat": "对于每个询问，输出一个整数表示答案。\n", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477\n\n对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$1\\le m\\le 5\\times 10^5$，$1\\le l\\le r \\le n$，$0 \\le a_i,x \\le 10^5+1$。\n\nBy nzhtl1477\n", "locale": "zh-CN"}}}
{"pid": "P4118", "type": "P", "difficulty": 7, "samples": [["5 5\n-2 -3 -3 -3 -3\n2 1 5\n1 2 4 4\n2 1 5\n1 2 3 1\n2 3 3", "0\n3\n2"], ["5 5\n-2 3 3 -3 3\n2 1 5\n1 2 4 -4\n2 1 5\n1 2 3 1\n2 3 3", "6\n3\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2018", "O2优化", "分块", "Ynoi"], "title": "[Ynoi2018] 末日时在做什么？有没有空？可以来拯救吗？", "background": "今天真是多谢你了\n\n让我体验了许多美好\n\n我留下了如同美梦一般的回忆 不过时间到了\n\n最后我还想拜托你一件事\n\n希望你可以把我忘掉\n\n ![](https://cdn.luogu.com.cn/upload/pic/13170.png) \n\n在自己消失之前\n\n心怀不想消失的愿望\n\n希望让某个人记住我\n\n希望能留下羁绊\n\n我这么希望着，又有什么不可以的吗\n\n ![](https://cdn.luogu.com.cn/upload/pic/13171.png) \n\n香香甜甜的，真好闻\n\n看起来很好吃\n\n ![](https://cdn.luogu.com.cn/upload/pic/13173.png) \n\n我遵守了...\n\n约...约定\n\n我非常...非常努力哦...\n\n ![](https://cdn.luogu.com.cn/upload/pic/13172.png) \n\n欢迎回来，珂朵莉\n", "description": "珂朵莉给了你一个长为 $n$ 的序列 $a$，有 $m$ 次操作。\n\n1. 把区间 $[l,r]$ 内所有数都加上 $x$。\n2. 查询区间 $[l,r]$ 内的最大子段和，可以不选数。\n", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数表示序列 $a$。\n\n后面 $m$ 行：\n\n- `1 l r x`：把区间 $[l,r]$ 内所有数加上 $x$。\n- `2 l r`：查询区间 $[l,r]$ 的最大子段和。\n", "outputFormat": "对于每个询问，输出一个数表示答案。\n", "hint": "Idea：nzhtl1477，Solution：ccz181078，Code：nzhtl1477&ccz181078&mrsrz，Data：nzhtl1477&mrsrz&w33z8kqrqk8zzzx33\n\n$1 \\le n , m \\le 10^5$，$| a_i | \\leq 10^9$，$|x|\\leq 10^9$。\n\n**保证任意时刻 $|a_i|\\leq 2\\times 10^9$。**\n\nBy nzhtl1477 & ccz181078\n", "locale": "zh-CN", "translations": {"en": {"title": "[Ynoi2018] What Are You Doing at the End of the World? Are You Busy? Will You Save Us?", "background": "Thank you so much for today.\nYou let me experience so many wonderful things.\nI have left behind memories like a beautiful dream, but time is up.\nOne last favor.\nI hope you can forget me.\n\n ![](https://cdn.luogu.com.cn/upload/pic/13170.png) \n\nBefore I disappear,\nI hold a wish not to disappear.\nI hope someone will remember me.\nI hope to leave a bond.\nIf I wish for that, is there anything wrong?\n\n ![](https://cdn.luogu.com.cn/upload/pic/13171.png) \n\nSweet and fragrant, it smells so nice.\nIt looks delicious.\n\n ![](https://cdn.luogu.com.cn/upload/pic/13173.png) \n\nI kept...\nour... our promise.\nI really... really tried hard...\n\n ![](https://cdn.luogu.com.cn/upload/pic/13172.png) \n\nWelcome back, Chtholly.", "description": "Chtholly gives you a sequence $a$ of length $n$, and there are $m$ operations.\n\n1. Add $x$ to all numbers in the interval $[l, r]$.\n2. Query the maximum subarray sum in the interval $[l, r]$, where choosing no elements is allowed.", "inputFormat": "The first line contains two integers $n, m$.\nThe second line contains $n$ integers representing the sequence $a$.\nThe following $m$ lines:\n- `1 l r x`: add $x$ to all numbers in the interval $[l, r]$.\n- `2 l r`: query the maximum subarray sum in the interval $[l, r]$, with the empty subarray allowed.", "outputFormat": "For each query, output one number representing the answer.", "hint": "Idea: nzhtl1477, Solution: ccz181078, Code: nzhtl1477 & ccz181078 & mrsrz, Data: nzhtl1477 & mrsrz & w33z8kqrqk8zzzx33.\n\n$1 \\le n , m \\le 10^5$, $| a_i | \\leq 10^9$, $|x|\\leq 10^9$.\n\n**It is guaranteed that at any time $|a_i|\\leq 2\\times 10^9$.**\n\nBy nzhtl1477 & ccz181078.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Ynoi2018] 末日时在做什么？有没有空？可以来拯救吗？", "background": "今天真是多谢你了\n\n让我体验了许多美好\n\n我留下了如同美梦一般的回忆 不过时间到了\n\n最后我还想拜托你一件事\n\n希望你可以把我忘掉\n\n ![](https://cdn.luogu.com.cn/upload/pic/13170.png) \n\n在自己消失之前\n\n心怀不想消失的愿望\n\n希望让某个人记住我\n\n希望能留下羁绊\n\n我这么希望着，又有什么不可以的吗\n\n ![](https://cdn.luogu.com.cn/upload/pic/13171.png) \n\n香香甜甜的，真好闻\n\n看起来很好吃\n\n ![](https://cdn.luogu.com.cn/upload/pic/13173.png) \n\n我遵守了...\n\n约...约定\n\n我非常...非常努力哦...\n\n ![](https://cdn.luogu.com.cn/upload/pic/13172.png) \n\n欢迎回来，珂朵莉\n", "description": "珂朵莉给了你一个长为 $n$ 的序列 $a$，有 $m$ 次操作。\n\n1. 把区间 $[l,r]$ 内所有数都加上 $x$。\n2. 查询区间 $[l,r]$ 内的最大子段和，可以不选数。\n", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数表示序列 $a$。\n\n后面 $m$ 行：\n\n- `1 l r x`：把区间 $[l,r]$ 内所有数加上 $x$。\n- `2 l r`：查询区间 $[l,r]$ 的最大子段和。\n", "outputFormat": "对于每个询问，输出一个数表示答案。\n", "hint": "Idea：nzhtl1477，Solution：ccz181078，Code：nzhtl1477&ccz181078&mrsrz，Data：nzhtl1477&mrsrz&w33z8kqrqk8zzzx33\n\n$1 \\le n , m \\le 10^5$，$| a_i | \\leq 10^9$，$|x|\\leq 10^9$。\n\n**保证任意时刻 $|a_i|\\leq 2\\times 10^9$。**\n\nBy nzhtl1477 & ccz181078\n", "locale": "zh-CN"}}}
{"pid": "P4119", "type": "P", "difficulty": 7, "samples": [["3 3\n2 3 3\n2 1 3 1\n1 1 3 3 1\n2 1 3 2", "2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "并查集", "O2优化", "分块", "Ynoi"], "title": "[Ynoi2018] 未来日记", "background": "所以说，小雪的未来是由乃的~\n\n ![](https://cdn.luogu.com.cn/upload/pic/13174.png) \n\n嗯...我知道你的未来会怎样\n\n听好吧，我妻由乃\n\n ![](https://cdn.luogu.com.cn/upload/pic/13175.png) \n\n因为小雪改变了未来，所以他们三人才能在一起...\n\n为什么...\n\n这样我简直就是坏人...\n\n ![](https://cdn.luogu.com.cn/upload/pic/13176.png) \n\n我不会刺的\n\n因为...这就是未来啊\n\n这里...就是我的家\n\n![](https://cdn.luogu.com.cn/upload/pic/13177.png)\n", "description": "我妻由乃给了你一个长为 $n$ 的序列 $a$，有 $m$ 次操作。\n\n1. 把区间 $[l,r]$ 内所有的 $x$ 变成 $y$。\n2. 查询区间 $[l,r]$ 内第 $k$ 小值。\n", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数表示序列 $a$。\n\n后面 $m$ 行：\n\n`1 l r x y` : 把区间 $[l,r]$ 中所有 $x$ 变成 $y$。\n\n`2 l r k` : 查询区间 $[l,r]$ 中的 $k$ 小值。\n", "outputFormat": "对于每个询问，输出一个整数表示答案。\n", "hint": "Idea：f321dd，Solution：f321dd&nzhtl1477，Code：nzhtl1477&Claris，Data：nzhtl1477&Juan_feng\n\n$1\\le n,m,a_i \\le 10^5$。\n\nBy f321dd & nzhtl1477 & Claris\n", "locale": "zh-CN", "translations": {"en": {"title": "[Ynoi2018] Future Diary", "background": "So, Xiaoxue’s (pinyin) future belongs to Yuno’s~\n\n![](https://cdn.luogu.com.cn/upload/pic/13174.png)\n\nHmm... I know what your future will be like.\n\nListen up, I am Yuno Gasai.\n\n![](https://cdn.luogu.com.cn/upload/pic/13175.png)\n\nBecause Xiaoxue changed the future, the three of them could be together...\n\nWhy...\n\nThat makes me the bad guy...\n\n![](https://cdn.luogu.com.cn/upload/pic/13176.png)\n\nI won’t stab.\n\nBecause... this is the future.\n\nThis... is my home.\n\n![](https://cdn.luogu.com.cn/upload/pic/13177.png)", "description": "Yuno Gasai gave you a sequence $a$ of length $n$, with $m$ operations.\n\n1. Replace all occurrences of $x$ with $y$ within the interval $[l, r]$.\n2. Query the $k$-th smallest value within the interval $[l, r]$.", "inputFormat": "The first line contains two integers $n$ and $m$.\n\nThe second line contains $n$ integers representing the sequence $a$.\n\nThe next $m$ lines:\n\n`1 l r x y`: Replace all $x$ in $[l, r]$ with $y$.\n\n`2 l r k`: Query the $k$-th smallest value in $[l, r]$.", "outputFormat": "For each query, output one integer as the answer.", "hint": "Idea: f321dd, Solution: f321dd & nzhtl1477, Code: nzhtl1477 & Claris, testdata: nzhtl1477 & Juan_feng.\n\nConstraints: $1 \\le n, m, a_i \\le 10^5$.\n\nBy f321dd & nzhtl1477 & Claris.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Ynoi2018] 未来日记", "background": "所以说，小雪的未来是由乃的~\n\n ![](https://cdn.luogu.com.cn/upload/pic/13174.png) \n\n嗯...我知道你的未来会怎样\n\n听好吧，我妻由乃\n\n ![](https://cdn.luogu.com.cn/upload/pic/13175.png) \n\n因为小雪改变了未来，所以他们三人才能在一起...\n\n为什么...\n\n这样我简直就是坏人...\n\n ![](https://cdn.luogu.com.cn/upload/pic/13176.png) \n\n我不会刺的\n\n因为...这就是未来啊\n\n这里...就是我的家\n\n![](https://cdn.luogu.com.cn/upload/pic/13177.png)\n", "description": "我妻由乃给了你一个长为 $n$ 的序列 $a$，有 $m$ 次操作。\n\n1. 把区间 $[l,r]$ 内所有的 $x$ 变成 $y$。\n2. 查询区间 $[l,r]$ 内第 $k$ 小值。\n", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数表示序列 $a$。\n\n后面 $m$ 行：\n\n`1 l r x y` : 把区间 $[l,r]$ 中所有 $x$ 变成 $y$。\n\n`2 l r k` : 查询区间 $[l,r]$ 中的 $k$ 小值。\n", "outputFormat": "对于每个询问，输出一个整数表示答案。\n", "hint": "Idea：f321dd，Solution：f321dd&nzhtl1477，Code：nzhtl1477&Claris，Data：nzhtl1477&Juan_feng\n\n$1\\le n,m,a_i \\le 10^5$。\n\nBy f321dd & nzhtl1477 & Claris\n", "locale": "zh-CN"}}}
{"pid": "P4120", "type": "P", "difficulty": 7, "samples": [["mst 0\n4 5 2 3\n1 2 1\n1 3 1\n2 3 1\n2 4 2\n3 4 2", "5"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "生成树", "WC"], "title": "[WC2012] 最小生成树", "background": null, "description": "给定无向带权连通图$G$，我们希望通过修改边的权值，使它的最小生成树唯一，已知减小，增加一条边的权值的单位代价分别为 $a$ 和 $b$，且修改后的权值必须为非负整数。\n\n例如，对某个图 $G$，如果将一条边的权值减 $3$，另一条边的权值加 $2$ 之后，它的最小生成树唯一，则此时的代价之和是 $3a+2b$。试计算代价之和的最小值。", "inputFormat": "从文件mst.in中读入数据。\n\n第一行包含字符串“$mst$” 和数据编号。\n\n第二行包含 $4$ 个正整数 $n$,$m$,$a$,$b$，分别表示图 $G$ 顶点的个数，边的条数，以及对一条边的权值减小 $1$，增加 $1$ 的代价。\n\n接下来 $m$ 行，每行 $3$ 个正整数 $x$,$y$,$w$，表示顶点 $x$ 和顶点 $y$ 之间有一条初始权值为 $w$ 的边。\n\n顶点由 $1$ 至 $n$ 编号。", "outputFormat": "输出到文件mst.out中。\n\n输出文件仅一行，包含一个整数，表示最小代价，无需修改则输出 $0$。", "hint": "【样例说明】\n\n将边$(2,4)$的权值减 $1$，边$(2,3)$的权值加 $1$ 之后，图 $G$ 的最小生成树唯一，且此时的代价之和为最小值。\n\n【数据范围】\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b10vkiev.png)\n[测试点$6$~$10$下载](https://pan.baidu.com/s/1bqiS6w3)", "locale": "zh-CN", "translations": {"en": {"title": "[WC2012] Minimum Spanning Tree", "background": "", "description": "Given an undirected, weighted, connected graph $G$, we want to modify edge weights so that its minimum spanning tree is unique. The unit costs to decrease and increase the weight of an edge by 1 are $a$ and $b$, respectively, and the modified weights must be non-negative integers.\n\nFor example, for some graph $G$, if after decreasing the weight of one edge by $3$ and increasing the weight of another edge by $2$ the minimum spanning tree becomes unique, then the total cost is $3a+2b$. Compute the minimal total cost.", "inputFormat": "Read from standard input.\n\nThe first line contains the string “$mst$” and a testdata ID.\n\nThe second line contains 4 positive integers $n$, $m$, $a$, $b$, denoting the number of vertices of $G$, the number of edges, and the unit costs to decrease an edge weight by $1$ and to increase it by $1$, respectively.\n\nEach of the next $m$ lines contains 3 positive integers $x$, $y$, $w$, indicating that there is an edge between vertices $x$ and $y$ with initial weight $w$.\n\nVertices are numbered from $1$ to $n$.", "outputFormat": "Write to standard output.\n\nOutput a single line containing one integer, the minimal total cost. If no modification is needed, output $0$.", "hint": "[Sample explanation]\n\nAfter decreasing the weight of edge $(2,4)$ by $1$ and increasing the weight of edge $(2,3)$ by $1$, the minimum spanning tree of graph $G$ becomes unique, and the total cost is minimal.\n\n[Constraints]\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b10vkiev.png)\n[Test points $6$~$10$ download](https://pan.baidu.com/s/1bqiS6w3)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2012] 最小生成树", "background": null, "description": "给定无向带权连通图$G$，我们希望通过修改边的权值，使它的最小生成树唯一，已知减小，增加一条边的权值的单位代价分别为 $a$ 和 $b$，且修改后的权值必须为非负整数。\n\n例如，对某个图 $G$，如果将一条边的权值减 $3$，另一条边的权值加 $2$ 之后，它的最小生成树唯一，则此时的代价之和是 $3a+2b$。试计算代价之和的最小值。", "inputFormat": "从文件mst.in中读入数据。\n\n第一行包含字符串“$mst$” 和数据编号。\n\n第二行包含 $4$ 个正整数 $n$,$m$,$a$,$b$，分别表示图 $G$ 顶点的个数，边的条数，以及对一条边的权值减小 $1$，增加 $1$ 的代价。\n\n接下来 $m$ 行，每行 $3$ 个正整数 $x$,$y$,$w$，表示顶点 $x$ 和顶点 $y$ 之间有一条初始权值为 $w$ 的边。\n\n顶点由 $1$ 至 $n$ 编号。", "outputFormat": "输出到文件mst.out中。\n\n输出文件仅一行，包含一个整数，表示最小代价，无需修改则输出 $0$。", "hint": "【样例说明】\n\n将边$(2,4)$的权值减 $1$，边$(2,3)$的权值加 $1$ 之后，图 $G$ 的最小生成树唯一，且此时的代价之和为最小值。\n\n【数据范围】\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b10vkiev.png)\n[测试点$6$~$10$下载](https://pan.baidu.com/s/1bqiS6w3)", "locale": "zh-CN"}}}
{"pid": "P4121", "type": "P", "difficulty": 6, "samples": [["5\n0 1 0 0 0\n0 1 1 1 0\n1 0 0 0 1\n0 0 1 0 0\n1 0 0 0 0\n2\n3 2\n2 3", "4 3\n5 2"]], "limits": {"time": [700, 700, 700, 700, 700, 700, 700, 700, 700, 700], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "线段树", "并查集", "生成树", "动态树 LCT", "WC"], "title": "[WC2005] 双面棋盘", "background": "", "description": "佳佳有一个 $n$ 行 $n$ 列的黑白棋盘，每个格子都有两面，一面白色，一面黑色。佳佳把棋盘平放在桌子上，因此每个格子恰好一面朝上，如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rcejbuct.png)\n\n我们把每行从上到下编号为 $1$，$2$，$3$，……，$n$，各列从左到右编号为 $1$，$2$，$3$，……，$n$，则每个格子可以用棋盘坐标$(x, y)$表示。在上图中，有 $8$ 个格子黑色朝上，另外 $17$ 个格子白色朝上。\n\n如果两个同色格子有一条公共边，我们称这两个同色格子属于同一个连通块。上图共有 $5$ 个黑色连通块和 $3$ 个白色连通块。\n\n佳佳可以每分钟将一个格子翻转（即白色变成黑色，黑色变成白色），然后计算当前有多少个黑色连通块和白色连通块，你能算得更快吗？\n", "inputFormat": "输入文件的第一行包含一个正整数 $n$，为格子的边长。以下 $n$ 行每行 $n$ 个整数，非 $0$ 即 $1$，表示初始状态。$0$ 表示白色，$1$ 表示黑色。  \n\n下一行包含一个整数 $m$，表示操作的数目。以下 $m$ 行每行两个整数 $x$, $y$ ( $1 \\le x,y \\le n$ )，表示把坐标为 $(x, y)$ 的格子翻转。\n", "outputFormat": "输出文件包含 $m$ 行，每行对应一个操作。该行包括两个整数 $b$, $w$，表示黑色区域和白色区域数目。\n", "hint": "【样例说明】\n\n翻转 $(3, 2)$ 之后，棋盘变为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9oqt0zsv.png)\n\n有 $4$ 个黑色区域和 $3$ 个白色区域\n\n翻转 $(2, 3)$ 之后，棋盘变为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f335hulm.png)\n\n有 $5$ 个黑色区域和 $2$ 个白色区域\n\n【数据范围】   \n对于 $100\\%$ 的数据，$1\\le n \\le 200$，$1\\le m \\le 10^4$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[WC2005] Double-faced Board", "background": "", "description": "Jiajia has an $n \\times n$ black-and-white board. Each cell has two faces: one white and one black. Jiajia lays the board flat on the table, so exactly one face of each cell is up, as shown in the figure below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rcejbuct.png)\n\nWe number the rows from top to bottom as $1, 2, 3, \\ldots, n$, and the columns from left to right as $1, 2, 3, \\ldots, n$. Thus, each cell can be represented by board coordinates $(x, y)$. In the figure above, there are $8$ cells with the black side up, and the other $17$ cells have the white side up.\n\nIf two cells of the same color share a common edge, we say these two same-colored cells belong to the same connected component. In the figure above, there are $5$ black connected components and $3$ white connected components.\n\nJiajia can flip one cell per minute (i.e., white becomes black, and black becomes white), then count how many black connected components and white connected components there are. Can you compute it faster?", "inputFormat": "The first line contains a positive integer $n$, the side length of the board.  \nEach of the next $n$ lines contains $n$ integers, each either $0$ or $1$, representing the initial state. $0$ means white, and $1$ means black.\n\nThe next line contains an integer $m$, the number of operations.  \nEach of the next $m$ lines contains two integers $x$, $y$ ($1 \\le x, y \\le n$), indicating to flip the cell at coordinates $(x, y)$.", "outputFormat": "Output contains $m$ lines, one for each operation. Each line contains two integers $b$, $w$, denoting the numbers of black connected components and white connected components.", "hint": "【Sample Explanation】\n\nAfter flipping $(3, 2)$, the board becomes:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9oqt0zsv.png)\n\nThere are $4$ black connected components and $3$ white connected components.\n\nAfter flipping $(2, 3)$, the board becomes:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f335hulm.png)\n\nThere are $5$ black connected components and $2$ white connected components.\n\n【Constraints】  \nFor $100\\%$ of the testdata, $1 \\le n \\le 200$, $1 \\le m \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2005] 双面棋盘", "background": "", "description": "佳佳有一个 $n$ 行 $n$ 列的黑白棋盘，每个格子都有两面，一面白色，一面黑色。佳佳把棋盘平放在桌子上，因此每个格子恰好一面朝上，如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rcejbuct.png)\n\n我们把每行从上到下编号为 $1$，$2$，$3$，……，$n$，各列从左到右编号为 $1$，$2$，$3$，……，$n$，则每个格子可以用棋盘坐标$(x, y)$表示。在上图中，有 $8$ 个格子黑色朝上，另外 $17$ 个格子白色朝上。\n\n如果两个同色格子有一条公共边，我们称这两个同色格子属于同一个连通块。上图共有 $5$ 个黑色连通块和 $3$ 个白色连通块。\n\n佳佳可以每分钟将一个格子翻转（即白色变成黑色，黑色变成白色），然后计算当前有多少个黑色连通块和白色连通块，你能算得更快吗？\n", "inputFormat": "输入文件的第一行包含一个正整数 $n$，为格子的边长。以下 $n$ 行每行 $n$ 个整数，非 $0$ 即 $1$，表示初始状态。$0$ 表示白色，$1$ 表示黑色。  \n\n下一行包含一个整数 $m$，表示操作的数目。以下 $m$ 行每行两个整数 $x$, $y$ ( $1 \\le x,y \\le n$ )，表示把坐标为 $(x, y)$ 的格子翻转。\n", "outputFormat": "输出文件包含 $m$ 行，每行对应一个操作。该行包括两个整数 $b$, $w$，表示黑色区域和白色区域数目。\n", "hint": "【样例说明】\n\n翻转 $(3, 2)$ 之后，棋盘变为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9oqt0zsv.png)\n\n有 $4$ 个黑色区域和 $3$ 个白色区域\n\n翻转 $(2, 3)$ 之后，棋盘变为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f335hulm.png)\n\n有 $5$ 个黑色区域和 $2$ 个白色区域\n\n【数据范围】   \n对于 $100\\%$ 的数据，$1\\le n \\le 200$，$1\\le m \\le 10^4$。\n", "locale": "zh-CN"}}}
{"pid": "P4122", "type": "P", "difficulty": 2, "samples": [["1 2 3 5\n6 0 10 4\n2 1 8 3", "17"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2017", "USACO", "离散化"], "title": "[USACO17DEC] Blocked Billboard B", "background": "", "description": "During long milking sessions, Bessie the cow likes to stare out the window of her barn at two huge rectangular billboards across the street advertising \"Farmer Alex's Amazingly Appetizing Alfalfa\" and \"Farmer Greg's Great Grain\". Pictures of these two cow feed products on the billboards look much tastier to Bessie than the grass from her farm.\n\nOne day, as Bessie is staring out the window, she is alarmed to see a huge rectangular truck parking across the street. The side of the truck has an advertisement for \"Farmer Smith's Superb Steaks\", which Bessie doesn't quite understand, but she is mostly concerned about the truck potentially blocking the view of her two favorite billboards.\n\nGiven the locations of the two billboards and the location of the truck, please calculate the total combined area of both billboards that is still visible. It is possible that the truck obscures neither, both, or only one of the billboards.\n", "inputFormat": "The first line of input contains four space-separated integers: $x_1,y_1,x_2 y_2$, where $(x_1,y_1)$ and $(x_2,y_2)$ are the coordinates of the lower-left and upper-right corners of the first billboard in Bessie's 2D field of view. The next line contains four more integers, similarly specifying the lower-left and upper-right corners of the second billboard. The third and final line of input contains four integers specifying the lower-left and upper-right corners of the truck. All coordinates are in the range $-1000$ to $+1000$. The two billboards are guaranteed not to have any positive area of overlap between themselves.", "outputFormat": "Please output the total combined area of both billboards that remains visible.", "hint": "Here, 5 units of area from the first billboard and 12 units of area from the second billboard remain visible.\n\nProblem credits: Brian Dean", "locale": "en", "translations": {"en": {"title": "[USACO17DEC] Blocked Billboard B", "background": "", "description": "During long milking sessions, Bessie the cow likes to stare out the window of her barn at two huge rectangular billboards across the street advertising \"Farmer Alex's Amazingly Appetizing Alfalfa\" and \"Farmer Greg's Great Grain\". Pictures of these two cow feed products on the billboards look much tastier to Bessie than the grass from her farm.\n\nOne day, as Bessie is staring out the window, she is alarmed to see a huge rectangular truck parking across the street. The side of the truck has an advertisement for \"Farmer Smith's Superb Steaks\", which Bessie doesn't quite understand, but she is mostly concerned about the truck potentially blocking the view of her two favorite billboards.\n\nGiven the locations of the two billboards and the location of the truck, please calculate the total combined area of both billboards that is still visible. It is possible that the truck obscures neither, both, or only one of the billboards.\n", "inputFormat": "The first line of input contains four space-separated integers: $x_1,y_1,x_2 y_2$, where $(x_1,y_1)$ and $(x_2,y_2)$ are the coordinates of the lower-left and upper-right corners of the first billboard in Bessie's 2D field of view. The next line contains four more integers, similarly specifying the lower-left and upper-right corners of the second billboard. The third and final line of input contains four integers specifying the lower-left and upper-right corners of the truck. All coordinates are in the range $-1000$ to $+1000$. The two billboards are guaranteed not to have any positive area of overlap between themselves.", "outputFormat": "Please output the total combined area of both billboards that remains visible.", "hint": "Here, 5 units of area from the first billboard and 12 units of area from the second billboard remain visible.\n\nProblem credits: Brian Dean", "locale": "en"}, "zh-CN": {"title": "[USACO17DEC] Blocked Billboard B", "background": null, "description": "在漫长的挤奶过程中，奶牛 Bessie 喜欢透过谷仓的窗户盯着街对面的两块巨大的矩形广告牌，上面分别写着“Farmer Alex 的美味苜蓿”和“Farmer Greg 的优质谷物”。广告牌上这两种奶牛饲料的图片对 Bessie 来说比她农场里的草看起来美味得多。\n\n有一天，当 Bessie 正盯着窗外时，她惊讶地看到一辆巨大的矩形卡车停在街对面。卡车的侧面有一则广告，写着“Farmer Smith 的顶级牛排”，Bessie 不太理解这则广告，但她更担心的是卡车可能会挡住她最喜欢的两块广告牌的视线。\n\n给定两块广告牌和卡车的位置，请计算两块广告牌仍然可见的总面积。卡车可能遮挡了其中一块、两块，或者没有遮挡任何一块广告牌。", "inputFormat": "输入的第一行包含四个用空格分隔的整数：$x_1,y_1,x_2,y_2$，其中 $(x_1,y_1)$ 和 $(x_2,y_2)$ 是 Bessie 的二维视野中第一块广告牌的左下角和右上角坐标。第二行包含四个整数，以相同的方式指定第二块广告牌的左下角和右上角坐标。第三行也是最后一行输入包含四个整数，指定卡车的左下角和右上角坐标。所有坐标都在 $-1000$ 到 $+1000$ 的范围内。保证两块广告牌之间没有任何重叠的正面积区域。", "outputFormat": "请输出两块广告牌仍然可见的总面积。", "hint": "在这个例子中，第一块广告牌有 $5$ 单位面积可见，第二块广告牌有 $12$ 单位面积可见。\n\n题目来源：Brian Dean", "locale": "zh-CN"}}}
{"pid": "P4123", "type": "P", "difficulty": 6, "samples": [["4 4\n1 2 3\n1 3 6\n2 4 5\n3 4 4", "3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2016", "重庆", "各省省选", "网络流", "分治", "最小割"], "title": "[CQOI2016] 不同的最小割", "background": "", "description": "学过图论的同学都知道最小割的概念：对于一个图，某个对图中结点的划分将图中所有结点分成两个部分，如果结点 $s,t$ 不在同一个部分中，则称这个划分是关于 $s,t$ 的割。对于带权图来说，将所有顶点处在不同部分的边的权值相加所得到的值定义为这个割的容量，而 $s,t$ 的最小割指的是在关于 $s,t$ 的割中容量最小的割。\n\n而对冲刺 NOI 竞赛的选手而言，求带权图中两点的最小割已经不是什么难事了。我们可以把视野放宽，考虑有 $N$ 个点的无向连通图中所有点对的最小割的容量，共能得到 $N(N-1)/2$ 个数值。这些数值中互不相同的有多少个呢？这似乎是个有趣的问题。", "inputFormat": "第一行包含两个数 $N,M$，表示点数和边数。\n\n接下来 $M$ 行，每行三个数 $u,v,w$，表示点 $u$ 和点 $v$ (从 $1$ 开始标号) 之间有一条权值是 $w$ 的边。", "outputFormat": "第一行为一个整数，表示不同的最小割容量的个数。", "hint": "$1\\leq N\\leq 850,1\\leq M\\leq 8500,1\\leq w\\leq 100000$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2016] Distinct Minimum Cuts", "background": "", "description": "Students who have studied graph theory all know the concept of the minimum cut: For a graph, a partition of the nodes divides all nodes into two parts. If nodes $s, t$ are not in the same part, then the partition is called a cut with respect to $s, t$. For a weighted graph, the capacity of a cut is defined as the sum of the weights of edges whose endpoints lie in different parts, and the $s, t$ minimum cut is the cut of minimum capacity among all cuts with respect to $s, t$.\n\nFor contestants preparing for the NOI, finding the minimum cut between two nodes in a weighted graph is no longer difficult. Let us broaden the view: In an undirected connected graph with $N$ nodes, consider the minimum cut capacity for every unordered pair of nodes. In total we obtain $\\,$ $N(N-1)/2$ $\\,$ values. How many of these values are distinct? This seems like an interesting problem.", "inputFormat": "The first line contains two integers $N, M$, the number of nodes and the number of edges.\n\nEach of the next $M$ lines contains three integers $u, v, w$, indicating there is an edge between node $u$ and node $v$ (indexed from $1$) with weight $w$.", "outputFormat": "Output a single integer on the first line, the number of distinct minimum cut capacities.", "hint": "Constraints: $1 \\leq N \\leq 850$, $1 \\leq M \\leq 8500$, $1 \\leq w \\leq 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2016] 不同的最小割", "background": "", "description": "学过图论的同学都知道最小割的概念：对于一个图，某个对图中结点的划分将图中所有结点分成两个部分，如果结点 $s,t$ 不在同一个部分中，则称这个划分是关于 $s,t$ 的割。对于带权图来说，将所有顶点处在不同部分的边的权值相加所得到的值定义为这个割的容量，而 $s,t$ 的最小割指的是在关于 $s,t$ 的割中容量最小的割。\n\n而对冲刺 NOI 竞赛的选手而言，求带权图中两点的最小割已经不是什么难事了。我们可以把视野放宽，考虑有 $N$ 个点的无向连通图中所有点对的最小割的容量，共能得到 $N(N-1)/2$ 个数值。这些数值中互不相同的有多少个呢？这似乎是个有趣的问题。", "inputFormat": "第一行包含两个数 $N,M$，表示点数和边数。\n\n接下来 $M$ 行，每行三个数 $u,v,w$，表示点 $u$ 和点 $v$ (从 $1$ 开始标号) 之间有一条权值是 $w$ 的边。", "outputFormat": "第一行为一个整数，表示不同的最小割容量的个数。", "hint": "$1\\leq N\\leq 850,1\\leq M\\leq 8500,1\\leq w\\leq 100000$。", "locale": "zh-CN"}}}
{"pid": "P4124", "type": "P", "difficulty": 5, "samples": [["12121284000 12121285550", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "2016", "重庆", "各省省选", "数位 DP"], "title": "[CQOI2016] 手机号码", "background": "", "description": "人们选择手机号码时都希望号码好记、吉利。比如号码中含有几位相邻的相同数字、不含谐音不吉利的数字等。手机运营商在发行新号码时也会考虑这些因素，从号段中选取含有某些特征的号码单独出售。为了便于前期规划，运营商希望开发一个工具来自动统计号段中满足特征的号码数量。\n\n工具需要检测的号码特征有两个：号码中要出现至少 $3$ 个相邻的相同数字；号码中不能同时出现 $8$ 和 $4$。号码必须同时包含两个特征才满足条件。满足条件的号码例如：13000988721、23333333333、14444101000。而不满足条件的号码例如：1015400080、10010012022。\n\n手机号码一定是 $11$ 位数，且不含前导的 $0$。工具接收两个数 $L$ 和 $R$，自动统计出 $[L,R]$ 区间内所有满足条件的号码数量。$L$ 和 $R$ 也是 $11$ 位的手机号码。", "inputFormat": "输入文件内容只有一行，为空格分隔的 $2$ 个正整数 $L,R$。", "outputFormat": "输出文件内容只有一行，为 $1$ 个整数，表示满足条件的手机号数量。", "hint": "样例解释：满足条件的号码： 12121285000、 12121285111、 12121285222、 12121285333、 12121285550。\n\n数据范围：$10^{10}\\leq L\\leq R<10^{11}$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2016] Mobile Phone Number", "background": "", "description": "People prefer mobile phone numbers that are easy to remember or considered lucky. For example, numbers that contain several adjacent identical digits, or numbers that avoid digits with inauspicious homophones. Mobile operators also consider these factors when issuing new numbers and may select numbers with certain features from a number range to sell separately. To aid planning, the operator wants a tool to automatically count how many numbers in a range satisfy certain features.\n\nThe tool checks two features: the number must contain at least $3$ consecutive identical digits; the number must not contain both $8$ and $4$ at the same time. A number is valid only if it satisfies both features. Examples that satisfy the conditions: 13000988721, 23333333333, 14444101000. Examples that do not satisfy the conditions: 1015400080, 10010012022.\n\nA mobile phone number has exactly $11$ digits and does not have a leading $0$. The tool receives two numbers $L$ and $R$ and automatically counts how many numbers in the interval $[L,R]$ satisfy the conditions. $L$ and $R$ are also $11$-digit mobile phone numbers.", "inputFormat": "The input contains a single line with $2$ positive integers $L,R$ separated by a space.", "outputFormat": "Output a single line with $1$ integer, the number of valid mobile phone numbers.", "hint": "Sample explanation: valid numbers are 12121285000, 12121285111, 12121285222, 12121285333, 12121285550.\n\nConstraints: $10^{10}\\leq L\\leq R<10^{11}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2016] 手机号码", "background": "", "description": "人们选择手机号码时都希望号码好记、吉利。比如号码中含有几位相邻的相同数字、不含谐音不吉利的数字等。手机运营商在发行新号码时也会考虑这些因素，从号段中选取含有某些特征的号码单独出售。为了便于前期规划，运营商希望开发一个工具来自动统计号段中满足特征的号码数量。\n\n工具需要检测的号码特征有两个：号码中要出现至少 $3$ 个相邻的相同数字；号码中不能同时出现 $8$ 和 $4$。号码必须同时包含两个特征才满足条件。满足条件的号码例如：13000988721、23333333333、14444101000。而不满足条件的号码例如：1015400080、10010012022。\n\n手机号码一定是 $11$ 位数，且不含前导的 $0$。工具接收两个数 $L$ 和 $R$，自动统计出 $[L,R]$ 区间内所有满足条件的号码数量。$L$ 和 $R$ 也是 $11$ 位的手机号码。", "inputFormat": "输入文件内容只有一行，为空格分隔的 $2$ 个正整数 $L,R$。", "outputFormat": "输出文件内容只有一行，为 $1$ 个整数，表示满足条件的手机号数量。", "hint": "样例解释：满足条件的号码： 12121285000、 12121285111、 12121285222、 12121285333、 12121285550。\n\n数据范围：$10^{10}\\leq L\\leq R<10^{11}$。", "locale": "zh-CN"}}}
{"pid": "P4125", "type": "P", "difficulty": 7, "samples": [["5 \n2 5 5 8 \n2 1 3 5 \n5 2 6 5 \n7 0 4 2 \n3 1 4 0 \n2 0 \n3 0 \n4 0 \n1 2 \n5 1 ", "3 \n2 0 \n3 0 \n4 3 \n1 2 \n5 1 "], ["4\n-1 1 2 3\n13 5 9 8\n10 10 15 14\n10 17 0 20\n3 1\n2 1\n1 1\n\n4 1", "2\n4 1\n3 1\n2 1\n1 1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2012", "线段树", "Special Judge", "拓扑排序", "WC"], "title": "[WC2012] 记忆中的水杉树", "background": "", "description": "江苏省常州高级中学是一所百年名校，这里萦绕着无数人难以忘怀的回忆。\n\nWill 记得，在他小的时候，常州高级中学改建以前，学校里有一片高大的水杉林，每到水杉落叶之时，针状的叶子会像毯子一样盖在地上，走在上面浪漫而又闲适。那时，Will 和同学们还喜欢用这些针叶，在水杉树下，玩“取叶子”的游戏。 \n\n游戏一开始，大家先将 $n$ 片针叶平铺在地上。接着，每一轮可以有一个同学选择一片针叶，按水平或者垂直方向将针叶移走（也就是平移到无穷远处）——当然，前提是移动过程中不被任何尚未移走的针叶所阻碍。如果某一轮针叶的移动会被阻碍，那么这次移动就是非法的，是不被允许的。\n\n$n$ 轮过后，当针叶都被移走时，游戏也就结束了。 针叶并不是任何时刻都可以被移动的。当针叶很多的时候，判断每一轮中一片针叶是否可以按一个特定的方向移动是一件很麻烦的事情。 现在我们将地面抽象为平面直角坐标系，$n$ 片针叶抽象为平面上 $n$ 条互不相交的线段，并将其从 $1$ 到 $n$ 编号，Will 还将给出每一轮游戏中，他想要移动的针叶编号以及移动方向，请你帮助他：\n\n1. 找出最早的一次非法移动出现在哪一轮；\n\n2. 给出一个合法的移动方案完成这个游戏。\n\n注意：在线段移动时仅端点接触不会造成阻碍，具体请参见样例。\n", "inputFormat": "输入文件的第一行包含一个正整数 $n$，表示针叶的数量。\n\n接下来 $n$ 行，每行 $4$ 个整数，描述针叶的位置信息。其中第 $i$ 行的整数为 $a_i$，$b_i$，$c_i$，$d_i$，表示编号为 $i$ 的针叶所抽象成的线段的端点为$(a_i, b_i)$和$(c_i, d_i)$。\n\n接下来 $n$ 行，每行 $2$ 个整数，描述移动操作。其中第 $i$ 行的整数为 $p_i$，$q_i$，表示第 $i$ 轮移动的针叶编号为 $p_i$，方向为 $q_i$。其中 $q_i$为一个 $0$ 到 $3$ 之间的整数，$0$ 表示向左平移（即 $x$ 轴负方向） ，$1$ 表示向上平移（即 $y$ 轴正方向） ，$2$ 表示向右平移，$3$ 表示向下平移。\n\n输入数据保证：\n\n- 所有线段长度为正，两两之间没有公共点，且不存在垂直或者水平的线段;\n- $p_1$ 到 $p_n$ 恰好组成一个 $1$ 到 $n$ 的排列；\n- Will 所给出的移动操作中一定存在非法移动；\n- $n$ 轮均合法的移动操作总是存在的。\n", "outputFormat": "输出文件一共包含 $n+1$ 行。\n\n输出的第一行包含一个 $1$ 到 $n$ 之间的整数，表示最早出现非法移动的是哪一轮。\n\n接下来 $n$ 行，每行两个整数，内容同输入格式所述，描述一个合法的移动序列。\n", "hint": "【样例说明】\n\n在 Will 给出的移动方案的第 $3$ 轮中，编号为 $4$ 的针叶向左移动会被编号为 $5$ 的针叶阻碍。\n\n【数据范围】\n\n具体数据范围见下表。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y7thkctp.png)\n\n对于一个测试点：\n\n如果非法移动判断正确，但是给出的方案错误，可以得到 $5$ 分。此时会提示：`An invalid move in step`\n\n如果非法移动判断错误，但是给出的方案正确，可以得到 $5$ 分。此时会提示：`Negative error detection!`\n\n如果非法移动的判断与给出方案均正确，则可以得到 $10$ 分；\n\n否则，得 $0$ 分。\n\n 如果程序的输出格式不正确，将被直接判作输出格式不正确，将被直接判作 $0$ 分。\n", "locale": "zh-CN", "translations": {"en": {"title": "[WC2012] Metasequoia in Memory", "background": "", "description": "Changzhou Senior High School of Jiangsu is a century-old prestigious school, filled with countless unforgettable memories.\n\nWill remembers that when he was little, before the school's reconstruction, there was a tall metasequoia grove. When the metasequoias shed their leaves, the needles would cover the ground like a blanket, making it romantic and leisurely to walk on. Back then, Will and his classmates liked to use these needles to play a “taking needles” game under the metasequoias.\n\nAt the start of the game, everyone lays $n$ needles flat on the ground. Then, in each round, one player may choose one needle and move it in the horizontal or vertical direction (that is, translate it to infinity) — provided that during the movement it is not blocked by any needle that has not yet been moved away. If a needle’s movement would be blocked in a round, then this move is illegal and not allowed.\n\nAfter $n$ rounds, when all needles have been removed, the game ends. Not every needle can be moved at any time. When there are many needles, determining in each round whether a specific needle can be moved in a given direction is troublesome. Now we abstract the ground as a 2D Cartesian plane, the $n$ needles as $n$ pairwise disjoint line segments in the plane, labeled from $1$ to $n$. Will also provides, for each round, the index of the needle he wants to move and the direction. Please help him:\n\n1. Find in which round the earliest illegal move occurs.\n2. Provide a legal move sequence that completes the game.\n\nNote: When moving segments, merely touching at endpoints does not cause obstruction. See the sample for details.", "inputFormat": "The first line contains a positive integer $n$, the number of needles.\n\nThe next $n$ lines each contain $4$ integers describing the positions of the needles. On the $i$-th of these lines, the integers $a_i$, $b_i$, $c_i$, $d_i$ indicate that the endpoints of the line segment abstracting needle $i$ are $(a_i, b_i)$ and $(c_i, d_i)$.\n\nThe next $n$ lines each contain $2$ integers describing the moves. On the $i$-th of these lines, the integers $p_i$, $q_i$ indicate that in round $i$, the needle to move is $p_i$, and the direction is $q_i$. Here $q_i$ is an integer between $0$ and $3$: $0$ means move left (the negative $x$-axis direction), $1$ means move up (the positive $y$-axis direction), $2$ means move right, and $3$ means move down.\n\nThe input is guaranteed that:\n\n- All segments have positive length, no two segments share a point, and there are no vertical or horizontal segments.\n- $p_1$ through $p_n$ form a permutation of $1$ through $n$.\n- There is at least one illegal move in Will’s given sequence.\n- There always exists a sequence of $n$ legal moves that completes the game.", "outputFormat": "The output contains $n+1$ lines.\n\nThe first line contains an integer between $1$ and $n$, indicating the earliest round in which an illegal move occurs.\n\nThe next $n$ lines each contain two integers, as in the input format, describing a legal move sequence.", "hint": "[Sample explanation]\n\nIn round $3$ of Will’s given plan, moving needle $4$ to the left is blocked by needle $5$.\n\n[Constraints]\n\nSee the table below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y7thkctp.png)\n\nFor a test point:\n\n- If the illegal move detection is correct but the provided plan is wrong, you can get $5$ points. The message will be: `An invalid move in step`.\n- If the illegal move detection is wrong but the provided plan is correct, you can get $5$ points. The message will be: `Negative error detection!`.\n- If both the detection and the plan are correct, you get $10$ points; otherwise, $0$ points.\n\nIf the program’s output format is incorrect, it will be directly judged as $0$ points.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2012] 记忆中的水杉树", "background": "", "description": "江苏省常州高级中学是一所百年名校，这里萦绕着无数人难以忘怀的回忆。\n\nWill 记得，在他小的时候，常州高级中学改建以前，学校里有一片高大的水杉林，每到水杉落叶之时，针状的叶子会像毯子一样盖在地上，走在上面浪漫而又闲适。那时，Will 和同学们还喜欢用这些针叶，在水杉树下，玩“取叶子”的游戏。 \n\n游戏一开始，大家先将 $n$ 片针叶平铺在地上。接着，每一轮可以有一个同学选择一片针叶，按水平或者垂直方向将针叶移走（也就是平移到无穷远处）——当然，前提是移动过程中不被任何尚未移走的针叶所阻碍。如果某一轮针叶的移动会被阻碍，那么这次移动就是非法的，是不被允许的。\n\n$n$ 轮过后，当针叶都被移走时，游戏也就结束了。 针叶并不是任何时刻都可以被移动的。当针叶很多的时候，判断每一轮中一片针叶是否可以按一个特定的方向移动是一件很麻烦的事情。 现在我们将地面抽象为平面直角坐标系，$n$ 片针叶抽象为平面上 $n$ 条互不相交的线段，并将其从 $1$ 到 $n$ 编号，Will 还将给出每一轮游戏中，他想要移动的针叶编号以及移动方向，请你帮助他：\n\n1. 找出最早的一次非法移动出现在哪一轮；\n\n2. 给出一个合法的移动方案完成这个游戏。\n\n注意：在线段移动时仅端点接触不会造成阻碍，具体请参见样例。\n", "inputFormat": "输入文件的第一行包含一个正整数 $n$，表示针叶的数量。\n\n接下来 $n$ 行，每行 $4$ 个整数，描述针叶的位置信息。其中第 $i$ 行的整数为 $a_i$，$b_i$，$c_i$，$d_i$，表示编号为 $i$ 的针叶所抽象成的线段的端点为$(a_i, b_i)$和$(c_i, d_i)$。\n\n接下来 $n$ 行，每行 $2$ 个整数，描述移动操作。其中第 $i$ 行的整数为 $p_i$，$q_i$，表示第 $i$ 轮移动的针叶编号为 $p_i$，方向为 $q_i$。其中 $q_i$为一个 $0$ 到 $3$ 之间的整数，$0$ 表示向左平移（即 $x$ 轴负方向） ，$1$ 表示向上平移（即 $y$ 轴正方向） ，$2$ 表示向右平移，$3$ 表示向下平移。\n\n输入数据保证：\n\n- 所有线段长度为正，两两之间没有公共点，且不存在垂直或者水平的线段;\n- $p_1$ 到 $p_n$ 恰好组成一个 $1$ 到 $n$ 的排列；\n- Will 所给出的移动操作中一定存在非法移动；\n- $n$ 轮均合法的移动操作总是存在的。\n", "outputFormat": "输出文件一共包含 $n+1$ 行。\n\n输出的第一行包含一个 $1$ 到 $n$ 之间的整数，表示最早出现非法移动的是哪一轮。\n\n接下来 $n$ 行，每行两个整数，内容同输入格式所述，描述一个合法的移动序列。\n", "hint": "【样例说明】\n\n在 Will 给出的移动方案的第 $3$ 轮中，编号为 $4$ 的针叶向左移动会被编号为 $5$ 的针叶阻碍。\n\n【数据范围】\n\n具体数据范围见下表。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y7thkctp.png)\n\n对于一个测试点：\n\n如果非法移动判断正确，但是给出的方案错误，可以得到 $5$ 分。此时会提示：`An invalid move in step`\n\n如果非法移动判断错误，但是给出的方案正确，可以得到 $5$ 分。此时会提示：`Negative error detection!`\n\n如果非法移动的判断与给出方案均正确，则可以得到 $10$ 分；\n\n否则，得 $0$ 分。\n\n 如果程序的输出格式不正确，将被直接判作输出格式不正确，将被直接判作 $0$ 分。\n", "locale": "zh-CN"}}}
{"pid": "P4126", "type": "P", "difficulty": 6, "samples": [["6 7 1 6\n1 2 3\n1 3 2\n2 4 4\n2 5 1\n3 5 5\n4 6 2\n5 6 3", "1 0\n1 0\n0 0\n1 0\n0 0\n1 0\n1 0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "并查集", "各省省选", "安徽", "强连通分量", "最小割"], "title": "[AHOI2009] 最小割", "background": null, "description": "$A,B$ 两个国家正在交战，其中 $A$ 国的物资运输网中有 $N$ 个中转站，$M$ 条单向道路。设其中第 $i(1\\le i\\le M)$ 条道路连接了 $v_i,u_i$ 两个中转站，那么中转站 $v_i$ 可以通过该道路到达 $u_i$ 中转站，如果切断这条道路，需要代价 $c_i$。\n\n现在 $B$ 国想找出一个路径切断方案，使中转站 $s$ 不能到达中转站 $t$，并且切断路径的代价之和最小。\n\n小可可一眼就看出，这是一个求最小割的问题。但爱思考的小可可并不局限于此。现在他对每条单向道路提出两个问题：\n\n- 问题一：是否存在一个最小代价路径切断方案，其中该道路被切断？\n- 问题二：是否对任何一个最小代价路径切断方案，都有该道路被切断？\n\n现在请你回答这两个问题。", "inputFormat": "第一行有 $4$ 个正整数，依次为 $N,M,s,t$。\n\n第 $2$ 行到第 $(M+1)$ 行每行 $3$ 个正整数 $v,u,c$，表示 $v$ 中转站到 $u$ 中转站之间有单向道路相连，单向道路的起点是 $v$，终点是 $u$，切断它的代价是 $c(1\\le c\\le100000)$。\n\n注意:两个中转站之间可能有多条道路直接相连。 同一行相邻两数之间可能有一个或多个空格。", "outputFormat": "对每条单向边，按输入顺序，依次输出一行，包含两个非 $0$ 即 $1$ 的整数，分别表示对问题一和问题二的回答(其中输出 $1$ 表示是，输出 $0$ 表示否)。 同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。", "hint": "设第 $(i+1)$ 行输入的边为 $i$ 号边，那么 $\\{1,2\\},\\{6,7\\},\\{2,4,6\\}$ 是仅有的三个最小代价切割方案。它们的并是 $\\{1,2,4,6,7\\}$，交是 $\\{\\varnothing \\}$。\n\n测试数据规模如下表所示\n\n数据编号|N|M|数据编号|N|M\n-|-|-|-|-|-\n1|10|50|6|1000|20000\n2|20|200|7|1000|40000\n3|200|2000|8|2000|50000\n4|200|2000|9|3000|60000\n5|1000|20000|10|4000|60000", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2009] Minimum Cut", "background": "", "description": "Countries $A, B$ are at war. In country $A$’s supply transport network, there are $N$ transshipment stations and $M$ directed roads. Suppose the $i$-th ($1\\le i\\le M$) road connects stations $v_i, u_i$, meaning that station $v_i$ can reach station $u_i$ via this road. Cutting this road costs $c_i$.\n\nCountry $B$ wants to find a set of roads to cut so that station $s$ cannot reach station $t$, and the total cutting cost is minimized.\n\nXiao Keke immediately recognizes that this is a minimum cut problem. But the thoughtful Xiao Keke goes further. For each directed road, he asks two questions:\n\n- Question 1: Does there exist a minimum-cost cut in which this road is cut?\n- Question 2: Is this road cut in every minimum-cost cut?\n\nPlease answer these two questions.", "inputFormat": "The first line contains $4$ positive integers: $N, M, s, t$.\n\nEach of the next $M$ lines contains $3$ positive integers $v, u, c$, indicating a directed road from station $v$ to station $u$, with cutting cost $c$ ($1\\le c\\le 100000$).\n\nNote: There may be multiple roads directly connecting the same pair of stations. Within the same line, adjacent numbers may be separated by one or more spaces.", "outputFormat": "For each directed road, in the input order, output one line containing two integers, each either $0$ or $1$. They are the answers to Question 1 and Question 2 respectively ($1$ means yes, $0$ means no). Separate the two numbers on the same line with a single space, and do not print extra spaces at the beginning or end of the line.", "hint": "Let the edge given on line $(i+1)$ be labeled as edge $i$. Then $\\{1,2\\}, \\{6,7\\}, \\{2,4,6\\}$ are the only three minimum-cost cuts. Their union is $\\{1,2,4,6,7\\}$, and their intersection is $\\varnothing$.\n\nThe scale of the testdata is shown in the table below.\n\nTestdata ID|N|M|Testdata ID|N|M\n-|-|-|-|-|-\n1|10|50|6|1000|20000\n2|20|200|7|1000|40000\n3|200|2000|8|2000|50000\n4|200|2000|9|3000|60000\n5|1000|20000|10|4000|60000\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2009] 最小割", "background": null, "description": "$A,B$ 两个国家正在交战，其中 $A$ 国的物资运输网中有 $N$ 个中转站，$M$ 条单向道路。设其中第 $i(1\\le i\\le M)$ 条道路连接了 $v_i,u_i$ 两个中转站，那么中转站 $v_i$ 可以通过该道路到达 $u_i$ 中转站，如果切断这条道路，需要代价 $c_i$。\n\n现在 $B$ 国想找出一个路径切断方案，使中转站 $s$ 不能到达中转站 $t$，并且切断路径的代价之和最小。\n\n小可可一眼就看出，这是一个求最小割的问题。但爱思考的小可可并不局限于此。现在他对每条单向道路提出两个问题：\n\n- 问题一：是否存在一个最小代价路径切断方案，其中该道路被切断？\n- 问题二：是否对任何一个最小代价路径切断方案，都有该道路被切断？\n\n现在请你回答这两个问题。", "inputFormat": "第一行有 $4$ 个正整数，依次为 $N,M,s,t$。\n\n第 $2$ 行到第 $(M+1)$ 行每行 $3$ 个正整数 $v,u,c$，表示 $v$ 中转站到 $u$ 中转站之间有单向道路相连，单向道路的起点是 $v$，终点是 $u$，切断它的代价是 $c(1\\le c\\le100000)$。\n\n注意:两个中转站之间可能有多条道路直接相连。 同一行相邻两数之间可能有一个或多个空格。", "outputFormat": "对每条单向边，按输入顺序，依次输出一行，包含两个非 $0$ 即 $1$ 的整数，分别表示对问题一和问题二的回答(其中输出 $1$ 表示是，输出 $0$ 表示否)。 同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。", "hint": "设第 $(i+1)$ 行输入的边为 $i$ 号边，那么 $\\{1,2\\},\\{6,7\\},\\{2,4,6\\}$ 是仅有的三个最小代价切割方案。它们的并是 $\\{1,2,4,6,7\\}$，交是 $\\{\\varnothing \\}$。\n\n测试数据规模如下表所示\n\n数据编号|N|M|数据编号|N|M\n-|-|-|-|-|-\n1|10|50|6|1000|20000\n2|20|200|7|1000|40000\n3|200|2000|8|2000|50000\n4|200|2000|9|3000|60000\n5|1000|20000|10|4000|60000", "locale": "zh-CN"}}}
{"pid": "P4127", "type": "P", "difficulty": 5, "samples": [["10 19", "3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "递推", "2009", "各省省选", "安徽", "枚举", "数位 DP"], "title": "[AHOI2009] 同类分布", "background": null, "description": "给出两个数 $a,b$，求出 $[a,b]$ 中各位数字之和能整除原数的数的个数。", "inputFormat": "一行，两个整数 $a$ 和 $b$。", "outputFormat": "一个整数，表示答案。", "hint": "对于所有的数据，$1 \\le a \\le b \\le 10^{18}$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2009] Similar Distribution", "background": "", "description": "Given two numbers $a, b$, find the count of integers in $[a, b]$ whose sum of digits divides the number itself.", "inputFormat": "One line, two integers $a$ and $b$.", "outputFormat": "A single integer representing the answer.", "hint": "For all testdata, $1 \\le a \\le b \\le 10^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2009] 同类分布", "background": null, "description": "给出两个数 $a,b$，求出 $[a,b]$ 中各位数字之和能整除原数的数的个数。", "inputFormat": "一行，两个整数 $a$ 和 $b$。", "outputFormat": "一个整数，表示答案。", "hint": "对于所有的数据，$1 \\le a \\le b \\le 10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P4128", "type": "P", "difficulty": 7, "samples": [["1 1 2", "1"], ["3 2 97", "4"], ["3 4 97", "20"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2006", "各省省选", "上海", "群论", "置换", "Pólya 定理"], "title": "[SHOI2006] 有色图", "background": null, "description": "如果一张无向完全图（完全图就是任意两个不同的顶点之间有且仅有一条边相连）的每条边都被染成了一种颜色，我们就称这种图为有色图。如果两张有色图有相同数量的顶点，而且经过某种顶点编号的重排，能够使得两张图对应的边的颜色是一样的，我们就称这两张有色图是同构的。以下两张图就是同构的，因为假如你把第一张图的顶点 $(1,2,3,4)$ 置换成第二张图的 $(4,1,2,3)$，就会发现它们是一样的。\n\n![](https://cdn.luogu.com.cn/upload/pic/13240.png) \n\n你的任务是，对于计算所有顶点数为 $n$，颜色种类不超过 $m$ 的图，最多有几张是两两不同构的图。由于最后的答案会很大，你只要输出结论模 $p$ 的余数就可以了（$p$ 是一个质数）。", "inputFormat": "输入文件只有一行，由三个正整数 $n,m,p$ 组成。", "outputFormat": "即总数模 $p$ 后的余数。", "hint": "对于 $100 \\%$ 的数据，$1\\leq n\\leq 53$，$1\\leq m\\leq 1000$，$n<p\\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2006] Colored Graph", "background": "", "description": "If every edge of an undirected complete graph (a complete graph means that any two distinct vertices are connected by exactly one edge) is colored with one color, we call such a graph a colored graph. If two colored graphs have the same number of vertices and, after some relabeling of the vertices, the colors of the corresponding edges are identical, then the two colored graphs are said to be isomorphic. The following two graphs are isomorphic, because if you permute the vertices of the first graph $(1,2,3,4)$ into $(4,1,2,3)$ in the second graph, you will find they are the same.\n\n![](https://cdn.luogu.com.cn/upload/pic/13240.png) \n\nYour task is to compute, among all undirected complete graphs on $n$ vertices whose edges are colored using at most $m$ colors, how many pairwise non-isomorphic graphs there are. Since the answer can be very large, you only need to output the remainder modulo $p$ (where $p$ is a prime).", "inputFormat": "The input contains a single line with three positive integers $n,m,p$.", "outputFormat": "Output the remainder of the total count modulo $p$.", "hint": "For $100\\%$ of the testdata, $1 \\leq n \\leq 53$, $1 \\leq m \\leq 1000$, $n < p \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2006] 有色图", "background": null, "description": "如果一张无向完全图（完全图就是任意两个不同的顶点之间有且仅有一条边相连）的每条边都被染成了一种颜色，我们就称这种图为有色图。如果两张有色图有相同数量的顶点，而且经过某种顶点编号的重排，能够使得两张图对应的边的颜色是一样的，我们就称这两张有色图是同构的。以下两张图就是同构的，因为假如你把第一张图的顶点 $(1,2,3,4)$ 置换成第二张图的 $(4,1,2,3)$，就会发现它们是一样的。\n\n![](https://cdn.luogu.com.cn/upload/pic/13240.png) \n\n你的任务是，对于计算所有顶点数为 $n$，颜色种类不超过 $m$ 的图，最多有几张是两两不同构的图。由于最后的答案会很大，你只要输出结论模 $p$ 的余数就可以了（$p$ 是一个质数）。", "inputFormat": "输入文件只有一行，由三个正整数 $n,m,p$ 组成。", "outputFormat": "即总数模 $p$ 后的余数。", "hint": "对于 $100 \\%$ 的数据，$1\\leq n\\leq 53$，$1\\leq m\\leq 1000$，$n<p\\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4129", "type": "P", "difficulty": 5, "samples": [["14 3\n9 1 2 3 4 5 6 7 8 3\n7 2 9 10 11 12 13 10\n2 2 14", "35"], ["10 2\n7 1 2 3 4 5 6 1\n6 3 7 8 9 10 2", "0"], ["5 1\n4 1 2 3 4", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "高精度", "2005", "2006", "各省省选", "上海", "仙人掌", "ICPC", "NERC/NEERC"], "title": "[NEERC 2005 / SHOI2006] 仙人掌", "background": "本题不同于 bzoj1023，bzoj1023 洛谷快捷通道：[[SHOI2008] 仙人掌图 II](/problem/P4244)。", "description": "仙人掌图（cactus）是一种无向连通图，它的每条边最多只能出现在一个简单回路（simple cycle）里面。从直观上说，可以把仙人掌图理解为允许存在回路的树。但是仙人掌图和树之间有个本质的不同，仙人掌图可以拥有多个支撑子图（spanning subgraph），而树的支撑子图只有一个（它自身），我们把仙人掌图的支撑子图的数目称为“仙人数”。你的任务就是计算给定图的“仙人数”。\n\n一些关于仙人掌图的举例：\n ![](https://cdn.luogu.com.cn/upload/pic/13241.png) \n\n第一张图是一个仙人掌图，第二张图的边 $(2,3)$ 在两个不同的回路里面，所以不是仙人掌图，第三张图不是一个连通图，所以也不是仙人掌图。\n\n以下是对一些术语的解释：\n\n- 简单回路（simple cycle）：简单回路是原图的一条路径，这条路径的边集构成了回路，回路中顶点只能出现一次。比如对于上例中第二个图来说，它一共有三个简单回路，分别是 $(4,3,2,1,6,5)$、$(7,8,9,10,2,3)$ 和 $(4,3,7,8,9,10,2,1,6,5)$；\n- 支撑子图（spanning subgraph）：支撑子图也是原图的子图，这种子图可以比原来少一些边，但是不能破坏图的连通性，也不能去除原来图上的任何顶点。“支撑”的概念类似于我们熟知的“最小支撑树”，对于上例中的第一张图来说，任意去除回路I中的图或回路II中的一条边都能构成一个支撑子图，所以它的支撑子图一共有 $6 + 4 + 6 × 4 + 1 = 35$ 种（注意图自身也是自己的一个子图）。", "inputFormat": "输入文件的第一行是两个整数 $n$ 和 $m$。$n$ 代表图的顶点数，顶点的编号总是从 $1$ 到 $n$ 表示的。\n\n接下来一共有 $m$ 行。每行都代表了图上的一条路径（注意：这里所表示的一条路径可不一定是一条回路）。这些行的格式是首先有一个整数 $k_i$ 代表这条路径通过了几个顶点，接下来是 $k_i$ 个在 $1$ 到 $n$ 之间的数字，其中每个数字代表了图上的一个顶点，相邻的顶点之间就定义了一条边。一条路径上可能通过一个顶点好几次，比如对于第一个例子，第一条路径从 $2$ 经过 $3$，又从 $8$ 返回到了 $3$，但是我们保证所有的边都会出现在某条路径上，而且不会重复出现在两条路径上，或者在一条路径上出现两次。", "outputFormat": "输出这张图的“仙人数”，如果它不是一张仙人掌图，输出 `0`。注意最后的答案可能是一个很大很大的数。", "hint": "对于所有数据，满足 $1\\le n\\le 20000$，$0\\le m\\le 1000$，$2\\le k_i\\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[NEERC 2005 / SHOI2006] Cactus", "background": "This problem is different from bzoj1023. Luogu quick access to bzoj1023: [[SHOI2008] Cactus II](/problem/P4244).", "description": "A cactus is an undirected connected graph in which each edge appears in at most one simple cycle. Intuitively, a cactus can be viewed as a tree that is allowed to have cycles. There is, however, a fundamental difference between cacti and trees: a cactus can have multiple connected spanning subgraphs, whereas a tree has only one (itself). We call the number of connected spanning subgraphs the “Xian” number (xiān). Your task is to compute the “Xian” number of the given graph.\n\nSome examples of cacti:\n ![](https://cdn.luogu.com.cn/upload/pic/13241.png) \n\nThe first figure is a cactus. In the second figure, the edge $(2,3)$ lies on two different cycles, so it is not a cactus. The third figure is not connected, so it is not a cactus either.\n\nExplanations of some terms:\n\n- Simple cycle: A simple cycle is a path in the original graph whose edge set forms a cycle, and each vertex appears at most once in the cycle. For example, for the second figure above, it has three simple cycles: $(4,3,2,1,6,5)$, $(7,8,9,10,2,3)$, and $(4,3,7,8,9,10,2,1,6,5)$.\n- Spanning subgraph: A spanning subgraph is also a subgraph of the original graph; it may have fewer edges, but it must preserve connectivity and must not remove any vertices of the original graph. The notion of “spanning” is similar to that in the familiar “minimum spanning tree.” For the first figure above, removing any one edge in cycle I or any one edge in cycle II yields a spanning subgraph, so the total number of spanning subgraphs is $6 + 4 + 6 \\times 4 + 1 = 35$ (note that a graph is also a subgraph of itself).", "inputFormat": "The first line contains two integers $n$ and $m$. The $n$ vertices are numbered from $1$ to $n$.\n\nEach of the next $m$ lines describes a path in the graph (note: such a path is not necessarily a cycle). The format of a line is: an integer $k_i$ indicating how many vertices this path goes through, followed by $k_i$ integers between $1$ and $n$, each denoting a vertex of the graph; consecutive vertices define an edge. A path may pass through the same vertex multiple times. For example, in the first figure, the first path goes from $2$ through $3$, and then returns to $3$ from $8$. We guarantee that every edge appears in exactly one path: no edge appears in two different paths, and no edge appears twice within a single path.", "outputFormat": "Output the graph’s “Xian” number. If it is not a cactus, output `0`. Note that the final answer can be very large.", "hint": "For all testdata, $1 \\le n \\le 20000$, $0 \\le m \\le 1000$, and $2 \\le k_i \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NEERC 2005 / SHOI2006] 仙人掌", "background": "本题不同于 bzoj1023，bzoj1023 洛谷快捷通道：[[SHOI2008] 仙人掌图 II](/problem/P4244)。", "description": "仙人掌图（cactus）是一种无向连通图，它的每条边最多只能出现在一个简单回路（simple cycle）里面。从直观上说，可以把仙人掌图理解为允许存在回路的树。但是仙人掌图和树之间有个本质的不同，仙人掌图可以拥有多个支撑子图（spanning subgraph），而树的支撑子图只有一个（它自身），我们把仙人掌图的支撑子图的数目称为“仙人数”。你的任务就是计算给定图的“仙人数”。\n\n一些关于仙人掌图的举例：\n ![](https://cdn.luogu.com.cn/upload/pic/13241.png) \n\n第一张图是一个仙人掌图，第二张图的边 $(2,3)$ 在两个不同的回路里面，所以不是仙人掌图，第三张图不是一个连通图，所以也不是仙人掌图。\n\n以下是对一些术语的解释：\n\n- 简单回路（simple cycle）：简单回路是原图的一条路径，这条路径的边集构成了回路，回路中顶点只能出现一次。比如对于上例中第二个图来说，它一共有三个简单回路，分别是 $(4,3,2,1,6,5)$、$(7,8,9,10,2,3)$ 和 $(4,3,7,8,9,10,2,1,6,5)$；\n- 支撑子图（spanning subgraph）：支撑子图也是原图的子图，这种子图可以比原来少一些边，但是不能破坏图的连通性，也不能去除原来图上的任何顶点。“支撑”的概念类似于我们熟知的“最小支撑树”，对于上例中的第一张图来说，任意去除回路I中的图或回路II中的一条边都能构成一个支撑子图，所以它的支撑子图一共有 $6 + 4 + 6 × 4 + 1 = 35$ 种（注意图自身也是自己的一个子图）。", "inputFormat": "输入文件的第一行是两个整数 $n$ 和 $m$。$n$ 代表图的顶点数，顶点的编号总是从 $1$ 到 $n$ 表示的。\n\n接下来一共有 $m$ 行。每行都代表了图上的一条路径（注意：这里所表示的一条路径可不一定是一条回路）。这些行的格式是首先有一个整数 $k_i$ 代表这条路径通过了几个顶点，接下来是 $k_i$ 个在 $1$ 到 $n$ 之间的数字，其中每个数字代表了图上的一个顶点，相邻的顶点之间就定义了一条边。一条路径上可能通过一个顶点好几次，比如对于第一个例子，第一条路径从 $2$ 经过 $3$，又从 $8$ 返回到了 $3$，但是我们保证所有的边都会出现在某条路径上，而且不会重复出现在两条路径上，或者在一条路径上出现两次。", "outputFormat": "输出这张图的“仙人数”，如果它不是一张仙人掌图，输出 `0`。注意最后的答案可能是一个很大很大的数。", "hint": "对于所有数据，满足 $1\\le n\\le 20000$，$0\\le m\\le 1000$，$2\\le k_i\\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P4130", "type": "P", "difficulty": 6, "samples": [["5 3\n1 2 3 2 1\n4\nC\nR 2\nP 5 5 2\nCS 4 1", "4\n1"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "线段树", "NOI"], "title": "[NOI2007] 项链工厂", "background": "T 公司是一家专门生产彩色珠子项链的公司，其生产的项链设计新颖、款式多样、价格适中，广受青年人的喜爱。\n\n最近 T 公司打算推出一款项链自助生产系统，使用该系统顾客可以自行设计心目中的美丽项链。该项链自助生产系统包括硬件系统与软件系统，软件系统与用户进行交互并控制硬件系统，硬件系统接受软件系统的命令生产指定的项链。该系统的硬件系统已经完成，而软件系统尚未开发，T 公司的人找到了正在参加全国信息学竞赛的你，你能帮助 T 公司编写一个软件模拟系统吗？", "description": "一条项链包含 $N$ 个珠子，每个珠子的颜色是 $1,2,…,c$ 中的一种。项链被固定在一个平板上，平板的某个位置被标记位置 $1$ ，按顺时针方向其他位置被记为 $2,3,…,N$。\n\n ![](https://cdn.luogu.com.cn/upload/pic/13560.png) \n\n你将要编写的软件系统应支持如下命令：\n\n ![](https://cdn.luogu.com.cn/upload/pic/13561.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/13562.png)", "inputFormat": "输入文件第一行包含两个整数 $N,c$，分别表示项链包含的珠子数目以及颜色数目。\n\n第二行包含 $N$ 个整数，$x_1,x_2,\\cdots,x_n$，表示从位置 $1$ 到位置 $N$ 的珠子的颜色，$1 \\le x_i \\le c$。\n\n第三行包含一个整数 $Q$，表示命令数目。\n\n接下来的 $Q$ 行每行一条命令，如上文所述。", "outputFormat": "对于每一个 `C` 和 `CS` 命令，应输出一个整数代表相应的答案。", "hint": "【数据规模和约定】\n\n对于 60% 的数据，$N \\le 1000$，$Q \\le 1000$；\n\n对于 100% 的数据，$N \\le 500000$，$Q \\le 500000$，$c \\le 1000$。\n\n关于旋转和翻转\n\n\n注意旋转命令旋转“珠子”但不改变“位置”的编号，而反转命令始终以位置 1 为对称轴。例如当 $N=10$ 时，项链上的位置编号如图 1：\n\n\n但注意此时项链上的位置编号仍然如图 1 所示，于是翻转的对称轴不变。因而再执行一次“F”命令时，项链的颜色如图 4 所示。\n\n ![](https://cdn.luogu.com.cn/upload/pic/13244.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/13245.png) \n\n关于 CountSegment 命令\n\n\nCS 命令表示查询一个“线段”中有多少个“部分”。尤其注意当查询的长度等于 $N$ 时，我们仍然将查询部分作为“线段”理解。\n\n\n例如在图 4 所示的情况中，执行“CS 1 10”命令，查询从位置 1 开始到位置 10 结束的这个长度为 10 的线段中有多少个“部分”，于是得到返回值 3。与之形成对照的是，若执行“C”命令，返回值则为 2。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2007] Necklace Factory", "background": "Company T specializes in producing necklaces made of colored beads. Its necklaces have fresh designs, diverse styles, and reasonable prices, and are popular among young people.\n\nRecently, Company T plans to launch a self-service necklace production system. With this system, customers can design their own beautiful necklaces. The system consists of a hardware component and a software component. The software interacts with users and controls the hardware, and the hardware executes the software’s commands to produce the specified necklace. The hardware has already been completed, but the software has not yet been developed. The team at Company T has found you, a participant in a national informatics competition. Can you help Company T write software to simulate this system?", "description": "A necklace contains $N$ beads. Each bead’s color is one of $1, 2, \\ldots, c$. The necklace is fixed on a flat board. Some point on the board is marked as position $1$, and in the clockwise direction the other positions are labelled $2, 3, \\ldots, N$.\n\n ![](https://cdn.luogu.com.cn/upload/pic/13560.png) \n\nThe software system you will write should support the following commands:\n\n ![](https://cdn.luogu.com.cn/upload/pic/13561.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/13562.png)", "inputFormat": "The first line contains two integers $N, c$, representing the number of beads in the necklace and the number of colors, respectively.\n\nThe second line contains $N$ integers, $x_1, x_2, \\cdots, x_N$, representing the colors of the beads from position $1$ to position $N$, where $1 \\le x_i \\le c$.\n\nThe third line contains an integer $Q$, representing the number of commands.\n\nEach of the next $Q$ lines contains one command, as described above.", "outputFormat": "For each `C` and `CS` command, output one integer representing the corresponding answer.", "hint": "[Constraints and Conventions]\n\nFor 60% of the testdata, $N \\le 1000$, $Q \\le 1000$.\n\nFor 100% of the testdata, $N \\le 500000$, $Q \\le 500000$, $c \\le 1000$.\n\nAbout rotation and flip\n\nNote that the rotation command rotates the beads but does not change the labels of the positions, and the flip command is always symmetric about position $1$. For example, when $N = 10$, the position labels on the necklace are as shown in Figure 1:\n\nHowever, note that the position labels on the necklace still remain as shown in Figure 1, so the axis of symmetry for flipping does not change. Therefore, after executing another “F” command, the colors on the necklace are as shown in Figure 4.\n\n ![](https://cdn.luogu.com.cn/upload/pic/13244.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/13245.png) \n\nAbout the CountSegment command\n\nThe `CS` command queries how many “segments” there are in a linear “segment” of the necklace. In particular, when the query length equals $N$, we still treat the query range as a linear “segment”.\n\nFor example, in the situation shown in Figure 4, executing the command `CS 1 10` queries how many “segments” there are in the linear segment starting at position $1$ and ending at position $10$, which has length $10$, and the return value is $3$. In contrast, if you execute the `C` command, the return value would be $2$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2007] 项链工厂", "background": "T 公司是一家专门生产彩色珠子项链的公司，其生产的项链设计新颖、款式多样、价格适中，广受青年人的喜爱。\n\n最近 T 公司打算推出一款项链自助生产系统，使用该系统顾客可以自行设计心目中的美丽项链。该项链自助生产系统包括硬件系统与软件系统，软件系统与用户进行交互并控制硬件系统，硬件系统接受软件系统的命令生产指定的项链。该系统的硬件系统已经完成，而软件系统尚未开发，T 公司的人找到了正在参加全国信息学竞赛的你，你能帮助 T 公司编写一个软件模拟系统吗？", "description": "一条项链包含 $N$ 个珠子，每个珠子的颜色是 $1,2,…,c$ 中的一种。项链被固定在一个平板上，平板的某个位置被标记位置 $1$ ，按顺时针方向其他位置被记为 $2,3,…,N$。\n\n ![](https://cdn.luogu.com.cn/upload/pic/13560.png) \n\n你将要编写的软件系统应支持如下命令：\n\n ![](https://cdn.luogu.com.cn/upload/pic/13561.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/13562.png)", "inputFormat": "输入文件第一行包含两个整数 $N,c$，分别表示项链包含的珠子数目以及颜色数目。\n\n第二行包含 $N$ 个整数，$x_1,x_2,\\cdots,x_n$，表示从位置 $1$ 到位置 $N$ 的珠子的颜色，$1 \\le x_i \\le c$。\n\n第三行包含一个整数 $Q$，表示命令数目。\n\n接下来的 $Q$ 行每行一条命令，如上文所述。", "outputFormat": "对于每一个 `C` 和 `CS` 命令，应输出一个整数代表相应的答案。", "hint": "【数据规模和约定】\n\n对于 60% 的数据，$N \\le 1000$，$Q \\le 1000$；\n\n对于 100% 的数据，$N \\le 500000$，$Q \\le 500000$，$c \\le 1000$。\n\n关于旋转和翻转\n\n\n注意旋转命令旋转“珠子”但不改变“位置”的编号，而反转命令始终以位置 1 为对称轴。例如当 $N=10$ 时，项链上的位置编号如图 1：\n\n\n但注意此时项链上的位置编号仍然如图 1 所示，于是翻转的对称轴不变。因而再执行一次“F”命令时，项链的颜色如图 4 所示。\n\n ![](https://cdn.luogu.com.cn/upload/pic/13244.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/13245.png) \n\n关于 CountSegment 命令\n\n\nCS 命令表示查询一个“线段”中有多少个“部分”。尤其注意当查询的长度等于 $N$ 时，我们仍然将查询部分作为“线段”理解。\n\n\n例如在图 4 所示的情况中，执行“CS 1 10”命令，查询从位置 1 开始到位置 10 结束的这个长度为 10 的线段中有多少个“部分”，于是得到返回值 3。与之形成对照的是，若执行“C”命令，返回值则为 2。", "locale": "zh-CN"}}}
{"pid": "P4131", "type": "P", "difficulty": 6, "samples": [["5 3\n1 2 3\n-5 3 2\n-2 3 0\n0 5 9\n3 4 -1\n-10 -11 7", "3 5\n36"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "Special Judge", "枚举", "WC", "状压 DP"], "title": "[WC2005] 友好的生物", "background": "", "description": "$W$ 星球是一个和地球一样气候适宜、物种聚集的星球。经过多年的研究，外星生物学家们已经发现了数万种生物，而且这个数字还在不断增大。\n\n$W$ 星球上的生物很有趣，有些生物之间很友好，朝夕相伴，形影不离；但有些却很敌对，一见面就难免发生战斗。为了能够更好地了解它们之间的友好程度，外星生物学家希望进行一些量化的计算。他们发现，两种生物之间的友好程度和它们的 $K$ 种属性有关，暂且将它们编号为属性 $1$、属性 $2$、……、属性 $K$，这些属性都是可以进行量化的。外星生物学家研究发现，如果前 $K-1$ 种属性的差别越大，这两种生物就越友好；但是属性 $K$ 与众不同，这种属性差别越小的两种生物越友好。\n\n因此他们猜想是不是可以用这样一个公式量化两种生物之间的友好程度：$Friendliness=(\\sum_{i=1}^{k-1} C_id_i)-C_Kd_K$\n\n其中 $C_i$ 是非负常数，$d_i$ 是属性 $i$ 的差别。如果知道了每种生物的各种属性，利用上述公式就很容易算出它们之间的友好程度了。现在，外星生物学家们想问一问：在目前发现的这些生物当中，关系最友好的那对生物是哪一对呢？它们之间的友好程度是多少？\n", "inputFormat": "输入文件的第一行是两个整数 $N$ 和 $K$，分别表示目前发现的生物种数和属性的种数。\n\n第二行有 $K$ 个非负整数 $C_i$，即计算友好程度时所需的常数。\n\n接下来的 $N$ 行，描述每种生物，按照先后顺序依次编号为生物 $1$、生物 $2$、……、生物 $N$。每一行都有 $K$ 个整数，给出该种生物的各项属性值，按照先后顺序依次编号为属性 $1$、属性 $2$、……、属性 $K$。\n", "outputFormat": "输出文件包含两行。第一行为两个整数 $i$ 和 $j$（$i \\neq j$），表示你所找到的关系最友好的两种生物为生物 $i$ 和生物 $j$。若最友好的不止一对，输出任意一对。\n\n第二行为一个整数，表示生物 $i$ 和生物 $j$ 之间的友好程度。\n", "hint": "【样例说明】\n\n生物 $3$ 和 $5$ 之间的友好程度为 $1\\times |0-(-10)|+2\\times |5-(-11)|-3\\times |9-7|=36$。\n\n【约定】\n\n- $2 \\leq N \\leq 100,000$\n\n- $2 \\leq K \\leq 5$\n\n- $0 \\leq C_i \\leq 100$。\n\n- 每种生物的各项属性值不小于$-10000$ 且不大于 $10000$。\n\n- 最大的友好程度一定大于 $0$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[WC2005] Friendly Creatures", "background": "", "description": "Planet $W$ is a world with an Earth-like climate and a diverse collection of species. After years of research, xenobiologists have discovered tens of thousands of species, and the number keeps growing.\n\nSpecies on planet $W$ are interesting: some pairs are very friendly, always together and inseparable; others are hostile and fight upon meeting. To better understand their degrees of friendliness, the xenobiologists want to run some quantitative calculations. They have found that the friendliness between two species depends on their $K$ attributes, temporarily numbered as attribute $1$, attribute $2$, …, attribute $K$, all of which are quantifiable. Their research suggests that the larger the differences in the first $K-1$ attributes, the friendlier the pair; but attribute $K$ is special: the smaller the difference in this attribute, the friendlier the pair.\n\nTherefore, they conjecture that the following formula can quantify the friendliness between two species: $Friendliness=(\\sum_{i=1}^{k-1} C_id_i)-C_Kd_K$,\n\nwhere $C_i$ are non-negative constants and $d_i$ is the difference in attribute $i$ (i.e., the absolute difference). If the attributes of each species are known, the above formula makes it easy to compute the friendliness between any pair. Now the xenobiologists ask: among the species discovered so far, which pair is the friendliest, and what is their friendliness?", "inputFormat": "The first line contains two integers $N$ and $K$, the number of discovered species and the number of attributes, respectively.\n\nThe second line contains $K$ non-negative integers $C_i$, the constants used to compute the friendliness.\n\nThe next $N$ lines describe each species, numbered in order as species $1$, species $2$, …, species $N$. Each line contains $K$ integers, giving the values of attributes $1$, $2$, …, $K$ for that species.", "outputFormat": "Output two lines. The first line contains two integers $i$ and $j$ ($i \\neq j$), indicating that the friendliest pair you found is species $i$ and species $j$. If there is more than one friendliest pair, output any one of them.\n\nThe second line contains an integer, the friendliness between species $i$ and species $j$.", "hint": "[Sample Explanation]\n\nThe friendliness between species $3$ and $5$ is $1\\times |0-(-10)|+2\\times |5-(-11)|-3\\times |9-7|=36$.\n\n[Constraints]\n- $2 \\leq N \\leq 100{,}000$.\n- $2 \\leq K \\leq 5$.\n- $0 \\leq C_i \\leq 100$.\n- Each attribute value is at least $-10000$ and at most $10000$.\n- The maximum friendliness is guaranteed to be greater than $0$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2005] 友好的生物", "background": "", "description": "$W$ 星球是一个和地球一样气候适宜、物种聚集的星球。经过多年的研究，外星生物学家们已经发现了数万种生物，而且这个数字还在不断增大。\n\n$W$ 星球上的生物很有趣，有些生物之间很友好，朝夕相伴，形影不离；但有些却很敌对，一见面就难免发生战斗。为了能够更好地了解它们之间的友好程度，外星生物学家希望进行一些量化的计算。他们发现，两种生物之间的友好程度和它们的 $K$ 种属性有关，暂且将它们编号为属性 $1$、属性 $2$、……、属性 $K$，这些属性都是可以进行量化的。外星生物学家研究发现，如果前 $K-1$ 种属性的差别越大，这两种生物就越友好；但是属性 $K$ 与众不同，这种属性差别越小的两种生物越友好。\n\n因此他们猜想是不是可以用这样一个公式量化两种生物之间的友好程度：$Friendliness=(\\sum_{i=1}^{k-1} C_id_i)-C_Kd_K$\n\n其中 $C_i$ 是非负常数，$d_i$ 是属性 $i$ 的差别。如果知道了每种生物的各种属性，利用上述公式就很容易算出它们之间的友好程度了。现在，外星生物学家们想问一问：在目前发现的这些生物当中，关系最友好的那对生物是哪一对呢？它们之间的友好程度是多少？\n", "inputFormat": "输入文件的第一行是两个整数 $N$ 和 $K$，分别表示目前发现的生物种数和属性的种数。\n\n第二行有 $K$ 个非负整数 $C_i$，即计算友好程度时所需的常数。\n\n接下来的 $N$ 行，描述每种生物，按照先后顺序依次编号为生物 $1$、生物 $2$、……、生物 $N$。每一行都有 $K$ 个整数，给出该种生物的各项属性值，按照先后顺序依次编号为属性 $1$、属性 $2$、……、属性 $K$。\n", "outputFormat": "输出文件包含两行。第一行为两个整数 $i$ 和 $j$（$i \\neq j$），表示你所找到的关系最友好的两种生物为生物 $i$ 和生物 $j$。若最友好的不止一对，输出任意一对。\n\n第二行为一个整数，表示生物 $i$ 和生物 $j$ 之间的友好程度。\n", "hint": "【样例说明】\n\n生物 $3$ 和 $5$ 之间的友好程度为 $1\\times |0-(-10)|+2\\times |5-(-11)|-3\\times |9-7|=36$。\n\n【约定】\n\n- $2 \\leq N \\leq 100,000$\n\n- $2 \\leq K \\leq 5$\n\n- $0 \\leq C_i \\leq 100$。\n\n- 每种生物的各项属性值不小于$-10000$ 且不大于 $10000$。\n\n- 最大的友好程度一定大于 $0$。\n", "locale": "zh-CN"}}}
{"pid": "P4132", "type": "P", "difficulty": 5, "samples": [["5 7", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "各省省选", "北京", "O2优化"], "title": "[BJOI2012] 算不出的等式", "background": "曾经有一个老掉牙的游戏放在我面前，我没有珍惜。直到这个游戏停产才追悔莫及。人世间最痛苦的事情莫过于此，如果上天给我一个再玩一次的机会，我一定要，通关！", "description": "如果你真的很想玩这个游戏，那么就先看看我的题目吧，搞不定这些的话是没办法通关的哟。第一关其实很简单，只有一个关闭的有密码锁的大门。这大门上写着一个奇怪的算式，估计是要你利用它算出密码来开门吧（果然是老掉牙的情节）。\n\n传说中这个式子中的 $p$ 和 $q$ 是两个奇质数，等号右边算出来应该就是密码了吧，你是真的算不出来么？\n\n\n$$\n\\sum_{k=1}^{\\frac{p-1}{2}} \\biggl\\lfloor\\frac{kq}{p}\\biggr\\rfloor+\\sum_{k=1}^{\\frac{q-1}{2}} \\biggl\\lfloor\\frac{kp}{q}\\biggr\\rfloor\n$$", "inputFormat": "只有一行，两个奇质数，分别表示 $p,q$。", "outputFormat": "一个数，表示算式结果。", "hint": "$p,q<2^{32}$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2012] The Uncomputable Equation", "background": "Once there was a cheesy old game right in front of me, and I didn’t cherish it. Only when the game was discontinued did I deeply regret it. There is nothing more painful in this world than that. If heaven gave me one more chance to play it, I would definitely beat it!", "description": "If you really want to play this game, then take a look at my problem first. If you can’t handle these, you won’t be able to clear the game. The first level is actually simple: there is only a locked door with a password. There is a strange formula written on the door; I guess you are supposed to use it to compute the password to open the door (what a cliché).\n\nLegend says that in this expression, $p$ and $q$ are two odd primes. The computed value should be the password. Can you really not work it out?\n\n$$\n\\sum_{k=1}^{\\frac{p-1}{2}} \\biggl\\lfloor\\frac{kq}{p}\\biggr\\rfloor+\\sum_{k=1}^{\\frac{q-1}{2}} \\biggl\\lfloor\\frac{kp}{q}\\biggr\\rfloor\n$$", "inputFormat": "A single line containing two odd primes, denoting $p, q$.", "outputFormat": "A single number, the value of the expression.", "hint": "$p, q < 2^{32}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2012] 算不出的等式", "background": "曾经有一个老掉牙的游戏放在我面前，我没有珍惜。直到这个游戏停产才追悔莫及。人世间最痛苦的事情莫过于此，如果上天给我一个再玩一次的机会，我一定要，通关！", "description": "如果你真的很想玩这个游戏，那么就先看看我的题目吧，搞不定这些的话是没办法通关的哟。第一关其实很简单，只有一个关闭的有密码锁的大门。这大门上写着一个奇怪的算式，估计是要你利用它算出密码来开门吧（果然是老掉牙的情节）。\n\n传说中这个式子中的 $p$ 和 $q$ 是两个奇质数，等号右边算出来应该就是密码了吧，你是真的算不出来么？\n\n\n$$\n\\sum_{k=1}^{\\frac{p-1}{2}} \\biggl\\lfloor\\frac{kq}{p}\\biggr\\rfloor+\\sum_{k=1}^{\\frac{q-1}{2}} \\biggl\\lfloor\\frac{kp}{q}\\biggr\\rfloor\n$$", "inputFormat": "只有一行，两个奇质数，分别表示 $p,q$。", "outputFormat": "一个数，表示算式结果。", "hint": "$p,q<2^{32}$。", "locale": "zh-CN"}}}
{"pid": "P4133", "type": "P", "difficulty": 5, "samples": [["16", "4"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "递推", "2012", "各省省选", "北京", "O2优化", "枚举", "Fibonacci 数列"], "title": "[BJOI2012] 最多的方案", "background": "", "description": "第二关和很出名的斐波那契数列有关，地球上的 OIer 都知道：  \n$$F_n = \\begin{cases} 1 & (n \\le 2) \\\\ F_{n-1}+F_{n-2} & (n \\ge 3) \\end{cases}$$ \n每一项都可以称为斐波那契数。  \n\n现在给一个正整数 $n$，它可以写成一些斐波那契数的和的形式。如果我们要求不同的方案中不能有相同的斐波那契数，那么对一个 $n$ 最多可以写出多少种方案呢？\n", "inputFormat": "只有一个整数 $n$。\n", "outputFormat": "一个整数表示方案数。", "hint": "Hint：16=3+13=3+5+8=1+2+13=1+2+5+8\n\n【数据范围】   \n对于 $30\\%$ 的数据，$n \\le 256$；  \n对于 $100\\%$ 的数据，$n \\le 10^{18}$。\n", "locale": "zh-CN", "translations": {"en": {"title": "{{[BJOI2012] Maximum Number of Ways}}", "background": "{{}}", "description": "{{The second stage is related to the famous Fibonacci sequence. Every OIer on Earth knows:\n$$F_n = \\begin{cases} 1 & (n \\le 2) \\\\ F_{n-1}+F_{n-2} & (n \\ge 3) \\end{cases}$$\nEach term is called a Fibonacci number.\n\nNow given a positive integer $n$, it can be written as a sum of some Fibonacci numbers. If we require that in each representation the Fibonacci numbers are distinct (no repetition), then for a given $n$, how many different ways can it be written?}}", "inputFormat": "{{A single integer $n$.}}", "outputFormat": "{{Output a single integer representing the number of ways.}}", "hint": "{{Hint: 16 = 3 + 13 = 3 + 5 + 8 = 1 + 2 + 13 = 1 + 2 + 5 + 8.\n\nConstraints  \nFor 30% of the testdata, $n \\le 256$.  \nFor 100% of the testdata, $n \\le 10^{18}$.}}\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2012] 最多的方案", "background": "", "description": "第二关和很出名的斐波那契数列有关，地球上的 OIer 都知道：  \n$$F_n = \\begin{cases} 1 & (n \\le 2) \\\\ F_{n-1}+F_{n-2} & (n \\ge 3) \\end{cases}$$ \n每一项都可以称为斐波那契数。  \n\n现在给一个正整数 $n$，它可以写成一些斐波那契数的和的形式。如果我们要求不同的方案中不能有相同的斐波那契数，那么对一个 $n$ 最多可以写出多少种方案呢？\n", "inputFormat": "只有一个整数 $n$。\n", "outputFormat": "一个整数表示方案数。", "hint": "Hint：16=3+13=3+5+8=1+2+13=1+2+5+8\n\n【数据范围】   \n对于 $30\\%$ 的数据，$n \\le 256$；  \n对于 $100\\%$ 的数据，$n \\le 10^{18}$。\n", "locale": "zh-CN"}}}
{"pid": "P4134", "type": "P", "difficulty": 6, "samples": [["1 15", "2 34"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "各省省选", "北京", "二分图", "费用流"], "title": "[BJOI2012] 连连看", "background": "", "description": "凡是考智商的题里面总会有这么一种消除游戏。不过现在面对的这关连连看可不是 QQ 游戏里那种考眼力的游戏。我们的规则是，给出一个闭区间 $[a,b]$ 中的全部整数，如果其中某两个数 $x$，$y$（$x>y$）的平方差 $x^2-y^2$ 是一个完全平方数 $z^2$，并且 $y$ 与 $z$ 互质，那么就可以将 $x$ 和 $y$ 连起来并且将它们一起消除，同时得到 $x+y$ 点分数。那么过关的要求就是，消除的数对尽可能多的前提下，得到足够的分数。快动手动笔算一算吧。", "inputFormat": "只有一行，两个整数，分别表示 $a$，$b$。", "outputFormat": "两个数，可以消去的对数，及在此基础上能得到的最大分数。\n", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $1\\le a,b\\le100$。\n- 对于 $100\\%$ 的数据，保证 $1\\le a,b\\le1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2012] Lianliankan", "background": "", "description": "Among IQ-test problems there is often an elimination game. But this round of Lianliankan is not the visual-matching game on QQ. Our rule is: given all integers in the closed interval $[a, b]$, if there exist two numbers $x$, $y$ ($x > y$) such that their square difference $x^2 - y^2$ is a perfect square $z^2$, and $y$ and $z$ are coprime, then you may connect $x$ and $y$, remove them together, and gain $x + y$ points. The goal is to maximize the number of removable pairs, and subject to that, maximize the total score. Try to figure it out.", "inputFormat": "One line with two integers, denoting $a$ and $b$.", "outputFormat": "Two integers: the number of pairs that can be removed, and, under that condition, the maximum total score.", "hint": "Constraints:\n- For $30\\%$ of the testdata, $1 \\le a, b \\le 100$.\n- For $100\\%$ of the testdata, $1 \\le a, b \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2012] 连连看", "background": "", "description": "凡是考智商的题里面总会有这么一种消除游戏。不过现在面对的这关连连看可不是 QQ 游戏里那种考眼力的游戏。我们的规则是，给出一个闭区间 $[a,b]$ 中的全部整数，如果其中某两个数 $x$，$y$（$x>y$）的平方差 $x^2-y^2$ 是一个完全平方数 $z^2$，并且 $y$ 与 $z$ 互质，那么就可以将 $x$ 和 $y$ 连起来并且将它们一起消除，同时得到 $x+y$ 点分数。那么过关的要求就是，消除的数对尽可能多的前提下，得到足够的分数。快动手动笔算一算吧。", "inputFormat": "只有一行，两个整数，分别表示 $a$，$b$。", "outputFormat": "两个数，可以消去的对数，及在此基础上能得到的最大分数。\n", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $1\\le a,b\\le100$。\n- 对于 $100\\%$ 的数据，保证 $1\\le a,b\\le1000$。", "locale": "zh-CN"}}}
{"pid": "P4135", "type": "P", "difficulty": 6, "samples": [["5 3 5\n1 2 2 3 1\n0 4\n1 2\n2 2\n2 3\n3 5", "2\n0\n0\n0\n1"]], "limits": {"time": [1500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "枚举", "分块"], "title": "作诗", "background": "神犇 SJY 虐完 HEOI 之后给傻× LYD 出了一题：\n\nSHY 是 T 国的公主，平时的一大爱好是作诗。", "description": "由于时间紧迫，SHY 作完诗之后还要虐 OI，于是 SHY 找来一篇长度为 $n$ 的文章，阅读 $m$ 次，每次只阅读其中连续的一段 $[l,r]$，从这一段中选出一些汉字构成诗。因为 SHY 喜欢对偶，所以 SHY 规定最后选出的每个汉字都必须在 $[l,r]$ 里出现了正偶数次。而且 SHY 认为选出的汉字的种类数（两个一样的汉字称为同一种）越多越好（为了拿到更多的素材！）。于是 SHY 请 LYD 安排选法。\n\nLYD 这种傻×当然不会了，于是向你请教……\n\n问题简述：给定 $n$ 个不大于 $c$ 的正整数 $a_1 \\dots a_n$ 和 $m$ 组询问，每次问 $[l,r]$ 中有多少个数出现正偶数次。", "inputFormat": "**本题强制在线**。\n\n第一行有三个整数 $n$、$c$ 以及 $m$ 。表示文章字数、汉字的种类数、要选择 $m$ 次。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个汉字的编码 $a_i$。\n\n接下来 $m$ 行每行两个整数 $L$ 和 $R$，设上一个询问的答案为 $ans$（第一个询问时 $ans=0$），令 $l=((L+ans)\\bmod n)+1$，$r=((R+ans)\\bmod n)+1$，若 $l>r$，交换 $l$ 和 $r$，则本次询问为 $[l,r]$。", "outputFormat": "输出共 $m$ 行，每行一个整数，第 $i$ 个数表示 SHY 第 $i$ 次能选出的汉字的最多种类数。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1\\le n,c,m\\le 10^5$，$1 \\leq a_i \\leq c$，$1 \\leq l,r \\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "Composing Poetry", "background": "The \"shenben\" SJY, after crushing HEOI, gave a problem to the \"sha×\" LYD.\n\nSHY is the princess of country T, and one of her hobbies is composing poetry.", "description": "Due to time pressure, after finishing a poem SHY still needs to crush OI, so she takes an article of length $n$, reads it $m$ times, and each time reads only a contiguous segment $[l, r]$. From this segment, she selects some Chinese characters to form a poem. Because SHY likes parallelism, she requires that every selected character must appear a positive even number of times within $[l, r]$. Also, SHY wants the number of distinct selected characters (two identical characters are considered the same type) to be as large as possible. So SHY asks LYD to arrange the selection.\n\nLYD, being a \"sha×\", certainly cannot do it, so he asks you for help.\n\nProblem summary: Given $n$ positive integers $a_1 \\dots a_n$ not greater than $c$ and $m$ queries, each query asks how many numbers in $[l, r]$ appear a positive even number of times.", "inputFormat": "This problem is strictly online.\n\nThe first line contains three integers $n$, $c$, and $m$, representing the article length, the number of character types, and the number of selections.\n\nThe second line contains $n$ integers. The $i$-th integer is the code $a_i$ of the $i$-th character.\n\nEach of the next $m$ lines contains two integers $L$ and $R$. Let the previous query’s answer be $ans$ (for the first query, $ans = 0$). Define $l=((L+ans)\\bmod n)+1$, $r=((R+ans)\\bmod n)+1$, and if $l>r$, swap $l$ and $r$. Then the current query is $[l, r]$.", "outputFormat": "Output $m$ lines. The $i$-th integer is the maximum number of distinct characters SHY can select for the $i$-th query.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $1 \\le n, c, m \\le 10^5$, $1 \\leq a_i \\leq c$, $1 \\leq l, r \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "作诗", "background": "神犇 SJY 虐完 HEOI 之后给傻× LYD 出了一题：\n\nSHY 是 T 国的公主，平时的一大爱好是作诗。", "description": "由于时间紧迫，SHY 作完诗之后还要虐 OI，于是 SHY 找来一篇长度为 $n$ 的文章，阅读 $m$ 次，每次只阅读其中连续的一段 $[l,r]$，从这一段中选出一些汉字构成诗。因为 SHY 喜欢对偶，所以 SHY 规定最后选出的每个汉字都必须在 $[l,r]$ 里出现了正偶数次。而且 SHY 认为选出的汉字的种类数（两个一样的汉字称为同一种）越多越好（为了拿到更多的素材！）。于是 SHY 请 LYD 安排选法。\n\nLYD 这种傻×当然不会了，于是向你请教……\n\n问题简述：给定 $n$ 个不大于 $c$ 的正整数 $a_1 \\dots a_n$ 和 $m$ 组询问，每次问 $[l,r]$ 中有多少个数出现正偶数次。", "inputFormat": "**本题强制在线**。\n\n第一行有三个整数 $n$、$c$ 以及 $m$ 。表示文章字数、汉字的种类数、要选择 $m$ 次。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个汉字的编码 $a_i$。\n\n接下来 $m$ 行每行两个整数 $L$ 和 $R$，设上一个询问的答案为 $ans$（第一个询问时 $ans=0$），令 $l=((L+ans)\\bmod n)+1$，$r=((R+ans)\\bmod n)+1$，若 $l>r$，交换 $l$ 和 $r$，则本次询问为 $[l,r]$。", "outputFormat": "输出共 $m$ 行，每行一个整数，第 $i$ 个数表示 SHY 第 $i$ 次能选出的汉字的最多种类数。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1\\le n,c,m\\le 10^5$，$1 \\leq a_i \\leq c$，$1 \\leq l,r \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P4136", "type": "P", "difficulty": 4, "samples": [["2\n0", "Alice"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "博弈论", "位运算"], "title": "谁能赢呢？", "background": "", "description": "小明和小红经常玩一个博弈游戏。给定一个 $n\\times n$ 的棋盘，一个石头被放在棋盘的左上角。他们轮流移动石头。每一回合，选手只能把石头向上，下，左，右四个方向移动一格，并且要求移动到的格子之前不能被访问过。谁不能移动石头了就算输。\n\n假如小明先移动石头，而且两个选手都以最优策略走步，问最后谁能赢？\n", "inputFormat": "输入文件有多组数据。\n\n输入第一行包含一个整数 $n$，表示棋盘的规模。\n\n当输入 $n$ 为 $0$ 时，表示输入结束。", "outputFormat": "对于每组数据，如果小明最后能赢，则输出 `Alice`，否则输出 `Bob`，每一组答案独占一行。", "hint": "对于 $20\\%$ 的数据，保证 $1\\le n\\le 10$；\n\n对于 $40\\%$ 的数据，保证 $1\\le n\\le 1000$；\n\n对于 $100\\%$ 数据，保证 $1\\le n\\le 10000$。", "locale": "zh-CN", "translations": {"en": {"title": "Who Will Win?", "background": "", "description": "Xiao Ming and Xiao Hong often play a game. Given an $n \\times n$ board, a stone is placed at the upper-left corner. They take turns moving the stone. On each turn, a player may move the stone exactly one cell in one of the four directions: up, down, left, or right, and the destination cell must not have been visited before. The player who cannot move loses.\n\nIf Xiao Ming moves first and both players play optimally, who will win?", "inputFormat": "There are multiple test cases.\n\nEach test case consists of a single integer $n$, the size of the board, on its own line.\n\nInput ends when $n = 0$.", "outputFormat": "For each test case, if Xiao Ming eventually wins, output `Alice`; otherwise output `Bob`. Print one answer per line.", "hint": "- For $20\\%$ of the testdata, $1 \\le n \\le 10$.\n- For $40\\%$ of the testdata, $1 \\le n \\le 1000$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "谁能赢呢？", "background": "", "description": "小明和小红经常玩一个博弈游戏。给定一个 $n\\times n$ 的棋盘，一个石头被放在棋盘的左上角。他们轮流移动石头。每一回合，选手只能把石头向上，下，左，右四个方向移动一格，并且要求移动到的格子之前不能被访问过。谁不能移动石头了就算输。\n\n假如小明先移动石头，而且两个选手都以最优策略走步，问最后谁能赢？\n", "inputFormat": "输入文件有多组数据。\n\n输入第一行包含一个整数 $n$，表示棋盘的规模。\n\n当输入 $n$ 为 $0$ 时，表示输入结束。", "outputFormat": "对于每组数据，如果小明最后能赢，则输出 `Alice`，否则输出 `Bob`，每一组答案独占一行。", "hint": "对于 $20\\%$ 的数据，保证 $1\\le n\\le 10$；\n\n对于 $40\\%$ 的数据，保证 $1\\le n\\le 1000$；\n\n对于 $100\\%$ 数据，保证 $1\\le n\\le 10000$。", "locale": "zh-CN"}}}
{"pid": "P4137", "type": "P", "difficulty": 5, "samples": [["5 5\n2 1 0 2 1\n3 3\n2 3\n2 4\n1 2\n3 5", "1\n2\n3\n0\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["莫队", "线段树", "可持久化", "分块", "CTT（清华集训/北大集训）"], "title": "Rmq Problem / mex", "background": "", "description": "有一个长度为 $n$ 的数组 $\\{a_1,a_2,\\ldots,a_n\\}$。\n\n$m$ 次询问，每次询问一个区间内最小没有出现过的自然数。", "inputFormat": "第一行，两个正整数 $n,m$。  \n第二行，$n$ 个非负整数 $a_1, a_2, \\ldots , a_n$。  \n接下来 $m$ 行，每行两个正整数 $l,r$，表示一次询问。", "outputFormat": "输出 $m$ 行，每行一个数，依次表示每个询问的答案。", "hint": "对于 $30\\%$ 的数据：$1\\leq n,m\\leq 1000$。  \n对于 $100\\%$ 的数据：$1\\leq n,m\\leq 2\\times {10}^5$，$1\\leq l\\leq r\\leq n$，$0\\leq a_i\\leq 2\\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Rmq Problem / mex", "background": "", "description": "There is an array $\\{a_1,a_2,\\ldots,a_n\\}$ of length $n$.\n\nThere are $m$ queries; for each query, find the smallest non-negative integer that does not appear in the interval (mex).", "inputFormat": "The first line contains two positive integers $n,m$.  \nThe second line contains $n$ non-negative integers $a_1, a_2, \\ldots , a_n$.  \nThen follow $m$ lines, each containing two positive integers $l,r$, representing a query.", "outputFormat": "Output $m$ lines, one number per line, giving the answer to each query in order.", "hint": "For $30\\%$ of the testdata: $1\\leq n,m\\leq 1000$.  \nFor $100\\%$ of the testdata: $1\\leq n,m\\leq 2\\times {10}^5$, $1\\leq l\\leq r\\leq n$, $0\\leq a_i\\leq 2\\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Rmq Problem / mex", "background": "", "description": "有一个长度为 $n$ 的数组 $\\{a_1,a_2,\\ldots,a_n\\}$。\n\n$m$ 次询问，每次询问一个区间内最小没有出现过的自然数。", "inputFormat": "第一行，两个正整数 $n,m$。  \n第二行，$n$ 个非负整数 $a_1, a_2, \\ldots , a_n$。  \n接下来 $m$ 行，每行两个正整数 $l,r$，表示一次询问。", "outputFormat": "输出 $m$ 行，每行一个数，依次表示每个询问的答案。", "hint": "对于 $30\\%$ 的数据：$1\\leq n,m\\leq 1000$。  \n对于 $100\\%$ 的数据：$1\\leq n,m\\leq 2\\times {10}^5$，$1\\leq l\\leq r\\leq n$，$0\\leq a_i\\leq 2\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4138", "type": "P", "difficulty": 4, "samples": [["5\n0 4\n2 -2\n1 -1\n0 1\n0 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2014", "剪枝", "背包 DP", "JOISC/JOIST（日本）"], "title": "[JOISC 2014] 挂饰 / Straps", "background": null, "description": "JOI 君有 $N$ 个装在手机上的挂饰，编号为 $1,2,\\cdots,N$。JOI 君可以将其中的一些装在手机上。\n\nJOI 君的挂饰有一些与众不同——其中的一些挂饰附有可以挂其他挂件的挂钩。每个挂件要么直接挂在手机上，要么挂在其他挂件的挂钩上。直接挂在手机上的挂件最多有 $1$ 个。\n\n此外，每个挂件有一个安装时会获得的喜悦值，用一个整数来表示。如果 JOI 君很讨厌某个挂饰，那么这个挂饰的喜悦值就是一个负数。\n\nJOI 君想要最大化所有挂饰的喜悦值之和。注意不必要将所有的挂钩都挂上挂饰，而且一个都不挂也是可以的。", "inputFormat": "第一行一个整数 $N$，代表挂饰的个数。\n\n接下来 $N$ 行，第 $i$ 行 $(1\\le i\\le N)$ 有两个空格分隔的整数 $A_i$ 和 $B_i$，表示挂饰 $i$ 有 $A_i$ 个挂钩，安装后会获得 $B_i$ 的喜悦值。", "outputFormat": "输出一行一个整数，表示手机上连接的挂饰总和的最大值。", "hint": "$1\\leq N\\leq 2000$。\n\n$0\\leq A_i\\leq N(1\\leq i\\leq N)$。\n\n$-10^6\\leq B_i\\leq 10^6(1\\leq i\\leq N)$。", "locale": "zh-CN", "translations": {"en": {"title": "[JOISC 2014] Straps", "background": "", "description": "JOI-kun has $N$ ornaments, numbered $1, 2, \\cdots, N$. He can attach some of them to his phone.\nSome ornaments are special—they have hooks that can hold other ornaments. Each ornament is either attached directly to the phone or to a hook of another ornament. At most one ornament can be attached directly to the phone.\nEach ornament has an integer joy value gained when it is installed. If JOI-kun dislikes an ornament, its joy value is negative.\nJOI-kun wants to maximize the sum of the joy values of all ornaments connected to the phone. It is not necessary to use all hooks, and attaching none is also allowed.", "inputFormat": "The first line contains an integer $N$, the number of ornaments.\nThe next $N$ lines, the $i$-th line ($1 \\le i \\le N$), contain two space-separated integers $A_i$ and $B_i$, meaning ornament $i$ has $A_i$ hooks and yields joy $B_i$ when installed.", "outputFormat": "Output a single integer, the maximum total joy value of the ornaments connected to the phone.", "hint": "- $1 \\leq N \\leq 2000$.\n- $0 \\leq A_i \\leq N$ ($1 \\leq i \\leq N$).\n- $-10^6 \\leq B_i \\leq 10^6$ ($1 \\leq i \\leq N$).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JOISC 2014] 挂饰 / Straps", "background": null, "description": "JOI 君有 $N$ 个装在手机上的挂饰，编号为 $1,2,\\cdots,N$。JOI 君可以将其中的一些装在手机上。\n\nJOI 君的挂饰有一些与众不同——其中的一些挂饰附有可以挂其他挂件的挂钩。每个挂件要么直接挂在手机上，要么挂在其他挂件的挂钩上。直接挂在手机上的挂件最多有 $1$ 个。\n\n此外，每个挂件有一个安装时会获得的喜悦值，用一个整数来表示。如果 JOI 君很讨厌某个挂饰，那么这个挂饰的喜悦值就是一个负数。\n\nJOI 君想要最大化所有挂饰的喜悦值之和。注意不必要将所有的挂钩都挂上挂饰，而且一个都不挂也是可以的。", "inputFormat": "第一行一个整数 $N$，代表挂饰的个数。\n\n接下来 $N$ 行，第 $i$ 行 $(1\\le i\\le N)$ 有两个空格分隔的整数 $A_i$ 和 $B_i$，表示挂饰 $i$ 有 $A_i$ 个挂钩，安装后会获得 $B_i$ 的喜悦值。", "outputFormat": "输出一行一个整数，表示手机上连接的挂饰总和的最大值。", "hint": "$1\\leq N\\leq 2000$。\n\n$0\\leq A_i\\leq N(1\\leq i\\leq N)$。\n\n$-10^6\\leq B_i\\leq 10^6(1\\leq i\\leq N)$。", "locale": "zh-CN"}}}
{"pid": "P4139", "type": "P", "difficulty": 5, "samples": [["3\n2\n3\n6", "0\n1\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "递归", "数论", "欧拉函数"], "title": "上帝与集合的正确用法", "background": null, "description": "根据一些书上的记载，上帝的一次失败的创世经历是这样的：\n\n第一天，上帝创造了一个世界的基本元素，称做元。\n\n第二天，上帝创造了一个新的元素，称作 $\\alpha$ 。 $\\alpha$ 被定义为元构成的集合。容易发现，一共有两种不同的 $\\alpha$ 。\n\n第三天，上帝又创造了一个新的元素，称作 $\\beta$ 。 $\\beta$ 被定义为 $\\alpha$ 构成的集合。容易发现，一共有四种不同的 $\\beta$。\n\n第四天，上帝创造了新的元素 $\\gamma$，$\\gamma$ 被定义为 $\\beta$ 的集合。显然，一共会有 $16$ 种不同的 $\\gamma$。\n\n如果按照这样下去，上帝创造的第五种元素将会有 $65536$ 种，第六种元素将会有 $2^{65536}$种。这将会是一个天文数字。\n\n然而，上帝并没有预料到元素种类数的增长是如此的迅速。他想要让世界的元素丰富起来，因此，日复一日，年复一年，他重复地创造着新的元素……\n\n然而不久，当上帝创造出最后一种元素 $\\theta$ 时，他发现这世界的元素实在是太多了，以致于世界的容量不足，无法承受。因此在这一天，上帝毁灭了世界。\n\n至今，上帝仍记得那次失败的创世经历，现在他想问问你，他最后一次创造的元素 $\\theta$ 一共有多少种？\n\n上帝觉得这个数字可能过于巨大而无法表示出来，因此你只需要回答这个数对 $p$ 取模后的值即可。\n\n你可以认为上帝从 $\\alpha$ 到 $\\theta$ 一共创造了 $10^9$ 次元素，或 $10^{18}$ 次，或者干脆 $\\infty$ 次。\n\n一句话题意：\n\n定义 $a_0=1,a_n=2^{a_{n-1}}$，可以证明 $b_n=a_n\\bmod p$ 在某一项后都是同一个值，求这个值。", "inputFormat": "第一行一个整数 $T$，表示数据个数。\n\n接下来 $T$ 行，每行一个正整数 $p$，代表你需要取模的值。", "outputFormat": "$T$ 行，每行一个正整数，为答案对 $p$ 取模后的值。", "hint": "对于 $100\\%$ 的数据，$T\\le 10^3$，$p\\le10^7$。", "locale": "zh-CN", "translations": {"en": {"title": "God and the Correct Use of Sets", "background": "", "description": "According to some books, one of God’s failed attempts at creation went like this:\n\nOn the first day, God created a basic element of the world, called \"yuan\" (pinyin).\n\nOn the second day, God created a new element, called $\\alpha$. $\\alpha$ is defined as a set composed of \"yuan\". It is easy to see that there are exactly two distinct $\\alpha$.\n\nOn the third day, God created another new element, called $\\beta$. $\\beta$ is defined as a set composed of $\\alpha$. It is easy to see that there are four distinct $\\beta$.\n\nOn the fourth day, God created a new element, $\\gamma$. $\\gamma$ is defined as a set of $\\beta$. Clearly, there are $16$ distinct $\\gamma$.\n\nIf this continues, the fifth kind of element will have $65536$ types, and the sixth kind will have $2^{65536}$ types. This will be an astronomical number.\n\nHowever, God did not anticipate how fast the number of element types would grow. He wanted to enrich the world’s elements, so day after day, year after year, he kept creating new elements…\n\nNot long after, when God created the last kind of element $\\theta$, he found that there were so many elements that the world’s capacity was insufficient to bear them. So that day, God destroyed the world.\n\nTo this day, God still remembers that failed act of creation. Now he wants to ask you: how many distinct elements of type $\\theta$ are there?\n\nGod thinks this number may be too huge to represent, so you only need to report it modulo $p$.\n\nYou may assume that from $\\alpha$ to $\\theta$, God created elements for $10^9$ steps, or $10^{18}$ steps, or simply $\\infty$ steps.\n\nIn short:\n\nDefine $a_0=1,a_n=2^{a_{n-1}}$. It can be proved that $b_n=a_n\\bmod p$ becomes constant after some index; find that value.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nEach of the next $T$ lines contains one positive integer $p$, the modulus.", "outputFormat": "Output $T$ lines, each containing one positive integer, which is the answer modulo $p$.", "hint": "For $100\\%$ of the testdata, $T\\le 10^3$, $p\\le 10^7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "上帝与集合的正确用法", "background": null, "description": "根据一些书上的记载，上帝的一次失败的创世经历是这样的：\n\n第一天，上帝创造了一个世界的基本元素，称做元。\n\n第二天，上帝创造了一个新的元素，称作 $\\alpha$ 。 $\\alpha$ 被定义为元构成的集合。容易发现，一共有两种不同的 $\\alpha$ 。\n\n第三天，上帝又创造了一个新的元素，称作 $\\beta$ 。 $\\beta$ 被定义为 $\\alpha$ 构成的集合。容易发现，一共有四种不同的 $\\beta$。\n\n第四天，上帝创造了新的元素 $\\gamma$，$\\gamma$ 被定义为 $\\beta$ 的集合。显然，一共会有 $16$ 种不同的 $\\gamma$。\n\n如果按照这样下去，上帝创造的第五种元素将会有 $65536$ 种，第六种元素将会有 $2^{65536}$种。这将会是一个天文数字。\n\n然而，上帝并没有预料到元素种类数的增长是如此的迅速。他想要让世界的元素丰富起来，因此，日复一日，年复一年，他重复地创造着新的元素……\n\n然而不久，当上帝创造出最后一种元素 $\\theta$ 时，他发现这世界的元素实在是太多了，以致于世界的容量不足，无法承受。因此在这一天，上帝毁灭了世界。\n\n至今，上帝仍记得那次失败的创世经历，现在他想问问你，他最后一次创造的元素 $\\theta$ 一共有多少种？\n\n上帝觉得这个数字可能过于巨大而无法表示出来，因此你只需要回答这个数对 $p$ 取模后的值即可。\n\n你可以认为上帝从 $\\alpha$ 到 $\\theta$ 一共创造了 $10^9$ 次元素，或 $10^{18}$ 次，或者干脆 $\\infty$ 次。\n\n一句话题意：\n\n定义 $a_0=1,a_n=2^{a_{n-1}}$，可以证明 $b_n=a_n\\bmod p$ 在某一项后都是同一个值，求这个值。", "inputFormat": "第一行一个整数 $T$，表示数据个数。\n\n接下来 $T$ 行，每行一个正整数 $p$，代表你需要取模的值。", "outputFormat": "$T$ 行，每行一个正整数，为答案对 $p$ 取模后的值。", "hint": "对于 $100\\%$ 的数据，$T\\le 10^3$，$p\\le10^7$。", "locale": "zh-CN"}}}
{"pid": "P4140", "type": "P", "difficulty": 5, "samples": [["6\n0 1 3\n1 1 5\n0 1 3\n1 1 7\n0 1 3\n0 2 3", "18\n24\n36\n6\n\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2014", "线段树", "树状数组", "素数判断,质数,筛法", "逆元", "CTT（清华集训/北大集训）"], "title": "[清华集训 2014] 奇数国", "background": null, "description": "在一片美丽的大陆上有 $100\\,000$ 个国家，记为 $1$ 到 $100\\,000$。这里经济发达，有数不尽的账房，并且每个国家有一个银行。\n\n某大公司的领袖在这 $100\\,000$ 个银行开户时都存了 $3$ 大洋，他惜财如命，因此会不时地派小弟 GFS 清点一些银行的存款或者让 GFS 改变某个银行的存款。\n\n该村子在财产上的求和运算等同于我们的乘法运算，也就是说领袖开户时的存款总和为 $3^{100000}$。这里发行的软妹面额是最小的 $60$ 个素数（$p_1=2,p_2=3,\\ldots, p_{60}=281$），任何人的财产都只能由这 $60$ 个基本面额表示，即设某个人的财产为 $fortune$（正整数），则 $fortune=p_1^{k_1} \\times p_2^{k_2} \\times \\ldots p_{60}^{k_{60}}$。\n\n领袖习惯将一段编号连续的银行里的存款拿到一个账房去清点，为了避免 GFS 串通账房叛变，所以他不会每次都选择同一个账房。GFS 跟随领袖多年已经摸清了门路,知道领袖选择账房的方式。如果领袖选择清点编号在 $[a,b]$ 内的银行财产，他会先对 $[a,b]$ 的财产求和（记为 $product$），然后在编号属于 $[1,product]$ 的账房中选择一个去清点存款，检验自己计算是否正确同时也检验账房与 GFS 是否有勾结。GFS 发现如果某个账房的编号 $number$ 与 $product$ 相冲，领袖绝对不会选择这个账房。\n\n怎样才算与 $product$ 不相冲呢？若存在整数 $x,y$ 使得 $number \\times x+product \\times y=1$，那么我们称 $number$ 与 $product$ 不相冲，即该账房有可能被领袖相中。当领袖又赚大钱了的时候，他会在某个银行改变存款，这样一来相同区间的银行在不同的时候算出来的 $product$ 可能是不一样的，而且领袖不会在某个银行的存款总数超过 $10^6$。\n\n现在 GFS 预先知道了领袖的清点存款与变动存款的计划，想请你告诉他，每次清点存款时领袖有多少个账房可以供他选择，当然这个值可能非常大，GFS 只想知道对 $19\\,961\\,993$ 取模后的答案。", "inputFormat": "第一行一个整数 $x$ 表示领袖清点和变动存款的总次数。\n\n接下来 $x$ 行，每行 $3$ 个整数 $a_i,b_i,c_i$。$a_i$ 为 $0$ 时表示该条记录是清点计划，领袖会清点 $b_i$ 到 $c_i$ 的银行存款，你需要对该条记录计算出 GFS 想要的答案。$a_i$ 为 $1$ 时表示该条记录是存款变动，你要把银行 $b_i$ 的存款改为 $c_i$，不需要对该记录进行计算。", "outputFormat": "对于每个询问，输出一行一个整数表示答案。", "hint": "### 样例解释\n\n- 初始化每个国家存款都为 $3$；\n- $1$ 到 $3$ 的 $product$ 为 $27$，$[1,27]$ 与 $27$ 不相冲的有 $18$ 个数；\n- $1$ 的存款变为 $5$；\n- $1$ 到 $3$ 的 $product$ 为 $45$，$[1,45]$ 与 $45$ 不相冲的有 $24$ 个数；\n- $1$ 的存款变为 $7$；\n- $1$ 到 $3$ 的 $product$ 为 $63$，$[1,63]$ 与 $63$ 不相冲的有 $36$个数；\n- $2$ 到 $3$ 的 $product$ 为 $9$，$[1,9]$ 与 $9$ 不相冲的有 $6$ 个数。\n\n### 数据范围\n\n所有数据均满足：$x \\geq 1$，$c_i -b_i \\geq 0$。\n\n| 子任务编号 | 分值 |    $x \\leq$     | $c_i - b_i \\leq$ | 特殊性质 |\n| :--------: | :--: | :-------------: | :--------------: | :------: |\n|    $1$     | $20$ |     $10^4$      |      $100$       |    有    |\n|    $2$     | $30$ | $5 \\times 10^4$ |      $10^4$      |    无    |\n|    $3$     | $50$ |     $10^5$      |      $10^5$      |    无    |\n\n特殊性质指：所有 $product \\leq 10^{18}$。", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training Camp 2014] Odd Country", "background": "", "description": "On a beautiful continent there are $100\\,000$ countries, numbered from $1$ to $100\\,000$. The economy is prosperous, there are countless accounting offices, and each country has one bank.\n\nWhen a big company's leader opened accounts in these $100\\,000$ banks, he deposited $3$ coins in each. He is very stingy, so he will from time to time send his lackey GFS to tally deposits in some banks or ask GFS to change the deposit of a certain bank.\n\nIn this land, the summation operation on wealth corresponds to our multiplication. That is, the total deposit when the leader opened accounts is $3^{100000}$. The banknote denominations issued here are the smallest $60$ primes ($p_1=2, p_2=3, \\ldots, p_{60}=281$). Anyone’s wealth can only be represented using these $60$ basic denominations. Suppose a person’s wealth is $fortune$ (a positive integer), then $fortune = p_1^{k_1} \\times p_2^{k_2} \\times \\ldots p_{60}^{k_{60}}$.\n\nThe leader tends to take deposits from a consecutive range of banks to one accounting office to tally. To avoid GFS colluding with an accounting office, he will not choose the same accounting office every time. After following the leader for many years, GFS has figured out the rule: if the leader chooses to tally the wealth of banks numbered in $[a,b]$, he will first “sum” (i.e., multiply) the wealth over $[a,b]$ (denoted as $product$), and then pick an accounting office whose number is in $[1, product]$ to tally the deposits, both to verify his own computation and to check whether the accounting office and GFS are colluding. GFS noticed that if an accounting office’s number $number$ is in conflict with $product$, the leader will never choose that office.\n\nWhat does it mean to be not in conflict with $product$? If there exist integers $x, y$ such that $number \\times x + product \\times y = 1$, then we say $number$ is not in conflict with $product$, i.e., that accounting office may be chosen by the leader. When the leader makes a lot more money, he will change the deposit in some bank; thus the $product$ computed for the same interval at different times may differ. Moreover, the leader will not let the deposit in any single bank exceed $10^6$.\n\nNow that GFS knows in advance the leader’s plan for tallying and changing deposits, he wants you to tell him, for each tally, how many accounting offices the leader can choose from. Since this number can be very large, GFS only wants the answer modulo $19\\,961\\,993$.", "inputFormat": "The first line contains an integer $x$ denoting the total number of tally and update operations.\n\nThen follow $x$ lines, each with $3$ integers $a_i, b_i, c_i$. If $a_i = 0$, this record is a tally plan: the leader will tally deposits of banks from $b_i$ to $c_i$, and you need to compute the answer GFS wants for this record. If $a_i = 1$, this record is an update: you should change the deposit of bank $b_i$ to $c_i$, and you do not need to output anything for this record.", "outputFormat": "For each query, output a single integer per line denoting the answer.", "hint": "### Sample Explanation\n\n- Initially, each country’s deposit is $3$.\n- The $product$ for $1$ to $3$ is $27$. In $[1,27]$, there are $18$ numbers not in conflict with $27$.\n- The deposit of $1$ becomes $5$.\n- The $product$ for $1$ to $3$ is $45$. In $[1,45]$, there are $24$ numbers not in conflict with $45$.\n- The deposit of $1$ becomes $7$.\n- The $product$ for $1$ to $3$ is $63$. In $[1,63]$, there are $36$ numbers not in conflict with $63$.\n- The $product$ for $2$ to $3$ is $9$. In $[1,9]$, there are $6$ numbers not in conflict with $9$.\n\n### Constraints\n\nAll testdata satisfy: $x \\geq 1$, $c_i - b_i \\geq 0$.\n\n| Subtask ID | Score |    $x \\leq$     | $c_i - b_i \\leq$ | Special Property |\n| :--------: | :---: | :-------------: | :--------------: | :--------------: |\n|    $1$     |  $20$ |     $10^4$      |       $100$      |       Yes        |\n|    $2$     |  $30$ | $5 \\times 10^4$ |      $10^4$      |        No        |\n|    $3$     |  $50$ |     $10^5$      |      $10^5$      |        No        |\n\nSpecial property means: all $product \\leq 10^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2014] 奇数国", "background": null, "description": "在一片美丽的大陆上有 $100\\,000$ 个国家，记为 $1$ 到 $100\\,000$。这里经济发达，有数不尽的账房，并且每个国家有一个银行。\n\n某大公司的领袖在这 $100\\,000$ 个银行开户时都存了 $3$ 大洋，他惜财如命，因此会不时地派小弟 GFS 清点一些银行的存款或者让 GFS 改变某个银行的存款。\n\n该村子在财产上的求和运算等同于我们的乘法运算，也就是说领袖开户时的存款总和为 $3^{100000}$。这里发行的软妹面额是最小的 $60$ 个素数（$p_1=2,p_2=3,\\ldots, p_{60}=281$），任何人的财产都只能由这 $60$ 个基本面额表示，即设某个人的财产为 $fortune$（正整数），则 $fortune=p_1^{k_1} \\times p_2^{k_2} \\times \\ldots p_{60}^{k_{60}}$。\n\n领袖习惯将一段编号连续的银行里的存款拿到一个账房去清点，为了避免 GFS 串通账房叛变，所以他不会每次都选择同一个账房。GFS 跟随领袖多年已经摸清了门路,知道领袖选择账房的方式。如果领袖选择清点编号在 $[a,b]$ 内的银行财产，他会先对 $[a,b]$ 的财产求和（记为 $product$），然后在编号属于 $[1,product]$ 的账房中选择一个去清点存款，检验自己计算是否正确同时也检验账房与 GFS 是否有勾结。GFS 发现如果某个账房的编号 $number$ 与 $product$ 相冲，领袖绝对不会选择这个账房。\n\n怎样才算与 $product$ 不相冲呢？若存在整数 $x,y$ 使得 $number \\times x+product \\times y=1$，那么我们称 $number$ 与 $product$ 不相冲，即该账房有可能被领袖相中。当领袖又赚大钱了的时候，他会在某个银行改变存款，这样一来相同区间的银行在不同的时候算出来的 $product$ 可能是不一样的，而且领袖不会在某个银行的存款总数超过 $10^6$。\n\n现在 GFS 预先知道了领袖的清点存款与变动存款的计划，想请你告诉他，每次清点存款时领袖有多少个账房可以供他选择，当然这个值可能非常大，GFS 只想知道对 $19\\,961\\,993$ 取模后的答案。", "inputFormat": "第一行一个整数 $x$ 表示领袖清点和变动存款的总次数。\n\n接下来 $x$ 行，每行 $3$ 个整数 $a_i,b_i,c_i$。$a_i$ 为 $0$ 时表示该条记录是清点计划，领袖会清点 $b_i$ 到 $c_i$ 的银行存款，你需要对该条记录计算出 GFS 想要的答案。$a_i$ 为 $1$ 时表示该条记录是存款变动，你要把银行 $b_i$ 的存款改为 $c_i$，不需要对该记录进行计算。", "outputFormat": "对于每个询问，输出一行一个整数表示答案。", "hint": "### 样例解释\n\n- 初始化每个国家存款都为 $3$；\n- $1$ 到 $3$ 的 $product$ 为 $27$，$[1,27]$ 与 $27$ 不相冲的有 $18$ 个数；\n- $1$ 的存款变为 $5$；\n- $1$ 到 $3$ 的 $product$ 为 $45$，$[1,45]$ 与 $45$ 不相冲的有 $24$ 个数；\n- $1$ 的存款变为 $7$；\n- $1$ 到 $3$ 的 $product$ 为 $63$，$[1,63]$ 与 $63$ 不相冲的有 $36$个数；\n- $2$ 到 $3$ 的 $product$ 为 $9$，$[1,9]$ 与 $9$ 不相冲的有 $6$ 个数。\n\n### 数据范围\n\n所有数据均满足：$x \\geq 1$，$c_i -b_i \\geq 0$。\n\n| 子任务编号 | 分值 |    $x \\leq$     | $c_i - b_i \\leq$ | 特殊性质 |\n| :--------: | :--: | :-------------: | :--------------: | :------: |\n|    $1$     | $20$ |     $10^4$      |      $100$       |    有    |\n|    $2$     | $30$ | $5 \\times 10^4$ |      $10^4$      |    无    |\n|    $3$     | $50$ |     $10^5$      |      $10^5$      |    无    |\n\n特殊性质指：所有 $product \\leq 10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P4141", "type": "P", "difficulty": 3, "samples": [["3 2\n1 1 2", "11\n11\n21"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "递推", "枚举", "分治", "背包 DP"], "title": "消失之物", "background": "", "description": "ftiasch 有 $n$ 个物品, 体积分别是 $w_1,w_2,\\dots,w_n$。由于她的疏忽，第 $i$ 个物品丢失了。   \n\n“要使用剩下的 $n-1$ 物品装满容积为 $x$ 的背包，有几种方法呢？”——这是经典的问题了。  \n\n她把答案记为 $\\text{cnt}(i,x)$ ，想要得到所有$i \\in [1,n]$, $x \\in [1,m]$ 的 $\\text{cnt}(i,x)$ 表格。\n\n![](https://cdn.luogu.com.cn/upload/pic/13426.png)", "inputFormat": "第一行两个整数 $n,m$，表示物品的数量和最大的容积。\n第二行 $n$ 个整数 $w_1,w_2,\\dots,w_n$，表示每个物品的体积。", "outputFormat": "输出一个 $n \\times m$ 的矩阵，表示 $\\text{cnt}(i,x)$ 的**末位数字**。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n,m \\le 2000$，且 $1\\le w_i\\le 2000$。\n\n【样例解释】  \n如果物品 3 丢失的话，只有一种方法装满容量是 2 的背包，即选择物品 1 和物品 2。\n\n---\n\n$\\text{upd 2023.8.11}$：新增加五组 Hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "The Missing Item", "background": "", "description": "ftiasch has $n$ items with volumes $w_1,w_2,\\dots,w_n$. Due to her negligence, the $i$-th item is missing.\n\n“How many ways are there to exactly fill a knapsack of capacity $x$ using the remaining $n-1$ items?” — this is a classic problem.\n\nShe records the answer as $\\text{cnt}(i,x)$ and wants the table of $\\text{cnt}(i,x)$ for all $i \\in [1,n]$ and $x \\in [1,m]$.\n\n![](https://cdn.luogu.com.cn/upload/pic/13426.png)", "inputFormat": "The first line contains two integers $n,m$, the number of items and the maximum capacity.  \nThe second line contains $n$ integers $w_1,w_2,\\dots,w_n$, the volume of each item.", "outputFormat": "Output an $n \\times m$ matrix, giving the last digit of $\\text{cnt}(i,x)$.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n,m \\le 2000$, and $1 \\le w_i \\le 2000$.\n\nSample explanation  \nIf item $3$ is missing, there is exactly one way to fill capacity $2$, namely choosing items $1$ and $2$.\n\n—  \n$\\text{upd 2023.8.11}$: Added five new hack test sets.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "消失之物", "background": "", "description": "ftiasch 有 $n$ 个物品, 体积分别是 $w_1,w_2,\\dots,w_n$。由于她的疏忽，第 $i$ 个物品丢失了。   \n\n“要使用剩下的 $n-1$ 物品装满容积为 $x$ 的背包，有几种方法呢？”——这是经典的问题了。  \n\n她把答案记为 $\\text{cnt}(i,x)$ ，想要得到所有$i \\in [1,n]$, $x \\in [1,m]$ 的 $\\text{cnt}(i,x)$ 表格。\n\n![](https://cdn.luogu.com.cn/upload/pic/13426.png)", "inputFormat": "第一行两个整数 $n,m$，表示物品的数量和最大的容积。\n第二行 $n$ 个整数 $w_1,w_2,\\dots,w_n$，表示每个物品的体积。", "outputFormat": "输出一个 $n \\times m$ 的矩阵，表示 $\\text{cnt}(i,x)$ 的**末位数字**。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n,m \\le 2000$，且 $1\\le w_i\\le 2000$。\n\n【样例解释】  \n如果物品 3 丢失的话，只有一种方法装满容量是 2 的背包，即选择物品 1 和物品 2。\n\n---\n\n$\\text{upd 2023.8.11}$：新增加五组 Hack 数据。", "locale": "zh-CN"}}}
{"pid": "P4142", "type": "P", "difficulty": 6, "samples": [["3 3 1\n0 1 0\n2 0 1\n0 1 0\n1 3", "3"], ["3 3 4\n0 2 0\n0 0 4\n0 3 0\n1 3\n2 1\n2 2\n3 1", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论建模", "构造"], "title": "洞穴遇险", "background": "**ZRQ**在洞穴中准备采集矿物的时候遇险了！洞穴**要塌了**！\n\n题目来源：[zhoutb2333](https://www.luogu.org/space/show?uid=31564)\n", "description": "整个洞穴是一个$N*N$的方格图，每个格子形如$(X,Y),1 \\le X,Y \\le N$。其中$X$表示从上到下的行数，$Y$表示从左到右的列数。$(1,1)$在左上角,$(1,N)$在右上角，$(N,1)$在左下角，$(N,N)$在右下角。\n\n\n满足$X+Y$为奇数格子的有一个不稳定度$V_{X,Y},X+Y$为偶数的格子的不稳定度为$0$。\n\n\n**ZRQ**现在手里恰巧有$M$个可以支撑洞穴的柱子，柱子的力量可以认为是无穷大。\n\n\n只要支撑住了一个格子那么这个格子的不稳定度将降为$0$。\n\n\n每个柱子是$L$型的，它除了要占据当前的格子外，还需要占据两个相邻的格子（这三个格子形成$L$型,可以选择任意方向放置，一共有$4$个方向）。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/13049.png) \n\n**柱子占据相邻的格子不会降低其不稳定度（换句话说就是柱子只有在拐角处有力量）**。\n\n\n有些格子的顶已经塌下来了，无法在其位置放置柱子了，这些格子也不能被占据了。这样已经塌了的格子有$K$个（他们的不稳定度都为$0$,**即使$X+Y$为奇数，塌下来的格子的不稳定度也会为$0$**）。\n\n\n**ZRQ**想问你，在放置一些柱子后 ，最小的不稳定度之和为多少（可以不将$M$个柱子都放完）。\n", "inputFormat": "第一行三个整数$N,M,K$\n\n\n接下来$N$行每行$N$个整数，表示每个格子的不稳定度，**保证$X+Y$为偶数的格子和已经塌下的格子的不稳定度为$0$**。\n\n\n接下来$K$行每行$2$个整数$X,Y$，表示已经塌下的格子的坐标。\n", "outputFormat": "一行一个整数，表示最小的不稳定度的和。\n", "hint": "共$10$个测试点，每个点$10$分，计$100$分。\n\n\n对于测试点$1$~$3$，有$1 \\le N \\le 6$\n\n\n对于测试点$4$~$7$，有$1 \\le N \\le 11$\n\n\n对于测试点$8$~$10$，有$1 \\le N \\le 50$\n\n\n对于所有测试点，$0 \\le M \\le \\frac{N^2}{3}, 0 \\le K \\le N^2, 0 \\le V_{X,Y} \\le 10^6$\n\n\n**样例#1解释：**\n\n显然无法让任意两个不稳定的格子都被拐角覆盖，于是将$(2,1)$用拐角覆盖住即可。这样剩余的不稳定度为$V_{1,2}+V_{2,3}+V_{3,2}=1+1+1=3$。\n\n**样例#2解释：**\n\n一个都放不下，这样剩余的不稳定度为$V_{1,2}+V_{2,3}+V_{3,2}=2+4+3=9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "{{Cave Emergency}}", "background": "{{When ZRQ was about to collect minerals in the cave, an accident happened. The cave is about to collapse!\n\nProblem source: [zhoutb2333](https://www.luogu.org/space/show?uid=31564).}}", "description": "{{The entire cave is an $N*N$ grid. Each cell is denoted as $(X, Y)$, where $1 \\le X, Y \\le N$. Here $X$ is the row index from top to bottom, and $Y$ is the column index from left to right. $(1,1)$ is the top-left corner, $(1,N)$ is the top-right corner, $(N,1)$ is the bottom-left corner, and $(N,N)$ is the bottom-right corner.\n\nCells with $X+Y$ odd have an instability $V_{X,Y}$, while cells with $X+Y$ even have instability $0$.\n\nZRQ happens to have $M$ pillars that can support the cave. The strength of each pillar can be regarded as infinite.\n\nAs long as a cell is supported, its instability becomes $0$.\n\nEach pillar is L-shaped: in addition to occupying its current cell (the corner), it must also occupy two adjacent cells so that the three cells form an L shape. You can place it in any of the $4$ orientations.\n\n![](https://cdn.luogu.com.cn/upload/pic/13049.png)\n\nOccupying adjacent cells with a pillar does not reduce their instability (in other words, a pillar only has force at its corner cell).\n\nSome cells have already collapsed, so you cannot place a pillar there, and these cells cannot be occupied either. There are $K$ such cells. Their instability is $0$ (even if $X+Y$ is odd, a collapsed cell’s instability is still $0$).\n\nZRQ asks: after placing some pillars (you do not have to use all $M$ pillars), what is the minimum possible sum of instabilities?}}", "inputFormat": "{{The first line contains three integers $N, M, K$.\n\nThe next $N$ lines each contain $N$ integers, representing the instability of each cell. It is guaranteed that cells with $X+Y$ even and collapsed cells have instability $0$.\n\nThe next $K$ lines each contain two integers $X, Y$, denoting the coordinates of the collapsed cells.}}", "outputFormat": "{{Output a single integer: the minimum possible sum of instabilities.}}", "hint": "{{There are $10$ test points, each worth $10$ points, for a total of $100$ points.\n\nConstraints:\n- For test points $1$–$3$: $1 \\le N \\le 6$.\n- For test points $4$–$7$: $1 \\le N \\le 11$.\n- For test points $8$–$10$: $1 \\le N \\le 50$.\n- For all test points: $0 \\le M \\le \\frac{N^2}{3}$, $0 \\le K \\le N^2$, $0 \\le V_{X,Y} \\le 10^6$.\n\nSample #1 explanation:\nIt is clearly impossible to have any two unstable cells both covered by a pillar’s corner. Therefore, just cover $(2,1)$ with a pillar’s corner. The remaining instability is $V_{1,2}+V_{2,3}+V_{3,2}=1+1+1=3$.\n\nSample #2 explanation:\nNone can be placed. The remaining instability is $V_{1,2}+V_{2,3}+V_{3,2}=2+4+3=9$.}}\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "洞穴遇险", "background": "**ZRQ**在洞穴中准备采集矿物的时候遇险了！洞穴**要塌了**！\n\n题目来源：[zhoutb2333](https://www.luogu.org/space/show?uid=31564)\n", "description": "整个洞穴是一个$N*N$的方格图，每个格子形如$(X,Y),1 \\le X,Y \\le N$。其中$X$表示从上到下的行数，$Y$表示从左到右的列数。$(1,1)$在左上角,$(1,N)$在右上角，$(N,1)$在左下角，$(N,N)$在右下角。\n\n\n满足$X+Y$为奇数格子的有一个不稳定度$V_{X,Y},X+Y$为偶数的格子的不稳定度为$0$。\n\n\n**ZRQ**现在手里恰巧有$M$个可以支撑洞穴的柱子，柱子的力量可以认为是无穷大。\n\n\n只要支撑住了一个格子那么这个格子的不稳定度将降为$0$。\n\n\n每个柱子是$L$型的，它除了要占据当前的格子外，还需要占据两个相邻的格子（这三个格子形成$L$型,可以选择任意方向放置，一共有$4$个方向）。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/13049.png) \n\n**柱子占据相邻的格子不会降低其不稳定度（换句话说就是柱子只有在拐角处有力量）**。\n\n\n有些格子的顶已经塌下来了，无法在其位置放置柱子了，这些格子也不能被占据了。这样已经塌了的格子有$K$个（他们的不稳定度都为$0$,**即使$X+Y$为奇数，塌下来的格子的不稳定度也会为$0$**）。\n\n\n**ZRQ**想问你，在放置一些柱子后 ，最小的不稳定度之和为多少（可以不将$M$个柱子都放完）。\n", "inputFormat": "第一行三个整数$N,M,K$\n\n\n接下来$N$行每行$N$个整数，表示每个格子的不稳定度，**保证$X+Y$为偶数的格子和已经塌下的格子的不稳定度为$0$**。\n\n\n接下来$K$行每行$2$个整数$X,Y$，表示已经塌下的格子的坐标。\n", "outputFormat": "一行一个整数，表示最小的不稳定度的和。\n", "hint": "共$10$个测试点，每个点$10$分，计$100$分。\n\n\n对于测试点$1$~$3$，有$1 \\le N \\le 6$\n\n\n对于测试点$4$~$7$，有$1 \\le N \\le 11$\n\n\n对于测试点$8$~$10$，有$1 \\le N \\le 50$\n\n\n对于所有测试点，$0 \\le M \\le \\frac{N^2}{3}, 0 \\le K \\le N^2, 0 \\le V_{X,Y} \\le 10^6$\n\n\n**样例#1解释：**\n\n显然无法让任意两个不稳定的格子都被拐角覆盖，于是将$(2,1)$用拐角覆盖住即可。这样剩余的不稳定度为$V_{1,2}+V_{2,3}+V_{3,2}=1+1+1=3$。\n\n**样例#2解释：**\n\n一个都放不下，这样剩余的不稳定度为$V_{1,2}+V_{2,3}+V_{3,2}=2+4+3=9$。\n", "locale": "zh-CN"}}}
{"pid": "P4143", "type": "P", "difficulty": 7, "samples": [["abcd\n10 0 1 1", "3\n1 1\n3 4\n4 4"], ["aaaa\n1 1 1 1", "0"], ["aaa\n1 1 1", "2\n1 2\n2 3"], ["aaa\n1 1 2", "1\n1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "线段树", "ST 表", "后缀数组 SA"], "title": "采集矿石", "background": "**ZRQ** 成功从坍塌的洞穴中逃了出来。终于，他看到了要研究的矿石。他想挑一些带回去完成任务。\n\n题目来源：[Zhang\\_RQ](https://www.luogu.org/space/show?uid=31565)~~哦对了 ZRQ 就他，嗯~~\n", "description": "**ZRQ** 发现这里有 $N$ 块排成一排的矿石。\n\n他用一个小写字母来表示每块矿石，他还发现每块矿石有一个重要度 $V_i$。\n\n**ZRQ** 想采集一段连续的矿石回研究所。\n\n他非常严格，被采集的一段矿石必须满足**小写字母的字典序降序排名等于这段矿石的重要度和。**\n\n**这里多个出现在不同位置的本质相同串的字典序排名相同。**\n\n比如说字母串为 `aa`，那么第一个 `a` 的排名和第二个 `a` 的排名相同，都是 `2`（第 `1` 是 `aa`）。\n\n**ZRQ** 问你，在原串中有哪些不同的子串可以被采集？\n\n**这里子串不同定义为出现位置不同，也就是说本质相同的子串出现在不同位置都要计算一次（当然重要度和等于排名是前提）。**\n\n比如共有 $4$ 块矿石，小写字母串为 `abcd`，重要度各为 `10 0 1 1`。\n\n我们把所有的子串按照字典序从大到小排名：`1:d 2:cd 3:c 4:bcd 5:bc 6:b 7:abcd 8:abc 9:ab 10:a`。\n\n那么串 `d` 的排名为 $1$（第一大），重要度和为 $1$，可以被采集。\n\n串 `cd` 的排名为 $2$，重要度和为 $2$，可以被采集。\n\n串 `a` 的排名为 $10$，重要度和为 $10$，可以被采集。\n\n其他串则不满足这个条件，故有三个串可以被采集。\n", "inputFormat": "第一行一个长度为 $N$ 由小写字母组成的字符串，每个字符代表一个矿石。\n\n\n第二行 $N$ 个整数，表示 $V_i$。\n", "outputFormat": "一行一个整数，表示能被采集的子串个数 $S$。\n\n\n接下来 $S$ 行每行两个整数 $L,R$，分别表示每个可采集子串的左端点与右端点，按照左端点升序为第一关键字，右端点升序为第二关键字排序。\n", "hint": "共 $10$ 个测试点，每个点 $10$ 分，计 $100$ 分。\n\n![pcg6nP.png](https://s1.ax1x.com/2018/01/19/pcg6nP.png)\n\n对于所有测试点，有 $N\\leq 10^5$，$0 \\le V_i \\le 1000$。保证每个点可被采集的子串不超过 $10^5$ 个。\n\n\n**样例#1解释**放在题面里了。\n\n**样例#2解释：**\n\n每个子串都不满足条件。\n\n串 `a` 的排名是 $4$，重要度和都是 $1$。\n\n串 `aa` 的排名是 $3$，重要度和都是 $2$。\n\n串 `aaa` 的排名是 $2$，重要度和都是 $3$。\n\n串 `aaaa` 的排名是 $1$，重要度和都是 $4$。\n\n**样例 #3解释：**\n\n串 `a` 的排名是 $3$，重要度和都是 $1$。\n\n串 `aa` 的排名是 $2$，重要度和都是 $2$，共有两个串`aa`，位置分别为 $1$~$2$ 和 $2$~$3$。\n\n串 `aaa` 的排名是 $1$，重要度和都是 $3$。\n\n**样例 #4解释：**\n\n可以发现，串 $2$~$3$（第二个 `aa`）不满足条件了。它的排名还是 $2$ 不变，但是重要度和为 $3$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Collecting Ores", "background": "ZRQ successfully escaped from the collapsed cave. At last, he saw the ores he needed to study. He wants to pick some to take back and complete the task.\n\nProblem source: [Zhang_RQ](https://www.luogu.org/space/show?uid=31565)~~Oh right, it is ZRQ, yeah~~.", "description": "ZRQ finds that there are $N$ ores arranged in a line.\n\nHe uses a lowercase letter to represent each ore, and he also finds that each ore has an importance value $V_i$.\n\nZRQ wants to collect a consecutive segment of ores and bring them back to the lab.\n\nHe is very strict: the collected segment must satisfy that the lexicographic rank in descending order of this substring among all substrings equals the sum of importance values of this segment.\n\nHere, multiple occurrences of substrings that are identical in content but appear at different positions share the same lexicographic rank.\n\nFor example, if the letter string is `aa`, then the rank of the first `a` and the second `a` is the same, both are `2` (the `1` is `aa`).\n\nZRQ asks you: which substrings in the original string can be collected?\n\nHere, substrings are considered different if their positions of occurrence are different, that is, identical substrings appearing at different positions are all counted separately (of course, only if the sum of importance equals the rank).\n\nFor example, there are $4$ ores, the lowercase letter string is `abcd`, and the importance values are `10 0 1 1`.\n\nWe rank all substrings in descending lexicographic order: `1:d 2:cd 3:c 4:bcd 5:bc 6:b 7:abcd 8:abc 9:ab 10:a`.\n\nThen the rank of `d` is $1$ (the largest), and its importance sum is $1$, so it can be collected.\n\nThe rank of `cd` is $2$, and its importance sum is $2$, so it can be collected.\n\nThe rank of `a` is $10$, and its importance sum is $10$, so it can be collected.\n\nOther substrings do not satisfy this condition, so there are three substrings that can be collected.", "inputFormat": "The first line contains a string of length $N$ consisting of lowercase letters, where each character represents an ore.\n\nThe second line contains $N$ integers, representing $V_i$.", "outputFormat": "The first line contains a single integer, the number $S$ of substrings that can be collected.\n\nThen output $S$ lines, each with two integers $L,R$, representing the left and right endpoints of each collectable substring, sorted by increasing left endpoint as the primary key and increasing right endpoint as the secondary key.", "hint": "There are $10$ testpoints, each worth $10$ points, totaling $100$ points.\n\n![pcg6nP.png](https://s1.ax1x.com/2018/01/19/pcg6nP.png)\n\nFor all testpoints, $N \\leq 10^5$, $0 \\le V_i \\le 1000$. It is guaranteed that the number of substrings that can be collected for each test is at most $10^5$.\n\nExplanation for Sample #1 is included in the statement.\n\nExplanation for Sample #2:\n\nNo substring satisfies the condition.\n\nThe rank of `a` is $4$, and the importance sums are all $1$.\n\nThe rank of `aa` is $3$, and the importance sums are all $2$.\n\nThe rank of `aaa` is $2$, and the importance sums are all $3$.\n\nThe rank of `aaaa` is $1$, and the importance sums are all $4$.\n\nExplanation for Sample #3:\n\nThe rank of `a` is $3$, and the importance sums are all $1$.\n\nThe rank of `aa` is $2$, and the importance sums are all $2$. There are two substrings `aa`, at positions $1$~$2$ and $2$~$3$.\n\nThe rank of `aaa` is $1$, and the importance sums are all $3$.\n\nExplanation for Sample #4:\n\nWe can see that the substring $2$~$3$ (the second `aa`) no longer satisfies the condition. Its rank is still $2$, but the importance sum is $3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "采集矿石", "background": "**ZRQ** 成功从坍塌的洞穴中逃了出来。终于，他看到了要研究的矿石。他想挑一些带回去完成任务。\n\n题目来源：[Zhang\\_RQ](https://www.luogu.org/space/show?uid=31565)~~哦对了 ZRQ 就他，嗯~~\n", "description": "**ZRQ** 发现这里有 $N$ 块排成一排的矿石。\n\n他用一个小写字母来表示每块矿石，他还发现每块矿石有一个重要度 $V_i$。\n\n**ZRQ** 想采集一段连续的矿石回研究所。\n\n他非常严格，被采集的一段矿石必须满足**小写字母的字典序降序排名等于这段矿石的重要度和。**\n\n**这里多个出现在不同位置的本质相同串的字典序排名相同。**\n\n比如说字母串为 `aa`，那么第一个 `a` 的排名和第二个 `a` 的排名相同，都是 `2`（第 `1` 是 `aa`）。\n\n**ZRQ** 问你，在原串中有哪些不同的子串可以被采集？\n\n**这里子串不同定义为出现位置不同，也就是说本质相同的子串出现在不同位置都要计算一次（当然重要度和等于排名是前提）。**\n\n比如共有 $4$ 块矿石，小写字母串为 `abcd`，重要度各为 `10 0 1 1`。\n\n我们把所有的子串按照字典序从大到小排名：`1:d 2:cd 3:c 4:bcd 5:bc 6:b 7:abcd 8:abc 9:ab 10:a`。\n\n那么串 `d` 的排名为 $1$（第一大），重要度和为 $1$，可以被采集。\n\n串 `cd` 的排名为 $2$，重要度和为 $2$，可以被采集。\n\n串 `a` 的排名为 $10$，重要度和为 $10$，可以被采集。\n\n其他串则不满足这个条件，故有三个串可以被采集。\n", "inputFormat": "第一行一个长度为 $N$ 由小写字母组成的字符串，每个字符代表一个矿石。\n\n\n第二行 $N$ 个整数，表示 $V_i$。\n", "outputFormat": "一行一个整数，表示能被采集的子串个数 $S$。\n\n\n接下来 $S$ 行每行两个整数 $L,R$，分别表示每个可采集子串的左端点与右端点，按照左端点升序为第一关键字，右端点升序为第二关键字排序。\n", "hint": "共 $10$ 个测试点，每个点 $10$ 分，计 $100$ 分。\n\n![pcg6nP.png](https://s1.ax1x.com/2018/01/19/pcg6nP.png)\n\n对于所有测试点，有 $N\\leq 10^5$，$0 \\le V_i \\le 1000$。保证每个点可被采集的子串不超过 $10^5$ 个。\n\n\n**样例#1解释**放在题面里了。\n\n**样例#2解释：**\n\n每个子串都不满足条件。\n\n串 `a` 的排名是 $4$，重要度和都是 $1$。\n\n串 `aa` 的排名是 $3$，重要度和都是 $2$。\n\n串 `aaa` 的排名是 $2$，重要度和都是 $3$。\n\n串 `aaaa` 的排名是 $1$，重要度和都是 $4$。\n\n**样例 #3解释：**\n\n串 `a` 的排名是 $3$，重要度和都是 $1$。\n\n串 `aa` 的排名是 $2$，重要度和都是 $2$，共有两个串`aa`，位置分别为 $1$~$2$ 和 $2$~$3$。\n\n串 `aaa` 的排名是 $1$，重要度和都是 $3$。\n\n**样例 #4解释：**\n\n可以发现，串 $2$~$3$（第二个 `aa`）不满足条件了。它的排名还是 $2$ 不变，但是重要度和为 $3$。\n", "locale": "zh-CN"}}}
{"pid": "P4144", "type": "P", "difficulty": 3, "samples": [["10 1 10000000\n7 9 9 4 0 0 8 8 4 7", "251"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "二分", "进制", "位运算"], "title": "大河的序列", "background": "“唯有龙虎相伴 最是脉脉深情”\n\n\n题目来源：[KingSann](https://www.luogu.org/space/show?uid=47111)\n", "description": "大河有一些袜子，但经常十分散乱的堆放着。\n\n\n有一天龙儿忍不住了，于是将袜子放到了一个序列上（称作袜子序列）。\n\n\n每个袜子都有一个$dirty$值，定义袜子序列的$dirty$值为 $ \\max  \\left( (dirty_{l} \\ bitand \\ dirty_{l+1} \\ bitand \\ \\cdots \\ bitand \\ dirty_{r}) + (dirty_{l} \\ bitor \\ dirty_{l+1} \\ bitor \\ \\cdots \\ bitor \\ dirty_{r}) \\right) $ ，其中 $ dirty_{i} $ 表示 第 $ i $ 只袜子 的 $ dirty $ 值，$bitand$表示按位与（C++中是`&`），$bitor$表示按位或（C++中是`|`）。\n\n\n简而言之，就是找一段连续子序列，使得所有数字的按位与加上按位或最大。\n\n\n如果这个袜子序列的$dirty$值达到了某个**阈**值，那么龙儿会讨厌大河的。\n\n\n大河当然不希望这样了，于是她想知道这个袜子序列的$dirty$值是多少。\n", "inputFormat": "第一行三个整数 $ n,b,p $ ，分别表示数列长度和输出相关的东西\n\n\n第二行有 $ n $ 个整数，表示这个数列的初始数值\n", "outputFormat": "设答案为 $ x $ ，你需要输出 $ (x+233)^{b} \\,\\, \\text{mod} \\,\\,p $\n", "hint": "$ 1 \\le n, p \\le 10^{5} $\n\n\n$ 0 \\le b, ditry_{i} \\le 10^{7} $\n\n\n对于测试点 $ 1 $ 和测试点 $ 2 $ 的数据，保证 $ 1 \\le n \\le 100 $\n", "locale": "zh-CN", "translations": {"en": {"title": "Dahe's Sequence", "background": "\"Only when dragon and tiger accompany each other is the deepest affection.\"\n\nProblem source: [KingSann](https://www.luogu.org/space/show?uid=47111).", "description": "Dahe has some socks, but they are often piled up messily.\n\nOne day, Long'er couldn’t stand it anymore, so she placed the socks onto a sequence (called the sock sequence).\n\nEach sock has a $dirty$ value. Define the $dirty$ value of the sock sequence as $ \\max  \\left( (dirty_{l} \\ bitand \\ dirty_{l+1} \\ bitand \\ \\cdots \\ bitand \\ dirty_{r}) + (dirty_{l} \\ bitor \\ dirty_{l+1} \\ bitor \\ \\cdots \\ bitor \\ dirty_{r}) \\right) $, where $ dirty_{i} $ denotes the $dirty$ value of the $i$-th sock; $bitand$ means bitwise AND (in C++ it is `&`), and $bitor$ means bitwise OR (in C++ it is `|`).\n\nIn short, find a contiguous subsequence that maximizes the sum of the bitwise AND and the bitwise OR of all numbers in it.\n\nIf the $dirty$ value of this sock sequence reaches a certain **threshold**, then Long'er will dislike Dahe.\n\nOf course, Dahe doesn’t want that, so she wants to know the $dirty$ value of this sock sequence.", "inputFormat": "The first line contains three integers $ n, b, p $, representing the length of the sequence and output-related parameters.\n\nThe second line contains $ n $ integers, the initial values of the sequence.", "outputFormat": "Let the answer be $ x $. You need to output $ (x+233)^{b} \\,\\, \\text{mod} \\,\\,p $.", "hint": "$ 1 \\le n, p \\le 10^{5} $.\n\n$ 0 \\le b, dirty_{i} \\le 10^{7} $.\n\nFor the testdata of test points $ 1 $ and $ 2 $, it is guaranteed that $ 1 \\le n \\le 100 $.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "大河的序列", "background": "“唯有龙虎相伴 最是脉脉深情”\n\n\n题目来源：[KingSann](https://www.luogu.org/space/show?uid=47111)\n", "description": "大河有一些袜子，但经常十分散乱的堆放着。\n\n\n有一天龙儿忍不住了，于是将袜子放到了一个序列上（称作袜子序列）。\n\n\n每个袜子都有一个$dirty$值，定义袜子序列的$dirty$值为 $ \\max  \\left( (dirty_{l} \\ bitand \\ dirty_{l+1} \\ bitand \\ \\cdots \\ bitand \\ dirty_{r}) + (dirty_{l} \\ bitor \\ dirty_{l+1} \\ bitor \\ \\cdots \\ bitor \\ dirty_{r}) \\right) $ ，其中 $ dirty_{i} $ 表示 第 $ i $ 只袜子 的 $ dirty $ 值，$bitand$表示按位与（C++中是`&`），$bitor$表示按位或（C++中是`|`）。\n\n\n简而言之，就是找一段连续子序列，使得所有数字的按位与加上按位或最大。\n\n\n如果这个袜子序列的$dirty$值达到了某个**阈**值，那么龙儿会讨厌大河的。\n\n\n大河当然不希望这样了，于是她想知道这个袜子序列的$dirty$值是多少。\n", "inputFormat": "第一行三个整数 $ n,b,p $ ，分别表示数列长度和输出相关的东西\n\n\n第二行有 $ n $ 个整数，表示这个数列的初始数值\n", "outputFormat": "设答案为 $ x $ ，你需要输出 $ (x+233)^{b} \\,\\, \\text{mod} \\,\\,p $\n", "hint": "$ 1 \\le n, p \\le 10^{5} $\n\n\n$ 0 \\le b, ditry_{i} \\le 10^{7} $\n\n\n对于测试点 $ 1 $ 和测试点 $ 2 $ 的数据，保证 $ 1 \\le n \\le 100 $\n", "locale": "zh-CN"}}}
{"pid": "P4145", "type": "P", "difficulty": 5, "samples": [["10\n1 2 3 4 5 6 7 8 9 10\n5\n0 1 10\n1 1 10\n1 1 5\n0 5 8\n1 4 8", "19\n7\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "并查集", "树状数组", "颜色段均摊（珂朵莉树 ODT）", "枚举", "分块"], "title": "上帝造题的七分钟 2 / 花神游历各国", "background": "XLk 觉得《上帝造题的七分钟》不太过瘾，于是有了第二部。", "description": "“第一分钟，X 说，要有数列，于是便给定了一个正整数数列。\n\n第二分钟，L 说，要能修改，于是便有了对一段数中每个数都开平方（下取整）的操作。\n\n第三分钟，k 说，要能查询，于是便有了求一段数的和的操作。\n\n第四分钟，彩虹喵说，要是 NOIP 难度，于是便有了数据范围。\n\n第五分钟，诗人说，要有韵律，于是便有了时间限制和内存限制。\n\n第六分钟，和雪说，要省点事，于是便有了保证运算过程中及最终结果均不超过 $64$ 位有符号整数类型的表示范围的限制。\n\n第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。”\n\n——《上帝造题的七分钟·第二部》\n\n所以这个神圣的任务就交给你了。", "inputFormat": "第一行一个整数 $n$，代表数列中数的个数。\n\n第二行 $n$ 个正整数，表示初始状态下数列中的数。\n\n第三行一个整数 $m$，表示有 $m$ 次操作。\n\n接下来 $m$ 行每行三个整数 `k l r`。\n\n- $k=0$ 表示给 $[l,r]$ 中的每个数开平方（下取整）。\n\n- $k=1$ 表示询问 $[l,r]$ 中各个数的和。\n\n**数据中有可能 $l>r$，所以遇到这种情况请交换 $l$ 和 $r$。**", "outputFormat": "对于询问操作，每行输出一个回答。", "hint": "对于 $30\\%$ 的数据，$1\\le n,m\\le 10^3$，数列中的数不超过 $32767$。\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 10^5$，$1\\le l,r\\le n$，数列中的数大于 $0$，且不超过 $10^{12}$。", "locale": "zh-CN", "translations": {"en": {"title": "Seven Minutes to Make a Problem 2 / The Flower God's Travels Across Countries", "background": "XLk felt that \"Seven Minutes to Make a Problem\" was not exciting enough, so there is a second part.", "description": "\"The first minute, X said, let there be a sequence, so a sequence of positive integers was given.\n\nThe second minute, L said, it should be modifiable, so there was an operation that takes the floor of the square root of every number in a segment.\n\nThe third minute, k said, it should be queryable, so there was an operation to find the sum of a segment.\n\nThe fourth minute, Caihong Miao said, make it NOIP difficulty, so there were constraints.\n\nThe fifth minute, the poet said, let there be rhythm, so there were time and memory limits.\n\nThe sixth minute, He Xue said, save some trouble, so it was guaranteed that during computation and in the final result, all values fit within the representable range of a $64$-bit signed integer type.\n\nThe seventh minute, this problem was finally created, but the problem setters no longer wanted to write the program for it.\"\n\n— \"Seven Minutes to Make a Problem · Part II\"\n\nSo this sacred task is handed to you.", "inputFormat": "The first line contains an integer $n$, the number of elements in the sequence.\n\nThe second line contains $n$ positive integers, the initial sequence.\n\nThe third line contains an integer $m$, the number of operations.\n\nEach of the next $m$ lines contains three integers `k l r`.\n\n- $k=0$ means replace every number in $[l,r]$ with the floor of its square root.\n- $k=1$ means query the sum of the numbers in $[l,r]$.\n\nIt is possible in the testdata that $l>r$, so when this happens please swap $l$ and $r$.", "outputFormat": "For each query operation, output one answer per line.", "hint": "Constraints:\n- For 30% of the testdata, $1\\le n,m\\le 10^3$, and the numbers in the sequence do not exceed $32767$.\n- For 100% of the testdata, $1\\le n,m\\le 10^5$, $1\\le l,r\\le n$, the numbers in the sequence are greater than $0$ and do not exceed $10^{12}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "上帝造题的七分钟 2 / 花神游历各国", "background": "XLk 觉得《上帝造题的七分钟》不太过瘾，于是有了第二部。", "description": "“第一分钟，X 说，要有数列，于是便给定了一个正整数数列。\n\n第二分钟，L 说，要能修改，于是便有了对一段数中每个数都开平方（下取整）的操作。\n\n第三分钟，k 说，要能查询，于是便有了求一段数的和的操作。\n\n第四分钟，彩虹喵说，要是 NOIP 难度，于是便有了数据范围。\n\n第五分钟，诗人说，要有韵律，于是便有了时间限制和内存限制。\n\n第六分钟，和雪说，要省点事，于是便有了保证运算过程中及最终结果均不超过 $64$ 位有符号整数类型的表示范围的限制。\n\n第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。”\n\n——《上帝造题的七分钟·第二部》\n\n所以这个神圣的任务就交给你了。", "inputFormat": "第一行一个整数 $n$，代表数列中数的个数。\n\n第二行 $n$ 个正整数，表示初始状态下数列中的数。\n\n第三行一个整数 $m$，表示有 $m$ 次操作。\n\n接下来 $m$ 行每行三个整数 `k l r`。\n\n- $k=0$ 表示给 $[l,r]$ 中的每个数开平方（下取整）。\n\n- $k=1$ 表示询问 $[l,r]$ 中各个数的和。\n\n**数据中有可能 $l>r$，所以遇到这种情况请交换 $l$ 和 $r$。**", "outputFormat": "对于询问操作，每行输出一个回答。", "hint": "对于 $30\\%$ 的数据，$1\\le n,m\\le 10^3$，数列中的数不超过 $32767$。\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 10^5$，$1\\le l,r\\le n$，数列中的数大于 $0$，且不超过 $10^{12}$。", "locale": "zh-CN"}}}
{"pid": "P4146", "type": "P", "difficulty": 5, "samples": [["4 4\n1 1 3 2\n1 2 4 -1\n2 1 3\n3 2 4", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "平衡树"], "title": "序列终结者", "background": "网上有许多题，就是给定一个序列，要你支持几种操作：A、B、C、D。一看另一道题，又是一个序列要支持几种操作：D、C、B、A。尤其是我们这里的某人，出模拟试题，居然还出了一道这样的，真是没技术含量……\n\n这样我也出一道题，我出这一道的目的是为了让大家以后做这种题目有一个“库”可以依靠，没有什么其他的意思。\n\n这道题目就叫序列终结者吧。\n", "description": "给定一个长度为 $N$ 的序列，每个序列的元素是一个整数（废话）。要支持以下三种操作：\n\n1. 将 $[L,R]$ 这个区间内的所有数加上 $V$。\n2. 将 $[L,R]$ 这个区间翻转，比如`1 2 3 4`变成`4 3 2 1`。\n3. 求 $[L,R]$ 这个区间中的最大值。\n\n最开始所有元素都是 $0$。\n", "inputFormat": "第一行两个整数 $N，M$。$M$ 为操作个数。\n\n以下 $M$ 行，每行最多四个整数，依次为 $K，L，R，V$。$K$ 表示是第几种操作，如果不是第 $1$ 种操作则 $K$ 后面只有两个数。\n", "outputFormat": "对于每个第 $3$ 种操作，给出正确的回答。\n\n", "hint": "$1\\le N \\le 50000$，$1\\le M \\le 100000$，$|V| \\leq 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Sequence Terminator", "background": "There are many problems online where, given a sequence, you need to support several operations: A, B, C, D. Then you see another problem: again a sequence with operations to support: D, C, B, A. Especially someone here, when making a mock exam, even made one like this. Honestly, there is not much technical content in that...\n\nSo I will also make one. My goal is to let everyone have a “library” to rely on when solving such problems in the future, nothing else.\n\nLet’s call this problem Sequence Terminator.", "description": "Given a sequence of length $N$, each element is an integer (trivial). You need to support the following three operations:\n\n1. Add $V$ to every number in the interval $[L,R]$.\n2. Reverse the interval $[L,R]$, for example, `1 2 3 4` becomes `4 3 2 1`.\n3. Query the maximum value in the interval $[L,R]$.\n\nInitially, all elements are $0$.", "inputFormat": "The first line contains two integers $N，M$. $M$ is the number of operations.\n\nThe next $M$ lines each contain up to four integers, in order: $K，L，R，V$. $K$ indicates the operation type. If it is not the $1$st operation, then only two numbers follow $K$.", "outputFormat": "For each operation of type $3$, output the correct answer.", "hint": "$1\\le N \\le 50000$，$1\\le M \\le 100000$，$|V| \\leq 1000$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "序列终结者", "background": "网上有许多题，就是给定一个序列，要你支持几种操作：A、B、C、D。一看另一道题，又是一个序列要支持几种操作：D、C、B、A。尤其是我们这里的某人，出模拟试题，居然还出了一道这样的，真是没技术含量……\n\n这样我也出一道题，我出这一道的目的是为了让大家以后做这种题目有一个“库”可以依靠，没有什么其他的意思。\n\n这道题目就叫序列终结者吧。\n", "description": "给定一个长度为 $N$ 的序列，每个序列的元素是一个整数（废话）。要支持以下三种操作：\n\n1. 将 $[L,R]$ 这个区间内的所有数加上 $V$。\n2. 将 $[L,R]$ 这个区间翻转，比如`1 2 3 4`变成`4 3 2 1`。\n3. 求 $[L,R]$ 这个区间中的最大值。\n\n最开始所有元素都是 $0$。\n", "inputFormat": "第一行两个整数 $N，M$。$M$ 为操作个数。\n\n以下 $M$ 行，每行最多四个整数，依次为 $K，L，R，V$。$K$ 表示是第几种操作，如果不是第 $1$ 种操作则 $K$ 后面只有两个数。\n", "outputFormat": "对于每个第 $3$ 种操作，给出正确的回答。\n\n", "hint": "$1\\le N \\le 50000$，$1\\le M \\le 100000$，$|V| \\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P4147", "type": "P", "difficulty": 4, "samples": [["5 6 \nR F F F F F \nF F F F F F \nR R R F F F \nF F F F F F \nF F F F F F", "45"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "枚举", "单调栈"], "title": "玉蟾宫", "background": "有一天，小猫 rainbow 和 freda 来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。", "description": "这片土地被分成 $N\\times M$ 个格子，每个格子里写着 `R` 或者 `F`，R 代表这块土地被赐予了 rainbow，F 代表这块土地被赐予了 freda。\n\n现在 freda 要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着 `F` 并且面积最大。\n\n但是 rainbow 和 freda 的 OI 水平都弱爆了，找不出这块土地，而蓝兔也想看 freda 卖萌（她显然是不会编程的……），所以它们决定，如果你找到的最大的土地面积为 $S$，它们每人给你 $S$ 两银子。", "inputFormat": "第一行两个整数 $N$，$M$，表示矩形土地有 $N$ 行 $M$ 列。\n\n接下来 $N$ 行，每行 $M$ 个用空格隔开的字符 `F` 或 `R`，描述了矩形土地。", "outputFormat": "输出一个整数，表示你能得到多少银子，即 $3\\times S$ 的值。", "hint": "对于 $50\\%$ 的数据，$1 \\leq N, M \\leq 200$。  \n对于 $100\\%$ 的数据，$1 \\leq N, M \\leq 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Yuchan Palace", "background": "One day, the kittens rainbow and freda came to Yuchan Palace on Tianmen Mountain in Zhangjiajie, Western Hunan. The palace master, Blue Rabbit (Lan Tu), warmly entertained them and granted them a piece of land.", "description": "This piece of land is divided into $N\\times M$ cells. Each cell contains `R` or `F`. `R` means the cell is granted to rainbow, and `F` means it is granted to freda.\n\nNow freda wants to act cute here... She wants to find a rectangular piece of land that is all `F`, with the largest possible area.\n\nBut rainbow and freda are very weak at OI, and Blue Rabbit also wants to watch freda act cute (she obviously cannot program), so they decide that if the largest area you find is $S$, each of them will give you $S$ taels of silver.", "inputFormat": "The first line contains two integers $N$ and $M$, meaning the rectangular land has $N$ rows and $M$ columns.\n\nThe next $N$ lines each contain $M$ characters separated by spaces, each being `F` or `R`, describing the land.", "outputFormat": "Output a single integer, the amount of silver you can get, i.e., the value of $3\\times S$.", "hint": "Constraints:\n- For $50\\%$ of the testdata, $1 \\leq N, M \\leq 200$.\n- For $100\\%$ of the testdata, $1 \\leq N, M \\leq 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "玉蟾宫", "background": "有一天，小猫 rainbow 和 freda 来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。", "description": "这片土地被分成 $N\\times M$ 个格子，每个格子里写着 `R` 或者 `F`，R 代表这块土地被赐予了 rainbow，F 代表这块土地被赐予了 freda。\n\n现在 freda 要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着 `F` 并且面积最大。\n\n但是 rainbow 和 freda 的 OI 水平都弱爆了，找不出这块土地，而蓝兔也想看 freda 卖萌（她显然是不会编程的……），所以它们决定，如果你找到的最大的土地面积为 $S$，它们每人给你 $S$ 两银子。", "inputFormat": "第一行两个整数 $N$，$M$，表示矩形土地有 $N$ 行 $M$ 列。\n\n接下来 $N$ 行，每行 $M$ 个用空格隔开的字符 `F` 或 `R`，描述了矩形土地。", "outputFormat": "输出一个整数，表示你能得到多少银子，即 $3\\times S$ 的值。", "hint": "对于 $50\\%$ 的数据，$1 \\leq N, M \\leq 200$。  \n对于 $100\\%$ 的数据，$1 \\leq N, M \\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P4148", "type": "P", "difficulty": 6, "samples": [["4\n1 2 3 3\n2 1 1 3 3\n1 1 1 1\n2 1 1 0 7\n3", "3\n5"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000], "memory": [20480, 20480, 20480, 20480, 20480]}, "tags": ["递归", "K-D Tree"], "title": "简单题", "background": "", "description": "你有一个$N \\times N$的棋盘，每个格子内有一个整数，初始时的时候全部为 $0$，现在需要维护两种操作：\n\n- `1 x y A`    $1\\le x,y\\le N$，$A$ 是正整数。将格子`x`,`y`里的数字加上 $A$。\n- `2 x1 y1 x2 y2`    $1 \\le x_1 \\le x_2 \\le N$，$1 \\le y_1\\le y_2 \\le N$。输出 $x_1, y_1, x_2, y_2$ 这个矩形内的数字和\n- `3`    无 终止程序\n", "inputFormat": "输入文件第一行一个正整数 $N$。\n\n接下来每行一个操作。每条命令除第一个数字之外，均要异或上一次输出的答案 `last_ans`，初始时 `last_ans` $=0$。\n", "outputFormat": "对于每个 $2$ 操作，输出一个对应的答案。\n", "hint": "$1\\leq N\\leq 5\\times 10^5$，操作数不超过 $2\\times 10^5$ 个，内存限制 $20\\texttt{MB}$，保证答案在 int 范围内并且解码之后数据仍合法。\n", "locale": "zh-CN", "translations": {"en": {"title": "Simple Problem", "background": "", "description": "You have an $N \\times N$ board with an integer in each cell, all initially $0$. You need to support three types of operations:\n\n- `1 x y A`    $1\\le x,y\\le N$, and $A$ is a positive integer. Add $A$ to the number in cell `x`, `y`.\n- `2 x1 y1 x2 y2`    $1 \\le x_1 \\le x_2 \\le N$, $1 \\le y_1\\le y_2 \\le N$. Output the sum of numbers inside the rectangle $x_1, y_1, x_2, y_2$.\n- `3`    None. Terminate the program.", "inputFormat": "The first line contains a positive integer $N$.\n\nEach of the following lines contains one operation. For every command, all numbers after the first one must be XORed with the previous output answer `last_ans`. Initially, `last_ans` $= 0$.", "outputFormat": "For each operation of type $2$, output the corresponding answer.", "hint": "Constraints: $1\\leq N\\leq 5\\times 10^5$, the number of operations does not exceed $2\\times 10^5$, memory limit $20\\texttt{MB}$. It is guaranteed that answers fit in the range of int and that after decoding the testdata remains valid.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "简单题", "background": "", "description": "你有一个$N \\times N$的棋盘，每个格子内有一个整数，初始时的时候全部为 $0$，现在需要维护两种操作：\n\n- `1 x y A`    $1\\le x,y\\le N$，$A$ 是正整数。将格子`x`,`y`里的数字加上 $A$。\n- `2 x1 y1 x2 y2`    $1 \\le x_1 \\le x_2 \\le N$，$1 \\le y_1\\le y_2 \\le N$。输出 $x_1, y_1, x_2, y_2$ 这个矩形内的数字和\n- `3`    无 终止程序\n", "inputFormat": "输入文件第一行一个正整数 $N$。\n\n接下来每行一个操作。每条命令除第一个数字之外，均要异或上一次输出的答案 `last_ans`，初始时 `last_ans` $=0$。\n", "outputFormat": "对于每个 $2$ 操作，输出一个对应的答案。\n", "hint": "$1\\leq N\\leq 5\\times 10^5$，操作数不超过 $2\\times 10^5$ 个，内存限制 $20\\texttt{MB}$，保证答案在 int 范围内并且解码之后数据仍合法。\n", "locale": "zh-CN"}}}
{"pid": "P4149", "type": "P", "difficulty": 5, "samples": [["4 3\n0 1 1\n1 2 2\n1 3 4", "2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2011", "点分治", "递归", "树上启发式合并", "IOI", "O2优化", "分治"], "title": "[IOI 2011] Race", "background": "", "description": "给一棵树，每条边有权。求一条简单路径，权值和等于 $k$，且边的数量最小。", "inputFormat": "第一行包含两个整数 $n,k$，表示树的大小与要求找到的路径的边权和。\n\n接下来 $n-1$ 行，每行三个整数 $u_i,v_i,w_i$，代表有一条连接 $u_i$ 与 $v_i$，边权为 $w_i$ 的无向边。\n\n**注意：点从 $0$ 开始编号**。", "outputFormat": "输出一个整数，表示最小边数量。\n\n如果不存在这样的路径，输出 $-1$。", "hint": "对于 $100\\%$ 的数据，保证 $1\\leq n\\leq 2\\times10^5$，$0\\leq k,w_i\\leq 10^6$，$0\\leq u_i,v_i<n$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2011] Race", "background": "", "description": "Given a tree with a weight on each edge, find a simple path whose total weight equals $k$, with the minimum possible number of edges.", "inputFormat": "The first line contains two integers $n, k$, representing the number of vertices in the tree and the target path sum.\n\nEach of the next $n-1$ lines contains three integers $u_i, v_i, w_i$, representing an undirected edge between $u_i$ and $v_i$ with weight $w_i$.\n\n**Note: vertices are numbered starting from $0$.**", "outputFormat": "Output a single integer, the minimal number of edges.\n\nIf no such path exists, output $-1$.", "hint": "For $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 2 \\times 10^5$, $0 \\leq k, w_i \\leq 10^6$, $0 \\leq u_i, v_i < n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2011] Race", "background": "", "description": "给一棵树，每条边有权。求一条简单路径，权值和等于 $k$，且边的数量最小。", "inputFormat": "第一行包含两个整数 $n,k$，表示树的大小与要求找到的路径的边权和。\n\n接下来 $n-1$ 行，每行三个整数 $u_i,v_i,w_i$，代表有一条连接 $u_i$ 与 $v_i$，边权为 $w_i$ 的无向边。\n\n**注意：点从 $0$ 开始编号**。", "outputFormat": "输出一个整数，表示最小边数量。\n\n如果不存在这样的路径，输出 $-1$。", "hint": "对于 $100\\%$ 的数据，保证 $1\\leq n\\leq 2\\times10^5$，$0\\leq k,w_i\\leq 10^6$，$0\\leq u_i,v_i<n$。", "locale": "zh-CN"}}}
{"pid": "P4150", "type": "P", "difficulty": 7, "samples": [["5\n0 0 1 0 0\n0 1 0 1 0\n0 2 0 1 0\n0 1 1 1 0\n0 0 0 0 0\n1 1 1 1 1\n5\n2 1 2 1 4\n1 1 1 10000\n2 1 2 1 4\n1 2 3 10000\n2 1 2 3 3", "0\n1\n2"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2009", "线段树", "O2优化", "WC"], "title": "[WC2009] 最短路问题", "background": "", "description": "【问题描述】\n\n一个 $6 * n$ 的方格，初始每个格子有一个非负权值。有如下两种操作形式：\n\n○改变一个格子的权值（改变以后仍然非负）；\n\n○求两个格子之间的最短路的权值。\n\n【注解与任务】\n\n任意格子 $P$ 的坐标$(x_P, y_P)$满足 $1 \\leq x_P \\leq 6$， $1 \\leq y_P \\leq n$。格子 $P$ 和 $Q$ 的曼哈顿距离定义为$|x_P - x_Q| + |y_P - y_Q|$。一个有序方格序列$(p_1, p_2, ..., p_n)$，若满足任意 $p_i$ 和 $p_i + 1$ 的曼哈顿距离为 $1$，则称该序列为一条从 $p_1$ 到 $p_n$ 的路径，其权值为$d(p1) + d(p2) + $...$ + d(p_n)$，其中 $d(P)$ 表示格子 $P$ 的权值。两个格子 $P$ 和 $Q$ 之间的最短路定义为从 $P$ 到 $Q$ 权值最小的路径。\n", "inputFormat": "第一行一个整数 $n$。接下来 $6$ 行，每行 $n$ 个整数，第 $i + 1$ 行第 $j$ 个整数表示初始格子$(i, j)$的权值。接下来是一个整数 $Q$， 后面的 $Q$ 行，每行描述一个操作。\n\n输入的操作有以下两种形式：\n\n操作 $1$： \"$1\\ x\\ y\\ c$\"(不含双引号)。表示将格子$(x, y)$的权值改成 $c$ ($1 \\leq x \\leq 6$, $1 \\leq y \\leq n$, $0 \\leq c \\leq 10000$) 。\n\n操作 $2$： \"$2\\ x_1\\ y_1\\ x_2\\ y_2$\"(不含双引号)。表示询问格子$(x_1, y_1)$和格子$(x_2, y_2)$之间的最短路的权值。（$1 \\leq x_1, x_2 \\leq 6$, $1 \\leq y_1, y_2 \\leq n$）\n", "outputFormat": "对于每个操作 $2$，按照它在输入中出现的顺序，依次输出一行一个整数表示\n\n求得的最短路权值。\n", "hint": "|数据编号|$n$|$Q$|数据编号|$n$|$Q$|\n|:-:|:-:|:-:|:-:|:-:|:-:|\n|$1$|$10$|$20$|$6$|$10^4$|$3\\times 10^4$|\n|$2$|$100$|$200$|$7$|$3.5\\times 10^4$|$3\\times 10^4$|\n|$3$|$10^3$|$2\\times 10^3$|$8$|$5\\times 10^4$|$5\\times 10^4$|\n|$4$|$10^4$|$10^4$|$9$|$10^5$|$6\\times 10^4$|\n|$5$|$10^4$|$10^4$|$10$|$10^5$|$10^5$|\n\n**2024/08/20: 增加 3 组 hack 数据**", "locale": "zh-CN", "translations": {"en": {"title": "[WC2009] Shortest Path Problem", "background": "", "description": "A $6 \\times n$ grid is given, where each cell initially has a non-negative weight. There are two types of operations:\n\n- Change the weight of a cell (the new weight is still non-negative).\n- Query the weight of the shortest path between two cells.\n\nNotes and task:\n\nFor any cell $P$, its coordinates $(x_P, y_P)$ satisfy $1 \\leq x_P \\leq 6$, $1 \\leq y_P \\leq n$. The Manhattan distance between cells $P$ and $Q$ is defined as $|x_P - x_Q| + |y_P - y_Q|$. An ordered sequence of cells $(p_1, p_2, \\ldots, p_k)$ is called a path from $p_1$ to $p_k$ if the Manhattan distance between any $p_i$ and $p_{i+1}$ is $1$. Its weight is $d(p_1) + d(p_2) + \\cdots + d(p_k)$, where $d(P)$ is the weight of cell $P$. The shortest path between two cells $P$ and $Q$ is a path from $P$ to $Q$ with the minimum total weight.", "inputFormat": "The first line contains an integer $n$. The next $6$ lines each contain $n$ integers; on the $(i+1)$-th line, the $j$-th integer is the initial weight of cell $(i, j)$. Then an integer $Q$ follows, and the next $Q$ lines each describe an operation.\n\nThere are two types of operations:\n\nType $1$: \"1 x y c\" (without double quotes). Set the weight of cell $(x, y)$ to $c$ ($1 \\leq x \\leq 6$, $1 \\leq y \\leq n$, $0 \\leq c \\leq 10000$).\n\nType $2$: \"2 x_1 y_1 x_2 y_2\" (without double quotes). Query the weight of the shortest path between cell $(x_1, y_1)$ and cell $(x_2, y_2)$ ($1 \\leq x_1, x_2 \\leq 6$, $1 \\leq y_1, y_2 \\leq n$).", "outputFormat": "For each type $2$ operation, in the order they appear, output one line with one integer: the weight of the shortest path.", "hint": "| Testdata ID | $n$ | $Q$ | Testdata ID | $n$ | $Q$ |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| $1$ | $10$ | $20$ | $6$ | $10^4$ | $3\\times 10^4$ |\n| $2$ | $100$ | $200$ | $7$ | $3.5\\times 10^4$ | $3\\times 10^4$ |\n| $3$ | $10^3$ | $2\\times 10^3$ | $8$ | $5\\times 10^4$ | $5\\times 10^4$ |\n| $4$ | $10^4$ | $10^4$ | $9$ | $10^5$ | $6\\times 10^4$ |\n| $5$ | $10^4$ | $10^4$ | $10$ | $10^5$ | $10^5$ |\n\n**2024/08/20: Added 3 sets of hack testdata.**\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2009] 最短路问题", "background": "", "description": "【问题描述】\n\n一个 $6 * n$ 的方格，初始每个格子有一个非负权值。有如下两种操作形式：\n\n○改变一个格子的权值（改变以后仍然非负）；\n\n○求两个格子之间的最短路的权值。\n\n【注解与任务】\n\n任意格子 $P$ 的坐标$(x_P, y_P)$满足 $1 \\leq x_P \\leq 6$， $1 \\leq y_P \\leq n$。格子 $P$ 和 $Q$ 的曼哈顿距离定义为$|x_P - x_Q| + |y_P - y_Q|$。一个有序方格序列$(p_1, p_2, ..., p_n)$，若满足任意 $p_i$ 和 $p_i + 1$ 的曼哈顿距离为 $1$，则称该序列为一条从 $p_1$ 到 $p_n$ 的路径，其权值为$d(p1) + d(p2) + $...$ + d(p_n)$，其中 $d(P)$ 表示格子 $P$ 的权值。两个格子 $P$ 和 $Q$ 之间的最短路定义为从 $P$ 到 $Q$ 权值最小的路径。\n", "inputFormat": "第一行一个整数 $n$。接下来 $6$ 行，每行 $n$ 个整数，第 $i + 1$ 行第 $j$ 个整数表示初始格子$(i, j)$的权值。接下来是一个整数 $Q$， 后面的 $Q$ 行，每行描述一个操作。\n\n输入的操作有以下两种形式：\n\n操作 $1$： \"$1\\ x\\ y\\ c$\"(不含双引号)。表示将格子$(x, y)$的权值改成 $c$ ($1 \\leq x \\leq 6$, $1 \\leq y \\leq n$, $0 \\leq c \\leq 10000$) 。\n\n操作 $2$： \"$2\\ x_1\\ y_1\\ x_2\\ y_2$\"(不含双引号)。表示询问格子$(x_1, y_1)$和格子$(x_2, y_2)$之间的最短路的权值。（$1 \\leq x_1, x_2 \\leq 6$, $1 \\leq y_1, y_2 \\leq n$）\n", "outputFormat": "对于每个操作 $2$，按照它在输入中出现的顺序，依次输出一行一个整数表示\n\n求得的最短路权值。\n", "hint": "|数据编号|$n$|$Q$|数据编号|$n$|$Q$|\n|:-:|:-:|:-:|:-:|:-:|:-:|\n|$1$|$10$|$20$|$6$|$10^4$|$3\\times 10^4$|\n|$2$|$100$|$200$|$7$|$3.5\\times 10^4$|$3\\times 10^4$|\n|$3$|$10^3$|$2\\times 10^3$|$8$|$5\\times 10^4$|$5\\times 10^4$|\n|$4$|$10^4$|$10^4$|$9$|$10^5$|$6\\times 10^4$|\n|$5$|$10^4$|$10^4$|$10$|$10^5$|$10^5$|\n\n**2024/08/20: 增加 3 组 hack 数据**", "locale": "zh-CN"}}}
{"pid": "P4151", "type": "P", "difficulty": 6, "samples": [["5 7\n1 2 2\n1 3 2\n2 4 1\n2 5 1\n4 5 3\n5 3 4\n4 3 2", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["图论", "贪心", "2011", "枚举", "深度优先搜索 DFS", "线性基", "向量", "WC"], "title": "[WC2011] 最大XOR和路径", "background": "", "description": "XOR（异或）是一种二元逻辑运算，其运算结果当且仅当两个输入的布尔值不相等时才为真，否则为假。 XOR 运算的真值表如下（$1$ 表示真， $0$ 表示假）：\n\n| 输入 | 输入 | 输出 |\n| :----------: | :----------: | :----------: |\n| A | B | A XOR B |\n| 0 | 0 | 0 |\n| 0 | 1 | 1 |\n| 1 | 0 | 1 |\n| 1 | 1 | 0 |\n\n\n而两个非负整数的 XOR 是指将它们表示成二进制数，再在对应的二进制位进行 XOR 运算。\n\n譬如 $12$ XOR $9$ 的计算过程如下：\n\n$$\n12=(1100)_2\\ \\ \\ 9=(1001)_2\\\\\n\\begin{matrix}\n&1\\ 1\\ 0\\ 0\\\\\n\\text{XOR}&1\\ 0\\ 0\\ 1\\\\\n\\hline\n&0\\ 1\\ 0\\ 1\\\\\n\\end{matrix}\\\\\n(0101)_2=5\n$$\n\n故 $12$ XOR $9 = 5$。\n\n容易验证， XOR 运算满足交换律与结合律，故计算若干个数的 XOR 时，不同的计算顺序不会对运算结果造成影响。从而，可以定义 $K$ 个非负整数 $A_1$，$A_2$，……，$A_{K-1}$，$A_K$的 XOR 和为\n\n$A_1$ XOR $A_2$ XOR …… XOR $A_{K-1}$ XOR $A_K$\n\n考虑一个边权为非负整数的无向连通图，节点编号为 $1$ 到 $N$，试求出一条从 $1$ 号节点到 $N$ 号节点的路径，使得路径上经过的边的权值的 XOR 和最大。\n\n路径可以重复经过某些点或边，当一条边在路径中出现了多次时，其权值在计算 XOR 和时也要被计算相应多的次数，具体见样例。\n", "inputFormat": "输入文件 xor.in 的第一行包含两个整数 $N$ 和 $M$， 表示该无向图中点的数目与边的数目。\n\n接下来 $M$ 行描述 $M$ 条边，每行三个整数 $S_i$， $T_i$ ， $D_i$， 表示 $S_i$ 与 $T_i$ 之间存在一条权值为 $D_i$ 的无向边。\n\n图中可能有重边或自环。\n", "outputFormat": "输出文件 xor.out 仅包含一个整数，表示最大的 XOR 和（十进制结果）。\n", "hint": "【样例说明】\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p6bf4fgf.png)\n\n如图，路径$1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 3 \\rightarrow 5 \\rightarrow 2 \\rightarrow 4 \\rightarrow 5$对应的XOR和为\n\n$2$ XOR $1$ XOR $2$ XOR $4$ XOR $1$ XOR $1$ XOR $3 = 6$\n\n当然，一条边数更少的路径$1 \\rightarrow 3 \\rightarrow 5$对应的XOR和也是$2$ XOR $4 = 6$。\n\n【数据规模】\n\n对于 $20 \\%$ 的数据，$N \\leq 100$， $M \\leq 1000$，$D_i \\leq 10^{4}$；\n\n对于 $50 \\%$ 的数据，$N \\leq 1000$， $M \\leq 10000$，$D_i \\leq 10^{18}$；\n\n对于 $70 \\%$ 的数据，$N \\leq 5000$， $M \\leq 50000$，$D_i \\leq 10^{18}$；\n\n对于 $100 \\%$ 的数据，$N \\leq 50000$， $M \\leq 100000$，$D_i \\leq 10^{18}$。\n\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[WC2011] Maximum XOR Sum Path", "background": "", "description": "XOR (exclusive OR) is a binary logical operation whose result is true if and only if the two input Boolean values are different; otherwise it is false. The truth table of the XOR operation is as follows ($1$ means true, $0$ means false):\n\n| Input | Input | Output |\n| :----------: | :----------: | :----------: |\n| A | B | A XOR B |\n| 0 | 0 | 0 |\n| 0 | 1 | 1 |\n| 1 | 0 | 1 |\n| 1 | 1 | 0 |\n\nThe XOR of two non-negative integers means writing them in binary and applying XOR on the corresponding bits.\n\nFor example, the computation of $12$ XOR $9$ is as follows:\n\n$$\n12=(1100)_2\\ \\ \\ 9=(1001)_2\\\\\n\\begin{matrix}\n&1\\ 1\\ 0\\ 0\\\\\n\\text{XOR}&1\\ 0\\ 0\\ 1\\\\\n\\hline\n&0\\ 1\\ 0\\ 1\\\\\n\\end{matrix}\\\\\n(0101)_2=5\n$$\n\nTherefore, $12$ XOR $9 = 5$.\n\nIt is easy to verify that XOR is commutative and associative, so the order does not affect the result when XOR-ing multiple numbers. Thus, we define the XOR sum of $K$ non-negative integers $A_1$, $A_2$, …, $A_{K-1}$, $A_K$ as\n\n$A_1$ XOR $A_2$ XOR … XOR $A_{K-1}$ XOR $A_K$.\n\nConsider an undirected connected graph with non-negative integer edge weights, with nodes numbered from $1$ to $N$. Find a path from node $1$ to node $N$ such that the XOR sum of the edge weights along the path is maximized.\n\nA path may visit some vertices or edges multiple times. When an edge appears multiple times in the path, its weight is counted the corresponding number of times in the XOR sum. See the sample for details.", "inputFormat": "The first line contains two integers $N$ and $M$, the number of nodes and edges in the undirected graph.\n\nThe next $M$ lines each describe an edge, with three integers $S_i$, $T_i$, $D_i$, indicating there is an undirected edge between $S_i$ and $T_i$ with weight $D_i$.\n\nMultiple edges and self-loops may exist.", "outputFormat": "Output a single integer, the maximum XOR sum (in decimal).", "hint": "[Sample Explanation]\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p6bf4fgf.png)\n\nAs shown, the path $1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 3 \\rightarrow 5 \\rightarrow 2 \\rightarrow 4 \\rightarrow 5$ has XOR sum\n\n$2$ XOR $1$ XOR $2$ XOR $4$ XOR $1$ XOR $1$ XOR $3 = 6$.\n\nOf course, a shorter path $1 \\rightarrow 3 \\rightarrow 5$ also has XOR sum $2$ XOR $4 = 6$.\n\nConstraints\n\n- For 20% of the testdata, $N \\leq 100$, $M \\leq 1000$, $D_i \\leq 10^{4}$.\n- For 50% of the testdata, $N \\leq 1000$, $M \\leq 10000$, $D_i \\leq 10^{18}$.\n- For 70% of the testdata, $N \\leq 5000$, $M \\leq 50000$, $D_i \\leq 10^{18}$.\n- For 100% of the testdata, $N \\leq 50000$, $M \\leq 100000$, $D_i \\leq 10^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2011] 最大XOR和路径", "background": "", "description": "XOR（异或）是一种二元逻辑运算，其运算结果当且仅当两个输入的布尔值不相等时才为真，否则为假。 XOR 运算的真值表如下（$1$ 表示真， $0$ 表示假）：\n\n| 输入 | 输入 | 输出 |\n| :----------: | :----------: | :----------: |\n| A | B | A XOR B |\n| 0 | 0 | 0 |\n| 0 | 1 | 1 |\n| 1 | 0 | 1 |\n| 1 | 1 | 0 |\n\n\n而两个非负整数的 XOR 是指将它们表示成二进制数，再在对应的二进制位进行 XOR 运算。\n\n譬如 $12$ XOR $9$ 的计算过程如下：\n\n$$\n12=(1100)_2\\ \\ \\ 9=(1001)_2\\\\\n\\begin{matrix}\n&1\\ 1\\ 0\\ 0\\\\\n\\text{XOR}&1\\ 0\\ 0\\ 1\\\\\n\\hline\n&0\\ 1\\ 0\\ 1\\\\\n\\end{matrix}\\\\\n(0101)_2=5\n$$\n\n故 $12$ XOR $9 = 5$。\n\n容易验证， XOR 运算满足交换律与结合律，故计算若干个数的 XOR 时，不同的计算顺序不会对运算结果造成影响。从而，可以定义 $K$ 个非负整数 $A_1$，$A_2$，……，$A_{K-1}$，$A_K$的 XOR 和为\n\n$A_1$ XOR $A_2$ XOR …… XOR $A_{K-1}$ XOR $A_K$\n\n考虑一个边权为非负整数的无向连通图，节点编号为 $1$ 到 $N$，试求出一条从 $1$ 号节点到 $N$ 号节点的路径，使得路径上经过的边的权值的 XOR 和最大。\n\n路径可以重复经过某些点或边，当一条边在路径中出现了多次时，其权值在计算 XOR 和时也要被计算相应多的次数，具体见样例。\n", "inputFormat": "输入文件 xor.in 的第一行包含两个整数 $N$ 和 $M$， 表示该无向图中点的数目与边的数目。\n\n接下来 $M$ 行描述 $M$ 条边，每行三个整数 $S_i$， $T_i$ ， $D_i$， 表示 $S_i$ 与 $T_i$ 之间存在一条权值为 $D_i$ 的无向边。\n\n图中可能有重边或自环。\n", "outputFormat": "输出文件 xor.out 仅包含一个整数，表示最大的 XOR 和（十进制结果）。\n", "hint": "【样例说明】\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p6bf4fgf.png)\n\n如图，路径$1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 3 \\rightarrow 5 \\rightarrow 2 \\rightarrow 4 \\rightarrow 5$对应的XOR和为\n\n$2$ XOR $1$ XOR $2$ XOR $4$ XOR $1$ XOR $1$ XOR $3 = 6$\n\n当然，一条边数更少的路径$1 \\rightarrow 3 \\rightarrow 5$对应的XOR和也是$2$ XOR $4 = 6$。\n\n【数据规模】\n\n对于 $20 \\%$ 的数据，$N \\leq 100$， $M \\leq 1000$，$D_i \\leq 10^{4}$；\n\n对于 $50 \\%$ 的数据，$N \\leq 1000$， $M \\leq 10000$，$D_i \\leq 10^{18}$；\n\n对于 $70 \\%$ 的数据，$N \\leq 5000$， $M \\leq 50000$，$D_i \\leq 10^{18}$；\n\n对于 $100 \\%$ 的数据，$N \\leq 50000$， $M \\leq 100000$，$D_i \\leq 10^{18}$。\n\n\n", "locale": "zh-CN"}}}
{"pid": "P4152", "type": "P", "difficulty": 6, "samples": [["3\n2 3\n3 4\n3 3\n3 4 4\n4 4\n5 9 7 8", "2\n4\n846"], ["1\n11 20\n97665 99289 91440 92389 93960 94623 96582 93975 98359 93492 90331\n", "3278"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "2014", "莫比乌斯反演", "组合数学", "WC"], "title": "[WC2014] 时空穿梭", "background": "", "description": "小X驾驶着他的飞船准备穿梭过一个 $n$ 维空间，这个空间里每个点的坐标可以用 $n$ 个实数来表示，即 $(x_1, x_2, ... , x_n)$ 。\n\n为了穿过这个空间，小 X 需要在这个空间中选取 $c$ $(c \\geq 2)$ 个点作为飞船停留的地方，而这些点需要满足以下三个条件：\n\n$1$. 每个点的每一维坐标均为正整数，且第 $i$ 维坐标不超过 $m_i$ 。\n\n$2$. 第 $i + 1$ $(1 \\leq i < c)$ 个点的第 $j$ $(1 \\leq j \\leq n)$ 维坐标必须严格大于第 $i$ 个点的第 $j$ 维坐标。\n\n$3$. 存在一条直线经过所选的所有点。在这个 $n$ 维空间里，一条直线可以用 $2n$个实数 $p_1$, $p_2$, … , $p_n$, $v_1$, $v_2$, … , $v_n$ 表示。 直线经过点 $(x_1, x_2, ... , x_n)$ ，当且仅当存在实数 $t$，使得对 $i = 1$ … $n$ 均满足 $x_i$ = $p_i + tv_i$。\n\n小 X 还没有确定他的最终方案，请你帮他计算一下一共有多少种不同的方案满足他的要求。由于答案可能会很大，你只需要输出答案 mod $10 007$ 后的值。\n", "inputFormat": "输入文件 space.in 的第一行包含一个正整数 $T$ ，表示有 $T$ 组数据需要求解。\n\n每组数据包含两行，第一行包含两个正整数 $n$, $c$ $(c \\geq 2)$ ，分别表示空间的维数和需要选择的暂停点个数。\n\n第二行包含 $n$ 个正整数，依次表示 $m_1$, $m_2$, … , $m_n$。\n", "outputFormat": "输出文件 space.out 包含 $T$ 行，每行包含一个非负整数，依次对应每组数据\n\n的答案。\n", "hint": "【样例$1$说明】\n\n样例数据第一组共有两种可行方案：一种是选择 $(1,1)$ , $(2,2)$ , $(3,3)$ ，另一种是选择 $(1,2)$ , $(2,3)$ , $(3,4)$ 。\n\n【数据规模】\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/84c5gmzc.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "[WC2014] Spacetime Shuttle", "background": "", "description": "Xiao X is piloting his spaceship to traverse an $n$-dimensional space, where each point is represented by $n$ real numbers, i.e., $(x_1, x_2, \\dots, x_n)$.\n\nTo pass through this space, Xiao X needs to choose $c$ ($c \\geq 2$) points in this space as stopping places for the spaceship, and these points must satisfy the following three conditions:\n\n1. Every coordinate of each point is a positive integer, and the $i$-th coordinate does not exceed $m_i$.\n2. For $1 \\leq i < c$ and $1 \\leq j \\leq n$, the $j$-th coordinate of the $(i+1)$-th point must be strictly greater than the $j$-th coordinate of the $i$-th point.\n3. There exists a straight line passing through all the chosen points. In this $n$-dimensional space, a straight line can be represented by $2n$ real numbers $p_1$, $p_2$, … , $p_n$, $v_1$, $v_2$, … , $v_n$. A line passes through a point $(x_1, x_2, \\dots, x_n)$ if and only if there exists a real number $t$ such that for $i = 1 \\dots n$ it holds that $x_i$ = $p_i + tv_i$.\n\nXiao X has not finalized his plan yet. Please help him compute how many different schemes satisfy his requirements. Since the answer may be very large, you only need to output the value of the answer mod $10 007$.", "inputFormat": "The first line contains a positive integer $T$, the number of test cases.\n\nFor each test case, there are two lines:\n- The first line contains two positive integers $n$, $c$ ($c \\geq 2$), denoting the dimension of the space and the number of stopping points to select.\n- The second line contains $n$ positive integers, which are $m_1$, $m_2$, … , $m_n$.", "outputFormat": "Output $T$ lines. Each line contains a non-negative integer, which is the answer for the corresponding test case.", "hint": "[Sample 1 Explanation]\n\nThere are two feasible schemes in the first sample: one is to choose $(1,1)$, $(2,2)$, $(3,3)$; the other is to choose $(1,2)$, $(2,3)$, $(3,4)$.\n\nConstraints\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/84c5gmzc.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2014] 时空穿梭", "background": "", "description": "小X驾驶着他的飞船准备穿梭过一个 $n$ 维空间，这个空间里每个点的坐标可以用 $n$ 个实数来表示，即 $(x_1, x_2, ... , x_n)$ 。\n\n为了穿过这个空间，小 X 需要在这个空间中选取 $c$ $(c \\geq 2)$ 个点作为飞船停留的地方，而这些点需要满足以下三个条件：\n\n$1$. 每个点的每一维坐标均为正整数，且第 $i$ 维坐标不超过 $m_i$ 。\n\n$2$. 第 $i + 1$ $(1 \\leq i < c)$ 个点的第 $j$ $(1 \\leq j \\leq n)$ 维坐标必须严格大于第 $i$ 个点的第 $j$ 维坐标。\n\n$3$. 存在一条直线经过所选的所有点。在这个 $n$ 维空间里，一条直线可以用 $2n$个实数 $p_1$, $p_2$, … , $p_n$, $v_1$, $v_2$, … , $v_n$ 表示。 直线经过点 $(x_1, x_2, ... , x_n)$ ，当且仅当存在实数 $t$，使得对 $i = 1$ … $n$ 均满足 $x_i$ = $p_i + tv_i$。\n\n小 X 还没有确定他的最终方案，请你帮他计算一下一共有多少种不同的方案满足他的要求。由于答案可能会很大，你只需要输出答案 mod $10 007$ 后的值。\n", "inputFormat": "输入文件 space.in 的第一行包含一个正整数 $T$ ，表示有 $T$ 组数据需要求解。\n\n每组数据包含两行，第一行包含两个正整数 $n$, $c$ $(c \\geq 2)$ ，分别表示空间的维数和需要选择的暂停点个数。\n\n第二行包含 $n$ 个正整数，依次表示 $m_1$, $m_2$, … , $m_n$。\n", "outputFormat": "输出文件 space.out 包含 $T$ 行，每行包含一个非负整数，依次对应每组数据\n\n的答案。\n", "hint": "【样例$1$说明】\n\n样例数据第一组共有两种可行方案：一种是选择 $(1,1)$ , $(2,2)$ , $(3,3)$ ，另一种是选择 $(1,2)$ , $(2,3)$ , $(3,4)$ 。\n\n【数据规模】\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/84c5gmzc.png)\n", "locale": "zh-CN"}}}
{"pid": "P4153", "type": "P", "difficulty": 7, "samples": [["3 3 1 3 100\n1 2 3\n2 3 4\n1 3 5\n", "8\n9\n12\n-1\n"], ["5 8 1 5 10\n1 2 45176\n1 3 41088\n1 4 32001\n2 5 48931\n3 5 39291\n4 5 28970\n2 3 48131\n4 2 49795\n", "116468\n117192\n118265\n120223\n145438\n147235\n149193\n157556\n158280\n161311\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "2015", "O2优化", "优先队列", "最小割", "WC"], "title": "[WC2015] k 小割", "background": "", "description": "给出一个有向带权网络 $G = (V, E)$，权值函数 $w: E \\rightarrow \\mathbb{Z^{*}}$（即任意边 $e$ 的权值 $w(e)$ 均为正整数），和点 $s, t \\in V$，使得在 $G' = (V, E - S)$ 上不存在 $s$ 到 $t$ 的路径。\n\n\n设 $\\mathfrak{S}$ 是所有满足条件的边集 $S$ 的全集，按 $w(S)$ 从小到大输出 $\\mathfrak{S}$ 中前 $k$ 小的边集的边权和。其中 $w(S) = \\sum_{e \\in S} w(e)$。\n", "inputFormat": "第一行包含 $5$ 个正整数 $n, m, s, t, k$，其中 $s, t, k$ 意义如上，$n, m$ 分别表示 $\\lvert V \\rvert, \\lvert E \\rvert$（即点数和边数）。规定图中的节点用 $1$ 到 $n$ 的整数表示。保证 $s \\neq t$。\n\n\n接下来 $m$ 行，每行 $3$ 个整数 $x, y, z$，表示一条边权为 $z$ 的从 $x$ 到 $y$ 的边。可能有重边但保证没有自环。\n", "outputFormat": "如果 $\\lvert \\mathfrak{S} \\rvert < k$，先输出 $\\lvert \\mathfrak{S} \\rvert$ 行，每行包含一个整数，表示前 $\\lvert \\mathfrak{S} \\rvert$ 个 $w(S)$；再输出一行一个整数 $-1$。\n\n\n如果 $\\lvert \\mathfrak{S} \\rvert \\geq k$，则输出 $k$ 行，表示前 $k$ 个 $w(S)$。\n\n\n两种情况均需按照 $w(S)$ 从小到大输出。\n", "hint": "| 测试点编号 | $n \\le$ | $m$ | $k \\le$ | 约束 |\n|:-:|:-:|:-:|:-:|:-:|\n| $1 \\sim 2$ | $10$ | $\\le 20$ | ${10}^6$ | 边权不超过 $65536$ |\n| $3 \\sim 6$ | $50$ | $\\le 100$ | $100$ | 边权不超过 $65536$ |\n| $7 \\sim 10$ | $3000$ | $= 2 n - 4$ | $5 \\times {10}^5$ | $s$ 有边连向所有非 $t$ 节点，所有非 $s$ 结点有边连向 $t$，边权不超过 $2^{31} - 1$ |\n| $11 \\sim 14$ | $1.5 \\times {10}^5$ | $= 2 n - 4$ | $5 \\times {10}^5$ | $s$ 有边连向所有非 $t$ 节点，所有非 $s$ 结点有边连向 $t$，边权不超过 $2^{31} - 1$ |\n| $15 \\sim 20$ | $50$ | $\\le 1500$ | $100$ | 边权不超过 $65536$ |", "locale": "zh-CN", "translations": {"en": {"title": "[WC2015] k-Min Cut", "background": "", "description": "Given a directed weighted network $G = (V, E)$, a weight function $w: E \\rightarrow \\mathbb{Z^{*}}$ (i.e., for any edge $e$, the weight $w(e)$ is a positive integer), and vertices $s, t \\in V$. Consider any edge set $S \\subseteq E$, and let $G' = (V, E - S)$. If there is no path from $s$ to $t$ in $G'$, then $S$ is valid.\n\nLet $\\mathfrak{S}$ be the set of all such edge sets $S$. Output the sums of edge weights of the smallest $k$ sets in $\\mathfrak{S}$ by nondecreasing $w(S)$, where $w(S) = \\sum_{e \\in S} w(e)$.", "inputFormat": "The first line contains $5$ positive integers $n, m, s, t, k$, where $s, t, k$ are as above, and $n, m$ denote $\\lvert V \\rvert, \\lvert E \\rvert$ (the numbers of vertices and edges). Vertices are labeled from $1$ to $n$. It is guaranteed that $s \\neq t$.\n\nThe next $m$ lines each contain $3$ integers $x, y, z$, representing a directed edge from $x$ to $y$ with weight $z$. Multiple edges may exist, but there are no self-loops.", "outputFormat": "If $\\lvert \\mathfrak{S} \\rvert < k$, first output $\\lvert \\mathfrak{S} \\rvert$ lines, each containing one integer, which are the first $\\lvert \\mathfrak{S} \\rvert$ values of $w(S)$. Then output one more line with a single integer $-1$.\n\nIf $\\lvert \\mathfrak{S} \\rvert \\geq k$, output $k$ lines, which are the first $k$ values of $w(S)$.\n\nIn both cases, the outputs must be in nondecreasing order of $w(S)$.", "hint": "| Test Point ID | $n \\le$ | $m$ | $k \\le$ | Constraints |\n|:-:|:-:|:-:|:-:|:-:|\n| $1 \\sim 2$ | $10$ | $\\le 20$ | ${10}^6$ | Edge weights do not exceed $65536$. |\n| $3 \\sim 6$ | $50$ | $\\le 100$ | $100$ | Edge weights do not exceed $65536$. |\n| $7 \\sim 10$ | $3000$ | $= 2 n - 4$ | $5 \\times {10}^5$ | $s$ has edges to all vertices other than $t$; every vertex other than $s$ has an edge to $t$; edge weights do not exceed $2^{31} - 1$. |\n| $11 \\sim 14$ | $1.5 \\times {10}^5$ | $= 2 n - 4$ | $5 \\times {10}^5$ | $s$ has edges to all vertices other than $t$; every vertex other than $s$ has an edge to $t$; edge weights do not exceed $2^{31} - 1$. |\n| $15 \\sim 20$ | $50$ | $\\le 1500$ | $100$ | Edge weights do not exceed $65536$. |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2015] k 小割", "background": "", "description": "给出一个有向带权网络 $G = (V, E)$，权值函数 $w: E \\rightarrow \\mathbb{Z^{*}}$（即任意边 $e$ 的权值 $w(e)$ 均为正整数），和点 $s, t \\in V$，使得在 $G' = (V, E - S)$ 上不存在 $s$ 到 $t$ 的路径。\n\n\n设 $\\mathfrak{S}$ 是所有满足条件的边集 $S$ 的全集，按 $w(S)$ 从小到大输出 $\\mathfrak{S}$ 中前 $k$ 小的边集的边权和。其中 $w(S) = \\sum_{e \\in S} w(e)$。\n", "inputFormat": "第一行包含 $5$ 个正整数 $n, m, s, t, k$，其中 $s, t, k$ 意义如上，$n, m$ 分别表示 $\\lvert V \\rvert, \\lvert E \\rvert$（即点数和边数）。规定图中的节点用 $1$ 到 $n$ 的整数表示。保证 $s \\neq t$。\n\n\n接下来 $m$ 行，每行 $3$ 个整数 $x, y, z$，表示一条边权为 $z$ 的从 $x$ 到 $y$ 的边。可能有重边但保证没有自环。\n", "outputFormat": "如果 $\\lvert \\mathfrak{S} \\rvert < k$，先输出 $\\lvert \\mathfrak{S} \\rvert$ 行，每行包含一个整数，表示前 $\\lvert \\mathfrak{S} \\rvert$ 个 $w(S)$；再输出一行一个整数 $-1$。\n\n\n如果 $\\lvert \\mathfrak{S} \\rvert \\geq k$，则输出 $k$ 行，表示前 $k$ 个 $w(S)$。\n\n\n两种情况均需按照 $w(S)$ 从小到大输出。\n", "hint": "| 测试点编号 | $n \\le$ | $m$ | $k \\le$ | 约束 |\n|:-:|:-:|:-:|:-:|:-:|\n| $1 \\sim 2$ | $10$ | $\\le 20$ | ${10}^6$ | 边权不超过 $65536$ |\n| $3 \\sim 6$ | $50$ | $\\le 100$ | $100$ | 边权不超过 $65536$ |\n| $7 \\sim 10$ | $3000$ | $= 2 n - 4$ | $5 \\times {10}^5$ | $s$ 有边连向所有非 $t$ 节点，所有非 $s$ 结点有边连向 $t$，边权不超过 $2^{31} - 1$ |\n| $11 \\sim 14$ | $1.5 \\times {10}^5$ | $= 2 n - 4$ | $5 \\times {10}^5$ | $s$ 有边连向所有非 $t$ 节点，所有非 $s$ 结点有边连向 $t$，边权不超过 $2^{31} - 1$ |\n| $15 \\sim 20$ | $50$ | $\\le 1500$ | $100$ | 边权不超过 $65536$ |", "locale": "zh-CN"}}}
{"pid": "P4154", "type": "P", "difficulty": 7, "samples": [["3 2 4 1\n0 1 2 2 2", "001\n010\n1110"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2015", "Special Judge", "WC"], "title": "[WC2015] 混淆与破解", "background": "", "description": "小强和阿米巴是好朋友。\n\n\n阿米巴研发出了一套相当高端的图片识别系统，并把它写成了一个手机app。这个识别系统具备特殊的识别能力，比如说，它能够识别一张图片里是否有萌萌的小狗。\n\n\n这个app由两个模块组成，特征提取模块和分类模块。每当小强拍摄一张图片，特征提取模块就从中提取出一个长度为 $n$ 的 01 串并存储起来。当小强希望进行识别的时候，分类模块就会根据提取出的 01 串进行分类（即，输出一个 $0$ 或者 $1$ 的答案）。\n\n\n为了保护分类算法，阿米巴的这个 app 是经过加密处理的。经过对阿米巴的死缠烂打，小强弄明白了这个分类算法的工作原理。\n\n\n分类模块会从输入的这个 $n$ 位 01 串中恢复出 $m$ 位的“有效信息”。每个“有效信息” 都是经过某些输入变量的异或。之后，分类模块会利用这些 “有效信息” 进行运算来得到真正的结果。为了进一步加密，阿米巴还会加入 “噪声”。所谓 “噪声”，是指这个分类模块会故意按一定的比例将结果反转。小强拿到的可能是经过了反转的结果。\n\n\n举个例子，分类模块的算法步骤可能是这样的：\n\n```cpp\nfunction f(x[]):\n    z[0] = x[0] xor x[4] xor x[7]\n    z[1] = x[12] xor x[2]\n    z[2] = x[0] xor x[1] xor x[2] xor x[3]\n    result = h(z[])\n    return result xor g(x[])\n```\n其中 x[] 是一个 01 串，x[i] 表示其中的第 $i$ 位，即一个 $0$ 或 $1$ 的函数。\n\n\ng(x[]) 是某个在大多数情况下返回 $0$，偶尔返回 $1$ 的函数。$h$ 是某个关于 z[] 的函数，其返回值为 $0$ 或 $1$。\n\n\nz[0], z[1], z[2] 就是 “有效信息”。\n\n\n为了让小强无法从app中看出算法，这个算法被进行了混淆。为了方便起见，我们把混淆之后的算法叫做“混淆版算法”。混淆版算法的代码共有 $Q$ 行，它的每一行都是这个样子：\n\n```cpp\ny[u] = (not (y[v] and y[s])) xor y[d] xor y[e]\n```\n其中 y[] 是一个长度为 $L$ 的 01 数组；xor 表示异或，and 表示与，not 表示非。$u, v, s, d, e$ 是这一行的参数。初始的时候，y[0]～y[n - 1] 里面放置了 x[0]～x[n - 1] 这 $n$ 个输入位，其他地方都是 $0$。执行完这 $Q$ 行代码之后，y[0] 这个位就是输出。\n\n\n对于阿米巴的这种以损失性能为代价进行加密的行径，小强感到很愤怒。于是，小强打算从混淆版算法中破解出阿米巴的分类算法。为了方便起见，我们把破解得到的算法叫做“破解版算法”。小强希望你能够帮他破解出：\n\n\n如何提取有效信息。这个可以表述为 $m$ 个 $\\{0, 1, \\dots, n - 1\\}$ 的子集，每个子集对应了一个有效信息是从哪几个输入位异或得到的；\n\n把这 $m$ 位有效信息映射到分类结果上的函数 $h$。该函数用一个长度为 $2^m$，每一位均为 $0$ 或 $1$ 的查找表表示；这 $2^m$ 位分别对应了 $m$ 位有效信息每一种可能的情况。\n\n当然，这种破解算法是不唯一的，即，可能会有多种有效信息提取方法和查找表的组合。你只需要给出其中的一种即可。\n\n\n阿米巴保证，引入的噪声比例不超过 $p$。即，你需要求出的破解版算法，和混淆版算法至少在 $2^n(1 - p)$ 个不同输入上得到的结果是一样的；并且阿米巴保证这样的算法是存在的。\n\n\n同时，阿米巴也保证，这 $m$ 个有效信息都是必须的，即，$h$ 无法化简为少于 $m$ 个输入的函数。\n", "inputFormat": "第一行包含 $4$ 个整数 $n, m, L, Q$。\n\n\n接下来 $Q$ 行，每行包含 $5$ 个整数 $u, v, s, d, e$，表示每行的参数。\n", "outputFormat": "先输出 $m$ 行，每行包含 $1$ 个 $n$ 位 01 串，表示每个有效信息是由哪些输入位异或得到的。其中 $1$ 表示包含该输入位，$0$ 表示不包含。\n\n\n接下来输出一行一个长度为 $2^m$ 的 01 串，表示 $h$ 函数的查找表。查找表中的项按字典序进行排列。即，先排第一个有效信息是 $0$ 的，再排第一个有效信息是 $1$ 的。排第一个有效信息是 $0$ 的项的时候，先排第二个有效信息是 $0$ 的，再排第二个有效信息是 $1$ 的，以此类推。\n", "hint": "【样例解释】\n\n样例输入等价于如下代码\n\n```cpp\ny[] = 0000\ninput x[0..n-1]\ny[0..n-1] = x[0..n-1]\ny[0] = (not (y[1] and y[2])) xor y[2] xor y[2]\noutput y[0]\n```\n其中 x[0..n-1] 表示 01 串 $x$ 的第 $0$ 位到第 $n - 1$ 位。\n\n\n在这段代码中，每一种输入对应的输出如下：\n\n```cpp\ninput    000    001    010    011    100    101    110    111\noutput    1    1    1    0    1    1    1    0\n```\n样例输出是一种破解方案，等价于如下代码：\n\n```cpp\ninput x[0..n-1]\nz[0] = x[2]\nz[1] = x[1]\noutput h(z[])\n```\n$h$ 函数的输入和输出有如下对应关系：\n\n```cpp\nz[]        00    01    10    11\nh(z[])    1    1    1    0\n```\n可以发现，对于每一种输入，破解版算法和混淆版算法的输出是相同的。\n\n\n\n【限制与约定】\n\n\n对于 10% 的数据，$m = 1$，$p = 0$；\n\n对于另外 30% 的数据，$m = 1$；\n\n对于另外 20% 的数据，$m = 2$；\n\n对于另外 20% 的数据，$m = 3$；\n\n对于另外 20% 的数据，$m = 4$。\n\n对于所有的数据，$1 \\leq n \\leq 64$，$1 \\leq L \\leq 256$，$1 \\leq Q \\leq 1024$，$0 \\leq p \\leq 0.01$，$0 \\leq u, v, s, d, e < L$（注意，输入中并没有把 $p$ 的值给你）。\n\n\n【提示】\n\n使用位运算一次在多个输入上求出函数值可以极大的加速你的程序。\n", "locale": "zh-CN", "translations": {"en": {"title": "[WC2015] Obfuscation and Cracking", "background": "", "description": "Xiaoqiang and Amiba are good friends.\n\nAmiba developed a fairly advanced image recognition system and released it as a mobile app. This recognition system has special capabilities; for example, it can recognize whether there is a cute puppy in a picture.\n\nThe app consists of two modules: a feature extraction module and a classification module. Every time Xiaoqiang takes a photo, the feature extraction module extracts a length-$n$ binary string and stores it. When Xiaoqiang wants a recognition result, the classification module classifies based on the extracted binary string (i.e., outputs either $0$ or $1$).\n\nTo protect the classification algorithm, Amiba encrypted the app. After much pestering, Xiaoqiang figured out how the classification algorithm works.\n\nThe classification module recovers $m$ bits of “effective information” from the $n$-bit input binary string. Each “effective information” bit is the XOR of some input variables. Then, the classification module uses these “effective information” bits to compute the final result. To further obfuscate, Amiba also adds “noise”, meaning the module intentionally flips the result with a certain probability. The result Xiaoqiang gets may be flipped.\n\nFor example, the steps of the classification module could be:\n\n```cpp\nfunction f(x[]):\n    z[0] = x[0] xor x[4] xor x[7]\n    z[1] = x[12] xor x[2]\n    z[2] = x[0] xor x[1] xor x[2] xor x[3]\n    result = h(z[])\n    return result xor g(x[])\n```\nHere x[] is a binary string, and x[i] denotes its $i$-th bit, i.e., either $0$ or $1$.\n\ng(x[]) is a function that returns $0$ in most cases and occasionally returns $1$. $h$ is some function of z[] whose return value is $0$ or $1$.\n\nz[0], z[1], z[2] are the “effective information”.\n\nTo prevent Xiaoqiang from seeing the algorithm directly in the app, the algorithm was obfuscated. For convenience, we call the obfuscated algorithm the “obfuscated version”. The obfuscated version has $Q$ lines of code, each of the form:\n\n```cpp\ny[u] = (not (y[v] and y[s])) xor y[d] xor y[e]\n```\nHere y[] is a length-$L$ binary array; xor means XOR, and means AND, and not means NOT. $u, v, s, d, e$ are the parameters on that line. Initially, y[0] through y[n - 1] hold x[0] through x[n - 1], and all other positions are $0$. After executing these $Q$ lines, y[0] is the output.\n\nAngered by Amiba’s practice of trading performance for encryption, Xiaoqiang decides to recover the classification algorithm from the obfuscated version. For convenience, we call the recovered algorithm the “cracked version”. Xiaoqiang hopes you can help him recover:\n\n- How to extract the effective information. This can be represented as $m$ subsets of $\\{0, 1, \\dots, n - 1\\}$, where each subset indicates which input bits are XORed to produce one effective information bit.\n- The function $h$ mapping these $m$ effective information bits to the classification result. This function is represented by a lookup table of length $2^m$ whose entries are $0$ or $1$. These $2^m$ entries correspond to all possible values of the $m$ effective information bits.\n\nOf course, the recovered algorithm is not unique; multiple combinations of effective information extraction and lookup tables may work. You only need to provide one.\n\nAmiba guarantees that the noise rate is at most $p$. That is, your cracked version and the obfuscated version must agree on at least $2^n (1 - p)$ different inputs, and Amiba guarantees such an algorithm exists.\n\nAmiba also guarantees that all $m$ effective information bits are necessary, i.e., $h$ cannot be simplified to a function of fewer than $m$ inputs.", "inputFormat": "The first line contains 4 integers $n, m, L, Q$.\n\nThen follow $Q$ lines, each containing 5 integers $u, v, s, d, e$, giving the parameters of each line.", "outputFormat": "First output $m$ lines, each containing an $n$-bit binary string that indicates which input bits are XORed to produce each effective information bit. A 1 means the input bit is included; a 0 means it is not included.\n\nThen output one line containing a binary string of length $2^m$ representing the lookup table of the function $h$. The entries are listed in lexicographic order: first list entries where the first effective information bit is $0$, then where it is $1$. While listing entries where the first effective information bit is $0$, first list those where the second effective information bit is $0$, then where it is $1$, and so on.", "hint": "[Sample explanation]\n\nThe sample input is equivalent to the following code:\n\n```cpp\ny[] = 0000\ninput x[0..n-1]\ny[0..n-1] = x[0..n-1]\ny[0] = (not (y[1] and y[2])) xor y[2] xor y[2]\noutput y[0]\n```\nHere x[0..n-1] denotes bits $0$ through $n - 1$ of the binary string $x$.\n\nIn this code, the output for each input is:\n\n```cpp\ninput    000    001    010    011    100    101    110    111\noutput   1      1      1      0      1      1      1      0\n```\nA sample cracked solution is equivalent to:\n\n```cpp\ninput x[0..n-1]\nz[0] = x[2]\nz[1] = x[1]\noutput h(z[])\n```\nThe inputs and outputs of the function $h$ are:\n\n```cpp\nz[]       00    01    10    11\nh(z[])    1     1     1     0\n```\nYou can verify that for every input, the cracked version and the obfuscated version produce the same output.\n\nConstraints\n\n- For 10% of the testdata, $m = 1$, $p = 0$.\n- For another 30% of the testdata, $m = 1$.\n- For another 20% of the testdata, $m = 2$.\n- For another 20% of the testdata, $m = 3$.\n- For another 20% of the testdata, $m = 4$.\n- For all testdata, $1 \\leq n \\leq 64$, $1 \\leq L \\leq 256$, $1 \\leq Q \\leq 1024$, $0 \\leq p \\leq 0.01$, and $0 \\leq u, v, s, d, e < L$ (note that the value of $p$ is not provided in the input).\n\nTip\n\nUsing bitwise operations to evaluate the function on many inputs at once can greatly speed up your program.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2015] 混淆与破解", "background": "", "description": "小强和阿米巴是好朋友。\n\n\n阿米巴研发出了一套相当高端的图片识别系统，并把它写成了一个手机app。这个识别系统具备特殊的识别能力，比如说，它能够识别一张图片里是否有萌萌的小狗。\n\n\n这个app由两个模块组成，特征提取模块和分类模块。每当小强拍摄一张图片，特征提取模块就从中提取出一个长度为 $n$ 的 01 串并存储起来。当小强希望进行识别的时候，分类模块就会根据提取出的 01 串进行分类（即，输出一个 $0$ 或者 $1$ 的答案）。\n\n\n为了保护分类算法，阿米巴的这个 app 是经过加密处理的。经过对阿米巴的死缠烂打，小强弄明白了这个分类算法的工作原理。\n\n\n分类模块会从输入的这个 $n$ 位 01 串中恢复出 $m$ 位的“有效信息”。每个“有效信息” 都是经过某些输入变量的异或。之后，分类模块会利用这些 “有效信息” 进行运算来得到真正的结果。为了进一步加密，阿米巴还会加入 “噪声”。所谓 “噪声”，是指这个分类模块会故意按一定的比例将结果反转。小强拿到的可能是经过了反转的结果。\n\n\n举个例子，分类模块的算法步骤可能是这样的：\n\n```cpp\nfunction f(x[]):\n    z[0] = x[0] xor x[4] xor x[7]\n    z[1] = x[12] xor x[2]\n    z[2] = x[0] xor x[1] xor x[2] xor x[3]\n    result = h(z[])\n    return result xor g(x[])\n```\n其中 x[] 是一个 01 串，x[i] 表示其中的第 $i$ 位，即一个 $0$ 或 $1$ 的函数。\n\n\ng(x[]) 是某个在大多数情况下返回 $0$，偶尔返回 $1$ 的函数。$h$ 是某个关于 z[] 的函数，其返回值为 $0$ 或 $1$。\n\n\nz[0], z[1], z[2] 就是 “有效信息”。\n\n\n为了让小强无法从app中看出算法，这个算法被进行了混淆。为了方便起见，我们把混淆之后的算法叫做“混淆版算法”。混淆版算法的代码共有 $Q$ 行，它的每一行都是这个样子：\n\n```cpp\ny[u] = (not (y[v] and y[s])) xor y[d] xor y[e]\n```\n其中 y[] 是一个长度为 $L$ 的 01 数组；xor 表示异或，and 表示与，not 表示非。$u, v, s, d, e$ 是这一行的参数。初始的时候，y[0]～y[n - 1] 里面放置了 x[0]～x[n - 1] 这 $n$ 个输入位，其他地方都是 $0$。执行完这 $Q$ 行代码之后，y[0] 这个位就是输出。\n\n\n对于阿米巴的这种以损失性能为代价进行加密的行径，小强感到很愤怒。于是，小强打算从混淆版算法中破解出阿米巴的分类算法。为了方便起见，我们把破解得到的算法叫做“破解版算法”。小强希望你能够帮他破解出：\n\n\n如何提取有效信息。这个可以表述为 $m$ 个 $\\{0, 1, \\dots, n - 1\\}$ 的子集，每个子集对应了一个有效信息是从哪几个输入位异或得到的；\n\n把这 $m$ 位有效信息映射到分类结果上的函数 $h$。该函数用一个长度为 $2^m$，每一位均为 $0$ 或 $1$ 的查找表表示；这 $2^m$ 位分别对应了 $m$ 位有效信息每一种可能的情况。\n\n当然，这种破解算法是不唯一的，即，可能会有多种有效信息提取方法和查找表的组合。你只需要给出其中的一种即可。\n\n\n阿米巴保证，引入的噪声比例不超过 $p$。即，你需要求出的破解版算法，和混淆版算法至少在 $2^n(1 - p)$ 个不同输入上得到的结果是一样的；并且阿米巴保证这样的算法是存在的。\n\n\n同时，阿米巴也保证，这 $m$ 个有效信息都是必须的，即，$h$ 无法化简为少于 $m$ 个输入的函数。\n", "inputFormat": "第一行包含 $4$ 个整数 $n, m, L, Q$。\n\n\n接下来 $Q$ 行，每行包含 $5$ 个整数 $u, v, s, d, e$，表示每行的参数。\n", "outputFormat": "先输出 $m$ 行，每行包含 $1$ 个 $n$ 位 01 串，表示每个有效信息是由哪些输入位异或得到的。其中 $1$ 表示包含该输入位，$0$ 表示不包含。\n\n\n接下来输出一行一个长度为 $2^m$ 的 01 串，表示 $h$ 函数的查找表。查找表中的项按字典序进行排列。即，先排第一个有效信息是 $0$ 的，再排第一个有效信息是 $1$ 的。排第一个有效信息是 $0$ 的项的时候，先排第二个有效信息是 $0$ 的，再排第二个有效信息是 $1$ 的，以此类推。\n", "hint": "【样例解释】\n\n样例输入等价于如下代码\n\n```cpp\ny[] = 0000\ninput x[0..n-1]\ny[0..n-1] = x[0..n-1]\ny[0] = (not (y[1] and y[2])) xor y[2] xor y[2]\noutput y[0]\n```\n其中 x[0..n-1] 表示 01 串 $x$ 的第 $0$ 位到第 $n - 1$ 位。\n\n\n在这段代码中，每一种输入对应的输出如下：\n\n```cpp\ninput    000    001    010    011    100    101    110    111\noutput    1    1    1    0    1    1    1    0\n```\n样例输出是一种破解方案，等价于如下代码：\n\n```cpp\ninput x[0..n-1]\nz[0] = x[2]\nz[1] = x[1]\noutput h(z[])\n```\n$h$ 函数的输入和输出有如下对应关系：\n\n```cpp\nz[]        00    01    10    11\nh(z[])    1    1    1    0\n```\n可以发现，对于每一种输入，破解版算法和混淆版算法的输出是相同的。\n\n\n\n【限制与约定】\n\n\n对于 10% 的数据，$m = 1$，$p = 0$；\n\n对于另外 30% 的数据，$m = 1$；\n\n对于另外 20% 的数据，$m = 2$；\n\n对于另外 20% 的数据，$m = 3$；\n\n对于另外 20% 的数据，$m = 4$。\n\n对于所有的数据，$1 \\leq n \\leq 64$，$1 \\leq L \\leq 256$，$1 \\leq Q \\leq 1024$，$0 \\leq p \\leq 0.01$，$0 \\leq u, v, s, d, e < L$（注意，输入中并没有把 $p$ 的值给你）。\n\n\n【提示】\n\n使用位运算一次在多个输入上求出函数值可以极大的加速你的程序。\n", "locale": "zh-CN"}}}
{"pid": "P4155", "type": "P", "difficulty": 5, "samples": [["4 8\n2 5\n4 7\n6 1\n7 3", "3 3 4 3"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["贪心", "2015", "四川", "倍增", "二分", "各省省选", "排序"], "title": "[SCOI2015] 国旗计划", "background": null, "description": "A 国正在开展一项伟大的计划 —— 国旗计划。这项计划的内容是边防战士手举国旗环绕边境线奔袭一圈。这项计划需要多名边防战士以接力的形式共同完成，为此，国土安全局已经挑选了 $N$ 名优秀的边防战士作为这项计划的候选人。\n\n\nA 国幅员辽阔，边境线上设有 $M$ 个边防站，顺时针编号 $1$ 至 $M$。每名边防战士常驻两个边防站，并且善于在这两个边防站之间长途奔袭，我们称这两个边防站之间的路程是这个边防战士的奔袭区间。$N$ 名边防战士都是精心挑选的，身体素质极佳，所以每名边防战士的奔袭区间都不会被其他边防战士的奔袭区间所包含。\n\n\n现在，国土安全局局长希望知道，至少需要多少名边防战士，才能使得他们的奔袭区间覆盖全部的边境线，从而顺利地完成国旗计划。不仅如此，安全局局长还希望知道更详细的信息：对于每一名边防战士，在他必须参加国旗计划的前提下，至少需要多少名边防战士才能覆盖全部边境线，从而顺利地完成国旗计划。", "inputFormat": "第一行，包含两个正整数 $N,M$，分别表示边防战士数量和边防站数量。\n\n\n随后 $N$ 行，每行包含两个正整数。其中第 $i$ 行包含的两个正整数 $C_i$、$D_i$ 分别表示 $i$ 号边防战士常驻的两个边防站编号，$C_i$ 号边防站沿顺时针方向至 $D_i$ 号边防站为他的奔袭区间。数据保证整个边境线都是可被覆盖的。", "outputFormat": "输出数据仅 $1$ 行，需要包含 $N$ 个正整数。其中，第 $j$ 个正整数表示 $j$ 号边防战士必须参加的前提下至少需要多少名边防战士才能顺利地完成国旗计划。", "hint": "$N\\leq 2×10^5,M<10^9,1\\leq C_i,D_i\\leq M$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2015] National Flag Plan", "background": "", "description": "Country A is carrying out a great plan — the National Flag Plan. In this plan, border guards will run a full loop along the border line in relay while holding the national flag. This requires multiple border guards working together in relay. The National Security Agency has selected $N$ outstanding border guards as candidates.\n\nCountry A is vast, and there are $M$ border posts on the border line, numbered $1$ to $M$ clockwise. Each border guard is based at two border posts and is skilled at long-distance running between these two posts. We call the path between these two posts the guard’s running interval. The $N$ guards are carefully selected and in excellent physical condition, so no guard’s running interval is contained within another guard’s running interval.\n\nThe director of the National Security Agency wants to know the minimum number of border guards whose running intervals can cover the entire border line to successfully complete the National Flag Plan. Moreover, for each border guard, under the condition that he must participate, the director also wants to know the minimum number of border guards required to cover the entire border line.", "inputFormat": "The first line contains two positive integers $N, M$, the number of border guards and the number of border posts.\n\nThen follow $N$ lines, each containing two positive integers. On the $i$-th line, the two integers $C_i, D_i$ denote the indices of the two border posts where guard $i$ is based. The running interval of guard $i$ is from post $C_i$ to post $D_i$ in the clockwise direction. It is guaranteed that the entire border line can be covered.", "outputFormat": "Output a single line containing $N$ positive integers. The $j$-th integer denotes, under the condition that guard $j$ must participate, the minimum number of border guards required to successfully complete the National Flag Plan.", "hint": "Constraints: $N \\leq 2 \\times 10^5, M < 10^9, 1 \\leq C_i, D_i \\leq M$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2015] 国旗计划", "background": null, "description": "A 国正在开展一项伟大的计划 —— 国旗计划。这项计划的内容是边防战士手举国旗环绕边境线奔袭一圈。这项计划需要多名边防战士以接力的形式共同完成，为此，国土安全局已经挑选了 $N$ 名优秀的边防战士作为这项计划的候选人。\n\n\nA 国幅员辽阔，边境线上设有 $M$ 个边防站，顺时针编号 $1$ 至 $M$。每名边防战士常驻两个边防站，并且善于在这两个边防站之间长途奔袭，我们称这两个边防站之间的路程是这个边防战士的奔袭区间。$N$ 名边防战士都是精心挑选的，身体素质极佳，所以每名边防战士的奔袭区间都不会被其他边防战士的奔袭区间所包含。\n\n\n现在，国土安全局局长希望知道，至少需要多少名边防战士，才能使得他们的奔袭区间覆盖全部的边境线，从而顺利地完成国旗计划。不仅如此，安全局局长还希望知道更详细的信息：对于每一名边防战士，在他必须参加国旗计划的前提下，至少需要多少名边防战士才能覆盖全部边境线，从而顺利地完成国旗计划。", "inputFormat": "第一行，包含两个正整数 $N,M$，分别表示边防战士数量和边防站数量。\n\n\n随后 $N$ 行，每行包含两个正整数。其中第 $i$ 行包含的两个正整数 $C_i$、$D_i$ 分别表示 $i$ 号边防战士常驻的两个边防站编号，$C_i$ 号边防站沿顺时针方向至 $D_i$ 号边防站为他的奔袭区间。数据保证整个边境线都是可被覆盖的。", "outputFormat": "输出数据仅 $1$ 行，需要包含 $N$ 个正整数。其中，第 $j$ 个正整数表示 $j$ 号边防战士必须参加的前提下至少需要多少名边防战士才能顺利地完成国旗计划。", "hint": "$N\\leq 2×10^5,M<10^9,1\\leq C_i,D_i\\leq M$。", "locale": "zh-CN"}}}
{"pid": "P4156", "type": "P", "difficulty": 7, "samples": [["1\n4 11\nbbab", "5"], ["2\n44 1000\nbaaaaaabaabbaaabbbbabbbaaabbbababaaabaaabaaa\n41 1000\nabaabbabaaabaabbbbbbbbbbbababbbbaaabaabbb", "195\n24"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "单调队列", "数论", "图论建模", "最短路", "KMP 算法", "WC"], "title": "[WC2016] 论战捆竹竿", "background": "", "description": "是一个美好的下午，小 W 和小 C 在竹林里切磋捆竹竿的技艺。\n\n竹林里有无数根完全一样的短竹子，每一根竹子由 $n$ 节组成。\n\n这些竹子比较特别，每一节都被染上了颜色。可能的颜色一共 $26$ 种，分别用小写英文字母 $\\underline{a}$ 到 $\\underline{z}$ 表示。也就是说，如果把竹子的底端到顶端的颜色按顺序写出来可以排成一个由小写英文字母组成的字符串。\n\n小 W 和小 C 都是捆竹竿的高手，他们知道怎样才能把零散的短竹子捆成一整根长竹竿。 初始时你拿着一根短竹子作为当前的竹竿。 每次你可以选择一根短竹子，短竹子底端若干节（可以是 $0$ 节）与竹竿的最上面若干节对应地一节一节捆起来，而短竹子前面剩下的节伸出去，这样就得到了一根更长的竹竿。注意，竹子的底端是靠近根部的那一端，不可以颠倒。\n\n小 W 对竹竿的审美要求很高， 他捆竹竿时有一个癖好： 如果两根竹子的某两节被捆在了一起，那么它们的颜色必须相同。\n\n我们假设一根短竹子从底端到顶端每节的颜色为 $\\underline{aba}$。\n\n那么两根竹子可以首尾捆在一起，可以得到一根颜色为 $\\underline{abaaba}$ 的竹竿；也可以将第一根顶端的一节 $\\underline{a}$ 与第二根底端的一节 $\\underline{a}$ 捆在一起，得到一根颜色为$\\underline{ababa}$ 的竹竿； 还可以直接将每一节都对应起来，捆成一根颜色为 $\\underline{aba}$ 的竹竿。\n\n假设我们在颜色为 $\\underline{ababa}$ 的竹竿顶端再捆一根竹子，则可以捆成 $\\underline{ababaaba}$，$\\underline{abababa}$ 和 $\\underline{ababa}$ 三种不同的情况。\n\n但是小 C 在这个问题上有不同的看法，他认为小 W 捆不出很多种长度不同的竹竿。小 W 非常不服，于是他找到了你——现在请你求出在竹竿长度不超过 $w$ 的情况下， 小 W 可以捆出多少种长度不同的竹竿。 其中， 竹竿的长度指从底端到顶端的竹子的节的个数。\n\n注意：如果 $w < n$，则没有合法的长度，此时答案为 $0$。\n", "inputFormat": "输入文件 jie.in 第一行包含 $1$ 个整数 $t$，为数据组数。\n\n每组数据的第一行包含 $2$ 个正整数 $n$ 和 $w$， 表示短竹子的长度和竹竿的长度上限。\n\n每组数据的第二行包含一个长度为 $n$ 的字符串，该字符串仅由小写英文字母构成，表示短竹子从底端到顶端每节的颜色。\n", "outputFormat": "输出文件为 jie.out。\n\n输出共 $T$ 行，每行包含一个整数表示捆成竹竿的不同长度种数。\n", "hint": "【样例解释$1$】\n\n可以捆成长度不超过 $11$ 的竹竿有 $6$ 种不同的情况：\n\n```\nbbab\nbbabbab\nbbabbbab\nbbabbabbab\nbbabbabbbab\nbbabbbabbab\n```\n\n后两种竹竿长度相同，因此不同长度的竹竿共有 $5$ 种。长度分别为： $4$， $7$，$8$， $10$， $11$。\n\n【数据规模和约定】\n\n对于所有的测试数据，保证所有的字符串均由小写字母构成。\n\n各测试点满足以下约定：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d4nlqw86.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "[WC2016] On Bundling Bamboo Poles", "background": "", "description": "It is a beautiful afternoon. Little W and Little C are practicing the skill of bundling bamboo poles in a bamboo grove.\n\nThere are infinitely many identical short bamboos in the grove. Each short bamboo consists of $n$ segments.\n\nThese bamboos are special: every segment is dyed a color. There are 26 possible colors, represented by lowercase letters $\\underline{a}$ to $\\underline{z}$. In other words, if you write down the colors from the bottom end to the top end of a bamboo, you get a string of lowercase letters.\n\nLittle W and Little C are masters at bundling bamboos. They know how to bind scattered short bamboos into one long bamboo pole. Initially, you hold one short bamboo as the current pole. Each time, you may choose one short bamboo and bind some number of its bottom segments (possibly $0$) one by one to the top segments of the current pole. The remaining segments in front protrude, producing a longer pole. Note that the bottom end is the end near the root; you cannot flip a bamboo.\n\nLittle W has high aesthetic standards. He has a habit when bundling: if two segments of two bamboos are bound together, then their colors must be the same.\n\nSuppose a short bamboo’s colors from bottom to top are $\\underline{aba}$.\n\nThen two bamboos can be bundled end-to-end to obtain a pole with colors $\\underline{abaaba}$; you can also bind the top segment $\\underline{a}$ of the first bamboo to the bottom segment $\\underline{a}$ of the second bamboo to obtain $\\underline{ababa}$; you can also align every segment and bind them all, forming a pole with colors $\\underline{aba}$.\n\nIf we bundle another short bamboo on top of the pole with colors $\\underline{ababa}$, we can obtain three different outcomes: $\\underline{ababaaba}$, $\\underline{abababa}$, and $\\underline{ababa}$.\n\nHowever, Little C disagrees. He believes Little W cannot produce many different lengths of bamboo poles. Little W is not convinced and asks you for help—please compute, under the constraint that the pole length does not exceed $w$, how many distinct lengths of bamboo poles Little W can produce. Here, the length of a pole is the number of segments from the bottom end to the top end.\n\nNote: If $w < n$, then there is no valid length. In this case, the answer is $0$.", "inputFormat": "The input file is jie.in. The first line contains one integer $T$, the number of test cases.\n\nFor each test case, the first line contains two positive integers $n$ and $w$, representing the length of a short bamboo and the upper bound on the pole length.\n\nThe second line contains a string of length $n$ consisting only of lowercase letters, representing the colors of the short bamboo from the bottom end to the top end.", "outputFormat": "The output file is jie.out.\n\nOutput $T$ lines. Each line contains one integer, the number of distinct lengths obtainable by bundling.", "hint": "[Sample Explanation 1]\n\nThere are 6 different configurations of poles with length not exceeding $11$:\n\n```\nbbab\nbbabbab\nbbabbbab\nbbabbabbab\nbbabbabbbab\nbbabbbabbab\n```\n\nThe last two poles have the same length, so there are 5 distinct lengths. The lengths are: $4$, $7$, $8$, $10$, $11$.\n\nConstraints\n\nFor all testdata, all strings consist of lowercase letters.\n\nEach test point satisfies the following agreement:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d4nlqw86.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2016] 论战捆竹竿", "background": "", "description": "是一个美好的下午，小 W 和小 C 在竹林里切磋捆竹竿的技艺。\n\n竹林里有无数根完全一样的短竹子，每一根竹子由 $n$ 节组成。\n\n这些竹子比较特别，每一节都被染上了颜色。可能的颜色一共 $26$ 种，分别用小写英文字母 $\\underline{a}$ 到 $\\underline{z}$ 表示。也就是说，如果把竹子的底端到顶端的颜色按顺序写出来可以排成一个由小写英文字母组成的字符串。\n\n小 W 和小 C 都是捆竹竿的高手，他们知道怎样才能把零散的短竹子捆成一整根长竹竿。 初始时你拿着一根短竹子作为当前的竹竿。 每次你可以选择一根短竹子，短竹子底端若干节（可以是 $0$ 节）与竹竿的最上面若干节对应地一节一节捆起来，而短竹子前面剩下的节伸出去，这样就得到了一根更长的竹竿。注意，竹子的底端是靠近根部的那一端，不可以颠倒。\n\n小 W 对竹竿的审美要求很高， 他捆竹竿时有一个癖好： 如果两根竹子的某两节被捆在了一起，那么它们的颜色必须相同。\n\n我们假设一根短竹子从底端到顶端每节的颜色为 $\\underline{aba}$。\n\n那么两根竹子可以首尾捆在一起，可以得到一根颜色为 $\\underline{abaaba}$ 的竹竿；也可以将第一根顶端的一节 $\\underline{a}$ 与第二根底端的一节 $\\underline{a}$ 捆在一起，得到一根颜色为$\\underline{ababa}$ 的竹竿； 还可以直接将每一节都对应起来，捆成一根颜色为 $\\underline{aba}$ 的竹竿。\n\n假设我们在颜色为 $\\underline{ababa}$ 的竹竿顶端再捆一根竹子，则可以捆成 $\\underline{ababaaba}$，$\\underline{abababa}$ 和 $\\underline{ababa}$ 三种不同的情况。\n\n但是小 C 在这个问题上有不同的看法，他认为小 W 捆不出很多种长度不同的竹竿。小 W 非常不服，于是他找到了你——现在请你求出在竹竿长度不超过 $w$ 的情况下， 小 W 可以捆出多少种长度不同的竹竿。 其中， 竹竿的长度指从底端到顶端的竹子的节的个数。\n\n注意：如果 $w < n$，则没有合法的长度，此时答案为 $0$。\n", "inputFormat": "输入文件 jie.in 第一行包含 $1$ 个整数 $t$，为数据组数。\n\n每组数据的第一行包含 $2$ 个正整数 $n$ 和 $w$， 表示短竹子的长度和竹竿的长度上限。\n\n每组数据的第二行包含一个长度为 $n$ 的字符串，该字符串仅由小写英文字母构成，表示短竹子从底端到顶端每节的颜色。\n", "outputFormat": "输出文件为 jie.out。\n\n输出共 $T$ 行，每行包含一个整数表示捆成竹竿的不同长度种数。\n", "hint": "【样例解释$1$】\n\n可以捆成长度不超过 $11$ 的竹竿有 $6$ 种不同的情况：\n\n```\nbbab\nbbabbab\nbbabbbab\nbbabbabbab\nbbabbabbbab\nbbabbbabbab\n```\n\n后两种竹竿长度相同，因此不同长度的竹竿共有 $5$ 种。长度分别为： $4$， $7$，$8$， $10$， $11$。\n\n【数据规模和约定】\n\n对于所有的测试数据，保证所有的字符串均由小写字母构成。\n\n各测试点满足以下约定：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d4nlqw86.png)\n", "locale": "zh-CN"}}}
{"pid": "P4157", "type": "P", "difficulty": 5, "samples": [["13", "3\n108\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["高精度", "2006", "四川", "各省省选", "枚举", "快速傅里叶变换 FFT"], "title": "[SCOI2006] 整数划分", "background": "", "description": "从文件中读入一个正整数 $n$（$10 \\le n \\le 31000$）。要求将 $n$ 写成若干个正整数之和，并且使这些正整数的乘积最大。\n\n例如，$n=13$，则当 $n$ 表示为 $4+3+3+3$（或 $2+2+3+3+3$）时，乘积 $=108$ 为最大。", "inputFormat": "一行一个正整数 $n$。", "outputFormat": "第 $1$ 行输出一个整数，为最大乘积的位数。\n\n第 $2$ 行输出最大乘积的前 $100$ 位，如果不足 $100$ 位，则按实际位数输出最大乘积。\n", "hint": "### 数据范围及约定\n\n对于全部数据，$10 \\le n \\le 31000$，同时保证最大乘积的位数不超过 $5000$ 位。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2006] Integer Partition", "background": "", "description": "Read a positive integer $n$ from the file ($10 \\le n \\le 31000$). You need to write $n$ as a sum of several positive integers, and make the product of these integers as large as possible.\n\nFor example, when $n=13$, if $n$ is written as $4+3+3+3$ (or $2+2+3+3+3$), the product $=108$ is maximal.", "inputFormat": "One line with a positive integer $n$.", "outputFormat": "Line 1: output an integer, the number of digits of the maximum product.\n\nLine 2: output the first 100 digits of the maximum product. If it has fewer than 100 digits, output the maximum product with its actual number of digits.", "hint": "Constraints\n\nFor all testdata, $10 \\le n \\le 31000$, and it is guaranteed that the number of digits of the maximum product does not exceed 5000 digits.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2006] 整数划分", "background": "", "description": "从文件中读入一个正整数 $n$（$10 \\le n \\le 31000$）。要求将 $n$ 写成若干个正整数之和，并且使这些正整数的乘积最大。\n\n例如，$n=13$，则当 $n$ 表示为 $4+3+3+3$（或 $2+2+3+3+3$）时，乘积 $=108$ 为最大。", "inputFormat": "一行一个正整数 $n$。", "outputFormat": "第 $1$ 行输出一个整数，为最大乘积的位数。\n\n第 $2$ 行输出最大乘积的前 $100$ 位，如果不足 $100$ 位，则按实际位数输出最大乘积。\n", "hint": "### 数据范围及约定\n\n对于全部数据，$10 \\le n \\le 31000$，同时保证最大乘积的位数不超过 $5000$ 位。", "locale": "zh-CN"}}}
{"pid": "P4158", "type": "P", "difficulty": 5, "samples": [["3 6 3\n111111\n000000\n001100", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2009", "四川", "各省省选", "枚举", "背包 DP"], "title": "[SCOI2009] 粉刷匠", "background": "", "description": "windy 有 $N$ 条木板需要被粉刷。 每条木板被分为 $M$ 个格子。 每个格子要被刷成红色或蓝色。\n\nwindy 每次粉刷，只能选择一条木板上一段连续的格子，然后涂上一种颜色。 每个格子最多只能被粉刷一次。\n\n如果 windy 只能粉刷 $T$ 次，他最多能正确粉刷多少格子？\n\n一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。\n\n", "inputFormat": "第一行包含三个整数，$N,M,T$。\n\n接下来有 $N$ 行，每行一个长度为 $M$ 的字符串，``0`` 表示红色，`1` 表示蓝色。\n", "outputFormat": "包含一个整数，最多能正确粉刷的格子数。\n", "hint": "$30\\%$ 的数据，满足 $1 \\le N,M \\le 10,0 \\le T \\le 100$ 。\n\n$100\\%$ 的数据，满足 $1 \\le N,M \\le 50,0 \\le T \\le 2500$ ", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2009] Painter", "background": "", "description": "windy has $N$ wooden boards that need to be painted. Each board is divided into $M$ cells. Each cell should be painted red or blue.\n\nIn each painting operation, windy can choose a contiguous segment of cells on a single board and paint it with one color. Each cell can be painted at most once.\n\nIf windy can paint at most $T$ times, what is the maximum number of cells he can paint correctly?\n\nA cell is considered incorrect if it is left unpainted or painted with the wrong color.", "inputFormat": "The first line contains three integers, $N$, $M$, $T$.\n\nThen there are $N$ lines, each containing a string of length $M$, where `0` denotes red and `1` denotes blue.", "outputFormat": "Output a single integer: the maximum number of cells that can be painted correctly.", "hint": "For $30\\%$ of the testdata, $1 \\le N, M \\le 10$, $0 \\le T \\le 100$.\n\nFor $100\\%$ of the testdata, $1 \\le N, M \\le 50$, $0 \\le T \\le 2500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2009] 粉刷匠", "background": "", "description": "windy 有 $N$ 条木板需要被粉刷。 每条木板被分为 $M$ 个格子。 每个格子要被刷成红色或蓝色。\n\nwindy 每次粉刷，只能选择一条木板上一段连续的格子，然后涂上一种颜色。 每个格子最多只能被粉刷一次。\n\n如果 windy 只能粉刷 $T$ 次，他最多能正确粉刷多少格子？\n\n一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。\n\n", "inputFormat": "第一行包含三个整数，$N,M,T$。\n\n接下来有 $N$ 行，每行一个长度为 $M$ 的字符串，``0`` 表示红色，`1` 表示蓝色。\n", "outputFormat": "包含一个整数，最多能正确粉刷的格子数。\n", "hint": "$30\\%$ 的数据，满足 $1 \\le N,M \\le 10,0 \\le T \\le 100$ 。\n\n$100\\%$ 的数据，满足 $1 \\le N,M \\le 50,0 \\le T \\le 2500$ ", "locale": "zh-CN"}}}
{"pid": "P4159", "type": "P", "difficulty": 5, "samples": [["2 2\n11\n00", "1\n\n"], ["5 30\n12045\n07105\n47805\n12024\n12345\n", "852"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "四川", "各省省选", "矩阵加速", "矩阵乘法"], "title": "[SCOI2009] 迷路", "background": "windy 在有向图中迷路了。", "description": "该有向图有 $n$ 个节点，节点从 $1$ 至 $n$ 编号，windy 从节点 $1$ 出发，他必须恰好在 $t$ 时刻到达节点 $n$。\n\n现在给出该有向图，你能告诉 windy 总共有多少种不同的路径吗？ \n\n答案对 $2009$ 取模。\n\n注意：windy 不能在某个节点逗留，且通过某有向边的时间严格为给定的时间。\n\n\n", "inputFormat": "第一行包含两个整数，分别代表 $n$ 和 $t$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个长度为 $n$ 的字符串，第 $(i + 1)$ 行的第 $j$ 个字符 $c_{i, j}$ 是一个数字字符，若为 $0$，则代表节点 $i$ 到节点 $j$ 无边，否则代表节点 $i$ 到节点 $j$ 的边的长度为 $c_{i, j}$。", "outputFormat": "输出一行一个整数代表答案对 $2009$ 取模的结果。", "hint": "#### 样例输入输出 1 解释\n\n路径为 $1 \\to 1 \\to 2$。\n\n#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\leq 5$，$t \\leq 30$。\n- 对于 $100\\%$ 的数据，保证 $2 \\leq n \\leq 10$，$1 \\leq t \\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2009] Lost", "background": "windy got lost in a directed graph.", "description": "The directed graph has $n$ nodes, numbered from $1$ to $n$. windy starts from node $1$ and must arrive at node $n$ exactly at time $t$.\n\nGiven the directed graph, can you tell windy how many different paths there are?\n\nThe answer is taken modulo $2009$.\n\nNote: windy cannot wait at any node, and the time to traverse any directed edge is exactly the specified time.", "inputFormat": "The first line contains two integers, $n$ and $t$.\n\nLines $2$ to $n+1$ each contain a string of length $n$. In line $(i+1)$, the $j$-th character $c_{i,j}$ is a digit. If it is $0$, there is no edge from node $i$ to node $j$; otherwise, the length of the edge from node $i$ to node $j$ is $c_{i,j}$.", "outputFormat": "Output a single integer: the answer modulo $2009$.", "hint": "- Explanation for Sample Input/Output 1  \n  The path is $1 \\to 1 \\to 2$.\n\n- Constraints\n  - For $30\\%$ of the testdata, $n \\leq 5$, $t \\leq 30$.\n  - For $100\\%$ of the testdata, $2 \\leq n \\leq 10$, $1 \\leq t \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2009] 迷路", "background": "windy 在有向图中迷路了。", "description": "该有向图有 $n$ 个节点，节点从 $1$ 至 $n$ 编号，windy 从节点 $1$ 出发，他必须恰好在 $t$ 时刻到达节点 $n$。\n\n现在给出该有向图，你能告诉 windy 总共有多少种不同的路径吗？ \n\n答案对 $2009$ 取模。\n\n注意：windy 不能在某个节点逗留，且通过某有向边的时间严格为给定的时间。\n\n\n", "inputFormat": "第一行包含两个整数，分别代表 $n$ 和 $t$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个长度为 $n$ 的字符串，第 $(i + 1)$ 行的第 $j$ 个字符 $c_{i, j}$ 是一个数字字符，若为 $0$，则代表节点 $i$ 到节点 $j$ 无边，否则代表节点 $i$ 到节点 $j$ 的边的长度为 $c_{i, j}$。", "outputFormat": "输出一行一个整数代表答案对 $2009$ 取模的结果。", "hint": "#### 样例输入输出 1 解释\n\n路径为 $1 \\to 1 \\to 2$。\n\n#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\leq 5$，$t \\leq 30$。\n- 对于 $100\\%$ 的数据，保证 $2 \\leq n \\leq 10$，$1 \\leq t \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4160", "type": "P", "difficulty": 4, "samples": [["5 5 5", "1.800000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2009", "四川", "各省省选", "深度优先搜索 DFS"], "title": "[SCOI2009] 生日快乐", "background": "", "description": "windy 的生日到了，为了庆祝生日，他的朋友们帮他买了一个边长分别为 $X$ 和 $Y$ 的矩形蛋糕。\n\n现在包括 windy，一共有 $N$ 个人来分这块大蛋糕，要求每个人必须获得相同面积的蛋糕。\n\nwindy 主刀，每一切只能平行于一块蛋糕的一边（任意一边），并且必须把这块蛋糕切成两块。\n\n这样，要切成 $N$ 块蛋糕，windy 必须切 $N-1$ 次。\n\n为了使得每块蛋糕看起来漂亮，我们要求 $N$ 块蛋糕的长边与短边的比值的最大值最小。\n\n你能帮助 windy 求出这个比值么？\n", "inputFormat": "一行三个整数 $X,Y,N$。\n", "outputFormat": "一行一个浮点数，保留 $6$ 位小数。\n", "hint": "对于 $100\\%$ 的数据，满足 $1 \\le X,Y \\le 10^4$，$1\\le N\\le 10$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2009] Happy Birthday", "background": "", "description": "windy's birthday has arrived. To celebrate, his friends bought a rectangular cake with side lengths $X$ and $Y$.\n\nNow, including windy, there are $N$ people to share this big cake, and each person must receive the same area.\n\nwindy makes the cuts. Each cut must be parallel to one of the cake's sides (either side), and it must split the piece being cut into two pieces.\n\nThus, to obtain $N$ pieces, windy must make $N-1$ cuts.\n\nTo make each piece look nice, we want to minimize the maximum ratio of the long side to the short side among the $N$ pieces.\n\nCan you help windy find this ratio?", "inputFormat": "One line with three integers $X$, $Y$, $N$.", "outputFormat": "One line with a floating-point number, rounded to 6 decimal places.", "hint": "For $100\\%$ of the testdata, it holds that $1 \\le X, Y \\le 10^4$, $1 \\le N \\le 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2009] 生日快乐", "background": "", "description": "windy 的生日到了，为了庆祝生日，他的朋友们帮他买了一个边长分别为 $X$ 和 $Y$ 的矩形蛋糕。\n\n现在包括 windy，一共有 $N$ 个人来分这块大蛋糕，要求每个人必须获得相同面积的蛋糕。\n\nwindy 主刀，每一切只能平行于一块蛋糕的一边（任意一边），并且必须把这块蛋糕切成两块。\n\n这样，要切成 $N$ 块蛋糕，windy 必须切 $N-1$ 次。\n\n为了使得每块蛋糕看起来漂亮，我们要求 $N$ 块蛋糕的长边与短边的比值的最大值最小。\n\n你能帮助 windy 求出这个比值么？\n", "inputFormat": "一行三个整数 $X,Y,N$。\n", "outputFormat": "一行一个浮点数，保留 $6$ 位小数。\n", "hint": "对于 $100\\%$ 的数据，满足 $1 \\le X,Y \\le 10^4$，$1\\le N\\le 10$。\n", "locale": "zh-CN"}}}
{"pid": "P4161", "type": "P", "difficulty": 5, "samples": [["3", "3"], ["10", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "数学", "2009", "四川", "各省省选", "素数判断,质数,筛法"], "title": "[SCOI2009] 游戏", "background": null, "description": "windy 学会了一种游戏。\n\n对于 $1$ 到 $N$ 这 $N$ 个数字，都有唯一且不同的 $1$ 到 $N$ 的数字与之对应。\n\n最开始 windy 把数字按顺序 $1,2,3,\\cdots,N$ 写一排在纸上。\n\n然后再在这一排下面写上它们对应的数字。\n\n然后又在新的一排下面写上它们对应的数字。\n\n如此反复，直到序列再次变为 $1,2,3,\\cdots,N$。\n\n如：$1\\ 2\\ 3\\ 4\\ 5\\ 6$\n\n对应的关系为：$1\\to 2$，$2\\to 3$，$3\\to 1$，$4\\to 5$，$5\\to 4$，$6\\to 6$。\n\nwindy 的操作如下：\n\n`1 2 3 4 5 6`\n\n`2 3 1 5 4 6`\n\n`3 1 2 4 5 6`\n\n`1 2 3 5 4 6`\n\n`2 3 1 4 5 6`\n\n`3 1 2 5 4 6`\n\n`1 2 3 4 5 6`\n\n这时，我们就有若干排 $1$ 到 $N$ 的排列，上例中有 $7$ 排。\n\n现在 windy 想知道，对于所有可能的对应关系，有多少种可能的排数。", "inputFormat": "一个整数，$N$。", "outputFormat": "一个整数，可能的排数。", "hint": "$30\\%$ 的数据，满足 $1 \\le n\\le 10$。\n\n$100\\%$ 的数据，满足 $1 \\le n\\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2009] Game", "background": "", "description": "windy has learned a game.\n\nFor the $N$ numbers from $1$ to $N$, each number is mapped to a unique and different number from $1$ to $N$ (i.e., a permutation).\n\nAt the beginning, windy writes the numbers in order $1, 2, 3, \\cdots, N$ in a row on paper.\n\nThen, underneath this row, he writes their corresponding numbers.\n\nNext, underneath the new row, he writes the numbers corresponding to that row.\n\nHe repeats this process until the sequence becomes $1, 2, 3, \\cdots, N$ again.\n\nFor example: $1\\ 2\\ 3\\ 4\\ 5\\ 6$.\n\nThe correspondence is: $1\\to 2$, $2\\to 3$, $3\\to 1$, $4\\to 5$, $5\\to 4$, $6\\to 6$.\n\nwindy operates as follows:\n`1 2 3 4 5 6`\n`2 3 1 5 4 6`\n`3 1 2 4 5 6`\n`1 2 3 5 4 6`\n`2 3 1 4 5 6`\n`3 1 2 5 4 6`\n`1 2 3 4 5 6`\n\nAt this point, we have several rows of permutations of $1$ to $N$; in the example there are $7$ rows.\n\nNow windy wants to know: over all possible correspondences, how many different possible numbers of rows are there.", "inputFormat": "A single integer, $N$.", "outputFormat": "A single integer, the number of possible row counts.", "hint": "For $30\\%$ of the testdata, $1 \\le N \\le 10$.\n\nFor $100\\%$ of the testdata, $1 \\le N \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2009] 游戏", "background": null, "description": "windy 学会了一种游戏。\n\n对于 $1$ 到 $N$ 这 $N$ 个数字，都有唯一且不同的 $1$ 到 $N$ 的数字与之对应。\n\n最开始 windy 把数字按顺序 $1,2,3,\\cdots,N$ 写一排在纸上。\n\n然后再在这一排下面写上它们对应的数字。\n\n然后又在新的一排下面写上它们对应的数字。\n\n如此反复，直到序列再次变为 $1,2,3,\\cdots,N$。\n\n如：$1\\ 2\\ 3\\ 4\\ 5\\ 6$\n\n对应的关系为：$1\\to 2$，$2\\to 3$，$3\\to 1$，$4\\to 5$，$5\\to 4$，$6\\to 6$。\n\nwindy 的操作如下：\n\n`1 2 3 4 5 6`\n\n`2 3 1 5 4 6`\n\n`3 1 2 4 5 6`\n\n`1 2 3 5 4 6`\n\n`2 3 1 4 5 6`\n\n`3 1 2 5 4 6`\n\n`1 2 3 4 5 6`\n\n这时，我们就有若干排 $1$ 到 $N$ 的排列，上例中有 $7$ 排。\n\n现在 windy 想知道，对于所有可能的对应关系，有多少种可能的排数。", "inputFormat": "一个整数，$N$。", "outputFormat": "一个整数，可能的排数。", "hint": "$30\\%$ 的数据，满足 $1 \\le n\\le 10$。\n\n$100\\%$ 的数据，满足 $1 \\le n\\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P4162", "type": "P", "difficulty": 4, "samples": [["3 3 0\n001\n001\n110", "1.414214"], ["4 3 0\n001\n001\n011\n000", "3.605551"], ["3 3 1\n001\n001\n001", "2.828427"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "四川", "各省省选", "剪枝", "最短路"], "title": "[SCOI2009] 最长距离", "background": "", "description": "windy 有一块矩形土地，被分为 $N\\times M$ 块 $1\\times 1$ 的小格子。 有的格子含有障碍物。 如果从格子 A 可以走到格子 B，那么两个格子的距离就为两个格子中心的欧几里德距离。 如果从格子 A 不可以走到格子 B，就没有距离。如果格子 X 和格子 Y 有公共边，并且 X 和 Y 均不含有障碍物，就可以从 X 走到 Y。 如果 windy 可以移走 $T$ 块障碍物，求所有格子间的最大距离。保证移走 $T$ 块障碍物以后，至少有一个格子不含有障碍物。\n", "inputFormat": "第一行包含三个整数，$N,M,T$。 接下来有 $N$ 行，每行一个长度为 $M$ 的字符串，`0` 表示空格子，`1` 表示该格子含有障碍物。\n", "outputFormat": "包含一个浮点数，保留 $6$ 位小数。\n", "hint": "- $20\\%$ 的数据，满足  $1 \\le N,M \\le 30 $，$ 0 \\le T \\le 0 $。\n- $40\\%$ 的数据，满足  $1 \\le N,M \\le 30 $，$ 0 \\le T \\le 2 $。\n- $100\\%$ 的数据，满足 $1 \\le N,M \\le 30 $，$ 0 \\le T \\le 30$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2009] Longest Distance", "background": "", "description": "windy has a rectangular piece of land divided into $N\\times M$ small $1\\times 1$ cells. Some cells contain obstacles. If cell A can reach cell B, then the distance between them is defined as the Euclidean distance between their centers. If cell A cannot reach cell B, then there is no distance between them. If cells X and Y share a common edge and both X and Y contain no obstacles, you can move from X to Y. If windy can remove $T$ obstacles, find the maximum distance over all pairs of cells (considering only pairs where one can reach the other). It is guaranteed that after removing $T$ obstacles, at least one cell contains no obstacle.", "inputFormat": "The first line contains three integers, $N,M,T$. Then there are $N$ lines, each containing a string of length $M$, where `0` denotes an empty cell and `1` denotes a cell containing an obstacle.", "outputFormat": "Output a single floating-point number, with $6$ digits after the decimal point.", "hint": "- For $20\\%$ of the testdata, $1 \\le N,M \\le 30 $ and $ 0 \\le T \\le 0 $.\n- For $40\\%$ of the testdata, $1 \\le N,M \\le 30 $ and $ 0 \\le T \\le 2 $.\n- For $100\\%$ of the testdata, $1 \\le N,M \\le 30 $ and $ 0 \\le T \\le 30$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2009] 最长距离", "background": "", "description": "windy 有一块矩形土地，被分为 $N\\times M$ 块 $1\\times 1$ 的小格子。 有的格子含有障碍物。 如果从格子 A 可以走到格子 B，那么两个格子的距离就为两个格子中心的欧几里德距离。 如果从格子 A 不可以走到格子 B，就没有距离。如果格子 X 和格子 Y 有公共边，并且 X 和 Y 均不含有障碍物，就可以从 X 走到 Y。 如果 windy 可以移走 $T$ 块障碍物，求所有格子间的最大距离。保证移走 $T$ 块障碍物以后，至少有一个格子不含有障碍物。\n", "inputFormat": "第一行包含三个整数，$N,M,T$。 接下来有 $N$ 行，每行一个长度为 $M$ 的字符串，`0` 表示空格子，`1` 表示该格子含有障碍物。\n", "outputFormat": "包含一个浮点数，保留 $6$ 位小数。\n", "hint": "- $20\\%$ 的数据，满足  $1 \\le N,M \\le 30 $，$ 0 \\le T \\le 0 $。\n- $40\\%$ 的数据，满足  $1 \\le N,M \\le 30 $，$ 0 \\le T \\le 2 $。\n- $100\\%$ 的数据，满足 $1 \\le N,M \\le 30 $，$ 0 \\le T \\le 30$。\n", "locale": "zh-CN"}}}
{"pid": "P4163", "type": "P", "difficulty": 5, "samples": [["7\n000 1\n001 1\n1234567890 1\n123434 2\n1234 7\n12345 17\n12345678 29", "1\n3\n3628800\n90\n3\n6\n1398\n"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2007", "四川", "各省省选", "剪枝", "排列组合", "状压 DP"], "title": "[SCOI2007] 排列", "background": "", "description": "给一个数字串 $s$ 和正整数 $d$, 统计 $s$ 有多少种不同的排列能被 $d$ 整除（可以有前导 $0$）。例如 $123434$ 有 $90$ 种排列能被 $2$ 整除，其中末位为 $2$ 的有 $30$ 种，末位为 $4$ 的有  $60$ 种。", "inputFormat": "输入第一行是一个整数 $T$，表示测试数据的个数，以下每行一组 $s$ 和 $d$，中间用空格隔开。$s$ 保证只包含数字 $0,1,2,3,4,5,6,7,8,9$。", "outputFormat": "每个数据仅一行，表示能被 $d$ 整除的排列的个数。", "hint": "$100\\%$ 的数据满足：$s$ 的长度不超过 $10$，$1\\le d\\le 1000$，$1\\le T\\le 15$。\n\n在前三个例子中，排列分别有 $1,3,3628800$ 种，它们都是 $1$ 的倍数。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2007] Permutation", "background": "", "description": "Given a digit string $s$ and a positive integer $d$, count how many distinct permutations of $s$ are divisible by $d$ (leading $0$ is allowed). For example, $123434$ has $90$ permutations divisible by $2$, among which $30$ end with $2$ and $60$ end with $4$.", "inputFormat": "The first line contains an integer $T$, the number of testdata. Each of the following lines contains $s$ and $d$, separated by a space. String $s$ contains only digits $0,1,2,3,4,5,6,7,8,9$.", "outputFormat": "For each testdata, output one line containing the number of permutations divisible by $d$.", "hint": "Constraints: For $100\\%$ of the testdata, the length of $s$ does not exceed $10$, $1 \\le d \\le 1000$, $1 \\le T \\le 15$.\n\nIn the first three examples, the numbers of permutations are $1, 3, 3628800$, and they are all multiples of $1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2007] 排列", "background": "", "description": "给一个数字串 $s$ 和正整数 $d$, 统计 $s$ 有多少种不同的排列能被 $d$ 整除（可以有前导 $0$）。例如 $123434$ 有 $90$ 种排列能被 $2$ 整除，其中末位为 $2$ 的有 $30$ 种，末位为 $4$ 的有  $60$ 种。", "inputFormat": "输入第一行是一个整数 $T$，表示测试数据的个数，以下每行一组 $s$ 和 $d$，中间用空格隔开。$s$ 保证只包含数字 $0,1,2,3,4,5,6,7,8,9$。", "outputFormat": "每个数据仅一行，表示能被 $d$ 整除的排列的个数。", "hint": "$100\\%$ 的数据满足：$s$ 的长度不超过 $10$，$1\\le d\\le 1000$，$1\\le T\\le 15$。\n\n在前三个例子中，排列分别有 $1,3,3628800$ 种，它们都是 $1$ 的倍数。", "locale": "zh-CN"}}}
{"pid": "P4164", "type": "P", "difficulty": 6, "samples": [["5\n1 -1 2\n0 -1 2\n4 -1 1\n3 -1 2\n2 -1 2", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2010", "各省省选", "江苏"], "title": "[JSOI2010] 挖宝藏", "background": "", "description": "JP 不好好训练，又喜欢上了另一个游戏——寻宝。\n\n游戏里有 $n$ 处宝藏，它们被埋在一个无限大的二维网格中。每个宝藏都有价值 $P_i$，位置是 $(x_i,y_i)$。\n\n如果网格 $(x,y)$ 满足下面两个条件之一，则它是可挖掘的：\n\n- $y=-1$。\n\n- $(x-1,y+1),(x,y+1),(x+1,y+1)$ 这三个方格都已经被挖掘了。\n\n挖掘一个方格的代价为 $1$。当一个宝藏被挖掘出来时，就认为已经获得了它的价值。请你帮 JP 求出所能得到的最大利润，也即价值减代价。（可能一个宝藏也不挖，利润为 $0$）\n", "inputFormat": "第一行为 $n$，表示宝藏数量。\n\n接下来 $n$ 行，每行三个整数 $x_i,y_i,P_i$ 表示宝藏的位置和价值。", "outputFormat": "一行一个整数，表示最大利润。", "hint": "### 样例解释 1\n\n挖 $1,2,4,5$ 号宝藏，价值为 $8$，花费代价为 $4$，所以利润为 $4$。可以证明没有更优的方案。\n\n### 数据范围\n\n对于 $30\\%$ 的数据，$n\\leq 15$。\n\n对于 $50\\%$ 的数据，$-10^3\\leq y_i\\leq 0$。\n\n对于 $100\\%$ 的数据，$n\\leq 10^3,-10^4\\leq x_i\\leq 10^4,-10^4\\leq y_i<0,1\\leq P_i\\leq 10^6$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JSOI2010] 挖宝藏", "background": "", "description": "JP 不好好训练，又喜欢上了另一个游戏——寻宝。\n\n游戏里有 $n$ 处宝藏，它们被埋在一个无限大的二维网格中。每个宝藏都有价值 $P_i$，位置是 $(x_i,y_i)$。\n\n如果网格 $(x,y)$ 满足下面两个条件之一，则它是可挖掘的：\n\n- $y=-1$。\n\n- $(x-1,y+1),(x,y+1),(x+1,y+1)$ 这三个方格都已经被挖掘了。\n\n挖掘一个方格的代价为 $1$。当一个宝藏被挖掘出来时，就认为已经获得了它的价值。请你帮 JP 求出所能得到的最大利润，也即价值减代价。（可能一个宝藏也不挖，利润为 $0$）\n", "inputFormat": "第一行为 $n$，表示宝藏数量。\n\n接下来 $n$ 行，每行三个整数 $x_i,y_i,P_i$ 表示宝藏的位置和价值。", "outputFormat": "一行一个整数，表示最大利润。", "hint": "### 样例解释 1\n\n挖 $1,2,4,5$ 号宝藏，价值为 $8$，花费代价为 $4$，所以利润为 $4$。可以证明没有更优的方案。\n\n### 数据范围\n\n对于 $30\\%$ 的数据，$n\\leq 15$。\n\n对于 $50\\%$ 的数据，$-10^3\\leq y_i\\leq 0$。\n\n对于 $100\\%$ 的数据，$n\\leq 10^3,-10^4\\leq x_i\\leq 10^4,-10^4\\leq y_i<0,1\\leq P_i\\leq 10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P4165", "type": "P", "difficulty": 4, "samples": [["4 1 2 10\n5 1\n3 2\n2 3\n2 1", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "四川", "各省省选", "枚举", "排序"], "title": "[SCOI2007] 组队", "background": null, "description": "NBA 每年都有球员选秀环节。通常用速度和身高两项数据来衡量一个篮球运动员的基本素质。假如一支球队里速度最慢的球员速度为 $minV$，身高最矮的球员高度为 $minH$，那么这支球队的所有队员都应该满足: $A\\times(height-minH)+B\\times( speed-minV)\\le C$ 其中 $A,B,C$ 为给定的经验值。这个式子很容易理解，如果一个球队的球员速度和身高差距太大，会造成配合的不协调。\n\n请问作为球队管理层的你，在 $N$ 名选秀球员中，最多能有多少名符合条件的候选球员。", "inputFormat": "第一行四个数 $N,A,B,C$ 下接 $N$行每行两个数描述一个球员的 $height$ 和 $speed$。", "outputFormat": "最多候选球员数目。", "hint": "数据范围：$N\\le5000,height,speed\\le10000$，$A,B,C$ 在长整型以内。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2007] Team Formation", "background": "", "description": "The NBA holds a player draft every year. A basketball player’s basic ability is usually measured by two pieces of data: speed and height. Suppose in a team, the slowest player’s speed is $minV$ and the shortest player’s height is $minH$. Then all players on this team should satisfy: $A\\times(height-minH)+B\\times( speed-minV)\\le C$, where $A, B, C$ are given empirical values. This formula is easy to understand: if the players in a team differ too much in speed and height, it will cause poor coordination.\n\nAs the team management, among $N$ draft players, what is the maximum number of candidate players that meet the condition?", "inputFormat": "The first line contains four integers $N, A, B, C$. Then $N$ lines follow; each line contains two integers describing one player’s $height$ and $speed$.", "outputFormat": "Output the maximum number of candidate players.", "hint": "Constraints: $N \\le 5000$, $height, speed \\le 10000$; $A, B, C$ fit in a long integer.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2007] 组队", "background": null, "description": "NBA 每年都有球员选秀环节。通常用速度和身高两项数据来衡量一个篮球运动员的基本素质。假如一支球队里速度最慢的球员速度为 $minV$，身高最矮的球员高度为 $minH$，那么这支球队的所有队员都应该满足: $A\\times(height-minH)+B\\times( speed-minV)\\le C$ 其中 $A,B,C$ 为给定的经验值。这个式子很容易理解，如果一个球队的球员速度和身高差距太大，会造成配合的不协调。\n\n请问作为球队管理层的你，在 $N$ 名选秀球员中，最多能有多少名符合条件的候选球员。", "inputFormat": "第一行四个数 $N,A,B,C$ 下接 $N$行每行两个数描述一个球员的 $height$ 和 $speed$。", "outputFormat": "最多候选球员数目。", "hint": "数据范围：$N\\le5000,height,speed\\le10000$，$A,B,C$ 在长整型以内。", "locale": "zh-CN"}}}
{"pid": "P4166", "type": "P", "difficulty": 6, "samples": [["5\n0 0\n1 0\n1 1\n0 1\n0.5 0.5", "1.000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2007", "四川", "各省省选", "枚举", "向量", "凸包", "叉积"], "title": "[SCOI2007] 最大土地面积", "background": null, "description": "在某块平面土地上有 $N$ 个点，你可以选择其中的任意四个点，将这片土地围起来，当然，你希望这四个点围成的多边形面积最大。", "inputFormat": "第 $1$ 行一个正整数 $N$，接下来 $N$ 行，每行 $2$ 个数 $x,y$，表示该点的横坐标和纵坐标。", "outputFormat": "最大的多边形面积，答案精确到小数点后 $3$ 位。", "hint": "$5\\le N\\le 2000, 0\\le |x|,|y|\\le 100000$", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2007] Maximum Land Area", "background": "", "description": "On a piece of planar land, there are $N$ points. You may choose any four of them to enclose the land. Of course, you want the polygon formed by these four points to have the maximum area.", "inputFormat": "The first line contains a positive integer $N$. The next $N$ lines each contain $2$ numbers $x, y$, representing the $x$-coordinate and $y$-coordinate of the point.", "outputFormat": "Output the maximum polygon area, rounded to $3$ decimal places.", "hint": "$5\\le N\\le 2000, 0\\le |x|,|y|\\le 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2007] 最大土地面积", "background": null, "description": "在某块平面土地上有 $N$ 个点，你可以选择其中的任意四个点，将这片土地围起来，当然，你希望这四个点围成的多边形面积最大。", "inputFormat": "第 $1$ 行一个正整数 $N$，接下来 $N$ 行，每行 $2$ 个数 $x,y$，表示该点的横坐标和纵坐标。", "outputFormat": "最大的多边形面积，答案精确到小数点后 $3$ 位。", "hint": "$5\\le N\\le 2000, 0\\le |x|,|y|\\le 100000$", "locale": "zh-CN"}}}
{"pid": "P4168", "type": "P", "difficulty": 6, "samples": [["6 3 \n1 2 3 2 1 2 \n1 5 \n3 6 \n1 5\n", "1 \n2 \n1\n"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["离散化", "O2优化", "枚举", "分块"], "title": "[Violet] 蒲公英", "background": "亲爱的哥哥：\n\n你在那个城市里面过得好吗？\n\n我在家里面最近很开心呢。昨天晚上奶奶给我讲了那个叫「绝望」的大坏蛋的故事的说！它把人们的房子和田地搞坏，还有好多小朋友也被它杀掉了。我觉得把那么可怕的怪物召唤出来的那个坏蛋也很坏呢。不过奶奶说他是很难受的时候才做出这样的事的……\n\n最近村子里长出了一大片一大片的蒲公英。一刮风，这些蒲公英就能飘到好远的地方了呢。我觉得要是它们能飘到那个城市里面，让哥哥看看就好了呢！\n\n哥哥你要快点回来哦！\n\n爱你的妹妹 Violet\n\nAzure 读完这封信之后微笑了一下。\n\n“蒲公英吗……”\n", "description": "在乡下的小路旁种着许多蒲公英，而我们的问题正是与这些蒲公英有关。\n\n为了简化起见，我们把所有的蒲公英看成一个长度为 $n$ 的序列 $\\{a_1,a_2..a_n\\}$，其中 $a_i$ 为一个正整数，表示第 $i$ 棵蒲公英的种类编号。\n\n而每次询问一个区间 $[l, r]$，你需要回答区间里出现次数最多的是哪种蒲公英，如果有若干种蒲公英出现次数相同，则输出种类编号最小的那个。\n\n**注意，你的算法必须是在线的**。\n", "inputFormat": "第一行有两个整数，分别表示蒲公英的数量 $n$ 和询问次数 $m$。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 棵蒲公英的种类 $a_i$。\n\n接下来 $m$ 行，每行两个整数 $l_0, r_0$，表示一次询问。输入是加密的，解密方法如下：\n\n令上次询问的结果为 $x$（如果这是第一次询问，则 $x = 0$），设 $l=((l_0+x-1)\\bmod n) + 1,r=((r_0+x-1) \\bmod n) + 1$。如果 $l > r$，则交换 $l, r$。  \n最终的询问区间为计算后的 $[l, r]$。\n", "outputFormat": "对于每次询问，输出一行一个整数表示答案。\n", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，保证 $n,m \\le 3000$。\n- 对于 $100\\%$ 的数据，保证 $1\\le n \\le 40000$，$1\\le m \\le 50000$，$1\\le a_i \\le 10^9$，$1 \\leq l_0, r_0 \\leq n$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Violet] Dandelion", "background": "Dear Brother:\n\nHow are you doing in that city?\n\nI’ve been very happy at home lately. Last night Grandma told me the story about that big villain called \"Despair\"! It ruined people’s houses and fields, and many children were killed by it, too. I think the bad guy who summoned such a scary monster is also very bad. But Grandma said he only did that when he was in great pain...\n\nRecently, lots and lots of dandelions have grown all over the village. When the wind blows, these dandelions can float far, far away. I think if they could float into that city and let you see them, that would be wonderful!\n\nBrother, please come back soon!\n\nLove, your sister Violet\n\nAzure smiled after reading this letter.\n\n\"Dandelions, huh...\"", "description": "There are many dandelions planted along a country path, and our problem is about these dandelions.\n\nTo simplify, we treat all the dandelions as a sequence of length $n$, $\\{a_1,a_2..a_n\\}$, where $a_i$ is a positive integer representing the type ID of the $i$-th dandelion.\n\nFor each query on an interval $[l, r]$, you need to report which type appears most frequently in the interval. If several types are tied, output the smallest type ID among them.\n\n**Note: your algorithm must be online.**", "inputFormat": "The first line contains two integers, representing the number of dandelions $n$ and the number of queries $m$.\n\nThe second line contains $n$ integers. The $i$-th integer is the type $a_i$ of the $i$-th dandelion.\n\nThen follow $m$ lines. Each line contains two integers $l_0, r_0$, representing one query. The input is encrypted; the decryption is as follows:\n\nLet the previous query’s result be $x$ (if this is the first query, then $x = 0$), and set $l=((l_0+x-1)\\bmod n) + 1, r=((r_0+x-1) \\bmod n) + 1$. If $l > r$, swap $l, r$.  \nThe final query interval is the computed $[l, r]$.", "outputFormat": "For each query, output one integer on its own line representing the answer.", "hint": "#### Constraints\n\n- For $20\\%$ of the testdata, it is guaranteed that $n, m \\le 3000$.\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\le n \\le 40000$, $1 \\le m \\le 50000$, $1 \\le a_i \\le 10^9$, $1 \\leq l_0, r_0 \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Violet] 蒲公英", "background": "亲爱的哥哥：\n\n你在那个城市里面过得好吗？\n\n我在家里面最近很开心呢。昨天晚上奶奶给我讲了那个叫「绝望」的大坏蛋的故事的说！它把人们的房子和田地搞坏，还有好多小朋友也被它杀掉了。我觉得把那么可怕的怪物召唤出来的那个坏蛋也很坏呢。不过奶奶说他是很难受的时候才做出这样的事的……\n\n最近村子里长出了一大片一大片的蒲公英。一刮风，这些蒲公英就能飘到好远的地方了呢。我觉得要是它们能飘到那个城市里面，让哥哥看看就好了呢！\n\n哥哥你要快点回来哦！\n\n爱你的妹妹 Violet\n\nAzure 读完这封信之后微笑了一下。\n\n“蒲公英吗……”\n", "description": "在乡下的小路旁种着许多蒲公英，而我们的问题正是与这些蒲公英有关。\n\n为了简化起见，我们把所有的蒲公英看成一个长度为 $n$ 的序列 $\\{a_1,a_2..a_n\\}$，其中 $a_i$ 为一个正整数，表示第 $i$ 棵蒲公英的种类编号。\n\n而每次询问一个区间 $[l, r]$，你需要回答区间里出现次数最多的是哪种蒲公英，如果有若干种蒲公英出现次数相同，则输出种类编号最小的那个。\n\n**注意，你的算法必须是在线的**。\n", "inputFormat": "第一行有两个整数，分别表示蒲公英的数量 $n$ 和询问次数 $m$。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 棵蒲公英的种类 $a_i$。\n\n接下来 $m$ 行，每行两个整数 $l_0, r_0$，表示一次询问。输入是加密的，解密方法如下：\n\n令上次询问的结果为 $x$（如果这是第一次询问，则 $x = 0$），设 $l=((l_0+x-1)\\bmod n) + 1,r=((r_0+x-1) \\bmod n) + 1$。如果 $l > r$，则交换 $l, r$。  \n最终的询问区间为计算后的 $[l, r]$。\n", "outputFormat": "对于每次询问，输出一行一个整数表示答案。\n", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，保证 $n,m \\le 3000$。\n- 对于 $100\\%$ 的数据，保证 $1\\le n \\le 40000$，$1\\le m \\le 50000$，$1\\le a_i \\le 10^9$，$1 \\leq l_0, r_0 \\leq n$。\n", "locale": "zh-CN"}}}
{"pid": "P4169", "type": "P", "difficulty": 6, "samples": [["2 3 \n1 1 \n2 3 \n2 1 2 \n1 3 3 \n2 4 2", "1 \n2"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["树状数组", "cdq 分治", "分治", "剪枝"], "title": "[Violet] 天使玩偶/SJY摆棋子", "background": "", "description": "\nAyu 在七年前曾经收到过一个天使玩偶，当时她把它当作时间囊埋在了地下。而七年后 的今天，Ayu 却忘了她把天使玩偶埋在了哪里，所以她决定仅凭一点模糊的记忆来寻找它。\n\n我们把 Ayu 生活的小镇看作一个二维平面坐标系，而 Ayu 会不定时地记起可能在某个点 $(x, y)$ 埋下了天使玩偶；或者 Ayu 会询问你，假如她在 $(x,y)$，那么她离近的天使玩偶可能埋下的地方有多远。\n\n因为 Ayu 只会沿着平行坐标轴的方向来行动，所以在这个问题里我们定义两个点之间的距离为 $\\operatorname{dist}(A,B)=|A_x-B_x|+|A_y-B_y|$。其中 $A_x$ 表示点 $A$ 的横坐标，其余类似。\n", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，在刚开始时，Ayu 已经知道有 $n$ 个点可能埋着天使玩偶， 接下来 Ayu 要进行 $m$ 次操作。\n\n接下来 $n$ 行，每行两个非负整数 $(x_i,y_i)$，表示初始 $n$ 个点的坐标。\n\n再接下来 $m$ 行，每行三个非负整数 $t,x_i,y_i$。\n\n* 如果 $t=1$，则表示 Ayu 又回忆起了一个可能埋着玩偶的点 $(x_i,y_i)$。\n* 如果 $t=2$，则表示 Ayu 询问如果她在点 $(x_i,y_i)$，那么在已经回忆出来的点里，离她近的那个点有多远", "outputFormat": "对于每个 $t=2$ 的询问，在单独的一行内输出该询问的结果。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据 保证 $1 \\leq n,m\\leq 3 \\times 10^5$，$0 \\leq x_i,y_i \\leq 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[Violet] Angel Doll / SJY Placing Chess Pieces", "background": "", "description": "Seven years ago, Ayu received an angel doll. She buried it underground as a time capsule. But today, seven years later, Ayu has forgotten where she buried it, so she decides to look for it based only on some vague memories.\n\nWe treat the town where Ayu lives as a 2D Cartesian coordinate plane. From time to time, Ayu will recall that the doll might have been buried at some point $(x, y)$; or she will ask you: if she is at $(x, y)$, how far is it to the nearest location where the angel doll might have been buried.\n\nBecause Ayu only moves along directions parallel to the coordinate axes, in this problem we define the distance between two points as $\\operatorname{dist}(A, B) = |A_x - B_x| + |A_y - B_y|$. Here $A_x$ denotes the $x$-coordinate of point $A$, and similarly for the others.", "inputFormat": "The first line contains two integers $n$ and $m$. At the start, Ayu already knows $n$ points where the doll might be buried, and then she will perform $m$ operations.\n\nThe next $n$ lines each contain two non-negative integers $(x_i, y_i)$, denoting the coordinates of the initial $n$ points.\n\nThen the next $m$ lines each contain three non-negative integers $t, x_i, y_i$.\n- If $t = 1$, Ayu recalls another point $(x_i, y_i)$ where the doll might be buried.\n- If $t = 2$, Ayu asks: if she is at $(x_i, y_i)$, among the points recalled so far, how far is the nearest point to her.", "outputFormat": "For each query with $t = 2$, output the result on a separate line.", "hint": "Constraints: For $100\\%$ of the testdata, it is guaranteed that $1 \\leq n, m \\leq 3 \\times 10^5$ and $0 \\leq x_i, y_i \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Violet] 天使玩偶/SJY摆棋子", "background": "", "description": "\nAyu 在七年前曾经收到过一个天使玩偶，当时她把它当作时间囊埋在了地下。而七年后 的今天，Ayu 却忘了她把天使玩偶埋在了哪里，所以她决定仅凭一点模糊的记忆来寻找它。\n\n我们把 Ayu 生活的小镇看作一个二维平面坐标系，而 Ayu 会不定时地记起可能在某个点 $(x, y)$ 埋下了天使玩偶；或者 Ayu 会询问你，假如她在 $(x,y)$，那么她离近的天使玩偶可能埋下的地方有多远。\n\n因为 Ayu 只会沿着平行坐标轴的方向来行动，所以在这个问题里我们定义两个点之间的距离为 $\\operatorname{dist}(A,B)=|A_x-B_x|+|A_y-B_y|$。其中 $A_x$ 表示点 $A$ 的横坐标，其余类似。\n", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，在刚开始时，Ayu 已经知道有 $n$ 个点可能埋着天使玩偶， 接下来 Ayu 要进行 $m$ 次操作。\n\n接下来 $n$ 行，每行两个非负整数 $(x_i,y_i)$，表示初始 $n$ 个点的坐标。\n\n再接下来 $m$ 行，每行三个非负整数 $t,x_i,y_i$。\n\n* 如果 $t=1$，则表示 Ayu 又回忆起了一个可能埋着玩偶的点 $(x_i,y_i)$。\n* 如果 $t=2$，则表示 Ayu 询问如果她在点 $(x_i,y_i)$，那么在已经回忆出来的点里，离她近的那个点有多远", "outputFormat": "对于每个 $t=2$ 的询问，在单独的一行内输出该询问的结果。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据 保证 $1 \\leq n,m\\leq 3 \\times 10^5$，$0 \\leq x_i,y_i \\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4170", "type": "P", "difficulty": 5, "samples": [["AAAAA", "1"], ["RGBGR", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "2007", "重庆", "各省省选", "枚举", "区间 DP"], "title": "[CQOI2007] 涂色", "background": "", "description": "假设你有一条长度为 $5$ 的木板，初始时没有涂过任何颜色。你希望把它的 $5$ 个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为 $5$ 的字符串表示这个目标：$\\texttt{RGBGR}$。\n\n每次你可以把一段连续的木板涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木板涂成 $\\texttt{RRRRR}$，第二次涂成 $\\texttt{RGGGR}$，第三次涂成 $\\texttt{RGBGR}$，达到目标。\n\n用尽量少的涂色次数达到目标。\n", "inputFormat": "输入仅一行，包含一个长度为 $n$ 的字符串，即涂色目标。字符串中的每个字符都是一个大写字母，不同的字母代表不同颜色，相同的字母代表相同颜色。\n", "outputFormat": "仅一行，包含一个数，即最少的涂色次数。\n", "hint": "$40\\%$ 的数据满足 $1\\le n\\le 10$。\n\n$100\\%$ 的数据满足 $1\\le n\\le 50$。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2007] Coloring", "background": "", "description": "Suppose you have a wooden board of length $5$, initially unpainted. You want to paint its $5$ unit segments red, green, blue, green, and red, respectively, represented by a length-$5$ string: $\\texttt{RGBGR}$.\n\nEach time, you may paint a consecutive segment of the board with a given color, and later paint covers earlier paint. For example, first paint $\\texttt{RRRRR}$, then paint $\\texttt{RGGGR}$, and finally paint $\\texttt{RGBGR}$ to reach the target.\n\nUse as few painting operations as possible to reach the target.", "inputFormat": "The input contains a single line with a string of length $n$, which is the painting target. Every character is an uppercase letter; different letters denote different colors, and the same letters denote the same color.", "outputFormat": "Output a single line with one number: the minimum number of painting operations.", "hint": "$40\\%$ of the testdata satisfies $1 \\le n \\le 10$.\n\n$100\\%$ of the testdata satisfies $1 \\le n \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2007] 涂色", "background": "", "description": "假设你有一条长度为 $5$ 的木板，初始时没有涂过任何颜色。你希望把它的 $5$ 个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为 $5$ 的字符串表示这个目标：$\\texttt{RGBGR}$。\n\n每次你可以把一段连续的木板涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木板涂成 $\\texttt{RRRRR}$，第二次涂成 $\\texttt{RGGGR}$，第三次涂成 $\\texttt{RGBGR}$，达到目标。\n\n用尽量少的涂色次数达到目标。\n", "inputFormat": "输入仅一行，包含一个长度为 $n$ 的字符串，即涂色目标。字符串中的每个字符都是一个大写字母，不同的字母代表不同颜色，相同的字母代表相同颜色。\n", "outputFormat": "仅一行，包含一个数，即最少的涂色次数。\n", "hint": "$40\\%$ 的数据满足 $1\\le n\\le 10$。\n\n$100\\%$ 的数据满足 $1\\le n\\le 50$。\n\n", "locale": "zh-CN"}}}
{"pid": "P4171", "type": "P", "difficulty": 5, "samples": [["2\n3 4\nm3 h1\nm1 m2\nh1 h3\nh3 m2\n2 4\nh1 m2\nm2 m1\nh1 h2\nm1 h2", "GOOD\nBAD"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2010", "各省省选", "江苏", "图论建模", "2-SAT"], "title": "[JSOI2010] 满汉全席", "background": null, "description": "满汉全席是中国最丰盛的宴客菜肴，有许多种不同的材料透过满族或是汉族的料理方式，呈现在数量繁多的菜色之中。由于菜色众多而繁杂，只有极少数博学多闻技艺高超的厨师能够做出满汉全席，而能够烹饪出经过专家认证的满汉全席，也是中国厨师最大的荣誉之一。世界满汉全席协会是由能够料理满汉全席的专家厨师们所组成，而他们之间还细分为许多不同等级的厨师。\n\n为了招收新进的厨师进入世界满汉全席协会，将于近日举办满汉全席大赛，协会派遣许多会员当作评审员，为的就是要在参赛的厨师之中，找到满汉界的明日之星。\n\n大会的规则如下：每位参赛的选手可以得到 $n$ 种材料，选手可以自由选择用满式或是汉式料理将材料做成菜肴。\n\n大会的评审制度是：共有 $m$ 位评审员分别把关。每一位评审员对于满汉全席有各自独特的见解，但基本见解是，要有两样菜色作为满汉全席的标志。如某评审认为，如果没有汉式东坡肉跟满式的涮羊肉锅，就不能算是满汉全席。但避免过于有主见的审核，大会规定一个评审员除非是在认为必备的两样菜色都没有做出来的状况下，才能淘汰一位选手，否则不能淘汰一位选手。\n\n换句话说，只要参赛者能在这两种材料的做法中，其中一个符合评审的喜好即可通过该评审的审查。如材料有猪肉，羊肉和牛肉时，有四位评审员的喜好如下表： \n\n```\n评审一 评审二 评审三 评审四 \n满式牛肉 满式猪肉 汉式牛肉 汉式牛肉 \n汉式猪肉 满式羊肉 汉式猪肉 满式羊肉 \n```\n\n如参赛者甲做出满式猪肉，满式羊肉和满式牛肉料理，他将无法满足评审三的要求，无法通过评审。而参赛者乙做出汉式猪肉，满式羊肉和满式牛肉料理，就可以满足所有评审的要求。\n\n但大会后来发现，在这样的制度下如果材料选择跟派出的评审员没有特别安排好的话，所有的参赛者最多只能通过部分评审员的审查而不是全部，所以可能会发生没有人通过考核的情形。\n\n如有四个评审员喜好如下表时，则不论参赛者采取什么样的做法，都不可能通过所有评审的考核： \n\n```\n评审一 评审二 评审三 评审四 \n满式羊肉 满式猪肉 汉式羊肉 汉式羊肉 \n汉式猪肉 满式羊肉 汉式猪肉 满式猪肉 \n```\n\n所以大会希望有人能写一个程序来判断，所选出的 $m$ 位评审，会不会发生没有人能通过考核的窘境，以便协会组织合适的评审团。", "inputFormat": "第一行包含一个数字 $K$（$1\\le K \\le 50$），代表测试文件包含了 $K$ 组数据。\n\n每一组测试数据的第一行包含两个数字 $n$ 跟 $m$（$n≤100$，$m≤1000$），代表有 $n$ 种材料，$m$ 位评审员。\n\n为方便起见，舍弃做法的中文名称而给予编号，编号分别从 $1$ 到 $n$。\n\n接下来的 $m$ 行，每行都代表对应的评审员所拥有的两个喜好，每个喜好由一个英文字母跟一个数字代表，如 $m1$ 代表这个评审喜欢第 $1$ 个材料透过满式料理做出来的菜，而 $h2$ 代表这个评审员喜欢第 $2$ 个材料透过汉式料理做出来的菜。", "outputFormat": "每组测试数据输出一行，如果不会发生没有人能通过考核的窘境，输出 ```GOOD```；否则输出 ```BAD```（均为大写字母）。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2010] Manchu-Han Banquet", "background": "", "description": "The Manchu-Han Banquet is the most lavish Chinese banquet. Many different ingredients, cooked in either Manchu or Han style, appear as a large variety of dishes. Because it is so complex, only a few highly skilled and knowledgeable chefs can make a Manchu-Han Banquet. Being able to cook a Manchu-Han Banquet certified by experts is one of the greatest honors for a Chinese chef. The World Manchu-Han Banquet Association consists of expert chefs capable of cooking this banquet, and they are further divided into different ranks.\n\nTo recruit new chefs into the association, a Manchu-Han Banquet competition will be held soon. The association will send many members to serve as judges, aiming to find the rising star among the contestants.\n\nThe rules are as follows: each contestant receives $n$ types of ingredients and can freely choose to cook each ingredient in Manchu style or Han style.\n\nThe judging system is: there are $m$ judges in total. Each judge has a unique view of the banquet, but the basic idea is that there are two hallmark dishes. For example, a judge may think that without Han-style braised pork (Dongpo pork) and Manchu-style mutton hotpot, it cannot be called a Manchu-Han Banquet. To avoid overly subjective judging, the contest rules state that a judge can eliminate a contestant only if both of their required dishes are missing; otherwise, the judge may not eliminate the contestant.\n\nIn other words, as long as the contestant’s choice for at least one of the two specified ingredients matches the judge’s preference, the contestant passes that judge. For example, if the ingredients are pork, mutton, and beef, and four judges have the following preferences: \n\n```\n评审一 评审二 评审三 评审四 \n满式牛肉 满式猪肉 汉式牛肉 汉式牛肉 \n汉式猪肉 满式羊肉 汉式猪肉 满式羊肉 \n```\n\nIf contestant A cooks Manchu-style pork, Manchu-style mutton, and Manchu-style beef, they cannot satisfy judge three and thus fail that judge. If contestant B cooks Han-style pork, Manchu-style mutton, and Manchu-style beef, they satisfy all judges.\n\nHowever, the organizers later found that under such a system, if the choice of ingredients and the set of judges are not suitably arranged, all contestants might pass at most part of the judges rather than all of them, so no one could pass the entire evaluation.\n\nFor example, if four judges have the following preferences, then no matter what choices a contestant makes, it is impossible to satisfy all judges: \n\n```\n评审一 评审二 评审三 评审四 \n满式羊肉 满式猪肉 汉式羊肉 汉式羊肉 \n汉式猪肉 满式羊肉 汉式猪肉 满式猪肉 \n```\n\nTherefore, the organizers hope for a program to determine whether the selected $m$ judges will lead to the awkward situation where no one can pass the evaluation, so that the association can form a suitable judging panel.", "inputFormat": "The first line contains an integer $K$ ($1\\le K \\le 50$), meaning the test file contains $K$ test cases.\n\nFor each test case, the first line contains two integers $n$ and $m$ ($n≤100$, $m≤1000$), meaning there are $n$ types of ingredients and $m$ judges.\n\nFor convenience, we discard the Chinese names and assign IDs from $1$ to $n$.\n\nThe next $m$ lines each describe the two preferences of a judge. Each preference is represented by an English letter and a number. For example, $m1$ means this judge likes ingredient $1$ cooked in Manchu style, and $h2$ means this judge likes ingredient $2$ cooked in Han style.", "outputFormat": "For each test case, output one line. If it will not happen that nobody can pass the evaluation, output ```GOOD```; otherwise output ```BAD``` (uppercase letters).", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2010] 满汉全席", "background": null, "description": "满汉全席是中国最丰盛的宴客菜肴，有许多种不同的材料透过满族或是汉族的料理方式，呈现在数量繁多的菜色之中。由于菜色众多而繁杂，只有极少数博学多闻技艺高超的厨师能够做出满汉全席，而能够烹饪出经过专家认证的满汉全席，也是中国厨师最大的荣誉之一。世界满汉全席协会是由能够料理满汉全席的专家厨师们所组成，而他们之间还细分为许多不同等级的厨师。\n\n为了招收新进的厨师进入世界满汉全席协会，将于近日举办满汉全席大赛，协会派遣许多会员当作评审员，为的就是要在参赛的厨师之中，找到满汉界的明日之星。\n\n大会的规则如下：每位参赛的选手可以得到 $n$ 种材料，选手可以自由选择用满式或是汉式料理将材料做成菜肴。\n\n大会的评审制度是：共有 $m$ 位评审员分别把关。每一位评审员对于满汉全席有各自独特的见解，但基本见解是，要有两样菜色作为满汉全席的标志。如某评审认为，如果没有汉式东坡肉跟满式的涮羊肉锅，就不能算是满汉全席。但避免过于有主见的审核，大会规定一个评审员除非是在认为必备的两样菜色都没有做出来的状况下，才能淘汰一位选手，否则不能淘汰一位选手。\n\n换句话说，只要参赛者能在这两种材料的做法中，其中一个符合评审的喜好即可通过该评审的审查。如材料有猪肉，羊肉和牛肉时，有四位评审员的喜好如下表： \n\n```\n评审一 评审二 评审三 评审四 \n满式牛肉 满式猪肉 汉式牛肉 汉式牛肉 \n汉式猪肉 满式羊肉 汉式猪肉 满式羊肉 \n```\n\n如参赛者甲做出满式猪肉，满式羊肉和满式牛肉料理，他将无法满足评审三的要求，无法通过评审。而参赛者乙做出汉式猪肉，满式羊肉和满式牛肉料理，就可以满足所有评审的要求。\n\n但大会后来发现，在这样的制度下如果材料选择跟派出的评审员没有特别安排好的话，所有的参赛者最多只能通过部分评审员的审查而不是全部，所以可能会发生没有人通过考核的情形。\n\n如有四个评审员喜好如下表时，则不论参赛者采取什么样的做法，都不可能通过所有评审的考核： \n\n```\n评审一 评审二 评审三 评审四 \n满式羊肉 满式猪肉 汉式羊肉 汉式羊肉 \n汉式猪肉 满式羊肉 汉式猪肉 满式猪肉 \n```\n\n所以大会希望有人能写一个程序来判断，所选出的 $m$ 位评审，会不会发生没有人能通过考核的窘境，以便协会组织合适的评审团。", "inputFormat": "第一行包含一个数字 $K$（$1\\le K \\le 50$），代表测试文件包含了 $K$ 组数据。\n\n每一组测试数据的第一行包含两个数字 $n$ 跟 $m$（$n≤100$，$m≤1000$），代表有 $n$ 种材料，$m$ 位评审员。\n\n为方便起见，舍弃做法的中文名称而给予编号，编号分别从 $1$ 到 $n$。\n\n接下来的 $m$ 行，每行都代表对应的评审员所拥有的两个喜好，每个喜好由一个英文字母跟一个数字代表，如 $m1$ 代表这个评审喜欢第 $1$ 个材料透过满式料理做出来的菜，而 $h2$ 代表这个评审员喜欢第 $2$ 个材料透过汉式料理做出来的菜。", "outputFormat": "每组测试数据输出一行，如果不会发生没有人能通过考核的窘境，输出 ```GOOD```；否则输出 ```BAD```（均为大写字母）。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4172", "type": "P", "difficulty": 6, "samples": [["4 4 3\n1 2 2\n2 3 3\n3 4 2\n1 4 2\n1 1 4\n2 1 4\n1 1 4\n", "2\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["图论", "2006", "平衡树", "O2优化", "生成树", "最近公共祖先 LCA", "动态树 LCT", "WC"], "title": "[WC2006] 水管局长", "background": "SC 省 MY 市有着庞大的地下水管网络，嘟嘟是 MY 市的水管局长（就是管水管的啦）。", "description": "每天供水公司可能要将一定量的水从 $u$ 处送往 $v$ 处，嘟嘟需要为供水公司找到一条从 $u$ 至 $v$ 的水管的路径，接着通过信息化的控制中心通知路径上的水管进入准备送水状态，等到路径上每一条水管都准备好了，供水公司就可以开始送水了。嘟嘟一次只能处理一项送水任务，等到当前的送水任务完成了，才能处理下一项。\n\n在处理每项送水任务之前，路径上的水管都要进行一系列的准备操作，如清洗、消毒等等。嘟嘟在控制中心一声令下，这些水管的准备操作同时开始，但由于各条管道的长度、内径不同，进行准备操作需要的时间可能不同。\n\n供水公司总是希望嘟嘟能找到这样一条送水路径，路径上的所有管道全都准备就绪所需要的时间尽量短。嘟嘟希望你能帮助他完成这样的一个选择路径的系统，以满足供水公司的要求。另外，由于 MY 市的水管年代久远，一些水管会不时出现故障导致不能使用，你的程序必须考虑到这一点。\n\n不妨将 MY 市的水管网络看作一幅简单无向图（即没有自环或重边）：水管是图中的边，水管的连接处为图中的结点。整张图共有 $n$ 个节点和 $m$ 条边，节点从 $1$ 至 $n$ 编号。\n", "inputFormat": "第一行有三个整数，分别表示管道连接处（结点）的数目 $n$，目前水管（无向边）的数目 $m$，以及你的程序需要处理的任务数目（包括寻找一条满足要求的路径和接受某条水管坏掉的事实）$q$。\n\n以下 $m$ 行，每行三个整数 $u, v, t$，表示存在一条连接 $(u, v)$ 的水管，准备时间为 $t$。\n\n以下 $q$ 行，每行三个整数 $k, u, v$，描述一项任务。其中 $k$ 表示任务类型：\n\n- 若 $k = 1$，则表示你需要为供水公司寻找一条满足要求的从 $u$ 到 $v$ 的水管路径，满足准备时间最短；\n- 若 $k = 2$，则表示直接连接 $u$ 和 $v$ 的水管宣布报废。\n", "outputFormat": "对于每个 $k = 1$ 的任务，输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n- $1 \\leq n \\leq 10^3$，$1 \\leq m, q \\leq 10^5$。\n- $1 \\leq k \\leq 2$，$1 \\leq u, v \\leq n$，$1 \\leq t \\leq 10^9$。\n- 给出的图无重边无自环，保证在宣布一条水管报废之前，该水管一定存在于图上且没有报废，\n- 宣布报废的水管不超过 $5 \\times 10^3$ 条，且在任意时刻，图一定是联通的。\n\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[WC2006] Waterworks Director", "background": "MY City in SC Province has a huge underground water pipe network. Dudu is the waterworks director of MY City (that is, the person in charge of the pipes).", "description": "Each day, the water supply company may need to deliver a certain amount of water from $u$ to $v$. Dudu must find a path of pipes from $u$ to $v$ for the company. Then, through an information control center, he instructs the pipes on the path to enter a ready-to-deliver state. Once every pipe on the path is ready, the company can start delivering water. Dudu can handle only one delivery task at a time; he can process the next task only after the current delivery is completed.\n\nBefore each delivery task, every pipe on the chosen path must undergo a series of preparation operations, such as cleaning and disinfection. At Dudu’s command, these preparations start simultaneously on all pipes of the path. However, due to differences in length and inner diameter, the required preparation time may vary from pipe to pipe.\n\nThe water supply company always hopes Dudu can find a delivery path such that the time until all pipes on the path are ready is as short as possible. Dudu wants you to help him build a system that selects such a path to meet the company’s requirement. In addition, since the water pipes in MY City are old, some pipes may occasionally fail and become unusable; your program must take this into account.\n\nWe model the water pipe network of MY City as a simple undirected graph (i.e., without self-loops or multiple edges): pipes are edges, and junctions are nodes. The entire graph has $n$ nodes and $m$ edges, with nodes numbered from $1$ to $n$.", "inputFormat": "The first line contains three integers, representing the number of junctions (nodes) $n$, the current number of pipes (undirected edges) $m$, and the number of tasks your program needs to process (including both finding a path that meets the requirement and accepting that some pipe has broken) $q$.\n\nEach of the next $m$ lines contains three integers $u, v, t$, indicating there is a pipe connecting $(u, v)$ with preparation time $t$.\n\nEach of the next $q$ lines contains three integers $k, u, v$, describing a task. Here $k$ indicates the task type:\n- If $k = 1$, you need to find a path of pipes from $u$ to $v$ that meets the requirement, i.e., the preparation time is minimized.\n- If $k = 2$, it means the pipe directly connecting $u$ and $v$ is declared scrapped.", "outputFormat": "For each task with $k = 1$, output a single integer on one line indicating the answer.", "hint": "#### Constraints\n\nFor all test points, it is guaranteed that:\n- $1 \\leq n \\leq 10^3$, $1 \\leq m, q \\leq 10^5$.\n- $1 \\leq k \\leq 2$, $1 \\leq u, v \\leq n$, $1 \\leq t \\leq 10^9$.\n- The given graph has no multiple edges and no self-loops. Before a pipe is declared scrapped, it is guaranteed that the pipe exists in the graph and has not been scrapped.\n- The number of scrapped pipes does not exceed $5 \\times 10^3$, and at any time the graph is guaranteed to remain connected.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2006] 水管局长", "background": "SC 省 MY 市有着庞大的地下水管网络，嘟嘟是 MY 市的水管局长（就是管水管的啦）。", "description": "每天供水公司可能要将一定量的水从 $u$ 处送往 $v$ 处，嘟嘟需要为供水公司找到一条从 $u$ 至 $v$ 的水管的路径，接着通过信息化的控制中心通知路径上的水管进入准备送水状态，等到路径上每一条水管都准备好了，供水公司就可以开始送水了。嘟嘟一次只能处理一项送水任务，等到当前的送水任务完成了，才能处理下一项。\n\n在处理每项送水任务之前，路径上的水管都要进行一系列的准备操作，如清洗、消毒等等。嘟嘟在控制中心一声令下，这些水管的准备操作同时开始，但由于各条管道的长度、内径不同，进行准备操作需要的时间可能不同。\n\n供水公司总是希望嘟嘟能找到这样一条送水路径，路径上的所有管道全都准备就绪所需要的时间尽量短。嘟嘟希望你能帮助他完成这样的一个选择路径的系统，以满足供水公司的要求。另外，由于 MY 市的水管年代久远，一些水管会不时出现故障导致不能使用，你的程序必须考虑到这一点。\n\n不妨将 MY 市的水管网络看作一幅简单无向图（即没有自环或重边）：水管是图中的边，水管的连接处为图中的结点。整张图共有 $n$ 个节点和 $m$ 条边，节点从 $1$ 至 $n$ 编号。\n", "inputFormat": "第一行有三个整数，分别表示管道连接处（结点）的数目 $n$，目前水管（无向边）的数目 $m$，以及你的程序需要处理的任务数目（包括寻找一条满足要求的路径和接受某条水管坏掉的事实）$q$。\n\n以下 $m$ 行，每行三个整数 $u, v, t$，表示存在一条连接 $(u, v)$ 的水管，准备时间为 $t$。\n\n以下 $q$ 行，每行三个整数 $k, u, v$，描述一项任务。其中 $k$ 表示任务类型：\n\n- 若 $k = 1$，则表示你需要为供水公司寻找一条满足要求的从 $u$ 到 $v$ 的水管路径，满足准备时间最短；\n- 若 $k = 2$，则表示直接连接 $u$ 和 $v$ 的水管宣布报废。\n", "outputFormat": "对于每个 $k = 1$ 的任务，输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n- $1 \\leq n \\leq 10^3$，$1 \\leq m, q \\leq 10^5$。\n- $1 \\leq k \\leq 2$，$1 \\leq u, v \\leq n$，$1 \\leq t \\leq 10^9$。\n- 给出的图无重边无自环，保证在宣布一条水管报废之前，该水管一定存在于图上且没有报废，\n- 宣布报废的水管不超过 $5 \\times 10^3$ 条，且在任意时刻，图一定是联通的。\n\n\n", "locale": "zh-CN"}}}
{"pid": "P4173", "type": "P", "difficulty": 6, "samples": [["3 7\na*b\naebr*ob", "2\n1 5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "数学", "快速傅里叶变换 FFT"], "title": "残缺的字符串", "background": null, "description": "很久很久以前，在你刚刚学习字符串匹配的时候，有两个仅包含小写字母的字符串 $A$ 和 $B$，其中 $A$ 串长度为 $m$，$B$ 串长度为 $n$。可当你现在再次碰到这两个串时，这两个串已经老化了，每个串都有不同程度的残缺。\n\n你想对这两个串重新进行匹配，其中 $A$ 为模板串，那么现在问题来了，请回答，对于 $B$ 的每一个位置 $i$，从这个位置开始连续 $m$ 个字符形成的子串是否可能与 $A$ 串完全匹配？", "inputFormat": "第一行包含两个正整数 $m,n$，分别表示 $A$ 串和 $B$ 串的长度。\n\n第二行为一个长度为 $m$ 的字符串 $A$。\n\n第三行为一个长度为 $n$ 的字符串 $B$。\n\n两个串均仅由小写字母和 $\\texttt *$ 组成，其中 $\\texttt *$ 表示相应位置已经残缺，每个 $\\texttt *$ 都可以匹配任意单个小写字母。", "outputFormat": "第一行包含一个整数 $k$，表示 $B$ 串中可以完全匹配 $A$ 串的位置个数。\n\n若 $k>0$，则第二行输出 $k$ 个正整数，从小到大依次输出每个可以匹配的开头位置（下标从 $1$ 开始）。", "hint": "$100\\%$ 的数据满足 $1 \\le m \\le n \\le 3 \\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Incomplete Strings", "background": "", "description": "Long ago, when you had just learned string matching, there were two strings $A$ and $B$ containing only lowercase letters, with lengths $m$ and $n$ respectively. Now, when you encounter these two strings again, they have aged; each string has become partially damaged.\n\nYou want to match the two strings again, taking $A$ as the pattern. For every position $i$ in $B$, determine whether the length-$m$ substring starting at this position could exactly match string $A$.", "inputFormat": "The first line contains two positive integers $m, n$, representing the lengths of strings $A$ and $B$ respectively.\n\nThe second line contains a string $A$ of length $m$.\n\nThe third line contains a string $B$ of length $n$.\n\nBoth strings consist only of lowercase letters and $\\texttt *$, where $\\texttt *$ indicates that the corresponding position is damaged and each $\\texttt *$ can match any single lowercase letter.", "outputFormat": "The first line contains an integer $k$, the number of starting positions in $B$ where $A$ can exactly match.\n\nIf $k > 0$, then on the second line output $k$ positive integers in increasing order, each being a valid starting position (indices start from $1$).", "hint": "For $100\\%$ of the testdata, $1 \\le m \\le n \\le 3 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "残缺的字符串", "background": null, "description": "很久很久以前，在你刚刚学习字符串匹配的时候，有两个仅包含小写字母的字符串 $A$ 和 $B$，其中 $A$ 串长度为 $m$，$B$ 串长度为 $n$。可当你现在再次碰到这两个串时，这两个串已经老化了，每个串都有不同程度的残缺。\n\n你想对这两个串重新进行匹配，其中 $A$ 为模板串，那么现在问题来了，请回答，对于 $B$ 的每一个位置 $i$，从这个位置开始连续 $m$ 个字符形成的子串是否可能与 $A$ 串完全匹配？", "inputFormat": "第一行包含两个正整数 $m,n$，分别表示 $A$ 串和 $B$ 串的长度。\n\n第二行为一个长度为 $m$ 的字符串 $A$。\n\n第三行为一个长度为 $n$ 的字符串 $B$。\n\n两个串均仅由小写字母和 $\\texttt *$ 组成，其中 $\\texttt *$ 表示相应位置已经残缺，每个 $\\texttt *$ 都可以匹配任意单个小写字母。", "outputFormat": "第一行包含一个整数 $k$，表示 $B$ 串中可以完全匹配 $A$ 串的位置个数。\n\n若 $k>0$，则第二行输出 $k$ 个正整数，从小到大依次输出每个可以匹配的开头位置（下标从 $1$ 开始）。", "hint": "$100\\%$ 的数据满足 $1 \\le m \\le n \\le 3 \\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4174", "type": "P", "difficulty": 6, "samples": [["5 5\n1 2 3 4 5\n1 2 3\n2 3 4\n1 3 3\n1 4 2\n4 5 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "NOI", "网络流", "广度优先搜索 BFS", "深度优先搜索 DFS"], "title": "[NOI2006] 最大获利", "background": "", "description": "新的技术正冲击着手机通讯市场，对于各大运营商来说，这既是机遇，更是挑战。THU 集团旗下的 CS&T 通讯公司在新一代通讯技术血战的前夜，需要做太多的准备工作，仅就站址选择一项，就需要完成前期市场研究、站址勘测、最优化等项目。\n\n在前期市场调查和站址勘测之后，公司得到了一共 $N$ 个可以作为通讯信号中转站的地址，而由于这些地址的地理位置差异，在不同的地方建造通讯中转站需要投入的成本也是不一样的，所幸在前期调查之后这些都是已知数据：建立第 $i$ 个通讯中转站需要的成本为 $P_i$（$1 \\leq i \\leq N$）。\n\n另外公司调查得出了所有期望中的用户群，一共 $M$ 个。关于第 $i$ 个用户群的信息概括为 $A_i$，$B_i$ 和 $C_i$ ：这些用户会使用中转站 $A_i$ 和中转站 $B_i$ 进行通讯，公司可以获益 $C_i$。（$1 \\leq i \\leq M$，$1 \\leq A_i, B_i \\leq N$）\n\nTHU 集团的 CS&T 公司可以有选择的建立一些中转站（投入成本），为一些用户提供服务并获得收益（获益之和）。那么如何选择最终建立的中转站才能让公司的净获利最大呢？（净获利 = 获益之和 – 投入成本之和）\n", "inputFormat": "输入文件中第一行有两个正整数 $N$ 和 $M$。\n\n第二行中有 $N$ 个整数描述每一个通讯中转站的建立成本，依次为 $P_1 , P_2 , …,P_N$。\n\n以下 $M$ 行，第 $i + 2$ 行的三个数 $A_i , B_i$ 和 $C_i$ 描述第 $i$ 个用户群的信息。\n\n所有变量的含义可以参见题目描述。\n", "outputFormat": "你的程序只要向输出文件输出一个整数，表示公司可以得到的最大净获利。\n", "hint": "样例：选择建立 $1,2,3$ 号中转站，则需要投入成本 $6$，获利为 $10$，因此得到最大收益 $4$。\n\n$100\\%$ 的数据中：$N \\leq 5\\,000$，$M \\leq50\\,000$，$0 \\leq C_i \\leq 100$，$0 \\leq P_i  \\leq 100$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2006] Maximum Profit", "background": "", "description": "New technologies are impacting the mobile communications market. For major operators, this is both an opportunity and a challenge. On the eve of the battle over next-generation communication technologies, the CS&T Communications company under the THU Group has a lot to prepare. Even for site selection alone, they need to complete preliminary market research, site surveys, and optimization.\n\nAfter the preliminary market research and site surveys, the company has identified a total of $N$ candidate locations for communication relay stations. Due to geographical differences, the cost of building a relay station varies by location. Fortunately, after the preliminary investigation, these data are known: the cost to build the $i$-th relay station is $P_i$ ($1 \\leq i \\leq N$).\n\nIn addition, the company has identified all target user groups, a total of $M$. The information for the $i$-th user group is summarized by $A_i$, $B_i$, and $C_i$: these users will use relay station $A_i$ and relay station $B_i$ to communicate, and the company can gain a profit of $C_i$ ($1 \\leq i \\leq M$, $1 \\leq A_i, B_i \\leq N$).\n\nThe CS&T company under THU can choose to build some relay stations (incurring costs), serve some user groups, and obtain revenue (the sum of gains). How should the company choose which relay stations to build to maximize net profit? (Net profit = sum of gains − sum of costs.)", "inputFormat": "The first line of the input contains two positive integers $N$ and $M$.\n\nThe second line contains $N$ integers describing the construction cost of each relay station, in order: $P_1 , P_2 , …,P_N$.\n\nThe following $M$ lines: the $(i + 2)$-th line contains three numbers $A_i$, $B_i$, and $C_i$ describing the information of the $i$-th user group.\n\nAll variables have the meanings described in the problem statement.", "outputFormat": "Output a single integer, representing the maximum net profit the company can obtain.", "hint": "Example: choose to build relay stations $1, 2, 3$. The total cost is $6$, and the total gain is $10$, so the maximum profit is $4$.\n\nFor $100\\%$ of the testdata: $N \\leq 5\\,000$, $M \\leq 50\\,000$, $0 \\leq C_i \\leq 100$, $0 \\leq P_i \\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2006] 最大获利", "background": "", "description": "新的技术正冲击着手机通讯市场，对于各大运营商来说，这既是机遇，更是挑战。THU 集团旗下的 CS&T 通讯公司在新一代通讯技术血战的前夜，需要做太多的准备工作，仅就站址选择一项，就需要完成前期市场研究、站址勘测、最优化等项目。\n\n在前期市场调查和站址勘测之后，公司得到了一共 $N$ 个可以作为通讯信号中转站的地址，而由于这些地址的地理位置差异，在不同的地方建造通讯中转站需要投入的成本也是不一样的，所幸在前期调查之后这些都是已知数据：建立第 $i$ 个通讯中转站需要的成本为 $P_i$（$1 \\leq i \\leq N$）。\n\n另外公司调查得出了所有期望中的用户群，一共 $M$ 个。关于第 $i$ 个用户群的信息概括为 $A_i$，$B_i$ 和 $C_i$ ：这些用户会使用中转站 $A_i$ 和中转站 $B_i$ 进行通讯，公司可以获益 $C_i$。（$1 \\leq i \\leq M$，$1 \\leq A_i, B_i \\leq N$）\n\nTHU 集团的 CS&T 公司可以有选择的建立一些中转站（投入成本），为一些用户提供服务并获得收益（获益之和）。那么如何选择最终建立的中转站才能让公司的净获利最大呢？（净获利 = 获益之和 – 投入成本之和）\n", "inputFormat": "输入文件中第一行有两个正整数 $N$ 和 $M$。\n\n第二行中有 $N$ 个整数描述每一个通讯中转站的建立成本，依次为 $P_1 , P_2 , …,P_N$。\n\n以下 $M$ 行，第 $i + 2$ 行的三个数 $A_i , B_i$ 和 $C_i$ 描述第 $i$ 个用户群的信息。\n\n所有变量的含义可以参见题目描述。\n", "outputFormat": "你的程序只要向输出文件输出一个整数，表示公司可以得到的最大净获利。\n", "hint": "样例：选择建立 $1,2,3$ 号中转站，则需要投入成本 $6$，获利为 $10$，因此得到最大收益 $4$。\n\n$100\\%$ 的数据中：$N \\leq 5\\,000$，$M \\leq50\\,000$，$0 \\leq C_i \\leq 100$，$0 \\leq P_i  \\leq 100$。\n", "locale": "zh-CN"}}}
{"pid": "P4175", "type": "P", "difficulty": 6, "samples": [["5 5\n5 1 2 3 4\n3 1\n2 1\n4 3\n5 3\n2 4 5\n0 1 2\n2 2 3\n2 1 4\n3 3 5", "3\n2\n2\ninvalid request!"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2008", "莫队", "线段树", "平衡树", "树状数组", "树链剖分", "树套树", "可持久化线段树", "分块", "整体二分", "CTSC/CTS"], "title": "[CTSC2008] 网络管理", "background": "", "description": "M 公司是一个非常庞大的跨国公司，在许多国家都设有它的下属分支机构或部门。为了让分布在世界各地的 $n$ 个部门之间协同工作，公司搭建了一个连接整个公司的通信网络。  \n\n该网络的结构由 $n$ 个路由器和 $n-1$ 条高速光缆组成。每个部门都有一个专属的路由器，部门局域网内的所有机器都联向这个路由器，然后再通过这个通信子网与其他部门进行通信联络。该网络结构保证网络中的任意两个路由器之间都存在一条直接或间接路径以进行通信。   \n\n高速光缆的数据传输速度非常快，以至于利用光缆传输的延迟时间可以忽略。但是由于路由器老化，在这些路由器上进行数据交换会带来很大的延迟。而两个路由器之间的通信延迟时间则与这两个路由器通信路径上所有路由器中最大的交换延迟时间有关。  \n\n作为 M 公司网络部门的一名实习员工，现在要求你编写一个简单的程序来监视公司的网络状况。该程序能够随时更新网络状况的变化信息（路由器数据交换延迟时间的变化），并且根据询问给出两个路由器通信路径上延迟第 $k$ 大的路由器的延迟时间。\n****\n【任务】   \n你的程序从输入文件中读入 $n$ 个路由器和 $n-1$ 条光缆的连接信息，每个路由器初始的数据交换延迟时间 $t_i$，以及 $q$ 条询问（或状态改变）的信息。并依次处理这 $q$ 条询问信息，它们可能是：\n\n1. 由于更新了设备，或者设备出现新的故障，使得某个路由器的数据交换延迟时间发生了变化。\n\n2. 查询某两个路由器 $a$ 和 $v$ 之间的路径上延迟第 $k$ 大的路由器的延迟时间。\n", "inputFormat": "第一行为两个整数 $n$ 和 $q$，分别表示路由器总数和询问的总数。\n\n第二行有 $n$ 个整数，第 $i$ 个数表示编号为i的路由器初始的数据延迟时间 $t_i$。\n\n紧接着 $n-1$ 行，每行包含两个整数 $x$ 和 $y$。表示有一条光缆连接路由器 $x$ 和路由器 $y$。\n\n紧接着是 $q$ 行，每行三个整数 $k,a,b$。\n\n如果 $k=0$，则表示路由器 $a$ 的状态发生了变化，它的数据交换延迟时间由 $t_a$ 变为 $b$。\n\n如果 $k>0$，则表示询问 $a$ 到 $b$ 的路径上所经过的所有路由器（包括 $a$ 和 $b$）中延迟第 $k$ 大的路由器的延迟时间。注意 $a$ 可以等于 $b$，此时路径上只有一个路由器。\n", "outputFormat": "对于每一个第二种询问（即 $k>0$ ），输出一行。  \n包含一个整数为相应的延迟时间。如果路径上的路由器不足 $k$ 个，则输出信息 `invalid request!`。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n,q \\le 80000$，$0 \\le k \\le n$，任意一个路由器在任何时刻都满足延迟时间小于 $10^8$。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2008] Network Management", "background": "", "description": "Company M is a very large multinational with branches or departments in many countries. To let the $n$ departments distributed around the world work together, the company built a communication network that connects the entire company.\n\nThe network consists of $n$ routers and $n-1$ high-speed fiber-optic cables. Each department has a dedicated router; all machines in the department’s local area network connect to this router, and then communicate with other departments through this communication subnet. The network structure guarantees that between any two routers there exists a direct or indirect path for communication.\n\nThe fiber-optic cables transmit data so fast that the latency on the cables can be ignored. However, due to router aging, exchanging data on the routers introduces significant delay. The communication delay between two routers is determined by the maximum exchange delay among all routers on the communication path between the two routers.\n\nAs an intern in Company M’s network division, you are asked to write a simple program to monitor the company’s network status. The program must be able to update the network status at any time (changes in routers’ data exchange delay), and, upon queries, report the delay of the $k$-th largest-delay router on the path between two routers.\n\nTask: Your program reads from the input file the connectivity of the $n$ routers and $n-1$ fiber-optic cables, the initial data exchange delay $t_i$ of each router, and $q$ queries (or state changes). Process the $q$ queries in order; each is one of:\n1. Due to an upgrade or a new fault, a router’s data exchange delay changes.\n2. Query the delay of the $k$-th largest-delay router on the path between routers $a$ and $b$.", "inputFormat": "The first line contains two integers $n$ and $q$, the total number of routers and the total number of queries.\n\nThe second line contains $n$ integers; the $i$-th number is the initial data exchange delay $t_i$ of router $i$.\n\nThe next $n-1$ lines each contain two integers $x$ and $y$, indicating there is a fiber-optic cable connecting router $x$ and router $y$.\n\nThen follow $q$ lines, each containing three integers $k, a, b$.\n\nIf $k=0$, router $a$ changes state: its data exchange delay changes from $t_a$ to $b$.\n\nIf $k>0$, query the $k$-th largest delay among all routers on the path from $a$ to $b$ (including $a$ and $b$). Note that $a$ can be equal to $b$; in this case, the path contains only one router.", "outputFormat": "For each query of the second type (i.e., $k>0$), output one line containing a single integer, the corresponding delay. If the routers on the path are fewer than $k$, output `invalid request!`.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n, q \\le 80000$, $0 \\le k \\le n$, and at any time the delay of any router is less than $10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2008] 网络管理", "background": "", "description": "M 公司是一个非常庞大的跨国公司，在许多国家都设有它的下属分支机构或部门。为了让分布在世界各地的 $n$ 个部门之间协同工作，公司搭建了一个连接整个公司的通信网络。  \n\n该网络的结构由 $n$ 个路由器和 $n-1$ 条高速光缆组成。每个部门都有一个专属的路由器，部门局域网内的所有机器都联向这个路由器，然后再通过这个通信子网与其他部门进行通信联络。该网络结构保证网络中的任意两个路由器之间都存在一条直接或间接路径以进行通信。   \n\n高速光缆的数据传输速度非常快，以至于利用光缆传输的延迟时间可以忽略。但是由于路由器老化，在这些路由器上进行数据交换会带来很大的延迟。而两个路由器之间的通信延迟时间则与这两个路由器通信路径上所有路由器中最大的交换延迟时间有关。  \n\n作为 M 公司网络部门的一名实习员工，现在要求你编写一个简单的程序来监视公司的网络状况。该程序能够随时更新网络状况的变化信息（路由器数据交换延迟时间的变化），并且根据询问给出两个路由器通信路径上延迟第 $k$ 大的路由器的延迟时间。\n****\n【任务】   \n你的程序从输入文件中读入 $n$ 个路由器和 $n-1$ 条光缆的连接信息，每个路由器初始的数据交换延迟时间 $t_i$，以及 $q$ 条询问（或状态改变）的信息。并依次处理这 $q$ 条询问信息，它们可能是：\n\n1. 由于更新了设备，或者设备出现新的故障，使得某个路由器的数据交换延迟时间发生了变化。\n\n2. 查询某两个路由器 $a$ 和 $v$ 之间的路径上延迟第 $k$ 大的路由器的延迟时间。\n", "inputFormat": "第一行为两个整数 $n$ 和 $q$，分别表示路由器总数和询问的总数。\n\n第二行有 $n$ 个整数，第 $i$ 个数表示编号为i的路由器初始的数据延迟时间 $t_i$。\n\n紧接着 $n-1$ 行，每行包含两个整数 $x$ 和 $y$。表示有一条光缆连接路由器 $x$ 和路由器 $y$。\n\n紧接着是 $q$ 行，每行三个整数 $k,a,b$。\n\n如果 $k=0$，则表示路由器 $a$ 的状态发生了变化，它的数据交换延迟时间由 $t_a$ 变为 $b$。\n\n如果 $k>0$，则表示询问 $a$ 到 $b$ 的路径上所经过的所有路由器（包括 $a$ 和 $b$）中延迟第 $k$ 大的路由器的延迟时间。注意 $a$ 可以等于 $b$，此时路径上只有一个路由器。\n", "outputFormat": "对于每一个第二种询问（即 $k>0$ ），输出一行。  \n包含一个整数为相应的延迟时间。如果路径上的路由器不足 $k$ 个，则输出信息 `invalid request!`。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n,q \\le 80000$，$0 \\le k \\le n$，任意一个路由器在任何时刻都满足延迟时间小于 $10^8$。\n\n", "locale": "zh-CN"}}}
{"pid": "P4176", "type": "P", "difficulty": 6, "samples": [["3 1", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2006", "各省省选", "湖南"], "title": "[HNOI2006] 花仙子的魔法", "background": "", "description": "相传，在天地初成的远古时代，世界上只有一种叫做“元”的花。接下来，出现了一位拥有魔法的花仙子，她能给花附加属性，从此，“元”便不断变异，产生了大千世界千奇百怪的各种各样的花。据说，花仙子既可存在于二维空间（平面），又可存在于三维空间（立体），还可存在于 $n$ 维空间（想象）。二维空间的点可用向量 $\\left(x_1,x_2\\right)$ 表示，三维空间的点可用向量 $\\left(x_1,x_2,x_3\\right)$ 表示，一般来说，$n$ 维空间的点可用向量 $\\left(x_1,x_2,\\cdots,x_n\\right)$ 表示。而 $n$ 维空间中两点 $\\left(x_1,x_2,\\cdots,x_n\\right)$ 与 $\\left(w_1,w_2,\\cdots,w_n\\right)$ 之间的距离定义为$\\sqrt{\\sum_{i=1}^{n}(X_i-W_i)^2}$。 在 $n$ 维空间中，花仙子每实施魔法就要选择一个参考点 $\\left(w_1,w_2,\\cdots,w_n\\right)$ 和一个作用半径 $r$，并且参考点的位置和作用半径的大小可以任意选择。这时，$n$ 维空间中所有与参考点 $\\left(w_1,w_2,\\cdots,w_n\\right)$ 之间的距离小于作用半径 $r$ 的花都会受到这次魔法的影响。每次魔法都会给受到影响的花带来不同的属性，且的效 果可以叠加。一般来说，若花仙子总共实施了 $m$ 次魔法，则 $n$ 维空间中处于某点的花所具有的属性可用长度为 $m$ 的二进制串 $\\left(a_1,a_2,\\cdots,a_n\\right)$ 来描述，其中对 $1\\le i\\le m$，若该花受到第 $i$ 次魔法的影响，则 $a_i$ 的值为 $1$,否则为 $0$。显然，不同的属性对应不同的花。 现在的问题是：花仙子在 $n$ 维空间中实施了 $m$ 次魔法后，最多能得到多少种不同的花？\n", "inputFormat": "包含两个整数，并用一个空格隔开，第一个整数表示实施魔法的次数 $m$，第二个整数表示空间的维数 $n$。其中，$1\\le m\\le 100$，$1 \\le n \\le 15$。\n", "outputFormat": "输出一行一个整数表示答案。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2006] The Flower Fairy’s Magic", "background": "", "description": "Legend says that in the primordial era when heaven and earth first formed, there was only one kind of flower in the world, called “Yuan” (yuan). Later, a Flower Fairy with magic appeared. She could add attributes to flowers, and from then on “Yuan” kept mutating, giving rise to countless diverse flowers. It is said that the Flower Fairy can exist in two-dimensional space (plane), three-dimensional space (solid), and even $n$-dimensional space (imagination). A point in two-dimensional space can be represented by the vector $\\left(x_1,x_2\\right)$, a point in three-dimensional space by $\\left(x_1,x_2,x_3\\right)$, and in general, a point in $n$-dimensional space by $\\left(x_1,x_2,\\cdots,x_n\\right)$. The distance between two points $\\left(x_1,x_2,\\cdots,x_n\\right)$ and $\\left(w_1,w_2,\\cdots,w_n\\right)$ in $n$-dimensional space is defined as $\\sqrt{\\sum_{i=1}^{n}(X_i-W_i)^2}$.\n\nIn $n$-dimensional space, every time the Flower Fairy performs magic, she chooses a reference point $\\left(w_1,w_2,\\cdots,w_n\\right)$ and an action radius $r$, and both the position of the reference point and the size of the radius can be chosen arbitrarily. At this time, all flowers in $n$-dimensional space whose distance to the reference point $\\left(w_1,w_2,\\cdots,w_n\\right)$ is less than $r$ will be affected by this spell. Each spell gives different attributes to the affected flowers, and the effects can be stacked.\n\nIn general, if the Flower Fairy performs $m$ spells in total, then the attributes of the flower located at any point in $n$-dimensional space can be described by a binary string of length $m$, $\\left(a_1,a_2,\\cdots,a_n\\right)$. For $1 \\le i \\le m$, if the flower is affected by the $i$-th spell, then $a_i$ is $1$; otherwise $a_i$ is $0$. Obviously, different attributes correspond to different kinds of flowers. The problem is: after the Flower Fairy performs $m$ spells in $n$-dimensional space, what is the maximum number of different kinds of flowers she can obtain?", "inputFormat": "Contains two integers separated by a space. The first integer $m$ is the number of spells performed, and the second integer $n$ is the dimension of the space. Constraints: $1 \\le m \\le 100$, $1 \\le n \\le 15$.", "outputFormat": "Output one line with a single integer representing the answer.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2006] 花仙子的魔法", "background": "", "description": "相传，在天地初成的远古时代，世界上只有一种叫做“元”的花。接下来，出现了一位拥有魔法的花仙子，她能给花附加属性，从此，“元”便不断变异，产生了大千世界千奇百怪的各种各样的花。据说，花仙子既可存在于二维空间（平面），又可存在于三维空间（立体），还可存在于 $n$ 维空间（想象）。二维空间的点可用向量 $\\left(x_1,x_2\\right)$ 表示，三维空间的点可用向量 $\\left(x_1,x_2,x_3\\right)$ 表示，一般来说，$n$ 维空间的点可用向量 $\\left(x_1,x_2,\\cdots,x_n\\right)$ 表示。而 $n$ 维空间中两点 $\\left(x_1,x_2,\\cdots,x_n\\right)$ 与 $\\left(w_1,w_2,\\cdots,w_n\\right)$ 之间的距离定义为$\\sqrt{\\sum_{i=1}^{n}(X_i-W_i)^2}$。 在 $n$ 维空间中，花仙子每实施魔法就要选择一个参考点 $\\left(w_1,w_2,\\cdots,w_n\\right)$ 和一个作用半径 $r$，并且参考点的位置和作用半径的大小可以任意选择。这时，$n$ 维空间中所有与参考点 $\\left(w_1,w_2,\\cdots,w_n\\right)$ 之间的距离小于作用半径 $r$ 的花都会受到这次魔法的影响。每次魔法都会给受到影响的花带来不同的属性，且的效 果可以叠加。一般来说，若花仙子总共实施了 $m$ 次魔法，则 $n$ 维空间中处于某点的花所具有的属性可用长度为 $m$ 的二进制串 $\\left(a_1,a_2,\\cdots,a_n\\right)$ 来描述，其中对 $1\\le i\\le m$，若该花受到第 $i$ 次魔法的影响，则 $a_i$ 的值为 $1$,否则为 $0$。显然，不同的属性对应不同的花。 现在的问题是：花仙子在 $n$ 维空间中实施了 $m$ 次魔法后，最多能得到多少种不同的花？\n", "inputFormat": "包含两个整数，并用一个空格隔开，第一个整数表示实施魔法的次数 $m$，第二个整数表示空间的维数 $n$。其中，$1\\le m\\le 100$，$1 \\le n \\le 15$。\n", "outputFormat": "输出一行一个整数表示答案。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4177", "type": "P", "difficulty": 6, "samples": [["2 3\n100 2\n1 30\n2 20\n100 2\n1 40\n3 80\n50\n80\n110", "50"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "CEOI（中欧）", "最小割"], "title": "[CEOI 2008] order", "background": "", "description": "有 $N$ 个工作，$M$ 种机器，每种机器可以租或者买。每个工作包括若干道工序，每道工序需要某种机器来完成。\n\n你需要最大化利益。", "inputFormat": "第一行给出 $N,M$。\n\n接下来若干行描述一个工作，对于每个工作，第一行给定 $x_i$ 和 $t_i$，分别表示此工作的收入和工序数。\n\n后面 $t_i$ 行，每行两个整数 $a_{ij}$ 和 $b_{ij}$，分别表示此工序需要的机器和此工作租用此机器的费用。\n\n最后 $M$ 行，每行一个正整数表示购买机器的费用 $y_i$。", "outputFormat": "最大利润\n", "hint": "对于 $100\\%$ 的数据满足 $1\\le N,M\\le 1200，1\\le x_i\\le 5000，b_{ij},y_i\\le 20000$。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2008] order", "background": "", "description": "There are $N$ jobs and $M$ types of machines. Each type of machine can either be rented or purchased. Each job consists of several operations, and each operation requires a certain type of machine to complete.\n\nYou need to maximize the profit.", "inputFormat": "The first line gives $N, M$.\n\nThen, for each of the $N$ jobs:\n- The first line gives $x_i$ and $t_i$, denoting the revenue of this job and the number of operations, respectively.\n- The next $t_i$ lines each contain two integers $a_{ij}$ and $b_{ij}$, denoting the machine required for this operation and the cost of renting this machine for this job, respectively.\n\nFinally, the last $M$ lines each contain a positive integer $y_i$, denoting the cost of purchasing machine $i$.", "outputFormat": "The maximum profit.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le N, M \\le 1200$, $1 \\le x_i \\le 5000$, $b_{ij}, y_i \\le 20000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CEOI 2008] order", "background": "", "description": "有 $N$ 个工作，$M$ 种机器，每种机器可以租或者买。每个工作包括若干道工序，每道工序需要某种机器来完成。\n\n你需要最大化利益。", "inputFormat": "第一行给出 $N,M$。\n\n接下来若干行描述一个工作，对于每个工作，第一行给定 $x_i$ 和 $t_i$，分别表示此工作的收入和工序数。\n\n后面 $t_i$ 行，每行两个整数 $a_{ij}$ 和 $b_{ij}$，分别表示此工序需要的机器和此工作租用此机器的费用。\n\n最后 $M$ 行，每行一个正整数表示购买机器的费用 $y_i$。", "outputFormat": "最大利润\n", "hint": "对于 $100\\%$ 的数据满足 $1\\le N,M\\le 1200，1\\le x_i\\le 5000，b_{ij},y_i\\le 20000$。", "locale": "zh-CN"}}}
{"pid": "P4178", "type": "P", "difficulty": 5, "samples": [["7\n1 6 13 \n6 3 9 \n3 5 7 \n4 1 3 \n2 4 20 \n4 7 2 \n10", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["线段树", "点分治", "树状数组", "树上启发式合并", "分治", "容斥原理"], "title": "Tree", "background": "", "description": "给定一棵 $n$ 个节点的树，每条边有边权，求出树上两点距离小于等于 $k$ 的点对数量。  ", "inputFormat": "第一行输入一个整数 $n$，表示节点个数。  \n\n第二行到第 $n$ 行每行输入三个整数 $u,v,w$ ，表示 $u$ 与 $v$ 有一条边，边权是 $w$。  \n\n第 $n+1$ 行一个整数 $k$ 。 ", "outputFormat": "一行一个整数，表示答案。  ", "hint": "**数据规模与约定**\n\n对于全部的测试点，保证：  \n\n- $1\\leq n\\leq 4\\times 10^4$。\n- $1\\leq u,v\\leq n$。\n- $0\\leq w\\leq 10^3$。\n- $0\\leq k\\leq 2\\times 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "Tree", "background": "", "description": "Given a tree with $n$ nodes where each edge has a weight, find the number of pairs of nodes whose distance on the tree is less than or equal to $k$.", "inputFormat": "The first line contains an integer $n$, the number of nodes.\n\nLines $2$ to $n$ each contain three integers $u, v, w$, indicating there is an edge between $u$ and $v$ with weight $w$.\n\nLine $n+1$ contains an integer $k$.", "outputFormat": "Output a single integer on one line, the answer.", "hint": "Constraints\n\nFor all test points, it is guaranteed that:\n- $1 \\le n \\le 4 \\times 10^4$.\n- $1 \\le u, v \\le n$.\n- $0 \\le w \\le 10^3$.\n- $0 \\le k \\le 2 \\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Tree", "background": "", "description": "给定一棵 $n$ 个节点的树，每条边有边权，求出树上两点距离小于等于 $k$ 的点对数量。  ", "inputFormat": "第一行输入一个整数 $n$，表示节点个数。  \n\n第二行到第 $n$ 行每行输入三个整数 $u,v,w$ ，表示 $u$ 与 $v$ 有一条边，边权是 $w$。  \n\n第 $n+1$ 行一个整数 $k$ 。 ", "outputFormat": "一行一个整数，表示答案。  ", "hint": "**数据规模与约定**\n\n对于全部的测试点，保证：  \n\n- $1\\leq n\\leq 4\\times 10^4$。\n- $1\\leq u,v\\leq n$。\n- $0\\leq w\\leq 10^3$。\n- $0\\leq k\\leq 2\\times 10^4$。", "locale": "zh-CN"}}}
{"pid": "P4179", "type": "P", "difficulty": 6, "samples": [["5 30", "190.803848"], ["3 45", "15.500000"], ["4 10", "91.573592\n"], ["3 0", "26.000000\n\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "重庆", "各省省选"], "title": "[CQOI2010] 鼹鼠", "background": "", "description": "Hilbert鼹鼠住在Hilbert地洞里——地洞的边界是一条$n$阶Hilbert曲线${H_n}$。Hilbert曲线的定义如下：${H_1}$是一个上端缺口的单位正方形；$H_n$由四份${H_n}-1$组成，其中左下和右下两份没有任何变化，而左上的那一份逆时针旋转了90度，而右上的那一份顺时针旋转了90度。这四份$H_n-1$用三条单位长度的线段连接起来构成了$H_n$。$H_1$~$H_4$如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0vif0fh6.png)\n\n你想捉一只Hilbert鼹鼠来玩，所以往地洞里使劲倒水想把它们赶出来。不过，由于地洞里有空气，无论你怎么倒水，有些地方总是淹不到的（假设水和空气都不可压缩）。输入Hilbert曲线\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/aaj85oki.png)\n\n的阶数 $n$ 和地面的倾斜角 $α$ ，你的任务是计算能淹没到的面积。\n\n注意，只有当水位严格高于一个障碍物时，水才能越过它往下流。更多细节可以参考下面的例子。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bbvmrpvd.png)\n", "inputFormat": "输入仅包含两个整数$n$，$α$。\n", "outputFormat": "输出仅一行，即被淹没的面积，输出保留小数点后6位。\n", "hint": "$rt,n<=12,0<=alpha<=90$", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2010] Mole", "background": "", "description": "The Hilbert mole lives in a Hilbert burrow — the burrow’s boundary is an order-$n$ Hilbert curve $H_n$. The Hilbert curve is defined as follows: $H_1$ is a unit square with an opening at the top; $H_n$ is composed of four copies of $H_{n-1}$, where the lower-left and lower-right copies remain unchanged, the upper-left copy is rotated 90 degrees counterclockwise, and the upper-right copy is rotated 90 degrees clockwise. These four copies of $H_{n-1}$ are connected by three unit-length segments to form $H_n$. $H_1$–$H_4$ are shown below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0vif0fh6.png)\n\nYou want to catch a Hilbert mole, so you pour water into the burrow to flush it out. However, because there is air inside the burrow and both water and air are incompressible, some places can never be flooded no matter how much water you pour. Given the order $n$ of the Hilbert curve\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/aaj85oki.png)\n\nand the ground tilt angle $\\alpha$, your task is to compute the area that can be flooded.\n\nNote that water can flow past an obstacle only when the water level is strictly higher than the obstacle. See the example below for more details.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bbvmrpvd.png)", "inputFormat": "The input contains two integers $n$ and $\\alpha$.", "outputFormat": "Output a single line with the flooded area, with 6 digits after the decimal point.", "hint": "Constraints: $n \\le 12$, $0 \\le \\alpha \\le 90$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2010] 鼹鼠", "background": "", "description": "Hilbert鼹鼠住在Hilbert地洞里——地洞的边界是一条$n$阶Hilbert曲线${H_n}$。Hilbert曲线的定义如下：${H_1}$是一个上端缺口的单位正方形；$H_n$由四份${H_n}-1$组成，其中左下和右下两份没有任何变化，而左上的那一份逆时针旋转了90度，而右上的那一份顺时针旋转了90度。这四份$H_n-1$用三条单位长度的线段连接起来构成了$H_n$。$H_1$~$H_4$如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0vif0fh6.png)\n\n你想捉一只Hilbert鼹鼠来玩，所以往地洞里使劲倒水想把它们赶出来。不过，由于地洞里有空气，无论你怎么倒水，有些地方总是淹不到的（假设水和空气都不可压缩）。输入Hilbert曲线\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/aaj85oki.png)\n\n的阶数 $n$ 和地面的倾斜角 $α$ ，你的任务是计算能淹没到的面积。\n\n注意，只有当水位严格高于一个障碍物时，水才能越过它往下流。更多细节可以参考下面的例子。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bbvmrpvd.png)\n", "inputFormat": "输入仅包含两个整数$n$，$α$。\n", "outputFormat": "输出仅一行，即被淹没的面积，输出保留小数点后6位。\n", "hint": "$rt,n<=12,0<=alpha<=90$", "locale": "zh-CN"}}}
{"pid": "P4180", "type": "P", "difficulty": 6, "samples": [["5 6\n1 2 1 \n1 3 2 \n2 4 3 \n3 5 4 \n3 4 3 \n4 5 6 ", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2010", "倍增", "北京", "O2优化", "生成树", "最近公共祖先 LCA"], "title": "[BJWC2010] 严格次小生成树", "background": "", "description": "小 C 最近学了很多最小生成树的算法，Prim 算法、Kruskal 算法、消圈算法等等。正当小 C 洋洋得意之时，小 P 又来泼小 C 冷水了。小 P 说，让小 C 求出一个无向图的次小生成树，而且这个次小生成树还得是严格次小的，也就是说：如果最小生成树选择的边集是 $E_M$，严格次小生成树选择的边集是 $E_S$，那么需要满足：($value(e)$ 表示边 $e$ 的权值) $\\sum_{e \\in E_M}value(e)<\\sum_{e \\in E_S}value(e)$。\n\n这下小 C 蒙了，他找到了你，希望你帮他解决这个问题。\n", "inputFormat": "第一行包含两个整数 $N$ 和 $M$，表示无向图的点数与边数。\n\n接下来 $M$ 行，每行 $3$ 个数 $x,y,z$ 表示，点 $x$ 和点 $y$ 之间有一条边，边的权值为 $z$。\n", "outputFormat": "包含一行，仅一个数，表示严格次小生成树的边权和。\n", "hint": "数据中无向图**不保证无自环**。\n\n对于 $50\\%$ 的数据， $N\\le 2000$，$M\\le 3000$。\n\n对于 $80\\%$ 的数据， $N\\le 5\\times 10^4$，$M\\le 10^5$。\n\n对于 $100\\%$ 的数据， $N\\le 10^5$，$M\\le 3\\times10^5$，边权  $\\in [0,10^9]$，数据保证必定存在严格次小生成树。", "locale": "zh-CN", "translations": {"en": {"title": "[BJWC2010] Strictly Second Minimum Spanning Tree", "background": "", "description": "Xiao C recently learned many algorithms for the minimum spanning tree, such as Prim, Kruskal, and cycle-canceling, etc. Just as Xiao C was feeling proud, Xiao P poured cold water on him. Xiao P asked Xiao C to find the second minimum spanning tree of an undirected graph, and it must be strictly second, that is: if the edge set chosen by the minimum spanning tree is $E_M$, and the edge set chosen by the strictly second minimum spanning tree is $E_S$, then it must satisfy: (here $value(e)$ denotes the weight of edge $e$) $\\sum_{e \\in E_M}value(e)<\\sum_{e \\in E_S}value(e)$.\n\nXiao C was stumped and came to you for help to solve this problem.", "inputFormat": "The first line contains two integers $N$ and $M$, denoting the number of vertices and edges of the undirected graph.\n\nThe next $M$ lines each contain three numbers $x, y, z$, indicating that there is an edge between vertex $x$ and vertex $y$ with weight $z$.", "outputFormat": "Output one line with a single number, the sum of edge weights of the strictly second minimum spanning tree.", "hint": "- The undirected graph may contain self-loops.\n\nConstraints:\n- For 50% of the testdata, $N \\le 2000$, $M \\le 3000$.\n- For 80% of the testdata, $N \\le 5 \\times 10^4$, $M \\le 10^5$.\n- For 100% of the testdata, $N \\le 10^5$, $M \\le 3 \\times 10^5$, edge weights $\\in [0,10^9]$, and the testdata guarantees that a strictly second minimum spanning tree exists.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJWC2010] 严格次小生成树", "background": "", "description": "小 C 最近学了很多最小生成树的算法，Prim 算法、Kruskal 算法、消圈算法等等。正当小 C 洋洋得意之时，小 P 又来泼小 C 冷水了。小 P 说，让小 C 求出一个无向图的次小生成树，而且这个次小生成树还得是严格次小的，也就是说：如果最小生成树选择的边集是 $E_M$，严格次小生成树选择的边集是 $E_S$，那么需要满足：($value(e)$ 表示边 $e$ 的权值) $\\sum_{e \\in E_M}value(e)<\\sum_{e \\in E_S}value(e)$。\n\n这下小 C 蒙了，他找到了你，希望你帮他解决这个问题。\n", "inputFormat": "第一行包含两个整数 $N$ 和 $M$，表示无向图的点数与边数。\n\n接下来 $M$ 行，每行 $3$ 个数 $x,y,z$ 表示，点 $x$ 和点 $y$ 之间有一条边，边的权值为 $z$。\n", "outputFormat": "包含一行，仅一个数，表示严格次小生成树的边权和。\n", "hint": "数据中无向图**不保证无自环**。\n\n对于 $50\\%$ 的数据， $N\\le 2000$，$M\\le 3000$。\n\n对于 $80\\%$ 的数据， $N\\le 5\\times 10^4$，$M\\le 10^5$。\n\n对于 $100\\%$ 的数据， $N\\le 10^5$，$M\\le 3\\times10^5$，边权  $\\in [0,10^9]$，数据保证必定存在严格次小生成树。", "locale": "zh-CN"}}}
{"pid": "P4181", "type": "P", "difficulty": 4, "samples": [["5 3 4\n6\n2\n4\n7\n1\n10 25\n2 10\n15 15\n250\n80\n100\n40", "725\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2018", "USACO", "排序"], "title": "[USACO18JAN] Rental Service S", "background": "", "description": "Farmer John realizes that the income he receives from milk production is insufficient to fund the growth of his farm, so to earn some extra money, he launches a cow-rental service, which he calls \"USACOW\" (pronounced \"Use-a-cow\").\n\nFarmer John has $N$ cows ($1 \\leq N \\leq 100,000$), each capable of producing some amount of milk every day. The $M$ stores near FJ's farm ($1 \\leq M \\leq 100,000$) each offer to buy a certain amount of milk at a certain price. Moreover, Farmer John's $R$ ($1 \\leq R \\leq 100,000$) neighboring farmers are each interested in renting a cow at a certain price.\n\n\nFarmer John has to choose whether each cow should be milked or rented to a nearby farmer. Help him find the maximum amount of money he can make per day.\n", "inputFormat": "The first line in the input contains $N$, $M$, and $R$. The next $N$ lines each contain an integer $c_i$ ($1 \\leq c_i \\leq 1,000,000$), indicating that Farmer John's $i$th cow can produce $c_i$ gallons of milk every day. The next $M$ lines each contain two integers $q_i$ and $p_i$ ($1 \\leq q_i, p_i \\leq 1,000,000$), indicating that the $i$th store is willing to buy up to $q_i$ gallons of milk for $p_i$ cents per gallon. Keep in mind that Farmer John can sell any amount of milk between zero and $q_i$ gallons to a given store. The next $R$ lines each contain an integer $r_i$ ($1 \\leq r_i \\leq 1,000,000$), indicating that one of Farmer John's neighbors wants to rent a cow for $r_i$ cents per day.\n", "outputFormat": "The output should consist of one line containing the maximum profit Farmer John can make per day by milking or renting out each of his cows. Note that the output might be too large to fit into a standard 32-bit integer, so you may need to use a larger integer type like a \"long long\" in C/C++.\n", "hint": "Farmer John should milk cows #1 and #4, to produce 13 gallons of milk. He should completely fill the order for 10 gallons, earning 250 cents, and sell the remaining three gallons at 15 cents each, for a total of 295 cents of milk profits.\n\n\nThen, he should rent out the other three cows for 250, 80, and 100 cents, to earn 430 more cents. (He should leave the request for a 40-cent rental unfilled.) This is a total of 725 cents of daily profit.\n", "locale": "en", "translations": {"en": {"title": "[USACO18JAN] Rental Service S", "background": "", "description": "Farmer John realizes that the income he receives from milk production is insufficient to fund the growth of his farm, so to earn some extra money, he launches a cow-rental service, which he calls \"USACOW\" (pronounced \"Use-a-cow\").\n\nFarmer John has $N$ cows ($1 \\leq N \\leq 100,000$), each capable of producing some amount of milk every day. The $M$ stores near FJ's farm ($1 \\leq M \\leq 100,000$) each offer to buy a certain amount of milk at a certain price. Moreover, Farmer John's $R$ ($1 \\leq R \\leq 100,000$) neighboring farmers are each interested in renting a cow at a certain price.\n\n\nFarmer John has to choose whether each cow should be milked or rented to a nearby farmer. Help him find the maximum amount of money he can make per day.\n", "inputFormat": "The first line in the input contains $N$, $M$, and $R$. The next $N$ lines each contain an integer $c_i$ ($1 \\leq c_i \\leq 1,000,000$), indicating that Farmer John's $i$th cow can produce $c_i$ gallons of milk every day. The next $M$ lines each contain two integers $q_i$ and $p_i$ ($1 \\leq q_i, p_i \\leq 1,000,000$), indicating that the $i$th store is willing to buy up to $q_i$ gallons of milk for $p_i$ cents per gallon. Keep in mind that Farmer John can sell any amount of milk between zero and $q_i$ gallons to a given store. The next $R$ lines each contain an integer $r_i$ ($1 \\leq r_i \\leq 1,000,000$), indicating that one of Farmer John's neighbors wants to rent a cow for $r_i$ cents per day.\n", "outputFormat": "The output should consist of one line containing the maximum profit Farmer John can make per day by milking or renting out each of his cows. Note that the output might be too large to fit into a standard 32-bit integer, so you may need to use a larger integer type like a \"long long\" in C/C++.\n", "hint": "Farmer John should milk cows #1 and #4, to produce 13 gallons of milk. He should completely fill the order for 10 gallons, earning 250 cents, and sell the remaining three gallons at 15 cents each, for a total of 295 cents of milk profits.\n\n\nThen, he should rent out the other three cows for 250, 80, and 100 cents, to earn 430 more cents. (He should leave the request for a 40-cent rental unfilled.) This is a total of 725 cents of daily profit.\n", "locale": "en"}, "zh-CN": {"title": "[USACO18JAN] Rental Service S", "background": null, "description": "Farmer John 意识到牛奶生产的收入不足以支持农场的扩展，因此为了赚取额外收入，他推出了一项奶牛租赁服务，称为“USACOW”（发音为“Use-a-cow”）。\n\nFarmer John 有 $N$ 头奶牛（$1 \\leq N \\leq 100,000$），每头奶牛每天可以生产一定量的牛奶。附近的 $M$ 家商店（$1 \\leq M \\leq 100,000$）每家都愿意以一定价格购买一定量的牛奶。此外，Farmer John 的 $R$ 个邻居（$1 \\leq R \\leq 100,000$）每家都愿意以一定价格租赁一头奶牛。\n\nFarmer John 需要决定每头奶牛是用于产奶还是租给附近的农民。请帮助他计算每天可以赚取的最大金额。", "inputFormat": "输入的第一行包含 $N$、$M$ 和 $R$。\n\n接下来的 $N$ 行每行包含一个整数 $c_i$（$1 \\leq c_i \\leq 1,000,000$），表示 Farmer John 的第 $i$ 头奶牛每天可以生产 $c_i$ 加仑牛奶。\n\n接下来的 $M$ 行每行包含两个整数 $q_i$ 和 $p_i$（$1 \\leq q_i, p_i \\leq 1,000,000$），表示第 $i$ 家商店愿意以每加仑 $p_i$ 美分的价格购买最多 $q_i$ 加仑牛奶。**请注意，Farmer John 可以向每家商店出售任意数量的牛奶，范围从 $0$ 到 $q_i$ 加仑。**\n\n接下来的 $R$ 行每行包含一个整数 $r_i$（$1 \\leq r_i \\leq 1,000,000$），表示 Farmer John 的一个邻居愿意以每天 $r_i$ 美分的价格租赁一头奶牛。", "outputFormat": "输出应包含一行，表示 Farmer John 通过产奶或租赁奶牛每天可以获得的最大利润。\n\n请注意，输出可能超过标准 32 位整数的范围，因此可能需要使用更大的整数类型，例如 C/C++ 中的 long long", "hint": "Farmer John 应该让奶牛 #1 和 #4 产奶，每天生产 $13$ 加仑牛奶。他应该完全满足 $10$ 加仑的订单，赚取 $250$ 美分，并以每加仑 $15$ 美分的价格出售剩余的 $3$ 加仑，总共赚取 $295$ 美分的牛奶利润。\n\n然后，他应该将其他三头奶牛分别以 $250$、$80$ 和 $100$ 美分的价格租出，赚取额外的 $430$ 美分。（他应该忽略 $40$ 美分的租赁请求。）这样，他每天的总利润为 $725$ 美分。", "locale": "zh-CN"}}}
{"pid": "P4182", "type": "P", "difficulty": 6, "samples": [["3 2\n1 8\n7 15\n2 14", "12\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2018", "USACO", "单调队列", "枚举", "队列"], "title": "[USACO18JAN] Lifeguards P", "background": "", "description": "Farmer John has opened a swimming pool for his cows, figuring it will help them relax and produce more milk.\n\nTo ensure safety, he hires $N$ cows as lifeguards, each of which has a shift that covers some contiguous interval of time during the day. For simplicity, the pool is open from time $0$ until time $10^9$ on a daily basis, so each shift can be described by two integers, giving the time at which a cow starts and ends her shift. For example, a lifeguard starting at time $t = 4$ and ending at time $t = 7$ covers three units of time (note that the endpoints are \"points\" in time).\n\n\nUnfortunately, Farmer John hired $K$ more lifeguards than he has the funds to support. Given that he must fire exactly $K$ lifeguards, what is the maximum amount of time that can still be covered by the shifts of the remaining lifeguards? An interval of time is covered if at least one lifeguard is present.\n", "inputFormat": "The first line of input contains $N$ and $K$ ($K \\leq N \\leq 100,000, 1 \\leq K \\leq 100$). Each of the next $N$ lines describes a lifeguard in terms of two integers in the range $0 \\ldots 10^9$, giving the starting and ending point of a lifeguard's shift. All such endpoints are distinct. Shifts of different lifeguards might overlap.\n", "outputFormat": "Please write a single number, giving the maximum amount of time that can still be covered if Farmer John fires $K$ lifeguards.\n", "hint": "In this example, FJ should fire the lifeguards covering $1 \\ldots 8$ and $7 \\ldots 15$.\n\n", "locale": "en", "translations": {"en": {"title": "[USACO18JAN] Lifeguards P", "background": "", "description": "Farmer John has opened a swimming pool for his cows, figuring it will help them relax and produce more milk.\n\nTo ensure safety, he hires $N$ cows as lifeguards, each of which has a shift that covers some contiguous interval of time during the day. For simplicity, the pool is open from time $0$ until time $10^9$ on a daily basis, so each shift can be described by two integers, giving the time at which a cow starts and ends her shift. For example, a lifeguard starting at time $t = 4$ and ending at time $t = 7$ covers three units of time (note that the endpoints are \"points\" in time).\n\n\nUnfortunately, Farmer John hired $K$ more lifeguards than he has the funds to support. Given that he must fire exactly $K$ lifeguards, what is the maximum amount of time that can still be covered by the shifts of the remaining lifeguards? An interval of time is covered if at least one lifeguard is present.\n", "inputFormat": "The first line of input contains $N$ and $K$ ($K \\leq N \\leq 100,000, 1 \\leq K \\leq 100$). Each of the next $N$ lines describes a lifeguard in terms of two integers in the range $0 \\ldots 10^9$, giving the starting and ending point of a lifeguard's shift. All such endpoints are distinct. Shifts of different lifeguards might overlap.\n", "outputFormat": "Please write a single number, giving the maximum amount of time that can still be covered if Farmer John fires $K$ lifeguards.\n", "hint": "In this example, FJ should fire the lifeguards covering $1 \\ldots 8$ and $7 \\ldots 15$.\n\n", "locale": "en"}, "zh-CN": {"title": "[USACO18JAN] Lifeguards P", "background": "", "description": "Farmer John 为他的奶牛们开设了一个游泳池，认为这将帮助它们放松并产更多的奶。\n\n为了确保安全，他雇佣了 $N$ 头奶牛作为救生员，每头奶牛的班次覆盖一天中的某个连续时间段。为简单起见，游泳池每天从时间 $0$ 开放到时间 $10^9$，因此每个班次可以用两个整数描述，分别表示奶牛开始和结束其班次的时间。例如，一头救生员从时间 $t = 4$ 开始到时间 $t = 7$ 结束，覆盖了 $3$ 个单位的时间（注意端点表示时间点）。\n\n不幸的是，Farmer John 多雇佣了 $K$ 名救生员，超出了他的资金支持范围。鉴于他必须解雇恰好 $K$ 名救生员，剩下的救生员的班次能够覆盖的最长时间是多少？如果至少有一名救生员在场，则某个时间段被视为被覆盖。", "inputFormat": "输入的第一行包含 $N$ 和 $K$（$K \\leq N \\leq 100,000$，$1 \\leq K \\leq 100$）。接下来的 $N$ 行每行描述一名救生员，用两个范围在 $0 \\ldots 10^9$ 的整数表示该救生员班次的开始和结束时间。所有端点都是唯一的。不同救生员的班次可能会重叠。", "outputFormat": "请输出一个数字，表示如果 Farmer John 解雇 $K$ 名救生员后，剩下的救生员的班次能够覆盖的最长时间。", "hint": "在这个例子中，Farmer John 应该解雇覆盖 $1 \\ldots 8$ 和 $7 \\ldots 15$ 的救生员。", "locale": "zh-CN"}}}
{"pid": "P4183", "type": "P", "difficulty": 6, "samples": [["7\n1 2\n1 3\n3 4\n3 5\n4 6\n5 7", "3\n1\n3\n3\n3\n1\n1"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "USACO", "点分治", "分治"], "title": "[USACO18JAN] Cow at Large P", "background": "", "description": "Cornered at last, Bessie has gone to ground in a remote farm. The farm consists of $N$ barns ($2 \\leq N \\leq 7 \\cdot 10^4$) and $N-1$ bidirectional tunnels between barns, so that there is a unique path between every pair of barns. Every barn which has only one tunnel is an exit. When morning comes, Bessie will surface at some barn and attempt to reach an exit.\n\nBut the moment Bessie surfaces at some barn, the law will be able to pinpoint her location. Some farmers will then start at various exit barns, and attempt to catch Bessie. The farmers move at the same speed as Bessie (so in each time step, each farmer can move from one barn to an adjacent barn). The farmers know where Bessie is at all times, and Bessie knows where the farmers are at all times. The farmers catch Bessie if at any instant a farmer is in the same barn as Bessie, or crossing the same tunnel as Bessie. Conversely, Bessie escapes if she reaches an exit barn strictly before any farmers catch her.\n\n\nBessie is unsure at which barn she should surface. For each of the $N$ barns, help Bessie determine the minimum number of farmers who would be needed to catch Bessie if she surfaced there, assuming that the farmers distribute themselves optimally among the exit barns.\n\n\nNote that the time limit for this problem is slightly larger than the default: 4 seconds for C/C++/Pascal, and 8 seconds for Java/Python.\n", "inputFormat": "The first line of the input contains $N$. Each of the following $N-1$ lines specify two integers, each in the range $1 \\ldots N$, describing a tunnel between two barns.\n", "outputFormat": "Please output $N$ lines, where the $i$th line of output tells the minimum number of farmers necessary to catch Bessie if she surfaced at the $i$th barn.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO18JAN] Cow at Large P", "background": "", "description": "Cornered at last, Bessie has gone to ground in a remote farm. The farm consists of $N$ barns ($2 \\leq N \\leq 7 \\cdot 10^4$) and $N-1$ bidirectional tunnels between barns, so that there is a unique path between every pair of barns. Every barn which has only one tunnel is an exit. When morning comes, Bessie will surface at some barn and attempt to reach an exit.\n\nBut the moment Bessie surfaces at some barn, the law will be able to pinpoint her location. Some farmers will then start at various exit barns, and attempt to catch Bessie. The farmers move at the same speed as Bessie (so in each time step, each farmer can move from one barn to an adjacent barn). The farmers know where Bessie is at all times, and Bessie knows where the farmers are at all times. The farmers catch Bessie if at any instant a farmer is in the same barn as Bessie, or crossing the same tunnel as Bessie. Conversely, Bessie escapes if she reaches an exit barn strictly before any farmers catch her.\n\n\nBessie is unsure at which barn she should surface. For each of the $N$ barns, help Bessie determine the minimum number of farmers who would be needed to catch Bessie if she surfaced there, assuming that the farmers distribute themselves optimally among the exit barns.\n\n\nNote that the time limit for this problem is slightly larger than the default: 4 seconds for C/C++/Pascal, and 8 seconds for Java/Python.\n", "inputFormat": "The first line of the input contains $N$. Each of the following $N-1$ lines specify two integers, each in the range $1 \\ldots N$, describing a tunnel between two barns.\n", "outputFormat": "Please output $N$ lines, where the $i$th line of output tells the minimum number of farmers necessary to catch Bessie if she surfaced at the $i$th barn.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO18JAN] Cow at Large P", "background": "", "description": "Bessie 被逼到了绝境，躲进了一个偏远的农场。这个农场由 $N$ 个谷仓（$2 \\leq N \\leq 7 \\cdot 10^4$）和 $N-1$ 条双向隧道组成，因此每对谷仓之间都有一条唯一的路径。每个只有一个隧道的谷仓都是一个出口。当早晨来临时，Bessie 会从某个谷仓出现，并试图到达一个出口。\n\n但是，当 Bessie 从某个谷仓出现时，执法人员会立即定位到她的位置。一些农民会从各个出口谷仓出发，试图抓住 Bessie。农民和 Bessie 的移动速度相同（因此在每个时间步中，每个农民可以从一个谷仓移动到相邻的谷仓）。农民们始终知道 Bessie 的位置，而 Bessie 也始终知道农民们的位置。如果农民和 Bessie 在同一谷仓或同时穿过同一条隧道，农民就会抓住 Bessie。相反，如果 Bessie 在农民抓住她之前严格地到达一个出口谷仓，她就能逃脱。\n\nBessie 不确定她应该从哪个谷仓出现。对于每个谷仓，请帮助 Bessie 确定如果她从该谷仓出现，假设农民们最优地分布在出口谷仓中，抓住她所需的最少农民数量。\n\n请注意，本题的时间限制略高于默认值：C/C++/Pascal 为 4 秒，Java/Python 为 8 秒。", "inputFormat": "输入的第一行包含 $N$。接下来的 $N-1$ 行每行包含两个整数，范围在 $1 \\ldots N$ 之间，描述一条连接两个谷仓的隧道。", "outputFormat": "请输出 $N$ 行，其中第 $i$ 行表示如果 Bessie 从第 $i$ 个谷仓出现，抓住她所需的最少农民数量。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4184", "type": "P", "difficulty": 6, "samples": [["5\n0 4\n1 1\n2 2\n3 0\n4 3", "21"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "线段树", "USACO", "前缀和"], "title": "[USACO18JAN] Sprinklers P", "background": "", "description": "Farmer John has a large field, and he is thinking of planting sweet corn in some part of it. After surveying his field, FJ found that it forms an $(N-1) \\times (N-1)$ square. The southwest corner is at coordinates $(0,0)$, and the northeast corner is at $(N-1,N-1)$.\n\nAt some integer coordinates there are double-headed sprinklers, each one sprinkling both water and fertilizer. A double-heading sprinkler at coordinates $(i,j)$ sprinkles water on the part of the field north and east of it, and sprinkles fertilizer on the part of the field south and west of it. Formally, it waters all real coordinates $(x,y)$ for which $N \\geq x \\geq i$ and $N \\geq y \\geq j$, and it fertilizes all real coordinates $(x,y)$ for which $0 \\leq x \\leq i$ and $0 \\leq y \\leq j$.\n\n\nFarmer John wants to plant sweet corn in some axis-aligned rectangle in his field with integer-valued corner coordinates. However, for the sweet corn to grow, all points in the rectangle must be both watered and fertilized by the double-headed sprinklers. And of course the rectangle must have positive area, or Farmer John wouldn't be able to grow any corn in it!\n\n\nHelp Farmer John determine the number of rectangles of positive area in which he could grow sweet corn. Since this number may be large, output the remainder of this number modulo $10^9 + 7$.\n", "inputFormat": "The first line of the input consists of a single integer $N$, the size of the field ($1 \\leq N \\leq 10^5$).\n\nThe next $N$ lines each contain two space-separated integers. If these integers are $i$ and $j$, where $0 \\leq i,j \\leq N-1$, they denote a sprinkler located at $(i,j)$.\n\n\nIt is guaranteed that there is exactly one sprinkler in each column and exactly one sprinkler in each row. That is, no two sprinklers have the same $x$-coordinate, and no two sprinklers have the same $y$-coordinate.\n", "outputFormat": "The output should consist of a single integer: the number of rectangles of positive area which are fully watered and fully fertilized, modulo $10^9 + 7$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO18JAN] Sprinklers P", "background": "", "description": "Farmer John has a large field, and he is thinking of planting sweet corn in some part of it. After surveying his field, FJ found that it forms an $(N-1) \\times (N-1)$ square. The southwest corner is at coordinates $(0,0)$, and the northeast corner is at $(N-1,N-1)$.\n\nAt some integer coordinates there are double-headed sprinklers, each one sprinkling both water and fertilizer. A double-heading sprinkler at coordinates $(i,j)$ sprinkles water on the part of the field north and east of it, and sprinkles fertilizer on the part of the field south and west of it. Formally, it waters all real coordinates $(x,y)$ for which $N \\geq x \\geq i$ and $N \\geq y \\geq j$, and it fertilizes all real coordinates $(x,y)$ for which $0 \\leq x \\leq i$ and $0 \\leq y \\leq j$.\n\n\nFarmer John wants to plant sweet corn in some axis-aligned rectangle in his field with integer-valued corner coordinates. However, for the sweet corn to grow, all points in the rectangle must be both watered and fertilized by the double-headed sprinklers. And of course the rectangle must have positive area, or Farmer John wouldn't be able to grow any corn in it!\n\n\nHelp Farmer John determine the number of rectangles of positive area in which he could grow sweet corn. Since this number may be large, output the remainder of this number modulo $10^9 + 7$.\n", "inputFormat": "The first line of the input consists of a single integer $N$, the size of the field ($1 \\leq N \\leq 10^5$).\n\nThe next $N$ lines each contain two space-separated integers. If these integers are $i$ and $j$, where $0 \\leq i,j \\leq N-1$, they denote a sprinkler located at $(i,j)$.\n\n\nIt is guaranteed that there is exactly one sprinkler in each column and exactly one sprinkler in each row. That is, no two sprinklers have the same $x$-coordinate, and no two sprinklers have the same $y$-coordinate.\n", "outputFormat": "The output should consist of a single integer: the number of rectangles of positive area which are fully watered and fully fertilized, modulo $10^9 + 7$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO18JAN] Sprinklers P", "background": null, "description": "农夫约翰有块田，这块田可视为一个 $N\\times N$ 的正方形网格。西南角为 $(0,0)$，东北角为 $(N-1, N-1)$。  \n在某些坐标点上有双头喷头，每一个都能够同时喷洒水和肥料。一个位于 $(i,j)$ 的双头喷头会\n* 将水洒在所有满足 $N\\ge x\\ge i$，$N\\ge y\\ge j$ 的坐标 $(x,y)$ 上；\n* 将肥料洒在所有满足 $0\\le x\\le i$，$0\\le y\\le j$ 的坐标 $(x,y)$ 上。\n\n农民约翰想在这块田里切割出一个矩形种甜玉米。矩形的顶点坐标需为整数。矩形内的所有点都必须能由双头喷头灌溉和施肥。  \n求切割矩形的方案数。由于这个数字可能很大，所以输出对 $10^9+7$ 取模。", "inputFormat": "第一行包含一个整数 $N$，表示农场的大小。  \n接下来的 $N$ 行，每行有两个由空格分隔的整数 $i, j$。这表示有一个双头喷头位于 $(i, j)$。  \n保证每列都有一台喷头，每排正好有一台喷头。换句话说，没有两个喷头有相同的横坐标或纵坐标。", "outputFormat": "输出包含一行，表示方案数，对 $10^9+7$ 取模。", "hint": "$1\\le N\\le 10^5$", "locale": "zh-CN"}}}
{"pid": "P4185", "type": "P", "difficulty": 4, "samples": [["4 3\n1 2 3\n2 3 2\n2 4 4\n1 2\n4 1\n3 1", "3\n0\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "USACO", "并查集", "连通块"], "title": "[USACO18JAN] MooTube G", "background": "*本题与 [银组同名题目](/problem/P6111) 在题意上一致，唯一的差别是数据范围。*", "description": "在业余时间，Farmer John 创建了一个新的视频共享服务，他将其命名为 MooTube。在 MooTube 上，Farmer John 的奶牛可以录制，分享和发现许多有趣的视频。他的奶牛已经发布了 $N$ 个视频（$1 \\leq N \\leq 10^5$），为了方便将其编号为  $1 \\ldots N$。然而，FJ 无法弄清楚如何帮助他的奶牛找到他们可能喜欢的新视频。\n\nFJ 希望为每个 MooTube 视频创建一个“推荐视频”列表。这样，奶牛将被推荐与他们已经观看过的视频最相关的视频。\n\nFJ 设计了一个“相关性”度量标准，顾名思义，它确定了两个视频相互之间的相关值。FJ 将他的视频建成一棵树（其中每个节点代表一条视频），并且计算了所有 $N-1$ 对相邻视频的相关值。这样任意视频都可以通过一条连通路径到达任意其他视频。FJ 决定将任意一对视频的相关值定义为沿此路径的任何连接的最小相关值。\n\nFarmer John 想要选择一个 $K$ 值，以便在任何给定的 MooTube 视频旁边，推荐所有其他与该视频相关值至少为 $K$ 的视频。然而，FJ 担心会向他的奶牛推荐太多的视频，这可能会分散他们对产奶的注意力！因此，他想设定适当的 $K$ 值。Farmer John 希望得到您的帮助，回答有关 $K$ 值的推荐视频的一些问题。", "inputFormat": "第一行输入包含 $N$ 和 $Q$（$1 \\leq Q \\leq 10^5$）。\n\n接下来的 $N-1$ 行描述了 FJ 手动比较的一对视频。 每行包括三个整数 $p_i$，$q_i$ 和 $r_i$（$1 \\leq p_i, q_i \\leq N$，$1 \\leq r_i \\leq 10^9$），表示视频 $p_i$ 和 $q_i$ 已连接并且相关值为 $r_i$。\n\n接下来的 $Q$ 行描述了 Farmer John 的 $Q$ 个问题。每行包含两个整数，$k_i$ 和 $v_i$（$1 \\leq k_i \\leq 10^9$，$1 \\leq v_i \\leq N$），表示 FJ 的第 $i$ 个问题询问中当 $K = k_i$ 时，第 $v_i$ 个视频推荐列表中将推荐的视频数。", "outputFormat": "输出 $Q$ 行。在第 $i$ 行，输出 FJ 的第 $i$ 个问题的答案。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[USACO18JAN] MooTube G", "background": "This problem has the same statement as the [Silver version](/problem/P6111); the only difference is the constraints.", "description": "In his spare time, Farmer John created a new video sharing service, which he named MooTube. On MooTube, Farmer John’s cows can record, share, and discover many interesting videos. His cows have posted $N$ videos ($1 \\leq N \\leq 10^5$), conveniently numbered $1 \\ldots N$. However, FJ cannot figure out how to help his cows find new videos they might like.\n\nFJ wants to create a “recommended videos” list for each MooTube video. This way, cows will be recommended videos that are most related to the videos they have already watched.\n\nFJ designed a “relevance” metric that, as the name suggests, measures how related two videos are. FJ models his videos as a tree (where each node represents a video) and computes the relevance for all $N-1$ pairs of adjacent videos. In this way, any video can reach any other video via a connected path. FJ defines the relevance of any pair of videos as the minimum relevance along the edges on the path between them.\n\nFarmer John wants to choose a value $K$ so that, next to any given MooTube video, he will recommend all other videos whose relevance to that video is at least $K$. However, FJ worries about recommending too many videos, which might distract the cows from producing milk. Therefore, he wants to set an appropriate value of $K$. Farmer John needs your help to answer some questions about the recommended videos for given $K$ values.", "inputFormat": "The first line contains $N$ and $Q$ ($1 \\leq Q \\leq 10^5$).\n\nEach of the next $N-1$ lines describes a pair of videos that FJ compared manually. Each line contains three integers $p_i$, $q_i$, and $r_i$ ($1 \\leq p_i, q_i \\leq N$, $1 \\leq r_i \\leq 10^9$), indicating that videos $p_i$ and $q_i$ are connected and have relevance $r_i$.\n\nEach of the next $Q$ lines describes one of Farmer John’s $Q$ queries. Each line contains two integers, $k_i$ and $v_i$ ($1 \\leq k_i \\leq 10^9$, $1 \\leq v_i \\leq N$), meaning that in FJ’s $i$-th query, when $K = k_i$, you should report how many videos would be recommended in the list for video $v_i$.", "outputFormat": "Output $Q$ lines. On the $i$-th line, output the answer to FJ’s $i$-th query.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18JAN] MooTube G", "background": "*本题与 [银组同名题目](/problem/P6111) 在题意上一致，唯一的差别是数据范围。*", "description": "在业余时间，Farmer John 创建了一个新的视频共享服务，他将其命名为 MooTube。在 MooTube 上，Farmer John 的奶牛可以录制，分享和发现许多有趣的视频。他的奶牛已经发布了 $N$ 个视频（$1 \\leq N \\leq 10^5$），为了方便将其编号为  $1 \\ldots N$。然而，FJ 无法弄清楚如何帮助他的奶牛找到他们可能喜欢的新视频。\n\nFJ 希望为每个 MooTube 视频创建一个“推荐视频”列表。这样，奶牛将被推荐与他们已经观看过的视频最相关的视频。\n\nFJ 设计了一个“相关性”度量标准，顾名思义，它确定了两个视频相互之间的相关值。FJ 将他的视频建成一棵树（其中每个节点代表一条视频），并且计算了所有 $N-1$ 对相邻视频的相关值。这样任意视频都可以通过一条连通路径到达任意其他视频。FJ 决定将任意一对视频的相关值定义为沿此路径的任何连接的最小相关值。\n\nFarmer John 想要选择一个 $K$ 值，以便在任何给定的 MooTube 视频旁边，推荐所有其他与该视频相关值至少为 $K$ 的视频。然而，FJ 担心会向他的奶牛推荐太多的视频，这可能会分散他们对产奶的注意力！因此，他想设定适当的 $K$ 值。Farmer John 希望得到您的帮助，回答有关 $K$ 值的推荐视频的一些问题。", "inputFormat": "第一行输入包含 $N$ 和 $Q$（$1 \\leq Q \\leq 10^5$）。\n\n接下来的 $N-1$ 行描述了 FJ 手动比较的一对视频。 每行包括三个整数 $p_i$，$q_i$ 和 $r_i$（$1 \\leq p_i, q_i \\leq N$，$1 \\leq r_i \\leq 10^9$），表示视频 $p_i$ 和 $q_i$ 已连接并且相关值为 $r_i$。\n\n接下来的 $Q$ 行描述了 Farmer John 的 $Q$ 个问题。每行包含两个整数，$k_i$ 和 $v_i$（$1 \\leq k_i \\leq 10^9$，$1 \\leq v_i \\leq N$），表示 FJ 的第 $i$ 个问题询问中当 $K = k_i$ 时，第 $v_i$ 个视频推荐列表中将推荐的视频数。", "outputFormat": "输出 $Q$ 行。在第 $i$ 行，输出 FJ 的第 $i$ 个问题的答案。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P4186", "type": "P", "difficulty": 5, "samples": [["7 1\n1 2\n1 3\n3 4\n3 5\n4 6\n5 7", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "USACO", "深度优先搜索 DFS"], "title": "[USACO18JAN] Cow at Large G", "background": "", "description": "Cornered at last, Bessie has gone to ground in a remote farm. The farm consists of $N$ barns ($2 \\leq N \\leq 10^5$) and $N-1$ bidirectional tunnels between barns, so that there is a unique path between every pair of barns. Every barn which has only one tunnel is an exit. When morning comes, Bessie will surface at some barn and attempt to reach an exit.\n\nBut the moment Bessie surfaces, the law will be able to pinpoint her location. Some farmers will then start at various exit barns, and attempt to catch Bessie. The farmers move at the same speed as Bessie (so in each time step, each farmer can move from one barn to an adjacent barn). The farmers know where Bessie is at all times, and Bessie knows where the farmers are at all times. The farmers catch Bessie if at any instant a farmer is in the same barn as Bessie, or crossing the same tunnel as Bessie. Conversely, Bessie escapes if she reaches an exit barn before any farms catch her.\n\n\nBessie is unsure about her chances of success, which depends on the number of farmers that the law is able to deploy. Given that Bessie surfaces at barn $K$, help Bessie determine the minimum number of farmers who would be needed to catch Bessie, assuming that the farmers distribute themselves optimally among the exit barns.\n", "inputFormat": "The first line of the input contains $N$ and $K$. Each of the following $N-1$ lines specify two integers, each in the range $1 \\ldots N$, describing a tunnel between two barns.\n", "outputFormat": "Please output the minimum number of farmers needed to ensure catching Bessie.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO18JAN] Cow at Large G", "background": "", "description": "Cornered at last, Bessie has gone to ground in a remote farm. The farm consists of $N$ barns ($2 \\leq N \\leq 10^5$) and $N-1$ bidirectional tunnels between barns, so that there is a unique path between every pair of barns. Every barn which has only one tunnel is an exit. When morning comes, Bessie will surface at some barn and attempt to reach an exit.\n\nBut the moment Bessie surfaces, the law will be able to pinpoint her location. Some farmers will then start at various exit barns, and attempt to catch Bessie. The farmers move at the same speed as Bessie (so in each time step, each farmer can move from one barn to an adjacent barn). The farmers know where Bessie is at all times, and Bessie knows where the farmers are at all times. The farmers catch Bessie if at any instant a farmer is in the same barn as Bessie, or crossing the same tunnel as Bessie. Conversely, Bessie escapes if she reaches an exit barn before any farms catch her.\n\n\nBessie is unsure about her chances of success, which depends on the number of farmers that the law is able to deploy. Given that Bessie surfaces at barn $K$, help Bessie determine the minimum number of farmers who would be needed to catch Bessie, assuming that the farmers distribute themselves optimally among the exit barns.\n", "inputFormat": "The first line of the input contains $N$ and $K$. Each of the following $N-1$ lines specify two integers, each in the range $1 \\ldots N$, describing a tunnel between two barns.\n", "outputFormat": "Please output the minimum number of farmers needed to ensure catching Bessie.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO18JAN] Cow at Large G", "background": "", "description": "最后，Bessie 被迫去了一个远方的农场。这个农场包含 $N$ 个谷仓（$2 \\le N \\le 10^5$）和 $N-1$ 条连接两个谷仓的双向隧道，所以每两个谷仓之间都有唯一的路径。每个只与一条隧道相连的谷仓都是农场的出口。当早晨来临的时候，Bessie 将在某个谷仓露面，然后试图到达一个出口。\n\n但当 Bessie 露面的时候，她的位置就会暴露。一些农民在那时将从不同的出口谷仓出发尝试抓住 Bessie。农民和 Bessie 的移动速度相同（在每个单位时间内，每个农民都可以从一个谷仓移动到相邻的一个谷仓，同时 Bessie 也可以这么做）。农民们和 Bessie 总是知道对方在哪里。如果在任意时刻，某个农民和 Bessie 处于同一个谷仓或在穿过同一个隧道，农民就可以抓住 Bessie。反过来，如果 Bessie 在农民们抓住她之前到达一个出口谷仓，Bessie 就可以逃走。\n\nBessie 不确定她成功的机会，这取决于被雇佣的农民的数量。给定 Bessie 露面的谷仓K，帮助 Bessie 确定为了抓住她所需要的农民的最小数量。假定农民们会自己选择最佳的方案来安排他们出发的出口谷仓。", "inputFormat": "输入的第一行包含 $N$ 和 $K$。接下来的 $N - 1$ 行，每行有两个整数（在 $1\\sim N$ 范围内）描述连接两个谷仓的一条隧道。", "outputFormat": "输出为了确保抓住 Bessie 所需的农民的最小数量。\n\n由 @Marser 提供翻译", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4187", "type": "P", "difficulty": 5, "samples": [["3 2 2", "6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "数学", "2018", "USACO", "排列组合"], "title": "[USACO18JAN] Stamp Painting G", "background": "", "description": "Bessie has found herself in possession of an $N$-unit long strip of canvas ($1 \\leq N \\leq 10^6$), and she intends to paint it. However, she has been unable to acquire paint brushes. In their place she has $M$ rubber stamps of different colors ($1 \\leq M \\leq 10^6$), each stamp $K$ units wide ($1 \\leq K \\leq 10^6$). Astounded by the possibilities that lie before her, she wishes to know exactly how many different paintings she could conceivably create, by stamping her stamps in some order on the canvas.\n\nTo use a stamp, it must first be aligned with exactly $K$ neighboring units on the canvas. The stamp cannot extend beyond the ends of the canvas, nor can it cover fractions of units. Once placed, the stamp paints the $K$ covered units with its color. Any given stamp may be used multiple times, once, or even never at all. But by the time Bessie is finished, every unit of canvas must have been painted at least once.\n\n\nHelp Bessie find the number of different paintings that she could paint, modulo $10^9 + 7$. Two paintings that look identical but were painted by different sequences of stamping operations are counted as the same.\n\n\nFor at least 75% of the input cases, $N,K \\leq 10^3$.\n", "inputFormat": "The first and only line of input has three integers, $N$, $M$, and $K$. It is guaranteed that $K \\leq N$.\n", "outputFormat": "A single integer: the number of possible paintings, modulo $10^9 + 7$.\n", "hint": "If the two stamps have colors A and B, the possible paintings are AAA, AAB, ABB, BAA, BBA, and BBB.\n", "locale": "en", "translations": {"en": {"title": "[USACO18JAN] Stamp Painting G", "background": "", "description": "Bessie has found herself in possession of an $N$-unit long strip of canvas ($1 \\leq N \\leq 10^6$), and she intends to paint it. However, she has been unable to acquire paint brushes. In their place she has $M$ rubber stamps of different colors ($1 \\leq M \\leq 10^6$), each stamp $K$ units wide ($1 \\leq K \\leq 10^6$). Astounded by the possibilities that lie before her, she wishes to know exactly how many different paintings she could conceivably create, by stamping her stamps in some order on the canvas.\n\nTo use a stamp, it must first be aligned with exactly $K$ neighboring units on the canvas. The stamp cannot extend beyond the ends of the canvas, nor can it cover fractions of units. Once placed, the stamp paints the $K$ covered units with its color. Any given stamp may be used multiple times, once, or even never at all. But by the time Bessie is finished, every unit of canvas must have been painted at least once.\n\n\nHelp Bessie find the number of different paintings that she could paint, modulo $10^9 + 7$. Two paintings that look identical but were painted by different sequences of stamping operations are counted as the same.\n\n\nFor at least 75% of the input cases, $N,K \\leq 10^3$.\n", "inputFormat": "The first and only line of input has three integers, $N$, $M$, and $K$. It is guaranteed that $K \\leq N$.\n", "outputFormat": "A single integer: the number of possible paintings, modulo $10^9 + 7$.\n", "hint": "If the two stamps have colors A and B, the possible paintings are AAA, AAB, ABB, BAA, BBA, and BBB.\n", "locale": "en"}, "zh-CN": {"title": "[USACO18JAN] Stamp Painting G", "background": null, "description": "Bessie 想拿 $M$ 种颜色的长为 $K$ 的图章涂一个长为 $N$ 的迷之画布。假设他选择涂一段区间，则这段区间长度必须为$K$，且涂完后该区间颜色全变成图章颜色。他可以随便涂，但是最后必须把画布画满。问能有多少种最终状态。$N\\leq 10^6,M\\leq 10^6,K\\leq 10^6$ 。\n\n对于 $75\\%$ 的数据，$N,K\\leq 10^3$。", "inputFormat": "一行三个整数 $N,M,K$。", "outputFormat": "一个整数表示答案（对 $10^9+7$ 取模）", "hint": "输入输出样例说明\n\n如果两个图章叫 A,B，合法方案如下:AAB,ABB,BAA,BBA,AAA,BBB。\n\nTranslated by @ComeIntoPower", "locale": "zh-CN"}}}
{"pid": "P4188", "type": "P", "difficulty": 5, "samples": [["3\n5 9\n1 4\n3 7", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "线段树", "USACO", "离散化", "枚举"], "title": "[USACO18JAN] Lifeguards S", "background": "", "description": "Farmer John has opened a swimming pool for his cows, figuring it will help them relax and produce more milk.\n\nTo ensure safety, he hires $N$ cows as lifeguards, each of which has a shift that covers some contiguous interval of time during the day. For simplicity, the pool is open from time $t=0$ until time $t = 1,000,000,000$ on a daily basis, so each shift can be described by two integers, giving the time at which a cow starts and ends her shift. For example, a lifeguard starting at time $t = 4$ and ending at time $t = 7$ covers three units of time (note that the endpoints are \"points\" in time).\n\n\nUnfortunately, Farmer John hired 1 more lifeguard than he has the funds to support. Given that he must fire exactly one lifeguard, what is the maximum amount of time that can still be covered by the shifts of the remaining lifeguards? An interval of time is covered if at least one lifeguard is present.\n", "inputFormat": "The first line of input contains $N$ ($1 \\leq N \\leq 100,000$). Each of the next $N$ lines describes a lifeguard in terms of two integers in the range $0 \\ldots 1,000,000,000$, giving the starting and ending point of a lifeguard's shift. All such endpoints are distinct. Shifts of different lifeguards might overlap.\n", "outputFormat": "Please write a single number, giving the maximum amount of time that can still be covered if Farmer John fires 1 lifeguard.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO18JAN] Lifeguards S", "background": "", "description": "Farmer John has opened a swimming pool for his cows, figuring it will help them relax and produce more milk.\n\nTo ensure safety, he hires $N$ cows as lifeguards, each of which has a shift that covers some contiguous interval of time during the day. For simplicity, the pool is open from time $t=0$ until time $t = 1,000,000,000$ on a daily basis, so each shift can be described by two integers, giving the time at which a cow starts and ends her shift. For example, a lifeguard starting at time $t = 4$ and ending at time $t = 7$ covers three units of time (note that the endpoints are \"points\" in time).\n\n\nUnfortunately, Farmer John hired 1 more lifeguard than he has the funds to support. Given that he must fire exactly one lifeguard, what is the maximum amount of time that can still be covered by the shifts of the remaining lifeguards? An interval of time is covered if at least one lifeguard is present.\n", "inputFormat": "The first line of input contains $N$ ($1 \\leq N \\leq 100,000$). Each of the next $N$ lines describes a lifeguard in terms of two integers in the range $0 \\ldots 1,000,000,000$, giving the starting and ending point of a lifeguard's shift. All such endpoints are distinct. Shifts of different lifeguards might overlap.\n", "outputFormat": "Please write a single number, giving the maximum amount of time that can still be covered if Farmer John fires 1 lifeguard.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO18JAN] Lifeguards S", "background": "", "description": "FJ 为他的奶牛们建造了一个游泳池，FJ 认为这将有助于他们放松身心以及生产更多牛奶。\n\n为了确保奶牛们的安全，FJ 雇佣了 $N$ 头牛，作为泳池的救生员，每一个救生员在一天内都会有一定的事情，并且这些事情都会覆盖一天内的一段时间。为了简单起见，泳池从时间 $t=0$ 时开门，直到时间 $t=10^9$ 关门，所以每个事情都可以用两个整数来描述，给出奶牛救生员开始以及结束事情的时间。例如，一个救生员在时间 $t=4$ 时开始事情并且在时间 $t=7$ 时结束事情，那么这件事情就覆盖了 $3$ 个单位时间。（注意：结束时间是“点”的时间）\n\n不幸的是，FJ 多雇佣了一名的救生员，但他没有足够的资金来雇佣这些救生员。因此他必须解雇一名救生员，求可以覆盖剩余救生员的轮班时间的最大总量是多少？如果当时至少有一名救生员的事情已经开始，则这个时段被覆盖。", "inputFormat": "输入的第一行包括一个整数 $N\\ ( 1 \\le N \\le 100000)$。接下来 $N$ 行中，每行告诉了我们一个救生员在 $0 \\sim 10^9$ 范围内的开始以及结束时间。所有的结束时间都是不同的。不同的救生员的事情覆盖的时间可能会重叠。", "outputFormat": "输出一行一个整数，如果 FJ 解雇一名救生员仍能覆盖的最大时间。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4189", "type": "P", "difficulty": 7, "samples": [["3\n2 6 2\n0 1\n1 2\n", "8\n7\n8\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2010", "CTSC/CTS"], "title": "[CTSC2010] 星际旅行", "background": "", "description": "公元$3000$年，地球联盟已经攻占了银河系内的$N$个星球，出于资金的考虑，政府仅仅在星球间建立了$N-1$条双向时空隧道保证任意两个星球之间互相可达。出于管理上的考虑，第$i$个星球的行政长官要求每个公民在一年内不得从该星球利用时空隧道次数超过$H_i$次（这一统计是基于离开次数统计的，如果你已经使用从该星球离开过$H_i$次，那么这一年内你就不能再使用时空隧道离开这个星球了）。Louis Paosen是一个星际旅行家，他希望能使用尽量多次的时空隧道，但又不希望最终被迫定居的星球条件太过恶劣。所以他希望能知道对于每个星球$i$，若从$0$号星球出发，最终以$i$号星球为终点，这样的星际旅行途中最多可以使用多少次时空隧道。\n", "inputFormat": "输入文件galaxy.in的第一行包含一个整数$N$。接下来的一行包含$N$个整数$H_i$，分别表示每个星球的离开次数限制。接下来$N-1$行每行两个整数，表示这两个星球之间有时空隧道连接。星球的编号从$0$开始，Louis Paosen一开始在$0$号星球。\n", "outputFormat": "输出文件为galaxy.out。文件包含$N$行，每行一个整数，表示如果最终旅行结束在这个星球，最多可以使用时空隧道的次数。\n", "hint": "$40 \\%$的数据$N \\leq 500$\n\n$100 \\%$的数据中$N \\leq 50000$。\n\n所有星球的离开次数限制满足$1 \\leq H_i \\leq 40000$，且每个星球的$H_i$大于等于与该星球直接相连的星球数（即度数）。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2010] Interstellar Travel", "background": "", "description": "In the year $3000$, the Earth Union has conquered $N$ planets in the Milky Way. For budget reasons, the government built only $N-1$ bidirectional spacetime tunnels between planets to ensure that any two planets are mutually reachable. For administrative reasons, the governor of the $i$-th planet requires that each citizen must not use spacetime tunnels to leave that planet more than $H_i$ times within a year (this is counted by the number of departures; if you have already departed from that planet $H_i$ times, then you cannot leave that planet via a spacetime tunnel again within the same year).\n\nLouis Paosen is an interstellar traveler. He hopes to use spacetime tunnels as many times as possible, but he does not want to end up settling on a planet with overly harsh conditions. Therefore, he wants to know, for each planet $i$, if he starts from planet $0$ and finally ends his trip on planet $i$, what is the maximum number of spacetime tunnel uses possible along the journey.", "inputFormat": "The input file galaxy.in contains an integer $N$ on the first line.  \nThe second line contains $N$ integers $H_i$, representing the departure limit for each planet.  \nEach of the next $N-1$ lines contains two integers, indicating that there is a spacetime tunnel between these two planets.  \nPlanets are numbered from $0$, and Louis Paosen starts on planet $0$.", "outputFormat": "The output file is galaxy.out. It contains $N$ lines, each with one integer, where the integer on line $i$ is the maximum possible number of spacetime tunnel uses if the trip ends on planet $i$.", "hint": "For $40\\%$ of the testdata, $N \\leq 500$.  \n\nFor $100\\%$ of the testdata, $N \\leq 50000$.  \n\nAll departure limits satisfy $1 \\leq H_i \\leq 40000$, and each planet’s $H_i$ is greater than or equal to the number of planets directly connected to it (i.e., its degree).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2010] 星际旅行", "background": "", "description": "公元$3000$年，地球联盟已经攻占了银河系内的$N$个星球，出于资金的考虑，政府仅仅在星球间建立了$N-1$条双向时空隧道保证任意两个星球之间互相可达。出于管理上的考虑，第$i$个星球的行政长官要求每个公民在一年内不得从该星球利用时空隧道次数超过$H_i$次（这一统计是基于离开次数统计的，如果你已经使用从该星球离开过$H_i$次，那么这一年内你就不能再使用时空隧道离开这个星球了）。Louis Paosen是一个星际旅行家，他希望能使用尽量多次的时空隧道，但又不希望最终被迫定居的星球条件太过恶劣。所以他希望能知道对于每个星球$i$，若从$0$号星球出发，最终以$i$号星球为终点，这样的星际旅行途中最多可以使用多少次时空隧道。\n", "inputFormat": "输入文件galaxy.in的第一行包含一个整数$N$。接下来的一行包含$N$个整数$H_i$，分别表示每个星球的离开次数限制。接下来$N-1$行每行两个整数，表示这两个星球之间有时空隧道连接。星球的编号从$0$开始，Louis Paosen一开始在$0$号星球。\n", "outputFormat": "输出文件为galaxy.out。文件包含$N$行，每行一个整数，表示如果最终旅行结束在这个星球，最多可以使用时空隧道的次数。\n", "hint": "$40 \\%$的数据$N \\leq 500$\n\n$100 \\%$的数据中$N \\leq 50000$。\n\n所有星球的离开次数限制满足$1 \\leq H_i \\leq 40000$，且每个星球的$H_i$大于等于与该星球直接相连的星球数（即度数）。\n", "locale": "zh-CN"}}}
{"pid": "P4190", "type": "P", "difficulty": 5, "samples": [["3\n1.0 0.0 0.5\n0.5 1.0 1.0\n0.5 0.5 0.5\n\n0.5 0.5 1.0\n0.5 0.0 0.5\n0.5 0.5 0.5\n\n0.5 0.0 1.0\n0.5 0.5 0.5\n0.5 0.5 0.5 \n", "0.273438"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2010", "CTSC/CTS"], "title": "[CTSC2010] 三国围棋擂台赛", "background": "", "description": "一年一度的“农心杯”三国围棋擂台赛是世界上最高水平的围棋比赛，也是中日韩三国围棋界最激动人心的较量。本题就是建立在这一比赛的规则之上。\n\n三国围棋擂台赛是三个国家的代表队之间的比赛，下面简要介绍一下比赛的规则：\n\n1. 不妨设三个国家分别为 $A$、$B$ 和 $C$，每个国家各有$n$名选手（在上述的实际比赛中$n = 5$），分别称其为$A_1$，$A_2$，…，$A_n$，$B_1$，$B_2$，…，$B_n$，$C_1$，$C_2$，…，$C_n$。\n\n2. 每场比赛都能分出胜负。每场比赛的负者遭到淘汰。\n\n3. 每队第一位出场的选手都已经确定为每队的第$n$位选手，即 $A_n$、$B_n$ 和 $C_n$。\n\n4. 通过抽签等概率地选出一支队伍。该队将在第一轮中轮空，而剩下的两支队伍的第 $n$ 位选手将进行第一场比赛。\n\n5. 第一场比赛的胜者（这里的胜者是指赢得该局比赛的选手，下同）与轮空队伍的第 $n$ 位选手进行第二场比赛。比如在第一场比赛中 $C_n$ 战胜了 $A_n$，则第二场则由$C_n$对阵$B_n$。\n\n6. 从第三场比赛开始，前一场比赛未参加的队伍将选出一个未被淘汰的选手与上一场比赛的胜者进行下一场比赛。\n\n7. 这个过程将一直进行，直到某个队伍的全部参赛选手都被淘汰为止。\n\n8. 当只有两支队伍的时候，每场比赛后，由负方选择一位未被淘汰的选手与胜者进行下一场比赛。\n\n9. 当两支队伍中的任意一队的全部选手均被淘汰后比赛结束，余下的那支队伍将获得农心杯。\n\n新一届的比赛就要开始了。你作为 $A$ 队的领队，在比赛开始前已经统计了这 $3n$ 位选手之间的胜率——即对于来自不同队伍的两个选手 $Q$ 和 $R$，我们已知 $Q$ 战胜 $R$ 的概率为 $p$（$0 \\leq p \\leq 1$），且$R$战胜 $Q$ 的概率为 $1-p$。\n\n由于你所在的国家实力超群，可以认为剩下的两只队伍都将矛头对准了你。$B$、$C$ 队的每个决策，即派出选手的顺序的目的都是使你所在的国家（$A$ 队）夺冠的概率尽可能小，而$A$队的决策的目的必然是使最后夺冠的概率尽可能大。你要做的事情就是计算出在这种极为不利的情况下，在三方都做出最优决策的前提下，$A$ 队夺冠的期望 $E_A$。\n\n关于期望的计算：设现在在场上比赛的人是 $Q$ 和 $R$，$Q$ 胜 $R$的概率为 $p$，则此时 $A$ 队胜率的期望\n\n$E_A = p$ × $E_1 + (1 - p)$ × $E_2$\n\n其中 $E_1$ 为 $Q$ 胜 $R$ 后 $A$ 队夺冠的期望，$E_2$ 为 $R$ 胜 $Q$ 后 $A$ 队夺冠的期望。$E_1$、$E_2$ 则同样使用上式递归计算。\n\n$A$ 队的决策会尽可能使这个期望尽可能大，而 $B$、$C$ 队则会使这个期望尽可能小。当 $B$、$C$ 队的全部选手都被淘汰后夺冠期望为 $1$，$A$ 队所有队员被淘汰后期望为 $0$。\n\n例如当每队有 $3$ 位参赛选手时，相互之间的胜率由如下的$3$ 个 $3\\times 3$ 的矩阵给出，其中矩阵中的每个数值$p$ 为所在行选手对于所在列选手的胜率，所在列选手对于所在行选手的胜率为 $1-p$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/db2s8dim.png)\n\n三支队的第三位选手的水平相同，在第两局比赛后，三支队的选手获胜的概率是相同的。假设第二局获胜的是 $B_3$，第三局轮到 $A$ 队出场。这时我们可以派出 $A_1$ 和 $A_2$ 两种选择。\n\n如果派出 $A_2$，虽然第三局一定可以战胜 $B_3$（胜率为$100 \\%$），但是 $C$ 队会在第四场比赛中派出 $C_2$，$A_2$ 对于 $C_2$ 必败（胜率为 $0$），第五场中 $B$ 队会让 $B_1$ 出场，第六场 $A_1$ 只能出场，这时对 $A_1$ 必胜的 $B_2$ 还未登场，因此 $A_1$ 迟早会遭到淘汰，$A$ 队夺冠的概率就为 $0$。\n\n如果派出$A_1$，虽然本局对于 $B_3$ 比赛只有 $50 \\%$ 的胜率，但是夺冠的概率为 $6.25 \\%$；因此在第三场应该派出 $A_1$。\n\n根据第三场比赛的参赛选手的六种情况，最后夺冠的期望为：\n\n$$ \\dfrac{(6.25\\%+3.125\\%+18.75\\%+25\\%+60.9375\\%+50\\%)}{6} = 27.34375\\%$$\n", "inputFormat": "输入文件为 go.in。\n\n第一行包括一个整数 $n$，表示每队的选手数。\n\n第二行到第 $n + 1$ 行每行包含 $n$ 个实数，整体为一个$n\\times n$ 的矩阵，表示 $A$ 队对 $B$ 队的胜率。其中第$i + 1$ 行的第 $j$ 个数表示选手 $A_i$ 对选手 $B_j$ 时的胜率。\n\n第 $n + 2$ 行为空行。\n\n第 $n + 3$ 行到第 $2n + 2$ 行每行包含 $n$ 个实数，同样为一个 $n\\times n$ 的矩阵，表示 $A$ 队对 $C$ 队的胜率。其中第 $i + n + 2$ 行的第 $j$ 个数表示选手 $A_i$ 对选手 $C_j$ 时的胜率。\n\n第 $2n + 3$ 行为空行。\n\n第 $2n + 4$ 行到第 $3n + 3$ 行每行包含 $n$ 个实数，整体为一个 $n\\times n$ 的矩阵，表示 $B$ 队对 $C$ 队的胜率。其中第 $i + 2n + 3$ 行的第 $j$ 个数表示选手 $B_i$ 对选手 $C_j$ 时的胜率。\n", "outputFormat": "输出文件 go.out 仅包含一个实数，保留 $6$ 位小数，表示$A$队获得冠军的概率。\n", "hint": "$30\\%$ 的数据中，$n \\leq 4$。\n\n$40\\%$ 的数据中，$n \\leq 5$。\n\n$100\\%$ 的数据中，$n \\leq 7$。\n\n对于 $10\\%$ 的数据有三个胜率矩阵中，每个矩阵的元素都相同，但不同矩阵的数字可能不同。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2010] Three-Nation Go Relay Tournament", "background": "", "description": "The annual “Nongshim Cup” three-nation Go relay tournament is the highest-level Go competition in the world and the most exciting contest among China, Japan, and Korea. This problem is based on the rules of that event.\n\nThe three-nation Go relay tournament is a match among national teams of three countries. The rules are briefly as follows:\n\n1. Let the three countries be $A$, $B$, and $C$. Each country has $n$ players (in the real event above, $n = 5$), named $A_1, A_2, \\ldots, A_n$, $B_1, B_2, \\ldots, B_n$, and $C_1, C_2, \\ldots, C_n$.\n\n2. Every game has a winner and a loser. The loser of a game is eliminated.\n\n3. The first player to appear for each team is fixed to be that team’s $n$-th player, i.e., $A_n$, $B_n$, and $C_n$.\n\n4. One team is drawn uniformly at random. That team has a bye in round 1, and the $n$-th players of the other two teams play the first game.\n\n5. The winner of the first game (the “winner” here always means the player who wins that game) plays the $n$-th player of the team that had the bye in the second game. For example, if $C_n$ defeats $A_n$ in the first game, then the second game is $C_n$ vs. $B_n$.\n\n6. From the third game onward, the team that did not participate in the previous game selects one not-yet-eliminated player to play against the previous game’s winner.\n\n7. This process continues until all players of some team have been eliminated.\n\n8. When only two teams remain, after each game, the losing side chooses one not-yet-eliminated player to play the next game against the winner.\n\n9. When all players of either of the two remaining teams are eliminated, the match ends, and the remaining team wins the Nongshim Cup.\n\nA new edition of the tournament is about to begin. As the leader of Team $A$, you have computed the win probabilities among all $3n$ players — that is, for any two players $Q$ and $R$ from different teams, we know that the probability that $Q$ defeats $R$ is $p$ ($0 \\leq p \\leq 1$), and the probability that $R$ defeats $Q$ is $1 - p$.\n\nSince your country is overwhelmingly strong, assume the other two teams will both target you. Every decision by Teams $B$ and $C$ — i.e., the order in which they send players — aims to minimize the probability that Team $A$ wins the title, while Team $A$’s decisions aim to maximize that probability. Your task is to compute, under this highly unfavorable scenario and assuming all three sides play optimally, the expected probability $E_A$ that Team $A$ wins the championship.\n\nAbout the expectation: suppose the current game is between players $Q$ and $R$, and $Q$ defeats $R$ with probability $p$. Then Team $A$’s winning expectation at this moment is\n$E_A = p \\times E_1 + (1 - p) \\times E_2$,\nwhere $E_1$ is the expectation that Team $A$ wins the title after $Q$ defeats $R$, and $E_2$ is the expectation after $R$ defeats $Q$. $E_1$ and $E_2$ are computed recursively using the same formula.\n\nTeam $A$’s decisions will maximize this expectation, while Teams $B$ and $C$ will minimize it. If all players of Teams $B$ and $C$ are eliminated, the expectation is $1$; if all players of Team $A$ are eliminated, the expectation is $0$.\n\nFor example, when each team has $3$ players, the head-to-head win probabilities are given by the following three $3\\times 3$ matrices. In each matrix, every value $p$ is the row player’s probability of defeating the column player, and the column player’s probability of defeating the row player is $1 - p$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/db2s8dim.png)\n\nThe third players of the three teams are of equal strength. After the first two games, the probability that the current winner comes from any of the three teams is the same. Suppose the winner of the second game is $B_3$, and in the third game it is Team $A$’s turn to send a player. Team $A$ can choose between $A_1$ and $A_2$.\n\nIf we send $A_2$, although the third game is guaranteed to defeat $B_3$ (win probability $100 \\%$), Team $C$ will send $C_2$ in the fourth game, against whom $A_2$ surely loses (win probability $0$). In the fifth game, Team $B$ will send $B_1$, and in the sixth game only $A_1$ can be sent. Since $B_2$, who surely defeats $A_1$, has not yet appeared, $A_1$ will be eliminated sooner or later, and Team $A$’s winning probability is $0$.\n\nIf we send $A_1$, although the win probability against $B_3$ in this game is only $50 \\%$, the probability of winning the championship is $6.25 \\%$. Therefore, in the third game we should send $A_1$.\n\nConsidering the six possible pairs of players in the third game, the final expected championship probability is:\n$$ \\dfrac{(6.25\\%+3.125\\%+18.75\\%+25\\%+60.9375\\%+50\\%)}{6} = 27.34375\\%.$$", "inputFormat": "The input file is go.in.\n\nThe first line contains an integer $n$, the number of players on each team.\n\nLines $2$ to $n + 1$ each contain $n$ real numbers, forming an $n \\times n$ matrix that gives Team $A$’s win probabilities against Team $B$. In particular, on line $i + 1$, the $j$-th number is the probability that player $A_i$ defeats player $B_j$.\n\nLine $n + 2$ is a blank line.\n\nLines $n + 3$ to $2n + 2$ each contain $n$ real numbers, forming an $n \\times n$ matrix that gives Team $A$’s win probabilities against Team $C$. In particular, on line $i + n + 2$, the $j$-th number is the probability that player $A_i$ defeats player $C_j$.\n\nLine $2n + 3$ is a blank line.\n\nLines $2n + 4$ to $3n + 3$ each contain $n$ real numbers, forming an $n \\times n$ matrix that gives Team $B$’s win probabilities against Team $C$. In particular, on line $i + 2n + 3$, the $j$-th number is the probability that player $B_i$ defeats player $C_j$.", "outputFormat": "The output file go.out contains a single real number with $6$ decimal places, the probability that Team $A$ wins the championship.", "hint": "- For $30\\%$ of the testdata, $n \\leq 4$.\n- For $40\\%$ of the testdata, $n \\leq 5$.\n- For $100\\%$ of the testdata, $n \\leq 7$.\n- For $10\\%$ of the testdata, in each of the three win-probability matrices, every matrix has constant entries (all elements in a given matrix are the same), but different matrices may have different values.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2010] 三国围棋擂台赛", "background": "", "description": "一年一度的“农心杯”三国围棋擂台赛是世界上最高水平的围棋比赛，也是中日韩三国围棋界最激动人心的较量。本题就是建立在这一比赛的规则之上。\n\n三国围棋擂台赛是三个国家的代表队之间的比赛，下面简要介绍一下比赛的规则：\n\n1. 不妨设三个国家分别为 $A$、$B$ 和 $C$，每个国家各有$n$名选手（在上述的实际比赛中$n = 5$），分别称其为$A_1$，$A_2$，…，$A_n$，$B_1$，$B_2$，…，$B_n$，$C_1$，$C_2$，…，$C_n$。\n\n2. 每场比赛都能分出胜负。每场比赛的负者遭到淘汰。\n\n3. 每队第一位出场的选手都已经确定为每队的第$n$位选手，即 $A_n$、$B_n$ 和 $C_n$。\n\n4. 通过抽签等概率地选出一支队伍。该队将在第一轮中轮空，而剩下的两支队伍的第 $n$ 位选手将进行第一场比赛。\n\n5. 第一场比赛的胜者（这里的胜者是指赢得该局比赛的选手，下同）与轮空队伍的第 $n$ 位选手进行第二场比赛。比如在第一场比赛中 $C_n$ 战胜了 $A_n$，则第二场则由$C_n$对阵$B_n$。\n\n6. 从第三场比赛开始，前一场比赛未参加的队伍将选出一个未被淘汰的选手与上一场比赛的胜者进行下一场比赛。\n\n7. 这个过程将一直进行，直到某个队伍的全部参赛选手都被淘汰为止。\n\n8. 当只有两支队伍的时候，每场比赛后，由负方选择一位未被淘汰的选手与胜者进行下一场比赛。\n\n9. 当两支队伍中的任意一队的全部选手均被淘汰后比赛结束，余下的那支队伍将获得农心杯。\n\n新一届的比赛就要开始了。你作为 $A$ 队的领队，在比赛开始前已经统计了这 $3n$ 位选手之间的胜率——即对于来自不同队伍的两个选手 $Q$ 和 $R$，我们已知 $Q$ 战胜 $R$ 的概率为 $p$（$0 \\leq p \\leq 1$），且$R$战胜 $Q$ 的概率为 $1-p$。\n\n由于你所在的国家实力超群，可以认为剩下的两只队伍都将矛头对准了你。$B$、$C$ 队的每个决策，即派出选手的顺序的目的都是使你所在的国家（$A$ 队）夺冠的概率尽可能小，而$A$队的决策的目的必然是使最后夺冠的概率尽可能大。你要做的事情就是计算出在这种极为不利的情况下，在三方都做出最优决策的前提下，$A$ 队夺冠的期望 $E_A$。\n\n关于期望的计算：设现在在场上比赛的人是 $Q$ 和 $R$，$Q$ 胜 $R$的概率为 $p$，则此时 $A$ 队胜率的期望\n\n$E_A = p$ × $E_1 + (1 - p)$ × $E_2$\n\n其中 $E_1$ 为 $Q$ 胜 $R$ 后 $A$ 队夺冠的期望，$E_2$ 为 $R$ 胜 $Q$ 后 $A$ 队夺冠的期望。$E_1$、$E_2$ 则同样使用上式递归计算。\n\n$A$ 队的决策会尽可能使这个期望尽可能大，而 $B$、$C$ 队则会使这个期望尽可能小。当 $B$、$C$ 队的全部选手都被淘汰后夺冠期望为 $1$，$A$ 队所有队员被淘汰后期望为 $0$。\n\n例如当每队有 $3$ 位参赛选手时，相互之间的胜率由如下的$3$ 个 $3\\times 3$ 的矩阵给出，其中矩阵中的每个数值$p$ 为所在行选手对于所在列选手的胜率，所在列选手对于所在行选手的胜率为 $1-p$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/db2s8dim.png)\n\n三支队的第三位选手的水平相同，在第两局比赛后，三支队的选手获胜的概率是相同的。假设第二局获胜的是 $B_3$，第三局轮到 $A$ 队出场。这时我们可以派出 $A_1$ 和 $A_2$ 两种选择。\n\n如果派出 $A_2$，虽然第三局一定可以战胜 $B_3$（胜率为$100 \\%$），但是 $C$ 队会在第四场比赛中派出 $C_2$，$A_2$ 对于 $C_2$ 必败（胜率为 $0$），第五场中 $B$ 队会让 $B_1$ 出场，第六场 $A_1$ 只能出场，这时对 $A_1$ 必胜的 $B_2$ 还未登场，因此 $A_1$ 迟早会遭到淘汰，$A$ 队夺冠的概率就为 $0$。\n\n如果派出$A_1$，虽然本局对于 $B_3$ 比赛只有 $50 \\%$ 的胜率，但是夺冠的概率为 $6.25 \\%$；因此在第三场应该派出 $A_1$。\n\n根据第三场比赛的参赛选手的六种情况，最后夺冠的期望为：\n\n$$ \\dfrac{(6.25\\%+3.125\\%+18.75\\%+25\\%+60.9375\\%+50\\%)}{6} = 27.34375\\%$$\n", "inputFormat": "输入文件为 go.in。\n\n第一行包括一个整数 $n$，表示每队的选手数。\n\n第二行到第 $n + 1$ 行每行包含 $n$ 个实数，整体为一个$n\\times n$ 的矩阵，表示 $A$ 队对 $B$ 队的胜率。其中第$i + 1$ 行的第 $j$ 个数表示选手 $A_i$ 对选手 $B_j$ 时的胜率。\n\n第 $n + 2$ 行为空行。\n\n第 $n + 3$ 行到第 $2n + 2$ 行每行包含 $n$ 个实数，同样为一个 $n\\times n$ 的矩阵，表示 $A$ 队对 $C$ 队的胜率。其中第 $i + n + 2$ 行的第 $j$ 个数表示选手 $A_i$ 对选手 $C_j$ 时的胜率。\n\n第 $2n + 3$ 行为空行。\n\n第 $2n + 4$ 行到第 $3n + 3$ 行每行包含 $n$ 个实数，整体为一个 $n\\times n$ 的矩阵，表示 $B$ 队对 $C$ 队的胜率。其中第 $i + 2n + 3$ 行的第 $j$ 个数表示选手 $B_i$ 对选手 $C_j$ 时的胜率。\n", "outputFormat": "输出文件 go.out 仅包含一个实数，保留 $6$ 位小数，表示$A$队获得冠军的概率。\n", "hint": "$30\\%$ 的数据中，$n \\leq 4$。\n\n$40\\%$ 的数据中，$n \\leq 5$。\n\n$100\\%$ 的数据中，$n \\leq 7$。\n\n对于 $10\\%$ 的数据有三个胜率矩阵中，每个矩阵的元素都相同，但不同矩阵的数字可能不同。\n", "locale": "zh-CN"}}}
{"pid": "P4191", "type": "P", "difficulty": 7, "samples": [["4 1\n1 2 3 4\n4 3 3 1\n", "2\n1\n0\n2\n"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2010", "分治", "素数判断,质数,筛法", "快速傅里叶变换 FFT", "CTSC/CTS"], "title": "[CTSC2010] 性能优化", "background": "", "description": "程序员小明正在开发一套大型软件，软件中有一段核心程序，用伪代码描述如下（假设所有变量初值均为 $0$，并且假定其中的数据类型均不会出现溢出）： \n\n~~~cpp\nInput a[0], a[1], ... , a[n - 1], b[0], b[1], ... , b[n - 1], C\nFor i: 0 to n - 1\n\tx[0, i] = a[i]\nFor i: 0 to C - 1\n\tFor j: 0 to n - 1\n\t\tFor k: 0 to n - 1\n\t\t\tx[i + 1, (j + k) mod n] = x[i + 1, (j + k) mod n] + b[k]x[i, j]\nOutput x[C, 0] mod (n + 1), x[C, 1] mod (n + 1), ... , x[C, n - 1] mod (n + 1)\n~~~\n\n但是，这段程序的效率非常低，它的时间复杂度高达 $\\Theta(n^2C)$。他想让你帮忙优化一下这个程序，当然要求输出相同的结果。为了使问题更简单，他保证输入的 $n$ 能表示成若干个不超过 $10$ 的正整数的乘积，并且 $n + 1$ 是质数。", "inputFormat": "规范起见，以下将下标统一写到数组名称的右下角。例如： $a_1$ 对应伪代码中的 `a[1]`，$x_{C, 0}$ 对应伪代码中的 `x[C, 0]`。\n\n输入的第一行包含两个非负整数 $n, C$。\n\n接下来一行包含 $n$ 个非负整数 $a_0, a_1, \\cdots , a_{n - 1}$。\n\n接下来一行包含 $n$ 个非负整数 $b_0, b_1, \\cdots , b_{n - 1}$。", "outputFormat": "输出包含 $n$ 行，每行包含一个数。第 $i$ 行为 $x_{C, i}\\bmod (n + 1)$ 的值。你需要保证输出的数在 $0 \\sim n$ 之间。", "hint": "总共 $10$ 个测试点，数据范围满足：\n\n| 测试点 |         $n$          |     $C$     |\n| :----: | :------------------: | :---------: |\n|   1    |      $\\leq 100$      | $\\leq 100$  |\n|   2    |      $\\leq 100$      | $\\leq 10^9$ |\n|   3    |      $\\leq 700$      | $\\leq 10^9$ |\n|   4    |      $\\leq 700$      | $\\leq 10^9$ |\n|   5    |     $\\leq 10^4$      |   $ = 1$    |\n|   6    |     $\\leq 10^5$      |    $= 1$    |\n|   7    |     $\\leq 10^5$      |    $= 1$    |\n|   8    | $\\leq 5 \\times 10^5$ | $\\leq 10^9$ |\n|   9    | $\\leq 5 \\times 10^5$ | $\\leq 10^9$ |\n|   10   | $\\leq 5 \\times 10^5$ | $\\leq 10^9$ |\n\n在所有输入数据中，$a_i$ 和 $b_i$ 均不超过 $10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2010] Performance Optimization", "background": "# Description\n\nProgrammer Xiao Ming is developing a large software system. There is a core routine described by the following pseudocode (assume all variables are initially $0$, and that none of the data types will overflow):\n\n~~~cpp\nInput a[0], a[1], ... , a[n - 1], b[0], b[1], ... , b[n - 1], C\nFor i: 0 to n - 1\n\tx[0, i] = a[i]\nFor i: 0 to C - 1\n\tFor j: 0 to n - 1\n\t\tFor k: 0 to n - 1\n\t\t\tx[i + 1, (j + k) mod n] = x[i + 1, (j + k) mod n] + b[k]x[i, j]\nOutput x[C, 0] mod (n + 1), x[C, 1] mod (n + 1), ... , x[C, n - 1] mod (n + 1)\n~~~\n\nHowever, this program is very inefficient; its time complexity is $\\Theta(n^2 C)$. He wants you to optimize this program while producing the same output. To make the problem easier, he guarantees that the input $n$ can be written as a product of some positive integers, each no greater than $10$, and that $n + 1$ is prime.", "description": "", "inputFormat": "", "outputFormat": "Output contains $n$ lines, one number per line. The $i$-th line is the value of $x_{C, i} \\bmod (n + 1)$. You should ensure each printed number is between $0$ and $n$ inclusive.", "hint": "There are $10$ test points in total. Constraints:\n\n| Test Point |         $n$          |     $C$     |\n| :--------: | :------------------: | :---------: |\n|     1      |      $\\leq 100$      | $\\leq 100$  |\n|     2      |      $\\leq 100$      | $\\leq 10^9$ |\n|     3      |      $\\leq 700$      | $\\leq 10^9$ |\n|     4      |      $\\leq 700$      | $\\leq 10^9$ |\n|     5      |     $\\leq 10^4$      |   $ = 1$    |\n|     6      |     $\\leq 10^5$      |    $= 1$    |\n|     7      |     $\\leq 10^5$      |    $= 1$    |\n|     8      | $\\leq 5 \\times 10^5$ | $\\leq 10^9$ |\n|     9      | $\\leq 5 \\times 10^5$ | $\\leq 10^9$ |\n|     10     | $\\leq 5 \\times 10^5$ | $\\leq 10^9$ |\n\nIn all testdata, $a_i$ and $b_i$ do not exceed $10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2010] 性能优化", "background": "", "description": "程序员小明正在开发一套大型软件，软件中有一段核心程序，用伪代码描述如下（假设所有变量初值均为 $0$，并且假定其中的数据类型均不会出现溢出）： \n\n~~~cpp\nInput a[0], a[1], ... , a[n - 1], b[0], b[1], ... , b[n - 1], C\nFor i: 0 to n - 1\n\tx[0, i] = a[i]\nFor i: 0 to C - 1\n\tFor j: 0 to n - 1\n\t\tFor k: 0 to n - 1\n\t\t\tx[i + 1, (j + k) mod n] = x[i + 1, (j + k) mod n] + b[k]x[i, j]\nOutput x[C, 0] mod (n + 1), x[C, 1] mod (n + 1), ... , x[C, n - 1] mod (n + 1)\n~~~\n\n但是，这段程序的效率非常低，它的时间复杂度高达 $\\Theta(n^2C)$。他想让你帮忙优化一下这个程序，当然要求输出相同的结果。为了使问题更简单，他保证输入的 $n$ 能表示成若干个不超过 $10$ 的正整数的乘积，并且 $n + 1$ 是质数。", "inputFormat": "规范起见，以下将下标统一写到数组名称的右下角。例如： $a_1$ 对应伪代码中的 `a[1]`，$x_{C, 0}$ 对应伪代码中的 `x[C, 0]`。\n\n输入的第一行包含两个非负整数 $n, C$。\n\n接下来一行包含 $n$ 个非负整数 $a_0, a_1, \\cdots , a_{n - 1}$。\n\n接下来一行包含 $n$ 个非负整数 $b_0, b_1, \\cdots , b_{n - 1}$。", "outputFormat": "输出包含 $n$ 行，每行包含一个数。第 $i$ 行为 $x_{C, i}\\bmod (n + 1)$ 的值。你需要保证输出的数在 $0 \\sim n$ 之间。", "hint": "总共 $10$ 个测试点，数据范围满足：\n\n| 测试点 |         $n$          |     $C$     |\n| :----: | :------------------: | :---------: |\n|   1    |      $\\leq 100$      | $\\leq 100$  |\n|   2    |      $\\leq 100$      | $\\leq 10^9$ |\n|   3    |      $\\leq 700$      | $\\leq 10^9$ |\n|   4    |      $\\leq 700$      | $\\leq 10^9$ |\n|   5    |     $\\leq 10^4$      |   $ = 1$    |\n|   6    |     $\\leq 10^5$      |    $= 1$    |\n|   7    |     $\\leq 10^5$      |    $= 1$    |\n|   8    | $\\leq 5 \\times 10^5$ | $\\leq 10^9$ |\n|   9    | $\\leq 5 \\times 10^5$ | $\\leq 10^9$ |\n|   10   | $\\leq 5 \\times 10^5$ | $\\leq 10^9$ |\n\n在所有输入数据中，$a_i$ 和 $b_i$ 均不超过 $10^9$。", "locale": "zh-CN"}}}
{"pid": "P4192", "type": "P", "difficulty": 6, "samples": [["5\n1 8 -8 3 -7\n3\n1 1 5\n0 1 3 6\n1 2 4", "9\n22"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["树状数组", "前缀和", "分块"], "title": "旅行规划", "background": null, "description": "OIVillage 是一个风景秀美的乡村，为了更好的利用当地的旅游资源，吸引游客，推动经济发展，xkszltl 决定修建了一条铁路将当地 $n$ 个最著名的景点连接起来，让游客可以通过火车从铁路起点（1 号景点）出发，依次游览每个景区。为了更好的评价这条铁路，xkszltl 为每一个景区都赋予了一个美观度，而一条旅行路径的价值就是它所经过的景区的美观度之和。不过，随着天气与季节的变化，某些景点的美观度也会发生变化。\n\nxkszltl 希望为每位旅客提供最佳的旅行指导，但是由于游客的时间有限，不一定能游览全部景区，然而他们也不希望旅途过于短暂，所以每个游客都希望能在某一个区间内的车站结束旅程，而 xkszltl 的任务就是为他们选择一个终点使得旅行线路的价值最大。可是当地的景点与前来观光的旅客实在是太多了，xkszltl 无法及时完成任务，于是找到了准备虐杀 NOI2011 的你，希望你能帮助他完成这个艰巨的任务。", "inputFormat": "第一行给出一个整数 $n$，接下来一行给出 $n$ 个景区的初始美观度。\n\n第三行给出一个整数 $m$，接下来 $m$ 行每行为一条指令：\n\n1. `0 x y k`：表示将 $x$ 到 $y$ 这段铁路边上的景区的美观度加上k；\n\n2. `1 x y`：表示有一名旅客想要在 $x$ 到 $y$ 这段（含 $x$ 与 $y$）中的某一站下车，你需要告诉他最大的旅行价值。", "outputFormat": "对于每个询问，输出一个整数表示最大的旅行价值。", "hint": "$1\\le n,m \\le 100000$\n\n$1\\le x\\le y\\le n$\n\n$|a_i|,|k|\\le 10^9$", "locale": "zh-CN", "translations": {"en": {"title": "Travel Planning", "background": "", "description": "OIVillage is a beautiful village. To better use its tourism resources, attract visitors, and boost the economy, xkszltl decided to build a railway connecting the $n$ most famous scenic spots so that tourists can take the train from the railway’s starting point (scenic spot 1) and visit each spot in order. To better evaluate this railway, xkszltl assigns each scenic spot a beauty value, and the value of a travel route is the sum of the beauty values of the scenic spots it passes through. However, as weather and seasons change, the beauty of some spots may change as well.\n\nxkszltl hopes to provide the best travel guidance for every tourist. Because tourists have limited time, they may not be able to visit all spots, but they also do not want the trip to be too short. Therefore, each tourist wants to end their trip at some station within a certain interval, and xkszltl’s task is to choose an endpoint for them so that the travel route’s value is maximized. However, there are simply too many scenic spots and too many tourists, so xkszltl cannot finish in time and turns to you—who is aiming to ace NOI 2011—for help with this challenging task.", "inputFormat": "- The first line contains an integer $n$. The next line contains $n$ integers, the initial beauty of each scenic spot.\n- The third line contains an integer $m$. The next $m$ lines each describe one instruction:\n  1. `0 x y k`: Add $k$ to the beauty of every scenic spot from $x$ to $y$.\n  2. `1 x y`: One tourist wants to get off at some station in the interval $[x, y]$ (inclusive). You must tell them the maximum travel value.\n\nThe traveler always starts from scenic spot 1 and visits spots in order.", "outputFormat": "For each query, output one integer: the maximum travel value.", "hint": "$1 \\le n, m \\le 100000$.\n\n$1 \\le x \\le y \\le n$.\n\n$|a_i|, |k| \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "旅行规划", "background": null, "description": "OIVillage 是一个风景秀美的乡村，为了更好的利用当地的旅游资源，吸引游客，推动经济发展，xkszltl 决定修建了一条铁路将当地 $n$ 个最著名的景点连接起来，让游客可以通过火车从铁路起点（1 号景点）出发，依次游览每个景区。为了更好的评价这条铁路，xkszltl 为每一个景区都赋予了一个美观度，而一条旅行路径的价值就是它所经过的景区的美观度之和。不过，随着天气与季节的变化，某些景点的美观度也会发生变化。\n\nxkszltl 希望为每位旅客提供最佳的旅行指导，但是由于游客的时间有限，不一定能游览全部景区，然而他们也不希望旅途过于短暂，所以每个游客都希望能在某一个区间内的车站结束旅程，而 xkszltl 的任务就是为他们选择一个终点使得旅行线路的价值最大。可是当地的景点与前来观光的旅客实在是太多了，xkszltl 无法及时完成任务，于是找到了准备虐杀 NOI2011 的你，希望你能帮助他完成这个艰巨的任务。", "inputFormat": "第一行给出一个整数 $n$，接下来一行给出 $n$ 个景区的初始美观度。\n\n第三行给出一个整数 $m$，接下来 $m$ 行每行为一条指令：\n\n1. `0 x y k`：表示将 $x$ 到 $y$ 这段铁路边上的景区的美观度加上k；\n\n2. `1 x y`：表示有一名旅客想要在 $x$ 到 $y$ 这段（含 $x$ 与 $y$）中的某一站下车，你需要告诉他最大的旅行价值。", "outputFormat": "对于每个询问，输出一个整数表示最大的旅行价值。", "hint": "$1\\le n,m \\le 100000$\n\n$1\\le x\\le y\\le n$\n\n$|a_i|,|k|\\le 10^9$", "locale": "zh-CN"}}}
{"pid": "P4193", "type": "P", "difficulty": 4, "samples": [["3\n1 5\n3 9\n8 8", "2\n2\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数论"], "title": "数字", "background": null, "description": "小 D 喜欢的数有这样的性质：\n\n令 $n$ 为正整数，$S(n)$ 为 $n$ 的各位数字之和，令\n\n$$D(n)\\begin{cases}\\displaystyle S(n) \\quad S(n)<10 \\\\\\displaystyle D(S(n)) \\quad S(n)>10\\end{cases}$$\n\n小 D 喜欢的数一定能表示成 $x \\times D(x)$ 这种形式（即若一个数 $A$ 是被喜欢的，则存在一个数 $x$，使得 $A = x \\times D(x)$）。\n\n小 D 想知道在区间 $[L, R]$ 中，有多少个数是他喜欢的。", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n接下来 $T$ 行，每行两个数 $L$、$R$（保证区间合法），代表询问 $[L, R]$。", "outputFormat": "输出 $T$ 行，每行一个数，表示在这个区间内小 D 喜欢的数出现了多少次。\n\n你的输出当且仅当和标准输出一样才能得该测试点满分。", "hint": "对于 $100 \\%$ 的数据，$L,R \\le 10^{18}$，$T \\le 20$。", "locale": "zh-CN", "translations": {"en": {"title": "Numbers", "background": "", "description": "Xiao D's favorite numbers have the following property.\n\nLet $n$ be a positive integer, let $S(n)$ be the sum of the digits of $n$, and define $D(n)$ as follows.\n$$\nD(n) = \\begin{cases}\n\\displaystyle S(n) & S(n) < 10 \\\\\n\\displaystyle D(S(n)) & S(n) > 10\n\\end{cases}\n$$\nEvery number that Xiao D likes can be written in the form $x \\times D(x)$ (that is, if a number $A$ is liked, then there exists a number $x$ such that $A = x \\times D(x)$).\n\nXiao D wants to know how many numbers he likes in the interval $[L, R]$.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nThe next $T$ lines each contain two numbers $L$ and $R$ (the interval is guaranteed to be valid), representing the query $[L, R]$.", "outputFormat": "Output $T$ lines, each with a single number, indicating how many numbers Xiao D likes appear in this interval.\n\nYou will receive full score for a test point if and only if your output exactly matches the standard output.", "hint": "For $100\\%$ of the testdata, $L, R \\le 10^{18}$ and $T \\le 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数字", "background": null, "description": "小 D 喜欢的数有这样的性质：\n\n令 $n$ 为正整数，$S(n)$ 为 $n$ 的各位数字之和，令\n\n$$D(n)\\begin{cases}\\displaystyle S(n) \\quad S(n)<10 \\\\\\displaystyle D(S(n)) \\quad S(n)>10\\end{cases}$$\n\n小 D 喜欢的数一定能表示成 $x \\times D(x)$ 这种形式（即若一个数 $A$ 是被喜欢的，则存在一个数 $x$，使得 $A = x \\times D(x)$）。\n\n小 D 想知道在区间 $[L, R]$ 中，有多少个数是他喜欢的。", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n接下来 $T$ 行，每行两个数 $L$、$R$（保证区间合法），代表询问 $[L, R]$。", "outputFormat": "输出 $T$ 行，每行一个数，表示在这个区间内小 D 喜欢的数出现了多少次。\n\n你的输出当且仅当和标准输出一样才能得该测试点满分。", "hint": "对于 $100 \\%$ 的数据，$L,R \\le 10^{18}$，$T \\le 20$。", "locale": "zh-CN"}}}
{"pid": "P4194", "type": "P", "difficulty": 6, "samples": [["2 2\n0 1\n2 1\n0 1", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": [], "title": "矩阵", "background": "", "description": "给定一个整数矩阵 $A[n\\times m]$，求一个矩阵 $B[n\\times m]$，满足 $\\forall 1\\le i\\le n,1\\le j\\le m,B_{i,j}\\in[L,R]$，且使下式值最小：\n\n$$\\max\\begin{cases}\\displaystyle\\max_{1\\le j\\le m}\\left\\{\\left|\\sum_{i=1}^n\\left(A_{i,j}-B_{i,j}\\right)\\right|\\right\\}\\\\\\displaystyle\\max_{1\\le i\\le n}\\left\\{\\left|\\sum_{j=1}^m\\left(A_{i,j}-B_{i,j}\\right)\\right|\\right\\}\\end{cases}$$", "inputFormat": "第一行两个整数 $n$，$m$，表示矩阵的大小。\n\n接下来 $n$ 行，每行 $m$ 个整数，描述矩阵 $A$。\n\n最后一行有两个整数 $L$，$R$。", "outputFormat": "输出一行一个整数代表答案。", "hint": "对于 $100\\%$ 的数据满足 $n,m\\le200$，$0\\le L\\le R\\le1000$，$0\\le A_{i,j}\\le1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Matrix", "background": "", "description": "Given an integer matrix $A[n\\times m]$, find a matrix $B[n\\times m]$ such that $\\forall 1\\le i\\le n,1\\le j\\le m,B_{i,j}\\in[L,R]$, and minimize the following value.\n\n$$\\max\\begin{cases}\\displaystyle\\max_{1\\le j\\le m}\\left\\{\\left|\\sum_{i=1}^n\\left(A_{i,j}-B_{i,j}\\right)\\right|\\right\\}\\\\\\displaystyle\\max_{1\\le i\\le n}\\left\\{\\left|\\sum_{j=1}^m\\left(A_{i,j}-B_{i,j}\\right)\\right|\\right\\}\\end{cases}$$", "inputFormat": "The first line contains two integers $n$ and $m$, the size of the matrix.\n\nEach of the next $n$ lines contains $m$ integers, describing matrix $A$.\n\nThe last line contains two integers $L$ and $R$.", "outputFormat": "Output one line with a single integer representing the answer.", "hint": "Constraints: For 100% of the testdata, $n, m \\le 200$, $0 \\le L \\le R \\le 1000$, $0 \\le A_{i,j} \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "矩阵", "background": "", "description": "给定一个整数矩阵 $A[n\\times m]$，求一个矩阵 $B[n\\times m]$，满足 $\\forall 1\\le i\\le n,1\\le j\\le m,B_{i,j}\\in[L,R]$，且使下式值最小：\n\n$$\\max\\begin{cases}\\displaystyle\\max_{1\\le j\\le m}\\left\\{\\left|\\sum_{i=1}^n\\left(A_{i,j}-B_{i,j}\\right)\\right|\\right\\}\\\\\\displaystyle\\max_{1\\le i\\le n}\\left\\{\\left|\\sum_{j=1}^m\\left(A_{i,j}-B_{i,j}\\right)\\right|\\right\\}\\end{cases}$$", "inputFormat": "第一行两个整数 $n$，$m$，表示矩阵的大小。\n\n接下来 $n$ 行，每行 $m$ 个整数，描述矩阵 $A$。\n\n最后一行有两个整数 $L$，$R$。", "outputFormat": "输出一行一个整数代表答案。", "hint": "对于 $100\\%$ 的数据满足 $n,m\\le200$，$0\\le L\\le R\\le1000$，$0\\le A_{i,j}\\le1000$。", "locale": "zh-CN"}}}
{"pid": "P4195", "type": "P", "difficulty": 6, "samples": [["5 58 33\n2 4 3\n0 0 0", "9\nNo Solution"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化", "枚举", "素数判断,质数,筛法", "分块", "大步小步算法 BSGS", "模板题"], "title": "【模板】扩展 BSGS / exBSGS", "background": "题目来源：SPOJ3105 Mod", "description": "给定 $a,p,b$，求满足 $a^x≡b \\pmod p$ 的最小自然数 $x$ 。\n", "inputFormat": "每个测试文件中包含若干组测试数据，保证 $\\sum \\sqrt p\\le 5\\times 10^6$。\n\n每组数据中，每行包含 $3$ 个正整数 $a,p,b$ 。\n\n当 $a=p=b=0$ 时，表示测试数据读入完全。\n", "outputFormat": "对于每组数据，输出一行。\n\n如果无解，输出 `No Solution`，否则输出最小自然数解。\n", "hint": "对于 $100\\%$ 的数据，$1\\le a,p,b≤10^9$ 或 $a=p=b=0$。\n\n2021/5/14 加强 by [SSerxhs](https://www.luogu.com.cn/user/29826)。  \n2021/7/1 新添加[一组 Hack 数据](https://www.luogu.com.cn/discuss/391666)。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Extended BSGS / exBSGS", "background": "Source: SPOJ3105 Mod.", "description": "Given $a,p,b$, find the smallest non-negative integer $x$ such that $a^x≡b \\pmod p$.", "inputFormat": "Each test file contains several test cases, with the guarantee that $\\sum \\sqrt p\\le 5\\times 10^6$.\n\nEach test case consists of one line with $3$ positive integers $a,p,b$.\n\nWhen $a=p=b=0$, it indicates the end of input.", "outputFormat": "For each test case, output one line.\n\nIf there is no solution, output `No Solution`. Otherwise, output the smallest non-negative integer solution.", "hint": "For $100\\%$ of the testdata, $1\\le a,p,b\\le 10^9$ or $a=p=b=0$.\n\n2021/5/14 strengthened by [SSerxhs](https://www.luogu.com.cn/user/29826).  \n2021/7/1 added [a set of hack testdata](https://www.luogu.com.cn/discuss/391666).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】扩展 BSGS / exBSGS", "background": "题目来源：SPOJ3105 Mod", "description": "给定 $a,p,b$，求满足 $a^x≡b \\pmod p$ 的最小自然数 $x$ 。\n", "inputFormat": "每个测试文件中包含若干组测试数据，保证 $\\sum \\sqrt p\\le 5\\times 10^6$。\n\n每组数据中，每行包含 $3$ 个正整数 $a,p,b$ 。\n\n当 $a=p=b=0$ 时，表示测试数据读入完全。\n", "outputFormat": "对于每组数据，输出一行。\n\n如果无解，输出 `No Solution`，否则输出最小自然数解。\n", "hint": "对于 $100\\%$ 的数据，$1\\le a,p,b≤10^9$ 或 $a=p=b=0$。\n\n2021/5/14 加强 by [SSerxhs](https://www.luogu.com.cn/user/29826)。  \n2021/7/1 新添加[一组 Hack 数据](https://www.luogu.com.cn/discuss/391666)。", "locale": "zh-CN"}}}
{"pid": "P4196", "type": "P", "difficulty": 6, "samples": [["2\n6\n-2 0\n-1 -2\n1 -2\n2 0\n1 2\n-1 2\n4\n0 -3\n1 -1\n2 2\n-1 0", "5.233"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "重庆", "各省省选", "排序", "向量", "栈", "队列", "半平面交", "模板题"], "title": "【模板】半平面交 / [CQOI2006] 凸多边形", "background": "", "description": "逆时针给出 $n$ 个凸多边形的顶点坐标，求它们交的面积。例如 $n=2$ 时，两个凸多边形如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7ieux7g3.png)\n\n则相交部分的面积为 $5.233$。", "inputFormat": "第一行有一个整数 $n$，表示凸多边形的个数，以下依次描述各个多边形。第 $i$ 个多边形的第一行包含一个整数 $m_i$，表示多边形的边数，以下 $m_i$ 行每行两个整数，逆时针给出各个顶点的坐标。", "outputFormat": "输出文件仅包含一个实数，表示相交部分的面积，保留三位小数。", "hint": "对于 $100\\%$ 的数据：$2 \\leq n \\leq 10$，$3 \\leq m_i \\leq 50$，每维坐标为 $[-1000,1000]$ 内的整数。", "locale": "zh-CN", "translations": {"en": {"title": "【Template】Half-Plane Intersection / [CQOI2006] Convex Polygon", "background": "", "description": "Given $n$ convex polygons with vertices listed in counterclockwise order, find the area of their intersection. For example, when $n = 2$, the two convex polygons are shown below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7ieux7g3.png)\n\nThe area of the intersection is $5.233$.", "inputFormat": "The first line contains an integer $n$, the number of convex polygons. Each polygon is then described in order. For the $i$-th polygon, the first line contains an integer $m_i$, the number of edges. The next $m_i$ lines each contain two integers, giving the coordinates of the vertices in counterclockwise order.", "outputFormat": "Output a single real number, the area of the intersection, rounded to three decimal places.", "hint": "Constraints: For $100\\%$ of the testdata: $2 \\leq n \\leq 10$, $3 \\leq m_i \\leq 50$, and each coordinate is an integer in $[-1000, 1000]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】半平面交 / [CQOI2006] 凸多边形", "background": "", "description": "逆时针给出 $n$ 个凸多边形的顶点坐标，求它们交的面积。例如 $n=2$ 时，两个凸多边形如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7ieux7g3.png)\n\n则相交部分的面积为 $5.233$。", "inputFormat": "第一行有一个整数 $n$，表示凸多边形的个数，以下依次描述各个多边形。第 $i$ 个多边形的第一行包含一个整数 $m_i$，表示多边形的边数，以下 $m_i$ 行每行两个整数，逆时针给出各个顶点的坐标。", "outputFormat": "输出文件仅包含一个实数，表示相交部分的面积，保留三位小数。", "hint": "对于 $100\\%$ 的数据：$2 \\leq n \\leq 10$，$3 \\leq m_i \\leq 50$，每维坐标为 $[-1000,1000]$ 内的整数。", "locale": "zh-CN"}}}
{"pid": "P4197", "type": "P", "difficulty": 6, "samples": [["10 11 4\n1 2 3 4 5 6 7 8 9 10\n1 4 4\n2 5 3\n9 8 2\n7 8 10\n7 1 4\n6 7 1\n6 4 8\n2 1 5\n10 8 10\n3 4 7\n3 4 6\n1 5 2\n1 5 6\n1 5 8\n8 9 2", "6\n1\n-1\n8\n"]], "limits": {"time": [2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152]}, "tags": ["2010", "倍增", "Kruskal 重构树", "生成树", "可持久化线段树"], "title": "[ONTAK2010] Peaks", "background": null, "description": "在 Bytemountains 有 $n$ 座山峰，每座山峰有他的高度 $h_i$。有些山峰之间有双向道路相连，共 $m$ 条路径，每条路径有一个困难值，这个值越大表示越难走。\n\n现在有 $q$ 组询问，每组询问询问从点 $v$ 开始只经过困难值小于等于 $x$ 的路径所能到达的山峰中第 $k$ 高的山峰，如果无解输出 $-1$。", "inputFormat": "第一行三个数 $n,m,q$。第二行 $n$ 个数，第 $i$ 个数为 $h_i$。\n\n接下来 $m$ 行，每行三个整数 $a,b,c$，表示从 $a \\to b$ 有一条困难值为 $c$ 的双向路径。\n\n接下来 $q$ 行，每行三个数 $v,x,k$，表示一组询问。", "outputFormat": "对于每组询问，输出一个整数表示能到达的山峰中第 $k$ 高的山峰的高度。", "hint": "### 数据规模与约定\n对于 $100\\%$ 的数据，$1 \\le v,k \\le n \\le 10^5$，$1 \\le m,q \\le 5\\times 10^5$，$1 \\le h_i,c,x \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[ONTAK2010] Peaks", "background": "", "description": "In Bytemountains, there are $n$ peaks, and each peak has its height $h_i$. Some pairs of peaks are connected by bidirectional roads; there are $m$ roads in total. Each road has a difficulty value, and a larger value means it is harder to traverse.\n\nThere are $q$ queries. For each query, starting from vertex $v$, you may only traverse roads whose difficulty is less than or equal to $x$. Among all peaks reachable this way, find the $k$-th highest peak. If there is no such peak, output $-1$.", "inputFormat": "The first line contains three integers $n, m, q$. The second line contains $n$ integers, where the $i$-th is $h_i$.\n\nThe next $m$ lines each contain three integers $a, b, c$, indicating there is a bidirectional road between $a$ and $b$ with difficulty $c$.\n\nThe next $q$ lines each contain three integers $v, x, k$, describing a query.", "outputFormat": "For each query, output a single integer: the height of the $k$-th highest reachable peak.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le v, k \\le n \\le 10^5$, $1 \\le m, q \\le 5 \\times 10^5$, $1 \\le h_i, c, x \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ONTAK2010] Peaks", "background": null, "description": "在 Bytemountains 有 $n$ 座山峰，每座山峰有他的高度 $h_i$。有些山峰之间有双向道路相连，共 $m$ 条路径，每条路径有一个困难值，这个值越大表示越难走。\n\n现在有 $q$ 组询问，每组询问询问从点 $v$ 开始只经过困难值小于等于 $x$ 的路径所能到达的山峰中第 $k$ 高的山峰，如果无解输出 $-1$。", "inputFormat": "第一行三个数 $n,m,q$。第二行 $n$ 个数，第 $i$ 个数为 $h_i$。\n\n接下来 $m$ 行，每行三个整数 $a,b,c$，表示从 $a \\to b$ 有一条困难值为 $c$ 的双向路径。\n\n接下来 $q$ 行，每行三个数 $v,x,k$，表示一组询问。", "outputFormat": "对于每组询问，输出一个整数表示能到达的山峰中第 $k$ 高的山峰的高度。", "hint": "### 数据规模与约定\n对于 $100\\%$ 的数据，$1 \\le v,k \\le n \\le 10^5$，$1 \\le m,q \\le 5\\times 10^5$，$1 \\le h_i,c,x \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4198", "type": "P", "difficulty": 6, "samples": [["3 4\n2 4\n3 6\n1 1000000000\n1 1", "1\n1\n1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "递归", "分块"], "title": "楼房重建", "background": "", "description": "小 A 的楼房外有一大片施工工地，工地上有 $N$ 栋待建的楼房。每天，这片工地上的房子拆了又建、建了又拆。他经常无聊地看着窗外发呆，数自己能够看到多少栋房子。\n\n为了简化问题，我们考虑这些事件发生在一个二维平面上。小 A 在平面上 $(0,0)$ 点的位置，第 $i$ 栋楼房可以用一条连接 $(i,0)$ 和 $(i,H_i)$ 的线段表示，其中 $H_i$ 为第 $i$ 栋楼房的高度。如果这栋楼房上存在一个高度大于 $0$ 的点与 $(0,0)$ 的连线没有与之前的线段相交，那么这栋楼房就被认为是可见的。\n\n施工队的建造总共进行了 $M$ 天。初始时，所有楼房都还没有开始建造，它们的高度均为 $0$。在第 $i$ 天，建筑队将会将横坐标为 $X_i$ 的房屋的高度变为 $Y_i$（高度可以比原来大—修建，也可以比原来小—拆除，甚至可以保持不变—建筑队这天什么事也没做）。请你帮小 A 数数每天在建筑队完工之后，他能看到多少栋楼房？", "inputFormat": "第一行两个正整数 $N,M$。\n\n接下来 $M$ 行，每行两个正整数 $X_i,Y_i$。", "outputFormat": "$M$ 行，第 $i$ 行一个整数表示第 $i$ 天过后小 A 能看到的楼房有多少栋。", "hint": "对于 $100\\%$ 的数据，$1 \\le X_i \\le N$，$1 \\le Y_i \\le 10^9$，$1\\le N,M \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Building Reconstruction", "background": "", "description": "Outside Xiao A’s building is a large construction site with $N$ buildings under construction. Every day, buildings on this site are torn down and rebuilt, over and over. He often stares out the window, counting how many buildings he can see.\n\nTo simplify, we consider the events in a 2D plane. Xiao A is at point $(0, 0)$. The $i$-th building is represented by a line segment connecting $(i, 0)$ and $(i, H_i)$, where $H_i$ is the height of the $i$-th building. A building is considered visible if there exists a point on it with height greater than $0$ such that the line segment from $(0, 0)$ to that point does not intersect any of the segments of buildings $1, 2, \\dots, i-1$.\n\nThe construction lasts for $M$ days. Initially, all buildings have height $0$. On day $i$, the crew sets the height of the building with $x$-coordinate $X_i$ to $Y_i$ (the height may increase — construction, decrease — demolition, or remain unchanged — meaning the crew effectively did nothing that day). After the crew finishes each day, please tell how many buildings Xiao A can see.", "inputFormat": "The first line contains two positive integers $N, M$.\n\nThe next $M$ lines each contain two positive integers $X_i, Y_i$.", "outputFormat": "Output $M$ lines. On the $i$-th line, output one integer denoting the number of buildings visible to Xiao A after day $i$.", "hint": "For $100\\%$ of the testdata, $1 \\le X_i \\le N$, $1 \\le Y_i \\le 10^9$, $1 \\le N, M \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "楼房重建", "background": "", "description": "小 A 的楼房外有一大片施工工地，工地上有 $N$ 栋待建的楼房。每天，这片工地上的房子拆了又建、建了又拆。他经常无聊地看着窗外发呆，数自己能够看到多少栋房子。\n\n为了简化问题，我们考虑这些事件发生在一个二维平面上。小 A 在平面上 $(0,0)$ 点的位置，第 $i$ 栋楼房可以用一条连接 $(i,0)$ 和 $(i,H_i)$ 的线段表示，其中 $H_i$ 为第 $i$ 栋楼房的高度。如果这栋楼房上存在一个高度大于 $0$ 的点与 $(0,0)$ 的连线没有与之前的线段相交，那么这栋楼房就被认为是可见的。\n\n施工队的建造总共进行了 $M$ 天。初始时，所有楼房都还没有开始建造，它们的高度均为 $0$。在第 $i$ 天，建筑队将会将横坐标为 $X_i$ 的房屋的高度变为 $Y_i$（高度可以比原来大—修建，也可以比原来小—拆除，甚至可以保持不变—建筑队这天什么事也没做）。请你帮小 A 数数每天在建筑队完工之后，他能看到多少栋楼房？", "inputFormat": "第一行两个正整数 $N,M$。\n\n接下来 $M$ 行，每行两个正整数 $X_i,Y_i$。", "outputFormat": "$M$ 行，第 $i$ 行一个整数表示第 $i$ 天过后小 A 能看到的楼房有多少栋。", "hint": "对于 $100\\%$ 的数据，$1 \\le X_i \\le N$，$1 \\le Y_i \\le 10^9$，$1\\le N,M \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4199", "type": "P", "difficulty": 6, "samples": [["abaabaa", "14"], ["aaabbbaaa", "44"], ["aaaaaaaa", "53"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2013", "枚举", "快速傅里叶变换 FFT", "湖北"], "title": "万径人踪灭", "background": "保先生是个好司机，总是开车带学生们上山玩。但是保先生去年开了最后一趟车后，由于一些奇奇怪怪的原因转行了。半年间，再也没有从这条路上山的人了。\n\n当 VFleaKing 再次来到这座山玩的时候，发现已经没有往日的来来往往的游人了。算了，过去保先生还在的时候，来山上玩的人，也不全是来欣赏山上的风景的。", "description": "如果机房马上要关门了，或者你急着要走，请直接跳到第六个自然段。\n\nVFleaKing 注意到了这条上山下山的土路，有些地方能欣赏到美景，有些地方则不能。把上山的道路每 $10$ cm 分为一小段，则对于每一小段，用 `a` 表示能欣赏到美景，用 `b` 表示不能欣赏到美景，就能得到一个只含 `a`、`b` 的字符串 $s$。当然由于下山和上山是一条路，所以下山的道路的字符串就是将上山的道路的字符串反过来。\n\n设上山字符串长度为 $n$，每个字符依次为 $s_1, s_2 .…, s_n$。在上山和下山的路上，VFleaKing 会选择某些小段查看旁边的景色，其他时间低头走路。即 VFleaKing 会选择 $k$ 个小段 $x_1, x_2 …x_k$，且 $k >0$，$1\\le x_1<x_2<…<x_k\\le n$，VFleaKing 上山和下山的过程中会在这些地方查看景色。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t9qpo3f9.png)\n\nVFleaKing 希望，上山下山时看到的美景的情况相同。也就是说，VFleaKing 上山时是否看到了美景的情况是： $s_{x_1},s_{x_2},\\cdots,s_{x_k}$ 记为字符序列 $T_1$，下山时是否看到了美景的情况是：$s_{x_k},s_{x_{k-1}},\\cdots,s_{x_1}$ 记为字符序列 $T_2$。VFleaKing 希望 $T_1=T_2$。\n\nVFleaKing 还希望，上山下山时查看景色的间隔相等。也就是说，上山时查看景色的间隔为：$x_2-x_1,x_3-x_2,x_k-x_{k-1}$，记为数列 $P_1$。下山时查看景色的间隔为：$x_k-x_{k-1},x_{k-1}-x_{k-2},…,x_2-x_1$，记为数列 $P_2$。VFleaKing 希望 $P_1=P_2$。\n\nVFleaKing 觉得，如果第一次查看景色和最后一次查看景色这段时间里，没有一次低头看路他就会摔倒。也就是说，如果对于所有 $1\\le i\\le k$ 都有$x_i=x_1+i- 1$，VFleaKing 就会摔倒，VFleaKing不希望发生这样的情况。\n\n就是要在一个只含 `a`、`b` 的字符串中选取一个子序列，使得:\n\n1. 位置和字符都关于某条对称轴对称。\n2. 不能是连续的一段。\n\n以 $s = \\texttt{\"abaaaaabbabbabaa\"}$ 为例。如果我们用符号 $[a_1, a_2,…,a_k]$ 表示一个序列，那么 $[1,4]$ 就是一个合法的序列 $x$，$[5,8,10,12,15]$ 也是，$[4,5,8,9,10,11,12,15,16]$ 也是。但是 $[1,2]$ 不满足 VFleaKing 第一个希望和第三个希望，所以不是。$[1,2,4]$ 不满足第二个希望，所以不是。$[9,10,11]$ 不满足第三个希望，所以不是。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6849dqla.png)\n\n给你字符串 $s$，现在 VFleaKing 想知道，有多少个合法的 $x$。答案可能很大，VFleaKing 想知道对 $1000000007$ 取模的值。", "inputFormat": "一行，一个只包含 `a`、`b` 的两种字符的字符串。", "outputFormat": "一行，一个非负整数表示问题的答案。", "hint": "## 样例解释\n\n### 样例解释 1\n\n$14$ 个方案分别是：\n\n- $[1,3]$，$[1,4]$，$[2,5]$，$[1,6]$，$[3,6]$，$[4,6]$，$[1,7]$，$[3,7]$，$[4,7]$；\n- $[1,4,7]$，$[3,5,7]$；\n- $[1,3,4,6]$，$[1,2,5,6]$，$[3,4,6,7]$。\n\n### 样例解释 2\n\n我已经想到了一个绝妙的解释，可惜方案太多，写不下了。\n\n### 样例解释 3\n\n我已经想到了一个绝妙的解释，可惜方案太多，写不下了。\n\n## 数据范围\n\n- 其中 $10\\%$ 的数据，字符串仅包含字母 `a` 或字母 `b`。\n- 另有 $20\\%$ 的数据，$n\\le 1000$。\n- 另有 $20\\%$ 的数据，要么 `a` 的个数不超过 $10$，要么 `a` 的个数不超过 $10$。\n- 另有 $10\\%$ 的数据，$n\\le 10000$。\n- 对于 $100\\%$ 的数据，$n \\le 100000$。\n\n## 来源\n\n- 2013 湖北互测 week1\n- bzoj 3160\n- 信息学奥赛之数学一本通\n- stong9070 整理\n\n", "locale": "zh-CN", "translations": {"en": {"title": "All Paths Deserted", "background": "Mr. Bao is a good driver who always drove students up the mountain for fun. But after his last trip last year, for some strange reasons, he changed careers. For half a year, no one has gone up the mountain along this road.\n\nWhen VFleaKing came back to this mountain, he found that the usual crowds of tourists were gone. Well, even when Mr. Bao was still around, not everyone coming to the mountain was there to enjoy the scenery.", "description": "If the computer room is about to close, or you are in a hurry, please skip directly to the sixth paragraph.\n\nVFleaKing noticed that along the dirt road going up and down the mountain, some places offer beautiful views while others do not. Divide the uphill road into segments of $10$ cm each. For every segment, use `a` to indicate that a nice view can be enjoyed, and `b` to indicate that it cannot. Then you get a string $s$ containing only `a` and `b`. Since going downhill uses the same road, the string for the downhill road is the reverse of the uphill string.\n\nLet the uphill string have length $n$, with characters $s_1, s_2, \\ldots, s_n$ in order. On the way up and down, VFleaKing will choose certain segments to look at the scenery, and keep his head down the rest of the time. That is, VFleaKing chooses $k$ segments $x_1, x_2, \\ldots, x_k$, where $k > 0$ and $1 \\le x_1 < x_2 < \\cdots < x_k \\le n$, and he will look at the scenery at these positions both uphill and downhill.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t9qpo3f9.png)\n\nVFleaKing wants the results of seeing scenery to be the same uphill and downhill. That is, the sequence of whether he sees scenery uphill is $s_{x_1}, s_{x_2}, \\cdots, s_{x_k}$, denoted by $T_1$, and the sequence downhill is $s_{x_k}, s_{x_{k-1}}, \\cdots, s_{x_1}$, denoted by $T_2$. VFleaKing wants $T_1 = T_2$.\n\nVFleaKing also wants the intervals between these checks to be equal uphill and downhill. That is, the uphill intervals are $x_2 - x_1, x_3 - x_2, \\ldots, x_k - x_{k-1}$, denoted by $P_1$. The downhill intervals are $x_k - x_{k-1}, x_{k-1} - x_{k-2}, \\ldots, x_2 - x_1$, denoted by $P_2$. VFleaKing wants $P_1 = P_2$.\n\nVFleaKing thinks that if, between the first and the last time he looks at the scenery, there is not a single moment when he keeps his head down, he will fall. That is, if for all $1 \\le i \\le k$ we have $x_i = x_1 + i - 1$, then VFleaKing will fall, and he does not want this to happen.\n\nIn short, select a subsequence from a string containing only `a` and `b` such that:\n\n1. Both positions and characters are symmetric about some axis.\n2. It is not a contiguous segment.\n\nTake $s = \\texttt{\"abaaaaabbabbabaa\"}$ as an example. If we use $[a_1, a_2, \\ldots, a_k]$ to denote a sequence, then $[1, 4]$ is a valid sequence $x$, $[5, 8, 10, 12, 15]$ is also valid, and $[4, 5, 8, 9, 10, 11, 12, 15, 16]$ is also valid. However, $[1, 2]$ does not satisfy VFleaKing’s first and third wishes, so it is not valid. $[1, 2, 4]$ does not satisfy the second wish, so it is not valid. $[9, 10, 11]$ does not satisfy the third wish, so it is not valid.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6849dqla.png)\n\nGiven the string $s$, VFleaKing wants to know how many valid sequences $x$ there are. The answer can be large; please output it modulo $1000000007$.", "inputFormat": "One line, a string containing only the two characters `a` and `b`.", "outputFormat": "One line, a non-negative integer representing the answer.", "hint": "Sample Explanation 1\n\nThere are $14$ valid sequences:\n\n- $[1, 3]$, $[1, 4]$, $[2, 5]$, $[1, 6]$, $[3, 6]$, $[4, 6]$, $[1, 7]$, $[3, 7]$, $[4, 7]$;\n- $[1, 4, 7]$, $[3, 5, 7]$;\n- $[1, 3, 4, 6]$, $[1, 2, 5, 6]$, $[3, 4, 6, 7]$.\n\nSample Explanation 2\n\nI have come up with a brilliant explanation, but there are too many cases to fit here.\n\nSample Explanation 3\n\nI have come up with a brilliant explanation, but there are too many cases to fit here.\n\nConstraints\n\n- For $10\\%$ of the testdata, the string contains only the letter `a` or only the letter `b`.\n- For another $20\\%$ of the testdata, $n \\le 1000$.\n- For another $20\\%$ of the testdata, either the number of `a` does not exceed $10$, or the number of `b` does not exceed $10$.\n- For another $10\\%$ of the testdata, $n \\le 10000$.\n- For $100\\%$ of the testdata, $n \\le 100000$.\n\nSource\n\n- 2013 Hubei Mutual Test week 1\n- bzoj 3160\n- A Mathematical Textbook for the Informatics Olympiad\n- Compiled by stong9070\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "万径人踪灭", "background": "保先生是个好司机，总是开车带学生们上山玩。但是保先生去年开了最后一趟车后，由于一些奇奇怪怪的原因转行了。半年间，再也没有从这条路上山的人了。\n\n当 VFleaKing 再次来到这座山玩的时候，发现已经没有往日的来来往往的游人了。算了，过去保先生还在的时候，来山上玩的人，也不全是来欣赏山上的风景的。", "description": "如果机房马上要关门了，或者你急着要走，请直接跳到第六个自然段。\n\nVFleaKing 注意到了这条上山下山的土路，有些地方能欣赏到美景，有些地方则不能。把上山的道路每 $10$ cm 分为一小段，则对于每一小段，用 `a` 表示能欣赏到美景，用 `b` 表示不能欣赏到美景，就能得到一个只含 `a`、`b` 的字符串 $s$。当然由于下山和上山是一条路，所以下山的道路的字符串就是将上山的道路的字符串反过来。\n\n设上山字符串长度为 $n$，每个字符依次为 $s_1, s_2 .…, s_n$。在上山和下山的路上，VFleaKing 会选择某些小段查看旁边的景色，其他时间低头走路。即 VFleaKing 会选择 $k$ 个小段 $x_1, x_2 …x_k$，且 $k >0$，$1\\le x_1<x_2<…<x_k\\le n$，VFleaKing 上山和下山的过程中会在这些地方查看景色。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t9qpo3f9.png)\n\nVFleaKing 希望，上山下山时看到的美景的情况相同。也就是说，VFleaKing 上山时是否看到了美景的情况是： $s_{x_1},s_{x_2},\\cdots,s_{x_k}$ 记为字符序列 $T_1$，下山时是否看到了美景的情况是：$s_{x_k},s_{x_{k-1}},\\cdots,s_{x_1}$ 记为字符序列 $T_2$。VFleaKing 希望 $T_1=T_2$。\n\nVFleaKing 还希望，上山下山时查看景色的间隔相等。也就是说，上山时查看景色的间隔为：$x_2-x_1,x_3-x_2,x_k-x_{k-1}$，记为数列 $P_1$。下山时查看景色的间隔为：$x_k-x_{k-1},x_{k-1}-x_{k-2},…,x_2-x_1$，记为数列 $P_2$。VFleaKing 希望 $P_1=P_2$。\n\nVFleaKing 觉得，如果第一次查看景色和最后一次查看景色这段时间里，没有一次低头看路他就会摔倒。也就是说，如果对于所有 $1\\le i\\le k$ 都有$x_i=x_1+i- 1$，VFleaKing 就会摔倒，VFleaKing不希望发生这样的情况。\n\n就是要在一个只含 `a`、`b` 的字符串中选取一个子序列，使得:\n\n1. 位置和字符都关于某条对称轴对称。\n2. 不能是连续的一段。\n\n以 $s = \\texttt{\"abaaaaabbabbabaa\"}$ 为例。如果我们用符号 $[a_1, a_2,…,a_k]$ 表示一个序列，那么 $[1,4]$ 就是一个合法的序列 $x$，$[5,8,10,12,15]$ 也是，$[4,5,8,9,10,11,12,15,16]$ 也是。但是 $[1,2]$ 不满足 VFleaKing 第一个希望和第三个希望，所以不是。$[1,2,4]$ 不满足第二个希望，所以不是。$[9,10,11]$ 不满足第三个希望，所以不是。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6849dqla.png)\n\n给你字符串 $s$，现在 VFleaKing 想知道，有多少个合法的 $x$。答案可能很大，VFleaKing 想知道对 $1000000007$ 取模的值。", "inputFormat": "一行，一个只包含 `a`、`b` 的两种字符的字符串。", "outputFormat": "一行，一个非负整数表示问题的答案。", "hint": "## 样例解释\n\n### 样例解释 1\n\n$14$ 个方案分别是：\n\n- $[1,3]$，$[1,4]$，$[2,5]$，$[1,6]$，$[3,6]$，$[4,6]$，$[1,7]$，$[3,7]$，$[4,7]$；\n- $[1,4,7]$，$[3,5,7]$；\n- $[1,3,4,6]$，$[1,2,5,6]$，$[3,4,6,7]$。\n\n### 样例解释 2\n\n我已经想到了一个绝妙的解释，可惜方案太多，写不下了。\n\n### 样例解释 3\n\n我已经想到了一个绝妙的解释，可惜方案太多，写不下了。\n\n## 数据范围\n\n- 其中 $10\\%$ 的数据，字符串仅包含字母 `a` 或字母 `b`。\n- 另有 $20\\%$ 的数据，$n\\le 1000$。\n- 另有 $20\\%$ 的数据，要么 `a` 的个数不超过 $10$，要么 `a` 的个数不超过 $10$。\n- 另有 $10\\%$ 的数据，$n\\le 10000$。\n- 对于 $100\\%$ 的数据，$n \\le 100000$。\n\n## 来源\n\n- 2013 湖北互测 week1\n- bzoj 3160\n- 信息学奥赛之数学一本通\n- stong9070 整理\n\n", "locale": "zh-CN"}}}
{"pid": "P4200", "type": "P", "difficulty": 6, "samples": [["5\n1 1 1\n3 1 2\n4 4 4\n2 0 1\n2 2 3\n5\n1 1 2\n2 4 4\n2 4 3\n3 0 1\n5 0 1", "3\n4\n6\n8\n8"], ["5\n1803632939 1051911108 963670239\n296082233 384714041 782958792\n1706221977 1051911108 963670239\n1890039364 -1429456864 794782986\n1152753107 1932597483 1442217530\n10\n3 -1429456864 794782986\n2 -1429456864 794782986\n4 -1429456864 794782986\n4 2062723523 -411953943\n5 -1429456864 794782986\n4 1051911108 963670239\n4 1051911108 963670239\n1 1051911108 963670239\n1 1051911108 963670239\n5 -1429456864 794782986", "1890039364\n3780078728\n3780078728\n3607265878\n3412443954"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2013", "平衡树", "湖北"], "title": "千山鸟飞绝", "background": "", "description": "话说有一天 doyouloveme 和 vfleaking 到山里玩。谁知 doyouloveme 刚刚进山，所有的鸟儿竟被他的神犇气场给惊得全部飞走了。vfleaking 顿时膜拜不已。\n\n这时鸟王用鸟语说道：「!@#\\$%…?」，安抚了一下众鸟的情绪。鸟王生性好斗，作出了一个决定：要排鸟布阵把刚才吓到它们的人类赶出山去。\n\n每只鸟都有一个编号，都有一个威武值。每秒钟鸟王都会发一个命令，编号为 $v$ 的鸟飞到 $(x,y)$ 去（坐标系原点是山顶，坐标单位为鸟爪）。鸟飞得很快，一秒之内就飞到了，可以看作是瞬间移动。如果编号为 $v$ 的鸟和编号为 $u$ 的鸟某一时刻处在同一位置，它们就会互相鼓励，增加各自的士气值和团结值。一只鸟的士气值等于此刻与它处在同一位置的鸟中的威武值的最大值，团结值等于此刻与它处在同一位置的鸟的只数。如果每一时刻都没有鸟与它处在同一位置，则士气值和团结值都为 $0$。要注意自己不能鼓励自己，计算士气值和团结值时不能算上自己。\n\n$t$ 秒钟后，doyouloveme 目测出了现在每只鸟的战斗力，于是感叹了一句：「不妙，我们得走了。」\n\n正所谓团结的鸟儿一个顶俩，所以 doyouloveme 这样描述战斗力：一只鸟战斗力值等于它在 $0$ 到 $t$ 秒中士气值的最大值与团结值的最大值的乘积。注意不是乘积的最大值，而是最大值的乘积。\n\nvfleaking 很想知道现在每只鸟的战斗力，但是他当然不会啦，于是他把这个任务交给了你来完成。\n", "inputFormat": "第一行一个整数 $n$，代表鸟的只数。（鸟王那家伙你可以完全忽视掉）\n\n接下来 $n$ 行，每行三个整数 $w,x,y$ 描述每只鸟的威武值和初始坐标。第 $i+1$ 行描述编号为i的鸟。\n\n接下来一行有一个整数 $t$，代表经过时间 $t$ 秒。\n\n接下来 $t$ 行，每行三个整数 $v,x,y$ 描述鸟王每秒的命令。\n", "outputFormat": "一共 $n$ 行，每行一个数，代表每只鸟的战斗力。", "hint": "对于 $100\\%$ 的数据，$1≤n≤30000$，$0≤t≤300000$，坐标为整数，均在 $[-2^{31},2^{31})$ 内。\n\n威武值为不超过 $2^{31}-1$ 的非负整数。", "locale": "zh-CN", "translations": {"en": {"title": "Across a Thousand Mountains, No Birds in Flight", "background": "", "description": "One day, doyouloveme and vfleaking went to play in the mountains. As soon as doyouloveme entered, all the birds were startled by his \"shen niu\" (shen niu, divine-cow, slang for an awesome person) aura and flew away. vfleaking immediately bowed in awe.\n\nThen the bird king said in birdspeak: 「!@#\\$%…?」, calming the flock. Being naturally combative, the bird king made a decision: line up the birds in formation to drive the humans who had just scared them out of the mountains.\n\nEach bird has an ID and a might value. Every second, the bird king issues a command: the bird with ID $v$ flies to $(x, y)$ (the origin of the coordinate system is the mountain peak, and the unit of length is a bird claw). Birds fly very fast and arrive within the same second; you can think of it as teleportation. If at any moment the bird with ID $v$ and the bird with ID $u$ are at the same position, they encourage each other, increasing their morale value and unity value. A bird’s morale value at that moment is the maximum might value among the birds at the same position as it at that moment, and its unity value is the number of birds at the same position as it at that moment. If at every moment no bird is at the same position as it, then both the morale value and the unity value are $0$. Note that a bird cannot encourage itself; when computing morale and unity, do not include itself.\n\nAfter $t$ seconds, doyouloveme eyeballed the current combat power of each bird and sighed, “Not good, we have to go.”\n\nAs the saying goes, united birds count for two, so doyouloveme describes combat power like this: a bird’s combat power equals the product of its maximum morale value over seconds $0$ to $t$ and its maximum unity value over seconds $0$ to $t$. Note: it is not the maximum of the product, but the product of the maxima.\n\nvfleaking wants to know the combat power of every bird, but of course he can’t compute it, so he’s handed the task to you.", "inputFormat": "The first line contains an integer $n$, the number of birds. (You can completely ignore that fellow, the bird king.)\n\nThe next $n$ lines each contain three integers $w, x, y$, describing each bird’s might value and initial coordinates. Line $i + 1$ describes the bird with ID $i$.\n\nThe next line contains an integer $t$, the number of seconds that have elapsed.\n\nThe next $t$ lines each contain three integers $v, x, y$, describing the bird king’s command for each second.", "outputFormat": "Output $n$ lines. Each line contains one number: the combat power of the corresponding bird.", "hint": "Constraints:\n\n- For $100\\%$ of the testdata, $1 \\le n \\le 30000$, $0 \\le t \\le 300000$. Coordinates are integers and lie in $[-2^{31}, 2^{31})$.\n- Might values are non-negative integers not exceeding $2^{31} - 1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "千山鸟飞绝", "background": "", "description": "话说有一天 doyouloveme 和 vfleaking 到山里玩。谁知 doyouloveme 刚刚进山，所有的鸟儿竟被他的神犇气场给惊得全部飞走了。vfleaking 顿时膜拜不已。\n\n这时鸟王用鸟语说道：「!@#\\$%…?」，安抚了一下众鸟的情绪。鸟王生性好斗，作出了一个决定：要排鸟布阵把刚才吓到它们的人类赶出山去。\n\n每只鸟都有一个编号，都有一个威武值。每秒钟鸟王都会发一个命令，编号为 $v$ 的鸟飞到 $(x,y)$ 去（坐标系原点是山顶，坐标单位为鸟爪）。鸟飞得很快，一秒之内就飞到了，可以看作是瞬间移动。如果编号为 $v$ 的鸟和编号为 $u$ 的鸟某一时刻处在同一位置，它们就会互相鼓励，增加各自的士气值和团结值。一只鸟的士气值等于此刻与它处在同一位置的鸟中的威武值的最大值，团结值等于此刻与它处在同一位置的鸟的只数。如果每一时刻都没有鸟与它处在同一位置，则士气值和团结值都为 $0$。要注意自己不能鼓励自己，计算士气值和团结值时不能算上自己。\n\n$t$ 秒钟后，doyouloveme 目测出了现在每只鸟的战斗力，于是感叹了一句：「不妙，我们得走了。」\n\n正所谓团结的鸟儿一个顶俩，所以 doyouloveme 这样描述战斗力：一只鸟战斗力值等于它在 $0$ 到 $t$ 秒中士气值的最大值与团结值的最大值的乘积。注意不是乘积的最大值，而是最大值的乘积。\n\nvfleaking 很想知道现在每只鸟的战斗力，但是他当然不会啦，于是他把这个任务交给了你来完成。\n", "inputFormat": "第一行一个整数 $n$，代表鸟的只数。（鸟王那家伙你可以完全忽视掉）\n\n接下来 $n$ 行，每行三个整数 $w,x,y$ 描述每只鸟的威武值和初始坐标。第 $i+1$ 行描述编号为i的鸟。\n\n接下来一行有一个整数 $t$，代表经过时间 $t$ 秒。\n\n接下来 $t$ 行，每行三个整数 $v,x,y$ 描述鸟王每秒的命令。\n", "outputFormat": "一共 $n$ 行，每行一个数，代表每只鸟的战斗力。", "hint": "对于 $100\\%$ 的数据，$1≤n≤30000$，$0≤t≤300000$，坐标为整数，均在 $[-2^{31},2^{31})$ 内。\n\n威武值为不超过 $2^{31}-1$ 的非负整数。", "locale": "zh-CN"}}}
{"pid": "P4201", "type": "P", "difficulty": 5, "samples": [["5 4 100 \n1 2 \n4 5 \n1 3 \n4 1", "1 \n10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "NOI"], "title": "[NOI2008] 设计路线", "background": "", "description": "Z 国坐落于遥远而又神奇的东方半岛上，在小 Z 的统治时代公路成为这里主要的交通手段。Z 国共有 $N$ 座城市，一些城市之间由双向的公路所连接。非常神奇的是 Z 国的每个城市所处的经度都不相同，并且最多只和一个位于它东边的城市直接通过公路相连。Z 国的首都是 Z 国政治经济文化旅游的中心，每天都有成千上万的人从 Z 国的其他城市涌向首都。\n\n为了使 Z 国的交通更加便利顺畅，小 Z 决定在 Z 国的公路系统中确定若干条规划路线，将其中的公路全部改建为铁路。\n\n我们定义每条规划路线为一个长度大于 $1$ 的城市序列，每个城市在该序列中最多出现一次，序列中相邻的城市之间由公路直接相连（待改建为铁路）。并且，每个城市最多只能出现在一条规划路线中，也就是说，任意两条规划路线不能有公共部分。\n\n当然在一般情况下是不可能将所有的公路修建为铁路的，因此从有些城市出发去往首都依然需要通过乘坐长途汽车，而长途汽车只往返于公路连接的相邻的城市之间，因此从某个城市出发可能需要不断地换乘长途汽车和火车才能到达首都。\n\n我们定义一个城市的“不便利值”为从它出发到首都需要乘坐的长途汽车的次数，而 Z 国的交通系统的“不便利值”为所有城市的不便利值的最大值，很明显首都的“不便利值”为 $0$。小 Z 想知道如何确定规划路线修建铁路使得 Z 国的交通系统的“不便利值”最小，以及有多少种不同的规划路线的选择方案使得“不便利值”达到最小。当然方案总数可能非常大，小 Z 只关心这个天文数字 $\\bmod\\ Q$ 后的值。\n\n注意：规划路线 $1-2-3$ 和规划路线 $3-2-1$ 是等价的，即将一条规划路线翻转，依然认为是等价的。两个方案不同当且仅当其中一个方案中存在一条规划路线不属于另一个方案。\n\n", "inputFormat": "第一行包含三个正整数 $N,M,Q$，其中 $N$ 表示城市个数， $M$ 表示公路总数，$N$ 个城市从 $1 \\sim N$ 编号，其中编号为 $1$ 的是首都。$Q$ 表示上文提到的设计路线的方法总数的模数。\n\n接下来 $M$ 行，每行两个不同的整数 $a_i,b_i(1 \\le a_i,b_i \\le N)$，表示有一条公路连接城市 $a_i$ 和城市 $b_i$。\n\n输入数据保证一条公路只出现一次。", "outputFormat": "应包含两行。\n\n第 $1$ 行为一个整数，表示最小的“不便利值”。\n\n第 $2$ 行为一个整数，表示使“不便利值”达到最小时不同的设计路线的方法总数 $\\bmod\\ Q$ 的值。\n\n如果某个城市无法到达首都，则输出两行 $-1$。", "hint": "对于 $20 \\%$ 的数据，$1 \\le N,M \\le 10$。\n\n对于 $50 \\%$ 的数据，$1 \\le N,M \\le 200$。\n\n对于 $60 \\%$ 的数据，$1 \\le N,M \\le 5000$。\n\n对于 $100 \\%$ 的数据，$1 \\le N,M \\le 10 ^ 5$，$1 \\le Q \\le 1.2 \\times 10 ^ 8$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2008] Designing Routes", "background": "", "description": "Country Z lies on a distant and magical eastern peninsula. During the reign of Xiao Z, highways became the main mode of transportation. There are $N$ cities in Country Z, and some pairs of cities are connected by bidirectional highways. Remarkably, each city has a unique longitude, and each city is directly connected by highway to at most one city located to its east. The capital is the political, economic, cultural, and tourism center of Country Z, and every day thousands of people flow into the capital from other cities.\n\nTo make transportation more convenient and efficient, Xiao Z decides to designate several planned routes in the highway system and rebuild all highways on these routes into railways.\n\nWe define each planned route as a city sequence of length strictly greater than $1$, where each city appears at most once in the sequence, and each pair of adjacent cities in the sequence is directly connected by a highway (to be rebuilt into railway). Moreover, each city can appear in at most one planned route, i.e., any two planned routes must be vertex-disjoint.\n\nOf course, in general it is impossible to rebuild all highways into railways, so traveling from some cities to the capital still requires taking long-distance buses. Long-distance buses only run between adjacent cities that are connected by a highway, so starting from a given city, one may need to alternate between taking buses and trains to reach the capital.\n\nWe define the “inconvenience value” of a city as the number of times one must take a long-distance bus to reach the capital from that city. The “inconvenience value” of the transportation system is the maximum inconvenience value over all cities. Clearly, the capital’s inconvenience value is $0$. Xiao Z wants to know how to choose planned routes to minimize the system’s inconvenience value, and how many different choices of planned routes achieve this minimum. Since the total number of plans may be huge, Xiao Z only cares about this astronomical number modulo $Q$.\n\nNote: A planned route $1-2-3$ is equivalent to $3-2-1$, i.e., reversing a planned route is considered the same. Two plans are different if and only if there exists a planned route that appears in one plan but not in the other.", "inputFormat": "The first line contains three positive integers $N, M, Q$, where $N$ is the number of cities, $M$ is the number of highways, and the cities are numbered from $1$ to $N$, with city $1$ being the capital. $Q$ is the modulus mentioned above for the number of route-design methods.\n\nEach of the next $M$ lines contains two distinct integers $a_i, b_i$ ($1 \\le a_i, b_i \\le N$), indicating that there is a highway connecting city $a_i$ and city $b_i$.\n\nThe input guarantees that each highway appears exactly once.", "outputFormat": "Output two lines.\n\nThe first line contains one integer: the minimal “inconvenience value.”\n\nThe second line contains one integer: the number of different route-design methods that achieve the minimal “inconvenience value,” modulo $Q$.\n\nIf some city cannot reach the capital, output two lines, each containing $-1$.", "hint": "For $20\\%$ of the testdata, $1 \\le N, M \\le 10$.\n\nFor $50\\%$ of the testdata, $1 \\le N, M \\le 200$.\n\nFor $60\\%$ of the testdata, $1 \\le N, M \\le 5000$.\n\nFor $100\\%$ of the testdata, $1 \\le N, M \\le 10^5$, $1 \\le Q \\le 1.2 \\times 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2008] 设计路线", "background": "", "description": "Z 国坐落于遥远而又神奇的东方半岛上，在小 Z 的统治时代公路成为这里主要的交通手段。Z 国共有 $N$ 座城市，一些城市之间由双向的公路所连接。非常神奇的是 Z 国的每个城市所处的经度都不相同，并且最多只和一个位于它东边的城市直接通过公路相连。Z 国的首都是 Z 国政治经济文化旅游的中心，每天都有成千上万的人从 Z 国的其他城市涌向首都。\n\n为了使 Z 国的交通更加便利顺畅，小 Z 决定在 Z 国的公路系统中确定若干条规划路线，将其中的公路全部改建为铁路。\n\n我们定义每条规划路线为一个长度大于 $1$ 的城市序列，每个城市在该序列中最多出现一次，序列中相邻的城市之间由公路直接相连（待改建为铁路）。并且，每个城市最多只能出现在一条规划路线中，也就是说，任意两条规划路线不能有公共部分。\n\n当然在一般情况下是不可能将所有的公路修建为铁路的，因此从有些城市出发去往首都依然需要通过乘坐长途汽车，而长途汽车只往返于公路连接的相邻的城市之间，因此从某个城市出发可能需要不断地换乘长途汽车和火车才能到达首都。\n\n我们定义一个城市的“不便利值”为从它出发到首都需要乘坐的长途汽车的次数，而 Z 国的交通系统的“不便利值”为所有城市的不便利值的最大值，很明显首都的“不便利值”为 $0$。小 Z 想知道如何确定规划路线修建铁路使得 Z 国的交通系统的“不便利值”最小，以及有多少种不同的规划路线的选择方案使得“不便利值”达到最小。当然方案总数可能非常大，小 Z 只关心这个天文数字 $\\bmod\\ Q$ 后的值。\n\n注意：规划路线 $1-2-3$ 和规划路线 $3-2-1$ 是等价的，即将一条规划路线翻转，依然认为是等价的。两个方案不同当且仅当其中一个方案中存在一条规划路线不属于另一个方案。\n\n", "inputFormat": "第一行包含三个正整数 $N,M,Q$，其中 $N$ 表示城市个数， $M$ 表示公路总数，$N$ 个城市从 $1 \\sim N$ 编号，其中编号为 $1$ 的是首都。$Q$ 表示上文提到的设计路线的方法总数的模数。\n\n接下来 $M$ 行，每行两个不同的整数 $a_i,b_i(1 \\le a_i,b_i \\le N)$，表示有一条公路连接城市 $a_i$ 和城市 $b_i$。\n\n输入数据保证一条公路只出现一次。", "outputFormat": "应包含两行。\n\n第 $1$ 行为一个整数，表示最小的“不便利值”。\n\n第 $2$ 行为一个整数，表示使“不便利值”达到最小时不同的设计路线的方法总数 $\\bmod\\ Q$ 的值。\n\n如果某个城市无法到达首都，则输出两行 $-1$。", "hint": "对于 $20 \\%$ 的数据，$1 \\le N,M \\le 10$。\n\n对于 $50 \\%$ 的数据，$1 \\le N,M \\le 200$。\n\n对于 $60 \\%$ 的数据，$1 \\le N,M \\le 5000$。\n\n对于 $100 \\%$ 的数据，$1 \\le N,M \\le 10 ^ 5$，$1 \\le Q \\le 1.2 \\times 10 ^ 8$。", "locale": "zh-CN"}}}
{"pid": "P4202", "type": "P", "difficulty": 7, "samples": [["4 1 0.5  \n2 3 1 3 \n10.0 10.0 10.0 10.0", "30.00 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "NOI"], "title": "[NOI2008] 奥运物流", "background": "", "description": "2008 北京奥运会即将开幕，举国上下都在为这一盛事做好准备。为了高效率、 成功地举办奥运会，对物流系统进行规划是必不可少的。\n\n物流系统由若干物流基站组成，以 $1$ 到 $n$ 进行编号。每个物流基站 $i$ 都有且仅有一个后继基站 $S_i$，而可以有多个前驱基站。基站 $i$ 中需要继续运输的物资都将被运往后继基站 $S_i$，显然一个物流基站的后继基站不能是其本身。编号为 $1$ 的 物流基站称为控制基站，从任何物流基站都可将物资运往控制基站。注意控制基站也有后继基站，以便在需要时进行物资的流通。在物流系统中，高可靠性与低成本是主要设计目的。对于基站 $i$，我们定义其“可靠性” $R(i)$ 如下： \n设物流基站 $i$ 有 $w$ 个前驱基站 $P_1,P_2,\\cdots,P_w$，即这些基站以 $i$ 为后继基站，则基 站 $i$ 的可靠性 $R(i)$ 满足下式： \n$$R(i)=C_i+k \\sum_{j=1}^{w}R(P_j).$$\n\n其中 $C_i$ 和 $k$ 都是常实数且恒为正，且有 $k$ 小于 $1$。\n\n整个系统的可靠性与控制基站的可靠性正相关，我们的目标是通过修改物流系统，即更改某些基站的后继基站，使得控制基站的可靠性 $R(1)$ 尽量大。但由于经费限制，最多只能修改 $m$ 个基站的后继基站，并且，控制基站的后继基站不可被修改。因而我们所面临的问题就是，如何修改不超过 $m$ 个基站的后继，使得控制基站的可靠性 $R(1)$ 最大化。\n", "inputFormat": "第一行包含两个整数与一个实数，$n,m,k$。其中 $n$ 表示基站数目，$m$ 表示最多可修改的后继基站数目，$k$ 分别为可靠性定义中的常数。\n\n第二行包含 $n$ 个整数，分别是 $S_1,S_2\\cdots,S_n$，即每一个基站的后继基站编号。\n\n第三行包含 $n$ 个正实数，分别是 $C_1,C_2\\cdots,C_n$，为可靠性定义中的常数。", "outputFormat": "仅包含一个实数，为可得到的最大 $R(1)$。精确到小数点两位。", "hint": "【样例说明】 \n原有物流系统如左图所示，$4$ 个物流基站的可靠性依次为 $22.8571,21.4286,25.7143,10$。\n\n最优方案为将 $2$ 号基站的后继基站改为 $1$ 号。\n\n此时 $4$ 个基站的可靠性依次为 $30,25,15,10$。\n本题的数据，具有如下分布： \n\n测试数据编号| $n$ | $m$\n:-:|:-:|:-:\n$1$|$\\leq6$| $\\leq6$\n$2$|$\\leq12$|$\\leq12$\n$3$|$\\leq60$|$0$\n$4$|$\\leq60$|$1$\n$5$|$\\leq 60$|$N-2$\n$6,7,8,9,10$|$\\leq60$|$\\leq60$\n\n 对于所有的数据，满足 $m \\leq n \\leq 60$，$C_i \\leq 10^6$，$0.3 \\leq k < 1$，请使用双精度实数，无需考虑由此带来的误差。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2008] Olympic Logistics", "background": "", "description": "The 2008 Beijing Olympic Games are about to open, and the whole country is preparing for this grand event. To hold the Games efficiently and successfully, it is essential to plan the logistics system.\n\nThe logistics system consists of several logistics base stations, numbered from $1$ to $n$. Each logistics base station $i$ has exactly one successor station $S_i$, and may have multiple predecessor stations. All goods at station $i$ that need to continue transportation will be sent to its successor station $S_i$. Obviously, a station cannot be its own successor. Station $1$ is called the control station, and goods can be sent from any station to the control station. Note that the control station also has a successor station, so that circulation is possible when needed. In the logistics system, high reliability and low cost are the main design goals. For station $i$, we define its “reliability” $R(i)$ as follows:\nSuppose station $i$ has $w$ predecessor stations $P_1, P_2, \\cdots, P_w$, i.e., these stations take $i$ as their successor station, then the reliability $R(i)$ of station $i$ satisfies:\n$$R(i)=C_i+k \\sum_{j=1}^{w}R(P_j).$$\n\nHere $C_i$ and $k$ are fixed positive real numbers, and $k$ is less than $1$.\n\nThe overall system reliability is positively correlated with the reliability of the control station. Our goal is to modify the logistics system—i.e., change the successors of some stations—so that the reliability $R(1)$ of the control station is as large as possible. Due to budget constraints, at most $m$ stations’ successors can be modified, and the successor of the control station cannot be modified. Therefore, the problem is: how to modify the successors of no more than $m$ stations to maximize the reliability $R(1)$ of the control station.", "inputFormat": "The first line contains two integers and a real number, $n, m, k$. Here $n$ is the number of stations, $m$ is the maximum number of successor changes allowed, and $k$ is the constant in the reliability definition.\n\nThe second line contains $n$ integers, $S_1, S_2 \\cdots S_n$, the successor station index of each station.\n\nThe third line contains $n$ positive real numbers, $C_1, C_2 \\cdots C_n$, the constants in the reliability definition.", "outputFormat": "Output a single real number: the maximum achievable $R(1)$. Round to two decimal places.", "hint": "[Sample explanation]\nIn the original logistics system (as shown in the left figure), the reliabilities of the $4$ stations are $22.8571, 21.4286, 25.7143, 10$ in order.\n\nThe optimal plan is to change the successor of station $2$ to station $1$.\n\nThen the reliabilities of the $4$ stations become $30, 25, 15, 10$ in order.\nThe testdata is distributed as follows:\n\n测试数据编号| $n$ | $m$\n:-:|:-:|:-:\n$1$|$\\leq 6$|$\\leq 6$\n$2$|$\\leq 12$|$\\leq 12$\n$3$|$\\leq 60$|$0$\n$4$|$\\leq 60$|$1$\n$5$|$\\leq 60$|$n-2$\n$6, 7, 8, 9, 10$|$\\leq 60$|$\\leq 60$\n\nFor all testdata, $m \\leq n \\leq 60$, $C_i \\leq 10^6$, $0.3 \\leq k < 1$. Please use double-precision floating-point numbers; you do not need to worry about the error introduced.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2008] 奥运物流", "background": "", "description": "2008 北京奥运会即将开幕，举国上下都在为这一盛事做好准备。为了高效率、 成功地举办奥运会，对物流系统进行规划是必不可少的。\n\n物流系统由若干物流基站组成，以 $1$ 到 $n$ 进行编号。每个物流基站 $i$ 都有且仅有一个后继基站 $S_i$，而可以有多个前驱基站。基站 $i$ 中需要继续运输的物资都将被运往后继基站 $S_i$，显然一个物流基站的后继基站不能是其本身。编号为 $1$ 的 物流基站称为控制基站，从任何物流基站都可将物资运往控制基站。注意控制基站也有后继基站，以便在需要时进行物资的流通。在物流系统中，高可靠性与低成本是主要设计目的。对于基站 $i$，我们定义其“可靠性” $R(i)$ 如下： \n设物流基站 $i$ 有 $w$ 个前驱基站 $P_1,P_2,\\cdots,P_w$，即这些基站以 $i$ 为后继基站，则基 站 $i$ 的可靠性 $R(i)$ 满足下式： \n$$R(i)=C_i+k \\sum_{j=1}^{w}R(P_j).$$\n\n其中 $C_i$ 和 $k$ 都是常实数且恒为正，且有 $k$ 小于 $1$。\n\n整个系统的可靠性与控制基站的可靠性正相关，我们的目标是通过修改物流系统，即更改某些基站的后继基站，使得控制基站的可靠性 $R(1)$ 尽量大。但由于经费限制，最多只能修改 $m$ 个基站的后继基站，并且，控制基站的后继基站不可被修改。因而我们所面临的问题就是，如何修改不超过 $m$ 个基站的后继，使得控制基站的可靠性 $R(1)$ 最大化。\n", "inputFormat": "第一行包含两个整数与一个实数，$n,m,k$。其中 $n$ 表示基站数目，$m$ 表示最多可修改的后继基站数目，$k$ 分别为可靠性定义中的常数。\n\n第二行包含 $n$ 个整数，分别是 $S_1,S_2\\cdots,S_n$，即每一个基站的后继基站编号。\n\n第三行包含 $n$ 个正实数，分别是 $C_1,C_2\\cdots,C_n$，为可靠性定义中的常数。", "outputFormat": "仅包含一个实数，为可得到的最大 $R(1)$。精确到小数点两位。", "hint": "【样例说明】 \n原有物流系统如左图所示，$4$ 个物流基站的可靠性依次为 $22.8571,21.4286,25.7143,10$。\n\n最优方案为将 $2$ 号基站的后继基站改为 $1$ 号。\n\n此时 $4$ 个基站的可靠性依次为 $30,25,15,10$。\n本题的数据，具有如下分布： \n\n测试数据编号| $n$ | $m$\n:-:|:-:|:-:\n$1$|$\\leq6$| $\\leq6$\n$2$|$\\leq12$|$\\leq12$\n$3$|$\\leq60$|$0$\n$4$|$\\leq60$|$1$\n$5$|$\\leq 60$|$N-2$\n$6,7,8,9,10$|$\\leq60$|$\\leq60$\n\n 对于所有的数据，满足 $m \\leq n \\leq 60$，$C_i \\leq 10^6$，$0.3 \\leq k < 1$，请使用双精度实数，无需考虑由此带来的误差。", "locale": "zh-CN"}}}
{"pid": "P4203", "type": "P", "difficulty": 6, "samples": [["10 10 \n1 0 10 1 3 -1 \n2 1 0 0 \n2 11 0 10 \n2 11 0 9 \n1 11 13 4 7 1 \n2 13 9 9 \n2 13 10 10 \n3 100 13 \n3 1999999999 10 \n1 2000000000 10 0 1 1", "1 \n1 \n0 \n2 \n1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "NOI"], "title": "[NOI2008] 糖果雨", "background": "", "description": "有一个美丽的童话：在天空的尽头有一个\"糖果国\"，这里大到摩天大厦，小 到小花小草都是用糖果建造而成的。更加神奇的是，天空中飘满了五颜六色的糖 果云，很快糖果雨密密麻麻从天而落，红色的是草莓糖，黄色的是柠檬糖，绿色 的是薄荷糖，黑色的是巧克力糖……这时糖果国的小朋友们便会拿出大大小小的 口袋来接天空中落下的糖果，拿回去与朋友们一起分享。\n\n对糖果情有独钟的小 Z 憧憬着能够来到这样一个童话的国度。所谓日有所 思，夜有所梦，这天晚上小 Z 梦见自己来到了\"糖果国\"。他惊喜地发现，任何时 候天空中所有的云朵颜色都不相同，不同颜色的云朵在不断地落下相应颜色的糖 果。更加有趣的是所有的云朵都在做着匀速往返运动，不妨想象天空是有边界的， 而所有的云朵恰好在两个边界之间做着往返运动。每一个单位时间云朵向左或向 右运动一个单位，当云朵的左界碰到天空的左界，它会改变方向向右运动；当云 朵完全移出了天空的右界，它会改变方向向左运动。\n\n我们不妨把天空想象为一个平面直角坐标系，而云朵则抽象为线段(线段可 能退化为点)： \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hsdveny3.png)\n\n如上图，不妨设天空的左界为 0，右界为 len。图中共有 5 片云朵，其中标 号为 1 的云朵恰好改变方向向右运动，标号为 2 的云朵恰好改变方向向左运动。\n\n忽略云朵的纵坐标，它们在运动过程中不会相互影响。\n\n小 Z 发现天空中会不断出现一些云朵(某个时刻从某个初始位置开始朝某个 方向运动)，而有的云朵运动到一定时刻就会从天空中消失，而在运动的过程中 糖果在不断地下落。小 Z 决定拿很多口袋来接糖果，口袋容量是无限的，但袋 口大小却是有限的。例如在时刻 T 小 Z 拿一个横坐标范围为[L, R]的口袋来接糖 果，如果[L, R]存在一个位置 x，该位置有某种颜色的糖果落下，则认为该口袋可 接到此种颜色的糖果。极端情况下，袋口区间可能是一个点，譬如[0,0]、[1,1]，但仍然可以接到相应位置的糖果。通常可以接到的糖果总数会很大，因而小 Z 想知道每一次(即拿出口袋的一瞬间)他的口袋可以接到多少种不同颜色的糖果。\n\n糖果下落的时间忽略不计。", "inputFormat": "输入文件第一行有两个正整数 n, len，分别表示事件总数以及天空 的“边界”。\n\n    接下来 n 行每行描述一个事件，所有的事件按照输入顺序依次发生。每行的 第一个数 k（k = 1，2，3）分别表示事件的类型，分别对应三种事件：插入事件， 询问事件以及删除事件。输入格式如下： \n\n事件类型|输入格式|说明 \n-|-|-\n插入事件 (天空中出现了一片 云朵)|`1 Ti Ci Li Ri Di`|时刻 Ti，天空中出现了一片 坐标范围为[Li, Ri]，颜色为 Ci的 云朵，初始的时候云朵运动方向 为向左(Di = -1)或向右(Di = 1)。满足 0 ≤ Li ≤ Ri ≤ len，Di = -1 或 1。数据保证任何时刻空中不 会出现两片颜色相同的云朵。\n询问事件 (询问一个口袋可以 接到多少种不同颜 色的糖果)|`2 Ti Li Ri` |时刻 Ti，小 Z 用一个坐标范 围为[Li, Ri]的大口袋去接糖果， 询问可以接到多少种不同的糖 果。满足 0 ≤ Li ≤ Ri ≤ len。\n删除事件 (天空中一片云朵消 失了)|`3 Ti Ci` |时刻 Ti，颜色为 Ci的云朵从 天空消失中。数据保证当前天空 中一定存在一片颜色为 Ci的云 朵。", "outputFormat": "对于每一个询问事件，输出中应包含相应的一行，为该次询 问的答案，即口袋可以接到多少种不同的糖果。", "hint": "【样例说明】 \n\n共 10 个事件，包括 3 个插入事件，5 个询问事件以及 2 个删除事件。\n\n时刻 0，天空中出现一片颜色为 10 的云朵，初始位置为[1, 3]，方向向左。\n\n时刻 1，范围为[0, 0]的口袋可以接到颜色为 10 的糖果(云朵位置为[0, 2])。\n\n 时刻11，范围为[0,10]的口袋可以接到颜色为10的糖果(云朵位置为[10, 12])。\n 时刻 11，范围为[0, 9]的口袋不能接到颜色为 10 的糖果(云朵位置为[10, 12])。\n 时刻 11, 天空中出现一片颜色为 13 的云朵, 初始位置为[4, 7], 方向向右。\n\n时刻 13，范围为[9, 9]的口袋可以接到颜色为 10(云朵的位置为[8, 10])和颜色 为 13(云朵的位置为[6, 9])两种不同的糖果。\n\n时刻 13，范围为[10, 10]的口袋仅仅可以接到颜色为 10 的一种糖果(云朵的位 置为[8, 10])，而不可以接到颜色为 13 的糖果(云朵的位置为[6, 9]),。\n\n时刻 100, 颜色为 13 的云朵从天空中消失。\n\n时刻 1999999999，颜色为 10 的云朵从天空中消失。\n\n时刻 2000000000，天空中又出现一片颜色为 10 的云朵，初始位置为[0, 1]， 方向向右。\n\n【数据范围】\n\n对于所有的数据，0 ≤ Ti ≤ 2000000000，1 ≤ Ci ≤ 1000000。\n\n数据保证{Ti}为非递减序列即 T1 ≤ T2 ≤ … ≤ Tn-1 ≤ Tn。\n\n对于所有的插入事件，令 Pi = Ri – Li，即 Pi表示每片云朵的长度。\n\n\n数据编号|n|len|Pi|数据编号|n|len|Pi\n-|-|-|-|-|-|-|-\n1|20|10|≤len|6|150000|1000|≤3\n2|200|100|≤len|7|200000|1000|≤3\n3|2000|1000|≤len|8|100000|1000|≤len\n4|100000|10|≤len|9|150000|1000|≤len\n5|100000|100|≤2|10|200000|1000|≤len\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2008] Candy Rain", "background": "", "description": "There is a beautiful fairy tale: at the end of the sky lies a “Candy Kingdom,” where everything from skyscrapers to tiny flowers and grass is made of candy. Even more magical, the sky is filled with colorful candy clouds, and soon a dense candy rain falls from above: red for strawberry candy, yellow for lemon candy, green for mint candy, black for chocolate candy… At these times, the children of the Candy Kingdom take out bags of all sizes to catch the candies falling from the sky and bring them back to share with their friends.\n\nZ, who loves candies, dreams of visiting such a fairy-tale land. As the saying goes, what you think about during the day comes to you in your dreams at night. One night, Z dreamed that he arrived at the “Candy Kingdom.” To his surprise, at any moment, all clouds in the sky have distinct colors, and each cloud keeps dropping candies of its own color. Even more interestingly, all clouds are moving back and forth at a uniform speed. Imagine the sky has boundaries, and all clouds perform back-and-forth motion exactly between the two boundaries. In each unit of time, a cloud moves one unit to the left or right. When the left edge of a cloud touches the left boundary of the sky, it reverses direction and moves right; when the cloud has completely moved out beyond the right boundary of the sky, it reverses direction and moves left.\n\nWe can imagine the sky as a 2D Cartesian plane, and each cloud as a line segment (possibly degenerated to a point):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hsdveny3.png)\n\nAs shown above, let the left boundary of the sky be 0 and the right boundary be $len$. There are 5 clouds in total. The cloud labeled 1 is just reversing to move right, and the cloud labeled 2 is just reversing to move left.\n\nIgnore the vertical coordinates of clouds; they do not affect each other during motion.\n\nZ notices that clouds may appear in the sky over time (starting at some initial position and moving in some direction), and some clouds may disappear after some time, while candies keep falling during their motion. Z decides to use many bags to catch candies. Each bag has infinite capacity but a finite opening width. For example, at time $T$, if Z uses a bag covering the $x$-coordinate interval $[L, R]$ to catch candies, and if there exists a position $x \\in [L, R]$ where candies of some color are falling at that instant, then the bag is considered to be able to catch candies of that color. In extreme cases, the interval of the bag opening may degenerate to a point, such as $[0, 0]$ or $[1, 1]$, but it can still catch candies at the corresponding position. Since the total number of candies that can be caught is usually very large, Z wants to know, at each moment he takes out a bag (i.e., at the instant of querying), how many distinct colors of candies his bag can catch.\n\nThe falling time of candies is negligible.", "inputFormat": "The first line contains two positive integers $n$, $len$, denoting the total number of events and the sky’s “boundary.”\n\nThen there are $n$ lines, each describing an event. All events occur in the order given. The first number $k$ on each line ($k \\in \\{1, 2, 3\\}$) denotes the event type: insertion, query, or deletion. The formats are as follows:\n\nEvent type|Input format|Explanation\n-|-|-\nInsertion (a cloud appears in the sky)|`1 Ti Ci Li Ri Di`|At time $T_i$, a cloud appears with coordinate range $[L_i, R_i]$, color $C_i$, and initial direction left ($D_i = -1$) or right ($D_i = 1$). It holds that $0 \\le L_i \\le R_i \\le len$, $D_i \\in \\{-1, 1\\}$. It is guaranteed that at any moment, there will not be two clouds with the same color in the sky.\nQuery (ask how many distinct colors a bag can catch)|`2 Ti Li Ri`|At time $T_i$, Z uses a bag covering the interval $[L_i, R_i]$ to catch candies and asks how many distinct colors can be caught. It holds that $0 \\le L_i \\le R_i \\le len$.\nDeletion (a cloud disappears from the sky)|`3 Ti Ci`|At time $T_i$, the cloud of color $C_i$ disappears from the sky. It is guaranteed that there is currently a cloud of color $C_i$ in the sky.\n\n$T_i$ are in non-decreasing order.", "outputFormat": "For each query event, output exactly one line containing the answer to that query, i.e., the number of distinct colors of candies the bag can catch.", "hint": "[Sample Explanation]\n\nThere are 10 events in total: 3 insertions, 5 queries, and 2 deletions.\n\nAt time 0, a cloud of color 10 appears with initial position $[1, 3]$ and direction left.\n\nAt time 1, a bag with range $[0, 0]$ can catch color 10 (the cloud is at $[0, 2]$).\n\nAt time 11, a bag with range $[0, 10]$ can catch color 10 (the cloud is at $[10, 12]$).\nAt time 11, a bag with range $[0, 9]$ cannot catch color 10 (the cloud is at $[10, 12]$).\nAt time 11, a cloud of color 13 appears with initial position $[4, 7]$ and direction right.\n\nAt time 13, a bag with range $[9, 9]$ can catch two different colors: 10 (the cloud is at $[8, 10]$) and 13 (the cloud is at $[6, 9]$).\n\nAt time 13, a bag with range $[10, 10]$ can catch only color 10 (the cloud is at $[8, 10]$), and cannot catch color 13 (the cloud is at $[6, 9]$).\n\nAt time 100, the cloud of color 13 disappears.\n\nAt time 1999999999, the cloud of color 10 disappears.\n\nAt time 2000000000, another cloud of color 10 appears with initial position $[0, 1]$ and direction right.\n\nConstraints\n\nFor all data, $0 \\le T_i \\le 2000000000$, $1 \\le C_i \\le 1000000$. The sequence $\\{T_i\\}$ is non-decreasing, i.e., $T_1 \\le T_2 \\le \\dots \\le T_{n-1} \\le T_n$.\n\nFor all insertion events, let $P_i = R_i - L_i$, i.e., $P_i$ denotes the length of each cloud.\n\nData ID|$n$|$len$|$P_i$\n-|-|-|-\n1|20|10|$\\le len$\n2|200|100|$\\le len$\n3|2000|1000|$\\le len$\n4|100000|10|$\\le len$\n5|100000|100|$\\le 2$\n6|150000|1000|$\\le 3$\n7|200000|1000|$\\le 3$\n8|100000|1000|$\\le len$\n9|150000|1000|$\\le len$\n10|200000|1000|$\\le len$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2008] 糖果雨", "background": "", "description": "有一个美丽的童话：在天空的尽头有一个\"糖果国\"，这里大到摩天大厦，小 到小花小草都是用糖果建造而成的。更加神奇的是，天空中飘满了五颜六色的糖 果云，很快糖果雨密密麻麻从天而落，红色的是草莓糖，黄色的是柠檬糖，绿色 的是薄荷糖，黑色的是巧克力糖……这时糖果国的小朋友们便会拿出大大小小的 口袋来接天空中落下的糖果，拿回去与朋友们一起分享。\n\n对糖果情有独钟的小 Z 憧憬着能够来到这样一个童话的国度。所谓日有所 思，夜有所梦，这天晚上小 Z 梦见自己来到了\"糖果国\"。他惊喜地发现，任何时 候天空中所有的云朵颜色都不相同，不同颜色的云朵在不断地落下相应颜色的糖 果。更加有趣的是所有的云朵都在做着匀速往返运动，不妨想象天空是有边界的， 而所有的云朵恰好在两个边界之间做着往返运动。每一个单位时间云朵向左或向 右运动一个单位，当云朵的左界碰到天空的左界，它会改变方向向右运动；当云 朵完全移出了天空的右界，它会改变方向向左运动。\n\n我们不妨把天空想象为一个平面直角坐标系，而云朵则抽象为线段(线段可 能退化为点)： \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hsdveny3.png)\n\n如上图，不妨设天空的左界为 0，右界为 len。图中共有 5 片云朵，其中标 号为 1 的云朵恰好改变方向向右运动，标号为 2 的云朵恰好改变方向向左运动。\n\n忽略云朵的纵坐标，它们在运动过程中不会相互影响。\n\n小 Z 发现天空中会不断出现一些云朵(某个时刻从某个初始位置开始朝某个 方向运动)，而有的云朵运动到一定时刻就会从天空中消失，而在运动的过程中 糖果在不断地下落。小 Z 决定拿很多口袋来接糖果，口袋容量是无限的，但袋 口大小却是有限的。例如在时刻 T 小 Z 拿一个横坐标范围为[L, R]的口袋来接糖 果，如果[L, R]存在一个位置 x，该位置有某种颜色的糖果落下，则认为该口袋可 接到此种颜色的糖果。极端情况下，袋口区间可能是一个点，譬如[0,0]、[1,1]，但仍然可以接到相应位置的糖果。通常可以接到的糖果总数会很大，因而小 Z 想知道每一次(即拿出口袋的一瞬间)他的口袋可以接到多少种不同颜色的糖果。\n\n糖果下落的时间忽略不计。", "inputFormat": "输入文件第一行有两个正整数 n, len，分别表示事件总数以及天空 的“边界”。\n\n    接下来 n 行每行描述一个事件，所有的事件按照输入顺序依次发生。每行的 第一个数 k（k = 1，2，3）分别表示事件的类型，分别对应三种事件：插入事件， 询问事件以及删除事件。输入格式如下： \n\n事件类型|输入格式|说明 \n-|-|-\n插入事件 (天空中出现了一片 云朵)|`1 Ti Ci Li Ri Di`|时刻 Ti，天空中出现了一片 坐标范围为[Li, Ri]，颜色为 Ci的 云朵，初始的时候云朵运动方向 为向左(Di = -1)或向右(Di = 1)。满足 0 ≤ Li ≤ Ri ≤ len，Di = -1 或 1。数据保证任何时刻空中不 会出现两片颜色相同的云朵。\n询问事件 (询问一个口袋可以 接到多少种不同颜 色的糖果)|`2 Ti Li Ri` |时刻 Ti，小 Z 用一个坐标范 围为[Li, Ri]的大口袋去接糖果， 询问可以接到多少种不同的糖 果。满足 0 ≤ Li ≤ Ri ≤ len。\n删除事件 (天空中一片云朵消 失了)|`3 Ti Ci` |时刻 Ti，颜色为 Ci的云朵从 天空消失中。数据保证当前天空 中一定存在一片颜色为 Ci的云 朵。", "outputFormat": "对于每一个询问事件，输出中应包含相应的一行，为该次询 问的答案，即口袋可以接到多少种不同的糖果。", "hint": "【样例说明】 \n\n共 10 个事件，包括 3 个插入事件，5 个询问事件以及 2 个删除事件。\n\n时刻 0，天空中出现一片颜色为 10 的云朵，初始位置为[1, 3]，方向向左。\n\n时刻 1，范围为[0, 0]的口袋可以接到颜色为 10 的糖果(云朵位置为[0, 2])。\n\n 时刻11，范围为[0,10]的口袋可以接到颜色为10的糖果(云朵位置为[10, 12])。\n 时刻 11，范围为[0, 9]的口袋不能接到颜色为 10 的糖果(云朵位置为[10, 12])。\n 时刻 11, 天空中出现一片颜色为 13 的云朵, 初始位置为[4, 7], 方向向右。\n\n时刻 13，范围为[9, 9]的口袋可以接到颜色为 10(云朵的位置为[8, 10])和颜色 为 13(云朵的位置为[6, 9])两种不同的糖果。\n\n时刻 13，范围为[10, 10]的口袋仅仅可以接到颜色为 10 的一种糖果(云朵的位 置为[8, 10])，而不可以接到颜色为 13 的糖果(云朵的位置为[6, 9]),。\n\n时刻 100, 颜色为 13 的云朵从天空中消失。\n\n时刻 1999999999，颜色为 10 的云朵从天空中消失。\n\n时刻 2000000000，天空中又出现一片颜色为 10 的云朵，初始位置为[0, 1]， 方向向右。\n\n【数据范围】\n\n对于所有的数据，0 ≤ Ti ≤ 2000000000，1 ≤ Ci ≤ 1000000。\n\n数据保证{Ti}为非递减序列即 T1 ≤ T2 ≤ … ≤ Tn-1 ≤ Tn。\n\n对于所有的插入事件，令 Pi = Ri – Li，即 Pi表示每片云朵的长度。\n\n\n数据编号|n|len|Pi|数据编号|n|len|Pi\n-|-|-|-|-|-|-|-\n1|20|10|≤len|6|150000|1000|≤3\n2|200|100|≤len|7|200000|1000|≤3\n3|2000|1000|≤len|8|100000|1000|≤len\n4|100000|10|≤len|9|150000|1000|≤len\n5|100000|100|≤2|10|200000|1000|≤len\n", "locale": "zh-CN"}}}
{"pid": "P4204", "type": "P", "difficulty": 6, "samples": [["2 3 1\n1 1\n1 1\n2 2\n3 1\n", "1/12\n"], ["3 1 2\n1 1 1\n5 1\n", "1/3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["高精度", "2006", "NOI", "排序"], "title": "[NOI2006] 神奇口袋", "background": "", "description": "Pòlya 获得了一个奇妙的口袋，上面写着人类难以理解的符号。Pòlya 看得入了迷，冥思苦想，发现了一个神奇的模型（被后人称为 Pòlya 模型)。为了生动地讲授这个神奇的模型，他带着学生们做了一个虚拟游戏：游戏开始时，袋中装入 $a_1$ 个颜色为 $1$ 的球，$a_2$ 个颜色为 $2$ 的球，……，$a_t$ 个颜色为 $t$ 的球，其中 $a_i \\in \\mathbb Z^+$（$1 \\le i \\le t$）。\n\n游戏开始后，每次严格进行如下的操作：\n\n从袋中随机的抽出一个小球（袋中所有小球被抽中的概率相等），Pòlya 独自观察这个小球的颜色后将其放回，然后再把 $d$ 个与其颜色相同的小球放到口袋中。\n\n设 $c_i$ 表示第 $i$ 次抽出的小球的颜色（$1 \\le C_i \\le t$），一个游戏过程将会产生一个颜色序列（$c_1, c_2, \\ldots, c_n, \\ldots$）。Pòlya 把游戏开始时 $t$ 种颜色的小球每一种的个数 $a_1, a_2, \\ldots, a_t$ 告诉了所有学生。然后他问学生：一次游戏过程产生的颜色序列满足下列条件的概率有多大？ \n\n$$c_{x_1}=y_1, c_{x_2}=y_2, \\ldots, c_{x_n}=y_n$$\n\n其中 $0 < x_1 < x_2 < \\cdots < x_n$，$1 \\le y_i \\le t$。换句话说，已知 $(t, n, d, a_1, a_2, \\ldots, a_t, x_1, y_1, x_2, y_2, \\ldots, x_n, y_n)$，你要回答有多大的可能性会发生下面的事件：“对所有 $k$（$1 \\le k \\le n$），第 $x_k$ 次抽出的球的颜色为 $y_k$”。", "inputFormat": "第一行有三个正整数 $t, n, d$；\n\n第二行有 $t$ 个正整数 $a_1, a_2, \\ldots, a_t$，表示游戏开始时口袋里 $t$ 种颜色的球，每种球的个数。\n\n以下 $n$ 行，每行有两个正整数 $x_i, y_i$，表示第 $x_i$ 次抽出颜色为的 $y_i$ 球。", "outputFormat": "要求用分数形式输出（显然此概率为有理数）。输出文件包含一行，格式为：`分子/分母`。同时要求输出最简形式（分子分母互质）。特别的，概率为 $0$ 应输出 `0/1`，概率为 $1$ 应输出 `1/1`。", "hint": "**【样例解释 #1】**\n\n初始时，两种颜色球数分别为 $(1, 1)$，取出色号为 $1$ 的球的概率为 $1/2$；第二次取球之前，两种颜色球数分别为 $(2, 1)$，取出色号为 $2$ 的球的概率为 $1/3$；第三次取球之前，两种颜色球数分别为 $(2, 2)$，取出色号为 $1$ 的球的概率为 $1/2$，所以三次取球的总概率为 $1/12$。\n\n**【数据规模和约定】**\n\n对于 $100 \\%$ 的数据，$1 \\le t, n \\le 1000$，$1 \\le a_k, d \\le 10$，$1 \\le x_1 < x_2 < \\cdots < x_n \\le 10000$，$1 \\le y_k \\le t$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2006] Magical Pocket", "background": "", "description": "Pòlya obtained a marvelous pocket inscribed with symbols beyond human understanding. Fascinated, he pondered and discovered a magical model (later called the \"Pòlya model\"). To vividly teach this model, he had his students play a virtual game: at the beginning, put $a_1$ balls of color $1$, $a_2$ balls of color $2$, …, and $a_t$ balls of color $t$ into the bag, where $a_i \\in \\mathbb Z^+$ ($1 \\le i \\le t$).\n\nAfter the game starts, repeat the following operation strictly each time:\n\nRandomly draw one ball from the bag (all balls in the bag are equally likely to be drawn), Pòlya observes the color of this ball and puts it back, then adds $d$ more balls of the same color into the pocket.\n\nLet $c_i$ be the color of the ball drawn on the $i$-th draw ($1 \\le c_i \\le t$). A single game run produces a color sequence $(c_1, c_2, \\ldots, c_n, \\ldots)$. Pòlya tells all students the initial counts of balls of the $t$ colors, namely $a_1, a_2, \\ldots, a_t$. Then he asks the students: what is the probability that a single run produces a color sequence satisfying\n\n$$c_{x_1}=y_1, c_{x_2}=y_2, \\ldots, c_{x_n}=y_n \\, ?$$\n\nHere $0 < x_1 < x_2 < \\cdots < x_n$, and $1 \\le y_i \\le t$. In other words, given $(t, n, d, a_1, a_2, \\ldots, a_t, x_1, y_1, x_2, y_2, \\ldots, x_n, y_n)$, you need to answer the probability of the following event: “for all $k$ ($1 \\le k \\le n$), the color of the $x_k$-th draw is $y_k$.”", "inputFormat": "- The first line contains three positive integers $t, n, d$.\n- The second line contains $t$ positive integers $a_1, a_2, \\ldots, a_t$, representing the number of balls of each of the $t$ colors at the beginning of the game.\n- Each of the next $n$ lines contains two positive integers $x_i, y_i$, indicating that on the $x_i$-th draw the color is $y_i$.", "outputFormat": "Output the probability as a fraction (this probability is clearly rational). The output contains one line in the format: numerator/denominator. It must be in lowest terms (the numerator and denominator are coprime). In particular, if the probability is $0$, output 0/1; if the probability is $1$, output 1/1.", "hint": "[Sample Explanation #1]\n\nInitially, the counts of the two colors are $(1, 1)$, so the probability of drawing a ball of color $1$ is $1/2$. Before the second draw, the counts become $(2, 1)$, so the probability of drawing a ball of color $2$ is $1/3$. Before the third draw, the counts become $(2, 2)$, so the probability of drawing a ball of color $1$ is $1/2$. Therefore, the total probability of the three draws is $1/12$.\n\nConstraints\n\nFor $100\\%$ of the testdata, $1 \\le t, n \\le 1000$, $1 \\le a_k, d \\le 10$, $1 \\le x_1 < x_2 < \\cdots < x_n \\le 10000$, $1 \\le y_k \\le t$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2006] 神奇口袋", "background": "", "description": "Pòlya 获得了一个奇妙的口袋，上面写着人类难以理解的符号。Pòlya 看得入了迷，冥思苦想，发现了一个神奇的模型（被后人称为 Pòlya 模型)。为了生动地讲授这个神奇的模型，他带着学生们做了一个虚拟游戏：游戏开始时，袋中装入 $a_1$ 个颜色为 $1$ 的球，$a_2$ 个颜色为 $2$ 的球，……，$a_t$ 个颜色为 $t$ 的球，其中 $a_i \\in \\mathbb Z^+$（$1 \\le i \\le t$）。\n\n游戏开始后，每次严格进行如下的操作：\n\n从袋中随机的抽出一个小球（袋中所有小球被抽中的概率相等），Pòlya 独自观察这个小球的颜色后将其放回，然后再把 $d$ 个与其颜色相同的小球放到口袋中。\n\n设 $c_i$ 表示第 $i$ 次抽出的小球的颜色（$1 \\le C_i \\le t$），一个游戏过程将会产生一个颜色序列（$c_1, c_2, \\ldots, c_n, \\ldots$）。Pòlya 把游戏开始时 $t$ 种颜色的小球每一种的个数 $a_1, a_2, \\ldots, a_t$ 告诉了所有学生。然后他问学生：一次游戏过程产生的颜色序列满足下列条件的概率有多大？ \n\n$$c_{x_1}=y_1, c_{x_2}=y_2, \\ldots, c_{x_n}=y_n$$\n\n其中 $0 < x_1 < x_2 < \\cdots < x_n$，$1 \\le y_i \\le t$。换句话说，已知 $(t, n, d, a_1, a_2, \\ldots, a_t, x_1, y_1, x_2, y_2, \\ldots, x_n, y_n)$，你要回答有多大的可能性会发生下面的事件：“对所有 $k$（$1 \\le k \\le n$），第 $x_k$ 次抽出的球的颜色为 $y_k$”。", "inputFormat": "第一行有三个正整数 $t, n, d$；\n\n第二行有 $t$ 个正整数 $a_1, a_2, \\ldots, a_t$，表示游戏开始时口袋里 $t$ 种颜色的球，每种球的个数。\n\n以下 $n$ 行，每行有两个正整数 $x_i, y_i$，表示第 $x_i$ 次抽出颜色为的 $y_i$ 球。", "outputFormat": "要求用分数形式输出（显然此概率为有理数）。输出文件包含一行，格式为：`分子/分母`。同时要求输出最简形式（分子分母互质）。特别的，概率为 $0$ 应输出 `0/1`，概率为 $1$ 应输出 `1/1`。", "hint": "**【样例解释 #1】**\n\n初始时，两种颜色球数分别为 $(1, 1)$，取出色号为 $1$ 的球的概率为 $1/2$；第二次取球之前，两种颜色球数分别为 $(2, 1)$，取出色号为 $2$ 的球的概率为 $1/3$；第三次取球之前，两种颜色球数分别为 $(2, 2)$，取出色号为 $1$ 的球的概率为 $1/2$，所以三次取球的总概率为 $1/12$。\n\n**【数据规模和约定】**\n\n对于 $100 \\%$ 的数据，$1 \\le t, n \\le 1000$，$1 \\le a_k, d \\le 10$，$1 \\le x_1 < x_2 < \\cdots < x_n \\le 10000$，$1 \\le y_k \\le t$。", "locale": "zh-CN"}}}
{"pid": "P4205", "type": "P", "difficulty": 6, "samples": [[".\n..\n...\n....\n.....\n.....C\n...CCC.\nEEEHH...\nE.HHH....\nE.........", "B\nBK\nBKK\nBJKK\nJJJDD\nGJGDDC\nGGGCCCI\nEEEHHIIA\nELHHHIAAF\nELLLLIFFFF"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2005", "NOI", "枚举", "剪枝", "Dancing Links"], "title": "[NOI2005] 智慧珠游戏", "background": "", "description": "智慧珠游戏拼盘由一个三角形盘件和 12 个形态各异的零件组成。拼盘的盘 件如图 1 所示\n![](https://cdn.luogu.com.cn/upload/pic/13767.png)\n![](https://cdn.luogu.com.cn/upload/pic/13768.png)\n![](https://cdn.luogu.com.cn/upload/pic/13769.png)\n对 于 由珠子构成的零件，可以放到盘件的任一位置，条件是能有地方放，且 尺寸合适，所有的零件都允许旋转(0º、90º、180º、270º)和翻转(水平、竖直)。\n \n \n现给出一个盘件的初始布局，求一种可行的智慧珠摆放方案，使所有的零件 都能放进盘件中。 ", "inputFormat": "文件中包含初始的盘件描述，一共有 10 行，第 i 行有 i 个字符。如果第 i 行 的第 j 个字符是字母”A”至”L”中的一个，则表示第 i 行第 j 列的格子上已经放了 零件，零件的编号为对应的字母。如果第 i 行的第 j 个字符是”.”，则表示第 i 行 第 j 列的格子上没有放零件。\n输入保证预放的零件已摆放在盘件中。", "outputFormat": "如果能找到解，向输出文件打印 10 行，为放完全部 12 个零件后的布局。其 中，第 i 行应包含 i 个字符，第 i 行的第 j 个字符表示第 i 行第 j 列的格子上放的 是哪个零件。 如果无解，输出单独的一个字符串‘No solution’(不要引号，请注意大小写)。\n 所有的数据保证最多只有一组解", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2005] Smart Beads Game", "background": "", "description": "The Smart Beads puzzle consists of a triangular board and 12 distinct pieces. The board is shown in Figure 1.\n![](https://cdn.luogu.com.cn/upload/pic/13767.png)\n![](https://cdn.luogu.com.cn/upload/pic/13768.png)\n![](https://cdn.luogu.com.cn/upload/pic/13769.png)\nEach piece, made of beads, can be placed at any position on the board as long as it fits and there is space for it. All pieces may be rotated by 0°, 90°, 180°, or 270°, and may be flipped horizontally or vertically.\nGiven an initial layout of the board, find a valid arrangement that places all 12 pieces on the board.", "inputFormat": "The file contains the initial board description in 10 lines. The i-th line has i characters.\nIf the j-th character of the i-th line is a letter 'A' to 'L', then the cell at row i and column j is already occupied by a piece whose ID is that letter. If the j-th character is '.', then the cell at row i and column j is empty.\nThe input guarantees that all pre-placed pieces are legally placed on the board.", "outputFormat": "If a solution exists, print 10 lines describing the layout after placing all 12 pieces. The i-th line should contain i characters, and the j-th character of the i-th line indicates which piece occupies that cell.\nIf there is no solution, print the single string No solution (without quotes, case-sensitive).\nAll testdata guarantee that there is at most one solution.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2005] 智慧珠游戏", "background": "", "description": "智慧珠游戏拼盘由一个三角形盘件和 12 个形态各异的零件组成。拼盘的盘 件如图 1 所示\n![](https://cdn.luogu.com.cn/upload/pic/13767.png)\n![](https://cdn.luogu.com.cn/upload/pic/13768.png)\n![](https://cdn.luogu.com.cn/upload/pic/13769.png)\n对 于 由珠子构成的零件，可以放到盘件的任一位置，条件是能有地方放，且 尺寸合适，所有的零件都允许旋转(0º、90º、180º、270º)和翻转(水平、竖直)。\n \n \n现给出一个盘件的初始布局，求一种可行的智慧珠摆放方案，使所有的零件 都能放进盘件中。 ", "inputFormat": "文件中包含初始的盘件描述，一共有 10 行，第 i 行有 i 个字符。如果第 i 行 的第 j 个字符是字母”A”至”L”中的一个，则表示第 i 行第 j 列的格子上已经放了 零件，零件的编号为对应的字母。如果第 i 行的第 j 个字符是”.”，则表示第 i 行 第 j 列的格子上没有放零件。\n输入保证预放的零件已摆放在盘件中。", "outputFormat": "如果能找到解，向输出文件打印 10 行，为放完全部 12 个零件后的布局。其 中，第 i 行应包含 i 个字符，第 i 行的第 j 个字符表示第 i 行第 j 列的格子上放的 是哪个零件。 如果无解，输出单独的一个字符串‘No solution’(不要引号，请注意大小写)。\n 所有的数据保证最多只有一组解", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4206", "type": "P", "difficulty": 5, "samples": [["4 3 \n1 4 \n1 2 \n2 3 \n3 4", "1.500 \n"], ["9 9 \n9 3 \n1 2 \n2 3 \n3 4 \n4 5 \n3 6 \n4 6 \n4 7 \n7 8 \n8 9", "2.167"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2005", "NOI", "广度优先搜索 BFS", "深度优先搜索 DFS", "记忆化搜索", "期望"], "title": "[NOI2005] 聪聪与可可", "background": "", "description": "在一个魔法森林里，住着一只聪明的小猫聪聪和一只可爱的小老鼠可可。虽然灰姑娘非常喜欢她们俩，但是，聪聪终究是一只猫，而可可终究是一只老鼠，同样不变的是，聪聪成天想着要吃掉可可。\n\n一天，聪聪意外得到了一台非常有用的机器，据说是叫 GPS，对可可能准确的定位。有了这台机器，聪聪要吃可可就易如反掌了。于是，聪聪准备马上出发，去找可可。而可怜的可可还不知道大难即将临头，仍在森林里无忧无虑的玩耍。小兔子乖乖听到这件事，马上向灰姑娘报告。灰姑娘决定尽快阻止聪聪，拯救可可，可她不知道还有没有足够的时间。\n\n整个森林可以认为是一个无向图，图中有 $N$ 个美丽的景点，景点从 $1$ 至 $N$ 编号。小动物们都只在景点休息、玩耍。在景点之间有一些路连接。\n\n当聪聪得到 GPS 时，可可正在景点 $M$（$M \\le N$）处。以后的每个时间单位，可可都会选择去相邻的景点（可能有多个）中的一个或停留在原景点不动。而去这些地方所发生的概率是相等的。假设有 $P$ 个景点与景点 $M$ 相邻，它们分别是景点 $R$、景点 $S$、……、景点 $Q$，在时刻 $T$ 可可处在景点 $M$，则在 $(T+1)$ 时刻，可可有 $1/(1 +P)$ 的可能在景点 $R$，有 $1/(1 +P)$ 的可能在景点 $S$，……，有 $1/(1 +P)$ 的可能在景点 $Q$，还有$1/(1 +P)$的可能停在景点 $M$。\n\n我们知道，聪聪是很聪明的，所以，当她在景点 $C$ 时，她会选一个更靠近可可的景点，如果这样的景点有多个，她会选一个标号最小的景点。由于聪聪太想吃掉可可了，如果走完第一步以后仍然没吃到可可，她还可以在本段时间内再向可可走近一步。\n\n在每个时间单位，假设聪聪先走，可可后走。在某一时刻，若聪聪和可可位于同一个景点，则可怜的可可就被吃掉了。\n\n灰姑娘想知道，平均情况下，聪聪几步就可能吃到可可。而你需要帮助灰姑娘尽快的找到答案。", "inputFormat": "数据的第 1 行为两个整数 $N$ 和 $E$，以空格分隔，分别表示森林中的景点数和连接相邻景点的路的条数。\n\n第 2 行包含两个整数 $C$ 和 $M$，以空格分隔，分别表示初始时聪聪和可可所在的景点的编号。\n\n接下来 E 行，每行两个整数，第 $i+2$ 行的两个整数 $A_i$ 和 $B_i$ 表示景点 $A_i$ 和景点 $B_i$ 之间有一条路。所有的路都是无向的，即：如果能从 A 走到 B，就可以从 B 走到 A。\n\n输入保证任何两个景点之间不会有多于一条路直接相连，且聪聪和可可之间必有路直接或间接的相连。", "outputFormat": "输出 1 个实数，四舍五入保留三位小数，表示平均多少个时间单位后聪聪会把可可吃掉。", "hint": "【样例说明 1】 \n\n开始时，聪聪和可可分别在景点 1 和景点 4。 \n\n第一个时刻，聪聪先走，她向更靠近可可(景点 4)的景点走动，走到景点 2， 然后走到景点 3；假定忽略走路所花时间。 \n\n可可后走，有两种可能： 第一种是走到景点 3，这样聪聪和可可到达同一个景点，可可被吃掉，步数为 $1$，概率为$0.5$。\n \n第二种是停在景点 4，不被吃掉。概率为 $0.5$。\n\n到第二个时刻，聪聪向更靠近可可(景点 4)的景点走动，只需要走一步即和 可可在同一景点。因此这种情况下聪聪会在两步吃掉可可。 所以平均的步数是 $1\\times 1/2 + 2\\times 1/2 =1.5$ 步。\n\n【样例说明 2】\n\n森林如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8uiq0ltc.png)\n\n对于 50%的数据，$1≤N≤50$。  \n对于所有的数据，$1≤N,E≤1000$。 ", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2005] Congcong and Keke", "background": "", "description": "In a magical forest, there live a clever kitten Congcong and a cute little mouse Keke. Although Cinderella likes both of them very much, Congcong is still a cat and Keke is still a mouse, and one thing never changes: Congcong is always thinking about eating Keke.\n\nOne day, Congcong accidentally obtained a very useful device called a GPS, which can accurately locate Keke. With this device, it becomes easy for Congcong to catch Keke. So Congcong plans to set off immediately to find Keke. Poor Keke, unaware of the looming danger, is still playing in the forest without a care. Little Bunny \"Guai Guai\" hears about this and reports to Cinderella at once. Cinderella decides to stop Congcong as soon as possible to save Keke, but she does not know whether there is still enough time.\n\nThe entire forest can be regarded as an undirected graph with $N$ beautiful spots, numbered from $1$ to $N$. The little animals only rest and play at the spots. There are some roads connecting pairs of spots.\n\nWhen Congcong gets the GPS, Keke is at spot $M$ ($M \\le N$). In each subsequent time unit, Keke will choose one of the adjacent spots (possibly multiple) or stay at the current spot. The probabilities of these choices are equal. Suppose there are $P$ spots adjacent to spot $M$, namely spots $R$, $S$, …, $Q$. If at time $T$ Keke is at spot $M$, then at time $(T+1)$ Keke has a $1/(1 +P)$ chance to be at spot $R$, a $1/(1 +P)$ chance to be at spot $S$, …, a $1/(1 +P)$ chance to be at spot $Q$, and a $1/(1 +P)$ chance to remain at spot $M$.\n\nWe know Congcong is very smart, so when she is at spot $C$, she will choose an adjacent spot that is closer to Keke. If there are multiple such spots, she chooses the one with the smallest index. Because Congcong is eager to eat Keke, if she still has not caught Keke after taking the first step, she can take one more step toward Keke within the same time unit. Assume the time spent walking is ignored.\n\nIn each time unit, Congcong moves first and Keke moves afterward. At any time, if Congcong and Keke are at the same spot, then poor Keke is eaten.\n\nCinderella wants to know, on average, how many time units it will take for Congcong to eat Keke. You need to help Cinderella find the answer as quickly as possible.", "inputFormat": "The first line contains two integers $N$ and $E$, separated by a space, representing the number of spots in the forest and the number of roads connecting adjacent spots.\n\nThe second line contains two integers $C$ and $M$, separated by a space, representing the initial spots of Congcong and Keke, respectively.\n\nThe next $E$ lines each contain two integers. On line $i+2$, the two integers $A_i$ and $B_i$ indicate that there is a road between spots $A_i$ and $B_i$. All roads are undirected, i.e., if one can go from $A$ to $B$, then one can also go from $B$ to $A$.\n\nThe input guarantees that there is no more than one direct road between any pair of spots, and that there is a path (direct or indirect) between Congcong and Keke.", "outputFormat": "Output one real number, rounded to three decimal places, representing the expected number of time units after which Congcong will eat Keke.", "hint": "Sample Explanation 1:\n\nInitially, Congcong and Keke are at spots 1 and 4, respectively.\n\nAt the first time unit, Congcong moves first. She moves toward Keke (spot 4), going to spot 2, then to spot 3; assume the time spent walking is ignored.\n\nKeke then moves, with two possibilities: The first is moving to spot 3, in which case Congcong and Keke are at the same spot, Keke is eaten, the number of time units is $1$, and the probability is $0.5$. The second is staying at spot 4, not being eaten, with probability $0.5$.\n\nAt the second time unit, Congcong moves toward Keke (spot 4) and needs only one step to reach the same spot as Keke. Therefore, in this case, Congcong will eat Keke in two time units. Hence the expected number of time units is $1\\times 1/2 + 2\\times 1/2 =1.5$.\n\nSample Explanation 2:\n\nThe forest is shown below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8uiq0ltc.png)\n\nFor 50% of the testdata, $1≤N≤50$.\nFor all testdata, $1≤N,E≤1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2005] 聪聪与可可", "background": "", "description": "在一个魔法森林里，住着一只聪明的小猫聪聪和一只可爱的小老鼠可可。虽然灰姑娘非常喜欢她们俩，但是，聪聪终究是一只猫，而可可终究是一只老鼠，同样不变的是，聪聪成天想着要吃掉可可。\n\n一天，聪聪意外得到了一台非常有用的机器，据说是叫 GPS，对可可能准确的定位。有了这台机器，聪聪要吃可可就易如反掌了。于是，聪聪准备马上出发，去找可可。而可怜的可可还不知道大难即将临头，仍在森林里无忧无虑的玩耍。小兔子乖乖听到这件事，马上向灰姑娘报告。灰姑娘决定尽快阻止聪聪，拯救可可，可她不知道还有没有足够的时间。\n\n整个森林可以认为是一个无向图，图中有 $N$ 个美丽的景点，景点从 $1$ 至 $N$ 编号。小动物们都只在景点休息、玩耍。在景点之间有一些路连接。\n\n当聪聪得到 GPS 时，可可正在景点 $M$（$M \\le N$）处。以后的每个时间单位，可可都会选择去相邻的景点（可能有多个）中的一个或停留在原景点不动。而去这些地方所发生的概率是相等的。假设有 $P$ 个景点与景点 $M$ 相邻，它们分别是景点 $R$、景点 $S$、……、景点 $Q$，在时刻 $T$ 可可处在景点 $M$，则在 $(T+1)$ 时刻，可可有 $1/(1 +P)$ 的可能在景点 $R$，有 $1/(1 +P)$ 的可能在景点 $S$，……，有 $1/(1 +P)$ 的可能在景点 $Q$，还有$1/(1 +P)$的可能停在景点 $M$。\n\n我们知道，聪聪是很聪明的，所以，当她在景点 $C$ 时，她会选一个更靠近可可的景点，如果这样的景点有多个，她会选一个标号最小的景点。由于聪聪太想吃掉可可了，如果走完第一步以后仍然没吃到可可，她还可以在本段时间内再向可可走近一步。\n\n在每个时间单位，假设聪聪先走，可可后走。在某一时刻，若聪聪和可可位于同一个景点，则可怜的可可就被吃掉了。\n\n灰姑娘想知道，平均情况下，聪聪几步就可能吃到可可。而你需要帮助灰姑娘尽快的找到答案。", "inputFormat": "数据的第 1 行为两个整数 $N$ 和 $E$，以空格分隔，分别表示森林中的景点数和连接相邻景点的路的条数。\n\n第 2 行包含两个整数 $C$ 和 $M$，以空格分隔，分别表示初始时聪聪和可可所在的景点的编号。\n\n接下来 E 行，每行两个整数，第 $i+2$ 行的两个整数 $A_i$ 和 $B_i$ 表示景点 $A_i$ 和景点 $B_i$ 之间有一条路。所有的路都是无向的，即：如果能从 A 走到 B，就可以从 B 走到 A。\n\n输入保证任何两个景点之间不会有多于一条路直接相连，且聪聪和可可之间必有路直接或间接的相连。", "outputFormat": "输出 1 个实数，四舍五入保留三位小数，表示平均多少个时间单位后聪聪会把可可吃掉。", "hint": "【样例说明 1】 \n\n开始时，聪聪和可可分别在景点 1 和景点 4。 \n\n第一个时刻，聪聪先走，她向更靠近可可(景点 4)的景点走动，走到景点 2， 然后走到景点 3；假定忽略走路所花时间。 \n\n可可后走，有两种可能： 第一种是走到景点 3，这样聪聪和可可到达同一个景点，可可被吃掉，步数为 $1$，概率为$0.5$。\n \n第二种是停在景点 4，不被吃掉。概率为 $0.5$。\n\n到第二个时刻，聪聪向更靠近可可(景点 4)的景点走动，只需要走一步即和 可可在同一景点。因此这种情况下聪聪会在两步吃掉可可。 所以平均的步数是 $1\\times 1/2 + 2\\times 1/2 =1.5$ 步。\n\n【样例说明 2】\n\n森林如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8uiq0ltc.png)\n\n对于 50%的数据，$1≤N≤50$。  \n对于所有的数据，$1≤N,E≤1000$。 ", "locale": "zh-CN"}}}
{"pid": "P4207", "type": "P", "difficulty": 7, "samples": [["2  0.7853981633 \n10.0  10.00  10.00 \n4.00  5.00", "171.97"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2005", "递归", "NOI", "积分"], "title": "[NOI2005] 月下柠檬树", "background": "", "description": "李哲非常非常喜欢柠檬树，特别是在静静的夜晚，当天空中有一弯明月温柔地照亮地面上的景物时，他必会悠闲地坐在他亲手植下的那棵柠檬树旁，独自思索着人生的哲理。\n\n李哲是一个喜爱思考的孩子，当他看到在月光的照射下柠檬树投在地面上的影子是如此的清晰，马上想到了一个问题：树影的面积是多大呢？\n\n李哲知道，直接测量面积是很难的，他想用几何的方法算，因为他对这棵柠檬树的形状了解得非常清楚，而且想好了简化的方法。\n\n李哲将整棵柠檬树分成了 $n$ 层，由下向上依次将层编号为 $1,2,...,n$。从第 $1$ 到 $n-1$ 层，每层都是一个圆台型，第 $n$ 层(最上面一层)是圆锥型。对于圆台型， 其上下底面都是水平的圆。对于相邻的两个圆台，上层的下底面和下层的上底面重合。第 $n$ 层(最上面一层)圆锥的底面就是第 $n-1$ 层圆台的上底面。所有的底面 的圆心(包括树顶)处在同一条与地面垂直的直线上。李哲知道每一层的高度为 $h_1,h_2,...,h_n$，第 $1$ 层圆台的下底面距地面的高度为 $h_0$，以及每层的下底面的圆的半径 $r_1,r_2,...,r_n$。李哲用熟知的方法测出了月亮的光线与地面的夹角为 $\\mathrm{alpha}$。\n\n![](https://cdn.luogu.com.cn/upload/pic/13770.png)\n\n为了便于计算，假设月亮的光线是平行光，且地面是水平的，在计算时忽略树干所产生的影子。李哲当然会算了，但是他希望你也来练练手。", "inputFormat": "第一行包含一个整数 $n$ 和一个实数 $\\mathrm{alpha}$，表示柠檬树的层数和月亮 的光线与地面夹角（单位为弧度）。\n\n第二行包含 $n+1$ 个实数 $h_0,h_1,h_2,...,h_n$ 表示树离地的高度和每层的高度。\n\n第三行包含 $n$ 个实数 $r_1,r_2,...,r_n$ 表示柠檬树每层下底面的圆的半径。\n\n同一行相邻的两个数之间用一个空格分隔。\n\n输入的所有实数的小数点后可能包含一至十位有效数字。", "outputFormat": "输出一个实数，表示树影的面积，四舍五入保留两位小数。", "hint": "对于 $10 \\%$ 的数据，$n \\leq 1$；\n\n对于 $30 \\%$ 的数据，$n \\leq 2$；\n\n对于 $60 \\%$ 的数据，$n \\leq 20$；\n\n对于 $100 \\%$ 的数据，$1 \\leq n \\leq 500$，$0.3 < \\mathrm{alpha} < \\frac{\\pi}{2}$，$0 < h_i \\leq 100$，$0 < r_i \\leq 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2005] Lemon Tree Under the Moonlight", "background": "", "description": "Li Zhe really loves lemon trees, especially on quiet nights when a crescent moon gently illuminates the ground. He always sits leisurely by the lemon tree he planted himself, pondering the philosophy of life.\n\nLi Zhe likes thinking. When he sees the lemon tree casting a sharp shadow on the ground under the moonlight, he immediately comes up with a question: what is the area of the tree’s shadow?\n\nHe knows that directly measuring the area is hard. He wants to compute it geometrically, because he understands the shape of this lemon tree very well and has a plan to simplify it.\n\nLi Zhe divides the whole lemon tree into $n$ layers, numbered from bottom to top as $1, 2, \\ldots, n$. From layer $1$ to layer $n-1$, each layer is a conical frustum, and layer $n$ (the topmost layer) is a cone. For a conical frustum, its top and bottom faces are horizontal circles. For two adjacent frustums, the lower base of the upper layer coincides with the upper base of the lower layer. The base of the cone in layer $n$ (the topmost layer) is exactly the upper base of the frustum in layer $n-1$. The centers of all circular bases (including the tree top) lie on a straight line perpendicular to the ground. Li Zhe knows the height of each layer $h_1, h_2, \\ldots, h_n$, the height of the lower base of the first frustum above the ground $h_0$, and the radius of the lower circular base of each layer $r_1, r_2, \\ldots, r_n$. Using a familiar method, he measured the angle between the moonlight rays and the ground to be $\\mathrm{alpha}$.\n\n![](https://cdn.luogu.com.cn/upload/pic/13770.png)\n\nFor convenience, assume the moonlight rays are parallel, the ground is horizontal, and ignore the shadow cast by the trunk. Of course Li Zhe can compute it, but he hopes you will give it a try too.", "inputFormat": "The first line contains an integer $n$ and a real number $\\mathrm{alpha}$, representing the number of layers of the lemon tree and the angle between the moonlight rays and the ground (in radians).\n\nThe second line contains $n+1$ real numbers $h_0, h_1, h_2, \\ldots, h_n$ representing the tree’s height above the ground and the height of each layer.\n\nThe third line contains $n$ real numbers $r_1, r_2, \\ldots, r_n$ representing the radius of the lower circular base of each layer of the lemon tree.\n\nAdjacent numbers on the same line are separated by a single space.\n\nAll real numbers in the input may have between 1 and 10 digits after the decimal point.", "outputFormat": "Output a single real number: the area of the tree’s shadow, rounded to two decimal places.", "hint": "For $10\\%$ of the testdata, $n \\leq 1$.\n\nFor $30\\%$ of the testdata, $n \\leq 2$.\n\nFor $60\\%$ of the testdata, $n \\leq 20$.\n\nFor $100\\%$ of the testdata, $1 \\leq n \\leq 500$, $0.3 < \\mathrm{alpha} < \\frac{\\pi}{2}$, $0 < h_i \\leq 100$, $0 < r_i \\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2005] 月下柠檬树", "background": "", "description": "李哲非常非常喜欢柠檬树，特别是在静静的夜晚，当天空中有一弯明月温柔地照亮地面上的景物时，他必会悠闲地坐在他亲手植下的那棵柠檬树旁，独自思索着人生的哲理。\n\n李哲是一个喜爱思考的孩子，当他看到在月光的照射下柠檬树投在地面上的影子是如此的清晰，马上想到了一个问题：树影的面积是多大呢？\n\n李哲知道，直接测量面积是很难的，他想用几何的方法算，因为他对这棵柠檬树的形状了解得非常清楚，而且想好了简化的方法。\n\n李哲将整棵柠檬树分成了 $n$ 层，由下向上依次将层编号为 $1,2,...,n$。从第 $1$ 到 $n-1$ 层，每层都是一个圆台型，第 $n$ 层(最上面一层)是圆锥型。对于圆台型， 其上下底面都是水平的圆。对于相邻的两个圆台，上层的下底面和下层的上底面重合。第 $n$ 层(最上面一层)圆锥的底面就是第 $n-1$ 层圆台的上底面。所有的底面 的圆心(包括树顶)处在同一条与地面垂直的直线上。李哲知道每一层的高度为 $h_1,h_2,...,h_n$，第 $1$ 层圆台的下底面距地面的高度为 $h_0$，以及每层的下底面的圆的半径 $r_1,r_2,...,r_n$。李哲用熟知的方法测出了月亮的光线与地面的夹角为 $\\mathrm{alpha}$。\n\n![](https://cdn.luogu.com.cn/upload/pic/13770.png)\n\n为了便于计算，假设月亮的光线是平行光，且地面是水平的，在计算时忽略树干所产生的影子。李哲当然会算了，但是他希望你也来练练手。", "inputFormat": "第一行包含一个整数 $n$ 和一个实数 $\\mathrm{alpha}$，表示柠檬树的层数和月亮 的光线与地面夹角（单位为弧度）。\n\n第二行包含 $n+1$ 个实数 $h_0,h_1,h_2,...,h_n$ 表示树离地的高度和每层的高度。\n\n第三行包含 $n$ 个实数 $r_1,r_2,...,r_n$ 表示柠檬树每层下底面的圆的半径。\n\n同一行相邻的两个数之间用一个空格分隔。\n\n输入的所有实数的小数点后可能包含一至十位有效数字。", "outputFormat": "输出一个实数，表示树影的面积，四舍五入保留两位小数。", "hint": "对于 $10 \\%$ 的数据，$n \\leq 1$；\n\n对于 $30 \\%$ 的数据，$n \\leq 2$；\n\n对于 $60 \\%$ 的数据，$n \\leq 20$；\n\n对于 $100 \\%$ 的数据，$1 \\leq n \\leq 500$，$0.3 < \\mathrm{alpha} < \\frac{\\pi}{2}$，$0 < h_i \\leq 100$，$0 < r_i \\leq 100$。", "locale": "zh-CN"}}}
{"pid": "P4208", "type": "P", "difficulty": 6, "samples": [["4 6\n1 2 1\n1 3 1\n1 4 1\n2 3 2\n2 4 1\n3 4 1", "8\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "矩阵树定理", "江苏"], "title": "[JSOI2008] 最小生成树计数", "background": "", "description": "现在给出了一个简单无向加权图。你不满足于求出这个图的最小生成树，而希望知道这个图中有多少个不同的最小生成树。（如果两棵最小生成树中至少有一条边不同，则这两个最小生成树就是不同的）。由于不同的最小生成树可能很多，所以你只需要输出方案数对 $31011$ 的模就可以了。", "inputFormat": "第一行包含两个数，$n$ 和 $m$，其中 $1 \\le n \\le 100$，$1 \\le m \\le 1000$，表示该无向图的节点数和边数。每个节点用 $1 \\sim n$ 的整数编号。\n\n接下来的 $m$ 行，每行包含两个整数：$a,b,c$，表示节点 $a,b$ 之间的边的权值为 $c$，其中 $1 \\le c \\le 10^9$。\n\n数据保证不会出现自回边和重边。注意：具有相同权值的边不会超过 $10$ 条。", "outputFormat": "输出不同的最小生成树有多少个。你只需要输出数量对 $31011$ 的模就可以了。", "hint": "### 数据范围及约定\n\n对于全部数据，$1 \\le n \\le 100$，$1 \\le m \\le 1000$，$1\\leq c_i\\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2008] Counting Minimum Spanning Trees", "background": "", "description": "You are given a simple undirected weighted graph. You are not satisfied with finding just one minimum spanning tree (MST); instead, you want to know how many different MSTs the graph has. Two MSTs are considered different if they differ by at least one edge. Since the number of different MSTs can be large, you only need to output the count modulo $31011$.", "inputFormat": "The first line contains two integers $n$ and $m$, where $1 \\le n \\le 100$, $1 \\le m \\le 1000$, representing the number of nodes and edges of the undirected graph. Nodes are numbered from $1$ to $n$.\n\nThe next $m$ lines each contain three integers $a, b, c$, indicating that there is an edge between nodes $a$ and $b$ with weight $c$, where $1 \\le c \\le 10^9$.\n\nIt is guaranteed that there are no self-loops or multiple edges. Note: For any fixed weight, there are at most $10$ edges with that weight.", "outputFormat": "Output the number of different minimum spanning trees. You only need to output the count modulo $31011$.", "hint": "### Constraints and Conventions\n\nFor all testdata, $1 \\le n \\le 100$, $1 \\le m \\le 1000$, $1 \\le c_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2008] 最小生成树计数", "background": "", "description": "现在给出了一个简单无向加权图。你不满足于求出这个图的最小生成树，而希望知道这个图中有多少个不同的最小生成树。（如果两棵最小生成树中至少有一条边不同，则这两个最小生成树就是不同的）。由于不同的最小生成树可能很多，所以你只需要输出方案数对 $31011$ 的模就可以了。", "inputFormat": "第一行包含两个数，$n$ 和 $m$，其中 $1 \\le n \\le 100$，$1 \\le m \\le 1000$，表示该无向图的节点数和边数。每个节点用 $1 \\sim n$ 的整数编号。\n\n接下来的 $m$ 行，每行包含两个整数：$a,b,c$，表示节点 $a,b$ 之间的边的权值为 $c$，其中 $1 \\le c \\le 10^9$。\n\n数据保证不会出现自回边和重边。注意：具有相同权值的边不会超过 $10$ 条。", "outputFormat": "输出不同的最小生成树有多少个。你只需要输出数量对 $31011$ 的模就可以了。", "hint": "### 数据范围及约定\n\n对于全部数据，$1 \\le n \\le 100$，$1 \\le m \\le 1000$，$1\\leq c_i\\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4209", "type": "P", "difficulty": 6, "samples": [["3 3 1\n1 2 3\n3 2 1\n111\n111\n111", "-2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["网络流", "费用流"], "title": "学习小组", "background": "", "description": "共有 $n$ 个学生，$m$ 个学习小组，每个学生只愿意参加其中的一些学习小组，且一个学生最多参加 $k$ 个学习小组。每个学生参加学习小组财务处都收一定的手续费，不同的学习小组有不同的手续费。若有 $a$ 个学生参加第 $i$ 个学习小组，财务处支付奖励 $C_i \\times a^2$ 元。在参与学生（而不是每个学习小组的人数总和）尽量多的情况下，求财务处最少要支出多少钱。", "inputFormat": "\n输入有若干行，第一行有三个用空格隔开的正整数 $n,m,k$。\n\n接下来的一行有 $m$ 个正整数，表示每个 $C_i$。\n\n第三行有 $m$ 个正整数，表示参加每个学习小组需要交的手续费 $F_i$。\n\n再接下来有一个 $n$ 行 $m$ 列的矩阵，表若第 $i$ 行 $j$ 列的数字是 $1$，则表示第 $i$ 个学生愿意参加第 $j$ 个学习小组，若为 $0$，则为不愿意。", "outputFormat": "输出只有一个整数，为最小的支出。", "hint": "对于 $100\\%$ 的数据，$0＜n\\le 100，0＜m≤90，0＜k\\le m，0＜C_i\\le 10，0＜F_i\\le 100。$", "locale": "zh-CN", "translations": {"en": {"title": "Study Groups", "background": "", "description": "There are $n$ students and $m$ study groups. Each student is willing to join only some of the study groups, and any student can join at most $k$ study groups. For each student participating in a study group, the finance office charges a handling fee; different study groups have different fees. If $a$ students join the $i$-th study group, the finance office pays a reward of $C_i \\times a^2$ yuan. Subject to making the number of participating students (i.e., the number of distinct students, not the sum over all groups) as large as possible, find the minimum amount of money the finance office must spend.", "inputFormat": "The input consists of multiple lines. The first line contains three positive integers $n, m, k$ separated by spaces.\n\nThe next line contains $m$ positive integers, the values of $C_i$.\n\nThe third line contains $m$ positive integers, the handling fees $F_i$ required to join each study group.\n\nThen follows an $n$-by-$m$ matrix. If the number at row $i$, column $j$ is 1, then the $i$-th student is willing to join the $j$-th study group; if it is 0, then the student is unwilling.", "outputFormat": "Output a single integer: the minimum expenditure.", "hint": "For $100\\%$ of the testdata, $0 < n \\le 100$, $0 < m \\le 90$, $0 < k \\le m$, $0 < C_i \\le 10$, $0 < F_i \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "学习小组", "background": "", "description": "共有 $n$ 个学生，$m$ 个学习小组，每个学生只愿意参加其中的一些学习小组，且一个学生最多参加 $k$ 个学习小组。每个学生参加学习小组财务处都收一定的手续费，不同的学习小组有不同的手续费。若有 $a$ 个学生参加第 $i$ 个学习小组，财务处支付奖励 $C_i \\times a^2$ 元。在参与学生（而不是每个学习小组的人数总和）尽量多的情况下，求财务处最少要支出多少钱。", "inputFormat": "\n输入有若干行，第一行有三个用空格隔开的正整数 $n,m,k$。\n\n接下来的一行有 $m$ 个正整数，表示每个 $C_i$。\n\n第三行有 $m$ 个正整数，表示参加每个学习小组需要交的手续费 $F_i$。\n\n再接下来有一个 $n$ 行 $m$ 列的矩阵，表若第 $i$ 行 $j$ 列的数字是 $1$，则表示第 $i$ 个学生愿意参加第 $j$ 个学习小组，若为 $0$，则为不愿意。", "outputFormat": "输出只有一个整数，为最小的支出。", "hint": "对于 $100\\%$ 的数据，$0＜n\\le 100，0＜m≤90，0＜k\\le m，0＜C_i\\le 10，0＜F_i\\le 100。$", "locale": "zh-CN"}}}
{"pid": "P4210", "type": "P", "difficulty": 6, "samples": [["3 3 \n8 \n9 \n1 2 2 6 2 \n2 3 8 5 7 \n1 3 9 4 1", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["网络流"], "title": "土地划分", "background": "", "description": "$Y$ 国有 $N$ 座城市，并且有 $M$ 条双向公路将这些城市连接起来，并且任意两个城市至少有一条路径可以互达。$Y$ 国的国王去世之后，他的两个儿子 A 和 B 都想成为新的国王，但他们都想让这个国家更加安定，不会用武力解决问题。于是他们想将这个国家分成两个小国家 A 国和 B 国。现在，A 拥有 $1$ 号城市，B 拥有 $N$ 号城市，其他的城市还尚未确定归属哪边（划分之后的国家内部城市可以不连通）。由于大家都想让国家变得更好，而某些城市的人民愿意国王的 A 儿子作为他们的领袖，而某些城市更看好 B，而为了交通的便捷，如果划分后的公路连接两个同一个国家的城市，那么更利于城市之间的交流。于是大臣们设计了一种对土地划分的评分机制，具体如下：对于城市 $i$，如果它划分给 A 国，将得到 $\\mathit{VA}_i$ 的得分；划分给 B 国，将得到 $\\mathit{VB}_i$ 的得分。对于一条公路 $i$，如果它连接两个 A 国的城市，将得到 $\\mathit{EA}_i$ 的得分；连接两个 B 国的城市，将得到 $\\mathit{EB}_i$ 的得分；否则，这条公路将失去意义，将扣除 $\\mathit{EC}_i$ 的得分。现请你找到最优的土地划分，使得这种它的评分最高。", "inputFormat": "第一行包含两个整数 $N$，$M$，含义如问题描述所示。接下来一行 $N-2$ 个非负整数，表示 $\\mathit{VA}_2,\\mathit{VA}_3,\\cdots,\\mathit{VA}_{N-1}$。接下来一行 $N-2$ 个非负整数，表示 $\\mathit{VB}_2,\\mathit{VB}_3,\\cdots,\\mathit{VB}_{N-1}$。接下来 $M$ 行，每行五个非负整数描述一条公路：$X,Y,\\mathit{EA}_i,\\mathit{EB}_i,\\mathit{EC}_i$，含义如问题描述所示。", "outputFormat": "输出有且仅有一个整数，表示最高评分。", "hint": "对于全部数据，$n \\le 10^4$，$m \\le 4\\times 10^4$。\n\n保证运算过程中及最终结果不超过 $32$ 位带符号整数类型的表示范围。\n", "locale": "zh-CN", "translations": {"en": {"title": "Land Division", "background": "", "description": "Country Y has $N$ cities and $M$ bidirectional roads connecting them, and any two cities are connected by at least one path. After the death of the king of Country Y, his two sons A and B both wish to become the new king, but they both want greater stability and will not use force. They decide to divide the country into two smaller countries: Country A and Country B. Currently, A owns city $1$, and B owns city $N$. The ownership of the other cities has not yet been determined (after the division, the cities within the same country do not need to be connected).\n\nSince everyone wants the country to prosper, some cities prefer the king’s son A as their leader, while others favor B. For transportation convenience, if a road connects two cities within the same country after the division, it is more beneficial for intercity communication. Therefore, the ministers designed a scoring mechanism for the land division, as follows:\n\nFor city $i$, if it is assigned to Country A, it yields a score of $\\mathit{VA}_i$; if it is assigned to Country B, it yields a score of $\\mathit{VB}_i$. For a road $i$, if it connects two cities in Country A, it yields a score of $\\mathit{EA}_i$; if it connects two cities in Country B, it yields a score of $\\mathit{EB}_i$; otherwise, the road becomes useless and incurs a penalty of $\\mathit{EC}_i$.\n\nPlease find the optimal land division that maximizes the total score.", "inputFormat": "The first line contains two integers $N$, $M$, as described above.  \nThe next line contains $N - 2$ non-negative integers, representing $\\mathit{VA}_2,\\mathit{VA}_3,\\cdots,\\mathit{VA}_{N-1}$.  \nThe next line contains $N - 2$ non-negative integers, representing $\\mathit{VB}_2,\\mathit{VB}_3,\\cdots,\\mathit{VB}_{N-1}$.  \nThe next $M$ lines each contain five non-negative integers describing a road: $X, Y, \\mathit{EA}_i, \\mathit{EB}_i, \\mathit{EC}_i$, with meanings as described above.", "outputFormat": "Output exactly one integer, the maximum score.", "hint": "Constraints: $N \\le 10^4$, $M \\le 4 \\times 10^4$.\n\nIt is guaranteed that all intermediate values and the final result fit within the range of a 32-bit signed integer.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "土地划分", "background": "", "description": "$Y$ 国有 $N$ 座城市，并且有 $M$ 条双向公路将这些城市连接起来，并且任意两个城市至少有一条路径可以互达。$Y$ 国的国王去世之后，他的两个儿子 A 和 B 都想成为新的国王，但他们都想让这个国家更加安定，不会用武力解决问题。于是他们想将这个国家分成两个小国家 A 国和 B 国。现在，A 拥有 $1$ 号城市，B 拥有 $N$ 号城市，其他的城市还尚未确定归属哪边（划分之后的国家内部城市可以不连通）。由于大家都想让国家变得更好，而某些城市的人民愿意国王的 A 儿子作为他们的领袖，而某些城市更看好 B，而为了交通的便捷，如果划分后的公路连接两个同一个国家的城市，那么更利于城市之间的交流。于是大臣们设计了一种对土地划分的评分机制，具体如下：对于城市 $i$，如果它划分给 A 国，将得到 $\\mathit{VA}_i$ 的得分；划分给 B 国，将得到 $\\mathit{VB}_i$ 的得分。对于一条公路 $i$，如果它连接两个 A 国的城市，将得到 $\\mathit{EA}_i$ 的得分；连接两个 B 国的城市，将得到 $\\mathit{EB}_i$ 的得分；否则，这条公路将失去意义，将扣除 $\\mathit{EC}_i$ 的得分。现请你找到最优的土地划分，使得这种它的评分最高。", "inputFormat": "第一行包含两个整数 $N$，$M$，含义如问题描述所示。接下来一行 $N-2$ 个非负整数，表示 $\\mathit{VA}_2,\\mathit{VA}_3,\\cdots,\\mathit{VA}_{N-1}$。接下来一行 $N-2$ 个非负整数，表示 $\\mathit{VB}_2,\\mathit{VB}_3,\\cdots,\\mathit{VB}_{N-1}$。接下来 $M$ 行，每行五个非负整数描述一条公路：$X,Y,\\mathit{EA}_i,\\mathit{EB}_i,\\mathit{EC}_i$，含义如问题描述所示。", "outputFormat": "输出有且仅有一个整数，表示最高评分。", "hint": "对于全部数据，$n \\le 10^4$，$m \\le 4\\times 10^4$。\n\n保证运算过程中及最终结果不超过 $32$ 位带符号整数类型的表示范围。\n", "locale": "zh-CN"}}}
{"pid": "P4211", "type": "P", "difficulty": 6, "samples": [["5 2\n0\n0\n1\n1\n1 4 3\n1 4 2", "8\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "线段树", "各省省选", "辽宁", "最近公共祖先 LCA", "树链剖分", "差分", "离线处理"], "title": "[LNOI2014] LCA", "background": "", "description": "给出一个 $n$ 个节点的有根树（编号为 $0$ 到 $n-1$，根节点为 $0$）。\n\n一个点的深度定义为这个节点到根的距离 $+1$。 \n\n设 $dep[i]$ 表示点 $i$ 的深度，$\\operatorname{LCA}(i, j)$ 表示 $i$ 与 $j$ 的最近公共祖先。 \n\n有 $m$ 次询问，每次询问给出 $l, r, z$，求 $\\sum_{i=l}^r dep[\\operatorname{LCA}(i,z)]$ 。", "inputFormat": "第一行 $2$ 个整数，$n, m$。\n\n接下来 $n-1$ 行，分别表示点 $1$ 到点 $n-1$ 的父节点编号。\n\n接下来 $m$ 行，每行 $3$ 个整数，$l, r, z$。", "outputFormat": "输出 $m$ 行，每行表示一个询问的答案。每个答案对 $201314$ 取模输出。", "hint": "### 数据范围及约定\n\n- 对于 $20\\%$ 的数据，$n\\le 10000,m\\le 10000$；\n- 对于 $40\\%$ 的数据，$n\\le 20000,m\\le 20000$；\n- 对于 $60\\%$ 的数据，$n\\le 30000,m\\le 30000$；\n- 对于 $80\\%$ 的数据，$n\\le 40000,m\\le 40000$；\n- 对于 $100\\%$ 的数据，$1\\le n\\le 50000,1\\le m\\le 50000$。", "locale": "zh-CN", "translations": {"en": {"title": "[LNOI2014] LCA", "background": "", "description": "You are given a rooted tree with $n$ nodes (numbered from $0$ to $n - 1$), with root $0$.\n\nThe depth of a node is defined as its distance to the root $+1$.\n\nLet $dep[i]$ denote the depth of node $i$, and let $\\operatorname{LCA}(i, j)$ denote the lowest common ancestor of $i$ and $j$.\n\nThere are $m$ queries. For each query with given $l, r, z$, compute $\\sum_{i=l}^{r} dep[\\operatorname{LCA}(i, z)]$.", "inputFormat": "- The first line contains $2$ integers $n, m$.\n- The next $n - 1$ lines give parent indices: for each $i$ from $1$ to $n - 1$, the $i$-th of these lines contains the parent of node $i$.\n- The next $m$ lines each contain $3$ integers $l, r, z$.", "outputFormat": "Output $m$ lines. Each line contains the answer for one query, taken modulo $201314$.", "hint": "Constraints\n\n- For $20\\%$ of the testdata, $n \\le 10000$, $m \\le 10000$.\n- For $40\\%$ of the testdata, $n \\le 20000$, $m \\le 20000$.\n- For $60\\%$ of the testdata, $n \\le 30000$, $m \\le 30000$.\n- For $80\\%$ of the testdata, $n \\le 40000$, $m \\le 40000$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 50000$, $1 \\le m \\le 50000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[LNOI2014] LCA", "background": "", "description": "给出一个 $n$ 个节点的有根树（编号为 $0$ 到 $n-1$，根节点为 $0$）。\n\n一个点的深度定义为这个节点到根的距离 $+1$。 \n\n设 $dep[i]$ 表示点 $i$ 的深度，$\\operatorname{LCA}(i, j)$ 表示 $i$ 与 $j$ 的最近公共祖先。 \n\n有 $m$ 次询问，每次询问给出 $l, r, z$，求 $\\sum_{i=l}^r dep[\\operatorname{LCA}(i,z)]$ 。", "inputFormat": "第一行 $2$ 个整数，$n, m$。\n\n接下来 $n-1$ 行，分别表示点 $1$ 到点 $n-1$ 的父节点编号。\n\n接下来 $m$ 行，每行 $3$ 个整数，$l, r, z$。", "outputFormat": "输出 $m$ 行，每行表示一个询问的答案。每个答案对 $201314$ 取模输出。", "hint": "### 数据范围及约定\n\n- 对于 $20\\%$ 的数据，$n\\le 10000,m\\le 10000$；\n- 对于 $40\\%$ 的数据，$n\\le 20000,m\\le 20000$；\n- 对于 $60\\%$ 的数据，$n\\le 30000,m\\le 30000$；\n- 对于 $80\\%$ 的数据，$n\\le 40000,m\\le 40000$；\n- 对于 $100\\%$ 的数据，$1\\le n\\le 50000,1\\le m\\le 50000$。", "locale": "zh-CN"}}}
{"pid": "P4212", "type": "P", "difficulty": 5, "samples": [["4\n1 2\n2 3\n3 1\n1 4", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "枚举", "随机化", "状压 DP"], "title": "外太空旅行", "background": "", "description": "在人类的触角伸向银河系的边缘之际，普通人上太空旅行已经变得稀松平常了。某理科试验班有 $n$ 个人，现在班主任要从中选出尽量多的人去参加一次太空旅行活动。\n可是 $n$ 名同学并不是和平相处的。有的人，比如小 A 和小 B 整天狼狈为奸，是好朋友；但还有的人，比如（政治敏感）和（政治敏感）就水火不相容。这 $n$ 名同学，由于是理科生，都非常的理性，所以“朋友的朋友就是朋友”和“敌人的朋友就是敌人”这两句话对这些同学无效。换句话说，有可能小 A 和小 B 是朋友，小 B 和小 C 是朋友，但是小 A 和小 C 两人势如水火。  \n任意两个人之间要不就是敌人，要不就是朋友。  \n因为在太空船上发生人员斗殴事件是很恶劣也很危险的，因此选出来参加旅行活动的同学必须互相之间都是朋友。你的任务就是确定最多可以选多少人参加旅行。", "inputFormat": "第一行一个整数 $n(1 \\le n \\le 50)$。所有的同学按照 $1 \\sim n$ 编号。  \n接下来若干行，每行两个用空格隔开的整数 $a, b(1 \\le a,b \\le n)$，表示 $a$ 和 $b$ 是朋友。\n注意：如果一个数对 $(x,y)$（或者 $(y,x)$）没有在文件中出现，那么编号为 $x$ 和 $y$ 的两个同学就是敌人。", "outputFormat": "一个数，即最多可以选多少人参加活动。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Outer Space Travel", "background": "", "description": "As humanity reaches the edge of the Milky Way, it has become commonplace for ordinary people to travel to space. In a science experimental class, there are $n$ people, and the homeroom teacher wants to select as many of them as possible to go on a space trip.\n\nHowever, the $n$ students do not all get along. Some people, such as Xiao A and Xiao B, are always together and are good friends; but others, such as (politically sensitive) and (politically sensitive), are incompatible. These $n$ students, being science students, are very rational, so the two statements “a friend of a friend is a friend” and “an enemy’s friend is an enemy” do not hold for them. In other words, it is possible that Xiao A and Xiao B are friends, Xiao B and Xiao C are friends, but Xiao A and Xiao C are sworn enemies.\n\nFor any two people, they are either enemies or friends. Because fights on a spaceship are very bad and dangerous, the selected students must be pairwise friends. Your task is to determine the maximum number of people who can be selected to participate.", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 50$). All students are numbered 1 to $n$.  \nThen follow several lines, each containing two space-separated integers $a$, $b$ ($1 \\le a, b \\le n$), indicating that $a$ and $b$ are friends.  \nNote: If a pair $(x, y)$ (or $(y, x)$) does not appear in the file, then students $x$ and $y$ are enemies.", "outputFormat": "A single integer, the maximum number of students that can be selected.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "外太空旅行", "background": "", "description": "在人类的触角伸向银河系的边缘之际，普通人上太空旅行已经变得稀松平常了。某理科试验班有 $n$ 个人，现在班主任要从中选出尽量多的人去参加一次太空旅行活动。\n可是 $n$ 名同学并不是和平相处的。有的人，比如小 A 和小 B 整天狼狈为奸，是好朋友；但还有的人，比如（政治敏感）和（政治敏感）就水火不相容。这 $n$ 名同学，由于是理科生，都非常的理性，所以“朋友的朋友就是朋友”和“敌人的朋友就是敌人”这两句话对这些同学无效。换句话说，有可能小 A 和小 B 是朋友，小 B 和小 C 是朋友，但是小 A 和小 C 两人势如水火。  \n任意两个人之间要不就是敌人，要不就是朋友。  \n因为在太空船上发生人员斗殴事件是很恶劣也很危险的，因此选出来参加旅行活动的同学必须互相之间都是朋友。你的任务就是确定最多可以选多少人参加旅行。", "inputFormat": "第一行一个整数 $n(1 \\le n \\le 50)$。所有的同学按照 $1 \\sim n$ 编号。  \n接下来若干行，每行两个用空格隔开的整数 $a, b(1 \\le a,b \\le n)$，表示 $a$ 和 $b$ 是朋友。\n注意：如果一个数对 $(x,y)$（或者 $(y,x)$）没有在文件中出现，那么编号为 $x$ 和 $y$ 的两个同学就是敌人。", "outputFormat": "一个数，即最多可以选多少人参加活动。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4213", "type": "P", "difficulty": 6, "samples": [["6\n1\n2\n8\n13\n30\n2333", "1 1\n2 0\n22 -2\n58 -3\n278 -3\n1655470 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "杜教筛", "模板题"], "title": "【模板】杜教筛", "background": "", "description": "给定一个正整数 $n$，求\n\n$$ans_1=\\sum_{i=1}^n\\varphi(i)$$\n\n$$ans_2=\\sum_{i=1}^n \\mu(i)$$", "inputFormat": "**本题单测试点内有多组数据**。\n\n输入的第一行为一个整数，表示数据组数 $T$。\n\n接下来 $T$ 行，每行一个整数 $n$，表示一组询问。", "outputFormat": "对于每组询问，输出一行两个整数，分别代表 $ans_1$ 和 $ans_2$。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq T \\leq 10$，$1 \\leq n \\lt 2^{31}$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Du Jiao Sieve", "background": "", "description": "Given a positive integer $n$, compute\n\n$$ans_1=\\sum_{i=1}^n\\varphi(i)$$\n\n$$ans_2=\\sum_{i=1}^n \\mu(i)$$", "inputFormat": "**This problem contains multiple test cases within a single test file.**\n\nThe first line contains an integer, denoting the number of test cases $T$.\n\nThen $T$ lines follow, each containing an integer $n$, representing one query.", "outputFormat": "For each query, output two integers in one line, representing $ans_1$ and $ans_2$.", "hint": "#### Constraints\n\nFor all test cases, it is guaranteed that $1 \\leq T \\leq 10$, $1 \\leq n \\lt 2^{31}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】杜教筛", "background": "", "description": "给定一个正整数 $n$，求\n\n$$ans_1=\\sum_{i=1}^n\\varphi(i)$$\n\n$$ans_2=\\sum_{i=1}^n \\mu(i)$$", "inputFormat": "**本题单测试点内有多组数据**。\n\n输入的第一行为一个整数，表示数据组数 $T$。\n\n接下来 $T$ 行，每行一个整数 $n$，表示一组询问。", "outputFormat": "对于每组询问，输出一行两个整数，分别代表 $ans_1$ 和 $ans_2$。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq T \\leq 10$，$1 \\leq n \\lt 2^{31}$。", "locale": "zh-CN"}}}
{"pid": "P4214", "type": "P", "difficulty": 6, "samples": [["6 8\n1 3\n2 3\n4 1\n5 6\n2 6\n5 1\n6 4\n5 3", "36"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "Tarjan", "双连通分量", "最小割", "ICPC", "CERC"], "title": "[CERC2015] Juice Junctions", "background": "", "description": "你被雇佣升级一个旧果汁加工厂的橙汁运输系统。系统有管道和节点构成。每条管道都是双向的，且每条管道的流量都是 $1$ 升每秒。管道可能连接节点，每个节点最多可以连接 $3$ 条管道。节点的流量是无限的。节点用整数 $1$ 到 $n$ 来表示。在升级系统之前，你需要对现有系统进行分析。对于两个不同节点 $s$ 和 $t$，$s-t$ 的流量被定义为：当 $s$ 为源点，$t$ 为汇点，从 $s$ 能流向 $t$ 的最大流量。\n\n以下面的第一组样例数据为例，$1-6$ 的流量为 $3$，$1-2$ 的流量为 $2$。\n\n计算每一对满足 $a<b$ 的节点 $a-b$ 的流量的和。", "inputFormat": "第一行包括 $2$ 个整数 $n$ 和 $m$（$2\\leq n\\leq 3\\times 10^3$，$0\\leq m\\leq 4500$），表示节点数和管道数。\n\n接下来 $m$ 行，每行包括两个相异整数 $a,b$（$1\\leq a,b\\leq n$），表示一条管道连接节点 $a,b$。\n\n每个节点最多连接 $3$ 条管道，每对节点最多被一条管道连接。", "outputFormat": "输出一个整数——每对满足 $a<b$ 的节点 $a-b$ 的流量之和。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[CERC2015] Juice Junctions", "background": "", "description": "You are hired to upgrade an old juice factory’s orange juice transport system. The system consists of pipes and nodes. Each pipe is bidirectional, and each pipe has a flow rate of $1$ liter per second. Pipes connect nodes, and each node can be connected to at most $3$ pipes. Nodes have infinite capacity. Nodes are labeled by integers $1$ through $n$. Before the upgrade, you need to analyze the existing system. For two distinct nodes $s$ and $t$, the $s$–$t$ flow is defined as the maximum flow from $s$ to $t$ when $s$ is the source and $t$ is the sink.\n\nIn the first sample below, the flow from $1$ to $6$ is $3$, and the flow from $1$ to $2$ is $2$.\n\nCompute the sum of $a$–$b$ flows over all pairs of nodes with $a < b$.", "inputFormat": "The first line contains $2$ integers $n$ and $m$ ($2\\leq n\\leq 3\\times 10^3$, $0\\leq m\\leq 4500$), denoting the number of nodes and the number of pipes.\n\nEach of the next $m$ lines contains two distinct integers $a,b$ ($1\\leq a,b\\leq n$), indicating that there is a pipe connecting nodes $a$ and $b$.\n\nEach node is incident to at most $3$ pipes, and there is at most one pipe between any pair of nodes.", "outputFormat": "Output a single integer: the sum of $a$–$b$ flows over all pairs with $a<b$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2015] Juice Junctions", "background": "", "description": "你被雇佣升级一个旧果汁加工厂的橙汁运输系统。系统有管道和节点构成。每条管道都是双向的，且每条管道的流量都是 $1$ 升每秒。管道可能连接节点，每个节点最多可以连接 $3$ 条管道。节点的流量是无限的。节点用整数 $1$ 到 $n$ 来表示。在升级系统之前，你需要对现有系统进行分析。对于两个不同节点 $s$ 和 $t$，$s-t$ 的流量被定义为：当 $s$ 为源点，$t$ 为汇点，从 $s$ 能流向 $t$ 的最大流量。\n\n以下面的第一组样例数据为例，$1-6$ 的流量为 $3$，$1-2$ 的流量为 $2$。\n\n计算每一对满足 $a<b$ 的节点 $a-b$ 的流量的和。", "inputFormat": "第一行包括 $2$ 个整数 $n$ 和 $m$（$2\\leq n\\leq 3\\times 10^3$，$0\\leq m\\leq 4500$），表示节点数和管道数。\n\n接下来 $m$ 行，每行包括两个相异整数 $a,b$（$1\\leq a,b\\leq n$），表示一条管道连接节点 $a,b$。\n\n每个节点最多连接 $3$ 条管道，每对节点最多被一条管道连接。", "outputFormat": "输出一个整数——每对满足 $a<b$ 的节点 $a-b$ 的流量之和。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4215", "type": "P", "difficulty": 6, "samples": [["5 3\n1 1 1 1 1\n5 5\n2 2\n1 3\n5 \n4 \n2 \n5 \n2 \n3", "0 \n1 \n1 \n2 \n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树"], "title": "踩气球", "background": null, "description": "六一儿童节到了，SHUXK 被迫陪着 $m$ 个熊孩子玩一个无聊的游戏：有 $n$ 个盒子从左到右排成一排，第 $i$ 个盒子里装着 $a_i$ 个气球。\n\nSHUXK 要进行 $Q$ 次操作，每次从某一个盒子里拿出一个没被踩爆的气球，然后熊孩子们就会立刻把它踩爆。\n\n这 $m$ 个熊孩子每个人都指定了一个盒子区间 $[l_i,r_i]$。如果某一个时刻，一个熊孩子发现自己选定的盒子区间 $[l_i,r_i]$ 中的所有气球都已经被踩爆了，他就会非常高兴（显然之后他一直会很高兴）。\n\n为了不辜负将自己的任务强行塞给 SHUXK 的那个人的期望，SHUXK 想向你询问：\n\n- 他每次操作过后会有多少个熊孩子很高兴。", "inputFormat": "第一行包含两个正整数 $n$ 和 $m$，分别表示盒子和熊孩子的个数。\n\n第二行包含 $n$ 个正整数 $a_i$（$1 \\le a_i \\le 10^5$），表示每个盒子里气球的数量。\n\n以下 $m$ 行每行包含两个正整数 $l_i,r_i$（$1 \\le l_i \\le r_i \\le n$），分别表示每一个熊孩子指定的区间。\n\n以下一行包含一个正整数 $Q$，表示 SHUXK 操作的次数。\n\n以下 $Q$ 行每行包含一个正整数 $x$，表示这次操作是从第 $x$ 个盒子里拿气球。为了体现在线，我们对输入的 $x$ 进行了加密。\n\n假设输入的正整数是 $\\hat{x}$，那么真正的 $x=(\\hat{x}+\\mathit{lastans}-1)\\bmod n+1$。其中 $\\mathit{lastans}$ 为上一次询问的答案。对于第一个询问，$\\mathit{lastans}=0$。", "outputFormat": "包含 $Q$ 行，每行输出一个整数，表示 SHUXK 一次操作后询问的答案。答案的顺序应与输入数据的顺序保持一致。", "hint": "### 数据范围及约定\n\n对于全部数据，$1\\le n \\le 10^5$，$1\\le m \\le 10^5$，$1\\le Q \\le 10^5$。\n\n输入数据保证 $1 \\le \\hat{x} \\le 10^9$，且第 $x$ 个盒子中有尚未被踩爆的气球。", "locale": "zh-CN", "translations": {"en": {"title": "Popping Balloons", "background": "", "description": "Children’s Day has arrived, and SHUXK is forced to play a boring game with $m$ kids: there are $n$ boxes lined up from left to right, and the $i$-th box contains $a_i$ balloons.\n\nSHUXK will perform $Q$ operations. In each operation, he takes one unpopped balloon from some box, and the kids immediately pop it.\n\nEach of the $m$ kids has specified an interval of boxes $[l_i, r_i]$. If at any moment a kid finds that all balloons in their chosen interval $[l_i, r_i]$ have been popped, they become very happy (and will remain happy thereafter).\n\nTo live up to the expectations of the person who dumped this task on SHUXK, he asks you:\n\n- After each operation, how many kids are happy?", "inputFormat": "The first line contains two positive integers $n$ and $m$, the numbers of boxes and kids, respectively.\n\nThe second line contains $n$ positive integers $a_i$ ($1 \\le a_i \\le 10^5$), the number of balloons in each box.\n\nEach of the following $m$ lines contains two positive integers $l_i, r_i$ ($1 \\le l_i \\le r_i \\le n$), the interval specified by each kid.\n\nThe next line contains a positive integer $Q$, the number of operations SHUXK performs.\n\nEach of the following $Q$ lines contains a positive integer $x$, indicating that this operation takes a balloon from the $x$-th box. To enforce online queries, the input $x$ is encrypted.\n\nLet the given positive integer be $\\hat{x}$; then the real $x=(\\hat{x}+\\mathit{lastans}-1)\\bmod n+1$, where $\\mathit{lastans}$ is the answer to the previous query. For the first query, $\\mathit{lastans}=0$.", "outputFormat": "Output $Q$ lines. Each line should contain one integer, the answer to SHUXK’s question after a single operation. The answers must be in the same order as the input queries.", "hint": "Constraints and Conventions\n\nFor all data, $1 \\le n \\le 10^5$, $1 \\le m \\le 10^5$, $1 \\le Q \\le 10^5$.\n\nThe testdata guarantees $1 \\le \\hat{x} \\le 10^9$, and that the $x$-th box always has at least one unpopped balloon.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "踩气球", "background": null, "description": "六一儿童节到了，SHUXK 被迫陪着 $m$ 个熊孩子玩一个无聊的游戏：有 $n$ 个盒子从左到右排成一排，第 $i$ 个盒子里装着 $a_i$ 个气球。\n\nSHUXK 要进行 $Q$ 次操作，每次从某一个盒子里拿出一个没被踩爆的气球，然后熊孩子们就会立刻把它踩爆。\n\n这 $m$ 个熊孩子每个人都指定了一个盒子区间 $[l_i,r_i]$。如果某一个时刻，一个熊孩子发现自己选定的盒子区间 $[l_i,r_i]$ 中的所有气球都已经被踩爆了，他就会非常高兴（显然之后他一直会很高兴）。\n\n为了不辜负将自己的任务强行塞给 SHUXK 的那个人的期望，SHUXK 想向你询问：\n\n- 他每次操作过后会有多少个熊孩子很高兴。", "inputFormat": "第一行包含两个正整数 $n$ 和 $m$，分别表示盒子和熊孩子的个数。\n\n第二行包含 $n$ 个正整数 $a_i$（$1 \\le a_i \\le 10^5$），表示每个盒子里气球的数量。\n\n以下 $m$ 行每行包含两个正整数 $l_i,r_i$（$1 \\le l_i \\le r_i \\le n$），分别表示每一个熊孩子指定的区间。\n\n以下一行包含一个正整数 $Q$，表示 SHUXK 操作的次数。\n\n以下 $Q$ 行每行包含一个正整数 $x$，表示这次操作是从第 $x$ 个盒子里拿气球。为了体现在线，我们对输入的 $x$ 进行了加密。\n\n假设输入的正整数是 $\\hat{x}$，那么真正的 $x=(\\hat{x}+\\mathit{lastans}-1)\\bmod n+1$。其中 $\\mathit{lastans}$ 为上一次询问的答案。对于第一个询问，$\\mathit{lastans}=0$。", "outputFormat": "包含 $Q$ 行，每行输出一个整数，表示 SHUXK 一次操作后询问的答案。答案的顺序应与输入数据的顺序保持一致。", "hint": "### 数据范围及约定\n\n对于全部数据，$1\\le n \\le 10^5$，$1\\le m \\le 10^5$，$1\\le Q \\le 10^5$。\n\n输入数据保证 $1 \\le \\hat{x} \\le 10^9$，且第 $x$ 个盒子中有尚未被踩爆的气球。", "locale": "zh-CN"}}}
{"pid": "P4216", "type": "P", "difficulty": 6, "samples": [["7\n0 1 1 2 2 3 3 \n6\n1 4 7 0\n2 1\n2 4\n2 7\n1 4 7 1\n1 4 7 3", "5 0\n5 2\n5 1"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2015", "四川", "线段树", "各省省选", "平衡树", "树链剖分", "可持久化线段树"], "title": "[SCOI2015] 情报传递", "background": null, "description": "奈特公司是一个巨大的情报公司，它有着庞大的情报网络。情报网络中共有 $n$ 名情报员。每名情报员可能有若干名 (可能没有) 下线，除 $1$ 名大头目外其余 $n-1$ 名情报员有且仅有 $1$ 名上线。奈特公司纪律森严，每名情报员只能与自己的上、下线联系，同时，情报网络中任意两名情报员一定能够通过情报网络传递情报。\n\n奈特公司每天会派发以下两种任务中的一个任务：\n\n1. 搜集情报：指派 $T$ 号情报员搜集情报；\n2. 传递情报：将一条情报从 $X$ 号情报员传递给 $Y$ 号情报员。\n\n情报员最初处于潜伏阶段，他们是相对安全的，我们认为此时所有情报员的危险值为 $0$；一旦某个情报员开始搜集情报，他的危险值就会持续增加，每天增加 $1$ 点危险值 (开始搜集情报的当天危险值仍为 $0$，第 $2$ 天危险值为 $1$，第 $3$ 天危险值为 $2$，以此类推)。传递情报并不会使情报员的危险值增加。\n\n为了保证传递情报的过程相对安全，每条情报都有一个风险控制值 $C$。奈特公司认为，参与传递这条情报的所有情报员中，危险值大于 $C$ 的情报员将对该条情报构成威胁。现在，奈特公司希望知道，对于每个传递情报任务，参与传递的情报员有多少个，其中对该条情报构成威胁的情报员有多少个。", "inputFormat": "第一行包含一个正整数 $n$，表示情报员个数。\n笫二行包含 $n$ 个非负整数，其中第 $i$ 个整数 $P_i$ 表示 $i$ 号情报员上线的编号。特别地，若 $P_i=0$，表示 $i$ 号情报员是大头目。\n第三行包含一个正整数 $q$，表示奈特公司将派发 $q$ 个任务 (每天一个)。\n\n随后 $q$ 行，依次描述 $q$ 个任务。每行首先有一个正整数 $k$。\n\n- 若 $k=1$，表示任务是传递情报，随后有三个正整数 $X_i$、$Y_i$、$C_i$，依次表示传递情报的起点、终点和风险控制值。\n- 若 $k=2$，表示任务是搜集情报，随后有 $1$ 个正整数 $T_i$，表示搜集情报的情报员编号。", "outputFormat": "对于每个传递情报任务输出一行，包含两个整数，分别是参与传递情报的情报员个数和对该条情报构成威胁的情报员个数。", "hint": "样例解释：\n\n对于 $3$ 个传递情报任务，都是经过 $5$ 名情报员，分别是 $4$ 号、$2$ 号、$1$ 号、$3$ 号和 $7$ 号。\n\n- 第 $1$ 个任务，所有情报员 (危险值为 $0$) 都不对情报构成威胁；\n- 第 $2$ 个任务，有 $2$ 名情报员对情报构成威胁，分别是 $1$ 号情报员 (危险值为 $3$) 和 $4$ 号情报员 (危险值为 $2$)，$7$ 号情报员 (危险值为 $1$) 并不构成威胁；\n- 第 $3$ 个任务，只有 $1$ 名情报员对情报构成威胁。\n\n数据范围：\n\n$n\\leqslant 2\\times 10^5,Q\\leqslant 2\\times 10^5,0\\le P_i,C_i\\leqslant N,1\\leqslant T_i,X_i,Y_i\\leqslant n$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2015] Intelligence Transmission", "background": "", "description": "Knight Company is a huge intelligence organization with a vast intelligence network. There are $n$ agents in the network. Each agent may have several (possibly none) subordinates. Except for one boss, each of the remaining $n-1$ agents has exactly one supervisor. The company has strict discipline: each agent may contact only their own supervisor and subordinates. Meanwhile, any two agents can pass intelligence through the network.\n\nEach day, the company assigns exactly one of the following two tasks:\n\n1. Collect intelligence: designate agent $T$ to start collecting intelligence.\n2. Transmit intelligence: transmit a piece of intelligence from agent $X$ to agent $Y$.\n\nInitially, all agents are in a dormant stage and are relatively safe; we consider their danger values to be $0$. Once an agent starts collecting intelligence, their danger value keeps increasing by $1$ per day (on the starting day, the danger value is still $0$; on the 2nd day it is $1$; on the 3rd day it is $2$; and so on). Transmission tasks do not increase any agent’s danger value.\n\nTo ensure safety during transmission, each piece of intelligence has a risk control value $C$. Among all agents who participate in transmitting this piece (i.e., those on the unique path between $X$ and $Y$, inclusive), any agent whose danger value is greater than $C$ is considered a threat to this piece.\n\nFor every transmission task, determine how many agents participate in the transmission and how many of them constitute a threat to this piece.", "inputFormat": "- The first line contains a positive integer $n$, the number of agents.\n- The second line contains $n$ non-negative integers. The $i$-th integer $P_i$ denotes the supervisor of agent $i$. In particular, if $P_i = 0$, agent $i$ is the boss.\n- The third line contains a positive integer $q$, the number of tasks (one per day).\n- The next $q$ lines each describe a task. Each line starts with a positive integer $k$:\n  - If $k = 1$, it is a transmission task, followed by three positive integers $X_i$, $Y_i$, $C_i$, denoting the start, the end, and the risk control value, respectively.\n  - If $k = 2$, it is a collection task, followed by one positive integer $T_i$, the agent who starts collecting intelligence.", "outputFormat": "For each transmission task, output one line containing two integers: the number of participating agents and the number of agents who constitute a threat to this piece of intelligence.", "hint": "Sample explanation:\n\nFor the $3$ transmission tasks, each passes through $5$ agents, namely $4$, $2$, $1$, $3$, and $7$.\n\n- In the 1st task, all agents (danger value $0$) do not constitute a threat.\n- In the 2nd task, there are $2$ threatening agents: agent $1$ (danger value $3$) and agent $4$ (danger value $2$). Agent $7$ (danger value $1$) is not a threat.\n- In the 3rd task, only $1$ agent is a threat.\n\nConstraints:\n\n$n \\le 2 \\times 10^5$, $q \\le 2 \\times 10^5$, $0 \\le P_i, C_i \\le n$, $1 \\le T_i, X_i, Y_i \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2015] 情报传递", "background": null, "description": "奈特公司是一个巨大的情报公司，它有着庞大的情报网络。情报网络中共有 $n$ 名情报员。每名情报员可能有若干名 (可能没有) 下线，除 $1$ 名大头目外其余 $n-1$ 名情报员有且仅有 $1$ 名上线。奈特公司纪律森严，每名情报员只能与自己的上、下线联系，同时，情报网络中任意两名情报员一定能够通过情报网络传递情报。\n\n奈特公司每天会派发以下两种任务中的一个任务：\n\n1. 搜集情报：指派 $T$ 号情报员搜集情报；\n2. 传递情报：将一条情报从 $X$ 号情报员传递给 $Y$ 号情报员。\n\n情报员最初处于潜伏阶段，他们是相对安全的，我们认为此时所有情报员的危险值为 $0$；一旦某个情报员开始搜集情报，他的危险值就会持续增加，每天增加 $1$ 点危险值 (开始搜集情报的当天危险值仍为 $0$，第 $2$ 天危险值为 $1$，第 $3$ 天危险值为 $2$，以此类推)。传递情报并不会使情报员的危险值增加。\n\n为了保证传递情报的过程相对安全，每条情报都有一个风险控制值 $C$。奈特公司认为，参与传递这条情报的所有情报员中，危险值大于 $C$ 的情报员将对该条情报构成威胁。现在，奈特公司希望知道，对于每个传递情报任务，参与传递的情报员有多少个，其中对该条情报构成威胁的情报员有多少个。", "inputFormat": "第一行包含一个正整数 $n$，表示情报员个数。\n笫二行包含 $n$ 个非负整数，其中第 $i$ 个整数 $P_i$ 表示 $i$ 号情报员上线的编号。特别地，若 $P_i=0$，表示 $i$ 号情报员是大头目。\n第三行包含一个正整数 $q$，表示奈特公司将派发 $q$ 个任务 (每天一个)。\n\n随后 $q$ 行，依次描述 $q$ 个任务。每行首先有一个正整数 $k$。\n\n- 若 $k=1$，表示任务是传递情报，随后有三个正整数 $X_i$、$Y_i$、$C_i$，依次表示传递情报的起点、终点和风险控制值。\n- 若 $k=2$，表示任务是搜集情报，随后有 $1$ 个正整数 $T_i$，表示搜集情报的情报员编号。", "outputFormat": "对于每个传递情报任务输出一行，包含两个整数，分别是参与传递情报的情报员个数和对该条情报构成威胁的情报员个数。", "hint": "样例解释：\n\n对于 $3$ 个传递情报任务，都是经过 $5$ 名情报员，分别是 $4$ 号、$2$ 号、$1$ 号、$3$ 号和 $7$ 号。\n\n- 第 $1$ 个任务，所有情报员 (危险值为 $0$) 都不对情报构成威胁；\n- 第 $2$ 个任务，有 $2$ 名情报员对情报构成威胁，分别是 $1$ 号情报员 (危险值为 $3$) 和 $4$ 号情报员 (危险值为 $2$)，$7$ 号情报员 (危险值为 $1$) 并不构成威胁；\n- 第 $3$ 个任务，只有 $1$ 名情报员对情报构成威胁。\n\n数据范围：\n\n$n\\leqslant 2\\times 10^5,Q\\leqslant 2\\times 10^5,0\\le P_i,C_i\\leqslant N,1\\leqslant T_i,X_i,Y_i\\leqslant n$。", "locale": "zh-CN"}}}
{"pid": "P4217", "type": "P", "difficulty": 7, "samples": [["4\n3 2 1 2\n2 5 2 2\n5 1 5 5\n1 2 1\n5 3 3", "30"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2010", "线段树", "模拟费用流", "CTSC/CTS"], "title": "[CTSC2010] 产品销售", "background": "", "description": "A 公司正在热销某计算机产品，作为 A 公司 CEO 的小 A 打算为接下来连续的 $N$ 个销售季度制定一份具体的生产和销售方案。 已知第 $i$ 个销售季度该产品的订购量为 $D_i$，在第 $i$ 个季度，A 公司会通过如下几种方式来解决用户的订购需求：\n\n- 在第 $i$ 个季度生产新的产品来销售。\n- 若在第 $i$ 个季度以前库存还有多余的产品，则可以直接在第 $i$ 个季度销售（注意第一个季度之前没有任何库存产品）。\n- 在第 $i$ 个季度可以不完成全部的订购需求，而将未完成的订购需求推迟，归入到下一个季度 $(i + 1)$ 的产品订购需求中。\n\nA 公司需要考虑以下几种耗费： 生产新产品的成本耗费、库存产品的额外储存耗费以及推迟订购需求而需要赔偿给用户的损失费。另外由于劳力和资源的限制，每个销售季度能够生产新产品的数量是有限的，各季度的耗费和可以生产的产品上限数也不尽相同，具体如下：\n\n- 在第 $i$ 个季度最多可以生产 $U_i$ 件新的产品，每一件的成本为 $P_i$。\n- 第 $i$ 个季度保存下来的产品，可以用于以后季度的销售。对于每一件产品，若从第 $i$ 季度保存到第 $i + 1$ 季度， 需要额外支付 $M_i$ 的存储费用（注意产品保存到下个季度后可能再次库存）。\n- 对于第 $i$ 个季度需要推迟而归入到下一个季度订购需求的每一件产品，A 公司需要赔偿给用户损失费 $C_i$（注意延迟到下个季度可能再次被延迟, 费用按后面季度的延迟费用计）。\n\n在第 $N$ 个季度结束后， A 公司必须解决之前所有的用户订单。可以保证， A公司能够生产的产品总数不会低于总订购量， 也就是说一定存在一组生产和销售方案使得满足所有的用户订购需求。小 A 想知道如何来安排产品的生产和销售，使得在满足所有订购需求的前提下公司总的耗费最小。", "inputFormat": "输入文件 $\\tt{product.in}$ 第一行是一个正整数 $N$，表示有 $N$ 个销售季度。\n\n第二行有 $N$ 个非负整数 $D_1,D_2,\\ldots,D_N$，表示第 $i$ 个季度的订购量。\n\n第三行有 $N$ 个非负整数 $U_1,U_2, \\ldots, U_N$，表示第 $i$ 个季度最多可以生产的新的产品数。\n\n第四行有 $N$ 个非负整数 $P_1, P_2, \\ldots, P_N$，表示第 $i$ 个季度生产一件新产品的成本。\n\n第五行有 $N - 1$ 个非负整数 $M_1, M_2,\\ldots,M_{N-1}$，表示将一件产品从第 $i$ 个季度保存到第 $i +1$ 个季度所需要的额外的耗费。\n\n第六行有 $N-1$ 个非负整数 $C_1, C_2, \\ldots, C_{N-1}$，表示一件产品的订购需求在第 $i$ 个季度没有完成而归入到第 $i +1$ 个季度的订购量中，需要赔偿给用户的损失费。", "outputFormat": "输出文件 $\\tt{product.out}$ 仅包含一个非负整数，表示公司的最小总耗费。", "hint": "【样例说明】\n\n第一个季度生产 $2$ 件产品，第二个季度生产 $5$ 件产品，第三个季度不生产产品，第四个季度生产 $1$ 件产品，成本为 $2 * 5 + 5 * 1 + 0 * 5 + 1 * 5 = 20$。\n\n因为第一个季度最多只能生产 $2$ 件产品，无法满足 $3$ 件的订购量，因此将 $1$件产品的订购量推迟到第二个季度，赔偿给用户的损失费为 $5$。\n\n第二个季度由于第一个季度推迟了一件产品的订购需求， 因而订购量变为 $3$。该季度生产了 $5$ 件产品，剩下的 $2$ 件保存下来。第三个季度直接销售库存的产品，再多出来的 $1$ 件产品继续储存到第四个季度，加上第四个季度生产了 $1$ 件产品，因此满足了所有订单需求。总的储存费用为 $2 * 2 + 1 * 1 = 5$。\n\n总的费用为 $20 + 5 + 5 = 30$。\n\n【数据规模】\n\n对于 $30\\%$的数据， $N \\leq 1,000$。\n\n对于 $100\\%$的数据， $1 \\leq N \\leq 100,000$， $1 \\leq D_i, U_i, P_i, M_i,C_i \\leq  10,000$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2010] Product Sales", "background": "", "description": "Company A is seeing strong sales of a certain computer product. As the CEO of Company A, Xiao A plans to make a detailed production and sales plan for the next consecutive $N$ sales quarters. It is known that in the $i$-th sales quarter the order quantity is $D_i$. In quarter $i$, Company A may meet the orders in the following ways:\n- Produce new products in quarter $i$ to sell.\n- If there is remaining inventory before quarter $i$, it can be sold directly in quarter $i$ (note that there is no inventory before the first quarter).\n- In quarter $i$, it is allowed to leave part of the orders unfilled and postpone them, merging them into the order quantity of the next quarter $(i + 1)$.\n\nCompany A needs to consider the following costs: the production cost for new products, the additional storage cost for inventory, and the compensation paid to users for delayed orders. Moreover, due to labor and resource limitations, the number of new products that can be produced in each sales quarter is limited, and both the costs and production upper bounds differ by quarter, as follows:\n- In quarter $i$, at most $U_i$ new units can be produced, and the cost per unit is $P_i$.\n- Products kept at the end of quarter $i$ for use in later quarters incur a storage fee: for each unit kept from quarter $i$ to quarter $i + 1$, an extra fee of $M_i$ must be paid (note that once kept to the next quarter, the product may remain in inventory again).\n- For each unit postponed from quarter $i$ and merged into the next quarter’s order quantity, Company A must compensate users $C_i$ (note that an order postponed to the next quarter may be postponed again, and the fee is charged according to the later quarter’s delay fee).\n\nBy the end of quarter $N$, Company A must have fulfilled all user orders. It is guaranteed that the total number of units the company can produce is not less than the total order quantity; that is, there exists at least one production and sales plan that satisfies all orders. Xiao A wants to know how to arrange production and sales so that, while satisfying all orders, the total cost is minimized.", "inputFormat": "The first line of the input file $\\tt{product.in}$ contains a positive integer $N$, the number of sales quarters.\n\nThe second line contains $N$ non-negative integers $D_1, D_2, \\ldots, D_N$, where $D_i$ is the order quantity in quarter $i$.\n\nThe third line contains $N$ non-negative integers $U_1, U_2, \\ldots, U_N$, where $U_i$ is the maximum number of new units that can be produced in quarter $i$.\n\nThe fourth line contains $N$ non-negative integers $P_1, P_2, \\ldots, P_N$, where $P_i$ is the per-unit production cost in quarter $i$.\n\nThe fifth line contains $N - 1$ non-negative integers $M_1, M_2, \\ldots, M_{N-1}$, where $M_i$ is the additional storage fee to keep one unit from quarter $i$ to quarter $i + 1$.\n\nThe sixth line contains $N - 1$ non-negative integers $C_1, C_2, \\ldots, C_{N-1}$, where $C_i$ is the compensation paid if one unit’s order is not fulfilled in quarter $i$ and is merged into the order quantity of quarter $i + 1$.", "outputFormat": "The output file $\\tt{product.out}$ contains a single non-negative integer, the minimal total cost.", "hint": "Sample Explanation:\n\nIn the first quarter, produce $2$ units. In the second quarter, produce $5$ units. In the third quarter, produce no units. In the fourth quarter, produce $1$ unit. The production cost is $2 * 5 + 5 * 1 + 0 * 5 + 1 * 5 = 20$.\n\nSince at most $2$ units can be produced in the first quarter, the $3$-unit order cannot be fully met; thus $1$ unit is postponed to the second quarter, incurring a compensation of $5$.\n\nIn the second quarter, because $1$ unit was postponed from the first quarter, the order quantity becomes $3$. This quarter produces $5$ units, leaving $2$ units in inventory. In the third quarter, sell directly from inventory; the extra $1$ unit is further stored to the fourth quarter. Together with producing $1$ unit in the fourth quarter, all orders are satisfied. The total storage cost is $2 * 2 + 1 * 1 = 5$.\n\nThe total cost is $20 + 5 + 5 = 30$.\n\nConstraints:\n\n- For $30\\%$ of the testdata, $N \\leq 1{,}000$.\n- For $100\\%$ of the testdata, $1 \\leq N \\leq 100{,}000$, $1 \\leq D_i, U_i, P_i, M_i, C_i \\leq 10{,}000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2010] 产品销售", "background": "", "description": "A 公司正在热销某计算机产品，作为 A 公司 CEO 的小 A 打算为接下来连续的 $N$ 个销售季度制定一份具体的生产和销售方案。 已知第 $i$ 个销售季度该产品的订购量为 $D_i$，在第 $i$ 个季度，A 公司会通过如下几种方式来解决用户的订购需求：\n\n- 在第 $i$ 个季度生产新的产品来销售。\n- 若在第 $i$ 个季度以前库存还有多余的产品，则可以直接在第 $i$ 个季度销售（注意第一个季度之前没有任何库存产品）。\n- 在第 $i$ 个季度可以不完成全部的订购需求，而将未完成的订购需求推迟，归入到下一个季度 $(i + 1)$ 的产品订购需求中。\n\nA 公司需要考虑以下几种耗费： 生产新产品的成本耗费、库存产品的额外储存耗费以及推迟订购需求而需要赔偿给用户的损失费。另外由于劳力和资源的限制，每个销售季度能够生产新产品的数量是有限的，各季度的耗费和可以生产的产品上限数也不尽相同，具体如下：\n\n- 在第 $i$ 个季度最多可以生产 $U_i$ 件新的产品，每一件的成本为 $P_i$。\n- 第 $i$ 个季度保存下来的产品，可以用于以后季度的销售。对于每一件产品，若从第 $i$ 季度保存到第 $i + 1$ 季度， 需要额外支付 $M_i$ 的存储费用（注意产品保存到下个季度后可能再次库存）。\n- 对于第 $i$ 个季度需要推迟而归入到下一个季度订购需求的每一件产品，A 公司需要赔偿给用户损失费 $C_i$（注意延迟到下个季度可能再次被延迟, 费用按后面季度的延迟费用计）。\n\n在第 $N$ 个季度结束后， A 公司必须解决之前所有的用户订单。可以保证， A公司能够生产的产品总数不会低于总订购量， 也就是说一定存在一组生产和销售方案使得满足所有的用户订购需求。小 A 想知道如何来安排产品的生产和销售，使得在满足所有订购需求的前提下公司总的耗费最小。", "inputFormat": "输入文件 $\\tt{product.in}$ 第一行是一个正整数 $N$，表示有 $N$ 个销售季度。\n\n第二行有 $N$ 个非负整数 $D_1,D_2,\\ldots,D_N$，表示第 $i$ 个季度的订购量。\n\n第三行有 $N$ 个非负整数 $U_1,U_2, \\ldots, U_N$，表示第 $i$ 个季度最多可以生产的新的产品数。\n\n第四行有 $N$ 个非负整数 $P_1, P_2, \\ldots, P_N$，表示第 $i$ 个季度生产一件新产品的成本。\n\n第五行有 $N - 1$ 个非负整数 $M_1, M_2,\\ldots,M_{N-1}$，表示将一件产品从第 $i$ 个季度保存到第 $i +1$ 个季度所需要的额外的耗费。\n\n第六行有 $N-1$ 个非负整数 $C_1, C_2, \\ldots, C_{N-1}$，表示一件产品的订购需求在第 $i$ 个季度没有完成而归入到第 $i +1$ 个季度的订购量中，需要赔偿给用户的损失费。", "outputFormat": "输出文件 $\\tt{product.out}$ 仅包含一个非负整数，表示公司的最小总耗费。", "hint": "【样例说明】\n\n第一个季度生产 $2$ 件产品，第二个季度生产 $5$ 件产品，第三个季度不生产产品，第四个季度生产 $1$ 件产品，成本为 $2 * 5 + 5 * 1 + 0 * 5 + 1 * 5 = 20$。\n\n因为第一个季度最多只能生产 $2$ 件产品，无法满足 $3$ 件的订购量，因此将 $1$件产品的订购量推迟到第二个季度，赔偿给用户的损失费为 $5$。\n\n第二个季度由于第一个季度推迟了一件产品的订购需求， 因而订购量变为 $3$。该季度生产了 $5$ 件产品，剩下的 $2$ 件保存下来。第三个季度直接销售库存的产品，再多出来的 $1$ 件产品继续储存到第四个季度，加上第四个季度生产了 $1$ 件产品，因此满足了所有订单需求。总的储存费用为 $2 * 2 + 1 * 1 = 5$。\n\n总的费用为 $20 + 5 + 5 = 30$。\n\n【数据规模】\n\n对于 $30\\%$的数据， $N \\leq 1,000$。\n\n对于 $100\\%$的数据， $1 \\leq N \\leq 100,000$， $1 \\leq D_i, U_i, P_i, M_i,C_i \\leq  10,000$。", "locale": "zh-CN"}}}
{"pid": "P4218", "type": "P", "difficulty": 7, "samples": [["3 5\n1 2\n1 3\naab\nabaab", "15"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "2010", "枚举", "分治", "后缀树", "CTSC/CTS"], "title": "[CTSC2010] 珠宝商", "background": "", "description": "Louis.PS 是一名精明的珠宝商，他出售的项链构造独特，很大程度上是因为他的制作方法与众不同。每次 Louis.PS 到达某个国家后，他会选择一条路径去遍历该国的城市。在到达一个城市后，他会使用在这个城市流行的材料制作一颗珠子，并按照城市被访问的顺序将珠子串联做成项链，为了使制作出来的项链不会因为城市之间的竞争而影响销量，路径中同一个城市不会重复出现（因为如果项链中 $A$ 城市的材料比 $B$ 城市的材料使用的多，则项链在 $B$ 城市的宣传可能会受到影响）。经过多年对消费者的调查，Louis.PS 已经掌握了判断一条项链吸引消费者程度的方法，具体来说，Louis.PS 经过调查得出了受消费者欢迎的项链的特征，并基于此制作了一个长项链（Louis.PS 称之为特征项链）。对于一条待售的项链，这条项链在特征项链里出现的次数越多，这条项链就越受消费者欢迎。\n\n考虑到现实情况的复杂性，我们对条件做出适当的简化。对于每个国家，在某些城市间存在道路直接相连，对于两个不同的城市，有且仅有一条路径连接这两个城市（即国家是连通的，且不存在一个环）。对于每个城市，我们用一个小写字母来表示在这个城市流行的材料类型。这样，我们就可以用一个仅包含小写字母的字符串来表示一条项链，我们将特征项链所对应的字符串称作特征字符串，设为 $\\mathit{EigenString}[1\\ldots M]$，$M$ 为特征项链的长度。对于一条项链，假设其对应字符串为 $P[1\\ldots L]$，$L$ 为这条项链的长度。如果存在一个正整数 $K$，使 $\\mathit{EigenString}[K\\ldots K+L-1]=P[1\\ldots L]$，称这条项链在特征项链中出现了一次。满足上述条件的正整数 $K$ 的个数即为这条项链在特征项链的出现次数，记为 $\\mathit{Popularity}(P)$。\n\nLouis.PS 使用数学中的期望概念来评价一个国家是否适合珠宝的采集,对于一个包含 $N$ 个城市的国家，令 $\\mathit{Str}_{u,v}$ 表示沿着从 $u$ 开始,至 $v$ 结束的路径所得到的项链的对应字符串。（$\\mathit{Str}_{u,v}$ 与 $\\mathit{Str}_{v,u}$ 表示的串一般不相同），则\n\n$$\n\\mathit{Expectation}=\\frac{\\sum_{u,v}{\\mathit{Popularity}(\\mathit{Str}_{u,v})}}{N^2}\n$$\n\n对于如下的例子（图中实线表示两端点的国家有直接道路相连）：\n\n$N=3$，所流行的材料类型分别为 $\\tt{a,a,b}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9zkwho64.png)\n\n$$\n\\mathit{Expectation}=\\frac{3+1+2+1+3+1+1+1+2}{9}=\\frac53\n$$\n\n对于一个国家，Louis.PS 想知道其 $\\mathit{Expectation}$ 的值，但苦于计算期望的工作量太大。作为珠宝店的学徒，你当然不愿放过难得在老板面前展示自己的机会。", "inputFormat": "输入第一行包含两个整数 $N,M$，表示城市个数及特征项链长度。\n\n接下来的 $N-1$ 行，每行两个整数 $x,y$，表示城市 $x$ 与城市 $y$ 有直接道路相连。城市由 $1\\sim N$ 进行编号。\n\n接下来的一行，包含一个长度为 $N$，仅包含小写字母的字符串，第 $i$ 位的字符表示在城市 $i$ 流行的原料类型。\n\n最后一行，包含一个长度为 $M$，仅包含小写字母的字符串， 表示特征字符串。", "outputFormat": "输出仅包含一个整数，为 $N^2\\times\\mathit{Expectation}$。", "hint": "有 $20\\%$ 的数据，满足 $M \\leq 1000$；\n\n有 $40\\%$ 的数据，满足ܰ $N \\leq 8000, M \\leq 50000$；\n\n对于 $100\\%$ 的数据，$N,M \\leq 50000$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2010] Jeweler", "background": "", "description": "Louis.PS is a shrewd jeweler whose necklaces have a unique construction, largely because his production method is different. Each time Louis.PS arrives in a country, he chooses a path to traverse the cities of that country. Upon arriving at a city, he makes a bead using the material popular in that city, and strings the beads together in the order the cities are visited to make a necklace. To prevent competition between cities from affecting sales, the path never visits the same city twice (because if the material from city $A$ is used more than that from city $B$ in the necklace, promotion in city $B$ may be affected). After years of consumer research, Louis.PS has learned how to judge how attractive a necklace is to consumers. Specifically, he has identified the features of popular necklaces and, based on this, has created a long necklace (which he calls the feature necklace). For a necklace for sale, the more times it appears in the feature necklace, the more popular it is.\n\nTo simplify the complex reality, we make the following assumptions. In each country, some cities are directly connected by roads; for any two distinct cities, there is exactly one path connecting them (i.e., the country is connected and has no cycle). For each city, we use a lowercase letter to denote the material type popular in that city. Thus, we can represent a necklace by a string containing only lowercase letters. We call the string corresponding to the feature necklace the feature string, denoted as $\\mathit{EigenString}[1\\ldots M]$, where $M$ is the length of the feature necklace. For a necklace, suppose its corresponding string is $P[1\\ldots L]$, where $L$ is the length of this necklace. If there exists a positive integer $K$ such that $\\mathit{EigenString}[K\\ldots K+L-1]=P[1\\ldots L]$, we say this necklace appears once in the feature necklace. The number of such positive integers $K$ is the occurrence count of this necklace in the feature necklace, denoted as $\\mathit{Popularity}(P)$.\n\nLouis.PS uses the mathematical concept of expectation to evaluate whether a country is suitable for material collection. For a country with $N$ cities, let $\\mathit{Str}_{u,v}$ denote the string corresponding to the necklace obtained along the path starting at $u$ and ending at $v$ (in general, $\\mathit{Str}_{u,v}$ and $\\mathit{Str}_{v,u}$ are different). Then\n$$\n\\mathit{Expectation}=\\frac{\\sum_{u,v}{\\mathit{Popularity}(\\mathit{Str}_{u,v})}}{N^2}\n$$\n\nFor the following example (solid lines in the figure indicate that the endpoints are directly connected by a road):\n\n$N=3$, and the popular material types are $\\tt{a,a,b}$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9zkwho64.png)\n\n$$\n\\mathit{Expectation}=\\frac{3+1+2+1+3+1+1+1+2}{9}=\\frac53\n$$\n\nFor a given country, Louis.PS wants to know the value of $\\mathit{Expectation}$, but the computation workload is large. As the apprentice, you certainly would not miss the chance to impress your boss.", "inputFormat": "The first line contains two integers $N, M$, the number of cities and the length of the feature necklace.\n\nThe next $N-1$ lines each contain two integers $x, y$, indicating that city $x$ and city $y$ are directly connected by a road. Cities are numbered from 1 to $N$.\n\nThe next line contains a string of length $N$ consisting only of lowercase letters. The $i$-th character indicates the material type popular in city $i$.\n\nThe last line contains a string of length $M$ consisting only of lowercase letters, denoting the feature string.", "outputFormat": "Output a single integer, which is $N^2 \\times \\mathit{Expectation}$.", "hint": "- 20% of the testdata satisfy $M \\leq 1000$.\n- 40% of the testdata satisfy $N \\leq 8000, M \\leq 50000$.\n- For 100% of the testdata, $N, M \\leq 50000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2010] 珠宝商", "background": "", "description": "Louis.PS 是一名精明的珠宝商，他出售的项链构造独特，很大程度上是因为他的制作方法与众不同。每次 Louis.PS 到达某个国家后，他会选择一条路径去遍历该国的城市。在到达一个城市后，他会使用在这个城市流行的材料制作一颗珠子，并按照城市被访问的顺序将珠子串联做成项链，为了使制作出来的项链不会因为城市之间的竞争而影响销量，路径中同一个城市不会重复出现（因为如果项链中 $A$ 城市的材料比 $B$ 城市的材料使用的多，则项链在 $B$ 城市的宣传可能会受到影响）。经过多年对消费者的调查，Louis.PS 已经掌握了判断一条项链吸引消费者程度的方法，具体来说，Louis.PS 经过调查得出了受消费者欢迎的项链的特征，并基于此制作了一个长项链（Louis.PS 称之为特征项链）。对于一条待售的项链，这条项链在特征项链里出现的次数越多，这条项链就越受消费者欢迎。\n\n考虑到现实情况的复杂性，我们对条件做出适当的简化。对于每个国家，在某些城市间存在道路直接相连，对于两个不同的城市，有且仅有一条路径连接这两个城市（即国家是连通的，且不存在一个环）。对于每个城市，我们用一个小写字母来表示在这个城市流行的材料类型。这样，我们就可以用一个仅包含小写字母的字符串来表示一条项链，我们将特征项链所对应的字符串称作特征字符串，设为 $\\mathit{EigenString}[1\\ldots M]$，$M$ 为特征项链的长度。对于一条项链，假设其对应字符串为 $P[1\\ldots L]$，$L$ 为这条项链的长度。如果存在一个正整数 $K$，使 $\\mathit{EigenString}[K\\ldots K+L-1]=P[1\\ldots L]$，称这条项链在特征项链中出现了一次。满足上述条件的正整数 $K$ 的个数即为这条项链在特征项链的出现次数，记为 $\\mathit{Popularity}(P)$。\n\nLouis.PS 使用数学中的期望概念来评价一个国家是否适合珠宝的采集,对于一个包含 $N$ 个城市的国家，令 $\\mathit{Str}_{u,v}$ 表示沿着从 $u$ 开始,至 $v$ 结束的路径所得到的项链的对应字符串。（$\\mathit{Str}_{u,v}$ 与 $\\mathit{Str}_{v,u}$ 表示的串一般不相同），则\n\n$$\n\\mathit{Expectation}=\\frac{\\sum_{u,v}{\\mathit{Popularity}(\\mathit{Str}_{u,v})}}{N^2}\n$$\n\n对于如下的例子（图中实线表示两端点的国家有直接道路相连）：\n\n$N=3$，所流行的材料类型分别为 $\\tt{a,a,b}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9zkwho64.png)\n\n$$\n\\mathit{Expectation}=\\frac{3+1+2+1+3+1+1+1+2}{9}=\\frac53\n$$\n\n对于一个国家，Louis.PS 想知道其 $\\mathit{Expectation}$ 的值，但苦于计算期望的工作量太大。作为珠宝店的学徒，你当然不愿放过难得在老板面前展示自己的机会。", "inputFormat": "输入第一行包含两个整数 $N,M$，表示城市个数及特征项链长度。\n\n接下来的 $N-1$ 行，每行两个整数 $x,y$，表示城市 $x$ 与城市 $y$ 有直接道路相连。城市由 $1\\sim N$ 进行编号。\n\n接下来的一行，包含一个长度为 $N$，仅包含小写字母的字符串，第 $i$ 位的字符表示在城市 $i$ 流行的原料类型。\n\n最后一行，包含一个长度为 $M$，仅包含小写字母的字符串， 表示特征字符串。", "outputFormat": "输出仅包含一个整数，为 $N^2\\times\\mathit{Expectation}$。", "hint": "有 $20\\%$ 的数据，满足 $M \\leq 1000$；\n\n有 $40\\%$ 的数据，满足ܰ $N \\leq 8000, M \\leq 50000$；\n\n对于 $100\\%$ 的数据，$N,M \\leq 50000$。", "locale": "zh-CN"}}}
{"pid": "P4219", "type": "P", "difficulty": 6, "samples": [["8 6\nA 2 3\nA 3 4\nA 3 8\nA 8 7\nA 6 5\nQ 3 8", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "各省省选", "北京", "树链剖分", "动态树 LCT", "线段树分治"], "title": "[BJOI2014] 大融合", "background": null, "description": "小强要在 $N$ 个孤立的星球上建立起一套通信系统。这套通信系统就是连接 $N$ 个点的一个树。\n\n这个树的边是一条一条添加上去的。\n\n在某个时刻，一条边的负载就是它所在的当前能够联通的树上路过它的简单路径的数量。\n\n![](https://cdn.luogu.com.cn/upload/pic/13969.png)\n\n例如，在上图中，现在一共有了 $5$ 条边。其中，$(3,8)$ 这条边的负载是 $6$，因为有六条简单路径 $2-3-8$,$2-3-8-7$,$3-8,3-8-7$,$4-3-8$,$4-3-8-7$ 路过了 $(3,8)$。\n\n现在，你的任务就是随着边的添加，动态的回答小强对于某些边的负载的询问。", "inputFormat": "第一行包含两个整数  $N, Q$,表示星球的数量和操作的数量。星球从 $1$ 开始编号。\n\n接下来的 $Q$  行，每行是如下两种格式之一：\n\n - ```A x y``` 表示在 $x$ 和 $y$ 之间连一条边。保证之前 $x$ 和 $y$ 是不联通的。\n - ```Q x y```表示询问 $(x,y)$ 这条边上的负载。保证 $x$ 和 $y$ 之间有一条边。", "outputFormat": "输出包含若干行整数，即为所有查询的答案。", "hint": "对于所有数据，$1≤N,Q≤10^5$", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2014] Great Merge", "background": "", "description": "Xiaoqiang wants to build a communication system across $N$ isolated planets. This communication system is a tree that connects $N$ nodes.\n\nEdges of the tree are added one by one.\n\nAt any given time, the load of an edge is the number of simple paths in its current connected tree that pass through it.\n\n![](https://cdn.luogu.com.cn/upload/pic/13969.png)\n\nFor example, in the figure above, there are $5$ edges in total. The load of edge $(3, 8)$ is $6$, because there are six simple paths $2-3-8$, $2-3-8-7$, $3-8$, $3-8-7$, $4-3-8$, $4-3-8-7$ that pass through $(3, 8)$.\n\nNow, as edges are added, your task is to dynamically answer Xiaoqiang’s queries about the load of certain edges.", "inputFormat": "The first line contains two integers $N, Q$, the number of planets and the number of operations. Planets are numbered starting from $1$.\n\nEach of the next $Q$ lines is in one of the following formats:\n- ```A x y``` Add an edge between $x$ and $y$. It is guaranteed that $x$ and $y$ were previously disconnected.\n- ```Q x y``` Query the load on edge $(x, y)$. It is guaranteed that there is an edge between $x$ and $y$.", "outputFormat": "Output several integers, each being the answer to a query, one per line.", "hint": "For all testdata, $1 \\le N, Q \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2014] 大融合", "background": null, "description": "小强要在 $N$ 个孤立的星球上建立起一套通信系统。这套通信系统就是连接 $N$ 个点的一个树。\n\n这个树的边是一条一条添加上去的。\n\n在某个时刻，一条边的负载就是它所在的当前能够联通的树上路过它的简单路径的数量。\n\n![](https://cdn.luogu.com.cn/upload/pic/13969.png)\n\n例如，在上图中，现在一共有了 $5$ 条边。其中，$(3,8)$ 这条边的负载是 $6$，因为有六条简单路径 $2-3-8$,$2-3-8-7$,$3-8,3-8-7$,$4-3-8$,$4-3-8-7$ 路过了 $(3,8)$。\n\n现在，你的任务就是随着边的添加，动态的回答小强对于某些边的负载的询问。", "inputFormat": "第一行包含两个整数  $N, Q$,表示星球的数量和操作的数量。星球从 $1$ 开始编号。\n\n接下来的 $Q$  行，每行是如下两种格式之一：\n\n - ```A x y``` 表示在 $x$ 和 $y$ 之间连一条边。保证之前 $x$ 和 $y$ 是不联通的。\n - ```Q x y```表示询问 $(x,y)$ 这条边上的负载。保证 $x$ 和 $y$ 之间有一条边。", "outputFormat": "输出包含若干行整数，即为所有查询的答案。", "hint": "对于所有数据，$1≤N,Q≤10^5$", "locale": "zh-CN"}}}
{"pid": "P4220", "type": "P", "difficulty": 7, "samples": [["5\n1 2 2\n1 3 0\n1 4 1\n4 5 7\n1 2 0\n2 3 1\n2 4 1\n2 5 3\n1 5 2\n2 3 8\n3 4 5\n4 5 1", "27"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2018", "并查集", "点分治", "分治", "虚树", "WC"], "title": "[WC2018] 通道", "background": "**滥用本题评测将被封号。**", "description": "11328 年，C 国的科学家们研发了一种高速传送通道，可以在很短的时间内把居民从通道的一端送往另一端，这些通道都是双向的。\n\n美中不足的是，这种传送通道需要进行大量的维护和检修。经过规划，C 国总统决定在 M 城中新建这种通道，在 M 城中，建立了 $n$ 个传送站和 $3\\times(n-1)$ 条传送通道，这些传送通道被分为 $3$ 组，每一组都包含了 $(n-1)$ 条通道。\n\n当任意一组通道运行时，居民都可以通过这组通道从任意一个传送站前往任意的另一个传送站。也就是说，所有的传送站都会被通道所连通。\n\n三组通道按照 $1$、 $2$、 $3$ 的顺序轮流运行，循环反复。在任意一个时刻，都有且只有一组传送通道可以使用。形式化地，在第 $i$ 天中，有且只有第 $((i-1)\\bmod 3+1)$ 组通道运行。\n\nC 国著名科学家 Access Globe 正在进行一项社会调查实验：调查两个传送站之间的传送通道使用者的信息。 Access Globe 的计划是这样的：\n\n- 选定两个传送站 $a, b$\n- 第一天，他从 $a$ 出发，使用正在运行的这组通道沿最短路径到达 $b$，并调查经过的所有通道上使用者的信息\n- 第二天，他从 $b$ 出发，使用正在运行的这组通道沿最短路径到达 $a$，并调查经过的所有通道上使用者的信息\n- 第三天，他从 $a$ 出发，使用正在运行的这组通道沿最短路径到达 $b$，并调查经过的所有通道上使用者的信息\n\nAccess Globe 知道每一条传输线路在运行时的使用者人数。他希望找出一对 $a, b$，使得在整个实验过程中所有经过的通道的使用者数量之和最大。 \n\nAccess Globe 希望参加 CCF NOI 2018 冬令营的你帮他解决这个简单的小问题。如果你成功地解决了这个问题， Access Globe 会送你一份小礼物——$100$ 分！", "inputFormat": "输入文件的第 $1$ 行包含一个正整数 $n$，表示传送站的个数，传送站从 $1$ 到 $n$ 编号；\n\n输入文件的第 $2$ 到第 $n$ 行，每行包含 $3$ 个数 $u,v,w$，表示第一组通道中有一条连接 $u,v$ 的通道，其运行时使用者数量为 $w$ 人；\n\n输入文件的第 $(n+1)$ 到第 $(2n-1)$ 行，每行包含 $3$ 个数 $u,v,w$，表示第二组通道中有一条连接 $u,v$ 的通道，其运行时使用者数量为 $w$ 人；\n\n输入文件的第 $2n$ 到第 $(3n-2)$ 行，每行包含 $3$ 个数 $u,v,w$，表示第三组通道中有一条连接 $u,v$ 的通道，其运行时使用者数量为 $w$ 人。", "outputFormat": "输出文件共 $1$ 行，包含一个整数，表示最大的使用者数量之和。", "hint": "【样例$1$说明】\n\n下图为样例中 $M$ 城的传送站和传输线路情况。其中点和虚线交替的线条、虚线条和实线条分别表示第一组、第二组和第三组通道。\n![](https://cdn.luogu.com.cn/upload/image_hosting/ozwxip1f.png)\n一种可行的方案是选择 $a=2,b=5$，这样的使用者数量之和为 $(3)+(8+5+1)+(2+1+7)=27$。\n\n【子任务】\n\n对于所有数据， $2 \\leq n \\leq 10^5,0 \\leq w \\leq 10^{12}$。\n\n特殊性质 $0$：任意两组通道构成完全相同。\n\n特殊性质 $1$：第二组通道和第三组通道构成完全相同。\n\n特殊性质 $2$：对于第二组的每一个传送站，最多只有两个通道可以到达它，且编号为 $x,y$ 的传送站之间通过一条通道直接连接充要条件是 $|x-y|=1$。\n\n特殊性质 $3$：对于第三组的每一个传送站，最多只有两个通道可以到达它。\n\n特殊性质 $4$： $n \\leq 3000$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fapzjyko.png)\n\n本题共 $31$ 个测试点，每个子任务对应测试点如下：\n\n- 子任务 $0$ 对应测试点 $1-7$；\n- 子任务 $1$ 对应测试点 $8$；\n- 子任务 $2$ 对应测试点 $9-11$；\n- 子任务 $3$ 对应测试点 $12-14$；\n- 子任务 $4$ 对应测试点 $15-17$；\n- 子任务 $5$ 对应测试点 $18-21$；\n- 子任务 $6$ 对应测试点 $22-25$；\n- 子任务 $7$ 对应测试点 $26-31$；\n\n【提示】\n\n- 在两组通道中，可能都包含了连接传送站 $x,y$ 的通道，此时我们认为这两条通道是不同的。\n- 特殊性质中，A 组通道和 B 组通道的『构成完全相同』是指：如果在 A 组中 $u,v$ 之间存在一条使用人数为 $w$ 的通道，那么在 B 组中 $u,v$ 之间一定也存在一条使用人数为 $w$ 的通道。是否相同与描述方式与描述顺序均无关。即在构成完全相同的两组通道 A 和 B 中，通道输入的顺序不一定相同，每条通道的端点的输入顺序也不一定相同（对于 A、B 组中一条连接 $u,v$ 的使用人数为 $w$ 的通道，一种可能出现的输入为： A 组通道中输入 $u\\ v\\ w$，而 B 组通道中输入 $v\\ u\\ w$）。", "locale": "zh-CN", "translations": {"en": {"title": "[WC2018] Channels", "background": "Abusing the judge for this problem will result in an account ban.", "description": "In the year 11328, scientists in country C developed a high-speed teleportation channel that can send residents from one end to the other in a very short time. These channels are bidirectional.\n\nThe downside is that such channels require extensive maintenance and inspection. After planning, the president of country C decided to build such channels in City M. In City M, $n$ teleportation stations and $3 \\times (n-1)$ channels were built. These channels are divided into $3$ groups, each containing $(n-1)$ channels.\n\nWhen any one group of channels is operating, residents can travel via this group of channels from any station to any other station. In other words, all stations are connected by channels.\n\nThe three groups of channels operate in a round-robin fashion in the order $1$, $2$, $3$, repeatedly. At any moment, exactly one group of channels is available. Formally, on day $i$, only group $((i-1)\\bmod 3+1)$ is operating.\n\nThe renowned scientist Access Globe is conducting a social survey experiment: collecting information on users of the channels between two stations. Access Globe’s plan is as follows:\n\n- Choose two stations $a, b$.\n- On day one, he starts from $a$, uses the currently operating group of channels to reach $b$ along a shortest path, and surveys the users on all channels he traverses.\n- On day two, he starts from $b$, uses the currently operating group of channels to reach $a$ along a shortest path, and surveys the users on all channels he traverses.\n- On day three, he starts from $a$, uses the currently operating group of channels to reach $b$ along a shortest path, and surveys the users on all channels he traverses.\n\nAccess Globe knows the number of users on each channel when it is operating. He wants to find a pair $a, b$ such that the total number of users over all traversed channels during the entire experiment is maximized.\n\nAccess Globe hopes you, a participant of the CCF NOI 2018 Winter Camp, can help him solve this simple problem. If you succeed, Access Globe will give you a small gift — $100$ points.", "inputFormat": "The first line contains a positive integer $n$, the number of stations, numbered from $1$ to $n$.\n\nLines $2$ to $n$: each line contains three numbers $u, v, w$, indicating that in the first group there is a channel connecting $u$ and $v$, with $w$ users when it is operating.\n\nLines $(n+1)$ to $(2n-1)$: each line contains three numbers $u, v, w$, indicating that in the second group there is a channel connecting $u$ and $v$, with $w$ users when it is operating.\n\nLines $2n$ to $(3n-2)$: each line contains three numbers $u, v, w$, indicating that in the third group there is a channel connecting $u$ and $v$, with $w$ users when it is operating.", "outputFormat": "Output a single line containing an integer: the maximum possible sum of user counts.", "hint": "[Sample 1 Explanation]\n\nThe figure below shows the stations and channels in City $M$ for the sample. The alternating dotted-and-dashed lines, dotted lines, and solid lines denote the first, second, and third groups of channels, respectively.\n![](https://cdn.luogu.com.cn/upload/image_hosting/ozwxip1f.png)\nOne feasible plan is to choose $a=2, b=5$. The total number of users is $(3) + (8+5+1) + (2+1+7) = 27$.\n\n[Subtasks]\n\nConstraints:\n- For all testdata, $2 \\le n \\le 10^5$, $0 \\le w \\le 10^{12}$.\n\nSpecial properties:\n- Special property $0$: Any two groups of channels are structurally identical.\n- Special property $1$: The second and third groups of channels are structurally identical.\n- Special property $2$: In the second group, each station has degree at most $2$, and stations numbered $x, y$ are directly connected by a channel if and only if $|x-y|=1$.\n- Special property $3$: In the third group, each station has degree at most $2$.\n- Special property $4$: $n \\le 3000$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fapzjyko.png)\n\nThere are $31$ test points in total, with the following mapping from subtasks to test points:\n- Subtask $0$: test points $1$–$7$.\n- Subtask $1$: test point $8$.\n- Subtask $2$: test points $9$–$11$.\n- Subtask $3$: test points $12$–$14$.\n- Subtask $4$: test points $15$–$17$.\n- Subtask $5$: test points $18$–$21$.\n- Subtask $6$: test points $22$–$25$.\n- Subtask $7$: test points $26$–$31$.\n\n[Notes]\n- It is possible that two groups both contain a channel connecting stations $x$ and $y$. In that case, we consider these as two distinct channels.\n- In the special properties, “structurally identical” between groups A and B means: if there is a channel between $u$ and $v$ with user count $w$ in group A, then there must also be a channel between $u$ and $v$ with user count $w$ in group B. Whether they are considered identical is independent of the description format and the input order. That is, in two structurally identical groups A and B, the order of channel inputs may differ, and the order of endpoints in each channel’s input may also differ (for a channel connecting $u, v$ with user count $w$ in groups A and B, one possible input is $u\\ v\\ w$ for group A and $v\\ u\\ w$ for group B).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2018] 通道", "background": "**滥用本题评测将被封号。**", "description": "11328 年，C 国的科学家们研发了一种高速传送通道，可以在很短的时间内把居民从通道的一端送往另一端，这些通道都是双向的。\n\n美中不足的是，这种传送通道需要进行大量的维护和检修。经过规划，C 国总统决定在 M 城中新建这种通道，在 M 城中，建立了 $n$ 个传送站和 $3\\times(n-1)$ 条传送通道，这些传送通道被分为 $3$ 组，每一组都包含了 $(n-1)$ 条通道。\n\n当任意一组通道运行时，居民都可以通过这组通道从任意一个传送站前往任意的另一个传送站。也就是说，所有的传送站都会被通道所连通。\n\n三组通道按照 $1$、 $2$、 $3$ 的顺序轮流运行，循环反复。在任意一个时刻，都有且只有一组传送通道可以使用。形式化地，在第 $i$ 天中，有且只有第 $((i-1)\\bmod 3+1)$ 组通道运行。\n\nC 国著名科学家 Access Globe 正在进行一项社会调查实验：调查两个传送站之间的传送通道使用者的信息。 Access Globe 的计划是这样的：\n\n- 选定两个传送站 $a, b$\n- 第一天，他从 $a$ 出发，使用正在运行的这组通道沿最短路径到达 $b$，并调查经过的所有通道上使用者的信息\n- 第二天，他从 $b$ 出发，使用正在运行的这组通道沿最短路径到达 $a$，并调查经过的所有通道上使用者的信息\n- 第三天，他从 $a$ 出发，使用正在运行的这组通道沿最短路径到达 $b$，并调查经过的所有通道上使用者的信息\n\nAccess Globe 知道每一条传输线路在运行时的使用者人数。他希望找出一对 $a, b$，使得在整个实验过程中所有经过的通道的使用者数量之和最大。 \n\nAccess Globe 希望参加 CCF NOI 2018 冬令营的你帮他解决这个简单的小问题。如果你成功地解决了这个问题， Access Globe 会送你一份小礼物——$100$ 分！", "inputFormat": "输入文件的第 $1$ 行包含一个正整数 $n$，表示传送站的个数，传送站从 $1$ 到 $n$ 编号；\n\n输入文件的第 $2$ 到第 $n$ 行，每行包含 $3$ 个数 $u,v,w$，表示第一组通道中有一条连接 $u,v$ 的通道，其运行时使用者数量为 $w$ 人；\n\n输入文件的第 $(n+1)$ 到第 $(2n-1)$ 行，每行包含 $3$ 个数 $u,v,w$，表示第二组通道中有一条连接 $u,v$ 的通道，其运行时使用者数量为 $w$ 人；\n\n输入文件的第 $2n$ 到第 $(3n-2)$ 行，每行包含 $3$ 个数 $u,v,w$，表示第三组通道中有一条连接 $u,v$ 的通道，其运行时使用者数量为 $w$ 人。", "outputFormat": "输出文件共 $1$ 行，包含一个整数，表示最大的使用者数量之和。", "hint": "【样例$1$说明】\n\n下图为样例中 $M$ 城的传送站和传输线路情况。其中点和虚线交替的线条、虚线条和实线条分别表示第一组、第二组和第三组通道。\n![](https://cdn.luogu.com.cn/upload/image_hosting/ozwxip1f.png)\n一种可行的方案是选择 $a=2,b=5$，这样的使用者数量之和为 $(3)+(8+5+1)+(2+1+7)=27$。\n\n【子任务】\n\n对于所有数据， $2 \\leq n \\leq 10^5,0 \\leq w \\leq 10^{12}$。\n\n特殊性质 $0$：任意两组通道构成完全相同。\n\n特殊性质 $1$：第二组通道和第三组通道构成完全相同。\n\n特殊性质 $2$：对于第二组的每一个传送站，最多只有两个通道可以到达它，且编号为 $x,y$ 的传送站之间通过一条通道直接连接充要条件是 $|x-y|=1$。\n\n特殊性质 $3$：对于第三组的每一个传送站，最多只有两个通道可以到达它。\n\n特殊性质 $4$： $n \\leq 3000$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fapzjyko.png)\n\n本题共 $31$ 个测试点，每个子任务对应测试点如下：\n\n- 子任务 $0$ 对应测试点 $1-7$；\n- 子任务 $1$ 对应测试点 $8$；\n- 子任务 $2$ 对应测试点 $9-11$；\n- 子任务 $3$ 对应测试点 $12-14$；\n- 子任务 $4$ 对应测试点 $15-17$；\n- 子任务 $5$ 对应测试点 $18-21$；\n- 子任务 $6$ 对应测试点 $22-25$；\n- 子任务 $7$ 对应测试点 $26-31$；\n\n【提示】\n\n- 在两组通道中，可能都包含了连接传送站 $x,y$ 的通道，此时我们认为这两条通道是不同的。\n- 特殊性质中，A 组通道和 B 组通道的『构成完全相同』是指：如果在 A 组中 $u,v$ 之间存在一条使用人数为 $w$ 的通道，那么在 B 组中 $u,v$ 之间一定也存在一条使用人数为 $w$ 的通道。是否相同与描述方式与描述顺序均无关。即在构成完全相同的两组通道 A 和 B 中，通道输入的顺序不一定相同，每条通道的端点的输入顺序也不一定相同（对于 A、B 组中一条连接 $u,v$ 的使用人数为 $w$ 的通道，一种可能出现的输入为： A 组通道中输入 $u\\ v\\ w$，而 B 组通道中输入 $v\\ u\\ w$）。", "locale": "zh-CN"}}}
{"pid": "P4221", "type": "P", "difficulty": 6, "samples": [["3 2 1\n1 2\n2 3\n1 1 1", "1"]], "limits": {"time": [15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["数学", "2018", "WC", "状压 DP"], "title": "[WC2018] 州区划分", "background": "**滥用本题评测将被封号！**", "description": "小 S 现在拥有 $n$ 座城市，第 $i$ 座城市的人口为 $w_i$，城市与城市之间可能有双向道路相连。\n\n现在小 S 要将这 $n$ 座城市划分成若干个州，每个州由至少一个城市组成，每个城市在恰好一个州内。\n\n假设小 S 将这些城市划分成了 $k$ 个州，设 $V_i$ 是第 $i$ 个州包含的所有城市组成的集合。定义一条道路是一个州的内部道路，当且仅当这条道路的两个端点城市都在这个州内。如果一个州内部存在一条起点终点相同，不经过任何不属于这个州的城市，且经过这个州的所有内部道路都恰好一次并且经过这个州的所有城市至少一次的路径（路径长度可以为 $0$），则称这个州是不合法的。\n\n定义第 $i$ 个州的满意度为：第 $i$ 个州的人口在前 $i$ 个州的人口中所占比例的 $p$ 次幂，即：\n\n$$\\left(\\dfrac{\\sum _ {x \\in V _ i} w _ x}{\\sum _ {j = 1} ^ i \\sum _ {x \\in V _ j} w _ x}\\right) ^ p$$\n\n\n定义一个划分的满意度为所有州的满意度的乘积。\n\n求所有合法的划分方案的满意度之和。\n\n答案对 $998244353$ 取模。\n两个划分 $\\{V_1, V _ 2, \\cdots, V_k\\}$ 和 $\\{C_1, C _ 2, \\cdots, C_s\\}$ 是不同的，当且仅当 $k \\neq s$，或存在某个 $1 \\leq i \\leq k$，使得 $V_i \\neq C_i$。", "inputFormat": "\n输入第一行包含三个整数 $n,m,p$，表示城市个数、城市之间的道路个数以及题目描述中的常数 $p$。\n\n接下来 $m$ 行，每行两个正整数 $u,v$，描述一条无向的道路，保证无重边无自环。\n\n输入第 $m+2$ 行有 $n$ 个正整数，第 $i$ 个正整数表示 $w_i$。", "outputFormat": "\n输出一行一个整数表示答案在模 $998244353$ 意义下的取值。\n\n即设答案化为最简分式后的形式为 $a/b$ ，其中 $a$ 和 $b$ 互质。输出整数 $x$ 使得 $bx \\equiv a \\pmod{ 998244353}$ 且 $0 \\leq x < 998244353$。可以证明这样的整数 $x$ 是唯一的。", "hint": "\n\n【提示】\n\n$x^{p-1} \\equiv 1 \\pmod p$，其中 $p$ 为质数， $x \\in [1,p)$。\n\n保证对于所有数据有：$0 \\leq n \\leq 21$， $0 \\leq m \\leq \\dfrac{n\\times (n-1)}{2}$ ， $0 \\leq p \\leq 2$， $1 \\leq w_i \\leq 100$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[WC2018] State Partition", "background": "**Abusing the judge for this problem will result in a ban!**", "description": "Xiao S currently has $n$ cities. The population of the $i$-th city is $w_i$, and there may be bidirectional roads between cities.\n\nNow Xiao S will partition these $n$ cities into several states. Each state contains at least one city, and each city belongs to exactly one state.\n\nSuppose Xiao S partitions the cities into $k$ states. Let $V_i$ be the set of all cities contained in the $i$-th state. A road is defined to be an internal road of a state if and only if both of its endpoint cities are within that state. A state is called illegal if and only if there exists a path within this state that starts and ends at the same city, does not pass through any city outside this state, traverses every internal road of this state exactly once, and visits every city of this state at least once (the path length may be $0$).\n\nDefine the satisfaction of the $i$-th state as the $p$-th power of the proportion of the $i$-th state's population in the total population of the first $i$ states, that is:\n$$\\left(\\dfrac{\\sum _ {x \\in V _ i} w _ x}{\\sum _ {j = 1} ^ i \\sum _ {x \\in V _ j} w _ x}\\right) ^ p$$\n\nDefine the satisfaction of a partition as the product of the satisfactions of all states.\n\nCompute the sum of the satisfactions of all legal partitions.\n\nTake the answer modulo $998244353$. Two partitions $\\{V_1, V _ 2, \\cdots, V_k\\}$ and $\\{C_1, C _ 2, \\cdots, C_s\\}$ are different if and only if $k \\neq s$, or there exists some $1 \\leq i \\leq k$ such that $V_i \\neq C_i$.", "inputFormat": "The first line contains three integers $n, m, p$, denoting the number of cities, the number of roads between cities, and the constant $p$ in the statement.\n\nThe next $m$ lines each contain two positive integers $u, v$, describing an undirected road. There are no multiple edges and no self-loops.\n\nLine $m+2$ contains $n$ positive integers, where the $i$-th integer is $w_i$.", "outputFormat": "Output a single integer, which is the value of the answer modulo $998244353$.\n\nThat is, let the answer in lowest terms be $a/b$, where $a$ and $b$ are coprime. Output an integer $x$ such that $b x \\equiv a \\pmod{ 998244353}$ and $0 \\leq x < 998244353$. It can be proven that such an integer $x$ is unique.", "hint": "$[ \\text{Hint} ]$\n\n$x^{p-1} \\equiv 1 \\pmod p$, where $p$ is a prime and $x \\in [1, p)$.\n\nConstraints (guaranteed for all testdata):\n$0 \\leq n \\leq 21$, $0 \\leq m \\leq \\dfrac{n \\times (n-1)}{2}$, $0 \\leq p \\leq 2$, $1 \\leq w_i \\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2018] 州区划分", "background": "**滥用本题评测将被封号！**", "description": "小 S 现在拥有 $n$ 座城市，第 $i$ 座城市的人口为 $w_i$，城市与城市之间可能有双向道路相连。\n\n现在小 S 要将这 $n$ 座城市划分成若干个州，每个州由至少一个城市组成，每个城市在恰好一个州内。\n\n假设小 S 将这些城市划分成了 $k$ 个州，设 $V_i$ 是第 $i$ 个州包含的所有城市组成的集合。定义一条道路是一个州的内部道路，当且仅当这条道路的两个端点城市都在这个州内。如果一个州内部存在一条起点终点相同，不经过任何不属于这个州的城市，且经过这个州的所有内部道路都恰好一次并且经过这个州的所有城市至少一次的路径（路径长度可以为 $0$），则称这个州是不合法的。\n\n定义第 $i$ 个州的满意度为：第 $i$ 个州的人口在前 $i$ 个州的人口中所占比例的 $p$ 次幂，即：\n\n$$\\left(\\dfrac{\\sum _ {x \\in V _ i} w _ x}{\\sum _ {j = 1} ^ i \\sum _ {x \\in V _ j} w _ x}\\right) ^ p$$\n\n\n定义一个划分的满意度为所有州的满意度的乘积。\n\n求所有合法的划分方案的满意度之和。\n\n答案对 $998244353$ 取模。\n两个划分 $\\{V_1, V _ 2, \\cdots, V_k\\}$ 和 $\\{C_1, C _ 2, \\cdots, C_s\\}$ 是不同的，当且仅当 $k \\neq s$，或存在某个 $1 \\leq i \\leq k$，使得 $V_i \\neq C_i$。", "inputFormat": "\n输入第一行包含三个整数 $n,m,p$，表示城市个数、城市之间的道路个数以及题目描述中的常数 $p$。\n\n接下来 $m$ 行，每行两个正整数 $u,v$，描述一条无向的道路，保证无重边无自环。\n\n输入第 $m+2$ 行有 $n$ 个正整数，第 $i$ 个正整数表示 $w_i$。", "outputFormat": "\n输出一行一个整数表示答案在模 $998244353$ 意义下的取值。\n\n即设答案化为最简分式后的形式为 $a/b$ ，其中 $a$ 和 $b$ 互质。输出整数 $x$ 使得 $bx \\equiv a \\pmod{ 998244353}$ 且 $0 \\leq x < 998244353$。可以证明这样的整数 $x$ 是唯一的。", "hint": "\n\n【提示】\n\n$x^{p-1} \\equiv 1 \\pmod p$，其中 $p$ 为质数， $x \\in [1,p)$。\n\n保证对于所有数据有：$0 \\leq n \\leq 21$， $0 \\leq m \\leq \\dfrac{n\\times (n-1)}{2}$ ， $0 \\leq p \\leq 2$， $1 \\leq w_i \\leq 100$。\n", "locale": "zh-CN"}}}
{"pid": "P4222", "type": "P", "difficulty": 5, "samples": [["20", "0001321"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2012", "重庆", "各省省选", "O2优化"], "title": "[CQOI2012] 编号", "background": "", "description": "你需要给一批商品编号，其中每个编号都是一个 $7$ 位 $16$ 进制\n数（由 $0$ 至 $9$, $a$ 至 $f$ 组成）。\n\n为了防止在人工处理时不小心把编号弄错，要求任意两个编号至少有三个位置对应的数字不相同。\n\n第一个编号为 $0000000$，第二个编号为不违反上述规定的前提下最小的编号，…，每次分配一个新编号时，总是选择不和前面编号冲突的最小编号（注意到编号都是 $16$ 进制数，可以比较大小）。\n\n按此规律，前面若干编号分别是：\n\n$$0000000,0000111,0000222,…,0000fff,0001012,0001103,0001230,00\n01321,0001456,…$$\n\n输入 $k$，你的任务是求出第 $k$ 小的编号。", "inputFormat": "一行一个数，为整数 $k$。", "outputFormat": "输出第 $k$ 小的编号（字母均为小写）。输入保证这个编号存在。", "hint": "对于 15% 的数据，$k \\leq 200$；\n\n对于 35% 的数据，$k \\leq 10000$；\n\n对于 60% 的数据，$k \\leq 200000$。\n\n对于 100% 的数据，$k \\leq 1048576$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2012] Numbering", "background": "", "description": "You need to assign numbers to a batch of products, where each number is a $7$-digit hexadecimal number (composed of $0$ to $9$, $a$ to $f$).\n\nTo prevent mistakes during manual processing, any two numbers must differ in at least three corresponding positions.\n\nThe first number is $0000000$, the second is the smallest number that does not violate the above rule, … Each time a new number is assigned, always choose the smallest number that does not conflict with the previous numbers (note that the numbers are hexadecimal, so they can be compared by value).\n\nFollowing this rule, the first few numbers are:\n$$0000000,0000111,0000222,…,0000fff,0001012,0001103,0001230,0001321,0001456,…$$\n\nGiven $k$, your task is to find the $k$-th smallest number.", "inputFormat": "One integer $k$ on a single line.", "outputFormat": "Output the $k$-th smallest number (letters must be lowercase). The input guarantees that this number exists.", "hint": "For 15% of the testdata, $k \\leq 200$;\n\nFor 35% of the testdata, $k \\leq 10000$;\n\nFor 60% of the testdata, $k \\leq 200000$.\n\nFor 100% of the testdata, $k \\leq 1048576$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2012] 编号", "background": "", "description": "你需要给一批商品编号，其中每个编号都是一个 $7$ 位 $16$ 进制\n数（由 $0$ 至 $9$, $a$ 至 $f$ 组成）。\n\n为了防止在人工处理时不小心把编号弄错，要求任意两个编号至少有三个位置对应的数字不相同。\n\n第一个编号为 $0000000$，第二个编号为不违反上述规定的前提下最小的编号，…，每次分配一个新编号时，总是选择不和前面编号冲突的最小编号（注意到编号都是 $16$ 进制数，可以比较大小）。\n\n按此规律，前面若干编号分别是：\n\n$$0000000,0000111,0000222,…,0000fff,0001012,0001103,0001230,00\n01321,0001456,…$$\n\n输入 $k$，你的任务是求出第 $k$ 小的编号。", "inputFormat": "一行一个数，为整数 $k$。", "outputFormat": "输出第 $k$ 小的编号（字母均为小写）。输入保证这个编号存在。", "hint": "对于 15% 的数据，$k \\leq 200$；\n\n对于 35% 的数据，$k \\leq 10000$；\n\n对于 60% 的数据，$k \\leq 200000$。\n\n对于 100% 的数据，$k \\leq 1048576$。", "locale": "zh-CN"}}}
{"pid": "P4223", "type": "P", "difficulty": 7, "samples": [["5 4 \n1 5 4 3 2", "50000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["树状数组", "枚举", "期望", "矩阵乘法"], "title": "期望逆序对", "background": "WXH大定理定律n", "description": "mcfx领导的修道院试图通过古老的膜法阵召唤出传说中的膜法处佬WXH。在他把召唤用具准备齐全后，mcfx在众人的键盘声中启动了召唤阵。\n\n这时，天地突然暗了下来，膜法阵中心电闪雷鸣。一道金光从天而降，金色的代码飘在了半空中。不一会，一个登陆界面显现了出来。mcfx仔细观察后发现上面有如下文字：\n\n\"WXHCoder是过去到未来所有的题目都有的题库。如果想要登陆它，你们必须解决接下来这道题。\"\n\n这道题目是这样子的：给你一个长为$n$的排列，有$k$次操作，每次随机选择两个不同的数交换，问期望逆序对数乘${{n}\\choose{2}}^k$的结果。\n\nmcfx发现数据范围是$n,k≤10^{20010910}$，他打算先探究更小的$n,k$。\n\n${n}\\choose{2}$表示在$n$个球中选两个的方案数", "inputFormat": "第一行两个整数$n,k$\n\n第二行一个$1$到$n$的排列", "outputFormat": "输出期望逆序对数乘${{n}\\choose{2}}^k$的结果模$10^9+7$", "hint": "$n≤500000,k≤10^9$", "locale": "zh-CN", "translations": {"en": {"title": "Expected Inversions", "background": "WXH Grand Theorem Law n.", "description": "The monastery led by mcfx attempts to summon the legendary “memetic master” WXH through an ancient ritual array. After preparing all the summoning tools, mcfx activates the array to the clatter of many keyboards.\n\nSuddenly, heaven and earth darken, and lightning strikes the center of the array. A golden beam descends from the sky, with golden code drifting in midair. Soon, a login interface appears. Upon careful inspection, mcfx sees the following text:\n\n\"WXHCoder is a problem bank that contains every problem from the past to the future. If you want to log into it, you must solve the following problem.\"\n\nThe problem is as follows: You are given a permutation of length $n$. There are $k$ operations. In each operation, two distinct numbers are chosen uniformly at random and swapped. Find the expected number of inversions multiplied by ${{n}\\choose{2}}^k$.\n\nmcfx discovered that the Constraints are $n, k \\le 10^{20010910}$, so he decides to first explore smaller $n, k$.\n\n${n}\\choose{2}$ denotes the number of ways to choose two from $n$ balls.", "inputFormat": "The first line contains two integers $n, k$.\n\nThe second line contains a permutation of $1$ through $n$.", "outputFormat": "Output the expected number of inversions multiplied by ${{n}\\choose{2}}^k$ modulo $10^9+7$.", "hint": "$n \\le 500000, k \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "期望逆序对", "background": "WXH大定理定律n", "description": "mcfx领导的修道院试图通过古老的膜法阵召唤出传说中的膜法处佬WXH。在他把召唤用具准备齐全后，mcfx在众人的键盘声中启动了召唤阵。\n\n这时，天地突然暗了下来，膜法阵中心电闪雷鸣。一道金光从天而降，金色的代码飘在了半空中。不一会，一个登陆界面显现了出来。mcfx仔细观察后发现上面有如下文字：\n\n\"WXHCoder是过去到未来所有的题目都有的题库。如果想要登陆它，你们必须解决接下来这道题。\"\n\n这道题目是这样子的：给你一个长为$n$的排列，有$k$次操作，每次随机选择两个不同的数交换，问期望逆序对数乘${{n}\\choose{2}}^k$的结果。\n\nmcfx发现数据范围是$n,k≤10^{20010910}$，他打算先探究更小的$n,k$。\n\n${n}\\choose{2}$表示在$n$个球中选两个的方案数", "inputFormat": "第一行两个整数$n,k$\n\n第二行一个$1$到$n$的排列", "outputFormat": "输出期望逆序对数乘${{n}\\choose{2}}^k$的结果模$10^9+7$", "hint": "$n≤500000,k≤10^9$", "locale": "zh-CN"}}}
{"pid": "P4224", "type": "P", "difficulty": 7, "samples": [["5 10 10\n1 2 5 9 10\n2\n1 7\n3\n3\n0 8\n3\n2\n1 8\n3\n0 3", "3 1\n2 2\n2 2\n2 2\n1 3\n1 4\n1 3\n1 2\n2 1\n1 2\n1 3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2017", "枚举", "排序", "CTT（清华集训/北大集训）"], "title": "[清华集训 2017] 简单数据结构", "background": "", "description": "参加完IOI2018之后就是姚班面试。而你，由于讨厌物理、并且想成为乔布斯一样的创业家，被成功踢回贵系。\n\n转眼，时间的指针被指向2019，大二，12月初，考试周。\n\n你早听学长说，数据结构期中考很难，对竞赛生不友好，集训队选手做不完卷子。\n\n你冷笑。哼，堂堂国际金，这点难度的考试算什么。\n\n两小时，你看完习题解析前五章所有内容，并且倒背如流；\n\n一小时，你看了500页的讲义，并且记忆犹新；\n\n十分钟，你骑车到考场，自信的你只带了一把水笔，虽然考试让带资料；\n\n现在，摊开传说中神级卷子，你定神一看——\n\n给出一个长度为 $N$ 的序列 $A_1,A_2,\\cdots,A_N$，如果 $A$ 中的一个子序列         $B_1,B_2,\\cdots,B_M$，满足条件：\n\n$1 \\le M \\le N$\n\n∀$1 \\le i \\le M$，$B_i$|$B_{i+1}$\n\n那么称 $B$ 为 $A$ 的上升倍数子序列。\n\n现在有一个长度为 $N$ 的序列 $A$ 被初始化为 $A_{1},A_{2},\\cdots,A_{N}$，以及 $Q$ 次对序列 $A$ 的操作。此处要求实现如下四种操作：\n\n0 x：在序列 $A$ 的最左端插入一个数字 $x$；\n\n1 x：在序列 $A$ 的最右端插入一个数字 $x$；\n\n2：移除序列 $A$ 最左端的一个数字；\n\n3：移除序列 $A$ 最右端的一个数字；\n\n在初始化序列 $A$ 和每次操作之后，请计算此时序列 $A$ 中最长上升倍数子序列的长度 $\\mathrm{MaxLen}$，以及所有长度为 $\\mathrm{MaxLen}$ 的上升倍数子序列的不同的开头数 $\\mathrm{Cnt}$，输出 $\\mathrm{MaxLen}$ 和 $\\mathrm{Cnt}$。\n\n为了大幅度降低题目难度，保证在任意时刻序列 $A$ 非空，其中的元素互不相等，并且均为 $1\\sim M$ 之间的正整数；同一个数字最多只会被插入 $C$ 次。\n", "inputFormat": "输入第一行包含三个正整数 $N,M,Q$，具体含义见上，保证 $1\\le N \\le 10^5$，$N \\le M \\le 10^6$，$0\\le Q \\le 10^5$；\n\n\n输入第二行包含 $N$ 个正整数，为 $A_1,A_2,\\cdots,A_N$，保证 $1\\le A_i\\le M$，并且序列 $A$ 中的元素互不相等；\n\n\n接下来共 $Q$ 行输入，每行输入格式形如0 x或者1 x或者2或者3，具体含义见上。\n", "outputFormat": "输出共 $Q+1$ 行，在初始化和每次对序列 $A$ 操作后，输出 $A$ 中最长上升倍数子序列的长度 $\\mathrm{MaxLen}$ 和所有长度为 $\\mathrm{MaxLen}$ 的上升倍数子序列的不同的开头数 $\\mathrm{Cnt}$，用一个空格隔开。\n", "hint": "**样例解释**\n\n表格中以//隔开不同开头的最长上升子序列。\n\n ![](https://cdn.luogu.com.cn/upload/pic/13370.png) \n\n对于所有的数据，有 $1\\le N \\le 10^5$，$N\\le M \\le 10^6$，$0\\le Q \\le 10^5$，$1\\le A_i\\le M$，$C=10$。\n\n\n下表展示了某些数据点的一些特殊约束，其中只有1表示只有形如1 x的操作，其他表述同理。\n\n![](https://cdn.luogu.com.cn/upload/pic/13371.png)\n\n后记\n\n“奋战两小时，考个四五十”的表情包占领了你的朋友圈：\n\n    “啊，感觉自己人生完全了”\n    “但愿……我真的能拿到四五十”\n    “我考完了……考完了……完了”\n    “曾经以为是开玩笑的，原来我还是naïve了”\n\n你冷笑。提前半小时交卷，你自然觉得，数据结构，满分，正常。", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training Camp 2017] Simple Data Structure", "background": "", "description": "After IOI 2018 comes the interview for the \"Yao Class\". But you, because you dislike physics and want to become an entrepreneur like Steve Jobs, are successfully kicked back to the CS Department.\n\nIn the blink of an eye, the clock points to 2019, sophomore year, early December, finals week.\n\nYou had long heard seniors say that the midterm exam for Data Structures is hard, unfriendly to competitive programmers, and even training team members cannot finish the paper.\n\nYou sneer. Hmph, as an IOI gold medalist, what’s so hard about this exam.\n\nIn two hours, you read all content of the first five chapters of the solution manual and can recite it backwards.\n\nIn one hour, you read a 500-page handout and remember it vividly.\n\nIn ten minutes, you bike to the exam room. Confidently, you bring only a pen, even though it’s an open-book exam.\n\nNow, you unfold the legendary god-tier paper, take a deep breath, and see—\n\nGiven a sequence of length $N$, $A_1, A_2, \\cdots, A_N$. If a subsequence $B_1, B_2, \\cdots, B_M$ of $A$ satisfies:\n\n$1 \\le M \\le N$\n\n∀$1 \\le i \\le M$，$B_i$|$B_{i+1}$\n\nthen we call $B$ an \"increasing multiple subsequence\" of $A$.\n\nNow there is a sequence $A$ of length $N$ initialized as $A_{1}, A_{2}, \\cdots, A_{N}$, and there are $Q$ operations on $A$. You are required to implement the following four operations:\n\n0 x: Insert a number $x$ at the left end of sequence $A$.\n\n1 x: Insert a number $x$ at the right end of sequence $A$.\n\n2: Remove one number from the left end of sequence $A$.\n\n3: Remove one number from the right end of sequence $A$.\n\nAfter initializing sequence $A$ and after each operation, compute the length $\\mathrm{MaxLen}$ of the longest increasing multiple subsequence in the current $A$, and the number $\\mathrm{Cnt}$ of distinct starting numbers among all increasing multiple subsequences of length $\\mathrm{MaxLen}$. Output $\\mathrm{MaxLen}$ and $\\mathrm{Cnt}$.\n\nTo drastically reduce the difficulty, it is guaranteed that the sequence $A$ is non-empty at any time, its elements are all distinct, and all elements are positive integers between $1 \\sim M$. Each same number will be inserted at most $C$ times.", "inputFormat": "The first line of input contains three positive integers $N, M, Q$ as described above. It is guaranteed that $1 \\le N \\le 10^5$, $N \\le M \\le 10^6$, $0 \\le Q \\le 10^5$.\n\nThe second line contains $N$ positive integers, which are $A_1, A_2, \\cdots, A_N$. It is guaranteed that $1 \\le A_i \\le M$, and all elements in sequence $A$ are distinct.\n\nThen there are $Q$ lines. Each line is in one of the following formats: 0 x, or 1 x, or 2, or 3, with meanings as described above.", "outputFormat": "Output $Q+1$ lines. After initialization and after each operation on sequence $A$, output the length $\\mathrm{MaxLen}$ of the longest increasing multiple subsequence in $A$ and the number $\\mathrm{Cnt}$ of distinct starting numbers among all increasing multiple subsequences of length $\\mathrm{MaxLen}$, separated by a single space.", "hint": "Sample explanation.\n\nIn the table, different longest increasing subsequences are separated by //.\n\n ![](https://cdn.luogu.com.cn/upload/pic/13370.png) \n\nFor all testdata, $1 \\le N \\le 10^5$, $N \\le M \\le 10^6$, $0 \\le Q \\le 10^5$, $1 \\le A_i \\le M$, $C = 10$.\n\nThe table below shows some special constraints for certain data points. Here, “only 1” means only operations of the form 1 x; similar statements apply to the others.\n\n![](https://cdn.luogu.com.cn/upload/pic/13371.png)\n\nPostscript.\n\nThe meme “fight for two hours, score forty or fifty” has taken over your social feed:\n\n    “Ah, I feel like my life is complete.”\n    “I hope... I can really get forty or fifty.”\n    “I finished the exam... Finished... Doomed.”\n    “I used to think it was a joke, turns out I was still naïve.”\n\nYou sneer. You hand in the paper half an hour early, naturally thinking: Data Structures, full score, as expected.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2017] 简单数据结构", "background": "", "description": "参加完IOI2018之后就是姚班面试。而你，由于讨厌物理、并且想成为乔布斯一样的创业家，被成功踢回贵系。\n\n转眼，时间的指针被指向2019，大二，12月初，考试周。\n\n你早听学长说，数据结构期中考很难，对竞赛生不友好，集训队选手做不完卷子。\n\n你冷笑。哼，堂堂国际金，这点难度的考试算什么。\n\n两小时，你看完习题解析前五章所有内容，并且倒背如流；\n\n一小时，你看了500页的讲义，并且记忆犹新；\n\n十分钟，你骑车到考场，自信的你只带了一把水笔，虽然考试让带资料；\n\n现在，摊开传说中神级卷子，你定神一看——\n\n给出一个长度为 $N$ 的序列 $A_1,A_2,\\cdots,A_N$，如果 $A$ 中的一个子序列         $B_1,B_2,\\cdots,B_M$，满足条件：\n\n$1 \\le M \\le N$\n\n∀$1 \\le i \\le M$，$B_i$|$B_{i+1}$\n\n那么称 $B$ 为 $A$ 的上升倍数子序列。\n\n现在有一个长度为 $N$ 的序列 $A$ 被初始化为 $A_{1},A_{2},\\cdots,A_{N}$，以及 $Q$ 次对序列 $A$ 的操作。此处要求实现如下四种操作：\n\n0 x：在序列 $A$ 的最左端插入一个数字 $x$；\n\n1 x：在序列 $A$ 的最右端插入一个数字 $x$；\n\n2：移除序列 $A$ 最左端的一个数字；\n\n3：移除序列 $A$ 最右端的一个数字；\n\n在初始化序列 $A$ 和每次操作之后，请计算此时序列 $A$ 中最长上升倍数子序列的长度 $\\mathrm{MaxLen}$，以及所有长度为 $\\mathrm{MaxLen}$ 的上升倍数子序列的不同的开头数 $\\mathrm{Cnt}$，输出 $\\mathrm{MaxLen}$ 和 $\\mathrm{Cnt}$。\n\n为了大幅度降低题目难度，保证在任意时刻序列 $A$ 非空，其中的元素互不相等，并且均为 $1\\sim M$ 之间的正整数；同一个数字最多只会被插入 $C$ 次。\n", "inputFormat": "输入第一行包含三个正整数 $N,M,Q$，具体含义见上，保证 $1\\le N \\le 10^5$，$N \\le M \\le 10^6$，$0\\le Q \\le 10^5$；\n\n\n输入第二行包含 $N$ 个正整数，为 $A_1,A_2,\\cdots,A_N$，保证 $1\\le A_i\\le M$，并且序列 $A$ 中的元素互不相等；\n\n\n接下来共 $Q$ 行输入，每行输入格式形如0 x或者1 x或者2或者3，具体含义见上。\n", "outputFormat": "输出共 $Q+1$ 行，在初始化和每次对序列 $A$ 操作后，输出 $A$ 中最长上升倍数子序列的长度 $\\mathrm{MaxLen}$ 和所有长度为 $\\mathrm{MaxLen}$ 的上升倍数子序列的不同的开头数 $\\mathrm{Cnt}$，用一个空格隔开。\n", "hint": "**样例解释**\n\n表格中以//隔开不同开头的最长上升子序列。\n\n ![](https://cdn.luogu.com.cn/upload/pic/13370.png) \n\n对于所有的数据，有 $1\\le N \\le 10^5$，$N\\le M \\le 10^6$，$0\\le Q \\le 10^5$，$1\\le A_i\\le M$，$C=10$。\n\n\n下表展示了某些数据点的一些特殊约束，其中只有1表示只有形如1 x的操作，其他表述同理。\n\n![](https://cdn.luogu.com.cn/upload/pic/13371.png)\n\n后记\n\n“奋战两小时，考个四五十”的表情包占领了你的朋友圈：\n\n    “啊，感觉自己人生完全了”\n    “但愿……我真的能拿到四五十”\n    “我考完了……考完了……完了”\n    “曾经以为是开玩笑的，原来我还是naïve了”\n\n你冷笑。提前半小时交卷，你自然觉得，数据结构，满分，正常。", "locale": "zh-CN"}}}
{"pid": "P4225", "type": "P", "difficulty": 7, "samples": [["0 1\n1\nLL_RR 1", "0 0 1 1"], ["0 1\n3\nLRRL_ 1\nLRR_L 1\nLLR_R 1", "4 2 0 2"], ["0 1\n1\nLRRL_ 1000000", "421273116 0 0 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "O2优化", "CTT（清华集训/北大集训）"], "title": "[清华集训 2017] 福若格斯", "background": "小d是4xx9小游戏高手。", "description": "有一天，小d发现了一个很经典的小游戏：跳青蛙。\n\n游戏在一个5个格子的棋盘上进行。在游戏的一开始，最左边的两个格子上各有一个向右的青蛙，最右边的两个格子上各有一个向左的青蛙。\n\n![0](https://i.loli.net/2017/12/14/5a32622508ea9.png)\n\n每次移动可以选取一个青蛙，向这只青蛙的前方移动一格到空格子中或跳过前方的一个不同朝向的青蛙并移动到空格子中。\n\n![1](https://i.loli.net/2017/12/14/5a3262250ca07.png)\n\n![2](https://i.loli.net/2017/12/14/5a3262250e38a.png)\n\n为了使你更好地理解这个游戏，我们下发了一个游戏demo作为参考（注意：这个demo中的棋盘大小和题目中并不相同）。\n\n这个游戏本身当然难不倒小d，小d轻松地就解决了这个游戏。但是一个人玩游戏实在是太寂寞了，于是小d找到了小m和他一起玩耍。小d规定，自己只能操控向右的青蛙，小m只能操控向左的青蛙。\n\n小d很快发现，这个游戏想要做到双方轮流行动，就无法达到交换所有青蛙的游戏结局。于是，小d打开了m个游戏，并规定双方轮流行动，每次选择其中一个游戏并控制自己的青蛙行动一步（不能不动）。小d发现，这么做的话就能够使大部分的游戏最终都交换所有的青蛙了。\n\n由于小d是坑队友高手，所以他们玩了一会之后，就开始互相坑害对方，都希望使对方无法行动。他们约定，当轮到一方行动时，若其所有的青蛙都无法行动，则对方获得游戏的胜利。正当博弈论大师小d计算着谁会成为最后的胜者时，电脑卡死了。小d发现，只能kill掉一些游戏才能使剩下的游戏进行下去了。由于电脑已经卡死了，小d无法自由选择kill掉哪些游戏，只能运行系统自带的随机kill小程序。具体来说，小d运行这个随机kill小程序之后，每个游戏有 1/2 ​​的概率被kill掉，有 1/2 ​​的概率能够继续下去。游戏之间被kill掉的概率是独立的。\n\n小d思考了一番，决定如果运行小程序之后他的胜率过低，就直接重启电脑。这时，小d突然发现自己已经不记得刚才轮到谁行动了，于是他决定综合考虑自己先手和后手的胜率。\n\n小d并不擅长概率论，他想让你告诉他运行小程序后，剩下的局面为小d必胜、小m必胜、先手必胜、后手必胜的概率各为多少，这样他才能更好地决定是否重启电脑。\n\n为了避免精度问题，输出答案乘$2^m$​​之后对$998244353$取模的结果。\n\n注意：题目并不保证输入的所有m个状态中小m和小d之前的总行动步数相差不超过1，但是保证不会出现起始状态无法到达的状态。", "inputFormat": "从标准输入读入数据。\n\n我们使用一个长度为5的字符串来表示一个状态，其中，L表示面朝右的青蛙，R表示面朝左的青蛙，_（下划线）表示空格子。例如，初始状态为LL_RR。\n\n本题含有多组数据，第一行两个整数$T,C$($1\\leq C\\leq 100$)分别表示测试点编号和数据组数。\n\n对于每组数据，第一行一个整数$n$($1\\leq n\\leq 23$)表示不同状态的棋盘个数，接下来n行每行一个长度为5的字符串$s_i$​​和一个正整数$a_i$​​($1\\leq a_i\\leq 10^6$​​)，分别表示棋盘的状态和在该状态下的棋盘的个数。\n\n保证输入的字符串合法且不重复。\n", "outputFormat": "输出到标准输出。\n\n定义$m=\\sum a_i$​​。\n\n对于每组数据，输出一行四个整数，分别表示小d必胜（即L的控制方必胜）、小m必胜（即R的控制方必胜）、先手必胜、后手必胜的概率乘$2^m$​​之后对$998244353$取模的结果。\n", "hint": "**样例1解释**\n对于样例1，若该游戏没有被kill，双方唯一可能的操作序列为LL_RR -> L_LRR -> LRL_R -> LR_LR -> LRRL_ -> LRR_L -> L胜，小m先手时同理，故该情况为先手必胜。若该游戏被kill了，双方都没有合法行动，后手必胜。\n\n**样例2解释**\n对于样例2，令这三个棋盘的状态从上到下为A,B,C，则$\\{A,B,C\\},\\{A,B\\},\\{A,C\\},\\{A\\}$,$\\{A\\}$为小d必胜，$\\{C\\},\\{B,C\\}$为小m必胜，$\\{B\\},\\{\\}$为后手必胜。\n\n保证数据中不会出现从LL_RR状态无法到达的状态（如RLLR_），故合法的状态共有23种。\n\n定义 $k-$不可达点 为从LL_RR操作$k$次（双方加起来一共操作$k$次，顺序任意）后依然无法到达的合法状态，如 1-不可达点 为 ：全集{LL_RR,L_LRR,LLR_R} 共20个， 5-不可达点 为{RLR_L,RRL_L,RR_LL,R_LRL,R_RLL}。\n\n对于100%的数据，$1\\leq n\\leq 23,1\\leq m\\leq 10^6,1\\leq C\\leq 100$，所有可能出现在该数据点的状态均为等概率出现（也就是说你可以认为最后一个点中每种状态的$a_i$之和大约为$10^8/23$。\n\n![12](https://cdn.luogu.com.cn/upload/pic/14334.png)\n![13](https://cdn.luogu.com.cn/upload/pic/14335.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training 2017] Froggers", "background": "Little d is a 4xx9 mini‑game expert.", "description": "One day, little d found a classic mini‑game: frog jumping.\n\nThe game is played on a board with 5 cells. At the beginning, there is one frog facing right on each of the two leftmost cells, and one frog facing left on each of the two rightmost cells.\n\n![0](https://i.loli.net/2017/12/14/5a32622508ea9.png)\n\nIn each move, you can choose a frog and either move it one cell forward into an empty cell, or jump over one frog in front of it that faces the opposite direction and land in an empty cell.\n\n![1](https://i.loli.net/2017/12/14/5a3262250ca07.png)\n\n![2](https://i.loli.net/2017/12/14/5a3262250e38a.png)\n\nTo help you better understand the game, we provide a demo as a reference (note: the board size in the demo is not the same as in the problem).\n\nThis game itself is of course easy for little d, and he quickly solved it. But playing alone is too lonely, so little d asked little m to play together. They agreed that little d can only control frogs facing right, and little m can only control frogs facing left.\n\nLittle d soon found that if the two players strictly alternate turns, then it is impossible to reach the end state where all frogs swap sides. So, little d opened m parallel games and stipulated that the two players alternate turns; on each turn they must choose exactly one of the games and move one of their own frogs in that game (they cannot pass). Little d found that with this setup, in most of the games the frogs can eventually swap sides.\n\nSince little d is good at trolling teammates, after a while they started trying to trap each other, both hoping to make the other unable to move. They agreed that when it is a player's turn, if none of that player's frogs in any remaining game can move, then the opponent wins the match. Just as the game theory master little d was calculating who would be the final winner, the computer froze. Little d realized he had to kill some games to let the rest proceed. Since the computer had already frozen, he could not freely choose which games to kill, and could only run the system’s built‑in random kill program. Specifically, after running this random kill program, each game is killed independently with probability 1/2 and survives with probability 1/2.\n\nAfter thinking for a while, little d decided that if his winning probability after running the program was too low, he would just reboot the computer. At this moment, little d suddenly realized he no longer remembered whose turn it was, so he decided to consider both the first‑move and second‑move winning probabilities.\n\nLittle d is not good at probability, and he wants you to tell him, after running the program, the probabilities that the remaining overall position is: d must win, m must win, first player must win, or second player must win. This will help him decide whether to reboot.\n\nTo avoid precision issues, output each probability multiplied by $2^m$ and then taken modulo $998244353$.\n\nNote: The problem does not guarantee that the total number of moves previously made by little m and little d across all m games differs by at most 1, but it guarantees that no state that is unreachable from the initial state appears.", "inputFormat": "Read from standard input.\n\nWe use a string of length 5 to represent a state. L denotes a frog facing right, R denotes a frog facing left, and _ (underscore) denotes an empty cell. For example, the initial state is LL_RR.\n\nThis problem contains multiple datasets. The first line contains two integers $T, C$ ($1 \\leq C \\leq 100$), denoting the testset ID and the number of datasets, respectively.\n\nFor each dataset, the first line contains an integer $n$ ($1 \\leq n \\leq 23$) denoting the number of distinct board states. Then follow $n$ lines, each containing a length‑5 string $s_i$ and a positive integer $a_i$ ($1 \\leq a_i \\leq 10^6$), representing a state and the number of boards in that state.\n\nAll input strings are valid and pairwise distinct.", "outputFormat": "Output to standard output.\n\nLet $m = \\sum a_i$.\n\nFor each dataset, output one line with four integers, denoting the probabilities that little d must win (i.e., the controller of L must win), little m must win (i.e., the controller of R must win), the first player must win, and the second player must win, respectively, each multiplied by $2^m$ and then taken modulo $998244353$.", "hint": "Sample 1 explanation:\nFor Sample 1, if that game is not killed, the only possible move sequence is LL_RR -> L_LRR -> LRL_R -> LR_LR -> LRRL_ -> LRR_L -> L wins; similarly when little m moves first, so in this case the first player must win. If that game is killed, neither player has a legal move, and the second player must win.\n\nSample 2 explanation:\nFor Sample 2, let the three board states from top to bottom be A, B, C. Then $\\{A,B,C\\}, \\{A,B\\}, \\{A,C\\}, \\{A\\}$ are d‑must‑win; $\\{C\\}, \\{B,C\\}$ are m‑must‑win; $\\{B\\}, \\{\\}$ are second‑player‑must‑win.\n\nIt is guaranteed that no state that is unreachable from LL_RR (such as RLLR_) appears in the data, so there are 23 legal states in total.\n\nDefine a k‑unreachable state as a legal state that is still unreachable after making $k$ moves in total from LL_RR (the two players together make $k$ moves in any order). For example, the 1‑unreachable set is the universal set excluding {LL_RR, L_LRR, LLR_R}, which has 20 states; the 5‑unreachable set is {RLR_L, RRL_L, RR_LL, R_LRL, R_RLL}.\n\nFor 100% of the testdata, $1 \\leq n \\leq 23$, $1 \\leq m \\leq 10^6$, $1 \\leq C \\leq 100$, and all states that may appear in that testset are equally likely (that is, you may assume that in the last testset the sum of $a_i$ over each state is about $10^8 / 23$).\n\n![12](https://cdn.luogu.com.cn/upload/pic/14334.png)\n![13](https://cdn.luogu.com.cn/upload/pic/14335.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2017] 福若格斯", "background": "小d是4xx9小游戏高手。", "description": "有一天，小d发现了一个很经典的小游戏：跳青蛙。\n\n游戏在一个5个格子的棋盘上进行。在游戏的一开始，最左边的两个格子上各有一个向右的青蛙，最右边的两个格子上各有一个向左的青蛙。\n\n![0](https://i.loli.net/2017/12/14/5a32622508ea9.png)\n\n每次移动可以选取一个青蛙，向这只青蛙的前方移动一格到空格子中或跳过前方的一个不同朝向的青蛙并移动到空格子中。\n\n![1](https://i.loli.net/2017/12/14/5a3262250ca07.png)\n\n![2](https://i.loli.net/2017/12/14/5a3262250e38a.png)\n\n为了使你更好地理解这个游戏，我们下发了一个游戏demo作为参考（注意：这个demo中的棋盘大小和题目中并不相同）。\n\n这个游戏本身当然难不倒小d，小d轻松地就解决了这个游戏。但是一个人玩游戏实在是太寂寞了，于是小d找到了小m和他一起玩耍。小d规定，自己只能操控向右的青蛙，小m只能操控向左的青蛙。\n\n小d很快发现，这个游戏想要做到双方轮流行动，就无法达到交换所有青蛙的游戏结局。于是，小d打开了m个游戏，并规定双方轮流行动，每次选择其中一个游戏并控制自己的青蛙行动一步（不能不动）。小d发现，这么做的话就能够使大部分的游戏最终都交换所有的青蛙了。\n\n由于小d是坑队友高手，所以他们玩了一会之后，就开始互相坑害对方，都希望使对方无法行动。他们约定，当轮到一方行动时，若其所有的青蛙都无法行动，则对方获得游戏的胜利。正当博弈论大师小d计算着谁会成为最后的胜者时，电脑卡死了。小d发现，只能kill掉一些游戏才能使剩下的游戏进行下去了。由于电脑已经卡死了，小d无法自由选择kill掉哪些游戏，只能运行系统自带的随机kill小程序。具体来说，小d运行这个随机kill小程序之后，每个游戏有 1/2 ​​的概率被kill掉，有 1/2 ​​的概率能够继续下去。游戏之间被kill掉的概率是独立的。\n\n小d思考了一番，决定如果运行小程序之后他的胜率过低，就直接重启电脑。这时，小d突然发现自己已经不记得刚才轮到谁行动了，于是他决定综合考虑自己先手和后手的胜率。\n\n小d并不擅长概率论，他想让你告诉他运行小程序后，剩下的局面为小d必胜、小m必胜、先手必胜、后手必胜的概率各为多少，这样他才能更好地决定是否重启电脑。\n\n为了避免精度问题，输出答案乘$2^m$​​之后对$998244353$取模的结果。\n\n注意：题目并不保证输入的所有m个状态中小m和小d之前的总行动步数相差不超过1，但是保证不会出现起始状态无法到达的状态。", "inputFormat": "从标准输入读入数据。\n\n我们使用一个长度为5的字符串来表示一个状态，其中，L表示面朝右的青蛙，R表示面朝左的青蛙，_（下划线）表示空格子。例如，初始状态为LL_RR。\n\n本题含有多组数据，第一行两个整数$T,C$($1\\leq C\\leq 100$)分别表示测试点编号和数据组数。\n\n对于每组数据，第一行一个整数$n$($1\\leq n\\leq 23$)表示不同状态的棋盘个数，接下来n行每行一个长度为5的字符串$s_i$​​和一个正整数$a_i$​​($1\\leq a_i\\leq 10^6$​​)，分别表示棋盘的状态和在该状态下的棋盘的个数。\n\n保证输入的字符串合法且不重复。\n", "outputFormat": "输出到标准输出。\n\n定义$m=\\sum a_i$​​。\n\n对于每组数据，输出一行四个整数，分别表示小d必胜（即L的控制方必胜）、小m必胜（即R的控制方必胜）、先手必胜、后手必胜的概率乘$2^m$​​之后对$998244353$取模的结果。\n", "hint": "**样例1解释**\n对于样例1，若该游戏没有被kill，双方唯一可能的操作序列为LL_RR -> L_LRR -> LRL_R -> LR_LR -> LRRL_ -> LRR_L -> L胜，小m先手时同理，故该情况为先手必胜。若该游戏被kill了，双方都没有合法行动，后手必胜。\n\n**样例2解释**\n对于样例2，令这三个棋盘的状态从上到下为A,B,C，则$\\{A,B,C\\},\\{A,B\\},\\{A,C\\},\\{A\\}$,$\\{A\\}$为小d必胜，$\\{C\\},\\{B,C\\}$为小m必胜，$\\{B\\},\\{\\}$为后手必胜。\n\n保证数据中不会出现从LL_RR状态无法到达的状态（如RLLR_），故合法的状态共有23种。\n\n定义 $k-$不可达点 为从LL_RR操作$k$次（双方加起来一共操作$k$次，顺序任意）后依然无法到达的合法状态，如 1-不可达点 为 ：全集{LL_RR,L_LRR,LLR_R} 共20个， 5-不可达点 为{RLR_L,RRL_L,RR_LL,R_LRL,R_RLL}。\n\n对于100%的数据，$1\\leq n\\leq 23,1\\leq m\\leq 10^6,1\\leq C\\leq 100$，所有可能出现在该数据点的状态均为等概率出现（也就是说你可以认为最后一个点中每种状态的$a_i$之和大约为$10^8/23$。\n\n![12](https://cdn.luogu.com.cn/upload/pic/14334.png)\n![13](https://cdn.luogu.com.cn/upload/pic/14335.png)\n", "locale": "zh-CN"}}}
{"pid": "P4226", "type": "P", "difficulty": 6, "samples": [["3\n8\n9\n10", "-1\n3 6 6 6\n-1"]], "limits": {"time": [1000, 1000, 1000], "memory": [256000, 256000, 256000]}, "tags": ["贪心", "2017", "Special Judge", "构造", "CTT（清华集训/北大集训）"], "title": "[清华集训 2017] 避难所", "background": "“B君啊，你当年的伙伴都不在北京了，为什么你还在北京呢？”\n\n“大概是因为出了一些事故吧，否则这道题就不叫避难所了。”\n\n“唔，那你之后会去哪呢？”\n\n“去一个没有冬天的地方。”", "description": "对于一个正整数 $n$，我们定义他在 $b$ 进制下，各个位上的数的乘积为 $p=F(n,b)$。\n\n比如 $F(3338,10)=216$。\n\n考虑这样一个问题，已知 $p$ 和 $b$，求最小的 $n$ 满足 $p=F(n,b)$。\n\n这是一个非常有趣的问题，对于一些 $b$ 来说，我们可以贪心来做，比如如果 $b=10,p=216$。\n\n我们可以从 $b-1$ 到 $2$ 试除，直到 $p$ 为 $1$ 为止，答案是 $389$，可以验证 $389$ 是满足 $p=F(n,b)$ 最小的 $n$。\n\n但是对于一些进制 $b$，是不能用贪心做的，比如 $b = 9, p = 216$。使用贪心得到的解是 $3338$，而最优解是 $666$。(均为 $9$ 进制下的。)\n\n本题便是在给定进制 $b$ 的情况下，举出一个这样的反例，或指出这样的反例不存在。\n\n由于计算资源所限，反例中所有数字的乘积不能超过 $10^{18}$​​。如果最小的反例中所有数字的乘积超过了 $10^{18}$​​，那么也应该输出 $-1$。", "inputFormat": "从标准输入读入数据。\n\n第一行一个整数 $t$，表示一共有 $t$ 组数据。\n\n接下来每行一个整数 $b$，表示进制。", "outputFormat": "输出到标准输出。\n\n如果不存在反例，输出一行一个整数 $-1$。\n\n如果存在反例，首先输出一个整数 $k$，表示反例 $n$ 的位数，接下来在同一行输出 $k$ 个十进制整数，表示任意一个反例的最优解。", "hint": "对于第 $1$ 个测试点，分值为 $30$，$1 \\leq n \\leq 32$；\n\n对于第 $2$ 个测试点，分值为 $40$，$1 \\leq n \\leq 100$；\n\n对于第 $3$ 个测试点，分值为 $30$，$1 \\leq t \\leq 200, 1 \\leq n \\leq 100000$。", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training 2017] Shelter", "background": "“B, all your old friends have left Beijing. Why are you still in Beijing?”\n\n“Probably because of some accidents. Otherwise this problem wouldn’t be called ‘Shelter’.”\n\n“Hmm, where will you go next?”\n\n“To a place without winter.”", "description": "For a positive integer $n$, we define the product of its digits in base $b$ as $p = F(n, b)$.\n\nFor example, $F(3338, 10) = 216$.\n\nConsider the following task: given $p$ and $b$, find the smallest $n$ such that $p = F(n, b)$.\n\nThis problem is quite interesting. For some bases $b$, we can solve it greedily. For example, if $b = 10, p = 216$, we can try dividing $p$ by integers from $b - 1$ down to $2$ until $p$ becomes $1$. The answer is $389$, and you can verify that $389$ is the smallest $n$ satisfying $p = F(n, b)$.\n\nHowever, for some bases $b$, this greedy approach does not work. For instance, when $b = 9, p = 216$, the greedy solution is $3338$, while the optimal answer is $666$ (both in base $9$).\n\nIn this problem, for a given base $b$, either produce such a counterexample or state that no such counterexample exists.\n\nDue to limited computing resources, in any counterexample the product of all digits must not exceed $10^{18}$. If in the smallest counterexample the product of all digits exceeds $10^{18}$, you should output $-1$.", "inputFormat": "Read from standard input.\n\nThe first line contains an integer $t$, the number of test cases.\n\nEach of the next $t$ lines contains an integer $b$, the base.", "outputFormat": "Output to standard output.\n\nIf no counterexample exists, output a single integer $-1$.\n\nIf a counterexample exists, first output an integer $k$, the number of digits of $n$ in the counterexample. Then, on the same line, output $k$ decimal integers, which represent any optimal solution (the digits of the smallest $n$ for that counterexample) in base $b$.", "hint": "- For the 1st subtask (30 points), $1 \\leq b \\leq 32$.\n- For the 2nd subtask (40 points), $1 \\leq b \\leq 100$.\n- For the 3rd subtask (30 points), $1 \\leq t \\leq 200, 1 \\leq b \\leq 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2017] 避难所", "background": "“B君啊，你当年的伙伴都不在北京了，为什么你还在北京呢？”\n\n“大概是因为出了一些事故吧，否则这道题就不叫避难所了。”\n\n“唔，那你之后会去哪呢？”\n\n“去一个没有冬天的地方。”", "description": "对于一个正整数 $n$，我们定义他在 $b$ 进制下，各个位上的数的乘积为 $p=F(n,b)$。\n\n比如 $F(3338,10)=216$。\n\n考虑这样一个问题，已知 $p$ 和 $b$，求最小的 $n$ 满足 $p=F(n,b)$。\n\n这是一个非常有趣的问题，对于一些 $b$ 来说，我们可以贪心来做，比如如果 $b=10,p=216$。\n\n我们可以从 $b-1$ 到 $2$ 试除，直到 $p$ 为 $1$ 为止，答案是 $389$，可以验证 $389$ 是满足 $p=F(n,b)$ 最小的 $n$。\n\n但是对于一些进制 $b$，是不能用贪心做的，比如 $b = 9, p = 216$。使用贪心得到的解是 $3338$，而最优解是 $666$。(均为 $9$ 进制下的。)\n\n本题便是在给定进制 $b$ 的情况下，举出一个这样的反例，或指出这样的反例不存在。\n\n由于计算资源所限，反例中所有数字的乘积不能超过 $10^{18}$​​。如果最小的反例中所有数字的乘积超过了 $10^{18}$​​，那么也应该输出 $-1$。", "inputFormat": "从标准输入读入数据。\n\n第一行一个整数 $t$，表示一共有 $t$ 组数据。\n\n接下来每行一个整数 $b$，表示进制。", "outputFormat": "输出到标准输出。\n\n如果不存在反例，输出一行一个整数 $-1$。\n\n如果存在反例，首先输出一个整数 $k$，表示反例 $n$ 的位数，接下来在同一行输出 $k$ 个十进制整数，表示任意一个反例的最优解。", "hint": "对于第 $1$ 个测试点，分值为 $30$，$1 \\leq n \\leq 32$；\n\n对于第 $2$ 个测试点，分值为 $40$，$1 \\leq n \\leq 100$；\n\n对于第 $3$ 个测试点，分值为 $30$，$1 \\leq t \\leq 200, 1 \\leq n \\leq 100000$。", "locale": "zh-CN"}}}
{"pid": "P4227", "type": "P", "difficulty": 7, "samples": [["2\n5 3\n0 0\n2 0\n2 2\n0 2\n1 1\n1 3 10 3 10\n1 3 10 3 20\n1 3 10 3 30\n3 1\n0 0\n100 0\n1000 0\n1 3 10 3 1000000000", "6\n11\n16\n1000001"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 10000, 10000, 10000, 10000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "O2优化", "枚举", "排序", "CTT（清华集训/北大集训）"], "title": "[清华集训 2017] 我的生命已如风中残烛", "background": "", "description": "九条可怜是一个贪玩的女孩子。\n\n这天她在一堵墙钉了 $n$ 个钉子，第 $i$ 个钉子的坐标是 ($x_i,y_i$)。接着她又在墙上钉上了 $m$ 根绳子，绳子的一端是点 $s_i$($sx_i,sy_i$)，绳子经过点 $t_i$($tx_i,ty_i$)，同时绳子的长度是 $L_i$​​。其中 $s_i$​ 点是粘在墙上的，而另一个端点是可以移动的。初始情况下绳子是紧绷的一条直线段。\n\n接着，对每一根绳子可怜都进行了一次游戏。在第 $i$ 次游戏中，可怜会捏着第 $i$ 根绳子的活动端点进行顺时针移动，移动过程中每时每刻绳子都是紧绷的。\n\n不难发现绳子每时每刻都在以某一个位置为圆心作顺时针的圆周运动。初始情况下圆心是绳子的固定端点 $s$，但是在运动的过程中圆心可能会不断发生变化，如下图所示：\n\n![0](https://i.loli.net/2017/12/14/5a32671628367.png)\n\n图中左侧红点为钉子所在的点，右侧红点为绳子的固定端点，其他颜色的点为虚拟点，活动端点为紫点；绳子从紫点开始运动，在运行到蓝点时绳子绕上左侧红点的钉子，因此活动端点更换了圆心和半径，继续作顺时针的圆周运动。接着活动端点会运行到绿点，并且接下来活动端点会一直绕左侧钉子不停地做圆周运动。\n\n不难发现绳子的运动是不会停止的，因此可怜在她感觉累了之后就会停下来。但是作为一个好奇心满满的女孩子，可怜决定对每一根绳子计算一下如果绳子无限的运行下去，那么它的圆心会切换多少次（包括初始的圆心）。不难发现这个数值一定是有限的。\n\n这里对游戏过程进行一定程度的假设来简化问题：\n\n1.活动端点在运动的过程中距离每一个钉子的欧几里得距离始终大于等于 $9 \\times 10^{-4}$。\n2.钉子的坐标两两不同但可能有**多点共线**。\n3.钉子的体积以及绳子的体积可以忽略不计。在游戏的过程中每一段绳子之间不会互相影响。\n4.初始情况下绳子距离每一个钉子的最近欧几里得距离大于等于 $9 \\times 10^{-4}$。\n5.每一根绳子初始粘着的端点**不会**影响绳子的运动，即**绳子不会绕回端点上**。\n", "inputFormat": "从标准输入读入数据。\n\n第一行输入一个整数 $T$，表示数据组数。\n\n每组数据第一行为两个整数 $n,m$，表示钉子数和绳子数。\n\n接下来 $n$ 行，每行两个整数 $x_i,y_i$​​ 表示钉子的坐标。\n\n接下来 $m$ 行，每行五个整数 $sx_i,sy_i,tx_i,ty_i,L_i$ 表示一段绳子，含义如上所述。\n", "outputFormat": "输出到标准输出。\n\n对于每组数据的每组询问，输出一行一个整数表示运行的过程中圆心变化了多少次。\n\n不同数据组数之间**无需**空行隔开。\n", "hint": "对于前 $10\\%$ 的数据，$n \\leq 2$。\n\n对于前 $20\\%$ 的数据，$n \\leq 3$。\n\n对于前 $30\\%$ 的数据，$n \\leq 10$。\n\n对于前 $60\\%$ 的数据，$n \\leq 100,m \\leq 100$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 500$，$1 \\leq m \\leq 500$，$1\\leq T \\leq 10$。\n\n对于 $100\\%$ 的数据，$0 \\leq |x_i|,|y_i|,|sx_i|,|sy_i|,|tx_i|,|ty_i| \\leq 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training 2017] My Life Is Like a Candle in the Wind", "background": "", "description": "Jiutiao Kelian is a playful girl.\n\nOne day she nails $n$ nails into a wall. The $i$-th nail is at $(x_i, y_i)$. Then she nails $m$ ropes onto the wall. One endpoint of the $i$-th rope is the point $s_i (sx_i, sy_i)$, the rope passes through the point $t_i (tx_i, ty_i)$, and the rope length is $L_i$. The point $s_i$ is stuck to the wall, while the other endpoint is movable. Initially, the rope is a taut straight-line segment.\n\nNext, for each rope, Kelian plays a game once. In the $i$-th game, Kelian pinches the moving endpoint of the $i$-th rope and moves it clockwise, keeping the rope taut at every moment.\n\nIt is not hard to see that, at every moment, the rope performs a clockwise circular motion around some center. Initially the center is the fixed endpoint $s$, but during the motion the center may keep changing, as shown below:\n\n![0](https://i.loli.net/2017/12/14/5a32671628367.png)\n\nIn the figure, the red dot on the left is a nail, the red dot on the right is the rope’s fixed endpoint, the other colored dots are virtual points, and the moving endpoint is the purple dot. The rope starts from the purple dot; when it reaches the blue dot, the rope wraps around the left red nail, so the moving endpoint switches its center and radius and continues a clockwise circular motion. Then the moving endpoint reaches the green dot, and thereafter it keeps circling around the left nail indefinitely.\n\nIt is easy to see the rope’s motion never stops, so Kelian stops whenever she feels tired. However, being very curious, she decides to compute, for each rope, if it runs indefinitely, how many times its center will switch (including the initial center). This number is guaranteed to be finite.\n\nTo simplify the problem, we make the following assumptions about the game:\n\n1. During the motion, the Euclidean distance from the moving endpoint to every nail is always greater than or equal to $9 \\times 10^{-4}$.\n2. Nail coordinates are pairwise distinct, but there may be multiple collinear points.\n3. The volumes of the nails and the rope are negligible. During the game, different segments of the rope do not interfere with each other.\n4. Initially, the minimum Euclidean distance from the rope to every nail is greater than or equal to $9 \\times 10^{-4}$.\n5. The initially attached endpoint does not affect the rope’s motion, i.e., the rope will not wrap back onto its fixed endpoint.", "inputFormat": "Read from standard input.\n\nThe first line contains an integer $T$, the number of test cases.\n\nFor each test case, the first line contains two integers $n, m$, the number of nails and the number of ropes.\n\nThe next $n$ lines each contain two integers $x_i, y_i$ giving the coordinates of the nails.\n\nThe next $m$ lines each contain five integers $sx_i, sy_i, tx_i, ty_i, L_i$ describing a rope, as stated above.", "outputFormat": "Output to standard output.\n\nFor each rope in each test case, output a single line with one integer: the number of times the center changes during the motion.\n\nDo not print extra blank lines between test cases.", "hint": "For the first $10\\%$ of the testdata, $n \\leq 2$.\n\nFor the first $20\\%$ of the testdata, $n \\leq 3$.\n\nFor the first $30\\%$ of the testdata, $n \\leq 10$.\n\nFor the first $60\\%$ of the testdata, $n \\leq 100, m \\leq 100$.\n\nFor $100\\%$ of the testdata, $1 \\leq n \\leq 500$, $1 \\leq m \\leq 500$, $1 \\leq T \\leq 10$.\n\nFor $100\\%$ of the testdata, $0 \\leq |x_i|, |y_i|, |sx_i|, |sy_i|, |tx_i|, |ty_i| \\leq 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2017] 我的生命已如风中残烛", "background": "", "description": "九条可怜是一个贪玩的女孩子。\n\n这天她在一堵墙钉了 $n$ 个钉子，第 $i$ 个钉子的坐标是 ($x_i,y_i$)。接着她又在墙上钉上了 $m$ 根绳子，绳子的一端是点 $s_i$($sx_i,sy_i$)，绳子经过点 $t_i$($tx_i,ty_i$)，同时绳子的长度是 $L_i$​​。其中 $s_i$​ 点是粘在墙上的，而另一个端点是可以移动的。初始情况下绳子是紧绷的一条直线段。\n\n接着，对每一根绳子可怜都进行了一次游戏。在第 $i$ 次游戏中，可怜会捏着第 $i$ 根绳子的活动端点进行顺时针移动，移动过程中每时每刻绳子都是紧绷的。\n\n不难发现绳子每时每刻都在以某一个位置为圆心作顺时针的圆周运动。初始情况下圆心是绳子的固定端点 $s$，但是在运动的过程中圆心可能会不断发生变化，如下图所示：\n\n![0](https://i.loli.net/2017/12/14/5a32671628367.png)\n\n图中左侧红点为钉子所在的点，右侧红点为绳子的固定端点，其他颜色的点为虚拟点，活动端点为紫点；绳子从紫点开始运动，在运行到蓝点时绳子绕上左侧红点的钉子，因此活动端点更换了圆心和半径，继续作顺时针的圆周运动。接着活动端点会运行到绿点，并且接下来活动端点会一直绕左侧钉子不停地做圆周运动。\n\n不难发现绳子的运动是不会停止的，因此可怜在她感觉累了之后就会停下来。但是作为一个好奇心满满的女孩子，可怜决定对每一根绳子计算一下如果绳子无限的运行下去，那么它的圆心会切换多少次（包括初始的圆心）。不难发现这个数值一定是有限的。\n\n这里对游戏过程进行一定程度的假设来简化问题：\n\n1.活动端点在运动的过程中距离每一个钉子的欧几里得距离始终大于等于 $9 \\times 10^{-4}$。\n2.钉子的坐标两两不同但可能有**多点共线**。\n3.钉子的体积以及绳子的体积可以忽略不计。在游戏的过程中每一段绳子之间不会互相影响。\n4.初始情况下绳子距离每一个钉子的最近欧几里得距离大于等于 $9 \\times 10^{-4}$。\n5.每一根绳子初始粘着的端点**不会**影响绳子的运动，即**绳子不会绕回端点上**。\n", "inputFormat": "从标准输入读入数据。\n\n第一行输入一个整数 $T$，表示数据组数。\n\n每组数据第一行为两个整数 $n,m$，表示钉子数和绳子数。\n\n接下来 $n$ 行，每行两个整数 $x_i,y_i$​​ 表示钉子的坐标。\n\n接下来 $m$ 行，每行五个整数 $sx_i,sy_i,tx_i,ty_i,L_i$ 表示一段绳子，含义如上所述。\n", "outputFormat": "输出到标准输出。\n\n对于每组数据的每组询问，输出一行一个整数表示运行的过程中圆心变化了多少次。\n\n不同数据组数之间**无需**空行隔开。\n", "hint": "对于前 $10\\%$ 的数据，$n \\leq 2$。\n\n对于前 $20\\%$ 的数据，$n \\leq 3$。\n\n对于前 $30\\%$ 的数据，$n \\leq 10$。\n\n对于前 $60\\%$ 的数据，$n \\leq 100,m \\leq 100$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 500$，$1 \\leq m \\leq 500$，$1\\leq T \\leq 10$。\n\n对于 $100\\%$ 的数据，$0 \\leq |x_i|,|y_i|,|sx_i|,|sy_i|,|tx_i|,|ty_i| \\leq 10^4$。", "locale": "zh-CN"}}}
{"pid": "P4228", "type": "P", "difficulty": 7, "samples": [["0 3\n4\n1 2\n1 3\n1 4\n6\n1 2\n1 3\n1 4\n4 5\n5 6\n10\n1 2\n1 3\n3 4\n3 5\n3 6\n4 7\n7 8\n8 9\n9 10", "0111\n000101\n0000001010"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "O2优化", "CTT（清华集训/北大集训）"], "title": "[清华集训 2017] 榕树之心", "background": "深秋。冷风吹散了最后一丝夏日的暑气，也吹落了榕树脚下灌木丛的叶子。相识数年的Evan和Lyra再次回到了小时候见面的茂盛榕树之下。小溪依旧，石桥依旧，榕树虽是历经荣枯更迭，依旧亭亭如盖，只是Evan和Lyra再也不是七八年前不经世事的少年了。\n\n……\n\n“已经快是严冬了，榕树的叶子还没落呢……”\n\n“榕树是常绿树，是看不到明显的落叶季节的……”\n\n“唉……想不到已经七年了呢。榕树还是当年的榕树，你却不是当年的你了……”\n\n“其实又有什么是一成不变的呢，榕树常绿，翠绿树冠的宏观永恒，是由无数细小树叶的荣枯更迭组成的。在时间的流逝中一切都在不断变化着呢……”\n\n“但你看这榕树，日日如此，季季如此，年年如此，仿佛亘古不变般，盘根错节，郁郁葱葱。我在想，或许成为一棵树更好吧，任时间从枝叶间流过，我只守这一片绿荫就好。”\n\n“榕树固然长久，但在这无限的时光里，终归是要湮灭于尘土的。与其像榕树一般，植根于一方泥土中感受年复一年的四季更替。倒不如在有限的时间里看过尽可能多的世界吧。再说了，榕树虽生长缓慢，却依旧会在每年春天抽出一根新的枝条去向外探索的呢……”\n\n“真的吗，榕树在她漫长的一生里，就是这样往外一步步探索的吗？”\n\n“毕竟就算树冠看起来一成不变，榕树也会随着时间周期变化，春天到了自然就是生长的时候了，她也应当做出对应的表现吧……”\n\n“相比于对季节更替做出本能的生长，我倒宁愿相信，榕树有一颗活跃的的，探索的心。”\n\n“其实榕树是有心的，榕树刚刚种下的时候，心就在根的地方发芽了。以后每年春天榕树长出新枝条的时候，心就会向着新枝条的方向移动一点，这样就能更靠近外面的世界了。你看这头顶上的枝条，纵横交错，其实心已经在这枝杈间，移动了数十载了呢……”\n\n“哇，也就是说，这密密麻麻的树杈中的某个地方，藏着这棵榕树的心吗？”\n\n“没错，可是要知道它在哪，就得另花一番功夫了……”\n\n“呀，这时候想想，一株树还是不如一个人好……比如你，要是这样贴上去的话，就能听到跳动的声音呢……”\n\n……\n", "description": "一棵榕树可以抽象成一棵$n$个结点的有根树，其中结点编号为$1 \\sim n$，而$1$号点就是根节点。初始时，树只有一号点，而心也在一号点。之后每一步，树都会长出一个新结点，即某个和当前已经存在的某个结点相邻的结点被加入了树中，之后，心会沿着心到新加结点的简单路径移动一步。这棵$n$个结点的树有很多种生长的顺序，不同的顺序可能会导致最终心的位置不同。现在，Evan和Lyra想知道，哪些结点可能是心在生长过程结束时停留的位置呢？\n\n例如一棵大小为$4$的树，连边为$\\{<1,2>,<1,3>,<1,4>\\}$，我们有三种不同的生长顺序可以让心分别停留在$2,3,4$号节点上：\n\n最终停留在$2$号点：\n\n    从1生长出3，心从1移动到3,\n    从1生长出4，心从3移动回1,\n    从1生长出2，心从1移动到2.\n\n最终停留在$3$号点：\n\n    从1生长出2，心从1移动到2,\n    从1生长出4，心从2移动回1,\n    从1生长出3，心从1移动到3.\n\n最终停留在$4$号点：\n\n    从1生长出2，心从1移动到2,\n    从1生长出3，心从2移动回1,\n    从1生长出4，心从1移动到4.\n\n而我们可以证明，不存在任何一种可能的生长顺序使得心停留在$1$号点。", "inputFormat": "从标准输入读入数据。\n\n输入第一行一个两个正整数$W,T$，分别表示子任务编号（在样例中$W=0$）和数据组数，接下来是$T$组数据的描述，对于每组数据：\n\n第一行一个正整数$n$表示树上结点的个数。\n\n接下来$n-1$行，每行两个正整数$a_i,b_i$​​，表示编号$a_i,b_i$​​的结点间有一条树边，保证$a_i \\neq b_i$并且输入的$n-1$条边恰好构成了一棵树。\n", "outputFormat": "输出到标准输出。\n\n若输入的$W$不等于$3$，对于每组数据输出一行一个长度为$n$的$01$字符串，表示编号为$1 \\sim n$的结点是否有可能是心最后所在的位置，若$01$字符串对应位是$1$则表示可能，为$0$则表示不可能。\n\n若输入的$W$等于$3$，则对每组数据输出一个字符表示$1$号点的答案。\n", "hint": "**TestPoint 1[10pts]**\n\n$T \\leq 50; n \\leq 15$。\n\n**TestPoint 2[10pts]**\n\n$T \\leq 20; n \\leq 10^5$。除了$1$号点之外，每个点度数（包括父亲）不超过$2$。\n\n**TestPoint 3[10pts]**\n\n$T \\leq 200; n \\leq 100$。只输出一个字符表示$1$号点答案，即保证$1$号点答案正确即可。\n\n**TestPoint 4[35pts]**\n\n$T \\leq 20; n \\leq 10^3$。\n\n**TestPoint 5[35pts]**\n\n$T \\leq 20; n \\leq 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training 2017] Heart of the Banyan Tree", "background": "Late autumn. The cold wind has blown away the last trace of summer heat and the leaves of the bushes under the banyan tree. Evan and Lyra, who have known each other for years, have returned once again to the lush banyan tree where they met as children. The brook is the same, the stone bridge is the same; though the banyan tree has experienced cycles of thriving and withering, it still stands tall like a green canopy. Only Evan and Lyra are no longer the inexperienced teenagers they were seven or eight years ago.\n\n...\n\n“It’s almost winter, yet the banyan still hasn’t shed its leaves...”\n\n“The banyan is an evergreen; you won’t see a distinct season of leaf fall...”\n\n“Sigh... I didn’t expect it’s already been seven years. The banyan is the same as it was back then, but you are no longer who you were...”\n\n“Is there really anything that never changes? The banyan is evergreen, and its seemingly everlasting green canopy is made up of countless leaves cycling through life and death. In the passage of time, everything is constantly changing...”\n\n“But look at this banyan—day after day, season after season, year after year—it seems unchanged since ancient times, with gnarled roots and lush foliage. I’m thinking, perhaps it would be better to be a tree, letting time flow between my branches and leaves, while I simply keep this patch of shade.”\n\n“The banyan may endure, but in this infinite span of time, it will eventually return to dust. Rather than rooting in one place and experiencing the same seasonal cycle year after year like a banyan, why not see as much of the world as possible in limited time? Besides, although the banyan grows slowly, it still sends out a new branch each spring to explore outward...”\n\n“Really? Over its long life, the banyan explores step by step like that?”\n\n“Even if the canopy appears unchanged, the banyan follows periodic changes over time. When spring comes, it naturally grows; it should show that, shouldn’t it...”\n\n“Compared to instinctive growth in response to the seasons, I’d rather believe the banyan has a lively, exploring heart.”\n\n“In fact, the banyan does have a heart. When it’s first planted, the heart sprouts at the root. Later, each spring when the banyan grows a new branch, its heart moves a little toward the direction of that new branch, getting closer to the outside world. Look at the branches above your head—crisscrossing in all directions—the heart has been moving among these boughs for decades...”\n\n“Wow, so somewhere among this dense network of branches, the banyan’s heart is hidden?”\n\n“Exactly. But to know where it is, you’ll need to put in some extra effort...”\n\n“Ah, thinking about it, a tree still isn’t as good as a person... For example, you—if you lean in like this, you can hear the heartbeat...”\n\n...", "description": "A banyan can be abstracted as a rooted tree with $n$ nodes, numbered $1 \\sim n$, where node $1$ is the root. Initially, the tree has only node $1$, and the heart is at node $1$. After that, at each step, the tree grows a new node: specifically, a node adjacent to some currently existing node is added to the tree. Then, the heart moves one step along the simple path from the heart to the newly added node. This tree with $n$ nodes has many possible growth orders, and different orders may lead to different final positions of the heart. Now Evan and Lyra want to know: which nodes could possibly be the final resting position of the heart when the growth process ends?\n\nFor example, consider a tree of size $4$ with edges $\\{<1,2>,<1,3>,<1,4>\\}$. There are three different growth orders that make the heart end at nodes $2$, $3$, and $4$, respectively:\n\nFinally ending at node $2$:\n- Grow $3$ from $1$, the heart moves from $1$ to $3$,\n- Grow $4$ from $1$, the heart moves from $3$ back to $1$,\n- Grow $2$ from $1$, the heart moves from $1$ to $2$.\n\nFinally ending at node $3$:\n- Grow $2$ from $1$, the heart moves from $1$ to $2$,\n- Grow $4$ from $1$, the heart moves from $2$ back to $1$,\n- Grow $3$ from $1$, the heart moves from $1$ to $3$.\n\nFinally ending at node $4$:\n- Grow $2$ from $1$, the heart moves from $1$ to $2$,\n- Grow $3$ from $1$, the heart moves from $2$ back to $1$,\n- Grow $4$ from $1$, the heart moves from $1$ to $4$.\n\nWe can prove that there is no growth order that makes the heart end at node $1$.", "inputFormat": "Read from standard input.\n\nThe first line contains two positive integers $W, T$, representing the subtask identifier (in the samples $W = 0$) and the number of test cases. Then follow $T$ test cases. For each test case:\n\n- The first line contains a positive integer $n$, the number of nodes in the tree.\n- The next $n - 1$ lines each contain two positive integers $a_i, b_i$, indicating there is a tree edge between nodes numbered $a_i$ and $b_i$. It is guaranteed that $a_i \\neq b_i$ and the $n - 1$ edges form a tree.", "outputFormat": "Output to standard output.\n\nIf the input $W$ is not equal to $3$, for each test case output a line containing a length-$n$ $01$ string. The $i$-th character indicates whether node $i$ could be the final position of the heart. A $1$ means possible, and a $0$ means impossible.\n\nIf the input $W$ equals $3$, then for each test case output a single character indicating the answer for node $1$.", "hint": "TestPoint 1 [10 pts]\n- $T \\leq 50; n \\leq 15$.\n\nTestPoint 2 [10 pts]\n- $T \\leq 20; n \\leq 10^5$. For every node except node $1$, the degree (including its parent) is at most $2$.\n\nTestPoint 3 [10 pts]\n- $T \\leq 200; n \\leq 100$. Only output a single character indicating the answer for node $1$, i.e., it suffices to ensure the correctness for node $1$.\n\nTestPoint 4 [35 pts]\n- $T \\leq 20; n \\leq 10^3$.\n\nTestPoint 5 [35 pts]\n- $T \\leq 20; n \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2017] 榕树之心", "background": "深秋。冷风吹散了最后一丝夏日的暑气，也吹落了榕树脚下灌木丛的叶子。相识数年的Evan和Lyra再次回到了小时候见面的茂盛榕树之下。小溪依旧，石桥依旧，榕树虽是历经荣枯更迭，依旧亭亭如盖，只是Evan和Lyra再也不是七八年前不经世事的少年了。\n\n……\n\n“已经快是严冬了，榕树的叶子还没落呢……”\n\n“榕树是常绿树，是看不到明显的落叶季节的……”\n\n“唉……想不到已经七年了呢。榕树还是当年的榕树，你却不是当年的你了……”\n\n“其实又有什么是一成不变的呢，榕树常绿，翠绿树冠的宏观永恒，是由无数细小树叶的荣枯更迭组成的。在时间的流逝中一切都在不断变化着呢……”\n\n“但你看这榕树，日日如此，季季如此，年年如此，仿佛亘古不变般，盘根错节，郁郁葱葱。我在想，或许成为一棵树更好吧，任时间从枝叶间流过，我只守这一片绿荫就好。”\n\n“榕树固然长久，但在这无限的时光里，终归是要湮灭于尘土的。与其像榕树一般，植根于一方泥土中感受年复一年的四季更替。倒不如在有限的时间里看过尽可能多的世界吧。再说了，榕树虽生长缓慢，却依旧会在每年春天抽出一根新的枝条去向外探索的呢……”\n\n“真的吗，榕树在她漫长的一生里，就是这样往外一步步探索的吗？”\n\n“毕竟就算树冠看起来一成不变，榕树也会随着时间周期变化，春天到了自然就是生长的时候了，她也应当做出对应的表现吧……”\n\n“相比于对季节更替做出本能的生长，我倒宁愿相信，榕树有一颗活跃的的，探索的心。”\n\n“其实榕树是有心的，榕树刚刚种下的时候，心就在根的地方发芽了。以后每年春天榕树长出新枝条的时候，心就会向着新枝条的方向移动一点，这样就能更靠近外面的世界了。你看这头顶上的枝条，纵横交错，其实心已经在这枝杈间，移动了数十载了呢……”\n\n“哇，也就是说，这密密麻麻的树杈中的某个地方，藏着这棵榕树的心吗？”\n\n“没错，可是要知道它在哪，就得另花一番功夫了……”\n\n“呀，这时候想想，一株树还是不如一个人好……比如你，要是这样贴上去的话，就能听到跳动的声音呢……”\n\n……\n", "description": "一棵榕树可以抽象成一棵$n$个结点的有根树，其中结点编号为$1 \\sim n$，而$1$号点就是根节点。初始时，树只有一号点，而心也在一号点。之后每一步，树都会长出一个新结点，即某个和当前已经存在的某个结点相邻的结点被加入了树中，之后，心会沿着心到新加结点的简单路径移动一步。这棵$n$个结点的树有很多种生长的顺序，不同的顺序可能会导致最终心的位置不同。现在，Evan和Lyra想知道，哪些结点可能是心在生长过程结束时停留的位置呢？\n\n例如一棵大小为$4$的树，连边为$\\{<1,2>,<1,3>,<1,4>\\}$，我们有三种不同的生长顺序可以让心分别停留在$2,3,4$号节点上：\n\n最终停留在$2$号点：\n\n    从1生长出3，心从1移动到3,\n    从1生长出4，心从3移动回1,\n    从1生长出2，心从1移动到2.\n\n最终停留在$3$号点：\n\n    从1生长出2，心从1移动到2,\n    从1生长出4，心从2移动回1,\n    从1生长出3，心从1移动到3.\n\n最终停留在$4$号点：\n\n    从1生长出2，心从1移动到2,\n    从1生长出3，心从2移动回1,\n    从1生长出4，心从1移动到4.\n\n而我们可以证明，不存在任何一种可能的生长顺序使得心停留在$1$号点。", "inputFormat": "从标准输入读入数据。\n\n输入第一行一个两个正整数$W,T$，分别表示子任务编号（在样例中$W=0$）和数据组数，接下来是$T$组数据的描述，对于每组数据：\n\n第一行一个正整数$n$表示树上结点的个数。\n\n接下来$n-1$行，每行两个正整数$a_i,b_i$​​，表示编号$a_i,b_i$​​的结点间有一条树边，保证$a_i \\neq b_i$并且输入的$n-1$条边恰好构成了一棵树。\n", "outputFormat": "输出到标准输出。\n\n若输入的$W$不等于$3$，对于每组数据输出一行一个长度为$n$的$01$字符串，表示编号为$1 \\sim n$的结点是否有可能是心最后所在的位置，若$01$字符串对应位是$1$则表示可能，为$0$则表示不可能。\n\n若输入的$W$等于$3$，则对每组数据输出一个字符表示$1$号点的答案。\n", "hint": "**TestPoint 1[10pts]**\n\n$T \\leq 50; n \\leq 15$。\n\n**TestPoint 2[10pts]**\n\n$T \\leq 20; n \\leq 10^5$。除了$1$号点之外，每个点度数（包括父亲）不超过$2$。\n\n**TestPoint 3[10pts]**\n\n$T \\leq 200; n \\leq 100$。只输出一个字符表示$1$号点答案，即保证$1$号点答案正确即可。\n\n**TestPoint 4[35pts]**\n\n$T \\leq 20; n \\leq 10^3$。\n\n**TestPoint 5[35pts]**\n\n$T \\leq 20; n \\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4229", "type": "P", "difficulty": 6, "samples": [["1\n3 2 3\n1 2 3\n2 3 2", "3"], ["2\n4 2 4\n1 2 3\n2 3 4\n7 3 74\n3 6 56\n2 5 56\n3 7 70", "20\n160326468"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "O2优化", "CTT（清华集训/北大集训）"], "title": "[清华集训 2017] 某位歌姬的故事", "background": null, "description": "IA 是一名会唱歌的女孩子。\n\nIOI2018 就要来了，IA 决定给参赛选手们写一首歌，以表达美好的祝愿。这首歌一共有 $n$ 个音符，第 $i$ 个音符的音高为 $h_i$​​。IA 的音域是 $A$，她只能唱出 $1\\sim A$ 中的正整数音高。因此 $1\\le h_i\\le A$。\n\n在写歌之前，IA 需要确定下这首歌的结构，于是她写下了 $Q$ 条限制，其中第 $i$ 条为：编号在 $l_i$ 到 $r_i$ 之间的音符的最高音高为 $m_i$。在确定了结构之后，她就可以开始写歌了。不过她还是想知道，一共有多少种可能的歌曲满足她的所有限制？她听说你还有 9 个月就要去 IOI 了，于是希望你帮她计算一下这个值。", "inputFormat": "从标准输入读入数据。\n\n输入的第一行包含一个整数 $T$($T\\le 20$)，代表测试数据的组数。\n\n每组数据的第一行包含三个正整数 $n,Q,A$。接下来 $Q$ 行，每行三个整数 $l_i,r_i,m_i$​​，表示一条限制。保证 $1\\le l_i\\le r_i\\le n, 1\\le m_i\\le A$。", "outputFormat": "输出到标准输出。\n\n输出文件只有一行，表示可能的歌曲数目。这个数可能很大，请将答案模 $998244353$ 输出。", "hint": "**样例1解释**\n以下是三种可能的歌曲：$(3,1,2),(3,2,1),(3,2,2)$。\n\n![0](https://cdn.luogu.com.cn/upload/pic/14340.png)", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training 2017] A Certain Songstress's Story", "background": "", "description": "IA is a girl who can sing.\n\nIOI 2018 is coming, and IA decides to write a song for the contestants to express her best wishes. The song has $n$ notes, and the pitch of the $i$-th note is $h_i$. IA's vocal range is $A$, and she can only sing positive integer pitches in $1\\sim A$. Therefore $1\\le h_i\\le A$.\n\nBefore composing, IA needs to decide the structure of the song, so she wrote down $Q$ constraints, where the $i$-th constraint is: among the notes indexed from $l_i$ to $r_i$, the maximum pitch is $m_i$. After the structure is fixed, she can start composing. However, she still wants to know how many possible songs satisfy all her constraints. She heard you will go to IOI in 9 months, so she hopes you can help her compute this value.", "inputFormat": "Read from standard input.\n\nThe first line contains an integer $T$ ($T\\le 20$), the number of testdata groups.\n\nFor each group, the first line contains three positive integers $n, Q, A$. Then follow $Q$ lines, each with three integers $l_i, r_i, m_i$, representing one constraint. It is guaranteed that $1\\le l_i\\le r_i\\le n, 1\\le m_i\\le A$.", "outputFormat": "Write to standard output.\n\nOutput a single line indicating the number of possible songs. Since this number can be large, output the answer modulo $998244353$.", "hint": "Explanation for Sample 1.\nThe following are the three possible songs: $(3, 1, 2)$, $(3, 2, 1)$, $(3, 2, 2)$.\n\n![0](https://cdn.luogu.com.cn/upload/pic/14340.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2017] 某位歌姬的故事", "background": null, "description": "IA 是一名会唱歌的女孩子。\n\nIOI2018 就要来了，IA 决定给参赛选手们写一首歌，以表达美好的祝愿。这首歌一共有 $n$ 个音符，第 $i$ 个音符的音高为 $h_i$​​。IA 的音域是 $A$，她只能唱出 $1\\sim A$ 中的正整数音高。因此 $1\\le h_i\\le A$。\n\n在写歌之前，IA 需要确定下这首歌的结构，于是她写下了 $Q$ 条限制，其中第 $i$ 条为：编号在 $l_i$ 到 $r_i$ 之间的音符的最高音高为 $m_i$。在确定了结构之后，她就可以开始写歌了。不过她还是想知道，一共有多少种可能的歌曲满足她的所有限制？她听说你还有 9 个月就要去 IOI 了，于是希望你帮她计算一下这个值。", "inputFormat": "从标准输入读入数据。\n\n输入的第一行包含一个整数 $T$($T\\le 20$)，代表测试数据的组数。\n\n每组数据的第一行包含三个正整数 $n,Q,A$。接下来 $Q$ 行，每行三个整数 $l_i,r_i,m_i$​​，表示一条限制。保证 $1\\le l_i\\le r_i\\le n, 1\\le m_i\\le A$。", "outputFormat": "输出到标准输出。\n\n输出文件只有一行，表示可能的歌曲数目。这个数可能很大，请将答案模 $998244353$ 输出。", "hint": "**样例1解释**\n以下是三种可能的歌曲：$(3,1,2),(3,2,1),(3,2,2)$。\n\n![0](https://cdn.luogu.com.cn/upload/pic/14340.png)", "locale": "zh-CN"}}}
{"pid": "P4230", "type": "P", "difficulty": 6, "samples": [["5\n1 2\n2 3\n3 4\n1 4\n4 2\n", "2 3 3 3 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["深度优先搜索 DFS", "动态树 LCT", "期望", "差分"], "title": "连环病原体", "background": "###（一）洞穴\n\n顺着狭窄倾斜的溶洞向下走，这里，真有一番地心探险的感觉呢。\n\n告诉你啊，地底有一片广阔的大世界，叫做旧地狱。\n\n那里居住着被地面上的人厌恶的妖怪们。\n\n虽然听着比较吓人，但实际上在地狱废弃后，一切都是井井有条的。\n\n前方有一片开阔的空间啊，好像有人。\n\n\"地面上的来客吗,你好啊\"\n\n终于遇到地底的居民了。\n\n眼前的两只妖怪是黑谷山女和琪斯美。\n\n琪斯美呆在一个小桶里，悬挂在空中，和山女讨论着什么。\n\n\"哇，你们在讨论什么啊\"\n\n\"嗯，有关病毒的问题，你们不懂的\"\n\n忘记说了，山女可以操纵疾病，所以谈论这样的话题自然也就很平常了。\n\n不过好奇心很难抵挡啊，那就假装自己能帮上忙，然后接着问下去吧。\n\n\"好吧，你们要是能帮上忙的话就再好不过了\"\n\n\"嗯，主要是，想知道病原体之间的相互作用，会对疾病产生什么影响呢。你看啊，把不同种的病原体看做点，相互作用看成连接这些点的线，如果产生了环，那么病毒的威力就会大幅加强，我把它叫做加强环。\"\n\n\"病原体之间的相互作用也有很多种呢，我想研究的是，每种相互作用在产生加强环的过程中有多么重要。\"\n\n啊，听起来好复杂，不过如果帮了她的忙，地底的妖怪们大概会对我们友善一些吧。\n\n而且，点，边，环？这些名词似乎见过呢，说不定我真的能帮上忙？\n\n那么，继续详细地询问吧。\n\n嗯，问出来的信息已经记录在这张纸上了。\n", "description": "问题摘要:\n\n有n 种病原体，它们之间会产生$m$种无方向性的影响，第$i$种影响发生在$u_i$,$v_i$ **两种**病原体之间。\n\n我们把所有的**影响**按编号顺序排成一个序列，如果某一个区间包含有环，那么这个区间被称作加强区间。\n\n求每种影响分别在多少个加强区间中出现过。\n\n那么，到底怎样做才能高效的得出结果呢？\n\n(后续剧情见本题题解，接下来请看T2)", "inputFormat": "第一行一个数$m$\n接下来$m$行每行两个数$u_i$,$v_i$，用空格分隔", "outputFormat": "一行$m$个数字，第$i$个数字代表第$i$种影响在多少个加强区间内出现过，数字之间用空格分隔", "hint": "###样例解释：\n\n第一种影响在[1,4]和[1,5]两个加强区间内出现\n\n第二种影响在[1,4]、[1,5]和[2,5]三个加强区间内出现\n\n第三种影响在[1,5]、[1,4]和[2,5]三个加强区间内出现\n\n第四种影响在[1,4]、[2,5]和[1,5]三个加强区间内出现\n\n第五种影响在[2,5]和[1,5]两个加强区间内出现\n\n注意：加强区间是由“影响”构成的，而不是由“病原体”构成的\n\n$n\\leqslant2m\\leqslant400000$\n\n测试点1~2总分10分，$m\\leqslant5$\n\n测试点3~6总分20分，$m\\leqslant200$\n\n测试点7~12总分30分，$m\\leqslant5000$\n\n测试点13~15总分15分，$m\\leqslant50000$\n\n测试点16~18总分15分，$m\\leqslant50000$，捆绑测试\n\n测试点19~22总分10分，$m\\leqslant200000$，捆绑测试\n\nby oscar", "locale": "zh-CN", "translations": {"en": {"title": "Cyclic Pathogens", "background": "### (I) Cave\n\nWalking down along a narrow, slanted karst cave, it really feels like a journey to the center of the earth.\n\nLet me tell you, there is a vast underground world called the Former Hell.\n\nIt is home to youkai shunned by people on the surface.\n\nAlthough it sounds scary, after Hell was abandoned, everything became orderly.\n\nThere is an open space ahead; it seems someone is there.\n\n\"A visitor from the surface? Hello.\"\n\nAt last, we met the residents of the underground.\n\nThe two youkai before us are Kurodani Yamame and Kisume.\n\nKisume stays in a small bucket, hanging in the air, discussing something with Yamame.\n\n\"Wow, what are you discussing?\"\n\n\"Mm, it's about viruses. You wouldn’t understand.\"\n\nI forgot to mention, Yamame can manipulate diseases, so discussing such topics is only natural.\n\nBut curiosity is hard to resist. Let's pretend we can help and keep asking.\n\n\"Well then, if you can help, that would be great.\"\n\n\"Mm, what I mainly want to know is how interactions among pathogens affect the disease. Look, if we treat different kinds of pathogens as points, and their interactions as lines connecting the points, then if a cycle is formed, the virus’s power is greatly enhanced. I call this a reinforcement cycle.\"\n\n\"There are many kinds of interactions among pathogens. I want to study how important each interaction is in forming reinforcement cycles.\"\n\nAh, it sounds complicated, but if we help her, the underground youkai might be friendlier to us.\n\nAlso, points, edges, cycles? These terms seem familiar. Maybe I really can help?\n\nLet’s keep asking for details.\n\nMm, the information we got has been written down on this sheet of paper.", "description": "Problem summary:\n\nThere are $n$ types of pathogens, and there are $m$ kinds of undirected influences among them. The $i$-th influence occurs between pathogens $u_i$ and $v_i$, specifically between **two** pathogens.\n\nWe arrange all the **influences** in order by their indices to form a sequence. If an interval contains a cycle, then that interval is called a reinforcement interval.\n\nFor each influence, count in how many reinforcement intervals it appears.\n\nSo, how can we compute the result efficiently?\n\n(For the subsequent story, see the editorial of this problem. Please proceed to T2.)", "inputFormat": "The first line contains a number $m$.\n\nThen $m$ lines follow; each line contains two numbers $u_i$, $v_i$, separated by a space.", "outputFormat": "Output one line with $m$ numbers. The $i$-th number denotes how many reinforcement intervals contain the $i$-th influence. Numbers are separated by spaces.", "hint": "### Sample explanation:\n\nThe first influence appears in two reinforcement intervals: [1,4] and [1,5].\n\nThe second influence appears in three reinforcement intervals: [1,4], [1,5], and [2,5].\n\nThe third influence appears in three reinforcement intervals: [1,5], [1,4], and [2,5].\n\nThe fourth influence appears in three reinforcement intervals: [1,4], [2,5], and [1,5].\n\nThe fifth influence appears in two reinforcement intervals: [2,5] and [1,5].\n\nNote: reinforcement intervals are formed by “influences” (edges), not by “pathogens” (vertices).\n\nConstraints\n\n$n\\leqslant2m\\leqslant400000$\n\nTest points 1–2, total 10 points, $m\\leqslant5$.\n\nTest points 3–6, total 20 points, $m\\leqslant200$.\n\nTest points 7–12, total 30 points, $m\\leqslant5000$.\n\nTest points 13–15, total 15 points, $m\\leqslant50000$.\n\nTest points 16–18, total 15 points, $m\\leqslant50000$, bundled test.\n\nTest points 19–22, total 10 points, $m\\leqslant200000$, bundled test.\n\nby oscar\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "连环病原体", "background": "###（一）洞穴\n\n顺着狭窄倾斜的溶洞向下走，这里，真有一番地心探险的感觉呢。\n\n告诉你啊，地底有一片广阔的大世界，叫做旧地狱。\n\n那里居住着被地面上的人厌恶的妖怪们。\n\n虽然听着比较吓人，但实际上在地狱废弃后，一切都是井井有条的。\n\n前方有一片开阔的空间啊，好像有人。\n\n\"地面上的来客吗,你好啊\"\n\n终于遇到地底的居民了。\n\n眼前的两只妖怪是黑谷山女和琪斯美。\n\n琪斯美呆在一个小桶里，悬挂在空中，和山女讨论着什么。\n\n\"哇，你们在讨论什么啊\"\n\n\"嗯，有关病毒的问题，你们不懂的\"\n\n忘记说了，山女可以操纵疾病，所以谈论这样的话题自然也就很平常了。\n\n不过好奇心很难抵挡啊，那就假装自己能帮上忙，然后接着问下去吧。\n\n\"好吧，你们要是能帮上忙的话就再好不过了\"\n\n\"嗯，主要是，想知道病原体之间的相互作用，会对疾病产生什么影响呢。你看啊，把不同种的病原体看做点，相互作用看成连接这些点的线，如果产生了环，那么病毒的威力就会大幅加强，我把它叫做加强环。\"\n\n\"病原体之间的相互作用也有很多种呢，我想研究的是，每种相互作用在产生加强环的过程中有多么重要。\"\n\n啊，听起来好复杂，不过如果帮了她的忙，地底的妖怪们大概会对我们友善一些吧。\n\n而且，点，边，环？这些名词似乎见过呢，说不定我真的能帮上忙？\n\n那么，继续详细地询问吧。\n\n嗯，问出来的信息已经记录在这张纸上了。\n", "description": "问题摘要:\n\n有n 种病原体，它们之间会产生$m$种无方向性的影响，第$i$种影响发生在$u_i$,$v_i$ **两种**病原体之间。\n\n我们把所有的**影响**按编号顺序排成一个序列，如果某一个区间包含有环，那么这个区间被称作加强区间。\n\n求每种影响分别在多少个加强区间中出现过。\n\n那么，到底怎样做才能高效的得出结果呢？\n\n(后续剧情见本题题解，接下来请看T2)", "inputFormat": "第一行一个数$m$\n接下来$m$行每行两个数$u_i$,$v_i$，用空格分隔", "outputFormat": "一行$m$个数字，第$i$个数字代表第$i$种影响在多少个加强区间内出现过，数字之间用空格分隔", "hint": "###样例解释：\n\n第一种影响在[1,4]和[1,5]两个加强区间内出现\n\n第二种影响在[1,4]、[1,5]和[2,5]三个加强区间内出现\n\n第三种影响在[1,5]、[1,4]和[2,5]三个加强区间内出现\n\n第四种影响在[1,4]、[2,5]和[1,5]三个加强区间内出现\n\n第五种影响在[2,5]和[1,5]两个加强区间内出现\n\n注意：加强区间是由“影响”构成的，而不是由“病原体”构成的\n\n$n\\leqslant2m\\leqslant400000$\n\n测试点1~2总分10分，$m\\leqslant5$\n\n测试点3~6总分20分，$m\\leqslant200$\n\n测试点7~12总分30分，$m\\leqslant5000$\n\n测试点13~15总分15分，$m\\leqslant50000$\n\n测试点16~18总分15分，$m\\leqslant50000$，捆绑测试\n\n测试点19~22总分10分，$m\\leqslant200000$，捆绑测试\n\nby oscar", "locale": "zh-CN"}}}
{"pid": "P4231", "type": "P", "difficulty": 4, "samples": [["5 2\n1 5 2 10\n2 4 1 1\n", "3 10"], ["6 2\n1 5 2 10\n2 4 1 1", "3 10"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["前缀和", "差分"], "title": "三步必杀", "background": "### （三）旧都\n\n离开狭窄的洞穴，眼前豁然开朗。\n\n天空飘着不寻常的雪花。\n\n一反之前的幽闭，现在面对的，是繁华的街市，可以听见酒碗碰撞的声音。\n\n这是由被人们厌恶的鬼族和其他妖怪们组成的小社会，一片其乐融融的景象。\n\n诶，不远处突然出现了一些密密麻麻的小点，好像大颗粒扬尘一样。\n\n离得近了点，终于看清楚了。\n\n长着角的鬼们聚在一起，围观着另一只鬼的表演。\n\n那”扬尘”，其实都是弹幕。\n\n勇仪的招数之一，三步之内，所到之处弹幕云集，几乎没有生存可能。\n\n为了强化这一技能，勇仪将对着一排柱子进行攻击。\n\n旧地狱的柱子虽然无比坚固，但保险起见还是先要了解一下这样一套攻击对柱子有多少损伤，顺带也能检验练习的效果。\n\n勇仪决定和其它鬼们商量商量...\n\n“我知道妖怪之山的河童一族有一种叫做计算机的神奇道具，说不定可以借来用用”，萃香说道。\n\n于是旧地狱的鬼族就决定请河城荷取来帮忙了。\n\n“要记录【所有柱子的损伤程度】吗”，荷取问道。\n\n经过进一步的询问，荷取发现他们仅仅需要【所有攻击都完成后】柱子的损伤程度。\n\n任务了解地差不多了，荷取将其中的重要部分提取了出来，记录在了她的工作笔记本上：\n\n(记录的内容见题目描述)\n\n那么实验就这样开始了。\n\n在惊天动地的碰撞声中，勇仪每完成一轮攻击，荷取都忠实地记录下对每根柱子产生的伤害。而此时勇仪就在旁边等待着记录完成，然后再进行下一轮的攻击。\n\n地面上，天色渐晚。\n\n“不想在这里留到深夜啊，不然就回不了家了”，荷取这样想着，手中依然在重复地向计算机中输入新产生的信息。\n\n“真的必须一次一次地记录下每轮攻击对每个柱子产生的伤害吗？有没有更高效的方法？”这一念头在荷取的心中闪过...\n\n（后续剧情在题解中，接下来请看T3）", "description": "$N$ 个柱子排成一排，一开始每个柱子损伤度为 $0$。\n\n接下来勇仪会进行 $M$ 次攻击，每次攻击可以用 $4$ 个参数 $l,r,s,e$ 来描述：\n\n表示这次攻击作用范围为第 $l$ 个到第 $r$ 个之间所有的柱子(包含 $l,r$)，对第一个柱子的伤害为 $s$，对最后一个柱子的伤害为 $e$。\n\n攻击产生的伤害值是一个等差数列。若 $l=1,r=5,s=2,e=10$，则对第 $1 \\sim 5$ 个柱子分别产生 $2,4,6,8,10$ 的伤害。\n\n鬼族们需要的是所有攻击完成之后每个柱子的损伤度。", "inputFormat": "第一行 $2$ 个整数 $N,M$，用空格隔开，下同。\n\n接下来 $M$ 行，每行 $4$ 个整数 $l,r,s,e$，含义见题目描述。\n\n数据保证对每个柱子产生的每次伤害值都是整数。", "outputFormat": "由于输出数据可能过大无法全部输出，为了确保你真的能维护所有柱子的损伤度，只要输出它们的异或和与最大值即可。\n\n（异或和就是所有数字按位异或起来的值。）\n\n（异或运算符在 c++ 里为 `^`。）", "hint": "### 样例解释：\n\n样例 $1$：\n\n第一次攻击产生的伤害：$2,4,6,8,10$。\n\n第二次攻击产生的伤害：$0,1,1,1,0$。\n\n所有攻击结束后每个柱子的损伤程度：$2,5,7,9,10$。\n\n输出异或和与最大值，就是 $3,10$。\n\n样例 $2$：\n\n没有打到第六根柱子，答案不变\n\n### 数据范围：\n\n本题满分为 $100$ 分，下面是 $4$ 个子任务。$(x/y)$ 表示(得分/测试点数量)。\n\n妖精级 $(18/3)$：$1 \\le n,m \\le 1000$。这种工作即使像妖精一样玩玩闹闹也能完成吧？\n\n河童级 $(10/1)$：$s=e$，这可以代替我工作吗？\n\n天狗级 $(20/4)$：$1 \\le n,m \\le 10^5$。小打小闹不再可行了呢。\n\n鬼神级 $(52/2)$：没有特殊限制。要真正开始思考了。\n\n以上四部分数据不相交。\n\n对于全部的数据：$1\\le n\\le 10^7$，$1\\le m\\le 3\\times 10^5$，$1\\le l < r \\le n$.\n\n所有输入输出数据以及柱子受损伤程度始终在 $[0,9 \\times 10^{18}]$ 范围内。\n\n### 提示：\n\n由于种种原因，时间限制可能会比较紧，c++ 选手请不要使用 `cin` 读入数据。\n\nby orangebird。", "locale": "zh-CN", "translations": {"en": {"title": "Three-Step Surekill", "background": "(3) The Old Capital\n\nLeaving the narrow cave, the view suddenly opened up.\n\nUnusual snowflakes drifted in the sky.\n\nIn contrast to the previous confinement, there was now a bustling marketplace, with the clinking of wine bowls audible.\n\nThis was a small society made up of the oni, who were disliked by humans, and other youkai, a scene of harmony and joy.\n\nEh? Not far away, some dense tiny dots appeared, like big grains of dust swirling in the air.\n\nGetting closer, it finally became clear.\n\nHorned oni gathered together, watching another oni’s performance.\n\nThat “dust cloud” was actually danmaku.\n\nOne of Yuugi’s moves: within three steps, wherever she passes, danmaku converge, leaving almost no chance of survival.\n\nTo strengthen this skill, Yuugi would attack a row of pillars.\n\nAlthough the pillars of the Old Hell were incredibly sturdy, it was still safer to first figure out how much damage such a sequence of attacks would cause to the pillars, and this could also help evaluate the effectiveness of practice.\n\nYuugi decided to discuss it with the other oni...\n\n“I know the kappa clan on Youkai Mountain has a magical tool called a computer; maybe we can borrow it,” said Suika.\n\nSo the oni of the Old Hell decided to ask Nitori Kawashiro to help.\n\n“Do you want to record the damage levels of all pillars?” Nitori asked.\n\nAfter further inquiries, Nitori found that they only needed the damage levels of the pillars after all attacks were completed.\n\nHaving understood the task, Nitori extracted the important parts and wrote them down in her work notebook:\n\n(See Problem Description for the recorded content.)\n\nThus the experiment began.\n\nAmid earth-shaking collisions, after Yuugi completed each round of attacks, Nitori faithfully recorded the damage inflicted on each pillar. Yuugi, meanwhile, waited for the recording to be completed before proceeding to the next round.\n\nOn the ground, dusk approached.\n\n“I don’t want to stay here until late at night, or I won’t be able to get home,” thought Nitori, her hands still repeatedly entering newly generated information into the computer.\n\n“Do I really have to record, one by one, the damage to each pillar after every round of attacks? Is there a more efficient way?” This thought flashed through Nitori’s mind...\n\n(The rest of the story is in the editorial; next, see T3.)", "description": "There are $N$ pillars in a row, and initially each pillar has damage $0$.\n\nYuugi will perform $M$ attacks. Each attack is described by four parameters $l, r, s, e$:\n\nIt means this attack affects all pillars from the $l$-th to the $r$-th (inclusive), dealing damage $s$ to the first pillar and $e$ to the last pillar within the range.\n\nThe damage values form an arithmetic progression. For example, if $l = 1, r = 5, s = 2, e = 10$, then the damages to pillars $1 \\sim 5$ are $2, 4, 6, 8, 10$ respectively.\n\nThe oni need the final damage of each pillar after all attacks are completed.", "inputFormat": "The first line contains $2$ integers $N, M$, separated by a space; same below.\n\nEach of the next $M$ lines contains $4$ integers $l, r, s, e$, as described above.\n\nIt is guaranteed that every individual damage applied to any pillar is an integer.", "outputFormat": "Because the output might be too large to print in full, to ensure you can indeed maintain all pillars’ damage, output two integers separated by a space: the XOR sum of all pillars’ final damages and the maximum of them.\n\n(The XOR sum is the value obtained by bitwise XOR over all numbers.)\n\n(The XOR operator in C++ is `^`.)", "hint": "Sample explanation:\n\nSample 1:\n\nDamage from the first attack: $2, 4, 6, 8, 10$.\n\nDamage from the second attack: $0, 1, 1, 1, 0$.\n\nFinal damage of each pillar after all attacks: $2, 5, 7, 9, 10$.\n\nOutput the XOR sum and the maximum, which are $3, 10$.\n\nSample 2:\n\nThe sixth pillar is not hit, so the answer remains unchanged.\n\nConstraints:\n\nThis problem is worth $100$ points, split into $4$ subtasks. $(x/y)$ means (score/testcase count).\n\n- Fairy level $(18/3)$: $1 \\le N, M \\le 1000$. Even fairies playing around could finish this job, right?\n- Kappa level $(10/1)$: $s = e$. Can this replace my work?\n- Tengu level $(20/4)$: $1 \\le N, M \\le 10^5$. Small tricks no longer suffice.\n- Oni God level $(52/2)$: No special restrictions. Time to really think.\n\nThese four parts of testdata do not overlap.\n\nFor all data: $1 \\le N \\le 10^7$, $1 \\le M \\le 3 \\times 10^5$, $1 \\le l < r \\le N$.\n\nAll input, output, and pillar damage values are always within $[0, 9 \\times 10^{18}]$.\n\nTip:\n\nDue to various reasons, the time limit may be tight. C++ participants, please do not use `cin` for input.\n\nby orangebird.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "三步必杀", "background": "### （三）旧都\n\n离开狭窄的洞穴，眼前豁然开朗。\n\n天空飘着不寻常的雪花。\n\n一反之前的幽闭，现在面对的，是繁华的街市，可以听见酒碗碰撞的声音。\n\n这是由被人们厌恶的鬼族和其他妖怪们组成的小社会，一片其乐融融的景象。\n\n诶，不远处突然出现了一些密密麻麻的小点，好像大颗粒扬尘一样。\n\n离得近了点，终于看清楚了。\n\n长着角的鬼们聚在一起，围观着另一只鬼的表演。\n\n那”扬尘”，其实都是弹幕。\n\n勇仪的招数之一，三步之内，所到之处弹幕云集，几乎没有生存可能。\n\n为了强化这一技能，勇仪将对着一排柱子进行攻击。\n\n旧地狱的柱子虽然无比坚固，但保险起见还是先要了解一下这样一套攻击对柱子有多少损伤，顺带也能检验练习的效果。\n\n勇仪决定和其它鬼们商量商量...\n\n“我知道妖怪之山的河童一族有一种叫做计算机的神奇道具，说不定可以借来用用”，萃香说道。\n\n于是旧地狱的鬼族就决定请河城荷取来帮忙了。\n\n“要记录【所有柱子的损伤程度】吗”，荷取问道。\n\n经过进一步的询问，荷取发现他们仅仅需要【所有攻击都完成后】柱子的损伤程度。\n\n任务了解地差不多了，荷取将其中的重要部分提取了出来，记录在了她的工作笔记本上：\n\n(记录的内容见题目描述)\n\n那么实验就这样开始了。\n\n在惊天动地的碰撞声中，勇仪每完成一轮攻击，荷取都忠实地记录下对每根柱子产生的伤害。而此时勇仪就在旁边等待着记录完成，然后再进行下一轮的攻击。\n\n地面上，天色渐晚。\n\n“不想在这里留到深夜啊，不然就回不了家了”，荷取这样想着，手中依然在重复地向计算机中输入新产生的信息。\n\n“真的必须一次一次地记录下每轮攻击对每个柱子产生的伤害吗？有没有更高效的方法？”这一念头在荷取的心中闪过...\n\n（后续剧情在题解中，接下来请看T3）", "description": "$N$ 个柱子排成一排，一开始每个柱子损伤度为 $0$。\n\n接下来勇仪会进行 $M$ 次攻击，每次攻击可以用 $4$ 个参数 $l,r,s,e$ 来描述：\n\n表示这次攻击作用范围为第 $l$ 个到第 $r$ 个之间所有的柱子(包含 $l,r$)，对第一个柱子的伤害为 $s$，对最后一个柱子的伤害为 $e$。\n\n攻击产生的伤害值是一个等差数列。若 $l=1,r=5,s=2,e=10$，则对第 $1 \\sim 5$ 个柱子分别产生 $2,4,6,8,10$ 的伤害。\n\n鬼族们需要的是所有攻击完成之后每个柱子的损伤度。", "inputFormat": "第一行 $2$ 个整数 $N,M$，用空格隔开，下同。\n\n接下来 $M$ 行，每行 $4$ 个整数 $l,r,s,e$，含义见题目描述。\n\n数据保证对每个柱子产生的每次伤害值都是整数。", "outputFormat": "由于输出数据可能过大无法全部输出，为了确保你真的能维护所有柱子的损伤度，只要输出它们的异或和与最大值即可。\n\n（异或和就是所有数字按位异或起来的值。）\n\n（异或运算符在 c++ 里为 `^`。）", "hint": "### 样例解释：\n\n样例 $1$：\n\n第一次攻击产生的伤害：$2,4,6,8,10$。\n\n第二次攻击产生的伤害：$0,1,1,1,0$。\n\n所有攻击结束后每个柱子的损伤程度：$2,5,7,9,10$。\n\n输出异或和与最大值，就是 $3,10$。\n\n样例 $2$：\n\n没有打到第六根柱子，答案不变\n\n### 数据范围：\n\n本题满分为 $100$ 分，下面是 $4$ 个子任务。$(x/y)$ 表示(得分/测试点数量)。\n\n妖精级 $(18/3)$：$1 \\le n,m \\le 1000$。这种工作即使像妖精一样玩玩闹闹也能完成吧？\n\n河童级 $(10/1)$：$s=e$，这可以代替我工作吗？\n\n天狗级 $(20/4)$：$1 \\le n,m \\le 10^5$。小打小闹不再可行了呢。\n\n鬼神级 $(52/2)$：没有特殊限制。要真正开始思考了。\n\n以上四部分数据不相交。\n\n对于全部的数据：$1\\le n\\le 10^7$，$1\\le m\\le 3\\times 10^5$，$1\\le l < r \\le n$.\n\n所有输入输出数据以及柱子受损伤程度始终在 $[0,9 \\times 10^{18}]$ 范围内。\n\n### 提示：\n\n由于种种原因，时间限制可能会比较紧，c++ 选手请不要使用 `cin` 读入数据。\n\nby orangebird。", "locale": "zh-CN"}}}
{"pid": "P4232", "type": "P", "difficulty": 7, "samples": [["3 2 1 2 10\n1 3\n2 3\n", "11.000"], ["6 8 2 1 2\n1 2\n1 3\n1 5\n2 3\n3 5\n5 6\n6 4\n2 4\n", "2.333"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递归", "线性规划", "期望"], "title": "无意识之外的捉迷藏", "background": "### （五）心与心的对话\n\n旧都还在下着雪。\n\n不知道走了多远的路，已经远离街市了。\n\n眼前隐隐约约能看到一座巨大的宫殿。\n\n那就是，地灵殿吗？\n\n心里突然紧张了起来。\n\n这里住着旧地狱最可怕的觉妖怪。\n\n古明地觉，她拥有读心的能力。人类，妖怪，甚至是怨灵，站在她面前的时候都如同赤身裸体，没有任何秘密可言。而且，听说在战斗中，她还会使用催眠术不断激起对手内心深处的恐怖回忆，从心灵上打垮对手。这样的妖怪自然会被人讨厌啦。\n\n不过，此次地底之旅可不能因为要遇到可怕的妖怪而就此结束。\n\n咚咚咚，敲了敲地灵殿的大门。\n\n“来客吗，真是少见呢。”\n\n眼前，站着一个少女，穿着蓝色的衣服，粉红色的裙子，头发也是粉红色的。\n\n在她的胸前，悬着一只红色的大眼睛，通过眼睛周围的六根管子连接着身体。\n\n她看起来很温柔的样子，完全不像听说的那样恐怖。\n\n“来地底旅行的外面世界的人类吗？真是非常少见呢，居然找到了这里”\n\n“看起来没有别的想法，就是想来转转呢，那就进来吧”\n\n走进大门。\n\n不愧是地灵”殿”，真的是好大的一个宫殿，桃红色和黑色相间的地板，印有花纹的窗户。\n\n眼前是一组很宽的台阶，通向二楼，然后分成左右两个通道。\n\n“很漂亮吧，这里空间大，宠物们都很喜欢呢。”\n\n就这样，我跟着觉进入了她工作的房间，我们坐在沙发上聊了很久，虽然我很少说话。\n\n在聊天的过程中，我了解到她还有一个妹妹古明地恋，由于不愿让别人因为自己会读心而讨厌自己，闭上了觉之瞳。觉为了开导妹妹，经常和宠物陪着她玩。\n\n地灵殿，觉和妹妹，宠物们，一直在过着平静又温馨的生活。\n\n“既然来这里了，就和我们一起玩吧。”觉邀请我们参与她们的游戏。\n\n地底的妖怪会玩怎样的游戏呢？\n\n于是，就这样，我就答应参与觉和恋的“无意识的捉迷藏”了。\n\n说是”捉迷藏”，其实和普通的捉迷藏区别很大，更类似于”捉人游戏”。\n\n就是觉和恋一开始分别站在两个地方，觉要捉到恋就算赢了。\n\n但为什么又说是”捉迷藏”呢？\n\n原来恋恋可以无意识地行动，也就是可以让周围人在潜意识里忽略她的存在，类似隐身，但又不是隐身。真是有趣的能力呢，是不是闭上了觉之瞳的缘故？\n\n我们玩得很开心。有时无意识碰到了恋恋的手，还吓了一跳呢。\n\n一段时间后，姐妹俩累了，觉还有工作要处理，就先回去了。\n\n宠物们似乎意犹未尽，她们还想继续。\n\n“可是在这个旧地狱啊，除了主人的妹妹恋以外，哪里又有妖怪能够操纵无意识呢？\n\n算了,干脆玩普通的捉人游戏吧。”阿燐提议道。\n\n于是宠物们很快又忘我地投入了”无意识之外的捉迷藏”中。\n\n不知什么时候，我感到背后一凉，回过头一看，原来是恋恋。\n\n我们就这样站在这里看着宠物们玩。\n\n虽然不知道为什么能耐心地看那么长时间，但几个小时过去了，我们依然站在这里。\n\n恋恋好像有一些疑问，在经过简单的交流后，我把她的疑问做了一个总结。\n\n(见题目描述)\n\n这个问题对无意识的恋恋来说果然无法解决啊。\n\n能和姐妹俩聊得这么开心，真是很感激呢，那就尽自己的努力思考一下这个问题吧。\n\n(后续剧情见题解，接下来请看T4)", "description": "### 问题摘要\n\n在一个有向无环图上，阿燐和阿空第0个时刻分别站在编号为 $s_r$，$s_k$ 的节点，二人都知道双方的初始位置，对地图完全了解。\n\n从第 $1$ 个时刻起，每个时刻阿燐和阿空都可以选择站着不动，也可以选择移动到相邻的节点，二人每时刻的移动是同时开始的，并且不能中途改变方向。\n\n阿燐被阿空捉住时，游戏立即结束。如果阿空一直没有捉住阿燐，第 $t$ 个时刻结束后两人就不能再继续移动了，游戏将在第 $t+1$ 个时刻结束。\n\n阿空的目的是尽快捉住阿燐(捉住的定义是与阿燐同一时刻站在同一节点)，而阿燐的目的是尽可能更长时间不被阿空捉住。具体而言，若一场游戏进行了 $t_0$ 时刻，阿燐的得分是 $t_0$ ，阿空的得分是 $-t_0$，双方都希望自己得分(或得分的期望值)更高。\n\n我们认为在这个过程中阿燐和阿空随时都能知道对方的位置。两人在第 $t$ 个时刻不能看出第 $t+1$ 个时刻对方要走到哪里。\n\n恋恋想知道，在双方最优决策的情况下，游戏结束时刻的期望值是多少。", "inputFormat": "第一行 $5$ 个整数 $n$，$m$，$s_r$，$s_k$，$t$，用空格隔开，下同。$n$ 表示地图点数，$m$ 表示边数。\n\n接下来 $m$ 行，每行两个整数 $a$，$b$，表示从 $a$ 到 $b$ 有一条单向边（不存在重边）。", "outputFormat": "一个实数，四舍五入保留 $3$ 位小数，表示游戏结束时刻的期望值。\n\n你的答案必须和标准答案完全相同才算正确。", "hint": "### 样例解释\n\n样例 $1$：阿燐只要一直不动，阿空在前$t$单位时间内就无法抓到阿燐，答案为 $t+1$，即 ```11.000```。\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n对于 30% 的数据，$n\\leqslant3$。\n\n对于另外 70% 的数据，$n$，$t\\leqslant20$，其中前 40% 的数据和后 30% 的数据分别捆绑测试。\n\n### 提示\n本题主要考察你能否使用正确的方法算出答案，对算法运行耗时要求不高。\n\nby orangebird", "locale": "zh-CN", "translations": {"en": {"title": "Hide-and-Seek Beyond the Unconscious", "background": "(5) A Conversation from Heart to Heart.\n\nSnow is still falling in the old capital.\n\nI don’t know how far I’ve walked; I’ve already gone far from the marketplace.\n\nAhead, I can vaguely see a huge palace.\n\nIs that the Palace of the Earth Spirits?\n\nI suddenly feel nervous.\n\nHere lives the most fearsome satori youkai in the Old Hell.\n\nKomeiji Satori, who has the power to read minds. Humans, youkai, even vengeful spirits—standing before her is like being stripped bare, with no secrets at all. It’s also said that in battle she uses hypnosis to repeatedly stir up her opponent’s deepest fears, defeating them from within. Of course a youkai like that would be disliked.\n\nStill, this underground trip can’t end just because we’re about to meet someone scary.\n\nKnock, knock—three taps on the palace gate.\n\n“A visitor? How rare.”\n\nIn front of me stands a girl wearing blue clothes and a pink skirt, with pink hair.\n\nOn her chest hangs a large red eye, connected to her body by six tubes radiating from it.\n\nShe looks very gentle—nothing like the terrifying stories I’d heard.\n\n“A human from the surface traveling underground? That’s really rare—you actually found this place.”\n\n“It seems you don’t have any other intention and just want to look around. Come in, then.”\n\nWe step through the gate.\n\nWorthy of the “Palace,” it’s truly vast—checkered floors in peach-pink and black, windows adorned with patterns.\n\nAhead is a broad staircase leading to the second floor, where it splits into left and right corridors.\n\n“Pretty, isn’t it? It’s spacious here; the pets love it.”\n\nI follow Satori into her office. We sit on the sofa and chat for a long time, though I speak very little.\n\nDuring the conversation, I learn that she has a younger sister, Komeiji Koishi. Not wanting to be disliked for reading minds, Koishi closed her satori eye. To guide her sister, Satori often plays with her, accompanied by their pets.\n\nIn the Palace of the Earth Spirits, Satori, her sister, and their pets have lived a peaceful, warm life.\n\n“Since you’re here, play with us,” Satori invites us to join their game.\n\nWhat kind of games do underground youkai play?\n\nAnd so, I agree to join Satori and Koishi’s “unconscious hide-and-seek.”\n\nThey call it “hide-and-seek,” but it’s actually very different from the usual game—more like tag.\n\nSatori and Koishi start in two different places; Satori wins if she tags Koishi.\n\nBut why call it “hide-and-seek”?\n\nIt turns out Koishi can act unconsciously—she can make people around her subconsciously ignore her presence. It’s like invisibility, but not exactly the same. What an interesting ability—maybe it’s because she closed her satori eye?\n\nWe have a blast. Sometimes I accidentally brush Koishi’s hand and jump in surprise.\n\nAfter a while, the sisters get tired. Satori has work to handle and heads back.\n\nThe pets seem unsatisfied and want to continue.\n\n“But down here in the Old Hell, besides the mistress’s sister Koishi, who else can manipulate the unconscious?\n\nForget it, let’s just play ordinary tag,” Orin suggests.\n\nThe pets quickly throw themselves into “hide-and-seek beyond the unconscious.”\n\nAt some point, I feel a chill behind me. I turn around—it’s Koishi.\n\nWe just stand there, watching the pets play.\n\nThough I don’t know why I can patiently watch for so long, even after hours we’re still standing there.\n\nKoishi seems to have some questions. After a brief exchange, I summarize them.\n\n(See Problem Description.)\n\nAs expected, this problem is indeed hard for unconscious Koishi.\n\nI’m grateful to have such a pleasant chat with the sisters, so I’ll do my best to think this problem through.\n\n(For the continuation of the story, see the editorial. Next, please see T4.)", "description": "Problem summary.\n\nOn a directed acyclic graph, A Rin and A Kong stand at time $0$ on nodes numbered $s_r$ and $s_k$, respectively. Both know each other’s initial positions and have full knowledge of the map.\n\nStarting from time $1$, at each time step both A Rin and A Kong may either stay put or move to an adjacent node along a directed edge. Their moves at each time step start simultaneously, and they cannot change direction mid-step.\n\nWhen A Rin is caught by A Kong, the game ends immediately. If A Kong never catches A Rin, then after time $t$ ends, neither can move anymore, and the game ends at time $t+1$.\n\nA Kong’s goal is to catch A Rin as quickly as possible (catching means being on the same node at the same time), while A Rin’s goal is to avoid being caught for as long as possible. Specifically, if a game lasts for $t_0$ time steps, A Rin’s score is $t_0$, and A Kong’s score is $-t_0$. Both aim to maximize their own (expected) scores.\n\nWe assume that throughout the process A Rin and A Kong always know each other’s current positions. At time $t$, neither can tell where the other will choose to move at time $t+1$.\n\nKoishi wants to know: under optimal play by both sides, what is the expected ending time of the game?", "inputFormat": "The first line contains $5$ integers $n$, $m$, $s_r$, $s_k$, $t$, separated by spaces. Here, $n$ is the number of nodes and $m$ is the number of edges.\n\nThe next $m$ lines each contain two integers $a$, $b$, indicating a directed edge from $a$ to $b$ (no multiple edges).", "outputFormat": "Output a real number, rounded to $3$ decimal places, which is the expected ending time of the game.\n\nYour answer must exactly match the standard answer to be accepted.", "hint": "Sample explanation.\n\nSample $1$: If A Rin always stays still, then A Kong cannot catch A Rin within the first $t$ units of time; the answer is $t+1$, i.e.,\n``` \n11.000\n```\n\nConstraints.\n\nThis problem uses bundled testdata.\n\n- For $30\\%$ of the data, $n \\leqslant 3$.\n- For the remaining $70\\%$ of the data, $n, t \\leqslant 20$. Among these, the first $40\\%$ and the last $30\\%$ are bundled and tested separately.\n\nTip: This problem mainly checks whether you can use the correct method to compute the answer; strict time limits on the algorithm are not the focus.\n\nby orangebird.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "无意识之外的捉迷藏", "background": "### （五）心与心的对话\n\n旧都还在下着雪。\n\n不知道走了多远的路，已经远离街市了。\n\n眼前隐隐约约能看到一座巨大的宫殿。\n\n那就是，地灵殿吗？\n\n心里突然紧张了起来。\n\n这里住着旧地狱最可怕的觉妖怪。\n\n古明地觉，她拥有读心的能力。人类，妖怪，甚至是怨灵，站在她面前的时候都如同赤身裸体，没有任何秘密可言。而且，听说在战斗中，她还会使用催眠术不断激起对手内心深处的恐怖回忆，从心灵上打垮对手。这样的妖怪自然会被人讨厌啦。\n\n不过，此次地底之旅可不能因为要遇到可怕的妖怪而就此结束。\n\n咚咚咚，敲了敲地灵殿的大门。\n\n“来客吗，真是少见呢。”\n\n眼前，站着一个少女，穿着蓝色的衣服，粉红色的裙子，头发也是粉红色的。\n\n在她的胸前，悬着一只红色的大眼睛，通过眼睛周围的六根管子连接着身体。\n\n她看起来很温柔的样子，完全不像听说的那样恐怖。\n\n“来地底旅行的外面世界的人类吗？真是非常少见呢，居然找到了这里”\n\n“看起来没有别的想法，就是想来转转呢，那就进来吧”\n\n走进大门。\n\n不愧是地灵”殿”，真的是好大的一个宫殿，桃红色和黑色相间的地板，印有花纹的窗户。\n\n眼前是一组很宽的台阶，通向二楼，然后分成左右两个通道。\n\n“很漂亮吧，这里空间大，宠物们都很喜欢呢。”\n\n就这样，我跟着觉进入了她工作的房间，我们坐在沙发上聊了很久，虽然我很少说话。\n\n在聊天的过程中，我了解到她还有一个妹妹古明地恋，由于不愿让别人因为自己会读心而讨厌自己，闭上了觉之瞳。觉为了开导妹妹，经常和宠物陪着她玩。\n\n地灵殿，觉和妹妹，宠物们，一直在过着平静又温馨的生活。\n\n“既然来这里了，就和我们一起玩吧。”觉邀请我们参与她们的游戏。\n\n地底的妖怪会玩怎样的游戏呢？\n\n于是，就这样，我就答应参与觉和恋的“无意识的捉迷藏”了。\n\n说是”捉迷藏”，其实和普通的捉迷藏区别很大，更类似于”捉人游戏”。\n\n就是觉和恋一开始分别站在两个地方，觉要捉到恋就算赢了。\n\n但为什么又说是”捉迷藏”呢？\n\n原来恋恋可以无意识地行动，也就是可以让周围人在潜意识里忽略她的存在，类似隐身，但又不是隐身。真是有趣的能力呢，是不是闭上了觉之瞳的缘故？\n\n我们玩得很开心。有时无意识碰到了恋恋的手，还吓了一跳呢。\n\n一段时间后，姐妹俩累了，觉还有工作要处理，就先回去了。\n\n宠物们似乎意犹未尽，她们还想继续。\n\n“可是在这个旧地狱啊，除了主人的妹妹恋以外，哪里又有妖怪能够操纵无意识呢？\n\n算了,干脆玩普通的捉人游戏吧。”阿燐提议道。\n\n于是宠物们很快又忘我地投入了”无意识之外的捉迷藏”中。\n\n不知什么时候，我感到背后一凉，回过头一看，原来是恋恋。\n\n我们就这样站在这里看着宠物们玩。\n\n虽然不知道为什么能耐心地看那么长时间，但几个小时过去了，我们依然站在这里。\n\n恋恋好像有一些疑问，在经过简单的交流后，我把她的疑问做了一个总结。\n\n(见题目描述)\n\n这个问题对无意识的恋恋来说果然无法解决啊。\n\n能和姐妹俩聊得这么开心，真是很感激呢，那就尽自己的努力思考一下这个问题吧。\n\n(后续剧情见题解，接下来请看T4)", "description": "### 问题摘要\n\n在一个有向无环图上，阿燐和阿空第0个时刻分别站在编号为 $s_r$，$s_k$ 的节点，二人都知道双方的初始位置，对地图完全了解。\n\n从第 $1$ 个时刻起，每个时刻阿燐和阿空都可以选择站着不动，也可以选择移动到相邻的节点，二人每时刻的移动是同时开始的，并且不能中途改变方向。\n\n阿燐被阿空捉住时，游戏立即结束。如果阿空一直没有捉住阿燐，第 $t$ 个时刻结束后两人就不能再继续移动了，游戏将在第 $t+1$ 个时刻结束。\n\n阿空的目的是尽快捉住阿燐(捉住的定义是与阿燐同一时刻站在同一节点)，而阿燐的目的是尽可能更长时间不被阿空捉住。具体而言，若一场游戏进行了 $t_0$ 时刻，阿燐的得分是 $t_0$ ，阿空的得分是 $-t_0$，双方都希望自己得分(或得分的期望值)更高。\n\n我们认为在这个过程中阿燐和阿空随时都能知道对方的位置。两人在第 $t$ 个时刻不能看出第 $t+1$ 个时刻对方要走到哪里。\n\n恋恋想知道，在双方最优决策的情况下，游戏结束时刻的期望值是多少。", "inputFormat": "第一行 $5$ 个整数 $n$，$m$，$s_r$，$s_k$，$t$，用空格隔开，下同。$n$ 表示地图点数，$m$ 表示边数。\n\n接下来 $m$ 行，每行两个整数 $a$，$b$，表示从 $a$ 到 $b$ 有一条单向边（不存在重边）。", "outputFormat": "一个实数，四舍五入保留 $3$ 位小数，表示游戏结束时刻的期望值。\n\n你的答案必须和标准答案完全相同才算正确。", "hint": "### 样例解释\n\n样例 $1$：阿燐只要一直不动，阿空在前$t$单位时间内就无法抓到阿燐，答案为 $t+1$，即 ```11.000```。\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n对于 30% 的数据，$n\\leqslant3$。\n\n对于另外 70% 的数据，$n$，$t\\leqslant20$，其中前 40% 的数据和后 30% 的数据分别捆绑测试。\n\n### 提示\n本题主要考察你能否使用正确的方法算出答案，对算法运行耗时要求不高。\n\nby orangebird", "locale": "zh-CN"}}}
{"pid": "P4233", "type": "P", "difficulty": 7, "samples": [["4", "1\n-1\n1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化", "剪枝", "强连通分量", "概率论", "期望", "快速傅里叶变换 FFT"], "title": "射命丸文的笔记", "background": "### （七）再见，地底世界的朋友们\n\n在地灵殿住了许多天了呢。\n\n这些日子里，觉分享了很多旧地狱的故事。\n\n此次地底旅行，可以说是非常充实了。\n\n虽然仍旧有些不舍，不过人类总是要见太阳的，再说这样麻烦觉姐姐招待我们也有些过意不去呢。\n\n那么，和觉，恋，阿燐，阿空，以及其他宠物们说再见吧。\n\n......\n\n旧地狱的街市，依旧飘着雪。\n\n已经能看到溶洞了。\n\n环境又变得幽闭起来。\n\n诶，前面不是山女吗？\n\n“啊，你们要回地面了吗，玩的怎样？”\n\n“很开心呢，对了，剩下的问题已经解决了”\n\n我们向山女解释了从荷取那里听到的方法。\n\n“谢谢!”\n\n“不客气，那么再见了~”\n\n世界一片白茫茫的...\n\n阳光是那么的刺眼，以至于几分钟后我们才能睁开眼睛看清楚地面的景色。\n\n沿着魔法森林中的小路向神社走去，这次的旅行也在我们的脚步声中走向了尾声。\n\n前方的地面上忽然出现了一页破损的笔记。\n\n捡起来一看，发现是从文文的笔记本上脱落下来的。\n\n射命丸文，作为（不靠谱的）新闻记者，观察到最近地灵殿里的宠物们偶尔会互相打架，于是将每场决斗的胜负关系写在了她的笔记本上。刚刚捡起来的这页笔记，上面就记录着几场“单循环赛”。\n\n每场循环赛被抽象成一张竞赛图，其中顶点代表参加循环赛的宠物，从顶点 $u$ 指向顶点 $v$ 的边代表在一场比赛中宠物 $u$ 战胜了宠物 $v$。\n\n观察到这页笔记上所有的竞赛图中都至少存在一条经过所有顶点的回路，我们猜想文文只会记录这样的循环赛。\n\n可能是因为文文不清楚宠物们谁能打过谁，于是在那页笔记的最下面留下了一个这样的问题...\n\n(见题目描述)\n\n这最后一个问题，就留给你来解决啦。\n\n博丽大结界，已经在我们身后了。\n\n希望这次地底旅行，能给你留下美好的记忆~\n\n(全文完)", "description": "如果一个竞赛图含有哈密顿回路，则称这张竞赛图为值得记录的。\n\n从所有含有 $n$ 个顶点（顶点互不相同）的，值得记录的竞赛图中等概率随机选取一个。\n\n求选取的竞赛图中哈密顿回路数量的期望值。\n\n由于答案可能过大/丢失精度，只需要输出答案除以 $998244353$ 的余数。\n\n即：设答案为 $\\frac{q}{p}$，则你需要输出一个整数 $x$，满足 $px\\equiv q \\mod 998244353$ 且 $0\\leqslant x<998244353$，可以证明恰好存在一个这样的 $x$。\n\n若不存在这样的竞赛图，输出 `-1`。", "inputFormat": "一行一个正整数 $n$。", "outputFormat": "$n$ 行，第 $i$ 行一个数字，代表输入为 $i$ 时的答案", "hint": "### 样例解释：\n\n$n=1$ 时只有一种满足条件的竞赛图，就是一个点。\n\n$n=2$ 时竞赛图中只有一条边，不能形成哈密顿回路。\n\n$n=3$ 时有两种满足条件的竞赛图，分别为 $1\\to2\\to3\\to1$ 和 $1\\to3\\to2\\to1$，都只有 $1$ 条哈密顿回路，随机取出后期望值为 $1$。\n\n$n=4$ 时有很多种满足条件的的竞赛图，这里写不下了，但是所有满足条件的竞赛图都是同构的，所以随机取出后期望值为 $1$。\n\n### 数据范围：\n\n测试点 1~3 中 $n\\leqslant7$。\n\n测试点 4~6 中 $n\\leqslant10$。\n\n测试点 7~10 中 $n\\leqslant1000$。\n\n测试点 11~16 中 $n\\leqslant10000$。\n\n测试点 17~25 中 $n\\leqslant100000$。\n\n数据有梯度，每个测试点 $4$ 分。\n\n为防止卡常，最后两个点开 2s 时限。\n\n### 名词解释：\n\n[竞赛图](https://en.wikipedia.org/wiki/Tournament_(graph_theory))：指任意两个顶点间恰有一条有向边的有向图。\n\n[哈密顿回路](https://en.wikipedia.org/wiki/Hamiltonian_cycle)：指除起点和终点外经过所有顶点恰好一次且起点和终点相同的路径。\n\n\nby oscar\n", "locale": "zh-CN", "translations": {"en": {"title": "Aya Shameimaru's Notes", "background": "(7) Goodbye, friends in the Underworld.\n\nWe have stayed in the Palace of the Earth Spirits for many days.\n\nDuring these days, Satori shared many stories about the Former Hell.\n\nThis trip underground has been very fulfilling.\n\nAlthough we are still a bit reluctant to leave, humans must see the sun after all, and it would be a burden to keep troubling Satori to host us.\n\nWell then, let us say goodbye to Satori, Koishi, Orin, Okuu, and the other pets.\n\n...\n\nSnow is still drifting over the streets of Former Hell.\n\nWe can already see the karst cave.\n\nThe environment is becoming enclosed again.\n\nEh, isn’t that the mountain woman ahead?\n\n“Ah, you are returning to the surface? How was it?”\n\n“It was great. By the way, the remaining problem has been solved.”\n\nWe explained to the mountain woman the method we heard from Nitori.\n\n“Thanks!”\n\n“You’re welcome. See you~”\n\nThe world is a vast white...\n\nThe sunlight is so dazzling that it takes several minutes before we can open our eyes to see the scenery on the surface.\n\nWe follow the path through the Magic Forest toward the shrine. This journey comes to an end with the sound of our footsteps.\n\nSuddenly, a torn page appears on the ground ahead.\n\nPicking it up, we find that it fell out of Aya’s notebook.\n\nAya Shameimaru (Shameimaru Aya), being a (not-so-reliable) reporter, noticed that the pets in the Palace of the Earth Spirits would sometimes fight each other, so she wrote down the win–loss relationships for each duel in her notebook. On the page we just picked up, several “single round-robin tournaments” are recorded.\n\nEach round-robin tournament is abstracted as a tournament graph, where vertices represent pets participating in the round robin, and a directed edge from vertex $u$ to vertex $v$ means that pet $u$ defeated pet $v$ in a match.\n\nObserving that every tournament on this page contains at least one cycle that visits all vertices, we guess Aya records only such tournaments.\n\nPerhaps because Aya was unsure who could beat whom, she left a question at the very bottom of that page...\n\n(See Problem Description.)\n\nThis last question is for you to solve.\n\nThe Great Hakurei Barrier is already behind us.\n\nWe hope this trip underground leaves you with warm memories.\n\n(The End.)", "description": "If a tournament contains a Hamiltonian cycle, then we call this tournament “worth recording.”\n\nChoose uniformly at random from all “worth recording” tournaments with $n$ pairwise distinct vertices.\n\nFind the expected number of Hamiltonian cycles in the chosen tournament.\n\nSince the answer may be too large or lose precision, you only need to output the answer modulo $998244353$.\n\nThat is: let the answer be $\\frac{q}{p}$. You must output an integer $x$ such that $p x \\equiv q \\bmod 998244353$ and $0 \\leqslant x < 998244353$. It can be proved that such an $x$ exists and is unique.\n\nIf no such tournament exists, output `-1`.", "inputFormat": "One line with a positive integer $n$.", "outputFormat": "Output $n$ lines. On line $i$, print the answer for input $i$.", "hint": "Sample explanations:\n\n- When $n=1$, there is only one tournament, which is a single vertex.\n- When $n=2$, the tournament has only one edge and cannot form a Hamiltonian cycle.\n- When $n=3$, there are two “worth recording” tournaments, namely $1\\to2\\to3\\to1$ and $1\\to3\\to2\\to1$, each having exactly $1$ Hamiltonian cycle, so the expected value is $1$.\n- When $n=4$, there are many “worth recording” tournaments (too many to list here), but all that satisfy the condition are isomorphic, so the expected value is $1$.\n\nConstraints:\n\n- In test points 1–3, $n \\leqslant 7$.\n- In test points 4–6, $n \\leqslant 10$.\n- In test points 7–10, $n \\leqslant 1000$.\n- In test points 11–16, $n \\leqslant 10000$.\n- In test points 17–25, $n \\leqslant 100000$.\n\nThe testdata has a gradient; each test point is worth 4 points.\n\nTo avoid constant-factor issues, the last two points have a 2 s time limit.\n\nTerminology:\n\n- Tournament: https://en.wikipedia.org/wiki/Tournament_(graph_theory)\n- Hamiltonian cycle: https://en.wikipedia.org/wiki/Hamiltonian_cycle\n\nby oscar\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "射命丸文的笔记", "background": "### （七）再见，地底世界的朋友们\n\n在地灵殿住了许多天了呢。\n\n这些日子里，觉分享了很多旧地狱的故事。\n\n此次地底旅行，可以说是非常充实了。\n\n虽然仍旧有些不舍，不过人类总是要见太阳的，再说这样麻烦觉姐姐招待我们也有些过意不去呢。\n\n那么，和觉，恋，阿燐，阿空，以及其他宠物们说再见吧。\n\n......\n\n旧地狱的街市，依旧飘着雪。\n\n已经能看到溶洞了。\n\n环境又变得幽闭起来。\n\n诶，前面不是山女吗？\n\n“啊，你们要回地面了吗，玩的怎样？”\n\n“很开心呢，对了，剩下的问题已经解决了”\n\n我们向山女解释了从荷取那里听到的方法。\n\n“谢谢!”\n\n“不客气，那么再见了~”\n\n世界一片白茫茫的...\n\n阳光是那么的刺眼，以至于几分钟后我们才能睁开眼睛看清楚地面的景色。\n\n沿着魔法森林中的小路向神社走去，这次的旅行也在我们的脚步声中走向了尾声。\n\n前方的地面上忽然出现了一页破损的笔记。\n\n捡起来一看，发现是从文文的笔记本上脱落下来的。\n\n射命丸文，作为（不靠谱的）新闻记者，观察到最近地灵殿里的宠物们偶尔会互相打架，于是将每场决斗的胜负关系写在了她的笔记本上。刚刚捡起来的这页笔记，上面就记录着几场“单循环赛”。\n\n每场循环赛被抽象成一张竞赛图，其中顶点代表参加循环赛的宠物，从顶点 $u$ 指向顶点 $v$ 的边代表在一场比赛中宠物 $u$ 战胜了宠物 $v$。\n\n观察到这页笔记上所有的竞赛图中都至少存在一条经过所有顶点的回路，我们猜想文文只会记录这样的循环赛。\n\n可能是因为文文不清楚宠物们谁能打过谁，于是在那页笔记的最下面留下了一个这样的问题...\n\n(见题目描述)\n\n这最后一个问题，就留给你来解决啦。\n\n博丽大结界，已经在我们身后了。\n\n希望这次地底旅行，能给你留下美好的记忆~\n\n(全文完)", "description": "如果一个竞赛图含有哈密顿回路，则称这张竞赛图为值得记录的。\n\n从所有含有 $n$ 个顶点（顶点互不相同）的，值得记录的竞赛图中等概率随机选取一个。\n\n求选取的竞赛图中哈密顿回路数量的期望值。\n\n由于答案可能过大/丢失精度，只需要输出答案除以 $998244353$ 的余数。\n\n即：设答案为 $\\frac{q}{p}$，则你需要输出一个整数 $x$，满足 $px\\equiv q \\mod 998244353$ 且 $0\\leqslant x<998244353$，可以证明恰好存在一个这样的 $x$。\n\n若不存在这样的竞赛图，输出 `-1`。", "inputFormat": "一行一个正整数 $n$。", "outputFormat": "$n$ 行，第 $i$ 行一个数字，代表输入为 $i$ 时的答案", "hint": "### 样例解释：\n\n$n=1$ 时只有一种满足条件的竞赛图，就是一个点。\n\n$n=2$ 时竞赛图中只有一条边，不能形成哈密顿回路。\n\n$n=3$ 时有两种满足条件的竞赛图，分别为 $1\\to2\\to3\\to1$ 和 $1\\to3\\to2\\to1$，都只有 $1$ 条哈密顿回路，随机取出后期望值为 $1$。\n\n$n=4$ 时有很多种满足条件的的竞赛图，这里写不下了，但是所有满足条件的竞赛图都是同构的，所以随机取出后期望值为 $1$。\n\n### 数据范围：\n\n测试点 1~3 中 $n\\leqslant7$。\n\n测试点 4~6 中 $n\\leqslant10$。\n\n测试点 7~10 中 $n\\leqslant1000$。\n\n测试点 11~16 中 $n\\leqslant10000$。\n\n测试点 17~25 中 $n\\leqslant100000$。\n\n数据有梯度，每个测试点 $4$ 分。\n\n为防止卡常，最后两个点开 2s 时限。\n\n### 名词解释：\n\n[竞赛图](https://en.wikipedia.org/wiki/Tournament_(graph_theory))：指任意两个顶点间恰有一条有向边的有向图。\n\n[哈密顿回路](https://en.wikipedia.org/wiki/Hamiltonian_cycle)：指除起点和终点外经过所有顶点恰好一次且起点和终点相同的路径。\n\n\nby oscar\n", "locale": "zh-CN"}}}
{"pid": "P4234", "type": "P", "difficulty": 6, "samples": [["4 6 \n1 2 10 \n1 3 100 \n1 4 90 \n2 3 20 \n2 4 80 \n3 4 40 \n", "20"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["图论", "O2优化", "枚举", "深度优先搜索 DFS", "生成树", "动态树 LCT"], "title": "最小差值生成树", "background": "", "description": "给定一个点标号从 $1$ 到 $n$ 的、有 $m$ 条边的无向图，求边权最大值与最小值的差值最小的生成树。图可能存在自环。", "inputFormat": "第一行有两个整数，表示图的点数 $n$ 和边数 $m$。\n\n接下来 $m$ 行，每行三个整数 $u, v, w$，表示存在一条连接 $u, v$ 长度为 $w$ 的边。", "outputFormat": "输出一行一个整数，表示答案。\n", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\leq 100$，$m \\leq 10^3$。\n- 对于 $97\\%$ 的数据，保证 $n \\leq 500$，$m \\leq 10^5$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 5 \\times 10^4$，$1 \\leq m \\leq 2 \\times 10^5$，$1 \\leq u, v \\leq n$，$1 \\leq w \\leq 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "Minimum Difference Spanning Tree", "background": "", "description": "Given an undirected graph with vertices labeled from $1$ to $n$ and $m$ edges, find a spanning tree that minimizes the difference between the maximum and minimum edge weights in the tree. The graph may contain self-loops.", "inputFormat": "The first line contains two integers, the number of vertices $n$ and the number of edges $m$.\n\nThen follow $m$ lines. Each line contains three integers $u, v, w$, indicating there is an edge between $u$ and $v$ with weight $w$.", "outputFormat": "Output a single integer on one line, which is the answer.", "hint": "#### Constraints and Conventions\n\n- For $30\\%$ of the testdata, it is guaranteed that $n \\leq 100$, $m \\leq 10^3$.\n- For $97\\%$ of the testdata, it is guaranteed that $n \\leq 500$, $m \\leq 10^5$.\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 5 \\times 10^4$, $1 \\leq m \\leq 2 \\times 10^5$, $1 \\leq u, v \\leq n$, $1 \\leq w \\leq 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最小差值生成树", "background": "", "description": "给定一个点标号从 $1$ 到 $n$ 的、有 $m$ 条边的无向图，求边权最大值与最小值的差值最小的生成树。图可能存在自环。", "inputFormat": "第一行有两个整数，表示图的点数 $n$ 和边数 $m$。\n\n接下来 $m$ 行，每行三个整数 $u, v, w$，表示存在一条连接 $u, v$ 长度为 $w$ 的边。", "outputFormat": "输出一行一个整数，表示答案。\n", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\leq 100$，$m \\leq 10^3$。\n- 对于 $97\\%$ 的数据，保证 $n \\leq 500$，$m \\leq 10^5$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 5 \\times 10^4$，$1 \\leq m \\leq 2 \\times 10^5$，$1 \\leq u, v \\leq n$，$1 \\leq w \\leq 10^4$。", "locale": "zh-CN"}}}
{"pid": "P4235", "type": "P", "difficulty": 6, "samples": [["2 2\naa\naa", "32770\n"], ["3 6\ni\ndont\nknow\nwhat\nto\nsay", "58261\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 4500, 4500, 4500, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [192000, 192000, 192000, 192000, 192000, 192000, 192000, 192000, 192000, 192000, 192000, 192000, 192000, 192000, 192000, 192000, 192000, 192000]}, "tags": ["字符串", "O2优化", "哈希 hashing", "概率论"], "title": "Hash?", "background": "**zhoutb2333**学习了哈希算法，他于是去统计给定一些字符串，其中有多少个本质不同的字符串。\n\n\n但是**zhoutb2333**突发奇想，如果哈希采用的$base$每次随机，那么结果会变成什么样呢？\n\n**辣鸡出题人又出锅了！subtask3的数据有问题，现在统一将模数改为65537**\n\n题目来源：[zhoutb2333](https://www.luogu.org/space/show?uid=31564)", "description": "他通过某种办法，获得了一个函数：`int Rand(int x)`，它会等概率地返回一个 $[0,x)$ 中的整数。\n\n他写下了这样的代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int x=10,maxn=35,maxlen=16010;\nll HASH[maxn];\nconst ll p=65537;\nchar str[maxlen];\nll Hash(){\n    int base=Rand(x);\n    ll ret=0;\n    for(int i=1;str[i];i++)\n        ret=(ret*base+str[i]-'a'+1)%p;\n    return ret;\n}\nint main(){\n    int ans=0,n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        scanf(\"%s\",str+1),HASH[i]=Hash();\n    sort(HASH+1,HASH+n+1);\n    HASH[0]=-1;\n    for(int i=1;i<=n;i++)\n        ans+=(HASH[i]!=HASH[i-1]);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n```\n\n**zhoutb2333** 想问你，给定一些字符串和参数 $x$，答案 $ans$ 的期望是多少呢？\n\n$65537= 2^{16}+1$ **是质数**\n\n**参数 $x$ 在这个程序中是确定的 $10$，但是每次输入会给定。**", "inputFormat": "第一行三个整数 $x,N$，表示 $base$ 生成的参数和字符串的个数\n\n接下来 $N$ 行每行一个字符串，字符串仅由小写字母组成。", "outputFormat": "一行一个小数，表示答案 $ans$ 的期望，**模 $65537$ 输出**。\n\n即：如果你的答案为 $\\frac{q}{p}$（$\\gcd (p,q)=1$），那么输出使得 $px \\equiv q \\pmod {65537}$ 的最小正整数 $x$。可以证明答案 $ans$ 一定为正有理数，并且这样的 $x$ 一定存在。", "hint": "本题由 $3$ 个 $\\text{subtask}$ 组成，设 $M$ 为这 $N$ 个字符串中，每个字符串长度的最大值。\n\n对于 $\\text{subtask} \\ 1$：$1 \\le N \\le 8 , M \\le 10,x \\le 4$，分值为 $20$，时间限制为 $1s$。\n\n对于 $\\text{subtask} \\ 2$：$1 \\le N \\le 30 , M \\le 500,x \\le 500$，分值为 $50$，时间限制为 $1s$。\n\n对于 $\\text{subtask} \\ 3$：$1 \\le N \\le 5 , M \\le 16000,x \\le 16000$，分值为 $30$，时间限制为 $4.5s$。\n\n**样例 #1 解释：**\n\n参数 $x=2$，那么可能的哈希 $base$ 为 $0,1$。\n\n如果哈希第一个 `aa` 采用的 $base$ 和第二个 `aa` 的 $base$ 相同，那么答案为 $1$。\n\n如果两个 $base$ 不相同，那么答案为 $2$。\n\n分析发现这两种情况发生的概率相同，都是 $\\frac{1}{2}$，那么答案 $ans$ 的期望为 $1 * \\frac{1}{2} + 2 * \\frac{1}{2}=\\frac{3}{2}$。使得 $2x \\equiv 3 \\ \\pmod {65537}$ 的最小正整数 $x$ 为 $32770$。\n\n**样例 #2 解释：**\n\n求得答案为 $\\frac{53}{9}$。使得 $9x \\equiv 53 \\ \\pmod {65537}$ 的最小正整数 $x$ 为 $58261$。", "locale": "zh-CN", "translations": {"en": {"title": "Hash?", "background": "zhoutb2333 learned hashing and decided to count how many essentially different strings there are among some given strings.\n\nBut then zhoutb2333 had a sudden idea: if the hashing $base$ is chosen randomly each time, what will the result look like?\n\nThe lousy problem setter broke it again! The testdata for subtask 3 had an issue, so the modulus is now uniformly changed to $65537$.\n\nProblem source: [zhoutb2333](https://www.luogu.org/space/show?uid=31564).", "description": "By some means, he obtained a function: `int Rand(int x)`, which returns an integer uniformly at random from $[0, x)$.\n\nHe wrote the following code:\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int x=10,maxn=35,maxlen=16010;\nll HASH[maxn];\nconst ll p=65537;\nchar str[maxlen];\nll Hash(){\n    int base=Rand(x);\n    ll ret=0;\n    for(int i=1;str[i];i++)\n        ret=(ret*base+str[i]-'a'+1)%p;\n    return ret;\n}\nint main(){\n    int ans=0,n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        scanf(\"%s\",str+1),HASH[i]=Hash();\n    sort(HASH+1,HASH+n+1);\n    HASH[0]=-1;\n    for(int i=1;i<=n;i++)\n        ans+=(HASH[i]!=HASH[i-1]);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n```\n\nzhoutb2333 asks: given some strings and the parameter $x$, what is the expectation of the answer $ans$?\n\n$65537 = 2^{16} + 1$ is prime.\n\nThe parameter $x$ is fixed to $10$ in this program, but it will be provided in each input.", "inputFormat": "The first line contains two integers $x, N$, denoting the parameter that generates the $base$ and the number of strings.\n\nThe next $N$ lines each contain one string, consisting only of lowercase letters.", "outputFormat": "Output a single number on one line: the expectation of $ans$, output modulo $65537$.\n\nThat is, if your answer is $\\frac{q}{p}$ ($\\gcd(p, q) = 1$), then output the smallest positive integer $x$ such that $p x \\equiv q \\pmod{65537}$. It can be proved that the answer $ans$ is always a positive rational number, and such an $x$ always exists.", "hint": "This problem has $3$ $\\text{subtask}$s. Let $M$ be the maximum length among these $N$ strings.\n\nFor $\\text{subtask} \\ 1$: $1 \\le N \\le 8, \\ M \\le 10, \\ x \\le 4$, score $20$, time limit $1 \\ \\text{s}$.\n\nFor $\\text{subtask} \\ 2$: $1 \\le N \\le 30, \\ M \\le 500, \\ x \\le 500$, score $50$, time limit $1 \\ \\text{s}$.\n\nFor $\\text{subtask} \\ 3$: $1 \\le N \\le 5, \\ M \\le 16000, \\ x \\le 16000$, score $30$, time limit $4.5 \\ \\text{s}$.\n\nSample #1 explanation:\n\nWith parameter $x = 2$, the possible hash $base$ values are $0, 1$.\n\nIf the first `aa` and the second `aa` use the same $base$ for hashing, then the answer is $1$.\nIf the two $base$ values are different, then the answer is $2$.\n\nThese two cases happen with the same probability, both $\\frac{1}{2}$, so the expectation of $ans$ is $1 * \\frac{1}{2} + 2 * \\frac{1}{2} = \\frac{3}{2}$. The smallest positive integer $x$ such that $2 x \\equiv 3 \\ \\pmod{65537}$ is $32770$.\n\nSample #2 explanation:\n\nThe answer is $\\frac{53}{9}$. The smallest positive integer $x$ such that $9 x \\equiv 53 \\ \\pmod{65537}$ is $58261$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Hash?", "background": "**zhoutb2333**学习了哈希算法，他于是去统计给定一些字符串，其中有多少个本质不同的字符串。\n\n\n但是**zhoutb2333**突发奇想，如果哈希采用的$base$每次随机，那么结果会变成什么样呢？\n\n**辣鸡出题人又出锅了！subtask3的数据有问题，现在统一将模数改为65537**\n\n题目来源：[zhoutb2333](https://www.luogu.org/space/show?uid=31564)", "description": "他通过某种办法，获得了一个函数：`int Rand(int x)`，它会等概率地返回一个 $[0,x)$ 中的整数。\n\n他写下了这样的代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int x=10,maxn=35,maxlen=16010;\nll HASH[maxn];\nconst ll p=65537;\nchar str[maxlen];\nll Hash(){\n    int base=Rand(x);\n    ll ret=0;\n    for(int i=1;str[i];i++)\n        ret=(ret*base+str[i]-'a'+1)%p;\n    return ret;\n}\nint main(){\n    int ans=0,n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        scanf(\"%s\",str+1),HASH[i]=Hash();\n    sort(HASH+1,HASH+n+1);\n    HASH[0]=-1;\n    for(int i=1;i<=n;i++)\n        ans+=(HASH[i]!=HASH[i-1]);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n```\n\n**zhoutb2333** 想问你，给定一些字符串和参数 $x$，答案 $ans$ 的期望是多少呢？\n\n$65537= 2^{16}+1$ **是质数**\n\n**参数 $x$ 在这个程序中是确定的 $10$，但是每次输入会给定。**", "inputFormat": "第一行三个整数 $x,N$，表示 $base$ 生成的参数和字符串的个数\n\n接下来 $N$ 行每行一个字符串，字符串仅由小写字母组成。", "outputFormat": "一行一个小数，表示答案 $ans$ 的期望，**模 $65537$ 输出**。\n\n即：如果你的答案为 $\\frac{q}{p}$（$\\gcd (p,q)=1$），那么输出使得 $px \\equiv q \\pmod {65537}$ 的最小正整数 $x$。可以证明答案 $ans$ 一定为正有理数，并且这样的 $x$ 一定存在。", "hint": "本题由 $3$ 个 $\\text{subtask}$ 组成，设 $M$ 为这 $N$ 个字符串中，每个字符串长度的最大值。\n\n对于 $\\text{subtask} \\ 1$：$1 \\le N \\le 8 , M \\le 10,x \\le 4$，分值为 $20$，时间限制为 $1s$。\n\n对于 $\\text{subtask} \\ 2$：$1 \\le N \\le 30 , M \\le 500,x \\le 500$，分值为 $50$，时间限制为 $1s$。\n\n对于 $\\text{subtask} \\ 3$：$1 \\le N \\le 5 , M \\le 16000,x \\le 16000$，分值为 $30$，时间限制为 $4.5s$。\n\n**样例 #1 解释：**\n\n参数 $x=2$，那么可能的哈希 $base$ 为 $0,1$。\n\n如果哈希第一个 `aa` 采用的 $base$ 和第二个 `aa` 的 $base$ 相同，那么答案为 $1$。\n\n如果两个 $base$ 不相同，那么答案为 $2$。\n\n分析发现这两种情况发生的概率相同，都是 $\\frac{1}{2}$，那么答案 $ans$ 的期望为 $1 * \\frac{1}{2} + 2 * \\frac{1}{2}=\\frac{3}{2}$。使得 $2x \\equiv 3 \\ \\pmod {65537}$ 的最小正整数 $x$ 为 $32770$。\n\n**样例 #2 解释：**\n\n求得答案为 $\\frac{53}{9}$。使得 $9x \\equiv 53 \\ \\pmod {65537}$ 的最小正整数 $x$ 为 $58261$。", "locale": "zh-CN"}}}
{"pid": "P4236", "type": "P", "difficulty": 5, "samples": [["3\n2 5\n2 9\n3 9", "lsq Win\nwzt Win\nlsq Win"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["进制"], "title": "扑克", "background": "lsq邀请wzt去他家打扑克牌", "description": "lsq的扑克没有大小王，共计有n张，由于wzt沉迷于幂运算无法自拔，wzt提出要每次抽a^2张牌（这里“^”是乘方的意思），lsq觉得这样抽真没意思，于是改成了每次抽a^k（k是一个自然数，由游戏者自由选择）张牌。**由lsq开始**，每个人轮流按上述规则摸牌，谁先摸到最后一张牌谁就赢。\n\n由于时间充裕，lsq和wzt一共会玩q盘游戏，每一盘都有不同的a和n。wzt怒敲了一波代码，竟然可以算出当确定了a和n的值后，若能必胜如何下。lsq在见识过你的~~毒瘤~~操作后，希望你也帮他写出一个程序，能判断确定了a和n的值后他是否能赢，lsq当然知道怎么下最优，所以不需要你算出如何下 \n\n**注意：此题中两方的打牌决策都是若有必胜决策则必用必胜决策**\n\n此题中k是一个每次抽牌都可由抽牌者自己决定的一个非负整数，可以结合下面的样例加以理解", "inputFormat": "第一行一个数q， 表示有q局游戏\n接下来q行，每行两个整数a,n，意义如上", "outputFormat": "输出共q行\n若lsq能赢，输出“lsq Win”\n若wzt能赢，输出“wzt Win”", "hint": "对于30%的数据，满足q<=30，a<=30，n<=1e8\n\n对于50%的数据，满足q<=50，a<=30，n<=1e12\n\n对于100%的数据，满足q<=50000，a<=20000，n<=1e500\n\n样例一解释：\n询问1：lsq必胜，lsq先抽2^1=2，接下来无论wzt抽2^1=2或2^0=1，lsq只要把牌抽完；其他抽法同上（只是顺序不同）\n\n询问2：wzt必胜，若lsq先抽2^0=1，则wzt抽2^3=8；若lsq先抽2^1=2，则wzt抽2^2=4，接下来无论lsq抽2^1=2或2^0=1，wzt只要把牌抽完；其他抽法同上（只是顺序不同）\n\n询问3：lsq必胜，lsq只需拿走3^2=9即可\n\nBy [Broadway](https://www.luogu.org/space/show?uid=33509)", "locale": "zh-CN", "translations": {"en": {"title": "Poker", "background": "lsq invites wzt to his home to play poker.", "description": "lsq’s deck has no Jokers and contains a total of $n$ cards. Since wzt is obsessed with exponentiation, he first proposed drawing $a^2$ cards each time (here “^” denotes exponentiation). lsq found that boring, so they changed the rule to drawing $a^k$ cards each time, where $k$ is a non-negative integer freely chosen by the player on their turn. lsq starts first, and the two players take turns drawing cards according to the rule. Whoever draws the last card wins.\n\nSince they have plenty of time, lsq and wzt will play $q$ games in total, each with different $a$ and $n$. wzt banged out some code and can compute the winning strategy once $a$ and $n$ are fixed. After seeing your “operations,” lsq hopes you can also write a program to determine whether he can win given $a$ and $n$. Since lsq knows how to play optimally, you do not need to output the specific moves.\n\nNote: In this problem, both players always choose a winning move whenever one exists.\n\nHere $k$ is a non-negative integer that the player drawing the cards can decide on each turn. You can refer to the sample below for understanding.", "inputFormat": "The first line contains one integer $q$, indicating there are $q$ games.  \nThe next $q$ lines each contain two integers $a$, $n$, as defined above.", "outputFormat": "Output $q$ lines.  \nIf lsq can win, output \"lsq Win\".  \nIf wzt can win, output \"wzt Win\".", "hint": "Constraints:\n- For 30% of the testdata, $q \\le 30$, $a \\le 30$, $n \\le 10^8$.\n- For 50% of the testdata, $q \\le 50$, $a \\le 30$, $n \\le 10^{12}$.\n- For 100% of the testdata, $q \\le 50000$, $a \\le 20000$, $n \\le 10^{500}$.\n\nExplanation for Sample 1:\n- Query 1: lsq is guaranteed to win. lsq first draws $2^1 = 2$. Afterwards, no matter whether wzt draws $2^1 = 2$ or $2^0 = 1$, lsq can take all the remaining cards. Other draw orders are similar (just a different order).\n- Query 2: wzt is guaranteed to win. If lsq first draws $2^0 = 1$, then wzt draws $2^3 = 8$. If lsq first draws $2^1 = 2$, then wzt draws $2^2 = 4$. Afterwards, no matter whether lsq draws $2^1 = 2$ or $2^0 = 1$, wzt can take all the remaining cards. Other draw orders are similar (just a different order).\n- Query 3: lsq is guaranteed to win; he only needs to take $3^2 = 9$.\n\nBy [Broadway](https://www.luogu.org/space/show?uid=33509)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "扑克", "background": "lsq邀请wzt去他家打扑克牌", "description": "lsq的扑克没有大小王，共计有n张，由于wzt沉迷于幂运算无法自拔，wzt提出要每次抽a^2张牌（这里“^”是乘方的意思），lsq觉得这样抽真没意思，于是改成了每次抽a^k（k是一个自然数，由游戏者自由选择）张牌。**由lsq开始**，每个人轮流按上述规则摸牌，谁先摸到最后一张牌谁就赢。\n\n由于时间充裕，lsq和wzt一共会玩q盘游戏，每一盘都有不同的a和n。wzt怒敲了一波代码，竟然可以算出当确定了a和n的值后，若能必胜如何下。lsq在见识过你的~~毒瘤~~操作后，希望你也帮他写出一个程序，能判断确定了a和n的值后他是否能赢，lsq当然知道怎么下最优，所以不需要你算出如何下 \n\n**注意：此题中两方的打牌决策都是若有必胜决策则必用必胜决策**\n\n此题中k是一个每次抽牌都可由抽牌者自己决定的一个非负整数，可以结合下面的样例加以理解", "inputFormat": "第一行一个数q， 表示有q局游戏\n接下来q行，每行两个整数a,n，意义如上", "outputFormat": "输出共q行\n若lsq能赢，输出“lsq Win”\n若wzt能赢，输出“wzt Win”", "hint": "对于30%的数据，满足q<=30，a<=30，n<=1e8\n\n对于50%的数据，满足q<=50，a<=30，n<=1e12\n\n对于100%的数据，满足q<=50000，a<=20000，n<=1e500\n\n样例一解释：\n询问1：lsq必胜，lsq先抽2^1=2，接下来无论wzt抽2^1=2或2^0=1，lsq只要把牌抽完；其他抽法同上（只是顺序不同）\n\n询问2：wzt必胜，若lsq先抽2^0=1，则wzt抽2^3=8；若lsq先抽2^1=2，则wzt抽2^2=4，接下来无论lsq抽2^1=2或2^0=1，wzt只要把牌抽完；其他抽法同上（只是顺序不同）\n\n询问3：lsq必胜，lsq只需拿走3^2=9即可\n\nBy [Broadway](https://www.luogu.org/space/show?uid=33509)", "locale": "zh-CN"}}}
{"pid": "P4237", "type": "P", "difficulty": 6, "samples": [["4 6 3 2\n16 37 22 24 \n1 4 25\n1 1 23\n4 1 20\n3 1 47\n1 1 18\n3 3 24\n213 1\n174 2\n62 4\n1493 3\n2632 4", "Yes\n3741"], ["4 2 3 2\n16 37 22 24\n1 4 25\n1 3 12\n213 1\n174 3\n62 4\n1493 2\n2632 4", "No\n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["最短路"], "title": "荒芜的海洋", "background": "在一个渺远的海洋中，一场世纪大战级别的游戏上演了。\n\n感谢 [lsq](https://www.luogu.org/space/show?uid=26556) 本人参与验题", "description": "这块海洋上有n个小岛，小岛有m座石桥相连。有一些小岛上有wzt埋下的奖赏，它们非常诱人。它们的诱惑力用整数ki描述。而一些小岛上有lsq的雇佣兵，他们有一个价格，用整数bi描述。lsq必须花钱，他的雇佣兵才会帮他寻找奖赏。 \n\n雇佣兵的价格并不会变。对于每一个雇佣兵，在寻找过程中，他会越过一座座的桥，这过程中，他的价格会 **加上他所经过的所有桥的长度** 。\n\n遗憾的是，不只有桥的阻挡，每座岛上有许多猛兽，虽然雇佣兵们都英勇无比，但驱逐猛兽的过程会让人很不爽。因此，对于每一个雇佣兵，价格会 **加上他所经过的所有岛（包括出发岛）上的猛兽数量之和**。\n\nlsq了解这里的一切情况，他需要做出决策，即决定他的每个雇佣兵应该去找哪个奖赏。lsq的目的是找到所有奖赏，并取得最大收益。每个雇佣兵只能雇佣一次。\n\n收益的定义为： **所有奖赏的诱惑力减去lsq花的所有的钱**\n\nlsq的决策异常艰难，于是只好请 ~~AK过NOI~~ 的你来帮忙。", "inputFormat": "第一行4个数，n（小岛总数）,m（桥总数）,a（lsq的雇佣兵总人数）,b（奖赏总数）\n\n接下来一行n个数，表示每个小岛上的猛兽数量\n\n接下来m行，每行三个数u,v,w，表示u号小岛与v号小岛之间有一座长度为w的桥相连\n\n接下来a行，每行两个数qi,pi，表示i号雇佣兵价格为qi，初始位置为pi号小岛\n\n接下来b行，每行两个数ki,qi，表示i号奖赏的诱惑力为ki，位置为qi号小岛", "outputFormat": "如果能找到所有奖赏，输出“Yes”，并在下一行输出能达到的最大满意度。\n\n如果不能找到所有奖赏，输出“No”，并在下一行输出最多能找到多少奖赏。", "hint": "对于30% 的数据，满足n<=200，m<=200，b<=a<=30\n\n对于50% 的数据，满足n<=500，m<=800，b<=a<=100\n\n对于100% 的数据，满足n<=1000，m<=15000，b<=a<=300，其余数据保证不会爆int(Pascal语言为longint)\n\n![](https://cdn.luogu.com.cn/upload/pic/14497.png)\n![](https://cdn.luogu.com.cn/upload/pic/14498.png)\n\nBy [Ebola](https://www.luogu.org/space/show?uid=20158)", "locale": "zh-CN", "translations": {"en": {"title": "Desolate Ocean", "background": "In a distant ocean, a game at the level of a century-defining war is being played.\n\nThanks to [lsq](https://www.luogu.org/space/show?uid=26556) for participating in problem testing.", "description": "There are $n$ small islands on this ocean, connected by $m$ stone bridges. Some islands have rewards buried by wzt; they are very tempting. Their temptation is described by an integer $k_i$. Some islands have lsq’s mercenaries, each with a price described by an integer $b_i$. lsq must pay money for his mercenaries to help him search for rewards.\n\nA mercenary’s base price does not change. During the search, for each mercenary, as he crosses bridges, his total cost will increase by the sum of the lengths of all bridges he passes. Unfortunately, there are not only bridges blocking the way; each island has many beasts. Although the mercenaries are brave, driving away beasts is unpleasant. Therefore, for each mercenary, his total cost will also increase by the sum of the numbers of beasts on all islands he passes through (including the starting island).\n\nlsq knows everything about the situation and must decide which reward each of his mercenaries should go for. The goal is to find all rewards and achieve maximum profit. Each mercenary can be hired at most once.\n\nProfit is defined as: the sum of the temptation values of all rewards minus all the money lsq spends.\n\nlsq’s decision is extremely difficult, so he asks you for help.", "inputFormat": "The first line contains four integers: $n$ (total number of islands), $m$ (total number of bridges), $a$ (total number of lsq’s mercenaries), $b$ (total number of rewards).\n\nThe next line contains $n$ integers, the number of beasts on each island.\n\nThe next $m$ lines, each with three integers $u, v, w$, indicate that there is a bridge of length $w$ connecting island $u$ and island $v$.\n\nThe next $a$ lines, each with two integers $q_i, p_i$, indicate that the $i$-th mercenary has base price $q_i$ and initial position at island $p_i$.\n\nThe next $b$ lines, each with two integers $k_i, q_i$, indicate that the $i$-th reward has temptation $k_i$ and is located at island $q_i$.", "outputFormat": "If all rewards can be found, output \"Yes\", and on the next line output the maximum profit.\n\nIf not all rewards can be found, output \"No\", and on the next line output the maximum number of rewards that can be found.", "hint": "Constraints:\n- For 30% of the testdata, $n \\le 200$, $m \\le 200$, $b \\le a \\le 30$.\n- For 50% of the testdata, $n \\le 500$, $m \\le 800$, $b \\le a \\le 100$.\n- For 100% of the testdata, $n \\le 1000$, $m \\le 15000$, $b \\le a \\le 300$. The rest of the testdata guarantees no 32-bit signed int overflow (Pascal: longint).\n\n![](https://cdn.luogu.com.cn/upload/pic/14497.png)\n![](https://cdn.luogu.com.cn/upload/pic/14498.png)\n\nBy [Ebola](https://www.luogu.org/space/show?uid=20158).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "荒芜的海洋", "background": "在一个渺远的海洋中，一场世纪大战级别的游戏上演了。\n\n感谢 [lsq](https://www.luogu.org/space/show?uid=26556) 本人参与验题", "description": "这块海洋上有n个小岛，小岛有m座石桥相连。有一些小岛上有wzt埋下的奖赏，它们非常诱人。它们的诱惑力用整数ki描述。而一些小岛上有lsq的雇佣兵，他们有一个价格，用整数bi描述。lsq必须花钱，他的雇佣兵才会帮他寻找奖赏。 \n\n雇佣兵的价格并不会变。对于每一个雇佣兵，在寻找过程中，他会越过一座座的桥，这过程中，他的价格会 **加上他所经过的所有桥的长度** 。\n\n遗憾的是，不只有桥的阻挡，每座岛上有许多猛兽，虽然雇佣兵们都英勇无比，但驱逐猛兽的过程会让人很不爽。因此，对于每一个雇佣兵，价格会 **加上他所经过的所有岛（包括出发岛）上的猛兽数量之和**。\n\nlsq了解这里的一切情况，他需要做出决策，即决定他的每个雇佣兵应该去找哪个奖赏。lsq的目的是找到所有奖赏，并取得最大收益。每个雇佣兵只能雇佣一次。\n\n收益的定义为： **所有奖赏的诱惑力减去lsq花的所有的钱**\n\nlsq的决策异常艰难，于是只好请 ~~AK过NOI~~ 的你来帮忙。", "inputFormat": "第一行4个数，n（小岛总数）,m（桥总数）,a（lsq的雇佣兵总人数）,b（奖赏总数）\n\n接下来一行n个数，表示每个小岛上的猛兽数量\n\n接下来m行，每行三个数u,v,w，表示u号小岛与v号小岛之间有一座长度为w的桥相连\n\n接下来a行，每行两个数qi,pi，表示i号雇佣兵价格为qi，初始位置为pi号小岛\n\n接下来b行，每行两个数ki,qi，表示i号奖赏的诱惑力为ki，位置为qi号小岛", "outputFormat": "如果能找到所有奖赏，输出“Yes”，并在下一行输出能达到的最大满意度。\n\n如果不能找到所有奖赏，输出“No”，并在下一行输出最多能找到多少奖赏。", "hint": "对于30% 的数据，满足n<=200，m<=200，b<=a<=30\n\n对于50% 的数据，满足n<=500，m<=800，b<=a<=100\n\n对于100% 的数据，满足n<=1000，m<=15000，b<=a<=300，其余数据保证不会爆int(Pascal语言为longint)\n\n![](https://cdn.luogu.com.cn/upload/pic/14497.png)\n![](https://cdn.luogu.com.cn/upload/pic/14498.png)\n\nBy [Ebola](https://www.luogu.org/space/show?uid=20158)", "locale": "zh-CN"}}}
{"pid": "P4238", "type": "P", "difficulty": 6, "samples": [["5\n1 6 3 4 9", "1 998244347 33 998244169 1020"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "递推", "倍增", "递归", "逆元", "快速傅里叶变换 FFT", "快速数论变换 NTT", "模板题"], "title": "【模板】多项式乘法逆", "background": "注意：本题并不属于中国计算机学会划定的提高组知识点考察范围。", "description": "给定一个多项式 $F(x)$ ，请求出一个多项式 $G(x)$， 满足 $F(x) * G(x) \\equiv 1 \\pmod{x^n}$。系数对 $998244353$ 取模。\n\n", "inputFormat": "首先输入一个整数 $n$， 表示输入多项式的项数。  \n接着输入 $n$ 个整数，第 $i$ 个整数 $a_i$ 代表 $F(x)$ 次数为 $i-1$ 的项的系数。  ", "outputFormat": "输出 $n$ 个数字，第 $i$ 个整数 $b_i$ 代表 $G(x)$ 次数为 $i-1$ 的项的系数。保证有解。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^5$，$ 0 \\leq a_i \\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "{{[Template] Polynomial Multiplicative Inverse}}", "background": "{{Note: This problem is not within the knowledge points designated by the China Computer Federation (CCF) for the Senior track.}}", "description": "{{Given a polynomial $F(x)$, find a polynomial $G(x)$ such that $F(x) * G(x) \\equiv 1 \\pmod{x^n}$. Coefficients are taken modulo 998244353.}}", "inputFormat": "{{First, input an integer $n$, indicating the number of terms of the input polynomial.  \nThen input $n$ integers; the $i$-th integer $a_i$ denotes the coefficient of the term of $F(x)$ with degree $i-1$.}}", "outputFormat": "{{Output $n$ integers; the $i$-th integer $b_i$ denotes the coefficient of the term of $G(x)$ with degree $i-1$. It is guaranteed that a solution exists.}}", "hint": "{{For $100\\%$ of the testdata, $1 \\leq n \\leq 10^5$, $0 \\leq a_i \\leq 10^9$.}}\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】多项式乘法逆", "background": "注意：本题并不属于中国计算机学会划定的提高组知识点考察范围。", "description": "给定一个多项式 $F(x)$ ，请求出一个多项式 $G(x)$， 满足 $F(x) * G(x) \\equiv 1 \\pmod{x^n}$。系数对 $998244353$ 取模。\n\n", "inputFormat": "首先输入一个整数 $n$， 表示输入多项式的项数。  \n接着输入 $n$ 个整数，第 $i$ 个整数 $a_i$ 代表 $F(x)$ 次数为 $i-1$ 的项的系数。  ", "outputFormat": "输出 $n$ 个数字，第 $i$ 个整数 $b_i$ 代表 $G(x)$ 次数为 $i-1$ 的项的系数。保证有解。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^5$，$ 0 \\leq a_i \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4239", "type": "P", "difficulty": 6, "samples": [["5\n1 6 3 4 9", "1 1000000001 33 999999823 1020"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "快速傅里叶变换 FFT", "模板题"], "title": "【模板】任意模数多项式乘法逆", "background": null, "description": "给定一个多项式 $F(x)$ ，请求出一个多项式 $G(x)$ ， 满足 $F(x) * G(x) \\equiv 1 ( \\mathrm{mod\\:} x^n )$\n 。系数对 $10^9+7$ 取模。", "inputFormat": "首先输入一个整数 $n$， 表示输入 $F(x)$ 为 $n-1$ 次。   \n接着输入 $n$ 个整数，第 $i$ 个整数 $a_i$ 代表 $F(x)$ 次数为 $i-1$ 项的系数。", "outputFormat": "输出 $n$ 个数字，第 $i$ 个整数 $b_i$ 代表 $G(x)$ 次数为 $i-1$ 的项的系数。", "hint": "$1 \\leq n \\leq 10^5$，$0 \\leq a_i \\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "【Template】Polynomial Multiplicative Inverse for Arbitrary Modulus", "background": "", "description": "Given a polynomial $F(x)$, find a polynomial $G(x)$ such that $F(x) * G(x) \\equiv 1 ( \\mathrm{mod\\:} x^n )$. Coefficients are taken modulo $10^9+7$.", "inputFormat": "First input an integer $n$, indicating that $F(x)$ has degree $n-1$. Then input $n$ integers; the $i$-th integer $a_i$ denotes the coefficient of the term of $F(x)$ with degree $i-1$.", "outputFormat": "Output $n$ integers; the $i$-th integer $b_i$ denotes the coefficient of the term of $G(x)$ with degree $i-1$.", "hint": "$1 \\leq n \\leq 10^5$, $0 \\leq a_i \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】任意模数多项式乘法逆", "background": null, "description": "给定一个多项式 $F(x)$ ，请求出一个多项式 $G(x)$ ， 满足 $F(x) * G(x) \\equiv 1 ( \\mathrm{mod\\:} x^n )$\n 。系数对 $10^9+7$ 取模。", "inputFormat": "首先输入一个整数 $n$， 表示输入 $F(x)$ 为 $n-1$ 次。   \n接着输入 $n$ 个整数，第 $i$ 个整数 $a_i$ 代表 $F(x)$ 次数为 $i-1$ 项的系数。", "outputFormat": "输出 $n$ 个数字，第 $i$ 个整数 $b_i$ 代表 $G(x)$ 次数为 $i-1$ 的项的系数。", "hint": "$1 \\leq n \\leq 10^5$，$0 \\leq a_i \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P4240", "type": "P", "difficulty": 7, "samples": [["3\n1 1\n2 2\n3 3", "1\n5\n19"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "莫队", "数论", "莫比乌斯反演", "前缀和", "根号分治", "整除分块", "欧拉函数"], "title": "毒瘤之神的考验", "background": "Salamander 的家门口是一条长长的公路。\n\n\n又是一年春天将至，Salamander 发现路边长出了一排毒瘤！\n\nSalamander 想带一些毒瘤回家，但是，这时毒瘤当中钻出来了一个毒瘤之神！\n\n毒瘤之神：你想要带毒瘤走吗？想要带走毒瘤，就必须回答我的问题！如果答不出来的话，你还是乖乖回家吧！", "description": "毒瘤之神会问 $T$ 次，每次给定 $n, m$，Salamander 需要回答出 $\\left( \\sum_{i=1}^n \\sum_{j=1}^m \\varphi(ij) \\right)\\! \\bmod 998244353$。\n\nSalamander 这么辣鸡当然不会做啦，于是把问题丢给了你。", "inputFormat": "第一行包含一个正整数 $T$。\n\n接下来 $T$ 行，每行包含两个正整数，用空格隔开，表示这次询问的 $n, m$。", "outputFormat": "包含 $T$ 行，每行一个整数表示答案。", "hint": "对于 $40\\%$ 的数据，$T=1$，$n, m \\le {10}^5$。  \n对于 $50\\%$ 的数据，$T \\le {10}^3$，$n, m \\le {10}^5$。  \n对于另外 $10\\%$ 的数据，$T \\le {10}^4$，$n = m \\le {10}^5$。  \n对于 $100\\%$ 的数据，$1 \\le T \\le {10}^4$，$1 \\le n, m \\le {10}^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Trial of the God of \"Duliu\"", "background": "At Salamander's doorstep lies a long road.\n\nAs spring approaches again, Salamander discovers a row of \"duliu\" growing by the roadside!\n\nSalamander wants to take some \"duliu\" home, but then a God of \"Duliu\" pops out from among them!\n\nGod of \"Duliu\": Do you want to take the \"duliu\"? If you want to take them, you must answer my question! If you can't answer it, you'd better go home!", "description": "The God of \"Duliu\" will ask $T$ times. Each time, given $n, m$, Salamander must answer $\\left( \\sum_{i=1}^n \\sum_{j=1}^m \\varphi(ij) \\right)\\! \\bmod 998244353$.\n\nSalamander cannot solve it, so he passes the problem to you.", "inputFormat": "The first line contains a positive integer $T$.\n\nThen follow $T$ lines; each line contains two positive integers separated by a space, representing this query's $n, m$.", "outputFormat": "Output $T$ lines, each containing one integer representing the answer.", "hint": "For $40\\%$ of the testdata, $T = 1$, $n, m \\le 10^5$.  \nFor $50\\%$ of the testdata, $T \\le 10^3$, $n, m \\le 10^5$.  \nFor another $10\\%$ of the testdata, $T \\le 10^4$, $n = m \\le 10^5$.  \nFor $100\\%$ of the testdata, $1 \\le T \\le 10^4$, $1 \\le n, m \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "毒瘤之神的考验", "background": "Salamander 的家门口是一条长长的公路。\n\n\n又是一年春天将至，Salamander 发现路边长出了一排毒瘤！\n\nSalamander 想带一些毒瘤回家，但是，这时毒瘤当中钻出来了一个毒瘤之神！\n\n毒瘤之神：你想要带毒瘤走吗？想要带走毒瘤，就必须回答我的问题！如果答不出来的话，你还是乖乖回家吧！", "description": "毒瘤之神会问 $T$ 次，每次给定 $n, m$，Salamander 需要回答出 $\\left( \\sum_{i=1}^n \\sum_{j=1}^m \\varphi(ij) \\right)\\! \\bmod 998244353$。\n\nSalamander 这么辣鸡当然不会做啦，于是把问题丢给了你。", "inputFormat": "第一行包含一个正整数 $T$。\n\n接下来 $T$ 行，每行包含两个正整数，用空格隔开，表示这次询问的 $n, m$。", "outputFormat": "包含 $T$ 行，每行一个整数表示答案。", "hint": "对于 $40\\%$ 的数据，$T=1$，$n, m \\le {10}^5$。  \n对于 $50\\%$ 的数据，$T \\le {10}^3$，$n, m \\le {10}^5$。  \n对于另外 $10\\%$ 的数据，$T \\le {10}^4$，$n = m \\le {10}^5$。  \n对于 $100\\%$ 的数据，$1 \\le T \\le {10}^4$，$1 \\le n, m \\le {10}^5$。", "locale": "zh-CN"}}}
{"pid": "P4241", "type": "P", "difficulty": 6, "samples": [["2 5\n2 3\n3 1", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["枚举", "背包 DP"], "title": "采摘毒瘤", "background": "Salamander见到路边有如此多的毒瘤，于是见猎心喜，从家里拿来了一个大袋子，准备将一些毒瘤带回家。\n", "description": "路边共有$n$种不同的毒瘤，第$i$种毒瘤有$k_i$个，每个需要占据$d_i$的空间。Salamander的袋子能装下的最大体积为$m$。\n\n\nSalamander是一个很贪心的人，不过他也**不要求**带尽可能多或是总体积尽可能大的毒瘤回家，他只要求袋子里**再也装不下剩余的任何一种毒瘤**。\n\n\nSalamander想知道有多少种不同的装毒瘤的方案。两种方案不同当且仅当取的毒瘤种类不同或者至少有一种毒瘤取的数量不同。由于方案数可能太多，请输出答案对$19260817$取模后的结果。\n", "inputFormat": "第一行包括两个正整数$n$、$m$，表示毒瘤的种类数和袋子的大小。\n\n接下来的$n$行，每行两个正整数$k_i$、$d_i$，表示一种毒瘤。\n", "outputFormat": "一行，表示不同的方案数对$19260817$取模后的结果。\n", "hint": "###样例解释：\n\n两种方案如下：\n\n1.取1个第一种毒瘤和2个第二种毒瘤。\n\n2.取3个第二种毒瘤。\n\n\n$~$\n$~$\n\n对于10%的数据，$1\\leq n,k_i,d_i\\leq 10$，$1\\leq m\\leq 100$；\n\n对于30%的数据，$1\\leq n,k_i,d_i\\leq 50$，$1\\leq m\\leq 5000$；\n\n对于另外20%的数据，$k_i=1$；\n\n对于100%的数据，$1\\leq n,k_i,d_i\\leq 500$，$1\\leq m\\leq 10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Picking Tumors", "background": "Salamander saw so many tumors by the roadside that he got excited. He brought a big bag from home, planning to take some tumors back.", "description": "There are $n$ different types of tumors by the roadside. For type $i$, there are $k_i$ items available, and each item occupies $d_i$ units of space. Salamander’s bag has a maximum total volume capacity of $m$.\n\nSalamander is very greedy, but he does not require taking as many items as possible or achieving the largest possible total volume. He only requires that the bag can no longer fit any tumor of any remaining type.\n\nFormally, choose integers $x_i$ with $0 \\le x_i \\le k_i$ for each $i$, such that $\\sum_i x_i d_i \\le m$, and if $x_i < k_i$ then the remaining capacity $m - \\sum_i x_i d_i < d_i$ for every such $i$.\n\nSalamander wants to know how many different packing schemes there are. Two schemes are different if and only if the set of types taken is different, or there exists at least one type for which the taken quantity is different. Since the number of schemes can be large, output the answer modulo $19260817$.", "inputFormat": "The first line contains two positive integers $n$ and $m$, the number of tumor types and the bag’s capacity.\n\nEach of the next $n$ lines contains two positive integers $k_i$ and $d_i$, describing one type of tumor.", "outputFormat": "Output a single line with the number of different schemes, modulo $19260817$.", "hint": "Sample explanation:\n\nThe two schemes are as follows:\n1. Take 1 item of type 1 and 2 items of type 2.\n2. Take 3 items of type 2.\n\n$~$\n$~$\n\nConstraints\n\n- For 10% of the testdata, $1 \\le n, k_i, d_i \\le 10$, $1 \\le m \\le 100$;\n- For 30% of the testdata, $1 \\le n, k_i, d_i \\le 50$, $1 \\le m \\le 5000$;\n- For another 20% of the testdata, $k_i = 1$;\n- For 100% of the testdata, $1 \\le n, k_i, d_i \\le 500$, $1 \\le m \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "采摘毒瘤", "background": "Salamander见到路边有如此多的毒瘤，于是见猎心喜，从家里拿来了一个大袋子，准备将一些毒瘤带回家。\n", "description": "路边共有$n$种不同的毒瘤，第$i$种毒瘤有$k_i$个，每个需要占据$d_i$的空间。Salamander的袋子能装下的最大体积为$m$。\n\n\nSalamander是一个很贪心的人，不过他也**不要求**带尽可能多或是总体积尽可能大的毒瘤回家，他只要求袋子里**再也装不下剩余的任何一种毒瘤**。\n\n\nSalamander想知道有多少种不同的装毒瘤的方案。两种方案不同当且仅当取的毒瘤种类不同或者至少有一种毒瘤取的数量不同。由于方案数可能太多，请输出答案对$19260817$取模后的结果。\n", "inputFormat": "第一行包括两个正整数$n$、$m$，表示毒瘤的种类数和袋子的大小。\n\n接下来的$n$行，每行两个正整数$k_i$、$d_i$，表示一种毒瘤。\n", "outputFormat": "一行，表示不同的方案数对$19260817$取模后的结果。\n", "hint": "###样例解释：\n\n两种方案如下：\n\n1.取1个第一种毒瘤和2个第二种毒瘤。\n\n2.取3个第二种毒瘤。\n\n\n$~$\n$~$\n\n对于10%的数据，$1\\leq n,k_i,d_i\\leq 10$，$1\\leq m\\leq 100$；\n\n对于30%的数据，$1\\leq n,k_i,d_i\\leq 50$，$1\\leq m\\leq 5000$；\n\n对于另外20%的数据，$k_i=1$；\n\n对于100%的数据，$1\\leq n,k_i,d_i\\leq 500$，$1\\leq m\\leq 10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P4242", "type": "P", "difficulty": 7, "samples": [["10 10\n708916891 100649777 100649777 544409200 100649777 47435517 47435517 708916891 644811607 544409200 \n3 2\n7 1\n8 1\n1 10\n3 4\n1 5\n9 2\n1 2\n3 6\n2 1\n6 \n2 6\n8 10 9 3 2 4 \n2 2\n7 8 \n2 1\n5 \n2 2\n6 10 \n2 3\n6 1 4 \n2 1\n7 \n1 9 8 100649777\n1 7 9 544409200\n2 4\n10 9 1 2 ", "1 \n13 17 15 11 11 15 \n3 3 \n1 \n5 5 \n7 7 7 \n1 \n4 4 4 4 "]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["分治", "虚树"], "title": "树上的毒瘤", "background": "Salamander 开心地把一大袋毒瘤带回了家，把他们染上了不同的颜色，并把他们挂在了院子里的树上。", "description": "这棵树上有 $n$ 个节点，由 $n-1$ 条树枝相连。初始时树上都挂了一个毒瘤，颜色为 $c_i$。接下来 Salamander 将会进行 $q$ 个操作。\n\nSalamander 有时会修改树上某个点到另外一个点的简单路径上所有毒瘤的颜色。\n\n对于给定的树上**某个点集 $\\bm{S}$**，Salamander 还定义了某个点的权值：\n\n$$W_i=\\sum_{j\\in S}T(i,j)$$\n\n其中 $T(i,j)$ 表示 $i$ 到 $j$ 的路径上毒瘤颜色的**段数**，比如 $i$ 到 $j$ 的路径上毒瘤颜色为 $1223312$ 时，颜色段数为 $5$。\n\nSalamander 对树上的毒瘤们的状态很感兴趣，所以有时会指定树上 $m$ 个节点作为点集，询问这 $m$ 个节点的权值。", "inputFormat": "第一行包括两个正整数 $n$、$q$，表示树上的节点数和操作个数。\n\n第二行包括用空格隔开的 $n$ 个正整数 $c_i$，表示树上每个节点初始的毒瘤颜色。\n\n接下来 $n-1$ 行，每行两个正整数 $u$、$v$，表示树上有一条连接 $u$ 和 $v$ 的边。\n\n接下来描述 $q$ 个操作：\n\n1. 若给出的第一个整数等于 $1$，那么接下来将会有三个正整数 $u$、$v$、$y$，表示将树上编号为 $u$ 的点到编号为 $v$ 的点的简单路径上的毒瘤颜色全都改为 $y$。\n\n2. 若给出的第一个整数等于 $2$，那么接下来将会有一个正整数 $m$，表示指定的树上节点个数。下一行将会有 $m$ 个用空格隔开的互不相同的正整数，表示当前询问给定的 $m$ 个节点。", "outputFormat": "若干行，对于每个 $2$ 操作输出对应的答案。", "hint": "保证输入数据合法。\n\n对于 $30\\%$ 的数据，有 $1\\leq n,q\\leq 1000$，$\\sum m\\leq 5000$。\n\n对于 $60\\%$ 的数据，有 $1\\leq n,q\\leq 20000$，$\\sum m\\leq 100000$。\n\n对于 $100\\%$ 的数据，有 $1\\leq n,q\\leq 100000$，$c_i,y\\leq 10^9$，$\\sum m\\leq 200000$，$m\\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "Tumors on the Tree", "background": "Salamander happily brought home a big bag of “tumors”, dyed them in different colors, and hung them on the tree in the yard.", "description": "The tree has $n$ nodes connected by $n-1$ edges. Initially, there is one “tumor” hanging on each node, with color $c_i$. Then Salamander will perform $q$ operations.\n\nSometimes Salamander will change the colors of all “tumors” on the simple path from one node to another.\n\nFor a given set of nodes on the tree, namely the point set $\\bm{S}$, Salamander defines the weight of a node:\n$$W_i=\\sum_{j\\in S}T(i,j)$$\nwhere $T(i,j)$ denotes the number of color segments along the path from $i$ to $j$. For example, if the colors along the path from $i$ to $j$ are $1223312$, the number of segments is $5$.\n\nSalamander is very interested in the state of the “tumors” on the tree, so sometimes he will specify $m$ nodes as the set and ask for the weights of these $m$ nodes.", "inputFormat": "The first line contains two positive integers $n$, $q$, the number of nodes in the tree and the number of operations.\n\nThe second line contains $n$ space-separated positive integers $c_i$, the initial color of the “tumor” on each node.\n\nThe next $n-1$ lines each contain two positive integers $u$, $v$, indicating there is an edge connecting $u$ and $v$.\n\nThen follow $q$ operations:\n\n1. If the first integer is $1$, then there will be three positive integers $u$, $v$, $y$, meaning that all “tumor” colors on the simple path from node $u$ to node $v$ are changed to $y$.\n2. If the first integer is $2$, then there will be one positive integer $m$, the number of specified nodes on the tree. The next line contains $m$ distinct positive integers separated by spaces, representing the $m$ nodes in the current query.", "outputFormat": "Output several lines. For each operation of type $2$, output the corresponding answer.", "hint": "The input is guaranteed to be valid.\n\nFor $30\\%$ of the testdata, $1 \\leq n, q \\leq 1000$, $\\sum m \\leq 5000$.\n\nFor $60\\%$ of the testdata, $1 \\leq n, q \\leq 20000$, $\\sum m \\leq 100000$.\n\nFor $100\\%$ of the testdata, $1 \\leq n, q \\leq 100000$, $c_i, y \\leq 10^9$, $\\sum m \\leq 200000$, $m \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "树上的毒瘤", "background": "Salamander 开心地把一大袋毒瘤带回了家，把他们染上了不同的颜色，并把他们挂在了院子里的树上。", "description": "这棵树上有 $n$ 个节点，由 $n-1$ 条树枝相连。初始时树上都挂了一个毒瘤，颜色为 $c_i$。接下来 Salamander 将会进行 $q$ 个操作。\n\nSalamander 有时会修改树上某个点到另外一个点的简单路径上所有毒瘤的颜色。\n\n对于给定的树上**某个点集 $\\bm{S}$**，Salamander 还定义了某个点的权值：\n\n$$W_i=\\sum_{j\\in S}T(i,j)$$\n\n其中 $T(i,j)$ 表示 $i$ 到 $j$ 的路径上毒瘤颜色的**段数**，比如 $i$ 到 $j$ 的路径上毒瘤颜色为 $1223312$ 时，颜色段数为 $5$。\n\nSalamander 对树上的毒瘤们的状态很感兴趣，所以有时会指定树上 $m$ 个节点作为点集，询问这 $m$ 个节点的权值。", "inputFormat": "第一行包括两个正整数 $n$、$q$，表示树上的节点数和操作个数。\n\n第二行包括用空格隔开的 $n$ 个正整数 $c_i$，表示树上每个节点初始的毒瘤颜色。\n\n接下来 $n-1$ 行，每行两个正整数 $u$、$v$，表示树上有一条连接 $u$ 和 $v$ 的边。\n\n接下来描述 $q$ 个操作：\n\n1. 若给出的第一个整数等于 $1$，那么接下来将会有三个正整数 $u$、$v$、$y$，表示将树上编号为 $u$ 的点到编号为 $v$ 的点的简单路径上的毒瘤颜色全都改为 $y$。\n\n2. 若给出的第一个整数等于 $2$，那么接下来将会有一个正整数 $m$，表示指定的树上节点个数。下一行将会有 $m$ 个用空格隔开的互不相同的正整数，表示当前询问给定的 $m$ 个节点。", "outputFormat": "若干行，对于每个 $2$ 操作输出对应的答案。", "hint": "保证输入数据合法。\n\n对于 $30\\%$ 的数据，有 $1\\leq n,q\\leq 1000$，$\\sum m\\leq 5000$。\n\n对于 $60\\%$ 的数据，有 $1\\leq n,q\\leq 20000$，$\\sum m\\leq 100000$。\n\n对于 $100\\%$ 的数据，有 $1\\leq n,q\\leq 100000$，$c_i,y\\leq 10^9$，$\\sum m\\leq 200000$，$m\\leq n$。", "locale": "zh-CN"}}}
{"pid": "P4243", "type": "P", "difficulty": 6, "samples": [["5\n1\n3\n-1\n-4\n7\n2\nA 2 4 -1 5\nB 1 5", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2009", "线段树", "各省省选", "江苏", "差分"], "title": "[JSOI2009] 等差数列", "background": "“一个长度为$l$的数列$a_i$，若相邻两数间的差$a_i - a_{i-1} \\ (2 \\leq i \\leq l)$全部相同，则这个数列为等差数列。”火星特级数学老师jyy，正在给他的火星学生们上数学课。", "description": "为了检验学生的掌握情况，jyy布置了一道习题：给定一个长度为$N$（$1 \\leq N \\leq 100,000$）的数列，初始时第$i$个数为$v_i$（$v_i$是整数，$-100,000 \\leq v_i \\leq 100,000$），学生们要按照jyy的给出的操作步骤来改变数列中的某些项的值。操作步骤的具体形式为：`A s t a b` （$s, t, a, b$均为整数，$1 \\leq s \\leq t \\leq N$，$-100,000 \\leq a, b \\leq 100,000$），它表示，在序列的$[s, t]$区间上加上初值为$a$，步长为$b$的等差数列。即$v_i$变为$v_i + a + b \\times (i - s)$（对于$s \\leq i \\leq t$）。\n\n在焦头烂额地计算之余，可怜的火星学生们还得随时回答jyy提出的问题。问题形式为：`B s t`（$s, t$均为整数，$1 \\leq s \\leq t \\leq N$），表示jyy询问当前序列的$[s, t]$区间最少能划分成几段，使得每一段都是等差数列。比如说`1 2 3 5 7`最少能划分成$2$段，一段是`1 2 3`，另一段是`5 7`。询问是需要同学们计算出答案后，作为作业交上来的。\n\n虽然操作数加问题数总共只有$Q$（$1 \\leq Q \\leq 100,000$）个，jyy还是觉得这个题很无聊很麻烦。于是他想让你帮他算一份标准答案。", "inputFormat": "第$1$行：$1$个整数$N$，第$2 \\cdots N + 1$行：每行一个整数。第$i + 1$行表示$v_i$。\n\n第$N + 2$行：$1$个整数$Q$，第$N + 3 \\cdots N + Q + 2$行：每行描述了一个操作或问题，格式如题中所述，不含引号。", "outputFormat": "若干行，每行一个整数，表示对一个问题的回答。请按照输入中的顺序依次给出回答。", "hint": "**样例说明：**\n\n原数列`1 3 -1 -4 7`。经过操作之后，数列变为`1 2 3 5 7`。如题中所述，最少能划分成$2$段。\n\n**数据规模：**\n\n对$30\\%$的数据，$N, Q \\leq 5000$。\n\n对$100\\%$的数据，$1 \\leq N, Q \\leq 100,000$。\n\n其他数据范围见题面。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2009] Arithmetic Progression", "background": "\"Given a sequence $a_i$ of length $l$, if the differences between adjacent numbers $a_i - a_{i-1}$ ($2 \\leq i \\leq l$) are all the same, then the sequence is an arithmetic progression.\" jyy, a top-level Martian math teacher, is teaching his Martian students.", "description": "To check how well the students have learned, jyy assigns an exercise: given a sequence of length $N$ ($1 \\leq N \\leq 100,000$), where initially the $i$-th number is $v_i$ ($v_i$ is an integer, $-100,000 \\leq v_i \\leq 100,000$), the students must modify some elements according to jyy’s operations. An operation has the form: `A s t a b` ($s, t, a, b$ are all integers, $1 \\leq s \\leq t \\leq N$, $-100,000 \\leq a, b \\leq 100,000$). It means: over the interval $[s, t]$, add an arithmetic progression with initial term $a$ and common difference $b$. That is, $v_i$ becomes $v_i + a + b \\times (i - s)$ (for $s \\leq i \\leq t$).\n\nAmid their hectic calculations, the poor Martian students must also answer jyy’s questions at any time. A query has the form: `B s t` ($s, t$ are integers, $1 \\leq s \\leq t \\leq N$), which asks for the minimum number of segments into which the current interval $[s, t]$ can be partitioned so that each segment is an arithmetic progression. For example, `1 2 3 5 7` can be partitioned into $2$ segments: `1 2 3` and `5 7`. The answers to the queries must be computed and handed in as homework.\n\nAlthough the total number of operations plus queries is only $Q$ ($1 \\leq Q \\leq 100,000$), jyy still finds this problem boring and troublesome. So he wants you to compute a standard answer for him.", "inputFormat": "Line $1$: one integer $N$. Lines $2 \\cdots N + 1$: each line contains one integer. Line $i + 1$ gives $v_i$.\n\nLine $N + 2$: one integer $Q$. Lines $N + 3 \\cdots N + Q + 2$: each line describes an operation or a query, in the format described above, without quotes.", "outputFormat": "Several lines, each containing one integer, representing the answer to a query. Output the answers in the same order as the queries appear in the input.", "hint": "Sample explanation:\n\nThe original sequence is `1 3 -1 -4 7`. After the operation, the sequence becomes `1 2 3 5 7`. As described above, the minimum number of segments is $2$.\n\nConstraints:\n\n- For $30\\%$ of the testdata, $N, Q \\leq 5000$.\n- For $100\\%$ of the testdata, $1 \\leq N, Q \\leq 100,000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2009] 等差数列", "background": "“一个长度为$l$的数列$a_i$，若相邻两数间的差$a_i - a_{i-1} \\ (2 \\leq i \\leq l)$全部相同，则这个数列为等差数列。”火星特级数学老师jyy，正在给他的火星学生们上数学课。", "description": "为了检验学生的掌握情况，jyy布置了一道习题：给定一个长度为$N$（$1 \\leq N \\leq 100,000$）的数列，初始时第$i$个数为$v_i$（$v_i$是整数，$-100,000 \\leq v_i \\leq 100,000$），学生们要按照jyy的给出的操作步骤来改变数列中的某些项的值。操作步骤的具体形式为：`A s t a b` （$s, t, a, b$均为整数，$1 \\leq s \\leq t \\leq N$，$-100,000 \\leq a, b \\leq 100,000$），它表示，在序列的$[s, t]$区间上加上初值为$a$，步长为$b$的等差数列。即$v_i$变为$v_i + a + b \\times (i - s)$（对于$s \\leq i \\leq t$）。\n\n在焦头烂额地计算之余，可怜的火星学生们还得随时回答jyy提出的问题。问题形式为：`B s t`（$s, t$均为整数，$1 \\leq s \\leq t \\leq N$），表示jyy询问当前序列的$[s, t]$区间最少能划分成几段，使得每一段都是等差数列。比如说`1 2 3 5 7`最少能划分成$2$段，一段是`1 2 3`，另一段是`5 7`。询问是需要同学们计算出答案后，作为作业交上来的。\n\n虽然操作数加问题数总共只有$Q$（$1 \\leq Q \\leq 100,000$）个，jyy还是觉得这个题很无聊很麻烦。于是他想让你帮他算一份标准答案。", "inputFormat": "第$1$行：$1$个整数$N$，第$2 \\cdots N + 1$行：每行一个整数。第$i + 1$行表示$v_i$。\n\n第$N + 2$行：$1$个整数$Q$，第$N + 3 \\cdots N + Q + 2$行：每行描述了一个操作或问题，格式如题中所述，不含引号。", "outputFormat": "若干行，每行一个整数，表示对一个问题的回答。请按照输入中的顺序依次给出回答。", "hint": "**样例说明：**\n\n原数列`1 3 -1 -4 7`。经过操作之后，数列变为`1 2 3 5 7`。如题中所述，最少能划分成$2$段。\n\n**数据规模：**\n\n对$30\\%$的数据，$N, Q \\leq 5000$。\n\n对$100\\%$的数据，$1 \\leq N, Q \\leq 100,000$。\n\n其他数据范围见题面。", "locale": "zh-CN"}}}
{"pid": "P4244", "type": "P", "difficulty": 6, "samples": [["15 3\n9 1 2 3 4 5 6 7 8 3\n7 2 9 10 11 12 13 10\n5 2 14 9 15 10", "8"], ["10 1\n10 1 2 3 4 5 6 7 8 9 10", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "各省省选", "单调队列", "上海", "深度优先搜索 DFS", "仙人掌"], "title": "[SHOI2008] 仙人掌图 II", "background": "题目这个II是和[SHOI2006的仙人掌图](https://www.luogu.org/problemnew/show/P4129)区分的，bzoj没有。\n**但是实际上还是和bzoj1023是一个题目的**。", "description": "如果某个无向连通图的任意一条边至多只出现在一条简单回路（simple cycle）里，我们就称这张图为仙人掌图（cactus）。所谓简单回路就是指在图上不重复经过任何一个顶点的回路。\n\n![](https://cdn.luogu.com.cn/upload/pic/13241.png)\n\n举例来说，上面的第一个例子是一张仙人图，而第二个不是——注意到它有三条简单回路：（4，3，2，1，6，5，4）、（7，8，9，10，2，3，7）以及（4，3，7，8，9，10，2，1，6，5，4），而（2，3）同时出现在前两个的简单回路里。另外，第三张图也不是仙人图，因为它并不是连通图。显然，仙人图上的每条边，或者是这张仙人图的桥（bridge），或者在且仅在一个简单回路里，两者必居其一。定义在图上两点之间的距离为这两点之间最短路径的距离。定义一个图的直径为这张图相距最远的两个点的距离。**现在我们假定仙人图的每条边的权值都是1，你的任务是求出给定的仙人图的直径**。", "inputFormat": "输入的第一行包括两个整数n和m（1≤n≤50000以及0≤m≤10000）。其中n代表顶点个数，我们约定图中的顶点将从1到n编号。接下来一共有m行。代表m条路径。每行的开始有一个整数k（2≤k≤1000），代表在这条路径上的顶点个数。接下来是k个1到n之间的整数，分别对应了一个顶点，相邻的顶点表示存在一条连接这两个顶点的边。一条路径上可能通过一个顶点好几次，比如对于第一个样例，第一条路径从3经过8，又从8返回到了3，但是我们保证所有的边都会出现在某条路径上，而且不会重复出现在两条路径上，或者在一条路径上出现两次。", "outputFormat": "只需输出一个数，这个数表示仙人图的直径长度。", "hint": "\n对第一个样例的说明：6号点和12号点的最短路径长度为8，所以这张图的直径为8。\n\n【注意】使用Pascal语言的选手请注意：你的程序在处理大数据的时候可能会出现栈溢出。\n如果需要调整栈空间的大小，可以在程序的开头填加一句：{\\$M 5000000}，其中5000000即指代栈空间的大小，请根据自己的程序选择适当的数值。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2008] Cactus Graph II", "background": "The “II” in the title distinguishes this problem from [SHOI2006 Cactus Graph](https://www.luogu.org/problemnew/show/P4129), which is not on BZOJ. \nHowever, it is actually the same problem as bzoj1023.", "description": "If, in an undirected connected graph, every edge appears in at most one simple cycle, we call the graph a cactus graph (cactus). A simple cycle is a cycle that does not visit any vertex more than once.\n\n![](https://cdn.luogu.com.cn/upload/pic/13241.png)\n\nFor example, the first figure above is a cactus graph, while the second is not—note that it has three simple cycles: (4, 3, 2, 1, 6, 5, 4), (7, 8, 9, 10, 2, 3, 7), and (4, 3, 7, 8, 9, 10, 2, 1, 6, 5, 4), and the edge (2, 3) appears in the first two simple cycles at the same time. In addition, the third figure is not a cactus graph either because it is not connected. Clearly, every edge in a cactus graph is either a bridge or lies in exactly one simple cycle; exactly one of these holds.\n\nDefine the distance between two vertices in the graph as the length of the shortest path between them. Define the diameter of a graph as the distance between the two vertices that are farthest apart. We assume every edge in the cactus graph has weight 1. Your task is to compute the diameter of the given cactus graph.", "inputFormat": "The first line contains two integers $n$ and $m$ ($1 \\le n \\le 50000$, $0 \\le m \\le 10000$). Here $n$ is the number of vertices, labeled from 1 to $n$.\n\nThe next $m$ lines each describe one path. Each such line starts with an integer $k$ ($2 \\le k \\le 1000$), the number of vertices on this path, followed by $k$ integers between 1 and $n$, each denoting a vertex. Adjacent vertices on the line indicate an edge between them. A path may pass through a vertex multiple times; for example, in the first sample, the first path goes from 3 to 8, then returns from 8 to 3. We guarantee that every edge appears in some path, and no edge appears in two different paths or appears twice within the same path.", "outputFormat": "Output a single integer: the diameter of the cactus graph.", "hint": "Explanation for the first sample: the shortest path length between vertex 6 and vertex 12 is 8, so the diameter is 8.\n\nNote for Pascal users: your program may encounter stack overflow on large testdata. If you need to adjust the stack size, you can add the following at the beginning of your program: {\\$M 5000000}, where 5000000 specifies the stack size. Please choose an appropriate value for your program.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2008] 仙人掌图 II", "background": "题目这个II是和[SHOI2006的仙人掌图](https://www.luogu.org/problemnew/show/P4129)区分的，bzoj没有。\n**但是实际上还是和bzoj1023是一个题目的**。", "description": "如果某个无向连通图的任意一条边至多只出现在一条简单回路（simple cycle）里，我们就称这张图为仙人掌图（cactus）。所谓简单回路就是指在图上不重复经过任何一个顶点的回路。\n\n![](https://cdn.luogu.com.cn/upload/pic/13241.png)\n\n举例来说，上面的第一个例子是一张仙人图，而第二个不是——注意到它有三条简单回路：（4，3，2，1，6，5，4）、（7，8，9，10，2，3，7）以及（4，3，7，8，9，10，2，1，6，5，4），而（2，3）同时出现在前两个的简单回路里。另外，第三张图也不是仙人图，因为它并不是连通图。显然，仙人图上的每条边，或者是这张仙人图的桥（bridge），或者在且仅在一个简单回路里，两者必居其一。定义在图上两点之间的距离为这两点之间最短路径的距离。定义一个图的直径为这张图相距最远的两个点的距离。**现在我们假定仙人图的每条边的权值都是1，你的任务是求出给定的仙人图的直径**。", "inputFormat": "输入的第一行包括两个整数n和m（1≤n≤50000以及0≤m≤10000）。其中n代表顶点个数，我们约定图中的顶点将从1到n编号。接下来一共有m行。代表m条路径。每行的开始有一个整数k（2≤k≤1000），代表在这条路径上的顶点个数。接下来是k个1到n之间的整数，分别对应了一个顶点，相邻的顶点表示存在一条连接这两个顶点的边。一条路径上可能通过一个顶点好几次，比如对于第一个样例，第一条路径从3经过8，又从8返回到了3，但是我们保证所有的边都会出现在某条路径上，而且不会重复出现在两条路径上，或者在一条路径上出现两次。", "outputFormat": "只需输出一个数，这个数表示仙人图的直径长度。", "hint": "\n对第一个样例的说明：6号点和12号点的最短路径长度为8，所以这张图的直径为8。\n\n【注意】使用Pascal语言的选手请注意：你的程序在处理大数据的时候可能会出现栈溢出。\n如果需要调整栈空间的大小，可以在程序的开头填加一句：{\\$M 5000000}，其中5000000即指代栈空间的大小，请根据自己的程序选择适当的数值。", "locale": "zh-CN"}}}
{"pid": "P4245", "type": "P", "difficulty": 6, "samples": [["5 8 28\n19 32 0 182 99 95\n77 54 15 3 98 66 21 20 38", "7 18 25 19 5 13 12 2 9 22 5 27 6 26"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "O2优化", "素数判断,质数,筛法", "中国剩余定理 CRT", "快速傅里叶变换 FFT", "模板题"], "title": "【模板】任意模数多项式乘法", "background": "模板题，无背景", "description": "给定 $2$ 个多项式 $F(x), G(x)$ ，请求出 $F(x) * G(x)$。    \n\n**系数对 $p$ 取模**，且**不保证** $p$ 可以分解成 $p = a \\cdot 2^k + 1$ 之形式。", "inputFormat": "输入共 $3$ 行。   \n第一行 $3$ 个整数 $n, m, p$，分别表示 $F(x), G(x)$ 的次数以及模数 $p$ 。   \n第二行为 $n+1$ 个整数，第 $i$ 个整数 $a_i$ 表示 $F(x)$ 的 $i-1$ 次项的系数。   \n第三行为 $m+1$ 个整数，第 $i$ 个整数 $b_i$ 表示 $G(x)$ 的 $i-1$ 次项的系数。\n", "outputFormat": "输出 $n+m+1$ 个整数， 第 $i$ 个整数 $c_i$ 表示 $F(x) * G(x)$ 的 $i-1$ 次项的系数。", "hint": "对于 $100 \\%$ 的数据，$1 \\leq n, m \\leq 10^5$，$0 \\leq a_i, b_i \\leq 10^9$，$2 \\leq p \\leq 10^9 + 9$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Polynomial Multiplication with Arbitrary Modulus", "background": "Template problem, no background.", "description": "Given $2$ polynomials $F(x), G(x)$, compute $F(x) * G(x)$. The coefficients are taken modulo $p$, and it is not guaranteed that $p$ can be written in the form $p = a \\cdot 2^k + 1$.", "inputFormat": "The input consists of $3$ lines.  \nThe first line contains $3$ integers $n, m, p$, representing the degrees of $F(x)$ and $G(x)$, and the modulus $p$.  \nThe second line contains $n+1$ integers; the $i$-th integer $a_i$ denotes the coefficient of the $(i-1)$-th term of $F(x)$.  \nThe third line contains $m+1$ integers; the $i$-th integer $b_i$ denotes the coefficient of the $(i-1)$-th term of $G(x)$.", "outputFormat": "Output $n+m+1$ integers. The $i$-th integer $c_i$ denotes the coefficient of the $(i-1)$-th term of $F(x) * G(x)$.", "hint": "For $100\\%$ of the testdata, $1 \\leq n, m \\leq 10^5$, $0 \\leq a_i, b_i \\leq 10^9$, $2 \\leq p \\leq 10^9 + 9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】任意模数多项式乘法", "background": "模板题，无背景", "description": "给定 $2$ 个多项式 $F(x), G(x)$ ，请求出 $F(x) * G(x)$。    \n\n**系数对 $p$ 取模**，且**不保证** $p$ 可以分解成 $p = a \\cdot 2^k + 1$ 之形式。", "inputFormat": "输入共 $3$ 行。   \n第一行 $3$ 个整数 $n, m, p$，分别表示 $F(x), G(x)$ 的次数以及模数 $p$ 。   \n第二行为 $n+1$ 个整数，第 $i$ 个整数 $a_i$ 表示 $F(x)$ 的 $i-1$ 次项的系数。   \n第三行为 $m+1$ 个整数，第 $i$ 个整数 $b_i$ 表示 $G(x)$ 的 $i-1$ 次项的系数。\n", "outputFormat": "输出 $n+m+1$ 个整数， 第 $i$ 个整数 $c_i$ 表示 $F(x) * G(x)$ 的 $i-1$ 次项的系数。", "hint": "对于 $100 \\%$ 的数据，$1 \\leq n, m \\leq 10^5$，$0 \\leq a_i, b_i \\leq 10^9$，$2 \\leq p \\leq 10^9 + 9$。", "locale": "zh-CN"}}}
{"pid": "P4246", "type": "P", "difficulty": 6, "samples": [["2\nOpen 1 1 1 2\nOpen 1 2 2 2\nAsk 1 1 2 2\nAsk 2 1 2 2\nExit", "Y\nN"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2008", "线段树", "各省省选", "递归", "上海"], "title": "[SHOI2008] 堵塞的交通", "background": "", "description": "有一天，由于某种穿越现象作用，你来到了传说中的小人国。小人国的布局非常奇特，整个国家的交通系统可以被看成是一个 $2$ 行 $C$ 列的矩形网格，网格上的每个点代表一个城市，相邻的城市之间有一条道路，所以总共有 $2C$ 个城市和 $3C-2 $条道路。 \n\n小人国的交通状况非常槽糕。有的时候由于交通堵塞，两座城市之间的道路会变得不连通，直到拥堵解决，道路才会恢复畅通。初来咋到的你决心毛遂自荐到交通部某份差事，部长听说你来自一个科技高度发达的世界，喜出望外地要求你编写一个查询应答系统，以挽救已经病入膏肓的小人国交通系统。 小人国的交通部将提供一些交通信息给你，你的任务是根据当前的交通情况回答查询的问题。交通信息可以分为以下几种格式：\n\n- `Close r1 c1 r2 c2`：相邻的两座城市 $(r_1, c_1)$ 和 $(r_2, c_2)$ 之间的道路被堵塞了；\n- `Open r1 c1 r2 c2`：相邻的两座城市 $(r_1, c_1)$ 和 $(r_2, c_2)$ 之间的道路被疏通了；\n- `Ask r1 c1 r2 c2`：询问城市 $(r_1, c_1)$ 和 $(r_2, c_2)$ 是否连通。如果存在一条路径使得这两条城市连通，则返回 `Y`，否则返回 `N`。\n\n*注：$r_i$ 表示行数，$c_i$ 表示列数，$1 \\leq r_i \\leq 2, 1 \\leq c_i \\leq C$。*", "inputFormat": "第一行只有一个整数 $C$，表示网格的列数。接下来若干行，每行为一条交通信息，以单独的一行 `Exit` 作为结束。我们假设在一开始所有的道路都是堵塞的。我们保证 $C$ 小于等于 $100000$，信息条数小于等于 $100000$。", "outputFormat": "对于每个查询，输出一个 `Y` 或 `N`。", "hint": "**数据范围：**\n\n对于 $100\\%$ 的数据，$1 \\leq C \\leq 100000$，$1 \\leq$ 信息条数 $\\leq 100000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2008] Blocked Traffic", "background": "", "description": "One day, due to some kind of time-travel phenomenon, you arrived in the legendary land of tiny people. Its layout is quite peculiar: the entire country's transportation network can be seen as a rectangular grid with $2$ rows and $C$ columns. Each point on the grid represents a city, and there is a road between adjacent cities. Thus there are $2C$ cities and $3C - 2$ roads in total.\n\nThe traffic situation is terrible. Sometimes, due to congestion, the road between two cities becomes disconnected; it will not be passable again until the congestion clears. As a newcomer, you volunteer to help at the Ministry of Transport. Hearing that you come from a highly advanced world, the minister gladly asks you to write a query response system to save the ailing transportation network. The ministry will provide some traffic information, and your task is to answer queries based on the current traffic situation. The information comes in the following formats:\n\n- `Close r1 c1 r2 c2`: the road between the two adjacent cities $(r_1, c_1)$ and $(r_2, c_2)$ is blocked.\n- `Open r1 c1 r2 c2`: the road between the two adjacent cities $(r_1, c_1)$ and $(r_2, c_2)$ is unblocked.\n- `Ask r1 c1 r2 c2`: ask whether cities $(r_1, c_1)$ and $(r_2, c_2)$ are connected. If there exists a path that connects the two cities, return `Y`; otherwise return `N`.\n\nNote: $r_i$ denotes the row index and $c_i$ denotes the column index, with $1 \\leq r_i \\leq 2$ and $1 \\leq c_i \\leq C$.", "inputFormat": "The first line contains a single integer $C$, the number of columns in the grid. The following lines each contain one traffic instruction, and a single line `Exit` marks the end of input. Initially, all roads are assumed to be blocked. It is guaranteed that $C \\leq 100000$ and the number of instructions $\\leq 100000$.", "outputFormat": "For each query, output a single `Y` or `N`.", "hint": "Constraints:\n\nFor $100\\%$ of the testdata, $1 \\leq C \\leq 100000$, and $1 \\leq$ number of instructions $\\leq 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2008] 堵塞的交通", "background": "", "description": "有一天，由于某种穿越现象作用，你来到了传说中的小人国。小人国的布局非常奇特，整个国家的交通系统可以被看成是一个 $2$ 行 $C$ 列的矩形网格，网格上的每个点代表一个城市，相邻的城市之间有一条道路，所以总共有 $2C$ 个城市和 $3C-2 $条道路。 \n\n小人国的交通状况非常槽糕。有的时候由于交通堵塞，两座城市之间的道路会变得不连通，直到拥堵解决，道路才会恢复畅通。初来咋到的你决心毛遂自荐到交通部某份差事，部长听说你来自一个科技高度发达的世界，喜出望外地要求你编写一个查询应答系统，以挽救已经病入膏肓的小人国交通系统。 小人国的交通部将提供一些交通信息给你，你的任务是根据当前的交通情况回答查询的问题。交通信息可以分为以下几种格式：\n\n- `Close r1 c1 r2 c2`：相邻的两座城市 $(r_1, c_1)$ 和 $(r_2, c_2)$ 之间的道路被堵塞了；\n- `Open r1 c1 r2 c2`：相邻的两座城市 $(r_1, c_1)$ 和 $(r_2, c_2)$ 之间的道路被疏通了；\n- `Ask r1 c1 r2 c2`：询问城市 $(r_1, c_1)$ 和 $(r_2, c_2)$ 是否连通。如果存在一条路径使得这两条城市连通，则返回 `Y`，否则返回 `N`。\n\n*注：$r_i$ 表示行数，$c_i$ 表示列数，$1 \\leq r_i \\leq 2, 1 \\leq c_i \\leq C$。*", "inputFormat": "第一行只有一个整数 $C$，表示网格的列数。接下来若干行，每行为一条交通信息，以单独的一行 `Exit` 作为结束。我们假设在一开始所有的道路都是堵塞的。我们保证 $C$ 小于等于 $100000$，信息条数小于等于 $100000$。", "outputFormat": "对于每个查询，输出一个 `Y` 或 `N`。", "hint": "**数据范围：**\n\n对于 $100\\%$ 的数据，$1 \\leq C \\leq 100000$，$1 \\leq$ 信息条数 $\\leq 100000$。", "locale": "zh-CN"}}}
{"pid": "P4247", "type": "P", "difficulty": 6, "samples": [["5 5\n1 2 3 4 5\nI 2 3 1\nQ 2 4 2\nR 1 5\nI 1 3 -1\nQ 1 5 1", "40\n19940397"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "线段树", "O2优化", "枚举", "CTT（清华集训/北大集训）"], "title": "[清华集训 2012] 序列操作", "background": "", "description": "有一个长度为 $n$ 的序列，有三个操作：\n\n1. `I a b c` 表示将 $[a,b]$ 这一段区间的元素集体增加 $c$；\n2. `R a b`表示将 $[a,b]$ 区间内所有元素变成相反数；\n3. `Q a b c` 表示询问 $[a,b]$ 这一段区间中选择 $c$ 个数相乘的所有方案的和 $\\mod 19940417$ 的值。", "inputFormat": "第一行两个数 $n, q$ 表示序列长度和操作个数。\n\n第二行 $n$ 个整数，表示序列。\n\n接下来 $q$ 行每行输入一个操作 `I a b c` 或者 `R a b` 或者 `Q a b c`，意义如题目描述。", "outputFormat": "对于每个询问，输出选出 $c$ 个数相乘的所有方案的和 $\\mod 19940417$ 的值。", "hint": "**样例说明：**\n\n做完第一个操作序列变为 `1 3 4 4 5`。\n\n第一次询问结果为 $3 \\times 4+3 \\times 4+4 \\times 4=40$。\n\n做完 `R` 操作变成 `-1 -3 -4 -4 -5`。\n\n做完 `I` 操作变为 `-2 -4 -5 -4 -5`。\n\n第二次询问结果为 $-2-4-5-4-5=-20$。\n\n**数据范围：**\n\n对于 $100\\%$ 的数据，$n \\leq 50000, q \\leq 50000$。初始序列的元素的绝对值 $\\leq 10^9$，保证 $[a,b]$ 是一个合法区间，`I` 操作中 $|c| \\leq 10^9$，`Q` 操作中 $1 \\leq c \\leq \\min(b-a+1,20)$。", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training 2012] Sequence Operations", "background": "", "description": "There is a sequence of length $n$ with three operations:\n\n1. `I a b c` means adding $c$ to all elements in the interval $[a,b]$.\n2. `R a b` means turning all elements in the interval $[a,b]$ into their opposites (negating them).\n3. `Q a b c` means querying the value of the sum of products over all ways to choose $c$ numbers from the interval $[a,b]$, taken $\\mod 19940417$.", "inputFormat": "The first line contains two integers $n, q$, denoting the sequence length and the number of operations.\n\nThe second line contains $n$ integers, representing the sequence.\n\nEach of the next $q$ lines contains one operation, either `I a b c`, `R a b`, or `Q a b c`, with meanings as described above.", "outputFormat": "For each query, output the value of the sum of products over all ways to choose $c$ numbers from the specified interval, taken $\\mod 19940417$.", "hint": "Sample explanation:\n\nAfter the first operation, the sequence becomes `1 3 4 4 5`.\n\nThe result of the first query is $3 \\times 4 + 3 \\times 4 + 4 \\times 4 = 40$.\n\nAfter the `R` operation, it becomes `-1 -3 -4 -4 -5`.\n\nAfter the `I` operation, it becomes `-2 -4 -5 -4 -5`.\n\nThe result of the second query is $(-2)+(-4)+(-5)+(-4)+(-5)=-20$.\n\nConstraints:\n\nFor $100\\%$ of the testdata, $n \\leq 50000, q \\leq 50000$. The absolute value of each element in the initial sequence is $\\leq 10^9$. It is guaranteed that $[a,b]$ is a valid interval. In operation `I`, $|c| \\leq 10^9$. In operation `Q`, $1 \\leq c \\leq \\min(b-a+1,20)$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2012] 序列操作", "background": "", "description": "有一个长度为 $n$ 的序列，有三个操作：\n\n1. `I a b c` 表示将 $[a,b]$ 这一段区间的元素集体增加 $c$；\n2. `R a b`表示将 $[a,b]$ 区间内所有元素变成相反数；\n3. `Q a b c` 表示询问 $[a,b]$ 这一段区间中选择 $c$ 个数相乘的所有方案的和 $\\mod 19940417$ 的值。", "inputFormat": "第一行两个数 $n, q$ 表示序列长度和操作个数。\n\n第二行 $n$ 个整数，表示序列。\n\n接下来 $q$ 行每行输入一个操作 `I a b c` 或者 `R a b` 或者 `Q a b c`，意义如题目描述。", "outputFormat": "对于每个询问，输出选出 $c$ 个数相乘的所有方案的和 $\\mod 19940417$ 的值。", "hint": "**样例说明：**\n\n做完第一个操作序列变为 `1 3 4 4 5`。\n\n第一次询问结果为 $3 \\times 4+3 \\times 4+4 \\times 4=40$。\n\n做完 `R` 操作变成 `-1 -3 -4 -4 -5`。\n\n做完 `I` 操作变为 `-2 -4 -5 -4 -5`。\n\n第二次询问结果为 $-2-4-5-4-5=-20$。\n\n**数据范围：**\n\n对于 $100\\%$ 的数据，$n \\leq 50000, q \\leq 50000$。初始序列的元素的绝对值 $\\leq 10^9$，保证 $[a,b]$ 是一个合法区间，`I` 操作中 $|c| \\leq 10^9$，`Q` 操作中 $1 \\leq c \\leq \\min(b-a+1,20)$。", "locale": "zh-CN"}}}
{"pid": "P4248", "type": "P", "difficulty": 6, "samples": [["cacao", "54"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2013", "各省省选", "安徽", "后缀自动机 SAM", "后缀数组 SA", "后缀树", "单调栈"], "title": "[AHOI2013] 差异", "background": "", "description": "给定一个长度为 $n$ 的字符串 $S$，令 $T_i$ 表示它从第 $i$ 个字符开始的后缀。求\n\n$$\\displaystyle \\sum_{1\\leqslant i<j\\leqslant n}\\operatorname{len}(T_i)+\\operatorname{len}(T_j)-2\\times\\operatorname{lcp}(T_i,T_j)$$\n\n其中，$\\text{len}(a)$ 表示字符串 $a$ 的长度，$\\text{lcp}(a,b)$ 表示字符串 $a$ 和字符串 $b$ 的最长公共前缀。", "inputFormat": "一行，一个字符串 $S$。", "outputFormat": "一行，一个整数，表示所求值。", "hint": "#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，保证 $2\\le n\\le 500000$，且 $S$ 中均为小写字母。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2013] Difference", "background": "", "description": "Given a string $S$ of length $n$, let $T_i$ denote the suffix starting from its $i$-th character. Compute\n\n$$\\displaystyle \\sum_{1\\leqslant i<j\\leqslant n}\\operatorname{len}(T_i)+\\operatorname{len}(T_j)-2\\times\\operatorname{lcp}(T_i,T_j)$$\n\nwhere $\\text{len}(a)$ denotes the length of string $a$, and $\\text{lcp}(a,b)$ denotes the longest common prefix of strings $a$ and $b$.", "inputFormat": "One line, a string $S$.", "outputFormat": "One line, an integer representing the required value.", "hint": "#### Constraints\n\n- For $100\\%$ of the testdata, it is guaranteed that $2\\le n\\le 500000$, and all characters in $S$ are lowercase letters.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2013] 差异", "background": "", "description": "给定一个长度为 $n$ 的字符串 $S$，令 $T_i$ 表示它从第 $i$ 个字符开始的后缀。求\n\n$$\\displaystyle \\sum_{1\\leqslant i<j\\leqslant n}\\operatorname{len}(T_i)+\\operatorname{len}(T_j)-2\\times\\operatorname{lcp}(T_i,T_j)$$\n\n其中，$\\text{len}(a)$ 表示字符串 $a$ 的长度，$\\text{lcp}(a,b)$ 表示字符串 $a$ 和字符串 $b$ 的最长公共前缀。", "inputFormat": "一行，一个字符串 $S$。", "outputFormat": "一行，一个整数，表示所求值。", "hint": "#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，保证 $2\\le n\\le 500000$，且 $S$ 中均为小写字母。", "locale": "zh-CN"}}}
{"pid": "P4249", "type": "P", "difficulty": 7, "samples": [["3\n0 1 2\n0 0 2\n2 2 0\n", "1\n0 1 0\n0 0 1\n1 0 0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["图论", "2007", "Special Judge", "O2优化", "图论建模", "费用流", "差分", "WC"], "title": "[WC2007] 剪刀石头布", "background": "", "description": "在一些一对一游戏的比赛（如下棋、乒乓球和羽毛球的单打）中，我们经常会遇到 $A$ 胜过 $B$，$B$ 胜过 $C$ 而 $C$ 又胜过 $A$ 的有趣情况，不妨形象的称之为剪刀石头布情况。有的时候，无聊的人们会津津乐道于统计有多少这样的剪刀石头布情况发生，即有多少对无序三元组 $(A,B,C)$，满足其中的一个人在比赛中赢了另一个人，另一个人赢了第三个人而第三个人又胜过了第一个人。注意这里无序的意思是说三元组中元素的顺序并不重要，将 $(A, B, C)$、$(A, C, B)$、$(B, A, C)$、$(B, C, A)$、$(C, A, B)$ 和 $(C, B, A)$ 视为相同的情况。\n\n有 $N$ 个人参加一场这样的游戏的比赛，赛程规定任意两个人之间都要进行一场比赛：这样总共有 $\\frac{N*(N-1)}{2}$ 场比赛。比赛已经进行了一部分，我们想知道在极端情况下，比赛结束后最多会发生多少剪刀石头布情况。即给出已经发生的比赛结果，而你可以任意安排剩下的比赛的结果，以得到尽量多的剪刀石头布情况。\n", "inputFormat": "输入文件的第 $1$ 行是一个整数 $N$，表示参加比赛的人数。\n\n之后是一个 $N$ 行 $N$ 列的数字矩阵：一共 $N$ 行，每行 $N$ 列，数字间用空格隔开。\n\n在第 $(i+1)$ 行的第 $j$ 列的数字如果是 $1$，则表示 $i$ 在已经发生的比赛中赢了 $j$；该数字若是 $0$，则表示在已经发生的比赛中 $i$ 败于 $j$；该数字是\n $2$，表示 $i$ 和 $j$ 之间的比赛尚未发生。数字矩阵对角线上的数字，即第 $(i+1)$ 行第 $i$ 列的数字都是 $0$，它们仅仅是占位符号，没有任何意义。\n\n输入文件保证合法，不会发生矛盾，当 $i \\neq j$ 时，第 $(i+1)$ 行第 $j$ 列和第 $(j+1)$ 行第 $i$ 列的两个数字要么都是 $2$，要么一个是 $0$ 一个是 $1$。\n", "outputFormat": "输出文件的第 $1$ 行是一个整数，表示在你安排的比赛结果中，出现了多少剪刀石头布情况。\n\n输出文件的第 $2$  行开始有一个和输入文件中格式相同的 $N$ 行 $N$ 列的数字矩阵。第 $(i+1)$ 行第 $j$ 个数字描述了 $i$ 和 $j$ 之间的比赛结果，$1$ 表示 $i$ 赢了 $j$，$0$ 表示 $i$ 负于 $j$，与输入矩阵不同的是，在这个矩阵中没有表示比赛尚未进行的数字 $2$；对角线上的数字都是 $0$。输出矩阵要保证合法，不能发生矛盾。\n", "hint": "### 【评分标准】\n对于每个测试点，仅当你的程序的输出第一行的数字和标准答案一致，且给出了一个与之一致的合法方案，你才能得到该测试点的满分，否则该测试点得 $0$ 分。\n### 【数据范围】\n$30\\%$ 的数据中，$N \\leq 6$；\n\n$100\\%$ 的数据中，$N \\leq 100$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[WC2007] Rock-Paper-Scissors", "background": "", "description": "In some one-on-one game competitions (such as chess, table tennis, and badminton singles), we often encounter the interesting situation where $A$ beats $B$, $B$ beats $C$, and $C$ beats $A$. Let us vividly call this the rock-paper-scissors situation. Sometimes, people will enthusiastically count how many such rock-paper-scissors situations occur, that is, how many unordered triples $(A, B, C)$ satisfy that one person beats another, the second beats the third, and the third beats the first. Note that unordered means the order of elements in the triple does not matter, and $(A, B, C)$, $(A, C, B)$, $(B, A, C)$, $(B, C, A)$, $(C, A, B)$, and $(C, B, A)$ are regarded as the same situation.\n\nThere are $N$ people participating in such a competition. The schedule requires that every pair of people plays exactly one match, so there are a total of $\\frac{N*(N-1)}{2}$ matches. Some matches have already been played. We want to know, in the extreme case, what is the maximum possible number of rock-paper-scissors situations after all matches are completed. That is, given the results of the matches that have already taken place, you may assign the outcomes of the remaining matches arbitrarily to obtain as many rock-paper-scissors situations as possible.", "inputFormat": "The first line contains an integer $N$, the number of participants.\n\nThen follows an $N$-by-$N$ numeric matrix: $N$ rows, each with $N$ columns, and numbers separated by spaces.\n\nIn row $(i+1)$ and column $j$, if the number is $1$, it means $i$ has already beaten $j$; if the number is $0$, it means $i$ has already lost to $j$; if the number is $2$, it means the match between $i$ and $j$ has not yet taken place. The numbers on the diagonal, i.e., the number in row $(i+1)$ and column $i$, are all $0$. They are merely placeholders and have no meaning.\n\nThe input is guaranteed to be valid and without contradictions. When $i \\neq j$, the two numbers at row $(i+1)$, column $j$ and row $(j+1)$, column $i$ are either both $2$, or one is $0$ and the other is $1$.", "outputFormat": "The first line contains an integer, indicating how many rock-paper-scissors situations occur in your arranged set of match results.\n\nStarting from line $2$, output an $N$-by-$N$ numeric matrix in the same format as the input. The number in row $(i+1)$ and column $j$ describes the result of the match between $i$ and $j$: $1$ means $i$ beats $j$, and $0$ means $i$ loses to $j$. Unlike the input matrix, there is no number $2$ indicating an unplayed match; the diagonal numbers are all $0$. The output matrix must be valid and free of contradictions.", "hint": "- Scoring criteria:\n  For each test point, you will receive full credit only if the first line of your output matches the standard answer and you provide a valid arrangement consistent with it. Otherwise, you will receive $0$ points for that test point.\n- Constraints:\n  For $30\\%$ of the testdata, $N \\leq 6$.\n  For $100\\%$ of the testdata, $N \\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2007] 剪刀石头布", "background": "", "description": "在一些一对一游戏的比赛（如下棋、乒乓球和羽毛球的单打）中，我们经常会遇到 $A$ 胜过 $B$，$B$ 胜过 $C$ 而 $C$ 又胜过 $A$ 的有趣情况，不妨形象的称之为剪刀石头布情况。有的时候，无聊的人们会津津乐道于统计有多少这样的剪刀石头布情况发生，即有多少对无序三元组 $(A,B,C)$，满足其中的一个人在比赛中赢了另一个人，另一个人赢了第三个人而第三个人又胜过了第一个人。注意这里无序的意思是说三元组中元素的顺序并不重要，将 $(A, B, C)$、$(A, C, B)$、$(B, A, C)$、$(B, C, A)$、$(C, A, B)$ 和 $(C, B, A)$ 视为相同的情况。\n\n有 $N$ 个人参加一场这样的游戏的比赛，赛程规定任意两个人之间都要进行一场比赛：这样总共有 $\\frac{N*(N-1)}{2}$ 场比赛。比赛已经进行了一部分，我们想知道在极端情况下，比赛结束后最多会发生多少剪刀石头布情况。即给出已经发生的比赛结果，而你可以任意安排剩下的比赛的结果，以得到尽量多的剪刀石头布情况。\n", "inputFormat": "输入文件的第 $1$ 行是一个整数 $N$，表示参加比赛的人数。\n\n之后是一个 $N$ 行 $N$ 列的数字矩阵：一共 $N$ 行，每行 $N$ 列，数字间用空格隔开。\n\n在第 $(i+1)$ 行的第 $j$ 列的数字如果是 $1$，则表示 $i$ 在已经发生的比赛中赢了 $j$；该数字若是 $0$，则表示在已经发生的比赛中 $i$ 败于 $j$；该数字是\n $2$，表示 $i$ 和 $j$ 之间的比赛尚未发生。数字矩阵对角线上的数字，即第 $(i+1)$ 行第 $i$ 列的数字都是 $0$，它们仅仅是占位符号，没有任何意义。\n\n输入文件保证合法，不会发生矛盾，当 $i \\neq j$ 时，第 $(i+1)$ 行第 $j$ 列和第 $(j+1)$ 行第 $i$ 列的两个数字要么都是 $2$，要么一个是 $0$ 一个是 $1$。\n", "outputFormat": "输出文件的第 $1$ 行是一个整数，表示在你安排的比赛结果中，出现了多少剪刀石头布情况。\n\n输出文件的第 $2$  行开始有一个和输入文件中格式相同的 $N$ 行 $N$ 列的数字矩阵。第 $(i+1)$ 行第 $j$ 个数字描述了 $i$ 和 $j$ 之间的比赛结果，$1$ 表示 $i$ 赢了 $j$，$0$ 表示 $i$ 负于 $j$，与输入矩阵不同的是，在这个矩阵中没有表示比赛尚未进行的数字 $2$；对角线上的数字都是 $0$。输出矩阵要保证合法，不能发生矛盾。\n", "hint": "### 【评分标准】\n对于每个测试点，仅当你的程序的输出第一行的数字和标准答案一致，且给出了一个与之一致的合法方案，你才能得到该测试点的满分，否则该测试点得 $0$ 分。\n### 【数据范围】\n$30\\%$ 的数据中，$N \\leq 6$；\n\n$100\\%$ 的数据中，$N \\leq 100$。\n", "locale": "zh-CN"}}}
{"pid": "P4250", "type": "P", "difficulty": 7, "samples": [["5\n1 8\n0 7\n0 0\n8 0\n8 8\n", "0.6316"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2015", "四川", "各省省选", "半平面交"], "title": "[SCOI2015] 小凸想跑步", "background": "", "description": "小凸晚上喜欢到操场跑步，今天他跑完两圈之后，他玩起了这样一个游戏。\n\n操场是个凸 $n$ 边形， $n$ 个顶点按照逆时针从 $0$ ∼ $n - 1$ 编号。现在小凸随机站在操场中的某个位置，标记为 $p$ 点。将 $p$ 点与 $n$ 个顶点各连一条边，形成 $n$ 个三角形。如果这时 $p$ 点， $0$ 号点， $1$ 号点形成的三角形的面\n积是 $n$ 个三角形中最小的一个，小凸则认为这是一次正确站位。\n\n现在小凸想知道他一次站位正确的概率是多少。", "inputFormat": "第 $1$ 行包含 $1$ 个整数 $n$, 表示操场的顶点数和游戏的次数。\n\n接下来有 $n$ 行，每行包含 $2$ 个整数 $x_i, y_i$，表示顶点的坐标。\n\n输入保证按逆时针顺序输入点，所有点保证构成一个凸多边形。所有点保证不存在三点共线。", "outputFormat": "输出 $1$ 个数，正确站位的概率，保留 $4$ 位小数。", "hint": "对于 $30$% 的数据， $3 \\leq n \\leq 4, 0 \\leq x, y \\leq 10$\n\n对于 $100$% 的数据， $3 \\leq n \\leq 10^5, -10^9 \\leq x, y \\leq 10^9$", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2015] Xiao Tu Wants to Run", "background": "", "description": "Xiao Tu (pinyin: Xiao Tu) likes running on the track at night. After finishing two laps today, he started the following game.\n\nThe track is a convex $n$-gon whose $n$ vertices are numbered in counterclockwise order from $0$ to $n - 1$. Now Xiao Tu stands uniformly at random at some point inside the track, denoted as point $p$. Connect point $p$ to all $n$ vertices to form $n$ triangles (i.e., triangles $(p, i, i + 1)$ for all $i$, with indices modulo $n$). If the triangle formed by $p$, vertex $0$, and vertex $1$ has the smallest area among these $n$ triangles, Xiao Tu considers this a correct placement.\n\nNow Xiao Tu wants to know the probability that a single placement is correct.", "inputFormat": "The first line contains an integer $n$, the number of vertices of the track.\n\nThe next $n$ lines each contain two integers $x_i, y_i$, the coordinates of the vertices.\n\nThe input guarantees that the vertices are given in counterclockwise order, they form a convex polygon, and no three points are collinear.", "outputFormat": "Output a single number: the probability of a correct placement, rounded to $4$ decimal places.", "hint": "For $30\\%$ of the testdata, $3 \\le n \\le 4$, $0 \\le x, y \\le 10$.\n\nFor $100\\%$ of the testdata, $3 \\le n \\le 10^5$, $-10^9 \\le x, y \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2015] 小凸想跑步", "background": "", "description": "小凸晚上喜欢到操场跑步，今天他跑完两圈之后，他玩起了这样一个游戏。\n\n操场是个凸 $n$ 边形， $n$ 个顶点按照逆时针从 $0$ ∼ $n - 1$ 编号。现在小凸随机站在操场中的某个位置，标记为 $p$ 点。将 $p$ 点与 $n$ 个顶点各连一条边，形成 $n$ 个三角形。如果这时 $p$ 点， $0$ 号点， $1$ 号点形成的三角形的面\n积是 $n$ 个三角形中最小的一个，小凸则认为这是一次正确站位。\n\n现在小凸想知道他一次站位正确的概率是多少。", "inputFormat": "第 $1$ 行包含 $1$ 个整数 $n$, 表示操场的顶点数和游戏的次数。\n\n接下来有 $n$ 行，每行包含 $2$ 个整数 $x_i, y_i$，表示顶点的坐标。\n\n输入保证按逆时针顺序输入点，所有点保证构成一个凸多边形。所有点保证不存在三点共线。", "outputFormat": "输出 $1$ 个数，正确站位的概率，保留 $4$ 位小数。", "hint": "对于 $30$% 的数据， $3 \\leq n \\leq 4, 0 \\leq x, y \\leq 10$\n\n对于 $100$% 的数据， $3 \\leq n \\leq 10^5, -10^9 \\leq x, y \\leq 10^9$", "locale": "zh-CN"}}}
{"pid": "P4251", "type": "P", "difficulty": 6, "samples": [["2 3 1\n1 2 4\n2 4 1", "1"], ["3 4 2\n1 5 6 6\n8 3 4 3\n6 8 6 3", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "四川", "二分", "各省省选", "网络流", "二分图"], "title": "[SCOI2015] 小凸玩矩阵", "background": "", "description": "小凸和小方是好朋友，小方给了小凸一个 $n$ × $m$ $(n \\leq m)$ 的矩阵 $A$，并且要求小凸从矩阵中选出 $n$ 个数，其中任意两个数都不能在同一行或者同一列。现在小凸想知道，选出的 $n$ 个数中第 $k$ 大的数的最小值是多少。", "inputFormat": "第 $1$ 行读入 $3$ 个整数 $n, m, k$。\n\n接下来 $n$ 行，每一行有 $m$ 个数字，第 $i$ 行第 $j$ 个数字代表矩阵中第 $i$ 行第 $j$ 列的元素 $A_{i,j}$。", "outputFormat": "输出包含一行，为选出的 $n$ 个数中第 $k$ 大数的最小值。", "hint": "对于 $20$% 的数据， $1 \\leq n \\leq m \\leq 9$\n\n对于 $40$% 的数据， $1 \\leq n \\leq m \\leq 22, 1 \\leq n \\leq 12$\n\n对于 $100$% 的数据， $1 \\leq k \\leq n \\leq m \\leq 250, 1 \\leq A_{i,j} \\leq 10^9$", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2015] Xiao Tu Plays with Matrices", "background": "", "description": "Xiao Tu and Xiao Fang are good friends. Xiao Fang gave Xiao Tu an $n \\times m$ ($n \\leq m$) matrix $A$, and asks Xiao Tu to choose $n$ numbers from the matrix such that no two chosen numbers are in the same row or the same column. Now Xiao Tu wants to know the minimum possible value of the $k$-th largest number among the $n$ chosen numbers.", "inputFormat": "The first line contains 3 integers $n$, $m$, $k$.\n\nThen follow $n$ lines, each containing $m$ numbers. In the $i$-th line, the $j$-th number denotes the element $A_{i,j}$ at row $i$ and column $j$ of the matrix.", "outputFormat": "Output one line: the minimum possible value of the $k$-th largest number among the $n$ chosen numbers.", "hint": "For $20$% of the testdata, $1 \\leq n \\leq m \\leq 9$.\n\nFor $40$% of the testdata, $1 \\leq n \\leq m \\leq 22$, $1 \\leq n \\leq 12$.\n\nFor $100$% of the testdata, $1 \\leq k \\leq n \\leq m \\leq 250$, $1 \\leq A_{i,j} \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2015] 小凸玩矩阵", "background": "", "description": "小凸和小方是好朋友，小方给了小凸一个 $n$ × $m$ $(n \\leq m)$ 的矩阵 $A$，并且要求小凸从矩阵中选出 $n$ 个数，其中任意两个数都不能在同一行或者同一列。现在小凸想知道，选出的 $n$ 个数中第 $k$ 大的数的最小值是多少。", "inputFormat": "第 $1$ 行读入 $3$ 个整数 $n, m, k$。\n\n接下来 $n$ 行，每一行有 $m$ 个数字，第 $i$ 行第 $j$ 个数字代表矩阵中第 $i$ 行第 $j$ 列的元素 $A_{i,j}$。", "outputFormat": "输出包含一行，为选出的 $n$ 个数中第 $k$ 大数的最小值。", "hint": "对于 $20$% 的数据， $1 \\leq n \\leq m \\leq 9$\n\n对于 $40$% 的数据， $1 \\leq n \\leq m \\leq 22, 1 \\leq n \\leq 12$\n\n对于 $100$% 的数据， $1 \\leq k \\leq n \\leq m \\leq 250, 1 \\leq A_{i,j} \\leq 10^9$", "locale": "zh-CN"}}}
{"pid": "P4252", "type": "P", "difficulty": 7, "samples": [["5 5\n1 2\n3 2\n2 4\n2 5\n4 5\n", "4\n1\n2\n4\n5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2006", "NOI", "提交答案", "Special Judge", "O2优化"], "title": "[NOI2006] 聪明的导游", "background": "输入数据下载地址：\n\nhttps://pan.baidu.com/s/1jJX0E3c\n\n数据由1584432137提供。\n\nUpd on 2022.8.7：输入文件在附件。", "description": "小佳最近迷上了导游这个工作，一天到晚想着带游客参观各处的景点。正好 M 市在举行 NOI，来参观的人特别的多。不少朋友给小佳介绍了需要导游的人。\n\nM 市有$n$个著名的景点，小佳将这些景点从$1$至$n$编号。有一些景点之间存在双向的路。小佳可以让游客们在任何一个景点集合，然后带着他们参观，最后也可以在任何一个景点结束参观。不过，来参观的游客们都不愿去已经参观过的地方。所以，小佳不能带游客们经过同一个景点两次或两次以上。\n\n小佳希望你帮助他设计一个方案, 走可行的路线, 带游客们参观尽可能多的地方。", "inputFormat": "输入文件为 guide1.in~guide10.in，第一行为两个整数$n,m$，分别表示景点数和路的条数。接下来$m$行，每行两个整数$a,b$，表示景点$a$和景点$b$之间有一条双向路。", "outputFormat": "你需要将答案输出到 guide1.out~guide10.out 中，guide?.out 为对应 guide?.in\n\n的答案。输出的第一行为$p$，表示你能找到的路径所经过的景点个数。接下来$p$ 行，每行一个整数，按顺序表示你所找到的路径上的每一个景点。", "hint": "【说明】\n\n这是一道提交答案式的题目，你不需要提供任何源代码，只需要将自己的输出文件放在与*.in 同一个目录即可。\n\n【样例说明】\t\t\t\t\n题目可能有多解，该样例有 4 个解，你只需输出其中任何一个解。\n\n::cute-table{tuack}\n\n|解 $1$|解 $2$|解 $3$|解 $4$|\n| :----------: | :----------: | :----------: | :----------: |\n|4  |4  |4  |4  |\n|1  |1  |3  |3  |\n|2  |2  |2  |2  |\n|4  |5  |4  |5  |\n|5  |4  |5  |4  |\n\n【评分方法】\n\n你的评分将由你的答案与标准答案之间的差异来给定。设你的答案正确且参观的景点数为 $x$，我们所给出的结果为 $\\mathit{ans}$，则按下表计算你的得分：\n\n::cute-table{tuack}\n\n|得分|条件|得分|条件|\n| :-----------: | :-----------: | :-----------: | :-----------: |\n|$12$  |$x>ans$  |$5$  |$x \\leq ans \\times 0.93$  |\n|$10$  |$x=ans$  |$4$  |$x \\leq ans \\times 0.9$  |\n|$9$  |$x \\leq ans-1$  |$3$  |$x \\leq ans \\times 0.8$  |\n|$8$  |$x \\leq ans-2$  |$2$  |$x \\leq ans \\times 0.7$  |\n|$7$  |$x \\leq ans-3$  |$1$  |$x \\leq ans \\times 0.5$  |\n|$6$  |$x \\leq ans \\times 0.95$  |$0$  |$x \\leq ans < 0.5$  |\n\n如果有多项满足，则取满足条件中的最高得分。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2006] Smart Tour Guide", "background": "Input testdata download link:\nhttps://pan.baidu.com/s/1jJX0E3c\n\nTestdata provided by 1584432137.\n\nUpdated on 2022-08-07: The input files are in the attachments.", "description": "Xiao Jia recently became obsessed with being a tour guide and keeps thinking about taking tourists to visit various scenic spots. It so happens that NOI is being held in M City, and there are many visitors. Many friends introduced people who need a tour guide to Xiao Jia.\n\nThere are $n$ famous scenic spots in M City, numbered from $1$ to $n$. Some pairs of scenic spots are connected by bidirectional roads. Xiao Jia can gather the tourists at any scenic spot to start the tour and can also end the tour at any scenic spot. However, the tourists do not want to visit a place they have already visited. Therefore, Xiao Jia cannot pass through the same scenic spot more than once.\n\nXiao Jia hopes you can help design a plan: choose a feasible route that visits as many scenic spots as possible.", "inputFormat": "The input files are guide1.in ~ guide10.in. The first line contains two integers $n, m$, the number of scenic spots and the number of roads. The next $m$ lines each contain two integers $a, b$, indicating there is a bidirectional road between scenic spot $a$ and scenic spot $b$.", "outputFormat": "You need to write the answers to guide1.out ~ guide10.out, where guide?.out is the answer corresponding to guide?.in. The first line outputs $p$, the number of scenic spots on your path. Then output $p$ lines, each containing one integer, in order, representing each scenic spot on your path.", "hint": "[Explanation]\nThis is an output-only problem. You do not need to submit any source code; just place your output files in the same directory as the corresponding *.in files.\n\n[Sample Explanation]\nThe problem may have multiple correct answers. This sample has 4 solutions. You only need to output any one of them.\n\n::cute-table{tuack}\n\n|Solution $1$|Solution $2$|Solution $3$|Solution $4$|\n| :----------: | :----------: | :----------: | :----------: |\n|4  |4  |4  |4  |\n|1  |1  |3  |3  |\n|2  |2  |2  |2  |\n|4  |5  |4  |5  |\n|5  |4  |5  |4  |\n\n[Scoring Method]\nYour score is determined by the difference between your answer and the official answer. Suppose your answer is correct and the number of scenic spots visited is $x$, and our result is $\\mathit{ans}$. Then your score is computed as follows:\n\n::cute-table{tuack}\n\n|Score|Condition|Score|Condition|\n| :-----------: | :-----------: | :-----------: | :-----------: |\n|$12$  |$x > ans$  |$5$  |$x \\leq ans \\times 0.93$  |\n|$10$  |$x = ans$  |$4$  |$x \\leq ans \\times 0.9$  |\n|$9$  |$x \\leq ans - 1$  |$3$  |$x \\leq ans \\times 0.8$  |\n|$8$  |$x \\leq ans - 2$  |$2$  |$x \\leq ans \\times 0.7$  |\n|$7$  |$x \\leq ans - 3$  |$1$  |$x \\leq ans \\times 0.5$  |\n|$6$  |$x \\leq ans \\times 0.95$  |$0$  |$x \\leq ans \\times 0.5$  |\n\nIf multiple conditions are satisfied, take the highest score.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2006] 聪明的导游", "background": "输入数据下载地址：\n\nhttps://pan.baidu.com/s/1jJX0E3c\n\n数据由1584432137提供。\n\nUpd on 2022.8.7：输入文件在附件。", "description": "小佳最近迷上了导游这个工作，一天到晚想着带游客参观各处的景点。正好 M 市在举行 NOI，来参观的人特别的多。不少朋友给小佳介绍了需要导游的人。\n\nM 市有$n$个著名的景点，小佳将这些景点从$1$至$n$编号。有一些景点之间存在双向的路。小佳可以让游客们在任何一个景点集合，然后带着他们参观，最后也可以在任何一个景点结束参观。不过，来参观的游客们都不愿去已经参观过的地方。所以，小佳不能带游客们经过同一个景点两次或两次以上。\n\n小佳希望你帮助他设计一个方案, 走可行的路线, 带游客们参观尽可能多的地方。", "inputFormat": "输入文件为 guide1.in~guide10.in，第一行为两个整数$n,m$，分别表示景点数和路的条数。接下来$m$行，每行两个整数$a,b$，表示景点$a$和景点$b$之间有一条双向路。", "outputFormat": "你需要将答案输出到 guide1.out~guide10.out 中，guide?.out 为对应 guide?.in\n\n的答案。输出的第一行为$p$，表示你能找到的路径所经过的景点个数。接下来$p$ 行，每行一个整数，按顺序表示你所找到的路径上的每一个景点。", "hint": "【说明】\n\n这是一道提交答案式的题目，你不需要提供任何源代码，只需要将自己的输出文件放在与*.in 同一个目录即可。\n\n【样例说明】\t\t\t\t\n题目可能有多解，该样例有 4 个解，你只需输出其中任何一个解。\n\n::cute-table{tuack}\n\n|解 $1$|解 $2$|解 $3$|解 $4$|\n| :----------: | :----------: | :----------: | :----------: |\n|4  |4  |4  |4  |\n|1  |1  |3  |3  |\n|2  |2  |2  |2  |\n|4  |5  |4  |5  |\n|5  |4  |5  |4  |\n\n【评分方法】\n\n你的评分将由你的答案与标准答案之间的差异来给定。设你的答案正确且参观的景点数为 $x$，我们所给出的结果为 $\\mathit{ans}$，则按下表计算你的得分：\n\n::cute-table{tuack}\n\n|得分|条件|得分|条件|\n| :-----------: | :-----------: | :-----------: | :-----------: |\n|$12$  |$x>ans$  |$5$  |$x \\leq ans \\times 0.93$  |\n|$10$  |$x=ans$  |$4$  |$x \\leq ans \\times 0.9$  |\n|$9$  |$x \\leq ans-1$  |$3$  |$x \\leq ans \\times 0.8$  |\n|$8$  |$x \\leq ans-2$  |$2$  |$x \\leq ans \\times 0.7$  |\n|$7$  |$x \\leq ans-3$  |$1$  |$x \\leq ans \\times 0.5$  |\n|$6$  |$x \\leq ans \\times 0.95$  |$0$  |$x \\leq ans < 0.5$  |\n\n如果有多项满足，则取满足条件中的最高得分。", "locale": "zh-CN"}}}
{"pid": "P4253", "type": "P", "difficulty": 6, "samples": [["3\n5 1 2\n2 1\n", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "2015", "四川", "各省省选", "树形 DP"], "title": "[SCOI2015] 小凸玩密室", "background": "", "description": "小凸和小方相约玩密室逃脱，这个密室是一棵有 $n$ 个节点的完全二叉树，每个节点有一个灯泡。点亮所有灯泡即可逃出密室。每个灯泡有个权值 $a_i$，每条边也有个权值 $b_i$。点亮第一个灯泡不需要花费，之后每点亮一个新的灯泡 $v$ 的花费，等于上一个被点亮的灯泡 $u$ 到这个点 $v$ 的距离 $D_{u,v}$，乘以这个点的权值 $a_v$。在点灯的过程中，要保证任意时刻所有被点亮的灯泡必须连通，在点亮一个灯泡后必须先点亮其子树所有灯泡才能点亮其他灯泡。请告诉他们，逃出密室的最少花费是多少。", "inputFormat": "第 $1$ 行包含 $1$ 个数 $n$，代表节点的个数\n\n第 $2$ 行包含 $n$ 个数，代表每个节点的权值 $a_i$。 $(i = 1, 2,$……$, n)$\n\n第 $3$ 行包含 $n - 1$ 个数，代表每条边的权值 $b_i$，第 $i$ 号边是由第 $(i+1)/2$ 号点连向第 $i + 1$ 号点的边。$(i = 1, 2,$……$, n - 1)$", "outputFormat": "输出包含 $1$ 个数，代表最少的花费。", "hint": "对于 $10$% 的数据， $1 \\leq n \\leq 10$\n\n对于 $20$% 的数据， $1 \\leq n \\leq 20$\n\n对于 $30$% 的数据， $1 \\leq n \\leq 2000$\n\n对于 $100$% 的数据， $1 \\leq n \\leq 2 \\times 10^5, 1 \\leq a_i, b_i \\leq 10^5$", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2015] Xiao Tu Plays the Escape Room", "background": "", "description": "Xiao Tu and Xiao Fang decide to play an escape room. The escape room is a complete binary tree with $n$ nodes, and each node has a light bulb. You can escape by lighting all bulbs. Each bulb has a weight $a_i$, and each edge has a weight $b_i$. Lighting the first bulb costs nothing. After that, lighting a new bulb $v$ costs $D_{u,v} \\times a_v$, where $u$ is the bulb lit immediately before and $D_{u,v}$ is the distance from $u$ to $v$ in the tree (the sum of edge weights along the path). During the process, at any time the lit bulbs must be connected. Moreover, once you light a bulb, you must finish lighting all bulbs in its subtree before you may light any bulb outside that subtree. Please tell them the minimum total cost to escape.", "inputFormat": "The first line contains one integer $n$, the number of nodes.\n\nThe second line contains $n$ integers, the weight $a_i$ of each node ($i = 1, 2, \\ldots, n$).\n\nThe third line contains $n - 1$ integers, the weight $b_i$ of each edge. The $i$-th edge connects node $\\left\\lfloor \\dfrac{i+1}{2} \\right\\rfloor$ to node $i + 1$ ($i = 1, 2, \\ldots, n - 1$).", "outputFormat": "Output one integer, the minimum total cost.", "hint": "For 10% of the testdata, $1 \\leq n \\leq 10$.\n\nFor 20% of the testdata, $1 \\leq n \\leq 20$.\n\nFor 30% of the testdata, $1 \\leq n \\leq 2000$.\n\nFor 100% of the testdata, $1 \\leq n \\leq 2 \\times 10^5$, $1 \\leq a_i, b_i \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2015] 小凸玩密室", "background": "", "description": "小凸和小方相约玩密室逃脱，这个密室是一棵有 $n$ 个节点的完全二叉树，每个节点有一个灯泡。点亮所有灯泡即可逃出密室。每个灯泡有个权值 $a_i$，每条边也有个权值 $b_i$。点亮第一个灯泡不需要花费，之后每点亮一个新的灯泡 $v$ 的花费，等于上一个被点亮的灯泡 $u$ 到这个点 $v$ 的距离 $D_{u,v}$，乘以这个点的权值 $a_v$。在点灯的过程中，要保证任意时刻所有被点亮的灯泡必须连通，在点亮一个灯泡后必须先点亮其子树所有灯泡才能点亮其他灯泡。请告诉他们，逃出密室的最少花费是多少。", "inputFormat": "第 $1$ 行包含 $1$ 个数 $n$，代表节点的个数\n\n第 $2$ 行包含 $n$ 个数，代表每个节点的权值 $a_i$。 $(i = 1, 2,$……$, n)$\n\n第 $3$ 行包含 $n - 1$ 个数，代表每条边的权值 $b_i$，第 $i$ 号边是由第 $(i+1)/2$ 号点连向第 $i + 1$ 号点的边。$(i = 1, 2,$……$, n - 1)$", "outputFormat": "输出包含 $1$ 个数，代表最少的花费。", "hint": "对于 $10$% 的数据， $1 \\leq n \\leq 10$\n\n对于 $20$% 的数据， $1 \\leq n \\leq 20$\n\n对于 $30$% 的数据， $1 \\leq n \\leq 2000$\n\n对于 $100$% 的数据， $1 \\leq n \\leq 2 \\times 10^5, 1 \\leq a_i, b_i \\leq 10^5$", "locale": "zh-CN"}}}
{"pid": "P4254", "type": "P", "difficulty": 6, "samples": [["10\nProject 5.10200 0.65000\nProject 2.76200 1.43000\nQuery 4\nQuery 2\nProject 3.80200 1.17000\nQuery 2\nQuery 3\nQuery 1\nProject 4.58200 0.91000\nProject 5.36200 0.39000", "0\n0\n0\n0\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "递归", "江苏", "李超线段树"], "title": "[JSOI2008] Blue Mary 开公司", "background": "Blue Mary 最近在筹备开一家自己的网络公司。由于他缺乏经济头脑，所以先后聘请了若干个金融顾问为他设计经营方案。", "description": "万事开头难，经营公司更是如此。开始的收益往往是很低的，不过随着时间的增长会慢慢变好。也就是说，**对于一个金融顾问 $i$，他设计的经营方案中，每天的收益都比前一天高，并且均增长一个相同的量 $P_i$。**\n\n由于金融顾问的工作效率不高，**所以在特定的时间，Blue Mary 只能根据他已经得到的经营方案来估算某一时间的最大收益**。由于 Blue Mary 是很没有经济头脑的，所以他在估算每天的最佳获益时完全不会考虑之前的情况，而是直接从所有金融顾问的方案中选择一个在当天获益最大的方案的当天的获益值，例如：\n\n有如下两个金融顾问分别对前四天的收益方案做了设计：\n\n|   | 第一天 | 第二天 | 第三天 | 第四天 | $P_i$ |\n| :-: | :-: | :-: | :-: | :-: | :-: |\n| 顾问 1 | $1$ | $5 $| $9$ | $13$ | $4$ |\n| 顾问 2 | $2$ | $5$ | $8$ | $11$ | $3$ |\n\n在第一天，Blue Mary 认为最大收益是 $2$（使用顾问 2 的方案），而在第三天和第四天，他认为最大收益分别是 $9$ 和 $13$（使用顾问 1 的方案）。而他认为前四天的最大收益是：$2 + 5 + 9 + 13 = 29$。\n\n现在你作为 Blue Mary 公司的副总经理，会不时收到金融顾问的设计方案，也需要随时回答 Blue Mary 对某天的“最大收益”的询问（这里的“最大收益”是按照 Blue Mary 的计算方法）。**一开始没有收到任何方案时，你可以认为每天的最大收益值是 0**。下面是一组收到方案和回答询问的例子：\n\n\n- 询问 $2$，回答 $0$。\n- 收到方案：$0\\ 1\\ 2\\ 3\\ 4\\ 5\\ \\cdots$\n- 询问 $2$，回答 $1$。\n- 收到方案：$2\\ 2.1\\ 2.2\\ 2.3\\ 2.4\\ \\cdots$\n- 询问 $2$，回答 $2.1$。", "inputFormat": "第一行 ：一个整数 $N$，表示方案和询问的总数。 \n\n接下来 $N$ 行，每行开头一个单词 `Query` 或 `Project`。 \n\n若单词为 `Query`，则后接一个整数 $T$，表示 Blue Mary 询问第 $T$ 天的最大收益。 \n\n若单词为 `Project`，则后接两个实数 $S, P$，表示该种设计方案第一天的收益 $S$，以及以后每天比上一天多出的收益 $P$。", "outputFormat": "对于每一个 `Query`，输出一个整数，表示询问的答案，并精确到整百元（以百元为单位，例如：该天最大收益为 $210$ 或 $290$ 时，均应该输出 $2$）。没有方案时回答询问要输出 $0$。", "hint": "**数据范围**\n\n$1 \\leq N \\leq 10 ^ 5$，$1 \\leq T \\leq 5\\times 10 ^ 4$，$0 < P < 100$，$|S| \\leq 10 ^ 5$。\n\n**提示**\n\n本题读写数据量可能相当巨大，请选手注意选择高效的文件读写方式。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2008] Blue Mary Starts a Company", "background": "Blue Mary is preparing to start her own Internet company. Since she lacks financial sense, she has successively hired several financial consultants to design business plans for her.", "description": "Starting is hard, and running a company is even harder. Initial profits are usually low, but they gradually improve over time. That is, for a financial consultant $i$, in the plan they design, each day's profit is higher than the previous day by the same amount $P_i$.\n\nBecause the consultants are not very efficient, at any particular time Blue Mary can only estimate the maximum profit for some day based on the plans she has already received. Since Blue Mary has little financial sense, when estimating the best profit for each day she does not consider the past at all, and simply chooses, among all consultants' plans, the profit of the plan that gives the largest profit on that day. For example:\n\nTwo consultants have designed profit plans for the first four days as follows:\n\n|   | Day 1 | Day 2 | Day 3 | Day 4 | $P_i$ |\n| :-: | :-: | :-: | :-: | :-: | :-: |\n| Consultant 1 | $1$ | $5$ | $9$ | $13$ | $4$ |\n| Consultant 2 | $2$ | $5$ | $8$ | $11$ | $3$ |\n\nOn Day 1, Blue Mary believes the maximum profit is $2$ (using Consultant 2's plan), and on Days 3 and 4 she believes the maximum profits are $9$ and $13$, respectively (using Consultant 1's plan). She believes the total maximum profit for the first four days is $2 + 5 + 9 + 13 = 29$.\n\nNow, as the deputy general manager of Blue Mary's company, you will occasionally receive consultants' plans and must also answer Blue Mary's queries for the \"maximum profit\" on some day (the \"maximum profit\" is computed according to Blue Mary's method). Initially, when no plan has been received, you may assume the maximum profit for every day is $0$. Here is an example of received plans and answered queries:\n\n- Query $2$, answer $0$.\n- Receive plan: $0\\ 1\\ 2\\ 3\\ 4\\ 5\\ \\cdots$.\n- Query $2$, answer $1$.\n- Receive plan: $2\\ 2.1\\ 2.2\\ 2.3\\ 2.4\\ \\cdots$.\n- Query $2$, answer $2.1$.", "inputFormat": "The first line contains an integer $N$, the total number of plans and queries.\n\nThe next $N$ lines each begin with a word `Query` or `Project`.\n\nIf the word is `Query`, it is followed by an integer $T$, meaning Blue Mary asks for the maximum profit on Day $T$.\n\nIf the word is `Project`, it is followed by two real numbers $S, P$, meaning that in this plan the profit on Day 1 is $S$, and afterwards each day's profit is greater than the previous day's by $P$.", "outputFormat": "For each `Query`, output one integer, reported in hundreds of yuan (i.e., in units of 100 yuan; for example, if the maximum profit on that day is $210$ or $290$, you should output $2$). When there is no plan, output $0$ for the query.", "hint": "Constraints\n\n$1 \\leq N \\leq 10^5$, $1 \\leq T \\leq 5 \\times 10^4$, $0 < P < 100$, $|S| \\leq 10^5$.\n\nHint\n\nThe amount of input and output may be quite large. Please use fast I/O methods.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2008] Blue Mary 开公司", "background": "Blue Mary 最近在筹备开一家自己的网络公司。由于他缺乏经济头脑，所以先后聘请了若干个金融顾问为他设计经营方案。", "description": "万事开头难，经营公司更是如此。开始的收益往往是很低的，不过随着时间的增长会慢慢变好。也就是说，**对于一个金融顾问 $i$，他设计的经营方案中，每天的收益都比前一天高，并且均增长一个相同的量 $P_i$。**\n\n由于金融顾问的工作效率不高，**所以在特定的时间，Blue Mary 只能根据他已经得到的经营方案来估算某一时间的最大收益**。由于 Blue Mary 是很没有经济头脑的，所以他在估算每天的最佳获益时完全不会考虑之前的情况，而是直接从所有金融顾问的方案中选择一个在当天获益最大的方案的当天的获益值，例如：\n\n有如下两个金融顾问分别对前四天的收益方案做了设计：\n\n|   | 第一天 | 第二天 | 第三天 | 第四天 | $P_i$ |\n| :-: | :-: | :-: | :-: | :-: | :-: |\n| 顾问 1 | $1$ | $5 $| $9$ | $13$ | $4$ |\n| 顾问 2 | $2$ | $5$ | $8$ | $11$ | $3$ |\n\n在第一天，Blue Mary 认为最大收益是 $2$（使用顾问 2 的方案），而在第三天和第四天，他认为最大收益分别是 $9$ 和 $13$（使用顾问 1 的方案）。而他认为前四天的最大收益是：$2 + 5 + 9 + 13 = 29$。\n\n现在你作为 Blue Mary 公司的副总经理，会不时收到金融顾问的设计方案，也需要随时回答 Blue Mary 对某天的“最大收益”的询问（这里的“最大收益”是按照 Blue Mary 的计算方法）。**一开始没有收到任何方案时，你可以认为每天的最大收益值是 0**。下面是一组收到方案和回答询问的例子：\n\n\n- 询问 $2$，回答 $0$。\n- 收到方案：$0\\ 1\\ 2\\ 3\\ 4\\ 5\\ \\cdots$\n- 询问 $2$，回答 $1$。\n- 收到方案：$2\\ 2.1\\ 2.2\\ 2.3\\ 2.4\\ \\cdots$\n- 询问 $2$，回答 $2.1$。", "inputFormat": "第一行 ：一个整数 $N$，表示方案和询问的总数。 \n\n接下来 $N$ 行，每行开头一个单词 `Query` 或 `Project`。 \n\n若单词为 `Query`，则后接一个整数 $T$，表示 Blue Mary 询问第 $T$ 天的最大收益。 \n\n若单词为 `Project`，则后接两个实数 $S, P$，表示该种设计方案第一天的收益 $S$，以及以后每天比上一天多出的收益 $P$。", "outputFormat": "对于每一个 `Query`，输出一个整数，表示询问的答案，并精确到整百元（以百元为单位，例如：该天最大收益为 $210$ 或 $290$ 时，均应该输出 $2$）。没有方案时回答询问要输出 $0$。", "hint": "**数据范围**\n\n$1 \\leq N \\leq 10 ^ 5$，$1 \\leq T \\leq 5\\times 10 ^ 4$，$0 < P < 100$，$|S| \\leq 10 ^ 5$。\n\n**提示**\n\n本题读写数据量可能相当巨大，请选手注意选择高效的文件读写方式。", "locale": "zh-CN"}}}
{"pid": "P4255", "type": "P", "difficulty": 5, "samples": [["5 5 5\n5 1\n9 2\n8 1\n8 1\n6 2\n5 2\n1 2\n2 2\n1 1\n5 3\n1 1 3 2\n2 1\n3 3 4 1\n3 2 3 1\n3 1 2 1\n", "9293681\n15578602\n849742\n"]], "limits": {"time": [1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["并查集", "O2优化", "素数判断,质数,筛法", "逆元"], "title": "公主の#18文明游戏", "background": "公主发现了一个游戏，998，于是我就花钱给她买下来了（捂脸）", "description": "这个游戏叫做《文♂明》（滑稽），但是跟平常意义上的不一样。\n\n这个游戏里有 $n$ 个城市，标号 $1 \\sim n$ ，有 $m$ 条双向道路相连，编号 $1 \\sim m$。\n\n游戏里会系统会添加 $N_i$ 个人到一个城市 $X_i$，并给定这些人的信仰 $C_i$。\n\n系统还会切断一条道路，并给定道路编号 $X_i$。\n\n系统还会给定一个城市 $X_i$，询问从 $X_i$ 出发可以到达的所有城市中选择 $N_i$ 个人，使得他们信仰都为 $C_i$ 的概率为多少，对 $19260817$ 取模。\n\n输入数据不保证没有重边和自环。\n\n输入数据不保证同一条边不会被切断两次以上。\n\n因为是公主的游戏，所以本题输入量较大，请注意输入的优化。", "inputFormat": "第一行三个正整数 $n$, $m$, $q$。\n\n接下来 $n$ 行，每行两个正整数 $N_i$, $C_i$，分别代表第 $i$ 个城市初始人数和信仰。\n\n接下来 $m$ 行，每行两个正整数 $X_i$， $Y_i$，分别代表这条道路的起点和终点。\n\n接下来 $q$ 行，每行第一个正整数 $opt$ $(1 \\leq opt \\leq 3)$。\n\n当 $opt=1$ 时，表示系统添加人类，输入三个整数 $X_i$, $N_i$, $C_i$。\n\n当 $opt=2$ 时，表示系统切断道路，输入一个整数 $X_i$。\n\n当 $opt=3$ 时，表示系统询问概率，输入三个整数 $X_i$, $N_i$, $C_i$。", "outputFormat": "对于每一个 $opt=3$ 的操作，输出一行一个整数。", "hint": "吐槽某人居然没告诉我 我没放样例\n\n补发样例（其实我本来有样例来着）\n\n在这里跟大家道歉\n\n对于30%的数据，$1 \\leq n,m,q \\leq 100$\n\n对于60%的数据，$1 \\leq n,m,q \\leq 50000$\n\n对于100%的数据，$1 \\leq n,m,q \\leq400000$\n\n对于100%的数据，保证所有信仰在 C++ 的 int，Pascal 的 long int 范围内\n\n对于 $100\\%$ 的数据，保证每次添加的人数和初始人数都不超过 $10$\n\n对于 $100\\%$ 的数据，保证数据随机生成\n\n题目 @玫葵之蝶", "locale": "zh-CN", "translations": {"en": {"title": "Princess’s #18 Civilization Game", "background": "The princess found a game priced at 998, so I paid to buy it for her (facepalm).", "description": "This game is called “Civil♂ization” (just for laughs), but it’s not the same as the usual meaning.\n\nThere are $n$ cities in the game, numbered $1 \\sim n$, connected by $m$ undirected roads, numbered $1 \\sim m$.\n\nThe system may add $N_i$ people to a city $X_i$, and assign these people the belief $C_i$.\n\nThe system may also cut a road, given by its road ID $X_i$.\n\nThe system may also give a city $X_i$ and ask: among all cities reachable from $X_i$, if we select $N_i$ people, what is the probability that all of them have belief $C_i$, modulo $19260817$.\n\nThe input data are not guaranteed to be free of multiple edges and self-loops.\n\nThe input data are not guaranteed that the same edge will not be cut more than twice.\n\nBecause it is the princess’s game, the input size is large. Please optimize input/output.", "inputFormat": "The first line contains three positive integers $n, m, q$.\n\nThe next $n$ lines each contain two positive integers $N_i, C_i$, representing the initial population and belief of city $i$.\n\nThe next $m$ lines each contain two positive integers $X_i, Y_i$, representing the endpoints of a road.\n\nThe next $q$ lines each begin with a positive integer $opt$ $(1 \\leq opt \\leq 3)$.\n\n- If $opt = 1$, the system adds people: input three integers $X_i, N_i, C_i$.\n- If $opt = 2$, the system cuts a road: input one integer $X_i$.\n- If $opt = 3$, the system asks for a probability: input three integers $X_i, N_i, C_i$.", "outputFormat": "For each operation with $opt = 3$, output one line with one integer.", "hint": "Complaining that someone didn’t tell me I forgot to include a sample.\n\nSupplementing a sample (I actually had one).\n\nApologies to everyone.\n\nConstraints:\n- For $30\\%$ of the testdata, $1 \\leq n, m, q \\leq 100$.\n- For $60\\%$ of the testdata, $1 \\leq n, m, q \\leq 50000$.\n- For $100\\%$ of the testdata, $1 \\leq n, m, q \\leq 400000$.\n- For $100\\%$ of the testdata, all beliefs fit within C++ int and Pascal long int.\n- For $100\\%$ of the testdata, each addition size and each initial population do not exceed $10$.\n- For $100\\%$ of the testdata, the testdata are randomly generated.\n\nProblem by @玫葵之蝶.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "公主の#18文明游戏", "background": "公主发现了一个游戏，998，于是我就花钱给她买下来了（捂脸）", "description": "这个游戏叫做《文♂明》（滑稽），但是跟平常意义上的不一样。\n\n这个游戏里有 $n$ 个城市，标号 $1 \\sim n$ ，有 $m$ 条双向道路相连，编号 $1 \\sim m$。\n\n游戏里会系统会添加 $N_i$ 个人到一个城市 $X_i$，并给定这些人的信仰 $C_i$。\n\n系统还会切断一条道路，并给定道路编号 $X_i$。\n\n系统还会给定一个城市 $X_i$，询问从 $X_i$ 出发可以到达的所有城市中选择 $N_i$ 个人，使得他们信仰都为 $C_i$ 的概率为多少，对 $19260817$ 取模。\n\n输入数据不保证没有重边和自环。\n\n输入数据不保证同一条边不会被切断两次以上。\n\n因为是公主的游戏，所以本题输入量较大，请注意输入的优化。", "inputFormat": "第一行三个正整数 $n$, $m$, $q$。\n\n接下来 $n$ 行，每行两个正整数 $N_i$, $C_i$，分别代表第 $i$ 个城市初始人数和信仰。\n\n接下来 $m$ 行，每行两个正整数 $X_i$， $Y_i$，分别代表这条道路的起点和终点。\n\n接下来 $q$ 行，每行第一个正整数 $opt$ $(1 \\leq opt \\leq 3)$。\n\n当 $opt=1$ 时，表示系统添加人类，输入三个整数 $X_i$, $N_i$, $C_i$。\n\n当 $opt=2$ 时，表示系统切断道路，输入一个整数 $X_i$。\n\n当 $opt=3$ 时，表示系统询问概率，输入三个整数 $X_i$, $N_i$, $C_i$。", "outputFormat": "对于每一个 $opt=3$ 的操作，输出一行一个整数。", "hint": "吐槽某人居然没告诉我 我没放样例\n\n补发样例（其实我本来有样例来着）\n\n在这里跟大家道歉\n\n对于30%的数据，$1 \\leq n,m,q \\leq 100$\n\n对于60%的数据，$1 \\leq n,m,q \\leq 50000$\n\n对于100%的数据，$1 \\leq n,m,q \\leq400000$\n\n对于100%的数据，保证所有信仰在 C++ 的 int，Pascal 的 long int 范围内\n\n对于 $100\\%$ 的数据，保证每次添加的人数和初始人数都不超过 $10$\n\n对于 $100\\%$ 的数据，保证数据随机生成\n\n题目 @玫葵之蝶", "locale": "zh-CN"}}}
{"pid": "P4256", "type": "P", "difficulty": 6, "samples": [["10 10\n42 68 35 1 70 25 79 59 63 65 \nL 2 6 28\nL 2 6 43\nG 2 7 5\nG 3 4 83\nL 7 9 96\nG 2 7 39\nS 3 8 100\nL 4 5 12\nG 4 4 65\nL 2 4 69", "0\n32\n1\n1\n75\n1\n1\n10\n1\n34"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "线段树", "O2优化", "素数判断,质数,筛法", "进制"], "title": "公主の#19准备月考", "background": "公主在玩完游戏后，也要月考了。（就算是公主也要月考啊QWQ）", "description": "公主的文综太差了，全校排名 $1100$+（全校就 $1100$ 多人），她分析了好久，发现她如果把所有时间放在选择题上，得分会比较好一点。\n\n文综题目共有 $n$ 个，编号从 $1$ 到 $n$。\n\n公主给每个题目算出来了一个预估值 $A_i$，她认为，一段连续题目的答案会在它们的预估值的 $\\gcd$ 和 $\\operatorname{lcm}$ 之间；有时候她的想法不同了，一些题目的预估值会改变；有时候，会出现多选题，多选题的答案数量就是一段连续题目答案的预估值的公约数的个数。\n\n具体来说，对于一个数列，有四种操作：\n\n- `L x y p`：表示公主询问区间 $[x,y]$ 的数字的 $\\operatorname{lcm}$ 对 $p$ 取模之后的值。\n\n- `G x y p`：表示公主询问区间 $[x,y]$ 的数字的 $\\gcd$ 对 $p$ 取模之后的值。\n\n- `C x y c`：表示公主改变区间 $[x,y]$ 的数字的值，统一改为 $c$。\n\n- `S x y p`：表示公主询问区间 $[x,y]$ 的数字的公因数个数对 $p$ 取模之后的值。\n\n公主月考不能挂科，不然她就不能学习 OI 了（假的），所以请你帮帮她吧！", "inputFormat": "第一行，两个正整数 $n$ 和 $q$，其中 $n$ 表示题目个数，$q$ 表示操作次数。\n\n第二行，$n$ 个正整数，表示公主对题目的预估值。\n\n接下来 $q$ 行，每行输入一个操作，格式详见题目描述。", "outputFormat": "对于每个询问，输出它的答案。", "hint": "对于 $30\\%$ 的数据，$1\\le n,q\\le 1000$。\n\n对于另外 $20\\%$ 的数据，$1\\le n\\le 1000，1\\le q\\le 10^5$。\n\n对于另外 $20\\%$ 的数据，$1\\le n\\le 10^5，1\\le q\\le 10^5$，保证没有修改操作。\n\n对于 $100\\%$ 的数据，$1\\le n\\le 3\\times 10^5，1\\le q\\le 3\\times 10^5$。\n\n保证任何时刻每个题目的预估值都在 $[1,100]$ 之间，答案取模之后不超过 `int`。", "locale": "zh-CN", "translations": {"en": {"title": "Princess #19 Prepares for the Monthly Exam", "background": "After finishing her games, the princess still has to take the monthly exam. (Even a princess has monthly exams, QWQ.)", "description": "The princess is very weak in liberal arts comprehensive, ranking $1100+$ in the whole school (and the whole school has just over $1100$ students). After thinking for a long time, she found that if she puts all her time into multiple-choice questions, she can score a bit better.\n\nThere are $n$ questions in liberal arts, numbered from $1$ to $n$.\n\nThe princess computed an estimated value $A_i$ for each question. She believes that the answer for a contiguous block of questions will lie between the $\\gcd$ and $\\operatorname{lcm}$ of their estimated values. Sometimes her thoughts change, and some questions’ estimated values will change. Sometimes multiple-answer questions appear; the number of correct answers for such questions equals the number of common divisors of the estimated values over a contiguous block.\n\nSpecifically, for a sequence, there are four operations:\n\n- `L x y p`: Ask for the value of $\\operatorname{lcm}$ of numbers in the range $[x,y]$ modulo $p$.\n- `G x y p`: Ask for the value of $\\gcd$ of numbers in the range $[x,y]$ modulo $p$.\n- `C x y c`: Change all numbers in the range $[x,y]$ to $c$.\n- `S x y p`: Ask for the number of common divisors of the numbers in the range $[x,y]$, then take it modulo $p$.\n\nThe princess must not fail the monthly exam, or she won't be able to study OI (just kidding), so please help her!", "inputFormat": "The first line contains two positive integers $n$ and $q$, where $n$ is the number of questions and $q$ is the number of operations.\n\nThe second line contains $n$ positive integers, representing the princess’s estimated values for the questions.\n\nThe next $q$ lines each contain one operation; see the Description for the format.", "outputFormat": "For each query, output its answer.", "hint": "Constraints\n\n- For $30\\%$ of the testdata, $1 \\le n, q \\le 1000$.\n- For another $20\\%$ of the testdata, $1 \\le n \\le 1000$, $1 \\le q \\le 10^5$.\n- For another $20\\%$ of the testdata, $1 \\le n \\le 10^5$, $1 \\le q \\le 10^5$, and there are no update operations.\n- For $100\\%$ of the testdata, $1 \\le n \\le 3 \\times 10^5$, $1 \\le q \\le 3 \\times 10^5$.\n\nAt any time, each question’s estimated value is in $[1, 100]$, and each answer after taking modulo fits in `int`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "公主の#19准备月考", "background": "公主在玩完游戏后，也要月考了。（就算是公主也要月考啊QWQ）", "description": "公主的文综太差了，全校排名 $1100$+（全校就 $1100$ 多人），她分析了好久，发现她如果把所有时间放在选择题上，得分会比较好一点。\n\n文综题目共有 $n$ 个，编号从 $1$ 到 $n$。\n\n公主给每个题目算出来了一个预估值 $A_i$，她认为，一段连续题目的答案会在它们的预估值的 $\\gcd$ 和 $\\operatorname{lcm}$ 之间；有时候她的想法不同了，一些题目的预估值会改变；有时候，会出现多选题，多选题的答案数量就是一段连续题目答案的预估值的公约数的个数。\n\n具体来说，对于一个数列，有四种操作：\n\n- `L x y p`：表示公主询问区间 $[x,y]$ 的数字的 $\\operatorname{lcm}$ 对 $p$ 取模之后的值。\n\n- `G x y p`：表示公主询问区间 $[x,y]$ 的数字的 $\\gcd$ 对 $p$ 取模之后的值。\n\n- `C x y c`：表示公主改变区间 $[x,y]$ 的数字的值，统一改为 $c$。\n\n- `S x y p`：表示公主询问区间 $[x,y]$ 的数字的公因数个数对 $p$ 取模之后的值。\n\n公主月考不能挂科，不然她就不能学习 OI 了（假的），所以请你帮帮她吧！", "inputFormat": "第一行，两个正整数 $n$ 和 $q$，其中 $n$ 表示题目个数，$q$ 表示操作次数。\n\n第二行，$n$ 个正整数，表示公主对题目的预估值。\n\n接下来 $q$ 行，每行输入一个操作，格式详见题目描述。", "outputFormat": "对于每个询问，输出它的答案。", "hint": "对于 $30\\%$ 的数据，$1\\le n,q\\le 1000$。\n\n对于另外 $20\\%$ 的数据，$1\\le n\\le 1000，1\\le q\\le 10^5$。\n\n对于另外 $20\\%$ 的数据，$1\\le n\\le 10^5，1\\le q\\le 10^5$，保证没有修改操作。\n\n对于 $100\\%$ 的数据，$1\\le n\\le 3\\times 10^5，1\\le q\\le 3\\times 10^5$。\n\n保证任何时刻每个题目的预估值都在 $[1,100]$ 之间，答案取模之后不超过 `int`。", "locale": "zh-CN"}}}
{"pid": "P4257", "type": "P", "difficulty": 6, "samples": [["4 1\n1 2 3 4\n", "333333359"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 2000, 2000, 10000, 5000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "O2优化", "快速莫比乌斯变换 FMT"], "title": "可爱の#10数字划分", "background": "可可可可可可爱的付公主 qwq 有 $n$ 个数，$1\\sim n$，每个数都有价值 $V_i$，你要将它们划分成若干个集合，每个数属于一个集合。", "description": "我们这里规定:\n\n1. 质数只能和质数分在同一个集合。  \n2. 合数只能和合数分在同一个集合（$1$ 也算在合数内）。   \n3. 我们假设目前所有质数集合的并集为 $U$（也就是之前所有质数集合以及 $S$ 的并集），每个质数集合 $S$ 的价值定义如下：  \n$$V_S=\\frac {(\\sum_{i\\in S}V_i)^p} {\\prod_{i\\in U}V_i}$$\n\n4. 我们定义每个合数集合 $S$ 的价值如下:\n\n令 $k=|S|$，我们用这 $k$ 个数分别作为 $k$ 条边的权值，连接 $k+1$ 个点，构成一棵树。对于一个排列 $P(1\\sim k+1)$，价值为：\n\n$$V_P=\\sum_{i=1}^{n-1} f(P_i,P_{i+1})$$\n\n其中 $f(u,v)$ 为路径 $(u,v)$ 上最大的边权。\n\n集合 $S$ 的价值为：\n\n$$V_S=E(\\min\\{V_P\\})\\times|S|$$\n\n其中 $E(X)$ 代表 $X$ 的数学期望，期望是针对所有可能的有标号无根树，$\\min$ 是针对所有可能的 $P$。这时集合内所有元素都不同，也就是所有边不同。\n\n5. 一个划分方案的价值定义为所有集合的价值的乘积。\n6. 两个划分方案相同当且仅当它们中所有集合对应相同，且质数集合的相对顺序相同。\n\n现在给定 $n,p$ 和 $V_i$，请你求出所有合法的不同划分方案的价值之和。\n\n结果对 $10^9+7$ 取模，除法请使用乘法逆元。", "inputFormat": "第一行输入两个正整数 $n,p$。\n\n第二行输入 $n$ 个正整数 $V_i$。", "outputFormat": "共一行一个非负整数，代表答案对 $10^9+7$ 取模的结果。", "hint": "### 样例解释\n\n有以下 $6$ 种划分方案:\n\n1. $(2,3)$ 和 $(1,4)$。$(2,3)$ 的价值为 ${\\dfrac 5 6}$，$(1,4)$ 的价值为 $10$，总价值为 ${\\dfrac {25} 3}$。\n2. $(2),(3)$ 和 $(1,4)$。$(2)$ 的价值为 $1$，$(3)$ 的价值为 ${\\dfrac 1 2}$，$(1,4)$ 的价值为 $10$，总价值为 $5$。\n3. $(3),(2)$ 和 $(1,4)$。$(3)$ 的价值为 $1$，$(2)$ 的价值为 ${\\dfrac 1 3}$，$(1,4)$ 的价值为 $10$，总价值为 ${\\dfrac {10} 3}$。\n4. $(2,3)$ 和 $(1),(4)$。$(2,3)$ 的价值为 ${\\dfrac 5 6}$，$(1)$ 的价值为 $1$，$(4)$ 的价值为 $4$，总价值为 ${\\dfrac {10} 3}$。\n5. $(2),(3)$ 和 $(1),(4)$。$(2)$ 的价值为 $1$，$(3)$ 的价值为 ${\\dfrac 1 2}$，$(1)$ 的价值为 $1$，$(4)$ 的价值为 $4$，总价值为 $2$。\n6. $(3),(2)$ 和 $(1),(4)$。$(3)$ 的价值为 $1$，$(2)$ 的价值为 ${\\dfrac 1 3}$，$(1)$ 的价值为 $1$，$(4)$ 的价值为 $4$，总价值为 ${\\dfrac 4 3}$。\n\n因此所有划分方案的价值和为${\\dfrac {70} 3}$。对 $10^9+7$ 取模后结果为 $333333359$。\n\n### 数据范围\n\n对于 $100\\%$ 的数据，满足 $1\\le n\\le 70$，$1\\le V_i\\le 10^{12}$。\n\n下表中给出了每个测试点具体的数据范围，都表示小于等于。为了防止卡 OJ，所以本题数据组数进行压缩，分值改变，具体参照表格。\n\n| 数据编号 |  n   |  p   |  Vi   | 测试点分值 | 时限 |\n| :------: | :--: | :--: | :---: | :--------: | :--: |\n|    1     |  10  |  1   |  100  |     10     |  1s  |\n|    2     |  20  |  1   | 1000  |     10     |  1s  |\n|    3     |  30  |  1   | 10000 |     10     |  1s  |\n|    4     |  40  | 1e9  | 1e12  |     10     |  1s  |\n|    5     |  50  |  1   | 1e12  |     5      |  1s  |\n|    6     |  50  | 1e9  | 1e12  |     5      |  1s  |\n|    7     |  60  |  1   | 1e12  |     5      |  2s  |\n|    8     |  60  | 1e9  | 1e12  |     5      |  2s  |\n|    9     |  70  | 1e9  | 1e12  |     20     |  10s  |\n|    10    |  70  | 1e9  | 1e12  |     20     |  5s  |\n\n提示：大家不要太过相信自己的常数，尽量做好常数优化。", "locale": "zh-CN", "translations": {"en": {"title": "Cute #10 Number Partition", "background": "Princess Fu, who is super cute qwq, has $n$ numbers, $1 \\sim n$. Each number has a value $V_i$, and you need to partition them into several sets so that each number belongs to exactly one set.", "description": "We stipulate:\n\n1. A prime number can only be placed in the same set with prime numbers.\n2. A composite number can only be placed in the same set with composite numbers ($1$ is considered composite).\n3. Let the union of all prime-number sets be $U$ (i.e., the union of all prime-number sets including $S$). For each prime-number set $S$, define its value as:\n$$V_S=\\frac {(\\sum_{i\\in S}V_i)^p} {\\prod_{i\\in U}V_i}.$$\n\n4. For each composite-number set $S$, define its value as follows:\n\nLet $k=|S|$. Use these $k$ numbers as the weights of $k$ edges to connect $k+1$ vertices, forming a tree. For a permutation $P(1 \\sim k+1)$, the value is:\n$$V_P=\\sum_{i=1}^{k} f(P_i,P_{i+1}),$$\nwhere $f(u,v)$ is the maximum edge weight on the path $(u,v)$.\n\nThe value of the set $S$ is:\n$$V_S=E(\\min\\{V_P\\})\\times|S|,$$\nwhere $E(X)$ denotes the mathematical expectation of $X$ over all possible labeled unrooted trees, and the $\\min$ is taken over all possible $P$. Here, all elements in the set are distinct, i.e., all edges are distinct.\n\n5. The value of a partition scheme is defined as the product of the values of all sets.\n6. Two partition schemes are the same if and only if their sets correspond exactly and the relative order of the prime-number sets is the same.\n\nNow, given $n, p$ and $V_i$, please compute the sum of values over all valid and distinct partition schemes.\n\nTake the result modulo $10^9+7$. For division, please use multiplicative inverses.", "inputFormat": "The first line contains two positive integers $n, p$.\n\nThe second line contains $n$ positive integers $V_i$.", "outputFormat": "Output a single non-negative integer: the answer modulo $10^9+7$.", "hint": "Sample Explanation\n\nThere are the following $6$ partition schemes:\n\n1. $(2,3)$ and $(1,4)$. The value of $(2,3)$ is ${\\dfrac 5 6}$, the value of $(1,4)$ is $10$, and the total value is ${\\dfrac {25} 3}$.\n2. $(2),(3)$ and $(1,4)$. The value of $(2)$ is $1$, the value of $(3)$ is ${\\dfrac 1 2}$, the value of $(1,4)$ is $10$, and the total value is $5$.\n3. $(3),(2)$ and $(1,4)$. The value of $(3)$ is $1$, the value of $(2)$ is ${\\dfrac 1 3}$, the value of $(1,4)$ is $10$, and the total value is ${\\dfrac {10} 3}$.\n4. $(2,3)$ and $(1),(4)$. The value of $(2,3)$ is ${\\dfrac 5 6}$, the value of $(1)$ is $1$, the value of $(4)$ is $4$, and the total value is ${\\dfrac {10} 3}$.\n5. $(2),(3)$ and $(1),(4)$. The value of $(2)$ is $1$, the value of $(3)$ is ${\\dfrac 1 2}$, the value of $(1)$ is $1$, the value of $(4)$ is $4$, and the total value is $2$.\n6. $(3),(2)$ and $(1),(4)$. The value of $(3)$ is $1$, the value of $(2)$ is ${\\dfrac 1 3}$, the value of $(1)$ is $1$, the value of $(4)$ is $4$, and the total value is ${\\dfrac 4 3}$.\n\nTherefore, the sum of values over all partition schemes is ${\\dfrac {70} 3}$. After taking modulo $10^9+7$, the result is $333333359$.\n\nConstraints\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 70$, $1 \\le V_i \\le 10^{12}$.\n\nThe table below gives the specific constraints for each test point (all are upper bounds). To prevent stressing the OJ, the testdata is compressed and the scores are adjusted; see the table for details.\n\n| Data ID |  n   |  p   |  V_i  | Score per test point | Time limit |\n| :-----: | :--: | :--: | :---: | :-------------------: | :--------: |\n|    1    |  10  |  1   |  100  |          10           |    1 s     |\n|    2    |  20  |  1   | 1000  |          10           |    1 s     |\n|    3    |  30  |  1   | 10000 |          10           |    1 s     |\n|    4    |  40  | 1e9  | 1e12  |          10           |    1 s     |\n|    5    |  50  |  1   | 1e12  |           5           |    1 s     |\n|    6    |  50  | 1e9  | 1e12  |           5           |    1 s     |\n|    7    |  60  |  1   | 1e12  |           5           |    2 s     |\n|    8    |  60  | 1e9  | 1e12  |           5           |    2 s     |\n|    9    |  70  | 1e9  | 1e12  |          20           |   10 s     |\n|   10    |  70  | 1e9  | 1e12  |          20           |    5 s     |\n\nTip: Do not be overly optimistic about constant factors; try to optimize them.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "可爱の#10数字划分", "background": "可可可可可可爱的付公主 qwq 有 $n$ 个数，$1\\sim n$，每个数都有价值 $V_i$，你要将它们划分成若干个集合，每个数属于一个集合。", "description": "我们这里规定:\n\n1. 质数只能和质数分在同一个集合。  \n2. 合数只能和合数分在同一个集合（$1$ 也算在合数内）。   \n3. 我们假设目前所有质数集合的并集为 $U$（也就是之前所有质数集合以及 $S$ 的并集），每个质数集合 $S$ 的价值定义如下：  \n$$V_S=\\frac {(\\sum_{i\\in S}V_i)^p} {\\prod_{i\\in U}V_i}$$\n\n4. 我们定义每个合数集合 $S$ 的价值如下:\n\n令 $k=|S|$，我们用这 $k$ 个数分别作为 $k$ 条边的权值，连接 $k+1$ 个点，构成一棵树。对于一个排列 $P(1\\sim k+1)$，价值为：\n\n$$V_P=\\sum_{i=1}^{n-1} f(P_i,P_{i+1})$$\n\n其中 $f(u,v)$ 为路径 $(u,v)$ 上最大的边权。\n\n集合 $S$ 的价值为：\n\n$$V_S=E(\\min\\{V_P\\})\\times|S|$$\n\n其中 $E(X)$ 代表 $X$ 的数学期望，期望是针对所有可能的有标号无根树，$\\min$ 是针对所有可能的 $P$。这时集合内所有元素都不同，也就是所有边不同。\n\n5. 一个划分方案的价值定义为所有集合的价值的乘积。\n6. 两个划分方案相同当且仅当它们中所有集合对应相同，且质数集合的相对顺序相同。\n\n现在给定 $n,p$ 和 $V_i$，请你求出所有合法的不同划分方案的价值之和。\n\n结果对 $10^9+7$ 取模，除法请使用乘法逆元。", "inputFormat": "第一行输入两个正整数 $n,p$。\n\n第二行输入 $n$ 个正整数 $V_i$。", "outputFormat": "共一行一个非负整数，代表答案对 $10^9+7$ 取模的结果。", "hint": "### 样例解释\n\n有以下 $6$ 种划分方案:\n\n1. $(2,3)$ 和 $(1,4)$。$(2,3)$ 的价值为 ${\\dfrac 5 6}$，$(1,4)$ 的价值为 $10$，总价值为 ${\\dfrac {25} 3}$。\n2. $(2),(3)$ 和 $(1,4)$。$(2)$ 的价值为 $1$，$(3)$ 的价值为 ${\\dfrac 1 2}$，$(1,4)$ 的价值为 $10$，总价值为 $5$。\n3. $(3),(2)$ 和 $(1,4)$。$(3)$ 的价值为 $1$，$(2)$ 的价值为 ${\\dfrac 1 3}$，$(1,4)$ 的价值为 $10$，总价值为 ${\\dfrac {10} 3}$。\n4. $(2,3)$ 和 $(1),(4)$。$(2,3)$ 的价值为 ${\\dfrac 5 6}$，$(1)$ 的价值为 $1$，$(4)$ 的价值为 $4$，总价值为 ${\\dfrac {10} 3}$。\n5. $(2),(3)$ 和 $(1),(4)$。$(2)$ 的价值为 $1$，$(3)$ 的价值为 ${\\dfrac 1 2}$，$(1)$ 的价值为 $1$，$(4)$ 的价值为 $4$，总价值为 $2$。\n6. $(3),(2)$ 和 $(1),(4)$。$(3)$ 的价值为 $1$，$(2)$ 的价值为 ${\\dfrac 1 3}$，$(1)$ 的价值为 $1$，$(4)$ 的价值为 $4$，总价值为 ${\\dfrac 4 3}$。\n\n因此所有划分方案的价值和为${\\dfrac {70} 3}$。对 $10^9+7$ 取模后结果为 $333333359$。\n\n### 数据范围\n\n对于 $100\\%$ 的数据，满足 $1\\le n\\le 70$，$1\\le V_i\\le 10^{12}$。\n\n下表中给出了每个测试点具体的数据范围，都表示小于等于。为了防止卡 OJ，所以本题数据组数进行压缩，分值改变，具体参照表格。\n\n| 数据编号 |  n   |  p   |  Vi   | 测试点分值 | 时限 |\n| :------: | :--: | :--: | :---: | :--------: | :--: |\n|    1     |  10  |  1   |  100  |     10     |  1s  |\n|    2     |  20  |  1   | 1000  |     10     |  1s  |\n|    3     |  30  |  1   | 10000 |     10     |  1s  |\n|    4     |  40  | 1e9  | 1e12  |     10     |  1s  |\n|    5     |  50  |  1   | 1e12  |     5      |  1s  |\n|    6     |  50  | 1e9  | 1e12  |     5      |  1s  |\n|    7     |  60  |  1   | 1e12  |     5      |  2s  |\n|    8     |  60  | 1e9  | 1e12  |     5      |  2s  |\n|    9     |  70  | 1e9  | 1e12  |     20     |  10s  |\n|    10    |  70  | 1e9  | 1e12  |     20     |  5s  |\n\n提示：大家不要太过相信自己的常数，尽量做好常数优化。", "locale": "zh-CN"}}}
{"pid": "P4258", "type": "P", "difficulty": 6, "samples": [["1\n4 3 6\n1 1\n2 1\n2 2\n3 2\n3 3\n4 3", "2\n1 2 3 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2016", "Special Judge", "图论建模", "一般图的最大匹配", "WC"], "title": "[WC2016] 挑战NPC", "background": "", "description": "小 N 最近在研究 NP 完全问题，小 O 看小 N 研究得热火朝天，便给他出了一道这样的题目：\n\n有 $n$ 个球，用整数 $1$ 到 $n$ 编号。还有 $m$ 个筐子，用整数 $1$ 到 $m$ 编号。每个筐子最多能装 $3$ 个球。\n\n每个球只能放进特定的筐子中。 具体有 $e$ 个条件，第 $i$ 个条件用两个整数\n$v_i$ 和 $u_i$ 描述，表示编号为 $v_i$ 的球可以放进编号为 $u_i$ 的筐子中。\n\n每个球都必须放进一个筐子中。如果一个筐子内有不超过 $1$ 个球，那么我们称这样的筐子为半空的。\n\n求半空的筐子最多有多少个，以及在最优方案中， 每个球分别放在哪个筐子中。\n\n小 N 看到题目后瞬间没了思路，站在旁边看热闹的小 I 嘿嘿一笑：“水题！”\n然后三言两语道出了一个多项式算法。\n\n小 N 瞬间就惊呆了，三秒钟后他回过神来一拍桌子：“不对！这个问题显然是 NP 完全问题，你算法肯定有错！”\n\n小 I 浅笑：“所以，等我领图灵奖吧！”\n\n小 O 只会出题不会做题，所以找到了你——请你对这个问题进行探究，并写一个程序解决此题。", "inputFormat": "输入文件 $\\tt{npc.in}$ 第一行包含 $1$ 个正整数 $T$， 表示有 $T$ 组数据。\n\n对于每组数据，第一行包含 $3$ 个正整数 $n, m, e$， 表示球的个数，筐子的个数和条件的个数。\n\n接下来 $e$ 行，每行包含 $2$ 个整数 $v_i, u_i$， 表示编号为 $v_i$ 的球可以放进编号为 $u_i$ 的筐子。", "outputFormat": "输出文件为 $\\tt{npc.out}$。\n\n对于每组数据，先输出一行，包含一个整数，表示半空的筐子最多有多少个。\n\n然后再输出一行，包含 $n$ 个整数 $p_1, p_2, ... , p_n$，相邻整数之间用空格隔开，表示一种最优解。其中 $p_i$ 表示编号为 $i$ 的球放进了编号为 $p_i$ 的筐子。 如果有多种最优解，可以输出其中任何一种。", "hint": "对于所有数据， $T \\leq 5, 1 \\leq n \\leq 3m$。 保证 $1 \\leq v_i \\leq n, 1 \\leq u_i \\leq m$，且不会出现重复的条件。\n\n保证至少有一种合法方案，使得每个球都放进了筐子，且每个筐子内球的个\n数不超过 $3$。\n\n各测试点满足以下约定：\n\n::cute-table{tuack}\n\n|测试点|$ m $     |约定        |\n|:-:|:--------:|:--------:|\n|1  |$\\leq 10$ |$n \\leq 20, e \\leq 25$|\n|2  |^         |^         |\n|3  |$\\leq 100$|$e=nm$    |\n|4  |^         |存在方案使得有 $m$ 个半空的筐子|\n|5  |^         |不存在有半空的筐子的方案|\n|6  |^         |^         |\n|7  |^         |无        |\n|8  |^         |^         |\n|9  |^         |^         |\n|10 |^         |^         |", "locale": "zh-CN", "translations": {"en": {"title": "[WC2016] Challenge NPC", "background": "", "description": "Little N has recently been studying NP-complete problems. Seeing him so absorbed, Little O gave him such a problem:\n\nThere are $n$ balls, numbered from $1$ to $n$. There are also $m$ baskets, numbered from $1$ to $m$. Each basket can hold at most $3$ balls.\n\nEach ball can only be placed into specific baskets. Specifically, there are $e$ constraints. The $i$-th constraint is described by two integers $v_i$ and $u_i$, meaning that ball $v_i$ can be placed into basket $u_i$.\n\nEvery ball must be placed into some basket. If a basket contains at most $1$ ball, we call such a basket half-empty.\n\nFind the maximum possible number of half-empty baskets, and in an optimal arrangement, determine which basket each ball is placed into.\n\nLittle N was stunned and lost his train of thought. Little I, watching from the side, chuckled, “Easy problem!” Then, with a few words, he described a polynomial-time algorithm.\n\nLittle N was shocked. Three seconds later, he slapped the table: “No way! This problem is clearly NP-complete. Your algorithm must be wrong!”\n\nLittle I smiled slightly: “Then I’ll wait for my Turing Award!”\n\nLittle O can make problems but not solve them, so he turned to you—please investigate this problem and write a program to solve it.", "inputFormat": "In the input file $\\tt{npc.in}$, the first line contains a single positive integer $T$, indicating there are $T$ test cases.\n\nFor each test case, the first line contains three positive integers $n$, $m$, $e$, representing the number of balls, the number of baskets, and the number of constraints.\n\nThe next $e$ lines each contain two integers $v_i$, $u_i$, indicating that ball $v_i$ can be placed into basket $u_i$.", "outputFormat": "The output file is $\\tt{npc.out}$.\n\nFor each test case, first output one line containing a single integer, the maximum possible number of half-empty baskets.\n\nThen output one more line containing $n$ integers $p_1, p_2, ... , p_n$, separated by spaces, describing one optimal arrangement. Here $p_i$ indicates that ball $i$ is placed into basket $p_i$. If there are multiple optimal solutions, any one of them may be printed.", "hint": "For all testdata, $T \\leq 5$, $1 \\leq n \\leq 3 m$. It is guaranteed that $1 \\leq v_i \\leq n$, $1 \\leq u_i \\leq m$, and there are no duplicate constraints.\n\nIt is guaranteed that there exists at least one feasible solution in which every ball is placed into a basket and the number of balls in each basket does not exceed $3$.\n\nEach test point satisfies the following conventions:\n::cute-table{tuack}\n|Test point|$ m $     |Notes        |\n|:-:|:--------:|:--------:|\n|1  |$\\leq 10$ |$n \\leq 20, e \\leq 25$|\n|2  |^         |^         |\n|3  |$\\leq 100$|$e = n m$ |\n|4  |^         |There exists a solution with $m$ half-empty baskets.|\n|5  |^         |No solution has any half-empty basket.|\n|6  |^         |^         |\n|7  |^         |None      |\n|8  |^         |^         |\n|9  |^         |^         |\n|10 |^         |^         |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2016] 挑战NPC", "background": "", "description": "小 N 最近在研究 NP 完全问题，小 O 看小 N 研究得热火朝天，便给他出了一道这样的题目：\n\n有 $n$ 个球，用整数 $1$ 到 $n$ 编号。还有 $m$ 个筐子，用整数 $1$ 到 $m$ 编号。每个筐子最多能装 $3$ 个球。\n\n每个球只能放进特定的筐子中。 具体有 $e$ 个条件，第 $i$ 个条件用两个整数\n$v_i$ 和 $u_i$ 描述，表示编号为 $v_i$ 的球可以放进编号为 $u_i$ 的筐子中。\n\n每个球都必须放进一个筐子中。如果一个筐子内有不超过 $1$ 个球，那么我们称这样的筐子为半空的。\n\n求半空的筐子最多有多少个，以及在最优方案中， 每个球分别放在哪个筐子中。\n\n小 N 看到题目后瞬间没了思路，站在旁边看热闹的小 I 嘿嘿一笑：“水题！”\n然后三言两语道出了一个多项式算法。\n\n小 N 瞬间就惊呆了，三秒钟后他回过神来一拍桌子：“不对！这个问题显然是 NP 完全问题，你算法肯定有错！”\n\n小 I 浅笑：“所以，等我领图灵奖吧！”\n\n小 O 只会出题不会做题，所以找到了你——请你对这个问题进行探究，并写一个程序解决此题。", "inputFormat": "输入文件 $\\tt{npc.in}$ 第一行包含 $1$ 个正整数 $T$， 表示有 $T$ 组数据。\n\n对于每组数据，第一行包含 $3$ 个正整数 $n, m, e$， 表示球的个数，筐子的个数和条件的个数。\n\n接下来 $e$ 行，每行包含 $2$ 个整数 $v_i, u_i$， 表示编号为 $v_i$ 的球可以放进编号为 $u_i$ 的筐子。", "outputFormat": "输出文件为 $\\tt{npc.out}$。\n\n对于每组数据，先输出一行，包含一个整数，表示半空的筐子最多有多少个。\n\n然后再输出一行，包含 $n$ 个整数 $p_1, p_2, ... , p_n$，相邻整数之间用空格隔开，表示一种最优解。其中 $p_i$ 表示编号为 $i$ 的球放进了编号为 $p_i$ 的筐子。 如果有多种最优解，可以输出其中任何一种。", "hint": "对于所有数据， $T \\leq 5, 1 \\leq n \\leq 3m$。 保证 $1 \\leq v_i \\leq n, 1 \\leq u_i \\leq m$，且不会出现重复的条件。\n\n保证至少有一种合法方案，使得每个球都放进了筐子，且每个筐子内球的个\n数不超过 $3$。\n\n各测试点满足以下约定：\n\n::cute-table{tuack}\n\n|测试点|$ m $     |约定        |\n|:-:|:--------:|:--------:|\n|1  |$\\leq 10$ |$n \\leq 20, e \\leq 25$|\n|2  |^         |^         |\n|3  |$\\leq 100$|$e=nm$    |\n|4  |^         |存在方案使得有 $m$ 个半空的筐子|\n|5  |^         |不存在有半空的筐子的方案|\n|6  |^         |^         |\n|7  |^         |无        |\n|8  |^         |^         |\n|9  |^         |^         |\n|10 |^         |^         |", "locale": "zh-CN"}}}
{"pid": "P4259", "type": "P", "difficulty": 6, "samples": [["5 4 10\n1 1 1 0\n1 1 1 1\n1 1 0 1\n1 0 1 0\n1 1 0 0\n1 1 1 5 4\n1 3 1 3 1\n1 3 3 3 3\n1 2 3 5 3\n0 2 2\n1 1 4 2 4\n1 1 3 3 3\n0 5 1\n1 2 3 2 4\n1 1 2 2 4\n", "2\n1\n0\n1\n1\n1\n1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["线段树", "单调队列", "枚举", "Code+"], "title": "[Code+#3] 寻找车位", "background": null, "description": "access_globe 有一个巨大的停车场，这个停车场有 $n$ 行，每行有 $m$ 个车位。为了美观，access_globe 在建立这个停车场时，规定这个停车场必须是长条形的，即 $n\\ge m$。每个车位都是一个正方形的区域。\n\n最近，access_globe 正在为抽不到 Missing Poster 而苦恼，因此他请你帮他维护这个停车场。你需要支持两个个事件：\n\n- 一辆车停到某一个车位中，或一辆车从某个车位开走\n- 查询一个矩形区域内最大的只包含空车位的正方形区域\n\n如果你能帮 access_globe 高效地解决这个问题，access_globe 一定会好好奖励你的。", "inputFormat": "第一行包含三个正整数 $n$、$m$、$q$，表示停车场的大小和事件的个数；\n\n接下来 $n$ 行，每行 $m$ 个 0 或 1 的数，如果第 $i$ 行第 $j$ 的数**为 $1$**，则表示第 $i$ 行第 $j$ 列的车位**为空**，否则表示这个车位**非空**；\n\n接下来 $q$ 行，每行表示一个事件，有以下两种形式：\n\n- $0$ $x$ $y$ ：第 $x$ 行第 $y$ 列的车位的停车情况改变，即若此事件发生前这个车位为空，则此事件后这个车位非空，否则此事件后这个车位为空，保证 $1\\le x\\le n$，$1\\le y\\le m$\n- $1$ $l$ $s$ $r$ $t$：询问以 $(l, s)$ 和 $(r,t)$ 为对角的矩形区域中，最大的全空正方形区域的边长，保证 $1\\le l\\le r\\le n$，$1\\le s\\le t\\le m$", "outputFormat": "对每个询问输出一行一个整数，表示该询问的全空正方形的边长。", "hint": "| 子任务编号 | $n,m$ 的额外限制 | $q$ 的额外限制 | 修改操作 | 是否保证 $s=1,t=m$ |\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$n,m \\le 500$|$q \\le 500$|存在|否|\n|$2$|$m \\le 10$|无|保证不存在|是|\n|$3$|^|^|存在|^|\n|$4$|$n \\le 400000$|^|保证不存在|^|\n|$5$|^|^|存在|^|\n|$6$|$m \\le 10$|^|保证不存在|否|\n|$7$|^|^|存在|^|\n|$8$|$n \\le 400000$|^|保证不存在|^|\n|$9$|^|^|存在|^|\n|$10$|无|^|^|^|\n\n所有子任务的分值均等分布。\n\n对于所有数据，保证 $n\\times m\\le4\\times 10^6$，$q\\le 2000$。\n\nCredit：https://www.luogu.org/discuss/show?postid=35727", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#3] Finding Parking Spaces", "background": "", "description": "access_globe has a huge parking lot with $n$ rows and $m$ spaces per row. For aesthetics, when building this parking lot, access_globe stipulated that it must be strip-shaped, i.e., $n\\ge m$. Each parking space is a square area.\n\nRecently, access_globe has been distressed about not being able to draw \"Missing Poster\", so he asks you to help maintain this parking lot. You need to support two types of events:\n- A car parks in a certain space, or a car leaves a certain space.\n- Query, within a rectangular region, the largest square region consisting only of empty spaces.\n\nIf you can help access_globe solve this efficiently, access_globe will reward you well.", "inputFormat": "The first line contains three positive integers $n$, $m$, and $q$, denoting the size of the parking lot and the number of events.\n\nThe next $n$ lines each contain $m$ numbers, either $0$ or $1$. If the number at row $i$, column $j$ is $1$, then the space at row $i$, column $j$ is empty; otherwise, that space is non-empty.\n\nThe next $q$ lines each describe an event in one of the following two forms:\n- $0$ $x$ $y$: The occupancy status of the space at row $x$, column $y$ toggles. That is, if this space was empty before this event, it becomes non-empty after the event; otherwise, it becomes empty. It is guaranteed that $1\\le x\\le n$, $1\\le y\\le m$.\n- $1$ $l$ $s$ $r$ $t$: Query the side length of the largest all-empty square region within the rectangle with opposite corners $(l, s)$ and $(r, t)$. It is guaranteed that $1\\le l\\le r\\le n$, $1\\le s\\le t\\le m$.", "outputFormat": "For each query, output one integer on its own line, representing the side length of the largest all-empty square for that query.", "hint": "| Subtask ID | Extra constraints on $n, m$ | Extra constraints on $q$ | Update operations | Whether guaranteed that $s=1, t=m$ |\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$n,m \\le 500$|$q \\le 500$|Present|No|\n|$2$|$m \\le 10$|None|Guaranteed absent|Yes|\n|$3$|^|^|Present|^|\n|$4$|$n \\le 400000$|^|Guaranteed absent|^|\n|$5$|^|^|Present|^|\n|$6$|$m \\le 10$|^|Guaranteed absent|No|\n|$7$|^|^|Present|^|\n|$8$|$n \\le 400000$|^|Guaranteed absent|^|\n|$9$|^|^|Present|^|\n|$10$|None|^|^|^|\n\nAll subtasks are evenly weighted.\n\nFor all testdata, it is guaranteed that $n\\times m\\le 4\\times 10^6$, $q\\le 2000$.\n\nCredit: https://www.luogu.org/discuss/show?postid=35727\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#3] 寻找车位", "background": null, "description": "access_globe 有一个巨大的停车场，这个停车场有 $n$ 行，每行有 $m$ 个车位。为了美观，access_globe 在建立这个停车场时，规定这个停车场必须是长条形的，即 $n\\ge m$。每个车位都是一个正方形的区域。\n\n最近，access_globe 正在为抽不到 Missing Poster 而苦恼，因此他请你帮他维护这个停车场。你需要支持两个个事件：\n\n- 一辆车停到某一个车位中，或一辆车从某个车位开走\n- 查询一个矩形区域内最大的只包含空车位的正方形区域\n\n如果你能帮 access_globe 高效地解决这个问题，access_globe 一定会好好奖励你的。", "inputFormat": "第一行包含三个正整数 $n$、$m$、$q$，表示停车场的大小和事件的个数；\n\n接下来 $n$ 行，每行 $m$ 个 0 或 1 的数，如果第 $i$ 行第 $j$ 的数**为 $1$**，则表示第 $i$ 行第 $j$ 列的车位**为空**，否则表示这个车位**非空**；\n\n接下来 $q$ 行，每行表示一个事件，有以下两种形式：\n\n- $0$ $x$ $y$ ：第 $x$ 行第 $y$ 列的车位的停车情况改变，即若此事件发生前这个车位为空，则此事件后这个车位非空，否则此事件后这个车位为空，保证 $1\\le x\\le n$，$1\\le y\\le m$\n- $1$ $l$ $s$ $r$ $t$：询问以 $(l, s)$ 和 $(r,t)$ 为对角的矩形区域中，最大的全空正方形区域的边长，保证 $1\\le l\\le r\\le n$，$1\\le s\\le t\\le m$", "outputFormat": "对每个询问输出一行一个整数，表示该询问的全空正方形的边长。", "hint": "| 子任务编号 | $n,m$ 的额外限制 | $q$ 的额外限制 | 修改操作 | 是否保证 $s=1,t=m$ |\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$n,m \\le 500$|$q \\le 500$|存在|否|\n|$2$|$m \\le 10$|无|保证不存在|是|\n|$3$|^|^|存在|^|\n|$4$|$n \\le 400000$|^|保证不存在|^|\n|$5$|^|^|存在|^|\n|$6$|$m \\le 10$|^|保证不存在|否|\n|$7$|^|^|存在|^|\n|$8$|$n \\le 400000$|^|保证不存在|^|\n|$9$|^|^|存在|^|\n|$10$|无|^|^|^|\n\n所有子任务的分值均等分布。\n\n对于所有数据，保证 $n\\times m\\le4\\times 10^6$，$q\\le 2000$。\n\nCredit：https://www.luogu.org/discuss/show?postid=35727", "locale": "zh-CN"}}}
{"pid": "P4260", "type": "P", "difficulty": 7, "samples": [["3 500\n1 1\n2 3\n4 4", "500000004\n200000002\n728571435"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["Code+"], "title": "[Code+#3] 博弈论与概率统计", "background": "", "description": "Alice 和 Bob 在玩一个双人游戏。每一轮中，Alice 有 $p$ 的概率胜利，$1-p$ 的概率失败，不会出现平局。\n\n双方初始时各有 $0$ 分，当一个人胜利的时候，他会获得一分，失败则扣掉一分。遗憾的是，博弈论世界的人目前是无法理解负数的，因此，如果某个人输掉一轮比赛的时候他只有 $0$ 分，那么他就不会被扣分（对方会照常加一分）。游戏一共要进行 $N+M$ 轮，Alice 想请你帮她算算在游戏结束时她的得分的数学期望。\n\n“这算啥，我小 L 分分钟搞定！”。比小 L 更熟练的你当然也是随手就算出来了，但就在你打算告诉 Alice 答案之前，博弈论世界之神——temporaryDO 出现了，他给大家带来了一个重要信息：这 $N+M$ 轮游戏中， Alice 恰好赢了 $N$ 轮！\n\n熟知条件概率那套理论的你**立刻**注意到，你需要修改自己的计算方法来得到正确的答案了。\n\n为了避免精度问题，请将结果对 $10^9+7$ 取模。即，我们的数据保证答案是一个有理数 $\\frac{p}{q}$，且有 $10^9+7\\nmid q$，你只需要找到一个整数 $x\\in [0, 10^9+7)$ 使得 $qx\\equiv p\\pmod{10^9+7}$ 即可。\n\n", "inputFormat": "输入的第一行包含两个正整数 $T$, $P'$，其中 $T$ 表示数据组数，$\\frac{P'}{1000}$ 表示 $p$ ，即 Alice 在每轮游戏中的获胜概率。\n\n接下来 $T$ 行，每行两个非负整数 $N,M$，表示一组数据。\n", "outputFormat": "输出 $T$ 行，每行一个整数，表示对应数据的答案。", "hint": "每一轮游戏 Alice 均有 $\\frac{1}{2}$ 的概率胜利。\n\n* 对于第一组数据，Alice 的胜利可能在第一轮或第二轮，并且概率相等。若她在第一轮胜利，则最终得分为 $0$，否则她的得分为 $1$。故期望为 $\\frac{1}{2}$，验证发现 $2\\times 500000004\\equiv 1\\pmod{10^9+7}$。\n* 对于第二组数据，所求期望为 $\\frac{3}{5}$。\n* 对于第三组数据，所求期望为 $\\frac{93}{70}$。\n\n【数据范围与约定】\n1. 对于 10% 的数据，$N,M,T\\le 50$ 。\n2. 对于另外 20% 的数据，$N,M,T\\le 2000$ 。\n3. 对于另外 20% 的数据，$N,M\\le 10^5$，$|N-M|\\le 200$，$T\\le 2\\times 10^5$ 。\n4. 对于另外 20% 的数据，$N,M,T\\le 5\\times 10^4$ 。\n5. 对于 100% 的数据，$N+M,T\\le 2.5\\times 10^5$， $0 < P' < 1000$ 。\n\nCredit：https://www.luogu.org/discuss/show?postid=35727", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#3] Game Theory and Probability", "background": "", "description": "Alice and Bob are playing a two-player game. In each round, Alice wins with probability $p$ and loses with probability $1-p$, and no tie occurs.\n\nBoth players start with $0$ points. When a player wins, they gain $1$ point; when a player loses, they lose $1$ point. Unfortunately, people in the world of game theory cannot comprehend negative numbers. Therefore, if someone loses a round while they have $0$ points, they will not be deducted any points (the opponent still gains $1$ point as usual). The game consists of $N+M$ rounds in total. Alice asks you to compute the expected value of her score at the end of the game.\n\n“This is nothing. I, little L, can do it in a minute!” You, being even more skilled than little L, also get the answer easily. But just as you are about to tell Alice the answer, the god of the game theory world—temporaryDO—appears and brings an important piece of information: among these $N+M$ rounds, Alice wins exactly $N$ rounds!\n\nBeing familiar with conditional probability, you immediately realize that you need to adjust your computation to obtain the correct answer.\n\nTo avoid precision issues, please output the result modulo $10^9+7$. That is, our testdata guarantees that the answer is a rational number $\\frac{p}{q}$ with $10^9+7 \\nmid q$. You only need to find an integer $x \\in [0, 10^9+7)$ such that $q x \\equiv p \\pmod{10^9+7}$.", "inputFormat": "The first line contains two positive integers $T$, $P'$, where $T$ is the number of test cases, and $\\frac{P'}{1000}$ equals $p$, i.e., Alice’s probability of winning each round.\n\nThen follow $T$ lines. Each line contains two nonnegative integers $N, M$, representing one test case.", "outputFormat": "Output $T$ lines, each containing one integer, which is the answer for the corresponding test case.", "hint": "In each round, Alice has probability $\\frac{1}{2}$ to win.\n\n- For the first test case, Alice’s win may occur in the first or second round, with equal probability. If she wins in the first round, her final score is $0$; otherwise, her score is $1$. Hence the expectation is $\\frac{1}{2}$. Verification: $2 \\times 500000004 \\equiv 1 \\pmod{10^9+7}$.\n- For the second test case, the expected value is $\\frac{3}{5}$.\n- For the third test case, the expected value is $\\frac{93}{70}$.\n\nConstraints and Conventions\n1. For 10% of the testdata, $N, M, T \\le 50$.\n2. For an additional 20% of the testdata, $N, M, T \\le 2000$.\n3. For an additional 20% of the testdata, $N, M \\le 10^5$, $|N-M| \\le 200$, $T \\le 2 \\times 10^5$.\n4. For an additional 20% of the testdata, $N, M, T \\le 5 \\times 10^4$.\n5. For 100% of the testdata, $N+M, T \\le 2.5 \\times 10^5$, $0 < P' < 1000$.\n\nCredit: https://www.luogu.org/discuss/show?postid=35727\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#3] 博弈论与概率统计", "background": "", "description": "Alice 和 Bob 在玩一个双人游戏。每一轮中，Alice 有 $p$ 的概率胜利，$1-p$ 的概率失败，不会出现平局。\n\n双方初始时各有 $0$ 分，当一个人胜利的时候，他会获得一分，失败则扣掉一分。遗憾的是，博弈论世界的人目前是无法理解负数的，因此，如果某个人输掉一轮比赛的时候他只有 $0$ 分，那么他就不会被扣分（对方会照常加一分）。游戏一共要进行 $N+M$ 轮，Alice 想请你帮她算算在游戏结束时她的得分的数学期望。\n\n“这算啥，我小 L 分分钟搞定！”。比小 L 更熟练的你当然也是随手就算出来了，但就在你打算告诉 Alice 答案之前，博弈论世界之神——temporaryDO 出现了，他给大家带来了一个重要信息：这 $N+M$ 轮游戏中， Alice 恰好赢了 $N$ 轮！\n\n熟知条件概率那套理论的你**立刻**注意到，你需要修改自己的计算方法来得到正确的答案了。\n\n为了避免精度问题，请将结果对 $10^9+7$ 取模。即，我们的数据保证答案是一个有理数 $\\frac{p}{q}$，且有 $10^9+7\\nmid q$，你只需要找到一个整数 $x\\in [0, 10^9+7)$ 使得 $qx\\equiv p\\pmod{10^9+7}$ 即可。\n\n", "inputFormat": "输入的第一行包含两个正整数 $T$, $P'$，其中 $T$ 表示数据组数，$\\frac{P'}{1000}$ 表示 $p$ ，即 Alice 在每轮游戏中的获胜概率。\n\n接下来 $T$ 行，每行两个非负整数 $N,M$，表示一组数据。\n", "outputFormat": "输出 $T$ 行，每行一个整数，表示对应数据的答案。", "hint": "每一轮游戏 Alice 均有 $\\frac{1}{2}$ 的概率胜利。\n\n* 对于第一组数据，Alice 的胜利可能在第一轮或第二轮，并且概率相等。若她在第一轮胜利，则最终得分为 $0$，否则她的得分为 $1$。故期望为 $\\frac{1}{2}$，验证发现 $2\\times 500000004\\equiv 1\\pmod{10^9+7}$。\n* 对于第二组数据，所求期望为 $\\frac{3}{5}$。\n* 对于第三组数据，所求期望为 $\\frac{93}{70}$。\n\n【数据范围与约定】\n1. 对于 10% 的数据，$N,M,T\\le 50$ 。\n2. 对于另外 20% 的数据，$N,M,T\\le 2000$ 。\n3. 对于另外 20% 的数据，$N,M\\le 10^5$，$|N-M|\\le 200$，$T\\le 2\\times 10^5$ 。\n4. 对于另外 20% 的数据，$N,M,T\\le 5\\times 10^4$ 。\n5. 对于 100% 的数据，$N+M,T\\le 2.5\\times 10^5$， $0 < P' < 1000$ 。\n\nCredit：https://www.luogu.org/discuss/show?postid=35727", "locale": "zh-CN"}}}
{"pid": "P4261", "type": "P", "difficulty": 6, "samples": [["3\n1\n0 0 1 1 0\n3\n0 -10 10 10 1\n10 0 10 10 1\n-10 0 10 10 0\n3\n0 10 10 10 1\n10 20 10 10 1\n10 0 10 10 0\n", "1\n2\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["离散化", "枚举", "线段相交", "Code+"], "title": "[Code+#3] 白金元首与克劳德斯", "background": "> 千里白金雪满天　烽火江山起狼烟　分手竟兵刃相见\n\n1941.7.\n\n苏联军队出乎意料的反抗力量、前线德军的补给困难 —— 元首 Adolf 望着天空的云层陷入沉思……", "description": "在 $xy$-直角坐标平面的天空中，有 $n$ 片四边平行于坐标轴的矩形云朵。每一片云由一个五元组 $(x_i, y_i, w_i, h_i, d_i)$ 表示，其中 $(x_i, y_i)$ 为云左下角顶点的坐标，$w_i$ 表示云在 $x$ 轴方向的宽度，$h_i$ 表示云在 $y$ 轴方向的长度，$d_i \\in \\{0, 1\\}$ 为云的移动方向（$0$ 为横向，$1$ 为纵向）。具体来说，满足 $d_i = 0$ 的云沿 $x$ 轴正方向以每秒 $1$ 长度单位的速率不断移动，而满足 $d_i = 1$ 的云沿 $y$ 轴正方向以每秒 $1$ 长度单位的速率不断移动。\n\n元首发现，**所有的云在此时没有重叠的面积**。他将这个时刻记作时刻 $0$。他想知道，对于 $(-\\infty, +\\infty)$ 中的**任意时刻**和平面上的**任意一个点**，最多可以同时被多少片云覆盖。一个点在某时刻被一朵云覆盖当且仅当这个点位于该时刻云朵所处矩形的**内部（不含边界）**。\n\n你需要编写程序帮助元首满足他的好奇心。\n", "inputFormat": "输入的第一行包含一个正整数 $T$ —— 数据的组数。接下来包含 $T$ 组数据，格式如下，数据间没有空行。\n\n* 第 $1$ 行：一个正整数 $n$ —— 云朵的数量。\n* 接下来 $n$ 行：每行五个空格分隔的整数 $x_i$、$y_i$、$w_i$、$h_i$ 和 $d_i$ —— 描述一朵云在时刻 $0$ 的状态。\n", "outputFormat": "对于每组数据输出一行 —— 在任意时刻，覆盖平面上任意一个点的云朵数目的最大值。", "hint": "第 $1$ 组数据中，任意时刻的任意一个点至多被惟一的一片云覆盖。\n\n第 $2$ 组数据中，下图从左至右分别示意时刻 $0$、时刻 $4$、时刻 $11$ 的情形。\n\n![](https://cdn.luogu.com.cn/upload/pic/15106.png)\n\n第 $3$ 组数据中，时刻 $0$ 对应第 $2$ 组数据时刻 $20$ 的情形。在该组数据中，$(-20, 0)$ 内的时刻均有 $2$ 片云覆盖同一个点。请注意考察范围 $(-\\infty, +\\infty)$ 包含时刻 $0$ 之前的时间段。\n\n对于所有数据，有 $1 \\leq T \\leq 15$，$-5\\times 10^8 \\leq x_i, y_i \\leq 5\\times 10^8$，$1 \\leq w_i, h_i \\leq 5\\times 10^8$，$d_i \\in {0, 1}$。\n\n![](https://cdn.luogu.com.cn/upload/pic/15108.png)\n\nCredit：https://www.luogu.org/discuss/show?postid=35727", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#3] The Platinum Führer and Claudius", "background": "> For a thousand li, platinum snow fills the sky; beacon fires rise over the realm; parted, we meet again with blades drawn.\n\n1941.7.\n\nThe unexpected resistance of the Soviet army and the supply difficulties of the German forces at the front — the Führer, Adolf, gazed at the clouds in the sky and fell into deep thought...", "description": "On the $xy$-Cartesian coordinate plane, there are $n$ axis-aligned rectangular clouds. Each cloud is represented by a 5-tuple $(x_i, y_i, w_i, h_i, d_i)$, where $(x_i, y_i)$ is the coordinate of the lower-left corner, $w_i$ is the width along the $x$-axis, $h_i$ is the length along the $y$-axis, and $d_i \\in \\{0, 1\\}$ is the moving direction ($0$ for horizontal, $1$ for vertical). Specifically, a cloud with $d_i = 0$ moves continuously along the positive $x$-axis at a speed of 1 unit length per second, and a cloud with $d_i = 1$ moves continuously along the positive $y$-axis at a speed of 1 unit length per second.\n\nThe Führer observes that all clouds have no overlapping area at this moment. He marks this moment as time $0$. He wants to know, for any moment in $(-\\infty, +\\infty)$ and any single point on the plane, what is the maximum number of clouds that can simultaneously cover it. A point is covered by a cloud at some moment if and only if it lies strictly inside the rectangle occupied by the cloud at that moment (excluding the boundary).\n\nYou need to write a program to satisfy his curiosity.", "inputFormat": "The first line contains a positive integer $T$ — the number of test cases. Then follow $T$ test cases in the format below, with no blank lines between them.\n\n- Line 1: a positive integer $n$ — the number of clouds.\n- Then $n$ lines follow: each line contains five space-separated integers $x_i$, $y_i$, $w_i$, $h_i$, and $d_i$ — describing the state of one cloud at time $0$.", "outputFormat": "For each test case, output one line — the maximum number of clouds that can cover some point at any time.", "hint": "In the 1st test group, at any time, any point is covered by at most one cloud.\n\nIn the 2nd test group, the following figure from left to right illustrates the situations at time 0, time 4, and time 11.\n\n![](https://cdn.luogu.com.cn/upload/pic/15106.png)\n\nIn the 3rd test group, time 0 corresponds to the situation at time 20 in the 2nd test group. In this group, during times in $(-20, 0)$, there are always 2 clouds covering the same point. Please note that the range $(-\\infty, +\\infty)$ includes times before time $0$.\n\nConstraints:\n\nFor all testdata, $1 \\leq T \\leq 15$, $-5\\times 10^8 \\leq x_i, y_i \\leq 5\\times 10^8$, $1 \\leq w_i, h_i \\leq 5\\times 10^8$, $d_i \\in \\{0, 1\\}$.\n\n![](https://cdn.luogu.com.cn/upload/pic/15108.png)\n\nCredit: https://www.luogu.org/discuss/show?postid=35727\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#3] 白金元首与克劳德斯", "background": "> 千里白金雪满天　烽火江山起狼烟　分手竟兵刃相见\n\n1941.7.\n\n苏联军队出乎意料的反抗力量、前线德军的补给困难 —— 元首 Adolf 望着天空的云层陷入沉思……", "description": "在 $xy$-直角坐标平面的天空中，有 $n$ 片四边平行于坐标轴的矩形云朵。每一片云由一个五元组 $(x_i, y_i, w_i, h_i, d_i)$ 表示，其中 $(x_i, y_i)$ 为云左下角顶点的坐标，$w_i$ 表示云在 $x$ 轴方向的宽度，$h_i$ 表示云在 $y$ 轴方向的长度，$d_i \\in \\{0, 1\\}$ 为云的移动方向（$0$ 为横向，$1$ 为纵向）。具体来说，满足 $d_i = 0$ 的云沿 $x$ 轴正方向以每秒 $1$ 长度单位的速率不断移动，而满足 $d_i = 1$ 的云沿 $y$ 轴正方向以每秒 $1$ 长度单位的速率不断移动。\n\n元首发现，**所有的云在此时没有重叠的面积**。他将这个时刻记作时刻 $0$。他想知道，对于 $(-\\infty, +\\infty)$ 中的**任意时刻**和平面上的**任意一个点**，最多可以同时被多少片云覆盖。一个点在某时刻被一朵云覆盖当且仅当这个点位于该时刻云朵所处矩形的**内部（不含边界）**。\n\n你需要编写程序帮助元首满足他的好奇心。\n", "inputFormat": "输入的第一行包含一个正整数 $T$ —— 数据的组数。接下来包含 $T$ 组数据，格式如下，数据间没有空行。\n\n* 第 $1$ 行：一个正整数 $n$ —— 云朵的数量。\n* 接下来 $n$ 行：每行五个空格分隔的整数 $x_i$、$y_i$、$w_i$、$h_i$ 和 $d_i$ —— 描述一朵云在时刻 $0$ 的状态。\n", "outputFormat": "对于每组数据输出一行 —— 在任意时刻，覆盖平面上任意一个点的云朵数目的最大值。", "hint": "第 $1$ 组数据中，任意时刻的任意一个点至多被惟一的一片云覆盖。\n\n第 $2$ 组数据中，下图从左至右分别示意时刻 $0$、时刻 $4$、时刻 $11$ 的情形。\n\n![](https://cdn.luogu.com.cn/upload/pic/15106.png)\n\n第 $3$ 组数据中，时刻 $0$ 对应第 $2$ 组数据时刻 $20$ 的情形。在该组数据中，$(-20, 0)$ 内的时刻均有 $2$ 片云覆盖同一个点。请注意考察范围 $(-\\infty, +\\infty)$ 包含时刻 $0$ 之前的时间段。\n\n对于所有数据，有 $1 \\leq T \\leq 15$，$-5\\times 10^8 \\leq x_i, y_i \\leq 5\\times 10^8$，$1 \\leq w_i, h_i \\leq 5\\times 10^8$，$d_i \\in {0, 1}$。\n\n![](https://cdn.luogu.com.cn/upload/pic/15108.png)\n\nCredit：https://www.luogu.org/discuss/show?postid=35727", "locale": "zh-CN"}}}
{"pid": "P4262", "type": "P", "difficulty": 6, "samples": [["2 4\n0 0 0 0\n0 0 0 1", "14 13 10 22\n15 11 17 0\n"], ["4 5\n0 0 0 1 1\n1 0 0 0 1\n1 0 0 0 0\n0 0 0 0 0\n", "1882 827 1523 0 0\n0 1189 791 1529 0\n0 1106 979 823 1315\n1810 899 1136 1075 1189"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["O2优化", "轮廓线 DP", "Code+"], "title": "[Code+#3] 白金元首与莫斯科", "background": "> 莫斯科吹的寒风 / 仿佛昨日那场梦 / 啊 你还会记得我吗\n\n1941.12.\n\n寒冷刺骨的天气、疲惫不堪的军队…… 包围首都的作战计划陷入了困境。空军或许是拯救战况的最后希望了，元首 Adolf 想道。", "description": "在一个 $n \\times m$ 的网格区域中存在一个陆军单位需要补给，区域中的每个格子为空地或障碍物中的一种。航空舰队需要派遣若干运输机前往此区域，每一架运输机可以向两个相邻（有一条公共边）的空地投放物资。为防止不必要的损坏，一个标记为空地的格子至多只能得到一次投放。\n\n由于天气原因，陆军单位所在的确切位置并不能确定。因此元首想知道，对于每个空地格子，当陆军单位在其中（视作障碍物）时，用若干（可以为 $0$）架运输机向其余空地投放任意数量的物资的不同方案数。两个投放方案不同，当且仅当存在一个格子在一个方案中被投放而另一方案中未被投放，或存在两个被投放的格子，在一个方案中被同一架运输机投放而在另一方案中非然。若仍有疑问，请参考【样例 1 解释】。\n\n你需要编写程序帮助元首计算这些值。", "inputFormat": "第 $1$ 行：两个空格分隔的正整数 $n, m$ —— 网格区域的行数和列数。\n接下来 $n$ 行：其中第 $i$ 行包含 $m$ 个空格分隔的整数 $A_{i1}, A_{i2}, \\ldots, A_{im}$ —— 其中 $A_{ij} = 0$ 表示第 $i$ 行第 $j$ 列的格子为空地；$A_{ij} = 1$ 表示该格为障碍物。", "outputFormat": "输出 $n$ 行，第 $i$ 行包含 $m$ 个空格分隔的整数 $B_{i1}, B_{i2}, \\ldots, B_{im}$ —— 若第 $i$ 行第 $j$ 列的格子为空地，$B_{ij}$ 为该格变为障碍物后投放的方案数；否则 $B_{ij} = 0$。每个答案对 $10^9+7$ 取模。", "hint": "#### 输入输出样例 1 解释\n\n以第 $2$ 行第 $1$ 列的**空地**格为例，其变为**障碍物**后的网格如下图，其中o格子代表**空地**，x格子代表**障碍物**。\n\n```\nｏｏｏｏ\nｘｏｏｘ\n```\n\n$15$ 种方案如下图所示，不同颜色代表不同运输机的投放位置。\n\n![](https://cdn.luogu.com.cn/upload/pic/15113.png)\n\n#### 数据规模与约定\n\n**本题采用捆绑测试，各测试点信息如下**：\n| 子任务编号 | 分值 | $n$ | $m$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $\\le 2$ | $\\le 17$ |\n| $2$ | $8$ | $\\le 5$ | $\\le 5$ |\n| $3$ | $6$ | $\\le 9$ | $\\le 9$ |\n| $4$ | $9$ | $\\le 12$ | $\\le 12$ |\n| $5$ | $17$ | $\\le 15$ | $\\le 15$ |\n| $6$ | $17$ | $\\le 16$ | $\\le 16$ |\n| $7$ | $33$ | $\\le 17$ | $\\le 17$ |\n\n对于所有数据，有 $1 \\leq n, m \\leq 17$，$A_{ij} \\in {0, 1}$。\n\n#### 说明\n\n*Von allem Anfang an bin ich nur verraten und betrogen worden!*\n\n题面与史实不尽相符。\n\n\nCredit：https://www.luogu.org/discuss/show?postid=35727", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#3] Platinum Führer and Moscow", "background": "> The cold wind blowing in Moscow / as if yesterday’s dream / Ah, will you still remember me?\n\n1941.12.\n\nThe weather was freezing cold, the army exhausted... The plan to encircle the capital had run into trouble. The air force might be the last hope to salvage the situation, thought Führer Adolf.", "description": "In an $n \\times m$ grid, there is an army unit that needs resupply. Each cell in the area is either an empty cell or an obstacle. The air fleet needs to dispatch several transport planes to this area. Each transport plane can drop supplies to two adjacent (sharing a common edge) empty cells. To prevent unnecessary damage, a cell marked as empty can receive at most one drop.\n\nDue to the weather, the exact location of the army unit cannot be determined. Therefore, for every empty cell, when the army unit is in that cell (treat it as an obstacle), the Führer wants to know the number of different schemes to drop any amount of supplies to the remaining empty cells using any number (possibly $0$) of transport planes. Two schemes are different if and only if there exists a cell that is supplied in one scheme but not in the other, or there exist two supplied cells that are supplied by the same plane in one scheme but not so in the other. If you are still unsure, please refer to the explanation for Sample 1.\n\nYou need to write a program to compute these values.", "inputFormat": "Line 1: two space-separated positive integers $n, m$ — the number of rows and columns of the grid region.\nNext $n$ lines: line $i$ contains $m$ space-separated integers $A_{i1}, A_{i2}, \\ldots, A_{im}$ — $A_{ij} = 0$ means the cell in row $i$, column $j$ is an empty cell; $A_{ij} = 1$ means the cell is an obstacle.", "outputFormat": "Output $n$ lines. Line $i$ contains $m$ space-separated integers $B_{i1}, B_{i2}, \\ldots, B_{im}$ — if the cell in row $i$, column $j$ is an empty cell, then $B_{ij}$ is the number of schemes after turning that cell into an obstacle; otherwise $B_{ij} = 0$. Each answer is taken modulo $10^9+7$.", "hint": "#### Explanation for Sample 1\n\nTake the empty cell in row $2$, column $1$ as an example. After it is changed into an obstacle, the grid is as follows. Cells marked with o are empty, and cells marked with x are obstacles.\n\n```\nｏｏｏｏ\nｘｏｏｘ\n```\n\nThere are $15$ schemes as shown below. Different colors represent the drop positions of different transport planes.\n\n![](https://cdn.luogu.com.cn/upload/pic/15113.png)\n\n#### Constraints\n\nThis problem uses bundled tests. The information for each test point is as follows:\n| Subtask ID | Points | $n$ | $m$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $\\le 2$ | $\\le 17$ |\n| $2$ | $8$ | $\\le 5$ | $\\le 5$ |\n| $3$ | $6$ | $\\le 9$ | $\\le 9$ |\n| $4$ | $9$ | $\\le 12$ | $\\le 12$ |\n| $5$ | $17$ | $\\le 15$ | $\\le 15$ |\n| $6$ | $17$ | $\\le 16$ | $\\le 16$ |\n| $7$ | $33$ | $\\le 17$ | $\\le 17$ |\n\nFor all testdata, $1 \\leq n, m \\leq 17$, $A_{ij} \\in \\{0, 1\\}$.\n\n#### Notes\n\n*Von allem Anfang an bin ich nur verraten und betrogen worden!*\n\nThe statement does not fully agree with historical facts.\n\nCredit: https://www.luogu.org/discuss/show?postid=35727\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#3] 白金元首与莫斯科", "background": "> 莫斯科吹的寒风 / 仿佛昨日那场梦 / 啊 你还会记得我吗\n\n1941.12.\n\n寒冷刺骨的天气、疲惫不堪的军队…… 包围首都的作战计划陷入了困境。空军或许是拯救战况的最后希望了，元首 Adolf 想道。", "description": "在一个 $n \\times m$ 的网格区域中存在一个陆军单位需要补给，区域中的每个格子为空地或障碍物中的一种。航空舰队需要派遣若干运输机前往此区域，每一架运输机可以向两个相邻（有一条公共边）的空地投放物资。为防止不必要的损坏，一个标记为空地的格子至多只能得到一次投放。\n\n由于天气原因，陆军单位所在的确切位置并不能确定。因此元首想知道，对于每个空地格子，当陆军单位在其中（视作障碍物）时，用若干（可以为 $0$）架运输机向其余空地投放任意数量的物资的不同方案数。两个投放方案不同，当且仅当存在一个格子在一个方案中被投放而另一方案中未被投放，或存在两个被投放的格子，在一个方案中被同一架运输机投放而在另一方案中非然。若仍有疑问，请参考【样例 1 解释】。\n\n你需要编写程序帮助元首计算这些值。", "inputFormat": "第 $1$ 行：两个空格分隔的正整数 $n, m$ —— 网格区域的行数和列数。\n接下来 $n$ 行：其中第 $i$ 行包含 $m$ 个空格分隔的整数 $A_{i1}, A_{i2}, \\ldots, A_{im}$ —— 其中 $A_{ij} = 0$ 表示第 $i$ 行第 $j$ 列的格子为空地；$A_{ij} = 1$ 表示该格为障碍物。", "outputFormat": "输出 $n$ 行，第 $i$ 行包含 $m$ 个空格分隔的整数 $B_{i1}, B_{i2}, \\ldots, B_{im}$ —— 若第 $i$ 行第 $j$ 列的格子为空地，$B_{ij}$ 为该格变为障碍物后投放的方案数；否则 $B_{ij} = 0$。每个答案对 $10^9+7$ 取模。", "hint": "#### 输入输出样例 1 解释\n\n以第 $2$ 行第 $1$ 列的**空地**格为例，其变为**障碍物**后的网格如下图，其中o格子代表**空地**，x格子代表**障碍物**。\n\n```\nｏｏｏｏ\nｘｏｏｘ\n```\n\n$15$ 种方案如下图所示，不同颜色代表不同运输机的投放位置。\n\n![](https://cdn.luogu.com.cn/upload/pic/15113.png)\n\n#### 数据规模与约定\n\n**本题采用捆绑测试，各测试点信息如下**：\n| 子任务编号 | 分值 | $n$ | $m$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $\\le 2$ | $\\le 17$ |\n| $2$ | $8$ | $\\le 5$ | $\\le 5$ |\n| $3$ | $6$ | $\\le 9$ | $\\le 9$ |\n| $4$ | $9$ | $\\le 12$ | $\\le 12$ |\n| $5$ | $17$ | $\\le 15$ | $\\le 15$ |\n| $6$ | $17$ | $\\le 16$ | $\\le 16$ |\n| $7$ | $33$ | $\\le 17$ | $\\le 17$ |\n\n对于所有数据，有 $1 \\leq n, m \\leq 17$，$A_{ij} \\in {0, 1}$。\n\n#### 说明\n\n*Von allem Anfang an bin ich nur verraten und betrogen worden!*\n\n题面与史实不尽相符。\n\n\nCredit：https://www.luogu.org/discuss/show?postid=35727", "locale": "zh-CN"}}}
{"pid": "P4263", "type": "P", "difficulty": 3, "samples": [["3\n10\n2 6 1 2 1 1 2 6 7 1\n10\n10 3 6 6 3 10 6 6 6 2\n10\n8 8 10 10 10 10 8 5 8 8", "1\n1\n1\n6\n1\n8"], ["3\n10\n1 4 3 1 8 8 7 2 8 7\n10\n1 10 9 1 3 2 9 9 2 1\n10\n4 1 5 4 1 9 5 5 4 1", "1\n8\n2\n1 9\n3\n1 4 5"], ["3\n10\n3 3 10 8 8 3 10 8 10 3\n10\n2 2 8 6 8 4 2 4 4 8\n10\n6 2 5 6 7 5 7 10 2 10", "1\n3\n3\n2 4 8\n-1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["Code+"], "title": "[Code+#3] 投票统计", "background": "", "description": "为了总结过去一段时间的命题工作，王队长组织了“我最喜欢的题目”评选活动，并邀请各位选手给题目进行投票。\n\n具体来说，每道题目有一个正整数作为它的编号，一共有 $n$ 名选手给它们进行投票，每位选手投且仅投给一道题，其中第 $i$ 位选手所投票的题目编号为 $a_i$。\n\n由于投票的选手众多，所以王队长请你来帮忙统计得票数。你需要找出收获选手投票最多的**题目数量**与**他们的编号**，并按**从小到大**的顺序列出这些编号。但这里有一个**例外情况**：如果所有被投票的题目得票数都相同，则王队长认为这次活动比较失败，你应该**输出-1**。\n\n", "inputFormat": "输入数据第一行包含一个正整数 $T$，表示测试数据的组数，各组数据之间没有空行。\n\n接下来 $2T$ 行，依次描述每组数据：\n\n每组数据包含两行，其中第一行包含一个正整数 $n$，表示参与这次活动的选手人数。第二行包含 $n$ 个由空格隔开的正整数 $a_1\\sim a_n$，其中第 $i$ 个数 $a_i$ 表示第 $i$ 位选手所投票的题目编号。\n\n", "outputFormat": "输出应由 $T$ 组数据组成，各组数据之间没有空行。对于每一组数据：\n\n若没有出现题面所述的例外情况，则这组测试数据输出两行，其中第一行输出一个正整数 $m$，表示收获选手投票最多的题目数量，第二行按**从小到大**的顺序输出 $m$ 个正整数，表示这些题目的编号。\n\n若出现题面所述的例外情况，则这组测试数据输出一行，请**输出-1**。\n", "hint": "测试点编号|$n$的范围|$a_i$的范围|特殊约定\n-|-|-|-\n1|$=2000$|$\\leq n$|得票数最多的题目唯一\n2|同上|同上|同上\n3|同上|$\\leq 10^9$|同上\n4|同上|$\\leq n$|不会出现例外情况\n5|同上|同上|同上\n6|同上|$\\leq 10^9$|同上\n7|同上|$\\leq n$|无\n8|同上|同上|同上\n9|同上|$\\leq 10^9$|同上\n10|同上|同上|同上\n11|$=100000$|$\\leq n$|得票数最多的题目唯一\n12|同上|同上|同上\n13|同上|$\\leq 10^9$|同上\n14|同上|$\\leq n$|不会出现例外情况\n15|同上|同上|同上\n16|同上|$\\leq 10^9$|同上\n17|同上|$\\leq n$|无\n18|同上|同上|同上\n19|同上|$\\leq 10^9$|同上\n20|同上|同上|同上\n\nCredit： https://www.luogu.org/discuss/show?postid=35727", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#3] Vote Counting", "background": "", "description": "To review the problem-setting work over the past period, Captain Wang organized a \"My Favorite Problem\" selection and invited all contestants to vote for the problems.\n\nSpecifically, each problem has a positive integer as its ID. There are $n$ contestants voting; each contestant votes for exactly one problem, and the $i$-th contestant votes for the problem with ID $a_i$.\n\nSince there are many voters, Captain Wang asks you to help tally the votes. You need to find the number of problems that received the most votes and their IDs, and list these IDs in ascending order. However, there is one exception: if all problems that received at least one vote have the same number of votes, then Captain Wang considers the event unsuccessful, and you should output -1.", "inputFormat": "The first line contains a positive integer $T$, the number of testdata groups. There is no blank line between groups.\n\nThe next $2T$ lines describe each group in order:\n\nEach group contains two lines. The first line contains a positive integer $n$, the number of contestants participating. The second line contains $n$ space-separated positive integers $a_1\\sim a_n$, where the $i$-th number $a_i$ is the ID of the problem voted for by the $i$-th contestant.", "outputFormat": "The output consists of $T$ groups, with no blank lines between groups. For each group:\n\nIf the exception described in the statement does not occur, output two lines for this group. On the first line, output a positive integer $m$, the number of problems that received the most votes. On the second line, output $m$ positive integers in ascending order, which are the IDs of these problems.\n\nIf the exception occurs, output one line for this group: output -1.", "hint": "Test point ID|Range of $n$|Range of $a_i$|Special notes\n-|-|-|-\n1|$=2000$|$\\leq n$|The problem with the most votes is unique\n2|Same as above|Same as above|Same as above\n3|Same as above|$\\leq 10^9$|Same as above\n4|Same as above|$\\leq n$|The exception will not occur\n5|Same as above|Same as above|Same as above\n6|Same as above|$\\leq 10^9$|Same as above\n7|Same as above|$\\leq n$|None\n8|Same as above|Same as above|Same as above\n9|Same as above|$\\leq 10^9$|Same as above\n10|Same as above|Same as above|Same as above\n11|$=100000$|$\\leq n$|The problem with the most votes is unique\n12|Same as above|Same as above|Same as above\n13|Same as above|$\\leq 10^9$|Same as above\n14|Same as above|$\\leq n$|The exception will not occur\n15|Same as above|Same as above|Same as above\n16|Same as above|$\\leq 10^9$|Same as above\n17|Same as above|$\\leq n$|None\n18|Same as above|Same as above|Same as above\n19|Same as above|$\\leq 10^9$|Same as above\n20|Same as above|Same as above|Same as above\n\nCredit: https://www.luogu.org/discuss/show?postid=35727.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#3] 投票统计", "background": "", "description": "为了总结过去一段时间的命题工作，王队长组织了“我最喜欢的题目”评选活动，并邀请各位选手给题目进行投票。\n\n具体来说，每道题目有一个正整数作为它的编号，一共有 $n$ 名选手给它们进行投票，每位选手投且仅投给一道题，其中第 $i$ 位选手所投票的题目编号为 $a_i$。\n\n由于投票的选手众多，所以王队长请你来帮忙统计得票数。你需要找出收获选手投票最多的**题目数量**与**他们的编号**，并按**从小到大**的顺序列出这些编号。但这里有一个**例外情况**：如果所有被投票的题目得票数都相同，则王队长认为这次活动比较失败，你应该**输出-1**。\n\n", "inputFormat": "输入数据第一行包含一个正整数 $T$，表示测试数据的组数，各组数据之间没有空行。\n\n接下来 $2T$ 行，依次描述每组数据：\n\n每组数据包含两行，其中第一行包含一个正整数 $n$，表示参与这次活动的选手人数。第二行包含 $n$ 个由空格隔开的正整数 $a_1\\sim a_n$，其中第 $i$ 个数 $a_i$ 表示第 $i$ 位选手所投票的题目编号。\n\n", "outputFormat": "输出应由 $T$ 组数据组成，各组数据之间没有空行。对于每一组数据：\n\n若没有出现题面所述的例外情况，则这组测试数据输出两行，其中第一行输出一个正整数 $m$，表示收获选手投票最多的题目数量，第二行按**从小到大**的顺序输出 $m$ 个正整数，表示这些题目的编号。\n\n若出现题面所述的例外情况，则这组测试数据输出一行，请**输出-1**。\n", "hint": "测试点编号|$n$的范围|$a_i$的范围|特殊约定\n-|-|-|-\n1|$=2000$|$\\leq n$|得票数最多的题目唯一\n2|同上|同上|同上\n3|同上|$\\leq 10^9$|同上\n4|同上|$\\leq n$|不会出现例外情况\n5|同上|同上|同上\n6|同上|$\\leq 10^9$|同上\n7|同上|$\\leq n$|无\n8|同上|同上|同上\n9|同上|$\\leq 10^9$|同上\n10|同上|同上|同上\n11|$=100000$|$\\leq n$|得票数最多的题目唯一\n12|同上|同上|同上\n13|同上|$\\leq 10^9$|同上\n14|同上|$\\leq n$|不会出现例外情况\n15|同上|同上|同上\n16|同上|$\\leq 10^9$|同上\n17|同上|$\\leq n$|无\n18|同上|同上|同上\n19|同上|$\\leq 10^9$|同上\n20|同上|同上|同上\n\nCredit： https://www.luogu.org/discuss/show?postid=35727", "locale": "zh-CN"}}}
{"pid": "P4264", "type": "P", "difficulty": 5, "samples": [["3\n-5 -7\n-3 10\n-2 7", "10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2018", "USACO", "枚举", "差分"], "title": "[USACO18FEB] Teleportation S", "background": "", "description": "One of the farming chores Farmer John dislikes the most is hauling around lots of cow manure. In order to streamline this process, he comes up with a brilliant invention: the manure teleporter! Instead of hauling manure between two points in a cart behind his tractor, he can use the manure teleporter to instantly transport manure from one location to another.\nFarmer John's farm is built along a single long straight road, so any location on his farm can be described simply using its position along this road (effectively a point on the number line). A teleporter is described by two numbers $x$ and $y$, where manure brought to location $x$ can be instantly transported to location $y$.\n\nFarmer John decides to build a teleporter with the first endpoint located at $x=0$; your task is to help him determine the best choice for the other endpoint $y$. In particular, there are $N$ piles of manure on his farm ($1 \\leq N \\leq 100,000$). The $i$th pile needs to moved from position $a_i$ to position $b_i$, and Farmer John transports each pile separately from the others. If we let $d_i$ denote the amount of distance FJ drives with manure in his tractor hauling the $i$th pile, then it is possible that $d_i = |a_i-b_i|$ if he hauls the $i$th pile directly with the tractor, or that $d_i$ could potentially be less if he uses the teleporter (e.g., by hauling with his tractor from $a_i$ to $x$, then from $y$ to $b_i$).\n\nPlease help FJ determine the minimum possible sum of the $d_i$'s he can achieve by building the other endpoint $y$ of the teleporter in a carefully-chosen optimal position. The same position $y$ is used during transport of every pile.", "inputFormat": "The first line of input contains $N$. In the $N$ lines that follow, the $i$th line contains $a_i$ and $b_i$, each an integer in the range $-10^8 \\ldots 10^8$. These values are not necessarily all distinct.", "outputFormat": "Print a single number giving the minimum sum of $d_i$'s FJ can achieve. Note that this number might be too large to fit into a standard 32-bit integer, so you may need to use large integer data types like a \"long long\" in C/C++. Also you may want to consider whether the answer is necessarily an integer or not...", "hint": "In this example, by setting $y = 8$ FJ can achieve $d_1 = 2$, $d_2 = 5$, and $d_3 = 3$. Note that any value of $y$ in the range $[7,10]$ would also yield an optimal solution.\n\nProblem credits: Brian Dean", "locale": "en", "translations": {"en": {"title": "[USACO18FEB] Teleportation S", "background": "", "description": "One of the farming chores Farmer John dislikes the most is hauling around lots of cow manure. In order to streamline this process, he comes up with a brilliant invention: the manure teleporter! Instead of hauling manure between two points in a cart behind his tractor, he can use the manure teleporter to instantly transport manure from one location to another.\nFarmer John's farm is built along a single long straight road, so any location on his farm can be described simply using its position along this road (effectively a point on the number line). A teleporter is described by two numbers $x$ and $y$, where manure brought to location $x$ can be instantly transported to location $y$.\n\nFarmer John decides to build a teleporter with the first endpoint located at $x=0$; your task is to help him determine the best choice for the other endpoint $y$. In particular, there are $N$ piles of manure on his farm ($1 \\leq N \\leq 100,000$). The $i$th pile needs to moved from position $a_i$ to position $b_i$, and Farmer John transports each pile separately from the others. If we let $d_i$ denote the amount of distance FJ drives with manure in his tractor hauling the $i$th pile, then it is possible that $d_i = |a_i-b_i|$ if he hauls the $i$th pile directly with the tractor, or that $d_i$ could potentially be less if he uses the teleporter (e.g., by hauling with his tractor from $a_i$ to $x$, then from $y$ to $b_i$).\n\nPlease help FJ determine the minimum possible sum of the $d_i$'s he can achieve by building the other endpoint $y$ of the teleporter in a carefully-chosen optimal position. The same position $y$ is used during transport of every pile.", "inputFormat": "The first line of input contains $N$. In the $N$ lines that follow, the $i$th line contains $a_i$ and $b_i$, each an integer in the range $-10^8 \\ldots 10^8$. These values are not necessarily all distinct.", "outputFormat": "Print a single number giving the minimum sum of $d_i$'s FJ can achieve. Note that this number might be too large to fit into a standard 32-bit integer, so you may need to use large integer data types like a \"long long\" in C/C++. Also you may want to consider whether the answer is necessarily an integer or not...", "hint": "In this example, by setting $y = 8$ FJ can achieve $d_1 = 2$, $d_2 = 5$, and $d_3 = 3$. Note that any value of $y$ in the range $[7,10]$ would also yield an optimal solution.\n\nProblem credits: Brian Dean", "locale": "en"}, "zh-CN": {"title": "[USACO18FEB] Teleportation S", "background": "", "description": "Farmer John 最不喜欢的农活之一就是到处搬运牛粪。为了简化这一过程，他发明了一个绝妙的装置：牛粪传送器！与其用拖拉机后面的拖车搬运牛粪，他可以使用牛粪传送器将牛粪从一个位置瞬间传送到另一个位置。\n\nFarmer John 的农场建在一条笔直的长路上，因此农场上的任何位置都可以简单地用其在这条路上的位置来描述（实际上就是数轴上的一个点）。传送器由两个数字 $x$ 和 $y$ 描述，其中被带到位置 $x$ 的牛粪可以瞬间传送到位置 $y$。\n\nFarmer John 决定建造一个传送器，其第一个端点位于 $x = 0$；你的任务是帮助他确定另一个端点 $y$ 的最佳选择。特别地，农场上有 $N$ 堆牛粪（$1 \\leq N \\leq 100,000$）。第 $i$ 堆牛粪需要从位置 $a_i$ 搬运到位置 $b_i$，Farmer John 会分别搬运每一堆牛粪。如果我们用 $d_i$ 表示 Farmer John 搬运第 $i$ 堆牛粪时拖拉机行驶的距离，那么如果他直接用拖拉机搬运第 $i$ 堆牛粪，则 $d_i = |a_i - b_i|$；如果他使用传送器，则 $d_i$ 可能会更小（例如，通过用拖拉机从 $a_i$ 运到 $x$，然后从 $y$ 运到 $b_i$）。\n\n请帮助 Farmer John 确定通过将传送器的另一个端点 $y$ 建在一个精心选择的最优位置，可以实现的最小 $d_i$ 总和。搬运每堆牛粪时使用相同的 $y$ 位置。", "inputFormat": "输入的第一行包含 $N$。接下来的 $N$ 行中，第 $i$ 行包含 $a_i$ 和 $b_i$，每个整数的范围在 $-10^8 \\ldots 10^8$ 之间。这些值不一定全部不同。", "outputFormat": "输出一个数字，表示 Farmer John 可以实现的最小 $d_i$ 总和。请注意，这个数字可能超过标准 32 位整数的范围，因此可能需要使用更大的整数类型，例如 C/C++ 中的 `long long`。此外，你可能需要考虑答案是否一定是整数……", "hint": "在这个例子中，通过设置 $y = 8$，Farmer John 可以实现 $d_1 = 2$、$d_2 = 5$ 和 $d_3 = 3$。请注意，$y$ 在范围 $[7,10]$ 内的任何值也会产生最优解。\n\n题目来源：Brian Dean", "locale": "zh-CN"}}}
{"pid": "P4265", "type": "P", "difficulty": 4, "samples": [["10 4\n0 2 8 3 6 7 5 1 4 0\n2 3\n4 2\n3 4\n7 1", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2018", "USACO", "枚举"], "title": "[USACO18FEB] Snow Boots S", "background": "", "description": "It's winter on the farm, and that means snow! There are $N$ tiles on the path from the farmhouse to the barn, conveniently numbered $1 \\dots N$, and tile $i$ is covered in $f_i$ feet of snow.\nFarmer John starts off on tile $1$ and must reach tile $N$ to wake up the cows. Tile $1$ is sheltered by the farmhouse roof, and tile $N$ is sheltered by the barn roof, so neither of these tiles has any snow. But to step on the other tiles, Farmer John needs to wear boots!\n\nIn his foul-weather backpack, Farmer John has $B$ pairs of boots, numbered $1 \\dots B$. Some pairs are more heavy-duty than others, and some pairs are more agile than others. In particular, pair $i$ lets FJ step in snow at most $s_i$ feet deep, and lets FJ move at most $d_i$ forward in each step.\n\nUnfortunately, the boots are packed in such a way that Farmer John can only access the topmost pair at any given time. So at any time, Farmer John can either put on the topmost pair of boots (discarding his old pair) or discard the topmost pair of boots (making a new pair of boots accessible).\n\nFarmer John can only change boots while standing on a tile. If that tile has $f$ feet of snow, both the boots he takes off AND the boots he puts on must be able to withstand at least $f$ feet of snow. Intermediate pairs of boots which he discards without wearing do not need to satisfy this restriction.\n\nHelp Farmer John minimize waste, by determining the minimum number of pairs of boots he needs to discard in order to reach the barn. You may assume that Farmer John is initially not wearing any boots.", "inputFormat": "The first line contains two space-separated integers $N$ and $B$ ($2 \\leq N,B \\leq 250$).\nThe second line contains $N$ space-separated integers. The $i$th integer is $f_i$, giving the depth of snow on tile $i$ ($0 \\leq f_i \\leq 10^9$). It's guaranteed that $f_1 = f_N = 0$.\n\nThe next $B$ lines contain two space-separated integers each. The first integer on line $i+2$ is $s_i$, the maximum depth of snow in which pair $i$ can step. The second integer on line $i+2$ is $d_i$, the maximum step size for pair $i$. It's guaranteed that $0 \\leq s_i \\leq 10^9$ and $1 \\leq d_i \\leq N-1$.\n\nThe boots are described in top-to-bottom order, so pair $1$ is the topmost pair in FJ's backpack, and so forth.", "outputFormat": "The output should consist of a single integer, giving the minimum number of boots Farmer John needs to discard. It's guaranteed that it will be possible for FJ to make it to the barn.", "hint": "Problem credits: Brian Dean and Dhruv Rohatgi", "locale": "en", "translations": {"en": {"title": "[USACO18FEB] Snow Boots S", "background": "", "description": "It's winter on the farm, and that means snow! There are $N$ tiles on the path from the farmhouse to the barn, conveniently numbered $1 \\dots N$, and tile $i$ is covered in $f_i$ feet of snow.\nFarmer John starts off on tile $1$ and must reach tile $N$ to wake up the cows. Tile $1$ is sheltered by the farmhouse roof, and tile $N$ is sheltered by the barn roof, so neither of these tiles has any snow. But to step on the other tiles, Farmer John needs to wear boots!\n\nIn his foul-weather backpack, Farmer John has $B$ pairs of boots, numbered $1 \\dots B$. Some pairs are more heavy-duty than others, and some pairs are more agile than others. In particular, pair $i$ lets FJ step in snow at most $s_i$ feet deep, and lets FJ move at most $d_i$ forward in each step.\n\nUnfortunately, the boots are packed in such a way that Farmer John can only access the topmost pair at any given time. So at any time, Farmer John can either put on the topmost pair of boots (discarding his old pair) or discard the topmost pair of boots (making a new pair of boots accessible).\n\nFarmer John can only change boots while standing on a tile. If that tile has $f$ feet of snow, both the boots he takes off AND the boots he puts on must be able to withstand at least $f$ feet of snow. Intermediate pairs of boots which he discards without wearing do not need to satisfy this restriction.\n\nHelp Farmer John minimize waste, by determining the minimum number of pairs of boots he needs to discard in order to reach the barn. You may assume that Farmer John is initially not wearing any boots.", "inputFormat": "The first line contains two space-separated integers $N$ and $B$ ($2 \\leq N,B \\leq 250$).\nThe second line contains $N$ space-separated integers. The $i$th integer is $f_i$, giving the depth of snow on tile $i$ ($0 \\leq f_i \\leq 10^9$). It's guaranteed that $f_1 = f_N = 0$.\n\nThe next $B$ lines contain two space-separated integers each. The first integer on line $i+2$ is $s_i$, the maximum depth of snow in which pair $i$ can step. The second integer on line $i+2$ is $d_i$, the maximum step size for pair $i$. It's guaranteed that $0 \\leq s_i \\leq 10^9$ and $1 \\leq d_i \\leq N-1$.\n\nThe boots are described in top-to-bottom order, so pair $1$ is the topmost pair in FJ's backpack, and so forth.", "outputFormat": "The output should consist of a single integer, giving the minimum number of boots Farmer John needs to discard. It's guaranteed that it will be possible for FJ to make it to the barn.", "hint": "Problem credits: Brian Dean and Dhruv Rohatgi", "locale": "en"}, "zh-CN": {"title": "[USACO18FEB] Snow Boots S", "background": "", "description": "农场的冬天到了，这意味着下雪了！从农舍到谷仓的路上有 $N$ 块地砖，方便地编号为 $1 \\dots N$，第 $i$ 块地砖上覆盖了 $f_i$ 英尺的雪。\n\nFarmer John 从第 $1$ 块地砖出发，必须到达第 $N$ 块地砖去叫醒奶牛。第 $1$ 块地砖被农舍的屋顶遮蔽，第 $N$ 块地砖被谷仓的屋顶遮蔽，因此这两块地砖上没有雪。但要踩在其他地砖上，Farmer John 需要穿靴子！\n\n在他的恶劣天气背包中，Farmer John 有 $B$ 双靴子，编号为 $1 \\dots B$。有些靴子比其他靴子更耐用，有些靴子比其他靴子更灵活。具体来说，第 $i$ 双靴子允许 Farmer John 在最多 $s_i$ 英尺深的雪中行走，并且每步最多可以移动 $d_i$ 块地砖。\n\n不幸的是，靴子的打包方式使得 Farmer John 在任何时候只能访问最上面的一双靴子。因此，Farmer John 可以随时穿上最上面的一双靴子（丢弃旧靴子）或丢弃最上面的一双靴子（使下一双靴子可访问）。\n\nFarmer John 只能在地砖上更换靴子。如果该地砖上有 $f$ 英尺的雪，那么他脱下的靴子和穿上的靴子都必须能够承受至少 $f$ 英尺的雪。他丢弃但未穿过的中间靴子不需要满足此限制。\n\n请帮助 Farmer John 最小化浪费，确定他到达谷仓需要丢弃的最少靴子对数。假设 Farmer John 最初没有穿任何靴子。", "inputFormat": "第一行包含两个以空格分隔的整数 $N$ 和 $B$（$2 \\leq N, B \\leq 250$）。\n\n第二行包含 $N$ 个以空格分隔的整数。第 $i$ 个整数是 $f_i$，表示第 $i$ 块地砖上的雪的深度（$0 \\leq f_i \\leq 10^9$）。保证 $f_1 = f_N = 0$。\n\n接下来的 $B$ 行每行包含两个以空格分隔的整数。第 $i+2$ 行的第一个整数是 $s_i$，表示第 $i$ 双靴子可以承受的最大雪深。第二个整数是 $d_i$，表示第 $i$ 双靴子的最大步长。保证 $0 \\leq s_i \\leq 10^9$ 且 $1 \\leq d_i \\leq N-1$。\n\n靴子按从上到下的顺序描述，因此第 $1$ 双靴子是背包中最上面的一双，依此类推。", "outputFormat": "输出应包含一个整数，表示 Farmer John 需要丢弃的最少靴子对数。保证 Farmer John 能够到达谷仓。", "hint": "题目来源：Brian Dean 和 Dhruv Rohatgi", "locale": "zh-CN"}}}
{"pid": "P4266", "type": "P", "difficulty": 3, "samples": [["10 2 4 3\n7 2\n8 1", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2018", "USACO", "排序"], "title": "[USACO18FEB] Rest Stops S", "background": "", "description": "Farmer John and his personal trainer Bessie are hiking up Mount Vancowver. For their purposes (and yours), the mountain can be represented as a long straight trail of length $L$ meters ($1 \\leq L \\leq 10^6$). Farmer John will hike the trail at a constant travel rate of $r_F$ seconds per meter ($1 \\leq r_F \\leq 10^6$). Since he is working on his stamina, he will not take any rest stops along the way.\nBessie, however, is allowed to take rest stops, where she might find some tasty grass. Of course, she cannot stop just anywhere! There are $N$ rest stops along the trail ($1 \\leq N \\leq 10^5$); the $i$-th stop is $x_i$ meters from the start of the trail ($0 < x_i < L$) and has a tastiness value $c_i$ ($1 \\leq c_i \\leq 10^6$). If Bessie rests at stop $i$ for $t$ seconds, she receives $c_i \\cdot t$ tastiness units.\n\nWhen not at a rest stop, Bessie will be hiking at a fixed travel rate of $r_B$ seconds per meter ($1 \\leq r_B \\leq 10^6$). Since Bessie is young and fit, $r_B$ is strictly less than $r_F$.\n\nBessie would like to maximize her consumption of tasty grass. But she is worried about Farmer John; she thinks that if at any point along the hike she is behind Farmer John on the trail, he might lose all motivation to continue!\n\nHelp Bessie find the maximum total tastiness units she can obtain while making sure that Farmer John completes the hike.", "inputFormat": "The first line of input contains four integers: $L$, $N$, $r_F$, and $r_B$. The next $N$ lines describe the rest stops. For each $i$ between $1$ and $N$, the $i+1$-st line contains two integers $x_i$ and $c_i$, describing the position of the $i$-th rest stop and the tastiness of the grass there.\nIt is guaranteed that $r_F > r_B$, and $0 < x_1 < \\dots < x_N < L $. **Note that $r_F$ and $r_B$ are given in seconds per meter!**", "outputFormat": "A single integer: the maximum total tastiness units Bessie can obtain.", "hint": "In this example, it is optimal for Bessie to stop for $7$ seconds at the $x=7$ rest stop (acquiring $14$ tastiness units) and then stop for an additional $1$ second at the $x=8$ rest stop (acquiring $1$ more tastiness unit, for a total of $15$ tastiness units).\n\nProblem credits: Dhruv Rohatgi", "locale": "en", "translations": {"en": {"title": "[USACO18FEB] Rest Stops S", "background": "", "description": "Farmer John and his personal trainer Bessie are hiking up Mount Vancowver. For their purposes (and yours), the mountain can be represented as a long straight trail of length $L$ meters ($1 \\leq L \\leq 10^6$). Farmer John will hike the trail at a constant travel rate of $r_F$ seconds per meter ($1 \\leq r_F \\leq 10^6$). Since he is working on his stamina, he will not take any rest stops along the way.\nBessie, however, is allowed to take rest stops, where she might find some tasty grass. Of course, she cannot stop just anywhere! There are $N$ rest stops along the trail ($1 \\leq N \\leq 10^5$); the $i$-th stop is $x_i$ meters from the start of the trail ($0 < x_i < L$) and has a tastiness value $c_i$ ($1 \\leq c_i \\leq 10^6$). If Bessie rests at stop $i$ for $t$ seconds, she receives $c_i \\cdot t$ tastiness units.\n\nWhen not at a rest stop, Bessie will be hiking at a fixed travel rate of $r_B$ seconds per meter ($1 \\leq r_B \\leq 10^6$). Since Bessie is young and fit, $r_B$ is strictly less than $r_F$.\n\nBessie would like to maximize her consumption of tasty grass. But she is worried about Farmer John; she thinks that if at any point along the hike she is behind Farmer John on the trail, he might lose all motivation to continue!\n\nHelp Bessie find the maximum total tastiness units she can obtain while making sure that Farmer John completes the hike.", "inputFormat": "The first line of input contains four integers: $L$, $N$, $r_F$, and $r_B$. The next $N$ lines describe the rest stops. For each $i$ between $1$ and $N$, the $i+1$-st line contains two integers $x_i$ and $c_i$, describing the position of the $i$-th rest stop and the tastiness of the grass there.\nIt is guaranteed that $r_F > r_B$, and $0 < x_1 < \\dots < x_N < L $. **Note that $r_F$ and $r_B$ are given in seconds per meter!**", "outputFormat": "A single integer: the maximum total tastiness units Bessie can obtain.", "hint": "In this example, it is optimal for Bessie to stop for $7$ seconds at the $x=7$ rest stop (acquiring $14$ tastiness units) and then stop for an additional $1$ second at the $x=8$ rest stop (acquiring $1$ more tastiness unit, for a total of $15$ tastiness units).\n\nProblem credits: Dhruv Rohatgi", "locale": "en"}, "zh-CN": {"title": "[USACO18FEB] Rest Stops S", "background": "", "description": "Farmer John 和他的私人教练 Bessie 正在攀登温哥华山。为了他们的目的（以及你的目的），这座山可以表示为一条长度为 $L$ 米的长直步道（$1 \\leq L \\leq 10^6$）。Farmer John 将以每米 $r_F$ 秒的恒定速度徒步（$1 \\leq r_F \\leq 10^6$）。由于他正在锻炼耐力，他不会在途中休息。\n\n然而，Bessie 被允许在休息站休息，她可能会在那里找到一些美味的草。当然，她不能随便停下来！步道上有 $N$ 个休息站（$1 \\leq N \\leq 10^5$）；第 $i$ 个休息站距离步道起点 $x_i$ 米（$0 < x_i < L$），并且有一个美味值 $c_i$（$1 \\leq c_i \\leq 10^6$）。如果 Bessie 在第 $i$ 个休息站休息 $t$ 秒，她会获得 $c_i \\cdot t$ 的美味单位。\n\n当不在休息站时，Bessie 将以每米 $r_B$ 秒的固定速度徒步（$1 \\leq r_B \\leq 10^6$）。由于 Bessie 年轻且健康，$r_B$ 严格小于 $r_F$。\n\nBessie 希望最大化她摄入的美味草量。但她担心 Farmer John；她认为如果在徒步的任何时刻她在步道上落后于 Farmer John，他可能会失去继续前进的动力！\n\n请帮助 Bessie 找到在确保 Farmer John 完成徒步的情况下，她能获得的最大总美味单位。", "inputFormat": "输入的第一行包含四个整数：$L$、$N$、$r_F$ 和 $r_B$。接下来的 $N$ 行描述了休息站。对于每个 $i$ 从 $1$ 到 $N$，第 $i+1$ 行包含两个整数 $x_i$ 和 $c_i$，分别描述第 $i$ 个休息站的位置和草的美味值。\n保证 $r_F > r_B$，且 $0 < x_1 < \\dots < x_N < L$。**注意，$r_F$ 和 $r_B$ 的单位是秒每米！**", "outputFormat": "输出一个整数：Bessie 能获得的最大总美味单位。", "hint": "在这个例子中，Bessie 最优的策略是在 $x=7$ 的休息站休息 $7$ 秒（获得 $14$ 个美味单位），然后在 $x=8$ 的休息站再休息 $1$ 秒（获得 $1$ 个美味单位，总共 $15$ 个美味单位）。", "locale": "zh-CN"}}}
{"pid": "P4267", "type": "P", "difficulty": 4, "samples": [["6\n1 1 2 0 0 1", "4\n2\n1\n2\n3\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2018", "USACO", "枚举"], "title": "[USACO18FEB] Taming the Herd G", "background": "", "description": "Early in the morning, Farmer John woke up to the sound of splintering wood. It was the cows, and they were breaking out of the barn again!\nFarmer John was sick and tired of the cows' morning breakouts, and he decided enough was enough: it was time to get tough. He nailed to the barn wall a counter tracking the number of days since the last breakout. So if a breakout occurred in the morning, the counter would be $0$ that day; if the most recent breakout was $3$ days ago, the counter would read $3$. Farmer John meticulously logged the counter every day.\n\nThe end of the year has come, and Farmer John is ready to do some accounting. The cows will pay, he says! But something about his log doesn't look quite right...\n\nFarmer John wants to find out how many breakouts have occurred since he started his log. However, he suspects that the cows have tampered with his log, and all he knows for sure is that he started his log on the day of a breakout. Please help him determine, for each number of breakouts that might have occurred since he started the log, the minimum number of log entries that must have been tampered with.", "inputFormat": "The first line contains a single integer $N$ ($1 \\leq N \\leq 100$), denoting the number of days since Farmer John started logging the cow breakout counter.\nThe second line contains $N$ space-separated integers. The $i$th integer is a non-negative integer $a_i$ (at most $100$), indicating that on day $i$ the counter was at $a_i$, unless the cows tampered with that day's log entry.", "outputFormat": "The output should consist of $N$ integers, one per line. The $i$th integer should be the minimum over all possible breakout sequences with $i$ breakouts, of the number of log entries that are inconsistent with that sequence.", "hint": "If there was only 1 breakout, then the correct log would look like 0 1 2 3 4 5, which is 4 entries different from the given log.\n\nIf there were 2 breakouts, then the correct log might look like 0 1 2 3 0 1, which is 2 entries different from the given log. In this case, the breakouts occurred on the first and fifth days.\n\nIf there were 3 breakouts, then the correct log might look like 0 1 2 0 0 1, which is just 1 entry different from the given log. In this case, the breakouts occurred on the first, fourth, and fifth days.\n\nAnd so on.\n\nProblem credits: Brian Dean and Dhruv Rohatgi", "locale": "en", "translations": {"en": {"title": "[USACO18FEB] Taming the Herd G", "background": "", "description": "Early in the morning, Farmer John woke up to the sound of splintering wood. It was the cows, and they were breaking out of the barn again!\nFarmer John was sick and tired of the cows' morning breakouts, and he decided enough was enough: it was time to get tough. He nailed to the barn wall a counter tracking the number of days since the last breakout. So if a breakout occurred in the morning, the counter would be $0$ that day; if the most recent breakout was $3$ days ago, the counter would read $3$. Farmer John meticulously logged the counter every day.\n\nThe end of the year has come, and Farmer John is ready to do some accounting. The cows will pay, he says! But something about his log doesn't look quite right...\n\nFarmer John wants to find out how many breakouts have occurred since he started his log. However, he suspects that the cows have tampered with his log, and all he knows for sure is that he started his log on the day of a breakout. Please help him determine, for each number of breakouts that might have occurred since he started the log, the minimum number of log entries that must have been tampered with.", "inputFormat": "The first line contains a single integer $N$ ($1 \\leq N \\leq 100$), denoting the number of days since Farmer John started logging the cow breakout counter.\nThe second line contains $N$ space-separated integers. The $i$th integer is a non-negative integer $a_i$ (at most $100$), indicating that on day $i$ the counter was at $a_i$, unless the cows tampered with that day's log entry.", "outputFormat": "The output should consist of $N$ integers, one per line. The $i$th integer should be the minimum over all possible breakout sequences with $i$ breakouts, of the number of log entries that are inconsistent with that sequence.", "hint": "If there was only 1 breakout, then the correct log would look like 0 1 2 3 4 5, which is 4 entries different from the given log.\n\nIf there were 2 breakouts, then the correct log might look like 0 1 2 3 0 1, which is 2 entries different from the given log. In this case, the breakouts occurred on the first and fifth days.\n\nIf there were 3 breakouts, then the correct log might look like 0 1 2 0 0 1, which is just 1 entry different from the given log. In this case, the breakouts occurred on the first, fourth, and fifth days.\n\nAnd so on.\n\nProblem credits: Brian Dean and Dhruv Rohatgi", "locale": "en"}, "zh-CN": {"title": "[USACO18FEB] Taming the Herd G", "background": "", "description": "清晨，Farmer John 被木头碎裂的声音吵醒。原来是奶牛们又一次从谷仓里逃出来了！\nFarmer John 对奶牛们的清晨逃跑行为感到厌烦，他决定受够了：是时候采取强硬措施了。他在谷仓的墙上钉了一个计数器，用于记录自上次逃跑以来的天数。因此，如果某天早上发生了逃跑，计数器当天会显示 $0$；如果最近一次逃跑发生在 $3$ 天前，计数器会显示 $3$。Farmer John 每天都会仔细记录计数器的值。\n\n年末到了，Farmer John 准备进行一些统计。他说，奶牛们要为此付出代价！但他发现他的记录似乎有些不对劲……\n\nFarmer John 想知道自从他开始记录以来发生了多少次逃跑。然而，他怀疑奶牛们篡改了他的记录，他唯一能确定的是他开始记录的那天发生了一次逃跑。请帮助他确定，对于可能发生的逃跑次数，记录中必须被篡改的最小条目数。", "inputFormat": "第一行包含一个整数 $N$（$1 \\leq N \\leq 100$），表示 Farmer John 开始记录奶牛逃跑计数器以来的天数。\n第二行包含 $N$ 个以空格分隔的整数。第 $i$ 个整数是一个非负整数 $a_i$（最多 $100$），表示第 $i$ 天计数器的值为 $a_i$，除非奶牛篡改了那天的记录。", "outputFormat": "输出应包含 $N$ 个整数，每行一个。第 $i$ 个整数应表示在所有可能的逃跑序列中，发生 $i$ 次逃跑时，与序列不一致的记录条目的最小数量。", "hint": "如果只有 $1$ 次逃跑，那么正确的记录应该是 `0 1 2 3 4 5`，这与给定的记录有 $4$ 个条目不同。\n\n如果有 $2$ 次逃跑，那么正确的记录可能是 `0 1 2 3 0 1`，这与给定的记录有 $2$ 个条目不同。在这种情况下，逃跑发生在第 $1$ 天和第 $5$ 天。\n\n如果有 $3$ 次逃跑，那么正确的记录可能是 `0 1 2 0 0 1`，这与给定的记录只有 $1$ 个条目不同。在这种情况下，逃跑发生在第 $1$ 天、第 $4$ 天和第 $5$ 天。\n\n以此类推。\n\n题目来源：Brian Dean 和 Dhruv Rohatgi", "locale": "zh-CN"}}}
{"pid": "P4268", "type": "P", "difficulty": 5, "samples": [["8\nbessie 3 2 6 8\nfolder1 2 3 4\nfile1 0\nfolder2 1 5\nfile2 0\nfolder3 1 7\nfile3 0\nfile4 0", "42"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "USACO", "树形 DP"], "title": "[USACO18FEB] Directory Traversal G", "background": "", "description": "Bessie the cow is surprisingly computer savvy. On her computer in the barn, she stores all of her precious files in a collection of directories; for example:\n\n```\nbessie/\n  folder1/\n    file1\n    folder2/\n      file2\n  folder3/\n    file3\n  file4\n```\n\nThere is a single \"top level\" directory, called bessie.\n\nBessie can navigate to be inside any directory she wants. From a given directory, any file can be referenced by a \"relative path\". In a relative path, the symbol \"..\" refers to the parent directory. If Bessie were in folder2, she could refer to the four files as follows:\n\n```\n../file1\nfile2\n../../folder3/file3\n../../file4\n```\n\nBessie would like to choose a directory from which the sum of the lengths of the relative paths to all the files is minimized.", "inputFormat": "The first line contains an integer N ($2 \\leq N \\leq 100,000$), giving the total number of files and directories. For the purposes of input, each object (file or directory) is assigned a unique integer ID between 1 and $N$, where ID 1 refers to the top level directory.\nNext, there will be $N$ lines. Each line starts with the name of a file or directory. The name will have only lower case characters a-z and digits 0-9, and will be at most 16 characters long. Following the name is an integer, $m$. If $m$ is 0, then this entity is a file. If $m > 0$, then this entity is a directory, and it has a total of $m$ files or directories inside it. Following $m$ there will be $m$ integers giving the IDs of the entities in this directory.", "outputFormat": "Output the minimal possible total length of all relative paths to files. Note that this value may be too large to fit into a 32-bit integer.", "hint": "This input describes the example directory structure given above.\n\nThe best solution is to be in folder1. From this directory, the relative paths are:\n\n```\nfile1\nfolder2/file2\n../folder3/file3\n../file4\n```\n\nProblem credits: Mark Gordon", "locale": "en", "translations": {"en": {"title": "[USACO18FEB] Directory Traversal G", "background": "", "description": "Bessie the cow is surprisingly computer savvy. On her computer in the barn, she stores all of her precious files in a collection of directories; for example:\n\n```\nbessie/\n  folder1/\n    file1\n    folder2/\n      file2\n  folder3/\n    file3\n  file4\n```\n\nThere is a single \"top level\" directory, called bessie.\n\nBessie can navigate to be inside any directory she wants. From a given directory, any file can be referenced by a \"relative path\". In a relative path, the symbol \"..\" refers to the parent directory. If Bessie were in folder2, she could refer to the four files as follows:\n\n```\n../file1\nfile2\n../../folder3/file3\n../../file4\n```\n\nBessie would like to choose a directory from which the sum of the lengths of the relative paths to all the files is minimized.", "inputFormat": "The first line contains an integer N ($2 \\leq N \\leq 100,000$), giving the total number of files and directories. For the purposes of input, each object (file or directory) is assigned a unique integer ID between 1 and $N$, where ID 1 refers to the top level directory.\nNext, there will be $N$ lines. Each line starts with the name of a file or directory. The name will have only lower case characters a-z and digits 0-9, and will be at most 16 characters long. Following the name is an integer, $m$. If $m$ is 0, then this entity is a file. If $m > 0$, then this entity is a directory, and it has a total of $m$ files or directories inside it. Following $m$ there will be $m$ integers giving the IDs of the entities in this directory.", "outputFormat": "Output the minimal possible total length of all relative paths to files. Note that this value may be too large to fit into a 32-bit integer.", "hint": "This input describes the example directory structure given above.\n\nThe best solution is to be in folder1. From this directory, the relative paths are:\n\n```\nfile1\nfolder2/file2\n../folder3/file3\n../file4\n```\n\nProblem credits: Mark Gordon", "locale": "en"}, "zh-CN": {"title": "[USACO18FEB] Directory Traversal G", "background": "", "description": "奶牛 Bessie 出人意料地精通计算机。她在谷仓的电脑上将所有珍贵文件存储在一系列目录中；例如：\n\n```\nbessie/\n  folder1/\n    file1\n    folder2/\n      file2\n  folder3/\n    file3\n  file4\n```\n\n有一个单一的“顶级”目录，名为 `bessie`。\n\nBessie 可以导航到她想要的任何目录。从给定目录中，任何文件都可以通过“相对路径”引用。在相对路径中，符号 `..` 表示父目录。如果 Bessie 在 `folder2` 中，她可以通过以下方式引用四个文件：\n\n```\n../file1\nfile2\n../../folder3/file3\n../../file4\n```\n\nBessie 希望选择一个目录，使得从该目录到所有文件的相对路径长度之和最小。", "inputFormat": "第一行包含一个整数 $N$（$2 \\leq N \\leq 100,000$），表示文件和目录的总数。为了输入方便，每个对象（文件或目录）被分配一个唯一的整数 ID，范围在 $1$ 到 $N$ 之间，其中 ID $1$ 表示顶级目录。\n\n接下来是 $N$ 行。每行以文件或目录的名称开头。名称仅包含小写字母 `a-z` 和数字 `0-9`，且长度最多为 $16$ 个字符。名称后是一个整数 $m$。如果 $m$ 为 $0$，则该实体是一个文件。如果 $m > 0$，则该实体是一个目录，并且它内部共有 $m$ 个文件或目录。在 $m$ 之后是 $m$ 个整数，表示该目录中实体的 ID。", "outputFormat": "输出所有文件的相对路径长度的最小可能总和。请注意，此值可能超过 32 位整数的范围。", "hint": "此输入描述了上面给出的示例目录结构。\n\n最佳解决方案是位于 `folder1` 中。从该目录中，相对路径为：\n\n```\nfile1\nfolder2/file2\n../folder3/file3\n../file4\n```\n\n题目来源：Mark Gordon", "locale": "zh-CN"}}}
{"pid": "P4269", "type": "P", "difficulty": 5, "samples": [["8 7\n0 3 8 5 6 9 0 0\n0 5\n0 6\n6 2\n8 1\n10 1\n5 3\n150 7", "0\n1\n1\n0\n1\n1\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2018", "线段树", "USACO", "并查集", "单调队列", "排序"], "title": "[USACO18FEB] Snow Boots G", "background": "", "description": "It's winter on the farm, and that means snow! There are $N$ tiles on the path from the farmhouse to the barn, conveniently numbered $1 \\dots N$, and tile $i$ is covered in $f_i$ feet of snow.\nIn his farmhouse cellar, Farmer John has $B$ pairs of boots, numbered $1 \\dots B$. Some pairs are more heavy-duty than others, and some pairs are more agile than others. In particular, pair $i$ lets FJ step in snow at most $s_i$ feet deep, and lets FJ move at most $d_i$ forward in each step.\n\nFarmer John starts off on tile $1$ and must reach tile $N$ to wake up the cows. Tile $1$ is sheltered by the farmhouse roof, and tile $N$ is sheltered by the barn roof, so neither of these tiles has any snow. Help Farmer John determine which pairs of snow boots will allow him to make the trek.", "inputFormat": "The first line contains two space-separated integers $N$ and $B$ ($1 \\leq N,B \\leq 10^5$).\nThe second line contains $N$ space-separated integers; the $i$th integer is $f_i$, the depth of snow on tile $i$ ($0 \\leq f_i \\leq 10^9$). It's guaranteed that $f_1 = f_N = 0$.\n\nThe next $B$ lines contain two space-separated integers each. The first integer on line $i+2$ is $s_i$, the maximum depth of snow in which pair $i$ can step. The second integer on line $i+2$ is $d_i$, the maximum step size for pair $i$. It's guaranteed that $0 \\leq s_i \\leq 10^9$ and $1 \\leq d_i \\leq N-1$.", "outputFormat": "The output should consist of $B$ lines. Line $i$ should contain a single integer: $1$ if Farmer John can trek from tile $1$ to tile $N$ wearing the $i$th pair of boots, and $0$ otherwise.", "hint": "Problem credits: Dhruv Rohatgi", "locale": "en", "translations": {"en": {"title": "[USACO18FEB] Snow Boots G", "background": "", "description": "It's winter on the farm, and that means snow! There are $N$ tiles on the path from the farmhouse to the barn, conveniently numbered $1 \\dots N$, and tile $i$ is covered in $f_i$ feet of snow.\nIn his farmhouse cellar, Farmer John has $B$ pairs of boots, numbered $1 \\dots B$. Some pairs are more heavy-duty than others, and some pairs are more agile than others. In particular, pair $i$ lets FJ step in snow at most $s_i$ feet deep, and lets FJ move at most $d_i$ forward in each step.\n\nFarmer John starts off on tile $1$ and must reach tile $N$ to wake up the cows. Tile $1$ is sheltered by the farmhouse roof, and tile $N$ is sheltered by the barn roof, so neither of these tiles has any snow. Help Farmer John determine which pairs of snow boots will allow him to make the trek.", "inputFormat": "The first line contains two space-separated integers $N$ and $B$ ($1 \\leq N,B \\leq 10^5$).\nThe second line contains $N$ space-separated integers; the $i$th integer is $f_i$, the depth of snow on tile $i$ ($0 \\leq f_i \\leq 10^9$). It's guaranteed that $f_1 = f_N = 0$.\n\nThe next $B$ lines contain two space-separated integers each. The first integer on line $i+2$ is $s_i$, the maximum depth of snow in which pair $i$ can step. The second integer on line $i+2$ is $d_i$, the maximum step size for pair $i$. It's guaranteed that $0 \\leq s_i \\leq 10^9$ and $1 \\leq d_i \\leq N-1$.", "outputFormat": "The output should consist of $B$ lines. Line $i$ should contain a single integer: $1$ if Farmer John can trek from tile $1$ to tile $N$ wearing the $i$th pair of boots, and $0$ otherwise.", "hint": "Problem credits: Dhruv Rohatgi", "locale": "en"}, "zh-CN": {"title": "[USACO18FEB] Snow Boots G", "background": "", "description": "到冬天了，这意味着下雪了！从农舍到牛棚的路上有 $N$ 块地砖，方便起见编号为 $1 \\dots N$，第 $i$ 块地砖上积了 $f_i$ 英尺的雪。\n在 Farmer John 的农舍的地窖中，总共有 $B$ 双靴子，编号为 $1 \\dots B$。其中某些比另一些结实，某些比另一些轻便。具体地说，第 $i$ 双靴子能够让 FJ 在至多 $s_i$ 英尺深的积雪中行走，能够让 FJ 每步至多前进 $d_i$。\n\nFarmer John 从 $1$ 号地砖出发，他必须到达 $N$ 号地砖才能叫醒奶牛们。$1$ 号地砖在农舍的屋檐下，$N$ 号地砖在牛棚的屋檐下，所以这两块地砖都没有积雪。帮助 Farmer John 求出哪些靴子可以帮助他走完这段艰辛的路程。", "inputFormat": "第一行包含两个空格分隔的整数 $N$ 和 $B$（$1 \\leq N,B \\leq 10^5$）。  \n第二行包含$N$个空格分隔的整数；第 $i$ 个整数为 $f_i$，即 $i$ 号地砖的积雪深度（$0 \\leq f_i \\leq 10^9$）。输入保证 $f_1 = f_N = 0$。\n\n下面 $B$ 行，每行包含两个空格分隔的整数。第 $i+2$ 行的第一个数为 $s_i$，表示第 $i$ 双靴子能够承受的最大积雪深度。第 $i+2$ 行的第二个数为 $d_i$，表示第 $i$ 双靴子的最大步长。输入保证 $0 \\leq s_i \\leq 10^9$ 以及 $1 \\leq d_i \\leq N-1$。", "outputFormat": "输出包含 $B$ 行。第 $i$ 行包含一个整数：如果 Farmer John 能够穿着第 $i$ 双靴子从 $1$ 号地砖走到 $N$ 号地砖，为 $1$，否则为 $0$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4270", "type": "P", "difficulty": 6, "samples": [["4", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "USACO", "数论", "欧拉函数"], "title": "[USACO18FEB] Cow Gymnasts P", "background": "", "description": "Bored of farm life, the cows have sold all their earthly possessions and joined the crew of a traveling circus. So far, the cows had been given easy acts: juggling torches, walking tightropes, riding unicycles -- nothing a handy-hoofed cow couldn't handle. However, the ringmaster wants to create a much more dramatic act for their next show.\nThe stage layout for the new act involves $N$ platforms arranged in a circle. On each platform, between $1$ and $N$ cows must form a stack, cow upon cow upon cow. When the ringmaster gives the signal, all stacks must simultaneously fall clockwise, so that the bottom cow in a stack doesn't move, the cow above her moves one platform clockwise, the next cow moves two platforms clockwise, and so forth. Being accomplished gymnasts, the cows know they will have no trouble with the technical aspect of this act. The various stacks of cows will not \"interfere\" with each other as they fall, so every cow will land on the intended platform. All of the cows landing on a platform form a new stack, which does not fall over.\n\nThe ringmaster thinks the act will be particularly dramatic if after the stacks fall, the new stack on each platform contains the same number of cows as the original stack on that platform. We call a configuration of stack sizes \"magical\" if it satisfies this condition. Please help the cows by computing the number of magical configurations. Since this number may be very large, compute its remainder modulo $10^9 + 7$.\n\nTwo configurations are considered distinct if there is any platform for which the configurations assign a different number of cows.", "inputFormat": "The input is a single integer, $N$ ($1 \\leq N \\leq 10^{12}$).", "outputFormat": "A single integer giving the number of magical configurations modulo $10^9 + 7$.", "hint": "For $N = 4$, the valid configurations are $(1,1,1,1)$, $(2,2,2,2)$, $(3,3,3,3)$, $(4,4,4,4)$, $(2,3,2,3)$, and $(3,2,3,2)$.\n\nProblem credits: Dhruv Rohatgi", "locale": "en", "translations": {"en": {"title": "[USACO18FEB] Cow Gymnasts P", "background": "", "description": "Bored of farm life, the cows have sold all their earthly possessions and joined the crew of a traveling circus. So far, the cows had been given easy acts: juggling torches, walking tightropes, riding unicycles -- nothing a handy-hoofed cow couldn't handle. However, the ringmaster wants to create a much more dramatic act for their next show.\nThe stage layout for the new act involves $N$ platforms arranged in a circle. On each platform, between $1$ and $N$ cows must form a stack, cow upon cow upon cow. When the ringmaster gives the signal, all stacks must simultaneously fall clockwise, so that the bottom cow in a stack doesn't move, the cow above her moves one platform clockwise, the next cow moves two platforms clockwise, and so forth. Being accomplished gymnasts, the cows know they will have no trouble with the technical aspect of this act. The various stacks of cows will not \"interfere\" with each other as they fall, so every cow will land on the intended platform. All of the cows landing on a platform form a new stack, which does not fall over.\n\nThe ringmaster thinks the act will be particularly dramatic if after the stacks fall, the new stack on each platform contains the same number of cows as the original stack on that platform. We call a configuration of stack sizes \"magical\" if it satisfies this condition. Please help the cows by computing the number of magical configurations. Since this number may be very large, compute its remainder modulo $10^9 + 7$.\n\nTwo configurations are considered distinct if there is any platform for which the configurations assign a different number of cows.", "inputFormat": "The input is a single integer, $N$ ($1 \\leq N \\leq 10^{12}$).", "outputFormat": "A single integer giving the number of magical configurations modulo $10^9 + 7$.", "hint": "For $N = 4$, the valid configurations are $(1,1,1,1)$, $(2,2,2,2)$, $(3,3,3,3)$, $(4,4,4,4)$, $(2,3,2,3)$, and $(3,2,3,2)$.\n\nProblem credits: Dhruv Rohatgi", "locale": "en"}, "zh-CN": {"title": "[USACO18FEB] Cow Gymnasts P", "background": "", "description": "厌倦了农场生活的奶牛们卖掉了所有的财产，加入了一个巡回马戏团。到目前为止，奶牛们被分配了一些简单的表演：杂耍火炬、走钢丝、骑独轮车——没有什么是一头灵巧的奶牛无法应付的。然而，马戏团团长希望为他们的下一场演出创造一个更加戏剧性的表演。\n\n新表演的舞台布局包括 $N$ 个平台，排列成一个圆圈。在每个平台上，必须有 $1$ 到 $N$ 头奶牛堆叠成一摞，奶牛一头叠在另一头上面。当团长发出信号时，所有的堆叠必须同时顺时针倒下，使得堆叠底部的奶牛不动，她上面的奶牛移动一个平台顺时针，再上面的奶牛移动两个平台顺时针，依此类推。作为技艺高超的体操运动员，奶牛们知道她们在技术方面不会有任何问题。各个奶牛堆叠在倒下时不会相互“干扰”，因此每头奶牛都会落在目标平台上。所有落在平台上的奶牛会形成一个新的堆叠，这个堆叠不会倒下。\n\n团长认为，如果堆叠倒下后，每个平台上的新堆叠包含的奶牛数量与原始堆叠相同，那么这个表演将特别戏剧化。我们称满足这一条件的堆叠大小为“魔法”配置。请帮助奶牛们计算魔法配置的数量。由于这个数字可能非常大，请计算其对 $10^9 + 7$ 取模的结果。\n\n如果两个配置在任何平台上分配的奶牛数量不同，则认为它们是不同的配置。", "inputFormat": "输入是一个整数 $N$（$1 \\leq N \\leq 10^{12}$）。", "outputFormat": "输出一个整数，表示魔法配置的数量对 $10^9 + 7$ 取模的结果。", "hint": "对于 $N = 4$，有效的配置是 $(1,1,1,1)$、$(2,2,2,2)$、$(3,3,3,3)$、$(4,4,4,4)$、$(2,3,2,3)$ 和 $(3,2,3,2)$。\n\n题目来源：Dhruv Rohatgi", "locale": "zh-CN"}}}
{"pid": "P4271", "type": "P", "difficulty": 6, "samples": [["7\nB -1\nQ 1\nB 1\nB 2\nQ 3\nB 2\nQ 2", "0\n2\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "USACO", "并查集", "连通块", "最近公共祖先 LCA", "树的直径", "动态树 LCT"], "title": "[USACO18FEB] New Barns P", "background": null, "description": "给你一棵树，初始没有节点。你需要支持两种操作：  \n\n- `B p` 表示新建一个节点，将它与 $p$  节点连接；若 $p=-1$，则表示不与其它节点相连  \n\n- `Q k` 表示查询在 $k$ 节点所在的连通块中，距它最远的点的距离。这里距离的定义是两点间经过的边数。", "inputFormat": "第一行一个正整数 $q$，表示操作个数。  \n接下来 $q$ 行，每行表示一个操作。", "outputFormat": "对于每个询问操作，输出一行一个整数表示答案。", "hint": "【数据范围】  \n\n对于 $100\\%$ 的数据，$1 \\le q \\le 10^5$。  \n保证操作合法。\n\nThe example input corresponds to this network of barns:\n```\n  (1) \n    \\   \n     (2)---(4)\n    /\n  (3)\n```\nIn query 1, we build barn number 1. In query 2, we ask for the distance of 1 to the farthest connected barn. Since barn 1 is connected to no other barns, the answer is 0. In query 3, we build barn number 2 and connect it to barn 1. In query 4, we build barn number 3 and connect it to barn 2. In query 5, we ask for the distance of 3 to the farthest connected barn. In this case, the farthest is barn 1, which is 2 units away. In query 6, we build barn number 4 and connect it to barn 2. In query 7, we ask for the distance of 2 to the farthest connected barn. All three barns 1, 3, 4 are the same distance away, which is 1, so this is our answer.\n\nProblem credits: Anson Hu", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18FEB] New Barns P", "background": "", "description": "You need to maintain a forest that initially has no nodes. Support two types of operations:\n- `B p` builds a new node and connects it to node $p$. If $p = -1$, it is not connected to any other node.\n- `Q k` asks, within the connected component containing node $k$, for the distance to the farthest node from it. The distance is defined as the number of edges on the path between two nodes.", "inputFormat": "The first line contains a positive integer $q$, the number of operations.  \nThe next $q$ lines each describe one operation.", "outputFormat": "For each query operation, output one integer per line representing the answer.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le q \\le 10^5$. The operations are guaranteed to be valid.\n\nThe example input corresponds to this network of barns:\n```\n  (1) \n    \\   \n     (2)---(4)\n    /\n  (3)\n```\nIn query 1, we build barn number 1. In query 2, we ask for the distance of 1 to the farthest connected barn. Since barn 1 is connected to no other barns, the answer is 0. In query 3, we build barn number 2 and connect it to barn 1. In query 4, we build barn number 3 and connect it to barn 2. In query 5, we ask for the distance of 3 to the farthest connected barn. In this case, the farthest is barn 1, which is 2 units away. In query 6, we build barn number 4 and connect it to barn 2. In query 7, we ask for the distance of 2 to the farthest connected barn. All three barns 1, 3, 4 are the same distance away, which is 1, so this is our answer.\n\nProblem credits: Anson Hu.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18FEB] New Barns P", "background": null, "description": "给你一棵树，初始没有节点。你需要支持两种操作：  \n\n- `B p` 表示新建一个节点，将它与 $p$  节点连接；若 $p=-1$，则表示不与其它节点相连  \n\n- `Q k` 表示查询在 $k$ 节点所在的连通块中，距它最远的点的距离。这里距离的定义是两点间经过的边数。", "inputFormat": "第一行一个正整数 $q$，表示操作个数。  \n接下来 $q$ 行，每行表示一个操作。", "outputFormat": "对于每个询问操作，输出一行一个整数表示答案。", "hint": "【数据范围】  \n\n对于 $100\\%$ 的数据，$1 \\le q \\le 10^5$。  \n保证操作合法。\n\nThe example input corresponds to this network of barns:\n```\n  (1) \n    \\   \n     (2)---(4)\n    /\n  (3)\n```\nIn query 1, we build barn number 1. In query 2, we ask for the distance of 1 to the farthest connected barn. Since barn 1 is connected to no other barns, the answer is 0. In query 3, we build barn number 2 and connect it to barn 1. In query 4, we build barn number 3 and connect it to barn 2. In query 5, we ask for the distance of 3 to the farthest connected barn. In this case, the farthest is barn 1, which is 2 units away. In query 6, we build barn number 4 and connect it to barn 2. In query 7, we ask for the distance of 2 to the farthest connected barn. All three barns 1, 3, 4 are the same distance away, which is 1, so this is our answer.\n\nProblem credits: Anson Hu", "locale": "zh-CN"}}}
{"pid": "P4272", "type": "P", "difficulty": 6, "samples": [["3 6 2 2\n1 4 6", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2009", "CTSC/CTS"], "title": "[CTSC2009] 序列变换", "background": "", "description": "给定一个整数序列 $X_1, X_2, X_3, ... ,X_n$ 和三个正整数 $Q, A, B$ 满足：\n\n- $1 \\leq X_i \\leq Q$ 对于任意 $1 \\leq i \\leq n$；\n\n- $X_i \\leq X_{i+1}$ 对于任意 $1 \\leq i < n$；\n\n- $A \\leq \\frac{Q-1}{n-1}$ 且 $A \\leq B$。\n\n对于任意 $1 \\leq i \\leq n$，做如下变换：$Y_i = X_i + \\delta_i$，其中 $\\delta_i$ 是一个整数。使得新序列 $Y$ 满足如下性质：\n\n- $1 \\leq Y_i \\leq Q$ 对于任意 $1 \\leq i \\leq n$；\n\n- $Y_{i+1} - Y_i \\in [A, B]$ 对于任意 $1 \\leq i < n$。\n\n对于这样一个变换，所需代价定义为 $\\operatorname{TransformCost}(X, Y) = \\sum_{i = 1}^{n}{\\left\\lvert\\delta_i\\right\\rvert}$。\n\n本题的任务即为寻找一个变换，使得 $\\operatorname{TransformCost}(X, Y)$ 最小化。\n", "inputFormat": "输入文件 sequence.in 包含两行。第一行 $4$ 个整数，$N, Q, A, B$。接下来一行包含 $N$ 个整数，分别为 $X_1, X_2, X_3, ... , X_n$。", "outputFormat": "输出文件 sequence.out 仅包含一行，为最小的 $\\operatorname{TransformCost}(X, Y)$。", "hint": "### 样例说明\n\n可以将序列变换为 $2\\ 4\\ 6$ 或者 $1\\ 3\\ 5$。前者变换代价为 $1$，后者为 $2$。因此最小 $\\operatorname{TransformCost}$ 为 $1$。\n\n### 数据规模\n\n对于 $10\\%$ 的数据 , $N \\leq 100, Q \\leq 10000, 1\\leq A, B \\leq 100$。\n\n对于 $30\\%$ 的数据 , $N \\leq 10000, Q \\leq 10000, 1\\leq A, B \\leq 100$。\n\n对于 $60\\%$ 的数据 , $N \\leq 10000, Q \\leq 10^9, 1\\leq A, B \\leq Q$。\n\n对于 $100\\%$ 的数据, $N \\leq 500000, Q \\leq 10^9, 1\\leq A, B \\leq Q$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2009] Sequence Transformation", "background": "", "description": "Given an integer sequence $X_1, X_2, X_3, \\dots, X_N$ and three positive integers $Q, A, B$ that satisfy:\n\n- $1 \\leq X_i \\leq Q$ for any $1 \\leq i \\leq N$;\n- $X_i \\leq X_{i+1}$ for any $1 \\leq i < N$;\n- $A \\leq \\frac{Q - 1}{N - 1}$ and $A \\leq B$.\n\nFor any $1 \\leq i \\leq N$, perform the transformation $Y_i = X_i + \\delta_i$, where $\\delta_i$ is an integer, such that the new sequence $Y$ satisfies:\n\n- $1 \\leq Y_i \\leq Q$ for any $1 \\leq i \\leq N$;\n- $Y_{i+1} - Y_i \\in [A, B]$ for any $1 \\leq i < N$.\n\nFor such a transformation, the required cost is defined as $\\operatorname{TransformCost}(X, Y) = \\sum_{i = 1}^{N}{\\left\\lvert\\delta_i\\right\\rvert}$.\n\nThe task is to find a transformation that minimizes $\\operatorname{TransformCost}(X, Y)$.", "inputFormat": "The first line contains $4$ integers $N, Q, A, B$.  \nThe second line contains $N$ integers, namely $X_1, X_2, \\dots, X_N$.", "outputFormat": "Output a single line with the minimal $\\operatorname{TransformCost}(X, Y)$.", "hint": "Sample Explanation.\n\nYou can transform the sequence to $2\\ 4\\ 6$ or $1\\ 3\\ 5$. The former has a cost of $1$, and the latter has a cost of $2$. Therefore, the minimal $\\operatorname{TransformCost}$ is $1$.\n\nConstraints.\n\nFor $10\\%$ of the testdata, $N \\leq 100$, $Q \\leq 10000$, $1 \\leq A, B \\leq 100$.  \nFor $30\\%$ of the testdata, $N \\leq 10000$, $Q \\leq 10000$, $1 \\leq A, B \\leq 100$.  \nFor $60\\%$ of the testdata, $N \\leq 10000$, $Q \\leq 10^9$, $1 \\leq A, B \\leq Q$.  \nFor $100\\%$ of the testdata, $N \\leq 500000$, $Q \\leq 10^9$, $1 \\leq A, B \\leq Q$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2009] 序列变换", "background": "", "description": "给定一个整数序列 $X_1, X_2, X_3, ... ,X_n$ 和三个正整数 $Q, A, B$ 满足：\n\n- $1 \\leq X_i \\leq Q$ 对于任意 $1 \\leq i \\leq n$；\n\n- $X_i \\leq X_{i+1}$ 对于任意 $1 \\leq i < n$；\n\n- $A \\leq \\frac{Q-1}{n-1}$ 且 $A \\leq B$。\n\n对于任意 $1 \\leq i \\leq n$，做如下变换：$Y_i = X_i + \\delta_i$，其中 $\\delta_i$ 是一个整数。使得新序列 $Y$ 满足如下性质：\n\n- $1 \\leq Y_i \\leq Q$ 对于任意 $1 \\leq i \\leq n$；\n\n- $Y_{i+1} - Y_i \\in [A, B]$ 对于任意 $1 \\leq i < n$。\n\n对于这样一个变换，所需代价定义为 $\\operatorname{TransformCost}(X, Y) = \\sum_{i = 1}^{n}{\\left\\lvert\\delta_i\\right\\rvert}$。\n\n本题的任务即为寻找一个变换，使得 $\\operatorname{TransformCost}(X, Y)$ 最小化。\n", "inputFormat": "输入文件 sequence.in 包含两行。第一行 $4$ 个整数，$N, Q, A, B$。接下来一行包含 $N$ 个整数，分别为 $X_1, X_2, X_3, ... , X_n$。", "outputFormat": "输出文件 sequence.out 仅包含一行，为最小的 $\\operatorname{TransformCost}(X, Y)$。", "hint": "### 样例说明\n\n可以将序列变换为 $2\\ 4\\ 6$ 或者 $1\\ 3\\ 5$。前者变换代价为 $1$，后者为 $2$。因此最小 $\\operatorname{TransformCost}$ 为 $1$。\n\n### 数据规模\n\n对于 $10\\%$ 的数据 , $N \\leq 100, Q \\leq 10000, 1\\leq A, B \\leq 100$。\n\n对于 $30\\%$ 的数据 , $N \\leq 10000, Q \\leq 10000, 1\\leq A, B \\leq 100$。\n\n对于 $60\\%$ 的数据 , $N \\leq 10000, Q \\leq 10^9, 1\\leq A, B \\leq Q$。\n\n对于 $100\\%$ 的数据, $N \\leq 500000, Q \\leq 10^9, 1\\leq A, B \\leq Q$。", "locale": "zh-CN"}}}
{"pid": "P4273", "type": "P", "difficulty": 5, "samples": [["2 4 3 10\n0 1 1\n3 1 -1", "65.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2004", "NOI"], "title": "[NOI2004] 降雨量", "background": null, "description": "M 国是个多雨的国家，尤其是 P 城，频繁的降雨给人们的出行带来了不少麻烦。为了方便行人雨天过马路，有关部门在每处人行横道的上空都安装了一种名为“自动伞”的装置。（如图 $1$ 所示）\n![](https://cdn.luogu.com.cn/upload/image_hosting/109hsm74.png)\n每把自动伞都可以近似地看作一块长方形的板，厚度不计。这种伞有相当出色的吸水能力，落到上面的雨水都会完全被伞顶的小孔吸入，并通过管道运走。不下雨时，这些伞闲置着。一旦下雨，它们便立刻开始作匀速率直线往返运动：从马路的一边以固定的速率移动到另一边，再从另一边以相同的速率返回，如此往复，直到雨停为止。任何时刻自动伞都不会越过马路的边界。有了自动伞，下雨天没带伞的行人只要躲在伞下行走，就不会被雨淋着了。\n\n由于自动伞的大小有限，当需要使用自动伞过马路的人比较多时，一把自动伞显然是不够的，所以有关部门在几处主要的人行横道上空安装了多把自动伞。每把自动伞的宽度都等于人行横道的宽度，高度各不相同，长度不一定相同，移动速率也不一定相同。\n\n现在已知一处人行横道的详细情况，请你计算从开始下雨到 $T$ 秒钟后的这段时间内，一共有多少体积的雨水降落到人行横道上。", "inputFormat": "第一行有四个整数 $N$，$W$，$T$，$V$。$N$ 表示自动伞的数目，$W$ 表示马路的宽度，$T$ 表示需要统计从开始下雨到多长时间后的降雨情况，$V$ 表示单位面积单位时间内的降雨体积。\n\n为了描述方便，我们画出了一个如图 $2$ 所示的天空中五把伞的剖面图，取马路左边界为原点，取向右为 $x$ 轴正方向，取向上为 $y$ 轴正方向，建立平面直角坐标系。这样，每把自动伞都可以看作平面上的一条线段。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5z9mrtlz.png)\n\n接下来的 $N$ 行，每行用三个整数描述一把自动伞。第一个数 $x$ 是伞的初始位置，用它左端点的横坐标表示。第二个数 $l$ 是伞的长度，即 $x$ 方向上的尺寸。第三个数 $v$ 是伞的速度，$v$ 的大小表示移动的速率。如果 $v > 0$，表示开始时伞向右移动；如果 $v < 0$，表示开始时伞向左移动；如果 $v = 0$，表示伞不动。", "outputFormat": "输出文件只包含一个实数，表示从开始下雨到 $T$ 秒钟后，一共有多少体积的水降落到人行横道上。输出结果精确到小数点后第二位。", "hint": "【约定】\n\n- 雨点均匀地匀速竖直下落\n\n- 自动伞和马路两者都是水平的\n\n- 自动伞的宽度和人行横道的宽度相等，都等于 $1$\n\n- $N \\leq 10$\n\n- $W \\leq 100$\n\n- $T \\leq 100$\n\n- $V \\leq 50$\n\n- 所有自动伞的往返次数之和不超过 $250$，一来一回算一个往返。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2004] Rainfall", "background": "", "description": "Country M is very rainy, especially City P, where frequent rainfall causes trouble for people traveling. To help pedestrians cross the street on rainy days, the authorities have installed a device called the \"automatic umbrella\" above every crosswalk (see Figure 1).\n![](https://cdn.luogu.com.cn/upload/image_hosting/109hsm74.png)\nEach automatic umbrella can be approximated as a rectangular board with negligible thickness. These umbrellas have excellent water absorption: any raindrops falling on them are completely absorbed by small holes on the top and carried away through pipes. When it is not raining, the umbrellas are idle. Once it starts raining, they immediately begin uniform linear back-and-forth motion: moving from one side of the road to the other at a fixed speed, then returning at the same speed, and repeating this cycle until the rain stops. At no time does an automatic umbrella cross the boundaries of the road. With these automatic umbrellas, pedestrians without umbrellas can walk under them in the rain without getting wet.\n\nSince the umbrellas are of limited size, one umbrella is obviously not enough when many people need to use them to cross the road. Therefore, multiple automatic umbrellas are installed above several main crosswalks. The width of each umbrella equals the width of the crosswalk, their heights differ, their lengths may differ, and their speeds may also differ.\n\nGiven the detailed setup of a particular crosswalk, compute the total volume of rainwater that falls onto the crosswalk during the time interval from the start of the rain to $T$ seconds.", "inputFormat": "The first line contains four integers $N$, $W$, $T$, $V$. Here, $N$ is the number of automatic umbrellas, $W$ is the width of the road, $T$ is the time duration (in seconds) from the start of the rain over which the rainfall is to be counted, and $V$ is the rainfall volume per unit area per unit time.\n\nFor clarity, consider the cross-section view of five umbrellas in the sky as shown in Figure 2. Take the left boundary of the road as the origin, the positive $x$-axis to the right, and the positive $y$-axis upward to set up a Cartesian coordinate system. In this way, each automatic umbrella can be viewed as a line segment in the plane.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5z9mrtlz.png)\n\nEach of the next $N$ lines describes one automatic umbrella with three integers. The first number $x$ is the initial position, given by the $x$-coordinate of its left endpoint. The second number $l$ is the length of the umbrella, i.e., its size in the $x$ direction. The third number $v$ is the umbrella’s velocity; the magnitude of $v$ is its speed. If $v > 0$, the umbrella initially moves to the right; if $v < 0$, it initially moves to the left; if $v = 0$, the umbrella is stationary.", "outputFormat": "Output a single real number: the total volume of rainwater that falls onto the crosswalk from the start of the rain to time $T$ seconds. The answer should be rounded to two decimal places.", "hint": "Conventions\n- Raindrops fall uniformly, straight down at a constant speed.\n- Both the automatic umbrellas and the road are horizontal.\n- The width of each automatic umbrella and the crosswalk are both equal to $1$.\n\nConstraints\n- $N \\leq 10$.\n- $W \\leq 100$.\n- $T \\leq 100$.\n- $V \\leq 50$.\n- The total number of round trips among all umbrellas does not exceed $250$; one round trip is counted as going there and back.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2004] 降雨量", "background": null, "description": "M 国是个多雨的国家，尤其是 P 城，频繁的降雨给人们的出行带来了不少麻烦。为了方便行人雨天过马路，有关部门在每处人行横道的上空都安装了一种名为“自动伞”的装置。（如图 $1$ 所示）\n![](https://cdn.luogu.com.cn/upload/image_hosting/109hsm74.png)\n每把自动伞都可以近似地看作一块长方形的板，厚度不计。这种伞有相当出色的吸水能力，落到上面的雨水都会完全被伞顶的小孔吸入，并通过管道运走。不下雨时，这些伞闲置着。一旦下雨，它们便立刻开始作匀速率直线往返运动：从马路的一边以固定的速率移动到另一边，再从另一边以相同的速率返回，如此往复，直到雨停为止。任何时刻自动伞都不会越过马路的边界。有了自动伞，下雨天没带伞的行人只要躲在伞下行走，就不会被雨淋着了。\n\n由于自动伞的大小有限，当需要使用自动伞过马路的人比较多时，一把自动伞显然是不够的，所以有关部门在几处主要的人行横道上空安装了多把自动伞。每把自动伞的宽度都等于人行横道的宽度，高度各不相同，长度不一定相同，移动速率也不一定相同。\n\n现在已知一处人行横道的详细情况，请你计算从开始下雨到 $T$ 秒钟后的这段时间内，一共有多少体积的雨水降落到人行横道上。", "inputFormat": "第一行有四个整数 $N$，$W$，$T$，$V$。$N$ 表示自动伞的数目，$W$ 表示马路的宽度，$T$ 表示需要统计从开始下雨到多长时间后的降雨情况，$V$ 表示单位面积单位时间内的降雨体积。\n\n为了描述方便，我们画出了一个如图 $2$ 所示的天空中五把伞的剖面图，取马路左边界为原点，取向右为 $x$ 轴正方向，取向上为 $y$ 轴正方向，建立平面直角坐标系。这样，每把自动伞都可以看作平面上的一条线段。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5z9mrtlz.png)\n\n接下来的 $N$ 行，每行用三个整数描述一把自动伞。第一个数 $x$ 是伞的初始位置，用它左端点的横坐标表示。第二个数 $l$ 是伞的长度，即 $x$ 方向上的尺寸。第三个数 $v$ 是伞的速度，$v$ 的大小表示移动的速率。如果 $v > 0$，表示开始时伞向右移动；如果 $v < 0$，表示开始时伞向左移动；如果 $v = 0$，表示伞不动。", "outputFormat": "输出文件只包含一个实数，表示从开始下雨到 $T$ 秒钟后，一共有多少体积的水降落到人行横道上。输出结果精确到小数点后第二位。", "hint": "【约定】\n\n- 雨点均匀地匀速竖直下落\n\n- 自动伞和马路两者都是水平的\n\n- 自动伞的宽度和人行横道的宽度相等，都等于 $1$\n\n- $N \\leq 10$\n\n- $W \\leq 100$\n\n- $T \\leq 100$\n\n- $V \\leq 50$\n\n- 所有自动伞的往返次数之和不超过 $250$，一来一回算一个往返。", "locale": "zh-CN"}}}
{"pid": "P4274", "type": "P", "difficulty": 6, "samples": [["0.5 0.2 2 4", "3000.0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2004", "NOI", "模拟退火"], "title": "[NOI2004] 小H的小屋", "background": "", "description": "小 H 发誓要做 $21$ 世纪最伟大的数学家。他认为，做数学家与做歌星一样，第一步要作好包装，不然本事再大也推不出去。为此他决定先在自己的住所上下功夫，让人一看就知道里面住着一个“未来的大数学家”。\n\n为了描述方便，我们以向东为 $x$ 轴正方向，向北为 $y$ 轴正方向，建立平面直角坐标系。小 H 的小屋东西长为 $100$  Hil（Hil 是小 H 自己使用的长度单位，至于怎样折合成“m”，谁也不知道）。东墙和西墙均平行于 $y$ 轴，北墙和南墙分别是斜率为 $k_1$ 和 $k_2$ 的直线，$k_1$ 和 $k_2$ 为正实数。北墙和南墙的墙角处有很多块草坪，每块草坪都是一个矩形，矩形的每条边都平行于坐标轴。相邻两块草坪的接触点恰好在墙上，接触点的横坐标被称为它所在墙的“分点”，这些分点必须是 $1$ 到 $99$ 的整数。\n\n小 H 认为，对称与不对称性的结合才能充分体现“数学美”。因此，在北墙角要有 $m$ 块草坪，在南墙角要有 $n$ 块草坪，并约定 $m \\leq n$。如果记北墙和南墙的分点集合分别为 $X_1$，$X_2$，则应满足 $X_1 \\subseteq X_2$，即北墙的任何一个分点一定是南墙的分点。\n\n由于小 H 目前还没有丰厚的收入，他必须把草坪的造价降到最低，即草坪\n的占地总面积最小。你能编程帮他解决这个难题吗？", "inputFormat": "仅一行，包含 $4$ 个数 $k_1$，$k_2$，$m$，$n$。$k_1$ 和 $k_2$ 为正实数，分别表示北墙和南墙的斜率，精确到小数点后第一位。$m$ 和 $n$ 为正整数，分别表示北墙角和南墙角的草坪的块数。", "outputFormat": "一个实数，表示草坪的最小占地总面积。精确到小数点后第一位。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/y83es0b9.png)\n【约定】\n\n○ $2 \\leq m \\leq n \\leq 100$\n\n○ 南北墙距离很远，不会出现南墙草坪和北墙草坪重叠的情况", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2004] Little H's Little House", "background": "", "description": "Little H swears to become the greatest mathematician of the 21st century. He believes that, just like singers, mathematicians need good packaging; otherwise, no matter how capable you are, you cannot get noticed. Therefore, he decides to start with his residence so that at a glance people know a \"future great mathematician\" lives inside.\n\nFor convenience, we set the positive direction of the $x$-axis to the east and the positive direction of the $y$-axis to the north, establishing a Cartesian coordinate system. Little H's house is $100$ Hil long from east to west (Hil is Little H's own unit of length; as for how it converts to \"m\", nobody knows). The east and west walls are both parallel to the $y$-axis, and the north and south walls are lines with slopes $k_1$ and $k_2$, where $k_1$ and $k_2$ are positive real numbers. There are many lawns at the corners along the north wall and the south wall; each lawn is a rectangle whose sides are parallel to the coordinate axes. The contact points of adjacent lawns lie exactly on the wall, and the $x$-coordinates of these contact points are called the wall's \"division points\". These division points must be integers from $1$ to $99$.\n\nLittle H believes that the combination of symmetry and asymmetry best reflects \"mathematical beauty\". Therefore, there must be $m$ lawns along the north wall corners and $n$ lawns along the south wall corners, with $m \\leq n$. If we denote the sets of division points on the north and south walls by $X_1$ and $X_2$ respectively, then they must satisfy $X_1 \\subseteq X_2$, that is, every division point on the north wall must also be a division point on the south wall.\n\nSince Little H does not yet have a large income, he must minimize the construction cost of the lawns, i.e., minimize the total area occupied by the lawns. Can you write a program to help him solve this problem?", "inputFormat": "A single line containing $4$ numbers $k_1$, $k_2$, $m$, $n$. The numbers $k_1$ and $k_2$ are positive real numbers representing the slopes of the north and south walls, accurate to one decimal place. The numbers $m$ and $n$ are positive integers representing the number of lawns along the north wall corners and the south wall corners, respectively.", "outputFormat": "A real number, the minimal total area occupied by the lawns, to one decimal place.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/y83es0b9.png)\nConventions\n\n○ $2 \\leq m \\leq n \\leq 100$.\n\n○ The distance between the north and south walls is very large; there will be no overlap between lawns near the south wall and those near the north wall.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2004] 小H的小屋", "background": "", "description": "小 H 发誓要做 $21$ 世纪最伟大的数学家。他认为，做数学家与做歌星一样，第一步要作好包装，不然本事再大也推不出去。为此他决定先在自己的住所上下功夫，让人一看就知道里面住着一个“未来的大数学家”。\n\n为了描述方便，我们以向东为 $x$ 轴正方向，向北为 $y$ 轴正方向，建立平面直角坐标系。小 H 的小屋东西长为 $100$  Hil（Hil 是小 H 自己使用的长度单位，至于怎样折合成“m”，谁也不知道）。东墙和西墙均平行于 $y$ 轴，北墙和南墙分别是斜率为 $k_1$ 和 $k_2$ 的直线，$k_1$ 和 $k_2$ 为正实数。北墙和南墙的墙角处有很多块草坪，每块草坪都是一个矩形，矩形的每条边都平行于坐标轴。相邻两块草坪的接触点恰好在墙上，接触点的横坐标被称为它所在墙的“分点”，这些分点必须是 $1$ 到 $99$ 的整数。\n\n小 H 认为，对称与不对称性的结合才能充分体现“数学美”。因此，在北墙角要有 $m$ 块草坪，在南墙角要有 $n$ 块草坪，并约定 $m \\leq n$。如果记北墙和南墙的分点集合分别为 $X_1$，$X_2$，则应满足 $X_1 \\subseteq X_2$，即北墙的任何一个分点一定是南墙的分点。\n\n由于小 H 目前还没有丰厚的收入，他必须把草坪的造价降到最低，即草坪\n的占地总面积最小。你能编程帮他解决这个难题吗？", "inputFormat": "仅一行，包含 $4$ 个数 $k_1$，$k_2$，$m$，$n$。$k_1$ 和 $k_2$ 为正实数，分别表示北墙和南墙的斜率，精确到小数点后第一位。$m$ 和 $n$ 为正整数，分别表示北墙角和南墙角的草坪的块数。", "outputFormat": "一个实数，表示草坪的最小占地总面积。精确到小数点后第一位。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/y83es0b9.png)\n【约定】\n\n○ $2 \\leq m \\leq n \\leq 100$\n\n○ 南北墙距离很远，不会出现南墙草坪和北墙草坪重叠的情况", "locale": "zh-CN"}}}
{"pid": "P4275", "type": "P", "difficulty": 4, "samples": [["B\n2\n2 3\n1 5", "1\n3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "Fibonacci 数列"], "title": "萃香的请柬", "background": "**管理员提示：数据中存在 $l=0$，请等同于 $l=1$ 处理。**\n\n现在是宴会开始前一天\n\n![](https://cdn.luogu.com.cn/upload/pic/15052.png)", "description": "萃香在小时候就一直有一个梦想，就是邀请全乡居民一起参加宴会，在上次发动异变被灵梦退治之后她仍旧没有放弃，而是在元宵节前早早准备好了难以计数的请柬。\n\n现在，宴会即将开始，萃香却还是有一大堆请柬没有送出。经过大数学家琪露诺的严谨推算，到2018年时幻想乡的居民数目已经远远超过了外界，而这就使得宴会的邀请变得极为困难。\n\n但是，拥有\"操纵密度程度的能力\"的萃香可以分成大大小小的萃香一起去送请柬。由于小萃香的移动速度过慢，因此她决定只让大萃香曲去送请柬。\n\n开始时有S只萃香，之后每过一秒每一个大萃香会分成一大一小两个萃香，与此同时上一次分出的小萃香会积聚能量变大为大萃香。\n\n直观的说，下面是开始只有一个大萃香时前四秒的变化情况(大萃香用\"B\"表示，小萃香用\"L\"表示)\n![](https://cdn.luogu.com.cn/upload/pic/15043.png)\n\n(很容易看出，第一次的大萃香经过一秒后分成了一大一小两只萃香，之后一秒刚才分出的大萃香继续分裂，而刚才的小萃香长大为大萃香)\n\n可是，我们这位\"小小的百鬼夜行\"发现了一个严重的问题:在**经过无限长的时间**后，萃香的数目太多了。于是她决定每一次只让一段区间内的大萃香去送请柬，而她现在想要知道每一次能够送出的请柬个数。\n\n如果你能帮她完成这个任务，她就会送给你两个奖励——100分和宴会的请柬!", "inputFormat": "第一行 $S$ 个大写字母 $\\verb!B!$ 或 $\\verb!L!$，表示开始时萃香的状态。\n\n之后是一个整数 $n$ 表示询问的个数。\n\n接下来 $n$ 行每行两个整数 $l,r$ 表示询问的区间。\n", "outputFormat": "共 $n$ 行，每行一个整数 $k$，表示区间 $[l,r]$ 中大萃香的个数。", "hint": "【数据范围】:\n\n![](https://cdn.luogu.com.cn/upload/pic/15239.png)", "locale": "zh-CN", "translations": {"en": {"title": "Suika's Invitation", "background": "Admin tip: There exists $l=0$ in the testdata; please handle it the same as $l=1$.\n\nIt is now the day before the banquet begins.\n\n![](https://cdn.luogu.com.cn/upload/pic/15052.png)", "description": "Since childhood, Suika has had a dream: to invite all the residents of the village to a banquet. Even after being defeated by Reimu (Língmèng) when she caused an incident last time, she did not give up and prepared a countless number of invitations well before the Lantern Festival.\n\nNow, with the banquet about to begin, Suika still has a huge pile of invitations left to deliver. According to rigorous calculations by the great mathematician Cirno (Qílùnuò), by 2018 the population of Gensokyo has far exceeded that of the outside world, making the invitation task extremely difficult.\n\nHowever, with her \"ability to manipulate density,\" Suika can split into many Suikas of different sizes to deliver the invitations. Because the small Suikas move too slowly, she decides to let only the big Suikas go deliver the invitations.\n\nInitially, there are $S$ Suikas. Then, every second, each big Suika splits into two Suikas: one big and one small. At the same time, the small Suikas produced in the previous second accumulate energy and grow into big Suikas.\n\nIntuitively, here is what happens during the first four seconds when starting with only one big Suika (big Suika is denoted by \"B\", small Suika by \"L\"):\n![](https://cdn.luogu.com.cn/upload/pic/15043.png)\n\n(It is easy to see that the initial big Suika splits into one big and one small after one second; in the next second, the newly produced big Suika splits again, while the small Suika from the previous second grows into a big Suika.)\n\nHowever, our \"Little Pandemonium\" realized a serious problem: after an infinite amount of time, the number of Suikas becomes too large. So she decides that each time only the big Suikas within an interval will go deliver the invitations, and now she wants to know for each query how many invitations can be delivered.\n\nIf you can help her accomplish this task, she will give you two rewards — 100 points and an invitation to the banquet!", "inputFormat": "The first line contains $S$ uppercase letters $\\verb!B!$ or $\\verb!L!$, representing the initial states of the Suikas.\n\nThen an integer $n$, the number of queries.\n\nEach of the next $n$ lines contains two integers $l, r$, representing the query interval.", "outputFormat": "Output $n$ lines. Each line contains an integer $k$, the number of big Suikas in the interval $[l,r]$.", "hint": "Constraints:\n\n![](https://cdn.luogu.com.cn/upload/pic/15239.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "萃香的请柬", "background": "**管理员提示：数据中存在 $l=0$，请等同于 $l=1$ 处理。**\n\n现在是宴会开始前一天\n\n![](https://cdn.luogu.com.cn/upload/pic/15052.png)", "description": "萃香在小时候就一直有一个梦想，就是邀请全乡居民一起参加宴会，在上次发动异变被灵梦退治之后她仍旧没有放弃，而是在元宵节前早早准备好了难以计数的请柬。\n\n现在，宴会即将开始，萃香却还是有一大堆请柬没有送出。经过大数学家琪露诺的严谨推算，到2018年时幻想乡的居民数目已经远远超过了外界，而这就使得宴会的邀请变得极为困难。\n\n但是，拥有\"操纵密度程度的能力\"的萃香可以分成大大小小的萃香一起去送请柬。由于小萃香的移动速度过慢，因此她决定只让大萃香曲去送请柬。\n\n开始时有S只萃香，之后每过一秒每一个大萃香会分成一大一小两个萃香，与此同时上一次分出的小萃香会积聚能量变大为大萃香。\n\n直观的说，下面是开始只有一个大萃香时前四秒的变化情况(大萃香用\"B\"表示，小萃香用\"L\"表示)\n![](https://cdn.luogu.com.cn/upload/pic/15043.png)\n\n(很容易看出，第一次的大萃香经过一秒后分成了一大一小两只萃香，之后一秒刚才分出的大萃香继续分裂，而刚才的小萃香长大为大萃香)\n\n可是，我们这位\"小小的百鬼夜行\"发现了一个严重的问题:在**经过无限长的时间**后，萃香的数目太多了。于是她决定每一次只让一段区间内的大萃香去送请柬，而她现在想要知道每一次能够送出的请柬个数。\n\n如果你能帮她完成这个任务，她就会送给你两个奖励——100分和宴会的请柬!", "inputFormat": "第一行 $S$ 个大写字母 $\\verb!B!$ 或 $\\verb!L!$，表示开始时萃香的状态。\n\n之后是一个整数 $n$ 表示询问的个数。\n\n接下来 $n$ 行每行两个整数 $l,r$ 表示询问的区间。\n", "outputFormat": "共 $n$ 行，每行一个整数 $k$，表示区间 $[l,r]$ 中大萃香的个数。", "hint": "【数据范围】:\n\n![](https://cdn.luogu.com.cn/upload/pic/15239.png)", "locale": "zh-CN"}}}
{"pid": "P4276", "type": "P", "difficulty": 6, "samples": [["2\n4 0 0 0 4 4 4 4 0\n3 8 0 12 4 12 0\n0 \n0\n1 2\n5 5", "300.97"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "计算几何", "枚举"], "title": "封兽鵺的激光游戏", "background": "#盛大的宴会已经开始\n![](https://cdn.luogu.com.cn/upload/pic/15071.png)", "description": "在你的帮助下，萃香终于在一天内送出了所有的请柬。\n\n夜幕低垂，随着由河城荷取提供的烟花\"嗖\"的一声蹿上天际，这场盛大的宴会终于如期开始。\n\n顷刻之间，偌大的会场就已经被大家的欢声笑语充满：萃香和勇仪把酒言欢，散发着醉醺醺的酒香；帕秋莉和爱丽丝拽着魔理沙的两只胳膊争论着先逛哪边；琪露诺和大妖精在地上写写画画钻研着数学难题......一切都显得和谐而美满。\n\n可是，随着会场愈发热闹，宴会的举办者萃香总感觉还是少了些什么，转念一想，她方才发觉自己没有准备游戏活动。没有游戏的宴会又怎能叫做宴会？为了解决这个严重的问题，萃香放下了酒葫芦，找到了路边的封兽鵺请她帮忙。\n\n这可愁死封兽鵺啦！只擅长搞事情和打马赛克的她苦思冥想，终于想出了一个好主意，于是她将自己的UFO翻出来一些，再找圣白莲借几束激光，而下面就是封兽鵺制定的游戏规则：\n\n封兽鵺在平面上放置了一些实心的质量均匀的UFO(可视为凸多边形)，由于她的能力有限，所以这些UFO最多只有五条边。现在你可以从一给定点向任意方向发射一束激光(x轴正方向为0°，y轴正方形为90°，保证发射角度为两位小数，即激光从0°开始旋转，每次旋转0.01°)，激光碰到UFO的边界便会发生反射，且激光每反射一次能量便会增加w(初始能量为0)，这里要注意的是，每当一条边被激光打中过一次后便会失去反射的能力变成一条可以直接透过的边，这时候你的激光可以直接穿进UFO的内部从内部进行反射。\n\n如果你还没有理解，封兽鵺已经贴心的为你准备了下面这张图：\n![](https://cdn.luogu.com.cn/upload/pic/15112.png)\n\n本来唯恐天下不乱的封兽鵺想让激光射出时能量最大，但是萃香担心会场被破坏而将\"能量最大\"改为\"能量最接近一整数E\"。同时为了保证游戏的难度，封兽鵺会在游戏开始前将每个UFO绕重心顺时针旋转k*90°。\n\n现在，轮到了你参加这个游戏，如果你射出激光的角度与封兽鵺的答案相符，那么你就会获得两份奖励——100分和封兽鵺的写真集！\n\n当然，拥有电脑的你当然不会一次一次去试，而是通过编程预先解决这个问题，然后真正实践的时候直接用最优解拔得头筹。", "inputFormat": "第一行一个整数n，为UFO的数量。\n\n之后n行每行一个整数m，随后有m个实数对x[i],y[i]表示按顺时针顺序给出的UFO的m个顶点。\n\n之后n行每行一个整数k，表示将该UFO顺时针旋转k*90°。\n\n第2n+2行两个整数w和E，分别为每次反射激光的能量增量及规定的接近量。\n\n最后一行两个实数x0，y0表示激光的射出点。", "outputFormat": "一个实数d，保留到两位小数，表示使激光出射能量最接近E的出射角度。(如果有多个解符合题意，请输出角度最小的那个)", "hint": "【样例解释】：\n\n如图所示，当激光射出偏角为300.97度时恰好能反射两次，E1-2*w=2=E，符合题意\n![](https://cdn.luogu.com.cn/upload/pic/15105.png)\n\n#你需要特别注意的一些事:\n1. 当一束激光碰到UFO顶点的时候不认为它们相撞\n2. 多边形不会重叠，初始激光射出点不会在UFO上或UFO内\n3. 不要在这里讲科学，所以激光可以射到UFO内部进行反射\n\n\n【数据范围】：\n\n![](https://cdn.luogu.com.cn/upload/pic/15115.png)\n\n奖励：\n\n![](https://cdn.luogu.com.cn/upload/pic/15074.png)\n\n(没错就是zun绘写真集，如果你AC了此题就可以获得)\n", "locale": "zh-CN", "translations": {"en": {"title": "Houjuu Nue's Laser Game", "background": "The grand banquet has begun.\n![](https://cdn.luogu.com.cn/upload/pic/15071.png)", "description": "With your help, Suika finally delivered all the invitations in a single day.\n\nNight falls. As the fireworks provided by Nitori Kawashiro shoot into the sky with a “whoosh,” the grand banquet begins right on time.\n\nIn an instant, the huge venue fills with laughter and joy: Suika and Yuugi drink and chat, the smell of alcohol wafting around; Patchouli and Alice each pull one of Marisa’s arms, arguing about which side to explore first; Cirno and Daiyousei are scribbling on the ground, working on math problems... Everything feels harmonious and perfect.\n\nHowever, as the party gets livelier, Suika, the host, still feels like something is missing. After a moment, she realizes she forgot to prepare a game. What is a party without games? To fix this serious problem, Suika puts down her gourd and asks Houjuu Nue for help.\n\nThis gives Nue a headache! Only good at causing chaos and pixelating things, she ponders hard and finally comes up with a good idea. She takes out some of her UFOs, then borrows a few laser beams from Byakuren Hijiri. The game rules set by Houjuu Nue are as follows:\n\nHoujuu Nue places some solid, uniformly dense UFOs on the plane (each can be regarded as a convex polygon). Due to her limited ability, each UFO has at most five edges. You can fire a laser from a given point in any direction (0° along the positive x-axis, 90° along the positive y-axis; the launch angle is guaranteed to have two decimal places, i.e., the laser rotates from 0° in steps of 0.01°). When the laser hits the boundary of a UFO, it reflects. Each time it reflects, the energy increases by w (initial energy is 0). Note that once an edge is hit by the laser once, it loses its reflective ability and becomes a transparent edge. After that, your laser can pass directly into the interior of a UFO and reflect from the inside.\n\nIf you still don’t understand, Houjuu Nue has thoughtfully prepared the following diagram:\n![](https://cdn.luogu.com.cn/upload/pic/15112.png)\n\nOriginally, chaos-loving Nue wanted the laser’s energy to be as large as possible at exit, but Suika worried about damage to the venue and changed the goal to “energy closest to an integer E.” To ensure difficulty, before the game starts, Nue will rotate each UFO clockwise about its centroid by k * 90°.\n\nNow it’s your turn to play. If the angle you choose matches Nue’s answer, you will receive two prizes—100 points and Houjuu Nue’s photo book!\n\nOf course, since you have a computer, you won’t try angles one by one. You will solve the problem by programming in advance, and when it’s time to play, you will use the optimal angle to win.", "inputFormat": "- The first line contains an integer n, the number of UFOs.\n- The next n lines: each line starts with an integer m, followed by m pairs of real numbers x[i], y[i], giving the m vertices of that UFO in clockwise order.\n- The next n lines: each contains an integer k, meaning this UFO is rotated clockwise by k * 90° about its centroid.\n- The next line contains two integers w and E, the energy increment per reflection and the target integer to approach.\n- The last line contains two real numbers x0, y0, the laser’s emission point.", "outputFormat": "Output a real number d, rounded to two decimal places, the emission angle that makes the laser’s exit energy closest to E. If multiple angles satisfy the requirement, output the smallest angle.", "hint": "Sample explanation:\nAs shown in the figure, when the emission angle is 300.97°, the laser reflects exactly twice. The energy is 2 * w, which equals E, so it meets the requirement.\n![](https://cdn.luogu.com.cn/upload/pic/15105.png)\n\nThings you must pay special attention to:\n1. When a laser hits a UFO’s vertex, it is not considered a collision.\n2. Polygons do not overlap. The initial emission point is not on or inside any UFO.\n3. Don’t talk science here: the laser can enter the interior of a UFO and reflect inside.\n\nConstraints:\n![](https://cdn.luogu.com.cn/upload/pic/15115.png)\n\nRewards:\n![](https://cdn.luogu.com.cn/upload/pic/15074.png)\n\n(Yes, it’s a ZUN illustration photo book. If you AC this problem, you can get it.)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "封兽鵺的激光游戏", "background": "#盛大的宴会已经开始\n![](https://cdn.luogu.com.cn/upload/pic/15071.png)", "description": "在你的帮助下，萃香终于在一天内送出了所有的请柬。\n\n夜幕低垂，随着由河城荷取提供的烟花\"嗖\"的一声蹿上天际，这场盛大的宴会终于如期开始。\n\n顷刻之间，偌大的会场就已经被大家的欢声笑语充满：萃香和勇仪把酒言欢，散发着醉醺醺的酒香；帕秋莉和爱丽丝拽着魔理沙的两只胳膊争论着先逛哪边；琪露诺和大妖精在地上写写画画钻研着数学难题......一切都显得和谐而美满。\n\n可是，随着会场愈发热闹，宴会的举办者萃香总感觉还是少了些什么，转念一想，她方才发觉自己没有准备游戏活动。没有游戏的宴会又怎能叫做宴会？为了解决这个严重的问题，萃香放下了酒葫芦，找到了路边的封兽鵺请她帮忙。\n\n这可愁死封兽鵺啦！只擅长搞事情和打马赛克的她苦思冥想，终于想出了一个好主意，于是她将自己的UFO翻出来一些，再找圣白莲借几束激光，而下面就是封兽鵺制定的游戏规则：\n\n封兽鵺在平面上放置了一些实心的质量均匀的UFO(可视为凸多边形)，由于她的能力有限，所以这些UFO最多只有五条边。现在你可以从一给定点向任意方向发射一束激光(x轴正方向为0°，y轴正方形为90°，保证发射角度为两位小数，即激光从0°开始旋转，每次旋转0.01°)，激光碰到UFO的边界便会发生反射，且激光每反射一次能量便会增加w(初始能量为0)，这里要注意的是，每当一条边被激光打中过一次后便会失去反射的能力变成一条可以直接透过的边，这时候你的激光可以直接穿进UFO的内部从内部进行反射。\n\n如果你还没有理解，封兽鵺已经贴心的为你准备了下面这张图：\n![](https://cdn.luogu.com.cn/upload/pic/15112.png)\n\n本来唯恐天下不乱的封兽鵺想让激光射出时能量最大，但是萃香担心会场被破坏而将\"能量最大\"改为\"能量最接近一整数E\"。同时为了保证游戏的难度，封兽鵺会在游戏开始前将每个UFO绕重心顺时针旋转k*90°。\n\n现在，轮到了你参加这个游戏，如果你射出激光的角度与封兽鵺的答案相符，那么你就会获得两份奖励——100分和封兽鵺的写真集！\n\n当然，拥有电脑的你当然不会一次一次去试，而是通过编程预先解决这个问题，然后真正实践的时候直接用最优解拔得头筹。", "inputFormat": "第一行一个整数n，为UFO的数量。\n\n之后n行每行一个整数m，随后有m个实数对x[i],y[i]表示按顺时针顺序给出的UFO的m个顶点。\n\n之后n行每行一个整数k，表示将该UFO顺时针旋转k*90°。\n\n第2n+2行两个整数w和E，分别为每次反射激光的能量增量及规定的接近量。\n\n最后一行两个实数x0，y0表示激光的射出点。", "outputFormat": "一个实数d，保留到两位小数，表示使激光出射能量最接近E的出射角度。(如果有多个解符合题意，请输出角度最小的那个)", "hint": "【样例解释】：\n\n如图所示，当激光射出偏角为300.97度时恰好能反射两次，E1-2*w=2=E，符合题意\n![](https://cdn.luogu.com.cn/upload/pic/15105.png)\n\n#你需要特别注意的一些事:\n1. 当一束激光碰到UFO顶点的时候不认为它们相撞\n2. 多边形不会重叠，初始激光射出点不会在UFO上或UFO内\n3. 不要在这里讲科学，所以激光可以射到UFO内部进行反射\n\n\n【数据范围】：\n\n![](https://cdn.luogu.com.cn/upload/pic/15115.png)\n\n奖励：\n\n![](https://cdn.luogu.com.cn/upload/pic/15074.png)\n\n(没错就是zun绘写真集，如果你AC了此题就可以获得)\n", "locale": "zh-CN"}}}
{"pid": "P4277", "type": "P", "difficulty": 5, "samples": [["1\n0 0 1 1 1", "1.0000"], ["5\n0 0 0 1 1\n1 0 0 1 10\n0 0 1 0 1\n0 0 1 1 1\n2 2 1 1 1", "3.2500"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "图论", "枚举", "最短路"], "title": "河城荷取的烟花", "background": "#宴会已经接近尾声\n![](https://cdn.luogu.com.cn/upload/pic/15119.png)", "description": "快乐的时光总是这么短暂，这场宴会终究将要闭幕。\n\n为了给大家留下一个深刻而美好的印象，萃香拜托掌握着顶尖科技的河城荷取用她刚刚研制出的装置来点燃烟花。\n\n这个装置由3部分构成——一些长度为1的绳子，一些长度为$\\sqrt{ 2 }$的绳子，还有一块不能燃烧的木板。河城荷取将木板划分成长度为 1 的单元格，并标上坐标，之后将这些绳子摆在木板上连接成一个连通图(即绳子上的任意两点均可互相到达)。注意，这些绳子的两端必须放在单元格的顶点上，即长度为 1 的绳子只能放在单元格的某一边上，长度为$\\sqrt{ 2 }$的绳子只能放在单元格的某一对角线上。\n\n现在，河城荷取会在木板上任意一根绳子的端点处点火(不能从绳子的中间处点火)，点火后，火会沿着绳子向前燃烧（每根绳子都有自己的燃烧速度），并能点燃与它相接的其它绳子。\n\n比如说下面这张图，河城荷取不能在 A 点点火，但在 C 点或 B点点火都是充许的。\n\n![](https://cdn.luogu.com.cn/upload/pic/15120.png)\n\n为了演出效果，河城荷取必须保证所有绳子都燃烧完的总时间最短，可是由于绳子的条数过多，所以河城荷取找到了你来帮忙，让你帮她求出最短的总时间是多少。\n\n如果你能完成这个任务，你就会获得两个奖励——100分和观赏一场盛大的烟花盛宴！\n", "inputFormat": "第一行为一个正整数n，表示绳子的条数\n\n接下来n行每行 5 个数： X1 Y1 X2 Y2 T,其中（X1, Y1）和（X2, Y2）分别表示绳子两端的坐标，T表示这根绳子的燃烧时间，是指从绳子的某一端点火燃烧到另一端，燃完所需的时间。\n\n", "outputFormat": "第一行一个实数t，保留 4 位小数，表示所有绳子完全燃烧的最少时间。", "hint": "【样例一解释】:从任一端点火都行，燃烧时间都是 1\n\n【样例二解释】:\n\n在 (0,0)位置点火，绳子 1, 3 和 4 将被点燃，燃烧 0.5 分钟后，绳子 2 将被从中间点燃向两端燃烧，再过 0.5 分钟，绳子 1, 3, 4 将被完全燃烧，绳子5将被点燃并在 1分钟后燃烧完 (比绳子 2 早燃完)。\n\n绳子 2 从中间向两端燃烧 0.5 分钟以后，变成两小段，每段的燃烧时间是 4.5\n分钟。但因为此时两小段绳子的另一端也同时被点燃，燃烧速度变成原来的\n两倍，还需 2.25 分钟的燃烧时间， 所以总时间： 1 + 2.25 = 3.25\n\n【数据范围】:\n\n![](https://cdn.luogu.com.cn/upload/pic/15213.png)", "locale": "zh-CN", "translations": {"en": {"title": "Kawashiro Nitori's Fireworks", "background": "The banquet is nearing its end.\n![](https://cdn.luogu.com.cn/upload/pic/15119.png)", "description": "Happy times are always short; this banquet will eventually come to a close.\n\nTo leave everyone with a deep and beautiful impression, Suika asked Kawashiro Nitori, who masters cutting-edge technology, to use her newly developed device to light the fireworks.\n\nThis device consists of three parts: some ropes of length 1, some ropes of length $\\sqrt{ 2 }$, and a nonflammable wooden board. Kawashiro Nitori divides the board into unit cells of side length 1 and marks coordinates. She then lays the ropes on the board to form a connected graph (that is, any two points on the ropes can reach each other). Note that both ends of every rope must be placed on grid vertices: a rope of length 1 can only lie along an edge of a cell, and a rope of length $\\sqrt{ 2 }$ can only lie along a diagonal of a cell.\n\nNow, Kawashiro Nitori will ignite the fire at an endpoint of any rope on the board (you cannot light from the middle of a rope). After ignition, the fire propagates along the rope (each rope has its own burning time), and it can ignite any ropes connected to it.\n\nFor example, in the figure below, Kawashiro Nitori cannot light at point A, but lighting at point C or point B is allowed.\n\n![](https://cdn.luogu.com.cn/upload/pic/15120.png)\n\nFor the best performance effect, Kawashiro Nitori must minimize the total time until all ropes are completely burned. Because there are too many ropes, she asks you to help compute the minimum total time.\n\nIf you can complete this task, you will receive two rewards: 100 points and a grand fireworks show!\n\n# Description", "inputFormat": "The first line contains a positive integer n, the number of ropes.\n\nEach of the next n lines contains 5 numbers: X1 Y1 X2 Y2 T, where (X1, Y1) and (X2, Y2) are the coordinates of the two endpoints of a rope, and T is the burning time for this rope when lit from one endpoint until the fire reaches the other endpoint.", "outputFormat": "Output one real number t on the first line, with 4 decimal places, representing the minimum time for all ropes to be completely burned.", "hint": "[Sample 1 Explanation]: Igniting from either endpoint is fine; the burning time is 1.\n\n[Sample 2 Explanation]:\n\nIgnite at (0, 0). Ropes 1, 3, and 4 will be lit. After 0.5 minutes of burning, rope 2 will be ignited from its midpoint and burn toward both ends. Another 0.5 minutes later, ropes 1, 3, and 4 will be fully burned; rope 5 will be ignited and will finish burning after 1 minute (earlier than rope 2).\n\nAfter burning from the middle for 0.5 minutes, rope 2 becomes two shorter segments, each with a remaining burning time of 4.5 minutes. But since the other ends of these two segments are also lit at the same time, the burning speed doubles, so they need only 2.25 more minutes. Therefore, the total time is 1 + 2.25 = 3.25.\n\nConstraints:\n\n![](https://cdn.luogu.com.cn/upload/pic/15213.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "河城荷取的烟花", "background": "#宴会已经接近尾声\n![](https://cdn.luogu.com.cn/upload/pic/15119.png)", "description": "快乐的时光总是这么短暂，这场宴会终究将要闭幕。\n\n为了给大家留下一个深刻而美好的印象，萃香拜托掌握着顶尖科技的河城荷取用她刚刚研制出的装置来点燃烟花。\n\n这个装置由3部分构成——一些长度为1的绳子，一些长度为$\\sqrt{ 2 }$的绳子，还有一块不能燃烧的木板。河城荷取将木板划分成长度为 1 的单元格，并标上坐标，之后将这些绳子摆在木板上连接成一个连通图(即绳子上的任意两点均可互相到达)。注意，这些绳子的两端必须放在单元格的顶点上，即长度为 1 的绳子只能放在单元格的某一边上，长度为$\\sqrt{ 2 }$的绳子只能放在单元格的某一对角线上。\n\n现在，河城荷取会在木板上任意一根绳子的端点处点火(不能从绳子的中间处点火)，点火后，火会沿着绳子向前燃烧（每根绳子都有自己的燃烧速度），并能点燃与它相接的其它绳子。\n\n比如说下面这张图，河城荷取不能在 A 点点火，但在 C 点或 B点点火都是充许的。\n\n![](https://cdn.luogu.com.cn/upload/pic/15120.png)\n\n为了演出效果，河城荷取必须保证所有绳子都燃烧完的总时间最短，可是由于绳子的条数过多，所以河城荷取找到了你来帮忙，让你帮她求出最短的总时间是多少。\n\n如果你能完成这个任务，你就会获得两个奖励——100分和观赏一场盛大的烟花盛宴！\n", "inputFormat": "第一行为一个正整数n，表示绳子的条数\n\n接下来n行每行 5 个数： X1 Y1 X2 Y2 T,其中（X1, Y1）和（X2, Y2）分别表示绳子两端的坐标，T表示这根绳子的燃烧时间，是指从绳子的某一端点火燃烧到另一端，燃完所需的时间。\n\n", "outputFormat": "第一行一个实数t，保留 4 位小数，表示所有绳子完全燃烧的最少时间。", "hint": "【样例一解释】:从任一端点火都行，燃烧时间都是 1\n\n【样例二解释】:\n\n在 (0,0)位置点火，绳子 1, 3 和 4 将被点燃，燃烧 0.5 分钟后，绳子 2 将被从中间点燃向两端燃烧，再过 0.5 分钟，绳子 1, 3, 4 将被完全燃烧，绳子5将被点燃并在 1分钟后燃烧完 (比绳子 2 早燃完)。\n\n绳子 2 从中间向两端燃烧 0.5 分钟以后，变成两小段，每段的燃烧时间是 4.5\n分钟。但因为此时两小段绳子的另一端也同时被点燃，燃烧速度变成原来的\n两倍，还需 2.25 分钟的燃烧时间， 所以总时间： 1 + 2.25 = 3.25\n\n【数据范围】:\n\n![](https://cdn.luogu.com.cn/upload/pic/15213.png)", "locale": "zh-CN"}}}
{"pid": "P4278", "type": "P", "difficulty": 7, "samples": [["10\n10 5 8 28 0 19 2 31 1 22\n30\nI 6 9\nM 1 11\nI 8 17\nM 1 31\nM 6 26\nQ 2 7 6\nI 23 30\nM 31 7\nI 22 27\nM 26 18\nQ 26 17 31\nI 5 2\nI 18 13\nQ 3 3 3\nI 27 19\nQ 23 23 30\nQ 5 13 5\nI 3 0\nM 15 27\nQ 0 28 13\nQ 3 29 11\nM 2 8\nQ 12 5 7\nI 30 19\nM 11 19\nQ 17 8 29\nM 29 4\nQ 3 0 12\nI 7 18\nM 29 27", "28\n2\n31\n0\n14\n15\n14\n27\n15\n14"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["分块"], "title": "带插入区间K小值", "background": "**本题时限已经修改为 $\\text{2s}$**。\n\n**请使用常数较小的写法或者比较好的科技去过本题**。", "description": "从前有 $n$ 只跳蚤排成一行做早操，每只跳蚤都有自己的一个弹跳力 $a_i$ 。跳蚤国王看着这些跳蚤国欣欣向荣的情景，感到非常高兴。这时跳蚤国王决定理性愉悦一下，查询区间 $k$ 小值。他每次向它的随从伏特提出这样的问题：从左往右第 $x$ 个到第 $y$ 个跳蚤中，$a_i$ 第 $k$ 小的值是多少。  \n\n这可难不倒伏特，他在脑袋里使用函数式线段树前缀和的方法水掉了跳蚤国王的询问。\n\n这时伏特发现有些跳蚤跳久了弹跳力会有变化，有的会增大，有的会减少。\n\n这可难不倒伏特，他在脑袋里使用树状数组套线段树的方法水掉了跳蚤国王的询问。（orz 主席树）\n\n这时伏特发现有些迟到的跳蚤会插入到这一行的某个位置上，他感到非常生气，因为……他不会做了。\n\n请你帮一帮伏特吧。\n\n**快捷版题意：带插入、修改的区间第 $k$ 小值在线查询**。", "inputFormat": "第一行一个正整数 $n$ ，表示原来有 $n$ 只跳蚤排成一行做早操。 \n\n第二行有 $n$ 个用空格隔开的非负整数，从左至右代表每只跳蚤的弹跳力。\n\n第三行一个正整数 $q$，表示下面有多少个操作。\n\n下面一共 $q$ 行，一共三种操作对原序列的操作：（假设此时一共 $m$ 只跳蚤）\n\n1. `Q x y k`: 询问从左至右第 $x$ 只跳蚤到从左至右第 $y$ 只跳蚤中，弹跳力第 $k$ 小的跳蚤的弹跳力是多少。($1 \\le x \\le y \\le m, 1 \\le k \\le y - x + 1$)\n\n2. `M x val`: 将从左至右第 $x$ 只跳蚤的弹跳力改为 $\\textit{val}$。($1 \\le x \\le m$)\n\n3. `I x val`: 在从左至右第 $x$ 只跳蚤的前面插入一只弹跳力为 $\\textit{val}$ 的跳蚤。即插入后从左至右第 $x$ 只跳蚤是我刚插入的跳蚤。($1 \\le x \\le m + 1$)\n\n为了体现在线操作，设 $\\textit{lastans}$ 为上一次查询的时候程序输出的结果，如果之前没有查询过，则 $\\textit{lastans} = 0$。\n\n则输入的时候实际是：\n\n- `Q _x _y _k`：表示 `Q _x^lastans _y^lastans _k^lastans`\n- `M _x _val`：表示 `M _x^lastans _val^lastans`\n- `I _x _val`：表示 `I _x^lastans _val^lastans`\n\n简单来说就是操作中输入的整数都要异或上一次询问的结果进行解码。\n\n(祝 `Pascal` 的同学早日转 `C++`，就不提供 `Pascal` 版的描述了。)", "outputFormat": "对于每个询问输出回答，每行一个回答。", "hint": "$n \\le 35000$；\n插入个数 $\\le 35000$，修改个数 $\\le 70000$，查询个数 $\\le 70000$  ,$0 \\le$ 每时每刻的权值 $\\le 70000$。\n\n数据无梯度。", "locale": "zh-CN", "translations": {"en": {"title": "Range K-th Smallest with Insertions", "background": "The time limit of this problem has been changed to $\\text{2s}$.\n\nPlease use an implementation with small constants or better techniques to pass.", "description": "Once there were $n$ fleas standing in a line doing morning exercises. Each flea has its own jumping power $a_i$. The Flea King was very pleased to see their prosperity. He then decided to have some rational fun by querying the range $k$-th smallest. Each time, he asked his servant Volter the following: among the fleas from the $x$-th to the $y$-th from left to right, what is the $k$-th smallest value of $a_i$?\n\nThis did not stump Volter. He used a persistent segment tree with prefix sums in his head to deal with the king’s queries.\n\nThen Volter noticed that some fleas’ jumping power would change over time, some increasing and some decreasing.\n\nThis still did not stump Volter. He used a Binary Indexed Tree wrapped around segment trees in his head to handle the king’s queries. (orz “Chairman Tree”)\n\nHowever, Volter then found that some late fleas would be inserted at some position in the line. He became very upset because... he could not do it.\n\nPlease help Volter.\n\nQuick version of the statement: online queries for the range $k$-th smallest with insertions and modifications.", "inputFormat": "The first line contains a positive integer $n$, the initial number of fleas in a line.\n\nThe second line contains $n$ non-negative integers separated by spaces, representing each flea’s jumping power from left to right.\n\nThe third line contains a positive integer $q$, the number of operations.\n\nThen follow $q$ lines, each being one of three operations on the current sequence (suppose there are currently $m$ fleas):\n\n1. `Q x y k`: Query the $k$-th smallest jumping power among the fleas from the $x$-th to the $y$-th from left to right. ($1 \\le x \\le y \\le m, 1 \\le k \\le y - x + 1$)\n2. `M x val`: Set the jumping power of the $x$-th flea from left to right to $\\textit{val}$. ($1 \\le x \\le m$)\n3. `I x val`: Insert a flea with jumping power $\\textit{val}$ in front of the $x$-th flea from left to right. After insertion, the $x$-th flea from left to right is the newly inserted one. ($1 \\le x \\le m + 1$)\n\nTo enforce online operations, let $\\textit{lastans}$ be the result output by the program in the most recent query; if there has been no query yet, then $\\textit{lastans} = 0$.\n\nThen the actual inputs are:\n\n- `Q _x _y _k`: represents `Q _x^lastans _y^lastans _k^lastans`\n- `M _x _val`: represents `M _x^lastans _val^lastans`\n- `I _x _val`: represents `I _x^lastans _val^lastans`\n\nIn short, every integer in the operations must be XORed with the previous query’s result to decode.\n\n(Wish the classmates using `Pascal` switch to `C++` soon, so no `Pascal` version of the statement is provided.)", "outputFormat": "For each query, output the answer, one per line.", "hint": "Constraints:\n- $n \\le 35000$.\n- Number of insertions $\\le 35000$, number of modifications $\\le 70000$, number of queries $\\le 70000$, and $0 \\le$ every value at any time $\\le 70000$.\n\nThe testdata has no gradient.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "带插入区间K小值", "background": "**本题时限已经修改为 $\\text{2s}$**。\n\n**请使用常数较小的写法或者比较好的科技去过本题**。", "description": "从前有 $n$ 只跳蚤排成一行做早操，每只跳蚤都有自己的一个弹跳力 $a_i$ 。跳蚤国王看着这些跳蚤国欣欣向荣的情景，感到非常高兴。这时跳蚤国王决定理性愉悦一下，查询区间 $k$ 小值。他每次向它的随从伏特提出这样的问题：从左往右第 $x$ 个到第 $y$ 个跳蚤中，$a_i$ 第 $k$ 小的值是多少。  \n\n这可难不倒伏特，他在脑袋里使用函数式线段树前缀和的方法水掉了跳蚤国王的询问。\n\n这时伏特发现有些跳蚤跳久了弹跳力会有变化，有的会增大，有的会减少。\n\n这可难不倒伏特，他在脑袋里使用树状数组套线段树的方法水掉了跳蚤国王的询问。（orz 主席树）\n\n这时伏特发现有些迟到的跳蚤会插入到这一行的某个位置上，他感到非常生气，因为……他不会做了。\n\n请你帮一帮伏特吧。\n\n**快捷版题意：带插入、修改的区间第 $k$ 小值在线查询**。", "inputFormat": "第一行一个正整数 $n$ ，表示原来有 $n$ 只跳蚤排成一行做早操。 \n\n第二行有 $n$ 个用空格隔开的非负整数，从左至右代表每只跳蚤的弹跳力。\n\n第三行一个正整数 $q$，表示下面有多少个操作。\n\n下面一共 $q$ 行，一共三种操作对原序列的操作：（假设此时一共 $m$ 只跳蚤）\n\n1. `Q x y k`: 询问从左至右第 $x$ 只跳蚤到从左至右第 $y$ 只跳蚤中，弹跳力第 $k$ 小的跳蚤的弹跳力是多少。($1 \\le x \\le y \\le m, 1 \\le k \\le y - x + 1$)\n\n2. `M x val`: 将从左至右第 $x$ 只跳蚤的弹跳力改为 $\\textit{val}$。($1 \\le x \\le m$)\n\n3. `I x val`: 在从左至右第 $x$ 只跳蚤的前面插入一只弹跳力为 $\\textit{val}$ 的跳蚤。即插入后从左至右第 $x$ 只跳蚤是我刚插入的跳蚤。($1 \\le x \\le m + 1$)\n\n为了体现在线操作，设 $\\textit{lastans}$ 为上一次查询的时候程序输出的结果，如果之前没有查询过，则 $\\textit{lastans} = 0$。\n\n则输入的时候实际是：\n\n- `Q _x _y _k`：表示 `Q _x^lastans _y^lastans _k^lastans`\n- `M _x _val`：表示 `M _x^lastans _val^lastans`\n- `I _x _val`：表示 `I _x^lastans _val^lastans`\n\n简单来说就是操作中输入的整数都要异或上一次询问的结果进行解码。\n\n(祝 `Pascal` 的同学早日转 `C++`，就不提供 `Pascal` 版的描述了。)", "outputFormat": "对于每个询问输出回答，每行一个回答。", "hint": "$n \\le 35000$；\n插入个数 $\\le 35000$，修改个数 $\\le 70000$，查询个数 $\\le 70000$  ,$0 \\le$ 每时每刻的权值 $\\le 70000$。\n\n数据无梯度。", "locale": "zh-CN"}}}
{"pid": "P4279", "type": "P", "difficulty": 5, "samples": [["2\n3\n3 5 1\n1\n1", "John\nBrother"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["博弈论", "2008", "各省省选", "上海"], "title": "[SHOI2008] 小约翰的游戏", "background": "", "description": "小约翰经常和他的哥哥玩一个非常有趣的游戏：桌子上有 $n$ 堆石子，小约翰和他的哥哥轮流取石子，每个人取的时候，可以随意选择一堆石子，在这堆石子中取走任意多的石子，但不能一粒石子也不取，我们规定取到最后一粒石子的人算输。\n\n小约翰相当固执，他坚持认为先取的人有很大的优势，所以他总是先取石子，而他的哥哥就聪明多了，他从来没有在游戏中犯过错误。小约翰一怒之前请你来做他的参谋。自然，你应该先写一个程序，预测一下谁将获得游戏的胜利。", "inputFormat": "本题的输入由多组数据组成，第一行包括一个整数 $T$（$1 \\leq T \\leq 500$），表示输入总共有 $T$ 组数据。\n\n每组数据的第一行包括一个整数 $N$（$1 \\leq N \\leq 50$），表示共有 $N$ 堆石子，接下来有 $N$ 个不超过 $5000$ 的整数，分别表示每堆石子的数目。", "outputFormat": "对于每组数据，如果约翰能赢得比赛，则输出 `John`，否则输出 `Brother`，请注意单词的大小写。", "hint": "- 对于 $40\\%$ 的数据，$T \\leq 250$；\n- 对于 $100\\%$ 的数据，$T \\leq 500$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2008] Little John's Game", "background": "", "description": "Little John often plays a very interesting game with his older brother: On the table there are $n$ heaps of stones. Little John and his brother take turns removing stones. On each turn, a player may choose any heap and remove any positive number of stones from that heap, but may not take zero stones. We stipulate that the player who takes the last stone loses.\n\nLittle John is quite stubborn. He insists that the first player has a big advantage, so he always moves first. His brother is much smarter and has never made a mistake in the game. In anger, Little John asks you to be his adviser. Naturally, you should first write a program to predict who will win the game.", "inputFormat": "The input consists of multiple test cases. The first line contains an integer $T$ ($1 \\leq T \\leq 500$), indicating there are $T$ test cases.\n\nFor each test case, the first line contains an integer $N$ ($1 \\leq N \\leq 50$), indicating there are $N$ heaps of stones. Then follow $N$ integers, each not exceeding $5000$, representing the number of stones in each heap.", "outputFormat": "For each test case, if John can win the game, output `John`; otherwise output `Brother`. Please pay attention to letter case.", "hint": "- For $40\\%$ of the testdata, $T \\leq 250$.\n- For $100\\%$ of the testdata, $T \\leq 500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2008] 小约翰的游戏", "background": "", "description": "小约翰经常和他的哥哥玩一个非常有趣的游戏：桌子上有 $n$ 堆石子，小约翰和他的哥哥轮流取石子，每个人取的时候，可以随意选择一堆石子，在这堆石子中取走任意多的石子，但不能一粒石子也不取，我们规定取到最后一粒石子的人算输。\n\n小约翰相当固执，他坚持认为先取的人有很大的优势，所以他总是先取石子，而他的哥哥就聪明多了，他从来没有在游戏中犯过错误。小约翰一怒之前请你来做他的参谋。自然，你应该先写一个程序，预测一下谁将获得游戏的胜利。", "inputFormat": "本题的输入由多组数据组成，第一行包括一个整数 $T$（$1 \\leq T \\leq 500$），表示输入总共有 $T$ 组数据。\n\n每组数据的第一行包括一个整数 $N$（$1 \\leq N \\leq 50$），表示共有 $N$ 堆石子，接下来有 $N$ 个不超过 $5000$ 的整数，分别表示每堆石子的数目。", "outputFormat": "对于每组数据，如果约翰能赢得比赛，则输出 `John`，否则输出 `Brother`，请注意单词的大小写。", "hint": "- 对于 $40\\%$ 的数据，$T \\leq 250$；\n- 对于 $100\\%$ 的数据，$T \\leq 500$。", "locale": "zh-CN"}}}
{"pid": "P4280", "type": "P", "difficulty": 5, "samples": [["5 4\n4 2 -1 -1 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "树状数组", "安徽", "前缀和"], "title": "[AHOI2008] 逆序对", "background": "", "description": "暑假到了，小可可和伙伴们来到海边度假，距离海滩不远的地方有个小岛，叫做欢乐岛，整个岛是一个大游乐园，里面有很多很好玩的益智游戏。碰巧岛上正在举行“解谜题赢取免费门票”的活动，只要猜出来迷题，那么小可可和他的朋友就能在欢乐岛上免费游玩两天。\n\n迷题是这样的：给出一串全部是正整数的数字，这些正整数都在一个范围内选取，谁能最快求出这串数字中“逆序对”的个数，那么大奖就是他的啦！\n\n当然、主办方不可能就这么简单的让迷题被解开，数字串都是被处理过的，一部分数字被故意隐藏起来，这些数字均用-1来代替，想要获得大奖就必须求出被处理的数字串中最少能有多少个逆序对。小可可很想获得免费游玩游乐园的机会，你能帮助他吗？\n\n注：“逆序对”就是如果有两个数A和B，A在B左边且A大于B，我们就称这两个数为一个“逆序对”，例如：4 2 1 3 3里面包含了5个逆序对：(4, 2)、(4, 1)、(4, 3)、(4, 3)、(2, 1)。\n\n    假设这串数字由5个正整数组成，其中任一数字N均在1～4之间，数字串中一部分数字被“-1”替代后，如：4 2 -1 -1 3 ，那么这串数字，可能是4 2 1 3 3，也可能是4 2 4 4 3，也可能是别的样子。你要做的就是根据已知的数字，推断出这串数字里最少能有多少个逆序对。", "inputFormat": "第一行两个正整数N和K；\n\n第二行N个整数，每个都是-1或是一个在1~K之间的数（N<=10000，K<=100）。", "outputFormat": "一个正整数，即这些数字里最少的逆序对个数。", "hint": "100%的数据中，N<=10000，K<=100。\n\n60%的数据中，N<=100。\n\n40%的数据中，-1出现不超过两次。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2008] Inversions", "background": "", "description": "The summer vacation has arrived. Keke and friends are on a beach holiday. Not far from the shore lies a small island called Happy Island. The whole island is a big amusement park with many fun puzzle games. By chance, the island is running an event: “Solve puzzles to win free tickets.” If you solve the puzzle, Keke and friends can play on Happy Island for two days for free.\n\nThe puzzle is: given a sequence of positive integers, all chosen from within a certain range, whoever can find the number of “inversion pairs” in the sequence the fastest wins the prize.\n\nOf course, the organizer will not make it that easy. The sequence has been processed: some numbers are deliberately hidden and replaced by −1. To win the prize, you must find the minimum possible number of inversion pairs that the processed sequence can have. Keke really wants that free chance to play. Can you help?\n\nNote: An “inversion pair” means that if there are two numbers A and B, A is to the left of B and A > B, then (A, B) is an inversion pair. For example: in 4 2 1 3 3, there are 5 inversion pairs: (4, 2), (4, 1), (4, 3), (4, 3), (2, 1).\n\nSuppose the sequence has 5 positive integers, and each number N is between $1$ and $4$. After replacing some numbers by “−1”, e.g., 4 2 −1 −1 3, the original sequence could be 4 2 1 3 3, or 4 2 4 4 3, or something else. Your task is to infer, based on the known numbers, the minimum possible number of inversion pairs in the sequence.", "inputFormat": "The first line contains two positive integers $N$ and $K$.\n\nThe second line contains $N$ integers, each either $-1$ or a number in $1$ to $K$. ($N \\le 10000$, $K \\le 100$.)", "outputFormat": "A single positive integer: the minimum number of inversion pairs in the sequence.", "hint": "- For 100% of the testdata, $N \\le 10000$, $K \\le 100$.\n- For 60% of the testdata, $N \\le 100$.\n- For 40% of the testdata, $-1$ appears no more than twice.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2008] 逆序对", "background": "", "description": "暑假到了，小可可和伙伴们来到海边度假，距离海滩不远的地方有个小岛，叫做欢乐岛，整个岛是一个大游乐园，里面有很多很好玩的益智游戏。碰巧岛上正在举行“解谜题赢取免费门票”的活动，只要猜出来迷题，那么小可可和他的朋友就能在欢乐岛上免费游玩两天。\n\n迷题是这样的：给出一串全部是正整数的数字，这些正整数都在一个范围内选取，谁能最快求出这串数字中“逆序对”的个数，那么大奖就是他的啦！\n\n当然、主办方不可能就这么简单的让迷题被解开，数字串都是被处理过的，一部分数字被故意隐藏起来，这些数字均用-1来代替，想要获得大奖就必须求出被处理的数字串中最少能有多少个逆序对。小可可很想获得免费游玩游乐园的机会，你能帮助他吗？\n\n注：“逆序对”就是如果有两个数A和B，A在B左边且A大于B，我们就称这两个数为一个“逆序对”，例如：4 2 1 3 3里面包含了5个逆序对：(4, 2)、(4, 1)、(4, 3)、(4, 3)、(2, 1)。\n\n    假设这串数字由5个正整数组成，其中任一数字N均在1～4之间，数字串中一部分数字被“-1”替代后，如：4 2 -1 -1 3 ，那么这串数字，可能是4 2 1 3 3，也可能是4 2 4 4 3，也可能是别的样子。你要做的就是根据已知的数字，推断出这串数字里最少能有多少个逆序对。", "inputFormat": "第一行两个正整数N和K；\n\n第二行N个整数，每个都是-1或是一个在1~K之间的数（N<=10000，K<=100）。", "outputFormat": "一个正整数，即这些数字里最少的逆序对个数。", "hint": "100%的数据中，N<=10000，K<=100。\n\n60%的数据中，N<=100。\n\n40%的数据中，-1出现不超过两次。", "locale": "zh-CN"}}}
{"pid": "P4281", "type": "P", "difficulty": 4, "samples": [["6 4  \n1 2  \n2 3  \n2 4 \n4 5\n5 6\n4 5 6\n6 3 1\n2 4 4 \n6 6 6", "5 2\n2 5\n4 1\n6 0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "倍增", "各省省选", "安徽", "最近公共祖先 LCA", "树链剖分"], "title": "[AHOI2008] 紧急集合 / 聚会", "background": "", "description": "欢乐岛上有个非常好玩的游戏，叫做“紧急集合”。在岛上分散有 $n$ 个等待点，有 $n-1$ 条道路连接着它们，每一条道路都连接某两个等待点，且通过这些道路可以走遍所有的等待点，通过道路从一个点到另一个点要花费一个游戏币。\n\n参加游戏的人三人一组，开始的时候，所有人员均任意分散在各个等待点上（每个点同时允许多个人等待），每个人均带有足够多的游戏币（用于支付使用道路的花费）、地图（标明等待点之间道路连接的情况）以及对话机（用于和同组的成员联系）。当集合号吹响后，每组成员之间迅速联系，了解到自己组所有成员所在的等待点后，迅速在 $n$ 个等待点中确定一个集结点，组内所有成员将在该集合点集合，集合所用花费最少的组将是游戏的赢家。\n\n小可可和他的朋友邀请你一起参加这个游戏，由你来选择集合点，聪明的你能够完成这个任务，帮助小可可赢得游戏吗？\n", "inputFormat": "第一行两个正整数 $n$ 和 $m$，分别表示等待点的个数（等待点也从 $1$ 到 $n$ 进行编号）和获奖所需要完成集合的次数。\n\n随后 $n-1$ 行，每行两个正整数 $a,b$，表示编号为 $a$ 和编号为 $b$ 的等待点之间有一条路。\n\n随后 $m$ 行，每行用三个正整数 $x,y,z$，表示某次集合前小可可、小可可的朋友以及你所在等待点的编号。", "outputFormat": "输出共 $m$ 行，每行两个用空格隔开的整数 $p,c$。其中第 $i$ 行表示第 $i$ 次集合点选择在编号为 $p$ 的等待点，集合总共的花费是 $c$ 个游戏币。", "hint": "对于 $40\\%$ 的数据，$n\\leq2\\times10^3$，$m\\leq2\\times 10^3$。\n\n对于 $100\\%$ 的数据，$1\\leq x,y,z\\leq n\\leq 5\\times10^5$，$1\\leq m\\leq 5\\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2008] Emergency Assembly / Gathering", "background": "", "description": "On Happy Island there is a fun game called \"Emergency Assembly.\" There are $n$ waiting points scattered around the island, connected by $n-1$ roads. Each road connects two waiting points, and by these roads one can reach all waiting points. Moving along a road from one point to another costs one game coin.\n\nPlayers participate in teams of three. At the start, all players are arbitrarily located at various waiting points (each point may have multiple players waiting at the same time). Every player carries enough game coins (to pay the road costs), a map (showing the road connections between the waiting points), and a communicator (to contact their teammates). When the assembly signal sounds, teammates quickly contact each other, learn the waiting points of all members in their team, and then promptly choose one meeting point among the $n$ waiting points. All team members will gather at that meeting point. The team with the smallest total cost of gathering will be the winner.\n\nXiao Keke and friends invite you to join the game, and you are in charge of choosing the meeting point. Can you smartly complete this task and help Xiao Keke win?", "inputFormat": "The first line contains two positive integers $n$ and $m$, denoting the number of waiting points (waiting points are numbered from $1$ to $n$) and the number of gatherings that must be completed to win a prize.\n\nThen follow $n-1$ lines. Each of these lines contains two positive integers $a, b$, indicating there is a road between waiting point $a$ and waiting point $b$.\n\nThen follow $m$ lines. Each line contains three positive integers $x, y, z$, indicating, before a particular gathering, the waiting points occupied by Xiao Keke, Xiao Keke’s friend, and you, respectively.", "outputFormat": "Output $m$ lines. Each line should contain two integers $p, c$ separated by a space. The $i$-th line indicates that for the $i$-th gathering, the chosen meeting point is the waiting point numbered $p$, and the total cost of gathering is $c$ game coins.", "hint": "- For $40\\%$ of the testdata, $n \\leq 2 \\times 10^3$, $m \\leq 2 \\times 10^3$.\n- For $100\\%$ of the testdata, $1 \\leq x, y, z \\leq n \\leq 5 \\times 10^5$, $1 \\leq m \\leq 5 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2008] 紧急集合 / 聚会", "background": "", "description": "欢乐岛上有个非常好玩的游戏，叫做“紧急集合”。在岛上分散有 $n$ 个等待点，有 $n-1$ 条道路连接着它们，每一条道路都连接某两个等待点，且通过这些道路可以走遍所有的等待点，通过道路从一个点到另一个点要花费一个游戏币。\n\n参加游戏的人三人一组，开始的时候，所有人员均任意分散在各个等待点上（每个点同时允许多个人等待），每个人均带有足够多的游戏币（用于支付使用道路的花费）、地图（标明等待点之间道路连接的情况）以及对话机（用于和同组的成员联系）。当集合号吹响后，每组成员之间迅速联系，了解到自己组所有成员所在的等待点后，迅速在 $n$ 个等待点中确定一个集结点，组内所有成员将在该集合点集合，集合所用花费最少的组将是游戏的赢家。\n\n小可可和他的朋友邀请你一起参加这个游戏，由你来选择集合点，聪明的你能够完成这个任务，帮助小可可赢得游戏吗？\n", "inputFormat": "第一行两个正整数 $n$ 和 $m$，分别表示等待点的个数（等待点也从 $1$ 到 $n$ 进行编号）和获奖所需要完成集合的次数。\n\n随后 $n-1$ 行，每行两个正整数 $a,b$，表示编号为 $a$ 和编号为 $b$ 的等待点之间有一条路。\n\n随后 $m$ 行，每行用三个正整数 $x,y,z$，表示某次集合前小可可、小可可的朋友以及你所在等待点的编号。", "outputFormat": "输出共 $m$ 行，每行两个用空格隔开的整数 $p,c$。其中第 $i$ 行表示第 $i$ 次集合点选择在编号为 $p$ 的等待点，集合总共的花费是 $c$ 个游戏币。", "hint": "对于 $40\\%$ 的数据，$n\\leq2\\times10^3$，$m\\leq2\\times 10^3$。\n\n对于 $100\\%$ 的数据，$1\\leq x,y,z\\leq n\\leq 5\\times10^5$，$1\\leq m\\leq 5\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4282", "type": "P", "difficulty": 2, "samples": [["3\n3 2 5\n1 1 2\n+\n0 0 3", "2 0 0\n\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "高精度", "2008", "各省省选", "安徽", "进制"], "title": "[AHOI2008] 计算器", "background": "", "description": "小可可在欢乐岛的快乐旅程还在继续，他想买一些纪念品带回去给同学们，于是来到了礼品部，在这里他发现了一个有趣的计算器.\n\n这个计算器是一种特殊的、支持变进制整数加减运算的计算器（所谓变进制，就是每一位的进制可以不同。例如，如果最低位是 $3$ 进制，次低位是 $5$ 进制，那么这种情况的 $42$ 转化成十进制就是 $4\\times 3+2=14$）。\n\n店主看小可可对这个计算器非常感兴趣，于是他问小可可：“小朋友，如果我告诉你这个计算器最多可以支持 $N$ 位的变进制整数，且每一位的进制分别是 $x_1,x_2,\\ldots,x_n$，那么你知道它能表示的最大整数 $M$ 是多少吗?”，小可可想了想说到：“它所能表示的最大的整数 $M$ 是 $(x_1\\times x_2\\times \\cdots\\times x_n)-1$。”\n\n店主非常高兴，说道：“你真是个聪明的孩子，如果我告诉你两个长度为 $N$ 的变进制整数 $A,B$，你按照我的要求来计算 $(A＋B)\\bmod(M+1)$ 或 $(A-B)\\bmod(M+1)$，答案还是用相同的变进制来表示，如果你算对了，那么我就把这个计算器送给你。”\n\n这下把小可可难住了，但是他非常想要这个计算器，聪明的你能够帮助小可可吗?", "inputFormat": "第一行包含一个整数 $N$，表示计算器所支持的变进制数的长度。\n\n第二行包含 $N$ 个整数 $x_1,x_2,\\ldots,x_N$，表示第 $1\\sim n$ 位的进制（从最高位到最低位）。\n\n第三行包含 $N$ 个整数 $A_1,A_2,\\ldots,A_N$，表示第一个运算数。\n\n第四行包含一个字符 $op$，表示需要实现的运算类型。\n\n第五行包含 $N$ 个整数 $B_1,B_2,\\ldots,B_N$，表示第二个运算数。", "outputFormat": "若 $op$ 为 `＋`，则输出 $(A+B)\\bmod(M+1)$ 的值，否则输出 $(A-B)\\bmod(M+1)$ 的值，每一位之间用一个空格隔开，注意高位补零，最高位之前和最低位之后不要有空格。", "hint": "$100\\%$ 的数据中，$1\\le N \\le 10^5$，$1 < x_1,x_2,\\ldots x_N<100$。\n\n$30\\%$ 的数据中，$N \\le 9$，$x_1 = x_2 =\\ldots = x_N =10$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2008] Calculator", "background": "", "description": "Keke’s happy journey on Joy Island continues. He wants to buy some souvenirs for his classmates, so he goes to the gift shop and finds an interesting calculator.\n\nThis calculator is a special one that supports addition and subtraction of mixed-radix integers (mixed-radix means each digit can have a different base. For example, if the least significant digit uses base $3$ and the next digit uses base $5$, then $42$ in this system converts to decimal as $4\\times 3+2=14$).\n\nThe shopkeeper notices Keke’s interest and asks: “Kid, if I tell you this calculator supports mixed-radix integers of up to $N$ digits, and the bases for each digit are $x_1,x_2,\\ldots,x_n$, do you know the maximum integer $M$ it can represent?” Keke thinks for a while and answers: “The maximum integer $M$ it can represent is $(x_1\\times x_2\\times \\cdots\\times x_n)-1$.”\n\nThe shopkeeper is very happy and says: “You are a smart kid. If I give you two mixed-radix integers $A$ and $B$ of length $N$, compute $(A + B)\\bmod(M+1)$ or $(A - B)\\bmod(M+1)$ as required, and give the answer in the same mixed-radix system. If you get it right, I will give you this calculator.”\n\nThis stumps Keke, but he really wants the calculator. Can you help him?", "inputFormat": "- The first line contains an integer $N$, the length of the mixed-radix numbers supported by the calculator.\n- The second line contains $N$ integers $x_1,x_2,\\ldots,x_N$, the bases of digits $1\\sim N$ (from the most significant digit to the least significant digit).\n- The third line contains $N$ integers $A_1,A_2,\\ldots,A_N$, representing the first operand.\n- The fourth line contains a character $op$, representing the operation type.\n- The fifth line contains $N$ integers $B_1,B_2,\\ldots,B_N$, representing the second operand.", "outputFormat": "If $op$ is '+', output $(A+B)\\bmod(M+1)$. Otherwise, output $(A-B)\\bmod(M+1)$. Separate digits with a single space, pad with leading zeros to $N$ digits, and do not print extra spaces before the most significant digit or after the least significant digit.", "hint": "Constraints:\n- For $100\\%$ of the testdata, $1\\le N \\le 10^5$, $1 < x_1,x_2,\\ldots,x_N<100$.\n- For $30\\%$ of the testdata, $N \\le 9$, and $x_1 = x_2 = \\ldots = x_N = 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2008] 计算器", "background": "", "description": "小可可在欢乐岛的快乐旅程还在继续，他想买一些纪念品带回去给同学们，于是来到了礼品部，在这里他发现了一个有趣的计算器.\n\n这个计算器是一种特殊的、支持变进制整数加减运算的计算器（所谓变进制，就是每一位的进制可以不同。例如，如果最低位是 $3$ 进制，次低位是 $5$ 进制，那么这种情况的 $42$ 转化成十进制就是 $4\\times 3+2=14$）。\n\n店主看小可可对这个计算器非常感兴趣，于是他问小可可：“小朋友，如果我告诉你这个计算器最多可以支持 $N$ 位的变进制整数，且每一位的进制分别是 $x_1,x_2,\\ldots,x_n$，那么你知道它能表示的最大整数 $M$ 是多少吗?”，小可可想了想说到：“它所能表示的最大的整数 $M$ 是 $(x_1\\times x_2\\times \\cdots\\times x_n)-1$。”\n\n店主非常高兴，说道：“你真是个聪明的孩子，如果我告诉你两个长度为 $N$ 的变进制整数 $A,B$，你按照我的要求来计算 $(A＋B)\\bmod(M+1)$ 或 $(A-B)\\bmod(M+1)$，答案还是用相同的变进制来表示，如果你算对了，那么我就把这个计算器送给你。”\n\n这下把小可可难住了，但是他非常想要这个计算器，聪明的你能够帮助小可可吗?", "inputFormat": "第一行包含一个整数 $N$，表示计算器所支持的变进制数的长度。\n\n第二行包含 $N$ 个整数 $x_1,x_2,\\ldots,x_N$，表示第 $1\\sim n$ 位的进制（从最高位到最低位）。\n\n第三行包含 $N$ 个整数 $A_1,A_2,\\ldots,A_N$，表示第一个运算数。\n\n第四行包含一个字符 $op$，表示需要实现的运算类型。\n\n第五行包含 $N$ 个整数 $B_1,B_2,\\ldots,B_N$，表示第二个运算数。", "outputFormat": "若 $op$ 为 `＋`，则输出 $(A+B)\\bmod(M+1)$ 的值，否则输出 $(A-B)\\bmod(M+1)$ 的值，每一位之间用一个空格隔开，注意高位补零，最高位之前和最低位之后不要有空格。", "hint": "$100\\%$ 的数据中，$1\\le N \\le 10^5$，$1 < x_1,x_2,\\ldots x_N<100$。\n\n$30\\%$ 的数据中，$N \\le 9$，$x_1 = x_2 =\\ldots = x_N =10$。", "locale": "zh-CN"}}}
{"pid": "P4283", "type": "P", "difficulty": 3, "samples": [["3 CAT\n3 TAC\n5 CATCH", "8\n\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2008", "各省省选", "安徽"], "title": "[AHOI2008] Y型项链", "background": null, "description": "欢乐岛上众多新奇的游乐项目让小可可他们玩的非常开心。现在他们正在玩比赛串项链的游戏，谁串的最快就能得到优厚的奖品。\n\n这可不是普通的项链，而是一种 Y 型项链，项链的最中间有一颗大珍珠作为结合点，从大珍珠上连出来 3 条由各种宝石串起来的链子。\n\n比赛的规则是这样的：每次可以从三条链子中某一条的末端取下来一个宝石，或者安上去一个宝石，称为一次操作，经过若干次操作，最终使得三条链子完全相同。想要赢得比赛，那么只能使用尽量少的操作次数。\n\n假设每种宝石都有无数多个以供使用，且链子足够长。你能帮助小可可赢得比赛吗？\n\n注：由于对 Y 型项链的宝石数没有特殊的要求，所以即使你把所有宝石都取下来，也是一个可以接受的方案（三根没有串宝石的绳子也是完全一样的）。", "inputFormat": "一共有 $3$ 行，表示 Y 型项链的三条链子，每行开始有一个整数 $N$ ，表示初始时这条链子上串有 $N$ 个宝石，随后是一个空格，然后是 $N$ 个大写字母，表示这个链子上的宝石，每个字母表示一种不同的宝石，这个字符串最左边的字符表示的是离大珍珠最近的那个宝石，而最右边的表示的是在链子末端的宝石。", "outputFormat": "只有一个整数，表示所需要的最少的操作次数。", "hint": "对于 $50\\%$ 的数据，$N\\leq 20$。\n\n对于 $100\\%$ 的数据，$1\\le N\\le 50$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2008] Y-shaped Necklace", "background": "", "description": "The many novel attractions on Happy Island make Xiao Keke and friends very happy. They are now competing in a necklace-threading game; whoever finishes the fastest wins a generous prize.\n\nThis is not an ordinary necklace, but a Y-shaped necklace. At the very center there is a big pearl serving as the junction, and from it extend 3 chains strung with various gemstones.\n\nThe rules are as follows: each time, you may either take one gemstone off from the end of one of the three chains, or attach one gemstone to the end of one of the three chains. This counts as one operation. After a number of operations, the goal is to make the three chains exactly the same. To win, you must use as few operations as possible.\n\nAssume there are infinitely many of each type of gemstone available, and the chains are long enough. Can you help Xiao Keke win?\n\nNote: Because there is no special requirement on the number of gemstones on the Y-shaped necklace, removing all gemstones is also an acceptable plan (three strings without gemstones are identical).", "inputFormat": "There are $3$ lines, describing the three chains of the Y-shaped necklace. Each line begins with an integer $N$, indicating the number of gemstones initially on this chain, followed by a space, and then $N$ uppercase letters representing the gemstones on this chain. Each letter denotes a type of gemstone. The leftmost character of the string is the gemstone closest to the big pearl, and the rightmost character is the gemstone at the end of the chain.", "outputFormat": "Output a single integer: the minimum number of operations required.", "hint": "For $50\\%$ of the testdata, $N\\leq 20$.\n\nFor $100\\%$ of the testdata, $1\\le N\\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2008] Y型项链", "background": null, "description": "欢乐岛上众多新奇的游乐项目让小可可他们玩的非常开心。现在他们正在玩比赛串项链的游戏，谁串的最快就能得到优厚的奖品。\n\n这可不是普通的项链，而是一种 Y 型项链，项链的最中间有一颗大珍珠作为结合点，从大珍珠上连出来 3 条由各种宝石串起来的链子。\n\n比赛的规则是这样的：每次可以从三条链子中某一条的末端取下来一个宝石，或者安上去一个宝石，称为一次操作，经过若干次操作，最终使得三条链子完全相同。想要赢得比赛，那么只能使用尽量少的操作次数。\n\n假设每种宝石都有无数多个以供使用，且链子足够长。你能帮助小可可赢得比赛吗？\n\n注：由于对 Y 型项链的宝石数没有特殊的要求，所以即使你把所有宝石都取下来，也是一个可以接受的方案（三根没有串宝石的绳子也是完全一样的）。", "inputFormat": "一共有 $3$ 行，表示 Y 型项链的三条链子，每行开始有一个整数 $N$ ，表示初始时这条链子上串有 $N$ 个宝石，随后是一个空格，然后是 $N$ 个大写字母，表示这个链子上的宝石，每个字母表示一种不同的宝石，这个字符串最左边的字符表示的是离大珍珠最近的那个宝石，而最右边的表示的是在链子末端的宝石。", "outputFormat": "只有一个整数，表示所需要的最少的操作次数。", "hint": "对于 $50\\%$ 的数据，$N\\leq 20$。\n\n对于 $100\\%$ 的数据，$1\\le N\\le 50$。", "locale": "zh-CN"}}}
{"pid": "P4284", "type": "P", "difficulty": 6, "samples": [["3\n1 2 50\n1 3 50\n50 0 0", "1.000000"], ["5\n1 2 90\n1 3 80\n1 4 70\n1 5 60\n100 10 20 30 40", "4.300000"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "各省省选", "上海", "连通块", "概率论", "期望"], "title": "[SHOI2014] 概率充电器", "background": null, "description": "著名的电子产品品牌 SHOI 刚刚发布了引领世界潮流的下一代电子产品——概率充电器：\n\n“采用全新纳米级加工技术，实现元件与导线能否通电完全由真随机数决定！SHOI 概率充电器，您生活不可或缺的必需品！能充上电吗？现在就试试看吧！”\n\nSHOI 概率充电器由 $n-1$ 条导线连通了 $n$ 个充电元件。进行充电时，每条导线是否可以导电以概率决定，每一个充电元件自身是否直接进行充电也由概率决定。随后电能可以从直接充电的元件经过通电的导线使得其他充电元件进行间接充电。\n\n作为 SHOI 公司的忠实客户，你无法抑制自己购买 SHOI 产品的冲动。在排了一个星期的长队之后终于入手了最新型号的 SHOI 概率充电器。你迫不及待地将 SHOI 概率充电器插入电源——这时你突然想知道，进入充电状态的元件个数的期望是多少呢？", "inputFormat": "第一行一个整数 $n$。概率充电器的充电元件个数。充电元件由 $1 \\sim n$ 编号。\n\n之后的 $n-1$ 行每行三个整数 $a, b, p$，描述了一根导线连接了编号为 $a$ 和 $b$ 的充电元件，通电概率为 $p\\%$。\n\n第 $n+1$ 行 $n$ 个整数 $q_i$。表示 $i$ 号元件直接充电的概率为 $q_i\\%$。", "outputFormat": "输出一行一个实数，为能进入充电状态的元件个数的期望，四舍五入到小数点后 $6$ 位小数。", "hint": "对于 $30\\%$ 的数据，$n \\leq 5 \\times 10^3$。\n\n对于 $100\\%$ 的数据，$n \\leq 5 \\times 10^5$，$0 \\leq p,q_i \\leq 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2014] Probability Charger", "background": "", "description": "The famous electronics brand SHOI has just released the next-generation product leading the global trend — the Probability Charger:\n\n“Using brand-new nano-scale fabrication technology, whether components and wires conduct is determined entirely by true random numbers! The SHOI Probability Charger, an indispensable necessity in your life! Can it charge? Try it now!”\n\nThe SHOI Probability Charger connects $n$ charging components with $n-1$ wires. During charging, whether each wire can conduct is decided by probability, and whether each component charges directly is also decided by probability. Then electric energy can travel from components that charge directly, through conducting wires, to make other components charge indirectly.\n\nAs a loyal customer of SHOI, you cannot resist the impulse to buy SHOI products. After waiting in a long line for a week, you finally get the latest model of the SHOI Probability Charger. You eagerly plug it into the power source — and suddenly wonder: what is the expected number of components that enter the charging state?", "inputFormat": "The first line contains an integer $n$, the number of charging components. The components are numbered $1 \\sim n$.\n\nEach of the next $n-1$ lines contains three integers $a, b, p$, describing a wire connecting components $a$ and $b$, with conduction probability $p\\%$.\n\nThe $(n+1)$-th line contains $n$ integers $q_i$, meaning that component $i$ charges directly with probability $q_i\\%$.", "outputFormat": "Output one real number: the expected number of components that enter the charging state, rounded to 6 decimal places.", "hint": "- Constraints:\n  - For $30\\%$ of the testdata, $n \\leq 5 \\times 10^3$.\n  - For $100\\%$ of the testdata, $n \\leq 5 \\times 10^5$, $0 \\leq p, q_i \\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2014] 概率充电器", "background": null, "description": "著名的电子产品品牌 SHOI 刚刚发布了引领世界潮流的下一代电子产品——概率充电器：\n\n“采用全新纳米级加工技术，实现元件与导线能否通电完全由真随机数决定！SHOI 概率充电器，您生活不可或缺的必需品！能充上电吗？现在就试试看吧！”\n\nSHOI 概率充电器由 $n-1$ 条导线连通了 $n$ 个充电元件。进行充电时，每条导线是否可以导电以概率决定，每一个充电元件自身是否直接进行充电也由概率决定。随后电能可以从直接充电的元件经过通电的导线使得其他充电元件进行间接充电。\n\n作为 SHOI 公司的忠实客户，你无法抑制自己购买 SHOI 产品的冲动。在排了一个星期的长队之后终于入手了最新型号的 SHOI 概率充电器。你迫不及待地将 SHOI 概率充电器插入电源——这时你突然想知道，进入充电状态的元件个数的期望是多少呢？", "inputFormat": "第一行一个整数 $n$。概率充电器的充电元件个数。充电元件由 $1 \\sim n$ 编号。\n\n之后的 $n-1$ 行每行三个整数 $a, b, p$，描述了一根导线连接了编号为 $a$ 和 $b$ 的充电元件，通电概率为 $p\\%$。\n\n第 $n+1$ 行 $n$ 个整数 $q_i$。表示 $i$ 号元件直接充电的概率为 $q_i\\%$。", "outputFormat": "输出一行一个实数，为能进入充电状态的元件个数的期望，四舍五入到小数点后 $6$ 位小数。", "hint": "对于 $30\\%$ 的数据，$n \\leq 5 \\times 10^3$。\n\n对于 $100\\%$ 的数据，$n \\leq 5 \\times 10^5$，$0 \\leq p,q_i \\leq 100$。", "locale": "zh-CN"}}}
{"pid": "P4285", "type": "P", "difficulty": 6, "samples": [["3\nAB BC CA BA CB AC", "7"], ["2\nAB BA CA BC CB AC", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "2008", "各省省选", "递归", "上海", "线性递推"], "title": "[SHOI2008] 汉诺塔", "background": null, "description": "汉诺塔由三根柱子（分别用 A、B、C 表示）和 $n$ 个大小互不相同的空心盘子组成。一开始 $n$ 个盘子都摞在柱子 A 上，大的在下面，小的在上面，形成了一个塔状的锥形体。\n\n对汉诺塔的一次合法的操作是指：从一根柱子的最上层拿一个盘子放到另一根柱子的最上层，同时要保证被移动的盘子一定放在比它更大的盘子上面（如果移动到空柱子上就不需要满足这个要求）。我们可以用两个字母来描述一次操作：第一个字母代表起始柱子，第二个字母代表目标柱子。例如，AB 就是把柱子 A 最上面的那个盘子移到柱子B。汉诺塔的游戏目标是将所有的盘子从柱子 A 移动到柱子 B 或柱子 C 上面。\n\n有一种非常简洁而经典的策略可以帮助我们完成这个游戏。首先，在任何操作执行之前，我们以任意的次序为六种操作（AB、AC、BA、BC、CA 和 CB）赋予不同的优先级，然后，我们总是选择符合以下两个条件的操作来移动盘子，直到所有的盘子都从柱子 A 移动到另一根柱子：\n\n1. 这种操作是所有合法操作中优先级最高的；\n2. 这种操作所要移动的盘子不是上一次操作所移动的那个盘子。\n\n可以证明，上述策略一定能完成汉诺塔游戏。现在你的任务就是假设给定了每种操作的优先级，计算按照上述策略操作汉诺塔移动所需要的步骤数。\n\n![](https://cdn.luogu.com.cn/upload/pic/21997.png)", "inputFormat": "输入有两行。第一行为一个整数 $n(1≤n≤30)$，代表盘子的个数。第二行是一串大写的 ABC 字符，代表六种操作的优先级，靠前的操作具有较高的优先级。每种操作都由一个空格隔开。", "outputFormat": "只需输出一个数，这个数表示移动的次数。我们保证答案不会超过 $10^{18}$。", "hint": "对于 $20\\%$ 的数据，$n≤10$。  \n对于 $100\\%$ 的数据，$1\\le n≤30$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2008] Towers of Hanoi", "background": "# Description\n\nThe Towers of Hanoi consists of three pegs (denoted A, B, C) and $n$ disks of distinct sizes. Initially, all $n$ disks are stacked on peg A, with larger disks below smaller ones, forming a conical tower.\n\nA legal move is: take the top disk from one peg and place it on top of another peg, with the constraint that the moved disk must be placed on a larger disk (this constraint is waived if the target peg is empty). We can describe a move with two letters: the first letter is the source peg, and the second is the destination peg. For example, AB means moving the top disk from peg A to peg B. The goal of the game is to move all disks from peg A onto either peg B or peg C.\n\nThere is a concise and classic strategy to complete this game. Before any move, assign distinct priorities, in any order, to the six possible moves: AB, AC, BA, BC, CA, CB. Then, repeatedly choose the move that satisfies both conditions below, until all disks have been moved from peg A to another peg:\n(1) Among all legal moves, it has the highest priority.\n(2) The disk to be moved is not the same disk that was moved in the previous step.\n\nIt can be proven that this strategy will always complete the Towers of Hanoi. Your task is: given the priority of each move, compute the number of steps needed under the strategy above.\n\n![](https://cdn.luogu.com.cn/upload/pic/21997.png)", "description": "The Towers of Hanoi consists of three pegs (denoted A, B, C) and $n$ disks of distinct sizes. Initially, all $n$ disks are stacked on peg A, with larger disks below smaller ones, forming a conical tower.\n\nA legal move is: take the top disk from one peg and place it on top of another peg, with the constraint that the moved disk must be placed on a larger disk (this constraint is waived if the target peg is empty). We can describe a move with two letters: the first letter is the source peg, and the second is the destination peg. For example, AB means moving the top disk from peg A to peg B. The goal of the game is to move all disks from peg A onto either peg B or peg C.\n\nThere is a concise and classic strategy to complete this game. Before any move, assign distinct priorities, in any order, to the six possible moves: AB, AC, BA, BC, CA, CB. Then, repeatedly choose the move that satisfies both conditions below, until all disks have been moved from peg A to another peg:\n(1) Among all legal moves, it has the highest priority.\n(2) The disk to be moved is not the same disk that was moved in the previous step.\n\nIt can be proven that this strategy will always complete the Towers of Hanoi. Your task is: given the priority of each move, compute the number of steps needed under the strategy above.\n\n![](https://cdn.luogu.com.cn/upload/pic/21997.png)\n\n# Description", "inputFormat": "The input consists of two lines.\n- The first line contains an integer $n$ ($1 \\le n \\le 30$), the number of disks.\n- The second line contains the six moves as a permutation of AB, AC, BA, BC, CA, CB, separated by spaces, where earlier moves have higher priority.", "outputFormat": "Output a single integer: the number of moves. It is guaranteed that the answer does not exceed $10^{18}$.", "hint": "- For 20% of the testdata, $n \\le 10$.\n- For 100% of the testdata, $n \\le 30$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2008] 汉诺塔", "background": null, "description": "汉诺塔由三根柱子（分别用 A、B、C 表示）和 $n$ 个大小互不相同的空心盘子组成。一开始 $n$ 个盘子都摞在柱子 A 上，大的在下面，小的在上面，形成了一个塔状的锥形体。\n\n对汉诺塔的一次合法的操作是指：从一根柱子的最上层拿一个盘子放到另一根柱子的最上层，同时要保证被移动的盘子一定放在比它更大的盘子上面（如果移动到空柱子上就不需要满足这个要求）。我们可以用两个字母来描述一次操作：第一个字母代表起始柱子，第二个字母代表目标柱子。例如，AB 就是把柱子 A 最上面的那个盘子移到柱子B。汉诺塔的游戏目标是将所有的盘子从柱子 A 移动到柱子 B 或柱子 C 上面。\n\n有一种非常简洁而经典的策略可以帮助我们完成这个游戏。首先，在任何操作执行之前，我们以任意的次序为六种操作（AB、AC、BA、BC、CA 和 CB）赋予不同的优先级，然后，我们总是选择符合以下两个条件的操作来移动盘子，直到所有的盘子都从柱子 A 移动到另一根柱子：\n\n1. 这种操作是所有合法操作中优先级最高的；\n2. 这种操作所要移动的盘子不是上一次操作所移动的那个盘子。\n\n可以证明，上述策略一定能完成汉诺塔游戏。现在你的任务就是假设给定了每种操作的优先级，计算按照上述策略操作汉诺塔移动所需要的步骤数。\n\n![](https://cdn.luogu.com.cn/upload/pic/21997.png)", "inputFormat": "输入有两行。第一行为一个整数 $n(1≤n≤30)$，代表盘子的个数。第二行是一串大写的 ABC 字符，代表六种操作的优先级，靠前的操作具有较高的优先级。每种操作都由一个空格隔开。", "outputFormat": "只需输出一个数，这个数表示移动的次数。我们保证答案不会超过 $10^{18}$。", "hint": "对于 $20\\%$ 的数据，$n≤10$。  \n对于 $100\\%$ 的数据，$1\\le n≤30$。", "locale": "zh-CN"}}}
{"pid": "P4286", "type": "P", "difficulty": 6, "samples": [["1 2\n-9 -6\n5 1\n3\n0 16\n-16 -12\n17 -6", "0.00"], ["2 3\n12 4\n16 17\n3 9\n4\n1 0\n4 19\n19 14\n6 12\n3\n10 10\n5 3\n18 2", "2.94"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "上海"], "title": "[SHOI2008] 安全的航线", "background": "", "description": "在设计航线的时候，安全是一个很重要的问题。首先，最重要的是应采取一切措施确保飞行不会发生任何事故，但同时也需要做好最坏的打算，一旦事故发生，就要确保乘客有尽量高的生还几率。\n\n当飞机迫降到海上的时候，最近的陆地就是一个关键的因素。航线中最危险的地方就是距离最近的陆地最远的地方，我们称这种点为这条航线“孤地点”。孤地点到最近陆地的距离被称为“孤地距离”。作为航空公司的高级顾问，你接受的第一个任务就是尽量找出一条航线的孤地点，并计算这条航线的孤地距离。\n\n为了简化问题，我们认为地图是一个二维平面，陆地可以用多边形近似，飞行线路为一条折线。航线的起点和终点都在陆地上，但中间的转折点是可能在海上（如下图所示，方格标示出了孤地点）。\n\n![](https://cdn.luogu.com.cn/upload/pic/15457.png)", "inputFormat": "输入的第一行包括两个整数C和N（1≤C≤20，2≤N≤20），分别代表陆地的数目的航线的转折点的数目。\n\n接下来有N行，每行有两个整数x,y。(x,y)表示一个航线转折点的坐标，第一个转折点为航线的起点，最后一个转折点为航线的终点。\n\n接下来的输入将用来描述C块大陆。每块输入由一个正整数M开始（M≤30），M表示多边形的顶点个数，接下来的M行，每行会包含两个整数x,y，(x,y)表示多边形的一个顶点坐标，我们保证这些顶点以顺时针或逆时针给出了该多边形的闭包，不会出现某些边相交的情况。此外我们也保证输入数据中任何两块大陆不会相交。\n\n输入的所有坐标将保证在-10,000到10,000的范围之间。", "outputFormat": "输出一个浮点数，表示航线的孤地距离，数据保留2位小数。", "hint": "对于50%的数据，1≤C≤2，2≤N≤5;\n\n对于100%的数据，1≤C≤20，2≤N≤20。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2008] Safe Air Route", "background": "", "description": "When designing air routes, safety is a crucial concern. First, the most important thing is to take every measure to ensure that no accident occurs during flight. At the same time, we must also prepare for the worst: if an accident happens, passengers should have the highest possible chance of survival.\n\nWhen a plane makes an emergency landing on the sea, the nearest land becomes a key factor. The most dangerous location along a route is the point that is farthest from the nearest land; we call such a point the route’s “isolation point.” The distance from the isolation point to the closest land is called the “isolation distance.” As a senior consultant for an airline, your first task is to find a route’s isolation point as best as possible and compute this route’s isolation distance.\n\nTo simplify the problem, we consider the map as a 2D plane, land masses are approximated by polygons, and the flight route is a polyline. The start and end points of the route lie on land, but intermediate turning points may be on the sea (as shown in the figure below; the grid marks the isolation point).\n\n![](https://cdn.luogu.com.cn/upload/pic/15457.png)", "inputFormat": "The first line contains two integers $C$ and $N$ ($1 \\le C \\le 20$, $2 \\le N \\le 20$), representing the number of land masses and the number of turning points of the route, respectively.\n\nThen there are $N$ lines, each containing two integers $x, y$. The pair $(x, y)$ is the coordinate of a turning point of the route. The first turning point is the start of the route, and the last turning point is the end of the route.\n\nThe next part of the input describes the $C$ land masses. Each land mass starts with a positive integer $M$ ($M \\le 30$), the number of vertices of the polygon. The following $M$ lines each contain two integers $x, y$, which are the coordinates of a polygon vertex. We guarantee that these vertices are given in clockwise or counterclockwise order and form a simple closed polygon (no edges intersect). We also guarantee that any two land masses do not intersect.\n\nAll coordinates are within the range from −10,000 to 10,000.", "outputFormat": "Output a floating-point number representing the route’s “isolation distance,” rounded to exactly 2 decimal places.", "hint": "For 50% of the testdata, $1 \\le C \\le 2$, $2 \\le N \\le 5$.  \nFor 100% of the testdata, $1 \\le C \\le 20$, $2 \\le N \\le 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2008] 安全的航线", "background": "", "description": "在设计航线的时候，安全是一个很重要的问题。首先，最重要的是应采取一切措施确保飞行不会发生任何事故，但同时也需要做好最坏的打算，一旦事故发生，就要确保乘客有尽量高的生还几率。\n\n当飞机迫降到海上的时候，最近的陆地就是一个关键的因素。航线中最危险的地方就是距离最近的陆地最远的地方，我们称这种点为这条航线“孤地点”。孤地点到最近陆地的距离被称为“孤地距离”。作为航空公司的高级顾问，你接受的第一个任务就是尽量找出一条航线的孤地点，并计算这条航线的孤地距离。\n\n为了简化问题，我们认为地图是一个二维平面，陆地可以用多边形近似，飞行线路为一条折线。航线的起点和终点都在陆地上，但中间的转折点是可能在海上（如下图所示，方格标示出了孤地点）。\n\n![](https://cdn.luogu.com.cn/upload/pic/15457.png)", "inputFormat": "输入的第一行包括两个整数C和N（1≤C≤20，2≤N≤20），分别代表陆地的数目的航线的转折点的数目。\n\n接下来有N行，每行有两个整数x,y。(x,y)表示一个航线转折点的坐标，第一个转折点为航线的起点，最后一个转折点为航线的终点。\n\n接下来的输入将用来描述C块大陆。每块输入由一个正整数M开始（M≤30），M表示多边形的顶点个数，接下来的M行，每行会包含两个整数x,y，(x,y)表示多边形的一个顶点坐标，我们保证这些顶点以顺时针或逆时针给出了该多边形的闭包，不会出现某些边相交的情况。此外我们也保证输入数据中任何两块大陆不会相交。\n\n输入的所有坐标将保证在-10,000到10,000的范围之间。", "outputFormat": "输出一个浮点数，表示航线的孤地距离，数据保留2位小数。", "hint": "对于50%的数据，1≤C≤2，2≤N≤5;\n\n对于100%的数据，1≤C≤20，2≤N≤20。", "locale": "zh-CN"}}}
{"pid": "P4287", "type": "P", "difficulty": 6, "samples": [["16\nggabaabaabaaball", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["字符串", "2011", "各省省选", "上海", "回文自动机 PAM", "Manacher 算法"], "title": "[SHOI2011] 双倍回文", "background": "", "description": "记字符串 $w$ 的倒置为 $w^{\\mathsf R}$。例如$\\tt (abcd)^{\\mathsf R}=dcba$，$\\tt (abba)^{\\mathsf R}=abba$。\n\n对字符串 $x$，如果 $x$ 满足 $x^{\\mathsf R}=x$，则称之为回文。例如 $\\tt abba$ 是一个回文，而 $\\tt abed$ 不是。\n\n如果 $x$ 能够写成 $ww^{\\mathsf R} ww^{\\mathsf R}$ 形式，则称它是一个“双倍回文”。换句话说，若要 $x$ 是双倍回文，它的长度必须是 $4$ 的倍数，而且 $x$，$x$ 的前半部分，$x$ 的后半部分都要是回文。例如 $\\tt abbaabba$ 是一个双倍回文，而 $\\tt abaaba$ 不是，因为它的长度不是 $4$ 的倍数。\n\n- $x$ 的子串是指在 $x$ 中连续的一段字符所组成的字符串。例如 $\\tt be$ 是 $\\tt abed$ 的子串，而 $\\tt ac$ 不是。\n- $x$ 的回文子串，就是指满足回文性质的 $x$ 的子串。\n- $x$ 的双倍回文子串，就是指满足双倍回文性质的 $x$ 的子串。\n\n你的任务是，对于给定的字符串，计算它的最长双倍回文子串的长度。", "inputFormat": "输入分为两行。\n\n第一行为一个整数，表示字符串的长度。  \n第二行有个连续的小写的英文字符，表示字符串的内容。", "outputFormat": "输出文件只有一行即输入数据中字符串的最长双倍回文子串的长度，如果双倍回文子串不存在，则输出 $0$。", "hint": "### 数据范围及约定\n\n对于全部数据，$1\\le N \\le 500000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2011] Double Palindrome", "background": "", "description": "Let the reversal of a string $w$ be denoted by $w^{\\mathsf R}$. For example, $\\tt (abcd)^{\\mathsf R}=dcba$, $\\tt (abba)^{\\mathsf R}=abba$.\n\nFor a string $x$, if $x$ satisfies $x^{\\mathsf R}=x$, it is called a palindrome. For example, $\\tt abba$ is a palindrome, while $\\tt abed$ is not.\n\nIf $x$ can be written in the form $ww^{\\mathsf R} ww^{\\mathsf R}$, it is called a \"double palindrome\". In other words, for $x$ to be a double palindrome, the length of $x$ must be a multiple of $4$, and $x$, its first half, and its second half must all be palindromes. For example, $\\tt abbaabba$ is a double palindrome, while $\\tt abaaba$ is not, because its length is not a multiple of $4$.\n\n- A substring of $x$ is a string formed by a consecutive segment of characters in $x$. For example, $\\tt be$ is a substring of $\\tt abed$, while $\\tt ac$ is not.\n- A palindromic substring of $x$ is a substring of $x$ that is a palindrome.\n- A double palindromic substring of $x$ is a substring of $x$ that is a double palindrome.\n\nYour task is to compute the length of the longest double palindromic substring of the given string.", "inputFormat": "The input consists of two lines.\n\n- The first line contains an integer $N$, the length of the string.\n- The second line contains a string of lowercase English letters, which is the content of the string.", "outputFormat": "Output a single line: the length of the longest double palindromic substring of the input string. If no double palindromic substring exists, output $0$.", "hint": "Constraints\n\nFor all testdata, $1 \\le N \\le 500000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2011] 双倍回文", "background": "", "description": "记字符串 $w$ 的倒置为 $w^{\\mathsf R}$。例如$\\tt (abcd)^{\\mathsf R}=dcba$，$\\tt (abba)^{\\mathsf R}=abba$。\n\n对字符串 $x$，如果 $x$ 满足 $x^{\\mathsf R}=x$，则称之为回文。例如 $\\tt abba$ 是一个回文，而 $\\tt abed$ 不是。\n\n如果 $x$ 能够写成 $ww^{\\mathsf R} ww^{\\mathsf R}$ 形式，则称它是一个“双倍回文”。换句话说，若要 $x$ 是双倍回文，它的长度必须是 $4$ 的倍数，而且 $x$，$x$ 的前半部分，$x$ 的后半部分都要是回文。例如 $\\tt abbaabba$ 是一个双倍回文，而 $\\tt abaaba$ 不是，因为它的长度不是 $4$ 的倍数。\n\n- $x$ 的子串是指在 $x$ 中连续的一段字符所组成的字符串。例如 $\\tt be$ 是 $\\tt abed$ 的子串，而 $\\tt ac$ 不是。\n- $x$ 的回文子串，就是指满足回文性质的 $x$ 的子串。\n- $x$ 的双倍回文子串，就是指满足双倍回文性质的 $x$ 的子串。\n\n你的任务是，对于给定的字符串，计算它的最长双倍回文子串的长度。", "inputFormat": "输入分为两行。\n\n第一行为一个整数，表示字符串的长度。  \n第二行有个连续的小写的英文字符，表示字符串的内容。", "outputFormat": "输出文件只有一行即输入数据中字符串的最长双倍回文子串的长度，如果双倍回文子串不存在，则输出 $0$。", "hint": "### 数据范围及约定\n\n对于全部数据，$1\\le N \\le 500000$。", "locale": "zh-CN"}}}
{"pid": "P4288", "type": "P", "difficulty": 6, "samples": [["2\n1 0\n-1 0\n0\n2", "0.500"], ["3\n1 1\n-1 -1\n0 0\n45\n7", "0.202"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2014", "各省省选", "上海"], "title": "[SHOI2014] 信号增幅仪", "background": "", "description": "无线网络基站在理想状况下有效信号覆盖范围是个圆形。而无线基站的功\n耗与圆的半径的平方成正比。现给出平面上若干网络用户的位置，请你选择一\n个合适的位置建设无线基站 ……\n\n就在你拿起键盘准备开始敲代码的时候，你的好朋友发明家SHTSC 突然出\n现了。SHTSC 刚刚完成了他的新发明——无线信号增幅仪。增幅仪能够在不增\n加无线基站功耗的前提下，使得有效信号的覆盖范围在某一特定方向上伸长若\n干倍。即：使用了增幅仪的无线基站覆盖范围是个椭圆，其功耗正比于半短轴\n长的平方。\n\n现给出平面上若干网络用户的位置，请你选择一个合适的位置建设无线基\n站，并在增幅仪的帮助下使所有的用户都能接收到信号，且无线基站的功耗最\n小。\n\n注意：由于SHTSC 增幅仪的工作原理依赖地磁场，增幅的方向是恒定的。", "inputFormat": "第一行一个整数：n。平面内的用户个数。之后的n 行每行两个整数x, y，表示一个用户的位置。\n\n第n+2 行一个整数：a。表示增幅仪的增幅方向，单位是度。表示增幅仪的\n方向是从x 正方向逆时针转a 度。\n\n第n+3 行一个整数：p。表示增幅仪的放大倍数。", "outputFormat": "输出一行一个实数，为能够覆盖所有用户的最小椭圆的半短轴长，四舍五入到三位小数。", "hint": "- 对于10%的数据，保证最优方案的中心在原点。\n- 对于20%的数据，保证点是随机生成的。\n- 对于30%的数据，n≤100。\n- 对于50%的数据，n≤5000。\n- 对于100%的数据，n≤50000，0≤a<180，1≤p≤100，|x|,|y|≤$2×10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2014] Signal Amplifier", "background": "", "description": "In ideal conditions, the effective coverage area of a wireless base station is a circle, and the power consumption is proportional to the square of the circle’s radius. Given the positions of several network users on the plane, you are to choose a suitable location to build a wireless base station...\n\nJust as you are about to start coding, your good friend, the inventor SHTSC, shows up. SHTSC has just completed his new invention — a wireless signal amplifier. Without increasing the base station’s power consumption, the amplifier can extend the effective signal coverage by a certain multiple in a specific direction. That is, a base station using the amplifier has an elliptical coverage area, and its power consumption is proportional to the square of the length of the semi-minor axis.\n\nGiven the positions of several network users on the plane, choose a suitable location to build a base station and, with the help of the amplifier, ensure that all users can receive the signal while minimizing the base station’s power consumption.\n\nNote: Because the working principle of SHTSC’s amplifier depends on the geomagnetic field, the amplification direction is fixed.", "inputFormat": "The first line contains an integer n, the number of users on the plane. The next n lines each contain two integers x, y, representing a user’s position.\n\nThe (n+2)-th line contains an integer a, representing the amplifier’s direction in degrees. It is measured counterclockwise from the positive x-axis.\n\nThe (n+3)-th line contains an integer p, representing the amplifier’s magnification factor.", "outputFormat": "Output a single real number: the length of the semi-minor axis of the smallest ellipse that can cover all users, rounded to three decimal places.", "hint": "- For 10% of the testdata, it is guaranteed that the optimal center is at the origin.\n- For 20% of the testdata, the points are randomly generated.\n- For 30% of the testdata, $n \\le 100$.\n- For 50% of the testdata, $n \\le 5000$.\n- For 100% of the testdata, $n \\le 50000$, $0 \\le a < 180$, $1 \\le p \\le 100$, $|x|, |y| \\le $ $2×10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2014] 信号增幅仪", "background": "", "description": "无线网络基站在理想状况下有效信号覆盖范围是个圆形。而无线基站的功\n耗与圆的半径的平方成正比。现给出平面上若干网络用户的位置，请你选择一\n个合适的位置建设无线基站 ……\n\n就在你拿起键盘准备开始敲代码的时候，你的好朋友发明家SHTSC 突然出\n现了。SHTSC 刚刚完成了他的新发明——无线信号增幅仪。增幅仪能够在不增\n加无线基站功耗的前提下，使得有效信号的覆盖范围在某一特定方向上伸长若\n干倍。即：使用了增幅仪的无线基站覆盖范围是个椭圆，其功耗正比于半短轴\n长的平方。\n\n现给出平面上若干网络用户的位置，请你选择一个合适的位置建设无线基\n站，并在增幅仪的帮助下使所有的用户都能接收到信号，且无线基站的功耗最\n小。\n\n注意：由于SHTSC 增幅仪的工作原理依赖地磁场，增幅的方向是恒定的。", "inputFormat": "第一行一个整数：n。平面内的用户个数。之后的n 行每行两个整数x, y，表示一个用户的位置。\n\n第n+2 行一个整数：a。表示增幅仪的增幅方向，单位是度。表示增幅仪的\n方向是从x 正方向逆时针转a 度。\n\n第n+3 行一个整数：p。表示增幅仪的放大倍数。", "outputFormat": "输出一行一个实数，为能够覆盖所有用户的最小椭圆的半短轴长，四舍五入到三位小数。", "hint": "- 对于10%的数据，保证最优方案的中心在原点。\n- 对于20%的数据，保证点是随机生成的。\n- 对于30%的数据，n≤100。\n- 对于50%的数据，n≤5000。\n- 对于100%的数据，n≤50000，0≤a<180，1≤p≤100，|x|,|y|≤$2×10^8$。", "locale": "zh-CN"}}}
