{"pid": "P1241", "type": "P", "difficulty": 2, "samples": [["([()\n", "()[]()\n"], ["([)", "()[]()"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化", "栈"], "title": "括号序列", "background": "", "description": "定义如下规则：\n\n1. 空串是「平衡括号序列」\n2. 若字符串 $S$ 是「平衡括号序列」，那么 $\\texttt{[}S\\texttt]$ 和 $\\texttt{(}S\\texttt)$ 也都是「平衡括号序列」\n3. 若字符串 $A$ 和 $B$ 都是「平衡括号序列」，那么 $AB$（两字符串拼接起来）也是「平衡括号序列」。\n\n\n例如，下面的字符串都是平衡括号序列：\n\n\n- `()`，`[]`，`(())`，`([])`，`()[]`，`()[()]`\n\n\n而以下几个则不是：\n\n\n- `(`，`[`，`]`，`)(`，`())`，`([()`\n\n\n现在，给定一个仅由 `(`，`)`，`[`，`]`构成的字符串 $s$，请你按照如下的方式给字符串中每个字符配对：\n1. 从左到右扫描整个字符串。\n2. 对于当前的字符，如果它是一个右括号，考察它与它左侧离它**最近**的**未匹配**的的左括号。如果该括号与之对应（即小括号匹配小括号，中括号匹配中括号），则将二者配对。如果左侧未匹配的左括号不存在或与之不对应，则其配对失败。\n\n配对结束后，对于 $s$ 中全部未配对的括号，请你在其旁边添加一个字符，使得该括号和新加的括号匹配。", "inputFormat": "输入只有一行一个字符串，表示 $s$。", "outputFormat": "输出一行一个字符串表示你的答案。", "hint": "### 数据规模与约定\n\n对于全部的测试点，保证 $s$ 的长度不超过 $100$，且只含  `(`，`)`，`[`，`]` 四种字符。", "locale": "zh-CN", "translations": {"en": {"title": "Bracket Sequence", "background": "", "description": "Define the following rules:\n1. The empty string is a \"balanced bracket sequence\".\n2. If string $S$ is a \"balanced bracket sequence\", then $\\texttt{[}S\\texttt{]}$ and $\\texttt{(}S\\texttt{)}$ are also \"balanced bracket sequences\".\n3. If strings $A$ and $B$ are both \"balanced bracket sequences\", then $AB$ (the concatenation of the two strings) is also a \"balanced bracket sequence\".\n\nFor example, the following strings are balanced bracket sequences:\n- `()`, `[]`, `(())`, `([])`, `()[]`, `()[()]`.\n\nThe following are not:\n- `(`, `[`, `]`, `)(`, `())`, `([()`.\n\nNow, given a string $s$ consisting only of `(`, `)`, `[`, `]`, please pair the characters in the string as follows:\n1. Scan the string from left to right.\n2. For the current character, if it is a right bracket, look at the nearest unmatched left bracket to its left. If they correspond (parenthesis matches parenthesis, square bracket matches square bracket), then pair them. If there is no unmatched left bracket to its left or they do not correspond, then pairing fails.\n\nAfter pairing ends, for every unmatched bracket in $s$, add one character next to it so that this bracket matches with the newly added one.", "inputFormat": "The input contains a single line with the string $s$.", "outputFormat": "Output a single line with the resulting string.", "hint": "Constraints\n\nFor all test points, it is guaranteed that the length of $s$ does not exceed $100$, and $s$ contains only the four characters `(`, `)`, `[`, `]`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "括号序列", "background": "", "description": "定义如下规则：\n\n1. 空串是「平衡括号序列」\n2. 若字符串 $S$ 是「平衡括号序列」，那么 $\\texttt{[}S\\texttt]$ 和 $\\texttt{(}S\\texttt)$ 也都是「平衡括号序列」\n3. 若字符串 $A$ 和 $B$ 都是「平衡括号序列」，那么 $AB$（两字符串拼接起来）也是「平衡括号序列」。\n\n\n例如，下面的字符串都是平衡括号序列：\n\n\n- `()`，`[]`，`(())`，`([])`，`()[]`，`()[()]`\n\n\n而以下几个则不是：\n\n\n- `(`，`[`，`]`，`)(`，`())`，`([()`\n\n\n现在，给定一个仅由 `(`，`)`，`[`，`]`构成的字符串 $s$，请你按照如下的方式给字符串中每个字符配对：\n1. 从左到右扫描整个字符串。\n2. 对于当前的字符，如果它是一个右括号，考察它与它左侧离它**最近**的**未匹配**的的左括号。如果该括号与之对应（即小括号匹配小括号，中括号匹配中括号），则将二者配对。如果左侧未匹配的左括号不存在或与之不对应，则其配对失败。\n\n配对结束后，对于 $s$ 中全部未配对的括号，请你在其旁边添加一个字符，使得该括号和新加的括号匹配。", "inputFormat": "输入只有一行一个字符串，表示 $s$。", "outputFormat": "输出一行一个字符串表示你的答案。", "hint": "### 数据规模与约定\n\n对于全部的测试点，保证 $s$ 的长度不超过 $100$，且只含  `(`，`)`，`[`，`]` 四种字符。", "locale": "zh-CN"}}}
{"pid": "P1242", "type": "P", "difficulty": 5, "samples": [["5\n3 3 2 1\n2 5 4\n0\n1 2\n3 5 4 3\n1 1", "move 1 from A to B\nmove 2 from A to C\nmove 1 from B to C\nmove 3 from A to B\nmove 1 from C to B\nmove 2 from C to A\nmove 1 from B to C\n7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递归", "枚举"], "title": "新汉诺塔", "background": "", "description": "\n设有 $n$ 个大小不等的中空圆盘，按从小到大的顺序从 $1$ 到 $n$ 编号。将这 $n$ 个圆盘任意的迭套在三根立柱上，立柱的编号分别为 $A,B,C$，这个状态称为初始状态。\n\n现在要求找到一种步数最少的移动方案，使得从初始状态转变为目标状态。\n\n移动时有如下要求：\n\n- 一次只能移一个盘；\n- 不允许把大盘移到小盘上面。", "inputFormat": "\n第一行一个整数，状态中圆盘总数 $n$。\n\n接下来三行每行若干个整数，分别代表初始状态下 $A$ , $B$ , $C$ 柱子上的圆盘从上到下的编号，如果只有一个数 $0$ 就代表这根柱子上没有数。\n\n接下来三行每行若干个整数，分别代表目标状态下 $A$ , $B$ , $C$ 柱子上的圆盘从上到下的编号，如果只有一个数 $0$ 就代表这根柱子上没有数。", "outputFormat": "若干行每行一个字符串，格式为 `move I from P to Q` ，代表一个移动的操作。\n\n接下来一行一个整数，代表从初始状态到目标状态的最少步数。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 45$ ，$1 \\le $ 每个圆盘的编号 $\\le n$ 。\n\n每行的圆盘描述是从下到上的圆盘编号。", "locale": "zh-CN", "translations": {"en": {"title": "New Tower of Hanoi", "background": "", "description": "There are $n$ hollow circular disks of distinct sizes, labeled from $1$ to $n$ in ascending order by size. These $n$ disks are arbitrarily nested on three pegs labeled $A$, $B$, $C$. This configuration is called the initial state.\n\nYour task is to find a shortest sequence of moves that transforms the initial state into the target state.\n\nThe move rules are as follows:\n- Only one disk may be moved at a time.\n- A larger disk may not be placed on top of a smaller disk.", "inputFormat": "The first line contains an integer $n$, the total number of disks present in the states.\n\nThe next three lines each contain several integers, describing the disks on pegs $A$, $B$, $C$ in the initial state, listed from bottom to top. If a line contains only the single number $0$, that peg has no disk.\n\nThe following three lines each contain several integers, describing the disks on pegs $A$, $B$, $C$ in the target state, listed from bottom to top. If a line contains only the single number $0$, that peg has no disk.", "outputFormat": "Several lines, each containing a string in the format `move I from P to Q`, representing a single move.\n\nThen output one line with one integer, the minimum number of moves from the initial state to the target state.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le n \\le 45$, and $1 \\le$ each disk's index $\\le n$.\n\nEach line’s disk description is listed from bottom to top.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "新汉诺塔", "background": "", "description": "\n设有 $n$ 个大小不等的中空圆盘，按从小到大的顺序从 $1$ 到 $n$ 编号。将这 $n$ 个圆盘任意的迭套在三根立柱上，立柱的编号分别为 $A,B,C$，这个状态称为初始状态。\n\n现在要求找到一种步数最少的移动方案，使得从初始状态转变为目标状态。\n\n移动时有如下要求：\n\n- 一次只能移一个盘；\n- 不允许把大盘移到小盘上面。", "inputFormat": "\n第一行一个整数，状态中圆盘总数 $n$。\n\n接下来三行每行若干个整数，分别代表初始状态下 $A$ , $B$ , $C$ 柱子上的圆盘从上到下的编号，如果只有一个数 $0$ 就代表这根柱子上没有数。\n\n接下来三行每行若干个整数，分别代表目标状态下 $A$ , $B$ , $C$ 柱子上的圆盘从上到下的编号，如果只有一个数 $0$ 就代表这根柱子上没有数。", "outputFormat": "若干行每行一个字符串，格式为 `move I from P to Q` ，代表一个移动的操作。\n\n接下来一行一个整数，代表从初始状态到目标状态的最少步数。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 45$ ，$1 \\le $ 每个圆盘的编号 $\\le n$ 。\n\n每行的圆盘描述是从下到上的圆盘编号。", "locale": "zh-CN"}}}
{"pid": "P1243", "type": "P", "difficulty": 3, "samples": [["3 4\n", "1 2 3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推"], "title": "排序集合", "background": "", "description": "对于集合 $N=\\{1,2,\\cdots,n\\}$ 的子集，定义一个称之为“小于”的关系：\n\n设 $S1=\\{X_1,X_2,\\cdots,X_i\\}$，$(X_1<X_2<\\cdots<X_i)$，$S2=\\{Y_1,Y_2,\\cdots,Y_j\\}$，$(Y_1<Y_2<\\cdots<Y_j)$，如果存在一个 $k$，$(0\\leq k\\leq\\min(i,j))$，使得 $X_1=Y_1,\\cdots,X_k=Y_k$，且 $k=i$ 或 $X_{k+1}<Y_{k+1}$，则称 $S1$ “小于” $S2$。\n\n你的任务是，对于任意的 $n(n\\leq31)$ 及 $k(k<2^n)$，求出第 $k$ 小的子集。", "inputFormat": "输入文件仅一行，包含两个用空格隔开的自然数，$n$ 和 $k$。", "outputFormat": "输出文件仅一行，使该子集的元素，由小到大排列。空集输出 $0$。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Sorting Subsets", "background": "", "description": "For subsets of $N=\\{1,2,\\cdots,n\\}$, define a relation called \"less than\":\n\nLet $S1=\\{X_1,X_2,\\cdots,X_i\\}$, $(X_1<X_2<\\cdots<X_i)$, $S2=\\{Y_1,Y_2,\\cdots,Y_j\\}$, $(Y_1<Y_2<\\cdots<Y_j)$. If there exists a $k$, $(0\\leq k\\leq\\min(i,j))$, such that $X_1=Y_1,\\cdots,X_k=Y_k$, and $k=i$ or $X_{k+1}<Y_{k+1}$, then $S1$ is said to be \"less than\" $S2$.\n\nYour task is, for any $n$ $(n\\leq31)$ and $k$ $(k<2^n)$, to find the $k$-th smallest subset.", "inputFormat": "The input file contains a single line with two natural numbers, $n$ and $k$, separated by a space.", "outputFormat": "Output a single line listing the elements of the subset in increasing order. Output $0$ for the empty set.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "排序集合", "background": "", "description": "对于集合 $N=\\{1,2,\\cdots,n\\}$ 的子集，定义一个称之为“小于”的关系：\n\n设 $S1=\\{X_1,X_2,\\cdots,X_i\\}$，$(X_1<X_2<\\cdots<X_i)$，$S2=\\{Y_1,Y_2,\\cdots,Y_j\\}$，$(Y_1<Y_2<\\cdots<Y_j)$，如果存在一个 $k$，$(0\\leq k\\leq\\min(i,j))$，使得 $X_1=Y_1,\\cdots,X_k=Y_k$，且 $k=i$ 或 $X_{k+1}<Y_{k+1}$，则称 $S1$ “小于” $S2$。\n\n你的任务是，对于任意的 $n(n\\leq31)$ 及 $k(k<2^n)$，求出第 $k$ 小的子集。", "inputFormat": "输入文件仅一行，包含两个用空格隔开的自然数，$n$ 和 $k$。", "outputFormat": "输出文件仅一行，使该子集的元素，由小到大排列。空集输出 $0$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1244", "type": "P", "difficulty": 2, "samples": [["1 1\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2000", "NOI"], "title": "[NOI2000] 青蛙过河", "background": "", "description": "**大小各不相同**的一队青蛙站在河左岸的石墩（记为 A）上，要过到对岸的石墩（记为 D）上去。河心有几片荷叶（分别记为 $Y_1 \\dots Y_m$）和几个石墩（分别记为 $S_1\\dots S_n$）。图示如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0u3st8yt.png)\n\n青蛙的站队和移动方法规则如下：\n\n- 每只青蛙只能站在荷叶、石墩，或者**仅比它大一号**的青蛙背上（统称为合法的落脚点）；\n- 一只青蛙只有背上没有其它青蛙的时候才能够从一个落脚点跳到另一个落脚点；\n- 青蛙允许从左岸 A 直接跳到河心的石墩、荷叶和右岸的石墩 D 上，允许从河心的石墩和荷叶跳到右岸的石墩 D 上；\n- 青蛙在河心的石墩之间、荷叶之间以及石墩和荷叶之间可以来回跳动；\n- 青蛙在离开左岸石墩后，不能再返回左岸；到达右岸后，不能再跳回；\n- 假定石墩承重能力很大，允许无论多少只青蛙都可呆在上面。但是，由于石墩的面积不大，至多只能有一只青蛙直接站在上面，而其他的青蛙只能依规则 1 落在比它大一号的青蛙的背上。\n- 荷叶不仅面积不大，而且负重能力也有限，至多只能有一只青蛙站在上面。\n- 每一步只能移动一只青蛙，并且移动后需要满足站队规则；\n- 在一开始的时候，青蛙均站在 A 上，最大的一只青蛙直接站在石墩上，而其它的青蛙依规则 6 站在比其大一号的青蛙的背上。\n\n青蛙希望最终能够全部移动到 D 上，并完成站队。\n\n设河心有 $m$ 片荷叶和 $n$ 个石墩，请求出这队青蛙至多有多少只，在满足站队和移动规则的前提下，能从 A 过到 D。\n\n你的任务是对于给出的 $n,m$，计算并输出最多能有多少只青蛙可以根据以上规则顺利过河。", "inputFormat": "输入两个整数 $n,m$。", "outputFormat": "一个整数，表示最多能有多少只青蛙可以根据以上规则顺利过河。\n", "hint": "$n \\leq 20$，$m \\leq 10^3$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2000] Frogs Crossing the River", "background": "", "description": "A line of frogs of different sizes stands on the stone post on the left bank (denoted as A) and wants to cross to the stone post on the right bank (denoted as D). There are several lily pads in the middle of the river (denoted as $Y_1 \\dots Y_m$) and several stone posts (denoted as $S_1\\dots S_n$). The illustration is as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0u3st8yt.png)\n\nThe lineup and movement rules for the frogs are as follows:\n\n- Each frog may stand only on a lily pad, a stone post, or on the back of a frog that is only one size larger than itself (collectively called valid landing spots).\n- A frog can jump from one landing spot to another only when there is no other frog on its back.\n- A frog is allowed to jump directly from the left bank A to stone posts or lily pads in the river center, as well as directly to the right-bank stone post D; a frog is also allowed to jump from stone posts or lily pads in the river center to the right-bank stone post D.\n- Frogs may jump back and forth among stone posts, among lily pads, and between stone posts and lily pads in the river center.\n- After leaving the left bank stone post, a frog cannot return to the left bank; after reaching the right bank, it cannot jump back.\n- Stone posts have very large load capacity and can hold any number of frogs; however, because their area is small, at most one frog may stand directly on a stone post, and any other frogs must, per Rule 1, stand on the back of a frog that is one size larger.\n- Lily pads not only have small area but also limited load capacity; at most one frog may stand on a lily pad.\n- At each step, only one frog may move, and after the move the lineup rules must be satisfied.\n- Initially, all frogs stand on A: the largest frog stands directly on the stone post, and all other frogs, per Rule 6, stand on the back of a frog that is one size larger.\n\nThe frogs hope that they can all eventually move onto D and complete the lineup.\n\nGiven that the river center has $m$ lily pads and $n$ stone posts, determine the maximum possible number of frogs that, under the lineup and movement rules, can move from A to D.\n\nYour task is: given $n, m$, compute and output the maximum number of frogs that can cross the river under the rules above.", "inputFormat": "Two integers $n, m$.", "outputFormat": "One integer, the maximum number of frogs that can, under the rules above, cross the river from A to D.", "hint": "Constraints: $n \\leq 20$, $m \\leq 10^3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2000] 青蛙过河", "background": "", "description": "**大小各不相同**的一队青蛙站在河左岸的石墩（记为 A）上，要过到对岸的石墩（记为 D）上去。河心有几片荷叶（分别记为 $Y_1 \\dots Y_m$）和几个石墩（分别记为 $S_1\\dots S_n$）。图示如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0u3st8yt.png)\n\n青蛙的站队和移动方法规则如下：\n\n- 每只青蛙只能站在荷叶、石墩，或者**仅比它大一号**的青蛙背上（统称为合法的落脚点）；\n- 一只青蛙只有背上没有其它青蛙的时候才能够从一个落脚点跳到另一个落脚点；\n- 青蛙允许从左岸 A 直接跳到河心的石墩、荷叶和右岸的石墩 D 上，允许从河心的石墩和荷叶跳到右岸的石墩 D 上；\n- 青蛙在河心的石墩之间、荷叶之间以及石墩和荷叶之间可以来回跳动；\n- 青蛙在离开左岸石墩后，不能再返回左岸；到达右岸后，不能再跳回；\n- 假定石墩承重能力很大，允许无论多少只青蛙都可呆在上面。但是，由于石墩的面积不大，至多只能有一只青蛙直接站在上面，而其他的青蛙只能依规则 1 落在比它大一号的青蛙的背上。\n- 荷叶不仅面积不大，而且负重能力也有限，至多只能有一只青蛙站在上面。\n- 每一步只能移动一只青蛙，并且移动后需要满足站队规则；\n- 在一开始的时候，青蛙均站在 A 上，最大的一只青蛙直接站在石墩上，而其它的青蛙依规则 6 站在比其大一号的青蛙的背上。\n\n青蛙希望最终能够全部移动到 D 上，并完成站队。\n\n设河心有 $m$ 片荷叶和 $n$ 个石墩，请求出这队青蛙至多有多少只，在满足站队和移动规则的前提下，能从 A 过到 D。\n\n你的任务是对于给出的 $n,m$，计算并输出最多能有多少只青蛙可以根据以上规则顺利过河。", "inputFormat": "输入两个整数 $n,m$。", "outputFormat": "一个整数，表示最多能有多少只青蛙可以根据以上规则顺利过河。\n", "hint": "$n \\leq 20$，$m \\leq 10^3$。", "locale": "zh-CN"}}}
{"pid": "P1245", "type": "P", "difficulty": 5, "samples": [["8\n73373711664\nthi\nshs\nthis\nis\nb\na\nboo\nk", "thi shs b boo k"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "Special Judge"], "title": "电话号码", "background": "", "description": "电话机上每一个数字下面都写了若干个英文字母。分布如下：\n\n- $1\\leftrightarrow \\verb!a!,\\verb!b!,\\verb!c!$；\n- $2\\leftrightarrow \\verb!d!,\\verb!e!,\\verb!f!$；\n- $3\\leftrightarrow \\verb!g!,\\verb!h!,\\verb!i!$；\n- $4\\leftrightarrow \\verb!j!,\\verb!k!,\\verb!l!$；\n- $5\\leftrightarrow \\verb!m!,\\verb!n!$；\n- $6\\leftrightarrow \\verb!o!,\\verb!p!,\\verb!q!$；\n- $7\\leftrightarrow \\verb!r!,\\verb!s!,\\verb!t!$；\n- $8\\leftrightarrow \\verb!u!,\\verb!v!,\\verb!w!$；\n- $9\\leftrightarrow \\verb!x!,\\verb!y!,\\verb!z!$。\n\n现在给定一个单词表和一串数字密码，请你用单词表中的单词翻译这个密码。\n", "inputFormat": "第一行为一个正整数 $N$ 表示单词表中单词的个数 $(N≤100)$；\n\n第二行为一个长度不超过 $100$ 的数字串，表示密码；\n\n接下来的 $N$ 行，每行一个长度不超过 $20$ 的单词，表示单词表。\n", "outputFormat": "仅一行，表示翻译后的原文，如果密码无法翻译，则输出 `No Solutions!`，如果密码有多种翻译方式，则输出任意一种即可。\n", "hint": "由 @zhouyonglong 提供SPJ\n", "locale": "zh-CN", "translations": {"en": {"title": "Phone Number", "background": "", "description": "On a telephone keypad, several English letters are written under each digit. The mapping is as follows:\n- $1\\leftrightarrow \\verb!a!,\\verb!b!,\\verb!c!$.\n- $2\\leftrightarrow \\verb!d!,\\verb!e!,\\verb!f!$.\n- $3\\leftrightarrow \\verb!g!,\\verb!h!,\\verb!i!$.\n- $4\\leftrightarrow \\verb!j!,\\verb!k!,\\verb!l!$.\n- $5\\leftrightarrow \\verb!m!,\\verb!n!$.\n- $6\\leftrightarrow \\verb!o!,\\verb!p!,\\verb!q!$.\n- $7\\leftrightarrow \\verb!r!,\\verb!s!,\\verb!t!$.\n- $8\\leftrightarrow \\verb!u!,\\verb!v!,\\verb!w!$.\n- $9\\leftrightarrow \\verb!x!,\\verb!y!,\\verb!z!$.\n\nNow, given a word list and a sequence of digits (a numeric code), please translate the code using words from the list.", "inputFormat": "The first line contains a positive integer $N$ indicating the number of words in the list $(N \\le 100)$.\n\nThe second line contains a digit string of length at most $100$, representing the code.\n\nThe next $N$ lines each contain one word of length at most $20$, representing the word list.", "outputFormat": "Output a single line: the decoded original text. If the code cannot be translated, output `No Solutions!`. If there are multiple valid translations, output any one of them.", "hint": "SPJ provided by @zhouyonglong.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "电话号码", "background": "", "description": "电话机上每一个数字下面都写了若干个英文字母。分布如下：\n\n- $1\\leftrightarrow \\verb!a!,\\verb!b!,\\verb!c!$；\n- $2\\leftrightarrow \\verb!d!,\\verb!e!,\\verb!f!$；\n- $3\\leftrightarrow \\verb!g!,\\verb!h!,\\verb!i!$；\n- $4\\leftrightarrow \\verb!j!,\\verb!k!,\\verb!l!$；\n- $5\\leftrightarrow \\verb!m!,\\verb!n!$；\n- $6\\leftrightarrow \\verb!o!,\\verb!p!,\\verb!q!$；\n- $7\\leftrightarrow \\verb!r!,\\verb!s!,\\verb!t!$；\n- $8\\leftrightarrow \\verb!u!,\\verb!v!,\\verb!w!$；\n- $9\\leftrightarrow \\verb!x!,\\verb!y!,\\verb!z!$。\n\n现在给定一个单词表和一串数字密码，请你用单词表中的单词翻译这个密码。\n", "inputFormat": "第一行为一个正整数 $N$ 表示单词表中单词的个数 $(N≤100)$；\n\n第二行为一个长度不超过 $100$ 的数字串，表示密码；\n\n接下来的 $N$ 行，每行一个长度不超过 $20$ 的单词，表示单词表。\n", "outputFormat": "仅一行，表示翻译后的原文，如果密码无法翻译，则输出 `No Solutions!`，如果密码有多种翻译方式，则输出任意一种即可。\n", "hint": "由 @zhouyonglong 提供SPJ\n", "locale": "zh-CN"}}}
{"pid": "P1246", "type": "P", "difficulty": 3, "samples": [["ab\r\n", "27\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "递归", "线性递推"], "title": "编码", "background": "", "description": "编码工作常被运用于密文或压缩传输。这里我们用一种最简单的编码方式进行编码：把一些有规律的单词编成数字。\n\n字母表中共有 $26$ 个字母 $\\mathtt{a,b,c,\\cdots,z}$，这些特殊的单词长度不超过 $6$ 且字母按升序排列。把所有这样的单词放在一起，按字典顺序排列，一个单词的编码就对应着它在字典中的位置。\n\n例如：\n\n- $\\verb!a! \\to 1$；\n- $\\verb!b! \\to 2$；\n- $\\verb!z! \\to 26$；\n- $\\verb!ab! \\to 27$；\n- $\\verb!ac! \\to 28$。\n\n你的任务就是对于所给的单词，求出它的编码。\n", "inputFormat": "仅一行，被编码的单词。\n", "outputFormat": "仅一行，对应的编码。如果单词不在字母表中，输出 $0$。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Encoding", "background": "", "description": "Encoding is often used for ciphertext or compressed transmission. Here we use one of the simplest methods: map some structured words to numbers.\n\nThere are $26$ letters in the alphabet, $\\mathtt{a,b,c,\\cdots,z}$. These special words have length at most $6$, and their letters are in strictly increasing order. Put all such words together and sort them in lexicographic order. The code of a word is the position of that word in this dictionary.\n\nFor example:\n- $\\verb!a! \\to 1$.\n- $\\verb!b! \\to 2$.\n- $\\verb!z! \\to 26$.\n- $\\verb!ab! \\to 27$.\n- $\\verb!ac! \\to 28$.\n\nYour task is to compute the code of the given word.", "inputFormat": "A single line containing the word to be encoded.", "outputFormat": "A single line containing the corresponding code. If the word is not in this dictionary, output $0$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "编码", "background": "", "description": "编码工作常被运用于密文或压缩传输。这里我们用一种最简单的编码方式进行编码：把一些有规律的单词编成数字。\n\n字母表中共有 $26$ 个字母 $\\mathtt{a,b,c,\\cdots,z}$，这些特殊的单词长度不超过 $6$ 且字母按升序排列。把所有这样的单词放在一起，按字典顺序排列，一个单词的编码就对应着它在字典中的位置。\n\n例如：\n\n- $\\verb!a! \\to 1$；\n- $\\verb!b! \\to 2$；\n- $\\verb!z! \\to 26$；\n- $\\verb!ab! \\to 27$；\n- $\\verb!ac! \\to 28$。\n\n你的任务就是对于所给的单词，求出它的编码。\n", "inputFormat": "仅一行，被编码的单词。\n", "outputFormat": "仅一行，对应的编码。如果单词不在字母表中，输出 $0$。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1247", "type": "P", "difficulty": 4, "samples": [["3\n3 6 9\n", "4 3\n3 6 5\n"], ["4\n15 22 19 10", "lose"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["博弈论"], "title": "取火柴游戏", "background": "", "description": "输入 $k$ 及 $k$ 个整数 $n_1,n_2,\\cdots,n_k$，表示有 $k$ 堆火柴棒，第 $i$ 堆火柴棒的根数为 $n_i$；接着便是你和计算机取火柴棒的对弈游戏。取的规则如下：每次可以从一堆中取走若干根火柴，也可以一堆全部取走，但不允许跨堆取，也不允许不取。\n\n谁取走最后一根火柴为胜利者。\n\n例如：$k=2$，$n_1=n_2=2$，A 代表你，P 代表计算机，若决定 A 先取：\n\n- A：$(2,2) \\rightarrow (1,2)$，即从第一堆中取一根。\n- P：$(1,2) \\rightarrow (1,1)$，即从第二堆中取一根。\n- A：$(1,1) \\rightarrow (1,0)$。\n- P：$(1,0) \\rightarrow (0,0)$。P 胜利。\n\n如果决定 $A$ 后取：\n\n- P：$(2,2) \\rightarrow (2,0)$。\n- A：$(2,0) \\rightarrow (0,0)$。A 胜利。\n\n又如 $k=3$，$n_1=1$，$n_2=2$，$n_3=3$，$A$ 决定后取：\n\n- P：$(1,2,3) \\rightarrow (0,2,3)$。\n- A：$(0,2,3) \\rightarrow (0,2,2)$。\n- A 已将游戏归结为 $(2,2)$ 的情况，不管 P 如何取 A 都必胜。\n\n编一个程序，在给出初始状态之后，判断是先取必胜还是先取必败，如果是先取必胜，请输出第一次该如何取。如果是先取必败，则输出 `lose`。", "inputFormat": "第一行，一个正整数 $k$。\n\n第二行，$k$ 个整数 $n_1,n_2,\\cdots,n_k$。", "outputFormat": "如果是先取必胜，请在第一行输出两个整数 $a,b$，表示第一次从第 $b$ 堆取出 $a$ 个。第二行为第一次取火柴后的状态。如果有多种答案，则输出 $\\lang b,a\\rang$ 字典序最小的答案（ 即 $b$ 最小的前提下，使 $a$ 最小）。\n\n如果是先取必败，则输出 `lose`。", "hint": "### 数据范围及约定\n\n对于全部数据，$k \\le 500000$，$n_i \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "Matchstick Game", "background": "", "description": "Given $k$ and $k$ integers $n_1, n_2, \\cdots, n_k$, there are $k$ piles of matchsticks, where the $i$-th pile contains $n_i$ sticks. You will then play a matchstick-taking game against the computer. The rules are as follows: on each turn, you may take any positive number of matchsticks from exactly one pile, possibly taking the entire pile, but you may not take from multiple piles in a single move, and you may not pass.\n\nWhoever takes the last matchstick wins.\n\nFor example: $k = 2$, $n_1 = n_2 = 2$. Let A denote you, and P denote the computer. If A moves first:\n\n- A: $(2, 2) \\rightarrow (1, 2)$, that is, take one from the first pile.\n- P: $(1, 2) \\rightarrow (1, 1)$, that is, take one from the second pile.\n- A: $(1, 1) \\rightarrow (1, 0)$.\n- P: $(1, 0) \\rightarrow (0, 0)$. P wins.\n\nIf A moves second:\n\n- P: $(2, 2) \\rightarrow (2, 0)$.\n- A: $(2, 0) \\rightarrow (0, 0)$. A wins.\n\nAnother example: $k = 3$, $n_1 = 1$, $n_2 = 2$, $n_3 = 3$, and A moves second:\n\n- P: $(1, 2, 3) \\rightarrow (0, 2, 3)$.\n- A: $(0, 2, 3) \\rightarrow (0, 2, 2)$.\n- A has reduced the game to the $(2, 2)$ case; no matter how P moves, A will surely win.\n\nWrite a program that, given the initial state, determines whether the first player has a forced win or a forced loss. If the first player has a forced win, output how to make the first move. If the first player has a forced loss, output `lose`.", "inputFormat": "The first line contains a positive integer $k$.\n\nThe second line contains $k$ integers $n_1, n_2, \\cdots, n_k$.", "outputFormat": "If the first player has a forced win, output two integers $a, b$ on the first line, meaning that on the first move you take $a$ matchsticks from pile $b$. The second line should be the state after the first move.\n\nIf there are multiple valid answers, output the lexicographically smallest answer by the pair $\\langle b, a \\rangle$ (that is, with the smallest $b$, and under that, the smallest $a$).\n\nIf the first player has a forced loss, output `lose`.", "hint": "### Constraints\n\nFor all testdata, $k \\le 500000$, $n_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "取火柴游戏", "background": "", "description": "输入 $k$ 及 $k$ 个整数 $n_1,n_2,\\cdots,n_k$，表示有 $k$ 堆火柴棒，第 $i$ 堆火柴棒的根数为 $n_i$；接着便是你和计算机取火柴棒的对弈游戏。取的规则如下：每次可以从一堆中取走若干根火柴，也可以一堆全部取走，但不允许跨堆取，也不允许不取。\n\n谁取走最后一根火柴为胜利者。\n\n例如：$k=2$，$n_1=n_2=2$，A 代表你，P 代表计算机，若决定 A 先取：\n\n- A：$(2,2) \\rightarrow (1,2)$，即从第一堆中取一根。\n- P：$(1,2) \\rightarrow (1,1)$，即从第二堆中取一根。\n- A：$(1,1) \\rightarrow (1,0)$。\n- P：$(1,0) \\rightarrow (0,0)$。P 胜利。\n\n如果决定 $A$ 后取：\n\n- P：$(2,2) \\rightarrow (2,0)$。\n- A：$(2,0) \\rightarrow (0,0)$。A 胜利。\n\n又如 $k=3$，$n_1=1$，$n_2=2$，$n_3=3$，$A$ 决定后取：\n\n- P：$(1,2,3) \\rightarrow (0,2,3)$。\n- A：$(0,2,3) \\rightarrow (0,2,2)$。\n- A 已将游戏归结为 $(2,2)$ 的情况，不管 P 如何取 A 都必胜。\n\n编一个程序，在给出初始状态之后，判断是先取必胜还是先取必败，如果是先取必胜，请输出第一次该如何取。如果是先取必败，则输出 `lose`。", "inputFormat": "第一行，一个正整数 $k$。\n\n第二行，$k$ 个整数 $n_1,n_2,\\cdots,n_k$。", "outputFormat": "如果是先取必胜，请在第一行输出两个整数 $a,b$，表示第一次从第 $b$ 堆取出 $a$ 个。第二行为第一次取火柴后的状态。如果有多种答案，则输出 $\\lang b,a\\rang$ 字典序最小的答案（ 即 $b$ 最小的前提下，使 $a$ 最小）。\n\n如果是先取必败，则输出 `lose`。", "hint": "### 数据范围及约定\n\n对于全部数据，$k \\le 500000$，$n_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P1248", "type": "P", "difficulty": 6, "samples": [["5\n3 5 8 7 10\n6 2 1 4 9\n", "34\n1 5 4 2 3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "Special Judge"], "title": "加工生产调度", "background": null, "description": "某工厂收到了 $n$ 个产品的订单，这 $n$ 个产品分别在 A、B 两个车间加工，并且必须先在 A 车间加工后才可以到 B 车间加工。一个车间在同一时刻只能加工一个产品。\n\n某个产品 $i$ 在 A、B 两车间加工的时间分别为 $A_i,B_i$。怎样安排这 $n$ 个产品的加工顺序，才能使总的加工时间最短。\n\n这里所说的加工时间是指：从开始加工第一个产品到最后所有的产品都已在 A、B 两车间加工完毕的时间。", "inputFormat": "第一行仅—个整数 $n$，表示产品的数量。\n\n接下来一行 $n$ 个整数是表示这 $n$ 个产品在 A 车间加工各自所要的时间。\n\n最后的 $n$ 个整数是表示这 $n$ 个产品在 B 车间加工各自所要的时间。", "outputFormat": "第一行一个整数，表示最少的加工时间。\n\n第二行是一种最小加工时间的加工顺序。", "hint": "$1\\leq n\\leq 1000$，$1\\leq A_i,B_i\\leq 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Two-Workshop Manufacturing Scheduling", "background": "", "description": "A factory has received orders for $n$ products. Each product must be processed in workshop A first and then in workshop B. At any moment, each workshop can process at most one product.\n\nFor product $i$, its processing times in workshops A and B are $A_i$ and $B_i$, respectively. Determine an order to process the $n$ products that minimizes the total processing time.\n\nThe total processing time is defined as the time from starting the first product until all products have finished processing in both workshops A and B.", "inputFormat": "- The first line contains a single integer $n$, the number of products.\n- The second line contains $n$ integers, the processing times of the $n$ products in workshop A.\n- The third line contains $n$ integers, the processing times of the $n$ products in workshop B.", "outputFormat": "- The first line contains one integer, the minimal total processing time.\n- The second line contains one processing order that achieves the minimal total processing time. Output the product indices (from $1$ to $n$) separated by spaces.", "hint": "Constraints: $1 \\leq n \\leq 1000$, $1 \\leq A_i, B_i \\leq 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "加工生产调度", "background": null, "description": "某工厂收到了 $n$ 个产品的订单，这 $n$ 个产品分别在 A、B 两个车间加工，并且必须先在 A 车间加工后才可以到 B 车间加工。一个车间在同一时刻只能加工一个产品。\n\n某个产品 $i$ 在 A、B 两车间加工的时间分别为 $A_i,B_i$。怎样安排这 $n$ 个产品的加工顺序，才能使总的加工时间最短。\n\n这里所说的加工时间是指：从开始加工第一个产品到最后所有的产品都已在 A、B 两车间加工完毕的时间。", "inputFormat": "第一行仅—个整数 $n$，表示产品的数量。\n\n接下来一行 $n$ 个整数是表示这 $n$ 个产品在 A 车间加工各自所要的时间。\n\n最后的 $n$ 个整数是表示这 $n$ 个产品在 B 车间加工各自所要的时间。", "outputFormat": "第一行一个整数，表示最少的加工时间。\n\n第二行是一种最小加工时间的加工顺序。", "hint": "$1\\leq n\\leq 1000$，$1\\leq A_i,B_i\\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P1249", "type": "P", "difficulty": 3, "samples": [["10\n", "2 3 5\n30"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "高精度"], "title": "最大乘积", "background": null, "description": "一个正整数一般可以分为几个互不相同的自然数的和，如 $3=1+2$，$4=1+3$，$5=1+4=2+3$，$6=1+5=2+4$。\n\n现在你的任务是将指定的正整数 $n$ 分解成若干个互不相同的自然数（也可以不分解，就是这个数字本身）的和，且使这些自然数的乘积最大。", "inputFormat": "只有一个正整数 $n$，（$3 \\leq n \\leq 10000$）。", "outputFormat": "第一行是分解方案，相邻的数之间用一个空格分开，并且按由小到大的顺序。\n\n第二行是最大的乘积。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Maximum Product", "background": "", "description": "A positive integer can generally be written as a sum of several pairwise distinct positive integers, such as $3=1+2$, $4=1+3$, $5=1+4=2+3$, $6=1+5=2+4$.\n\nYour task is to decompose the given positive integer $n$ into a sum of several pairwise distinct positive integers (you may also choose not to decompose it and use the number itself), such that the product of these integers is maximized.", "inputFormat": "A single positive integer $n$ ($3 \\leq n \\leq 10000$).", "outputFormat": "The first line contains the decomposition, with adjacent numbers separated by a single space, in nondecreasing order.\n\nThe second line contains the maximum product.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最大乘积", "background": null, "description": "一个正整数一般可以分为几个互不相同的自然数的和，如 $3=1+2$，$4=1+3$，$5=1+4=2+3$，$6=1+5=2+4$。\n\n现在你的任务是将指定的正整数 $n$ 分解成若干个互不相同的自然数（也可以不分解，就是这个数字本身）的和，且使这些自然数的乘积最大。", "inputFormat": "只有一个正整数 $n$，（$3 \\leq n \\leq 10000$）。", "outputFormat": "第一行是分解方案，相邻的数之间用一个空格分开，并且按由小到大的顺序。\n\n第二行是最大的乘积。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1250", "type": "P", "difficulty": 3, "samples": [["9\n4\n1 4 2\n4 6 2\n8 9 2\n3 5 2", "5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "排序", "差分约束"], "title": "种树", "background": "一条街的一边有几座房子，因为环保原因居民想要在路边种些树。", "description": "路边的地区被分割成块，并被编号成 $1, 2, \\ldots,n$。每个部分为一个单位尺寸大小并最多可种一棵树。\n\n每个居民都想在门前种些树，并指定了三个号码 $b$，$e$，$t$。这三个数表示该居民想在地区 $b$ 和 $e$ 之间（包括 $b$ 和 $e$）种至少 $t$ 棵树。\n\n居民们想种树的各自区域可以交叉。你的任务是求出能满足所有要求的最少的树的数量。", "inputFormat": "输入的第一行是一个整数，代表区域的个数 $n$。\n\n输入的第二行是一个整数，代表房子个数 $h$。\n\n第 $3$ 到第 $(h + 2)$ 行，每行三个整数，第 $(i + 2)$ 行的整数依次为 $b_i, e_i, t_i$，代表第 $i$ 个居民想在 $b_i$ 和 $e_i$ 之间种至少 $t_i$ 棵树。", "outputFormat": "输出一行一个整数，代表最少的树木个数。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n\n- $1 \\leq n \\leq 3 \\times 10^4$，$1 \\leq h \\leq 5 \\times 10^3$。\n- $1 \\leq b_i \\leq e_i \\leq n$，$1 \\leq t_i \\leq e_i - b_i + 1$。", "locale": "zh-CN", "translations": {"en": {"title": "Planting Trees", "background": "On one side of a street there are several houses. For environmental reasons, the residents want to plant some trees along the roadside.", "description": "The roadside area is divided into blocks and numbered $1, 2, \\ldots,n$. Each block has unit size and can contain at most one tree.\n\nEach resident wants to plant some trees in front of their house and specifies three numbers $b$, $e$, $t$. These numbers mean that the resident wants at least $t$ trees in the area between $b$ and $e$ (inclusive of $b$ and $e$).\n\nDifferent residents’ desired intervals may overlap. Your task is to find the minimum number of trees that can satisfy all requirements.", "inputFormat": "The first line contains an integer, the number of areas $n$.\n\nThe second line contains an integer, the number of houses $h$.\n\nLines $3$ to $(h + 2)$ each contain three integers. On line $(i + 2)$, the integers are $b_i, e_i, t_i$, meaning the $i$-th resident wants at least $t_i$ trees between $b_i$ and $e_i$.", "outputFormat": "Output a single integer, the minimum number of trees.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that:\n\n- $1 \\leq n \\leq 3 \\times 10^4$，$1 \\leq h \\leq 5 \\times 10^3$。\n- $1 \\leq b_i \\leq e_i \\leq n$，$1 \\leq t_i \\leq e_i - b_i + 1$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "种树", "background": "一条街的一边有几座房子，因为环保原因居民想要在路边种些树。", "description": "路边的地区被分割成块，并被编号成 $1, 2, \\ldots,n$。每个部分为一个单位尺寸大小并最多可种一棵树。\n\n每个居民都想在门前种些树，并指定了三个号码 $b$，$e$，$t$。这三个数表示该居民想在地区 $b$ 和 $e$ 之间（包括 $b$ 和 $e$）种至少 $t$ 棵树。\n\n居民们想种树的各自区域可以交叉。你的任务是求出能满足所有要求的最少的树的数量。", "inputFormat": "输入的第一行是一个整数，代表区域的个数 $n$。\n\n输入的第二行是一个整数，代表房子个数 $h$。\n\n第 $3$ 到第 $(h + 2)$ 行，每行三个整数，第 $(i + 2)$ 行的整数依次为 $b_i, e_i, t_i$，代表第 $i$ 个居民想在 $b_i$ 和 $e_i$ 之间种至少 $t_i$ 棵树。", "outputFormat": "输出一行一个整数，代表最少的树木个数。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n\n- $1 \\leq n \\leq 3 \\times 10^4$，$1 \\leq h \\leq 5 \\times 10^3$。\n- $1 \\leq b_i \\leq e_i \\leq n$，$1 \\leq t_i \\leq e_i - b_i + 1$。", "locale": "zh-CN"}}}
{"pid": "P1251", "type": "P", "difficulty": 6, "samples": [["3\n1 7 5 \n11 2 2 3 1\n", "134\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "网络流", "O2优化", "费用流", "网络流与线性规划 24 题"], "title": "餐巾计划问题", "background": "", "description": "一个餐厅在相继的 $N$ 天里，每天需用的餐巾数不尽相同。假设第 $i$ 天需要 $r_i$ 块餐巾（$i = 1, 2, \\dots, N$）。餐厅可以购买新的餐巾，每块餐巾的费用为 $p$ 分；或者把旧餐巾送到快洗部，洗一块需 $m$ 天，其费用为 $f$ 分；或者送到慢洗部，洗一块需 $n$ 天（$n \\gt m$），其费用为 $s$ 分（$s \\lt f$）。\n\n每天结束时，餐厅必须决定将多少块脏的餐巾送到快洗部，多少块餐巾送到慢洗部，以及多少块保存起来延期送洗。但是每天洗好的餐巾和购买的新餐巾数之和，要满足当天的需求量。\n\n试设计一个算法为餐厅合理地安排好 $N$ 天中餐巾使用计划，使总的花费最小。编程找出一个最佳餐巾使用计划。\n", "inputFormat": "由标准输入提供输入数据。文件第 $1$ 行有 $1$ 个正整数 $N$，代表要安排餐巾使用计划的天数。\n\n接下来的一行是餐厅在相继的 $N$ 天里，每天需用的餐巾数。\n\n最后一行包含 $5$ 个正整数 $p, m, f, n, s$。$p$ 是每块新餐巾的费用；$m$ 是快洗部洗一块餐巾需用天数；$f$ 是快洗部洗一块餐巾需要的费用；$n$ 是慢洗部洗一块餐巾需用天数；$s$ 是慢洗部洗一块餐巾需要的费用。\n", "outputFormat": "将餐厅在相继的 $N$ 天里使用餐巾的最小总花费输出。\n", "hint": "对于 $100 \\%$ 的数据，$1 \\le N \\le 2 \\times 10^3$，$1 \\le r_i \\le 10^7$，$1 \\le p, f, s \\le 10^4$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Napkin Planning Problem", "background": "", "description": "A restaurant needs different numbers of napkins on $N$ consecutive days. Suppose on day $i$ it needs $r_i$ napkins ($i = 1, 2, \\dots, N$). The restaurant can buy new napkins at a cost of $p$ cents per napkin; or send used napkins to a fast laundry, which takes $m$ days and costs $f$ cents per napkin; or send them to a slow laundry, which takes $n$ days ($n \\gt m$) and costs $s$ cents per napkin ($s \\lt f$).\n\nAt the end of each day, the restaurant must decide how many dirty napkins to send to the fast laundry, how many to send to the slow laundry, and how many to store for later laundering. On each day, the total number of napkins returned from laundries that day plus newly purchased napkins must meet that day’s demand.\n\nDesign an algorithm to plan napkin usage over $N$ days so that the total cost is minimized. Write a program to find an optimal napkin usage plan.", "inputFormat": "Input is given via standard input. The first line contains one positive integer $N$, the number of days to plan.\n\nThe next line contains the restaurant’s napkin demand for each of the $N$ consecutive days.\n\nThe last line contains $5$ positive integers $p, m, f, n, s$. Here, $p$ is the cost per new napkin; $m$ is the number of days the fast laundry takes per napkin; $f$ is the cost per napkin at the fast laundry; $n$ is the number of days the slow laundry takes per napkin; $s$ is the cost per napkin at the slow laundry.", "outputFormat": "Output the minimum total cost of napkin usage over the $N$ consecutive days.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le N \\le 2 \\times 10^3$, $1 \\le r_i \\le 10^7$, $1 \\le p, f, s \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "餐巾计划问题", "background": "", "description": "一个餐厅在相继的 $N$ 天里，每天需用的餐巾数不尽相同。假设第 $i$ 天需要 $r_i$ 块餐巾（$i = 1, 2, \\dots, N$）。餐厅可以购买新的餐巾，每块餐巾的费用为 $p$ 分；或者把旧餐巾送到快洗部，洗一块需 $m$ 天，其费用为 $f$ 分；或者送到慢洗部，洗一块需 $n$ 天（$n \\gt m$），其费用为 $s$ 分（$s \\lt f$）。\n\n每天结束时，餐厅必须决定将多少块脏的餐巾送到快洗部，多少块餐巾送到慢洗部，以及多少块保存起来延期送洗。但是每天洗好的餐巾和购买的新餐巾数之和，要满足当天的需求量。\n\n试设计一个算法为餐厅合理地安排好 $N$ 天中餐巾使用计划，使总的花费最小。编程找出一个最佳餐巾使用计划。\n", "inputFormat": "由标准输入提供输入数据。文件第 $1$ 行有 $1$ 个正整数 $N$，代表要安排餐巾使用计划的天数。\n\n接下来的一行是餐厅在相继的 $N$ 天里，每天需用的餐巾数。\n\n最后一行包含 $5$ 个正整数 $p, m, f, n, s$。$p$ 是每块新餐巾的费用；$m$ 是快洗部洗一块餐巾需用天数；$f$ 是快洗部洗一块餐巾需要的费用；$n$ 是慢洗部洗一块餐巾需用天数；$s$ 是慢洗部洗一块餐巾需要的费用。\n", "outputFormat": "将餐厅在相继的 $N$ 天里使用餐巾的最小总花费输出。\n", "hint": "对于 $100 \\%$ 的数据，$1 \\le N \\le 2 \\times 10^3$，$1 \\le r_i \\le 10^7$，$1 \\le p, f, s \\le 10^4$。\n", "locale": "zh-CN"}}}
{"pid": "P1252", "type": "P", "difficulty": 2, "samples": [["333 700 1200 1710 2240 2770 3345 3956 4778 5899 \n300 610 960 1370 1800 2712 3734 4834 5998 7682\n298 612 990 1540 2109 2896 3790 4747 5996 7654\n289 577 890 1381 1976 2734 3876 5378 6890 9876\n312 633 995 1407 1845 2634 3636 4812 5999 8123", "9905\n6 5 5 4 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "Special Judge", "枚举"], "title": "马拉松接力赛", "background": "", "description": "某城市冬季举办环城 $25\\rm km$ 马拉松接力赛，每个代表队有 $5$ 人参加比赛，比赛要求每个的每名参赛选手只能跑一次，一次至少跑 $1\\rm km$ 、最多只能跑 $10\\rm km$，而且每个选手所跑的公里数必须为整数，即接力的地方在整公里处。\n\n刘老师作为学校代表队的教练，精心选择了 $5$ 名长跑能手，进行了训练和测试，得到了这 $5$ 名选手尽力连续跑 $1\\rm km$、$2\\rm km$、…、$10\\rm km$ 的所用时间。现在他要进行一个合理的安排，让每个选手跑合适的公里数，使学校代表队跑完 $25\\rm km$ 所用的时间最短。根据队员的情况，这个最短的时间是惟一的，但安排方案可能并不惟一。\n\n根据测试情况及一般运动员的情况得知，连续跑 $1\\rm km$ 要比连续跑 $2\\rm km$ 速度快，连续跑 $2\\rm km$ 又要比连续跑 $3\\rm km$ 速度快……也就是说连续跑的路程越长，速度越慢，当然也有特殊的，就是速度不会变慢，但是绝不可能变快。", "inputFormat": "$5$ 行数据，分别是 $1$ 到 $5$ 号队员的测试数据，每行的 $10$ 个整数，表示某一个运动员尽力连续跑 $1\\rm km$ 、 $2\\rm km$、…、$10\\rm km$ 所用的时间。时间为一个不超过 $10^7$ 的正整数。", "outputFormat": "两行，第一行是最短的时间，第二行是五个数据，分别是 $1$ 到 $5$ 号队员各自连续跑的公里数。\n", "hint": "@Jomoo 提供了修正后的数据", "locale": "zh-CN", "translations": {"en": {"title": "Marathon Relay", "background": "", "description": "A city holds a winter around-the-city $25\\rm km$ marathon relay. Each team has $5$ participants. Each participant runs exactly once, with each leg being at least $1\\rm km$ and at most $10\\rm km$, and the distance each runner covers must be an integer, i.e., handoffs occur at whole-kilometer marks.\n\nCoach Liu, as the coach of the school team, carefully selected $5$ endurance runners and conducted training and tests to obtain the time each of the $5$ runners needs to run continuously for $1\\rm km$, $2\\rm km$, …, $10\\rm km$. He now needs to make a reasonable arrangement so that each runner runs a suitable number of kilometers, minimizing the total time to finish $25\\rm km$. Given the athletes’ abilities, this minimal time is unique, but the arrangement plan may not be unique.\n\nBased on the test results and typical athletes’ performance, running $1\\rm km$ continuously is faster than running $2\\rm km$, running $2\\rm km$ is faster than running $3\\rm km$, and so on. In other words, the longer the continuous distance, the slower the speed. There can be special cases where the speed does not slow down, but it can never get faster.", "inputFormat": "$5$ lines of data, corresponding to the test data of athletes $1$ to $5$. Each line contains $10$ integers, representing the time it takes that athlete to run continuously for $1\\rm km$, $2\\rm km$, …, $10\\rm km$. Each time is a positive integer not exceeding $10^7$.", "outputFormat": "Two lines. The first line is the minimal total time. The second line contains five integers, which are the consecutive kilometers covered by athletes $1$ to $5$.", "hint": "@Jomoo provided the corrected testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "马拉松接力赛", "background": "", "description": "某城市冬季举办环城 $25\\rm km$ 马拉松接力赛，每个代表队有 $5$ 人参加比赛，比赛要求每个的每名参赛选手只能跑一次，一次至少跑 $1\\rm km$ 、最多只能跑 $10\\rm km$，而且每个选手所跑的公里数必须为整数，即接力的地方在整公里处。\n\n刘老师作为学校代表队的教练，精心选择了 $5$ 名长跑能手，进行了训练和测试，得到了这 $5$ 名选手尽力连续跑 $1\\rm km$、$2\\rm km$、…、$10\\rm km$ 的所用时间。现在他要进行一个合理的安排，让每个选手跑合适的公里数，使学校代表队跑完 $25\\rm km$ 所用的时间最短。根据队员的情况，这个最短的时间是惟一的，但安排方案可能并不惟一。\n\n根据测试情况及一般运动员的情况得知，连续跑 $1\\rm km$ 要比连续跑 $2\\rm km$ 速度快，连续跑 $2\\rm km$ 又要比连续跑 $3\\rm km$ 速度快……也就是说连续跑的路程越长，速度越慢，当然也有特殊的，就是速度不会变慢，但是绝不可能变快。", "inputFormat": "$5$ 行数据，分别是 $1$ 到 $5$ 号队员的测试数据，每行的 $10$ 个整数，表示某一个运动员尽力连续跑 $1\\rm km$ 、 $2\\rm km$、…、$10\\rm km$ 所用的时间。时间为一个不超过 $10^7$ 的正整数。", "outputFormat": "两行，第一行是最短的时间，第二行是五个数据，分别是 $1$ 到 $5$ 号队员各自连续跑的公里数。\n", "hint": "@Jomoo 提供了修正后的数据", "locale": "zh-CN"}}}
{"pid": "P1253", "type": "P", "difficulty": 4, "samples": [["6 6\n1 1 4 5 1 4\n1 1 2 6\n2 3 4 2\n3 1 4\n3 2 3\n1 1 6 -1\n3 1 6\n", "7\n6\n-1"], ["4 4\n10 4 -3 -7\n1 1 3 0\n2 3 4 -4\n1 2 4 -9\n3 1 4", "0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "线段树", "O2优化"], "title": "扶苏的问题", "background": "", "description": "给定一个长度为 $n$ 的序列 $a$，要求支持如下三个操作：\n\n1. 给定区间 $[l, r]$，将区间内每个数都修改为 $x$。\n2. 给定区间 $[l, r]$，将区间内每个数都加上 $x$。\n3. 给定区间 $[l, r]$，求区间内的最大值。", "inputFormat": "第一行是两个整数，依次表示序列的长度 $n$ 和操作的个数 $q$。  \n第二行有 $n$ 个整数，第 $i$ 个整数表示序列中的第 $i$ 个数 $a_i$。  \n接下来 $q$ 行，每行表示一个操作。每行首先有一个整数 $op$，表示操作的类型。\n- 若 $op = 1$，则接下来有三个整数 $l, r, x$，表示将区间 $[l, r]$ 内的每个数都修改为 $x$。\n- 若 $op = 2$，则接下来有三个整数 $l, r, x$，表示将区间 $[l, r]$ 内的每个数都加上 $x$。\n- 若 $op = 3$，则接下来有两个整数 $l, r$，表示查询区间 $[l, r]$ 内的最大值。", "outputFormat": "对于每个 $op = 3$ 的操作，输出一行一个整数表示答案。", "hint": "### 数据规模与约定\n\n- 对于 $10\\%$ 的数据，$n = q = 1$。\n- 对于 $40\\%$ 的数据，$n, q \\leq 10^3$。\n- 对于 $50\\%$ 的数据，$0 \\leq a_i, x \\leq 10^4$。\n- 对于 $60\\%$ 的数据，$op \\neq 1$。\n- 对于 $90\\%$ 的数据，$n, q \\leq 10^5$。\n- 对于 $100\\%$ 的数据，$1 \\leq n, q \\leq 10^6$，$1 \\leq l, r \\leq n$，$op \\in \\{1, 2, 3\\}$，$|a_i|, |x| \\leq 10^9$。\n\n### 提示\n\n请注意大量数据读入对程序效率造成的影响。", "locale": "zh-CN", "translations": {"en": {"title": "Fusu's Problem", "background": "", "description": "Given a sequence $a$ of length $n$, support the following three operations:\n\n1. Given a range $[l, r]$, set every number in the range to $x$.\n2. Given a range $[l, r]$, add $x$ to every number in the range.\n3. Given a range $[l, r]$, query the maximum value in the range.", "inputFormat": "The first line contains two integers, the length of the sequence $n$ and the number of operations $q$.  \nThe second line contains $n$ integers, where the $i$-th integer is the $i$-th number $a_i$ in the sequence.  \nThen follow $q$ lines, each representing an operation. Each line starts with an integer $op$ indicating the type of operation.\n- If $op = 1$, then there are three integers $l, r, x$, meaning set every number in the range $[l, r]$ to $x$.\n- If $op = 2$, then there are three integers $l, r, x$, meaning add $x$ to every number in the range $[l, r]$.\n- If $op = 3$, then there are two integers $l, r$, meaning query the maximum value in the range $[l, r]$.", "outputFormat": "For each operation with $op = 3$, output one line with a single integer representing the answer.", "hint": "Constraints\n\n- For $10\\%$ of the testdata, $n = q = 1$.\n- For $40\\%$ of the testdata, $n, q \\leq 10^3$.\n- For $50\\%$ of the testdata, $0 \\leq a_i, x \\leq 10^4$.\n- For $60\\%$ of the testdata, $op \\neq 1$.\n- For $90\\%$ of the testdata, $n, q \\leq 10^5$.\n- For $100\\%$ of the testdata, $1 \\leq n, q \\leq 10^6$, $1 \\leq l, r \\leq n$, $op \\in \\{1, 2, 3\\}$, $|a_i|, |x| \\leq 10^9$.\n\nPlease note the impact of large input on program efficiency.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "扶苏的问题", "background": "", "description": "给定一个长度为 $n$ 的序列 $a$，要求支持如下三个操作：\n\n1. 给定区间 $[l, r]$，将区间内每个数都修改为 $x$。\n2. 给定区间 $[l, r]$，将区间内每个数都加上 $x$。\n3. 给定区间 $[l, r]$，求区间内的最大值。", "inputFormat": "第一行是两个整数，依次表示序列的长度 $n$ 和操作的个数 $q$。  \n第二行有 $n$ 个整数，第 $i$ 个整数表示序列中的第 $i$ 个数 $a_i$。  \n接下来 $q$ 行，每行表示一个操作。每行首先有一个整数 $op$，表示操作的类型。\n- 若 $op = 1$，则接下来有三个整数 $l, r, x$，表示将区间 $[l, r]$ 内的每个数都修改为 $x$。\n- 若 $op = 2$，则接下来有三个整数 $l, r, x$，表示将区间 $[l, r]$ 内的每个数都加上 $x$。\n- 若 $op = 3$，则接下来有两个整数 $l, r$，表示查询区间 $[l, r]$ 内的最大值。", "outputFormat": "对于每个 $op = 3$ 的操作，输出一行一个整数表示答案。", "hint": "### 数据规模与约定\n\n- 对于 $10\\%$ 的数据，$n = q = 1$。\n- 对于 $40\\%$ 的数据，$n, q \\leq 10^3$。\n- 对于 $50\\%$ 的数据，$0 \\leq a_i, x \\leq 10^4$。\n- 对于 $60\\%$ 的数据，$op \\neq 1$。\n- 对于 $90\\%$ 的数据，$n, q \\leq 10^5$。\n- 对于 $100\\%$ 的数据，$1 \\leq n, q \\leq 10^6$，$1 \\leq l, r \\leq n$，$op \\in \\{1, 2, 3\\}$，$|a_i|, |x| \\leq 10^9$。\n\n### 提示\n\n请注意大量数据读入对程序效率造成的影响。", "locale": "zh-CN"}}}
{"pid": "P1254", "type": "P", "difficulty": 5, "samples": [["1", "1\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "贪心"], "title": "扇区填数", "background": null, "description": "有一个圆，当输入一个整数\n $n\\ (1≤n≤8)$ 后，它被分成 $n$ 个扇区，请你为每一扇区选择一个正整数。\n\n向各个扇区放入数之后，你可以从单个扇区中选出—个数，也可以从相邻的两个或多个扇区中各选一个数，相加后形成一个新的数，请使用这些整数形成一个连续的整数序列：$1,2,3,\\cdots,i$，你的任务是使 $i$ 尽可能地大。", "inputFormat": "共一行一个整数 $n\\ (1\\le n \\le 8)$。", "outputFormat": "第一行是最大的 $i$，接下来的几行是所有能达到最大 $i$ 的填法。\n\n由于圆里不分顺序，所以同一种填法可以有多种输出。为了减少这种情况，这里规定从 $1$ 开始输出（因为连续数里要有 $1$，所以所填的数中肯定有 $1$）。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Sector Filling", "background": "", "description": "There is a circle. After an integer $n\\ (1≤n≤8)$ is given, it is divided into $n$ sectors. Please choose a positive integer for each sector.\n\nAfter placing the numbers, you may pick a single number from one sector, or pick one number from each of two or more adjacent sectors; summing them produces a new number. Use the integers obtained in this way to form a consecutive integer sequence: $1,2,3,\\cdots,i$, and make $i$ as large as possible.", "inputFormat": "One line containing an integer $n\\ (1\\le n \\le 8)$.", "outputFormat": "The first line contains the maximum $i$. The following lines list all fillings that achieve this maximum $i$.\n\nBecause a circle has no inherent order, the same filling may correspond to multiple outputs. To reduce this, it is required to list the numbers starting from $1$ (since the consecutive sequence must contain $1$, the filled numbers must include $1$).", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "扇区填数", "background": null, "description": "有一个圆，当输入一个整数\n $n\\ (1≤n≤8)$ 后，它被分成 $n$ 个扇区，请你为每一扇区选择一个正整数。\n\n向各个扇区放入数之后，你可以从单个扇区中选出—个数，也可以从相邻的两个或多个扇区中各选一个数，相加后形成一个新的数，请使用这些整数形成一个连续的整数序列：$1,2,3,\\cdots,i$，你的任务是使 $i$ 尽可能地大。", "inputFormat": "共一行一个整数 $n\\ (1\\le n \\le 8)$。", "outputFormat": "第一行是最大的 $i$，接下来的几行是所有能达到最大 $i$ 的填法。\n\n由于圆里不分顺序，所以同一种填法可以有多种输出。为了减少这种情况，这里规定从 $1$ 开始输出（因为连续数里要有 $1$，所以所填的数中肯定有 $1$）。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P1255", "type": "P", "difficulty": 2, "samples": [["4", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["高精度", "递推", "Fibonacci 数列"], "title": "数楼梯", "background": "", "description": "楼梯有 $N$ 阶，上楼可以一步上一阶，也可以一步上二阶。\n\n编一个程序，计算共有多少种不同的走法。", "inputFormat": "一个数字，楼梯数。\n", "outputFormat": "输出走的方式总数。\n", "hint": "- 对于 $60\\%$ 的数据，$N \\leq 50$；   \n- 对于 $100\\%$ 的数据，$1 \\le N \\leq 5000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Counting Stairs", "background": "", "description": "A staircase has $N$ steps. You can climb either 1 step or 2 steps at a time. Write a program to compute the number of distinct ways to reach the top.", "inputFormat": "A single integer $N$, the number of steps.", "outputFormat": "Output the total number of ways.", "hint": "- For $60\\%$ of the testdata, $N \\leq 50$.\n- For $100\\%$ of the testdata, $1 \\le N \\leq 5000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数楼梯", "background": "", "description": "楼梯有 $N$ 阶，上楼可以一步上一阶，也可以一步上二阶。\n\n编一个程序，计算共有多少种不同的走法。", "inputFormat": "一个数字，楼梯数。\n", "outputFormat": "输出走的方式总数。\n", "hint": "- 对于 $60\\%$ 的数据，$N \\leq 50$；   \n- 对于 $100\\%$ 的数据，$1 \\le N \\leq 5000$。\n", "locale": "zh-CN"}}}
{"pid": "P1256", "type": "P", "difficulty": 3, "samples": [["3 4\n0001\n0011\n0110\n", "3 2 1 0\n2 1 0 0\n1 0 0 1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "广度优先搜索 BFS"], "title": "显示图像", "background": "", "description": "古老的显示屏是由 $N \\times M$ 个像素（Pixel）点组成的。一个像素点的位置是根据所在行数和列数决定的。例如 $P(2,1)$ 表示第 $2$ 行第 $1$ 列的像素点。那时候，屏幕只能显示黑与白两种颜色，人们用二进制 $0$ 和 $1$ 来表示。$0$ 表示黑色，$1$ 表示白色。当计算机发出一个指令：$P(x,y)=1$，则屏幕上的第 $x$ 行第 $y$ 列的阴极射线管就开始工作，使该像素点显示白色，若 $P(x,y)=0$，则对应位置的阴极射线管不工作，像素点保持黑色。在某一单位时刻，计算机以 $N \\times M$ 二维 $01$ 矩阵的方式发出显示整个屏幕图像的命令。\n\n例如，屏幕是由 $3 \\times 4$ 的像素点组成，在某单位时刻，计算机发出如下命令：\n\n$$\\begin{pmatrix}\n0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 1 \\\\\n0 & 1 & 1 & 0 \\\\\n\\end{pmatrix}$$\n\n对应屏幕显示应为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cwg2di9s.png)\n\n假设放大后，一个格子表示一个像素点。\n\n由于未知的原因，显示黑色的像素点总是受显示白色的像素点的影响——可能是阴极射线管工作的作用。并且，距离越近，影响越大。这里的距离定义如下：\n\n设有像素点 $P_1(x_1,y_1)$ 和像素点 $P_2(x_2,y_2)$，则它们之间的距离 $D(P_1,P_2)=|x_1-x_2|+|y_1-y_2|$。\n\n在某一时刻，计算机发出显示命令后，科学家们期望知道，每个像素点和其最近的显示白色的像素点之间的最短距离是多少——科学家们保证屏幕上至少有一个显示白色的像素点。\n\n上面的例子中，像素 $P(1,1)$ 与最近的白色像素点之间的距离为 $3$，而像素 $P(3,2)$ 本身显示白色，所以最短距离为 $0$。\n", "inputFormat": "第一行有两个数字，$N$ 和 $M\\ (1 \\le N,M \\le 182)$，表示屏幕的规格。\n\n以下 $N$ 行，每行 $M$ 个数字，$0$ 或 $1$。为计算机发出的显示命令。", "outputFormat": "输出文件有 $N$ 行，每行 $M$ 个数字，中间用 $1$ 个空格分开。第 $i$ 行第 $j$ 列的数字表示距像素点 $P(i,j)$ 最近的白色像素点的最短距离。", "hint": "- 对于 $30\\%$ 的数据：$N\\times M \\le 10000$；\n- 对于 $100\\%$ 的数据：$N,M \\le 182$。", "locale": "zh-CN", "translations": {"en": {"title": "Displaying the Image", "background": "", "description": "An old display screen consists of $N \\times M$ pixels. The position of a pixel is determined by its row and column. For example, $P(2,1)$ denotes the pixel at row $2$, column $1$. At that time, the screen could only show two colors, black and white, represented by binary $0$ and $1$. $0$ denotes black and $1$ denotes white. When the computer issues an instruction $P(x,y)=1$, the cathode ray tube at row $x$, column $y$ on the screen starts working, making that pixel display white; if $P(x,y)=0$, then the corresponding cathode ray tube does not work, and the pixel remains black. At a certain moment, the computer issues a command for the entire screen in the form of an $N \\times M$ two-dimensional $01$ matrix.\n\nFor example, the screen consists of $3 \\times 4$ pixels. At some moment, the computer issues the following command:\n\n$$\\begin{pmatrix}\n0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 1 \\\\\n0 & 1 & 1 & 0 \\\\\n\\end{pmatrix}$$\n\nThe corresponding screen display should be:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cwg2di9s.png)\n\nAssume that after magnification, one cell represents one pixel.\n\nFor unknown reasons, black pixels are always affected by white pixels—possibly due to the operation of the cathode ray tube. Moreover, the closer the distance, the greater the influence. The distance is defined as follows:\n\nGiven pixel $P_1(x_1,y_1)$ and pixel $P_2(x_2,y_2)$, their distance is $D(P_1,P_2)=|x_1-x_2|+|y_1-y_2|$.\n\nAt a certain moment after the display command is issued, scientists want to know, for each pixel, the shortest distance to its nearest white pixel—scientists guarantee that there is at least one white pixel on the screen.\n\nIn the example above, the distance between pixel $P(1,1)$ and its nearest white pixel is $3$, while pixel $P(3,2)$ itself is white, so the shortest distance is $0$.", "inputFormat": "The first line contains two numbers, $N$ and $M\\ (1 \\le N,M \\le 182)$, indicating the screen size.\n\nThe next $N$ lines each contain $M$ numbers, $0$ or $1$. This is the display command issued by the computer.", "outputFormat": "Output $N$ lines, each containing $M$ numbers separated by a single space. The number in row $i$, column $j$ indicates the shortest distance from pixel $P(i,j)$ to its nearest white pixel.", "hint": "- For $30\\%$ of the testdata: $N\\times M \\le 10000$.\n- For $100\\%$ of the testdata: $N\\times M \\le 182^2$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "显示图像", "background": "", "description": "古老的显示屏是由 $N \\times M$ 个像素（Pixel）点组成的。一个像素点的位置是根据所在行数和列数决定的。例如 $P(2,1)$ 表示第 $2$ 行第 $1$ 列的像素点。那时候，屏幕只能显示黑与白两种颜色，人们用二进制 $0$ 和 $1$ 来表示。$0$ 表示黑色，$1$ 表示白色。当计算机发出一个指令：$P(x,y)=1$，则屏幕上的第 $x$ 行第 $y$ 列的阴极射线管就开始工作，使该像素点显示白色，若 $P(x,y)=0$，则对应位置的阴极射线管不工作，像素点保持黑色。在某一单位时刻，计算机以 $N \\times M$ 二维 $01$ 矩阵的方式发出显示整个屏幕图像的命令。\n\n例如，屏幕是由 $3 \\times 4$ 的像素点组成，在某单位时刻，计算机发出如下命令：\n\n$$\\begin{pmatrix}\n0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 1 \\\\\n0 & 1 & 1 & 0 \\\\\n\\end{pmatrix}$$\n\n对应屏幕显示应为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cwg2di9s.png)\n\n假设放大后，一个格子表示一个像素点。\n\n由于未知的原因，显示黑色的像素点总是受显示白色的像素点的影响——可能是阴极射线管工作的作用。并且，距离越近，影响越大。这里的距离定义如下：\n\n设有像素点 $P_1(x_1,y_1)$ 和像素点 $P_2(x_2,y_2)$，则它们之间的距离 $D(P_1,P_2)=|x_1-x_2|+|y_1-y_2|$。\n\n在某一时刻，计算机发出显示命令后，科学家们期望知道，每个像素点和其最近的显示白色的像素点之间的最短距离是多少——科学家们保证屏幕上至少有一个显示白色的像素点。\n\n上面的例子中，像素 $P(1,1)$ 与最近的白色像素点之间的距离为 $3$，而像素 $P(3,2)$ 本身显示白色，所以最短距离为 $0$。\n", "inputFormat": "第一行有两个数字，$N$ 和 $M\\ (1 \\le N,M \\le 182)$，表示屏幕的规格。\n\n以下 $N$ 行，每行 $M$ 个数字，$0$ 或 $1$。为计算机发出的显示命令。", "outputFormat": "输出文件有 $N$ 行，每行 $M$ 个数字，中间用 $1$ 个空格分开。第 $i$ 行第 $j$ 列的数字表示距像素点 $P(i,j)$ 最近的白色像素点的最短距离。", "hint": "- 对于 $30\\%$ 的数据：$N\\times M \\le 10000$；\n- 对于 $100\\%$ 的数据：$N,M \\le 182$。", "locale": "zh-CN"}}}
{"pid": "P1257", "type": "P", "difficulty": 2, "samples": [["3\n1 1\n1 2\n2 2\n", "1.0000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "O2优化", "枚举"], "title": "平面上的最接近点对", "background": null, "description": "给定平面上 $n$ 个点，找出其中的一对点的距离，使得在这 $n$ 个点的所有点对中，该距离为所有点对中最小的。", "inputFormat": "第一行一个整数 $n$，表示点的个数。\n\n接下来 $n$ 行，每行两个整数 $x,y$，表示一个点的行坐标和列坐标。", "outputFormat": "仅一行，一个实数，表示最短距离，四舍五入保留 $4$ 位小数。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $2 \\leq n \\leq 10^4$，$0 \\leq x, y \\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "Closest Pair of Points in the Plane", "background": "", "description": "Given $n$ points in the plane, find the distance between a pair of points such that among all pairs of these $n$ points, this distance is the smallest.", "inputFormat": "The first line contains an integer $n$, denoting the number of points.\nThe next $n$ lines each contain two integers $x,y$, representing the $x$ and $y$ coordinates of a point.", "outputFormat": "Output a single line containing a real number, which is the shortest distance, rounded to $4$ decimal places.", "hint": "#### Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that $2 \\leq n \\leq 10^4$, $0 \\leq x, y \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "平面上的最接近点对", "background": null, "description": "给定平面上 $n$ 个点，找出其中的一对点的距离，使得在这 $n$ 个点的所有点对中，该距离为所有点对中最小的。", "inputFormat": "第一行一个整数 $n$，表示点的个数。\n\n接下来 $n$ 行，每行两个整数 $x,y$，表示一个点的行坐标和列坐标。", "outputFormat": "仅一行，一个实数，表示最短距离，四舍五入保留 $4$ 位小数。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $2 \\leq n \\leq 10^4$，$0 \\leq x, y \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P1258", "type": "P", "difficulty": 2, "samples": [["120 5 25\n", "9.600000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "二分"], "title": "小车问题", "background": "", "description": "甲、乙两人同时从 A 地出发要尽快同时赶到 B 地。出发时 A 地有一辆小车，可是这辆小车除了驾驶员外只能带一人。已知甲、乙两人的步行速度一样，且小于车的速度。问：怎样利用小车才能使两人尽快同时到达。", "inputFormat": "仅一行，三个实数，分别表示 AB 两地的距离 $s$，人的步行速度 $a$，车的速度 $b$。", "outputFormat": "两人同时到达 B 地需要的最短时间，保留 $6$ 位小数。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $0 \\leq s, a, b \\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "The Small Car Problem", "background": "", "description": "Two people, Jia and Yi, start from point A at the same time and want to arrive at point B simultaneously as quickly as possible. At the departure time, there is a car at A, but this car can carry only one passenger in addition to the driver. It is known that Jia and Yi have the same walking speed, and it is less than the car’s speed. How should the car be used so that both arrive at point B at the same time as quickly as possible?", "inputFormat": "A single line with three real numbers, representing the distance $s$ between points A and B, the walking speed $a$, and the car’s speed $b$.", "outputFormat": "The minimum time for both to arrive at point B simultaneously, rounded to $6$ decimal places.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that $0 \\leq s, a, b \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小车问题", "background": "", "description": "甲、乙两人同时从 A 地出发要尽快同时赶到 B 地。出发时 A 地有一辆小车，可是这辆小车除了驾驶员外只能带一人。已知甲、乙两人的步行速度一样，且小于车的速度。问：怎样利用小车才能使两人尽快同时到达。", "inputFormat": "仅一行，三个实数，分别表示 AB 两地的距离 $s$，人的步行速度 $a$，车的速度 $b$。", "outputFormat": "两人同时到达 B 地需要的最短时间，保留 $6$ 位小数。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $0 \\leq s, a, b \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P1259", "type": "P", "difficulty": 3, "samples": [["7", "ooooooo*******--\noooooo--******o*\noooooo******--o*\nooooo--*****o*o*\nooooo*****--o*o*\noooo--****o*o*o*\noooo****--o*o*o*\nooo--***o*o*o*o*\nooo*o**--*o*o*o*\no--*o**oo*o*o*o*\no*o*o*--o*o*o*o*\n--o*o*o*o*o*o*o*\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["递归", "Special Judge"], "title": "黑白棋子的移动", "background": "", "description": "有 $2n$ 个棋子排成一行，开始为位置白子全部在左边，黑子全部在右边，如下图为 $n=5$ 的情况：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dzfwand6.png)\n\n移动棋子的规则是：每次必须同时移动相邻的两个棋子，颜色不限，可以左移也可以右移到空位上去，但不能调换两个棋子的左右位置。每次移动必须跳过若干个棋子（不能平移），要求最后能移成黑白相间的一行棋子。如 $n=5$ 时，成为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yus9ph6d.png)\n\n任务：编程打印出移动过程。", "inputFormat": "\n一个整数 $n$。", "outputFormat": "若干行，表示初始状态和每次移动的状态，用 $\\verb!o!$ 表示白子，$\\verb!*!$ 表示黑子，$\\verb!-!$ 表示空行。\n", "hint": " $ 4\\leq n\\leq 100$ ", "locale": "zh-CN", "translations": {"en": {"title": "Movement of Black and White Pieces", "background": "# Description\n\nThere are $2n$ pieces arranged in a row. Initially, all white pieces are on the left and all black pieces are on the right. The following figure shows the case $n=5$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dzfwand6.png)\n\nThe rules for moving the pieces are as follows: in each move, you must move two adjacent pieces simultaneously, regardless of their colors. They may move left or right into empty positions, but their left–right order cannot be swapped. Each move must jump over one or more pieces (you cannot simply slide). The goal is to obtain a row of pieces alternating in color. For example, when $n=5$, the target becomes:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yus9ph6d.png)\n\nTask: write a program to print the whole sequence of moves.", "description": "There are $2n$ pieces arranged in a row. Initially, all white pieces are on the left and all black pieces are on the right. The following figure shows the case $n=5$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dzfwand6.png)\n\nThe rules for moving the pieces are as follows: in each move, you must move two adjacent pieces simultaneously, regardless of their colors. They may move left or right into empty positions, but their left–right order cannot be swapped. Each move must jump over one or more pieces (you cannot simply slide). The goal is to obtain a row of pieces alternating in color. For example, when $n=5$, the target becomes:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yus9ph6d.png)\n\nTask: write a program to print the whole sequence of moves.\n\n# Description", "inputFormat": "A single integer $n$.", "outputFormat": "Multiple lines, showing the initial state and the state after each move. Use 'o' to denote a white piece, '*' to denote a black piece, and '-' to denote an empty cell.", "hint": "Constraints: $4 \\leq n \\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "黑白棋子的移动", "background": "", "description": "有 $2n$ 个棋子排成一行，开始为位置白子全部在左边，黑子全部在右边，如下图为 $n=5$ 的情况：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dzfwand6.png)\n\n移动棋子的规则是：每次必须同时移动相邻的两个棋子，颜色不限，可以左移也可以右移到空位上去，但不能调换两个棋子的左右位置。每次移动必须跳过若干个棋子（不能平移），要求最后能移成黑白相间的一行棋子。如 $n=5$ 时，成为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yus9ph6d.png)\n\n任务：编程打印出移动过程。", "inputFormat": "\n一个整数 $n$。", "outputFormat": "若干行，表示初始状态和每次移动的状态，用 $\\verb!o!$ 表示白子，$\\verb!*!$ 表示黑子，$\\verb!-!$ 表示空行。\n", "hint": " $ 4\\leq n\\leq 100$ ", "locale": "zh-CN"}}}
{"pid": "P1260", "type": "P", "difficulty": 4, "samples": [["5 8\n1 2 0\n1 5 -1\n2 5 1\n3 1 5\n4 1 4\n4 3 -1\n5 3 -1\n5 4 -3", "0\n2\n5\n4\n1\n"], ["5 5\n1 2 -3\n1 5 -1\n2 5 -1\n5 1 -5\n4 1 4", "NO SOLUTION\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "Special Judge", "差分约束"], "title": "工程规划", "background": "", "description": "造一幢大楼是一项艰巨的工程，它是由 $n$ 个子任务构成的，给它们分别编号 $1,2,\\cdots,n\\ (5≤n≤1000)$。由于对一些任务的起始条件有着严格的限制，所以每个任务的起始时间 $T_1,T_2,\\cdots,T_n$ 并不是很容易确定的(但这些起始时间都是非负整数，因为它们必须在整个工程开始后启动)。例如：挖掘完成后，紧接着就要打地基；但是混凝土浇筑完成后，却要等待一段时间再去掉模板。\n\n这种要求就可以用 $m\\ (5≤m≤5000)$ 个不等式表示，不等式形如 $T_i-T_j≤b$ 代表 $i$ 和 $j$ 的起始时间必须满足的条件。每个不等式的右边都是一个常数 $b$，这些常数可能不相同，但是它们都在区间 $(-100,100)$ 内。\n\n你的任务就是写一个程序，给定像上面那样的不等式，找出一种可能的起始时间序列 $T_1,T_2,\\cdots,T_n$，或者判断问题无解。对于有解的情况，要使最早进行的那个任务和整个工程的起始时间相同，也就是说，$T_1,T_2,\\cdots,T_n$ 中至少有一个为 $0$。\n", "inputFormat": "第一行是用空格隔开的两个正整数 $n$ 和 $m$，下面的 $m$ 行每行有三个用空格隔开的整数 $i,j,b$ 对应着不等式 $T_i-T_j≤b$。\n", "outputFormat": "如果有可行的方案，那么输出 $n$ 行，每行都有一个非负整数且至少有一个为 $0$，按顺序表示每个任务的起始时间。如果没有可行的方案，就输出信息 `NO SOLUTION`。\n", "hint": "由@zhouyonglong提供SPJ\n", "locale": "zh-CN", "translations": {"en": {"title": "Project Planning", "background": "", "description": "Building a skyscraper is a challenging project composed of $n$ subtasks, numbered $1, 2, \\cdots, n$ ($5 \\le n \\le 1000$). Due to strict constraints on the starting conditions of some tasks, the start times $T_1, T_2, \\cdots, T_n$ are not easy to determine (however, these start times are all non-negative integers because they must start after the entire project begins). For example: after excavation is completed, the foundation must be laid immediately; but after concrete pouring is completed, one must wait for a while before removing the formwork.\n\nSuch requirements can be expressed by $m$ ($5 \\le m \\le 5000$) inequalities. An inequality of the form $T_i - T_j ≤ b$ represents a constraint that the start times of tasks $i$ and $j$ must satisfy. The right-hand side of each inequality is a constant $b$. These constants may differ, but they all lie within the interval $(-100, 100)$.\n\nYour task is to write a program that, given inequalities like the above, finds a possible sequence of start times $T_1, T_2, \\cdots, T_n$, or determines that the problem has no solution. For solvable cases, the earliest task must start at the same time as the entire project, that is, at least one of $T_1, T_2, \\cdots, T_n$ equals $0$.", "inputFormat": "The first line contains two positive integers $n$ and $m$ separated by a space. Each of the next $m$ lines contains three integers $i, j, b$ separated by spaces, corresponding to the inequality $T_i - T_j ≤ b$.", "outputFormat": "If there is a feasible solution, output $n$ lines. Each line contains a non-negative integer, and at least one of them must be $0$, representing in order the start time of each task. If there is no feasible solution, output the message `NO SOLUTION`.", "hint": "SPJ provided by @zhouyonglong.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "工程规划", "background": "", "description": "造一幢大楼是一项艰巨的工程，它是由 $n$ 个子任务构成的，给它们分别编号 $1,2,\\cdots,n\\ (5≤n≤1000)$。由于对一些任务的起始条件有着严格的限制，所以每个任务的起始时间 $T_1,T_2,\\cdots,T_n$ 并不是很容易确定的(但这些起始时间都是非负整数，因为它们必须在整个工程开始后启动)。例如：挖掘完成后，紧接着就要打地基；但是混凝土浇筑完成后，却要等待一段时间再去掉模板。\n\n这种要求就可以用 $m\\ (5≤m≤5000)$ 个不等式表示，不等式形如 $T_i-T_j≤b$ 代表 $i$ 和 $j$ 的起始时间必须满足的条件。每个不等式的右边都是一个常数 $b$，这些常数可能不相同，但是它们都在区间 $(-100,100)$ 内。\n\n你的任务就是写一个程序，给定像上面那样的不等式，找出一种可能的起始时间序列 $T_1,T_2,\\cdots,T_n$，或者判断问题无解。对于有解的情况，要使最早进行的那个任务和整个工程的起始时间相同，也就是说，$T_1,T_2,\\cdots,T_n$ 中至少有一个为 $0$。\n", "inputFormat": "第一行是用空格隔开的两个正整数 $n$ 和 $m$，下面的 $m$ 行每行有三个用空格隔开的整数 $i,j,b$ 对应着不等式 $T_i-T_j≤b$。\n", "outputFormat": "如果有可行的方案，那么输出 $n$ 行，每行都有一个非负整数且至少有一个为 $0$，按顺序表示每个任务的起始时间。如果没有可行的方案，就输出信息 `NO SOLUTION`。\n", "hint": "由@zhouyonglong提供SPJ\n", "locale": "zh-CN"}}}
