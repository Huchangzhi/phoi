{"pid": "P12852", "type": "P", "difficulty": 0, "samples": [["4\n1 1 1", "7\n4 3 4 2 4 3 4"], ["4\n1 2 3", "3\n2 3 4"], ["6\n1 1 2 2 2", "17\n3 2 3 6 3 5 3 6 3 4 3 6 3 5 3 6 3"], ["5\n1 2 1 1", "11\n5 4 5 2 5 4 5 3 5 4 5"], ["5\n1 1 2 3", "8\n3 5 2 5 3 4 3 5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2020 Online] Color the Tree", "background": "", "description": "Christina has a rooted tree with $n$ vertices. Initially, all vertices are colored green, except for the root, which is colored red. Christina thinks that the tree is $\\emph{beautiful}$ if two rules are satisfied:\n\n- The root is colored red.\n- If the vertex is colored red, all vertices on the shortest path between it and the root are also red.\n\nChristina repeatedly performs the following operation on the tree --- chooses a vertex and changes its color (if it was red, colors it green; if it was green, colors it red). \nThe following rules must be satisfied while performing the operations:\n\n- The tree should stay beautiful.\n- The coloring of vertices should be unique. That means there is no moment in the past when each vertex had the same color as it has right now.\n\nYour task is to help Christina build the longest possible sequence of operations following the rules.", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 20$) --- the number of vertices in the tree.\n\nThe second line contains $n - 1$ integers $p_i$ ($1 \\le p_i \\le i$ for $1 \\le i \\le n - 1$), denoting parent vertices in the tree. The vertices in the tree are numbered from $1$ to $n$, the root has number $1$, the $i$-th vertex has parent $p_{i-1}$ for $2 \\le i \\le n$.", "outputFormat": "On the first line output an integer $m$ --- the maximum number of operations. \n\nOn the second line output $m$ integers $o_i$ ($2 \\le o_i \\le n)$. $o_i$ is the number of the vertex that changes color during the corresponding operation.\n\nIf there are several possible longest sequences, output any one of them.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2020 Online] Color the Tree", "background": "", "description": "Christina has a rooted tree with $n$ vertices. Initially, all vertices are colored green, except for the root, which is colored red. Christina thinks that the tree is $\\emph{beautiful}$ if two rules are satisfied:\n\n- The root is colored red.\n- If the vertex is colored red, all vertices on the shortest path between it and the root are also red.\n\nChristina repeatedly performs the following operation on the tree --- chooses a vertex and changes its color (if it was red, colors it green; if it was green, colors it red). \nThe following rules must be satisfied while performing the operations:\n\n- The tree should stay beautiful.\n- The coloring of vertices should be unique. That means there is no moment in the past when each vertex had the same color as it has right now.\n\nYour task is to help Christina build the longest possible sequence of operations following the rules.", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 20$) --- the number of vertices in the tree.\n\nThe second line contains $n - 1$ integers $p_i$ ($1 \\le p_i \\le i$ for $1 \\le i \\le n - 1$), denoting parent vertices in the tree. The vertices in the tree are numbered from $1$ to $n$, the root has number $1$, the $i$-th vertex has parent $p_{i-1}$ for $2 \\le i \\le n$.", "outputFormat": "On the first line output an integer $m$ --- the maximum number of operations. \n\nOn the second line output $m$ integers $o_i$ ($2 \\le o_i \\le n)$. $o_i$ is the number of the vertex that changes color during the corresponding operation.\n\nIf there are several possible longest sequences, output any one of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2020 Online] Color the Tree", "background": "", "description": "Christina 有一棵包含 $n$ 个顶点的有根树。初始时，除根节点为红色外，所有顶点均为绿色。Christina 认为这棵树**美丽**的条件是满足以下两条规则：\n\n- 根节点必须为红色。\n- 如果某个顶点为红色，则该顶点到根节点的最短路径上的所有顶点也必须为红色。\n\nChristina 会反复对树执行以下操作——选择一个顶点并改变其颜色（若为红色则变为绿色，若为绿色则变为红色）。执行操作时必须满足以下规则：\n\n- 树必须始终保持美丽。\n- 顶点的着色必须是唯一的。即任何时候都不能出现与过去某一时刻完全相同的着色状态。\n\n你的任务是帮助 Christina 构建一个符合规则的最长操作序列。", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 20$）——树中顶点的数量。\n\n第二行包含 $n - 1$ 个整数 $p_i$（$1 \\le p_i \\le i$，$1 \\le i \\le n - 1$），表示树中父顶点的编号。树中顶点编号为 $1$ 到 $n$，根节点编号为 $1$，第 $i$ 个顶点（$2 \\le i \\le n$）的父节点为 $p_{i-1}$。\n", "outputFormat": "第一行输出一个整数 $m$——最大操作次数。\n\n第二行输出 $m$ 个整数 $o_i$（$2 \\le o_i \\le n$），表示每次操作中改变颜色的顶点编号。\n\n若存在多个最长操作序列，输出其中任意一个即可。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12853", "type": "P", "difficulty": 0, "samples": [["3\nWWWWWWWW\nRRRRRRRR\nWWWWWWWW", "221"], ["7\nWWWWRRWW\nWWWRRRWW\nWWWRRWWW\nWWRRRWWW\nWWRRWWWW\nWRRRWWWW\nWRRWWWWW", "2111121"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "ICPC", "NERC/NEERC"], "title": "[NERC 2020 Online] Down We Dig", "background": "", "description": "Dina and Dima are young archeologists exploring an ancient mosaic-covered staircase attributed to Dacian culture (presumably, king Decebalus himself) in Danube Delta (modern Dobruja region).\n\nEach step is covered with 8 pieces of mosaic, each being either white or red.\nEach morning they undig exactly one step of the stairway, obviously from top to bottom.\n\nEach afternoon while walking down the staircase towards the working area after lunch, they play a game. They put (very carefully) a handkerchief on the topmost step. Then they make moves in turn, starting with Dina. Each move, a player moves the handkerchief down a few steps.\nIt is only allowed to move the handkerchief from one step to a lower step if the distance between these steps is less than or equal to the number of their common mosaic pieces (pairs of the same color in the same positions).\nThe player who can not make a move loses today's game.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qz4uce2i.png)\n\nFor example, here Dina can move the handkerchief from the topmost step to the middle one (because $1 \\le 7$) or to the bottom one (because $2 \\le 6$).\n\nFor each afternoon, find out who wins the game if they both play optimally.", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 300\\,000$) --- the height of the staircase.\n\nEach of the next $n$ lines contains 8 characters `W` or `R` --- the descriptions of steps from top to bottom.", "outputFormat": "Output a line with $n$ digits, one digit for each afternoon game. 1 means that Dina wins, 2 means that Dima wins.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2020 Online] Down We Dig", "background": "", "description": "Dina and Dima are young archeologists exploring an ancient mosaic-covered staircase attributed to Dacian culture (presumably, king Decebalus himself) in Danube Delta (modern Dobruja region).\n\nEach step is covered with 8 pieces of mosaic, each being either white or red.\nEach morning they undig exactly one step of the stairway, obviously from top to bottom.\n\nEach afternoon while walking down the staircase towards the working area after lunch, they play a game. They put (very carefully) a handkerchief on the topmost step. Then they make moves in turn, starting with Dina. Each move, a player moves the handkerchief down a few steps.\nIt is only allowed to move the handkerchief from one step to a lower step if the distance between these steps is less than or equal to the number of their common mosaic pieces (pairs of the same color in the same positions).\nThe player who can not make a move loses today's game.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qz4uce2i.png)\n\nFor example, here Dina can move the handkerchief from the topmost step to the middle one (because $1 \\le 7$) or to the bottom one (because $2 \\le 6$).\n\nFor each afternoon, find out who wins the game if they both play optimally.", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 300\\,000$) --- the height of the staircase.\n\nEach of the next $n$ lines contains 8 characters `W` or `R` --- the descriptions of steps from top to bottom.", "outputFormat": "Output a line with $n$ digits, one digit for each afternoon game. 1 means that Dina wins, 2 means that Dima wins.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2020 Online] Down We Dig", "background": "", "description": "Dina 和 Dima 是年轻的考古学家，他们正在多瑙河三角洲（今多布罗加地区）探索一座被认为属于达契亚文化（可能是国王德切巴鲁斯本人）的古老马赛克阶梯。\n\n每个台阶上都覆盖着 8 块马赛克，每块马赛克要么是白色（W），要么是红色（R）。每天早上，他们都会从上往下挖掘恰好一个台阶。\n\n每天下午吃完午饭后，当他们沿着阶梯走向工作区域时，他们会玩一个游戏。他们会（非常小心地）将一块手帕放在最顶层的台阶上。然后由 Dina 先手，两人轮流移动手帕。每次移动时，玩家可以将手帕向下移动若干个台阶。只有当两个台阶之间的距离小于或等于它们共同马赛克块数（相同位置颜色相同的马赛克对数）时，才允许将手帕从一个台阶移动到另一个较低的台阶。无法移动的玩家将输掉当天的游戏。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qz4uce2i.png)\n\n例如，在上图中，Dina 可以将手帕从最顶层移动到中间台阶（因为 $1 \\le 7$），或者移动到底部台阶（因为 $2 \\le 6$）。\n\n对于每个下午的游戏，如果双方都采取最优策略，请判断谁会获胜。", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 300\\,000$）——阶梯的高度。\n\n接下来的 $n$ 行，每行包含 8 个字符 `W` 或 `R`——从上到下描述每个台阶的马赛克图案。\n", "outputFormat": "输出一行包含 $n$ 个数字，每个数字对应一个下午的游戏结果。1 表示 Dina 获胜，2 表示 Dima 获胜。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12854", "type": "P", "difficulty": 2, "samples": [["3\n9 6\n40 60\n60 40", "4\n13\n29"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288]}, "tags": ["数学", "2020", "ICPC", "NERC/NEERC"], "title": "[NERC 2020 Online] Easy Measurements", "background": "", "description": "Edward was tasked to measure the pumping rate of two water pumps. To do so, he used the pumps to pump water into a water tank and checked how much water was pumped into the tank in a specific time.\n\nHe found out that the first pump pumps $a$ liters of water in $b$ seconds, and the second pump pumps $c$ liters of water in $d$ seconds. He also discovered that when both pumps are used at the same time, together they pump $b$ liters of water in $d$ seconds.\n\nUnfortunately, Edward has spilled some water on his records, so now he can't recover the values $a$ and $c$. However, he remembers that these values were positive integers. Now he wonders how many ways are there to choose the values $a$ and $c$ that are consistent with his measurements.", "inputFormat": "The first line contains an integer $n$ ($1\\le n\\le1000$) --- the number of test cases.\n\nEach of the next $n$ lines contains two integers $b$ and $d$ ($1\\le b,d\\le10^9$).", "outputFormat": "For each test case, output a single integer --- the number of ways to choose $a$ and $c$. Output each answer on a separate line.", "hint": "In the first test case, the possible values are $a=3$, $c=7$; $a=6$, $c=5$; $a=9$, $c=3$; and $a=12$, $c=1$.", "locale": "en", "translations": {"en": {"title": "[NERC 2020 Online] Easy Measurements", "background": "", "description": "Edward was tasked to measure the pumping rate of two water pumps. To do so, he used the pumps to pump water into a water tank and checked how much water was pumped into the tank in a specific time.\n\nHe found out that the first pump pumps $a$ liters of water in $b$ seconds, and the second pump pumps $c$ liters of water in $d$ seconds. He also discovered that when both pumps are used at the same time, together they pump $b$ liters of water in $d$ seconds.\n\nUnfortunately, Edward has spilled some water on his records, so now he can't recover the values $a$ and $c$. However, he remembers that these values were positive integers. Now he wonders how many ways are there to choose the values $a$ and $c$ that are consistent with his measurements.", "inputFormat": "The first line contains an integer $n$ ($1\\le n\\le1000$) --- the number of test cases.\n\nEach of the next $n$ lines contains two integers $b$ and $d$ ($1\\le b,d\\le10^9$).", "outputFormat": "For each test case, output a single integer --- the number of ways to choose $a$ and $c$. Output each answer on a separate line.", "hint": "In the first test case, the possible values are $a=3$, $c=7$; $a=6$, $c=5$; $a=9$, $c=3$; and $a=12$, $c=1$.", "locale": "en"}, "zh-CN": {"title": "[NERC 2020 Online] Easy Measurements", "background": "", "description": "Edward 需要测量两个水泵的抽水速率。为此，他使用这两个水泵向水箱中注水，并记录在特定时间内注入水箱的水量。\n\n他发现第一个水泵在 $b$ 秒内抽了 $a$ 升水，第二个水泵在 $d$ 秒内抽了 $c$ 升水。他还发现当两个水泵同时工作时，它们一起在 $d$ 秒内抽了 $b$ 升水。\n\n不幸的是，Edward 的记录被水浸湿了，导致他无法恢复 $a$ 和 $c$ 的具体数值。但他记得这两个值都是正整数。现在他想知道有多少种选择 $a$ 和 $c$ 的方式符合他的测量结果。\n", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 1000$）——测试用例的数量。\n\n接下来的 $n$ 行，每行包含两个整数 $b$ 和 $d$（$1 \\le b, d \\le 10^9$）。\n", "outputFormat": "对于每个测试用例，输出一个整数——表示选择 $a$ 和 $c$ 的方式数量。每个答案单独占一行。\n", "hint": "在第一个测试用例中，可能的取值组合为 $a=3$, $c=7$；$a=6$, $c=5$；$a=9$, $c=3$；以及 $a=12$, $c=1$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12855", "type": "P", "difficulty": 7, "samples": [["1 1 1 10", "74529"], ["1 2 1 10", "189347824"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "各省省选", "2022", "福建", "ICPC", "NERC/NEERC"], "title": "[NERC 2020 Online] Find a Square", "background": "", "description": "Frank likes square numbers. That is numbers, which are the product of some integer with itself. Also Frank likes quadratic polynomials. He even has his favorite one: $p(x) = a \\cdot x^2 + b \\cdot x + c$. \n\nThis morning Frank evaluated his favorite quadratic polynomial for $n$ consecutive integer arguments starting from $0$ and multiplied all the numbers he got.\n\nIf the resulting product is a square, his day is just perfect, but that might be not the case. So he asks you to find the largest square number which is a divisor of the resulting product.", "inputFormat": "The only line of the input contains 4 integers $a, b, c, n$ ($1 \\le a,b,c,n \\le 600\\,000$). \n", "outputFormat": "Find the largest square divisor of $\\prod\\limits_{i=0}^{n-1}{p(i)}$. As this number could be very large, output a single integer --- its remainder modulo $10^9+7$.", "hint": "In the first example, the product is equal to $1\\cdot 3\\cdot 7\\cdot 13\\cdot 21\\cdot 31\\cdot 43\\cdot 57\\cdot 73\\cdot 91 = 2893684641939 = 38826291 \\cdot 273^2$.", "locale": "en", "translations": {"en": {"title": "[NERC 2020 Online] Find a Square", "background": "", "description": "Frank likes square numbers. That is numbers, which are the product of some integer with itself. Also Frank likes quadratic polynomials. He even has his favorite one: $p(x) = a \\cdot x^2 + b \\cdot x + c$. \n\nThis morning Frank evaluated his favorite quadratic polynomial for $n$ consecutive integer arguments starting from $0$ and multiplied all the numbers he got.\n\nIf the resulting product is a square, his day is just perfect, but that might be not the case. So he asks you to find the largest square number which is a divisor of the resulting product.", "inputFormat": "The only line of the input contains 4 integers $a, b, c, n$ ($1 \\le a,b,c,n \\le 600\\,000$). \n", "outputFormat": "Find the largest square divisor of $\\prod\\limits_{i=0}^{n-1}{p(i)}$. As this number could be very large, output a single integer --- its remainder modulo $10^9+7$.", "hint": "In the first example, the product is equal to $1\\cdot 3\\cdot 7\\cdot 13\\cdot 21\\cdot 31\\cdot 43\\cdot 57\\cdot 73\\cdot 91 = 2893684641939 = 38826291 \\cdot 273^2$.", "locale": "en"}, "zh-CN": {"title": "[NERC 2020 Online] Find a Square", "background": "", "description": "Frank 喜欢平方数。平方数是指某个整数与自身相乘得到的数。Frank 还喜欢二次多项式，他尤其钟爱一个特定的二次多项式：$p(x) = a \\cdot x^2 + b \\cdot x + c$。\n\n今天早上，Frank 用他最喜欢的二次多项式计算了从 $0$ 开始的连续 $n$ 个整数的值，并将所有结果相乘。\n\n如果最终乘积是一个平方数，那么他今天就会非常开心。但实际情况可能并非如此。因此，他请你找出这个乘积的最大平方因数。\n", "inputFormat": "输入仅有一行，包含 4 个整数 $a, b, c, n$（$1 \\le a, b, c, n \\le 600\\,000$）。\n", "outputFormat": "找出 $\\prod\\limits_{i=0}^{n-1}{p(i)}$ 的最大平方因数。由于这个数可能非常大，输出其对 $10^9+7$ 取模后的结果。\n", "hint": "在第一个样例中，乘积为 $1 \\cdot 3 \\cdot 7 \\cdot 13 \\cdot 21 \\cdot 31 \\cdot 43 \\cdot 57 \\cdot 73 \\cdot 91 = 2893684641939 = 38826291 \\cdot 273^2$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12856", "type": "P", "difficulty": 0, "samples": [["2\n0 -1 -4 3 4 3\n5 4 0 1 3 -2", "15\n2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "ICPC", "NERC/NEERC"], "title": "[NERC 2020 Online] Geometrical Combinatorics", "background": "", "description": "Grace is developing a brand new theory of geometrical combinatorics --- a study about geometrical properties of combinatoric objects. \n\nConsider two triangles on plane --- a Pascal's triangle and an ordinary triangle. Pascal's triangle is drawn with it's root at point (0, 0), and two sides along diagonals of upper-halfplane quarters. Formally, there are 1's written in points $(i, i)$ and $(-i, i)$, and between them at point $(-i + 2 k, i)$ there is a number equal to the sum of numbers at $(-i + 2k + 1, i - 1)$ and at $(-i + 2k - 1, i - 1)$ for all $k$ from $1$ to $i - 1$. An ordinary triangle is drawn as just a triangle with vertices at $(x_A, y_A)$, $(x_B, y_B)$, $(x_C, y_C)$. \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3gacksfw.png)\n\nGrace defines an $\\emph{intersection value}$ of Pascal's triangle and an ordinary triangle as the sum of values of Pascal's triangle inside or on the border of the ordinary triangle. Can you develop a program that calculates this intersection value?", "inputFormat": "On the first line there is an integer $t$ ($1 \\le t \\le 5$) --- the number of tests to process. Each of the next $t$ lines contains 6 integers $x_A$, $y_A$, $x_B$, $y_B$, $x_C$, $y_C$ ($-10^6 \\le x_A, y_A, x_B, y_B, x_C, y_C \\le 10^6$). Three points in each test do not lie on a line.", "outputFormat": "For each test output an integer --- the intersection value modulo $10^9+7$. ", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2020 Online] Geometrical Combinatorics", "background": "", "description": "Grace is developing a brand new theory of geometrical combinatorics --- a study about geometrical properties of combinatoric objects. \n\nConsider two triangles on plane --- a Pascal's triangle and an ordinary triangle. Pascal's triangle is drawn with it's root at point (0, 0), and two sides along diagonals of upper-halfplane quarters. Formally, there are 1's written in points $(i, i)$ and $(-i, i)$, and between them at point $(-i + 2 k, i)$ there is a number equal to the sum of numbers at $(-i + 2k + 1, i - 1)$ and at $(-i + 2k - 1, i - 1)$ for all $k$ from $1$ to $i - 1$. An ordinary triangle is drawn as just a triangle with vertices at $(x_A, y_A)$, $(x_B, y_B)$, $(x_C, y_C)$. \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3gacksfw.png)\n\nGrace defines an $\\emph{intersection value}$ of Pascal's triangle and an ordinary triangle as the sum of values of Pascal's triangle inside or on the border of the ordinary triangle. Can you develop a program that calculates this intersection value?", "inputFormat": "On the first line there is an integer $t$ ($1 \\le t \\le 5$) --- the number of tests to process. Each of the next $t$ lines contains 6 integers $x_A$, $y_A$, $x_B$, $y_B$, $x_C$, $y_C$ ($-10^6 \\le x_A, y_A, x_B, y_B, x_C, y_C \\le 10^6$). Three points in each test do not lie on a line.", "outputFormat": "For each test output an integer --- the intersection value modulo $10^9+7$. ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2020 Online] Geometrical Combinatorics", "background": "", "description": "Grace 正在发展一种全新的几何组合学理论——研究组合对象的几何性质。\n\n考虑平面上的两个三角形——**帕斯卡三角形**和**普通三角形**。帕斯卡三角形的根位于点 $(0, 0)$，两条边沿着上半平面象限的对角线延伸。正式定义如下：\n- 在点 $(i, i)$ 和 $(-i, i)$ 处标记数字 $1$；\n- 对于 $k$ 从 $1$ 到 $i-1$，在点 $(-i + 2k, i)$ 处的数字等于 $(-i + 2k + 1, i - 1)$ 和 $(-i + 2k - 1, i - 1)$ 两处数字之和。\n\n普通三角形由顶点 $(x_A, y_A)$、$(x_B, y_B)$、$(x_C, y_C)$ 定义。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3gacksfw.png)\n\nGrace 定义帕斯卡三角形与普通三角形的**交值**为：普通三角形内部或边界上所有帕斯卡三角形数字的总和。请你编写程序计算这一交值。", "inputFormat": "第一行输入整数 $t$（$1 \\le t \\le 5$）——测试用例数量。  \n接下来 $t$ 行，每行包含 6 个整数 $x_A, y_A, x_B, y_B, x_C, y_C$（$-10^6 \\le x_A, y_A, x_B, y_B, x_C, y_C \\le 10^6$），保证三点不共线。\n", "outputFormat": "对每个测试用例，输出交值对 $10^9+7$ 取模的结果。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12857", "type": "P", "difficulty": 7, "samples": [["2\n10.0 0.5 0.5 0.5 0.5\n8.0 0.1 0.9 0.9 0.1", "6.5990202123649855\n7.540407031059442"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "Special Judge", "概率论", "ICPC", "NERC/NEERC"], "title": "[NERC 2020 Online] Hit the Hay", "background": "", "description": "Some consider putting a baby to sleep to be an art, but this problem will show it is all just maths.\n\nConsider a night during which a parent is trying to put a baby to sleep. An alarm clock will sound at the end of the night, and the parent is not allowed to change the alarm time, so the length of the night is fixed at $k$ hours from now.\n\nThe baby can be in one of the three states: state 0 means the baby is awake, state 1 means the baby is in light sleep, and state 2 means the baby is in deep sleep. The baby starts in state 0, and the change in a state happens continuously rather than discretely. You are given three numbers $p_0$, $p_1$, and $p_2$. Whenever the baby is in state $i$, the probability that no state change will happen in the next $x$ hours is $p_i^x$, where $x$ is a positive real number. In other words, the time before the next state change is picked from the $\\emph{exponential distribution}$ with the cumulative distribution function of $1-p_i^x$.\n\nWhenever a state change does happen, if the baby was in state 0, it will always switch to state 1; if the baby was in state 2, it will also always switch to state 1; if the baby was in state 1, it will switch to state 0 with the probability $q_0$ and to state 2 with the probability $1-q_0$.\n\nThe parent decides when to go to sleep themselves. However, if the baby is in state 0, it will cry and wake the parent up, so the parent can only be asleep if the baby is in state 1 or 2. The parent can choose to still stay awake even if the baby is in one of those states. If they do stay awake, they can:\n- see which of the three states the baby is in;\n- prevent the baby from waking up: if the baby decides to switch from state 1 to state 0 according to the above rules, and the parent is not asleep, then the baby will be comforted and will stay in state~1 instead.\n\nThe parent can decide to go to sleep arbitrarily, for example using the current state of the baby or the current time to make this decision. However, if they do go to sleep, then they will be asleep until either the baby wakes up (goes to state 0), or the alarm clock sounds at the end of the $k$ hours. If they get woken up by the baby waking up, then they can later decide to go to sleep again arbitrarily.\n\nWhat is the maximum expected number of hours of sleep the parent can get if they decide to go to sleep in the optimal fashion?", "inputFormat": "The first line of the input contains an integer $t$ ($1 \\le t \\le 1000$) --- the number of test cases.\n\nThe next $t$ lines describe test cases, each contains five floating-point numbers with exactly $\\emph{one}$ digit after the decimal point, in the following order: $k$, $p_0$, $p_1$, $p_2$, $q_0$ ($0.1 \\le k \\le 10$; $0.1 \\le p_0, p_1, p_2, q_0 \\le 0.9$).", "outputFormat": "Output $t$ lines with a floating-point number on each line --- the maximum expected amount of sleep for each test case. Your outputs will be considered correct if they are within $10^{-9}$ absolute difference from the answers.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2020 Online] Hit the Hay", "background": "", "description": "Some consider putting a baby to sleep to be an art, but this problem will show it is all just maths.\n\nConsider a night during which a parent is trying to put a baby to sleep. An alarm clock will sound at the end of the night, and the parent is not allowed to change the alarm time, so the length of the night is fixed at $k$ hours from now.\n\nThe baby can be in one of the three states: state 0 means the baby is awake, state 1 means the baby is in light sleep, and state 2 means the baby is in deep sleep. The baby starts in state 0, and the change in a state happens continuously rather than discretely. You are given three numbers $p_0$, $p_1$, and $p_2$. Whenever the baby is in state $i$, the probability that no state change will happen in the next $x$ hours is $p_i^x$, where $x$ is a positive real number. In other words, the time before the next state change is picked from the $\\emph{exponential distribution}$ with the cumulative distribution function of $1-p_i^x$.\n\nWhenever a state change does happen, if the baby was in state 0, it will always switch to state 1; if the baby was in state 2, it will also always switch to state 1; if the baby was in state 1, it will switch to state 0 with the probability $q_0$ and to state 2 with the probability $1-q_0$.\n\nThe parent decides when to go to sleep themselves. However, if the baby is in state 0, it will cry and wake the parent up, so the parent can only be asleep if the baby is in state 1 or 2. The parent can choose to still stay awake even if the baby is in one of those states. If they do stay awake, they can:\n- see which of the three states the baby is in;\n- prevent the baby from waking up: if the baby decides to switch from state 1 to state 0 according to the above rules, and the parent is not asleep, then the baby will be comforted and will stay in state~1 instead.\n\nThe parent can decide to go to sleep arbitrarily, for example using the current state of the baby or the current time to make this decision. However, if they do go to sleep, then they will be asleep until either the baby wakes up (goes to state 0), or the alarm clock sounds at the end of the $k$ hours. If they get woken up by the baby waking up, then they can later decide to go to sleep again arbitrarily.\n\nWhat is the maximum expected number of hours of sleep the parent can get if they decide to go to sleep in the optimal fashion?", "inputFormat": "The first line of the input contains an integer $t$ ($1 \\le t \\le 1000$) --- the number of test cases.\n\nThe next $t$ lines describe test cases, each contains five floating-point numbers with exactly $\\emph{one}$ digit after the decimal point, in the following order: $k$, $p_0$, $p_1$, $p_2$, $q_0$ ($0.1 \\le k \\le 10$; $0.1 \\le p_0, p_1, p_2, q_0 \\le 0.9$).", "outputFormat": "Output $t$ lines with a floating-point number on each line --- the maximum expected amount of sleep for each test case. Your outputs will be considered correct if they are within $10^{-9}$ absolute difference from the answers.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2020 Online] Hit the Hay", "background": "", "description": "有人认为哄婴儿入睡是一门艺术，但这个问题将证明它其实只是数学。\n\n考虑一个夜晚，父母正试图哄婴儿入睡。闹钟会在夜晚结束时响起，父母不能更改闹钟时间，因此夜晚的时长固定为从现在开始的 $k$ 小时。\n\n婴儿可能处于以下三种状态之一：\n- 状态 0 表示婴儿醒着；\n- 状态 1 表示婴儿处于浅睡眠；\n- 状态 2 表示婴儿处于深睡眠。\n\n婴儿初始状态为 0，状态变化是连续而非离散的。给定三个概率值 $p_0$、$p_1$ 和 $p_2$。当婴儿处于状态 $i$ 时，接下来的 $x$ 小时内不发生状态变化的概率为 $p_i^x$（$x$ 为正实数）。换句话说，下一次状态变化的时间服从**指数分布**，其累积分布函数为 $1 - p_i^x$。\n\n当状态变化发生时：\n- 如果婴儿当前处于状态 0，则必定转移到状态 1；\n- 如果处于状态 2，也必定转移到状态 1；\n- 如果处于状态 1，则以概率 $q_0$ 转移到状态 0，以概率 $1 - q_0$ 转移到状态 2。\n\n父母可以自行决定何时入睡，但只有婴儿处于状态 1 或 2 时才能入睡（状态 0 时婴儿会哭闹吵醒父母）。即使婴儿处于可入睡状态，父母也可以选择保持清醒。若保持清醒，父母可以：\n1. 观察婴儿当前状态；\n2. 阻止婴儿醒来：如果婴儿根据规则本应从状态 1 转移到状态 0，而父母未入睡，则婴儿会被安抚并保持在状态 1。\n\n父母可以根据婴儿当前状态或时间等因素自由决定何时入睡。一旦入睡，将持续睡眠直到：\n- 婴儿醒来（进入状态 0），或\n- 闹钟在 $k$ 小时结束时响起。\n\n若被婴儿吵醒，父母可以再次选择入睡时机。\n\n**问题**：在最优策略下，父母能获得的最大期望睡眠时长是多少？", "inputFormat": "第一行输入整数 $t$（$1 \\le t \\le 1000$）——测试用例数量。  \n接下来 $t$ 行，每行包含 5 个**精确到小数点后一位**的浮点数，依次为：$k$、$p_0$、$p_1$、$p_2$、$q_0$（$0.1 \\le k \\le 10$；$0.1 \\le p_0, p_1, p_2, q_0 \\le 0.9$）。\n", "outputFormat": "输出 $t$ 行，每行一个浮点数表示对应测试用例的最大期望睡眠时长。答案与标准解的绝对误差不超过 $10^{-9}$ 即视为正确。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12858", "type": "P", "difficulty": 0, "samples": [["2 4\n\nmove -1 1\n\nmove -1 1\n\nmove -1 1\n\nmove 0 1\n\nmove -1 0\n\nwin\n\nmove 0 -1\n\nmove -1 0\n\nlose", "\n0 1\n\n0 1\n\n0 1\n\n-1 0\n\n-1 1\n\n1 0\n\n1 0\n\n1 -1\n\n1 0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "交互题", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2020 Online] Interactive Knockout", "background": "", "description": "This is an interactive problem. You are to defeat a randomly moving jury in a series of independent rounds of the game.\n\nThe game is played on a hexagonal field with axial coordinates. The field is bounded by a hexagon with vertices in cells $(n, 0)$, $(0, n)$, $(-n, n)$, $(-n, 0)$, $(0, -n)$, and $(n, -n)$. In all test cases, except for the sample test case in this statement, which is not present in the real test set, $n=20$.\n\nThere are two players --- you and the jury. You start in the cell $(-n/2, 0)$ and the jury starts in the cell $(n/2, 0)$. Players take turns, you move first.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qokd7hdg.png)\n\nА field for $n=4$ (the blue cell is your starting cell and the red cell is the starting cell for the jury).\n\nAt each turn, the player moves to any cell adjacent by side, which does not contain the opponent and has not been destroyed. After that, the previously occupied cell is destroyed and is not available to players on the following turns anymore.\nThe player who cannot move to any adjacent cell loses the game.\n\nThe jury did not come up with any smart algorithm to play this game, so they've decided to move equiprobably randomly to any valid adjacent cell on each turn.\n\nYou need to show your complete dominance --- win all of $t$ independent rounds of the game.\n\n### Interactive Protocol\n\nIn the first line, you are given integers $t$ and $n$ --- the number of independent rounds of the game you need to win, and the field size ($1 \\le t \\le 50$; $n = 20$ except for the sample test case, which is not present in the real test set). \n\nEach turn, you need to output a line with the direction of your move --- two integers $dx, dy$, where $(dx, dy) \\in \\{ (1, 0)$, $(0, 1)$, $(-1, 1)$, $(-1, 0)$, $(0, -1)$, $(1, -1) \\}$. After that, read one line in the following format:\n\n- token $\\tt{move}$ and two integers $dx, dy$ --- direction $(dx, dy)$ where the jury moved. It is guaranteed to be chosen equiprobably randomly;\n- token $\\tt{win}$, if the jury doesn't have any valid cells to move to. In this case, you should immediately start playing the next game, or finish your program with the exit code 0 if all $t$ rounds were played.\n- token $\\tt{lose}$, if you made an invalid move. In this case, you should finish your program with the exit code 0 to get an adequate verdict of Wrong answer.\n\nIt is guaranteed that there are at most 100 tests (with at most $50$ game rounds in each test) for a total of at most 5000 game rounds that you shall win. The jury uses a fixed random seed for each test. ", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "Note that the interaction in the sample test case results in the Wrong answer verdict, as only 1 round out of 2 is won. The two rounds played are shown below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qwap731n.png)\n\nThe starting player wins (on the left) and loses by making an invalid move (on the right).", "locale": "en", "translations": {"en": {"title": "[NERC 2020 Online] Interactive Knockout", "background": "", "description": "This is an interactive problem. You are to defeat a randomly moving jury in a series of independent rounds of the game.\n\nThe game is played on a hexagonal field with axial coordinates. The field is bounded by a hexagon with vertices in cells $(n, 0)$, $(0, n)$, $(-n, n)$, $(-n, 0)$, $(0, -n)$, and $(n, -n)$. In all test cases, except for the sample test case in this statement, which is not present in the real test set, $n=20$.\n\nThere are two players --- you and the jury. You start in the cell $(-n/2, 0)$ and the jury starts in the cell $(n/2, 0)$. Players take turns, you move first.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qokd7hdg.png)\n\nА field for $n=4$ (the blue cell is your starting cell and the red cell is the starting cell for the jury).\n\nAt each turn, the player moves to any cell adjacent by side, which does not contain the opponent and has not been destroyed. After that, the previously occupied cell is destroyed and is not available to players on the following turns anymore.\nThe player who cannot move to any adjacent cell loses the game.\n\nThe jury did not come up with any smart algorithm to play this game, so they've decided to move equiprobably randomly to any valid adjacent cell on each turn.\n\nYou need to show your complete dominance --- win all of $t$ independent rounds of the game.\n\n### Interactive Protocol\n\nIn the first line, you are given integers $t$ and $n$ --- the number of independent rounds of the game you need to win, and the field size ($1 \\le t \\le 50$; $n = 20$ except for the sample test case, which is not present in the real test set). \n\nEach turn, you need to output a line with the direction of your move --- two integers $dx, dy$, where $(dx, dy) \\in \\{ (1, 0)$, $(0, 1)$, $(-1, 1)$, $(-1, 0)$, $(0, -1)$, $(1, -1) \\}$. After that, read one line in the following format:\n\n- token $\\tt{move}$ and two integers $dx, dy$ --- direction $(dx, dy)$ where the jury moved. It is guaranteed to be chosen equiprobably randomly;\n- token $\\tt{win}$, if the jury doesn't have any valid cells to move to. In this case, you should immediately start playing the next game, or finish your program with the exit code 0 if all $t$ rounds were played.\n- token $\\tt{lose}$, if you made an invalid move. In this case, you should finish your program with the exit code 0 to get an adequate verdict of Wrong answer.\n\nIt is guaranteed that there are at most 100 tests (with at most $50$ game rounds in each test) for a total of at most 5000 game rounds that you shall win. The jury uses a fixed random seed for each test. ", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "Note that the interaction in the sample test case results in the Wrong answer verdict, as only 1 round out of 2 is won. The two rounds played are shown below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qwap731n.png)\n\nThe starting player wins (on the left) and loses by making an invalid move (on the right).", "locale": "en"}, "zh-CN": {"title": "[NERC 2020 Online] Interactive Knockout", "background": "", "description": "这是一道交互题。你需要在多轮独立游戏中击败随机移动的裁判方。\n\n游戏在六边形网格场地上进行，采用轴向坐标系。场地边界为顶点位于 $(n, 0)$、$(0, n)$、$(-n, n)$、$(-n, 0)$、$(0, -n)$ 和 $(n, -n)$ 的正六边形。除样例测试用例外（实际测试集中不包含该样例），所有测试用例中 $n=20$。\n\n两名玩家分别为**你**和**裁判**。你的起始位置为 $(-n/2, 0)$，裁判起始位置为 $(n/2, 0)$。玩家轮流移动，你先行。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qokd7hdg.png)\n\n图示为 $n=4$ 时的场地（蓝色格子为你方起始位置，红色格子为裁判方起始位置）。\n\n每轮行动中，玩家可移动到任意未被摧毁且不包含对手的**相邻边格子**。移动后，原位置将被摧毁且后续回合不可再使用。无法移动的玩家判负。\n\n裁判未设计智能策略，其每次移动会**完全随机**选择任意合法相邻格子。\n\n你的任务是展现绝对统治力——在 $t$ 轮独立游戏中全部获胜。\n\n### 交互协议\n\n首行输入整数 $t$ 和 $n$——需获胜的独立游戏轮数和场地大小（$1 \\le t \\le 50$；实际测试中 $n=20$，样例除外）。\n\n你的每回合需输出移动方向——两个整数 $dx, dy$，其中 $(dx, dy) \\in \\{ (1, 0)$, $(0, 1)$, $(-1, 1)$, $(-1, 0)$, $(0, -1)$, $(1, -1) \\}$。随后读取一行响应：\n- 若为 `move dx dy`：表示裁判随机移动的方向（保证等概率随机）；\n- 若为 `win`：表示裁判无合法移动位置。此时应立即开始下一轮游戏，或当全部 $t$ 轮结束时正常退出程序；\n- 若为 `lose`：表示你的移动非法。此时应立即退出程序以获取 Wrong answer 判题结果。\n\n保证所有测试用例总轮数不超过 5000 轮（每组测试最多 100 个用例，每用例最多 50 轮）。裁判方对每个测试用例使用固定随机种子。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "注意样例交互过程会导致 Wrong answer，因仅 2 轮中获胜 1 轮。两轮游戏过程如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qwap731n.png)\n\n左侧为先手获胜回合，右侧因非法移动判负。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12859", "type": "P", "difficulty": 0, "samples": [["6 5\n3 9 11 12 16 18\n5 1 6 2 5 7", "25.83095189484530047"], ["6 4\n3 9 11 12 16 18\n5 1 6 2 5 7", "-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2020 Online] Jumping Cat", "background": "", "description": "A city skyline is specified by $n$ integers $d_1, d_2, \\ldots, d_n$ ($0 < d_1 < d_2 < \\ldots < d_n$) and $n$ integers $h_1, h_2, \\ldots, h_n$.\n\nA skyline surface consists of $n$ horizontal line segments, the $i$-th segment connects points $(d_{i-1}, h_i)$ and $(d_i, h_i)$, where $d_0 = 0$. Each segment is a roof of a building.\n\nA cat (which is so small that can be considered a point) wants to get from the leftmost point of the skyline, $(0, h_1)$, to the rightmost point of the skyline, $(d_n, h_n)$.\nTo achieve that, the cat performs a sequence of moves. Each move is one of two types:\n\n- $\\emph{Walk}$ from point $(x_1, y_1)$ to point $(x_2, y_2)$. Both points must belong to the same surface segment, i.e. there exists $i$ such that $y_1 = y_2 = h_i$ and $d_{i-1} \\le x_1, x_2 \\le d_i$. A trajectory of a walk is a straight line segment. \n- $\\emph{Jump}$ from point $(x_1, y_1)$ to point $(x_2, y_2)$. Points $(x_1, y_1)$ and $(x_2, y_2)$ must belong to different surface segments. A trajectory of a jump is a straight line segment and must satisfy the following constraints:\n  - the distance between $(x_1, y_1)$ and $(x_2, y_2)$ is at most $L$;\n  - the line segment between $(x_1, y_1)$ and $(x_2, y_2)$ does not intersect any of the buildings, i.e. thereis no point $(x, y)$ belonging to the segment and integer $i$ such that $d_{i-1} < x < d_i$ and $y < h_i$.\n\nThe length of the cat's trajectory is the sum of lengths of all the moves in it. Find the shortest trajectory for the cat to get from $(0, h_1)$ to $(d_n, h_n)$, or determine that the goal is unreachable.", "inputFormat": "The first line contains two integers $n$ and $L$ ($1 \\le n \\le 50$; $1 \\le L \\le 100$).\n\nThe second line contains $n$ integers $d_1, d_2, \\ldots, d_n$ ($0 < d_1 < d_2 < \\ldots < d_n \\le 1000$).\n\nThe third line contains $n$ integers $h_1, h_2, \\ldots, h_n$ ($1 \\le h_i \\le 100$; $h_i \\ne h_{i+1}$).", "outputFormat": "Output a single floating-point number --- the length of the shortest trajectory from point $(0, h_1)$ to point $(d_n, h_n)$, or $-1$ if no valid trajectory exists.\n\nYour answer will be considered correct if its absolute or relative error doesn't exceed $10^{-9}$.", "hint": "The picture for the first sample is shown below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5syjye8q.png)", "locale": "en", "translations": {"en": {"title": "[NERC 2020 Online] Jumping Cat", "background": "", "description": "A city skyline is specified by $n$ integers $d_1, d_2, \\ldots, d_n$ ($0 < d_1 < d_2 < \\ldots < d_n$) and $n$ integers $h_1, h_2, \\ldots, h_n$.\n\nA skyline surface consists of $n$ horizontal line segments, the $i$-th segment connects points $(d_{i-1}, h_i)$ and $(d_i, h_i)$, where $d_0 = 0$. Each segment is a roof of a building.\n\nA cat (which is so small that can be considered a point) wants to get from the leftmost point of the skyline, $(0, h_1)$, to the rightmost point of the skyline, $(d_n, h_n)$.\nTo achieve that, the cat performs a sequence of moves. Each move is one of two types:\n\n- $\\emph{Walk}$ from point $(x_1, y_1)$ to point $(x_2, y_2)$. Both points must belong to the same surface segment, i.e. there exists $i$ such that $y_1 = y_2 = h_i$ and $d_{i-1} \\le x_1, x_2 \\le d_i$. A trajectory of a walk is a straight line segment. \n- $\\emph{Jump}$ from point $(x_1, y_1)$ to point $(x_2, y_2)$. Points $(x_1, y_1)$ and $(x_2, y_2)$ must belong to different surface segments. A trajectory of a jump is a straight line segment and must satisfy the following constraints:\n  - the distance between $(x_1, y_1)$ and $(x_2, y_2)$ is at most $L$;\n  - the line segment between $(x_1, y_1)$ and $(x_2, y_2)$ does not intersect any of the buildings, i.e. thereis no point $(x, y)$ belonging to the segment and integer $i$ such that $d_{i-1} < x < d_i$ and $y < h_i$.\n\nThe length of the cat's trajectory is the sum of lengths of all the moves in it. Find the shortest trajectory for the cat to get from $(0, h_1)$ to $(d_n, h_n)$, or determine that the goal is unreachable.", "inputFormat": "The first line contains two integers $n$ and $L$ ($1 \\le n \\le 50$; $1 \\le L \\le 100$).\n\nThe second line contains $n$ integers $d_1, d_2, \\ldots, d_n$ ($0 < d_1 < d_2 < \\ldots < d_n \\le 1000$).\n\nThe third line contains $n$ integers $h_1, h_2, \\ldots, h_n$ ($1 \\le h_i \\le 100$; $h_i \\ne h_{i+1}$).", "outputFormat": "Output a single floating-point number --- the length of the shortest trajectory from point $(0, h_1)$ to point $(d_n, h_n)$, or $-1$ if no valid trajectory exists.\n\nYour answer will be considered correct if its absolute or relative error doesn't exceed $10^{-9}$.", "hint": "The picture for the first sample is shown below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5syjye8q.png)", "locale": "en"}, "zh-CN": {"title": "[NERC 2020 Online] Jumping Cat", "background": "", "description": "城市天际线由 $n$ 个整数 $d_1, d_2, \\ldots, d_n$（$0 < d_1 < d_2 < \\ldots < d_n$）和 $n$ 个整数 $h_1, h_2, \\ldots, h_n$ 定义。\n\n天际线表面由 $n$ 条水平线段组成，第 $i$ 条线段连接点 $(d_{i-1}, h_i)$ 和 $(d_i, h_i)$（其中 $d_0 = 0$）。每条线段代表一栋建筑的屋顶。\n\n一只猫（体积极小可视为质点）需要从天际线最左端点 $(0, h_1)$ 移动到最右端点 $(d_n, h_n)$。为此，猫会执行一系列移动操作，每次操作有两种类型：\n\n1. **行走**：从点 $(x_1, y_1)$ 移动到点 $(x_2, y_2)$。两点必须位于同一条表面线段上，即存在 $i$ 使得 $y_1 = y_2 = h_i$ 且 $d_{i-1} \\le x_1, x_2 \\le d_i$。行走轨迹为直线段。\n2. **跳跃**：从点 $(x_1, y_1)$ 移动到点 $(x_2, y_2)$。两点必须位于不同表面线段上，且需满足：\n   - 两点间距离不超过 $L$；\n   - 连接两点的直线段不与任何建筑相交，即不存在线段上的点 $(x, y)$ 和整数 $i$ 使得 $d_{i-1} < x < d_i$ 且 $y < h_i$。\n\n猫的轨迹长度为所有移动操作的长度之和。求从 $(0, h_1)$ 到 $(d_n, h_n)$ 的最短轨迹长度，若无法到达则输出 $-1$。", "inputFormat": "第一行包含两个整数 $n$ 和 $L$（$1 \\le n \\le 50$；$1 \\le L \\le 100$）。  \n第二行包含 $n$ 个整数 $d_1, d_2, \\ldots, d_n$（$0 < d_1 < d_2 < \\ldots < d_n \\le 1000$）。  \n第三行包含 $n$ 个整数 $h_1, h_2, \\ldots, h_n$（$1 \\le h_i \\le 100$；$h_i \\ne h_{i+1}$）。\n", "outputFormat": "输出一个浮点数表示最短轨迹长度，若不可达则输出 $-1$。答案的绝对或相对误差不超过 $10^{-9}$ 即视为正确。\n", "hint": "第一组样例的图示如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5syjye8q.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12860", "type": "P", "difficulty": 1, "samples": [["4\n100 9876543210\n200 00112233445566778899\n160 012345678924568\n150 000000123456789", "3"], ["5\n100 0123456789\n120 0022446688\n200 00224466883456789\n10 0\n10 1", "0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2020", "Special Judge", "O2优化", "排序", "ICPC", "NERC/NEERC", "STL"], "title": "[NERC 2020 Online] Kate' s 2021 Celebration", "background": "", "description": "Kate did not have a good year 2020 and she is glad that it is coming to an end. She is planning to celebrate New Year 2021 on a grand scale. \n\nKate has decided to buy four balloons with digits $\\texttt{2} \\texttt{0} \\texttt{2} \\texttt{1}$ painted on them for her 2021 celebration. She went to a store's web site and has found that balloons with digits are sold in packs containing different assortments of balloons of various sizes, colors, and with different digits painted on them. Kate does not care about their size, color, or other attributes. She only cares about digits written on those balloons. Fortunately, the store has all the information about different packs of balloons that are available. Kate has managed to retrieve it through the store's REST API and extracted just the information she needs --- the price and the digits that are written on balloons in each pack. \n\nPlease, help Kate with the final task of figuring out what is the cheapest pack of balloons she can buy that would get her the four digits she needs for her 2021 celebration.", "inputFormat": "The first line of the input file contains an integer $n$ ($1 \\le n \\le 1000$) --- the number of packs of balloons available in the store.  \n\nThe next $n$ lines contain descriptions of packs, one line per pack. Each pack is described by an integer $p$ ($1 \\le p \\le 10^5$) --- the price of the pack in roubles, followed by a string of at least one and at most $100$ digits (each digit is from $\\texttt{0}$to $\\texttt{9}$) --- the digits on the balloons in the pack.", "outputFormat": "Output a single integer --- the number of the cheapest pack that Kate can buy to get the digits for her $2021$ celebration. Packs of balloons are numbered starting from $1$ in the order they are given in the input. If there are multiple packs with the same price, output any one of them.\n\nOutput $0$ if there is no pack in the store that Kate can buy for her 2021 celebration.", "hint": "In the first example, 2nd and 3rd packs of balloons contain digits $\\texttt{2} \\texttt{0} \\texttt{2} \\texttt{1}$ and the 3rd one is the cheapest.", "locale": "en", "translations": {"en": {"title": "[NERC 2020 Online] Kate' s 2021 Celebration", "background": "", "description": "Kate did not have a good year 2020 and she is glad that it is coming to an end. She is planning to celebrate New Year 2021 on a grand scale. \n\nKate has decided to buy four balloons with digits $\\texttt{2} \\texttt{0} \\texttt{2} \\texttt{1}$ painted on them for her 2021 celebration. She went to a store's web site and has found that balloons with digits are sold in packs containing different assortments of balloons of various sizes, colors, and with different digits painted on them. Kate does not care about their size, color, or other attributes. She only cares about digits written on those balloons. Fortunately, the store has all the information about different packs of balloons that are available. Kate has managed to retrieve it through the store's REST API and extracted just the information she needs --- the price and the digits that are written on balloons in each pack. \n\nPlease, help Kate with the final task of figuring out what is the cheapest pack of balloons she can buy that would get her the four digits she needs for her 2021 celebration.", "inputFormat": "The first line of the input file contains an integer $n$ ($1 \\le n \\le 1000$) --- the number of packs of balloons available in the store.  \n\nThe next $n$ lines contain descriptions of packs, one line per pack. Each pack is described by an integer $p$ ($1 \\le p \\le 10^5$) --- the price of the pack in roubles, followed by a string of at least one and at most $100$ digits (each digit is from $\\texttt{0}$to $\\texttt{9}$) --- the digits on the balloons in the pack.", "outputFormat": "Output a single integer --- the number of the cheapest pack that Kate can buy to get the digits for her $2021$ celebration. Packs of balloons are numbered starting from $1$ in the order they are given in the input. If there are multiple packs with the same price, output any one of them.\n\nOutput $0$ if there is no pack in the store that Kate can buy for her 2021 celebration.", "hint": "In the first example, 2nd and 3rd packs of balloons contain digits $\\texttt{2} \\texttt{0} \\texttt{2} \\texttt{1}$ and the 3rd one is the cheapest.", "locale": "en"}, "zh-CN": {"title": "[NERC 2020 Online] Kate' s 2021 Celebration", "background": "", "description": "Kate 的 2020 年并不顺利，因此她很高兴这一年即将结束。她计划以盛大的方式庆祝 2021 新年。\n\nKate 决定为她的 2021 庆祝购买四个气球，上面分别印有数字 $\\texttt{2}$、$\\texttt{0}$、$\\texttt{2}$、$\\texttt{1}$。她访问了一家商店的网站，发现印有数字的气球以不同的组合包形式出售，每个包包含不同大小、颜色和数字的气球。Kate 并不关心气球的大小、颜色或其他属性，她只关心气球上的数字。幸运的是，商店提供了所有可用的气球包信息。Kate 通过商店的 REST API 获取了这些信息，并提取了她所需的部分——每个包的价格以及气球上的数字。\n\n请帮助 Kate 完成最后的任务：找出她可以购买的最便宜的气球包，以获得她庆祝 2021 所需的四个数字。", "inputFormat": "输入文件的第一行包含一个整数 $n$（$1 \\le n \\le 1000$）——商店中可用的气球包数量。\n\n接下来的 $n$ 行每行描述一个气球包，每行包含一个整数 $p$（$1 \\le p \\le 10^5$）——该包的价格（以卢布为单位），以及一个由至少一个、最多 $100$ 个数字（每个数字为 $\\texttt{0}$ 到 $\\texttt{9}$）组成的字符串——该包中气球上的数字。", "outputFormat": "输出一个整数——Kate 可以购买的最便宜的气球包的编号，以获得她的 2021 庆祝所需的数字。气球包的编号从 $1$ 开始，按输入中的顺序排列。如果有多个价格相同的气球包，输出其中任意一个即可。\n\n如果商店中没有适合 Kate 的 2021 庆祝的气球包，则输出 $0$。\n", "hint": "在第一个样例中，第 2 个和第 3 个气球包包含数字 $\\texttt{2}$、$\\texttt{0}$、$\\texttt{2}$、$\\texttt{1}$，而第 3 个包是最便宜的。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12861", "type": "P", "difficulty": 5, "samples": [["7\n2 3 4\n4 0 2\n5 6 8\n0 0 1\n0 7 5\n0 0 9\n0 0 6\n5\n2 7\n0 10\n2 8\n4 4\n3 3", "7\n1\n7\n3\n3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "树状数组", "树论", "扫描线", "ICPC", "Ad-hoc", "离线处理", "NERC/NEERC"], "title": "[NERC 2020 Online] Lookup Performance", "background": "", "description": "A $\\emph{binary search tree}$ is a rooted binary tree whose nodes store keys so that each node's key is greater than all the keys in the node's left subtree and less than those in its right subtree.\n\nA binary search tree can be used to maintain sorted sets and allows to perform different types of queries on the set. A query that we are considering in this problem is finding the number of values in the range $[L, R]$ within the set. \n\nLet $S$ be the set of all keys in the binary search tree. You are given two values $L$ and $R$. The query is to find the number of such $x \\in S$ so that $L \\le x \\le R$. The following recursive function computes this value when called with the parameters $\\verb|lookup(root, L, R)|$, where $\\verb|root|$ is the root of the binary search tree.\n\n```\nfunction lookup(v, L, R):\n  if v == null:\n    return 0\n  if L <= v.min and v.max <= R:\n    return v.count\n  if v.max < L or R < v.min:\n    return 0\n  res = 0\n  if L <= v.key and v.key <= R:\n    res += 1\n  res += lookup(v.left, L, R)\n  res += lookup(v.right, L, R)\n  return res\n```\n\nValues $\\verb|v.left|, \\verb|v.right|, \\verb|v.min|, \\verb|v.max|, \\verb|v.key|$, and  $\\verb|v.count|$ are the fields of the nodes of the binary search tree. \n\n- $\\verb|v.left|$ and $\\verb|v.right|$ are the left and the right children of node $v$, respectively. \n- $\\verb|v.min|$ and $\\verb|v.max|$ are the minimum and the maximum keys in the subtree rooted at node $v$. \n- $\\verb|v.key|$ is the key of node $v$. \n- $\\verb|v.count|$ is the number of nodes in the subtree rooted at node $v$.\n\nYou are given a binary search tree with integer keys. You are also given queries, each query consisting of two integers $L$ and $R$. Find the number of calls of the $\\verb|lookup|$ function that are made when $\\verb|lookup(root, L, R)|$ is called, including the initial $\\verb|lookup(root, L, R)|$ call itself.", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 200\\,000$) --- the number of nodes in the binary search tree.\n\nThe next $n$ lines describe the nodes of the tree. The $i$-th of these lines contains three integers $l_i$, $r_i$, and $k_i$ denoting the left child, the right child and the key of the $i$-th node. If the node does not have the left or/and the right child, the corresponding value is 0 ($l_i = 0$ or $i < l_i \\le n$; $r_i = 0$ or $i < r_i \\le n$; $-10^9 \\le k_i \\le 10^9$). The root of the tree is at node 1 and it is guaranteed to be a well-formed binary search tree.\n\nNote that the values $\\verb|v.min|, \\verb|v.max|$ and $\\verb|v.count|$ are not given in the input explicitly, since they can be deduced from $l_i$, $r_i$ and $k_i$.\n\nThe next line contains an integer $q$ ($1 \\le q \\le 200\\,000$) --- the number of the queries.\n\nEach of the next $q$ lines contains two integers $L$ and $R$ ($-10^9 \\le L \\le R \\le 10^9$) --- the parameters given to the $\\verb|lookup|$ function.", "outputFormat": "Output $q$ lines, the $i$-th line containing a single integer --- the number of calls of the $\\verb|lookup|$ function that are made for the $i$-th query.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2020 Online] Lookup Performance", "background": "", "description": "A $\\emph{binary search tree}$ is a rooted binary tree whose nodes store keys so that each node's key is greater than all the keys in the node's left subtree and less than those in its right subtree.\n\nA binary search tree can be used to maintain sorted sets and allows to perform different types of queries on the set. A query that we are considering in this problem is finding the number of values in the range $[L, R]$ within the set. \n\nLet $S$ be the set of all keys in the binary search tree. You are given two values $L$ and $R$. The query is to find the number of such $x \\in S$ so that $L \\le x \\le R$. The following recursive function computes this value when called with the parameters $\\verb|lookup(root, L, R)|$, where $\\verb|root|$ is the root of the binary search tree.\n\n```\nfunction lookup(v, L, R):\n  if v == null:\n    return 0\n  if L <= v.min and v.max <= R:\n    return v.count\n  if v.max < L or R < v.min:\n    return 0\n  res = 0\n  if L <= v.key and v.key <= R:\n    res += 1\n  res += lookup(v.left, L, R)\n  res += lookup(v.right, L, R)\n  return res\n```\n\nValues $\\verb|v.left|, \\verb|v.right|, \\verb|v.min|, \\verb|v.max|, \\verb|v.key|$, and  $\\verb|v.count|$ are the fields of the nodes of the binary search tree. \n\n- $\\verb|v.left|$ and $\\verb|v.right|$ are the left and the right children of node $v$, respectively. \n- $\\verb|v.min|$ and $\\verb|v.max|$ are the minimum and the maximum keys in the subtree rooted at node $v$. \n- $\\verb|v.key|$ is the key of node $v$. \n- $\\verb|v.count|$ is the number of nodes in the subtree rooted at node $v$.\n\nYou are given a binary search tree with integer keys. You are also given queries, each query consisting of two integers $L$ and $R$. Find the number of calls of the $\\verb|lookup|$ function that are made when $\\verb|lookup(root, L, R)|$ is called, including the initial $\\verb|lookup(root, L, R)|$ call itself.", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 200\\,000$) --- the number of nodes in the binary search tree.\n\nThe next $n$ lines describe the nodes of the tree. The $i$-th of these lines contains three integers $l_i$, $r_i$, and $k_i$ denoting the left child, the right child and the key of the $i$-th node. If the node does not have the left or/and the right child, the corresponding value is 0 ($l_i = 0$ or $i < l_i \\le n$; $r_i = 0$ or $i < r_i \\le n$; $-10^9 \\le k_i \\le 10^9$). The root of the tree is at node 1 and it is guaranteed to be a well-formed binary search tree.\n\nNote that the values $\\verb|v.min|, \\verb|v.max|$ and $\\verb|v.count|$ are not given in the input explicitly, since they can be deduced from $l_i$, $r_i$ and $k_i$.\n\nThe next line contains an integer $q$ ($1 \\le q \\le 200\\,000$) --- the number of the queries.\n\nEach of the next $q$ lines contains two integers $L$ and $R$ ($-10^9 \\le L \\le R \\le 10^9$) --- the parameters given to the $\\verb|lookup|$ function.", "outputFormat": "Output $q$ lines, the $i$-th line containing a single integer --- the number of calls of the $\\verb|lookup|$ function that are made for the $i$-th query.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2020 Online] Lookup Performance", "background": "", "description": "**二叉搜索树**（binary search tree）是一种带根的二叉树，其节点存储的键值满足：每个节点的键值大于其左子树中所有节点的键值，并小于其右子树中所有节点的键值。\n\n二叉搜索树可用于维护有序集合，并支持对集合执行多种查询操作。本题中我们考虑的查询是：在集合中查找位于区间 $[L, R]$ 内的值的数量。\n\n设 $S$ 为二叉搜索树中所有键值的集合。给定两个值 $L$ 和 $R$，查询的目标是找出满足 $L \\le x \\le R$ 的 $x \\in S$ 的数量。以下递归函数在调用 `lookup(root, L, R)` 时会计算该值，其中 `root` 是二叉搜索树的根节点。\n\n```\nfunction lookup(v, L, R):\n  if v == null:\n    return 0\n  if L <= v.min and v.max <= R:\n    return v.count\n  if v.max < L or R < v.min:\n    return 0\n  res = 0\n  if L <= v.key and v.key <= R:\n    res += 1\n  res += lookup(v.left, L, R)\n  res += lookup(v.right, L, R)\n  return res\n```\n\n变量 `v.left`、`v.right`、`v.min`、`v.max`、`v.key` 和 `v.count` 是二叉搜索树节点的字段：\n\n- `v.left` 和 `v.right` 分别是节点 $v$ 的左子节点和右子节点。\n- `v.min` 和 `v.max` 分别是以节点 $v$ 为根的子树中的最小键值和最大键值。\n- `v.key` 是节点 $v$ 的键值。\n- `v.count` 是以节点 $v$ 为根的子树中的节点数量。\n\n给定一棵键值为整数的二叉搜索树，以及若干查询，每个查询包含两个整数 $L$ 和 $R$。请计算在调用 `lookup(root, L, R)` 时，`lookup` 函数被调用的总次数（包括初始调用 `lookup(root, L, R)` 本身）。", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 200\\,000$）——二叉搜索树的节点数量。\n\n接下来的 $n$ 行描述树的节点。第 $i$ 行包含三个整数 $l_i$、$r_i$ 和 $k_i$，分别表示第 $i$ 个节点的左子节点、右子节点和键值。如果节点没有左子节点或右子节点，则对应值为 $0$（$l_i = 0$ 或 $i < l_i \\le n$；$r_i = 0$ 或 $i < r_i \\le n$；$-10^9 \\le k_i \\le 10^9$）。树的根节点为节点 $1$，保证这是一棵合法的二叉搜索树。\n\n注意，`v.min`、`v.max` 和 `v.count` 并未在输入中显式给出，因为它们可以通过 $l_i$、$r_i$ 和 $k_i$ 推导得出。\n\n接下来一行包含一个整数 $q$（$1 \\le q \\le 200\\,000$）——查询的数量。\n\n接下来的 $q$ 行每行包含两个整数 $L$ 和 $R$（$-10^9 \\le L \\le R \\le 10^9$）——作为 `lookup` 函数的参数。", "outputFormat": "输出 $q$ 行，第 $i$ 行包含一个整数——第 $i$ 个查询中 `lookup` 函数被调用的总次数。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12862", "type": "P", "difficulty": 3, "samples": [["5\n1 1\n2 1 2\n1 2\n1 2\n1 1", "4"], ["5\n1 1\n1 1\n1 1\n1 1\n1 1", "5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "二分", "拓扑排序", "ICPC", "NERC/NEERC"], "title": "[NERC 2020 Online] Miser", "background": "", "description": "In some non-classical University, there is going to be an opening ceremony of the cafeteria in $n$ days. In front of the closed cafeteria, there is a sign with a number --- how many days are left before the opening.\n\nFor each day out of these $n$, the director of the cafeteria knows all the people who are coming to the University and are going to see the sign. The director has to choose a sign with a number each day, such that each person who is coming to the University sees that the number on the sign is decreasing. The director is a typical $\\emph{miser}$ who spends as little money as possible and wants to order the minimum possible number of different signs. Your task is to help the director find this number.\n\nConsider the first test case: person $1$ comes on days $1$, $2$ and $5$, and person $2$ comes on days $2$, $3$ and $4$. The director can order just four signs with numbers $1$, $2$, $3$ and $4$, to put a sign with $1$ on days $5$ and $4$, a sign with $2$ on day $3$, a sign with $3$ on day $2$, and a sign with $4$ on day $1$. Thus, person $1$ will see the signs $4$, $2$, and $1$ and person $2$ will see the signs $3$, $2$, and $1$.", "inputFormat": "The first line of the input contains an integer $n$ --- the total number of days before the opening of the~cafeteria. The next $n$ lines contain the description of each day. The description starts with the positive integer $k$ --- the number of people that come to the University this day. This integer is followed by $k$ distinct integers --- the identifiers of the people that come.\n\nThe sum of all $k$ over all days does not exceed $10^5$. Identifiers of people are positive and do not exceed $10^5$.", "outputFormat": "Output one integer --- the minimum possible number of different signs that have to be ordered.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2020 Online] Miser", "background": "", "description": "In some non-classical University, there is going to be an opening ceremony of the cafeteria in $n$ days. In front of the closed cafeteria, there is a sign with a number --- how many days are left before the opening.\n\nFor each day out of these $n$, the director of the cafeteria knows all the people who are coming to the University and are going to see the sign. The director has to choose a sign with a number each day, such that each person who is coming to the University sees that the number on the sign is decreasing. The director is a typical $\\emph{miser}$ who spends as little money as possible and wants to order the minimum possible number of different signs. Your task is to help the director find this number.\n\nConsider the first test case: person $1$ comes on days $1$, $2$ and $5$, and person $2$ comes on days $2$, $3$ and $4$. The director can order just four signs with numbers $1$, $2$, $3$ and $4$, to put a sign with $1$ on days $5$ and $4$, a sign with $2$ on day $3$, a sign with $3$ on day $2$, and a sign with $4$ on day $1$. Thus, person $1$ will see the signs $4$, $2$, and $1$ and person $2$ will see the signs $3$, $2$, and $1$.", "inputFormat": "The first line of the input contains an integer $n$ --- the total number of days before the opening of the~cafeteria. The next $n$ lines contain the description of each day. The description starts with the positive integer $k$ --- the number of people that come to the University this day. This integer is followed by $k$ distinct integers --- the identifiers of the people that come.\n\nThe sum of all $k$ over all days does not exceed $10^5$. Identifiers of people are positive and do not exceed $10^5$.", "outputFormat": "Output one integer --- the minimum possible number of different signs that have to be ordered.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2020 Online] Miser", "background": "", "description": "在某所非传统大学中，食堂将在 $n$ 天后举行开业仪式。在尚未开放的食堂门前，有一块标牌显示着距离开业的天数。\n\n对于这 $n$ 天中的每一天，食堂主管都知道当天会来学校并看到标牌的所有人员名单。主管需要每天选择一个标牌数字，并确保每个来校人员看到的数字是递减的。主管是个典型的**吝啬鬼**，希望尽可能少地订购不同数字的标牌。你的任务是帮助主管计算出最少需要订购多少种不同的标牌。\n\n以第一个测试用例为例：人员 $1$ 在第 $1$、$2$ 和 $5$ 天来校，人员 $2$ 在第 $2$、$3$ 和 $4$ 天来校。主管可以仅订购四个标牌，数字分别为 $1$、$2$、$3$ 和 $4$：在第 $5$ 和 $4$ 天放置数字 $1$ 的标牌，第 $3$ 天放置数字 $2$，第 $2$ 天放置数字 $3$，第 $1$ 天放置数字 $4$。这样，人员 $1$ 将依次看到 $4$、$2$ 和 $1$，人员 $2$ 将依次看到 $3$、$2$ 和 $1$。\n", "inputFormat": "输入的第一行包含一个整数 $n$ —— 食堂开业前的总天数。接下来的 $n$ 行描述每一天的情况。每行以一个正整数 $k$ 开头，表示当天来校的人数，随后是 $k$ 个不同的整数 —— 来校人员的编号。\n\n$n$ 不超过 $10^5$。所有 $k$ 的总和不超过 $10^5$。人员编号为正整数且不超过 $10^5$。\n", "outputFormat": "输出一个整数 —— 最少需要订购的不同标牌数量。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12863", "type": "P", "difficulty": 0, "samples": [["6 2 1 -2 1\n2 1\n0 3\n-2 1\n-2 -1\n0 -3\n2 -1", "90"], ["4 -1 -1 1 0\n1 1\n-1 1\n-1 -1\n1 -1", "36.86989764584401285674"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2020 Online] New Flat", "background": "", "description": "Flato lives in Flatburg, the capital of Flatland, and he just bought a new flat! His only problem is that while the movers brought in his favorite couch, they have put it in the wrong place. Now Flato wants to fix this by moving his couch, but it is pretty long.\nCan you help Flato?\n\nAs with all flats in Flatland, Flato's flat is a convex polygon. His favorite couch is infinitely thin, so we would represent it as a segment. Formally speaking, we have a polygon $P$ representing the flat and a segment $AB$ inside the polygon representing the couch. We say that couch can $\\emph{reach}$ position $CD$ if there are 2 continuous functions $f$ and $g$ from $[0, 1]$ to the inside or the boundary of $P$ such that $f(0) = A, f(1) = C, g(0) = B, g(1) = D$ and $|f(x)g(x)| = |AB|$ for $0 \\leq x \\leq 1$. Your task is to find the maximal possible value of the angle between the lines $AB$ and $CD$ for all the reachable positions $CD$. The angle between lines is defined as the minimum of two angles at the point of intersection, or $0$ if lines are parallel.", "inputFormat": "The first line of the input contains five integers $n$, $x_A$, $y_A$, $x_B$, and $y_B$ ($3 \\leq n \\leq 50$; $-15\\,000 \\leq x_A, y_A$, $x_B, y_B \\leq 15\\,000$) --- the number of vertices in $P$ and the coordinates of the ends of the couch.\n\nThe next $n$ lines contain two integers $x$ and $y$ each ($-15\\,000 \\leq x, y \\leq 15\\,000$) --- the coordinates of the polygon vertices in counter-clockwise order.\n\nIt is guaranteed that both $A$ and $B$ are either inside or on the boundary of $P$ and that the polygon is convex.", "outputFormat": "Output the maximal angle in degrees as described in the problem statement. Your output will be considered correct if its absolute or relative error does not exceed $10^{-6}$.\n", "hint": "The angle between two lines is always between 0 and 90 degrees. Pictures for both samples with the initial and one of the possible final positions with the largest angle are shown below. \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xo2d5dt8.png)", "locale": "en", "translations": {"en": {"title": "[NERC 2020 Online] New Flat", "background": "", "description": "Flato lives in Flatburg, the capital of Flatland, and he just bought a new flat! His only problem is that while the movers brought in his favorite couch, they have put it in the wrong place. Now Flato wants to fix this by moving his couch, but it is pretty long.\nCan you help Flato?\n\nAs with all flats in Flatland, Flato's flat is a convex polygon. His favorite couch is infinitely thin, so we would represent it as a segment. Formally speaking, we have a polygon $P$ representing the flat and a segment $AB$ inside the polygon representing the couch. We say that couch can $\\emph{reach}$ position $CD$ if there are 2 continuous functions $f$ and $g$ from $[0, 1]$ to the inside or the boundary of $P$ such that $f(0) = A, f(1) = C, g(0) = B, g(1) = D$ and $|f(x)g(x)| = |AB|$ for $0 \\leq x \\leq 1$. Your task is to find the maximal possible value of the angle between the lines $AB$ and $CD$ for all the reachable positions $CD$. The angle between lines is defined as the minimum of two angles at the point of intersection, or $0$ if lines are parallel.", "inputFormat": "The first line of the input contains five integers $n$, $x_A$, $y_A$, $x_B$, and $y_B$ ($3 \\leq n \\leq 50$; $-15\\,000 \\leq x_A, y_A$, $x_B, y_B \\leq 15\\,000$) --- the number of vertices in $P$ and the coordinates of the ends of the couch.\n\nThe next $n$ lines contain two integers $x$ and $y$ each ($-15\\,000 \\leq x, y \\leq 15\\,000$) --- the coordinates of the polygon vertices in counter-clockwise order.\n\nIt is guaranteed that both $A$ and $B$ are either inside or on the boundary of $P$ and that the polygon is convex.", "outputFormat": "Output the maximal angle in degrees as described in the problem statement. Your output will be considered correct if its absolute or relative error does not exceed $10^{-6}$.\n", "hint": "The angle between two lines is always between 0 and 90 degrees. Pictures for both samples with the initial and one of the possible final positions with the largest angle are shown below. \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xo2d5dt8.png)", "locale": "en"}, "zh-CN": {"title": "[NERC 2020 Online] New Flat", "background": "", "description": "Flato 住在平面国的首都 Flatburg，他刚刚买了一套新公寓！唯一的问题是，搬家工人把他最爱的沙发搬进来了，但放错了位置。现在 Flato 想通过移动沙发来解决这个问题，但这个沙发相当长。你能帮帮 Flato 吗？\n\n和平面国的所有公寓一样，Flato 的公寓是一个凸多边形。他最喜欢的沙发无限薄，因此我们可以用一条线段来表示它。形式化地说，我们有一个表示公寓的多边形 $P$ 和一条位于多边形内部的线段 $AB$ 表示沙发。我们说沙发可以**到达**位置 $CD$，如果存在两个连续函数 $f$ 和 $g$ 从 $[0, 1]$ 映射到 $P$ 的内部或边界，满足 $f(0) = A$、$f(1) = C$、$g(0) = B$、$g(1) = D$，并且对于 $0 \\leq x \\leq 1$ 有 $|f(x)g(x)| = |AB|$。你的任务是找出在所有可到达的位置 $CD$ 中，直线 $AB$ 和 $CD$ 之间夹角的最大可能值。两条直线之间的夹角定义为它们在交点处两个角中的较小值，如果两条直线平行则定义为 $0$。\n", "inputFormat": "输入的第一行包含五个整数 $n$、$x_A$、$y_A$、$x_B$ 和 $y_B$（$3 \\leq n \\leq 50$；$-15\\,000 \\leq x_A, y_A, x_B, y_B \\leq 15\\,000$）——多边形 $P$ 的顶点数以及沙发两端的坐标。\n\n接下来的 $n$ 行每行包含两个整数 $x$ 和 $y$（$-15\\,000 \\leq x, y \\leq 15\\,000$）——按逆时针顺序给出的多边形顶点坐标。\n\n保证 $A$ 和 $B$ 都在多边形 $P$ 的内部或边界上，且多边形是凸的。", "outputFormat": "输出题目描述中所要求的最大角度（以度为单位）。如果你的输出的绝对误差或相对误差不超过 $10^{-6}$，则视为正确。\n", "hint": "两条直线之间的夹角始终在 0 到 90 度之间。下方展示了两个样例的示意图，其中包含了初始位置和可能的最大角度对应的最终位置之一。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xo2d5dt8.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12864", "type": "P", "difficulty": 7, "samples": [["3 4\n20 14 5 2\n1 2 3 0\n3 0 3 0\n0 0 0 20\n0 15 0\n15 0 0\n0 0 0", "78\n9 9 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "网络流", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2020 Online] Optimum Server Location", "background": "", "description": "The world's best IT company Oondex is coming to Lineland! After years of facing annoying \"This service is not available in your area\" error messages, Linelanders will finally be able to listen to the most popular music, watch fresh viral videos and use lots of other opportunities provided by Oondex's services. \n\nLineland can be seen as a real coordinate line. It has unusual network tariffs: connecting two servers $d$ kilometers apart from each other with a network channel of throughput $t$ Mbit/s costs $d \\cdot t$ dollars. \n\nIn order to provide better user experience, Oondex is going to place $n$ servers in Lineland. These servers will be performing regular data processing activities which requires intense pairwise network interaction between these servers. At the same time, these servers are going to serve external users using $m$ special CDN servers (which are specialized content delivery servers) already present in Lineland. \n\nAnalysts of Oondex determined for each pair $i$, $j$ ($1 \\leq i < j \\leq n$) the required throughput $d_{ij}$ Mbit/sec between servers $i$ and $j$, and also for each pair $i$, $k$ ($1 \\leq i \\leq n$; $1 \\leq k \\leq m$) the required throughput $c_{ik}$ Mbit/sec between server $i$ and CDN server $k$. \n\nGiven the locations of CDN servers $a_k$ ($1 \\leq k \\leq m$), determine the locations $x_i$ ($1 \\leq i \\leq n$) such that the cost of placing servers into them is the minimum possible. Formally, determine $x_i$ such that the cost value of $v = \\sum\\limits_{1 \\leq i < j \\leq n} |x_i - x_j| \\cdot d_{ij} + \\sum\\limits_{\\substack{1 \\leq i \\leq n \\\\ 1 \\leq k \\leq m}} |x_i - a_k| \\cdot c_{ik}$ is the minimum possible. Multiple servers (both Oondex and CDN) may be located at the same point.", "inputFormat": "The first line contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 70$) --- the number of Oondex servers to place and the number of existing CDN servers.\n\nThe second line contains $m$ integers $a_1, a_2, \\ldots, a_m$ ($0 \\leq a_k \\leq 10^6$) --- the locations of existing CDN servers.\n\nThe $i$-th of the next $n$ lines contains $m$ integers $c_{i1}, c_{i2}, \\ldots, c_{im}$ where $c_{ik}$ ($0 \\leq c_{ik} \\leq 50$) is the throughput between $i$-th Oondex server and the $k$-th CDN server.\n\nFinally, the $i$-th of the next $n$ lines contains $n$ integers $d_{i1}, d_{i2}, \\ldots, d_{in}$ ($0 \\leq d_{ij} \\leq 50$; $d_{ij} = d_{ji}$; $d_{ii} = 0$) where $d_{ij}$ is the throughput between $j$-th Oondex server and the $i$-th Oondex server.", "outputFormat": "On the first line output the value $v$ --- the minimum possible cost of placing $n$ Oondex servers.\n\nOn the second line output $n$ integers $x_1, x_2, \\ldots, x_n$ where $x_i$ ($0 \\leq x_i \\leq 10^6$) --- the coordinates at which the $i$-th Oondex server should be placed. It can be proven that an optimum answer satisfying these restrictions on $x_i$ (range and integrality) exists.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2020 Online] Optimum Server Location", "background": "", "description": "The world's best IT company Oondex is coming to Lineland! After years of facing annoying \"This service is not available in your area\" error messages, Linelanders will finally be able to listen to the most popular music, watch fresh viral videos and use lots of other opportunities provided by Oondex's services. \n\nLineland can be seen as a real coordinate line. It has unusual network tariffs: connecting two servers $d$ kilometers apart from each other with a network channel of throughput $t$ Mbit/s costs $d \\cdot t$ dollars. \n\nIn order to provide better user experience, Oondex is going to place $n$ servers in Lineland. These servers will be performing regular data processing activities which requires intense pairwise network interaction between these servers. At the same time, these servers are going to serve external users using $m$ special CDN servers (which are specialized content delivery servers) already present in Lineland. \n\nAnalysts of Oondex determined for each pair $i$, $j$ ($1 \\leq i < j \\leq n$) the required throughput $d_{ij}$ Mbit/sec between servers $i$ and $j$, and also for each pair $i$, $k$ ($1 \\leq i \\leq n$; $1 \\leq k \\leq m$) the required throughput $c_{ik}$ Mbit/sec between server $i$ and CDN server $k$. \n\nGiven the locations of CDN servers $a_k$ ($1 \\leq k \\leq m$), determine the locations $x_i$ ($1 \\leq i \\leq n$) such that the cost of placing servers into them is the minimum possible. Formally, determine $x_i$ such that the cost value of $v = \\sum\\limits_{1 \\leq i < j \\leq n} |x_i - x_j| \\cdot d_{ij} + \\sum\\limits_{\\substack{1 \\leq i \\leq n \\\\ 1 \\leq k \\leq m}} |x_i - a_k| \\cdot c_{ik}$ is the minimum possible. Multiple servers (both Oondex and CDN) may be located at the same point.", "inputFormat": "The first line contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 70$) --- the number of Oondex servers to place and the number of existing CDN servers.\n\nThe second line contains $m$ integers $a_1, a_2, \\ldots, a_m$ ($0 \\leq a_k \\leq 10^6$) --- the locations of existing CDN servers.\n\nThe $i$-th of the next $n$ lines contains $m$ integers $c_{i1}, c_{i2}, \\ldots, c_{im}$ where $c_{ik}$ ($0 \\leq c_{ik} \\leq 50$) is the throughput between $i$-th Oondex server and the $k$-th CDN server.\n\nFinally, the $i$-th of the next $n$ lines contains $n$ integers $d_{i1}, d_{i2}, \\ldots, d_{in}$ ($0 \\leq d_{ij} \\leq 50$; $d_{ij} = d_{ji}$; $d_{ii} = 0$) where $d_{ij}$ is the throughput between $j$-th Oondex server and the $i$-th Oondex server.", "outputFormat": "On the first line output the value $v$ --- the minimum possible cost of placing $n$ Oondex servers.\n\nOn the second line output $n$ integers $x_1, x_2, \\ldots, x_n$ where $x_i$ ($0 \\leq x_i \\leq 10^6$) --- the coordinates at which the $i$-th Oondex server should be placed. It can be proven that an optimum answer satisfying these restrictions on $x_i$ (range and integrality) exists.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2020 Online] Optimum Server Location", "background": "", "description": "世界顶级 IT 公司 Oondex 即将进驻 Lineland！在经历了多年烦人的\"该服务在您所在区域不可用\"错误提示后，Lineland 的居民终于能够收听最流行的音乐、观看最新的病毒视频，并享受 Oondex 提供的诸多服务。\n\nLineland 可以看作一条实数坐标轴。该地区有独特的网络资费标准：连接两个相距 $d$ 公里的服务器，建立一条吞吐量为 $t$ Mbit/s 的网络通道需要花费 $d \\cdot t$ 美元。\n\n为了提供更好的用户体验，Oondex 计划在 Lineland 部署 $n$ 台服务器。这些服务器将执行常规的数据处理任务，需要彼此之间进行密集的网络交互。同时，这些服务器还将为外部用户提供服务，通过 Lineland 已有的 $m$ 台特殊 CDN 服务器（内容分发服务器）进行内容分发。\n\nOondex 的分析师已经确定：\n- 对于每对服务器 $i$, $j$（$1 \\leq i < j \\leq n$），服务器 $i$ 和 $j$ 之间需要的吞吐量为 $d_{ij}$ Mbit/s\n- 对于每对服务器 $i$ 和 CDN 服务器 $k$（$1 \\leq i \\leq n$；$1 \\leq k \\leq m$），服务器 $i$ 和 CDN 服务器 $k$ 之间需要的吞吐量为 $c_{ik}$ Mbit/s\n\n给定 CDN 服务器的位置 $a_k$（$1 \\leq k \\leq m$），确定 Oondex 服务器的部署位置 $x_i$（$1 \\leq i \\leq n$），使得部署成本最小。形式化地说，确定 $x_i$ 使得成本值 $v = \\sum\\limits_{1 \\leq i < j \\leq n} |x_i - x_j| \\cdot d_{ij} + \\sum\\limits_{\\substack{1 \\leq i \\leq n \\\\ 1 \\leq k \\leq m}} |x_i - a_k| \\cdot c_{ik}$ 最小。允许多台服务器（包括 Oondex 服务器和 CDN 服务器）部署在同一位置。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$（$1 \\leq n, m \\leq 70$）——需要部署的 Oondex 服务器数量和已有的 CDN 服务器数量。\n\n第二行包含 $m$ 个整数 $a_1, a_2, \\ldots, a_m$（$0 \\leq a_k \\leq 10^6$）——现有 CDN 服务器的位置。\n\n接下来的 $n$ 行，第 $i$ 行包含 $m$ 个整数 $c_{i1}, c_{i2}, \\ldots, c_{im}$，其中 $c_{ik}$（$0 \\leq c_{ik} \\leq 50$）表示第 $i$ 台 Oondex 服务器与第 $k$ 台 CDN 服务器之间的吞吐量。\n\n最后的 $n$ 行，第 $i$ 行包含 $n$ 个整数 $d_{i1}, d_{i2}, \\ldots, d_{in}$（$0 \\leq d_{ij} \\leq 50$；$d_{ij} = d_{ji}$；$d_{ii} = 0$），其中 $d_{ij}$ 表示第 $j$ 台 Oondex 服务器与第 $i$ 台 Oondex 服务器之间的吞吐量。\n", "outputFormat": "第一行输出值 $v$——部署 $n$ 台 Oondex 服务器的最小可能成本。\n\n第二行输出 $n$ 个整数 $x_1, x_2, \\ldots, x_n$，其中 $x_i$（$0 \\leq x_i \\leq 10^6$）表示第 $i$ 台 Oondex 服务器应该部署的位置。可以证明存在满足 $x_i$ 范围限制（范围和整数性）的最优解。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12865", "type": "P", "difficulty": 6, "samples": [["4\n5 3 5 2\n6\n2 1 3\n1\n2 1 1\n2 2 4\n1\n2 1 2", "13\n3\n12\n5"], ["5\n1 1 2 1 2\n5\n2 2 3\n1\n2 2 4\n1\n2 2 4", "3\n4\n4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["树状数组", "2025", "排序", "可持久化线段树", "JOI（日本）"], "title": "[JOI Open 2025] 冒泡排序机 / Bubble Sort Machine", "background": "译自 [JOI Open 2025](https://contests.ioi-jp.org/open-2025/index.html) T1「[Bubble Sort Machine](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/cm7aghex)」/ 「[バブルソート機](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/gkrcwais)」。\n", "description": "\nJOI 君——一名算法工程师，开发了冒泡排序机。\n\n冒泡排序机操作长为 $N$ 的整数序列 $a=(a_1,a_2,\\ldots,a_N)$。为了让机器能工作，给定 $A_i$ 作为 $a_i$（$1\\le i\\le N$）的初值。每当机器上的**按钮壹**被按下时，机器会按照如下方式修改序列 $a$：\n\n> 对于 $i=1,2,\\ldots,N-1$（按此顺序），若 $a_i\\gt a_{i+1}$，交换 $a_i,a_{i+1}$ 的值。\n\n为了使冒泡排序机更博人眼球，JOI 君决定加入以下功能：\n\n> 当**按钮贰**被按下时，给定整数 $l,r$ 作为输入（须满足 $1\\le l\\le r\\le N$），机器会输出 $a_{l}+a_{l+1}+\\cdots+a_r$ 的值。\n\n给定整数序列的初值和冒泡排序机的操作序列，编程计算按钮贰的输出值。\n", "inputFormat": "\n输入格式如下所示：\n\n> $N$ \\\n> $A_1$ $A_2$ $\\cdots$ $A_N$ \\\n> $Q$ \\\n> $(\\text{Query }1)$ \\\n> $(\\text{Query }2)$ \\\n> $\\vdots$ \\\n> $(\\text{Query }Q)$\n\n这里，$Q$ 指的是冒泡排序机的操作数。每个 $(\\text{Query }j)$（$1\\le j\\le Q$）由若干个空格分隔的数字组成。令 $T_j$ 为 $(\\text{Query }j)$ 的首个数字。这行的内容为以下二者之一：\n\n- 若 $T_j=1$，这行再没有其他整数了。这意味着冒泡排序机的第 $j$ 次操作按下了按钮壹。\n- 若 $T_j=2$，接下来还有两个整数，依次是 $L_j,R_j$。这意味着冒泡排序机的第 $j$ 次操作按下了按钮贰，给定的输入为 $L_j,R_j$。", "outputFormat": "\n对每个按下按钮贰的操作［意思是，对每个满足 $T_j=2$ 的 $j$（$1\\le j\\le Q$）］，输出一行一个整数，表示冒泡排序机的输出。你的输出应与询问的顺序相符。", "hint": "\n### 样例解释\n\n#### 样例 $1$ 解释\n\n初值为 $a_1=5,a_2=3,a_3=5,a_4=2$，$a=(5,3,5,2)$。接下来在冒泡排序机上操作：\n\n1. 按下按钮贰，输入 $l=1,r=3$。机器输出 $a_1+a_2+a_3=13$。\n2. 按下按钮壹。对 $i=1,2,3$，按此顺序进行如下操作：\n    - $i=1$：由于 $a_1\\gt a_2$，交换二者的值，操作后 $a=(3,5,5,2)$。\n    - $i=2$：由于并没有 $a_2\\gt a_3$，不操作 $a$。\n    - $i=3$：由于 $a_3\\gt a_4$，交换二者的值，操作后 $a=(3,5,2,5)$。\n3. 按下按钮贰，输入 $l=1,r=1$。机器输出 $a_1=3$。\n3. 按下按钮贰，输入 $l=2,r=4$。机器输出 $a_2+a_3+a_4=12$。\n5. 按下按钮壹。对 $i=1,2,3$，按此顺序进行如下操作：\n    - $i=1$：由于并没有 $a_1\\gt a_2$，不操作 $a$。\n    - $i=2$：由于 $a_2\\gt a_3$，交换二者的值，操作后 $a=(3,2,5,5)$。\n    - $i=3$：由于并没有 $a_3\\gt a_4$，不操作 $a$。\n6. 按下按钮贰，输入 $l=1,r=2$。机器输出 $a_1+a_2=5$。\n\n样例 $1$ 满足子任务 $1,5,6$ 的限制。\n\n#### 样例 $2$ 解释\n\n样例 $2$ 满足子任务 $1,3,5,6$ 的限制。\n\n\n### 数据范围\n\n- $2\\le N\\le 500\\, 000$；\n- $1\\le A_i\\le 10^9\\, (1\\le i\\le N)$；\n- $1\\le Q\\le 500\\, 000$；\n- $T_j\\in \\{1,2\\}\\, (1\\le j\\le Q)$；\n- 若 $T_j=2$，有 $1\\le L_j\\le R_j\\le N\\, (1\\le j\\le Q)$；\n- 输入的值都是整数。\n\n### 子任务\n\n- $\\text{Subtask 1 (5 pts)}$：满足 $T_j=1$ 的 $j\\,(1\\le j\\le Q)$ 至多有 $10$ 个；\n- $\\text{Subtask 2 (11 pts)}$：$N,Q\\le 150\\, 000$，当 $T_j=2$ 时 $L_j=R_j=1\\, (1\\le j\\le Q)$；\n- $\\text{Subtask 3 (15 pts)}$：$N,Q\\le 150\\, 000$，$1\\le A_i\\le 2\\, (1\\le i\\le N)$；\n- $\\text{Subtask 4 (23 pts)}$：$N,Q\\le 150\\, 000$，当 $T_j=2$ 时 $L_j=R_j\\, (1\\le j\\le Q)$；\n- $\\text{Subtask 5 (29 pts)}$：$N,Q\\le 150\\, 000$；\n- $\\text{Subtask 6 (17 pts)}$：无额外限制。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI Open 2025] 冒泡排序机 / Bubble Sort Machine", "background": "译自 [JOI Open 2025](https://contests.ioi-jp.org/open-2025/index.html) T1「[Bubble Sort Machine](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/cm7aghex)」/ 「[バブルソート機](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/gkrcwais)」。\n", "description": "\nJOI 君——一名算法工程师，开发了冒泡排序机。\n\n冒泡排序机操作长为 $N$ 的整数序列 $a=(a_1,a_2,\\ldots,a_N)$。为了让机器能工作，给定 $A_i$ 作为 $a_i$（$1\\le i\\le N$）的初值。每当机器上的**按钮壹**被按下时，机器会按照如下方式修改序列 $a$：\n\n> 对于 $i=1,2,\\ldots,N-1$（按此顺序），若 $a_i\\gt a_{i+1}$，交换 $a_i,a_{i+1}$ 的值。\n\n为了使冒泡排序机更博人眼球，JOI 君决定加入以下功能：\n\n> 当**按钮贰**被按下时，给定整数 $l,r$ 作为输入（须满足 $1\\le l\\le r\\le N$），机器会输出 $a_{l}+a_{l+1}+\\cdots+a_r$ 的值。\n\n给定整数序列的初值和冒泡排序机的操作序列，编程计算按钮贰的输出值。\n", "inputFormat": "\n输入格式如下所示：\n\n> $N$ \\\n> $A_1$ $A_2$ $\\cdots$ $A_N$ \\\n> $Q$ \\\n> $(\\text{Query }1)$ \\\n> $(\\text{Query }2)$ \\\n> $\\vdots$ \\\n> $(\\text{Query }Q)$\n\n这里，$Q$ 指的是冒泡排序机的操作数。每个 $(\\text{Query }j)$（$1\\le j\\le Q$）由若干个空格分隔的数字组成。令 $T_j$ 为 $(\\text{Query }j)$ 的首个数字。这行的内容为以下二者之一：\n\n- 若 $T_j=1$，这行再没有其他整数了。这意味着冒泡排序机的第 $j$ 次操作按下了按钮壹。\n- 若 $T_j=2$，接下来还有两个整数，依次是 $L_j,R_j$。这意味着冒泡排序机的第 $j$ 次操作按下了按钮贰，给定的输入为 $L_j,R_j$。", "outputFormat": "\n对每个按下按钮贰的操作［意思是，对每个满足 $T_j=2$ 的 $j$（$1\\le j\\le Q$）］，输出一行一个整数，表示冒泡排序机的输出。你的输出应与询问的顺序相符。", "hint": "\n### 样例解释\n\n#### 样例 $1$ 解释\n\n初值为 $a_1=5,a_2=3,a_3=5,a_4=2$，$a=(5,3,5,2)$。接下来在冒泡排序机上操作：\n\n1. 按下按钮贰，输入 $l=1,r=3$。机器输出 $a_1+a_2+a_3=13$。\n2. 按下按钮壹。对 $i=1,2,3$，按此顺序进行如下操作：\n    - $i=1$：由于 $a_1\\gt a_2$，交换二者的值，操作后 $a=(3,5,5,2)$。\n    - $i=2$：由于并没有 $a_2\\gt a_3$，不操作 $a$。\n    - $i=3$：由于 $a_3\\gt a_4$，交换二者的值，操作后 $a=(3,5,2,5)$。\n3. 按下按钮贰，输入 $l=1,r=1$。机器输出 $a_1=3$。\n3. 按下按钮贰，输入 $l=2,r=4$。机器输出 $a_2+a_3+a_4=12$。\n5. 按下按钮壹。对 $i=1,2,3$，按此顺序进行如下操作：\n    - $i=1$：由于并没有 $a_1\\gt a_2$，不操作 $a$。\n    - $i=2$：由于 $a_2\\gt a_3$，交换二者的值，操作后 $a=(3,2,5,5)$。\n    - $i=3$：由于并没有 $a_3\\gt a_4$，不操作 $a$。\n6. 按下按钮贰，输入 $l=1,r=2$。机器输出 $a_1+a_2=5$。\n\n样例 $1$ 满足子任务 $1,5,6$ 的限制。\n\n#### 样例 $2$ 解释\n\n样例 $2$ 满足子任务 $1,3,5,6$ 的限制。\n\n\n### 数据范围\n\n- $2\\le N\\le 500\\, 000$；\n- $1\\le A_i\\le 10^9\\, (1\\le i\\le N)$；\n- $1\\le Q\\le 500\\, 000$；\n- $T_j\\in \\{1,2\\}\\, (1\\le j\\le Q)$；\n- 若 $T_j=2$，有 $1\\le L_j\\le R_j\\le N\\, (1\\le j\\le Q)$；\n- 输入的值都是整数。\n\n### 子任务\n\n- $\\text{Subtask 1 (5 pts)}$：满足 $T_j=1$ 的 $j\\,(1\\le j\\le Q)$ 至多有 $10$ 个；\n- $\\text{Subtask 2 (11 pts)}$：$N,Q\\le 150\\, 000$，当 $T_j=2$ 时 $L_j=R_j=1\\, (1\\le j\\le Q)$；\n- $\\text{Subtask 3 (15 pts)}$：$N,Q\\le 150\\, 000$，$1\\le A_i\\le 2\\, (1\\le i\\le N)$；\n- $\\text{Subtask 4 (23 pts)}$：$N,Q\\le 150\\, 000$，当 $T_j=2$ 时 $L_j=R_j\\, (1\\le j\\le Q)$；\n- $\\text{Subtask 5 (29 pts)}$：$N,Q\\le 150\\, 000$；\n- $\\text{Subtask 6 (17 pts)}$：无额外限制。\n\n", "locale": "zh-CN"}}}
{"pid": "P12866", "type": "P", "difficulty": 6, "samples": [["5 3\n2 1 3 1 0\n1 1 0 2 0\n0 3\n1 4\n2 3", "2\n0\n2"], ["6 5\n1 3 3 2 1 0\n1 2 1 1 2 1\n0 1\n1 2\n1 4\n2 5\n4 5", "2\n3\n3\n1\n1"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "交互题", "Special Judge", "JOI（日本）"], "title": "[JOI Open 2025] 抽奖 / Lottery", "background": "\n译自 [JOI Open 2025](https://contests.ioi-jp.org/open-2025/index.html) T2「[Lottery](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/lgmg41dn)」/ 「[くじ引き](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/ydv1gwqi)」。\n\n**这是一道函数式交互题**。请使用 $\\textcolor{red}{\\texttt{C++\\,20}}$ 提交。\n\n**不要** $\\texttt{\\#include \"lottery.h\"}$。", "description": "\nJOI 君计划举办一场抽奖活动。活动将会用到偶数数量的袋子，一开始每袋中装着若干（可以是零个）红球和蓝球。玩家会一直来抽奖，直到有一个袋子被取空。每位玩家从每个袋子中各取一球，若取的红球数等于蓝球数，则中奖。取走的球不会放回袋中。\n\nJOI 君准备了 $N$ 个袋子，编号 $0\\sim N-1$。袋 $i$ 中装有 $X_i$ 个红球，$Y_i$ 个蓝球。\n\nJOI 君会选择这 $N$ 个袋子中的若干个用在实际抽奖活动中。有 $Q$ 个计划，第 $j\\, (1\\le j\\le Q)$ 个计划中，将会用到袋 $L_j,L_j+1,\\ldots,R_j$。这里，保证 $R_j-L_j+1$ 是偶数。\n\n为预订奖品，JOI 君想要知道每个计划中玩家最多可以中多少次奖。给定袋中球的数量和各个方案，试编程计算每个计划中玩家最多可以中多少次奖。\n\n\n### 实现细节\n\n\n**这是一道函数式交互题**。你不应该，也不需要定义 `main` 函数。\n\n**不要** $\\texttt{\\#include \"lottery.h\"}$。\n\n你应当实现以下的函数：\n\n```cpp\nvoid init(int N, int Q, std::vector<int> X, std::vector<int> Y);\n```\n\n- 该函数仅在开始时被调用一次。\n- $\\texttt{N}$ 指 JOI 君准备的袋子数 $N$。\n- $\\texttt{Q}$ 指计划数 $Q$。\n- $\\texttt{X}$ 是一个长度为 $N$ 的数组。$\\texttt{X[i]}\\, (0\\le i\\le N-1)$ 指袋 $i$ 中的红球数。\n- $\\texttt{Y}$ 是一个长度为 $N$ 的数组。$\\texttt{Y[i]}\\, (0\\le i\\le N-1)$ 指袋 $i$ 中的蓝球数。\n\n\n\n```cpp\nint max_prize(int L, int R)\n```\n\n- 该函数在 `init` 调用后被调用恰好 $Q$ 次。\n- 第 $j\\, (1\\le j\\le Q)$ 次调用：\n    - $\\texttt{L}$ 指第 $j$ 个计划的 $L_j$。\n    - $\\texttt{R}$ 指第 $j$ 个计划的 $R_j$。\n    - 该函数必须返回第 $j$ 个计划中玩家最多可以中多少次奖。\n\n### 重要说明\n\n- 你可以在程序中定义其他函数或使用全局变量。\n- 你的程序不得使用标准输出输出，禁止以任何方式与任何文件交互。你可以输出调试信息到标准错误流。\n\n### 编译运行\n\n你可以在「附件」中下载附件压缩包，压缩包中包含 Sample Grader 和本题的示例文件。\n\nSample Grader 是文件 $\\texttt{grader.cpp}$。为测试程序，将 $\\texttt{grader.cpp},\\texttt{lottery.cpp},\\texttt{lottery.h}$ 置于同一目录下，用以下命令来编译：\n\n```bash\ng++ -std=gnu++20 -O2 -o grader grader.cpp lottery.cpp\n```\n\n此外，你也可以运行压缩包中的 $\\texttt{compile.sh}$ 来编译：\n\n```bash\n./complie.sh\n```\n\n若编译成功，会生成名为 $\\texttt{grader}$ 的可执行文件。\n\n注意，实际测评时使用的 Grader 与 Sample Grader 不同。Sample Grader 以单进程方式执行，从标准输入流读入数据并将结果输出至标准输出流。\n", "inputFormat": "\nSample Grader 从标准输入流读入以下格式的数据：\n\n> $N$ $Q$\\\n> $X_0$ $X_1$ $\\cdots$ $X_{N-1}$\\\n> $Y_0$ $Y_1$ $\\cdots$ $Y_{N-1}$\\\n> $L_1$ $R_1$\\\n> $L_2$ $R_2$\\\n> $\\vdots$\\\n> $L_Q$ $R_Q$", "outputFormat": "Sample Grader 将每次 `max_prize` 的调用结果输出至标准输出流。\n", "hint": "\n### 样例解释\n\n#### 样例 $1$ 解释\n\n| 调用函数 | 返回值 |\n| - | - |\n| $\\texttt{init(5,3,[2,1,3,1,0],[1,1,0,2,0])}$ | |\n| $\\texttt{max\\_prize(0,3)}$ | $2$ |\n| $\\texttt{max\\_prize(1,4)}$ | $0$ |\n| $\\texttt{max\\_prize(2,3)}$ | $2$ |\n\n**第一次调用** `max_prize` 时，使用了袋 $0,1,2,3$。按照以下方式取球，中奖次数为 $2$：\n\n- 第一位玩家从袋 $0,1,2,3$ 中依次取出红球、蓝球、红球、蓝球。由于红蓝球数量相等，该玩家中奖。 \n- 第二位玩家从袋 $0,1,2,3$ 中依次取出蓝球、红球、红球、蓝球。由于红蓝球数量相等，该玩家中奖。 \n- 袋 $1$ 被取空，抽奖活动结束。\n\n无法得到 $\\gt 2$ 次的中奖次数，所以第一次调用返回 $2$。\n\n**第二次调用** `max_prize` 时，使用了袋 $1,2,3,4$。由于袋 $4$ 是空的，没人抽奖抽奖活动就结束了。因此，无人中奖，第二次调用返回 $0$。\n\n\n**第三次调用** `max_prize` 时，使用了袋 $2,3$。按照以下方式取球，中奖次数为 $3$：\n\n- 第一位玩家从袋 $2,3$ 中依次取出红球、红球。没有中奖。\n- 第二位玩家从袋 $2,3$ 中依次取出红球、蓝球。由于红蓝球数量相等，该玩家中奖。 \n- 第三位玩家从袋 $2,3$ 中依次取出红球、蓝球。由于红蓝球数量相等，该玩家中奖。 \n- 袋 $2,3$ 被取空，抽奖活动结束。\n\n无法得到 $\\gt 2$ 次的中奖次数，所以第三次调用返回 $2$。\n\n\n样例 $1$ 满足子任务 $1,2,4\\sim 6$ 的限制。\n\n#### 样例 $2$ 解释\n\n| 调用函数 | 返回值 |\n| - | - |\n| $\\texttt{init(6,5,[1,3,3,2,1,0],[1,2,1,1,2,1])}$ | |\n| $\\texttt{max\\_prize(0,1)}$ | $2$ |\n| $\\texttt{max\\_prize(1,2)}$ | $3$ |\n| $\\texttt{max\\_prize(1,4)}$ | $3$ |\n| $\\texttt{max\\_prize(2,5)}$ | $1$ |\n| $\\texttt{max\\_prize(4,5)}$ | $1$ |\n\n样例 $2$ 满足所有子任务的限制。\n\n\n### 数据范围\n\n- $2\\le N\\le 200\\, 000$；\n- $1\\le Q\\le 500\\, 000$；\n- $0\\le X_i\\le 10^9\\, (0\\le i\\le N-1)$；\n- $0\\le Y_i\\le 10^9\\, (0\\le i\\le N-1)$；\n- $0\\le L_j\\lt R_j\\le N-1\\, (1\\le j\\le Q)$；\n- $R_j-L_j+1$ 为偶数 $(1\\le j\\le Q)$；\n- 输入的值都是整数。\n\n### 子任务\n\n- $\\text{Subtask 1 (16 pts)}$：$Q,X_i,Y_i,R_j-L_j+1\\le 100\\, (0\\le i\\le N-1,1\\le j\\le Q)$；\n- $\\text{Subtask 2 (16 pts)}$：$Q,R_j-L_j+1\\le 100\\, (1\\le j\\le Q)$\n- $\\text{Subtask 3 (19 pts)}$：$Q\\le 200\\, 000$，$L_j\\le L_{j+1},R_j\\le R_{j+1}\\, (1\\le j\\le Q-1)$\n- $\\text{Subtask 4 (12 pts)}$：$N\\le 20\\, 000$，$Q\\le 50\\, 000$；\n- $\\text{Subtask 5 (14 pts)}$：$N\\le 100\\, 000$，$Q\\le 200\\, 000$；\n- $\\text{Subtask 6 (23 pts)}$：无额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI Open 2025] 抽奖 / Lottery", "background": "\n译自 [JOI Open 2025](https://contests.ioi-jp.org/open-2025/index.html) T2「[Lottery](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/lgmg41dn)」/ 「[くじ引き](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/ydv1gwqi)」。\n\n**这是一道函数式交互题**。请使用 $\\textcolor{red}{\\texttt{C++\\,20}}$ 提交。\n\n**不要** $\\texttt{\\#include \"lottery.h\"}$。", "description": "\nJOI 君计划举办一场抽奖活动。活动将会用到偶数数量的袋子，一开始每袋中装着若干（可以是零个）红球和蓝球。玩家会一直来抽奖，直到有一个袋子被取空。每位玩家从每个袋子中各取一球，若取的红球数等于蓝球数，则中奖。取走的球不会放回袋中。\n\nJOI 君准备了 $N$ 个袋子，编号 $0\\sim N-1$。袋 $i$ 中装有 $X_i$ 个红球，$Y_i$ 个蓝球。\n\nJOI 君会选择这 $N$ 个袋子中的若干个用在实际抽奖活动中。有 $Q$ 个计划，第 $j\\, (1\\le j\\le Q)$ 个计划中，将会用到袋 $L_j,L_j+1,\\ldots,R_j$。这里，保证 $R_j-L_j+1$ 是偶数。\n\n为预订奖品，JOI 君想要知道每个计划中玩家最多可以中多少次奖。给定袋中球的数量和各个方案，试编程计算每个计划中玩家最多可以中多少次奖。\n\n\n### 实现细节\n\n\n**这是一道函数式交互题**。你不应该，也不需要定义 `main` 函数。\n\n**不要** $\\texttt{\\#include \"lottery.h\"}$。\n\n你应当实现以下的函数：\n\n```cpp\nvoid init(int N, int Q, std::vector<int> X, std::vector<int> Y);\n```\n\n- 该函数仅在开始时被调用一次。\n- $\\texttt{N}$ 指 JOI 君准备的袋子数 $N$。\n- $\\texttt{Q}$ 指计划数 $Q$。\n- $\\texttt{X}$ 是一个长度为 $N$ 的数组。$\\texttt{X[i]}\\, (0\\le i\\le N-1)$ 指袋 $i$ 中的红球数。\n- $\\texttt{Y}$ 是一个长度为 $N$ 的数组。$\\texttt{Y[i]}\\, (0\\le i\\le N-1)$ 指袋 $i$ 中的蓝球数。\n\n\n\n```cpp\nint max_prize(int L, int R)\n```\n\n- 该函数在 `init` 调用后被调用恰好 $Q$ 次。\n- 第 $j\\, (1\\le j\\le Q)$ 次调用：\n    - $\\texttt{L}$ 指第 $j$ 个计划的 $L_j$。\n    - $\\texttt{R}$ 指第 $j$ 个计划的 $R_j$。\n    - 该函数必须返回第 $j$ 个计划中玩家最多可以中多少次奖。\n\n### 重要说明\n\n- 你可以在程序中定义其他函数或使用全局变量。\n- 你的程序不得使用标准输出输出，禁止以任何方式与任何文件交互。你可以输出调试信息到标准错误流。\n\n### 编译运行\n\n你可以在「附件」中下载附件压缩包，压缩包中包含 Sample Grader 和本题的示例文件。\n\nSample Grader 是文件 $\\texttt{grader.cpp}$。为测试程序，将 $\\texttt{grader.cpp},\\texttt{lottery.cpp},\\texttt{lottery.h}$ 置于同一目录下，用以下命令来编译：\n\n```bash\ng++ -std=gnu++20 -O2 -o grader grader.cpp lottery.cpp\n```\n\n此外，你也可以运行压缩包中的 $\\texttt{compile.sh}$ 来编译：\n\n```bash\n./complie.sh\n```\n\n若编译成功，会生成名为 $\\texttt{grader}$ 的可执行文件。\n\n注意，实际测评时使用的 Grader 与 Sample Grader 不同。Sample Grader 以单进程方式执行，从标准输入流读入数据并将结果输出至标准输出流。\n", "inputFormat": "\nSample Grader 从标准输入流读入以下格式的数据：\n\n> $N$ $Q$\\\n> $X_0$ $X_1$ $\\cdots$ $X_{N-1}$\\\n> $Y_0$ $Y_1$ $\\cdots$ $Y_{N-1}$\\\n> $L_1$ $R_1$\\\n> $L_2$ $R_2$\\\n> $\\vdots$\\\n> $L_Q$ $R_Q$", "outputFormat": "Sample Grader 将每次 `max_prize` 的调用结果输出至标准输出流。\n", "hint": "\n### 样例解释\n\n#### 样例 $1$ 解释\n\n| 调用函数 | 返回值 |\n| - | - |\n| $\\texttt{init(5,3,[2,1,3,1,0],[1,1,0,2,0])}$ | |\n| $\\texttt{max\\_prize(0,3)}$ | $2$ |\n| $\\texttt{max\\_prize(1,4)}$ | $0$ |\n| $\\texttt{max\\_prize(2,3)}$ | $2$ |\n\n**第一次调用** `max_prize` 时，使用了袋 $0,1,2,3$。按照以下方式取球，中奖次数为 $2$：\n\n- 第一位玩家从袋 $0,1,2,3$ 中依次取出红球、蓝球、红球、蓝球。由于红蓝球数量相等，该玩家中奖。 \n- 第二位玩家从袋 $0,1,2,3$ 中依次取出蓝球、红球、红球、蓝球。由于红蓝球数量相等，该玩家中奖。 \n- 袋 $1$ 被取空，抽奖活动结束。\n\n无法得到 $\\gt 2$ 次的中奖次数，所以第一次调用返回 $2$。\n\n**第二次调用** `max_prize` 时，使用了袋 $1,2,3,4$。由于袋 $4$ 是空的，没人抽奖抽奖活动就结束了。因此，无人中奖，第二次调用返回 $0$。\n\n\n**第三次调用** `max_prize` 时，使用了袋 $2,3$。按照以下方式取球，中奖次数为 $3$：\n\n- 第一位玩家从袋 $2,3$ 中依次取出红球、红球。没有中奖。\n- 第二位玩家从袋 $2,3$ 中依次取出红球、蓝球。由于红蓝球数量相等，该玩家中奖。 \n- 第三位玩家从袋 $2,3$ 中依次取出红球、蓝球。由于红蓝球数量相等，该玩家中奖。 \n- 袋 $2,3$ 被取空，抽奖活动结束。\n\n无法得到 $\\gt 2$ 次的中奖次数，所以第三次调用返回 $2$。\n\n\n样例 $1$ 满足子任务 $1,2,4\\sim 6$ 的限制。\n\n#### 样例 $2$ 解释\n\n| 调用函数 | 返回值 |\n| - | - |\n| $\\texttt{init(6,5,[1,3,3,2,1,0],[1,2,1,1,2,1])}$ | |\n| $\\texttt{max\\_prize(0,1)}$ | $2$ |\n| $\\texttt{max\\_prize(1,2)}$ | $3$ |\n| $\\texttt{max\\_prize(1,4)}$ | $3$ |\n| $\\texttt{max\\_prize(2,5)}$ | $1$ |\n| $\\texttt{max\\_prize(4,5)}$ | $1$ |\n\n样例 $2$ 满足所有子任务的限制。\n\n\n### 数据范围\n\n- $2\\le N\\le 200\\, 000$；\n- $1\\le Q\\le 500\\, 000$；\n- $0\\le X_i\\le 10^9\\, (0\\le i\\le N-1)$；\n- $0\\le Y_i\\le 10^9\\, (0\\le i\\le N-1)$；\n- $0\\le L_j\\lt R_j\\le N-1\\, (1\\le j\\le Q)$；\n- $R_j-L_j+1$ 为偶数 $(1\\le j\\le Q)$；\n- 输入的值都是整数。\n\n### 子任务\n\n- $\\text{Subtask 1 (16 pts)}$：$Q,X_i,Y_i,R_j-L_j+1\\le 100\\, (0\\le i\\le N-1,1\\le j\\le Q)$；\n- $\\text{Subtask 2 (16 pts)}$：$Q,R_j-L_j+1\\le 100\\, (1\\le j\\le Q)$\n- $\\text{Subtask 3 (19 pts)}$：$Q\\le 200\\, 000$，$L_j\\le L_{j+1},R_j\\le R_{j+1}\\, (1\\le j\\le Q-1)$\n- $\\text{Subtask 4 (12 pts)}$：$N\\le 20\\, 000$，$Q\\le 50\\, 000$；\n- $\\text{Subtask 5 (14 pts)}$：$N\\le 100\\, 000$，$Q\\le 200\\, 000$；\n- $\\text{Subtask 6 (23 pts)}$：无额外限制。", "locale": "zh-CN"}}}
{"pid": "P12867", "type": "P", "difficulty": 7, "samples": [["2\n1\n3\n0 1\n1 2\n2 1 0\n2 0 1\n1 0", ""]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "交互题", "Special Judge", "JOI（日本）", "通信题"], "title": "[JOI Open 2025] 心灵感应 / Telepathy", "background": "\n译自 [JOI Open 2025](https://contests.ioi-jp.org/open-2025/index.html) T3「[Telepathy](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/ipo36fvo)」/ 「[テレパシー](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/axpo7zc2)」。\n\n**这是一道通信题**。请使用 $\\texttt{\\textcolor{red}{C++\\,20}}$ 提交。\n\n**不要** $\\texttt{\\#include \"telepathy.h\"}$。", "description": "\n**这是一道通信题**。\n\nAitana 和 Bruno 在游玩 Bolivia 的一座国家公园。园内有 $N$ 个景点，$(N-1)$ 条道路，每条道路连接两个景点。可以通过道路从任意一个景点到达任意一个景点。\n\n他们在游玩时走散了。此刻开始，他们必须同时抵达某个景点，在那里汇合。然而，身处亚马逊雨林深处，他俩无法互相通信。他们唯一可以依靠的是手头上的地图，地图刻画了公园的结构。他俩在自己的地图上给每个景点标号了 $0,1,\\ldots,N-1$。**然而，Aitana 和 Bruno 的标号可能不同**。\n\n为了汇合，Aitana 和 Bruno 现在开始移动。每一轮，他们同时做以下两件事之一：通过一条道路移动到相邻的景点，或者原地不动。\n\n编程实现一个能够让 Aitana 和 Bruno 汇合的策略。本题中，如果在 $6d$ 轮内让他俩汇合，可以获得满分；这里，$d$ 是 Aitana 景点到 Bruno 景点最短路上的边数。**注意，如果他们在道路中间相遇，不算作汇合。**\n\n本题单个测试点内有 $Q$ 组测试数据。\n\n### 形式化题意\n\n我们形式化地描述题意。\n\n国家公园的每个景点都分配了一个 $0\\sim N-1$ 的标号，第 $j$（$0\\le j\\le N-2$）条道路连接标号为 $u_j,v_j$ 的景点。标号为 $i$（$0\\le i\\le N-1$）的景点在 Aitana 的地图上标号为 $p_i$，在 Bruno 的地图上标号 $q_i$。这里，$(p_0,p_1,\\ldots,p_{N-1})$ 和 $(q_0,q_1,\\ldots,q_{N-1})$ 是 $(0,1,\\ldots,N-1)$ 的排列。\n\nAitana 知道，对于 $j=0,1,\\ldots,N-2$，有一条连接标号 $A_j,B_j$ 的景点的道路，并且此时她位于标号为 $S$ 的景点。这里的「标号」指的是 Aitana 地图上的标号。从而，第 $j\\, (0\\le j\\le N-2)$ 条路连接着标号 $p_{u_j},p_{v_j}$ 的景点，并且令 Aitana 现在所在的景点标号为 $s$，有 $S=p_s$。注意，道路不一定按顺序给出，也不一定是 $u_j,v_j$ 的顺序。类似地，Bruno 知道，对于 $j=0,1,\\ldots,N-2$，有一条连接标号 $C_j,D_j$ 的景点的道路，并且此时她位于标号为 $T$ 的景点。这里的「标号」指的是 Bruno 地图上的标号。特别地，令 Bruno 现在所在的景点标号为 $t$，有 $T=q_t$。\n\n根据已知信息，Aitana 和 Bruno 决定他们接下来 $10N$ 轮的动向。换言之，Aitana 选定标号序列 $x_0,x_1,\\ldots,x_{10N}$，Bruno 选定标号序列 $y_0,y_1,\\ldots,y_{10N}$，表示他们各自的动向。以下条件必须满足：\n\n- $x_0=S$，$\\forall 1\\le k\\le 10N$，要么 $x_k=x_{k-1}$，要么（在 Aitana 的地图中）标号 $x_k,x_{k-1}$ 的节点有道路连接。\n- $y_0=T$，$\\forall 1\\le k\\le 10N$，要么 $y_k=y_{k-1}$，要么（在 Bruno 的地图中）标号 $y_k,y_{k-1}$ 的节点有道路连接。\n\nAitana 与 Bruno 汇合时的轮数 $k^*$ 指最小的满足（Aitana 的地图中）标号 $x_k$ 的景点与（Bruno 的地图中）标号 $y_k$ 的景点代表着同一个景点的 $k$。获得满分，当且仅当 $k^*\\le 6d$。\n\n### 实现细节\n\n\n**这是一道通信题**。你不应该，也不需要定义 `main` 函数。\n\n**不要** $\\texttt{\\#include \"telepathy.h\"}$。\n\n你应该定义以下的函数：\n\n```cpp\nvector<int> Aitana(int N, vector<int> A, vector<int> B, int S, int subtask);\n```\n\n该函数实现了 Aitana 的策略。每组测试数据中该函数被调用恰好一次，所以该函数一共会被调用 $Q$ 次。\n- $\\texttt{N}$ 指国家公园的景点数 $N$。\n- $\\texttt{A},\\texttt{B}$ 均为长度 $N-2$ 的数组，$\\forall 0\\le j\\le N-2$，$\\texttt{A[j]},\\texttt{B[j]}$ 是一条道路连接着的两个景点的标号 $A_j,B_j$。\n- $\\texttt{S}$ 为 Aitana 当前所在景点的标号。\n- $\\texttt{subtask}$ 指该测试点所在的子任务编号，只能为 $1,2,3$ 之一。\n- 返回一个数组 $[x_0,x_1,\\ldots,x_{10N}]$，描述 Aitana 的动向。\n- 返回的数组长度必须为 $10N+1$，否则会被判为 $\\texttt{Wrong Answer\\,[1]}$。\n- 对于任意 $k\\, (0\\le k\\le 10N)$，必须有 $0\\le x_k\\le N-1$，否则会被判为 $\\texttt{Wrong Answer\\,[2]}$。\n- 必须有 $x_0=S$，否则会被判为 $\\texttt{Wrong Answer\\,[3]}$。\n- 对于任意 $k\\, (1\\le k\\le 10N)$，要么 $x_k=x_{k-1}$，要么标号 $x_k,x_{k-1}$ 的景点有道路连接。否则会被判为 $\\texttt{Wrong Answer\\,[4]}$。\n\n以上的「标号」指的是 Aitana 地图上的标号。\n\n\n```cpp\nvector<int> Bruno(int N, vector<int> C, vector<int> D, int T, int subtask);\n```\n\n该函数实现了 Bruno 的策略。每组测试数据中该函数在调用 `Aitana` 后被调用恰好一次，所以该函数一共会被调用 $Q$ 次。\n- $\\texttt{N}$ 指国家公园的景点数 $N$。\n- $\\texttt{C},\\texttt{D}$ 均为长度 $N-2$ 的数组，$\\forall 0\\le j\\le N-2$，$\\texttt{C[j]},\\texttt{D[j]}$ 是一条道路连接着的两个景点的标号 $C_j,D_j$。\n- $\\texttt{T}$ 为 Bruno 当前所在景点的标号。\n- $\\texttt{subtask}$ 指该测试点所在的子任务编号，只能为 $1,2,3$ 之一。\n- 返回一个数组 $[y_0,y_1,\\ldots,y_{10N}]$，描述 Bruno 的动向。\n- 返回的数组长度必须为 $10N+1$，否则会被判为 $\\texttt{Wrong Answer\\,[5]}$。\n- 对于任意 $k\\, (0\\le k\\le 10N)$，必须有 $0\\le y_k\\le N-1$，否则会被判为 $\\texttt{Wrong Answer\\,[6]}$。\n- 必须有 $y_0=T$，否则会被判为 $\\texttt{Wrong Answer\\,[7]}$。\n- 对于任意 $k\\, (1\\le k\\le 10N)$，要么 $y_k=y_{k-1}$，要么标号 $y_k,y_{k-1}$ 的景点有道路连接。否则会被判为 $\\texttt{Wrong Answer\\,[8]}$。\n\n以上的「标号」指的是 Bruno 地图上的标号。\n\n\n如果在 $10N$ 轮内 Aitana 和 Bruno 没有汇合，换句话说，$\\forall 0\\le k\\le 10N$，（Aitana 的地图中）标号 $x_k$ 的景点与（Bruno 的地图中）标号 $y_k$ 的景点均为不同的景点，你的程序会被判为 $\\texttt{Wrong Answer\\,[9]}$。\n\n### 重要说明\n\n- 你可以在程序中定义其他函数或使用全局变量。在实际评测时，你的程序将会以两个不同的进程（Aitana,Bruno）运行，这两个进程无法共享全局变量。\n- 你的程序不得使用标准输出输出，禁止以任何方式与任何文件交互。你可以输出调试信息到标准错误流。\n\n### 编译运行\n\n你可以在「附件」中下载附件压缩包，压缩包中包含 Sample Grader 和本题的示例文件。\n\n\nSample Grader 是文件 $\\texttt{grader.cpp}$。为测试程序，将 $\\texttt{grader.cpp},\\texttt{telepathy.cpp},\\texttt{telepathy.h}$ 置于同一目录下，用以下命令来编译：\n\n```bash\ng++ -std=gnu++20 -O2 -o grader grader.cpp telepathy.cpp\n```\n\n此外，你也可以运行压缩包中的 $\\texttt{compile.sh}$ 来编译：\n\n```bash\n./complie.sh\n```\n\n若编译成功，会生成名为 $\\texttt{grader}$ 的可执行文件。\n\n注意，实际测评时使用的 Grader 与 Sample Grader 不同。Sample Grader 以单进程方式执行，从标准输入流读入数据并将结果输出至标准输出流。", "inputFormat": "\nSample Grader 从标准输入流读入以下格式的数据（这里，测试数据编号 $0\\sim Q-1$，$\\mathrm{subtask}$ 指子任务编号）：\n\n> $\\mathrm{subtask}$\\\n> $Q$\\\n> (第 $0$ 组数据的内容)\\\n> (第 $1$ 组数据的内容)\\\n> $\\vdots$\\\n> (第 $(Q-1)$ 组数据的内容)\n\n每组数据格式如下：\n\n> $N$\\\n> $u_0$ $v_0$\\\n> $u_1$ $v_1$\\\n> $\\vdots$\\\n> $u_{n-2}$ $v_{n-2}$\\\n> $p_0$ $p_1$ $\\ldots$ $p_{N-1}$\\\n> $q_0$ $q_1$ $\\ldots$ $q_{N-1}$\\\n> $s$ $t$\n\n关于各变量的含义，请阅读「形式化题意」部分。**注意没有直接输入 Aitana 地图和 Bruno 地图的信息。**\n\n将道路打乱的方式由伪随机数决定，伪随机数的结果在各次运行中均相同。如果想要更换随机数种子，将随机数种子作为第一个参数运行 Sample Grader：\n\n```bash\n./grader 20250615\n```", "outputFormat": "\nSample Grader 输出 $Q$ 行到标准输出流，依次表示每组测试数据的信息：\n\n- 若该组数据正确，依次输出汇合轮数 $k^{*}$ 和 $d$（Aitana 当前所在景点与 Bruno 当前所在景点的最短路上的边数），例如 $\\texttt{Case \\#0: Accepted 5 2}$。\n- 否则，输出错误类型，如 $\\texttt{Case \\#0: Wrong Answer [1]}$。", "hint": "\n### 注意事项\n\n实际评测时，输入未必在程序执行前就确定了，有可能会根据 `Aitana` 和 `Bruno` 的返回值确定。\n\n### 样例解释\n\n返回值中，若干部分被省略了，实际上每个返回值都是长度为 $31$ 的数组。\n\n调用 `Aitana`：$\\texttt{Aitana(3,[0,1],[1,2],1,2)}$，返回 $\\texttt{[1,0,0,1,2,...,2]}$。\n\n调用 `Bruno`：$\\texttt{Bruno(3,[1,0],[2,0],2,2)}$，返回 $\\texttt{[2,2,0,0,1,...,1]}$。\n\n该样例中，国家公园的结构以及 Aitana、Bruno 地图上的信息如图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wyo5pnum.png)\n\nAitana 的动向是：每一轮中，她分别在（她地图中）标号 $1,0,0,1,2,\\ldots,2$ 的景点。Bruno 的动向是：每一轮中，他分别在（他地图中）标号 $2,2,0,0,1,\\ldots,1$ 的景点。他们第 $3$ 轮结束时汇合。此时，Aitana 在（她地图中）标号 $1$ 的景点，Bruno 在（他地图中）标号 $0$ 的景点，这两个实际上是同一个景点。\n\n\n### 数据范围\n\n本题中，单组数据中至多有 $201$ 个测试点（即 $1\\le Q\\le 201$）。每个测试点满足以下的限制：\n\n- $2\\le N\\le 200$；\n- $(p_0,p_1,\\ldots,p_{N-1})$ 是 $(0,1,\\ldots,N-1)$ 的排列；\n- $(q_0,q_1,\\ldots,q_{N-1})$ 是 $(0,1,\\ldots,N-1)$ 的排列；\n- $0\\le u_j\\le N-1\\, (0\\le j\\le N-2)$；\n- $0\\le v_j\\le N-1\\, (0\\le j\\le N-2)$；\n- 从任意景点，可通过道路移动到任意景点；\n- $0\\le s\\le N-1$；\n- $0\\le t\\le N-1$；\n- $s\\neq t$。\n\n### 子任务\n\n- $\\text{Subtask 1 (40 pts)}$：$(p_0,p_1,\\ldots,p_{N-1})$=$(q_0,q_1,\\ldots,q_{N-1})=(0,1,\\ldots,N-1)$；\n- $\\text{Subtask 2 (40 pts)}$：$u_j=j,v_j=j+1$（$0\\le j\\le N-2$）；\n- $\\text{Subtask 3 (20 pts)}$：无额外限制。\n\n### 计分方式\n\n令 $k^{*}$ 表示 Aitana 和 Bruno 汇合的轮数，$d$ 表示 Aitana 当前所在景点与 Bruno 当前所在景点的最短路上的边数。令 $\\alpha$ 表示该子任务重 $\\frac{k^*}{d}$ 的最大值。\n\n如果该子任务中你的程序被判为错误，得零分。否则，按照以下方式得分（若同时满足多个条件，则取最高的分数）：\n\n- 若任意数据都有 $k^*\\le 10N$，得 $15\\%$ 的分。\n- 若任意数据都有 $k^*\\le \\max(10d,N)$，得 $25\\%$ 的分。\n- 若任意数据都有 $k^*\\le 10d$：\n    - 若 $9\\lt \\alpha\\le 10$，得 $40\\%$ 的分；\n    - 若 $0\\lt \\alpha\\le 9$，得 $\\lfloor 100-20(\\alpha-6)\\rfloor \\%$ 的分；\n    - 若 $\\alpha\\le 6$，得 $100\\%$ 的分。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI Open 2025] 心灵感应 / Telepathy", "background": "\n译自 [JOI Open 2025](https://contests.ioi-jp.org/open-2025/index.html) T3「[Telepathy](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/ipo36fvo)」/ 「[テレパシー](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/axpo7zc2)」。\n\n**这是一道通信题**。请使用 $\\texttt{\\textcolor{red}{C++\\,20}}$ 提交。\n\n**不要** $\\texttt{\\#include \"telepathy.h\"}$。", "description": "\n**这是一道通信题**。\n\nAitana 和 Bruno 在游玩 Bolivia 的一座国家公园。园内有 $N$ 个景点，$(N-1)$ 条道路，每条道路连接两个景点。可以通过道路从任意一个景点到达任意一个景点。\n\n他们在游玩时走散了。此刻开始，他们必须同时抵达某个景点，在那里汇合。然而，身处亚马逊雨林深处，他俩无法互相通信。他们唯一可以依靠的是手头上的地图，地图刻画了公园的结构。他俩在自己的地图上给每个景点标号了 $0,1,\\ldots,N-1$。**然而，Aitana 和 Bruno 的标号可能不同**。\n\n为了汇合，Aitana 和 Bruno 现在开始移动。每一轮，他们同时做以下两件事之一：通过一条道路移动到相邻的景点，或者原地不动。\n\n编程实现一个能够让 Aitana 和 Bruno 汇合的策略。本题中，如果在 $6d$ 轮内让他俩汇合，可以获得满分；这里，$d$ 是 Aitana 景点到 Bruno 景点最短路上的边数。**注意，如果他们在道路中间相遇，不算作汇合。**\n\n本题单个测试点内有 $Q$ 组测试数据。\n\n### 形式化题意\n\n我们形式化地描述题意。\n\n国家公园的每个景点都分配了一个 $0\\sim N-1$ 的标号，第 $j$（$0\\le j\\le N-2$）条道路连接标号为 $u_j,v_j$ 的景点。标号为 $i$（$0\\le i\\le N-1$）的景点在 Aitana 的地图上标号为 $p_i$，在 Bruno 的地图上标号 $q_i$。这里，$(p_0,p_1,\\ldots,p_{N-1})$ 和 $(q_0,q_1,\\ldots,q_{N-1})$ 是 $(0,1,\\ldots,N-1)$ 的排列。\n\nAitana 知道，对于 $j=0,1,\\ldots,N-2$，有一条连接标号 $A_j,B_j$ 的景点的道路，并且此时她位于标号为 $S$ 的景点。这里的「标号」指的是 Aitana 地图上的标号。从而，第 $j\\, (0\\le j\\le N-2)$ 条路连接着标号 $p_{u_j},p_{v_j}$ 的景点，并且令 Aitana 现在所在的景点标号为 $s$，有 $S=p_s$。注意，道路不一定按顺序给出，也不一定是 $u_j,v_j$ 的顺序。类似地，Bruno 知道，对于 $j=0,1,\\ldots,N-2$，有一条连接标号 $C_j,D_j$ 的景点的道路，并且此时她位于标号为 $T$ 的景点。这里的「标号」指的是 Bruno 地图上的标号。特别地，令 Bruno 现在所在的景点标号为 $t$，有 $T=q_t$。\n\n根据已知信息，Aitana 和 Bruno 决定他们接下来 $10N$ 轮的动向。换言之，Aitana 选定标号序列 $x_0,x_1,\\ldots,x_{10N}$，Bruno 选定标号序列 $y_0,y_1,\\ldots,y_{10N}$，表示他们各自的动向。以下条件必须满足：\n\n- $x_0=S$，$\\forall 1\\le k\\le 10N$，要么 $x_k=x_{k-1}$，要么（在 Aitana 的地图中）标号 $x_k,x_{k-1}$ 的节点有道路连接。\n- $y_0=T$，$\\forall 1\\le k\\le 10N$，要么 $y_k=y_{k-1}$，要么（在 Bruno 的地图中）标号 $y_k,y_{k-1}$ 的节点有道路连接。\n\nAitana 与 Bruno 汇合时的轮数 $k^*$ 指最小的满足（Aitana 的地图中）标号 $x_k$ 的景点与（Bruno 的地图中）标号 $y_k$ 的景点代表着同一个景点的 $k$。获得满分，当且仅当 $k^*\\le 6d$。\n\n### 实现细节\n\n\n**这是一道通信题**。你不应该，也不需要定义 `main` 函数。\n\n**不要** $\\texttt{\\#include \"telepathy.h\"}$。\n\n你应该定义以下的函数：\n\n```cpp\nvector<int> Aitana(int N, vector<int> A, vector<int> B, int S, int subtask);\n```\n\n该函数实现了 Aitana 的策略。每组测试数据中该函数被调用恰好一次，所以该函数一共会被调用 $Q$ 次。\n- $\\texttt{N}$ 指国家公园的景点数 $N$。\n- $\\texttt{A},\\texttt{B}$ 均为长度 $N-2$ 的数组，$\\forall 0\\le j\\le N-2$，$\\texttt{A[j]},\\texttt{B[j]}$ 是一条道路连接着的两个景点的标号 $A_j,B_j$。\n- $\\texttt{S}$ 为 Aitana 当前所在景点的标号。\n- $\\texttt{subtask}$ 指该测试点所在的子任务编号，只能为 $1,2,3$ 之一。\n- 返回一个数组 $[x_0,x_1,\\ldots,x_{10N}]$，描述 Aitana 的动向。\n- 返回的数组长度必须为 $10N+1$，否则会被判为 $\\texttt{Wrong Answer\\,[1]}$。\n- 对于任意 $k\\, (0\\le k\\le 10N)$，必须有 $0\\le x_k\\le N-1$，否则会被判为 $\\texttt{Wrong Answer\\,[2]}$。\n- 必须有 $x_0=S$，否则会被判为 $\\texttt{Wrong Answer\\,[3]}$。\n- 对于任意 $k\\, (1\\le k\\le 10N)$，要么 $x_k=x_{k-1}$，要么标号 $x_k,x_{k-1}$ 的景点有道路连接。否则会被判为 $\\texttt{Wrong Answer\\,[4]}$。\n\n以上的「标号」指的是 Aitana 地图上的标号。\n\n\n```cpp\nvector<int> Bruno(int N, vector<int> C, vector<int> D, int T, int subtask);\n```\n\n该函数实现了 Bruno 的策略。每组测试数据中该函数在调用 `Aitana` 后被调用恰好一次，所以该函数一共会被调用 $Q$ 次。\n- $\\texttt{N}$ 指国家公园的景点数 $N$。\n- $\\texttt{C},\\texttt{D}$ 均为长度 $N-2$ 的数组，$\\forall 0\\le j\\le N-2$，$\\texttt{C[j]},\\texttt{D[j]}$ 是一条道路连接着的两个景点的标号 $C_j,D_j$。\n- $\\texttt{T}$ 为 Bruno 当前所在景点的标号。\n- $\\texttt{subtask}$ 指该测试点所在的子任务编号，只能为 $1,2,3$ 之一。\n- 返回一个数组 $[y_0,y_1,\\ldots,y_{10N}]$，描述 Bruno 的动向。\n- 返回的数组长度必须为 $10N+1$，否则会被判为 $\\texttt{Wrong Answer\\,[5]}$。\n- 对于任意 $k\\, (0\\le k\\le 10N)$，必须有 $0\\le y_k\\le N-1$，否则会被判为 $\\texttt{Wrong Answer\\,[6]}$。\n- 必须有 $y_0=T$，否则会被判为 $\\texttt{Wrong Answer\\,[7]}$。\n- 对于任意 $k\\, (1\\le k\\le 10N)$，要么 $y_k=y_{k-1}$，要么标号 $y_k,y_{k-1}$ 的景点有道路连接。否则会被判为 $\\texttt{Wrong Answer\\,[8]}$。\n\n以上的「标号」指的是 Bruno 地图上的标号。\n\n\n如果在 $10N$ 轮内 Aitana 和 Bruno 没有汇合，换句话说，$\\forall 0\\le k\\le 10N$，（Aitana 的地图中）标号 $x_k$ 的景点与（Bruno 的地图中）标号 $y_k$ 的景点均为不同的景点，你的程序会被判为 $\\texttt{Wrong Answer\\,[9]}$。\n\n### 重要说明\n\n- 你可以在程序中定义其他函数或使用全局变量。在实际评测时，你的程序将会以两个不同的进程（Aitana,Bruno）运行，这两个进程无法共享全局变量。\n- 你的程序不得使用标准输出输出，禁止以任何方式与任何文件交互。你可以输出调试信息到标准错误流。\n\n### 编译运行\n\n你可以在「附件」中下载附件压缩包，压缩包中包含 Sample Grader 和本题的示例文件。\n\n\nSample Grader 是文件 $\\texttt{grader.cpp}$。为测试程序，将 $\\texttt{grader.cpp},\\texttt{telepathy.cpp},\\texttt{telepathy.h}$ 置于同一目录下，用以下命令来编译：\n\n```bash\ng++ -std=gnu++20 -O2 -o grader grader.cpp telepathy.cpp\n```\n\n此外，你也可以运行压缩包中的 $\\texttt{compile.sh}$ 来编译：\n\n```bash\n./complie.sh\n```\n\n若编译成功，会生成名为 $\\texttt{grader}$ 的可执行文件。\n\n注意，实际测评时使用的 Grader 与 Sample Grader 不同。Sample Grader 以单进程方式执行，从标准输入流读入数据并将结果输出至标准输出流。", "inputFormat": "\nSample Grader 从标准输入流读入以下格式的数据（这里，测试数据编号 $0\\sim Q-1$，$\\mathrm{subtask}$ 指子任务编号）：\n\n> $\\mathrm{subtask}$\\\n> $Q$\\\n> (第 $0$ 组数据的内容)\\\n> (第 $1$ 组数据的内容)\\\n> $\\vdots$\\\n> (第 $(Q-1)$ 组数据的内容)\n\n每组数据格式如下：\n\n> $N$\\\n> $u_0$ $v_0$\\\n> $u_1$ $v_1$\\\n> $\\vdots$\\\n> $u_{n-2}$ $v_{n-2}$\\\n> $p_0$ $p_1$ $\\ldots$ $p_{N-1}$\\\n> $q_0$ $q_1$ $\\ldots$ $q_{N-1}$\\\n> $s$ $t$\n\n关于各变量的含义，请阅读「形式化题意」部分。**注意没有直接输入 Aitana 地图和 Bruno 地图的信息。**\n\n将道路打乱的方式由伪随机数决定，伪随机数的结果在各次运行中均相同。如果想要更换随机数种子，将随机数种子作为第一个参数运行 Sample Grader：\n\n```bash\n./grader 20250615\n```", "outputFormat": "\nSample Grader 输出 $Q$ 行到标准输出流，依次表示每组测试数据的信息：\n\n- 若该组数据正确，依次输出汇合轮数 $k^{*}$ 和 $d$（Aitana 当前所在景点与 Bruno 当前所在景点的最短路上的边数），例如 $\\texttt{Case \\#0: Accepted 5 2}$。\n- 否则，输出错误类型，如 $\\texttt{Case \\#0: Wrong Answer [1]}$。", "hint": "\n### 注意事项\n\n实际评测时，输入未必在程序执行前就确定了，有可能会根据 `Aitana` 和 `Bruno` 的返回值确定。\n\n### 样例解释\n\n返回值中，若干部分被省略了，实际上每个返回值都是长度为 $31$ 的数组。\n\n调用 `Aitana`：$\\texttt{Aitana(3,[0,1],[1,2],1,2)}$，返回 $\\texttt{[1,0,0,1,2,...,2]}$。\n\n调用 `Bruno`：$\\texttt{Bruno(3,[1,0],[2,0],2,2)}$，返回 $\\texttt{[2,2,0,0,1,...,1]}$。\n\n该样例中，国家公园的结构以及 Aitana、Bruno 地图上的信息如图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wyo5pnum.png)\n\nAitana 的动向是：每一轮中，她分别在（她地图中）标号 $1,0,0,1,2,\\ldots,2$ 的景点。Bruno 的动向是：每一轮中，他分别在（他地图中）标号 $2,2,0,0,1,\\ldots,1$ 的景点。他们第 $3$ 轮结束时汇合。此时，Aitana 在（她地图中）标号 $1$ 的景点，Bruno 在（他地图中）标号 $0$ 的景点，这两个实际上是同一个景点。\n\n\n### 数据范围\n\n本题中，单组数据中至多有 $201$ 个测试点（即 $1\\le Q\\le 201$）。每个测试点满足以下的限制：\n\n- $2\\le N\\le 200$；\n- $(p_0,p_1,\\ldots,p_{N-1})$ 是 $(0,1,\\ldots,N-1)$ 的排列；\n- $(q_0,q_1,\\ldots,q_{N-1})$ 是 $(0,1,\\ldots,N-1)$ 的排列；\n- $0\\le u_j\\le N-1\\, (0\\le j\\le N-2)$；\n- $0\\le v_j\\le N-1\\, (0\\le j\\le N-2)$；\n- 从任意景点，可通过道路移动到任意景点；\n- $0\\le s\\le N-1$；\n- $0\\le t\\le N-1$；\n- $s\\neq t$。\n\n### 子任务\n\n- $\\text{Subtask 1 (40 pts)}$：$(p_0,p_1,\\ldots,p_{N-1})$=$(q_0,q_1,\\ldots,q_{N-1})=(0,1,\\ldots,N-1)$；\n- $\\text{Subtask 2 (40 pts)}$：$u_j=j,v_j=j+1$（$0\\le j\\le N-2$）；\n- $\\text{Subtask 3 (20 pts)}$：无额外限制。\n\n### 计分方式\n\n令 $k^{*}$ 表示 Aitana 和 Bruno 汇合的轮数，$d$ 表示 Aitana 当前所在景点与 Bruno 当前所在景点的最短路上的边数。令 $\\alpha$ 表示该子任务重 $\\frac{k^*}{d}$ 的最大值。\n\n如果该子任务中你的程序被判为错误，得零分。否则，按照以下方式得分（若同时满足多个条件，则取最高的分数）：\n\n- 若任意数据都有 $k^*\\le 10N$，得 $15\\%$ 的分。\n- 若任意数据都有 $k^*\\le \\max(10d,N)$，得 $25\\%$ 的分。\n- 若任意数据都有 $k^*\\le 10d$：\n    - 若 $9\\lt \\alpha\\le 10$，得 $40\\%$ 的分；\n    - 若 $0\\lt \\alpha\\le 9$，得 $\\lfloor 100-20(\\alpha-6)\\rfloor \\%$ 的分；\n    - 若 $\\alpha\\le 6$，得 $100\\%$ 的分。\n\n", "locale": "zh-CN"}}}
{"pid": "P12868", "type": "P", "difficulty": 1, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["数学", "2025", "蓝桥杯国赛"], "title": "[蓝桥杯 2025 国 Python A] 最大周长", "background": "", "description": "已知一个长方形的面积为 $2025$，且其长和宽均为正整数。现在，请你计算这个长方形可能的最大周长是多少。\n", "inputFormat": "", "outputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2025 国 Python A] 最大周长", "background": "", "description": "已知一个长方形的面积为 $2025$，且其长和宽均为正整数。现在，请你计算这个长方形可能的最大周长是多少。\n", "inputFormat": "", "outputFormat": "这是一道结果填空题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12869", "type": "P", "difficulty": 2, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["数学", "2025", "枚举", "蓝桥杯国赛"], "title": "[蓝桥杯 2025 国 Python A] 特殊整数对的数量", "background": "", "description": "我们称一对正整数 $(a, b)$ 是 “特别互素对”，如果满足以下条件：\n\n1. $1 \\leq a < b \\leq 10^6$ 。\n2. $a$ 与 $b$ 互素，即 $a$ 和 $b$ 的最大公约数为 $1$ 。\n3. $a + b$ 是 $2025$ 的倍数。\n\n请计算一共有多少对 $(a, b)$ 是 “特别互素对”。", "inputFormat": "", "outputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个数字，在提交答案时只填写这个数字，填写多余的内容将无法得分。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2025 国 Python A] 特殊整数对的数量", "background": "", "description": "我们称一对正整数 $(a, b)$ 是 “特别互素对”，如果满足以下条件：\n\n1. $1 \\leq a < b \\leq 10^6$ 。\n2. $a$ 与 $b$ 互素，即 $a$ 和 $b$ 的最大公约数为 $1$ 。\n3. $a + b$ 是 $2025$ 的倍数。\n\n请计算一共有多少对 $(a, b)$ 是 “特别互素对”。", "inputFormat": "", "outputFormat": "这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个数字，在提交答案时只填写这个数字，填写多余的内容将无法得分。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12870", "type": "P", "difficulty": 1, "samples": [["9", "10"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "贪心", "2025", "蓝桥杯国赛"], "title": "[蓝桥杯 2025 国 Python A] 铺设能源管道", "background": "", "description": "能源公司正着手建立新的基地。为了确保基地的能源供应，公司计划铺设一条长度至少为 $n$ 公里的能源管道。铺设管道的成本并非简单地与管道长度成正比，而是由管道长度的**各位数字之和**决定。例如，铺设 $123$ 公里的管道，实际成本为 $1 + 2 + 3 = 6$ 。\n\n为了尽可能降低成本，公司希望找到一个长度为 $m$ 公里的铺设方案，使得 $m$ 不小于 $n$，并且 $m$ 的数位和最小。如果存在多个满足条件的 $m$，则选择数值最小的方案，以确保在成本相同的情况下，尽可能减少资源浪费。\n\n现在，请你帮助能源公司计算出最优的管道铺设长度 $m$。", "inputFormat": "输入一行包含一个整数 $n$，表示需要铺设的最低管道长度。\n", "outputFormat": "输出一行包含一个整数 $m$，表示最优的管道铺设长度。\n", "hint": "**【评测用例规模与约定】**\n\n对于 $30\\%$ 的评测用例，$1 \\leq n \\leq 100$。\n\n对于所有的评测用例，$1 \\leq n \\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2025 国 Python A] 铺设能源管道", "background": "", "description": "能源公司正着手建立新的基地。为了确保基地的能源供应，公司计划铺设一条长度至少为 $n$ 公里的能源管道。铺设管道的成本并非简单地与管道长度成正比，而是由管道长度的**各位数字之和**决定。例如，铺设 $123$ 公里的管道，实际成本为 $1 + 2 + 3 = 6$ 。\n\n为了尽可能降低成本，公司希望找到一个长度为 $m$ 公里的铺设方案，使得 $m$ 不小于 $n$，并且 $m$ 的数位和最小。如果存在多个满足条件的 $m$，则选择数值最小的方案，以确保在成本相同的情况下，尽可能减少资源浪费。\n\n现在，请你帮助能源公司计算出最优的管道铺设长度 $m$。", "inputFormat": "输入一行包含一个整数 $n$，表示需要铺设的最低管道长度。\n", "outputFormat": "输出一行包含一个整数 $m$，表示最优的管道铺设长度。\n", "hint": "**【评测用例规模与约定】**\n\n对于 $30\\%$ 的评测用例，$1 \\leq n \\leq 100$。\n\n对于所有的评测用例，$1 \\leq n \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P12871", "type": "P", "difficulty": 2, "samples": [["3 3 4\nangel\nac\nangle\nlang", "2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "2025", "哈希 hashing", "蓝桥杯国赛"], "title": "[蓝桥杯 2025 国 Python A] 倒排索引", "background": "", "description": "在信息检索系统中，倒排索引是一种常用的数据结构，用于快速查找包含特定词语的文档集合。为了增强搜索的灵活性，我们引入了 N-Gram 分词算法，参数 $[\\min, \\max]$，表示分别按照长度 $\\min$、$\\min+1$、$\\cdots$、$\\max$ 对单词进行滑动窗口截取。例如对于 $[3, 5]$ 的 N-Gram，会将单词 $\\tt{lanqb}$ 分割为 $[\\tt{lan, anq, nqb, lanq, anqb, lanqb}]$ 的索引序列，如果文档长度小于 $\\min$，那么索引序列只包含文档本身。\n\n给定 $n$ 个文档，对于第 $i$ 个文档 $d_i$，利用上述的 N-Gram 算法为其生成一组索引序列 $L_i$。对于查询词 $q$，也对其应用 N-Gram 为其生成一个索引序列 $P$，如果序列 $P$ 中的某个单词出现在序列 $L_i$ 中，那么就认为查询词和文档 $d_i$ 匹配成功。\n\n请统计查询词 $q$ 能与多少个文档匹配成功。", "inputFormat": "输入的第一行包含三个正整数 $n$，$\\min$，$\\max$，相邻整数之间使用一个空格分隔。\n\n接下来 $n$ 行，每行包含一个字符串，其中第 $i$ 行的字符串表示文档 $d_i$。\n\n接下来一行包含一个字符串，表示查询词 $q$。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "**【样例说明】**\n\n文档分词结果如下：\n\n- $\\tt{angel}$：$[\\tt{ang, nge, gel, ange, ngel}]$\n- $\\tt{ac}$：$[\\tt{ac}]$\n- $\\tt{angle}$：$[\\tt{ang, ngl, gle, angl, ngle}]$\n\n查询词分词结果如下：\n\n- $\\tt{lang}$：$[\\tt{lan, ang, lang}]$\n\n$\\tt{angel}$ 和 $\\tt{angle}$ 的分词中都包含 $\\tt{ang}$，所以答案为 $2$。\n\n**【评测用例规模与约定】**\n\n设 $|s|$ 表示字符串 $s$ 的长度。\n\n对于 50% 的评测用例，$1 \\leq n \\leq 100$；\n\n对于所有评测用例，$1 \\leq n \\leq 10^3$，$1 \\leq \\min \\leq \\max \\leq 20$，$1 \\leq |d_i|, |q| \\leq 20$，$d_i$ 和 $q$ 都只包含小写英文字母。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2025 国 Python A] 倒排索引", "background": "", "description": "在信息检索系统中，倒排索引是一种常用的数据结构，用于快速查找包含特定词语的文档集合。为了增强搜索的灵活性，我们引入了 N-Gram 分词算法，参数 $[\\min, \\max]$，表示分别按照长度 $\\min$、$\\min+1$、$\\cdots$、$\\max$ 对单词进行滑动窗口截取。例如对于 $[3, 5]$ 的 N-Gram，会将单词 $\\tt{lanqb}$ 分割为 $[\\tt{lan, anq, nqb, lanq, anqb, lanqb}]$ 的索引序列，如果文档长度小于 $\\min$，那么索引序列只包含文档本身。\n\n给定 $n$ 个文档，对于第 $i$ 个文档 $d_i$，利用上述的 N-Gram 算法为其生成一组索引序列 $L_i$。对于查询词 $q$，也对其应用 N-Gram 为其生成一个索引序列 $P$，如果序列 $P$ 中的某个单词出现在序列 $L_i$ 中，那么就认为查询词和文档 $d_i$ 匹配成功。\n\n请统计查询词 $q$ 能与多少个文档匹配成功。", "inputFormat": "输入的第一行包含三个正整数 $n$，$\\min$，$\\max$，相邻整数之间使用一个空格分隔。\n\n接下来 $n$ 行，每行包含一个字符串，其中第 $i$ 行的字符串表示文档 $d_i$。\n\n接下来一行包含一个字符串，表示查询词 $q$。", "outputFormat": "输出一行包含一个整数表示答案。", "hint": "**【样例说明】**\n\n文档分词结果如下：\n\n- $\\tt{angel}$：$[\\tt{ang, nge, gel, ange, ngel}]$\n- $\\tt{ac}$：$[\\tt{ac}]$\n- $\\tt{angle}$：$[\\tt{ang, ngl, gle, angl, ngle}]$\n\n查询词分词结果如下：\n\n- $\\tt{lang}$：$[\\tt{lan, ang, lang}]$\n\n$\\tt{angel}$ 和 $\\tt{angle}$ 的分词中都包含 $\\tt{ang}$，所以答案为 $2$。\n\n**【评测用例规模与约定】**\n\n设 $|s|$ 表示字符串 $s$ 的长度。\n\n对于 50% 的评测用例，$1 \\leq n \\leq 100$；\n\n对于所有评测用例，$1 \\leq n \\leq 10^3$，$1 \\leq \\min \\leq \\max \\leq 20$，$1 \\leq |d_i|, |q| \\leq 20$，$d_i$ 和 $q$ 都只包含小写英文字母。", "locale": "zh-CN"}}}
