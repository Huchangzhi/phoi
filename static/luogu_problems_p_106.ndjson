{"pid": "P3148", "type": "P", "difficulty": 7, "samples": [["5\n5 5\naaaaa\n..a..\nbbabb\n..a..\naaaaa\n3 5\n..abb\n..a..\naaaaa\n5 2\na.\na.\naa\na.\na.\n1 2\nbb\n1 5\nbbabb\n2 5\naaaaa\n..a..", "3"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["模拟", "2016", "二分", "USACO", "O2优化", "哈希 hashing", "前缀和"], "title": "[USACO16OPEN] Bull in a China Shop P", "background": null, "description": "Farmer John has decided his home needs more decoration. Visiting the local china shop, he finds a delicate glass cow figurine that he decides to purchase, knowing that it will fit perfectly on the mantel above his fireplace.\n\nThe shape of the cow figurine is described by an $N \\times M$ grid of characters like the one below ($3 \\leq N, M \\leq 500$), where lowercase letter characters are each part of the figurine (indicating different colors) and '.' characters are not.\n\n```\n...............\n...............\nx..x...........\nxxxx...........\nxxxxaaaaaaa...\n.xx.aaaaaaaaa..\n....aaaaaaa.aa.\n....ll...ll....\n....vv...vv....\n...............\n```\n\nUnfortunately, right before FJ can make his purchase, a bull runs through the shop and breaks not only FJ's figurine, but many of the other glass objects on the shelves as well! FJ's figurine breaks into 3 pieces, which quickly become lost among $K$ total pieces lying on the ground ($4 \\leq K \\leq 100$). Each of the $K$ pieces is described by a grid of characters, just like the original figurine.\n\nPlease help FJ determine how many sets of 3 pieces (out of the $K$ on the floor) could be glued back together to mend his broken figurine.\n\nThe pieces on the ground might have been flipped vertically or horizontally, or rotated by some multiple of 90 degrees. Therefore, given the original grid as well as $K$ grids describing pieces, you want to find sets of 3 pieces that can be joined together to form the original picture, allowing the pieces to be translated, flipped, or rotated multiples of 90 degrees. When then superimposed, the 3 pieces should exactly form the original picture, with each colored square in the original picture represented in exactly one of the pieces.", "inputFormat": "The first line contains a single integer $K$. Following that will be $K + 1$ piece descriptions. The first description will describe the original glass cow, the following $K$ descriptions will be of the broken pieces.\n\nEach description begins with a line containing two integers $R$ and $C$ ($1 \\le R, C \\le 500$).  The following $R$ lines contain $C$ lowercase alphabet characters describing the color of each cell. Each piece will be horizontally/vertically connected and have at least one non-empty cell.", "outputFormat": "Output the number of triples $i, j, k$ ($i < j < k$) such that pieces $i$, $j$, and $k$ can be arranged to form the original glass cow.", "hint": "The three solutions use pieces $(0, 1, 2)$, $(0, 2, 4)$, $(1, 3, 4)$.\n\nNote that this problem has a time limit of 6 seconds per test case (and twice that for Java and Python submissions).", "locale": "en", "translations": {"en": {"title": "[USACO16OPEN] Bull in a China Shop P", "background": null, "description": "Farmer John has decided his home needs more decoration. Visiting the local china shop, he finds a delicate glass cow figurine that he decides to purchase, knowing that it will fit perfectly on the mantel above his fireplace.\n\nThe shape of the cow figurine is described by an $N \\times M$ grid of characters like the one below ($3 \\leq N, M \\leq 500$), where lowercase letter characters are each part of the figurine (indicating different colors) and '.' characters are not.\n\n```\n...............\n...............\nx..x...........\nxxxx...........\nxxxxaaaaaaa...\n.xx.aaaaaaaaa..\n....aaaaaaa.aa.\n....ll...ll....\n....vv...vv....\n...............\n```\n\nUnfortunately, right before FJ can make his purchase, a bull runs through the shop and breaks not only FJ's figurine, but many of the other glass objects on the shelves as well! FJ's figurine breaks into 3 pieces, which quickly become lost among $K$ total pieces lying on the ground ($4 \\leq K \\leq 100$). Each of the $K$ pieces is described by a grid of characters, just like the original figurine.\n\nPlease help FJ determine how many sets of 3 pieces (out of the $K$ on the floor) could be glued back together to mend his broken figurine.\n\nThe pieces on the ground might have been flipped vertically or horizontally, or rotated by some multiple of 90 degrees. Therefore, given the original grid as well as $K$ grids describing pieces, you want to find sets of 3 pieces that can be joined together to form the original picture, allowing the pieces to be translated, flipped, or rotated multiples of 90 degrees. When then superimposed, the 3 pieces should exactly form the original picture, with each colored square in the original picture represented in exactly one of the pieces.", "inputFormat": "The first line contains a single integer $K$. Following that will be $K + 1$ piece descriptions. The first description will describe the original glass cow, the following $K$ descriptions will be of the broken pieces.\n\nEach description begins with a line containing two integers $R$ and $C$ ($1 \\le R, C \\le 500$).  The following $R$ lines contain $C$ lowercase alphabet characters describing the color of each cell. Each piece will be horizontally/vertically connected and have at least one non-empty cell.", "outputFormat": "Output the number of triples $i, j, k$ ($i < j < k$) such that pieces $i$, $j$, and $k$ can be arranged to form the original glass cow.", "hint": "The three solutions use pieces $(0, 1, 2)$, $(0, 2, 4)$, $(1, 3, 4)$.\n\nNote that this problem has a time limit of 6 seconds per test case (and twice that for Java and Python submissions).", "locale": "en"}, "zh-CN": {"title": "[USACO16OPEN] Bull in a China Shop P", "background": "", "description": "Farmer John 决定给他的家增添一些装饰。在当地的瓷器店里，他发现了一尊精致的玻璃牛雕像，决定购买它，因为它完美地适合放在壁炉上方的壁炉架上。\n\n牛雕像的形状由一个 $N \\times M$ 的字符网格描述（$3 \\leq N, M \\leq 500$），其中小写字母字符代表雕像的各个部分（表示不同的颜色），而 '.' 字符则不代表雕像部分。\n\n```cpp\n...............\n...............\nx..x...........\nxxxx...........\nxxxxaaaaaaa...\n.xx.aaaaaaaaa..\n....aaaaaaa.aa.\n....ll...ll....\n....vv...vv....\n...............\n```\n\n不幸的是，就在 FJ 准备购买之前，一头公牛冲进了商店，不仅撞碎了 FJ 的雕像，还撞碎了许多其他货架上的玻璃制品！FJ 的雕像碎成了 3 块，并迅速混入了地上的 $K$ 块碎片中（$4 \\leq K \\leq 100$）。每一块碎片都由一个字符网格描述，就像原来的雕像一样。\n\n请帮助 FJ 确定有多少组 3 块碎片（地上的 $K$ 块中）可以粘合在一起修复他破碎的雕像。\n\n地上的碎片可能被垂直或水平翻转，或者旋转了 90 度的倍数。因此，给定原始网格以及描述碎片的 $K$ 个网格，你需要找到可以组合成原始图片的 3 块碎片，允许碎片被平移、翻转或旋转 90 度的倍数。当这 3 块碎片叠加在一起时，它们应该准确地形成原始图片，且原始图片中的每个彩色方块都恰好出现在一块碎片中。", "inputFormat": "第一行包含一个整数 $K$。接下来是 $K + 1$ 个碎片的描述。第一个描述是原始玻璃牛的描述，接下来的 $K$ 个描述是破碎的碎片。\n\n每个描述以两个整数 $R$ 和 $C$（$1 \\le R, C \\le 500$）开始。接下来的 $R$ 行包含 $C$ 个小写字母字符，描述每个单元格的颜色。每块碎片在水平/垂直方向上都是连通的，并且至少有一个非空单元格。", "outputFormat": "输出满足条件的三元组 $i, j, k$（$i < j < k$）的数量，使得碎片 $i$、$j$ 和 $k$ 可以排列成原始玻璃牛。", "hint": "三个解决方案使用了碎片 $(0, 1, 2)$、$(0, 2, 4)$ 和 $(1, 3, 4)$。\n\n请注意，这个问题每个测试用例的时间限制为 6 秒（Java 和 Python 提交的时间限制为 12 秒）。\n\n备注：原文“输入格式”部分中 $R, C$ 的范围是 $1 \\leq R, C \\leq 100$，而实际数据与之不符，疑为笔误。", "locale": "zh-CN"}}}
{"pid": "P3149", "type": "P", "difficulty": 5, "samples": [["5 2\n1 5 3 4 2\n3\n4", "5\n4\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["树状数组", "离散化", "洛谷原创"], "title": "排序", "background": "", "description": "有 $n$ 个人依次站在小 A 面前。小 A 会依次对这 $n$ 个人进行 $m$ 次操作。\n\n每次操作选择一个位置 $k$，将这 $n$ 个人中的所有身高小于等于当前 $k$ 位置的人的身高的人从队伍里拎出，然后按照身高从矮到高的顺序从左到右依次插入到 这些人原本的位置当中。\n\n小 A 对这 $n$ 个人身高构成的序列的逆序对很感兴趣。现在小 A 想要知道每一次操作后这个序列的逆序对数。\n\n----\n\nUpdate（2021-01-17）：$a$ 序列中的逆序对的定义是满足 $i < j$ 且 $a_i > a_j$ 的数对 $(i, j)$。", "inputFormat": "第一行两个整数 $n$ 和 $m$，表示人数和操作数。\n\n接下来一行 $n$ 个整数 $a_i$，表示初始状态从左到右每个人的身高。\n\n接下来 $m$ 行每行一个数，表示这次操作的 $k$。", "outputFormat": "输出共 $m + 1$ 行，第一行表示未操作时的逆序对数量。\n\n除第一行外第 $i$ 行表示第 $i - 1$ 次操作后序列的逆序对数。", "hint": "**【样例解释 #1】**\n\n第一次操作后序列为 $1, 5, 2, 4, 3$。\n\n第二次操作后序列为 $1, 5, 2, 3, 4$。\n\n**【数据范围】**\n\n对于 $100 \\%$ 的数据，$1 \\le n,m \\le 3 \\times {10}^5$，$1 \\le k \\le n$，$1 \\le a_i \\le {10}^9$。", "locale": "zh-CN", "translations": {"en": {"title": "Sorting", "background": "", "description": "There are $n$ people standing in front of Xiao A in order. Xiao A will perform $m$ operations on these $n$ people, one after another.\n\nIn each operation, choose a position $k$. Take out from the line all people whose heights are less than or equal to the height of the person currently at position $k$. Then, sort these extracted people by height in increasing order (from shortest to tallest), and put them back into the line at the same set of positions they originally occupied, filling those positions from left to right.\n\nXiao A is interested in the number of inversions of the sequence formed by these $n$ heights. Now Xiao A wants to know the inversion count of this sequence after each operation.\n\n----\nUpdate (2021-01-17): In the $a$ sequence, an inversion is a pair $(i, j)$ such that $i < j$ and $a_i > a_j$.", "inputFormat": "The first line contains two integers $n$ and $m$, the number of people and the number of operations.\n\nThe next line contains $n$ integers $a_i$, representing the heights from left to right in the initial state.\n\nEach of the next $m$ lines contains one integer, the $k$ for that operation.", "outputFormat": "Output $m + 1$ lines. The first line is the number of inversions before any operation.\n\nFor $i \\ge 2$, line $i$ is the inversion count after the $(i - 1)$-th operation.", "hint": "[Sample Explanation #1]\nAfter the first operation, the sequence is $1, 5, 2, 4, 3$.\nAfter the second operation, the sequence is $1, 5, 2, 3, 4$.\n\nConstraints\nFor $100 \\%$ of the testdata, $1 \\le n,m \\le 3 \\times 10^5$, $1 \\le k \\le n$, $1 \\le a_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "排序", "background": "", "description": "有 $n$ 个人依次站在小 A 面前。小 A 会依次对这 $n$ 个人进行 $m$ 次操作。\n\n每次操作选择一个位置 $k$，将这 $n$ 个人中的所有身高小于等于当前 $k$ 位置的人的身高的人从队伍里拎出，然后按照身高从矮到高的顺序从左到右依次插入到 这些人原本的位置当中。\n\n小 A 对这 $n$ 个人身高构成的序列的逆序对很感兴趣。现在小 A 想要知道每一次操作后这个序列的逆序对数。\n\n----\n\nUpdate（2021-01-17）：$a$ 序列中的逆序对的定义是满足 $i < j$ 且 $a_i > a_j$ 的数对 $(i, j)$。", "inputFormat": "第一行两个整数 $n$ 和 $m$，表示人数和操作数。\n\n接下来一行 $n$ 个整数 $a_i$，表示初始状态从左到右每个人的身高。\n\n接下来 $m$ 行每行一个数，表示这次操作的 $k$。", "outputFormat": "输出共 $m + 1$ 行，第一行表示未操作时的逆序对数量。\n\n除第一行外第 $i$ 行表示第 $i - 1$ 次操作后序列的逆序对数。", "hint": "**【样例解释 #1】**\n\n第一次操作后序列为 $1, 5, 2, 4, 3$。\n\n第二次操作后序列为 $1, 5, 2, 3, 4$。\n\n**【数据范围】**\n\n对于 $100 \\%$ 的数据，$1 \\le n,m \\le 3 \\times {10}^5$，$1 \\le k \\le n$，$1 \\le a_i \\le {10}^9$。", "locale": "zh-CN"}}}
{"pid": "P3150", "type": "P", "difficulty": 3, "samples": [["5\n1\n3\n7\n20\n5", "zs wins\nzs wins\nzs wins\npb wins\nzs wins\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["博弈论"], "title": "pb的游戏（1）", "background": "有一天 pb 和 zs 玩游戏  你需要帮 zs 求出每局的胜败情况。", "description": "游戏规则是这样的：\n\n- 先手对给出的数进行分割，分割成两个正整数之和，接着后手选择上一轮分割出的两个数中的其中一个再次进行分割。两人轮流操作，直到一方无法操作，另一方胜利。\n\n现在要你求出 $N$ 次游戏的胜败。\n\n我们认为双方绝顶聪明。每局由 pb 先进行分割。如果 pb 存在必胜策略，输出 `pb wins`；否则输出 `zs wins`。", "inputFormat": "第一行一个数 $N$，表示数据组数。\n\n之后 $N$ 行，每行一个数 $M$，表示每局初始的数。", "outputFormat": "共 $N$ 行，每行一串字符，表示游戏结果。", "hint": "对于全部数据，$1<N<50$，$1\\le M\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "pb's Game (1)", "background": "One day pb and zs played a game. You need to help zs determine the winner of each round.", "description": "The rules are as follows:\n- The first player splits the given number into the sum of two positive integers. Then the second player chooses one of the two numbers produced in the previous move and splits it again. The two players take turns. When a player cannot make a move, the other player wins.\n\nNow you need to determine the winner for $N$ games.\n\nWe assume both players play optimally. In each game, pb moves first. If pb has a winning strategy, output `pb wins`; otherwise output `zs wins`.", "inputFormat": "The first line contains an integer $N$, the number of test cases.\n\nThen follow $N$ lines. Each line contains an integer $M$, the initial number for that game.", "outputFormat": "Output $N$ lines. Each line contains a string indicating the game result.", "hint": "Constraints: For all testdata, $1 < N < 50$, $1 \\le M \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "pb的游戏（1）", "background": "有一天 pb 和 zs 玩游戏  你需要帮 zs 求出每局的胜败情况。", "description": "游戏规则是这样的：\n\n- 先手对给出的数进行分割，分割成两个正整数之和，接着后手选择上一轮分割出的两个数中的其中一个再次进行分割。两人轮流操作，直到一方无法操作，另一方胜利。\n\n现在要你求出 $N$ 次游戏的胜败。\n\n我们认为双方绝顶聪明。每局由 pb 先进行分割。如果 pb 存在必胜策略，输出 `pb wins`；否则输出 `zs wins`。", "inputFormat": "第一行一个数 $N$，表示数据组数。\n\n之后 $N$ 行，每行一个数 $M$，表示每局初始的数。", "outputFormat": "共 $N$ 行，每行一串字符，表示游戏结果。", "hint": "对于全部数据，$1<N<50$，$1\\le M\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3152", "type": "P", "difficulty": 2, "samples": [["2", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "递归"], "title": "正整数序列", "background": null, "description": "kkk 制造了一个序列，这个序列里的数全是由正整数构成的。你别认为她的数列很神奇——其实就是 $1, 2, …, n$ 而已。当然，$n$ 是给定的。kkk 的同学 lzn 认为 $0$ 是一个好数字（看上去很饱满有木有），所以他机智的趁 kkk 不在把这个序列全变成了 $0$（其实只是准备窝）~\n\n可是 kkk 突然回来了！于是 lzn 的计划破灭了。但是他并不甘心，就和 kkk 说：我可以每次从这个序列中选取一些数，然后一起减去一个相同的数（当然也是正整数）。然后经过有(wu)限(qiong)次这样的操作后，这个序列就可以全变成 $0$。\n\nkkk 当然不信咯，于是 lzn 就求出了他最少要做几次这样的操作，才能使这个序列全部变成 $0$。", "inputFormat": "一个正整数 $n$。", "outputFormat": "输出最少操作次数，如果无解输出 ```-1```。", "hint": "**数据范围**\n\n对于全部数据，$1 \\le n \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "Sequence of Positive Integers", "background": "", "description": "kkk made a sequence consisting entirely of positive integers. Don’t think it’s anything magical — it’s just $1, 2, …, n$, and $n$ is given. kkk’s classmate lzn thinks $0$ is a nice number (it looks very round), so when kkk wasn’t around, he cleverly changed the whole sequence into $0$ (well, he was just getting ready to do so).\n\nBut kkk suddenly came back! lzn’s plan failed. Unwilling to give up, he told kkk: each time, I can select some numbers from this sequence and subtract the same positive integer from all of them. After a finite number of such operations, the entire sequence can become $0$.\n\nkkk didn’t believe it, so lzn calculated the minimum number of such operations needed to make the entire sequence become $0$.", "inputFormat": "A positive integer $n$.", "outputFormat": "Output the minimum number of operations. If there is no solution, output ```-1```.", "hint": "Constraints\n\nFor all testdata, $1 \\le n \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "正整数序列", "background": null, "description": "kkk 制造了一个序列，这个序列里的数全是由正整数构成的。你别认为她的数列很神奇——其实就是 $1, 2, …, n$ 而已。当然，$n$ 是给定的。kkk 的同学 lzn 认为 $0$ 是一个好数字（看上去很饱满有木有），所以他机智的趁 kkk 不在把这个序列全变成了 $0$（其实只是准备窝）~\n\n可是 kkk 突然回来了！于是 lzn 的计划破灭了。但是他并不甘心，就和 kkk 说：我可以每次从这个序列中选取一些数，然后一起减去一个相同的数（当然也是正整数）。然后经过有(wu)限(qiong)次这样的操作后，这个序列就可以全变成 $0$。\n\nkkk 当然不信咯，于是 lzn 就求出了他最少要做几次这样的操作，才能使这个序列全部变成 $0$。", "inputFormat": "一个正整数 $n$。", "outputFormat": "输出最少操作次数，如果无解输出 ```-1```。", "hint": "**数据范围**\n\n对于全部数据，$1 \\le n \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3153", "type": "P", "difficulty": 6, "samples": [["3 0\nYYY\nYYY\nYYY", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2009", "重庆", "二分", "各省省选", "网络流"], "title": "[CQOI2009] 跳舞", "background": "", "description": "一次舞会有 $n$ 个男孩和 $n$ 个女孩。\n\n每首曲子开始时，所有男孩和女孩恰好配成 $n$ 对跳交谊舞。每个男孩都不会和同一个女孩跳两首（或更多）舞曲。\n\n有一些男孩女孩相互喜欢，而其他相互不喜欢（不会“单向喜欢”）。每个男孩最多只愿意和 $k$ 个不喜欢的女孩跳舞，而每个女孩也最多只愿意和 $k$ 个不喜欢的男孩跳舞。\n\n给出每对男孩女孩是否相互喜欢的信息，舞会最多能有几首舞曲？", "inputFormat": "第一行包含两个整数 $n$ 和 $k$。\n\n以下 $n$ 行每行包含 $n$ 个字符，每个字符只可能是 `Y` 或 `N`。第 $(i + 1)$ 行的第 $j$ 个字符为 `Y` 当且仅当男孩 $i$ 和女孩 $j$ 相互喜欢。\n", "outputFormat": "一行一个整数代表舞曲数目的最大值。", "hint": "#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，保证 $1\\leq n\\leq 50$，$0\\leq k\\leq 30$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2009] Dancing", "background": "", "description": "There are $n$ boys and $n$ girls at a party.\n\nAt the start of each song, all boys and girls are paired into exactly $n$ couples to dance ballroom. No boy ever dances two (or more) songs with the same girl.\n\nSome boy–girl pairs mutually like each other, while others mutually do not; there are no \"one-way likes.\" Each boy is willing to dance with at most $k$ girls he does not like, and each girl is willing to dance with at most $k$ boys she does not like.\n\nGiven the mutual-like information for every boy–girl pair, what is the maximum number of songs the party can have?", "inputFormat": "The first line contains two integers $n$ and $k$.\n\nEach of the next $n$ lines contains $n$ characters, and each character is either `Y` or `N`. The $j$-th character on line $(i + 1)$ is `Y` if and only if boy $i$ and girl $j$ mutually like each other.", "outputFormat": "Output a single integer on one line, representing the maximum number of songs.", "hint": "Constraints\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\le n \\le 50$, $0 \\le k \\le 30$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2009] 跳舞", "background": "", "description": "一次舞会有 $n$ 个男孩和 $n$ 个女孩。\n\n每首曲子开始时，所有男孩和女孩恰好配成 $n$ 对跳交谊舞。每个男孩都不会和同一个女孩跳两首（或更多）舞曲。\n\n有一些男孩女孩相互喜欢，而其他相互不喜欢（不会“单向喜欢”）。每个男孩最多只愿意和 $k$ 个不喜欢的女孩跳舞，而每个女孩也最多只愿意和 $k$ 个不喜欢的男孩跳舞。\n\n给出每对男孩女孩是否相互喜欢的信息，舞会最多能有几首舞曲？", "inputFormat": "第一行包含两个整数 $n$ 和 $k$。\n\n以下 $n$ 行每行包含 $n$ 个字符，每个字符只可能是 `Y` 或 `N`。第 $(i + 1)$ 行的第 $j$ 个字符为 `Y` 当且仅当男孩 $i$ 和女孩 $j$ 相互喜欢。\n", "outputFormat": "一行一个整数代表舞曲数目的最大值。", "hint": "#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，保证 $1\\leq n\\leq 50$，$0\\leq k\\leq 30$。", "locale": "zh-CN"}}}
{"pid": "P3154", "type": "P", "difficulty": 5, "samples": [["6\n5 6 7 7 8 8", "121"]], "limits": {"time": [800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2009", "重庆", "各省省选", "剪枝", "前缀和"], "title": "[CQOI2009] 循环赛", "background": "", "description": "$n$ 支队伍比赛，每两支队伍比赛一次，平 $1$ 胜 $3$ 负 $0$。\n\n给出队伍的最终得分，求有多少种可能的分数表。\n\n```平1胜3负0```指：\n\n- 若两支队伍打平，则各得到 $1$ 分；\n- 否则，胜利的队伍得到 $3$ 分，被打败的队伍得到 $0$ 分。\n", "inputFormat": "第一行包含一个正整数 $n$，表示队伍的个数。第二行包含 $n$ 个非负整数，即每支队伍的得分。\n", "outputFormat": "输出仅一行，即可能的分数表数目。保证至少存在一个可能的分数表。\n", "hint": "所有数据满足 $n\\le 8$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2009] Round-robin Tournament", "background": "", "description": "$n$ teams play a round-robin: every pair of teams plays exactly once, and a draw gives $1$, a win $3$, and a loss $0$ points.\n\nGiven the teams’ final scores, find how many possible scoreboards there are.\n\n```平1胜3负0``` means:\n- If two teams draw, each receives $1$ point.\n- Otherwise, the winner receives $3$ points, and the defeated team receives $0$ points.", "inputFormat": "The first line contains a positive integer $n$, the number of teams. The second line contains $n$ non-negative integers, the score of each team.", "outputFormat": "Output a single line: the number of possible scoreboards. It is guaranteed that at least one possible scoreboard exists.", "hint": "All testdata satisfy $n \\le 8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2009] 循环赛", "background": "", "description": "$n$ 支队伍比赛，每两支队伍比赛一次，平 $1$ 胜 $3$ 负 $0$。\n\n给出队伍的最终得分，求有多少种可能的分数表。\n\n```平1胜3负0```指：\n\n- 若两支队伍打平，则各得到 $1$ 分；\n- 否则，胜利的队伍得到 $3$ 分，被打败的队伍得到 $0$ 分。\n", "inputFormat": "第一行包含一个正整数 $n$，表示队伍的个数。第二行包含 $n$ 个非负整数，即每支队伍的得分。\n", "outputFormat": "输出仅一行，即可能的分数表数目。保证至少存在一个可能的分数表。\n", "hint": "所有数据满足 $n\\le 8$。", "locale": "zh-CN"}}}
{"pid": "P3155", "type": "P", "difficulty": 4, "samples": [["5 3\n0\n1\n0\n1 4\n2 5\n4 5\n3 5", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "重庆", "各省省选", "树形 DP"], "title": "[CQOI2009] 叶子的染色", "background": "", "description": "给一棵 $m$ 个结点的无根树，你可以选择一个度数大于 $1$ 的结点作为根，然后给一些结点（根、内部结点和叶子均可）着以黑色或白色。\n\n你的着色方案应该保证根结点到每个叶子的简单路径上都至少包含一个有色结点（哪怕是这个叶子本身）。 \n\n对于每个叶结点 $u$，定义 $c_u$ 为从根结点到 $u$ 的简单路径上最后一个有色结点的颜色。给出每个 $c_u$ 的值，设计着色方案，使得着色结点的个数尽量少。", "inputFormat": "第一行包含两个整数 $m,n$，其中 $n$ 是叶子的个数，$m$ 是结点总数。结点编号为 $1,2,\\ldots,m$，其中编号 $1,2,\\ldots ,n$ 是叶子。\n\n以下 $n$ 行每行一个 $0$ 或 $1$ 的整数（$0$ 表示黑色，$1$ 表示白色），依次为 $c_1,c_2,\\ldots,c_n$。\n\n以下 $m-1$ 行每行两个整数 $a,b$，表示结点 $a$ 和 $b$ 有边相连。", "outputFormat": "仅一个数，即着色结点数的最小值。\n", "hint": "#### 数据规模与约定\n对于全部的测试点，保证 $1\\le m\\le 10^4$，$1\\le n\\le 5021$，$1\\le a < b \\le m$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2009] Coloring the Leaves", "background": "", "description": "Given an unrooted tree with $m$ nodes, you may choose any node with degree greater than $1$ as the root, and then color some nodes (the root, internal nodes, and leaves are all allowed) black or white.\n\nYour coloring must ensure that on the simple path from the root to each leaf, there is at least one colored node (possibly the leaf itself).\n\nFor each leaf node $u$, define $c_u$ as the color of the last colored node on the simple path from the root to $u$. Given all values of $c_u$, design a coloring scheme that minimizes the number of colored nodes.", "inputFormat": "The first line contains two integers $m, n$, where $n$ is the number of leaves and $m$ is the total number of nodes. Nodes are numbered $1, 2, \\ldots, m$, and nodes $1, 2, \\ldots, n$ are leaves.\n\nEach of the next $n$ lines contains an integer $0$ or $1$ ($0$ means black, $1$ means white), in order $c_1, c_2, \\ldots, c_n$.\n\nEach of the next $m-1$ lines contains two integers $a, b$, indicating that nodes $a$ and $b$ are connected by an edge.", "outputFormat": "Output a single integer: the minimum number of colored nodes.", "hint": "#### Constraints\nFor all testdata, it is guaranteed that $1 \\le m \\le 10^4$, $1 \\le n \\le 5021$, $1 \\le a < b \\le m$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2009] 叶子的染色", "background": "", "description": "给一棵 $m$ 个结点的无根树，你可以选择一个度数大于 $1$ 的结点作为根，然后给一些结点（根、内部结点和叶子均可）着以黑色或白色。\n\n你的着色方案应该保证根结点到每个叶子的简单路径上都至少包含一个有色结点（哪怕是这个叶子本身）。 \n\n对于每个叶结点 $u$，定义 $c_u$ 为从根结点到 $u$ 的简单路径上最后一个有色结点的颜色。给出每个 $c_u$ 的值，设计着色方案，使得着色结点的个数尽量少。", "inputFormat": "第一行包含两个整数 $m,n$，其中 $n$ 是叶子的个数，$m$ 是结点总数。结点编号为 $1,2,\\ldots,m$，其中编号 $1,2,\\ldots ,n$ 是叶子。\n\n以下 $n$ 行每行一个 $0$ 或 $1$ 的整数（$0$ 表示黑色，$1$ 表示白色），依次为 $c_1,c_2,\\ldots,c_n$。\n\n以下 $m-1$ 行每行两个整数 $a,b$，表示结点 $a$ 和 $b$ 有边相连。", "outputFormat": "仅一个数，即着色结点数的最小值。\n", "hint": "#### 数据规模与约定\n对于全部的测试点，保证 $1\\le m\\le 10^4$，$1\\le n\\le 5021$，$1\\le a < b \\le m$。", "locale": "zh-CN"}}}
{"pid": "P3156", "type": "P", "difficulty": 1, "samples": [["10 3\n1 9 2 60 8 17 11 4 5 14\n1 5 9\n", "1\n8\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": [], "title": "【深基15.例1】询问学号", "background": "", "description": "有 $n(n \\le 2 \\times 10^6)$ 名同学陆陆续续进入教室。我们知道每名同学的学号（在 $1$ 到 $10^9$ 之间），按进教室的顺序给出。上课了，老师想知道第 $i$ 个进入教室的同学的学号是什么（最先进入教室的同学 $i=1$），询问次数不超过 $10^5$ 次。", "inputFormat": "第一行 $2$ 个整数 $n$ 和 $m$，表示学生个数和询问次数。\n\n第二行 $n$ 个整数，表示按顺序进入教室的学号。\n\n第三行 $m$ 个整数，表示询问第几个进入教室的同学。", "outputFormat": "输出 $m$ 个整数表示答案，用换行隔开。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[Shenji 15. Example 1] Query Student ID Numbers", "background": "", "description": "There are $n(n \\le 2 \\times 10^6)$ students entering the classroom one after another. We know each student’s ID number (between $1$ and $10^9$), given in the order they enter the classroom. Class starts, and the teacher wants to know what the ID number of the $i$-th student who entered the classroom is (the first student to enter has $i=1$). The number of queries does not exceed $10^5$.", "inputFormat": "The first line contains $2$ integers $n$ and $m$, representing the number of students and the number of queries.\n\nThe second line contains $n$ integers, representing the ID numbers in the order they enter the classroom.\n\nThe third line contains $m$ integers, representing queries asking for which student (by entry order) to check.", "outputFormat": "Output $m$ integers as the answers, separated by newlines.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【深基15.例1】询问学号", "background": "", "description": "有 $n(n \\le 2 \\times 10^6)$ 名同学陆陆续续进入教室。我们知道每名同学的学号（在 $1$ 到 $10^9$ 之间），按进教室的顺序给出。上课了，老师想知道第 $i$ 个进入教室的同学的学号是什么（最先进入教室的同学 $i=1$），询问次数不超过 $10^5$ 次。", "inputFormat": "第一行 $2$ 个整数 $n$ 和 $m$，表示学生个数和询问次数。\n\n第二行 $n$ 个整数，表示按顺序进入教室的学号。\n\n第三行 $m$ 个整数，表示询问第几个进入教室的同学。", "outputFormat": "输出 $m$ 个整数表示答案，用换行隔开。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3157", "type": "P", "difficulty": 6, "samples": [["5 4\n1\n5\n3\n4\n2\n5\n1\n4\n2", "5\n2\n2\n1"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2011", "重庆", "各省省选", "树状数组", "cdq 分治", "树套树", "可持久化线段树", "分块", "整体二分"], "title": "[CQOI2011] 动态逆序对", "background": "", "description": "对于序列 $a$，它的逆序对数定义为集合  \n$$\\{(i,j)| i<j \\wedge a_i > a_j \\}$$\n中的元素个数。  \n\n现在给出 $1\\sim n$ 的一个排列，按照某种顺序依次删除 $m$ 个元素，你的任务是在每次删除一个元素**之前**统计整个序列的逆序对数。\n", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，即初始元素的个数和删除的元素个数。  \n以下 $n$ 行，每行包含一个 $1 \\sim n$ 之间的正整数，即初始排列。  \n接下来 $m$ 行，每行一个正整数，依次为每次删除的元素。\n", "outputFormat": "输出包含 $m$ 行，依次为删除每个元素之前，逆序对的个数。\n", "hint": "【数据范围】   \n对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，$1\\le m \\le 50000$。\n\n【样例解释】  \n删除每个元素之前的序列依次为：  \n$$1,5,3,4,2$$  \n$$1,3,4,2$$  \n$$3,4,2$$  \n$$3,2$$  ", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2011] Dynamic Inversions", "background": "", "description": "For a sequence $a$, its number of inversions is defined as the size of the set  \n$$\\{(i,j)\\mid i<j \\wedge a_i > a_j \\}.$$\nYou are given a permutation of $1\\sim n$. According to some order, $m$ elements are deleted one by one. Your task is to count the number of inversions of the entire sequence before each deletion.", "inputFormat": "The first line contains two integers $n$ and $m$, which are the initial number of elements and the number of deletions.  \nThe next $n$ lines each contain a positive integer between $1 \\sim n$, which is the initial permutation.  \nThen the next $m$ lines each contain a positive integer, in order, which is the element to delete at each step.", "outputFormat": "Output $m$ lines, where the $i$-th line is the number of inversions before deleting the $i$-th element.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n \\le 10^5$, $1 \\le m \\le 50000$.\n\nSample Explanation  \nThe sequences before each deletion are:  \n$$1,5,3,4,2$$  \n$$1,3,4,2$$  \n$$3,4,2$$  \n$$3,2$$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2011] 动态逆序对", "background": "", "description": "对于序列 $a$，它的逆序对数定义为集合  \n$$\\{(i,j)| i<j \\wedge a_i > a_j \\}$$\n中的元素个数。  \n\n现在给出 $1\\sim n$ 的一个排列，按照某种顺序依次删除 $m$ 个元素，你的任务是在每次删除一个元素**之前**统计整个序列的逆序对数。\n", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，即初始元素的个数和删除的元素个数。  \n以下 $n$ 行，每行包含一个 $1 \\sim n$ 之间的正整数，即初始排列。  \n接下来 $m$ 行，每行一个正整数，依次为每次删除的元素。\n", "outputFormat": "输出包含 $m$ 行，依次为删除每个元素之前，逆序对的个数。\n", "hint": "【数据范围】   \n对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，$1\\le m \\le 50000$。\n\n【样例解释】  \n删除每个元素之前的序列依次为：  \n$$1,5,3,4,2$$  \n$$1,3,4,2$$  \n$$3,4,2$$  \n$$3,2$$  ", "locale": "zh-CN"}}}
{"pid": "P3158", "type": "P", "difficulty": 6, "samples": [["4 2 2\n3 1", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2011", "重庆", "各省省选", "容斥原理"], "title": "[CQOI2011] 放棋子", "background": "", "description": "在一个 $m$ 行 $n$ 列的棋盘里放一些彩色的棋子，使得每个格子最多放一个棋子，且不同颜色的棋子不能在同一行或者同一列，有多少种方法？\n\n例如，$n=m=3$，有两个白棋子和一个灰棋子，下面左边两种方法都是合法的，但右边两种都是非法的。\n\n![](https://cdn.luogu.com.cn/upload/pic/28150.png)", "inputFormat": "输入第一行为两个整数 $n,m,c$，即行数、列数和棋子的颜色数。\n\n第二行包含 $c$ 个正整数，即每个颜色的棋子数。", "outputFormat": "输出仅一行，即方案总数除以 $10^9+9$ 的余数。", "hint": "对于 $100\\%$ 的测试数据，满足 $1\\le n,m\\le 30$，$1\\le c\\le 10$，$\\texttt{总棋子数}\\le n\\times m$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2011] Placing Pieces", "background": "", "description": "On an $m$-row by $n$-column board, place some colored pieces so that each cell contains at most one piece, and pieces of different colors cannot lie in the same row or the same column. How many ways are there?\n\nFor example, when $n=m=3$, there are two white pieces and one gray piece. The two arrangements on the left below are valid, while the two on the right are invalid.\n\n![](https://cdn.luogu.com.cn/upload/pic/28150.png)", "inputFormat": "The first line contains three integers $n,m,c$, which are the numbers of rows, columns, and colors.\n\nThe second line contains $c$ positive integers, which are the number of pieces of each color.", "outputFormat": "Output a single line: the remainder when the total number of arrangements is divided by $10^9+9$.", "hint": "For $100\\%$ of the testdata, $1\\le n,m\\le 30$, $1\\le c\\le 10$, and the total number of pieces $\\le n\\times m$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2011] 放棋子", "background": "", "description": "在一个 $m$ 行 $n$ 列的棋盘里放一些彩色的棋子，使得每个格子最多放一个棋子，且不同颜色的棋子不能在同一行或者同一列，有多少种方法？\n\n例如，$n=m=3$，有两个白棋子和一个灰棋子，下面左边两种方法都是合法的，但右边两种都是非法的。\n\n![](https://cdn.luogu.com.cn/upload/pic/28150.png)", "inputFormat": "输入第一行为两个整数 $n,m,c$，即行数、列数和棋子的颜色数。\n\n第二行包含 $c$ 个正整数，即每个颜色的棋子数。", "outputFormat": "输出仅一行，即方案总数除以 $10^9+9$ 的余数。", "hint": "对于 $100\\%$ 的测试数据，满足 $1\\le n,m\\le 30$，$1\\le c\\le 10$，$\\texttt{总棋子数}\\le n\\times m$。", "locale": "zh-CN"}}}
{"pid": "P3159", "type": "P", "difficulty": 6, "samples": [["3 3\n110\n000\n001\n000\n110\n100\n222\n222\n222", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "重庆", "各省省选", "网络流", "费用流"], "title": "[CQOI2012] 交换棋子", "background": "", "description": "有一个 $n$ 行 $m$ 列的黑白棋盘，你每次可以交换两个相邻格子（**相邻是指有公共边或公共顶点**）中的棋子，最终达到目标状态。要求第 $i$ 行第 $j$ 列的格子只能参与 $m_{i,j}$ 次交换。", "inputFormat": "第一行包含两个整数 $n,m$。以下 $n$ 行为初始状态，每行为一个包含 $m$ 个字符的 $01$ 串，其中 $0$ 表示黑色棋子，$1$ 表示白色棋子。以下 $n$ 行为目标状态，格式同初始状态。以下 $n$ 行每行为一个包含 $m$ 个 $0\\sim9$ 数字的字符串，表示每个格子参与交换的次数上限。\n", "outputFormat": "输出仅一行，为最小交换总次数。如果无解，输出 $-1$。", "hint": "### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1\\leq n,m\\leq20$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2012] Swap Pieces", "background": "", "description": "There is a black-and-white board with $n$ rows and $m$ columns. Each time, you may swap the pieces in two adjacent cells (**adjacent means sharing an edge or a vertex**) to reach a target state. The cell at row $i$, column $j$ may participate in at most $m_{i,j}$ swaps.", "inputFormat": "The first line contains two integers $n, m$.  \nThe next $n$ lines describe the initial state; each line is a binary string of length $m$, where $0$ denotes a black piece and $1$ denotes a white piece.  \nThe next $n$ lines describe the target state in the same format as the initial state.  \nThe next $n$ lines each contain a string of $m$ digits from '0' to '9', representing the upper bound on the number of times each cell may participate in swaps.", "outputFormat": "Output a single line with the minimum total number of swaps. If there is no solution, output $-1$.", "hint": "### Constraints\n\nFor $100\\%$ of the testdata, $1 \\le n, m \\le 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2012] 交换棋子", "background": "", "description": "有一个 $n$ 行 $m$ 列的黑白棋盘，你每次可以交换两个相邻格子（**相邻是指有公共边或公共顶点**）中的棋子，最终达到目标状态。要求第 $i$ 行第 $j$ 列的格子只能参与 $m_{i,j}$ 次交换。", "inputFormat": "第一行包含两个整数 $n,m$。以下 $n$ 行为初始状态，每行为一个包含 $m$ 个字符的 $01$ 串，其中 $0$ 表示黑色棋子，$1$ 表示白色棋子。以下 $n$ 行为目标状态，格式同初始状态。以下 $n$ 行每行为一个包含 $m$ 个 $0\\sim9$ 数字的字符串，表示每个格子参与交换的次数上限。\n", "outputFormat": "输出仅一行，为最小交换总次数。如果无解，输出 $-1$。", "hint": "### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1\\leq n,m\\leq20$。", "locale": "zh-CN"}}}
{"pid": "P3160", "type": "P", "difficulty": 6, "samples": [["3 2\nX.\n..\n.X", "60"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2012", "重庆", "各省省选", "容斥原理", "状压 DP"], "title": "[CQOI2012] 局部极小值", "background": "", "description": "有一个 $n$ 行 $m$ 列的整数矩阵，其中 $1$ 到 $n\\times m$ 之间的每个整数恰好出现一次。\n\n如果一个格子比所有相邻格子（相邻是指有公共边或公共顶点）都小，我们说这个格子是局部极小值。给出所有局部极小值的位置，你的任务是判断有多少个可能的矩阵。\n\n答案对 $12{,}345{,}678$ 取模。", "inputFormat": "输入第一行包含两个整数 $n$ 和 $m$，即行数和列数。\n\n以下 $n$ 行每行 $m$ 个字符，第 $(i + 1)$ 行的第 $j$ 个字符代表第 $i$ 列的第 $j$ 个格子是否是局部极小值，该字符只可能是 `X` 或 `.`，其中 `X` 表示局部极小值，`.` 表示非局部极小值。", "outputFormat": "输出仅一行，为可能的矩阵总数除以 $12345678$ 的余数。", "hint": "#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，保证 $1\\le n\\le4$，$1\\le m\\le7$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2012] Local Minima", "background": "", "description": "There is an $n$ by $m$ integer matrix in which each integer between $1$ and $n \\times m$ appears exactly once.\n\nIf a cell is smaller than all of its adjacent cells (adjacent means sharing a side or a vertex), we say this cell is a local minimum. Given the positions of all local minima, your task is to determine how many matrices are possible.\n\nOutput the answer modulo $12{,}345{,}678$.", "inputFormat": "The first line contains two integers $n$ and $m$, the number of rows and columns.\n\nEach of the next $n$ lines contains $m$ characters. For each $i$ from $1$ to $n$, the $ (i + 1) $-th line’s $j$-th character represents whether the cell at row $i$ and column $j$ is a local minimum. Each character is either `X` or `.`, where `X` denotes a local minimum and `.` denotes a non-local minimum.", "outputFormat": "Output a single line containing the number of possible matrices modulo $12{,}345{,}678$.", "hint": "- Constraints  \n  - For $100\\%$ of the testdata, $1 \\le n \\le 4$, $1 \\le m \\le 7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2012] 局部极小值", "background": "", "description": "有一个 $n$ 行 $m$ 列的整数矩阵，其中 $1$ 到 $n\\times m$ 之间的每个整数恰好出现一次。\n\n如果一个格子比所有相邻格子（相邻是指有公共边或公共顶点）都小，我们说这个格子是局部极小值。给出所有局部极小值的位置，你的任务是判断有多少个可能的矩阵。\n\n答案对 $12{,}345{,}678$ 取模。", "inputFormat": "输入第一行包含两个整数 $n$ 和 $m$，即行数和列数。\n\n以下 $n$ 行每行 $m$ 个字符，第 $(i + 1)$ 行的第 $j$ 个字符代表第 $i$ 列的第 $j$ 个格子是否是局部极小值，该字符只可能是 `X` 或 `.`，其中 `X` 表示局部极小值，`.` 表示非局部极小值。", "outputFormat": "输出仅一行，为可能的矩阵总数除以 $12345678$ 的余数。", "hint": "#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，保证 $1\\le n\\le4$，$1\\le m\\le7$。", "locale": "zh-CN"}}}
{"pid": "P3161", "type": "P", "difficulty": 6, "samples": [["2\n5 1 8\n7 15 3", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心", "2012", "重庆", "各省省选"], "title": "[CQOI2012] 模拟工厂", "background": "", "description": "有一个称为“模拟工厂”的游戏是这样的：在时刻 $0$，工厂的生产力等于 $1$。在每个时刻，你可以提高生产力或者生产商品。如果选择提高生产力，在下一个时刻时工厂的生产力加 $1$；如果选择生产商品，则下一个时刻你所拥有的商品数量增加 $p$，其中 $p$ 是本时刻工厂的生产力。  \n\n有 $n$ 个订单，可以选择接受或者不接受。第 $i$ 个订单 $(t_i, g_i, m_i)$ 要求在时刻 $t_i$ 给买家提供 $g_i$ 个商品，事成之后商品数量减少 $g_i$，而收入增加 $m_i$ 元。如果接受订单 $i$，则必须恰好在时刻 $t_i$ 交易，不能早也不能晚。同一时刻可以接受多个订单，但每个订单只能被接受一次。要求最后的总收入最大。  \n\n例如，如果一共有两个订单 $(5,1,8)$ 和 $(7,15,3)$，用如下策略是最优的：时刻 $0$, $1$, $2$ 提高生产力（时刻 $3$ 的生产力为 $4$），然后在时刻 $3$，$4$ 生产商品，则在时刻 $5$ 时将拥有 $8$ 个商品。此时接受第 $1$ 个订单（还会剩下 $7$ 个商品），并且在时刻 $5$，$6$ 继续生产商品，则在时刻 $7$ 时拥有 $7+4+4=15$ 个商品，正好满足订单 $2$。", "inputFormat": "输入第一行包含一个整数 $n$，即订单数目。以下 $n$ 行每行三个整数 $t_i, g_i, m_i$。", "outputFormat": "输出仅一行，为最大总收入。输出保证在 $32$ 位带符号整数范围内。", "hint": "**【数据范围】**\n\n| 编号 | $n \\le$ | $t_i \\le$ | $g_i \\le$ | $m_i \\le$ |\n|:-:|:-:|:-:|:-:|:-:|\n| $1 \\sim 3$ | $5$ | $100$ | $10000$ | $10000$ |\n| $4 \\sim 6$ | $10$ | $100$ | $10000$ | $10000$ |\n| $7 \\sim 10$ | $15$ | $100000$ | $10^9$ | $10^9$ |", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2012] Simulated Factory", "background": "", "description": "There is a game called “Simulated Factory” as follows: at time $0$, the factory’s productivity equals $1$. At each time, you may either increase productivity or produce goods. If you choose to increase productivity, then at the next time the factory’s productivity increases by $1$; if you choose to produce goods, then at the next time your number of goods increases by $p$, where $p$ is the factory’s productivity at the current time.\n\nThere are $n$ orders, and you may choose to accept or reject each one. The $i$-th order $(t_i, g_i, m_i)$ requires delivering $g_i$ goods to the buyer at time $t_i$. After completion, your goods decrease by $g_i$, and your revenue increases by $m_i$ yuan. If you accept order $i$, you must transact exactly at time $t_i$, neither earlier nor later. Multiple orders may be accepted at the same time, but each order can be accepted at most once. Maximize the final total revenue.\n\nFor example, if there are two orders $(5,1,8)$ and $(7,15,3)$, the following strategy is optimal: at times $0$, $1$, $2$ increase productivity (so the productivity at time $3$ is $4$), then at times $3$ and $4$ produce goods; at time $5$ you will have $8$ goods. Accept order $1$ at this time (you will still have $7$ goods left), and continue producing goods at times $5$ and $6$; then at time $7$ you will have $7+4+4=15$ goods, exactly meeting order $2$.", "inputFormat": "The first line contains an integer $n$, the number of orders. Each of the following $n$ lines contains three integers $t_i, g_i, m_i$.", "outputFormat": "Output a single line with the maximum total revenue. The answer is guaranteed to fit in the 32-bit signed integer range.", "hint": "Constraints\n\n| Index | $n \\le$ | $t_i \\le$ | $g_i \\le$ | $m_i \\le$ |\n|:-:|:-:|:-:|:-:|:-:|\n| $1 \\sim 3$ | $5$ | $100$ | $10000$ | $10000$ |\n| $4 \\sim 6$ | $10$ | $100$ | $10000$ | $10000$ |\n| $7 \\sim 10$ | $15$ | $100000$ | $10^9$ | $10^9$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2012] 模拟工厂", "background": "", "description": "有一个称为“模拟工厂”的游戏是这样的：在时刻 $0$，工厂的生产力等于 $1$。在每个时刻，你可以提高生产力或者生产商品。如果选择提高生产力，在下一个时刻时工厂的生产力加 $1$；如果选择生产商品，则下一个时刻你所拥有的商品数量增加 $p$，其中 $p$ 是本时刻工厂的生产力。  \n\n有 $n$ 个订单，可以选择接受或者不接受。第 $i$ 个订单 $(t_i, g_i, m_i)$ 要求在时刻 $t_i$ 给买家提供 $g_i$ 个商品，事成之后商品数量减少 $g_i$，而收入增加 $m_i$ 元。如果接受订单 $i$，则必须恰好在时刻 $t_i$ 交易，不能早也不能晚。同一时刻可以接受多个订单，但每个订单只能被接受一次。要求最后的总收入最大。  \n\n例如，如果一共有两个订单 $(5,1,8)$ 和 $(7,15,3)$，用如下策略是最优的：时刻 $0$, $1$, $2$ 提高生产力（时刻 $3$ 的生产力为 $4$），然后在时刻 $3$，$4$ 生产商品，则在时刻 $5$ 时将拥有 $8$ 个商品。此时接受第 $1$ 个订单（还会剩下 $7$ 个商品），并且在时刻 $5$，$6$ 继续生产商品，则在时刻 $7$ 时拥有 $7+4+4=15$ 个商品，正好满足订单 $2$。", "inputFormat": "输入第一行包含一个整数 $n$，即订单数目。以下 $n$ 行每行三个整数 $t_i, g_i, m_i$。", "outputFormat": "输出仅一行，为最大总收入。输出保证在 $32$ 位带符号整数范围内。", "hint": "**【数据范围】**\n\n| 编号 | $n \\le$ | $t_i \\le$ | $g_i \\le$ | $m_i \\le$ |\n|:-:|:-:|:-:|:-:|:-:|\n| $1 \\sim 3$ | $5$ | $100$ | $10000$ | $10000$ |\n| $4 \\sim 6$ | $10$ | $100$ | $10000$ | $10000$ |\n| $7 \\sim 10$ | $15$ | $100000$ | $10^9$ | $10^9$ |", "locale": "zh-CN"}}}
{"pid": "P3162", "type": "P", "difficulty": 6, "samples": [["3 5\n-1 3\n0 1\n2 3\n4 2\n5 2", "2.0000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "贪心", "2012", "重庆", "各省省选", "排序"], "title": "[CQOI2012] 组装", "background": "", "description": "数轴上有 $m$ 个生产车间可以生产零件。一共有 $n$ 种零件，编号为 $1\\sim n$。第 $i$ 个车间的坐标为 $x_i$ ，生产第 $p_i$ 种零件（$1\\le p_i\\le n$）。你需要在数轴上的某个位置修建一个组装车间，把这些零件组装起来。为了节约运输成本，你需要最小化 $cost_1+cost_2+\\ldots+cost_n$，其中 $cost_x$ 表示生产第 $x$ 种零件的车间中，到组装车间距离的平方的最小值。", "inputFormat": "输入第一行为两个整数 $n$, $m$ ，即零件的种类数和生产车间的个数。以下 $m$ 行每行两个整数 $x_i$ 和 $p_i$（$1\\le p_i\\le n$）。输入按照生产车间从左到右的顺序排列（即 $x_i\\le x_{i+1}$ 。注意车间位置可以重复）。输入保证每种零件都有车间生产。", "outputFormat": "输出仅一行，即组装车间的最优位置（可以和某个生产车间重合），四舍五入保留四位小数。输入保证最优位置惟一。\n", "hint": "- 测试点 $1 \\sim 4$，满足 $n\\le 15$，$m\\le 25$，$x_i\\le100$；\n- 测试点 $5 \\sim 10$，满足 $n\\le 10^4,m\\le 10^5,x_i\\le10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2012] Assembly", "background": "", "description": "There are $m$ production workshops on the number line that can produce parts. There are $n$ types of parts, numbered $1 \\sim n$. The $i$-th workshop is located at coordinate $x_i$ and produces part type $p_i$ ($1 \\le p_i \\le n$). You need to build an assembly workshop at some position on the number line to assemble these parts. To minimize transportation cost, you need to minimize $\\,$ $cost_1 + cost_2 + \\ldots + cost_n$, where $cost_x$ denotes the minimum squared distance from the assembly workshop to any workshop that produces part type $x$.", "inputFormat": "The first line contains two integers $n$, $m$, the number of part types and the number of production workshops. Each of the following $m$ lines contains two integers $x_i$ and $p_i$ ($1 \\le p_i \\le n$). The input is ordered from left to right by workshop position (i.e., $x_i \\le x_{i+1}$; note that positions may repeat). It is guaranteed that every part type has at least one workshop producing it.", "outputFormat": "Output a single line: the optimal location of the assembly workshop (it may coincide with a production workshop), rounded to four decimal places. It is guaranteed that the optimal location is unique.", "hint": "- Test points 1–4: $n \\le 15$, $m \\le 25$, $x_i \\le 100$.\n- Test points 5–10: $n \\le 10^4$, $m \\le 10^5$, $x_i \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2012] 组装", "background": "", "description": "数轴上有 $m$ 个生产车间可以生产零件。一共有 $n$ 种零件，编号为 $1\\sim n$。第 $i$ 个车间的坐标为 $x_i$ ，生产第 $p_i$ 种零件（$1\\le p_i\\le n$）。你需要在数轴上的某个位置修建一个组装车间，把这些零件组装起来。为了节约运输成本，你需要最小化 $cost_1+cost_2+\\ldots+cost_n$，其中 $cost_x$ 表示生产第 $x$ 种零件的车间中，到组装车间距离的平方的最小值。", "inputFormat": "输入第一行为两个整数 $n$, $m$ ，即零件的种类数和生产车间的个数。以下 $m$ 行每行两个整数 $x_i$ 和 $p_i$（$1\\le p_i\\le n$）。输入按照生产车间从左到右的顺序排列（即 $x_i\\le x_{i+1}$ 。注意车间位置可以重复）。输入保证每种零件都有车间生产。", "outputFormat": "输出仅一行，即组装车间的最优位置（可以和某个生产车间重合），四舍五入保留四位小数。输入保证最优位置惟一。\n", "hint": "- 测试点 $1 \\sim 4$，满足 $n\\le 15$，$m\\le 25$，$x_i\\le100$；\n- 测试点 $5 \\sim 10$，满足 $n\\le 10^4,m\\le 10^5,x_i\\le10^5$。", "locale": "zh-CN"}}}
{"pid": "P3163", "type": "P", "difficulty": 6, "samples": [["4 0 1 1 2 3 1\nXOXX\nOXOX\nXOXO\nXXOX\n4 0 2 1 1 3 2\nXNXO\nNXOX\nXOXO\nOXOX\n", "Yes\nNo\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "重庆", "各省省选", "网络流"], "title": "[CQOI2014] 危桥", "background": "", "description": "Alice 和 Bob 居住在一个由 $N$ 座岛屿组成的国家，岛屿被编号为 $0$ 到 $N-1$。某些岛屿之间有桥相连，桥上的道路是双向的，但一次只能供一人通行。其中一些桥由于年久失修成为危桥，最多只能通行两次。\n\nAlice 希望在岛屿 $a_1$ 和 $a_2$ 之间往返 $a_n$ 次（从 $a1$ 到 $a2$ 再从 $a2$ 到 $a1$ 算一次往返）。同时，Bob 希望在岛屿 $b_1$ 和 $b_2$ 之间往返 $b_n$ 次。这个过程中，所有危桥最多通行两次，其余的桥可以无限次通行。请问 Alice 和 Bob 能完成他们的愿望吗？\n", "inputFormat": "本题有多组测试数据。\n\n每组数据第一行包含七个空格隔开的整数，分别为$N$、$a_1$、$a_2$、$a_n$、$b_1$、$b_2$、$b_n$。  \n接下来是一个 $N$ 行 $N$ 列的对称矩阵，由大写字母组成。矩阵的 $i$ 行 $j$ 列描述编号 $i-1$ 和 $j-1$ 的岛屿间的连接情况，若为 “`O`” 则表示有危桥相连：为 “`N`” 表示有普通的桥相连：为 “`X`” 表示没有桥相连。", "outputFormat": "对于每组测试数据输出一行，如果他们都能完成愿望输出 “Yes”，否则输出 “No”（不含引号）。\n", "hint": "对于所有数据，$4 \\leq N\\leq 50,\\ 0 \\leq a_1, a_2, b_1, b_2 \\leq N-1,\\ 1 \\leq a_n, b_n \\leq 50$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2014] Dangerous Bridges", "background": "", "description": "Alice and Bob live in a country consisting of $N$ islands, numbered from $0$ to $N-1$. Some pairs of islands are connected by bridges. The roads on the bridges are bidirectional, but only one person can pass at a time. Some bridges have become dangerous due to age and can be used at most twice.\n\nAlice wants to make $a_n$ round trips between islands $a_1$ and $a_2$ (a round trip means going from $a_1$ to $a_2$ and then back from $a_2$ to $a_1$). Meanwhile, Bob wants to make $b_n$ round trips between islands $b_1$ and $b_2$. During the whole process, each dangerous bridge can be used at most twice in total, while the other bridges can be used infinitely many times. Can Alice and Bob fulfill their wishes?", "inputFormat": "There are multiple test cases.\n\nFor each test case, the first line contains seven space-separated integers: $N$, $a_1$, $a_2$, $a_n$, $b_1$, $b_2$, $b_n$.  \nThen follows an $N$-by-$N$ symmetric matrix of uppercase letters. The entry at row $i$ and column $j$ describes the connection between islands numbered $i-1$ and $j-1$: if it is `O`, there is a dangerous bridge; if it is `N`, there is a normal bridge; if it is `X`, there is no bridge.", "outputFormat": "For each test case, output one line. Output “Yes” if they can both fulfill their wishes, otherwise output “No” (without quotes).", "hint": "Constraints: For all testdata, $4 \\leq N \\leq 50$, $0 \\leq a_1, a_2, b_1, b_2 \\leq N-1$, $1 \\leq a_n, b_n \\leq 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2014] 危桥", "background": "", "description": "Alice 和 Bob 居住在一个由 $N$ 座岛屿组成的国家，岛屿被编号为 $0$ 到 $N-1$。某些岛屿之间有桥相连，桥上的道路是双向的，但一次只能供一人通行。其中一些桥由于年久失修成为危桥，最多只能通行两次。\n\nAlice 希望在岛屿 $a_1$ 和 $a_2$ 之间往返 $a_n$ 次（从 $a1$ 到 $a2$ 再从 $a2$ 到 $a1$ 算一次往返）。同时，Bob 希望在岛屿 $b_1$ 和 $b_2$ 之间往返 $b_n$ 次。这个过程中，所有危桥最多通行两次，其余的桥可以无限次通行。请问 Alice 和 Bob 能完成他们的愿望吗？\n", "inputFormat": "本题有多组测试数据。\n\n每组数据第一行包含七个空格隔开的整数，分别为$N$、$a_1$、$a_2$、$a_n$、$b_1$、$b_2$、$b_n$。  \n接下来是一个 $N$ 行 $N$ 列的对称矩阵，由大写字母组成。矩阵的 $i$ 行 $j$ 列描述编号 $i-1$ 和 $j-1$ 的岛屿间的连接情况，若为 “`O`” 则表示有危桥相连：为 “`N`” 表示有普通的桥相连：为 “`X`” 表示没有桥相连。", "outputFormat": "对于每组测试数据输出一行，如果他们都能完成愿望输出 “Yes”，否则输出 “No”（不含引号）。\n", "hint": "对于所有数据，$4 \\leq N\\leq 50,\\ 0 \\leq a_1, a_2, b_1, b_2 \\leq N-1,\\ 1 \\leq a_n, b_n \\leq 50$。", "locale": "zh-CN"}}}
{"pid": "P3164", "type": "P", "difficulty": 6, "samples": [["4 4", "0 1 0 0\n1 1 1 0\n0 0 0 1\n1 1 0 1\n\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "重庆", "各省省选", "Special Judge", "高斯消元"], "title": "[CQOI2014] 和谐矩阵", "background": "", "description": "我们称一个由 $0$ 和 $1$ 组成的矩阵是和谐的，当且仅当每个元素都有偶数个相邻的 $1$。一个元素相邻的元素包括它本身，及他上下左右的 $4$ 个元素（如果存在）。给定矩阵的行数和列数，请计算并输出一个和谐的矩阵。注意：所有元素为 $0$ 的矩阵是不允许的。\n", "inputFormat": "输入一行，包含两个空格分隔的整数 $m$ 和 $n$，分别表示矩阵的行数和列数。\n", "outputFormat": "输出包含 $m$ 行，每行 $n$ 个空格分隔整数（$0$ 或 $1$），为所求矩阵。测试数据保证有解。\n", "hint": "数据范围\n\n$1\\le n,m\\le 40$。\n\n感谢@miaomiao 提供spj。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2014] Harmonious Matrix", "background": "", "description": "We call a matrix composed of $0$ and $1$ harmonious if and only if every element has an even number of adjacent $1$'s. The neighbors of an element include the element itself and its four neighbors above, below, left, and right (if they exist). Given the number of rows and columns of the matrix, compute and output a harmonious matrix. Note: the all-zero matrix is not allowed.", "inputFormat": "The input consists of one line containing two space-separated integers $m$ and $n$, denoting the number of rows and columns of the matrix.", "outputFormat": "Output $m$ lines, each containing $n$ space-separated integers ($0$ or $1$), forming the required matrix. The testdata guarantees that a solution exists.", "hint": "Constraints\n\n$1\\le n,m\\le 40$.\n\nThanks to @miaomiao for providing the SPJ.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2014] 和谐矩阵", "background": "", "description": "我们称一个由 $0$ 和 $1$ 组成的矩阵是和谐的，当且仅当每个元素都有偶数个相邻的 $1$。一个元素相邻的元素包括它本身，及他上下左右的 $4$ 个元素（如果存在）。给定矩阵的行数和列数，请计算并输出一个和谐的矩阵。注意：所有元素为 $0$ 的矩阵是不允许的。\n", "inputFormat": "输入一行，包含两个空格分隔的整数 $m$ 和 $n$，分别表示矩阵的行数和列数。\n", "outputFormat": "输出包含 $m$ 行，每行 $n$ 个空格分隔整数（$0$ 或 $1$），为所求矩阵。测试数据保证有解。\n", "hint": "数据范围\n\n$1\\le n,m\\le 40$。\n\n感谢@miaomiao 提供spj。\n", "locale": "zh-CN"}}}
{"pid": "P3165", "type": "P", "difficulty": 6, "samples": [["6\n3 4 5 1 6 2", "4 6 4 5 6 6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "重庆", "各省省选", "平衡树"], "title": "[CQOI2014] 排序机械臂", "background": null, "description": "为了把工厂中高低不等的物品按从低到高排好序，工程师发明了一种排序机械臂。它遵循一个简单的排序规则，第一次操作找到高度最低的物品的位置 $P_1$，并把左起第一个物品至 $P_1$ 间的物品 (即区间 $[1,P_1]$ 间的物品) 反序；第二次找到第二低的物品的位置 $P_2$，并把左起第二个至 $P_2$ 间的物品 (即区间 $[2,P_2]$ 间的物品) 反序……最终所有的物品都会被排好序。\n\n![样例说明](https://cdn.luogu.com.cn/upload/pic/15642.png)\n\n上图给出有六个物品的示例，第一次操作前，高度最低的物品在位置 $4$，于是把第一至第四的物品反序；第二次操作前，第二低的物品在位罝六，于是把第二至六的物品反序……\n\n你的任务便是编写一个程序，确定一个操作序列，即每次操作前第 $i$ 低的物品所在位置 $P_i$，以便机械臂工作。需要注意的是，如果有高度相同的物品，必须保证排序后它们的相对位置关系与初始时相同。", "inputFormat": "第一行包含正整数 $n$，表示需要排序的物品数量。\n\n第二行包含 $n$ 个空格分隔的整数 $P_i$，表示每个物品的高度。", "outputFormat": "输出一行包含 $n$ 个空格分隔的整数 $P_i$。", "hint": "$N \\le 100000$\n\n$P_i \\le 10^7$", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2014] Sorting Robotic Arm", "background": "", "description": "To sort items of varying heights in nondecreasing order, engineers invented a sorting robotic arm. It follows a simple rule: in the first operation, find the position $P_1$ of the lowest item and reverse the items from the first item from the left up to $P_1$ (i.e., reverse the subarray $[1, P_1]$); in the second operation, find the position $P_2$ of the second lowest item and reverse the items from the second item from the left up to $P_2$ (i.e., reverse the subarray $[2, P_2]$); and so on. Eventually, all items will be sorted.\n\n![样例说明](https://cdn.luogu.com.cn/upload/pic/15642.png)\n\nThe figure above shows an example with six items. Before the first operation, the lowest item is at position $4$, so the first through fourth items are reversed. Before the second operation, the second lowest item is at position $6$, so the second through sixth items are reversed.\n\nYour task is to write a program to determine the sequence of operations, namely, the position $P_i$ of the $i$-th lowest item before each operation, so the robotic arm can execute them. Note that if there are items with equal height, their relative order must remain the same after sorting.", "inputFormat": "The first line contains a positive integer $n$, the number of items to sort.\n\nThe second line contains $n$ space-separated integers $P_i$, the height of each item.", "outputFormat": "Output one line containing $n$ space-separated integers $P_i$.", "hint": "$N \\le 100000$\n\n$P_i \\le 10^7$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2014] 排序机械臂", "background": null, "description": "为了把工厂中高低不等的物品按从低到高排好序，工程师发明了一种排序机械臂。它遵循一个简单的排序规则，第一次操作找到高度最低的物品的位置 $P_1$，并把左起第一个物品至 $P_1$ 间的物品 (即区间 $[1,P_1]$ 间的物品) 反序；第二次找到第二低的物品的位置 $P_2$，并把左起第二个至 $P_2$ 间的物品 (即区间 $[2,P_2]$ 间的物品) 反序……最终所有的物品都会被排好序。\n\n![样例说明](https://cdn.luogu.com.cn/upload/pic/15642.png)\n\n上图给出有六个物品的示例，第一次操作前，高度最低的物品在位置 $4$，于是把第一至第四的物品反序；第二次操作前，第二低的物品在位罝六，于是把第二至六的物品反序……\n\n你的任务便是编写一个程序，确定一个操作序列，即每次操作前第 $i$ 低的物品所在位置 $P_i$，以便机械臂工作。需要注意的是，如果有高度相同的物品，必须保证排序后它们的相对位置关系与初始时相同。", "inputFormat": "第一行包含正整数 $n$，表示需要排序的物品数量。\n\n第二行包含 $n$ 个空格分隔的整数 $P_i$，表示每个物品的高度。", "outputFormat": "输出一行包含 $n$ 个空格分隔的整数 $P_i$。", "hint": "$N \\le 100000$\n\n$P_i \\le 10^7$", "locale": "zh-CN"}}}
{"pid": "P3166", "type": "P", "difficulty": 4, "samples": [["2 2", "76"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2014", "重庆", "各省省选", "最大公约数 gcd", "排列组合"], "title": "[CQOI2014] 数三角形", "background": "", "description": "给定一个 $N\\times M$ 的网格，请计算三点都在格点上的三角形共有多少个。注意三角形的三点不能共线。", "inputFormat": "输入一行，包含两个空格分隔的正整数 $M$ 和 $N$。", "outputFormat": "输出一个正整数，为所求三角形数量。\n", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1\\le N,M\\le1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2014] Counting Triangles", "background": "", "description": "Given an $N \\times M$ grid, compute how many triangles have all three vertices at grid points. Note that the three points of a triangle must not be collinear.", "inputFormat": "The input consists of one line containing two space-separated positive integers $M$ and $N$.", "outputFormat": "Output a single positive integer, which is the number of such triangles.", "hint": "Constraints\n\nFor all test points, $1 \\le N, M \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2014] 数三角形", "background": "", "description": "给定一个 $N\\times M$ 的网格，请计算三点都在格点上的三角形共有多少个。注意三角形的三点不能共线。", "inputFormat": "输入一行，包含两个空格分隔的正整数 $M$ 和 $N$。", "outputFormat": "输出一个正整数，为所求三角形数量。\n", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1\\le N,M\\le1000$。", "locale": "zh-CN"}}}
{"pid": "P3167", "type": "P", "difficulty": 5, "samples": [["*aca?ctc\n6\nacaacatctc\nacatctc\naacacatctc\naggggcaacacctc\naggggcaacatctc\naggggcaacctct", "YES\r\nYES\r\nYES\r\nYES\r\nYES\r\nNO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2014", "重庆", "各省省选", "哈希 hashing", "AC 自动机"], "title": "[CQOI2014] 通配符匹配", "background": null, "description": "几乎所有操作系统的命令行界面（CLI）中都支持文件名的通配符匹配以方便用户。最常见的通配符有两个，一个是星号（```*```），可以匹配 0 个及以上的任意字符；另一个是问号（```?```），可以匹配恰好一个任意字符。现在需要你编写一个程序，对于给定的文件名列表和一个包含通配符的字符串，判断哪些文件可以被匹配。", "inputFormat": "第一行是一个由小写字母和上述通配符组成的字符串。第二行包含一个整数 $n$，表示文件个数。接下来 $n$ 行，每行为一个仅包含小写字母字符串，表示文件名列表。", "outputFormat": "输出 $n$ 行，每行为 ``YES`` 或 ``NO``，表示对应文件能否被通配符匹配。", "hint": "对于 $100 \\%$ 的数据\n\n- 字符串长度不超过 $100000$\n- $1 \\le n \\le 100$\n- 通配符个数不超过 $10$", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2014] Wildcard Matching", "background": "", "description": "Almost all operating systems' command-line interfaces (CLI) support wildcard matching for filenames to help users. The two most common wildcards are: an asterisk (```*```), which matches any sequence of characters of length 0 or more; and a question mark (```?```), which matches exactly one arbitrary character. You are to write a program that, given a list of filenames and a pattern string containing wildcards, determines which files can be matched.", "inputFormat": "The first line is a string consisting of lowercase letters and the above wildcards. The second line contains an integer $n$, indicating the number of files. The next $n$ lines each contain a string consisting only of lowercase letters, representing the list of filenames.", "outputFormat": "Output $n$ lines, each being ``YES`` or ``NO``, indicating whether the corresponding file can be matched by the pattern.", "hint": "For $100 \\%$ of the testdata:\n\n- String length does not exceed 100000.\n- $1 \\le n \\le 100$.\n- The number of wildcards does not exceed 10.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2014] 通配符匹配", "background": null, "description": "几乎所有操作系统的命令行界面（CLI）中都支持文件名的通配符匹配以方便用户。最常见的通配符有两个，一个是星号（```*```），可以匹配 0 个及以上的任意字符；另一个是问号（```?```），可以匹配恰好一个任意字符。现在需要你编写一个程序，对于给定的文件名列表和一个包含通配符的字符串，判断哪些文件可以被匹配。", "inputFormat": "第一行是一个由小写字母和上述通配符组成的字符串。第二行包含一个整数 $n$，表示文件个数。接下来 $n$ 行，每行为一个仅包含小写字母字符串，表示文件名列表。", "outputFormat": "输出 $n$ 行，每行为 ``YES`` 或 ``NO``，表示对应文件能否被通配符匹配。", "hint": "对于 $100 \\%$ 的数据\n\n- 字符串长度不超过 $100000$\n- $1 \\le n \\le 100$\n- 通配符个数不超过 $10$", "locale": "zh-CN"}}}
{"pid": "P3168", "type": "P", "difficulty": 5, "samples": [["4 3\n1 2 6\n2 3 3\n1 3 2\n3 3 4\n3 1 3 2\n1 1 3 4\n2 2 4 3", "2\n8\n11"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2015", "重庆", "线段树", "各省省选", "可持久化线段树", "可持久化"], "title": "[CQOI2015] 任务查询系统", "background": "", "description": "最近实验室正在为其管理的超级计算机编制一套任务管理系统，而你被安排完成其中的查询部分。  \n\n超级计算机中的任务用三元组 $(s_i, e_i, p_i)$ 描述，$(s_i, e_i, p_i)$ 表示任务从第 $s_i$ 秒开始，在第 $e_i$ 秒后结束（第 $s_i$ 秒和 $e_i$ 秒任务也在运行），其优先级为 $p_i$。同一时间可能有多个任务同时执行，它们的优先级可能相同，也可能不同。  \n\n调度系统会经常向查询系统询问，第 $x_i$ 秒正在运行的任务中，优先级最小的 $k_i$ 个任务（即将任务按照优先级从小到大排序后取前 $k_i$ 个）的优先级之和是多少。  \n\n特别的，如果 $k_i$ 大于第 $x_i$ 秒正在运行的任务总数，则直接回答第 $x_i$ 秒正在运行的任务优先级之和。上述所有参数均为整数，时间的范围在 $[1, n]$ 之间。\n", "inputFormat": "输入文件第一行包含两个空格分开的正整数 $m$ 和 $n$，分别表示任务总数和时间范围。  \n\n接下来 $m$ 行，每行包含三个空格分开的正整数 $s_i,e_i,p_i$（$s_i \\le e_i$），描述一个任务。  \n\n接下来 $n$ 行，每行包含四个空格分开的整数 $x_i,a_i,b_i,c_i$，描述一次查询。  \n\n**本题强制在线**。查询的参数 $k_i$ 需要由公式 $k_i = 1 +(a_i \\times \\text{pre}+b_i) \\bmod c_i$ 计算得到。其中 $\\text{pre}$ 表示上一次查询的结果，定义初始 $\\text{pre} = 1$ 。\n", "outputFormat": "输出共 $n$ 行，每行一个整数，表示查询结果。\n", "hint": "【样例解释】\n\n$k_1 = (1\\times 1 + 3)\\bmod 2 + 1 = 1$；\n\n$k_2 = (1\\times 2+3)\\bmod 4 + 1 = 2$；\n\n$k_3 = (2 \\times 8+4)\\bmod 3+1 = 3$。\n\n【数据范围】\n \n对于 $100\\%$ 的数据，$1\\le m,n,c_i \\le 10 ^ 5$，$0 \\le a _ i, b _ i \\le 10 ^ 5$，$1\\leq s_i\\leq e_i\\leq n$，$1\\le p_i \\le 10^7$，$x_i$ 为 $1$ 到 $n$ 的一个排列。\n\n\n注：2024-12-28 加入一个 hack 数据，[帖子链接](https://www.luogu.com.cn/discuss/1025247)。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2015] Task Query System", "background": "", "description": "The laboratory is building a task management system for its supercomputer, and you are assigned to implement the query component.\n\nEach task in the supercomputer is described by a triple $(s_i, e_i, p_i)$, meaning it runs from second $s_i$ through second $e_i$ inclusive (the task is running at both second $s_i$ and second $e_i$), and its priority is $p_i$. Multiple tasks may run at the same time, and their priorities may be the same or different.\n\nThe scheduler frequently asks the query system: among the tasks running at second $x_i$, what is the sum of priorities of the smallest $k_i$ tasks (i.e., sort tasks by priority in ascending order and take the first $k_i$)?\n\nIn particular, if $k_i$ is larger than the number of tasks running at second $x_i$, return the sum of priorities of all tasks running at second $x_i$. All parameters are integers, and the time range is within $[1, n]$.", "inputFormat": "The first line contains two space-separated positive integers $m$ and $n$, the number of tasks and the time range, respectively.\n\nThe next $m$ lines each contain three space-separated positive integers $s_i, e_i, p_i$ ($s_i \\le e_i$), describing one task.\n\nThe next $n$ lines each contain four space-separated integers $x_i, a_i, b_i, c_i$, describing one query.\n\nThis problem is online. The parameter $k_i$ is computed by $k_i = 1 + (a_i \\times \\text{pre} + b_i) \\bmod c_i$, where $\\text{pre}$ denotes the previous query’s result, with initial $\\text{pre} = 1$.", "outputFormat": "Output $n$ lines, each containing one integer, the result of each query.", "hint": "[Sample explanation]\n\n$k_1 = (1\\times 1 + 3)\\bmod 2 + 1 = 1$.\n\n$k_2 = (1\\times 2+3)\\bmod 4 + 1 = 2$.\n\n$k_3 = (2 \\times 8+4)\\bmod 3+1 = 3$.\n\nConstraints\n\nFor $100\\%$ of the testdata, $1 \\le m, n, c_i \\le 10^5$, $0 \\le a_i, b_i \\le 10^5$, $1 \\le s_i \\le e_i \\le n$, $1 \\le p_i \\le 10^7$, and the $x_i$ form a permutation of $1$ to $n$.\n\nNote: On 2024-12-28 a hack testdata was added, [post link](https://www.luogu.com.cn/discuss/1025247).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2015] 任务查询系统", "background": "", "description": "最近实验室正在为其管理的超级计算机编制一套任务管理系统，而你被安排完成其中的查询部分。  \n\n超级计算机中的任务用三元组 $(s_i, e_i, p_i)$ 描述，$(s_i, e_i, p_i)$ 表示任务从第 $s_i$ 秒开始，在第 $e_i$ 秒后结束（第 $s_i$ 秒和 $e_i$ 秒任务也在运行），其优先级为 $p_i$。同一时间可能有多个任务同时执行，它们的优先级可能相同，也可能不同。  \n\n调度系统会经常向查询系统询问，第 $x_i$ 秒正在运行的任务中，优先级最小的 $k_i$ 个任务（即将任务按照优先级从小到大排序后取前 $k_i$ 个）的优先级之和是多少。  \n\n特别的，如果 $k_i$ 大于第 $x_i$ 秒正在运行的任务总数，则直接回答第 $x_i$ 秒正在运行的任务优先级之和。上述所有参数均为整数，时间的范围在 $[1, n]$ 之间。\n", "inputFormat": "输入文件第一行包含两个空格分开的正整数 $m$ 和 $n$，分别表示任务总数和时间范围。  \n\n接下来 $m$ 行，每行包含三个空格分开的正整数 $s_i,e_i,p_i$（$s_i \\le e_i$），描述一个任务。  \n\n接下来 $n$ 行，每行包含四个空格分开的整数 $x_i,a_i,b_i,c_i$，描述一次查询。  \n\n**本题强制在线**。查询的参数 $k_i$ 需要由公式 $k_i = 1 +(a_i \\times \\text{pre}+b_i) \\bmod c_i$ 计算得到。其中 $\\text{pre}$ 表示上一次查询的结果，定义初始 $\\text{pre} = 1$ 。\n", "outputFormat": "输出共 $n$ 行，每行一个整数，表示查询结果。\n", "hint": "【样例解释】\n\n$k_1 = (1\\times 1 + 3)\\bmod 2 + 1 = 1$；\n\n$k_2 = (1\\times 2+3)\\bmod 4 + 1 = 2$；\n\n$k_3 = (2 \\times 8+4)\\bmod 3+1 = 3$。\n\n【数据范围】\n \n对于 $100\\%$ 的数据，$1\\le m,n,c_i \\le 10 ^ 5$，$0 \\le a _ i, b _ i \\le 10 ^ 5$，$1\\leq s_i\\leq e_i\\leq n$，$1\\le p_i \\le 10^7$，$x_i$ 为 $1$ 到 $n$ 的一个排列。\n\n\n注：2024-12-28 加入一个 hack 数据，[帖子链接](https://www.luogu.com.cn/discuss/1025247)。", "locale": "zh-CN"}}}
