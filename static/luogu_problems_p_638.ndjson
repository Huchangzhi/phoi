{"pid": "P13936", "type": "P", "difficulty": 4, "samples": [["90 2 2 2\n30 20 20 \n60 20 20", "80"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2022", "蓝桥杯省赛"], "title": "[蓝桥杯 2022 省 Java B] 红绿灯", "background": "", "description": "爱丽丝要开车去上班，上班的路上有许多红绿灯，这让爱丽丝很难过。为了上班不迟到，她给自己的车安装了氮气喷射装置。现在她想知道自己上班最短需要多少时间。\n\n爱丽丝的车最高速度是 $\\frac{1}{V}$ 米每秒，并且经过改装后，可以瞬间加速到小于等于最高速的任意速度，也可以瞬间停止。\n\n爱丽丝家离公司有 $N$ 米远，路上有 $M$ 个红绿灯，第 $i$ 个红绿灯位于离爱丽丝家 $A_i$ 米远的位置，绿灯持续 $B_i$ 秒，红灯持续 $C_i$ 秒。在初始时（爱丽丝开始计时的瞬间），所有红绿灯都恰好从红灯变为绿灯。如果爱丽丝在绿灯变红的瞬间到达红绿灯，她会停下车等红灯，因为她是遵纪守法的好市民。\n\n氮气喷射装置可以让爱丽丝的车瞬间加速到超光速（且不受相对论效应的影响！），达到瞬移的效果，但是爱丽丝是遵纪守法的好市民，在每个红绿灯前她都会停下氮气喷射，即使是绿灯，因为红绿灯处有斑马线，而使用氮气喷射装置通过斑马线是违法的。此外，氮气喷射装置不能连续启动，需要一定时间的冷却，表现为通过 $K$ 个红绿灯后才能再次使用。（也就是说，如果 $K = 1$，就能一直使用啦！）初始时，氮气喷射装置处于可用状态。\n", "inputFormat": "第一行四个正整数 $N$、$M$、$K$、$V$，含义如题面所述。\n\n接下来 $M$ 行，每行三个正整数 $A_i$、$B_i$、$C_i$，含义如题面所述。", "outputFormat": "输出一个正整数 $T$，表示爱丽丝到达公司最短需要多少秒。", "hint": "**【样例说明】**\n\n爱丽丝在最开始直接使用氮气喷射装置瞬间到达第一个红绿灯，然后绿灯通过，以最高速行进 $60$ 秒后到达第二个红绿灯，此时绿灯刚好变红，于是她等待 $20$ 秒再次变为绿灯后通过该红绿灯，此时氮气喷射装置冷却完毕，爱丽丝再次使用瞬间到达公司，总共用时 $80$ 秒。\n\n**【评测用例规模与约定】**\n\n对于 $30\\%$ 的数据，$N \\leq 100$；$M \\leq 10$；$M < K$；$V = 1$.\n\n对于 $60\\%$ 的数据，$N \\leq 1000$；$M \\leq 100$；$K \\leq 50$；$B_i, C_i \\leq 100$；$V \\leq 10$.\n\n对于 $100\\%$ 的数据，$0 < N \\leq 10^3$；$M \\leq 1000$；$K \\leq 1000$；$0 < B_i, C_i \\leq 10^6$；$0 < V \\leq 10^6$；$0 < A_i < N$；对任意 $i < j$，有 $A_i < A_j$.\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2022 省 Java B] 红绿灯", "background": "", "description": "爱丽丝要开车去上班，上班的路上有许多红绿灯，这让爱丽丝很难过。为了上班不迟到，她给自己的车安装了氮气喷射装置。现在她想知道自己上班最短需要多少时间。\n\n爱丽丝的车最高速度是 $\\frac{1}{V}$ 米每秒，并且经过改装后，可以瞬间加速到小于等于最高速的任意速度，也可以瞬间停止。\n\n爱丽丝家离公司有 $N$ 米远，路上有 $M$ 个红绿灯，第 $i$ 个红绿灯位于离爱丽丝家 $A_i$ 米远的位置，绿灯持续 $B_i$ 秒，红灯持续 $C_i$ 秒。在初始时（爱丽丝开始计时的瞬间），所有红绿灯都恰好从红灯变为绿灯。如果爱丽丝在绿灯变红的瞬间到达红绿灯，她会停下车等红灯，因为她是遵纪守法的好市民。\n\n氮气喷射装置可以让爱丽丝的车瞬间加速到超光速（且不受相对论效应的影响！），达到瞬移的效果，但是爱丽丝是遵纪守法的好市民，在每个红绿灯前她都会停下氮气喷射，即使是绿灯，因为红绿灯处有斑马线，而使用氮气喷射装置通过斑马线是违法的。此外，氮气喷射装置不能连续启动，需要一定时间的冷却，表现为通过 $K$ 个红绿灯后才能再次使用。（也就是说，如果 $K = 1$，就能一直使用啦！）初始时，氮气喷射装置处于可用状态。\n", "inputFormat": "第一行四个正整数 $N$、$M$、$K$、$V$，含义如题面所述。\n\n接下来 $M$ 行，每行三个正整数 $A_i$、$B_i$、$C_i$，含义如题面所述。", "outputFormat": "输出一个正整数 $T$，表示爱丽丝到达公司最短需要多少秒。", "hint": "**【样例说明】**\n\n爱丽丝在最开始直接使用氮气喷射装置瞬间到达第一个红绿灯，然后绿灯通过，以最高速行进 $60$ 秒后到达第二个红绿灯，此时绿灯刚好变红，于是她等待 $20$ 秒再次变为绿灯后通过该红绿灯，此时氮气喷射装置冷却完毕，爱丽丝再次使用瞬间到达公司，总共用时 $80$ 秒。\n\n**【评测用例规模与约定】**\n\n对于 $30\\%$ 的数据，$N \\leq 100$；$M \\leq 10$；$M < K$；$V = 1$.\n\n对于 $60\\%$ 的数据，$N \\leq 1000$；$M \\leq 100$；$K \\leq 50$；$B_i, C_i \\leq 100$；$V \\leq 10$.\n\n对于 $100\\%$ 的数据，$0 < N \\leq 10^3$；$M \\leq 1000$；$K \\leq 1000$；$0 < B_i, C_i \\leq 10^6$；$0 < V \\leq 10^6$；$0 < A_i < N$；对任意 $i < j$，有 $A_i < A_j$.\n", "locale": "zh-CN"}}}
{"pid": "P13937", "type": "P", "difficulty": 4, "samples": [["2 4\n0 0 0 0\n1 1 1 0", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "2022", "蓝桥杯省赛"], "title": "[蓝桥杯 2022 省 Java B] 拉箱子", "background": "", "description": "推箱子是一款经典电子游戏，爱丽丝很喜欢玩，但是她有点玩腻了，现在她想设计一款拉箱子游戏。\n\n拉箱子游戏需要玩家在一个 $N \\times M$ 的网格地图中，控制小人上下左右移动，将箱子拉到终点以获得胜利。\n\n现在爱丽丝想知道，在给定地形（即所有墙的位置）的情况下，有多少种不同的可解的初始局面。\n\n**【初始局面】** 的定义如下：\n\n1. 初始局面由排列成 $N \\times M$ 矩形网格状的各种元素组成，每个网格中有且只有一种元素。可能的元素有：空地、墙、小人、箱子、终点。\n2. 初始局面中有且只有一个小人。\n3. 初始局面中有且只有一个箱子。\n4. 初始局面中有且只有一个终点。\n\n**【可解】** 的定义如下：\n\n通过有限次数的移动小人（可以在移动的同时拉箱子），箱子能够到达终点所在的网格。\n\n**【移动】** 的定义如下：\n\n在一次移动中，小人可以移动到相邻（上、下、左、右四种选项）的一个网格中，前提是满足以下条件：\n\n1. 小人永远不能移动到 $N \\times M$ 的网格外部。\n2. 小人永远不能移动到墙上或是箱子上。\n3. 小人可以移动到空地或是终点上。\n\n**【拉箱子】** 的定义如下：\n\n在一次合法移动的同时，如果小人初始所在网格沿小人移动方向的反方向上的相邻网格上恰好是箱子，小人可以拉动箱子一起移动，让箱子移动到小人初始所在网格。\n\n即使满足条件，小人也可以只移动而不拉箱子。", "inputFormat": "第一行两个正整数 $N$ 和 $M$，表示网格的大小。\n\n接下来 $N$ 行，每行 $M$ 个由空格隔开的整数 $0$ 或 $1$ 描述给定的地形。其中 $1$ 表示墙，$0$ 表示未知的元素，未知元素可能是小人或箱子或空地或终点，但不能是墙。\n", "outputFormat": "输出一个正整数，表示可解的初始局面数量。", "hint": "**【样例说明】**\n\n13 种可解的初始局面示意图如下：\n\n人终箱空\n\n墙墙墙空\n\n---\n\n人终空箱\n\n墙墙墙空\n\n---\n\n人空终箱\n\n墙墙墙空\n\n---\n\n箱人终空\n\n墙墙墙空\n\n---\n\n空人终箱\n\n墙墙墙空\n\n---\n\n箱终人空\n\n墙墙墙空\n\n---\n\n空终人箱\n\n墙墙墙空\n\n---\n\n箱终空人\n\n墙墙墙空\n\n---\n\n箱空终人\n\n墙墙墙空\n\n---\n\n空箱终人\n\n墙墙墙空\n\n---\n\n箱终空空\n\n墙墙墙人\n\n---\n\n箱空终空\n\n墙墙墙人\n\n---\n\n空箱终空\n\n墙墙墙人\n\n---\n\n**【评测用例规模与约定】**\n\n对于 $30\\%$ 的数据，$N, M \\leq 3$.\n\n对于 $100\\%$ 的数据，$0 < N, M \\leq 10$.\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2022 省 Java B] 拉箱子", "background": "", "description": "推箱子是一款经典电子游戏，爱丽丝很喜欢玩，但是她有点玩腻了，现在她想设计一款拉箱子游戏。\n\n拉箱子游戏需要玩家在一个 $N \\times M$ 的网格地图中，控制小人上下左右移动，将箱子拉到终点以获得胜利。\n\n现在爱丽丝想知道，在给定地形（即所有墙的位置）的情况下，有多少种不同的可解的初始局面。\n\n**【初始局面】** 的定义如下：\n\n1. 初始局面由排列成 $N \\times M$ 矩形网格状的各种元素组成，每个网格中有且只有一种元素。可能的元素有：空地、墙、小人、箱子、终点。\n2. 初始局面中有且只有一个小人。\n3. 初始局面中有且只有一个箱子。\n4. 初始局面中有且只有一个终点。\n\n**【可解】** 的定义如下：\n\n通过有限次数的移动小人（可以在移动的同时拉箱子），箱子能够到达终点所在的网格。\n\n**【移动】** 的定义如下：\n\n在一次移动中，小人可以移动到相邻（上、下、左、右四种选项）的一个网格中，前提是满足以下条件：\n\n1. 小人永远不能移动到 $N \\times M$ 的网格外部。\n2. 小人永远不能移动到墙上或是箱子上。\n3. 小人可以移动到空地或是终点上。\n\n**【拉箱子】** 的定义如下：\n\n在一次合法移动的同时，如果小人初始所在网格沿小人移动方向的反方向上的相邻网格上恰好是箱子，小人可以拉动箱子一起移动，让箱子移动到小人初始所在网格。\n\n即使满足条件，小人也可以只移动而不拉箱子。", "inputFormat": "第一行两个正整数 $N$ 和 $M$，表示网格的大小。\n\n接下来 $N$ 行，每行 $M$ 个由空格隔开的整数 $0$ 或 $1$ 描述给定的地形。其中 $1$ 表示墙，$0$ 表示未知的元素，未知元素可能是小人或箱子或空地或终点，但不能是墙。\n", "outputFormat": "输出一个正整数，表示可解的初始局面数量。", "hint": "**【样例说明】**\n\n13 种可解的初始局面示意图如下：\n\n人终箱空\n\n墙墙墙空\n\n---\n\n人终空箱\n\n墙墙墙空\n\n---\n\n人空终箱\n\n墙墙墙空\n\n---\n\n箱人终空\n\n墙墙墙空\n\n---\n\n空人终箱\n\n墙墙墙空\n\n---\n\n箱终人空\n\n墙墙墙空\n\n---\n\n空终人箱\n\n墙墙墙空\n\n---\n\n箱终空人\n\n墙墙墙空\n\n---\n\n箱空终人\n\n墙墙墙空\n\n---\n\n空箱终人\n\n墙墙墙空\n\n---\n\n箱终空空\n\n墙墙墙人\n\n---\n\n箱空终空\n\n墙墙墙人\n\n---\n\n空箱终空\n\n墙墙墙人\n\n---\n\n**【评测用例规模与约定】**\n\n对于 $30\\%$ 的数据，$N, M \\leq 3$.\n\n对于 $100\\%$ 的数据，$0 < N, M \\leq 10$.\n", "locale": "zh-CN"}}}
{"pid": "P13938", "type": "P", "difficulty": 2, "samples": [["1 1", "0"], ["2 3", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "2019", "枚举", "ICPC", "EC Final"], "title": "[EC Final 2019] City", "background": "", "description": "Hi ICPCer, welcome to Xi'an.\n\nBeing a beautiful ancient city, Xi'an is the capital city of Zhou, Qin, Han, and Tang Dynasties. With a long history, the streets in Xi'an have a grid pattern. \n\nAttracted by the streets' structure, Coach $\\textit{Pang}$ would like to conduct his research on them. He draws an $n\\times m$ grid on the board. The grid consists $n+1$ vertical line segments and $m+1$ horizontal line segments. The vertical and horizontal line segments intersect at exactly $(n+1)\\times(m+1)$ points, forming $n\\times m$ unit squares. We call the $(n+1)\\times (m+1)$ intersections $\\textit{grid point}$s. Output the number of line segments(not only vertical or horizontal) $l$ satisfying the following three conditions:\n\n- The length is not zero.\n- Both endpoints of $l$ are grid points.\n- The midpoint of $l$ is a grid point.", "inputFormat": "The only line contains two integers $n, m$($1\\le n, m\\le 1000$).", "outputFormat": "Print the answer in a single line.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2019] City", "background": "", "description": "Hi ICPCer, welcome to Xi'an.\n\nBeing a beautiful ancient city, Xi'an is the capital city of Zhou, Qin, Han, and Tang Dynasties. With a long history, the streets in Xi'an have a grid pattern. \n\nAttracted by the streets' structure, Coach $\\textit{Pang}$ would like to conduct his research on them. He draws an $n\\times m$ grid on the board. The grid consists $n+1$ vertical line segments and $m+1$ horizontal line segments. The vertical and horizontal line segments intersect at exactly $(n+1)\\times(m+1)$ points, forming $n\\times m$ unit squares. We call the $(n+1)\\times (m+1)$ intersections $\\textit{grid point}$s. Output the number of line segments(not only vertical or horizontal) $l$ satisfying the following three conditions:\n\n- The length is not zero.\n- Both endpoints of $l$ are grid points.\n- The midpoint of $l$ is a grid point.", "inputFormat": "The only line contains two integers $n, m$($1\\le n, m\\le 1000$).", "outputFormat": "Print the answer in a single line.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2019] City", "background": "", "description": "你好，ICPCer，欢迎来到西安。\n\n作为一座美丽的古城，西安曾是周、秦、汉、唐等朝代的都城。西安历史悠久，街道呈现网格状布局。\n\n受到街道结构的吸引，教练 Pang 希望对其进行研究。他在黑板上画了一个 $n\\times m$ 的网格。该网格由 $n+1$ 条竖直线段和 $m+1$ 条水平线段组成。竖直线段与水平线段恰好在 $(n+1)\\times(m+1)$ 个点上相交，形成 $n\\times m$ 个单位正方形。我们称这 $(n+1)\\times (m+1)$ 个交点为“网格点”。请输出满足以下三个条件的线段 $l$ 的数量（不限于竖直或水平线段）：\n\n- 长度不为零。\n- $l$ 的两个端点都是网格点。\n- $l$ 的中点也是网格点。", "inputFormat": "一行包含两个整数 $n, m$（$1\\le n, m\\le 1000$）。", "outputFormat": "输出一个整数，表示满足条件的线段数量。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13939", "type": "P", "difficulty": 6, "samples": [["5\n1 1 0\n1 1 -1\n2 2 1\n2 2 0\n4 4 1", "1\n0\n1\n4\n16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "ICPC", "EC Final"], "title": "[EC Final 2019] Black and White", "background": "", "description": "$\\textit{Master Pang}$ walks from the bottom-left corner of a $n\\times m$ chessboard to the top-right corner. The chessboard contains $n+1$ horizontal line segments and $m+1$ vertical line segments. The horizontal line segments are numbered from $0$ to $n$ from bottom to top and the vertical ones are numbered from $0$ to $m$ from left to right. The intersection of horizontal line segment $r$ and vertical segment $c$ is denoted by $(r,c)$. The bottom-left corner is $(0, 0)$ and the top-right corner is $(n, m)$. At each step, he can only walk from $(x, y)$ to $(x, y+1)$ or from $(x, y)$ to $(x + 1, y)$.\n\nEach of the $n\\times m$ cells is colored white or black. A cell with corners $(i,j), (i+1,j), (i,j+1), (i+1,j+1)$ $(0\\le i<n, 0\\le j<m)$ is colored white if and only if $i\\equiv j\\pmod 2$. \n\nGiven $Pang$'s walking path from $(0, 0)$ to $(n, m)$, his score is $a-b$ where $a$ is the number of white cells to the left of his walking path and $b$ is the number of black cells to the left of his walking path.\n\nHelp $\\textit{Master Pang}$ count the number of walking paths with score $k$ modulo $998244353$.", "inputFormat": "The first line contains a single integer $T$ --- the number of test cases ($1\\le T \\le 100$).\n\nEach of the next $T$ lines contains three integers $n$, $m$ and $k$ ($1\\le n\\le 100000, 1\\le m\\le 100000, -100000\\le k\\le 100000$).", "outputFormat": "For each test case, output a single integer --- the answer modulo $998244353$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2019] Black and White", "background": "", "description": "$\\textit{Master Pang}$ walks from the bottom-left corner of a $n\\times m$ chessboard to the top-right corner. The chessboard contains $n+1$ horizontal line segments and $m+1$ vertical line segments. The horizontal line segments are numbered from $0$ to $n$ from bottom to top and the vertical ones are numbered from $0$ to $m$ from left to right. The intersection of horizontal line segment $r$ and vertical segment $c$ is denoted by $(r,c)$. The bottom-left corner is $(0, 0)$ and the top-right corner is $(n, m)$. At each step, he can only walk from $(x, y)$ to $(x, y+1)$ or from $(x, y)$ to $(x + 1, y)$.\n\nEach of the $n\\times m$ cells is colored white or black. A cell with corners $(i,j), (i+1,j), (i,j+1), (i+1,j+1)$ $(0\\le i<n, 0\\le j<m)$ is colored white if and only if $i\\equiv j\\pmod 2$. \n\nGiven $Pang$'s walking path from $(0, 0)$ to $(n, m)$, his score is $a-b$ where $a$ is the number of white cells to the left of his walking path and $b$ is the number of black cells to the left of his walking path.\n\nHelp $\\textit{Master Pang}$ count the number of walking paths with score $k$ modulo $998244353$.", "inputFormat": "The first line contains a single integer $T$ --- the number of test cases ($1\\le T \\le 100$).\n\nEach of the next $T$ lines contains three integers $n$, $m$ and $k$ ($1\\le n\\le 100000, 1\\le m\\le 100000, -100000\\le k\\le 100000$).", "outputFormat": "For each test case, output a single integer --- the answer modulo $998244353$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2019] Black and White", "background": null, "description": "$\\textit{Master Pang}$ 从一个 $n\\times m$ 的棋盘的左下角走到右上角。棋盘包含 $n+1$ 条水平线段和 $m+1$ 条竖直线段。水平线段自下而上编号为 $0$ 到 $n$，竖直线段自左而右编号为 $0$ 到 $m$。水平线段 $r$ 与竖直线段 $c$ 的交点记作 $(r,c)$。左下角为 $(0, 0)$，右上角为 $(n, m)$。每一步，他只能从 $(x, y)$ 走到 $(x, y+1)$ 或 $(x, y)$ 走到 $(x+1, y)$。\n\n棋盘上的每个单元格都是白色或黑色。一个以 $(i,j), (i+1,j), (i,j+1), (i+1,j+1)$ 为顶点的单元格（$0\\le i<n, 0\\le j<m$）当且仅当 $i\\equiv j\\pmod 2$ 时为白色。\n\n给定 $Pang$ 从 $(0, 0)$ 走到 $(n, m)$ 的一条路径，他的得分为 $a-b$，其中 $a$ 是路径左侧的白色单元格数量，$b$ 是路径左侧的黑色单元格数量。\n\n请你帮助 $\\textit{Master Pang}$ 计算得分为 $k$ 的路径数量，对 $998244353$ 取模。", "inputFormat": "第一行包含一个整数 $T$，表示测试用例数量（$1\\le T \\le 100$）。\n\n接下来的 $T$ 行，每行包含三个整数 $n$、$m$ 和 $k$（$1\\le n\\le 100000, 1\\le m\\le 100000, -100000\\le k\\le 100000$）。", "outputFormat": "对于每个测试用例，输出一个整数，表示答案对 $998244353$ 取模后的结果。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13940", "type": "P", "difficulty": 6, "samples": [["5 2\n1 8 4 26 6", "1 4 2 5 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "Special Judge", "ICPC", "EC Final"], "title": "[EC Final 2019] Dirichlet k-th root", "background": "", "description": "$\\textit{Mathematician Pang}$ learned Dirichlet convolution during the previous camp. However, compared with deep reinforcement learning, it's too easy for him. Therefore, he did something special. \n\nIf $f,g: \\{1,2,\\ldots,n\\} \\to \\mathbb {Z} $ are two functions from the positive integers to the integers, the Dirichlet convolution $f * g$ is a new function defined by: $$(f * g)(n)  =\\sum_{d \\mid n}f(d)g ({\\frac {n}{d}}) .$$\n\nWe define the $k$-th power of an function $g=f^k$ by $$ f^{k}=\\underbrace {f * \\dots * f} _{k~{\\textrm {times}}}.$$\n\nIn this problem, we want to solve the inverse problem: Given $g$ and $k$, you need to find a function $f$ such that $g=f^k$.\n\nMoreover, there is an additional constraint that $f(1)$ and $g(1)$ must equal to $1$. And all the arithmetic operations are done on $\\mathbb{F}_{p}$ where $p=998244353$, which means that in the Dirichlet convolution, $(f * g)(n)  =\\left(\\sum_{d \\mid n}f(d)g ({\\frac {n}{d}})\\right) \\bmod p$.", "inputFormat": "The first line contains two integers $n$ and $k~(2\\leq n\\leq 10^5,1\\leq k<998244353)$ .\n\nThe second line contains n integers $g(1), g(2),..., g(n)$ ($0\\le g(i)<998244353, g(1)=1$).", "outputFormat": "If there is no solution, output $-1$.\n\nOtherwise, output $f(1), f(2), ..., f(n)$ ($0\\le f(i)<998244353, f(1)=1$). If there are multiple solutions, print anyone.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2019] Dirichlet k-th root", "background": "", "description": "$\\textit{Mathematician Pang}$ learned Dirichlet convolution during the previous camp. However, compared with deep reinforcement learning, it's too easy for him. Therefore, he did something special. \n\nIf $f,g: \\{1,2,\\ldots,n\\} \\to \\mathbb {Z} $ are two functions from the positive integers to the integers, the Dirichlet convolution $f * g$ is a new function defined by: $$(f * g)(n)  =\\sum_{d \\mid n}f(d)g ({\\frac {n}{d}}) .$$\n\nWe define the $k$-th power of an function $g=f^k$ by $$ f^{k}=\\underbrace {f * \\dots * f} _{k~{\\textrm {times}}}.$$\n\nIn this problem, we want to solve the inverse problem: Given $g$ and $k$, you need to find a function $f$ such that $g=f^k$.\n\nMoreover, there is an additional constraint that $f(1)$ and $g(1)$ must equal to $1$. And all the arithmetic operations are done on $\\mathbb{F}_{p}$ where $p=998244353$, which means that in the Dirichlet convolution, $(f * g)(n)  =\\left(\\sum_{d \\mid n}f(d)g ({\\frac {n}{d}})\\right) \\bmod p$.", "inputFormat": "The first line contains two integers $n$ and $k~(2\\leq n\\leq 10^5,1\\leq k<998244353)$ .\n\nThe second line contains n integers $g(1), g(2),..., g(n)$ ($0\\le g(i)<998244353, g(1)=1$).", "outputFormat": "If there is no solution, output $-1$.\n\nOtherwise, output $f(1), f(2), ..., f(n)$ ($0\\le f(i)<998244353, f(1)=1$). If there are multiple solutions, print anyone.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2019] Dirichlet k-th root", "background": null, "description": "庞数学家在上一次集训中学习了狄利克雷卷积。不过，相比深度强化学习，这对他来说太简单了。因此，他做了一些特别的事情。\n\n如果 $f,g: \\{1,2,\\ldots,n\\} \\to \\mathbb {Z} $ 是从正整数到整数的两个函数，则狄利克雷卷积 $f * g$ 定义为一个新函数：\n$$(f * g)(n)  =\\sum_{d \\mid n}f(d)g \\left(\\frac {n}{d}\\right) .$$\n\n我们定义函数 $g=f^k$ 的 $k$ 次幂为\n$$ f^{k}=\\underbrace {f * \\dots * f} _{k~{\\textrm {次}}}.$$\n\n在本题中，我们要求解逆问题：给定 $g$ 和 $k$，你需要找到一个函数 $f$，使得 $g=f^k$。\n\n此外，还有一个额外的限制条件：$f(1)$ 和 $g(1)$ 必须等于 $1$。所有的算术运算都在 $\\mathbb{F}_{p}$ 上进行，其中 $p=998244353$，也就是说，在狄利克雷卷积中，$(f * g)(n)  =\\left(\\sum_{d \\mid n}f(d)g \\left(\\frac {n}{d}\\right)\\right) \\bmod p$。", "inputFormat": "第一行包含两个整数 $n$ 和 $k~(2\\leq n\\leq 10^5,1\\leq k<998244353)$。\n\n第二行包含 $n$ 个整数 $g(1), g(2),..., g(n)$（$0\\le g(i)<998244353, g(1)=1$）。", "outputFormat": "如果无解，输出 $-1$。\n\n否则，输出 $f(1), f(2), ..., f(n)$（$0\\le f(i)<998244353, f(1)=1$）。如果有多组解，输出任意一组即可。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13941", "type": "P", "difficulty": 6, "samples": [["3 1\n1 2\n1 3\n4 3 5", "1"], ["3 1\n1 2\n1 3\n2 10 10", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "ICPC", "EC Final"], "title": "[EC Final 2019] Fire", "background": "", "description": "$\\textit{Pang}$ lives on a tree with $n$ vertices. The vertices are labelled as $1,2,\\ldots, n$ and $\\textit{Pang}$ is in vertex $1$. Each vertex has a temperature. On the morning of each day after day 0, the temperature of each vertex decreases by $1$. The temperature doesn't decrease on day 0. On the afternoon of each day, $\\textit{Pang}$ can travel to an adjacent vertex, provided that he is at a vertex with positive temperature and his destination vertex has a non-negative temperature. On the evening of each day, if the temperature is higher than or equal to $0$, $\\textit{Pang}$ can cast magic which increases the temperature of the vertex he is in by $k$.  For each pair of adjacent vertices $a$ and $b$, $\\textit{Pang}$ can travel from vertex $a$ to vertex $b$ at most once (and from $b$ to $a$ at most once). He can choose not to travel and stay in the current vertex. \n\n$\\textit{Pang}$ wants to cast his magic on each vertex exactly once. He also tries to stay at vertex $1$ as long as possible, before traveling to any other city. Given the temperature of each vertex right before the morning of the day $1$, on which day must $\\textit{Pang}$ prepare for departing? If $\\textit{Pang}$ prepares on day $i$, he can cast his magic on that day and will make his first move on day $i+1$. If he cannot cast his magic on each vertex exactly once even if he prepares for departing on the day $0$, output $-1$.\n", "inputFormat": "The first line contains two integers $n$ and $k$ ($2\\le n\\le 100000, 0\\le k\\le 1000000000$).\n\nEach of the next $n-1$ lines contains two integers $x$ and $y$, indicating an edge between vertices $x$ and $y$ ($1\\le x, y\\le n$).\n\nThe $(n+1)$-th line contains $n$ integers $a_1,a_2,\\ldots,a_n$ --- the temperature of vertex $i$ right before the morning of day $1$ ($0\\le a_i\\le 1000000000$).\n\nIt's guaranteed that the input is a tree structure.", "outputFormat": "If he cannot cast his magic on each vertex exactly once, output $-1$.\n\nOtherwise, output a single integer $x$ --- he must prepare for departing from vertex $1$ on  day $x$. Day $1$ is the day after day $0$, and so on.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2019] Fire", "background": "", "description": "$\\textit{Pang}$ lives on a tree with $n$ vertices. The vertices are labelled as $1,2,\\ldots, n$ and $\\textit{Pang}$ is in vertex $1$. Each vertex has a temperature. On the morning of each day after day 0, the temperature of each vertex decreases by $1$. The temperature doesn't decrease on day 0. On the afternoon of each day, $\\textit{Pang}$ can travel to an adjacent vertex, provided that he is at a vertex with positive temperature and his destination vertex has a non-negative temperature. On the evening of each day, if the temperature is higher than or equal to $0$, $\\textit{Pang}$ can cast magic which increases the temperature of the vertex he is in by $k$.  For each pair of adjacent vertices $a$ and $b$, $\\textit{Pang}$ can travel from vertex $a$ to vertex $b$ at most once (and from $b$ to $a$ at most once). He can choose not to travel and stay in the current vertex. \n\n$\\textit{Pang}$ wants to cast his magic on each vertex exactly once. He also tries to stay at vertex $1$ as long as possible, before traveling to any other city. Given the temperature of each vertex right before the morning of the day $1$, on which day must $\\textit{Pang}$ prepare for departing? If $\\textit{Pang}$ prepares on day $i$, he can cast his magic on that day and will make his first move on day $i+1$. If he cannot cast his magic on each vertex exactly once even if he prepares for departing on the day $0$, output $-1$.\n", "inputFormat": "The first line contains two integers $n$ and $k$ ($2\\le n\\le 100000, 0\\le k\\le 1000000000$).\n\nEach of the next $n-1$ lines contains two integers $x$ and $y$, indicating an edge between vertices $x$ and $y$ ($1\\le x, y\\le n$).\n\nThe $(n+1)$-th line contains $n$ integers $a_1,a_2,\\ldots,a_n$ --- the temperature of vertex $i$ right before the morning of day $1$ ($0\\le a_i\\le 1000000000$).\n\nIt's guaranteed that the input is a tree structure.", "outputFormat": "If he cannot cast his magic on each vertex exactly once, output $-1$.\n\nOtherwise, output a single integer $x$ --- he must prepare for departing from vertex $1$ on  day $x$. Day $1$ is the day after day $0$, and so on.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2019] Fire", "background": null, "description": "$\\textit{Pang}$ 住在一棵有 $n$ 个节点的树上。节点编号为 $1,2,\\ldots, n$，$\\textit{Pang}$ 起初在节点 $1$。每个节点都有一个温度。从第 $1$ 天早晨开始，每天早晨每个节点的温度都会减少 $1$。第 $0$ 天温度不会减少。每天的下午，如果 $\\textit{Pang}$ 当前所在的节点温度为正，且他要前往的相邻节点温度不小于 $0$，他可以移动到一个相邻节点。每天的晚上，如果当前节点的温度大于等于 $0$，$\\textit{Pang}$ 可以施放魔法，使他所在节点的温度增加 $k$。\n\n对于每一对相邻节点 $a$ 和 $b$，$\\textit{Pang}$ 最多只能从 $a$ 走到 $b$ 一次（从 $b$ 到 $a$ 也最多一次）。他也可以选择不移动，留在当前节点。\n\n$\\textit{Pang}$ 想要在每个节点上恰好施放一次魔法。他还希望在出发前尽可能长时间地待在节点 $1$。已知第 $1$ 天早晨之前每个节点的温度，$\\textit{Pang}$ 应该在第几天准备离开？如果他在第 $i$ 天准备离开，他可以在这一天施放魔法，并将在第 $i+1$ 天进行第一次移动。如果即使在第 $0$ 天准备离开也无法在每个节点上恰好施放一次魔法，输出 $-1$。", "inputFormat": "第一行包含两个整数 $n$ 和 $k$（$2\\le n\\le 100000, 0\\le k\\le 1000000000$）。\n\n接下来的 $n-1$ 行，每行包含两个整数 $x$ 和 $y$，表示节点 $x$ 和 $y$ 之间有一条边（$1\\le x, y\\le n$）。\n\n第 $n+1$ 行包含 $n$ 个整数 $a_1,a_2,\\ldots,a_n$，表示第 $i$ 个节点在第 $1$ 天早晨之前的温度（$0\\le a_i\\le 1000000000$）。\n\n保证输入是一棵树结构。", "outputFormat": "如果无法在每个节点上恰好施放一次魔法，输出 $-1$。\n\n否则，输出一个整数 $x$，表示他必须在第 $x$ 天从节点 $1$ 准备出发。第 $1$ 天是第 $0$ 天之后的一天，依此类推。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13942", "type": "P", "difficulty": 4, "samples": [["4 3\n1 2 1\n2 3 2\n3 4 3", "1"], ["4 4\n1 2 1\n1 3 1\n2 4 2\n3 4 2", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "ICPC", "EC Final"], "title": "[EC Final 2019] Flow", "background": "", "description": "One of $\\textit{Pang}$'s research interests is the maximum flow problem. \n\nA directed graph $G$ with $n$ vertices is $\\textit{universe}$ if the following condition is satisfied:\n- $G$ is the union of $k$ vertex-independent simple paths from vertex $1$ to vertex $n$ of the same length.\n\nA set of paths is vertex-independent if they do not have any internal vertex in common. \n\nA vertex in a path is called internal if it is not an endpoint of that path.\n\nA path is simple if its vertices are distinct.\n\nLet $G$ be a $\\textit{universe}$ graph with $n$ vertices and $m$ edges. Each edge has a non-negative integral capacity. You are allowed to perform the following operation any (including $0$) times to make the maximum flow from vertex $1$ to vertex $n$ as large as possible:\n\nLet $e$ be an edge with positive capacity. Reduce the capacity of $e$ by $1$ and increase the capacity of another edge by $1$.\n\n$\\textit{Pang}$ wants to know what is the minimum number of operations to achieve it?", "inputFormat": "The first line contains two integers $n$ and $m$ ($2\\leq n\\leq 100000, 1\\leq m \\leq 200000$).\n\nEach of the next $m$ lines contains three integers $x, y$ and $z$, denoting an edge from $x$ to $y$ with capacity $z$ ($1 \\leq x, y \\leq n$, $0\\le z\\le 1000000000$).\n\nIt's guaranteed that the input is a $universe$ graph without multiple edges and self-loops.\n", "outputFormat": "Output a single integer --- the minimum number of operations.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2019] Flow", "background": "", "description": "One of $\\textit{Pang}$'s research interests is the maximum flow problem. \n\nA directed graph $G$ with $n$ vertices is $\\textit{universe}$ if the following condition is satisfied:\n- $G$ is the union of $k$ vertex-independent simple paths from vertex $1$ to vertex $n$ of the same length.\n\nA set of paths is vertex-independent if they do not have any internal vertex in common. \n\nA vertex in a path is called internal if it is not an endpoint of that path.\n\nA path is simple if its vertices are distinct.\n\nLet $G$ be a $\\textit{universe}$ graph with $n$ vertices and $m$ edges. Each edge has a non-negative integral capacity. You are allowed to perform the following operation any (including $0$) times to make the maximum flow from vertex $1$ to vertex $n$ as large as possible:\n\nLet $e$ be an edge with positive capacity. Reduce the capacity of $e$ by $1$ and increase the capacity of another edge by $1$.\n\n$\\textit{Pang}$ wants to know what is the minimum number of operations to achieve it?", "inputFormat": "The first line contains two integers $n$ and $m$ ($2\\leq n\\leq 100000, 1\\leq m \\leq 200000$).\n\nEach of the next $m$ lines contains three integers $x, y$ and $z$, denoting an edge from $x$ to $y$ with capacity $z$ ($1 \\leq x, y \\leq n$, $0\\le z\\le 1000000000$).\n\nIt's guaranteed that the input is a $universe$ graph without multiple edges and self-loops.\n", "outputFormat": "Output a single integer --- the minimum number of operations.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2019] Flow", "background": null, "description": "$\\textit{Pang}$ 的研究兴趣之一是最大流问题。\n\n一个有 $n$ 个顶点的有向图 $G$ 被称为 $\\textit{universe}$，如果满足以下条件：\n- $G$ 是 $k$ 条从顶点 $1$ 到顶点 $n$ 的顶点互不相交、长度相同的简单路径的并集。\n\n一组路径是顶点互不相交的，如果它们没有任何内部顶点相同。\n\n路径中的一个顶点被称为内部顶点，如果它不是该路径的端点。\n\n一条路径是简单的，如果其顶点互不相同。\n\n设 $G$ 是一个有 $n$ 个顶点、$m$ 条边的 $\\textit{universe}$ 图。每条边都有一个非负整数容量。你可以进行如下操作任意次（包括 $0$ 次），以使从顶点 $1$ 到顶点 $n$ 的最大流尽可能大：\n\n设 $e$ 是一条容量大于 $0$ 的边。将 $e$ 的容量减少 $1$，并将另一条边的容量增加 $1$。\n\n$\\textit{Pang}$ 想知道，最少需要多少次操作才能实现最大流最大化？", "inputFormat": "第一行包含两个整数 $n$ 和 $m$（$2\\leq n\\leq 100000, 1\\leq m \\leq 200000$）。\n\n接下来的 $m$ 行，每行包含三个整数 $x, y, z$，表示一条从 $x$ 到 $y$ 的有向边，容量为 $z$（$1 \\leq x, y \\leq n$, $0\\le z\\le 1000000000$）。\n\n保证输入是一个 $\\textit{universe}$ 图，没有重边和自环。", "outputFormat": "输出一个整数，表示最少需要的操作次数。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13943", "type": "P", "difficulty": 6, "samples": [["4\n40 39 38 38 37 37 36 36 35 35 34 34 34 33 33 33 32 32 32 31 31 31 30 30\n34 31 36 33 31 39 37 38 35 32 32 35 36 31 34 32 38 40 30 33 30 34 33 37\n37 30 40 38 36 38 32 34 36 35 37 32 34 33 31 30 33 31 35 34 33 39 31 32\n30 33 32 39 37 38 35 40 34 30 31 37 31 33 31 33 34 32 36 36 35 34 32 38", "34 39 35 38 33 34 36 31 37 31 32 37 33 33 35 32 36 38 31 32 30 40 30 34\n35 30 32 33 33 38 32 31 35 33 31 37 36 31 39 30 34 32 40 36 34 34 37 38\n36 39 34 38 34 32 33 33 30 31 37 33 40 32 34 36 30 32 38 35 31 31 35 37\n36 35 34 39 40 33 31 37 31 30 32 38 30 33 33 34 32 34 35 37 36 32 38 31"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "Special Judge", "ICPC", "EC Final"], "title": "[EC Final 2019] Game", "background": "", "description": "Alice and Bob are playing $\\textit{Luzhanqi}$. Each of them has a $\\textit{permutation}$ of the following $24$ pieces:\n\n- one Field Marshal, order 9\n- one General, order 8\n- two Major Generals, order 7\n- two Brigadier Generals, order 6\n- two Colonels, order 5\n- two Majors, order 4\n- three Captains, order 3\n- three Lieutenants, order 2\n- three Engineers, order 1\n- two Bombs\n- three Landmines\n\nTo determine the winner, we repeat the following process until someone wins the game or the game ends in a draw:\n- If both permutations are empty, the game ends in a draw.\n- If Alice's permutation is empty, Bob wins the game.\n- If Bob's permutation is empty, Alice wins the game.\n- Let the first piece in Alice's permutation be $A$ and the first piece in Bob's permutation be $B$. The following is the outcome of the battle between $A$ and $B$:\n-If $A$ and $B$ are the same types of pieces, or if one of $A$ and $B$ is Bomb, they are both removed.\n- Otherwise, if one of $A$ and $B$ is Landmine and the other is Engineer, the Landmine is removed and the Engineer stays alive.\n- Otherwise, if one of $A$ and $B$ is Landmine and the other's order is greater than 1, the Landmine stays alive and the other one is removed.\n- Otherwise, we compare the order of $A$ and $B$ and the piece with smaller order is removed.\n\nBob knows Alice's permutation in advance and can decide his permutation based on that information. After Bob deciding his permutation, Alice can swap two pieces in Bob's permutation. Can Bob construct a permutation that wins against Alice's permutation no matter which pair of pieces she swaps? ", "inputFormat": "The first line contains one integer $T$ denoting the number of test cases ($1\\le T\\le 100$).\n\nEach of the next $T$ lines contains $24$ integers denoting Alice's permutation: \n\n- $40$ represents Field Marshal\n- $39$ represents General\n- $38$ represents Major Generals\n- $37$ represents Brigadier Generals\n- $36$ represents Colonels\n- $35$ represents Majors\n- $34$ represents Captains\n- $33$ represents Lieutenants\n- $32$ represents Engineers\n- $31$ represents Landmines\n- $30$ represents Bombs\n\nIt is guaranteed that all permutations are chosen uniformly at random and contains exactly the $24$ pieces described in the statement.", "outputFormat": "Output one line for each test case.\n\nIf Bob cannot construct the required permutation, print $-1$.\n\nOtherwise, print $24$ integers representing Bob's permutation in the same format as in the input. If there are multiple solutions, print any. Bob's permutation must contain exactly the $24$ pieces described in the statement.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2019] Game", "background": "", "description": "Alice and Bob are playing $\\textit{Luzhanqi}$. Each of them has a $\\textit{permutation}$ of the following $24$ pieces:\n\n- one Field Marshal, order 9\n- one General, order 8\n- two Major Generals, order 7\n- two Brigadier Generals, order 6\n- two Colonels, order 5\n- two Majors, order 4\n- three Captains, order 3\n- three Lieutenants, order 2\n- three Engineers, order 1\n- two Bombs\n- three Landmines\n\nTo determine the winner, we repeat the following process until someone wins the game or the game ends in a draw:\n- If both permutations are empty, the game ends in a draw.\n- If Alice's permutation is empty, Bob wins the game.\n- If Bob's permutation is empty, Alice wins the game.\n- Let the first piece in Alice's permutation be $A$ and the first piece in Bob's permutation be $B$. The following is the outcome of the battle between $A$ and $B$:\n-If $A$ and $B$ are the same types of pieces, or if one of $A$ and $B$ is Bomb, they are both removed.\n- Otherwise, if one of $A$ and $B$ is Landmine and the other is Engineer, the Landmine is removed and the Engineer stays alive.\n- Otherwise, if one of $A$ and $B$ is Landmine and the other's order is greater than 1, the Landmine stays alive and the other one is removed.\n- Otherwise, we compare the order of $A$ and $B$ and the piece with smaller order is removed.\n\nBob knows Alice's permutation in advance and can decide his permutation based on that information. After Bob deciding his permutation, Alice can swap two pieces in Bob's permutation. Can Bob construct a permutation that wins against Alice's permutation no matter which pair of pieces she swaps? ", "inputFormat": "The first line contains one integer $T$ denoting the number of test cases ($1\\le T\\le 100$).\n\nEach of the next $T$ lines contains $24$ integers denoting Alice's permutation: \n\n- $40$ represents Field Marshal\n- $39$ represents General\n- $38$ represents Major Generals\n- $37$ represents Brigadier Generals\n- $36$ represents Colonels\n- $35$ represents Majors\n- $34$ represents Captains\n- $33$ represents Lieutenants\n- $32$ represents Engineers\n- $31$ represents Landmines\n- $30$ represents Bombs\n\nIt is guaranteed that all permutations are chosen uniformly at random and contains exactly the $24$ pieces described in the statement.", "outputFormat": "Output one line for each test case.\n\nIf Bob cannot construct the required permutation, print $-1$.\n\nOtherwise, print $24$ integers representing Bob's permutation in the same format as in the input. If there are multiple solutions, print any. Bob's permutation must contain exactly the $24$ pieces described in the statement.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2019] Game", "background": null, "description": "Alice 和 Bob 正在玩“陆战棋”。他们每个人都有一个由以下 $24$ 个棋子组成的 $\\textit{排列}$：\n\n- 1 个司令，序号 9\n- 1 个军长，序号 8\n- 2 个师长，序号 7\n- 2 个旅长，序号 6\n- 2 个团长，序号 5\n- 2 个营长，序号 4\n- 3 个连长，序号 3\n- 3 个排长，序号 2\n- 3 个工兵，序号 1\n- 2 个炸弹\n- 3 个地雷\n\n为了决定胜负，重复以下过程直到有人获胜或平局：\n\n- 如果两个排列都为空，游戏平局。\n- 如果 Alice 的排列为空，Bob 获胜。\n- 如果 Bob 的排列为空，Alice 获胜。\n- 令 Alice 排列的第一个棋子为 $A$，Bob 排列的第一个棋子为 $B$，则 $A$ 与 $B$ 进行对战，规则如下：\n    - 如果 $A$ 和 $B$ 是同类型棋子，或其中一个是炸弹，则两者都被移除。\n    - 否则，如果 $A$ 或 $B$ 是地雷，且另一个是工兵，则地雷被移除，工兵存活。\n    - 否则，如果 $A$ 或 $B$ 是地雷，且另一个的序号大于 1，则地雷存活，另一个被移除。\n    - 否则，比较 $A$ 和 $B$ 的序号，序号较小的被移除。\n\nBob 事先知道 Alice 的排列，并可以根据此信息决定自己的排列。在 Bob 决定好自己的排列后，Alice 可以交换 Bob 排列中的任意两个棋子。请问 Bob 能否构造出一个排列，使得无论 Alice 交换哪一对棋子，Bob 都能战胜 Alice 的排列？如果可以，请输出任意一个满足条件的排列。", "inputFormat": "第一行包含一个整数 $T$，表示测试用例数量（$1\\le T\\le 100$）。\n\n接下来的 $T$ 行，每行包含 $24$ 个整数，表示 Alice 的排列：\n\n- $40$ 表示司令\n- $39$ 表示军长\n- $38$ 表示师长\n- $37$ 表示旅长\n- $36$ 表示团长\n- $35$ 表示营长\n- $34$ 表示连长\n- $33$ 表示排长\n- $32$ 表示工兵\n- $31$ 表示地雷\n- $30$ 表示炸弹\n\n保证所有排列均为随机选取，并且每种棋子的数量与题目描述一致。", "outputFormat": "每个测试用例输出一行。\n\n如果 Bob 无法构造出满足条件的排列，输出 $-1$。\n\n否则，输出 $24$ 个整数，表示 Bob 的排列，格式与输入相同。如果有多种方案，输出任意一种。Bob 的排列必须包含题目描述中的全部 $24$ 个棋子。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13944", "type": "P", "difficulty": 6, "samples": [["10\n233 1,-,-,7 7,257 4,173 5,117 1,-,-,85 3\n-,231 0,167 0,257 7,-,-,122 4,283 0,215 4,-\n41 1,-,290 8,-,-,-,-,246 7,120 3,184 9\n142 8,243 7,69 0,-,41 9,-,279 1,264 4,-,74 9\n53 8,-,187 9,60 1,48 8,99 10,-,-,55 7,259 5\n250 0,-,-,-,166 0,16 3,-,82 4,73 0,184 3\n-,-,-,-,105 3,-,-,-,152 4,-\n-,84 5,98 8,-,120 8,241 3,94 1,-,28 7,109 8\n280 6,246 5,58 9,-,-,-,-,-,-,-\n38 10,-,227 10,187 9,182 1,-,203 9,254 7,-,-", "1800"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "ICPC", "EC Final"], "title": "[EC Final 2019] Happiness", "background": "", "description": "$\\textit{Pang}$ has graduated from college $3$ years and he really misses the time he spent with ICPC(Interspecies Collegiate Pokemon Camp).\n\nThere are $10$ problems in one contest in ICPC. $n$ participating teams have $300$ minutes to solve them. After the contest, teams are ranked according to the most problems solved.  Teams who solve the same number of problems are ranked by least total time. The total time is the sum of the time consumed for each problem solved. The time consumed for a solved problem is the time elapsed from the beginning of the contest to the submittal of the first accepted run plus 20 penalty minutes for every previously rejected run for that problem.  There is no time consumed for a problem that is not solved. If two teams tie, their $\\textit{solution time list}$s are calculated. A team's solution time list is a list consisting of solution times of all problems solved by that team, sorted in descending order. The solution time of one problem is the time elapsed from the beginning of the contest to the submittal of the first accepted run of that problem. (We do not add a penalty for the solution time.) The team with a lexicographically smaller solution time list has a better rank. A list $(a_1, \\ldots, a_k)$ is lexicographically smaller than $(b_1,\\ldots,b_k)$ if there exists an integer $i\\in [1,k]$ such that $a_i<b_i$ and $a_j=b_j$ for all integers $j\\in [1,i)$. If teams still tie, $\\textit{Pang}$'s team is assumed to have a better rank. \n\nAfter determining the rank, prizes will be awarded. Initially, a team with rank $r$ will get $\\lfloor 5000/r\\rfloor$ happiness. Then medals are awarded: Teams with rank $1$ to $\\lfloor n/10\\rfloor$ are awarded gold medal. The $\\textit{happiness}$ of receiving a gold medal is $1200$. Teams with rank $\\lfloor n/10\\rfloor+1$ to $3\\lfloor n/10\\rfloor$ are awarded silver medal. The $\\textit{happiness}$ of receiving a silver medal is $800$. Teams with rank $3\\lfloor n/10\\rfloor+1$ to $6\\lfloor n/10\\rfloor$ are awarded bronze medal. The $\\textit{happiness}$ of receiving a bronze medal is $400$. In addition to medals, for each problem, the team solved it first gets $800$ happiness. The team with at least one solution and the smallest solution time overall teams and all problems gets an extra $700$ happiness. The team with at least one solution and the largest solution time overall teams and all problems gets an extra $500$ happiness. In the case of a tie, $\\textit{Pang}$'s team can always get happiness.\n\nThere were $n$ teams in a contest $\\textit{Pang}$ participated. He remembers all the submissions (time and verdict) of all other teams. For each problem, he also remembers if he knew the solution to that problem and the number of rejected runs and times he needed to solve it.\n\nIf $\\textit{Pang}$ solved problems in the wisest order, what is the maximum happiness he could get? Note that $\\textit{Pang}$ cannot solve any problem after $300$ minutes from the beginning of the contest (He can solve problems at exactly 300 minutes). Once $\\textit{Pang}$ solves a problem, he needs to submit it immediately and solve another one. He can't postpone his submission to get the last submission happiness.", "inputFormat": "The first line contains an integer $n$ denoting the number of teams ($10\\le n\\le 300$, $n$ is a multiple of $10$).\n\nEach of the next $n-1$ lines describes one team and contains the statuses of the $10$ problems. For each problem, if it is not solved by the team, the status contains a single character ``-``. Otherwise, the status contains two integers $t$ and $w$ separated by a single space denoting the solution time and the number of rejected runs before the solution time ($1\\le t\\le 300, 0\\le w\\le 10$). Statuses of different problems are separated by ``,``.\n\nThe last line describes $\\textit{Pang}$'s team. For each problem, if $\\textit{Pang}$ did not know how to solve it, the status contains a single character ``-``. Otherwise, the status contains two integers $x$ and $y$ separated by a single space denoting the required time and the number of rejected runs before $\\textit{Pang}$ could solve it ($1\\le x\\le 300, 0\\le y\\le 10$). Statuses of different problems are separated by ``,``.\n\nThere are no extra spaces and other characters in the statuses of $\\textit{Pang}$ and other teams.", "outputFormat": "Output one integer --- the maximum happiness.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2019] Happiness", "background": "", "description": "$\\textit{Pang}$ has graduated from college $3$ years and he really misses the time he spent with ICPC(Interspecies Collegiate Pokemon Camp).\n\nThere are $10$ problems in one contest in ICPC. $n$ participating teams have $300$ minutes to solve them. After the contest, teams are ranked according to the most problems solved.  Teams who solve the same number of problems are ranked by least total time. The total time is the sum of the time consumed for each problem solved. The time consumed for a solved problem is the time elapsed from the beginning of the contest to the submittal of the first accepted run plus 20 penalty minutes for every previously rejected run for that problem.  There is no time consumed for a problem that is not solved. If two teams tie, their $\\textit{solution time list}$s are calculated. A team's solution time list is a list consisting of solution times of all problems solved by that team, sorted in descending order. The solution time of one problem is the time elapsed from the beginning of the contest to the submittal of the first accepted run of that problem. (We do not add a penalty for the solution time.) The team with a lexicographically smaller solution time list has a better rank. A list $(a_1, \\ldots, a_k)$ is lexicographically smaller than $(b_1,\\ldots,b_k)$ if there exists an integer $i\\in [1,k]$ such that $a_i<b_i$ and $a_j=b_j$ for all integers $j\\in [1,i)$. If teams still tie, $\\textit{Pang}$'s team is assumed to have a better rank. \n\nAfter determining the rank, prizes will be awarded. Initially, a team with rank $r$ will get $\\lfloor 5000/r\\rfloor$ happiness. Then medals are awarded: Teams with rank $1$ to $\\lfloor n/10\\rfloor$ are awarded gold medal. The $\\textit{happiness}$ of receiving a gold medal is $1200$. Teams with rank $\\lfloor n/10\\rfloor+1$ to $3\\lfloor n/10\\rfloor$ are awarded silver medal. The $\\textit{happiness}$ of receiving a silver medal is $800$. Teams with rank $3\\lfloor n/10\\rfloor+1$ to $6\\lfloor n/10\\rfloor$ are awarded bronze medal. The $\\textit{happiness}$ of receiving a bronze medal is $400$. In addition to medals, for each problem, the team solved it first gets $800$ happiness. The team with at least one solution and the smallest solution time overall teams and all problems gets an extra $700$ happiness. The team with at least one solution and the largest solution time overall teams and all problems gets an extra $500$ happiness. In the case of a tie, $\\textit{Pang}$'s team can always get happiness.\n\nThere were $n$ teams in a contest $\\textit{Pang}$ participated. He remembers all the submissions (time and verdict) of all other teams. For each problem, he also remembers if he knew the solution to that problem and the number of rejected runs and times he needed to solve it.\n\nIf $\\textit{Pang}$ solved problems in the wisest order, what is the maximum happiness he could get? Note that $\\textit{Pang}$ cannot solve any problem after $300$ minutes from the beginning of the contest (He can solve problems at exactly 300 minutes). Once $\\textit{Pang}$ solves a problem, he needs to submit it immediately and solve another one. He can't postpone his submission to get the last submission happiness.", "inputFormat": "The first line contains an integer $n$ denoting the number of teams ($10\\le n\\le 300$, $n$ is a multiple of $10$).\n\nEach of the next $n-1$ lines describes one team and contains the statuses of the $10$ problems. For each problem, if it is not solved by the team, the status contains a single character ``-``. Otherwise, the status contains two integers $t$ and $w$ separated by a single space denoting the solution time and the number of rejected runs before the solution time ($1\\le t\\le 300, 0\\le w\\le 10$). Statuses of different problems are separated by ``,``.\n\nThe last line describes $\\textit{Pang}$'s team. For each problem, if $\\textit{Pang}$ did not know how to solve it, the status contains a single character ``-``. Otherwise, the status contains two integers $x$ and $y$ separated by a single space denoting the required time and the number of rejected runs before $\\textit{Pang}$ could solve it ($1\\le x\\le 300, 0\\le y\\le 10$). Statuses of different problems are separated by ``,``.\n\nThere are no extra spaces and other characters in the statuses of $\\textit{Pang}$ and other teams.", "outputFormat": "Output one integer --- the maximum happiness.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2019] Happiness", "background": null, "description": "$\\textit{Pang}$ 已经毕业 3 年了，他非常怀念和 ICPC（Interspecies Collegiate Pokemon Camp）一起度过的时光。\n\n在 ICPC 的一场比赛中有 $10$ 道题目，$n$ 支参赛队伍有 $300$ 分钟来解决这些题目。比赛结束后，队伍按照解决题目的数量从多到少排名。解决题目数相同的队伍，按照总用时从少到多排名。总用时为每道被解决题目的用时之和。某道题目的用时为从比赛开始到该题首次通过的提交的时间，加上该题此前每次被拒绝的提交各 $20$ 分钟的罚时。未解决的题目不计入总用时。如果两队仍然并列，则计算它们的“解题时间列表”。某队的解题时间列表是该队所有已解决题目的解题时间（即首次通过的提交时间，不加罚时），按降序排列。若某队的解题时间列表在字典序上更小，则排名更高。对于两个长度相同的列表 $(a_1, \\ldots, a_k)$ 和 $(b_1, \\ldots, b_k)$，如果存在整数 $i\\in [1,k]$ 使得 $a_i<b_i$ 且对所有 $j\\in [1,i)$ 有 $a_j=b_j$，则前者字典序更小。如果仍然并列，则$\\textit{Pang}$ 的队伍排名更高。\n\n排名确定后，将发放奖励。初始时，排名为 $r$ 的队伍将获得 $\\lfloor 5000/r\\rfloor$ 的幸福值。然后发放奖牌：排名 $1$ 到 $\\lfloor n/10\\rfloor$ 的队伍获得金牌，获得金牌的幸福值为 $1200$；排名 $\\lfloor n/10\\rfloor+1$ 到 $3\\lfloor n/10\\rfloor$ 的队伍获得银牌，获得银牌的幸福值为 $800$；排名 $3\\lfloor n/10\\rfloor+1$ 到 $6\\lfloor n/10\\rfloor$ 的队伍获得铜牌，获得铜牌的幸福值为 $400$。除此之外，对于每道题，最先解决该题的队伍可获得 $800$ 的幸福值。所有队伍和所有题目中，解题时间最小（即最快解出一道题）的队伍可额外获得 $700$ 的幸福值；解题时间最大（即最晚解出一道题）的队伍可额外获得 $500$ 的幸福值。如果有并列，$\\textit{Pang}$ 的队伍总是可以获得该项幸福值。\n\n$\\textit{Pang}$ 参加的那场比赛共有 $n$ 支队伍。他记得所有其他队伍的所有提交（时间和判题结果）。对于每道题，他也记得自己是否会做，以及自己需要多少次被拒绝和多少时间才能解决。\n\n如果 $\\textit{Pang}$ 以最明智的顺序解题，他最多能获得多少幸福值？注意，$\\textit{Pang}$ 不能在比赛开始 $300$ 分钟后再解题（可以恰好在 $300$ 分钟时解题）。一旦 $\\textit{Pang}$ 解出一道题，必须立即提交，然后才能解下一道题，不能故意拖延提交以获得“最后提交”相关的幸福值。", "inputFormat": "第一行包含一个整数 $n$，表示队伍数（$10\\le n\\le 300$，$n$ 是 $10$ 的倍数）。\n\n接下来的 $n-1$ 行，每行描述一支队伍，包含该队伍 $10$ 道题目的状态。对于每道题，如果该队伍没有解决，状态为一个字符“-”；否则，状态为两个整数 $t$ 和 $w$，表示解题时间和该题解出前被拒绝的次数（$1\\le t\\le 300, 0\\le w\\le 10$）。不同题目的状态用英文逗号分隔。\n\n最后一行描述 $\\textit{Pang}$ 的队伍。对于每道题，如果 $\\textit{Pang}$ 不会做，状态为“-”；否则，状态为两个整数 $x$ 和 $y$，表示解决该题所需时间和被拒绝的次数（$1\\le x\\le 300, 0\\le y\\le 10$）。不同题目的状态用英文逗号分隔。\n\n输入中没有多余的空格或其他字符。", "outputFormat": "输出一个整数，表示最大幸福值。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13945", "type": "P", "difficulty": 5, "samples": [["4\n6 1000000007\n1 1 2 4 8 16\n6 1000000007\n597337906 816043578 617563954 668607211 89163513 464203601\n5 1000000007\n2 4 5 6 8\n5 1000000007\n2 4 5 6 7", "5\n-1\n3\n-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "ICPC", "EC Final"], "title": "[EC Final 2019] King", "background": "", "description": "As we all know, the number of $\\textit{Pang}$'s papers follows exponential growth. Therefore, we are curious about $\\textit{King}$ sequence.\n\nYou are given a prime $p$. A sequence $(a_1,a_2,\\ldots,a_n)$ is a $\\textit{King}$ sequence if and only if there is an integer $1\\leq q < p$ such that for all integers $i\\in [2,n]$, $q a_{i-1} \\equiv a_i \\pmod p$.\n\nGiven a sequence $B=(b_1,\\ldots,b_m)$, what is the length of the longest $\\textit{King}$ subsequence of $B$? \n\nA subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.\n\n$Pang$ is super busy recently, so the only thing he wants to know is whether the answer is greater than or equal to $\\frac{n}{2}$. \n\nIf the length of the longest $\\textit{King}$ sequence is less than $\\frac{n}{2}$, output $-1$. Otherwise, output the length of the longest $\\textit{King}$ subsequence.", "inputFormat": "The first line contains an integer $T$ denoting the number of test cases ($1\\le T\\le 1000$).\n\nThe first line in a test case contains two integers $n$ and $p$ ($2\\le n \\le 200000$, $2\\le p \\le 1000000007$, $p$ is a prime). The sum of $n$ over all test cases does not exceed $200000$.\n\nThe second line in a test case contains a sequence $b_1,\\ldots, b_n$ ($1\\le b_i< p$).", "outputFormat": "For each test case, output one line containing the answer which is $-1$ or the length of the longest $\\textit{King}$ subsequence.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2019] King", "background": "", "description": "As we all know, the number of $\\textit{Pang}$'s papers follows exponential growth. Therefore, we are curious about $\\textit{King}$ sequence.\n\nYou are given a prime $p$. A sequence $(a_1,a_2,\\ldots,a_n)$ is a $\\textit{King}$ sequence if and only if there is an integer $1\\leq q < p$ such that for all integers $i\\in [2,n]$, $q a_{i-1} \\equiv a_i \\pmod p$.\n\nGiven a sequence $B=(b_1,\\ldots,b_m)$, what is the length of the longest $\\textit{King}$ subsequence of $B$? \n\nA subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.\n\n$Pang$ is super busy recently, so the only thing he wants to know is whether the answer is greater than or equal to $\\frac{n}{2}$. \n\nIf the length of the longest $\\textit{King}$ sequence is less than $\\frac{n}{2}$, output $-1$. Otherwise, output the length of the longest $\\textit{King}$ subsequence.", "inputFormat": "The first line contains an integer $T$ denoting the number of test cases ($1\\le T\\le 1000$).\n\nThe first line in a test case contains two integers $n$ and $p$ ($2\\le n \\le 200000$, $2\\le p \\le 1000000007$, $p$ is a prime). The sum of $n$ over all test cases does not exceed $200000$.\n\nThe second line in a test case contains a sequence $b_1,\\ldots, b_n$ ($1\\le b_i< p$).", "outputFormat": "For each test case, output one line containing the answer which is $-1$ or the length of the longest $\\textit{King}$ subsequence.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2019] King", "background": null, "description": "众所周知，$\\textit{Pang}$ 的论文数量呈指数增长。因此，我们对 $\\textit{King}$ 序列产生了好奇。\n\n给定一个质数 $p$。当且仅当存在一个整数 $1\\leq q < p$，使得对于所有整数 $i\\in [2,n]$，都有 $q a_{i-1} \\equiv a_i \\pmod p$，则序列 $(a_1,a_2,\\ldots,a_n)$ 被称为 $\\textit{King}$ 序列。\n\n给定一个序列 $B=(b_1,\\ldots,b_m)$，请问 $B$ 的最长 $\\textit{King}$ 子序列的长度是多少？\n\n子序列指的是从原序列中删除若干元素（可以为零），且不改变剩余元素的相对顺序后得到的序列。\n\n$Pang$ 最近非常忙，所以他只关心答案是否大于等于 $\\frac{n}{2}$。\n\n如果最长 $\\textit{King}$ 序列的长度小于 $\\frac{n}{2}$，输出 $-1$。否则，输出最长 $\\textit{King}$ 子序列的长度。", "inputFormat": "第一行包含一个整数 $T$，表示测试用例的数量（$1\\le T\\le 1000$）。\n\n每个测试用例的第一行包含两个整数 $n$ 和 $p$（$2\\le n \\le 200000$，$2\\le p \\le 1000000007$，$p$ 为质数）。所有测试用例中 $n$ 的总和不超过 $200000$。\n\n每个测试用例的第二行包含一个长度为 $n$ 的序列 $b_1,\\ldots, b_n$（$1\\le b_i< p$）。", "outputFormat": "对于每个测试用例，输出一行答案，若最长 $\\textit{King}$ 子序列长度小于 $\\frac{n}{2}$，则输出 $-1$，否则输出最长 $\\textit{King}$ 子序列的长度。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13946", "type": "P", "difficulty": 7, "samples": [["3\n1 0 0\n0 1 0\n0 0 1", "0.875000000000"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["计算几何", "2019", "Special Judge", "三维计算几何", "ICPC", "EC Final"], "title": "[EC Final 2019] Moon", "background": "", "description": "Let $S$ be a sphere with radius $1$ and center $(0, 0, 0)$. Let $a_0,a_1,\\ldots,a_n$ be $n+1$ points on the surface of $S$. The positions of $a_1,\\ldots,a_n$ are fixed while the position of $a_0$ is a uniform random point on the surface of $S$. Let $f$ be $1$ if there exists a hemisphere of $S$ that contains $a_0,\\ldots,a_n$ and $0$ otherwise. Calculate the expected value of $f$.", "inputFormat": "The first line contains an integer $n$ denoting the number of points ($0\\le n\\le 100000$).\n\nThe $i$-th line of the next $n$ lines contains three integers $x, y, z$ denoting the point $a_i=\\left(\\frac{x}{\\sqrt{x^2+y^2+z^2}}, \\frac{y}{\\sqrt{x^2+y^2+z^2}}, \\frac{z}{\\sqrt{x^2+y^2+z^2}}\\right)$ ($-1000000\\le x, y, z\\le 1000000, x^2+y^2+z^2\\neq 0$).\n\nIt is guaranteed that $a_1,\\ldots,a_n$ are distinct.", "outputFormat": "Output the answer.\n\nThe answer will be considered correct if its absolute or relative error doesn't exceed $10 ^{-6}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2019] Moon", "background": "", "description": "Let $S$ be a sphere with radius $1$ and center $(0, 0, 0)$. Let $a_0,a_1,\\ldots,a_n$ be $n+1$ points on the surface of $S$. The positions of $a_1,\\ldots,a_n$ are fixed while the position of $a_0$ is a uniform random point on the surface of $S$. Let $f$ be $1$ if there exists a hemisphere of $S$ that contains $a_0,\\ldots,a_n$ and $0$ otherwise. Calculate the expected value of $f$.", "inputFormat": "The first line contains an integer $n$ denoting the number of points ($0\\le n\\le 100000$).\n\nThe $i$-th line of the next $n$ lines contains three integers $x, y, z$ denoting the point $a_i=\\left(\\frac{x}{\\sqrt{x^2+y^2+z^2}}, \\frac{y}{\\sqrt{x^2+y^2+z^2}}, \\frac{z}{\\sqrt{x^2+y^2+z^2}}\\right)$ ($-1000000\\le x, y, z\\le 1000000, x^2+y^2+z^2\\neq 0$).\n\nIt is guaranteed that $a_1,\\ldots,a_n$ are distinct.", "outputFormat": "Output the answer.\n\nThe answer will be considered correct if its absolute or relative error doesn't exceed $10 ^{-6}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2019] Moon", "background": null, "description": "设 $S$ 为一个半径为 $1$，中心为 $(0, 0, 0)$ 的球。给定 $n+1$ 个点 $a_0, a_1, \\ldots, a_n$，它们都位于 $S$ 的表面上。点 $a_1, \\ldots, a_n$ 的位置是固定的，而 $a_0$ 的位置是在 $S$ 表面上均匀随机选取的。定义函数 $f$，若存在一个 $S$ 的半球包含 $a_0, \\ldots, a_n$，则 $f=1$，否则 $f=0$。请计算 $f$ 的期望值。", "inputFormat": "第一行包含一个整数 $n$，表示点的数量（$0\\le n\\le 100000$）。\n\n接下来的 $n$ 行中，第 $i$ 行包含三个整数 $x, y, z$，表示点 $a_i=\\left(\\frac{x}{\\sqrt{x^2+y^2+z^2}}, \\frac{y}{\\sqrt{x^2+y^2+z^2}}, \\frac{z}{\\sqrt{x^2+y^2+z^2}}\\right)$（$-1000000\\le x, y, z\\le 1000000, x^2+y^2+z^2\\neq 0$）。\n\n保证 $a_1, \\ldots, a_n$ 互不相同。", "outputFormat": "输出答案。\n\n如果你的答案的绝对误差或相对误差不超过 $10^{-6}$，则视为正确。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13947", "type": "P", "difficulty": 6, "samples": [["5\n5 3\n3 4 2 1 5\n5 4\n4 2 1 3 5\n5 2\n4 5 3 1 2\n5 3\n4 3 2 1 5\n5 2\n2 3 1 5 4", "6\n1\n4\n6\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "线段树", "分治", "ICPC", "笛卡尔树", "EC Final"], "title": "[EC Final 2019] Permutation", "background": "", "description": "You are given a permutation $p_1, p_2, \\dots, p_n$. You can do the following operations repeatedly:\n\n- Choose an interval $p_{l}, p_{l+1}, \\dots, p_{l+c} (l \\geq 1, l+c \\leq n)$ where $p_l$ is the smallest element in this interval, you can permutate $p_{l+1}, \\dots, p_{l+c}$ in arbitrary way.\n- Choose an interval $p_{l}, p_{l+1}, \\dots, p_{l+c} (l\\geq 1, l+c \\leq n)$ where $p_{l+c}$ is the smallest element in this interval, you can permutate $p_{l}, \\dots, p_{l+c-1}$ in arbitrary way.\n\nYou want to know how many distinct permutations you can get using operations. The answer can be large, output the answer modulo $998244353$.", "inputFormat": "The first line contains an integer $T$ denoting the number of test cases ($1\\le T\\le 100000$).\n\nThe first line in a test case contains two integers $n$ and $c$ ($2\\le c \\le 500000$, $2\\le n\\le 500000$). The sum of $n$ over all test cases does not exceed $500000$.\n\nThe second line in a test case contains a permutation $p_1,\\ldots, p_n$ ($1\\le p_i\\le n$).", "outputFormat": "For each test case, output one line containing the answer modulo $998244353$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2019] Permutation", "background": "", "description": "You are given a permutation $p_1, p_2, \\dots, p_n$. You can do the following operations repeatedly:\n\n- Choose an interval $p_{l}, p_{l+1}, \\dots, p_{l+c} (l \\geq 1, l+c \\leq n)$ where $p_l$ is the smallest element in this interval, you can permutate $p_{l+1}, \\dots, p_{l+c}$ in arbitrary way.\n- Choose an interval $p_{l}, p_{l+1}, \\dots, p_{l+c} (l\\geq 1, l+c \\leq n)$ where $p_{l+c}$ is the smallest element in this interval, you can permutate $p_{l}, \\dots, p_{l+c-1}$ in arbitrary way.\n\nYou want to know how many distinct permutations you can get using operations. The answer can be large, output the answer modulo $998244353$.", "inputFormat": "The first line contains an integer $T$ denoting the number of test cases ($1\\le T\\le 100000$).\n\nThe first line in a test case contains two integers $n$ and $c$ ($2\\le c \\le 500000$, $2\\le n\\le 500000$). The sum of $n$ over all test cases does not exceed $500000$.\n\nThe second line in a test case contains a permutation $p_1,\\ldots, p_n$ ($1\\le p_i\\le n$).", "outputFormat": "For each test case, output one line containing the answer modulo $998244353$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2019] Permutation", "background": null, "description": "给定一个排列 $p_1, p_2, \\dots, p_n$。你可以重复进行以下操作：\n\n- 选择一个区间 $p_{l}, p_{l+1}, \\dots, p_{l+c}$（$l \\geq 1, l+c \\leq n$），如果 $p_l$ 是该区间中的最小元素，则你可以任意排列 $p_{l+1}, \\dots, p_{l+c}$。\n- 选择一个区间 $p_{l}, p_{l+1}, \\dots, p_{l+c}$（$l \\geq 1, l+c \\leq n$），如果 $p_{l+c}$ 是该区间中的最小元素，则你可以任意排列 $p_{l}, \\dots, p_{l+c-1}$。\n\n你想知道通过这些操作，最多可以得到多少种不同的排列。答案可能很大，请输出对 $998244353$ 取模后的结果。", "inputFormat": "第一行包含一个整数 $T$，表示测试用例的数量（$1\\le T\\le 100000$）。\n\n每个测试用例的第一行包含两个整数 $n$ 和 $c$（$2\\le c \\le 500000$，$2\\le n\\le 500000$）。所有测试用例中 $n$ 的总和不超过 $500000$。\n\n每个测试用例的第二行包含一个排列 $p_1,\\ldots, p_n$（$1\\le p_i\\le n$）。", "outputFormat": "对于每个测试用例，输出一行答案，对 $998244353$ 取模。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13948", "type": "P", "difficulty": 7, "samples": [["6 8\n1 2 1\n2 3 10\n3 4 100\n4 5 1000\n5 6 10000\n6 1 100000\n1 4 1000000\n1 5 10000000", "12343461"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "Kruskal 重构树", "平面图", "ICPC", "EC Final"], "title": "[EC Final 2019] All Pair Maximum Flow", "background": "", "description": "You are given an undirected graph. You want to compute the maximum flow from each vertex to every other vertex.\n\nThe graph is special. You can regard it as a convex polygon with $n$ points (vertices) and some line segments (edges) connecting them. The vertices are labeled from $1$ to $n$ in the clockwise order. The line segments can only intersect each other at the vertices.\n\nEach edge has a capacity constraint. \n\nDenote the maximum flow from $s$ to $t$ by $f(s,t)$. Output $\\left(\\sum_{s=1}^n \\sum_{t=s+1}^n f(s,t) \\right) \\bmod 998244353$.", "inputFormat": "The first line contains two integers $n$ and $m$, representing the number of vertices and edges ($3\\le n\\le 200000, n\\le m\\le 400000$).\n\nEach of the next $m$ lines contains three integers $u, v, w$ denoting the two endpoints of an edge and its capacity ($1\\le u, v\\le n, 0\\le w\\le 1000000000$).\n\nIt is guaranteed there are no multiple edges and self-loops.\n\nIt is guaranteed that there is an edge between vertex $i$ and vertex $(i\\bmod n)+1$ for all $i=1,2,\\ldots, n$.", "outputFormat": "Output the answer in one line.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2019] All Pair Maximum Flow", "background": "", "description": "You are given an undirected graph. You want to compute the maximum flow from each vertex to every other vertex.\n\nThe graph is special. You can regard it as a convex polygon with $n$ points (vertices) and some line segments (edges) connecting them. The vertices are labeled from $1$ to $n$ in the clockwise order. The line segments can only intersect each other at the vertices.\n\nEach edge has a capacity constraint. \n\nDenote the maximum flow from $s$ to $t$ by $f(s,t)$. Output $\\left(\\sum_{s=1}^n \\sum_{t=s+1}^n f(s,t) \\right) \\bmod 998244353$.", "inputFormat": "The first line contains two integers $n$ and $m$, representing the number of vertices and edges ($3\\le n\\le 200000, n\\le m\\le 400000$).\n\nEach of the next $m$ lines contains three integers $u, v, w$ denoting the two endpoints of an edge and its capacity ($1\\le u, v\\le n, 0\\le w\\le 1000000000$).\n\nIt is guaranteed there are no multiple edges and self-loops.\n\nIt is guaranteed that there is an edge between vertex $i$ and vertex $(i\\bmod n)+1$ for all $i=1,2,\\ldots, n$.", "outputFormat": "Output the answer in one line.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2019] All Pair Maximum Flow", "background": null, "description": "给定一个无向图。你需要计算每一对顶点之间的最大流。\n\n该图具有特殊结构。你可以将其视为一个有 $n$ 个点（顶点）的凸多边形，并有若干线段（边）连接这些顶点。顶点按顺时针顺序从 $1$ 到 $n$ 编号。线段只能在顶点处相交。\n\n每条边都有容量限制。\n\n记从 $s$ 到 $t$ 的最大流为 $f(s,t)$。请输出 $\\left(\\sum_{s=1}^n \\sum_{t=s+1}^n f(s,t) \\right) \\bmod 998244353$。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，表示顶点数和边数（$3\\le n\\le 200000, n\\le m\\le 400000$）。\n\n接下来的 $m$ 行，每行包含三个整数 $u, v, w$，表示一条边的两个端点和容量（$1\\le u, v\\le n, 0\\le w\\le 1000000000$）。\n\n保证没有重边和自环。\n\n保证对于所有 $i=1,2,\\ldots, n$，顶点 $i$ 和顶点 $(i\\bmod n)+1$ 之间存在一条边。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13949", "type": "P", "difficulty": 7, "samples": [["2 2 1\n1 2\n2 1", "6"], ["2 2 2\n1 2\n2 1", "30"], ["3 3 3\n1 2\n2 1\n1 3", "103"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "ICPC", "EC Final"], "title": "[EC Final 2019] Travel", "background": "", "description": "\"I'm tired of seeing the same scenery in the world.\" --- $\\textit{Philosopher Pang}$\n\n$\\textit{Pang}$'s world can be simplified as a directed graph $G$ with $n$ vertices and $m$ edges.\n\nA $\\textit{path}$ in $G$ is an ordered list of vertices $(v_0,\\ldots,v_{t-1})$ for some non-negative integer $t$ such that $v_iv_{i+1}$ is an edge in $G$ for all $0\\le i<t-1$. A $\\textit{path}$ can be empty in this problem.\n\nA $\\textit{cycle}$ in $G$ is an ordered list of distinct vertices $(v_0,\\ldots,v_{t-1})$ for some positive integer $t \\geq 2$ such that $v_iv_{(i+1) \\bmod t}$ is an edge in $G$ for all $0\\le i<t$. All circular shifts of a cycle are considered the same.\n\n$G$ satisfies the following property: Every vertex is in at most one cycle.\n\nGiven a fixed integer $k$, count the number of pairs $(P_1,P_2)$ modulo $998244353$ such that \n- $P_1,P_2$ are paths;\n- For every vertex $v\\in G$, $v$ is in $P_1$ or $P_2$;\n- Let $c(P, v)$ be the number of occurrences of $v$ in path $P$. For every vertex $v$ of $G$, $c(P_1,v)+c(P_2, v)\\le k$.  ", "inputFormat": "The first line contains $3$ integers $n$, $m$ and $k$ ($1\\le n\\le 2000, 0\\le m\\le 4000, 0\\le k\\le 1000000000$).\n\nEach of the next $m$ lines contains two integers $a$ and $b$, denoting an edge from vertex $a$ to $b$ ($1\\le a, b\\le n, a\\neq b$). \n\nNo two edges connect the same pair of vertices in the same direction.", "outputFormat": "Output one integer --- the number of pairs $(P_1,P_2)$ modulo $998244353$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2019] Travel", "background": "", "description": "\"I'm tired of seeing the same scenery in the world.\" --- $\\textit{Philosopher Pang}$\n\n$\\textit{Pang}$'s world can be simplified as a directed graph $G$ with $n$ vertices and $m$ edges.\n\nA $\\textit{path}$ in $G$ is an ordered list of vertices $(v_0,\\ldots,v_{t-1})$ for some non-negative integer $t$ such that $v_iv_{i+1}$ is an edge in $G$ for all $0\\le i<t-1$. A $\\textit{path}$ can be empty in this problem.\n\nA $\\textit{cycle}$ in $G$ is an ordered list of distinct vertices $(v_0,\\ldots,v_{t-1})$ for some positive integer $t \\geq 2$ such that $v_iv_{(i+1) \\bmod t}$ is an edge in $G$ for all $0\\le i<t$. All circular shifts of a cycle are considered the same.\n\n$G$ satisfies the following property: Every vertex is in at most one cycle.\n\nGiven a fixed integer $k$, count the number of pairs $(P_1,P_2)$ modulo $998244353$ such that \n- $P_1,P_2$ are paths;\n- For every vertex $v\\in G$, $v$ is in $P_1$ or $P_2$;\n- Let $c(P, v)$ be the number of occurrences of $v$ in path $P$. For every vertex $v$ of $G$, $c(P_1,v)+c(P_2, v)\\le k$.  ", "inputFormat": "The first line contains $3$ integers $n$, $m$ and $k$ ($1\\le n\\le 2000, 0\\le m\\le 4000, 0\\le k\\le 1000000000$).\n\nEach of the next $m$ lines contains two integers $a$ and $b$, denoting an edge from vertex $a$ to $b$ ($1\\le a, b\\le n, a\\neq b$). \n\nNo two edges connect the same pair of vertices in the same direction.", "outputFormat": "Output one integer --- the number of pairs $(P_1,P_2)$ modulo $998244353$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2019] Travel", "background": null, "description": "“我已经厌倦了世界上相同的风景。”——$\\textit{Philosopher Pang}$\n\n$\\textit{Pang}$ 的世界可以简化为一个有向图 $G$，包含 $n$ 个顶点和 $m$ 条边。\n\n在 $G$ 中，一条 $\\textit{路径}$ 是一个有序顶点序列 $(v_0,\\ldots,v_{t-1})$，其中 $t$ 是某个非负整数，满足对于所有 $0\\le i<t-1$，$v_iv_{i+1}$ 是 $G$ 的一条边。在本题中，路径可以为空。\n\n在 $G$ 中，一个 $\\textit{环}$ 是一个由不同顶点组成的有序序列 $(v_0,\\ldots,v_{t-1})$，其中 $t$ 是某个满足 $t\\geq 2$ 的正整数，且对于所有 $0\\le i<t$，$v_iv_{(i+1) \\bmod t}$ 是 $G$ 的一条边。所有环的循环移位视为同一个环。\n\n$G$ 满足如下性质：每个顶点至多属于一个环。\n\n给定一个固定整数 $k$，请计算满足以下条件的有序对 $(P_1,P_2)$ 的数量，对 $998244353$ 取模：\n- $P_1,P_2$ 都是路径；\n- 对于 $G$ 的每个顶点 $v$，$v$ 必须出现在 $P_1$ 或 $P_2$ 中；\n- 记 $c(P, v)$ 为顶点 $v$ 在路径 $P$ 中出现的次数。对于 $G$ 的每个顶点 $v$，有 $c(P_1,v)+c(P_2, v)\\le k$。", "inputFormat": "第一行包含 $3$ 个整数 $n$、$m$ 和 $k$（$1\\le n\\le 2000, 0\\le m\\le 4000, 0\\le k\\le 1000000000$）。\n\n接下来的 $m$ 行，每行包含两个整数 $a$ 和 $b$，表示一条从顶点 $a$ 到顶点 $b$ 的有向边（$1\\le a, b\\le n, a\\neq b$）。\n\n没有两条边连接同一对顶点且方向相同。", "outputFormat": "输出一个整数，表示满足条件的有序对 $(P_1,P_2)$ 的数量，对 $998244353$ 取模。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13950", "type": "P", "difficulty": 4, "samples": [["4\n1 1 1 2\n1 1 1 1", "4"], ["4\n1 1 1 1\n1 1 1 2", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "ICPC", "EC Final"], "title": "[EC Final 2019] Value", "background": "", "description": "$\\textit{Pang}$ believes that one cannot make an omelet without breaking eggs.\n\nFor a subset $A$ of $\\{1,2,\\ldots,n\\}$, we calculate the score of $A$ as follows:\n- Initialize the score as $0$.\n- For any $i\\in A$, add $a_i$ to the score.\n- For any pair of integers $(i, j)$ satisfying $i\\ge 2$, $j\\ge 2$, $i\\in A$ and $j\\in A$, if there exists positive integer $k > 1$ such that $i^k=j$, subtract $b_j$ from the score.\n\nFind the maximum possible score over the choice of $A$. ", "inputFormat": "The first line contains a single integer $n$ $(1\\le n\\le 100000)$.\n\nThe second line contains $n$ integers $a_1,a_2,\\ldots,a_n$ $(1\\le a_i\\le 1000000000)$.\n\nThe third line contains $n$ integers $b_1,b_2,\\ldots,b_n$ $(1\\le b_i\\le 1000000000)$.", "outputFormat": "Print a single integer $x$ --- the maximum possible score.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2019] Value", "background": "", "description": "$\\textit{Pang}$ believes that one cannot make an omelet without breaking eggs.\n\nFor a subset $A$ of $\\{1,2,\\ldots,n\\}$, we calculate the score of $A$ as follows:\n- Initialize the score as $0$.\n- For any $i\\in A$, add $a_i$ to the score.\n- For any pair of integers $(i, j)$ satisfying $i\\ge 2$, $j\\ge 2$, $i\\in A$ and $j\\in A$, if there exists positive integer $k > 1$ such that $i^k=j$, subtract $b_j$ from the score.\n\nFind the maximum possible score over the choice of $A$. ", "inputFormat": "The first line contains a single integer $n$ $(1\\le n\\le 100000)$.\n\nThe second line contains $n$ integers $a_1,a_2,\\ldots,a_n$ $(1\\le a_i\\le 1000000000)$.\n\nThe third line contains $n$ integers $b_1,b_2,\\ldots,b_n$ $(1\\le b_i\\le 1000000000)$.", "outputFormat": "Print a single integer $x$ --- the maximum possible score.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2019] Value", "background": null, "description": "$\\textit{Pang}$ 认为“要做蛋卷，必先打破鸡蛋”。\n\n对于集合 $\\{1,2,\\ldots,n\\}$ 的一个子集 $A$，我们按照如下方式计算 $A$ 的得分：\n- 初始得分为 $0$。\n- 对于任意 $i\\in A$，将 $a_i$ 加入得分。\n- 对于任意满足 $i\\ge 2$、$j\\ge 2$、$i\\in A$ 且 $j\\in A$ 的整数对 $(i, j)$，如果存在正整数 $k>1$ 使得 $i^k = j$，则从得分中减去 $b_j$。\n\n请你求出所有 $A$ 的最大可能得分。", "inputFormat": "第一行包含一个整数 $n$，表示元素个数 $(1\\le n\\le 100000)$。\n\n第二行包含 $n$ 个整数 $a_1,a_2,\\ldots,a_n$，表示每个元素的加分值 $(1\\le a_i\\le 1000000000)$。\n\n第三行包含 $n$ 个整数 $b_1,b_2,\\ldots,b_n$，表示每个元素的扣分值 $(1\\le b_i\\le 1000000000)$。", "outputFormat": "输出一个整数 $x$，表示最大可能得分。", "hint": "\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13951", "type": "P", "difficulty": 4, "samples": [["4\n2 5\n.OO..\nO..O.\n1 3\nO.O\n1 3\n.O.\n2 3\nOOO\nOOO", "3\n1\n0\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "ICPC", "南京"], "title": "[ICPC 2023 Nanjing R] 酷，昨日四次重现", "background": "", "description": "继 2018，2019，2020，2021 和 2022 年成功承办赛事之后，南京航空航天大学（NUAA）将连续第六年承办国际大学生程序设计竞赛（ICPC）。\n\n在 2018 与 2019 年，“中二之力”队与“三个顶俩”队为清华大学赢得了冠军。在 2020，2021 与 2022 年，北京大学的“逆十字”队赢得三连冠。今年，将会有约 $330$ 支队伍参与南京站的竞赛。本次竞赛将会颁发至多 $33$ 项金奖，$66$ 项银奖与 $99$ 项铜奖（数字仅供参考）。让我们期待选手们出色的表现！\n\n更棒的是，因为疫情已经结束，我们终于可以相聚南京参与这场精彩的比赛。我们想要感谢竞赛组委会与志愿者们的努力付出。感谢你们为本次竞赛做出的贡献！\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/p9rf7tg8.png)\n2018 国际大学生程序设计竞赛亚洲区域赛（南京站）\n:::\n\n在 2018 年的竞赛中，K 题《袋鼠谜题》要求选手为以下游戏构造一个操作序列：\n\n> 谜题由一个 $n$ 行 $m$ 列的网格（$1 \\le n, m \\le 20$）组成，且有一些（至少 $2$ 只）袋鼠位于网格中。玩家的目标是控制袋鼠并把它们聚集在同一个格子中。一些格子里有墙，袋鼠无法进入这些有墙的格子，而其它格子是空的。袋鼠可以从一个空格子移动到上，下，左，右相邻的另一个空格子中。    \n> 游戏开始时，每个空格子里都有一只袋鼠。玩家可以通过键盘上 U，D，L，R 四个按键控制袋鼠的移动。所有袋鼠会同时根据您按下的按键移动。    \n> 选手需要构造一个长度至多为 $5 \\times 10^4$ 且由 U，D，L，R 组成的操作序列以达成目标。\n\n在 2020 年的竞赛中，A 题《啊，昨日重现》要求选手构造一张输入地图，以证明以下代码并不是上述问题的解：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstring s = \"UDLR\";\nint main()\n{\n  srand(time(NULL));\n  for (int i = 1; i <= 50000; i++) putchar(s[rand() % 4]);\n  return 0;\n}\n```\n\n在 2021 年的竞赛中，A 题《呀，昨日再次重现》同样要求选手为以下游戏构造操作序列：\n\n> 本题中，网格中的每个格子都有恰好一只袋鼠。您需要构造一个仅由字符 `U`，`D`，`L` 和 `R` 组成的操作序列。在应用该操作序列后，所有袋鼠必须聚集在指定格子 $(a,b)$ 中。操作序列的长度不能超过 $3(n-1)$。同往常一样，所有袋鼠会根据您的命令同时移动。\n\n在 2022 年的竞赛中，A 题《停停，昨日请不要再重现》要求选手解决以下计数问题：\n\n> 本题中，网格中的每个格子（除了一个格子是洞）都恰好有一只袋鼠。给定操作序列，所有走出网格外或踩到洞上的袋鼠都会被移除。给定所有操作后剩余的袋鼠数量，求有几个位置可能是洞。\n\n在 2023 年的竞赛中，袋鼠题又回来啦！我们不知道为什么命题组的成员们那么喜欢袋鼠，但题目如下：\n\n给定一张 $n$ 行 $m$ 列的网格，每个格子要么是洞，要么是空地。每个空地都恰好有一只袋鼠。\n\n相似地，袋鼠可以被键盘上的 U，D，L，R 键控制。所有袋鼠会同时根据按下的按键移动。具体来说，对于一只位于第 $i$ 行第 $j$ 列的格子（用 $(i,j)$ 表示）上的袋鼠：\n\n- 按键 U：它会移动到 $(i-1,j)$。\n- 按键 D：它会移动到 $(i+1,j)$。\n- 按键 L：它会移动到 $(i,j-1)$。\n- 按键 R：它会移动到 $(i,j+1)$。\n\n如果一只袋鼠踩到了洞或者移动到了网格外面，它将被从网格上移除。如果完成一系列操作后（操作序列可以为空）恰有一只袋鼠留在网格上，那么这只袋鼠就是赢家。\n\n您需要解决的问题是：对于每只袋鼠，判断是否存在一个操作序列使得它成为赢家。输出可能成为赢家的袋鼠总数。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入两个整数 $n$ 与 $m$（$1 \\le n, m \\le 10^3$，$1 \\le n \\times m \\le 10^3$）表示网格的行数和列数。\n\n对于接下来 $n$ 行，第 $i$ 行输入一个长度为 $m$ 的字符串 $s_{i, 1}s_{i, 2} \\cdots s_{i, m}$，每个字符要么是 $\\texttt{.}$（点号，ascii: 46）要么是 $\\texttt{O}$（大写字母，ascii: 79）。如果 $s_{i, j}$ 是 $\\texttt{.}$ 则格子 $(i, j)$ 是空地；如果 $s_{i, j}$ 是 $\\texttt{O}$ 则格子 $(i, j)$ 是洞。\n\n保证所有数据  $n \\times m$ 之和不超过 $5 \\times 10^3$。", "outputFormat": "每组数据输出一行一个整数，表示共有几只袋鼠满足存在一个操作序列使得它成为赢家。", "hint": "样例数据解释如下。我们用 `W` 表示接下来成为赢家的袋鼠，用 `K` 表示其它袋鼠。\n\n对于第一组样例数据，初始位于 $(1, 4)$，$(1, 5)$ 和 $(2, 5)$ 的袋鼠可能成为赢家。以下展示可能的操作序列：\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/tme0c3nq.png)\n:::\n\n对于第二组样例数据，因为只有一只袋鼠，无需任何操作即可让它成为赢家。\n\n对于第三组样例数据，因为任何操作都会让两只袋鼠同时被移除，所以没有任何可能的赢家。\n\n对于第四组样例数据，因为没有袋鼠，所以没有任何可能的赢家。", "locale": "zh-CN", "translations": {"en": {"title": "[ICPC 2023 Nanjing R] Cool, It's Yesterday Four Times More", "background": "", "description": "After the great success in 2018, 2019, 2020, 2021 and 2022, Nanjing University of Aeronautics and Astronautics (NUAA) will host the $\\textit{International Collegiate Programming Contest}$ (ICPC) Nanjing regional for the sixth time in a row.\n\nTeam $\\textbf{\\textit{Power of Two}}$ and team $\\textbf{\\textit{Three Hold Two}}$ won the champion title for Tsinghua University in 2018 and 2019. In 2020, 2021 and 2022, team $\\textbf{\\textit{Inverted Cross}}$ from Peking University won the three-peat champion titles. This year, there are around $330$ teams participating in the contest. There are at most $33$ gold medals, $66$ silver medals and $99$ bronze medals that will be awarded (note that these numbers are for reference only). We are looking forward to seeing participants' outstanding performance!\n\nWhat's even better is that, as the pandemic has come to an end, we can finally gather in Nanjing to participate in this wonderful contest. We'd like to be grateful for the hard work done by all staff and volunteers for this contest. Thank you all for your great contribution to this contest!\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/p9rf7tg8.png)\nThe 2018 ICPC Asia Nanjing Regional Contest\n:::\n\nIn the 2018 contest, problem K, $\\textbf{\\textit{Kangaroo Puzzle}}$, requires the contestants to construct an operation sequence for the game:\n\n> The puzzle is a grid with $n$ rows and $m$ columns ($1 \\le n, m \\le 20$) and there are some (at least $2$) kangaroos standing in the puzzle. The player's goal is to control them to get together. There are some walls in some cells and the kangaroos cannot enter the cells with walls. The other cells are empty. The kangaroos can move from an empty cell to an adjacent empty cell in four directions: up, down, left, and right.    \n> There is exactly one kangaroo in every empty cell in the beginning and the player can control the kangaroos by pressing the button U, D, L, R on the keyboard. The kangaroos will move simultaneously according to the button you press.    \n> The contestant needs to construct an operating sequence of at most $5 \\times 10^4$ steps consisting of U, D, L, R only to achieve the goal.\n\nIn the 2020 contest, problem A, $\\textbf{\\textit{Ah, It's Yesterday Once More}}$, requires the contestants to construct an input map to hack the following code of the problem described before:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstring s = \"UDLR\";\nint main()\n{\n  srand(time(NULL));\n  for (int i = 1; i <= 50000; i++) putchar(s[rand() % 4]);\n  return 0;\n}\n```\n\nIn the 2021 contest, problem A, $\\textbf{\\textit{Oops, It's Yesterday Twice More}}$, also requires the contestants to construct an operation sequence for the game: \n\n> This time, every cell in the grid stands exactly one kangaroo. You need to construct an operating sequence consisting only of characters `U`, `D`, `L`, and `R`. After applying it, you must make sure every kangaroo will gather at the specific cell $(a,b)$. The length of the operating sequence cannot exceed $3(n-1)$. As always, the kangaroos will move simultaneously according to the operation you command.\n\nIn the 2022 contest, problem A, $\\textbf{\\textit{Stop, Yesterday Please No More}}$, asks the contestants to solve the following counting problem:\n\n> This time, every cell (except one which is a hole) in the grid stands exactly one kangaroo. The operating sequence is given and all kangaroos stepping out of the grid or onto the hole will be removed. Given the number of kangaroos remaining after all operations, count the number of positions which might be the hole.\n\nNow, in the 2023 contest, the kangaroo problem is back again! We don't know why problem setters are so obsessed with kangaroos but the problem is as follows:\n\nYou are given a grid with $n$ rows and $m$ columns. Each cell is either a hole or empty. In each empty cell stands exactly one kangaroo.\n\nSimilarly, the kangaroos are controlled by pressing the button U, D, L, R on the keyboard. All kangaroos will move simultaneously according to the button pressed. Specifically, for any kangaroo located in the cell on the $i$-th row and the $j$-th column, indicated by $(i,j)$:\n\n- Button U: it will move to $(i-1,j)$.\n- Button D: it will move to $(i+1,j)$.\n- Button L: it will move to $(i,j-1)$.\n- Button R: it will move to $(i,j+1)$.\n\nIf a kangaroo steps onto a hole or steps out of the grid, it will be removed from the grid. If after applying a sequence of operations (possibly an empty sequence) there is exactly one kangaroo remaining on the grid, that kangaroo becomes the winner.\n\nThe problem is: for each kangaroo, determine if there exists a sequence of operations to make it the winner. Output the total number of kangaroos which are possible to become the winner.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n, m \\le 10^3$, $1 \\le n \\times m \\le 10^3$) indicating the number of rows and columns of the grid.\n\nFor the following $n$ lines, the $i$-th line contains a string $s_{i, 1}s_{i, 2} \\cdots s_{i, m}$ of length $m$ where each character is either $\\texttt{.}$ (dot, ascii: 46) or $\\texttt{O}$ (capitalized letter, ascii: 79). If $s_{i, j}$ is a $\\texttt{.}$ then grid $(i, j)$ is empty; If $s_{i, j}$ is a $\\texttt{O}$ then grid $(i, j)$ is a hole.\n\nIt's guaranteed that the sum of $n \\times m$ of all test cases will not exceed $5 \\times 10^3$.", "outputFormat": "For each test case output one line containing one integer indicating the number of kangaroos for which there exists a sequence of operations to make it the winner.", "hint": "The sample test cases are explained below. We use `W` to indicate the kangaroo which later becomes winner and `K` to indicate the other kangaroos.\n\nFor the first sample test case, kangaroos initially located at $(1, 4)$, $(1, 5)$ and $(2, 5)$ may become winners. Possible sequences of operations are shown as follows:\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/tme0c3nq.png)\n:::\n\nFor the second sample test case, as there is only one kangaroo, no operation is needed for it to become the winner.\n\nFor the third sample test case, as any operation will remove the two kangaroos at the same time, there is no possible winner.\n\nFor the fourth sample test case, as there is no kangaroo, there is no possible winner.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Nanjing R] 酷，昨日四次重现", "background": "", "description": "继 2018，2019，2020，2021 和 2022 年成功承办赛事之后，南京航空航天大学（NUAA）将连续第六年承办国际大学生程序设计竞赛（ICPC）。\n\n在 2018 与 2019 年，“中二之力”队与“三个顶俩”队为清华大学赢得了冠军。在 2020，2021 与 2022 年，北京大学的“逆十字”队赢得三连冠。今年，将会有约 $330$ 支队伍参与南京站的竞赛。本次竞赛将会颁发至多 $33$ 项金奖，$66$ 项银奖与 $99$ 项铜奖（数字仅供参考）。让我们期待选手们出色的表现！\n\n更棒的是，因为疫情已经结束，我们终于可以相聚南京参与这场精彩的比赛。我们想要感谢竞赛组委会与志愿者们的努力付出。感谢你们为本次竞赛做出的贡献！\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/p9rf7tg8.png)\n2018 国际大学生程序设计竞赛亚洲区域赛（南京站）\n:::\n\n在 2018 年的竞赛中，K 题《袋鼠谜题》要求选手为以下游戏构造一个操作序列：\n\n> 谜题由一个 $n$ 行 $m$ 列的网格（$1 \\le n, m \\le 20$）组成，且有一些（至少 $2$ 只）袋鼠位于网格中。玩家的目标是控制袋鼠并把它们聚集在同一个格子中。一些格子里有墙，袋鼠无法进入这些有墙的格子，而其它格子是空的。袋鼠可以从一个空格子移动到上，下，左，右相邻的另一个空格子中。    \n> 游戏开始时，每个空格子里都有一只袋鼠。玩家可以通过键盘上 U，D，L，R 四个按键控制袋鼠的移动。所有袋鼠会同时根据您按下的按键移动。    \n> 选手需要构造一个长度至多为 $5 \\times 10^4$ 且由 U，D，L，R 组成的操作序列以达成目标。\n\n在 2020 年的竞赛中，A 题《啊，昨日重现》要求选手构造一张输入地图，以证明以下代码并不是上述问题的解：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstring s = \"UDLR\";\nint main()\n{\n  srand(time(NULL));\n  for (int i = 1; i <= 50000; i++) putchar(s[rand() % 4]);\n  return 0;\n}\n```\n\n在 2021 年的竞赛中，A 题《呀，昨日再次重现》同样要求选手为以下游戏构造操作序列：\n\n> 本题中，网格中的每个格子都有恰好一只袋鼠。您需要构造一个仅由字符 `U`，`D`，`L` 和 `R` 组成的操作序列。在应用该操作序列后，所有袋鼠必须聚集在指定格子 $(a,b)$ 中。操作序列的长度不能超过 $3(n-1)$。同往常一样，所有袋鼠会根据您的命令同时移动。\n\n在 2022 年的竞赛中，A 题《停停，昨日请不要再重现》要求选手解决以下计数问题：\n\n> 本题中，网格中的每个格子（除了一个格子是洞）都恰好有一只袋鼠。给定操作序列，所有走出网格外或踩到洞上的袋鼠都会被移除。给定所有操作后剩余的袋鼠数量，求有几个位置可能是洞。\n\n在 2023 年的竞赛中，袋鼠题又回来啦！我们不知道为什么命题组的成员们那么喜欢袋鼠，但题目如下：\n\n给定一张 $n$ 行 $m$ 列的网格，每个格子要么是洞，要么是空地。每个空地都恰好有一只袋鼠。\n\n相似地，袋鼠可以被键盘上的 U，D，L，R 键控制。所有袋鼠会同时根据按下的按键移动。具体来说，对于一只位于第 $i$ 行第 $j$ 列的格子（用 $(i,j)$ 表示）上的袋鼠：\n\n- 按键 U：它会移动到 $(i-1,j)$。\n- 按键 D：它会移动到 $(i+1,j)$。\n- 按键 L：它会移动到 $(i,j-1)$。\n- 按键 R：它会移动到 $(i,j+1)$。\n\n如果一只袋鼠踩到了洞或者移动到了网格外面，它将被从网格上移除。如果完成一系列操作后（操作序列可以为空）恰有一只袋鼠留在网格上，那么这只袋鼠就是赢家。\n\n您需要解决的问题是：对于每只袋鼠，判断是否存在一个操作序列使得它成为赢家。输出可能成为赢家的袋鼠总数。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入两个整数 $n$ 与 $m$（$1 \\le n, m \\le 10^3$，$1 \\le n \\times m \\le 10^3$）表示网格的行数和列数。\n\n对于接下来 $n$ 行，第 $i$ 行输入一个长度为 $m$ 的字符串 $s_{i, 1}s_{i, 2} \\cdots s_{i, m}$，每个字符要么是 $\\texttt{.}$（点号，ascii: 46）要么是 $\\texttt{O}$（大写字母，ascii: 79）。如果 $s_{i, j}$ 是 $\\texttt{.}$ 则格子 $(i, j)$ 是空地；如果 $s_{i, j}$ 是 $\\texttt{O}$ 则格子 $(i, j)$ 是洞。\n\n保证所有数据  $n \\times m$ 之和不超过 $5 \\times 10^3$。", "outputFormat": "每组数据输出一行一个整数，表示共有几只袋鼠满足存在一个操作序列使得它成为赢家。", "hint": "样例数据解释如下。我们用 `W` 表示接下来成为赢家的袋鼠，用 `K` 表示其它袋鼠。\n\n对于第一组样例数据，初始位于 $(1, 4)$，$(1, 5)$ 和 $(2, 5)$ 的袋鼠可能成为赢家。以下展示可能的操作序列：\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/tme0c3nq.png)\n:::\n\n对于第二组样例数据，因为只有一只袋鼠，无需任何操作即可让它成为赢家。\n\n对于第三组样例数据，因为任何操作都会让两只袋鼠同时被移除，所以没有任何可能的赢家。\n\n对于第四组样例数据，因为没有袋鼠，所以没有任何可能的赢家。", "locale": "zh-CN"}}}
{"pid": "P13952", "type": "P", "difficulty": 7, "samples": [["3\n0 2 2 0 0 -2 -2 0\n7 -2 9 -2 9 2 7 2\n7 13 11 10 5 2 1 5", "0.70710678118654752\n1\n0.62384322483109367"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["计算几何", "2023", "Special Judge", "ICPC", "南京"], "title": "[ICPC 2023 Nanjing R] 交并比", "background": "", "description": "交并比，又称雅卡尔指数或雅卡尔相似系数（法语原文 coefficient de communauté，由 Paul Jaccard 提出），是用于比较样本集的相似性与多样性的统计量。雅卡尔系数能够量度有限样本集合的相似度，其定义为两个集合交集大小与并集大小之间的比例：\n\n$$J(A, B) = \\frac{|A \\cap B|}{|A \\cup B|}$$\n\n在计算机视觉中，交并比（IOU）是一个被广泛使用的统计量，用于衡量各类对象检测和分割算法。\n\n与 x 轴和 y 轴对齐的矩形（即矩形的边与 x 轴或 y 轴平行）通常被称作“轴对齐矩形”，“轴对齐矩形边界框”（AABB），或 “边界框”。另一方面，与 x 轴和 y 轴不一定对齐的矩形（即矩形的边与坐标轴可能成一个角度）通常被成为“旋转矩形”，“旋转矩形边界框”，或“方向矩形边界框”（OBB）。在计算机视觉与图像处理应用中，根据需要解决的问题，两种矩形都被广泛使用。\n\n本题中，您需要找到一个轴对齐矩形（AABB），使得它与一个旋转矩形（OBB）的交并比最大。两个矩形之间的交并比定义为两个矩形交集的面积除以两个矩形并集的面积。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$（$1 \\le T \\le 10^4$）表示测试数据组数，对于每组测试数据：\n\n第一行输入八个整数 $x_1$，$y_1$，$x_2$，$y_2$，$x_3$，$y_3$，$x_4$，$y_4$（$-10^9 \\le x_i, y_i \\le 10^9$），其中 $(x_i, y_i)$ 表示旋转矩形的第 $i$ 个顶点的坐标。顶点以顺时针或逆时针顺序给定。保证旋转矩形的面积为正。", "outputFormat": "每组数据输出一行一个数表示旋转矩形和轴对齐矩形之间的最大交并比。如果相对误差或绝对误差不超过 $10^{-9}$，您的答案将被接受。\n", "hint": "样例数据解释如下。输入的矩形用点状阴影表示，最优的轴对齐矩形用斜线阴影表示。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/8unz6ovw.png)\n:::", "locale": "zh-CN", "translations": {"en": {"title": "[ICPC 2023 Nanjing R] Intersection over Union", "background": "", "description": "$\\textit{Intersection over Union}$, also known as the $\\textit{Jaccard index}$ and the $\\textit{Jaccard similarity}$ coefficient (originally given the French name coefficient de communauté by Paul Jaccard), is a statistic used for gauging the similarity and diversity of sample sets. The Jaccard coefficient measures similarity between finite sample sets, and is defined as the size of the intersection divided by the size of the union of the sample sets:\n\n$$J(A, B) = \\frac{|A \\cap B|}{|A \\cup B|}$$\n\nIntersection over Union (IOU) is also a widely used metric in computer vision for evaluating object detection and segmentation algorithms.\n\nA rectangle that is aligned with the x and y axes (i.e., its sides are parallel to the x and y axes) is often called an \"axis-aligned rectangle\", \"axis-aligned bounding box\" (AABB), or simply \"bounding box\". On the other hand, a rectangle that is not necessarily aligned with the x and y axes (i.e., its sides might be at an angle) is often called a \"rotated rectangle\", a \"rotated bounding box\", or an \"oriented bounding box\" (OBB). In computer vision and image processing applications, both types of rectangles are widely in use, depending on the problem at hand. \n\nIn this problem, your task is to find an axis-aligned rectangle (AABB) that maximizes the IOU with a rotated rectangle (OBB). The IOU between two rectangles is defined as the area of the intersection between the two rectangles divided by the area of their union.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 10^4$) indicating the number of test cases. For each test case:\n\nThe first and only line contains eight integers $x_1$, $y_1$, $x_2$, $y_2$, $x_3$, $y_3$, $x_4$, $y_4$ ($-10^9 \\le x_i, y_i \\le 10^9$), where $(x_i, y_i)$ represents the coordinates of the $i$-th vertex of the rotated rectangle, in either clockwise or counterclockwise order. It's guaranteed that the rotated rectangle has a positive area.", "outputFormat": "For each test case, output one line containing one number indicating the maximum IOU between the rotated rectangle and the axis-aligned rectangle. Your answer will be considered correct if the absolute or relative error does not exceed $10^{-9}$.", "hint": "The sample test cases are shown as follows. The input rectangles are shown with dots and the optimal axis-aligned rectangles are shown with hatching.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/8unz6ovw.png)\n:::", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Nanjing R] 交并比", "background": "", "description": "交并比，又称雅卡尔指数或雅卡尔相似系数（法语原文 coefficient de communauté，由 Paul Jaccard 提出），是用于比较样本集的相似性与多样性的统计量。雅卡尔系数能够量度有限样本集合的相似度，其定义为两个集合交集大小与并集大小之间的比例：\n\n$$J(A, B) = \\frac{|A \\cap B|}{|A \\cup B|}$$\n\n在计算机视觉中，交并比（IOU）是一个被广泛使用的统计量，用于衡量各类对象检测和分割算法。\n\n与 x 轴和 y 轴对齐的矩形（即矩形的边与 x 轴或 y 轴平行）通常被称作“轴对齐矩形”，“轴对齐矩形边界框”（AABB），或 “边界框”。另一方面，与 x 轴和 y 轴不一定对齐的矩形（即矩形的边与坐标轴可能成一个角度）通常被成为“旋转矩形”，“旋转矩形边界框”，或“方向矩形边界框”（OBB）。在计算机视觉与图像处理应用中，根据需要解决的问题，两种矩形都被广泛使用。\n\n本题中，您需要找到一个轴对齐矩形（AABB），使得它与一个旋转矩形（OBB）的交并比最大。两个矩形之间的交并比定义为两个矩形交集的面积除以两个矩形并集的面积。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$（$1 \\le T \\le 10^4$）表示测试数据组数，对于每组测试数据：\n\n第一行输入八个整数 $x_1$，$y_1$，$x_2$，$y_2$，$x_3$，$y_3$，$x_4$，$y_4$（$-10^9 \\le x_i, y_i \\le 10^9$），其中 $(x_i, y_i)$ 表示旋转矩形的第 $i$ 个顶点的坐标。顶点以顺时针或逆时针顺序给定。保证旋转矩形的面积为正。", "outputFormat": "每组数据输出一行一个数表示旋转矩形和轴对齐矩形之间的最大交并比。如果相对误差或绝对误差不超过 $10^{-9}$，您的答案将被接受。\n", "hint": "样例数据解释如下。输入的矩形用点状阴影表示，最优的轴对齐矩形用斜线阴影表示。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/8unz6ovw.png)\n:::", "locale": "zh-CN"}}}
{"pid": "P13953", "type": "P", "difficulty": 4, "samples": [["3\n2 0\n7 11\n1145141 998244353", "1\n2\n872"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "ICPC", "南京"], "title": "[ICPC 2023 Nanjing R] 原根", "background": "", "description": "堡堡刚刚学会了数论中的原根。现在他正通过即时通信软件向小青鱼炫耀他的知识。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/b99yvxrq.png)\n\n本图仅为娱乐，与题目本身无关。如果您看不懂中文，可以安全地跳过本图。\n:::\n\n因为如果非负整数 $g$ 是模 $P$ 的原根（$P$ 是质数），则 $g^{P - 1} \\equiv 1 \\pmod{P}$，所以堡堡打算用表达式 $\\texttt{(g \\^ (P - 1)) \\% P == 1}$ 来检查 $g$ 是不是模 $P$ 的原根。不幸的是，在大多数编程语言中（例如 C 和 C++）， $\\texttt{\\^ }$ 是按位异或（XOR）运算符，而不是次方运算符。小青鱼一下子就发现了这个错误，现在他开始思考起以下问题：\n\n给定质数 $P$ 和非负整数 $m$，有多少非负整数 $g$ 满足 $g \\leq m$ 且 $g \\oplus (P-1) \\equiv 1 \\pmod{P}$？这里 $\\oplus$ 是按位异或（XOR）运算符。\n\n请帮助小青鱼解决这个问题。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$（$1 \\leq T \\leq 10^{5}$）表示测试数据组数，对于每组测试数据：\n\n第一行输入两个整数 $P$ 和 $m$（$2 \\le P \\le 10^{18}$，$0 \\leq m \\leq 10^{18}$，$P$ 是质数）。", "outputFormat": "每组数据输出一行一个整数表示满足限制的 $g$ 的数量。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[ICPC 2023 Nanjing R] Primitive Root", "background": "", "description": "BaoBao has just learnt about primitive roots in number theory and is showing off his knowledge to Little Cyan Fish through an instant messaging software.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/b99yvxrq.png)\n\nThis image is only for amusement and has nothing to do with the problem itself. You can safely skip this image if you can't read Chinese.\n:::\n\nBased on the fact that if a non-negative integer $g$ is a primitive root modulo $P$ (where $P$ is a prime), then $g^{P - 1} \\equiv 1 \\pmod{P}$, BaoBao decided to use the expression $\\texttt{(g \\^ (P - 1)) \\% P == 1}$ to check if $g$ is a primitive root modulo $P$. Unfortunately, in most programming languages (for example C and C++), $\\texttt{\\^ }$ is the bitwise exclusive-or (XOR) operator, not the power operator. Little Cyan Fish spotted this issue at once and now he is interested in the following problem:\n\nGiven a prime number $P$ and a non-negative integer $m$, how many non-negative integers $g$ satisfies $g \\leq m$ and $g \\oplus (P-1) \\equiv 1 \\pmod{P}$? Here $\\oplus$ is bitwise exclusive-or (XOR) operator.\n\nPlease help Little Cyan Fish solve this problem.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\leq T \\leq 10^{5}$) indicating the number of test cases. For each test case:\n\nThe first and only line contains two integers $P$ and $m$ ($2 \\le P \\le 10^{18}$, $0 \\leq m \\leq 10^{18}$, $P$ is a prime).", "outputFormat": "For each test case, output one line containing one integer indicating the number of $g$ satisfying the constraints.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Nanjing R] 原根", "background": "", "description": "堡堡刚刚学会了数论中的原根。现在他正通过即时通信软件向小青鱼炫耀他的知识。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/b99yvxrq.png)\n\n本图仅为娱乐，与题目本身无关。如果您看不懂中文，可以安全地跳过本图。\n:::\n\n因为如果非负整数 $g$ 是模 $P$ 的原根（$P$ 是质数），则 $g^{P - 1} \\equiv 1 \\pmod{P}$，所以堡堡打算用表达式 $\\texttt{(g \\^ (P - 1)) \\% P == 1}$ 来检查 $g$ 是不是模 $P$ 的原根。不幸的是，在大多数编程语言中（例如 C 和 C++）， $\\texttt{\\^ }$ 是按位异或（XOR）运算符，而不是次方运算符。小青鱼一下子就发现了这个错误，现在他开始思考起以下问题：\n\n给定质数 $P$ 和非负整数 $m$，有多少非负整数 $g$ 满足 $g \\leq m$ 且 $g \\oplus (P-1) \\equiv 1 \\pmod{P}$？这里 $\\oplus$ 是按位异或（XOR）运算符。\n\n请帮助小青鱼解决这个问题。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$（$1 \\leq T \\leq 10^{5}$）表示测试数据组数，对于每组测试数据：\n\n第一行输入两个整数 $P$ 和 $m$（$2 \\le P \\le 10^{18}$，$0 \\leq m \\leq 10^{18}$，$P$ 是质数）。", "outputFormat": "每组数据输出一行一个整数表示满足限制的 $g$ 的数量。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P13954", "type": "P", "difficulty": 6, "samples": [["2\n9\n101011110\n1 1 3 3 3 6 2 2\n4\n1011\n1 1 3", "4 1 2 0 0 0 0 0 0\n2 0 0 0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2023", "ICPC", "南京", "斜率维护技巧 slope trick"], "title": "[ICPC 2023 Nanjing R] 红黑树", "background": "", "description": "有一棵 $n$ 个节点的有根树，节点编号从 $1$ 到 $n$，其中节点 $1$ 为根。每个节点都有一个颜色， 要么是红色，要么是黑色。\n\n称一个节点是好的，若每一条以该节点为起点，以该节点任意一个后代叶子节点为终点的简单路径中，都包含相同数量的黑色节点。称一棵树是完美的，若树中每个节点都是好的。\n\n令 $R_k$ 表示以节点 $k$ 为根的子树。对于每个 $1 \\le k \\le n$，回答以下询问：如果您可以任意选择一些节点并改变它们的颜色（也就是说，把红色节点改成黑色，以及把黑色节点改成红色），至少需要选择几个节点才能让 $R_k$ 变得完美。\n\n请回忆：简单路径不会多次经过同一条边。\n\n同时请回忆：以节点 $k$ 为根的子树是一棵由节点 $k$ 所有后代组成的有根树，并以节点 $k$ 为根。请注意，每个节点都是它自己的后代。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入一个整数 $n$（$2 \\le n \\le 10^5$）表示树中节点的数量。\n\n第二行输入一个长度为 $n$ 的字符串 $s_1s_2\\cdots s_n$（$s_i \\in \\{0, 1\\}$）。若 $s_i = 0$ 则节点 $i$ 是红色节点；若 $s_i = 1$ 则节点 $i$ 是黑色节点。\n\n第三行输入 $(n - 1)$ 个整数 $p_2, p_3, \\cdots, p_n$（$1 \\le p_i < i$），其中 $p_i$ 是节点 $i$ 的父节点。\n\n保证所有数据 $n$ 之和不超过 $10^6$。", "outputFormat": "每组数据输出一行 $n$ 个由单个空格分隔的整数，其中第 $i$ 个整数表示至少需要选择几个节点才能让 $R_i$ 变得完美。\n\n请不要在行末输出多余空格，否则您的答案可能会被认为是错误的！", "hint": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/99pg7vpy.png)\n:::\n\n我们展示第一组样例数据。\n\n为了让 $R_1$ 变得完美，我们可以改变节点 $2$，$4$，$6$ 和 $9$ 的颜色。改变之后，所有从节点 $1$ 到后代叶子节点的路径均包含 $3$ 个黑色节点，所有从节点 $2$ 到后代叶子节点的路径均包含 $2$ 个黑色节点，所有从节点 $3$ 到后代叶子节点的路径均包含 $2$ 个黑色节点。由于节点 $4$ 到 $9$ 都只有一个后代叶子节点，所以它们一直都是好的。\n\n为了让 $R_2$ 变得完美，我们可以改变节点 $8$ 的颜色。改变之后，所有从节点 $2$ 到后代叶子节点的路径均包含 $0$ 个黑色节点。由于节点 $8$ 和 $9$ 都只有一个后代叶子节点，所以它们一直都是好的。", "locale": "zh-CN", "translations": {"en": {"title": "[ICPC 2023 Nanjing R] Red Black Tree", "background": "", "description": "There is a rooted tree with $n$ vertices numbered from $1$ to $n$, where vertex $1$ is the root. Each vertex has a color, which is either red or black.\n\nWe say a vertex is good, if every simple path from that vertex to any of its descendant leaf vertex contains the same number of black vertices. We say a tree is perfect, if all its vertices are good.\n\nLet $R_k$ be the subtree rooted at vertex $k$. For each $1 \\le k \\le n$, answer the following query: If you can choose a set of vertices and change their colors (that is, change red vertices to black, and change black vertices to red), calculate the minimum number of vertices you have to choose to make $R_k$ perfect.\n\nRecall that a simple path is a path which does not go through the same edge multiple times.\n\nAlso recall that a subtree rooted at vertex $k$ is a tree consisting of all descendants of vertex $k$ and has vertex $k$ as the root. Note that any vertex is a descendant of itself.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($2 \\le n \\le 10^5$) indicating the number of vertices in the tree.\n\nThe second line contains a string $s_1s_2\\cdots s_n$ of length $n$ ($s_i \\in \\{0, 1\\}$). If $s_i = 0$ then vertex $i$ is red; If $s_i = 1$ then vertex $i$ is black.\n\nThe third line contains $(n - 1)$ integers $p_2, p_3, \\cdots, p_n$ ($1 \\le p_i < i$) where $p_i$ is the parent of vertex $i$.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing $n$ integers separated by a space, where the $i$-th integer indicates the minimum number of vertices whose color you have to change to make $R_i$ perfect.\n\nPlease, DO NOT output extra spaces at the end of each line, or your solution may be considered incorrect!", "hint": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/99pg7vpy.png)\n:::\n\nWe illustrate the first sample test case.\n\nTo make $R_1$ perfect, we can change the color of vertices $2$, $4$, $6$ and $9$. After that, all paths from vertex $1$ to its descendant leaves will contain $3$ black vertices, all paths from vertex $2$ to its descendant leaves will contain $2$ black vertices, and all paths from vertex $3$ to its descendant leaves will contain $2$ black vertices. As vertices $4$ to $9$ only has one descendant leaf, they're always good.\n\nTo make $R_2$ perfect, we can change the color of vertex $8$. After that, all paths from vertex $2$ to its descendant leaves will contain $0$ vertices. As vertices $8$ and $9$ only has one descendant leaf, they're always good.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Nanjing R] 红黑树", "background": "", "description": "有一棵 $n$ 个节点的有根树，节点编号从 $1$ 到 $n$，其中节点 $1$ 为根。每个节点都有一个颜色， 要么是红色，要么是黑色。\n\n称一个节点是好的，若每一条以该节点为起点，以该节点任意一个后代叶子节点为终点的简单路径中，都包含相同数量的黑色节点。称一棵树是完美的，若树中每个节点都是好的。\n\n令 $R_k$ 表示以节点 $k$ 为根的子树。对于每个 $1 \\le k \\le n$，回答以下询问：如果您可以任意选择一些节点并改变它们的颜色（也就是说，把红色节点改成黑色，以及把黑色节点改成红色），至少需要选择几个节点才能让 $R_k$ 变得完美。\n\n请回忆：简单路径不会多次经过同一条边。\n\n同时请回忆：以节点 $k$ 为根的子树是一棵由节点 $k$ 所有后代组成的有根树，并以节点 $k$ 为根。请注意，每个节点都是它自己的后代。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入一个整数 $n$（$2 \\le n \\le 10^5$）表示树中节点的数量。\n\n第二行输入一个长度为 $n$ 的字符串 $s_1s_2\\cdots s_n$（$s_i \\in \\{0, 1\\}$）。若 $s_i = 0$ 则节点 $i$ 是红色节点；若 $s_i = 1$ 则节点 $i$ 是黑色节点。\n\n第三行输入 $(n - 1)$ 个整数 $p_2, p_3, \\cdots, p_n$（$1 \\le p_i < i$），其中 $p_i$ 是节点 $i$ 的父节点。\n\n保证所有数据 $n$ 之和不超过 $10^6$。", "outputFormat": "每组数据输出一行 $n$ 个由单个空格分隔的整数，其中第 $i$ 个整数表示至少需要选择几个节点才能让 $R_i$ 变得完美。\n\n请不要在行末输出多余空格，否则您的答案可能会被认为是错误的！", "hint": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/99pg7vpy.png)\n:::\n\n我们展示第一组样例数据。\n\n为了让 $R_1$ 变得完美，我们可以改变节点 $2$，$4$，$6$ 和 $9$ 的颜色。改变之后，所有从节点 $1$ 到后代叶子节点的路径均包含 $3$ 个黑色节点，所有从节点 $2$ 到后代叶子节点的路径均包含 $2$ 个黑色节点，所有从节点 $3$ 到后代叶子节点的路径均包含 $2$ 个黑色节点。由于节点 $4$ 到 $9$ 都只有一个后代叶子节点，所以它们一直都是好的。\n\n为了让 $R_2$ 变得完美，我们可以改变节点 $8$ 的颜色。改变之后，所有从节点 $2$ 到后代叶子节点的路径均包含 $0$ 个黑色节点。由于节点 $8$ 和 $9$ 都只有一个后代叶子节点，所以它们一直都是好的。", "locale": "zh-CN"}}}
{"pid": "P13955", "type": "P", "difficulty": 7, "samples": [["2\n3 4 6\n2 1 15\n7 1 9\n13 3 2\n3 6 1 2\n5 2 15 3\n3 3 3\n1 1\n2 2\n3 3\n1 1 1\n2 2 2", "9\n2 3 15\n7 1 10\n13 3 4\n3 6 3 2\n5 4 15 3\n4\n4 1\n3 2\n3 3\n1 1 1\n2 2 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "网络流", "Special Judge", "ICPC", "南京"], "title": "[ICPC 2023 Nanjing R] 延伸距离", "background": "", "description": "有 $n \\times m$ 个点排成了 $n$ 行 $m$ 列，相邻点之间被无向带权边连接。具体来说，令 $(i, j)$ 表示位于第 $i$ 行第 $j$ 列的点，对于所有 $1 \\le i, i' \\le n$ 和 $1 \\le j, j' \\le m$，$(i, j)$ 和 $(i', j')$ 之间有边相连当且仅当 $|i - i'| + |j - j'| = 1$。\n\n堡堡的旅行将从第一列的任意一个点 $(p, 1)$ 开始，到最后一列的任意一点 $(q, m)$ 结束。对于每条边他都可以沿着这条边的两个方向走。一条路径的距离定义为这条路径经过的边权之和。在所有从第一列到最后一列的路径中，堡堡会选择最短的路径。\n\n小青鱼希望堡堡享受这段旅行，于是他尝试在堡堡出发前增加一些边的权值。具体来说，小青鱼每次操作可以选择一条边，将它的权值增加 $1$。小青鱼希望在他修改后，堡堡旅行的距离恰好增加了 $k$。请帮助他求出最少需要进行多少次操作，并输出方案。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入三个整数 $n$，$m$ 和 $k$（$1\\leq n\\times m\\leq 500$，$2\\leq n,m\\leq 500$，$1\\leq k\\leq 100$）表示行数，列数和最短路径距离的增加量。\n\n对于接下来的 $n$ 行，第 $i$ 行输入 $(m - 1)$ 个整数 $r_{i,1}, r_{i,2}, \\cdots, r_{i,m-1}$（$1\\leq r_{i,j}\\leq 10^9$），其中 $r_{i,j}$ 表示连接 $(i,j)$ 和 $(i,j+1)$ 的边权。\n\n对于接下来的 $(n - 1)$行，第 $i$ 行输入 $m$ 个整数 $c_{i,1}, c_{i, 2}, \\cdots, c_{i,m}$（$1\\leq c_{i,j}\\leq 10^9$），其中 $c_{i,j}$ 表示连接 $(i,j)$ 和 $(i+1,j)$ 的边权。\n\n保证所有数据 $n\\times m$ 之和不超过 $5 \\times 10^3$。", "outputFormat": "对于每组数据：\n\n首先输出一行一个整数表示最少需要的操作次数。\n\n接下来输出 $n$ 行，第 $i$ 行输出 $(m - 1)$ 个由单个空格分隔的整数 $r'_{i,1}, r'_{i,2}, \\cdots, r'_{i,m-1}$（$1\\leq r'_{i,j}\\leq 2\\times 10^9$），其中 $r'_{i,j}$ 表示完成所有操作后连接 $(i,j)$ 和 $(i,j+1)$ 的边权。\n\n接下来输出 $(n - 1)$ 行，第 $i$ 行输出 $m$ 个由单个空格分隔的整数 $c'_{i,1}, c'_{i,2}, \\cdots, c'_{i,m}$（$1\\leq c'_{i,j}\\leq 2\\times 10^9$），其中 $c'_{i,j}$ 表示完成所有操作后连接 $(i,j)$ 和 $(i+1,j)$ 的边权。\n\n如果有多种合法答案，输出任意一种。\n\n请不要在行末输出多余空格，否则您的答案可能会被认为是错误的！", "hint": "第一组样例数据如下图所示。左边的是原图，右边的是增加一些边的权值之后的图。每张图的最短路用红色线条表示。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/tcvxvrnt.png)\n:::", "locale": "zh-CN", "translations": {"en": {"title": "[ICPC 2023 Nanjing R] Extending Distance", "background": "", "description": "Given $n \\times m$ points arranged into $n$ rows and $m$ columns, there are weighted bidirectional edges between adjacent points. That is, let $(i, j)$ be the point on the $i$-th row and the $j$-th column, for all $1 \\le i, i' \\le n$ and $1 \\le j, j' \\le m$, there is an edge between $(i, j)$ and $(i', j')$ if and only if $|i - i'| + |j - j'| = 1$.\n\nBaoBao will begin his journey at any point $(p, 1)$ on the first column and finish the journey at any point $(q, m)$ on the last column. He can travel along the edges in both directions. The distance of a path is defined as the sum of the weight of the edges in the path. Among all the paths from the first column to the last column, BaoBao will choose the shortest path. \n\nLittle Cyan Fish hopes BaoBao to better enjoy the journey, so he tries to increase the weight of some edges before BaoBao begins traveling. Specifically, Little Cyan Fish can increase the weight of any edge by $1$ in one operation. He hopes the distance of BaoBao's path can increase by $k$ after all operations. Please help him calculate the minimum number of operations needed and output the corresponding solution.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains three integers $n$, $m$ and $k$ ($1\\leq n\\times m\\leq 500$, $2\\leq n,m\\leq 500$, $1\\leq k\\leq 100$) indicating the number of rows and columns, and the increment on the length of the shortest path.\n\nFor the following $n$ lines, the $i$-th line contains $(m - 1)$ integers $r_{i,1}, r_{i,2}, \\cdots, r_{i,m-1}$ ($1\\leq r_{i,j}\\leq 10^9$) where $r_{i,j}$ indicates the weight of the edge between $(i,j)$ and $(i,j+1)$.\n\nFor the following $(n - 1)$ lines, the $i$-th line contains $m$ integers $c_{i,1}, c_{i, 2}, \\cdots, c_{i,m}$ ($1\\leq c_{i,j}\\leq 10^9$) where $c_{i,j}$ indicates the weight of the edge between $(i,j)$ and $(i+1,j)$.\n\nIt is guaranteed that the sum of $n\\times m$ of all test cases will not exceed $5 \\times 10^3$.", "outputFormat": "For each test case:\n\nFirst output one line containing one integer indicating the minimum number of operations needed.\n\nThen output $n$ lines. The $i$-th line contains $(m - 1)$ integers $r'_{i,1}, r'_{i,2}, \\cdots, r'_{i,m-1}$ ($1\\leq r'_{i,j}\\leq 2\\times 10^9$) separated by a space, where $r'_{i,j}$ indicates the weight of the edge between $(i,j)$ and $(i,j+1)$ after all operations.\n\nThen output $(n - 1)$ lines. The $i$-th line contains $m$ integers $c'_{i,1}, c'_{i,2}, \\cdots, c'_{i,m}$ ($1\\leq c'_{i,j}\\leq 2\\times 10^9$) separated by a space, where $c'_{i,j}$ indicates the weight of the edge between $(i,j)$ and $(i+1,j)$ after all operations.\n\nIf there are multiple valid answers, output any of them.\n\nPlease, DO NOT output extra spaces at the end of each line, or your solution may be considered incorrect!\n", "hint": "The first sample test case is illustrated below. The graph on the left is the original graph and the graph on the right is the graph after increasing the weight of some edges. Shortest paths of each graph are marked by red lines.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/tcvxvrnt.png)\n:::", "locale": "en"}, "zh-CN": {"title": "[ICPC 2023 Nanjing R] 延伸距离", "background": "", "description": "有 $n \\times m$ 个点排成了 $n$ 行 $m$ 列，相邻点之间被无向带权边连接。具体来说，令 $(i, j)$ 表示位于第 $i$ 行第 $j$ 列的点，对于所有 $1 \\le i, i' \\le n$ 和 $1 \\le j, j' \\le m$，$(i, j)$ 和 $(i', j')$ 之间有边相连当且仅当 $|i - i'| + |j - j'| = 1$。\n\n堡堡的旅行将从第一列的任意一个点 $(p, 1)$ 开始，到最后一列的任意一点 $(q, m)$ 结束。对于每条边他都可以沿着这条边的两个方向走。一条路径的距离定义为这条路径经过的边权之和。在所有从第一列到最后一列的路径中，堡堡会选择最短的路径。\n\n小青鱼希望堡堡享受这段旅行，于是他尝试在堡堡出发前增加一些边的权值。具体来说，小青鱼每次操作可以选择一条边，将它的权值增加 $1$。小青鱼希望在他修改后，堡堡旅行的距离恰好增加了 $k$。请帮助他求出最少需要进行多少次操作，并输出方案。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入三个整数 $n$，$m$ 和 $k$（$1\\leq n\\times m\\leq 500$，$2\\leq n,m\\leq 500$，$1\\leq k\\leq 100$）表示行数，列数和最短路径距离的增加量。\n\n对于接下来的 $n$ 行，第 $i$ 行输入 $(m - 1)$ 个整数 $r_{i,1}, r_{i,2}, \\cdots, r_{i,m-1}$（$1\\leq r_{i,j}\\leq 10^9$），其中 $r_{i,j}$ 表示连接 $(i,j)$ 和 $(i,j+1)$ 的边权。\n\n对于接下来的 $(n - 1)$行，第 $i$ 行输入 $m$ 个整数 $c_{i,1}, c_{i, 2}, \\cdots, c_{i,m}$（$1\\leq c_{i,j}\\leq 10^9$），其中 $c_{i,j}$ 表示连接 $(i,j)$ 和 $(i+1,j)$ 的边权。\n\n保证所有数据 $n\\times m$ 之和不超过 $5 \\times 10^3$。", "outputFormat": "对于每组数据：\n\n首先输出一行一个整数表示最少需要的操作次数。\n\n接下来输出 $n$ 行，第 $i$ 行输出 $(m - 1)$ 个由单个空格分隔的整数 $r'_{i,1}, r'_{i,2}, \\cdots, r'_{i,m-1}$（$1\\leq r'_{i,j}\\leq 2\\times 10^9$），其中 $r'_{i,j}$ 表示完成所有操作后连接 $(i,j)$ 和 $(i,j+1)$ 的边权。\n\n接下来输出 $(n - 1)$ 行，第 $i$ 行输出 $m$ 个由单个空格分隔的整数 $c'_{i,1}, c'_{i,2}, \\cdots, c'_{i,m}$（$1\\leq c'_{i,j}\\leq 2\\times 10^9$），其中 $c'_{i,j}$ 表示完成所有操作后连接 $(i,j)$ 和 $(i+1,j)$ 的边权。\n\n如果有多种合法答案，输出任意一种。\n\n请不要在行末输出多余空格，否则您的答案可能会被认为是错误的！", "hint": "第一组样例数据如下图所示。左边的是原图，右边的是增加一些边的权值之后的图。每张图的最短路用红色线条表示。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/tcvxvrnt.png)\n:::", "locale": "zh-CN"}}}
