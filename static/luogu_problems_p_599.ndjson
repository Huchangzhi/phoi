{"pid": "P13155", "type": "P", "difficulty": 6, "samples": [["", ""]], "limits": {"time": [90000, 90000], "memory": [1048576, 1048576]}, "tags": ["2018", "二分", "交互题", "Special Judge", "Google Code Jam"], "title": "[GCJ 2018 Finals] Go, Gophers!", "background": "", "description": "Earlier this year, the Code Jam team planted an orchard with the help of an industrious gopher. It must have told other gophers, because we now have somewhere between 2 and 25 gophers living in the orchard. But it is hard to be sure exactly how many there are, because these gophers only emerge from their underground tunnels to eat at night, and we are too tired after a hard day of tree-pruning to stay up and watch for them. However, we do know how to make one \"gopher snack\" per day, which we can leave out each night to see whether it gets eaten. We think we can use this information to determine the number of gophers.\n\nHere is what we know about the way that gophers eat. The $N$ gophers meet during one day in a council to determine an order in which they will emerge over the following $N$ nights, one at a time. Then, during each of the $i$-th of the next $N$ nights, the $i$-th gopher in the order emerges and looks for a gopher snack. Each gopher has its own particular taste level (which never changes), and it will eat a snack if and only if the snack's quality level is at least as high as that gopher's taste level. During the day after the $N$-th gopher in the order has emerged, the gophers choose a new order and the process continues. Notice that even if a gopher chooses not to eat the snack that it finds, it still does not emerge again until it comes up in the next order chosen by the council.\n\nWe must make exactly one new gopher snack each day; even if a snack is not eaten, it spoils and cannot be reused the next night. Each morning, we learn whether or not the previous night's snack was taken.\n\nToday, we know that the gophers are meeting in their council to determine their next order, so tonight will mark the start of that order. We are willing to devote some serious time to this investigation — as many as $10^5$ nights. Using $S$ or fewer snacks, can you help us figure out how many gophers there are?\n\n**Interactive Protocol**\n\nThis problem is interactive, which means that the concepts of input and output are different than in standard Code Jam problems. You will interact with a separate process that both provides you with information and evaluates your responses. All information comes into your program via standard input; anything that you need to communicate should be sent via standard output. Remember that many programming languages buffer the output by default, so make sure your output actually goes out (for instance, by flushing the buffer) before blocking to wait for a response. See the [FAQ](http://faq) for an explanation of what it means to flush the buffer. Anything your program sends through standard error is ignored, but it might consume some memory and be counted against your memory limit, so do not overflow it. To help you debug, a local testing tool script (in Python) is provided at the very end of the problem statement. In addition, sample solutions to a previous Code Jam interactive problem (in all of our supported languages) are provided in the analysis for [Number Guessing](http://number_guessing).\n\nInitially, your program should read a single line containing a single integer $T$ indicating the number of test cases. Then, you need to process $T$ test cases. For each test case, your program will first read one line containing one integer $S$: the maximum number of snacks you can use. Then, your program will process up to $S + 1$ exchanges with our judge, in which the last exchange must be a guess at the answer.\n\nFor the $i$-th exchange, your program needs to use standard output to send a single line containing an integer $Q_i$.\n\n* If $Q_i$ is in the inclusive range $[1, 10^6]$, it represents that you will leave out a gopher snack with quality level $Q_i$. In response, the judge will print a single line with a single integer: 1 if the gopher ate the snack, or 0 if it did not. This line will be printed to your input stream, as described above, and your program must read it through standard input. Then, you can start another exchange.\n* If $Q_i$ is in the inclusive range $[-25, -2]$, it represents that your answer to the test case is that there are $-Q_i$ gophers. If your answer is correct, the judge will proceed to the next test case, if there is one.\n\nThe judge will print a single line with the integer $-1$, and then stop sending output to your input stream, if any of the following happen:\n\n1. Your program sends a malformed or out-of-bounds value (e.g., $1000001$, $-1$, or GO_IS_THE_BEST_LANGUAGE), or too many values (e.g., 1 2).\n2. Your program sends a value not in the inclusive range $[-25, -2]$ after having already sent $S$ values for the current test case.\n3. Your program sends a value in the inclusive range $[-25, -2]$ that is not a correct answer. Note that this means that you only get one chance to answer a test case correctly.\n\nIf your program continues to wait for the judge after receiving $-1$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive the appropriate verdict (Wrong Answer, Runtime Error, etc.) instead of a Time Limit Exceeded error. As usual, if the total time or memory is exceeded, or your program gets a runtime error, you will receive the appropriate verdict.\n\nYou should not send additional information to the judge after solving all test cases. In other words, if your program keeps printing to standard output after sending the answer to the last test case, you will get a Wrong Answer judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interactions**\n\nThe following interaction is for Test set 1.\n\n```\n  // In this example, the problem setters have already determined that the first\n  // test case has two gophers with taste levels 1 and 2 (we will call them A\n  // and B, respectively), and that the second test case has four gophers with\n  // taste levels 1, 999, 123, and 4567 (we will call them C, D, E, and F,\n  // respectively).\n  // The judge randomly generates the first order: A, B.\n  t = readline_int()           // Code reads 2 into t.\n  s = readline_int()           // Code reads 100000 into s.\n  printline 1 to stdout        // Code sends a snack with quality level 1.\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher A ate the\n                               //   snack).\n  printline 1 to stdout\n  flush stdout\n  resp = readline_srt()        // Code reads 0 into resp (gopher B did not eat\n                               //   the snack).\n                               // Judge randomly generates B, A as the next\n                               //   order.\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher B ate the\n                               //   snack).\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher A ate the\n                               //   snack).\n                               // Judge randomly generates B, A as the next\n                               //   order.\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher B ate the\n                               //   snack).\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher A ate the\n                               //   snack).\n  printline -2 to stdout       // Code correctly determines that the only\n  flush stdout                 //   scenario consistent with the information\n                               //   given so far is two gophers with taste\n                               //   levels 1 and 2.\n                               // Judge rules that the answer is correct, and\n                               //   prepares the next test case...\n                               // Judge randomly generates C, E, F, D as the\n                               //   first order.\n  s = readline_int()           // Code reads 100000 into s. (This also shows\n                               //   that the answer to the first test case was\n                               //   correct.)\n  printline 0 to stdout        // Code sends an invalid value.\n  flush stdout\n  resp = readline_str()        // Code reads -1 into resp.\n  exit                         // Code exits to avoid an ambiguous TLE error.\n```\n\nThe following interaction is for Test set 2. Notice that the interactions in the first test case are the same as in the previous example, but the outcome is different.\n\n```\n\n  // In this example, the problem setters have already determined that the first\n  // test case has three gophers with taste levels 1, 2, and 1; we will call\n  // them A, B, and C, respectively, and they will be ordered ABCCBAABCCBA...\n  t = readline_int()           // Code reads 1 into t.\n  s = readline_int()           // Code reads 100000 into s.\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher A ate\n                               //   the snack).\n  printline 1 to stdout\n  flush stdout\n  resp = readline_srt()        // Code reads 0 into resp (gopher B did not eat\n                               //   the snack).\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher C ate the\n                               //   snack).\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher C ate the\n                               //   snack).\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher B ate the\n                               //   snack).\n  printline -2 to stdout       // Code erroneously decides that there\n                               //   are two gophers A and B with taste levels\n                               //   1 and 2; this is consistent with the\n                               //   information given so far for the order\n                               //   A,B,A,B,A, but the true number of gophers\n  flush stdout                 //   is different, so judge rules it is wrong.\n  s = readline_str()           // Code tries to read s but gets -1, meaning\n                               //   that the answer to the last test case was\n                               //   wrong.\n  exit                         // Code exits to avoid an ambiguous TLE error.\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Important warning**\n\nContext switching between your program and the judge is expensive, and more so in our judging system. As opposed to other interactive problems, we found it necessary in all our reference solutions for this problem to bundle the exchanges to the server. That is, instead of \"print taste level, read response, print taste level, read response\" we can do \"print taste level, print taste level, read response, read response\" which requires less context switching.\n\n**Benchmarks**\n\nTo give you some idea of how a given bundling of queries will perform in our system, we are providing some benchmarks. We wrote a program that performs $S = 10^5$ exchanges bundled into groups of specific sizes $B$ — that is, it prints $B$ taste levels, then reads $B$ responses, then prints $B$ more, then reads $B$ more, and so on, $S / B$ times. We implemented this in both Python and C++, always printing the $B$ taste levels to a string variable and printing that string later, ensuring the buffer is not flushed within a bundle. Here are the results for each bundle size $B$, in seconds (rounded up to the next half-second, and taking the worst case over multiple runs):\n\n| $B$ | 1 | 10 | 50 | 100 | 200 | 500 | $10^5$ |\n|:---:|:---:|:----:|:----:|:-----:|:-----:|:-----:|:--------:|\n| Python | 167 | 21 | 6.5 | 5.5 | 5 | 5 | >250 |\n| C++ | 130 | 18 | 5.5 | 5.5 | 4.5 | 2.5 | >250 |\n\nNotice that with somewhat small bundle sizes, the context switching time gets below 5s per test, which is under a minute per test set.\n\n**Limits**\n\n- $1 \\leq T \\leq 10$.\n- The number of gophers is between 2 and 25, inclusive. The taste level of each gopher is between 1 and $10^6$, inclusive. $S = 10^5$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- No two gophers have the same taste level.\n- The order in which the gophers emerge each night is chosen uniformly at random from all possible orders, and independently of all other orders.\n\n**Test set 2 (38 Pts, Hidden)**\n\n- The GCD of the set $\\{x : \\text{there exist exactly } x \\geq 1 \\text{ gophers in the input that share a taste level}\\} = 1$.\n- The order in which the gophers emerge is chosen independently of the provided snacks.\n\nFor each test case, the multiset of taste levels and the seed for the random number generation are generated by the problem setters in advance of the contest, and will be the same for any contestant, for any submission. That means two submissions that offer the same number $s_i$ of snacks for test case $i$ will see the gophers emerge in the same order.\n  - For example, the following scenario would be possible in either of the test sets:\n    * two gophers, one with taste level 1, and one with taste level 2\n  - The following scenario would be possible in test set 2, but not in test set 1:\n    * three gophers, two with taste level 1, and one with taste level 2\n  - The following scenarios would not be possible in either of the test sets:\n    * six gophers, four with taste level 1, and two with taste level 2\n    * two gophers, both with taste level 7", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 Finals] Go, Gophers!", "background": "", "description": "Earlier this year, the Code Jam team planted an orchard with the help of an industrious gopher. It must have told other gophers, because we now have somewhere between 2 and 25 gophers living in the orchard. But it is hard to be sure exactly how many there are, because these gophers only emerge from their underground tunnels to eat at night, and we are too tired after a hard day of tree-pruning to stay up and watch for them. However, we do know how to make one \"gopher snack\" per day, which we can leave out each night to see whether it gets eaten. We think we can use this information to determine the number of gophers.\n\nHere is what we know about the way that gophers eat. The $N$ gophers meet during one day in a council to determine an order in which they will emerge over the following $N$ nights, one at a time. Then, during each of the $i$-th of the next $N$ nights, the $i$-th gopher in the order emerges and looks for a gopher snack. Each gopher has its own particular taste level (which never changes), and it will eat a snack if and only if the snack's quality level is at least as high as that gopher's taste level. During the day after the $N$-th gopher in the order has emerged, the gophers choose a new order and the process continues. Notice that even if a gopher chooses not to eat the snack that it finds, it still does not emerge again until it comes up in the next order chosen by the council.\n\nWe must make exactly one new gopher snack each day; even if a snack is not eaten, it spoils and cannot be reused the next night. Each morning, we learn whether or not the previous night's snack was taken.\n\nToday, we know that the gophers are meeting in their council to determine their next order, so tonight will mark the start of that order. We are willing to devote some serious time to this investigation — as many as $10^5$ nights. Using $S$ or fewer snacks, can you help us figure out how many gophers there are?\n\n**Interactive Protocol**\n\nThis problem is interactive, which means that the concepts of input and output are different than in standard Code Jam problems. You will interact with a separate process that both provides you with information and evaluates your responses. All information comes into your program via standard input; anything that you need to communicate should be sent via standard output. Remember that many programming languages buffer the output by default, so make sure your output actually goes out (for instance, by flushing the buffer) before blocking to wait for a response. See the [FAQ](http://faq) for an explanation of what it means to flush the buffer. Anything your program sends through standard error is ignored, but it might consume some memory and be counted against your memory limit, so do not overflow it. To help you debug, a local testing tool script (in Python) is provided at the very end of the problem statement. In addition, sample solutions to a previous Code Jam interactive problem (in all of our supported languages) are provided in the analysis for [Number Guessing](http://number_guessing).\n\nInitially, your program should read a single line containing a single integer $T$ indicating the number of test cases. Then, you need to process $T$ test cases. For each test case, your program will first read one line containing one integer $S$: the maximum number of snacks you can use. Then, your program will process up to $S + 1$ exchanges with our judge, in which the last exchange must be a guess at the answer.\n\nFor the $i$-th exchange, your program needs to use standard output to send a single line containing an integer $Q_i$.\n\n* If $Q_i$ is in the inclusive range $[1, 10^6]$, it represents that you will leave out a gopher snack with quality level $Q_i$. In response, the judge will print a single line with a single integer: 1 if the gopher ate the snack, or 0 if it did not. This line will be printed to your input stream, as described above, and your program must read it through standard input. Then, you can start another exchange.\n* If $Q_i$ is in the inclusive range $[-25, -2]$, it represents that your answer to the test case is that there are $-Q_i$ gophers. If your answer is correct, the judge will proceed to the next test case, if there is one.\n\nThe judge will print a single line with the integer $-1$, and then stop sending output to your input stream, if any of the following happen:\n\n1. Your program sends a malformed or out-of-bounds value (e.g., $1000001$, $-1$, or GO_IS_THE_BEST_LANGUAGE), or too many values (e.g., 1 2).\n2. Your program sends a value not in the inclusive range $[-25, -2]$ after having already sent $S$ values for the current test case.\n3. Your program sends a value in the inclusive range $[-25, -2]$ that is not a correct answer. Note that this means that you only get one chance to answer a test case correctly.\n\nIf your program continues to wait for the judge after receiving $-1$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive the appropriate verdict (Wrong Answer, Runtime Error, etc.) instead of a Time Limit Exceeded error. As usual, if the total time or memory is exceeded, or your program gets a runtime error, you will receive the appropriate verdict.\n\nYou should not send additional information to the judge after solving all test cases. In other words, if your program keeps printing to standard output after sending the answer to the last test case, you will get a Wrong Answer judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interactions**\n\nThe following interaction is for Test set 1.\n\n```\n  // In this example, the problem setters have already determined that the first\n  // test case has two gophers with taste levels 1 and 2 (we will call them A\n  // and B, respectively), and that the second test case has four gophers with\n  // taste levels 1, 999, 123, and 4567 (we will call them C, D, E, and F,\n  // respectively).\n  // The judge randomly generates the first order: A, B.\n  t = readline_int()           // Code reads 2 into t.\n  s = readline_int()           // Code reads 100000 into s.\n  printline 1 to stdout        // Code sends a snack with quality level 1.\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher A ate the\n                               //   snack).\n  printline 1 to stdout\n  flush stdout\n  resp = readline_srt()        // Code reads 0 into resp (gopher B did not eat\n                               //   the snack).\n                               // Judge randomly generates B, A as the next\n                               //   order.\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher B ate the\n                               //   snack).\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher A ate the\n                               //   snack).\n                               // Judge randomly generates B, A as the next\n                               //   order.\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher B ate the\n                               //   snack).\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher A ate the\n                               //   snack).\n  printline -2 to stdout       // Code correctly determines that the only\n  flush stdout                 //   scenario consistent with the information\n                               //   given so far is two gophers with taste\n                               //   levels 1 and 2.\n                               // Judge rules that the answer is correct, and\n                               //   prepares the next test case...\n                               // Judge randomly generates C, E, F, D as the\n                               //   first order.\n  s = readline_int()           // Code reads 100000 into s. (This also shows\n                               //   that the answer to the first test case was\n                               //   correct.)\n  printline 0 to stdout        // Code sends an invalid value.\n  flush stdout\n  resp = readline_str()        // Code reads -1 into resp.\n  exit                         // Code exits to avoid an ambiguous TLE error.\n```\n\nThe following interaction is for Test set 2. Notice that the interactions in the first test case are the same as in the previous example, but the outcome is different.\n\n```\n\n  // In this example, the problem setters have already determined that the first\n  // test case has three gophers with taste levels 1, 2, and 1; we will call\n  // them A, B, and C, respectively, and they will be ordered ABCCBAABCCBA...\n  t = readline_int()           // Code reads 1 into t.\n  s = readline_int()           // Code reads 100000 into s.\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher A ate\n                               //   the snack).\n  printline 1 to stdout\n  flush stdout\n  resp = readline_srt()        // Code reads 0 into resp (gopher B did not eat\n                               //   the snack).\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher C ate the\n                               //   snack).\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher C ate the\n                               //   snack).\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher B ate the\n                               //   snack).\n  printline -2 to stdout       // Code erroneously decides that there\n                               //   are two gophers A and B with taste levels\n                               //   1 and 2; this is consistent with the\n                               //   information given so far for the order\n                               //   A,B,A,B,A, but the true number of gophers\n  flush stdout                 //   is different, so judge rules it is wrong.\n  s = readline_str()           // Code tries to read s but gets -1, meaning\n                               //   that the answer to the last test case was\n                               //   wrong.\n  exit                         // Code exits to avoid an ambiguous TLE error.\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Important warning**\n\nContext switching between your program and the judge is expensive, and more so in our judging system. As opposed to other interactive problems, we found it necessary in all our reference solutions for this problem to bundle the exchanges to the server. That is, instead of \"print taste level, read response, print taste level, read response\" we can do \"print taste level, print taste level, read response, read response\" which requires less context switching.\n\n**Benchmarks**\n\nTo give you some idea of how a given bundling of queries will perform in our system, we are providing some benchmarks. We wrote a program that performs $S = 10^5$ exchanges bundled into groups of specific sizes $B$ — that is, it prints $B$ taste levels, then reads $B$ responses, then prints $B$ more, then reads $B$ more, and so on, $S / B$ times. We implemented this in both Python and C++, always printing the $B$ taste levels to a string variable and printing that string later, ensuring the buffer is not flushed within a bundle. Here are the results for each bundle size $B$, in seconds (rounded up to the next half-second, and taking the worst case over multiple runs):\n\n| $B$ | 1 | 10 | 50 | 100 | 200 | 500 | $10^5$ |\n|:---:|:---:|:----:|:----:|:-----:|:-----:|:-----:|:--------:|\n| Python | 167 | 21 | 6.5 | 5.5 | 5 | 5 | >250 |\n| C++ | 130 | 18 | 5.5 | 5.5 | 4.5 | 2.5 | >250 |\n\nNotice that with somewhat small bundle sizes, the context switching time gets below 5s per test, which is under a minute per test set.\n\n**Limits**\n\n- $1 \\leq T \\leq 10$.\n- The number of gophers is between 2 and 25, inclusive. The taste level of each gopher is between 1 and $10^6$, inclusive. $S = 10^5$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- No two gophers have the same taste level.\n- The order in which the gophers emerge each night is chosen uniformly at random from all possible orders, and independently of all other orders.\n\n**Test set 2 (38 Pts, Hidden)**\n\n- The GCD of the set $\\{x : \\text{there exist exactly } x \\geq 1 \\text{ gophers in the input that share a taste level}\\} = 1$.\n- The order in which the gophers emerge is chosen independently of the provided snacks.\n\nFor each test case, the multiset of taste levels and the seed for the random number generation are generated by the problem setters in advance of the contest, and will be the same for any contestant, for any submission. That means two submissions that offer the same number $s_i$ of snacks for test case $i$ will see the gophers emerge in the same order.\n  - For example, the following scenario would be possible in either of the test sets:\n    * two gophers, one with taste level 1, and one with taste level 2\n  - The following scenario would be possible in test set 2, but not in test set 1:\n    * three gophers, two with taste level 1, and one with taste level 2\n  - The following scenarios would not be possible in either of the test sets:\n    * six gophers, four with taste level 1, and two with taste level 2\n    * two gophers, both with taste level 7", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 Finals] Go, Gophers!", "background": null, "description": "今年早些时候，Code Jam 团队在一只勤劳的地鼠的帮助下种植了一片果园。可能是它把消息告诉了其他地鼠，现在果园里住着 2 到 25 只地鼠。但我们很难确定具体有多少只，因为这些地鼠只在夜间从地下洞穴出来觅食，而我们经过一天的修剪树木后太累，无法熬夜观察。不过，我们知道每天可以制作一个“地鼠零食”，晚上放出去看看是否被吃掉。我们认为可以利用这些信息来确定地鼠的数量。\n\n以下是我们已知的地鼠觅食方式。$N$ 只地鼠会在白天开会，决定接下来 $N$ 个夜晚它们出洞的顺序，每晚一只。然后，在接下来的第 $i$ 个夜晚，顺序中的第 $i$ 只地鼠会出来寻找地鼠零食。每只地鼠都有自己独特的口味等级（且永远不会改变），只有当零食的质量等级不低于该地鼠的口味等级时，它才会吃掉零食。在顺序中的第 $N$ 只地鼠出来后的第二天，地鼠们会重新决定顺序，流程再次循环。注意，即使某只地鼠选择不吃它发现的零食，它也不会再次出现，直到下次会议决定的新顺序轮到它。\n\n我们每天必须制作一个新的地鼠零食；即使零食没有被吃掉，也会变质，不能留到第二天。每天早上，我们会得知前一晚的零食是否被吃掉。\n\n今天，我们知道地鼠们正在开会决定新的顺序，所以今晚将是新顺序的开始。我们愿意为这项调查投入大量时间——最多 $10^5$ 个夜晚。请你帮我们用不超过 $S$ 个零食，确定地鼠的数量。\n\n**交互协议**\n\n本题为交互题，这意味着输入输出方式与标准 Code Jam 题目不同。你需要与一个独立进程进行交互，该进程既向你提供信息，也会评判你的回答。所有信息通过标准输入进入你的程序；你需要传达的信息应通过标准输出发送。请注意，许多编程语言默认会缓冲输出，因此在等待响应前请确保你的输出已真正发送（例如，刷新缓冲区）。详见 [FAQ](http://faq) 关于刷新缓冲区的说明。你通过标准错误发送的任何内容都会被忽略，但可能会占用内存并计入内存限制，因此请勿溢出。为帮助调试，题目末尾提供了本地测试工具脚本（Python）。此外，[Number Guessing](http://number_guessing) 的分析中提供了以所有支持语言编写的交互题样例代码。\n\n最开始，你的程序应读取一行，包含一个整数 $T$，表示测试用例数量。然后，你需要处理 $T$ 个测试用例。对于每个测试用例，你的程序首先读取一行，包含一个整数 $S$，表示你最多可以使用的零食数量。接下来，你的程序将与评测机进行最多 $S+1$ 次交互，其中最后一次必须是对答案的猜测。\n\n在第 $i$ 次交互中，你的程序需要通过标准输出发送一行，包含一个整数 $Q_i$。\n\n- 如果 $Q_i$ 在区间 $[1, 10^6]$ 内，表示你放置了一个质量等级为 $Q_i$ 的地鼠零食。作为回应，评测机会向你的输入流输出一行，包含一个整数：若地鼠吃了零食则为 1，否则为 0。你的程序必须通过标准输入读取该值。然后可以开始下一次交互。\n- 如果 $Q_i$ 在区间 $[-25, -2]$ 内，表示你认为本测试用例中有 $-Q_i$ 只地鼠。如果你的答案正确，评测机会进入下一个测试用例（如果还有的话）。\n\n如果发生以下任一情况，评测机会输出一行 $-1$，然后停止向你的输入流发送输出：\n\n1. 你的程序发送了格式错误或越界的值（如 $1000001$、$-1$ 或 GO_IS_THE_BEST_LANGUAGE），或发送了过多的值（如 1 2）。\n2. 在当前测试用例中，已经发送了 $S$ 个值后，又发送了区间 $[-25, -2]$ 内的值。\n3. 你的程序发送了区间 $[-25, -2]$ 内的值，但答案不正确。注意，每个测试用例你只有一次答题机会。\n\n如果你的程序在收到 $-1$ 后仍继续等待评测机，将会超时，导致 Time Limit Exceeded 错误。请注意，你有责任让程序及时退出，以获得正确的评判结果（Wrong Answer、Runtime Error 等），而不是超时。和往常一样，如果总时间或内存超限，或程序运行时出错，你将收到相应的评判结果。\n\n在解决所有测试用例后，不应再向评测机发送任何信息。换句话说，如果你在发送最后一个测试用例的答案后仍继续向标准输出打印内容，将会被判为 Wrong Answer。", "inputFormat": "见交互协议。", "outputFormat": "见交互协议。", "hint": "**样例交互**\n\n以下交互为测试集 1 的示例。\n\n```\n  // 在本例中，出题人已确定第一个测试用例有两只地鼠，口味等级分别为 1 和 2（我们称它们为 A 和 B），第二个测试用例有四只地鼠，口味等级分别为 1、999、123 和 4567（我们称它们为 C、D、E 和 F）。\n  // 评测机随机生成第一个顺序：A, B。\n  t = readline_int()           // 代码读取到 t=2。\n  s = readline_int()           // 代码读取到 s=100000。\n  printline 1 to stdout        // 代码发送一个质量等级为 1 的零食。\n  flush stdout\n  resp = readline_str()        // 代码读取到 resp=1（地鼠 A 吃了零食）。\n  printline 1 to stdout\n  flush stdout\n  resp = readline_srt()        // 代码读取到 resp=0（地鼠 B 没有吃零食）。\n                               // 评测机随机生成下一个顺序 B, A。\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // 代码读取到 resp=1（地鼠 B 吃了零食）。\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // 代码读取到 resp=1（地鼠 A 吃了零食）。\n                               // 评测机随机生成下一个顺序 B, A。\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // 代码读取到 resp=1（地鼠 B 吃了零食）。\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // 代码读取到 resp=1（地鼠 A 吃了零食）。\n  printline -2 to stdout       // 代码正确判断唯一符合条件的情况是两只地鼠，口味等级为 1 和 2。\n  flush stdout                 // 评测机判定答案正确，准备下一个测试用例……\n                               // 评测机随机生成 C, E, F, D 作为第一个顺序。\n  s = readline_int()           // 代码读取到 s=100000。（这也说明第一个测试用例答案正确。）\n  printline 0 to stdout        // 代码发送了一个非法值。\n  flush stdout\n  resp = readline_str()        // 代码读取到 resp=-1。\n  exit                         // 代码退出以避免出现不明确的 TLE 错误。\n```\n\n以下交互为测试集 2 的示例。注意第一个测试用例的交互与前例相同，但结果不同。\n\n```\n  // 在本例中，出题人已确定第一个测试用例有三只地鼠，口味等级分别为 1、2 和 1；我们称它们为 A、B 和 C，顺序为 ABCCBAABCCBA……\n  t = readline_int()           // 代码读取到 t=1。\n  s = readline_int()           // 代码读取到 s=100000。\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // 代码读取到 resp=1（地鼠 A 吃了零食）。\n  printline 1 to stdout\n  flush stdout\n  resp = readline_srt()        // 代码读取到 resp=0（地鼠 B 没有吃零食）。\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // 代码读取到 resp=1（地鼠 C 吃了零食）。\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // 代码读取到 resp=1（地鼠 C 吃了零食）。\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // 代码读取到 resp=1（地鼠 B 吃了零食）。\n  printline -2 to stdout       // 代码错误地判断只有两只地鼠 A 和 B，口味等级为 1 和 2；这与当前顺序 A,B,A,B,A 一致，但实际地鼠数量不同，因此评测机判定错误。\n  flush stdout\n  s = readline_str()           // 代码尝试读取 s，但得到 -1，表示上一个测试用例答案错误。\n  exit                         // 代码退出以避免出现不明确的 TLE 错误。\n```\n\n你可以使用本地测试工具在本地或平台上测试。若要在本地测试，需要并行运行该工具和你的代码；可使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件注释中的说明。\n\n测试工具的使用说明已包含在工具注释中。我们鼓励你自行添加测试用例。请注意，尽管测试工具旨在模拟评测系统，但它**不是**真实的评测系统，可能会有不同的行为。\n\n**重要警告**\n\n你与评测机之间的上下文切换开销很大，在我们的评测系统中更甚。与其他交互题不同，我们发现本题所有参考解法都需要将多次交互打包发送。即，不是“打印口味等级，读取响应，打印口味等级，读取响应”，而是“打印多个口味等级，再读取多个响应”，这样可以减少上下文切换。\n\n**性能基准**\n\n为帮助你了解不同批量交互的性能，我们提供了如下基准。我们写了一个程序，进行 $S=10^5$ 次交互，每 $B$ 次为一组——即先打印 $B$ 个口味等级，再读取 $B$ 个响应，如此 $S/B$ 组。我们用 Python 和 C++ 实现，始终将 $B$ 个口味等级打印到字符串变量，最后再输出，确保批量内不刷新缓冲区。以下为每个批量大小 $B$ 的耗时（秒，向上取整，多次运行取最大值）：\n\n| $B$ | 1 | 10 | 50 | 100 | 200 | 500 | $10^5$ |\n|:---:|:---:|:----:|:----:|:-----:|:-----:|:-----:|:--------:|\n| Python | 167 | 21 | 6.5 | 5.5 | 5 | 5 | >250 |\n| C++ | 130 | 18 | 5.5 | 5.5 | 4.5 | 2.5 | >250 |\n\n注意，批量较小时，上下文切换时间可降至每组 5 秒以内，整个测试集不到一分钟。\n\n**数据范围**\n\n- $1 \\leq T \\leq 10$。\n- 地鼠数量在 2 到 25 之间，口味等级在 1 到 $10^6$ 之间。$S=10^5$。\n\n**测试集 1（10 分，可见）**\n\n- 没有两只地鼠的口味等级相同。\n- 每晚地鼠出洞顺序均匀随机，从所有可能顺序中独立选择。\n\n**测试集 2（38 分，隐藏）**\n\n- 集合 $\\{x : \\text{存在恰好 } x \\geq 1 \\text{ 只地鼠口味等级相同}\\}$ 的最大公约数为 1。\n- 地鼠出洞顺序与所提供零食无关，且每次独立选择。\n\n对于每个测试用例，口味等级的多重集和随机数生成种子由出题人在赛前预先生成，对于任何选手、任何提交都是相同的。这意味着对于同一个测试用例，提交相同数量 $s_i$ 的零食，地鼠出现的顺序也完全相同。\n  - 例如，以下情况在任意测试集都可能出现：\n    * 两只地鼠，口味等级分别为 1 和 2\n  - 以下情况只可能出现在测试集 2，不会出现在测试集 1：\n    * 三只地鼠，两只口味等级为 1，一只口味等级为 2\n  - 以下情况在任意测试集都不会出现：\n    * 六只地鼠，四只口味等级为 1，两只口味等级为 2\n    * 两只地鼠，口味等级均为 7\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13156", "type": "P", "difficulty": 7, "samples": [["3\n5\n0 1001 -1 1001\n0 1001 -1 1001\n0 1001 -2 1001\n0 1001 0 500\n0 1002 1234 5678\n4\n500 500 1000 1000\n500 500 0 1000\n500 500 0 0\n500 500 1000 0\n4\n500 500 1000 1001\n500 500 0 1000\n500 500 0 0\n500 500 1000 0", "Case #1: 1.000000\nCase #2: 0.750000\nCase #3: 1.000000"]], "limits": {"time": [40000, 40000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2018", "Special Judge", "Google Code Jam"], "title": "[GCJ 2018 Finals] The Cartesian Job", "background": "", "description": "You may have heard of the platinum-iridium cylinder that serves as the standard for the kilogram, but did you know that there is a special line segment used as the standard for the kilometer? It runs from $(0, 0)$ to $(0, 1000)$ in a 2D plane in a confidential and very flat location.\n\nNaturally, this segment is extremely valuable, so it is protected by $N$ rotating surveillance lasers, which are rays in the 2D plane. Each laser has a fixed endpoint, and it rotates around that endpoint at a constant speed of 1 revolution per second. Whether each laser rotates clockwise or counterclockwise is chosen uniformly and independently at random by the security system.\n\nLasers are not blocked by other lasers or their endpoints, or the segment itself. No laser has an endpoint on the segment.\n\nYou have been hired to audit the security system, but all you have to work with is a single snapshot from an instant in time, which shows the endpoint and orientation (at that instant) of each laser. Since the image is just a snapshot, you have no way of inferring the rotation directions of the lasers.\n\nYou have determined that the segment could be stolen in a heist if there is ever a non-empty open interval of time during which no laser is touching the segment. What is the probability of this happening?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with one line containing one integer $N$: the number of lasers. Then, $N$ more lines follow. The $i$-th of these lines represents the ray that is the $i$-th laser, and contains four integers $X_i$, $Y_i$, $X_i'$, and $Y_i'$, representing the 2D coordinates of the endpoint of the ray, followed by the 2D coordinates of some other point on the ray.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the probability described above. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, note that multiple lasers might share the same endpoint and initial orientation, but this does not necessarily imply that they rotate in the same direction. (Also note that the second and third lasers have the same initial orientation even though it is specified differently.) Regardless of their rotation directions, though, each of these lasers only touches the segment at the instant that it is pointing in the negative y direction, so there is clearly some other open interval during which no laser is touching the segment, and the answer is 1.\n\nIn Sample Case #2, each of the lasers touches the segment during exactly 1/4 of its rotation, and the segment will be touched by a laser at all times if and only if lasers 1 and 4 rotate in the same direction, and lasers 2 and 3 rotate in the same direction. The probability of that is 1/4, so the answer is 3/4.\n\nSample Case #3 is like Sample Case #2, but with a slight difference that guarantees that there will be an instant at which no laser is touching the segment, even if the lasers are all rotating the same way. So the answer is 1.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $-10^6 \\leq X_i \\leq 10^6$, for all $i$.\n- $-10^6 \\leq Y_i \\leq 10^6$, for all $i$.\n- $-10^6 \\leq X_i' \\leq 10^6$, for all $i$.\n- $-10^6 \\leq Y_i' \\leq 10^6$, for all $i$.\n- $(X_i, Y_i) \\neq (X_i', Y_i')$, for all $i$.\n- If $X_i = 0$, then either $Y_i < 0$ or $Y_i > 1000$, for all $i$. (No laser's endpoint is on the segment.)\n\n**Test set 1 (10 Pts, Visible)**\n\n- $1 \\leq N \\leq 10$.\n\n**Test set 2 (38 Pts, Hidden)**\n\n- $1 \\leq N \\leq 10000$.\n- There are at most 8 cases with $N > 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 Finals] The Cartesian Job", "background": "", "description": "You may have heard of the platinum-iridium cylinder that serves as the standard for the kilogram, but did you know that there is a special line segment used as the standard for the kilometer? It runs from $(0, 0)$ to $(0, 1000)$ in a 2D plane in a confidential and very flat location.\n\nNaturally, this segment is extremely valuable, so it is protected by $N$ rotating surveillance lasers, which are rays in the 2D plane. Each laser has a fixed endpoint, and it rotates around that endpoint at a constant speed of 1 revolution per second. Whether each laser rotates clockwise or counterclockwise is chosen uniformly and independently at random by the security system.\n\nLasers are not blocked by other lasers or their endpoints, or the segment itself. No laser has an endpoint on the segment.\n\nYou have been hired to audit the security system, but all you have to work with is a single snapshot from an instant in time, which shows the endpoint and orientation (at that instant) of each laser. Since the image is just a snapshot, you have no way of inferring the rotation directions of the lasers.\n\nYou have determined that the segment could be stolen in a heist if there is ever a non-empty open interval of time during which no laser is touching the segment. What is the probability of this happening?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with one line containing one integer $N$: the number of lasers. Then, $N$ more lines follow. The $i$-th of these lines represents the ray that is the $i$-th laser, and contains four integers $X_i$, $Y_i$, $X_i'$, and $Y_i'$, representing the 2D coordinates of the endpoint of the ray, followed by the 2D coordinates of some other point on the ray.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the probability described above. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, note that multiple lasers might share the same endpoint and initial orientation, but this does not necessarily imply that they rotate in the same direction. (Also note that the second and third lasers have the same initial orientation even though it is specified differently.) Regardless of their rotation directions, though, each of these lasers only touches the segment at the instant that it is pointing in the negative y direction, so there is clearly some other open interval during which no laser is touching the segment, and the answer is 1.\n\nIn Sample Case #2, each of the lasers touches the segment during exactly 1/4 of its rotation, and the segment will be touched by a laser at all times if and only if lasers 1 and 4 rotate in the same direction, and lasers 2 and 3 rotate in the same direction. The probability of that is 1/4, so the answer is 3/4.\n\nSample Case #3 is like Sample Case #2, but with a slight difference that guarantees that there will be an instant at which no laser is touching the segment, even if the lasers are all rotating the same way. So the answer is 1.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $-10^6 \\leq X_i \\leq 10^6$, for all $i$.\n- $-10^6 \\leq Y_i \\leq 10^6$, for all $i$.\n- $-10^6 \\leq X_i' \\leq 10^6$, for all $i$.\n- $-10^6 \\leq Y_i' \\leq 10^6$, for all $i$.\n- $(X_i, Y_i) \\neq (X_i', Y_i')$, for all $i$.\n- If $X_i = 0$, then either $Y_i < 0$ or $Y_i > 1000$, for all $i$. (No laser's endpoint is on the segment.)\n\n**Test set 1 (10 Pts, Visible)**\n\n- $1 \\leq N \\leq 10$.\n\n**Test set 2 (38 Pts, Hidden)**\n\n- $1 \\leq N \\leq 10000$.\n- There are at most 8 cases with $N > 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 Finals] The Cartesian Job", "background": null, "description": "你可能听说过作为千克标准的铂铱圆柱体，但你知道有一条特殊的线段被用作千米的标准吗？它位于二维平面中的 $(0, 0)$ 到 $(0, 1000)$，地点保密且非常平坦。\n\n自然，这条线段极其珍贵，因此由 $N$ 台旋转监控激光器保护。每台激光器在二维平面中是一条射线，拥有一个固定端点，并以每秒 1 圈的速度围绕该端点旋转。每台激光器是顺时针还是逆时针旋转，由安保系统独立且等概率地随机选择。\n\n激光不会被其他激光、端点或线段本身阻挡。没有任何激光的端点在该线段上。\n\n你被雇佣来审计安保系统，但你只能获得某一时刻的快照，快照显示了每台激光器的端点和当时的朝向。由于这只是一个快照，你无法推断激光器的旋转方向。\n\n你已经确定，如果存在某个非空的时间开区间，在此期间没有任何激光器照射到该线段，则该线段有可能被盗。请问这种情况发生的概率是多少？", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为一个整数 $N$，表示激光器的数量。接下来的 $N$ 行，每行包含四个整数 $X_i$、$Y_i$、$X_i'$、$Y_i'$，表示第 $i$ 台激光器的端点坐标和射线上另一点的坐标。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是所求概率。$y$ 的绝对误差或相对误差在 $10^{-6}$ 以内均视为正确。", "hint": "**样例解释**\n\n在样例 1 中，注意多台激光器可能有相同的端点和初始朝向，但这并不意味着它们的旋转方向相同。（还要注意，第二台和第三台激光器虽然输入不同，但初始朝向相同。）无论旋转方向如何，每台激光器仅在指向负 $y$ 方向时才能照射到线段，因此显然总有一段时间没有激光器照射到线段，答案为 1。\n\n在样例 2 中，每台激光器在旋转周期的 $1/4$ 时间内照射到线段。只有当第 1 和第 4 台激光器旋转方向相同，且第 2 和第 3 台激光器旋转方向相同时，线段才会始终被激光照射。该概率为 $1/4$，所以答案为 $3/4$。\n\n样例 3 与样例 2 类似，但有细微差别，保证即使所有激光器旋转方向相同，也会有某一时刻没有激光器照射到线段，因此答案为 1。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $-10^6 \\leq X_i \\leq 10^6$，对所有 $i$。\n- $-10^6 \\leq Y_i \\leq 10^6$，对所有 $i$。\n- $-10^6 \\leq X_i' \\leq 10^6$，对所有 $i$。\n- $-10^6 \\leq Y_i' \\leq 10^6$，对所有 $i$。\n- $(X_i, Y_i) \\neq (X_i', Y_i')$，对所有 $i$。\n- 如果 $X_i = 0$，则 $Y_i < 0$ 或 $Y_i > 1000$，对所有 $i$。（没有激光器的端点在该线段上。）\n\n**测试点 1（10 分，公开）**\n\n- $1 \\leq N \\leq 10$。\n\n**测试点 2（38 分，隐藏）**\n\n- $1 \\leq N \\leq 10000$。\n- 其中 $N > 100$ 的测试用例不超过 8 个。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13157", "type": "P", "difficulty": 7, "samples": [["5\n2 2\n1 2\n1\n1 2\n2 1\n1 2\n1\n2 2\n1 1\n1\n2\n1 1\n2\n1\n2 5\n1 1\n2\n3\n2 1\n2 4\n2\n3 5\n3 2\n1 2 3\n3 4\n2 4\n3 4\n2 3 4 5\n2 5\n4 5\n1 2 3 4 5\n4 4\n1 1\n1\n4\n2 3\n2 3\n2 3 4\n1 3\n4\n1 2 4\n1 3\n4\n1 3 4", "Case #1: NO\nCase #2: YES\nCase #3: NO\nCase #4: NO\nCase #5: YES"]], "limits": {"time": [10000, 10000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2018", "Google Code Jam"], "title": "[GCJ 2018 Finals] Swordmaster", "background": "", "description": "You are a duelist aspiring to become the next Swordmaster. You will work toward this title by dueling with opponents until you win against every opponent. Every opponent is always available for dueling, and opponents do not duel each other.\n\nEach duelist (including you) knows at least one attack, and at least one defense. There are at most $P$ pairs of attacks and defenses in the world; the $i$-th defense only counters the $i$-th attack, and the $i$-th attack is only countered by the $i$-th defense. It is possible that there are attacks and/or defenses that no duelist knows. You can use any attack or defense that you know as many times as you like; they do not get \"used up\".\n\nHere are the rules for each individual duel with an opponent:\n\n* As the aspiring Swordmaster, you always get to attack first. You select an attack that you know. If the opponent knows the corresponding defense, they may choose to use it. If they do not know that defense, or they choose not to use it, then they do not defend.\n* Then, the opponent selects an attack that they know. If you know the corresponding defense, you may choose to use it. If you do not know that defense, or you choose not to use it, then you do not defend.\n* If you successfully defended and the opponent did not, you win the duel! Otherwise, you do not win, but your quest to become the Swordmaster can continue.\n\nYou can fight as many duels as you want, including multiple duels with the same opponent, regardless of the outcomes of any previous duels. You do not need to determine a complete schedule of duels in advance; you can base your next decision on what has already happened. Once you have won at least once against every opponent, you become the Swordmaster!\n\nYou are an especially quick learner. After each duel, regardless of the outcome of the duel, you can add the attack and the defense (if any) used by the opponent to your own set of known attacks/defenses. (Note that if an opponent uses an unfamiliar defense against you, you do not learn it during the duel itself, so you cannot use it against the opponent's attack in the same duel.) Only you have this advantage; the attacks and defenses known by your opponents never change.\n\nMoreover, after you win against an opponent, and before your next duel, that opponent will teach you all of the attacks and defenses that they know and that you do not already know. (Once they have lost to you, it looks better for them if you eventually do become the Swordmaster!)\n\nYou know which attacks and defenses each opponent knows. If you make optimal choices, is it possible to guarantee that you will become the Swordmaster, regardless of what choices your opponents make?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow.\n\n* Each case begins with one line with two integers $N$ and $P$: the number of duelists (including you), and the maximum number of attack/defense pairs in the world.\n* Then, there are $N$ groups of three lines each. The $i$-th of these groups represents one of the duelists; in particular, the first of them represents you. Each group has the following structure:\n    1. One line with two integers $Attacks_i$ and $Defenses_i$: the numbers of different attacks and defenses, respectively, known by the $i$-th duelist.\n    2. One line with $Attacks_i$ different integers $A_{ij}$, sorted in increasing order: the identities of the attacks known by the $i$-th duelist.\n    3. One line with $Defenses_i$ different integers $D_{ij}$, sorted in increasing order: the identities of the defenses known by the $i$-th duelist.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is `YES` if you can guarantee that you will become the Swordmaster (as described in the problem statement), or `NO` otherwise.", "hint": "**Sample Explanation**\n\nNote that the last four sample cases would not appear in Test set 1.\n\nIn Sample Case #1, as long as your opponent keeps choosing defense 1 and attack 1, you cannot win the duel. There is no guarantee that your opponent will ever choose attack 2 or choose not to use defense 1, so it is not possible to guarantee that you will become the Swordmaster.\n\nIn Sample Case #2, you know attack 1 and defense 2, and your (only) opponent knows attack 2 and defense 1. The following strategy is guaranteed to make you the Swordmaster:\n\n* In your first duel, you must choose attack 1; the opponent may defend with defense 1. Then, the opponent must choose attack 2; you should choose defense 2.\n    * If the opponent did not defend, then you won and you are now the Swordmaster.\n    * Otherwise, you do not win, but you learn attack 2 and defense 1 afterward. Then, start a second duel with that opponent. This time, choose attack 2; the opponent cannot defend against it. Once again, the opponent must choose attack 2; you should choose defense 2. You have won and you are now the Swordmaster.\n\nIn Sample Case #3, in your first duel, if your opponent always chooses attack 4, you will never be able to defend, since nobody knows the defense to that attack. So, there is no way for you to ever become the swordmaster. Note that there can be attacks and/or defenses that exist in the world, but are not known by any of the duelists in this problem.\n\nIn Sample Case #4, there is an opponent that knows every defense, so you cannot guarantee that you will ever win against them (they would have to be nice and not defend!)\n\nHere is one guaranteed winning strategy for Sample Case #5:\n\n1. Duel the first opponent. You must choose attack 1, and they cannot defend. We will proceed assuming that they choose attack 2. (If they choose attack 3, an isomorphic strategy will work.) You cannot defend, and you do not win the duel, but you learn attack 2.\n2. Duel the third opponent, and use attack 2 and defense 4 for a guaranteed win. You learn attack 4 (which you will never use) and defenses 1 and 3.\n3. Duel the second opponent, and use attack 2. You are guaranteed to learn defense 2: either the opponent will use it against you, or they will not use it and you will win (and learn all of their attacks and defenses).\n4. Duel the first opponent again, and choose attack 1. Now, whichever attack they use, you can defend, and you win. You learn attack 3.\n5. Duel the second opponent again, using attack 3, if you did not already win against them before.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq N \\leq 1000$.\n- $1 \\leq P \\leq 1000$.\n- $1 \\leq Attacks_i \\leq P$, for all $i$.\n- $1 \\leq Defenses_i \\leq P$, for all $i$.\n- $1 \\leq A_{ij} < A_{i(j+1)} \\leq P$, for all $i$ and $j$.\n- $1 \\leq D_{ij} < D_{i(j+1)} \\leq P$, for all $i$ and $j$.\n- The sum of all $Attacks_i$ + the sum of all $Defenses_i$, over all $i$, does not exceed $50000$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $A_{i1} = 1$, for all $i$. (Attack 1 is known by all the duelists, including you.)\n- $D_{i1} = 1$, for all $i$. (Defense 1 is known by all the duelists, including you.)\n\n**Test set 2 (38 Pts, Hidden)**\n\n- No extra restrictions.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 Finals] Swordmaster", "background": "", "description": "You are a duelist aspiring to become the next Swordmaster. You will work toward this title by dueling with opponents until you win against every opponent. Every opponent is always available for dueling, and opponents do not duel each other.\n\nEach duelist (including you) knows at least one attack, and at least one defense. There are at most $P$ pairs of attacks and defenses in the world; the $i$-th defense only counters the $i$-th attack, and the $i$-th attack is only countered by the $i$-th defense. It is possible that there are attacks and/or defenses that no duelist knows. You can use any attack or defense that you know as many times as you like; they do not get \"used up\".\n\nHere are the rules for each individual duel with an opponent:\n\n* As the aspiring Swordmaster, you always get to attack first. You select an attack that you know. If the opponent knows the corresponding defense, they may choose to use it. If they do not know that defense, or they choose not to use it, then they do not defend.\n* Then, the opponent selects an attack that they know. If you know the corresponding defense, you may choose to use it. If you do not know that defense, or you choose not to use it, then you do not defend.\n* If you successfully defended and the opponent did not, you win the duel! Otherwise, you do not win, but your quest to become the Swordmaster can continue.\n\nYou can fight as many duels as you want, including multiple duels with the same opponent, regardless of the outcomes of any previous duels. You do not need to determine a complete schedule of duels in advance; you can base your next decision on what has already happened. Once you have won at least once against every opponent, you become the Swordmaster!\n\nYou are an especially quick learner. After each duel, regardless of the outcome of the duel, you can add the attack and the defense (if any) used by the opponent to your own set of known attacks/defenses. (Note that if an opponent uses an unfamiliar defense against you, you do not learn it during the duel itself, so you cannot use it against the opponent's attack in the same duel.) Only you have this advantage; the attacks and defenses known by your opponents never change.\n\nMoreover, after you win against an opponent, and before your next duel, that opponent will teach you all of the attacks and defenses that they know and that you do not already know. (Once they have lost to you, it looks better for them if you eventually do become the Swordmaster!)\n\nYou know which attacks and defenses each opponent knows. If you make optimal choices, is it possible to guarantee that you will become the Swordmaster, regardless of what choices your opponents make?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow.\n\n* Each case begins with one line with two integers $N$ and $P$: the number of duelists (including you), and the maximum number of attack/defense pairs in the world.\n* Then, there are $N$ groups of three lines each. The $i$-th of these groups represents one of the duelists; in particular, the first of them represents you. Each group has the following structure:\n    1. One line with two integers $Attacks_i$ and $Defenses_i$: the numbers of different attacks and defenses, respectively, known by the $i$-th duelist.\n    2. One line with $Attacks_i$ different integers $A_{ij}$, sorted in increasing order: the identities of the attacks known by the $i$-th duelist.\n    3. One line with $Defenses_i$ different integers $D_{ij}$, sorted in increasing order: the identities of the defenses known by the $i$-th duelist.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is `YES` if you can guarantee that you will become the Swordmaster (as described in the problem statement), or `NO` otherwise.", "hint": "**Sample Explanation**\n\nNote that the last four sample cases would not appear in Test set 1.\n\nIn Sample Case #1, as long as your opponent keeps choosing defense 1 and attack 1, you cannot win the duel. There is no guarantee that your opponent will ever choose attack 2 or choose not to use defense 1, so it is not possible to guarantee that you will become the Swordmaster.\n\nIn Sample Case #2, you know attack 1 and defense 2, and your (only) opponent knows attack 2 and defense 1. The following strategy is guaranteed to make you the Swordmaster:\n\n* In your first duel, you must choose attack 1; the opponent may defend with defense 1. Then, the opponent must choose attack 2; you should choose defense 2.\n    * If the opponent did not defend, then you won and you are now the Swordmaster.\n    * Otherwise, you do not win, but you learn attack 2 and defense 1 afterward. Then, start a second duel with that opponent. This time, choose attack 2; the opponent cannot defend against it. Once again, the opponent must choose attack 2; you should choose defense 2. You have won and you are now the Swordmaster.\n\nIn Sample Case #3, in your first duel, if your opponent always chooses attack 4, you will never be able to defend, since nobody knows the defense to that attack. So, there is no way for you to ever become the swordmaster. Note that there can be attacks and/or defenses that exist in the world, but are not known by any of the duelists in this problem.\n\nIn Sample Case #4, there is an opponent that knows every defense, so you cannot guarantee that you will ever win against them (they would have to be nice and not defend!)\n\nHere is one guaranteed winning strategy for Sample Case #5:\n\n1. Duel the first opponent. You must choose attack 1, and they cannot defend. We will proceed assuming that they choose attack 2. (If they choose attack 3, an isomorphic strategy will work.) You cannot defend, and you do not win the duel, but you learn attack 2.\n2. Duel the third opponent, and use attack 2 and defense 4 for a guaranteed win. You learn attack 4 (which you will never use) and defenses 1 and 3.\n3. Duel the second opponent, and use attack 2. You are guaranteed to learn defense 2: either the opponent will use it against you, or they will not use it and you will win (and learn all of their attacks and defenses).\n4. Duel the first opponent again, and choose attack 1. Now, whichever attack they use, you can defend, and you win. You learn attack 3.\n5. Duel the second opponent again, using attack 3, if you did not already win against them before.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq N \\leq 1000$.\n- $1 \\leq P \\leq 1000$.\n- $1 \\leq Attacks_i \\leq P$, for all $i$.\n- $1 \\leq Defenses_i \\leq P$, for all $i$.\n- $1 \\leq A_{ij} < A_{i(j+1)} \\leq P$, for all $i$ and $j$.\n- $1 \\leq D_{ij} < D_{i(j+1)} \\leq P$, for all $i$ and $j$.\n- The sum of all $Attacks_i$ + the sum of all $Defenses_i$, over all $i$, does not exceed $50000$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $A_{i1} = 1$, for all $i$. (Attack 1 is known by all the duelists, including you.)\n- $D_{i1} = 1$, for all $i$. (Defense 1 is known by all the duelists, including you.)\n\n**Test set 2 (38 Pts, Hidden)**\n\n- No extra restrictions.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 Finals] Swordmaster", "background": null, "description": "你是一名决斗者，渴望成为下一任剑术大师。你需要通过与对手决斗，直到你战胜了每一位对手。每个对手始终可以与你决斗，且对手之间不会互相决斗。\n\n每位决斗者（包括你自己）至少掌握一种攻击和一种防御。世界上最多存在 $P$ 对攻击与防御，每一对中的第 $i$ 种防御只能克制第 $i$ 种攻击，第 $i$ 种攻击也只会被第 $i$ 种防御克制。可能存在某些攻击或防御没有任何决斗者掌握。你可以无限次使用自己掌握的任意攻击或防御，它们不会“用完”。\n\n每场与对手的单独决斗规则如下：\n\n- 作为剑术大师的候选人，你总是先攻击。你选择自己会的一种攻击。如果对手会相应的防御，则可以选择使用该防御。如果对手不会该防御，或者选择不使用，则无法防御。\n- 然后，对手选择自己会的一种攻击。如果你会相应的防御，则可以选择使用该防御。如果你不会该防御，或者选择不使用，则无法防御。\n- 如果你成功防御了对手的攻击，而对手没有防御你的攻击，则你赢得这场决斗！否则，你未能获胜，但你追求剑术大师之路可以继续。\n\n你可以进行任意多场决斗，包括与同一对手多次决斗，无论之前的结果如何。你不需要提前安排所有决斗的顺序，可以根据之前的结果决定下一步。只要你至少战胜过每一位对手一次，你就成为了剑术大师！\n\n你有极强的学习能力。每场决斗结束后，无论胜负，你都可以将对手在该场决斗中使用的攻击和防御（如果有）加入到你自己的已知攻击/防御集合中。（注意，如果对手在对你攻击时使用了你不熟悉的防御，你在本场决斗中无法学会，因此不能在本场对对手的攻击使用该防御。）只有你拥有这个优势；对手们掌握的攻击和防御永远不会变化。\n\n此外，在你战胜某位对手后，在下一场决斗之前，该对手会将他们所掌握而你尚未掌握的所有攻击和防御全部教给你。（他们输给你后，希望你最终能成为剑术大师，这样对他们更有面子！）\n\n你知道每位对手掌握哪些攻击和防御。如果你做出最优选择，是否可以保证最终成为剑术大师，无论对手如何选择？", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。\n\n每组数据开头一行包含两个整数 $N$ 和 $P$，分别表示决斗者（包括你自己）的数量，以及世界上最多存在的攻击/防御对数。\n\n接下来有 $N$ 组，每组包含三行，描述每位决斗者（第一个为你自己）：\n\n1. 一行包含两个整数 $Attacks_i$ 和 $Defenses_i$，分别表示第 $i$ 位决斗者已知的攻击数和防御数。\n2. 一行包含 $Attacks_i$ 个不同的递增整数 $A_{ij}$，表示第 $i$ 位决斗者已知的攻击编号。\n3. 一行包含 $Defenses_i$ 个不同的递增整数 $D_{ij}$，表示第 $i$ 位决斗者已知的防御编号。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为 `YES` 或 `NO`，表示你是否可以保证最终成为剑术大师。", "hint": "**样例解释**\n\n注意，最后四个样例不会出现在测试集 1 中。\n\n样例 1 中，只要你的对手一直选择防御 1 并使用攻击 1，你就无法获胜。无法保证对手会选择攻击 2 或不使用防御 1，因此无法保证你能成为剑术大师。\n\n样例 2 中，你会攻击 1 和防御 2，唯一的对手会攻击 2 和防御 1。你可以采用如下策略保证获胜：\n\n- 首先，你必须选择攻击 1；对手可能用防御 1 防御。然后，对手只能选择攻击 2，你应选择防御 2。\n    - 如果对手没有防御，你获胜，成为剑术大师。\n    - 否则，你未能获胜，但你学会了攻击 2 和防御 1。然后再次与该对手决斗，这次你选择攻击 2，对手无法防御。对手仍然只能选择攻击 2，你用防御 2。你获胜，成为剑术大师。\n\n样例 3 中，若对手始终选择攻击 4，你永远无法防御，因为没人会防御 4。因此你无法成为剑术大师。注意，可能存在世界上有攻击或防御，但无人掌握。\n\n样例 4 中，有一位对手掌握所有防御，因此你无法保证战胜他（除非他“好心”不防御）。\n\n样例 5 的一种必胜策略如下：\n\n1. 与第一个对手决斗。你只能选择攻击 1，对方无法防御。假设对方选择攻击 2（如果选择攻击 3，也有类似策略）。你无法防御，未能获胜，但你学会了攻击 2。\n2. 与第三个对手决斗，使用攻击 2 和防御 4，必胜。你学会攻击 4（虽然不会用到）和防御 1、3。\n3. 与第二个对手决斗，使用攻击 2。你一定能学会防御 2：要么对手用它防御你，要么不用你直接获胜（并学会他所有攻击和防御）。\n4. 再次与第一个对手决斗，选择攻击 1。此时无论对方用哪种攻击，你都能防御，获胜。你学会攻击 3。\n5. 如之前未战胜第二个对手，再次与其决斗，使用攻击 3。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $2 \\leq N \\leq 1000$。\n- $1 \\leq P \\leq 1000$。\n- $1 \\leq Attacks_i \\leq P$，对所有 $i$。\n- $1 \\leq Defenses_i \\leq P$，对所有 $i$。\n- $1 \\leq A_{ij} < A_{i(j+1)} \\leq P$，对所有 $i$ 和 $j$。\n- $1 \\leq D_{ij} < D_{i(j+1)} \\leq P$，对所有 $i$ 和 $j$。\n- 所有 $Attacks_i$ 与 $Defenses_i$ 之和不超过 $50000$。\n\n**测试集 1（10 分，可见）**\n\n- 对所有 $i$，$A_{i1} = 1$。（所有决斗者都知道攻击 1，包括你。）\n- 对所有 $i$，$D_{i1} = 1$。（所有决斗者都知道防御 1，包括你。）\n\n**测试集 2（38 分，隐藏）**\n\n- 无额外限制。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13158", "type": "P", "difficulty": 3, "samples": [["3\n---+-++- 3\n+++++ 4\n-+-+- 4", "Case #1: 3\nCase #2: 0\nCase #3: IMPOSSIBLE"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2017", "Google Code Jam"], "title": "[GCJ 2017 Qualification] Oversized Pancake Flipper", "background": "", "description": "Last year, the Infinite House of Pancakes introduced a new kind of pancake. It has a happy face made of chocolate chips on one side (the \"happy side\"), and nothing on the other side (the \"blank side\").\n\nYou are the head cook on duty. The pancakes are cooked in a single row over a hot surface. As part of its infinite efforts to maximize efficiency, the House has recently given you an oversized pancake flipper that flips exactly $K$ consecutive pancakes. That is, in that range of $K$ pancakes, it changes every happy-side pancake to a blank-side pancake, and vice versa; it does not change the left-to-right order of those pancakes.\n\nYou cannot flip fewer than $K$ pancakes at a time with the flipper, even at the ends of the row (since there are raised borders on both sides of the cooking surface). For example, you can flip the first $K$ pancakes, but not the first $K - 1$ pancakes.\n\nYour apprentice cook, who is still learning the job, just used the old-fashioned single-pancake flipper to flip some individual pancakes and then ran to the restroom with it, right before the time when customers come to visit the kitchen. You only have the oversized pancake flipper left, and you need to use it quickly to leave all the cooking pancakes happy side up, so that the customers leave feeling happy with their visit.\n\nGiven the current state of the pancakes, calculate the minimum number of uses of the oversized pancake flipper needed to leave all pancakes happy side up, or state that there is no way to do it.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of one line with a string $S$ and an integer $K$. $S$ represents the row of pancakes: each of its characters is either + (which represents a pancake that is initially happy side up) or - (which represents a pancake that is initially blank side up).\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either `IMPOSSIBLE` if there is no way to get all the pancakes happy side up, or an integer representing the the minimum number of times you will need to use the oversized pancake flipper to do it.", "hint": "**Sample Explanation**\n\n- In Case #1, you can get all the pancakes happy side up by first flipping the leftmost 3 pancakes, getting to ++++-++-, then the rightmost 3, getting to ++++---+, and finally the 3 pancakes that remain blank side up. There are other ways to do it with 3 flips or more, but none with fewer than 3 flips.\n\n- In Case #2, all of the pancakes are already happy side up, so there is no need to flip any of them.\n\n- In Case #3, there is no way to make the second and third pancakes from the left have the same side up, because any flip flips them both. Therefore, there is no way to make all of the pancakes happy side up.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- Every character in $S$ is either + or -.\n- $2 \\leq K \\leq$ length of $S$.\n\n**Small dataset (5 Pts, Test Set 1 - Visible)**\n\n- $2 \\leq$ length of $S \\leq 10$.\n\n**Large dataset (10 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leq$ length of $S \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 Qualification] Oversized Pancake Flipper", "background": "", "description": "Last year, the Infinite House of Pancakes introduced a new kind of pancake. It has a happy face made of chocolate chips on one side (the \"happy side\"), and nothing on the other side (the \"blank side\").\n\nYou are the head cook on duty. The pancakes are cooked in a single row over a hot surface. As part of its infinite efforts to maximize efficiency, the House has recently given you an oversized pancake flipper that flips exactly $K$ consecutive pancakes. That is, in that range of $K$ pancakes, it changes every happy-side pancake to a blank-side pancake, and vice versa; it does not change the left-to-right order of those pancakes.\n\nYou cannot flip fewer than $K$ pancakes at a time with the flipper, even at the ends of the row (since there are raised borders on both sides of the cooking surface). For example, you can flip the first $K$ pancakes, but not the first $K - 1$ pancakes.\n\nYour apprentice cook, who is still learning the job, just used the old-fashioned single-pancake flipper to flip some individual pancakes and then ran to the restroom with it, right before the time when customers come to visit the kitchen. You only have the oversized pancake flipper left, and you need to use it quickly to leave all the cooking pancakes happy side up, so that the customers leave feeling happy with their visit.\n\nGiven the current state of the pancakes, calculate the minimum number of uses of the oversized pancake flipper needed to leave all pancakes happy side up, or state that there is no way to do it.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of one line with a string $S$ and an integer $K$. $S$ represents the row of pancakes: each of its characters is either + (which represents a pancake that is initially happy side up) or - (which represents a pancake that is initially blank side up).\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either `IMPOSSIBLE` if there is no way to get all the pancakes happy side up, or an integer representing the the minimum number of times you will need to use the oversized pancake flipper to do it.", "hint": "**Sample Explanation**\n\n- In Case #1, you can get all the pancakes happy side up by first flipping the leftmost 3 pancakes, getting to ++++-++-, then the rightmost 3, getting to ++++---+, and finally the 3 pancakes that remain blank side up. There are other ways to do it with 3 flips or more, but none with fewer than 3 flips.\n\n- In Case #2, all of the pancakes are already happy side up, so there is no need to flip any of them.\n\n- In Case #3, there is no way to make the second and third pancakes from the left have the same side up, because any flip flips them both. Therefore, there is no way to make all of the pancakes happy side up.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- Every character in $S$ is either + or -.\n- $2 \\leq K \\leq$ length of $S$.\n\n**Small dataset (5 Pts, Test Set 1 - Visible)**\n\n- $2 \\leq$ length of $S \\leq 10$.\n\n**Large dataset (10 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leq$ length of $S \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 Qualification] Oversized Pancake Flipper", "background": null, "description": "去年，Infinite House of Pancakes 推出了一种新型煎饼。这种煎饼的一面（“开心面”）上有用巧克力豆做成的笑脸，另一面（“空白面”）则什么都没有。\n\n你是当班的主厨。煎饼被排成一排在加热面上烹饪。为了进一步提升效率，餐厅最近给你配备了一个超大号煎饼翻转器，每次可以同时翻转恰好 $K$ 个连续的煎饼。也就是说，在这 $K$ 个煎饼的范围内，每个开心面朝上的煎饼会变为空白面朝上，反之亦然；煎饼的左右顺序不会改变。\n\n你不能用翻转器翻转少于 $K$ 个煎饼，即使是在煎饼排的两端（因为加热面两侧有凸起的边界）。例如，你可以翻转最左边的 $K$ 个煎饼，但不能只翻转最左边的 $K-1$ 个煎饼。\n\n你的学徒厨师还在学习工作，他刚刚用老式的单煎饼翻转器翻转了一些单独的煎饼，然后带着翻转器跑去洗手间了，正好在顾客即将参观厨房之前。现在你只剩下超大号煎饼翻转器，你需要尽快使用它，使所有正在烹饪的煎饼都开心面朝上，这样顾客才能满意地离开。\n\n给定当前煎饼的状态，计算至少需要使用多少次超大号煎饼翻转器，才能让所有煎饼都开心面朝上；或者说明无法做到这一点。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来有 $T$ 组测试用例。每组测试用例包含一行，包括一个字符串 $S$ 和一个整数 $K$。$S$ 表示煎饼的排列：每个字符为 +（表示该煎饼初始为开心面朝上）或 -（表示该煎饼初始为空白面朝上）。", "outputFormat": "对于每组测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是所需使用超大号煎饼翻转器的最小次数，或者如果无法做到则输出 `IMPOSSIBLE`。", "hint": "**样例解释**\n\n- 对于第 1 组测试用例，你可以先翻转最左边的 3 个煎饼，变为 ++++-++-，然后翻转最右边的 3 个，变为 ++++---+，最后再翻转剩下的 3 个空白面朝上的煎饼。还有其他方法可以用 3 次或更多次翻转完成，但没有比 3 次更少的方案。\n\n- 对于第 2 组测试用例，所有煎饼已经全部开心面朝上，因此不需要翻转。\n\n- 对于第 3 组测试用例，无法让从左数第 2 和第 3 个煎饼都朝同一面，因为任何一次翻转都会同时翻转它们。因此无法让所有煎饼都开心面朝上。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $S$ 中每个字符均为 + 或 -。\n- $2 \\leq K \\leq S$ 的长度。\n\n**小数据集（5 分，测试集 1 - 可见）**\n\n- $2 \\leq S$ 的长度 $\\leq 10$。\n\n**大数据集（10 分，测试集 2 - 隐藏）**\n\n- $2 \\leq S$ 的长度 $\\leq 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13159", "type": "P", "difficulty": 3, "samples": [["4\n132\n1000\n7\n111111111111111110", "Case #1: 129\nCase #2: 999\nCase #3: 7\nCase #4: 99999999999999999"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["数学", "贪心", "2017", "二分", "Google Code Jam"], "title": "[GCJ 2017 Qualification] Tidy Numbers", "background": "", "description": "Tatiana likes to keep things tidy. Her toys are sorted from smallest to largest, her pencils are sorted from shortest to longest and her computers from oldest to newest. One day, when practicing her counting skills, she noticed that some integers, when written in base 10 with no leading zeroes, have their digits sorted in non-decreasing order. Some examples of this are 8, 123, 555, and 224488. She decided to call these numbers $tidy$. Numbers that do not have this property, like 20, 321, 495 and 999990, are not tidy.\n\nShe just finished counting all positive integers in ascending order from 1 to $N$. What was the last tidy number she counted?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each line describes a test case with a single integer $N$, the last number counted by Tatiana.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the last tidy number counted by Tatiana.", "hint": "**Sample Explanation**\n\nNote that the last sample case would not appear in the Small dataset.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n\n**Small dataset (5 Pts, Test Set 1 - Visible)**\n\n- $1 \\leq N \\leq 1000$.\n\n**Large dataset (10 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq N \\leq 10^{18}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 Qualification] Tidy Numbers", "background": "", "description": "Tatiana likes to keep things tidy. Her toys are sorted from smallest to largest, her pencils are sorted from shortest to longest and her computers from oldest to newest. One day, when practicing her counting skills, she noticed that some integers, when written in base 10 with no leading zeroes, have their digits sorted in non-decreasing order. Some examples of this are 8, 123, 555, and 224488. She decided to call these numbers $tidy$. Numbers that do not have this property, like 20, 321, 495 and 999990, are not tidy.\n\nShe just finished counting all positive integers in ascending order from 1 to $N$. What was the last tidy number she counted?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each line describes a test case with a single integer $N$, the last number counted by Tatiana.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the last tidy number counted by Tatiana.", "hint": "**Sample Explanation**\n\nNote that the last sample case would not appear in the Small dataset.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n\n**Small dataset (5 Pts, Test Set 1 - Visible)**\n\n- $1 \\leq N \\leq 1000$.\n\n**Large dataset (10 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq N \\leq 10^{18}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 Qualification] Tidy Numbers", "background": null, "description": "Tatiana 喜欢保持整洁。她的玩具按照从小到大的顺序排列，她的铅笔按照从短到长的顺序排列，她的电脑按照从旧到新的顺序排列。一天，在练习数数的时候，她注意到有些整数在十进制下书写且没有前导零时，其各位数字是非递减排列的。例如 8、123、555 和 224488 就是这样的数。她决定把这些数称为“tidy”数。不满足这个性质的数，比如 20、321、495 和 999990，就不是 tidy 数。\n\n她刚刚从 1 开始按升序数到了 $N$。她数到的最后一个 tidy 数是多少？", "inputFormat": "输入的第一行包含一个整数 $T$，表示测试用例的数量。接下来的 $T$ 行，每行包含一个整数 $N$，表示 Tatiana 数到的最后一个数。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 Tatiana 数到的最后一个 tidy 数。", "hint": "**样例解释**\n\n注意，最后一个样例不会出现在 Small 数据集里。\n\n**限制条件**\n\n- $1 \\leq T \\leq 100$。\n\n**Small 数据集（5 分，测试集 1 - 可见）**\n\n- $1 \\leq N \\leq 1000$。\n\n**Large 数据集（10 分，测试集 2 - 隐藏）**\n\n- $1 \\leq N \\leq 10^{18}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13160", "type": "P", "difficulty": 4, "samples": [["5\n4 2\n5 2\n6 2\n1000 1000\n1000 1", "Case #1: 1 0\nCase #2: 1 0\nCase #3: 1 1\nCase #4: 0 0\nCase #5: 500 499"]], "limits": {"time": [15000, 15000, 15000], "memory": [1048576, 1048576, 1048576]}, "tags": ["数学", "2017", "Google Code Jam"], "title": "[GCJ 2017 Qualification] Bathroom Stalls", "background": "", "description": "A certain bathroom has $N + 2$ stalls in a single row; the stalls on the left and right ends are permanently occupied by the bathroom guards. The other $N$ stalls are for users.\n\nWhenever someone enters the bathroom, they try to choose a stall that is as far from other people as possible. To avoid confusion, they follow deterministic rules: For each empty stall $S$, they compute two values $L_S$ and $R_S$, each of which is the number of empty stalls between $S$ and the closest occupied stall to the left or right, respectively. Then they consider the set of stalls with the farthest closest neighbor, that is, those $S$ for which $\\min(L_S, R_S)$ is maximal. If there is only one such stall, they choose it; otherwise, they choose the one among those where $\\max(L_S, R_S)$ is maximal. If there are still multiple tied stalls, they choose the leftmost stall among those.\n\n$K$ people are about to enter the bathroom; each one will choose their stall before the next arrives. Nobody will ever leave.\n\nWhen the last person chooses their stall $S$, what will the values of $\\max(L_S, R_S)$ and $\\min(L_S, R_S)$ be?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each line describes a test case with two integers $N$ and $K$, as described above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1), $y$ is $\\max(L_S, R_S)$, and $z$ is $\\min(L_S, R_S)$ as calculated by the last person to enter the bathroom for their chosen stall $S$.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the first person occupies the leftmost of the middle two stalls, leaving the following configuration (O stands for an occupied stall and . for an empty one): `O.O..O`. Then, the second and last person occupies the stall immediately to the right, leaving 1 empty stall on one side and none on the other.\n\nIn Sample Case #2, the first person occupies the middle stall, getting to `O..O..O`. Then, the second and last person occupies the leftmost stall.\n\nIn Sample Case #3, the first person occupies the leftmost of the two middle stalls, leaving `O..O...O`. The second person then occupies the middle of the three consecutive empty stalls.\n\nIn Sample Case #4, every stall is occupied at the end, no matter what the stall choices are.\n\nIn Sample Case #5, the first and only person chooses the leftmost middle stall.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq K \\leq N$.\n\n**Small Dataset 1 (5 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 1000$.\n\n**Small Dataset 2 (10 Pts, Test set 2 - Visible)**\n\n- $1 \\leq N \\leq 10^{6}$.\n\n**Large Dataset (15 Pts, Test set 3 - Hidden)**\n\n- $1 \\leq N \\leq 10^{18}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 Qualification] Bathroom Stalls", "background": "", "description": "A certain bathroom has $N + 2$ stalls in a single row; the stalls on the left and right ends are permanently occupied by the bathroom guards. The other $N$ stalls are for users.\n\nWhenever someone enters the bathroom, they try to choose a stall that is as far from other people as possible. To avoid confusion, they follow deterministic rules: For each empty stall $S$, they compute two values $L_S$ and $R_S$, each of which is the number of empty stalls between $S$ and the closest occupied stall to the left or right, respectively. Then they consider the set of stalls with the farthest closest neighbor, that is, those $S$ for which $\\min(L_S, R_S)$ is maximal. If there is only one such stall, they choose it; otherwise, they choose the one among those where $\\max(L_S, R_S)$ is maximal. If there are still multiple tied stalls, they choose the leftmost stall among those.\n\n$K$ people are about to enter the bathroom; each one will choose their stall before the next arrives. Nobody will ever leave.\n\nWhen the last person chooses their stall $S$, what will the values of $\\max(L_S, R_S)$ and $\\min(L_S, R_S)$ be?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each line describes a test case with two integers $N$ and $K$, as described above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1), $y$ is $\\max(L_S, R_S)$, and $z$ is $\\min(L_S, R_S)$ as calculated by the last person to enter the bathroom for their chosen stall $S$.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the first person occupies the leftmost of the middle two stalls, leaving the following configuration (O stands for an occupied stall and . for an empty one): `O.O..O`. Then, the second and last person occupies the stall immediately to the right, leaving 1 empty stall on one side and none on the other.\n\nIn Sample Case #2, the first person occupies the middle stall, getting to `O..O..O`. Then, the second and last person occupies the leftmost stall.\n\nIn Sample Case #3, the first person occupies the leftmost of the two middle stalls, leaving `O..O...O`. The second person then occupies the middle of the three consecutive empty stalls.\n\nIn Sample Case #4, every stall is occupied at the end, no matter what the stall choices are.\n\nIn Sample Case #5, the first and only person chooses the leftmost middle stall.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq K \\leq N$.\n\n**Small Dataset 1 (5 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 1000$.\n\n**Small Dataset 2 (10 Pts, Test set 2 - Visible)**\n\n- $1 \\leq N \\leq 10^{6}$.\n\n**Large Dataset (15 Pts, Test set 3 - Hidden)**\n\n- $1 \\leq N \\leq 10^{18}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 Qualification] Bathroom Stalls", "background": null, "description": "某间洗手间有 $N + 2$ 个隔间排成一排，最左端和最右端的隔间被洗手间管理员永久占用。其余 $N$ 个隔间供用户使用。\n\n每当有人进入洗手间时，他们会尽量选择距离其他人最远的隔间。为避免混淆，他们遵循如下确定性规则：对于每一个空隔间 $S$，计算两个值 $L_S$ 和 $R_S$，分别表示 $S$ 到其左侧最近被占用隔间之间的空隔间数，以及到其右侧最近被占用隔间之间的空隔间数。然后，他们会考虑那些最近邻距离最远的隔间，即使得 $\\min(L_S, R_S)$ 最大的所有 $S$。如果只有一个这样的隔间，则选择它；否则，在这些隔间中选择 $\\max(L_S, R_S)$ 最大的那个。如果仍有多个隔间并列，则选择这些隔间中最靠左的一个。\n\n有 $K$ 个人即将依次进入洗手间；每个人都会在下一个人到来前选择好自己的隔间。没有人会离开。\n\n当最后一个人选择隔间 $S$ 时，对于他所选隔间，$\\max(L_S, R_S)$ 和 $\\min(L_S, R_S)$ 的值分别是多少？", "inputFormat": "输入的第一行为测试用例数 $T$。接下来的 $T$ 行，每行描述一个测试用例，包含两个整数 $N$ 和 $K$，含义如上所述。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y z`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为最后一个人选择的隔间 $S$ 的 $\\max(L_S, R_S)$，$z$ 为 $\\min(L_S, R_S)$。", "hint": "**样例解释**\n\n在样例 1 中，第一个人占据了中间两个隔间中最左边的一个，剩下的状态为（O 表示已占用，. 表示空）：`O.O..O`。然后，第二个人（也是最后一个人）占据了紧挨着右侧的隔间，此时一侧有 1 个空隔间，另一侧没有空隔间。\n\n在样例 2 中，第一个人占据了中间的隔间，状态变为 `O..O..O`。然后，第二个人占据了最左边的隔间。\n\n在样例 3 中，第一个人占据了两个中间隔间中最左边的一个，状态为 `O..O...O`。第二个人随后占据了连续三个空隔间中间的那个。\n\n在样例 4 中，最后所有隔间都被占满，无论选择顺序如何。\n\n在样例 5 中，唯一一个人选择了最左边的中间隔间。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq K \\leq N$。\n\n**小数据集 1（5 分，测试点 1 - 可见）**\n\n- $1 \\leq N \\leq 1000$。\n\n**小数据集 2（10 分，测试点 2 - 可见）**\n\n- $1 \\leq N \\leq 10^{6}$。\n\n**大数据集（15 分，测试点 3 - 隐藏）**\n\n- $1 \\leq N \\leq 10^{18}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13161", "type": "P", "difficulty": 6, "samples": [["3\n2 0\n1 1\no 1 1\n3 4\n+ 2 3\n+ 2 1\nx 3 1\n+ 2 2", "Case #1: 4 3\no 2 2\n+ 2 1\nx 1 1\nCase #2: 2 0\nCase #3: 6 2\no 2 3\nx 1 2"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2017", "Special Judge", "Google Code Jam"], "title": "[GCJ 2017 Qualification] Fashion Show", "background": "", "description": "You are about to host a fashion show to show off three new styles of clothing. The show will be held on a stage which is in the most fashionable of all shapes: an $N$-by-$N$ grid of cells.\n\nEach cell in the grid can be empty (which we represent with a `.` character) or can contain one fashion model. The models come in three types, depending on the clothing style they are wearing: `+`, `x`, and the super-trendy `o`. A cell with a `+` or `x` model in it adds 1 style point to the show. A cell with an `o` model in it adds 2 style points. Empty cells add no style points.\n\nTo achieve the maximum artistic effect, there are rules on how models can be placed relative to each other.\n\n* Whenever any two models share a row or column, at least one of the two must be a `+`.\n* Whenever any two models share a diagonal of the grid, at least one of the two must be an `x`.\n\nFormally, a model located in row $i_0$ and column $j_0$ and a model located in row $i_1$ and column $j_1$ share a row if and only if $i_0 = i_1$, they share a column if and only if $j_0 = j_1$, and they share a diagonal if and only if $i_0 + j_0 = i_1 + j_1$ or $i_0 - j_0 = i_1 - j_1$.\n\nFor example, the following grid is not legal:\n\n```\n...\nx+o\n.+.\n```\n\nThe middle row has a pair of models (`x` and `o`) that does not include a `+`. The diagonal starting at the `+` in the bottom row and running up to the `o` in the middle row has two models, and neither of them is an `x`.\n\nHowever, the following grid is legal. No row, column, or diagonal violates the rules.\n\n```\n+.x\n+x+\no..\n```\n\nYour artistic advisor has already placed $M$ models in certain cells, following these rules. You are free to place any number (including zero) of additional models of whichever types you like. You may not remove existing models, but you may upgrade as many existing `+` and `x` models into o models as you wish, as long as the above rules are not violated.\n\nYour task is to find a legal way of placing and/or upgrading models that earns the maximum possible number of style points.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with one line with two integers $N$ and $M$, as described above. Then, $M$ more lines follow; the $i$-th of these lines has a `+`, `x`, or `o` character (the type of the model) and two integers $R_i$ and $C_i$ (the position of the model). The rows of the grid are numbered 1 through $N$, from top to bottom. The columns of the grid are numbered 1 through $N$, from left to right.\n", "outputFormat": "For each test case, first output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1), $y$ is the number of style points earned in your arrangement, and $z$ is the total number of models you have added and/or substituted in. Then, for each model that you have added or substituted in, output exactly one line in exactly the same format described in the Input section, where the character is the type of the model that you have added or substituted in. These $z$ lines can be in any order.\n\nIf there are multiple valid answers, you may output any one of them.", "hint": "**Sample Explanation**\n\nThe sample output displays one set of answers to the sample cases. Other answers may be possible. Note that the last sample case would not appear in the Small dataset.\n\nIn sample case #1, the grid is 2-by-2 and is initially blank. The output corresponds to the following grid. (In these explanations, we will use . to denote a blank cell.)\n```\nx.\n+o\n```\nIn sample case #2, the only cell is already occupied by an o model, and it is impossible to add a new model or replace the o model.\n\nIn sample case #3, the grid looks like this before you place any models:\n```\n...\n+++\nx..\n```\nThe output corresponds to this grid:\n```\n.x.\n++o\nx..\n```\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N \\leq 100$.\n- $1 \\leq C_i \\leq N$, for all $i$.\n- $0 \\leq M \\leq N^2$.\n- No two pre-placed models appear in the same cell.\n- It is guaranteed that the set of pre-placed models follows the rules.\n\n**Small dataset (10 Pts, Test Set 1 - Visible)**\n\n- $R_i = 1$, for all $i$. (Any models that are pre-placed are in the top row. Note that you may add/replace models in that row and/or add models in other rows.)\n\n**Large dataset (25 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq R_i \\leq N$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 Qualification] Fashion Show", "background": "", "description": "You are about to host a fashion show to show off three new styles of clothing. The show will be held on a stage which is in the most fashionable of all shapes: an $N$-by-$N$ grid of cells.\n\nEach cell in the grid can be empty (which we represent with a `.` character) or can contain one fashion model. The models come in three types, depending on the clothing style they are wearing: `+`, `x`, and the super-trendy `o`. A cell with a `+` or `x` model in it adds 1 style point to the show. A cell with an `o` model in it adds 2 style points. Empty cells add no style points.\n\nTo achieve the maximum artistic effect, there are rules on how models can be placed relative to each other.\n\n* Whenever any two models share a row or column, at least one of the two must be a `+`.\n* Whenever any two models share a diagonal of the grid, at least one of the two must be an `x`.\n\nFormally, a model located in row $i_0$ and column $j_0$ and a model located in row $i_1$ and column $j_1$ share a row if and only if $i_0 = i_1$, they share a column if and only if $j_0 = j_1$, and they share a diagonal if and only if $i_0 + j_0 = i_1 + j_1$ or $i_0 - j_0 = i_1 - j_1$.\n\nFor example, the following grid is not legal:\n\n```\n...\nx+o\n.+.\n```\n\nThe middle row has a pair of models (`x` and `o`) that does not include a `+`. The diagonal starting at the `+` in the bottom row and running up to the `o` in the middle row has two models, and neither of them is an `x`.\n\nHowever, the following grid is legal. No row, column, or diagonal violates the rules.\n\n```\n+.x\n+x+\no..\n```\n\nYour artistic advisor has already placed $M$ models in certain cells, following these rules. You are free to place any number (including zero) of additional models of whichever types you like. You may not remove existing models, but you may upgrade as many existing `+` and `x` models into o models as you wish, as long as the above rules are not violated.\n\nYour task is to find a legal way of placing and/or upgrading models that earns the maximum possible number of style points.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with one line with two integers $N$ and $M$, as described above. Then, $M$ more lines follow; the $i$-th of these lines has a `+`, `x`, or `o` character (the type of the model) and two integers $R_i$ and $C_i$ (the position of the model). The rows of the grid are numbered 1 through $N$, from top to bottom. The columns of the grid are numbered 1 through $N$, from left to right.\n", "outputFormat": "For each test case, first output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1), $y$ is the number of style points earned in your arrangement, and $z$ is the total number of models you have added and/or substituted in. Then, for each model that you have added or substituted in, output exactly one line in exactly the same format described in the Input section, where the character is the type of the model that you have added or substituted in. These $z$ lines can be in any order.\n\nIf there are multiple valid answers, you may output any one of them.", "hint": "**Sample Explanation**\n\nThe sample output displays one set of answers to the sample cases. Other answers may be possible. Note that the last sample case would not appear in the Small dataset.\n\nIn sample case #1, the grid is 2-by-2 and is initially blank. The output corresponds to the following grid. (In these explanations, we will use . to denote a blank cell.)\n```\nx.\n+o\n```\nIn sample case #2, the only cell is already occupied by an o model, and it is impossible to add a new model or replace the o model.\n\nIn sample case #3, the grid looks like this before you place any models:\n```\n...\n+++\nx..\n```\nThe output corresponds to this grid:\n```\n.x.\n++o\nx..\n```\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N \\leq 100$.\n- $1 \\leq C_i \\leq N$, for all $i$.\n- $0 \\leq M \\leq N^2$.\n- No two pre-placed models appear in the same cell.\n- It is guaranteed that the set of pre-placed models follows the rules.\n\n**Small dataset (10 Pts, Test Set 1 - Visible)**\n\n- $R_i = 1$, for all $i$. (Any models that are pre-placed are in the top row. Note that you may add/replace models in that row and/or add models in other rows.)\n\n**Large dataset (25 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq R_i \\leq N$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 Qualification] Fashion Show", "background": null, "description": "你即将举办一场时装秀，展示三种新款服装。秀场的舞台是最时尚的形状：一个 $N \\times N$ 的网格。\n\n网格中的每个格子可以是空的（用 `.` 表示），也可以有一位时装模特。模特分为三种类型，取决于他们所穿的服装风格：`+`、`x`，以及超级时尚的 `o`。一个格子中如果有 `+` 或 `x` 型模特，将为秀场增加 1 分风格分；如果有 `o` 型模特，则增加 2 分风格分。空格子不加分。\n\n为了达到最佳艺术效果，模特的摆放有如下规则：\n\n- 只要有两个模特处于同一行或同一列，这两个模特中至少有一个必须是 `+`。\n- 只要有两个模特处于同一对角线，这两个模特中至少有一个必须是 `x`。\n\n形式化地说，若一个模特位于第 $i_0$ 行第 $j_0$ 列，另一个模特位于第 $i_1$ 行第 $j_1$ 列，则当 $i_0 = i_1$ 时他们同一行，当 $j_0 = j_1$ 时同一列，当 $i_0 + j_0 = i_1 + j_1$ 或 $i_0 - j_0 = i_1 - j_1$ 时同一对角线。\n\n例如，下面这个网格是不合法的：\n\n```\n...\nx+o\n.+.\n```\n\n中间一行有一对模特（`x` 和 `o`），但其中没有 `+`。从底行的 `+` 到中间行的 `o` 的对角线上有两个模特，但都不是 `x`。\n\n而下面这个网格是合法的，没有任何行、列或对角线违反规则：\n\n```\n+.x\n+x+\no..\n```\n\n你的艺术顾问已经按照规则在某些格子中预先放置了 $M$ 个模特。你可以在任意数量（包括零个）格子中自由添加任意类型的模特。你不能移除已有的模特，但可以将已有的 `+` 或 `x` 型模特升级为 `o` 型，只要不违反上述规则。\n\n你的任务是找到一种合法的放置和/或升级方式，使得获得的风格分最大。", "inputFormat": "第一行输入一个整数 $T$，表示测试用例的数量。接下来有 $T$ 组测试数据。每组测试数据的第一行包含两个整数 $N$ 和 $M$。接下来 $M$ 行，每行包含一个字符（`+`、`x` 或 `o`）和两个整数 $R_i$、$C_i$，表示该模特的类型和位置。网格的行从上到下编号为 $1$ 到 $N$，列从左到右编号为 $1$ 到 $N$。", "outputFormat": "对于每个测试用例，首先输出一行 `Case #x: y z`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是你安排下获得的风格分，$z$ 是你添加和/或替换的模特总数。然后，对于每一个你添加或替换的模特，输出一行，格式与输入部分相同，字符为你添加或替换的模特类型。这 $z$ 行顺序不限。\n\n如果有多种合法方案，你可以输出其中任意一种。", "hint": "**样例说明**\n\n样例输出展示了样例数据的一组解。其他解也是可能的。注意最后一个样例不会出现在 Small 数据集中。\n\n在样例 1 中，网格为 $2 \\times 2$，初始为空。输出对应如下网格（用 `.` 表示空格）：\n```\nx.\n+o\n```\n在样例 2 中，唯一的格子已经被 `o` 型模特占据，无法再添加或替换模特。\n\n在样例 3 中，初始网格如下：\n```\n...\n+++\nx..\n```\n输出对应如下网格：\n```\n.x.\n++o\nx..\n```\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq N \\leq 100$。\n- $1 \\leq C_i \\leq N$，对所有 $i$。\n- $0 \\leq M \\leq N^2$。\n- 不会有两个预放置的模特在同一格子。\n- 保证所有预放置的模特均符合规则。\n\n**小数据（10 分，测试集 1 - 可见）**\n\n- $R_i = 1$，对所有 $i$。（所有预放置的模特都在第一行。你可以在该行添加/替换模特，也可以在其他行添加模特。）\n\n**大数据（25 分，测试集 2 - 隐藏）**\n\n- $1 \\leq R_i \\leq N$，对所有 $i$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13162", "type": "P", "difficulty": 3, "samples": [["3\n3 3\nG??\n?C?\n??J\n3 4\nCODE\n????\n?JAM\n2 2\nCA\nKE", "Case #1:\nGGJ\nCCJ\nCCJ\nCase #2:\nCODE\nCOAE\nJJAM\nCase #3:\nCA\nKE"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["数学", "贪心", "2017", "递归", "Special Judge", "Google Code Jam"], "title": "[GCJ 2017 #1A] Alphabet Cake", "background": "", "description": "You are catering a party for some children, and you are serving them a cake in the shape of a grid with $R$ rows and $C$ columns. Your assistant has started to decorate the cake by writing every child's initial in icing on exactly one cell of the cake. Each cell contains at most one initial, and since no two children share the same initial, no initial appears more than once on the cake.\n\nEach child wants a single rectangular (grid-aligned) piece of cake that has their initial and no other child's initial(s). Can you find a way to assign every blank cell of the cake to one child, such that this goal is accomplished? It is guaranteed that this is always possible. There is no need to split the cake evenly among the children, and one or more of them may even get a 1-by-1 piece; this will be a valuable life lesson about unfairness.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line with two integers $R$ and $C$. Then, there are $R$ more lines of $C$ characters each, representing the cake. Each character is either an uppercase English letter (which means that your assistant has already added that letter to that cell) or ? (which means that that cell is blank).\n", "outputFormat": "For each test case, output one line containing `Case #x:` and nothing else. Then output $R$ more lines of $C$ characters each. Your output grid must be identical to the input grid, but with every `?` replaced with an uppercase English letter, representing that that cell appears in the slice for the child who has that initial. You may not add letters that did not originally appear in the input. In your grid, for each letter, the region formed by all the cells containing that letter must be a single grid-aligned rectangle.", "hint": "**Sample Explanation**\n\nThe sample output displays one set of answers to the sample cases. Other answers may be possible.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- There is at least one letter in the input grid.\n- No letter appears in more than one cell in the input grid.\n- It is guaranteed that at least one answer exists for each test case.\n\n**Small dataset (8 Pts, Test Set 1 - Visible)**\n\n- $1 \\leq R \\leq 12$.\n- $1 \\leq C \\leq 12$.\n- $R \\times C \\leq 12$.\n\n**Large dataset (13 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq R \\leq 25$.\n- $1 \\leq C \\leq 25$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #1A] Alphabet Cake", "background": "", "description": "You are catering a party for some children, and you are serving them a cake in the shape of a grid with $R$ rows and $C$ columns. Your assistant has started to decorate the cake by writing every child's initial in icing on exactly one cell of the cake. Each cell contains at most one initial, and since no two children share the same initial, no initial appears more than once on the cake.\n\nEach child wants a single rectangular (grid-aligned) piece of cake that has their initial and no other child's initial(s). Can you find a way to assign every blank cell of the cake to one child, such that this goal is accomplished? It is guaranteed that this is always possible. There is no need to split the cake evenly among the children, and one or more of them may even get a 1-by-1 piece; this will be a valuable life lesson about unfairness.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line with two integers $R$ and $C$. Then, there are $R$ more lines of $C$ characters each, representing the cake. Each character is either an uppercase English letter (which means that your assistant has already added that letter to that cell) or ? (which means that that cell is blank).\n", "outputFormat": "For each test case, output one line containing `Case #x:` and nothing else. Then output $R$ more lines of $C$ characters each. Your output grid must be identical to the input grid, but with every `?` replaced with an uppercase English letter, representing that that cell appears in the slice for the child who has that initial. You may not add letters that did not originally appear in the input. In your grid, for each letter, the region formed by all the cells containing that letter must be a single grid-aligned rectangle.", "hint": "**Sample Explanation**\n\nThe sample output displays one set of answers to the sample cases. Other answers may be possible.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- There is at least one letter in the input grid.\n- No letter appears in more than one cell in the input grid.\n- It is guaranteed that at least one answer exists for each test case.\n\n**Small dataset (8 Pts, Test Set 1 - Visible)**\n\n- $1 \\leq R \\leq 12$.\n- $1 \\leq C \\leq 12$.\n- $R \\times C \\leq 12$.\n\n**Large dataset (13 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq R \\leq 25$.\n- $1 \\leq C \\leq 25$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #1A] Alphabet Cake", "background": null, "description": "你正在为一些孩子举办一个聚会，并为他们准备了一个蛋糕，蛋糕的形状是一个 $R$ 行 $C$ 列的网格。你的助手已经开始装饰蛋糕，在每个孩子的首字母上用糖霜写在蛋糕的某一个格子里。每个格子最多只包含一个首字母，并且没有两个孩子的首字母相同，因此每个首字母在蛋糕上只出现一次。\n\n每个孩子都希望得到一块包含自己首字母且不包含其他孩子首字母的矩形（与网格对齐）蛋糕。你能否为蛋糕上的每一个空白格子分配归属，使得每个孩子都能得到满足要求的蛋糕块？保证一定存在可行解。蛋糕不需要平均分配，甚至有的孩子可能只得到 $1 \\times 1$ 的小块；这将是关于不公平的宝贵人生课程。", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试数据。每组数据的第一行为两个整数 $R$ 和 $C$。接下来 $R$ 行，每行 $C$ 个字符，表示蛋糕的网格。每个字符要么是一个大写英文字母（表示你的助手已经在该格子写上了这个字母），要么是 `?`（表示该格子为空）。", "outputFormat": "对于每组测试数据，输出一行 `Case #x:`，其中 $x$ 是当前测试数据的编号（从 1 开始）。然后输出 $R$ 行，每行 $C$ 个字符，表示你分配后的蛋糕网格。你的输出网格必须与输入网格相同，只不过将所有的 `?` 替换为大写英文字母，表示该格子属于哪个孩子的蛋糕块。你不能添加输入中没有出现过的字母。在你的输出网格中，对于每个字母，所有包含该字母的格子必须组成一个与网格对齐的矩形区域。", "hint": "**样例解释**\n\n样例输出展示了样例数据的一组可行解。其他解也是可能的。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- 输入网格中至少有一个字母。\n- 每个字母最多只在一个格子中出现一次。\n- 保证每组测试数据都至少有一个解。\n\n**小数据范围（8 分，测试点 1 - 可见）**\n\n- $1 \\leq R \\leq 12$。\n- $1 \\leq C \\leq 12$。\n- $R \\times C \\leq 12$。\n\n**大数据范围（13 分，测试点 2 - 隐藏）**\n\n- $1 \\leq R \\leq 25$。\n- $1 \\leq C \\leq 25$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13163", "type": "P", "difficulty": 4, "samples": [["6\n2 1\n500 300\n900\n660\n2 1\n500 300\n1500\n809\n2 2\n50 100\n450 449\n1100 1101\n2 1\n500 300\n300\n500\n1 8\n10\n11 13 17 11 16 14 12 18\n3 3\n70 80 90\n1260 1500 700\n800 1440 1600\n1700 1620 900", "Case #1: 1\nCase #2: 0\nCase #3: 1\nCase #4: 0\nCase #5: 3\nCase #6: 3"]], "limits": {"time": [15000, 30000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2017", "Google Code Jam"], "title": "[GCJ 2017 #1A] Ratatouille", "background": "", "description": "You've discovered it: the ultimate recipe for ratatouille, the famous French dish! You know which ingredients to use, and how many grams of each one to use, in order to make one serving of ratatouille. But you believe that anyone can cook, and so you want to share the recipe with the world... and make some money in the process!\n\nYou have ordered some ingredient packages that are easy to ship. Each package contains some amount of one ingredient; different packages may have different amounts even if they contain the same ingredient. For convenience, you ordered the same number of packages of each ingredient.\n\nYou would like to use these packages to form as many ratatouille kits as possible to send to customers. A kit consists of exactly one package of each ingredient, and a label with the integer number of servings of ratatouille that the kit makes. Since you do not want to shortchange customers or waste food, each package must contain between $90$ and $110$ percent (inclusive) of the amount of that ingredient that is actually needed to make the number of servings of ratatouille on the kit's label.\n\nFor example, suppose that one serving of ratatouille takes $500$ g of tomato and $300$ g of onion. Suppose that you have a $900$ g package of tomato and a $660$ g package of onion. You could form these into a kit that makes two servings of ratatouille. To make two servings, $1000$ g of tomato and $600$ g of onion are required. Since the $900$ g of tomato you have is within $[90, 110]\\%$ of the $1000$ g of tomato required, and the $660$ g of onion you have is within $[90, 110]\\%$ of the $600$ g of onion required, this is acceptable. However, you could not say that the kit makes one or three servings of ratatouille, nor could you say that it makes $1.999$ servings (the number of servings must be an integer).\n\nNote that there are some sets of packages that could never form a kit. Continuing with our recipe above, if you have a $1500$ g package of tomato and an $809$ g package of onion, for example, there is no amount of servings that you can make. Three servings would take $1500$ g of tomato and $900$ g of onion, and the amount of onion is not within the $[90, 110]\\%$ range. No other integer amount of servings works, either.\n\nYou want to share your recipe with as many customers as possible, so you want to produce the maximum number of valid kits. (Of course, each package can be used in at most one kit.) What is the largest number of kits that you can form? Note that you are not required to maximize the total number of servings of ratatouille formed.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case consists of the following:\n\n* One line with two integers $N$: the number of ingredients, and $P$, the number of packages of each ingredient.\n* One line with $N$ integers $R_i$. The i-th of these represents the number of grams of the i-th ingredient needed to make one serving of ratatouille.\n* $N$ more lines of $P$ integers each. The j-th value on the i-th of these lines, $Q_{ij}$, represents the quantity, in grams, in the j-th package of the i-th ingredient.", "outputFormat": "For each test case, output one line containing Case #x: y, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of kits you can produce, as described above.", "hint": "**Sample Explanation**\n\nNote that the last sample case would not appear in the Small dataset.\n\nSample cases #1 and #2 are the ones described in the problem statement.\n\nIn sample case #3, you can form a kit out of the $450$ g package of the first ingredient and the $1100$ g package of the second ingredient, and say that the kit makes $10$ servings of ratatouille. That number of servings requires $500$ g of the first ingredient; you have $450$ g, which is $90\\%$ of $500$ and within the allowed limit. It requires $1000$ g of the second ingredient; you have $1100$ g, which is $110\\%$ of $1000$ and within the allowed limit.\n\nOnce you form this kit, however, you cannot form the remaining packages into a kit. $449$ g of the first ingredient and $1101$ g of the second ingredient would not be able to form $10$ (or any other number of) servings. In fact, the ($450$ g, $1100$ g) kit is the only kit that can be formed from these packages.\n\nIn sample case #4, no kits can be formed. Note that the recipe requires particular amounts of particular ingredients in the given order, the ingredients are not interchangeable. This is fine French cuisine, after all!\n\nIn sample case #5, the recipe has only one ingredient — how elegantly simple! A single serving cannot use more than $11$ g, and two servings cannot use fewer than $18$ g. It is possible to form three kits: two with an $11$ g package, and one with an $18$ g package.\n\nIn sample case #6, you can form three valid kits: ($700$ g, $800$ g, $900$ g), which makes $10$ servings, and ($1500$ g, $1600$ g, $1700$ g) and ($1260$ g, $1440$ g, $1620$ g), each of which makes $20$ servings. Note that you could also say that the ($1260$ g, $1440$ g, $1620$ g) kit makes $17$, $18$, or $19$ servings, but it does not matter how many servings a kit makes as long as the kit is valid.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq R_i \\leq 10^6$, for all $i$.\n- $1 \\leq Q_{ij} \\leq 10^6$, for all $i$ and $j$.\n\n**Small dataset (12 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $1 \\leq N \\leq 2$.\n- $1 \\leq P \\leq 8$.\n\n**Large dataset (23 Pts, Test Set 2 - Hidden)**\n\n- Time limit: ~~120~~ 30 seconds.\n- $1 \\leq N \\leq 50$.\n- $1 \\leq P \\leq 50$.\n- $N \\times P \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #1A] Ratatouille", "background": "", "description": "You've discovered it: the ultimate recipe for ratatouille, the famous French dish! You know which ingredients to use, and how many grams of each one to use, in order to make one serving of ratatouille. But you believe that anyone can cook, and so you want to share the recipe with the world... and make some money in the process!\n\nYou have ordered some ingredient packages that are easy to ship. Each package contains some amount of one ingredient; different packages may have different amounts even if they contain the same ingredient. For convenience, you ordered the same number of packages of each ingredient.\n\nYou would like to use these packages to form as many ratatouille kits as possible to send to customers. A kit consists of exactly one package of each ingredient, and a label with the integer number of servings of ratatouille that the kit makes. Since you do not want to shortchange customers or waste food, each package must contain between $90$ and $110$ percent (inclusive) of the amount of that ingredient that is actually needed to make the number of servings of ratatouille on the kit's label.\n\nFor example, suppose that one serving of ratatouille takes $500$ g of tomato and $300$ g of onion. Suppose that you have a $900$ g package of tomato and a $660$ g package of onion. You could form these into a kit that makes two servings of ratatouille. To make two servings, $1000$ g of tomato and $600$ g of onion are required. Since the $900$ g of tomato you have is within $[90, 110]\\%$ of the $1000$ g of tomato required, and the $660$ g of onion you have is within $[90, 110]\\%$ of the $600$ g of onion required, this is acceptable. However, you could not say that the kit makes one or three servings of ratatouille, nor could you say that it makes $1.999$ servings (the number of servings must be an integer).\n\nNote that there are some sets of packages that could never form a kit. Continuing with our recipe above, if you have a $1500$ g package of tomato and an $809$ g package of onion, for example, there is no amount of servings that you can make. Three servings would take $1500$ g of tomato and $900$ g of onion, and the amount of onion is not within the $[90, 110]\\%$ range. No other integer amount of servings works, either.\n\nYou want to share your recipe with as many customers as possible, so you want to produce the maximum number of valid kits. (Of course, each package can be used in at most one kit.) What is the largest number of kits that you can form? Note that you are not required to maximize the total number of servings of ratatouille formed.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case consists of the following:\n\n* One line with two integers $N$: the number of ingredients, and $P$, the number of packages of each ingredient.\n* One line with $N$ integers $R_i$. The i-th of these represents the number of grams of the i-th ingredient needed to make one serving of ratatouille.\n* $N$ more lines of $P$ integers each. The j-th value on the i-th of these lines, $Q_{ij}$, represents the quantity, in grams, in the j-th package of the i-th ingredient.", "outputFormat": "For each test case, output one line containing Case #x: y, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of kits you can produce, as described above.", "hint": "**Sample Explanation**\n\nNote that the last sample case would not appear in the Small dataset.\n\nSample cases #1 and #2 are the ones described in the problem statement.\n\nIn sample case #3, you can form a kit out of the $450$ g package of the first ingredient and the $1100$ g package of the second ingredient, and say that the kit makes $10$ servings of ratatouille. That number of servings requires $500$ g of the first ingredient; you have $450$ g, which is $90\\%$ of $500$ and within the allowed limit. It requires $1000$ g of the second ingredient; you have $1100$ g, which is $110\\%$ of $1000$ and within the allowed limit.\n\nOnce you form this kit, however, you cannot form the remaining packages into a kit. $449$ g of the first ingredient and $1101$ g of the second ingredient would not be able to form $10$ (or any other number of) servings. In fact, the ($450$ g, $1100$ g) kit is the only kit that can be formed from these packages.\n\nIn sample case #4, no kits can be formed. Note that the recipe requires particular amounts of particular ingredients in the given order, the ingredients are not interchangeable. This is fine French cuisine, after all!\n\nIn sample case #5, the recipe has only one ingredient — how elegantly simple! A single serving cannot use more than $11$ g, and two servings cannot use fewer than $18$ g. It is possible to form three kits: two with an $11$ g package, and one with an $18$ g package.\n\nIn sample case #6, you can form three valid kits: ($700$ g, $800$ g, $900$ g), which makes $10$ servings, and ($1500$ g, $1600$ g, $1700$ g) and ($1260$ g, $1440$ g, $1620$ g), each of which makes $20$ servings. Note that you could also say that the ($1260$ g, $1440$ g, $1620$ g) kit makes $17$, $18$, or $19$ servings, but it does not matter how many servings a kit makes as long as the kit is valid.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq R_i \\leq 10^6$, for all $i$.\n- $1 \\leq Q_{ij} \\leq 10^6$, for all $i$ and $j$.\n\n**Small dataset (12 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $1 \\leq N \\leq 2$.\n- $1 \\leq P \\leq 8$.\n\n**Large dataset (23 Pts, Test Set 2 - Hidden)**\n\n- Time limit: ~~120~~ 30 seconds.\n- $1 \\leq N \\leq 50$.\n- $1 \\leq P \\leq 50$.\n- $N \\times P \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #1A] Ratatouille", "background": null, "description": "你发现了终极的“ratatouille”（法国蔬菜杂烩）配方！你已经知道制作一份 ratatouille 需要哪些原料，以及每种原料需要多少克。你相信“人人都能做菜”，所以你想把这个配方分享给全世界……顺便赚点钱！\n\n你订购了一些便于运输的原料包装。每个包装只包含一种原料；即使是同一种原料，不同包装中的数量也可能不同。为了方便，你为每种原料都订购了相同数量的包装。\n\n你希望用这些包装尽可能多地组装出 ratatouille 套装，发给顾客。每个套装由每种原料各一个包装组成，并贴有一个标签，标明该套装可以制作多少份 ratatouille（份数为整数）。为了保证不亏待顾客且不浪费食材，每个包装中的原料含量必须在制作标签上标明的份数所需原料的 $90\\%$ 到 $110\\%$（含端点）之间。\n\n例如，假设制作一份 ratatouille 需要 $500$ 克番茄和 $300$ 克洋葱。假如你有一个 $900$ 克的番茄包装和一个 $660$ 克的洋葱包装。你可以将它们组合成一个可以制作两份 ratatouille 的套装。制作两份需要 $1000$ 克番茄和 $600$ 克洋葱。你拥有的 $900$ 克番茄在 $1000$ 克的 $[90\\%, 110\\%]$ 区间内，$660$ 克洋葱也在 $600$ 克的 $[90\\%, 110\\%]$ 区间内，因此这是可行的。然而，你不能说这个套装可以制作一份或三份 ratatouille，也不能说可以制作 $1.999$ 份（份数必须为整数）。\n\n注意，有些包装组合永远无法组成一个套装。继续上面的例子，如果你有一个 $1500$ 克的番茄包装和一个 $809$ 克的洋葱包装，无论制作多少份都不行。三份需要 $1500$ 克番茄和 $900$ 克洋葱，但 $809$ 克洋葱不在 $[90\\%, 110\\%]$ 区间内。没有其他整数份数可行。\n\n你希望让尽可能多的顾客享受到你的配方，所以你想制作最多数量的有效套装。（当然，每个包装最多只能用在一个套装中。）你最多能组装出多少个套装？注意，你不需要最大化 ratatouille 的总份数。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据包括：\n\n- 一行包含两个整数 $N$ 和 $P$，分别表示原料种类数和每种原料的包装数量。\n- 一行包含 $N$ 个整数 $R_i$，第 $i$ 个数表示制作一份 ratatouille 需要的第 $i$ 种原料的克数。\n- 接下来 $N$ 行，每行包含 $P$ 个整数。第 $i$ 行的第 $j$ 个数 $Q_{ij}$ 表示第 $i$ 种原料的第 $j$ 个包装的克数。", "outputFormat": "对于每组测试数据，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是你最多能组装出的套装数量。", "hint": "**样例解释**\n\n注意，最后一个样例不会出现在 Small 数据集中。\n\n样例 1 和 2 就是题目描述中的例子。\n\n在样例 3 中，你可以用第一种原料的 $450$ 克包装和第二种原料的 $1100$ 克包装，组装成一个制作 $10$ 份 ratatouille 的套装。制作 $10$ 份需要第一种原料 $500$ 克，你有 $450$ 克，正好是 $500$ 克的 $90\\%$，在允许范围内。第二种原料需要 $1000$ 克，你有 $1100$ 克，正好是 $110\\%$，也在允许范围内。\n\n但组装完这个套装后，剩下的包装无法再组成套装。$449$ 克的第一种原料和 $1101$ 克的第二种原料无法组成 $10$ 份（或其他份数）的套装。实际上，($450$ 克, $1100$ 克) 是唯一能组成的套装。\n\n在样例 4 中，无法组成任何套装。注意，配方要求每种原料的顺序和用量都不能变，原料不可互换。这可是正宗法式料理！\n\n在样例 5 中，配方只有一种原料——多么优雅！一份不能超过 $11$ 克，两份不能少于 $18$ 克。可以组装出三个套装：两个 $11$ 克包装，一个 $18$ 克包装。\n\n在样例 6 中，可以组装出三个有效套装：($700$ 克, $800$ 克, $900$ 克)，可制作 $10$ 份；($1500$ 克, $1600$ 克, $1700$ 克) 和 ($1260$ 克, $1440$ 克, $1620$ 克)，每个都可制作 $20$ 份。注意，($1260$ 克, $1440$ 克, $1620$ 克) 也可以标为 $17$、$18$ 或 $19$ 份，但只要套装有效，份数具体是多少并不重要。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq R_i \\leq 10^6$，对所有 $i$。\n- $1 \\leq Q_{ij} \\leq 10^6$，对所有 $i, j$。\n\n**小数据集（12 分，测试点 1 - 可见）**\n\n- 时间限制：15 秒。\n- $1 \\leq N \\leq 2$。\n- $1 \\leq P \\leq 8$。\n\n**大数据集（23 分，测试点 2 - 隐藏）**\n\n- 时间限制：30 秒。\n- $1 \\leq N \\leq 50$。\n- $1 \\leq P \\leq 50$。\n- $N \\times P \\leq 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13164", "type": "P", "difficulty": 7, "samples": [["4\n11 5 16 5 0 0\n3 1 3 2 2 0\n3 1 3 2 1 0\n2 1 5 1 1 1", "Case #1: 5\nCase #2: 2\nCase #3: IMPOSSIBLE\nCase #4: 5"]], "limits": {"time": [15000, 60000], "memory": [1048576, 1048576]}, "tags": ["数学", "2017", "Google Code Jam"], "title": "[GCJ 2017 #1A] Play the Dragon", "background": "", "description": "You are a friendly dragon fighting to protect your lair from a greedy knight! You have $H_d$ health points and an attack power of $A_d$, and the knight has $H_k$ health points and an attack power of $A_k$. If your health drops to 0 or below at any point; you are knocked out and you instantly lose; if the knight's health drops to 0 or below at any point, the knight is knocked out and you win!\n\nYou will battle the knight in a series of turns. On each turn, you go first, and you can choose and execute any one of the following actions.\n\n* Attack: Reduce the opponent's health by your own attack power.\n* Buff: Increase your attack power by $B$ for the rest of the battle.\n* Cure: Your health becomes $H_d$.\n* Debuff: Decrease the opponent's attack power by $D$ for the rest of the battle. If a Debuff would cause the opponent's attack power to become less than 0, it instead sets it to 0.\n\nThen, if the knight's health is greater than 0 following your action, the knight will execute an Attack action. After that, the turn ends. (Note that a turn in which you defeat the knight still counts as a turn even though the knight does not get to act.)\n\nNote that buffs stack with each other; every buff adds an additional $B$ to your attack power. Similarly, debuffs stack with each other.\n\nYou would like to defeat the knight as fast as possible (if it is possible) so that you will not be late to help the villagers roast marshmallows at tonight's festival. Can you determine the minimum number of turns in which you can defeat the knight, or that it is IMPOSSIBLE to do so?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of one line with six integers $H_d$, $A_d$, $H_k$, $A_k$, $B$, and $D$, as described above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either IMPOSSIBLE if it is not possible to defeat the knight, or the minimum number of turns needed to defeat the knight.", "hint": "**Sample Explanation**\n\nIn Case #1, you have 11 health and 5 attack, and the knight has 16 health and 5 attack. One possible optimal sequence of actions is:\n\n* Turn 1: Attack, reducing the knight's health to 11. Then the knight attacks and reduces your health to 6.\n* Turn 2: Attack, reducing the knight's health to 6. Then the knight attacks and reduces your health to 1.\n* Turn 3: Cure, restoring your health to 11. Then the knight attacks and reduces your health to 6. (If you had attacked instead this turn, the knight's next attack would have caused you to lose.)\n* Turn 4: Attack, reducing the knight's health to 1. Then the knight attacks and reduces your health to 1.\n* Turn 5: Attack, reducing the knight's health to -4. You instantly win and the knight does not get another attack.\n\nIn Case #2, one possible optimal sequence of actions is:\n\n* Turn 1: Buff, increasing your attack power to 3. Then the knight attacks and reduces your health to 1.\n* Turn 2: Attack, reducing the knight's health to 0. You instantly win and the knight does not get another attack.\n\nIn Case #3, the knight only needs two attacks to defeat you, and you cannot do enough damage fast enough to defeat the knight. You can indefinitely extend the combat by executing the Cure action after every attack, but it is impossible to actually defeat the knight.\n\nIn Case #4, one possible optimal sequence of actions is: Attack, Debuff, Buff, Attack, Attack.\n\n**Limits**\n\n$1 \\leq T \\leq 100$.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $1 \\leq H_d \\leq 100$.\n- $1 \\leq A_d \\leq 100$.\n- $1 \\leq H_k \\leq 100$.\n- $1 \\leq A_k \\leq 100$.\n- $0 \\leq B \\leq 100$.\n- $0 \\leq D \\leq 100$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- Time limit: ~~240~~ 60 seconds.\n- $1 \\leq H_d \\leq 10^9$.\n- $1 \\leq A_d \\leq 10^9$.\n- $1 \\leq H_k \\leq 10^9$.\n- $1 \\leq A_k \\leq 10^9$.\n- $0 \\leq B \\leq 10^9$.\n- $0 \\leq D \\leq 10^9$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #1A] Play the Dragon", "background": "", "description": "You are a friendly dragon fighting to protect your lair from a greedy knight! You have $H_d$ health points and an attack power of $A_d$, and the knight has $H_k$ health points and an attack power of $A_k$. If your health drops to 0 or below at any point; you are knocked out and you instantly lose; if the knight's health drops to 0 or below at any point, the knight is knocked out and you win!\n\nYou will battle the knight in a series of turns. On each turn, you go first, and you can choose and execute any one of the following actions.\n\n* Attack: Reduce the opponent's health by your own attack power.\n* Buff: Increase your attack power by $B$ for the rest of the battle.\n* Cure: Your health becomes $H_d$.\n* Debuff: Decrease the opponent's attack power by $D$ for the rest of the battle. If a Debuff would cause the opponent's attack power to become less than 0, it instead sets it to 0.\n\nThen, if the knight's health is greater than 0 following your action, the knight will execute an Attack action. After that, the turn ends. (Note that a turn in which you defeat the knight still counts as a turn even though the knight does not get to act.)\n\nNote that buffs stack with each other; every buff adds an additional $B$ to your attack power. Similarly, debuffs stack with each other.\n\nYou would like to defeat the knight as fast as possible (if it is possible) so that you will not be late to help the villagers roast marshmallows at tonight's festival. Can you determine the minimum number of turns in which you can defeat the knight, or that it is IMPOSSIBLE to do so?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of one line with six integers $H_d$, $A_d$, $H_k$, $A_k$, $B$, and $D$, as described above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either IMPOSSIBLE if it is not possible to defeat the knight, or the minimum number of turns needed to defeat the knight.", "hint": "**Sample Explanation**\n\nIn Case #1, you have 11 health and 5 attack, and the knight has 16 health and 5 attack. One possible optimal sequence of actions is:\n\n* Turn 1: Attack, reducing the knight's health to 11. Then the knight attacks and reduces your health to 6.\n* Turn 2: Attack, reducing the knight's health to 6. Then the knight attacks and reduces your health to 1.\n* Turn 3: Cure, restoring your health to 11. Then the knight attacks and reduces your health to 6. (If you had attacked instead this turn, the knight's next attack would have caused you to lose.)\n* Turn 4: Attack, reducing the knight's health to 1. Then the knight attacks and reduces your health to 1.\n* Turn 5: Attack, reducing the knight's health to -4. You instantly win and the knight does not get another attack.\n\nIn Case #2, one possible optimal sequence of actions is:\n\n* Turn 1: Buff, increasing your attack power to 3. Then the knight attacks and reduces your health to 1.\n* Turn 2: Attack, reducing the knight's health to 0. You instantly win and the knight does not get another attack.\n\nIn Case #3, the knight only needs two attacks to defeat you, and you cannot do enough damage fast enough to defeat the knight. You can indefinitely extend the combat by executing the Cure action after every attack, but it is impossible to actually defeat the knight.\n\nIn Case #4, one possible optimal sequence of actions is: Attack, Debuff, Buff, Attack, Attack.\n\n**Limits**\n\n$1 \\leq T \\leq 100$.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $1 \\leq H_d \\leq 100$.\n- $1 \\leq A_d \\leq 100$.\n- $1 \\leq H_k \\leq 100$.\n- $1 \\leq A_k \\leq 100$.\n- $0 \\leq B \\leq 100$.\n- $0 \\leq D \\leq 100$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- Time limit: ~~240~~ 60 seconds.\n- $1 \\leq H_d \\leq 10^9$.\n- $1 \\leq A_d \\leq 10^9$.\n- $1 \\leq H_k \\leq 10^9$.\n- $1 \\leq A_k \\leq 10^9$.\n- $0 \\leq B \\leq 10^9$.\n- $0 \\leq D \\leq 10^9$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #1A] Play the Dragon", "background": null, "description": "你是一条友善的龙，正在与一名贪婪的骑士战斗，以保护你的巢穴！你拥有 $H_d$ 点生命值和 $A_d$ 点攻击力，骑士拥有 $H_k$ 点生命值和 $A_k$ 点攻击力。如果你的生命值在任何时刻降至 $0$ 或以下，你会被击倒并立即失败；如果骑士的生命值在任何时刻降至 $0$ 或以下，骑士会被击倒，你获得胜利！\n\n你将与骑士进行一系列回合的战斗。在每个回合中，你先行动，可以选择并执行以下任意一个动作：\n\n- 攻击（Attack）：使对方的生命值减少你当前的攻击力。\n- 增益（Buff）：你的攻击力永久增加 $B$。\n- 治疗（Cure）：你的生命值恢复为 $H_d$。\n- 减益（Debuff）：对方的攻击力永久减少 $D$。如果减益会使对方攻击力降至 $0$ 以下，则将其设为 $0$。\n\n然后，如果你的动作后骑士的生命值仍大于 $0$，骑士会执行一次攻击动作。之后本回合结束。（注意，如果你在本回合击败了骑士，虽然骑士不会再行动，但该回合仍然计入总回合数。）\n\n注意，增益和减益效果可以叠加；每次增益会额外增加 $B$ 攻击力，每次减益会额外减少 $D$ 攻击力。\n\n你希望尽快击败骑士（如果可能的话），这样你就不会错过今晚村民们烤棉花糖的节日了。你能否判断出击败骑士所需的最少回合数，或者判断是否不可能击败骑士？", "inputFormat": "输入的第一行包含一个整数 $T$，表示测试用例的数量。接下来有 $T$ 组测试用例。每组测试用例占一行，包含六个整数 $H_d$、$A_d$、$H_k$、$A_k$、$B$ 和 $D$，含义如上所述。", "outputFormat": "对于每组测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是击败骑士所需的最少回合数，或者如果无法击败骑士则输出 `IMPOSSIBLE`。", "hint": "**样例解释**\n\n在第 1 组样例中，你有 11 点生命值和 5 点攻击力，骑士有 16 点生命值和 5 点攻击力。一种可能的最优行动顺序如下：\n\n- 第 1 回合：攻击，将骑士生命值降至 11。骑士攻击你，你的生命值降至 6。\n- 第 2 回合：攻击，将骑士生命值降至 6。骑士攻击你，你的生命值降至 1。\n- 第 3 回合：治疗，生命值恢复到 11。骑士攻击你，你的生命值降至 6。（如果你本回合选择攻击，下回合骑士的攻击会让你失败。）\n- 第 4 回合：攻击，将骑士生命值降至 1。骑士攻击你，你的生命值降至 1。\n- 第 5 回合：攻击，将骑士生命值降至 -4。你立即获胜，骑士不会再攻击。\n\n在第 2 组样例中，一种可能的最优行动顺序如下：\n\n- 第 1 回合：增益，攻击力提升至 3。骑士攻击你，你的生命值降至 1。\n- 第 2 回合：攻击，将骑士生命值降至 0。你立即获胜，骑士不会再攻击。\n\n在第 3 组样例中，骑士只需两次攻击就能击败你，而你无法在足够快的时间内击败骑士。你可以通过每次攻击后都治疗来无限延长战斗，但实际上无法击败骑士。\n\n在第 4 组样例中，一种可能的最优行动顺序为：攻击、减益、增益、攻击、攻击。\n\n**数据范围**\n\n$1 \\leq T \\leq 100$。\n\n**小数据集（测试集 1 - 可见）**\n\n- 时间限制：~~60~~ 15 秒。\n- $1 \\leq H_d \\leq 100$。\n- $1 \\leq A_d \\leq 100$。\n- $1 \\leq H_k \\leq 100$。\n- $1 \\leq A_k \\leq 100$。\n- $0 \\leq B \\leq 100$。\n- $0 \\leq D \\leq 100$。\n\n**大数据集（测试集 2 - 隐藏）**\n\n- 时间限制：~~240~~ 60 秒。\n- $1 \\leq H_d \\leq 10^9$。\n- $1 \\leq A_d \\leq 10^9$。\n- $1 \\leq H_k \\leq 10^9$。\n- $1 \\leq A_k \\leq 10^9$。\n- $0 \\leq B \\leq 10^9$。\n- $0 \\leq D \\leq 10^9$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13165", "type": "P", "difficulty": 2, "samples": [["3\n2525 1\n2400 5\n300 2\n120 60\n60 90\n100 2\n80 100\n70 10", "Case #1: 101.000000\nCase #2: 100.000000\nCase #3: 33.333333"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["数学", "2017", "Special Judge", "Google Code Jam"], "title": "[GCJ 2017 #1B] Steed 2: Cruise Control", "background": "", "description": "Annie is a bus driver with a high-stress job. She tried to unwind by going on a Caribbean cruise, but that also turned out to be stressful, so she has recently taken up horseback riding.\n\nToday, Annie is riding her horse to the east along a long and narrow one-way road that runs west to east. She is currently at kilometer 0 of the road, and her destination is at kilometer $D$; kilometers along the road are numbered from west to east.\n\nThere are $N$ other horses traveling east on the same road; all of them will go on traveling forever, and all of them are currently between Annie's horse and her destination. The $i$-th of these horses is initially at kilometer $K_i$ and is traveling at its maximum speed of $S_i$ kilometers per hour.\n\nHorses are very polite, and a horse $H_1$ will not pass (move ahead of) another horse $H_2$ that started off ahead of $H_1$. (Two or more horses can share the same position for any amount of time; you may consider the horses to be single points.) Horses (other than Annie's) travel at their maximum speeds, except that whenever a horse $H_1$ catches up to another slower horse $H_2$, $H_1$ reduces its speed to match the speed of $H_2$.\n\nAnnie's horse, on the other hand, does not have a maximum speed and can travel at any speed that Annie chooses, as long as it does not pass another horse. To ensure a smooth ride for her and her horse, Annie wants to choose a single constant \"cruise control\" speed for her horse for the entire trip, from her current position to the destination, such that her horse will not pass any other horses. What is the maximum such speed that she can choose?", "inputFormat": "The first line of the input gives the number of test cases, $T$; $T$ test cases follow. Each test case begins with two integers $D$ and $N$: the destination position of all of the horses (in kilometers) and the number of other horses on the road. Then, $N$ lines follow. The $i$-th of those lines has two integers $K_i$ and $S_i$: the initial position (in kilometers) and maximum speed (in kilometers per hour) of the $i$-th of the other horses on the road.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum constant speed (in kilometers per hour) that Annie can use without colliding with other horses. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is one other (very slow!) horse on the road; it will reach Annie's destination after $25$ hours. Anything faster than $101$ kilometers per hour would cause Annie to pass the horse before reaching the destination.\n\nIn Sample Case #2, there are two other horses on the road. The faster horse will catch up to the slower horse at kilometer $240$ after $2$ hours. Both horses will then go at the slower horse's speed for $1$ more hour, until the horses reach Annie's destination at kilometer 300. The maximum speed that Annie can choose without passing another horse is $100$ kilometers per hour.\n\n**Sample Explanation**\n\n- $1 \\leq T \\leq 100$.\n- $0 < K_i < D \\leq 10^9$, for all $i$.\n- $K_i \\neq K_j$, for all $i \\neq j$. (No two horses start in the same position.)\n- $1 \\leq S_i \\leq 10000$.\n\n**Small Dataset (11 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 2$.\n\n**Large Dataset (14 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #1B] Steed 2: Cruise Control", "background": "", "description": "Annie is a bus driver with a high-stress job. She tried to unwind by going on a Caribbean cruise, but that also turned out to be stressful, so she has recently taken up horseback riding.\n\nToday, Annie is riding her horse to the east along a long and narrow one-way road that runs west to east. She is currently at kilometer 0 of the road, and her destination is at kilometer $D$; kilometers along the road are numbered from west to east.\n\nThere are $N$ other horses traveling east on the same road; all of them will go on traveling forever, and all of them are currently between Annie's horse and her destination. The $i$-th of these horses is initially at kilometer $K_i$ and is traveling at its maximum speed of $S_i$ kilometers per hour.\n\nHorses are very polite, and a horse $H_1$ will not pass (move ahead of) another horse $H_2$ that started off ahead of $H_1$. (Two or more horses can share the same position for any amount of time; you may consider the horses to be single points.) Horses (other than Annie's) travel at their maximum speeds, except that whenever a horse $H_1$ catches up to another slower horse $H_2$, $H_1$ reduces its speed to match the speed of $H_2$.\n\nAnnie's horse, on the other hand, does not have a maximum speed and can travel at any speed that Annie chooses, as long as it does not pass another horse. To ensure a smooth ride for her and her horse, Annie wants to choose a single constant \"cruise control\" speed for her horse for the entire trip, from her current position to the destination, such that her horse will not pass any other horses. What is the maximum such speed that she can choose?", "inputFormat": "The first line of the input gives the number of test cases, $T$; $T$ test cases follow. Each test case begins with two integers $D$ and $N$: the destination position of all of the horses (in kilometers) and the number of other horses on the road. Then, $N$ lines follow. The $i$-th of those lines has two integers $K_i$ and $S_i$: the initial position (in kilometers) and maximum speed (in kilometers per hour) of the $i$-th of the other horses on the road.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum constant speed (in kilometers per hour) that Annie can use without colliding with other horses. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is one other (very slow!) horse on the road; it will reach Annie's destination after $25$ hours. Anything faster than $101$ kilometers per hour would cause Annie to pass the horse before reaching the destination.\n\nIn Sample Case #2, there are two other horses on the road. The faster horse will catch up to the slower horse at kilometer $240$ after $2$ hours. Both horses will then go at the slower horse's speed for $1$ more hour, until the horses reach Annie's destination at kilometer 300. The maximum speed that Annie can choose without passing another horse is $100$ kilometers per hour.\n\n**Sample Explanation**\n\n- $1 \\leq T \\leq 100$.\n- $0 < K_i < D \\leq 10^9$, for all $i$.\n- $K_i \\neq K_j$, for all $i \\neq j$. (No two horses start in the same position.)\n- $1 \\leq S_i \\leq 10000$.\n\n**Small Dataset (11 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 2$.\n\n**Large Dataset (14 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #1B] Steed 2: Cruise Control", "background": null, "description": "Annie 是一名公交车司机，工作压力很大。她曾尝试通过加勒比海邮轮来放松自己，但那次旅行同样让她感到压力重重，于是她最近开始学习骑马。\n\n今天，Annie 正骑着她的马沿着一条狭长的单向公路向东行进。她现在位于公路的 $0$ 公里处，目的地在 $D$ 公里处；公路上的公里数从西到东依次编号。\n\n在这条路上，还有 $N$ 匹其他马同样向东行进；它们都会一直前进下去，并且目前都位于 Annie 的马和她的目的地之间。第 $i$ 匹马当前位于 $K_i$ 公里处，并以其最大速度 $S_i$ 公里每小时行进。\n\n马非常有礼貌，一匹马 $H_1$ 不会超过（即不会跑到前面去）另一匹起始位置在 $H_1$ 前面的马 $H_2$。（多匹马可以在任意时刻处于同一位置；你可以将马视为一个点。）除 Annie 的马以外，其他马都以最大速度行进，除非某匹马 $H_1$ 追上了另一匹更慢的马 $H_2$，此时 $H_1$ 会减速至 $H_2$ 的速度。\n\n而 Annie 的马没有最大速度限制，她可以选择任意速度，只要不超过其他马。为了让自己和马都能顺利前行，Annie 想为她的马选择一个全程恒定的“巡航速度”，使得她的马在从当前位置到目的地的整个过程中都不会超过其他马。请问她能选择的最大速度是多少？", "inputFormat": "输入的第一行为测试用例数 $T$；接下来有 $T$ 组测试数据。每组测试数据的第一行为两个整数 $D$ 和 $N$，分别表示所有马的目的地位置（单位：公里）和道路上的其他马的数量。接下来的 $N$ 行，每行包含两个整数 $K_i$ 和 $S_i$，分别表示第 $i$ 匹其他马的初始位置（单位：公里）和最大速度（单位：公里每小时）。", "outputFormat": "对于每组测试数据，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 Annie 能选择的不超过其他马的最大恒定速度（单位：公里每小时）。如果 $y$ 的绝对误差或相对误差在 $10^{-6}$ 以内，则视为正确。", "hint": "**样例解释**\n\n在样例 1 中，只有一匹（非常慢的）马在路上；它到达 Annie 目的地需要 $25$ 小时。Annie 选择的速度只要不超过 $101$ 公里每小时，就不会在到达目的地前超过这匹马。\n\n在样例 2 中，有两匹马在路上。较快的马会在 $2$ 小时后于 $240$ 公里处追上较慢的马。此后，两匹马会以较慢马的速度再行进 $1$ 小时，直到到达 $300$ 公里处的目的地。Annie 能选择的最大速度是 $100$ 公里每小时。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $0 < K_i < D \\leq 10^9$，对所有 $i$。\n- $K_i \\neq K_j$，对所有 $i \\neq j$。（没有两匹马起始位置相同。）\n- $1 \\leq S_i \\leq 10000$。\n\n**小数据范围（11 分，测试点 1 - 可见）**\n\n- $1 \\leq N \\leq 2$。\n\n**大数据范围（14 分，测试点 2 - 隐藏）**\n\n- $1 \\leq N \\leq 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13166", "type": "P", "difficulty": 5, "samples": [["4\n6 2 0 2 0 2 0\n3 1 0 2 0 0 0\n6 2 0 1 1 2 0\n4 0 0 2 0 0 2", "Case #1: RYBRBY\nCase #2: IMPOSSIBLE\nCase #3: YBRGRB\nCase #4: YVYV"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["数学", "2017", "Special Judge", "Google Code Jam"], "title": "[GCJ 2017 #1B] Stable Neigh-bors", "background": "", "description": "You are lucky enough to own $N$ pet unicorns. Each of your unicorns has either one or two of the following kinds of hairs in its mane: red hairs, yellow hairs, and blue hairs. The color of a mane depends on exactly which sorts of colored hairs it contains:\n\n- A mane with only one color of hair appears to be that color. For example, a mane with only blue hairs is blue.\n- A mane with red and yellow hairs appears orange.\n- A mane with yellow and blue hairs appears green.\n- A mane with red and blue hairs appears violet.\n\nYou have $R$, $O$, $Y$, $G$, $B$, and $V$ unicorns with red, orange, yellow, green, blue, and violet manes, respectively.\n\nYou have just built a circular stable with $N$ stalls, arranged in a ring such that each stall borders two other stalls. You would like to put exactly one of your unicorns in each of these stalls. However, unicorns need to feel rare and special, so no unicorn can be next to another unicorn that shares at least one of the hair colors in its mane. For example, a unicorn with an orange mane cannot be next to a unicorn with a violet mane, since both of those manes have red hairs. Similarly, a unicorn with a green mane cannot be next to a unicorn with a yellow mane, since both of those have yellow hairs.\n\nIs it possible to place all of your unicorns? If so, provide any one arrangement.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of one line with seven integers: $N$, $R$, $O$, $Y$, $G$, $B$, and $V$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is `IMPOSSIBLE` if it is not possible to place all the unicorns, or a string of $N$ characters representing the placements of unicorns in stalls, starting at a point of your choice and reading clockwise around the circle. Use `R` to represent each unicorn with a red mane, `O` to represent each unicorn with an orange mane, and so on with `Y`, `G`, `B`, and `V`. This arrangement must obey the rules described in the statement above.\n\nIf multiple arrangements are possible, you may print any of them.", "hint": "**Sample Explanation**\n\nNote that the last two sample cases would not appear in the Small dataset.\n\nFor sample case #1, there are many possible answers; for example, another is BYBRYR. Note that BYRYRB would not be a valid answer; remember that the stalls form a ring, and the first touches the last!\n\nIn sample case #2, there are only three stalls, and each stall is a neighbor of the other two, so the two unicorns with yellow manes would have to be neighbors, which is not allowed.\n\nFor sample case #3, note that arranging the unicorns in the same color pattern as the Google logo (BRYBGR) would not be valid, since a unicorn with a blue mane would be a neighbor of a unicorn with a green mane, and both of those manes share blue hairs.\n\nIn sample case #4, no two unicorns with yellow manes can be neighbors, and no two unicorns with violet manes can be neighbors.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $3 \\leq N \\leq 1000$.\n- $R + O + Y + G + B + V = N$.\n- $0 \\leq Z$ for each $Z$ in $\\{R, O, Y, G, B, V\\}$.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- $O = G = V = 0$. (Each unicorn has only one hair color in its mane.)\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- No restrictions beyond the general limits. (Each unicorn may have either one or two hair colors in its mane.)", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #1B] Stable Neigh-bors", "background": "", "description": "You are lucky enough to own $N$ pet unicorns. Each of your unicorns has either one or two of the following kinds of hairs in its mane: red hairs, yellow hairs, and blue hairs. The color of a mane depends on exactly which sorts of colored hairs it contains:\n\n- A mane with only one color of hair appears to be that color. For example, a mane with only blue hairs is blue.\n- A mane with red and yellow hairs appears orange.\n- A mane with yellow and blue hairs appears green.\n- A mane with red and blue hairs appears violet.\n\nYou have $R$, $O$, $Y$, $G$, $B$, and $V$ unicorns with red, orange, yellow, green, blue, and violet manes, respectively.\n\nYou have just built a circular stable with $N$ stalls, arranged in a ring such that each stall borders two other stalls. You would like to put exactly one of your unicorns in each of these stalls. However, unicorns need to feel rare and special, so no unicorn can be next to another unicorn that shares at least one of the hair colors in its mane. For example, a unicorn with an orange mane cannot be next to a unicorn with a violet mane, since both of those manes have red hairs. Similarly, a unicorn with a green mane cannot be next to a unicorn with a yellow mane, since both of those have yellow hairs.\n\nIs it possible to place all of your unicorns? If so, provide any one arrangement.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of one line with seven integers: $N$, $R$, $O$, $Y$, $G$, $B$, and $V$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is `IMPOSSIBLE` if it is not possible to place all the unicorns, or a string of $N$ characters representing the placements of unicorns in stalls, starting at a point of your choice and reading clockwise around the circle. Use `R` to represent each unicorn with a red mane, `O` to represent each unicorn with an orange mane, and so on with `Y`, `G`, `B`, and `V`. This arrangement must obey the rules described in the statement above.\n\nIf multiple arrangements are possible, you may print any of them.", "hint": "**Sample Explanation**\n\nNote that the last two sample cases would not appear in the Small dataset.\n\nFor sample case #1, there are many possible answers; for example, another is BYBRYR. Note that BYRYRB would not be a valid answer; remember that the stalls form a ring, and the first touches the last!\n\nIn sample case #2, there are only three stalls, and each stall is a neighbor of the other two, so the two unicorns with yellow manes would have to be neighbors, which is not allowed.\n\nFor sample case #3, note that arranging the unicorns in the same color pattern as the Google logo (BRYBGR) would not be valid, since a unicorn with a blue mane would be a neighbor of a unicorn with a green mane, and both of those manes share blue hairs.\n\nIn sample case #4, no two unicorns with yellow manes can be neighbors, and no two unicorns with violet manes can be neighbors.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $3 \\leq N \\leq 1000$.\n- $R + O + Y + G + B + V = N$.\n- $0 \\leq Z$ for each $Z$ in $\\{R, O, Y, G, B, V\\}$.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- $O = G = V = 0$. (Each unicorn has only one hair color in its mane.)\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- No restrictions beyond the general limits. (Each unicorn may have either one or two hair colors in its mane.)", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #1B] Stable Neigh-bors", "background": null, "description": "你非常幸运地拥有 $N$ 只独角兽。每只独角兽的鬃毛中只包含以下三种颜色中的一种或两种：红色、黄色和蓝色。鬃毛的颜色取决于它包含的具体颜色种类：\n\n- 只有一种颜色的鬃毛，看起来就是那种颜色。例如，只有蓝色鬃毛的鬃毛就是蓝色。\n- 同时有红色和黄色鬃毛的鬃毛看起来是橙色。\n- 同时有黄色和蓝色鬃毛的鬃毛看起来是绿色。\n- 同时有红色和蓝色鬃毛的鬃毛看起来是紫色。\n\n你拥有 $R$、$O$、$Y$、$G$、$B$ 和 $V$ 只鬃毛分别为红色、橙色、黄色、绿色、蓝色和紫色的独角兽。\n\n你刚刚建造了一个有 $N$ 个马厩的圆形马圈，这些马厩首尾相连，每个马厩都与两个其他马厩相邻。你希望将每只独角兽恰好放入一个马厩中。然而，独角兽需要感到稀有和特别，因此，任何两只鬃毛中包含至少一种相同颜色的独角兽都不能相邻。例如，鬃毛为橙色的独角兽不能与鬃毛为紫色的独角兽相邻，因为它们的鬃毛都含有红色。同理，鬃毛为绿色的独角兽不能与鬃毛为黄色的独角兽相邻，因为它们的鬃毛都含有黄色。\n\n你能否将所有独角兽都安置好？如果可以，请给出任意一种可行的安排。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据，每组数据为一行，包含七个整数：$N$、$R$、$O$、$Y$、$G$、$B$ 和 $V$。", "outputFormat": "对于每组测试数据，输出一行，格式为 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为 `IMPOSSIBLE`（如果无法安排所有独角兽），或者为一个长度为 $N$ 的字符串，表示独角兽在马厩中的排列顺序，从任意一个马厩开始，顺时针排列。用 `R` 表示红色鬃毛的独角兽，`O` 表示橙色，`Y` 表示黄色，`G` 表示绿色，`B` 表示蓝色，`V` 表示紫色。该排列必须满足题目描述中的所有规则。\n\n如果存在多种可行的排列方式，你可以输出任意一种。", "hint": "**样例解释**\n\n注意，最后两个样例不会出现在 Small 数据集中。\n\n对于样例 1，有多种可行答案；例如，BYBRYR 也是一种可行解。注意，BYRYRB 并不是有效答案，因为马厩是环形的，第一个和最后一个马厩也是相邻的！\n\n对于样例 2，只有三个马厩，每个马厩都与其他两个相邻，因此两只黄色鬃毛的独角兽必须相邻，这是不允许的。\n\n对于样例 3，注意如果按照 Google logo 的颜色顺序（BRYBGR）排列独角兽，并不是有效答案，因为蓝色鬃毛的独角兽会与绿色鬃毛的独角兽相邻，而它们的鬃毛都含有蓝色。\n\n对于样例 4，不能有两只黄色鬃毛的独角兽相邻，也不能有两只紫色鬃毛的独角兽相邻。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $3 \\leq N \\leq 1000$。\n- $R + O + Y + G + B + V = N$。\n- 对于每个 $Z \\in \\{R, O, Y, G, B, V\\}$，$0 \\leq Z$。\n\n**Small 数据集（测试集 1 - 可见）**\n\n- $O = G = V = 0$。（每只独角兽的鬃毛只包含一种颜色。）\n\n**Large 数据集（测试集 2 - 隐藏）**\n\n- 除一般限制外无其他限制。（每只独角兽的鬃毛可能包含一种或两种颜色。）\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13167", "type": "P", "difficulty": 4, "samples": [["3\n3 1\n2 3\n2 4\n4 4\n-1 1 -1\n-1 -1 1\n-1 -1 -1\n1 3\n4 1\n13 10\n1 1000\n10 8\n5 5\n-1 1 -1 -1\n-1 -1 1 -1\n-1 -1 -1 10\n-1 -1 -1 -1\n1 4\n4 3\n30 60\n10 1000\n12 5\n20 1\n-1 10 -1 31\n10 -1 10 -1\n-1 -1 -1 10\n15 6 -1 -1\n2 4\n3 1\n3 2", "Case #1: 0.583333333\nCase #2: 1.2\nCase #3: 0.51 8.01 8.0"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["2017", "Special Judge", "最短路", "Google Code Jam"], "title": "[GCJ 2017 #1B] Pony Express", "background": "", "description": "It's the year 1860, and the Pony Express is the fastest mail delivery system joining the East and West coasts of the United States. This system serves $N$ different cities. In each city, there is one horse (as in the expression \"one-horse town\"); each horse travels at a certain constant speed and has a maximum total distance it can travel before it becomes too tired to continue.\n\nThe Pony Express rider starts off on the starting city's horse. Every time the rider reaches a city, they may continue to use their current horse or switch to that city's horse; switching is instantaneous. Horses never get a chance to rest, so whenever part of a horse's maximum total distance is \"used up\", it is used up forever! When the rider reaches the destination city, the mail is delivered.\n\nThe routes between cities were established via complicated negotiations between company owners, lawmakers, union delegates, and cousin Pete. That means that the distances between cities do not necessarily follow common sense: for instance, they do not necessarily comply with the triangle inequality, and the distance from city A to city B might be different from the distance from city B to city A!\n\nYou are a time traveling entrepreneur, and you have brought a fast computer from the future. A single computer is not enough for you to set up an e-mail service and make the Pony Express obsolete, but you can use it to make optimal routing plans for the Pony Express. Given all data about routes between cities and the horses in each city, and a list of pairs of starting and ending cities, can you quickly calculate the minimum time necessary for each delivery? (You should treat all of these deliveries as independent; using cities/horses on one route does not make them unavailable on other routes.)\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case is described as follows:\n\n- One line with two integers: $N$, the number of cities with horses, and $Q$, the number of pairs of stops we are interested in. Cities are numbered from 1 to $N$.\n- $N$ lines, each containing two integers $E_i$, the maximum total distance, in kilometers, the horse in the i-th city can go and $S_i$, the constant speed, in kilometers per hour, at which the horse travels.\n- $N$ lines, each containing $N$ integers. The j-th integer on the i-th of these lines, $D_{ij}$, is -1 if there is no direct route from the i-th to the j-th city, and the length of that route in kilometers otherwise.\n- $Q$ lines containing two integers $U_k$ and $V_k$, the starting and destination point, respectively, of the k-th pair of cities we want to investigate.", "outputFormat": "For each test case, output one line containing `Case #x: y_1 y_2 ... y_Q`, where $x$ is the test case number (starting from 1) and $y_k$ is the minimum time, in hours, to deliver a letter from city $U_k$ to city $V_k$.\n\nEach $y_k$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nNote that the last sample case would not appear in the Small dataset.\n\nIn Case #1 there are two options: use the horse in city 1 for the entire trip, or change horses in city 2. Both horses have enough endurance, so both options are viable. Since the horse in city 2 is faster, it is better to change, for a total time of $1/3 + 1/4$.\n\nIn Case #2 there are two intermediate cities in which you can change horses. If you change horses in city 2, however, your new horse, while blazingly fast, will not have enough endurance, so you will be forced to change again in city 3. If you keep your horse, you will have the option to change horses (or not) in city 3. So, the three options, with their total times, are:\n\n1. Change horses in both city 2 and 3 ($1/10 + 1/1000 + 10/8 = 1.351$).\n2. Change horses just in city 3 ($2/10 + 10/8 = 1.45$).\n3. Never change horses ($12/10 = 1.2$).\n\nIn Case #3, there are lots of alternatives for each delivery. The optimal one for the first delivery (city 2 to city 4) is to go to city 1 in time $10/1000$, change horses, and then go to cities 2, 3 and 4, in that order, using the horse from city 1, which takes time $(10 + 10 + 10) / 60$.\n\nFor the second delivery (city 3 to city 2) you have no choice but to first go to city 4 which takes time $10/5$. Your relatively fast horse does not have enough endurance to get anywhere else, so you need to grab the horse in city 4. You could use it to get directly to city 1 in time 15, but that would be slower than riding it to city 2 in time 6 and then using the blazingly fast horse in city 2 to get to city 1 in just $10/1000$ extra time.\n\nIn the third delivery (city 3 to city 1) of Case #3 it is optimal to use the first two steps of the previous one, for a total time of $10/5 + 6 = 8$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq N \\leq 100$.\n- $1 \\leq E_i \\leq 10^9$, for all $i$.\n- $1 \\leq S_i \\leq 1000$, for all $i$.\n- $-1 \\leq D_{ij} \\leq 10^9$, for all $i, j$.\n- $D_{ii} = -1$, for all $i$. (There are no direct routes from a city to itself.)\n- $D_{ij} \\neq 0$, for all $i, j$.\n- $U_k \\neq V_k$, for all $k$.\n- It is guaranteed that the delivery from $U_k$ to $V_k$ can be accomplished with the given horses, for all $k$.\n- $U_l \\neq U_m$ and/or $V_l \\neq V_m$, for all different $l, m$. (No ordered pair of cities to investigate is repeated within a test case.)\n\n**Small dataset (16 Pts, Test Set 1 - Visible)**\n\n- $D_{ij} = -1$, for all $i, j$ where $i + 1 \\neq j$. (The cities are in a single line; each route goes from one city to the next city in line.)\n- $Q = 1$.\n- $U_1 = 1$.\n- $V_1 = N$. (The only delivery to calculate is between the first and last cities in the line).\n\n**Large dataset (24 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq Q \\leq 100$.\n- $1 \\leq U_k \\leq N$, for all $k$.\n- $1 \\leq V_k \\leq N$, for all $k$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #1B] Pony Express", "background": "", "description": "It's the year 1860, and the Pony Express is the fastest mail delivery system joining the East and West coasts of the United States. This system serves $N$ different cities. In each city, there is one horse (as in the expression \"one-horse town\"); each horse travels at a certain constant speed and has a maximum total distance it can travel before it becomes too tired to continue.\n\nThe Pony Express rider starts off on the starting city's horse. Every time the rider reaches a city, they may continue to use their current horse or switch to that city's horse; switching is instantaneous. Horses never get a chance to rest, so whenever part of a horse's maximum total distance is \"used up\", it is used up forever! When the rider reaches the destination city, the mail is delivered.\n\nThe routes between cities were established via complicated negotiations between company owners, lawmakers, union delegates, and cousin Pete. That means that the distances between cities do not necessarily follow common sense: for instance, they do not necessarily comply with the triangle inequality, and the distance from city A to city B might be different from the distance from city B to city A!\n\nYou are a time traveling entrepreneur, and you have brought a fast computer from the future. A single computer is not enough for you to set up an e-mail service and make the Pony Express obsolete, but you can use it to make optimal routing plans for the Pony Express. Given all data about routes between cities and the horses in each city, and a list of pairs of starting and ending cities, can you quickly calculate the minimum time necessary for each delivery? (You should treat all of these deliveries as independent; using cities/horses on one route does not make them unavailable on other routes.)\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case is described as follows:\n\n- One line with two integers: $N$, the number of cities with horses, and $Q$, the number of pairs of stops we are interested in. Cities are numbered from 1 to $N$.\n- $N$ lines, each containing two integers $E_i$, the maximum total distance, in kilometers, the horse in the i-th city can go and $S_i$, the constant speed, in kilometers per hour, at which the horse travels.\n- $N$ lines, each containing $N$ integers. The j-th integer on the i-th of these lines, $D_{ij}$, is -1 if there is no direct route from the i-th to the j-th city, and the length of that route in kilometers otherwise.\n- $Q$ lines containing two integers $U_k$ and $V_k$, the starting and destination point, respectively, of the k-th pair of cities we want to investigate.", "outputFormat": "For each test case, output one line containing `Case #x: y_1 y_2 ... y_Q`, where $x$ is the test case number (starting from 1) and $y_k$ is the minimum time, in hours, to deliver a letter from city $U_k$ to city $V_k$.\n\nEach $y_k$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nNote that the last sample case would not appear in the Small dataset.\n\nIn Case #1 there are two options: use the horse in city 1 for the entire trip, or change horses in city 2. Both horses have enough endurance, so both options are viable. Since the horse in city 2 is faster, it is better to change, for a total time of $1/3 + 1/4$.\n\nIn Case #2 there are two intermediate cities in which you can change horses. If you change horses in city 2, however, your new horse, while blazingly fast, will not have enough endurance, so you will be forced to change again in city 3. If you keep your horse, you will have the option to change horses (or not) in city 3. So, the three options, with their total times, are:\n\n1. Change horses in both city 2 and 3 ($1/10 + 1/1000 + 10/8 = 1.351$).\n2. Change horses just in city 3 ($2/10 + 10/8 = 1.45$).\n3. Never change horses ($12/10 = 1.2$).\n\nIn Case #3, there are lots of alternatives for each delivery. The optimal one for the first delivery (city 2 to city 4) is to go to city 1 in time $10/1000$, change horses, and then go to cities 2, 3 and 4, in that order, using the horse from city 1, which takes time $(10 + 10 + 10) / 60$.\n\nFor the second delivery (city 3 to city 2) you have no choice but to first go to city 4 which takes time $10/5$. Your relatively fast horse does not have enough endurance to get anywhere else, so you need to grab the horse in city 4. You could use it to get directly to city 1 in time 15, but that would be slower than riding it to city 2 in time 6 and then using the blazingly fast horse in city 2 to get to city 1 in just $10/1000$ extra time.\n\nIn the third delivery (city 3 to city 1) of Case #3 it is optimal to use the first two steps of the previous one, for a total time of $10/5 + 6 = 8$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq N \\leq 100$.\n- $1 \\leq E_i \\leq 10^9$, for all $i$.\n- $1 \\leq S_i \\leq 1000$, for all $i$.\n- $-1 \\leq D_{ij} \\leq 10^9$, for all $i, j$.\n- $D_{ii} = -1$, for all $i$. (There are no direct routes from a city to itself.)\n- $D_{ij} \\neq 0$, for all $i, j$.\n- $U_k \\neq V_k$, for all $k$.\n- It is guaranteed that the delivery from $U_k$ to $V_k$ can be accomplished with the given horses, for all $k$.\n- $U_l \\neq U_m$ and/or $V_l \\neq V_m$, for all different $l, m$. (No ordered pair of cities to investigate is repeated within a test case.)\n\n**Small dataset (16 Pts, Test Set 1 - Visible)**\n\n- $D_{ij} = -1$, for all $i, j$ where $i + 1 \\neq j$. (The cities are in a single line; each route goes from one city to the next city in line.)\n- $Q = 1$.\n- $U_1 = 1$.\n- $V_1 = N$. (The only delivery to calculate is between the first and last cities in the line).\n\n**Large dataset (24 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq Q \\leq 100$.\n- $1 \\leq U_k \\leq N$, for all $k$.\n- $1 \\leq V_k \\leq N$, for all $k$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #1B] Pony Express", "background": null, "description": "现在是 1860 年，Pony Express 是连接美国东西海岸最快的邮件递送系统。该系统服务于 $N$ 个不同的城市。每个城市都有一匹马（正如“一马小镇”这个说法）；每匹马都有一个恒定的速度，并且有一个最大总行驶距离，超过这个距离马就会太累无法继续前进。\n\nPony Express 的骑手会骑上起始城市的马出发。每当骑手到达一个城市时，可以选择继续使用当前的马，或者换乘该城市的马；换马是瞬间完成的。马匹永远没有休息的机会，因此一旦马的最大总距离被“消耗”了一部分，这部分就永远无法恢复！当骑手到达目的地城市时，邮件就被送达。\n\n城市之间的路线是通过公司老板、立法者、工会代表和表哥 Pete 的复杂协商建立的。这意味着城市之间的距离不一定符合常理：例如，它们不一定满足三角不等式，从城市 A 到城市 B 的距离可能与从城市 B 到城市 A 的距离不同！\n\n你是一位穿越时空的企业家，带来了一台来自未来的高速计算机。虽然一台计算机还不足以让你建立电子邮件服务从而让 Pony Express 过时，但你可以用它为 Pony Express 制定最优的路线规划。给定所有城市间路线和每个城市马匹的信息，以及一系列起点和终点城市对，你能否快速计算出每次递送所需的最短时间？（你应将所有递送视为独立事件；在一条路线中使用的城市/马匹不会影响其他路线的可用性。）", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据描述如下：\n\n- 一行包含两个整数：$N$，表示有马的城市数量，$Q$，表示需要查询的起止城市对数量。城市编号为 $1$ 到 $N$。\n- 接下来 $N$ 行，每行包含两个整数 $E_i$ 和 $S_i$，分别表示第 $i$ 个城市的马的最大总行驶距离（单位：千米）和恒定速度（单位：千米/小时）。\n- 接下来 $N$ 行，每行包含 $N$ 个整数。第 $i$ 行第 $j$ 个整数 $D_{ij}$，若 $D_{ij} = -1$，表示没有从第 $i$ 个城市到第 $j$ 个城市的直达路线，否则表示该路线的长度（单位：千米）。\n- 接下来 $Q$ 行，每行包含两个整数 $U_k$ 和 $V_k$，分别表示第 $k$ 个需要查询的起点和终点城市。", "outputFormat": "对于每组测试数据，输出一行，格式为 `Case #x: y_1 y_2 ... y_Q`，其中 $x$ 表示测试用例编号（从 1 开始），$y_k$ 表示从城市 $U_k$ 到城市 $V_k$ 递送邮件所需的最短时间（单位：小时）。\n\n每个 $y_k$ 的答案只要在绝对误差或相对误差 $10^{-6}$ 以内都视为正确。", "hint": "**样例说明**\n\n注意，最后一个样例不会出现在 Small 数据集中。\n\n在 Case #1 中有两种选择：全程使用城市 1 的马，或者在城市 2 换马。两匹马的耐力都足够，因此两种方案都可行。由于城市 2 的马更快，所以换马更优，总时间为 $1/3 + 1/4$。\n\n在 Case #2 中，有两个中间城市可以换马。如果你在城市 2 换马，虽然新马速度极快，但耐力不足，因此你必须在城市 3 再次换马。如果你不换马，则可以选择在城市 3 换马（或不换）。三种方案及其总时间如下：\n\n1. 在城市 2 和 3 都换马（$1/10 + 1/1000 + 10/8 = 1.351$）。\n2. 只在城市 3 换马（$2/10 + 10/8 = 1.45$）。\n3. 全程不换马（$12/10 = 1.2$）。\n\n在 Case #3 中，每次递送都有许多选择。对于第一次递送（城市 2 到城市 4），最优方案是先到城市 1，耗时 $10/1000$，换马后再依次到城市 2、3、4，使用城市 1 的马，总耗时为 $(10 + 10 + 10) / 60$。\n\n对于 Case #3 的第二次递送（城市 3 到城市 2），你只能先到城市 4，耗时 $10/5$。你的马虽然速度快，但耐力不足以到其他地方，因此你需要换乘城市 4 的马。你可以直接骑它到城市 1，耗时 15，但骑到城市 2 只需 6，然后再用城市 2 的极速马到城市 1，仅需额外 $10/1000$ 时间。\n\n对于 Case #3 的第三次递送（城市 3 到城市 1），最优方案是复用上一次的前两步，总耗时 $10/5 + 6 = 8$。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $2 \\leq N \\leq 100$。\n- $1 \\leq E_i \\leq 10^9$，对于所有 $i$。\n- $1 \\leq S_i \\leq 1000$，对于所有 $i$。\n- $-1 \\leq D_{ij} \\leq 10^9$，对于所有 $i, j$。\n- $D_{ii} = -1$，对于所有 $i$。（不存在城市到自身的直达路线。）\n- $D_{ij} \\neq 0$，对于所有 $i, j$。\n- $U_k \\neq V_k$，对于所有 $k$。\n- 保证对于所有 $k$，从 $U_k$ 到 $V_k$ 的递送一定可以完成。\n- 对于任意不同的 $l, m$，有 $U_l \\neq U_m$ 和/或 $V_l \\neq V_m$。（每组测试数据中不会有重复的城市对。）\n\n**Small 数据集（16 分，测试集 1 - 可见）**\n\n- 对于所有 $i, j$，若 $i + 1 \\neq j$，则 $D_{ij} = -1$。（城市排成一条直线，每条路线只连接相邻城市。）\n- $Q = 1$。\n- $U_1 = 1$。\n- $V_1 = N$。（唯一需要计算的递送是从第一座城市到最后一座城市。）\n\n**Large 数据集（24 分，测试集 2 - 隐藏）**\n\n- $1 \\leq Q \\leq 100$。\n- $1 \\leq U_k \\leq N$，对于所有 $k$。\n- $1 \\leq V_k \\leq N$，对于所有 $k$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13168", "type": "P", "difficulty": 3, "samples": [["4\n2 1\n100 20\n200 10\n2 2\n100 20\n200 10\n3 2\n100 10\n100 10\n100 10\n4 2\n9 3\n7 1\n10 1\n8 4", "Case #1: 138230.076757951\nCase #2: 150796.447372310\nCase #3: 43982.297150257\nCase #4: 625.176938064"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["2017", "堆", "Special Judge", "排序", "Google Code Jam"], "title": "[GCJ 2017 #1C] Ample Syrup", "background": "", "description": "The kitchen at the Infinite House of Pancakes has just received an order for a stack of $K$ pancakes! The chef currently has $N$ pancakes available, where $N \\geq K$. Each pancake is a cylinder, and different pancakes may have different radii and heights.\n\nAs the sous-chef, you must choose $K$ out of the $N$ available pancakes, discard the others, and arrange those $K$ pancakes in a stack on a plate as follows. First, take the pancake that has the largest radius, and lay it on the plate on one of its circular faces. (If multiple pancakes have the same radius, you can use any of them.) Then, take the remaining pancake with the next largest radius and lay it on top of that pancake, and so on, until all $K$ pancakes are in the stack and the centers of the circular faces are aligned in a line perpendicular to the plate, as illustrated by this example:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/57lkgshp.png)\n\nYou know that there is only one thing your diners love as much as they love pancakes: syrup! It is best to maximize the total amount of exposed pancake surface area in the stack, since more exposed pancake surface area means more places to pour on delicious syrup. Any part of a pancake that is not touching part of another pancake or the plate is considered to be exposed.\n\nIf you choose the $K$ pancakes optimally, what is the largest total exposed pancake surface area you can achieve?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line with two integers $N$ and $K$: the total number of available pancakes, and the size of the stack that the diner has ordered. Then, $N$ more lines follow. Each contains two integers $R_i$ and $H_i$: the radius and height of the $i$-th pancake, in millimeters.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum possible total exposed pancake surface area, in millimeters squared. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nIn sample case #1, the \"stack\" consists only of one pancake. A stack of just the first pancake would have an exposed area of $\\pi \\times R_0^2 + 2 \\times \\pi \\times R_0 \\times H_0 = 14000\\pi \\text{ mm}^2$. A stack of just the second pancake would have an exposed area of $44000\\pi \\text{ mm}^2$. So it is better to use the second pancake.\n\nIn sample case #2, we can use both of the same pancakes from case #1. The first pancake contributes its top area and its side, for a total of $14000\\pi \\text{ mm}^2$. The second pancake contributes some of its top area (the part not covered by the first pancake) and its side, for a total of $34000\\pi \\text{ mm}^2$. The combined exposed surface area is $48000\\pi \\text{ mm}^2$.\n\nIn sample case #3, all of the pancakes have radius 100 and height 10. If we stack two of these together, we effectively have a single new cylinder of radius 100 and height 20. The exposed surface area is $14000\\pi \\text{ mm}^2$.\n\nIn sample case #4, the optimal stack uses the pancakes with radii of 8 and 9.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq K \\leq N$.\n- $1 \\leq R_i \\leq 10^6$, for all $i$.\n- $1 \\leq H_i \\leq 10^6$, for all $i$.\n\n**Small dataset (9 Pts, Test Set 1 - Visible)**\n\n- $1 \\leq N \\leq 10$.\n\n**Large dataset (16 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq N \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #1C] Ample Syrup", "background": "", "description": "The kitchen at the Infinite House of Pancakes has just received an order for a stack of $K$ pancakes! The chef currently has $N$ pancakes available, where $N \\geq K$. Each pancake is a cylinder, and different pancakes may have different radii and heights.\n\nAs the sous-chef, you must choose $K$ out of the $N$ available pancakes, discard the others, and arrange those $K$ pancakes in a stack on a plate as follows. First, take the pancake that has the largest radius, and lay it on the plate on one of its circular faces. (If multiple pancakes have the same radius, you can use any of them.) Then, take the remaining pancake with the next largest radius and lay it on top of that pancake, and so on, until all $K$ pancakes are in the stack and the centers of the circular faces are aligned in a line perpendicular to the plate, as illustrated by this example:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/57lkgshp.png)\n\nYou know that there is only one thing your diners love as much as they love pancakes: syrup! It is best to maximize the total amount of exposed pancake surface area in the stack, since more exposed pancake surface area means more places to pour on delicious syrup. Any part of a pancake that is not touching part of another pancake or the plate is considered to be exposed.\n\nIf you choose the $K$ pancakes optimally, what is the largest total exposed pancake surface area you can achieve?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line with two integers $N$ and $K$: the total number of available pancakes, and the size of the stack that the diner has ordered. Then, $N$ more lines follow. Each contains two integers $R_i$ and $H_i$: the radius and height of the $i$-th pancake, in millimeters.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum possible total exposed pancake surface area, in millimeters squared. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nIn sample case #1, the \"stack\" consists only of one pancake. A stack of just the first pancake would have an exposed area of $\\pi \\times R_0^2 + 2 \\times \\pi \\times R_0 \\times H_0 = 14000\\pi \\text{ mm}^2$. A stack of just the second pancake would have an exposed area of $44000\\pi \\text{ mm}^2$. So it is better to use the second pancake.\n\nIn sample case #2, we can use both of the same pancakes from case #1. The first pancake contributes its top area and its side, for a total of $14000\\pi \\text{ mm}^2$. The second pancake contributes some of its top area (the part not covered by the first pancake) and its side, for a total of $34000\\pi \\text{ mm}^2$. The combined exposed surface area is $48000\\pi \\text{ mm}^2$.\n\nIn sample case #3, all of the pancakes have radius 100 and height 10. If we stack two of these together, we effectively have a single new cylinder of radius 100 and height 20. The exposed surface area is $14000\\pi \\text{ mm}^2$.\n\nIn sample case #4, the optimal stack uses the pancakes with radii of 8 and 9.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq K \\leq N$.\n- $1 \\leq R_i \\leq 10^6$, for all $i$.\n- $1 \\leq H_i \\leq 10^6$, for all $i$.\n\n**Small dataset (9 Pts, Test Set 1 - Visible)**\n\n- $1 \\leq N \\leq 10$.\n\n**Large dataset (16 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq N \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #1C] Ample Syrup", "background": null, "description": "无限煎饼屋的厨房刚刚收到了一份包含 $K$ 张煎饼的订单！厨师目前有 $N$ 张煎饼可用，其中 $N \\geq K$。每张煎饼都是一个圆柱体，不同的煎饼可能有不同的半径和高度。\n\n作为副厨师，你需要从这 $N$ 张煎饼中选择 $K$ 张，丢弃其余的煎饼，并将这 $K$ 张煎饼按如下方式叠放在盘子上。首先，取出半径最大的煎饼，将其一面圆形朝下放在盘子上。（如果有多张煎饼半径相同，可以任选其中一张。）然后，取剩下的半径次大的煎饼，叠放在第一张煎饼上，以此类推，直到所有 $K$ 张煎饼都叠好，并且所有圆形面的中心都在一条垂直于盘子的直线上，如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/57lkgshp.png)\n\n你知道，食客们除了喜欢煎饼外，还同样喜欢糖浆！最大化煎饼堆中所有暴露在外的煎饼表面积是最好的，因为暴露的表面积越多，能倒上美味糖浆的地方就越多。任何没有与其他煎饼或盘子接触的煎饼部分都被视为暴露在外。\n\n如果你最优地选择这 $K$ 张煎饼，能获得的最大总暴露煎饼表面积是多少？", "inputFormat": "输入的第一行包含测试用例数 $T$。接下来有 $T$ 组测试用例。每组测试用例的第一行为两个整数 $N$ 和 $K$，分别表示可用煎饼总数和订单所需的煎饼数量。接下来的 $N$ 行，每行包含两个整数 $R_i$ 和 $H_i$，分别表示第 $i$ 张煎饼的半径和高度，单位为毫米。", "outputFormat": "对于每组测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是最大可能的总暴露煎饼表面积，单位为平方毫米。只要 $y$ 的绝对误差或相对误差在 $10^{-6}$ 以内，都视为正确。", "hint": "**样例解释**\n\n在样例 1 中，\"堆叠\" 只包含一张煎饼。只用第一张煎饼时，暴露表面积为 $\\pi \\times R_0^2 + 2 \\times \\pi \\times R_0 \\times H_0 = 14000\\pi \\text{ mm}^2$。只用第二张煎饼时，暴露表面积为 $44000\\pi \\text{ mm}^2$。因此，使用第二张煎饼更优。\n\n在样例 2 中，我们可以使用样例 1 中的两张煎饼。第一张煎饼贡献了顶部面积和侧面积，总共 $14000\\pi \\text{ mm}^2$。第二张煎饼贡献了部分顶部面积（未被第一张煎饼覆盖的部分）和侧面积，总共 $34000\\pi \\text{ mm}^2$。合计暴露表面积为 $48000\\pi \\text{ mm}^2$。\n\n在样例 3 中，所有煎饼的半径均为 100，高度均为 10。如果叠放两张这样的煎饼，实际上就相当于一个半径为 100、高度为 20 的新圆柱体。暴露表面积为 $14000\\pi \\text{ mm}^2$。\n\n在样例 4 中，最优的堆叠方式是选择半径为 8 和 9 的煎饼。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq K \\leq N$。\n- $1 \\leq R_i \\leq 10^6$，对于所有 $i$。\n- $1 \\leq H_i \\leq 10^6$，对于所有 $i$。\n\n**小数据范围（9 分，测试点 1 - 可见）**\n\n- $1 \\leq N \\leq 10$。\n\n**大数据范围（16 分，测试点 2 - 隐藏）**\n\n- $1 \\leq N \\leq 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13169", "type": "P", "difficulty": 4, "samples": [["5\n1 1\n540 600\n840 900\n2 0\n900 1260\n180 540\n1 1\n1439 1440\n0 1\n2 2\n0 1\n1439 1440\n1438 1439\n1 2\n3 4\n0 10\n1420 1440\n90 100\n550 600\n900 950\n100 150\n1050 1400", "Case #1: 2\nCase #2: 4\nCase #3: 2\nCase #4: 4\nCase #5: 6"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2017", "Google Code Jam"], "title": "[GCJ 2017 #1C] Parenting Partnering", "background": "", "description": "Cameron and Jamie are longtime life partners and have recently become parents! Being in charge of a baby, exciting as it is, is not without challenges. Given that both parents have a scientific mind, they have decided to take a scientific approach to baby care.\n\nCameron and Jamie are establishing a daily routine and need to decide who will be the main person in charge of the baby at each given time. They have been equal partners their whole relationship, and they do not want to stop now, so they decided that each of them will be in charge for exactly 12 hours (720 minutes) per day.\n\nCameron and Jamie have other activities that they either need or want to do on their own. Cameron has $A_C$ of these and Jamie has $A_J$. These activities always take place at the same times each day. None of Cameron's activities overlap with Jamie's activities, so at least one of the parents will always be free to take care of the baby.\n\nCameron and Jamie want to come up with a daily baby care schedule such that:\n\n* Scheduled baby time must not interfere with a scheduled activity. That is, during Cameron's activities, Jamie has to be in charge of the baby, and vice versa.\n* Each of Cameron and Jamie must have exactly 720 minutes assigned to them.\n* The number of exchanges — that is, the number of times the person in charge of the baby changes from one partner to the other — must be as small as possible.\n\nFor example, suppose that Jamie and Cameron have a single activity each: Jamie has a morning activity from 9 am to 10 am, and Cameron has an afternoon activity from 2 pm to 3 pm. One possible but suboptimal schedule would be for Jamie to take care of the baby from midnight to 6 am and from noon to 6 pm, and for Cameron to take care of the baby from 6 am to noon and 6 pm to midnight. That fulfills the first two conditions, and requires a total of 4 exchanges, which happen at midnight, 6 am, noon and 6 pm. If there is an exchange happening at midnight, it is counted exactly once, not zero or two times.\n\nA better option would be for Cameron to take care of the baby from midnight to noon, and Jamie to take care of the baby from noon to midnight. This schedule also fulfills the first two conditions, but it uses only 2 exchanges, which is the minimum possible.\n\nGiven Cameron's and Jamie's lists of activities, and the restrictions above, what is the minimum possible number of exchanges in a daily schedule?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a line containing two integers $A_C$ and $A_J$, the number of activities that Cameron and Jamie have, respectively. Then, $A_C + A_J$ lines follow. The first $A_C$ of these lines contain two integers $C_i$ and $D_i$ each. The $i$-th of Cameron's activities starts exactly $C_i$ minutes after the start of the day at midnight and ends exactly $D_i$ minutes after the start of the day at midnight (taking exactly $D_i - C_i$ minutes). The last $A_J$ of these lines contain two integers $J_i$ and $K_i$ each, representing the starting and ending time of one of Jamie's activities, in minutes counting from the start of the day at midnight (same format as Cameron's). No activity spans two days, and no two activities overlap (except that one might end exactly as another starts, but an exchange can still occur at that time).", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ the minimum possible number of exchanges, as described in the statement.", "hint": "**Sample Explanation**\n\nNote that Cases #4 and #5 would not appear in the Small dataset.\n\nCase #1 is the one described in the problem statement.\n\nIn Case #2, Jamie must cover for all of Cameron's activity time, and then Cameron must cover all the remaining time. This schedule entails four exchanges.\n\nIn Case #3, there is an exchange at midnight, from Cameron to Jamie. No matter how the parents divide up the remaining $1438$ non-activity minutes of the day, there must be at least one exchange from Jamie to Cameron, and there is no reason to add more exchanges than that.\n\nIn Case #4, note that back-to-back activities can exist for the same partner or different partners. There is no exchange at midnight because Cameron has activities both right before and right after that time. However, the schedule needs to add some time for Cameron in between Jamie's activities, requiring a total of $4$ exchanges. Notice that it is optimal to add a single interval for Cameron of length $718$ somewhere between minutes $2$ and $1438$, but the exact position of that added interval does not impact the number of exchanges, so there are multiple optimal schedules.\n\nIn Case #5, a possible optimal schedule is to assign Cameron to the intervals (in minutes) $100-200$, $500-620$, and $900-1400$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $0 \\leq C_i < D_i \\leq 24 \\times 60$, for all $i$.\n- $0 \\leq J_i < K_i \\leq 24 \\times 60$, for all $i$.\n- Any two of the intervals of $\\{[C_i, D_i)\\}$ for all $i$ union $\\{[J_i, K_i)\\}$ for all $i$ have an empty intersection. (The intervals are closed on the left and open on the right, which ensures that two exactly consecutive intervals have nothing in between but do not overlap.)\n- $\\sum (D_i - C_i)$ for all $i \\leq 720$.\n- $\\sum (K_i - J_i)$ for all $i \\leq 720$.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- $0 \\leq A_C \\leq 2$.\n- $0 \\leq A_J \\leq 2$.\n- $1 \\leq A_C + A_J \\leq 2$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- $0 \\leq A_C \\leq 100$.\n- $0 \\leq A_J \\leq 100$.\n- $1 \\leq A_C + A_J \\leq 200$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #1C] Parenting Partnering", "background": "", "description": "Cameron and Jamie are longtime life partners and have recently become parents! Being in charge of a baby, exciting as it is, is not without challenges. Given that both parents have a scientific mind, they have decided to take a scientific approach to baby care.\n\nCameron and Jamie are establishing a daily routine and need to decide who will be the main person in charge of the baby at each given time. They have been equal partners their whole relationship, and they do not want to stop now, so they decided that each of them will be in charge for exactly 12 hours (720 minutes) per day.\n\nCameron and Jamie have other activities that they either need or want to do on their own. Cameron has $A_C$ of these and Jamie has $A_J$. These activities always take place at the same times each day. None of Cameron's activities overlap with Jamie's activities, so at least one of the parents will always be free to take care of the baby.\n\nCameron and Jamie want to come up with a daily baby care schedule such that:\n\n* Scheduled baby time must not interfere with a scheduled activity. That is, during Cameron's activities, Jamie has to be in charge of the baby, and vice versa.\n* Each of Cameron and Jamie must have exactly 720 minutes assigned to them.\n* The number of exchanges — that is, the number of times the person in charge of the baby changes from one partner to the other — must be as small as possible.\n\nFor example, suppose that Jamie and Cameron have a single activity each: Jamie has a morning activity from 9 am to 10 am, and Cameron has an afternoon activity from 2 pm to 3 pm. One possible but suboptimal schedule would be for Jamie to take care of the baby from midnight to 6 am and from noon to 6 pm, and for Cameron to take care of the baby from 6 am to noon and 6 pm to midnight. That fulfills the first two conditions, and requires a total of 4 exchanges, which happen at midnight, 6 am, noon and 6 pm. If there is an exchange happening at midnight, it is counted exactly once, not zero or two times.\n\nA better option would be for Cameron to take care of the baby from midnight to noon, and Jamie to take care of the baby from noon to midnight. This schedule also fulfills the first two conditions, but it uses only 2 exchanges, which is the minimum possible.\n\nGiven Cameron's and Jamie's lists of activities, and the restrictions above, what is the minimum possible number of exchanges in a daily schedule?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a line containing two integers $A_C$ and $A_J$, the number of activities that Cameron and Jamie have, respectively. Then, $A_C + A_J$ lines follow. The first $A_C$ of these lines contain two integers $C_i$ and $D_i$ each. The $i$-th of Cameron's activities starts exactly $C_i$ minutes after the start of the day at midnight and ends exactly $D_i$ minutes after the start of the day at midnight (taking exactly $D_i - C_i$ minutes). The last $A_J$ of these lines contain two integers $J_i$ and $K_i$ each, representing the starting and ending time of one of Jamie's activities, in minutes counting from the start of the day at midnight (same format as Cameron's). No activity spans two days, and no two activities overlap (except that one might end exactly as another starts, but an exchange can still occur at that time).", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ the minimum possible number of exchanges, as described in the statement.", "hint": "**Sample Explanation**\n\nNote that Cases #4 and #5 would not appear in the Small dataset.\n\nCase #1 is the one described in the problem statement.\n\nIn Case #2, Jamie must cover for all of Cameron's activity time, and then Cameron must cover all the remaining time. This schedule entails four exchanges.\n\nIn Case #3, there is an exchange at midnight, from Cameron to Jamie. No matter how the parents divide up the remaining $1438$ non-activity minutes of the day, there must be at least one exchange from Jamie to Cameron, and there is no reason to add more exchanges than that.\n\nIn Case #4, note that back-to-back activities can exist for the same partner or different partners. There is no exchange at midnight because Cameron has activities both right before and right after that time. However, the schedule needs to add some time for Cameron in between Jamie's activities, requiring a total of $4$ exchanges. Notice that it is optimal to add a single interval for Cameron of length $718$ somewhere between minutes $2$ and $1438$, but the exact position of that added interval does not impact the number of exchanges, so there are multiple optimal schedules.\n\nIn Case #5, a possible optimal schedule is to assign Cameron to the intervals (in minutes) $100-200$, $500-620$, and $900-1400$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $0 \\leq C_i < D_i \\leq 24 \\times 60$, for all $i$.\n- $0 \\leq J_i < K_i \\leq 24 \\times 60$, for all $i$.\n- Any two of the intervals of $\\{[C_i, D_i)\\}$ for all $i$ union $\\{[J_i, K_i)\\}$ for all $i$ have an empty intersection. (The intervals are closed on the left and open on the right, which ensures that two exactly consecutive intervals have nothing in between but do not overlap.)\n- $\\sum (D_i - C_i)$ for all $i \\leq 720$.\n- $\\sum (K_i - J_i)$ for all $i \\leq 720$.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- $0 \\leq A_C \\leq 2$.\n- $0 \\leq A_J \\leq 2$.\n- $1 \\leq A_C + A_J \\leq 2$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- $0 \\leq A_C \\leq 100$.\n- $0 \\leq A_J \\leq 100$.\n- $1 \\leq A_C + A_J \\leq 200$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #1C] Parenting Partnering", "background": null, "description": "Cameron 和 Jamie 是多年的生活伴侣，最近刚刚成为了父母！照顾婴儿虽然令人兴奋，但也充满挑战。由于两位父母都具有科学思维，他们决定以科学的方法来照顾孩子。\n\nCameron 和 Jamie 正在制定每日作息时间表，需要决定在每天的每个时刻由谁主要负责照看婴儿。他们一直以来都是平等的伴侣，现在也不想改变这一点，因此他们决定每天各自负责照看婴儿恰好 12 小时（720 分钟）。\n\nCameron 和 Jamie 各自还有一些必须或想要独自完成的活动。Cameron 有 $A_C$ 个这样的活动，Jamie 有 $A_J$ 个。这些活动每天都在相同的时间进行。Cameron 的活动与 Jamie 的活动不会重叠，因此至少有一位父母始终可以照看婴儿。\n\nCameron 和 Jamie 想要制定一个每日照看婴儿的时间表，使得：\n\n- 安排的照看时间不能与已安排的活动冲突。也就是说，在 Cameron 有活动时，Jamie 必须负责照看婴儿，反之亦然。\n- Cameron 和 Jamie 每人分配的照看时间必须恰好为 720 分钟。\n- 交接次数——即负责照看婴儿的人从一方变为另一方的次数——要尽可能少。\n\n例如，假设 Jamie 和 Cameron 各有一项活动：Jamie 有一项早上 9 点到 10 点的活动，Cameron 有一项下午 2 点到 3 点的活动。一种可能但非最优的安排是，Jamie 从午夜到早上 6 点以及中午到下午 6 点照看婴儿，Cameron 从早上 6 点到中午以及下午 6 点到午夜照看婴儿。这样满足前两个条件，总共需要 4 次交接，分别发生在午夜、早上 6 点、中午和下午 6 点。如果交接发生在午夜，只计作一次，不计作零次或两次。\n\n更优的方案是 Cameron 从午夜到中午照看婴儿，Jamie 从中午到午夜照看婴儿。这个安排同样满足前两个条件，但只需要 2 次交接，这是最少可能的次数。\n\n给定 Cameron 和 Jamie 的活动列表，以及上述限制，问每日时间表中最少需要多少次交接？", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试用例。每组测试用例的第一行为两个整数 $A_C$ 和 $A_J$，分别表示 Cameron 和 Jamie 的活动数。接下来的 $A_C + A_J$ 行，每行包含两个整数。前 $A_C$ 行，每行包含两个整数 $C_i$ 和 $D_i$，表示 Cameron 的第 $i$ 个活动从午夜起第 $C_i$ 分钟开始，到第 $D_i$ 分钟结束（持续 $D_i - C_i$ 分钟）。接下来的 $A_J$ 行，每行包含两个整数 $J_i$ 和 $K_i$，表示 Jamie 的一项活动的开始和结束时间（同样以午夜起的分钟数计）。没有活动跨越两天，且任意两项活动不会重叠（但可能一个活动结束时另一个活动正好开始，此时可以发生交接）。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为最少的交接次数。", "hint": "**样例解释**\n\n注意，样例 #4 和 #5 不会出现在 Small 数据集。\n\n样例 #1 即题目描述中的例子。\n\n在样例 #2 中，Jamie 必须覆盖 Cameron 所有活动的时间，然后 Cameron 覆盖剩余的时间。这个安排需要 4 次交接。\n\n在样例 #3 中，午夜时有一次从 Cameron 到 Jamie 的交接。无论父母如何分配剩余的 $1438$ 分钟非活动时间，至少还需要一次从 Jamie 到 Cameron 的交接，没有理由增加更多交接。\n\n在样例 #4 中，注意同一方或不同方的活动可能连续出现。由于 Cameron 在午夜前后都有活动，因此午夜没有交接。但在 Jamie 的活动之间需要为 Cameron 安排一段时间，总共需要 4 次交接。最优做法是在第 2 分钟到第 1438 分钟之间为 Cameron 安排一段长度为 718 分钟的区间，具体位置不影响交接次数，因此存在多种最优方案。\n\n在样例 #5 中，一种最优方案是将 Cameron 分配到区间（以分钟计）$100-200$、$500-620$ 和 $900-1400$。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- 对所有 $i$，$0 \\leq C_i < D_i \\leq 24 \\times 60$。\n- 对所有 $i$，$0 \\leq J_i < K_i \\leq 24 \\times 60$。\n- 所有 $\\{[C_i, D_i)\\}$ 与 $\\{[J_i, K_i)\\}$ 区间两两不重叠（区间左闭右开，确保两个完全连续的区间之间没有重叠，但也没有间隙）。\n- $\\sum (D_i - C_i)$ 对所有 $i$ 不超过 720。\n- $\\sum (K_i - J_i)$ 对所有 $i$ 不超过 720。\n\n**Small 数据集（测试集 1 - 可见）**\n\n- $0 \\leq A_C \\leq 2$。\n- $0 \\leq A_J \\leq 2$。\n- $1 \\leq A_C + A_J \\leq 2$。\n\n**Large 数据集（测试集 2 - 隐藏）**\n\n- $0 \\leq A_C \\leq 100$。\n- $0 \\leq A_J \\leq 100$。\n- $1 \\leq A_C + A_J \\leq 200$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13170", "type": "P", "difficulty": 7, "samples": [["4\n4 4\n1.4000\n0.5000 0.7000 0.8000 0.6000\n2 2\n1.0000\n0.0000 0.0000\n2 1\n0.0000\n0.9000 0.8000\n2 1\n0.1000\n0.4000 0.5000", "Case #1: 1.000000\nCase #2: 0.250000\nCase #3: 0.980000\nCase #4: 0.760000"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2017", "Special Judge", "概率论", "Google Code Jam"], "title": "[GCJ 2017 #1C] Core Training", "background": "", "description": "Writing Code Jam problems is hard, so we have built an AI to come up with new ideas. To make the AI as creative as possible, we have given it $N$ different \"cores\", each of which has its own \"personality\". However, just like people, these cores may become distracted or corrupt or may refuse to work; the i-th core has a success probability $P_i$ of functioning properly. As long as at least $K$ of the cores function properly, the AI will function properly. Otherwise, it will probably become evil and trap us in a maze of fiendish puzzles of its own design. And who knows what it might do to Code Jam — it might just write a bunch of tough probability problems!\n\nTo prevent this from happening, we plan to train one or more of the cores to become more reliable. We have a total of $U$ \"training units\" that we can use to improve the cores. Spending $X$ units on the i-th core will add $X$ to its success probability. We can divide up the units among the cores however we like, and it is possible that one or more cores may not receive any units. Of course, a core's success probability cannot be increased above 1.\n\nIf we assign the training units to maximize the probability that the AI will function properly, what is that probability?\n\n~~**Solving this problem**~~\n\n~~This problem has 2 Small datasets and no Large dataset. You must solve the first Small dataset before you can attempt the second Small dataset. You will be able to retry either of the datasets (with a time penalty).~~", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each consists of three lines. The first line contains two integers $N$ and $K$: the total number of cores, and the minimum number of cores that must succeed for the AI to function properly. The second line contains one rational $U$: the number of training units. The third line contains $N$ rational numbers $P_i$; the i-th of these gives the probability that the i-th core will function properly. All of these probabilities are specified to exactly four decimal places of precision.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the probability that the AI will function properly if the training units are assigned optimally. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nNote that the last two sample cases would not appear in Small dataset 1.\n\nIn Sample Case #1, we have enough training units to spend to give all cores a success probability of 1, so the AI will certainly function properly.\n\nIn Sample Case #2, both of the cores must function properly for the AI to function properly, so we must give each core at least some training units. The best option turns out to be to train each one up to $0.5$. Then the probability that the AI functions properly is $0.5 \\times 0.5 = 0.25$. Any other assignment is inferior; for instance, if we train one core to $0.9$ and the other core to $0.1$, the probability of success is only $0.9 \\times 0.1 = 0.09$.\n\nIn Sample Case #3, we have no training units to spend, and at least one of the two cores must function properly for the AI to function properly. We can approach this by first calculating the probability that the AI does not function properly, which happens only if both cores fail to function properly. The probability that both cores fail is $(1 - 0.9) \\times (1 - 0.8) = 0.02$. So the probability that at least one core functions properly, and thus that the AI functions properly, is $1 - 0.02 = 0.98$.\n\nIn Sample Case #4, the optimal strategy is to give all the training units to the second core. That makes the probability of at least one core functioning properly $1 - (0.4 \\times 0.6) = 0.76$. All other options are inferior; for example, giving all the training units to the first core only yields $0.75$, and dividing them equally among the cores gives $0.7525$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N \\leq 50$.\n- For all $i$, $0.0000 \\leq P_i \\leq 1.0000$.\n- $0.0000 \\leq U \\leq N - \\sum P_i$. (There will not be more training units than can be used.)\n\n**Small dataset 1 (15 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~20~~ 5 seconds.\n- $K = N$. (All of the cores must function properly for the AI to function properly.)\n\n**Small dataset 2 (28 Pts, Test Set 2 - Visible)**\n\n- Time limit: ~~40~~ 10 seconds.\n- $1 \\leq K \\leq N$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #1C] Core Training", "background": "", "description": "Writing Code Jam problems is hard, so we have built an AI to come up with new ideas. To make the AI as creative as possible, we have given it $N$ different \"cores\", each of which has its own \"personality\". However, just like people, these cores may become distracted or corrupt or may refuse to work; the i-th core has a success probability $P_i$ of functioning properly. As long as at least $K$ of the cores function properly, the AI will function properly. Otherwise, it will probably become evil and trap us in a maze of fiendish puzzles of its own design. And who knows what it might do to Code Jam — it might just write a bunch of tough probability problems!\n\nTo prevent this from happening, we plan to train one or more of the cores to become more reliable. We have a total of $U$ \"training units\" that we can use to improve the cores. Spending $X$ units on the i-th core will add $X$ to its success probability. We can divide up the units among the cores however we like, and it is possible that one or more cores may not receive any units. Of course, a core's success probability cannot be increased above 1.\n\nIf we assign the training units to maximize the probability that the AI will function properly, what is that probability?\n\n~~**Solving this problem**~~\n\n~~This problem has 2 Small datasets and no Large dataset. You must solve the first Small dataset before you can attempt the second Small dataset. You will be able to retry either of the datasets (with a time penalty).~~", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each consists of three lines. The first line contains two integers $N$ and $K$: the total number of cores, and the minimum number of cores that must succeed for the AI to function properly. The second line contains one rational $U$: the number of training units. The third line contains $N$ rational numbers $P_i$; the i-th of these gives the probability that the i-th core will function properly. All of these probabilities are specified to exactly four decimal places of precision.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the probability that the AI will function properly if the training units are assigned optimally. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nNote that the last two sample cases would not appear in Small dataset 1.\n\nIn Sample Case #1, we have enough training units to spend to give all cores a success probability of 1, so the AI will certainly function properly.\n\nIn Sample Case #2, both of the cores must function properly for the AI to function properly, so we must give each core at least some training units. The best option turns out to be to train each one up to $0.5$. Then the probability that the AI functions properly is $0.5 \\times 0.5 = 0.25$. Any other assignment is inferior; for instance, if we train one core to $0.9$ and the other core to $0.1$, the probability of success is only $0.9 \\times 0.1 = 0.09$.\n\nIn Sample Case #3, we have no training units to spend, and at least one of the two cores must function properly for the AI to function properly. We can approach this by first calculating the probability that the AI does not function properly, which happens only if both cores fail to function properly. The probability that both cores fail is $(1 - 0.9) \\times (1 - 0.8) = 0.02$. So the probability that at least one core functions properly, and thus that the AI functions properly, is $1 - 0.02 = 0.98$.\n\nIn Sample Case #4, the optimal strategy is to give all the training units to the second core. That makes the probability of at least one core functioning properly $1 - (0.4 \\times 0.6) = 0.76$. All other options are inferior; for example, giving all the training units to the first core only yields $0.75$, and dividing them equally among the cores gives $0.7525$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N \\leq 50$.\n- For all $i$, $0.0000 \\leq P_i \\leq 1.0000$.\n- $0.0000 \\leq U \\leq N - \\sum P_i$. (There will not be more training units than can be used.)\n\n**Small dataset 1 (15 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~20~~ 5 seconds.\n- $K = N$. (All of the cores must function properly for the AI to function properly.)\n\n**Small dataset 2 (28 Pts, Test Set 2 - Visible)**\n\n- Time limit: ~~40~~ 10 seconds.\n- $1 \\leq K \\leq N$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #1C] Core Training", "background": null, "description": "编写 Code Jam 题目很难，因此我们开发了一个 AI 来提出新点子。为了让 AI 尽可能有创造力，我们为它配备了 $N$ 个不同的“核心”，每个核心都有自己的“个性”。然而，就像人一样，这些核心可能会分心、损坏或拒绝工作；第 $i$ 个核心正常工作的概率为 $P_i$。只要至少有 $K$ 个核心正常工作，AI 就能正常运行。否则，它很可能会变得邪恶，把我们困在自己设计的恶魔谜题迷宫里。谁知道它会对 Code Jam 做些什么——也许会写出一堆难到爆炸的概率题！\n\n为了防止这种情况发生，我们计划训练一个或多个核心，使其更可靠。我们总共有 $U$ 个“训练单元”可以用来提升核心的可靠性。将 $X$ 个训练单元分配给第 $i$ 个核心，会使其成功概率增加 $X$。我们可以随意分配这些训练单元，也可以让一个或多个核心不分配任何训练单元。当然，核心的成功概率不能超过 $1$。\n\n如果我们以最大化 AI 正常运行概率的方式分配训练单元，这个概率是多少？", "inputFormat": "输入的第一行包含测试用例数 $T$。接下来有 $T$ 组测试数据，每组包含三行。第一行包含两个整数 $N$ 和 $K$，分别表示核心总数和 AI 正常运行所需的最少正常核心数。第二行包含一个有理数 $U$，表示训练单元的数量。第三行包含 $N$ 个有理数 $P_i$，第 $i$ 个数表示第 $i$ 个核心正常工作的概率。所有概率均精确到小数点后四位。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是在最优分配训练单元后 AI 正常运行的概率。如果 $y$ 与正确答案的绝对误差或相对误差不超过 $10^{-6}$，则视为正确。", "hint": "**样例解释**\n\n注意，最后两个样例不会出现在小数据集 1 中。\n\n在样例 1 中，我们有足够的训练单元，可以让所有核心的成功概率都变为 1，因此 AI 一定能正常运行。\n\n在样例 2 中，两个核心都必须正常工作，AI 才能正常运行，因此必须给每个核心分配一些训练单元。最优方案是将每个核心都训练到 $0.5$。此时 AI 正常运行的概率为 $0.5 \\times 0.5 = 0.25$。其他分配方式都不如这个好；比如把一个核心训练到 $0.9$，另一个训练到 $0.1$，成功概率只有 $0.9 \\times 0.1 = 0.09$。\n\n在样例 3 中，我们没有训练单元可用，且至少需要一个核心正常工作。可以先计算 AI 无法正常工作的概率，即所有核心都失效。两个核心都失效的概率为 $(1 - 0.9) \\times (1 - 0.8) = 0.02$。因此至少有一个核心正常工作的概率，即 AI 正常运行的概率为 $1 - 0.02 = 0.98$。\n\n在样例 4 中，最优策略是将所有训练单元都分配给第二个核心。这样至少有一个核心正常工作的概率为 $1 - (0.4 \\times 0.6) = 0.76$。其他分配方式都不如这个好；比如全部分配给第一个核心只得到 $0.75$，平均分配给两个核心得到 $0.7525$。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq N \\leq 50$。\n- 对所有 $i$，$0.0000 \\leq P_i \\leq 1.0000$。\n- $0.0000 \\leq U \\leq N - \\sum P_i$。（不会有多于可用的训练单元。）\n\n**小数据集 1（15 分，测试集 1 - 可见）**\n\n- 时间限制：5 秒。\n- $K = N$。（所有核心都必须正常工作，AI 才能正常运行。）\n\n**小数据集 2（28 分，测试集 2 - 可见）**\n\n- 时间限制：10 秒。\n- $1 \\leq K \\leq N$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13171", "type": "P", "difficulty": 3, "samples": [["3\n4 3\n4 5 6 4\n4 2\n4 5 6 4\n3 3\n1 1 1", "Case #1: 3\nCase #2: 4\nCase #3: 1"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "贪心", "2017", "Google Code Jam"], "title": "[GCJ 2017 #2] Fresh Chocolate", "background": "", "description": "You are the public relations manager for a chocolate manufacturer. Unfortunately, the company's image has suffered because customers think the owner is cheap and miserly. You hope to undo that impression by offering a free factory tour and chocolate tasting.\n\nSoon after starting the new project, you realized that the company owner's reputation is well-deserved: he only agreed to give away free chocolate if you would minimize the cost. The chocolate to be given away comes in packs of $P$ pieces. You would like to open new packs for each tour group, but the owner insists that if there are leftover pieces from one group, they must be used with the next tour group before opening up any new packs.\n\nFor instance, suppose that each pack contains $P=3$ pieces, and that a tour group with $5$ people comes. You will open two packs to give one piece to each person, and you will have one piece left over. Suppose that after that, another tour group with $6$ people comes. They will receive the leftover piece, and then you will open two more packs to finish giving them their samples, and so you will have one piece left over again. If two groups with $4$ people each come right after, the first of those will get the leftover piece plus a full pack, and the last $4$ person group will get their pieces from two newly opened packs. Notice that you cannot open new packs until all leftovers have been used up, even if you plan on using all of the newly opened pack immediately.\n\nIn the example above, $2$ out of the $4$ groups (the first and last groups) got all of their chocolate from freshly opened packs. The other $2$ groups got some fresh chocolate and some leftovers. You know that giving out leftovers is not the best way to undo the owner's miserly image, but you had to accept this system in order to get your cheap boss to agree to the project. Despite the unfavorable context, you are committed to doing a good job.\n\nYou have requests from $N$ groups, and each group has specified the number of people that will come into the factory. Groups will come in one at a time. You want to bring them in in an order that maximizes the number of groups that get only fresh chocolate and no leftovers. You cannot reject groups, nor have a group get chocolate more than once, and you need to give exactly one piece to each person in each group.\n\nIn the example above, if instead of $5, 6, 4, 4$, the order were $4, 5, 6, 4$, a total of $3$ groups (all but the $5$ person group) would get only fresh chocolate. For that set of groups, it is not possible to do better, as no arrangement would cause all groups to get only fresh chocolate.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case consists of two lines. The first line contains two integers $N$, the number of groups coming for a tour, and $P$, the number of pieces of chocolate per pack. The second line contains $N$ integers $G_1, G_2, \\dots, G_N$, the number of people in each of the groups.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of groups that will receive only fresh chocolate if you bring them in in an order that maximizes that number.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one explained in the statement. Besides the possible optimal order given above, other orders like $6, 5, 4, 4$ also maximize the number of groups with only fresh chocolate, although the groups that get the fresh chocolate are not necessarily the same. Notice that we only care about the number of groups that get the best experience, not the total number of people in them.\n\nIn Sample Case #2, the groups are the same as in Case #1, but the packs contain two pieces each. In this case, several ways of ordering them — for instance, $4, 4, 6, 5$ — make all groups get only fresh chocolate.\n\nIn Sample Case #3, all groups are single individuals, and they will all eat from the same pack. Of course, only the first one to come in is going to get a freshly opened pack.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N \\leq 100$.\n- $1 \\leq G_i \\leq 100$, for all $i$.\n\n**Small dataset (6 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~20~~ 5 seconds.\n- $2 \\leq P \\leq 3$.\n\n**Large dataset (10 Pts, Test Set 2 - Hidden)**\n\n- Time limit: ~~40~~ 10 seconds.\n- $2 \\leq P \\leq 4$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #2] Fresh Chocolate", "background": "", "description": "You are the public relations manager for a chocolate manufacturer. Unfortunately, the company's image has suffered because customers think the owner is cheap and miserly. You hope to undo that impression by offering a free factory tour and chocolate tasting.\n\nSoon after starting the new project, you realized that the company owner's reputation is well-deserved: he only agreed to give away free chocolate if you would minimize the cost. The chocolate to be given away comes in packs of $P$ pieces. You would like to open new packs for each tour group, but the owner insists that if there are leftover pieces from one group, they must be used with the next tour group before opening up any new packs.\n\nFor instance, suppose that each pack contains $P=3$ pieces, and that a tour group with $5$ people comes. You will open two packs to give one piece to each person, and you will have one piece left over. Suppose that after that, another tour group with $6$ people comes. They will receive the leftover piece, and then you will open two more packs to finish giving them their samples, and so you will have one piece left over again. If two groups with $4$ people each come right after, the first of those will get the leftover piece plus a full pack, and the last $4$ person group will get their pieces from two newly opened packs. Notice that you cannot open new packs until all leftovers have been used up, even if you plan on using all of the newly opened pack immediately.\n\nIn the example above, $2$ out of the $4$ groups (the first and last groups) got all of their chocolate from freshly opened packs. The other $2$ groups got some fresh chocolate and some leftovers. You know that giving out leftovers is not the best way to undo the owner's miserly image, but you had to accept this system in order to get your cheap boss to agree to the project. Despite the unfavorable context, you are committed to doing a good job.\n\nYou have requests from $N$ groups, and each group has specified the number of people that will come into the factory. Groups will come in one at a time. You want to bring them in in an order that maximizes the number of groups that get only fresh chocolate and no leftovers. You cannot reject groups, nor have a group get chocolate more than once, and you need to give exactly one piece to each person in each group.\n\nIn the example above, if instead of $5, 6, 4, 4$, the order were $4, 5, 6, 4$, a total of $3$ groups (all but the $5$ person group) would get only fresh chocolate. For that set of groups, it is not possible to do better, as no arrangement would cause all groups to get only fresh chocolate.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case consists of two lines. The first line contains two integers $N$, the number of groups coming for a tour, and $P$, the number of pieces of chocolate per pack. The second line contains $N$ integers $G_1, G_2, \\dots, G_N$, the number of people in each of the groups.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of groups that will receive only fresh chocolate if you bring them in in an order that maximizes that number.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one explained in the statement. Besides the possible optimal order given above, other orders like $6, 5, 4, 4$ also maximize the number of groups with only fresh chocolate, although the groups that get the fresh chocolate are not necessarily the same. Notice that we only care about the number of groups that get the best experience, not the total number of people in them.\n\nIn Sample Case #2, the groups are the same as in Case #1, but the packs contain two pieces each. In this case, several ways of ordering them — for instance, $4, 4, 6, 5$ — make all groups get only fresh chocolate.\n\nIn Sample Case #3, all groups are single individuals, and they will all eat from the same pack. Of course, only the first one to come in is going to get a freshly opened pack.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N \\leq 100$.\n- $1 \\leq G_i \\leq 100$, for all $i$.\n\n**Small dataset (6 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~20~~ 5 seconds.\n- $2 \\leq P \\leq 3$.\n\n**Large dataset (10 Pts, Test Set 2 - Hidden)**\n\n- Time limit: ~~40~~ 10 seconds.\n- $2 \\leq P \\leq 4$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #2] Fresh Chocolate", "background": null, "description": "你是一家巧克力制造商的公关经理。不幸的是，由于顾客认为老板吝啬小气，公司的形象受到了影响。你希望通过提供免费的工厂参观和巧克力品尝来扭转这种印象。\n\n然而，在新项目刚开始后，你就意识到老板的名声并非空穴来风：他只同意免费赠送巧克力，前提是你能将成本降到最低。要赠送的巧克力以每包 $P$ 块的形式提供。你本希望每个参观团都能打开新的一包，但老板坚持要求，如果上一组有剩余的巧克力，必须在为下一组服务前先用完这些剩余，之后才能打开新的一包。\n\n例如，假设每包有 $P=3$ 块巧克力，某一参观团有 $5$ 人。你需要打开两包巧克力，每人分到一块，还会剩下一块。假设接下来又有一组 $6$ 人的参观团到来，他们会先拿到那块剩余的巧克力，然后你再打开两包新巧克力，分给剩下的人，这样又会剩下一块。如果之后有两个 $4$ 人的参观团，第一个团会拿到剩余的一块加上一包新开的巧克力，最后一个 $4$ 人团则需要打开两包新巧克力。注意，即使你打算立刻用完新开的巧克力，也不能在用完所有剩余之前打开新的一包。\n\n在上述例子中，$4$ 个团中有 $2$ 个团（第一个和最后一个）拿到的都是新开的巧克力。其余 $2$ 个团则拿到了一部分新巧克力和一部分剩余巧克力。你知道发放剩余巧克力并不能改善老板吝啬的形象，但为了让老板同意这个项目，你不得不接受这个制度。尽管条件不利，你仍然致力于把工作做好。\n\n现在有 $N$ 个参观团提出了申请，每个团都说明了将有多少人来参观工厂。参观团会一个接一个到来。你希望安排他们的到场顺序，使得拿到全新巧克力（没有剩余巧克力）的团数最多。你不能拒绝任何团，也不能让同一个团多次领取巧克力，并且必须保证每个人都正好拿到一块巧克力。\n\n在上述例子中，如果顺序不是 $5, 6, 4, 4$，而是 $4, 5, 6, 4$，那么总共有 $3$ 个团（除了 $5$ 人团外）能拿到全新巧克力。对于这组团体来说，没有任何顺序能让所有团都只拿到新巧克力。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据包含两行。第一行包含两个整数 $N$（参观团数量）和 $P$（每包巧克力的块数）。第二行包含 $N$ 个整数 $G_1, G_2, \\dots, G_N$，分别表示每个团的人数。", "outputFormat": "对于每组测试数据，输出一行，格式为 `Case #x: y`，其中 $x$ 表示测试用例编号（从 1 开始），$y$ 表示在最优安排下，能拿到全新巧克力的团数。", "hint": "**样例解释**\n\n样例 1 即题目描述中的例子。除了上文给出的最优顺序外，像 $6, 5, 4, 4$ 这样的顺序也能使拿到全新巧克力的团数最大，尽管具体哪些团拿到新巧克力可能不同。注意，我们只关心拿到全新巧克力的团数，而不是这些团的人数总和。\n\n样例 2 中，团体和样例 1 相同，但每包有两块巧克力。在这种情况下，有多种顺序（如 $4, 4, 6, 5$）可以让所有团都拿到全新巧克力。\n\n样例 3 中，所有团都是单人团，他们都会从同一包巧克力中领取。当然，只有第一个人能拿到刚开封的巧克力。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq N \\leq 100$。\n- $1 \\leq G_i \\leq 100$，对所有 $i$。\n\n**小数据范围（6 分，测试点 1 - 可见）**\n\n- 时间限制：5 秒。\n- $2 \\leq P \\leq 3$。\n\n**大数据范围（10 分，测试点 2 - 隐藏）**\n\n- 时间限制：10 秒。\n- $2 \\leq P \\leq 4$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13172", "type": "P", "difficulty": 4, "samples": [["5\n2 2 2\n2 1\n2 2\n2 2 2\n1 1\n1 2\n2 2 2\n1 1\n2 1\n1000 1000 4\n3 2\n2 1\n3 3\n3 1\n3 3 5\n3 1\n2 2\n3 3\n2 2\n3 1", "Case #1: 1 1\nCase #2: 2 0\nCase #3: 2 0\nCase #4: 2 1\nCase #5: 2 1"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["数学", "贪心", "2017", "Google Code Jam"], "title": "[GCJ 2017 #2] Roller Coaster Scheduling", "background": "", "description": "You created a new roller coaster that is about to open. Its train consists of a single row of $N$ seats numbered $1$ through $N$ from front to back. Of course, seats closer to the front are more valuable. Customers have already purchased opening-day tickets. Each ticket allows a specific customer to take one ride on the coaster in a particular seat. Some customers may have bought more than one ticket, and they expect to go on one ride for each ticket.\n\nYou need to decide how many roller coaster rides there will be on opening day. On each ride, one customer can sit in each seat; some seats on a ride might be left empty. You cannot assign a customer to more than one seat in the same ride, nor can you put two customers on the same seat in any given ride.\n\nYou wish to minimize the number of rides required to honor all tickets, to reduce operational costs. To reduce the required number of rides, you can promote any number of tickets. Promoting a ticket means taking a customer's ticket and giving that customer a new ticket for a seat closer to the front of the train (that is, a seat with a lower number). You would prefer to promote as few tickets as possible, since too many promotions might cause customers to get greedy and ask for more promotions in the future.\n\nGiven the positions and buyers of all the tickets that have been sold, what is the minimum number of rides needed to honor all tickets, using as many promotions as needed and scheduling the rides optimally? And what is the minimum number of ticket promotions necessary to attain that number of rides? Note that promoting a given customer on a given ride from seat $4$ to seat $2$, for example, counts as only one promotion, not two separate ones.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a single line with three integers $N$, the number of seats in the roller coaster, $C$, the number of potential customers, and $M$, the number of tickets sold. The customers are identified with numbers between 1 and $C$. Then, $M$ lines follow, each containing two integers: $P_i$, the position in the roller coaster assigned to the $i$-th ticket, and $B_i$, the identifier of the buyer of that ticket.\n", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1), $y$ is the minimum number of rides you need to honor all tickets if you use the promotions and schedule the rides optimally, and $z$ is the minimum number of promotions you need to make be able to honor all tickets with $y$ rides.", "hint": "**Sample Explanation**\n\nNote that the last two sample cases would not appear in the Small dataset.\n\nIn Case #1, both customers purchased a ticket for position 2. It is impossible to honor both tickets with a single ride, but promoting either ticket to position 1 allows you to accommodate both tickets on the same round.\n\nCase #2 is a similar story, except both tickets are for position 1. Since you cannot promote those tickets or exchange them for inferior tickets, you are forced to run 2 separate rides, one per customer.\n\nCase #3 features the same customer purchasing both positions. Since you are forced to have 2 rides for that customer, there is no reason to give out any promotions.\n\nIn Case #4, notice that there may be both customers and positions with no tickets assigned. In this case, there are three tickets sold for position three. If you promote customer 2 to position 2, for instance, you can have one ride with customer 1 sitting in position 2 and customer 3 sitting in position 3, and a second ride with customer 2 in position 2 and customer 1 in position 3. Additional promotions will not allow you to decrease the number of rides, because customer 1 has two tickets and you need to honor those in different rides, regardless of position.\n\nIn Case #5, one optimal solution is to promote one of the $3\\ 1$ tickets to $1\\ 1$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq N \\leq 1000$.\n- $1 \\leq M \\leq 1000$.\n- $1 \\leq P_i \\leq N$.\n- $1 \\leq B_i \\leq C$.\n\n**Small dataset (7 Pts, Test Set 1 - Visible)**\n\n- $C = 2$.\n\n**Large dataset (14 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leq C \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #2] Roller Coaster Scheduling", "background": "", "description": "You created a new roller coaster that is about to open. Its train consists of a single row of $N$ seats numbered $1$ through $N$ from front to back. Of course, seats closer to the front are more valuable. Customers have already purchased opening-day tickets. Each ticket allows a specific customer to take one ride on the coaster in a particular seat. Some customers may have bought more than one ticket, and they expect to go on one ride for each ticket.\n\nYou need to decide how many roller coaster rides there will be on opening day. On each ride, one customer can sit in each seat; some seats on a ride might be left empty. You cannot assign a customer to more than one seat in the same ride, nor can you put two customers on the same seat in any given ride.\n\nYou wish to minimize the number of rides required to honor all tickets, to reduce operational costs. To reduce the required number of rides, you can promote any number of tickets. Promoting a ticket means taking a customer's ticket and giving that customer a new ticket for a seat closer to the front of the train (that is, a seat with a lower number). You would prefer to promote as few tickets as possible, since too many promotions might cause customers to get greedy and ask for more promotions in the future.\n\nGiven the positions and buyers of all the tickets that have been sold, what is the minimum number of rides needed to honor all tickets, using as many promotions as needed and scheduling the rides optimally? And what is the minimum number of ticket promotions necessary to attain that number of rides? Note that promoting a given customer on a given ride from seat $4$ to seat $2$, for example, counts as only one promotion, not two separate ones.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a single line with three integers $N$, the number of seats in the roller coaster, $C$, the number of potential customers, and $M$, the number of tickets sold. The customers are identified with numbers between 1 and $C$. Then, $M$ lines follow, each containing two integers: $P_i$, the position in the roller coaster assigned to the $i$-th ticket, and $B_i$, the identifier of the buyer of that ticket.\n", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1), $y$ is the minimum number of rides you need to honor all tickets if you use the promotions and schedule the rides optimally, and $z$ is the minimum number of promotions you need to make be able to honor all tickets with $y$ rides.", "hint": "**Sample Explanation**\n\nNote that the last two sample cases would not appear in the Small dataset.\n\nIn Case #1, both customers purchased a ticket for position 2. It is impossible to honor both tickets with a single ride, but promoting either ticket to position 1 allows you to accommodate both tickets on the same round.\n\nCase #2 is a similar story, except both tickets are for position 1. Since you cannot promote those tickets or exchange them for inferior tickets, you are forced to run 2 separate rides, one per customer.\n\nCase #3 features the same customer purchasing both positions. Since you are forced to have 2 rides for that customer, there is no reason to give out any promotions.\n\nIn Case #4, notice that there may be both customers and positions with no tickets assigned. In this case, there are three tickets sold for position three. If you promote customer 2 to position 2, for instance, you can have one ride with customer 1 sitting in position 2 and customer 3 sitting in position 3, and a second ride with customer 2 in position 2 and customer 1 in position 3. Additional promotions will not allow you to decrease the number of rides, because customer 1 has two tickets and you need to honor those in different rides, regardless of position.\n\nIn Case #5, one optimal solution is to promote one of the $3\\ 1$ tickets to $1\\ 1$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq N \\leq 1000$.\n- $1 \\leq M \\leq 1000$.\n- $1 \\leq P_i \\leq N$.\n- $1 \\leq B_i \\leq C$.\n\n**Small dataset (7 Pts, Test Set 1 - Visible)**\n\n- $C = 2$.\n\n**Large dataset (14 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leq C \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #2] Roller Coaster Scheduling", "background": null, "description": "你设计了一款即将开放的新过山车。它的列车由一排 $N$ 个座位组成，座位从前到后编号为 $1$ 到 $N$。显然，越靠前的座位越有价值。顾客们已经购买了开业当天的门票。每张门票允许特定顾客在特定座位上乘坐一次过山车。有些顾客可能购买了多张门票，他们期望每张门票都能乘坐一次。\n\n你需要决定开业当天需要安排多少次过山车运行。每次运行时，每个座位只能坐一位顾客；某些座位可以空着。你不能让同一位顾客在同一次运行中占据多个座位，也不能让两位顾客在同一次运行中坐在同一个座位上。\n\n你希望通过合理安排，最小化所需的运行次数以满足所有门票。为了减少所需的运行次数，你可以对任意数量的门票进行“晋升”。晋升一张门票意味着将某位顾客的门票换成编号更小（即更靠前）的座位。你希望晋升的门票数量尽可能少，因为晋升太多可能会让顾客变得贪心，今后要求更多晋升。\n\n给定所有已售门票的座位和购买者信息，请你计算：在可以任意晋升门票并最优安排运行的情况下，满足所有门票所需的最少运行次数是多少？以及达到该最少运行次数所需的最少晋升次数是多少？注意，对于同一位顾客在同一次运行中将座位从 $4$ 晋升到 $2$，只算作一次晋升，而不是两次。", "inputFormat": "输入的第一行包含一个整数 $T$，表示测试用例的数量。接下来有 $T$ 组测试数据。每组测试数据的第一行包含三个整数：$N$（过山车的座位数）、$C$（潜在顾客数）和 $M$（已售门票数）。顾客编号为 $1$ 到 $C$。接下来的 $M$ 行，每行包含两个整数：$P_i$ 表示第 $i$ 张门票对应的座位编号，$B_i$ 表示购买该门票的顾客编号。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y z`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是在允许晋升并最优安排运行的情况下满足所有门票所需的最少运行次数，$z$ 是达到该最少运行次数所需的最少晋升次数。", "hint": "**样例解释**\n\n注意，最后两个样例不会出现在 Small 数据集。\n\n在第 1 个样例中，两位顾客都购买了第 2 号座位的门票。无法在一次运行中满足两张门票，但如果将其中一张晋升到第 1 号座位，就可以在同一轮中安排两位顾客。\n\n第 2 个样例类似，只不过两张门票都是第 1 号座位。由于无法再晋升，也无法交换到更差的座位，因此只能安排两次运行，每位顾客各一次。\n\n第 3 个样例中，同一位顾客购买了两个座位。由于必须为该顾客安排两次运行，因此无需进行任何晋升。\n\n第 4 个样例中，注意可能存在没有门票的顾客和座位。本例中，第 3 号座位卖出了三张门票。如果将顾客 2 晋升到第 2 号座位，例如，可以安排一次运行：顾客 1 坐第 2 号座位，顾客 3 坐第 3 号座位；再安排一次运行：顾客 2 坐第 2 号座位，顾客 1 坐第 3 号座位。即使再晋升，也无法减少运行次数，因为顾客 1 有两张门票，必须分两次运行，无论座位如何。\n\n第 5 个样例中，一种最优方案是将其中一张 $3\\ 1$ 门票晋升到 $1\\ 1$。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $2 \\leq N \\leq 1000$。\n- $1 \\leq M \\leq 1000$。\n- $1 \\leq P_i \\leq N$。\n- $1 \\leq B_i \\leq C$。\n\n**Small 数据集（7 分，测试点 1 - 可见）**\n\n- $C = 2$。\n\n**Large 数据集（14 分，测试点 2 - 隐藏）**\n\n- $2 \\leq C \\leq 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13173", "type": "P", "difficulty": 6, "samples": [["5\n1 3\n-.-\n3 4\n#.##\n#--#\n####\n2 2\n-.\n#|\n4 3\n.|.\n-//\n.-.\n#\\/\n3 3\n/|\\\n\\\\/\n./#", "Case #1: IMPOSSIBLE\nCase #2: POSSIBLE\n#.##\n#||#\n####\nCase #3: POSSIBLE\n|.\n#|\nCase #4: POSSIBLE\n.-.\n|//\n.|.\n#\\/\nCase #5: IMPOSSIBLE"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["2017", "Special Judge", "2-SAT", "Google Code Jam"], "title": "[GCJ 2017 #2] Beaming With Joy", "background": "", "description": "Joy is about to go on a long vacation, so she has hired technicians to install a security system based on infrared laser beams. The technicians have given her a diagram that represents her house as a grid of unit cells with $R$ rows and $C$ columns. Each cell in this grid contains one of the following:\n\n* `/`: A two-sided mirror that runs from the cell's lower left corner to its upper right corner.\n* `\\`: A two-sided mirror that runs from the cell's upper left corner to its lower right corner.\n* `-`: A beam shooter that shoots horizontal beams out into the cells (if any) to the immediate left and right of this cell.\n* `|`: A beam shooter that shoots vertical beams out into the cells (if any) immediately above and below this cell.\n* `#`: A wall. (Note that the house is not necessarily surrounded by a border of walls; this is one reason why Joy needs a security system!)\n* `.`: Nothing; the cell is empty.\n\nBeams travel in straight lines and continue on through empty cells. When a beam hits a mirror, it bounces 90 degrees off the mirror's surface and continues. When a beam traveling to the right hits a `/` mirror, it bounces off the mirror and starts traveling up; beams traveling up, left, or down that hit a `/` mirror bounce off and travel right, down, or left, respectively. The `\\` mirror behaves similarly: when a beam traveling right, up, left or down hits it, it bounces off and starts traveling down, left, up or right, respectively. When a beam hits a wall or goes out of the bounds of the grid, it stops. It is fine for beams to cross other beams, but if a beam hits any beam shooter (including, perhaps, the beam shooter that originated the beam), that beam shooter will be destroyed!\n\nJoy wants to make sure that every empty cell in the house has at least one beam passing through it, and that no beam shooters are destroyed, since that would just be wasting money! Unfortunately, the technicians have already installed the system, so the most Joy can do is rotate some of the existing beam shooters 90 degrees. That is, for any number (including zero) of beam shooters, she can turn `-` into `|` or vice versa.\n\nCan you find any way for Joy to achieve her goal, or determine that it is impossible? Note that it is not required to minimize the number of rotations of beam shooters.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with one line with two integers $R$ and $C$: the number of rows and columns in the grid representing the house. Then, $R$ lines of $C$ characters each follow; each character is `/, \\, -, |, #`, or `.`, as described in the statement.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if Joy cannot accomplish her goal, or POSSIBLE if she can. Then, if the case is possible, output the same $R$ lines of $C$ characters each from the input grid, with zero or more instances of - replaced by | or vice versa.\n\nIf there are multiple possible answers, you may output any of them.", "hint": "**Sample Explanation**\n\nNote that the last 2 sample cases would not appear in the Small dataset.\n\nIn Sample Case #1, if a beam shooter is positioned to shoot its beam into the empty cell, it will necessarily destroy the other beam shooter. So the case is IMPOSSIBLE.\n\nIn Sample Case #2, the leftmost beam shooter must be rotated to cover the empty cell. The rightmost beam shooter must also be rotated to avoid destroying the leftmost beam shooter.\n\nIn Sample Case #3, the existing beam shooters already cover all empty cells with their beams and do not destroy each other, so outputting the grid from the input would be acceptable. However, notice that the output that we have given is also correct.\n\nIn Sample Case #4, one acceptable solution is to rotate all three of the beam shooters. However, note that the following would also be acceptable:\n```\n.-.\n|//\n.-.\n#\\/\n```\nsince it is not necessary for cells with mirrors to have a beam pass through them. (Who would steal giant diagonal mirrors, anyway?)\n\nIn Sample Case #5, the beam shooter would destroy itself no matter which orientation Joy chooses for it, so the case is IMPOSSIBLE.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq C \\leq 50$.\n- Each character in the grid is one of `/, \\, -, |, #`, or `.`.\n- The number of `-` characters plus the number of `|` characters (that is, the number of beam shooters) in the grid is between $1$ and $100$, inclusive.\n- There is at least $1$ `.` character (that is, empty space) in the grid.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- $1 \\leq R \\leq 5$.\n- There are no `/` or `\\` characters (that is, no mirrors) in the grid.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- $1 \\leq R \\leq 50$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #2] Beaming With Joy", "background": "", "description": "Joy is about to go on a long vacation, so she has hired technicians to install a security system based on infrared laser beams. The technicians have given her a diagram that represents her house as a grid of unit cells with $R$ rows and $C$ columns. Each cell in this grid contains one of the following:\n\n* `/`: A two-sided mirror that runs from the cell's lower left corner to its upper right corner.\n* `\\`: A two-sided mirror that runs from the cell's upper left corner to its lower right corner.\n* `-`: A beam shooter that shoots horizontal beams out into the cells (if any) to the immediate left and right of this cell.\n* `|`: A beam shooter that shoots vertical beams out into the cells (if any) immediately above and below this cell.\n* `#`: A wall. (Note that the house is not necessarily surrounded by a border of walls; this is one reason why Joy needs a security system!)\n* `.`: Nothing; the cell is empty.\n\nBeams travel in straight lines and continue on through empty cells. When a beam hits a mirror, it bounces 90 degrees off the mirror's surface and continues. When a beam traveling to the right hits a `/` mirror, it bounces off the mirror and starts traveling up; beams traveling up, left, or down that hit a `/` mirror bounce off and travel right, down, or left, respectively. The `\\` mirror behaves similarly: when a beam traveling right, up, left or down hits it, it bounces off and starts traveling down, left, up or right, respectively. When a beam hits a wall or goes out of the bounds of the grid, it stops. It is fine for beams to cross other beams, but if a beam hits any beam shooter (including, perhaps, the beam shooter that originated the beam), that beam shooter will be destroyed!\n\nJoy wants to make sure that every empty cell in the house has at least one beam passing through it, and that no beam shooters are destroyed, since that would just be wasting money! Unfortunately, the technicians have already installed the system, so the most Joy can do is rotate some of the existing beam shooters 90 degrees. That is, for any number (including zero) of beam shooters, she can turn `-` into `|` or vice versa.\n\nCan you find any way for Joy to achieve her goal, or determine that it is impossible? Note that it is not required to minimize the number of rotations of beam shooters.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with one line with two integers $R$ and $C$: the number of rows and columns in the grid representing the house. Then, $R$ lines of $C$ characters each follow; each character is `/, \\, -, |, #`, or `.`, as described in the statement.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if Joy cannot accomplish her goal, or POSSIBLE if she can. Then, if the case is possible, output the same $R$ lines of $C$ characters each from the input grid, with zero or more instances of - replaced by | or vice versa.\n\nIf there are multiple possible answers, you may output any of them.", "hint": "**Sample Explanation**\n\nNote that the last 2 sample cases would not appear in the Small dataset.\n\nIn Sample Case #1, if a beam shooter is positioned to shoot its beam into the empty cell, it will necessarily destroy the other beam shooter. So the case is IMPOSSIBLE.\n\nIn Sample Case #2, the leftmost beam shooter must be rotated to cover the empty cell. The rightmost beam shooter must also be rotated to avoid destroying the leftmost beam shooter.\n\nIn Sample Case #3, the existing beam shooters already cover all empty cells with their beams and do not destroy each other, so outputting the grid from the input would be acceptable. However, notice that the output that we have given is also correct.\n\nIn Sample Case #4, one acceptable solution is to rotate all three of the beam shooters. However, note that the following would also be acceptable:\n```\n.-.\n|//\n.-.\n#\\/\n```\nsince it is not necessary for cells with mirrors to have a beam pass through them. (Who would steal giant diagonal mirrors, anyway?)\n\nIn Sample Case #5, the beam shooter would destroy itself no matter which orientation Joy chooses for it, so the case is IMPOSSIBLE.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq C \\leq 50$.\n- Each character in the grid is one of `/, \\, -, |, #`, or `.`.\n- The number of `-` characters plus the number of `|` characters (that is, the number of beam shooters) in the grid is between $1$ and $100$, inclusive.\n- There is at least $1$ `.` character (that is, empty space) in the grid.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- $1 \\leq R \\leq 5$.\n- There are no `/` or `\\` characters (that is, no mirrors) in the grid.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- $1 \\leq R \\leq 50$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #2] Beaming With Joy", "background": null, "description": "Joy 即将去度长假，因此她雇佣了技术人员为她安装一个基于红外激光束的安防系统。技术人员给了她一张图纸，将她的房子表示为一个 $R$ 行 $C$ 列的单元格网格。每个单元格包含以下之一：\n\n- `/`：一面双面镜，从单元格的左下角延伸到右上角。\n- `\\`：一面双面镜，从单元格的左上角延伸到右下角。\n- `-`：一个水平激光发射器，会向该单元格左右相邻的单元格（如果有）发射水平激光束。\n- `|`：一个垂直激光发射器，会向该单元格上下相邻的单元格（如果有）发射垂直激光束。\n- `#`：一面墙。（注意，房子不一定被墙包围，这也是 Joy 需要安防系统的原因之一！）\n- `.`：空单元格，什么都没有。\n\n激光束会沿直线传播，并穿过空单元格。当激光束遇到镜子时，会以 90 度角反射并继续传播。当向右传播的激光束遇到 `/` 镜子时，会反射并向上传播；而向上、向左或向下传播的激光束遇到 `/` 镜子时，会分别反射并向右、向下或向左传播。`\\` 镜子的反射方式类似：当激光束向右、上、左或下传播时遇到它，会分别反射并向下、向左、向上或向右传播。当激光束遇到墙壁或超出网格边界时，会停止传播。激光束可以与其他激光束交叉，但如果激光束击中任何激光发射器（包括可能是发射该激光束的发射器本身），该激光发射器会被摧毁！\n\nJoy 希望确保房子里的每个空单元格都至少有一束激光通过，并且没有任何激光发射器被摧毁，否则就浪费钱了！不幸的是，技术人员已经安装好了系统，所以 Joy 现在最多只能将一些现有的激光发射器旋转 90 度，也就是说，可以将任意数量（包括 0 个）的 `-` 改为 `|`，或将 `|` 改为 `-`。\n\n你能帮 Joy 判断是否有办法达成她的目标，或者判断是否不可能实现吗？注意，不要求最小化旋转激光发射器的数量。", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试数据。每组数据的第一行为两个整数 $R$ 和 $C$，表示房子的网格有 $R$ 行 $C$ 列。接下来 $R$ 行，每行 $C$ 个字符，字符为 `/`、`\\`、`-`、`|`、`#` 或 `.`，含义如题目描述所述。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 为 IMPOSSIBLE（如果 Joy 无法达成目标）或 POSSIBLE（如果可以达成目标）。如果可能，请在接下来的 $R$ 行输出修改后的网格（与输入格式相同），其中可以有若干 `-` 被替换为 `|` 或反之。\n\n如果有多种可行解，输出任意一种即可。", "hint": "**样例解释**\n\n注意，最后两个样例不会出现在 Small 数据集中。\n\n在样例 1 中，如果一个激光发射器被设置为发射激光覆盖空单元格，则必然会摧毁另一个激光发射器。因此该情况为 IMPOSSIBLE。\n\n在样例 2 中，最左侧的激光发射器必须旋转以覆盖空单元格。最右侧的激光发射器也必须旋转，以避免摧毁最左侧的激光发射器。\n\n在样例 3 中，现有的激光发射器已经覆盖了所有空单元格且不会互相摧毁，因此直接输出输入网格即可。当然，给出的输出也是正确的。\n\n在样例 4 中，一种可行解是将三个激光发射器全部旋转。不过，以下解也是可行的：\n```\n.-.\n|//\n.-.\n#\\/\n```\n因为镜子所在的单元格不需要有激光通过。（毕竟没人会偷巨大的斜面镜子，对吧？）\n\n在样例 5 中，无论激光发射器如何旋转，都会自我摧毁，因此该情况为 IMPOSSIBLE。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq C \\leq 50$。\n- 网格中的每个字符为 `/`、`\\`、`-`、`|`、`#` 或 `.`。\n- 网格中 `-` 和 `|`（即激光发射器）的总数在 $1$ 到 $100$ 之间。\n- 至少有 $1$ 个 `.`（即空单元格）。\n\n**小数据集（测试集 1 - 可见）**\n\n- $1 \\leq R \\leq 5$。\n- 网格中没有 `/` 或 `\\`（即没有镜子）。\n\n**大数据集（测试集 2 - 隐藏）**\n\n- $1 \\leq R \\leq 50$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13174", "type": "P", "difficulty": 6, "samples": [["4\n2 2 1\n#S\nT.\n2 6 4\n.T\n.T\n.T\nS#\nS#\nS#\n5 5 4\n.....\nSS#.T\nSS#TT\nSS#.T\n.....\n3 3 8\nS.#\n.#.\n#.T", "Case #1: 1\n1 1\nCase #2: 3\n3 3\n1 1\n2 2\nCase #3: 3\n1 2\n2 1\n6 3\nCase #4: 0"]], "limits": {"time": [7500, 15000], "memory": [524288, 524288]}, "tags": ["2017", "Special Judge", "广度优先搜索 BFS", "二分图", "Google Code Jam"], "title": "[GCJ 2017 #2] Shoot the Turrets", "background": "", "description": "The fight to free the city from extraterrestrial invaders is over! People are happy that love and peace have returned.\n\nThe city is represented as a grid with $R$ rows and $C$ columns. Some cells on the grid are buildings (through which nobody can see, nobody can shoot, and nobody can walk), and some are streets (through which everybody can see, shoot and walk). Unfortunately, during the war, the now-defeated invaders set up automatic security turrets in the city. These turrets are only in streets (not in buildings). They pose a threat to the citizens, but fortunately, there are also some soldiers on the streets (not in buildings). Initially, no soldier is in the same place as a turret.\n\nThe invader turrets do not move. They are small, so they don't block sight and shooting. A soldier cannot walk through an active turret's cell, but can walk through it once it is destroyed. A turret can only see soldiers in the cells for which it has a horizontal or vertical line of sight. If a soldier enters such a cell, the turret does not fire. If a soldier attempts to exit such a cell (after entering it, or after starting in that cell), the turret fires. Luckily, a soldier can still shoot from that cell, and the turret will not detect that as movement. It means that none of your soldiers will actually die, because in the worst case they can always wait, motionless, for help (perhaps for a long time). Maybe you will have a chance to rescue them later.\n\nEach soldier can make a total of $M$ unit moves. Each of these moves must be one cell in a horizontal or vertical direction. Soldiers can walk through each other and do not block the lines of sight of other soldiers or turrets. Each soldier also has one bullet. If a soldier has a turret in her horizontal or vertical line of sight, the soldier can shoot and destroy it. Each shot can only destroy one turret, but the soldiers are such excellent shooters that they can even shoot past one or several turrets or soldiers in their line of sight and hit another turret farther away!\n\nYou are given a map (with the soldier and turret positions marked). What is the largest number of turrets that the soldiers can destroy?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing the integer $C$ (the width of the map), $R$ (the height of the map) and $M$ (the number of unit moves each soldier can make). The next $R$ lines contain $C$ characters each, with . representing a street, # representing a building, S representing a soldier and T representing a turret.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of turrets that it is possible to destroy. Then $y$ lines should follow: each should contain two integers $s_i$ and $t_i$ denoting that the $i$th thing that happens should be soldier $s_i$ destroying turret $t_i$ (you don't need to specify exactly how the soldier has to move). If multiple valid strategies exist, you may output any one of them.\n\nSoldiers are numbered from 1, reading from left to right along the top row, then left to right along the next row down from the top, and so on, from top to bottom.", "hint": "**Sample Explanation**\n\nIn Case #2, one of the possible solutions is to move soldier $3$ up three cells and shoot turret $3$. Then soldier $1$ can move up one cell and right one cell (to where turret $3$ was) and shoot past turret $2$ to destroy turret $1$. Finally, soldier $2$ can move up three cells and shoot turret $2$.\n\nIn Case #3, soldier $1$ can move up one cell, then right three cells and shoot turret $2$. Then soldier $2$ can move up one cell, then right three cells and shoot turret $1$. Finally, soldier $6$ can move down one cell, then right three cells and shoot turret $3$. Other soldiers have insufficient move range to shoot any other turrets.\n\nIn Case #4, the soldier cannot move to within the same row or column as the turret, so the turret cannot be destroyed.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $0 \\leq M < C \\times R$.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- Time limit: ~~30~~ 7.5 seconds.\n- $1 \\leq C \\leq 30$.\n- $1 \\leq R \\leq 30$.\n- The number of S symbols is between $1$ and $10$.\n- The number of T symbols is between $1$ and $10$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $1 \\leq C \\leq 100$.\n- $1 \\leq R \\leq 100$.\n- The number of S symbols is between $1$ and $100$.\n- The number of T symbols is between $1$ and $100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #2] Shoot the Turrets", "background": "", "description": "The fight to free the city from extraterrestrial invaders is over! People are happy that love and peace have returned.\n\nThe city is represented as a grid with $R$ rows and $C$ columns. Some cells on the grid are buildings (through which nobody can see, nobody can shoot, and nobody can walk), and some are streets (through which everybody can see, shoot and walk). Unfortunately, during the war, the now-defeated invaders set up automatic security turrets in the city. These turrets are only in streets (not in buildings). They pose a threat to the citizens, but fortunately, there are also some soldiers on the streets (not in buildings). Initially, no soldier is in the same place as a turret.\n\nThe invader turrets do not move. They are small, so they don't block sight and shooting. A soldier cannot walk through an active turret's cell, but can walk through it once it is destroyed. A turret can only see soldiers in the cells for which it has a horizontal or vertical line of sight. If a soldier enters such a cell, the turret does not fire. If a soldier attempts to exit such a cell (after entering it, or after starting in that cell), the turret fires. Luckily, a soldier can still shoot from that cell, and the turret will not detect that as movement. It means that none of your soldiers will actually die, because in the worst case they can always wait, motionless, for help (perhaps for a long time). Maybe you will have a chance to rescue them later.\n\nEach soldier can make a total of $M$ unit moves. Each of these moves must be one cell in a horizontal or vertical direction. Soldiers can walk through each other and do not block the lines of sight of other soldiers or turrets. Each soldier also has one bullet. If a soldier has a turret in her horizontal or vertical line of sight, the soldier can shoot and destroy it. Each shot can only destroy one turret, but the soldiers are such excellent shooters that they can even shoot past one or several turrets or soldiers in their line of sight and hit another turret farther away!\n\nYou are given a map (with the soldier and turret positions marked). What is the largest number of turrets that the soldiers can destroy?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing the integer $C$ (the width of the map), $R$ (the height of the map) and $M$ (the number of unit moves each soldier can make). The next $R$ lines contain $C$ characters each, with . representing a street, # representing a building, S representing a soldier and T representing a turret.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of turrets that it is possible to destroy. Then $y$ lines should follow: each should contain two integers $s_i$ and $t_i$ denoting that the $i$th thing that happens should be soldier $s_i$ destroying turret $t_i$ (you don't need to specify exactly how the soldier has to move). If multiple valid strategies exist, you may output any one of them.\n\nSoldiers are numbered from 1, reading from left to right along the top row, then left to right along the next row down from the top, and so on, from top to bottom.", "hint": "**Sample Explanation**\n\nIn Case #2, one of the possible solutions is to move soldier $3$ up three cells and shoot turret $3$. Then soldier $1$ can move up one cell and right one cell (to where turret $3$ was) and shoot past turret $2$ to destroy turret $1$. Finally, soldier $2$ can move up three cells and shoot turret $2$.\n\nIn Case #3, soldier $1$ can move up one cell, then right three cells and shoot turret $2$. Then soldier $2$ can move up one cell, then right three cells and shoot turret $1$. Finally, soldier $6$ can move down one cell, then right three cells and shoot turret $3$. Other soldiers have insufficient move range to shoot any other turrets.\n\nIn Case #4, the soldier cannot move to within the same row or column as the turret, so the turret cannot be destroyed.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $0 \\leq M < C \\times R$.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- Time limit: ~~30~~ 7.5 seconds.\n- $1 \\leq C \\leq 30$.\n- $1 \\leq R \\leq 30$.\n- The number of S symbols is between $1$ and $10$.\n- The number of T symbols is between $1$ and $10$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $1 \\leq C \\leq 100$.\n- $1 \\leq R \\leq 100$.\n- The number of S symbols is between $1$ and $100$.\n- The number of T symbols is between $1$ and $100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #2] Shoot the Turrets", "background": null, "description": "解放城市摆脱外星入侵者的战斗已经结束！人们为爱与和平的回归而欢欣鼓舞。\n\n城市被表示为一个有 $R$ 行 $C$ 列的网格。网格上的某些格子是建筑物（无法看见、无法射击、无法行走），其余格子是街道（可以看见、可以射击、可以行走）。不幸的是，在战争期间，已经被击败的入侵者在城市中设置了自动安保炮台。这些炮台只会出现在街道上（不会在建筑物中）。它们对市民构成威胁，但幸运的是，街道上也有一些士兵（同样不会在建筑物中）。最初，没有任何士兵与炮台处于同一格子。\n\n入侵者的炮台不会移动。它们体积很小，不会阻挡视线和射击。士兵无法穿过一个激活状态的炮台所在的格子，但炮台被摧毁后可以通过。炮台只能看到与自己处于同一行或同一列的士兵。如果士兵进入这样的格子，炮台不会开火；但如果士兵试图离开这样的格子（无论是进入后还是一开始就在该格子），炮台就会开火。幸运的是，士兵仍然可以在该格子射击，炮台不会因为射击而发现士兵的移动。这意味着你的士兵实际上不会阵亡，因为在最坏的情况下，他们总可以静止等待救援（也许会等很久）。或许你以后还有机会去救他们。\n\n每个士兵最多可以进行 $M$ 次单位移动。每次移动只能向上下左右四个方向之一移动一个格子。士兵可以相互穿越，并且不会阻挡其他士兵或炮台的视线。每个士兵还有一颗子弹。如果士兵与某个炮台处于同一行或同一列，并且中间没有建筑物阻挡，则可以射击并摧毁该炮台。每次射击只能摧毁一个炮台，但士兵射击技术高超，即使有一个或多个炮台或士兵在射击路径上，也能击中更远处的炮台！\n\n你将获得一张标记了士兵和炮台位置的地图。请问士兵们最多能摧毁多少个炮台？", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为三个整数 $C$（地图宽度）、$R$（地图高度）和 $M$（每个士兵可移动的单位步数）。接下来的 $R$ 行每行包含 $C$ 个字符，`.` 表示街道，`#` 表示建筑物，`S` 表示士兵，`T` 表示炮台。", "outputFormat": "对于每组测试数据，输出一行 `Case #x: y`，其中 $x$ 表示测试用例编号（从 1 开始），$y$ 表示最多可以被摧毁的炮台数量。接下来输出 $y$ 行，每行两个整数 $s_i$ 和 $t_i$，表示第 $i$ 个事件是编号为 $s_i$ 的士兵摧毁编号为 $t_i$ 的炮台（不需要具体说明士兵如何移动）。\n\n士兵的编号从 1 开始，按照从上到下、每行从左到右的顺序编号。炮台的编号同理。", "hint": "**样例解释**\n\n在第 2 组样例中，一种可行的方案是让第 3 号士兵向上移动三格并射击第 3 号炮台。然后第 1 号士兵向上移动一格再向右移动一格（到达第 3 号炮台原本的位置），并穿过第 2 号炮台射击摧毁第 1 号炮台。最后第 2 号士兵向上移动三格并射击第 2 号炮台。\n\n在第 3 组样例中，第 1 号士兵可以向上移动一格，然后向右移动三格并射击第 2 号炮台。第 2 号士兵可以向上移动一格，然后向右移动三格并射击第 1 号炮台。最后第 6 号士兵可以向下移动一格，然后向右移动三格并射击第 3 号炮台。其他士兵的移动步数不足以射击其他炮台。\n\n在第 4 组样例中，士兵无法移动到与炮台同一行或同一列，因此无法摧毁炮台。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $0 \\leq M < C \\times R$。\n\n**小数据集（测试集 1 - 可见）**\n\n- 时间限制：7.5 秒。\n- $1 \\leq C \\leq 30$。\n- $1 \\leq R \\leq 30$。\n- $S$ 的数量在 $1$ 到 $10$ 之间。\n- $T$ 的数量在 $1$ 到 $10$ 之间。\n\n**大数据集（测试集 2 - 隐藏）**\n\n- 时间限制：15 秒。\n- $1 \\leq C \\leq 100$。\n- $1 \\leq R \\leq 100$。\n- $S$ 的数量在 $1$ 到 $100$ 之间。\n- $T$ 的数量在 $1$ 到 $100$ 之间。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
