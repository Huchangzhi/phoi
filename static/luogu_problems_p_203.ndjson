{"pid": "P5106", "type": "P", "difficulty": 6, "samples": [["2 2", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": [], "title": "dkw的lcm", "background": "", "description": "**特别地，一个数的lcm是自身**\n\n善良的dkw决定直接告诉你题面：\n$$\\prod_{i_1=1}^n\\prod_{i_2=1}^n …\\prod_{i_k=1}^n \\varphi\\big(lcm(i_1,i_2,…,i_k)\\big)$$\n请你求上述式子，答案对 $10^9+7$ 取模。\n\n其中 $lcm(i_1,i_2,...,i_k)$ 代表这 $k$ 个数的最小公倍数。\n\n其中 $\\varphi$ 代表欧拉函数，不知道的可以问度娘。\n\n其中 $\\prod$ 代表连乘符号，简单来说就是 $\\sum$ 的乘法版。", "inputFormat": "两个正整数，$n,k$", "outputFormat": "一个非负整数，代表式子的值对 $10^9+7$ 取模的结果。", "hint": "对于 50% 的数据，$1\\le n,k\\le 8$\n\n对于 100% 的数据，$1\\le n,k\\le 10^6$", "locale": "zh-CN", "translations": {"en": {"title": "dkw's LCM.", "background": "", "description": "In particular, the LCM of a single number is the number itself.\n\nKind dkw decides to tell you the statement directly:\n$$\\prod_{i_1=1}^n\\prod_{i_2=1}^n …\\prod_{i_k=1}^n \\varphi\\big(lcm(i_1,i_2,…,i_k)\\big)$$\nPlease compute the expression above, and output the answer modulo $10^9+7$.\n\nHere, $lcm(i_1,i_2,...,i_k)$ denotes the least common multiple of these $k$ numbers.\n\nHere, $\\varphi$ denotes Euler's totient function.\n\nHere, $\\prod$ denotes the product symbol, which is the multiplicative version of $\\sum$.", "inputFormat": "Two positive integers, $n,k$.", "outputFormat": "One non-negative integer, representing the value of the expression modulo $10^9+7$.", "hint": "For 50% of the testdata, $1\\le n,k\\le 8$.\n\nFor 100% of the testdata, $1\\le n,k\\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "dkw的lcm", "background": "", "description": "**特别地，一个数的lcm是自身**\n\n善良的dkw决定直接告诉你题面：\n$$\\prod_{i_1=1}^n\\prod_{i_2=1}^n …\\prod_{i_k=1}^n \\varphi\\big(lcm(i_1,i_2,…,i_k)\\big)$$\n请你求上述式子，答案对 $10^9+7$ 取模。\n\n其中 $lcm(i_1,i_2,...,i_k)$ 代表这 $k$ 个数的最小公倍数。\n\n其中 $\\varphi$ 代表欧拉函数，不知道的可以问度娘。\n\n其中 $\\prod$ 代表连乘符号，简单来说就是 $\\sum$ 的乘法版。", "inputFormat": "两个正整数，$n,k$", "outputFormat": "一个非负整数，代表式子的值对 $10^9+7$ 取模的结果。", "hint": "对于 50% 的数据，$1\\le n,k\\le 8$\n\n对于 100% 的数据，$1\\le n,k\\le 10^6$", "locale": "zh-CN"}}}
{"pid": "P5107", "type": "P", "difficulty": 5, "samples": [["5 10 3\n4 5 3 2 7 \n4 1\n1 4\n2 1\n3 2\n1 2\n5 1\n2 4\n2 1\n2 4\n1 4\n1\n2\n3\n", "15\n548614965\n80769513\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["O2优化"], "title": "能量采集", "background": "", "description": "**题面已修改，请大家注意。**\n\n请你求下列式子：$\\sum_{i=1}^N\\sum_{j=1}^Ngcd(i,j)$ ，答案对大质数取模。\n\n不好意思读错剧本了。\n\n给定一个 $n$ 个点 $m$ 条边的有向图，每个点有初始能量 $a_i$ 。\n\n每过一秒，每个点的能量便会等量地流向所有出边，另外，会有一份流向自己（你可以当做有一个自环）。\n\n现在 $dkw$ 有 $q$ 次询问，每次询问会给你一个时间 $t$ ，$dkw$想知道 $t$ 秒时每个点的能量。\n\n不保证图中没有重边和自环，答案对$998244353$取模。", "inputFormat": "第一行包含三个整数，$n,m,q$ 。\n\n第二行包含$n$个整数，从$a_1$到$a_n$ ，代表初始能量。\n\n接下来 $m$ 行，每行包含两个正整数 $x_i,y_i$ ，代表一条有向边，从 $x_i$ 指向 $y_i$ ，我们约定点编号从 $1$ 到 $n$ 。\n\n接下来 $q$ 行，每行包含一个正整数 $t$ ，代表一次询问。", "outputFormat": "为了防止输出过大，对于每个询问你只需要输出一行一个非负整数，代表 $n$ 个点的能量（取模）的异或和对$998244353$取模的结果。 ", "hint": "对于 30% 的数据，$1\\le t \\le 50$\n\n对于 60% 的数据，$1\\le q\\le 50$\n\n对于 80% 的数据，$1\\le q\\le 1000$\n\n对于 100% 的数据，$1\\le n\\le 50,1\\le m\\le n\\times (n-1),1\\le q\\le 5\\times 10^4,0< a_i< 998244353,1\\le t\\le 10^9$", "locale": "zh-CN", "translations": {"en": {"title": "Energy Harvesting", "background": "", "description": "**The statement has been modified. Please pay attention.**\n\nPlease compute the following expression: $\\sum_{i=1}^N\\sum_{j=1}^Ngcd(i,j)$, and take the answer modulo a large prime number.\n\nSorry, I read the wrong script.\n\nYou are given a directed graph with $n$ nodes and $m$ edges. Each node has an initial energy value $a_i$.\n\nEvery second, the energy at each node flows equally to all of its outgoing edges. In addition, one share flows to itself (you may treat this as having a self-loop).\n\nNow $dkw$ has $q$ queries. Each query gives a time $t$, and $dkw$ wants to know the energy at each node after $t$ seconds.\n\nThe graph is not guaranteed to be free of multiple edges or self-loops. All answers are taken modulo $998244353$.", "inputFormat": "The first line contains three integers, $n,m,q$.\n\nThe second line contains $n$ integers, from $a_1$ to $a_n$, representing the initial energy.\n\nThe next $m$ lines each contain two positive integers $x_i,y_i$, representing a directed edge from $x_i$ to $y_i$. We assume the nodes are numbered from $1$ to $n$.\n\nThe next $q$ lines each contain one positive integer $t$, representing a query.", "outputFormat": "To avoid overly large output, for each query you only need to output one line with one non-negative integer, which is the XOR sum of the energies (modulo) of the $n$ nodes, and then taken modulo $998244353$.", "hint": "For $30\\%$ of the testdata, $1\\le t \\le 50$.\n\nFor $60\\%$ of the testdata, $1\\le q\\le 50$.\n\nFor $80\\%$ of the testdata, $1\\le q\\le 1000$.\n\nFor $100\\%$ of the testdata, $1\\le n\\le 50,1\\le m\\le n\\times (n-1),1\\le q\\le 5\\times 10^4,0< a_i< 998244353,1\\le t\\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "能量采集", "background": "", "description": "**题面已修改，请大家注意。**\n\n请你求下列式子：$\\sum_{i=1}^N\\sum_{j=1}^Ngcd(i,j)$ ，答案对大质数取模。\n\n不好意思读错剧本了。\n\n给定一个 $n$ 个点 $m$ 条边的有向图，每个点有初始能量 $a_i$ 。\n\n每过一秒，每个点的能量便会等量地流向所有出边，另外，会有一份流向自己（你可以当做有一个自环）。\n\n现在 $dkw$ 有 $q$ 次询问，每次询问会给你一个时间 $t$ ，$dkw$想知道 $t$ 秒时每个点的能量。\n\n不保证图中没有重边和自环，答案对$998244353$取模。", "inputFormat": "第一行包含三个整数，$n,m,q$ 。\n\n第二行包含$n$个整数，从$a_1$到$a_n$ ，代表初始能量。\n\n接下来 $m$ 行，每行包含两个正整数 $x_i,y_i$ ，代表一条有向边，从 $x_i$ 指向 $y_i$ ，我们约定点编号从 $1$ 到 $n$ 。\n\n接下来 $q$ 行，每行包含一个正整数 $t$ ，代表一次询问。", "outputFormat": "为了防止输出过大，对于每个询问你只需要输出一行一个非负整数，代表 $n$ 个点的能量（取模）的异或和对$998244353$取模的结果。 ", "hint": "对于 30% 的数据，$1\\le t \\le 50$\n\n对于 60% 的数据，$1\\le q\\le 50$\n\n对于 80% 的数据，$1\\le q\\le 1000$\n\n对于 100% 的数据，$1\\le n\\le 50,1\\le m\\le n\\times (n-1),1\\le q\\le 5\\times 10^4,0< a_i< 998244353,1\\le t\\le 10^9$", "locale": "zh-CN"}}}
{"pid": "P5108", "type": "P", "difficulty": 6, "samples": [["26 11\nremoonqaqac", "8 10 8 8 2 2 2 2 2 2 1"], ["26 11\ntxdydkwqaqa\n", "9 9 9 5 5 5 5 3 3 1 1"], ["10000000 17\n9 9 8 2 4 4 3 5 3 1 9 2 6 0 8 1 7", "14 14 14 14 10 10 10 10 4 4 4 4 4 4 3 2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化"], "title": "仰望半月的夜空", "background": "“你不久也会遇到喜欢的女生吧。听好了，你可得好好守护她喔。”\n\n这是父亲给予戎崎裕一的教诲\n\n父亲称不上是一个合格的父亲\n\n但是，却正是这样的父亲，连接了戎崎裕一和秋庭里香\n\n![](https://www.cnblogs.com/images/cnblogs_com/reverymoon/1200086/o_0.png)\n\n秋庭里香，明明是那样的傲娇，却不得不去守护的女生\n\n但同时，又是一个为了回忆，为了懵懂的爱情而坚强着的女生\n\n你是不是在她身上看到了小夜子的身影呢？夏目吾郎医生\n\n你是不是在他身上看到了过去的自己呢？夏目吾郎医生\n\n也许疾病切断了人与人之间的联系，但是曾经存在的痕迹，定将会化作美好的回忆，流传下去\n\n愿你们幸福\n\n", "description": "半月的夜空中，寄托了多少人与人之间的思念啊\n\n曦月知道，这些思念会汇集成一个字符串 $S$（$n = |S|$）。\n\n由于思念汇集的过于复杂，因此曦月希望提炼出所有的思念。\n\n我们定义 $Y_S(i)$ 表示对于字符串 $S$ 而言，长度为 $i$ 的子串中，字典序最小的，左端点最小的左端点的值\n\n比如对于串 $S = \\texttt{\"baa\"}$，$Y_S(1) = 2$、$Y_S(2) = 2$、$Y_S(3) = 1$。\n\n曦月会告知你 $S$ 串，你只需要告诉曦月 $Y_S(i)$（$1 \\le i \\le n$）即可。", "inputFormat": "第一行，两个参数，分别是 $\\sigma \\in \\{10, 26, 10^7\\}$ 和 $n$。\n\n如果 $\\sigma = 26$，那么第二行将是一个长为 $n$ 的小写字母字符串 $S$。\n\n其他情况下，第二行将输入 $n$ 个位于 $[0, \\sigma]$ 内的整数。", "outputFormat": "输出一行，第 $i$ 个数表示 $Y_S(i)$ 的值。", "hint": "数据范围的图不见了 QAQ\n\n最大范围是 $1 \\le n \\le 3 \\times {10}^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Half-Moon Night Sky", "background": "“You will soon meet a girl you like. Listen carefully, you must protect her well.”\n\nThis was the advice that Father gave to Yuichi Ronzaki.\n\nFather could hardly be called a qualified father.\n\nBut it was exactly such a father who connected Yuichi Ronzaki and Rika Akiba.\n\n![](https://www.cnblogs.com/images/cnblogs_com/reverymoon/1200086/o_0.png)\n\nRika Akiba is a girl who is clearly a tsundere, yet someone you cannot help but protect.\n\nAt the same time, she is also a girl who stays strong for memories, and for innocent love.\n\nDo you see Sayoko’s shadow in her, Doctor Goro Natsume?\n\nDo you see your past self in him, Doctor Goro Natsume?\n\nMaybe illness cuts off the connection between people, but the traces that once existed will surely turn into beautiful memories and be passed on.\n\nMay you be happy.", "description": "In the half-moon night sky, how many people’s feelings for each other are carried.\n\nXiyue knows that these feelings will gather into a string $S$ ($n = |S|$).\n\nBecause the feelings are gathered in a way that is too complex, Xiyue hopes to refine all of them.\n\nWe define $Y_S(i)$ as follows: for the string $S$, among all substrings of length $i$, take the lexicographically smallest one; if there are multiple, take the one with the smallest left endpoint. Then $Y_S(i)$ is the value of that left endpoint.\n\nFor example, for $S = \\texttt{\"baa\"}$, $Y_S(1) = 2$, $Y_S(2) = 2$, $Y_S(3) = 1$.\n\nXiyue will tell you the string $S$. You only need to tell Xiyue $Y_S(i)$ ($1 \\le i \\le n$).", "inputFormat": "The first line contains two parameters: $\\sigma \\in \\{10, 26, 10^7\\}$ and $n$.\n\nIf $\\sigma = 26$, then the second line is a lowercase letter string $S$ of length $n$.\n\nOtherwise, the second line contains $n$ integers in $[0, \\sigma]$.", "outputFormat": "Output one line. The $i$-th number表示 the value of $Y_S(i)$.", "hint": "The Constraints chart is missing QAQ.\n\nThe maximum range is $1 \\le n \\le 3 \\times {10}^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "仰望半月的夜空", "background": "“你不久也会遇到喜欢的女生吧。听好了，你可得好好守护她喔。”\n\n这是父亲给予戎崎裕一的教诲\n\n父亲称不上是一个合格的父亲\n\n但是，却正是这样的父亲，连接了戎崎裕一和秋庭里香\n\n![](https://www.cnblogs.com/images/cnblogs_com/reverymoon/1200086/o_0.png)\n\n秋庭里香，明明是那样的傲娇，却不得不去守护的女生\n\n但同时，又是一个为了回忆，为了懵懂的爱情而坚强着的女生\n\n你是不是在她身上看到了小夜子的身影呢？夏目吾郎医生\n\n你是不是在他身上看到了过去的自己呢？夏目吾郎医生\n\n也许疾病切断了人与人之间的联系，但是曾经存在的痕迹，定将会化作美好的回忆，流传下去\n\n愿你们幸福\n\n", "description": "半月的夜空中，寄托了多少人与人之间的思念啊\n\n曦月知道，这些思念会汇集成一个字符串 $S$（$n = |S|$）。\n\n由于思念汇集的过于复杂，因此曦月希望提炼出所有的思念。\n\n我们定义 $Y_S(i)$ 表示对于字符串 $S$ 而言，长度为 $i$ 的子串中，字典序最小的，左端点最小的左端点的值\n\n比如对于串 $S = \\texttt{\"baa\"}$，$Y_S(1) = 2$、$Y_S(2) = 2$、$Y_S(3) = 1$。\n\n曦月会告知你 $S$ 串，你只需要告诉曦月 $Y_S(i)$（$1 \\le i \\le n$）即可。", "inputFormat": "第一行，两个参数，分别是 $\\sigma \\in \\{10, 26, 10^7\\}$ 和 $n$。\n\n如果 $\\sigma = 26$，那么第二行将是一个长为 $n$ 的小写字母字符串 $S$。\n\n其他情况下，第二行将输入 $n$ 个位于 $[0, \\sigma]$ 内的整数。", "outputFormat": "输出一行，第 $i$ 个数表示 $Y_S(i)$ 的值。", "hint": "数据范围的图不见了 QAQ\n\n最大范围是 $1 \\le n \\le 3 \\times {10}^5$。", "locale": "zh-CN"}}}
{"pid": "P5109", "type": "P", "difficulty": 7, "samples": [["5 5 2 3\n0 0 \n1 2 \n3 3 \n2 1 \n3 2 \n1 3 0 \n2 1 2 \n3 0 1 \n4 1 2 \n2 0 1 \n", "0\n3\n14\n34\n2\n"], ["5 5 2 3\n2 2 \n2 0 \n2 3 \n0 3 \n2 1 \n2 0 1 \n3 1 1 \n1 0 2 \n2 3 0 \n5 0 2 \n", "4\n0\n0\n0\n465\n"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["O2优化"], "title": "归程", "background": "", "description": "dkw在玩一款叫做《ION8102》的游戏，这个游戏分为序章，第一章，第二章。\n\n她已经满血通过了序章，来到了第一章的第一关。\n\n这关的名字叫归程，她需要到达指定地点，这一路上要经过 $m$ 扇机关门。\n\n每扇机关门上有一个钥匙孔，只有特制钥匙可以放进去，里面有 $k$ 把转轮锁，每个转轮锁都要恰好转到目标位置 $a_i$ 才能开门，每个转轮锁的最大刻度都是 $v$ ，刻度标号从 $0$ 到 $v$ ，每个转轮锁初始位置都是 $0$ 。\n\ndkw身上有 $n$ 把钥匙，每把钥匙都有 $k$ 个转动量 $b_i$ ，分别代表这把钥匙转一圈，可以让机关门中的这个转轮锁走多少个位置。\n\n每扇机关门还有一个圈数限制 $c$ ，也就是你总共只能用钥匙转最多 $c$ 圈，并且每把钥匙只能正着转，只能转整数圈。\n\n任务要求顺次打开这 $m$ 扇门，这么简单的问题dkw当然秒了，但是dkw好奇的是：对于每一扇门，有多少种方案能顺利打开呢？\n\n两种方案不同，当且仅当两种方案中总圈数不同或某一圈所用钥匙不同。\n\n如果你解答了dkw的好奇心，那么你将会收到她的一份大~礼物——100分！", "inputFormat": "第一行包含四个正整数 $n,m,k,v$ ，含义详见题目描述。\n\n接下来 $n$ 行，每行包含 $k$ 个非负整数，依次代表这把钥匙的转动量 $b_i$ 。\n\n接下来 $m$ 行，首先是一个非负整数 $c$ 代表圈数限制，接着是 $k$ 个非负整数，依次代表这扇门的目标位置 $a_i$ 。", "outputFormat": "对于每个询问，输出一行一个非负整数代表这次询问的答案，对 $2333$ 取模。", "hint": "本题采用子任务测试。\n\n- 子任务1 (9pts)：$1\\le n,m,k,c,v\\le 5$\n- 子任务2 (16pts)：$1\\le n\\le 10^5,1\\le m,c\\le 100,v=1,k\\le 12$\n- 子任务3 (17pts)：$1\\le n\\le 10^5,1\\le m,c\\le 100,v=2,k\\le 8$\n- 子任务4 (19pts)：$1\\le n\\le 10^5,1\\le m,c\\le 100,v=3,k\\le 6$\n- 子任务5 (16pts)：$1\\le n\\le 10^5,1\\le m,c\\le 100$\n- 子任务6 (23pts)：$1\\le n\\le 10^5,1\\le m\\le 5,1\\le c\\le 10^9$\n\n每个测试点的 $v$ 和 $k$ 会从下表的对应关系中选取。\n\n其中 $maxk$ 代表 $k$ 不会超过该值。\n\n| 编号 | v    | maxk |\n| ---- | ---- | ---- |\n| 1    | 1    | 12   |\n| 2    | 2    | 8    |\n| 3    | 3    | 6    |\n| 4    | 4    | 5    |\n| 5    | 5    | 4    |\n| 6    | 6    | 4    |\n| 7    | 7    | 3    |\n| 8    | 8    | 3    |\n| 9    | 9    | 3    |", "locale": "zh-CN", "translations": {"en": {"title": "Return Journey", "background": "", "description": "dkw is playing a game called *ION8102*. The game is divided into the prologue, Chapter 1, and Chapter 2.\n\nShe has cleared the prologue with full health and has arrived at the first level of Chapter 1.\n\nThis level is called Return Journey. She needs to reach a specified location, and along the way she must pass through $m$ mechanical doors.\n\nEach mechanical door has a keyhole, and only a special key can be inserted. Inside there are $k$ dial locks. Each dial lock must be turned to the target position $a_i$ exactly in order to open the door. The maximum scale of each dial is $v$, with labels from $0$ to $v$. The initial position of every dial lock is $0$.\n\ndkw has $n$ keys. Each key has $k$ rotation amounts $b_i$, meaning that if this key is turned by one full circle, it will move the corresponding dial lock in the door by that many positions.\n\nEach mechanical door also has a turn limit $c$, which means that in total you can use keys to turn at most $c$ circles. Also, each key can only be turned forward, and only an integer number of circles can be turned.\n\nThe task requires opening these $m$ doors in order. Such an easy problem is of course solved instantly by dkw, but she is curious: for each door, how many different plans can open it successfully?\n\nTwo plans are different if and only if either the total number of circles is different, or the key used in some circle is different.\n\nIf you satisfy dkw’s curiosity, you will receive a big gift from her—100 points.", "inputFormat": "The first line contains four positive integers $n,m,k,v$, with meanings as described above.\n\nThe next $n$ lines each contain $k$ non-negative integers, representing the rotation amounts $b_i$ of this key in order.\n\nThe next $m$ lines: first a non-negative integer $c$ representing the turn limit, followed by $k$ non-negative integers representing the target positions $a_i$ of this door in order.", "outputFormat": "For each query, output one line with one non-negative integer representing the answer to this query, modulo $2333$.", "hint": "This problem uses subtasks.\n\n- Subtask 1 (9pts): $1\\le n,m,k,c,v\\le 5$.\n- Subtask 2 (16pts): $1\\le n\\le 10^5,1\\le m,c\\le 100,v=1,k\\le 12$.\n- Subtask 3 (17pts): $1\\le n\\le 10^5,1\\le m,c\\le 100,v=2,k\\le 8$.\n- Subtask 4 (19pts): $1\\le n\\le 10^5,1\\le m,c\\le 100,v=3,k\\le 6$.\n- Subtask 5 (16pts): $1\\le n\\le 10^5,1\\le m,c\\le 100$.\n- Subtask 6 (23pts): $1\\le n\\le 10^5,1\\le m\\le 5,1\\le c\\le 10^9$.\n\nFor each test point, $v$ and $k$ are chosen from the corresponding relation in the table below.\n\nHere, $maxk$ means that $k$ will not exceed this value.\n\n| Index | v    | maxk |\n| ---- | ---- | ---- |\n| 1    | 1    | 12   |\n| 2    | 2    | 8    |\n| 3    | 3    | 6    |\n| 4    | 4    | 5    |\n| 5    | 5    | 4    |\n| 6    | 6    | 4    |\n| 7    | 7    | 3    |\n| 8    | 8    | 3    |\n| 9    | 9    | 3    |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "归程", "background": "", "description": "dkw在玩一款叫做《ION8102》的游戏，这个游戏分为序章，第一章，第二章。\n\n她已经满血通过了序章，来到了第一章的第一关。\n\n这关的名字叫归程，她需要到达指定地点，这一路上要经过 $m$ 扇机关门。\n\n每扇机关门上有一个钥匙孔，只有特制钥匙可以放进去，里面有 $k$ 把转轮锁，每个转轮锁都要恰好转到目标位置 $a_i$ 才能开门，每个转轮锁的最大刻度都是 $v$ ，刻度标号从 $0$ 到 $v$ ，每个转轮锁初始位置都是 $0$ 。\n\ndkw身上有 $n$ 把钥匙，每把钥匙都有 $k$ 个转动量 $b_i$ ，分别代表这把钥匙转一圈，可以让机关门中的这个转轮锁走多少个位置。\n\n每扇机关门还有一个圈数限制 $c$ ，也就是你总共只能用钥匙转最多 $c$ 圈，并且每把钥匙只能正着转，只能转整数圈。\n\n任务要求顺次打开这 $m$ 扇门，这么简单的问题dkw当然秒了，但是dkw好奇的是：对于每一扇门，有多少种方案能顺利打开呢？\n\n两种方案不同，当且仅当两种方案中总圈数不同或某一圈所用钥匙不同。\n\n如果你解答了dkw的好奇心，那么你将会收到她的一份大~礼物——100分！", "inputFormat": "第一行包含四个正整数 $n,m,k,v$ ，含义详见题目描述。\n\n接下来 $n$ 行，每行包含 $k$ 个非负整数，依次代表这把钥匙的转动量 $b_i$ 。\n\n接下来 $m$ 行，首先是一个非负整数 $c$ 代表圈数限制，接着是 $k$ 个非负整数，依次代表这扇门的目标位置 $a_i$ 。", "outputFormat": "对于每个询问，输出一行一个非负整数代表这次询问的答案，对 $2333$ 取模。", "hint": "本题采用子任务测试。\n\n- 子任务1 (9pts)：$1\\le n,m,k,c,v\\le 5$\n- 子任务2 (16pts)：$1\\le n\\le 10^5,1\\le m,c\\le 100,v=1,k\\le 12$\n- 子任务3 (17pts)：$1\\le n\\le 10^5,1\\le m,c\\le 100,v=2,k\\le 8$\n- 子任务4 (19pts)：$1\\le n\\le 10^5,1\\le m,c\\le 100,v=3,k\\le 6$\n- 子任务5 (16pts)：$1\\le n\\le 10^5,1\\le m,c\\le 100$\n- 子任务6 (23pts)：$1\\le n\\le 10^5,1\\le m\\le 5,1\\le c\\le 10^9$\n\n每个测试点的 $v$ 和 $k$ 会从下表的对应关系中选取。\n\n其中 $maxk$ 代表 $k$ 不会超过该值。\n\n| 编号 | v    | maxk |\n| ---- | ---- | ---- |\n| 1    | 1    | 12   |\n| 2    | 2    | 8    |\n| 3    | 3    | 6    |\n| 4    | 4    | 5    |\n| 5    | 5    | 4    |\n| 6    | 6    | 4    |\n| 7    | 7    | 3    |\n| 8    | 8    | 3    |\n| 9    | 9    | 3    |", "locale": "zh-CN"}}}
{"pid": "P5110", "type": "P", "difficulty": 6, "samples": [["4779 17790102303135 73152356900611 22086182463002", "391030355"], ["49999561 116754637679537 79587668206509 80161279644028", "705437004"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000, 16000]}, "tags": ["O2优化"], "title": "块速递推", "background": "shadowice1984 发现了一道题：求斐波那契数列第 $n$ 项模 $10^9+7$ 的值，$n \\leq 10^9$。\n\nshadowice1984 想了一个星期可他还是不会做。\n\n当然，这是 shadowice1984 刚学 OI 时候的事情了，今天他学习了矩阵快速幂并且花了一整天解决了上面的问题。\n\n他决定出一道题来测试你的矩阵快速幂水平如何，为了检查他花了一个星期写出的 std 到底有没有错，他决定让你来帮他验题。", "description": "给定一个数列 $a$ 满足递推式\n\n$$a_{n}=233a_{n-1}+666a_{n-2},a_{0}=0,a_{1}=1$$\n\n求这个数列第 $n$ 项模 $10^9+7$ 的值，一共有 $T$ 组询问。\n\n为了在某种程度上减少你的输入和输出量，我们采用以下的代码来生成询问：\n\n```C\nnamespace Mker\n{\n\tunsigned long long SA,SB,SC;\n\tvoid init(){scanf(\"%llu%llu%llu\",&SA,&SB,&SC);}\n\tunsigned long long rand()\n\t{\n\t    SA^=SA<<32,SA^=SA>>13,SA^=SA<<1;\n\t    unsigned long long t=SA;\n\t\tSA=SB,SB=SC,SC^=t^SA;return SC;\n\t}\n}\n```\n在调用 `Mker::init()` 函数之后这个随机数生成器便可以正常工作了，当你第 $i$ 次调用 `Mker::rand()` 函数时返回的便是第 $i$ 次询问的 $n$ 值。\n\n为了减少你的输出量，你只需要输出所有询问答案的异或和。", "inputFormat": "仅一行四个整数，表示 $T,SA,SB,SC$ 的值，你可以在读入 $T$ 之后直接调用 `Mker::init()` 来完成输入工作。", "outputFormat": "仅一行一个整数，表示所有答案的异或和。", "hint": "$SA,SB,SC$ 均在 `unsigned long long` 数据类型的范围之内，由此可以发现返回的 $n$ 值也是 `unsigned long long` 数据类型的范围之内。\n\n前 6 个测试点每个测试点 $1$ 分。\n\n对于 1,2 测试点 $T \\leq 5000$。\n\n对于 3,4,5,6 测试点 $T \\leq 500000$。\n\n对于所有测试点 $1 \\leq T \\leq 5×10^7$。", "locale": "zh-CN", "translations": {"en": {"title": "Block Fast Recurrence", "background": "shadowice1984 found a problem: compute the $n$-th term of the Fibonacci sequence modulo $10^9+7$, where $n \\leq 10^9$.\n\nshadowice1984 thought about it for a whole week but still could not solve it.\n\nOf course, that was when shadowice1984 had just started learning OI. Today, he learned fast matrix exponentiation and spent an entire day solving the problem above.\n\nHe decided to make a problem to test your fast matrix exponentiation skills. To check whether the std he spent a week writing has any mistakes, he decided to ask you to help verify the problem.", "description": "Given a sequence $a$ that satisfies the recurrence\n\n$$a_{n}=233a_{n-1}+666a_{n-2},a_{0}=0,a_{1}=1$$\n\nCompute the value of the $n$-th term of this sequence modulo $10^9+7$. There are $T$ queries in total.\n\nTo reduce your input and output workload to some extent, we generate the queries using the following code:\n\n```C\nnamespace Mker\n{\n\tunsigned long long SA,SB,SC;\n\tvoid init(){scanf(\"%llu%llu%llu\",&SA,&SB,&SC);}\n\tunsigned long long rand()\n\t{\n\t    SA^=SA<<32,SA^=SA>>13,SA^=SA<<1;\n\t    unsigned long long t=SA;\n\t\tSA=SB,SB=SC,SC^=t^SA;return SC;\n\t}\n}\n```\n\nAfter calling `Mker::init()`, this random number generator will work normally. When you call `Mker::rand()` for the $i$-th time, the returned value is the $n$ for the $i$-th query.\n\nTo reduce your output, you only need to output the bitwise XOR of the answers to all queries.", "inputFormat": "A single line with four integers, representing $T,SA,SB,SC$. After reading $T$, you can directly call `Mker::init()` to finish the input.", "outputFormat": "A single line with one integer, representing the bitwise XOR of all answers.", "hint": "$SA,SB,SC$ are all within the range of the `unsigned long long` data type, so the returned $n$ is also within the range of the `unsigned long long` data type.\n\nThe first 6 test points are worth $1$ point each.\n\nFor test points 1 and 2, $T \\leq 5000$.\n\nFor test points 3, 4, 5, and 6, $T \\leq 500000$.\n\nFor all test points, $1 \\leq T \\leq 5×10^7$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "块速递推", "background": "shadowice1984 发现了一道题：求斐波那契数列第 $n$ 项模 $10^9+7$ 的值，$n \\leq 10^9$。\n\nshadowice1984 想了一个星期可他还是不会做。\n\n当然，这是 shadowice1984 刚学 OI 时候的事情了，今天他学习了矩阵快速幂并且花了一整天解决了上面的问题。\n\n他决定出一道题来测试你的矩阵快速幂水平如何，为了检查他花了一个星期写出的 std 到底有没有错，他决定让你来帮他验题。", "description": "给定一个数列 $a$ 满足递推式\n\n$$a_{n}=233a_{n-1}+666a_{n-2},a_{0}=0,a_{1}=1$$\n\n求这个数列第 $n$ 项模 $10^9+7$ 的值，一共有 $T$ 组询问。\n\n为了在某种程度上减少你的输入和输出量，我们采用以下的代码来生成询问：\n\n```C\nnamespace Mker\n{\n\tunsigned long long SA,SB,SC;\n\tvoid init(){scanf(\"%llu%llu%llu\",&SA,&SB,&SC);}\n\tunsigned long long rand()\n\t{\n\t    SA^=SA<<32,SA^=SA>>13,SA^=SA<<1;\n\t    unsigned long long t=SA;\n\t\tSA=SB,SB=SC,SC^=t^SA;return SC;\n\t}\n}\n```\n在调用 `Mker::init()` 函数之后这个随机数生成器便可以正常工作了，当你第 $i$ 次调用 `Mker::rand()` 函数时返回的便是第 $i$ 次询问的 $n$ 值。\n\n为了减少你的输出量，你只需要输出所有询问答案的异或和。", "inputFormat": "仅一行四个整数，表示 $T,SA,SB,SC$ 的值，你可以在读入 $T$ 之后直接调用 `Mker::init()` 来完成输入工作。", "outputFormat": "仅一行一个整数，表示所有答案的异或和。", "hint": "$SA,SB,SC$ 均在 `unsigned long long` 数据类型的范围之内，由此可以发现返回的 $n$ 值也是 `unsigned long long` 数据类型的范围之内。\n\n前 6 个测试点每个测试点 $1$ 分。\n\n对于 1,2 测试点 $T \\leq 5000$。\n\n对于 3,4,5,6 测试点 $T \\leq 500000$。\n\n对于所有测试点 $1 \\leq T \\leq 5×10^7$。", "locale": "zh-CN"}}}
{"pid": "P5111", "type": "P", "difficulty": 7, "samples": [["20 5\n11 12\n14 20\n6 12\n8 13\n10 19\n", "67"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["O2优化"], "title": "zhtobu3232 的线段树", "background": "zhtobu3232 发现了一道线段树题，在 30s 后 zhtobu3232 敲出了一份线段树并且 AC 了这题。\n\n当然，这是 zhtobu3232 刚刚学 OI 时候的事情了，现在的他只需 1s 就可以敲出一份完美的线段树板子。\n\n现在 ztb 想要重温一下他之前切过的水题，不过他的笔记本电脑年代有些久远，导致内存条损坏了很多，从而线段树也开始损坏了，现在他不关心当年敲了什么水题而只关心这个线段树可以表示出多少合法的区间，请你计算出这个数字并对 $998244353$ 取模。\n\n顺便说一句 ztb 认为这个问题比线段树简单多了，因为线段树的节点少了，所以维护的信息也少了，他已经用 1ms 敲好了 std，接下来就等着你帮他验题了。", "description": "我们定义一颗长度为 $n$ 的线段树是这样的算法流程执行 `build(0,n)` 后建出的二叉树。\n\n注意这里的线段树应该和大家平常写的没什么区别（除了区间是左开右闭表示的以外），会线段树的可以忽略。\n\n```C\nnode build (l,r)\n{\n\tnode p=newnode();p.l=l+1;p.r=r;\n    if(r-l==1)return p;\n    mid=(l+r)/2;\n    node.leftson=build(l,mid);\n\tnode.rightson=build(mid,r);\n    return p;\n}\n```\n\n而我们定义一个区间 $(l,r)$ 在线段树上的**拆分**是将这个区间表示为线段树上若干个节点的集合，满足这些节点对应的区间不相交，不嵌套，这些区间的并集恰好是 $(l,r)$，并且没有两个节点是兄弟关系。\n\n拆分的伪代码如下：\n\n```C\nvoid solve(l,r,dl,dr)\n{\n\tif(dl==l&&dr==r){S.push(node(l+1,r));return;}\n\t mid=(l+r)/2;\n    if(dl<mid)solve(l,mid,dl,min(dr,mid));\n    if(mid<dr)solve(mid,r,max(dl,mid),dr);\n}\n\n```\n\n当我们执行完 `solve(0,n,l-1,r)` 之后得到的 $S$ 集合就是区间 $(l,r)$ 在 $(1,n)$ 这颗线段树上的**拆分**了。换句话说就是你平时写线段树时将一个区间拆成 $O(\\log n)$ 个区间的操作。\n\n现在我们给出了 $m$ 个区间 $(l,r)$，这些区间在线段树 $(1,n)$ 上拆分出来的节点都是非法节点，换句话说这些节点都不可以使用了。\n\n现在请你计算有多少个区间 $(l,r)$ 是合法的，满足以下两个限制条件：\n\n1. $1 \\leq l \\leq r \\leq n$；\n2. 这个区间在线段树 $(1,n)$ 上的拆分不含有非法的节点。\n\n答案对 $998244353$ 取模。", "inputFormat": "**为了避免您被题意杀，请务必按照题目中给出的左开右闭法建线段树，采用其他的建树方式可能导致线段树的形态和 std 中的线段树不符导致 WA。**\n\n第一行两个整数 $n,m$，表示线段树的长度和区间个数。\n\n接下来 $m$ 行每行两个整数 $l,r$，表示 $(l,r)$ 这个区间在线段树上拆分出的节点全部为非法节点。", "outputFormat": "仅一行一个整数，表示所有合法的区间个数对 $998244353$ 取模之后的值。", "hint": "$1,2,3,4,5,6,7$ 测试点的分数全部为 $1$ 分。\n\n对于测试点 $1,2$，$n \\leq 1000,m\\leq 100$。\n\n对于测试点 $3,4$，$n \\leq 100000,m \\leq 5000$。\n\n对于测试点 $5,6,7$，$n \\leq 10^7,m \\leq 10^5$。\n\n对于所有数据，$1 \\leq n \\leq 10^{14}$，$1 \\leq m \\leq 10^5$，$1 \\leq l \\leq r \\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "zhtobu3232’s Segment Tree", "background": "zhtobu3232 found a segment tree problem. After 30 seconds, zhtobu3232 typed out a segment tree and got AC on it.\n\nOf course, that was when zhtobu3232 had just started learning OI. Now he only needs 1 second to type out a perfect segment tree template.\n\nNow ztb wants to relive those easy problems he solved before. But his laptop is quite old, and many memory sticks have been damaged, so the segment tree has also started to break. Now he does not care what easy problem he coded back then; he only cares about how many valid intervals this segment tree can represent. Please compute this number and take it modulo $998244353$.\n\nBy the way, ztb thinks this problem is much simpler than a segment tree, because the segment tree has fewer nodes, so there is less information to maintain. He has already typed the std in 1 ms, and now he is waiting for you to help validate the problem.", "description": "We define a segment tree of length $n$ as the binary tree built by executing `build(0,n)` in the following algorithm.\n\nNote that this segment tree should be almost the same as the one everyone usually writes (except that intervals are represented as left-open right-closed). If you know segment trees, you may ignore this note.\n\n```C\nnode build (l,r)\n{\n\tnode p=newnode();p.l=l+1;p.r=r;\n    if(r-l==1)return p;\n    mid=(l+r)/2;\n    node.leftson=build(l,mid);\n\tnode.rightson=build(mid,r);\n    return p;\n}\n```\n\nWe define the **decomposition** of an interval $(l,r)$ on the segment tree as representing this interval as a set of several nodes on the segment tree, such that the intervals corresponding to these nodes are non-overlapping, not nested, their union is exactly $(l,r)$, and no two nodes are siblings.\n\nThe pseudo-code for decomposition is:\n\n```C\nvoid solve(l,r,dl,dr)\n{\n\tif(dl==l&&dr==r){S.push(node(l+1,r));return;}\n\t mid=(l+r)/2;\n    if(dl<mid)solve(l,mid,dl,min(dr,mid));\n    if(mid<dr)solve(mid,r,max(dl,mid),dr);\n}\n\n```\n\nAfter executing `solve(0,n,l-1,r)`, the set $S$ obtained is exactly the **decomposition** of interval $(l,r)$ on the segment tree $(1,n)$. In other words, it is the operation you usually do in a segment tree where you split an interval into $O(\\log n)$ intervals.\n\nNow we are given $m$ intervals $(l,r)$. All nodes produced by decomposing these intervals on the segment tree $(1,n)$ are illegal nodes. In other words, these nodes cannot be used.\n\nNow please compute how many intervals $(l,r)$ are valid, satisfying the following two constraints:\n\n1. $1 \\leq l \\leq r \\leq n$.\n2. The decomposition of this interval on the segment tree $(1,n)$ does not contain any illegal nodes.\n\nOutput the answer modulo $998244353$.", "inputFormat": "**To avoid being misled by the statement, you must build the segment tree using the left-open right-closed convention described in the problem. Using other building methods may cause the segment tree shape to differ from the one in std, leading to WA.**\n\nThe first line contains two integers $n,m$, representing the length of the segment tree and the number of intervals.\n\nThe next $m$ lines each contain two integers $l,r$, meaning that all nodes produced by decomposing the interval $(l,r)$ on the segment tree are illegal nodes.", "outputFormat": "Output one integer in a single line: the number of all valid intervals modulo $998244353$.", "hint": "The scores of test points $1,2,3,4,5,6,7$ are all $1$ point.\n\nFor test points $1,2$, $n \\leq 1000,m \\leq 100$.\n\nFor test points $3,4$, $n \\leq 100000,m \\leq 5000$.\n\nFor test points $5,6,7$, $n \\leq 10^7,m \\leq 10^5$.\n\nFor all testdata, $1 \\leq n \\leq 10^{14}$, $1 \\leq m \\leq 10^5$, $1 \\leq l \\leq r \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "zhtobu3232 的线段树", "background": "zhtobu3232 发现了一道线段树题，在 30s 后 zhtobu3232 敲出了一份线段树并且 AC 了这题。\n\n当然，这是 zhtobu3232 刚刚学 OI 时候的事情了，现在的他只需 1s 就可以敲出一份完美的线段树板子。\n\n现在 ztb 想要重温一下他之前切过的水题，不过他的笔记本电脑年代有些久远，导致内存条损坏了很多，从而线段树也开始损坏了，现在他不关心当年敲了什么水题而只关心这个线段树可以表示出多少合法的区间，请你计算出这个数字并对 $998244353$ 取模。\n\n顺便说一句 ztb 认为这个问题比线段树简单多了，因为线段树的节点少了，所以维护的信息也少了，他已经用 1ms 敲好了 std，接下来就等着你帮他验题了。", "description": "我们定义一颗长度为 $n$ 的线段树是这样的算法流程执行 `build(0,n)` 后建出的二叉树。\n\n注意这里的线段树应该和大家平常写的没什么区别（除了区间是左开右闭表示的以外），会线段树的可以忽略。\n\n```C\nnode build (l,r)\n{\n\tnode p=newnode();p.l=l+1;p.r=r;\n    if(r-l==1)return p;\n    mid=(l+r)/2;\n    node.leftson=build(l,mid);\n\tnode.rightson=build(mid,r);\n    return p;\n}\n```\n\n而我们定义一个区间 $(l,r)$ 在线段树上的**拆分**是将这个区间表示为线段树上若干个节点的集合，满足这些节点对应的区间不相交，不嵌套，这些区间的并集恰好是 $(l,r)$，并且没有两个节点是兄弟关系。\n\n拆分的伪代码如下：\n\n```C\nvoid solve(l,r,dl,dr)\n{\n\tif(dl==l&&dr==r){S.push(node(l+1,r));return;}\n\t mid=(l+r)/2;\n    if(dl<mid)solve(l,mid,dl,min(dr,mid));\n    if(mid<dr)solve(mid,r,max(dl,mid),dr);\n}\n\n```\n\n当我们执行完 `solve(0,n,l-1,r)` 之后得到的 $S$ 集合就是区间 $(l,r)$ 在 $(1,n)$ 这颗线段树上的**拆分**了。换句话说就是你平时写线段树时将一个区间拆成 $O(\\log n)$ 个区间的操作。\n\n现在我们给出了 $m$ 个区间 $(l,r)$，这些区间在线段树 $(1,n)$ 上拆分出来的节点都是非法节点，换句话说这些节点都不可以使用了。\n\n现在请你计算有多少个区间 $(l,r)$ 是合法的，满足以下两个限制条件：\n\n1. $1 \\leq l \\leq r \\leq n$；\n2. 这个区间在线段树 $(1,n)$ 上的拆分不含有非法的节点。\n\n答案对 $998244353$ 取模。", "inputFormat": "**为了避免您被题意杀，请务必按照题目中给出的左开右闭法建线段树，采用其他的建树方式可能导致线段树的形态和 std 中的线段树不符导致 WA。**\n\n第一行两个整数 $n,m$，表示线段树的长度和区间个数。\n\n接下来 $m$ 行每行两个整数 $l,r$，表示 $(l,r)$ 这个区间在线段树上拆分出的节点全部为非法节点。", "outputFormat": "仅一行一个整数，表示所有合法的区间个数对 $998244353$ 取模之后的值。", "hint": "$1,2,3,4,5,6,7$ 测试点的分数全部为 $1$ 分。\n\n对于测试点 $1,2$，$n \\leq 1000,m\\leq 100$。\n\n对于测试点 $3,4$，$n \\leq 100000,m \\leq 5000$。\n\n对于测试点 $5,6,7$，$n \\leq 10^7,m \\leq 10^5$。\n\n对于所有数据，$1 \\leq n \\leq 10^{14}$，$1 \\leq m \\leq 10^5$，$1 \\leq l \\leq r \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P5112", "type": "P", "difficulty": 6, "samples": [["20 15 3\noouuoouuoouuoouuoouu\n10 16\n2 15\n4 13\n6 7\n4 12\n12 14\n12 13\n7 19\n1 5\n6 13\n1 15\n9 15\n11 15\n1 19\n15 18", "3\n18\n8\n0\n6\n0\n0\n12\n1\n4\n21\n3\n1\n32\n0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["字符串", "O2优化"], "title": "FZOUTSY", "background": "", "description": "### 原始题意\n\ncdm1020 是一名废宅，他平时最喜欢的事情就是水（复）群（读）。\n\n他截取了他最近水的群的聊天记录，并且通过某种奥妙重重的压缩算法将这些聊天记录压缩成了一个长度为 $n$ 的字符串，因为他是一个中二社厨，所以这个字符串当中仅仅含有 $\\mathtt{f,z,o,u,t,s,y}$ 这 $7$ 种字符，出于对后缀数据结构的狂热，他只对这个字符串的后缀感兴趣，他定义一个后缀的编号为 $i$，当且仅当它代表的字符串的区间为 $[i,n]$。\n\ncdm1020 定义一对后缀 $(i,j)$ 是\"$k$级复读的\"当且仅当 $i$ 和 $j$ 的最长公共前缀的长度大于等于 $k$，换句话说一对$k$级复读的后缀也是 $k-1,k-2,k-3,\\cdots,1,0$ 级复读的。\n\n现在他想问你对于编号在 $(l,r)$ 中的后缀，有多少对后缀是 $k$ 级复读的。\n\n### 一句话题意\n\n给定一个长度为 $n$ 并且字符集为 $\\mathtt{f,z,o,u,t,s,y}$ 的字符串和一个询问参数 $k$，多组询问 $(l,r)$ 求编号在 $(l,r)$ 间的后缀中，有多少对后缀的 LCP（最长公共前缀）长度大于等于 $k$。\n\n定义一个后缀的编号为 $i$ 当且仅当这个后缀代表的是 $(i,n)$ 这段区间的字符。", "inputFormat": "第一行三个正整数 $n,m,k$ 分别代表字符串的长度 $n$，询问次数 $m$ 和询问的参数 $k$。\n\n第二行一个长度为 $n$ 的字符串表示你需要处理的字符串。\n\n接下来 $m$ 行，每行两个正整数 $l,r$ 表示询问的区间 $l,r$。", "outputFormat": "输出 $m$ 行正整数，表示询问区间中 LCP 长度大于等于 $k$ 的后缀对数量。", "hint": "### 数据范围及约定\n\n对于全部数据，$1\\leq l\\leq r\\leq n \\leq 3×10^6$，$1\\leq k \\leq n \\leq 3×10^6$，$1\\leq m \\leq 10^5$，$1 \\leq n^2m \\leq 10^{15}$。\n\n保证输入的字符串中仅含 $\\mathtt{f,z,o,u,t,s,y}$ 这 $7$ 种小写字母。", "locale": "zh-CN", "translations": {"en": {"title": "FZOUTSY", "background": "", "description": "### Original Meaning\n\ncdm1020 is a shut-in. His favorite thing in daily life is chatting (and copying) in group chats.\n\nHe took the chat logs from a group he recently chatted in, and used some mysterious compression algorithm to compress these chat logs into a string of length $n$. Because he is a chuunibyou-style fan, this string contains only $7$ kinds of characters: $\\mathtt{f,z,o,u,t,s,y}$. Because of his obsession with suffix data structures, he is only interested in the suffixes of this string. He defines the index of a suffix to be $i$ if and only if the interval of the string it represents is $[i,n]$.\n\ncdm1020 defines a pair of suffixes $(i,j)$ to be “$k$-level copying” if and only if the length of the longest common prefix of suffix $i$ and suffix $j$ is at least $k$. In other words, a pair of $k$-level copying suffixes is also $k-1,k-2,k-3,\\cdots,1,0$-level copying.\n\nNow he wants to ask: among the suffixes with indices in $(l,r)$, how many pairs of suffixes are $k$-level copying.\n\n### One-Sentence Meaning\n\nGiven a string of length $n$ over the alphabet $\\mathtt{f,z,o,u,t,s,y}$ and a query parameter $k$, for multiple queries $(l,r)$, find among the suffixes with indices in $(l,r)$ how many pairs of suffixes have LCP (longest common prefix) length at least $k$.\n\nA suffix has index $i$ if and only if it represents the characters in the interval $(i,n)$.", "inputFormat": "The first line contains three positive integers $n,m,k$, representing the string length $n$, the number of queries $m$, and the query parameter $k$.\n\nThe second line contains a string of length $n$, which is the string you need to process.\n\nThe next $m$ lines each contain two positive integers $l,r$, representing the query interval $l,r$.", "outputFormat": "Output $m$ lines, each containing a positive integer, representing the number of suffix pairs in the query interval whose LCP length is at least $k$.", "hint": "### Constraints and Notes\n\nFor all testdata, $1\\leq l\\leq r\\leq n \\leq 3×10^6$, $1\\leq k \\leq n \\leq 3×10^6$, $1\\leq m \\leq 10^5$, $1 \\leq n^2m \\leq 10^{15}$.\n\nIt is guaranteed that the input string contains only the $7$ lowercase letters $\\mathtt{f,z,o,u,t,s,y}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "FZOUTSY", "background": "", "description": "### 原始题意\n\ncdm1020 是一名废宅，他平时最喜欢的事情就是水（复）群（读）。\n\n他截取了他最近水的群的聊天记录，并且通过某种奥妙重重的压缩算法将这些聊天记录压缩成了一个长度为 $n$ 的字符串，因为他是一个中二社厨，所以这个字符串当中仅仅含有 $\\mathtt{f,z,o,u,t,s,y}$ 这 $7$ 种字符，出于对后缀数据结构的狂热，他只对这个字符串的后缀感兴趣，他定义一个后缀的编号为 $i$，当且仅当它代表的字符串的区间为 $[i,n]$。\n\ncdm1020 定义一对后缀 $(i,j)$ 是\"$k$级复读的\"当且仅当 $i$ 和 $j$ 的最长公共前缀的长度大于等于 $k$，换句话说一对$k$级复读的后缀也是 $k-1,k-2,k-3,\\cdots,1,0$ 级复读的。\n\n现在他想问你对于编号在 $(l,r)$ 中的后缀，有多少对后缀是 $k$ 级复读的。\n\n### 一句话题意\n\n给定一个长度为 $n$ 并且字符集为 $\\mathtt{f,z,o,u,t,s,y}$ 的字符串和一个询问参数 $k$，多组询问 $(l,r)$ 求编号在 $(l,r)$ 间的后缀中，有多少对后缀的 LCP（最长公共前缀）长度大于等于 $k$。\n\n定义一个后缀的编号为 $i$ 当且仅当这个后缀代表的是 $(i,n)$ 这段区间的字符。", "inputFormat": "第一行三个正整数 $n,m,k$ 分别代表字符串的长度 $n$，询问次数 $m$ 和询问的参数 $k$。\n\n第二行一个长度为 $n$ 的字符串表示你需要处理的字符串。\n\n接下来 $m$ 行，每行两个正整数 $l,r$ 表示询问的区间 $l,r$。", "outputFormat": "输出 $m$ 行正整数，表示询问区间中 LCP 长度大于等于 $k$ 的后缀对数量。", "hint": "### 数据范围及约定\n\n对于全部数据，$1\\leq l\\leq r\\leq n \\leq 3×10^6$，$1\\leq k \\leq n \\leq 3×10^6$，$1\\leq m \\leq 10^5$，$1 \\leq n^2m \\leq 10^{15}$。\n\n保证输入的字符串中仅含 $\\mathtt{f,z,o,u,t,s,y}$ 这 $7$ 种小写字母。", "locale": "zh-CN"}}}
{"pid": "P5113", "type": "P", "difficulty": 7, "samples": [["20 20\n8 6 4 9 9 8 5 5 7 9 8 8 5 8 2 2 2 1 9 4 \n1 17 19 4\n1 3 8 5\n3 2\n2 4 10\n1 14 19 8\n2 10 16\n2 9 9\n1 1 18 1\n1 1 7 10\n2 4 6\n2 9 10\n1 5 17 2\n1 10 19 6\n1 2 5 2\n1 6 8 2\n1 14 19 1\n1 4 7 6\n1 17 19 10\n2 8 12\n1 10 10 2\n", "52\n54\n7\n30\n2\n22\n"], ["20 20\n8 6 4 9 9 8 5 5 7 9 8 8 5 8 2 2 2 1 9 4 \n1 17 19 4\n1 3 8 5\n3 2\n2 4 10\n1 58 39 8\n2 62 36\n2 63 63\n1 6 21 1\n1 6 0 10\n2 3 1\n2 23 20\n1 7 19 2\n1 8 17 6\n1 0 7 2\n1 4 10 2\n1 12 17 1\n1 6 5 6\n1 19 17 10\n2 10 14\n1 28 28 2\n", "52\n54\n7\n30\n2\n22\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["O2优化"], "title": "Sabbat of the witch", "background": "您正在在游玩《魔女的夜宴》,突然开始思考一个哲学问题:这作的restart线到底算不算ntr？\n\n![](http://0d077ef9e74d8.cdn.sohucs.com/rcLQDT4_png)\n\n![](http://0d077ef9e74d8.cdn.sohucs.com/rcLQJyV_png)\n\n![](http://0d077ef9e74d8.cdn.sohucs.com/rcLQMrk_png)\n~~您在思索了很长时间之后,突然注意到这是个涉及到时间线和人格同一性的哲学问题~~\n\n此时您突然发现galgame和数(毒)据(瘤)结(分)构(块)有一些奥妙重重的关系，为了更好的思考这个问题，您决定去写一道数(毒)据(瘤)结(分)构(块)题", "description": "维护一个序列,支持以下三种操作\n\n1.区间赋值\n\n2.区间求和\n\n3.撤回之前的一个区间赋值操作\n\n**强制在线**\n\n注意：这里的撤回操作既不会影响之前的操作也不会影响之后的操作，换句话讲撤回一个操作之后序列将会变成历史上从来没有过被撤回操作的状态\n\n煮个栗子，假设我们对序列按顺序执行了1,2,3,4,5号操作\n\n当我们撤回操作4的时候，整个序列应该和按顺序执行了1,2,3,5操作之后的序列一样\n\n当我们接着撤回操作2的时候，整个序列应该和按顺序执行了1,3,5操作之后的序列一样\n\n\n\n\n\n", "inputFormat": "第一行两个整数$n,m$表示序列长度和操作个数\n\n第二行$n$个整数$a_{1}...a_{n}$其中$a_{i}$表示序列的第$i$项\n\n接下来$m$行\n\n如果这一行是$1,l,r,v$的话代表将$(l,r)$这段区间赋值成$v$,假如这个操作是第$k$次赋值操作，那么这个操作的编号就是$k$\n\n如果这一行是$2,l,r$的话代表询问$(l,r)$这段区间中数字的和\n\n如果这一行是$3,x$的话代表撤回编号为$x$的操作\n\n**数据保证被撤回的操作一定存在并且每个操作只会被撤回一次**\n\n为了体现题目的在线性，我们设lastans表示读入当前操作时最后一次询问的答案，(lastans的初始值为0)\n\n那么对于操作1,你需要操作的真实区间是$(l \\oplus lastans,r \\oplus lastans)$\n\n对于操作2,你需要询问的真实区间是$(l \\oplus lastans,r \\oplus lastans)$\n\n对于操作3,你需要撤回的操作编号是$x \\oplus lastans$\n\n其中$\\oplus$运算符表示异或运算\n\n", "outputFormat": "对于每一个操作2输出一行一个整数，表示询问区间中的元素之和\n\n为了方便你理解题意和调试，我们了准备两个样例，一个是强制在线的而另一个是非强制在线的(尽管本题没有非强制在线的部分分)", "hint": "对于第9,10个测试点,满足$n,m \\leq 10^4$，这两个测试点的分数都为1\n\n对于剩余的测试点$n,m \\leq 10^5$并且操作1的个数不超过$65000$\n\n保证输入的数字全部小于$10^9$", "locale": "zh-CN", "translations": {"en": {"title": "Sabbat of the witch", "background": "You are playing *Sabbat of the Witch* and suddenly start thinking about a philosophical question: does the restart route in this game count as NTR?\n\n~~After thinking for a long time, you suddenly realize this is a philosophical problem involving timelines and personal identity.~~\n\nThen you suddenly discover that galgames and data structures have some deeply mysterious connections. To think about this problem better, you decide to write a data structure problem.", "description": "Maintain a sequence and support the following three operations.\n\n1. Range assignment.\n2. Range sum query.\n3. Undo a previous range assignment operation.\n\n**Online only.**\n\nNote: this undo operation does not affect any operations before it, and also does not affect any operations after it. In other words, after undoing an operation, the sequence becomes the state as if the undone operation had never existed in history.\n\nFor example, suppose we apply operations $1,2,3,4,5$ in order.\n\n- When we undo operation $4$, the whole sequence should be the same as the sequence after applying operations $1,2,3,5$ in order.\n- When we then undo operation $2$, the whole sequence should be the same as the sequence after applying operations $1,3,5$ in order.", "inputFormat": "The first line contains two integers $n,m$, representing the length of the sequence and the number of operations.\n\nThe second line contains $n$ integers $a_{1}...a_{n}$, where $a_{i}$ is the $i$-th element of the sequence.\n\nNext $m$ lines:\n\n- If a line is $1,l,r,v$, it means assigning the interval $(l,r)$ to value $v$. If this operation is the $k$-th assignment operation, then its ID is $k$.\n- If a line is $2,l,r$, it means querying the sum of numbers in the interval $(l,r)$.\n- If a line is $3,x$, it means undoing the operation whose ID is $x$.\n\n**It is guaranteed that the undone operation always exists, and each operation will be undone at most once.**\n\nTo enforce the online requirement, let `lastans` be the answer of the most recent query at the time the current operation is read (`lastans` is initially $0$).\n\n- For operation 1, the real interval you need to modify is $(l \\oplus lastans,r \\oplus lastans)$.\n- For operation 2, the real interval you need to query is $(l \\oplus lastans,r \\oplus lastans)$.\n- For operation 3, the real operation ID you need to undo is $x \\oplus lastans$.\n\nHere $\\oplus$ denotes the XOR operation.", "outputFormat": "For each operation 2, output one integer per line, representing the sum of elements in the queried interval.\n\nTo help you understand the statement and debug, we prepared two samples: one is online-only and the other is not online-only (although this problem has no partial score for the non-online-only part).", "hint": "For test points 9 and 10, $n,m \\leq 10^4$. Each of these test points is worth 1 point.\n\nFor the remaining test points, $n,m \\leq 10^5$, and the number of operation 1 does not exceed $65000$.\n\nAll input numbers are guaranteed to be less than $10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Sabbat of the witch", "background": "您正在在游玩《魔女的夜宴》,突然开始思考一个哲学问题:这作的restart线到底算不算ntr？\n\n![](http://0d077ef9e74d8.cdn.sohucs.com/rcLQDT4_png)\n\n![](http://0d077ef9e74d8.cdn.sohucs.com/rcLQJyV_png)\n\n![](http://0d077ef9e74d8.cdn.sohucs.com/rcLQMrk_png)\n~~您在思索了很长时间之后,突然注意到这是个涉及到时间线和人格同一性的哲学问题~~\n\n此时您突然发现galgame和数(毒)据(瘤)结(分)构(块)有一些奥妙重重的关系，为了更好的思考这个问题，您决定去写一道数(毒)据(瘤)结(分)构(块)题", "description": "维护一个序列,支持以下三种操作\n\n1.区间赋值\n\n2.区间求和\n\n3.撤回之前的一个区间赋值操作\n\n**强制在线**\n\n注意：这里的撤回操作既不会影响之前的操作也不会影响之后的操作，换句话讲撤回一个操作之后序列将会变成历史上从来没有过被撤回操作的状态\n\n煮个栗子，假设我们对序列按顺序执行了1,2,3,4,5号操作\n\n当我们撤回操作4的时候，整个序列应该和按顺序执行了1,2,3,5操作之后的序列一样\n\n当我们接着撤回操作2的时候，整个序列应该和按顺序执行了1,3,5操作之后的序列一样\n\n\n\n\n\n", "inputFormat": "第一行两个整数$n,m$表示序列长度和操作个数\n\n第二行$n$个整数$a_{1}...a_{n}$其中$a_{i}$表示序列的第$i$项\n\n接下来$m$行\n\n如果这一行是$1,l,r,v$的话代表将$(l,r)$这段区间赋值成$v$,假如这个操作是第$k$次赋值操作，那么这个操作的编号就是$k$\n\n如果这一行是$2,l,r$的话代表询问$(l,r)$这段区间中数字的和\n\n如果这一行是$3,x$的话代表撤回编号为$x$的操作\n\n**数据保证被撤回的操作一定存在并且每个操作只会被撤回一次**\n\n为了体现题目的在线性，我们设lastans表示读入当前操作时最后一次询问的答案，(lastans的初始值为0)\n\n那么对于操作1,你需要操作的真实区间是$(l \\oplus lastans,r \\oplus lastans)$\n\n对于操作2,你需要询问的真实区间是$(l \\oplus lastans,r \\oplus lastans)$\n\n对于操作3,你需要撤回的操作编号是$x \\oplus lastans$\n\n其中$\\oplus$运算符表示异或运算\n\n", "outputFormat": "对于每一个操作2输出一行一个整数，表示询问区间中的元素之和\n\n为了方便你理解题意和调试，我们了准备两个样例，一个是强制在线的而另一个是非强制在线的(尽管本题没有非强制在线的部分分)", "hint": "对于第9,10个测试点,满足$n,m \\leq 10^4$，这两个测试点的分数都为1\n\n对于剩余的测试点$n,m \\leq 10^5$并且操作1的个数不超过$65000$\n\n保证输入的数字全部小于$10^9$", "locale": "zh-CN"}}}
{"pid": "P5114", "type": "P", "difficulty": 7, "samples": [["15 15\n29 -23 -14 -50 -13 -23 5 33 50 32 27 27 -9 -42 -11\n-37 39 21 50 10 -42 -2 25 1 28 40 -45 -24 -29 47\n0 0 1 0 0 1 1 0 0 1 0 1 0 0 0\n2 1\n3 1\n4 3\n5 2\n6 2\n7 2\n8 4\n9 1\n10 2\n11 5\n12 3\n13 5\n14 3\n15 9\n-8\n36\n44\n29\n-5\n-4\n-3\n-2\n-1\n0\n1\n2\n3\n4\n5\n", "679\n3252\n3988\n2608\n436\n355\n274\n199\n135\n126\n155\n232\n309\n386\n471\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["点分治", "凸包"], "title": "八月脸", "background": "Cdm1020 十分喜欢 August-soft 出品的游戏，在游玩 august 社历届作品的时候他突然发现了一些神奇的事实。\n\n**那就是所有的人物立绘的脸都是一样的!**\n\n\n![](https://i.loli.net/2018/09/17/5b9fb47a8b3e0.gif)\n\n不过尽管如此，作为一名资深的八月厨，他依然可以敏锐的分辨出各张立绘之间的细微差异 ~~（并不，就是同一张脸有什么好分辨的）~~，为了进一步研究八月社的立绘水平，Cdm1020 将八月社的所有立绘都放到了一颗树上 ~~（什么鬼啊）~~\n\n（如果你不知道什么是树的话，你可以将树理解为一个无环的无向连通图）\n\n具体来讲树上的每个节点仅保存了一张八月社的立绘，Cdm1020 通过和他的八月厨朋友们交流发现，狂热程度不同的八月厨对于同一张立绘的喜爱程度是不一样的，具体来讲每张立绘有两个属性 $a$ 和 $b$，对于一个狂热指数为 $k$ 的八月厨来讲，他对一张属性为 $(a,b)$ 的立绘的喜爱程度为 $ka+b$。\n\n现在 Cdm1020 想要带领他的 $m$ 个狂热指数不同的朋友参观八月社的立绘（们），他希望你对于他的每一个朋友，帮他规划出一条喜爱程度之和最大的游览路线。\n\n当然这个问题很简单，他是不会拿来烦你的。现在他真正头疼的事情是八月社新来了一个画师夏野。他的朋友们现在闹腾着想要看八月社的新立绘 ~~（反正还是一张脸有什么好看的）~~，所以他规定你的路线必须从一张属于 b 叔的立绘开始，到一张属于夏野的立绘结束，你能帮帮他吗？", "description": "**请忽略上面的鬼话，就当什么也没看见**\n\n一句话题意，给定一颗 $n$ 个点的树，树上每个点不是黑色就是白色，每个点有两个属性 $a$ 和 $b$。\n\n现在多组询问，每次询问仅给出一个参数 $k$，要求你从树上找出一条路径 $(u,v)$ 使得 $u$ 和 $v$ 的颜色不同并且\n\n$$k\\times \\sum_{p \\in path (u-v)}p.a+\\sum_{p\\in path(u-v)}p.b$$\n\n最大，对于每个询问你仅需要输出这个最大值即可（式子里面的两个和式的意思分别是路径上的点 $a$ 属性之和和路径上点的 $b$ 属性之和）。\n\n**tips: $a,b,k$ 均可正可负，并且我们不允许你不选路径，也就是说我们求出的的最大值可以是一个负数，这会发生在所有合法路径的权值都是负数的时候**。", "inputFormat": "第一行两个正整数 $n,m$ 表示树的节点个数和询问次数。\n\n接下来一行 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个点的 $a$ 属性的值。\n\n接下来一行 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个点的 $b$ 属性的值。\n\n接下来一行 $n$ 个整数，每个数要么为 $0$ 要么为 $1$，第 $i$ 个数为 $0$ 表示第 $i$ 个点是一个白色点，为 $1$ 表示第 $i$ 个点是一个黑色点。\n\n接下来 $n-1$ 行，每行两个正整数 $u,v$，表示存在一条从点 $u$ 到点 $v$ 的边。\n\n接下来 $m$ 行，每行一个整数 $k$ 表示询问的参数。", "outputFormat": "输出 $m$ 行，对于每一个询问，输出题目中给出式子的最大值。", "hint": "$2 \\leq n\\leq 10^5$，$1 \\leq m \\leq 10^5$，$-10^8 \\leq k \\leq 10^8 $\n\n保证不会存在所有点都是黑色或者都是白色的数据，保证对于树上的任意路径，路径上点的 $a$ 属性之和的绝对值不超过$1.5×10^9$，路径上点的 $b$ 属性之和的绝对值不超过 $1.5×10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "August Faces.", "background": "Cdm1020 really likes games made by August-soft. While playing August’s past works, he suddenly discovered some amazing facts.\n\n**That is, all character portraits have the same face!**\n\n![](https://i.loli.net/2018/09/17/5b9fb47a8b3e0.gif)\n\nEven so, as an experienced “August fan”, he can still sharply tell the tiny differences between portraits ~~(no, it’s the same face, what is there to tell)~~. To further study August’s portrait quality, Cdm1020 put all of August’s portraits onto a tree ~~(what on earth)~~.\n\n(If you do not know what a tree is, you can think of it as an undirected connected graph with no cycles.)\n\nMore specifically, each node on the tree stores exactly one portrait from August. After talking with his fellow fans, Cdm1020 found that fans with different “enthusiasm levels” like the same portrait differently. Each portrait has two attributes $a$ and $b$. For a fan whose enthusiasm index is $k$, their liking for a portrait with attributes $(a,b)$ is $ka+b$.\n\nNow Cdm1020 wants to lead his $m$ friends (with different enthusiasm indices) to visit the portraits. For each friend, he wants you to plan a visiting route with the maximum total liking.\n\nOf course, this problem is too easy, so he would not bother you with it. What really troubles him is that August has a new artist, Xiano (Xià Yě). His friends are now making noise and want to see August’s new portraits ~~(it is still the same face anyway, what is there to see)~~, so he requires that your route must start from a portrait by Uncle B and end at a portrait by Xiano. Can you help him?", "description": "**Please ignore the nonsense above and pretend you did not see anything.**\n\nIn one sentence: you are given a tree with $n$ nodes. Each node is either black or white, and each node has two attributes $a$ and $b$.\n\nNow there are multiple queries. Each query gives only one parameter $k$. You need to find a path $(u,v)$ in the tree such that $u$ and $v$ have different colors, and\n\n$$k\\times \\sum_{p \\in path (u-v)}p.a+\\sum_{p\\in path(u-v)}p.b$$\n\nis maximized. For each query, you only need to output this maximum value (the two summations mean the sum of attribute $a$ on the path and the sum of attribute $b$ on the path, respectively).\n\n**Tips: $a$, $b$, and $k$ can all be positive or negative, and you are not allowed to choose no path. That is, the maximum value we find may be negative. This happens when the weights of all valid paths are negative.**", "inputFormat": "The first line contains two positive integers $n,m$, representing the number of nodes in the tree and the number of queries.\n\nThe next line contains $n$ integers. The $i$-th integer is the value of attribute $a$ of node $i$.\n\nThe next line contains $n$ integers. The $i$-th integer is the value of attribute $b$ of node $i$.\n\nThe next line contains $n$ integers, each being either $0$ or $1$. If the $i$-th number is $0$, then node $i$ is a white node; if it is $1$, then node $i$ is a black node.\n\nThe next $n-1$ lines each contain two positive integers $u,v$, indicating that there is an edge between node $u$ and node $v$.\n\nThe next $m$ lines each contain one integer $k$, the parameter of the query.", "outputFormat": "Output $m$ lines. For each query, output the maximum value of the expression given in the statement.", "hint": "Constraints: $2 \\leq n\\leq 10^5$, $1 \\leq m \\leq 10^5$, $-10^8 \\leq k \\leq 10^8$.\n\nIt is guaranteed that there will not be testdata where all nodes are black or all nodes are white. It is guaranteed that for any path in the tree, the absolute value of the sum of attribute $a$ on the path does not exceed $1.5×10^9$, and the absolute value of the sum of attribute $b$ on the path does not exceed $1.5×10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "八月脸", "background": "Cdm1020 十分喜欢 August-soft 出品的游戏，在游玩 august 社历届作品的时候他突然发现了一些神奇的事实。\n\n**那就是所有的人物立绘的脸都是一样的!**\n\n\n![](https://i.loli.net/2018/09/17/5b9fb47a8b3e0.gif)\n\n不过尽管如此，作为一名资深的八月厨，他依然可以敏锐的分辨出各张立绘之间的细微差异 ~~（并不，就是同一张脸有什么好分辨的）~~，为了进一步研究八月社的立绘水平，Cdm1020 将八月社的所有立绘都放到了一颗树上 ~~（什么鬼啊）~~\n\n（如果你不知道什么是树的话，你可以将树理解为一个无环的无向连通图）\n\n具体来讲树上的每个节点仅保存了一张八月社的立绘，Cdm1020 通过和他的八月厨朋友们交流发现，狂热程度不同的八月厨对于同一张立绘的喜爱程度是不一样的，具体来讲每张立绘有两个属性 $a$ 和 $b$，对于一个狂热指数为 $k$ 的八月厨来讲，他对一张属性为 $(a,b)$ 的立绘的喜爱程度为 $ka+b$。\n\n现在 Cdm1020 想要带领他的 $m$ 个狂热指数不同的朋友参观八月社的立绘（们），他希望你对于他的每一个朋友，帮他规划出一条喜爱程度之和最大的游览路线。\n\n当然这个问题很简单，他是不会拿来烦你的。现在他真正头疼的事情是八月社新来了一个画师夏野。他的朋友们现在闹腾着想要看八月社的新立绘 ~~（反正还是一张脸有什么好看的）~~，所以他规定你的路线必须从一张属于 b 叔的立绘开始，到一张属于夏野的立绘结束，你能帮帮他吗？", "description": "**请忽略上面的鬼话，就当什么也没看见**\n\n一句话题意，给定一颗 $n$ 个点的树，树上每个点不是黑色就是白色，每个点有两个属性 $a$ 和 $b$。\n\n现在多组询问，每次询问仅给出一个参数 $k$，要求你从树上找出一条路径 $(u,v)$ 使得 $u$ 和 $v$ 的颜色不同并且\n\n$$k\\times \\sum_{p \\in path (u-v)}p.a+\\sum_{p\\in path(u-v)}p.b$$\n\n最大，对于每个询问你仅需要输出这个最大值即可（式子里面的两个和式的意思分别是路径上的点 $a$ 属性之和和路径上点的 $b$ 属性之和）。\n\n**tips: $a,b,k$ 均可正可负，并且我们不允许你不选路径，也就是说我们求出的的最大值可以是一个负数，这会发生在所有合法路径的权值都是负数的时候**。", "inputFormat": "第一行两个正整数 $n,m$ 表示树的节点个数和询问次数。\n\n接下来一行 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个点的 $a$ 属性的值。\n\n接下来一行 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个点的 $b$ 属性的值。\n\n接下来一行 $n$ 个整数，每个数要么为 $0$ 要么为 $1$，第 $i$ 个数为 $0$ 表示第 $i$ 个点是一个白色点，为 $1$ 表示第 $i$ 个点是一个黑色点。\n\n接下来 $n-1$ 行，每行两个正整数 $u,v$，表示存在一条从点 $u$ 到点 $v$ 的边。\n\n接下来 $m$ 行，每行一个整数 $k$ 表示询问的参数。", "outputFormat": "输出 $m$ 行，对于每一个询问，输出题目中给出式子的最大值。", "hint": "$2 \\leq n\\leq 10^5$，$1 \\leq m \\leq 10^5$，$-10^8 \\leq k \\leq 10^8 $\n\n保证不会存在所有点都是黑色或者都是白色的数据，保证对于树上的任意路径，路径上点的 $a$ 属性之和的绝对值不超过$1.5×10^9$，路径上点的 $b$ 属性之和的绝对值不超过 $1.5×10^9$。", "locale": "zh-CN"}}}
{"pid": "P5115", "type": "P", "difficulty": 7, "samples": [["aabccbbbcbbcbccacbcb\n8 20", "140"], ["checkcheckcheckonetwo\n7 11", "216"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["字符串", "O2优化"], "title": "Check,Check,Check one two!", "background": "您正在听くらげP的チェチェ・チェック・ワンツー!，突然教导主任推门进来了，于是您只好假装自己在写字符串题\n\n~~(结果教导主任一眼秒了这水题，您因没事刷水题被批判了一番)~~", "description": "给定一个字符串\n\n我们定义$lcp(i,j)$表示从字符串第$i$个位置开始的后缀和从第$j$个位置开始的后缀的最长公共前缀长度\n\n我们定义$lcs(i,j)$表示在字符串第$i$个位置结束的前缀和在第$j$个位置结束的前缀的最长公共后缀长度\n\n现在给定一个长度为$n$的字符串，希望您求出\n\n$$\\sum_{1\\leq i < j \\leq n}lcp(i,j)lcs(i,j)[lcp(i,j)\\leq k1][lcs(i,j) \\leq k2]$$\n\n模$2^{64}$的值(也就是unsigned long long自然溢出即可)\n\n$[lcs(i,j) \\leq k]$表示如果$lcs(i,j) \\leq k$这个命题为真那么这个式子的值是1否则是0,另外一个方括号也是同理\n\n", "inputFormat": "第一行一个字符串$S$,保证仅含有小写的英文字母\n\n第二行两个正整数$k1,k2$表示题目中的限制条件", "outputFormat": "仅一行一个正整数，表示题目中所给式子模$2^{64}$的值", "hint": "设n表示字符串的长度\n\n测试点10的分值为1,这个测试点的$n \\leq 1000$\n\n对于所有的测试点\n\n$$1 \\leq n \\leq 10^5,1\\leq k1 , k2 \\leq n$$", "locale": "zh-CN", "translations": {"en": {"title": "Check, Check, Check one two!", "background": "You are listening to くらげP’s チェチェ・チェック・ワンツー!, and suddenly the head teacher pushes the door open. So you have to pretend that you are working on a string problem.\n\n~~(But the head teacher sees through this easy problem at a glance, and you get criticized for doing easy problems when you had nothing to do.)~~", "description": "You are given a string.\n\nWe define $lcp(i,j)$ as the length of the longest common prefix of the suffix starting at position $i$ of the string and the suffix starting at position $j$.\n\nWe define $lcs(i,j)$ as the length of the longest common suffix of the prefix ending at position $i$ of the string and the prefix ending at position $j$.\n\nNow you are given a string of length $n$, and you need to compute\n\n$$\\sum_{1\\leq i < j \\leq n}lcp(i,j)lcs(i,j)[lcp(i,j)\\leq k1][lcs(i,j) \\leq k2]$$\n\nmodulo $2^{64}$ (that is, natural overflow of unsigned long long is sufficient).\n\n$[lcs(i,j) \\leq k]$ means that if the proposition $lcs(i,j) \\leq k$ is true, then this term equals 1; otherwise it equals 0. The other bracket is defined similarly.", "inputFormat": "The first line contains a string $S$, guaranteed to consist only of lowercase English letters.\n\nThe second line contains two positive integers $k1,k2$, representing the constraints in the statement.", "outputFormat": "Output a single positive integer, which is the value of the given expression modulo $2^{64}$.", "hint": "Let $n$ denote the length of the string.\n\nTest point 10 is worth 1 point, and for this test point, $n \\leq 1000$.\n\nFor all test points,\n\n$$1 \\leq n \\leq 10^5,1\\leq k1 , k2 \\leq n$$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Check,Check,Check one two!", "background": "您正在听くらげP的チェチェ・チェック・ワンツー!，突然教导主任推门进来了，于是您只好假装自己在写字符串题\n\n~~(结果教导主任一眼秒了这水题，您因没事刷水题被批判了一番)~~", "description": "给定一个字符串\n\n我们定义$lcp(i,j)$表示从字符串第$i$个位置开始的后缀和从第$j$个位置开始的后缀的最长公共前缀长度\n\n我们定义$lcs(i,j)$表示在字符串第$i$个位置结束的前缀和在第$j$个位置结束的前缀的最长公共后缀长度\n\n现在给定一个长度为$n$的字符串，希望您求出\n\n$$\\sum_{1\\leq i < j \\leq n}lcp(i,j)lcs(i,j)[lcp(i,j)\\leq k1][lcs(i,j) \\leq k2]$$\n\n模$2^{64}$的值(也就是unsigned long long自然溢出即可)\n\n$[lcs(i,j) \\leq k]$表示如果$lcs(i,j) \\leq k$这个命题为真那么这个式子的值是1否则是0,另外一个方括号也是同理\n\n", "inputFormat": "第一行一个字符串$S$,保证仅含有小写的英文字母\n\n第二行两个正整数$k1,k2$表示题目中的限制条件", "outputFormat": "仅一行一个正整数，表示题目中所给式子模$2^{64}$的值", "hint": "设n表示字符串的长度\n\n测试点10的分值为1,这个测试点的$n \\leq 1000$\n\n对于所有的测试点\n\n$$1 \\leq n \\leq 10^5,1\\leq k1 , k2 \\leq n$$", "locale": "zh-CN"}}}
{"pid": "P5116", "type": "P", "difficulty": 2, "samples": [["10 3\n11 4\n12 5", "0\n10\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2018", "USACO"], "title": "[USACO18DEC] Mixing Milk B", "background": "", "description": "农业，尤其是生产牛奶，是一个竞争激烈的行业。Farmer John 发现如果他不在牛奶生产工艺上有所创新，他的乳制品生意可能就会受到重创！\n\n幸运的是，Farmer John 想出了一个好主意。他的三头获奖的乳牛，Bessie、Elsie 和 Mildred，各自产奶的口味有些许不同，他打算混合这三种牛奶调制出完美的口味。\n\n为了混合这三种不同的牛奶，他拿来三个桶，其中分别装有三头奶牛所产的奶。这些桶可能有不同的容积，也可能并没有完全装满。然后他将桶 $1$ 的牛奶倒入桶 $2$，然后将桶 $2$ 中的牛奶倒入桶 $3$，然后将桶 $3$ 中的牛奶倒入桶 $1$，然后再将桶 $1$ 的牛奶倒入桶 $2$，如此周期性地操作，共计进行 $100$ 次（所以第 $100$ 次操作会是桶 $1$ 倒入桶 $2$）。当 Farmer John 将桶 $a$ 中的牛奶倒入桶 $b$ 时，他会倒出尽可能多的牛奶，直到桶 $a$ 被倒空或是桶 $b$ 被倒满。\n\n请告诉 Farmer John 当他倒了 $100$ 次之后每个桶里将会有多少牛奶。\n\n", "inputFormat": "输入文件的第一行包含两个空格分隔的整数：第一个桶的容积 $c_1$，以及第一个桶里的牛奶量 $m_1$。$c_1$ 和 $m_1$ 均为正，并且不超过 $10^9$。第二和第三行类似地包含第二和第三个桶地容积和牛奶量。", "outputFormat": "输出三行，给出倒了 $100$ 次之后每个桶里的牛奶量。", "hint": "在这个例子中，每倒一次之后每个桶里的牛奶量如下：\n\n0. 初始状态：3  4  5\n1. 桶 1->2：0  7  5\n2. 桶 2->3：0  0  12\n3. 桶 3->1：10 0  2\n4. 桶 1->2：0  10 2\n5. 桶 2->3：0  0  12\n\n（之后最后三个状态循环出现……）", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18DEC] Mixing Milk B", "background": "", "description": "Farming, especially milk production, is a highly competitive industry. Farmer John realizes that if he does not innovate in the milk production process, his dairy business could suffer a major blow.\n\nFortunately, Farmer John has come up with a great idea. His three award-winning cows, Bessie, Elsie, and Mildred, produce milk with slightly different flavors, and he plans to mix these three kinds of milk to create the perfect taste.\n\nTo mix these three different kinds of milk, he uses three buckets, each containing the milk produced by one of the cows. These buckets may have different capacities, and they may not be completely full. Then he pours the milk from bucket $1$ into bucket $2$, then pours the milk from bucket $2$ into bucket $3$, then pours the milk from bucket $3$ into bucket $1$, then pours the milk from bucket $1$ into bucket $2$, and so on in a cycle, for a total of $100$ pours (so the $100$-th operation will be bucket $1$ poured into bucket $2$). When Farmer John pours milk from bucket $a$ into bucket $b$, he pours as much as possible until bucket $a$ is empty or bucket $b$ is full.\n\nPlease tell Farmer John how much milk will be in each bucket after he has poured $100$ times.", "inputFormat": "The first line of the input file contains two space-separated integers: the capacity of the first bucket $c_1$, and the amount of milk in the first bucket $m_1$. Both $c_1$ and $m_1$ are positive and do not exceed $10^9$. The second and third lines similarly contain the capacities and milk amounts for the second and third buckets.", "outputFormat": "Output three lines, giving the amount of milk in each bucket after $100$ pours.", "hint": "In this example, after each pour, the amounts of milk in the buckets are as follows.\n\n0. Initial state: 3  4  5  \n1. Bucket 1->2: 0  7  5  \n2. Bucket 2->3: 0  0  12  \n3. Bucket 3->1: 10 0  2  \n4. Bucket 1->2: 0  10 2  \n5. Bucket 2->3: 0  0  12  \n\n(The last three states then repeat in a cycle.)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18DEC] Mixing Milk B", "background": "", "description": "农业，尤其是生产牛奶，是一个竞争激烈的行业。Farmer John 发现如果他不在牛奶生产工艺上有所创新，他的乳制品生意可能就会受到重创！\n\n幸运的是，Farmer John 想出了一个好主意。他的三头获奖的乳牛，Bessie、Elsie 和 Mildred，各自产奶的口味有些许不同，他打算混合这三种牛奶调制出完美的口味。\n\n为了混合这三种不同的牛奶，他拿来三个桶，其中分别装有三头奶牛所产的奶。这些桶可能有不同的容积，也可能并没有完全装满。然后他将桶 $1$ 的牛奶倒入桶 $2$，然后将桶 $2$ 中的牛奶倒入桶 $3$，然后将桶 $3$ 中的牛奶倒入桶 $1$，然后再将桶 $1$ 的牛奶倒入桶 $2$，如此周期性地操作，共计进行 $100$ 次（所以第 $100$ 次操作会是桶 $1$ 倒入桶 $2$）。当 Farmer John 将桶 $a$ 中的牛奶倒入桶 $b$ 时，他会倒出尽可能多的牛奶，直到桶 $a$ 被倒空或是桶 $b$ 被倒满。\n\n请告诉 Farmer John 当他倒了 $100$ 次之后每个桶里将会有多少牛奶。\n\n", "inputFormat": "输入文件的第一行包含两个空格分隔的整数：第一个桶的容积 $c_1$，以及第一个桶里的牛奶量 $m_1$。$c_1$ 和 $m_1$ 均为正，并且不超过 $10^9$。第二和第三行类似地包含第二和第三个桶地容积和牛奶量。", "outputFormat": "输出三行，给出倒了 $100$ 次之后每个桶里的牛奶量。", "hint": "在这个例子中，每倒一次之后每个桶里的牛奶量如下：\n\n0. 初始状态：3  4  5\n1. 桶 1->2：0  7  5\n2. 桶 2->3：0  0  12\n3. 桶 3->1：10 0  2\n4. 桶 1->2：0  10 2\n5. 桶 2->3：0  0  12\n\n（之后最后三个状态循环出现……）", "locale": "zh-CN"}}}
{"pid": "P5117", "type": "P", "difficulty": 2, "samples": [["3\n4 10 1\n8 13 3\n2 6 2", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2018", "USACO", "差分"], "title": "[USACO18DEC] The Bucket List B", "background": "", "description": "Farmer John 正在考虑改变他给奶牛挤奶的时候分配牛奶桶的方式。他认为这最终能使得他使用数量更少的桶，然而他不清楚具体是多少。请帮助他！\n\nFarmer John 有 $N$ 头奶牛（$1\\le N\\le 100$），方便起见编号为 $1\\dots N$。 第 $i$ 头奶牛需要从时间 $s_i$ 到时间 $t_i$ 之间挤奶，并且挤奶过程中需要用到 $b_i$ 个桶。于是多头奶牛可能在同一时刻都在挤奶；如果这样，他们不能使用相同的桶。也就是说，一个在第 $i$ 头奶牛挤奶时用的桶不可以被任何在时间 $s_i$ 到时间 $t_i$ 之间挤奶的其他奶牛使用。当然，这个桶在这段时间之外可以被其他奶牛所使用。为了简化他的工作，FJ 保证在任一时刻，至多只有一头奶牛开始或是结束挤奶（也就是说，所有的 $s_i$ 和 $t_i$ 各不相同）。\n\nFJ 有一个储藏室，里面有依次编号为 $1$、$2$、$3$、……的桶。在他的挤奶策略中，当某一头奶牛（比如说，奶牛 $i$）开始挤奶（在时间 $s_i$），FJ 就跑到储藏室取出编号最小的 $b_i$ 个桶分配给第i头奶牛用来挤奶。\n\n请求出 FJ 需要在储藏室中存放多少个桶才能使得他能够顺利地给所有奶牛挤奶。\n", "inputFormat": "输入的第一行包含 $N$。以下 $N$ 行，每行描述了一头奶牛，包含三个空格分隔的数 $s_i$，$t_i$，和 $b_i$。 其中 $s_i$ 和 $t_i$ 均为 $1\\dots 1000$ 之间的整数，$b_i$ 为 $1\\dots 10$ 之间的整数。", "outputFormat": "输出一个整数，为 FJ 需要的桶的数量。", "hint": "在这个例子中，FJ 需要 $4$ 个桶：他用桶 $1$ 和桶 $2$ 来给奶牛 $3$ 挤奶（从时间 $2$ 开始）。他用桶 $3$ 给奶牛 $1$ 挤奶（从时间 $4$ 开始）。当奶牛 $2$ 在时间 $8$ 开始挤奶时，桶 $1$ 和桶 $2$ 可以再次利用，然而桶 $3$ 不可以，所以他会使用桶 $1$、桶 $2$ 和桶 $4$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18DEC] The Bucket List B", "background": "", "description": "Farmer John is considering changing the way he assigns milk buckets when milking his cows. He believes this might let him use fewer buckets overall, but he does not know how many. Please help him.\n\nFarmer John has $N$ cows ($1\\le N\\le 100$), numbered $1\\dots N$ for convenience. Cow $i$ needs to be milked from time $s_i$ to time $t_i$, and during milking it requires $b_i$ buckets. Therefore, multiple cows may be milking at the same time; if so, they cannot share the same buckets. In other words, a bucket used for cow $i$ cannot be used by any other cow that is being milked during the time interval from $s_i$ to $t_i$. Of course, that bucket can be used by other cows outside this time period. To simplify his work, FJ guarantees that at any moment, at most one cow starts or ends milking (that is, all $s_i$ and $t_i$ are pairwise distinct).\n\nFJ has a storage room with buckets numbered $1$, $2$, $3$, $\\dots$ in order. Under his milking strategy, when a cow (say, cow $i$) starts milking (at time $s_i$), FJ goes to the storage room and takes the smallest-numbered $b_i$ buckets to assign to cow $i$ for milking.\n\nCompute how many buckets FJ needs to store so that he can successfully milk all cows.", "inputFormat": "The first line contains $N$. The next $N$ lines each describe one cow, containing three space-separated numbers $s_i$, $t_i$, and $b_i$. Here $s_i$ and $t_i$ are integers between $1\\dots 1000$, and $b_i$ is an integer between $1\\dots 10$.", "outputFormat": "Output one integer: the number of buckets FJ needs.", "hint": "In this example, FJ needs $4$ buckets. He uses buckets $1$ and $2$ to milk cow $3$ (starting at time $2$). He uses bucket $3$ to milk cow $1$ (starting at time $4$). When cow $2$ starts milking at time $8$, buckets $1$ and $2$ can be reused, but bucket $3$ cannot, so he will use buckets $1$, $2$, and $4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18DEC] The Bucket List B", "background": "", "description": "Farmer John 正在考虑改变他给奶牛挤奶的时候分配牛奶桶的方式。他认为这最终能使得他使用数量更少的桶，然而他不清楚具体是多少。请帮助他！\n\nFarmer John 有 $N$ 头奶牛（$1\\le N\\le 100$），方便起见编号为 $1\\dots N$。 第 $i$ 头奶牛需要从时间 $s_i$ 到时间 $t_i$ 之间挤奶，并且挤奶过程中需要用到 $b_i$ 个桶。于是多头奶牛可能在同一时刻都在挤奶；如果这样，他们不能使用相同的桶。也就是说，一个在第 $i$ 头奶牛挤奶时用的桶不可以被任何在时间 $s_i$ 到时间 $t_i$ 之间挤奶的其他奶牛使用。当然，这个桶在这段时间之外可以被其他奶牛所使用。为了简化他的工作，FJ 保证在任一时刻，至多只有一头奶牛开始或是结束挤奶（也就是说，所有的 $s_i$ 和 $t_i$ 各不相同）。\n\nFJ 有一个储藏室，里面有依次编号为 $1$、$2$、$3$、……的桶。在他的挤奶策略中，当某一头奶牛（比如说，奶牛 $i$）开始挤奶（在时间 $s_i$），FJ 就跑到储藏室取出编号最小的 $b_i$ 个桶分配给第i头奶牛用来挤奶。\n\n请求出 FJ 需要在储藏室中存放多少个桶才能使得他能够顺利地给所有奶牛挤奶。\n", "inputFormat": "输入的第一行包含 $N$。以下 $N$ 行，每行描述了一头奶牛，包含三个空格分隔的数 $s_i$，$t_i$，和 $b_i$。 其中 $s_i$ 和 $t_i$ 均为 $1\\dots 1000$ 之间的整数，$b_i$ 为 $1\\dots 10$ 之间的整数。", "outputFormat": "输出一个整数，为 FJ 需要的桶的数量。", "hint": "在这个例子中，FJ 需要 $4$ 个桶：他用桶 $1$ 和桶 $2$ 来给奶牛 $3$ 挤奶（从时间 $2$ 开始）。他用桶 $3$ 给奶牛 $1$ 挤奶（从时间 $4$ 开始）。当奶牛 $2$ 在时间 $8$ 开始挤奶时，桶 $1$ 和桶 $2$ 可以再次利用，然而桶 $3$ 不可以，所以他会使用桶 $1$、桶 $2$ 和桶 $4$。", "locale": "zh-CN"}}}
{"pid": "P5118", "type": "P", "difficulty": 3, "samples": [["1 1 1 1 1 1 1 1 1 2\n5 5 5 5 5 5 5 5 5 5", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "2018", "USACO", "枚举"], "title": "[USACO18DEC] Back and Forth B", "background": "", "description": "Farmer John 有两个挤奶棚，每个挤奶棚里各有一个奶罐和一个装有 $10$ 个各种尺寸的桶的储物柜。他喜欢将在两个挤奶棚之间来回运送牛奶作为一种锻炼方式。\n\n周一，Farmer John 量了恰好 $1000$ 加仑的牛奶放在第一个挤奶棚的奶罐里，又量了恰好 $1000$ 加仑的牛奶放在第二个挤奶棚的奶罐里。\n\n周二，他从第一个挤奶棚里取出一个桶，并装满牛奶，然后将牛奶运到第二个挤奶棚，并将牛奶倒进奶罐。他把这个桶留在了第二个挤奶棚。\n\n周三，他从第二个挤奶棚里取出一个桶（可能是周二留在这里的），并装满牛奶，然后将牛奶运到第一个挤奶棚，并将牛奶倒进奶罐。他把这个桶留在了第一个挤奶棚。\n\n周四，他从第一个挤奶棚里取出一个桶（可能是周三留在这里的），并装满牛奶，然后将牛奶运到第二个挤奶棚，并将牛奶倒进奶罐。他把这个桶留在了第二个挤奶棚。\n\n周五，他从第二个挤奶棚里取出一个桶（可能是周二或周四留在这里的），并装满牛奶，然后将牛奶运到第一个挤奶棚，并将牛奶倒进奶罐。他把这个桶留在了第一个挤奶棚。\n\n此时 Farmer John 测量了第一个挤奶棚的奶罐里的牛奶。他总共可能得到多少种不同的读数？\n", "inputFormat": "输入的第一行包含 $10$ 个整数，为第一个挤奶棚里初始的桶的容积。输入的第二行也包含 $10$ 个整数，为第二个挤奶棚里初始的桶的容积。 所有桶的容积均在 $1\\dots 100$ 的范围内。", "outputFormat": "输出 Farmer John 在周五之后测量第一个挤奶棚里的奶罐的牛奶时可能得到的读数的数量。", "hint": "在这个例子中，最后第一个挤奶棚的奶罐中的牛奶量总共有 $5$ 种可能的结果：\n\n$1000$：FJ 可以在每次往返的时候都携带同一个桶，从而不会改变第一个挤奶棚的奶罐的牛奶量。\n\n$1003$：FJ 可以在周二运送 $2$ 个单位，周三 $5$ 个单位，周四 $1$ 个单位，周五 $1$ 个单位。\n\n$1004$：FJ 可以在周二运送 $1$ 个单位，周三 $5$ 个单位，周四 $1$ 个单位，周五 $1$ 个单位。\n\n$1007$：FJ 可以在周二运送 $1$ 个单位，周三 $5$ 个单位，周四 $2$ 个单位，周五 $5$ 个单位。\n\n$1008$：FJ 可以在周二运送 $1$ 个单位，周三 $5$ 个单位，周四 $1$ 个单位，周五 $5$ 个单位。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18DEC] Back and Forth B", "background": "", "description": "Farmer John has two milking barns. In each barn, there is a milk tank and a storage cabinet holding $10$ buckets of various sizes. He likes to carry milk back and forth between the two barns as a form of exercise.\n\nOn Monday, Farmer John measured exactly $1000$ gallons of milk into the tank in the first barn, and also measured exactly $1000$ gallons of milk into the tank in the second barn.\n\nOn Tuesday, he takes one bucket from the first barn, fills it with milk, then carries the milk to the second barn and pours it into the tank. He leaves this bucket in the second barn.\n\nOn Wednesday, he takes one bucket from the second barn (possibly the one left there on Tuesday), fills it with milk, then carries the milk to the first barn and pours it into the tank. He leaves this bucket in the first barn.\n\nOn Thursday, he takes one bucket from the first barn (possibly the one left there on Wednesday), fills it with milk, then carries the milk to the second barn and pours it into the tank. He leaves this bucket in the second barn.\n\nOn Friday, he takes one bucket from the second barn (possibly the one left there on Tuesday or Thursday), fills it with milk, then carries the milk to the first barn and pours it into the tank. He leaves this bucket in the first barn.\n\nAt this point, Farmer John measures the milk in the tank in the first barn. How many different readings could he possibly get in total?", "inputFormat": "The first line contains $10$ integers, the capacities of the buckets initially in the first barn. The second line also contains $10$ integers, the capacities of the buckets initially in the second barn. All bucket capacities are in the range $1\\dots 100$.", "outputFormat": "Output the number of possible readings Farmer John could get when measuring the milk in the tank in the first barn after Friday.", "hint": "In this example, there are $5$ possible final amounts of milk in the first barn's tank:\n\n$1000$: FJ can carry the same bucket on every trip, so the amount of milk in the first barn's tank does not change.\n\n$1003$: FJ can move $2$ units on Tuesday, $5$ units on Wednesday, $1$ unit on Thursday, and $1$ unit on Friday.\n\n$1004$: FJ can move $1$ unit on Tuesday, $5$ units on Wednesday, $1$ unit on Thursday, and $1$ unit on Friday.\n\n$1007$: FJ can move $1$ unit on Tuesday, $5$ units on Wednesday, $2$ units on Thursday, and $5$ units on Friday.\n\n$1008$: FJ can move $1$ unit on Tuesday, $5$ units on Wednesday, $1$ unit on Thursday, and $5$ units on Friday.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18DEC] Back and Forth B", "background": "", "description": "Farmer John 有两个挤奶棚，每个挤奶棚里各有一个奶罐和一个装有 $10$ 个各种尺寸的桶的储物柜。他喜欢将在两个挤奶棚之间来回运送牛奶作为一种锻炼方式。\n\n周一，Farmer John 量了恰好 $1000$ 加仑的牛奶放在第一个挤奶棚的奶罐里，又量了恰好 $1000$ 加仑的牛奶放在第二个挤奶棚的奶罐里。\n\n周二，他从第一个挤奶棚里取出一个桶，并装满牛奶，然后将牛奶运到第二个挤奶棚，并将牛奶倒进奶罐。他把这个桶留在了第二个挤奶棚。\n\n周三，他从第二个挤奶棚里取出一个桶（可能是周二留在这里的），并装满牛奶，然后将牛奶运到第一个挤奶棚，并将牛奶倒进奶罐。他把这个桶留在了第一个挤奶棚。\n\n周四，他从第一个挤奶棚里取出一个桶（可能是周三留在这里的），并装满牛奶，然后将牛奶运到第二个挤奶棚，并将牛奶倒进奶罐。他把这个桶留在了第二个挤奶棚。\n\n周五，他从第二个挤奶棚里取出一个桶（可能是周二或周四留在这里的），并装满牛奶，然后将牛奶运到第一个挤奶棚，并将牛奶倒进奶罐。他把这个桶留在了第一个挤奶棚。\n\n此时 Farmer John 测量了第一个挤奶棚的奶罐里的牛奶。他总共可能得到多少种不同的读数？\n", "inputFormat": "输入的第一行包含 $10$ 个整数，为第一个挤奶棚里初始的桶的容积。输入的第二行也包含 $10$ 个整数，为第二个挤奶棚里初始的桶的容积。 所有桶的容积均在 $1\\dots 100$ 的范围内。", "outputFormat": "输出 Farmer John 在周五之后测量第一个挤奶棚里的奶罐的牛奶时可能得到的读数的数量。", "hint": "在这个例子中，最后第一个挤奶棚的奶罐中的牛奶量总共有 $5$ 种可能的结果：\n\n$1000$：FJ 可以在每次往返的时候都携带同一个桶，从而不会改变第一个挤奶棚的奶罐的牛奶量。\n\n$1003$：FJ 可以在周二运送 $2$ 个单位，周三 $5$ 个单位，周四 $1$ 个单位，周五 $1$ 个单位。\n\n$1004$：FJ 可以在周二运送 $1$ 个单位，周三 $5$ 个单位，周四 $1$ 个单位，周五 $1$ 个单位。\n\n$1007$：FJ 可以在周二运送 $1$ 个单位，周三 $5$ 个单位，周四 $2$ 个单位，周五 $5$ 个单位。\n\n$1008$：FJ 可以在周二运送 $1$ 个单位，周三 $5$ 个单位，周四 $1$ 个单位，周五 $5$ 个单位。", "locale": "zh-CN"}}}
{"pid": "P5119", "type": "P", "difficulty": 3, "samples": [["6 3 2\n1 1 10 14 4 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "二分", "USACO"], "title": "[USACO18DEC] Convention S", "background": "", "description": "一场别开生面的牛吃草大会就要在 Farmer John 的农场举办了！\n\n世界各地的奶牛将会到达当地的机场，前来参会并且吃草。具体地说，有 $N$ 头奶牛到达了机场（$1\\le N\\le 10^5$），其中奶牛 $i$ 在时间 $t_i$（$0\\le t_i\\le 10^9$）到达。Farmer John 安排了 $M$（$1\\le M\\le 10^5$）辆大巴来机场接这些奶牛。每辆大巴可以乘坐 $C$ 头奶牛（$1\\le C\\le N$）。Farmer John 正在机场等待奶牛们到来，并且准备安排到达的奶牛们乘坐大巴。当最后一头乘坐某辆大巴的奶牛到达的时候，这辆大巴就可以发车了。Farmer John 想要做一个优秀的主办者，所以并不想让奶牛们在机场等待过长的时间。如果 Farmer John 合理地协调这些大巴，等待时间最长的奶牛等待的时间的最小值是多少？一头奶牛的等待时间等于她的到达时间与她乘坐的大巴的发车时间之差。\n\n输入保证 $MC\\ge N$。", "inputFormat": "输入的第一行包含三个空格分隔的整数 $N$，$M$，和 $C$。第二行包含 $N$ 个空格分隔的整数，表示每头奶牛到达的时间。", "outputFormat": "输出一行，包含所有到达的奶牛中的最大等待时间的最小值。", "hint": "如果两头时间 $1$ 到达的奶牛乘坐一辆巴士，时间 $3$ 和时间 $4$ 到达的奶牛乘坐乘坐第二辆，时间 $10$ 和时间 $14$ 到达的奶牛乘坐第三辆，那么等待时间最长的奶牛等待了 $4$ 个单位时间（时间 $10$ 到达的奶牛从时间 $10$ 等到了时间 $14$）。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18DEC] Convention S", "background": "", "description": "A unique cow grass-eating convention is about to be held at Farmer John’s farm.\n\nCows from all over the world will arrive at the local airport to attend the convention and eat grass. Specifically, there are $N$ cows arriving at the airport ($1\\le N\\le 10^5$), and cow $i$ arrives at time $t_i$ ($0\\le t_i\\le 10^9$). Farmer John has arranged $M$ buses ($1\\le M\\le 10^5$) to pick up these cows at the airport. Each bus can carry $C$ cows ($1\\le C\\le N$). Farmer John is waiting at the airport and plans to assign arriving cows to buses. When the last cow assigned to a bus arrives, that bus can depart. Farmer John wants to be a good host, so he does not want the cows to wait at the airport for too long. If Farmer John schedules the buses optimally, what is the minimum possible value of the maximum waiting time among all cows? A cow’s waiting time is the difference between her arrival time and the departure time of the bus she takes.\n\nThe input guarantees that $MC\\ge N$.", "inputFormat": "The first line contains three space-separated integers $N$, $M$, and $C$. The second line contains $N$ space-separated integers, representing the arrival time of each cow.", "outputFormat": "Output one line containing the minimum possible value of the maximum waiting time among all arriving cows.", "hint": "If two cows arriving at time $1$ take the first bus, the cows arriving at times $3$ and $4$ take the second bus, and the cows arriving at times $10$ and $14$ take the third bus, then the cow with the longest waiting time waits for $4$ units of time (the cow arriving at time $10$ waits from time $10$ until time $14$).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18DEC] Convention S", "background": "", "description": "一场别开生面的牛吃草大会就要在 Farmer John 的农场举办了！\n\n世界各地的奶牛将会到达当地的机场，前来参会并且吃草。具体地说，有 $N$ 头奶牛到达了机场（$1\\le N\\le 10^5$），其中奶牛 $i$ 在时间 $t_i$（$0\\le t_i\\le 10^9$）到达。Farmer John 安排了 $M$（$1\\le M\\le 10^5$）辆大巴来机场接这些奶牛。每辆大巴可以乘坐 $C$ 头奶牛（$1\\le C\\le N$）。Farmer John 正在机场等待奶牛们到来，并且准备安排到达的奶牛们乘坐大巴。当最后一头乘坐某辆大巴的奶牛到达的时候，这辆大巴就可以发车了。Farmer John 想要做一个优秀的主办者，所以并不想让奶牛们在机场等待过长的时间。如果 Farmer John 合理地协调这些大巴，等待时间最长的奶牛等待的时间的最小值是多少？一头奶牛的等待时间等于她的到达时间与她乘坐的大巴的发车时间之差。\n\n输入保证 $MC\\ge N$。", "inputFormat": "输入的第一行包含三个空格分隔的整数 $N$，$M$，和 $C$。第二行包含 $N$ 个空格分隔的整数，表示每头奶牛到达的时间。", "outputFormat": "输出一行，包含所有到达的奶牛中的最大等待时间的最小值。", "hint": "如果两头时间 $1$ 到达的奶牛乘坐一辆巴士，时间 $3$ 和时间 $4$ 到达的奶牛乘坐乘坐第二辆，时间 $10$ 和时间 $14$ 到达的奶牛乘坐第三辆，那么等待时间最长的奶牛等待了 $4$ 个单位时间（时间 $10$ 到达的奶牛从时间 $10$ 等到了时间 $14$）。", "locale": "zh-CN"}}}
{"pid": "P5120", "type": "P", "difficulty": 3, "samples": [["5\n25 3\n105 30\n20 50\n10 17\n100 10", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2018", "USACO", "堆"], "title": "[USACO18DEC] Convention II S", "background": null, "description": "虽然在接机上耽误了挺长时间，Farmer John 为吃草爱好牛们举行的大会至今为止都非常顺利。大会吸引了世界各地的奶牛。\n\n然而大会的重头戏看起来却给 Farmer John 带来了一些新的安排上的困扰。他的农场上的一块非常小的牧草地出产一种据某些识货的奶牛说是世界上最美味的品种的草。因此，所有参会的 $N$ 头奶牛（$1\\le N\\le 10^5$）都想要品尝一下这种草。由于这块牧草地小到仅能容纳一头奶牛，这很有可能会导致排起长龙。\n\nFarmer John 知道每头奶牛 $i$ 计划到达这块特殊的牧草地的时间 $a_i$，以及当轮到她时，她计划品尝这种草花费的时间 $t_i$。当奶牛 $i$ 开始吃草时，她会在离开前花费全部 $t_i$ 的时间，此时其他到达的奶牛需要排队等候。如果这块牧草地空出来的时候多头奶牛同时在等候，那么资历最深的奶牛将会是下一头品尝鲜草的奶牛。在这里，恰好在另一头奶牛吃完草离开时到达的奶牛被认为是“在等待的”。类似地，如果当没有奶牛在吃草的时候有多头奶牛同时到达，那么资历最深的奶牛是下一头吃草的奶牛。\n\n请帮助 FJ 计算所有奶牛中在队伍里等待的时间（$a_i$ 到这头奶牛开始吃草之间的时间）的最大值。", "inputFormat": "输入的第一行包含 $N$。以下 $N$ 行按资历顺序给出了 $N$ 头奶牛的信息（资历最深的奶牛排在最前面）。每行包含一头奶牛的 $a_i$ 和 $t_i$。所有的 $t_i$ 为不超过 $10^4$ 的正整数，所有 $a_i$ 为不超过 $10^9$ 的正整数。", "outputFormat": "输出所有奶牛中的最长等待时间。", "hint": "在这个例子中，我们有 $5$ 头奶牛（按输入中的顺序编号为 $1\\dots 5$）。奶牛 $4$ 最先到达（时间 $10$），在她吃完之前（时间 $27$）奶牛 $1$ 和奶牛 $3$ 都到达了。由于奶牛 $1$ 拥有较深的资历，所以她先吃，从她到达开始共计等待了 $2$ 个单位时间。她在时间 $30$ 结束吃草，随后奶牛 $3$ 开始吃草，从她到达开始共计等待了 $10$ 单位时间。在一段没有奶牛吃草的时间过后，奶牛 $5$ 到达，在她正在吃草的时间里奶牛 $2$ 也到达了，在 $5$ 个单位时间之后能够吃到草。相比到达时间等待最久的奶牛是奶牛 $3$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18DEC] Convention II S", "background": "", "description": "Although Farmer John was delayed for quite a long time picking up arrivals at the airport, the convention he is holding for his grass-loving cows has been going very smoothly so far. The convention has attracted cows from all over the world.\n\nHowever, the highlight of the convention now seems to have caused Farmer John some new scheduling trouble. A very small pasture on his farm produces a type of grass that, according to some knowledgeable cows, is the most delicious in the world. Therefore, all $N$ cows ($1\\le N\\le 10^5$) attending the convention want to taste this grass. Since the pasture is so small that it can only hold one cow, this may cause a long line.\n\nFarmer John knows the time $a_i$ when each cow $i$ plans to arrive at this special pasture, and the amount of time $t_i$ she plans to spend tasting the grass when it is her turn. When cow $i$ starts eating, she will spend the full $t_i$ time before leaving, and any other cows that have arrived must wait in line. If multiple cows are waiting when the pasture becomes free, then the most senior cow will be the next to taste the fresh grass. Here, a cow that arrives exactly when another cow finishes eating and leaves is considered to be \"waiting.\" Similarly, if multiple cows arrive at the same time when no cow is eating, then the most senior cow is the next one to eat.\n\nPlease help FJ compute the maximum waiting time among all cows (the time from $a_i$ until that cow starts eating).", "inputFormat": "The first line of input contains $N$. The next $N$ lines give the information of the $N$ cows in order of seniority (the most senior cow is listed first). Each line contains $a_i$ and $t_i$ for one cow. All $t_i$ are positive integers not exceeding $10^4$, and all $a_i$ are positive integers not exceeding $10^9$.", "outputFormat": "Output the longest waiting time among all cows.", "hint": "In this example, we have $5$ cows (numbered $1\\dots 5$ in the order of the input). Cow $4$ arrives first (at time $10$). Before she finishes eating (at time $27$), cows $1$ and $3$ both arrive. Since cow $1$ is more senior, she eats first, and she waits a total of $2$ time units from her arrival. She finishes eating at time $30$, then cow $3$ starts eating, and she waits a total of $10$ time units from her arrival. After a period when no cow is eating, cow $5$ arrives. While she is eating, cow $2$ also arrives, and can eat after $5$ time units. The cow that waits the longest is cow $3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18DEC] Convention II S", "background": null, "description": "虽然在接机上耽误了挺长时间，Farmer John 为吃草爱好牛们举行的大会至今为止都非常顺利。大会吸引了世界各地的奶牛。\n\n然而大会的重头戏看起来却给 Farmer John 带来了一些新的安排上的困扰。他的农场上的一块非常小的牧草地出产一种据某些识货的奶牛说是世界上最美味的品种的草。因此，所有参会的 $N$ 头奶牛（$1\\le N\\le 10^5$）都想要品尝一下这种草。由于这块牧草地小到仅能容纳一头奶牛，这很有可能会导致排起长龙。\n\nFarmer John 知道每头奶牛 $i$ 计划到达这块特殊的牧草地的时间 $a_i$，以及当轮到她时，她计划品尝这种草花费的时间 $t_i$。当奶牛 $i$ 开始吃草时，她会在离开前花费全部 $t_i$ 的时间，此时其他到达的奶牛需要排队等候。如果这块牧草地空出来的时候多头奶牛同时在等候，那么资历最深的奶牛将会是下一头品尝鲜草的奶牛。在这里，恰好在另一头奶牛吃完草离开时到达的奶牛被认为是“在等待的”。类似地，如果当没有奶牛在吃草的时候有多头奶牛同时到达，那么资历最深的奶牛是下一头吃草的奶牛。\n\n请帮助 FJ 计算所有奶牛中在队伍里等待的时间（$a_i$ 到这头奶牛开始吃草之间的时间）的最大值。", "inputFormat": "输入的第一行包含 $N$。以下 $N$ 行按资历顺序给出了 $N$ 头奶牛的信息（资历最深的奶牛排在最前面）。每行包含一头奶牛的 $a_i$ 和 $t_i$。所有的 $t_i$ 为不超过 $10^4$ 的正整数，所有 $a_i$ 为不超过 $10^9$ 的正整数。", "outputFormat": "输出所有奶牛中的最长等待时间。", "hint": "在这个例子中，我们有 $5$ 头奶牛（按输入中的顺序编号为 $1\\dots 5$）。奶牛 $4$ 最先到达（时间 $10$），在她吃完之前（时间 $27$）奶牛 $1$ 和奶牛 $3$ 都到达了。由于奶牛 $1$ 拥有较深的资历，所以她先吃，从她到达开始共计等待了 $2$ 个单位时间。她在时间 $30$ 结束吃草，随后奶牛 $3$ 开始吃草，从她到达开始共计等待了 $10$ 单位时间。在一段没有奶牛吃草的时间过后，奶牛 $5$ 到达，在她正在吃草的时间里奶牛 $2$ 也到达了，在 $5$ 个单位时间之后能够吃到草。相比到达时间等待最久的奶牛是奶牛 $3$。", "locale": "zh-CN"}}}
{"pid": "P5121", "type": "P", "difficulty": 4, "samples": [["6 3\n0000000000\n0000000300\n0054000300\n1054502230\n2211122220\n1111111223", "0000000000\n0000000000\n0000000000\n0000000000\n1054000000\n2254500000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "2018", "USACO"], "title": "[USACO18DEC] Mooyo Mooyo S", "background": "", "description": "由于手上（更确实的，蹄子上）有大把的空余时间，Farmer John 的农场里的奶牛经常玩电子游戏消磨时光。她们最爱的游戏之一是基于一款流行的电子游戏 Puyo Puyo 的奶牛版；名称当然叫做 Mooyo Mooyo。\n\nMooyo Mooyo 是在一块又高又窄的棋盘上进行的游戏，高 $N$（$1\\le N\\le 100$）格，宽 $10$ 格。 这是一个 $N=6$ 的棋盘的例子：\n\n```\n0000000000\n0000000300\n0054000300\n1054502230\n2211122220\n1111111223\n```\n\n每个格子或者是空的（用 $0$ 表示），或者是九种颜色之一的干草捆（用字符 $1\\dots 9$ 表示）。重力会使得干草捆下落，所以没有干草捆的下方是 $0$。\n\n如果两个格子水平或垂直方向直接相邻，并且为同一种非 $0$ 颜色，那么这两个格子就属于同一个连通区域。任意时刻出现至少 $K$ 个格子构成的连通区域，其中的干草捆就会全部消失，变为 $0$。如果同时出现多个这样的连通区域，它们同时消失。随后，重力可能会导致干草捆向下落入某个变为 $0$ 的格子。由此形成的新的布局中，又可能出现至少 $K$ 个格子构成的连通区域。若如此，它们同样也会消失（如果又有多个这样的区域，则同时消失），然后重力又会使得剩下的方块下落，这一过程持续进行，直到不存在大小至少为 $K$ 的连通区域为止。\n\n给定一块 Mooyo Mooyo 棋盘的状态，输出这些过程发生之后最终的棋盘的图案。\n\n", "inputFormat": "输入的第一行包含 $N$ 和 $K$（$1\\le K\\le 10N$）。以下 $N$ 行给出了棋盘的初始状态。", "outputFormat": "输出 $N$ 行，描述最终的棋盘状态。", "hint": "在上面的例子中，如果 $K=3$，那么存在一个大小至少为 $K$ 的颜色 $1$ 的连通区域，同样有一个颜色 $2$ 的连通区域。当它们同时被移除之后，棋盘暂时成为了这样：\n\n```\n0000000000\n0000000300\n0054000300\n1054500030\n2200000000\n0000000003\n```\n\n然后，由于重力效果，干草捆下落形成这样的布局：\n\n```\n0000000000\n0000000000\n0000000000\n0000000000\n1054000300\n2254500333\n```\n\n再一次地，出现了一个大小至少为 $K$ 地连通区域（颜色 $3$）。移除这个区域就得到了最终的棋盘布局：\n\n```\n0000000000\n0000000000\n0000000000\n0000000000\n1054000000\n2254500000\n```", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18DEC] Mooyo Mooyo S", "background": "", "description": "Because they have lots of free time on their hands (or more accurately, on their hooves), the cows on Farmer John’s farm often play video games to pass the time. One of their favorite games is a cow-themed version of the popular game Puyo Puyo, naturally called Mooyo Mooyo.\n\nMooyo Mooyo is played on a tall, narrow board with height $N$ ($1\\le N\\le 100$) and width $10$. Here is an example board with $N=6$:\n\n```\n0000000000\n0000000300\n0054000300\n1054502230\n2211122220\n1111111223\n```\n\nEach cell is either empty (represented by $0$) or a hay bale of one of nine colors (represented by characters $1\\dots 9$). Gravity causes hay bales to fall, so there will be no hay bale with a $0$ directly below it.\n\nIf two cells are directly adjacent horizontally or vertically and have the same non-$0$ color, then they belong to the same connected component. Whenever a connected component of size at least $K$ appears, all hay bales in that component disappear and become $0$. If multiple such components exist at the same time, they disappear simultaneously. Then gravity may cause hay bales to fall downward into cells that became $0$. In the new layout, there may again be connected components of size at least $K$. If so, they also disappear (simultaneously if there are multiple), and gravity makes the remaining blocks fall again. This process continues until there is no connected component of size at least $K$.\n\nGiven a Mooyo Mooyo board state, output the final board pattern after all these processes occur.", "inputFormat": "The first line of input contains $N$ and $K$ ($1\\le K\\le 10N$). The next $N$ lines give the initial state of the board.", "outputFormat": "Output $N$ lines describing the final state of the board.", "hint": "In the example above, if $K=3$, then there is a connected component of color $1$ with size at least $K$, and also a connected component of color $2$. After they are removed simultaneously, the board temporarily becomes:\n\n```\n0000000000\n0000000300\n0054000300\n1054500030\n2200000000\n0000000003\n```\n\nThen, due to gravity, the hay bales fall and form this layout:\n\n```\n0000000000\n0000000000\n0000000000\n0000000000\n1054000300\n2254500333\n```\n\nOnce again, a connected component of size at least $K$ appears (color $3$). Removing this component gives the final board layout:\n\n```\n0000000000\n0000000000\n0000000000\n0000000000\n1054000000\n2254500000\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18DEC] Mooyo Mooyo S", "background": "", "description": "由于手上（更确实的，蹄子上）有大把的空余时间，Farmer John 的农场里的奶牛经常玩电子游戏消磨时光。她们最爱的游戏之一是基于一款流行的电子游戏 Puyo Puyo 的奶牛版；名称当然叫做 Mooyo Mooyo。\n\nMooyo Mooyo 是在一块又高又窄的棋盘上进行的游戏，高 $N$（$1\\le N\\le 100$）格，宽 $10$ 格。 这是一个 $N=6$ 的棋盘的例子：\n\n```\n0000000000\n0000000300\n0054000300\n1054502230\n2211122220\n1111111223\n```\n\n每个格子或者是空的（用 $0$ 表示），或者是九种颜色之一的干草捆（用字符 $1\\dots 9$ 表示）。重力会使得干草捆下落，所以没有干草捆的下方是 $0$。\n\n如果两个格子水平或垂直方向直接相邻，并且为同一种非 $0$ 颜色，那么这两个格子就属于同一个连通区域。任意时刻出现至少 $K$ 个格子构成的连通区域，其中的干草捆就会全部消失，变为 $0$。如果同时出现多个这样的连通区域，它们同时消失。随后，重力可能会导致干草捆向下落入某个变为 $0$ 的格子。由此形成的新的布局中，又可能出现至少 $K$ 个格子构成的连通区域。若如此，它们同样也会消失（如果又有多个这样的区域，则同时消失），然后重力又会使得剩下的方块下落，这一过程持续进行，直到不存在大小至少为 $K$ 的连通区域为止。\n\n给定一块 Mooyo Mooyo 棋盘的状态，输出这些过程发生之后最终的棋盘的图案。\n\n", "inputFormat": "输入的第一行包含 $N$ 和 $K$（$1\\le K\\le 10N$）。以下 $N$ 行给出了棋盘的初始状态。", "outputFormat": "输出 $N$ 行，描述最终的棋盘状态。", "hint": "在上面的例子中，如果 $K=3$，那么存在一个大小至少为 $K$ 的颜色 $1$ 的连通区域，同样有一个颜色 $2$ 的连通区域。当它们同时被移除之后，棋盘暂时成为了这样：\n\n```\n0000000000\n0000000300\n0054000300\n1054500030\n2200000000\n0000000003\n```\n\n然后，由于重力效果，干草捆下落形成这样的布局：\n\n```\n0000000000\n0000000000\n0000000000\n0000000000\n1054000300\n2254500333\n```\n\n再一次地，出现了一个大小至少为 $K$ 地连通区域（颜色 $3$）。移除这个区域就得到了最终的棋盘布局：\n\n```\n0000000000\n0000000000\n0000000000\n0000000000\n1054000000\n2254500000\n```", "locale": "zh-CN"}}}
{"pid": "P5122", "type": "P", "difficulty": 5, "samples": [["4 5 1\n1 4 10\n2 1 20\n4 2 3\n2 3 5\n4 3 2\n2 7", "1\n1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "USACO", "最短路"], "title": "[USACO18DEC] Fine Dining G", "background": null, "description": "漫长的一天结束了，饥困交加的奶牛们准备返回牛棚。\n\n农场由 $N$ 片牧场组成（$2\\le N\\le 5\\times 10^4$），方便起见编号为 $1\\dots N$。所有奶牛都要前往位于牧场 $N$ 的牛棚。其他 $N-1$ 片牧场中每片有一头奶牛。奶牛们可以通过 $M$ 条无向的小路在牧场之间移动（$1\\le M\\le 10^5$）。第i条小路连接牧场 $a_i$ 和 $b_i$，通过需要时间 $t_i$。每头奶牛都可以经过一些小路回到牛棚。\n\n由于饥饿，奶牛们很乐于在他们回家的路上停留一段时间觅食。农场里有 $K$ 个有美味的干草捆（$1 \\le K \\le N$），第 $i$ 个干草捆的美味值为 $y_i$。每头奶牛都想要在她回牛棚的路上在某一个干草捆处停留，但是她这样做仅当经过这个干草捆使她回牛棚的时间增加不超过这个干草捆的美味值。注意一头奶牛仅仅“正式地”在一个干草捆处因进食而停留，即使她的路径上经过其他放有干草捆的牧场；她会简单地无视其他的干草捆。", "inputFormat": "输入的第一行包含三个空格分隔的整数 $N$，$M$ 和 $K$。以下 $M$ 行每行包含三个整数 $a_i$，$b_i$ 和 $t_i$，表示牧场 $a_i$ 和 $b_i$ 之间有一条需要 $t_i$ 时间通过的小路（$a_i$ 不等于 $b_i$，$t_i$ 为不超过 $10^4$ 的正整数）。\n\n以下 $K$ 行，每行以两个整数描述了一个干草捆：该干草捆所在牧场的编号，以及它的美味值（一个不超过 $10^9$ 的正整数）。同一片牧场中可能会有多个干草捆。", "outputFormat": "输出包含 $N-1$ 行。如果牧场 $i$ 里的奶牛可以在回牛棚的路上前往某一个干草捆并且在此进食，则第 $i$ 行为一个整数 $1$，否则为一个整数 $0$。", "hint": "在这个例子中，牧场 $3$ 里的奶牛可以停留进食，因为她回去的时间仅会增加 $6$（从 $2$ 增加到 $8$），而这个增加量并没有超过干草捆的美味值 $7$。牧场 $2$ 里的奶牛显然可以吃掉牧场 $2$ 里的干草，因为这并不会导致她的最佳路径发生变化。对于牧场 $1$ 里的奶牛是一个有趣的情况，因为看起来她的最佳路径（$10$）可能会因为前去进食而有过大的增加量。然而，确实存在一条路径使得她可以前去干草捆处停留：先到牧场 $4$，然后去牧场 $2$（吃草），然后回到牧场 $4$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18DEC] Fine Dining G", "background": "", "description": "After a long day, the hungry and tired cows are ready to return to the barn.\n\nThe farm has $N$ pastures ($2\\le N\\le 5\\times 10^4$), numbered $1\\dots N$ for convenience. All cows want to go to the barn located at pasture $N$. Each of the other $N-1$ pastures has one cow. The cows can move between pastures using $M$ undirected paths ($1\\le M\\le 10^5$). The $i$-th path connects pastures $a_i$ and $b_i$, and it takes time $t_i$ to travel along it. Each cow can take some sequence of paths to get back to the barn.\n\nBecause they are hungry, the cows are happy to stop and eat along the way home. There are $K$ pastures with tasty hay bales ($1 \\le K \\le N$). The $i$-th hay bale has tastiness value $y_i$. Each cow wants to stop at exactly one hay bale on her way to the barn, but she will do so only if going through that hay bale increases her travel time to the barn by no more than the hay bale’s tastiness value. Note that a cow only “officially” stops to eat at one hay bale, even if her path passes through other pastures that also have hay bales; she will simply ignore the other hay bales.", "inputFormat": "The first line contains three space-separated integers $N$, $M$, and $K$. The next $M$ lines each contain three integers $a_i$, $b_i$, and $t_i$, describing a path between pastures $a_i$ and $b_i$ that takes time $t_i$ to traverse ($a_i$ is not equal to $b_i$, and $t_i$ is a positive integer not exceeding $10^4$).\n\nThe next $K$ lines each describe a hay bale with two integers: the index of the pasture where the hay bale is located, and its tastiness value (a positive integer not exceeding $10^9$). There may be multiple hay bales in the same pasture.", "outputFormat": "Output $N-1$ lines. If the cow in pasture $i$ can visit some hay bale and eat there on her way back to the barn, output an integer $1$ on line $i$; otherwise output an integer $0$.", "hint": "In this example, the cow in pasture $3$ can stop to eat, because her time to get back increases by only $6$ (from $2$ to $8$), and this increase does not exceed the hay bale’s tastiness value $7$. The cow in pasture $2$ can clearly eat the hay in pasture $2$, since this does not cause her best path to change. The cow in pasture $1$ is an interesting case, because it looks like her best path ($10$) might increase too much if she goes to eat. However, there is indeed a path that lets her stop at a hay bale: first go to pasture $4$, then go to pasture $2$ (eat hay), and then return to pasture $4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18DEC] Fine Dining G", "background": null, "description": "漫长的一天结束了，饥困交加的奶牛们准备返回牛棚。\n\n农场由 $N$ 片牧场组成（$2\\le N\\le 5\\times 10^4$），方便起见编号为 $1\\dots N$。所有奶牛都要前往位于牧场 $N$ 的牛棚。其他 $N-1$ 片牧场中每片有一头奶牛。奶牛们可以通过 $M$ 条无向的小路在牧场之间移动（$1\\le M\\le 10^5$）。第i条小路连接牧场 $a_i$ 和 $b_i$，通过需要时间 $t_i$。每头奶牛都可以经过一些小路回到牛棚。\n\n由于饥饿，奶牛们很乐于在他们回家的路上停留一段时间觅食。农场里有 $K$ 个有美味的干草捆（$1 \\le K \\le N$），第 $i$ 个干草捆的美味值为 $y_i$。每头奶牛都想要在她回牛棚的路上在某一个干草捆处停留，但是她这样做仅当经过这个干草捆使她回牛棚的时间增加不超过这个干草捆的美味值。注意一头奶牛仅仅“正式地”在一个干草捆处因进食而停留，即使她的路径上经过其他放有干草捆的牧场；她会简单地无视其他的干草捆。", "inputFormat": "输入的第一行包含三个空格分隔的整数 $N$，$M$ 和 $K$。以下 $M$ 行每行包含三个整数 $a_i$，$b_i$ 和 $t_i$，表示牧场 $a_i$ 和 $b_i$ 之间有一条需要 $t_i$ 时间通过的小路（$a_i$ 不等于 $b_i$，$t_i$ 为不超过 $10^4$ 的正整数）。\n\n以下 $K$ 行，每行以两个整数描述了一个干草捆：该干草捆所在牧场的编号，以及它的美味值（一个不超过 $10^9$ 的正整数）。同一片牧场中可能会有多个干草捆。", "outputFormat": "输出包含 $N-1$ 行。如果牧场 $i$ 里的奶牛可以在回牛棚的路上前往某一个干草捆并且在此进食，则第 $i$ 行为一个整数 $1$，否则为一个整数 $0$。", "hint": "在这个例子中，牧场 $3$ 里的奶牛可以停留进食，因为她回去的时间仅会增加 $6$（从 $2$ 增加到 $8$），而这个增加量并没有超过干草捆的美味值 $7$。牧场 $2$ 里的奶牛显然可以吃掉牧场 $2$ 里的干草，因为这并不会导致她的最佳路径发生变化。对于牧场 $1$ 里的奶牛是一个有趣的情况，因为看起来她的最佳路径（$10$）可能会因为前去进食而有过大的增加量。然而，确实存在一条路径使得她可以前去干草捆处停留：先到牧场 $4$，然后去牧场 $2$（吃草），然后回到牧场 $4$。", "locale": "zh-CN"}}}
{"pid": "P5123", "type": "P", "difficulty": 4, "samples": [["4\n1 2 3 4 5\n1 2 3 10 8\n10 9 8 7 6\n50 60 70 80 90", "4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "USACO", "容斥原理"], "title": "[USACO18DEC] Cowpatibility G", "background": "2025/4/9 加入两组 hack 数据（@Starrykiller）。", "description": "研究证明，有一个因素在两头奶牛能否作为朋友和谐共处这方面比其他任何因素都来得重要——她们是不是喜欢同一种口味的冰激凌！\n\nFarmer John 的 $N$ 头奶牛（$2\\le N\\le 5\\times 10^4$）各自列举了她们最喜欢的五种冰激凌口味的清单。为使这个清单更加精炼，每种可能的口味用一个不超过 $10^6$ 的正整数 $\\texttt{ID}$ 表示。如果两头奶牛的清单上有至少一种共同的冰激凌口味，那么她们可以和谐共处。\n\n请求出不能和谐共处的奶牛的对数。", "inputFormat": "输入的第一行包含 $N$。以下 $N$ 行每行包含 $5$ 个整数（各不相同），表示一头奶牛最喜欢的冰激凌口味。", "outputFormat": "输出不能和谐共处的奶牛的对数。", "hint": "在这里，奶牛 $4$ 不能和奶牛 $1$、$2$、$3$ 中的任一头和谐共处，奶牛 $1$ 和奶牛 $3$ 也不能和谐共处。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18DEC] Cowpatibility G", "background": "On 2025/4/9, two groups of hack testdata were added (@Starrykiller).", "description": "Research shows that one factor matters more than anything else in whether two cows can get along as friends—whether they like the same ice cream flavor.\n\nFarmer John has $N$ cows ($2 \\le N \\le 5 \\times 10^4$). Each cow lists her five favorite ice cream flavors. To make the list more concise, each possible flavor is represented by a positive integer $\\texttt{ID}$ not exceeding $10^6$. If two cows' lists share at least one common ice cream flavor, then they can get along.\n\nPlease compute the number of pairs of cows that cannot get along.", "inputFormat": "The first line contains $N$. The next $N$ lines each contain $5$ integers (all distinct), representing one cow’s favorite ice cream flavors.", "outputFormat": "Output the number of pairs of cows that cannot get along.", "hint": "Here, cow $4$ cannot get along with any of cows $1$, $2$, or $3$, and cow $1$ and cow $3$ also cannot get along.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18DEC] Cowpatibility G", "background": "2025/4/9 加入两组 hack 数据（@Starrykiller）。", "description": "研究证明，有一个因素在两头奶牛能否作为朋友和谐共处这方面比其他任何因素都来得重要——她们是不是喜欢同一种口味的冰激凌！\n\nFarmer John 的 $N$ 头奶牛（$2\\le N\\le 5\\times 10^4$）各自列举了她们最喜欢的五种冰激凌口味的清单。为使这个清单更加精炼，每种可能的口味用一个不超过 $10^6$ 的正整数 $\\texttt{ID}$ 表示。如果两头奶牛的清单上有至少一种共同的冰激凌口味，那么她们可以和谐共处。\n\n请求出不能和谐共处的奶牛的对数。", "inputFormat": "输入的第一行包含 $N$。以下 $N$ 行每行包含 $5$ 个整数（各不相同），表示一头奶牛最喜欢的冰激凌口味。", "outputFormat": "输出不能和谐共处的奶牛的对数。", "hint": "在这里，奶牛 $4$ 不能和奶牛 $1$、$2$、$3$ 中的任一头和谐共处，奶牛 $1$ 和奶牛 $3$ 也不能和谐共处。", "locale": "zh-CN"}}}
{"pid": "P5124", "type": "P", "difficulty": 4, "samples": [["7 3\n1\n15\n7\n9\n2\n5\n10", "84"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2018", "USACO", "线性 DP"], "title": "[USACO18DEC] Teamwork G", "background": "", "description": "在 Farmer John 最喜欢的节日里，他想要给他的朋友们赠送一些礼物。由于他并不擅长包装礼物，他想要获得他的奶牛们的帮助。你可能能够想到，奶牛们本身也不是很擅长包装礼物，而 Farmer John 即将得到这一教训。\n\nFarmer John 的 $N$ 头奶牛（$1\\le N\\le 10^4$）排成一行，方便起见依次编号为 $1\\dots N$。奶牛 $i$ 的包装礼物的技能水平为 $s_i$。她们的技能水平可能参差不齐，所以 FJ 决定把她的奶牛们分成小组。每一组可以包含任意不超过 $K$ 头的连续的奶牛（$1\\le K\\le 10^3$），并且一头奶牛不能属于多于一个小组。由于奶牛们会互相学习，这一组中每一头奶牛的技能水平会变成这一组中水平最高的奶牛的技能水平。\n\n请帮助 FJ 求出，在他合理地安排分组的情况下，可以达到的技能水平之和的最大值。", "inputFormat": "输入的第一行包含 $N$ 和 $K$。以下 $N$ 行按照 $N$ 头奶牛的排列顺序依次给出她们的技能水平。技能水平是一个不超过 $10^5$ 的正整数。", "outputFormat": "输出 FJ 通过将连续的奶牛进行分组可以达到的最大技能水平和。", "hint": "在这个例子中，最优的方案是将前三头奶牛和后三头奶牛分别分为一组，中间的奶牛单独成为一组（注意一组的奶牛数量可以小于 $K$）。这样能够有效地将 $7$ 头奶牛的技能水平提高至 $15$、$15$、$15$、$9$、$10$、$10$、$10$，和为 $84$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18DEC] Teamwork G", "background": "", "description": "On Farmer John’s favorite holiday, he wants to give some gifts to his friends. Since he is not very good at wrapping gifts, he wants help from his cows. As you might guess, cows are also not very good at wrapping gifts, and Farmer John is about to learn this lesson.\n\nFarmer John has $N$ cows ($1\\le N\\le 10^4$) standing in a line, numbered $1\\dots N$ for convenience. Cow $i$ has a gift-wrapping skill level of $s_i$. Their skill levels may vary a lot, so FJ decides to divide his cows into groups. Each group can contain any number of consecutive cows, as long as it has at most $K$ cows ($1\\le K\\le 10^3$), and no cow can belong to more than one group. Since the cows learn from each other, every cow in a group will have her skill level changed to the highest skill level within that group.\n\nHelp FJ find the maximum possible total sum of skill levels, if he groups the cows in the best way.", "inputFormat": "The first line contains $N$ and $K$. The next $N$ lines give the cows’ skill levels in order. Each skill level is a positive integer not exceeding $10^5$.", "outputFormat": "Output the maximum total sum of skill levels that FJ can achieve by grouping consecutive cows.", "hint": "In this example, the best plan is to put the first three cows into one group and the last three cows into another group, with the middle cow alone as a group (note that a group can have fewer than $K$ cows). This effectively increases the 7 cows’ skill levels to $15$, $15$, $15$, $9$, $10$, $10$, $10$, for a total of $84$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18DEC] Teamwork G", "background": "", "description": "在 Farmer John 最喜欢的节日里，他想要给他的朋友们赠送一些礼物。由于他并不擅长包装礼物，他想要获得他的奶牛们的帮助。你可能能够想到，奶牛们本身也不是很擅长包装礼物，而 Farmer John 即将得到这一教训。\n\nFarmer John 的 $N$ 头奶牛（$1\\le N\\le 10^4$）排成一行，方便起见依次编号为 $1\\dots N$。奶牛 $i$ 的包装礼物的技能水平为 $s_i$。她们的技能水平可能参差不齐，所以 FJ 决定把她的奶牛们分成小组。每一组可以包含任意不超过 $K$ 头的连续的奶牛（$1\\le K\\le 10^3$），并且一头奶牛不能属于多于一个小组。由于奶牛们会互相学习，这一组中每一头奶牛的技能水平会变成这一组中水平最高的奶牛的技能水平。\n\n请帮助 FJ 求出，在他合理地安排分组的情况下，可以达到的技能水平之和的最大值。", "inputFormat": "输入的第一行包含 $N$ 和 $K$。以下 $N$ 行按照 $N$ 头奶牛的排列顺序依次给出她们的技能水平。技能水平是一个不超过 $10^5$ 的正整数。", "outputFormat": "输出 FJ 通过将连续的奶牛进行分组可以达到的最大技能水平和。", "hint": "在这个例子中，最优的方案是将前三头奶牛和后三头奶牛分别分为一组，中间的奶牛单独成为一组（注意一组的奶牛数量可以小于 $K$）。这样能够有效地将 $7$ 头奶牛的技能水平提高至 $15$、$15$、$15$、$9$、$10$、$10$、$10$，和为 $84$。", "locale": "zh-CN"}}}
{"pid": "P5125", "type": "P", "difficulty": 5, "samples": [["5 6\n3 3\n2 3\n2 5\n3 5\n0 4\n6 4", "0\n1\n1\n1\n7\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": [], "title": "不认识", "background": "又是一年军训时，今年的军训有点不一样。小 L 和小 K 所在的班的同学来自五湖四海（才怪），原来互相都不认识。", "description": "小 K 和小 L 的教官将同学们按随机顺序排成一列。教官发现所有同学互相之间竟然都不认识（小 L 和小 K 失忆了），于是教官决定让同学们互相认识一下。每次教官会令编号在闭区间 $[l,r]$ 的所有同学两两互相认识。如果其中的一对同学在之前的操作中已经认识，那么他们不会再次认识。请问，在每次教官的操作（命令）之前，在教官指定的这个区间内有多少对同学是不认识的？\n\n每对同学可以表示为 $(u,v)[u<v]$。两对同学 $(u_1,v_1)$ 和 $(u_2,v_2)$ 不同当且仅当 $u_1\\neq u_2~or~v_1\\neq v_2$。", "inputFormat": "输入第一行为一个整数 $n$ 和 $q$，$n$ 表示小 L 和小 K 所在的班的学生数，$q$ 表示教官的操作数；\n\n之后的 $q$ 行，每行两个整数 $l'$ 和 $r'$，表示这次操作使得闭区间 $[l',r']$ 的所有同学两两互相认识。\n\n本题输入加密。输入的第三行至最后一行，输入的数字都按位异或（$\\oplus$）了 $lastans$，也就是上一个询问的输出。对于输入的第二行，你可以认为 $lastans=0$。对于每个操作，你需要将 $l',r'$ 通过某种方式解密得到真正的，即未加密过的 $l,r$。", "outputFormat": "输出共 $q$ 行。每行对应输入中的一次操作，输出这次操作的答案。", "hint": "样例解释：  \n这是解密后的输入：\n```\n5 6\n3 3\n2 3\n3 4\n2 4\n1 5\n1 3\n```\n\n$Subtask\\#1:~20pts~,~1\\le n,q \\le 100$；\n\n$Subtask\\#2:~30pts~,~1\\le n,q\\le 5000$；\n\n$Subtask\\#3:~50pts~,~1\\le n,q \\le 10^6,1\\le l,r \\le n$\n\n保证解密后的每对 $l,r$ 均满足 $l\\le r$。", "locale": "zh-CN", "translations": {"en": {"title": "Unfamiliar.", "background": "It is military training season again this year, and this year’s training is a bit different. The classmates in the class of Xiao L and Xiao K come from all over the country (not really), and it turns out that none of them knew each other before.", "description": "The instructor of Xiao K and Xiao L arranges the students into a line in a random order. The instructor finds that all students do not know each other (Xiao L and Xiao K lost their memories), so the instructor decides to let the students get to know each other.\n\nEach time, the instructor will make all students whose indices are in the closed interval $[l,r]$ know each other pairwise. If a pair of students already knew each other from previous operations, they will not get to know each other again.\n\nFor each instructor operation (command), before performing this operation, how many pairs of students in the specified interval do not know each other?\n\nEach pair of students can be represented as $(u,v)[u<v]$. Two pairs $(u_1,v_1)$ and $(u_2,v_2)$ are different if and only if $u_1\\neq u_2~or~v_1\\neq v_2$.", "inputFormat": "The first line contains two integers $n$ and $q$. $n$ is the number of students in the class of Xiao L and Xiao K, and $q$ is the number of instructor operations.\n\nIn the following $q$ lines, each line contains two integers $l'$ and $r'$, meaning that this operation makes all students in the closed interval $[l',r']$ know each other pairwise.\n\nThe input of this problem is encrypted. From the third line to the last line, all input numbers are XORed bitwise ($\\oplus$) with $lastans$, i.e., the output of the previous query. For the second line of input, you may assume $lastans=0$. For each operation, you need to decrypt $l',r'$ in some way to obtain the real (unencrypted) $l,r$.", "outputFormat": "Output $q$ lines in total. Each line corresponds to an operation in the input, and you should output the answer for that operation.", "hint": "Sample explanation:  \nThis is the decrypted input:\n```\n5 6\n3 3\n2 3\n3 4\n2 4\n1 5\n1 3\n```\n\n$Subtask\\#1:~20pts~,~1\\le n,q \\le 100$.\n\n$Subtask\\#2:~30pts~,~1\\le n,q\\le 5000$.\n\n$Subtask\\#3:~50pts~,~1\\le n,q \\le 10^6,1\\le l,r \\le n$.\n\nIt is guaranteed that after decryption, every pair $l,r$ satisfies $l\\le r$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "不认识", "background": "又是一年军训时，今年的军训有点不一样。小 L 和小 K 所在的班的同学来自五湖四海（才怪），原来互相都不认识。", "description": "小 K 和小 L 的教官将同学们按随机顺序排成一列。教官发现所有同学互相之间竟然都不认识（小 L 和小 K 失忆了），于是教官决定让同学们互相认识一下。每次教官会令编号在闭区间 $[l,r]$ 的所有同学两两互相认识。如果其中的一对同学在之前的操作中已经认识，那么他们不会再次认识。请问，在每次教官的操作（命令）之前，在教官指定的这个区间内有多少对同学是不认识的？\n\n每对同学可以表示为 $(u,v)[u<v]$。两对同学 $(u_1,v_1)$ 和 $(u_2,v_2)$ 不同当且仅当 $u_1\\neq u_2~or~v_1\\neq v_2$。", "inputFormat": "输入第一行为一个整数 $n$ 和 $q$，$n$ 表示小 L 和小 K 所在的班的学生数，$q$ 表示教官的操作数；\n\n之后的 $q$ 行，每行两个整数 $l'$ 和 $r'$，表示这次操作使得闭区间 $[l',r']$ 的所有同学两两互相认识。\n\n本题输入加密。输入的第三行至最后一行，输入的数字都按位异或（$\\oplus$）了 $lastans$，也就是上一个询问的输出。对于输入的第二行，你可以认为 $lastans=0$。对于每个操作，你需要将 $l',r'$ 通过某种方式解密得到真正的，即未加密过的 $l,r$。", "outputFormat": "输出共 $q$ 行。每行对应输入中的一次操作，输出这次操作的答案。", "hint": "样例解释：  \n这是解密后的输入：\n```\n5 6\n3 3\n2 3\n3 4\n2 4\n1 5\n1 3\n```\n\n$Subtask\\#1:~20pts~,~1\\le n,q \\le 100$；\n\n$Subtask\\#2:~30pts~,~1\\le n,q\\le 5000$；\n\n$Subtask\\#3:~50pts~,~1\\le n,q \\le 10^6,1\\le l,r \\le n$\n\n保证解密后的每对 $l,r$ 均满足 $l\\le r$。", "locale": "zh-CN"}}}
