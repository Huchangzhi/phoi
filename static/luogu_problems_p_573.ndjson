{"pid": "P12631", "type": "P", "difficulty": 5, "samples": [["3\n5 4 3\n2 2 2\n8 1 5", "4\n1\n24"], ["2\n500000003 1 600000010\n511374200 637192506 100000000", "799999999\n7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "ICPC", "NAC"], "title": "[ICPC 2025 NAC] Solar Farm", "background": "", "description": "You are building a new solar farm.  The area in which you are allowed to build\nis a circular field of radius $r$, and the solar panels each take up a\nrectangular space of size $w \\times h$.  You must place all the panels in the same\norientation of your choice in a single rectangular array (so that all of the panels combined\nexactly form a single rectangle).  What is the maximum number of panels that you can fit in this farm?", "inputFormat": "The first line of input contains a single integer $T$ ($1\\leq T \\leq 1\\,000$).\nThis is the number of test cases.\n\nThe next $T$ lines of input each represent one test case and consist of three space-separated integers $r$, $w$, and $h$\n($1 \\leq r, w, h \\leq 10^9$): the radius of the field, the width of\neach solar panel, and the height of each solar panel, respectively.", "outputFormat": "For each test case, print a line with a single integer: the maximum\nnumber of solar panels that can be placed in a solar farm within the circular\nfield.", "hint": "The diagram below illustrates one optimal layout of solar panels for each of the three test cases in Sample Input 1 (from left to right).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l3d8fv6t.png)", "locale": "en", "translations": {"en": {"title": "[ICPC 2025 NAC] Solar Farm", "background": "", "description": "You are building a new solar farm.  The area in which you are allowed to build\nis a circular field of radius $r$, and the solar panels each take up a\nrectangular space of size $w \\times h$.  You must place all the panels in the same\norientation of your choice in a single rectangular array (so that all of the panels combined\nexactly form a single rectangle).  What is the maximum number of panels that you can fit in this farm?", "inputFormat": "The first line of input contains a single integer $T$ ($1\\leq T \\leq 1\\,000$).\nThis is the number of test cases.\n\nThe next $T$ lines of input each represent one test case and consist of three space-separated integers $r$, $w$, and $h$\n($1 \\leq r, w, h \\leq 10^9$): the radius of the field, the width of\neach solar panel, and the height of each solar panel, respectively.", "outputFormat": "For each test case, print a line with a single integer: the maximum\nnumber of solar panels that can be placed in a solar farm within the circular\nfield.", "hint": "The diagram below illustrates one optimal layout of solar panels for each of the three test cases in Sample Input 1 (from left to right).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l3d8fv6t.png)", "locale": "en"}, "zh-CN": {"title": "[ICPC 2025 NAC] Solar Farm", "background": "", "description": "你正在建造一个新的太阳能农场。允许建造的区域是一个半径为 $r$ 的圆形场地，而每块太阳能电池板占据一个大小为 $w \\times h$ 的矩形空间。你必须将所有电池板按照你选择的同一方向排列成一个单一的矩形阵列（即所有电池板组合起来恰好形成一个完整的矩形）。在这个农场中，最多可以放置多少块电池板？", "inputFormat": "第一行输入包含一个整数 $T$（$1 \\leq T \\leq 1\\,000$），表示测试用例的数量。\n\n接下来的 $T$ 行每行代表一个测试用例，包含三个用空格分隔的整数 $r$、$w$ 和 $h$（$1 \\leq r, w, h \\leq 10^9$），分别表示场地的半径、每块太阳能电池板的宽度和高度。\n", "outputFormat": "对于每个测试用例，输出一行，包含一个整数：在圆形场地内可以放置的太阳能电池板的最大数量。\n", "hint": "下图展示了样例输入 1 中三个测试用例（从左到右）各自的一种最优太阳能电池板布局。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l3d8fv6t.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12632", "type": "P", "difficulty": 6, "samples": [["6 3\n21 28 24 23 1 12", "1 1 3 6 3 10\n"], ["3 1000\n8 2 10\n", "0 0 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "ICPC", "NAC"], "title": "[ICPC 2025 NAC] This Is Sparta!", "background": "", "description": "King Primonidas is putting together a tournament to find the strongest gladiator in all the lands. In total $N$ gladiators have made their way to the Coliseum to bring back honor and glory to their hometowns. Each gladiator starts with a certain amount of vitality. Vitality is similar to health points in that it reflects the amount of damage a gladiator can take, but it also represents the amount of damage they can deal (since energy is needed for strong blows).\n\nThe tournament consists of $K$ rounds. Every round, the king arranges the gladiators in a line from least to most remaining vitality, breaking ties randomly. King Primonidas believes that the true strength of a gladiator lies in their ability to take a beating, so he orders the first gladiator (the one with the lowest remaining vitality) to deal their strongest blow to the second gladiator. This blow subtracts the first gladiator's vitality from the second gladiator's vitality. After the second gladiator takes the hit, they deal their strongest blow (using their new, lowered vitality) to the third gladiator, and so on. This process repeats until the second-to-last gladiator deals their strongest blow to the last gladiator (who doesn't get to attack anybody).\n\nNotice that in the above process, a gladiator's vitality can never go below zero. (A gladiator with zero vitality deals a feeble blow of no damage to the next gladiator.)\n\nPrint the vitality of each gladiator after $K$ tournament rounds, in order from the first to the last gladiator in line.", "inputFormat": "The first line of input contains two space-separated integers $N$ ($2 \\leq N \\leq 10^5$) and $K$ ($1 \\leq K \\leq 10^{18}$): the number of gladiators and the number of rounds in the tournament.\n\nThe next line of input contains $N$ space-separated integers $v_1 \\; v_2 \\; \\ldots v_N$ ($0 \\leq v_i \\leq 10^{18}$): the starting vitality of the gladiators.", "outputFormat": "Print $N$ space-separated integers: the vitality of the gladiators at the end of the $K$th round of the tournament, in the order that the gladiators currently stand in line.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2025 NAC] This Is Sparta!", "background": "", "description": "King Primonidas is putting together a tournament to find the strongest gladiator in all the lands. In total $N$ gladiators have made their way to the Coliseum to bring back honor and glory to their hometowns. Each gladiator starts with a certain amount of vitality. Vitality is similar to health points in that it reflects the amount of damage a gladiator can take, but it also represents the amount of damage they can deal (since energy is needed for strong blows).\n\nThe tournament consists of $K$ rounds. Every round, the king arranges the gladiators in a line from least to most remaining vitality, breaking ties randomly. King Primonidas believes that the true strength of a gladiator lies in their ability to take a beating, so he orders the first gladiator (the one with the lowest remaining vitality) to deal their strongest blow to the second gladiator. This blow subtracts the first gladiator's vitality from the second gladiator's vitality. After the second gladiator takes the hit, they deal their strongest blow (using their new, lowered vitality) to the third gladiator, and so on. This process repeats until the second-to-last gladiator deals their strongest blow to the last gladiator (who doesn't get to attack anybody).\n\nNotice that in the above process, a gladiator's vitality can never go below zero. (A gladiator with zero vitality deals a feeble blow of no damage to the next gladiator.)\n\nPrint the vitality of each gladiator after $K$ tournament rounds, in order from the first to the last gladiator in line.", "inputFormat": "The first line of input contains two space-separated integers $N$ ($2 \\leq N \\leq 10^5$) and $K$ ($1 \\leq K \\leq 10^{18}$): the number of gladiators and the number of rounds in the tournament.\n\nThe next line of input contains $N$ space-separated integers $v_1 \\; v_2 \\; \\ldots v_N$ ($0 \\leq v_i \\leq 10^{18}$): the starting vitality of the gladiators.", "outputFormat": "Print $N$ space-separated integers: the vitality of the gladiators at the end of the $K$th round of the tournament, in the order that the gladiators currently stand in line.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2025 NAC] This Is Sparta!", "background": "", "description": "普里莫尼达斯国王正在举办一场锦标赛，以寻找全境最强的角斗士。共有 $N$ 名角斗士来到竞技场，为家乡带回荣誉与荣耀。每名角斗士初始拥有一定的活力值。活力值类似于生命值，反映了角斗士能承受的伤害量，同时也代表他们能造成的伤害量（因为强力攻击需要消耗能量）。\n\n锦标赛包含 $K$ 轮。每一轮，国王会按照剩余活力值从低到高将角斗士排成一行，若活力值相同则随机排序。普里莫尼达斯国王认为，角斗士的真正实力在于他们的抗打击能力，因此他命令第一名角斗士（剩余活力值最低的）对第二名角斗士发动最强一击。这一击会将第一名角斗士的活力值从第二名角斗士的活力值中扣除。第二名角斗士受到攻击后，会用他们新的（降低后的）活力值对第三名角斗士发动最强一击，以此类推。此过程重复进行，直到倒数第二名角斗士对最后一名角斗士发动攻击（最后一名角斗士无需攻击任何人）。\n\n注意在上述过程中，角斗士的活力值永远不会低于零。（活力值为零的角斗士对下一名角斗士的攻击将毫无伤害。）\n\n输出 $K$ 轮锦标赛后每名角斗士的活力值，按当前队伍中的顺序排列。", "inputFormat": "第一行输入包含两个以空格分隔的整数 $N$（$2 \\leq N \\leq 10^5$）和 $K$（$1 \\leq K \\leq 10^{18}$）：角斗士的数量和锦标赛的轮数。\n\n第二行输入包含 $N$ 个以空格分隔的整数 $v_1 \\; v_2 \\; \\ldots v_N$（$0 \\leq v_i \\leq 10^{18}$）：角斗士的初始活力值。\n", "outputFormat": "输出 $N$ 个以空格分隔的整数：第 $K$ 轮锦标赛结束后角斗士的活力值，按当前队伍中的顺序排列。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12633", "type": "P", "difficulty": 3, "samples": [["4\n2 1 3 4\n4 2 1 3", "14"], ["6\n1 10 3 9 8 2\n8 3 2 4 5 6", "51"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "2020", "UOI（乌克兰）"], "title": "[UOI 2020] Skyscraper", "background": "", "description": "Vus the Cossack lives in a skyscraper.\n\nSince he started working as a builder, $n$ customers gave him the task to build $n$ skyscrapers. One of them should be at a distance of one kilometer from the skyscraper of Vus the Cossack, the other should be at a distance of two kilometers, the other should be at a distance of three kilometers and so on. All skyscrapers (including Cossack) must be on the same line, with his skyscraper being the leftmost.\n\nThe $i$-th customer wants his skyscraper to be $a_i$ high. However, customers do not care how far their skyscrapers will be from the Vus' skyscraper. Therefore, the Cossack can decide for himself in what order to build other skyscrapers from his skyscraper.\n\nVus the Cossack wants to make the view from his skyscraper as beautiful as possible. We will assume that the $i$-th floor of a certain skyscraper is visible from the Mustache skyscraper only if there is no other skyscraper between them that will have the $i$-th floor. Vus the Cossack believes that every floor of the $i$-th skyscraper has the beauty of $b_i$. Therefore, he wants the total beauty of all the floors he will see from his skyscraper to be as great as possible.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uh2smivm.png)\n\nAn example for $n$ = 4.\n\nThe figure shows an example for $n=4$. At a distance of one kilometer built a two-story skyscraper with the beauty of $4$. Then one-story with the beauty of $2$. Then a three-story with the beauty of $1$. Finally, the latter built a $4$-story skyscraper with a $3$ beauty. From the Vus' skyscraper you can see only both floors of the first skyscraper, the third floor of the third and the fourth floor of the fourth skyscraper. Accordingly, we consider the total beauty of these floors: $4+4+1+3=12$. Note that this may not be the optimal order of construction.\n\nHelp him find the maximum possible beauty.", "inputFormat": "The first line contains one integer $n$ ($1 \\leq n \\leq 10^5$) --- the number of skyscrapers that need to be built.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\leq a_i \\leq 10^9$) --- the height of skyscrapers.\n\nThe third line contains $n$ integers  $b_1, b_2, \\dots, b_n$ ($1 \\leq b_i \\leq 10^9$) --- the beauty of the floors in the skyscrapers.", "outputFormat": "Print one integer --- the maximum possible total beauty.", "hint": "- ($10$ points) $1 \\leq n \\leq 10, 1 \\leq a_i \\leq 10, 1 \\leq b_i \\leq 10$;\n- ($27$ points) $1 \\leq n \\leq 10^3, 1 \\leq a_i \\leq 10^3, 1 \\leq b_i \\leq 10^3$;\n- ($25$ points) $1 \\leq n \\leq 10^3, 1 \\leq a_i \\leq 10^9, 1 \\leq b_i \\leq 10^9$;\n- ($38$ points) without additional restrictions.", "locale": "en", "translations": {"en": {"title": "[UOI 2020] Skyscraper", "background": "", "description": "Vus the Cossack lives in a skyscraper.\n\nSince he started working as a builder, $n$ customers gave him the task to build $n$ skyscrapers. One of them should be at a distance of one kilometer from the skyscraper of Vus the Cossack, the other should be at a distance of two kilometers, the other should be at a distance of three kilometers and so on. All skyscrapers (including Cossack) must be on the same line, with his skyscraper being the leftmost.\n\nThe $i$-th customer wants his skyscraper to be $a_i$ high. However, customers do not care how far their skyscrapers will be from the Vus' skyscraper. Therefore, the Cossack can decide for himself in what order to build other skyscrapers from his skyscraper.\n\nVus the Cossack wants to make the view from his skyscraper as beautiful as possible. We will assume that the $i$-th floor of a certain skyscraper is visible from the Mustache skyscraper only if there is no other skyscraper between them that will have the $i$-th floor. Vus the Cossack believes that every floor of the $i$-th skyscraper has the beauty of $b_i$. Therefore, he wants the total beauty of all the floors he will see from his skyscraper to be as great as possible.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uh2smivm.png)\n\nAn example for $n$ = 4.\n\nThe figure shows an example for $n=4$. At a distance of one kilometer built a two-story skyscraper with the beauty of $4$. Then one-story with the beauty of $2$. Then a three-story with the beauty of $1$. Finally, the latter built a $4$-story skyscraper with a $3$ beauty. From the Vus' skyscraper you can see only both floors of the first skyscraper, the third floor of the third and the fourth floor of the fourth skyscraper. Accordingly, we consider the total beauty of these floors: $4+4+1+3=12$. Note that this may not be the optimal order of construction.\n\nHelp him find the maximum possible beauty.", "inputFormat": "The first line contains one integer $n$ ($1 \\leq n \\leq 10^5$) --- the number of skyscrapers that need to be built.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\leq a_i \\leq 10^9$) --- the height of skyscrapers.\n\nThe third line contains $n$ integers  $b_1, b_2, \\dots, b_n$ ($1 \\leq b_i \\leq 10^9$) --- the beauty of the floors in the skyscrapers.", "outputFormat": "Print one integer --- the maximum possible total beauty.", "hint": "- ($10$ points) $1 \\leq n \\leq 10, 1 \\leq a_i \\leq 10, 1 \\leq b_i \\leq 10$;\n- ($27$ points) $1 \\leq n \\leq 10^3, 1 \\leq a_i \\leq 10^3, 1 \\leq b_i \\leq 10^3$;\n- ($25$ points) $1 \\leq n \\leq 10^3, 1 \\leq a_i \\leq 10^9, 1 \\leq b_i \\leq 10^9$;\n- ($38$ points) without additional restrictions.", "locale": "en"}, "zh-CN": {"title": "[UOI 2020] Skyscraper", "background": "1s 256M", "description": "Cossack Vus 住在一座摩天大楼里。\n\n自从他开始从事建筑工作以来，$n$ 位客户委托他建造 $n$ 座摩天大楼。其中一座应距离 Cossack Vus 的摩天大楼 1 公里，另一座应距离 2 公里，第三座应距离 3 公里，以此类推。所有摩天大楼（包括 Cossack 的）必须位于同一条直线上，且他的摩天大楼位于最左侧。\n\n第 $i$ 位客户希望他的摩天大楼高度为 $a_i$。然而，客户并不关心他们的摩天大楼距离 Vus 的摩天大楼有多远。因此，Cossack 可以自行决定其他摩天大楼相对于他的摩天大楼的建造顺序。\n\nCossack Vus 希望从他的摩天大楼看到的景色尽可能美丽。我们假设某一座摩天大楼的第 $i$ 层只有在没有其他摩天大楼的遮挡时，才能从 Vus 的摩天大楼看到。Cossack Vus 认为第 $i$ 座摩天大楼的每一层的美观度为 $b_i$。因此，他希望从他摩天大楼看到的所有楼层的总美观度尽可能大。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uh2smivm.png)\n\n一个 $n=4$ 的例子。\n\n图中展示了一个 $n=4$ 的例子。在 1 公里处建造了一座 2 层的摩天大楼，美观度为 $4$；接着是一座 1 层的摩天大楼，美观度为 $2$；然后是一座 3 层的摩天大楼，美观度为 $1$；最后是一座 4 层的摩天大楼，美观度为 $3$。从 Vus 的摩天大楼只能看到第一座摩天大楼的两层、第三座摩天大楼的第三层和第四座摩天大楼的第四层。因此，这些楼层的总美观度为 $4+4+1+3=12$。注意，这可能不是最优的建造顺序。\n\n帮助他找到可能的最大美观度。", "inputFormat": "第一行包含一个整数 $n$（$1 \\leq n \\leq 10^5$）——需要建造的摩天大楼数量。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\dots, a_n$（$1 \\leq a_i \\leq 10^9$）——摩天大楼的高度。\n\n第三行包含 $n$ 个整数 $b_1, b_2, \\dots, b_n$（$1 \\leq b_i \\leq 10^9$）——摩天大楼各层的美观度。\n", "outputFormat": "输出一个整数——可能的最大总美观度。\n", "hint": "- （$10$ 分）$1 \\leq n \\leq 10$，$1 \\leq a_i \\leq 10$，$1 \\leq b_i \\leq 10$；\n- （$27$ 分）$1 \\leq n \\leq 10^3$，$1 \\leq a_i \\leq 10^3$，$1 \\leq b_i \\leq 10^3$；\n- （$25$ 分）$1 \\leq n \\leq 10^3$，$1 \\leq a_i \\leq 10^9$，$1 \\leq b_i \\leq 10^9$；\n- （$38$ 分）无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12634", "type": "P", "difficulty": 0, "samples": [["2 2 4 0\n1 4 0\n2 3 0\n3 3 1\n4 4 1", "1"], ["2 6 2 0\n1 2 0\n3 2 0", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "UOI（乌克兰）"], "title": "[UOI 2020] Chessfield", "background": "", "description": "Pani Annochka recently got an interview with an IT company. In this interview, she was given a *very interesting task*:\n\nThe girl is given a field divided into squares. That is, each side is $1$. And each square is painted in either white or black.\n\nWe say that a chessfield has sizes $n$ and $m$, when it consists of rectangles having $n$ units in height and $m$ units in width. Also, all these rectangles should be painted either white or black. And each white rectangle borders only on black and vice versa --- each black borders only on white.\n\nFor example, the following chessboard has sizes $2$ and $3$ (blue is the coordinate axis):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/88zoek3f.png)\n\nBut these are not:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/egfvlilp.png)\n\nAs you may have noticed, there are often a lot of chessfiels with sizes $n$ and $m$. The challenge is to say how many there are. *No-no-no, it's too easy*.\n\nAnnochka also knows $k$ squares on this field and their colors. Pani must find the number of chessfields with sizes $n$ and $m$ such that the squares with the corresponding coordinates have the specified colors. Help her do it!\n\nMore formally, you are given $k$ triplets of numbers: $x_i, y_i, c_i$, where ($x_i,y_i$) --- the coordinates of the lower left edge of the square, and $c_i$ is $0$ if this square is to be is painted black, and is $1$ if this square is to be painted white. You need to print the number of different chessfields with sizes $n$ and $m$ that fit under these constraints. Two chessfields are considered different if there is at least one square painted in different colors on these planes.", "inputFormat": "The first line contains four integers $n$, $m$, $k$, $g$ ($1 \\leq k \\leq 10^5$, $1 \\leq n, m \\leq 10^9$, $0 \\leq g \\leq 4$) --- the height of each rectangular, the width of each rectangular, the number of known squares and the number of group.\n\nEach of the next $k$ lines contains three integers $x_i$, $y_i$, $c_i$ ($1 \\leq x_i, y_i \\leq 10^9, 0 \\leq c_i \\leq 1$) --- the coordinates and color size. Note that coordinates can be **repeated**.", "outputFormat": "Print one integer --- the number of different chess planes with sizes $n$ and $m$ that fit the given constraints.", "hint": "On the left is an image of a single plane that fits the $1$ example limit.\n\nOn the right side there is one of the $8$ possible chessfields that satisfy the conditions of the example $2$.\n\n(Blue is the coordinate axis, light gray --- squares, which should be white, dark gray --- squares, which should be black).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b1ygrj64.png)\n\n- ($17$ points): $1 \\leq n, m, x_i, y_i, k \\leq 100$;\n- ($24$ points): $1 \\leq n, m, k \\leq 100$;\n- ($31$ points): $1 \\leq n \\cdot m \\leq 10^5, 1 \\leq k \\leq 10^4$;\n- ($28$ points): without additional restrictions.", "locale": "en", "translations": {"en": {"title": "[UOI 2020] Chessfield", "background": "", "description": "Pani Annochka recently got an interview with an IT company. In this interview, she was given a *very interesting task*:\n\nThe girl is given a field divided into squares. That is, each side is $1$. And each square is painted in either white or black.\n\nWe say that a chessfield has sizes $n$ and $m$, when it consists of rectangles having $n$ units in height and $m$ units in width. Also, all these rectangles should be painted either white or black. And each white rectangle borders only on black and vice versa --- each black borders only on white.\n\nFor example, the following chessboard has sizes $2$ and $3$ (blue is the coordinate axis):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/88zoek3f.png)\n\nBut these are not:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/egfvlilp.png)\n\nAs you may have noticed, there are often a lot of chessfiels with sizes $n$ and $m$. The challenge is to say how many there are. *No-no-no, it's too easy*.\n\nAnnochka also knows $k$ squares on this field and their colors. Pani must find the number of chessfields with sizes $n$ and $m$ such that the squares with the corresponding coordinates have the specified colors. Help her do it!\n\nMore formally, you are given $k$ triplets of numbers: $x_i, y_i, c_i$, where ($x_i,y_i$) --- the coordinates of the lower left edge of the square, and $c_i$ is $0$ if this square is to be is painted black, and is $1$ if this square is to be painted white. You need to print the number of different chessfields with sizes $n$ and $m$ that fit under these constraints. Two chessfields are considered different if there is at least one square painted in different colors on these planes.", "inputFormat": "The first line contains four integers $n$, $m$, $k$, $g$ ($1 \\leq k \\leq 10^5$, $1 \\leq n, m \\leq 10^9$, $0 \\leq g \\leq 4$) --- the height of each rectangular, the width of each rectangular, the number of known squares and the number of group.\n\nEach of the next $k$ lines contains three integers $x_i$, $y_i$, $c_i$ ($1 \\leq x_i, y_i \\leq 10^9, 0 \\leq c_i \\leq 1$) --- the coordinates and color size. Note that coordinates can be **repeated**.", "outputFormat": "Print one integer --- the number of different chess planes with sizes $n$ and $m$ that fit the given constraints.", "hint": "On the left is an image of a single plane that fits the $1$ example limit.\n\nOn the right side there is one of the $8$ possible chessfields that satisfy the conditions of the example $2$.\n\n(Blue is the coordinate axis, light gray --- squares, which should be white, dark gray --- squares, which should be black).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b1ygrj64.png)\n\n- ($17$ points): $1 \\leq n, m, x_i, y_i, k \\leq 100$;\n- ($24$ points): $1 \\leq n, m, k \\leq 100$;\n- ($31$ points): $1 \\leq n \\cdot m \\leq 10^5, 1 \\leq k \\leq 10^4$;\n- ($28$ points): without additional restrictions.", "locale": "en"}, "zh-CN": {"title": "[UOI 2020] Chessfield", "background": "1s 256M", "description": "Pani Annochka 最近参加了一家 IT 公司的面试。在面试中，她被赋予了一个*非常有趣的任务*：\n\n女孩被给定一个被划分为方格的区域。每个方格的边长为 $1$，且每个方格被涂成白色或黑色。\n\n我们称一个棋盘区域的大小为 $n$ 和 $m$，当它由高度为 $n$ 个单位、宽度为 $m$ 个单位的矩形组成。此外，所有这些矩形必须被涂成白色或黑色，且每个白色矩形只能与黑色矩形相邻，反之亦然——每个黑色矩形只能与白色矩形相邻。\n\n例如，以下棋盘的大小为 $2$ 和 $3$（蓝色为坐标轴）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/88zoek3f.png)\n\n但以下这些不符合要求：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/egfvlilp.png)\n\n你可能已经注意到，大小为 $n$ 和 $m$ 的棋盘区域通常有很多种。挑战在于计算有多少种这样的棋盘区域。*不不不，这太简单了*。\n\nAnnochka 还知道该区域上的 $k$ 个方格及其颜色。Pani 需要找到满足以下条件的棋盘区域数量：这些方格在对应坐标处必须具有指定的颜色。帮助她完成这个任务！\n\n更正式地说，给定 $k$ 组三元数：$x_i$, $y_i$, $c_i$，其中 $(x_i, y_i)$ 是方格左下角的坐标，$c_i$ 为 $0$ 表示该方格应为黑色，为 $1$ 表示该方格应为白色。你需要输出满足这些约束条件的大小为 $n$ 和 $m$ 的不同棋盘区域的数量。如果两个棋盘区域中至少有一个方格的颜色不同，则认为它们是不同的。", "inputFormat": "第一行包含四个整数 $n$, $m$, $k$, $g$（$1 \\leq k \\leq 10^5$, $1 \\leq n, m \\leq 10^9$, $0 \\leq g \\leq 4$）——每个矩形的高度、每个矩形的宽度、已知方格的数量以及组别编号。\n\n接下来的 $k$ 行，每行包含三个整数 $x_i$, $y_i$, $c_i$（$1 \\leq x_i, y_i \\leq 10^9$, $0 \\leq c_i \\leq 1$）——方格的坐标和颜色。注意，坐标可能**重复**。\n", "outputFormat": "输出一个整数——满足给定约束条件的大小为 $n$ 和 $m$ 的不同棋盘区域的数量。\n", "hint": "左侧是满足样例 $1$ 条件的唯一棋盘区域的示意图。\n\n右侧是满足样例 $2$ 条件的 $8$ 种可能棋盘区域之一。\n\n（蓝色为坐标轴，浅灰色表示应为白色的方格，深灰色表示应为黑色的方格）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b1ygrj64.png)\n\n- （$17$ 分）：$1 \\leq n, m, x_i, y_i, k \\leq 100$；\n- （$24$ 分）：$1 \\leq n, m, k \\leq 100$；\n- （$31$ 分）：$1 \\leq n \\cdot m \\leq 10^5$, $1 \\leq k \\leq 10^4$；\n- （$28$ 分）：无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12635", "type": "P", "difficulty": 0, "samples": [["5 3 100 0\n0\n0\n1\n1\n0\n2\n3", "1 1\n1 2\n1 3\n1 4\n1 5\n1 1\n1 3\n2 1 2 1 2 3\n"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "交互题", "Special Judge", "UOI（乌克兰）"], "title": "[UOI 2020] Guess the Color", "background": "", "description": "Given $n$ balls numbered from $1$ to $n$. Each ball has its own color, which you do not know. There are $k$ different colors in total.\n\nYou can look at a ball in one query and find out the number of balls of the same color that you have already seen (including this one). You will not know the color of the ball itself with such a query. In total, such a query can be made no more than $c$ times.\n\nYou need to find an array $colors$ of $n$ elements, where each element --- an integer from $1$ to $k$ such that $colors[i]=colors[j]$ if and only if balls with numbers $i$ and $j$ of the same color.", "inputFormat": "### Interaction\n\nThe first line contains four integers $n$, $k$, $c$, and $g$ ($1 \\leq k \\leq n \\leq 10^4$) --- the number of balls, the number of colors, the maximum number of queries, and the block number, respectively. See the constraints on $c$ below.\n\nYou can make no more than $c$ queries. To make a query, you need to output the number $1$ and the number $index$ ($1 \\leq index \\leq n$) in one line --- the position of the ball you want to look at. After that, you need to output the end of line character and perform the 'flush' operation. Only after that can you read the answer.\n\nWhen you already know the answer --- you need to output the number $2$ and $n$ integers of the array $colors$, where each element is from $1$ to $k$. After that, you need to output the end of line character, perform the 'flush' operation, and terminate the program.", "outputFormat": "See Interaction", "hint": "Let $n=5$, $k=3$, $c=100$ and $a = [2\\ 1\\ 2\\ 1\\ 3]$.\n\nIf you look at a ball $1$, you will get a value of $1$. If you look at the ball $1$ again, the value will be $2$. Now, if you look at the ball $2$, the value will be $1$. Then for $3$ ball --- we get $3$. For $4$ ball --- we get $2$. For $5$ ball --- we get $1$.\n\nAfter that, the array $[2\\ 3\\ 2\\ 3\\ 1]$ can be returned. This answer will be correct.\n\n### Scoring\n\n- ($7$ points) $n \\le 10^4$; $k = n-1$; $c = 5 \\cdot 10^4$; there are two balls of the same color, and the rest of the balls are of different colors;\n- ($7$ points) $n \\le 10^4$; $k = 2$; $c = 5 \\cdot 10^4$;\n- ($10$ points) $n \\le 500$; $k \\le n$; $c = 3 \\cdot 10^5$;\n- ($14$ points) $n \\le 10^4$; $k \\le 10$; $c = 3 \\cdot 10^5$;\n- ($15$ points) $n \\le 10^4$; $k \\le n$; $c = 2 \\cdot 10^4$; for each color from $1$ to $k$, the number of balls of this color is different; each color occurs at least once;\n- (up to $47$ points) $n \\le 10^4$; $k \\le n$; $c = 4 \\cdot 10^6$:\n    - $7$ points if you use no more than $4 \\cdot 10^6$ requests;\n    - $17$ points if you use no more than $10^6$ requests;\n    - $32$ points if you use no more than $6 \\cdot 10^5$ requests;\n    - $47$ points if you use no more than $3 \\cdot 10^5$ requests;\n\n", "locale": "en", "translations": {"en": {"title": "[UOI 2020] Guess the Color", "background": "", "description": "Given $n$ balls numbered from $1$ to $n$. Each ball has its own color, which you do not know. There are $k$ different colors in total.\n\nYou can look at a ball in one query and find out the number of balls of the same color that you have already seen (including this one). You will not know the color of the ball itself with such a query. In total, such a query can be made no more than $c$ times.\n\nYou need to find an array $colors$ of $n$ elements, where each element --- an integer from $1$ to $k$ such that $colors[i]=colors[j]$ if and only if balls with numbers $i$ and $j$ of the same color.", "inputFormat": "### Interaction\n\nThe first line contains four integers $n$, $k$, $c$, and $g$ ($1 \\leq k \\leq n \\leq 10^4$) --- the number of balls, the number of colors, the maximum number of queries, and the block number, respectively. See the constraints on $c$ below.\n\nYou can make no more than $c$ queries. To make a query, you need to output the number $1$ and the number $index$ ($1 \\leq index \\leq n$) in one line --- the position of the ball you want to look at. After that, you need to output the end of line character and perform the 'flush' operation. Only after that can you read the answer.\n\nWhen you already know the answer --- you need to output the number $2$ and $n$ integers of the array $colors$, where each element is from $1$ to $k$. After that, you need to output the end of line character, perform the 'flush' operation, and terminate the program.", "outputFormat": "See Interaction", "hint": "Let $n=5$, $k=3$, $c=100$ and $a = [2\\ 1\\ 2\\ 1\\ 3]$.\n\nIf you look at a ball $1$, you will get a value of $1$. If you look at the ball $1$ again, the value will be $2$. Now, if you look at the ball $2$, the value will be $1$. Then for $3$ ball --- we get $3$. For $4$ ball --- we get $2$. For $5$ ball --- we get $1$.\n\nAfter that, the array $[2\\ 3\\ 2\\ 3\\ 1]$ can be returned. This answer will be correct.\n\n### Scoring\n\n- ($7$ points) $n \\le 10^4$; $k = n-1$; $c = 5 \\cdot 10^4$; there are two balls of the same color, and the rest of the balls are of different colors;\n- ($7$ points) $n \\le 10^4$; $k = 2$; $c = 5 \\cdot 10^4$;\n- ($10$ points) $n \\le 500$; $k \\le n$; $c = 3 \\cdot 10^5$;\n- ($14$ points) $n \\le 10^4$; $k \\le 10$; $c = 3 \\cdot 10^5$;\n- ($15$ points) $n \\le 10^4$; $k \\le n$; $c = 2 \\cdot 10^4$; for each color from $1$ to $k$, the number of balls of this color is different; each color occurs at least once;\n- (up to $47$ points) $n \\le 10^4$; $k \\le n$; $c = 4 \\cdot 10^6$:\n    - $7$ points if you use no more than $4 \\cdot 10^6$ requests;\n    - $17$ points if you use no more than $10^6$ requests;\n    - $32$ points if you use no more than $6 \\cdot 10^5$ requests;\n    - $47$ points if you use no more than $3 \\cdot 10^5$ requests;\n\n", "locale": "en"}, "zh-CN": {"title": "[UOI 2020] Guess the Color", "background": "6-60s 256M", "description": "给定编号从 $1$ 到 $n$ 的 $n$ 个球。每个球都有其未知的颜色，总共有 $k$ 种不同的颜色。\n\n每次查询时，你可以查看一个球，并获知当前已见过的同色球的数量（包括本次查询的球）。这种查询不会告诉你球的具体颜色。你最多可以进行 $c$ 次这样的查询。\n\n你需要找到一个长度为 $n$ 的数组 $colors$，其中每个元素是 $1$ 到 $k$ 之间的整数，且满足 $colors[i]=colors[j]$ 当且仅当编号为 $i$ 和 $j$ 的球颜色相同。", "inputFormat": "第一行包含四个整数 $n$、$k$、$c$ 和 $g$（$1 \\leq k \\leq n \\leq 10^4$）——分别表示球的数量、颜色的数量、最大查询次数以及测试组编号。关于 $c$ 的具体限制见下文。\n\n你最多可以进行 $c$ 次查询。每次查询时，你需要在一行中输出数字 $1$ 和球的编号 $index$（$1 \\leq index \\leq n$），表示你要查看的球的位置。之后，你需要输出换行符并执行 'flush' 操作。只有在执行完这些操作后，你才能读取查询结果。\n\n当你已经知道答案时，你需要输出数字 $2$ 和长度为 $n$ 的数组 $colors$，其中每个元素是 $1$ 到 $k$ 之间的整数。之后，你需要输出换行符，执行 'flush' 操作，并终止程序。\n", "outputFormat": "见交互说明", "hint": "设 $n=5$，$k=3$，$c=100$，且实际颜色数组为 $a = [2\\ 1\\ 2\\ 1\\ 3]$。\n\n如果你查询球 $1$，你会得到返回值 $1$。如果再次查询球 $1$，返回值将是 $2$。查询球 $2$ 时，返回值是 $1$。查询球 $3$ 时，返回值是 $3$。查询球 $4$ 时，返回值是 $2$。查询球 $5$ 时，返回值是 $1$。\n\n之后，你可以返回数组 $[2\\ 3\\ 2\\ 3\\ 1]$。这个答案是正确的。\n\n### 评分标准\n\n- （$7$ 分）$n \\leq 10^4$；$k = n-1$；$c = 5 \\cdot 10^4$；只有两个球同色，其余球颜色各不相同；\n- （$7$ 分）$n \\leq 10^4$；$k = 2$；$c = 5 \\cdot 10^4$；\n- （$10$ 分）$n \\leq 500$；$k \\leq n$；$c = 3 \\cdot 10^5$；\n- （$14$ 分）$n \\leq 10^4$；$k \\leq 10$；$c = 3 \\cdot 10^5$；\n- （$15$ 分）$n \\leq 10^4$；$k \\leq n$；$c = 2 \\cdot 10^4$；每种颜色对应的球的数量互不相同，且每种颜色至少出现一次；\n- （最多 $47$ 分）$n \\leq 10^4$；$k \\leq n$；$c = 4 \\cdot 10^6$：\n    - $7$ 分：使用不超过 $4 \\cdot 10^6$ 次查询；\n    - $17$ 分：使用不超过 $10^6$ 次查询；\n    - $32$ 分：使用不超过 $6 \\cdot 10^5$ 次查询；\n    - $47$ 分：使用不超过 $3 \\cdot 10^5$ 次查询。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12636", "type": "P", "difficulty": 7, "samples": [["4 10 1\n2 5 9 -4", "4\n1 1 2 0 "], ["5 1 100\n-1000 -1000 10 -1000 -1000", "10\n0 0 10 0 0 "], ["2 1 1\n1 0", "-1"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "UOI（乌克兰）"], "title": "[UOI 2020] Array Reduction", "background": "", "description": "Given an array $a$ consisting of $n$ integers. For one operation, you can choose position $i$ ($1 \\leq i \\leq n$), decrease $a_i$ by $k$, and increase the value of all other elements $a_j$ ($1 \\leq j \\leq n, i \\neq j$) by $t$.\n\nFind the minimum number of operations needed to make all elements of the array less than or equal to zero (i.e., non-positive), or report that it is impossible to do so.", "inputFormat": "The first line contains three integers $n$, $k$, $t$ ($1 \\leq n \\leq 10^6$, $0 \\leq k, t \\leq 10^9$) --- the length of the array and the operation parameters.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($-10^{18} \\leq a_i \\leq 10^9$) --- the initial values of the array elements.", "outputFormat": "Output a single integer $c$ --- the minimum number of operations needed to make all elements of the array less than or equal to zero. If it is impossible, output $-1$.\n\nIf it is possible, output $n$ integers $cnt_i$ ($1 \\leq i \\leq n$), which represent the number of operations performed on the element with index $i$. Note that the equality $\\sum\\limits_{i=1}^n cnt_i = c$ must hold.", "hint": "- ($3$ points) $t = 0$;\n- ($5$ points) $1 \\leq n \\leq 300, 0 \\leq |a_i| \\leq 300, 0 \\leq t \\leq 10^6$;\n- ($8$ points) $1 \\leq n \\leq 3000, 0 \\leq |a_i| \\leq 3000, 0 \\leq t \\leq 10^6$;\n- ($9$ points) $1 \\leq n \\leq 10^3, 1 \\leq a_i \\leq 10^9, 0 \\leq t \\leq 10^6$;\n- ($5$ points) $1 \\leq n \\leq 10^4, 1 \\leq a_i \\leq 10^9$;\n- ($13$ points) $1 \\leq n \\leq 10^5, 1 \\leq a_i \\leq 10^9$;\n- ($8$ points) $1 \\leq a_i \\leq 10^9$;\n- ($9$ points) $1 \\leq n \\leq 10^3, 0 \\leq t \\leq 10^6$;\n- ($5$ points) $1 \\leq n \\leq 10^4$;\n- ($14$ points) $1 \\leq n \\leq 10^5$;\n- ($21$ points) without additional constraints.", "locale": "en", "translations": {"en": {"title": "[UOI 2020] Array Reduction", "background": "", "description": "Given an array $a$ consisting of $n$ integers. For one operation, you can choose position $i$ ($1 \\leq i \\leq n$), decrease $a_i$ by $k$, and increase the value of all other elements $a_j$ ($1 \\leq j \\leq n, i \\neq j$) by $t$.\n\nFind the minimum number of operations needed to make all elements of the array less than or equal to zero (i.e., non-positive), or report that it is impossible to do so.", "inputFormat": "The first line contains three integers $n$, $k$, $t$ ($1 \\leq n \\leq 10^6$, $0 \\leq k, t \\leq 10^9$) --- the length of the array and the operation parameters.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($-10^{18} \\leq a_i \\leq 10^9$) --- the initial values of the array elements.", "outputFormat": "Output a single integer $c$ --- the minimum number of operations needed to make all elements of the array less than or equal to zero. If it is impossible, output $-1$.\n\nIf it is possible, output $n$ integers $cnt_i$ ($1 \\leq i \\leq n$), which represent the number of operations performed on the element with index $i$. Note that the equality $\\sum\\limits_{i=1}^n cnt_i = c$ must hold.", "hint": "- ($3$ points) $t = 0$;\n- ($5$ points) $1 \\leq n \\leq 300, 0 \\leq |a_i| \\leq 300, 0 \\leq t \\leq 10^6$;\n- ($8$ points) $1 \\leq n \\leq 3000, 0 \\leq |a_i| \\leq 3000, 0 \\leq t \\leq 10^6$;\n- ($9$ points) $1 \\leq n \\leq 10^3, 1 \\leq a_i \\leq 10^9, 0 \\leq t \\leq 10^6$;\n- ($5$ points) $1 \\leq n \\leq 10^4, 1 \\leq a_i \\leq 10^9$;\n- ($13$ points) $1 \\leq n \\leq 10^5, 1 \\leq a_i \\leq 10^9$;\n- ($8$ points) $1 \\leq a_i \\leq 10^9$;\n- ($9$ points) $1 \\leq n \\leq 10^3, 0 \\leq t \\leq 10^6$;\n- ($5$ points) $1 \\leq n \\leq 10^4$;\n- ($14$ points) $1 \\leq n \\leq 10^5$;\n- ($21$ points) without additional constraints.", "locale": "en"}, "zh-CN": {"title": "[UOI 2020] Array Reduction", "background": "5s 512M", "description": "给定一个包含 $n$ 个整数的数组 $a$。每次操作中，你可以选择一个位置 $i$（$1 \\leq i \\leq n$），将 $a_i$ 减少 $k$，同时将所有其他元素 $a_j$（$1 \\leq j \\leq n$ 且 $i \\neq j$）增加 $t$。\n\n求将数组中所有元素变为非正数（即小于或等于零）所需的最少操作次数。如果无法实现，则报告该情况。\n", "inputFormat": "第一行包含三个整数 $n$、$k$、$t$（$1 \\leq n \\leq 10^6$，$0 \\leq k, t \\leq 10^9$）——数组长度及操作参数。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\ldots, a_n$（$-10^{18} \\leq a_i \\leq 10^9$）——数组元素的初始值。\n", "outputFormat": "输出一个整数 $c$——将数组所有元素变为非正数所需的最少操作次数。如果无法实现，输出 $-1$。\n\n如果可以实现，还需输出 $n$ 个整数 $cnt_i$（$1 \\leq i \\leq n$），表示对第 $i$ 个元素执行的操作次数。注意必须满足 $\\sum\\limits_{i=1}^n cnt_i = c$。\n", "hint": "- （$3$ 分）$t = 0$；\n- （$5$ 分）$1 \\leq n \\leq 300$，$0 \\leq |a_i| \\leq 300$，$0 \\leq t \\leq 10^6$；\n- （$8$ 分）$1 \\leq n \\leq 3000$，$0 \\leq |a_i| \\leq 3000$，$0 \\leq t \\leq 10^6$；\n- （$9$ 分）$1 \\leq n \\leq 10^3$，$1 \\leq a_i \\leq 10^9$，$0 \\leq t \\leq 10^6$；\n- （$5$ 分）$1 \\leq n \\leq 10^4$，$1 \\leq a_i \\leq 10^9$；\n- （$13$ 分）$1 \\leq n \\leq 10^5$，$1 \\leq a_i \\leq 10^9$；\n- （$8$ 分）$1 \\leq a_i \\leq 10^9$；\n- （$9$ 分）$1 \\leq n \\leq 10^3$，$0 \\leq t \\leq 10^6$；\n- （$5$ 分）$1 \\leq n \\leq 10^4$；\n- （$14$ 分）$1 \\leq n \\leq 10^5$；\n- （$21$ 分）无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12637", "type": "P", "difficulty": 0, "samples": [["2 0\n2 3\n4 5 1\n9 2 0\n1 4\n1 4 5 4", "20\n4\n1 1 2 1\n1 2 2 2\n2 1 2 2\n2 2 2 3\n14\n3\n1 1 1 2\n1 2 1 3\n1 3 1 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "Special Judge", "UOI（乌克兰）"], "title": "[UOI 2020] Golden Field", "background": "", "description": "Vus the Cossack accidentally found a rectangular field $n \\times m$ square meters. The field has $n$ rows and $m$ columns. Rows are numbered from $1$ to $n$ from top to bottom. Columns are numbered from $1$ to $m$ from left to right.\n\nCossack noticed that in some squares there are gold coins, namely: in the square, which is in the $i$-th row and the $j$-th column, there are exactly $a_{ij}$ gold coins.\n\nJust pick up all the coins --- it's too easy for Vus, so he decided to take all the coins from the squares where the number of coins is even.\n\nHowever, this task turned out to be too easy for him, so Vus the Cossack decided to move the coins the next way: he can take **all** coins in a square and transfer them to any neighboring square. Squares are considered adjacent if they have a common side. He can perform the described shift operation any number of times.\n\nNow Cossack is wondering how many coins he can take. Help him find that number, and help him understand how he needs to move coins to pick up that number.\n\nNote that Cossack does not need to minimize the number of shift operations, he only needs to maximize the number of coins he will take.", "inputFormat": "The first line contains two integers $t$ and $g$ ($1 \\leq t \\leq 10$, $0 \\leq g \\leq 6$) --- number of tests and block number.\n\nThe first line of each test contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 50$) --- field sizes.\n\nEach of the next $n$ line contains $m$ integers $a_{i1}, a_{i2}, \\dots, a_{im}$ ($0 \\leq a_{ij} \\leq 100$) --- the number of gold coins in the squares.\n\nIt is not guaranteed that there is at least one coin in the field.", "outputFormat": "For each test, do the following:\n\nIn the first line, print one integer --- the maximum number of coins that Vus will take.\n\nIn the second line, print one integer $p$ ($0 \\leq p \\leq 10\\,000$) --- the number of move operations that need to be performed. Note that you do not need to minimize the value of $p$.\n\nIn each of the following $p$ lines, print four integers $x_1$, $y_1$, $x_2$, $y_2$ ($1 \\leq x_1, x_2 \\leq n$, $1 \\leq y_1, y_2 \\leq m$), which means that coins that are squared ($x_1$, $y_1$) must be shifted to the square ($x_2$, $y_2$).\n\nIf there are several correct answers, it is allowed to deduce any of them. It is guaranteed that there is an optimal answer, where the number of shift operations does not exceed $10\\,000$.", "hint": "In the first example, the Cossack can first move all the coins from the square $(1, 2)$ to $(2, 2)$, after which the field will look like this:\n\n$$\\begin{array}{cc}\n4 & 0 & 1\\\\\n9 & 7 & 0\\\\\n\\end{array}$$\n\nAfter shifting coins from $(2, 2)$ to $(2, 1)$ the field will look like this:\n\n$$\\begin{array}{cc}\n4 & 0 & 1\\\\\n16 & 0 & 0\\\\\n\\end{array}$$\n\nTherefore, the answer is $4+16=20$.\n\nIn the second example, the Cossack can first move all the coins from the square $(1, 1)$ to $(1, 2)$, after which the field will look like this:\n\n$$\\begin{array}{c}\n0 & 5 & 5 & 4\n\\end{array}$$\n\nAfter shifting coins from $(1, 2)$ to $(1, 3)$ the field will look like this:\n\n$$\\begin{array}{c}\n0 & 0 & 10 & 4\n\\end{array}$$\n\nTherefore, the answer is $10+4=14$.\n\n### Scoring\n\n- ($14$ points) $n=1$, all $a_{ij}$ are even;\n- ($16$ points) $n=1$, all $a_{ij}$ are odd;\n- ($19$ points) $n=1$;\n- ($14$ points) $n,m>1$, all $a_{ij}$ are even;\n- ($17$ points) $n,m>1$, all $a_{ij}$ are odd;\n- ($20$ points) $n,m>1$.", "locale": "en", "translations": {"en": {"title": "[UOI 2020] Golden Field", "background": "", "description": "Vus the Cossack accidentally found a rectangular field $n \\times m$ square meters. The field has $n$ rows and $m$ columns. Rows are numbered from $1$ to $n$ from top to bottom. Columns are numbered from $1$ to $m$ from left to right.\n\nCossack noticed that in some squares there are gold coins, namely: in the square, which is in the $i$-th row and the $j$-th column, there are exactly $a_{ij}$ gold coins.\n\nJust pick up all the coins --- it's too easy for Vus, so he decided to take all the coins from the squares where the number of coins is even.\n\nHowever, this task turned out to be too easy for him, so Vus the Cossack decided to move the coins the next way: he can take **all** coins in a square and transfer them to any neighboring square. Squares are considered adjacent if they have a common side. He can perform the described shift operation any number of times.\n\nNow Cossack is wondering how many coins he can take. Help him find that number, and help him understand how he needs to move coins to pick up that number.\n\nNote that Cossack does not need to minimize the number of shift operations, he only needs to maximize the number of coins he will take.", "inputFormat": "The first line contains two integers $t$ and $g$ ($1 \\leq t \\leq 10$, $0 \\leq g \\leq 6$) --- number of tests and block number.\n\nThe first line of each test contains two integers $n$ and $m$ ($1 \\leq n, m \\leq 50$) --- field sizes.\n\nEach of the next $n$ line contains $m$ integers $a_{i1}, a_{i2}, \\dots, a_{im}$ ($0 \\leq a_{ij} \\leq 100$) --- the number of gold coins in the squares.\n\nIt is not guaranteed that there is at least one coin in the field.", "outputFormat": "For each test, do the following:\n\nIn the first line, print one integer --- the maximum number of coins that Vus will take.\n\nIn the second line, print one integer $p$ ($0 \\leq p \\leq 10\\,000$) --- the number of move operations that need to be performed. Note that you do not need to minimize the value of $p$.\n\nIn each of the following $p$ lines, print four integers $x_1$, $y_1$, $x_2$, $y_2$ ($1 \\leq x_1, x_2 \\leq n$, $1 \\leq y_1, y_2 \\leq m$), which means that coins that are squared ($x_1$, $y_1$) must be shifted to the square ($x_2$, $y_2$).\n\nIf there are several correct answers, it is allowed to deduce any of them. It is guaranteed that there is an optimal answer, where the number of shift operations does not exceed $10\\,000$.", "hint": "In the first example, the Cossack can first move all the coins from the square $(1, 2)$ to $(2, 2)$, after which the field will look like this:\n\n$$\\begin{array}{cc}\n4 & 0 & 1\\\\\n9 & 7 & 0\\\\\n\\end{array}$$\n\nAfter shifting coins from $(2, 2)$ to $(2, 1)$ the field will look like this:\n\n$$\\begin{array}{cc}\n4 & 0 & 1\\\\\n16 & 0 & 0\\\\\n\\end{array}$$\n\nTherefore, the answer is $4+16=20$.\n\nIn the second example, the Cossack can first move all the coins from the square $(1, 1)$ to $(1, 2)$, after which the field will look like this:\n\n$$\\begin{array}{c}\n0 & 5 & 5 & 4\n\\end{array}$$\n\nAfter shifting coins from $(1, 2)$ to $(1, 3)$ the field will look like this:\n\n$$\\begin{array}{c}\n0 & 0 & 10 & 4\n\\end{array}$$\n\nTherefore, the answer is $10+4=14$.\n\n### Scoring\n\n- ($14$ points) $n=1$, all $a_{ij}$ are even;\n- ($16$ points) $n=1$, all $a_{ij}$ are odd;\n- ($19$ points) $n=1$;\n- ($14$ points) $n,m>1$, all $a_{ij}$ are even;\n- ($17$ points) $n,m>1$, all $a_{ij}$ are odd;\n- ($20$ points) $n,m>1$.", "locale": "en"}, "zh-CN": {"title": "[UOI 2020] Golden Field", "background": "", "description": "哥萨克人 Vus 偶然发现了一块 $n \\times m$ 平方米的矩形田地。这块田地有 $n$ 行 $m$ 列，行从上到下编号为 $1$ 到 $n$，列从左到右编号为 $1$ 到 $m$。\n\nVus 注意到某些方格中有金币：位于第 $i$ 行第 $j$ 列的方格中恰好有 $a_{ij}$ 枚金币。\n\n如果只是简单地捡起所有金币，对 Vus 来说太容易了，因此他决定只从金币数量为偶数的方格中收取金币。\n\n然而这个任务对他来说还是太简单，于是 Vus 决定通过以下方式移动金币：他可以将某个方格中的全部金币转移到任意相邻的方格中。两个方格相邻当且仅当它们共享一条边。他可以执行任意次数的这种转移操作。\n\n现在 Vus 想知道他最多能收取多少金币。请你帮他计算这个最大值，并告诉他应该如何移动金币才能达到这个目标。\n\n注意 Vus 不需要最小化转移操作的次数，他只需要最大化最终收取的金币数量。", "inputFormat": "第一行包含两个整数 $t$ 和 $g$（$1 \\leq t \\leq 10$，$0 \\leq g \\leq 6$）——测试用例数量和测试组编号。\n\n每个测试用例的第一行包含两个整数 $n$ 和 $m$（$1 \\leq n, m \\leq 50$）——田地的尺寸。\n\n接下来的 $n$ 行每行包含 $m$ 个整数 $a_{i1}, a_{i2}, \\dots, a_{im}$（$0 \\leq a_{ij} \\leq 100$）——每个方格中的金币数量。\n\n不保证田地中至少有一枚金币。", "outputFormat": "对于每个测试用例，按以下格式输出：\n\n第一行输出一个整数——Vus 能收取的最大金币数量。\n\n第二行输出一个整数 $p$（$0 \\leq p \\leq 10\\,000$）——需要执行的转移操作次数。注意不需要最小化 $p$ 的值。\n\n接下来的 $p$ 行，每行输出四个整数 $x_1$, $y_1$, $x_2$, $y_2$（$1 \\leq x_1, x_2 \\leq n$，$1 \\leq y_1, y_2 \\leq m$），表示将位于 $(x_1, y_1)$ 的方格中的所有金币转移到 $(x_2, y_2)$ 的方格中。\n\n如果有多个正确答案，输出任意一个即可。题目保证存在最优解，且转移操作次数不超过 $10\\,000$。\n", "hint": "在第一个样例中，Vus 可以先将 $(1, 2)$ 方格中的所有金币转移到 $(2, 2)$，此时田地状态为：\n\n$$\\begin{array}{cc}\n4 & 0 & 1\\\\\n9 & 7 & 0\\\\\n\\end{array}$$\n\n然后将 $(2, 2)$ 方格中的金币转移到 $(2, 1)$，田地状态变为：\n\n$$\\begin{array}{cc}\n4 & 0 & 1\\\\\n16 & 0 & 0\\\\\n\\end{array}$$\n\n因此最终收取的金币数量为 $4+16=20$。\n\n在第二个样例中，Vus 可以先将 $(1, 1)$ 方格中的金币转移到 $(1, 2)$，此时田地状态为：\n\n$$\\begin{array}{c}\n0 & 5 & 5 & 4\n\\end{array}$$\n\n然后将 $(1, 2)$ 方格中的金币转移到 $(1, 3)$，田地状态变为：\n\n$$\\begin{array}{c}\n0 & 0 & 10 & 4\n\\end{array}$$\n\n因此最终收取的金币数量为 $10+4=14$。\n\n### 评分标准\n\n- （$14$ 分）$n=1$，所有 $a_{ij}$ 为偶数；\n- （$16$ 分）$n=1$，所有 $a_{ij}$ 为奇数；\n- （$19$ 分）$n=1$；\n- （$14$ 分）$n,m>1$，所有 $a_{ij}$ 为偶数；\n- （$17$ 分）$n,m>1$，所有 $a_{ij}$ 为奇数；\n- （$20$ 分）$n,m>1$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12638", "type": "P", "difficulty": 0, "samples": [["3 0\n4 4 3", "5"], ["7 0\n4 7 7 4 2 2 3", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "UOI（乌克兰）"], "title": "[UOI 2020] Stone Pairs", "background": "", "description": "Alice and Bob have $n$ piles of stones numbered from $1$ to $n$. In the $i$-th merchant of $a_i$ stones. They perform the following process:\n\n- Alice chooses two non-empty piles. Let there are $x$ and $y$ stones in the piles, respectively.\n- Alice takes one stone from each of these piles.\n- Next, Bob also chooses two non-empty piles so that they also have $x$ and $y$ stones, respectively. That is, Bob chooses two piles so that they have the same number of stones as was originally in Alice's piles. Bob is allowed to choose the piles that Alice has chosen. If he can't do it, the process ends.\n- Bob also takes one stone from his chosen piles.\n- If the number of non-empty piles is less than $2$, the described process ends, otherwise it is repeated from the beginning.\n\nNote that Alice does not have to choose the same values of $x$ and $y$ each time.\n\nAlice and Bob want to make sure there are as few stones as possible in the piles. Note that they have a common goal. Help them find the minimum number of stones that may remain.", "inputFormat": "The first line contains two integers $n$ and $g$ ($2 \\leq n \\leq 2 \\cdot 10^5$, $0 \\leq g \\leq 5$) --- the number of piles and the group number.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\leq a_i \\leq 10^9$) --- the number of stones in each pile.", "outputFormat": "Print out one integer --- the answer.", "hint": "In the first example, Alice can first select the first and third piles: $x=4$ and $y=3$. After she picks up the stones, there will be $3, 4, 2$ stones in the piles, respectively.\n\nBob has to choose piles with $x=4$ and $y=3$ stones, so he will choose the second and first piles respectively. After he picks up the stones, there will be $2, 3, 2$ stones in the piles, respectively.\n\nIn the next step, Alice can choose, for example, the second and third piles: $x=3$ and $y=2$. After she picks up the stones, there will be $2, 2, 1$ stones in the piles, respectively.\n\nBob will not be able to choose such piles that they have $x=3$ and $y=2$ stones, so the process ends. There are $2+2+1=5$ stones left.\n\n### Scoring\n\n- ($17$ points) $n \\le 8$; $a_i \\le 8$;\n- ($23$ points) $n$ is even; $a_1=a_2,\\ a_3=a_4,\\ \\dots,\\ a_{n-1}=a_{n}$;\n- ($22$ points) all $a_i$ are even;\n- ($18$ points) $a_i \\le 2 \\cdot 10^5$\n- ($20$ points) without additional restrictions.", "locale": "en", "translations": {"en": {"title": "[UOI 2020] Stone Pairs", "background": "", "description": "Alice and Bob have $n$ piles of stones numbered from $1$ to $n$. In the $i$-th merchant of $a_i$ stones. They perform the following process:\n\n- Alice chooses two non-empty piles. Let there are $x$ and $y$ stones in the piles, respectively.\n- Alice takes one stone from each of these piles.\n- Next, Bob also chooses two non-empty piles so that they also have $x$ and $y$ stones, respectively. That is, Bob chooses two piles so that they have the same number of stones as was originally in Alice's piles. Bob is allowed to choose the piles that Alice has chosen. If he can't do it, the process ends.\n- Bob also takes one stone from his chosen piles.\n- If the number of non-empty piles is less than $2$, the described process ends, otherwise it is repeated from the beginning.\n\nNote that Alice does not have to choose the same values of $x$ and $y$ each time.\n\nAlice and Bob want to make sure there are as few stones as possible in the piles. Note that they have a common goal. Help them find the minimum number of stones that may remain.", "inputFormat": "The first line contains two integers $n$ and $g$ ($2 \\leq n \\leq 2 \\cdot 10^5$, $0 \\leq g \\leq 5$) --- the number of piles and the group number.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\leq a_i \\leq 10^9$) --- the number of stones in each pile.", "outputFormat": "Print out one integer --- the answer.", "hint": "In the first example, Alice can first select the first and third piles: $x=4$ and $y=3$. After she picks up the stones, there will be $3, 4, 2$ stones in the piles, respectively.\n\nBob has to choose piles with $x=4$ and $y=3$ stones, so he will choose the second and first piles respectively. After he picks up the stones, there will be $2, 3, 2$ stones in the piles, respectively.\n\nIn the next step, Alice can choose, for example, the second and third piles: $x=3$ and $y=2$. After she picks up the stones, there will be $2, 2, 1$ stones in the piles, respectively.\n\nBob will not be able to choose such piles that they have $x=3$ and $y=2$ stones, so the process ends. There are $2+2+1=5$ stones left.\n\n### Scoring\n\n- ($17$ points) $n \\le 8$; $a_i \\le 8$;\n- ($23$ points) $n$ is even; $a_1=a_2,\\ a_3=a_4,\\ \\dots,\\ a_{n-1}=a_{n}$;\n- ($22$ points) all $a_i$ are even;\n- ($18$ points) $a_i \\le 2 \\cdot 10^5$\n- ($20$ points) without additional restrictions.", "locale": "en"}, "zh-CN": {"title": "[UOI 2020] Stone Pairs", "background": "", "description": "Alice 和 Bob 有 $n$ 堆石子，编号从 $1$ 到 $n$。第 $i$ 堆石子有 $a_i$ 颗。他们执行以下过程：\n\n- Alice 选择两堆非空的石子堆，假设这两堆分别有 $x$ 和 $y$ 颗石子。\n- Alice 从这两堆中各取走一颗石子。\n- 接着，Bob 也必须选择两堆非空的石子堆，且这两堆的石子数量必须与 Alice 最初选择的两堆相同（即分别为 $x$ 和 $y$ 颗）。Bob 可以选择 Alice 选过的石堆。如果他无法选择这样的两堆，则过程结束。\n- Bob 从他选择的两堆中各取走一颗石子。\n- 如果非空的石子堆数量少于 $2$，则上述过程结束，否则重复从第一步开始。\n\n注意 Alice 每次可以选择不同的 $x$ 和 $y$ 值。\n\nAlice 和 Bob 希望最终剩下的石子尽可能少。注意他们的目标是共同的。请帮助他们求出最终可能剩下的最少石子数量。\n", "inputFormat": "第一行包含两个整数 $n$ 和 $g$（$2 \\leq n \\leq 2 \\cdot 10^5$，$0 \\leq g \\leq 5$）——石子堆的数量和测试组编号。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\dots, a_n$（$1 \\leq a_i \\leq 10^9$）——每堆石子的初始数量。\n", "outputFormat": "输出一个整数——最终剩下的最少石子数量。\n", "hint": "在第一个样例中，Alice 可以先选择第一堆和第三堆：$x=4$ 和 $y=3$。取走石子后，三堆的石子数量分别为 $3$、$4$、$2$。\n\nBob 必须选择石子数量为 $x=4$ 和 $y=3$ 的两堆，因此他会选择第二堆和第一堆。取走石子后，三堆的石子数量分别为 $2$、$3$、$2$。\n\n在下一步中，Alice 可以选择第二堆和第三堆：$x=3$ 和 $y=2$。取走石子后，三堆的石子数量分别为 $2$、$2$、$1$。\n\nBob 无法找到石子数量为 $x=3$ 和 $y=2$ 的两堆，因此过程结束。最终剩下的石子总数为 $2+2+1=5$。\n\n### 评分标准\n\n- （$17$ 分）$n \\leq 8$；$a_i \\leq 8$；\n- （$23$ 分）$n$ 为偶数；$a_1=a_2$，$a_3=a_4$，$\\dots$，$a_{n-1}=a_{n}$；\n- （$22$ 分）所有 $a_i$ 均为偶数；\n- （$18$ 分）$a_i \\leq 2 \\cdot 10^5$；\n- （$20$ 分）无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12639", "type": "P", "difficulty": 6, "samples": [["4\n1 <\n2 <\n3 >", "3"], ["4\n1 <\n1 <\n1 <", "6"], ["5\n1 <\n1 <\n3 >\n3 >", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2020", "树形 DP", "拓扑排序", "组合数学", "前缀和", "容斥原理", "UOI（乌克兰）"], "title": "[UOI 2020] Topological Sorting of a Tree", "background": "", "description": "You are given a tree with $n$ vertices, numbered from $1$ to $n$. The root of the tree is the vertex with number $1$. For each $v$ from $2$ to $n$, let's define $p_v$ as the number of the vertex adjacent to $v$ that lies on the simple path between vertex $v$ and the root. Each edge $(p_v, v)$ is labeled with the symbol $\\tt{<}$ or $\\tt{>}$.\n\nFind the number of ways to place the numbers from $1$ to $n$ in the vertices of the tree, such that each number is used exactly once and all the relationships indicated on the edges are satisfied. That is, for all edges with the symbol $\\tt{<}$, $a[p_v] < a[v]$ should hold, and for all edges with the symbol $\\tt{>}$, $a[p_v] > a[v]$ should hold.\n\nSince the answer can be very large, output it modulo $10^9 + 7$.", "inputFormat": "The first line contains a single integer $n$ ($1 \\leq n \\leq 3\\,000$) - the number of vertices in the tree.\n\nEach of the next $n-1$ lines contains a single integer $p_i$ ($1 \\leq p_i < i$) and a character $c_i$ ($c_i \\in \\{\\tt{<}, \\tt{>}\\}$), indicating that the edge between vertices with indices $p_i$ and $i$ is labeled with the symbol $c_i$. Note that the indexing starts from $2$.", "outputFormat": "Output a single integer - the number of ways to arrange all numbers from $1$ to $n$ in the vertices of the tree such that all the relationships indicated on the edges are satisfied. Note that you should output the remainder of the division by $10^9 + 7$, not the actual answer.", "hint": "- ($8$ points) $n \\leq 10$;\n- ($6$ points) $n \\leq 18$;\n- ($10$ points) $c_i = \\tt{<}$;\n- ($4$ points) $p_i = 1$;\n- ($13$ points) $p_i = i - 1, 1 \\leq n \\leq 200$;\n- ($19$ points) $p_i = i - 1$;\n- ($24$ points) $n \\leq 200$;\n- ($16$ points) no additional constraints.", "locale": "en", "translations": {"en": {"title": "[UOI 2020] Topological Sorting of a Tree", "background": "", "description": "You are given a tree with $n$ vertices, numbered from $1$ to $n$. The root of the tree is the vertex with number $1$. For each $v$ from $2$ to $n$, let's define $p_v$ as the number of the vertex adjacent to $v$ that lies on the simple path between vertex $v$ and the root. Each edge $(p_v, v)$ is labeled with the symbol $\\tt{<}$ or $\\tt{>}$.\n\nFind the number of ways to place the numbers from $1$ to $n$ in the vertices of the tree, such that each number is used exactly once and all the relationships indicated on the edges are satisfied. That is, for all edges with the symbol $\\tt{<}$, $a[p_v] < a[v]$ should hold, and for all edges with the symbol $\\tt{>}$, $a[p_v] > a[v]$ should hold.\n\nSince the answer can be very large, output it modulo $10^9 + 7$.", "inputFormat": "The first line contains a single integer $n$ ($1 \\leq n \\leq 3\\,000$) - the number of vertices in the tree.\n\nEach of the next $n-1$ lines contains a single integer $p_i$ ($1 \\leq p_i < i$) and a character $c_i$ ($c_i \\in \\{\\tt{<}, \\tt{>}\\}$), indicating that the edge between vertices with indices $p_i$ and $i$ is labeled with the symbol $c_i$. Note that the indexing starts from $2$.", "outputFormat": "Output a single integer - the number of ways to arrange all numbers from $1$ to $n$ in the vertices of the tree such that all the relationships indicated on the edges are satisfied. Note that you should output the remainder of the division by $10^9 + 7$, not the actual answer.", "hint": "- ($8$ points) $n \\leq 10$;\n- ($6$ points) $n \\leq 18$;\n- ($10$ points) $c_i = \\tt{<}$;\n- ($4$ points) $p_i = 1$;\n- ($13$ points) $p_i = i - 1, 1 \\leq n \\leq 200$;\n- ($19$ points) $p_i = i - 1$;\n- ($24$ points) $n \\leq 200$;\n- ($16$ points) no additional constraints.", "locale": "en"}, "zh-CN": {"title": "[UOI 2020] Topological Sorting of a Tree", "background": "", "description": "给定一棵包含 $n$ 个顶点的树，顶点编号从 $1$ 到 $n$。树的根节点是编号为 $1$ 的顶点。对于每个 $v$（从 $2$ 到 $n$），定义 $p_v$ 为与 $v$ 相邻且在 $v$ 到根节点路径上的顶点编号。每条边 $(p_v, v)$ 上都标有符号 $\\tt{<}$ 或 $\\tt{>}$。\n\n求将数字 $1$ 到 $n$ 填入树的所有顶点中的方案数，要求每个数字恰好使用一次，且满足所有边上标明的约束关系。具体来说：\n- 对于标有 $\\tt{<}$ 的边，需满足 $a[p_v] < a[v]$\n- 对于标有 $\\tt{>}$ 的边，需满足 $a[p_v] > a[v]$\n\n由于答案可能很大，请输出对 $10^9 + 7$ 取模的结果。", "inputFormat": "第一行包含一个整数 $n$（$1 \\leq n \\leq 3\\,000$）——树中顶点的数量。\n\n接下来的 $n-1$ 行，每行包含一个整数 $p_i$（$1 \\leq p_i < i$）和一个字符 $c_i$（$c_i \\in \\{\\tt{<}, \\tt{>}\\}$），表示顶点 $p_i$ 和 $i$ 之间的边标有符号 $c_i$。注意顶点编号从 $2$ 开始。\n", "outputFormat": "输出一个整数——将数字 $1$ 到 $n$ 填入顶点且满足所有边约束的方案数。注意需要输出对 $10^9 + 7$ 取模后的结果。\n", "hint": "- （$8$ 分）$n \\leq 10$；\n- （$6$ 分）$n \\leq 18$；\n- （$10$ 分）所有 $c_i = \\tt{<}$；\n- （$4$ 分）所有 $p_i = 1$；\n- （$13$ 分）$p_i = i - 1$，且 $1 \\leq n \\leq 200$；\n- （$19$ 分）所有 $p_i = i - 1$；\n- （$24$ 分）$n \\leq 200$；\n- （$16$ 分）无额外限制。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12640", "type": "P", "difficulty": 0, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["2020", "提交答案", "Special Judge", "UOI（乌克兰）"], "title": "[UOI 2020] Add edges", "background": "", "description": "Given a tree with $n$ vertices and $n-1$ edges. It is necessary to add exactly $m$ new edges to this tree. Adding multiple edges or loops is prohibited. If the degree of a certain vertex was $t_i$ before adding edges, then after adding edges, its degree should not exceed $t_i + k$. It should be noted that the degree of a vertex is the number of edges connecting it to other vertices.\n\nIn addition, $m+n-1$ integers $a_1, a_2, \\dots, a_{m+n-1}$ are given. After adding edges, it is necessary to assign each edge one of the elements of the array $a$ so that each element of the array corresponds to exactly one edge. The value $a_i$ assigned to the edge will denote its weight.\n\nIt is necessary to add new edges and assign numbers to the edges in such a way that the sum of the shortest distances between each pair of vertices is **maximized**. That is, it is necessary to maximize the function $\\sum d_{ij}$, where $d_{ij}$ is the minimum distance between vertices, for all $i$ and $j$ ($1 \\leq i < j \\leq n$). The minimum distance between vertices is considered to be the sum of the weights of all edges on the simple path between them.\n\nPlease note that in this problem, you need to submit not the code, but the actual answers. You also have access to all the tests.", "inputFormat": "There are $5$ tests.\n\nThe first line of each test contains three integers $n$, $m$, and $k$ ($1 \\leq n \\leq 5\\,000$, $1 \\leq m \\leq 250\\,000$, $1 \\leq k \\leq 500$) - the number of vertices in the tree, the number of edges to be added, and the maximum number of edges that can be added to one vertex.\n\nThe second line contains $m+n-1$ integers $a_1, a_2, \\dots, a_{m+n-1}$ ($1 \\leq a_i \\leq 10^6$).\n\nThe next $n-1$ lines contain two integers each, $v_i$ and $u_i$ ($1 \\leq v_i, u_i \\leq n$) - the numbers of vertices connected by an edge. It is guaranteed that the initially given graph is a tree.\n\nIt is guaranteed that it is always possible to add edges in such a way that all the requirements described in the task are met.", "outputFormat": "For each test, output the following:\n\nIf you have an answer for this test, output $1$, otherwise output $0$.\n\nIf you have an answer, then in each of the next $m+n-1$ lines, output three integers $v_i, u_i, a_i$ - the numbers of vertices connected by an edge in the final graph, and its weight.", "hint": "Let $d_0$ be a certain variable in the test, and $d$ be the sum of distances in your graph. If $d>d_0$, you will receive $20$ points for the test. Otherwise, you will receive as many points for the test as: $$(100^{(d-d_0)/d_0})^5 \\cdot 20$$\n\nIf $s$ is the sum of points for all tests, then for the attempt you will receive $s$, rounded to the nearest integer.", "locale": "en", "translations": {"en": {"title": "[UOI 2020] Add edges", "background": "", "description": "Given a tree with $n$ vertices and $n-1$ edges. It is necessary to add exactly $m$ new edges to this tree. Adding multiple edges or loops is prohibited. If the degree of a certain vertex was $t_i$ before adding edges, then after adding edges, its degree should not exceed $t_i + k$. It should be noted that the degree of a vertex is the number of edges connecting it to other vertices.\n\nIn addition, $m+n-1$ integers $a_1, a_2, \\dots, a_{m+n-1}$ are given. After adding edges, it is necessary to assign each edge one of the elements of the array $a$ so that each element of the array corresponds to exactly one edge. The value $a_i$ assigned to the edge will denote its weight.\n\nIt is necessary to add new edges and assign numbers to the edges in such a way that the sum of the shortest distances between each pair of vertices is **maximized**. That is, it is necessary to maximize the function $\\sum d_{ij}$, where $d_{ij}$ is the minimum distance between vertices, for all $i$ and $j$ ($1 \\leq i < j \\leq n$). The minimum distance between vertices is considered to be the sum of the weights of all edges on the simple path between them.\n\nPlease note that in this problem, you need to submit not the code, but the actual answers. You also have access to all the tests.", "inputFormat": "There are $5$ tests.\n\nThe first line of each test contains three integers $n$, $m$, and $k$ ($1 \\leq n \\leq 5\\,000$, $1 \\leq m \\leq 250\\,000$, $1 \\leq k \\leq 500$) - the number of vertices in the tree, the number of edges to be added, and the maximum number of edges that can be added to one vertex.\n\nThe second line contains $m+n-1$ integers $a_1, a_2, \\dots, a_{m+n-1}$ ($1 \\leq a_i \\leq 10^6$).\n\nThe next $n-1$ lines contain two integers each, $v_i$ and $u_i$ ($1 \\leq v_i, u_i \\leq n$) - the numbers of vertices connected by an edge. It is guaranteed that the initially given graph is a tree.\n\nIt is guaranteed that it is always possible to add edges in such a way that all the requirements described in the task are met.", "outputFormat": "For each test, output the following:\n\nIf you have an answer for this test, output $1$, otherwise output $0$.\n\nIf you have an answer, then in each of the next $m+n-1$ lines, output three integers $v_i, u_i, a_i$ - the numbers of vertices connected by an edge in the final graph, and its weight.", "hint": "Let $d_0$ be a certain variable in the test, and $d$ be the sum of distances in your graph. If $d>d_0$, you will receive $20$ points for the test. Otherwise, you will receive as many points for the test as: $$(100^{(d-d_0)/d_0})^5 \\cdot 20$$\n\nIf $s$ is the sum of points for all tests, then for the attempt you will receive $s$, rounded to the nearest integer.", "locale": "en"}, "zh-CN": {"title": "[UOI 2020] Add edges", "background": "", "description": "给定一棵包含 $n$ 个顶点和 $n-1$ 条边的树。需要在这棵树上添加恰好 $m$ 条新边。不允许添加重边或自环。如果某个顶点在添加边之前的度数为 $t_i$，那么在添加边之后，其度数不得超过 $t_i + k$。注意顶点的度数是指与其相连的边的数量。\n\n此外，给定 $m+n-1$ 个整数 $a_1, a_2, \\dots, a_{m+n-1}$。添加边后，需要为每条边分配数组 $a$ 中的一个元素，且每个数组元素恰好对应一条边。分配给边的值 $a_i$ 表示其权重。\n\n需要以如下方式添加新边并为边分配数值：使得所有顶点对之间的最短距离之和 **最大化**。即需要最大化函数 $\\sum d_{ij}$，其中 $d_{ij}$ 是顶点 $i$ 和 $j$（$1 \\leq i < j \\leq n$）之间的最小距离。顶点之间的最小距离是指它们之间简单路径上所有边的权重之和。\n\n请注意，本题不需要提交代码，而是需要提交实际答案。你可以访问所有测试数据。", "inputFormat": "共有 $5$ 个测试用例。\n\n每个测试用例的第一行包含三个整数 $n$、$m$ 和 $k$（$1 \\leq n \\leq 5\\,000$，$1 \\leq m \\leq 250\\,000$，$1 \\leq k \\leq 500$）——树中的顶点数量、需要添加的边数以及每个顶点可以添加的最大边数。\n\n第二行包含 $m+n-1$ 个整数 $a_1, a_2, \\dots, a_{m+n-1}$（$1 \\leq a_i \\leq 10^6$）。\n\n接下来的 $n-1$ 行，每行包含两个整数 $v_i$ 和 $u_i$（$1 \\leq v_i, u_i \\leq n$）——表示初始树中相连的顶点编号。保证初始给定的图是一棵树。\n\n保证总能以符合题目要求的方式添加边。", "outputFormat": "对于每个测试用例，输出以下内容：\n\n如果你有该测试用例的答案，输出 $1$，否则输出 $0$。\n\n如果有答案，则在接下来的 $m+n-1$ 行中，每行输出三个整数 $v_i$、$u_i$ 和 $a_i$——表示最终图中相连的顶点编号及其边的权重。\n", "hint": "设 $d_0$ 是测试用例中的某个基准值，$d$ 为你的图中所有顶点对距离之和。如果 $d > d_0$，你将获得该测试用例的 $20$ 分。否则，你将获得的分数为：\n$$(100^{(d-d_0)/d_0})^5 \\cdot 20$$\n\n如果 $s$ 是所有测试用例得分的总和，则本次提交将获得四舍五入后的整数 $s$ 分。", "locale": "zh-CN"}}}
{"pid": "P12641", "type": "P", "difficulty": 1, "samples": [["3 8\n2 1\n6 3\n4 4", "4"], ["1 30\n15 20", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "KOI（韩国）"], "title": "[KOI 2024 Round 1] 上学", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "小明为了不迟到，必须在 $X$ 分钟内到达学校。为了前往学校，他需要选择搭乘一辆在车站停靠的 $N$ 辆公交车中的一辆。\n\n懒惰的小明为了尽可能晚些出发，查阅了 $N$ 辆公交车的所有信息。他已经知道每辆公交车距离现在还有多少分钟会从车站出发（记为 $S$），也知道每辆公交车从车站到学校需要多少分钟（记为 $T$），但他尚未决定搭乘哪一辆。\n\n请帮助小明，在所有能够使他不迟到的公交车中，找出最晚出发的那一辆，并输出该公交车距离现在还有多少分钟会从车站出发。如果没有任何一辆公交车能让他准时到达学校，请输出 $-1$。", "inputFormat": "第一行给出 $N$ 和 $X$，用一个空格隔开。\n\n从第二行起，给出 $N$ 行，每行包含一个公交车的信息，其中每行包含两个数字：$S$（公交车从车站出发的时间）和 $T$（公交车从车站到学校的时间），两者用空格隔开。", "outputFormat": "如果没有公交车能够在 $X$ 分钟内到达学校，则输出 $-1$。\n\n如果有公交车能够在 $X$ 分钟内到达学校，则输出最晚出发的公交车从现在起出发所需的时间。", "hint": "**限制条件**\n- 所有给定的数字均为整数。\n- $1 \\leq N \\leq 100$\n- $2 \\leq X \\leq 200$\n- 对于每辆公交车，其出发时间 $S$ 和行驶时间 $T$ 满足：\n  - $1 \\leq S \\leq 100$\n  - $1 \\leq T \\leq 100$\n  \n**子问题**\n1. （10 分）$N = 1$\n2. （15 分）所有公交车都能在 $X$ 分钟内到达学校。\n3. （30 分）所有公交车的 $T = 20$\n4. （45 分）无额外限制条件\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2024 Round 1] 上学", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "小明为了不迟到，必须在 $X$ 分钟内到达学校。为了前往学校，他需要选择搭乘一辆在车站停靠的 $N$ 辆公交车中的一辆。\n\n懒惰的小明为了尽可能晚些出发，查阅了 $N$ 辆公交车的所有信息。他已经知道每辆公交车距离现在还有多少分钟会从车站出发（记为 $S$），也知道每辆公交车从车站到学校需要多少分钟（记为 $T$），但他尚未决定搭乘哪一辆。\n\n请帮助小明，在所有能够使他不迟到的公交车中，找出最晚出发的那一辆，并输出该公交车距离现在还有多少分钟会从车站出发。如果没有任何一辆公交车能让他准时到达学校，请输出 $-1$。", "inputFormat": "第一行给出 $N$ 和 $X$，用一个空格隔开。\n\n从第二行起，给出 $N$ 行，每行包含一个公交车的信息，其中每行包含两个数字：$S$（公交车从车站出发的时间）和 $T$（公交车从车站到学校的时间），两者用空格隔开。", "outputFormat": "如果没有公交车能够在 $X$ 分钟内到达学校，则输出 $-1$。\n\n如果有公交车能够在 $X$ 分钟内到达学校，则输出最晚出发的公交车从现在起出发所需的时间。", "hint": "**限制条件**\n- 所有给定的数字均为整数。\n- $1 \\leq N \\leq 100$\n- $2 \\leq X \\leq 200$\n- 对于每辆公交车，其出发时间 $S$ 和行驶时间 $T$ 满足：\n  - $1 \\leq S \\leq 100$\n  - $1 \\leq T \\leq 100$\n  \n**子问题**\n1. （10 分）$N = 1$\n2. （15 分）所有公交车都能在 $X$ 分钟内到达学校。\n3. （30 分）所有公交车的 $T = 20$\n4. （45 分）无额外限制条件\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P12642", "type": "P", "difficulty": 3, "samples": [["5\n3 1 4 1 5", "4"], ["5\n3 1 5 1 5", "6"], ["5\n1 2 3 4 5", "0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "递推", "2024", "KOI（韩国）"], "title": "[KOI 2024 Round 1] 加倍", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "给定一个长度为 $N$ 的正整数序列 $A_1, A_2, \\dots, A_N$。现在希望将该序列变为升序排列。所谓升序排列，是指对于所有的 $i$（$1 \\leq i \\leq N - 1$），都有 $A_i \\leq A_{i+1}$。\n\n为了将序列 $A$ 排成升序，可以对序列执行以下操作若干次（可为零次）：\n\n- 对于某个 $i$（$1 \\leq i \\leq N$），将 $A_i$ 乘以 $2$。\n\n你的任务是以最小的操作次数将序列 $A$ 排成升序，并输出所需的最小操作次数。", "inputFormat": "第一行输入一个整数 $N$。  \n第二行输入 $N$ 个整数，表示 $A_1, A_2, \\dots, A_N$，以空格分隔。", "outputFormat": "输出一个整数，表示将序列变为升序所需的最小操作次数。", "hint": "**样例 1 说明**\n\n对 $A_2$ 和 $A_4$ 各执行两次操作后，序列变为 $[3, 4, 4, 4, 5]$。\n\n**样例 2 说明**\n\n对 $A_2$ 操作两次，$A_4$ 操作三次，$A_5$ 操作一次，最终序列为 $[3, 4, 5, 8, 10]$。\n\n**约束条件**  \n- 所有给定的数均为整数。\n- $1 \\leq N \\leq 250\\,000$\n- $1 \\leq A_i \\leq 1\\,000\\,000$，其中 $1 \\leq i \\leq N$\n\n**子问题**\n1. （12 分）对于所有 $i$（$1 \\leq i \\leq N$），$A_i = 1$ 或 $A_i = 2$\n2. （10 分）对于所有 $i$（$1 \\leq i \\leq N$），存在非负整数 $k_i$，使得 $A_i = 2^{k_i}$\n3. （11 分）$N \\leq 10$\n4. （19 分）对于所有 $i$（$1 \\leq i \\leq N$），$A_i = 2$ 或 $A_i = 3$\n5. （20 分）对于所有 $i$（$1 \\leq i \\leq N - 1$），$A_i \\geq A_{i+1}$\n6. （28 分）无额外限制条件\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2024 Round 1] 加倍", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "给定一个长度为 $N$ 的正整数序列 $A_1, A_2, \\dots, A_N$。现在希望将该序列变为升序排列。所谓升序排列，是指对于所有的 $i$（$1 \\leq i \\leq N - 1$），都有 $A_i \\leq A_{i+1}$。\n\n为了将序列 $A$ 排成升序，可以对序列执行以下操作若干次（可为零次）：\n\n- 对于某个 $i$（$1 \\leq i \\leq N$），将 $A_i$ 乘以 $2$。\n\n你的任务是以最小的操作次数将序列 $A$ 排成升序，并输出所需的最小操作次数。", "inputFormat": "第一行输入一个整数 $N$。  \n第二行输入 $N$ 个整数，表示 $A_1, A_2, \\dots, A_N$，以空格分隔。", "outputFormat": "输出一个整数，表示将序列变为升序所需的最小操作次数。", "hint": "**样例 1 说明**\n\n对 $A_2$ 和 $A_4$ 各执行两次操作后，序列变为 $[3, 4, 4, 4, 5]$。\n\n**样例 2 说明**\n\n对 $A_2$ 操作两次，$A_4$ 操作三次，$A_5$ 操作一次，最终序列为 $[3, 4, 5, 8, 10]$。\n\n**约束条件**  \n- 所有给定的数均为整数。\n- $1 \\leq N \\leq 250\\,000$\n- $1 \\leq A_i \\leq 1\\,000\\,000$，其中 $1 \\leq i \\leq N$\n\n**子问题**\n1. （12 分）对于所有 $i$（$1 \\leq i \\leq N$），$A_i = 1$ 或 $A_i = 2$\n2. （10 分）对于所有 $i$（$1 \\leq i \\leq N$），存在非负整数 $k_i$，使得 $A_i = 2^{k_i}$\n3. （11 分）$N \\leq 10$\n4. （19 分）对于所有 $i$（$1 \\leq i \\leq N$），$A_i = 2$ 或 $A_i = 3$\n5. （20 分）对于所有 $i$（$1 \\leq i \\leq N - 1$），$A_i \\geq A_{i+1}$\n6. （28 分）无额外限制条件\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P12643", "type": "P", "difficulty": 2, "samples": [["4\n2 5 7 10\n20 4 16 11", "23"], ["3\n1 2 3\n3 2 1", "6"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "KOI（韩国）"], "title": "[KOI 2024 Round 1] 回收退货", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "如下图所示，沿直线排列的道路上，从左到右依次编号为 $1$ 到 $N$ 的 $N$ 户人家。第 $i$ 户人家的位置为 $X_i$（$X_i > 0$）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7wgrl8k4.png)\n\n一家快递公司打算使用一辆卡车沿这些人家路线访问，回收各家要退回的物品。卡车从快递公司所在的位置 $0$ 出发，出发时间为时刻 $0$。第 $i$ 户人家会在时刻 $T_i$ 将退货物品摆出。卡车以速度 $1$ 移动，因此移动距离为 $d$ 时，需要花费 $d$ 单位时间。卡车也可以原地等待，不必一直行驶。\n\n卡车一旦经过某户人家的位置，就可以瞬间回收退货物品。也就是说，回收物品所需时间为 $0$。因此，只要卡车在时刻 $T_i$ 或之后经过位置 $X_i$，就能成功回收第 $i$ 户人家的退货物品。\n\n现在给定各户人家在直线道路上的位置和其放出退货物品的时刻，请你编写程序，计算卡车完成所有退货物品回收，并返回快递公司所需的最短时间。", "inputFormat": "第一行输入一个整数 $N$，表示需要回收退货物品的人家数量。  \n第二行输入 $N$ 个整数，表示各户人家的位置 $X_1, X_2, \\dots, X_N$，以空格分隔。  \n第三行输入 $N$ 个整数，表示各户人家将退货物品摆出的时间 $T_1, T_2, \\dots, T_N$，以空格分隔。", "outputFormat": "输出一个整数，表示卡车回收所有物品并返回快递公司所需的最短时间。\n", "hint": "**约束条件**\n- 所有给定的数均为整数。\n- $1 \\leq N \\leq 3000$\n- $1 \\leq X_1 < X_2 < \\cdots < X_N \\leq 10^8$\n- $0 \\leq T_i \\leq 10^8 \\quad (1 \\leq i \\leq N)$\n\n**子问题**\n1. （10 分）$N = 2$\n2. （15 分）$N \\leq 9$\n3. （5 分）对所有 $1 \\leq i \\leq N$，$T_i = 0$\n4. （25 分）对所有 $2 \\leq i \\leq N$，都有 $T_{i-1} \\leq T_i$\n5. （45 分）无附加限制条件\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2024 Round 1] 回收退货", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "如下图所示，沿直线排列的道路上，从左到右依次编号为 $1$ 到 $N$ 的 $N$ 户人家。第 $i$ 户人家的位置为 $X_i$（$X_i > 0$）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7wgrl8k4.png)\n\n一家快递公司打算使用一辆卡车沿这些人家路线访问，回收各家要退回的物品。卡车从快递公司所在的位置 $0$ 出发，出发时间为时刻 $0$。第 $i$ 户人家会在时刻 $T_i$ 将退货物品摆出。卡车以速度 $1$ 移动，因此移动距离为 $d$ 时，需要花费 $d$ 单位时间。卡车也可以原地等待，不必一直行驶。\n\n卡车一旦经过某户人家的位置，就可以瞬间回收退货物品。也就是说，回收物品所需时间为 $0$。因此，只要卡车在时刻 $T_i$ 或之后经过位置 $X_i$，就能成功回收第 $i$ 户人家的退货物品。\n\n现在给定各户人家在直线道路上的位置和其放出退货物品的时刻，请你编写程序，计算卡车完成所有退货物品回收，并返回快递公司所需的最短时间。", "inputFormat": "第一行输入一个整数 $N$，表示需要回收退货物品的人家数量。  \n第二行输入 $N$ 个整数，表示各户人家的位置 $X_1, X_2, \\dots, X_N$，以空格分隔。  \n第三行输入 $N$ 个整数，表示各户人家将退货物品摆出的时间 $T_1, T_2, \\dots, T_N$，以空格分隔。", "outputFormat": "输出一个整数，表示卡车回收所有物品并返回快递公司所需的最短时间。\n", "hint": "**约束条件**\n- 所有给定的数均为整数。\n- $1 \\leq N \\leq 3000$\n- $1 \\leq X_1 < X_2 < \\cdots < X_N \\leq 10^8$\n- $0 \\leq T_i \\leq 10^8 \\quad (1 \\leq i \\leq N)$\n\n**子问题**\n1. （10 分）$N = 2$\n2. （15 分）$N \\leq 9$\n3. （5 分）对所有 $1 \\leq i \\leq N$，$T_i = 0$\n4. （25 分）对所有 $2 \\leq i \\leq N$，都有 $T_{i-1} \\leq T_i$\n5. （45 分）无附加限制条件\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P12644", "type": "P", "difficulty": 3, "samples": [["5 1\n1 3 10 11 15\n3 11", "7"], ["5 5\n1 3 11 17 20\n1 20\n2 2\n2 19\n2 28\n10 16", "15\n0\n8\n16\n0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "KOI（韩国）"], "title": "[KOI 2024 Round 1] 会议地点", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "在 KOI 村中，$N$ 户人家建在一条数轴直线上。每户人家住着一位居民。将这些人家的坐标按从小到大的顺序排列，第 $i$ 户人家的坐标为 $X_i$（$X_i > 0$）。\n\n当村子中有事务需要处理时，村民们会通过“会议集合”进行决策。每个会议集合可以由全体村民参与，也可以只由部分人参与。会议集合由若干场会议组成，每场会议都在参与者之一的家中举行。每个参与者的家中都会轮流召开一次会议，因此如果一个会议集合中有 $K$ 位村民参与，那么这个集合中会举行 $K$ 场会议。\n\n每场会议的开销是所有参与者从自己家前往会议地点所需的距离之和。一个会议集合的“疲劳度”由所有会议的开销顺序决定，定义为按照会议顺序，相邻两场会议的开销差的绝对值之和。\n\n例如，若人们住在坐标为 $1$、$3$、$10$、$11$、$15$ 的位置，其中住在 $3$、$10$ 和 $11$ 的三位居民参与会议集合，则：\n- 在坐标为 $3$ 的家开会的开销为 $|3 - 3| + |3 - 10| + |3 - 11| = 15$；\n- 在坐标为 $10$ 的家开会的开销为 $|10 - 3| + |10 - 10| + |10 - 11| = 8$；\n- 在坐标为 $11$ 的家开会的开销为 $|11 - 3| + |11 - 10| + |11 - 11| = 9$。\n\n若会议召开顺序为 $3 \\rightarrow 10 \\rightarrow 11$，则疲劳度为 $|15 - 8| + |8 - 9| = 8$；  \n若顺序为 $3 \\rightarrow 11 \\rightarrow 10$，则疲劳度为 $|15 - 9| + |9 - 8| = 7$，此时疲劳度最小。\n\n如果会议集合中参与者不超过 $1$ 人，疲劳度为 $0$。\n\nKOI 村将举行共 $Q$ 次会议集合。第 $i$ 次会议集合的参与者是住在坐标区间 $[L_i, R_i]$ 内的所有居民。请你编程，求出每次会议集合的最小疲劳度。", "inputFormat": "第一行输入两个整数 $N$ 和 $Q$，以空格分隔。  \n第二行输入 $N$ 个整数，表示居民所在的房屋坐标 $X_1, X_2, \\dots, X_N$，按升序排列。  \n接下来的 $Q$ 行，每行输入两个整数 $L_i$ 和 $R_i$，表示第 $i$ 次会议集合的参与者坐标范围。", "outputFormat": "输出 $Q$ 行，每行一个整数，第 $i$ 行表示第 $i$ 次会议集合的最小疲劳度。", "hint": "**约束条件**\n- 所有给定数值均为整数。\n- $1 \\leq N \\leq 200\\,000$\n- $1 \\leq Q \\leq 200\\,000$\n- $1 \\leq X_i \\leq 10^9 \\quad (1 \\leq i \\leq N)$\n- $X_i < X_{i+1} \\quad (1 \\leq i < N)$\n- $1 \\leq L_i \\leq R_i \\leq 10^9 \\quad (1 \\leq i \\leq Q)$\n\n**子问题**\n1. （5 分）$N \\leq 5$，$Q \\leq 5$\n2. （15 分）$N \\leq 16$，$Q \\leq 16$\n3. （15 分）$N \\leq 500$，$Q \\leq 500$\n4. （30 分）$N \\leq 3\\,000$，$Q \\leq 3\\,000$\n5. （35 分）无附加限制条件\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2024 Round 1] 会议地点", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "在 KOI 村中，$N$ 户人家建在一条数轴直线上。每户人家住着一位居民。将这些人家的坐标按从小到大的顺序排列，第 $i$ 户人家的坐标为 $X_i$（$X_i > 0$）。\n\n当村子中有事务需要处理时，村民们会通过“会议集合”进行决策。每个会议集合可以由全体村民参与，也可以只由部分人参与。会议集合由若干场会议组成，每场会议都在参与者之一的家中举行。每个参与者的家中都会轮流召开一次会议，因此如果一个会议集合中有 $K$ 位村民参与，那么这个集合中会举行 $K$ 场会议。\n\n每场会议的开销是所有参与者从自己家前往会议地点所需的距离之和。一个会议集合的“疲劳度”由所有会议的开销顺序决定，定义为按照会议顺序，相邻两场会议的开销差的绝对值之和。\n\n例如，若人们住在坐标为 $1$、$3$、$10$、$11$、$15$ 的位置，其中住在 $3$、$10$ 和 $11$ 的三位居民参与会议集合，则：\n- 在坐标为 $3$ 的家开会的开销为 $|3 - 3| + |3 - 10| + |3 - 11| = 15$；\n- 在坐标为 $10$ 的家开会的开销为 $|10 - 3| + |10 - 10| + |10 - 11| = 8$；\n- 在坐标为 $11$ 的家开会的开销为 $|11 - 3| + |11 - 10| + |11 - 11| = 9$。\n\n若会议召开顺序为 $3 \\rightarrow 10 \\rightarrow 11$，则疲劳度为 $|15 - 8| + |8 - 9| = 8$；  \n若顺序为 $3 \\rightarrow 11 \\rightarrow 10$，则疲劳度为 $|15 - 9| + |9 - 8| = 7$，此时疲劳度最小。\n\n如果会议集合中参与者不超过 $1$ 人，疲劳度为 $0$。\n\nKOI 村将举行共 $Q$ 次会议集合。第 $i$ 次会议集合的参与者是住在坐标区间 $[L_i, R_i]$ 内的所有居民。请你编程，求出每次会议集合的最小疲劳度。", "inputFormat": "第一行输入两个整数 $N$ 和 $Q$，以空格分隔。  \n第二行输入 $N$ 个整数，表示居民所在的房屋坐标 $X_1, X_2, \\dots, X_N$，按升序排列。  \n接下来的 $Q$ 行，每行输入两个整数 $L_i$ 和 $R_i$，表示第 $i$ 次会议集合的参与者坐标范围。", "outputFormat": "输出 $Q$ 行，每行一个整数，第 $i$ 行表示第 $i$ 次会议集合的最小疲劳度。", "hint": "**约束条件**\n- 所有给定数值均为整数。\n- $1 \\leq N \\leq 200\\,000$\n- $1 \\leq Q \\leq 200\\,000$\n- $1 \\leq X_i \\leq 10^9 \\quad (1 \\leq i \\leq N)$\n- $X_i < X_{i+1} \\quad (1 \\leq i < N)$\n- $1 \\leq L_i \\leq R_i \\leq 10^9 \\quad (1 \\leq i \\leq Q)$\n\n**子问题**\n1. （5 分）$N \\leq 5$，$Q \\leq 5$\n2. （15 分）$N \\leq 16$，$Q \\leq 16$\n3. （15 分）$N \\leq 500$，$Q \\leq 500$\n4. （30 分）$N \\leq 3\\,000$，$Q \\leq 3\\,000$\n5. （35 分）无附加限制条件\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P12645", "type": "P", "difficulty": 5, "samples": [["5\n0 0\n1 0\n1 2\n3 1\n4 4", "3\n7\n21\n47\n254"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "KOI（韩国）"], "title": "[KOI 2024 Round 1] 二叉树", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "对于所有子节点个数为 $0$ 或 $2$ 的二叉树 $T$，定义 $S(T)$ 的值如下：\n\n- 对于 $T$ 中某个节点 $u$，以 $u$ 为根的子树是仅包含 $u$ 和 $u$ 的所有后代节点的集合。\n- $T$ 的中序遍历序列 $p(T)$ 是按照中序遍历方式访问节点所得到的序列，其定义如下：\n  - 设 $r$ 为 $T$ 的根节点。记 $[r]$ 为仅包含 $r$ 的长度为 $1$ 的序列。\n  - 若 $r$ 没有子节点，则 $p(T) = [r]$；\n  - 若 $r$ 有两个子节点，设以 $r$ 的左子节点为根的子树为 $X$，右子节点为根的子树为 $Y$，则有 $p(T) = p(X), [r], p(Y)$，按此顺序拼接而成。\n- 设 $T$ 的叶子节点数为 $k$。将编号 $1, 2, \\dots, k$ 按照这些叶子节点在 $p(T)$ 中出现的顺序赋予它们。\n- 若选择了一个子树，该子树中包含的所有叶子节点就被称为“被覆盖”。\n- 对于 $1 \\leq a \\leq b \\leq k$，定义 $f(a, b)$ 为为了只覆盖编号在 $[a, b]$ 区间内的叶子节点而不覆盖其他叶子节点所需选择的最少子树个数。\n- $S(T)$ 的值为所有满足 $1 \\leq a \\leq b \\leq k$ 的整数对 $(a, b)$ 的 $f(a, b)$ 之和对 $10^9 + 7$ 取模的结果。\n\n例如，假设给定一个如图所示的二叉树 $T$，则 $f(5, 7)$ 的值为 $2$，因为可以通过选择两个子树来仅覆盖 $5$、$6$ 和 $7$ 号叶子节点。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lkqncxr5.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2bfbbyo7.png)\n\n根据上述方式，对所有 $1 \\leq a \\leq b \\leq 7$ 的 $f(a, b)$ 求和得到 $47$，因此 $S(T) = 47 \\bmod (10^9 + 7)$。\n\n给定两个整数序列 $A_1, A_2, \\dots, A_N$ 和 $B_1, B_2, \\dots, B_N$，定义一系列二叉树 $T_0, T_1, \\dots, T_N$ 如下：\n\n- $T_0$ 为仅包含一个节点的树；\n- 对于 $1 \\leq i \\leq N$，$T_i$ 是一个二叉树，其左子树为 $T_{A_i}$，右子树为 $T_{B_i}$。\n\n请编写程序，求出 $S(T_1), S(T_2), \\dots, S(T_N)$。", "inputFormat": "第一行输入一个整数 $N$。  \n接下来 $N$ 行，每行输入两个整数 $A_i$ 和 $B_i$，以空格分隔。", "outputFormat": "输出 $N$ 行，第 $i$ 行输出 $S(T_i)$ 的值。", "hint": "**样例 1 解释**\n\n示例中的 $T_4$ 如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/looj12wu.png)\n\n**约束条件**\n\n- 所有输入均为整数。\n- $1 \\leq N \\leq 100\\,000$\n- $0 \\leq A_i \\leq i - 1\\ (1 \\leq i \\leq N)$\n- $0 \\leq B_i \\leq i - 1\\ (1 \\leq i \\leq N)$\n\n**子问题**\n1. （5 分）$A_i = B_i = i - 1\\ (1 \\leq i \\leq N),\\ N \\leq 10$\n2. （10 分）$A_i = B_i = i - 1$\n3. （5 分）$A_i = i - 1,\\ B_i = 0$\n4. （10 分）所有 $T_1, \\dots, T_N$ 的节点总数不超过 $1\\,000$\n5. （25 分）所有 $T_1, \\dots, T_N$ 的节点总数不超过 $300\\,000$\n6. （45 分）无额外限制条件\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2024 Round 1] 二叉树", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "对于所有子节点个数为 $0$ 或 $2$ 的二叉树 $T$，定义 $S(T)$ 的值如下：\n\n- 对于 $T$ 中某个节点 $u$，以 $u$ 为根的子树是仅包含 $u$ 和 $u$ 的所有后代节点的集合。\n- $T$ 的中序遍历序列 $p(T)$ 是按照中序遍历方式访问节点所得到的序列，其定义如下：\n  - 设 $r$ 为 $T$ 的根节点。记 $[r]$ 为仅包含 $r$ 的长度为 $1$ 的序列。\n  - 若 $r$ 没有子节点，则 $p(T) = [r]$；\n  - 若 $r$ 有两个子节点，设以 $r$ 的左子节点为根的子树为 $X$，右子节点为根的子树为 $Y$，则有 $p(T) = p(X), [r], p(Y)$，按此顺序拼接而成。\n- 设 $T$ 的叶子节点数为 $k$。将编号 $1, 2, \\dots, k$ 按照这些叶子节点在 $p(T)$ 中出现的顺序赋予它们。\n- 若选择了一个子树，该子树中包含的所有叶子节点就被称为“被覆盖”。\n- 对于 $1 \\leq a \\leq b \\leq k$，定义 $f(a, b)$ 为为了只覆盖编号在 $[a, b]$ 区间内的叶子节点而不覆盖其他叶子节点所需选择的最少子树个数。\n- $S(T)$ 的值为所有满足 $1 \\leq a \\leq b \\leq k$ 的整数对 $(a, b)$ 的 $f(a, b)$ 之和对 $10^9 + 7$ 取模的结果。\n\n例如，假设给定一个如图所示的二叉树 $T$，则 $f(5, 7)$ 的值为 $2$，因为可以通过选择两个子树来仅覆盖 $5$、$6$ 和 $7$ 号叶子节点。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lkqncxr5.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2bfbbyo7.png)\n\n根据上述方式，对所有 $1 \\leq a \\leq b \\leq 7$ 的 $f(a, b)$ 求和得到 $47$，因此 $S(T) = 47 \\bmod (10^9 + 7)$。\n\n给定两个整数序列 $A_1, A_2, \\dots, A_N$ 和 $B_1, B_2, \\dots, B_N$，定义一系列二叉树 $T_0, T_1, \\dots, T_N$ 如下：\n\n- $T_0$ 为仅包含一个节点的树；\n- 对于 $1 \\leq i \\leq N$，$T_i$ 是一个二叉树，其左子树为 $T_{A_i}$，右子树为 $T_{B_i}$。\n\n请编写程序，求出 $S(T_1), S(T_2), \\dots, S(T_N)$。", "inputFormat": "第一行输入一个整数 $N$。  \n接下来 $N$ 行，每行输入两个整数 $A_i$ 和 $B_i$，以空格分隔。", "outputFormat": "输出 $N$ 行，第 $i$ 行输出 $S(T_i)$ 的值。", "hint": "**样例 1 解释**\n\n示例中的 $T_4$ 如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/looj12wu.png)\n\n**约束条件**\n\n- 所有输入均为整数。\n- $1 \\leq N \\leq 100\\,000$\n- $0 \\leq A_i \\leq i - 1\\ (1 \\leq i \\leq N)$\n- $0 \\leq B_i \\leq i - 1\\ (1 \\leq i \\leq N)$\n\n**子问题**\n1. （5 分）$A_i = B_i = i - 1\\ (1 \\leq i \\leq N),\\ N \\leq 10$\n2. （10 分）$A_i = B_i = i - 1$\n3. （5 分）$A_i = i - 1,\\ B_i = 0$\n4. （10 分）所有 $T_1, \\dots, T_N$ 的节点总数不超过 $1\\,000$\n5. （25 分）所有 $T_1, \\dots, T_N$ 的节点总数不超过 $300\\,000$\n6. （45 分）无额外限制条件\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P12646", "type": "P", "difficulty": 5, "samples": [["10 5\n5 2 7 3 2 9 6 3 3 5\n3 9\n1 10\n1 8\n2 4\n8 9", "14\n27\n19\n2\n0"], ["10 5\n2 8 4 9 10 8 5 3 7 7\n2 8\n1 10\n3 3\n1 3\n8 10", "7\n11\n0\n1\n0"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "单调栈", "KOI（韩国）"], "title": "[KOI 2024 Round 1] 升序", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "给定一个长度为 $M$ 的正整数序列 $X_1, X_2, \\dots, X_M$，我们希望将这个序列变为升序。一个序列 $X_1, X_2, \\dots, X_M$ 是升序的，当且仅当对所有 $i$（$1 \\leq i \\leq M - 1$）满足 $X_i \\leq X_{i+1}$。\n\n为了将序列 $X$ 变为升序，可以对其应用如下操作任意次数（包括 $0$ 次）：\n\n- 对于某个 $i$（$1 \\leq i \\leq M$），将 $X_i$ 乘以 $2$。\n\n我们将通过最少的操作次数将 $X$ 变为升序时所需的操作次数记为 $f(X)$。\n\n现在，给定一个长度为 $N$ 的正整数序列 $A_1, A_2, \\dots, A_N$，以及 $Q$ 个查询。每个查询给出两个整数 $l$ 和 $r$，满足 $1 \\leq l \\leq r \\leq N$。查询的目标是计算 $f(A_l, A_{l+1}, \\dots, A_r)$，即将从 $A$ 中截取的子序列升序所需的最小操作次数。\n\n请计算并输出每个查询的答案。", "inputFormat": "第一行输入两个整数 $N$ 和 $Q$，用空格分隔。  \n第二行输入 $N$ 个整数 $A_1, A_2, \\dots, A_N$，用空格分隔。  \n接下来的 $Q$ 行，每行输入两个整数 $l$ 和 $r$，表示一次查询。", "outputFormat": "输出 $Q$ 行，第 $i$ 行输出第 $i$ 个查询的答案。\n", "hint": "**约束条件**\n\n- 所有输入均为整数。\n- $1 \\leq N \\leq 250\\,000$\n- $1 \\leq Q \\leq 250\\,000$\n- $1 \\leq A_i \\leq 10^9 \\quad (1 \\leq i \\leq N)$\n- 对所有查询满足 $1 \\leq l \\leq r \\leq N$\n\n**子问题**\n\n1.（5 分）$N \\leq 10\\,000,\\ Q \\leq 10\\,000$  \n2.（7 分）$N \\leq 10\\,000$  \n3.（28 分）所有查询满足 $r = N$  \n4.（10 分）对所有 $i$ 满足 $A_i \\geq A_{i+1}$  \n5.（5 分）对所有 $i$ 满足 $A_i \\leq 2$  \n6.（10 分）对所有 $i$ 存在非负整数 $k_i$ 使得 $A_i = 2^{k_i}$  \n7.（35 分）无额外限制条件\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2024 Round 1] 升序", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "给定一个长度为 $M$ 的正整数序列 $X_1, X_2, \\dots, X_M$，我们希望将这个序列变为升序。一个序列 $X_1, X_2, \\dots, X_M$ 是升序的，当且仅当对所有 $i$（$1 \\leq i \\leq M - 1$）满足 $X_i \\leq X_{i+1}$。\n\n为了将序列 $X$ 变为升序，可以对其应用如下操作任意次数（包括 $0$ 次）：\n\n- 对于某个 $i$（$1 \\leq i \\leq M$），将 $X_i$ 乘以 $2$。\n\n我们将通过最少的操作次数将 $X$ 变为升序时所需的操作次数记为 $f(X)$。\n\n现在，给定一个长度为 $N$ 的正整数序列 $A_1, A_2, \\dots, A_N$，以及 $Q$ 个查询。每个查询给出两个整数 $l$ 和 $r$，满足 $1 \\leq l \\leq r \\leq N$。查询的目标是计算 $f(A_l, A_{l+1}, \\dots, A_r)$，即将从 $A$ 中截取的子序列升序所需的最小操作次数。\n\n请计算并输出每个查询的答案。", "inputFormat": "第一行输入两个整数 $N$ 和 $Q$，用空格分隔。  \n第二行输入 $N$ 个整数 $A_1, A_2, \\dots, A_N$，用空格分隔。  \n接下来的 $Q$ 行，每行输入两个整数 $l$ 和 $r$，表示一次查询。", "outputFormat": "输出 $Q$ 行，第 $i$ 行输出第 $i$ 个查询的答案。\n", "hint": "**约束条件**\n\n- 所有输入均为整数。\n- $1 \\leq N \\leq 250\\,000$\n- $1 \\leq Q \\leq 250\\,000$\n- $1 \\leq A_i \\leq 10^9 \\quad (1 \\leq i \\leq N)$\n- 对所有查询满足 $1 \\leq l \\leq r \\leq N$\n\n**子问题**\n\n1.（5 分）$N \\leq 10\\,000,\\ Q \\leq 10\\,000$  \n2.（7 分）$N \\leq 10\\,000$  \n3.（28 分）所有查询满足 $r = N$  \n4.（10 分）对所有 $i$ 满足 $A_i \\geq A_{i+1}$  \n5.（5 分）对所有 $i$ 满足 $A_i \\leq 2$  \n6.（10 分）对所有 $i$ 存在非负整数 $k_i$ 使得 $A_i = 2^{k_i}$  \n7.（35 分）无额外限制条件\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P12647", "type": "P", "difficulty": 2, "samples": [["2\n-2 3 0\n4 8 6", "5\n4"], ["9\n-1 1 0\n-2 1 0\n-3 1 0\n-1 2 0\n-2 2 0\n-3 2 0\n-1 3 0\n-2 3 0\n-3 3 0", "2\n2\n2\n3\n4\n4\n3\n5\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2024", "KOI（韩国）"], "title": "[KOI 2024 Round 2] 寻宝游戏", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "你正与朋友小彬在如下图所示的无限长数轴上玩寻宝游戏。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2l3vf80d.png)\n\n首先，你会将两件宝物藏在数轴上两个不同的位置 $L$ 和 $R$ 上（满足 $L < R$）。下图为将宝物藏在 $L = -2$ 和 $R = 3$ 的一个例子。用橙色标示的两个格子中藏有宝物。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/m8lyeu2d.png)\n\n你藏好宝物后，小彬便开始找宝物。她将从你指定的起始位置 $S$ 出发，按照以下顺序进行：\n\n- 第一步：检查当前位置 $S$；\n- 第二步：向右移动 $1$ 格，检查位置 $S + 1$；\n- 第三步：向左移动 $2$ 格，检查位置 $S + 1 - 2$；\n- 第四步：向右移动 $3$ 格，检查位置 $S + 1 - 2 + 3$；\n- 第五步：向左移动 $4$ 格，检查位置 $S + 1 - 2 + 3 - 4$；\n- 第六步：向右移动 $5$ 格，检查位置 $S + 1 - 2 + 3 - 4 + 5$；\n- …\n\n也就是说，第 $x$ 步时，如果 $x$ 是偶数，小彬会向右移动 $x - 1$ 格；如果 $x$ 是奇数，小彬会向左移动 $x - 1$ 格，然后检查所到达的位置。\n\n如果某一步检查的位置上有宝物，游戏就结束。\n\n例如，在 $L = -2$、$R = 3$、$S = 0$ 的情形下，小彬会在第 $5$ 步检查位置 $-2$，那里藏有宝物，因此游戏会在第 $5$ 步结束。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qcbtzy39.png)", "inputFormat": "第一行输入一个整数 $T$，表示你想测试的游戏情况数。  \n接下来 $T$ 行，每行三个整数 $L\\ R\\ S$，表示两个宝物的位置 $L,\\ R$ 和小彬的起始位置 $S$。\n", "outputFormat": "输出 $T$ 行，第 $i$ 行输出对应第 $i$ 个游戏中，游戏在第几步结束（即找到第一个宝物）。\n", "hint": "**样例 1 说明**\n\n- 第一个例子如题面图所示，小彬第 $5$ 步找到了位置 $-2$ 的宝物。\n- 第二个例子中，小彬从 $6$ 出发：\n  - 第 1 步：$6$\n  - 第 2 步：$7$\n  - 第 3 步：$5$\n  - 第 4 步：$8$ ← 找到宝物，游戏结束。\n  \n**约束条件**\n- 所有输入为整数。\n- $1 \\leq T \\leq 10\\,000$\n- $-100\\,000\\,000 \\leq L < S < R \\leq 100\\,000\\,000$\n\n\n**子问题**\n1. （8 分）$T = 1,\\ R = 1,\\ S = 0$  \n2. （9 分）$T = 1,\\ L = -1,\\ S = 0$  \n3. （15 分）$-1\\,000 \\leq L \\leq -1,\\ 1 \\leq R \\leq 1\\,000,\\ S = 0$  \n4. （16 分）$-1\\,000 \\leq L < S < R \\leq 1\\,000$  \n5. （52 分）无额外限制条件\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2024 Round 2] 寻宝游戏", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "你正与朋友小彬在如下图所示的无限长数轴上玩寻宝游戏。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2l3vf80d.png)\n\n首先，你会将两件宝物藏在数轴上两个不同的位置 $L$ 和 $R$ 上（满足 $L < R$）。下图为将宝物藏在 $L = -2$ 和 $R = 3$ 的一个例子。用橙色标示的两个格子中藏有宝物。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/m8lyeu2d.png)\n\n你藏好宝物后，小彬便开始找宝物。她将从你指定的起始位置 $S$ 出发，按照以下顺序进行：\n\n- 第一步：检查当前位置 $S$；\n- 第二步：向右移动 $1$ 格，检查位置 $S + 1$；\n- 第三步：向左移动 $2$ 格，检查位置 $S + 1 - 2$；\n- 第四步：向右移动 $3$ 格，检查位置 $S + 1 - 2 + 3$；\n- 第五步：向左移动 $4$ 格，检查位置 $S + 1 - 2 + 3 - 4$；\n- 第六步：向右移动 $5$ 格，检查位置 $S + 1 - 2 + 3 - 4 + 5$；\n- …\n\n也就是说，第 $x$ 步时，如果 $x$ 是偶数，小彬会向右移动 $x - 1$ 格；如果 $x$ 是奇数，小彬会向左移动 $x - 1$ 格，然后检查所到达的位置。\n\n如果某一步检查的位置上有宝物，游戏就结束。\n\n例如，在 $L = -2$、$R = 3$、$S = 0$ 的情形下，小彬会在第 $5$ 步检查位置 $-2$，那里藏有宝物，因此游戏会在第 $5$ 步结束。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qcbtzy39.png)", "inputFormat": "第一行输入一个整数 $T$，表示你想测试的游戏情况数。  \n接下来 $T$ 行，每行三个整数 $L\\ R\\ S$，表示两个宝物的位置 $L,\\ R$ 和小彬的起始位置 $S$。\n", "outputFormat": "输出 $T$ 行，第 $i$ 行输出对应第 $i$ 个游戏中，游戏在第几步结束（即找到第一个宝物）。\n", "hint": "**样例 1 说明**\n\n- 第一个例子如题面图所示，小彬第 $5$ 步找到了位置 $-2$ 的宝物。\n- 第二个例子中，小彬从 $6$ 出发：\n  - 第 1 步：$6$\n  - 第 2 步：$7$\n  - 第 3 步：$5$\n  - 第 4 步：$8$ ← 找到宝物，游戏结束。\n  \n**约束条件**\n- 所有输入为整数。\n- $1 \\leq T \\leq 10\\,000$\n- $-100\\,000\\,000 \\leq L < S < R \\leq 100\\,000\\,000$\n\n\n**子问题**\n1. （8 分）$T = 1,\\ R = 1,\\ S = 0$  \n2. （9 分）$T = 1,\\ L = -1,\\ S = 0$  \n3. （15 分）$-1\\,000 \\leq L \\leq -1,\\ 1 \\leq R \\leq 1\\,000,\\ S = 0$  \n4. （16 分）$-1\\,000 \\leq L < S < R \\leq 1\\,000$  \n5. （52 分）无额外限制条件\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P12648", "type": "P", "difficulty": 3, "samples": [["10 3 4\n1 4 8", "0\n0\n0\n1"], ["4 5 5\n0 1 2 3 4", "0\n0\n0\n0\n0"], ["7 1 4\n3", "0\n1\n1\n2"], ["9 4 10\n0 3 6 9", "0\n0\n0\n0\n1\n1\n1\n1\n1\n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["模拟", "数学", "2024", "枚举", "排序", "KOI（韩国）"], "title": "[KOI 2024 Round 2] 路灯", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "在一条数轴表示的直线道路上，安装了 $N$ 盏路灯。每盏路灯的位置按从左到右依次为 $A_1 < A_2 < \\cdots < A_N$。\n\n我们定义某个位置 $x$ 的“黑暗程度”为该位置到所有路灯之间距离的最小值。即，黑暗程度等于数列 $|A_1 - x|, |A_2 - x|, \\dots, |A_N - x|$ 中的最小值。其中，$|y|$ 表示 $y$ 的绝对值，若 $y \\geq 0$，则 $|y| = y$；若 $y < 0$，则 $|y| = -y$。\n\n例如，若 $N = 3$，且路灯分别位于 $A_1 = 1$、$A_2 = 4$、$A_3 = 8$，那么从位置 $x = 0$ 到 $x = 10$ 的黑暗程度如下：\n\n| 位置 $x$ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\n|----------|---|---|---|---|---|---|---|---|---|----|----|\n| 黑暗程度 | 1 | 0 | 1 | 1 | 0 | 1 | 2 | 1 | 0 | 1  | 2  |\n| 是否有灯 |   | O |   |   | O |   |   |   | O |    |    |\n\n给定一个整数 $L$，我们关心从 $x = 0$ 到 $x = L$ 这 $L+1$ 个整数位置的黑暗程度。请你编程，输出其中按黑暗程度从小到大排序后的前 $K$ 小的值。", "inputFormat": "第一行输入三个整数 $L,\\ N,\\ K$，用空格隔开。  \n第二行输入 $N$ 个整数 $A_1, A_2, \\dots, A_N$，表示每盏路灯的位置，以空格隔开。", "outputFormat": "输出 $K$ 行，第 $i$ 行输出从小到大排序后的第 $i$ 小黑暗程度值。", "hint": "**约束条件**\n\n- 所有输入为整数。\n- $1 \\leq L \\leq 10^{18}$\n- $1 \\leq N \\leq 3 \\times 10^5$\n- $1 \\leq K \\leq 5 \\times 10^5$\n- $K \\leq L + 1$\n- $0 \\leq A_1 < A_2 < \\cdots < A_N \\leq L$\n\n**子问题**\n\n1. （10 分）$N = 1$  \n2. （20 分）$N \\leq 2\\,500,\\ L \\leq 2\\,500$  \n3. （15 分）$2 \\leq N$ 且 $N - 1$ 整除 $L$，且 $A_i = \\dfrac{L}{N-1} \\times (i - 1)$  \n4. （20 分）$L \\leq 5 \\times 10^6$  \n5. （35 分）无额外限制条件\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2024 Round 2] 路灯", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "在一条数轴表示的直线道路上，安装了 $N$ 盏路灯。每盏路灯的位置按从左到右依次为 $A_1 < A_2 < \\cdots < A_N$。\n\n我们定义某个位置 $x$ 的“黑暗程度”为该位置到所有路灯之间距离的最小值。即，黑暗程度等于数列 $|A_1 - x|, |A_2 - x|, \\dots, |A_N - x|$ 中的最小值。其中，$|y|$ 表示 $y$ 的绝对值，若 $y \\geq 0$，则 $|y| = y$；若 $y < 0$，则 $|y| = -y$。\n\n例如，若 $N = 3$，且路灯分别位于 $A_1 = 1$、$A_2 = 4$、$A_3 = 8$，那么从位置 $x = 0$ 到 $x = 10$ 的黑暗程度如下：\n\n| 位置 $x$ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\n|----------|---|---|---|---|---|---|---|---|---|----|----|\n| 黑暗程度 | 1 | 0 | 1 | 1 | 0 | 1 | 2 | 1 | 0 | 1  | 2  |\n| 是否有灯 |   | O |   |   | O |   |   |   | O |    |    |\n\n给定一个整数 $L$，我们关心从 $x = 0$ 到 $x = L$ 这 $L+1$ 个整数位置的黑暗程度。请你编程，输出其中按黑暗程度从小到大排序后的前 $K$ 小的值。", "inputFormat": "第一行输入三个整数 $L,\\ N,\\ K$，用空格隔开。  \n第二行输入 $N$ 个整数 $A_1, A_2, \\dots, A_N$，表示每盏路灯的位置，以空格隔开。", "outputFormat": "输出 $K$ 行，第 $i$ 行输出从小到大排序后的第 $i$ 小黑暗程度值。", "hint": "**约束条件**\n\n- 所有输入为整数。\n- $1 \\leq L \\leq 10^{18}$\n- $1 \\leq N \\leq 3 \\times 10^5$\n- $1 \\leq K \\leq 5 \\times 10^5$\n- $K \\leq L + 1$\n- $0 \\leq A_1 < A_2 < \\cdots < A_N \\leq L$\n\n**子问题**\n\n1. （10 分）$N = 1$  \n2. （20 分）$N \\leq 2\\,500,\\ L \\leq 2\\,500$  \n3. （15 分）$2 \\leq N$ 且 $N - 1$ 整除 $L$，且 $A_i = \\dfrac{L}{N-1} \\times (i - 1)$  \n4. （20 分）$L \\leq 5 \\times 10^6$  \n5. （35 分）无额外限制条件\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P12649", "type": "P", "difficulty": 5, "samples": [["5\n4 1\n3 5\n2 4\n3 2\n5 1", "6"], ["2\n1 1\n2 2", "0"], ["4\n2 1\n3 1\n2 4\n3 4", "-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["图论", "2024", "图论建模", "KOI（韩国）"], "title": "[KOI 2024 Round 2] 收集彩球", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "现在有 $2N$ 个彩球和 $N + 1$ 个盒子。彩球的颜色为 $1, 2, \\dots, N$ 中的某一个。对于每种颜色，恰好有两个彩球被涂成该颜色。每个盒子最多可以容纳两个彩球。\n\n最开始，第 $1$ 到第 $N$ 个盒子中每个盒子内都放有两个彩球，第 $N + 1$ 个盒子是空的。第 $i$ 个盒子中，最上面那个彩球的颜色为 $A_i$，下面那个彩球的颜色为 $B_i$。\n\n你可以将一个盒子顶部的彩球取出，放入另一个盒子的顶部，完成一次移动操作。\n\n你的目标是使得每种颜色的两个彩球都被放入同一个盒子中。每次移动操作必须满足下列两个条件之一：\n\n- 被放入彩球的目标盒子是空的；\n- 被放入彩球的目标盒子中恰好已有一个彩球，并且该彩球与被放入的彩球颜色相同。\n\n请你编写程序，计算为了实现目标——使每种颜色的两个彩球在同一个盒子中，所需的最小移动次数。如果无法实现目标，请输出 $-1$。", "inputFormat": "第一行输入一个整数 $N$。  \n接下来的 $N$ 行中，第 $i$ 行输入两个整数 $A_i$ 和 $B_i$，以空格分隔，表示第 $i$ 个盒子中从上到下的两个彩球的颜色。", "outputFormat": "如果存在解决方案，输出最小的移动次数；如果不存在解决方案，输出 $-1$。\n", "hint": "**样例 1 说明**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jm5qt4kg.png)\n\n可以按照如下步骤完成：\n1. 将第 4 号盒子中的颜色为 $3$ 的球移动到第 6 号盒子；\n2. 将第 3 号盒子中的颜色为 $2$ 的球移动到第 4 号盒子；\n3. 将第 1 号盒子中的颜色为 $4$ 的球移动到第 3 号盒子；\n4. 将第 2 号盒子中的颜色为 $3$ 的球移动到第 6 号盒子；\n5. 将第 5 号盒子中的颜色为 $5$ 的球移动到第 2 号盒子；\n6. 将第 5 号盒子中的颜色为 $1$ 的球移动到第 1 号盒子。\n\n**约束条件**\n\n- 所有输入均为整数。\n- $1 \\leq N \\leq 200\\,000$\n- $1 \\leq A_i, B_i \\leq N$\n- 对于每个 $1 \\leq i \\leq N$，$A_1, A_2, \\dots, A_N, B_1, B_2, \\dots, B_N$ 中恰好有两个数等于 $i$。\n\n**子问题**\n\n1. （2 分）$N \\leq 2$  \n2. （23 分）$N \\leq 20$  \n3. （15 分）存在使所有同色彩球放入同一盒子的方法  \n4. （15 分）$N \\leq 2\\,000$  \n5. （45 分）无附加限制条件\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2024 Round 2] 收集彩球", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "现在有 $2N$ 个彩球和 $N + 1$ 个盒子。彩球的颜色为 $1, 2, \\dots, N$ 中的某一个。对于每种颜色，恰好有两个彩球被涂成该颜色。每个盒子最多可以容纳两个彩球。\n\n最开始，第 $1$ 到第 $N$ 个盒子中每个盒子内都放有两个彩球，第 $N + 1$ 个盒子是空的。第 $i$ 个盒子中，最上面那个彩球的颜色为 $A_i$，下面那个彩球的颜色为 $B_i$。\n\n你可以将一个盒子顶部的彩球取出，放入另一个盒子的顶部，完成一次移动操作。\n\n你的目标是使得每种颜色的两个彩球都被放入同一个盒子中。每次移动操作必须满足下列两个条件之一：\n\n- 被放入彩球的目标盒子是空的；\n- 被放入彩球的目标盒子中恰好已有一个彩球，并且该彩球与被放入的彩球颜色相同。\n\n请你编写程序，计算为了实现目标——使每种颜色的两个彩球在同一个盒子中，所需的最小移动次数。如果无法实现目标，请输出 $-1$。", "inputFormat": "第一行输入一个整数 $N$。  \n接下来的 $N$ 行中，第 $i$ 行输入两个整数 $A_i$ 和 $B_i$，以空格分隔，表示第 $i$ 个盒子中从上到下的两个彩球的颜色。", "outputFormat": "如果存在解决方案，输出最小的移动次数；如果不存在解决方案，输出 $-1$。\n", "hint": "**样例 1 说明**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jm5qt4kg.png)\n\n可以按照如下步骤完成：\n1. 将第 4 号盒子中的颜色为 $3$ 的球移动到第 6 号盒子；\n2. 将第 3 号盒子中的颜色为 $2$ 的球移动到第 4 号盒子；\n3. 将第 1 号盒子中的颜色为 $4$ 的球移动到第 3 号盒子；\n4. 将第 2 号盒子中的颜色为 $3$ 的球移动到第 6 号盒子；\n5. 将第 5 号盒子中的颜色为 $5$ 的球移动到第 2 号盒子；\n6. 将第 5 号盒子中的颜色为 $1$ 的球移动到第 1 号盒子。\n\n**约束条件**\n\n- 所有输入均为整数。\n- $1 \\leq N \\leq 200\\,000$\n- $1 \\leq A_i, B_i \\leq N$\n- 对于每个 $1 \\leq i \\leq N$，$A_1, A_2, \\dots, A_N, B_1, B_2, \\dots, B_N$ 中恰好有两个数等于 $i$。\n\n**子问题**\n\n1. （2 分）$N \\leq 2$  \n2. （23 分）$N \\leq 20$  \n3. （15 分）存在使所有同色彩球放入同一盒子的方法  \n4. （15 分）$N \\leq 2\\,000$  \n5. （45 分）无附加限制条件\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
{"pid": "P12650", "type": "P", "difficulty": 5, "samples": [["5 11\n10001000000\n01000100000\n00100110001\n00010101010\n00001000100", "13"], ["3 3\n111\n111\n111", "6"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "贪心", "2024", "前缀和", "KOI（韩国）"], "title": "[KOI 2024 Round 2] 双 v 字形涂色", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "给定一个 $N$ 行 $M$ 列的网格图，每个格子被涂成白色或黑色。\n\n定义以下操作为一次“V 字形涂色”：\n\n1. 选择一个白色格子作为起点；\n2. 从该格子开始，沿左上对角线（即每次向左上方移动一格）前进，直到遇到非白色格子或越出网格为止，将经过的所有格子涂为蓝色；\n3. 从起点的右上方一格开始，沿右上对角线（即每次向右上方移动一格）前进，直到遇到非白色格子或越出网格为止，将经过的所有格子涂为蓝色。\n\n现在你可以执行两次 V 字形涂色操作。请计算，两次操作之后，最多能将多少个格子涂成蓝色。\n\n例如，在如下的 $5$ 行 $11$ 列网格中，\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y2jblpiq.png)\n\n第一次在 $(5,5)$ 位置执行 V 字形涂色后，部分格子被涂为蓝色；  \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ajestsdo.png)\n\n第二次在 $(5,9)$ 执行 V 字形涂色后，共有 $11$ 个格子变成蓝色。  \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1xw6d2af.png)\n\n而若先在 $(5,9)$ 执行，再在 $(5,5)$ 执行，共有 $13$ 个格子变为蓝色，这比前一种情况更多。  \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/w29u05r9.png)\n\n因此，这种情况下的答案是 $13$。", "inputFormat": "第一行输入两个整数 $N$ 和 $M$，用空格隔开。  \n接下来的 $N$ 行，每行包含一个长度为 $M$ 的仅由 $0$ 和 $1$ 组成的字符串，表示网格信息。  \n第 $i$ 行第 $j$ 个字符为 $1$ 表示该格子为白色，为 $0$ 表示为黑色。", "outputFormat": "输出一个整数，表示两次 V 字形涂色后最多能变成蓝色的格子数量。", "hint": "**约束条件**\n\n- $1 \\leq N, M \\leq 3000$\n- 网格中至少存在 $2$ 个白色格子\n\n**子问题**\n\n1. （11 分）$N, M \\leq 20$\n2. （20 分）$N, M \\leq 100$\n3. （24 分）$N, M \\leq 500$\n4. （45 分）无附加限制条件\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KOI 2024 Round 2] 双 v 字形涂色", "background": "试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。\n\n按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。", "description": "给定一个 $N$ 行 $M$ 列的网格图，每个格子被涂成白色或黑色。\n\n定义以下操作为一次“V 字形涂色”：\n\n1. 选择一个白色格子作为起点；\n2. 从该格子开始，沿左上对角线（即每次向左上方移动一格）前进，直到遇到非白色格子或越出网格为止，将经过的所有格子涂为蓝色；\n3. 从起点的右上方一格开始，沿右上对角线（即每次向右上方移动一格）前进，直到遇到非白色格子或越出网格为止，将经过的所有格子涂为蓝色。\n\n现在你可以执行两次 V 字形涂色操作。请计算，两次操作之后，最多能将多少个格子涂成蓝色。\n\n例如，在如下的 $5$ 行 $11$ 列网格中，\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y2jblpiq.png)\n\n第一次在 $(5,5)$ 位置执行 V 字形涂色后，部分格子被涂为蓝色；  \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ajestsdo.png)\n\n第二次在 $(5,9)$ 执行 V 字形涂色后，共有 $11$ 个格子变成蓝色。  \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1xw6d2af.png)\n\n而若先在 $(5,9)$ 执行，再在 $(5,5)$ 执行，共有 $13$ 个格子变为蓝色，这比前一种情况更多。  \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/w29u05r9.png)\n\n因此，这种情况下的答案是 $13$。", "inputFormat": "第一行输入两个整数 $N$ 和 $M$，用空格隔开。  \n接下来的 $N$ 行，每行包含一个长度为 $M$ 的仅由 $0$ 和 $1$ 组成的字符串，表示网格信息。  \n第 $i$ 行第 $j$ 个字符为 $1$ 表示该格子为白色，为 $0$ 表示为黑色。", "outputFormat": "输出一个整数，表示两次 V 字形涂色后最多能变成蓝色的格子数量。", "hint": "**约束条件**\n\n- $1 \\leq N, M \\leq 3000$\n- 网格中至少存在 $2$ 个白色格子\n\n**子问题**\n\n1. （11 分）$N, M \\leq 20$\n2. （20 分）$N, M \\leq 100$\n3. （24 分）$N, M \\leq 500$\n4. （45 分）无附加限制条件\n\n翻译由 ChatGPT-4o 完成", "locale": "zh-CN"}}}
