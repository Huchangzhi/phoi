{"pid": "P9073", "type": "P", "difficulty": 7, "samples": [["18\n+ 5 1\n+ 2 1\n? 3\n+ 3 2\n? 4\n? 4\n+ 4 1\n? 3\nR 3\n- 2 2\n? 3\n- 1 1\n? 2\n? 4\n- 1 2\n? 1\n- 9 9\n? 1", "3 1\n1 3\n2 2\n2 4\n2 1\n1 2\n1 1\n1 1\n1 1"], ["见附件中的 stairs2.in", "见附件中的 stairs2.ans"], ["见附件中的 stairs3.in", "见附件中的 stairs3.ans"], ["见附件中的 stairs4.in", "见附件中的 stairs4.ans"], ["见附件中的 stairs5.in", "见附件中的 stairs5.ans"], ["见附件中的 stairs6.in", "见附件中的 stairs6.ans"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "Special Judge", "O2优化", "杨表", "WC", "CTSC/CTS"], "title": "[WC/CTS2023] 楼梯", "background": "长颈鹿累了，他开始做梦。\n\n在梦中他下坠。他穿过草地，穿过打着转的羊群。他穿过星海，穿过漫天的火羽。\n\n终于，他站在了一块屏幕前。屏幕上展示着某种类似楼梯的图样。", "description": "我们首先给出一些关于楼梯的形式定义。\n\n我们称一对正整数组成的二元组 $(x,y)$ 为**格子**，称格子构成的集合 $L$（可以为空）为**楼梯**当且仅当其满足下面两个条件：\n\n+ 若 $(x,y)\\in L$ 且 $x>1$，则 $(x-1,y)\\in L$。\n+ 若 $(x,y)\\in L$ 且 $y>1$，则 $(x,y-1)\\in L$。\n\n对于一个楼梯 $L$ 和 $(x,y)\\in L$，我们定义 $(x,y)$ 为**生成格**生成的**子楼梯**为\n\n$$\n\\{(a-x+1, b-y+1) \\mid (a,b) \\in L, a \\ge x, b \\ge y\\}\n$$\n\n容易证明这一集合仍然是一个楼梯。对于一个楼梯 $L$，我们定义**边界格数**为满足 $x=1$ 或 $y=1$ 的 $(x,y) \\in L$ 的数量。\n\n为了方便理解，我们接下来给出直观解释。我们在平面上可以将所有格子按从左到右 $y$ 坐标递增、从上到下 $x$ 坐标递增的顺序排列成网格，因此我们也称 $(x,y)$ 为第 $x$ 行第 $y$ 列的格子。\n\n在这一解释下，若一个格子属于某个楼梯，且它上方和左方不是边界，则对应格子也属于这个楼梯。子楼梯就是生成格右下方区域格子所构成的非空楼梯，一个楼梯的边界格数是上边界或左边界上的总格数。\n\n如下图，$(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(4,1),(5,1)$ 组成了一个合法的楼梯。这一楼梯的边界格数为 $8$，其中以 $(1,3)$ 作为生成格生成的子楼梯的边界格数为 $4$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/88e0br57.png)\n\n长颈鹿看到屏幕上的楼梯后很好奇。他首先计算出了这一楼梯的边界格数 $p$，并给定了 $p$ 的某一**正整数因子** $q$。他想要知道，给定的楼梯是否有子楼梯满足边界格数等于 $q$。如果是，他希望你给出**任一**这样的子楼梯的生成格。\n\n梦境时常变化，因此长颈鹿可能会有许多次这样的询问，楼梯也可能会发生变化。初始楼梯 $L$ 为空，对于 $i \\ge 1$ 记 $s_i$ 为最大的满足 $(i,s_i) \\in L$ 的正整数，若不存在则令其为 $0$，则有若干次三种之一的修改：\n\n- 给定正整数 $a$ 和 $b$，在前 $a$ 行的末尾插入 $b$ 格。形式化地，对于 $i=1, 2, \\dots, a$，将 $(i,s_i+1), (i,s_i+2),\\dots,(i,s_i+b)$ 加入 $L$。\n- 给定正整数 $a$ 和 $b$，在第 $a$ 行后（包含第 $a$ 行）的所有行行末尾删去 $b$ 格，若不足则删空。形式化地，对于 $i=a,a+1,a+2,\\dots,10^{100}$，将 $(i,s_i),(i,s_i−1),\\dots,(i,s_i−b+1)$ 从 $L$ 中移除（不存在的则忽略）。\n- 给定正整数 $u$，撤销之前的 $u$ 次操作，即将楼梯还原为 $u$ 次操作前的状态，**保证这 $u$ 次操作均为询问或在行末尾插入**。具体地，假设该操作为第 $t$ 次操作，我们一定有 $t>u$，且第 $t−1,t−2,\\dots,t−u$ 次操作均为询问或在行末尾插入（即上述的第一种修改）。你只需要将楼梯还原为第 $t−u$ 次操作前的状态即可（当然，你应该保留询问的输出）。\n\n可以证明每次修改之后得到的集合仍然是一个楼梯。", "inputFormat": "输入数据第一行包含一个正整数 $m$，表示操作总数。\n\n接下来 $m$ 行每行描述四种之一的操作，详细含义可参见题目描述一节。描述为由空格分隔的一个字符和一到两个正整数，具体地：\n\n- `+ a b`：在前 $a$ 行的末尾插入 $b$ 格。\n- `- a b`：在第 $a$ 行后（包括第 $a$ 行）的所有行行末尾删去 $b$ 格，若不足则删空。\n- `R u`：撤销之前的 $u$ 次操作，即将楼梯还原为 $u$ 次操作前的状态。**保证这 $u$ 次操作存在且均为询问或在行末尾插入**，即该行之前的 $u$ 行均以 `+` 或 `?` 开头。\n- `? q`：询问是否有边界格数等于 $q$ 的子楼梯，若有则给出任意合法生成格。**保证 $q$ 是当前楼梯边界格数的因子**。", "outputFormat": "对于每个询问（`?` 操作）输出一行。\n\n如果存在边界格数等于 $q$ 的子楼梯，输出一行两个用空格分隔的正整数 `x y`，表示一个合法生成格是 $(x,y)$。否则输出一行两个用空格分隔的 $-1$。", "hint": "**【样例解释 #1】**\n\n每次修改操作之后的楼梯如下图（排列方式同题目描述，省略了各格子的编号）。注意撤销操作实际只撤销了一个 `+` 操作。样例有多个合法解，给出的输出只是一种合法的输出。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/milfbsr1.png)\n\n**【数据范围】**\n\n对于所有测试数据，$1 \\le m \\le 3 \\times 10^5$。\n\n+ 对于 `+` 和 `-` 操作，$1 \\le a, b \\le 10^9$。\n+ 对于 `R` 操作，保证之前紧邻的 $u$ 次操作存在且均为询问或在行末尾插入。\n+ 对于 `?` 操作，$1 \\le q \\le 10^{18}$ 且**保证为当前楼梯边界格数的因子**。\n\n记 $a_{\\max}$ 为所有 `+` 和 `-` 操作中 $a$ 的最大值，$b_{\\max}$ 为所有 `+` 和 `-` 操作中 $b$ 的最大值。\n\n| 测试点 | $m =$ | $a_{\\max} \\leq$ | $b_{\\max} \\leq$ | 特殊性质 |\n| :-: | :-: | :-: | :-: | :-: |\n| $1$ | $200$ | $50$ | $20$ | 无 |\n| $2$ | $400$ | $100$ | $100$ | AB |\n| $3$ | $600$ | $500$ | $500$ | A |\n| $4$ | $800$ | $500$ | $10^6$ | 无 |\n| $5$ | $10^3$ | $10^3$ | $10^6$ | 无 |\n| $6$ | $3000$ | $10^6$ | $10^6$ | B |\n| $7$ | $5000$ | $10^6$ | $10^6$ | AB |\n| $8$ | $10^4$ | $10^9$ | $10^9$ | 无 |\n| $9$ | $3 \\times 10^4$ | $10^9$ | $10^9$ | A |\n| $10$ | $5 \\times 10^4$ | $10^9$ | $10^9$ | 无 |\n| $11$ | $7 \\times 10^4$ | $10^9$ | $10^9$ | 无 |\n| $12$ | $10^5$ | $10^9$ | $10^9$ | B |\n| $13$ | $1.2 \\times 10^5$ | $10^9$ | $10^9$ | 无 |\n| $14$ | $1.4 \\times 10^5$ | $10^6$ | $10^6$ | 无 |\n| $15$ | $1.6 \\times 10^5$ | $10^6$ | $10^6$ | AB |\n| $16$ | $1.8 \\times 10^5$ | $10^9$ | $10^9$ | 无 |\n| $17$ | $2 \\times 10^5$ | $10^6$ | $10^6$ | B |\n| $18$ | $2.5 \\times 10^5$ | $10^6$ | $10^6$ | B |\n| $19$ | $2.7 \\times 10^5$ | $10^9$ | $10^9$ | 无 |\n| $20$ | $3 \\times 10^5$ | $10^9$ | $10^9$ | 无 |\n\n其中附加限制中的特殊性质如下所示：\n\n- 特殊性质 A：`?` 操作在所有 `+` 和 `-` 操作之后。没有 `R` 操作。\n- 特殊性质 B：没有 `-` 操作。\n\n**【提示】**\n\n请注意选用合适的数据类型存储各结果。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[WC/CTS2023] 楼梯", "background": "长颈鹿累了，他开始做梦。\n\n在梦中他下坠。他穿过草地，穿过打着转的羊群。他穿过星海，穿过漫天的火羽。\n\n终于，他站在了一块屏幕前。屏幕上展示着某种类似楼梯的图样。", "description": "我们首先给出一些关于楼梯的形式定义。\n\n我们称一对正整数组成的二元组 $(x,y)$ 为**格子**，称格子构成的集合 $L$（可以为空）为**楼梯**当且仅当其满足下面两个条件：\n\n+ 若 $(x,y)\\in L$ 且 $x>1$，则 $(x-1,y)\\in L$。\n+ 若 $(x,y)\\in L$ 且 $y>1$，则 $(x,y-1)\\in L$。\n\n对于一个楼梯 $L$ 和 $(x,y)\\in L$，我们定义 $(x,y)$ 为**生成格**生成的**子楼梯**为\n\n$$\n\\{(a-x+1, b-y+1) \\mid (a,b) \\in L, a \\ge x, b \\ge y\\}\n$$\n\n容易证明这一集合仍然是一个楼梯。对于一个楼梯 $L$，我们定义**边界格数**为满足 $x=1$ 或 $y=1$ 的 $(x,y) \\in L$ 的数量。\n\n为了方便理解，我们接下来给出直观解释。我们在平面上可以将所有格子按从左到右 $y$ 坐标递增、从上到下 $x$ 坐标递增的顺序排列成网格，因此我们也称 $(x,y)$ 为第 $x$ 行第 $y$ 列的格子。\n\n在这一解释下，若一个格子属于某个楼梯，且它上方和左方不是边界，则对应格子也属于这个楼梯。子楼梯就是生成格右下方区域格子所构成的非空楼梯，一个楼梯的边界格数是上边界或左边界上的总格数。\n\n如下图，$(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(4,1),(5,1)$ 组成了一个合法的楼梯。这一楼梯的边界格数为 $8$，其中以 $(1,3)$ 作为生成格生成的子楼梯的边界格数为 $4$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/88e0br57.png)\n\n长颈鹿看到屏幕上的楼梯后很好奇。他首先计算出了这一楼梯的边界格数 $p$，并给定了 $p$ 的某一**正整数因子** $q$。他想要知道，给定的楼梯是否有子楼梯满足边界格数等于 $q$。如果是，他希望你给出**任一**这样的子楼梯的生成格。\n\n梦境时常变化，因此长颈鹿可能会有许多次这样的询问，楼梯也可能会发生变化。初始楼梯 $L$ 为空，对于 $i \\ge 1$ 记 $s_i$ 为最大的满足 $(i,s_i) \\in L$ 的正整数，若不存在则令其为 $0$，则有若干次三种之一的修改：\n\n- 给定正整数 $a$ 和 $b$，在前 $a$ 行的末尾插入 $b$ 格。形式化地，对于 $i=1, 2, \\dots, a$，将 $(i,s_i+1), (i,s_i+2),\\dots,(i,s_i+b)$ 加入 $L$。\n- 给定正整数 $a$ 和 $b$，在第 $a$ 行后（包含第 $a$ 行）的所有行行末尾删去 $b$ 格，若不足则删空。形式化地，对于 $i=a,a+1,a+2,\\dots,10^{100}$，将 $(i,s_i),(i,s_i−1),\\dots,(i,s_i−b+1)$ 从 $L$ 中移除（不存在的则忽略）。\n- 给定正整数 $u$，撤销之前的 $u$ 次操作，即将楼梯还原为 $u$ 次操作前的状态，**保证这 $u$ 次操作均为询问或在行末尾插入**。具体地，假设该操作为第 $t$ 次操作，我们一定有 $t>u$，且第 $t−1,t−2,\\dots,t−u$ 次操作均为询问或在行末尾插入（即上述的第一种修改）。你只需要将楼梯还原为第 $t−u$ 次操作前的状态即可（当然，你应该保留询问的输出）。\n\n可以证明每次修改之后得到的集合仍然是一个楼梯。", "inputFormat": "输入数据第一行包含一个正整数 $m$，表示操作总数。\n\n接下来 $m$ 行每行描述四种之一的操作，详细含义可参见题目描述一节。描述为由空格分隔的一个字符和一到两个正整数，具体地：\n\n- `+ a b`：在前 $a$ 行的末尾插入 $b$ 格。\n- `- a b`：在第 $a$ 行后（包括第 $a$ 行）的所有行行末尾删去 $b$ 格，若不足则删空。\n- `R u`：撤销之前的 $u$ 次操作，即将楼梯还原为 $u$ 次操作前的状态。**保证这 $u$ 次操作存在且均为询问或在行末尾插入**，即该行之前的 $u$ 行均以 `+` 或 `?` 开头。\n- `? q`：询问是否有边界格数等于 $q$ 的子楼梯，若有则给出任意合法生成格。**保证 $q$ 是当前楼梯边界格数的因子**。", "outputFormat": "对于每个询问（`?` 操作）输出一行。\n\n如果存在边界格数等于 $q$ 的子楼梯，输出一行两个用空格分隔的正整数 `x y`，表示一个合法生成格是 $(x,y)$。否则输出一行两个用空格分隔的 $-1$。", "hint": "**【样例解释 #1】**\n\n每次修改操作之后的楼梯如下图（排列方式同题目描述，省略了各格子的编号）。注意撤销操作实际只撤销了一个 `+` 操作。样例有多个合法解，给出的输出只是一种合法的输出。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/milfbsr1.png)\n\n**【数据范围】**\n\n对于所有测试数据，$1 \\le m \\le 3 \\times 10^5$。\n\n+ 对于 `+` 和 `-` 操作，$1 \\le a, b \\le 10^9$。\n+ 对于 `R` 操作，保证之前紧邻的 $u$ 次操作存在且均为询问或在行末尾插入。\n+ 对于 `?` 操作，$1 \\le q \\le 10^{18}$ 且**保证为当前楼梯边界格数的因子**。\n\n记 $a_{\\max}$ 为所有 `+` 和 `-` 操作中 $a$ 的最大值，$b_{\\max}$ 为所有 `+` 和 `-` 操作中 $b$ 的最大值。\n\n| 测试点 | $m =$ | $a_{\\max} \\leq$ | $b_{\\max} \\leq$ | 特殊性质 |\n| :-: | :-: | :-: | :-: | :-: |\n| $1$ | $200$ | $50$ | $20$ | 无 |\n| $2$ | $400$ | $100$ | $100$ | AB |\n| $3$ | $600$ | $500$ | $500$ | A |\n| $4$ | $800$ | $500$ | $10^6$ | 无 |\n| $5$ | $10^3$ | $10^3$ | $10^6$ | 无 |\n| $6$ | $3000$ | $10^6$ | $10^6$ | B |\n| $7$ | $5000$ | $10^6$ | $10^6$ | AB |\n| $8$ | $10^4$ | $10^9$ | $10^9$ | 无 |\n| $9$ | $3 \\times 10^4$ | $10^9$ | $10^9$ | A |\n| $10$ | $5 \\times 10^4$ | $10^9$ | $10^9$ | 无 |\n| $11$ | $7 \\times 10^4$ | $10^9$ | $10^9$ | 无 |\n| $12$ | $10^5$ | $10^9$ | $10^9$ | B |\n| $13$ | $1.2 \\times 10^5$ | $10^9$ | $10^9$ | 无 |\n| $14$ | $1.4 \\times 10^5$ | $10^6$ | $10^6$ | 无 |\n| $15$ | $1.6 \\times 10^5$ | $10^6$ | $10^6$ | AB |\n| $16$ | $1.8 \\times 10^5$ | $10^9$ | $10^9$ | 无 |\n| $17$ | $2 \\times 10^5$ | $10^6$ | $10^6$ | B |\n| $18$ | $2.5 \\times 10^5$ | $10^6$ | $10^6$ | B |\n| $19$ | $2.7 \\times 10^5$ | $10^9$ | $10^9$ | 无 |\n| $20$ | $3 \\times 10^5$ | $10^9$ | $10^9$ | 无 |\n\n其中附加限制中的特殊性质如下所示：\n\n- 特殊性质 A：`?` 操作在所有 `+` 和 `-` 操作之后。没有 `R` 操作。\n- 特殊性质 B：没有 `-` 操作。\n\n**【提示】**\n\n请注意选用合适的数据类型存储各结果。", "locale": "zh-CN"}}}
{"pid": "P9074", "type": "P", "difficulty": 7, "samples": [["4\n5 2\n3 1 2 3\n3 3 4 5\n7 7\n3 1 2 4\n3 2 3 5\n3 3 4 6\n3 4 5 7\n3 5 6 1\n3 6 7 2\n3 7 1 3\n8 2\n4 1 2 3 4\n4 5 6 7 8\n10 1\n10 1 2 3 4 5 6 7 8 9 10", "1 3 4 2 5\n1 2 3 4 5 6 7\n1 5 2 6 3 7 4 8\n-1"], ["见附件中的 contest2.in", "见附件中的 contest2.ans"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "Special Judge", "O2优化", "WC", "CTSC/CTS"], "title": "[WC/CTS2023] 比赛", "background": "", "description": "有 $n$ 名学生，标号从 $1$ 到 $n$，他们一共加入了 $m$ 个社团。由于一些奇怪的原因，**任意两个社团至多只包含一名公共成员**。\n\n现在学校要组织一场比赛，想让这 $n$ 名学生围成一个圈。为了防止作弊，校长希望**圈上任意连续三个人不来自同一个社团**。\n\n校长找到了你，希望你给他一组圆排列学生的方案，或指出这样的方案并不存在。", "inputFormat": "第一行包含一个正整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行包含两个非负整数 $n, m$，分别表示学生的数量和社团的数量。\n\n接下来 $m$ 行，其中的第 $i$ 行的第一个整数为 $k_i$，表示第 $i$ 个社团的人数，紧随着 $k_i$ 个不重复的整数 $a_{i,1}, a_{i,2}, \\dots, a_{i, k_i}$，表示第 $i$ 个社团的成员的标号。", "outputFormat": "对于每组数据，输出一行：\n\n如果存在满足条件的圆排列，则该行包含 $n$ 个整数，表示一个满足条件的圆排列。**如果有多个满足条件的圆排列，输出任意一组均可**。\n\n如果不存在满足条件的圆排列，则该行仅包含一个整数 $-1$。", "hint": "**【样例解释 #1】**\n\n在正式评测时，**任意一组满足条件的圆排列**都被视为正确，无论排列以谁开始，以哪个方向。\n\n**【样例解释 #2】**\n\n这个样例中前 $110$ 组数据满足 $n \\le 15$，后 $35$ 组数据满足 $n \\le 45$。\n\n**【数据范围】**\n\n对于所有的测试点，保证 $T \\ge 1$，$n \\ge 3$，$\\sum n \\le 2000$，$m \\ge 0$，$3 \\le k_i \\le n$，$1 \\le a_{i,j} \\le n$，$a_{i,1}, a_{i,2}, \\dots, a_{i,k_i}$ 互不相同，且满足题中所述性质（任意两个社团至多包含一名公共成员）。\n\n每个测试点的具体限制见下表：\n\n| 测试点编号 | $n$ | $m$ | 特殊性质 |\n| :-: | :-: | :-: | :-: |\n| $1 \\sim 2$ | $\\leq 9$ | 无 | 无 |\n| $3 \\sim 4$ | $\\leq 15$ | 无 | 无 |\n| $5 \\sim 6$ | $\\leq 45$ | 无 | 无 |\n| $7 \\sim 8$ | $\\leq 400$ | $= 1$ | 无 |\n| $9 \\sim 12$ | $\\leq 400$ | 无 | 保证 $a_{i,j+1} = a_{i,j} + 1$ |\n| $13 \\sim 16$ | $\\leq 400$ | 无 | 无 |\n| $17 \\sim 18$ | $\\leq 2000$ | $= 1$ | 无 |\n| $19 \\sim 21$ | $\\leq 2000$ | 无 | 保证 $a_{i,j+1} = a_{i,j} + 1$ |\n| $22 \\sim 25$ | $\\leq 2000$ | 无 | 无 |\n\n可以使用下发文件（题目附件）中的 `chk.cpp` 以检验你的输出的合法性，使用时先将其编译为可执行文件 `chk`。\n\n+ Linux 系统使用 `./chk <input‐file> <output‐file> <answer‐file>` 测试\n+ Windows 系统使用 `chk <input‐file> <output‐file> <answer‐file>` 测试。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[WC/CTS2023] 比赛", "background": "", "description": "有 $n$ 名学生，标号从 $1$ 到 $n$，他们一共加入了 $m$ 个社团。由于一些奇怪的原因，**任意两个社团至多只包含一名公共成员**。\n\n现在学校要组织一场比赛，想让这 $n$ 名学生围成一个圈。为了防止作弊，校长希望**圈上任意连续三个人不来自同一个社团**。\n\n校长找到了你，希望你给他一组圆排列学生的方案，或指出这样的方案并不存在。", "inputFormat": "第一行包含一个正整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行包含两个非负整数 $n, m$，分别表示学生的数量和社团的数量。\n\n接下来 $m$ 行，其中的第 $i$ 行的第一个整数为 $k_i$，表示第 $i$ 个社团的人数，紧随着 $k_i$ 个不重复的整数 $a_{i,1}, a_{i,2}, \\dots, a_{i, k_i}$，表示第 $i$ 个社团的成员的标号。", "outputFormat": "对于每组数据，输出一行：\n\n如果存在满足条件的圆排列，则该行包含 $n$ 个整数，表示一个满足条件的圆排列。**如果有多个满足条件的圆排列，输出任意一组均可**。\n\n如果不存在满足条件的圆排列，则该行仅包含一个整数 $-1$。", "hint": "**【样例解释 #1】**\n\n在正式评测时，**任意一组满足条件的圆排列**都被视为正确，无论排列以谁开始，以哪个方向。\n\n**【样例解释 #2】**\n\n这个样例中前 $110$ 组数据满足 $n \\le 15$，后 $35$ 组数据满足 $n \\le 45$。\n\n**【数据范围】**\n\n对于所有的测试点，保证 $T \\ge 1$，$n \\ge 3$，$\\sum n \\le 2000$，$m \\ge 0$，$3 \\le k_i \\le n$，$1 \\le a_{i,j} \\le n$，$a_{i,1}, a_{i,2}, \\dots, a_{i,k_i}$ 互不相同，且满足题中所述性质（任意两个社团至多包含一名公共成员）。\n\n每个测试点的具体限制见下表：\n\n| 测试点编号 | $n$ | $m$ | 特殊性质 |\n| :-: | :-: | :-: | :-: |\n| $1 \\sim 2$ | $\\leq 9$ | 无 | 无 |\n| $3 \\sim 4$ | $\\leq 15$ | 无 | 无 |\n| $5 \\sim 6$ | $\\leq 45$ | 无 | 无 |\n| $7 \\sim 8$ | $\\leq 400$ | $= 1$ | 无 |\n| $9 \\sim 12$ | $\\leq 400$ | 无 | 保证 $a_{i,j+1} = a_{i,j} + 1$ |\n| $13 \\sim 16$ | $\\leq 400$ | 无 | 无 |\n| $17 \\sim 18$ | $\\leq 2000$ | $= 1$ | 无 |\n| $19 \\sim 21$ | $\\leq 2000$ | 无 | 保证 $a_{i,j+1} = a_{i,j} + 1$ |\n| $22 \\sim 25$ | $\\leq 2000$ | 无 | 无 |\n\n可以使用下发文件（题目附件）中的 `chk.cpp` 以检验你的输出的合法性，使用时先将其编译为可执行文件 `chk`。\n\n+ Linux 系统使用 `./chk <input‐file> <output‐file> <answer‐file>` 测试\n+ Windows 系统使用 `chk <input‐file> <output‐file> <answer‐file>` 测试。", "locale": "zh-CN"}}}
{"pid": "P9075", "type": "P", "difficulty": 7, "samples": [["3 100 100\n1 2\n2 1", "Right output! cnt1 = 2, cnt2 = 5."], ["见附件中的 ds2.in", "见附件中的 ds2.ans"], ["见附件中的 ds3.in", "见附件中的 ds3.ans"], ["见附件中的 ds4.in", "见附件中的 ds4.ans"], ["见附件中的 ds5.in", "见附件中的 ds5.ans"], ["见附件中的 ds6.in", "见附件中的 ds6.ans"], ["见附件中的 ds7.in", "见附件中的 ds7.ans"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "交互题", "O2优化", "WC", "CTSC/CTS"], "title": "[WC/CTS2023] 树据结构", "background": "**这是一道交互题。**\n\n**在提交本题前请务必仔细阅读以下内容。**\n\n本题只支持 C++ 语言提交（建议使用 C++14，请不要使用 C++14 (GCC9)）。\n\n由于洛谷特殊的交互机制，在提交本题时，请去掉代码中的 ```#include \"ds.h\"``` 语句，并将以下内容粘贴到代码最开头，然后提交：\n\n```cpp\n#include <vector>\nvoid exchange(int x, int y);\nint query(int u);\nvoid answer(std::vector<int> par, std::vector<int> val);\n```\n\n如果您在提交本题时出现了任何意外的情况，请咨询管理员。", "description": "作为一个熟练的 OI 选手，你对数据结构的各种题型早已轻车熟路，比赛中只要碰到数据结构题就能三下五除二轻松搞定。这一天，你翻开 OJ，看到了这道题：\n\n给定 $n$ 个点的有根树，点编号为 $1, 2, \\dots, n$，$1$ 为根。每条边上有一个 $1$ 至 $n - 1$ 的**两两不同**的权值。维护一个数据结构，支持交换**权值为 $x$ 和 $y$** 的边的权值，以及询问从根节点到 $u$ 号点的所有的边的权值最大值。\n\n这种简单而经典的树上问题，对你已经是不在话下。厌倦了维护修改，回答询问的你，打算换一个角色。这回，你才是那个提问题的人，你需要构造合适的操作来套取题的数据。\n\n具体地说，现在你并不知道树的结构，也不知道初始时树上每条边的权值，你需要通过如下两种操作得到树的结构和 **初始时** 树上每条边的权值：\n\n1. 给出正整数 $x, y$，其中 $1 \\le x, y < n$，$x \\neq y$，交换 **权值为 $x, y$** 的两条边的权值。\n2. 给出正整数 $u$，其中 $2 \\le u \\le n$，并得到从 $1$ 号点到 $u$ 号点的路径上所有边中权值的最大值。\n\n**题目保证树的形态和每条边的权值是预先给定的，不会根据你的操作而动态生成。**\n\n**【实现细节】**\n\n你需要引用头文件 `#include \"ds.h\"`。你可以调用以下函数与交互库进行交互：\n\n```cpp\nvoid exchange(int x, int y);\n```\n\n+ 这个函数对应操作 $1$，表示交换**权值为 $x, y$** 的两条边的权值。\n+ 你需要保证 $1 \\le x, y < n$，$x \\neq y$。\n\n```cpp\nint query(int u);\n```\n\n+ 这个函数对应操作 $2$，返回从 $1$ 号点到 $u$ 号点的路径上所有边的权值的最大值。\n+ 你需要保证 $2 \\le u \\le n$。\n\n```cpp\nvoid answer(std::vector<int> par, std::vector<int> val);\n```\n\n- 这个函数用来回答你所得到的答案，格式如下：\n  - `par` 是一个长度为 $n - 1$ 的数组，其中 `par[i]` 表示树上 $i + 2$ 号节点的父亲编号，其中 $0 \\le i \\le n - 2$。\n  - `val` 也是一个长度为 $n - 1$ 的数组，其中 `val[i]` 表示树上 $i + 2$ 号节点到它父亲的边的**初始权值**，其中 $0 \\le i \\le n - 2$。\n- **你需要调用该函数恰好一次！**\n\n你不需要，也不应该实现主函数。在本题中，你只需要实现如下函数：\n\n```cpp\nvoid solve(int n, int lim1, int lim2);\n```\n\n- 其中，$n$ 表示树的点数，$lim1$ 表示操作 $1$ 的次数限制，$lim2$ 表示操作 $2$ 的次数限制。\n- 最终测试时，对于每个测试点，交互库会调用**恰好一次** `solve` 函数，并根据调用 `answer` 函数的正误来评分。\n\n在题目附件中，我们提供了 `sample.cpp` 供你参考，你可以在此基础上实现你的程序。\n\n**【测试程序方式】**\n\n题目附件中提供了 `grader.cpp` 文件。最终测试的交互库与下发交互库有不同，因此你的实现不应依赖交互库实现。\n\n你需要将你的程序 `ds.cpp` 和 `grader.cpp`、`ds.h` 放置在同一目录下，并在该目录下使用如下编译命令得到可执行程序 `ds(.exe)`：\n\n```bash\ng++ -o ds ds.cpp grader.cpp -O2 -std=c++14 -lm\n```\n\n**题目附件还提供了 `compile.sh`，其内容为该编译命令。你可以运行它进行编译，也可以复制该文件中的编译命令进行编译。**\n\n可执行程序从标准输入读入以下格式的数据：\n\n- 第一行包含三个正整数 $n, lim1, lim2$，表示树的点数，操作 $1$ 的限制次数和操作 $2$ 的限制次数。交互库保证可以处理 $2 \\le n \\le 500000$ 的情况，对于 $n > 500000$ 的情况不做正确运行保证。\n- 第二行 $n - 1$ 个正整数 $p_2, p_3, \\dots, p_n$。其中 $p_i$ 表示 $i$ 号点的父亲的节点编号。**你需要保证 $1 \\le p_i \\le n$ 且输入给出了合法的树的结构。**\n- 第三行 $n - 1$ 个正整数 $v_2, v_3, \\dots, v_n$。其中 $v_i$ 表示 $i$ 连向 $p_i$ 的边的权值。**你需要保证 $v_2, v_3, \\dots, v_n$ 构成 $1$ 至 $n - 1$ 的一个排列。**\n- **在本地测试时，请务必保证你的输入格式符合要求，否则我们不保证交互库会正常运行。**\n\n如果你的输入合法且没有运行错误，下发的交互库将会根据你的调用输出如下信息：\n\n- 如果某次 `exchange` 函数的调用违反了 $1 \\le x, y < n$，$x \\neq y$ 的限制，输出错误信息：`Invalid call of exchange(x, y)!`。\n- 如果 `exchange` 函数调用次数超过 $lim1$，输出错误信息：`Too many exchanges!`。\n- 如果某次 `query` 函数的调用违反了 $2 \\le u \\le n$ 的限制，输出错误信息：`Invalid call of query(u)!`。\n- 如果 `query` 函数调用次数超过 $lim2$，输出错误信息：`Too many queries!`。\n- 在输出任何以上错误信息后，交互库立即终止。\n- 交互库会在你**每次**调用 `answer` 函数时输出提示信息：\n  - 如果 `par` 或 `val` 的长度不是 $n - 1$，则输出 `Invalid output!`。\n  - 如果 `par` 数组与树的形态不同，那么它会给出**第一个**错误的位置，并返回如下格式的错误信息：`The answer to p[i] is wrong! The right answer is j, but you output k.`。注意，这里 $2 \\le i \\le n$，$j = p_i$ 为 $i$ 号点的真正的父亲编号，$k = $ `par[i - 2]` 为你给出的位置编号。\n  - 如果 `par` 数组正确，但 `val` 数组与**初始时**树上边权值不同，那么它会给出你**第一个**错误的位置，并返回如下格式的错误信息：`The answer to v[i] is wrong! The right answer is j, but you output k.`。类似地，这里 $2 \\le i \\le n$，$j = v_i$ 为 $i$ 号点到它父亲的边的真正的初始权值，$k =$ `val[i - 2]` 为你给出的权值。\n  - 如果你给出的 `par` 和 `val` 数组正确，那么交互库会输出你调用 `exchange` 函数和 `query` 函数的次数。输出格式为：`Right output! cnt1 = A, cnt2= B.`，其中 $A$ 表示你调用 `exchange` 函数的次数，$B$ 表示你调用 `query` 函数的次数。\n- **使用下发的交互库时你可以通过调用多次 `answer` 函数对你的程序进行测试。但对于你提交的代码，如果调用 `answer` 函数超过 $1$ 次，便只能获得 $0$ 分。**\n\n**你的程序不应该操作标准输入输出，否则视为攻击交互库。**\n", "inputFormat": "见【测试程序方式】。", "outputFormat": "见【测试程序方式】。", "hint": "**【样例解释 #1】**\n\n一种可能的输入如下：\n\n+ $2$ 号点的父亲是 $1$，$1$ 到 $2$ 的边初始权值为 $2$。\n+ $3$ 号点的父亲是 $2$，$2$ 到 $3$ 的边初始权值为 $1$。\n\n一种可能的交互过程如下：\n\n+ 调用 `query(2)`，返回 $2$。\n+ 调用 `exchange(1, 2)`。此时，$1$ 到 $2$ 的边权值为 $1$，$2$ 到 $3$ 的边权值为 $2$。\n+ 调用 `query(2)`，返回 $1$。此时，我们可以知道 $1$ 与 $2$ 直接相连。\n+ 调用 `query(3)`，返回 $2$。\n+ 调用 `exchange(1, 2)`。\n+ 调用 `query(3)`，返回 $2$。此时，我们可以推出 $2$ 与 $3$ 直接相连。\n+ 调用 `query(2)`，返回 $2$。此时，我们可以推出在两次 `exchange` 操作之后，$1$ 到 $2$ 的边权值为 $2$，$2$ 到 $3$ 的边的权值为 $1$。\n+ 调用 `answer([1, 2], [2, 1])`，结束程序。\n\n**【样例解释 #2】**\n\n这个样例满足 $n \\le 50$ 和特殊性质 A 的条件。\n\n**【样例解释 #3】**\n\n这个样例满足 $n \\le 1000$。\n\n**【样例解释 #4】**\n\n这个样例满足 $n \\le 20000$ 和特殊性质 B 的条件。\n\n**【样例解释 #5】**\n\n这个样例满足 $n \\le 100000$ 和特殊性质 A 的条件。\n\n**【样例解释 #6】**\n\n这个样例满足 $n \\le 100000$。\n\n**【样例解释 #7】**\n\n这个样例满足 $n \\le 500000$。\n\n**【数据范围】**\n\n|测试点编号|$n=$|$lim1=$|$lim2=$|特殊性质|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$10$|$1000001$|$1000001$|A|\n|$2$|$10$|$1000001$|$1000001$|A|\n|$3$|$50$|$1000002$|$1000002$|A|\n|$4$|$50$|$1000002$|$1000002$|A|\n|$5$|$600$|$3000003$|$3000003$|A|\n|$6$|$600$|$3000003$|$3000003$|A|\n|$7$|$1000$|$1100004$|$2200004$|A|\n|$8$|$1000$|$1100005$|$2200005$||\n|$9$|$1000$|$1100005$|$2200005$||\n|$10$|$20000$|$3000006$|$3000006$|B|\n|$11$|$20000$|$3000006$|$3000006$|B|\n|$12$|$20000$|$3000006$|$3000006$|B|\n|$13$|$100000$|$3000007$|$3000007$|A|\n|$14$|$100000$|$3000007$|$3000007$|A|\n|$15$|$100000$|$3000008$|$3000008$||\n|$16$|$100000$|$3000008$|$3000008$||\n|$17$|$100000$|$3000008$|$3000008$||\n|$18$|$500000$|$3500009$|$3500009$|A|\n|$19$|$500000$|$3500009$|$3500009$|A|\n|$20$|$500000$|$3500010$|$3500010$|B|\n|$21$|$500000$|$3500010$|$3500010$|B|\n|$22$|$500000$|$3500011$|$3500011$||\n|$23$|$500000$|$3500011$|$3500011$||\n|$24$|$500000$|$3500011$|$3500011$||\n|$25$|$500000$|$3500011$|$3500011$||\n\n特殊性质 A：\n\n+ 每个节点有不超过 $1$ 个儿子，即树的形态是一条链；\n+ 链的非根节点标号在所有可能的标号中等概率随机；\n+ 边的权值排列在所有 $(n - 1)!$ 种可能的排列中等概率随机。\n\n特殊性质 B：\n\n+ 树形态按如下方式随机生成：\n  - 先对每个 $2 \\le i \\le n$，令 $i$ 的父亲在 $[1, i - 1]$ 的整数之间等概率随机选取，\n  - **再等概率随机打乱非根节点的编号**，得到最终的带标号有根树的结构。\n+ 边的权值排列在所有 $(n - 1)!$ 种可能的排列中等概率随机。\n\n你可以根据 $lim1, lim2$ 的值来判断数据所满足的特殊性质。\n\n**【评分方式】**\n\n**本题首先会受到和传统题相同的限制**。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。你只能访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。\n\n在以上条件下，你能够拿到一个测试点的分数当且仅当你每次调用函数的参数格式正确，调用 `exchange` 函数的次数不超过 $lim1$ 次，调用 `query` 函数的次数不超过 $lim2$ 次，且**第一次**调用 `answer` 函数给出的 `par` 数组和 `val` 数组正确。\n\n保证在下发的交互库和最终评测的交互库中，`exchange` 和 `query` 函数的单次最坏复杂度是 $O(\\log n)$，在题目限制下使用时间不超过 $4$ 秒，最大空间占用不超过 $256$ MB。\n\n也就是说，你至少有 $4$ 秒的时间和 $768$ MB 的空间可以使用。\n\n**【提示】**\n\n我们再次提醒：**树的形态和每条边的权值是预先给定的，不会根据你的操作而动态生成。**\n\n你需要注意你的程序的时间开销和空间开销。\n\n**通过访问输入输出文件、攻击评测系统或攻击评测库等方式得分属于作弊行为，所得分数无效。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[WC/CTS2023] 树据结构", "background": "**这是一道交互题。**\n\n**在提交本题前请务必仔细阅读以下内容。**\n\n本题只支持 C++ 语言提交（建议使用 C++14，请不要使用 C++14 (GCC9)）。\n\n由于洛谷特殊的交互机制，在提交本题时，请去掉代码中的 ```#include \"ds.h\"``` 语句，并将以下内容粘贴到代码最开头，然后提交：\n\n```cpp\n#include <vector>\nvoid exchange(int x, int y);\nint query(int u);\nvoid answer(std::vector<int> par, std::vector<int> val);\n```\n\n如果您在提交本题时出现了任何意外的情况，请咨询管理员。", "description": "作为一个熟练的 OI 选手，你对数据结构的各种题型早已轻车熟路，比赛中只要碰到数据结构题就能三下五除二轻松搞定。这一天，你翻开 OJ，看到了这道题：\n\n给定 $n$ 个点的有根树，点编号为 $1, 2, \\dots, n$，$1$ 为根。每条边上有一个 $1$ 至 $n - 1$ 的**两两不同**的权值。维护一个数据结构，支持交换**权值为 $x$ 和 $y$** 的边的权值，以及询问从根节点到 $u$ 号点的所有的边的权值最大值。\n\n这种简单而经典的树上问题，对你已经是不在话下。厌倦了维护修改，回答询问的你，打算换一个角色。这回，你才是那个提问题的人，你需要构造合适的操作来套取题的数据。\n\n具体地说，现在你并不知道树的结构，也不知道初始时树上每条边的权值，你需要通过如下两种操作得到树的结构和 **初始时** 树上每条边的权值：\n\n1. 给出正整数 $x, y$，其中 $1 \\le x, y < n$，$x \\neq y$，交换 **权值为 $x, y$** 的两条边的权值。\n2. 给出正整数 $u$，其中 $2 \\le u \\le n$，并得到从 $1$ 号点到 $u$ 号点的路径上所有边中权值的最大值。\n\n**题目保证树的形态和每条边的权值是预先给定的，不会根据你的操作而动态生成。**\n\n**【实现细节】**\n\n你需要引用头文件 `#include \"ds.h\"`。你可以调用以下函数与交互库进行交互：\n\n```cpp\nvoid exchange(int x, int y);\n```\n\n+ 这个函数对应操作 $1$，表示交换**权值为 $x, y$** 的两条边的权值。\n+ 你需要保证 $1 \\le x, y < n$，$x \\neq y$。\n\n```cpp\nint query(int u);\n```\n\n+ 这个函数对应操作 $2$，返回从 $1$ 号点到 $u$ 号点的路径上所有边的权值的最大值。\n+ 你需要保证 $2 \\le u \\le n$。\n\n```cpp\nvoid answer(std::vector<int> par, std::vector<int> val);\n```\n\n- 这个函数用来回答你所得到的答案，格式如下：\n  - `par` 是一个长度为 $n - 1$ 的数组，其中 `par[i]` 表示树上 $i + 2$ 号节点的父亲编号，其中 $0 \\le i \\le n - 2$。\n  - `val` 也是一个长度为 $n - 1$ 的数组，其中 `val[i]` 表示树上 $i + 2$ 号节点到它父亲的边的**初始权值**，其中 $0 \\le i \\le n - 2$。\n- **你需要调用该函数恰好一次！**\n\n你不需要，也不应该实现主函数。在本题中，你只需要实现如下函数：\n\n```cpp\nvoid solve(int n, int lim1, int lim2);\n```\n\n- 其中，$n$ 表示树的点数，$lim1$ 表示操作 $1$ 的次数限制，$lim2$ 表示操作 $2$ 的次数限制。\n- 最终测试时，对于每个测试点，交互库会调用**恰好一次** `solve` 函数，并根据调用 `answer` 函数的正误来评分。\n\n在题目附件中，我们提供了 `sample.cpp` 供你参考，你可以在此基础上实现你的程序。\n\n**【测试程序方式】**\n\n题目附件中提供了 `grader.cpp` 文件。最终测试的交互库与下发交互库有不同，因此你的实现不应依赖交互库实现。\n\n你需要将你的程序 `ds.cpp` 和 `grader.cpp`、`ds.h` 放置在同一目录下，并在该目录下使用如下编译命令得到可执行程序 `ds(.exe)`：\n\n```bash\ng++ -o ds ds.cpp grader.cpp -O2 -std=c++14 -lm\n```\n\n**题目附件还提供了 `compile.sh`，其内容为该编译命令。你可以运行它进行编译，也可以复制该文件中的编译命令进行编译。**\n\n可执行程序从标准输入读入以下格式的数据：\n\n- 第一行包含三个正整数 $n, lim1, lim2$，表示树的点数，操作 $1$ 的限制次数和操作 $2$ 的限制次数。交互库保证可以处理 $2 \\le n \\le 500000$ 的情况，对于 $n > 500000$ 的情况不做正确运行保证。\n- 第二行 $n - 1$ 个正整数 $p_2, p_3, \\dots, p_n$。其中 $p_i$ 表示 $i$ 号点的父亲的节点编号。**你需要保证 $1 \\le p_i \\le n$ 且输入给出了合法的树的结构。**\n- 第三行 $n - 1$ 个正整数 $v_2, v_3, \\dots, v_n$。其中 $v_i$ 表示 $i$ 连向 $p_i$ 的边的权值。**你需要保证 $v_2, v_3, \\dots, v_n$ 构成 $1$ 至 $n - 1$ 的一个排列。**\n- **在本地测试时，请务必保证你的输入格式符合要求，否则我们不保证交互库会正常运行。**\n\n如果你的输入合法且没有运行错误，下发的交互库将会根据你的调用输出如下信息：\n\n- 如果某次 `exchange` 函数的调用违反了 $1 \\le x, y < n$，$x \\neq y$ 的限制，输出错误信息：`Invalid call of exchange(x, y)!`。\n- 如果 `exchange` 函数调用次数超过 $lim1$，输出错误信息：`Too many exchanges!`。\n- 如果某次 `query` 函数的调用违反了 $2 \\le u \\le n$ 的限制，输出错误信息：`Invalid call of query(u)!`。\n- 如果 `query` 函数调用次数超过 $lim2$，输出错误信息：`Too many queries!`。\n- 在输出任何以上错误信息后，交互库立即终止。\n- 交互库会在你**每次**调用 `answer` 函数时输出提示信息：\n  - 如果 `par` 或 `val` 的长度不是 $n - 1$，则输出 `Invalid output!`。\n  - 如果 `par` 数组与树的形态不同，那么它会给出**第一个**错误的位置，并返回如下格式的错误信息：`The answer to p[i] is wrong! The right answer is j, but you output k.`。注意，这里 $2 \\le i \\le n$，$j = p_i$ 为 $i$ 号点的真正的父亲编号，$k = $ `par[i - 2]` 为你给出的位置编号。\n  - 如果 `par` 数组正确，但 `val` 数组与**初始时**树上边权值不同，那么它会给出你**第一个**错误的位置，并返回如下格式的错误信息：`The answer to v[i] is wrong! The right answer is j, but you output k.`。类似地，这里 $2 \\le i \\le n$，$j = v_i$ 为 $i$ 号点到它父亲的边的真正的初始权值，$k =$ `val[i - 2]` 为你给出的权值。\n  - 如果你给出的 `par` 和 `val` 数组正确，那么交互库会输出你调用 `exchange` 函数和 `query` 函数的次数。输出格式为：`Right output! cnt1 = A, cnt2= B.`，其中 $A$ 表示你调用 `exchange` 函数的次数，$B$ 表示你调用 `query` 函数的次数。\n- **使用下发的交互库时你可以通过调用多次 `answer` 函数对你的程序进行测试。但对于你提交的代码，如果调用 `answer` 函数超过 $1$ 次，便只能获得 $0$ 分。**\n\n**你的程序不应该操作标准输入输出，否则视为攻击交互库。**\n", "inputFormat": "见【测试程序方式】。", "outputFormat": "见【测试程序方式】。", "hint": "**【样例解释 #1】**\n\n一种可能的输入如下：\n\n+ $2$ 号点的父亲是 $1$，$1$ 到 $2$ 的边初始权值为 $2$。\n+ $3$ 号点的父亲是 $2$，$2$ 到 $3$ 的边初始权值为 $1$。\n\n一种可能的交互过程如下：\n\n+ 调用 `query(2)`，返回 $2$。\n+ 调用 `exchange(1, 2)`。此时，$1$ 到 $2$ 的边权值为 $1$，$2$ 到 $3$ 的边权值为 $2$。\n+ 调用 `query(2)`，返回 $1$。此时，我们可以知道 $1$ 与 $2$ 直接相连。\n+ 调用 `query(3)`，返回 $2$。\n+ 调用 `exchange(1, 2)`。\n+ 调用 `query(3)`，返回 $2$。此时，我们可以推出 $2$ 与 $3$ 直接相连。\n+ 调用 `query(2)`，返回 $2$。此时，我们可以推出在两次 `exchange` 操作之后，$1$ 到 $2$ 的边权值为 $2$，$2$ 到 $3$ 的边的权值为 $1$。\n+ 调用 `answer([1, 2], [2, 1])`，结束程序。\n\n**【样例解释 #2】**\n\n这个样例满足 $n \\le 50$ 和特殊性质 A 的条件。\n\n**【样例解释 #3】**\n\n这个样例满足 $n \\le 1000$。\n\n**【样例解释 #4】**\n\n这个样例满足 $n \\le 20000$ 和特殊性质 B 的条件。\n\n**【样例解释 #5】**\n\n这个样例满足 $n \\le 100000$ 和特殊性质 A 的条件。\n\n**【样例解释 #6】**\n\n这个样例满足 $n \\le 100000$。\n\n**【样例解释 #7】**\n\n这个样例满足 $n \\le 500000$。\n\n**【数据范围】**\n\n|测试点编号|$n=$|$lim1=$|$lim2=$|特殊性质|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$10$|$1000001$|$1000001$|A|\n|$2$|$10$|$1000001$|$1000001$|A|\n|$3$|$50$|$1000002$|$1000002$|A|\n|$4$|$50$|$1000002$|$1000002$|A|\n|$5$|$600$|$3000003$|$3000003$|A|\n|$6$|$600$|$3000003$|$3000003$|A|\n|$7$|$1000$|$1100004$|$2200004$|A|\n|$8$|$1000$|$1100005$|$2200005$||\n|$9$|$1000$|$1100005$|$2200005$||\n|$10$|$20000$|$3000006$|$3000006$|B|\n|$11$|$20000$|$3000006$|$3000006$|B|\n|$12$|$20000$|$3000006$|$3000006$|B|\n|$13$|$100000$|$3000007$|$3000007$|A|\n|$14$|$100000$|$3000007$|$3000007$|A|\n|$15$|$100000$|$3000008$|$3000008$||\n|$16$|$100000$|$3000008$|$3000008$||\n|$17$|$100000$|$3000008$|$3000008$||\n|$18$|$500000$|$3500009$|$3500009$|A|\n|$19$|$500000$|$3500009$|$3500009$|A|\n|$20$|$500000$|$3500010$|$3500010$|B|\n|$21$|$500000$|$3500010$|$3500010$|B|\n|$22$|$500000$|$3500011$|$3500011$||\n|$23$|$500000$|$3500011$|$3500011$||\n|$24$|$500000$|$3500011$|$3500011$||\n|$25$|$500000$|$3500011$|$3500011$||\n\n特殊性质 A：\n\n+ 每个节点有不超过 $1$ 个儿子，即树的形态是一条链；\n+ 链的非根节点标号在所有可能的标号中等概率随机；\n+ 边的权值排列在所有 $(n - 1)!$ 种可能的排列中等概率随机。\n\n特殊性质 B：\n\n+ 树形态按如下方式随机生成：\n  - 先对每个 $2 \\le i \\le n$，令 $i$ 的父亲在 $[1, i - 1]$ 的整数之间等概率随机选取，\n  - **再等概率随机打乱非根节点的编号**，得到最终的带标号有根树的结构。\n+ 边的权值排列在所有 $(n - 1)!$ 种可能的排列中等概率随机。\n\n你可以根据 $lim1, lim2$ 的值来判断数据所满足的特殊性质。\n\n**【评分方式】**\n\n**本题首先会受到和传统题相同的限制**。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。你只能访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。\n\n在以上条件下，你能够拿到一个测试点的分数当且仅当你每次调用函数的参数格式正确，调用 `exchange` 函数的次数不超过 $lim1$ 次，调用 `query` 函数的次数不超过 $lim2$ 次，且**第一次**调用 `answer` 函数给出的 `par` 数组和 `val` 数组正确。\n\n保证在下发的交互库和最终评测的交互库中，`exchange` 和 `query` 函数的单次最坏复杂度是 $O(\\log n)$，在题目限制下使用时间不超过 $4$ 秒，最大空间占用不超过 $256$ MB。\n\n也就是说，你至少有 $4$ 秒的时间和 $768$ MB 的空间可以使用。\n\n**【提示】**\n\n我们再次提醒：**树的形态和每条边的权值是预先给定的，不会根据你的操作而动态生成。**\n\n你需要注意你的程序的时间开销和空间开销。\n\n**通过访问输入输出文件、攻击评测系统或攻击评测库等方式得分属于作弊行为，所得分数无效。**", "locale": "zh-CN"}}}
{"pid": "P9076", "type": "P", "difficulty": 3, "samples": [["35", "2"]], "limits": {"time": [200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "2018", "PA（波兰）"], "title": "[PA 2018] PIN", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda próbna [PIN](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/pin/)**\n\nBytie 忘记了手机密码。他记得它由三个不同的正整数 $a < b < c$ 组成。这些数字的总和是 $n$，此外每对数字（在 $(a, b)$，$(a,c)$ 和 $(b, c)$ 中）中，一个数字是另一个的倍数。\n\n帮助他计算需要检查的可能的三元组数目，以便他可以决定是否值得浪费在尝试密码上。", "inputFormat": "一行输入一个正整数 $n$。", "outputFormat": "输出一个整数，表示合法的三元组数目。", "hint": "#### 样例 1 解释\n\n有两个可行三元组：$(1,2,32)$，$(5,10,20)$。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2018] PIN", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda próbna [PIN](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/pin/)**\n\nBytie 忘记了手机密码。他记得它由三个不同的正整数 $a < b < c$ 组成。这些数字的总和是 $n$，此外每对数字（在 $(a, b)$，$(a,c)$ 和 $(b, c)$ 中）中，一个数字是另一个的倍数。\n\n帮助他计算需要检查的可能的三元组数目，以便他可以决定是否值得浪费在尝试密码上。", "inputFormat": "一行输入一个正整数 $n$。", "outputFormat": "输出一个整数，表示合法的三元组数目。", "hint": "#### 样例 1 解释\n\n有两个可行三元组：$(1,2,32)$，$(5,10,20)$。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P9077", "type": "P", "difficulty": 2, "samples": [["6\n2 1 5 3 1 1", "0\n5\n1 2\n2 3\n1 4\n1 5"], ["3\n1 2 2", "1\n3\n1 2\n2 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "Special Judge", "PA（波兰）"], "title": "[PA 2018] Poddrzewo", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 1 [Poddrzewo](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/pod/)**\n\n给定一个长度为 $n$ 的序列 $a$。\n\n构造一个结点数为 $k$ 的无根树，结点编号分别为 $1 \\cdots k$。该树第 $i$ 个结点的度数为 $a_i$。\n\n有可能无解，你可以进行如下操作来使其有解：\n\n1. 修改序列中第 $i$ 个数。\n1. 删除序列中第 $i$ 个数。\n1. 交换序列中第 $i,j$ 个数。\n\n可以证明，进行有限次操作后一定有解。\n\n你的任务是 **最小化操作 $1$ 使用的次数**。\n", "inputFormat": "一行一个整数 $n$，表示序列 $a$ 的长度。\n\n下一行有 $n$ 个整数，第 $i$ 个整数表示 $a_i$。\n", "outputFormat": "第一行一个整数 $x$ ，表示操作 $1$ 使用次数最小值。\n\n第二行一个整数 $k\\ (2 \\le k \\le n)$，表示你构造的树结点数目。\n\n接下来 $k-1$ 行，每行两个数 $u,v\\ (1 \\le u, v \\le k)$，表示连接第 $u,v$ 个结点。\n\n多解输出任意解。\n", "hint": "#### 样例 1 解释\n\n我们可以删除第 $3$ 个数字，然后更改元素的顺序。\n\n得到最后的序列为 $(3,2,1,1,1)$。\n\n这是构造的树的示意图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ptch7dx0.png)\n\n------------\n\n#### 样例 2 解释\n\n我们可以修改第 $3$ 个数字，得到最后的序列为 $(1,2,1)$。可以证明，操作 $1$ 至少需要使用 $1$ 次。\n\n这是构造的树的示意图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o6mhe76c.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据：\n\n- $2 \\le n \\le 10^6$\n- $1 \\le a_i \\le n-1$\n\n保证存在至少一个子任务，其中操作 $1$ 使用次数最小值为 $0$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2018] Poddrzewo", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 1 [Poddrzewo](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/pod/)**\n\n给定一个长度为 $n$ 的序列 $a$。\n\n构造一个结点数为 $k$ 的无根树，结点编号分别为 $1 \\cdots k$。该树第 $i$ 个结点的度数为 $a_i$。\n\n有可能无解，你可以进行如下操作来使其有解：\n\n1. 修改序列中第 $i$ 个数。\n1. 删除序列中第 $i$ 个数。\n1. 交换序列中第 $i,j$ 个数。\n\n可以证明，进行有限次操作后一定有解。\n\n你的任务是 **最小化操作 $1$ 使用的次数**。\n", "inputFormat": "一行一个整数 $n$，表示序列 $a$ 的长度。\n\n下一行有 $n$ 个整数，第 $i$ 个整数表示 $a_i$。\n", "outputFormat": "第一行一个整数 $x$ ，表示操作 $1$ 使用次数最小值。\n\n第二行一个整数 $k\\ (2 \\le k \\le n)$，表示你构造的树结点数目。\n\n接下来 $k-1$ 行，每行两个数 $u,v\\ (1 \\le u, v \\le k)$，表示连接第 $u,v$ 个结点。\n\n多解输出任意解。\n", "hint": "#### 样例 1 解释\n\n我们可以删除第 $3$ 个数字，然后更改元素的顺序。\n\n得到最后的序列为 $(3,2,1,1,1)$。\n\n这是构造的树的示意图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ptch7dx0.png)\n\n------------\n\n#### 样例 2 解释\n\n我们可以修改第 $3$ 个数字，得到最后的序列为 $(1,2,1)$。可以证明，操作 $1$ 至少需要使用 $1$ 次。\n\n这是构造的树的示意图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o6mhe76c.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据：\n\n- $2 \\le n \\le 10^6$\n- $1 \\le a_i \\le n-1$\n\n保证存在至少一个子任务，其中操作 $1$ 使用次数最小值为 $0$。\n", "locale": "zh-CN"}}}
{"pid": "P9078", "type": "P", "difficulty": 1, "samples": [["kostka", "6"], ["aaaa", "3"]], "limits": {"time": [250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "PA（波兰）"], "title": "[PA 2018] Język polski", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 1 [Język polski](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/pol/)** 。\n\n给定一个字符串 $s$ ，求出该字符串中满足以下条件的子串的数量。\n\n- 该字符串中至少有一个长度为 $3$ 的子串仅由辅音字母或仅由元音字母构成。\n\n注意，**波兰语的元音字母与英语不同**。波兰语中元音字母有 $a,e,i,o,u,y$。\n\n不是元音字母的字母即为辅音字母。", "inputFormat": "一行仅包含小写字母的字符串 $s$。", "outputFormat": "一行一个整数，表示满足条件的子串数。", "hint": "#### 样例 1 解释\n\n所有满足条件的子串列举如下：$\\texttt{stk},\\texttt{ostk},\\texttt{kostk},\\texttt{stka},\\texttt{ostka},\\texttt{kostka}$。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n设字符串长度为 $\\mathrm{len}$ ，则 $\\mathrm{len} \\le 200000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2018] Język polski", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 1 [Język polski](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/pol/)** 。\n\n给定一个字符串 $s$ ，求出该字符串中满足以下条件的子串的数量。\n\n- 该字符串中至少有一个长度为 $3$ 的子串仅由辅音字母或仅由元音字母构成。\n\n注意，**波兰语的元音字母与英语不同**。波兰语中元音字母有 $a,e,i,o,u,y$。\n\n不是元音字母的字母即为辅音字母。", "inputFormat": "一行仅包含小写字母的字符串 $s$。", "outputFormat": "一行一个整数，表示满足条件的子串数。", "hint": "#### 样例 1 解释\n\n所有满足条件的子串列举如下：$\\texttt{stk},\\texttt{ostk},\\texttt{kostk},\\texttt{stka},\\texttt{ostka},\\texttt{kostka}$。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n设字符串长度为 $\\mathrm{len}$ ，则 $\\mathrm{len} \\le 200000$。", "locale": "zh-CN"}}}
{"pid": "P9079", "type": "P", "difficulty": 0, "samples": [["6 5 1\n1 3\n2 3\n3 4\n4 5\n4 6", "2"], ["3 3 3\n1 2\n1 3\n2 3", "0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "PA（波兰）"], "title": "[PA 2018] Heros", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 2 [Heros](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/her/)**\n\n给定一个有向无环图，该图有 $n$ 个节点， $m$ 条有向边。\n\n你需要从中删除 $k$ 个点以及与其关联的边，使得图中的最长链最短。", "inputFormat": "第一行三个整数，分别表示 $n$ , $m$ , $k$。\n\n接下来 $m$ 行，每行两个整数 $x$ , $y$ ，表示从 $x$ 点到 $y$ 点有一条有向边。\n", "outputFormat": "一行一个整数，表示图中最长链的长度最小值。", "hint": "#### 样例 1 解释\n\n删除编号为 $4$ 的点后，图中的最长链长度为 $2$ 。即为我们可以得到的最长链长度的最小值。可以验证所有方案中图中最长链长度最小为 $2$ 。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6sgk5qmj.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据：\n\n- $1 \\le n \\le 300$\n- $0 \\le m \\le 400$\n- $0 \\le k \\le \\min(n,4)$\n- $1 \\le x < y \\le n$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2018] Heros", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 2 [Heros](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/her/)**\n\n给定一个有向无环图，该图有 $n$ 个节点， $m$ 条有向边。\n\n你需要从中删除 $k$ 个点以及与其关联的边，使得图中的最长链最短。", "inputFormat": "第一行三个整数，分别表示 $n$ , $m$ , $k$。\n\n接下来 $m$ 行，每行两个整数 $x$ , $y$ ，表示从 $x$ 点到 $y$ 点有一条有向边。\n", "outputFormat": "一行一个整数，表示图中最长链的长度最小值。", "hint": "#### 样例 1 解释\n\n删除编号为 $4$ 的点后，图中的最长链长度为 $2$ 。即为我们可以得到的最长链长度的最小值。可以验证所有方案中图中最长链长度最小为 $2$ 。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6sgk5qmj.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据：\n\n- $1 \\le n \\le 300$\n- $0 \\le m \\le 400$\n- $0 \\le k \\le \\min(n,4)$\n- $1 \\le x < y \\le n$", "locale": "zh-CN"}}}
{"pid": "P9080", "type": "P", "difficulty": 0, "samples": [["3\n8\n5\n13", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "PA（波兰）"], "title": "[PA 2018] Nowy kontrakt", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 2 [Nowy kontrakt](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/kon/)** 。\n\n给定一个长度为 $N$ 的正整数序列 $a$ ，你需要对序列内数末尾添加数字的方法使序列**严格单调递增**，你的目标是最小化添加数字的次数。\n\n在数 $a$ 后添加数字 $t$ 即为：\n\n$a \\gets a \\times 10 + t$ ,其中 $t \\in \\{0,1,2,3,4,5,6,7,8,9\\}$\n\n", "inputFormat": "第一行一个整数 $N$ 表示序列长度。\n\n第 $2$ 行至 $N+1$ 行每行一个数，第 $i$ 行表示序列中第 $i-1$ 个数。", "outputFormat": "一行一个整数，表示最小操作次数。", "hint": "#### 样例 1 解释\n\n对第 $2$ 个数字和第 $3$ 个数字分别添加一个数字，即 $a_2 \\gets a_2 \\times 10 + 7$ ， $a_3 \\gets a_3 \\times 10 + 3$ 。 得到的新序列为 $(8,57,133)$ ，是一个严格单调递增序列。操作次数为 $2$ ，还有其他的操作次数为 $2$ 的方法，但是不存在操作次数为 $1$ 的方法。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据：\n\n- $1 \\le N \\le 200000$ \n- $1 \\le a_i \\le 10^9$ ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2018] Nowy kontrakt", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 2 [Nowy kontrakt](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/kon/)** 。\n\n给定一个长度为 $N$ 的正整数序列 $a$ ，你需要对序列内数末尾添加数字的方法使序列**严格单调递增**，你的目标是最小化添加数字的次数。\n\n在数 $a$ 后添加数字 $t$ 即为：\n\n$a \\gets a \\times 10 + t$ ,其中 $t \\in \\{0,1,2,3,4,5,6,7,8,9\\}$\n\n", "inputFormat": "第一行一个整数 $N$ 表示序列长度。\n\n第 $2$ 行至 $N+1$ 行每行一个数，第 $i$ 行表示序列中第 $i-1$ 个数。", "outputFormat": "一行一个整数，表示最小操作次数。", "hint": "#### 样例 1 解释\n\n对第 $2$ 个数字和第 $3$ 个数字分别添加一个数字，即 $a_2 \\gets a_2 \\times 10 + 7$ ， $a_3 \\gets a_3 \\times 10 + 3$ 。 得到的新序列为 $(8,57,133)$ ，是一个严格单调递增序列。操作次数为 $2$ ，还有其他的操作次数为 $2$ 的方法，但是不存在操作次数为 $1$ 的方法。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据：\n\n- $1 \\le N \\le 200000$ \n- $1 \\le a_i \\le 10^9$ ", "locale": "zh-CN"}}}
{"pid": "P9081", "type": "P", "difficulty": 6, "samples": [["4\n0 0 0 -1\n-1 5 -2 2\n4 0 4 1\n2 2 6 6", "4.8000000000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "Special Judge", "PA（波兰）"], "title": "[PA 2018] Magiczne wieże", "background": "", "description": "**译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/)  Runda 3 [Magiczne wieże](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/mag/)**\n\n在一个王国中有 $n$ 个魔法师。每个魔法师有两座魔法塔。并且魔法师可以在自己的两座塔之间随意传送。\n\n出于某种原因，该国的居民只想居住在被魔法师环绕的区域。具体来说，如果一位居民从住所向任何方向移动，他都将接近其中一个魔法师（无论在哪个塔），他的住所就是安全的。\n\n依次连接所有的安全住所，它们围成了一个安全区域，请你求出这个区域的面积。", "inputFormat": "第一行一个整数 $n$，表示魔法师的数量。\n\n接下来的 $n$ 行，每行 $4$ 个整数 $ax_i,ay_i,bx_i,by_i$，表示第 $i$ 个魔法师所拥有的两座魔法塔 $a,b$。\n\n数据保证没有两座塔在同一位置上。", "outputFormat": "输出安全区域的面积。特殊地，如果没有安全点，那么区域的面积为 $0$。\n\n你的输出与标准答案的相对误差不能超过 $10^{-8}$。", "hint": "#### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yul09fhv.png)\n\n如图，黑色线段为一位魔法师的两座塔，灰色区域为安全区域。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，$3\\leq n\\leq 100$，$-500\\leq ax_i,ay_i,bx_i,by_i\\leq 500$。\n\n共 $10$ 个子任务，其中以下各个条件均至少有一个子任务满足：（每行为一个条件）\n\n- $n\\leq 10$，$-30\\leq ax_i,ay_i,bx_i,by_i\\leq 30$。\n\n- $n\\leq 10$。\n\n- $-30\\leq ax_i,ay_i,bx_i,by_i\\leq 30$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2018] Magiczne wieże", "background": "", "description": "**译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/)  Runda 3 [Magiczne wieże](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/mag/)**\n\n在一个王国中有 $n$ 个魔法师。每个魔法师有两座魔法塔。并且魔法师可以在自己的两座塔之间随意传送。\n\n出于某种原因，该国的居民只想居住在被魔法师环绕的区域。具体来说，如果一位居民从住所向任何方向移动，他都将接近其中一个魔法师（无论在哪个塔），他的住所就是安全的。\n\n依次连接所有的安全住所，它们围成了一个安全区域，请你求出这个区域的面积。", "inputFormat": "第一行一个整数 $n$，表示魔法师的数量。\n\n接下来的 $n$ 行，每行 $4$ 个整数 $ax_i,ay_i,bx_i,by_i$，表示第 $i$ 个魔法师所拥有的两座魔法塔 $a,b$。\n\n数据保证没有两座塔在同一位置上。", "outputFormat": "输出安全区域的面积。特殊地，如果没有安全点，那么区域的面积为 $0$。\n\n你的输出与标准答案的相对误差不能超过 $10^{-8}$。", "hint": "#### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yul09fhv.png)\n\n如图，黑色线段为一位魔法师的两座塔，灰色区域为安全区域。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，$3\\leq n\\leq 100$，$-500\\leq ax_i,ay_i,bx_i,by_i\\leq 500$。\n\n共 $10$ 个子任务，其中以下各个条件均至少有一个子任务满足：（每行为一个条件）\n\n- $n\\leq 10$，$-30\\leq ax_i,ay_i,bx_i,by_i\\leq 30$。\n\n- $n\\leq 10$。\n\n- $-30\\leq ax_i,ay_i,bx_i,by_i\\leq 30$。", "locale": "zh-CN"}}}
{"pid": "P9082", "type": "P", "difficulty": 7, "samples": [["2 12\n3\n0 -8 -512\n-16 -1 -128\n8 -2 -512\n3\n0 64 -1\n64 -1 -1\n1 -1 -1", "R TANK\nM 0 0 1 0\n=\n=\nM 1 0 1 1\nR FARMER\nM 0 0 1 0\n=\nM 1 0 2 0\n=\nM 2 0 1 0\n=\nM 1 0 0 0\n=\n===\nR FARMER\nM 0 0 0 1\nR FARMER\nM 0 0 1 0\n=\n=\n=\n=\nM 0 1 0 0\n=\nM 0 0 0 1\n=\n=\nM 1 0 2 0\n=\nM 2 0 1 0\n=\nM 1 0 0 0\n=\nM 0 0 1 0\n=\nR FARMER\nM 1 0 2 0\nM 0 0 1 0\nM 0 1 0 0\n=\n==="]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "Special Judge", "PA（波兰）"], "title": "[PA 2018] Gra", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 5 [Gra](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/gra/)**\n\n现在已经是周末了！你终于可以放松一下，玩你最喜欢的策略游戏了。这个游戏的目标是收集地图上的所有金币并将它们运回基地，规则如下：\n\n- 地图由一个 $n\\times n$ 的网格构成。行从上到下编号为 $0$ 到 $n-1$，列从左到右编号为 $0$ 到 $n-1$。我们用 $(r,c)$ 表示第 $r$ 行第 $c$ 列的单元格。两单元格相邻当且仅当它们共享同一条边。\n- 你的基地位于单元格 $(0,0)$，它位于左上角。你可以在那里招募新的角色，并且你必须把收集到的金币带到那里。剩下的 $n^2-1$ 个格子中初始要么有一定数量的金币，要么有一定数量的石头。\n- 游戏中有两种可以在地图上移动的角色：**农民**可以收集金币，但不可以进入有石头的单元格，**坦克**可以清除石头，并且可以进入任何种类的单元格。\n- 游戏分轮次进行。每轮每个角色可以至多移动一次，移动到与它所在的单元格相邻的单元格中。两个角色不能在同一时间处于同一单元格中。所有移动都是瞬时的（移动花费的时间为零）。\n- 如果在一轮结束时，农民位于有金币的单元格中，他就会拿走 $10$ 枚金币并放到自己的背包里。如果单元格中的金币少于 $10$ 枚，他就会全部拿走。农民的背包容量无限。但农民无法进入石头量不为 $0$ 的单元格中。如果在一轮结束时农民回到了基地，他就会把背包里所有的金币放回基地。\n- 如果在一轮结束时，坦克位于有石头的单元格中，它就会清除单元格中的 $10$ 个石头（如果少于 $10$ 个则清除全部）。\n- 最初基地中有 $200$ 枚金币。每买一种角色——农民或者坦克——都要花费 $100$ 金币（买之前在基地中必须至少有这么多金币），买后角色即时出现。所以新角色可以在同一轮移动。\n\n你的任务是，对于每一个输入给定的地图（也就是对于每个测试点），找到一个操作序列，使得按这个操作序列进行游戏后，所有地图上的金币都被运回了基地（并且可能部分或全部花掉了）。换句话说，结束后的地图上，任何单元格中都没有金币，任何农民的背包里也没有金币。命令如下表所示：\n\n|                   命令                   |                           效果                           |\n| :--------------------------------------: | :------------------------------------------------------: |\n|           $\\texttt{R FARMER}$            |              买一个农民角色，并出生在基地中              |\n|            $\\texttt{R TANK}$             |              买一个坦克角色，并出生在基地中              |\n| $\\texttt{M}\\ \\ r_1\\ \\ c_1\\ \\ r_2\\ \\ c_2$ | 将一个角色从 $(r_1,c_1)$ 移动到相邻的格子 $(r_2,c_2)$ 中 |\n|               $\\texttt{=}$               |                         结束这轮                         |\n|              $\\texttt{===}$              |              结束游戏（即目前的这个测试点）              |\n\n你的程序会使用组织者准备的测试数据进行测试，每组测试数据由一定数量的地图——也就是测试点组成。每组测试数据都有一个限制 $k$（请参考「数据范围及限制」一节）。这是对于每组数据平均轮数的限制。换句话说，如果测试数据中有 $T$ 张地图，你的程序必须在最多 $T\\cdot k$ 轮结束所有游戏。我们定义每个测试点的轮数为使用命令 $\\texttt{=}$ 的次数加 $1$。\n\n错误的命令，超出轮数限制或没有达成目标，均会被判为 Wrong Answer。", "inputFormat": "第一行包含两个整数 $T,k$，表示测试点个数和平均轮数限制。除了样例外所有测试数据都有 $T=10$。\n\n对于每组数据，第一行一个正整数 $n$。除了样例外所有测试数据都有 $n=20$。\n\n接下来 $n$ 行，每行 $n$ 个整数。$0$ 表示基地（一定位于左上角）。正数 $a$ 意味着这个单元格有 $a$ 枚金币，负数 $a$ 意味着这个单元格有 $|a|$ 个石头。\n\n地图按如下方式生成：对于每组测试数据，组织者会选择一个常数 $p\\ (0\\le p<1)$，表示单元格中有石头的概率。对于每个除基地以外的单元格，随机选择一个在 $0$ 到 $9$ 范围内的整数 $x$，然后将 $a=2^x$ 赋给这个单元格。在此之后，以 $p$ 的概率给这个值乘以 $-1$。", "outputFormat": "对于每组测试点，输出操作序列。一条命令输出一行。最多输出 $2\\ 000\\ 000$ 条命令。", "hint": "#### 样例 1 解释\n\n对于第一个测试点，我们首先买了一辆坦克，并立即从 $(0,0)$ 移动到 $(1,0)$，这样在两轮中清除掉了所有石头。然后我们将坦克移动到 $(1,1)$，在基地中买一个农民，并将其送到 $(2,0)$ 收集金币。当金币收集完后，我们让农民返回金币并清空背包。我们可以在第一轮就购买一个农民，但他需要一直等到坦克清除石头后才能移动。\n\n第二个测试点展示了一种不是最优但正确的答案。注意农民可以在不收集全部金币的情况下离开这个单元格。招募前两个角色就会花掉所有初始金币（$200$），所以我们只能在农民向基地运回 $100$ 金币后买第三个角色。\n\n第一个测试点中使用了 $7$ 轮，第二个测试点使用了 $13$ 轮。平均是 $10$ 轮，没有超过给定 $k$ 的限制。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n共有十个子任务，每个子任务包含 $2$ 到 $5$ 个测试数据。确切的 $p$ 值和 $k$ 值如下表所示：\n\n| $\\text{id}$ |   1    |   2    |   3    |   4   |   5   |   6    |   7    |   8    |   9    |  10   |\n| :---------: | :----: | :----: | :----: | :---: | :---: | :----: | :----: | :----: | :----: | :---: |\n|     $p$     |  $0$   |  $0$   |  $0$   |  $0$  |  $0$  | $0.3$  | $0.4$  | $0.5$  | $0.6$  | $0.7$ |\n|     $k$     | $9000$ | $3500$ | $1500$ | $600$ | $370$ | $1000$ | $1500$ | $3500$ | $1200$ | $750$ |\n\n请注意样例和测试数据在地图大小和测试点个数上稍有不同。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2018] Gra", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 5 [Gra](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/gra/)**\n\n现在已经是周末了！你终于可以放松一下，玩你最喜欢的策略游戏了。这个游戏的目标是收集地图上的所有金币并将它们运回基地，规则如下：\n\n- 地图由一个 $n\\times n$ 的网格构成。行从上到下编号为 $0$ 到 $n-1$，列从左到右编号为 $0$ 到 $n-1$。我们用 $(r,c)$ 表示第 $r$ 行第 $c$ 列的单元格。两单元格相邻当且仅当它们共享同一条边。\n- 你的基地位于单元格 $(0,0)$，它位于左上角。你可以在那里招募新的角色，并且你必须把收集到的金币带到那里。剩下的 $n^2-1$ 个格子中初始要么有一定数量的金币，要么有一定数量的石头。\n- 游戏中有两种可以在地图上移动的角色：**农民**可以收集金币，但不可以进入有石头的单元格，**坦克**可以清除石头，并且可以进入任何种类的单元格。\n- 游戏分轮次进行。每轮每个角色可以至多移动一次，移动到与它所在的单元格相邻的单元格中。两个角色不能在同一时间处于同一单元格中。所有移动都是瞬时的（移动花费的时间为零）。\n- 如果在一轮结束时，农民位于有金币的单元格中，他就会拿走 $10$ 枚金币并放到自己的背包里。如果单元格中的金币少于 $10$ 枚，他就会全部拿走。农民的背包容量无限。但农民无法进入石头量不为 $0$ 的单元格中。如果在一轮结束时农民回到了基地，他就会把背包里所有的金币放回基地。\n- 如果在一轮结束时，坦克位于有石头的单元格中，它就会清除单元格中的 $10$ 个石头（如果少于 $10$ 个则清除全部）。\n- 最初基地中有 $200$ 枚金币。每买一种角色——农民或者坦克——都要花费 $100$ 金币（买之前在基地中必须至少有这么多金币），买后角色即时出现。所以新角色可以在同一轮移动。\n\n你的任务是，对于每一个输入给定的地图（也就是对于每个测试点），找到一个操作序列，使得按这个操作序列进行游戏后，所有地图上的金币都被运回了基地（并且可能部分或全部花掉了）。换句话说，结束后的地图上，任何单元格中都没有金币，任何农民的背包里也没有金币。命令如下表所示：\n\n|                   命令                   |                           效果                           |\n| :--------------------------------------: | :------------------------------------------------------: |\n|           $\\texttt{R FARMER}$            |              买一个农民角色，并出生在基地中              |\n|            $\\texttt{R TANK}$             |              买一个坦克角色，并出生在基地中              |\n| $\\texttt{M}\\ \\ r_1\\ \\ c_1\\ \\ r_2\\ \\ c_2$ | 将一个角色从 $(r_1,c_1)$ 移动到相邻的格子 $(r_2,c_2)$ 中 |\n|               $\\texttt{=}$               |                         结束这轮                         |\n|              $\\texttt{===}$              |              结束游戏（即目前的这个测试点）              |\n\n你的程序会使用组织者准备的测试数据进行测试，每组测试数据由一定数量的地图——也就是测试点组成。每组测试数据都有一个限制 $k$（请参考「数据范围及限制」一节）。这是对于每组数据平均轮数的限制。换句话说，如果测试数据中有 $T$ 张地图，你的程序必须在最多 $T\\cdot k$ 轮结束所有游戏。我们定义每个测试点的轮数为使用命令 $\\texttt{=}$ 的次数加 $1$。\n\n错误的命令，超出轮数限制或没有达成目标，均会被判为 Wrong Answer。", "inputFormat": "第一行包含两个整数 $T,k$，表示测试点个数和平均轮数限制。除了样例外所有测试数据都有 $T=10$。\n\n对于每组数据，第一行一个正整数 $n$。除了样例外所有测试数据都有 $n=20$。\n\n接下来 $n$ 行，每行 $n$ 个整数。$0$ 表示基地（一定位于左上角）。正数 $a$ 意味着这个单元格有 $a$ 枚金币，负数 $a$ 意味着这个单元格有 $|a|$ 个石头。\n\n地图按如下方式生成：对于每组测试数据，组织者会选择一个常数 $p\\ (0\\le p<1)$，表示单元格中有石头的概率。对于每个除基地以外的单元格，随机选择一个在 $0$ 到 $9$ 范围内的整数 $x$，然后将 $a=2^x$ 赋给这个单元格。在此之后，以 $p$ 的概率给这个值乘以 $-1$。", "outputFormat": "对于每组测试点，输出操作序列。一条命令输出一行。最多输出 $2\\ 000\\ 000$ 条命令。", "hint": "#### 样例 1 解释\n\n对于第一个测试点，我们首先买了一辆坦克，并立即从 $(0,0)$ 移动到 $(1,0)$，这样在两轮中清除掉了所有石头。然后我们将坦克移动到 $(1,1)$，在基地中买一个农民，并将其送到 $(2,0)$ 收集金币。当金币收集完后，我们让农民返回金币并清空背包。我们可以在第一轮就购买一个农民，但他需要一直等到坦克清除石头后才能移动。\n\n第二个测试点展示了一种不是最优但正确的答案。注意农民可以在不收集全部金币的情况下离开这个单元格。招募前两个角色就会花掉所有初始金币（$200$），所以我们只能在农民向基地运回 $100$ 金币后买第三个角色。\n\n第一个测试点中使用了 $7$ 轮，第二个测试点使用了 $13$ 轮。平均是 $10$ 轮，没有超过给定 $k$ 的限制。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n共有十个子任务，每个子任务包含 $2$ 到 $5$ 个测试数据。确切的 $p$ 值和 $k$ 值如下表所示：\n\n| $\\text{id}$ |   1    |   2    |   3    |   4   |   5   |   6    |   7    |   8    |   9    |  10   |\n| :---------: | :----: | :----: | :----: | :---: | :---: | :----: | :----: | :----: | :----: | :---: |\n|     $p$     |  $0$   |  $0$   |  $0$   |  $0$  |  $0$  | $0.3$  | $0.4$  | $0.5$  | $0.6$  | $0.7$ |\n|     $k$     | $9000$ | $3500$ | $1500$ | $600$ | $370$ | $1000$ | $1500$ | $3500$ | $1200$ | $750$ |\n\n请注意样例和测试数据在地图大小和测试点个数上稍有不同。", "locale": "zh-CN"}}}
{"pid": "P9083", "type": "P", "difficulty": 7, "samples": [["4\n3 5\n2 1\n1 4\n2 1", "27\n24\n25\n35"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "PA（波兰）"], "title": "[PA 2018] Ryki", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 5 [Ryki](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/ryk/)**\n\nBerlandia 是一个由方格组成的无限大棋盘。行从下到上用递增的整数编号，列从左到右用递增的整数编号。令 $(r,c)$ 表示第 $r$ 行第 $c$ 列的方格。如果两个不同方格至少有一个角接触，我们就称这两个格子相邻。这意味着格子是八连通的。\n\n两个格子 $(R_A,C_A)$ 与 $(R_B,C_B)$ 之间的距离是欧几里得距离，也就是：\n$$\n\\sqrt{(R_A-R_B)^2+(C_A-C_B)^2}\n$$\nBerlandia 地区居住着 $n$ 只熊。第 $i$ 只熊居住在方格 $(r_i,c_i)$ 处。同一方格中可以居住多只熊。\n\n熊可以单独生活，但是有时也会相互靠近。当一只熊吼叫时，其他方格中所有的熊会立即移动到相邻的方格中离吼叫的熊最近的方格。可以证明有且仅有一个这样的方格（不会出现并列情况）。与吼叫的熊在同一方格的熊不会移动位置。\n\n例如，考虑一对熊，一只在方格 $(2,1)$，另一只在方格 $(4,8)$。方格 $(2,1)$ 中的熊吼叫会让另一只熊移向方格 $(3,7)$ ，这两只熊最后相距 $\\sqrt{(3-2)^2+(7-1)^2}=\\sqrt{37}$。\n\n这些熊会按第一只，第二只，……，最后一只的顺序依次吼叫。除了一只叫 Limak 的熊，他太冷了以至于吼不出来，并且他也不能离开他所在的方格，可怜的 Limak。\n\n但你不知道 Limak 是哪只熊，对于 $1$ 到 $n$ 的每一个 $k$，如果第 $k$ 只熊是 Limak，请找出所有熊的最终位置。对于每种可能，输出所有熊的横纵坐标乘积之和就可以了。也就是说，假设在 $n-1$ 次吼叫后，第 $i$ 只熊在 $(r_i',c_i')$，则输出：\n$$\n\\sum_{i=1}^n r_i'c_i'\n$$\n", "inputFormat": "输入第一行包括一个正整数 $n\\ (2\\le n\\le 250\\ 000)$，表示熊的数量。\n\n接下来 $n$ 行，每行两个整数 $r_i,c_i\\ (1\\le r_i,c_i\\le 10^6)$，第 $i$ 行表示第 $i$ 只熊的初始位置。", "outputFormat": "输出 $n$ 行，第 $k$ 行输出一个整数，表示假设 Limak 是第 $k$ 只熊的话，最终所有熊所在行列之积的和。", "hint": "#### 样例 1 解释\n\n下图展示了 $k=2$ 的情况，即熊的吼叫顺序为 $1,3,4$。红色圆圈表示吼叫的熊。最后乘积的和为 $2 \\cdot 4 + 2 \\cdot 1 + 2 \\cdot 4 + 2 \\cdot 3 = 24$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ri72cgjf.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n保证每组子任务中下述三种情况至少出现一种：\n\n- $n\\le 10^5$\n- 对于所有 $i$ 都有 $c_i=1$\n- 时间限制为 $8$ 秒\n\n注：由于未公布每个测试点的详细时间限制，因此本题所有测试点的时间限制均为 $4$ 秒。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2018] Ryki", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 5 [Ryki](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/ryk/)**\n\nBerlandia 是一个由方格组成的无限大棋盘。行从下到上用递增的整数编号，列从左到右用递增的整数编号。令 $(r,c)$ 表示第 $r$ 行第 $c$ 列的方格。如果两个不同方格至少有一个角接触，我们就称这两个格子相邻。这意味着格子是八连通的。\n\n两个格子 $(R_A,C_A)$ 与 $(R_B,C_B)$ 之间的距离是欧几里得距离，也就是：\n$$\n\\sqrt{(R_A-R_B)^2+(C_A-C_B)^2}\n$$\nBerlandia 地区居住着 $n$ 只熊。第 $i$ 只熊居住在方格 $(r_i,c_i)$ 处。同一方格中可以居住多只熊。\n\n熊可以单独生活，但是有时也会相互靠近。当一只熊吼叫时，其他方格中所有的熊会立即移动到相邻的方格中离吼叫的熊最近的方格。可以证明有且仅有一个这样的方格（不会出现并列情况）。与吼叫的熊在同一方格的熊不会移动位置。\n\n例如，考虑一对熊，一只在方格 $(2,1)$，另一只在方格 $(4,8)$。方格 $(2,1)$ 中的熊吼叫会让另一只熊移向方格 $(3,7)$ ，这两只熊最后相距 $\\sqrt{(3-2)^2+(7-1)^2}=\\sqrt{37}$。\n\n这些熊会按第一只，第二只，……，最后一只的顺序依次吼叫。除了一只叫 Limak 的熊，他太冷了以至于吼不出来，并且他也不能离开他所在的方格，可怜的 Limak。\n\n但你不知道 Limak 是哪只熊，对于 $1$ 到 $n$ 的每一个 $k$，如果第 $k$ 只熊是 Limak，请找出所有熊的最终位置。对于每种可能，输出所有熊的横纵坐标乘积之和就可以了。也就是说，假设在 $n-1$ 次吼叫后，第 $i$ 只熊在 $(r_i',c_i')$，则输出：\n$$\n\\sum_{i=1}^n r_i'c_i'\n$$\n", "inputFormat": "输入第一行包括一个正整数 $n\\ (2\\le n\\le 250\\ 000)$，表示熊的数量。\n\n接下来 $n$ 行，每行两个整数 $r_i,c_i\\ (1\\le r_i,c_i\\le 10^6)$，第 $i$ 行表示第 $i$ 只熊的初始位置。", "outputFormat": "输出 $n$ 行，第 $k$ 行输出一个整数，表示假设 Limak 是第 $k$ 只熊的话，最终所有熊所在行列之积的和。", "hint": "#### 样例 1 解释\n\n下图展示了 $k=2$ 的情况，即熊的吼叫顺序为 $1,3,4$。红色圆圈表示吼叫的熊。最后乘积的和为 $2 \\cdot 4 + 2 \\cdot 1 + 2 \\cdot 4 + 2 \\cdot 3 = 24$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ri72cgjf.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n保证每组子任务中下述三种情况至少出现一种：\n\n- $n\\le 10^5$\n- 对于所有 $i$ 都有 $c_i=1$\n- 时间限制为 $8$ 秒\n\n注：由于未公布每个测试点的详细时间限制，因此本题所有测试点的时间限制均为 $4$ 秒。", "locale": "zh-CN"}}}
{"pid": "P9084", "type": "P", "difficulty": 6, "samples": [["5 3 100000007", "4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2018", "笛卡尔树", "PA（波兰）"], "title": "[PA 2018] Skwarki", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 5 [Skwarki](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/skw/)** 。\n\n求有多少种长度为 $ N $ 的满足以下条件的序列 ：\n\n* $ 1 \\sim N $ 这 $ N $ 个数在序列中各出现了一次；\n* 进行恰好 $K$ 次操作后，该序列才只含有 $1$ 个元素。\n\n下面对操作进行描述：\n\n设 $A_i$ 为序列中的第 $i$ 个元素（$1 < i < \\mathrm{len}$ ， $\\mathrm{len}$ 为序列长度），若 $A_{i-1} > A_{i}$ 或 $A_{i+1} > A_{i}$ 则标记 $A_i$ 。 若 $A_2 > A_1$ 则标记 $A_1$ ， 若 $A_{\\mathrm{len}-1} > A_{\\mathrm{len}}$ 则标记 $A_{\\mathrm{len}}$ 。\n\n然后，将有标记的元素从序列中删除。\n\n满足条件的序列可能很多，所以请将结果对 $P$ 取模。", "inputFormat": "输入仅一行，包含三个整数 $N,K,P$。", "outputFormat": "输出一行一个整数，表示满足条件的序列个数对 $P$ 取模的结果。", "hint": "#### 样例 1 解释\n\n所有满足条件的序列列举如下：\n\n- $(4,1,3,2,5)$\n- $(4,2,3,1,5)$\n- $(5,1,3,2,4)$\n- $(5,2,3,1,4)$\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1 \\le K,N \\le 1000$ , $N \\ge 2$ , $10^8 \\le P \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2018] Skwarki", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 5 [Skwarki](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/skw/)** 。\n\n求有多少种长度为 $ N $ 的满足以下条件的序列 ：\n\n* $ 1 \\sim N $ 这 $ N $ 个数在序列中各出现了一次；\n* 进行恰好 $K$ 次操作后，该序列才只含有 $1$ 个元素。\n\n下面对操作进行描述：\n\n设 $A_i$ 为序列中的第 $i$ 个元素（$1 < i < \\mathrm{len}$ ， $\\mathrm{len}$ 为序列长度），若 $A_{i-1} > A_{i}$ 或 $A_{i+1} > A_{i}$ 则标记 $A_i$ 。 若 $A_2 > A_1$ 则标记 $A_1$ ， 若 $A_{\\mathrm{len}-1} > A_{\\mathrm{len}}$ 则标记 $A_{\\mathrm{len}}$ 。\n\n然后，将有标记的元素从序列中删除。\n\n满足条件的序列可能很多，所以请将结果对 $P$ 取模。", "inputFormat": "输入仅一行，包含三个整数 $N,K,P$。", "outputFormat": "输出一行一个整数，表示满足条件的序列个数对 $P$ 取模的结果。", "hint": "#### 样例 1 解释\n\n所有满足条件的序列列举如下：\n\n- $(4,1,3,2,5)$\n- $(4,2,3,1,5)$\n- $(5,1,3,2,4)$\n- $(5,2,3,1,4)$\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1 \\le K,N \\le 1000$ , $N \\ge 2$ , $10^8 \\le P \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P9085", "type": "P", "difficulty": 7, "samples": [["6 5 5", "42"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "PA（波兰）"], "title": "[PA 2018] Wielokąty", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 5 [Wielokąty](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/wie/)** 。\n\n请求出满足以下条件的多边形的个数：\n\n-  记该多边形的第 $i$ 个顶点为$(x_i,y_i)$ ，则 $x_i,y_i \\in \\mathbb{Z}$ 且 $1 \\le x_i \\le X$ , $1 \\le y_i \\le Y$ 。\n-  该多边形的任意一条边（不包含端点）不能经过格点（即横纵坐标都为整数的点）。\n-  该多边形的每一条边的长度都是不超过 $K$ 的整数。\n-  该多边形是一个凸多边形，而且不能退化（不能出现三点共线，自切，不小于 $180 ^{\\circ}$ 的角）。\n-  该多边形的每一条边都是线段。\n\n由于满足条件的多边形数量太大，你只需要输出其对 $2^{32}$ 取模后的值即可。 \n\n下图展示了三个不合法的多边形。第一个多边形的边经过了格点，第二个多边形退化了，第三个多边形不是凸的。而且第一，三个有的边长不是整数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/esporbly.png)\n\n我们将两个多边形看做不相同的多边形，当且仅当它们有至少一个顶点不相同。", "inputFormat": "输入只有一行，包含三个正整数 $X,Y,K$。", "outputFormat": "输出一行一个整数，即为满足条件的多边形的数量对 $2^{32}$ 取模后的值。\n", "hint": "#### 样例 1 解释\n\n下图展示了 $42$ 个合法多边形中的一个多边形。\n\n可以验证，该多边形满足每一个条件。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bs5qcmn5.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1 \\le X,Y \\le 10^9,1 \\le K \\le 250$ 。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2018] Wielokąty", "background": "", "description": "**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 5 [Wielokąty](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/wie/)** 。\n\n请求出满足以下条件的多边形的个数：\n\n-  记该多边形的第 $i$ 个顶点为$(x_i,y_i)$ ，则 $x_i,y_i \\in \\mathbb{Z}$ 且 $1 \\le x_i \\le X$ , $1 \\le y_i \\le Y$ 。\n-  该多边形的任意一条边（不包含端点）不能经过格点（即横纵坐标都为整数的点）。\n-  该多边形的每一条边的长度都是不超过 $K$ 的整数。\n-  该多边形是一个凸多边形，而且不能退化（不能出现三点共线，自切，不小于 $180 ^{\\circ}$ 的角）。\n-  该多边形的每一条边都是线段。\n\n由于满足条件的多边形数量太大，你只需要输出其对 $2^{32}$ 取模后的值即可。 \n\n下图展示了三个不合法的多边形。第一个多边形的边经过了格点，第二个多边形退化了，第三个多边形不是凸的。而且第一，三个有的边长不是整数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/esporbly.png)\n\n我们将两个多边形看做不相同的多边形，当且仅当它们有至少一个顶点不相同。", "inputFormat": "输入只有一行，包含三个正整数 $X,Y,K$。", "outputFormat": "输出一行一个整数，即为满足条件的多边形的数量对 $2^{32}$ 取模后的值。\n", "hint": "#### 样例 1 解释\n\n下图展示了 $42$ 个合法多边形中的一个多边形。\n\n可以验证，该多边形满足每一个条件。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bs5qcmn5.png)\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于 $100\\%$ 的数据，保证 $1 \\le X,Y \\le 10^9,1 \\le K \\le 250$ 。", "locale": "zh-CN"}}}
{"pid": "P9086", "type": "P", "difficulty": 2, "samples": [["1\n4\n1 2 3 4\n2 4 3 4", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "洛谷原创", "O2优化", "洛谷月赛"], "title": "「SvR-2」令人为难的区间操作问题", "background": "**Problem Number:** $\\textit{45}$\n\n众所周知，区间操作问题应该求出区间和、最大值等值。但今天小 F 有个不情之请。", "description": "小 F 正在研究[斐波那契数列](https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0)，他惊讶地发现，可以把这种数列 $F$ 的定义式略作修改，得到 $\\digamma$ 数列：\n\n$$\\digamma(x)=\\{1,1,-1,-1,1,1,-1,-1,1,\\ldots\\}$$\n\n注意到 $\\digamma$ 数列具有周期性，最小正周期 $T=4$。\n\n请注意这里 $\\digamma$ 数列与数学上用其表示的[双伽玛函数](https://zh.wikipedia.org/wiki/%E5%8F%8C%E4%BC%BD%E7%8E%9B%E5%87%BD%E6%95%B0)的区别。\n\n小 F 找到一个长度为 $n$ 的数列 $a$，他每次对其进行如下操作：\n\n- 选定两个整数 $l,r$，满足 $1\\le l\\le r\\le n$。\n- 对于每个满足 $l\\le i\\le r$ 的 $i$，将 $a_i$ 加上 $\\digamma(i-l+1)$。\n- 记录下本次操作（即第 $j$ 次操作）的选定区间的长度 $len_j=r-l+1$。\n\n他一共进行了 $m$ 次操作，操作后得到数列记作 $b$，同时记 $sum=\\sum_{i=1}^mlen_i$。\n\n不幸的是，小 F 把 $sum$ 和数列 $len$ 都弄丢了，他只记得 $n$ 和数列 $a,b$。\n\n现在，他想请你根据这些信息，求出 $sum$ 的**奇偶**，**即 $\\textbf{\\textit{sum}}$ 对 $\\textbf2$ 取模后的值**。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n接下来 $3\\cdot T$ 行，描述每组数据。对于每组数据：\n\n- 第一行一个整数 $n$。\n- 第二行 $n$ 个整数，描述数列 $a$。\n- 第三行 $n$ 个整数，描述数列 $b$。\n\n**数据保证数列 $a$ 一定可以经过若干操作变为数列 $b$。**", "outputFormat": "对于每组数据，输出仅一行一个数，即 $sum$ 对 $2$ 取模后的值。", "hint": "#### 样例 1 说明\n\n注意到可能进行的是如下操作：\n\n- 第 $1$ 次操作选定 $l=2,r=3$，则数列变成 $[1,{\\underline{\\color{red}\\textbf{3}}},{\\underline{\\color{red}\\textbf{4}}},4]$。此时 $len_1=2$。\n- 第 $2$ 次操作选定 $l=1,r=3$，则数列变成 $[{\\underline{\\color{red}\\textbf{2}}},{\\underline{\\color{red}\\textbf{4}}},{\\underline{\\color{red}\\textbf{3}}},4]$。此时 $len_2=3$。\n\n则 $sum=len_1+len_2=5$，是奇数。故 $sum\\bmod 2=1$。\n\n#### 数据规模与约定\n**本题采用捆绑测试**\n$$\n\\newcommand{\\arraystretch}{1.5}\n\\begin{array}{c|c|c|c}\\hline\\hline\n\\textbf{Subtask} & \\bm{\\sum n\\le} & \\textbf{特殊性质} & \\textbf{分值} \\\\\\hline\n\\textsf{1} & \\le 10 & a_i,b_i\\le 10^9 & 10 \\\\\\hline\n\\textsf{2} & \\le 10^3 & a_i,b_i\\le 10^9 & 20 \\\\\\hline\n\\textsf{3} & \\text{无特殊限制} & a_i,b_i\\le 10^9 & 20 \\\\\\hline\n\\textsf{4} & \\text{无特殊限制} & a_i\\le b_i & 20 \\\\\\hline\n\\textsf{5} & \\text{无特殊限制} & - & 30 \\\\\\hline\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，有 $1\\le T\\le 10^3$，$1\\le n\\le 10^5$，$1\\le a_i,b_i\\le 10^{18}$。\n\n单个测试点内保证 $\\sum n\\le 2\\times 10^5$。\n\n#### 说明\n\n$\\digamma$ 数列拥有如下的递推式：\n\n$$\n\\digamma(x)=\n\\begin{cases}\n1,&x\\le 2\\\\\n-1,&x=3\\\\\n\\digamma(x-1)-\\digamma(x-2)+\\digamma(x-3),&x>3.\n\\end{cases}\n$$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「SvR-2」令人为难的区间操作问题", "background": "**Problem Number:** $\\textit{45}$\n\n众所周知，区间操作问题应该求出区间和、最大值等值。但今天小 F 有个不情之请。", "description": "小 F 正在研究[斐波那契数列](https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0)，他惊讶地发现，可以把这种数列 $F$ 的定义式略作修改，得到 $\\digamma$ 数列：\n\n$$\\digamma(x)=\\{1,1,-1,-1,1,1,-1,-1,1,\\ldots\\}$$\n\n注意到 $\\digamma$ 数列具有周期性，最小正周期 $T=4$。\n\n请注意这里 $\\digamma$ 数列与数学上用其表示的[双伽玛函数](https://zh.wikipedia.org/wiki/%E5%8F%8C%E4%BC%BD%E7%8E%9B%E5%87%BD%E6%95%B0)的区别。\n\n小 F 找到一个长度为 $n$ 的数列 $a$，他每次对其进行如下操作：\n\n- 选定两个整数 $l,r$，满足 $1\\le l\\le r\\le n$。\n- 对于每个满足 $l\\le i\\le r$ 的 $i$，将 $a_i$ 加上 $\\digamma(i-l+1)$。\n- 记录下本次操作（即第 $j$ 次操作）的选定区间的长度 $len_j=r-l+1$。\n\n他一共进行了 $m$ 次操作，操作后得到数列记作 $b$，同时记 $sum=\\sum_{i=1}^mlen_i$。\n\n不幸的是，小 F 把 $sum$ 和数列 $len$ 都弄丢了，他只记得 $n$ 和数列 $a,b$。\n\n现在，他想请你根据这些信息，求出 $sum$ 的**奇偶**，**即 $\\textbf{\\textit{sum}}$ 对 $\\textbf2$ 取模后的值**。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n接下来 $3\\cdot T$ 行，描述每组数据。对于每组数据：\n\n- 第一行一个整数 $n$。\n- 第二行 $n$ 个整数，描述数列 $a$。\n- 第三行 $n$ 个整数，描述数列 $b$。\n\n**数据保证数列 $a$ 一定可以经过若干操作变为数列 $b$。**", "outputFormat": "对于每组数据，输出仅一行一个数，即 $sum$ 对 $2$ 取模后的值。", "hint": "#### 样例 1 说明\n\n注意到可能进行的是如下操作：\n\n- 第 $1$ 次操作选定 $l=2,r=3$，则数列变成 $[1,{\\underline{\\color{red}\\textbf{3}}},{\\underline{\\color{red}\\textbf{4}}},4]$。此时 $len_1=2$。\n- 第 $2$ 次操作选定 $l=1,r=3$，则数列变成 $[{\\underline{\\color{red}\\textbf{2}}},{\\underline{\\color{red}\\textbf{4}}},{\\underline{\\color{red}\\textbf{3}}},4]$。此时 $len_2=3$。\n\n则 $sum=len_1+len_2=5$，是奇数。故 $sum\\bmod 2=1$。\n\n#### 数据规模与约定\n**本题采用捆绑测试**\n$$\n\\newcommand{\\arraystretch}{1.5}\n\\begin{array}{c|c|c|c}\\hline\\hline\n\\textbf{Subtask} & \\bm{\\sum n\\le} & \\textbf{特殊性质} & \\textbf{分值} \\\\\\hline\n\\textsf{1} & \\le 10 & a_i,b_i\\le 10^9 & 10 \\\\\\hline\n\\textsf{2} & \\le 10^3 & a_i,b_i\\le 10^9 & 20 \\\\\\hline\n\\textsf{3} & \\text{无特殊限制} & a_i,b_i\\le 10^9 & 20 \\\\\\hline\n\\textsf{4} & \\text{无特殊限制} & a_i\\le b_i & 20 \\\\\\hline\n\\textsf{5} & \\text{无特殊限制} & - & 30 \\\\\\hline\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，有 $1\\le T\\le 10^3$，$1\\le n\\le 10^5$，$1\\le a_i,b_i\\le 10^{18}$。\n\n单个测试点内保证 $\\sum n\\le 2\\times 10^5$。\n\n#### 说明\n\n$\\digamma$ 数列拥有如下的递推式：\n\n$$\n\\digamma(x)=\n\\begin{cases}\n1,&x\\le 2\\\\\n-1,&x=3\\\\\n\\digamma(x-1)-\\digamma(x-2)+\\digamma(x-3),&x>3.\n\\end{cases}\n$$", "locale": "zh-CN"}}}
{"pid": "P9087", "type": "P", "difficulty": 4, "samples": [["2\n4 5 2 2\n8 6 3 2", "0\nSept\n3\n2023yyds"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["洛谷原创", "Special Judge", "构造", "洛谷月赛"], "title": "「SvR-2」音符", "background": "", "description": ">本题中「子串」指：\n>\n>若字符串 $s$ 中有一段**连续的**字符构成字符串 $p$，则 $p$ 是 $s$ 的子串。\n\n我们用一个字符串代替一份乐谱，用字符代替每一个音符。\n\n我们定义「重音」表示乐谱中出现了两个**连续**的相同字符，如 $\\tt eeeee$ 中存在 $4$ 个「重音」。\n\n现在 Sept 准备写一份长度为 $n$ 的乐谱给 Tpes 看，他对乐谱的评价标准如下：\n\n- 乐谱中每出现一个「重音」，他的愤怒值就会增加 $a$。\n- 乐谱中每有一段长度为 $k$ 的**子串**中不存在「重音」，他的愤怒值就会增加 $b$。\n\n现在已知 $n,k,a,b$，请你帮 Sept 构造出一份乐谱，使得 Tpes 的愤怒值 $x$ **最小**。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n接下来 $T$ 行，每行两个整数 $n,k,a,b$，意义如题目所述。", "outputFormat": "共 $2 \\cdot T$ 行，对于每组数据都输出两行：\n\n- 第 1 行表示 Tpes 最小的愤怒值 $x$。\n- 第 2 行表示你构造出的乐谱。", "hint": "#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n| $\\bf{Subtask}$ | $\\bm{n\\le}$ | $\\bm{\\sum n\\le}$ | $\\bm{T\\le}$ | $\\bf{Score}$ |\n| :-: | :-: | :-: | :-: | :-: |\n| $\\sf 1$ | $6$ | $10$ | $3$ | $\\tt 10$ |\n| $\\sf 2$ | $10^3$ | $2\\times 10^3$ | 无特殊限制 | $\\tt 30$ |\n| $\\sf 3$ | 无特殊限制 | 无特殊限制 | 无特殊限制 | $\\tt 60$ |\n\n对于 $100\\%$ 的数据，有 $2\\le T\\le 100$，$2\\le n,k\\le 10^5$，$1\\le a,b\\le 10^9$。单组数据内保证 $\\sum n\\le 2\\times 10^5$。\n\n#### 输出注意事项\n\n输出 $x$ 和构造乐谱可以看作是两个子问题，如果你只会完成其中的一个，请在另一个子问题对应的地方用**符合要求的字符或数字**占位。\n\n乐谱中你可以输出任意字符，包括数字、大小写字母等，但**不能出现空格**。\n\n#### Special Judge 返回信息说明\n\n本题采用 Special Judge 判断你的答案是否正确。\n\nchecker.cpp 将会以 $\\texttt{Score=}\\text A,\\texttt{Type=}\\text B$ 的方式返回信息。\n\n$\\tt Score$ 类表示你的得分情况，$\\text A$ 有以下取值：\n\n- $\\text A=1$，表示含义如下：\\\n  $\\text{Accepted.} \\texttt{ Your Ans and SM are both proper.}$\\\n  代表 $T$ 组答案全部符合要求。\n- $\\text A=2$，表示含义如下：\\\n  $\\text{Partially Correct.}\\texttt{ All Ans are right.}$\\\n  表示该测试点中你的回答中 $x$ 全部正确，你能得到该测试点 $20\\%$ 的分数。\n- $\\text A=3$，表示含义如下：\\\n  $\\text{Partially Correct.}\\texttt{ You pass 70\\% tests!}$\\\n  表示该测试点中你的回答正确的组数**不少于**$\\lfloor0.7\\times T\\rfloor$（$x$ 与乐谱均符合要求），你能得到该测试点 $10\\%$ 的分数。\n- $\\text A=4$，表示该测试点你只能拿到 $0$ 分。\n\n$\\tt Type$ 类表示你的得分情况，$\\text B$ 有以下取值：\n\n- $\\text B=0$，表示你的答案全部正确，与 $\\text A=1$ 配对。\n- $\\text B=1$，表示含义如下：\\\n  $\\text{Wrong Answer.}\\texttt{ The length of your SM is not right!}$\\\n  代表你在一组数据中构造的乐谱的长度不为 $n$。\n- $\\text B=2$，表示含义如下：\\\n  $\\text{Wrong Answer.}\\texttt{ Your Ans is not right!}$\\\n  代表你在一组数据中 $x$ 的值错误。\n- $\\text B=3$，表示含义如下：\\\n  $\\text{Wrong Answer.}\\texttt{ Your Ans and SM are not matched!}$\\\n  代表你在一组数据中构造的乐谱使 Tpes 产生的愤怒值不为 $x$。\n\n这里 $\\text{Ans, SM}$ 分别表示 Answer（$x$ 的值）和 Sheet Music（乐谱）。\n\n注意到 $\\tt Type$ 只会反映你在该测试点中**第一次错误**的类型。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「SvR-2」音符", "background": "", "description": ">本题中「子串」指：\n>\n>若字符串 $s$ 中有一段**连续的**字符构成字符串 $p$，则 $p$ 是 $s$ 的子串。\n\n我们用一个字符串代替一份乐谱，用字符代替每一个音符。\n\n我们定义「重音」表示乐谱中出现了两个**连续**的相同字符，如 $\\tt eeeee$ 中存在 $4$ 个「重音」。\n\n现在 Sept 准备写一份长度为 $n$ 的乐谱给 Tpes 看，他对乐谱的评价标准如下：\n\n- 乐谱中每出现一个「重音」，他的愤怒值就会增加 $a$。\n- 乐谱中每有一段长度为 $k$ 的**子串**中不存在「重音」，他的愤怒值就会增加 $b$。\n\n现在已知 $n,k,a,b$，请你帮 Sept 构造出一份乐谱，使得 Tpes 的愤怒值 $x$ **最小**。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n接下来 $T$ 行，每行两个整数 $n,k,a,b$，意义如题目所述。", "outputFormat": "共 $2 \\cdot T$ 行，对于每组数据都输出两行：\n\n- 第 1 行表示 Tpes 最小的愤怒值 $x$。\n- 第 2 行表示你构造出的乐谱。", "hint": "#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n| $\\bf{Subtask}$ | $\\bm{n\\le}$ | $\\bm{\\sum n\\le}$ | $\\bm{T\\le}$ | $\\bf{Score}$ |\n| :-: | :-: | :-: | :-: | :-: |\n| $\\sf 1$ | $6$ | $10$ | $3$ | $\\tt 10$ |\n| $\\sf 2$ | $10^3$ | $2\\times 10^3$ | 无特殊限制 | $\\tt 30$ |\n| $\\sf 3$ | 无特殊限制 | 无特殊限制 | 无特殊限制 | $\\tt 60$ |\n\n对于 $100\\%$ 的数据，有 $2\\le T\\le 100$，$2\\le n,k\\le 10^5$，$1\\le a,b\\le 10^9$。单组数据内保证 $\\sum n\\le 2\\times 10^5$。\n\n#### 输出注意事项\n\n输出 $x$ 和构造乐谱可以看作是两个子问题，如果你只会完成其中的一个，请在另一个子问题对应的地方用**符合要求的字符或数字**占位。\n\n乐谱中你可以输出任意字符，包括数字、大小写字母等，但**不能出现空格**。\n\n#### Special Judge 返回信息说明\n\n本题采用 Special Judge 判断你的答案是否正确。\n\nchecker.cpp 将会以 $\\texttt{Score=}\\text A,\\texttt{Type=}\\text B$ 的方式返回信息。\n\n$\\tt Score$ 类表示你的得分情况，$\\text A$ 有以下取值：\n\n- $\\text A=1$，表示含义如下：\\\n  $\\text{Accepted.} \\texttt{ Your Ans and SM are both proper.}$\\\n  代表 $T$ 组答案全部符合要求。\n- $\\text A=2$，表示含义如下：\\\n  $\\text{Partially Correct.}\\texttt{ All Ans are right.}$\\\n  表示该测试点中你的回答中 $x$ 全部正确，你能得到该测试点 $20\\%$ 的分数。\n- $\\text A=3$，表示含义如下：\\\n  $\\text{Partially Correct.}\\texttt{ You pass 70\\% tests!}$\\\n  表示该测试点中你的回答正确的组数**不少于**$\\lfloor0.7\\times T\\rfloor$（$x$ 与乐谱均符合要求），你能得到该测试点 $10\\%$ 的分数。\n- $\\text A=4$，表示该测试点你只能拿到 $0$ 分。\n\n$\\tt Type$ 类表示你的得分情况，$\\text B$ 有以下取值：\n\n- $\\text B=0$，表示你的答案全部正确，与 $\\text A=1$ 配对。\n- $\\text B=1$，表示含义如下：\\\n  $\\text{Wrong Answer.}\\texttt{ The length of your SM is not right!}$\\\n  代表你在一组数据中构造的乐谱的长度不为 $n$。\n- $\\text B=2$，表示含义如下：\\\n  $\\text{Wrong Answer.}\\texttt{ Your Ans is not right!}$\\\n  代表你在一组数据中 $x$ 的值错误。\n- $\\text B=3$，表示含义如下：\\\n  $\\text{Wrong Answer.}\\texttt{ Your Ans and SM are not matched!}$\\\n  代表你在一组数据中构造的乐谱使 Tpes 产生的愤怒值不为 $x$。\n\n这里 $\\text{Ans, SM}$ 分别表示 Answer（$x$ 的值）和 Sheet Music（乐谱）。\n\n注意到 $\\tt Type$ 只会反映你在该测试点中**第一次错误**的类型。", "locale": "zh-CN"}}}
{"pid": "P9088", "type": "P", "difficulty": 5, "samples": [["3\n4 1 3 4 7 7 9 10 3\n6 3 6 4 3 4 5 6 6\n6 10 7 1 4 2 6 4 2\n", "31\n23\n19\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2023", "网络流", "洛谷原创", "O2优化", "图论建模", "欧拉回路", "费用流", "洛谷月赛", "Ad-hoc"], "title": "「SvR-2」1+2=3", "background": null, "description": "你有一些木棒，每个木棒左边有一个数，右边有一个数，数只有 $0,1,2$，你要将所有木棒拼起来，使相邻的数和为 $3$ 的对数最大。\n\n例如，$1\\text{ - }2$ 和 $1\\text{ - }0$ 两个木棒，如果按 $1\\text{ - }0,1\\text{ - }2$ 这样拼，相邻的数和为 $3$ 的对数是 $0$；而按 $1\\text{ - }\\textcolor{red}{\\underline{\\textbf 2}},\\textcolor{red}{\\underline{\\textbf 1}}\\text{ - }0$ 这样拼相邻的数和为 $3$ 的对数是 $1$，因为 $2+1=3$。", "inputFormat": "**本题有多组数据。**\n\n输入的第一行一个正整数表示数据组数 $T$。\n\n对于每组数据，一行 $9$ 个非负整数，分别表示 $0\\text{ - }0,0\\text{ - }1,0\\text{ - }2,1\\text{ - }0,1\\text{ - }1,1\\text{ - }2,2\\text{ - }0,2\\text{ - }1,2\\text{ - }2$ 型木棒的个数。", "outputFormat": "$T$ 行，每行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n对于全部数据，保证 $1\\le T\\le 10^5$，记 $a_{i,j}$ 表示 $i\\text-j$ 木棒的个数，保证 $0\\le a_{i,j}\\le 10^9$。\n\n**本题自动开启捆绑测试和 O2 优化。**\n\n记 $sum$ 表示一个测试点中所有数据的所有 $a_{i,j}$ 之和。\n\n| Subtask | $T$ | $sum$ | 特殊性质 |分值 |\n| :------: | :------: | :------: | :------: | :------: |\n| $1$ | $1 \\leq T \\leq 10$ | $1\\le sum\\le 10$ |无| $10 \\operatorname{pts}$ |\n| $2$ | $1 \\leq T \\leq 50$ | $1\\le sum\\le 80$ | 无|$20 \\operatorname{pts}$ |\n| $3$ | 无特殊限制 | 无特殊限制 |A| $15\\operatorname{pts}$ |\n| $4$ | 无特殊限制 | 无特殊限制 |B| $20 \\operatorname{pts}$ |\n| $5$ | $1\\le T\\le 1000$ | 无特殊限制 |C| $20 \\operatorname{pts}$ |\n| $6$ | 无特殊限制 | 无特殊限制 |无| $15 \\operatorname{pts}$ |\n\n特殊性质 A：$a_{i,j}$ 在 $[0,10^9]$ 中均匀随机生成。\n\n特殊性质 B：所有 $a_{i,j}>0$。\n\n特殊性质 C：所有 $a_{i,j}\\le 100$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「SvR-2」1+2=3", "background": null, "description": "你有一些木棒，每个木棒左边有一个数，右边有一个数，数只有 $0,1,2$，你要将所有木棒拼起来，使相邻的数和为 $3$ 的对数最大。\n\n例如，$1\\text{ - }2$ 和 $1\\text{ - }0$ 两个木棒，如果按 $1\\text{ - }0,1\\text{ - }2$ 这样拼，相邻的数和为 $3$ 的对数是 $0$；而按 $1\\text{ - }\\textcolor{red}{\\underline{\\textbf 2}},\\textcolor{red}{\\underline{\\textbf 1}}\\text{ - }0$ 这样拼相邻的数和为 $3$ 的对数是 $1$，因为 $2+1=3$。", "inputFormat": "**本题有多组数据。**\n\n输入的第一行一个正整数表示数据组数 $T$。\n\n对于每组数据，一行 $9$ 个非负整数，分别表示 $0\\text{ - }0,0\\text{ - }1,0\\text{ - }2,1\\text{ - }0,1\\text{ - }1,1\\text{ - }2,2\\text{ - }0,2\\text{ - }1,2\\text{ - }2$ 型木棒的个数。", "outputFormat": "$T$ 行，每行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n对于全部数据，保证 $1\\le T\\le 10^5$，记 $a_{i,j}$ 表示 $i\\text-j$ 木棒的个数，保证 $0\\le a_{i,j}\\le 10^9$。\n\n**本题自动开启捆绑测试和 O2 优化。**\n\n记 $sum$ 表示一个测试点中所有数据的所有 $a_{i,j}$ 之和。\n\n| Subtask | $T$ | $sum$ | 特殊性质 |分值 |\n| :------: | :------: | :------: | :------: | :------: |\n| $1$ | $1 \\leq T \\leq 10$ | $1\\le sum\\le 10$ |无| $10 \\operatorname{pts}$ |\n| $2$ | $1 \\leq T \\leq 50$ | $1\\le sum\\le 80$ | 无|$20 \\operatorname{pts}$ |\n| $3$ | 无特殊限制 | 无特殊限制 |A| $15\\operatorname{pts}$ |\n| $4$ | 无特殊限制 | 无特殊限制 |B| $20 \\operatorname{pts}$ |\n| $5$ | $1\\le T\\le 1000$ | 无特殊限制 |C| $20 \\operatorname{pts}$ |\n| $6$ | 无特殊限制 | 无特殊限制 |无| $15 \\operatorname{pts}$ |\n\n特殊性质 A：$a_{i,j}$ 在 $[0,10^9]$ 中均匀随机生成。\n\n特殊性质 B：所有 $a_{i,j}>0$。\n\n特殊性质 C：所有 $a_{i,j}\\le 100$。", "locale": "zh-CN"}}}
{"pid": "P9089", "type": "P", "difficulty": 5, "samples": [["4\nint\nprintf\nscanf\nntnt", "23"], ["4\nireallywanttobemissjiaransdog\nbutmissjiaransaidthatshelikedcatsandicried\niknowwhyicrywheniamneitheradognoracatbecauseimactuallyamouse\nineverexpectedmissjiarantolikeherselfiunderstandthatallpeopleliketounderstandthecutedogorcatthatyuyuusestomakemoneyandnoonelikesthemousewithwetandwetdiseases", "391"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "二分", "洛谷原创", "后缀自动机 SAM", "O2优化", "哈希 hashing", "AC 自动机", "洛谷月赛"], "title": "「SvR-2」Work", "background": null, "description": "给定 $n$ 个**由小写字母组成**的字符串，定义第 $i$ 个字符串的价值为其有意义的子串的数量（**如果有多个本质相同的子串也统计多次**），第 $i$ 个字符串的一个子串有意义，当且仅当这个子串能被分成若干个串，其中每个串都是这 $n$ 个字符串中任意一个字符串的任意一个后缀。\n\n这里有一个 $n=4$ 的例子：\n```plain\nint\nprintf\nscanf\nntnt\n```\n\n- 对于 `printf` 这个字符串而言，`intf` 是有意义的，因为可以表示成 `int` 和 `f` ，分别是 `int` 和 `scanf` 的后缀，而 `rint` 则不是。\n\n- 对于 `ntnt` 这个字符串而言，`ntnt` 也是有意义的，因为可以表示成 `nt` 和 `nt`，它们都是 `int` 同一个后缀，或者可以表示成 `ntnt`，是 `ntnt` 的一个后缀。\n\n现在，小 Z 想知道这 $n$ 个字符串价值之和。", "inputFormat": "第一行一个整数 $n$。\n\n之后 $n$ 行，每行一个字符串。", "outputFormat": "一行一个整数，表示价值之和。", "hint": "#### 数据规模与约定\n\n**本题开启捆绑测试和 O2 优化。**\n\n令 $s_i$ 表示第 $i$ 个字符串长度。\n| Subtask | 数据范围/特殊性质 | 分值 |\n| :------: | :------: | :------: |\n| $1$ |  $n\\le 3$，$\\sum\\limits \\lvert s_i\\rvert\\le10$| $5 \\operatorname{pts}$ |\n| $2$ | $n=26$，每种字符串均由一种字符组成 | $5 \\operatorname{pts}$ |\n| $3$ |$n=1$ | $15 \\operatorname{pts}$ |\n| $4$ | $\\sum\\limits \\lvert s_i \\rvert \\le 2000$ | $15 \\operatorname{pts}$ |\n| $5$ | $\\sum\\limits \\lvert s_i \\rvert \\le 2\\times10^5$ | $30 \\operatorname{pts}$ |\n| $6$ | $\\sum\\limits \\lvert s_i \\rvert \\le 10^6$ | $30 \\operatorname{pts}$ |\n\n对于 $100\\%$ 的数据，$1\\le n \\le 5\\times10^5$，$n\\le \\sum\\limits \\lvert s_i \\rvert \\le 10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「SvR-2」Work", "background": null, "description": "给定 $n$ 个**由小写字母组成**的字符串，定义第 $i$ 个字符串的价值为其有意义的子串的数量（**如果有多个本质相同的子串也统计多次**），第 $i$ 个字符串的一个子串有意义，当且仅当这个子串能被分成若干个串，其中每个串都是这 $n$ 个字符串中任意一个字符串的任意一个后缀。\n\n这里有一个 $n=4$ 的例子：\n```plain\nint\nprintf\nscanf\nntnt\n```\n\n- 对于 `printf` 这个字符串而言，`intf` 是有意义的，因为可以表示成 `int` 和 `f` ，分别是 `int` 和 `scanf` 的后缀，而 `rint` 则不是。\n\n- 对于 `ntnt` 这个字符串而言，`ntnt` 也是有意义的，因为可以表示成 `nt` 和 `nt`，它们都是 `int` 同一个后缀，或者可以表示成 `ntnt`，是 `ntnt` 的一个后缀。\n\n现在，小 Z 想知道这 $n$ 个字符串价值之和。", "inputFormat": "第一行一个整数 $n$。\n\n之后 $n$ 行，每行一个字符串。", "outputFormat": "一行一个整数，表示价值之和。", "hint": "#### 数据规模与约定\n\n**本题开启捆绑测试和 O2 优化。**\n\n令 $s_i$ 表示第 $i$ 个字符串长度。\n| Subtask | 数据范围/特殊性质 | 分值 |\n| :------: | :------: | :------: |\n| $1$ |  $n\\le 3$，$\\sum\\limits \\lvert s_i\\rvert\\le10$| $5 \\operatorname{pts}$ |\n| $2$ | $n=26$，每种字符串均由一种字符组成 | $5 \\operatorname{pts}$ |\n| $3$ |$n=1$ | $15 \\operatorname{pts}$ |\n| $4$ | $\\sum\\limits \\lvert s_i \\rvert \\le 2000$ | $15 \\operatorname{pts}$ |\n| $5$ | $\\sum\\limits \\lvert s_i \\rvert \\le 2\\times10^5$ | $30 \\operatorname{pts}$ |\n| $6$ | $\\sum\\limits \\lvert s_i \\rvert \\le 10^6$ | $30 \\operatorname{pts}$ |\n\n对于 $100\\%$ 的数据，$1\\le n \\le 5\\times10^5$，$n\\le \\sum\\limits \\lvert s_i \\rvert \\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P9090", "type": "P", "difficulty": 6, "samples": [["5 3\n2 3\n0 4\n5 0\n0 0 \n0 0\n2 5 \n2 1\n1 1", "5\n24\n6"], ["5 1\n2 3\n0 4\n5 0\n0 0 \n0 0\n64 1", "592424678"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "贪心", "洛谷原创", "O2优化", "矩阵加速", "洛谷月赛"], "title": "「SvR-2」G64", "background": "", "description": "定义对于两棵有根二叉树 $T_1,T_2$，$\\operatorname{merge}(T_1,T_2)$ 的结果是一棵二叉树，满足其根节点的左子树为 $T_1$，右子树为 $T_2$，显然 $\\operatorname{merge}(T_1,T_2)$ 的结果唯一且必然存在。\n\n定义对于一棵有根二叉树 $T$，有函数 $G_x(T)$。其中 $G_1(T)$ 表示沿着 $T$ 的根向右儿子走，直到走到某个不存在右儿子的节点，将其右子树变为 $T$，这棵新树即为 $G_1(T)$ ，而当 $x>1$ 时，$G_x(T)$ 满足如下关系：\n\n$$G_x(T)=G_1(\\operatorname{merge}(G_{x-1}(T),G_{x-1}(T)))$$\n\n给一棵 $n$ 个节点的以 $1$ 为根的有根二叉树，记以 $i$ 为根的子树为 $T_i$，$q$ 次询问，每次询问给定 $x,i$，求 $G_x(T_i)$ 的最大独立集。\n", "inputFormat": "第一行两个整数 $n,q$。\n\n之后 $n$ 行，每行两个整数 $ls_i,rs_i$ 表示其左儿子和右儿子，若为 $0$ 则说明没有对应儿子。\n\n之后 $q$ 行，每行两个整数 $x,i$ ，表示一次询问。", "outputFormat": "$q$ 行，每行一个数，表示这次询问的  $G_x(T_i)$ 的最大独立集大小对 $998244353$ 取模的结果。", "hint": "### 样例解释\n\n对于第一组样例，$G_2(T_5)$ 的结果如下图（忽略编号）：\n![](https://cdn.luogu.com.cn/upload/image_hosting/fcjnzc23.png) \n \n\n对于第二组样例，我有一个绝妙的解释，可惜 $G_{64}$ 太大了，这里写不下。\n\n#### 数据规模与约定\n\n**本题开启捆绑测试和 O2 优化。**\n\n| Subtask | 数据范围/特殊性质 | 分值 |\n| :------: | :------: | :------: |\n| $1$ |  $n,q,x\\le 10$| $10 \\operatorname{pts}$ |\n| $2$ | $x =1$ | $5 \\operatorname{pts}$ |\n| $3$ |$x\\le 3$ | $10 \\operatorname{pts}$ |\n| $4$ | $x\\le 10$ | $15 \\operatorname{pts}$ |\n| $5$ | 保证 $T_i$ 大小为 $1$ | $10 \\operatorname{pts}$ |\n| $6$ | 无特殊限制 | $50 \\operatorname{pts}$ |\n\n\n对于 $100\\%$ 的数据，\n$1\\le x\\le 10^9$，$1\\le n\\le 5\\times 10^5$，$1\\le q\\le 5\\times 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「SvR-2」G64", "background": "", "description": "定义对于两棵有根二叉树 $T_1,T_2$，$\\operatorname{merge}(T_1,T_2)$ 的结果是一棵二叉树，满足其根节点的左子树为 $T_1$，右子树为 $T_2$，显然 $\\operatorname{merge}(T_1,T_2)$ 的结果唯一且必然存在。\n\n定义对于一棵有根二叉树 $T$，有函数 $G_x(T)$。其中 $G_1(T)$ 表示沿着 $T$ 的根向右儿子走，直到走到某个不存在右儿子的节点，将其右子树变为 $T$，这棵新树即为 $G_1(T)$ ，而当 $x>1$ 时，$G_x(T)$ 满足如下关系：\n\n$$G_x(T)=G_1(\\operatorname{merge}(G_{x-1}(T),G_{x-1}(T)))$$\n\n给一棵 $n$ 个节点的以 $1$ 为根的有根二叉树，记以 $i$ 为根的子树为 $T_i$，$q$ 次询问，每次询问给定 $x,i$，求 $G_x(T_i)$ 的最大独立集。\n", "inputFormat": "第一行两个整数 $n,q$。\n\n之后 $n$ 行，每行两个整数 $ls_i,rs_i$ 表示其左儿子和右儿子，若为 $0$ 则说明没有对应儿子。\n\n之后 $q$ 行，每行两个整数 $x,i$ ，表示一次询问。", "outputFormat": "$q$ 行，每行一个数，表示这次询问的  $G_x(T_i)$ 的最大独立集大小对 $998244353$ 取模的结果。", "hint": "### 样例解释\n\n对于第一组样例，$G_2(T_5)$ 的结果如下图（忽略编号）：\n![](https://cdn.luogu.com.cn/upload/image_hosting/fcjnzc23.png) \n \n\n对于第二组样例，我有一个绝妙的解释，可惜 $G_{64}$ 太大了，这里写不下。\n\n#### 数据规模与约定\n\n**本题开启捆绑测试和 O2 优化。**\n\n| Subtask | 数据范围/特殊性质 | 分值 |\n| :------: | :------: | :------: |\n| $1$ |  $n,q,x\\le 10$| $10 \\operatorname{pts}$ |\n| $2$ | $x =1$ | $5 \\operatorname{pts}$ |\n| $3$ |$x\\le 3$ | $10 \\operatorname{pts}$ |\n| $4$ | $x\\le 10$ | $15 \\operatorname{pts}$ |\n| $5$ | 保证 $T_i$ 大小为 $1$ | $10 \\operatorname{pts}$ |\n| $6$ | 无特殊限制 | $50 \\operatorname{pts}$ |\n\n\n对于 $100\\%$ 的数据，\n$1\\le x\\le 10^9$，$1\\le n\\le 5\\times 10^5$，$1\\le q\\le 5\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P9091", "type": "P", "difficulty": 7, "samples": [["4 2", "26"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["递推", "2023", "数论", "洛谷原创", "O2优化", "素数判断,质数,筛法", "排列组合", "容斥原理", "洛谷月赛", "根号分治"], "title": "「SvR-2」Let's Meet at a Higher Place", "background": "$$「有朝一日，让我们相逢在更高处！」$$", "description": "构造一个长为 $m$ 的整数序列 $a$，使 $\\forall 1 \\leq i \\leq m$，$a_i \\in [1, n]$。\n\n求出其前缀 $\\gcd$，记为整数序列 $b$。\n\n$f(n, m, k)$ 的值为可以通过如上方式构造出的 $b$ 序列中**相邻项相等的情况出现次数 $\\leq k$** 的**不同**的 $b$ 序列的个数。\n\n给定正整数 $n, m$，小 L 请你帮他求出 $\\displaystyle\\sum_{i = 1}^n \\sum_{j = 1}^m \\sum_{k = 0}^{j - 1} f(\\lfloor \\frac{n}{i} \\rfloor, j, k)$ 的值。\n\n由于结果可能很大，所以你只需要求出结果对 $2^{32}$ 取模的值。", "inputFormat": "一行，两个整数 $n, m$。", "outputFormat": "一行，一个整数，表示所求的值。", "hint": "| $\\bf{Subtask}$ | $n$ | $m$ | 分值 |\n| :------: | :------: | :------: | :------: |\n| $1$ | $1 \\leq n \\leq 10^4$ | 无特殊限制 | $10 \\operatorname{pts}$ |\n| $2$ | $1 \\leq n \\leq 10^6$ | 同上 | $20 \\operatorname{pts}$ |\n| $3$ | $1 \\leq n \\leq 10^9$ | 同上 | $20 \\operatorname{pts}$ |\n| $4$ | 无特殊限制 | $1 \\leq m \\leq 25$ | $20 \\operatorname{pts}$ |\n| $5$ | 同上 | 无特殊限制 | $30 \\operatorname{pts}$ |\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^{10}$，$1 \\leq m \\leq 34$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「SvR-2」Let's Meet at a Higher Place", "background": "$$「有朝一日，让我们相逢在更高处！」$$", "description": "构造一个长为 $m$ 的整数序列 $a$，使 $\\forall 1 \\leq i \\leq m$，$a_i \\in [1, n]$。\n\n求出其前缀 $\\gcd$，记为整数序列 $b$。\n\n$f(n, m, k)$ 的值为可以通过如上方式构造出的 $b$ 序列中**相邻项相等的情况出现次数 $\\leq k$** 的**不同**的 $b$ 序列的个数。\n\n给定正整数 $n, m$，小 L 请你帮他求出 $\\displaystyle\\sum_{i = 1}^n \\sum_{j = 1}^m \\sum_{k = 0}^{j - 1} f(\\lfloor \\frac{n}{i} \\rfloor, j, k)$ 的值。\n\n由于结果可能很大，所以你只需要求出结果对 $2^{32}$ 取模的值。", "inputFormat": "一行，两个整数 $n, m$。", "outputFormat": "一行，一个整数，表示所求的值。", "hint": "| $\\bf{Subtask}$ | $n$ | $m$ | 分值 |\n| :------: | :------: | :------: | :------: |\n| $1$ | $1 \\leq n \\leq 10^4$ | 无特殊限制 | $10 \\operatorname{pts}$ |\n| $2$ | $1 \\leq n \\leq 10^6$ | 同上 | $20 \\operatorname{pts}$ |\n| $3$ | $1 \\leq n \\leq 10^9$ | 同上 | $20 \\operatorname{pts}$ |\n| $4$ | 无特殊限制 | $1 \\leq m \\leq 25$ | $20 \\operatorname{pts}$ |\n| $5$ | 同上 | 无特殊限制 | $30 \\operatorname{pts}$ |\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^{10}$，$1 \\leq m \\leq 34$。", "locale": "zh-CN"}}}
{"pid": "P9092", "type": "P", "difficulty": 5, "samples": [["1 100", "23"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "数位 DP", "PA（波兰）"], "title": "[PA 2020] Liczba Potyczkowa", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda próbna [Liczba Potyczkowa](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/lic/)。**\n\nBajtek 在数学史课上了到解了一位俄罗斯数学家弗拉基米尔·波季奇科夫（Vladimir Potyczkow）。这位科学家以对数字的研究而闻名，为了纪念他，今天我们将这些数称为 **Potyczkow 数**：是一个正整数，并且可以用其十进制表示中出现过的每个数字整除。特别地，这意味着十进制表示中不能有零。例如 $48$、$1$ 和 $112$ 是 Potyczkow 数，而 $23$、$10$ 和 $121$ 不是。Bajtek 想知道在 $[l, r]$ 范围内有多少这样的数，请帮助他数一数！", "inputFormat": "一行输入两个正整数 $l,r$。\n", "outputFormat": "输出一行一个整数，表示在 $[l, r]$ 范围内 Potyczkow 数的数量。", "hint": "#### 样例 1 解释\n\n不超过 $100$ 的 Potyczkow 数有 $1, 2, 3, 4, 5, 6, 7, 8, 9,11,12, 15, 22, 24, 33, 36, 44, 48, 55, 66, 77, 88$ 和 $99$。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于部分子任务，满足 $r-l\\le 10^6$。\n\n对于 $100\\%$ 的数据，保证 $1\\le l\\le r\\le 10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2020] Liczba Potyczkowa", "background": "", "description": "**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda próbna [Liczba Potyczkowa](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/lic/)。**\n\nBajtek 在数学史课上了到解了一位俄罗斯数学家弗拉基米尔·波季奇科夫（Vladimir Potyczkow）。这位科学家以对数字的研究而闻名，为了纪念他，今天我们将这些数称为 **Potyczkow 数**：是一个正整数，并且可以用其十进制表示中出现过的每个数字整除。特别地，这意味着十进制表示中不能有零。例如 $48$、$1$ 和 $112$ 是 Potyczkow 数，而 $23$、$10$ 和 $121$ 不是。Bajtek 想知道在 $[l, r]$ 范围内有多少这样的数，请帮助他数一数！", "inputFormat": "一行输入两个正整数 $l,r$。\n", "outputFormat": "输出一行一个整数，表示在 $[l, r]$ 范围内 Potyczkow 数的数量。", "hint": "#### 样例 1 解释\n\n不超过 $100$ 的 Potyczkow 数有 $1, 2, 3, 4, 5, 6, 7, 8, 9,11,12, 15, 22, 24, 33, 36, 44, 48, 55, 66, 77, 88$ 和 $99$。\n\n------------\n\n#### 数据范围\n\n**本题采用捆绑测试**\n\n对于部分子任务，满足 $r-l\\le 10^6$。\n\n对于 $100\\%$ 的数据，保证 $1\\le l\\le r\\le 10^{18}$。", "locale": "zh-CN"}}}
