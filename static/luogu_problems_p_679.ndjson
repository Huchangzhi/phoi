{"pid": "P14766", "type": "P", "difficulty": 3, "samples": [["5\n0 1 0 0 1\n1 0 2 3 1", "4"], ["2\n3 5\n5 1", "2"], ["3\n0 1 0\n1 0 2", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["图论", "树形数据结构", "并查集", "2024", "ICPC", "首尔"], "title": "[ICPC 2024 Seoul R] Cards Flipping", "background": "", "description": "The magician $ B $ has $ n $ cards in a row on a desk. Each card has two sides with colors. The top side of a card is the side facing upwards. The bottom side of a card is the side facing downwards. Each side of a card has one color. We want to find the maximum number of distinct colors on the top sides. In the following example, we are given 5 cards in a row on a desk. The colors of the top sides of the cards are violet, red, violet, violet, and red from the left to the right as shown in the following figure. The colors of the bottom sides of the cards are red, violet, blue, yellow, and red from the left to the right.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/kcztau6u.png)\n:::\n\nIf we flip a card, then the top side and the bottom side of the card are exchanged. If we flip the $ 3^{rd} $ and the $ 4^{th} $ card from the left, then the colors of the cards on the top sides become like the following.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/ip3frfs6.png)\n:::\n\nThe number of distinct colors on the top sides becomes $ 4 $ which is the maximum for the example.\n\nGiven $ n $ cards placed in a row on a desk and the colors on the sides of cards, write a program to output the maximum number of distinct colors on the top sides.", "inputFormat": "Your program is to read from the standard input. The input starts with a line containing an integer $ n $ ($ 1 \\leq n \\leq 200,000 $), where $ n $ is the number of cards. The cards are numbered from 1 to $ n $. In the following two lines, the first line contains the colors on the top sides of cards from the card 1 to the card $ n $. The second line contains the colors on the bottom sides of cards from the card 1 to the card $ n $. Each color is represented by a nonnegative integer, not exceeding $ 10^6 $.", "outputFormat": "Your program is to write to the standard output. Print exactly one line. The line should contain the maximumnumber of distinct colors on the top sides.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Seoul R] Cards Flipping", "background": "", "description": "The magician $ B $ has $ n $ cards in a row on a desk. Each card has two sides with colors. The top side of a card is the side facing upwards. The bottom side of a card is the side facing downwards. Each side of a card has one color. We want to find the maximum number of distinct colors on the top sides. In the following example, we are given 5 cards in a row on a desk. The colors of the top sides of the cards are violet, red, violet, violet, and red from the left to the right as shown in the following figure. The colors of the bottom sides of the cards are red, violet, blue, yellow, and red from the left to the right.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/kcztau6u.png)\n:::\n\nIf we flip a card, then the top side and the bottom side of the card are exchanged. If we flip the $ 3^{rd} $ and the $ 4^{th} $ card from the left, then the colors of the cards on the top sides become like the following.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/ip3frfs6.png)\n:::\n\nThe number of distinct colors on the top sides becomes $ 4 $ which is the maximum for the example.\n\nGiven $ n $ cards placed in a row on a desk and the colors on the sides of cards, write a program to output the maximum number of distinct colors on the top sides.", "inputFormat": "Your program is to read from the standard input. The input starts with a line containing an integer $ n $ ($ 1 \\leq n \\leq 200,000 $), where $ n $ is the number of cards. The cards are numbered from 1 to $ n $. In the following two lines, the first line contains the colors on the top sides of cards from the card 1 to the card $ n $. The second line contains the colors on the bottom sides of cards from the card 1 to the card $ n $. Each color is represented by a nonnegative integer, not exceeding $ 10^6 $.", "outputFormat": "Your program is to write to the standard output. Print exactly one line. The line should contain the maximumnumber of distinct colors on the top sides.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Seoul R] Cards Flipping", "background": null, "description": "魔术师 B 在桌面上排成一排放置了 $n$ 张卡片。每张卡片的两面都有颜色。卡片的**正面**是朝上的一面。卡片的**背面**是朝下的一面。卡片的每一面都有一种颜色。我们希望找到正面朝上的颜色中，不同颜色的最大数量。在下面的例子中，桌面上依次排开了 5 张卡片。从左到右，卡片正面的颜色分别是紫色、红色、紫色、紫色、红色，如下图所示。从左到右，卡片背面的颜色分别是红色、紫色、蓝色、黄色、红色。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/kcztau6u.png)\n:::\n\n如果我们翻转一张卡片，那么这张卡片的正面和背面就会交换。如果我们翻转从左数的第 $3$ 张和第 $4$ 张卡片，那么卡片正面的颜色会变成下面这样。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/ip3frfs6.png)\n:::\n\n此时正面朝上的不同颜色的数量变成了 $4$，这是这个例子中能得到的最大值。\n\n给定在桌面上排成一排的 $n$ 张卡片以及卡片两面的颜色，请编写一个程序，输出正面朝上的颜色中不同颜色的最大数量。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含一个整数 $n$（$1 \\leq n \\leq 200,000$），其中 $n$ 是卡片的数量。卡片从 $1$ 到 $n$ 编号。接下来的两行中，第一行包含从卡片 $1$ 到卡片 $n$ 的正面颜色。第二行包含从卡片 $1$ 到卡片 $n$ 的背面颜色。每种颜色由一个不超过 $10^{6}$ 的非负整数表示。", "outputFormat": "你的程序需要向标准输出写入结果。输出恰好一行。该行应包含正面朝上的颜色中不同颜色的最大数量。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P14767", "type": "P", "difficulty": 5, "samples": [["5 4\n0 1 0 0 4\n2 0 0 1 3\n3 0 2 0 0\n0 0 0 0 0\n0 2 1 2 0", "1"], ["3 4\n1 2 3\n4 1 2\n3 4 1", "0"], ["4 8\n0 1 2 0\n8 0 0 3\n7 0 0 4\n0 6 5 0", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "ICPC", "首尔"], "title": "[ICPC 2024 Seoul R] Colorful Quadrants", "background": "", "description": "You are given an $ n \\times n $ grid, and some of the grid points are colored by one of the $ k $ colors. The color of a point is represented by an integer from 0 to $ k $, where 0 represents the uncolored case. Note that multiple points may be colored the same. The rows and columns of the grid are denoted by integers from 1 to $ n $, and a point located at row $ i $ and column $ j $ is denoted by $ (i,j) $. For an uncolored point $ (i,j) $ that satisfies $ 1 < i < n $ and $ 1 < j < n $, we define four sub-grids by removing row $ i $ and column $ j $ from the grid. Each of the four sub-grids is called NW (northwest), NE (northeast), SW (southwest), and SE (southeast) based on the position relative to $ (i,j) $. We say that $ (i,j) $ has **colorful quadrants** if, when selecting one point from each of the four sub-grids, the chosen four points are all of different colors.\n\nSee Figure C.1(a) as a $ 5 \\times 5 $ grid example. The point $ (2,3) $ has colorful quadrants because NW has color 1, NE has color 4, SW has color 3, and SE has color 2, as shown in Figure C.1(b). However, the point $ (4,3) $ does not have colorful quadrants because both SW and SE have color 2 only, as shown in Figure C.1(c).\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/cxvgq9w7.png)\n\nFigure C.1\n:::\n\nGiven an $ n \\times n $ grid containing at least four grid points colored in different colors, write a program to count the number of uncolored points that have colorful quadrants.\n", "inputFormat": "Your program is to read from standard input. The input starts with a line containing two integers, $ n $ and $ k $ ($ 3 \\leq n \\leq 2,000 $, $ 4 \\leq k \\leq 1,000 $), where $ n $ is the number of rows and columns of the grid and $ k $ is the number of colors. In the following $ n $ lines, the $ i $-th line contains $ n $ integers that represent the colors of the points $ (i,j) $ for $ 1 \\leq j \\leq n $. The integer $ c $ that represents the color of a point is in range $ 0 \\leq c \\leq k $.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the number of uncolored points that have colorful quadrants.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Seoul R] Colorful Quadrants", "background": "", "description": "You are given an $ n \\times n $ grid, and some of the grid points are colored by one of the $ k $ colors. The color of a point is represented by an integer from 0 to $ k $, where 0 represents the uncolored case. Note that multiple points may be colored the same. The rows and columns of the grid are denoted by integers from 1 to $ n $, and a point located at row $ i $ and column $ j $ is denoted by $ (i,j) $. For an uncolored point $ (i,j) $ that satisfies $ 1 < i < n $ and $ 1 < j < n $, we define four sub-grids by removing row $ i $ and column $ j $ from the grid. Each of the four sub-grids is called NW (northwest), NE (northeast), SW (southwest), and SE (southeast) based on the position relative to $ (i,j) $. We say that $ (i,j) $ has **colorful quadrants** if, when selecting one point from each of the four sub-grids, the chosen four points are all of different colors.\n\nSee Figure C.1(a) as a $ 5 \\times 5 $ grid example. The point $ (2,3) $ has colorful quadrants because NW has color 1, NE has color 4, SW has color 3, and SE has color 2, as shown in Figure C.1(b). However, the point $ (4,3) $ does not have colorful quadrants because both SW and SE have color 2 only, as shown in Figure C.1(c).\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/cxvgq9w7.png)\n\nFigure C.1\n:::\n\nGiven an $ n \\times n $ grid containing at least four grid points colored in different colors, write a program to count the number of uncolored points that have colorful quadrants.\n", "inputFormat": "Your program is to read from standard input. The input starts with a line containing two integers, $ n $ and $ k $ ($ 3 \\leq n \\leq 2,000 $, $ 4 \\leq k \\leq 1,000 $), where $ n $ is the number of rows and columns of the grid and $ k $ is the number of colors. In the following $ n $ lines, the $ i $-th line contains $ n $ integers that represent the colors of the points $ (i,j) $ for $ 1 \\leq j \\leq n $. The integer $ c $ that represents the color of a point is in range $ 0 \\leq c \\leq k $.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the number of uncolored points that have colorful quadrants.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Seoul R] Colorful Quadrants", "background": "", "description": "给定一个 $n \\times n$ 的网格，其中部分网格点被 $k$ 种颜色之一着色。点的颜色用一个 $0$ 到 $k$ 的整数表示，其中 $0$ 表示未着色的情况。注意，多个点可能被涂成相同的颜色。网格的行和列用 $1$ 到 $n$ 的整数表示，位于第 $i$ 行、第 $j$ 列的点记作 $(i,j)$。对于一个满足 $1 < i < n$ 且 $1 < j < n$ 的未着色点 $(i,j)$，我们通过从网格中移除第 $i$ 行和第 $j$ 列，定义四个子网格。这四个子网格根据其相对于 $(i,j)$ 的位置，分别称为 **NW**（西北）、**NE**（东北）、**SW**（西南）和 **SE**（东南）。如果从这四个子网格中各选一个点，所选的四个点颜色各不相同，则称 $(i,j)$ 具有 **多彩象限**。\n\n参见图 C.1(a) 作为一个 $5 \\times 5$ 网格的例子。点 $(2,3)$ 具有多彩象限，因为 NW 子网格有颜色 1，NE 有颜色 4，SW 有颜色 3，SE 有颜色 2，如图 C.1(b) 所示。然而，点 $(4,3)$ 不具有多彩象限，因为 SW 和 SE 子网格都只有颜色 2，如图 C.1(c) 所示。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/cxvgq9w7.png)\n\n图 C.1\n:::\n\n给定一个 $n \\times n$ 的网格，其中至少包含四个被涂上不同颜色的网格点，请编写一个程序，统计具有多彩象限的未着色点的数量。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含两个整数 $n$ 和 $k$ ($3 \\leq n \\leq 2,000$, $4 \\leq k \\leq 1,000$)，其中 $n$ 是网格的行数和列数，$k$ 是颜色的数量。接下来的 $n$ 行中，第 $i$ 行包含 $n$ 个整数，表示点 $(i,j)$ ($1 \\leq j \\leq n$) 的颜色。表示点颜色的整数 $c$ 在 $0 \\leq c \\leq k$ 的范围内。", "outputFormat": "你的程序需要向标准输出写入结果。输出恰好一行。该行应包含具有多彩象限的未着色点的数量。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14768", "type": "P", "difficulty": 6, "samples": [["4 4 3\n3 1\n2 2\n5 2\n6 3\nA 7 1\nA 4 3\nD 3 1", "3\n6\n3"], ["4 5 5\n3 1\n2 2\n5 2\n6 3\n7 1\nD 6 3\nD 7 1\nD 5 2\nD 3 1\nD 2 2", "2\n3\n2\n1\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "ICPC", "首尔"], "title": "[ICPC 2024 Seoul R] Ladder Update", "background": "", "description": "Ladder game is a popular game in Korea, as well as China and Japan. Wikipedia says that “It is known in Korean as Sadaritagi (사다리타기, literally \"ladder climbing\"), in Japanese as Amidakuji (阿弥陀籤, \"Amida lottery\"), and in Chinese as Guijiaotu (鬼腳圖, literally \"ghost leg diagram\").”\n\nThe diagram where the game is played consists of $ n $ vertical lines with horizontal line segments connecting two adjacent vertical lines. The horizontal line segments are called **legs**. Each vertical line has a starting (upper) point and an end (lower) point. The basic rule of this game is simple as follows:\n\n- Start from the starting point of each vertical line and move downward along the vertical line. When encountering a leg, move along the leg to the adjacent vertical line, and continue downwards until reaching the end of a vertical line.\n\nThe vertical lines are numbered from 1 to $ n $ from left to right. It is well known that the game result is a permutation of $ [1,2,...,n] $. For example, given a diagram with 4 vertical lines and 5 legs shown below, the game result is $ [2,3,4,1] $ from left to right.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/p3meeq2o.png)\n:::\n\nHowever, some legs are redundant, meaning that the same result $ [2,3,4,1] $ can be achieved with fewer legs; as in the figure below, one can obtain the same result only with three legs excluding topmost and bottommost ones. We want to determine the minimum number of horizontal line segments (legs) needed to achieve the same result. Note that it is possible to draw new legs than the given ones if necessary.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/exn1u264.png)\n:::\n\nYou are given $ q $ queries, where each query either adds a new leg or deletes an existing one. Write a program to output the minimum number of legs required to achieve the same game result of the ladder structure obtained after the query is processed. Note that each query is cumulative, meaning each subsequent query is applied to the ladder structure resulting from previous queries.\n", "inputFormat": "Your program is to read from standard input. The input starts with a line containing three integers $ n $, the number of vertical lines, $ m $, the initial number of legs, and $ q $, the number of queries, separated by a space where $ 2 \\leq n \\leq 100,000 $, $ 1 \\leq m \\leq 100,000 $, and $ 1 \\leq q \\leq 100,000 $.\n\nIn the following $ m $ lines, each line contains two positive integers $ h $ and $ a $, representing a leg at height $ h $ connecting the $ a $-th and $ (a+1) $-th vertical lines ($ 1 \\leq a \\leq n-1 $). The vertical lines are ordered from left to right, and the height is numbered from top to bottom starting with 1. The height is no more than $ 10^9 $.\n\nThe next $ q $ lines contain the query information. Each query is either in the form of $ A\\ h\\ a $ or $ D\\ h\\ a $, where $ 1 \\leq h \\leq 10^9 $, $ 1 \\leq a \\leq n-1 $.\n\n- $ A\\ h\\ a $: add a leg at height $ h $ between the $ a $-th and $ (a+1) $-th vertical lines.\n- $ D\\ h\\ a $: delete the leg at height $ h $ between the $ a $-th and $ (a+1) $-th vertical lines.\n\nYou can assume that there are no contradictory operations, that is, existing legs will not be added, and non-existing legs will not be deleted. Also, you can assume that no two legs are positioned such that they share the endpoint of the same height and the same vertical line.\n", "outputFormat": "Your program is to write to standard output. The output consists of $ q $ lines and each line contains the minimum number of legs required to achieve the same result for a query in the input order.", "hint": "**Explanation for Sample Input 1:**\n\nThe sample input 1 gives the initial ladder structure below. The game result is $ [3,2,4,1] $.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/dpmsdc91.png)\n:::\n\nAfter applying the first query $ A\\ 7\\ 1 $ in the figure blow, the ladder structure is changed, then the game result becomes $ [2,3,4,1] $.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/5fbz7is2.png)\n:::\n\nAmong the five legs, only three legs (without topmost and bottommost legs) are enough to achieve the same game result $ [2,3,4,1] $ as shown in figure below, so the answer for the first query is 3.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/bqbrnq9k.png)\n:::\n\nAfter processing the second query $ A\\ 4\\ 3 $, the ladder structure is changed as shown below. The number of legs cannot be further reduced. The answer for the second query is 6.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/o8ywi5bk.png)\n:::\n\nAfter applying the third query $ D\\ 3\\ 1 $, the ladder structure is changed as shown below.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/pox1jnce.png)\n:::\n\nThe ladder structure with three legs as shown below guarantees the same game result, so the answer for the third query is 3.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mrevftgt.png)\n:::", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Seoul R] Ladder Update", "background": "", "description": "Ladder game is a popular game in Korea, as well as China and Japan. Wikipedia says that “It is known in Korean as Sadaritagi (사다리타기, literally \"ladder climbing\"), in Japanese as Amidakuji (阿弥陀籤, \"Amida lottery\"), and in Chinese as Guijiaotu (鬼腳圖, literally \"ghost leg diagram\").”\n\nThe diagram where the game is played consists of $ n $ vertical lines with horizontal line segments connecting two adjacent vertical lines. The horizontal line segments are called **legs**. Each vertical line has a starting (upper) point and an end (lower) point. The basic rule of this game is simple as follows:\n\n- Start from the starting point of each vertical line and move downward along the vertical line. When encountering a leg, move along the leg to the adjacent vertical line, and continue downwards until reaching the end of a vertical line.\n\nThe vertical lines are numbered from 1 to $ n $ from left to right. It is well known that the game result is a permutation of $ [1,2,...,n] $. For example, given a diagram with 4 vertical lines and 5 legs shown below, the game result is $ [2,3,4,1] $ from left to right.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/p3meeq2o.png)\n:::\n\nHowever, some legs are redundant, meaning that the same result $ [2,3,4,1] $ can be achieved with fewer legs; as in the figure below, one can obtain the same result only with three legs excluding topmost and bottommost ones. We want to determine the minimum number of horizontal line segments (legs) needed to achieve the same result. Note that it is possible to draw new legs than the given ones if necessary.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/exn1u264.png)\n:::\n\nYou are given $ q $ queries, where each query either adds a new leg or deletes an existing one. Write a program to output the minimum number of legs required to achieve the same game result of the ladder structure obtained after the query is processed. Note that each query is cumulative, meaning each subsequent query is applied to the ladder structure resulting from previous queries.\n", "inputFormat": "Your program is to read from standard input. The input starts with a line containing three integers $ n $, the number of vertical lines, $ m $, the initial number of legs, and $ q $, the number of queries, separated by a space where $ 2 \\leq n \\leq 100,000 $, $ 1 \\leq m \\leq 100,000 $, and $ 1 \\leq q \\leq 100,000 $.\n\nIn the following $ m $ lines, each line contains two positive integers $ h $ and $ a $, representing a leg at height $ h $ connecting the $ a $-th and $ (a+1) $-th vertical lines ($ 1 \\leq a \\leq n-1 $). The vertical lines are ordered from left to right, and the height is numbered from top to bottom starting with 1. The height is no more than $ 10^9 $.\n\nThe next $ q $ lines contain the query information. Each query is either in the form of $ A\\ h\\ a $ or $ D\\ h\\ a $, where $ 1 \\leq h \\leq 10^9 $, $ 1 \\leq a \\leq n-1 $.\n\n- $ A\\ h\\ a $: add a leg at height $ h $ between the $ a $-th and $ (a+1) $-th vertical lines.\n- $ D\\ h\\ a $: delete the leg at height $ h $ between the $ a $-th and $ (a+1) $-th vertical lines.\n\nYou can assume that there are no contradictory operations, that is, existing legs will not be added, and non-existing legs will not be deleted. Also, you can assume that no two legs are positioned such that they share the endpoint of the same height and the same vertical line.\n", "outputFormat": "Your program is to write to standard output. The output consists of $ q $ lines and each line contains the minimum number of legs required to achieve the same result for a query in the input order.", "hint": "**Explanation for Sample Input 1:**\n\nThe sample input 1 gives the initial ladder structure below. The game result is $ [3,2,4,1] $.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/dpmsdc91.png)\n:::\n\nAfter applying the first query $ A\\ 7\\ 1 $ in the figure blow, the ladder structure is changed, then the game result becomes $ [2,3,4,1] $.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/5fbz7is2.png)\n:::\n\nAmong the five legs, only three legs (without topmost and bottommost legs) are enough to achieve the same game result $ [2,3,4,1] $ as shown in figure below, so the answer for the first query is 3.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/bqbrnq9k.png)\n:::\n\nAfter processing the second query $ A\\ 4\\ 3 $, the ladder structure is changed as shown below. The number of legs cannot be further reduced. The answer for the second query is 6.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/o8ywi5bk.png)\n:::\n\nAfter applying the third query $ D\\ 3\\ 1 $, the ladder structure is changed as shown below.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/pox1jnce.png)\n:::\n\nThe ladder structure with three legs as shown below guarantees the same game result, so the answer for the third query is 3.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mrevftgt.png)\n:::", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Seoul R] Ladder Update", "background": "", "description": "梯子游戏是韩国、中国和日本流行的一种游戏。维基百科称：“它在韩语中被称为 Sadaritagi (사다리타기，字面意思是‘爬梯子’)，在日语中被称为 Amidakuji (阿弥陀籤，意为‘阿弥陀佛抽签’)，在中文中被称为 Guijiaotu (鬼腳圖，字面意思是‘鬼脚图’)。”\n\n进行游戏的图由 $n$ 条垂直线组成，相邻垂直线之间由水平线段连接。这些水平线段被称为 **横档**。每条垂直线都有一个起点（上端）和一个终点（下端）。该游戏的基本规则如下：\n\n- 从每条垂直线的起点开始，沿垂直线向下移动。当遇到横档时，沿横档移动到相邻的垂直线，然后继续向下移动，直到到达垂直线的终点。\n\n垂直线从左到右编号为 $1$ 到 $n$。众所周知，游戏结果是 $[1,2,...,n]$ 的一个排列。例如，给定一个有 $4$ 条垂直线和 $5$ 个横档的图（如下所示），从左到右的游戏结果是 $[2,3,4,1]$。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/p3meeq2o.png)\n:::\n\n然而，有些横档是冗余的，这意味着可以用更少的横档实现相同的结果 $[2,3,4,1]$；如下图所示，只需三个横档（不包括最顶部和最底部的横档）即可获得相同结果。我们希望确定实现相同结果所需的最小水平线段（横档）数量。请注意，如果需要，可以绘制新的横档，而非仅限于给定的那些。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/exn1u264.png)\n:::\n\n你将收到 $q$ 个查询，每个查询要么添加一个新横档，要么删除一个现有横档。请编写一个程序，在处理查询后，输出实现梯子结构相同游戏结果所需的最少横档数量。注意，每个查询是累积的，即每个后续查询都应用于先前查询产生的梯子结构。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含三个整数 $n$（垂直线的数量）、$m$（初始横档数量）和 $q$（查询数量），用一个空格分隔，其中 $2 \\leq n \\leq 100,000$，$1 \\leq m \\leq 100,000$，$1 \\leq q \\leq 100,000$。\n\n接下来的 $m$ 行，每行包含两个正整数 $h$ 和 $a$，表示在高度 $h$ 处连接第 $a$ 条和第 $a+1$ 条垂直线的一个横档 ($1 \\leq a \\leq n-1$)。垂直线从左到右排序，高度从上到下编号，从 $1$ 开始。高度不超过 $10^9$。\n\n接下来的 $q$ 行包含查询信息。每个查询的形式为 $A\\ h\\ a$ 或 $D\\ h\\ a$，其中 $1 \\leq h \\leq 10^9$，$1 \\leq a \\leq n-1$。\n\n- $A\\ h\\ a$：在高度 $h$ 处添加一个连接第 $a$ 条和第 $a+1$ 条垂直线的横档。\n- $D\\ h\\ a$：删除在高度 $h$ 处连接第 $a$ 条和第 $a+1$ 条垂直线的横档。\n\n你可以假设没有矛盾的操作，即不会添加已存在的横档，也不会删除不存在的横档。同时，可以假设没有两个横档的位置使得它们在相同高度和相同垂直线共享端点。", "outputFormat": "你的程序需要向标准输出写入结果。输出包含 $q$ 行，每行包含按输入顺序对应查询所需的实现相同结果的最少横档数量。\n", "hint": "**样例 1 解释：**\n\n样例输入 1 给出了初始的梯子结构，如下图所示。游戏结果为 $[3,2,4,1]$。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/dpmsdc91.png)\n:::\n\n应用第一个查询 $A\\ 7\\ 1$ 后（如下图所示），梯子结构发生改变，此时游戏结果变为 $[2,3,4,1]$。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/5fbz7is2.png)\n:::\n\n在五个横档中，只需三个横档（不包括最顶部和最底部的横档）即可实现相同的游戏结果 $[2,3,4,1]$，如下图所示，因此第一个查询的答案是 3。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/bqbrnq9k.png)\n:::\n\n处理第二个查询 $A\\ 4\\ 3$ 后，梯子结构改变，如下图所示。横档数量无法进一步减少。第二个查询的答案是 6。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/o8ywi5bk.png)\n:::\n\n应用第三个查询 $D\\ 3\\ 1$ 后，梯子结构改变，如下图所示。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/pox1jnce.png)\n:::\n\n如下图所示，具有三个横档的梯子结构可以保证相同的游戏结果，因此第三个查询的答案是 3。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mrevftgt.png)\n:::\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14769", "type": "P", "difficulty": 6, "samples": [["12\n0 5 2 8 5 3 7 6 11 4 13 0\n11 8 3 3", "10.077687"], ["8\n0 7 2 2 5 7 7 0\n-2 4 6 4", "11.767829"], ["4\n0 5 8 0\n8 6 4 2", "6.0"]], "limits": {"time": [300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "Special Judge", "ICPC", "首尔"], "title": "[ICPC 2024 Seoul R] Mausoleum", "background": "", "description": "The Mausoleum of King Geo III is a huge stone structure in the shape of a histogram. A histogram is a simple rectilinear polygon whose boundary consists of two chains: an upper chain that is monotone with respect to the horizontal axis, and a lower chain that is a horizontal line segment, called the base segment (see Figure E.1).\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/500onkm4.png)\n:::\n\nIt is rumored that a hidden treasure lies somewhere within this mausoleum. Metry, a renowned treasure hunter, has uncovered the treasure's location at point $ T $. Metry's plan is to break through the mausoleum's walls, enter, and retrieve the treasure. She will start at a specific location $ S $ outside the mausoleum. Using her equipment, Metry can drill through only one point, which corresponds to a vertex on the boundary of the mausoleum. Since the time required to drill through the walls is the same at all vertices, the key to minimizing the time spent is to find the shortest path from $ S $ to $ T $.\n\nFigure E.1 illustrates a mausoleum along with several possible paths from $ S $ to $ T $, where the vertices are pierced only once. The path through vertex $ a $ has a total length of $ 11.385165 = 6 + \\sqrt{29} $, the path through vertex $ b $ has a length of $ 10.077687 = \\sqrt{20} + \\sqrt{13} + 2 $, and the path through vertex $ c $ has a length of $ 11.0 = 2 + \\sqrt{25} + 4 $. Among these, the shortest path is through vertex $ b $.\n\nGiven the boundary of the mausoleum and the positions of $ S $ and $ T $, write a program to find the length of the shortest path from $ S $ to $ T $ with a single vertex piercing.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing an integer, $ n $ ($ 4 \\leq n \\leq 100,000 $), where $ n $ is even and is the number of vertices of a histogram representing the mausoleum. In the second line, $ n $ integers $ v_1, v_2, \\ldots, v_n $ ($ v_1 = v_n = 0 $, $ 0 \\leq v_i \\leq 10^6 $) are given, which represent the x-coordinates of the vertical edges and the y-coordinates of the horizontal edges. The vertical and horizontal edges alternate as you traverse the upper chain of the histogram, from the left end to the right end of the base segment. The length of each edge is at least 1, and the x-coordinates are given in strictly increasing order. The last line contains four integers $ s_x, s_y, t_x, $ and $ t_y $ ($ -10^6 \\leq s_x, s_y \\leq 2 \\times 10^6 $, $ 0 < t_x, t_y < 10^6 $), where $ (s_x, s_y) $ and $ (t_x, t_y) $ correspond to the points $ S $ and $ T $, respectively. Notice that $ S $ is a point outside the histogram and $ T $ is a point inside the histogram, neither of which lies on the boundary.", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain exactly one real value which is the length of the shortest path between $ S $ and $ T $. Your output $ z $ should be in the format that consists of its integer part, a decimal point, and its fractional part, and will be decided to be \"correct\" if it holds that $ a - 10^{-3} < z < a + 10^{-3} $, where $ a $ denotes the jury's answer. The Euclidean distance between two points $ p = (x_1, y_1) $ and $ q = (x_2, y_2) $ is $ \\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2} $.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Seoul R] Mausoleum", "background": "", "description": "The Mausoleum of King Geo III is a huge stone structure in the shape of a histogram. A histogram is a simple rectilinear polygon whose boundary consists of two chains: an upper chain that is monotone with respect to the horizontal axis, and a lower chain that is a horizontal line segment, called the base segment (see Figure E.1).\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/500onkm4.png)\n:::\n\nIt is rumored that a hidden treasure lies somewhere within this mausoleum. Metry, a renowned treasure hunter, has uncovered the treasure's location at point $ T $. Metry's plan is to break through the mausoleum's walls, enter, and retrieve the treasure. She will start at a specific location $ S $ outside the mausoleum. Using her equipment, Metry can drill through only one point, which corresponds to a vertex on the boundary of the mausoleum. Since the time required to drill through the walls is the same at all vertices, the key to minimizing the time spent is to find the shortest path from $ S $ to $ T $.\n\nFigure E.1 illustrates a mausoleum along with several possible paths from $ S $ to $ T $, where the vertices are pierced only once. The path through vertex $ a $ has a total length of $ 11.385165 = 6 + \\sqrt{29} $, the path through vertex $ b $ has a length of $ 10.077687 = \\sqrt{20} + \\sqrt{13} + 2 $, and the path through vertex $ c $ has a length of $ 11.0 = 2 + \\sqrt{25} + 4 $. Among these, the shortest path is through vertex $ b $.\n\nGiven the boundary of the mausoleum and the positions of $ S $ and $ T $, write a program to find the length of the shortest path from $ S $ to $ T $ with a single vertex piercing.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing an integer, $ n $ ($ 4 \\leq n \\leq 100,000 $), where $ n $ is even and is the number of vertices of a histogram representing the mausoleum. In the second line, $ n $ integers $ v_1, v_2, \\ldots, v_n $ ($ v_1 = v_n = 0 $, $ 0 \\leq v_i \\leq 10^6 $) are given, which represent the x-coordinates of the vertical edges and the y-coordinates of the horizontal edges. The vertical and horizontal edges alternate as you traverse the upper chain of the histogram, from the left end to the right end of the base segment. The length of each edge is at least 1, and the x-coordinates are given in strictly increasing order. The last line contains four integers $ s_x, s_y, t_x, $ and $ t_y $ ($ -10^6 \\leq s_x, s_y \\leq 2 \\times 10^6 $, $ 0 < t_x, t_y < 10^6 $), where $ (s_x, s_y) $ and $ (t_x, t_y) $ correspond to the points $ S $ and $ T $, respectively. Notice that $ S $ is a point outside the histogram and $ T $ is a point inside the histogram, neither of which lies on the boundary.", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain exactly one real value which is the length of the shortest path between $ S $ and $ T $. Your output $ z $ should be in the format that consists of its integer part, a decimal point, and its fractional part, and will be decided to be \"correct\" if it holds that $ a - 10^{-3} < z < a + 10^{-3} $, where $ a $ denotes the jury's answer. The Euclidean distance between two points $ p = (x_1, y_1) $ and $ q = (x_2, y_2) $ is $ \\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2} $.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Seoul R] Mausoleum", "background": "", "description": "乔三世国王陵墓是一座巨大的石头建筑，呈直方图形状。直方图是一个简单的直边多边形，其边界由两条链组成：一条是相对于水平轴单调的**上链**，另一条是水平线段的**下链**，称为基线段（见图 E.1）。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/500onkm4.png)\n:::\n\n传闻有一处隐藏的宝藏位于这座陵墓内的某个地方。著名的宝藏猎人梅特里发现了宝藏位于点 $T$。梅特里的计划是凿穿陵墓的墙壁，进入内部并取回宝藏。她将从陵墓外的一个特定位置 $S$ 开始。利用她的设备，梅特里只能凿穿一个点，该点对应于陵墓边界上的一个顶点。由于在所有顶点凿穿墙壁所需的时间相同，因此最小化所用时间的关键在于找到从 $S$ 到 $T$ 的最短路径。\n\n图 E.1 展示了一座陵墓以及从 $S$ 到 $T$ 的几条可能路径，这些路径只穿过一个顶点。穿过顶点 $a$ 的路径总长度为 $11.385165 = 6 + \\sqrt{29}$，穿过顶点 $b$ 的路径长度为 $10.077687 = \\sqrt{20} + \\sqrt{13} + 2$，穿过顶点 $c$ 的路径长度为 $11.0 = 2 + \\sqrt{25} + 4$。其中，最短路径是穿过顶点 $b$ 的路径。\n\n给定陵墓的边界以及 $S$ 和 $T$ 的位置，请编写一个程序，找到从 $S$ 到 $T$ 且仅穿过一个顶点的最短路径的长度。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含一个整数 $n$ ($4 \\leq n \\leq 100,000$)，其中 $n$ 为偶数，表示代表陵墓的直方图的顶点数。第二行给出 $n$ 个整数 $v_1, v_2, \\ldots, v_n$ ($v_1 = v_n = 0$, $0 \\leq v_i \\leq 10^6$)，它们表示垂直边的 x 坐标和水平边的 y 坐标。沿着直方图的上链，从基线段的左端到右端，垂直边和水平边交替出现。每条边的长度至少为 $1$，且 x 坐标按严格递增的顺序给出。最后一行包含四个整数 $s_x, s_y, t_x, t_y$ ($-10^6 \\leq s_x, s_y \\leq 2 \\times 10^6$, $0 < t_x, t_y < 10^6$)，其中 $(s_x, s_y)$ 和 $(t_x, t_y)$ 分别对应点 $S$ 和 $T$。注意 $S$ 是直方图外部的一个点，$T$ 是直方图内部的一个点，两者均不位于边界上。", "outputFormat": "你的程序需要向标准输出写入结果。输出恰好一行。该行应包含一个实数值，即从 $S$ 到 $T$ 的最短路径的长度。你的输出 $z$ 应采用整数部分、小数点和小数部分的格式，并且如果满足 $a - 10^{-3} < z < a + 10^{-3}$，则被认为是“正确的”，其中 $a$ 表示出题人的答案。两点 $p = (x_1, y_1)$ 和 $q = (x_2, y_2)$ 之间的欧几里得距离为 $\\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}$。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14770", "type": "P", "difficulty": 4, "samples": [["3", "6\n1 3 2\n2 3 1\n1 2 1\n1 3 2\n2 3 1\n1 2 1"], ["3", "5\n1 3 2\n2 3 1\n1 3 1\n2 3 1\n1 2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "Special Judge", "ICPC", "首尔"], "title": "[ICPC 2024 Seoul R] Pair Sorting", "background": "", "description": "There are $ n $ bins arranged in a row and $ 2n $ balls on the ground. The balls are numbered from 1 to $ n $ and there are exactly two balls numbered $ i $, for each $ i $, $ 1 \\leq i \\leq n $. Also, for $ 1 \\leq i \\leq n $, the $ i $-th bin is denoted by $ B_i $ and each bin $ B_i $ can contain at most two balls. Initially, the bin $ B_i $ contains both of ball $ n+1-i $'s, for $ 1 \\leq i \\leq n $. See the Figure F.1 below for the initial configuration of bins.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/ts3inbbb.png)\n\nFigure F.1. The initial configuration of bins\n:::\n\nYou can swap two balls only from adjacent bins, which implies one swap operation. Note the bin is not a stack and for adjacent bins $ B_i $ and $ B_{i+1} $, you can swap the one of two balls in $ B_i $ and the one in $ B_{i+1} $. See the Figure F.2 below. The figure represents two swap operations.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/wjn92uxb.png)\n\nFigure F.2. The swap operations between adjacent bins\n:::\n\nThrough these swap operations, you should sort the balls. As a result of the sorting, the bin $ B_i $ must contain the both of ball $ i $'s, for $ 1 \\leq i \\leq n $. In particular, the total number of swap operations should be no more than $ \\text{Bound} $, when $ \\text{Bound} $ is given as a function of $ n $, especially, $ \\text{Bound} = 0.7n^2 $.\n\nGiven $ n $ bins and $ 2n $ balls, write a program to find a sorting method of balls such that the total number of swap operations is no more than $ \\text{Bound} = 0.7n^2 $.", "inputFormat": "Your program is to read from standard input. The input consists of exactly one line. The line contains an integer $ n $ ($ 3 \\leq n \\leq 100 $), representing that there are $ n $ bins and $ 2n $ balls.", "outputFormat": "Your program is to write to standard output. Let $ S $ be the total number of swap operations in your sorting method for the input. Print exactly $ S+1 $ lines. The first line contains $ S $. Each of the following $ S $ lines contains three integers $ j, a, $ and $ b $, representing one swap operation between the ball $ a $ in the bin $ B_j $ and the ball $ b $ in $ B_{j+1} $, where $ 1 \\leq j \\leq n-1 $ and $ 1 \\leq a, b \\leq n $. The swap operations in your sorting method should be printed in order, one per line. The number $ S $ must satisfy that $ S \\leq 0.7n^2 $.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Seoul R] Pair Sorting", "background": "", "description": "There are $ n $ bins arranged in a row and $ 2n $ balls on the ground. The balls are numbered from 1 to $ n $ and there are exactly two balls numbered $ i $, for each $ i $, $ 1 \\leq i \\leq n $. Also, for $ 1 \\leq i \\leq n $, the $ i $-th bin is denoted by $ B_i $ and each bin $ B_i $ can contain at most two balls. Initially, the bin $ B_i $ contains both of ball $ n+1-i $'s, for $ 1 \\leq i \\leq n $. See the Figure F.1 below for the initial configuration of bins.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/ts3inbbb.png)\n\nFigure F.1. The initial configuration of bins\n:::\n\nYou can swap two balls only from adjacent bins, which implies one swap operation. Note the bin is not a stack and for adjacent bins $ B_i $ and $ B_{i+1} $, you can swap the one of two balls in $ B_i $ and the one in $ B_{i+1} $. See the Figure F.2 below. The figure represents two swap operations.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/wjn92uxb.png)\n\nFigure F.2. The swap operations between adjacent bins\n:::\n\nThrough these swap operations, you should sort the balls. As a result of the sorting, the bin $ B_i $ must contain the both of ball $ i $'s, for $ 1 \\leq i \\leq n $. In particular, the total number of swap operations should be no more than $ \\text{Bound} $, when $ \\text{Bound} $ is given as a function of $ n $, especially, $ \\text{Bound} = 0.7n^2 $.\n\nGiven $ n $ bins and $ 2n $ balls, write a program to find a sorting method of balls such that the total number of swap operations is no more than $ \\text{Bound} = 0.7n^2 $.", "inputFormat": "Your program is to read from standard input. The input consists of exactly one line. The line contains an integer $ n $ ($ 3 \\leq n \\leq 100 $), representing that there are $ n $ bins and $ 2n $ balls.", "outputFormat": "Your program is to write to standard output. Let $ S $ be the total number of swap operations in your sorting method for the input. Print exactly $ S+1 $ lines. The first line contains $ S $. Each of the following $ S $ lines contains three integers $ j, a, $ and $ b $, representing one swap operation between the ball $ a $ in the bin $ B_j $ and the ball $ b $ in $ B_{j+1} $, where $ 1 \\leq j \\leq n-1 $ and $ 1 \\leq a, b \\leq n $. The swap operations in your sorting method should be printed in order, one per line. The number $ S $ must satisfy that $ S \\leq 0.7n^2 $.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Seoul R] Pair Sorting", "background": "", "description": "有 $n$ 个箱子排成一行，地上有 $2n$ 个球。球的编号从 $1$ 到 $n$，对于每个 $i$ ($1 \\leq i \\leq n$)，恰好有两个编号为 $i$ 的球。此外，对于 $1 \\leq i \\leq n$，第 $i$ 个箱子记为 $B_i$，每个箱子 $B_i$ 最多可以容纳两个球。初始时，对于 $1 \\leq i \\leq n$，箱子 $B_i$ 中包含两个编号为 $n+1-i$ 的球。初始的箱子配置参见下面的图 F.1。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/ts3inbbb.png)\n\n图 F.1. 箱子的初始配置\n:::\n\n你只能交换相邻两个箱子中的球，这代表一次**交换操作**。请注意，箱子不是栈，对于相邻的箱子 $B_i$ 和 $B_{i+1}$，你可以交换 $B_i$ 中两个球中的一个与 $B_{i+1}$ 中的一个球。参见下面的图 F.2。该图展示了两次交换操作。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/wjn92uxb.png)\n\n图 F.2. 相邻箱子之间的交换操作\n:::\n\n通过这些交换操作，你需要对球进行排序。排序完成后，对于 $1 \\leq i \\leq n$，箱子 $B_i$ 必须包含两个编号为 $i$ 的球。特别地，当给定一个关于 $n$ 的函数 $\\text{Bound}$ 时（尤其是 $\\text{Bound} = 0.7n^2$），交换操作的总数不应超过 $\\text{Bound}$。\n\n给定 $n$ 个箱子和 $2n$ 个球，请编写一个程序，找到一种球的排序方法，使得交换操作的总数不超过 $\\text{Bound} = 0.7n^2$。", "inputFormat": "你的程序需要从标准输入读取数据。输入恰好包含一行。该行包含一个整数 $n$ ($3 \\leq n \\leq 100$)，表示有 $n$ 个箱子和 $2n$ 个球。", "outputFormat": "你的程序需要向标准输出写入结果。令 $S$ 为你的排序方法中交换操作的总数。输出恰好 $S+1$ 行。第一行包含 $S$。接下来的 $S$ 行，每行包含三个整数 $j, a, b$，表示一次交换操作：交换箱子 $B_j$ 中的球 $a$ 与箱子 $B_{j+1}$ 中的球 $b$，其中 $1 \\leq j \\leq n-1$，$1 \\leq a, b \\leq n$。你的排序方法中的交换操作应按顺序逐行打印。数字 $S$ 必须满足 $S \\leq 0.7n^2$。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14771", "type": "P", "difficulty": 7, "samples": [["6\nabaaca", "2"], ["5\nacaba", "3"], ["5\nabcde", "5"], ["5\nradar", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "回文自动机 PAM", "ICPC", "首尔"], "title": "[ICPC 2024 Seoul R] Palindromic Length", "background": null, "description": "A string is called a **palindrome** if it is read the same forward and backward. Palindromes are useful factors for measuring the complexity of strings like the asymmetry of the strings. The asymmetry of a string $ S $ of length $ n $ can be measured by its **palindromic length**, $ \\text{PL}(S) $, which is the minimum number of palindromic substrings into which $ S $ can be partitioned. More precisely, $ \\text{PL}(S) $ is the minimum number $ t $ ($ 1 \\leq t \\leq n $) such that there exist palindromic substrings $ S_1, S_2, \\dots, S_t $ whose concatenation $ S_1S_2 \\cdots S_t $ becomes $ S $. To make it easier to distinguish, we denote a partition of $ S $ into $ S_1, S_2, \\dots, S_t $ as $ S_1 \\mid S_2 \\mid \\cdots \\mid S_t $.\n\nFor example, a string $ S = \\text{abaaca} $ can be partitioned into two palindromic substrings as $ \\text{aba} \\mid \\text{aca} $, that is the minimum, so $ \\text{PL}(\\text{abaaca}) = 2 $. A string $ \\text{acaba} $ cannot be partitioned into two palindromic substrings, but it can be partitioned into three palindromic substrings, $ S = \\text{aca} \\mid \\text{b} \\mid \\text{a} $ or $ S = \\text{a} \\mid \\text{c} \\mid \\text{aba} $, so $ \\text{PL}(\\text{acaba}) = 3 $. For $ S = \\text{radar} $, $ \\text{PL}(S) = 1 $ because $ S $ is a palindrome. $ \\text{PL}(S) = 5 $ for $ S = \\text{abcde} $.\n\nGiven a non-empty string $ S $ of English lowercase letters, write a program to output $ \\text{PL}(S) $.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing a positive integer $ n $ ($ 1 \\leq n \\leq 100,000 $), where $ n $ is the number of letters of a string. The next line contains a string of $ n $ English lowercase letters. Note that the string contains no space between the letters.", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain a positive integer which is the palindromic length $ \\text{PL}(S) $ of the input string $ S $.", "hint": null, "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Seoul R] Palindromic Length", "background": null, "description": "A string is called a **palindrome** if it is read the same forward and backward. Palindromes are useful factors for measuring the complexity of strings like the asymmetry of the strings. The asymmetry of a string $ S $ of length $ n $ can be measured by its **palindromic length**, $ \\text{PL}(S) $, which is the minimum number of palindromic substrings into which $ S $ can be partitioned. More precisely, $ \\text{PL}(S) $ is the minimum number $ t $ ($ 1 \\leq t \\leq n $) such that there exist palindromic substrings $ S_1, S_2, \\dots, S_t $ whose concatenation $ S_1S_2 \\cdots S_t $ becomes $ S $. To make it easier to distinguish, we denote a partition of $ S $ into $ S_1, S_2, \\dots, S_t $ as $ S_1 \\mid S_2 \\mid \\cdots \\mid S_t $.\n\nFor example, a string $ S = \\text{abaaca} $ can be partitioned into two palindromic substrings as $ \\text{aba} \\mid \\text{aca} $, that is the minimum, so $ \\text{PL}(\\text{abaaca}) = 2 $. A string $ \\text{acaba} $ cannot be partitioned into two palindromic substrings, but it can be partitioned into three palindromic substrings, $ S = \\text{aca} \\mid \\text{b} \\mid \\text{a} $ or $ S = \\text{a} \\mid \\text{c} \\mid \\text{aba} $, so $ \\text{PL}(\\text{acaba}) = 3 $. For $ S = \\text{radar} $, $ \\text{PL}(S) = 1 $ because $ S $ is a palindrome. $ \\text{PL}(S) = 5 $ for $ S = \\text{abcde} $.\n\nGiven a non-empty string $ S $ of English lowercase letters, write a program to output $ \\text{PL}(S) $.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing a positive integer $ n $ ($ 1 \\leq n \\leq 100,000 $), where $ n $ is the number of letters of a string. The next line contains a string of $ n $ English lowercase letters. Note that the string contains no space between the letters.", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain a positive integer which is the palindromic length $ \\text{PL}(S) $ of the input string $ S $.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Seoul R] Palindromic Length", "background": null, "description": "如果一个字符串从前向后读和从后向前读相同，则称其为 **回文串**。回文串是用于衡量字符串复杂度（例如字符串的不对称性）的有用因子。一个长度为 $n$ 的字符串 $S$ 的不对称性可以通过其 **回文长度** $\\text{PL}(S)$ 来度量，即 $S$ 能被划分成的回文子串的最小数量。更精确地说，$\\text{PL}(S)$ 是最小的整数 $t$ ($1 \\leq t \\leq n$)，使得存在回文子串 $S_1, S_2, \\dots, S_t$，它们的连接 $S_1S_2 \\cdots S_t$ 等于 $S$。为了便于区分，我们将 $S$ 划分为 $S_1, S_2, \\dots, S_t$ 记作 $S_1 \\mid S_2 \\mid \\cdots \\mid S_t$。\n\n例如，字符串 $S = \\text{abaaca}$ 可以划分成两个回文子串，即 $\\text{aba} \\mid \\text{aca}$，这是最小的划分，因此 $\\text{PL}(\\text{abaaca}) = 2$。字符串 $\\text{acaba}$ 不能被划分成两个回文子串，但可以划分成三个回文子串，例如 $S = \\text{aca} \\mid \\text{b} \\mid \\text{a}$ 或 $S = \\text{a} \\mid \\text{c} \\mid \\text{aba}$，因此 $\\text{PL}(\\text{acaba}) = 3$。对于 $S = \\text{radar}$，$\\text{PL}(S) = 1$，因为 $S$ 本身就是一个回文串。而对于 $S = \\text{abcde}$，$\\text{PL}(S) = 5$。\n\n给定一个由英文小写字母组成的非空字符串 $S$，请编写一个程序输出 $\\text{PL}(S)$。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含一个正整数 $n$ ($1 \\leq n \\leq 100,000$)，其中 $n$ 是字符串的字母数量。接下来的一行包含一个由 $n$ 个英文小写字母组成的字符串。注意，字符串中的字母之间没有空格。", "outputFormat": "你的程序需要向标准输出写入结果。输出恰好一行。该行应包含一个正整数，即输入字符串 $S$ 的回文长度 $\\text{PL}(S)$。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14772", "type": "P", "difficulty": 6, "samples": [["4 2\n1 2 1 1\n1 610 2 1 100\n3 2001 0", "2"], ["2 2\n1 2 1 1", "1"], ["8 6\n1 2 1 1\n1 3 2 1 2\n2 1 0\n3 4 1 2\n2 3 1 1\n1 4 1 3\n3 4 1 1", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "树链剖分", "ICPC", "首尔"], "title": "[ICPC 2024 Seoul R] Protecting Kingdom", "background": "", "description": "In the kingdom of **CPIC** (Committee for Public Infrastructure Conservation), there are $ n $ villages numbered from 1 to $ n $ and connected by a network of $ n-1 $ roads forming a tree structure. Each road connects two villages and has a positive length. Specifically, the $ i $-th road connects village $ i+1 $ with village $ p_i $ ($ 1 \\leq p_i \\leq i $) and has a length of $ l_i $. Due to treacherous terrains and past incidents, some points along these roads are identified as hazardous.\n\nOn the $ i $-th road, there are $ k_i $ hazardous points located at specific distances $ x_{i,1}, x_{i,2}, \\dots, x_{i,k_i} $ from village $ p_i $, satisfying $ 0 < x_{i,1} < x_{i,2} < \\cdots < x_{i,k_i} < l_i $. These distances are integers, indicating positions along the road.\n\nThe newly established **CPIC** Safety Committee aims to enhance traveler safety by deploying a protective measure. They can select any two points on the roads, including villages, and secure the shortest path between them. The path can cover all hazardous points located exactly on it, including its endpoints, and its length must not exceed a given length $ w $.\n\nGiven the road network, the positions of the hazardous points, and the maximum allowable path length $ w $, write a program to determine the maximum number of hazardous points that can be covered by optimally choosing the two points and securing the shortest path between them with length $ \\leq w $.\n", "inputFormat": "Your program is to read from standard input. The input starts with a line containing two integers, $ n $ and $ w $ ($ 2 \\leq n \\leq 250,000 $, $ 1 \\leq w \\leq 10^{18} $), where $ n $ is the number of villages and $ w $ is the maximum allowable length of the secured path. In the following $ n-1 $ lines, the $ i $-th line, which provides information about the $ i $-th road, starts with three integers $ p_i $, $ l_i $, and $ k_i $ ($ 1 \\leq p_i \\leq i $, $ 1 \\leq l_i \\leq 10^{12} $, $ k_i \\geq 0 $), where $ p_i $ is the village connected to village $ i+1 $ by the road, $ l_i $ is the length of the road, and $ k_i $ is the number of hazardous points on the road. If $ k_i > 0 $, the line is followed by $ k_i $ integers $ x_{i,1}, x_{i,2}, \\dots, x_{i,k_i} $ ($ 0 < x_{i,1} < x_{i,2} < \\cdots < x_{i,k_i} < l_i $), representing the distances from village $ p_i $ to each hazardous point along the road. The total number of hazardous points $ k_1 + k_2 + \\cdots + k_{n-1} $ does not exceed $ 10^6 $.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the maximum number of hazardous points that can be covered by a shortest path of length $ w $ or less between any two points on the roads.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Seoul R] Protecting Kingdom", "background": "", "description": "In the kingdom of **CPIC** (Committee for Public Infrastructure Conservation), there are $ n $ villages numbered from 1 to $ n $ and connected by a network of $ n-1 $ roads forming a tree structure. Each road connects two villages and has a positive length. Specifically, the $ i $-th road connects village $ i+1 $ with village $ p_i $ ($ 1 \\leq p_i \\leq i $) and has a length of $ l_i $. Due to treacherous terrains and past incidents, some points along these roads are identified as hazardous.\n\nOn the $ i $-th road, there are $ k_i $ hazardous points located at specific distances $ x_{i,1}, x_{i,2}, \\dots, x_{i,k_i} $ from village $ p_i $, satisfying $ 0 < x_{i,1} < x_{i,2} < \\cdots < x_{i,k_i} < l_i $. These distances are integers, indicating positions along the road.\n\nThe newly established **CPIC** Safety Committee aims to enhance traveler safety by deploying a protective measure. They can select any two points on the roads, including villages, and secure the shortest path between them. The path can cover all hazardous points located exactly on it, including its endpoints, and its length must not exceed a given length $ w $.\n\nGiven the road network, the positions of the hazardous points, and the maximum allowable path length $ w $, write a program to determine the maximum number of hazardous points that can be covered by optimally choosing the two points and securing the shortest path between them with length $ \\leq w $.\n", "inputFormat": "Your program is to read from standard input. The input starts with a line containing two integers, $ n $ and $ w $ ($ 2 \\leq n \\leq 250,000 $, $ 1 \\leq w \\leq 10^{18} $), where $ n $ is the number of villages and $ w $ is the maximum allowable length of the secured path. In the following $ n-1 $ lines, the $ i $-th line, which provides information about the $ i $-th road, starts with three integers $ p_i $, $ l_i $, and $ k_i $ ($ 1 \\leq p_i \\leq i $, $ 1 \\leq l_i \\leq 10^{12} $, $ k_i \\geq 0 $), where $ p_i $ is the village connected to village $ i+1 $ by the road, $ l_i $ is the length of the road, and $ k_i $ is the number of hazardous points on the road. If $ k_i > 0 $, the line is followed by $ k_i $ integers $ x_{i,1}, x_{i,2}, \\dots, x_{i,k_i} $ ($ 0 < x_{i,1} < x_{i,2} < \\cdots < x_{i,k_i} < l_i $), representing the distances from village $ p_i $ to each hazardous point along the road. The total number of hazardous points $ k_1 + k_2 + \\cdots + k_{n-1} $ does not exceed $ 10^6 $.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain the maximum number of hazardous points that can be covered by a shortest path of length $ w $ or less between any two points on the roads.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Seoul R] Protecting Kingdom", "background": "", "description": "在 **CPIC**（公共基础设施保护委员会）王国中，有 $n$ 个村庄，编号从 1 到 $n$，它们通过 $n-1$ 条道路连接，形成一个树状结构。每条道路连接两个村庄，并具有正的长度。具体来说，第 $i$ 条道路连接村庄 $i+1$ 与村庄 $p_i$ ($1 \\leq p_i \\leq i$)，长度为 $l_i$。由于地形险峻且发生过事故，这些道路上的某些点被标记为危险点。\n\n在第 $i$ 条道路上，有 $k_i$ 个危险点，位于距离村庄 $p_i$ 特定距离 $x_{i,1}, x_{i,2}, \\dots, x_{i,k_i}$ 处，满足 $0 < x_{i,1} < x_{i,2} < \\cdots < x_{i,k_i} < l_i$。这些距离为整数，表示沿道路的位置。\n\n新成立的 **CPIC** 安全委员会希望通过部署一项保护措施来提升旅行者的安全。他们可以选择道路上的任意两点（包括村庄），并保护它们之间的最短路径。这条路径可以覆盖位于其上（包括端点）的所有危险点，且其长度不得超过给定的长度 $w$。\n\n给定道路网络、危险点的位置以及允许的最大路径长度 $w$，请编写一个程序，确定通过最优选择两个点并保护它们之间长度 $\\leq w$ 的最短路径所能覆盖的危险点的最大数量。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含两个整数 $n$ 和 $w$ ($2 \\leq n \\leq 250,000$, $1 \\leq w \\leq 10^{18}$)，其中 $n$ 是村庄的数量，$w$ 是允许的保护路径的最大长度。接下来的 $n-1$ 行中，第 $i$ 行提供关于第 $i$ 条道路的信息，以三个整数 $p_i$, $l_i$, $k_i$ 开头 ($1 \\leq p_i \\leq i$, $1 \\leq l_i \\leq 10^{12}$, $k_i \\geq 0$)，其中 $p_i$ 是通过该道路与村庄 $i+1$ 连接的村庄，$l_i$ 是道路的长度，$k_i$ 是道路上的危险点数量。如果 $k_i > 0$，则该行后面跟着 $k_i$ 个整数 $x_{i,1}, x_{i,2}, \\dots, x_{i,k_i}$ ($0 < x_{i,1} < x_{i,2} < \\cdots < x_{i,k_i} < l_i$)，表示从村庄 $p_i$ 到道路上每个危险点的距离。危险点的总数 $k_1 + k_2 + \\cdots + k_{n-1}$ 不超过 $10^6$。", "outputFormat": "你的程序需要向标准输出写入结果。输出恰好一行。该行应包含通过选择道路上任意两点并保护它们之间长度不超过 $w$ 的最短路径所能覆盖的危险点的最大数量。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14773", "type": "P", "difficulty": 6, "samples": [["5\n0 9999\n0 0\n0 -9999\n200 0\n10000 9999", "2"], ["5\n10 -9999\n0 0\n3 9999\n9000 -9999\n10003 9999", "2"], ["6\n10 -9999\n0 0\n3 9999\n9000 -9999\n10003 -9999\n10003 9999", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "ICPC", "首尔"], "title": "[ICPC 2024 Seoul R] Square Stamping", "background": "", "description": "In the plane, there are $ n $ points whose y-coordinates are either $ -9999 $, $ 0 $, or $ 9999 $. Let $ P $ be the set of these $ n $ points. Your task is to enclose all the points in $ P $ by a minimum number of congruent axis-parallel squares of side length 10,000. As a subset of the plane, each such square consists of all points inside and on the boundary.", "inputFormat": "Your program is to read from standard input. The input starts with a line consisting of a single integer $ n $ ($ 1 \\leq n \\leq 300,000 $), representing the number of input points in $ P $. In each of the following $ n $ lines, there are two integers $ x $ and $ y $, representing the $ x $- and $ y $-coordinates of a point in $ P $, respectively, such that it holds that $ -10^9 \\leq x \\leq 10^9 $ and $ y \\in \\{-9999, 0, 9999\\} $. You may assume that all the $ n $ input points are distinct.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should consist of a single integer that represents the minimum possible number $ t $ such that there exist $ t $ axis-parallel squares of side length 10,000 whose union encloses all the input points in $ P $.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Seoul R] Square Stamping", "background": "", "description": "In the plane, there are $ n $ points whose y-coordinates are either $ -9999 $, $ 0 $, or $ 9999 $. Let $ P $ be the set of these $ n $ points. Your task is to enclose all the points in $ P $ by a minimum number of congruent axis-parallel squares of side length 10,000. As a subset of the plane, each such square consists of all points inside and on the boundary.", "inputFormat": "Your program is to read from standard input. The input starts with a line consisting of a single integer $ n $ ($ 1 \\leq n \\leq 300,000 $), representing the number of input points in $ P $. In each of the following $ n $ lines, there are two integers $ x $ and $ y $, representing the $ x $- and $ y $-coordinates of a point in $ P $, respectively, such that it holds that $ -10^9 \\leq x \\leq 10^9 $ and $ y \\in \\{-9999, 0, 9999\\} $. You may assume that all the $ n $ input points are distinct.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should consist of a single integer that represents the minimum possible number $ t $ such that there exist $ t $ axis-parallel squares of side length 10,000 whose union encloses all the input points in $ P $.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Seoul R] Square Stamping", "background": "", "description": "平面上有 $n$ 个点，它们的 $y$ 坐标只能是 $-9999$、$0$ 或 $9999$。令 $P$ 为这 $n$ 个点的集合。你的任务是用最少数量的全等且边与坐标轴平行的正方形来包围 $P$ 中的所有点。每个这样的正方形边长为 $10,000$。作为一个平面子集，每个正方形包含其内部及边界上的所有点。\n", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含一个整数 $n$ ($1 \\leq n \\leq 300,000$)，表示集合 $P$ 中点的数量。接下来的 $n$ 行，每行包含两个整数 $x$ 和 $y$，分别表示 $P$ 中一个点的 $x$ 坐标和 $y$ 坐标，满足 $-10^9 \\leq x \\leq 10^9$ 且 $y \\in \\{-9999, 0, 9999\\}$。你可以假设所有 $n$ 个输入点都是互不相同的。", "outputFormat": "你的程序需要向标准输出写入结果。输出恰好一行。该行应包含一个整数，表示可能存在的最小数 $t$，使得存在 $t$ 个边长为 $10,000$ 且边与坐标轴平行的正方形，它们的并集能够包围 $P$ 中的所有输入点。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14774", "type": "P", "difficulty": 4, "samples": [["10 4\n0 3 7 10", "3"], ["100 5\n0 97 98 99 100", "49"], ["1 2\n0 1", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["二分", "2024", "ICPC", "首尔"], "title": "[ICPC 2024 Seoul R] Street Development", "background": "", "description": "**ICPC** street is currently an undeveloped area, with a large-scale development plan scheduled soon. Before starting the development, information about $ n $ important points along the street will be collected using $ n $ remote-controlled robots, with each robot collecting information from one of these important points. Now, the goal is to combine all the collected information into a single robot to find the most efficient development approach. To combine the information, the robots can move towards left or right and combine the information that they have from other robots. Also, each robot is powered by its own battery, and all the robots are equipped with identical batteries. Specifically, let $ p_1, p_2, \\dots, p_n $ represent the positions of the important points where the robots collect information, arranged from left to right. Then the requirements are as follows:\n\n1. The **ICPC** street is considered as a one-dimensional interval $ [0, L] $ with a positive integer $ L $. The important points $ p_1, p_2, \\dots, p_n $ are always represented as integers on the interval, including two endpoints of the interval. That is, $ p_1 = 0 $ and $ p_n = L $. Initially, each robot is positioned at one of the important points, so it has the information of the important point before beginning to move. Note that there is exactly one robot at each of these points initially, which means $ n $ is also the number of robots, and always at least 2 and at most $ L+1 $.\n\n2. For combining the information from other robots, robots can move freely to the left or right, consuming 1 unit of battery for 1 unit of distance traveled, regardless of direction. All robots are equipped with the same battery capacity with integer $ P $, and move only in integer units of distance.\n\n3. When two or more robots meet at the integer position on the street, they can combine each other's information. For example, if a robot with information about $ p_1 $ and $ p_2 $ encounters with a robot with information about $ p_3 $ and $ p_4 $, both robots will then have information about the positions $ p_1, p_2, p_3 $, and $ p_4 $.\n\n4. Robots consume the battery only for movement. Therefore, they do not use the battery when changing direction or when combining the information from other robots.\n\n5. After all movements, at least one robot must have information about all the positions $ p_1, p_2, \\dots, p_n $.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/de2s0b2q.png)\n:::\n\nFor example, the figure above shows an example with $ L=10 $, $ n=4 $, and Robots 1, 2, 3, and 4 (R1, R2, R3, R4 in the figure) collect information (and are initially positioned) at $ p_1=0 $, $ p_2=3 $, $ p_3=7 $, and $ p_4=10 $, respectively. Then the following sequence of steps can be performed with a battery capacity of $ P=3 $:\n\n1. Robot 1 moves to $ p_2 $, and Robots 1 and 2 combine each other's information.\n2. Robot 4 moves to $ p_3 $, and Robots 3 and 4 combine each other's information.\n3. Robot 2 moves 2 units to the right, Robot 3 moves 2 units to the left, and they combine each other's information at the position 5 on the street.\n\nThen after completing the process, Robots 2 and 3 will have information about all the positions $ p_1, p_2, p_3 $, and $ p_4 $.\n\nSince the battery is much more expensive than the other parts of robot, it is important to determine the minimum battery capacity required for each robot for efficient data collection. Given $ L $, $ n $, and the positions of the important points $ p_1, p_2, \\dots, p_n $, write a program to calculate the minimum battery capacity $ P $ required for at least one robot to have information about all the important points.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing two positive integers, $ L $ and $ n $ ($ 1 \\leq L \\leq 10^6 $, $ 2 \\leq n \\leq L+1 $), where $ n $ is the number of robots and important points on the street and $ L $ is the position of the right endpoint of the street. In the following line, $ n $ distinct integers between 0 and $ L $ that represent the positions of important points of the street (the initial positions of the robots) are given in increasing order, where the first integer is 0 and the last one is $ L $.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain a single integer that represents the minimum battery capacity $ P $ required for at least one robot to have information about all the important points.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Seoul R] Street Development", "background": "", "description": "**ICPC** street is currently an undeveloped area, with a large-scale development plan scheduled soon. Before starting the development, information about $ n $ important points along the street will be collected using $ n $ remote-controlled robots, with each robot collecting information from one of these important points. Now, the goal is to combine all the collected information into a single robot to find the most efficient development approach. To combine the information, the robots can move towards left or right and combine the information that they have from other robots. Also, each robot is powered by its own battery, and all the robots are equipped with identical batteries. Specifically, let $ p_1, p_2, \\dots, p_n $ represent the positions of the important points where the robots collect information, arranged from left to right. Then the requirements are as follows:\n\n1. The **ICPC** street is considered as a one-dimensional interval $ [0, L] $ with a positive integer $ L $. The important points $ p_1, p_2, \\dots, p_n $ are always represented as integers on the interval, including two endpoints of the interval. That is, $ p_1 = 0 $ and $ p_n = L $. Initially, each robot is positioned at one of the important points, so it has the information of the important point before beginning to move. Note that there is exactly one robot at each of these points initially, which means $ n $ is also the number of robots, and always at least 2 and at most $ L+1 $.\n\n2. For combining the information from other robots, robots can move freely to the left or right, consuming 1 unit of battery for 1 unit of distance traveled, regardless of direction. All robots are equipped with the same battery capacity with integer $ P $, and move only in integer units of distance.\n\n3. When two or more robots meet at the integer position on the street, they can combine each other's information. For example, if a robot with information about $ p_1 $ and $ p_2 $ encounters with a robot with information about $ p_3 $ and $ p_4 $, both robots will then have information about the positions $ p_1, p_2, p_3 $, and $ p_4 $.\n\n4. Robots consume the battery only for movement. Therefore, they do not use the battery when changing direction or when combining the information from other robots.\n\n5. After all movements, at least one robot must have information about all the positions $ p_1, p_2, \\dots, p_n $.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/de2s0b2q.png)\n:::\n\nFor example, the figure above shows an example with $ L=10 $, $ n=4 $, and Robots 1, 2, 3, and 4 (R1, R2, R3, R4 in the figure) collect information (and are initially positioned) at $ p_1=0 $, $ p_2=3 $, $ p_3=7 $, and $ p_4=10 $, respectively. Then the following sequence of steps can be performed with a battery capacity of $ P=3 $:\n\n1. Robot 1 moves to $ p_2 $, and Robots 1 and 2 combine each other's information.\n2. Robot 4 moves to $ p_3 $, and Robots 3 and 4 combine each other's information.\n3. Robot 2 moves 2 units to the right, Robot 3 moves 2 units to the left, and they combine each other's information at the position 5 on the street.\n\nThen after completing the process, Robots 2 and 3 will have information about all the positions $ p_1, p_2, p_3 $, and $ p_4 $.\n\nSince the battery is much more expensive than the other parts of robot, it is important to determine the minimum battery capacity required for each robot for efficient data collection. Given $ L $, $ n $, and the positions of the important points $ p_1, p_2, \\dots, p_n $, write a program to calculate the minimum battery capacity $ P $ required for at least one robot to have information about all the important points.", "inputFormat": "Your program is to read from standard input. The input starts with a line containing two positive integers, $ L $ and $ n $ ($ 1 \\leq L \\leq 10^6 $, $ 2 \\leq n \\leq L+1 $), where $ n $ is the number of robots and important points on the street and $ L $ is the position of the right endpoint of the street. In the following line, $ n $ distinct integers between 0 and $ L $ that represent the positions of important points of the street (the initial positions of the robots) are given in increasing order, where the first integer is 0 and the last one is $ L $.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain a single integer that represents the minimum battery capacity $ P $ required for at least one robot to have information about all the important points.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Seoul R] Street Development", "background": "", "description": "**ICPC** 街道目前是一个未开发区域，一项大规模开发计划即将启动。在开始开发之前，将使用 $n$ 个遥控机器人收集沿街 $n$ 个重要点的信息，每个机器人负责从一个重要点收集信息。现在的目标是将所有收集到的信息合并到单个机器人中，以找到最高效的开发方案。为了合并信息，机器人可以向左或向右移动，并与携带其他机器人信息的机器人合并信息。此外，每个机器人由其自身的电池供电，所有机器人都配备相同的电池。具体来说，令 $p_1, p_2, \\dots, p_n$ 表示机器人收集信息的重要点的位置，按从左到右的顺序排列。要求如下：\n\n1. **ICPC** 街道被视为一个一维区间 $[0, L]$，其中 $L$ 为正整数。重要点 $p_1, p_2, \\dots, p_n$ 始终表示为该区间上的整数，包括区间的两个端点。即 $p_1 = 0$ 且 $p_n = L$。初始时，每个机器人位于其中一个重要点上，因此在开始移动前它已拥有该重要点的信息。注意，初始时每个重要点上恰好有一个机器人，这意味着 $n$ 同时也是机器人的数量，且 $n$ 至少为 $2$，至多为 $L+1$。\n\n2. 为了合并来自其他机器人的信息，机器人可以自由地向左或向右移动，每移动 $1$ 单位距离消耗 $1$ 单位电池电量，与方向无关。所有机器人都配备相同的电池容量，其整数值为 $P$，且只在整数距离单位上移动。\n\n3. 当两个或更多机器人在街道上的整数位置相遇时，它们可以合并彼此的信息。例如，如果一个拥有 $p_1$ 和 $p_2$ 信息的机器人与一个拥有 $p_3$ 和 $p_4$ 信息的机器人相遇，则两个机器人随后都将拥有 $p_1, p_2, p_3, p_4$ 这些位置的信息。\n\n4. 机器人仅在移动时消耗电池电量。因此，它们在改变方向或合并其他机器人信息时不消耗电量。\n\n5. 在所有移动结束后，至少有一个机器人必须拥有所有位置 $p_1, p_2, \\dots, p_n$ 的信息。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/de2s0b2q.png)\n:::\n\n例如，上图展示了一个 $L=10$，$n=4$ 的例子，机器人 1、2、3、4（图中 R1、R2、R3、R4）分别收集信息（且初始位于）$p_1=0$，$p_2=3$，$p_3=7$，$p_4=10$。那么，在电池容量 $P=3$ 的情况下，可以执行以下步骤序列：\n\n1. 机器人 1 移动到 $p_2$，机器人 1 和 2 合并彼此的信息。\n2. 机器人 4 移动到 $p_3$，机器人 3 和 4 合并彼此的信息。\n3. 机器人 2 向右移动 $2$ 单位，机器人 3 向左移动 $2$ 单位，它们在街道上的位置 $5$ 处合并彼此的信息。\n\n完成此过程后，机器人 2 和 3 将拥有所有位置 $p_1, p_2, p_3, p_4$ 的信息。\n\n由于电池比机器人的其他部件昂贵得多，因此确定每个机器人进行高效数据收集所需的最小电池容量非常重要。给定 $L$、$n$ 以及重要点的位置 $p_1, p_2, \\dots, p_n$，请编写一个程序计算至少一个机器人拥有所有重要点信息所需的最小电池容量 $P$。", "inputFormat": "你的程序需要从标准输入读取数据。输入的第一行包含两个正整数 $L$ 和 $n$ ($1 \\leq L \\leq 10^6$, $2 \\leq n \\leq L+1$)，其中 $n$ 是街道上机器人（即重要点）的数量，$L$ 是街道右端点的位置。接下来的一行按递增顺序给出 $n$ 个介于 $0$ 和 $L$ 之间且互不相同的整数，表示街道重要点（机器人的初始位置）的位置，其中第一个整数为 $0$，最后一个整数为 $L$。", "outputFormat": "你的程序需要向标准输出写入结果。输出恰好一行。该行应包含一个整数，表示至少一个机器人拥有所有重要点信息所需的最小电池容量 $P$。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14775", "type": "P", "difficulty": 5, "samples": [["aabbb", "3"], ["abacb", "2"], ["azadzzadaz", "4"], ["a", "1"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "ICPC", "首尔"], "title": "[ICPC 2024 Seoul R] String Rank", "background": "", "description": "Let $ w $ and $ u $ be strings consisting of the English lowercase alphabet. We say that a string $ u $ is a subsequence of a string $ w $ if there exists a strictly increasing sequence of integers $ i_1, \\dots, i_k $, where $ |w| = n $, $ |u| = k $ and $ u[j] = w[i_j] $ for all $ j = 1, \\dots, k $. Here, $ v[i] $ denotes the $ i $-th character of the string $ v $. Let $ w[i:] $ denote the suffix $ w[i] \\cdots w[n] $. If $ i > n $, then $ w[i:] $ is the empty string denoted by $ \\lambda $.\n\nGiven a nonempty string $ w $ and a positive integer $ k $, we define the $ k $-set of $ w $ to be the set $ Q_k(w) $ of subsequences of $ w $ whose lengths are $ 0, 1, \\dots, k $. This implies that, for any string $ w $, the empty string $ \\lambda $ belongs to $ Q_k(w) $ by definition.\n\nFor example, when $ w = \\text{aaba} $, we have $ Q_3(\\text{aaba}) = \\{\\lambda, \\text{a}, \\text{b}, \\text{ba}, \\text{ab}, \\text{aa}, \\text{aba}, \\text{aab}, \\text{aaa}\\} $.\n\nFor a string $ w $, we define the rank of $ w $ to be the minimum integer $ t $ such that the $ t $-sets for all suffixes of $ w $ are all different. In other words, the rank of $ w $ is $ \\min\\{t \\geq 1 \\mid Q_t(w[i:]) \\neq Q_t(w[j:]), \\forall 1 \\leq i < j \\leq n\\} $.\n\nFor instance, when $ w = \\text{aaba} $, the 2-sets $ Q_2(\\text{aba}) $ and $ Q_2(\\text{aaba}) $ are equal. On the other hand, for $ t = 3 $, we have\n\n$$\n\\begin{aligned}\nQ_3(\\lambda) &= \\{\\lambda\\}, \\\\\nQ_3(\\text{a}) &= \\{\\lambda, \\text{a}\\}, \\\\\nQ_3(\\text{ba}) &= \\{\\lambda, \\text{a}, \\text{b}, \\text{ba}\\}, \\\\\nQ_3(\\text{aba}) &= \\{\\lambda, \\text{a}, \\text{b}, \\text{ba}, \\text{ab}, \\text{aa}, \\text{aba}\\}, \\\\\nQ_3(\\text{aaba}) &= \\{\\lambda, \\text{a}, \\text{b}, \\text{ba}, \\text{ab}, \\text{aa}, \\text{aba}, \\text{aab}, \\text{aaa}\\}.\n\\end{aligned}\n$$\n\nTherefore, the rank of the string $ w = \\text{aaba} $ is 3.\n\nGiven a string $ w $, write a program to output its rank.\n", "inputFormat": "Your program is to read from standard input. The input consists of a single nonempty string $ w $, which consists only of lowercase characters from the English alphabet. The length of the string is at most $ 3 \\times 10^6 $.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain a positive integer to represent the rank $ t $ of the input string $ w $.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Seoul R] String Rank", "background": "", "description": "Let $ w $ and $ u $ be strings consisting of the English lowercase alphabet. We say that a string $ u $ is a subsequence of a string $ w $ if there exists a strictly increasing sequence of integers $ i_1, \\dots, i_k $, where $ |w| = n $, $ |u| = k $ and $ u[j] = w[i_j] $ for all $ j = 1, \\dots, k $. Here, $ v[i] $ denotes the $ i $-th character of the string $ v $. Let $ w[i:] $ denote the suffix $ w[i] \\cdots w[n] $. If $ i > n $, then $ w[i:] $ is the empty string denoted by $ \\lambda $.\n\nGiven a nonempty string $ w $ and a positive integer $ k $, we define the $ k $-set of $ w $ to be the set $ Q_k(w) $ of subsequences of $ w $ whose lengths are $ 0, 1, \\dots, k $. This implies that, for any string $ w $, the empty string $ \\lambda $ belongs to $ Q_k(w) $ by definition.\n\nFor example, when $ w = \\text{aaba} $, we have $ Q_3(\\text{aaba}) = \\{\\lambda, \\text{a}, \\text{b}, \\text{ba}, \\text{ab}, \\text{aa}, \\text{aba}, \\text{aab}, \\text{aaa}\\} $.\n\nFor a string $ w $, we define the rank of $ w $ to be the minimum integer $ t $ such that the $ t $-sets for all suffixes of $ w $ are all different. In other words, the rank of $ w $ is $ \\min\\{t \\geq 1 \\mid Q_t(w[i:]) \\neq Q_t(w[j:]), \\forall 1 \\leq i < j \\leq n\\} $.\n\nFor instance, when $ w = \\text{aaba} $, the 2-sets $ Q_2(\\text{aba}) $ and $ Q_2(\\text{aaba}) $ are equal. On the other hand, for $ t = 3 $, we have\n\n$$\n\\begin{aligned}\nQ_3(\\lambda) &= \\{\\lambda\\}, \\\\\nQ_3(\\text{a}) &= \\{\\lambda, \\text{a}\\}, \\\\\nQ_3(\\text{ba}) &= \\{\\lambda, \\text{a}, \\text{b}, \\text{ba}\\}, \\\\\nQ_3(\\text{aba}) &= \\{\\lambda, \\text{a}, \\text{b}, \\text{ba}, \\text{ab}, \\text{aa}, \\text{aba}\\}, \\\\\nQ_3(\\text{aaba}) &= \\{\\lambda, \\text{a}, \\text{b}, \\text{ba}, \\text{ab}, \\text{aa}, \\text{aba}, \\text{aab}, \\text{aaa}\\}.\n\\end{aligned}\n$$\n\nTherefore, the rank of the string $ w = \\text{aaba} $ is 3.\n\nGiven a string $ w $, write a program to output its rank.\n", "inputFormat": "Your program is to read from standard input. The input consists of a single nonempty string $ w $, which consists only of lowercase characters from the English alphabet. The length of the string is at most $ 3 \\times 10^6 $.\n", "outputFormat": "Your program is to write to standard output. Print exactly one line. The line should contain a positive integer to represent the rank $ t $ of the input string $ w $.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Seoul R] String Rank", "background": "", "description": "设 $w$ 和 $u$ 是由英文小写字母组成的字符串。如果存在一个严格递增的整数序列 $i_1, \\dots, i_k$，其中 $|w| = n$，$|u| = k$，且对于所有 $j = 1, \\dots, k$ 有 $u[j] = w[i_j]$，则称字符串 $u$ 是字符串 $w$ 的一个**子序列**。这里 $v[i]$ 表示字符串 $v$ 的第 $i$ 个字符。令 $w[i:]$ 表示后缀 $w[i] \\cdots w[n]$。如果 $i > n$，则 $w[i:]$ 为空字符串，记为 $\\lambda$。\n\n给定一个非空字符串 $w$ 和一个正整数 $k$，我们定义 $w$ 的 **$k$ 集合** 为集合 $Q_k(w)$，它包含 $w$ 中所有长度为 $0, 1, \\dots, k$ 的子序列。这意味着，根据定义，对于任何字符串 $w$，空字符串 $\\lambda$ 都属于 $Q_k(w)$。\n\n例如，当 $w = \\text{aaba}$ 时，有 $Q_3(\\text{aaba}) = \\{\\lambda, \\text{a}, \\text{b}, \\text{ba}, \\text{ab}, \\text{aa}, \\text{aba}, \\text{aab}, \\text{aaa}\\}$。\n\n对于一个字符串 $w$，我们定义 $w$ 的 **秩** 为最小整数 $t$，使得 $w$ 的所有后缀的 $t$ 集合互不相同。换句话说，$w$ 的秩是 $\\min\\{t \\geq 1 \\mid Q_t(w[i:]) \\neq Q_t(w[j:]), \\forall 1 \\leq i < j \\leq n\\}$。\n\n例如，当 $w = \\text{aaba}$ 时，2 集合 $Q_2(\\text{aba})$ 和 $Q_2(\\text{aaba})$ 是相等的。另一方面，对于 $t = 3$，我们有\n\n$$\n\\begin{aligned}\nQ_3(\\lambda) &= \\{\\lambda\\}, \\\\\nQ_3(\\text{a}) &= \\{\\lambda, \\text{a}\\}, \\\\\nQ_3(\\text{ba}) &= \\{\\lambda, \\text{a}, \\text{b}, \\text{ba}\\}, \\\\\nQ_3(\\text{aba}) &= \\{\\lambda, \\text{a}, \\text{b}, \\text{ba}, \\text{ab}, \\text{aa}, \\text{aba}\\}, \\\\\nQ_3(\\text{aaba}) &= \\{\\lambda, \\text{a}, \\text{b}, \\text{ba}, \\text{ab}, \\text{aa}, \\text{aba}, \\text{aab}, \\text{aaa}\\}.\n\\end{aligned}\n$$\n\n因此，字符串 $w = \\text{aaba}$ 的秩为 $3$。\n\n给定一个字符串 $w$，请编写一个程序输出其秩。", "inputFormat": "你的程序需要从标准输入读取数据。输入包含一个非空字符串 $w$，该字符串仅由英文小写字母组成。字符串的长度不超过 $3 \\times 10^6$。", "outputFormat": "你的程序需要向标准输出写入结果。输出恰好一行。该行应包含一个正整数，表示输入字符串 $w$ 的秩 $t$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14776", "type": "P", "difficulty": 3, "samples": [["4 8 -8 -1 7 -7", "69 46"], ["-8 1 7 11 7 -5", "121 23"], ["0 0 1 10 10 0", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["数学", "计算几何", "2024", "ICPC", "首尔"], "title": "[ICPC 2024 Seoul R] Triangle", "background": "", "description": "There is a triangle whose coordinates of three vertices $ A, B, $ and $ C $ are all integers. If you select a point on each side of the triangle whose coordinates are integers and connect those points, a new triangle is created. When creating a new triangle, no vertex of the given triangle can be selected as a vertex of the new triangle.\n\nDepending on which points you select and connect, the area of the newly created triangle may be large or small.\n\nYou are to write a program that finds out the largest and smallest areas of the newly created triangle if they exist.\n\nFor example, as shown in the figure below, if the coordinates of the three vertices of the given triangle are $ (4,8) $, $ (-8,-1) $, and $ (7,-7) $, the yellow triangle shown in Fig. L.1(a) has the largest area among those that satisfy the condition, and the blue triangle shown in Fig. L.1(b) has the smallest area.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/z0iopswz.png)\n:::\n\nThere may not be a point on any side of the given triangle whose coordinates are integers, in which case the triangle you are looking for does not exist.\n\nIt is guaranteed that the three points of the given input are not on a straight line.", "inputFormat": "Your program is to read from standard input. The input consists of a line containing six integers that are the $ (x,y) $-coordinates of the three vertices $ A = (A_x, A_y) $, $ B = (B_x, B_y) $, and $ C = (C_x, C_y) $ of a triangle, which $ A_x $, $ A_y $, $ B_x $, $ B_y $, $ C_x $, and $ C_y $ are given in that order. Each value of the coordinates is an integer between $ -10^9 $ and $ 10^9 $, inclusive.", "outputFormat": "Your program is to write to standard output. Let the area of the newly created triangle with the largest area be $ S_{\\text{max}} $, and the area of the triangle with the smallest area be $ S_{\\text{min}} $. If such triangles can be found, print $ 2S_{\\text{max}} $ and $ 2S_{\\text{min}} $ in that order, where both $ 2S_{\\text{max}} $ and $ 2S_{\\text{min}} $ are positive integers. If such triangles cannot be found, print $ -1 $.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2024 Seoul R] Triangle", "background": "", "description": "There is a triangle whose coordinates of three vertices $ A, B, $ and $ C $ are all integers. If you select a point on each side of the triangle whose coordinates are integers and connect those points, a new triangle is created. When creating a new triangle, no vertex of the given triangle can be selected as a vertex of the new triangle.\n\nDepending on which points you select and connect, the area of the newly created triangle may be large or small.\n\nYou are to write a program that finds out the largest and smallest areas of the newly created triangle if they exist.\n\nFor example, as shown in the figure below, if the coordinates of the three vertices of the given triangle are $ (4,8) $, $ (-8,-1) $, and $ (7,-7) $, the yellow triangle shown in Fig. L.1(a) has the largest area among those that satisfy the condition, and the blue triangle shown in Fig. L.1(b) has the smallest area.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/z0iopswz.png)\n:::\n\nThere may not be a point on any side of the given triangle whose coordinates are integers, in which case the triangle you are looking for does not exist.\n\nIt is guaranteed that the three points of the given input are not on a straight line.", "inputFormat": "Your program is to read from standard input. The input consists of a line containing six integers that are the $ (x,y) $-coordinates of the three vertices $ A = (A_x, A_y) $, $ B = (B_x, B_y) $, and $ C = (C_x, C_y) $ of a triangle, which $ A_x $, $ A_y $, $ B_x $, $ B_y $, $ C_x $, and $ C_y $ are given in that order. Each value of the coordinates is an integer between $ -10^9 $ and $ 10^9 $, inclusive.", "outputFormat": "Your program is to write to standard output. Let the area of the newly created triangle with the largest area be $ S_{\\text{max}} $, and the area of the triangle with the smallest area be $ S_{\\text{min}} $. If such triangles can be found, print $ 2S_{\\text{max}} $ and $ 2S_{\\text{min}} $ in that order, where both $ 2S_{\\text{max}} $ and $ 2S_{\\text{min}} $ are positive integers. If such triangles cannot be found, print $ -1 $.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2024 Seoul R] Triangle", "background": "", "description": "存在一个三角形，其三个顶点 $A$、$B$、$C$ 的坐标均为整数。如果你在三角形的每条边上各选取一个坐标为整数的点，并将这些点连接起来，就会形成一个新的三角形。在创建新三角形时，不能选取给定三角形的顶点作为新三角形的顶点。\n\n根据你选取和连接的点的不同，新创建的三角形的面积可能较大也可能较小。\n\n你需要编写一个程序，找出新三角形可能的最大面积和最小面积（如果它们存在的话）。\n\n例如，如下图所示，如果给定三角形的三个顶点坐标为 $(4,8)$、$(-8,-1)$ 和 $(7,-7)$，那么图 L.1(a) 中所示的黄色三角形是满足条件的三角形中面积最大的，而图 L.1(b) 中所示的蓝色三角形是面积最小的。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/z0iopswz.png)\n:::\n\n可能在给定三角形的某些边上不存在坐标为整数的点，这种情况下，你所寻找的三角形就不存在。\n\n保证输入的三个点不共线。", "inputFormat": "你的程序需要从标准输入读取数据。输入包含一行，包含六个整数，分别是一个三角形的三个顶点 $A = (A_x, A_y)$、$B = (B_x, B_y)$、$C = (C_x, C_y)$ 的 $(x, y)$ 坐标，按顺序依次给出 $A_x$、$A_y$、$B_x$、$B_y$、$C_x$、$C_y$。每个坐标值都是介于 $-10^9$ 到 $10^9$ 之间（含）的整数。", "outputFormat": "你的程序需要向标准输出写入结果。设新创建的三角形中面积最大的面积为 $S_{\\text{max}}$，面积最小的面积为 $S_{\\text{min}}$。如果这样的三角形可以找到，则按顺序输出 $2S_{\\text{max}}$ 和 $2S_{\\text{min}}$，其中 $2S_{\\text{max}}$ 和 $2S_{\\text{min}}$ 均为正整数。如果这样的三角形无法找到，则输出 $-1$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14777", "type": "P", "difficulty": 1, "samples": [["1 1\nALURDF", "F"], ["3 2\nLUUADDRCRB", "AA.\nACB\nCBB"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2025", "O2优化", "COCI（克罗地亚）"], "title": "[COCI 2025/2026 #3] 画笔 / Kist", "background": "本题满分 $50$。", "description": "Ivo 位于一个 $n \\times n$ 的方阵中（$n$ 为奇数），手里拿着一把“厚度”为 $k$ 的魔法画笔。初始时，矩阵的每个格子都标记为字符 `.`，并且 Ivo 在矩阵的中心格。\n\nIvo 收到一个由大写英文字母组成的指令串。他按顺序执行每个字符代表的一条指令，规则如下：\n\n- `L`：向左移动 $1$ 格  \n- `R`：向右移动 $1$ 格  \n- `U`：向上移动 $1$ 格  \n- `D`：向下移动 $1$ 格  \n- 若当前字符是其他任意大写字母：Ivo **不移动**，而是用该字母作为“颜色”，将所有与当前位置距离 **严格小于** $k$ 的格子染成该颜色，无论之前是否被染过（即新的颜色会覆盖原有的颜色）。\n\n若某次移动会使 Ivo 走出矩阵，则**跳过**该步（位置不变），继续执行后续指令。\n\n> 两个格子的“距离”定义为：只能上下左右移动，从一个格子走到另一个格子所需的最少步数（即曼哈顿距离）。", "inputFormat": "第一行包含两个自然数 $n, k$（$1 \\le n, k \\le 50$）。\n\n第二行包含一个由大写英文字母组成的字符串，长度 $\\le 50$。", "outputFormat": "输出 $n$ 行，每行包含 $n$ 个字符，表示 Ivo 执行完全部指令后的矩阵状态。", "hint": "#### 【样例解释】\n\n样例 #1 解释：由于矩阵只有一个格子，Ivo 永远不会离开该格子，只会不断给该格子上色。最终颜色为 `F`。\n\n#### 【子任务】\n\n| 子任务 | 分值 | 限制 |\n|:---:|:---:|:---:|\n| $1$ | $2$ | $n = 1$ |\n| $2$ | $10$ | $k = 1$ |\n| $3$ | $15$ | $k = 2$ |\n| $4$ | $23$ | 无额外限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2025/2026 #3] 画笔 / Kist", "background": "本题满分 $50$。", "description": "Ivo 位于一个 $n \\times n$ 的方阵中（$n$ 为奇数），手里拿着一把“厚度”为 $k$ 的魔法画笔。初始时，矩阵的每个格子都标记为字符 `.`，并且 Ivo 在矩阵的中心格。\n\nIvo 收到一个由大写英文字母组成的指令串。他按顺序执行每个字符代表的一条指令，规则如下：\n\n- `L`：向左移动 $1$ 格  \n- `R`：向右移动 $1$ 格  \n- `U`：向上移动 $1$ 格  \n- `D`：向下移动 $1$ 格  \n- 若当前字符是其他任意大写字母：Ivo **不移动**，而是用该字母作为“颜色”，将所有与当前位置距离 **严格小于** $k$ 的格子染成该颜色，无论之前是否被染过（即新的颜色会覆盖原有的颜色）。\n\n若某次移动会使 Ivo 走出矩阵，则**跳过**该步（位置不变），继续执行后续指令。\n\n> 两个格子的“距离”定义为：只能上下左右移动，从一个格子走到另一个格子所需的最少步数（即曼哈顿距离）。", "inputFormat": "第一行包含两个自然数 $n, k$（$1 \\le n, k \\le 50$）。\n\n第二行包含一个由大写英文字母组成的字符串，长度 $\\le 50$。", "outputFormat": "输出 $n$ 行，每行包含 $n$ 个字符，表示 Ivo 执行完全部指令后的矩阵状态。", "hint": "#### 【样例解释】\n\n样例 #1 解释：由于矩阵只有一个格子，Ivo 永远不会离开该格子，只会不断给该格子上色。最终颜色为 `F`。\n\n#### 【子任务】\n\n| 子任务 | 分值 | 限制 |\n|:---:|:---:|:---:|\n| $1$ | $2$ | $n = 1$ |\n| $2$ | $10$ | $k = 1$ |\n| $3$ | $15$ | $k = 2$ |\n| $4$ | $23$ | 无额外限制 |", "locale": "zh-CN"}}}
{"pid": "P14778", "type": "P", "difficulty": 2, "samples": [["3 1", "2"], ["3 2", "3"], ["4 2", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "数学", "2025", "O2优化", "COCI（克罗地亚）"], "title": "[COCI 2025/2026 #3] 节日 / Festival", "background": "本题满分 $70$。", "description": "Ivan 在今年的巧克力节工作时，老板给了他 $n$ 个**互不相同**的巧克力糖果，让他用这些糖果准备 $k$ 个巧克力盒。Ivan 想知道一共有多少种不同的摆放方式（之后再从中选最好的）。\n\n糖果的摆放必须满足：\n\n- 每个盒子至少包含 $1$ 颗糖；\n- 每颗糖恰好放入 $1$ 个盒子；\n- 盒子彼此**完全相同**：交换两个盒子的内容不算产生新方案。我们只关心每个盒子里有哪些糖，以及它们在盒子里的排列顺序；\n- 每个盒子中，**最大**的那颗糖必须放在该盒子的第一个位置。（可以认为任意一组糖的最大值都能唯一确定。）\n\n问共有多少种摆放方式？答案可能很大，请输出它对 $10^9+7$ 取模的结果。", "inputFormat": "一行包含两个自然数 $n, k$（$1 \\le k \\le n \\le 5000$），表示糖果数与盒子数。", "outputFormat": "输出一行，包含一个整数，表示方案数 $\\bmod\\ (10^9+7)$ 的值。", "hint": "#### 【样例解释】\n\n样例 #1 解释：将糖果按从小到大编号为 $1,2,3$。只有 $1$ 个盒子，因此全都在同一盒中。最大糖 $3$ 必须在第一位，其余两颗可以任意排列：$[3,1,2]$、$[3,2,1]$，共 $2$ 种。\n\n样例 #2 解释：同样编号 $1,2,3$，分成 $2$ 个相同盒子，有 $3$ 种：$\\{[1], [3,2]\\}$，$\\{[2], [3,1]\\}$ 和 $\\{[3], [2,1]\\}$。\n\n#### 【子任务】\n\n| 子任务 | 分值 | 限制 |\n|:---:|:---:|:---:|\n| $1$ | $8$ | $k = 1$ |\n| $2$ | $19$ | $k = 2$ |\n| $3$ | $14$ | $n \\le 10$ |\n| $4$ | $29$ | 无额外限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2025/2026 #3] 节日 / Festival", "background": "本题满分 $70$。", "description": "Ivan 在今年的巧克力节工作时，老板给了他 $n$ 个**互不相同**的巧克力糖果，让他用这些糖果准备 $k$ 个巧克力盒。Ivan 想知道一共有多少种不同的摆放方式（之后再从中选最好的）。\n\n糖果的摆放必须满足：\n\n- 每个盒子至少包含 $1$ 颗糖；\n- 每颗糖恰好放入 $1$ 个盒子；\n- 盒子彼此**完全相同**：交换两个盒子的内容不算产生新方案。我们只关心每个盒子里有哪些糖，以及它们在盒子里的排列顺序；\n- 每个盒子中，**最大**的那颗糖必须放在该盒子的第一个位置。（可以认为任意一组糖的最大值都能唯一确定。）\n\n问共有多少种摆放方式？答案可能很大，请输出它对 $10^9+7$ 取模的结果。", "inputFormat": "一行包含两个自然数 $n, k$（$1 \\le k \\le n \\le 5000$），表示糖果数与盒子数。", "outputFormat": "输出一行，包含一个整数，表示方案数 $\\bmod\\ (10^9+7)$ 的值。", "hint": "#### 【样例解释】\n\n样例 #1 解释：将糖果按从小到大编号为 $1,2,3$。只有 $1$ 个盒子，因此全都在同一盒中。最大糖 $3$ 必须在第一位，其余两颗可以任意排列：$[3,1,2]$、$[3,2,1]$，共 $2$ 种。\n\n样例 #2 解释：同样编号 $1,2,3$，分成 $2$ 个相同盒子，有 $3$ 种：$\\{[1], [3,2]\\}$，$\\{[2], [3,1]\\}$ 和 $\\{[3], [2,1]\\}$。\n\n#### 【子任务】\n\n| 子任务 | 分值 | 限制 |\n|:---:|:---:|:---:|\n| $1$ | $8$ | $k = 1$ |\n| $2$ | $19$ | $k = 2$ |\n| $3$ | $14$ | $n \\le 10$ |\n| $4$ | $29$ | 无额外限制 |", "locale": "zh-CN"}}}
{"pid": "P14779", "type": "P", "difficulty": 5, "samples": [["2 3\n1 2\n1 4\n3 4", "4\n2 1 4 3"], ["3 5\n1 2\n2 3\n1 4\n4 5\n1 6", "4\n6 1 2 3"], ["4 8\n1 2\n2 3\n3 4\n4 1\n2 5\n3 6\n4 7\n7 8", "6\n6 3 4 1 2 5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "2025", "Special Judge", "O2优化", "拓扑排序", "二分图", "COCI（克罗地亚）"], "title": "[COCI 2025/2026 #3] 宴会 / Domjenak", "background": "本题满分 $110$。", "description": "Malnar 先生正在为他的 $2N$ 位同事举办宴会，同事编号为 $1,2,\\dots,2N$。同事们是两两成对来到宴会的。Malnar 先生观察到这群人传播信息时遵循一些奇怪规则：\n\n第一，当且仅当两人是朋友，A 才愿意把信息告诉 B。保证一起到宴会的那一对同事互为朋友。\n\n第二，每个人最多只愿意向一个人分享信息，并且对方必须尚未知道该信息。\n\n第三，每个人尝试分享信息时，优先级最高的是与自己同来宴会的搭档。\n\n换句话说：若 A 与 B 同来宴会，并且 A 知道而 B 不知道某信息，则 A 一定会把信息告诉 B。由于规则 2，A 不会再把该信息告诉其他人；而 B 之后会尝试把信息告诉另一位朋友，如此继续。  \n\n第四，这群人可以被划分为两个子集，使得任意一对朋友都不在同一子集。\n\nMalnar 先生打算把故事讲给其中一位同事，并关心最多能有多少位同事听到故事。若最大人数为 $K$，他还希望你给出一个长度为 $K$ 的序列 $a_1,a_2,\\ldots,a_K$，使得如果他把故事讲给 $a_1$，那么对所有 $i=1,2,\\ldots,K-1$，同事 $a_i$ 都能把故事讲给 $a_{i+1}$（符合上述传播规则）。\n\n在整理规则时，Malnar 先生记录下了所有“朋友关系”，但忘记了当初哪些同事是成对来到宴会的。幸运的是，这些信息可以被唯一恢复：也就是说，存在且仅存在一种把 $2N$ 位同事划分为 $N$ 对的方式，使得同一对里的两人是朋友。\n\n请你帮助 Malnar 先生回答上述问题。", "inputFormat": "第一行包含两个整数 $N, M$（$1 \\le N \\le 5\\cdot 10^5$，$N \\le M \\le 10^6$），分别表示参加宴会的同事“对数”与朋友关系条数。\n\n接下来 $M$ 行，每行包含两个整数 $u_i, v_i$（$1 \\le u_i, v_i \\le 2N$），表示 $u_i$ 与 $v_i$ 是朋友。", "outputFormat": "第一行包含一个整数 $K$，表示最多能听到故事的人数。\n\n第二行包含 $K$ 个整数，给出满足条件的序列。若有多种可能的答案，输出任意一种即可。", "hint": "#### 【样例解释】\n\n样例 #1 解释：参加宴会的同事配对为：$(1,2)$、$(3,4)$。\n\n样例 #2 解释：参加宴会的同事配对为：$(1,6)$、$(2,3)$、$(4,5)$。可以证明不存在更长的可行序列。\n\n例如序列 $(3,2,1,4,5)$，虽然相邻两人都是朋友，但 $1$ 从 $2$ 听到故事后无法把故事告诉 $4$，因为 $1$ 的宴会搭档 $6$ 仍不知道故事（规则 3 的优先级阻止了该传播）。\n\n#### 【子任务】\n\n| 子任务 | 分值 | 限制 |\n|:---:|:---:|:---:|\n| $1$ | $24$ | $N \\le 10$ |\n| $2$ | $16$ | 每位同事最多与 $2$ 位同事是朋友 |\n| $3$ | $30$ | $N \\le 2000$，$M \\le 5000$ |\n| $4$ | $40$ | 无额外限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2025/2026 #3] 宴会 / Domjenak", "background": "本题满分 $110$。", "description": "Malnar 先生正在为他的 $2N$ 位同事举办宴会，同事编号为 $1,2,\\dots,2N$。同事们是两两成对来到宴会的。Malnar 先生观察到这群人传播信息时遵循一些奇怪规则：\n\n第一，当且仅当两人是朋友，A 才愿意把信息告诉 B。保证一起到宴会的那一对同事互为朋友。\n\n第二，每个人最多只愿意向一个人分享信息，并且对方必须尚未知道该信息。\n\n第三，每个人尝试分享信息时，优先级最高的是与自己同来宴会的搭档。\n\n换句话说：若 A 与 B 同来宴会，并且 A 知道而 B 不知道某信息，则 A 一定会把信息告诉 B。由于规则 2，A 不会再把该信息告诉其他人；而 B 之后会尝试把信息告诉另一位朋友，如此继续。  \n\n第四，这群人可以被划分为两个子集，使得任意一对朋友都不在同一子集。\n\nMalnar 先生打算把故事讲给其中一位同事，并关心最多能有多少位同事听到故事。若最大人数为 $K$，他还希望你给出一个长度为 $K$ 的序列 $a_1,a_2,\\ldots,a_K$，使得如果他把故事讲给 $a_1$，那么对所有 $i=1,2,\\ldots,K-1$，同事 $a_i$ 都能把故事讲给 $a_{i+1}$（符合上述传播规则）。\n\n在整理规则时，Malnar 先生记录下了所有“朋友关系”，但忘记了当初哪些同事是成对来到宴会的。幸运的是，这些信息可以被唯一恢复：也就是说，存在且仅存在一种把 $2N$ 位同事划分为 $N$ 对的方式，使得同一对里的两人是朋友。\n\n请你帮助 Malnar 先生回答上述问题。", "inputFormat": "第一行包含两个整数 $N, M$（$1 \\le N \\le 5\\cdot 10^5$，$N \\le M \\le 10^6$），分别表示参加宴会的同事“对数”与朋友关系条数。\n\n接下来 $M$ 行，每行包含两个整数 $u_i, v_i$（$1 \\le u_i, v_i \\le 2N$），表示 $u_i$ 与 $v_i$ 是朋友。", "outputFormat": "第一行包含一个整数 $K$，表示最多能听到故事的人数。\n\n第二行包含 $K$ 个整数，给出满足条件的序列。若有多种可能的答案，输出任意一种即可。", "hint": "#### 【样例解释】\n\n样例 #1 解释：参加宴会的同事配对为：$(1,2)$、$(3,4)$。\n\n样例 #2 解释：参加宴会的同事配对为：$(1,6)$、$(2,3)$、$(4,5)$。可以证明不存在更长的可行序列。\n\n例如序列 $(3,2,1,4,5)$，虽然相邻两人都是朋友，但 $1$ 从 $2$ 听到故事后无法把故事告诉 $4$，因为 $1$ 的宴会搭档 $6$ 仍不知道故事（规则 3 的优先级阻止了该传播）。\n\n#### 【子任务】\n\n| 子任务 | 分值 | 限制 |\n|:---:|:---:|:---:|\n| $1$ | $24$ | $N \\le 10$ |\n| $2$ | $16$ | 每位同事最多与 $2$ 位同事是朋友 |\n| $3$ | $30$ | $N \\le 2000$，$M \\le 5000$ |\n| $4$ | $40$ | 无额外限制 |", "locale": "zh-CN"}}}
{"pid": "P14780", "type": "P", "difficulty": 6, "samples": [["4\n1 2\n1 3\n1 4", "4 12 6 1"], ["4\n1 2\n2 3\n1 4", "4 12 4 0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "O2优化", "树形 DP", "COCI（克罗地亚）"], "title": "[COCI 2025/2026 #3] 国家 / Drzava", "background": "本题满分 $110$。", "description": "在遥远的 Airlanvaosma-i 国度，有 $n$ 座城市，由 $n-1$ 条道路连接，且从任意城市到任意城市都能到达。并且任意两座城市之间的最短路经过的道路数都小于 $36$。\n\nKrešimir 想建立自己的国家。一个国家必须选择：\n- $1$ 个**首都**（从这里治理国家）；\n- 若干个（可以为 $0$ 个）**次级城市**（归首都管辖）。\n\n国家的规模定义为该国家包含的城市总数（包含首都和所有次级城市）。\n\n为了保证治理效率，Krešimir 规定：\n\n- 对每一个次级城市，在从首都到该次级城市的路径上，**不能出现其他次级城市**。  \n  换句话说：不允许某个次级城市位于首都与另一个次级城市之间。\n\n对每个规模 $k$（$1 \\le k \\le n$），求 Krešimir 能建立多少个不同规模为 $k$ 的国家。答案可能很大，请输出它对 $10^9+7$ 取模的结果。\n\n定义两个国家建立方案不同，当且仅当两个国家在“首都选择”或“任一被选为次级城市的城市”上有不同。", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 3000$），表示城市数量。\n\n接下来 $n-1$ 行，每行包含两个整数 $u, v$（$1 \\le u, v \\le n$，$u \\ne v$），表示城市 $u$ 与 $v$ 之间有道路。", "outputFormat": "输出一行包含 $n$ 个整数，分别表示规模为 $1,2,\\dots,n$ 的国家数量对 $10^9+7$ 取模的值。", "hint": "#### 【样例解释】\n\n样例 #2 解释：\n\n- 规模为 $1$：只有选首都，因此共 $4$ 种方案。\n- 规模为 $2$：先选首都（$4$ 种），再选 $1$ 个次级城市（剩下 $3$ 种），因此共 $12$ 种方案。\n- 规模为 $3$：当首都选 $1$ 或 $2$ 时，各有 $2$ 种方案选择 $2$ 个次级城市，因此共 $4$ 种方案。\n\n#### 【子任务】\n\n| 子任务 | 分值 | 限制 |\n|:---:|:---:|:---:|\n| $1$ | $18$ | $1 \\le n \\le 15$ |\n| $2$ | $17$ | $1 \\le n \\le 200$ |\n| $3$ | $26$ | $1 \\le n \\le 600$ |\n| $4$ | $49$ | 无额外限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2025/2026 #3] 国家 / Drzava", "background": "本题满分 $110$。", "description": "在遥远的 Airlanvaosma-i 国度，有 $n$ 座城市，由 $n-1$ 条道路连接，且从任意城市到任意城市都能到达。并且任意两座城市之间的最短路经过的道路数都小于 $36$。\n\nKrešimir 想建立自己的国家。一个国家必须选择：\n- $1$ 个**首都**（从这里治理国家）；\n- 若干个（可以为 $0$ 个）**次级城市**（归首都管辖）。\n\n国家的规模定义为该国家包含的城市总数（包含首都和所有次级城市）。\n\n为了保证治理效率，Krešimir 规定：\n\n- 对每一个次级城市，在从首都到该次级城市的路径上，**不能出现其他次级城市**。  \n  换句话说：不允许某个次级城市位于首都与另一个次级城市之间。\n\n对每个规模 $k$（$1 \\le k \\le n$），求 Krešimir 能建立多少个不同规模为 $k$ 的国家。答案可能很大，请输出它对 $10^9+7$ 取模的结果。\n\n定义两个国家建立方案不同，当且仅当两个国家在“首都选择”或“任一被选为次级城市的城市”上有不同。", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 3000$），表示城市数量。\n\n接下来 $n-1$ 行，每行包含两个整数 $u, v$（$1 \\le u, v \\le n$，$u \\ne v$），表示城市 $u$ 与 $v$ 之间有道路。", "outputFormat": "输出一行包含 $n$ 个整数，分别表示规模为 $1,2,\\dots,n$ 的国家数量对 $10^9+7$ 取模的值。", "hint": "#### 【样例解释】\n\n样例 #2 解释：\n\n- 规模为 $1$：只有选首都，因此共 $4$ 种方案。\n- 规模为 $2$：先选首都（$4$ 种），再选 $1$ 个次级城市（剩下 $3$ 种），因此共 $12$ 种方案。\n- 规模为 $3$：当首都选 $1$ 或 $2$ 时，各有 $2$ 种方案选择 $2$ 个次级城市，因此共 $4$ 种方案。\n\n#### 【子任务】\n\n| 子任务 | 分值 | 限制 |\n|:---:|:---:|:---:|\n| $1$ | $18$ | $1 \\le n \\le 15$ |\n| $2$ | $17$ | $1 \\le n \\le 200$ |\n| $3$ | $26$ | $1 \\le n \\le 600$ |\n| $4$ | $49$ | 无额外限制 |", "locale": "zh-CN"}}}
{"pid": "P14781", "type": "P", "difficulty": 3, "samples": [["3\n4 6 4\n2 3 4", "10"], ["3\n4 6 3\n3 3 2", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2025", "数论", "O2优化", "最大公约数 gcd", "COCI（克罗地亚）"], "title": "[COCI 2025/2026 #3] 尺子 / Ravnalo", "background": "本题满分 $110$。", "description": "建筑师 Hrvoje 需要画出一堵由竖直柱子组成的不规则墙。\n\n墙由 $n$ 根紧挨着摆放的柱子组成，第 $i$ 根柱子的高度为 $a_i$，宽度为 $1$。为了让图更复杂，第 $i$ 根柱子会被水平等分为 $b_i$ 段（每段高度相等）。\n\nHrvoje 只有直尺和铅笔。他一次落笔可以画出**一条线段**（两个点间的直线），且画线段过程中不能抬笔。目标是用尽可能少的线段画出整堵墙，包括：\n\n- 所有柱子的外边界；\n- 每根柱子内部的所有分割边界（等分线）。\n\n请输出画完整堵墙所需的最少线段数。", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 10^5$）。\n\n第二行包含 $n$ 个整数 $a_i$（$1 \\le a_i \\le 10^9$）。\n\n第三行包含 $n$ 个整数 $b_i$（$1 \\le b_i \\le 10^9$）。", "outputFormat": "输出一行，包含一个整数，表示最少需要的线段数。", "hint": "#### 【样例解释】\n\n样例 #2 解释：如图，Hrvoje 会把第 $1$ 根柱子最上方的一条线段延伸到第 $2$ 根柱子，从而把两条线段“合并”为一条；他也会对墙底部的 $3$ 条线段做同样处理。最终总共画 $12$ 条线段，并且可以证明这是最小值。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d4ahctka.png)\n\n#### 【子任务】\n\n| 子任务 | 分值 | 限制 |\n|:---:|:---:|:---:|\n| $1$ | $11$ | $n = 1$ |\n| $2$ | $13$ | $n = 2$，且 $1 \\le a_i, b_i \\le 10$ |\n| $3$ | $29$ | $1 \\le a_i \\le 10^6$，且对每个 $i$，$b_i$ 整除 $a_i$ |\n| $4$ | $57$ | 无额外限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2025/2026 #3] 尺子 / Ravnalo", "background": "本题满分 $110$。", "description": "建筑师 Hrvoje 需要画出一堵由竖直柱子组成的不规则墙。\n\n墙由 $n$ 根紧挨着摆放的柱子组成，第 $i$ 根柱子的高度为 $a_i$，宽度为 $1$。为了让图更复杂，第 $i$ 根柱子会被水平等分为 $b_i$ 段（每段高度相等）。\n\nHrvoje 只有直尺和铅笔。他一次落笔可以画出**一条线段**（两个点间的直线），且画线段过程中不能抬笔。目标是用尽可能少的线段画出整堵墙，包括：\n\n- 所有柱子的外边界；\n- 每根柱子内部的所有分割边界（等分线）。\n\n请输出画完整堵墙所需的最少线段数。", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 10^5$）。\n\n第二行包含 $n$ 个整数 $a_i$（$1 \\le a_i \\le 10^9$）。\n\n第三行包含 $n$ 个整数 $b_i$（$1 \\le b_i \\le 10^9$）。", "outputFormat": "输出一行，包含一个整数，表示最少需要的线段数。", "hint": "#### 【样例解释】\n\n样例 #2 解释：如图，Hrvoje 会把第 $1$ 根柱子最上方的一条线段延伸到第 $2$ 根柱子，从而把两条线段“合并”为一条；他也会对墙底部的 $3$ 条线段做同样处理。最终总共画 $12$ 条线段，并且可以证明这是最小值。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d4ahctka.png)\n\n#### 【子任务】\n\n| 子任务 | 分值 | 限制 |\n|:---:|:---:|:---:|\n| $1$ | $11$ | $n = 1$ |\n| $2$ | $13$ | $n = 2$，且 $1 \\le a_i, b_i \\le 10$ |\n| $3$ | $29$ | $1 \\le a_i \\le 10^6$，且对每个 $i$，$b_i$ 整除 $a_i$ |\n| $4$ | $57$ | 无额外限制 |", "locale": "zh-CN"}}}
{"pid": "P14782", "type": "P", "difficulty": 2, "samples": [["3 10\nNEERC\nNERC\nNEF", "9 9 -1"], ["4 4\nLENSE\nTEN\nSENSELESSNESSES\nLENSE", "3 -1 0 3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "二分", "2025", "ICPC", "NERC/NEERC"], "title": "[NERC 2025] Alphabet City", "background": "", "description": "Al is an urban designer in Alphabet City, and today their task is to prepare signs for $n$ city streets. In Alphabet City, the street signs simply consist of the street names composed of capital identically stamped English metal letters. For instance, if, during nighttime, someone sneakily exchanges the first letters on NERC street and on NEF street, the next day nobody will see the difference as the letter 'N' is identical on both signs.\n\nAl is planning to put $m$ signs on each street, and they have already ordered the required number of brass letters for each of the street names from the metallurgical plant. However, one hour before the order arrived, Al got a call from the plant’s manager with a devastating piece of news: they lost one of the items from the list of street names! To mitigate the issue, Al decided for now to put as many signs as possible on each street whose order was not lost, and, with the leftover letters, to prepare at least one sign for the street whose order was lost.\n\nFormally, if $s_1, \\dots, s_n$ are the street names, and $\\ell$ is the index of the missing item from the order, Al is interested in the maximum integer $k$ such that it is possible, from all the letters of $m$ copies of $s_1, \\dots, s_{\\ell-1}, s_{\\ell+1}, \\dots, s_n$, to compose $k$ copies of $s_1, \\dots, s_{\\ell-1}, s_{\\ell+1}, \\dots, s_n$ and additionally at least one copy of $s_\\ell$, or to determine that such a composition is impossible for any non-negative $k$. Al still does not know which of the items was lost. Write a program that, given $m$ and all street names, for each $\\ell \\in \\{1, 2, \\dots, n\\}$ prints the maximum value of $k$, or $-1$ if such a composition is impossible.\n", "inputFormat": "The first line consists of two integers $n$ and $m$, denoting the number of streets in Alphabet City for which the signs are needed and the number of copies of each street name that Al initially ordered ($2 \\le n \\le 2 \\cdot 10^5$; $1 \\le m \\le 5 \\cdot 10^5$). Each of the next $n$ lines consists of one string $s_i$ — the street name ($1 \\le |s_i| \\le 5 \\cdot 10^5$). All these names are composed of capital English letters. Some or all of these names may coincide. It is guaranteed that the sum of the lengths of all the street names does not exceed $5 \\cdot 10^5$.\n", "outputFormat": "Print $n$ integers, the $\\ell$-th of them denoting the maximum integer $k$ such that the letters of $m \\times s_1, \\dots, m \\times s_{\\ell-1}, m \\times s_{\\ell+1}, \\dots, m \\times s_n$ (where $m \\times s$ denotes $m$ copies of street name $s$) are enough to compose $k \\times s_1, \\dots, k \\times s_{\\ell-1}, 1 \\times s_\\ell, k \\times s_{\\ell+1}, \\dots, k \\times s_n$. If, for the given value of $\\ell$, these letters are insufficient for any integer $k \\ge 0$, print $-1$ instead.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2025] Alphabet City", "background": "", "description": "Al is an urban designer in Alphabet City, and today their task is to prepare signs for $n$ city streets. In Alphabet City, the street signs simply consist of the street names composed of capital identically stamped English metal letters. For instance, if, during nighttime, someone sneakily exchanges the first letters on NERC street and on NEF street, the next day nobody will see the difference as the letter 'N' is identical on both signs.\n\nAl is planning to put $m$ signs on each street, and they have already ordered the required number of brass letters for each of the street names from the metallurgical plant. However, one hour before the order arrived, Al got a call from the plant’s manager with a devastating piece of news: they lost one of the items from the list of street names! To mitigate the issue, Al decided for now to put as many signs as possible on each street whose order was not lost, and, with the leftover letters, to prepare at least one sign for the street whose order was lost.\n\nFormally, if $s_1, \\dots, s_n$ are the street names, and $\\ell$ is the index of the missing item from the order, Al is interested in the maximum integer $k$ such that it is possible, from all the letters of $m$ copies of $s_1, \\dots, s_{\\ell-1}, s_{\\ell+1}, \\dots, s_n$, to compose $k$ copies of $s_1, \\dots, s_{\\ell-1}, s_{\\ell+1}, \\dots, s_n$ and additionally at least one copy of $s_\\ell$, or to determine that such a composition is impossible for any non-negative $k$. Al still does not know which of the items was lost. Write a program that, given $m$ and all street names, for each $\\ell \\in \\{1, 2, \\dots, n\\}$ prints the maximum value of $k$, or $-1$ if such a composition is impossible.\n", "inputFormat": "The first line consists of two integers $n$ and $m$, denoting the number of streets in Alphabet City for which the signs are needed and the number of copies of each street name that Al initially ordered ($2 \\le n \\le 2 \\cdot 10^5$; $1 \\le m \\le 5 \\cdot 10^5$). Each of the next $n$ lines consists of one string $s_i$ — the street name ($1 \\le |s_i| \\le 5 \\cdot 10^5$). All these names are composed of capital English letters. Some or all of these names may coincide. It is guaranteed that the sum of the lengths of all the street names does not exceed $5 \\cdot 10^5$.\n", "outputFormat": "Print $n$ integers, the $\\ell$-th of them denoting the maximum integer $k$ such that the letters of $m \\times s_1, \\dots, m \\times s_{\\ell-1}, m \\times s_{\\ell+1}, \\dots, m \\times s_n$ (where $m \\times s$ denotes $m$ copies of street name $s$) are enough to compose $k \\times s_1, \\dots, k \\times s_{\\ell-1}, 1 \\times s_\\ell, k \\times s_{\\ell+1}, \\dots, k \\times s_n$. If, for the given value of $\\ell$, these letters are insufficient for any integer $k \\ge 0$, print $-1$ instead.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2025] Alphabet City", "background": "", "description": "Al 是字母城的一位城市规划师，今天他的任务是为 $n$ 条城市街道准备路牌。在字母城，路牌仅由大写、完全相同的金属字母模印的街道名称组成。例如，如果在夜间有人偷偷交换了 NERC 街和 NEF 街路牌上的第一个字母，第二天不会有人发现异常，因为两个牌子上的字母 'N' 是相同的。\n\nAl 计划为每条街道放置 $m$ 个路牌，并且他已经从金属加工厂订购了每个街道名称所需数量的黄铜字母。然而，在订单到达前一个小时，Al 接到了工厂经理的电话，带来了一个毁灭性的消息：他们丢失了街道名称清单中的一项！为了缓解这个问题，Al 决定暂时为订单未丢失的每条街道尽可能多地放置路牌，并用剩余的字母为订单丢失的那条街道至少制作一个路牌。\n\n形式化地说，如果 $s_1, \\dots, s_n$ 是街道名称，$\\ell$ 是订单中丢失项的索引，Al 想知道最大的整数 $k$，使得从 $m$ 份 $s_1, \\dots, s_{\\ell-1}, s_{\\ell+1}, \\dots, s_n$ 的所有字母中，可以拼凑出 $k$ 份 $s_1, \\dots, s_{\\ell-1}, s_{\\ell+1}, \\dots, s_n$ 以及至少一份 $s_\\ell$；或者确定对于任何非负整数 $k$ 这样的拼凑都是不可能的。Al 仍然不知道具体丢失了哪一项。请编写一个程序，给定 $m$ 和所有街道名称，对于每个 $\\ell \\in \\{1, 2, \\dots, n\\}$，输出 $k$ 的最大值；如果这样的拼凑不可能，则输出 $-1$。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$，分别表示需要制作路牌的街道数量和 Al 最初订购的每个街道名称的副本数 ($2 \\le n \\le 2 \\cdot 10^5$；$1 \\le m \\le 5 \\cdot 10^5$)。接下来的 $n$ 行，每行包含一个字符串 $s_i$ —— 街道名称 ($1 \\le |s_i| \\le 5 \\cdot 10^5$)。所有这些名称都由大写英文字母组成。部分或全部名称可能相同。保证所有街道名称的长度之和不超过 $5 \\cdot 10^5$。", "outputFormat": "输出 $n$ 个整数，第 $\\ell$ 个表示最大的整数 $k$，使得 $m \\times s_1, \\dots, m \\times s_{\\ell-1}, m \\times s_{\\ell+1}, \\dots, m \\times s_n$（其中 $m \\times s$ 表示街道名称 $s$ 的 $m$ 个副本）的字母足够拼凑出 $k \\times s_1, \\dots, k \\times s_{\\ell-1}, 1 \\times s_\\ell, k \\times s_{\\ell+1}, \\dots, k \\times s_n$。如果对于给定的 $\\ell$ 值，这些字母不足以拼凑出任何整数 $k \\ge 0$ 的情况，则输出 $-1$。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14783", "type": "P", "difficulty": 3, "samples": [["2\n1 1\n70\n90\n2 3\n30 30\n20 20 40", "Alice\nBob"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "堆", "2025", "优先队列", "ICPC", "NERC/NEERC"], "title": "[NERC 2025] Battle of Arrays", "background": null, "description": "Alice and Bob play a turn-based game. Initially, Alice has an array $a$ of $n$ positive integers, and Bob has an array $b$ of $m$ positive integers. The players take turns, with Alice moving first.\n\nOn a player’s turn, they must choose one element $x$ from their own array and **the maximal** element $y$ from their opponent’s array. Then they perform the following operation:\n\n- If $y \\le x$: the element $y$ is destroyed (removed from the opponent’s array).\n- If $y > x$: the element $y$ is decreased by $x$ (the value of $y$ becomes $y - x$).\n\nA player wins if, after their move, the opponent’s array becomes empty.\n\nAssuming both players play optimally, determine the winner.", "inputFormat": "Each input contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^5$). The first line of each test case contains two integers $n$ and $m$ ($1 \\le n, m \\le 10^5$) — the sizes of Alice’s and Bob’s arrays respectively.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$) — Alice’s array.\n\nThe third line contains $m$ integers $b_1, b_2, \\dots, b_m$ ($1 \\le b_i \\le 10^9$) — Bob’s array.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$ and the sum of $m$ over all test cases does not exceed $10^5$.", "outputFormat": "For each test case, print the name of the winner of the game if both players follow the optimal strategy: “Alice” or “Bob”.", "hint": "In the first test Alice moves and decreases Bob’s element by $70$, so it becomes $20$. Then Bob moves and decreases Alice’s element by $20$, so it becomes $50$. Finally, Alice moves, destroys Bob’s element, and wins.", "locale": "en", "translations": {"en": {"title": "[NERC 2025] Battle of Arrays", "background": null, "description": "Alice and Bob play a turn-based game. Initially, Alice has an array $a$ of $n$ positive integers, and Bob has an array $b$ of $m$ positive integers. The players take turns, with Alice moving first.\n\nOn a player’s turn, they must choose one element $x$ from their own array and **the maximal** element $y$ from their opponent’s array. Then they perform the following operation:\n\n- If $y \\le x$: the element $y$ is destroyed (removed from the opponent’s array).\n- If $y > x$: the element $y$ is decreased by $x$ (the value of $y$ becomes $y - x$).\n\nA player wins if, after their move, the opponent’s array becomes empty.\n\nAssuming both players play optimally, determine the winner.", "inputFormat": "Each input contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^5$). The first line of each test case contains two integers $n$ and $m$ ($1 \\le n, m \\le 10^5$) — the sizes of Alice’s and Bob’s arrays respectively.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$) — Alice’s array.\n\nThe third line contains $m$ integers $b_1, b_2, \\dots, b_m$ ($1 \\le b_i \\le 10^9$) — Bob’s array.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$ and the sum of $m$ over all test cases does not exceed $10^5$.", "outputFormat": "For each test case, print the name of the winner of the game if both players follow the optimal strategy: “Alice” or “Bob”.", "hint": "In the first test Alice moves and decreases Bob’s element by $70$, so it becomes $20$. Then Bob moves and decreases Alice’s element by $20$, so it becomes $50$. Finally, Alice moves, destroys Bob’s element, and wins.", "locale": "en"}, "zh-CN": {"title": "[NERC 2025] Battle of Arrays", "background": null, "description": "Alice 和 Bob 正在玩一个回合制游戏。初始时，Alice 拥有一个包含 $n$ 个正整数的数组 $a$，Bob 拥有一个包含 $m$ 个正整数的数组 $b$。玩家轮流行动，Alice 先手。\n\n在轮到一名玩家时，他必须从自己的数组中选取一个元素 $x$，并从对手的数组中选取**最大的**元素 $y$。然后执行以下操作：\n\n- 如果 $y \\le x$：元素 $y$ 被摧毁（从对手的数组中移除）。\n- 如果 $y > x$：元素 $y$ 减少 $x$（$y$ 的值变为 $y - x$）。\n\n如果一名玩家在移动后，对手的数组变为空，则该玩家获胜。\n\n假设双方都采取最优策略，请确定获胜者。", "inputFormat": "每个输入包含多个测试用例。第一行包含测试用例的数量 $t$ ($1 \\le t \\le 10^5$)。每个测试用例的第一行包含两个整数 $n$ 和 $m$ ($1 \\le n, m \\le 10^5$) —— 分别表示 Alice 和 Bob 数组的大小。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$) —— Alice 的数组。\n\n第三行包含 $m$ 个整数 $b_1, b_2, \\dots, b_m$ ($1 \\le b_i \\le 10^9$) —— Bob 的数组。\n\n保证所有测试用例的 $n$ 之和不超过 $10^5$，所有测试用例的 $m$ 之和也不超过 $10^5$。", "outputFormat": "对于每个测试用例，如果双方都遵循最优策略，请输出游戏的获胜者名字：“Alice” 或 “Bob”。", "hint": "在第一个测试用例中，Alice 移动并将 Bob 的元素减少 $70$，使其变为 $20$。然后 Bob 移动并将 Alice 的元素减少 $20$，使其变为 $50$。最后，Alice 移动，摧毁 Bob 的元素，并获胜。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14784", "type": "P", "difficulty": 7, "samples": [["1\n7\n\n0\n\n1\n\n1\n\n1", "\n\n\n? 0 1\n\n? 0 3\n\n? 2 4\n\n! -1 3 1 3 2 3 2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "交互题", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2025] Cacti Classification", "background": "", "description": "Ivan and Petr like to play with **cacti** — special graphs where each edge belongs to at most one simple cycle, and the graph is connected. Multiple edges between pairs of vertices and loops are allowed.\n\nThey invent the following game:\n\n- Petr secretly builds a cactus with $n$ vertices and $m$ edges. The edges are labeled from $1$ to $m$.\n- Petr only tells Ivan the number $m$.\n- Ivan is then allowed to ask questions of the following form:\n  - He chooses a subset $S$ of edge labels (see below about limitations on the subset), and asks: “If we only keep the edges whose labels are in $S$ (and all $n$ vertices), is the resulting graph connected?”\n  - Petr must answer either “yes” or “no”.\n\nAfter asking at most $8m$ questions, Ivan must determine, for every edge:\n\n1. whether this edge lies on some cycle in the cactus;\n2. if it does, what is the length of that simple cycle.\n\nIn this problem, each loop is considered a simple cycle of length $1$ and two edges between the same pair of vertices form a simple cycle of length $2$.\n\nHowever, Ivan is still very young and only knows numbers up to $14$. So:\n\n- if an edge lies on a simple cycle of length at most $14$, he must output that exact length;\n- if an edge lies on a simple cycle of length greater than $14$, he must say that this edge lies on a **big cycle**.\n\nAlso, to avoid having to list a lot of edges each time, Ivan always asks about an edge set obtained from the set used in one of the previous queries, or from the set of all edges, by removing exactly one edge.\n\nCan you design a strategy that allows Ivan to complete this task?", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe first line of each test case contains $m$ ($1 \\le m \\le 10^4$) — the number of edges in the cactus.\n\nIt is guaranteed that the sum of $m$ over all test cases does not exceed $10^4$.\n\n### Interaction Protocol\n\nTo ask a query, output a line in the following format (without the quotes):\n\n- `? p e` ($0 \\le p \\le q$; $1 \\le e \\le m$), where $p$ is the number of a previous query or zero (queries are numbered from $1$ in the order they are asked), $q$ is the number of queries made before the current one, $e$ is the label of an edge.\n\nThe query denotes a graph consisting of the edges used in the query number $p$ (or all edges if $p = 0$), with edge $e$ removed. The interactor checks whether this graph is connected when considering **all original vertices** and returns a single integer:\n\n- $1$ if the graph denoted by the query is connected;\n- $0$ if the graph denoted by the query is not connected;\n- $-1$ if you have exceeded $8m$ allowed queries or edge $e$ was already removed from the set of edges used in query $p$. In this case you should terminate your program to receive a Wrong Answer verdict.\n\nWhen you have found the answer, output a single line in the following format:\n\n- `! e_1 e_2 … e_m` ($-1 \\le e_i \\le 14$ for all $i$),\n\nwhere:\n\n- if $e_i$ is positive, then edge number $i$ belongs to a simple cycle of length exactly $e_i$;\n- if $e_i = 0$, then edge number $i$ belongs to a **big cycle** (simple cycle of length greater than $14$);\n- if $e_i = -1$, then edge number $i$ does not belong to any cycle.\n\nThe interactor returns a single integer:\n\n- $1$ if your answer is correct. Proceed to the next test case or terminate your program if this was the last case.\n- $-1$ if your answer is incorrect. In this case you should terminate your program to receive a Wrong Answer verdict.\n\nThe interactor is **not adaptive**, meaning that the graph is fixed before you ask any queries.\n", "outputFormat": "", "hint": "In the example interaction, the input and output contain empty lines to align interactor responses with queries. These empty lines do not appear in the actual input and output.\n\nIn this example, the graph has $5$ vertices and $7$ edges; edges $1$ through $7$, in this order, are $(1,2)$, $(2,3)$, $(3,3)$, $(3,4)$, $(4,5)$, $(2,4)$, $(4,5)$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/xd7f8r2w.png)\n:::", "locale": "en", "translations": {"en": {"title": "[NERC 2025] Cacti Classification", "background": "", "description": "Ivan and Petr like to play with **cacti** — special graphs where each edge belongs to at most one simple cycle, and the graph is connected. Multiple edges between pairs of vertices and loops are allowed.\n\nThey invent the following game:\n\n- Petr secretly builds a cactus with $n$ vertices and $m$ edges. The edges are labeled from $1$ to $m$.\n- Petr only tells Ivan the number $m$.\n- Ivan is then allowed to ask questions of the following form:\n  - He chooses a subset $S$ of edge labels (see below about limitations on the subset), and asks: “If we only keep the edges whose labels are in $S$ (and all $n$ vertices), is the resulting graph connected?”\n  - Petr must answer either “yes” or “no”.\n\nAfter asking at most $8m$ questions, Ivan must determine, for every edge:\n\n1. whether this edge lies on some cycle in the cactus;\n2. if it does, what is the length of that simple cycle.\n\nIn this problem, each loop is considered a simple cycle of length $1$ and two edges between the same pair of vertices form a simple cycle of length $2$.\n\nHowever, Ivan is still very young and only knows numbers up to $14$. So:\n\n- if an edge lies on a simple cycle of length at most $14$, he must output that exact length;\n- if an edge lies on a simple cycle of length greater than $14$, he must say that this edge lies on a **big cycle**.\n\nAlso, to avoid having to list a lot of edges each time, Ivan always asks about an edge set obtained from the set used in one of the previous queries, or from the set of all edges, by removing exactly one edge.\n\nCan you design a strategy that allows Ivan to complete this task?", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 100$). The description of the test cases follows.\n\nThe first line of each test case contains $m$ ($1 \\le m \\le 10^4$) — the number of edges in the cactus.\n\nIt is guaranteed that the sum of $m$ over all test cases does not exceed $10^4$.\n\n### Interaction Protocol\n\nTo ask a query, output a line in the following format (without the quotes):\n\n- `? p e` ($0 \\le p \\le q$; $1 \\le e \\le m$), where $p$ is the number of a previous query or zero (queries are numbered from $1$ in the order they are asked), $q$ is the number of queries made before the current one, $e$ is the label of an edge.\n\nThe query denotes a graph consisting of the edges used in the query number $p$ (or all edges if $p = 0$), with edge $e$ removed. The interactor checks whether this graph is connected when considering **all original vertices** and returns a single integer:\n\n- $1$ if the graph denoted by the query is connected;\n- $0$ if the graph denoted by the query is not connected;\n- $-1$ if you have exceeded $8m$ allowed queries or edge $e$ was already removed from the set of edges used in query $p$. In this case you should terminate your program to receive a Wrong Answer verdict.\n\nWhen you have found the answer, output a single line in the following format:\n\n- `! e_1 e_2 … e_m` ($-1 \\le e_i \\le 14$ for all $i$),\n\nwhere:\n\n- if $e_i$ is positive, then edge number $i$ belongs to a simple cycle of length exactly $e_i$;\n- if $e_i = 0$, then edge number $i$ belongs to a **big cycle** (simple cycle of length greater than $14$);\n- if $e_i = -1$, then edge number $i$ does not belong to any cycle.\n\nThe interactor returns a single integer:\n\n- $1$ if your answer is correct. Proceed to the next test case or terminate your program if this was the last case.\n- $-1$ if your answer is incorrect. In this case you should terminate your program to receive a Wrong Answer verdict.\n\nThe interactor is **not adaptive**, meaning that the graph is fixed before you ask any queries.\n", "outputFormat": "", "hint": "In the example interaction, the input and output contain empty lines to align interactor responses with queries. These empty lines do not appear in the actual input and output.\n\nIn this example, the graph has $5$ vertices and $7$ edges; edges $1$ through $7$, in this order, are $(1,2)$, $(2,3)$, $(3,3)$, $(3,4)$, $(4,5)$, $(2,4)$, $(4,5)$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/xd7f8r2w.png)\n:::", "locale": "en"}, "zh-CN": {"title": "[NERC 2025] Cacti Classification", "background": "", "description": "Ivan 和 Petr 喜欢玩 **仙人掌图** —— 这是一种特殊的图，其中每条边最多属于一个简单环，且图是连通的。允许一对顶点之间存在多条边，也允许自环。\n\n他们发明了以下游戏：\n\n- Petr 秘密地构建一个有 $n$ 个顶点和 $m$ 条边的仙人掌图。这些边被标记为 $1$ 到 $m$。\n- Petr 只告诉 Ivan 数字 $m$。\n- 然后 Ivan 被允许提出以下形式的问题：\n  - 他选择一个边标签的子集 $S$（关于子集的限制见下文），并问：“如果我们只保留标签在 $S$ 中的边（以及所有 $n$ 个顶点），得到的图是否连通？”\n  - Petr 必须回答 “yes” 或 “no”。\n\n在最多提出 $8m$ 个问题后，Ivan 必须确定每条边：\n\n1. 这条边是否位于仙人掌图的某个环上；\n2. 如果是，该简单环的长度是多少。\n\n在这个问题中，每个自环被视为长度为 $1$ 的简单环，而同一对顶点之间的两条边构成一个长度为 $2$ 的简单环。\n\n然而，Ivan 还很年轻，只认识不超过 $14$ 的数字。因此：\n\n- 如果一条边位于长度不超过 $14$ 的简单环上，他必须输出该确切长度；\n- 如果一条边位于长度大于 $14$ 的简单环上，他必须说这条边位于一个 **大环** 上。\n\n此外，为了避免每次列出很多条边，Ivan 总是询问从之前某个查询使用的边集，或从所有边的集合中，恰好移除一条边所得到的边集。\n\n你能设计一个策略让 Ivan 完成这个任务吗？", "inputFormat": "每个测试包含多个测试用例。第一行包含测试用例的数量 $t$ ($1 \\le t \\le 100$)。接下来是测试用例的描述。\n\n每个测试用例的第一行包含 $m$ ($1 \\le m \\le 10^4$) —— 仙人掌图中边的数量。\n\n保证所有测试用例的 $m$ 之和不超过 $10^4$。\n\n### 交互协议\n\n要提出一个查询，请按以下格式输出一行（不含引号）：\n\n- `? p e` ($0 \\le p \\le q$；$1 \\le e \\le m$)，其中 $p$ 是之前某个查询的编号，或为零（查询按提出顺序从 $1$ 开始编号），$q$ 是当前查询之前已提出的查询数量，$e$ 是一条边的标签。\n\n该查询表示一个图，由查询编号 $p$ 中使用的边（如果 $p = 0$ 则表示所有边）去除边 $e$ 后组成。交互器检查该图在考虑 **所有原始顶点** 时是否连通，并返回一个整数：\n\n- $1$ 如果查询所表示的图是连通的；\n- $0$ 如果查询所表示的图不是连通的；\n- $-1$ 如果你超出了 $8m$ 个允许的查询，或者边 $e$ 已经从查询 $p$ 使用的边集中被移除了。在这种情况下，你应该终止程序以收到 Wrong Answer 的判定。\n\n当你找到答案时，按以下格式输出一行：\n\n- `! e_1 e_2 … e_m`（对所有 $i$，$-1 \\le e_i \\le 14$），\n\n其中：\n\n- 如果 $e_i$ 为正数，则编号为 $i$ 的边属于一个长度恰好为 $e_i$ 的简单环；\n- 如果 $e_i = 0$，则编号为 $i$ 的边属于一个 **大环**（长度大于 $14$ 的简单环）；\n- 如果 $e_i = -1$，则编号为 $i$ 的边不属于任何环。\n\n交互器返回一个整数：\n\n- $1$ 如果你的答案正确。继续下一个测试用例，或者如果是最后一个用例则终止程序。\n- $-1$ 如果你的答案不正确。在这种情况下，你应该终止程序以收到 Wrong Answer 的判定。\n\n交互器是 **非自适应的**，这意味着图在你提出任何查询之前就已经固定了。", "outputFormat": "", "hint": "在示例交互中，输入和输出包含空行以使交互器的响应与查询对齐。这些空行在实际的输入和输出中不会出现。\n\n在这个例子中，图有 $5$ 个顶点和 $7$ 条边；边 $1$ 到 $7$，按顺序依次是 $(1,2)$、$(2,3)$、$(3,3)$、$(3,4)$、$(4,5)$、$(2,4)$、$(4,5)$。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/xd7f8r2w.png)\n:::", "locale": "zh-CN"}}}
{"pid": "P14785", "type": "P", "difficulty": 4, "samples": [["2\n2 2 11 3 2\n3 4 12 1 1 2", "4"], ["2\n2 0 7 2 4\n1 4 9 4", "0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "线段树", "2025", "排序", "ICPC", "NERC/NEERC", "STL"], "title": "[NERC 2025] Doorway", "background": "", "description": "The construction of the doorway for the Nonsense Engineering and Research Convention was delegated to one of the future attendees, who decided on a multi-layered sliding door design.\n\nEach layer can be described as a horizontal interval, bounded by solid walls on the left and right, containing a number of sliding doors of fixed lengths. Within a layer, each door can move independently to the left or right, as long as it does not overlap other doors or the walls. All layers are parallel and stacked vertically.\n\nAfter construction, the organizers noticed a problem: it is difficult to fully open the door, and since a large number of attendees are expected, they need to create the largest possible opening to allow everyone to pass through freely.\n\nThe size of the opening is defined as the total length of horizontal intervals such that, at every point of such an interval and in every layer, there is neither a door nor a wall. Your task is to determine the largest possible opening, given the doors’ layout.\n", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 100\\,000$) — the number of layers of the door.\n\nEach of the next $n$ lines starts with three integers $k_i$, $x_{i,1}$, $x_{i,2}$ ($0 \\le k_i \\le 300\\,000$; $0 \\le x_{i,1} < x_{i,2} \\le 10^9$) — the number of sliding doors on that layer and the $x$-coordinates $x_{i,1}$ and $x_{i,2}$ of the walls on that layer. There is a wall at $x_{i,1}$ and a wall at $x_{i,2}$; all positions with $x < x_{i,1}$ or $x > x_{i,2}$ are blocked by walls.\n\nThey are followed by $k_i$ integers $l_{i,1}, \\dots, l_{i,k_i}$ ($1 \\le l_{i,j}$; $\\sum_{j=1}^{k_i} l_{i,j} \\le x_{i,2} - x_{i,1}$) — the lengths of the sliding doors on that layer given in order from the leftmost door to the rightmost.\n\nIt is guaranteed that $\\sum_{i=1}^{n} k_i \\le 300\\,000$.", "outputFormat": "Output a single integer — the size of the largest possible opening that can be achieved by moving the sliding doors on each layer.", "hint": "This illustration shows a solution for the first example. Walls are filled with black color, doors are filled with various shades of grey, the opening is white. When first doors on each layer are shifted to the left and the rest of the doors to the right, we get the largest opening of $4$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/a6lelhuy.png)\n:::", "locale": "en", "translations": {"en": {"title": "[NERC 2025] Doorway", "background": "", "description": "The construction of the doorway for the Nonsense Engineering and Research Convention was delegated to one of the future attendees, who decided on a multi-layered sliding door design.\n\nEach layer can be described as a horizontal interval, bounded by solid walls on the left and right, containing a number of sliding doors of fixed lengths. Within a layer, each door can move independently to the left or right, as long as it does not overlap other doors or the walls. All layers are parallel and stacked vertically.\n\nAfter construction, the organizers noticed a problem: it is difficult to fully open the door, and since a large number of attendees are expected, they need to create the largest possible opening to allow everyone to pass through freely.\n\nThe size of the opening is defined as the total length of horizontal intervals such that, at every point of such an interval and in every layer, there is neither a door nor a wall. Your task is to determine the largest possible opening, given the doors’ layout.\n", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 100\\,000$) — the number of layers of the door.\n\nEach of the next $n$ lines starts with three integers $k_i$, $x_{i,1}$, $x_{i,2}$ ($0 \\le k_i \\le 300\\,000$; $0 \\le x_{i,1} < x_{i,2} \\le 10^9$) — the number of sliding doors on that layer and the $x$-coordinates $x_{i,1}$ and $x_{i,2}$ of the walls on that layer. There is a wall at $x_{i,1}$ and a wall at $x_{i,2}$; all positions with $x < x_{i,1}$ or $x > x_{i,2}$ are blocked by walls.\n\nThey are followed by $k_i$ integers $l_{i,1}, \\dots, l_{i,k_i}$ ($1 \\le l_{i,j}$; $\\sum_{j=1}^{k_i} l_{i,j} \\le x_{i,2} - x_{i,1}$) — the lengths of the sliding doors on that layer given in order from the leftmost door to the rightmost.\n\nIt is guaranteed that $\\sum_{i=1}^{n} k_i \\le 300\\,000$.", "outputFormat": "Output a single integer — the size of the largest possible opening that can be achieved by moving the sliding doors on each layer.", "hint": "This illustration shows a solution for the first example. Walls are filled with black color, doors are filled with various shades of grey, the opening is white. When first doors on each layer are shifted to the left and the rest of the doors to the right, we get the largest opening of $4$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/a6lelhuy.png)\n:::", "locale": "en"}, "zh-CN": {"title": "[NERC 2025] Doorway", "background": "", "description": "Nonsense 工程与研究大会的门廊建造任务被委托给了一位未来的参会者，他决定采用多层滑动门的设计。\n\n每一层可以描述为一个水平区间，左右以实心墙为界，其中包含若干扇固定长度的滑动门。在一层之内，每扇门可以独立地向左或向右移动，只要它不与其他门或墙壁重叠。所有层都彼此平行且垂直堆叠。\n\n建造完成后，组织者发现了一个问题：很难将门完全打开，而且由于预计会有大量参会者，他们需要创造出尽可能大的开口，以便所有人都能自由通过。\n\n开口的大小定义为水平区间的总长度，使得在该区间的每一点上，每一层都没有门或墙壁。给定门的布局，你的任务是确定可能的最大开口。", "inputFormat": "第一行包含一个整数 $n$ ($1 \\le n \\le 100\\,000$) —— 门的层数。\n\n接下来的 $n$ 行，每行以三个整数 $k_i$, $x_{i,1}$, $x_{i,2}$ ($0 \\le k_i \\le 300\\,000$；$0 \\le x_{i,1} < x_{i,2} \\le 10^9$) 开始 —— 分别是该层滑动门的数量，以及该层墙壁的 $x$ 坐标 $x_{i,1}$ 和 $x_{i,2}$。在 $x_{i,1}$ 和 $x_{i,2}$ 处各有一堵墙；所有满足 $x < x_{i,1}$ 或 $x > x_{i,2}$ 的位置都被墙壁阻挡。\n\n随后跟着 $k_i$ 个整数 $l_{i,1}, \\dots, l_{i,k_i}$ ($1 \\le l_{i,j}$；$\\sum_{j=1}^{k_i} l_{i,j} \\le x_{i,2} - x_{i,1}$) —— 该层滑动门的长度，按从左到右的顺序给出。\n\n保证 $\\sum_{i=1}^{n} k_i \\le 300\\,000$。\n", "outputFormat": "输出一个整数 —— 通过移动各层的滑动门可以实现的最大可能开口的大小。", "hint": "这张图展示了第一个示例的一种解决方案。墙壁用黑色填充，门用不同的灰色阴影填充，开口为白色。当每层的第一扇门向左移动，其余门向右移动时，我们得到最大的开口 $4$。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/a6lelhuy.png)\n:::", "locale": "zh-CN"}}}
