{"pid": "P4721", "type": "P", "difficulty": 6, "samples": [["4\n3 1 2", "1 3 10 35"], ["10\n2 456 32 13524543 998244352 0 1231 634544 51", "1 2 460 1864 13738095 55389979 617768468 234028967 673827961 708520894"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["分治", "生成函数", "快速傅里叶变换 FFT", "快速数论变换 NTT", "模板题"], "title": "【模板】分治 FFT", "background": "也可用多项式求逆解决。", "description": "给定序列 $g_{1\\dots n - 1}$，求序列 $f_{0\\dots n - 1}$。\n\n其中 $f_i=\\sum_{j=1}^if_{i-j}g_j$，边界为 $f_0=1$。\n\n答案对 $998244353$ 取模。", "inputFormat": "第一行一个整数 $n$ 。\n\n第二行 $n-1$ 个整数 $g_{1\\dots n - 1}$。", "outputFormat": "一行 $n$ 个整数，表示 $f_{0\\dots n - 1}$ 对 $998244353$ 取模后的值。", "hint": "$2\\leq n\\leq 10^5$，$0\\leq g_i<998244353$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Divide and Conquer FFT", "background": "It can also be solved using polynomial inversion.", "description": "Given a sequence $g_{1\\dots n - 1}$, find the sequence $f_{0\\dots n - 1}$.\n\nHere, $f_i=\\sum_{j=1}^if_{i-j}g_j$, with the boundary condition $f_0=1$.\n\nTake the answer modulo $998244353$.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains $n-1$ integers $g_{1\\dots n - 1}$.", "outputFormat": "Output one line with $n$ integers, representing the values of $f_{0\\dots n - 1}$ modulo $998244353$.", "hint": "Constraints: $2\\leq n\\leq 10^5$, $0\\leq g_i<998244353$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】分治 FFT", "background": "也可用多项式求逆解决。", "description": "给定序列 $g_{1\\dots n - 1}$，求序列 $f_{0\\dots n - 1}$。\n\n其中 $f_i=\\sum_{j=1}^if_{i-j}g_j$，边界为 $f_0=1$。\n\n答案对 $998244353$ 取模。", "inputFormat": "第一行一个整数 $n$ 。\n\n第二行 $n-1$ 个整数 $g_{1\\dots n - 1}$。", "outputFormat": "一行 $n$ 个整数，表示 $f_{0\\dots n - 1}$ 对 $998244353$ 取模后的值。", "hint": "$2\\leq n\\leq 10^5$，$0\\leq g_i<998244353$。", "locale": "zh-CN"}}}
{"pid": "P4722", "type": "P", "difficulty": 6, "samples": [["7 14 1 7\n1 2 5\n1 3 6\n1 4 5\n2 3 2\n2 5 3\n3 2 2\n3 4 3\n3 5 3\n3 6 7\n4 6 5\n5 6 1\n6 5 1\n5 7 8\n6 7 7\n", "14"], ["10 16 1 2\n1 3 2\n1 4 2\n5 2 2\n6 2 2\n3 5 1\n3 6 1\n4 5 1\n4 6 1\n1 7 2147483647\n9 2 2147483647\n7 8 2147483647\n10 9 2147483647\n8 5 2\n8 6 2\n3 10 2\n4 10 2\n", "8"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["网络流", "O2优化", "优先队列", "队列", "模板题"], "title": "【模板】最大流 加强版 / 预流推进", "background": "", "description": "给定 $n$ 个点，$m$ 条有向边，给定每条边的容量，求从点 $s$ 到点 $t$ 的最大流。", "inputFormat": "第一行包含四个正整数 $n$、$m$、$s$、$t$，用空格分隔，分别表示点的个数、有向边的个数、源点序号、汇点序号。\n\n接下来 $m$ 行每行包含三个正整数 $u_i$、$v_i$、$c_i$，用空格分隔，表示第 $i$ 条有向边从 $u_i$ 出发，到达 $v_i$，容量为 $c_i$。", "outputFormat": "一个整数，表示 $s$ 到 $t$ 的最大流。", "hint": "$1\\leqslant n \\leqslant 1200, 1\\leqslant m \\leqslant 120000, 1\\leqslant c \\leqslant 2^{31}-1$。\n\n保证答案不超过 $2^{31}-1$。\n\n常用网络流算法的复杂度为 $O(n^2 m)$，请尽量优化算法。\n\n数据提供者：@negiizhao\n\n（如果有人用 dinic 算法过掉了此题，请私信上传者）", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Maximum Flow Enhanced / Push-Relabel", "background": "", "description": "Given $n$ vertices and $m$ directed edges, with a capacity on each edge, find the maximum flow from vertex $s$ to vertex $t$.", "inputFormat": "The first line contains four positive integers $n$, $m$, $s$, $t$, separated by spaces, representing the number of vertices, the number of directed edges, the source vertex index, and the sink vertex index.\n\nThe next $m$ lines each contain three positive integers $u_i$, $v_i$, $c_i$, separated by spaces, meaning that the $i$-th directed edge starts from $u_i$, ends at $v_i$, and has capacity $c_i$.", "outputFormat": "Output one integer, the maximum flow from $s$ to $t$.", "hint": "Constraints: $1\\leqslant n \\leqslant 1200$, $1\\leqslant m \\leqslant 120000$, $1\\leqslant c \\leqslant 2^{31}-1$.\n\nIt is guaranteed that the answer does not exceed $2^{31}-1$.\n\nThe time complexity of common network flow algorithms is $O(n^2 m)$, so please optimize your algorithm as much as possible.\n\ntestdata provider: @negiizhao.\n\n(If anyone passes this problem using Dinic’s algorithm, please send a private message to the uploader.)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】最大流 加强版 / 预流推进", "background": "", "description": "给定 $n$ 个点，$m$ 条有向边，给定每条边的容量，求从点 $s$ 到点 $t$ 的最大流。", "inputFormat": "第一行包含四个正整数 $n$、$m$、$s$、$t$，用空格分隔，分别表示点的个数、有向边的个数、源点序号、汇点序号。\n\n接下来 $m$ 行每行包含三个正整数 $u_i$、$v_i$、$c_i$，用空格分隔，表示第 $i$ 条有向边从 $u_i$ 出发，到达 $v_i$，容量为 $c_i$。", "outputFormat": "一个整数，表示 $s$ 到 $t$ 的最大流。", "hint": "$1\\leqslant n \\leqslant 1200, 1\\leqslant m \\leqslant 120000, 1\\leqslant c \\leqslant 2^{31}-1$。\n\n保证答案不超过 $2^{31}-1$。\n\n常用网络流算法的复杂度为 $O(n^2 m)$，请尽量优化算法。\n\n数据提供者：@negiizhao\n\n（如果有人用 dinic 算法过掉了此题，请私信上传者）", "locale": "zh-CN"}}}
{"pid": "P4723", "type": "P", "difficulty": 7, "samples": [["6 4\n3 -1 0 4\n-2 3 1 5", "73"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144]}, "tags": ["递推", "线性递推", "向量", "模板题"], "title": "【模板】常系数齐次线性递推", "background": "", "description": "求一个满足 $k$ 阶齐次线性递推数列 ${a_i}$ 的第 $n$ 项，即：\n\n$$a_n=\\sum\\limits_{i=1}^{k}f_i \\times a_{n-i}$$", "inputFormat": "第一行两个数 $n$,$k$，如题面所述。\n\n第二行 $k$ 个数，表示 $f_1 \\ f_2 \\ \\cdots \\ f_k$\n\n第三行 $k$ 个数，表示 $a_0 \\ a_1 \\ \\cdots \\ a_{k-1}$", "outputFormat": "一个数，表示 $a_n \\bmod 998244353$ 的值", "hint": "$N = 10^{9} , K = 32000 $\n\n保证读入的数字均为 $[-10^9,10^9]$ 内的整数。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Constant-Coefficient Homogeneous Linear Recurrence.", "background": "", "description": "Find the $n$-th term of a $k$-th order homogeneous linear recurrence sequence $\\{a_i\\}$, that is:\n\n$$a_n=\\sum\\limits_{i=1}^{k}f_i \\times a_{n-i}$$", "inputFormat": "The first line contains two integers $n$ and $k$, as described in the statement.\n\nThe second line contains $k$ integers, representing $f_1 \\ f_2 \\ \\cdots \\ f_k$.\n\nThe third line contains $k$ integers, representing $a_0 \\ a_1 \\ \\cdots \\ a_{k-1}$.", "outputFormat": "Output one integer, the value of $a_n \\bmod 998244353$.", "hint": "Constraints: $N = 10^{9}$, $K = 32000$.\n\nIt is guaranteed that all input numbers are integers in the range $[-10^9,10^9]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】常系数齐次线性递推", "background": "", "description": "求一个满足 $k$ 阶齐次线性递推数列 ${a_i}$ 的第 $n$ 项，即：\n\n$$a_n=\\sum\\limits_{i=1}^{k}f_i \\times a_{n-i}$$", "inputFormat": "第一行两个数 $n$,$k$，如题面所述。\n\n第二行 $k$ 个数，表示 $f_1 \\ f_2 \\ \\cdots \\ f_k$\n\n第三行 $k$ 个数，表示 $a_0 \\ a_1 \\ \\cdots \\ a_{k-1}$", "outputFormat": "一个数，表示 $a_n \\bmod 998244353$ 的值", "hint": "$N = 10^{9} , K = 32000 $\n\n保证读入的数字均为 $[-10^9,10^9]$ 内的整数。", "locale": "zh-CN"}}}
{"pid": "P4724", "type": "P", "difficulty": 7, "samples": [["4 \n0 0 0\n1 0 0\n0 1 0\n0 0 1", "2.366"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "三维计算几何", "模板题"], "title": "【模板】三维凸包", "background": "", "description": "给出空间中 $n$ 个点，求凸包表面积。", "inputFormat": "第一行一个整数 $n$，表示点数。\n\n接下来 $n$ 行，每行三个实数 $x, y, z$ 描述坐标。\n", "outputFormat": "输出凸包表面积，保留 $3$ 位小数。", "hint": "$4 \\le n \\le 2000$", "locale": "zh-CN", "translations": {"en": {"title": "[Template] 3D Convex Hull", "background": "", "description": "Given $n$ points in 3D space, find the surface area of their convex hull.", "inputFormat": "The first line contains an integer $n$, which is the number of points.\n\nThe next $n$ lines each contain three real numbers $x, y, z$, describing the coordinates.", "outputFormat": "Output the surface area of the convex hull, rounded to $3$ decimal places.", "hint": "$4 \\le n \\le 2000$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】三维凸包", "background": "", "description": "给出空间中 $n$ 个点，求凸包表面积。", "inputFormat": "第一行一个整数 $n$，表示点数。\n\n接下来 $n$ 行，每行三个实数 $x, y, z$ 描述坐标。\n", "outputFormat": "输出凸包表面积，保留 $3$ 位小数。", "hint": "$4 \\le n \\le 2000$", "locale": "zh-CN"}}}
{"pid": "P4725", "type": "P", "difficulty": 6, "samples": [["6\n1 927384623 878326372 3882 273455637 998233543", "0 927384623 817976920 427326948 149643566 610586717"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "洛谷原创", "O2优化", "导数", "积分", "快速傅里叶变换 FFT", "快速数论变换 NTT", "模板题"], "title": "【模板】多项式对数函数（多项式 ln）", "background": null, "description": "给出 $n-1$ 次多项式 $A(x)$，求一个 $\\bmod{\\:x^n}$ 下的多项式 $B(x)$，满足 $B(x) \\equiv \\ln A(x)$。\n\n在 $\\text{mod } 998244353$ 意义下进行，且 $a_i \\in [0, 998244353) \\cap \\mathbb{Z}$。", "inputFormat": "第一行一个整数 $n$。\n\n下一行有 $n$ 个整数，依次表示多项式的系数 $a_0, a_1, \\cdots, a_{n-1}$。\n\n保证 $a_0 = 1$。", "outputFormat": "输出 $n$ 个整数，表示答案多项式中的系数 $a_0, a_1, \\cdots, a_{n-1}$。", "hint": "对于 $100\\%$ 的数据，$n \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Polynomial Logarithm Function (Polynomial $\\ln$).", "background": "", "description": "Given a polynomial $A(x)$ of degree $n - 1$, find a polynomial $B(x)$ modulo $x^n$ such that $B(x) \\equiv \\ln A(x)$.\n\nAll computations are done modulo $998244353$, and $a_i \\in [0, 998244353) \\cap \\mathbb{Z}$.", "inputFormat": "The first line contains an integer $n$.\n\nThe next line contains $n$ integers, which are the coefficients $a_0, a_1, \\cdots, a_{n-1}$ of the polynomial in order.\n\nIt is guaranteed that $a_0 = 1$.", "outputFormat": "Output $n$ integers, which are the coefficients $a_0, a_1, \\cdots, a_{n-1}$ of the answer polynomial in order.", "hint": "For $100\\%$ of the data, $n \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】多项式对数函数（多项式 ln）", "background": null, "description": "给出 $n-1$ 次多项式 $A(x)$，求一个 $\\bmod{\\:x^n}$ 下的多项式 $B(x)$，满足 $B(x) \\equiv \\ln A(x)$。\n\n在 $\\text{mod } 998244353$ 意义下进行，且 $a_i \\in [0, 998244353) \\cap \\mathbb{Z}$。", "inputFormat": "第一行一个整数 $n$。\n\n下一行有 $n$ 个整数，依次表示多项式的系数 $a_0, a_1, \\cdots, a_{n-1}$。\n\n保证 $a_0 = 1$。", "outputFormat": "输出 $n$ 个整数，表示答案多项式中的系数 $a_0, a_1, \\cdots, a_{n-1}$。", "hint": "对于 $100\\%$ 的数据，$n \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4726", "type": "P", "difficulty": 6, "samples": [["6\n0 927384623 817976920 427326948 149643566 610586717", "1 927384623 878326372 3882 273455637 998233543"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["倍增", "递归", "O2优化", "快速傅里叶变换 FFT", "快速数论变换 NTT", "模板题"], "title": "【模板】多项式指数函数（多项式 exp）", "background": "", "description": "给出 $n-1$ 次多项式 $A(x)$，求一个 $\\bmod{\\:x^n}$ 下的多项式 $B(x)$，满足 $B(x) \\equiv \\text e^{A(x)}$。系数对 $998244353$ 取模。", "inputFormat": "第一行一个整数 $n$.\n\n下一行有 $n$ 个整数，依次表示多项式的系数 $a_0, a_1, \\cdots, a_{n-1}$.\n\n保证 $a_0 = 0$.", "outputFormat": "输出 $n$ 个整数，表示答案多项式中的系数 $a_0, a_1, \\cdots, a_{n-1}$.", "hint": "对于 $100\\%$ 的数据，$n \\le 10^5$.", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Polynomial Exponential Function (Polynomial exp).", "background": "", "description": "Given a polynomial $A(x)$ of degree $n - 1$, find a polynomial $B(x)$ modulo $x^n$ such that $B(x) \\equiv \\text e^{A(x)}$. All coefficients are taken modulo $998244353$.", "inputFormat": "The first line contains an integer $n$.\n\nThe next line contains $n$ integers, representing the coefficients $a_0, a_1, \\cdots, a_{n-1}$ of the polynomial in order.\n\nIt is guaranteed that $a_0 = 0$.", "outputFormat": "Output $n$ integers, representing the coefficients $a_0, a_1, \\cdots, a_{n-1}$ of the answer polynomial.", "hint": "For $100\\%$ of the testdata, $n \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】多项式指数函数（多项式 exp）", "background": "", "description": "给出 $n-1$ 次多项式 $A(x)$，求一个 $\\bmod{\\:x^n}$ 下的多项式 $B(x)$，满足 $B(x) \\equiv \\text e^{A(x)}$。系数对 $998244353$ 取模。", "inputFormat": "第一行一个整数 $n$.\n\n下一行有 $n$ 个整数，依次表示多项式的系数 $a_0, a_1, \\cdots, a_{n-1}$.\n\n保证 $a_0 = 0$.", "outputFormat": "输出 $n$ 个整数，表示答案多项式中的系数 $a_0, a_1, \\cdots, a_{n-1}$.", "hint": "对于 $100\\%$ 的数据，$n \\le 10^5$.", "locale": "zh-CN"}}}
{"pid": "P4727", "type": "P", "difficulty": 7, "samples": [["1", "1"], ["2", "2"], ["3", "4"], ["5", "34"], ["9", "493"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2009", "各省省选", "湖南", "群论", "置换", "Pólya 定理", "逆元"], "title": "[HNOI2009] 图的同构计数", "background": "当学生们遇到某个难题时经常会说“这怎么做，这不是 NP 问题吗？”、“这个只有搜了，这己经被证明是 NP 问题了”。但是，你应该清楚，大多数人此时所说的 NP 问题其实都是指 NPC 问题。很多人没有真正掌握 NP 问题和 NPC 问题这两个基本概念。其实 NP 问题并不是那种“只有搜才行”的问题，NPC 问题才是。\n\n很久以前就有一个古老的传说：有―个著名的问题，即 P 是否等于 NP 的问题，传说中谁要是证明或者证伪了这个命题，他将获得幸福。这里 P 是指能在多项式时间里求解的问题的集合。而 NP 是指可在多项式时间里验证的问题的集合。显然 P 是 NP 的子集，因为能在多项式时间里求解的问题，必定可在多项式时间里验证。\n\n到目前为止还没有人因这个命题得到幸福。但是，有一个总的趋势，也就是人们普遍认为，$P=NP$ 不成立，即，多数人相信，至少存在一个不可能有多项式时间复杂度的求解算法的 NP 问题。人们如此坚信 $P \\neq NP$ 是有原因的，因为在研究 NP 问题的过程中找出了一类非常特殊的 NP 问题叫做 NP-完全问题，也就是所谓的 NPC 问题。正是因为存在 NPC 问题，才使人们相信 $P \\neq NP$。\n\n在提出 NPC 的概念之后，绝大多数“自然”的难题最后都被证明是 NPC 问题，只有三个例外，它们分别是：\n\n- 线性规划问题；\n- 图同构问题；\n- 素数判定问题与大数分解问题。", "description": "小雪在了解到以上情况后，自认为直接挑战终极难题还有不少困难，于是决定先从简单的问题做起，具体来说，他对图同构问题产生了浓厚的兴趣。$A$ 图与 $B$ 图被认为是同构的是指：$A$ 图的顶点经过一定的重新标号以后，$A$ 图的顶点集和边集要完全与 $B$ 图一一对应。\n\n小雪现在专注于如何判断两个图是否同构，同时他还想知道两两互不同构的含 $N$ 个点的图有多少种。众所周知含 $N$ 个点的简单图最多有 $N\\times(N-1)/2$ 条边，这样含 $N$ 个点的图有 $2^{N\\times(N-1)/2}$ 种可能的情况。显然这些图中有很多图是同构的，小雪想知道的便是：若同构的图算成一种，则有多少种不同的图。他把这个任务丢给了你，在他想出来之前快点解决吧！", "inputFormat": "输入包含一个非负整数 $N$，表示图的顶点数，且 $0 \\leq N \\leq 60$。", "outputFormat": "输出包含一个整数，表示含 $N$ 个点的图在同构意义下不同构的图的数目。因为答案可能很大，所以输出的最终答案是 $\\bmod ~ 997$ 的结果（$997$ 是一个素数）。", "hint": "对于 $40 \\%$ 的数据，$N \\le 20$。  \n对于 $100 \\%$ 的数据，$0 \\le N \\le 60$。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2009] Counting Graph Isomorphism Classes", "background": "When students run into a hard problem, they often say, “How can this be done? Isn’t this an NP problem?”, or “You can only search; this has already been proved to be an NP problem.” However, you should know that what most people call an NP problem in such cases actually refers to an NPC problem. Many people have not truly understood the two basic concepts: NP problems and NPC problems. In fact, an NP problem is not the kind of problem that “can only be solved by searching”; NPC problems are.\n\nLong ago, there was an old legend: there is a famous question, namely whether $P$ equals $NP$. In the legend, whoever proves or disproves this statement will obtain happiness. Here, $P$ refers to the set of problems that can be solved in polynomial time. $NP$ refers to the set of problems whose solutions can be verified in polynomial time. Clearly, $P$ is a subset of $NP$, because any problem solvable in polynomial time must also be verifiable in polynomial time.\n\nSo far, no one has obtained happiness because of this statement. However, there is a general trend: people commonly believe that $P=NP$ does not hold. That is, most people believe that there exists at least one NP problem that cannot have a polynomial-time algorithm. People are so convinced that $P \\neq NP$ for a reason: during the study of NP problems, researchers found a very special class of NP problems called NP-complete problems, i.e., the so-called NPC problems. It is precisely because NPC problems exist that people believe $P \\neq NP$.\n\nAfter the concept of NPC was proposed, almost all “natural” hard problems were eventually proved to be NPC problems, with only three exceptions:\n\n- Linear programming;\n- Graph isomorphism;\n- Primality testing and integer factorization.", "description": "After learning the above, Xiaoxue felt that directly challenging the ultimate problem was still quite difficult, so he decided to start with simpler problems. Specifically, he became very interested in the graph isomorphism problem. Graph $A$ and graph $B$ are considered isomorphic if, after relabeling the vertices of graph $A$ in some way, the vertex set and edge set of $A$ correspond exactly one-to-one with those of $B$.\n\nXiaoxue is now focused on how to determine whether two graphs are isomorphic. At the same time, he also wants to know how many pairwise non-isomorphic graphs with $N$ vertices there are. It is well known that a simple graph with $N$ vertices has at most $N\\times(N-1)/2$ edges, so there are $2^{N\\times(N-1)/2}$ possible graphs with $N$ vertices. Clearly, many of these graphs are isomorphic. What Xiaoxue wants to know is: if we count isomorphic graphs as one, how many different graphs are there? He threw this task to you—solve it quickly before he figures it out!", "inputFormat": "The input contains a non-negative integer $N$, representing the number of vertices of the graph, and $0 \\leq N \\leq 60$.", "outputFormat": "Output one integer, representing the number of graphs with $N$ vertices that are non-isomorphic under isomorphism. Since the answer may be very large, output the final result $\\bmod ~ 997$ ($997$ is a prime).", "hint": "For $40\\%$ of the testdata, $N \\le 20$.  \nFor $100\\%$ of the testdata, $0 \\le N \\le 60$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2009] 图的同构计数", "background": "当学生们遇到某个难题时经常会说“这怎么做，这不是 NP 问题吗？”、“这个只有搜了，这己经被证明是 NP 问题了”。但是，你应该清楚，大多数人此时所说的 NP 问题其实都是指 NPC 问题。很多人没有真正掌握 NP 问题和 NPC 问题这两个基本概念。其实 NP 问题并不是那种“只有搜才行”的问题，NPC 问题才是。\n\n很久以前就有一个古老的传说：有―个著名的问题，即 P 是否等于 NP 的问题，传说中谁要是证明或者证伪了这个命题，他将获得幸福。这里 P 是指能在多项式时间里求解的问题的集合。而 NP 是指可在多项式时间里验证的问题的集合。显然 P 是 NP 的子集，因为能在多项式时间里求解的问题，必定可在多项式时间里验证。\n\n到目前为止还没有人因这个命题得到幸福。但是，有一个总的趋势，也就是人们普遍认为，$P=NP$ 不成立，即，多数人相信，至少存在一个不可能有多项式时间复杂度的求解算法的 NP 问题。人们如此坚信 $P \\neq NP$ 是有原因的，因为在研究 NP 问题的过程中找出了一类非常特殊的 NP 问题叫做 NP-完全问题，也就是所谓的 NPC 问题。正是因为存在 NPC 问题，才使人们相信 $P \\neq NP$。\n\n在提出 NPC 的概念之后，绝大多数“自然”的难题最后都被证明是 NPC 问题，只有三个例外，它们分别是：\n\n- 线性规划问题；\n- 图同构问题；\n- 素数判定问题与大数分解问题。", "description": "小雪在了解到以上情况后，自认为直接挑战终极难题还有不少困难，于是决定先从简单的问题做起，具体来说，他对图同构问题产生了浓厚的兴趣。$A$ 图与 $B$ 图被认为是同构的是指：$A$ 图的顶点经过一定的重新标号以后，$A$ 图的顶点集和边集要完全与 $B$ 图一一对应。\n\n小雪现在专注于如何判断两个图是否同构，同时他还想知道两两互不同构的含 $N$ 个点的图有多少种。众所周知含 $N$ 个点的简单图最多有 $N\\times(N-1)/2$ 条边，这样含 $N$ 个点的图有 $2^{N\\times(N-1)/2}$ 种可能的情况。显然这些图中有很多图是同构的，小雪想知道的便是：若同构的图算成一种，则有多少种不同的图。他把这个任务丢给了你，在他想出来之前快点解决吧！", "inputFormat": "输入包含一个非负整数 $N$，表示图的顶点数，且 $0 \\leq N \\leq 60$。", "outputFormat": "输出包含一个整数，表示含 $N$ 个点的图在同构意义下不同构的图的数目。因为答案可能很大，所以输出的最终答案是 $\\bmod ~ 997$ 的结果（$997$ 是一个素数）。", "hint": "对于 $40 \\%$ 的数据，$N \\le 20$。  \n对于 $100 \\%$ 的数据，$0 \\le N \\le 60$。", "locale": "zh-CN"}}}
{"pid": "P4728", "type": "P", "difficulty": 5, "samples": [["2\n6 3 1 4 5 8 7\n6 3 2 1 6 5 4", "Yes!\nNo!"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "各省省选", "湖南"], "title": "[HNOI2009] 双递增序列", "background": "", "description": "考虑一个长度为偶数 $n$ 的序列 $a_1, a_2, \\dots, a_n$，我们称这个序列为好的，当且仅当存在 $a_1, a_2, \\dots, a_n$ 的一个划分 $U=\\{ a_{i_1}, a_{i_2}, \\dots, a_{i_{n/2}} \\}, V=\\{ a_{j_1}, a_{j_2}, \\dots, a_{j_{n/2}} \\}=\\{ a_1, a_2, \\dots, a_n \\}-U$，且 $i_1<i_2< \\dots <i_{n/2}, a_{i_1}<a_{i_2}< \\dots <a_{i_{n/2}}, j_1<j_2< \\dots <j_{n/2}, a_{j_1}<a_{j_2}< \\dots <a_{j_{n/2}}$。\n\n比如序列 $3, 1, 4, 5, 8, 7$ 就是一个好的序列。因为它可以分成 $U=\\{3, 4, 8\\}, V=\\{1, 5, 7\\}$。而序列 $3, 2, 1, 6, 5, 4$ 则不是一个好的序列。\n\n现在的问题是，针对给出的若干序列，请你判断它们是否是好的序列。\n", "inputFormat": "第一行仅包含一个整数 $m$，表示需要判断 $m$ 个序列。  \n接下来的 $m$ 行分别给出这些序列。每个序列的输入为一行，每行的第一个数为一个偶数 $n$，表示序列的长度，随后的 $n$ 个整数表示序列本身的元素 $a_1, a_2, \\dots, a_n$。同一行的各数之间用一个空格隔开。", "outputFormat": "输出 $m$ 行，如果第 $i$ 个序列为好的序列，那么第 $i$ 行输出`Yes!`，否则输出 `No!`。", "hint": "对于 $10\\%$ 的数据，$n \\le 100$。  \n对于 $40\\%$ 的数据，$n \\le 300$。  \n对于 $100\\%$ 的数据，$1 \\le n \\leq 2000$，$1 \\le m \\leq 25$，$0 \\le a_i \\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2009] Double Increasing Sequences", "background": "", "description": "Consider a sequence $a_1, a_2, \\dots, a_n$ of even length $n$. We call this sequence good if and only if there exists a partition of $a_1, a_2, \\dots, a_n$ into two sets\n$U=\\{ a_{i_1}, a_{i_2}, \\dots, a_{i_{n/2}} \\}$ and $V=\\{ a_{j_1}, a_{j_2}, \\dots, a_{j_{n/2}} \\}=\\{ a_1, a_2, \\dots, a_n \\}-U$,\nsuch that\n$i_1<i_2< \\dots <i_{n/2}$, $a_{i_1}<a_{i_2}< \\dots <a_{i_{n/2}}$, $j_1<j_2< \\dots <j_{n/2}$, and $a_{j_1}<a_{j_2}< \\dots <a_{j_{n/2}}$.\n\nFor example, the sequence $3, 1, 4, 5, 8, 7$ is a good sequence, because it can be split into $U=\\{3, 4, 8\\}$ and $V=\\{1, 5, 7\\}$. However, the sequence $3, 2, 1, 6, 5, 4$ is not a good sequence.\n\nNow, for several given sequences, please determine whether each of them is a good sequence.", "inputFormat": "The first line contains only one integer $m$, indicating that you need to judge $m$ sequences.  \nThe next $m$ lines give these sequences. Each sequence is given on one line: the first number is an even integer $n$, indicating the length of the sequence, and the following $n$ integers are the elements of the sequence $a_1, a_2, \\dots, a_n$. Numbers on the same line are separated by a single space.", "outputFormat": "Output $m$ lines. If the $i$-th sequence is a good sequence, output `Yes!` on the $i$-th line; otherwise, output `No!`.", "hint": "For $10\\%$ of the testdata, $n \\le 100$.  \nFor $40\\%$ of the testdata, $n \\le 300$.  \nFor $100\\%$ of the testdata, $1 \\le n \\leq 2000$, $1 \\le m \\leq 25$, $0 \\le a_i \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2009] 双递增序列", "background": "", "description": "考虑一个长度为偶数 $n$ 的序列 $a_1, a_2, \\dots, a_n$，我们称这个序列为好的，当且仅当存在 $a_1, a_2, \\dots, a_n$ 的一个划分 $U=\\{ a_{i_1}, a_{i_2}, \\dots, a_{i_{n/2}} \\}, V=\\{ a_{j_1}, a_{j_2}, \\dots, a_{j_{n/2}} \\}=\\{ a_1, a_2, \\dots, a_n \\}-U$，且 $i_1<i_2< \\dots <i_{n/2}, a_{i_1}<a_{i_2}< \\dots <a_{i_{n/2}}, j_1<j_2< \\dots <j_{n/2}, a_{j_1}<a_{j_2}< \\dots <a_{j_{n/2}}$。\n\n比如序列 $3, 1, 4, 5, 8, 7$ 就是一个好的序列。因为它可以分成 $U=\\{3, 4, 8\\}, V=\\{1, 5, 7\\}$。而序列 $3, 2, 1, 6, 5, 4$ 则不是一个好的序列。\n\n现在的问题是，针对给出的若干序列，请你判断它们是否是好的序列。\n", "inputFormat": "第一行仅包含一个整数 $m$，表示需要判断 $m$ 个序列。  \n接下来的 $m$ 行分别给出这些序列。每个序列的输入为一行，每行的第一个数为一个偶数 $n$，表示序列的长度，随后的 $n$ 个整数表示序列本身的元素 $a_1, a_2, \\dots, a_n$。同一行的各数之间用一个空格隔开。", "outputFormat": "输出 $m$ 行，如果第 $i$ 个序列为好的序列，那么第 $i$ 行输出`Yes!`，否则输出 `No!`。", "hint": "对于 $10\\%$ 的数据，$n \\le 100$。  \n对于 $40\\%$ 的数据，$n \\le 300$。  \n对于 $100\\%$ 的数据，$1 \\le n \\leq 2000$，$1 \\le m \\leq 25$，$0 \\le a_i \\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P4729", "type": "P", "difficulty": 6, "samples": [["6\n1 3 2\n4 7 2\n2 5 1\n3 6 1\n8 11 2\n6 8 3", "0\n0\n1\n0\n0\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2009", "线段树", "各省省选", "湖南", "平面图欧拉公式"], "title": "[HNOI2009] 积木游戏", "background": "", "description": "丹丹是一位狂热的俄罗斯方块爱好者，但在把积分刷爆之后她终于开始感到厌倦了。于是她着手思考这样一个俄罗斯方块的简化版游戏：在初始状态地面上是空的。假设所有的积木都是长方形，且积木不能旋转或翻转。丹丹在每个时刻会选择一个位置将一块积木落下，当积木在落下的过程中碰到地面或另一块积木时，它会停留在地面上或那块积木上。落到另—块积木上意味着：上面的积木的下边界与下面的积木的上边界至少有一条线段重合(―个点不算)，如图 1 所示。\n\n![图1](https://cdn.luogu.com.cn/upload/pic/22107.png)\n\n在俄罗斯方块中，如果某个时刻积木之间形成了一个洞，那么看上去就很不优美。于是丹丹想知道，每落下一块积木之后，会形成几个新的洞。一个洞是指由积木的边界或地面组成的一块面积大于 $0$ 的封闭的区域，如图 2（a）和图 2（b）所示。\n\n要注意的是：当出现图 3 所示的情况时，因为积木 1 和积木 2 紧紧地挨在一起，所以当积木 3 落下的时候，不会形成新的洞。\n\n现在丹丹告诉你她依次落下的积木的髙度 $H_i$ 以及落下的位置的左右边界 $L_i$ 与 $R_i$，$1 \\leq i \\leq n$，而她想知道毎次积木落下时会形成几个新的洞？\n\n![图23](https://cdn.luogu.com.cn/upload/pic/22108.png)", "inputFormat": "第一行包含一个正整数 $n$，表示落下的积木的总数。接下来有$n$行，每行有用一个空格隔开的三个整数，分别表示 $L_i$、$R_i$ 和 $H_i$，即积木落下的左右边界和积木的高度。", "outputFormat": "包含 $n$ 行，每行只有一个数，第 $i$ 行表示第 $i$ 个积木落下后形成的新的洞的数目。", "hint": "**【数据范围】**\n\n输入数据保证 $0 \\leq L_i < R_i \\leq 100000, H_i \\leq 1000$。\n\n$30\\%$ 的数据保证 $n \\leq 100$。\n\n$100\\%$ 的数据保证$n \\leq 100000$。\n\n**【样例说明】**\n\n样例执行后的结果如图 4 所示，其中依次落下的积木按顺序编号为从 $1$ 到 $6$ 的一个整数。\n\n![图4](https://cdn.luogu.com.cn/upload/pic/22110.png)", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2009] Block Game", "background": "", "description": "Dandan is a die-hard Tetris fan, but after maxing out the score she finally started to feel bored. So she began to think about a simplified Tetris-like game:\n\nInitially, the ground is empty. Assume all blocks are rectangles, and blocks cannot be rotated or flipped. At each moment, Dandan chooses a position and drops one block. During the falling process, when the block touches the ground or another block, it will stop on the ground or on that block. “Landing on another block” means: the bottom boundary of the upper block and the top boundary of the lower block overlap in at least one line segment (a single point does not count), as shown in Figure 1.\n\n![Figure 1](https://cdn.luogu.com.cn/upload/pic/22107.png)\n\nIn Tetris, if at some moment a hole is formed between blocks, it looks unattractive. Therefore, Dandan wants to know: after each block is dropped, how many new holes will be formed. A hole is a closed region with area greater than $0$, bounded by block boundaries or the ground, as shown in Figure 2(a) and Figure 2(b).\n\nNote: in the situation shown in Figure 3, because block 1 and block 2 are tightly adjacent, when block 3 falls, no new hole will be formed.\n\nNow Dandan tells you, in order, the height $H_i$ of each block and the left and right boundaries $L_i$ and $R_i$ of where it is dropped, $1 \\leq i \\leq n$. She wants to know how many new holes are formed each time a block is dropped.\n\n![Figure 2 and Figure 3](https://cdn.luogu.com.cn/upload/pic/22108.png)", "inputFormat": "The first line contains a positive integer $n$, the total number of blocks to be dropped. The next $n$ lines each contain three integers separated by spaces: $L_i$, $R_i$, and $H_i$, representing the left boundary, right boundary, and height of the block.", "outputFormat": "Output $n$ lines. Each line contains one number. The $i$-th line should be the number of new holes formed after the $i$-th block is dropped.", "hint": "**Constraints**\n\nThe input guarantees $0 \\leq L_i < R_i \\leq 100000$, $H_i \\leq 1000$.\n\nFor $30\\%$ of the testdata, $n \\leq 100$.\n\nFor $100\\%$ of the testdata, $n \\leq 100000$.\n\n**Sample Explanation**\n\nThe result after running the sample is shown in Figure 4. The blocks dropped are numbered in order from $1$ to $6$.\n\n![Figure 4](https://cdn.luogu.com.cn/upload/pic/22110.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2009] 积木游戏", "background": "", "description": "丹丹是一位狂热的俄罗斯方块爱好者，但在把积分刷爆之后她终于开始感到厌倦了。于是她着手思考这样一个俄罗斯方块的简化版游戏：在初始状态地面上是空的。假设所有的积木都是长方形，且积木不能旋转或翻转。丹丹在每个时刻会选择一个位置将一块积木落下，当积木在落下的过程中碰到地面或另一块积木时，它会停留在地面上或那块积木上。落到另—块积木上意味着：上面的积木的下边界与下面的积木的上边界至少有一条线段重合(―个点不算)，如图 1 所示。\n\n![图1](https://cdn.luogu.com.cn/upload/pic/22107.png)\n\n在俄罗斯方块中，如果某个时刻积木之间形成了一个洞，那么看上去就很不优美。于是丹丹想知道，每落下一块积木之后，会形成几个新的洞。一个洞是指由积木的边界或地面组成的一块面积大于 $0$ 的封闭的区域，如图 2（a）和图 2（b）所示。\n\n要注意的是：当出现图 3 所示的情况时，因为积木 1 和积木 2 紧紧地挨在一起，所以当积木 3 落下的时候，不会形成新的洞。\n\n现在丹丹告诉你她依次落下的积木的髙度 $H_i$ 以及落下的位置的左右边界 $L_i$ 与 $R_i$，$1 \\leq i \\leq n$，而她想知道毎次积木落下时会形成几个新的洞？\n\n![图23](https://cdn.luogu.com.cn/upload/pic/22108.png)", "inputFormat": "第一行包含一个正整数 $n$，表示落下的积木的总数。接下来有$n$行，每行有用一个空格隔开的三个整数，分别表示 $L_i$、$R_i$ 和 $H_i$，即积木落下的左右边界和积木的高度。", "outputFormat": "包含 $n$ 行，每行只有一个数，第 $i$ 行表示第 $i$ 个积木落下后形成的新的洞的数目。", "hint": "**【数据范围】**\n\n输入数据保证 $0 \\leq L_i < R_i \\leq 100000, H_i \\leq 1000$。\n\n$30\\%$ 的数据保证 $n \\leq 100$。\n\n$100\\%$ 的数据保证$n \\leq 100000$。\n\n**【样例说明】**\n\n样例执行后的结果如图 4 所示，其中依次落下的积木按顺序编号为从 $1$ 到 $6$ 的一个整数。\n\n![图4](https://cdn.luogu.com.cn/upload/pic/22110.png)", "locale": "zh-CN"}}}
{"pid": "P4730", "type": "P", "difficulty": 7, "samples": [["5 5\n1 6\n3 2\n9 2\n7 3\n7 8\n4 9\n3\n5 4\n1 3\n1 2\n1 2 0\n2 5 0\n1 5 1\n1 3 1\n3 4 1", "2\n2\n-1"], ["6 14\n2 7\n3 10\n8 9\n3 4\n6 5\n3 10\n6 7\n4\n6 2\n1 2\n5 2\n3 6\n5 2 0\n4 5 1\n2 3 1\n5 4 0\n1 2 1\n1 4 0\n6 4 1\n5 4 1\n4 6 0\n1 5 0\n4 1 0\n6 4 0\n5 5 0\n1 2 0", "2\n1\n1\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["搜索", "图论", "2013", "O2优化", "广度优先搜索 BFS", "湖北"], "title": "孤舟蓑笠翁", "background": "![Background](https://i.loli.net/2018/07/04/5b3cc42f57e64.png)\n\n出于保护鱼类的目的，最优秀的渔翁才能在洞庭湖继续捕鱼。经过层层选拔，洞庭湖上只剩下孤舟蓑笠翁。以前跟其他渔翁一起钓鱼、打牌、切磋武艺，而如今只剩孤单一人，蓑笠翁不禁黯然神伤。选拔被淘汰，如今他们都去哪里了呢？大概回家种田养猪了吧。", "description": "![Description](https://i.loli.net/2018/07/04/5b3cc3f0cd5f5.png)\n\n蓑笠翁现在闲暇时在练的武术名为\"左右互搏术\"，相传是周伯通首创的武功。\n\n练功时，蓑笠翁的双手在某竖直平面内运动，以该平面上某点作为坐标原点，向右为 $x$ 轴正方向，向上为 $y$ 轴正方向建立直角坐标系。那么该平面内的一个点就可以用坐标 $(x, y)$ 来表示。\n\n该武功有 $n$ 个可停顿点，分别为 $p_1 = (x_1, y_1), p_2 = (x_2, y_2), \\ldots, p_n = (x_n, y_n)$。我们可以将蓑笠翁练功的过程分成一秒一秒来看，第 $i$ 秒时，双手都处于可停顿点上。而第 $i$ 秒末双手进行移动，移动到其它可停顿点上。（当然也可以不移动）\n\n左右互搏术中，有 $k$ 种绝招。第 $i$ 种绝招为：左手处于 $v_i$ 号可停顿点，右手处于 $u_i$ 号可停顿点，则可以发动绝招。\n\n练武功也有禁忌，在两只手停顿的时候，如果两只手的曼哈顿距离小于 $d_{min}$，则容易走火入魔。如果两只手的曼哈顿距离大于 $d_{max}$，则蓑笠翁的胳膊显然快被扯断了。所以假设左手在 $l$ 号停顿点，右手在 $r$ 号停顿点，则需要满足 $d_{min} \\leq |x_l - x_r| + |y_l - y_r| \\leq d_{max}$。\n\n从一个停顿点移动到另一个停顿点也有讲究，而且对于左右手还不一样。有 $m$ 个移动条件，每个移动条件形如：左手在 $a$ 号停顿点时能移动到 $b$ 号停顿点且在 $b$ 号停顿点时也能移动到 $a$ 号停顿点，或右手在 $a$ 号停顿点时能移动到 $b$ 号停顿点且在 $b$ 号停顿点时也能移动到 $a$ 号停顿点。对于某一秒末，蓑笠翁的手没那么快，所以每只手至多只能进行移动一次。上面未提到的移动方式均为非法。\n\n蓑笠翁希望能发动连击。即先发动第 $i$ 种绝招，经过 $t$ 秒的移动后，又发动了第 $j$ 种绝招，且 $i \\neq j$。\n\n给出 $p_1, \\ldots , p_n$，$v_1, \\ldots v_k$，$u_1, \\ldots , u_k$，$d_{min}$，$d_{max}$，和 $m$ 个移动条件，现在蓑笠翁想知道，发动第 $i$ 种绝招之后，最少经过多少秒的移动后能发动某个编号不为 $i$ 的绝招，即发动连击的最短耗时。请对于每个 $1 \\leq i \\leq k$ 输出答案。", "inputFormat": "![Input](https://i.loli.net/2018/07/04/5b3ce144d752b.png)\n\n第一行两个正整数 $n,m$。\n\n第二行两个非负整数 $d_{min}, d_{max}$。保证 $d_{min} \\leq d_{max}$。\n\n接下来 $n$ 行，这 $n$ 行中的第 $i$ 行每行两个正整数 $x, y$ 表示 $i$ 号停顿点的坐标。\n\n接下来的一行一个正整数 $k$ 。\n\n接下来 $k$ 行，这 $k$ 行中的第 $i$ 行每行两个正整数 $v, u$ 表示 $i$ 号绝招。左手处于 $v$ 号可停顿点，右手处于 $u$ 号可停顿点时能发动该绝招。保证 $1 \\leq v, u \\leq n$，不会有两个绝招完全相同，保证 $v, u$ 的曼哈顿距离不小于 $d_{min}$ 不大于 $d_{max}$。\n\n接下来 $m$ 行，每行三个正整数 $a, b, type$，若 $type = 0$ 则表示左手在 $a$ 号停顿点时能移动到 $b$ 号停顿点且在 $b$ 号停顿点时也能移动到 $a$ 号停顿点，若 $type = 1$ 则表示右手在 $a$ 号停顿点时能移动到 $b$ 号停顿点且在 $b$ 号停顿点时也能移动到 $a$ 号停顿点。保证 $1 \\leq a, b \\leq n$，$type \\in \\{0, 1\\}$。", "outputFormat": "![Output](https://i.loli.net/2018/07/04/5b3cc520d9fa0.png)\n\n$k$ 行，第 $i$ 行表示第 $i$ 个绝招发动一次连击的最短耗时。\n\n如果无论如何都无法连击，请输出 $-1$。", "hint": "**【样例解释】**\n\n![Explain](https://i.loli.net/2018/07/04/5b3cc62a913ae.png)\n\n**对于样例一的解释**　对于绝招 $1$，可以先同时将左手移动到 $2$ 号可停顿点，右手移动到 $3$ 号可停顿点，这样耗时 $1 \\textrm{ s}$，再将左手移动到 $1$ 号可停顿点，右手不动，这样可以发动绝招 $2$，共用时 $2 \\textrm{ s}$。对于绝招 $2$ 可以把刚才的过程反过来，发动绝招 $1$。对于绝招 $3$，无论如何右手都无法移动，不能发动任何绝招，故输出 $-1$。\n\n**对于样例二的解释**　不解释。\n\n**【数据范围】**\n\n![Constraint](https://i.loli.net/2018/07/04/5b3cc6528795b.png)\n\n其中 $20 \\%$ 的数据，$n \\leq 50$，$m \\leq 100$，$k \\leq 100$。  \n另有 $30 \\%$ 的数据，$n \\leq 500$，$m \\leq 2000$，$k \\leq 10000$，$d_{min} = 0$，$d_{max} = 10000$。  \n对于 $100 \\%$ 的数据，$n \\leq 1000$，$m \\leq 4000$，$1 \\leq x_i, y_i \\leq 1000$，$0 \\leq d_{min} \\leq d_{max} \\leq {10}^9$。", "locale": "zh-CN", "translations": {"en": {"title": "The Lone Fisherman in a Small Boat", "background": "![Background](https://i.loli.net/2018/07/04/5b3cc42f57e64.png)\n\nTo protect fish, only the best fishermen are allowed to keep fishing on Dongting Lake. After multiple rounds of selection, only the lone fisherman in a small boat remains on Dongting Lake. In the past, he used to fish, play cards, and spar with other fishermen, but now he is left all alone, and cannot help feeling sad. Those eliminated in the selection—where did they go now? Probably went home to farm and raise pigs.", "description": "![Description](https://i.loli.net/2018/07/04/5b3cc3f0cd5f5.png)\n\nThe martial art he practices in his spare time is called \"Left-Right Mutual Combat Technique\", said to be created by Zhou Botong.\n\nDuring practice, the fisherman’s two hands move within a certain vertical plane. Take some point on this plane as the origin, set the positive $x$-axis to the right and the positive $y$-axis upward to form a Cartesian coordinate system. Then any point in this plane can be represented by coordinates $(x, y)$.\n\nThis technique has $n$ stopping points, namely $p_1 = (x_1, y_1), p_2 = (x_2, y_2), \\ldots, p_n = (x_n, y_n)$. We can view the training process second by second: at the $i$-th second, both hands are located at stopping points. At the end of the $i$-th second, the hands move to other stopping points (or they may also stay still).\n\nIn the Left-Right Mutual Combat Technique, there are $k$ special moves. The $i$-th special move is: if the left hand is at stopping point $v_i$ and the right hand is at stopping point $u_i$, then this special move can be performed.\n\nThere are also taboos in practicing. While both hands are stopped, if the Manhattan distance between the two hands is less than $d_{min}$, it is easy to lose control. If the Manhattan distance is greater than $d_{max}$, then obviously his arms are about to be torn apart. So suppose the left hand is at stopping point $l$ and the right hand is at stopping point $r$, then it must satisfy $d_{min} \\leq |x_l - x_r| + |y_l - y_r| \\leq d_{max}$.\n\nMoving from one stopping point to another also has rules, and the rules are different for the left and right hands. There are $m$ movement constraints, each of the form: when the left hand is at stopping point $a$ it can move to stopping point $b$, and when it is at $b$ it can also move to $a$; or when the right hand is at stopping point $a$ it can move to stopping point $b$, and when it is at $b$ it can also move to $a$. At the end of any second, his hands are not that fast, so each hand can make at most one move. Any movement not mentioned above is illegal.\n\nThe fisherman hopes to perform a combo. That is, he first performs the $i$-th special move, and after $t$ seconds of movement, he performs the $j$-th special move, with $i \\neq j$.\n\nGiven $p_1, \\ldots , p_n$, $v_1, \\ldots v_k$, $u_1, \\ldots , u_k$, $d_{min}$, $d_{max}$, and the $m$ movement constraints, the fisherman wants to know: after performing the $i$-th special move, what is the minimum number of seconds of movement needed to perform some special move whose index is not $i$, i.e. the shortest time needed to perform a combo. Output the answer for each $1 \\leq i \\leq k$.", "inputFormat": "![Input](https://i.loli.net/2018/07/04/5b3ce144d752b.png)\n\nThe first line contains two positive integers $n, m$.\n\nThe second line contains two non-negative integers $d_{min}, d_{max}$. It is guaranteed that $d_{min} \\leq d_{max}$.\n\nThe next $n$ lines: the $i$-th line contains two positive integers $x, y$, indicating the coordinates of stopping point $i$.\n\nThe next line contains one positive integer $k$.\n\nThe next $k$ lines: the $i$-th line contains two positive integers $v, u$, indicating the $i$-th special move. The special move can be performed when the left hand is at stopping point $v$ and the right hand is at stopping point $u$. It is guaranteed that $1 \\leq v, u \\leq n$, no two special moves are exactly the same, and the Manhattan distance between $v$ and $u$ is not less than $d_{min}$ and not greater than $d_{max}$.\n\nThe next $m$ lines: each line contains three positive integers $a, b, type$. If $type = 0$, it means the left hand can move from stopping point $a$ to stopping point $b$ and also from $b$ to $a$. If $type = 1$, it means the right hand can move from stopping point $a$ to stopping point $b$ and also from $b$ to $a$. It is guaranteed that $1 \\leq a, b \\leq n$, $type \\in \\{0, 1\\}$.", "outputFormat": "![Output](https://i.loli.net/2018/07/04/5b3cc520d9fa0.png)\n\nOutput $k$ lines. The $i$-th line should contain the shortest time needed for the $i$-th special move to perform a combo once.\n\nIf it is impossible to perform a combo no matter what, output $-1$.", "hint": "**[Sample Explanation]**\n\n![Explain](https://i.loli.net/2018/07/04/5b3cc62a913ae.png)\n\n**Explanation for Sample 1.** For special move $1$, you can first move the left hand to stopping point $2$ and the right hand to stopping point $3$ at the same time, which costs $1 \\textrm{ s}$. Then move the left hand to stopping point $1$ and keep the right hand still; then you can perform special move $2$, taking a total of $2 \\textrm{ s}$. For special move $2$, you can reverse the above process to perform special move $1$. For special move $3$, the right hand cannot move in any way, so no special move can be performed, hence output $-1$.\n\n**Explanation for Sample 2.** Omitted.\n\n**[Constraints]**\n\n![Constraint](https://i.loli.net/2018/07/04/5b3cc6528795b.png)\n\nFor $20\\%$ of the testdata, $n \\leq 50$, $m \\leq 100$, $k \\leq 100$.  \nFor another $30\\%$ of the testdata, $n \\leq 500$, $m \\leq 2000$, $k \\leq 10000$, $d_{min} = 0$, $d_{max} = 10000$.  \nFor $100\\%$ of the testdata, $n \\leq 1000$, $m \\leq 4000$, $1 \\leq x_i, y_i \\leq 1000$, $0 \\leq d_{min} \\leq d_{max} \\leq {10}^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "孤舟蓑笠翁", "background": "![Background](https://i.loli.net/2018/07/04/5b3cc42f57e64.png)\n\n出于保护鱼类的目的，最优秀的渔翁才能在洞庭湖继续捕鱼。经过层层选拔，洞庭湖上只剩下孤舟蓑笠翁。以前跟其他渔翁一起钓鱼、打牌、切磋武艺，而如今只剩孤单一人，蓑笠翁不禁黯然神伤。选拔被淘汰，如今他们都去哪里了呢？大概回家种田养猪了吧。", "description": "![Description](https://i.loli.net/2018/07/04/5b3cc3f0cd5f5.png)\n\n蓑笠翁现在闲暇时在练的武术名为\"左右互搏术\"，相传是周伯通首创的武功。\n\n练功时，蓑笠翁的双手在某竖直平面内运动，以该平面上某点作为坐标原点，向右为 $x$ 轴正方向，向上为 $y$ 轴正方向建立直角坐标系。那么该平面内的一个点就可以用坐标 $(x, y)$ 来表示。\n\n该武功有 $n$ 个可停顿点，分别为 $p_1 = (x_1, y_1), p_2 = (x_2, y_2), \\ldots, p_n = (x_n, y_n)$。我们可以将蓑笠翁练功的过程分成一秒一秒来看，第 $i$ 秒时，双手都处于可停顿点上。而第 $i$ 秒末双手进行移动，移动到其它可停顿点上。（当然也可以不移动）\n\n左右互搏术中，有 $k$ 种绝招。第 $i$ 种绝招为：左手处于 $v_i$ 号可停顿点，右手处于 $u_i$ 号可停顿点，则可以发动绝招。\n\n练武功也有禁忌，在两只手停顿的时候，如果两只手的曼哈顿距离小于 $d_{min}$，则容易走火入魔。如果两只手的曼哈顿距离大于 $d_{max}$，则蓑笠翁的胳膊显然快被扯断了。所以假设左手在 $l$ 号停顿点，右手在 $r$ 号停顿点，则需要满足 $d_{min} \\leq |x_l - x_r| + |y_l - y_r| \\leq d_{max}$。\n\n从一个停顿点移动到另一个停顿点也有讲究，而且对于左右手还不一样。有 $m$ 个移动条件，每个移动条件形如：左手在 $a$ 号停顿点时能移动到 $b$ 号停顿点且在 $b$ 号停顿点时也能移动到 $a$ 号停顿点，或右手在 $a$ 号停顿点时能移动到 $b$ 号停顿点且在 $b$ 号停顿点时也能移动到 $a$ 号停顿点。对于某一秒末，蓑笠翁的手没那么快，所以每只手至多只能进行移动一次。上面未提到的移动方式均为非法。\n\n蓑笠翁希望能发动连击。即先发动第 $i$ 种绝招，经过 $t$ 秒的移动后，又发动了第 $j$ 种绝招，且 $i \\neq j$。\n\n给出 $p_1, \\ldots , p_n$，$v_1, \\ldots v_k$，$u_1, \\ldots , u_k$，$d_{min}$，$d_{max}$，和 $m$ 个移动条件，现在蓑笠翁想知道，发动第 $i$ 种绝招之后，最少经过多少秒的移动后能发动某个编号不为 $i$ 的绝招，即发动连击的最短耗时。请对于每个 $1 \\leq i \\leq k$ 输出答案。", "inputFormat": "![Input](https://i.loli.net/2018/07/04/5b3ce144d752b.png)\n\n第一行两个正整数 $n,m$。\n\n第二行两个非负整数 $d_{min}, d_{max}$。保证 $d_{min} \\leq d_{max}$。\n\n接下来 $n$ 行，这 $n$ 行中的第 $i$ 行每行两个正整数 $x, y$ 表示 $i$ 号停顿点的坐标。\n\n接下来的一行一个正整数 $k$ 。\n\n接下来 $k$ 行，这 $k$ 行中的第 $i$ 行每行两个正整数 $v, u$ 表示 $i$ 号绝招。左手处于 $v$ 号可停顿点，右手处于 $u$ 号可停顿点时能发动该绝招。保证 $1 \\leq v, u \\leq n$，不会有两个绝招完全相同，保证 $v, u$ 的曼哈顿距离不小于 $d_{min}$ 不大于 $d_{max}$。\n\n接下来 $m$ 行，每行三个正整数 $a, b, type$，若 $type = 0$ 则表示左手在 $a$ 号停顿点时能移动到 $b$ 号停顿点且在 $b$ 号停顿点时也能移动到 $a$ 号停顿点，若 $type = 1$ 则表示右手在 $a$ 号停顿点时能移动到 $b$ 号停顿点且在 $b$ 号停顿点时也能移动到 $a$ 号停顿点。保证 $1 \\leq a, b \\leq n$，$type \\in \\{0, 1\\}$。", "outputFormat": "![Output](https://i.loli.net/2018/07/04/5b3cc520d9fa0.png)\n\n$k$ 行，第 $i$ 行表示第 $i$ 个绝招发动一次连击的最短耗时。\n\n如果无论如何都无法连击，请输出 $-1$。", "hint": "**【样例解释】**\n\n![Explain](https://i.loli.net/2018/07/04/5b3cc62a913ae.png)\n\n**对于样例一的解释**　对于绝招 $1$，可以先同时将左手移动到 $2$ 号可停顿点，右手移动到 $3$ 号可停顿点，这样耗时 $1 \\textrm{ s}$，再将左手移动到 $1$ 号可停顿点，右手不动，这样可以发动绝招 $2$，共用时 $2 \\textrm{ s}$。对于绝招 $2$ 可以把刚才的过程反过来，发动绝招 $1$。对于绝招 $3$，无论如何右手都无法移动，不能发动任何绝招，故输出 $-1$。\n\n**对于样例二的解释**　不解释。\n\n**【数据范围】**\n\n![Constraint](https://i.loli.net/2018/07/04/5b3cc6528795b.png)\n\n其中 $20 \\%$ 的数据，$n \\leq 50$，$m \\leq 100$，$k \\leq 100$。  \n另有 $30 \\%$ 的数据，$n \\leq 500$，$m \\leq 2000$，$k \\leq 10000$，$d_{min} = 0$，$d_{max} = 10000$。  \n对于 $100 \\%$ 的数据，$n \\leq 1000$，$m \\leq 4000$，$1 \\leq x_i, y_i \\leq 1000$，$0 \\leq d_{min} \\leq d_{max} \\leq {10}^9$。", "locale": "zh-CN"}}}
{"pid": "P4731", "type": "P", "difficulty": 6, "samples": [["2\n10\n08x-7/2/x?x-23??1/???\n8 -1 40 60 82 97 102 110 120 140\n5\nx-x-23?/00-\n22 37 42 52 52", "9\n10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2015", "BalticOI（波罗的海）"], "title": "[BalticOI 2015] Bowling", "background": "", "description": "Byteasar is a fan of both bowling and statistics. He has written down the results of a few past bowling games.\n\nUnfortunately, some characters in the notes are blurry, and thus unreadable. Byteasar asks you to write a\nprogram to calculate the number of distinct games which are consistent with his notes.\n\n## Rules of Bowling\n\nA bowling game consists of $n$ frames: $n-1$ simple frames and one final frame. In a typical game $n = 10$. At the beginning of each frame $10$ pins are put standing upright at the end of a lane and a player gets no more than two (or three for the final frame) attempts (shots) to throw a bowling ball down the lane to try to knock down as many pins as possible. Each frame is denoted by two (for a simple frame) or three (for the final frame)\ncharacters.\n\nFor each shot the player receives as basic points the total number of pins knocked down in this shot. The player’s basic points in each frame are the sum of basic points of all the shots in this frame. If all $10$ pins are knocked down in a simple frame (and therefore $10$ basic points are earned), the player gets additional bonus points.\n\nFor a simple frame the rules are the following:\n\n   - If a player knocks down all $10$ pins in the first shot of a frame, she gets a strike and the frame ends. As bonus points she gets the sum of basic points of her next two shots. A strike is denoted as “``x-``”.\n \n   - If a player knocks down all $10$ pins using both shots of a frame, she gets a spare. As bonus points she gets the basic points of her next shot. A spare is denoted as “``A/``”, where $A$ is a digit describing the number of pins knocked down in the first shot of the frame.\n   \n   - If $9$ or fewer pins are knocked down after both shots, the player gets just basic points and such a frame is denoted as “``AB``”, where $A$ is the one-digit number of pins knocked down in the first shot, and $B$ is the one-digit number of pins knocked down in the second shot $(A + B < 10)$.\n\nNote that bonus points are included to the score of a frame in which the strike or the spare was obtained,regardless of the fact that the exact number of bonus points depends on future shots in next frames.\n\nFor the final frame the rules are the following:\n\n   - Initially the player receives two shots in this frame. If $9$ or fewer pins are knocked down in the two shots,the frame ends. Otherwise (if the first two shots are a spare or the first shot is a strike), the player receives a third shot in the frame. Whenever the player knocks down all the pins in any of the three shots, the pins are reset to the initial configuration for the next shot. The score of the final frame is the total number of pins knocked down (note that no bonus points are earned due to strikes and spares).\n\n   - Overall there are seven possible configurations of the final frame with the following outcomes ($A$ and $B$ stand for one-digit numbers):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vz466ecx.png)\n\nEach game is described as a sequence of $2n + 1$ characters. At the end of the game the total number of points after each frame may be calculated. For example, for a game of $n = 10$ frames described as “``08x-7/2/x-x-23441/0/x``”, the player’s points after respective frames were as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6arspls8.png)\n\n", "inputFormat": "The first line of input contains one integer $q(1 \\le q \\le 25)$, specifying the number of test cases to consider. The following $3q$ lines of input contain descriptions of test cases. Each test case is described by three lines of input.\nThe first line of a test case description contains one integer $n(2 \\le n \\le 10)$, specifying the number of frames. The second line contains a sequence of $2n + 1$ characters which denotes the game description from Byteasar’s notes. Blurry characters are replaced by “``?``” characters. The third line contains $n$ integers, the total number of points after each frame, separated by spaces. In each number either all digits are readable, or all digits are blurry. Numbers in which all digits are blurry are replaced by “``-1``”.", "outputFormat": "Your program should output $q$ lines, one line per each test case in the same order as in the input.\n\nFor each test case your program should write one integer: the number of possible distinct games corre-sponding to the test case. Two games are considered different if and only if they differ in at least one shot,that is, their $(2n+1)$-character game descriptions are different. You can assume that there is at least one game consistent with each test case in the input. You can assume that the result fits into 64-bit signed integer type.", "hint": "**Explanation to the examples:** In the first case, in frame $5$ after the character “``x``” the only possible character is “``-``”. In frame $8$ the player got $8$ points in total. Thus there are $9$ possibilities how this sum could have been obtained: $0 + 8,1 + 7,...,8 + 0$. There were no bonus points in frame $9$. Therefore, there were no points on the first shot of the final frame. To obtain $20$ points in the last two shots, the only possibility is a spare with a following strike in the last shot of the frame. Therefore there are $9$ different valid games which correspond to this input data.\n\nIn the second case, any character from $0$ to $9$ is consistent with the input data.\n\n以下子任务和评测无关，仅供参考。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v8uz3sto.png)\n\n（但是我开不了 5 个 Subtask，所以就放在一起测了）", "locale": "en", "translations": {"en": {"title": "[BalticOI 2015] Bowling", "background": "", "description": "Byteasar is a fan of both bowling and statistics. He has written down the results of a few past bowling games.\n\nUnfortunately, some characters in the notes are blurry, and thus unreadable. Byteasar asks you to write a\nprogram to calculate the number of distinct games which are consistent with his notes.\n\n## Rules of Bowling\n\nA bowling game consists of $n$ frames: $n-1$ simple frames and one final frame. In a typical game $n = 10$. At the beginning of each frame $10$ pins are put standing upright at the end of a lane and a player gets no more than two (or three for the final frame) attempts (shots) to throw a bowling ball down the lane to try to knock down as many pins as possible. Each frame is denoted by two (for a simple frame) or three (for the final frame)\ncharacters.\n\nFor each shot the player receives as basic points the total number of pins knocked down in this shot. The player’s basic points in each frame are the sum of basic points of all the shots in this frame. If all $10$ pins are knocked down in a simple frame (and therefore $10$ basic points are earned), the player gets additional bonus points.\n\nFor a simple frame the rules are the following:\n\n   - If a player knocks down all $10$ pins in the first shot of a frame, she gets a strike and the frame ends. As bonus points she gets the sum of basic points of her next two shots. A strike is denoted as “``x-``”.\n \n   - If a player knocks down all $10$ pins using both shots of a frame, she gets a spare. As bonus points she gets the basic points of her next shot. A spare is denoted as “``A/``”, where $A$ is a digit describing the number of pins knocked down in the first shot of the frame.\n   \n   - If $9$ or fewer pins are knocked down after both shots, the player gets just basic points and such a frame is denoted as “``AB``”, where $A$ is the one-digit number of pins knocked down in the first shot, and $B$ is the one-digit number of pins knocked down in the second shot $(A + B < 10)$.\n\nNote that bonus points are included to the score of a frame in which the strike or the spare was obtained,regardless of the fact that the exact number of bonus points depends on future shots in next frames.\n\nFor the final frame the rules are the following:\n\n   - Initially the player receives two shots in this frame. If $9$ or fewer pins are knocked down in the two shots,the frame ends. Otherwise (if the first two shots are a spare or the first shot is a strike), the player receives a third shot in the frame. Whenever the player knocks down all the pins in any of the three shots, the pins are reset to the initial configuration for the next shot. The score of the final frame is the total number of pins knocked down (note that no bonus points are earned due to strikes and spares).\n\n   - Overall there are seven possible configurations of the final frame with the following outcomes ($A$ and $B$ stand for one-digit numbers):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vz466ecx.png)\n\nEach game is described as a sequence of $2n + 1$ characters. At the end of the game the total number of points after each frame may be calculated. For example, for a game of $n = 10$ frames described as “``08x-7/2/x-x-23441/0/x``”, the player’s points after respective frames were as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6arspls8.png)\n\n", "inputFormat": "The first line of input contains one integer $q(1 \\le q \\le 25)$, specifying the number of test cases to consider. The following $3q$ lines of input contain descriptions of test cases. Each test case is described by three lines of input.\nThe first line of a test case description contains one integer $n(2 \\le n \\le 10)$, specifying the number of frames. The second line contains a sequence of $2n + 1$ characters which denotes the game description from Byteasar’s notes. Blurry characters are replaced by “``?``” characters. The third line contains $n$ integers, the total number of points after each frame, separated by spaces. In each number either all digits are readable, or all digits are blurry. Numbers in which all digits are blurry are replaced by “``-1``”.", "outputFormat": "Your program should output $q$ lines, one line per each test case in the same order as in the input.\n\nFor each test case your program should write one integer: the number of possible distinct games corre-sponding to the test case. Two games are considered different if and only if they differ in at least one shot,that is, their $(2n+1)$-character game descriptions are different. You can assume that there is at least one game consistent with each test case in the input. You can assume that the result fits into 64-bit signed integer type.", "hint": "**Explanation to the examples:** In the first case, in frame $5$ after the character “``x``” the only possible character is “``-``”. In frame $8$ the player got $8$ points in total. Thus there are $9$ possibilities how this sum could have been obtained: $0 + 8,1 + 7,...,8 + 0$. There were no bonus points in frame $9$. Therefore, there were no points on the first shot of the final frame. To obtain $20$ points in the last two shots, the only possibility is a spare with a following strike in the last shot of the frame. Therefore there are $9$ different valid games which correspond to this input data.\n\nIn the second case, any character from $0$ to $9$ is consistent with the input data.\n\n以下子任务和评测无关，仅供参考。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v8uz3sto.png)\n\n（但是我开不了 5 个 Subtask，所以就放在一起测了）", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2015] Bowling", "background": "", "description": "Byteasar 是一个保龄球和统计学的爱好者。他记录了一些过去保龄球比赛的结果。不幸的是，笔记中的一些字符模糊不清，因此无法辨认。Byteasar 请你编写一个程序来计算与他的笔记一致的不同游戏的数量。\n\n## 保龄球规则\n\n一场保龄球比赛由 $n$ 局组成：$n-1$ 个简单局和一个最后局。在典型的比赛中 $n = 10$。在每局开始时，10 个瓶子被竖直放置在球道的末端，玩家最多有两次（最后一局有三次）机会（投球）将保龄球投向球道，尽可能多地击倒瓶子。每局用两个（对于简单局）或三个（对于最后局）字符表示。\n\n对于每次投球，玩家获得的基本分数是该次投球击倒的瓶子总数。玩家在每局的基本分数是该局所有投球的基本分数之和。如果在一个简单局中击倒了所有 10 个瓶子（因此获得了 10 个基本分数），玩家会获得额外的奖励分数。\n\n对于简单局，规则如下：\n\n- 如果玩家在一局的第一次投球中击倒了所有 10 个瓶子，她获得一个全中，局结束。作为奖励分数，她获得下一次两次投球的基本分数之和。全中记为 “`x-`”。\n- 如果玩家在一局的两次投球中击倒了所有 10 个瓶子，她获得一个补中。作为奖励分数，她获得下一次投球的基本分数。补中记为 “`A/`”，其中 $A$ 是描述该局第一次投球击倒瓶子数的数字。\n- 如果在两次投球后击倒了 9 个或更少的瓶子，玩家只获得基本分数，这样的局记为 “`AB`”，其中 $A$ 是第一次投球击倒的瓶子数的一个数字，$B$ 是第二次投球击倒的瓶子数的一个数字 $(A + B < 10)$。\n\n注意，奖励分数被计入获得全中或补中的局的分数中，尽管确切的奖励分数取决于下一局的投球。\n\n对于最后局，规则如下：\n\n- 玩家在此局最初有两次投球。如果在两次投球中击倒了 9 个或更少的瓶子，局结束。否则（如果前两次投球是补中或第一次投球是全中），玩家在此局获得第三次投球。每当玩家在三次投球中的任何一次击倒所有瓶子时，瓶子会为下一次投球恢复到初始状态。最后局的分数是击倒的瓶子总数（注意，由于全中和补中没有奖励分数）。\n- 总共有七种可能的最后局配置，结果如下（$A$ 和 $B$ 代表一位数的数字）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vz466ecx.png)\n\n每场比赛被描述为一个 $2n + 1$ 个字符的序列。在比赛结束时，可以计算每局后的总分数。例如，对于一个由 “`08x-7/2/x-x-23441/0/x`” 描述的 $n = 10$ 局的比赛，玩家在各局后的分数如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6arspls8.png)", "inputFormat": "输入的第一行包含一个整数 $q(1 \\le q \\le 25)$，指定要考虑的测试用例数量。接下来的 $3q$ 行输入包含测试用例的描述。每个测试用例由三行输入描述。测试用例描述的第一行包含一个整数 $n(2 \\le n \\le 10)$，指定局数。第二行包含一个 $2n + 1$ 个字符的序列，表示 Byteasar 笔记中的比赛描述。模糊的字符用 “`?`” 字符替代。第三行包含 $n$ 个整数，表示每局后的总分数，以空格分隔。在每个数字中，要么所有数字可读，要么所有数字模糊。所有数字模糊的数字用 “`-1`” 替代。", "outputFormat": "你的程序应输出 $q$ 行，每个测试用例一行，顺序与输入相同。\n\n对于每个测试用例，你的程序应输出一个整数：与该测试用例对应的可能不同比赛的数量。只有在至少一个投球不同的情况下，两个比赛才被认为是不同的，即它们的 $(2n+1)$ 字符比赛描述不同。你可以假设输入中的每个测试用例至少有一个与之相符的比赛。你可以假设结果适合 64 位有符号整数类型。", "hint": "**示例解释：** 在第一个例子中，在第 5 局中，在字符 “`x`” 之后，唯一可能的字符是 “`-`”。在第 8 局中，玩家总共获得了 8 分。因此，有 9 种可能的方式获得这个总和：$0 + 8, 1 + 7, ..., 8 + 0$。在第 9 局中没有奖励分数。因此，在最后一局的第一次投球中没有分数。为了在最后两次投球中获得 20 分，唯一的可能性是补中，接着在该局的最后一次投球中全中。因此，有 9 个不同的有效比赛与此输入数据相符。\n\n在第二个例子中，任何从 $0$ 到 $9$ 的字符都与输入数据一致。\n\n以下子任务和评测无关，仅供参考。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v8uz3sto.png)\n\n（但是我开不了 5 个 Subtask，所以就放在一起测了）\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4732", "type": "P", "difficulty": 6, "samples": [["11\n1\n2\n5\n-1\n-1\n-3\n4\n-2\n-1\n-1\n1", "1\n2\n5\n2\n1\n2\n4\n2\n1\n0\n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "Special Judge", "BalticOI（波罗的海）"], "title": "[BalticOI 2015] Editor", "background": "", "description": "Byteasar is a programmer who works on a revolutionary text editor. In the editor there are two types of operations: one type allows to edit text in the editor, and the other type allows to undo previously performed operations. One of the innovative features of this editor is a multilevel undo operation. It works as follows.\n\nWe say that a text editing operation is an operation of level $0$. An undo operation of level $i(for \\ i = 1,2,...)$ undoes the last operation of level at most $i-1$ which is not undone. For instance, an undo operation of level $1$ can undo only editing operations, and an undo operation of level $2$ can undo editing operations as well as undo operations of level $1$ (but no undo operations of greater levels).\n\nMore formally, each of the already performed operations can be in two states: active or undone. Let $X$ be one of the operations. Just after performing the operation $X$, it is in the state active. If $X$ is an undo operation of level $i$, we find the most recent operation in state active of level at most $i-1$ (denote it by $X_1$) and change the state of the operation X1 to undone. If X1 is also an undo operation, we must change to active the state of the operation which $X_1$ had undone (say $X_2$). We continue in the same manner: whenever\nthe state of an undo operation $X_j$ which had previously undone some operation $X_{j+1}$ changes, we must also change the state of the operation $X_{j+1}$(which, of course, may result in changing states of further operations).\n\nThe whole chain of state modifications finishes when an editing operation is reached.\n\nFor simplicity, the current contents of text in the editor will be specified by a single integer s, called the editor state (equal to $0$ at the beginning). Each editing operation specifies the editor state that it produces.\n\nThe editor state depends on the last editing operation in the state active. Help Byteasar and write a program which keeps track of the editor state.\n\nLet us see this in action: the following table shows some operations performed by Byteasar and the editor state after performing each of them. The symbol $E_s$ denotes an editing operation which changes the editor state to $s$, whereas the symbol $U_i$ denotes an undo operation of level $i$.\n\n\n\n| Operation |  | $\\mathrm{E}_1$ | $\\mathrm{E}_2$ | $\\mathrm{E}_5$ | $\\mathrm{U}_1$ | $\\mathrm{U}_1$ | $\\mathrm{U}_3$ | $\\mathrm{E}_4$ | $\\mathrm{U}_2$ | $\\mathrm{U}_1$ | $\\mathrm{U}_1$ | $\\mathrm{E}_1$ |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| Editor state | 0 | 1 | 2 | 5 | 2 | 1 | 2 | 4 | 2 | 1 | 0 | 1 |\n\nFirst, Byteasar performed three editing operations. The editor state changed from $0$ to $1$, then to $2$, and finally to $5$. Next, he performed two undo operations of level $1$, which undid the operations $E_5$ and $E_2$(changing\ntheir state to undone). Thus the editor state was restored to $1$. The following undo operation of level $3$ undid the last operation $U_1$(changing its state to undone), consequently restoring the operation $E_2$(changing its state\nback to active). As a result the editor state changed once again to $2$. Operation $U_2$ undid the operation $E_4$,operation $U_1$ once again undid the restored operation $E_2$, the last operation $U_1$ undid the operation $E_1$, and the final operation is $E_1$.", "inputFormat": "The first line of the input contains a positive integer $n$, specifying the number of operations performed by Byteasar. The next $n$ lines contain descriptions of operations, one per line, each being an integer $a_i(-n \\le a_i \\le n, a_i ≠ 0)$. If $a_i> 0$, then it specifies an editing operation which modifies the editor state to $a_i$. If $a_i< 0$,then it specifies an undo operation of level $-a_i$. You can assume that for every undo operation there will be some operation in the state active of smaller level to undo.", "outputFormat": "Your program should output $n$ lines. The $i-th$ line should contain one integer specifying the editor state after performing the first $i$ operations from the input.", "hint": "以下子任务和评测无关，仅供参考。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zejidndn.png)\n\n（但是我开不了 4 个 Subtask，所以就放在一起测了）", "locale": "en", "translations": {"en": {"title": "[BalticOI 2015] Editor", "background": "", "description": "Byteasar is a programmer who works on a revolutionary text editor. In the editor there are two types of operations: one type allows to edit text in the editor, and the other type allows to undo previously performed operations. One of the innovative features of this editor is a multilevel undo operation. It works as follows.\n\nWe say that a text editing operation is an operation of level $0$. An undo operation of level $i(for \\ i = 1,2,...)$ undoes the last operation of level at most $i-1$ which is not undone. For instance, an undo operation of level $1$ can undo only editing operations, and an undo operation of level $2$ can undo editing operations as well as undo operations of level $1$ (but no undo operations of greater levels).\n\nMore formally, each of the already performed operations can be in two states: active or undone. Let $X$ be one of the operations. Just after performing the operation $X$, it is in the state active. If $X$ is an undo operation of level $i$, we find the most recent operation in state active of level at most $i-1$ (denote it by $X_1$) and change the state of the operation X1 to undone. If X1 is also an undo operation, we must change to active the state of the operation which $X_1$ had undone (say $X_2$). We continue in the same manner: whenever\nthe state of an undo operation $X_j$ which had previously undone some operation $X_{j+1}$ changes, we must also change the state of the operation $X_{j+1}$(which, of course, may result in changing states of further operations).\n\nThe whole chain of state modifications finishes when an editing operation is reached.\n\nFor simplicity, the current contents of text in the editor will be specified by a single integer s, called the editor state (equal to $0$ at the beginning). Each editing operation specifies the editor state that it produces.\n\nThe editor state depends on the last editing operation in the state active. Help Byteasar and write a program which keeps track of the editor state.\n\nLet us see this in action: the following table shows some operations performed by Byteasar and the editor state after performing each of them. The symbol $E_s$ denotes an editing operation which changes the editor state to $s$, whereas the symbol $U_i$ denotes an undo operation of level $i$.\n\n\n\n| Operation |  | $\\mathrm{E}_1$ | $\\mathrm{E}_2$ | $\\mathrm{E}_5$ | $\\mathrm{U}_1$ | $\\mathrm{U}_1$ | $\\mathrm{U}_3$ | $\\mathrm{E}_4$ | $\\mathrm{U}_2$ | $\\mathrm{U}_1$ | $\\mathrm{U}_1$ | $\\mathrm{E}_1$ |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| Editor state | 0 | 1 | 2 | 5 | 2 | 1 | 2 | 4 | 2 | 1 | 0 | 1 |\n\nFirst, Byteasar performed three editing operations. The editor state changed from $0$ to $1$, then to $2$, and finally to $5$. Next, he performed two undo operations of level $1$, which undid the operations $E_5$ and $E_2$(changing\ntheir state to undone). Thus the editor state was restored to $1$. The following undo operation of level $3$ undid the last operation $U_1$(changing its state to undone), consequently restoring the operation $E_2$(changing its state\nback to active). As a result the editor state changed once again to $2$. Operation $U_2$ undid the operation $E_4$,operation $U_1$ once again undid the restored operation $E_2$, the last operation $U_1$ undid the operation $E_1$, and the final operation is $E_1$.", "inputFormat": "The first line of the input contains a positive integer $n$, specifying the number of operations performed by Byteasar. The next $n$ lines contain descriptions of operations, one per line, each being an integer $a_i(-n \\le a_i \\le n, a_i ≠ 0)$. If $a_i> 0$, then it specifies an editing operation which modifies the editor state to $a_i$. If $a_i< 0$,then it specifies an undo operation of level $-a_i$. You can assume that for every undo operation there will be some operation in the state active of smaller level to undo.", "outputFormat": "Your program should output $n$ lines. The $i-th$ line should contain one integer specifying the editor state after performing the first $i$ operations from the input.", "hint": "以下子任务和评测无关，仅供参考。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zejidndn.png)\n\n（但是我开不了 4 个 Subtask，所以就放在一起测了）", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2015] Editor", "background": "", "description": "Byteasar 是一名程序员，他正在开发一个革命性的文本编辑器。在这个编辑器中，有两种类型的操作：一种是允许在编辑器中编辑文本的操作，另一种是允许撤销先前执行的操作的操作。这个编辑器的一个创新功能是多级撤销操作。其工作原理如下。\n\n我们说文本编辑操作是一个 0 级操作。一个 i 级的撤销操作（对于 $i = 1, 2, \\ldots$）可以撤销最后一个未被撤销的、级别不超过 $i-1$ 的操作。例如，一个 1 级的撤销操作只能撤销编辑操作，而一个 2 级的撤销操作可以撤销编辑操作以及 1 级的撤销操作（但不能撤销更高级别的撤销操作）。\n\n更正式地说，已经执行的每个操作可以处于两种状态：活动或已撤销。设 $X$ 是其中一个操作。刚执行完操作 $X$ 后，它处于活动状态。如果 $X$ 是一个 i 级的撤销操作，我们找到最近的、处于活动状态的、级别不超过 $i-1$ 的操作（记为 $X_1$），并将操作 $X_1$ 的状态更改为已撤销。如果 $X_1$ 也是一个撤销操作，我们必须将 $X_1$ 撤销的操作（记为 $X_2$）的状态更改为活动。我们以相同的方式继续：每当一个撤销操作 $X_j$ 的状态改变时，我们必须也改变 $X_{j+1}$ 的状态（当然，这可能导致进一步操作的状态改变）。\n\n当达到一个编辑操作时，整个状态修改链结束。\n\n为简单起见，编辑器中的当前文本内容将由一个称为编辑器状态的单一整数 $s$ 指定（初始为 $0$）。每个编辑操作指定它产生的编辑器状态。\n\n编辑器状态取决于处于活动状态的最后一个编辑操作。帮助 Byteasar 编写一个程序来跟踪编辑器状态。\n\n让我们看看这个功能的实际应用：下表显示了 Byteasar 执行的一些操作以及每次执行后的编辑器状态。符号 $E_s$ 表示将编辑器状态更改为 $s$ 的编辑操作，而符号 $U_i$ 表示 i 级的撤销操作。\n\n| Operation |  | $\\mathrm{E}_1$ | $\\mathrm{E}_2$ | $\\mathrm{E}_5$ | $\\mathrm{U}_1$ | $\\mathrm{U}_1$ | $\\mathrm{U}_3$ | $\\mathrm{E}_4$ | $\\mathrm{U}_2$ | $\\mathrm{U}_1$ | $\\mathrm{U}_1$ | $\\mathrm{E}_1$ |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| Editor state | 0 | 1 | 2 | 5 | 2 | 1 | 2 | 4 | 2 | 1 | 0 | 1 |\n\n首先，Byteasar 执行了三个编辑操作。编辑器状态从 $0$ 变为 $1$，然后变为 $2$，最后变为 $5$。接下来，他执行了两个 1 级的撤销操作，撤销了操作 $E_5$ 和 $E_2$（将它们的状态更改为已撤销）。因此，编辑器状态恢复为 $1$。接下来的 3 级撤销操作撤销了最后一个 $U_1$ 操作（将其状态更改为已撤销），从而恢复了操作 $E_2$（将其状态改回活动）。结果，编辑器状态再次变为 $2$。操作 $U_2$ 撤销了操作 $E_4$，操作 $U_1$ 再次撤销了恢复的操作 $E_2$，最后一个操作 $U_1$ 撤销了操作 $E_1$，最后的操作是 $E_1$。", "inputFormat": "输入的第一行包含一个正整数 $n$，指定 Byteasar 执行的操作数。接下来的 $n$ 行包含操作的描述，每行一个整数 $a_i(-n \\le a_i \\le n, a_i \neq 0)$。如果 $a_i > 0$，则它指定一个将编辑器状态修改为 $a_i$ 的编辑操作。如果 $a_i < 0$，则它指定一个级别为 $-a_i$ 的撤销操作。你可以假设对于每个撤销操作，都会有一些较低级别的活动状态的操作可以被撤销。", "outputFormat": "你的程序应输出 $n$ 行。第 $i$ 行应包含一个整数，指定执行输入中的前 $i$ 个操作后的编辑器状态。", "hint": "以下子任务和评测无关，仅供参考。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zejidndn.png)\n\n（但是我开不了 4 个 Subtask，所以就放在一起测了。）\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4733", "type": "P", "difficulty": 7, "samples": [["4 1\n1 1 1\n2 1 2\n2 2 8\n1 2 2\n3 3 5\n3 3 2\n4 4 1\n4 4 2", "YES"], ["2 5\n1 1 1\n1 2 4\n2 2 1\n2 1 4", "NO"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2015", "BalticOI（波罗的海）"], "title": "[BalticOI 2015] Tug of War", "background": "", "description": "拔河（*Tug of War*）在 Byteland 是十分受欢迎的运动。规则十分简单：两队以相反方向拉绳子。一年一度的 Byteland 拔河比赛将要进行，并且许多选手都报名参加了。作为公平竞赛专员，你的工作是把选手们划分为两个队伍，使得这个比赛能够进行很长时间。\n\n由于一共 $2n$ 名选手报名参赛，所以一个队有 $n$ 名队员。一根绳上左右两边各有 $n$ 个点。Byteland 的拔河精英们都很挑剔，每个参赛选手在左右两边都有一个他们想要站的位置。此外，你知道每一个参赛选手的力量值。\n\n组织者现在问你如下的问题：给定一个整数 $k$，能否分出两个队，这两个队各有 $n$ 名选手，并且他们站在他们想站的位置（当然不能有两名或以上选手站在同一位置），双方力量和之差不超过 $k$？", "inputFormat": "输入的第一行有两个正整数 $n,k$，分别表示绳子每一侧的位置数和两队的最大力量差。为了简单，我们把参赛者编号为 $1$ 到 $2n$。\n\n接下来 $2n$ 行，每行描述一个参赛者，这些行中的第 $i$ 行包含三个正整数 $l_i,r_i,s_i$，分别表示 $i$ 号选手有力量 $s_i$，并且想站在左边的 $l_i$ 位置或是右边的 $r_i$ 位置。", "outputFormat": "你的程序应在第一行输出一个单词 `YES` 或 `NO`，表示是否有可能建立两支符合上述条件的队伍。", "hint": "### 样例解释 1\n\n第一个样例中我们可以安排 $1,3,6,7$ 号选手站在左边（这个队伍力量值为 $1+8+2+1=12$），并安排 $2,4,5,8$ 号选手站在右边（这个队伍力量值为 $2+2+5+2=11$）。力量值的差为 $1$。\n\n### 样例解释 2\n\n第二个样例中两位力量值为 $4$ 的选手不得不在一个队中，因此两队最小的力量值之差为 $6$。\n\n### 子任务\n\n以下子任务与评测无关，仅供参考。\n\n本题采用子任务式测评，只有一个子任务内所有测试点均正确才可获得此子任务的分数。\n\n对于全部子任务，$k\\le 20n,1\\le l_i,r_i\\le n,1\\le s_i\\le 20$。\n\n对于每个子任务满足的条件如下：\n\n| 子任务 |           条件            | 分数 |\n| :----: | :-----------------------: | :--: |\n|  $1$   |         $n\\le 10$         | $18$ |\n|  $2$   |    $n\\le 2\\times 10^3$    | $30$ |\n|  $3$   | $n\\le 3\\times 10^4,s_i=1$ | $23$ |\n|  $4$   |    $n\\le 3\\times 10^4$    | $29$ |\n\n~~注：实际上，拔河并不取决于力量而取决于双方体重。原题的选手力量值应正比于选手体重值。~~\n\n### 附注\n\n本题翻译搬运自 [LibreOJ](https://loj.ac/problem/2707)，译者为 HeRaNO，在此对原翻译者表示感谢。", "locale": "zh-CN", "translations": {"en": {"title": "[BalticOI 2015] Tug of War", "background": "", "description": "Tug of War is a very popular sport in Byteland. The rules are very simple: two teams pull a rope in opposite directions. The annual Byteland Tug of War tournament is about to be held, and many players have signed up. As the fair play officer, your job is to divide the players into two teams so that the match can last for a long time.\n\nSince there are $2n$ players in total, each team has $n$ members. On the rope, there are $n$ positions on the left side and $n$ positions on the right side. Byteland’s tug of war elites are very picky: each player has one position they want to stand at on the left side and one position they want to stand at on the right side. Also, you know the strength value of each player.\n\nThe organizers now ask you the following question: given an integer $k$, is it possible to form two teams, each with $n$ players, such that they stand in the positions they want (of course, no two or more players can stand in the same position), and the difference between the total strengths of the two teams does not exceed $k$?", "inputFormat": "The first line contains two positive integers $n,k$, representing the number of positions on each side of the rope and the maximum allowed difference in total strength between the two teams. For simplicity, we number the players from $1$ to $2n$.\n\nIn the next $2n$ lines, each line describes one player. The $i$-th of these lines contains three positive integers $l_i,r_i,s_i$, meaning that player $i$ has strength $s_i$ and wants to stand at position $l_i$ on the left side or position $r_i$ on the right side.", "outputFormat": "Your program should output a single word `YES` or `NO` on the first line, indicating whether it is possible to form two teams that satisfy the conditions above.", "hint": "### Sample Explanation 1\n\nIn the first sample, we can arrange players $1,3,6,7$ to stand on the left side (this team has total strength $1+8+2+1=12$), and arrange players $2,4,5,8$ to stand on the right side (this team has total strength $2+2+5+2=11$). The difference in total strength is $1$.\n\n### Sample Explanation 2\n\nIn the second sample, the two players with strength $4$ must be on the same team, so the minimum possible difference between the total strengths of the two teams is $6$.\n\n### Subtasks\n\nThe following subtasks are not related to judging and are for reference only.\n\nThis problem uses subtask-based scoring. You can get the score for a subtask only if all test points in that subtask are correct.\n\nFor all subtasks, $k\\le 20n,1\\le l_i,r_i\\le n,1\\le s_i\\le 20$.\n\nThe conditions for each subtask are as follows:\n\n| Subtask |        Condition         | Score |\n| :-----: | :----------------------: | :---: |\n|   $1$   |        $n\\le 10$         | $18$  |\n|   $2$   |    $n\\le 2\\times 10^3$   | $30$  |\n|   $3$   | $n\\le 3\\times 10^4,s_i=1$ | $23$ |\n|   $4$   |    $n\\le 3\\times 10^4$   | $29$  |\n\n~~Note: in fact, tug of war does not depend on strength, but on the weight of both sides. In the original problem, the players’ strength values should be proportional to their weights.~~\n\n### Notes\n\nThis translation is adapted and carried over from [LibreOJ](https://loj.ac/problem/2707). The translator is HeRaNO, and we would like to thank the original translator here.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2015] Tug of War", "background": "", "description": "拔河（*Tug of War*）在 Byteland 是十分受欢迎的运动。规则十分简单：两队以相反方向拉绳子。一年一度的 Byteland 拔河比赛将要进行，并且许多选手都报名参加了。作为公平竞赛专员，你的工作是把选手们划分为两个队伍，使得这个比赛能够进行很长时间。\n\n由于一共 $2n$ 名选手报名参赛，所以一个队有 $n$ 名队员。一根绳上左右两边各有 $n$ 个点。Byteland 的拔河精英们都很挑剔，每个参赛选手在左右两边都有一个他们想要站的位置。此外，你知道每一个参赛选手的力量值。\n\n组织者现在问你如下的问题：给定一个整数 $k$，能否分出两个队，这两个队各有 $n$ 名选手，并且他们站在他们想站的位置（当然不能有两名或以上选手站在同一位置），双方力量和之差不超过 $k$？", "inputFormat": "输入的第一行有两个正整数 $n,k$，分别表示绳子每一侧的位置数和两队的最大力量差。为了简单，我们把参赛者编号为 $1$ 到 $2n$。\n\n接下来 $2n$ 行，每行描述一个参赛者，这些行中的第 $i$ 行包含三个正整数 $l_i,r_i,s_i$，分别表示 $i$ 号选手有力量 $s_i$，并且想站在左边的 $l_i$ 位置或是右边的 $r_i$ 位置。", "outputFormat": "你的程序应在第一行输出一个单词 `YES` 或 `NO`，表示是否有可能建立两支符合上述条件的队伍。", "hint": "### 样例解释 1\n\n第一个样例中我们可以安排 $1,3,6,7$ 号选手站在左边（这个队伍力量值为 $1+8+2+1=12$），并安排 $2,4,5,8$ 号选手站在右边（这个队伍力量值为 $2+2+5+2=11$）。力量值的差为 $1$。\n\n### 样例解释 2\n\n第二个样例中两位力量值为 $4$ 的选手不得不在一个队中，因此两队最小的力量值之差为 $6$。\n\n### 子任务\n\n以下子任务与评测无关，仅供参考。\n\n本题采用子任务式测评，只有一个子任务内所有测试点均正确才可获得此子任务的分数。\n\n对于全部子任务，$k\\le 20n,1\\le l_i,r_i\\le n,1\\le s_i\\le 20$。\n\n对于每个子任务满足的条件如下：\n\n| 子任务 |           条件            | 分数 |\n| :----: | :-----------------------: | :--: |\n|  $1$   |         $n\\le 10$         | $18$ |\n|  $2$   |    $n\\le 2\\times 10^3$    | $30$ |\n|  $3$   | $n\\le 3\\times 10^4,s_i=1$ | $23$ |\n|  $4$   |    $n\\le 3\\times 10^4$    | $29$ |\n\n~~注：实际上，拔河并不取决于力量而取决于双方体重。原题的选手力量值应正比于选手体重值。~~\n\n### 附注\n\n本题翻译搬运自 [LibreOJ](https://loj.ac/problem/2707)，译者为 HeRaNO，在此对原翻译者表示感谢。", "locale": "zh-CN"}}}
{"pid": "P4734", "type": "P", "difficulty": 4, "samples": [["4\n7 6 8 4", "13"], ["5\n1 1 1 1 1", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["贪心", "2015", "线段树", "单调队列", "前缀和", "ST 表", "构造", "BalticOI（波罗的海）"], "title": "[BalticOI 2015] Hacker", "background": "", "description": "Byteasar the hacker has qualified for this year’s IHO, the International Hacking Olympiad. One of the tasks in the Olympiad involves competing against a system operator. There are $n$ computers numbered from $1$ to $n$,connected in a ring topology, i.e. computers $i$ and $i+1$ are connected $(for \\ i = 1,...,n-1)$, and also computers $n$ and $1$ are connected.\nThe competition is performed as a game between the hacker and the system operator:\n   - Byteasar moves first. Afterwards, the operator and Byteasar move alternately.\n   - In his first move, Byteasar chooses any computer and hacks it (for instance,by exploiting some operating system vulnerabilities).\n   - In his first move, the operator chooses any non-hacked computer and protects it (for instance, by installing latest security upgrades).\n   - In all his following moves, Byteasar either (a) does nothing or (b) chooses any computer that is neither hacked nor protected and is directly linked to any hacked computer, and hacks it.\n   - In all his following moves, the operator either (a) does nothing or (b) chooses any computer that is neither hacked nor protected and is directly linked to any protected computer, and protects it.\n   - The game ends as soon as both have done nothing in two subsequent moves.\n\nAt the beginning of the game none of the computers are hacked or protected.\nEvery computer $i$ has a certain value viwhich specifies the value of the data which is stored on it. For each hacked computer $i$, Byteasar scores its value $v_i$. Byteasar is quite a good hacker, but has no idea of algorithms.\nThat is why he asks you to write a program that computes his maximum possible score, assuming that the operator plays optimally.", "inputFormat": "The first line of input contains a positive integer $n(n \\ge 2)$, specifying the number of computers. The second line contains a sequence of $n$ integers $v_1,v_2,...,v_n(1 \\le v_i \\le 2000)$; number vispecifies the value of the data\nstored on computer $i$.", "outputFormat": "In the first and only line of output your program should write one integer: Byteasar’s maximum possible score against an optimally playing operator.", "hint": "**Explanation to the examples:** In the first example, Byteasar in his first move should hack computer $2$(scoring $6$). The operator’s response will be protecting computer $3$. In the next move Byteasar can hack computer $1$ (scoring $7$). Finally, the operator will protect computer $4$.\n\n以下子任务与评测无关，仅供参考。\n\n![PVIZHx.png](https://s1.ax1x.com/2018/07/05/PVIZHx.png)", "locale": "en", "translations": {"en": {"title": "[BalticOI 2015] Hacker", "background": "", "description": "Byteasar the hacker has qualified for this year’s IHO, the International Hacking Olympiad. One of the tasks in the Olympiad involves competing against a system operator. There are $n$ computers numbered from $1$ to $n$,connected in a ring topology, i.e. computers $i$ and $i+1$ are connected $(for \\ i = 1,...,n-1)$, and also computers $n$ and $1$ are connected.\nThe competition is performed as a game between the hacker and the system operator:\n   - Byteasar moves first. Afterwards, the operator and Byteasar move alternately.\n   - In his first move, Byteasar chooses any computer and hacks it (for instance,by exploiting some operating system vulnerabilities).\n   - In his first move, the operator chooses any non-hacked computer and protects it (for instance, by installing latest security upgrades).\n   - In all his following moves, Byteasar either (a) does nothing or (b) chooses any computer that is neither hacked nor protected and is directly linked to any hacked computer, and hacks it.\n   - In all his following moves, the operator either (a) does nothing or (b) chooses any computer that is neither hacked nor protected and is directly linked to any protected computer, and protects it.\n   - The game ends as soon as both have done nothing in two subsequent moves.\n\nAt the beginning of the game none of the computers are hacked or protected.\nEvery computer $i$ has a certain value viwhich specifies the value of the data which is stored on it. For each hacked computer $i$, Byteasar scores its value $v_i$. Byteasar is quite a good hacker, but has no idea of algorithms.\nThat is why he asks you to write a program that computes his maximum possible score, assuming that the operator plays optimally.", "inputFormat": "The first line of input contains a positive integer $n(n \\ge 2)$, specifying the number of computers. The second line contains a sequence of $n$ integers $v_1,v_2,...,v_n(1 \\le v_i \\le 2000)$; number vispecifies the value of the data\nstored on computer $i$.", "outputFormat": "In the first and only line of output your program should write one integer: Byteasar’s maximum possible score against an optimally playing operator.", "hint": "**Explanation to the examples:** In the first example, Byteasar in his first move should hack computer $2$(scoring $6$). The operator’s response will be protecting computer $3$. In the next move Byteasar can hack computer $1$ (scoring $7$). Finally, the operator will protect computer $4$.\n\n以下子任务与评测无关，仅供参考。\n\n![PVIZHx.png](https://s1.ax1x.com/2018/07/05/PVIZHx.png)", "locale": "en"}, "zh-CN": {"title": "[BalticOI 2015] Hacker", "background": null, "description": "### 题面描述\n\nByteasar 获得了今年国际黑客奥林匹克竞赛的参赛资格。竞赛的任务之一是与系统操作员竞争。有从 $1$ 到 $n$ 编号的 $n$ 台计算机，以环形连接，即计算机 $i$ 和 $i+1$ 连接（其中 $i = 1,2,\\dots,n-1$），特别的，计算机 $n$ 和 $1$ 也连接。\n\n这个任务是黑客和系统操作员之间的游戏：\n\n- Byteasar 先走。之后，操作员和 Byteasar 交替移动。\n- Byteasar 的第一步是选择任何一台计算机并对其进行黑客攻击。\n- 在他的第一步中，操作员选择任何未被黑客攻击的计算机并对其进行保护。\n- 在接下来的所有动作中，Byteasar 要么什么都不做，要么选择任意一台既没有被黑客攻击也没有受到保护的计算机且该计算机直接链接到任意一台被黑客攻击的计算机，然后对其进行黑客攻击。\n- 在接下来的所有动作中，操作员要么什么都不做，要么选择任意一台既没有被黑客攻击也没有受到保护的计算机且该计算机直接链接到任何受保护的计算机并对其进行保护。\n- 一旦两人在接下来的两个动作中都没有做任何事情，游戏就结束了。\n\n在游戏开始时，没有任何一台电脑被黑客攻击或受到保护。\n\n每台计算机 $i$ 都有一个特定的值 $v_i$，该值指定了存储在这台电脑上的数据的价值。Byteasar 最终获得的分数就是所有被他攻击的计算机的 $v$ 值之和。\n\n虽然 Byteasar 是一个很好的黑客，但对算法一无所知——这就是为什么他要求你编写一个程序来计算他的最大的可能分数，假设操作员按最优策略进行操作。", "inputFormat": "第一行输入包含一个正整数 $n(n\\ge 2)$，指定计算机的数量。第二行包含一个含有 $n$ 个整数的序列 $v_1,v_2,\\dots,v_n(1\\le v_i\\le 2000)$。", "outputFormat": "在输出的第一行，也是唯一一行，你的程序应该输出一个整数：Byteasar 获得的总得分的最大值。", "hint": "对样例的说明：\n\n在第一个样例中，Byteasar 应在第一步黑客攻击编号为 $2$ 的计算机（得分为 $6$）。系统操作员第二步选择保护编号为 $3$ 的计算机。接下来 Byteasar 选择黑客攻击编号为 $1$ 的计算机（得分为 $7$）。最后，系统操作员选择保护编号为 $4$ 的计算机。由于双方都不能继续操作，游戏结束。最后 Byteasar 的得分为 $13$，可以证明这是他的最大得分。\n\n数据范围：\n\n对于 $100\\%$ 的数据，满足 $2 \\le n \\le 5 \\times 10^5,1\\le v_i\\le 2000$。", "locale": "zh-CN"}}}
{"pid": "P4735", "type": "P", "difficulty": 6, "samples": [["5 5\n2 6 4 3 6\nA 1 \nQ 3 5 4 \nA 4\nQ 5 7 0 \nQ 3 6 6 ", "4\n5\n6"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "可持久化", "前缀和", "字典树 Trie"], "title": "最大异或和", "background": "", "description": "给定一个非负整数序列 $\\{a\\}$，初始长度为 $N$。  \n\n有 $M$ 个操作，有以下两种操作类型：  \n\n1. `A x`：添加操作，表示在序列末尾添加一个数 $x$，序列的长度 $N$ 加 $1$。  \n2. `Q l r x`：询问操作，你需要找到一个位置 $p$，满足 $l \\le p \\le r$，使得：$a[p] \\oplus a[p+1] \\oplus ... \\oplus a[N] \\oplus x$ 最大，输出最大值。  ", "inputFormat": "第一行包含两个整数 $N, M$，含义如问题描述所示。     \n第二行包含 $N$ 个非负整数，表示初始的序列 $A$。   \n接下来 $M$ 行，每行描述一个操作，格式如题面所述。     ", "outputFormat": "假设询问操作有 $T$ 个，则输出应该有 $T$ 行，每行一个整数表示询问的答案。", "hint": "- 对于所有测试点，$1\\le N,M \\le 3\\times 10 ^ 5$，$0\\leq a_i\\leq 10 ^ 7$。", "locale": "zh-CN", "translations": {"en": {"title": "Maximum XOR Sum", "background": "", "description": "You are given a sequence of non-negative integers $\\{a\\}$ with initial length $N$.\n\nThere are $M$ operations of the following two types:\n\n1. `A x`: an append operation, meaning that a number $x$ is appended to the end of the sequence, and the length $N$ increases by $1$.\n2. `Q l r x`: a query operation. You need to find a position $p$ such that $l \\le p \\le r$, to maximize $a[p] \\oplus a[p+1] \\oplus ... \\oplus a[N] \\oplus x$, and output the maximum value.", "inputFormat": "The first line contains two integers $N, M$, as described above.  \nThe second line contains $N$ non-negative integers, representing the initial sequence $A$.  \nThe next $M$ lines each describe one operation, in the format given in the statement.", "outputFormat": "Suppose there are $T$ query operations. Output $T$ lines, each containing one integer, which is the answer to a query.", "hint": "- For all test cases, $1 \\le N, M \\le 3 \\times 10 ^ 5$, $0 \\le a_i \\le 10 ^ 7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最大异或和", "background": "", "description": "给定一个非负整数序列 $\\{a\\}$，初始长度为 $N$。  \n\n有 $M$ 个操作，有以下两种操作类型：  \n\n1. `A x`：添加操作，表示在序列末尾添加一个数 $x$，序列的长度 $N$ 加 $1$。  \n2. `Q l r x`：询问操作，你需要找到一个位置 $p$，满足 $l \\le p \\le r$，使得：$a[p] \\oplus a[p+1] \\oplus ... \\oplus a[N] \\oplus x$ 最大，输出最大值。  ", "inputFormat": "第一行包含两个整数 $N, M$，含义如问题描述所示。     \n第二行包含 $N$ 个非负整数，表示初始的序列 $A$。   \n接下来 $M$ 行，每行描述一个操作，格式如题面所述。     ", "outputFormat": "假设询问操作有 $T$ 个，则输出应该有 $T$ 行，每行一个整数表示询问的答案。", "hint": "- 对于所有测试点，$1\\le N,M \\le 3\\times 10 ^ 5$，$0\\leq a_i\\leq 10 ^ 7$。", "locale": "zh-CN"}}}
{"pid": "P4736", "type": "P", "difficulty": 3, "samples": [["2 17\n...........\n---.#--.---\n...........\n---.---.---\n...........\n", "...........\nhnd.#lb.fpj\n...........\nkqg.cma.eoi\n...........\n"], ["6 26\n...........\n---.---.###\n#-#.---.---\n---.###.---\n...........\n---.###.---\n#--.#-#.--#\n#--.--#.#-#\n...........\n", "...........\ngke.aic.###\n#-#.mzo.r-v\nx-p.###.n-t\n...........\nfjb.###.dlh\n#-s.#-#.w-#\n#-u.qy#.#-#\n...........\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "ICPC", "CERC"], "title": "[CERC2017] Assignment Algorithm", "background": "", "description": "A low-budget airline is designing a sophisticated algorithm that will assign more desirable seats to passengers who buy tickets earlier. Their airplane has $r$ rows of seats, where $r$ is an even integer. There are also $3$ exit rows in the airplane; those rows do not contain any seats but only provide access to the emergency exits. One exit row is in the very front of the airplane (before the first row of seats), one in the very back (behind the last row of seats) and one right in the middle. The rows are numbered with integers $1$ through $r + 3$ with row numbers increasing from the front to the back of the airplane. Rows\nnumbered $1$, $r/2 + 2$ and $r + 3$ are exit rows while all the other rows are seat rows.\nThe seating configuration is “3–3–3” — each seat row contains three groups of three seats with the passenger aisles between the groups. Seats in the same row are denoted with consecutive letters left to right corresponding to the pattern “``ABC.DEF.GHI``”.\nWhen a passenger purchases a ticket, she is assigned a seat according to the following rules:\n   1.    If there is an empty seat in a row directly after an exit row, all other rows are ignored in the following step (but they are not ignored when balancing the airplane in the last step).\n   2.    First, we select a seat row with the largest number of empty seats. If there are multiple such rows,we select the one closest to an exit row (distance between rows $a$ and $b$ is simply $|a − b|$). If there are still multiple such rows, we select the one with the lowest number.\n   3.    Now, we consider empty seats in the selected row and select one with the highest priority. Seat priorities, from highest to lowest are as follows:\n   - (a) Aisle seats in the middle group (``D`` or ``F``).\n   - (b) Aisle seats in the first and third group (``C`` or ``G``).\n   - (c) Window seats (``A`` or ``I``).\n   - (d) Middle seat in the middle group (``E``).\n   - (e) Other middle seats (``B`` or ``H``).\n\nIf there are two empty seats with the same highest priority, we consider the balance of the entire airplane. The airplane’s left side contains all seats with letters ``A``, ``B``, ``C`` or ``D``, while the right side contains all seats with letters ``F``, ``G``, ``H`` or ``I``. We select an empty seat in the side with more empty seats. If both sides have the same number of empty seats, we select the seat in the left side of the airplane.\n\nSome of the airplane’s seats are already reserved (possibly using a completely different procedure from the one described above). Determine the seats assigned to the next $n$ passengers purchasing a ticket.\n", "inputFormat": "The first line contains two integers $r$ and $n(2 \\le r \\le 50, 1 \\le n \\le 26)$ — the number of seat rows in the airplane (always an even integer) and the number of new passengers purchasing tickets. The following $r + 3$ lines contain the current layout of the airplane. The $j-th$ line contains exactly $11$ characters — the layout of the row $j$ of the airplane. Exit rows and aisles are denoted with the “``.``” characters. The “``#``” character denotes a reserved seat, while the “``-``” character denotes a seat that is currently empty. You may assume there will be at least $n$ empty seats in the airplane.\n", "outputFormat": "Output $r + 3$ lines containing the final layout of the airplane. The layout should be exactly the same as in input with the following exception: the seat assigned to the $j-th$ passenger purchasing a ticket should be denoted with the $j-th$ lowercase letter of the English alphabet.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2017] Assignment Algorithm", "background": "", "description": "A low-budget airline is designing a sophisticated algorithm that will assign more desirable seats to passengers who buy tickets earlier. Their airplane has $r$ rows of seats, where $r$ is an even integer. There are also $3$ exit rows in the airplane; those rows do not contain any seats but only provide access to the emergency exits. One exit row is in the very front of the airplane (before the first row of seats), one in the very back (behind the last row of seats) and one right in the middle. The rows are numbered with integers $1$ through $r + 3$ with row numbers increasing from the front to the back of the airplane. Rows\nnumbered $1$, $r/2 + 2$ and $r + 3$ are exit rows while all the other rows are seat rows.\nThe seating configuration is “3–3–3” — each seat row contains three groups of three seats with the passenger aisles between the groups. Seats in the same row are denoted with consecutive letters left to right corresponding to the pattern “``ABC.DEF.GHI``”.\nWhen a passenger purchases a ticket, she is assigned a seat according to the following rules:\n   1.    If there is an empty seat in a row directly after an exit row, all other rows are ignored in the following step (but they are not ignored when balancing the airplane in the last step).\n   2.    First, we select a seat row with the largest number of empty seats. If there are multiple such rows,we select the one closest to an exit row (distance between rows $a$ and $b$ is simply $|a − b|$). If there are still multiple such rows, we select the one with the lowest number.\n   3.    Now, we consider empty seats in the selected row and select one with the highest priority. Seat priorities, from highest to lowest are as follows:\n   - (a) Aisle seats in the middle group (``D`` or ``F``).\n   - (b) Aisle seats in the first and third group (``C`` or ``G``).\n   - (c) Window seats (``A`` or ``I``).\n   - (d) Middle seat in the middle group (``E``).\n   - (e) Other middle seats (``B`` or ``H``).\n\nIf there are two empty seats with the same highest priority, we consider the balance of the entire airplane. The airplane’s left side contains all seats with letters ``A``, ``B``, ``C`` or ``D``, while the right side contains all seats with letters ``F``, ``G``, ``H`` or ``I``. We select an empty seat in the side with more empty seats. If both sides have the same number of empty seats, we select the seat in the left side of the airplane.\n\nSome of the airplane’s seats are already reserved (possibly using a completely different procedure from the one described above). Determine the seats assigned to the next $n$ passengers purchasing a ticket.\n", "inputFormat": "The first line contains two integers $r$ and $n(2 \\le r \\le 50, 1 \\le n \\le 26)$ — the number of seat rows in the airplane (always an even integer) and the number of new passengers purchasing tickets. The following $r + 3$ lines contain the current layout of the airplane. The $j-th$ line contains exactly $11$ characters — the layout of the row $j$ of the airplane. Exit rows and aisles are denoted with the “``.``” characters. The “``#``” character denotes a reserved seat, while the “``-``” character denotes a seat that is currently empty. You may assume there will be at least $n$ empty seats in the airplane.\n", "outputFormat": "Output $r + 3$ lines containing the final layout of the airplane. The layout should be exactly the same as in input with the following exception: the seat assigned to the $j-th$ passenger purchasing a ticket should be denoted with the $j-th$ lowercase letter of the English alphabet.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Assignment Algorithm", "background": "", "description": "一家航空公司正在设计一种复杂的算法，将为提前购票的乘客分配更理想的座位。他们的飞机有 $r$ 排座位，其中 $r$ 是一个偶数。飞机上有 $3$ 行出口行，这些排没有座位，只提供通往紧急出口的通道。一个出口排在飞机的最前面（在第一排座椅之前），一个在最后面（在最后一排座椅之后），另一个在中间的位置。这些行用整数 $1$ 到 $r+3$ 进行编号，行号从飞机前部到后部递增。\n\n编号为 $1$、$r/2+2$ 和 $r+3$ 的行是出口行，而所有其他行都是座位行。\n座位配置为 “$3–3–3$” 每排座位包含三个组三个座位，每组座位之间有乘客通道。同一排座位用从左到右的连续字母表示，对应于“``ABC.DEF.GHI``”模式。\n当乘客购买机票时，会根据以下规则为其分配座位：\n\n1.如果在出口排的正后方有一排空座位，则在接下来的步骤中忽略所有其他排（但在最后一步中平衡飞机时不忽略）。\n\n2.首先，我们选择空座位数最多的一排座位。如果有多个这样的行，则选择最靠近出口行的行（行 $a$ 和 $b$ 之间的距离仅为 $|a− b|$）。如果仍有多个这样的行，则选择编号最低的行。\n\n3.现在，我们考虑所选行中的空座位，并选择一个优先级最高的座位。座位优先级从高到低排序按照如下规则：\\\n-（a）中间组的过道座位（即`D`或`F`）。\\\n-（b）第一组和第三组的过道座位（即``C``或``G``）。\\\n-（c）靠窗座位（即``A``或``I``）。\\\n-（d）中间组中的中间座位（即`E`）。\\\n-（e）第一组和第三组的中间座位（即``B``或``H``）。\\\n如果有两个空座位具有相同的最高优先级，我们会考虑整个飞机的平衡。飞机左侧包含字母``A``、``B``、`C`或`D`的所有座位，而右侧包含字母`F` 、`G`、`H`或 `I` 的所有座位。我们在空座位较多的一侧选择一个空座位。如果两边有相同数量的空座位，则优先选择飞机左侧的座位。\\\n飞机的一些座位已经预定好了（即输入中的 `#`）。现在请你确定分配给第 $i$ 个购票的乘客的座位。", "inputFormat": "第一行包含两个整数 $r$ 和 $n$ （$2\\le r \\le50，1\\le n \\le26$）表示飞机中的座位排数（保证为偶数）和购买机票的乘客数。第 $2$ 到 $r+3$ 行包含飞机的当前布局。第 $j$ 行正好包含 $11$ 个字符，即飞机第 $j$ 行的布局。出口行和通道用 “``.``” 字符表示。“``#``” 字符表示已经预定好的座位，而“``-``”表示当前空座位。保证飞机上至少有 $n$ 个空座位。", "outputFormat": "输出包含飞机最终布局的 $r+3$ 行。整体布局应与输入中的布局相同，分配给第 $j$ 个购票乘客的座位应使用英文字母，依次从小写字母 $a$ 到 $z$ 表示。\n\n### 样例输入 #1.\n\n```\n2 17\n...........\n---.#--.---\n...........\n---.---.---\n...........\n```\n\n### 样例输出 #1\n\n```\n...........\nhnd.#lb.fpj\n...........\nkqg.cma.eoi\n...........\n```\n\n### 样例输入 #2\n\n```\n6 26\n...........\n---.---.###\n#-#.---.---\n---.###.---\n...........\n---.###.---\n#--.#-#.--#\n#--.--#.#-#\n...........\n```\n\n### 样例输出 #2\n\n```\n...........\ngke.aic.###\n#-#.mzo.r-v\nx-p.###.n-t\n...........\nfjb.###.dlh\n#-s.#-#.w-#\n#-u.qy#.#-#\n...........\n```", "hint": "", "locale": "zh-CN"}}}
{"pid": "P4737", "type": "P", "difficulty": 6, "samples": [["7\n1 1\n4 2\n6 2\n5 3\n2 5\n4 7\n7 5\n4\n4 4\n8 2\n9 6\n6 5", "2\n1\n3\n2"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "并查集", "ICPC", "CERC"], "title": "[CERC2017] Buffalo Barricades", "background": "", "description": "A pasture in the wild west can be represented as a rectangular grid embedded in the upper-right quadrant of a standard coordinate system. A herd of $n$ buffalos is scattered throughout the grid, each occupying a unit square. Buffalos are numbered $1$ through $n$; buffalo $j$ is located in the unit square whose upper-right corner is the point with integer coordinates $(x_j,y_j)$. The coordinate axes represent two rivers meeting at the origin, restricting buffalo movement downwards and leftwards.\n\nA total of $m$ settlers arrive, one by one, and each claims a piece of land using the following procedure:\n   1.    The settler picks a point with integer coordinates and installs a single fence post at that point.The point he picks is guaranteed to be free of any previously installed fence posts or fences.Moreover, no two fence posts will have the same $x$-coordinate and no two fence posts will have the same $y$-coordinates.\n   2.    Starting from the fence post, the settler builds horizontal and vertical fence segments leftwards and downwards, respectively. Each segment is built to be as long as possible — i. e. until it reaches the river or another fence.\n   3.    The settler claims all the land in the connected area bounded with fences and rivers whose upper-right corner is his fence post. Of course, he claims all the buffalos inside as well. Note that settlers arriving later may claim pieces of land already claimed by earlier settlers.\n\nFor each settler, find the total number of buffalos he claimed when he arrived.\n", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 300 000)$ — the number of buffalos. The $j-th$ of the following $n$ lines contains two integers $x_j$ and $y_j(1 \\le x_j,y_j \\le 10^9)$ — the location of the $j-th$ buffalo.No two buffalos will share the same location.\nThe following line contains an integer $m(1 \\le m \\le 300 000)$ — the number of settlers. The $j-th$ of the following $m$ lines contains two integers $x^{'}_{j}$ and $y^{'}_{j}(1 \\le x^{'}_{j},y^{'}_{j} \\le 10^9)$ — the coordinates of the fence postinstalled by the $j-th$ settler. All $x^{'}_{j}$ are different and all $y^{'}_{j}$ are different.\n", "outputFormat": "Output $m$ lines. The $j-th$ line should contain the number of buffalos claimed by the $j-th$ settler upon arrival.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2017] Buffalo Barricades", "background": "", "description": "A pasture in the wild west can be represented as a rectangular grid embedded in the upper-right quadrant of a standard coordinate system. A herd of $n$ buffalos is scattered throughout the grid, each occupying a unit square. Buffalos are numbered $1$ through $n$; buffalo $j$ is located in the unit square whose upper-right corner is the point with integer coordinates $(x_j,y_j)$. The coordinate axes represent two rivers meeting at the origin, restricting buffalo movement downwards and leftwards.\n\nA total of $m$ settlers arrive, one by one, and each claims a piece of land using the following procedure:\n   1.    The settler picks a point with integer coordinates and installs a single fence post at that point.The point he picks is guaranteed to be free of any previously installed fence posts or fences.Moreover, no two fence posts will have the same $x$-coordinate and no two fence posts will have the same $y$-coordinates.\n   2.    Starting from the fence post, the settler builds horizontal and vertical fence segments leftwards and downwards, respectively. Each segment is built to be as long as possible — i. e. until it reaches the river or another fence.\n   3.    The settler claims all the land in the connected area bounded with fences and rivers whose upper-right corner is his fence post. Of course, he claims all the buffalos inside as well. Note that settlers arriving later may claim pieces of land already claimed by earlier settlers.\n\nFor each settler, find the total number of buffalos he claimed when he arrived.\n", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 300 000)$ — the number of buffalos. The $j-th$ of the following $n$ lines contains two integers $x_j$ and $y_j(1 \\le x_j,y_j \\le 10^9)$ — the location of the $j-th$ buffalo.No two buffalos will share the same location.\nThe following line contains an integer $m(1 \\le m \\le 300 000)$ — the number of settlers. The $j-th$ of the following $m$ lines contains two integers $x^{'}_{j}$ and $y^{'}_{j}(1 \\le x^{'}_{j},y^{'}_{j} \\le 10^9)$ — the coordinates of the fence postinstalled by the $j-th$ settler. All $x^{'}_{j}$ are different and all $y^{'}_{j}$ are different.\n", "outputFormat": "Output $m$ lines. The $j-th$ line should contain the number of buffalos claimed by the $j-th$ settler upon arrival.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Buffalo Barricades", "background": "", "description": "（西进运动时期）美国西部的一块牧场可以被表示为坐标系第一象限中的一块矩形网格。有 $n$ 头水牛在其中分布着，每一头都占据着一个单位正方形。水牛们从 $1$ 到 $n$ 编号；$j$ 号水牛位于右上角坐标为 $(x_j, y_j)$ 的单位正方形中。坐标轴表示了两条交汇于原点处的河流，阻止水牛向左下方移动。\n\n一共有 $m$ 个殖民者接连到达，每个人都要宣称一块土地的所有权，其过程遵循以下规则：\n\n1. 殖民者选定一个整数坐标点，并在此处安装一个栅栏柱。他选定的点必须没有被此前安装的栅栏或栅栏柱占据。并且，不存在两个栅栏柱会拥有相同的 $x$ 坐标，也不存在两个栅栏柱会拥有相同的 $y$ 坐标。\n2. 从栅栏柱开始，殖民者分别朝着左侧或下侧修建水平或竖直的栅栏片段。每段栅栏都修建得尽可能长：即直到碰到了河流或另一段栅栏才停下。\n3. 殖民者宣称以他的栅栏柱为右上角的，被栅栏和河流包围住的连通区域的所有权。当然，他也宣称了其中的所有水牛的所有权。注意后到来的殖民者也有可能宣称了已被先到来的殖民者宣称过的土地。\n\n对于每个殖民者，请求出当他刚到来时，被他宣称了所有权的水牛的数量。", "inputFormat": "第一行一个正整数 $n$，表示水牛的个数。\n\n接下来 $n$ 行，第 $j$ 行两个正整数 $x_j, y_j$，表示第 $j$ 头水牛的位置，不存在两头水牛的位置重合。\n\n接下来一行一个正整数 $m$，表示殖民者的个数。\n\n接下来 $m$ 行，第 $j$ 行两个正整数 $x'_j, y'_j$，表示第 $j$ 个殖民者安装的栅栏柱的位置，所有 $x'_j$ 互不相同，所有 $y'_j$ 互不相同。", "outputFormat": "输出 $m$ 行，第 $j$ 行一个整数，表示第 $j$ 个殖民者刚到来时，被他宣称了所有权的水牛的数量。", "hint": "对于全部数据，$1 \\le n, m \\le 3 \\times {10}^5$，$1 \\le x_j, y_j, x'_j, y'_j \\le {10}^9$，所有有序数对 $(x_j, y_j)$ 互不相同，所有 $x'_j$ 互不相同，所有 $y'_j$ 互不相同。\n\n**翻译来源**：IOI 2021 集训队第一部分作业，PinkRabbit。", "locale": "zh-CN"}}}
{"pid": "P4738", "type": "P", "difficulty": 6, "samples": [["3 5\n1 1 1\n2 1 1\n3 1 1\n4 1 1\n5 1 1", "2\n2\n1\n3\n3"], ["4 4\n2 1 5\n4 4 3\n4 8 1\n10 3 2", "18\n15\n5\n13"], ["7 1\n1 1 125", "4031"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "ICPC", "CERC"], "title": "[CERC2017] Cumulative Code", "background": "", "description": "As you probably know, a tree is a graph consisting of $n$ nodes and $n - 1$ undirected edges in which any two nodes are connected by exactly one path. In a labeled tree each node is labeled with a different integer between $1$ and $n$.\nThe Prüfer code of a labeled tree is a unique sequence associated with the tree, generated by repeatedly removing nodes from the tree until only two nodes remain. More precisely, in each step we remove the leaf with the smallest label and append the label of its neighbour to the end of the code. Recall, a leaf is\na node with exactly one neighbour. Therefore, the Prüfer code of a labeled tree is an integer sequence of length $n - 2$. It can be shown that the original tree can be easily reconstructed from its Prüfer code.\nThe complete binary tree of depth $k$, denoted with $C_k$, is a labeled tree with $2^k - 1$ nodes where node $j$ is connected to nodes $2j$ and $2j + 1$ for all $j < 2^{k-1}$. Denote the Prüfer code of $C_k$ with $p_1,p_2,..., p_{2^k-3}$.\nSince the Prüfer code of $C_k$ can be quite long, you do not have to print it out. Instead, you need to answer $n$ questions about the sums of certain elements on the code. Each question consists of three integers: $a, d$ and $m$. The answer is the sum of the of the $C_k'$ s Prüfer code elements $p_a, p_{a+d},p_{a+2d},...,p_{a+(m-1)d}$.\n", "inputFormat": "The first line contains two integers $k$ and $q(2 \\le k \\le 30,1 \\le q \\le 300)$ — the depth of the complete binary tree and the number of questions. The $j-th$ of the following $q$ lines contains the $j-th$ question:three positive integers $a_j,d_j$ and $m_j$ such that $a_j,d_j$ and $a_j + (m_j - 1)d_j$ are all at most $2^k - 3$.\n", "outputFormat": "Output 1 lines. The $j-th$ line should contain a single integer — the answer to the $j-th$ question.\n", "hint": "In the first example above, when constructing the Prüfer code for $C_3$ the nodes are removed in the following order: $4, 5, 2, 1, 6$. Therefore, the Prüfer code of $C_3$ is $2, 2, 1, 3, 3$.\n", "locale": "en", "translations": {"en": {"title": "[CERC2017] Cumulative Code", "background": "", "description": "As you probably know, a tree is a graph consisting of $n$ nodes and $n - 1$ undirected edges in which any two nodes are connected by exactly one path. In a labeled tree each node is labeled with a different integer between $1$ and $n$.\nThe Prüfer code of a labeled tree is a unique sequence associated with the tree, generated by repeatedly removing nodes from the tree until only two nodes remain. More precisely, in each step we remove the leaf with the smallest label and append the label of its neighbour to the end of the code. Recall, a leaf is\na node with exactly one neighbour. Therefore, the Prüfer code of a labeled tree is an integer sequence of length $n - 2$. It can be shown that the original tree can be easily reconstructed from its Prüfer code.\nThe complete binary tree of depth $k$, denoted with $C_k$, is a labeled tree with $2^k - 1$ nodes where node $j$ is connected to nodes $2j$ and $2j + 1$ for all $j < 2^{k-1}$. Denote the Prüfer code of $C_k$ with $p_1,p_2,..., p_{2^k-3}$.\nSince the Prüfer code of $C_k$ can be quite long, you do not have to print it out. Instead, you need to answer $n$ questions about the sums of certain elements on the code. Each question consists of three integers: $a, d$ and $m$. The answer is the sum of the of the $C_k'$ s Prüfer code elements $p_a, p_{a+d},p_{a+2d},...,p_{a+(m-1)d}$.\n", "inputFormat": "The first line contains two integers $k$ and $q(2 \\le k \\le 30,1 \\le q \\le 300)$ — the depth of the complete binary tree and the number of questions. The $j-th$ of the following $q$ lines contains the $j-th$ question:three positive integers $a_j,d_j$ and $m_j$ such that $a_j,d_j$ and $a_j + (m_j - 1)d_j$ are all at most $2^k - 3$.\n", "outputFormat": "Output 1 lines. The $j-th$ line should contain a single integer — the answer to the $j-th$ question.\n", "hint": "In the first example above, when constructing the Prüfer code for $C_3$ the nodes are removed in the following order: $4, 5, 2, 1, 6$. Therefore, the Prüfer code of $C_3$ is $2, 2, 1, 3, 3$.\n", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Cumulative Code", "background": "", "description": "如你所知，树是一个由 $n$ 个节点和 $n - 1$ 条无向边组成的图，其中任意两个节点之间有且仅有一条路径。在标记树中，每个节点都用 $1$ 到 $n$ 之间的不同整数标记。标记树的 Prüfer 码是与该树相关联的唯一序列，通过不断从树中移除节点直到只剩下两个节点来生成。更确切地说，在每一步中，我们移除标号最小的叶子，并将其邻居的标号附加到代码的末尾。回忆一下，叶子是一个只有一个邻居的节点。因此，标记树的 Prüfer 码是一个长度为 $n - 2$ 的整数序列。可以证明，原始树可以很容易地从其 Prüfer 码重建。深度为 $k$ 的完全二叉树，记为 $C_k$，是一个有 $2^k - 1$ 个节点的标记树，其中对于所有 $j < 2^{k-1}$，节点 $j$ 连接到节点 $2j$ 和 $2j + 1$。记 $C_k$ 的 Prüfer 码为 $p_1,p_2,..., p_{2^k-3}$。由于 $C_k$ 的 Prüfer 码可能很长，你不需要输出它。相反，你需要回答关于代码中某些元素和的 $n$ 个问题。每个问题由三个整数组成：$a, d$ 和 $m$。答案是 $C_k$ 的 Prüfer 码元素 $p_a, p_{a+d}, p_{a+2d},..., p_{a+(m-1)d}$ 的和。", "inputFormat": "第一行包含两个整数 $k$ 和 $q(2 \\le k \\le 30,1 \\le q \\le 300)$ —— 完全二叉树的深度和问题的数量。接下来的 $q$ 行中的第 $j$ 行包含第 $j$ 个问题：三个正整数 $a_j, d_j$ 和 $m_j$，使得 $a_j, d_j$ 和 $a_j + (m_j - 1)d_j$ 都最多为 $2^k - 3$。", "outputFormat": "输出 $q$ 行。第 $j$ 行应包含一个整数 —— 第 $j$ 个问题的答案。", "hint": "在上面的第一个例子中，当构造 $C_3$ 的 Prüfer 码时，节点按以下顺序被移除：$4, 5, 2, 1, 6$。因此，$C_3$ 的 Prüfer 码是 $2, 2, 1, 3, 3$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4739", "type": "P", "difficulty": 5, "samples": [["4 4\n1 2 9 3\n3 5 4 8\n4 3 2 7\n5 8 1 6\n4\nmove 1\nmove 1\nchange 1 4 100\nmove 1\n", "4 2\n1 3\n1 4\n"], ["3 4\n10 20 30 40\n50 60 70 80\n90 93 95 99\n3\nmove 4\nchange 2 1 100\nmove 4\n", "3 1\n2 1\n"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "线段树", "倍增", "ICPC", "CERC"], "title": "[CERC2017] Donut Drone", "background": "", "description": "You are building a simulation in which a drone explores a volatile torus-shaped planet. Technically,the drone is moving across a toroidal grid — a rectangular grid that wraps around circularly in both dimensions. The grid consists of cells organized into $r$ rows numbered $1$ through $r$ top to bottom and $c$\ncolumns numbered $1$ through $c$ left to right. Each grid cell has a certain elevation — a positive integer.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/c7d7xb1p.png)\n\nThe drone is initially located in the cell in the first row and first column. In each step the drone considers three cells: the cell directly to the right, the cell diagonally right-down and the cell diagonally right-up (wrapping around if necessary). The drone flies to the cell with the largest elevation of the three.\n\nTwo types of events may happen during the simulation:\n   - “``move k``” — The drone makes $k$ steps.\n   - “``change a b e``” — The elevation of the cell in row $a$ column $b$ changes to $e$.\n\nFind the drone’s position immediately after each ``move`` event. You may assume that at each point in time, no sequence of three circularly consecutive cells in the same column will have the same elevation.\nHence, each drone step is well defined.\n", "inputFormat": "The first line contains two integers $r$ and $c(3 \\le r,c \\le 2 000)$ — the number of rows and the number of columns of the toroidal grid. The $i-th$ of the following $r$ lines contains a sequence of $c$ integers $e_{i,1},e_{i,2},...,e_{i,c}(1 \\le e_{i,j} \\le 10^9)$ — the initial elevations of cells in row $i$.\n\nThe following line contains an integer $m(1 \\le m \\le 5 000)$ — the number of events. The $j-th$ of the following $m$ lines contains the $j-th$ event and is either of the form “``move k``” where $k$ is an integer such that $1 \\le k \\le 10^9$ or “``change a b e``” where $a,b$ and $e$ are integers such that $1 \\le a \\le r, 1 \\le b \\le c$ and $1 \\le e \\le 10^9$.\n", "outputFormat": "Output $w$ lines where $w$ is the number of ``move`` events in the input — the $j-th$ line should contain the drone’s position (row and column numbers) after the $j-th$ ``move`` event in the input.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[CERC2017] Donut Drone", "background": "", "description": "You are building a simulation in which a drone explores a volatile torus-shaped planet. Technically,the drone is moving across a toroidal grid — a rectangular grid that wraps around circularly in both dimensions. The grid consists of cells organized into $r$ rows numbered $1$ through $r$ top to bottom and $c$\ncolumns numbered $1$ through $c$ left to right. Each grid cell has a certain elevation — a positive integer.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/c7d7xb1p.png)\n\nThe drone is initially located in the cell in the first row and first column. In each step the drone considers three cells: the cell directly to the right, the cell diagonally right-down and the cell diagonally right-up (wrapping around if necessary). The drone flies to the cell with the largest elevation of the three.\n\nTwo types of events may happen during the simulation:\n   - “``move k``” — The drone makes $k$ steps.\n   - “``change a b e``” — The elevation of the cell in row $a$ column $b$ changes to $e$.\n\nFind the drone’s position immediately after each ``move`` event. You may assume that at each point in time, no sequence of three circularly consecutive cells in the same column will have the same elevation.\nHence, each drone step is well defined.\n", "inputFormat": "The first line contains two integers $r$ and $c(3 \\le r,c \\le 2 000)$ — the number of rows and the number of columns of the toroidal grid. The $i-th$ of the following $r$ lines contains a sequence of $c$ integers $e_{i,1},e_{i,2},...,e_{i,c}(1 \\le e_{i,j} \\le 10^9)$ — the initial elevations of cells in row $i$.\n\nThe following line contains an integer $m(1 \\le m \\le 5 000)$ — the number of events. The $j-th$ of the following $m$ lines contains the $j-th$ event and is either of the form “``move k``” where $k$ is an integer such that $1 \\le k \\le 10^9$ or “``change a b e``” where $a,b$ and $e$ are integers such that $1 \\le a \\le r, 1 \\le b \\le c$ and $1 \\le e \\le 10^9$.\n", "outputFormat": "Output $w$ lines where $w$ is the number of ``move`` events in the input — the $j-th$ line should contain the drone’s position (row and column numbers) after the $j-th$ ``move`` event in the input.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Donut Drone", "background": "", "description": "你正在构建一个模拟，其中一架无人机在一个不稳定的环形星球上探索。技术上来说，无人机在一个环形网格上移动——一个在两个维度上都循环连接的矩形网格。网格由 $r$ 行组成，从上到下编号为 $1$ 到 $r$，以及 $c$ 列，从左到右编号为 $1$ 到 $c$。每个网格单元都有一定的海拔——一个正整数。\n\n无人机最初位于第一行第一列的单元格中。在每一步中，无人机会考虑三个单元格：直接向右的单元格、右下对角线的单元格和右上对角线的单元格（如有必要，进行循环连接）。无人机飞向这三个单元格中海拔最高的那个。\n\n在模拟过程中可能发生两种类型的事件：\n- “`move k`”——无人机移动 $k$ 步。\n- “`change a b e`”——第 $a$ 行第 $b$ 列的单元格的海拔变为 $e$。\n\n在每个 `move` 事件之后，找到无人机的位置。你可以假设在任何时候，同一列中连续的三个循环单元格不会有相同的海拔。因此，每一步无人机的移动都是明确的。", "inputFormat": "第一行包含两个整数 $r$ 和 $c(3 \\le r,c \\le 2 000)$——环形网格的行数和列数。接下来的 $r$ 行中的第 $i$ 行包含一个 $c$ 个整数的序列 $e_{i,1},e_{i,2},...,e_{i,c}(1 \\le e_{i,j} \\le 10^9)$——第 $i$ 行中单元格的初始海拔。\n\n接下来的一行包含一个整数 $m(1 \\le m \\le 5 000)$——事件的数量。接下来的 $m$ 行中的第 $j$ 行包含第 $j$ 个事件，形式为“`move k`”，其中 $k$ 是一个整数，满足 $1 \\le k \\le 10^9$，或者“`change a b e`”，其中 $a,b$ 和 $e$ 是整数，满足 $1 \\le a \\le r, 1 \\le b \\le c$ 和 $1 \\le e \\le 10^9$。", "outputFormat": "输出 $w$ 行，其中 $w$ 是输入中 `move` 事件的数量——第 $j$ 行应包含输入中第 $j$ 个 `move` 事件后无人机的位置（行号和列号）。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P4740", "type": "P", "difficulty": 6, "samples": [["5\n1 2\n2 3\n2 4\n4 5", "4"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "2017", "ICPC", "CERC"], "title": "[CERC2017] Embedding Enumeration", "background": "", "description": "As you probably know, a tree is a graph consisting of $n$ nodes and $n - 1$ undirected edges in which any two nodes are connected by exactly one path. In a labeled tree each node is labeled with a different integer between $1$ and $n$. In general, it may be hard to visualize trees nicely, but some trees can be\nneatly embedded in rectangular grids.\n\nGiven a labeled tree $G$ with $n$ nodes, a $2$ by $n$ embedding of $G$ is a mapping of nodes of $G$ to the cells of a rectangular grid consisting of $2$ rows and $n$ columns such that:\n   - Node $1$ is mapped to the cell in the upper-left corner.\n   - Nodes connected with an edge are mapped to neighboring grid cells (up, down, left or right).\n   - No two nodes are mapped to the same cell.\n\nFind the number of $2$ by $n$ embeddings of a given tree, modulo $10^9 + 7$.", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 300 000)$ — the number of nodes in $G$. The $j-th$ of the following $n - 1$ lines contains two different integers $a_j$ and $b_j(1 \\le a_j,b_j \\le n)$ — the endpoints of the $j-th$ edge.\n", "outputFormat": "Output the number of $2$ by $n$ embeddings of the given tree, modulo $10^9 + 7$.", "hint": "![PZgNB8.png](https://s1.ax1x.com/2018/07/06/PZgNB8.png)\n\nAll $4$ embeddings of the tree in the example input are given in the figure above.\n", "locale": "en", "translations": {"en": {"title": "[CERC2017] Embedding Enumeration", "background": "", "description": "As you probably know, a tree is a graph consisting of $n$ nodes and $n - 1$ undirected edges in which any two nodes are connected by exactly one path. In a labeled tree each node is labeled with a different integer between $1$ and $n$. In general, it may be hard to visualize trees nicely, but some trees can be\nneatly embedded in rectangular grids.\n\nGiven a labeled tree $G$ with $n$ nodes, a $2$ by $n$ embedding of $G$ is a mapping of nodes of $G$ to the cells of a rectangular grid consisting of $2$ rows and $n$ columns such that:\n   - Node $1$ is mapped to the cell in the upper-left corner.\n   - Nodes connected with an edge are mapped to neighboring grid cells (up, down, left or right).\n   - No two nodes are mapped to the same cell.\n\nFind the number of $2$ by $n$ embeddings of a given tree, modulo $10^9 + 7$.", "inputFormat": "The first line contains an integer $n(1 \\le n \\le 300 000)$ — the number of nodes in $G$. The $j-th$ of the following $n - 1$ lines contains two different integers $a_j$ and $b_j(1 \\le a_j,b_j \\le n)$ — the endpoints of the $j-th$ edge.\n", "outputFormat": "Output the number of $2$ by $n$ embeddings of the given tree, modulo $10^9 + 7$.", "hint": "![PZgNB8.png](https://s1.ax1x.com/2018/07/06/PZgNB8.png)\n\nAll $4$ embeddings of the tree in the example input are given in the figure above.\n", "locale": "en"}, "zh-CN": {"title": "[CERC2017] Embedding Enumeration", "background": "", "description": "如你所知，树是一种图结构，由 $n$ 个节点和 $n - 1$ 条无向边组成，其中任意两个节点之间恰好有一条路径。在标记树中，每个节点都被标记为 $1$ 到 $n$ 之间的不同整数。通常情况下，树的可视化可能比较困难，但有些树可以整齐地嵌入到矩形网格中。\n\n给定一个具有 $n$ 个节点的标记树 $G$，一个 $2 \\times n$ 的嵌入是将 $G$ 的节点映射到一个由 $2$ 行和 $n$ 列组成的矩形网格的单元格中，满足以下条件：\n- 节点 $1$ 被映射到左上角的单元格。\n- 通过边连接的节点被映射到相邻的网格单元格（上、下、左或右）。\n- 没有两个节点被映射到同一个单元格。\n\n求给定树的 $2 \\times n$ 嵌入的数量，结果对 $10^9 + 7$ 取模。", "inputFormat": "第一行包含一个整数 $n(1 \\le n \\le 300 000)$，表示 $G$ 中的节点数。接下来的 $n - 1$ 行中的第 $j$ 行包含两个不同的整数 $a_j$ 和 $b_j(1 \\le a_j,b_j \\le n)$，表示第 $j$ 条边的两个端点。", "outputFormat": "输出给定树的 $2 \\times n$ 嵌入的数量，结果对 $10^9 + 7$ 取模。", "hint": "![PZgNB8.png](https://s1.ax1x.com/2018/07/06/PZgNB8.png)\n\n图中给出了示例输入中树的所有 $4$ 种嵌入。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
