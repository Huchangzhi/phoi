{"pid": "P11042", "type": "P", "difficulty": 2, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["2024", "枚举", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 Java B] 类斐波那契循环数", "background": "", "description": "\n对于一个有 $n$ 位的十进制数 $N = d_1d_2d_3\\dots d_n$，可以生成一个类斐波那契数列 $S$，数列 $S$ 的前 $n$ 个数为 $\\{S_1=d_1,S_2=d_2,S_3=d_3,\\dots,S_n=d_n\\}$，数列 $S$ 的第 $k(k>n)$ 个数为 $\\sum^{k−1}_{i=k−n} S_i$。如果这个数 $N$ 会出现在对应的类斐波那契数列 $S$ 中，那么 $N$ 就是一个类斐波那契循环数。\n\n例如对于 $197$，对应的数列 $S$ 为 $\\{1, 9, 7, 17, 33, 57, 107, 197, \\dots \\}$，$197$ 出现在 $S$ 中，所以 $197$ 是一个类斐波那契循环数。\n\n\n请问在 $0$ 至 $10^7$ 中，最大的类斐波那契循环数是多少？\n\n这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只输出这个整数，填写多余的内容将无法得分。", "inputFormat": "本题无输入。", "outputFormat": "一行一个整数，表示你算出的答案。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 Java B] 类斐波那契循环数", "background": "", "description": "\n对于一个有 $n$ 位的十进制数 $N = d_1d_2d_3\\dots d_n$，可以生成一个类斐波那契数列 $S$，数列 $S$ 的前 $n$ 个数为 $\\{S_1=d_1,S_2=d_2,S_3=d_3,\\dots,S_n=d_n\\}$，数列 $S$ 的第 $k(k>n)$ 个数为 $\\sum^{k−1}_{i=k−n} S_i$。如果这个数 $N$ 会出现在对应的类斐波那契数列 $S$ 中，那么 $N$ 就是一个类斐波那契循环数。\n\n例如对于 $197$，对应的数列 $S$ 为 $\\{1, 9, 7, 17, 33, 57, 107, 197, \\dots \\}$，$197$ 出现在 $S$ 中，所以 $197$ 是一个类斐波那契循环数。\n\n\n请问在 $0$ 至 $10^7$ 中，最大的类斐波那契循环数是多少？\n\n这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只输出这个整数，填写多余的内容将无法得分。", "inputFormat": "本题无输入。", "outputFormat": "一行一个整数，表示你算出的答案。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P11043", "type": "P", "difficulty": 2, "samples": [["3\nadd 1\nadd 2\nquery\nadd 1\nsync 1\nsync 1\nsync 2\nquery\nsync 1\nquery\nsync 2\nsync 2\nsync 1\nquery", "0\n1\n1\n3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2024", "队列", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 Java B] 分布式队列", "background": "", "description": "小蓝最近学习了一种神奇的队列：分布式队列。简单来说，分布式队列包含 $N$ 个节点（编号为 $0$ 至 $N−1$，其中 $0$ 号为主节点），其中只有一个主节点，其余为副节点。主、副节点中都各自维护着一个队列，当往分布式队列中添加元素时都是由主节点完成的（每次都会添加元素到队列尾部）；副节点只负责同步主节点中的队列。可以认为主/副节点中的队列是一个长度无限的一维数组，下标为 $0,1,2,3,\\dots$，同时副节点中的元素的同步顺序和主节点中的元素添加顺序保持一致。\n\n由于副本的同步速度各异，因此为了保障数据的一致性，元素添加到主节点后，需要同步到所有的副节点后，才具有可见性。\n\n给出一个分布式队列的运行状态，所有的操作都按输入顺序执行。你需要回答在某个时刻，队列中有多少个元素具有可见性。", "inputFormat": "第一行包含一个整数 $N$，表示节点个数。\n\n\n接下来包含多行输入，每一行包含一个操作，操作类型共有以下三个：add、sync 和 query，各自的输入格式如下：\n\n1. `add element`：表示这是一个添加操作，将元素 $element$ 添加到队列中；\n\n2. `sync follower_id`：表示这是一个同步操作，$follower\\_id$ 号副节点会从主节点中同步下一个自己缺失的元素；\n\n3. `query`：查询操作，询问当前分布式队列中有多少个元素具有可见性。", "outputFormat": "对于每一个 query 操作，输出一行，包含一个整数表示答案。", "hint": "**【样例说明】**\n\n执行到第一个 query 时，队列内容如下：\n\n- 节点 $0$：$[1,2]$\n- 节点 $1$：$[]$\n- 节点 $2$：$[]$\n\n两个副节点中都无元素，因此答案为 $0$。\n \n执行到第二个 query 时，队列内容如下：\n\n- 节点 $0$：$[1,2,1]$\n- 节点 $1$：$[1,2]$\n- 节点 $2$：$[1]$\n\n只有下标为 $0$ 的元素被所有节点同步，因此答案为 $1$。\n\n执行到第三个 query 时，队列内容如下：\n\n- 节点 $0$：$[1,2,1]$\n- 节点 $1$：$[1,2,1]$\n- 节点 $2$：$[1]$\n\n只有下标为 $0$ 的元素被所有节点同步，因此答案为 $1$。\n\n执行到第四个 query 时，队列内容如下：\n\n- 节点 $0$：$[1,2,1]$\n- 节点 $1$：$[1,2,1]$\n- 节点 $2$：$[1,2,1]$\n\n三个元素都被所有节点同步，因此答案为 $3$。\n\n**【评测用例规模与约定】**\n\n设输入的操作数为 $q$。\n\n对于 $30\\%$ 的评测用例：$1\\leq q \\leq 100$。\n\n对于 $100\\%$ 的评测用例：$1\\leq q\\leq 2000$，$1\\leq N\\leq 10$，$1\\leq follower\\_id<N$，$0\\leq element\\leq10^5$。\n\n**数据保证执行同步操作时，$follower\\_id$ 号副节点一定缺失元素**。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 Java B] 分布式队列", "background": "", "description": "小蓝最近学习了一种神奇的队列：分布式队列。简单来说，分布式队列包含 $N$ 个节点（编号为 $0$ 至 $N−1$，其中 $0$ 号为主节点），其中只有一个主节点，其余为副节点。主、副节点中都各自维护着一个队列，当往分布式队列中添加元素时都是由主节点完成的（每次都会添加元素到队列尾部）；副节点只负责同步主节点中的队列。可以认为主/副节点中的队列是一个长度无限的一维数组，下标为 $0,1,2,3,\\dots$，同时副节点中的元素的同步顺序和主节点中的元素添加顺序保持一致。\n\n由于副本的同步速度各异，因此为了保障数据的一致性，元素添加到主节点后，需要同步到所有的副节点后，才具有可见性。\n\n给出一个分布式队列的运行状态，所有的操作都按输入顺序执行。你需要回答在某个时刻，队列中有多少个元素具有可见性。", "inputFormat": "第一行包含一个整数 $N$，表示节点个数。\n\n\n接下来包含多行输入，每一行包含一个操作，操作类型共有以下三个：add、sync 和 query，各自的输入格式如下：\n\n1. `add element`：表示这是一个添加操作，将元素 $element$ 添加到队列中；\n\n2. `sync follower_id`：表示这是一个同步操作，$follower\\_id$ 号副节点会从主节点中同步下一个自己缺失的元素；\n\n3. `query`：查询操作，询问当前分布式队列中有多少个元素具有可见性。", "outputFormat": "对于每一个 query 操作，输出一行，包含一个整数表示答案。", "hint": "**【样例说明】**\n\n执行到第一个 query 时，队列内容如下：\n\n- 节点 $0$：$[1,2]$\n- 节点 $1$：$[]$\n- 节点 $2$：$[]$\n\n两个副节点中都无元素，因此答案为 $0$。\n \n执行到第二个 query 时，队列内容如下：\n\n- 节点 $0$：$[1,2,1]$\n- 节点 $1$：$[1,2]$\n- 节点 $2$：$[1]$\n\n只有下标为 $0$ 的元素被所有节点同步，因此答案为 $1$。\n\n执行到第三个 query 时，队列内容如下：\n\n- 节点 $0$：$[1,2,1]$\n- 节点 $1$：$[1,2,1]$\n- 节点 $2$：$[1]$\n\n只有下标为 $0$ 的元素被所有节点同步，因此答案为 $1$。\n\n执行到第四个 query 时，队列内容如下：\n\n- 节点 $0$：$[1,2,1]$\n- 节点 $1$：$[1,2,1]$\n- 节点 $2$：$[1,2,1]$\n\n三个元素都被所有节点同步，因此答案为 $3$。\n\n**【评测用例规模与约定】**\n\n设输入的操作数为 $q$。\n\n对于 $30\\%$ 的评测用例：$1\\leq q \\leq 100$。\n\n对于 $100\\%$ 的评测用例：$1\\leq q\\leq 2000$，$1\\leq N\\leq 10$，$1\\leq follower\\_id<N$，$0\\leq element\\leq10^5$。\n\n**数据保证执行同步操作时，$follower\\_id$ 号副节点一定缺失元素**。", "locale": "zh-CN"}}}
{"pid": "P11044", "type": "P", "difficulty": 3, "samples": [["2\n3 0 1 0 1\n0 2 2 1 1", "6\n10"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "贪心", "2024", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 Java B] 食堂", "background": "", "description": "S 学校里一共有 $a_2$ 个两人寝、$a_3$ 个三人寝，$a_4$ 个四人寝，而食堂里有 $b_4$ 个四人桌和 $b_6$ 个六人桌。学校想要安排学生们在食堂用餐，并且满足每个寝室里的同学都在同一桌就坐，请问这个食堂最多同时满足多少同学用餐？", "inputFormat": "**本题采用多组数据输入。**\n\n输入共 $q+1$ 行。\n\n第一行为一个正整数 $q$ 表示数据组数。\n\n后面 $q$ 行，每行五个非负整数 $a_2,a_3,a_4,b_4,b_6$ 表示一组数据。", "outputFormat": "输出共 $q$ 行，每行一个整数表示对应输入数据的答案。", "hint": "**【样例说明】**\n\n对于第一组数据，只有一个六人桌，因此最多安排三个两人寝的同学就餐，答案为 $(2+2+2)=6$。\n\n对于第二组数据，用一个六人桌安排两个三人寝的同学，用一个四人桌安排一个四人寝的同学，答案为 $(3+3)+(4)=10$。\n\n**【评测用例规模与约定】**\n\n对于 $20\\%$ 的评测用例，保证 $a_2+a_3+a_4\\leq 8$。\n\n对于 $100\\%$ 的评测用例，保证 $q\\leq 100$，$b_4+b_6\\leq a_2+a_3+a_4\\leq 100$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 Java B] 食堂", "background": "", "description": "S 学校里一共有 $a_2$ 个两人寝、$a_3$ 个三人寝，$a_4$ 个四人寝，而食堂里有 $b_4$ 个四人桌和 $b_6$ 个六人桌。学校想要安排学生们在食堂用餐，并且满足每个寝室里的同学都在同一桌就坐，请问这个食堂最多同时满足多少同学用餐？", "inputFormat": "**本题采用多组数据输入。**\n\n输入共 $q+1$ 行。\n\n第一行为一个正整数 $q$ 表示数据组数。\n\n后面 $q$ 行，每行五个非负整数 $a_2,a_3,a_4,b_4,b_6$ 表示一组数据。", "outputFormat": "输出共 $q$ 行，每行一个整数表示对应输入数据的答案。", "hint": "**【样例说明】**\n\n对于第一组数据，只有一个六人桌，因此最多安排三个两人寝的同学就餐，答案为 $(2+2+2)=6$。\n\n对于第二组数据，用一个六人桌安排两个三人寝的同学，用一个四人桌安排一个四人寝的同学，答案为 $(3+3)+(4)=10$。\n\n**【评测用例规模与约定】**\n\n对于 $20\\%$ 的评测用例，保证 $a_2+a_3+a_4\\leq 8$。\n\n对于 $100\\%$ 的评测用例，保证 $q\\leq 100$，$b_4+b_6\\leq a_2+a_3+a_4\\leq 100$。", "locale": "zh-CN"}}}
{"pid": "P11045", "type": "P", "difficulty": 4, "samples": [["1000\n0.05", "5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2024", "枚举", "期望", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 Java B] 最优分组", "background": "", "description": "小蓝开了一家宠物店，最近有一种 X 病毒在动物之间进行传染，小蓝为了以防万一打算购买测试剂对自己的宠物进行病毒感染测试。\n\n为了减少使用的测试剂数目，小蓝想到了一个好方法：将 $N$ 个宠物平均分为若干组，使得每组恰好有 $K$ 只宠物，这样对同一组的宠物进行采样并混合后用一个试剂进行检测，如果测试结果为阴性则说明组内宠物都未感染 X 病毒；如果是阳性的话则需要对组内所有 $K$ 只宠物单独检测，需要再消耗 $K$ 支测试剂（当 $K=1$ 时，就没必要再次进行单独检测了，因为组内只有一只宠物，一次检测便能确认答案）。\n\n现在我们已知小蓝的宠物被感染的概率为 $p$，请问 $K$ 应该取值为多少，才能使得期望的测试剂的消耗数目最少？如果有多个答案，请输出最小的 $K$。", "inputFormat": "第一行，一个整数 $N$。\n\n第二行，一个浮点数 $p$。", "outputFormat": "输出一行，一个整数 $K$ 表示答案。", "hint": "**【评测用例规模与约定】**\n\n对于 $30\\%$ 的评测用例：$1\\leq N\\leq 10$。\n\n对于 $60\\%$ 的评测用例：$1\\leq N\\leq 1000$。\n\n对于 $100\\%$ 的评测用例：$1\\leq N\\leq 10^6$，$0\\leq p\\leq 1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 Java B] 最优分组", "background": "", "description": "小蓝开了一家宠物店，最近有一种 X 病毒在动物之间进行传染，小蓝为了以防万一打算购买测试剂对自己的宠物进行病毒感染测试。\n\n为了减少使用的测试剂数目，小蓝想到了一个好方法：将 $N$ 个宠物平均分为若干组，使得每组恰好有 $K$ 只宠物，这样对同一组的宠物进行采样并混合后用一个试剂进行检测，如果测试结果为阴性则说明组内宠物都未感染 X 病毒；如果是阳性的话则需要对组内所有 $K$ 只宠物单独检测，需要再消耗 $K$ 支测试剂（当 $K=1$ 时，就没必要再次进行单独检测了，因为组内只有一只宠物，一次检测便能确认答案）。\n\n现在我们已知小蓝的宠物被感染的概率为 $p$，请问 $K$ 应该取值为多少，才能使得期望的测试剂的消耗数目最少？如果有多个答案，请输出最小的 $K$。", "inputFormat": "第一行，一个整数 $N$。\n\n第二行，一个浮点数 $p$。", "outputFormat": "输出一行，一个整数 $K$ 表示答案。", "hint": "**【评测用例规模与约定】**\n\n对于 $30\\%$ 的评测用例：$1\\leq N\\leq 10$。\n\n对于 $60\\%$ 的评测用例：$1\\leq N\\leq 1000$。\n\n对于 $100\\%$ 的评测用例：$1\\leq N\\leq 10^6$，$0\\leq p\\leq 1$。", "locale": "zh-CN"}}}
{"pid": "P11046", "type": "P", "difficulty": 3, "samples": [["3 2 3\n1 2\n2 3\n2 1\n2 0\n1 1", "2.00"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "广度优先搜索 BFS", "概率论", "期望", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 Java B] 星际旅行", "background": "备注：原题（Java）时间限制 3.0s，空间限制 512 MB。", "description": "小明国庆节准备去某星系进行星际旅行，这个星系里一共有 $n$ 个星球，其中布置了 $m$ 道双向传送门，第 $i$ 道传送门可以连接 $a_i$，$b_i$ 两颗星球（$a_i \\neq b_i$ 且任意两颗星球之间最多只有一个传送门）。\n\n他看中了一款 “旅游盲盒”，一共有 $Q$ 个盲盒，第 $i$ 个盲盒里的旅行方案规定了旅行的起始星球 $x_i$ 和最多可以使用传送门的次数 $y_i$。只要从起始星球出发，使用传送门不超过规定次数能到达的所有星球都可以去旅行。\n\n小明关心在每个方案中有多少个星球可以旅行到。小明只能在这些盲盒里随机选一个购买，他想知道能旅行到的不同星球的数量的期望是多少。", "inputFormat": "输入共 $m + Q + 1$ 行。\n\n第一行为三个正整数 $n, m, Q$。\n\n后面 $m$ 行，每行两个正整数 $a_i$，$b_i$。\n\n后面 $Q$ 行，每行两个整数 $x_i$，$y_i$。", "outputFormat": "输出共一行，一个浮点数（四舍五入保留两位小数）。", "hint": "【样例解释】\n\n- 第一个盲盒可以旅行到 $1, 2, 3$。\n- 第二个盲盒可以旅行到 $2$。\n- 第三个盲盒可以旅行到 $1, 2$。\n\n所以期望是 $(3 + 1 + 2) / 3 = 2.00$。\n\n【数据范围】\n\n- 对于 $20 \\%$ 的评测用例，保证 $n \\leq 300$。\n- 对于 $100 \\%$ 的评测用例，保证 $n \\leq 1000$，$m \\leq \\min \\left\\{\\dfrac{n(n - 1)}{2}, 5n\\right\\}$，$Q \\leq 50000$，$0 \\leq y_i \\leq n$，$1 \\leq x_i \\leq n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 Java B] 星际旅行", "background": "备注：原题（Java）时间限制 3.0s，空间限制 512 MB。", "description": "小明国庆节准备去某星系进行星际旅行，这个星系里一共有 $n$ 个星球，其中布置了 $m$ 道双向传送门，第 $i$ 道传送门可以连接 $a_i$，$b_i$ 两颗星球（$a_i \\neq b_i$ 且任意两颗星球之间最多只有一个传送门）。\n\n他看中了一款 “旅游盲盒”，一共有 $Q$ 个盲盒，第 $i$ 个盲盒里的旅行方案规定了旅行的起始星球 $x_i$ 和最多可以使用传送门的次数 $y_i$。只要从起始星球出发，使用传送门不超过规定次数能到达的所有星球都可以去旅行。\n\n小明关心在每个方案中有多少个星球可以旅行到。小明只能在这些盲盒里随机选一个购买，他想知道能旅行到的不同星球的数量的期望是多少。", "inputFormat": "输入共 $m + Q + 1$ 行。\n\n第一行为三个正整数 $n, m, Q$。\n\n后面 $m$ 行，每行两个正整数 $a_i$，$b_i$。\n\n后面 $Q$ 行，每行两个整数 $x_i$，$y_i$。", "outputFormat": "输出共一行，一个浮点数（四舍五入保留两位小数）。", "hint": "【样例解释】\n\n- 第一个盲盒可以旅行到 $1, 2, 3$。\n- 第二个盲盒可以旅行到 $2$。\n- 第三个盲盒可以旅行到 $1, 2$。\n\n所以期望是 $(3 + 1 + 2) / 3 = 2.00$。\n\n【数据范围】\n\n- 对于 $20 \\%$ 的评测用例，保证 $n \\leq 300$。\n- 对于 $100 \\%$ 的评测用例，保证 $n \\leq 1000$，$m \\leq \\min \\left\\{\\dfrac{n(n - 1)}{2}, 5n\\right\\}$，$Q \\leq 50000$，$0 \\leq y_i \\leq n$，$1 \\leq x_i \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P11047", "type": "P", "difficulty": 5, "samples": [["2\n5\n1 1 1 1 1\n1 0 1 1 0\n1 0 0 0 1\n1 0 1 0 1\n1 1 1 1 1\n5\n1 0 0 1 1\n1 1 1 1 1\n1 1 1 1 0\n1 1 1 0 1\n0 1 1 1 1", "No\nYes"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "2024", "剪枝", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 Java B] LITS 游戏", "background": "备注：原题（Java）时间限制 3.0s，空间限制 512 MB。", "description": "俄罗斯方块是一款风靡全球的游戏，在游戏中有多种方格图案，我们只关注这四个经典的方块图案：**LITS**，如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/run4pn8d.png)\n\nLITS 这四种方块都是由四个相同大小的小方块组成的。 \n现在给出一副大小为 $N \\times N$ 的格子图，每个格子上都有一个数字 $0/1$，如果格子处的数字为 $1$ 说明这个格子上有一个小方块，数字为 $0$ 则没有。 \n你需要判断从这个格子图上是否可以找出 LITS 四个方块图案（每个方块图案之间都是独立的，不存在不同的图案公用同一个小方块的情况）。其中 LITS 方块的形状旋转任意个 $90^\\circ$ 都是合法的，但不允许翻转。", "inputFormat": "第一行一个整数 $T$，表示有 $T$ 组数据。 \n每组数据的第一行包含一个整数 $N$，表示格子图大小。 \n接下来输入 $N$ 行，每行 $N$ 个值为 $0/1$ 的整数，表示格子布局。", "outputFormat": "对于每组数据，输出一行包含一个字符串。如果此组数据满足题意则输出 `Yes`，否则输出 `No`。", "hint": "【样例解释】\n\n对于样例中的第二个格子图，一种 LITS 的摆放方案如下：\n\n```txt\n1 0 0 1 1\nL S T T T\nL S S T 0\nL L S 0 1\n0 I I I I\n```\n\n【数据范围】\n\n- 对于 $30 \\%$ 的评测用例：$1 \\leq N \\leq 5$。\n- 对于 $60 \\%$ 的评测用例：$1 \\leq N \\leq 10$。\n- 对于 $100 \\%$ 的评测用例：$1 \\leq T \\leq 10$，$1 \\leq N \\leq 50$。\n\n【特别备注】\n\n由于讨论情况较多，本题部分其他平台的题解可能存在错误。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 Java B] LITS 游戏", "background": "备注：原题（Java）时间限制 3.0s，空间限制 512 MB。", "description": "俄罗斯方块是一款风靡全球的游戏，在游戏中有多种方格图案，我们只关注这四个经典的方块图案：**LITS**，如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/run4pn8d.png)\n\nLITS 这四种方块都是由四个相同大小的小方块组成的。 \n现在给出一副大小为 $N \\times N$ 的格子图，每个格子上都有一个数字 $0/1$，如果格子处的数字为 $1$ 说明这个格子上有一个小方块，数字为 $0$ 则没有。 \n你需要判断从这个格子图上是否可以找出 LITS 四个方块图案（每个方块图案之间都是独立的，不存在不同的图案公用同一个小方块的情况）。其中 LITS 方块的形状旋转任意个 $90^\\circ$ 都是合法的，但不允许翻转。", "inputFormat": "第一行一个整数 $T$，表示有 $T$ 组数据。 \n每组数据的第一行包含一个整数 $N$，表示格子图大小。 \n接下来输入 $N$ 行，每行 $N$ 个值为 $0/1$ 的整数，表示格子布局。", "outputFormat": "对于每组数据，输出一行包含一个字符串。如果此组数据满足题意则输出 `Yes`，否则输出 `No`。", "hint": "【样例解释】\n\n对于样例中的第二个格子图，一种 LITS 的摆放方案如下：\n\n```txt\n1 0 0 1 1\nL S T T T\nL S S T 0\nL L S 0 1\n0 I I I I\n```\n\n【数据范围】\n\n- 对于 $30 \\%$ 的评测用例：$1 \\leq N \\leq 5$。\n- 对于 $60 \\%$ 的评测用例：$1 \\leq N \\leq 10$。\n- 对于 $100 \\%$ 的评测用例：$1 \\leq T \\leq 10$，$1 \\leq N \\leq 50$。\n\n【特别备注】\n\n由于讨论情况较多，本题部分其他平台的题解可能存在错误。", "locale": "zh-CN"}}}
{"pid": "P11048", "type": "P", "difficulty": 4, "samples": [["5\n1 10 0\n6 6 0\n8 6 1\n6 10 0\n1 2 1", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["树形数据结构", "树状数组", "2024", "蓝桥杯省赛"], "title": "[蓝桥杯 2024 省 Java B] 拼十字", "background": "备注：原题（Java）时间限制 3.0s，空间限制 512 MB。", "description": "在 LQ 国神秘的古老森林，有一座被称为 “拼十字” 的神秘遗迹。据传， “拼十字” 是由古代文明建造的，它是一个巨大的石头结构，由两个巨大的矩形交叉叠放在一起，形成了一个庄严而神秘的十字形状。这个遗迹被认为是连接人类和神灵之间的通道，拥有神秘的力量和能量。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qn9sqnae.png)\n\n现在给出 $N$ 个矩形，其中第 $i$ 个矩形的长度和宽度分别为 $l_i$，$w_i$，并且矩形的颜色 $c_i$ 为红 $(0)$、黄 $(1)$、蓝 $(2)$ 中的一种。现在小蓝想知道在这 $N$ 个矩形中有多少对可以“拼十字”？\n\n两个矩形可以“拼十字”的充要条件是：\n\n1. 两个矩形的颜色不同；\n2. 矩形 $1$ 的长度严格大于矩形 $2$ 的长度并且矩形 $1$ 的宽度严格小于矩形 $2$ 的宽度。\n\n注意，矩形长度和宽度属性是固定的，是不可以通过旋转矩形而发生转变的。", "inputFormat": "第一行一个整数 $N$，表示有 $N$ 个矩形。\n\n接下来 $N$ 行，每行输入三个整数 $l$、$w$、$c$ 表示一个矩形的长、宽和颜色。", "outputFormat": "输出一个整数表示答案。由于答案可能会很大，所以你需要将答案对 $10^9 + 7$ 取模之后输出。", "hint": "【样例解释】\n\n第 $3$ 个矩形可以和第 $1$ 个矩形拼十字，第 $3$ 个矩形也可以和第 $4$ 个矩形拼十字。所以一共有两对矩形可以拼十字，答案为 $2$。\n\n【数据范围】\n\n- 对于 $30\\%$ 的评测用例：$1 \\leq N \\leq 5000$。\n- 对于 $100 \\%$ 的评测用例：$1 \\leq N \\leq 10^5$，$1 \\leq l,w \\leq 10^5$，$0 \\leq c \\leq 2$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2024 省 Java B] 拼十字", "background": "备注：原题（Java）时间限制 3.0s，空间限制 512 MB。", "description": "在 LQ 国神秘的古老森林，有一座被称为 “拼十字” 的神秘遗迹。据传， “拼十字” 是由古代文明建造的，它是一个巨大的石头结构，由两个巨大的矩形交叉叠放在一起，形成了一个庄严而神秘的十字形状。这个遗迹被认为是连接人类和神灵之间的通道，拥有神秘的力量和能量。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qn9sqnae.png)\n\n现在给出 $N$ 个矩形，其中第 $i$ 个矩形的长度和宽度分别为 $l_i$，$w_i$，并且矩形的颜色 $c_i$ 为红 $(0)$、黄 $(1)$、蓝 $(2)$ 中的一种。现在小蓝想知道在这 $N$ 个矩形中有多少对可以“拼十字”？\n\n两个矩形可以“拼十字”的充要条件是：\n\n1. 两个矩形的颜色不同；\n2. 矩形 $1$ 的长度严格大于矩形 $2$ 的长度并且矩形 $1$ 的宽度严格小于矩形 $2$ 的宽度。\n\n注意，矩形长度和宽度属性是固定的，是不可以通过旋转矩形而发生转变的。", "inputFormat": "第一行一个整数 $N$，表示有 $N$ 个矩形。\n\n接下来 $N$ 行，每行输入三个整数 $l$、$w$、$c$ 表示一个矩形的长、宽和颜色。", "outputFormat": "输出一个整数表示答案。由于答案可能会很大，所以你需要将答案对 $10^9 + 7$ 取模之后输出。", "hint": "【样例解释】\n\n第 $3$ 个矩形可以和第 $1$ 个矩形拼十字，第 $3$ 个矩形也可以和第 $4$ 个矩形拼十字。所以一共有两对矩形可以拼十字，答案为 $2$。\n\n【数据范围】\n\n- 对于 $30\\%$ 的评测用例：$1 \\leq N \\leq 5000$。\n- 对于 $100 \\%$ 的评测用例：$1 \\leq N \\leq 10^5$，$1 \\leq l,w \\leq 10^5$，$0 \\leq c \\leq 2$。", "locale": "zh-CN"}}}
{"pid": "P11049", "type": "P", "difficulty": 5, "samples": [["5\n15 5 1\n12 4 2\n2 5 2\n10 6 3\n21 3 2\n3\n5\n9\n1\n", "16\n11\n23\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000]}, "tags": ["线段树", "2024", "IOI", "交互题", "矩阵乘法", "分块"], "title": "[IOI 2024] 尼罗河船运", "background": "这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。\n\n本题仅支持 C++ 语言提交。但请勿使用 C++14 (GCC 9)", "description": "你想通过尼罗河来运输 $N$ 件手工艺品。这些手工艺品从 $0$ 到 $N-1$ 编号。第 $i$（$0 \\leq i < N$）件手工艺品的重量是 $W[i]$。\n\n\n\n为了运输这些手工艺品，你使用了特制的船。每艘船**最多**可以运**两件**手工艺品。\n\n\n* 如果你决定将单件手工艺品放在一艘船上，那么这件手工艺品的重量可以是任意的。\n* 如果你想把两件手工艺品一起放在同一艘船上，你必须保证这艘船的平衡。具体来说，如果手工艺品 $p$ 和 $q$（$0 \\leq p < q < N$）的重量差的绝对值不超过 $D$，即满足 $|W[p] - W[q]| \\leq D$，那么你可以将它们一起放在同一艘船上。\n\n\n\n你必须付费来运一件手工艺品，其运费取决于同一艘船上所运载的手工艺品数量。手工艺品 $i$（$0 \\leq i < N$）的运费是：\n\n* $A[i]$，如果你把手工艺品 $i$ 单独放在船上，或者\n* $B[i]$，如果你把手工艺品 $i$ 和另一件手工艺品一起放在船上。\n\n\n注意在第二种情况中，你要为船上两件手工艺品都支付运费。具体来说，如果你决定用同一艘船运输手工艺品 $p$ 和 $q$（$0 \\leq p < q < N$），你需要支付 $B[p] + B[q]$。\n\n\n\n一件手工艺品单独用一艘船运输的费用，总是比与其他手工艺品合用一艘船时的费用要高，所以对任意满足 $0 \\leq i < N$ 的 $i$，都有 $B[i] < A[i]$。\n\n\n麻烦的是，由于尼罗河变化莫测，导致 $D$ 的值经常改变。你的任务是回答 $Q$ 个问题，从 $0$ 到 $Q-1$ 编号。这些问题用一个长度为 $Q$ 的数组 $E$ 来描述。问题 $j$（$0 \\leq j < Q$）的答案，是在 $D$ 的值等于 $E[j]$ 时运输所有 $N$ 件手工艺品的最小总代价。", "inputFormat": "评测程序按如下顺序读取输入数据：\n\n```plain\nN\nW[0] A[0] B[0]\nW[1] A[1] B[1]\n...\nW[N-1] A[N-1] B[N-1]\nQ\nE[0]\nE[1]\n...\nE[Q-1]\n```", "outputFormat": "评测程序按如下顺序输出：\n\n\n\n```plain\nR[0]\nR[1]\n...\nR[S-1]\n```\n\n这里，$S$ 是 `calculate_costs` 所返回的数组 $R$ 的长度。", "hint": "## 实现细节\n\n\n你需要实现以下函数。\n\n```\nstd::vector<long long> calculate_costs(\n    std::vector<int> W, std::vector<int> A, \n    std::vector<int> B, std::vector<int> E)\n```\n\n* $W$，$A$，$B$：长度均为 $N$ 的整数数组，分别给出手工艺品的重量和运费。\n* $E$：长度为 $Q$ 的整数数组，给出每个问题中的 $D$ 值。\n* 该函数应该返回一个包含 $Q$ 个整数的数组 $R$，给出运输手工艺品的最小总代价，其中 $R[j]$ 对应 $D$ 等于 $E[j]$（对每个满足 $0 \\leq j < Q$ 的 $j$）时的运费。\n* 对于每个测试用例，该函数恰好被调用一次。\n\n\n## 约束条件\n\n* $1 \\leq N \\leq 100\\,000$。\n* $1 \\leq Q \\leq 100\\,000$。\n* 对每个满足 $0 \\leq i < N$ 的 $i$，都有 $1 \\leq W[i] \\leq 10^{9}$。\n* 对每个满足 $0 \\leq i < N$ 的 $i$，都有 $1 \\leq B[i] < A[i] \\leq 10^{9}$。\n* 对每个满足 $0 \\leq j < Q$ 的 $j$，都有 $1 \\leq E[j] \\leq 10^{9}$。\n\n\n## 子任务\n\n| 子任务 | 分数 | 额外的约束条件                                               |\n| :----: | :--: | ------------------------------------------------------------ |\n|   1    | $6$  | $Q \\leq 5$；$N \\leq 2000$；对每个满足 $0 \\leq i < N$ 的 $i$，都有 $W[i] = 1$ |\n|   2    | $13$ | $Q \\leq 5$；对每个满足  $0 \\leq i < N$ 的 $i$，都有 $W[i] = i+1$ |\n|   3    | $17$ | $Q \\leq 5$；对每个满足  $0 \\leq i < N$ 的 $i$，都有 $A[i] = 2$ 且 $B[i] = 1$ |\n|   4    | $11$ | $Q \\leq 5$；$N \\leq 2000$                                    |\n|   5    | $20$ | $Q \\leq 5$                                                   |\n|   6    | $15$ | 对每个满足 $0 \\leq i < N$ 的 $i$，都有 $A[i] = 2$ 且 $B[i] = 1$ |\n|   7    | $18$ | 没有额外的约束条件。                                         |\n\n\n## 例子\n\n\n考虑以下调用。\n\n```\ncalculate_costs([15, 12, 2, 10, 21],\n                [5, 4, 5, 6, 3],\n                [1, 2, 2, 3, 2],\n                [5, 9, 1])\n```\n\n\n在该例子中，我们有 $N=5$ 件手工艺品和 $Q=3$ 个问题。\n\n\n\n在第一个问题中，$D = 5$。你可以把手工艺品 $0$ 和手工艺品 $3$ 放在同一艘船上（因为 $|15 - 10| \\leq 5$），而其他手工艺品都各自放在不同的船上。这使得运输所有手工艺品的总代价最小，即 $1+4+5+3+3 = 16$。\n\n\n在第二个问题中，$D = 9$。你可以把手工艺品 $0$ 和手工艺品 $1$ 放在同一艘船上（因为 $|15 - 12| \\leq 9$），而把手工艺品 $2$ 和手工艺品 $3$ 放在同一艘船上（因为 $|2 - 10| \\leq 9$）。剩下的手工艺品单独用一艘船运输。这使得运输所有手工艺品的总代价最小，即 $1+2+2+3+3 = 11$。\n\n\n在最后一个问题中，$D = 1$。你需要把每件手工艺品都单独用一艘船运输。这使得运输所有手工艺品的总代价最小，即 $5+4+5+6+3 = 23$。\n\n因此，该函数应该返回 $[16, 11, 23]$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2024] 尼罗河船运", "background": "这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。\n\n本题仅支持 C++ 语言提交。但请勿使用 C++14 (GCC 9)", "description": "你想通过尼罗河来运输 $N$ 件手工艺品。这些手工艺品从 $0$ 到 $N-1$ 编号。第 $i$（$0 \\leq i < N$）件手工艺品的重量是 $W[i]$。\n\n\n\n为了运输这些手工艺品，你使用了特制的船。每艘船**最多**可以运**两件**手工艺品。\n\n\n* 如果你决定将单件手工艺品放在一艘船上，那么这件手工艺品的重量可以是任意的。\n* 如果你想把两件手工艺品一起放在同一艘船上，你必须保证这艘船的平衡。具体来说，如果手工艺品 $p$ 和 $q$（$0 \\leq p < q < N$）的重量差的绝对值不超过 $D$，即满足 $|W[p] - W[q]| \\leq D$，那么你可以将它们一起放在同一艘船上。\n\n\n\n你必须付费来运一件手工艺品，其运费取决于同一艘船上所运载的手工艺品数量。手工艺品 $i$（$0 \\leq i < N$）的运费是：\n\n* $A[i]$，如果你把手工艺品 $i$ 单独放在船上，或者\n* $B[i]$，如果你把手工艺品 $i$ 和另一件手工艺品一起放在船上。\n\n\n注意在第二种情况中，你要为船上两件手工艺品都支付运费。具体来说，如果你决定用同一艘船运输手工艺品 $p$ 和 $q$（$0 \\leq p < q < N$），你需要支付 $B[p] + B[q]$。\n\n\n\n一件手工艺品单独用一艘船运输的费用，总是比与其他手工艺品合用一艘船时的费用要高，所以对任意满足 $0 \\leq i < N$ 的 $i$，都有 $B[i] < A[i]$。\n\n\n麻烦的是，由于尼罗河变化莫测，导致 $D$ 的值经常改变。你的任务是回答 $Q$ 个问题，从 $0$ 到 $Q-1$ 编号。这些问题用一个长度为 $Q$ 的数组 $E$ 来描述。问题 $j$（$0 \\leq j < Q$）的答案，是在 $D$ 的值等于 $E[j]$ 时运输所有 $N$ 件手工艺品的最小总代价。", "inputFormat": "评测程序按如下顺序读取输入数据：\n\n```plain\nN\nW[0] A[0] B[0]\nW[1] A[1] B[1]\n...\nW[N-1] A[N-1] B[N-1]\nQ\nE[0]\nE[1]\n...\nE[Q-1]\n```", "outputFormat": "评测程序按如下顺序输出：\n\n\n\n```plain\nR[0]\nR[1]\n...\nR[S-1]\n```\n\n这里，$S$ 是 `calculate_costs` 所返回的数组 $R$ 的长度。", "hint": "## 实现细节\n\n\n你需要实现以下函数。\n\n```\nstd::vector<long long> calculate_costs(\n    std::vector<int> W, std::vector<int> A, \n    std::vector<int> B, std::vector<int> E)\n```\n\n* $W$，$A$，$B$：长度均为 $N$ 的整数数组，分别给出手工艺品的重量和运费。\n* $E$：长度为 $Q$ 的整数数组，给出每个问题中的 $D$ 值。\n* 该函数应该返回一个包含 $Q$ 个整数的数组 $R$，给出运输手工艺品的最小总代价，其中 $R[j]$ 对应 $D$ 等于 $E[j]$（对每个满足 $0 \\leq j < Q$ 的 $j$）时的运费。\n* 对于每个测试用例，该函数恰好被调用一次。\n\n\n## 约束条件\n\n* $1 \\leq N \\leq 100\\,000$。\n* $1 \\leq Q \\leq 100\\,000$。\n* 对每个满足 $0 \\leq i < N$ 的 $i$，都有 $1 \\leq W[i] \\leq 10^{9}$。\n* 对每个满足 $0 \\leq i < N$ 的 $i$，都有 $1 \\leq B[i] < A[i] \\leq 10^{9}$。\n* 对每个满足 $0 \\leq j < Q$ 的 $j$，都有 $1 \\leq E[j] \\leq 10^{9}$。\n\n\n## 子任务\n\n| 子任务 | 分数 | 额外的约束条件                                               |\n| :----: | :--: | ------------------------------------------------------------ |\n|   1    | $6$  | $Q \\leq 5$；$N \\leq 2000$；对每个满足 $0 \\leq i < N$ 的 $i$，都有 $W[i] = 1$ |\n|   2    | $13$ | $Q \\leq 5$；对每个满足  $0 \\leq i < N$ 的 $i$，都有 $W[i] = i+1$ |\n|   3    | $17$ | $Q \\leq 5$；对每个满足  $0 \\leq i < N$ 的 $i$，都有 $A[i] = 2$ 且 $B[i] = 1$ |\n|   4    | $11$ | $Q \\leq 5$；$N \\leq 2000$                                    |\n|   5    | $20$ | $Q \\leq 5$                                                   |\n|   6    | $15$ | 对每个满足 $0 \\leq i < N$ 的 $i$，都有 $A[i] = 2$ 且 $B[i] = 1$ |\n|   7    | $18$ | 没有额外的约束条件。                                         |\n\n\n## 例子\n\n\n考虑以下调用。\n\n```\ncalculate_costs([15, 12, 2, 10, 21],\n                [5, 4, 5, 6, 3],\n                [1, 2, 2, 3, 2],\n                [5, 9, 1])\n```\n\n\n在该例子中，我们有 $N=5$ 件手工艺品和 $Q=3$ 个问题。\n\n\n\n在第一个问题中，$D = 5$。你可以把手工艺品 $0$ 和手工艺品 $3$ 放在同一艘船上（因为 $|15 - 10| \\leq 5$），而其他手工艺品都各自放在不同的船上。这使得运输所有手工艺品的总代价最小，即 $1+4+5+3+3 = 16$。\n\n\n在第二个问题中，$D = 9$。你可以把手工艺品 $0$ 和手工艺品 $1$ 放在同一艘船上（因为 $|15 - 12| \\leq 9$），而把手工艺品 $2$ 和手工艺品 $3$ 放在同一艘船上（因为 $|2 - 10| \\leq 9$）。剩下的手工艺品单独用一艘船运输。这使得运输所有手工艺品的总代价最小，即 $1+2+2+3+3 = 11$。\n\n\n在最后一个问题中，$D = 1$。你需要把每件手工艺品都单独用一艘船运输。这使得运输所有手工艺品的总代价最小，即 $5+4+5+6+3 = 23$。\n\n因此，该函数应该返回 $[16, 11, 23]$。", "locale": "zh-CN"}}}
{"pid": "P11050", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "IOI", "交互题", "Special Judge", "通信题"], "title": "[IOI 2024] 消息篡改者", "background": "不要 $\\texttt{\\#include \"message.h\"}$。\n\n请使用 C++ 20 提交，并在文件头粘贴如下的内容：\n\n```cpp\n#include <vector>\n\nstd::vector<bool> send_packet(std::vector<bool>);\nvoid send_message(std::vector<bool>, std::vector<bool>);\nstd::vector<bool> receive_message(std::vector<std::vector<bool>>);\n```", "description": "## 任务描述\n\nAisha 和 Basma 是两位互相通信的朋友。Aisha 有一条消息 $M$ 想要发给 Basma，该消息是由 $S$ 个比特（即若干 0 或 1）组成的序列。Aisha 通过发送**数据包**来跟 Basma 通信。一个数据包是由 $31$ 个比特组成的序列，对应的位置从 $0$ 到 $30$ 编号。Aisha 想向 Basma 发送消息 $M$ 时，会发送若干数据包。\n\n然而第三个人 Cleopatra 在破坏 Aisha 和 Basma 之间的通信，能够**篡改**发送的数据包。在每个数据包中，Cleopatra 可以修改恰好 $15$ 个位置的比特。具体来说，给定长度为 $31$ 的数组 $C$，其中每个元素为 $0$ 或 $1$，含义如下：\n\n* $C[i] = 1$ 表示位置为 $i$ 的比特可以被 Cleopatra 修改。我们称此类位置是被 Cleopatra **控制**的。\n* $C[i] = 0$ 表示位置为 $i$ 的比特不能被 Cleopatra 修改。\n\n数组 $C$ 恰好包含 $15$ 个 $1$ 和 $16$ 个 $0$。当发送消息 $M$ 时，Cleopatra 控制的位置集合对于所有数据包都是相同的。Aisha 清楚地知道哪 $15$ 个位置被 Cleopatra 控制。Basma 只知道有 $15$ 个位置被 Cleopatra 控制，但不知道是哪些位置。\n\n令 $A$ 为 Aisha 决定要发送的数据包（称之为**原始数据包**）。令 $B$ 为 Basma 收到的数据包（称之为**篡改数据包**）。对每个在 $0 \\leq i < 31$ 的 $i$ 都有：\n\n* 如果 Cleopatra 不能控制位置为 $i$ 的比特（$C[i]=0$），那么 Basma 将能收到 Aisha 发送的第 $i$ 个比特（$B[i]=A[i]$），\n* 否则，如果 Cleopatra 控制了位置为 $i$ 的比特（$C[i]=1$），那么 $B[i]$ 的值由 Cleopatra 决定。\n\n每个数据包发送后，Aisha 会立刻知道被篡改后的数据包内容。\n\n当 Aisha 发送完所有数据包后，Basma **按照发送顺序**接收到所有被篡改的数据包，她必须重建原始消息 $M$。\n\n你的任务是制定并实现某种策略，使得 Aisha 给 Basma 发送消息 $M$ 时，Basma 能够从篡改数据包中恢复 $M$。具体来说，你要实现两个函数，第一个函数进行 Aisha 的动作：给定消息 $M$ 和数组 $C$，给 Basma 发送若干数据包来传输消息。第二个函数进行 Basma 的动作：给定若干篡改数据包，恢复原始消息 $M$。\n\n## 实现细节\n\n你要实现的第一个函数是：\n\n```\nvoid send_message(std::vector<bool> M, std::vector<bool> C)\n```\n\n* $M$：长度为 $S$ 的数组，描述 Aisha 想要发给 Basma 的消息。\n* $C$：长度为 $31$ 的数组，标记 Cleopatra 控制的数据包中的位置。\n* 每个测试用例中，该函数**最多**可被调用**2100次**。\n\n该函数调用以下函数来发送数据包：\n\n```\nstd::vector<bool> send_packet(std::vector<bool> A)\n```\n\n* $A$：原始数据包（长度为 $31$ 的数组），表示 Aisha 发送的比特。\n* 此函数返回篡改数据包 $B$，表示 Basma 接收到的比特。\n* 此函数在 `send_message` 的一次调用过程中最多被调用 $100$ 次。\n\n你要实现的第二个函数是：\n\n```\nstd::vector<bool> receive_message(std::vector<std::vector<bool>> R)\n```\n\n* $R$：描述若干篡改数据包的数组。这些数据包源自 Aisha 在一次 `send_message` 调用时发送的若干数据包，且按照 Aisha 的发送顺序排列。$R$ 的每个元素是长度为 $31$ 的数组，表示一个篡改数据包。\n* 该函数应返回包含 $S$ 个比特的数组，且与原始消息 $M$ 相同。\n* 每个测试用例中，该函数可能被调用**多次**。对于每次 `send_message` 的调用，对应地该函数要有**恰好一次**调用。函数 `receive_message` 的**调用顺序**不必与对应的 `send_message` 调用顺序一致。\n\n注意在评测系统中，`send_message` 和 `receive_message` 两个函数是在**不同的程序**中来调用的。", "inputFormat": "", "outputFormat": "", "hint": "## 约束条件\n\n* $1 \\leq S \\leq 1024$\n* $C$ 恰好有 $31$ 个元素，且其中 $16$ 个为 $0$，$15$ 个为 $1$。\n\n## 子任务与评分\n\n如果在任意的测试用例中，函数 ``send_packet`` 的调用不符合上述规则，或者某个函数 `receive_message` 的调用的返回值不正确，你的解答在该测试用例上得 $0$ 分。\n\n否则，令 $Q$ 为所有测试用例中，每次 `send_message` 调用时调用函数 `send_packet` 的次数的最大值。令 $X$ 等于：\n\n- $1$，如果 $Q \\leq 66$\n- $0.95 ^ {Q - 66}$，如果 $66 < Q \\leq 100$\n- $0$，如果 $100 < Q$\n\n那么，得分将由以下式子计算获得：\n\n| 子任务 |     分数     | 额外的约束条件       |\n| :----: | :----------: | -------------------- |\n|   1    | $10 \\cdot X$ | $S \\leq 64$          |\n|   2    | $90 \\cdot X$ | 没有额外的约束条件。 |\n\n注意在某些测试用例中，评测程序的行为是**自适应的**。这意味着 `send_packet` 的返回值可能取决于它的输入参数和以前调用该函数的返回值。\n\n## 例子\n\n考虑以下调用。\n\n```\nsend_message([0, 1, 1, 0],\n             [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n              1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])\n```\n\nAisha 试图发给 Basma 的消息是 $[0, 1, 1, 0]$。数据包的第 $0$ 至第 $15$ 个比特不能被 Cleopatra 修改，而第 $16$ 至第 $30$ 个比特可以被 Cleopatra 修改。\n\n为便于解释这个例子，我们假设 Cleopatra 的行为是确定性的：她交替地用 $0$ 和 $1$ 填充所控制的比特，也就是她把她控制的第一个位置赋 $0$（例子中的第 $16$ 位），把她控制的第二个位置赋 $1$（第 $17$ 位），把她控制的第三个位置赋 $0$（第 $18$ 位），以此类推。\n\nAisha 可以做出的一种决定是在一个数据包中发送原始消息中的两个比特，例如她是这样做的：通过她控制的前 $8$ 个位置来发送第一个比特，通过她控制的接下来 $8$ 个位置来发送第二个比特。\n\n于是 Aisha 发送以下数据包：\n\n```\nsend_packet([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,\n             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n```\n\n由于 Cleopatra 可以更改最后 $15$ 个比特，所以 Aisha 决定随意设置它们，因为它们可能会被覆盖。使用前面假定的 Cleopatra 的策略，该函数返回：\n\n$[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]$。\n\nAisha 决定在第二个数据包中发送 $M$ 的最后两个比特，与之前类似：\n\n```\nsend_packet([1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n```\n\n根据假定的 Cleopatra 的策略，该函数返回：\n\n$[1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]$。\n\nAisha 还可以发送更多的数据包，但她没有这样做。\n\n然后评测程序进行以下函数调用：\n\n```\nreceive_message([[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,\n                  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],\n                 [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n                  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]])\n```\n\nBasma 按照如下方式恢复消息 $M$。她从每个数据包中提取出第一个连续出现两次的比特，以及最后一个连续出现两次的比特。也就是说，她从第一个数据包提取出两个比特 $[0, 1]$ ，从第二个数据包中提取出两个比特 $[1, 0]$。把它们放在一起，她恢复了消息 $[0, 1, 1, 0]$，这是对 `receive_message` 调用的正确返回值。\n\n可以证明，在假设的 Cleopatra 的策略下，对于长度为 $4$ 的消息，不管 $C$ 的值是多少，Basma 这样做能够正确恢复 $M$。然而，一般情况下这并不正确。\n\n## 评测程序示例\n\n评测程序示例不具备自适应性，Cleopatra 的行为是确定性的，她交替地用 $0$ 和 $1$ 来填充她控制的比特，就像她在例子中所做的那样。\n\n输入格式：**输入第一行包含一个整数 $T$，指定测试用例的数量。**接下来有 $T$ 组测试用例，每组测试用例都按以下格式描述：\n\n```\nS\nM[0]  M[1]  ...  M[S-1]\nC[0]  C[1]  ...  C[30]\n```\n\n输出格式：评测程序示例按照输入的顺序，用以下格式输出 $T$ 组测试用例的结果：\n\n```\nK L\nD[0]  D[1]  ...  D[L-1]\n```\n\n这里， $K$ 是 `send_packet` 的调用次数，$D$ 是 `receive_message` 返回的消息，$L$ 是它的长度。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2024] 消息篡改者", "background": "不要 $\\texttt{\\#include \"message.h\"}$。\n\n请使用 C++ 20 提交，并在文件头粘贴如下的内容：\n\n```cpp\n#include <vector>\n\nstd::vector<bool> send_packet(std::vector<bool>);\nvoid send_message(std::vector<bool>, std::vector<bool>);\nstd::vector<bool> receive_message(std::vector<std::vector<bool>>);\n```", "description": "## 任务描述\n\nAisha 和 Basma 是两位互相通信的朋友。Aisha 有一条消息 $M$ 想要发给 Basma，该消息是由 $S$ 个比特（即若干 0 或 1）组成的序列。Aisha 通过发送**数据包**来跟 Basma 通信。一个数据包是由 $31$ 个比特组成的序列，对应的位置从 $0$ 到 $30$ 编号。Aisha 想向 Basma 发送消息 $M$ 时，会发送若干数据包。\n\n然而第三个人 Cleopatra 在破坏 Aisha 和 Basma 之间的通信，能够**篡改**发送的数据包。在每个数据包中，Cleopatra 可以修改恰好 $15$ 个位置的比特。具体来说，给定长度为 $31$ 的数组 $C$，其中每个元素为 $0$ 或 $1$，含义如下：\n\n* $C[i] = 1$ 表示位置为 $i$ 的比特可以被 Cleopatra 修改。我们称此类位置是被 Cleopatra **控制**的。\n* $C[i] = 0$ 表示位置为 $i$ 的比特不能被 Cleopatra 修改。\n\n数组 $C$ 恰好包含 $15$ 个 $1$ 和 $16$ 个 $0$。当发送消息 $M$ 时，Cleopatra 控制的位置集合对于所有数据包都是相同的。Aisha 清楚地知道哪 $15$ 个位置被 Cleopatra 控制。Basma 只知道有 $15$ 个位置被 Cleopatra 控制，但不知道是哪些位置。\n\n令 $A$ 为 Aisha 决定要发送的数据包（称之为**原始数据包**）。令 $B$ 为 Basma 收到的数据包（称之为**篡改数据包**）。对每个在 $0 \\leq i < 31$ 的 $i$ 都有：\n\n* 如果 Cleopatra 不能控制位置为 $i$ 的比特（$C[i]=0$），那么 Basma 将能收到 Aisha 发送的第 $i$ 个比特（$B[i]=A[i]$），\n* 否则，如果 Cleopatra 控制了位置为 $i$ 的比特（$C[i]=1$），那么 $B[i]$ 的值由 Cleopatra 决定。\n\n每个数据包发送后，Aisha 会立刻知道被篡改后的数据包内容。\n\n当 Aisha 发送完所有数据包后，Basma **按照发送顺序**接收到所有被篡改的数据包，她必须重建原始消息 $M$。\n\n你的任务是制定并实现某种策略，使得 Aisha 给 Basma 发送消息 $M$ 时，Basma 能够从篡改数据包中恢复 $M$。具体来说，你要实现两个函数，第一个函数进行 Aisha 的动作：给定消息 $M$ 和数组 $C$，给 Basma 发送若干数据包来传输消息。第二个函数进行 Basma 的动作：给定若干篡改数据包，恢复原始消息 $M$。\n\n## 实现细节\n\n你要实现的第一个函数是：\n\n```\nvoid send_message(std::vector<bool> M, std::vector<bool> C)\n```\n\n* $M$：长度为 $S$ 的数组，描述 Aisha 想要发给 Basma 的消息。\n* $C$：长度为 $31$ 的数组，标记 Cleopatra 控制的数据包中的位置。\n* 每个测试用例中，该函数**最多**可被调用**2100次**。\n\n该函数调用以下函数来发送数据包：\n\n```\nstd::vector<bool> send_packet(std::vector<bool> A)\n```\n\n* $A$：原始数据包（长度为 $31$ 的数组），表示 Aisha 发送的比特。\n* 此函数返回篡改数据包 $B$，表示 Basma 接收到的比特。\n* 此函数在 `send_message` 的一次调用过程中最多被调用 $100$ 次。\n\n你要实现的第二个函数是：\n\n```\nstd::vector<bool> receive_message(std::vector<std::vector<bool>> R)\n```\n\n* $R$：描述若干篡改数据包的数组。这些数据包源自 Aisha 在一次 `send_message` 调用时发送的若干数据包，且按照 Aisha 的发送顺序排列。$R$ 的每个元素是长度为 $31$ 的数组，表示一个篡改数据包。\n* 该函数应返回包含 $S$ 个比特的数组，且与原始消息 $M$ 相同。\n* 每个测试用例中，该函数可能被调用**多次**。对于每次 `send_message` 的调用，对应地该函数要有**恰好一次**调用。函数 `receive_message` 的**调用顺序**不必与对应的 `send_message` 调用顺序一致。\n\n注意在评测系统中，`send_message` 和 `receive_message` 两个函数是在**不同的程序**中来调用的。", "inputFormat": "", "outputFormat": "", "hint": "## 约束条件\n\n* $1 \\leq S \\leq 1024$\n* $C$ 恰好有 $31$ 个元素，且其中 $16$ 个为 $0$，$15$ 个为 $1$。\n\n## 子任务与评分\n\n如果在任意的测试用例中，函数 ``send_packet`` 的调用不符合上述规则，或者某个函数 `receive_message` 的调用的返回值不正确，你的解答在该测试用例上得 $0$ 分。\n\n否则，令 $Q$ 为所有测试用例中，每次 `send_message` 调用时调用函数 `send_packet` 的次数的最大值。令 $X$ 等于：\n\n- $1$，如果 $Q \\leq 66$\n- $0.95 ^ {Q - 66}$，如果 $66 < Q \\leq 100$\n- $0$，如果 $100 < Q$\n\n那么，得分将由以下式子计算获得：\n\n| 子任务 |     分数     | 额外的约束条件       |\n| :----: | :----------: | -------------------- |\n|   1    | $10 \\cdot X$ | $S \\leq 64$          |\n|   2    | $90 \\cdot X$ | 没有额外的约束条件。 |\n\n注意在某些测试用例中，评测程序的行为是**自适应的**。这意味着 `send_packet` 的返回值可能取决于它的输入参数和以前调用该函数的返回值。\n\n## 例子\n\n考虑以下调用。\n\n```\nsend_message([0, 1, 1, 0],\n             [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n              1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])\n```\n\nAisha 试图发给 Basma 的消息是 $[0, 1, 1, 0]$。数据包的第 $0$ 至第 $15$ 个比特不能被 Cleopatra 修改，而第 $16$ 至第 $30$ 个比特可以被 Cleopatra 修改。\n\n为便于解释这个例子，我们假设 Cleopatra 的行为是确定性的：她交替地用 $0$ 和 $1$ 填充所控制的比特，也就是她把她控制的第一个位置赋 $0$（例子中的第 $16$ 位），把她控制的第二个位置赋 $1$（第 $17$ 位），把她控制的第三个位置赋 $0$（第 $18$ 位），以此类推。\n\nAisha 可以做出的一种决定是在一个数据包中发送原始消息中的两个比特，例如她是这样做的：通过她控制的前 $8$ 个位置来发送第一个比特，通过她控制的接下来 $8$ 个位置来发送第二个比特。\n\n于是 Aisha 发送以下数据包：\n\n```\nsend_packet([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,\n             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n```\n\n由于 Cleopatra 可以更改最后 $15$ 个比特，所以 Aisha 决定随意设置它们，因为它们可能会被覆盖。使用前面假定的 Cleopatra 的策略，该函数返回：\n\n$[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]$。\n\nAisha 决定在第二个数据包中发送 $M$ 的最后两个比特，与之前类似：\n\n```\nsend_packet([1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n```\n\n根据假定的 Cleopatra 的策略，该函数返回：\n\n$[1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]$。\n\nAisha 还可以发送更多的数据包，但她没有这样做。\n\n然后评测程序进行以下函数调用：\n\n```\nreceive_message([[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,\n                  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],\n                 [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n                  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]])\n```\n\nBasma 按照如下方式恢复消息 $M$。她从每个数据包中提取出第一个连续出现两次的比特，以及最后一个连续出现两次的比特。也就是说，她从第一个数据包提取出两个比特 $[0, 1]$ ，从第二个数据包中提取出两个比特 $[1, 0]$。把它们放在一起，她恢复了消息 $[0, 1, 1, 0]$，这是对 `receive_message` 调用的正确返回值。\n\n可以证明，在假设的 Cleopatra 的策略下，对于长度为 $4$ 的消息，不管 $C$ 的值是多少，Basma 这样做能够正确恢复 $M$。然而，一般情况下这并不正确。\n\n## 评测程序示例\n\n评测程序示例不具备自适应性，Cleopatra 的行为是确定性的，她交替地用 $0$ 和 $1$ 来填充她控制的比特，就像她在例子中所做的那样。\n\n输入格式：**输入第一行包含一个整数 $T$，指定测试用例的数量。**接下来有 $T$ 组测试用例，每组测试用例都按以下格式描述：\n\n```\nS\nM[0]  M[1]  ...  M[S-1]\nC[0]  C[1]  ...  C[30]\n```\n\n输出格式：评测程序示例按照输入的顺序，用以下格式输出 $T$ 组测试用例的结果：\n\n```\nK L\nD[0]  D[1]  ...  D[L-1]\n```\n\n这里， $K$ 是 `send_packet` 的调用次数，$D$ 是 `receive_message` 返回的消息，$L$ 是它的长度。", "locale": "zh-CN"}}}
{"pid": "P11051", "type": "P", "difficulty": 7, "samples": [["3\n0 0\n1 1 1\n2\n1 1\n1 2\n", "3\n2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "IOI", "交互题"], "title": "[IOI 2024] 树上代价", "background": "提交时请不要引用 `tree.h`。\n\n请不要使用 C++14 (GCC 9) 提交。", "description": "有一棵包括 $N$ 个**结点**的**树**，结点从 $0$ 到 $N-1$ 编号。结点 $0$ 是树的**根**。除根以外的每个结点都有唯一的**父结点**。对所有满足 $1 \\leq i < N$ 的 $i$，结点 $i$ 的父结点为 $P[i]$，这里有 $P[i] < i$。我们约定 $P[0] = -1$。\n\n对所有结点 $i$（$0 \\leq i < N$），$i$ 的**子树**是如下结点组成的集合：\n * $i$，以及\n * 所有父结点为 $i$ 的结点，以及\n * 所有父结点的父结点为 $i$ 的结点，以及\n * 所有父结点的父结点的父结点为 $i$ 的结点，以及\n * 以此类推。\n\n下图给出了一个包含 $N = 6$ 个结点的树的例子。每个箭头都从某个结点连向它的父结点（根结点除外，因为它没有父结点）。结点 $2$ 的子树包括结点 $2, 3, 4$ 和 $5$。结点 $0$ 的子树包括树中的全部 $6$ 个结点，而结点 $4$ 的子树仅包括结点 $4$ 自己。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vg5uaueo.png \"150\")\n\n每个结点都被赋以非负整数的**权重**。我们将结点 $i$（$0 \\leq i < N$）的权重记为 $W[i]$。\n\n你的任务是写一个程序来回答 $Q$ 个询问，其中每个询问都用一对正整数 $(L, R)$ 来表示。对于询问的回答，应按照如下要求进行计算。\n\n对树中的每个结点，都指派一个整数，称为**系数**。这样的指派结果被描述成一个序列 $C[0], \\ldots, C[N-1]$，这里 $C[i]$（$0 \\leq i < N$）是指派给结点 $i$ 的系数。我们称该序列为一个**系数序列**。注意，系数序列中的元素可以取负值、$0$ 或正值。\n\n对某个询问 $(L, R)$，一个系数序列被称为是**有效的**，如果对于每个结点 $i$（$0 \\leq i < N$）都有如下条件成立：结点 $i$ 的子树中的系数之和不小于 $L$ 且不大于 $R$。\n\n对于一个给定的系数序列 $C[0], \\ldots, C[N-1]$，结点 $i$ 的**代价**为 $|C[i]| \\cdot W[i]$，这里 $|C[i]|$ 表示 $C[i]$ 的绝对值。最后，**总体代价**为所有结点的代价之和。你的任务是，对于每个询问，计算出可以由某个有效系数序列达到的**最小总体代价**。\n\n可以证明，对于任意询问，都至少存在一个有效的系数序列。\n\n### 实现细节\n\n你需要实现如下两个函数：\n\n```\nvoid init(std::vector<int> P, std::vector<int> W)\n```\n\n* $P$，$W$：两个长度为 $N$ 的整数数组，记录了结点的父结点和权重。\n* 对于每个测试样例，在评测程序与你的程序开始交互时，该函数将被恰好调用一次。\n\n```\nlong long query(int L, int R)\n```\n* $L$，$R$：两个整数，描述一次询问。\n* 对于每个测试样例，在 `init` 被调用后，该函数将被调用 $Q$ 次。\n* 该函数应该返回对给定询问的答案。", "inputFormat": "评测程序示例读取如下格式的输入：\n\n```\nN\nP[1]  P[2] ...  P[N-1]\nW[0]  W[1] ...  W[N-2] W[N-1]\nQ\nL[0]  R[0]\nL[1]  R[1]\n...\nL[Q-1]  R[Q-1]\n```\n\n这里的 $L[j]$ 和 $R[j]$（$0 \\leq j < Q$），是对 `query` 的第 $j$ 次调用的输入参数。注意，输入数据中的第二行中**仅包括 $N-1$ 个整数**，因为评测程序示例并不读取 $P[0]$ 的值。", "outputFormat": "评测程序示例按照如下格式打印你的答案：\n\n```\nA[0]\nA[1]\n...\nA[Q-1]\n```\n\n这里的 $A[j]$（$0 \\leq j < Q$），是第 $j$ 次调用 `query` 时返回的值。", "hint": "考虑如下调用：\n\n```\ninit([-1, 0, 0], [1, 1, 1])\n```\n这棵树包含 $3$ 个结点：根结点以及它的 $2$ 个子结点。所有结点的权重均为 $1$。\n\n```\nquery(1, 1)\n```\n\n本次询问有 $L = R = 1$，这意味着每个子树中的系数之和都必须等于 $1$。考虑系数序列 $[-1, 1, 1]$。这棵树以及相应的系数（在阴影矩形中）图示如下。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fg1hjoze.png \"150\")\n\n对每个结点 $i$（$0 \\leq i < 3$），$i$ 的子树中全部结点的系数之和均为 $1$。因此，系数序列是有效的。总体代价的计算如下：\n\n\n| 结点 | 权重 | 系数 |            代价            |\n| :----: | :----: | :---------: | :------------------------: |\n|   $0$    |   $1$    |     $-1$      | $\\mid -1 \\mid \\cdot 1 = 1$ |\n|   $1$    |   $1$    |      $1$      | $\\mid 1 \\mid \\cdot 1 = 1$  |\n|   $2$    |   $1$    |      $1$      | $\\mid 1 \\mid \\cdot 1 = 1$  |\n\n因此总体代价为 $3$。这是唯一的有效系数序列，因此调用应该返回 $3$。\n\n```\nquery(1, 2)\n```\n对于该询问的最小总体代价为 $2$，可以在系数序列为 $[0, 1, 1]$ 时达到。\n\n### 约束条件\n\n* $1 \\leq N \\leq 200\\,000$\n* $1 \\leq Q \\leq 100\\,000$\n* $P[0] = -1$\n* 对所有满足 $1 \\leq i < N$ 的 $i$，都有 $0 \\leq P[i] < i$\n* 对所有满足 $0 \\leq i < N$ 的 $i$，都有 $0 \\leq W[i] \\leq 1\\,000\\,000$\n* 在每次询问中，都有 $1 \\leq L \\leq R \\leq 1\\,000\\,000$\n\n| 子任务 | 分数 | 额外的约束条件                                     |\n| :-----: | :---: | ------------------------------------------------------------ |\n|    1    | $10$  | $Q \\leq 10$；对所有满足 $1 \\leq i < N$ 的 $i$，都有 $W[P[i]] \\leq W[i]$ |\n|    2    | $13$  | $Q \\leq 10$；$N \\leq 2\\,000$                                 |\n|    3    | $18$  | $Q \\leq 10$；$N \\leq 60\\,000$                                |\n|    4    |  $7$  | 对所有满足 $0 \\leq i < N$ 的 $i$，都有 $W[i] = 1$              |\n|    5    | $11$  | 对所有满足 $0 \\leq i < N$ 的 $i$，都有 $W[i] \\leq 1$           |\n|    6    | $22$  | $L = 1$                                                      |\n|    7    | $19$  | 没有额外的约束条件。                                   |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2024] 树上代价", "background": "提交时请不要引用 `tree.h`。\n\n请不要使用 C++14 (GCC 9) 提交。", "description": "有一棵包括 $N$ 个**结点**的**树**，结点从 $0$ 到 $N-1$ 编号。结点 $0$ 是树的**根**。除根以外的每个结点都有唯一的**父结点**。对所有满足 $1 \\leq i < N$ 的 $i$，结点 $i$ 的父结点为 $P[i]$，这里有 $P[i] < i$。我们约定 $P[0] = -1$。\n\n对所有结点 $i$（$0 \\leq i < N$），$i$ 的**子树**是如下结点组成的集合：\n * $i$，以及\n * 所有父结点为 $i$ 的结点，以及\n * 所有父结点的父结点为 $i$ 的结点，以及\n * 所有父结点的父结点的父结点为 $i$ 的结点，以及\n * 以此类推。\n\n下图给出了一个包含 $N = 6$ 个结点的树的例子。每个箭头都从某个结点连向它的父结点（根结点除外，因为它没有父结点）。结点 $2$ 的子树包括结点 $2, 3, 4$ 和 $5$。结点 $0$ 的子树包括树中的全部 $6$ 个结点，而结点 $4$ 的子树仅包括结点 $4$ 自己。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vg5uaueo.png \"150\")\n\n每个结点都被赋以非负整数的**权重**。我们将结点 $i$（$0 \\leq i < N$）的权重记为 $W[i]$。\n\n你的任务是写一个程序来回答 $Q$ 个询问，其中每个询问都用一对正整数 $(L, R)$ 来表示。对于询问的回答，应按照如下要求进行计算。\n\n对树中的每个结点，都指派一个整数，称为**系数**。这样的指派结果被描述成一个序列 $C[0], \\ldots, C[N-1]$，这里 $C[i]$（$0 \\leq i < N$）是指派给结点 $i$ 的系数。我们称该序列为一个**系数序列**。注意，系数序列中的元素可以取负值、$0$ 或正值。\n\n对某个询问 $(L, R)$，一个系数序列被称为是**有效的**，如果对于每个结点 $i$（$0 \\leq i < N$）都有如下条件成立：结点 $i$ 的子树中的系数之和不小于 $L$ 且不大于 $R$。\n\n对于一个给定的系数序列 $C[0], \\ldots, C[N-1]$，结点 $i$ 的**代价**为 $|C[i]| \\cdot W[i]$，这里 $|C[i]|$ 表示 $C[i]$ 的绝对值。最后，**总体代价**为所有结点的代价之和。你的任务是，对于每个询问，计算出可以由某个有效系数序列达到的**最小总体代价**。\n\n可以证明，对于任意询问，都至少存在一个有效的系数序列。\n\n### 实现细节\n\n你需要实现如下两个函数：\n\n```\nvoid init(std::vector<int> P, std::vector<int> W)\n```\n\n* $P$，$W$：两个长度为 $N$ 的整数数组，记录了结点的父结点和权重。\n* 对于每个测试样例，在评测程序与你的程序开始交互时，该函数将被恰好调用一次。\n\n```\nlong long query(int L, int R)\n```\n* $L$，$R$：两个整数，描述一次询问。\n* 对于每个测试样例，在 `init` 被调用后，该函数将被调用 $Q$ 次。\n* 该函数应该返回对给定询问的答案。", "inputFormat": "评测程序示例读取如下格式的输入：\n\n```\nN\nP[1]  P[2] ...  P[N-1]\nW[0]  W[1] ...  W[N-2] W[N-1]\nQ\nL[0]  R[0]\nL[1]  R[1]\n...\nL[Q-1]  R[Q-1]\n```\n\n这里的 $L[j]$ 和 $R[j]$（$0 \\leq j < Q$），是对 `query` 的第 $j$ 次调用的输入参数。注意，输入数据中的第二行中**仅包括 $N-1$ 个整数**，因为评测程序示例并不读取 $P[0]$ 的值。", "outputFormat": "评测程序示例按照如下格式打印你的答案：\n\n```\nA[0]\nA[1]\n...\nA[Q-1]\n```\n\n这里的 $A[j]$（$0 \\leq j < Q$），是第 $j$ 次调用 `query` 时返回的值。", "hint": "考虑如下调用：\n\n```\ninit([-1, 0, 0], [1, 1, 1])\n```\n这棵树包含 $3$ 个结点：根结点以及它的 $2$ 个子结点。所有结点的权重均为 $1$。\n\n```\nquery(1, 1)\n```\n\n本次询问有 $L = R = 1$，这意味着每个子树中的系数之和都必须等于 $1$。考虑系数序列 $[-1, 1, 1]$。这棵树以及相应的系数（在阴影矩形中）图示如下。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fg1hjoze.png \"150\")\n\n对每个结点 $i$（$0 \\leq i < 3$），$i$ 的子树中全部结点的系数之和均为 $1$。因此，系数序列是有效的。总体代价的计算如下：\n\n\n| 结点 | 权重 | 系数 |            代价            |\n| :----: | :----: | :---------: | :------------------------: |\n|   $0$    |   $1$    |     $-1$      | $\\mid -1 \\mid \\cdot 1 = 1$ |\n|   $1$    |   $1$    |      $1$      | $\\mid 1 \\mid \\cdot 1 = 1$  |\n|   $2$    |   $1$    |      $1$      | $\\mid 1 \\mid \\cdot 1 = 1$  |\n\n因此总体代价为 $3$。这是唯一的有效系数序列，因此调用应该返回 $3$。\n\n```\nquery(1, 2)\n```\n对于该询问的最小总体代价为 $2$，可以在系数序列为 $[0, 1, 1]$ 时达到。\n\n### 约束条件\n\n* $1 \\leq N \\leq 200\\,000$\n* $1 \\leq Q \\leq 100\\,000$\n* $P[0] = -1$\n* 对所有满足 $1 \\leq i < N$ 的 $i$，都有 $0 \\leq P[i] < i$\n* 对所有满足 $0 \\leq i < N$ 的 $i$，都有 $0 \\leq W[i] \\leq 1\\,000\\,000$\n* 在每次询问中，都有 $1 \\leq L \\leq R \\leq 1\\,000\\,000$\n\n| 子任务 | 分数 | 额外的约束条件                                     |\n| :-----: | :---: | ------------------------------------------------------------ |\n|    1    | $10$  | $Q \\leq 10$；对所有满足 $1 \\leq i < N$ 的 $i$，都有 $W[P[i]] \\leq W[i]$ |\n|    2    | $13$  | $Q \\leq 10$；$N \\leq 2\\,000$                                 |\n|    3    | $18$  | $Q \\leq 10$；$N \\leq 60\\,000$                                |\n|    4    |  $7$  | 对所有满足 $0 \\leq i < N$ 的 $i$，都有 $W[i] = 1$              |\n|    5    | $11$  | 对所有满足 $0 \\leq i < N$ 的 $i$，都有 $W[i] \\leq 1$           |\n|    6    | $22$  | $L = 1$                                                      |\n|    7    | $19$  | 没有额外的约束条件。                                   |", "locale": "zh-CN"}}}
{"pid": "P11052", "type": "P", "difficulty": 7, "samples": [["6 5\n0 0 1 0 1 2\n2 0 1 0 2\n", "4\n0 1 0 2\n"], ["3 2\n0 0 2\n1 1\n", "0\n\n"], ["3 3\n0 1 0\n1 0 1\n", "1\n-1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "IOI", "交互题"], "title": "[IOI 2024] 象形文字序列", "background": "请在提交时不要引用 `hieroglyphs.h`。\n\n请勿用 C++14 (GCC 9) 提交。", "description": "一个研究团队正在研究象形文字序列之间的相似性。他们将每个象形文字表示成一个非负整数。为了开展研究，他们采用了关于序列的如下概念。\n\n对于一个给定的序列 $A$，某个序列 $S$ 被称为是 $A$ 的**子序列**，当且仅当 $S$ 能够通过移除 $A$ 中的某些（也可能零个）元素而得到。\n\n下表给出了序列 $A = [3, 2, 1, 2]$ 的子序列的一部分例子。\n\n| 子序列  | 由 $A$ 得到子序列的方式                          |\n| ------------ | -------------------------------------------------------- |\n| [3, 2, 1, 2] | 不移除任何元素。                                 |\n| [2, 1, 2]    | [~~3~~, 2, 1, 2]                                      |\n| [3, 2, 2]    | [3, 2, ~~1~~, 2]                                      |\n| [3, 2]       | [3, ~~2~~, ~~1~~, 2] 或者 [3, 2, ~~1~~, ~~2~~] |\n| [3]          | [3, ~~2~~, ~~1~~, ~~2~~]                        |\n| [ ]          | [~~3~~, ~~2~~, ~~1~~, ~~2~~]                 |\n\n另一方面，$[3, 3]$ 或 $[1, 3]$ 不是 $A$ 的子序列。\n\n考虑有两个象形文字序列 $A$ 和 $B$。某个序列 $S$ 被称为是 $A$ 和 $B$ 的**公共子序列**，当且仅当 $S$ 同时是 $A$ 和 $B$ 的子序列。此外，我们说某个序列 $U$ 是 $A$ 和 $B$ 的一个**最全公共子序列**，当且仅当如下两个条件成立：\n* $U$ 是 $A$ 和 $B$ 的一个公共子序列。\n* $A$ 和 $B$ 的任意公共子序列，都是 $U$ 的一个子序列。\n\n可以证明，任意两个序列 $A$ 和 $B$ 都至多有一个最全公共子序列。\n\n研究人员发现了两个象形文字序列 $A$ 和  $B$。序列 $A$ 包含 $N$ 个象形文字，而序列 $B$ 包含 $M$ 个象形文字。请帮助研究人员为序列 $A$ 和 $B$ 找到一个最全公共子序列，或者判定这样的序列并不存在。", "inputFormat": "```\nN  M\nA[0]  A[1]  ...  A[N-1]\nB[0]  B[1]  ...  B[M-1]\n```", "outputFormat": "```\nT\nR[0]  R[1]  ...  R[T-1]\n```\n\n这里 $R$ 是 `ucs` 所返回的数组，而 $T$ 为其长度。", "hint": "## 实现细节\n\n你要实现以下函数。\n\n```\nstd::vector<int> ucs(std::vector<int> A, std::vector<int> B)\n```\n\n* $A$：长度为 $N$ 的数组，给出第一个序列。\n* $B$：长度为 $M$ 的数组，给出第二个序列。\n* 如果 $A$ 和 $B$ 有一个最全公共子序列，该函数应当返回一个包含该序列的数组。否则，该函数应当返回 $[-1]$（一个长度为 $1$ 的数组，其唯一元素为 $-1$）。\n* 对每个测试用例，该函数恰好被调用一次。\n\n## 约束条件\n\n* $1 \\leq N \\leq 100\\,000$\n* $1 \\leq M \\leq 100\\,000$\n* 对所有满足 $0 \\leq i < N$ 的 $i$，都有 $0 \\leq A[i] \\leq 200\\,000$\n* 对所有满足 $0 \\leq j < M$ 的 $j$，都有 $0 \\leq B[j] \\leq 200\\,000$\n\n## 子任务\n\n| 子任务 | 分数 | 额外的约束条件                                       |\n| :-----: | :---: | ------------------------------------------------------------ |\n|    1    |  $3$  | $N = M$；$A$ 和 $B$ 均由 $N$ 个**不同的**整数构成，取自 $0$ 到 $N-1$（包括这两个值） |\n|    2    | $15$  | 对任意整数 $k$，$k$ 在 $A$ 和 $B$ 中的出现次数，加起来至多等于 $3$。 |\n|    3    | $10$  | 对所有满足 $0 \\leq i < N$ 的 $i$，都有 $A[i] \\leq 1$；对所有满足 $0 \\leq j < M$ 的 $j$，都有 $B[j] \\leq 1$ |\n|    4    | $16$  | $A$ 和 $B$ 存在最全公共子序列。  |\n|    5    | $14$  | $N \\leq 3000$；$M \\leq 3000$                                 |\n|    6    | $42$  | 没有额外的约束条件。                                   |\n\n## 例子\n\n### 例 1\n\n考虑以下函数调用。\n\n```\nucs([0, 0, 1, 0, 1, 2], [2, 0, 1, 0, 2])\n```\n\n此时，$A$ 和 $B$ 的公共子序列为：$[\\ ]$，$[0]$，$[1]$，$[2]$，$[0, 0]$，$[0, 1]$，$[0, 2]$，$[1, 0]$，$[1, 2]$，$[0, 0, 2]$，$[0, 1, 0]$，$[0, 1, 2]$，$[1, 0, 2]$ 和 $[0, 1, 0, 2]$。\n\n由于 $[0, 1, 0, 2]$ 是 $A$ 和 $B$ 的一个公共子序列，而 $A$ 和 $B$ 的所有公共子序列又都是 $[0, 1, 0, 2]$ 的子序列，因此函数应该返回 $[0, 1, 0, 2]$。\n\n### 例 2\n\n考虑以下函数调用。\n\n```\nucs([0, 0, 2], [1, 1])\n```\n\n此时，$A$ 和 $B$ 唯一的公共子序列为空序列 $[\\ ]$。因此函数应该返回一个空数组 $[\\ ]$。\n\n### 例 3\n\n考虑以下函数调用。\n\n```\nucs([0, 1, 0], [1, 0, 1])\n```\n\n此时，$A$ 和 $B$ 的公共子序列为 $[\\ ]$，$[0]$，$[1]$，$[0, 1]$ 和 $[1, 0]$，可以看出两者并不存在最全公共子序列。因此，函数应该返回 $[-1]$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2024] 象形文字序列", "background": "请在提交时不要引用 `hieroglyphs.h`。\n\n请勿用 C++14 (GCC 9) 提交。", "description": "一个研究团队正在研究象形文字序列之间的相似性。他们将每个象形文字表示成一个非负整数。为了开展研究，他们采用了关于序列的如下概念。\n\n对于一个给定的序列 $A$，某个序列 $S$ 被称为是 $A$ 的**子序列**，当且仅当 $S$ 能够通过移除 $A$ 中的某些（也可能零个）元素而得到。\n\n下表给出了序列 $A = [3, 2, 1, 2]$ 的子序列的一部分例子。\n\n| 子序列  | 由 $A$ 得到子序列的方式                          |\n| ------------ | -------------------------------------------------------- |\n| [3, 2, 1, 2] | 不移除任何元素。                                 |\n| [2, 1, 2]    | [~~3~~, 2, 1, 2]                                      |\n| [3, 2, 2]    | [3, 2, ~~1~~, 2]                                      |\n| [3, 2]       | [3, ~~2~~, ~~1~~, 2] 或者 [3, 2, ~~1~~, ~~2~~] |\n| [3]          | [3, ~~2~~, ~~1~~, ~~2~~]                        |\n| [ ]          | [~~3~~, ~~2~~, ~~1~~, ~~2~~]                 |\n\n另一方面，$[3, 3]$ 或 $[1, 3]$ 不是 $A$ 的子序列。\n\n考虑有两个象形文字序列 $A$ 和 $B$。某个序列 $S$ 被称为是 $A$ 和 $B$ 的**公共子序列**，当且仅当 $S$ 同时是 $A$ 和 $B$ 的子序列。此外，我们说某个序列 $U$ 是 $A$ 和 $B$ 的一个**最全公共子序列**，当且仅当如下两个条件成立：\n* $U$ 是 $A$ 和 $B$ 的一个公共子序列。\n* $A$ 和 $B$ 的任意公共子序列，都是 $U$ 的一个子序列。\n\n可以证明，任意两个序列 $A$ 和 $B$ 都至多有一个最全公共子序列。\n\n研究人员发现了两个象形文字序列 $A$ 和  $B$。序列 $A$ 包含 $N$ 个象形文字，而序列 $B$ 包含 $M$ 个象形文字。请帮助研究人员为序列 $A$ 和 $B$ 找到一个最全公共子序列，或者判定这样的序列并不存在。", "inputFormat": "```\nN  M\nA[0]  A[1]  ...  A[N-1]\nB[0]  B[1]  ...  B[M-1]\n```", "outputFormat": "```\nT\nR[0]  R[1]  ...  R[T-1]\n```\n\n这里 $R$ 是 `ucs` 所返回的数组，而 $T$ 为其长度。", "hint": "## 实现细节\n\n你要实现以下函数。\n\n```\nstd::vector<int> ucs(std::vector<int> A, std::vector<int> B)\n```\n\n* $A$：长度为 $N$ 的数组，给出第一个序列。\n* $B$：长度为 $M$ 的数组，给出第二个序列。\n* 如果 $A$ 和 $B$ 有一个最全公共子序列，该函数应当返回一个包含该序列的数组。否则，该函数应当返回 $[-1]$（一个长度为 $1$ 的数组，其唯一元素为 $-1$）。\n* 对每个测试用例，该函数恰好被调用一次。\n\n## 约束条件\n\n* $1 \\leq N \\leq 100\\,000$\n* $1 \\leq M \\leq 100\\,000$\n* 对所有满足 $0 \\leq i < N$ 的 $i$，都有 $0 \\leq A[i] \\leq 200\\,000$\n* 对所有满足 $0 \\leq j < M$ 的 $j$，都有 $0 \\leq B[j] \\leq 200\\,000$\n\n## 子任务\n\n| 子任务 | 分数 | 额外的约束条件                                       |\n| :-----: | :---: | ------------------------------------------------------------ |\n|    1    |  $3$  | $N = M$；$A$ 和 $B$ 均由 $N$ 个**不同的**整数构成，取自 $0$ 到 $N-1$（包括这两个值） |\n|    2    | $15$  | 对任意整数 $k$，$k$ 在 $A$ 和 $B$ 中的出现次数，加起来至多等于 $3$。 |\n|    3    | $10$  | 对所有满足 $0 \\leq i < N$ 的 $i$，都有 $A[i] \\leq 1$；对所有满足 $0 \\leq j < M$ 的 $j$，都有 $B[j] \\leq 1$ |\n|    4    | $16$  | $A$ 和 $B$ 存在最全公共子序列。  |\n|    5    | $14$  | $N \\leq 3000$；$M \\leq 3000$                                 |\n|    6    | $42$  | 没有额外的约束条件。                                   |\n\n## 例子\n\n### 例 1\n\n考虑以下函数调用。\n\n```\nucs([0, 0, 1, 0, 1, 2], [2, 0, 1, 0, 2])\n```\n\n此时，$A$ 和 $B$ 的公共子序列为：$[\\ ]$，$[0]$，$[1]$，$[2]$，$[0, 0]$，$[0, 1]$，$[0, 2]$，$[1, 0]$，$[1, 2]$，$[0, 0, 2]$，$[0, 1, 0]$，$[0, 1, 2]$，$[1, 0, 2]$ 和 $[0, 1, 0, 2]$。\n\n由于 $[0, 1, 0, 2]$ 是 $A$ 和 $B$ 的一个公共子序列，而 $A$ 和 $B$ 的所有公共子序列又都是 $[0, 1, 0, 2]$ 的子序列，因此函数应该返回 $[0, 1, 0, 2]$。\n\n### 例 2\n\n考虑以下函数调用。\n\n```\nucs([0, 0, 2], [1, 1])\n```\n\n此时，$A$ 和 $B$ 唯一的公共子序列为空序列 $[\\ ]$。因此函数应该返回一个空数组 $[\\ ]$。\n\n### 例 3\n\n考虑以下函数调用。\n\n```\nucs([0, 1, 0], [1, 0, 1])\n```\n\n此时，$A$ 和 $B$ 的公共子序列为 $[\\ ]$，$[0]$，$[1]$，$[0, 1]$ 和 $[1, 0]$，可以看出两者并不存在最全公共子序列。因此，函数应该返回 $[-1]$。", "locale": "zh-CN"}}}
{"pid": "P11053", "type": "P", "difficulty": 6, "samples": [["4\n1 0 1 0\n1 1 0 1\n2\n0 3 0 3\n2 3 0 2\n", "7\n3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "IOI", "交互题"], "title": "[IOI 2024] 马赛克上色", "background": "提交时请不要引用 `mosaic.h`。\n\n请不要使用 C++14 (GCC 9) 提交。", "description": "Salma 想给墙上的粘土马赛克上色。该马赛克由 $N \\times N$ 片正方形瓷砖组成，共有 $N^2$ 片瓷砖；每片瓷砖的尺寸为 $1 \\times 1$，都还没有上色。马赛克从上到下每行瓷砖的行编号从 $0$ 到 $N-1$，从左到右每列瓷砖的列编号从 $0$ 到 $N-1$。位于第 $i$ 行第 $j$ 列（$0 \\leq i < N$，$0 \\leq j < N$）的瓷砖记为 $(i,j)$。每片瓷砖要么涂成白色（记为 $0$），要么涂成黑色（记为 $1$）。\n\n为了给马赛克上色，Salma 首先选取两个长度为 $N$ 的数组 $X$ 和 $Y$，每个数组都由 $0$ 和 $1$ 组成，并且 $X[0] = Y[0]$。她按照数组 $X$ 对最上面的行（第 $0$ 行）的瓷砖进行上色，使得瓷砖 $(0,j)$ 的颜色为 $X[j]$（$0 \\leq j < N$）。她按照数组 $Y$ 对最左边的列（第 $0$ 列）的瓷砖进行上色，使得瓷砖 $(i,0)$ 的颜色为 $Y[i]$（$0 \\leq i < N$）。\n\n然后她重复以下步骤直至所有瓷砖都上色完成：\n* 她找到任意一片**没有上色**的瓷砖 $(i,j)$，其上方相邻的瓷砖 $(i-1, j)$ 和左边相邻的瓷砖 $(i, j-1)$ 都**已经上色**。\n* 然后，如果这两片相邻的瓷砖都是白色，她会把瓷砖 $(i,j)$ 涂成黑色；否则，涂成白色。\n\n可以证明，瓷砖最终的颜色不依赖于 Salma 的上色顺序。\n\nYasmin 对马赛克瓷砖的颜色非常好奇。她向 Salma 提出 $Q$ 个问题，从 $0$ 到 $Q-1$ 编号。在问题 $k$（$0 \\leq k < Q$）中，Yasmin 通过以下信息指定马赛克中的一个长方形：\n* 最上面的行 $T[k]$ 和最下面的行 $B[k]$（$0 \\leq T[k] \\leq B[k] < N$）；\n* 最左边的列 $L[k]$ 和最右边的列 $R[k]$（$0 \\leq L[k] \\leq R[k] < N$）。\n\n问题的答案是该长方形中黑色瓷砖的数量。具体来说，Salma 应当找出有多少片瓷砖 $(i,j)$ 满足  $T[k] \\leq i \\leq B[k]$，$L[k] \\leq j \\leq R[k]$，且颜色为黑色。\n\n请编写程序回答 Yasmin 的问题。\n\n### 实现细节\n\n你要实现以下函数。\n\n```\nstd::vector<long long> mosaic(\n\tstd::vector<int> X, std::vector<int> Y,\n    std::vector<int> T, std::vector<int> B,\n    std::vector<int> L, std::vector<int> R)\n```\n\n* $X$，$Y$：长度为 $N$ 的数组，分别描述最上方行和最左边列的瓷砖的颜色。\n* $T$，$B$，$L$，$R$：长度为 $Q$ 的数组，分别描述 Yasmin 所提出的问题。\n* 该函数应返回一个长度为 $Q$ 的数组 $C$，使得 $C[k]$ 给出问题 $k$（$0 \\leq k < Q$）的答案。\n* 对每个测试用例，该函数恰好被调用一次。", "inputFormat": "评测程序示例读取如下格式的输入：\n\n```\nN\nX[0]  X[1]  ...  X[N-1]\nY[0]  Y[1]  ...  Y[N-1]\nQ\nT[0]  B[0]  L[0]  R[0]\nT[1]  B[1]  L[1]  R[1]\n...\nT[Q-1]  B[Q-1]  L[Q-1]  R[Q-1]\n```", "outputFormat": "评测程序示例按照如下格式打印你的答案：\n\n```\nC[0]\nC[1]\n...\nC[S-1]\n```\n\n其中 $S$ 是  `mosaic` 所返回的数组 $C$ 的长度。", "hint": "考虑以下函数调用。\n\n```\nmosaic([1, 0, 1, 0], [1, 1, 0, 1], [0, 2], [3, 3], [0, 0], [3, 2])\n```\n\n该例子如下图所示。左边的图展示了马赛克中瓷砖的颜色，中间和右边的图分别展示了 Yasmin 的第一个问题和第二个问题中的长方形。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dhy83fvl.png \"550\")\n\n这两个问题的答案（即阴影长方形中 1 的个数）分别是 7 和 3。因此，函数应该返回 $[7, 3]$。\n\n### 约束条件\n\n* $1 \\leq N \\leq 200\\,000$\n* $1 \\leq Q \\leq 200\\,000$\n* 对所有满足  $0 \\leq i < N$ 的 $i$，都有 $X[i] \\in \\{0, 1\\}$，且 $Y[i] \\in \\{0, 1\\}$\n* $X[0] = Y[0]$\n* 对所有满足 $0 \\leq k < Q$ 的 $k$，都有 $0 \\leq T[k] \\leq B[k] < N$，且 $0 \\leq L[k] \\leq R[k] < N$\n\n| 子任务 | 分数 | 额外的约束条件 |\n| :-----: | :----: | ---------------------- |\n| 1       | $5$    | $N \\leq 2; Q \\leq 10$\n| 2       | $7$    | $N \\leq 200; Q \\leq 200$\n| 3       | $7$    | 对所有满足  $0 \\leq k < Q$ 的 $k$，都有 $T[k] = B[k] = 0$\n| 4       | $10$   | $N \\leq 5000$\n| 5       | $8$    | 对所有满足 $0 \\leq i < N$ 的 $i$，都有 $X[i] = Y[i] = 0$\n| 6       | $22$   | 对所有满足 $0 \\leq k < Q$ 的 $k$，都有 $T[k] = B[k]$，且 $L[k] = R[k]$\n| 7       | $19$   | 对所有满足 $0 \\leq k < Q$ 的 $k$，都有 $T[k] = B[k]$ \n| 8       | $22$   | 没有额外的约束条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2024] 马赛克上色", "background": "提交时请不要引用 `mosaic.h`。\n\n请不要使用 C++14 (GCC 9) 提交。", "description": "Salma 想给墙上的粘土马赛克上色。该马赛克由 $N \\times N$ 片正方形瓷砖组成，共有 $N^2$ 片瓷砖；每片瓷砖的尺寸为 $1 \\times 1$，都还没有上色。马赛克从上到下每行瓷砖的行编号从 $0$ 到 $N-1$，从左到右每列瓷砖的列编号从 $0$ 到 $N-1$。位于第 $i$ 行第 $j$ 列（$0 \\leq i < N$，$0 \\leq j < N$）的瓷砖记为 $(i,j)$。每片瓷砖要么涂成白色（记为 $0$），要么涂成黑色（记为 $1$）。\n\n为了给马赛克上色，Salma 首先选取两个长度为 $N$ 的数组 $X$ 和 $Y$，每个数组都由 $0$ 和 $1$ 组成，并且 $X[0] = Y[0]$。她按照数组 $X$ 对最上面的行（第 $0$ 行）的瓷砖进行上色，使得瓷砖 $(0,j)$ 的颜色为 $X[j]$（$0 \\leq j < N$）。她按照数组 $Y$ 对最左边的列（第 $0$ 列）的瓷砖进行上色，使得瓷砖 $(i,0)$ 的颜色为 $Y[i]$（$0 \\leq i < N$）。\n\n然后她重复以下步骤直至所有瓷砖都上色完成：\n* 她找到任意一片**没有上色**的瓷砖 $(i,j)$，其上方相邻的瓷砖 $(i-1, j)$ 和左边相邻的瓷砖 $(i, j-1)$ 都**已经上色**。\n* 然后，如果这两片相邻的瓷砖都是白色，她会把瓷砖 $(i,j)$ 涂成黑色；否则，涂成白色。\n\n可以证明，瓷砖最终的颜色不依赖于 Salma 的上色顺序。\n\nYasmin 对马赛克瓷砖的颜色非常好奇。她向 Salma 提出 $Q$ 个问题，从 $0$ 到 $Q-1$ 编号。在问题 $k$（$0 \\leq k < Q$）中，Yasmin 通过以下信息指定马赛克中的一个长方形：\n* 最上面的行 $T[k]$ 和最下面的行 $B[k]$（$0 \\leq T[k] \\leq B[k] < N$）；\n* 最左边的列 $L[k]$ 和最右边的列 $R[k]$（$0 \\leq L[k] \\leq R[k] < N$）。\n\n问题的答案是该长方形中黑色瓷砖的数量。具体来说，Salma 应当找出有多少片瓷砖 $(i,j)$ 满足  $T[k] \\leq i \\leq B[k]$，$L[k] \\leq j \\leq R[k]$，且颜色为黑色。\n\n请编写程序回答 Yasmin 的问题。\n\n### 实现细节\n\n你要实现以下函数。\n\n```\nstd::vector<long long> mosaic(\n\tstd::vector<int> X, std::vector<int> Y,\n    std::vector<int> T, std::vector<int> B,\n    std::vector<int> L, std::vector<int> R)\n```\n\n* $X$，$Y$：长度为 $N$ 的数组，分别描述最上方行和最左边列的瓷砖的颜色。\n* $T$，$B$，$L$，$R$：长度为 $Q$ 的数组，分别描述 Yasmin 所提出的问题。\n* 该函数应返回一个长度为 $Q$ 的数组 $C$，使得 $C[k]$ 给出问题 $k$（$0 \\leq k < Q$）的答案。\n* 对每个测试用例，该函数恰好被调用一次。", "inputFormat": "评测程序示例读取如下格式的输入：\n\n```\nN\nX[0]  X[1]  ...  X[N-1]\nY[0]  Y[1]  ...  Y[N-1]\nQ\nT[0]  B[0]  L[0]  R[0]\nT[1]  B[1]  L[1]  R[1]\n...\nT[Q-1]  B[Q-1]  L[Q-1]  R[Q-1]\n```", "outputFormat": "评测程序示例按照如下格式打印你的答案：\n\n```\nC[0]\nC[1]\n...\nC[S-1]\n```\n\n其中 $S$ 是  `mosaic` 所返回的数组 $C$ 的长度。", "hint": "考虑以下函数调用。\n\n```\nmosaic([1, 0, 1, 0], [1, 1, 0, 1], [0, 2], [3, 3], [0, 0], [3, 2])\n```\n\n该例子如下图所示。左边的图展示了马赛克中瓷砖的颜色，中间和右边的图分别展示了 Yasmin 的第一个问题和第二个问题中的长方形。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dhy83fvl.png \"550\")\n\n这两个问题的答案（即阴影长方形中 1 的个数）分别是 7 和 3。因此，函数应该返回 $[7, 3]$。\n\n### 约束条件\n\n* $1 \\leq N \\leq 200\\,000$\n* $1 \\leq Q \\leq 200\\,000$\n* 对所有满足  $0 \\leq i < N$ 的 $i$，都有 $X[i] \\in \\{0, 1\\}$，且 $Y[i] \\in \\{0, 1\\}$\n* $X[0] = Y[0]$\n* 对所有满足 $0 \\leq k < Q$ 的 $k$，都有 $0 \\leq T[k] \\leq B[k] < N$，且 $0 \\leq L[k] \\leq R[k] < N$\n\n| 子任务 | 分数 | 额外的约束条件 |\n| :-----: | :----: | ---------------------- |\n| 1       | $5$    | $N \\leq 2; Q \\leq 10$\n| 2       | $7$    | $N \\leq 200; Q \\leq 200$\n| 3       | $7$    | 对所有满足  $0 \\leq k < Q$ 的 $k$，都有 $T[k] = B[k] = 0$\n| 4       | $10$   | $N \\leq 5000$\n| 5       | $8$    | 对所有满足 $0 \\leq i < N$ 的 $i$，都有 $X[i] = Y[i] = 0$\n| 6       | $22$   | 对所有满足 $0 \\leq k < Q$ 的 $k$，都有 $T[k] = B[k]$，且 $L[k] = R[k]$\n| 7       | $19$   | 对所有满足 $0 \\leq k < Q$ 的 $k$，都有 $T[k] = B[k]$ \n| 8       | $22$   | 没有额外的约束条件。", "locale": "zh-CN"}}}
{"pid": "P11054", "type": "P", "difficulty": 7, "samples": [["4 4\n2 0 0 0\n0 1\n1 2\n0 2\n0 3", "4 3\n2 0 0 0\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "IOI", "交互题", "Special Judge"], "title": "[IOI 2024] 斯芬克斯的谜题", "background": "请在提交时不要引用 `sphinx.h`，并在代码开头加入如下内容：\n\n```cpp\n#include <vector>\nint perform_experiment(std::vector<int> E);\n```\n\n请勿用 C++14 (GCC 9) 提交。", "description": "斯芬克斯为你准备了一个谜题。给定 $N$ 个顶点的图，顶点从 $0$ 到 $N-1$ 编号。图中有 $M$ 条边，从 $0$ 到 $M-1$ 编号。每条边连接两个不同的顶点，且边是双向的。具体来说，对从 $0$ 到 $M-1$ 的每个 $j$，边 $j$ 连接顶点 $X[j]$ 和 $Y[j]$。任意两个顶点之间最多有一条边。若两个顶点被一条边连接，则它们是**相邻的**。\n\n对顶点序列 $v_0, v_1, \\ldots, v_k$（对 $k \\ge 0$），若每两个连续顶点 $v_l$ 和 $v_{l+1}$（对所有满足 $0 \\le l \\lt k$ 的 $l$）是相邻的，则称其为一条**路径**。路径 $v_0, v_1, \\ldots, v_k$ **连接**顶点 $v_0$ 和 $v_k$。在给定的图中，每对顶点被某条路径连接。\n\n现在有 $N + 1$ 种颜色，从 $0$ 到 $N$ 编号。其中，颜色 $N$ 是特殊的，称为**斯芬克斯之色**。一开始每个顶点都有一种颜色，顶点 $i$（$0 \\le i \\lt N$）的颜色是 $C[i]$。多个顶点可以是同一种颜色的，有的颜色可能没有对应的顶点，且不会有顶点的颜色是斯芬克斯之色。也就是说，$0 \\le C[i] \\lt N$（$0 \\le i \\lt N$）。\n\n若一条路径 $v_0, v_1, \\ldots, v_k$（对 $k \\ge 0$）上的所有顶点都是相同颜色的，则称其是**单色**的。也就是说，满足 $C[v_l] = C[v_{l+1}]$（对所有满足 $0 \\le l \\lt k$ 的 $l$）。此外，两个顶点 $p$ 和 $q$（$0 \\le p \\lt N$，$0 \\le q \\lt N$）在同一个**单色分支**中，当且仅当它们被某条单色路径连接。\n\n你知道图中顶点和边的关系，但是你不知道每个顶点的颜色。你希望通过**重新着色实验**来弄清楚顶点的颜色。\n\n在一次重新着色实验中，你可以对任意多的顶点进行重新着色。具体来说，在一次重新着色实验中，你先给出一个长度为 $N$ 的数组 $E$，对每个 $i$（$0 \\le i \\lt N$），$E[i]$ 的值在 $-1$ 和 $N$ 之间（**包括** $-1$ 和 $N$）。重新着色后，每个顶点 $i$ 的颜色变成了 $S[i]$，其中 $S[i]$ 的值：\n* 若 $E[i] = -1$，则是 $C[i]$，也就是重新着色前顶点 $i$ 的颜色；\n* 否则，是 $E[i]$。\n\n注意：你可以在重新着色的过程中使用斯芬克斯之色。\n\n在将每个顶点 $i$ 的颜色设为 $S[i]$（$0 \\le i \\lt N$）之后，斯芬克斯会宣布图中单色分支的数量。新的着色情况仅在本次重新着色实验中有效，因此**当本次实验结束后，所有顶点的颜色会恢复成最初的情况**。\n\n你的任务是至多通过 $2\\,750$ 次重新着色实验来确定图中顶点的颜色。如果正确给出了每对相邻顶点是否具有相同颜色，那么也会获得部分分数。\n\n### 实现细节\n\n你要实现以下函数。\n\n```\nstd::vector<int> find_colours(int N,\n    std::vector<int> X, std::vector<int> Y)\n```\n\n* $N$：图中顶点的数量。\n* $X$，$Y$：两个长度为 $M$ 的数组，描述图中的边。\n* 该函数应该返回一个长度为 $N$ 的数组 $G$，表示图中顶点的颜色。\n* 对每个测试用例，该函数恰好被调用一次。\n\n以上函数可以通过调用下面的函数来进行重新着色实验：\n\n```\nint perform_experiment(std::vector<int> E)\n```\n\n* $E$：长度为 $N$ 的数组，指定顶点重新着色的方式。\n* 该函数返回根据 $E$ 所给出的方式进行重新着色后单色分支的数量。\n* 该函数至多只能调用 $2\\,750$ 次。\n\n评测程序**不是自适应的**。也就是说，顶点的颜色在调用 `find_colours` 之前就已经固定下来了。", "inputFormat": "评测程序示例读取如下格式的输入：\n\n```\nN  M\nC[0]  C[1] ... C[N-1]\nX[0]  Y[0]\nX[1]  Y[1]\n...\nX[M-1]  Y[M-1]\n```", "outputFormat": "评测程序示例按照如下格式打印你的答案：\n\n```\nL  Q\nG[0]  G[1] ... G[L-1]\n```\n\n这里，$L$ 是 `find_colours` 返回的数组 $G$ 的长度，$Q$ 是调用 `perform_experiment` 的次数。", "hint": "考虑以下函数调用。\n\n```\nfind_colours(4, [0, 1, 0, 0], [1, 2, 2, 3])\n```\n\n在这个例子中，假设顶点的（隐藏的）颜色是 $C = [2, 0, 0, 0]$，如下图所示。顶点的颜色同时也用数字标注在顶点右上角的标签里。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ih99ftw2.png \"230\")\n\n假设该函数以下列方式调用 `perform_experiment`。\n\n```\nperform_experiment([-1, -1, -1, -1])\n```\n\n这次调用没有重新着色任何顶点，因此所有顶点都保持它们原来的颜色。\n\n顶点 $1$ 和顶点 $2$ 都是颜色 $0$ 的。因此路径 $1, 2$ 是单色路径，从而顶点 $1$ 和顶点 $2$ 在同一个单色分支中。\n\n顶点 $1$ 和顶点 $3$ 都是颜色 $0$ 的。但是由于不存在连接它们的单色路径，因此它们在不同的单色分支中。\n\n总共有 $3$ 个单色分支，分别是顶点集合 $\\{0\\}$、$\\{1, 2\\}$ 和 $\\{3\\}$。因此，本次函数调用返回 $3$。\n\n再假设该函数以下列方式调用 `perform_experiment`。\n\n```\nperform_experiment([0, -1, -1, -1])\n```\n\n这次调用只把顶点 $0$ 重新着色成颜色 $0$，结果如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n0qub0o1.png \"230\")\n\n此时所有顶点都属于同一个单色分支，因此本次函数调用返回 $1$。由此可以推断顶点 $1$、$2$ 和 $3$ 都是颜色 $0$ 的。\n\n假设该函数还以下列方式调用 `perform_experiment`。\n\n```\nperform_experiment([-1, -1, -1, 2])\n```\n\n这次调用把顶点 $3$ 重新着色成颜色 $2$，结果如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ds6xl13a.png \"230\")\n\n这时有 $2$ 个单色分支，分别是顶点集合 $\\{0, 3\\}$ 和 $\\{1, 2\\}$，因此本次函数调用返回 $2$。由此可以推断顶点 $0$ 是颜色 $2$ 的。\n\n然后函数 `find_colours` 返回数组 $[2, 0, 0, 0]$。由于 $C = [2, 0, 0, 0]$，因此可以获得满分。\n\n此外，也还有多种返回值，例如 $[1, 2, 2, 2]$ 或 $[1, 2, 2, 3]$，可以获得 $50\\%$ 的分数。\n\n### 约束条件\n\n* $2 \\le N \\le 250$\n* $N - 1 \\le M \\le \\frac{N \\cdot (N - 1)}{2}$\n* 对所有满足 $0 \\le j \\lt M$ 的 $j$，都有 $0 \\le X[j] \\lt Y[j] \\lt N$。\n* 对所有满足 $0 \\le j \\lt k \\lt M$ 的 $j$ 和 $k$，都有 $X[j] \\neq X[k]$ 或 $Y[j] \\neq Y[k]$。\n* 每对顶点被某条路径连接。\n* 对所有满足 $0 \\le i \\lt N$ 的 $i$，都有 $0 \\le C[i] \\lt N$。\n\n| 子任务 | 分数  | 额外的约束条件 |\n| :-----: | :----: | ---------------------- |\n| 1       | $3$    | $N = 2$|\n| 2       | $7$    | $N \\le 50$|\n| 3       | $33$   | 给定的图是一条路径：$M = N - 1$，且顶点 $j$ 和 $j+1$ 是相邻的（$0 \\leq j < M$）。 |\n| 4       | $21$   | 给定的图是完全图：$M = \\frac{N \\cdot (N - 1)}{2}$，且任意两个顶点是相邻的。 |\n| 5       | $36$   | 没有额外的约束条件。 |\n\n在每个子任务中，如果你的程序正确给出了每对相邻顶点是否具有相同颜色，那么也会获得部分分数。\n\n更准确地说，如果在所有测试用例中 `find_colours` 返回的数组 $G$ 与数组 $C$ 完全一样（也就是对所有满足 $0 \\le i \\lt N$ 的 $i$，都有 $G[i] = C[i]$），你会获得该子任务的全部分数。否则，如果在某个子任务的所有测试样例中满足下列条件，你会获得该子任务 $50\\%$ 的分数：\n\n* 对所有满足 $0 \\le i \\lt N$ 的 $i$，都有 $0 \\le G[i] \\lt N$；\n* 对所有满足 $0 \\le j \\lt M$ 的 $j$，都有：\n  * $G[X[j]] = G[Y[j]]$ 当且仅当 $C[X[j]] = C[Y[j]]$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2024] 斯芬克斯的谜题", "background": "请在提交时不要引用 `sphinx.h`，并在代码开头加入如下内容：\n\n```cpp\n#include <vector>\nint perform_experiment(std::vector<int> E);\n```\n\n请勿用 C++14 (GCC 9) 提交。", "description": "斯芬克斯为你准备了一个谜题。给定 $N$ 个顶点的图，顶点从 $0$ 到 $N-1$ 编号。图中有 $M$ 条边，从 $0$ 到 $M-1$ 编号。每条边连接两个不同的顶点，且边是双向的。具体来说，对从 $0$ 到 $M-1$ 的每个 $j$，边 $j$ 连接顶点 $X[j]$ 和 $Y[j]$。任意两个顶点之间最多有一条边。若两个顶点被一条边连接，则它们是**相邻的**。\n\n对顶点序列 $v_0, v_1, \\ldots, v_k$（对 $k \\ge 0$），若每两个连续顶点 $v_l$ 和 $v_{l+1}$（对所有满足 $0 \\le l \\lt k$ 的 $l$）是相邻的，则称其为一条**路径**。路径 $v_0, v_1, \\ldots, v_k$ **连接**顶点 $v_0$ 和 $v_k$。在给定的图中，每对顶点被某条路径连接。\n\n现在有 $N + 1$ 种颜色，从 $0$ 到 $N$ 编号。其中，颜色 $N$ 是特殊的，称为**斯芬克斯之色**。一开始每个顶点都有一种颜色，顶点 $i$（$0 \\le i \\lt N$）的颜色是 $C[i]$。多个顶点可以是同一种颜色的，有的颜色可能没有对应的顶点，且不会有顶点的颜色是斯芬克斯之色。也就是说，$0 \\le C[i] \\lt N$（$0 \\le i \\lt N$）。\n\n若一条路径 $v_0, v_1, \\ldots, v_k$（对 $k \\ge 0$）上的所有顶点都是相同颜色的，则称其是**单色**的。也就是说，满足 $C[v_l] = C[v_{l+1}]$（对所有满足 $0 \\le l \\lt k$ 的 $l$）。此外，两个顶点 $p$ 和 $q$（$0 \\le p \\lt N$，$0 \\le q \\lt N$）在同一个**单色分支**中，当且仅当它们被某条单色路径连接。\n\n你知道图中顶点和边的关系，但是你不知道每个顶点的颜色。你希望通过**重新着色实验**来弄清楚顶点的颜色。\n\n在一次重新着色实验中，你可以对任意多的顶点进行重新着色。具体来说，在一次重新着色实验中，你先给出一个长度为 $N$ 的数组 $E$，对每个 $i$（$0 \\le i \\lt N$），$E[i]$ 的值在 $-1$ 和 $N$ 之间（**包括** $-1$ 和 $N$）。重新着色后，每个顶点 $i$ 的颜色变成了 $S[i]$，其中 $S[i]$ 的值：\n* 若 $E[i] = -1$，则是 $C[i]$，也就是重新着色前顶点 $i$ 的颜色；\n* 否则，是 $E[i]$。\n\n注意：你可以在重新着色的过程中使用斯芬克斯之色。\n\n在将每个顶点 $i$ 的颜色设为 $S[i]$（$0 \\le i \\lt N$）之后，斯芬克斯会宣布图中单色分支的数量。新的着色情况仅在本次重新着色实验中有效，因此**当本次实验结束后，所有顶点的颜色会恢复成最初的情况**。\n\n你的任务是至多通过 $2\\,750$ 次重新着色实验来确定图中顶点的颜色。如果正确给出了每对相邻顶点是否具有相同颜色，那么也会获得部分分数。\n\n### 实现细节\n\n你要实现以下函数。\n\n```\nstd::vector<int> find_colours(int N,\n    std::vector<int> X, std::vector<int> Y)\n```\n\n* $N$：图中顶点的数量。\n* $X$，$Y$：两个长度为 $M$ 的数组，描述图中的边。\n* 该函数应该返回一个长度为 $N$ 的数组 $G$，表示图中顶点的颜色。\n* 对每个测试用例，该函数恰好被调用一次。\n\n以上函数可以通过调用下面的函数来进行重新着色实验：\n\n```\nint perform_experiment(std::vector<int> E)\n```\n\n* $E$：长度为 $N$ 的数组，指定顶点重新着色的方式。\n* 该函数返回根据 $E$ 所给出的方式进行重新着色后单色分支的数量。\n* 该函数至多只能调用 $2\\,750$ 次。\n\n评测程序**不是自适应的**。也就是说，顶点的颜色在调用 `find_colours` 之前就已经固定下来了。", "inputFormat": "评测程序示例读取如下格式的输入：\n\n```\nN  M\nC[0]  C[1] ... C[N-1]\nX[0]  Y[0]\nX[1]  Y[1]\n...\nX[M-1]  Y[M-1]\n```", "outputFormat": "评测程序示例按照如下格式打印你的答案：\n\n```\nL  Q\nG[0]  G[1] ... G[L-1]\n```\n\n这里，$L$ 是 `find_colours` 返回的数组 $G$ 的长度，$Q$ 是调用 `perform_experiment` 的次数。", "hint": "考虑以下函数调用。\n\n```\nfind_colours(4, [0, 1, 0, 0], [1, 2, 2, 3])\n```\n\n在这个例子中，假设顶点的（隐藏的）颜色是 $C = [2, 0, 0, 0]$，如下图所示。顶点的颜色同时也用数字标注在顶点右上角的标签里。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ih99ftw2.png \"230\")\n\n假设该函数以下列方式调用 `perform_experiment`。\n\n```\nperform_experiment([-1, -1, -1, -1])\n```\n\n这次调用没有重新着色任何顶点，因此所有顶点都保持它们原来的颜色。\n\n顶点 $1$ 和顶点 $2$ 都是颜色 $0$ 的。因此路径 $1, 2$ 是单色路径，从而顶点 $1$ 和顶点 $2$ 在同一个单色分支中。\n\n顶点 $1$ 和顶点 $3$ 都是颜色 $0$ 的。但是由于不存在连接它们的单色路径，因此它们在不同的单色分支中。\n\n总共有 $3$ 个单色分支，分别是顶点集合 $\\{0\\}$、$\\{1, 2\\}$ 和 $\\{3\\}$。因此，本次函数调用返回 $3$。\n\n再假设该函数以下列方式调用 `perform_experiment`。\n\n```\nperform_experiment([0, -1, -1, -1])\n```\n\n这次调用只把顶点 $0$ 重新着色成颜色 $0$，结果如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n0qub0o1.png \"230\")\n\n此时所有顶点都属于同一个单色分支，因此本次函数调用返回 $1$。由此可以推断顶点 $1$、$2$ 和 $3$ 都是颜色 $0$ 的。\n\n假设该函数还以下列方式调用 `perform_experiment`。\n\n```\nperform_experiment([-1, -1, -1, 2])\n```\n\n这次调用把顶点 $3$ 重新着色成颜色 $2$，结果如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ds6xl13a.png \"230\")\n\n这时有 $2$ 个单色分支，分别是顶点集合 $\\{0, 3\\}$ 和 $\\{1, 2\\}$，因此本次函数调用返回 $2$。由此可以推断顶点 $0$ 是颜色 $2$ 的。\n\n然后函数 `find_colours` 返回数组 $[2, 0, 0, 0]$。由于 $C = [2, 0, 0, 0]$，因此可以获得满分。\n\n此外，也还有多种返回值，例如 $[1, 2, 2, 2]$ 或 $[1, 2, 2, 3]$，可以获得 $50\\%$ 的分数。\n\n### 约束条件\n\n* $2 \\le N \\le 250$\n* $N - 1 \\le M \\le \\frac{N \\cdot (N - 1)}{2}$\n* 对所有满足 $0 \\le j \\lt M$ 的 $j$，都有 $0 \\le X[j] \\lt Y[j] \\lt N$。\n* 对所有满足 $0 \\le j \\lt k \\lt M$ 的 $j$ 和 $k$，都有 $X[j] \\neq X[k]$ 或 $Y[j] \\neq Y[k]$。\n* 每对顶点被某条路径连接。\n* 对所有满足 $0 \\le i \\lt N$ 的 $i$，都有 $0 \\le C[i] \\lt N$。\n\n| 子任务 | 分数  | 额外的约束条件 |\n| :-----: | :----: | ---------------------- |\n| 1       | $3$    | $N = 2$|\n| 2       | $7$    | $N \\le 50$|\n| 3       | $33$   | 给定的图是一条路径：$M = N - 1$，且顶点 $j$ 和 $j+1$ 是相邻的（$0 \\leq j < M$）。 |\n| 4       | $21$   | 给定的图是完全图：$M = \\frac{N \\cdot (N - 1)}{2}$，且任意两个顶点是相邻的。 |\n| 5       | $36$   | 没有额外的约束条件。 |\n\n在每个子任务中，如果你的程序正确给出了每对相邻顶点是否具有相同颜色，那么也会获得部分分数。\n\n更准确地说，如果在所有测试用例中 `find_colours` 返回的数组 $G$ 与数组 $C$ 完全一样（也就是对所有满足 $0 \\le i \\lt N$ 的 $i$，都有 $G[i] = C[i]$），你会获得该子任务的全部分数。否则，如果在某个子任务的所有测试样例中满足下列条件，你会获得该子任务 $50\\%$ 的分数：\n\n* 对所有满足 $0 \\le i \\lt N$ 的 $i$，都有 $0 \\le G[i] \\lt N$；\n* 对所有满足 $0 \\le j \\lt M$ 的 $j$，都有：\n  * $G[X[j]] = G[Y[j]]$ 当且仅当 $C[X[j]] = C[Y[j]]$。", "locale": "zh-CN"}}}
{"pid": "P11055", "type": "P", "difficulty": 4, "samples": [["4 3\n1 2\n3 4\n1 2", "2\n1 4\n2 3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["Special Judge", "O2优化"], "title": "Yet another ZP problem", "background": "", "description": "从左到右排列着 $n$ 个点，编号分别为 $1,2,\\dots,n$。\n\n你要在他们之间连一些边，记边集为 $E=\\{(x,y)\\ |\\ 1\\leq x<y\\leq n\\}$。\n\n我们称边集 $E$ 满足限制 $[l,r]$，当且仅当存在 $(x,y)\\in E$ 使得 $[x\\in[l,r]]+[y\\in[l,r]]=1$。\n\n基础地，我们希望对所有 $1\\leq i\\leq n$ 满足限制 $[i,i]$。\n\n在此基础上，输入还给定了额外的 $m$ 个限制 $[l_i,r_i]$（$1\\leq l_i<r_i\\leq n$ 并且 $[l_i,r_i]\\neq [1,n]$）。\n\n请问 $|E|$ 最小是多少，在此基础上给出一组合法构造。可以证明，合法的 $E$ 总是存在的。\n\n对于形如 $[P]$ 的表达式，当且仅当命题 $P$ 为真时其取值为 $1$，否则取值为 $0$。", "inputFormat": "第一行输入两个整数 $n,m$。\n\n接下来 $m$ 行每行两个正整数 $l_i,r_i$。", "outputFormat": "第一行输出一个数代表 $|E|$。\n\n接下来 $|E|$ 行，每行两个数 $x,y$ 代表一条边，**注意你需要保证 $1\\le x<y\\le n$**。", "hint": "### 样例解释\n\n对于限制 $[1, 1]$，存在边 $(1, 4)$ 使得 $[1 \\in [1, 1]] + [4 \\in [1, 1]] = 1$。\n\n对于限制 $[3, 4]$，存在边 $(1, 4)$ 使得 $[1 \\in [3, 4]] + [4 \\in [3, 4]] = 1$。\n\n对于限制 $[2, 2]$，存在边 $(2, 3)$ 使得 $[2 \\in [2, 2]] + [3 \\in [2, 2]] = 1$。\n\n### 数据范围\n\n对于所有数据，保证 $3\\leq n\\leq 10^4$，$0\\leq m\\leq 10^5$，$1\\le l_i<r_i\\le n$，$[l_i,r_i]\\ne [1,n]$。\n\n| 测试点编号 | 特殊性质 |\n| :----------: | :----------: |\n| $1\\sim 5$ | $n,m\\le 5$ |\n| $6\\sim 7$ | $m=0$ |\n| $8\\sim 11$ | $r_i<l_{i+1}$ |\n| $12\\sim 14$ | $l_i=1$ |\n| $15\\sim 20$ | 无 |\n\n**对于第 $i$ 个测试点，保证 $n$ 的奇偶性与 $i$ 的奇偶性相同，$m$ 的奇偶性与 $\\lfloor\\frac{i}{2}\\rfloor+1$ 的奇偶性相同。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Yet another ZP problem", "background": "", "description": "从左到右排列着 $n$ 个点，编号分别为 $1,2,\\dots,n$。\n\n你要在他们之间连一些边，记边集为 $E=\\{(x,y)\\ |\\ 1\\leq x<y\\leq n\\}$。\n\n我们称边集 $E$ 满足限制 $[l,r]$，当且仅当存在 $(x,y)\\in E$ 使得 $[x\\in[l,r]]+[y\\in[l,r]]=1$。\n\n基础地，我们希望对所有 $1\\leq i\\leq n$ 满足限制 $[i,i]$。\n\n在此基础上，输入还给定了额外的 $m$ 个限制 $[l_i,r_i]$（$1\\leq l_i<r_i\\leq n$ 并且 $[l_i,r_i]\\neq [1,n]$）。\n\n请问 $|E|$ 最小是多少，在此基础上给出一组合法构造。可以证明，合法的 $E$ 总是存在的。\n\n对于形如 $[P]$ 的表达式，当且仅当命题 $P$ 为真时其取值为 $1$，否则取值为 $0$。", "inputFormat": "第一行输入两个整数 $n,m$。\n\n接下来 $m$ 行每行两个正整数 $l_i,r_i$。", "outputFormat": "第一行输出一个数代表 $|E|$。\n\n接下来 $|E|$ 行，每行两个数 $x,y$ 代表一条边，**注意你需要保证 $1\\le x<y\\le n$**。", "hint": "### 样例解释\n\n对于限制 $[1, 1]$，存在边 $(1, 4)$ 使得 $[1 \\in [1, 1]] + [4 \\in [1, 1]] = 1$。\n\n对于限制 $[3, 4]$，存在边 $(1, 4)$ 使得 $[1 \\in [3, 4]] + [4 \\in [3, 4]] = 1$。\n\n对于限制 $[2, 2]$，存在边 $(2, 3)$ 使得 $[2 \\in [2, 2]] + [3 \\in [2, 2]] = 1$。\n\n### 数据范围\n\n对于所有数据，保证 $3\\leq n\\leq 10^4$，$0\\leq m\\leq 10^5$，$1\\le l_i<r_i\\le n$，$[l_i,r_i]\\ne [1,n]$。\n\n| 测试点编号 | 特殊性质 |\n| :----------: | :----------: |\n| $1\\sim 5$ | $n,m\\le 5$ |\n| $6\\sim 7$ | $m=0$ |\n| $8\\sim 11$ | $r_i<l_{i+1}$ |\n| $12\\sim 14$ | $l_i=1$ |\n| $15\\sim 20$ | 无 |\n\n**对于第 $i$ 个测试点，保证 $n$ 的奇偶性与 $i$ 的奇偶性相同，$m$ 的奇偶性与 $\\lfloor\\frac{i}{2}\\rfloor+1$ 的奇偶性相同。**", "locale": "zh-CN"}}}
{"pid": "P11056", "type": "P", "difficulty": 5, "samples": [["5 2\n1 2 3 4 5", "FFBFF"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 65536, 524288, 65536, 524288, 65536, 524288, 65536, 524288, 65536, 524288, 65536, 524288, 65536, 524288, 65536, 524288, 65536, 524288, 65536]}, "tags": ["O2优化"], "title": "Fire and Big", "background": null, "description": "小 F 要和其他人玩游戏，但他不想输，所以来找你帮他研究策略。\n\n有 $m$ 个石子，小 F 和小 B 轮流取石子，小 F 先开始取，不能取的人输。\n\n给定正整数 $n$，每次取石子的个数 $k$（$k$ 是正整数） 必须满足如下两个条件**之一**：\n\n- $k$ 是 $n$ 的倍数。\n- $k$ 是 $<n$ 的完全平方数。\n\n他们要玩 $T$ 局游戏，不过每一局游戏的 $n$ 不变，只有石子个数 $m$ 会变。\n\n对于每一局，假设两人足够聪明，问谁有必胜策略。", "inputFormat": "第一行，两个正整数 $T,n$。\n\n第二行，$T$ 个正整数 $m$，表示每一局游戏的石子个数。", "outputFormat": "输出一行一个长为 $T$ 的字符串，每个字符为 `F` 或者 `B`，分别表示这一局游戏先手必胜与后手必胜。", "hint": "### 样例解释\n\n以下将说明当 $n = 2, m = 3$ 时，后手必胜。对先手第一次取走的石子的数量进行讨论：\n\n- 若先手取走 $1$ 个石子，则后手可以取完剩下 $2$ 个石子；\n- 若先手取走 $2$ 个石子，则后手可以取完剩下 $1$ 个石子。\n\n因此无论如何，后手总会赢得胜利。\n\n### 数据范围\n\n| 测试点编号 | $n$ | $m\\le$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $\\le 5\\times 10^5$ | $1$ |\n| $2\\sim 3$ | $\\le 5$ | $5$ |\n| $4\\sim 6$ | $\\le 10^5$ | $n$ |\n| $7\\sim 8$ | $=2$ | $10^9$ |\n| $9\\sim 11$ | $\\le 5$ | $10^9$ |\n| $12\\sim 14$ | $\\le 10^3$ | $10^9$ |\n| $15\\sim 17$ | $\\le 10^5$ | $10^9$ |\n| $18\\sim 20$ | $\\le 5\\times 10^5$ | $10^9$ |\n\n对于所有数据，保证 $1\\le T,n\\le 5\\times 10^5$，$1\\le m\\le 10^9$。\n\n**对于奇数编号测试点，内存限制为 $512\\ \\text{MB}$；对于偶数编号测试点，内存限制为 $64\\ \\text{MB}$。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Fire and Big", "background": null, "description": "小 F 要和其他人玩游戏，但他不想输，所以来找你帮他研究策略。\n\n有 $m$ 个石子，小 F 和小 B 轮流取石子，小 F 先开始取，不能取的人输。\n\n给定正整数 $n$，每次取石子的个数 $k$（$k$ 是正整数） 必须满足如下两个条件**之一**：\n\n- $k$ 是 $n$ 的倍数。\n- $k$ 是 $<n$ 的完全平方数。\n\n他们要玩 $T$ 局游戏，不过每一局游戏的 $n$ 不变，只有石子个数 $m$ 会变。\n\n对于每一局，假设两人足够聪明，问谁有必胜策略。", "inputFormat": "第一行，两个正整数 $T,n$。\n\n第二行，$T$ 个正整数 $m$，表示每一局游戏的石子个数。", "outputFormat": "输出一行一个长为 $T$ 的字符串，每个字符为 `F` 或者 `B`，分别表示这一局游戏先手必胜与后手必胜。", "hint": "### 样例解释\n\n以下将说明当 $n = 2, m = 3$ 时，后手必胜。对先手第一次取走的石子的数量进行讨论：\n\n- 若先手取走 $1$ 个石子，则后手可以取完剩下 $2$ 个石子；\n- 若先手取走 $2$ 个石子，则后手可以取完剩下 $1$ 个石子。\n\n因此无论如何，后手总会赢得胜利。\n\n### 数据范围\n\n| 测试点编号 | $n$ | $m\\le$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $\\le 5\\times 10^5$ | $1$ |\n| $2\\sim 3$ | $\\le 5$ | $5$ |\n| $4\\sim 6$ | $\\le 10^5$ | $n$ |\n| $7\\sim 8$ | $=2$ | $10^9$ |\n| $9\\sim 11$ | $\\le 5$ | $10^9$ |\n| $12\\sim 14$ | $\\le 10^3$ | $10^9$ |\n| $15\\sim 17$ | $\\le 10^5$ | $10^9$ |\n| $18\\sim 20$ | $\\le 5\\times 10^5$ | $10^9$ |\n\n对于所有数据，保证 $1\\le T,n\\le 5\\times 10^5$，$1\\le m\\le 10^9$。\n\n**对于奇数编号测试点，内存限制为 $512\\ \\text{MB}$；对于偶数编号测试点，内存限制为 $64\\ \\text{MB}$。**", "locale": "zh-CN"}}}
{"pid": "P11057", "type": "P", "difficulty": 6, "samples": [["2 2", "2 3\n3 16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化"], "title": "诈骗题", "background": "这是一道诈骗题。", "description": "定义 $f(n,m)$ 为下列问题的答案。\n\n> 考虑一个 $n\\times m$ 黑白网格图，初始全是白色的。每次操作如下：\n> - 选择一个白格子 $(x,y)$，将其所在行全染黑，这个操作叫 $(x,y,\\text{R})$。\n> - 选择一个白格子 $(x,y)$，将其所在列全染黑，这个操作叫 $(x,y,\\text{C})$。\n> \n> 假设最多能操作 $k$ 次。问：\n> \n> - 对于所有操作 $k$ 次的方案，有多少种本质不同的 **操作集合** 。操作集合是一个大小为 $k$ 的集合，代表操作过的 $k$ 种操作。（注意，顺序不同但操作集合相同的 $2$ 种方案只会被计算 $1$ 次）\n\n称两个操作集合 $A, B$ 本质不同，当且仅当存在某种操作 $opt$，满足 $[opt \\in A] + [opt \\in B] = 1$。\n\n现在给定 $n,m$，请你对于所有 $1\\le i\\le n,\\ 1\\le j\\le m$ 求出 $f(i,j)$ 的取值。\n\n由于答案可能有点大，因此你只需要输出其取模 $998244353$ 的结果。", "inputFormat": "输入一行两个正整数 $n,m$。", "outputFormat": "输出一个 $n$ 行 $m$ 列的矩阵，第 $i$ 行第 $j$ 个数表示 $f(i,j)\\bmod 998244353$。", "hint": "### 样例解释\n\n对于 $f(1, 2)$，此时 $k = 2$，一共有以下 $3$ 个可能的操作集合：\n\n- $\\{(1, 1, \\text R), (1, 2, \\text C)\\}$\n- $\\{(1, 1, \\text C), (1, 2, \\text R)\\}$\n- $\\{(1, 1, \\text C), (1, 2, \\text C)\\}$\n\n注意到对于最后一个集合，有不止一种操作顺序，但是由于它们对应的操作集合相同，因此只被记入答案一次。\n\n### 数据范围\n\n**洛谷代码长度限制为 $\\textbf{50\\ KB}$。**\n\n| 测试点编号 | $n=$ | $m=$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $2$ | $2$ |\n| $2$ | $3$ | $3$ |\n| $3$ | $5$ | $5$ |\n| $4$ | $10$ | $10$ |\n| $5$ | $20$ | $20$ |\n| $6$ | $50$ | $50$ |\n| $7$ | $100$ | $100$ |\n| $8$ | $1$ | $200$ |\n| $9$ | $2$ | $200$ |\n| $10$ | $300$ | $300$ |\n\n对于所有数据，保证 $1\\le n,m\\le 300$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "诈骗题", "background": "这是一道诈骗题。", "description": "定义 $f(n,m)$ 为下列问题的答案。\n\n> 考虑一个 $n\\times m$ 黑白网格图，初始全是白色的。每次操作如下：\n> - 选择一个白格子 $(x,y)$，将其所在行全染黑，这个操作叫 $(x,y,\\text{R})$。\n> - 选择一个白格子 $(x,y)$，将其所在列全染黑，这个操作叫 $(x,y,\\text{C})$。\n> \n> 假设最多能操作 $k$ 次。问：\n> \n> - 对于所有操作 $k$ 次的方案，有多少种本质不同的 **操作集合** 。操作集合是一个大小为 $k$ 的集合，代表操作过的 $k$ 种操作。（注意，顺序不同但操作集合相同的 $2$ 种方案只会被计算 $1$ 次）\n\n称两个操作集合 $A, B$ 本质不同，当且仅当存在某种操作 $opt$，满足 $[opt \\in A] + [opt \\in B] = 1$。\n\n现在给定 $n,m$，请你对于所有 $1\\le i\\le n,\\ 1\\le j\\le m$ 求出 $f(i,j)$ 的取值。\n\n由于答案可能有点大，因此你只需要输出其取模 $998244353$ 的结果。", "inputFormat": "输入一行两个正整数 $n,m$。", "outputFormat": "输出一个 $n$ 行 $m$ 列的矩阵，第 $i$ 行第 $j$ 个数表示 $f(i,j)\\bmod 998244353$。", "hint": "### 样例解释\n\n对于 $f(1, 2)$，此时 $k = 2$，一共有以下 $3$ 个可能的操作集合：\n\n- $\\{(1, 1, \\text R), (1, 2, \\text C)\\}$\n- $\\{(1, 1, \\text C), (1, 2, \\text R)\\}$\n- $\\{(1, 1, \\text C), (1, 2, \\text C)\\}$\n\n注意到对于最后一个集合，有不止一种操作顺序，但是由于它们对应的操作集合相同，因此只被记入答案一次。\n\n### 数据范围\n\n**洛谷代码长度限制为 $\\textbf{50\\ KB}$。**\n\n| 测试点编号 | $n=$ | $m=$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $2$ | $2$ |\n| $2$ | $3$ | $3$ |\n| $3$ | $5$ | $5$ |\n| $4$ | $10$ | $10$ |\n| $5$ | $20$ | $20$ |\n| $6$ | $50$ | $50$ |\n| $7$ | $100$ | $100$ |\n| $8$ | $1$ | $200$ |\n| $9$ | $2$ | $200$ |\n| $10$ | $300$ | $300$ |\n\n对于所有数据，保证 $1\\le n,m\\le 300$。", "locale": "zh-CN"}}}
{"pid": "P11058", "type": "P", "difficulty": 6, "samples": [["3\n1 10\n27 3\n32 2", "1 2\n4 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["提交答案", "Special Judge", "O2优化"], "title": "合并香蕉", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/xi3q8vw1.png)", "description": "有 $n$ 条大香蕉，第 $i$ 条大香蕉可简化为一个正整数二元组 $(a_i,k_i)$，其中 $2\\le k_i\\le 10$。\n\n初始时有 $n$ 堆大香蕉，第 $i$ 堆只包含第 $i$ 条大香蕉。\n\n每次可以选择不同的两堆合并，合并时会损耗香蕉的大小。\n\n具体地，如果第 $i$ 条香蕉**参与了合并**，则其大小 $a_i$ 会变为原来的 $\\frac{1}{k_i}$ 倍。\n\n**参与了合并**：合并前在两堆香蕉中的某一堆中。\n\n你想把大香蕉们合为一堆，由于香蕉越大越好，你需要让操作结束后所有的 $a_i$ 之和**越大越好**。\n\n考虑到求出最优解可能会比较困难，你只需要**尽可能接近标准答案**即可，具体参见**评分标准**。\n\n为了防止你乱输出一个数，你还需要**输出方案**，具体参见**输出格式**。", "inputFormat": "第一行一个正整数代表 $n$。\n\n接下来 $n$ 行，每行两个正整数代表 $a_i,k_i$。", "outputFormat": "输出 $n-1$ 行，每行两个数 $x,y$ 代表合并第 $x$ 堆和第 $y$ 堆。\n\n对于第 $i$ 次合并，我们记新形成的香蕉堆是第 $n+i$ 堆，而原来的两个香蕉堆（第 $x$ 堆、第 $y$ 堆）从此将**被视为不存在** ，所以之后的合并中不允许调用 $x$ 和 $y$，否则你将会爆零。", "hint": "### 样例解释\n\n该样例输出对应的操作结束后满足 $a=(0.01,3,16)$，对应的 $a_i$ 之和为 $19.01$。\n\n另外，如果输出如下，则操作结束后满足 $a=(0.01,9,8)$，对应的 $a_i$ 之和为 $17.01$，可以获得 $4$ 分。\n```\n1 3\n2 4\n```\n### 评分标准\n\n对于每个测试点，我们采用如下方式评分：\n\n- 如果你的输出不合法，得 $0$ 分。\n- 否则设你输出的方案对应的操作结束后的 $a_i$ 之和为 $f$，标准答案输出的方案对应的操作结束后的 $a_i$ 之和为 $ans$，则你的得分 $s=\\lfloor \\max\\{0,10-\\log_{10} \\max\\{1,\\frac{ans-f}{\\epsilon}\\}\\}\\rfloor$ 分，其中 $\\epsilon=10^{-5}$。\n\n### 数据范围\n\n本题共有 $10$ 个测试点，每个测试点 $10$ 分。\n\n| 测试点编号 | $n=$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $3$ | 无 |\n| $2$ | $5$ | 无 |\n| $3$ | $10$ | 无 |\n| $4$ | $20$ | 无 |\n| $5$ | $100$ | 无 |\n| $6$ | $10^3$ | 无 |\n| $7$ | $10^5-3$ | $a_i=1$ 且 $k_i=2$ |\n| $8$ | $10^5-2$ | $a_i=1$ |\n| $9$ | $10^5-1$ | $k_i=2$ |\n| $10$ | $10^5$ | 无 |\n\n对于所有数据，保证 $3\\le n\\le 10^5$，$1\\le a_i\\le 10^5$，$2\\le k_i\\le 10$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "合并香蕉", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/xi3q8vw1.png)", "description": "有 $n$ 条大香蕉，第 $i$ 条大香蕉可简化为一个正整数二元组 $(a_i,k_i)$，其中 $2\\le k_i\\le 10$。\n\n初始时有 $n$ 堆大香蕉，第 $i$ 堆只包含第 $i$ 条大香蕉。\n\n每次可以选择不同的两堆合并，合并时会损耗香蕉的大小。\n\n具体地，如果第 $i$ 条香蕉**参与了合并**，则其大小 $a_i$ 会变为原来的 $\\frac{1}{k_i}$ 倍。\n\n**参与了合并**：合并前在两堆香蕉中的某一堆中。\n\n你想把大香蕉们合为一堆，由于香蕉越大越好，你需要让操作结束后所有的 $a_i$ 之和**越大越好**。\n\n考虑到求出最优解可能会比较困难，你只需要**尽可能接近标准答案**即可，具体参见**评分标准**。\n\n为了防止你乱输出一个数，你还需要**输出方案**，具体参见**输出格式**。", "inputFormat": "第一行一个正整数代表 $n$。\n\n接下来 $n$ 行，每行两个正整数代表 $a_i,k_i$。", "outputFormat": "输出 $n-1$ 行，每行两个数 $x,y$ 代表合并第 $x$ 堆和第 $y$ 堆。\n\n对于第 $i$ 次合并，我们记新形成的香蕉堆是第 $n+i$ 堆，而原来的两个香蕉堆（第 $x$ 堆、第 $y$ 堆）从此将**被视为不存在** ，所以之后的合并中不允许调用 $x$ 和 $y$，否则你将会爆零。", "hint": "### 样例解释\n\n该样例输出对应的操作结束后满足 $a=(0.01,3,16)$，对应的 $a_i$ 之和为 $19.01$。\n\n另外，如果输出如下，则操作结束后满足 $a=(0.01,9,8)$，对应的 $a_i$ 之和为 $17.01$，可以获得 $4$ 分。\n```\n1 3\n2 4\n```\n### 评分标准\n\n对于每个测试点，我们采用如下方式评分：\n\n- 如果你的输出不合法，得 $0$ 分。\n- 否则设你输出的方案对应的操作结束后的 $a_i$ 之和为 $f$，标准答案输出的方案对应的操作结束后的 $a_i$ 之和为 $ans$，则你的得分 $s=\\lfloor \\max\\{0,10-\\log_{10} \\max\\{1,\\frac{ans-f}{\\epsilon}\\}\\}\\rfloor$ 分，其中 $\\epsilon=10^{-5}$。\n\n### 数据范围\n\n本题共有 $10$ 个测试点，每个测试点 $10$ 分。\n\n| 测试点编号 | $n=$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $3$ | 无 |\n| $2$ | $5$ | 无 |\n| $3$ | $10$ | 无 |\n| $4$ | $20$ | 无 |\n| $5$ | $100$ | 无 |\n| $6$ | $10^3$ | 无 |\n| $7$ | $10^5-3$ | $a_i=1$ 且 $k_i=2$ |\n| $8$ | $10^5-2$ | $a_i=1$ |\n| $9$ | $10^5-1$ | $k_i=2$ |\n| $10$ | $10^5$ | 无 |\n\n对于所有数据，保证 $3\\le n\\le 10^5$，$1\\le a_i\\le 10^5$，$2\\le k_i\\le 10$。", "locale": "zh-CN"}}}
{"pid": "P11059", "type": "P", "difficulty": 2, "samples": [["3 8", "107"], ["1 1", "1"], ["5 3", "10002"], ["2 7", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "O2优化", "语言月赛"], "title": "[入门赛 #27] 数字 (Hard Ver.)", "background": "> 如果我说不吻你不罢休\\\n> 谁能逼我将就\\\n> ——李荣浩《不将就》\n\n人生不能将就，是否做出了最好的选择，取决于每个人自己。", "description": "你需要求出一个 $n$ 位数 $x$，满足以下两个条件：\n\n- 1. $x$ 的**各位数字之和**除以 $p$ 的**余数**尽可能小。\n- 2. 在**已经满足 1** 的情况下，$x$ 的值尽可能小。\n\n各位数字之和：一个数的每个位置上的数字加起来的总和。例如，$123$ 的各位数字之和为 $1+2+3=6$", "inputFormat": "输入共一行，两个整数 $n,p$。", "outputFormat": "输出一个整数，表示上述问题的答案。", "hint": "#### 样例解释 #1\n\n三位数包含 $100,101,\\dots,999$。其中 $107$ 的各位数字之和为 $1+0+7=8$，$8$ 除以 $8$ 的余数为 $0$。\n\n#### 数据范围\n\n\n对于 $30\\%$ 的数据，$1\\le n\\le 18$，$1\\le p\\le 200$；\\\n对于 $100\\%$ 的数据，$1\\le n \\le 10^6$，\n$ 1 \\le p \\le 10^9 $；", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[入门赛 #27] 数字 (Hard Ver.)", "background": "> 如果我说不吻你不罢休\\\n> 谁能逼我将就\\\n> ——李荣浩《不将就》\n\n人生不能将就，是否做出了最好的选择，取决于每个人自己。", "description": "你需要求出一个 $n$ 位数 $x$，满足以下两个条件：\n\n- 1. $x$ 的**各位数字之和**除以 $p$ 的**余数**尽可能小。\n- 2. 在**已经满足 1** 的情况下，$x$ 的值尽可能小。\n\n各位数字之和：一个数的每个位置上的数字加起来的总和。例如，$123$ 的各位数字之和为 $1+2+3=6$", "inputFormat": "输入共一行，两个整数 $n,p$。", "outputFormat": "输出一个整数，表示上述问题的答案。", "hint": "#### 样例解释 #1\n\n三位数包含 $100,101,\\dots,999$。其中 $107$ 的各位数字之和为 $1+0+7=8$，$8$ 除以 $8$ 的余数为 $0$。\n\n#### 数据范围\n\n\n对于 $30\\%$ 的数据，$1\\le n\\le 18$，$1\\le p\\le 200$；\\\n对于 $100\\%$ 的数据，$1\\le n \\le 10^6$，\n$ 1 \\le p \\le 10^9 $；", "locale": "zh-CN"}}}
{"pid": "P11060", "type": "P", "difficulty": 1, "samples": [["0\n", "YES\n"], ["3\n", "NO\n"], ["6\n", "NO\n"], ["7\n", "YES\n"], ["15\n", "YES\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "梦熊比赛"], "title": "【MX-X4-T0】「Jason-1」x!", "background": "原题链接：<https://oier.team/problems/X4A>。", "description": "给定一个非负整数 $n$，判断 $n!$ 是否是 $n+1$ 的倍数，如果是则输出 `YES`，否则输出 `NO`。\n\n其中 $n!$ 表示 $n$ 的阶乘，其值为所有小于等于 $n$ 的正整数的乘积。例如 $3! = 1 \\times 2 \\times 3 = 6$。并额外规定 $0! = 1$。", "inputFormat": "仅一行，一个非负整数 $n$。", "outputFormat": "仅一行一个字符串 `YES` 或 `NO`，表示 $n!$ 是否是 $n+1$ 的倍数。", "hint": "**【样例解释 #1】**\n\n$0! = 1$，而 $1$ 是 $1$ 的倍数，故输出 `YES`。\n\n**【样例解释 #2】**\n\n$3! = 1 \\times 2 \\times 3 = 6$，而 $6$ 不是 $4$ 的倍数，故输出 `NO`。\n\n**【样例解释 #3】**\n\n$6! = 1 \\times 2 \\times 3 \\times 4 \\times 5 \\times 6 = 720$，而 $720$ 不是 $7$ 的倍数，故输出 `NO`。\n\n**【样例解释 #4】**\n\n$7! = 1 \\times 2 \\times 3 \\times 4 \\times 5 \\times 6 \\times 7= 5040$，而 $5040$ 是 $8$ 的倍数，故输出 `YES`。\n\n**【样例解释 #5】**\n\n$15! = 1 \\times 2 \\times 3 \\times 4 \\times 5 \\times 6 \\times 7 \\times 8 \\times 9 \\times 10 \\times 11 \\times 12 \\times 13 \\times 14 \\times 15 = 1{,}3076{,}7436{,}8000$，而 $1{,}3076{,}7436{,}8000$ 是 $16$ 的倍数，故输出 `YES`。\n\n**【数据范围】**\n\n本题共有 $20$ 个测试点，第 $i$ 个测试点的 $n$ 为 $i-1$。\n\n对于 $100\\%$ 的数据，$0 \\le n \\le 19$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【MX-X4-T0】「Jason-1」x!", "background": "原题链接：<https://oier.team/problems/X4A>。", "description": "给定一个非负整数 $n$，判断 $n!$ 是否是 $n+1$ 的倍数，如果是则输出 `YES`，否则输出 `NO`。\n\n其中 $n!$ 表示 $n$ 的阶乘，其值为所有小于等于 $n$ 的正整数的乘积。例如 $3! = 1 \\times 2 \\times 3 = 6$。并额外规定 $0! = 1$。", "inputFormat": "仅一行，一个非负整数 $n$。", "outputFormat": "仅一行一个字符串 `YES` 或 `NO`，表示 $n!$ 是否是 $n+1$ 的倍数。", "hint": "**【样例解释 #1】**\n\n$0! = 1$，而 $1$ 是 $1$ 的倍数，故输出 `YES`。\n\n**【样例解释 #2】**\n\n$3! = 1 \\times 2 \\times 3 = 6$，而 $6$ 不是 $4$ 的倍数，故输出 `NO`。\n\n**【样例解释 #3】**\n\n$6! = 1 \\times 2 \\times 3 \\times 4 \\times 5 \\times 6 = 720$，而 $720$ 不是 $7$ 的倍数，故输出 `NO`。\n\n**【样例解释 #4】**\n\n$7! = 1 \\times 2 \\times 3 \\times 4 \\times 5 \\times 6 \\times 7= 5040$，而 $5040$ 是 $8$ 的倍数，故输出 `YES`。\n\n**【样例解释 #5】**\n\n$15! = 1 \\times 2 \\times 3 \\times 4 \\times 5 \\times 6 \\times 7 \\times 8 \\times 9 \\times 10 \\times 11 \\times 12 \\times 13 \\times 14 \\times 15 = 1{,}3076{,}7436{,}8000$，而 $1{,}3076{,}7436{,}8000$ 是 $16$ 的倍数，故输出 `YES`。\n\n**【数据范围】**\n\n本题共有 $20$ 个测试点，第 $i$ 个测试点的 $n$ 为 $i-1$。\n\n对于 $100\\%$ 的数据，$0 \\le n \\le 19$。", "locale": "zh-CN"}}}
{"pid": "P11061", "type": "P", "difficulty": 2, "samples": [["5\n0 0 0 1 2\n", "4\n"], ["7\n0 0 1 0 3 1 3\n", "7\n"], ["7\n0 1 0 0 2 1 0\n", "5\n"], ["4\n0 0 0 0\n", "0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "梦熊比赛"], "title": "【MX-X4-T1】「Jason-1」IO++", "background": "原题链接：<https://oier.team/problems/X4B>。", "description": "有一类只有输入语句与输出语句的程序，我们用一个非负整数序列 $[a_1, a_2, \\ldots]$ 描述它。\n\n该程序将从前往后依次执行，对于第 $i$ 个元素 $a_i$：\n\n- 若 $a_i = 0$，表示一条输入语句：\n\t- 程序将从输入中读取一个整数。\n- 否则，表示一条输出语句：\n\t- 程序将输出第 $a_i$ 次输入读取到的整数。\n\t- 对于给出的程序，保证执行本语句前，程序至少进行了 $a_i$ 次输入。对于你编写的程序，你同样需要保证这一点。\n\n特别地，一个长度为 $0$ 的空程序也是合法的。\n\n给定一个长度为 $n$ 的程序 $[b_1, \\ldots, b_n]$，你需要求出能够实现相同的功能的程序所需的最短长度。\n\n两个程序能实现相同功能，当且仅当对于任意的长度为 $10^{10^{10}}$、值为 $[1, 10^{10^{10}}]$ 之内整数的输入，两个程序执行的输出语句次数相同，且每一次输出的结果均一致。", "inputFormat": "第一行，一个正整数 $n$，表示程序的长度。\n\n第二行，$n$ 个非负整数 $b_1, \\ldots, b_n$，描述了一个程序。", "outputFormat": "仅一行一个整数，表示要实现相同功能的程序所需要的最小长度。", "hint": "**【样例解释 #1】**\n\n长度为 $4$ 的程序 $[0,0,1,2]$，$[0,1,0,2]$ 均可以实现相同的功能。可以证明不存在长度 $\\leq 3$ 且实现了相同功能的程序，所以答案为 $4$。\n\n- 对于输入 $[2, 3, 4, \\ldots]$，程序 $[0, 0, 0, 1, 2]$ 和 $[0, 0, 1, 2]$ 和 $[0, 1, 0, 2]$ 的输出均为 $[2, 3]$，符合题意。\n- 可以验证，对于任意的长度为 $10^{10^{10}}$、值为 $[1, 10^{10^{10}}]$ 之内整数的输入，两个程序执行的输出语句次数相同，且每一次输出的结果均一致。\n\n但是，程序 $[0,1,1]$ 无法实现相同的功能，因为对于输入 $[2, 3, 4, \\ldots]$，该程序的输出为 $[2, 2]$，与原程序的 $[2, 3]$ 不相同，故不能实现相同功能。\n\n程序 $[0,1,2]$ 是不合法的程序，因为运行第 $3$ 条指令（即一条输出语句 $a_i = 2$）时，只执行了 $1$ 次输入语句。\n\n**【样例解释 #2】**\n\n不存在更短的程序能实现相同功能。\n\n**【样例解释 #3】**\n\n长度为 $5$ 的程序 $[0,1,0,2,1]$ 可以实现相同功能。\n\n**【样例解释 #4】**\n\n由于没有输出语句，因此长度为 $0$ 的空程序即可实现相同功能。\n\n**【数据范围】**\n\n对于 $50\\%$ 的数据，保证 $b_1, \\ldots, b_n$ 非严格单调递增，即对于任意 $2 \\le i \\le n$ 均有 $b_{i-1} \\le b_i$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^5$，$0 \\le b_i \\le n$，且保证执行任何输出语句 $b_i$ 前，程序至少进行了 $b_i$ 次输入。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【MX-X4-T1】「Jason-1」IO++", "background": "原题链接：<https://oier.team/problems/X4B>。", "description": "有一类只有输入语句与输出语句的程序，我们用一个非负整数序列 $[a_1, a_2, \\ldots]$ 描述它。\n\n该程序将从前往后依次执行，对于第 $i$ 个元素 $a_i$：\n\n- 若 $a_i = 0$，表示一条输入语句：\n\t- 程序将从输入中读取一个整数。\n- 否则，表示一条输出语句：\n\t- 程序将输出第 $a_i$ 次输入读取到的整数。\n\t- 对于给出的程序，保证执行本语句前，程序至少进行了 $a_i$ 次输入。对于你编写的程序，你同样需要保证这一点。\n\n特别地，一个长度为 $0$ 的空程序也是合法的。\n\n给定一个长度为 $n$ 的程序 $[b_1, \\ldots, b_n]$，你需要求出能够实现相同的功能的程序所需的最短长度。\n\n两个程序能实现相同功能，当且仅当对于任意的长度为 $10^{10^{10}}$、值为 $[1, 10^{10^{10}}]$ 之内整数的输入，两个程序执行的输出语句次数相同，且每一次输出的结果均一致。", "inputFormat": "第一行，一个正整数 $n$，表示程序的长度。\n\n第二行，$n$ 个非负整数 $b_1, \\ldots, b_n$，描述了一个程序。", "outputFormat": "仅一行一个整数，表示要实现相同功能的程序所需要的最小长度。", "hint": "**【样例解释 #1】**\n\n长度为 $4$ 的程序 $[0,0,1,2]$，$[0,1,0,2]$ 均可以实现相同的功能。可以证明不存在长度 $\\leq 3$ 且实现了相同功能的程序，所以答案为 $4$。\n\n- 对于输入 $[2, 3, 4, \\ldots]$，程序 $[0, 0, 0, 1, 2]$ 和 $[0, 0, 1, 2]$ 和 $[0, 1, 0, 2]$ 的输出均为 $[2, 3]$，符合题意。\n- 可以验证，对于任意的长度为 $10^{10^{10}}$、值为 $[1, 10^{10^{10}}]$ 之内整数的输入，两个程序执行的输出语句次数相同，且每一次输出的结果均一致。\n\n但是，程序 $[0,1,1]$ 无法实现相同的功能，因为对于输入 $[2, 3, 4, \\ldots]$，该程序的输出为 $[2, 2]$，与原程序的 $[2, 3]$ 不相同，故不能实现相同功能。\n\n程序 $[0,1,2]$ 是不合法的程序，因为运行第 $3$ 条指令（即一条输出语句 $a_i = 2$）时，只执行了 $1$ 次输入语句。\n\n**【样例解释 #2】**\n\n不存在更短的程序能实现相同功能。\n\n**【样例解释 #3】**\n\n长度为 $5$ 的程序 $[0,1,0,2,1]$ 可以实现相同功能。\n\n**【样例解释 #4】**\n\n由于没有输出语句，因此长度为 $0$ 的空程序即可实现相同功能。\n\n**【数据范围】**\n\n对于 $50\\%$ 的数据，保证 $b_1, \\ldots, b_n$ 非严格单调递增，即对于任意 $2 \\le i \\le n$ 均有 $b_{i-1} \\le b_i$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^5$，$0 \\le b_i \\le n$，且保证执行任何输出语句 $b_i$ 前，程序至少进行了 $b_i$ 次输入。", "locale": "zh-CN"}}}
