{"pid": "P9255", "type": "P", "difficulty": 4, "samples": [["6 3\n3 5 4 8 3 7\n", "TAK\n3 5\n"], ["4 2\n2 3 2 3\n", "NIE\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "Special Judge", "PA（波兰）"], "title": "[PA 2022] Podwyżki", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 2 [Podwyżki](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/pod/)**\n\n对于 Bytecorp 来说，2022 年是艰难的一年。商业决策失误，再加上不景气的市场状况，意味着公司无力为员工涨薪。为了准备应对员工提出的不舒服的问题，人资部门发明了一种方法来证明员工不值得涨薪。\n\n根据一个雇员在连续几天内产生的总收益，可以将一年（在 Byteotia，一年不一定是 365 天）划分为若干区间，这将表明该雇员工作不投入。更确切地说，人资部门希望将收入序列划分为 $k$ 个连续区间，使得序列中的每个元素都恰好属于一个区间。如果**不可能**从每个区间选择一个元素，使所选元素形成严格的升序，那么这种划分是正确的。\n\nBytecorp 的未来在你手上。写一个程序读入某个雇员产生的收益序列和一个整数 $k$，并根据人资部门的要求把序列分成 $k$ 段，或者判断无法分成这样的 $k$ 段。", "inputFormat": "输入的第一行包含两个整数 $n,k$，表示序列长度和要分成的段数。\n\n第二行包含 $n$ 个整数 $a_1,a_2,\\ldots,a_n$，表示收益序列。", "outputFormat": "如果这个序列不能按如上方法分割，输出一行一个字符串 `NIE`。\n\n否则输出两行，第一行一个字符串 `TAK`，第二行输出 $k-1$ 个整数 $v_1,\\ldots,v_{k-1}$，表示正确的划分中除最后一个区间外，每个连续区间的右端点，最后一个区间的右端点一定是 $n$。\n\n如果有多个正确答案，可以输出任意一个。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$2\\le k\\le n\\le 5 \\times 10 ^ 5, 1\\le a_i\\le 10^9, 1\\le v_i<n,v_i<v_{i+1}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2022] Podwyżki", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 2 [Podwyżki](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/pod/)**\n\n对于 Bytecorp 来说，2022 年是艰难的一年。商业决策失误，再加上不景气的市场状况，意味着公司无力为员工涨薪。为了准备应对员工提出的不舒服的问题，人资部门发明了一种方法来证明员工不值得涨薪。\n\n根据一个雇员在连续几天内产生的总收益，可以将一年（在 Byteotia，一年不一定是 365 天）划分为若干区间，这将表明该雇员工作不投入。更确切地说，人资部门希望将收入序列划分为 $k$ 个连续区间，使得序列中的每个元素都恰好属于一个区间。如果**不可能**从每个区间选择一个元素，使所选元素形成严格的升序，那么这种划分是正确的。\n\nBytecorp 的未来在你手上。写一个程序读入某个雇员产生的收益序列和一个整数 $k$，并根据人资部门的要求把序列分成 $k$ 段，或者判断无法分成这样的 $k$ 段。", "inputFormat": "输入的第一行包含两个整数 $n,k$，表示序列长度和要分成的段数。\n\n第二行包含 $n$ 个整数 $a_1,a_2,\\ldots,a_n$，表示收益序列。", "outputFormat": "如果这个序列不能按如上方法分割，输出一行一个字符串 `NIE`。\n\n否则输出两行，第一行一个字符串 `TAK`，第二行输出 $k-1$ 个整数 $v_1,\\ldots,v_{k-1}$，表示正确的划分中除最后一个区间外，每个连续区间的右端点，最后一个区间的右端点一定是 $n$。\n\n如果有多个正确答案，可以输出任意一个。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$2\\le k\\le n\\le 5 \\times 10 ^ 5, 1\\le a_i\\le 10^9, 1\\le v_i<n,v_i<v_{i+1}$。", "locale": "zh-CN"}}}
{"pid": "P9256", "type": "P", "difficulty": 3, "samples": [["3", "2\n3 1\n"], ["10", "6\n7 5 4 3 2 1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "PA（波兰）"], "title": "[PA 2022] Muzyka pop 2", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 2 [Muzyka pop 2](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/muz/)**\n\n你可能还记得，Matthew 喜欢流行音乐。他刚刚编好一首新歌，就差给这首歌谱一个结尾了。\n\nMatthew 想让这个结尾包含一些非空的音符，这些音符用其响度表示，响度是一个正整数。Matthew 可以使用任何响度的音符，但结尾的任务是逐渐淡出整首歌——出于这个原因，结尾的音符响度必须形成一个严格递减的序列。\n\n你可能知道或记得，流行音乐中好的节拍是很重要的。这次 Matthew 发现响度为 $x$ 的音符的节拍值为 $x$ 的二进制形式中 $1$ 的个数。考虑这首歌的剩余部分，他想让这个结尾所有音符的节拍值之和恰好为 $n$。\n\n帮他找到这个正确的音符响度序列。可以证明总存在至少一个满足条件的序列，因此你的任务是输出字典序最小的序列。\n\n注：如果对于两个数字序列 $A$ 和 $B$，在两序列第一个不同的位置，$A$ 序列中这个位置包含的整数比 $B$ 序列的小，我们称数字序列 $A$ 的字典序比 $B$ 的字典序小。如果不存在这个位置，则称更短的那个数字序列字典序更小。例如，序列 $[1, 10000000]$ 的字典序小于序列 $[2,2]$，序列 $[4, 2, 20, 30, 40]$ 的字典序小于 $[4, 2, 100, 1]$，并且序列 $[5,4,3,2]$ 的字典序小于序列 $[5,4,3,2,1]$。", "inputFormat": "输入一行一个整数 $n$，表示要求的序列中音符的节拍值之和。", "outputFormat": "输出第一行包含一个整数 $k$，表示找到的这个序列的长度。\n\n第二行包含 $k$ 个正整数，表示找到的这个序列。这个序列应该是字典序最小且严格递减的，并且这些正整数的二进制表示中 $1$ 的个数和应恰好是 $n$。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$1\\le n\\le 10 ^ 6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2022] Muzyka pop 2", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 2 [Muzyka pop 2](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/muz/)**\n\n你可能还记得，Matthew 喜欢流行音乐。他刚刚编好一首新歌，就差给这首歌谱一个结尾了。\n\nMatthew 想让这个结尾包含一些非空的音符，这些音符用其响度表示，响度是一个正整数。Matthew 可以使用任何响度的音符，但结尾的任务是逐渐淡出整首歌——出于这个原因，结尾的音符响度必须形成一个严格递减的序列。\n\n你可能知道或记得，流行音乐中好的节拍是很重要的。这次 Matthew 发现响度为 $x$ 的音符的节拍值为 $x$ 的二进制形式中 $1$ 的个数。考虑这首歌的剩余部分，他想让这个结尾所有音符的节拍值之和恰好为 $n$。\n\n帮他找到这个正确的音符响度序列。可以证明总存在至少一个满足条件的序列，因此你的任务是输出字典序最小的序列。\n\n注：如果对于两个数字序列 $A$ 和 $B$，在两序列第一个不同的位置，$A$ 序列中这个位置包含的整数比 $B$ 序列的小，我们称数字序列 $A$ 的字典序比 $B$ 的字典序小。如果不存在这个位置，则称更短的那个数字序列字典序更小。例如，序列 $[1, 10000000]$ 的字典序小于序列 $[2,2]$，序列 $[4, 2, 20, 30, 40]$ 的字典序小于 $[4, 2, 100, 1]$，并且序列 $[5,4,3,2]$ 的字典序小于序列 $[5,4,3,2,1]$。", "inputFormat": "输入一行一个整数 $n$，表示要求的序列中音符的节拍值之和。", "outputFormat": "输出第一行包含一个整数 $k$，表示找到的这个序列的长度。\n\n第二行包含 $k$ 个正整数，表示找到的这个序列。这个序列应该是字典序最小且严格递减的，并且这些正整数的二进制表示中 $1$ 的个数和应恰好是 $n$。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$1\\le n\\le 10 ^ 6$。", "locale": "zh-CN"}}}
{"pid": "P9257", "type": "P", "difficulty": 7, "samples": [["4\n3 2 7\n1 2\n2 3\n3 3 7\n1 2\n2 3\n1 3\n5 3 1\n1 5\n2 4\n1 5\n5 2 2\n2 4\n1 5\n", "1 1\n2\n2 3\n1 2 3\n-1\n2 4\n1 2 4 5\n"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "PA（波兰）"], "title": "[PA 2022] Mędrcy", "background": "", "description": "### 警告：滥用本题卡评测者将被封号。\n\n**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 3 [Mędrcy](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/med/)**\n\n几个世纪以来，神奇的 Bitoland 一直是 $n$ 个贤者和 $m$ 条咒语的家园。根据古老的魔法法则，每条咒语恰好被 $n-2$ 个贤者知道。所有的贤者都知道每条咒语都被他们中的一些确定的人所知，但他们不知道到底有多少条咒语存在。每个贤者，对于他所知道的每一条咒语，都清楚地知道其他哪些贤者知道它。然而，贤者不知道存在多少他不知道的咒语。特别的，一个贤者可能不知道任何咒语——在这种情况下，他不知道是否存在咒语（但他仍然知道，如果存在咒语，则正好有 $n-2$ 个贤者会知道它们）。\n\n贤者每天中午都会在 Stumegabyte 森林里聚会，但他们在那里不会互相交流，他们只是各自问候对方并进行冥想，晚上他们都回到自己的小屋。贤者除了在见面时看到对方之外，并没有其他任何方式的交流。他们这样做是因为他们害怕约束他们的古老传统，其中规定，如果一个贤者发现有他不知道的咒语，他必须在当天午夜神不知鬼不觉地离开这里，并且永远不能回到 Bitoland。\n\n有一天，一个流浪者来到了 Bitoland。在观察了几天这些贤者之后，他决定去见他们，在那里他不明智地对所有贤者宣布：「我已经注意到，你们中至少有一个贤者知道至少一条咒语！」\n\n流浪者将在 Bitoland 再停留 $k$ 天（最多一个月），每天观察聚会情况，但不会再多说什么。在这段时间里，会不会有一天，一些贤者不会在聚会上出现？\n\n我们假设贤者的推断是完美的，也就是说，如果他们中的任何一个人能够从流浪者宣布的内容和他们所掌握的关于咒语的信息中推断出什么，那么现实情况一定是这样的，并且他们会这么做。", "inputFormat": "第一行一个正整数 $t$，表示测试点个数。\n\n对于每个测试点，第一行包含三个整数 $n,m,k$，分别表示贤者人数，咒语个数和流浪者会观察会议的天数。贤者从 $1$ 到 $n$ 编号。\n\n接下来 $m$ 行，每行两个整数 $a_i,b_i\\ $，表示除了贤者 $a_i$ 和 $b_i$ 之外其他所有贤者都知道这条咒语。\n\n", "outputFormat": "对于每组数据，如果接下来 $k$ 天的每一天，所有贤者都会来参加聚会，则输出一行 $-1$。否则输出两行。第一行包含两个整数 $d$ 和 $c$，其中 $d$ 表示有贤者没来聚会的最早的一次，$c$ 表示这一次没来聚会的贤者个数。第二行包含 $c$ 个整数，表示没来聚会的贤者编号，按从小到大的顺序输出。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$3\\le n,1\\le m,1\\le k\\le 30, 1\\le a_i<b_i\\le n$,\n\n一组数据中所有测试点的 $n$ 之和不超过 $10 ^ 3$，所有 $m$ 之和不超过 $3 \\times 10 ^ 3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2022] Mędrcy", "background": "", "description": "### 警告：滥用本题卡评测者将被封号。\n\n**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 3 [Mędrcy](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/med/)**\n\n几个世纪以来，神奇的 Bitoland 一直是 $n$ 个贤者和 $m$ 条咒语的家园。根据古老的魔法法则，每条咒语恰好被 $n-2$ 个贤者知道。所有的贤者都知道每条咒语都被他们中的一些确定的人所知，但他们不知道到底有多少条咒语存在。每个贤者，对于他所知道的每一条咒语，都清楚地知道其他哪些贤者知道它。然而，贤者不知道存在多少他不知道的咒语。特别的，一个贤者可能不知道任何咒语——在这种情况下，他不知道是否存在咒语（但他仍然知道，如果存在咒语，则正好有 $n-2$ 个贤者会知道它们）。\n\n贤者每天中午都会在 Stumegabyte 森林里聚会，但他们在那里不会互相交流，他们只是各自问候对方并进行冥想，晚上他们都回到自己的小屋。贤者除了在见面时看到对方之外，并没有其他任何方式的交流。他们这样做是因为他们害怕约束他们的古老传统，其中规定，如果一个贤者发现有他不知道的咒语，他必须在当天午夜神不知鬼不觉地离开这里，并且永远不能回到 Bitoland。\n\n有一天，一个流浪者来到了 Bitoland。在观察了几天这些贤者之后，他决定去见他们，在那里他不明智地对所有贤者宣布：「我已经注意到，你们中至少有一个贤者知道至少一条咒语！」\n\n流浪者将在 Bitoland 再停留 $k$ 天（最多一个月），每天观察聚会情况，但不会再多说什么。在这段时间里，会不会有一天，一些贤者不会在聚会上出现？\n\n我们假设贤者的推断是完美的，也就是说，如果他们中的任何一个人能够从流浪者宣布的内容和他们所掌握的关于咒语的信息中推断出什么，那么现实情况一定是这样的，并且他们会这么做。", "inputFormat": "第一行一个正整数 $t$，表示测试点个数。\n\n对于每个测试点，第一行包含三个整数 $n,m,k$，分别表示贤者人数，咒语个数和流浪者会观察会议的天数。贤者从 $1$ 到 $n$ 编号。\n\n接下来 $m$ 行，每行两个整数 $a_i,b_i\\ $，表示除了贤者 $a_i$ 和 $b_i$ 之外其他所有贤者都知道这条咒语。\n\n", "outputFormat": "对于每组数据，如果接下来 $k$ 天的每一天，所有贤者都会来参加聚会，则输出一行 $-1$。否则输出两行。第一行包含两个整数 $d$ 和 $c$，其中 $d$ 表示有贤者没来聚会的最早的一次，$c$ 表示这一次没来聚会的贤者个数。第二行包含 $c$ 个整数，表示没来聚会的贤者编号，按从小到大的顺序输出。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$3\\le n,1\\le m,1\\le k\\le 30, 1\\le a_i<b_i\\le n$,\n\n一组数据中所有测试点的 $n$ 之和不超过 $10 ^ 3$，所有 $m$ 之和不超过 $3 \\times 10 ^ 3$。", "locale": "zh-CN"}}}
{"pid": "P9258", "type": "P", "difficulty": 6, "samples": [["4\nLLPLPP\nPPLP\nLLP\nP\n", "29 9 8 5\n8 2 2 1\n11 4 3 2\n4 1 1 0\n"]], "limits": {"time": [9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "PA（波兰）"], "title": "[PA 2022] Drybling Bajtessiego", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 3 [Drybling Bajtessiego](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/baj/)**\n\nBytessi 因是世界足坛最好的锋线（和球员）而广为人知。为了即将到来的世界杯，他编制了一份 $n$ 种运球方式的清单，其中每次运球可以用一串字母 `L` 和 `P` 来描述，表示他用左脚和右脚触球的顺序。\n\n如果一个球员用左脚和右脚触球次数相等，我们就称这种运球方式是**平衡的**。此外，如果对于给定的这种运球方式，如果任意一个初始部分（前缀），满足左脚触球次数不少于右脚触球次数，就称这种运球方式是**左利脚的**。由于 Bytessi 是左利脚，他认为如果一种运球方式即平衡又左利脚，那么这种运球方式是**极佳的**。\n\n世界杯是一个特殊的比赛，世界上最好的球员都会来参赛。出于这个原因，Bytessi 需要准备更多的运球方式。他决定使用一种简单的方式把运球方式增加到 $n^2$ 种——对于初始列表中每一对运球方式（可以相同），新的运球方式用这两种运球方式直接相连来描述。换句话说，他会先使用第一种运球方式运球，然后接着用第二种运球方式运球。\n\n在激烈的比赛中，很容易忘记一些本应进行的触球，所以 Bytessi 最后的运球方式将是他最初想的运球方式的一个非空的子序列。换句话说，最后的运球方式将通过删除他想进行的运球方式中的一些（也许没有，但不是全部）字母来得到。其余字母的顺序必须保持不变。\n\n最终采用的运球方式将是极佳的，如果这样的话 Bytessi 会非常高兴。他现在想知道，对于新清单中的每一种运球方式，他可以意外地进行多少种可能的极佳运球方式。由于这个数字可能非常大，Bytessi 只需要知道将这个数字除以 $10^9+7$ 的余数。请帮 Bytessi 解决这个问题。\n\n注意：Bytessi 感兴趣的是其原始运球方式的子序列可以得到多少种不同的极佳运球，而不是从原始运球的描述中划掉字母而得到极佳运球的方法的数量。", "inputFormat": "第一行一个整数 $n$，表示 Bytessi 准备的运球方式种数。\n\n接下来 $n$ 行描述 Bytessi 的运球方式。第 $i$ 行包含一个由 `L` 和 `P` 组成的非空串，描述第 $i$ 种运球方式。", "outputFormat": "输出 $n$ 行，每行 $n$ 个整数。第 $i$ 行第 $j$ 个整数表示如果把第 $i$ 种和第 $j$ 种运球方式相连，新的运球方式中有多少子序列是极佳的，结果对 $10^9+7$ 取模。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$1\\le n\\le 600$，\n\n每种运球方式的长度不超过 $600$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2022] Drybling Bajtessiego", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 3 [Drybling Bajtessiego](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/baj/)**\n\nBytessi 因是世界足坛最好的锋线（和球员）而广为人知。为了即将到来的世界杯，他编制了一份 $n$ 种运球方式的清单，其中每次运球可以用一串字母 `L` 和 `P` 来描述，表示他用左脚和右脚触球的顺序。\n\n如果一个球员用左脚和右脚触球次数相等，我们就称这种运球方式是**平衡的**。此外，如果对于给定的这种运球方式，如果任意一个初始部分（前缀），满足左脚触球次数不少于右脚触球次数，就称这种运球方式是**左利脚的**。由于 Bytessi 是左利脚，他认为如果一种运球方式即平衡又左利脚，那么这种运球方式是**极佳的**。\n\n世界杯是一个特殊的比赛，世界上最好的球员都会来参赛。出于这个原因，Bytessi 需要准备更多的运球方式。他决定使用一种简单的方式把运球方式增加到 $n^2$ 种——对于初始列表中每一对运球方式（可以相同），新的运球方式用这两种运球方式直接相连来描述。换句话说，他会先使用第一种运球方式运球，然后接着用第二种运球方式运球。\n\n在激烈的比赛中，很容易忘记一些本应进行的触球，所以 Bytessi 最后的运球方式将是他最初想的运球方式的一个非空的子序列。换句话说，最后的运球方式将通过删除他想进行的运球方式中的一些（也许没有，但不是全部）字母来得到。其余字母的顺序必须保持不变。\n\n最终采用的运球方式将是极佳的，如果这样的话 Bytessi 会非常高兴。他现在想知道，对于新清单中的每一种运球方式，他可以意外地进行多少种可能的极佳运球方式。由于这个数字可能非常大，Bytessi 只需要知道将这个数字除以 $10^9+7$ 的余数。请帮 Bytessi 解决这个问题。\n\n注意：Bytessi 感兴趣的是其原始运球方式的子序列可以得到多少种不同的极佳运球，而不是从原始运球的描述中划掉字母而得到极佳运球的方法的数量。", "inputFormat": "第一行一个整数 $n$，表示 Bytessi 准备的运球方式种数。\n\n接下来 $n$ 行描述 Bytessi 的运球方式。第 $i$ 行包含一个由 `L` 和 `P` 组成的非空串，描述第 $i$ 种运球方式。", "outputFormat": "输出 $n$ 行，每行 $n$ 个整数。第 $i$ 行第 $j$ 个整数表示如果把第 $i$ 种和第 $j$ 种运球方式相连，新的运球方式中有多少子序列是极佳的，结果对 $10^9+7$ 取模。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$1\\le n\\le 600$，\n\n每种运球方式的长度不超过 $600$。", "locale": "zh-CN"}}}
{"pid": "P9259", "type": "P", "difficulty": 4, "samples": [["5\n1670\n2011\n1560\n1232\n1447\n", "1\n5\n2 1 3 4 5\n"], ["6\n1556\n1449\n1863\n2014\n1333\n1220\n", "2\n5\n5 6 1 4 3\n4\n1 2 3 4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "Special Judge", "PA（波兰）"], "title": "[PA 2022] Fotografia", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 3 [Fotografia](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/fot/)**\n\n字节科技学校（*Bajtockiej Szkoły Technicznej*, BST）的毕业生们聚集在学校前面的广场上拍摄纪念照。他们排成一排，其位置从左到右编号为 $1$ 至 $n$，其中 $n$ 是今年毕业生的人数。\n\n摄影师决定重新安排这些人的位置，让他们按身高升序排列。最矮的人在最左边，最高的人在最右边。幸运的是，今年的毕业生中没有任意两人身高相同。\n\n为了避免混乱，安排位置将按一定方式进行。在一次操作中，摄影师将喊出一串位置编号。在这些位置上的人将按所喊到的顺序出列并走到广场中间。然后，摄影师将重复同样的数字列表。广场中间的人将他们出列顺序的**逆序**，依次回到摄影师所喊出的位置。\n\n我们希望用尽可能少的操作将所有毕业生按身高的升序排列。你的工作是规划重新安排的方案，并告诉摄影师在第几次操作让哪些毕业生出列。", "inputFormat": "第一行一个整数 $n$，表示毕业生人数。\n\n接下来 $n$ 行是一个整数序列 $h_1,h_2,\\ldots,h_n$，每行一个整数，表示站成一排的人的身高。所有身高两两不同。", "outputFormat": "输出第一行包含一个整数 $r$，表示把所有人按身高升序排列所用的最少操作次数。\n\n接下来 $2r$ 行包含对这些操作的描述。描述第一行包含一个整数 $p_i\\ ()$，表示这一轮出列的人数，第二行 $p_i$ 个整数，表示按输出顺序喊出人的位置编号。在一次操作中喊出的人不能重复。\n\n如果有多种操作次数最少的方案，输出任意一种即可。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$1\\le n\\le 3 \\times 10 ^ 3, 1\\le h_i\\le 3 \\times 10 ^ 3, 1\\le p_i\\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2022] Fotografia", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 3 [Fotografia](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/fot/)**\n\n字节科技学校（*Bajtockiej Szkoły Technicznej*, BST）的毕业生们聚集在学校前面的广场上拍摄纪念照。他们排成一排，其位置从左到右编号为 $1$ 至 $n$，其中 $n$ 是今年毕业生的人数。\n\n摄影师决定重新安排这些人的位置，让他们按身高升序排列。最矮的人在最左边，最高的人在最右边。幸运的是，今年的毕业生中没有任意两人身高相同。\n\n为了避免混乱，安排位置将按一定方式进行。在一次操作中，摄影师将喊出一串位置编号。在这些位置上的人将按所喊到的顺序出列并走到广场中间。然后，摄影师将重复同样的数字列表。广场中间的人将他们出列顺序的**逆序**，依次回到摄影师所喊出的位置。\n\n我们希望用尽可能少的操作将所有毕业生按身高的升序排列。你的工作是规划重新安排的方案，并告诉摄影师在第几次操作让哪些毕业生出列。", "inputFormat": "第一行一个整数 $n$，表示毕业生人数。\n\n接下来 $n$ 行是一个整数序列 $h_1,h_2,\\ldots,h_n$，每行一个整数，表示站成一排的人的身高。所有身高两两不同。", "outputFormat": "输出第一行包含一个整数 $r$，表示把所有人按身高升序排列所用的最少操作次数。\n\n接下来 $2r$ 行包含对这些操作的描述。描述第一行包含一个整数 $p_i\\ ()$，表示这一轮出列的人数，第二行 $p_i$ 个整数，表示按输出顺序喊出人的位置编号。在一次操作中喊出的人不能重复。\n\n如果有多种操作次数最少的方案，输出任意一种即可。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$1\\le n\\le 3 \\times 10 ^ 3, 1\\le h_i\\le 3 \\times 10 ^ 3, 1\\le p_i\\le n$。", "locale": "zh-CN"}}}
{"pid": "P9260", "type": "P", "difficulty": 7, "samples": [["5\n8 1 0 4 6\n2 4 2\n3 1 9\n2 5 5\n2 1 2\n", "4 1 1 4 2\n"]], "limits": {"time": [9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000, 9000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["点分治", "2022", "拓扑排序", "强连通分量", "Tarjan", "分块", "线段树合并", "PA（波兰）", "bitset"], "title": "[PA 2022] Miny", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 4 [Miny](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/min/)**\n\n给定一棵树（无向无环图），树上每条边有一个确定的长度。每个点上都有一颗地雷，每个地雷有一个确定的爆炸半径。如果一个地雷爆炸了，所有距离这颗地雷不超过其爆炸半径的地雷都会爆炸。我们定义两个点之间的距离是这两个点之间简单路径上边的长度和。对于每颗地雷，如果手动引爆它，确定有多少地雷会爆炸。注意对于每颗地雷，我们认为手动引爆它与手动引爆其他地雷互相独立。", "inputFormat": "第一行包含一个整数 $n$，表示树的节点数（也是地雷个数）。树节点编号是从 $1$ 到 $n$ 的整数。\n\n第二行 $n$ 个整数 $r_1,r_2,\\ldots,r_n$，第 $i$ 个整数为位于节点 $i$ 的地雷的爆炸半径。\n\n接下来 $n-1$ 行，每行三个整数 $a_i,b_i,c_i$，表示一条长 $c_i$ 的边连接节点 $a_i$ 和 $b_i$。\n\n保证输入可以正确表示一棵树。", "outputFormat": "对于 $100\\%$ 的数据，满足：\n\n输出一行 $n$ 个整数，第 $i$ 个整数表示如果我们手动引爆在节点 $i$ 上的地雷，有多少地雷会爆炸。", "hint": "$1\\le n\\le 10 ^ 5, 0\\le r_i\\le 10^{18}, 1\\le a_i,b_i\\le n,1\\le c_i\\le 10^{12}$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2022] Miny", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 4 [Miny](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/min/)**\n\n给定一棵树（无向无环图），树上每条边有一个确定的长度。每个点上都有一颗地雷，每个地雷有一个确定的爆炸半径。如果一个地雷爆炸了，所有距离这颗地雷不超过其爆炸半径的地雷都会爆炸。我们定义两个点之间的距离是这两个点之间简单路径上边的长度和。对于每颗地雷，如果手动引爆它，确定有多少地雷会爆炸。注意对于每颗地雷，我们认为手动引爆它与手动引爆其他地雷互相独立。", "inputFormat": "第一行包含一个整数 $n$，表示树的节点数（也是地雷个数）。树节点编号是从 $1$ 到 $n$ 的整数。\n\n第二行 $n$ 个整数 $r_1,r_2,\\ldots,r_n$，第 $i$ 个整数为位于节点 $i$ 的地雷的爆炸半径。\n\n接下来 $n-1$ 行，每行三个整数 $a_i,b_i,c_i$，表示一条长 $c_i$ 的边连接节点 $a_i$ 和 $b_i$。\n\n保证输入可以正确表示一棵树。", "outputFormat": "对于 $100\\%$ 的数据，满足：\n\n输出一行 $n$ 个整数，第 $i$ 个整数表示如果我们手动引爆在节点 $i$ 上的地雷，有多少地雷会爆炸。", "hint": "$1\\le n\\le 10 ^ 5, 0\\le r_i\\le 10^{18}, 1\\le a_i,b_i\\le n,1\\le c_i\\le 10^{12}$", "locale": "zh-CN"}}}
{"pid": "P9261", "type": "P", "difficulty": 6, "samples": [["3 2\n1 5 3\n4 2 6\n", "12 9\n"], ["5 3\n1 3 5 7 9\n2 6 4 8 10\n", "40 14 1\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "PA（波兰）"], "title": "[PA 2022] Płótno", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 4 [Płótno](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/plo/)**\n\n由于圣诞节，Bytie 从父母那里得到了一块大画布，画布被分成 $2n$ 个方格，排列成两行 $n$ 列的矩形。为了方便在上面画画，这块画布被包在在一个很低很宽的圆柱体的侧面上，这样，画布的第一列就与最后一列相邻。如果画布上的两个方格有一条公共边，则认为它们是相邻的。即它们要么在同一列，要么在同一行的相邻列。\n\n数学上，我们可以用一个有序数对 $(y,x)$ 表示画布上的每个方格，其中 $1\\le y\\le 2,1\\le x\\le n$。两个方格 $(y_1,x_1)$ 和 $(y_2,x_2)$ 相邻，如果满足：\n\n- 它们在同一行，即 $y_1=y_2$，并且列相邻，即 $x_1+1\\equiv x_2 \\pmod n$ 或 $x_2+1\\equiv x_1\\pmod n$，或者\n- 它们在同一列，即 $x_1=x_2$。\n\nBytie 一到画布前，就把 $2n$ 个方格的每一个都画成了**不同**的颜色。为简单起见，我们用 $1$ 到 $2n$ 的整数来表示颜色。\n\n每个看到这个孩子的劳动成果的人都对这么小的孩子能够创造出如此宏伟的作品而感到非常惊讶。这甚至吸引了著名的艺术评论家 Bytona Bitego。他决定亲眼看看是什么让人们如此着迷，他将用自己特别准备的方法评估他的画，其方法如下：\n\n我们选择一个特定的颜色区间 $[l, r]$，然后只考虑颜色在这个区间内的方格。我们称这个颜色区间的好奇值等于这些方格形成的连通区域的数量。如果存在一连串颜色在 $[l, r]$ 中的相邻方格使得两个颜色在 $[l,r]$ 的方格连通，那么这两个方格就在一个区域内。\n\nBytona Bitego 想知道对于每个 $v\\in \\{1,2,\\ldots,k\\}$，有多少区间的好奇值为 $v$。你的任务就是回答他的问题。", "inputFormat": "第一行包含两个整数 $n,k$，分别表示画布的宽度和 Bajtona Bitego 想知道的最大好奇值。\n\n第二行包含 $n$ 个整数，表示画布第一行方格的颜色。从左到右按列编号递增顺序给出。\n\n类似地，第三行包含 $n$ 个整数，表示画布第二行方格的颜色，顺序与第一行相同。\n\n第二行和第三行的数字合起来形成了一个 $1$ 到 $2n$ 的整数排列。", "outputFormat": "输出一行 $k$ 个整数，第 $v$ 个整数表示有多少个区间的好奇值为 $v$。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$2\\le n\\le 10 ^ 5, 1\\le k\\le 10$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2022] Płótno", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 4 [Płótno](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/plo/)**\n\n由于圣诞节，Bytie 从父母那里得到了一块大画布，画布被分成 $2n$ 个方格，排列成两行 $n$ 列的矩形。为了方便在上面画画，这块画布被包在在一个很低很宽的圆柱体的侧面上，这样，画布的第一列就与最后一列相邻。如果画布上的两个方格有一条公共边，则认为它们是相邻的。即它们要么在同一列，要么在同一行的相邻列。\n\n数学上，我们可以用一个有序数对 $(y,x)$ 表示画布上的每个方格，其中 $1\\le y\\le 2,1\\le x\\le n$。两个方格 $(y_1,x_1)$ 和 $(y_2,x_2)$ 相邻，如果满足：\n\n- 它们在同一行，即 $y_1=y_2$，并且列相邻，即 $x_1+1\\equiv x_2 \\pmod n$ 或 $x_2+1\\equiv x_1\\pmod n$，或者\n- 它们在同一列，即 $x_1=x_2$。\n\nBytie 一到画布前，就把 $2n$ 个方格的每一个都画成了**不同**的颜色。为简单起见，我们用 $1$ 到 $2n$ 的整数来表示颜色。\n\n每个看到这个孩子的劳动成果的人都对这么小的孩子能够创造出如此宏伟的作品而感到非常惊讶。这甚至吸引了著名的艺术评论家 Bytona Bitego。他决定亲眼看看是什么让人们如此着迷，他将用自己特别准备的方法评估他的画，其方法如下：\n\n我们选择一个特定的颜色区间 $[l, r]$，然后只考虑颜色在这个区间内的方格。我们称这个颜色区间的好奇值等于这些方格形成的连通区域的数量。如果存在一连串颜色在 $[l, r]$ 中的相邻方格使得两个颜色在 $[l,r]$ 的方格连通，那么这两个方格就在一个区域内。\n\nBytona Bitego 想知道对于每个 $v\\in \\{1,2,\\ldots,k\\}$，有多少区间的好奇值为 $v$。你的任务就是回答他的问题。", "inputFormat": "第一行包含两个整数 $n,k$，分别表示画布的宽度和 Bajtona Bitego 想知道的最大好奇值。\n\n第二行包含 $n$ 个整数，表示画布第一行方格的颜色。从左到右按列编号递增顺序给出。\n\n类似地，第三行包含 $n$ 个整数，表示画布第二行方格的颜色，顺序与第一行相同。\n\n第二行和第三行的数字合起来形成了一个 $1$ 到 $2n$ 的整数排列。", "outputFormat": "输出一行 $k$ 个整数，第 $v$ 个整数表示有多少个区间的好奇值为 $v$。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$2\\le n\\le 10 ^ 5, 1\\le k\\le 10$。", "locale": "zh-CN"}}}
{"pid": "P9262", "type": "P", "difficulty": 6, "samples": [["4 5\n.....\n.B.C.\n..C..\n...B.\n3\nGLP\n", "..BCC\n....B\n.....\n.....\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "PA（波兰）"], "title": "[PA 2022] Łamigłówka", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 4 [Łamigłówka](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/lam/)**\n\nByteasar 在玩拼图。它是一个由单元格组成的 $n\\times m$ 大小的矩形。每个单元格可能是空的，也可能包含一个黑色或白色的方块。\n\n在每次操作中，这个玩具可以向平行于矩形边的四个方向之一倾斜。然后所有的方块会朝那个方向滑动到最远可以所处的位置，而不超出矩形范围或重叠。\n\nByteasar 倾斜了多次，请给出倾斜最后一次后整个拼图的状态。", "inputFormat": "第一行两个整数 $n,m$，表示这个矩形的大小。\n\n接下来 $n$ 行，每行一个长为 $m$ 的字符串，表示初始状态。字符串中仅包含三种字符：`.` 表示这个单元格是空的，`B` 表示这个单元格中有一个白色方块，`C` 表示这个单元格中有一个黑色方块。\n\n接下来一行一个整数 $k$，表示 Byteasar 倾斜的次数。\n\n最后一行包含一个长为 $k$ 的字符串，表示 Byteasar 每次的倾斜方向。字符串中仅包含 `G`，`D`，`L`，`P` 四种字符，分别表示向上，向下，向左和向右倾斜。", "outputFormat": "输出这个玩具的最终状态，输出格式与输入的初始状态格式相同，输出 $n$ 行，每行一个长度为 $m$ 的字符串，字符串中仅包含 `.`，`B`，`C` 三种字符。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$1\\le n,m\\le 500, 1\\le k\\le 5 \\times 10 ^ 5$。 ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2022] Łamigłówka", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 4 [Łamigłówka](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/lam/)**\n\nByteasar 在玩拼图。它是一个由单元格组成的 $n\\times m$ 大小的矩形。每个单元格可能是空的，也可能包含一个黑色或白色的方块。\n\n在每次操作中，这个玩具可以向平行于矩形边的四个方向之一倾斜。然后所有的方块会朝那个方向滑动到最远可以所处的位置，而不超出矩形范围或重叠。\n\nByteasar 倾斜了多次，请给出倾斜最后一次后整个拼图的状态。", "inputFormat": "第一行两个整数 $n,m$，表示这个矩形的大小。\n\n接下来 $n$ 行，每行一个长为 $m$ 的字符串，表示初始状态。字符串中仅包含三种字符：`.` 表示这个单元格是空的，`B` 表示这个单元格中有一个白色方块，`C` 表示这个单元格中有一个黑色方块。\n\n接下来一行一个整数 $k$，表示 Byteasar 倾斜的次数。\n\n最后一行包含一个长为 $k$ 的字符串，表示 Byteasar 每次的倾斜方向。字符串中仅包含 `G`，`D`，`L`，`P` 四种字符，分别表示向上，向下，向左和向右倾斜。", "outputFormat": "输出这个玩具的最终状态，输出格式与输入的初始状态格式相同，输出 $n$ 行，每行一个长度为 $m$ 的字符串，字符串中仅包含 `.`，`B`，`C` 三种字符。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$1\\le n,m\\le 500, 1\\le k\\le 5 \\times 10 ^ 5$。 ", "locale": "zh-CN"}}}
{"pid": "P9263", "type": "P", "difficulty": 7, "samples": [["4 5\nO...O\n?OO.?\n.OOO.\n?..O.\n", "5/2\n"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "PA（波兰）"], "title": "[PA 2022] Bakterie", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 5 [Bakterie](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/bak/)**\n\nAlbert Bynstein 教授目前正在研究一种新发现的细菌菌株，他给它起了一个代号叫 *Algorithmic Proeliis*。在他的下一个实验中，他准备了一个大的矩形实验台，他将其分为 $n\\cdot m$ 个区域，排列成 $n$ 行，每行 $m$ 个区域。\n\n然后对于每个区域，教授将从三个选项中选择一个：要么他一定会在其中放置一个培养皿，要么他一定不放培养皿，要么他将抛出一枚均匀的硬币来决定放不放培养皿。一旦培养皿放置完毕，为了进行实验就需要选择一个正整数 $k$，并在每个培养皿里放置恰好 $k$ 个细菌。\n\n这种细菌的特点是十分敌视其他菌落，因此实验过程如下：只要有一对相邻的、非空的培养皿，就会随机选出一对这样的培养皿（概率分布相等），之后两个培养皿中各有一个细菌死亡。我们假定，当且仅当两个培养皿所处的区域有一条公共边时，两区域相邻。\n\n考虑到抛硬币决定将培养皿放在某些区域里的随机性，和选择相邻培养皿并让其中的细菌死亡的随机性，令 $f(k)$ 表示在整个实验中存活的细菌的期望数量。显然，当不再有一对相邻的培养皿各含有至少一个细菌时，实验就会结束。\n\n一次在培养皿里放几个细菌很难，但一次性放置很多细菌就会容易得多。为此，教授沉思了一下，然后在黑板上写下了如下表达式：\n$$\n\\lim_{k\\to \\infty}\\frac{f(k)}{k}\n$$\n你作为他的助手，任务是计算上述极限的值。可以证明这个值总是一个可测的数字，所以你需要用一个不可约分数的形式表达这个值。", "inputFormat": "输入第一行包含两个整数 $n,m$，表示这个矩形实验台的大小。\n\n接下来 $n$ 行描述试验台。第 $i$ 行包含 $m$ 个字符，第 $j$ 个字符记为 $a_{i,j}$。如果 $a_{i,j}$ 是 `.`，则第 $i$ 行的第 $j$ 个区域一定不放培养皿。如果 $a_{i,j}$ 是 `O`（大写的 `o`），则第 $i$ 行的第 $j$ 个区域一定放培养皿。如果 $a_{i,j}$ 是 `?`，则第 $i$ 行的第 $j$ 个区域会用投硬币的方式决定放不放培养皿。", "outputFormat": "输出一行，表示对教授问题的回答。按 $a/b$ 的形式输出，其中 $b\\ge 1$ 且 $\\gcd(a,b)=1$。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$1\\le n,m\\le 200$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2022] Bakterie", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 5 [Bakterie](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/bak/)**\n\nAlbert Bynstein 教授目前正在研究一种新发现的细菌菌株，他给它起了一个代号叫 *Algorithmic Proeliis*。在他的下一个实验中，他准备了一个大的矩形实验台，他将其分为 $n\\cdot m$ 个区域，排列成 $n$ 行，每行 $m$ 个区域。\n\n然后对于每个区域，教授将从三个选项中选择一个：要么他一定会在其中放置一个培养皿，要么他一定不放培养皿，要么他将抛出一枚均匀的硬币来决定放不放培养皿。一旦培养皿放置完毕，为了进行实验就需要选择一个正整数 $k$，并在每个培养皿里放置恰好 $k$ 个细菌。\n\n这种细菌的特点是十分敌视其他菌落，因此实验过程如下：只要有一对相邻的、非空的培养皿，就会随机选出一对这样的培养皿（概率分布相等），之后两个培养皿中各有一个细菌死亡。我们假定，当且仅当两个培养皿所处的区域有一条公共边时，两区域相邻。\n\n考虑到抛硬币决定将培养皿放在某些区域里的随机性，和选择相邻培养皿并让其中的细菌死亡的随机性，令 $f(k)$ 表示在整个实验中存活的细菌的期望数量。显然，当不再有一对相邻的培养皿各含有至少一个细菌时，实验就会结束。\n\n一次在培养皿里放几个细菌很难，但一次性放置很多细菌就会容易得多。为此，教授沉思了一下，然后在黑板上写下了如下表达式：\n$$\n\\lim_{k\\to \\infty}\\frac{f(k)}{k}\n$$\n你作为他的助手，任务是计算上述极限的值。可以证明这个值总是一个可测的数字，所以你需要用一个不可约分数的形式表达这个值。", "inputFormat": "输入第一行包含两个整数 $n,m$，表示这个矩形实验台的大小。\n\n接下来 $n$ 行描述试验台。第 $i$ 行包含 $m$ 个字符，第 $j$ 个字符记为 $a_{i,j}$。如果 $a_{i,j}$ 是 `.`，则第 $i$ 行的第 $j$ 个区域一定不放培养皿。如果 $a_{i,j}$ 是 `O`（大写的 `o`），则第 $i$ 行的第 $j$ 个区域一定放培养皿。如果 $a_{i,j}$ 是 `?`，则第 $i$ 行的第 $j$ 个区域会用投硬币的方式决定放不放培养皿。", "outputFormat": "输出一行，表示对教授问题的回答。按 $a/b$ 的形式输出，其中 $b\\ge 1$ 且 $\\gcd(a,b)=1$。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$1\\le n,m\\le 200$。", "locale": "zh-CN"}}}
{"pid": "P9264", "type": "P", "difficulty": 7, "samples": [["4\n1 2 3 4\n", "24\n"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "PA（波兰）"], "title": "[PA 2022] Drzewa rozpinające", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 5 [Drzewa rozpinające](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/drz/)**\n\n给定一个长为 $n$ 的整数序列 $a_1,a_2,\\ldots,a_n$。根据这个序列你可以生成一个 $n$ 个节点的无向图：节点 $i$ 和 $j$ 之间（对于 $i\\neq j$）有 $\\gcd(a_i,a_j)$ 条可区分的边将这两个节点相连。你的任务是计算这个图的生成树数量。如果对于两棵树，其中一棵树包含另一棵树中不存在的边，那么就认为这两棵树不同。因为生成树数量很大，请输出它对 $10^9+7$ 取模后的值。", "inputFormat": "输入第一行一个整数 $n$，表示整数序列的长度。\n\n第二行 $n$ 个整数 $a_1,a_2,\\ldots,a_n$，表示这个整数序列。", "outputFormat": "输出一行一个整数，表示生成的图的生成树个数，对 $10^9+7$ 取模。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$1\\le n\\le 5000, 1\\le a_i\\le 5000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2022] Drzewa rozpinające", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 5 [Drzewa rozpinające](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/drz/)**\n\n给定一个长为 $n$ 的整数序列 $a_1,a_2,\\ldots,a_n$。根据这个序列你可以生成一个 $n$ 个节点的无向图：节点 $i$ 和 $j$ 之间（对于 $i\\neq j$）有 $\\gcd(a_i,a_j)$ 条可区分的边将这两个节点相连。你的任务是计算这个图的生成树数量。如果对于两棵树，其中一棵树包含另一棵树中不存在的边，那么就认为这两棵树不同。因为生成树数量很大，请输出它对 $10^9+7$ 取模后的值。", "inputFormat": "输入第一行一个整数 $n$，表示整数序列的长度。\n\n第二行 $n$ 个整数 $a_1,a_2,\\ldots,a_n$，表示这个整数序列。", "outputFormat": "输出一行一个整数，表示生成的图的生成树个数，对 $10^9+7$ 取模。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$1\\le n\\le 5000, 1\\le a_i\\le 5000$。", "locale": "zh-CN"}}}
{"pid": "P9265", "type": "P", "difficulty": 7, "samples": [["7\n2 1 4 7 3 6 5\n", "1 1 9 5 6 7 7\n"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "PA（波兰）"], "title": "[PA 2022] Chodzenie po linie", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 5 [Chodzenie po linie](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/lin/)**\n\nByteasar 是世界著名的马戏团演员，他擅长走钢丝，并在钢丝之间穿行。在他著名的表演中，马戏团帐篷的天花板下拉了 $n$ 条钢丝。如果我们俯瞰帐篷，并将其放置在坐标系中，第 $i\\ (i=1,2,\\ldots,n)$ 条钢丝连接点 $(i,0)$ 和点 $(p_i,1)$，其中序列 $p_1,p_2,\\ldots,p_n$ 是 $1$ 到 $n$ 整数的一个排列。\n\nByteasar 站在其中一条钢丝上开始表演，并让观众给他一些钢丝的编号。他的目标是站在观众所说的那条钢丝上面。Byteasar 非常善于沿钢丝移动，但从一条钢丝移动到另一条钢丝是相当复杂的。因为他非常勇敢，但并不愚蠢，只有两条钢丝相交时，他才能从一条钢丝移到另一条钢丝上。所有的钢丝都悬挂在相似的高度，所以这样的移动总能成功，但这是相当累人的。出于这个原因，Byteasar 将选择一条不同钢丝之间交点个数最少的路线。唯一的例外是当以这种方式不可能到达目标钢丝的情况——在这种情况下，Byteasar 将礼貌地感谢观众并回到后台，从而不进行任何穿越。\n\n然而，Byteasar 不确定他应该从哪根钢丝开始他的表演。对于这些钢丝的每一根，他都想知道对于观众所有可能的选择，他最少经过交点个数的和。帮他写一个程序来计算这些值。", "inputFormat": "输入第一行一个整数 $n$，表示钢丝数量。\n\n第二行 $n$ 个整数 $p_1,p_2,\\ldots,p_n$，，意义如题目描述。", "outputFormat": "输出一行 $n$ 个整数，第 $i$ 个整数表示如果 Byteasar 从第 $i$ 根钢丝出发，对于观众所有可能的选择，他最少经过交点个数的和。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$1\\le n\\le 2 \\times 10 ^ 5, 1\\le p_i\\le n$，\n\n保证对于任意 $i,j\\ (i\\neq j)$，满足 $p_i\\neq p_j$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2022] Chodzenie po linie", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 5 [Chodzenie po linie](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/lin/)**\n\nByteasar 是世界著名的马戏团演员，他擅长走钢丝，并在钢丝之间穿行。在他著名的表演中，马戏团帐篷的天花板下拉了 $n$ 条钢丝。如果我们俯瞰帐篷，并将其放置在坐标系中，第 $i\\ (i=1,2,\\ldots,n)$ 条钢丝连接点 $(i,0)$ 和点 $(p_i,1)$，其中序列 $p_1,p_2,\\ldots,p_n$ 是 $1$ 到 $n$ 整数的一个排列。\n\nByteasar 站在其中一条钢丝上开始表演，并让观众给他一些钢丝的编号。他的目标是站在观众所说的那条钢丝上面。Byteasar 非常善于沿钢丝移动，但从一条钢丝移动到另一条钢丝是相当复杂的。因为他非常勇敢，但并不愚蠢，只有两条钢丝相交时，他才能从一条钢丝移到另一条钢丝上。所有的钢丝都悬挂在相似的高度，所以这样的移动总能成功，但这是相当累人的。出于这个原因，Byteasar 将选择一条不同钢丝之间交点个数最少的路线。唯一的例外是当以这种方式不可能到达目标钢丝的情况——在这种情况下，Byteasar 将礼貌地感谢观众并回到后台，从而不进行任何穿越。\n\n然而，Byteasar 不确定他应该从哪根钢丝开始他的表演。对于这些钢丝的每一根，他都想知道对于观众所有可能的选择，他最少经过交点个数的和。帮他写一个程序来计算这些值。", "inputFormat": "输入第一行一个整数 $n$，表示钢丝数量。\n\n第二行 $n$ 个整数 $p_1,p_2,\\ldots,p_n$，，意义如题目描述。", "outputFormat": "输出一行 $n$ 个整数，第 $i$ 个整数表示如果 Byteasar 从第 $i$ 根钢丝出发，对于观众所有可能的选择，他最少经过交点个数的和。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$1\\le n\\le 2 \\times 10 ^ 5, 1\\le p_i\\le n$，\n\n保证对于任意 $i,j\\ (i\\neq j)$，满足 $p_i\\neq p_j$。", "locale": "zh-CN"}}}
{"pid": "P9266", "type": "P", "difficulty": 7, "samples": [["15 2\n())(()())()(())\n", "6\n"], ["15 3\n())(()())()(())\n", "3\n"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "PA（波兰）"], "title": "[PA 2022] Nawiasowe podziały", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 5 [Nawiasowe podziały](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/naw/)**\n\n我确信你是知道括号序列的，但是以防万一，并且作为回顾，让我们回忆一下它的定义：\n\n- `()` 是一个合法的括号序列。\n- 如果 $S$ 是一个合法的括号序列，那么 `(S)` 也是一个合法的括号序列。\n- 如果 $S_1$ 和 $S_2$ 都是合法的括号序列，那么 $S_1S_2$ 也是一个合法的括号序列。\n- 不符合上述规则的括号序列都不是合法的括号序列。\n\n给出一个长度为 $n$ 且仅由字符 `(` 和 `)` 组成的字符串，以及一个数字 $k$，这个字符串不一定是合法的括号序列。你的任务是把它分成 $k$ 个非空段（每个字符必须恰好属于一段内），使得每段中是合法括号序列的子串个数之和最小。", "inputFormat": "第一行两个整数 $n,k$，分别表示字符串长度和要分成的段数。\n\n第二行一个长度为 $n$ 的字符串，保证字符串仅由 `(` 和 `)` 组成。", "outputFormat": "输出一行一个整数，表示所有段中是合法括号序列的子串个数之和的最小值。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$1\\le k\\le n\\le 10 ^ 5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2022] Nawiasowe podziały", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 5 [Nawiasowe podziały](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/naw/)**\n\n我确信你是知道括号序列的，但是以防万一，并且作为回顾，让我们回忆一下它的定义：\n\n- `()` 是一个合法的括号序列。\n- 如果 $S$ 是一个合法的括号序列，那么 `(S)` 也是一个合法的括号序列。\n- 如果 $S_1$ 和 $S_2$ 都是合法的括号序列，那么 $S_1S_2$ 也是一个合法的括号序列。\n- 不符合上述规则的括号序列都不是合法的括号序列。\n\n给出一个长度为 $n$ 且仅由字符 `(` 和 `)` 组成的字符串，以及一个数字 $k$，这个字符串不一定是合法的括号序列。你的任务是把它分成 $k$ 个非空段（每个字符必须恰好属于一段内），使得每段中是合法括号序列的子串个数之和最小。", "inputFormat": "第一行两个整数 $n,k$，分别表示字符串长度和要分成的段数。\n\n第二行一个长度为 $n$ 的字符串，保证字符串仅由 `(` 和 `)` 组成。", "outputFormat": "输出一行一个整数，表示所有段中是合法括号序列的子串个数之和的最小值。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$1\\le k\\le n\\le 10 ^ 5$。", "locale": "zh-CN"}}}
{"pid": "P9267", "type": "P", "difficulty": 4, "samples": [["7\n3 2 3 5\n2 3 6\n3 5 6 7\n1 6\n1 7\n0\n0\n", "6\n"], ["3\n0\n1 3\n0\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "PA（波兰）"], "title": "[PA 2022] Walizki", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 5 [Walizki](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/wal/)**\n\n有没有想过，你在机场办理完了登机手续，你的行李箱会去哪里？就在它们消失的帘子后面，有一个巨大的大厅，里面布满了错综复杂的平台和传送带，对你的行李进行相应的分类。\n\nByteasar 负责评估新规划的 Byteburg Bitom 机场的行李大厅的设计。根据规划，大厅里将有 $n$ 个平台，用 $1$ 到 $n$ 的整数编号，每个行李箱最初都要运输到第一个平台。一些单向传送带可以从平台出发，连接到编号严格更大的平台。如果一个平台没有传送带出口，在这个平台的行李箱将由机场工作人员手动拿走并转移到相应的飞机上。另一方面，如果平台接有多条出口传送带，那么传送带的顺序就很重要——第一个行李箱遇到这样的平台，就会从第一条传送带上离开，第二个就会从第二条上离开，以此类推。当行李箱从最后一条传送带离开平台时，下一个行李箱又会从第一条传送带离开，如此循环往复。\n\n一旦一个行李箱被送到第一个平台，它在传送带上的运输和工作人员的收集都在下一个行李箱放在第一个平台之前进行。换句话说，在任何时候，最多只有一个行李箱在传送带上运输。\n\n可以想见，在处理了一定数量的行李箱后，这个行李系统会「复位」，即回到对于每个有出口传送带的平台，行李箱到达平台后都从第一条出口传送带离开的状态。Byteasar 想知道最少处理多少行李箱之后，系统将自我复位。请帮他计算出这个值！", "inputFormat": "第一行一个整数 $n$，表示平台个数。\n\n接下来 $n$ 行描述平台。第 $i$ 行开头一个非负整数 $r_i$，表示从第 $i$ 个平台离开的传送带条数。如果 $r_i=0$，表示工作人员从这个平台取行李。如果 $r_i>0$，这一行接着有 $r_i$ 个整数 $l_{i,1},l_{i,2},\\ldots,l_{i,r_i}$，按顺序表示出口传送带连接的平台编号（到达的平台编号也同样是递增的）。", "outputFormat": "输出一行一个整数，表示最少处理多少行李箱之后，系统将自我复位。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$1\\le n\\le 100, i<l_{i,1}<l_{i,2}<\\ldots<l_{i,r_i}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2022] Walizki", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 5 [Walizki](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/wal/)**\n\n有没有想过，你在机场办理完了登机手续，你的行李箱会去哪里？就在它们消失的帘子后面，有一个巨大的大厅，里面布满了错综复杂的平台和传送带，对你的行李进行相应的分类。\n\nByteasar 负责评估新规划的 Byteburg Bitom 机场的行李大厅的设计。根据规划，大厅里将有 $n$ 个平台，用 $1$ 到 $n$ 的整数编号，每个行李箱最初都要运输到第一个平台。一些单向传送带可以从平台出发，连接到编号严格更大的平台。如果一个平台没有传送带出口，在这个平台的行李箱将由机场工作人员手动拿走并转移到相应的飞机上。另一方面，如果平台接有多条出口传送带，那么传送带的顺序就很重要——第一个行李箱遇到这样的平台，就会从第一条传送带上离开，第二个就会从第二条上离开，以此类推。当行李箱从最后一条传送带离开平台时，下一个行李箱又会从第一条传送带离开，如此循环往复。\n\n一旦一个行李箱被送到第一个平台，它在传送带上的运输和工作人员的收集都在下一个行李箱放在第一个平台之前进行。换句话说，在任何时候，最多只有一个行李箱在传送带上运输。\n\n可以想见，在处理了一定数量的行李箱后，这个行李系统会「复位」，即回到对于每个有出口传送带的平台，行李箱到达平台后都从第一条出口传送带离开的状态。Byteasar 想知道最少处理多少行李箱之后，系统将自我复位。请帮他计算出这个值！", "inputFormat": "第一行一个整数 $n$，表示平台个数。\n\n接下来 $n$ 行描述平台。第 $i$ 行开头一个非负整数 $r_i$，表示从第 $i$ 个平台离开的传送带条数。如果 $r_i=0$，表示工作人员从这个平台取行李。如果 $r_i>0$，这一行接着有 $r_i$ 个整数 $l_{i,1},l_{i,2},\\ldots,l_{i,r_i}$，按顺序表示出口传送带连接的平台编号（到达的平台编号也同样是递增的）。", "outputFormat": "输出一行一个整数，表示最少处理多少行李箱之后，系统将自我复位。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$1\\le n\\le 100, i<l_{i,1}<l_{i,2}<\\ldots<l_{i,r_i}$。", "locale": "zh-CN"}}}
{"pid": "P9268", "type": "P", "difficulty": 4, "samples": [["1 5\nO....\n\n....O\n", "0.25"], ["2 2\nO.\n.O\n\nOO\n..\n", "0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "Special Judge", "PA（波兰）"], "title": "[PA 2022] Wieczór gier", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 5 [Wieczór gier](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/wie/)**\n\nBytie 喜欢在晚上玩他最喜欢的棋盘游戏。幸运的是，这个游戏是单人游戏，Bytie 不需要和朋友一起玩这个游戏。\n\n棋盘共 $n$ 行，每行有 $m$ 个方格，整个棋盘共有 $nm$ 个方格。棋盘上有 $k$ 个无法区分的棋子，最多只有 $8$ 个。 棋盘的边缘有装饰性的标记，这些标记表明了棋盘的上下左右方位。每个方格可能是空的，也可能放有一个棋子，但棋盘上总是至少有一个棋子，而且至少有一个方格是空的。换句话说，满足 $1\\le k\\le nm-1$。游戏中一步棋指的是选择一个包含棋子的方格和与之相邻的另一个不包含棋子的方格，然后将棋子从这个方格移到相邻的空方格中。\n\nBytie 喜欢这个不复杂但令人兴奋的规则，他可以花几个小时来移动棋子。一天晚上，他坐在棋盘前，在棋盘上摆了 $k$ 个棋子，并想到了一种棋子的排布方式，这种排布方式也许与开始时不同。他说，每次他要走一步棋时，他都会确定现在所有棋子的所有可能走法，并从这些走法中随机选出他要怎么走棋。例如，如果棋盘上有两个棋子，第一个棋子有一种走法，第二个棋子有两种走法，那么 Bytie 将以 $\\frac{1}{3}$ 的概率从这三种走法中选出一种来走下一步棋。\n\nBytie（正如我们已经提到的）非常喜欢玩这个游戏，所以他已经确定他会正好走 $100^{100^{100^{100}}}$ 步棋。在走了这么多步之后，棋盘上的棋子排布和目标排布相同的概率是多少？", "inputFormat": "第一行两个整数 $n,m$，分别表示棋盘的行数和列数。\n\n接下来 $n$ 行，每行 $m$ 个字符，表示初始的棋盘排布。如果第 $i$ 行第 $j$ 个字符是 `.`，那么棋盘第 $i$ 行第 $j$ 列的方格是空的。否则，这个字符将是 `O`（大写的 `o`），表示第 $i$ 行第 $j$ 列的方格中有一个棋子。\n\n接下来空一行，再接下来 $n$ 行描述目标状态，格式如初始状态。\n\n保证两个棋盘上的棋子个数相同，并且这个个数属于区间 $[1,nm-1]$。此外，保证棋子数不超过 $8$。", "outputFormat": "输出一行一个实数，表示在恰好走了 $100^{100^{100^{100}}}$ 步棋后，棋盘上的棋子排布和目标排布相同的概率。如果输出与答案的**绝对**误差不超过 $10^{-13}$，那么输出将被认为是正确的。\n\n注意：由于技术原因，输出小数点后位数多于 $18$ 位，或输出科学计数法形式的小数均将被判为「答案错误」。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$1\\le n,m\\le 8$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2022] Wieczór gier", "background": "", "description": "**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 5 [Wieczór gier](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/wie/)**\n\nBytie 喜欢在晚上玩他最喜欢的棋盘游戏。幸运的是，这个游戏是单人游戏，Bytie 不需要和朋友一起玩这个游戏。\n\n棋盘共 $n$ 行，每行有 $m$ 个方格，整个棋盘共有 $nm$ 个方格。棋盘上有 $k$ 个无法区分的棋子，最多只有 $8$ 个。 棋盘的边缘有装饰性的标记，这些标记表明了棋盘的上下左右方位。每个方格可能是空的，也可能放有一个棋子，但棋盘上总是至少有一个棋子，而且至少有一个方格是空的。换句话说，满足 $1\\le k\\le nm-1$。游戏中一步棋指的是选择一个包含棋子的方格和与之相邻的另一个不包含棋子的方格，然后将棋子从这个方格移到相邻的空方格中。\n\nBytie 喜欢这个不复杂但令人兴奋的规则，他可以花几个小时来移动棋子。一天晚上，他坐在棋盘前，在棋盘上摆了 $k$ 个棋子，并想到了一种棋子的排布方式，这种排布方式也许与开始时不同。他说，每次他要走一步棋时，他都会确定现在所有棋子的所有可能走法，并从这些走法中随机选出他要怎么走棋。例如，如果棋盘上有两个棋子，第一个棋子有一种走法，第二个棋子有两种走法，那么 Bytie 将以 $\\frac{1}{3}$ 的概率从这三种走法中选出一种来走下一步棋。\n\nBytie（正如我们已经提到的）非常喜欢玩这个游戏，所以他已经确定他会正好走 $100^{100^{100^{100}}}$ 步棋。在走了这么多步之后，棋盘上的棋子排布和目标排布相同的概率是多少？", "inputFormat": "第一行两个整数 $n,m$，分别表示棋盘的行数和列数。\n\n接下来 $n$ 行，每行 $m$ 个字符，表示初始的棋盘排布。如果第 $i$ 行第 $j$ 个字符是 `.`，那么棋盘第 $i$ 行第 $j$ 列的方格是空的。否则，这个字符将是 `O`（大写的 `o`），表示第 $i$ 行第 $j$ 列的方格中有一个棋子。\n\n接下来空一行，再接下来 $n$ 行描述目标状态，格式如初始状态。\n\n保证两个棋盘上的棋子个数相同，并且这个个数属于区间 $[1,nm-1]$。此外，保证棋子数不超过 $8$。", "outputFormat": "输出一行一个实数，表示在恰好走了 $100^{100^{100^{100}}}$ 步棋后，棋盘上的棋子排布和目标排布相同的概率。如果输出与答案的**绝对**误差不超过 $10^{-13}$，那么输出将被认为是正确的。\n\n注意：由于技术原因，输出小数点后位数多于 $18$ 位，或输出科学计数法形式的小数均将被判为「答案错误」。", "hint": "对于 $100\\%$ 的数据，满足：\n\n$1\\le n,m\\le 8$。", "locale": "zh-CN"}}}
{"pid": "P9269", "type": "P", "difficulty": 5, "samples": [["2\n0\n1\n2", "1 1 1 1\n1 2 1 2\n2 1 2 2\nEND\n01\n11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "交互题", "Special Judge", "CEOI（中欧）", "前缀和"], "title": "[CEOI 2013] 新宝岛 / Treasure", "background": "翻译自 [CEOI 2013 Day 1](https://ceoi2013.hsin.hr/tasks/tasks_day1.pdf)。\n\n**这是一道 IO 交互题。**\n\n一次地震过后，亚得里亚海出现了一座新岛。在岛上发现了一个特殊装置，名叫“神谕”。尽管没有说明手册，但考古学家和计算机专家的队伍成功地理解了它的行为。\n\n神谕提供了一些有关该岛宝藏位置的信息。该岛被分为一个 $N$ 行 $N$ 列的网格，其中行和列都从 $1$ 到 $N$ 编号。网格中的一些单元格包含宝藏。神谕只会回答以下形式的问题：“给定网格中的一个矩形，在这个矩形中，有多少个单元格包含宝藏？”\n\n**尽管神谕可以回答所有大小的矩形问题，但发现请求的信息越具体（矩形越小），神谕在回答时消耗的能量越多**。更精确地说，如果一个矩形包含 $S$ 个单元格，则神谕将使用 $1 + N \\times N - S$ 个单位的能量来回答。", "description": "编写一个程序，通过与神谕交互的方式，确定该岛上所有含有宝藏的单元格的位置。我们不希望在此过程中使用过多的能量，能量使用越少越好。但是也不要求使用的能量数量是最小的，具体得分规则见最后的“说明/提示”。\n\n这是一个交互式任务。您的程序使用标准输出向神谕提问，并通过读取标准输入来获得答案。\n\n- 在程序开始时，它应该读取一个整数 $N$（$2 \\leq N \\leq 100$），表示网格的大小。\n- 要向神谕提问，您的程序应输出一行包含 $4$ 个整数 $R_1$、$C_1$、$R_2$ 和 $C_2$，它们之间由空格分隔，使得 $1 \\leq R_1 \\leq R_2 \\leq N$ 和 $1 \\leq C_1 \\leq C_2 \\leq N$ 成立。如果条件不成立或行格式不正确，则您的程序在该测试运行中将得零分。\n- 神谕将响应一个包含单个整数的行 - 包含宝藏的矩形中提供的单元格数。更确切地说，是 $R_1 \\leq R \\leq R_2$ 且 $C_1 \\leq C \\leq C_2$ 且位于行 $R$、列 $C$ 的单元格包含宝藏的单元格数（$R$，$C$）。\n- 当程序完成提问（已经确定所有宝藏的位置）后，它应在新的一行上输出 `END`。然后，再输出 $N$ 行，每行包含 $N$ 个 `0` 或 `1` 字符的字符串。第 $R$ 行中的第 $C$ 个字符是 `1`，如果该行中列 $C$ 的单元格中有宝藏，则为 `0`，如果没有，则为 `1`。行从顶部到底部编号为 $1$ 到 $N$，列从左到右编号。一旦您的程序输出解决方案，程序的执行将会自动终止。\n\n为了与评分器正确交互，需要在每个问题和写出解决方案后**刷新标准输出**，这是交互题的惯例。\n\n在每个测试运行中，可以假定神谕必然正确回答问题，并且在交互之前宝藏的位置是确定的。换句话说，答案不会取决于程序先前问的问题（不会根据你问的问题来改变答案），它在每个测试点都是固定的。", "inputFormat": "该任务是一个交互式任务。要成功完成任务，需要编写一个程序以最大化降低向神谕提问的次数和使用的能量。在程序开始时，输入岛屿的大小 $N$。", "outputFormat": "通过输出行号和列号的方式向神谕询问包含宝藏的单元格数量。每当程序获得答案后，就要输出 `END`，然后将宝藏位置汇总并输出。最终得分将由程序使用的能量数量确定。具体评分标准在题目的最后面，具体格式可见输入输出的一组样例。", "hint": "[样例解释](https://www.luogu.com.cn/paste/tpzc0qdt)\n\n每个测试用例得分为 $10$ 分。如果程序的输出不正确，则该测试用例得零分。否则，根据神谕使用的总能量单位 $K$ 来确定分数。\n\n具体而言:\n- 如果 $K ≤ \\frac{7}{16} N^4 + N^2$，则得 $10$ 分。\n- 否则，如果 $K ≤ \\frac{7}{16} N^4 + 2N^3$，则得 $8$ 分。\n- 否则，如果 $K ≤ \\frac{3}{4} N^4$，则得 $4$ 分。\n- 否则，如果 $K ≤ N^4$，则得 $1$ 分。\n- 否则，得 $0$ 分。\n\n此外，在至少占总分 $40\\%$ 的测试数据中，$N$ 将最多为 $20$。\n\n总而言之，**花费的能量越少，你的得分就越高**。\n\n交互库/SPJ 提供者：@[Sprague_Garundy](https://www.luogu.com.cn/user/764746) 。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2013] 新宝岛 / Treasure", "background": "翻译自 [CEOI 2013 Day 1](https://ceoi2013.hsin.hr/tasks/tasks_day1.pdf)。\n\n**这是一道 IO 交互题。**\n\n一次地震过后，亚得里亚海出现了一座新岛。在岛上发现了一个特殊装置，名叫“神谕”。尽管没有说明手册，但考古学家和计算机专家的队伍成功地理解了它的行为。\n\n神谕提供了一些有关该岛宝藏位置的信息。该岛被分为一个 $N$ 行 $N$ 列的网格，其中行和列都从 $1$ 到 $N$ 编号。网格中的一些单元格包含宝藏。神谕只会回答以下形式的问题：“给定网格中的一个矩形，在这个矩形中，有多少个单元格包含宝藏？”\n\n**尽管神谕可以回答所有大小的矩形问题，但发现请求的信息越具体（矩形越小），神谕在回答时消耗的能量越多**。更精确地说，如果一个矩形包含 $S$ 个单元格，则神谕将使用 $1 + N \\times N - S$ 个单位的能量来回答。", "description": "编写一个程序，通过与神谕交互的方式，确定该岛上所有含有宝藏的单元格的位置。我们不希望在此过程中使用过多的能量，能量使用越少越好。但是也不要求使用的能量数量是最小的，具体得分规则见最后的“说明/提示”。\n\n这是一个交互式任务。您的程序使用标准输出向神谕提问，并通过读取标准输入来获得答案。\n\n- 在程序开始时，它应该读取一个整数 $N$（$2 \\leq N \\leq 100$），表示网格的大小。\n- 要向神谕提问，您的程序应输出一行包含 $4$ 个整数 $R_1$、$C_1$、$R_2$ 和 $C_2$，它们之间由空格分隔，使得 $1 \\leq R_1 \\leq R_2 \\leq N$ 和 $1 \\leq C_1 \\leq C_2 \\leq N$ 成立。如果条件不成立或行格式不正确，则您的程序在该测试运行中将得零分。\n- 神谕将响应一个包含单个整数的行 - 包含宝藏的矩形中提供的单元格数。更确切地说，是 $R_1 \\leq R \\leq R_2$ 且 $C_1 \\leq C \\leq C_2$ 且位于行 $R$、列 $C$ 的单元格包含宝藏的单元格数（$R$，$C$）。\n- 当程序完成提问（已经确定所有宝藏的位置）后，它应在新的一行上输出 `END`。然后，再输出 $N$ 行，每行包含 $N$ 个 `0` 或 `1` 字符的字符串。第 $R$ 行中的第 $C$ 个字符是 `1`，如果该行中列 $C$ 的单元格中有宝藏，则为 `0`，如果没有，则为 `1`。行从顶部到底部编号为 $1$ 到 $N$，列从左到右编号。一旦您的程序输出解决方案，程序的执行将会自动终止。\n\n为了与评分器正确交互，需要在每个问题和写出解决方案后**刷新标准输出**，这是交互题的惯例。\n\n在每个测试运行中，可以假定神谕必然正确回答问题，并且在交互之前宝藏的位置是确定的。换句话说，答案不会取决于程序先前问的问题（不会根据你问的问题来改变答案），它在每个测试点都是固定的。", "inputFormat": "该任务是一个交互式任务。要成功完成任务，需要编写一个程序以最大化降低向神谕提问的次数和使用的能量。在程序开始时，输入岛屿的大小 $N$。", "outputFormat": "通过输出行号和列号的方式向神谕询问包含宝藏的单元格数量。每当程序获得答案后，就要输出 `END`，然后将宝藏位置汇总并输出。最终得分将由程序使用的能量数量确定。具体评分标准在题目的最后面，具体格式可见输入输出的一组样例。", "hint": "[样例解释](https://www.luogu.com.cn/paste/tpzc0qdt)\n\n每个测试用例得分为 $10$ 分。如果程序的输出不正确，则该测试用例得零分。否则，根据神谕使用的总能量单位 $K$ 来确定分数。\n\n具体而言:\n- 如果 $K ≤ \\frac{7}{16} N^4 + N^2$，则得 $10$ 分。\n- 否则，如果 $K ≤ \\frac{7}{16} N^4 + 2N^3$，则得 $8$ 分。\n- 否则，如果 $K ≤ \\frac{3}{4} N^4$，则得 $4$ 分。\n- 否则，如果 $K ≤ N^4$，则得 $1$ 分。\n- 否则，得 $0$ 分。\n\n此外，在至少占总分 $40\\%$ 的测试数据中，$N$ 将最多为 $20$。\n\n总而言之，**花费的能量越少，你的得分就越高**。\n\n交互库/SPJ 提供者：@[Sprague_Garundy](https://www.luogu.com.cn/user/764746) 。", "locale": "zh-CN"}}}
{"pid": "P9270", "type": "P", "difficulty": 4, "samples": [["3 7\nE\nE\nE\nL 2\nE\nL 1\nE", "1 1\n3 2\n1 2\n3 1\n1 1"], ["13 9\nE\nE\nE\nE\nE\nE\nE\nE\nE", "1 1\n13 2\n7 1\n4 2\n10 1\n2 2\n3 1\n5 1\n6 2"], ["10 9\nE\nE\nE\nE\nL 3\nE\nE\nL 6\nE", "1 1\n10 2\n5 2\n7 1\n4 2\n2 2\n4 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "CEOI（中欧）"], "title": "[CEOI 2013] 有轨电车 / Tram", "background": "翻译自 [CEOI 2013 Day 1](https://ceoi2013.hsin.hr/tasks/tasks_day1.pdf)。\n\n在萨格勒布运营的电车的座位就像一个 $n$ 行 $2$ 列的网格，两个座位之间的距离，是相应网格正方形中心之间的欧几里得距离（直线距离）。\n\n\n大多数乘客在使用公共交通工具时会社恐，也就是说，当乘客进入电车时，会选择一个没有人坐的座位，并且该座位与最近的座位的距离尽可能大。如果有多个这样的座位，他们总是会选择一个行号较小的座位（因为这样他不需要走太远）。如果仍然有多个这种座位，他们会选择列号较小（即列号为 $1$）的座位。乘客选择座位后，会一直坐在那里，直到他离开电车。如果电车是空的，进入的乘客将始终选择第 $1$ 排第 $1$ 列的座位。", "description": "给定一系列事件，每个事件都是乘客进入或离开电车。你需要输出这位乘客进入时他会坐在哪里。电车一开始是空的。\n\n输入中有 $m$ 个事件，按事件发生的顺序编号为 $1$ 到 $m$。有两种事件：`E` 类事件表示乘客进入有轨电车，而 `L` 类事件则表示乘客离开有轨电车。对于类型为 `L` 的事件，还给出了一个整数 $p$，它表示在该事件中离开的乘客是在**事件** $p$ 中进入的乘客。\n\n测试数据确保每当乘客试图进入电车时，电车中至少有一个空位。", "inputFormat": "第一行输入包含两个整数 $n$ 和 $m$。\n\n接下来 $m$ 行，其中第 $i$ 行表示事件 $i$ 的内容，首先输入一个字符 `E` 或 `L`，当字符是 `L` 时再输入一个数 $p_i$，保证事件 $p_i$ 的类型一定是 `E`。", "outputFormat": "输出中的行数应等于输入中 `E` 类事件的数量。对于第 $i$ 个类型为 `E` 的事件，在第 $i$ 行上输出该乘客选择的座位号 $r,c$（行和列），中间用一个空格隔开。", "hint": "对于 $25\\%$ 的数据，$n,m\\le150$。\n\n对于 $45\\%$ 的数据，$n\\le1500$。\n\n对于 $65\\%$ 的数据，$m\\le1500$。\n\n对于 $100\\%$ 的数据，$n\\le150000,m\\le30000$。\n\n前三个测试点是样例。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2013] 有轨电车 / Tram", "background": "翻译自 [CEOI 2013 Day 1](https://ceoi2013.hsin.hr/tasks/tasks_day1.pdf)。\n\n在萨格勒布运营的电车的座位就像一个 $n$ 行 $2$ 列的网格，两个座位之间的距离，是相应网格正方形中心之间的欧几里得距离（直线距离）。\n\n\n大多数乘客在使用公共交通工具时会社恐，也就是说，当乘客进入电车时，会选择一个没有人坐的座位，并且该座位与最近的座位的距离尽可能大。如果有多个这样的座位，他们总是会选择一个行号较小的座位（因为这样他不需要走太远）。如果仍然有多个这种座位，他们会选择列号较小（即列号为 $1$）的座位。乘客选择座位后，会一直坐在那里，直到他离开电车。如果电车是空的，进入的乘客将始终选择第 $1$ 排第 $1$ 列的座位。", "description": "给定一系列事件，每个事件都是乘客进入或离开电车。你需要输出这位乘客进入时他会坐在哪里。电车一开始是空的。\n\n输入中有 $m$ 个事件，按事件发生的顺序编号为 $1$ 到 $m$。有两种事件：`E` 类事件表示乘客进入有轨电车，而 `L` 类事件则表示乘客离开有轨电车。对于类型为 `L` 的事件，还给出了一个整数 $p$，它表示在该事件中离开的乘客是在**事件** $p$ 中进入的乘客。\n\n测试数据确保每当乘客试图进入电车时，电车中至少有一个空位。", "inputFormat": "第一行输入包含两个整数 $n$ 和 $m$。\n\n接下来 $m$ 行，其中第 $i$ 行表示事件 $i$ 的内容，首先输入一个字符 `E` 或 `L`，当字符是 `L` 时再输入一个数 $p_i$，保证事件 $p_i$ 的类型一定是 `E`。", "outputFormat": "输出中的行数应等于输入中 `E` 类事件的数量。对于第 $i$ 个类型为 `E` 的事件，在第 $i$ 行上输出该乘客选择的座位号 $r,c$（行和列），中间用一个空格隔开。", "hint": "对于 $25\\%$ 的数据，$n,m\\le150$。\n\n对于 $45\\%$ 的数据，$n\\le1500$。\n\n对于 $65\\%$ 的数据，$m\\le1500$。\n\n对于 $100\\%$ 的数据，$n\\le150000,m\\le30000$。\n\n前三个测试点是样例。", "locale": "zh-CN"}}}
{"pid": "P9271", "type": "P", "difficulty": 6, "samples": [["Po|Px|Sxo#Soo#|o#Soo#|o#", "3\nPo|Px|Sxo#Sox#|o#Soo#|o#"], ["Po|SPo|oo|o#Px|oo|o##Po|Sxo#Po|ox|o#|o#|o#", "7\nPo|SPo|xx|o#Px|ox|o##Po|Sxx#Po|ox|o#|o#|o#"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "Special Judge", "CEOI（中欧）"], "title": "[CEOI 2013] 停车场 / Splot", "background": "翻译自 [CEOI 2013 Day 1](https://ceoi2013.hsin.hr/tasks/tasks_day1.pdf)。\n\n亚得里亚海沿岸和岛屿都有各种形状和大小的美丽沙滩。然而，许多沙滩无法通过汽车到达。为了满足不断增长的需求，沿海附近的一片巨大空地被改建成停车场。\n\n由于参与设计的所有建筑师都具有电气工程背景，想着怎么着自己学过的专业也得用上，于是停车场的布局就类似于在设计电路时常用的串并联图。\n\n停车场由停车位和连接它们的双向道路组成。每条道路连接两个不同的停车位，每一对停车位之间最多只能通过一条道路连接。每个停车位在任何时刻最多只能停放一辆汽车。其他车辆不能通过被占用的停车位行驶。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j207s329.png)\n$$\\text{图 1：构建停车图的规则，对应下面的三点}$$\n\n串并联停车场（也称为 splot，下文称为停车图）是一种由称为源点和终点的两个特定停车位构成的停车场，它是通过使用串并联组合规则从单个停车位构建而成的。每个停车图可以通过编码来指定其结构和停放车辆的位置，编码是一个描述其结构的字符序列。有效的停车图及其编码按照以下递归方式定义：\n\n1. 只包含一个停车位且没有道路的停车场是一个有效的停车图。这个单个停车位既是停车图的源点也是终点。如果停车位为空，则该停车图的编码为小写字母 `o`，如果停车位被汽车占用，则编码为小写字母`x`。\n   - ![](https://cdn.luogu.com.cn/upload/image_hosting/x6vficzn.png?x-oss-process=image/resize,m_lfit,h_170,w_225)\n\n2. 如果 $G_1$ 和 $G_2$ 是两个有效的停车图，它们的串联组合 $G$ 也是一个停车图。串联组合是通过在 $G_1$ 的终点和 $G_2$ 的源点之间添加一条道路来获得的。新获得的停车图 $G$ 的源点是 $G_1$ 的源点，而终点是 $G_2$ 的终点。如果 $E_1$ 和 $E_2$ 分别是停车图 $G_1$ 和 $G_2$ 的编码，则 $G$ 的编码为 `SE1E2#`。换句话说，编码是通过连接大写字母 `S`、组成它的停车图的编码和井号 `#` 获得的。\n   - ![](https://cdn.luogu.com.cn/upload/image_hosting/bzrozfho.png?x-oss-process=image/resize,m_lfit,h_340,w_450)\n\n3. 如果 $G_1$ 和 $G_2$ 是两个有效的停车图，它们的并联组合 $G$ 也是一个有效的停车图。并联组合是通过添加两个新的停车位 $s$ 和 $t$，添加从 $s$ 到 $G_1$ 和 $G_2$ 的源之间的道路，以及从 $t$ 到 $G_1$ 和 $G_2$ 的终端之间的道路得到的。新获得的停车图G的源是新添加的停车位 $s$，而 $G$ 的终端是新添加的停车位 $t$。如果 $E_1$ 和 $E_2$ 分别是停车图 $G_1$ 和 $G_2$ 的编码，而 $E_s$ 和 $E_t$ 是源 $s$ 和终端 $t$ 的编码（如果相应的空间为空，则为小写字母 `o`，否则为小写字母 `x`），则 $G$ 的编码为 `PEs|E1E2|Et#`。换句话说，编码是通过连接大写字母 `P`，源停车位的编码，竖线符号 `|`，被组合的停车图的编码，另一个竖线符号 `|`，终端停车位的编码，最后是井号 `#` 得到的。\n   - ![](https://cdn.luogu.com.cn/upload/image_hosting/czj2m8t8.png?x-oss-process=image/resize,m_lfit,h_340,w_450)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6gyst5bp.png)\n$$\\text{图2：与下面第一个测试示例对应的停车图}$$\n\n例如，上图中给出的停车图的编码是 `Po|Px|Sxo#Soo#|o#Soo#|o#`（译者注：`{Po|[Px|(Sxo#)(Soo#)|o#](Soo#)|o#}`）。请注意，停车图 $G$ 的编码中小写字母（`o` 或 `x`）的数量始终与 $G$ 中的停车位数量相同，并且停车图中的停车位与其编码中的小写字母之间存在一一对应关系。停车场只有一个出口，它就在整个停车图的**源停车位**。如果车辆可以通过一些道路和空的停车位到达源停车位，即它可以离开这个停车图，则我们称该车辆未被阻挡。例如，在上面的停车图中，两辆车都没有被阻挡，但是如果我们将一辆车停在停车图的终端（最右边的节点）上，则其中一辆车将被阻挡。允许将车停在停车图的源停车位上（但是如果这样做，停车图中的所有其他车辆都将被阻挡）。", "description": "停车场的运营商希望以一种方式安排进站的车辆，让图中没有车辆被阻挡。\n\n编写一个程序，计算可以停放在给定停车场的最大汽车总数，（**包括已经在那里的汽车**），使它没有任何汽车被阻挡，也不会移动任何已经在那里的车。此外，程序应该**找到一种方法**来安排停车图中最大数量的汽车。", "inputFormat": "输入一行，包含一个至少 $1$ 个、最多 $10$ 万个字符的序列，表示给定的 splot 的编码。序列中只会出现大写字母 `P` 和 `S`，小写字母 `o` 和 `x`，以及字符 `#`（`ASCII 35`）和 `|`（`ASCII 124`）。根据上面的规则，输入将是一个 splot 的编码。输入保证已经在停车场的汽车都不会被阻挡。", "outputFormat": "输出应包含 $2$ 行。第一行应该包含一个整数 $m$，表示可以停放在 splot 中的最大汽车数量。\n\n第二行应该包含一个字符序列，表示最终将车停放进 splot 的最佳方案。该序列应恰好包含 $m$ 个字母 `x`，并且是通过将原来的一些字母 `o` 替换为 `x` 得来的。\n\n可能有多个最佳安排，程序可以输出其中的任何一个。", "hint": "样例解释见题目描述最后一趴。\n\n如果输出不正确或不完整，但第一行输出（最大汽车数量）是正确的，你将获得相应测试点 $80\\%$ 的分数。\n\n在 $30\\%$ 的测试点中，splot 中的停车位总数最多为 $20$ 个。\n\n在另外 $40\\%$ 的测试点中，splot 为空，即输入不包含字母 `x`。\n\n对于 $100\\%$ 的数据，给定的 splot 的编码最多包含 $10$ 万个字符。\n\nSPJ 提供者：@[cff_0102](https://www.luogu.com.cn/user/542457) 。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2013] 停车场 / Splot", "background": "翻译自 [CEOI 2013 Day 1](https://ceoi2013.hsin.hr/tasks/tasks_day1.pdf)。\n\n亚得里亚海沿岸和岛屿都有各种形状和大小的美丽沙滩。然而，许多沙滩无法通过汽车到达。为了满足不断增长的需求，沿海附近的一片巨大空地被改建成停车场。\n\n由于参与设计的所有建筑师都具有电气工程背景，想着怎么着自己学过的专业也得用上，于是停车场的布局就类似于在设计电路时常用的串并联图。\n\n停车场由停车位和连接它们的双向道路组成。每条道路连接两个不同的停车位，每一对停车位之间最多只能通过一条道路连接。每个停车位在任何时刻最多只能停放一辆汽车。其他车辆不能通过被占用的停车位行驶。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j207s329.png)\n$$\\text{图 1：构建停车图的规则，对应下面的三点}$$\n\n串并联停车场（也称为 splot，下文称为停车图）是一种由称为源点和终点的两个特定停车位构成的停车场，它是通过使用串并联组合规则从单个停车位构建而成的。每个停车图可以通过编码来指定其结构和停放车辆的位置，编码是一个描述其结构的字符序列。有效的停车图及其编码按照以下递归方式定义：\n\n1. 只包含一个停车位且没有道路的停车场是一个有效的停车图。这个单个停车位既是停车图的源点也是终点。如果停车位为空，则该停车图的编码为小写字母 `o`，如果停车位被汽车占用，则编码为小写字母`x`。\n   - ![](https://cdn.luogu.com.cn/upload/image_hosting/x6vficzn.png?x-oss-process=image/resize,m_lfit,h_170,w_225)\n\n2. 如果 $G_1$ 和 $G_2$ 是两个有效的停车图，它们的串联组合 $G$ 也是一个停车图。串联组合是通过在 $G_1$ 的终点和 $G_2$ 的源点之间添加一条道路来获得的。新获得的停车图 $G$ 的源点是 $G_1$ 的源点，而终点是 $G_2$ 的终点。如果 $E_1$ 和 $E_2$ 分别是停车图 $G_1$ 和 $G_2$ 的编码，则 $G$ 的编码为 `SE1E2#`。换句话说，编码是通过连接大写字母 `S`、组成它的停车图的编码和井号 `#` 获得的。\n   - ![](https://cdn.luogu.com.cn/upload/image_hosting/bzrozfho.png?x-oss-process=image/resize,m_lfit,h_340,w_450)\n\n3. 如果 $G_1$ 和 $G_2$ 是两个有效的停车图，它们的并联组合 $G$ 也是一个有效的停车图。并联组合是通过添加两个新的停车位 $s$ 和 $t$，添加从 $s$ 到 $G_1$ 和 $G_2$ 的源之间的道路，以及从 $t$ 到 $G_1$ 和 $G_2$ 的终端之间的道路得到的。新获得的停车图G的源是新添加的停车位 $s$，而 $G$ 的终端是新添加的停车位 $t$。如果 $E_1$ 和 $E_2$ 分别是停车图 $G_1$ 和 $G_2$ 的编码，而 $E_s$ 和 $E_t$ 是源 $s$ 和终端 $t$ 的编码（如果相应的空间为空，则为小写字母 `o`，否则为小写字母 `x`），则 $G$ 的编码为 `PEs|E1E2|Et#`。换句话说，编码是通过连接大写字母 `P`，源停车位的编码，竖线符号 `|`，被组合的停车图的编码，另一个竖线符号 `|`，终端停车位的编码，最后是井号 `#` 得到的。\n   - ![](https://cdn.luogu.com.cn/upload/image_hosting/czj2m8t8.png?x-oss-process=image/resize,m_lfit,h_340,w_450)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6gyst5bp.png)\n$$\\text{图2：与下面第一个测试示例对应的停车图}$$\n\n例如，上图中给出的停车图的编码是 `Po|Px|Sxo#Soo#|o#Soo#|o#`（译者注：`{Po|[Px|(Sxo#)(Soo#)|o#](Soo#)|o#}`）。请注意，停车图 $G$ 的编码中小写字母（`o` 或 `x`）的数量始终与 $G$ 中的停车位数量相同，并且停车图中的停车位与其编码中的小写字母之间存在一一对应关系。停车场只有一个出口，它就在整个停车图的**源停车位**。如果车辆可以通过一些道路和空的停车位到达源停车位，即它可以离开这个停车图，则我们称该车辆未被阻挡。例如，在上面的停车图中，两辆车都没有被阻挡，但是如果我们将一辆车停在停车图的终端（最右边的节点）上，则其中一辆车将被阻挡。允许将车停在停车图的源停车位上（但是如果这样做，停车图中的所有其他车辆都将被阻挡）。", "description": "停车场的运营商希望以一种方式安排进站的车辆，让图中没有车辆被阻挡。\n\n编写一个程序，计算可以停放在给定停车场的最大汽车总数，（**包括已经在那里的汽车**），使它没有任何汽车被阻挡，也不会移动任何已经在那里的车。此外，程序应该**找到一种方法**来安排停车图中最大数量的汽车。", "inputFormat": "输入一行，包含一个至少 $1$ 个、最多 $10$ 万个字符的序列，表示给定的 splot 的编码。序列中只会出现大写字母 `P` 和 `S`，小写字母 `o` 和 `x`，以及字符 `#`（`ASCII 35`）和 `|`（`ASCII 124`）。根据上面的规则，输入将是一个 splot 的编码。输入保证已经在停车场的汽车都不会被阻挡。", "outputFormat": "输出应包含 $2$ 行。第一行应该包含一个整数 $m$，表示可以停放在 splot 中的最大汽车数量。\n\n第二行应该包含一个字符序列，表示最终将车停放进 splot 的最佳方案。该序列应恰好包含 $m$ 个字母 `x`，并且是通过将原来的一些字母 `o` 替换为 `x` 得来的。\n\n可能有多个最佳安排，程序可以输出其中的任何一个。", "hint": "样例解释见题目描述最后一趴。\n\n如果输出不正确或不完整，但第一行输出（最大汽车数量）是正确的，你将获得相应测试点 $80\\%$ 的分数。\n\n在 $30\\%$ 的测试点中，splot 中的停车位总数最多为 $20$ 个。\n\n在另外 $40\\%$ 的测试点中，splot 为空，即输入不包含字母 `x`。\n\n对于 $100\\%$ 的数据，给定的 splot 的编码最多包含 $10$ 万个字符。\n\nSPJ 提供者：@[cff_0102](https://www.luogu.com.cn/user/542457) 。", "locale": "zh-CN"}}}
{"pid": "P9272", "type": "P", "difficulty": 5, "samples": [["7\n1 7\n7 5\n4 5\n4 8\n6 6\n6 1\n2 3", "16\n11\n12\n11\n12\n16\n8"], ["4\n1 1\n2 3\n3 2\n4 4", "3\n4\n4\n3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "CEOI（中欧）"], "title": "[CEOI 2013] 千岛之国 / Adritic", "background": "翻译自 [CEOI 2013 Day 2](https://ceoi2013.hsin.hr/tasks/tasks_day2.pdf)。\n\n“千岛之国”是克罗地亚旅游业在二十世纪九十年代中期的官方口号。虽然这个口号实际上不准确（克罗地亚的岛屿数量略多于 $1000$ 个），但“跳岛旅游”（从一个岛屿航行到另一个岛屿）是一个受欢迎的夏季活动。亚得里亚海的地图是由组成 $2500$ 行和 $2500$ 列的单位正方形组成的网格。行编号从北到南为 $1$ 到 $2500$，而列编号从西到东为 $1$ 到 $2500$。海中有 $N$ 个岛屿，编号为 $1$ 到 $N$，每个岛屿都位于网格的某个单位正方形内。岛屿 $K$ 的位置由相应的网格方格的坐标确定——其行号 $R_K$ 和列号 $C_K$。没有两个岛屿的位置相同。\n\n由于风和海流的影响，只有当岛屿 $B$ 对于 $A$ 来说位于大致的西北或东南方向时才能直接从一个岛屿航行到另一个岛屿。更准确地说，只有在 $R_A < R_B$ 和 $C_A < C_B$ 都成立，或 $R_A > R_B$ 和 $C_A > C_B$ 都成立时，才可以从岛屿 $A$ “跳”到岛屿 $B$。请注意，两个岛屿之间的距离或其他岛屿的存在并不影响从一个岛屿跳到另一个岛屿的可能性。如果无法直接从 $A$ 跳到 $B$，则可能通过其他岛屿使用一些“跳跃”序列从 $A$ 到 $B$ 进行航行。从 $A$ 到 $B$ 的航行距离定义为从 $A$ 到 $B$ 所需的最少“跳跃”次数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hdqlicpn.png)\n\n例如，在上面的图中，从位于第 $2$ 行第 $3$ 列的岛屿开始，我们可以跳到另外四个岛屿，而剩下的两个岛屿的航行距离为两个跳跃次数。", "description": "一次帆船大会正在计划，组织者正在考虑每个岛屿作为大会的可能场地。在考虑候选岛屿时，他们想知道：如果每个其他岛屿都派出一艘帆船，为了使所有帆船都到达候选岛屿，需要的最小跳数是多少，或者等效地说，从所有其他岛屿到候选岛屿的航行距离之和是多少。\n\n编写一个程序，对于给定 $N$ 个岛屿的位置，对于每个岛屿 $K$，计算所有其他岛屿到岛屿 $K$ 的航行距离之和。测试数据保证，对于所有岛屿 $A$ 和 $B$，可以使用一些跳跃序列从 $A$ 到 $B$ 航行。", "inputFormat": "第一行包含一个整数 $N$（$1\\le N\\le250000$），表示岛屿的数量。接下来的 $N$ 行包含岛屿的位置。每个位置用一对整数表示，它们介于 $1$ 和 $2500$ 之间（包括 $1$ 和 $2500$），分别表示行和列号。", "outputFormat": "输出应包含 $N$ 行。对于每个岛屿，按照它们在输入中给出的顺序，输出从所有其他岛屿到该岛屿的航行距离之和，每个岛屿输出一行。", "hint": "在 $25\\%$ 的测试用例中，$N$ 最多为 $100$。\n\n在 $50\\%$ 的测试用例中，$N$ 最多为 $1500$。\n\n在 $60\\%$ 的测试用例中，$N$ 最多为 $5000$。\n\n在 $80\\%$ 的测试用例中，$N$ 最多为 $25000$。\n\n在 $100\\%$ 的测试用例中，$1\\le N\\le250000$。\n\n**注意：$N$ 可以是 $1$。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2013] 千岛之国 / Adritic", "background": "翻译自 [CEOI 2013 Day 2](https://ceoi2013.hsin.hr/tasks/tasks_day2.pdf)。\n\n“千岛之国”是克罗地亚旅游业在二十世纪九十年代中期的官方口号。虽然这个口号实际上不准确（克罗地亚的岛屿数量略多于 $1000$ 个），但“跳岛旅游”（从一个岛屿航行到另一个岛屿）是一个受欢迎的夏季活动。亚得里亚海的地图是由组成 $2500$ 行和 $2500$ 列的单位正方形组成的网格。行编号从北到南为 $1$ 到 $2500$，而列编号从西到东为 $1$ 到 $2500$。海中有 $N$ 个岛屿，编号为 $1$ 到 $N$，每个岛屿都位于网格的某个单位正方形内。岛屿 $K$ 的位置由相应的网格方格的坐标确定——其行号 $R_K$ 和列号 $C_K$。没有两个岛屿的位置相同。\n\n由于风和海流的影响，只有当岛屿 $B$ 对于 $A$ 来说位于大致的西北或东南方向时才能直接从一个岛屿航行到另一个岛屿。更准确地说，只有在 $R_A < R_B$ 和 $C_A < C_B$ 都成立，或 $R_A > R_B$ 和 $C_A > C_B$ 都成立时，才可以从岛屿 $A$ “跳”到岛屿 $B$。请注意，两个岛屿之间的距离或其他岛屿的存在并不影响从一个岛屿跳到另一个岛屿的可能性。如果无法直接从 $A$ 跳到 $B$，则可能通过其他岛屿使用一些“跳跃”序列从 $A$ 到 $B$ 进行航行。从 $A$ 到 $B$ 的航行距离定义为从 $A$ 到 $B$ 所需的最少“跳跃”次数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hdqlicpn.png)\n\n例如，在上面的图中，从位于第 $2$ 行第 $3$ 列的岛屿开始，我们可以跳到另外四个岛屿，而剩下的两个岛屿的航行距离为两个跳跃次数。", "description": "一次帆船大会正在计划，组织者正在考虑每个岛屿作为大会的可能场地。在考虑候选岛屿时，他们想知道：如果每个其他岛屿都派出一艘帆船，为了使所有帆船都到达候选岛屿，需要的最小跳数是多少，或者等效地说，从所有其他岛屿到候选岛屿的航行距离之和是多少。\n\n编写一个程序，对于给定 $N$ 个岛屿的位置，对于每个岛屿 $K$，计算所有其他岛屿到岛屿 $K$ 的航行距离之和。测试数据保证，对于所有岛屿 $A$ 和 $B$，可以使用一些跳跃序列从 $A$ 到 $B$ 航行。", "inputFormat": "第一行包含一个整数 $N$（$1\\le N\\le250000$），表示岛屿的数量。接下来的 $N$ 行包含岛屿的位置。每个位置用一对整数表示，它们介于 $1$ 和 $2500$ 之间（包括 $1$ 和 $2500$），分别表示行和列号。", "outputFormat": "输出应包含 $N$ 行。对于每个岛屿，按照它们在输入中给出的顺序，输出从所有其他岛屿到该岛屿的航行距离之和，每个岛屿输出一行。", "hint": "在 $25\\%$ 的测试用例中，$N$ 最多为 $100$。\n\n在 $50\\%$ 的测试用例中，$N$ 最多为 $1500$。\n\n在 $60\\%$ 的测试用例中，$N$ 最多为 $5000$。\n\n在 $80\\%$ 的测试用例中，$N$ 最多为 $25000$。\n\n在 $100\\%$ 的测试用例中，$1\\le N\\le250000$。\n\n**注意：$N$ 可以是 $1$。**", "locale": "zh-CN"}}}
{"pid": "P9273", "type": "P", "difficulty": 3, "samples": [["2 2\n.....|.....\n.....|.....\n...#.|.....\n.....|.....\n.....|.....\n-----+-----\n.....|.....\n.....|.....\n.....|.....\n.....|.....\n.....|.....", "aaacc|dxxxa\nbbbce|dyyya\nddd#e|dzzza\nccbae|fccbb\ncbbaa|ffcdb\n-----+---_-\nssrrr|tttdd\nsaaax_xxeee\nyxbbb|zdaaa\nyxccc|zdbbb\nyxddd|zdccc"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2013", "提交答案", "Special Judge", "CEOI（中欧）"], "title": "[CEOI 2013] 灌水 / Watering", "background": "upd on 2023/11/01: 本题部分分已修复。\n\n翻译自 [CEOI 2013 Day 2](https://ceoi2013.hsin.hr/tasks/tasks_day2.pdf)。\n\nSara 是一位专注的农民，拥有一块大的长方形土地。她的土地被分成网格状的若干个单元格，共有 $5\\times R$ 行和 $5\\times C$ 列。此外，每隔五行有一道横向的围栏，每隔五列有一道纵向的围栏。这些围栏将土地划分成了 $R\\times C$ 个大小为 $5\\times5$ 的区域，称为田地。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1d5z6e4a.png)\n\n这块农田两个最常见的问题是鸟害和旱灾。为了对抗鸟害，有些田地安置了稻草人。稻草人（如果有的话）占据一个单元格，每个 $5\\times5$ 的田地最多只能有一个稻草人。\n\n在干旱期，可能会持续数月时间，Sara 使用洒水器来浇灌她的庄稼。每个洒水器都有三个喷嘴：一个主喷嘴和两个侧喷嘴。它正好占据三个单元格，并浇灌所有这些单元格。侧喷嘴总是占据紧邻主喷嘴（上、下、左或右）的两个单元格。因此，单个洒水器可以浇灌到的三个单元格如图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mkdmixtp.png)\n\nSara 要在未被稻草人占据的每个单元格上恰好放置一个洒水器。含有稻草人的单元格不能包含洒水器喷嘴。此外，喷嘴不能放置在 Sara 的土地之外。被单个洒水器浇灌的三个单元格不一定属于同一 $5\\times5$ 领域：它们也可以属于相邻的领域。在这种情况下，Sara 必须在两个由同一洒水器浇灌的相邻领域之间的栅栏上钻一个洞。", "description": "**这是一个提交答案题。您将获得 $10$ 个输入文件，只需提交相应的输出文件即可。您可以从附件里的 `watering.in.zip` 中下载输入文件。**\n\n提交一个可行的浇灌方案，使得它满足所有的要求。\n\n如果存在多个解决方案，可以提交任何一个。", "inputFormat": "输入的第一行包含一对整数 $R$ 和 $C$（$1≤R,C≤100$），它们表示 Sara 的土地的大小。\n\n\n接下来的 $6\\times R-1$ 行，每行包含一个长度为 $6\\times C-1$ 的字符序列。它们代表 Sara 的田地和它们之间的围栏。即使围栏实际上是无限薄的，它也用字符表示。\n\n\n一个单元格用一个字符表示。点字符 `.` 表示空单元格，而 `#` 字符表示稻草人。垂直围栏用 `|` 字符表示，水平围栏用 `-` 字符表示。交叉点用 `+` 字符表示。", "outputFormat": "输出文件应该包含采用与输入文件相同格式的文本表示具有有效喷水器排列的字段。栅栏中的每个孔应该由下划线字符 `_` 表示。输入文件中的所有空单元格（点）都应替换为小写字母 `a` - `z` ，以满足以下规则：\n\n1. 由同一喷水器浇灌的任何三个单元格都由相同的字母表示，即使它们不全部在同一个 $5\\times5$ 的农田中。\n2. 如果同一块田中相邻的两个单元格由不同的喷水器浇灌，则它们必须用不同的字母表示。\n3. 如果不同农田中的两个相邻单元格由不同的喷水器浇灌，并且它们之间有一个栅栏孔，则它们必须用不同的字母表示（但是这样钻孔的意义何在）。\n4. 允许将属于不同农田的相邻单元格表示为相同的字母，只要满足所有先前的规则。", "hint": "每个测试点的分值为 $10$ 分。如果输出方案无效，该测试点将获得零分。如果方案有效，则将按以下方式进行评分：\n- 如果栅栏上的孔的数量不超过 $R\\times C$，则得分为 $10$ 分。\n- 否则，得分为 $5$ 分。\n\n\n在 $10$ 个测试输入中的 $4$ 个中，每个田地都有一个稻草人。\n\nSPJ 提供者：@[cff_0102](https://www.luogu.com.cn/user/542457) 。注：附件中的文件请用记事本/写字板打开。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2013] 灌水 / Watering", "background": "upd on 2023/11/01: 本题部分分已修复。\n\n翻译自 [CEOI 2013 Day 2](https://ceoi2013.hsin.hr/tasks/tasks_day2.pdf)。\n\nSara 是一位专注的农民，拥有一块大的长方形土地。她的土地被分成网格状的若干个单元格，共有 $5\\times R$ 行和 $5\\times C$ 列。此外，每隔五行有一道横向的围栏，每隔五列有一道纵向的围栏。这些围栏将土地划分成了 $R\\times C$ 个大小为 $5\\times5$ 的区域，称为田地。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1d5z6e4a.png)\n\n这块农田两个最常见的问题是鸟害和旱灾。为了对抗鸟害，有些田地安置了稻草人。稻草人（如果有的话）占据一个单元格，每个 $5\\times5$ 的田地最多只能有一个稻草人。\n\n在干旱期，可能会持续数月时间，Sara 使用洒水器来浇灌她的庄稼。每个洒水器都有三个喷嘴：一个主喷嘴和两个侧喷嘴。它正好占据三个单元格，并浇灌所有这些单元格。侧喷嘴总是占据紧邻主喷嘴（上、下、左或右）的两个单元格。因此，单个洒水器可以浇灌到的三个单元格如图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mkdmixtp.png)\n\nSara 要在未被稻草人占据的每个单元格上恰好放置一个洒水器。含有稻草人的单元格不能包含洒水器喷嘴。此外，喷嘴不能放置在 Sara 的土地之外。被单个洒水器浇灌的三个单元格不一定属于同一 $5\\times5$ 领域：它们也可以属于相邻的领域。在这种情况下，Sara 必须在两个由同一洒水器浇灌的相邻领域之间的栅栏上钻一个洞。", "description": "**这是一个提交答案题。您将获得 $10$ 个输入文件，只需提交相应的输出文件即可。您可以从附件里的 `watering.in.zip` 中下载输入文件。**\n\n提交一个可行的浇灌方案，使得它满足所有的要求。\n\n如果存在多个解决方案，可以提交任何一个。", "inputFormat": "输入的第一行包含一对整数 $R$ 和 $C$（$1≤R,C≤100$），它们表示 Sara 的土地的大小。\n\n\n接下来的 $6\\times R-1$ 行，每行包含一个长度为 $6\\times C-1$ 的字符序列。它们代表 Sara 的田地和它们之间的围栏。即使围栏实际上是无限薄的，它也用字符表示。\n\n\n一个单元格用一个字符表示。点字符 `.` 表示空单元格，而 `#` 字符表示稻草人。垂直围栏用 `|` 字符表示，水平围栏用 `-` 字符表示。交叉点用 `+` 字符表示。", "outputFormat": "输出文件应该包含采用与输入文件相同格式的文本表示具有有效喷水器排列的字段。栅栏中的每个孔应该由下划线字符 `_` 表示。输入文件中的所有空单元格（点）都应替换为小写字母 `a` - `z` ，以满足以下规则：\n\n1. 由同一喷水器浇灌的任何三个单元格都由相同的字母表示，即使它们不全部在同一个 $5\\times5$ 的农田中。\n2. 如果同一块田中相邻的两个单元格由不同的喷水器浇灌，则它们必须用不同的字母表示。\n3. 如果不同农田中的两个相邻单元格由不同的喷水器浇灌，并且它们之间有一个栅栏孔，则它们必须用不同的字母表示（但是这样钻孔的意义何在）。\n4. 允许将属于不同农田的相邻单元格表示为相同的字母，只要满足所有先前的规则。", "hint": "每个测试点的分值为 $10$ 分。如果输出方案无效，该测试点将获得零分。如果方案有效，则将按以下方式进行评分：\n- 如果栅栏上的孔的数量不超过 $R\\times C$，则得分为 $10$ 分。\n- 否则，得分为 $5$ 分。\n\n\n在 $10$ 个测试输入中的 $4$ 个中，每个田地都有一个稻草人。\n\nSPJ 提供者：@[cff_0102](https://www.luogu.com.cn/user/542457) 。注：附件中的文件请用记事本/写字板打开。", "locale": "zh-CN"}}}
{"pid": "P9274", "type": "P", "difficulty": 4, "samples": [["3\nassembler 0.50\nfurnace 0.50\nmining_well 0.55\n6\niron_plate furnace 3.20\n1\niron_ore 1\ncopper_plate furnace 3.20\n1\ncopper_ore 1\niron_ore mining_well 1.00\n0\ncopper_ore mining_well 1.00\n0\ncopper_cable assembler 0.50\n1\ncopper_plate 1\nelectronic_circuit assembler 0.50\n2\niron_plate 1\ncopper_cable 3\n1\nelectronic_circuit 10", "iron_plate furnace 64\ncopper_plate furnace 192\niron_ore mining_well 19\ncopper_ore mining_well 55\ncopper_cable assembler 30\nelectronic_circuit assembler 10"], ["3\nassembler 0.50\nfurnace 0.50\nmining_well 0.55\n4\niron_plate furnace 3.20\n1\niron_ore 1\niron_ore mining_well 1.00\n0\niron_gear assembler 0.50\n1\niron_plate 2\ntransport_belt assembler 0.50\n2\niron_plate 1\niron_gear 1\n1\ntransport_belt 7", "iron_plate furnace 135\niron_ore mining_well 39\niron_gear assembler 7\ntransport_belt assembler 7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "O2优化", "AGM"], "title": "[AGM 2023 资格赛] 建设计划", "background": "", "description": "一组工程师正在计划建造一座新工厂。为了使他们的工厂可靠，他们希望以恒定且可靠的单位每秒速率创建各种物品。他们可以使用不同的机器来制作这些材料。每个机器都有自己的速度，影响制作过程。每种材料都有自己的制作配方，必须在特定的机器执行。\n\n您将获得每个机器的描述以及您需要的每种材料和中间材料的配方。你也会得到一份材料清单，你必须以一定的速度生产，这样你的工厂是可靠的。\n\n我们认为一种机器配置是最优的，当且仅当如果从配置中移除任意一台机器，至少有一种材料的生产速率小于所需的速率。\n\n你需要找到一种最优的配置。", "inputFormat": "输入的第一行将包含一个整数 $M(1≤M≤100)$，表示我们拥有的机器类型的数量。在接下来的 $M$ 行中，每一行都有一个字符串 $n(1≤|n|≤30)$ 和一个数字 $s(0.01≤s≤100)$，表示一台机器的名称和速度。\n\n下面一行输入将包含一个整数 $N(1≤N≤100)$，表示配方的数量。\n\n接下来输入 $n$ 组配方。对于每组配方，在配方的第一行，字符串 $p(1≤|p|≤30)$ 表示要制作的材料的名称，字符串 $l(1≤|l|≤30)$ 表示制作过程中使用的机器名称，数字 $t(0.01≤t≤100)$ 表示以正常速度制作材料所需的时间(以秒为单位)。在下一行中，有一个数字 $k(0≤k≤15)$，表示生产当前这个材料过程中所需另外材料的种类数。下面的 $k$ 行中，每一行包含一个字符串 $n(1≤|n|≤30)$ ，表示所需材料的名称，一个整数 $c(1≤c≤10)$，表示所需的相应材料的单位数。\n\n下一行将包含一个整数 $Q(1≤Q≤100)$，表示需求的数量。\n\n下面的每一条 $Q$ 行都包含一个字符串 $m(1≤|m|≤30)$，表示需要这个需求下生产的材料的名称，以及一个整数 $c(1≤c≤10)$，表示每秒需要生产的该材料的单位数。\n\n$s$ 和 $t$ 都是有两个小数点的浮点数。保证存在最优配置。保证最优解中每种材料的生产速率不超过每秒 $10^9$个单位，每种材料都可以使用独特的配方制作。并且保证配方的需求关系不存在环。", "outputFormat": "总共 $n$ 行，在第 $n$ 行，输出 $p_i,l_i,r_i$，其中 $r_i$ 表示用来执行第 $i$ 个配方的机器数量。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[AGM 2023 资格赛] 建设计划", "background": "", "description": "一组工程师正在计划建造一座新工厂。为了使他们的工厂可靠，他们希望以恒定且可靠的单位每秒速率创建各种物品。他们可以使用不同的机器来制作这些材料。每个机器都有自己的速度，影响制作过程。每种材料都有自己的制作配方，必须在特定的机器执行。\n\n您将获得每个机器的描述以及您需要的每种材料和中间材料的配方。你也会得到一份材料清单，你必须以一定的速度生产，这样你的工厂是可靠的。\n\n我们认为一种机器配置是最优的，当且仅当如果从配置中移除任意一台机器，至少有一种材料的生产速率小于所需的速率。\n\n你需要找到一种最优的配置。", "inputFormat": "输入的第一行将包含一个整数 $M(1≤M≤100)$，表示我们拥有的机器类型的数量。在接下来的 $M$ 行中，每一行都有一个字符串 $n(1≤|n|≤30)$ 和一个数字 $s(0.01≤s≤100)$，表示一台机器的名称和速度。\n\n下面一行输入将包含一个整数 $N(1≤N≤100)$，表示配方的数量。\n\n接下来输入 $n$ 组配方。对于每组配方，在配方的第一行，字符串 $p(1≤|p|≤30)$ 表示要制作的材料的名称，字符串 $l(1≤|l|≤30)$ 表示制作过程中使用的机器名称，数字 $t(0.01≤t≤100)$ 表示以正常速度制作材料所需的时间(以秒为单位)。在下一行中，有一个数字 $k(0≤k≤15)$，表示生产当前这个材料过程中所需另外材料的种类数。下面的 $k$ 行中，每一行包含一个字符串 $n(1≤|n|≤30)$ ，表示所需材料的名称，一个整数 $c(1≤c≤10)$，表示所需的相应材料的单位数。\n\n下一行将包含一个整数 $Q(1≤Q≤100)$，表示需求的数量。\n\n下面的每一条 $Q$ 行都包含一个字符串 $m(1≤|m|≤30)$，表示需要这个需求下生产的材料的名称，以及一个整数 $c(1≤c≤10)$，表示每秒需要生产的该材料的单位数。\n\n$s$ 和 $t$ 都是有两个小数点的浮点数。保证存在最优配置。保证最优解中每种材料的生产速率不超过每秒 $10^9$个单位，每种材料都可以使用独特的配方制作。并且保证配方的需求关系不存在环。", "outputFormat": "总共 $n$ 行，在第 $n$ 行，输出 $p_i,l_i,r_i$，其中 $r_i$ 表示用来执行第 $i$ 个配方的机器数量。", "hint": "", "locale": "zh-CN"}}}
