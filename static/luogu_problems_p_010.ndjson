{"pid": "P3532", "type": "P", "difficulty": 6, "samples": [["6\n1\n2\n3\n4\n5\n6", "2\n1\n1\n2\n1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2012", "POI（波兰）", "枚举"], "title": "[POI 2012] ODL-Distance", "background": "", "description": "We consider the distance between positive integers in this problem, defined as follows.\n\nA single operation consists in either multiplying a given number by a prime number1    or dividing it by a prime number (if it does divide without a remainder).\n\nThe distance between the numbers ![](http://main.edu.pl/images/OI19/odl-en-tex.1.png) and ![](http://main.edu.pl/images/OI19/odl-en-tex.2.png), denoted ![](http://main.edu.pl/images/OI19/odl-en-tex.3.png), is the minimum number of operations    it takes to transform the number ![](http://main.edu.pl/images/OI19/odl-en-tex.4.png) into the number ![](http://main.edu.pl/images/OI19/odl-en-tex.5.png).\n\nFor example, ![](http://main.edu.pl/images/OI19/odl-en-tex.6.png).\n\nObserve that the function ![](http://main.edu.pl/images/OI19/odl-en-tex.7.png) is indeed a distance function - for any positive integers ![](http://main.edu.pl/images/OI19/odl-en-tex.8.png), ![](http://main.edu.pl/images/OI19/odl-en-tex.9.png) and ![](http://main.edu.pl/images/OI19/odl-en-tex.10.png) the following hold:\n\nthe distance between a number and itself is 0: ![](http://main.edu.pl/images/OI19/odl-en-tex.11.png),                  the distance from ![](http://main.edu.pl/images/OI19/odl-en-tex.12.png) to ![](http://main.edu.pl/images/OI19/odl-en-tex.13.png) is the same as from ![](http://main.edu.pl/images/OI19/odl-en-tex.14.png) to ![](http://main.edu.pl/images/OI19/odl-en-tex.15.png): ![](http://main.edu.pl/images/OI19/odl-en-tex.16.png), and                  the triangle inequality holds: ![](http://main.edu.pl/images/OI19/odl-en-tex.17.png).\n\nA sequence of ![](http://main.edu.pl/images/OI19/odl-en-tex.18.png) positive integers, ![](http://main.edu.pl/images/OI19/odl-en-tex.19.png), is given.\n\nFor each number ![](http://main.edu.pl/images/OI19/odl-en-tex.20.png) we have to determine ![](http://main.edu.pl/images/OI19/odl-en-tex.21.png) such that ![](http://main.edu.pl/images/OI19/odl-en-tex.22.png) and ![](http://main.edu.pl/images/OI19/odl-en-tex.23.png) is minimal.", "inputFormat": "In the first line of standard input there is a single integer ![](http://main.edu.pl/images/OI19/odl-en-tex.24.png) (![](http://main.edu.pl/images/OI19/odl-en-tex.25.png)).\n\nIn the following ![](http://main.edu.pl/images/OI19/odl-en-tex.26.png) lines the numbers ![](http://main.edu.pl/images/OI19/odl-en-tex.27.png) (![](http://main.edu.pl/images/OI19/odl-en-tex.28.png)) are given,      one per line.\n\nIn tests worth 30% of total point it additionally holds that ![](http://main.edu.pl/images/OI19/odl-en-tex.29.png).\n", "outputFormat": "Your program should print exactly ![](http://main.edu.pl/images/OI19/odl-en-tex.30.png) lines to the standard output, a single integer in each line.\n\nThe ![](http://main.edu.pl/images/OI19/odl-en-tex.31.png)-th line should give the minimum ![](http://main.edu.pl/images/OI19/odl-en-tex.32.png) such that: ![](http://main.edu.pl/images/OI19/odl-en-tex.33.png), ![](http://main.edu.pl/images/OI19/odl-en-tex.34.png) and ![](http://main.edu.pl/images/OI19/odl-en-tex.35.png) is minimal.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] ODL-Distance", "background": "", "description": "We consider the distance between positive integers in this problem, defined as follows.\n\nA single operation consists in either multiplying a given number by a prime number1    or dividing it by a prime number (if it does divide without a remainder).\n\nThe distance between the numbers ![](http://main.edu.pl/images/OI19/odl-en-tex.1.png) and ![](http://main.edu.pl/images/OI19/odl-en-tex.2.png), denoted ![](http://main.edu.pl/images/OI19/odl-en-tex.3.png), is the minimum number of operations    it takes to transform the number ![](http://main.edu.pl/images/OI19/odl-en-tex.4.png) into the number ![](http://main.edu.pl/images/OI19/odl-en-tex.5.png).\n\nFor example, ![](http://main.edu.pl/images/OI19/odl-en-tex.6.png).\n\nObserve that the function ![](http://main.edu.pl/images/OI19/odl-en-tex.7.png) is indeed a distance function - for any positive integers ![](http://main.edu.pl/images/OI19/odl-en-tex.8.png), ![](http://main.edu.pl/images/OI19/odl-en-tex.9.png) and ![](http://main.edu.pl/images/OI19/odl-en-tex.10.png) the following hold:\n\nthe distance between a number and itself is 0: ![](http://main.edu.pl/images/OI19/odl-en-tex.11.png),                  the distance from ![](http://main.edu.pl/images/OI19/odl-en-tex.12.png) to ![](http://main.edu.pl/images/OI19/odl-en-tex.13.png) is the same as from ![](http://main.edu.pl/images/OI19/odl-en-tex.14.png) to ![](http://main.edu.pl/images/OI19/odl-en-tex.15.png): ![](http://main.edu.pl/images/OI19/odl-en-tex.16.png), and                  the triangle inequality holds: ![](http://main.edu.pl/images/OI19/odl-en-tex.17.png).\n\nA sequence of ![](http://main.edu.pl/images/OI19/odl-en-tex.18.png) positive integers, ![](http://main.edu.pl/images/OI19/odl-en-tex.19.png), is given.\n\nFor each number ![](http://main.edu.pl/images/OI19/odl-en-tex.20.png) we have to determine ![](http://main.edu.pl/images/OI19/odl-en-tex.21.png) such that ![](http://main.edu.pl/images/OI19/odl-en-tex.22.png) and ![](http://main.edu.pl/images/OI19/odl-en-tex.23.png) is minimal.", "inputFormat": "In the first line of standard input there is a single integer ![](http://main.edu.pl/images/OI19/odl-en-tex.24.png) (![](http://main.edu.pl/images/OI19/odl-en-tex.25.png)).\n\nIn the following ![](http://main.edu.pl/images/OI19/odl-en-tex.26.png) lines the numbers ![](http://main.edu.pl/images/OI19/odl-en-tex.27.png) (![](http://main.edu.pl/images/OI19/odl-en-tex.28.png)) are given,      one per line.\n\nIn tests worth 30% of total point it additionally holds that ![](http://main.edu.pl/images/OI19/odl-en-tex.29.png).\n", "outputFormat": "Your program should print exactly ![](http://main.edu.pl/images/OI19/odl-en-tex.30.png) lines to the standard output, a single integer in each line.\n\nThe ![](http://main.edu.pl/images/OI19/odl-en-tex.31.png)-th line should give the minimum ![](http://main.edu.pl/images/OI19/odl-en-tex.32.png) such that: ![](http://main.edu.pl/images/OI19/odl-en-tex.33.png), ![](http://main.edu.pl/images/OI19/odl-en-tex.34.png) and ![](http://main.edu.pl/images/OI19/odl-en-tex.35.png) is minimal.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] ODL-Distance", "background": "", "description": "**译自 POI 2012 Stage 1. 「[Distance](https://szkopul.edu.pl/problemset/problem/Phel_x2Ny30OUh7z1RhCtzEG/site/?key=statement)」**\n\n定义一次「操作」为将一个正整数除以或乘以一个质数。定义函数 $d(a,b)$ 表示将 $a$ 进行若干次“操作”变成 $b$ 所需要的最小操作次数。例如，$d(69,42)=3$.\n\n$d$ 显然是一个距离函数，满足以下性质：\n* $d(a,a) = 0$\n* $d(a,b) = d(b,a)$\n* $d(a,b) + d(b,c) \\ge d(a,c)$\n\n给定 $n$ 个正整数 $a_1, a_2, \\ldots, a_n$，对每个 $a_i (1 \\le i \\le n)$，求 $j$ 使得 $j \\neq i$ 且 $d(a_i,a_j)$ 最小。如果有多个满足条件的 $j$，应输出最小的那个。", "inputFormat": "第一行一个正整数 $n (2 \\le n \\le 100,000)$.\n\n第二行 $n$ 个正整数 $a_1, a_2, \\ldots, a_n (1 \\le a_i \\le 1\\ 000\\ 000)$.", "outputFormat": "输出 $n$ 行，每行一个整数，表示使 $j \\neq i$ 且 $d(a_i,a_j)$ 最小的 $j$.", "hint": "对于 $30\\%$ 的数据有 $n \\le 1000$.\n\n对于所有数据有 $2 \\le n \\le 10^5,1 \\le a_i \\le 10^6$.\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2690)。", "locale": "zh-CN"}}}
{"pid": "P3533", "type": "P", "difficulty": 5, "samples": [["12 5\n4 3 5 5 1 1 12 12 9 9 7 1\n7 2\n8 11\n1 2\n9 10\n10 5", "2 3\n1 2\n2 2\n0 1\n-1 -1"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2012", "倍增", "并查集", "POI（波兰）", "最近公共祖先 LCA", "基环树"], "title": "[POI 2012] RAN-Rendezvous", "background": "", "description": "Byteasar is a ranger who works in the Arrow Cave - a famous rendezvous destination among lovers.\n\nThe cave consists of $n$ chambers connected with one-way corridors.\n\nIn each chamber exactly one outgoing corridor is marked with an arrow.\n\nEvery corridor leads directly to some (not necessarily different) chamber.\n\nThe enamoured couples that agree to meet in the Arrow Cave are notorious for forgetting to agree upon    specific chamber, and consequently often cannot find their dates.\n\nIn the past this led to many mix-ups and misunderstandings\\dots    But ever since each chamber is equipped with an emergency telephone line to the ranger on duty,    helping the enamoured find their dates has become the rangers' main occupation.\n\nThe rangers came up with the following method.\n\nKnowing where the enamoured are, they tell each of them how many times they should follow the corridor marked with an arrow in order to meet their date.\n\nThe lovers obviously want to meet as soon as possible - after all, they came to the cave to spend time together, not to wander around alone!\n\nMost rangers are happy to oblige: they do their best to give each couple a valid pair of numbers such that their maximum is minimal.\n\nBut some rangers, among their numbers Byteasar, grew tired of this extracurricular activity and ensuing puzzles.  Byteasar has asked you to write a program    that will ease the process.  The program, given a description of the cave and the current location of $k$ couples,    should determine $k$ pairs of numbers $x_i$ and $y_i$ such that if the $i$-th couple follows respectively: he $x_i$ and she $y_i$ corridors marked with arrows,then they will meet in a single chamber of the cave $max(x_i,y_i)$ is minimal,subject to above $min(x_i,y_i)$ is minimal,if above conditions do not determine a unique solution, then the woman should cover smaller distance ($x_i\\ge y_i$).\n\nIt may happen that such numbers $x_i$ and $y_i$ do not exist - then let $x_i=y_i=-1$.  Note that it is fine for several couples    to meet in a single chamber.  Once the lovers have found their dates, they will be happy to lose themselves in the cave again...", "inputFormat": "In the first line of the standard input there are two positive integers $n$ and $k$($1\\le n,k\\le 500\\ 000$), separated by a single space, that denote   the number of chambers in the Arrow Cave and the number of couples who want to find their dates, respectively.\n\nThe chambers are numbered from 1 to $n$, while the enamoured couples are numbered from 1 to $k$.\n\nThe second line of input contains $n$ positive integers separated by single spaces:\n\nthe $i$-th such integer determines the number of chamber to which the corridor marked with an arrow going out of chamber $i$ leads.\n\nThe following $k$ lines specify the queries by the separated couples. Each such query consists of two positive integers separated by a single space - these denote the numbers of chambers where the lovers are - first him, then her.\n\nIn the tests worth 40% of the total points it additionally holds that $n,k\\le 2\\ 000$.\n", "outputFormat": "Your program should print exactly $k$ lines to the standard output,   one line per each couple specified in the input:\n\nthe $i$-th line of the output should give the instructions for the $i$-th couple on the input.\n\nI.e., the $i$-th line of output should contain the integers $x_i,y_i$, separated by a single space.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] RAN-Rendezvous", "background": "", "description": "Byteasar is a ranger who works in the Arrow Cave - a famous rendezvous destination among lovers.\n\nThe cave consists of $n$ chambers connected with one-way corridors.\n\nIn each chamber exactly one outgoing corridor is marked with an arrow.\n\nEvery corridor leads directly to some (not necessarily different) chamber.\n\nThe enamoured couples that agree to meet in the Arrow Cave are notorious for forgetting to agree upon    specific chamber, and consequently often cannot find their dates.\n\nIn the past this led to many mix-ups and misunderstandings\\dots    But ever since each chamber is equipped with an emergency telephone line to the ranger on duty,    helping the enamoured find their dates has become the rangers' main occupation.\n\nThe rangers came up with the following method.\n\nKnowing where the enamoured are, they tell each of them how many times they should follow the corridor marked with an arrow in order to meet their date.\n\nThe lovers obviously want to meet as soon as possible - after all, they came to the cave to spend time together, not to wander around alone!\n\nMost rangers are happy to oblige: they do their best to give each couple a valid pair of numbers such that their maximum is minimal.\n\nBut some rangers, among their numbers Byteasar, grew tired of this extracurricular activity and ensuing puzzles.  Byteasar has asked you to write a program    that will ease the process.  The program, given a description of the cave and the current location of $k$ couples,    should determine $k$ pairs of numbers $x_i$ and $y_i$ such that if the $i$-th couple follows respectively: he $x_i$ and she $y_i$ corridors marked with arrows,then they will meet in a single chamber of the cave $max(x_i,y_i)$ is minimal,subject to above $min(x_i,y_i)$ is minimal,if above conditions do not determine a unique solution, then the woman should cover smaller distance ($x_i\\ge y_i$).\n\nIt may happen that such numbers $x_i$ and $y_i$ do not exist - then let $x_i=y_i=-1$.  Note that it is fine for several couples    to meet in a single chamber.  Once the lovers have found their dates, they will be happy to lose themselves in the cave again...", "inputFormat": "In the first line of the standard input there are two positive integers $n$ and $k$($1\\le n,k\\le 500\\ 000$), separated by a single space, that denote   the number of chambers in the Arrow Cave and the number of couples who want to find their dates, respectively.\n\nThe chambers are numbered from 1 to $n$, while the enamoured couples are numbered from 1 to $k$.\n\nThe second line of input contains $n$ positive integers separated by single spaces:\n\nthe $i$-th such integer determines the number of chamber to which the corridor marked with an arrow going out of chamber $i$ leads.\n\nThe following $k$ lines specify the queries by the separated couples. Each such query consists of two positive integers separated by a single space - these denote the numbers of chambers where the lovers are - first him, then her.\n\nIn the tests worth 40% of the total points it additionally holds that $n,k\\le 2\\ 000$.\n", "outputFormat": "Your program should print exactly $k$ lines to the standard output,   one line per each couple specified in the input:\n\nthe $i$-th line of the output should give the instructions for the $i$-th couple on the input.\n\nI.e., the $i$-th line of output should contain the integers $x_i,y_i$, separated by a single space.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] RAN-Rendezvous", "background": "", "description": "**译自 POI 2012 Stage 1. 「[Rendezvous](https://szkopul.edu.pl/problemset/problem/MZTXfOVnJmac175TTH5Lr9Q3/site/?key=statement)」**\n\n给定一个有 $n$ 个顶点的有向图，每个顶点有且仅有一条出边。每次询问给出两个顶点 $a_i$ 和 $b_i$，求满足以下条件的 $x_i$ 和 $y_i$：\n* 从顶点 $a_i$ 沿出边走 $x_i$ 步与从顶点 $b_i$ 沿出边走 $y_i$ 步到达的顶点相同。\n* $\\max(x_i, y_i)$ 最小。\n* 满足以上条件的情况下 $\\min(x_i, y_i)$ 最小。\n* 如果以上条件没有给出一个唯一的解，则还需要满足 $x_i \\ge y_i$。\n\n如果不存在这样的 $x_i$ 和 $y_i$，则 $x_i = y_i = -1$。", "inputFormat": "第一行两个正整数 $n$ 和 $k$（$1 \\le n \\le 500\\ 000,1 \\le k \\le 500\\ 000$），表示顶点数和询问个数。\n\n接下来一行 $n$ 个正整数，第 $i$ 个数表示 $i$ 号顶点出边指向的顶点。\n\n接下来 $k$ 行表示询问，每行两个整数 $a_i$ 和 $b_i$。", "outputFormat": "对每组询问输出两个整数 $x_i$ 和 $y_i$.", "hint": "对于 $40\\%$ 的数据，$n \\le 2000,k \\le 2000$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 500\\ 000,1 \\le k \\le 500\\ 000$。", "locale": "zh-CN"}}}
{"pid": "P3534", "type": "P", "difficulty": 6, "samples": [["16 15\n8 7 6 5 5 5 5 5 6 6 7 8 9 7 5 5", "1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "二分", "POI（波兰）", "Special Judge"], "title": "[POI 2012] STU-Well", "background": "", "description": "Byteasar has set off on a journey along the Dry River, which crosses the Byteotian Desert.\n\nUnfortunately, the Dry River has dried out, and Byteasar has run out of water.\n\nHis only hope is to dig a deep enough well in the dried river bed.\n\nRealising the graveness of his situation, Byteasar decides to plan everything carefully before he actually starts digging.\n\nThe danger is that he drains his strength before he reaches the water level - in such case he is unlikely to survive.\n\nHe managed to determine the depth of the water level.  He also knows how much he can dig before losing strength.\n\nHis only worry is a possible landslide, which might bury him alive.\n\nHe sends you (via a satellite telephone) a topographic map of the river bed.\n\nAnd, of course, he asks you to help him determine where he should dig so that he reaches water before draining his strength    while keeping the slope of his excavation as gentle as possible.\n\nHe is waiting for your advice!\n\n", "inputFormat": "In the first line of the standard input two positive integers are given, $n$ and $m$ ($1\\le n\\le 1\\ 000\\ 000$, $1\\le m\\le 10^{18}$), separated by a single space.\n\nThe second line holds $n$ positive integers $x_1,x_2,\\cdots,x_n$ ($1\\le x_i\\le 10^9$), also separated by single spaces.\n\nByteasar has enough energy to perform $m$ swings of the shovel.\n\nThe numbers $x_1,x_2,\\cdots,x_n$ describe the topography of the Dry River's bed.\n\nThey represent the depth of the sand layer above the ground water level in successive one meter spaced spots along the river bed.\n\nWith a single swing of the shovel Byteasar can extract an amount of the sand that decreases any of the numbers $x_i$ by 1.If any of these numbers, say $x_k$, drops to 0, this means that Byteasar has dug down to the water. But Byteasar has a secondary goal as well. He wants the following number $z$, characterising the slope of the sand hill, minimised:\n\n$z=max_{i=1,2,\\cdots,n-1}|x_i-x_{i+1}|$\nIf there are multiple correct values of the number $k$,representing the spot where Byteasar is to dig down to reach the water, your program can pick one arbitrarily. The spots $1,2,\\cdots,n$ are the only ones suitable for digging - elsewhere there is rock rather than sand. You may assume that Byteasar has enough energy to reach water at one of the spots.\n", "outputFormat": "Your program should print two integers to the standard output, separated by a single space:\n\nthe spot $k$, where Byteasar should dig for water, and the minimum value of the number $z$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] STU-Well", "background": "", "description": "Byteasar has set off on a journey along the Dry River, which crosses the Byteotian Desert.\n\nUnfortunately, the Dry River has dried out, and Byteasar has run out of water.\n\nHis only hope is to dig a deep enough well in the dried river bed.\n\nRealising the graveness of his situation, Byteasar decides to plan everything carefully before he actually starts digging.\n\nThe danger is that he drains his strength before he reaches the water level - in such case he is unlikely to survive.\n\nHe managed to determine the depth of the water level.  He also knows how much he can dig before losing strength.\n\nHis only worry is a possible landslide, which might bury him alive.\n\nHe sends you (via a satellite telephone) a topographic map of the river bed.\n\nAnd, of course, he asks you to help him determine where he should dig so that he reaches water before draining his strength    while keeping the slope of his excavation as gentle as possible.\n\nHe is waiting for your advice!\n\n", "inputFormat": "In the first line of the standard input two positive integers are given, $n$ and $m$ ($1\\le n\\le 1\\ 000\\ 000$, $1\\le m\\le 10^{18}$), separated by a single space.\n\nThe second line holds $n$ positive integers $x_1,x_2,\\cdots,x_n$ ($1\\le x_i\\le 10^9$), also separated by single spaces.\n\nByteasar has enough energy to perform $m$ swings of the shovel.\n\nThe numbers $x_1,x_2,\\cdots,x_n$ describe the topography of the Dry River's bed.\n\nThey represent the depth of the sand layer above the ground water level in successive one meter spaced spots along the river bed.\n\nWith a single swing of the shovel Byteasar can extract an amount of the sand that decreases any of the numbers $x_i$ by 1.If any of these numbers, say $x_k$, drops to 0, this means that Byteasar has dug down to the water. But Byteasar has a secondary goal as well. He wants the following number $z$, characterising the slope of the sand hill, minimised:\n\n$z=max_{i=1,2,\\cdots,n-1}|x_i-x_{i+1}|$\nIf there are multiple correct values of the number $k$,representing the spot where Byteasar is to dig down to reach the water, your program can pick one arbitrarily. The spots $1,2,\\cdots,n$ are the only ones suitable for digging - elsewhere there is rock rather than sand. You may assume that Byteasar has enough energy to reach water at one of the spots.\n", "outputFormat": "Your program should print two integers to the standard output, separated by a single space:\n\nthe spot $k$, where Byteasar should dig for water, and the minimum value of the number $z$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] STU-Well", "background": "**译自 POI 2012 Stage 1. 「[Well](https://szkopul.edu.pl/problemset/problem/S-cyTRH8ScRh-XfLPAsXCQ0e/site/?key=statement)」**\n\n翻译来自 [LOJ](https://loj.ac/p/2692)。", "description": "\n给定 $n$ 个正整数 $x_1, x_2, \\ldots, x_n$，可以进行不超过 $m$ 次操作，每次操作时选择一个正整数 $x_i$ 并将其减一。\n\n在存在 $k$ 使得 $x_k=0$ 的情况下，最小化\n$$ z = \\max_{i=1,2,\\ldots,n-1}{\\lvert x_i - x_{i+1} \\rvert} $$\n\n求最小的 $z$ 和对应的 $k$。如果有多组解，可以输出任意一组。", "inputFormat": "第一行两个正整数 $n, m (1 \\le n \\le 1\\ 000\\ 000, 1 \\le m \\le 10^{18})$，表示正整数的个数和操作的次数。\n\n第二行 $n$ 个正整数 $x_1, x_2, \\ldots, x_n (1 \\le x_i \\le 10^9)$。", "outputFormat": "输出两个正整数，分别表示 $k$ 和 $z$。", "hint": "\n\n![](https://szkopul.edu.pl/problemset/problem/3oC6jWN7HZAUhEGLlHdF_ci2/site/images/OI19/stu0.gif)\n\n\n对于 $35\\%$ 的数据，$n \\le 10\\ 000$；\n\n对于所有数据，$1 \\le n \\le 1\\ 000\\ 000, 1 \\le m \\le 10^{18},1 \\le x_i \\le 10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P3535", "type": "P", "difficulty": 4, "samples": [["11 13 5\n1 2\n1 3\n1 5\n3 5\n2 8\n4 11\n7 11\n6 10\n6 9\n2 3\n8 9\n5 9\n9 10", "3\n2 3\n5 9\n3 5"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "2012", "并查集", "POI（波兰）", "Special Judge"], "title": "[POI 2012] TOU-Tour de Byteotia", "background": null, "description": "**译自 POI 2012 Stage 2. Day 0「[Tour de Byteotia](https://szkopul.edu.pl/problemset/problem/mormqC6WwjeIiBpSNMhVbHni/site/?key=statement)」**\n\n给定一个 $n$ 个点、$m$ 条边的**无向图**，问最少删掉多少条边能使得编号小于等于 $k$ 的点都不在任何一条简单环上。", "inputFormat": "第一行包含三个整数 $n$、$m$、$k$，分别表示 $n$ 个节点， $m$ 条边，$k$ 意义见题面。\n\n接下来 $m$ 行，每行两个整数 $u$、$v$，表示一条由 $u$ 到 $v$ 的**双向边**。数据保证**没有重边**。", "outputFormat": "第一行一个整数 $cnt$，表示最少的删边数量；\n\n接下来 $cnt$ 行，每行输出两个正整数 $a,b$，表示删除 $a,b$ 之间的一条边。先输出编号小的点，再输出编号大的点。", "hint": "样例配图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gs7p4m5e.png)\n\n对于 $40\\%$ 的数据，$n \\le 1000$，$m \\le 5000$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^6$，$0 \\le m \\le 2\\times10^6$，$1 \\le k \\le n$，$1 \\le u \\lt v \\le n$。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2693)。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2012] TOU-Tour de Byteotia", "background": "", "description": "**Translated from POI 2012 Stage 2. Day 0 「[Tour de Byteotia](https://szkopul.edu.pl/problemset/problem/mormqC6WwjeIiBpSNMhVbHni/site/?key=statement)」.**\n\nGiven an undirected graph with $n$ vertices and $m$ edges, find the minimum number of edges to delete so that all vertices with indices less than or equal to $k$ are not on any simple cycle.", "inputFormat": "The first line contains three integers $n$, $m$, and $k$, denoting $n$ vertices, $m$ edges, and $k$ as defined above.\n\nThen follow $m$ lines, each containing two integers $u$ and $v$, representing an undirected edge between $u$ and $v$. It is guaranteed that there are no multiple edges.", "outputFormat": "The first line contains an integer $cnt$, the minimum number of edges to delete.\n\nThen output $cnt$ lines, each containing two positive integers $a$ and $b$, indicating that the edge between $a$ and $b$ is deleted. Output the smaller vertex first, then the larger one.", "hint": "The sample illustration is as follows.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gs7p4m5e.png)\n\nFor $40\\%$ of the testdata, $n \\le 1000$, $m \\le 5000$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^6$, $0 \\le m \\le 2\\times10^6$, $1 \\le k \\le n$, $1 \\le u \\lt v \\le n$.\n\nTranslated from [LibreOJ](https://loj.ac/p/2693).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2012] TOU-Tour de Byteotia", "background": null, "description": "**译自 POI 2012 Stage 2. Day 0「[Tour de Byteotia](https://szkopul.edu.pl/problemset/problem/mormqC6WwjeIiBpSNMhVbHni/site/?key=statement)」**\n\n给定一个 $n$ 个点、$m$ 条边的**无向图**，问最少删掉多少条边能使得编号小于等于 $k$ 的点都不在任何一条简单环上。", "inputFormat": "第一行包含三个整数 $n$、$m$、$k$，分别表示 $n$ 个节点， $m$ 条边，$k$ 意义见题面。\n\n接下来 $m$ 行，每行两个整数 $u$、$v$，表示一条由 $u$ 到 $v$ 的**双向边**。数据保证**没有重边**。", "outputFormat": "第一行一个整数 $cnt$，表示最少的删边数量；\n\n接下来 $cnt$ 行，每行输出两个正整数 $a,b$，表示删除 $a,b$ 之间的一条边。先输出编号小的点，再输出编号大的点。", "hint": "样例配图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gs7p4m5e.png)\n\n对于 $40\\%$ 的数据，$n \\le 1000$，$m \\le 5000$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^6$，$0 \\le m \\le 2\\times10^6$，$1 \\le k \\le n$，$1 \\le u \\lt v \\le n$。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2693)。", "locale": "zh-CN"}}}
{"pid": "P3536", "type": "P", "difficulty": 5, "samples": [["4\n1\n6\n8\n16\n3\n4\n2\n4", "3\n2\n4\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2012", "POI（波兰）"], "title": "[POI 2012] BON-Vouchers", "background": "", "description": "The candy shop owned by Byteasar sells delicious caramel candy.\n\nFor every positive integer $c$ there is exactly one package that contains $c$ candies; currently no new deliveries are expected.\n\nTo encourage customers to buy the sweets, Byteasar has planted $m$ vouchers for an annual supply of chocolate into some packages,  making sure to put at most one voucher in each package.\n\nThe carnival starts next week in Byteburg, and it will last $n$ days;  on the $k$-th day of the carnival a party with $a_k$ guests will be held.\n\nByteasar is confident that on the $k$-th day's morning each of those guests is going to buy, in his own store, the smallest package  of candy available whose content can be equally distributed between the party guests.  For example, if $n=2$, $a_1=4$, $a_2=2$,  then on the first day of the carnival he expects to sell the packages containing four, eight, twelve, and sixteen candies, selling  those with two and six candies on the second day.\n\nNow he is wondering which customers will end up with the packages holding the vouchers.\n\nHe has asked you to write a program that will determine this for him.\n\n定义n个数为幸运数字，一共有n批人，设第i批人有x个，则它们会依次取走余下的x的倍数中最小的x个，问哪些人去走了幸运数字\n", "inputFormat": "On the first line of the standard input there is a single integer $m$ ($1\\le m\\le 1\\ 000\\ 000$) that denotes the number of vouchers.\n\nThe $k$-th of the $m$ lines that follow holds an integer $b_k$ ($1\\le b_k\\le 1\\ 000\\ 000$)denoting the size (i.e., the number of candies inside) of a package in which Byteasar has placed the $k$-th voucher.\n\nThese numbers are given in an increasing order.\n\nThen the next line contains a single integer $n$ ($1\\le n\\le 1\\ 000\\ 000$) that denotes the number of carnival days.\n\nThe $k$-th of the $n$ lines that follow holds an integer $a_k$($1\\le a_k\\le 1\\ 000\\ 000$)denoting the number of guests attending the $k$-th party.\n\nYou may assume that in tests worth at least 50% of the total points none of the numbers given on the input exceeds $5\\ 000$.\n", "outputFormat": "In the first line of the standard output your program should print an integer $z$ - the number of packages with vouchers sold.\n\nThe following $z$ lines should specify the numbers of those customers who bought a package with a voucher, in an increasing order.\n\nThe customers are numbered from $1$ in the order of their purchases.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] BON-Vouchers", "background": "", "description": "The candy shop owned by Byteasar sells delicious caramel candy.\n\nFor every positive integer $c$ there is exactly one package that contains $c$ candies; currently no new deliveries are expected.\n\nTo encourage customers to buy the sweets, Byteasar has planted $m$ vouchers for an annual supply of chocolate into some packages,  making sure to put at most one voucher in each package.\n\nThe carnival starts next week in Byteburg, and it will last $n$ days;  on the $k$-th day of the carnival a party with $a_k$ guests will be held.\n\nByteasar is confident that on the $k$-th day's morning each of those guests is going to buy, in his own store, the smallest package  of candy available whose content can be equally distributed between the party guests.  For example, if $n=2$, $a_1=4$, $a_2=2$,  then on the first day of the carnival he expects to sell the packages containing four, eight, twelve, and sixteen candies, selling  those with two and six candies on the second day.\n\nNow he is wondering which customers will end up with the packages holding the vouchers.\n\nHe has asked you to write a program that will determine this for him.\n\n定义n个数为幸运数字，一共有n批人，设第i批人有x个，则它们会依次取走余下的x的倍数中最小的x个，问哪些人去走了幸运数字\n", "inputFormat": "On the first line of the standard input there is a single integer $m$ ($1\\le m\\le 1\\ 000\\ 000$) that denotes the number of vouchers.\n\nThe $k$-th of the $m$ lines that follow holds an integer $b_k$ ($1\\le b_k\\le 1\\ 000\\ 000$)denoting the size (i.e., the number of candies inside) of a package in which Byteasar has placed the $k$-th voucher.\n\nThese numbers are given in an increasing order.\n\nThen the next line contains a single integer $n$ ($1\\le n\\le 1\\ 000\\ 000$) that denotes the number of carnival days.\n\nThe $k$-th of the $n$ lines that follow holds an integer $a_k$($1\\le a_k\\le 1\\ 000\\ 000$)denoting the number of guests attending the $k$-th party.\n\nYou may assume that in tests worth at least 50% of the total points none of the numbers given on the input exceeds $5\\ 000$.\n", "outputFormat": "In the first line of the standard output your program should print an integer $z$ - the number of packages with vouchers sold.\n\nThe following $z$ lines should specify the numbers of those customers who bought a package with a voucher, in an increasing order.\n\nThe customers are numbered from $1$ in the order of their purchases.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] BON-Vouchers", "background": null, "description": "Byteasar 经营着一家焦糖店。\n\n对于所有正整数 $c$，Byteasar 都有且仅有一个装有 $c$ 个糖果的包裹。\n\nByteasar 准备了 $m$ 张代金券，并在装有 $b_i$ 个糖果的包裹里分别放入一张。\n\n现在共有 $n$ 批顾客，第 $i$ 批客人有 $a_i$ 人，且每名顾客会买走装有最少糖果的包裹，满足这些糖果可平均分给这一批的 $a_i$ 个人。例如，若 $n = 2, a_1 = 4, a_2 = 2$，则第一批顾客买走的糖果数量分别为  $4, 8, 12, 16$，第二批顾客买走的糖果数量分别为 $2, 6$。\n\n将所有顾客按顺序从 $1$ 开始编号，Byteasar 想知道取走代金券的顾客数量和各自的编号。", "inputFormat": "第一行输入一个整数 $m$ ($1 \\le m \\le 1\\ 000\\ 000$)，表示代金券总数。\n\n接下来 $m$ 行，输入 $m$ 个整数 $b_1,b_2,\\cdots, b_m$ ($1 \\le b_i \\le 1\\ 000\\ 000$)，分别代表放入代金券的包裹装有的糖果数量，保证 $b_i$ 单调递增。\n\n接下来输入一个整数 $n$ ($1 \\le n \\le 1\\ 000\\ 000$)，表示共有 $n$ 批顾客。\n\n接下来 $n$ 行，输入 $n$ 个整数 $a_1,a_2,\\cdots, a_n$ ($1 \\le a_i \\le 1\\ 000\\ 000$)，分别代表每批顾客的人数。\n\n对于不少于 $50\\%$ 的数据，保证输入的所有数字不超过 $5\\ 000$。", "outputFormat": "第一行一个整数 $z$，代表获得代金券的顾客数量。\n\n接下来 $z$ 行每行一个整数，从小到大输出获得代金券的顾客编号。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3537", "type": "P", "difficulty": 5, "samples": [["5\n6 2 7\n5 4 9\n1 2 4\n2 5 8\n1 3 9\n5\n2 7 1\n2 7 2\n3 2 0\n5 7 2\n4 1 5", "TAK\nNIE\nTAK\nTAK\nNIE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2012", "POI（波兰）"], "title": "[POI 2012] SZA-Cloakroom", "background": "", "description": "The annual rich citizen's reunion is taking place in Byteotia.\n\nThey meet to boast about their incomes, Lebytene's shoes and other luxuries.\n\nNaturally, not all these objects of pride are carried into the banquet - coats,  jackets, umbrellas and such are left in the cloakroom, and picked up upon leave.\n\nUnfortunately for the well off, a gang of Byteotian thieves plans to break into  the cloakroom and steal part of the items stored therein.\n\nAt this very moment the gang's leader is examining the plans of the robbery put  forward by other gang members (they are a democratic lot!).\n\nA plan typically looks as follows: the thieves break into the cloakroom at time $m_j$,  take items worth exactly $k_j$ and escape, where the whole heist takes them $s_j$ time.\n\nThe gang leader would first of all like to know which of these plans are feasible and which are not.\n\nA plan is feasible if at time $m_j$ it is possible to collect items of total value $k_j$ in such a way  that up to the very $m_j+s_j$ moment no one shows up to retrieve any of the stolen goods  (in such event, they would notify security, and the robbery would fail).\n\nIn particular, if at time $m_j$ it is impossible to select items of exact total worth $k_j$,  then the plan is infeasible and consequently rejected.\n\nKnowing the drop off and retrieval times for each item, determine which plans are feasible and which are not.\n\nWe assume that an item left in the cloakroom the moment a robbery starts can already be stolen (see the example).\n", "inputFormat": "In the first line of the standard input there is a single integer $n$($1\\le n\\le 1\\ 000$) denoting the number of items that will be left in the cloakroom.\n\nThose items are described in the $n$ lines that follow.\n\nEach of those lines consists of three integers $c_i$, $a_i$, and $b_i$ ($1\\le c_i\\le 1\\ 000$, $1\\le a_i<b_i\\le 10^9$),  separated by single spaces, that denote respectively: the item's value, the moment it is left in the cloakroom,  and the moment it will be retrieved by the owner.\n\nThe next line holds an integer $p$ ($1\\le p\\le 1\\ 000\\ 000$),the number of plans the gang came up with. Each is specified in a separate line by three integers,$m_j$,$k_j$ and $s_j$($1\\le m_j\\le 10^9$,$1\\le k_j\\le 100\\ 000$,$0\\le s_j\\le 10^9$), separated by single spaces, that denote respectively: the moment the thieves would enter the cloakroom, the value of goods they would like to steal, and the time the robbery would take them.\n\nIn test worth 16% of the total points $p\\le 10$ holds in addition.\n\nn some other tests, also worth 16% of the points, all the items have the same $a_i$ values.\n\nIn yet other tests, worth 24% of the points, all the queries share the same $s_j$ value.\n", "outputFormat": "For each plan put forward by the gang determine if it is feasible, i.e., whether it is possible  to steal items of total worth exactly $k_j$ and escape before anyone asks for their belongings.\n\nIf the plan is feasible, your program should print the word TAK (Polish for yes) on the  standard output, otherwise it should print NIE (Polish for no).\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] SZA-Cloakroom", "background": "", "description": "The annual rich citizen's reunion is taking place in Byteotia.\n\nThey meet to boast about their incomes, Lebytene's shoes and other luxuries.\n\nNaturally, not all these objects of pride are carried into the banquet - coats,  jackets, umbrellas and such are left in the cloakroom, and picked up upon leave.\n\nUnfortunately for the well off, a gang of Byteotian thieves plans to break into  the cloakroom and steal part of the items stored therein.\n\nAt this very moment the gang's leader is examining the plans of the robbery put  forward by other gang members (they are a democratic lot!).\n\nA plan typically looks as follows: the thieves break into the cloakroom at time $m_j$,  take items worth exactly $k_j$ and escape, where the whole heist takes them $s_j$ time.\n\nThe gang leader would first of all like to know which of these plans are feasible and which are not.\n\nA plan is feasible if at time $m_j$ it is possible to collect items of total value $k_j$ in such a way  that up to the very $m_j+s_j$ moment no one shows up to retrieve any of the stolen goods  (in such event, they would notify security, and the robbery would fail).\n\nIn particular, if at time $m_j$ it is impossible to select items of exact total worth $k_j$,  then the plan is infeasible and consequently rejected.\n\nKnowing the drop off and retrieval times for each item, determine which plans are feasible and which are not.\n\nWe assume that an item left in the cloakroom the moment a robbery starts can already be stolen (see the example).\n", "inputFormat": "In the first line of the standard input there is a single integer $n$($1\\le n\\le 1\\ 000$) denoting the number of items that will be left in the cloakroom.\n\nThose items are described in the $n$ lines that follow.\n\nEach of those lines consists of three integers $c_i$, $a_i$, and $b_i$ ($1\\le c_i\\le 1\\ 000$, $1\\le a_i<b_i\\le 10^9$),  separated by single spaces, that denote respectively: the item's value, the moment it is left in the cloakroom,  and the moment it will be retrieved by the owner.\n\nThe next line holds an integer $p$ ($1\\le p\\le 1\\ 000\\ 000$),the number of plans the gang came up with. Each is specified in a separate line by three integers,$m_j$,$k_j$ and $s_j$($1\\le m_j\\le 10^9$,$1\\le k_j\\le 100\\ 000$,$0\\le s_j\\le 10^9$), separated by single spaces, that denote respectively: the moment the thieves would enter the cloakroom, the value of goods they would like to steal, and the time the robbery would take them.\n\nIn test worth 16% of the total points $p\\le 10$ holds in addition.\n\nn some other tests, also worth 16% of the points, all the items have the same $a_i$ values.\n\nIn yet other tests, worth 24% of the points, all the queries share the same $s_j$ value.\n", "outputFormat": "For each plan put forward by the gang determine if it is feasible, i.e., whether it is possible  to steal items of total worth exactly $k_j$ and escape before anyone asks for their belongings.\n\nIf the plan is feasible, your program should print the word TAK (Polish for yes) on the  standard output, otherwise it should print NIE (Polish for no).\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] SZA-Cloakroom", "background": null, "description": "每年，Byteotia 举行富人聚会。\n\n他们聚在一起炫耀他们的收入、Lebytene 的鞋子和其他奢侈品。\n\n当然，并不是所有这些物品都会被带入宴会——大衣、夹克、雨伞等会被留在衣帽间，离开时再取走。\n\n不幸的是，一伙 Byteotia 小偷计划闯入衣帽间，偷走其中的一部分物品。\n\n此时此刻，团伙的头目正在审查其他团伙成员提出的抢劫计划（他们是民主的！）。\n\n计划通常如下：小偷在时间 $m_j$ 闯入衣帽间，拿走价值正好为 $k_j$ 的物品并逃跑，整个抢劫过程耗时 $s_j$。\n\n团伙头目首先想知道这些计划中哪些是可行的，哪些不可行。\n\n一个计划是可行的，当且仅当在时间 $m_j$ 可以收集总价值为 $k_j$ 的物品，并且直到 $m_j+s_j$ 时刻没有人出现取回任何被盗物品（在这种情况下，他们会通知保安，抢劫就会失败）。\n\n特别地，如果在时间 $m_j$ 不可能选择总价值正好为 $k_j$ 的物品，那么计划不可行，因此被拒绝。\n\n已知每件物品的存放和取回时间，确定哪些计划是可行的，哪些不可行。\n\n我们假设在抢劫开始的那一刻留在衣帽间的物品已经可以被偷走（见例子）。", "inputFormat": "输入的第一行有一个整数 $n$（$1\\le n\\le 1000$），表示将留在衣帽间的物品数量。\n\n接下来的 $n$ 行描述这些物品。\n\n每行由三个整数 $c_i$，$a_i$ 和 $b_i$（$1\\le c_i\\le 1\\ 000$, $1\\le a_i<b_i\\le 10^9$）组成，分别表示：物品的价值、存放在衣帽间的时刻以及将被主人取回的时刻。\n\n下一行包含一个整数 $p$（$1\\le p\\le 10^6$），表示团伙提出的计划数量。每行三个整数 $m_j$、$k_j$ 和 $s_j$（$1\\le m_j\\le 10^9$, $1\\le k_j\\le 10^5$, $0\\le s_j\\le 10^9$），分别表示一个计划中：小偷进入衣帽间的时刻、他们想要偷走的物品的价值以及抢劫所需的时间。\n\n对于 $16\\%$ 的数据，$p\\le 10$。\n\n对于另外 $16\\%$ 的数据，所有物品的 $a_i$ 相同。\n\n对于另外 $24\\%$ 的数据，所有查询的 $s_j$ 相同。", "outputFormat": "对于团伙提出的每个计划，确定它是否可行，即是否可以在不被任何人要求归还物品之前偷走总价值正好为 $k_j$ 的物品并逃跑。\n\n如果计划可行，程序需标准输出中打印单词 `TAK`（波兰语中的“是”），否则打印 `NIE`（波兰语中的“否”）。", "hint": "题面翻译由 ChatGPT-4o 提供，fixed by @tallnut。", "locale": "zh-CN"}}}
{"pid": "P3538", "type": "P", "difficulty": 6, "samples": [["8\naaabcabc\n3\n1 3\n3 8\n4 8", "1\n3\n5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2012", "POI（波兰）", "哈希 hashing"], "title": "[POI 2012] OKR-A Horrible Poem", "background": "", "description": "Byteie boy has to learn a fragment of a certain poem by heart. The poem, following the best lines of modern art, is a long string consisting of lowercase English alphabet letters only. Obviously, it sounds horrible, but that is the least of Byteie's worries. First and foremost, he completely forgot which fragment is he supposed to learn. And they all look quite difficult to memorize...\n\nThere is hope, however: some parts of the poem exhibit certain regularity. In particular, every now and then a fragment, say $A$, is but a multiple repetition of another fragment, say $B$ (in other words, $A = BB\\cdots B$, i.e., $A = B^k$, where $k\\geq1$ is an integer). In such case we say that $B$ is a full period of $A$ (in particular, every string is its own full period). If a given fragment has a short full period, Byteie's task will be easy. The question remains... which fragment was that?\n\nMake a gift for Byteie - write a program that will read the whole poem as well as a list of fragments that Byteie suspects might be the one he is supposed to memorize, and for each of them determines its shortest full period.", "inputFormat": "In the first line of the standard input there is a single integer $n$ ($1\\leq n\\leq500,000$). In the second line there is a string of length $n$ consisting of lowercase English alphabet letters - the poem. We number the positions of its successive characters from $1$ to $n$.\n\nThe next line holds a single integer $q$ ($1\\leq q\\leq2,000,000$) denoting the number of fragments. Then the following $q$ lines give queries, one per line. Each query is a pair of integers $a_i$ and $b_i$ ($1\\leq a_i\\leq b_i\\leq n$), separated by a single space, such that the answer to the query should be the length of the shortest full period of the poem's fragment that begins at position $a_i$ and ends at position $b_i$.\n\nIn tests worth in total 42% of the points $n\\leq10,000$ holds in addition. In some of those, worth 30% of points in total, $q\\leq10,000$ holds as well.", "outputFormat": "Your program should print $q$ lines on the standard output. The $i$ - th of these lines should hold a single integer - the answer to the $i$ - th query. ", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] OKR-A Horrible Poem", "background": "", "description": "Byteie boy has to learn a fragment of a certain poem by heart. The poem, following the best lines of modern art, is a long string consisting of lowercase English alphabet letters only. Obviously, it sounds horrible, but that is the least of Byteie's worries. First and foremost, he completely forgot which fragment is he supposed to learn. And they all look quite difficult to memorize...\n\nThere is hope, however: some parts of the poem exhibit certain regularity. In particular, every now and then a fragment, say $A$, is but a multiple repetition of another fragment, say $B$ (in other words, $A = BB\\cdots B$, i.e., $A = B^k$, where $k\\geq1$ is an integer). In such case we say that $B$ is a full period of $A$ (in particular, every string is its own full period). If a given fragment has a short full period, Byteie's task will be easy. The question remains... which fragment was that?\n\nMake a gift for Byteie - write a program that will read the whole poem as well as a list of fragments that Byteie suspects might be the one he is supposed to memorize, and for each of them determines its shortest full period.", "inputFormat": "In the first line of the standard input there is a single integer $n$ ($1\\leq n\\leq500,000$). In the second line there is a string of length $n$ consisting of lowercase English alphabet letters - the poem. We number the positions of its successive characters from $1$ to $n$.\n\nThe next line holds a single integer $q$ ($1\\leq q\\leq2,000,000$) denoting the number of fragments. Then the following $q$ lines give queries, one per line. Each query is a pair of integers $a_i$ and $b_i$ ($1\\leq a_i\\leq b_i\\leq n$), separated by a single space, such that the answer to the query should be the length of the shortest full period of the poem's fragment that begins at position $a_i$ and ends at position $b_i$.\n\nIn tests worth in total 42% of the points $n\\leq10,000$ holds in addition. In some of those, worth 30% of points in total, $q\\leq10,000$ holds as well.", "outputFormat": "Your program should print $q$ lines on the standard output. The $i$ - th of these lines should hold a single integer - the answer to the $i$ - th query. ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] OKR-A Horrible Poem", "background": null, "description": "Byteie 男孩需要背诵一首诗的某个片段。这首诗遵循现代艺术的最高标准，是一个仅由小写英文字母组成的长字符串。显然，它听起来很糟糕，但这还不是 Byteie 最担心的。首先，他完全忘记了自己该背诵哪个片段。而且所有片段看起来都很难记……\n\n不过仍有希望：诗中某些部分呈现出特定的规律性。特别是，时常会出现某个片段（记作 $A$）仅是另一个片段（记作 $B$）的多次重复（即 $A = BB\\cdots B$，可表示为 $A = B^k$，其中 $k\\geq1$ 为整数）。这种情况下，我们称 $B$ 是 $A$ 的一个**完整周期**（特别地，每个字符串都是其自身的完整周期）。如果一个片段存在很短的完整周期，Byteie 的任务就会变得简单。问题在于……到底是哪个片段呢？\n\n送给 Byteie 一份礼物吧——编写一个程序，它会读入整首诗以及 Byteie 怀疑可能需要背诵的片段列表，并针对每个片段找出其**最短的完整周期**", "inputFormat": "第一行：一个整数 $n$ ($1\\leq n\\leq500,000$)，表示诗的长度。\n\n第二行：一个长度为 $n$ 的字符串，表示诗的内容。字符串中字符的位置依次编号为 $1$ 到 $n$。\n\n第三行：一个整数 $q$ ($1\\leq q\\leq2,000,000$)，表示查询的片段数量。\n\n接下来的 $q$ 行：每行包含两个整数 $a_i$ 和 $b_i$ ($1\\leq a_i\\leq b_i\\leq n$)，用空格分隔。表示查询从位置 $a_i$ 开始到位置 $b_i$ 结束的诗的片段的最短完整周期的长度。\n\n在总计占比 $42\\%$ 分数的测试点中，额外满足 $n\\leq10,000$。其中占比 $30\\%$ 分数的测试点还满足 $q\\leq10,000$。", "outputFormat": "输出 $q$ 行到标准输出。第 $i$ 行输出一个整数，表示第 $i$ 个查询的答案。", "hint": "题面翻译由 deepseek-R1 提供。", "locale": "zh-CN"}}}
{"pid": "P3539", "type": "P", "difficulty": 6, "samples": [["1\n1070", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2012", "POI（波兰）"], "title": "[POI 2012] ROZ-Fibonacci Representation", "background": "", "description": "The Fibonacci sequence is a sequence of integers, called Fibonacci numbers, defined as follows:\n\n$Fib_{0}=0,Fib_{1}=1,Fib_{n}=Fib_{n-2}+Fib_{n-1}\\ for\\ n>1$\n\nIts initial elements are: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...\n\nByteasar investigates representations of numbers as sums or differences of Fibonacci numbers. Currently he is wondering what is the minimum representation, i.e., one with the minimum number of (not necessarily different) Fibonacci numbers, for a given positive integer $k$ . For example, the numbers 10, 19, 17, and 1070 can be minimally represented using, respectively, 2, 2, 3, and 4 Fibonacci numbers as follows:\n\n$10=5+5$\n\n$19=21-2$\n\n$17=13+5-1$\n\n$1070=987+89-5-1$\n\nHelp Byteasar! Write a program that, for a given positive integer $k$ determines the minimum number of Fibonacci numbers required to represent $k$ as their sum or difference.", "inputFormat": "In the first line of the standard input a single positive integer $p$ is given ($1\\le p\\le 10$) that denotes the number of queries. The following $p$ lines hold a single positive integer $k$ each ($1\\le k\\le 1\\times 10^{17}$).\n", "outputFormat": "For each query your program should print on the standard output the minimum number of Fibonacci numbers needed to represent the number $k$ as their sum or difference.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] ROZ-Fibonacci Representation", "background": "", "description": "The Fibonacci sequence is a sequence of integers, called Fibonacci numbers, defined as follows:\n\n$Fib_{0}=0,Fib_{1}=1,Fib_{n}=Fib_{n-2}+Fib_{n-1}\\ for\\ n>1$\n\nIts initial elements are: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...\n\nByteasar investigates representations of numbers as sums or differences of Fibonacci numbers. Currently he is wondering what is the minimum representation, i.e., one with the minimum number of (not necessarily different) Fibonacci numbers, for a given positive integer $k$ . For example, the numbers 10, 19, 17, and 1070 can be minimally represented using, respectively, 2, 2, 3, and 4 Fibonacci numbers as follows:\n\n$10=5+5$\n\n$19=21-2$\n\n$17=13+5-1$\n\n$1070=987+89-5-1$\n\nHelp Byteasar! Write a program that, for a given positive integer $k$ determines the minimum number of Fibonacci numbers required to represent $k$ as their sum or difference.", "inputFormat": "In the first line of the standard input a single positive integer $p$ is given ($1\\le p\\le 10$) that denotes the number of queries. The following $p$ lines hold a single positive integer $k$ each ($1\\le k\\le 1\\times 10^{17}$).\n", "outputFormat": "For each query your program should print on the standard output the minimum number of Fibonacci numbers needed to represent the number $k$ as their sum or difference.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] ROZ-Fibonacci Representation", "background": "", "description": "**译自 POI 2012 Stage 2. Day 2「[Rozkład Fibonacciego](https://szkopul.edu.pl/problemset/problem/w1QbhPufazp-sH6X-u4pTnNu/site/?key=statement)」**\n\n给定正整数 $k$，求用斐波那契数的和或差表示 $k$ 所需要的斐波那契数数量最小值，例如：\n- $10=5+5$\n- $19=21-2$\n- $17=13+5-1$\n- $1070=987+89-5-1$", "inputFormat": "第一行一个整数 $p (1 \\le p \\le 10)$ 表示询问的数量。\n\n接下来 $p$ 行每行一个整数 $k (1 \\le k \\le 4 \\cdot 10^{17})$。", "outputFormat": "对每个询问输出一个整数，表示最少需要的斐波那契数数量。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2697)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3540", "type": "P", "difficulty": 6, "samples": [["4\n3 5 4 7 6 5", "1\n1 2 3 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2012", "POI（波兰）", "Special Judge"], "title": "[POI 2012] SQU-Squarks", "background": "", "description": "A famous Byteotian physicist Byteasar is studying a new constituent of matter - squarks.\n\nThese are quite exotic particles that never exist alone but always in pairs.\n\nMoreover, squarks of a particular kind form pairs only with squarks of different kinds.\n\nAfter years of studies Byteasar has established that there are ![](http://main.edu.pl/images/OI19/squ-en-tex.1.png) different kinds of squarks.\n\nSquarks of each kind have a unique mass, which is a positive integer multiple of (an appropriate) unit.\n\nByteasar has also measured the total mass of each of the ![](http://main.edu.pl/images/OI19/squ-en-tex.2.png) possible pairs of squarks.\n\nAccording to standard Byteotian model of physics, the mass of a pair of squarks equals the sum of the masses    of the two squarks forming it.\n\nNow Byteasar desires to determine the individual masses of squarks of every kind.\n\nHe has asked your help in writing a program that will determine all solutions to this puzzle,    i.e., will reconstruct all configurations of squark masses that are consistent with his previous measurements.", "inputFormat": "In the first line of the standard input there is a single integer ![](http://main.edu.pl/images/OI19/squ-en-tex.3.png) (![](http://main.edu.pl/images/OI19/squ-en-tex.4.png))      that denotes the number of different kinds of squarks.\n\nIn the second line there are ![](http://main.edu.pl/images/OI19/squ-en-tex.5.png) positive integers, separated by single spaces,      that denote the total masses of all possible pairs of squarks.\n\nThe mass of every pair does not exceed ![](http://main.edu.pl/images/OI19/squ-en-tex.6.png).\n\nFor each two different kinds of squarks, the mass of the pair they form is given on the input exactly once.\n\n      The masses on the input are given in a random order.\n\nIn tests worth 32% of the points the following conditions hold in addition:\n\n![](http://main.edu.pl/images/OI19/squ-en-tex.7.png) and the mass of every pair of squarks does not exceed ![](http://main.edu.pl/images/OI19/squ-en-tex.8.png).\n", "outputFormat": "In the first line of the standard output your program should print the number ![](http://main.edu.pl/images/OI19/squ-en-tex.9.png) of possible solutions to the problem.\n\nIn the ![](http://main.edu.pl/images/OI19/squ-en-tex.10.png) lines that follow it should report successive solutions, one per line.\n\nEach solution should consist of ![](http://main.edu.pl/images/OI19/squ-en-tex.11.png) different positive integers, namely the masses of squarks of all kinds.\n\nIn every solution these should be given in increasing order and separated by single spaces.\n\nSolutions can be reported in arbitrary order, but they cannot be repeated.\n\nYou may assume that for each test data there exists at least one solution, i.e., ![](http://main.edu.pl/images/OI19/squ-en-tex.12.png).\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] SQU-Squarks", "background": "", "description": "A famous Byteotian physicist Byteasar is studying a new constituent of matter - squarks.\n\nThese are quite exotic particles that never exist alone but always in pairs.\n\nMoreover, squarks of a particular kind form pairs only with squarks of different kinds.\n\nAfter years of studies Byteasar has established that there are ![](http://main.edu.pl/images/OI19/squ-en-tex.1.png) different kinds of squarks.\n\nSquarks of each kind have a unique mass, which is a positive integer multiple of (an appropriate) unit.\n\nByteasar has also measured the total mass of each of the ![](http://main.edu.pl/images/OI19/squ-en-tex.2.png) possible pairs of squarks.\n\nAccording to standard Byteotian model of physics, the mass of a pair of squarks equals the sum of the masses    of the two squarks forming it.\n\nNow Byteasar desires to determine the individual masses of squarks of every kind.\n\nHe has asked your help in writing a program that will determine all solutions to this puzzle,    i.e., will reconstruct all configurations of squark masses that are consistent with his previous measurements.", "inputFormat": "In the first line of the standard input there is a single integer ![](http://main.edu.pl/images/OI19/squ-en-tex.3.png) (![](http://main.edu.pl/images/OI19/squ-en-tex.4.png))      that denotes the number of different kinds of squarks.\n\nIn the second line there are ![](http://main.edu.pl/images/OI19/squ-en-tex.5.png) positive integers, separated by single spaces,      that denote the total masses of all possible pairs of squarks.\n\nThe mass of every pair does not exceed ![](http://main.edu.pl/images/OI19/squ-en-tex.6.png).\n\nFor each two different kinds of squarks, the mass of the pair they form is given on the input exactly once.\n\n      The masses on the input are given in a random order.\n\nIn tests worth 32% of the points the following conditions hold in addition:\n\n![](http://main.edu.pl/images/OI19/squ-en-tex.7.png) and the mass of every pair of squarks does not exceed ![](http://main.edu.pl/images/OI19/squ-en-tex.8.png).\n", "outputFormat": "In the first line of the standard output your program should print the number ![](http://main.edu.pl/images/OI19/squ-en-tex.9.png) of possible solutions to the problem.\n\nIn the ![](http://main.edu.pl/images/OI19/squ-en-tex.10.png) lines that follow it should report successive solutions, one per line.\n\nEach solution should consist of ![](http://main.edu.pl/images/OI19/squ-en-tex.11.png) different positive integers, namely the masses of squarks of all kinds.\n\nIn every solution these should be given in increasing order and separated by single spaces.\n\nSolutions can be reported in arbitrary order, but they cannot be repeated.\n\nYou may assume that for each test data there exists at least one solution, i.e., ![](http://main.edu.pl/images/OI19/squ-en-tex.12.png).\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] SQU-Squarks", "background": "", "description": "**译自 POI 2012 Stage 3. Day 0「[Squarks](https://szkopul.edu.pl/problemset/problem/lo_jOsVfQ4ajCSHxFGZS27W-/site/?key=statement)」**\n\n给定 $n$ 个不同的正整数两两的和，求这 $n$ 个正整数的所有可能。", "inputFormat": "第一行一个正整数 $n (1 \\le n \\le 300)$，表示正整数的数量。\n\n接下来一行有 $\\frac{n(n-1)}2$ 个正整数，表示两两正整数的和，不超过 $10^8$，顺序随机。", "outputFormat": "第一行输出一个正整数 $k$，表示解的个数。\n\n接下来 $k$ 行每行按递增顺序输出 $n$ 个正整数，表示一组可能的解。\n\n可以以任意顺序输出解。保证存在一组解。", "hint": "对于 $32\\%$ 的数据保证 $n \\le 20$ 且任何两个正整数的和不超过 $2000$.\n\n对于所有数据保证 $n \\le 300$ 且任何两个正整数的和不超过 $10^8$.\n\n翻译与 checker 来自于 [LibreOJ](https://loj.ac/p/2698)。", "locale": "zh-CN"}}}
{"pid": "P3541", "type": "P", "difficulty": 6, "samples": [["7 3\n2 4 3 1 3 5 3\n< > =", "6\n2 4 3 3 5 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2010", "POI（波兰）", "Special Judge", "O2优化"], "title": "[POI 2010] Monotonicity", "background": "", "description": "**译自 POI 2010 Stage 3. Day 0「[Monotonicity](https://szkopul.edu.pl/problemset/problem/HVVwfLd9uyYNOW6hUZ_Zcnqe/site/?key=statement)」**\n\n对于一个整数序列 $a_1, a_2, \\cdots, a_n$，我们定义其“单调序列\"为一个由 $<$，$>$ 和 $=$ 组成的符号序列 $s_1, s_2, \\cdots,s_{n-1}$，其中符号 $s_i$ 表示 $a_i$ 和 $a_{i+1}$ 之间的关系。例如，数列 $2, 4, 3, 3, 5, 3$ 的单调序列为 $<, >, =, <, >$。\n\n对于整数序列 $b_1, b_2, \\cdots, b_{n+1}$ 以及其单调序列 $s_1, s_2, \\cdots, s_n$，如果符号序列 $s_1', s_2', \\cdots, s_k'$ 满足对所有 $1 \\le i \\le n$ 有 $s_i = s_{((i - 1) \\bmod n) + 1}'$，我们就说序列 $s_1, s_2, \\cdots, s_n$ 「实现」了序列 $s_1', s_2', \\cdots, s_k'$。也就是说，序列 $s_1, s_2, \\cdots, s_n$ 可以通过重复多次 $s_1', s_2', \\cdots, s_k'$ 序列并删除一个后缀得到。例如，整数数列 $2, 4, 3, 3, 5, 3$ 至少实现了以下符号序列：\n\n* $<, >, =$\n* $<, >, =, <, >$\n* $<, >, =, <, >, <, <, =$\n* $<, >, =, <, >, =, >, >$\n\n给定一个整数序列 $a_1, a_2, \\cdots, a_n$ 以及一个单调序列 $s_1, s_2, \\cdots, s_k$，求出原整数序列最长的子序列 $a_{i_1}, a_{i_2}, \\cdots, a_{i_m} (1 \\le i_1 \\lt i_2 \\lt \\cdots \\lt i_m \\le n)$ 使得前者的单调序列实现后者的符号序列。", "inputFormat": "第一行包含用空格分隔的两个整数 $n,k$，分别表示整数序列 $a_i$ 的长度和单调序列 $s_j$ 的长度。\n\n第二行包含用空格分隔的 $n$ 个整数，表示序列 $a_i$。\n\n第三行包含用空格分隔的 $k$ 个符号，表示符号序列 $s_j$。", "outputFormat": "第一行输出一个整数 $m$，表示序列 $a_1, a_2, \\cdots, a_n$ 的最长的「实现」了单调序列 $s_1, s_2, \\cdots, s_n$ 的子序列。\n\n第二行输出任意一个这样的子序列 $a_{i_1}, a_{i_2}, \\cdots, a_{i_n}$，元素之间用空格分隔。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 20000$，$1 \\le k \\le 100$，$1 \\le a_i \\le 1000000$，$s_j \\in \\{<, >, =\\}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2010] Monotonicity", "background": "", "description": "**译自 POI 2010 Stage 3. Day 0「[Monotonicity](https://szkopul.edu.pl/problemset/problem/HVVwfLd9uyYNOW6hUZ_Zcnqe/site/?key=statement)」**\n\n对于一个整数序列 $a_1, a_2, \\cdots, a_n$，我们定义其“单调序列\"为一个由 $<$，$>$ 和 $=$ 组成的符号序列 $s_1, s_2, \\cdots,s_{n-1}$，其中符号 $s_i$ 表示 $a_i$ 和 $a_{i+1}$ 之间的关系。例如，数列 $2, 4, 3, 3, 5, 3$ 的单调序列为 $<, >, =, <, >$。\n\n对于整数序列 $b_1, b_2, \\cdots, b_{n+1}$ 以及其单调序列 $s_1, s_2, \\cdots, s_n$，如果符号序列 $s_1', s_2', \\cdots, s_k'$ 满足对所有 $1 \\le i \\le n$ 有 $s_i = s_{((i - 1) \\bmod n) + 1}'$，我们就说序列 $s_1, s_2, \\cdots, s_n$ 「实现」了序列 $s_1', s_2', \\cdots, s_k'$。也就是说，序列 $s_1, s_2, \\cdots, s_n$ 可以通过重复多次 $s_1', s_2', \\cdots, s_k'$ 序列并删除一个后缀得到。例如，整数数列 $2, 4, 3, 3, 5, 3$ 至少实现了以下符号序列：\n\n* $<, >, =$\n* $<, >, =, <, >$\n* $<, >, =, <, >, <, <, =$\n* $<, >, =, <, >, =, >, >$\n\n给定一个整数序列 $a_1, a_2, \\cdots, a_n$ 以及一个单调序列 $s_1, s_2, \\cdots, s_k$，求出原整数序列最长的子序列 $a_{i_1}, a_{i_2}, \\cdots, a_{i_m} (1 \\le i_1 \\lt i_2 \\lt \\cdots \\lt i_m \\le n)$ 使得前者的单调序列实现后者的符号序列。", "inputFormat": "第一行包含用空格分隔的两个整数 $n,k$，分别表示整数序列 $a_i$ 的长度和单调序列 $s_j$ 的长度。\n\n第二行包含用空格分隔的 $n$ 个整数，表示序列 $a_i$。\n\n第三行包含用空格分隔的 $k$ 个符号，表示符号序列 $s_j$。", "outputFormat": "第一行输出一个整数 $m$，表示序列 $a_1, a_2, \\cdots, a_n$ 的最长的「实现」了单调序列 $s_1, s_2, \\cdots, s_n$ 的子序列。\n\n第二行输出任意一个这样的子序列 $a_{i_1}, a_{i_2}, \\cdots, a_{i_n}$，元素之间用空格分隔。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 20000$，$1 \\le k \\le 100$，$1 \\le a_i \\le 1000000$，$s_j \\in \\{<, >, =\\}$。", "locale": "zh-CN"}}}
{"pid": "P3542", "type": "P", "difficulty": 6, "samples": [["10\n2 2\n2 10\n1 0\n2 9\n2 5\n4 0\n6 0\n6 0\n5 0\n5 0", "2\n10\n1\n9\n5\n8\n0\n0\n0\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2012", "POI（波兰）", "深度优先搜索 DFS"], "title": "[POI 2012] PEN-Salaries", "background": "", "description": "The Byteotian Software Corporation (BSC) has $n$ employees.\n\nIn BSC's strict hierarchy, each employee has a direct supervisor, except the CEO, to whom all other BSC employees answer, directly or not.\n\nEach employee has a unique monthly salary, and all their salaries range from 1 to $n$ bythalers.\n\nEach supervisor earns more than each of their subordinates.\n\nAccording to Byteotian law, the salaries of employees on certain posts may be publicly disclosed.\n\nFurthermore, if the salary of an employee is disclosed, then the salary of their supervisor is also disclosed.\n\nThe Byteotian Internal Revenue Anti-Corruption Service (BIRAS) has decided to investigate BSC.\n\nBefore BIRAS enters BSC with a warrant, they intend to learn the salaries of all BSC employees    that are not disclosed but can be determined from those that are disclosed.", "inputFormat": "In the first line of the standard input a single integer $n$ ($1\\le n\\le 1\\ 000\\ 000$) is given that denotes the number of BSC employees.\n\nThe employees have id's that range from 1 to $n$.\n\nThe $n$ lines that follow provide information on these employees.\n\nThe line no. $i+1$ describes the employee no. $i$ by two integers $p_i$ and $z_i$ ($1\\le p_i\\le n$, $0\\le z_i\\le n$), separated by a single space.\n\nThe number $p_i$ is the id of the direct supervisor of the employee $i$.If $p_i=i$, then $i$ is the CEO of BSC. If $z_i>0$,then that is the salary of the employee $i$.If, on the other hand,$z_i=0$, then the salary of employee $i$ is not disclosed.Those $z_i$'s that are positive are also pairwise different.\n\nThe input data will always be such that there is at least one assignment of salaries to employees consistent with them, i.e., with the hierarchy and the partial assignment that they provide.\n\nIn tests worth 54% of the total points the condition $n\\le 10\\ 000$  holds in addition.\n", "outputFormat": "Your program should print $n$ lines to the standard output, each line holding a single integer.\n\nIf the employee $i$'s salary is disclosed or can be inferred from disclosed salaries, then the $i$-th line should hold employee $i$'s salary.\n\nOtherwise the $i$-th line should contain $0$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] PEN-Salaries", "background": "", "description": "The Byteotian Software Corporation (BSC) has $n$ employees.\n\nIn BSC's strict hierarchy, each employee has a direct supervisor, except the CEO, to whom all other BSC employees answer, directly or not.\n\nEach employee has a unique monthly salary, and all their salaries range from 1 to $n$ bythalers.\n\nEach supervisor earns more than each of their subordinates.\n\nAccording to Byteotian law, the salaries of employees on certain posts may be publicly disclosed.\n\nFurthermore, if the salary of an employee is disclosed, then the salary of their supervisor is also disclosed.\n\nThe Byteotian Internal Revenue Anti-Corruption Service (BIRAS) has decided to investigate BSC.\n\nBefore BIRAS enters BSC with a warrant, they intend to learn the salaries of all BSC employees    that are not disclosed but can be determined from those that are disclosed.", "inputFormat": "In the first line of the standard input a single integer $n$ ($1\\le n\\le 1\\ 000\\ 000$) is given that denotes the number of BSC employees.\n\nThe employees have id's that range from 1 to $n$.\n\nThe $n$ lines that follow provide information on these employees.\n\nThe line no. $i+1$ describes the employee no. $i$ by two integers $p_i$ and $z_i$ ($1\\le p_i\\le n$, $0\\le z_i\\le n$), separated by a single space.\n\nThe number $p_i$ is the id of the direct supervisor of the employee $i$.If $p_i=i$, then $i$ is the CEO of BSC. If $z_i>0$,then that is the salary of the employee $i$.If, on the other hand,$z_i=0$, then the salary of employee $i$ is not disclosed.Those $z_i$'s that are positive are also pairwise different.\n\nThe input data will always be such that there is at least one assignment of salaries to employees consistent with them, i.e., with the hierarchy and the partial assignment that they provide.\n\nIn tests worth 54% of the total points the condition $n\\le 10\\ 000$  holds in addition.\n", "outputFormat": "Your program should print $n$ lines to the standard output, each line holding a single integer.\n\nIf the employee $i$'s salary is disclosed or can be inferred from disclosed salaries, then the $i$-th line should hold employee $i$'s salary.\n\nOtherwise the $i$-th line should contain $0$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] PEN-Salaries", "background": "", "description": "**译自 POI 2012 Stage 3. Day 1「[Salaries](https://szkopul.edu.pl/problemset/problem/_qn633f6DVAHRkv0OX3LQaph/site/?key=statement)」**\n\n有一个 $n$ 个点的有根树，每个点的权值分别为 $1 \\ldots n$，且大于其儿子的权值。其中一部分点的权值是公开的，且每个权值已知的点的父亲权值也一定已知。求能够根据已知信息推算出来的权值未知的点的权值。", "inputFormat": "第一行一个整数 $n$，表示点的个数。\n\n接下来 $n$ 行每行两个整数 $p_i, z_i (1 \\le p_i \\le n,0 \\le z_i \\le n)$，其中 $p_i$ 表示结点 $i$ 的父亲，$z_i$ 表示结点 $i$ 的权值。如果 $z_i = 0$，则该点权值未知，否则该点权值为 $z_i$。", "outputFormat": "输出 $n$ 行，每行一个整数，表示 $i$ 点的权值。如果该点权值已知或可以推算出来，输出该点权值，否则输出 $0$。\n\n### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bjf4memv.png)", "hint": "对于 $54\\%$ 的数据有 $n \\le 10^4$.\n\n对于所有数据有 $1 \\le n \\le 10^6$。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2700)。", "locale": "zh-CN"}}}
{"pid": "P3543", "type": "P", "difficulty": 7, "samples": [["5 2 3\n1 2 1 1 -1", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2012", "POI（波兰）"], "title": "[POI 2012] WYR-Leveling Ground", "background": "", "description": "Byteasar has decided to build a house.\n\nHe has chosen a very narrow valley as its location.\n\nBefore Byteasar starts the actual construction work, he has to level the ground first.\n\nHe has two excavators at his disposal: the first one can either increase or decrease the  ground level of any connected area in the valley by exactly ![](http://main.edu.pl/images/OI19/wyr-en-tex.1.png) meters;  the other can do the same, i.e., either increase or decrease the  ground level of any connected area in the valley, but by exactly ![](http://main.edu.pl/images/OI19/wyr-en-tex.2.png) meters.\n\nNotice that neither before such an operation nor after it needs the ground in the affected  area be actually leveled.\n\nGiven a map of the area, determine the minimum number of operations required to  level the ground in the whole valley, i.e., to make the ground level everywhere  equal 0.  While the operations are performed, the ground level at any point in  the valley can have arbitrary value; in particular, it may be negative.", "inputFormat": "In the first line of the standard input there are three integers, ![](http://main.edu.pl/images/OI19/wyr-en-tex.3.png), ![](http://main.edu.pl/images/OI19/wyr-en-tex.4.png), ![](http://main.edu.pl/images/OI19/wyr-en-tex.5.png)    (![](http://main.edu.pl/images/OI19/wyr-en-tex.6.png), ![](http://main.edu.pl/images/OI19/wyr-en-tex.7.png)), separated by single spaces.\n\nThe number ![](http://main.edu.pl/images/OI19/wyr-en-tex.8.png) denotes the valley's length in meters.\n\nThe second line contains ![](http://main.edu.pl/images/OI19/wyr-en-tex.9.png) integers, ![](http://main.edu.pl/images/OI19/wyr-en-tex.10.png), separated by single spaces.\n\nThese numbers, all with absolute value no larger than ![](http://main.edu.pl/images/OI19/wyr-en-tex.11.png), represent the initial ground level in meters    of successive one meter long slices of the valley.\n\nIn tests worth 30% of the points the following conditions hold in addition: ![](http://main.edu.pl/images/OI19/wyr-en-tex.12.png) and   ![](http://main.edu.pl/images/OI19/wyr-en-tex.13.png).\n\nIn tests worth 60% of the points the following conditions hold in addition: ![](http://main.edu.pl/images/OI19/wyr-en-tex.14.png) and   ![](http://main.edu.pl/images/OI19/wyr-en-tex.15.png).\n\nIn tests worth 90% of the points the condition ![](http://main.edu.pl/images/OI19/wyr-en-tex.16.png) holds in addition.\n", "outputFormat": "In the first and only line of the standard output your program should print a single    integer: the minimum number of operations required to level the ground in the whole valley,    or ![](http://main.edu.pl/images/OI19/wyr-en-tex.17.png) if leveling the whole valley with given excavators is impossible.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] WYR-Leveling Ground", "background": "", "description": "Byteasar has decided to build a house.\n\nHe has chosen a very narrow valley as its location.\n\nBefore Byteasar starts the actual construction work, he has to level the ground first.\n\nHe has two excavators at his disposal: the first one can either increase or decrease the  ground level of any connected area in the valley by exactly ![](http://main.edu.pl/images/OI19/wyr-en-tex.1.png) meters;  the other can do the same, i.e., either increase or decrease the  ground level of any connected area in the valley, but by exactly ![](http://main.edu.pl/images/OI19/wyr-en-tex.2.png) meters.\n\nNotice that neither before such an operation nor after it needs the ground in the affected  area be actually leveled.\n\nGiven a map of the area, determine the minimum number of operations required to  level the ground in the whole valley, i.e., to make the ground level everywhere  equal 0.  While the operations are performed, the ground level at any point in  the valley can have arbitrary value; in particular, it may be negative.", "inputFormat": "In the first line of the standard input there are three integers, ![](http://main.edu.pl/images/OI19/wyr-en-tex.3.png), ![](http://main.edu.pl/images/OI19/wyr-en-tex.4.png), ![](http://main.edu.pl/images/OI19/wyr-en-tex.5.png)    (![](http://main.edu.pl/images/OI19/wyr-en-tex.6.png), ![](http://main.edu.pl/images/OI19/wyr-en-tex.7.png)), separated by single spaces.\n\nThe number ![](http://main.edu.pl/images/OI19/wyr-en-tex.8.png) denotes the valley's length in meters.\n\nThe second line contains ![](http://main.edu.pl/images/OI19/wyr-en-tex.9.png) integers, ![](http://main.edu.pl/images/OI19/wyr-en-tex.10.png), separated by single spaces.\n\nThese numbers, all with absolute value no larger than ![](http://main.edu.pl/images/OI19/wyr-en-tex.11.png), represent the initial ground level in meters    of successive one meter long slices of the valley.\n\nIn tests worth 30% of the points the following conditions hold in addition: ![](http://main.edu.pl/images/OI19/wyr-en-tex.12.png) and   ![](http://main.edu.pl/images/OI19/wyr-en-tex.13.png).\n\nIn tests worth 60% of the points the following conditions hold in addition: ![](http://main.edu.pl/images/OI19/wyr-en-tex.14.png) and   ![](http://main.edu.pl/images/OI19/wyr-en-tex.15.png).\n\nIn tests worth 90% of the points the condition ![](http://main.edu.pl/images/OI19/wyr-en-tex.16.png) holds in addition.\n", "outputFormat": "In the first and only line of the standard output your program should print a single    integer: the minimum number of operations required to level the ground in the whole valley,    or ![](http://main.edu.pl/images/OI19/wyr-en-tex.17.png) if leveling the whole valley with given excavators is impossible.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] WYR-Leveling Ground", "background": "", "description": "**译自 POI 2012 Stage 3. Day 1「[Leveling Ground](https://szkopul.edu.pl/problemset/problem/W54iZIwStF1TYWRxa1bdVPQo/site/?key=statement)」**\n\n给定一个长度为 $n$ 的数组，每次操作可以将一个区间的数增加或减少 $a$，或将一个区间的数增加或减少 $b$。求使整个数组变为 $0$ 的最小操作次数。若无解请输出 $-1$。", "inputFormat": "第一行三个整数 $n, a, b (1 \\le n \\le 100\\ 000, 1 \\le a,b \\le 10^9)$。\n\n接下来一行 $n$ 个整数 $h_1, h_2, \\ldots, h_n$，绝对值均不超过 $10^9$。", "outputFormat": "输出一行一个整数，表示最小操作次数。\n\n### 样例解释\n\n一种操作方案是：\n* 将前两个数加 $2$；\n* 将前两个数减 $3$；\n* 将后四个数加 $2$；\n* 将最后一个数加 $2$；\n* 将后四个数减 $3$。", "hint": "对于 $30\\%$ 的数据，$n,a,b \\le 200,-200 \\le h_1,h_2,\\ldots,h_n \\le 200$.\n\n对于 $60\\%$ 的数据，$n,a,b \\le 2000,-2000 \\le h_1,h_2,\\ldots,h_n \\le 2000$.\n\n对于 $90\\%$ 的数据，$a,b \\le 10^6$.\n\n对于所有数据，$1 \\le n \\le 100\\ 000, 1 \\le a,b \\le 10^9$.\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2701)。", "locale": "zh-CN"}}}
{"pid": "P3544", "type": "P", "difficulty": 6, "samples": [["3 2\n5 10 5\n1 2 5\n2 3 3", "12 15"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2012", "POI（波兰）", "广度优先搜索 BFS"], "title": "[POI 2012] BEZ-Minimalist Security", "background": "", "description": "A map of Mafiatown's road network is given.\n\nThe network consists of intersections and bidirectional streets that connect them.\n\nThe streets cross only at the intersections, but they may lead through tunnels or flyovers.\n\nEach pair of intersections is linked by at most one street.\n\nAt every intersection $v$ there is a police station manned by $p(v)$ policemen.\n\nA street linking the intersections $u$ and $v$ is considered safe if there are at least $b(u,v)$ policemen in total in the two stations at the streets ends. Initially    $p(u)+p(v)\\ge b(u,v)$ holds for every street.\n\nHowever, due to an ongoing crisis the mayor Byteasar has ordained the Minimalist Security Act (MSA), which states that:\n\na certain number (which may be zero) of policemen is to be laid off from each police station        (we denote the number of policemen laid off from the station at the intersection $v$ by $z(v)$),                  after the layoff, the total number of the policemen at both ends of every street connecting some two intersections,        say $u$ and $v$, should equal $b(u,v)$ exactly, i.e.:\n\n$p(u)-z(u)+p(v)-z(v)=b(u,v)$ These rules do not determine uniquely how many policemen are to be laid off.\n\nByteasar wonders what is the minimum and the maximum number of laid off policemen    (the sum of $z$ values over all intersections) that complies with aforementioned rules.", "inputFormat": "In the first line of the standard input there are two integers, $n$ and $m$ ($1\\le n\\le 500\\ 000$, $0\\le m\\le 3\\ 000\\ 000$), separated by a single space, that denote    the number of intersections and the number of streets in Mafiatown, respectively.\n\nThe intersections are numbered from 1 to $n$.\n\nIn the second line $n$ nonnegative integers separated by single spaces are given.\n\nThese are the numbers of policemen currently employed at successive stations, i.e., the values $p(1),p(2),\\cdots,p(n)$($0\\le p(i)\\le 10^6$).\n\nEach of the following $m$ lines describes a single bidirectional street. Such description consists of three integers,$u_i,v_i,b(u_i,v_i)$($1\\le u_i,v_i\\le n$,$u_i\\ne v_i$,$0\\le b(u_i,v_i)\\le 10^6$), separated by single spaces, that denote respectively: the numbers of the intersections at the ends of the street and the minimum total number of policemen that have to man the stations at those intersections.\n", "outputFormat": "If Byteasar's ordinance can be carried out, your program should print, on the standard output,    exactly one line with two integers separated by a single space.\n\nThe numbers should be the minimum and the maximum number of policemen that should be laid off    in order to carry out the ordinance.\n\nIf carrying out the ordinance is impossible, your program should print a single line containing    the word NIE (Polish for no).\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2012] BEZ-Minimalist Security", "background": "", "description": "A map of Mafiatown's road network is given.\n\nThe network consists of intersections and bidirectional streets that connect them.\n\nThe streets cross only at the intersections, but they may lead through tunnels or flyovers.\n\nEach pair of intersections is linked by at most one street.\n\nAt every intersection $v$ there is a police station manned by $p(v)$ policemen.\n\nA street linking the intersections $u$ and $v$ is considered safe if there are at least $b(u,v)$ policemen in total in the two stations at the streets ends. Initially    $p(u)+p(v)\\ge b(u,v)$ holds for every street.\n\nHowever, due to an ongoing crisis the mayor Byteasar has ordained the Minimalist Security Act (MSA), which states that:\n\na certain number (which may be zero) of policemen is to be laid off from each police station        (we denote the number of policemen laid off from the station at the intersection $v$ by $z(v)$),                  after the layoff, the total number of the policemen at both ends of every street connecting some two intersections,        say $u$ and $v$, should equal $b(u,v)$ exactly, i.e.:\n\n$p(u)-z(u)+p(v)-z(v)=b(u,v)$ These rules do not determine uniquely how many policemen are to be laid off.\n\nByteasar wonders what is the minimum and the maximum number of laid off policemen    (the sum of $z$ values over all intersections) that complies with aforementioned rules.", "inputFormat": "In the first line of the standard input there are two integers, $n$ and $m$ ($1\\le n\\le 500\\ 000$, $0\\le m\\le 3\\ 000\\ 000$), separated by a single space, that denote    the number of intersections and the number of streets in Mafiatown, respectively.\n\nThe intersections are numbered from 1 to $n$.\n\nIn the second line $n$ nonnegative integers separated by single spaces are given.\n\nThese are the numbers of policemen currently employed at successive stations, i.e., the values $p(1),p(2),\\cdots,p(n)$($0\\le p(i)\\le 10^6$).\n\nEach of the following $m$ lines describes a single bidirectional street. Such description consists of three integers,$u_i,v_i,b(u_i,v_i)$($1\\le u_i,v_i\\le n$,$u_i\\ne v_i$,$0\\le b(u_i,v_i)\\le 10^6$), separated by single spaces, that denote respectively: the numbers of the intersections at the ends of the street and the minimum total number of policemen that have to man the stations at those intersections.\n", "outputFormat": "If Byteasar's ordinance can be carried out, your program should print, on the standard output,    exactly one line with two integers separated by a single space.\n\nThe numbers should be the minimum and the maximum number of policemen that should be laid off    in order to carry out the ordinance.\n\nIf carrying out the ordinance is impossible, your program should print a single line containing    the word NIE (Polish for no).\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2012] BEZ-Minimalist Security", "background": "", "description": "**译自 POI 2012 Stage 3. Day 2「[Bezpieczeństwo minimalistyczne](https://szkopul.edu.pl/problemset/problem/aSbIC_LB4H-CGMYPEVue5jFw/site/?key=statement)」**\n\n给定一张无向图，点有点权 $p(v)$，边有边权 $b(u,v)$，初始时保证对每条边有 $p(u) + p(v) \\ge b(u,v)$。\n\n现在需要减少一部分点的点权（减少后必须是非负整数），使得对每条边都恰有 $p(u) + p(v) = b(u,v)$.\n\n求整张图减少的点权和的最小值和最大值。", "inputFormat": "第一行两个整数 $n$ 和 $m$（$1 \\le n \\le 500\\ 000,0 \\le m \\le 3\\ 000\\ 000$），表示图的点数和边数。\n\n接下来一行 $n$ 个非负整数 $p(1),p(2),\\ldots,p(n) (0 \\le p(i) \\le 10^6)$，表示点权。\n\n接下来 $m$ 行每行三个整数 $u_i, v_i, b(u_i, v_i)$（$1 \\le u_i,v_i \\le n,u_i \\neq v_i,0 \\le b(u_i,v_i) \\le 10^6$），表示边和边权。", "outputFormat": "如果存在符合条件的方案，输出一行两个整数，表示整张图减少的点权和的最小值和最大值。\n\n如果不存在，输出 `NIE`.", "hint": "对于 $56\\%$ 的数据有 $n \\le 2000,m \\le 8000$.\n\n对于所有数据有 $1 \\le n \\le 500\\ 000,0 \\le m \\le 3\\ 000\\ 000$.\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2702)。", "locale": "zh-CN"}}}
{"pid": "P3545", "type": "P", "difficulty": 5, "samples": [["6\n2 2 1 2 1 0\n1 2 2 3 4 4", "3\n1 2 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2012", "POI（波兰）", "Special Judge", "反悔贪心"], "title": "[POI 2012] HUR-Warehouse Store", "background": null, "description": "现在有 $n$ 天。第 $i$ 天上午会进货 $A_i$ 件商品，中午的时候会有顾客需要购买 $B_i$ 件商品，可以选择满足顾客的要求，或是无视掉他。\n\n如果要满足顾客的需求，就必须要有足够的库存。问最多能够满足多少个顾客的需求。", "inputFormat": "第一行包含一个整数 $n$，表示有 $n$ 天。\n\n第二行有 $n$ 个整数 $a_i$，表示第 $i$ 天上午进货 $a$ 件商品。\n\n第三行包含 $n$ 个整数 $b_i$，表示在第 $i$ 天中午有顾客来买 $b$ 件商品。", "outputFormat": "第一行一个整数，表示最多能满足几天中顾客的需求。\n\n\n第二行输出最多能够满足哪些天顾客的需求。如果有多种方案，输出任意一种即可。", "hint": "对于 $100\\%$ 的数据，$1\\leqslant n\\leqslant 2.5\\times 10^5$，$0\\leqslant a_i,b_i \\leqslant 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2012] HUR-Warehouse Store", "background": "", "description": "There are $n$ days. On the morning of day $i$, $A_i$ items arrive. At noon of day $i$, a customer wants to buy $B_i$ items; you may either fulfill the customer's request or ignore it.\n\nTo fulfill the customer's request, you must have enough inventory. What is the maximum number of days whose customer requests can be fulfilled?", "inputFormat": "The first line contains an integer $n$, the number of days.\n\nThe second line contains $n$ integers $a_i$, where $a_i$ is the number of items arriving on the morning of day $i$.\n\nThe third line contains $n$ integers $b_i$, where $b_i$ is the number of items a customer wants to buy at noon of day $i$.", "outputFormat": "The first line contains a single integer: the maximum number of days whose customer requests can be fulfilled.\n\nThe second line outputs one such set of days that achieves the maximum. If there are multiple solutions, output any one of them.", "hint": "For $100\\%$ of the testdata, $1 \\leqslant n \\leqslant 2.5 \\times 10^5$, $0 \\leqslant a_i, b_i \\leqslant 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2012] HUR-Warehouse Store", "background": null, "description": "现在有 $n$ 天。第 $i$ 天上午会进货 $A_i$ 件商品，中午的时候会有顾客需要购买 $B_i$ 件商品，可以选择满足顾客的要求，或是无视掉他。\n\n如果要满足顾客的需求，就必须要有足够的库存。问最多能够满足多少个顾客的需求。", "inputFormat": "第一行包含一个整数 $n$，表示有 $n$ 天。\n\n第二行有 $n$ 个整数 $a_i$，表示第 $i$ 天上午进货 $a$ 件商品。\n\n第三行包含 $n$ 个整数 $b_i$，表示在第 $i$ 天中午有顾客来买 $b$ 件商品。", "outputFormat": "第一行一个整数，表示最多能满足几天中顾客的需求。\n\n\n第二行输出最多能够满足哪些天顾客的需求。如果有多种方案，输出任意一种即可。", "hint": "对于 $100\\%$ 的数据，$1\\leqslant n\\leqslant 2.5\\times 10^5$，$0\\leqslant a_i,b_i \\leqslant 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3546", "type": "P", "difficulty": 6, "samples": [["15\nababbabababbaab", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["字符串", "2012", "POI（波兰）", "哈希 hashing", "线性递推", "KMP 算法"], "title": "[POI 2012] PRE-Prefixuffix", "background": null, "description": "对于两个串 $S_1, S_2$，如果能够将 $S_1$ 的一个后缀移动到开头后变成 $S_2$，就称 $S_1$ 和 $S_2$ 循环相同。例如串 $\\tt ababba$ 和串 $\\tt abbaab$ 是循环相同的。\n\n给出一个长度为 $n$ 的串 $S$，求满足下面条件的最大的 $L(L\\leq \\frac n 2)$：$S$ 的 $L$ 前缀和 $S$ 的 $L$ 后缀是循环相同的。", "inputFormat": "第一行包含一个正整数 $n$，表示字符串 $t$ 的长度。\n\n第二行包含一个由 $n$ 个小写字母构成的字符串 $t$。", "outputFormat": "一行一个整数，表示最大的 $L$。", "hint": "数据范围：\n\n- 对于 $30\\%$ 的数据，保证 $n\\le 500$；\n- 对于 $50\\%$ 的数据，保证 $n\\le 5000$；\n- 对于 $100\\%$ 数据，保证 $1\\le n\\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2012] PRE-Prefixuffix", "background": null, "description": "We consider strings consisting of lowercase letters of the English alphabet in this problem. An initial fragment of a given string is called its prefix. A final (terminal) fragment of a given string is called its suffix. In particular, the empty string is both a prefix and a suffix of any string. Two strings are cyclically equivalent if one of them can be obtained from another by moving its certain suffix from the end of the string to its beginning. For example, the strings ababba and abbaab are cyclically equivalent, whereas the strings ababba and ababab are not. In particular, every string is cyclically equivalent to itself.\n\nA string $t$ consisting of $n$ letters is given. We are looking for its prefix $p$ and suffix $s$ of equal length such that:\n\n- $p$ and $s$ are cyclically equivalent,\n- the common length of $p$ and $s$ does not exceed (i.e., the prefix $p$ and the suffix $s$ do not overlap in $t$), and\n- the common length of $p$ and $s$ is maximized.", "inputFormat": "The first line of the standard input contains a single integer $n$ ($1 \\le n \\le 10^6$) denoting the length of the string $t$.\n\nThe second line of input contains the string $t$ itself, consisting of $n$ lowercase letters of the English alphabet.", "outputFormat": "Your program should print a single integer in the first and only line of the standard output, namely the common length of the prefix $p$ and the suffix $s$ that we are looking for.", "hint": "In tests worth $30\\%$ of the points the condition $n \\le 500$ holds in addition.\n\nIn tests worth $50\\%$ of the points the condition $n \\le 5000$ holds in addition.", "locale": "en"}, "zh-CN": {"title": "[POI 2012] PRE-Prefixuffix", "background": null, "description": "对于两个串 $S_1, S_2$，如果能够将 $S_1$ 的一个后缀移动到开头后变成 $S_2$，就称 $S_1$ 和 $S_2$ 循环相同。例如串 $\\tt ababba$ 和串 $\\tt abbaab$ 是循环相同的。\n\n给出一个长度为 $n$ 的串 $S$，求满足下面条件的最大的 $L(L\\leq \\frac n 2)$：$S$ 的 $L$ 前缀和 $S$ 的 $L$ 后缀是循环相同的。", "inputFormat": "第一行包含一个正整数 $n$，表示字符串 $t$ 的长度。\n\n第二行包含一个由 $n$ 个小写字母构成的字符串 $t$。", "outputFormat": "一行一个整数，表示最大的 $L$。", "hint": "数据范围：\n\n- 对于 $30\\%$ 的数据，保证 $n\\le 500$；\n- 对于 $50\\%$ 的数据，保证 $n\\le 5000$；\n- 对于 $100\\%$ 数据，保证 $1\\le n\\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P3547", "type": "P", "difficulty": 7, "samples": [["5 5 1 3 2\n1 2\n2 3\n3 4\n4 5\n3 1\n", "0\n3\n3\n2\n5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2013", "POI（波兰）", "广度优先搜索 BFS"], "title": "[POI 2013] CEN-Price List", "background": "", "description": "Railway has always been the most popular mean of transport in Byteotia.\n\nOut of $n$ towns in the land, $m$ pairs are connected by track segments    belonging to Byteotian State Railways (BSR).\n\nThe tracks do not cross outside of towns, and may lead through picturesque    bridges and somewhat less picturesque tunnels.\n\nThe ticket for travelling between any two towns    directly connected by rail costs $a$ bythalers.\n\nCurrently the transportation market in Byteotia is changing.\n\nAs of now, BSR faces a new competitor: Byteotian Airlines (BA).\n\nBA plans to operate flights between some pairs of towns.\n\nSince Byteotian railways are quite comfortable, the BA board has decided to    operate flights only between pairs of towns that are not directly    connected by rail.  Due to economy, BA will fly only between towns    for which the cheapest railway connection requires exactly one change.\n\nThe ticket for each such flight is going to cost $b$ bythalers.\n\nTo help Byteotian citizens in planning their trips, the Byteotian    Ministry for Transport (BMT) has decided to issue leaflets specifying the    cheapest routes between all possible towns.  A sequence of an    arbitrary number of direct railway or airplane connections is    called a route.  A BMT officer by the name of Byteasar has been    commissioned with the task of preparing the price list for the leaflets.\n\nCould you help him in writing a program that will determine the right    prices?\n\nLet us clarify that all the connections in Byteotia, both by railway and    airplane, are bidirectional.\n", "inputFormat": "The first line of the standard input contains five integers,$n$,$m$,$k$,$a$ and $b$ ($2\\le n\\le 100\\ 000$, $\\le m\\le 100\\ 000$, $1\\le k\\le n$, $1\\le a,b\\le 1\\ 000$),      separated by single spaces.\n\nThe numbers $n$ and $m$ denote the number of towns and the number of      direct railway connections in Byteotia, respectively.\n\nFor simplicity, we number the towns in Byteotia from $1$ to $n$. The other numbers denote:$k$ - the number of the source town for which the connection prices are to be determined;$a$ - the price of a direct railway connection;$b$ - the price of a direct airplane connection.\n\nEach of the following $m$ lines contains a pair of integers $u_i$ and $v_i$($1\\le u_i,v_i\\le n$,$u_i\\ne v_i$ for $i=1,2,\\cdots,m$), separated by a single space, specifying the number of towns directly connected by tracks.\n\n\nYou may assume that all towns are reachable by railway from the town no. $k$.\n", "outputFormat": "Your program should print $n$ lines to the standard output.\n\nThe line no. $i$ (for $i=1,2,\\cdots,n$) should contain a single integer:\n\nthe cost of the cheapest route from town no. $k$ to town no. $i$.\n\nAmong those, the line no. $k$ should contain the number $0$.\n", "hint": "\n\n------------\n\n2024/2/4 添加了一部分来自 bzoj 的数据。", "locale": "en", "translations": {"en": {"title": "[POI 2013] CEN-Price List", "background": "", "description": "Railway has always been the most popular mean of transport in Byteotia.\n\nOut of $n$ towns in the land, $m$ pairs are connected by track segments    belonging to Byteotian State Railways (BSR).\n\nThe tracks do not cross outside of towns, and may lead through picturesque    bridges and somewhat less picturesque tunnels.\n\nThe ticket for travelling between any two towns    directly connected by rail costs $a$ bythalers.\n\nCurrently the transportation market in Byteotia is changing.\n\nAs of now, BSR faces a new competitor: Byteotian Airlines (BA).\n\nBA plans to operate flights between some pairs of towns.\n\nSince Byteotian railways are quite comfortable, the BA board has decided to    operate flights only between pairs of towns that are not directly    connected by rail.  Due to economy, BA will fly only between towns    for which the cheapest railway connection requires exactly one change.\n\nThe ticket for each such flight is going to cost $b$ bythalers.\n\nTo help Byteotian citizens in planning their trips, the Byteotian    Ministry for Transport (BMT) has decided to issue leaflets specifying the    cheapest routes between all possible towns.  A sequence of an    arbitrary number of direct railway or airplane connections is    called a route.  A BMT officer by the name of Byteasar has been    commissioned with the task of preparing the price list for the leaflets.\n\nCould you help him in writing a program that will determine the right    prices?\n\nLet us clarify that all the connections in Byteotia, both by railway and    airplane, are bidirectional.\n", "inputFormat": "The first line of the standard input contains five integers,$n$,$m$,$k$,$a$ and $b$ ($2\\le n\\le 100\\ 000$, $\\le m\\le 100\\ 000$, $1\\le k\\le n$, $1\\le a,b\\le 1\\ 000$),      separated by single spaces.\n\nThe numbers $n$ and $m$ denote the number of towns and the number of      direct railway connections in Byteotia, respectively.\n\nFor simplicity, we number the towns in Byteotia from $1$ to $n$. The other numbers denote:$k$ - the number of the source town for which the connection prices are to be determined;$a$ - the price of a direct railway connection;$b$ - the price of a direct airplane connection.\n\nEach of the following $m$ lines contains a pair of integers $u_i$ and $v_i$($1\\le u_i,v_i\\le n$,$u_i\\ne v_i$ for $i=1,2,\\cdots,m$), separated by a single space, specifying the number of towns directly connected by tracks.\n\n\nYou may assume that all towns are reachable by railway from the town no. $k$.\n", "outputFormat": "Your program should print $n$ lines to the standard output.\n\nThe line no. $i$ (for $i=1,2,\\cdots,n$) should contain a single integer:\n\nthe cost of the cheapest route from town no. $k$ to town no. $i$.\n\nAmong those, the line no. $k$ should contain the number $0$.\n", "hint": "\n\n------------\n\n2024/2/4 添加了一部分来自 bzoj 的数据。", "locale": "en"}, "zh-CN": {"title": "[POI 2013] CEN-Price List", "background": "", "description": "铁路一直是 Byteotia 最受欢迎的交通方式。\n\n在这个国家的 $n$ 个城镇中，有 $m$ 对城镇由 Byteotian State Railways (BSR) 的轨道段连接。\n\n这些轨道不会在城镇外交叉，可能会经过风景如画的桥梁和不太风景如画的隧道。\n\n直接通过铁路连接的任意两个城镇之间的票价为 $a$ 比特勒。\n\n目前，Byteotia 的交通市场正在发生变化。\n\n截至目前，BSR 面临着一个新的竞争对手：Byteotian Airlines (BA)。\n\nBA 计划在一些城镇对之间运营航班。\n\n由于 Byteotian 铁路相当舒适，BA 董事会决定只在那些没有直接铁路连接的城镇对之间运营航班。出于经济原因，BA 只会在那些需要恰好一次换乘的城镇之间飞行。\n\n每张此类航班的票价为 $b$ 比特勒。\n\n为了帮助 Byteotia 的市民规划他们的旅行，Byteotian 交通部 (BMT) 决定发行传单，说明所有可能城镇之间的最便宜路线。任意数量的直接铁路或飞机连接的序列被称为路线。名叫 Byteasar 的 BMT 官员被委派准备传单的价格表。\n\n你能帮他写一个程序来确定正确的价格吗？\n\n让我们明确一下，Byteotia 的所有连接，无论是铁路还是飞机，都是双向的。", "inputFormat": "标准输入的第一行包含五个整数，$n$，$m$，$k$，$a$ 和 $b$ ($2\\le n\\le 100\\ 000$, $0\\le m\\le 100\\ 000$, $1\\le k\\le n$, $1\\le a,b\\le 1\\ 000$)，以单个空格分隔。\n\n数字 $n$ 和 $m$ 分别表示 Byteotia 中的城镇数量和直接铁路连接的数量。\n\n为简化起见，我们将 Byteotia 的城镇编号为 $1$ 到 $n$。其他数字表示：$k$ - 需要确定连接价格的源城镇的编号；$a$ - 直接铁路连接的价格；$b$ - 直接飞机连接的价格。\n\n接下来的 $m$ 行中的每一行包含一对整数 $u_i$ 和 $v_i$ ($1\\le u_i,v_i\\le n$，$u_i\ne v_i$ 对于 $i=1,2,\\cdots,m$)，以单个空格分隔，指定由轨道直接连接的城镇对的编号。\n\n你可以假设所有城镇都可以通过铁路从编号为 $k$ 的城镇到达。", "outputFormat": "你的程序应输出 $n$ 行到标准输出。\n\n第 $i$ 行（对于 $i=1,2,\\cdots,n$）应包含一个整数：\n\n从编号为 $k$ 的城镇到编号为 $i$ 的城镇的最便宜路线的费用。\n\n其中，第 $k$ 行应包含数字 $0$。", "hint": "------------\n\n2024/2/4 添加了一部分来自 bzoj 的数据。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3548", "type": "P", "difficulty": 0, "samples": [["1\n16\n5 -3\n4 -4\n3 -7\n0 -5\n-3 -7\n-4 -4\n-5 -3\n-1 -1\n-4 3\n-2 4\n-1 2\n0 7\n1 2\n2 4\n4 3\n1 -1\nC\nS\nS\nS\nS\nC\nC\nS\nS\nC\nS\nS\nC\nS\nS\nC\n        \n\n", "TAK\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2013", "POI（波兰）"], "title": "[POI 2013] GOB-Tapestries", "background": "", "description": "An exhibition of tapestries is opening in Byteotian Museum of Fine Arts.\n\nThe main exhibition room, viewed from top, is a polygon (not necessarily    convex).  A tapestry is hanged on each wall of the room, each tapestry    taking all the area of its wall.\n\nA lamp has been installed in the room in order to illuminate the exhibition.\n\n    The lamp is glowing uniformly in all directions.\n\nHowever, while some of the tapestries have to be flooded with light,    others cannot be exposed to strong light.\n\nByteasar, the curator, has been moving the lamp around the room, but so far    he is not satisfied with the results.\n\nNow he is terrified by the prospect of moving the tapestries around    instead - this would require much effort, and the exhibition is to open soon.\n\nPerhaps you will be able to tell him if his attempts are doomed or not?\n\nYour task is to determine if there is such a spot that placing the lamp    in it satisfies the following:\n\neach wall is to be either completely illuminated or completely shaded, as required by the tapestry hanging on it;        there can be no wall that is partly illuminated and partly shaded;                  if the lamp is located exactly on the wall or its extension, this wall is not illuminated;                the lamp can neither be switched off nor taken away from the room; it has      to be on while located (strictly) inside the room (i.e., it cannot be      placed in a corner or on any wall).", "inputFormat": "There is a single integer ![](http://main.edu.pl/images/OI20/gob-en-tex.1.png) (![](http://main.edu.pl/images/OI20/gob-en-tex.2.png)) in the first line of      the standard input, denoting the number of data sets.\n\nThe following lines describe these data sets.\n\nThe first line of a single description holds a single integer ![](http://main.edu.pl/images/OI20/gob-en-tex.3.png) (![](http://main.edu.pl/images/OI20/gob-en-tex.4.png)), denoting the number of walls in the main exhibition room.\n\nThen the following ![](http://main.edu.pl/images/OI20/gob-en-tex.5.png) lines specify the room's shape.\n\nEach of those lines contains a pair of integers ![](http://main.edu.pl/images/OI20/gob-en-tex.6.png) and ![](http://main.edu.pl/images/OI20/gob-en-tex.7.png)      (![](http://main.edu.pl/images/OI20/gob-en-tex.8.png) for ![](http://main.edu.pl/images/OI20/gob-en-tex.9.png)), separated by      a single space, denoting the coordinates of the room's corner or, in      other words, the vertex of corresponding polygon.  The vertices are given      clockwise.\n\nThe next ![](http://main.edu.pl/images/OI20/gob-en-tex.10.png) lines specify the tapestries' requirements.\n\nEach of those lines contains a single letter, S or      C, denoting that the wall has to be illuminated or shaded,      respectively.\n\nThe letter in the ![](http://main.edu.pl/images/OI20/gob-en-tex.11.png)-th of these lines (for ![](http://main.edu.pl/images/OI20/gob-en-tex.12.png))      regards the wall between the ![](http://main.edu.pl/images/OI20/gob-en-tex.13.png)-th and the ![](http://main.edu.pl/images/OI20/gob-en-tex.14.png)-th vertex.\n\nThe letter in the last of these lines regards the wall between the last      and the first vertex.\n\nThe polygon depicting the room's shape has no self-crossings, i.e.,      with the exception of successive sides, which share a common vertex,      no two sides of the polygon share a common point.  Furthermore, no three      vertices …\n", "outputFormat": "For each data set your program should print to the standard output      a single line containing a single word:\n\nTAK (Polish for yes) if the lamp can be placed so as   to satisfy all aforementioned requirements, or                      NIE (Polish for no) otherwise.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2013] GOB-Tapestries", "background": "", "description": "An exhibition of tapestries is opening in Byteotian Museum of Fine Arts.\n\nThe main exhibition room, viewed from top, is a polygon (not necessarily    convex).  A tapestry is hanged on each wall of the room, each tapestry    taking all the area of its wall.\n\nA lamp has been installed in the room in order to illuminate the exhibition.\n\n    The lamp is glowing uniformly in all directions.\n\nHowever, while some of the tapestries have to be flooded with light,    others cannot be exposed to strong light.\n\nByteasar, the curator, has been moving the lamp around the room, but so far    he is not satisfied with the results.\n\nNow he is terrified by the prospect of moving the tapestries around    instead - this would require much effort, and the exhibition is to open soon.\n\nPerhaps you will be able to tell him if his attempts are doomed or not?\n\nYour task is to determine if there is such a spot that placing the lamp    in it satisfies the following:\n\neach wall is to be either completely illuminated or completely shaded, as required by the tapestry hanging on it;        there can be no wall that is partly illuminated and partly shaded;                  if the lamp is located exactly on the wall or its extension, this wall is not illuminated;                the lamp can neither be switched off nor taken away from the room; it has      to be on while located (strictly) inside the room (i.e., it cannot be      placed in a corner or on any wall).", "inputFormat": "There is a single integer ![](http://main.edu.pl/images/OI20/gob-en-tex.1.png) (![](http://main.edu.pl/images/OI20/gob-en-tex.2.png)) in the first line of      the standard input, denoting the number of data sets.\n\nThe following lines describe these data sets.\n\nThe first line of a single description holds a single integer ![](http://main.edu.pl/images/OI20/gob-en-tex.3.png) (![](http://main.edu.pl/images/OI20/gob-en-tex.4.png)), denoting the number of walls in the main exhibition room.\n\nThen the following ![](http://main.edu.pl/images/OI20/gob-en-tex.5.png) lines specify the room's shape.\n\nEach of those lines contains a pair of integers ![](http://main.edu.pl/images/OI20/gob-en-tex.6.png) and ![](http://main.edu.pl/images/OI20/gob-en-tex.7.png)      (![](http://main.edu.pl/images/OI20/gob-en-tex.8.png) for ![](http://main.edu.pl/images/OI20/gob-en-tex.9.png)), separated by      a single space, denoting the coordinates of the room's corner or, in      other words, the vertex of corresponding polygon.  The vertices are given      clockwise.\n\nThe next ![](http://main.edu.pl/images/OI20/gob-en-tex.10.png) lines specify the tapestries' requirements.\n\nEach of those lines contains a single letter, S or      C, denoting that the wall has to be illuminated or shaded,      respectively.\n\nThe letter in the ![](http://main.edu.pl/images/OI20/gob-en-tex.11.png)-th of these lines (for ![](http://main.edu.pl/images/OI20/gob-en-tex.12.png))      regards the wall between the ![](http://main.edu.pl/images/OI20/gob-en-tex.13.png)-th and the ![](http://main.edu.pl/images/OI20/gob-en-tex.14.png)-th vertex.\n\nThe letter in the last of these lines regards the wall between the last      and the first vertex.\n\nThe polygon depicting the room's shape has no self-crossings, i.e.,      with the exception of successive sides, which share a common vertex,      no two sides of the polygon share a common point.  Furthermore, no three      vertices …\n", "outputFormat": "For each data set your program should print to the standard output      a single line containing a single word:\n\nTAK (Polish for yes) if the lamp can be placed so as   to satisfy all aforementioned requirements, or                      NIE (Polish for no) otherwise.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2013] GOB-Tapestries", "background": null, "description": "Byteotian 美术馆正在举办一场挂毯展览。\n\n从顶部看，主展厅是一个多边形（不一定是凸形）。房间的每一面墙上都挂着一幅挂毯，每幅挂毯都占据了墙壁的全部面积。\n\n为了照亮展览，房间里安装了一盏灯，这盏灯向各个方向均匀发光。然而，有些挂毯必须充满光线，但另一些挂毯不能暴露在强光下。\n\n策展人 Byteasar 一直在房间里移动灯，但到目前为止，他对结果并不满意。\n\n现在，他对移动挂毯的前景感到恐惧——这需要付出很多努力，展览很快就会开幕。\n\n也许你能告诉他，他的尝试是否注定要失败？\n\n**你的任务**是确定是否有这样一个点，将灯放在其中满足以下条件：\n\n1. 根据挂在墙上的挂毯的要求，每面墙要么完全照亮，要么完全遮阳；\n2. 不可能有一面墙是部分照明和部分遮阳的；如果灯正好位于墙上或其延伸部分，则这面墙不会被照亮；\n3. 灯既不能关闭，也不能从房间里拿走；它必须严格位于房间内（即它不能放置在角落或任何墙上）。", "inputFormat": "标准输入的第一行中有一个整数 $T$，表示数据集的数量。\n\n对于每个数据集，第一行有一个整数 $N$，表示主展厅的墙的数量。\n\n接下来 $N$ 行，每行 $2$ 个用空格隔开的整数 $x_i$ 和 $y_i$，表示房间角落的坐标。换句话说，就是相应多边形的顶点。顶点按顺时针方向给出。\n\n然后的的 $N$ 行指定了挂毯的要求。每一行都包含一个字母 $S$ 或 $C$，分别表示墙壁必须被照亮或遮蔽。\n\n第 $i$（$1\\le i\\le N$）行中的字母表示第 $i$ 个顶点和第 $i+1$ 个顶点之间的墙，最后一行中的字母表示最后一个顶点和第一个顶点之间的墙。\n\n描绘房间形状的多边形没有自交，即除了连续的边共享一个共同的顶点外，多边形的任何两条边都不共享一个顶点。而且没有三个顶点在一条线上。", "outputFormat": "对于每个数据集，你的程序应该在标准输出中打印一行包含一个单词：如果灯可以满足以上要求则输出 `TAK`（波兰语中“是”的意思）,否则输出 `NIE`（波兰语中表示“否”的意思）。", "hint": "- 对于 $40\\%$ 的数据点，$n\\le20$。\n- 对于另外 $10\\%$ 的数据点，所有地毯都需要被照亮。\n- 对于 $100\\%$ 的数据点，满足 $1\\le T\\le 20$，$3\\le N\\le 1000$，$-30000\\le xi,yi\\le30000$。", "locale": "zh-CN"}}}
{"pid": "P3549", "type": "P", "difficulty": 7, "samples": [["12\n1 7\n7 8\n7 11\n7 2\n2 4\n4 10\n2 5\n5 9\n2 6\n3 6\n3 12\n", "1\n11\n8\n7\n4\n10\n2\n9\n5\n6\n3\n12\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "2013", "POI（波兰）", "Special Judge", "构造"], "title": "[POI 2013] MUL-Multidrink", "background": "**本题翻译为 AI 生成。**", "description": "Byteasar 住在 Byteburg，一座以每个街角都有牛奶吧而闻名的城市。某天，Byteasar 想出了一个“牛奶多饮计划”：他希望每个牛奶吧只去喝一次。理想情况下，他希望设计一条路线，使得每次前往下一个牛奶吧时，其距离上一个牛奶吧不会超过两个街区（即：路口）。\n\nByteburg 的路口从 $1$ 到 $N$ 编号，所有街道都是双向通行的。在每对路口之间，存在唯一的一条直接路径，即不会重复经过任何路口的路径。Byteasar 将从编号为 $1$ 的路口出发，并在编号为 $N$ 的路口结束。你的任务是找出一条满足 Byteasar 要求的任意路线（如果存在的话）。", "inputFormat": "标准输入的第一行包含一个整数 $N$（$2 \\leq N \\leq 500000$），表示 Byteburg 中的路口数量。接下来的 $N - 1$ 行中，每行包含一对用一个空格分隔的不同整数 $A_i$ 和 $B_i$（$1 \\leq A_i, B_i \\leq N$），表示连接路口 $A_i$ 和 $B_i$ 的街道。", "outputFormat": "如果不存在满足要求的路线，你的程序应在标准输出中输出一个单词“**BRAK**”（波兰语，意为“无”），不带引号。否则，你的程序应在标准输出中输出 $N$ 行，第 $i$ 行输出满足条件的第 $i$ 个路口的编号。显然，在这种情况下，第一行应为数字 $1$，第 $N$ 行应为数字 $N$。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2013] MUL-Multidrink", "background": "**This translation is AI-generated.**", "description": "Byteasar lives in Byteburg, a city famous for having a milk bar on every street corner. One day, he came up with a “multidrink plan”: he wants to visit each milk bar exactly once. Ideally, he wants to design a route such that the distance from the previous milk bar to the next one is at most 2 edges each time.\n\nThe intersections of Byteburg are numbered from $1$ to $N$, and all streets are bidirectional. Between every pair of intersections, there is a unique simple path (i.e., a path that does not visit any intersection more than once). Byteasar will start at intersection $1$ and finish at intersection $N$. Your task is to find any route that satisfies his requirement, if it exists.", "inputFormat": "The first line contains an integer $N$ ($2 \\leq N \\leq 500000$), the number of intersections in Byteburg. Each of the next $N - 1$ lines contains a pair of distinct integers $A_i$ and $B_i$ ($1 \\leq A_i, B_i \\leq N$), describing a street connecting intersections $A_i$ and $B_i$.", "outputFormat": "If no such route exists, output a single word “BRAK” (Polish for “none”) without quotes. Otherwise, output $N$ lines; the $i$-th line should contain the index of the $i$-th intersection on the route. In this case, the first line must be $1$, and the last line must be $N$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2013] MUL-Multidrink", "background": "**本题翻译为 AI 生成。**", "description": "Byteasar 住在 Byteburg，一座以每个街角都有牛奶吧而闻名的城市。某天，Byteasar 想出了一个“牛奶多饮计划”：他希望每个牛奶吧只去喝一次。理想情况下，他希望设计一条路线，使得每次前往下一个牛奶吧时，其距离上一个牛奶吧不会超过两个街区（即：路口）。\n\nByteburg 的路口从 $1$ 到 $N$ 编号，所有街道都是双向通行的。在每对路口之间，存在唯一的一条直接路径，即不会重复经过任何路口的路径。Byteasar 将从编号为 $1$ 的路口出发，并在编号为 $N$ 的路口结束。你的任务是找出一条满足 Byteasar 要求的任意路线（如果存在的话）。", "inputFormat": "标准输入的第一行包含一个整数 $N$（$2 \\leq N \\leq 500000$），表示 Byteburg 中的路口数量。接下来的 $N - 1$ 行中，每行包含一对用一个空格分隔的不同整数 $A_i$ 和 $B_i$（$1 \\leq A_i, B_i \\leq N$），表示连接路口 $A_i$ 和 $B_i$ 的街道。", "outputFormat": "如果不存在满足要求的路线，你的程序应在标准输出中输出一个单词“**BRAK**”（波兰语，意为“无”），不带引号。否则，你的程序应在标准输出中输出 $N$ 行，第 $i$ 行输出满足条件的第 $i$ 个路口的编号。显然，在这种情况下，第一行应为数字 $1$，第 $N$ 行应为数字 $N$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3550", "type": "P", "difficulty": 4, "samples": [["42 23 6\n20 25 14 27 30 7\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2013", "POI（波兰）"], "title": "[POI 2013] TAK-Taxis", "background": null, "description": "Byteasar 想从 Bytehole 镇乘坐出租车前往 Bytepit 镇，两镇之间的距离为 $m$ 公里。\n\n在从 Bytehole 镇前往 Bytepit 镇的途中，距离 Bytehole 镇恰好 $d$ 公里处，有一个停有 $n$ 辆出租车的基地，这些出租车编号为 1 到 $n$。\n\n其中，第 $i$ 辆出租车的燃油量足够行驶恰好 $x_i$ 公里。\n\nByteasar 可以在任意地点换乘出租车。\n\n所有出租车均从基地出发，且无需返回基地。\n\n你的任务是判断 Byteasar 能否从 Bytehole 镇抵达 Bytepit 镇；若能抵达，求出完成这段行程所需的最少出租车数量。", "inputFormat": "标准输入的第一行包含三个整数 $m$、$d$、$n$（$1 \\le d \\le m \\le 10^{18}$，$1 \\le n \\le 500000$），整数之间用单个空格分隔。\n\n它们分别表示：Bytehole 镇到 Bytepit 镇的距离、Bytehole 镇到出租车基地的距离、基地内出租车的数量。\n\n输入的第二行包含 $n$ 个整数 $x_1, x_2, \\cdots, x_n$（$1 \\le x_i \\le 10^{18}$），整数之间用单个空格分隔。\n\n其中 $x_i$ 表示第 $i$ 辆出租车最多能行驶的距离（单位：公里）。", "outputFormat": "你的程序应向标准输出打印一个整数：\n\n即 Byteasar 从 Bytehole 镇到 Bytepit 镇所需的最少出租车数量。若无法抵达，则输出 $0$。", "hint": "提示：此题需开 long long", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2013] TAK-Taxis", "background": null, "description": "Byteasar wants to take a taxi from the town Bytehole to the town Bytepit, which is $m$ kilometres away from Bytehole.\n\nExactly $d$ kilometres along the way from Bytehole to Bytepit, there is a base of $n$ taxis, numbered from $1$ to $n$.\n\nThe taxi no. $i$ has enough fuel to drive exactly $x_i$ kilometres.\n\nByteasar can change taxis at any point.\n\nAll the taxis start at their base but need not return there.\n\nYour task is to determine whether Byteasar can be driven from Bytehole to Bytepit, and if so, what it the minimum number of taxis required for such a journey.", "inputFormat": "The first line of the standard input holds three integers, $m$, $d$, and $n$ ($1\\le d\\le m\\le 10^{18}$, $1\\le n\\le 500\\ 000$), separated by single spaces.\n\nThose denote, respectively: the distance from Bytehole to Bytepit,the distance from Bytehole to the taxi base, and the number of taxis at the base.\n\nThe second line of input contains $n$ integers, $x_1,x_2,\\cdots,x_n$ ($1\\le x_i\\le 10^{18}$), separated by single spaces.\n\nThe number $x_i$ denotes the maximum distance (in kilometres) that the i-th taxi can travel.", "outputFormat": "Your program should print a single integer to the standard output:\n\nthe minimum number of taxis Byteasar has to take to get from Bytehole to Bytepit. If getting there is impossible, your program should print the number $0$.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[POI 2013] TAK-Taxis", "background": null, "description": "Byteasar 想从 Bytehole 镇乘坐出租车前往 Bytepit 镇，两镇之间的距离为 $m$ 公里。\n\n在从 Bytehole 镇前往 Bytepit 镇的途中，距离 Bytehole 镇恰好 $d$ 公里处，有一个停有 $n$ 辆出租车的基地，这些出租车编号为 1 到 $n$。\n\n其中，第 $i$ 辆出租车的燃油量足够行驶恰好 $x_i$ 公里。\n\nByteasar 可以在任意地点换乘出租车。\n\n所有出租车均从基地出发，且无需返回基地。\n\n你的任务是判断 Byteasar 能否从 Bytehole 镇抵达 Bytepit 镇；若能抵达，求出完成这段行程所需的最少出租车数量。", "inputFormat": "标准输入的第一行包含三个整数 $m$、$d$、$n$（$1 \\le d \\le m \\le 10^{18}$，$1 \\le n \\le 500000$），整数之间用单个空格分隔。\n\n它们分别表示：Bytehole 镇到 Bytepit 镇的距离、Bytehole 镇到出租车基地的距离、基地内出租车的数量。\n\n输入的第二行包含 $n$ 个整数 $x_1, x_2, \\cdots, x_n$（$1 \\le x_i \\le 10^{18}$），整数之间用单个空格分隔。\n\n其中 $x_i$ 表示第 $i$ 辆出租车最多能行驶的距离（单位：公里）。", "outputFormat": "你的程序应向标准输出打印一个整数：\n\n即 Byteasar 从 Bytehole 镇到 Bytepit 镇所需的最少出租车数量。若无法抵达，则输出 $0$。", "hint": "提示：此题需开 long long", "locale": "zh-CN"}}}
{"pid": "P3551", "type": "P", "difficulty": 4, "samples": [["12 2\nccbcbbbbbbcb\n", "1 8 12\n2 6 7\n3 4 5\n9 10 11\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "POI（波兰）", "Special Judge", "栈"], "title": "[POI 2013] USU-Take-out", "background": "", "description": "Little Edna has received the take-out game as a present.\n\nTake-out is a single player game, in which the player is given a sequence of $n$ adjacent blocks, numbered from $1$ to $n$.\n\nEach block is either black or white, and there are $k$ times as many white    blocks as there are black ones.\n\nThe player's goal is to remove all the blocks by certain permissible moves.\n\nA single move consists in removing exactly $k$ white blocks and a single    black block without changing the positions of other blocks.\n\nThe move is permissible if there is no \"gap\" (a space left by    a previously taken out block) between any two blocks being removed.\n\nHelp poor little Edna in finding any sequence of permissible moves that    remove all the blocks.\n\n有n块砖，其中白色是黑色的k倍，求一个消除序列，满足以下条件：\n\n每次消除k+1个砖，其中k块白色，1块黑色，并且这k+1块砖从开始到结束，中间不能路过已经消除过的砖\n\n数据保证有解\n", "inputFormat": "In the first line of the standard input there are two integers, $n$ and $k$ ($2\\le n\\le 1\\ 000\\ 000$, $1\\le k\\le n-1$), separated by a single space, that denote the total number of blocks used in the gameand the number of white blocks per black node (to be removed in every move).  In all the tests the condition $k+1|n$ holds.\n\nIn the second line there is a string of $n$ letters b      or c.  These tell the colours of successive blocks (in Polish):\n\nb (for biały) - white, c (for czarny)      - black.  You may assume that in all the tests there exists a sequence      of permissible moves that takes out all the blocks.\n", "outputFormat": "Your program should print $\\frac{n}{k+1}$ lines to the standard output.\n\nSuccessive lines should describe successive moves.\n\nEach line should contain $k+1$ integers, in increasing order,separated by single spaces, that denote the numbers of blocks to be removed in the move.\n", "hint": "有n块砖，其中白色是黑色的k倍，求一个消除序列，满足以下条件：\n\n每次消除k+1个砖，其中k块白色，1块黑色，并且这k+1块砖从开始到结束，中间不能路过已经消除过的砖\n\n数据保证有解\n\n\n返回`TAT1`：同一个位置输出$2$次\n\n返回`TAT2`：输出的$k+1$个位置不满足白色是黑色$k$倍\n\n返回`TAT3`：未按照升序输出或者中间路过已经消除的砖\n\nSPJ provided by @colazcy", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2013] USU-Take-out", "background": "", "description": "Little Edna has received the game Take-out as a present.\n\nTake-out is a single-player game played on a sequence of $n$ adjacent blocks, numbered from $1$ to $n$. Each block is either white or black, and there are $k$ times as many white blocks as black blocks. The goal is to remove all blocks using permissible moves.\n\nIn a single move, you remove exactly $k$ white blocks and $1$ black block, without changing the positions of the other blocks. A move is permissible if there is no “gap” (a position of a previously removed block) between any two blocks removed in that move.\n\nFind any sequence of permissible moves that removes all the blocks. It is guaranteed that a solution exists.", "inputFormat": "In the first line of the standard input there are two integers, $n$ and $k$ ($2\\le n\\le 1\\ 000\\ 000$, $1\\le k\\le n-1$), separated by a single space, that denote the total number of blocks used in the game and the number of white blocks per black block (to be removed in every move). In all the tests the condition $k+1|n$ holds.\n\nIn the second line there is a string of $n$ letters 'b' or 'c'. These tell the colours of successive blocks (in Polish): 'b' (for biały) — white, 'c' (for czarny) — black. You may assume that in all the tests there exists a sequence of permissible moves that takes out all the blocks.", "outputFormat": "Your program should print $\\frac{n}{k+1}$ lines to the standard output. Successive lines should describe successive moves. Each line should contain $k+1$ integers, in increasing order, separated by single spaces, that denote the numbers of blocks to be removed in the move.", "hint": "Return `TAT1`: the same position is output $2$ times.\n\nReturn `TAT2`: among the $k+1$ output positions, the number of white blocks is not $k$ times the number of black blocks.\n\nReturn `TAT3`: the positions are not in increasing order, or the segment passes through a block that has already been removed.\n\nSPJ provided by @colazcy.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2013] USU-Take-out", "background": "", "description": "Little Edna has received the take-out game as a present.\n\nTake-out is a single player game, in which the player is given a sequence of $n$ adjacent blocks, numbered from $1$ to $n$.\n\nEach block is either black or white, and there are $k$ times as many white    blocks as there are black ones.\n\nThe player's goal is to remove all the blocks by certain permissible moves.\n\nA single move consists in removing exactly $k$ white blocks and a single    black block without changing the positions of other blocks.\n\nThe move is permissible if there is no \"gap\" (a space left by    a previously taken out block) between any two blocks being removed.\n\nHelp poor little Edna in finding any sequence of permissible moves that    remove all the blocks.\n\n有n块砖，其中白色是黑色的k倍，求一个消除序列，满足以下条件：\n\n每次消除k+1个砖，其中k块白色，1块黑色，并且这k+1块砖从开始到结束，中间不能路过已经消除过的砖\n\n数据保证有解\n", "inputFormat": "In the first line of the standard input there are two integers, $n$ and $k$ ($2\\le n\\le 1\\ 000\\ 000$, $1\\le k\\le n-1$), separated by a single space, that denote the total number of blocks used in the gameand the number of white blocks per black node (to be removed in every move).  In all the tests the condition $k+1|n$ holds.\n\nIn the second line there is a string of $n$ letters b      or c.  These tell the colours of successive blocks (in Polish):\n\nb (for biały) - white, c (for czarny)      - black.  You may assume that in all the tests there exists a sequence      of permissible moves that takes out all the blocks.\n", "outputFormat": "Your program should print $\\frac{n}{k+1}$ lines to the standard output.\n\nSuccessive lines should describe successive moves.\n\nEach line should contain $k+1$ integers, in increasing order,separated by single spaces, that denote the numbers of blocks to be removed in the move.\n", "hint": "有n块砖，其中白色是黑色的k倍，求一个消除序列，满足以下条件：\n\n每次消除k+1个砖，其中k块白色，1块黑色，并且这k+1块砖从开始到结束，中间不能路过已经消除过的砖\n\n数据保证有解\n\n\n返回`TAT1`：同一个位置输出$2$次\n\n返回`TAT2`：输出的$k+1$个位置不满足白色是黑色$k$倍\n\n返回`TAT3`：未按照升序输出或者中间路过已经消除的砖\n\nSPJ provided by @colazcy", "locale": "zh-CN"}}}
{"pid": "P3552", "type": "P", "difficulty": 6, "samples": [["4 6\n0000 1011\n0110\n0111\n0011\n1101\n1010\n1001\n", "TAK\n"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "2013", "POI（波兰）", "哈希 hashing"], "title": "[POI 2013] SPA-Walk", "background": "", "description": "The names of towns in Byteotia are unique sequences of exactly $n$ bits.\n\nThere are $2^n-k$ towns in Byteotia, and thus,only $k$ sequences of $n$ bits do not correspond to any town.\n\nSome pairs of towns are connected with roads.\n\nSpecifically, two towns are directly linked by a road if and only if their names differ in a single bit.\n\nThe roads do not cross outside of towns.\n\nByteasar intends to take a stroll - he intends to walk from the town $x$ to the town $y$, taking the existing roads.\n\nYour task is to write a program that will determine if such a walk is possible.\n\n有2^n个长度为n的01串，两个01串之间有边当且仅当这两个01串只有一位不同，现在从这2n个串中拿掉k个，问指定两个串之间能否到达\n", "inputFormat": "In the first line of the standard input, there are two integers,$n$ and $k$($1\\le n\\le 60$, $0\\le k\\le 1\\ 000\\ 000$, $k\\le 2^n-1$, $n\\times k\\le 5\\ 000\\ 000$),      separated by a single space.\n\nThese are the length of town names in bits and the the number of $n$-bit sequences that do not correspond to any town, respectively.\n\nIn the second line, there are two strings, separated by a single space,      each consisting of $n$ characters 0 and/or 1.\n\nThese are the names of the towns $x$ and $y$.\n\nIn the $k$ lines that follow, all the sequences of $n$ bits that do not correspond to any town are given, one sequence per line.In the $k$ lines that follow, all the sequences of $n$ bits that do not correspond to any town are given, one sequence per line.Each such sequence is a string of $n$ characters 0 and/or 1.You may assume that $x$ and $y$ are not among those $k$ sequences.\n", "outputFormat": "Your program should print to the standard output the word TAK (Polish for yes) if walking from the town x to the town y is possible, and the word NIE (Polish for no) otherwise.\n", "hint": "有2^n个长度为n的01串，两个01串之间有边当且仅当这两个01串只有一位不同，现在从这2n个串中拿掉k个，问指定两个串之间能否到达\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2013] SPA-Walk", "background": "", "description": "The names of towns in Byteotia are unique sequences of exactly $n$ bits. There are $2^n-k$ towns in Byteotia, and thus, only $k$ sequences of $n$ bits do not correspond to any town.\n\nSome pairs of towns are connected by roads. Specifically, two towns are directly linked by a road if and only if their names differ in exactly one bit. The roads do not cross outside of towns.\n\nByteasar intends to take a stroll — he plans to walk from the town $x$ to the town $y$, taking the existing roads. Your task is to determine whether such a walk is possible.", "inputFormat": "The first line contains two integers $n$ and $k$ ($1 \\le n \\le 60$, $0 \\le k \\le 1\\ 000\\ 000$, $k \\le 2^n - 1$, $n \\times k \\le 5\\ 000\\ 000$), separated by a single space. These are the length of the town names in bits and the number of $n$-bit sequences that do not correspond to any town, respectively.\n\nThe second line contains two strings, separated by a single space, each consisting of $n$ characters 0 and/or 1. These are the names of the towns $x$ and $y$.\n\nEach of the next $k$ lines contains one sequence of $n$ bits that does not correspond to any town. You may assume that $x$ and $y$ are not among these $k$ sequences.", "outputFormat": "Print TAK if it is possible to walk from $x$ to $y$, and NIE otherwise.", "hint": "There are $2^n$ binary strings of length $n$. Two strings are connected by an edge if and only if they differ in exactly one bit. After removing $k$ of these $2^n$ strings, determine whether the two specified strings are reachable from each other.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2013] SPA-Walk", "background": "", "description": "The names of towns in Byteotia are unique sequences of exactly $n$ bits.\n\nThere are $2^n-k$ towns in Byteotia, and thus,only $k$ sequences of $n$ bits do not correspond to any town.\n\nSome pairs of towns are connected with roads.\n\nSpecifically, two towns are directly linked by a road if and only if their names differ in a single bit.\n\nThe roads do not cross outside of towns.\n\nByteasar intends to take a stroll - he intends to walk from the town $x$ to the town $y$, taking the existing roads.\n\nYour task is to write a program that will determine if such a walk is possible.\n\n有2^n个长度为n的01串，两个01串之间有边当且仅当这两个01串只有一位不同，现在从这2n个串中拿掉k个，问指定两个串之间能否到达\n", "inputFormat": "In the first line of the standard input, there are two integers,$n$ and $k$($1\\le n\\le 60$, $0\\le k\\le 1\\ 000\\ 000$, $k\\le 2^n-1$, $n\\times k\\le 5\\ 000\\ 000$),      separated by a single space.\n\nThese are the length of town names in bits and the the number of $n$-bit sequences that do not correspond to any town, respectively.\n\nIn the second line, there are two strings, separated by a single space,      each consisting of $n$ characters 0 and/or 1.\n\nThese are the names of the towns $x$ and $y$.\n\nIn the $k$ lines that follow, all the sequences of $n$ bits that do not correspond to any town are given, one sequence per line.In the $k$ lines that follow, all the sequences of $n$ bits that do not correspond to any town are given, one sequence per line.Each such sequence is a string of $n$ characters 0 and/or 1.You may assume that $x$ and $y$ are not among those $k$ sequences.\n", "outputFormat": "Your program should print to the standard output the word TAK (Polish for yes) if walking from the town x to the town y is possible, and the word NIE (Polish for no) otherwise.\n", "hint": "有2^n个长度为n的01串，两个01串之间有边当且仅当这两个01串只有一位不同，现在从这2n个串中拿掉k个，问指定两个串之间能否到达\n", "locale": "zh-CN"}}}
{"pid": "P3553", "type": "P", "difficulty": 6, "samples": [["2\n3 5\n1 1 1\n1 2 1\n2 3 1\n4 1 1\n4 2 1\n3 3\n3 3 0\n2 2 0\n1 1 0\n", "4\n3\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2013", "二分", "POI（波兰）", "构造"], "title": "INS-Inspector", "background": "", "description": "Inspector Byteasar is investigating a crime that took place on the premises of a software development company.\n\nHe is trying to establish the chain of events.\n\nUnfortunately, the programmers are rather scatterbrained.\n\nStatements of the kind \"Well, when I checked at 14:42,    there were five other programmers logged in on the server.\"    are the most informative of those that Byteasar could get.\n\nIt is known that every programmer came to office at some point    during that day, spent some time in there without going out,    and then left for good, never coming back on the same day.\n\nByteasar, confused by the programmers' statements, is not sure    if he should rely on them.  In fact, he is wondering whether it is at all    possible that they all tell the truth.  He asks you for help in finding    that out.", "inputFormat": "In the first line of the standard input, there is an integer $z$($1\\le z\\le 50$),      the number of data sets.\n\nThe lines that follow contain the $z$ data sets.\n\nThe first line of each data set holds two integers, $n$ and $m$,separated by a single space ($1\\le n,m\\le 100\\ 000$).\n\nThese are the number of programmers working in the office and the      number of statements recorded by Byteasar.\n\nThe programmers are numbered from 1 to $n$.\n\nEach of the $m$ lines that follow describes a single statement.\n\nEach such line contains three integers $t$,$j$ and $i$, separated by single spaces ($1\\le t\\le m$,$1\\le j\\le n$,$0\\le i\\le n$). These indicate that the programmer no. $j$ confessed that at time $t$ he was in the office and there were $i$ more programmers apart from him.We assume that the programmers came in to the office and left it at times different from those appearing in the statements, i.e., either before, after or in between them.", "outputFormat": "For each data set, your program should print a single positive integer      to the standard output.\n\nPrinting out the number $k$ ($1\\le k\\le m$) indicates that the first $k$ statements given on the input can be true but the first $k+1$ statements cannot.  In particular, if $k=m$, then all the statements given as input can be true.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "INS-Inspector", "background": "", "description": "Inspector Byteasar is investigating a crime that took place on the premises of a software development company.\n\nHe is trying to establish the chain of events.\n\nUnfortunately, the programmers are rather scatterbrained.\n\nStatements of the kind \"Well, when I checked at 14:42,    there were five other programmers logged in on the server.\"    are the most informative of those that Byteasar could get.\n\nIt is known that every programmer came to office at some point    during that day, spent some time in there without going out,    and then left for good, never coming back on the same day.\n\nByteasar, confused by the programmers' statements, is not sure    if he should rely on them.  In fact, he is wondering whether it is at all    possible that they all tell the truth.  He asks you for help in finding    that out.", "inputFormat": "In the first line of the standard input, there is an integer $z$($1\\le z\\le 50$),      the number of data sets.\n\nThe lines that follow contain the $z$ data sets.\n\nThe first line of each data set holds two integers, $n$ and $m$,separated by a single space ($1\\le n,m\\le 100\\ 000$).\n\nThese are the number of programmers working in the office and the      number of statements recorded by Byteasar.\n\nThe programmers are numbered from 1 to $n$.\n\nEach of the $m$ lines that follow describes a single statement.\n\nEach such line contains three integers $t$,$j$ and $i$, separated by single spaces ($1\\le t\\le m$,$1\\le j\\le n$,$0\\le i\\le n$). These indicate that the programmer no. $j$ confessed that at time $t$ he was in the office and there were $i$ more programmers apart from him.We assume that the programmers came in to the office and left it at times different from those appearing in the statements, i.e., either before, after or in between them.", "outputFormat": "For each data set, your program should print a single positive integer      to the standard output.\n\nPrinting out the number $k$ ($1\\le k\\le m$) indicates that the first $k$ statements given on the input can be true but the first $k+1$ statements cannot.  In particular, if $k=m$, then all the statements given as input can be true.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2013] INS-Inspector", "background": null, "description": "一天公司有 $n$ 个员工和 $m$ 个员工记录，每个员工只会在连续的一段时间内工作。现在给出 $m$ 条记录，表示某个时刻某个人在工作以及除他之外还有多少人在工作。求最大的 $k$ 使得前 $k$ 条记录互不矛盾。", "inputFormat": "第一行一个整数 $T(1 \\le T \\le 50)$，表示一个测试点有 $T$ 组测试数据。\n\n接下来的每组测试数据的第一行包含两个由空格分隔的整数 $ n,m(1 \\le n, m \\le 10^5)$，分别表示员工数量和员工记录数量。接下来的 $m$ 行中，每一行包含三个由空格分隔的整数 $t,j,i(1 \\le t \\le m，1 \\le j \\le n,0 \\le i \\le n )$。表示在时间为 $t$ 时，编号为 $j$ 的员工在办公室里工作并且除了他以外还有 $i$ 个员工在那里。", "outputFormat": "输出共 $T$ 行。对于每一个测试数据，输出最大的 $k$ 使得前 $k$ 条记录互不矛盾。两个答案之间用换行隔开。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3554", "type": "P", "difficulty": 5, "samples": [["7\n1 2\n1 3\n2 5\n2 6\n7 2\n4 1\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2013", "二分", "POI（波兰）", "树形 DP"], "title": "[POI 2013] LUK-Triumphal arch", "background": null, "description": "给一颗 $n$ 个节点的树，初始时 $1$ 号节点被染黑，其余是白的。两个人轮流操作，一开始 B 在 $1$ 号节点。每一轮，A 选择 $k$ 个点染黑，然后 B 走到一个相邻节点，如果 B 当前处于白点则 B 胜，否则当 A 将所有点染为黑点时 A 胜。求能让 A 获胜的最小的 $k$。", "inputFormat": "第一行读入一个整数 $n$，表示树的节点数\n\n接下来 $n-1$ 行，每行读入两个用空格分隔的整数 $u,v$，表示 $u$、$v$ 之间有一条边。", "outputFormat": "输出仅有一行，表示让 A 获胜的最小的 $k$。", "hint": "$n \\le 3 \\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2013] LUK-Triumphal arch", "background": null, "description": "The king of Byteotia, Byteasar, is returning to his country after a victorious battle.\n\nIn Byteotia, there are $n$ towns connected with only $n-1$ roads.\n\nIt is known that every town can be reached from every other town by a unique route, consisting of one or more (direct) roads.\n\n(In other words, the road network forms a tree).\n\nThe king has just entered the capital.\n\nTherein a triumphal arch, i.e., a gate a victorious king rides through, has been erected.\n\nByteasar, delighted by a warm welcome by his subjects, has planned a triumphal procession to visit all the towns of Byteotia, starting with the capital he is currently in.\n\nThe other towns are not ready to greet their king just yet - the constructions of the triumphal arches in those towns did not even begin!\n\nBut Byteasar's trusted advisor is seeing to the issue.\n\nHe desires to hire a number of construction crews.\n\nEvery crew can construct a single arch each day, in any town.\n\nUnfortunately, no one knows the order in which the king will visit the towns.\n\nThe only thing that is clear is that every day the king will travel from the city he is currently in to a neighboring one.\n\nThe king may visit any town an arbitrary number of times (but as he is not vain, one arch in each town will suffice).\n\nByteasar's advisor has to pay each crew the same flat fee, regardless of how many arches this crew builds.\n\nThus, while he needs to ensure that every town has an arch when it is visited by the king, he wants to hire as few crews as possible.\n\nHelp him out by writing a program that will determine the minimum number of crews that allow a timely delivery of the arches.", "inputFormat": "The first line of the standard input contains a single integer $n$ ($n\\le 300000$), the number of towns in Byteotia.\n\nThe towns are numbered from $1$ to $n$, where the number $1$ corresponds to the capital.\n\nThe road network is described in $n-1$ lines that then follow.\n\nEach of those lines contains two integers, $a,b$ ($1\\le a,b\\le n$), separated by a single space, indicating that towns $a$ and $b$ are directly connected with a two way road.\n\nIn tests worth $50\\%$ of the total points, an additional condition $n\\le 10000$ holds.", "outputFormat": "The first and only line of the standard output is to hold a single integer, the minimum number of crews that Byteasar's advisor needs to hire.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[POI 2013] LUK-Triumphal arch", "background": null, "description": "给一颗 $n$ 个节点的树，初始时 $1$ 号节点被染黑，其余是白的。两个人轮流操作，一开始 B 在 $1$ 号节点。每一轮，A 选择 $k$ 个点染黑，然后 B 走到一个相邻节点，如果 B 当前处于白点则 B 胜，否则当 A 将所有点染为黑点时 A 胜。求能让 A 获胜的最小的 $k$。", "inputFormat": "第一行读入一个整数 $n$，表示树的节点数\n\n接下来 $n-1$ 行，每行读入两个用空格分隔的整数 $u,v$，表示 $u$、$v$ 之间有一条边。", "outputFormat": "输出仅有一行，表示让 A 获胜的最小的 $k$。", "hint": "$n \\le 3 \\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3556", "type": "P", "difficulty": 5, "samples": [["8 7 4\n1 2\n2 3\n3 4\n5 6\n6 7\n7 8\n8 5\n2 3 1\n1 4 1\n5 5 8\n1 8 10\n", "TAK\nNIE\nTAK\nNIE\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2013", "POI（波兰）"], "title": "[POI 2013] MOR-Tales of seafaring", "background": "", "description": "Young Bytensson loves to hang out in the port tavern, where he often    listens to the sea dogs telling their tales of seafaring.\n\nInitially, he believed them all, however incredible they sounded.\n\nOver time though, he became suspicious.\n\nHe has decided to write a program that will verify if there may be    any grain of truth in those tall stories.\n\nBytensson reasoned that while he cannot tell if the sailors indeed    weathered all those storms, he can at least find out if their travel    itineraries make sense.\n\nThis is a task for a programmer, which Bytensson, unfortunately, is not.\n\nHelp him out!\n\nThere are $n$ ports and $m$ waterways connecting them in the waters    frequented by the sailors Bytensson listened to.\n\nIf there is a waterway between two ports, then sailing from one to the    other is possible.  Any waterway can be sailed in both    directions.\n\nBytensson got to know $k$ seafaring tales.\n\nEach tells of a sailor who began his journey in one port,    sailed a number of waterways, and ended up in another port,    which may have been the one he initially set sail from.\n\nThe sailor in question may have sailed through the same waterway    many times, each time in any direction.", "inputFormat": "In the first line of the standard input, there are three integers, $n$,$m$ and $k$ ($2\\le n\\le 5\\ 000$, $1\\le m\\le 5\\ 000$, $1\\le k\\le 1\\ 000\\ 000$).\n\nThese denote, respectively: the number of ports in the waters      frequented by the sailors who told Bytensson their stories,the number of waterways, and the number of tales.\n\nThe $m$ lines that follow specify the waterways.\n\nA single waterway's description consists of a single line that contains two integers, $a$ and $b$ ($1\\le a,b\\le n$,$a\\ne b$), separated by a single space; these specify the numbers of ports at the two ends of this particular waterway.\n\nThe $k$ lines that follow specify the tales that Bytensson has heard. A single tale's description consists of a single line with three integers,$s$,$t$,and $d$ ($1\\le s,t\\le n$,$1\\le d\\le 1\\ 000\\ 000\\ 000$ ), separated by single spaces. These indicate that the tale's protagonist set sail from port no. $s$ , ended the journey in port no. $t$ , and sailed exactly $d$ times through various waterways.", "outputFormat": "Your program should print exactly $k$ lines to the standard output; the $i$-th of them should contain the word TAK (Polish for yes) if the journey described in the $i$-th tale(in input order) could have taken place.\n\nIf it could not, then the line should contain the word NIE (Polish for no).", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2013] MOR-Tales of seafaring", "background": "", "description": "Young Bytensson loves to hang out in the port tavern, where he often    listens to the sea dogs telling their tales of seafaring.\n\nInitially, he believed them all, however incredible they sounded.\n\nOver time though, he became suspicious.\n\nHe has decided to write a program that will verify if there may be    any grain of truth in those tall stories.\n\nBytensson reasoned that while he cannot tell if the sailors indeed    weathered all those storms, he can at least find out if their travel    itineraries make sense.\n\nThis is a task for a programmer, which Bytensson, unfortunately, is not.\n\nHelp him out!\n\nThere are $n$ ports and $m$ waterways connecting them in the waters    frequented by the sailors Bytensson listened to.\n\nIf there is a waterway between two ports, then sailing from one to the    other is possible.  Any waterway can be sailed in both    directions.\n\nBytensson got to know $k$ seafaring tales.\n\nEach tells of a sailor who began his journey in one port,    sailed a number of waterways, and ended up in another port,    which may have been the one he initially set sail from.\n\nThe sailor in question may have sailed through the same waterway    many times, each time in any direction.", "inputFormat": "In the first line of the standard input, there are three integers, $n$,$m$ and $k$ ($2\\le n\\le 5\\ 000$, $1\\le m\\le 5\\ 000$, $1\\le k\\le 1\\ 000\\ 000$).\n\nThese denote, respectively: the number of ports in the waters      frequented by the sailors who told Bytensson their stories,the number of waterways, and the number of tales.\n\nThe $m$ lines that follow specify the waterways.\n\nA single waterway's description consists of a single line that contains two integers, $a$ and $b$ ($1\\le a,b\\le n$,$a\\ne b$), separated by a single space; these specify the numbers of ports at the two ends of this particular waterway.\n\nThe $k$ lines that follow specify the tales that Bytensson has heard. A single tale's description consists of a single line with three integers,$s$,$t$,and $d$ ($1\\le s,t\\le n$,$1\\le d\\le 1\\ 000\\ 000\\ 000$ ), separated by single spaces. These indicate that the tale's protagonist set sail from port no. $s$ , ended the journey in port no. $t$ , and sailed exactly $d$ times through various waterways.", "outputFormat": "Your program should print exactly $k$ lines to the standard output; the $i$-th of them should contain the word TAK (Polish for yes) if the journey described in the $i$-th tale(in input order) could have taken place.\n\nIf it could not, then the line should contain the word NIE (Polish for no).", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2013] MOR-Tales of seafaring", "background": "", "description": "年轻的你喜欢在港口酒馆闲逛，经常听海员们讲述他们的航海故事。\n\n起初，你对所有故事都深信不疑，无论听起来多么不可思议。\n\n但随着时间的推移，你开始产生怀疑。\n\n你决定编写一个程序来验证这些夸张的故事是否可能有一丝真实性。\n\n你认为，虽然你无法判断水手们是否真的经历过那些风暴，但至少可以检查他们的航行路线是否合理。\n\n这不是你能完成的任务，因为你不是程序员，但你还是要完成！\n\n在你所听说的海域中，有 $n$ 个港口和 $m$ 条连接它们的水道。\n\n如果两个港口之间有水道，则可以双向航行。\n\n你收集了 $k$ 个航海故事。每个故事讲述了一名水手从某个港口出发，经过若干水道航行后，到达另一个港口（可能与出发港相同）。水手可能多次航行通过同一水道，每次方向不限。\n", "inputFormat": "第一行三个整数 $n,m,k（2≤n≤5000，1≤m≤5000，1≤k≤1000000）$，分别表示港口数量、水道数量和故事数量。\n\n接下来 $m$ 行描述水道，每行两个整数 $a,b（1≤a,b≤n，a≠b）$，表示水道连接的两个港口。\n\n接下来 $k$ 行描述故事，每行三个整数 $s,t,d（1≤s,t≤n，1≤d≤1000000000）$，表示水手从港口 $s$ 出发，经过 $d$ 次航行后到达港口 $t$。", "outputFormat": "输出 $k$ 行，对每个故事，如果可能则输出 `TAK`（波兰语的\"是\"），否则输出 `NIE`（波兰语的\"否\"）。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3557", "type": "P", "difficulty": 4, "samples": [["9 8 3\n1 2\n2 3\n3 4\n1 4\n3 5\n4 6\n7 8\n8 9\n", "3\n1 5 7 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2013", "POI（波兰）", "Special Judge", "构造"], "title": "[POI 2013] GRA-Tower Defense Game", "background": null, "description": "Bytie 正在玩一款电脑游戏 Tower Defense。\n\n他的目标是建造守卫塔楼，以保护他的整个领地。\n\n在 Bytie 的领地中有多个城镇，其中一些城镇通过双向道路相连。\n\n如果 Bytie 在一个城市建造了守卫塔楼，那么这座塔楼将保护它所在的城市以及所有通过道路直接与之相连的城市。\n\n正当 Bytie 在思考如何在他的领地上布置守卫塔楼时，他的姐姐 Bytea 走进了房间。她瞥了一眼屏幕上显示的地图，片刻之后大声说道：\n\n“嗨，这有什么好想的，显然 $k$ 座塔就足够了！”\n\n被姐姐破坏了游戏乐趣所激怒，Bytie 把姐姐请出了门，然后开始思考接下来该怎么办。\n\n他的自尊心不允许他建造超过 $k$ 座塔楼。\n\n不过，他自有妙计：\n\n他可以研发一项技术，使他能够建造升级版守卫塔楼。\n\n一座升级版守卫塔楼不仅能保护它所在的城镇及其直接相邻的城镇，还能保护更远距离的城镇。\n\n具体来说，如果满足以下任一条件，则建在城镇 $u$ 的升级版守卫塔楼将保护城镇 $v$：\n\n- $u = v$；\n\n- 存在一条从 $u$ 直接通往 $v$ 的道路；\n\n- 或者存在一个城镇 $w$，使得存在从 $u$ 到 $w$ 的直接道路和从 $w$ 到 $v$ 的直接道路。\n\n当然，Bytie 仍然努力最多只建造 $k$ 座塔楼，但他现在对这些塔楼是升级版守卫塔楼毫无顾虑。", "inputFormat": "标准输入的第一行包含三个整数 $n$、$m$ 和 $k$（$2\\le n\\le 500\\ 000$，$0\\le m\\le 1\\ 000\\ 000$，$1\\le k\\le n$），它们以单个空格分隔，分别表示 Bytie 领地中的城镇数量、道路数量，以及 Bytea 给定的数值 $k$。\n\nBytie 领地中的城镇编号为 1 至 $n$。\n\n接下来是 $m$ 行道路描述。\n\n每行包含两个整数 $a_i$ 和 $b_i$（$1\\le a_i,b_i\\le n$，$a_i \\ne b_i$），表示编号为 $a_i$ 和 $b_i$ 的城镇间存在双向道路直接相连。任意两座城镇之间至多由一条道路连接。", "outputFormat": "你的程序需要向标准输出打印两行内容，描述升级版守卫塔楼在 Bytie 领地中的部署方案：\n\n第一行输出整数 $r$（$1\\le r\\le k$），表示 Bytie 应建造的升级版守卫塔楼数量。\n\n第二行通过提供 $r$ 个两两不同的整数来指定塔楼部署位置，这些整数即建造升级版守卫塔楼的城镇编号。\n\n城镇编号可以按任意顺序输出。\n\n若存在多种可行方案，输出任意一种即可。\n\n需特别说明：任意不超过 $k$ 座升级版塔楼的部署方案均可接受——你无需最小化塔楼数量。\n\n你可以默认 Bytea 的判断是正确的，即 Bytie 的整个领地确实能被 $k$ 座普通（非升级版）守卫塔楼保护。因此本题始终存在可行解。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[POI 2013] GRA-Tower Defense Game", "background": null, "description": "Bytie is playing the computer game Tower Defense.\n\nHis aim is to construct guard towers, so that they protect all of his domain.\n\nThere are multiple towns in Bytie's domain, some of which are linked by  bidirectional roads.\n\nIf Bytie erects a guard tower in a city, then the tower protects its city and  all the cities directly linked with it by roads.\n\nJust as Bytie was pondering over the placement of guard towers in his domain,  his elder sister Bytea entered the room.  She glanced at the map displayed on  the screen, and after a moment exclaimed:\n\n\"Oi, what is there to think about, clearly $k$ towers suffice!\".\n\nAngered by his sister spoiling the fun, Bytie showed his sister the door,  and began wondering what to do next.\n\nPride will not let him construct more than $k$ towers.\n\nHe has an up his sleeve though:\n\nhe can research a technology that will allow him to construct improved guard towers.\n\nAn improved guard tower protects not only the town it was erected in and its  immediate neighbors but also the towns that are further away.\n\nFormally, an improved guard tower built in the town $u$ protects the town $v$ if either of the following holds:\n\n- $u=v$;\n\n- there is a direct road from $u$ to $v$;\n\n- or there is such a town $w$ that there are direct roads from $u$ to $w$ and from $w$ to $v$.\n\nOf course, Bytie still strives to erect at most $k$ towers,  but he has no qualms about making these the improved guard towers.", "inputFormat": "In the first line of the standard input, there are three integers,  $n$, $m$, and $k$ ($2\\le n\\le 500\\ 000$,  $0\\le m\\le 1\\ 000\\ 000$, $1\\le k\\le n$), separated by single spaces,  that specify, respectively, the number of towns and roads in Bytie's domain,  and the number $k$ given by Bytea.\n\nThe towns in Bytie's domain are numbered from 1 to $n$.\n\nNext,$m$ lines describing the roads follow.\n\nEach of those lines holds two integers, $a_i$ and $b_i$ ($1\\le a_i,b_i\\le n$,$a_i\\ne b_i$), indicating that the towns no. $a_i$ and $b_i$ are directly linked by a bidirectional road. Each pair of towns is linked by at most a single road.", "outputFormat": "Your program is to print two lines, describing the placement of improved  guard towers in Bytie's domain, to the standard output.\n\nThe first line is to hold an integer $r$ ($1\\le r\\le k$), the number of  improved guard towers that Bytie should construct.\n\nThe second line is to specify the placement of these by providing $r$ pairwise disjoint integers that are the numbers of town where the improved  guard towers are to be built.\n\nThe town numbers can be given in an arbitrary order.\n\nIf more than one solution exists, any solution can be printed.\n\nLet us remind that any placement of no more than $k$ improved towers will do  - you need not minimize their number.\n\nYou may assume that Bytea was correct, i.e., that the whole domain of Bytie  can indeed be protected by $k$ plain (not improved) guard towers. Thus a solution always exists.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[POI 2013] GRA-Tower Defense Game", "background": null, "description": "Bytie 正在玩一款电脑游戏 Tower Defense。\n\n他的目标是建造守卫塔楼，以保护他的整个领地。\n\n在 Bytie 的领地中有多个城镇，其中一些城镇通过双向道路相连。\n\n如果 Bytie 在一个城市建造了守卫塔楼，那么这座塔楼将保护它所在的城市以及所有通过道路直接与之相连的城市。\n\n正当 Bytie 在思考如何在他的领地上布置守卫塔楼时，他的姐姐 Bytea 走进了房间。她瞥了一眼屏幕上显示的地图，片刻之后大声说道：\n\n“嗨，这有什么好想的，显然 $k$ 座塔就足够了！”\n\n被姐姐破坏了游戏乐趣所激怒，Bytie 把姐姐请出了门，然后开始思考接下来该怎么办。\n\n他的自尊心不允许他建造超过 $k$ 座塔楼。\n\n不过，他自有妙计：\n\n他可以研发一项技术，使他能够建造升级版守卫塔楼。\n\n一座升级版守卫塔楼不仅能保护它所在的城镇及其直接相邻的城镇，还能保护更远距离的城镇。\n\n具体来说，如果满足以下任一条件，则建在城镇 $u$ 的升级版守卫塔楼将保护城镇 $v$：\n\n- $u = v$；\n\n- 存在一条从 $u$ 直接通往 $v$ 的道路；\n\n- 或者存在一个城镇 $w$，使得存在从 $u$ 到 $w$ 的直接道路和从 $w$ 到 $v$ 的直接道路。\n\n当然，Bytie 仍然努力最多只建造 $k$ 座塔楼，但他现在对这些塔楼是升级版守卫塔楼毫无顾虑。", "inputFormat": "标准输入的第一行包含三个整数 $n$、$m$ 和 $k$（$2\\le n\\le 500\\ 000$，$0\\le m\\le 1\\ 000\\ 000$，$1\\le k\\le n$），它们以单个空格分隔，分别表示 Bytie 领地中的城镇数量、道路数量，以及 Bytea 给定的数值 $k$。\n\nBytie 领地中的城镇编号为 1 至 $n$。\n\n接下来是 $m$ 行道路描述。\n\n每行包含两个整数 $a_i$ 和 $b_i$（$1\\le a_i,b_i\\le n$，$a_i \\ne b_i$），表示编号为 $a_i$ 和 $b_i$ 的城镇间存在双向道路直接相连。任意两座城镇之间至多由一条道路连接。", "outputFormat": "你的程序需要向标准输出打印两行内容，描述升级版守卫塔楼在 Bytie 领地中的部署方案：\n\n第一行输出整数 $r$（$1\\le r\\le k$），表示 Bytie 应建造的升级版守卫塔楼数量。\n\n第二行通过提供 $r$ 个两两不同的整数来指定塔楼部署位置，这些整数即建造升级版守卫塔楼的城镇编号。\n\n城镇编号可以按任意顺序输出。\n\n若存在多种可行方案，输出任意一种即可。\n\n需特别说明：任意不超过 $k$ 座升级版塔楼的部署方案均可接受——你无需最小化塔楼数量。\n\n你可以默认 Bytea 的判断是正确的，即 Bytie 的整个领地确实能被 $k$ 座普通（非升级版）守卫塔楼保护。因此本题始终存在可行解。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3558", "type": "P", "difficulty": 4, "samples": [["6\n-1 1 0 -1 0 1\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2013", "POI（波兰）"], "title": "[POI 2013] BAJ-Bytecomputer", "background": "", "description": "A sequence of $n$ integers $x_1,x_2,\\cdots,x_n$ from the set $\\{-1, 0, 1\\}$ is given. The bytecomputer is a device that allows the following operation on the sequence: incrementing $x_{i + 1}$ by $x_i$ for any $1\\leq i\\leq n$. There is no limit on the range of integers the bytecomputer can store, i.e., each $x_i$ can (in principle) have arbitrarily small or large value.\n\nProgram the bytecomputer so that it transforms the input sequence into a non - decreasing sequence (i.e., such that $x_1\\leq x_2\\leq\\cdots\\leq x_n$) with the minimum number of operations.", "inputFormat": "The first line of the standard input holds a single integer $n$ ($1\\leq n\\leq1000000$), the number of elements in the (bytecomputer's) input sequence.\n\nThe second line contains $n$ integers $x_1,x_2,\\cdots,x_n$ ($x_i\\in\\{-1, 0, 1\\}$) that are the successive elements of the (bytecomputer's) input sequence, separated by single spaces.\n\nIn tests worth 24% of the total points it holds that $n\\leq500$, and in tests worth 48% of the total points it holds that $n\\leq10000$.", "outputFormat": "The first and only line of the standard output should give one integer, the minimum number of operations the bytecomputer has to perform to make its input sequence non - decreasing, or the single word BRAK (Polish for *none*) if obtaining such a sequence is impossible. ", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2013] BAJ-Bytecomputer", "background": "", "description": "A sequence of $n$ integers $x_1,x_2,\\cdots,x_n$ from the set $\\{-1, 0, 1\\}$ is given. The bytecomputer is a device that allows the following operation on the sequence: incrementing $x_{i + 1}$ by $x_i$ for any $1\\leq i\\leq n$. There is no limit on the range of integers the bytecomputer can store, i.e., each $x_i$ can (in principle) have arbitrarily small or large value.\n\nProgram the bytecomputer so that it transforms the input sequence into a non - decreasing sequence (i.e., such that $x_1\\leq x_2\\leq\\cdots\\leq x_n$) with the minimum number of operations.", "inputFormat": "The first line of the standard input holds a single integer $n$ ($1\\leq n\\leq1000000$), the number of elements in the (bytecomputer's) input sequence.\n\nThe second line contains $n$ integers $x_1,x_2,\\cdots,x_n$ ($x_i\\in\\{-1, 0, 1\\}$) that are the successive elements of the (bytecomputer's) input sequence, separated by single spaces.\n\nIn tests worth 24% of the total points it holds that $n\\leq500$, and in tests worth 48% of the total points it holds that $n\\leq10000$.", "outputFormat": "The first and only line of the standard output should give one integer, the minimum number of operations the bytecomputer has to perform to make its input sequence non - decreasing, or the single word BRAK (Polish for *none*) if obtaining such a sequence is impossible. ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2013] BAJ-Bytecomputer", "background": null, "description": "给定一个由集合 $\\{-1, 0, 1\\}$ 中的 $n$ 个整数 $x_1, x_2, \\cdots, x_n$ 组成的序列。字节计算机是一种允许对序列进行以下操作的设备：对于任何 $1 \\leq i < n$，可以将 $x_{i+1}$ 改为 $x_{i+1} + x_i$。字节计算机可以存储的整数范围没有限制，即每个 $x_i$ 可以（原则上）具有任意小或大的值。\n\n编程实现字节计算机，使其将输入序列转换为非递减序列（即 $x_1 \\leq x_2 \\leq \\cdots \\leq x_n$），并使操作次数最少。", "inputFormat": "标准输入的第一行包含一个整数 $n$ ($1 \\leq n \\leq 1000000$)，表示（字节计算机的）输入序列中的元素个数。\n\n第二行包含 $n$ 个整数 $x_1, x_2, \\cdots, x_n$ ($x_i \\in \\{-1, 0, 1\\}$)，它们是（字节计算机的）输入序列的连续元素，元素之间用单个空格分隔。\n\n在占总分 24% 的测试中，$n \\leq 500$；在占总分 48% 的测试中，$n \\leq 10000$。", "outputFormat": "标准输出的第一行应输出一个整数，即字节计算机必须执行的最小操作次数，以使其输入序列成为非递减序列；如果无法获得这样的序列，则输出单词 BRAK（波兰语，意为“无”）。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3559", "type": "P", "difficulty": 7, "samples": [["LLLLPPLL\n", "0 0\n2 0\n2 2\n-1 2\n-1 -2\n1 -2\n1 -1\n0 -1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["计算几何", "2013", "POI（波兰）", "Special Judge"], "title": "[POI 2013] LAB-Maze", "background": null, "description": "注意：在比赛期间，你可以询问关于此问题任意三个提交的得分情况。\n\n拜特萨最近读了一个有趣的故事。\n\n故事的主人公是一位希腊王子，他用一根毛线击败了怪物，或诸如此类的情节。\n\n但故事中另一点让拜特萨着迷的是：高潮部分发生在一个迷宫中。\n\n从那时起，拜特萨就对迷宫产生了浓厚的兴趣。\n\n拜特萨在方格纸上绘制迷宫草图。\n\n每个草图是一个多边形（代表迷宫的墙壁），其边平行于纸张的边缘（即笛卡尔坐标系的坐标轴），且每两条相邻边相互垂直。\n\n拜特萨发现，如果将入口放置在迷宫的某条边（**不能是顶点**）上，那么通过始终将右手放在墙上行走，可以遍历整个迷宫并返回入口。\n\n此外，在迷宫遍历过程中，我们可以记录所采取的转弯方向。\n\n当从一面墙移动到另一面墙时，如果左转，我们记下字母 `L`；如果右转，则记下字母 `P`。\n\n拜特萨想知道，对于给定的由字母 `L` 和 `P` 组成的字符串，是否存在一个迷宫，其遍历过程恰好生成该字符串，如果是，则输出这个迷宫。", "inputFormat": "标准输入的第一行给出一个由字母 `L` 和 `P` 组成的字符串 $S$（$1 \\leq |S| \\leq 10^5$），描述了在迷宫遍历过程中连续转弯的序列。\n\n在占总分 $50\\%$ 的测试用例中，额外满足约束 $|S| \\leq 1000$。", "outputFormat": "如果没有迷宫与输入的描述相对应，则在标准输出上打印单词 `NIE`（波兰语中的“否”）。\n\n否则，应恰好输出 $|S|$ 行，指定任意一个与输入一致的迷宫，格式如下：\n\n第 $i$ 行包含两个整数 $x_i$ 和 $y_i$（用单个空格分隔），表示迷宫草图第 $i$ 个顶点的坐标。\n顶点需按多边形外围**逆时针**顺序输出；可以选择任意一个顶点作为第一个顶点，且无需指明入口的位置。", "hint": "翻译由 Deepseek-V3 完成，并进行了微调。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2013] LAB-Maze", "background": "", "description": "Note: During the contest, you may query the scores of any three submissions for this problem.\n\nBajtazar recently read an interesting story.\n\nIts hero was a Greek prince who defeated a monster with a ball of thread, or something like that.\n\nBut what fascinated Bajtazar was that the climax took place in a maze.\n\nSince then, Bajtazar has been very interested in mazes.\n\nHe sketches mazes on squared paper.\n\nEach sketch is a polygon (representing the maze walls) whose edges are parallel to the edges of the paper (i.e., to the axes of the Cartesian coordinate system), and every two consecutive edges are perpendicular.\n\nBajtazar found that if the entrance is placed on some edge of the maze (not at a vertex), then by always walking with his right hand on the wall, one can traverse the entire maze and return to the entrance.\n\nMoreover, during the traversal, we can record the directions of turns.\n\nWhen moving from one wall to the next, if we turn left, we write the letter 'L'; if we turn right, we write the letter 'P'.\n\nBajtazar wants to know whether, for a given string consisting of letters 'L' and 'P', there exists a maze whose traversal produces exactly that string, and if so, output such a maze.", "inputFormat": "The first line of the standard input contains a string $S$ consisting of letters 'L' and 'P' ($1 \\leq |S| \\leq 10^5$), describing the sequence of consecutive turns taken during the traversal of the maze.\n\nIn testcases worth 50% of the points, it additionally holds that $|S| \\leq 1000$.", "outputFormat": "If no maze corresponds to the input description, print the word 'NIE' (Polish for 'no') to the standard output.\n\nOtherwise, print exactly $|S|$ lines, specifying any maze consistent with the input, in the following format:\n\nOn the $i$-th line, print two integers $x_i$ and $y_i$ (separated by a single space), which are the coordinates of the $i$-th vertex of the maze sketch.\nThe vertices must be output in counterclockwise order along the outer boundary of the polygon; you may choose any vertex as the first one, and you do not need to indicate the entrance position.", "hint": "Translation by Deepseek-V3, with minor edits.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2013] LAB-Maze", "background": null, "description": "注意：在比赛期间，你可以询问关于此问题任意三个提交的得分情况。\n\n拜特萨最近读了一个有趣的故事。\n\n故事的主人公是一位希腊王子，他用一根毛线击败了怪物，或诸如此类的情节。\n\n但故事中另一点让拜特萨着迷的是：高潮部分发生在一个迷宫中。\n\n从那时起，拜特萨就对迷宫产生了浓厚的兴趣。\n\n拜特萨在方格纸上绘制迷宫草图。\n\n每个草图是一个多边形（代表迷宫的墙壁），其边平行于纸张的边缘（即笛卡尔坐标系的坐标轴），且每两条相邻边相互垂直。\n\n拜特萨发现，如果将入口放置在迷宫的某条边（**不能是顶点**）上，那么通过始终将右手放在墙上行走，可以遍历整个迷宫并返回入口。\n\n此外，在迷宫遍历过程中，我们可以记录所采取的转弯方向。\n\n当从一面墙移动到另一面墙时，如果左转，我们记下字母 `L`；如果右转，则记下字母 `P`。\n\n拜特萨想知道，对于给定的由字母 `L` 和 `P` 组成的字符串，是否存在一个迷宫，其遍历过程恰好生成该字符串，如果是，则输出这个迷宫。", "inputFormat": "标准输入的第一行给出一个由字母 `L` 和 `P` 组成的字符串 $S$（$1 \\leq |S| \\leq 10^5$），描述了在迷宫遍历过程中连续转弯的序列。\n\n在占总分 $50\\%$ 的测试用例中，额外满足约束 $|S| \\leq 1000$。", "outputFormat": "如果没有迷宫与输入的描述相对应，则在标准输出上打印单词 `NIE`（波兰语中的“否”）。\n\n否则，应恰好输出 $|S|$ 行，指定任意一个与输入一致的迷宫，格式如下：\n\n第 $i$ 行包含两个整数 $x_i$ 和 $y_i$（用单个空格分隔），表示迷宫草图第 $i$ 个顶点的坐标。\n顶点需按多边形外围**逆时针**顺序输出；可以选择任意一个顶点作为第一个顶点，且无需指明入口的位置。", "hint": "翻译由 Deepseek-V3 完成，并进行了微调。", "locale": "zh-CN"}}}
{"pid": "P3560", "type": "P", "difficulty": 4, "samples": [["7 3\n2 1 1\n1 2 3\n4 2 1 3 1 2 5\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "POI（波兰）", "哈希 hashing"], "title": "[POI 2013] LAN-Colorful Chain", "background": null, "description": "Little Bytie loves to play with colorful chains.\n\nHe already has quite an impressive collection, and some of them he likes    more than the others.\n\nEach chain consists of a certain number of colorful links.\n\nByteasar has noticed that Bytie's sense of aesthetics is very precise.\n\nIt turns out that Bytie finds a contiguous fragment of a chain nice if    it contains exactly    ![](http://main.edu.pl/images/OI20/lan-en-tex.1.png) links of color ![](http://main.edu.pl/images/OI20/lan-en-tex.2.png) links of color ![](http://main.edu.pl/images/OI20/lan-en-tex.3.png) links of color ![](http://main.edu.pl/images/OI20/lan-en-tex.4.png),    and moreover it contains no links of other colors.\n\nA chain's appeal is its number of (contiguous) fragments that are nice.\n\nBy trial and error, Byteasar has determined the values ![](http://main.edu.pl/images/OI20/lan-en-tex.5.png) and ![](http://main.edu.pl/images/OI20/lan-en-tex.6.png).\n\nNow he would like to buy a new chain, and therefore asks you to write a program to aid him in shopping.\n\n给定一个长度为 $n$ 的序列 $\\{a\\}$ 和 $m$ 个条件（每个条件中包含键 $c_i$ 和值 $l_i$），要求找出满足下列条件的子串的数量并输出：\n\n+ 对于 $m$ 个条件中存在的 $c_i$（$1\\le i\\le n$），子串中包含**恰好** $l_i$ 个 $c_i$；\n\n+ 对于 $m$ 个条件中不存在的键值，子串中不包含它。", "inputFormat": "The first line of the standard input gives two integers, ![](http://main.edu.pl/images/OI20/lan-en-tex.7.png) and ![](http://main.edu.pl/images/OI20/lan-en-tex.8.png)      (![](http://main.edu.pl/images/OI20/lan-en-tex.9.png)), separated by a single space.\n\nThese are the length of the chain and the length of a nice fragment's description.\n\nThe second line gives ![](http://main.edu.pl/images/OI20/lan-en-tex.10.png) integers, ![](http://main.edu.pl/images/OI20/lan-en-tex.11.png) (![](http://main.edu.pl/images/OI20/lan-en-tex.12.png)),      separated by single spaces.\n\nThe third line gives ![](http://main.edu.pl/images/OI20/lan-en-tex.13.png) integers, ![](http://main.edu.pl/images/OI20/lan-en-tex.14.png)      (![](http://main.edu.pl/images/OI20/lan-en-tex.15.png), ![](http://main.edu.pl/images/OI20/lan-en-tex.16.png) for ![](http://main.edu.pl/images/OI20/lan-en-tex.17.png)), also separated by single spaces.\n\nThe sequences ![](http://main.edu.pl/images/OI20/lan-en-tex.18.png) and ![](http://main.edu.pl/images/OI20/lan-en-tex.19.png) define a nice fragment of a chain - it has to contain exactly ![](http://main.edu.pl/images/OI20/lan-en-tex.20.png) links of color ![](http://main.edu.pl/images/OI20/lan-en-tex.21.png).\n\nThe fourth line gives ![](http://main.edu.pl/images/OI20/lan-en-tex.22.png) integers, ![](http://main.edu.pl/images/OI20/lan-en-tex.23.png) (![](http://main.edu.pl/images/OI20/lan-en-tex.24.png)),      separated by single spaces, that are the colors of successive links of      the chain.\n\nIn tests worth 50% of total points the constraint ![](http://main.edu.pl/images/OI20/lan-en-tex.25.png) holds in addition.\n\n先输入 $n$ 和 $m$，再输入 $m$ 个条件的 $l_i$，然后输入 $m$ 个条件的 $c_i$，最后输入 $a_i$。", "outputFormat": "Your program is to print a single integer, the number of nice contiguous    fragments in the chain, to the first and only line of the standard output.\n\n输出一行一个整数，表示满足条件的子串数量。", "hint": "### 数据范围：\n\n对于 $100\\%$ 的数据，$1\\leq m\\leq n \\leq 10^6$，$1\\leq a_i,l_i,c_i\\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2013] LAN-Colorful Chain", "background": "", "description": "Little Bytie loves to play with colorful chains. Each chain consists of a certain number of colorful links. Bytie finds a contiguous fragment of a chain nice if it contains exactly $l_i$ links of color $c_i$ for every $i$ in $[1, m]$, and moreover contains no links of any other colors. The appeal of a chain is the number of its contiguous fragments that are nice.\n\nGiven a sequence of length $n$ representing the colors of the chain and $m$ conditions (each condition gives a color $c_i$ and a required count $l_i$), count how many contiguous substrings are nice, that is:\n- For every $c_i$ among the $m$ conditions, the substring contains exactly $l_i$ occurrences of $c_i$.\n- For any color not listed among the $m$ conditions, the substring contains none of it.", "inputFormat": "- The first line contains two integers $n$ and $m$ ($1 \\le m \\le n \\le 10^6$). These are the length of the chain and the number of conditions.\n- The second line contains $m$ integers $l_1, l_2, \\dots, l_m$ ($1 \\le l_i \\le n$).\n- The third line contains $m$ integers $c_1, c_2, \\dots, c_m$ ($1 \\le c_i \\le n$). These define that a nice fragment must contain exactly $l_i$ links of color $c_i$ for each $i$ and no links of any other colors.\n- The fourth line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$), the colors of successive links of the chain.", "outputFormat": "Print a single integer, the number of nice contiguous fragments in the chain.", "hint": "Constraints:\n\nFor $100\\%$ of the testdata, $1 \\le m \\le n \\le 10^6$ and $1 \\le a_i, l_i, c_i \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2013] LAN-Colorful Chain", "background": null, "description": "Little Bytie loves to play with colorful chains.\n\nHe already has quite an impressive collection, and some of them he likes    more than the others.\n\nEach chain consists of a certain number of colorful links.\n\nByteasar has noticed that Bytie's sense of aesthetics is very precise.\n\nIt turns out that Bytie finds a contiguous fragment of a chain nice if    it contains exactly    ![](http://main.edu.pl/images/OI20/lan-en-tex.1.png) links of color ![](http://main.edu.pl/images/OI20/lan-en-tex.2.png) links of color ![](http://main.edu.pl/images/OI20/lan-en-tex.3.png) links of color ![](http://main.edu.pl/images/OI20/lan-en-tex.4.png),    and moreover it contains no links of other colors.\n\nA chain's appeal is its number of (contiguous) fragments that are nice.\n\nBy trial and error, Byteasar has determined the values ![](http://main.edu.pl/images/OI20/lan-en-tex.5.png) and ![](http://main.edu.pl/images/OI20/lan-en-tex.6.png).\n\nNow he would like to buy a new chain, and therefore asks you to write a program to aid him in shopping.\n\n给定一个长度为 $n$ 的序列 $\\{a\\}$ 和 $m$ 个条件（每个条件中包含键 $c_i$ 和值 $l_i$），要求找出满足下列条件的子串的数量并输出：\n\n+ 对于 $m$ 个条件中存在的 $c_i$（$1\\le i\\le n$），子串中包含**恰好** $l_i$ 个 $c_i$；\n\n+ 对于 $m$ 个条件中不存在的键值，子串中不包含它。", "inputFormat": "The first line of the standard input gives two integers, ![](http://main.edu.pl/images/OI20/lan-en-tex.7.png) and ![](http://main.edu.pl/images/OI20/lan-en-tex.8.png)      (![](http://main.edu.pl/images/OI20/lan-en-tex.9.png)), separated by a single space.\n\nThese are the length of the chain and the length of a nice fragment's description.\n\nThe second line gives ![](http://main.edu.pl/images/OI20/lan-en-tex.10.png) integers, ![](http://main.edu.pl/images/OI20/lan-en-tex.11.png) (![](http://main.edu.pl/images/OI20/lan-en-tex.12.png)),      separated by single spaces.\n\nThe third line gives ![](http://main.edu.pl/images/OI20/lan-en-tex.13.png) integers, ![](http://main.edu.pl/images/OI20/lan-en-tex.14.png)      (![](http://main.edu.pl/images/OI20/lan-en-tex.15.png), ![](http://main.edu.pl/images/OI20/lan-en-tex.16.png) for ![](http://main.edu.pl/images/OI20/lan-en-tex.17.png)), also separated by single spaces.\n\nThe sequences ![](http://main.edu.pl/images/OI20/lan-en-tex.18.png) and ![](http://main.edu.pl/images/OI20/lan-en-tex.19.png) define a nice fragment of a chain - it has to contain exactly ![](http://main.edu.pl/images/OI20/lan-en-tex.20.png) links of color ![](http://main.edu.pl/images/OI20/lan-en-tex.21.png).\n\nThe fourth line gives ![](http://main.edu.pl/images/OI20/lan-en-tex.22.png) integers, ![](http://main.edu.pl/images/OI20/lan-en-tex.23.png) (![](http://main.edu.pl/images/OI20/lan-en-tex.24.png)),      separated by single spaces, that are the colors of successive links of      the chain.\n\nIn tests worth 50% of total points the constraint ![](http://main.edu.pl/images/OI20/lan-en-tex.25.png) holds in addition.\n\n先输入 $n$ 和 $m$，再输入 $m$ 个条件的 $l_i$，然后输入 $m$ 个条件的 $c_i$，最后输入 $a_i$。", "outputFormat": "Your program is to print a single integer, the number of nice contiguous    fragments in the chain, to the first and only line of the standard output.\n\n输出一行一个整数，表示满足条件的子串数量。", "hint": "### 数据范围：\n\n对于 $100\\%$ 的数据，$1\\leq m\\leq n \\leq 10^6$，$1\\leq a_i,l_i,c_i\\leq n$。", "locale": "zh-CN"}}}
{"pid": "P3561", "type": "P", "difficulty": 6, "samples": [["4\n1\n1 1\n1 0 1", "4 1 2 3 4\n3 2 3 4\n3 3 4 2\n3 4 2 3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "POI（波兰）", "Special Judge"], "title": "[POI 2017] Turysta", "background": "", "description": "给出一个 $n$ 个点的有向图，任意两个点之间有且仅一条有向边。\n\n对于每个点 $v$，求出从 $v$ 出发的一条经过点数最多，且没有重复经过同一个点两次及两次以上的简单路径。", "inputFormat": "第一行包含一个正整数 $n$，表示点数。\n\n接下来的 $n-1$ 行，其中的第 $i$ 行有 $i-1$ 个数。\n\n如果第 $j$ 个数是 $1$，那么表示有向边 $j\\rightarrow i+1$ ，如果是 $0$，那么表示有向边 $j\\leftarrow i+1$。", "outputFormat": "输出 $n$ 行，第 $i$ 行首先包含一个正整数 $k$，表示从 $i$ 点出发的最优路径所经过的点数。\n\n接下来 $k$ 个正整数，依次表示路径上的每个点。\n\n若有多组最优解，输出任意一组。\n\n**本题使用 SPJ （Claris 制作）**", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 2 \\times 10^3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2017] Turysta", "background": "", "description": "给出一个 $n$ 个点的有向图，任意两个点之间有且仅一条有向边。\n\n对于每个点 $v$，求出从 $v$ 出发的一条经过点数最多，且没有重复经过同一个点两次及两次以上的简单路径。", "inputFormat": "第一行包含一个正整数 $n$，表示点数。\n\n接下来的 $n-1$ 行，其中的第 $i$ 行有 $i-1$ 个数。\n\n如果第 $j$ 个数是 $1$，那么表示有向边 $j\\rightarrow i+1$ ，如果是 $0$，那么表示有向边 $j\\leftarrow i+1$。", "outputFormat": "输出 $n$ 行，第 $i$ 行首先包含一个正整数 $k$，表示从 $i$ 点出发的最优路径所经过的点数。\n\n接下来 $k$ 个正整数，依次表示路径上的每个点。\n\n若有多组最优解，输出任意一组。\n\n**本题使用 SPJ （Claris 制作）**", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 2 \\times 10^3$。", "locale": "zh-CN"}}}
{"pid": "P3562", "type": "P", "difficulty": 6, "samples": [["3 6\n1 2 2 4\n3 1 5 1\n3 2 2 3\n3 3 3 4\n2 2 2 2\n6 1 3 5", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "POI（波兰）"], "title": "[POI 2013] LAS-Laser", "background": "", "description": "平面上有些线段，你最多从原点射出 $k$ 条射线，穿过最多的线段，且使得每条线段最多被穿过 $1$ 次。\n\n求最多能穿过多少线段。", "inputFormat": "第一行两个整数 $k$，$n$，其中 $n$ 是线段数量。  \n\n之后 $n$ 行，每行四个整数 $x_1,y_1,x_2,y_2$ 表示一条线段。", "outputFormat": "输出一个整数，表示最多能穿过几条线段。", "hint": "对于 $100\\%$ 的数据，$1 \\leq k\\le100$，$1 \\leq n\\le5\\times10^5$，$1 \\leq x_1, y_1, x_2, y_2 \\leq 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2013] LAS-Laser", "background": "", "description": "There are some line segments in the plane. You may shoot at most $k$ rays starting from the origin to intersect as many segments as possible, and each segment may be counted at most once.\n\nFind the maximum number of segments that can be intersected.", "inputFormat": "The first line contains two integers $k$, $n$, where $n$ is the number of segments.  \nThen $n$ lines follow, each containing four integers $x_1, y_1, x_2, y_2$ describing a segment.", "outputFormat": "Output a single integer, the maximum number of segments that can be intersected.", "hint": "For $100\\%$ of the testdata, $1 \\leq k \\leq 100$, $1 \\leq n \\leq 5\\times10^5$, $1 \\leq x_1, y_1, x_2, y_2 \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2013] LAS-Laser", "background": "", "description": "平面上有些线段，你最多从原点射出 $k$ 条射线，穿过最多的线段，且使得每条线段最多被穿过 $1$ 次。\n\n求最多能穿过多少线段。", "inputFormat": "第一行两个整数 $k$，$n$，其中 $n$ 是线段数量。  \n\n之后 $n$ 行，每行四个整数 $x_1,y_1,x_2,y_2$ 表示一条线段。", "outputFormat": "输出一个整数，表示最多能穿过几条线段。", "hint": "对于 $100\\%$ 的数据，$1 \\leq k\\le100$，$1 \\leq n\\le5\\times10^5$，$1 \\leq x_1, y_1, x_2, y_2 \\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3563", "type": "P", "difficulty": 6, "samples": [["4\n1 2\n1 3\n1 4\n", "3 5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "动态规划 DP", "贪心", "2013", "POI（波兰）"], "title": "[POI 2013] POL-Polarization", "background": "", "description": "Everyone knew it would only be a matter of time. So what? Faced for years on, a peril becomes the every-day reality. It loses its meaning...\n\nToday the letter of the Bitotian char Bittard to the Byteotian king Byteasar was released to the public. Bitotia requested annexation of the whole Byteotia on pain of using the Bit Polarizing Magnet (BPM). If used, the BPM would make each and every road in Byteotia unidirectional. The enemy knows only too well that this could be a fatal blow to the minimalist Byteotian infrastructure - there is a unique way between each pair of towns.\n\nHow badly can the BPM damage the Byteotian infrastructure? Determine the minimum and the maximum number of such pairs of towns that it will still be possible to travel from one of them to the other while observing the new roads orientation.", "inputFormat": "The first line of the standard input gives a single integer n (1 ≤ n ≤ 250,000), the number of towns in Byteotia. The n-1 lines that follow describe these roads. Each such line holds two integers, u and v (1 ≤ u ≤ v ≤ n), which indicate that there is a direct road (still bidirectional at the moment) linking the towns no. u and v.", "outputFormat": "Two integers should be printed to the first and only line of the standard output. \n\nThe first number should be the minimum and the second - the maximum number of pairs of towns which could remain connected (though in one direction only) after the roads are polarized.", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2013] POL-Polarization", "background": "", "description": "Everyone knew it would only be a matter of time. So what? Faced for years on, a peril becomes the every-day reality. It loses its meaning...\n\nToday the letter of the Bitotian char Bittard to the Byteotian king Byteasar was released to the public. Bitotia requested annexation of the whole Byteotia on pain of using the Bit Polarizing Magnet (BPM). If used, the BPM would make each and every road in Byteotia unidirectional. The enemy knows only too well that this could be a fatal blow to the minimalist Byteotian infrastructure - there is a unique way between each pair of towns.\n\nHow badly can the BPM damage the Byteotian infrastructure? Determine the minimum and the maximum number of such pairs of towns that it will still be possible to travel from one of them to the other while observing the new roads orientation.", "inputFormat": "The first line of the standard input gives a single integer n (1 ≤ n ≤ 250,000), the number of towns in Byteotia. The n-1 lines that follow describe these roads. Each such line holds two integers, u and v (1 ≤ u ≤ v ≤ n), which indicate that there is a direct road (still bidirectional at the moment) linking the towns no. u and v.", "outputFormat": "Two integers should be printed to the first and only line of the standard output. \n\nThe first number should be the minimum and the second - the maximum number of pairs of towns which could remain connected (though in one direction only) after the roads are polarized.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2013] POL-Polarization", "background": null, "description": "每个人都知道这只是时间问题。那么又如何呢？\n\n面对多年的威胁，这种危险成为了日常现实。\n\n它失去了意义……\n\n今天，Bitotia 的 char Bittard 给 Byteotia 国王 Byteasar 的信被公开了。\n\nBitotia 要求吞并整个 Byteotia，否则将使用 Bit 极化磁铁（BPM）。\n\n如果使用，BPM 将使 Byteotia 的每条道路变为单向。\n\n敌人非常清楚，这可能会对极简的 Byteotia 基础设施造成致命打击——在每对城镇之间只有唯一的路径。\n\nBPM 能对 Byteotia 的基础设施造成多大的破坏？\n\n确定在新的道路方向下，仍然可以从一个城镇到另一个城镇的最小和最大城镇对数。", "inputFormat": "标准输入的第一行给出一个整数 $n$ ($1 \\leq n \\leq 250\\,000$)，表示 Byteotia 中的城镇数量。\n\n接下来的 $n-1$ 行描述这些道路。\n\n每行包含两个整数，$a$ 和 $b$ ($1 \\leq a, b \\leq n$)，表示目前仍为双向的直接道路连接城镇 $a$ 和 $b$。\n\n在占总分 60% 的测试中，额外的约束 $n \\leq 5\\,000$ 成立；此外，在其中一些占总分 30% 的测试中，甚至有 $n \\leq 1\\,000$。", "outputFormat": "标准输出的第一行应打印两个整数。\n\n第一个数字应为在道路极化后仍然可以连接的城镇对数的最小值，第二个数字应为最大值（尽管仅为单向）。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3564", "type": "P", "difficulty": 6, "samples": [["6\njpjppj\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "二分", "POI（波兰）", "前缀和", "ST 表", "单调栈"], "title": "[POI 2014] BAR-Salad Bar", "background": "", "description": "Bytea went to a salad bar.\n\nThere are $n$ fruits one next to another on the bar counter.\n\nSpecifically, these are apples and oranges.\n\nBytea can pick any contiguous part of the line of fruits for her salad.\n\nThe fruits she chooses will be added to the salad either from left to right or from right to left.\n\nAs Bytea loves oranges, she requires that throughout the salad making process, the number of oranges    in it should always be no smaller than the number of apples, regardless of whether these are added %    from left to right or from right to left.\n\nHelp Bytea out by writing a program that will find the longest contiguous part of the line of fruits    that satisfies her requirements.\n\n有一个长度为n的字符串，每一位只会是p或j。求一个最长子串，使得不管是从左往右还是从右往左取，都保证每时每刻已取出的p的个数不小于j的个数。\n", "inputFormat": "The first line of the standard input contains a single integer $n$ ($1\\le n\\le 1\\ 000\\ 000$), denoting the number of fruits.\n\nThe next line contains a string of $n$ characters $a_1,a_2,\\cdots,a_n$ ($a_i\\in \\{j,p\\}$).\n\nThese stand for Polish names of apples and oranges: jab\\l{ka} and pomara\\'ncze).\n\nConsequently, if $a_i=j$, then the $i$-th fruit in a line is an apple,      and otherwise it is an orange.\n", "outputFormat": "The first and only line of the standard output should contain a single integer equal to the number of fruits in the longest contiguous part of the line that satisfies Bytea's requirements.\n\nNote that it could be the case that $0$ is the correct result.\n", "hint": "有一个长度为n的字符串，每一位只会是p或j。求一个最长子串，使得不管是从左往右还是从右往左取，都保证每时每刻已取出的p的个数不小于j的个数。\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] BAR-Salad Bar", "background": "", "description": "Bytea went to a salad bar.\n\nThere are $n$ fruits lined up on the bar counter.\n\nSpecifically, these are apples and oranges.\n\nBytea can pick any contiguous segment of the line of fruits for her salad.\n\nThe fruits she chooses will be added to the salad either from left to right or from right to left.\n\nAs Bytea loves oranges, she requires that throughout the salad-making process, the number of oranges in the salad should always be no smaller than the number of apples, regardless of whether the fruits are added from left to right or from right to left.\n\nHelp Bytea by writing a program that finds the longest contiguous segment of the line of fruits that satisfies her requirements.", "inputFormat": "The first line of the standard input contains a single integer $n$ ($1 \\le n \\le 1\\ 000\\ 000$), denoting the number of fruits.\n\nThe next line contains a string of $n$ characters $a_1, a_2, \\cdots, a_n$ ($a_i \\in \\{j, p\\}$).\n\nThese stand for Polish names of apples and oranges: jab\\l{ka} and pomara\\'ncze.\n\nConsequently, if $a_i = j$, then the $i$-th fruit in the line is an apple, and otherwise it is an orange.", "outputFormat": "The first and only line of the standard output should contain a single integer equal to the number of fruits in the longest contiguous segment that satisfies Bytea's requirements.\n\nNote that it could be the case that $0$ is the correct result.", "hint": "Given a string of length $n$ consisting only of 'p' and 'j', find the longest substring such that, whether you take it from left to right or from right to left, at every moment the number of 'p' taken is no less than the number of 'j'.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] BAR-Salad Bar", "background": "", "description": "Bytea went to a salad bar.\n\nThere are $n$ fruits one next to another on the bar counter.\n\nSpecifically, these are apples and oranges.\n\nBytea can pick any contiguous part of the line of fruits for her salad.\n\nThe fruits she chooses will be added to the salad either from left to right or from right to left.\n\nAs Bytea loves oranges, she requires that throughout the salad making process, the number of oranges    in it should always be no smaller than the number of apples, regardless of whether these are added %    from left to right or from right to left.\n\nHelp Bytea out by writing a program that will find the longest contiguous part of the line of fruits    that satisfies her requirements.\n\n有一个长度为n的字符串，每一位只会是p或j。求一个最长子串，使得不管是从左往右还是从右往左取，都保证每时每刻已取出的p的个数不小于j的个数。\n", "inputFormat": "The first line of the standard input contains a single integer $n$ ($1\\le n\\le 1\\ 000\\ 000$), denoting the number of fruits.\n\nThe next line contains a string of $n$ characters $a_1,a_2,\\cdots,a_n$ ($a_i\\in \\{j,p\\}$).\n\nThese stand for Polish names of apples and oranges: jab\\l{ka} and pomara\\'ncze).\n\nConsequently, if $a_i=j$, then the $i$-th fruit in a line is an apple,      and otherwise it is an orange.\n", "outputFormat": "The first and only line of the standard output should contain a single integer equal to the number of fruits in the longest contiguous part of the line that satisfies Bytea's requirements.\n\nNote that it could be the case that $0$ is the correct result.\n", "hint": "有一个长度为n的字符串，每一位只会是p或j。求一个最长子串，使得不管是从左往右还是从右往左取，都保证每时每刻已取出的p的个数不小于j的个数。\n", "locale": "zh-CN"}}}
{"pid": "P3565", "type": "P", "difficulty": 5, "samples": [["7\n1 2\n5 7\n2 5\n2 3\n5 6\n4 5\n", "5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["动态规划 DP", "2014", "POI（波兰）", "树形 DP"], "title": "[POI 2014] HOT-Hotels", "background": "", "description": "There are $n$ towns in Byteotia, connected with only $n-1$ roads.\n\nEach road directly links two towns.\n\nAll the roads have the same length and are two way.\n\nIt is known that every town can be reached from every other town    via a route consisting of one or more (direct-link) roads.\n\nIn other words, the road network forms a tree.\n\nByteasar, the king of Byteotia, wants three luxury hotels    erected to attract tourists from all over the world.\n\nThe king desires that the hotels be in different towns    and at the same distance one from each other.\n\nHelp the king out by writing a program that determines the number    of possible locations of the hotel triplet in Byteotia.", "inputFormat": "The first line of the standard input contains a single integer $n$ ($1\\le n\\le 5\\ 000$),   the number of towns in Byteotia.\n\nThe towns are numbered from $1$ to $n$.\n\nThe Byteotian road network is then described in $n-1$ lines.\n\nEach line contains two integers $a$ and $b$ ($1\\le a\\le b\\le n$) ,   separated by a single space, that indicate there is   a direct road between the towns $a$ and $b$.\n", "outputFormat": "The first and only line of the standard output should contain a single integer    equal to the number of possible placements of the hotels.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2014] HOT-Hotels", "background": "", "description": "There are $n$ towns in Byteotia, connected with only $n-1$ roads.\n\nEach road directly links two towns.\n\nAll the roads have the same length and are two way.\n\nIt is known that every town can be reached from every other town    via a route consisting of one or more (direct-link) roads.\n\nIn other words, the road network forms a tree.\n\nByteasar, the king of Byteotia, wants three luxury hotels    erected to attract tourists from all over the world.\n\nThe king desires that the hotels be in different towns    and at the same distance one from each other.\n\nHelp the king out by writing a program that determines the number    of possible locations of the hotel triplet in Byteotia.", "inputFormat": "The first line of the standard input contains a single integer $n$ ($1\\le n\\le 5\\ 000$),   the number of towns in Byteotia.\n\nThe towns are numbered from $1$ to $n$.\n\nThe Byteotian road network is then described in $n-1$ lines.\n\nEach line contains two integers $a$ and $b$ ($1\\le a\\le b\\le n$) ,   separated by a single space, that indicate there is   a direct road between the towns $a$ and $b$.\n", "outputFormat": "The first and only line of the standard output should contain a single integer    equal to the number of possible placements of the hotels.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2014] HOT-Hotels", "background": "", "description": "在 Byteotia 有 $n$ 个城镇，通过 $n-1$ 条道路连接。\n\n每条道路直接连接两个城镇。\n\n所有的道路长度相同，并且是双向的。\n\n已知每个城镇都可以通过一条或多条（直接连接的）道路到达其他城镇。\n\n换句话说，道路网络形成了一棵树。\n\nByteotia 的国王 Byteasar 希望建造三家豪华酒店，以吸引来自世界各地的游客。\n\n国王希望这些酒店位于不同的城镇，并且彼此之间的距离相同。\n\n请通过编写程序来帮助国王，确定在 Byteotia 中可能的酒店三元组位置的数量。", "inputFormat": "标准输入的第一行包含一个整数 $n$ ($1\\le n\\le 5\\ 000$)，表示 Byteotia 中的城镇数量。\n\n城镇编号从 $1$ 到 $n$。\n\n接下来 $n-1$ 行描述了 Byteotia 的道路网络。\n\n每行包含两个整数 $a$ 和 $b$ ($1\\le a\\le b\\le n$)，用一个空格分隔，表示在城镇 $a$ 和 $b$ 之间有一条直接的道路。", "outputFormat": "标准输出的第一行应包含一个整数，表示可能的酒店位置的数量。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3566", "type": "P", "difficulty": 6, "samples": [["3 3 1\n2 3 3\n", "3 2 1 3 2 3 2 1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2014", "POI（波兰）", "Special Judge"], "title": "[POI 2014] KLO-Bricks", "background": "", "description": "Little Bitie and his friends spent the whole yesterday playing    with colorful bricks in the kindergarten.\n\nInitially they made building models but they quickly got bored with that.\n\nThen they decided to place the bricks in a line, one after another.\n\nTo avoid a dull look, they tried to avoid putting two bricks of the same    color next to each other.\n\nAfter a long while they succeeded in placing all the bricks while observing    this rule.\n\nThen the day care was over, and the children went home with their parents.\n\nToday Bitie came to the kindergarten early.\n\nHe was satisfied to see that their yesterday's creation was still standing.\n\nBut then he tripped over in a most unfortunate way,    falling right on the line of bricks, which all mixed in a pile.\n\nThe boy quickly sorted them by color and wondered how best to quickly    reassemble the perfect line.\n\nHe managed to recall what were the colors of the two bricks on both end of the line.\n\nHelp little Bitie out and tell him how to order the bricks in a line so that    no two bricks of the same color are next to each other and the bricks at the ends    of the line have the colors that he recalled.\n\nNote that Bitie could have made a mistake in recalling the two colors    or perhaps he did not find some of the blocks after falling into them,    so the reconstruction might not be possible.", "inputFormat": "There are three integers in the first line of the standard input,    $k$,$p$, and $q$ ($1\\le k\\le 1 000 000$,$1\\le p,q\\le k$), separated by single spaces,    denoting the number of brick colors, and the colors of    the first and the last brick in the desired arrangement, respectively.\n\nIn the second line, there are $k$ integers,$i_{1},i_{2},...,i{k}$ ($1\\le i_{j}\\le 1 000 000$),    separated by single spaces.\n\nThe number $i_{j}$ signifies that Bitie has exactly $i_{j}$ bricks    of color $j$.\n\nYou may assume that the total number of bricks does not exceed one million, i.e., that $n=i_1+i_2+\\cdots+i_k\\le 1\\ 000\\ 000$.\n", "outputFormat": "Your program should print $n$ integers to the standard output,    separated by single spaces.\n\nThe numbers should represent the colors of successive bricks in    an arrangement that satisfies aforementioned constraints.\n\nIf no such arrangement exists, your program should print only    a single integer: $0$.\n\nIf there are several correct answers, your program can pick one    arbitrarily.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2014] KLO-Bricks", "background": "", "description": "Little Bitie and his friends spent the whole yesterday playing    with colorful bricks in the kindergarten.\n\nInitially they made building models but they quickly got bored with that.\n\nThen they decided to place the bricks in a line, one after another.\n\nTo avoid a dull look, they tried to avoid putting two bricks of the same    color next to each other.\n\nAfter a long while they succeeded in placing all the bricks while observing    this rule.\n\nThen the day care was over, and the children went home with their parents.\n\nToday Bitie came to the kindergarten early.\n\nHe was satisfied to see that their yesterday's creation was still standing.\n\nBut then he tripped over in a most unfortunate way,    falling right on the line of bricks, which all mixed in a pile.\n\nThe boy quickly sorted them by color and wondered how best to quickly    reassemble the perfect line.\n\nHe managed to recall what were the colors of the two bricks on both end of the line.\n\nHelp little Bitie out and tell him how to order the bricks in a line so that    no two bricks of the same color are next to each other and the bricks at the ends    of the line have the colors that he recalled.\n\nNote that Bitie could have made a mistake in recalling the two colors    or perhaps he did not find some of the blocks after falling into them,    so the reconstruction might not be possible.", "inputFormat": "There are three integers in the first line of the standard input,    $k$,$p$, and $q$ ($1\\le k\\le 1 000 000$,$1\\le p,q\\le k$), separated by single spaces,    denoting the number of brick colors, and the colors of    the first and the last brick in the desired arrangement, respectively.\n\nIn the second line, there are $k$ integers,$i_{1},i_{2},...,i{k}$ ($1\\le i_{j}\\le 1 000 000$),    separated by single spaces.\n\nThe number $i_{j}$ signifies that Bitie has exactly $i_{j}$ bricks    of color $j$.\n\nYou may assume that the total number of bricks does not exceed one million, i.e., that $n=i_1+i_2+\\cdots+i_k\\le 1\\ 000\\ 000$.\n", "outputFormat": "Your program should print $n$ integers to the standard output,    separated by single spaces.\n\nThe numbers should represent the colors of successive bricks in    an arrangement that satisfies aforementioned constraints.\n\nIf no such arrangement exists, your program should print only    a single integer: $0$.\n\nIf there are several correct answers, your program can pick one    arbitrarily.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2014] KLO-Bricks", "background": null, "description": "现在你有 $k$ 种颜色的砖块，已知每种颜色砖块的数量，问是否有一种方案可以将砖块放成一排并且第一块和最后一块砖块的颜色为 $p,q$ 且相邻的砖块颜色不同，如果没有合法方案则输出 $0$。", "inputFormat": "第一行输入三个整数 $k,p,q$ 分别代表砖块有 $k$ 种颜色，第一块和最后一块的砖块颜色分别是 $p,q$，第二行输入 $k$ 个数，第 $j$ 个数表示颜色为 $j$ 砖块的数量。", "outputFormat": "输出一个排列，要求用完全部砖块并且满足上述约束条件，如果有多个正确答案只需要输出其中一种，特别的，如果无解输出 $0$。在最后一个数字后请不要输出空格。", "hint": "$1 \\leq k \\leq 10^6,1\\leq p,q \\leq k$。\n\n其中保证砖块总数量之和不超过 $10^6$。", "locale": "zh-CN"}}}
{"pid": "P3567", "type": "P", "difficulty": 5, "samples": [["7 5\n1 1 3 2 3 4 3\n1 3\n1 4\n3 7\n1 7\n6 6\n", "1\n0\n3\n0\n4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "线段树", "POI（波兰）", "可持久化线段树", "可持久化", "随机化"], "title": "[POI 2014] KUR-Couriers", "background": "", "description": "Byteasar works for the BAJ company, which sells computer games.\n\nThe BAJ company cooperates with many courier companies    that deliver the games sold by the BAJ company to its customers.\n\nByteasar is inspecting the cooperation of the BAJ company with the couriers.\n\nHe has a log of successive packages with the courier company that made the delivery    specified for each package.\n\nHe wants to make sure that no courier company had an unfair advantage over the others.\n\nIf a given courier company delivered more than half of all packages sent in some period of time,    we say that it dominated in that period.\n\nByteasar wants to find out which courier companies dominated in certain periods of time, if any.\n\nHelp Byteasar out!\n\nWrite a program that determines a dominating courier company or that there was none.\n\n给一个数列，每次询问一个区间内有没有一个数出现次数超过一半\n", "inputFormat": "The first line of the standard input contains two integers, ![](http://main.edu.pl/images/OI21/kur-en-tex.1.png) and ![](http://main.edu.pl/images/OI21/kur-en-tex.2.png) (![](http://main.edu.pl/images/OI21/kur-en-tex.3.png)),    separated by a single space, that are the number of packages shipped by the BAJ company    and the number of time periods for which the dominating courier is to be determined, respectively.\n\nThe courier companies are numbered from ![](http://main.edu.pl/images/OI21/kur-en-tex.4.png) to (at most) ![](http://main.edu.pl/images/OI21/kur-en-tex.5.png).\n\nThe second line of input contains ![](http://main.edu.pl/images/OI21/kur-en-tex.6.png) integers, ![](http://main.edu.pl/images/OI21/kur-en-tex.7.png) (![](http://main.edu.pl/images/OI21/kur-en-tex.8.png)),    separated by single spaces;    ![](http://main.edu.pl/images/OI21/kur-en-tex.9.png) is the number of the courier company that delivered the ![](http://main.edu.pl/images/OI21/kur-en-tex.10.png)-th package (in shipment chronology).\n\nThe ![](http://main.edu.pl/images/OI21/kur-en-tex.11.png) lines that follow specify the time period queries, one per line.\n\nEach query is specified by two integers, ![](http://main.edu.pl/images/OI21/kur-en-tex.12.png) and ![](http://main.edu.pl/images/OI21/kur-en-tex.13.png) (![](http://main.edu.pl/images/OI21/kur-en-tex.14.png)),    separated by a single space.\n\nThese mean that the courier company dominating in the period between the shipments of the    ![](http://main.edu.pl/images/OI21/kur-en-tex.15.png)-th and the ![](http://main.edu.pl/images/OI21/kur-en-tex.16.png)-th package, including those, is to be determined.\n\nIn tests worth ![](http://main.edu.pl/images/OI21/kur-en-tex.17.png) of total score, the condition ![](http://main.edu.pl/images/OI21/kur-en-tex.18.png) holds,    and in tests worth ![](http://main.edu.pl/images/OI21/kur-en-tex.19.png) of total score ![](http://main.edu.pl/images/OI21/kur-en-tex.20.png).\n", "outputFormat": "The answers to successive queries should be printed to the standard output, one per line.\n\n(Thus a total of ![](http://main.edu.pl/images/OI21/kur-en-tex.21.png) lines should be printed.)    Each line should hold a single integer: the number of the courier company that dominated    in the corresponding time period, or ![](http://main.edu.pl/images/OI21/kur-en-tex.22.png) if there was no such company.\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] KUR-Couriers", "background": "", "description": "Byteasar works for the BAJ company, which sells computer games.\n\nThe BAJ company cooperates with many courier companies that deliver the games sold by the BAJ company to its customers.\n\nByteasar is inspecting the cooperation of the BAJ company with the couriers.\n\nHe has a log of successive packages with the courier company that made the delivery specified for each package.\n\nHe wants to make sure that no courier company had an unfair advantage over the others.\n\nIf a given courier company delivered more than half of all packages sent in some period of time, we say that it dominated in that period.\n\nByteasar wants to find out which courier companies dominated in certain periods of time, if any.\n\nHelp Byteasar out!\n\nWrite a program that determines a dominating courier company or that there was none.\n\nGiven a sequence of integers, for each query on an interval, determine whether there is a number whose occurrences are more than half of the interval length; if so, report it, otherwise report $0$.", "inputFormat": "The first line contains two integers $n$ and $m$, which are the number of packages shipped by the BAJ company and the number of time periods (queries) for which the dominating courier is to be determined, respectively.\n\nThe courier companies are numbered from $1$ to (at most) $C$.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ separated by single spaces; $a_i$ is the number of the courier company that delivered the $i$-th package (in shipment chronology).\n\nThe next $m$ lines each describe one time period. Each line contains two integers $l$ and $r$, separated by a single space. These mean that the courier company dominating in the period between the shipments of the $l$-th and the $r$-th package, inclusive, is to be determined.", "outputFormat": "Print $m$ lines. Each line should contain a single integer: the number of the courier company that dominated in the corresponding time period, or $0$ if there was no such company.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] KUR-Couriers", "background": "", "description": "Byteasar works for the BAJ company, which sells computer games.\n\nThe BAJ company cooperates with many courier companies    that deliver the games sold by the BAJ company to its customers.\n\nByteasar is inspecting the cooperation of the BAJ company with the couriers.\n\nHe has a log of successive packages with the courier company that made the delivery    specified for each package.\n\nHe wants to make sure that no courier company had an unfair advantage over the others.\n\nIf a given courier company delivered more than half of all packages sent in some period of time,    we say that it dominated in that period.\n\nByteasar wants to find out which courier companies dominated in certain periods of time, if any.\n\nHelp Byteasar out!\n\nWrite a program that determines a dominating courier company or that there was none.\n\n给一个数列，每次询问一个区间内有没有一个数出现次数超过一半\n", "inputFormat": "The first line of the standard input contains two integers, ![](http://main.edu.pl/images/OI21/kur-en-tex.1.png) and ![](http://main.edu.pl/images/OI21/kur-en-tex.2.png) (![](http://main.edu.pl/images/OI21/kur-en-tex.3.png)),    separated by a single space, that are the number of packages shipped by the BAJ company    and the number of time periods for which the dominating courier is to be determined, respectively.\n\nThe courier companies are numbered from ![](http://main.edu.pl/images/OI21/kur-en-tex.4.png) to (at most) ![](http://main.edu.pl/images/OI21/kur-en-tex.5.png).\n\nThe second line of input contains ![](http://main.edu.pl/images/OI21/kur-en-tex.6.png) integers, ![](http://main.edu.pl/images/OI21/kur-en-tex.7.png) (![](http://main.edu.pl/images/OI21/kur-en-tex.8.png)),    separated by single spaces;    ![](http://main.edu.pl/images/OI21/kur-en-tex.9.png) is the number of the courier company that delivered the ![](http://main.edu.pl/images/OI21/kur-en-tex.10.png)-th package (in shipment chronology).\n\nThe ![](http://main.edu.pl/images/OI21/kur-en-tex.11.png) lines that follow specify the time period queries, one per line.\n\nEach query is specified by two integers, ![](http://main.edu.pl/images/OI21/kur-en-tex.12.png) and ![](http://main.edu.pl/images/OI21/kur-en-tex.13.png) (![](http://main.edu.pl/images/OI21/kur-en-tex.14.png)),    separated by a single space.\n\nThese mean that the courier company dominating in the period between the shipments of the    ![](http://main.edu.pl/images/OI21/kur-en-tex.15.png)-th and the ![](http://main.edu.pl/images/OI21/kur-en-tex.16.png)-th package, including those, is to be determined.\n\nIn tests worth ![](http://main.edu.pl/images/OI21/kur-en-tex.17.png) of total score, the condition ![](http://main.edu.pl/images/OI21/kur-en-tex.18.png) holds,    and in tests worth ![](http://main.edu.pl/images/OI21/kur-en-tex.19.png) of total score ![](http://main.edu.pl/images/OI21/kur-en-tex.20.png).\n", "outputFormat": "The answers to successive queries should be printed to the standard output, one per line.\n\n(Thus a total of ![](http://main.edu.pl/images/OI21/kur-en-tex.21.png) lines should be printed.)    Each line should hold a single integer: the number of the courier company that dominated    in the corresponding time period, or ![](http://main.edu.pl/images/OI21/kur-en-tex.22.png) if there was no such company.\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3568", "type": "P", "difficulty": 7, "samples": [["9\n0 0 5 0 17 0 0 0 21\n8 0 0 3 16 0 0 25 0\n0 0 0 0 0 0 0 0 23\n", "7 6 5 4 17 18 19 20 21\n8 1 2 3 16 15 26 25 22\n9 10 11 12 13 14 27 24 23\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "POI（波兰）", "Special Judge"], "title": "[POI 2014] WAZ-Snake", "background": "", "description": "A snake fills a ![](http://main.edu.pl/images/OI21/waz-en-tex.1.png) board completely.\n\nSuccessive segments of the snake are numbered from ![](http://main.edu.pl/images/OI21/waz-en-tex.2.png) to ![](http://main.edu.pl/images/OI21/waz-en-tex.3.png).\n\nThe segments with successive numbers (i.e., 1 and 2, 2 and 3, 3 and 4...) occupy squares  that share an edge.\n\nFor example, a snake can fill a ![](http://main.edu.pl/images/OI21/waz-en-tex.4.png) board as follows:\n\nThe snake's segment numbers in some of the squares have been erased.\n\n  Can you reconstruct the snake?\n\n一只蛇被放在了一块3\\*n的木板上（填充满了），蛇被分为多个小段，小段的编号是1到3n。比如说蛇可以填写一个3\\*9的木板，如下所示：\n\n\n部分木板上的蛇段已删遮挡。\n\n\n你能重建蛇吗？\n", "inputFormat": "In the first line of the standard input, there is a single integer ![](http://main.edu.pl/images/OI21/waz-en-tex.5.png)  (![](http://main.edu.pl/images/OI21/waz-en-tex.6.png)), the length of the board.\n\nThe three lines that follow describe the board;  the ![](http://main.edu.pl/images/OI21/waz-en-tex.7.png)-th of them contains ![](http://main.edu.pl/images/OI21/waz-en-tex.8.png) integers ![](http://main.edu.pl/images/OI21/waz-en-tex.9.png)  (![](http://main.edu.pl/images/OI21/waz-en-tex.10.png) for ![](http://main.edu.pl/images/OI21/waz-en-tex.11.png)).\n\nIf ![](http://main.edu.pl/images/OI21/waz-en-tex.12.png), then ![](http://main.edu.pl/images/OI21/waz-en-tex.13.png) is the number of the snake's segment  occupying the ![](http://main.edu.pl/images/OI21/waz-en-tex.14.png)-th square of the ![](http://main.edu.pl/images/OI21/waz-en-tex.15.png)-th row of the board.\n\nIf on the other hand ![](http://main.edu.pl/images/OI21/waz-en-tex.16.png), then the number of the snake's segment  on this square is unknown.\n\nIn tests worth 15% of the total score ![](http://main.edu.pl/images/OI21/waz-en-tex.17.png) holds,  in those worth 40% of the total score ![](http://main.edu.pl/images/OI21/waz-en-tex.18.png) holds,  and finally, in those worth 70% of the total score ![](http://main.edu.pl/images/OI21/waz-en-tex.19.png) holds.\n\n在标准输入的第一行中，有一个整数n（1<=n<=1000），即板的长度。\n\n\n下面三行描述木板的情况，第i行是n个整数aij（0<=aij<=3n）(1<=j<=n)。\n\n\n如果aij大于0，那么aij就是蛇段的第aij部分\n\n\n如果aij=0，那么这个蛇段就是我们不知道的\n", "outputFormat": "Your program is to print three lines to the standard output.\n\nThe ![](http://main.edu.pl/images/OI21/waz-en-tex.20.png)-th lines should hold ![](http://main.edu.pl/images/OI21/waz-en-tex.21.png) positive integers ![](http://main.edu.pl/images/OI21/waz-en-tex.22.png) (for ![](http://main.edu.pl/images/OI21/waz-en-tex.23.png)).\n\nAll the numbers ![](http://main.edu.pl/images/OI21/waz-en-tex.24.png) together should be a permutation of the numbers from ![](http://main.edu.pl/images/OI21/waz-en-tex.25.png) to ![](http://main.edu.pl/images/OI21/waz-en-tex.26.png).\n\nThe output numbers should be a valid reconstruction of the snake, i.e., they should  be consistent with the (positive) input numbers and satisfy aforementioned constraints.\n\nYou may assume that there is at least one valid reconstruction of the snake.\n\nIf there is more than one, your program can print any valid reconstruction.\n\n将所有aij为0的蛇段补齐\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] WAZ-Snake", "background": "# Description\n\nA snake fills a $3 \\times n$ board completely. The snake is divided into segments numbered from $1$ to $3n$. Consecutive segments (i.e., $k$ and $k+1$) must occupy squares that share an edge. Some segment numbers on the board are erased. Can you reconstruct the snake?\n\nConstraints: $1 \\le n \\le 1000$.", "description": "A snake fills a $3 \\times n$ board completely. The snake is divided into segments numbered from $1$ to $3n$. Consecutive segments (i.e., $k$ and $k+1$) must occupy squares that share an edge. Some segment numbers on the board are erased. Can you reconstruct the snake?\n\nConstraints: $1 \\le n \\le 1000$.\n\n# Description", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 1000$), the length of the board.\n\nThe next three lines describe the board. The $i$-th of these lines contains $n$ integers $a_{i j}$ ($0 \\le a_{i j} \\le 3n$) for $1 \\le j \\le n$.\n\nIf $a_{i j} > 0$, then $a_{i j}$ is the number of the snake’s segment occupying the $j$-th square of the $i$-th row. If $a_{i j} = 0$, then the number on this square is unknown.\n\nIt is guaranteed that there is at least one valid reconstruction.", "outputFormat": "Print three lines. The $i$-th line should contain $n$ positive integers $b_{i j}$ ($1 \\le j \\le n$).\n\nAll numbers $b_{i j}$ together must form a permutation of $1, 2, \\dots, 3n$. For every $(i, j)$ with $a_{i j} > 0$, it must hold that $b_{i j} = a_{i j}$. Moreover, for every $k$ from $1$ to $3n-1$, the squares containing $k$ and $k+1$ must share an edge.\n\nIf multiple solutions exist, output any of them.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] WAZ-Snake", "background": "", "description": "A snake fills a ![](http://main.edu.pl/images/OI21/waz-en-tex.1.png) board completely.\n\nSuccessive segments of the snake are numbered from ![](http://main.edu.pl/images/OI21/waz-en-tex.2.png) to ![](http://main.edu.pl/images/OI21/waz-en-tex.3.png).\n\nThe segments with successive numbers (i.e., 1 and 2, 2 and 3, 3 and 4...) occupy squares  that share an edge.\n\nFor example, a snake can fill a ![](http://main.edu.pl/images/OI21/waz-en-tex.4.png) board as follows:\n\nThe snake's segment numbers in some of the squares have been erased.\n\n  Can you reconstruct the snake?\n\n一只蛇被放在了一块3\\*n的木板上（填充满了），蛇被分为多个小段，小段的编号是1到3n。比如说蛇可以填写一个3\\*9的木板，如下所示：\n\n\n部分木板上的蛇段已删遮挡。\n\n\n你能重建蛇吗？\n", "inputFormat": "In the first line of the standard input, there is a single integer ![](http://main.edu.pl/images/OI21/waz-en-tex.5.png)  (![](http://main.edu.pl/images/OI21/waz-en-tex.6.png)), the length of the board.\n\nThe three lines that follow describe the board;  the ![](http://main.edu.pl/images/OI21/waz-en-tex.7.png)-th of them contains ![](http://main.edu.pl/images/OI21/waz-en-tex.8.png) integers ![](http://main.edu.pl/images/OI21/waz-en-tex.9.png)  (![](http://main.edu.pl/images/OI21/waz-en-tex.10.png) for ![](http://main.edu.pl/images/OI21/waz-en-tex.11.png)).\n\nIf ![](http://main.edu.pl/images/OI21/waz-en-tex.12.png), then ![](http://main.edu.pl/images/OI21/waz-en-tex.13.png) is the number of the snake's segment  occupying the ![](http://main.edu.pl/images/OI21/waz-en-tex.14.png)-th square of the ![](http://main.edu.pl/images/OI21/waz-en-tex.15.png)-th row of the board.\n\nIf on the other hand ![](http://main.edu.pl/images/OI21/waz-en-tex.16.png), then the number of the snake's segment  on this square is unknown.\n\nIn tests worth 15% of the total score ![](http://main.edu.pl/images/OI21/waz-en-tex.17.png) holds,  in those worth 40% of the total score ![](http://main.edu.pl/images/OI21/waz-en-tex.18.png) holds,  and finally, in those worth 70% of the total score ![](http://main.edu.pl/images/OI21/waz-en-tex.19.png) holds.\n\n在标准输入的第一行中，有一个整数n（1<=n<=1000），即板的长度。\n\n\n下面三行描述木板的情况，第i行是n个整数aij（0<=aij<=3n）(1<=j<=n)。\n\n\n如果aij大于0，那么aij就是蛇段的第aij部分\n\n\n如果aij=0，那么这个蛇段就是我们不知道的\n", "outputFormat": "Your program is to print three lines to the standard output.\n\nThe ![](http://main.edu.pl/images/OI21/waz-en-tex.20.png)-th lines should hold ![](http://main.edu.pl/images/OI21/waz-en-tex.21.png) positive integers ![](http://main.edu.pl/images/OI21/waz-en-tex.22.png) (for ![](http://main.edu.pl/images/OI21/waz-en-tex.23.png)).\n\nAll the numbers ![](http://main.edu.pl/images/OI21/waz-en-tex.24.png) together should be a permutation of the numbers from ![](http://main.edu.pl/images/OI21/waz-en-tex.25.png) to ![](http://main.edu.pl/images/OI21/waz-en-tex.26.png).\n\nThe output numbers should be a valid reconstruction of the snake, i.e., they should  be consistent with the (positive) input numbers and satisfy aforementioned constraints.\n\nYou may assume that there is at least one valid reconstruction of the snake.\n\nIf there is more than one, your program can print any valid reconstruction.\n\n将所有aij为0的蛇段补齐\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3569", "type": "P", "difficulty": 5, "samples": [["4\n2 5\n3 4\n6 3\n2 7\n2\n3 4\n1 3\n", "NIE\nTAK\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2014", "线段树", "POI（波兰）"], "title": "[POI 2014] KAR-Cards", "background": "", "description": "There are $n$ cards arranged on a table in a certain order.\n\nTwo integers are written on each card, one per side: the obverse and the reverse.\n\nInitially all cards lie with the averse facing up.\n\nByteasar, The Great Illusionist, intends to perform (multiple times!) his signature    Binary Search Card Manipulation.  However, to present it, he needs the sequence of numbers    as seen on the cards to be non-decreasing.\n\nThus, Byteasar may have to turn over some cards so that the numbers on their reverse sides    become visible.\n\nFurthermore, the illusion requires a participant from the audience.\n\nAlas, some of the volunteers are deployed by Byteasar's competitors who want him to fail.\n\nEach such supposititious volunteer, upon entering the scene, would swap two cards on the table in a lightning move of a hand.  After each such swap, Byteasar can again turn over any cards he desires but nevertheless, he may not be able to perform his great illusion.\n\nIf that were to happen, he would be forced to turn to traditional illusions, such as pulling a rabbit out of a hat.\n\nWrite a program that determines, after each card swap, if Byteasar can perform his great illusion.\n\n有一些卡牌，正反各有一个数，你可以任意翻转，每次操作会将两张卡牌的位置调换，你需要在每次操作后回答以现在的卡牌顺序能否通过反转形成一个单调不降的序列\n", "inputFormat": "In the first line of the standard input, there is a single integer, $n$ ($2\\le n\\le 200\\ 000$), the number of the cards.\n\nThe $n$ lines that follow describe the cards, one per line,in the order they are arranged on the table.\n\nThe $i$-th of these lines has two integers $x_i$ and $y_i$ ($0\\le x_i,y_i\\le 10^7$), separated by a single space.\n\nThese are the numbers written on the $i$-th card:\n\n$x_i$ is the one written on the obverse and $y_i$ the one on the reverse.\n\nThe initial sequence of cards may not allow performing the great illusion.\n\nAfterwards, there is a line with a single integer $m$ ($1\\le m\\le 1\\ 000\\ 000$), the number of card swaps.The $m$ lines that follow describe the swaps: $j$-th of these lines has two integers $a_j$ and $b_j$ ($1\\le a_j,b_j\\le n$), separated by a single space, indicating that the $j$-th (supposititious) volunteer will swap the $a_j$-th and the $b_j$-th cards.\n", "outputFormat": "Your program should print $m$ lines to the standard output, each containing a single word:\n\nTAK (Polish for yes) or NIE (Polish for no).\n\nThe $j$-th line should read TAK if Byteasar can obtain a non-decreasing sequence      of numbers by turning the cards over after the $j$-th card swap.  If he cannot,      the line should read NIE.\n", "hint": "有一些卡牌，正反各有一个数，你可以任意翻转，每次操作会将两张卡牌的位置调换，你需要在每次操作后回答以现在的卡牌顺序能否通过反转形成一个单调不降的序列\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] KAR-Cards", "background": "", "description": "There are $n$ cards arranged on a table in a fixed order.\n\nEach card has two integers, one on each side: the obverse and the reverse. The $i$-th card has $x_i$ on the obverse and $y_i$ on the reverse. Initially, all cards lie with the obverse side up.\n\nByteasar, the Great Illusionist, wants the sequence of visible numbers on the cards to be non-decreasing. He may flip any subset of cards to show the other side.\n\nHowever, an audience participant will repeatedly swap two cards on the table. After each such swap, Byteasar may again flip any cards, but he might still be unable to achieve a non-decreasing sequence. After each swap, determine whether it is possible to obtain a non-decreasing sequence of visible numbers by flipping cards as needed.", "inputFormat": "The first line contains a single integer $n$ ($2 \\le n \\le 200\\ 000$), the number of cards.\n\nThe next $n$ lines describe the cards, in their current order on the table. The $i$-th of these lines contains two integers $x_i$ and $y_i$ ($0 \\le x_i, y_i \\le 10^7$), separated by a single space, where $x_i$ is written on the obverse and $y_i$ on the reverse of the $i$-th card.\n\nThe initial sequence of cards may not allow forming a non-decreasing sequence.\n\nAfterwards, there is a line with a single integer $m$ ($1 \\le m \\le 1\\ 000\\ 000$), the number of card swaps. The next $m$ lines describe the swaps: the $j$-th of these lines has two integers $a_j$ and $b_j$ ($1 \\le a_j, b_j \\le n$), indicating that the $j$-th participant swaps the $a_j$-th and $b_j$-th cards.", "outputFormat": "Print $m$ lines. On the $j$-th line, print TAK (Polish for yes) if, after the $j$-th swap, Byteasar can obtain a non-decreasing sequence of visible numbers by flipping any subset of cards; otherwise, print NIE (Polish for no).", "hint": "There are several cards, each with a number on both sides. You may flip any cards. Each operation swaps two cards’ positions. After each operation, determine whether, with the current card order, flipping some cards can form a non-decreasing sequence.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] KAR-Cards", "background": "", "description": "There are $n$ cards arranged on a table in a certain order.\n\nTwo integers are written on each card, one per side: the obverse and the reverse.\n\nInitially all cards lie with the averse facing up.\n\nByteasar, The Great Illusionist, intends to perform (multiple times!) his signature    Binary Search Card Manipulation.  However, to present it, he needs the sequence of numbers    as seen on the cards to be non-decreasing.\n\nThus, Byteasar may have to turn over some cards so that the numbers on their reverse sides    become visible.\n\nFurthermore, the illusion requires a participant from the audience.\n\nAlas, some of the volunteers are deployed by Byteasar's competitors who want him to fail.\n\nEach such supposititious volunteer, upon entering the scene, would swap two cards on the table in a lightning move of a hand.  After each such swap, Byteasar can again turn over any cards he desires but nevertheless, he may not be able to perform his great illusion.\n\nIf that were to happen, he would be forced to turn to traditional illusions, such as pulling a rabbit out of a hat.\n\nWrite a program that determines, after each card swap, if Byteasar can perform his great illusion.\n\n有一些卡牌，正反各有一个数，你可以任意翻转，每次操作会将两张卡牌的位置调换，你需要在每次操作后回答以现在的卡牌顺序能否通过反转形成一个单调不降的序列\n", "inputFormat": "In the first line of the standard input, there is a single integer, $n$ ($2\\le n\\le 200\\ 000$), the number of the cards.\n\nThe $n$ lines that follow describe the cards, one per line,in the order they are arranged on the table.\n\nThe $i$-th of these lines has two integers $x_i$ and $y_i$ ($0\\le x_i,y_i\\le 10^7$), separated by a single space.\n\nThese are the numbers written on the $i$-th card:\n\n$x_i$ is the one written on the obverse and $y_i$ the one on the reverse.\n\nThe initial sequence of cards may not allow performing the great illusion.\n\nAfterwards, there is a line with a single integer $m$ ($1\\le m\\le 1\\ 000\\ 000$), the number of card swaps.The $m$ lines that follow describe the swaps: $j$-th of these lines has two integers $a_j$ and $b_j$ ($1\\le a_j,b_j\\le n$), separated by a single space, indicating that the $j$-th (supposititious) volunteer will swap the $a_j$-th and the $b_j$-th cards.\n", "outputFormat": "Your program should print $m$ lines to the standard output, each containing a single word:\n\nTAK (Polish for yes) or NIE (Polish for no).\n\nThe $j$-th line should read TAK if Byteasar can obtain a non-decreasing sequence      of numbers by turning the cards over after the $j$-th card swap.  If he cannot,      the line should read NIE.\n", "hint": "有一些卡牌，正反各有一个数，你可以任意翻转，每次操作会将两张卡牌的位置调换，你需要在每次操作后回答以现在的卡牌顺序能否通过反转形成一个单调不降的序列\n", "locale": "zh-CN"}}}
{"pid": "P3570", "type": "P", "difficulty": 6, "samples": [["15 7\n2 5 6 2 4 7 3 3 2 3 7 5 3 6 2\n3 2\n4 7 3\n5 3\n", "3\n7 8 10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["2014", "线性数据结构", "POI（波兰）", "枚举"], "title": "[POI 2014] PRZ-Criminals", "background": "", "description": "Byteburg is a beautiful town by a river.\n\nThere are $n$ houses along the river, numbered downstream with successive integers from $1$ to $n$.\n\nByteburg used to be a nice quiet town in which everyone was happy.\n\nAlas, this changed recently, as two dangerous criminals - Bitie and Bytie set up shop in it.\n\nThey did so many robberies already that the citizens are afraid to leave their houses.\n\nBitie and Bytie do no mere burglaries but rather whole raids: each time they leave their houses and walk towards each other, never turning back.\n\nBitie walks downstream (towards larger numbers) while Bytie walks upstream (towards smaller numbers).\n\nAlong the way, before they meet, each chooses several houses to break into and steal precious items    (and vital data).\n\nAfter the robberies they meet in a house and divide their loot.\n\nByteburgers are sick of this already - they would all rather have their tranquility restored.\n\nSo they asked the detective Bythony for help.\n\nThe detective established that the bandits live in houses of the same color but he does not know which one.\n\nJust a moment ago, an anonymous tip claimed that the robbers are on a raid.\n\nFearing for their own safety, the source did not say which houses will be broken into.\n\nThey did however specify their colors.\n\nAs it turns out, the bandits are quite superstitious - each of them will rob a house of each color at most once.\n\nBythony can wait no longer.\n\nHe intends to ambush the criminals at their meeting place.\n\nAid Bythony in his undertaking by writing a program to find all possible meeting places of the robbers.\n", "inputFormat": "There are two integers in the first line of the standard input, $n$ and $k$ ($3\\le n\\le 1\\ 000\\ 000$, $1\\le k\\le 1\\ 000\\ 000$, $k\\le n$),  separated by a single space, that specify the number of houses and the number of house colors  in Byteburg respectively.\n\nThe colors are number with successive integers from $1$ to $k$.\n\nIn the second line of input, there is a sequence of $n$ integers, $c_1,c_2,\\cdots,c_n$ ($1\\le c_i\\le k$), separated by single spaces.\n\nThese are the colors of successive houses in Byteburg.\n\nIn the third line of input, there are two integers $m$ and $l$($1\\le m,l\\le n$,$m+l\\le n-1$), separated by a single space, specifying the numbers of houses (to be) broken into by Bitie and Bytie respectively. In the fourth line of input, there are $m$ pairwise different integers $x_1,x_2,\\cdots,x_m$($1\\le x_i\\le k$), separated by single spaces. These are the colors of houses robbed by Bitie in the order of being broken into (i.e., excluding Bitie's house). In the fifth, which is the last, line of input, there are $l$ pairwise different integers $y_1,y_2,\\cdots,y_l$ ($1\\le y_i\\le k$), separated by single spaces. These are the colors of houses robbed by Bytie in the order of being broken into (again, these do not include Bytie's house). Moreover, $x_m=y_l$ is the color of the house in which the robbers will divide the plunder. (Clearly, they have to break into that one as well!)\n", "outputFormat": "Your program it to print exactly two lines to the standard output.\n\nThe first of those should give the number of houses in which the criminals can meet  while respecting aforementioned constraints.\n\nThe second line should contain the increasing sequence of the numbers of those houses,  separated by single spaces.\n\nIf the robbers cannot meet at all, the first line should contain the number 0 while the second one should be empty.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2014] PRZ-Criminals", "background": "", "description": "Byteburg is a beautiful town by a river.\n\nThere are $n$ houses along the river, numbered downstream with successive integers from $1$ to $n$.\n\nByteburg used to be a nice quiet town in which everyone was happy.\n\nAlas, this changed recently, as two dangerous criminals - Bitie and Bytie set up shop in it.\n\nThey did so many robberies already that the citizens are afraid to leave their houses.\n\nBitie and Bytie do no mere burglaries but rather whole raids: each time they leave their houses and walk towards each other, never turning back.\n\nBitie walks downstream (towards larger numbers) while Bytie walks upstream (towards smaller numbers).\n\nAlong the way, before they meet, each chooses several houses to break into and steal precious items    (and vital data).\n\nAfter the robberies they meet in a house and divide their loot.\n\nByteburgers are sick of this already - they would all rather have their tranquility restored.\n\nSo they asked the detective Bythony for help.\n\nThe detective established that the bandits live in houses of the same color but he does not know which one.\n\nJust a moment ago, an anonymous tip claimed that the robbers are on a raid.\n\nFearing for their own safety, the source did not say which houses will be broken into.\n\nThey did however specify their colors.\n\nAs it turns out, the bandits are quite superstitious - each of them will rob a house of each color at most once.\n\nBythony can wait no longer.\n\nHe intends to ambush the criminals at their meeting place.\n\nAid Bythony in his undertaking by writing a program to find all possible meeting places of the robbers.\n", "inputFormat": "There are two integers in the first line of the standard input, $n$ and $k$ ($3\\le n\\le 1\\ 000\\ 000$, $1\\le k\\le 1\\ 000\\ 000$, $k\\le n$),  separated by a single space, that specify the number of houses and the number of house colors  in Byteburg respectively.\n\nThe colors are number with successive integers from $1$ to $k$.\n\nIn the second line of input, there is a sequence of $n$ integers, $c_1,c_2,\\cdots,c_n$ ($1\\le c_i\\le k$), separated by single spaces.\n\nThese are the colors of successive houses in Byteburg.\n\nIn the third line of input, there are two integers $m$ and $l$($1\\le m,l\\le n$,$m+l\\le n-1$), separated by a single space, specifying the numbers of houses (to be) broken into by Bitie and Bytie respectively. In the fourth line of input, there are $m$ pairwise different integers $x_1,x_2,\\cdots,x_m$($1\\le x_i\\le k$), separated by single spaces. These are the colors of houses robbed by Bitie in the order of being broken into (i.e., excluding Bitie's house). In the fifth, which is the last, line of input, there are $l$ pairwise different integers $y_1,y_2,\\cdots,y_l$ ($1\\le y_i\\le k$), separated by single spaces. These are the colors of houses robbed by Bytie in the order of being broken into (again, these do not include Bytie's house). Moreover, $x_m=y_l$ is the color of the house in which the robbers will divide the plunder. (Clearly, they have to break into that one as well!)\n", "outputFormat": "Your program it to print exactly two lines to the standard output.\n\nThe first of those should give the number of houses in which the criminals can meet  while respecting aforementioned constraints.\n\nThe second line should contain the increasing sequence of the numbers of those houses,  separated by single spaces.\n\nIf the robbers cannot meet at all, the first line should contain the number 0 while the second one should be empty.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2014] PRZ-Criminals", "background": "", "description": "两个罪犯 Bitie 和 Bytie 抢劫 $n$ 个房子，每个房子有一个颜色，Bitie 从低编号到高编号，Bytie 从高编号到低编号，直到相遇为止。已知罪犯开始时所在房子颜色相同（但不知道是什么颜色），并且知道罪犯依次抢劫的所有房子的颜色，且每个罪犯对每种颜色的房子分别最多抢劫一次，求所有可能的相遇点。", "inputFormat": "第一行两个整数 $n,k$ ，分别表示房子的个数和不同的颜色数。颜色以从 $1$ 到 $k$ 的整数标号。\n\n接下来一行有 $n$ 个整数 $c_1,c_2,...,c_n (1 \\le c_i \\le k)$，表示房子的颜色。\n\n第三行有两个整数 $m,l (1 \\le m,l \\le n,m+l \\le n-1)$，分别表示 Bitie 和 Bytie 抢劫房子的个数。\n\n第四行有 $m$ 个两两不同的整数 $x_1, x_2, ..., x_m (1 \\le x_i \\le k)$，表示 Bitie 抢劫房子的颜色（不包括 Bitie 开始时所在房子的颜色）。\n\n第五行有 $l$ 个两两不同的整数 $y_1, y_2, ..., y_l (1 \\le y_i \\le k)$，表示 Bytie 抢劫房子的颜色 （不包括 Bytie 开始时所在房子的颜色）。\n\n保证 $x_m = y_l$。", "outputFormat": "输出两行，第一行一个整数，表示可能相遇的房子个数，第二行升序输出可能相遇的房子编号。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3571", "type": "P", "difficulty": 7, "samples": [["20 1\n3\n1 1 1 3 4 3 2 8 6 9 10 12 12 13 14 11 11 11 11\n", "8\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "POI（波兰）", "斜率优化", "凸包"], "title": "[POI 2014] SUP-Supercomputer", "background": "", "description": "Byteasar has designed a supercomputer of novel architecture.\n\n```plain\nIt may comprise of many (identical) processing units.\n```\nEach processing unit can execute a single instruction per time unit.\n\nThe programs for this computer are not sequential but rather have a tree structure.\n\nEach instruction may have zero, one, or multiple subsequent instructions,    for which it is the parent instruction.\n\nThe instructions of the program can be executed in parallel on all available    processing units.  Moreover, they can be executed in many orders: the only    restriction is that an instruction cannot be executed unless its parent    instruction has been executed before.  For example, as many subsequent    instructions of an instruction that has been executed already can be    executed in parallel as there are processing units.\n\nByteasar has a certain program to run.  Since he likes utilizing his resources    optimally, he is wondering how the number of processing units would affect the running time.\n\nHe asks you to determine, for a given program and number of processing units,    the minimum execution time of the program on a supercomputer with this many processing units.\n\n给定一棵N个节点的有根树，根节点为1。Q次询问，每次给定一个K，用最少的操作次数遍历完整棵树，输出最少操作次数。每次操作可以选择访问不超过K个未访问的点，且这些点的父亲必须在之前被访问过。\n", "inputFormat": "In the first line of standard input, there are two integers, $n$ and $q$ ($1\\le n,q\\le 1\\ 000\\ 000$), separated by a single space, that specify the number of    instructions in Byteasar's program and the number of running time queries (for different numbers    of processing units).\n\nIn the second line of input, there is a sequence of $q$ integers, $k_1,k_2,\\cdots,k_q$ ($1\\le k_i\\le 1\\ 000\\ 000$), separated by single spaces: $k_i$ is the number of processing units in    Byteasar's $i$-th query.\n\nIn the third and last input line, there is a sequence of $n-1$ integers, $a_2,a_3,\\cdots,a_n$($1\\le a_i<i$) separated by single spaces: $a_i$ specifies the number of the parent instruction of the instruction number $i$. The instructions are numbered with successive integers from 1 to $n$, where the instruction no. 1 is the first instruction of the program.\n", "outputFormat": "Your program should print one line consisting of $q$ integers, separated by single spaces,    to the standard output:\n\nthe $i$-th of these numbers should specify the minimum execution time of the program on a supercomputer with $k_i$ processing units.\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] SUP-Supercomputer", "background": "", "description": "Byteasar has designed a supercomputer of novel architecture.\n\n```plain\nIt may comprise of many (identical) processing units.\n```\nEach processing unit can execute a single instruction per time unit.\n\nThe programs for this computer are not sequential but rather have a tree structure.\n\nEach instruction may have zero, one, or multiple subsequent instructions, for which it is the parent instruction.\n\nThe instructions of the program can be executed in parallel on all available processing units. Moreover, they can be executed in many orders: the only restriction is that an instruction cannot be executed unless its parent instruction has been executed before. For example, as many subsequent instructions of an instruction that has been executed already can be executed in parallel as there are processing units.\n\nByteasar has a certain program to run. Since he likes utilizing his resources optimally, he is wondering how the number of processing units would affect the running time.\n\nHe asks you to determine, for a given program and number of processing units, the minimum execution time of the program on a supercomputer with this many processing units.\n\nEquivalent formulation: You are given a rooted tree with $n$ nodes, with root $1$. There are $q$ queries; in each query, a number $k$ is given. In one step, you may visit up to $k$ unvisited vertices whose parents have already been visited. Find the minimum number of steps needed to visit the whole tree for each given $k$.", "inputFormat": "In the first line of standard input, there are two integers, $n$ and $q$ ($1\\le n, q\\le 1\\,000\\,000$), separated by a single space, that specify the number of instructions in Byteasar's program and the number of running time queries (for different numbers of processing units).\n\nIn the second line of input, there is a sequence of $q$ integers, $k_1, k_2, \\ldots, k_q$ ($1\\le k_i\\le 1\\,000\\,000$), separated by single spaces: $k_i$ is the number of processing units in Byteasar's $i$-th query.\n\nIn the third and last input line, there is a sequence of $n-1$ integers, $a_2, a_3, \\ldots, a_n$ ($1\\le a_i<i$) separated by single spaces: $a_i$ specifies the number of the parent instruction of instruction number $i$. The instructions are numbered with successive integers from $1$ to $n$, where instruction no. $1$ is the first instruction of the program.", "outputFormat": "Your program should print one line consisting of $q$ integers, separated by single spaces: the $i$-th of these numbers should specify the minimum execution time of the program on a supercomputer with $k_i$ processing units.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] SUP-Supercomputer", "background": "", "description": "Byteasar has designed a supercomputer of novel architecture.\n\n```plain\nIt may comprise of many (identical) processing units.\n```\nEach processing unit can execute a single instruction per time unit.\n\nThe programs for this computer are not sequential but rather have a tree structure.\n\nEach instruction may have zero, one, or multiple subsequent instructions,    for which it is the parent instruction.\n\nThe instructions of the program can be executed in parallel on all available    processing units.  Moreover, they can be executed in many orders: the only    restriction is that an instruction cannot be executed unless its parent    instruction has been executed before.  For example, as many subsequent    instructions of an instruction that has been executed already can be    executed in parallel as there are processing units.\n\nByteasar has a certain program to run.  Since he likes utilizing his resources    optimally, he is wondering how the number of processing units would affect the running time.\n\nHe asks you to determine, for a given program and number of processing units,    the minimum execution time of the program on a supercomputer with this many processing units.\n\n给定一棵N个节点的有根树，根节点为1。Q次询问，每次给定一个K，用最少的操作次数遍历完整棵树，输出最少操作次数。每次操作可以选择访问不超过K个未访问的点，且这些点的父亲必须在之前被访问过。\n", "inputFormat": "In the first line of standard input, there are two integers, $n$ and $q$ ($1\\le n,q\\le 1\\ 000\\ 000$), separated by a single space, that specify the number of    instructions in Byteasar's program and the number of running time queries (for different numbers    of processing units).\n\nIn the second line of input, there is a sequence of $q$ integers, $k_1,k_2,\\cdots,k_q$ ($1\\le k_i\\le 1\\ 000\\ 000$), separated by single spaces: $k_i$ is the number of processing units in    Byteasar's $i$-th query.\n\nIn the third and last input line, there is a sequence of $n-1$ integers, $a_2,a_3,\\cdots,a_n$($1\\le a_i<i$) separated by single spaces: $a_i$ specifies the number of the parent instruction of the instruction number $i$. The instructions are numbered with successive integers from 1 to $n$, where the instruction no. 1 is the first instruction of the program.\n", "outputFormat": "Your program should print one line consisting of $q$ integers, separated by single spaces,    to the standard output:\n\nthe $i$-th of these numbers should specify the minimum execution time of the program on a supercomputer with $k_i$ processing units.\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3572", "type": "P", "difficulty": 4, "samples": [["9\n4 6 3 6 3 7 2 6 5\n2\n2\n5\n", "2\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2014", "单调队列", "POI（波兰）"], "title": "[POI 2014] PTA-Little Bird", "background": "", "description": "In the Byteotian Line Forest there are $n$ trees in a row.\n\nOn top of the first one, there is a little bird who would like to fly over to the top of the last tree.\n\nBeing in fact very little, the bird might lack the strength to fly there without any stop.\n\nIf the bird is sitting on top of the tree no. i, then in a single flight leg it can fly toany of the trees no. $i+1,i+2,\\cdots,i+k$, and then has to rest afterward.\n\nMoreover, flying up is far harder to flying down.  A flight leg is tiresome if it ends in a tree at leastas high as the one where is started.  Otherwise the flight leg is not tiresome.\n\nThe goal is to select the trees on which the little bird will land so that the overall flight is leasttiresome, i.e., it has the minimum number of tiresome legs.\n\nWe note that birds are social creatures, and our bird has a few bird-friends who would also like to getfrom the first tree to the last one.  The stamina of all the birds varies,so the bird's friends may have different values of the parameter $k$.\n\nHelp all the birds, little and big!", "inputFormat": "There is a single integer $n$ ($2\\le n\\le 1\\ 000\\ 000$) in the first line of the standard input:\n\nthe number of trees in the Byteotian Line Forest.\n\nThe second line of input holds $n$ integers $d_1,d_2,\\cdots,d_n$ ($1\\le d_i\\le 10^9$)separated by single spaces: $d_i$ is the height of the i-th tree.\n\nThe third line of the input holds a single integer $q$ ($1\\le q\\le 25$): the number of birds whoseflights need to be planned.\n\nThe following $q$ lines describe these birds: in the $i$-th of these lines, there is an integer $k_i$ ($1\\le k_i\\le n-1$) specifying the $i$-th bird's stamina. In other words, the maximum number of trees that the $i$-th bird can pass before it has to rest is $k_i-1$.\n", "outputFormat": "Your program should print exactly $q$ lines to the standard output.\n\nIn the $i$-th line, it should specify the minimum number of tiresome flight legs of the $i$-th bird.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2014] PTA-Little Bird", "background": "", "description": "In the Byteotian Line Forest there are $n$ trees in a row.\n\nOn top of the first one, there is a little bird who would like to fly over to the top of the last tree.\n\nBeing in fact very little, the bird might lack the strength to fly there without any stop.\n\nIf the bird is sitting on top of the tree no. i, then in a single flight leg it can fly toany of the trees no. $i+1,i+2,\\cdots,i+k$, and then has to rest afterward.\n\nMoreover, flying up is far harder to flying down.  A flight leg is tiresome if it ends in a tree at leastas high as the one where is started.  Otherwise the flight leg is not tiresome.\n\nThe goal is to select the trees on which the little bird will land so that the overall flight is leasttiresome, i.e., it has the minimum number of tiresome legs.\n\nWe note that birds are social creatures, and our bird has a few bird-friends who would also like to getfrom the first tree to the last one.  The stamina of all the birds varies,so the bird's friends may have different values of the parameter $k$.\n\nHelp all the birds, little and big!", "inputFormat": "There is a single integer $n$ ($2\\le n\\le 1\\ 000\\ 000$) in the first line of the standard input:\n\nthe number of trees in the Byteotian Line Forest.\n\nThe second line of input holds $n$ integers $d_1,d_2,\\cdots,d_n$ ($1\\le d_i\\le 10^9$)separated by single spaces: $d_i$ is the height of the i-th tree.\n\nThe third line of the input holds a single integer $q$ ($1\\le q\\le 25$): the number of birds whoseflights need to be planned.\n\nThe following $q$ lines describe these birds: in the $i$-th of these lines, there is an integer $k_i$ ($1\\le k_i\\le n-1$) specifying the $i$-th bird's stamina. In other words, the maximum number of trees that the $i$-th bird can pass before it has to rest is $k_i-1$.\n", "outputFormat": "Your program should print exactly $q$ lines to the standard output.\n\nIn the $i$-th line, it should specify the minimum number of tiresome flight legs of the $i$-th bird.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2014] PTA-Little Bird", "background": "", "description": "有 $n$ 棵树排成一排，第 $i$ 棵树的高度是 $d_i$。\n\n有 $q$ 只鸟要从第 $1$ 棵树到第 $n$ 棵树。\n\n当第 $i$ 只鸟在第 $j$ 棵树时，它可以飞到第 $j+1, j+2, \\cdots, j+k_i$ 棵树。\n\n如果一只鸟飞到一颗高度大于等于当前树的树，那么它的劳累值会增加 $1$，否则不会。\n\n由于这些鸟已经体力不支，所以它们想要最小化劳累值。", "inputFormat": "第一行输入 $n$。\n\n第二行 $n$ 个数，第 $i$ 个数表示 $d_i$。\n\n第三行输入 $q$。\n\n接下来 $q$ 行，每一行一个整数，第 $i$ 行的整数为 $k_i$。", "outputFormat": "共 $q$ 行，每一行输出第 $i$ 只鸟的最小劳累值。", "hint": "$1 \\le n \\le 10^6$，$1 \\le d_i \\le 10^9$，$1 \\le q \\le 25$，$1 \\le k_i \\le n - 1$。", "locale": "zh-CN"}}}
{"pid": "P3573", "type": "P", "difficulty": 6, "samples": [["6 5\n1 3\n1 4\n3 6\n3 4\n4 5\n", "1 2\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "线段树", "POI（波兰）", "Special Judge", "可持久化线段树"], "title": "[POI 2014] RAJ-Rally", "background": "", "description": "  An annual bicycle rally will soon begin in Byteburg.\n\nThe bikers of Byteburg are natural long distance cyclists.\n\nLocal representatives of motorcyclists, long feuding the cyclists,  have decided to sabotage the event.\n\nThere are ![](http://main.edu.pl/images/OI21/raj-en-tex.1.png) intersections in Byteburg, connected with one way streets.\n\nStrangely enough, there are no cycles in the street network - if one can ride from  intersection ![](http://main.edu.pl/images/OI21/raj-en-tex.2.png) to intersection ![](http://main.edu.pl/images/OI21/raj-en-tex.3.png), then it is definitely impossible to get from ![](http://main.edu.pl/images/OI21/raj-en-tex.4.png) to ![](http://main.edu.pl/images/OI21/raj-en-tex.5.png).\n\nThe rally's route will lead through Byteburg's streets.\n\nThe motorcyclists plan to ride their blazing machines in the early morning of the rally day  to one intersection and completely block it.\n\nThe cyclists' association will then of course determine an alternative route  but it could happen that this new route will be relatively short,  and the cyclists will thus be unable to exhibit their remarkable endurance.\n\nClearly, this is the motorcyclists' plan - they intend to block such an intersection  that the longest route that does not pass through it is as short as \n", "inputFormat": "In the first line of the standard input, there are two integers, N and M(2<=N<=500 000,1<=M<=1 000 000), separated by a single space, that specify the number of intersections and streets in Byteburg. The intersections are numbered from   to  . The   lines that follow describe the street network: in the  -th of these lines, there are two integers, Ai, Bi(1<=Ai,Bi<=N,Ai<>Bi), separated by a single space, that signify that there is a one way street from the intersection no. Ai to the one no. Bi\n", "outputFormat": "The first and only line of the standard output should contain two integers separated by a single space.\n\nThe first of these should be the number of the intersection that the motorcyclists should block,  and the second - the maximum number of streets that the cyclists can then ride along in their rally.\n\nIf there are many solutions, your program can choose one of them arbitrarily.", "hint": "感谢@zyh2015 提供spj\n", "locale": "en", "translations": {"en": {"title": "[POI 2014] RAJ-Rally", "background": "", "description": "  An annual bicycle rally will soon begin in Byteburg.\n\nThe bikers of Byteburg are natural long distance cyclists.\n\nLocal representatives of motorcyclists, long feuding the cyclists,  have decided to sabotage the event.\n\nThere are ![](http://main.edu.pl/images/OI21/raj-en-tex.1.png) intersections in Byteburg, connected with one way streets.\n\nStrangely enough, there are no cycles in the street network - if one can ride from  intersection ![](http://main.edu.pl/images/OI21/raj-en-tex.2.png) to intersection ![](http://main.edu.pl/images/OI21/raj-en-tex.3.png), then it is definitely impossible to get from ![](http://main.edu.pl/images/OI21/raj-en-tex.4.png) to ![](http://main.edu.pl/images/OI21/raj-en-tex.5.png).\n\nThe rally's route will lead through Byteburg's streets.\n\nThe motorcyclists plan to ride their blazing machines in the early morning of the rally day  to one intersection and completely block it.\n\nThe cyclists' association will then of course determine an alternative route  but it could happen that this new route will be relatively short,  and the cyclists will thus be unable to exhibit their remarkable endurance.\n\nClearly, this is the motorcyclists' plan - they intend to block such an intersection  that the longest route that does not pass through it is as short as \n", "inputFormat": "In the first line of the standard input, there are two integers, N and M(2<=N<=500 000,1<=M<=1 000 000), separated by a single space, that specify the number of intersections and streets in Byteburg. The intersections are numbered from   to  . The   lines that follow describe the street network: in the  -th of these lines, there are two integers, Ai, Bi(1<=Ai,Bi<=N,Ai<>Bi), separated by a single space, that signify that there is a one way street from the intersection no. Ai to the one no. Bi\n", "outputFormat": "The first and only line of the standard output should contain two integers separated by a single space.\n\nThe first of these should be the number of the intersection that the motorcyclists should block,  and the second - the maximum number of streets that the cyclists can then ride along in their rally.\n\nIf there are many solutions, your program can choose one of them arbitrarily.", "hint": "感谢@zyh2015 提供spj\n", "locale": "en"}, "zh-CN": {"title": "[POI 2014] RAJ-Rally", "background": "", "description": "给定一个 $n$ 个点 $m$ 条边的有向无环图，每条边长度都是 $1$。\n\n请找到一个点，使得删掉这个点后剩余的图中的最长路径最短。", "inputFormat": "第一行包含两个正整数 $n$，$m$（$2\\le n\\le5\\times10^5$，$1\\le m\\le10^6$），表示点数、边数。\n\n接下来 $m$ 行每行包含两个正整数 $a_i,b_i$（$1\\le a_i,b_i\\le n,a_i\\ne b_i$），表示 $a_i$ 到 $b_i$ 有一条边。", "outputFormat": "包含一行两个整数 $x$，$y$，用一个空格隔开，$x$ 为要删去的点，$y$ 为删除 $x$ 后图中的最长路径的长度，如果有多组解请输出任意一组。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3574", "type": "P", "difficulty": 5, "samples": [["6\n1 8 9 6 3 2\n1 3\n2 3\n3 4\n4 5\n4 6\n", "11\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2014", "POI（波兰）", "树形 DP"], "title": "[POI 2014] FAR-FarmCraft", "background": "", "description": "In a village called Byteville, there are $n$ houses connected with $n-1$ roads.\n\nFor each pair of houses, there is a unique way to get from one to another.\n\nThe houses are numbered from 1 to $n$.\n\nThe house no. 1 belongs to the village administrator Byteasar.\n\nAs part of enabling modern technologies for rural areas framework, $n$ computers have been delivered    to Byteasar's house.\n\nEvery house is to be supplied with a computer, and it is Byteasar's task to distribute them.\n\nThe citizens of Byteville have already agreed to play the most recent version of FarmCraft (the game) as soon as they have their computers.\n\nByteasar has loaded all the computers on his pickup truck and is about to set out to deliver the goods.\n\nHe has just the right amount of gasoline to drive each road twice.\n\nIn each house, Byteasar leaves one computer, and immediately continues on his route.\n\nIn each house, as soon as house dwellers get their computer, they turn it on and install FarmCraft.\n\nThe time it takes to install and set up the game very much depends on one's tech savviness, which is fortunately known for each household.\n\nAfter he delivers all the computers, Byteasar will come back to his house and install the game on his computer.\n\nThe travel time along each road linking two houses is exactly 1 minute, and (due to citizens' eagerness to play) the time to unload a computer is negligible.\n\nHelp Byteasar in determining a delivery order that allows all Byteville's citizens    (including Byteasar) to start playing together as soon as possible.\n\nIn other words, find an order that minimizes the time when everyone has FarmCraft installed.", "inputFormat": "The first line of the standard input contains a single integer $n$($2\\le n\\le 500\\ 000$) that gives the number of houses in Byteville.\n\nThe second line contains $n$ integers $c_1,c_2,\\cdots,c_n$ ($1\\le c_i\\le 10^9$),separated by single spaces; $c_i$ is the installation time (in minutes) for the dwellers of house no. i.\n\nThe next $n-1$ lines specify the roads linking the houses.\n\nEach such line contains two positive integers $a$ and $b$ ($1\\le a<b\\le n$), separated by a single space.These indicate that there is a direct road between the houses no. $a$ and $b$.\n", "outputFormat": "The first and only line of the standard output should contain a single integer:\n\nthe (minimum) number of minutes after which all citizens will be able to play FarmCraft together.\n", "hint": " ![](https://cdn.luogu.com.cn/upload/pic/6971.png) \n\n给一棵树，走过每条边需要花费一个时间，安装软件又需要花费一个时间，需要遍历整棵树并回到起点，想让所有点中到达时间+安装时间的最大值最小，问这个值是多少\n", "locale": "en", "translations": {"en": {"title": "[POI 2014] FAR-FarmCraft", "background": "", "description": "In a village called Byteville, there are $n$ houses connected with $n-1$ roads.\n\nFor each pair of houses, there is a unique way to get from one to another.\n\nThe houses are numbered from 1 to $n$.\n\nThe house no. 1 belongs to the village administrator Byteasar.\n\nAs part of enabling modern technologies for rural areas framework, $n$ computers have been delivered    to Byteasar's house.\n\nEvery house is to be supplied with a computer, and it is Byteasar's task to distribute them.\n\nThe citizens of Byteville have already agreed to play the most recent version of FarmCraft (the game) as soon as they have their computers.\n\nByteasar has loaded all the computers on his pickup truck and is about to set out to deliver the goods.\n\nHe has just the right amount of gasoline to drive each road twice.\n\nIn each house, Byteasar leaves one computer, and immediately continues on his route.\n\nIn each house, as soon as house dwellers get their computer, they turn it on and install FarmCraft.\n\nThe time it takes to install and set up the game very much depends on one's tech savviness, which is fortunately known for each household.\n\nAfter he delivers all the computers, Byteasar will come back to his house and install the game on his computer.\n\nThe travel time along each road linking two houses is exactly 1 minute, and (due to citizens' eagerness to play) the time to unload a computer is negligible.\n\nHelp Byteasar in determining a delivery order that allows all Byteville's citizens    (including Byteasar) to start playing together as soon as possible.\n\nIn other words, find an order that minimizes the time when everyone has FarmCraft installed.", "inputFormat": "The first line of the standard input contains a single integer $n$($2\\le n\\le 500\\ 000$) that gives the number of houses in Byteville.\n\nThe second line contains $n$ integers $c_1,c_2,\\cdots,c_n$ ($1\\le c_i\\le 10^9$),separated by single spaces; $c_i$ is the installation time (in minutes) for the dwellers of house no. i.\n\nThe next $n-1$ lines specify the roads linking the houses.\n\nEach such line contains two positive integers $a$ and $b$ ($1\\le a<b\\le n$), separated by a single space.These indicate that there is a direct road between the houses no. $a$ and $b$.\n", "outputFormat": "The first and only line of the standard output should contain a single integer:\n\nthe (minimum) number of minutes after which all citizens will be able to play FarmCraft together.\n", "hint": " ![](https://cdn.luogu.com.cn/upload/pic/6971.png) \n\n给一棵树，走过每条边需要花费一个时间，安装软件又需要花费一个时间，需要遍历整棵树并回到起点，想让所有点中到达时间+安装时间的最大值最小，问这个值是多少\n", "locale": "en"}, "zh-CN": {"title": "[POI 2014] FAR-FarmCraft", "background": "", "description": "在一个叫做比特村的小村庄中，有 $n-1$ 条路连接着这个村庄中的全部 $n$ 个房子。\n\n每两个房子之间都有一条唯一的通路。这些房子的编号为 $1$ 至 $n$。\n\n$1$ 号房子属于村庄的管理员比特安萨尔。\n\n为了提升村庄的科技使用水平，$n$ 台电脑被快递到了比特安萨尔的房子。每个房子都应该有一台电脑，且分发电脑的任务就落在了比特安萨尔的肩上。\n\n比特村的居民一致同意去玩农场物语这个游戏的最新快照版，而且好消息是他们很快就要得到他们最新的高配置电脑了。\n\n比特安萨尔将所有电脑都装在了他的卡车上，而且他准备好完成这个艰巨的任务了。\n\n**他的汽油恰好够走每条路两遍。**\n\n在每个房子边，比特安萨尔把电脑贴心的配送给居民，且立即前往下一个房子。（配送过程不花费任何时间）\n\n只要每间房子的居民拿到了他们的新电脑，它们就会立即开始安装农场物语。安装农场物语所用的时间根据居民的科技素养而定。幸运的是，每间房子中居民的科技素养都是已知的。\n\n在比特安萨尔配送完所有电脑后，他会回到他自己的 $1$ 号房子去安装他自己的农场物语。\n\n用卡车开过每条路的时间恰好是 $1$ 分钟，而居民开电脑箱的时间可以忽略不计。（因为他们太想玩农场物语了）\n\n请你帮助比特安萨尔算出从开始配送到所有居民都玩上了农场物语的最少时间。", "inputFormat": "第一行包含一个整数 $n(2 \\leq n \\leq 5\\times 10^5)$，代表比特村中有多少房子。\n\n第二行包含 $n$ 个整数 $c_1, c_2, ⋯, c_n(1 \\leq c_i \\leq 10^9)$，每个数都被单个空格隔开。$c_i$ 是第 $i$ 号房间中居民安装农场物语所用的时间。\n\n接下来的 $n-1$ 行代表了每一条路的两个顶点。两个顶点 $a$ 和 $b$ 满足 $1 \\leq a < b \\leq n$，两个数之间有一个空格。", "outputFormat": "一行，包含一个整数，代表题目中所说的最小时间。\n\n感谢@deadpool123 提供的翻译", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3575", "type": "P", "difficulty": 6, "samples": [["6 4\n2 2 1 3 3 1\n3 2 4 11\n", "4\nNIE\n3\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2014", "倍增", "POI（波兰）", "栈"], "title": "[POI 2014] DOO-Around the world", "background": "", "description": "After trying hard for many years, Byteasar has finally received a pilot license.\n\nTo celebrate the fact, he intends to buy himself an airplane and fly around the planet  3-SATurn (as you may have guessed, this is the planet on which Byteotia is located).\n\nSpecifically, Byteasar plans to fly along the equator.\n\nUnfortunately, the equator is rather long, necessitating refuels.\n\n  The flight range (on full tank) of each aircraft is known.\n\nThere is a number of airports along the equator, and a plane can be refueled when it lands on one.\n\nSince buying an airplane is a big decision, Byteasar asks your help.\n\nHe is about to present you with a list of different plane models he is considering.\n\nNaturally, these differ in their flight range.\n\nFor each plane model, he would like to know the minimum number of landings  (including the final one) he would have to make in order to complete the journey.\n\nNote that for each airplane model, the journey may start at a different airport.\n\n通过几年的努力，Byteasar最终拿到了飞行员驾驶证。为了庆祝这一事实，他打算买一架飞机并且绕Byteotia星球赤道飞行一圈。但不幸的是赤道非常长所以需要中途加几次油。现在已知赤道上面所有飞机场，所有飞机从飞机场起飞降落也可以加油。因为买飞机是个十分重大的决定，Byteasar决定寻求你的帮助。他将会让你模拟不同的飞行路线。自然这些飞机一次能走的航程是不同的。对于每次模拟，他想要知道最少需要降落多少次（包括最后一次）。需要注意的是起点可以任意选取。\n", "inputFormat": "The first line of the standard input contains two integers $n$ and $s$ ($2\\le n\\le 1\\ 000\\ 000$, $1\\le s\\le 100$),separated by a single space,  denoting the number of airports along the equator and the number of airplane models Byteasar is considering.\n\nThe second line contains $n$ positive integers $l_1,l_2,\\cdots,l_n$ ($l_1+l_2+\\cdots+l_n\\le 10^9$), separated by single spaces, specifying the distances between successive airports along the equator.\n\nThe number $l_i$ is the distance between the $i$-th and $(i+1)$-st (or $n$-th and first if $i=n$) in kilometers.\n\nThe third line contains $s$ integers $d_1,d_2,\\cdots,d_s$ ($1\\le d_i\\le l_1+l_2+\\cdots+l_n$), separated by single spaces. The number $d_i$ is the $i$-th airplane model's flight range in kilometers, i.e., the maximum distance it can fly before landing and refueling.\n", "outputFormat": "Your program should print $s$ lines to the standard output: the $i$-th of these should contain a single integer, namely, the minimum lumber of flight segments (and thus also landings) necessary to fly the $i$-th airplane around the planet 3-SATurn along the equator, starting at an airport of choice, or the word NIE (Polish for no) if it is impossible to complete the journey with this airplane.\n", "hint": "通过几年的努力，Byteasar最终拿到了飞行员驾驶证。为了庆祝这一事实，他打算买一架飞机并且绕Byteotia星球赤道飞行一圈。但不幸的是赤道非常长所以需要中途加几次油。现在已知赤道上面所有飞机场，所有飞机从飞机场起飞降落也可以加油。因为买飞机是个十分重大的决定，Byteasar决定寻求你的帮助。他将会让你模拟不同的飞行路线。自然这些飞机一次能走的航程是不同的。对于每次模拟，他想要知道最少需要降落多少次（包括最后一次）。需要注意的是起点可以任意选取。\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] DOO-Around the world", "background": "", "description": "After striving for many years, Byteasar has finally obtained a pilot license. To celebrate, he intends to buy an airplane and fly around the planet 3-SATurn (where Byteotia is located), specifically along the equator. The equator is long, so refueling is necessary.\n\nThere are airports along the equator, and a plane can refuel when it lands at one. Each airplane model has a known flight range on a full tank. Byteasar is considering several different models, which naturally differ in flight range. For each model, determine the minimum number of landings (including the final one) needed to complete a full lap along the equator, starting at an airport of choice. If it is impossible to complete the journey with a given model, report that as well. Note that the starting airport may be chosen independently for each model.", "inputFormat": "The first line contains two integers $n$ and $s$ ($2 \\le n \\le 1\\,000\\,000$, $1 \\le s \\le 100$), separated by a single space, denoting the number of airports along the equator and the number of airplane models Byteasar is considering.\n\nThe second line contains $n$ positive integers $l_1, l_2, \\cdots, l_n$ ($l_1 + l_2 + \\cdots + l_n \\le 10^9$), separated by single spaces, specifying the distances between successive airports along the equator. The number $l_i$ is the distance between the $i$-th and $(i+1)$-st airports (or between the $n$-th and the first if $i = n$), in kilometers.\n\nThe third line contains $s$ integers $d_1, d_2, \\cdots, d_s$ ($1 \\le d_i \\le l_1 + l_2 + \\cdots + l_n$), separated by single spaces. The number $d_i$ is the $i$-th airplane model’s flight range in kilometers, i.e., the maximum distance it can fly before landing and refueling.", "outputFormat": "Print $s$ lines. The $i$-th line should contain a single integer, namely, the minimum number of flight segments (and thus also landings) necessary to fly the $i$-th airplane around the planet 3-SATurn along the equator, starting at an airport of choice, or the word NIE (Polish for “no”) if it is impossible to complete the journey with this airplane.", "hint": "After several years of effort, Byteasar finally obtained a pilot license. To celebrate, he plans to buy an airplane and fly a lap around the equator of the planet Byteotia. Unfortunately, the equator is very long, so he needs to refuel en route. All airports along the equator are known, and an airplane can refuel when it lands at an airport. Because buying an airplane is a major decision, Byteasar seeks your help. He will ask you to simulate different flight routes. Naturally, different airplanes have different ranges per full tank. For each simulation, he wants to know the minimum number of landings required (including the final one). Note that the starting point can be chosen arbitrarily.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] DOO-Around the world", "background": "", "description": "After trying hard for many years, Byteasar has finally received a pilot license.\n\nTo celebrate the fact, he intends to buy himself an airplane and fly around the planet  3-SATurn (as you may have guessed, this is the planet on which Byteotia is located).\n\nSpecifically, Byteasar plans to fly along the equator.\n\nUnfortunately, the equator is rather long, necessitating refuels.\n\n  The flight range (on full tank) of each aircraft is known.\n\nThere is a number of airports along the equator, and a plane can be refueled when it lands on one.\n\nSince buying an airplane is a big decision, Byteasar asks your help.\n\nHe is about to present you with a list of different plane models he is considering.\n\nNaturally, these differ in their flight range.\n\nFor each plane model, he would like to know the minimum number of landings  (including the final one) he would have to make in order to complete the journey.\n\nNote that for each airplane model, the journey may start at a different airport.\n\n通过几年的努力，Byteasar最终拿到了飞行员驾驶证。为了庆祝这一事实，他打算买一架飞机并且绕Byteotia星球赤道飞行一圈。但不幸的是赤道非常长所以需要中途加几次油。现在已知赤道上面所有飞机场，所有飞机从飞机场起飞降落也可以加油。因为买飞机是个十分重大的决定，Byteasar决定寻求你的帮助。他将会让你模拟不同的飞行路线。自然这些飞机一次能走的航程是不同的。对于每次模拟，他想要知道最少需要降落多少次（包括最后一次）。需要注意的是起点可以任意选取。\n", "inputFormat": "The first line of the standard input contains two integers $n$ and $s$ ($2\\le n\\le 1\\ 000\\ 000$, $1\\le s\\le 100$),separated by a single space,  denoting the number of airports along the equator and the number of airplane models Byteasar is considering.\n\nThe second line contains $n$ positive integers $l_1,l_2,\\cdots,l_n$ ($l_1+l_2+\\cdots+l_n\\le 10^9$), separated by single spaces, specifying the distances between successive airports along the equator.\n\nThe number $l_i$ is the distance between the $i$-th and $(i+1)$-st (or $n$-th and first if $i=n$) in kilometers.\n\nThe third line contains $s$ integers $d_1,d_2,\\cdots,d_s$ ($1\\le d_i\\le l_1+l_2+\\cdots+l_n$), separated by single spaces. The number $d_i$ is the $i$-th airplane model's flight range in kilometers, i.e., the maximum distance it can fly before landing and refueling.\n", "outputFormat": "Your program should print $s$ lines to the standard output: the $i$-th of these should contain a single integer, namely, the minimum lumber of flight segments (and thus also landings) necessary to fly the $i$-th airplane around the planet 3-SATurn along the equator, starting at an airport of choice, or the word NIE (Polish for no) if it is impossible to complete the journey with this airplane.\n", "hint": "通过几年的努力，Byteasar最终拿到了飞行员驾驶证。为了庆祝这一事实，他打算买一架飞机并且绕Byteotia星球赤道飞行一圈。但不幸的是赤道非常长所以需要中途加几次油。现在已知赤道上面所有飞机场，所有飞机从飞机场起飞降落也可以加油。因为买飞机是个十分重大的决定，Byteasar决定寻求你的帮助。他将会让你模拟不同的飞行路线。自然这些飞机一次能走的航程是不同的。对于每次模拟，他想要知道最少需要降落多少次（包括最后一次）。需要注意的是起点可以任意选取。\n", "locale": "zh-CN"}}}
{"pid": "P3576", "type": "P", "difficulty": 6, "samples": [["7 5 3\n3 4 1 9 11\n1 2\n1 4\n4 3\n4 5\n4 6\n6 7\n", "21\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2014", "二分", "POI（波兰）", "树形 DP"], "title": "[POI 2014] MRO-Ant colony", "background": "[English Edition](/paste/44plylwf)", "description": "正在寻找食物的蚂蚁们来到了一座山。\n\n这座山有 $n$ 个洞穴，并有 $n-1$ 条道路连接这些洞穴。也就是说，所有的洞穴和道路组成了一个树形结构。\n\n对于每个只有一条道路连接的洞穴，都有一个出入口使得该洞穴与外界相连。\n\n在**每个出入口**处，都有 $g$ 群蚂蚁，第 $i$ 群蚂蚁的大小为 $m_i$。\n\n蚂蚁群会一个接一个地进入山中，当且仅当山中没有蚂蚁，下一群蚂蚁才会进入。\n\n进入山后，蚂蚁们会按如下方式行动：\n\n- 如果蚂蚁们进入了一个洞穴，该洞穴有 $d$ 条道路与之相连（不包括它们进入该洞穴经过的道路），则蚂蚁们会分为大小相等的 $d$ 个蚁群，每个蚁群各选择一条道路，使得一个道路恰好有一条蚁群经过，特别地，如果 $d=0$（即蚁群到达了出口），蚂蚁们会从该出口离开山。\n- 根据上文，假如这个蚁群有 $x$ 只蚂蚁，则每个蚁群会有 $\\left \\lfloor \\dfrac{x}{d} \\right \\rfloor$ 只蚂蚁，多余的蚂蚁将会消失（至于怎么消失，这并不重要 :)）。\n\n下面这张图就是一个例子：大小为 $m$ 的蚁群到达了一个洞穴，该洞穴有 $3$ 条道路（除了它们进入该洞穴时经过的道路），则该蚁群分割成了三个大小为 $\\left \\lfloor \\dfrac{m}{3} \\right \\rfloor$ 的蚁群。\n\n![](https://cdn.luogu.com.cn/upload/pic/6972.png)\n\n在其中一条道路上，有一只食蚁兽，当经过该道路的蚁群大小恰好为 $k$ 时，它会把这个蚁群的蚂蚁全部吃掉。\n\n现在请你求出食蚁兽一共吃掉多少只蚂蚁。", "inputFormat": "第一行三个整数 $n, g, k$。\n\n之后一行 $g$ 个整数，分别为 $m_1, m_2,\\dots, m_g$。\n\n之后 $n-1$ 行，每行两个整数 $a, b$，表示在 $a, b$ 之间有一条边。\n\n输入的第一条边是食蚁兽所在的边。", "outputFormat": "输出一行一个整数， 表示所有被吃掉的蚁群的大小之和。", "hint": "对于 $100\\%$ 的数据，$2\\le n,g\\le10^6$，$1\\le k,m_i\\le10^9$，$1\\le a_i,b_i\\le n$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] MRO-Ant colony", "background": "[English Edition](/paste/44plylwf)", "description": "Ants searching for food have come to a mountain.\n\nThis mountain has $n$ caves and $n-1$ roads connecting these caves. In other words, all caves and roads form a tree.\n\nFor each cave that is connected by exactly one road, there is an entrance that connects that cave to the outside.\n\nAt each entrance, there are $g$ swarms of ants. The size of the $i$-th swarm is $m_i$.\n\nThe swarms enter the mountain one after another; the next swarm enters if and only if there are no ants in the mountain.\n\nOnce inside, the ants move as follows:\n- If a swarm enters a cave that is connected to $d$ roads (excluding the road they used to enter this cave), then the swarm splits into $d$ swarms of equal size, and each swarm chooses one road so that each road is taken by exactly one swarm. In particular, if $d=0$ (i.e., the swarm reaches an exit), the ants leave the mountain through that exit.\n- According to the above, if this swarm has $x$ ants, then each of the $d$ swarms has $\\left\\lfloor \\dfrac{x}{d} \\right\\rfloor$ ants, and the remaining ants disappear (how they disappear is not important :)).\n\nThe figure below shows an example: a swarm of size $m$ arrives at a cave that has $3$ roads (other than the one they came from), and the swarm splits into three swarms of size $\\left\\lfloor \\dfrac{m}{3} \\right\\rfloor$ each.\n\n![](https://cdn.luogu.com.cn/upload/pic/6972.png)\n\nOn one of the roads, there is an anteater. Whenever a swarm passing along that road has size exactly $k$, it eats that entire swarm.\n\nNow, please compute how many ants the anteater eats in total.", "inputFormat": "The first line contains three integers $n, g, k$.\n\nThe next line contains $g$ integers $m_1, m_2, \\dots, m_g$.\n\nThen follow $n-1$ lines, each containing two integers $a, b$, indicating that there is an edge between $a$ and $b$.\n\nThe first edge in the input is the edge where the anteater is located.", "outputFormat": "Output a single integer, the sum of the sizes of all eaten swarms.", "hint": "For $100\\%$ of the testdata, $2 \\le n, g \\le 10^6$, $1 \\le k, m_i \\le 10^9$, $1 \\le a_i, b_i \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] MRO-Ant colony", "background": "[English Edition](/paste/44plylwf)", "description": "正在寻找食物的蚂蚁们来到了一座山。\n\n这座山有 $n$ 个洞穴，并有 $n-1$ 条道路连接这些洞穴。也就是说，所有的洞穴和道路组成了一个树形结构。\n\n对于每个只有一条道路连接的洞穴，都有一个出入口使得该洞穴与外界相连。\n\n在**每个出入口**处，都有 $g$ 群蚂蚁，第 $i$ 群蚂蚁的大小为 $m_i$。\n\n蚂蚁群会一个接一个地进入山中，当且仅当山中没有蚂蚁，下一群蚂蚁才会进入。\n\n进入山后，蚂蚁们会按如下方式行动：\n\n- 如果蚂蚁们进入了一个洞穴，该洞穴有 $d$ 条道路与之相连（不包括它们进入该洞穴经过的道路），则蚂蚁们会分为大小相等的 $d$ 个蚁群，每个蚁群各选择一条道路，使得一个道路恰好有一条蚁群经过，特别地，如果 $d=0$（即蚁群到达了出口），蚂蚁们会从该出口离开山。\n- 根据上文，假如这个蚁群有 $x$ 只蚂蚁，则每个蚁群会有 $\\left \\lfloor \\dfrac{x}{d} \\right \\rfloor$ 只蚂蚁，多余的蚂蚁将会消失（至于怎么消失，这并不重要 :)）。\n\n下面这张图就是一个例子：大小为 $m$ 的蚁群到达了一个洞穴，该洞穴有 $3$ 条道路（除了它们进入该洞穴时经过的道路），则该蚁群分割成了三个大小为 $\\left \\lfloor \\dfrac{m}{3} \\right \\rfloor$ 的蚁群。\n\n![](https://cdn.luogu.com.cn/upload/pic/6972.png)\n\n在其中一条道路上，有一只食蚁兽，当经过该道路的蚁群大小恰好为 $k$ 时，它会把这个蚁群的蚂蚁全部吃掉。\n\n现在请你求出食蚁兽一共吃掉多少只蚂蚁。", "inputFormat": "第一行三个整数 $n, g, k$。\n\n之后一行 $g$ 个整数，分别为 $m_1, m_2,\\dots, m_g$。\n\n之后 $n-1$ 行，每行两个整数 $a, b$，表示在 $a, b$ 之间有一条边。\n\n输入的第一条边是食蚁兽所在的边。", "outputFormat": "输出一行一个整数， 表示所有被吃掉的蚁群的大小之和。", "hint": "对于 $100\\%$ 的数据，$2\\le n,g\\le10^6$，$1\\le k,m_i\\le10^9$，$1\\le a_i,b_i\\le n$。", "locale": "zh-CN"}}}
{"pid": "P3577", "type": "P", "difficulty": 6, "samples": [["6 6\n3 8 5 6 2 2\n1 2\n2 3\n1 3\n3 4\n4 5\n4 6\n", "7\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2014", "POI（波兰）"], "title": "[POI 2014] TUR-Tourism", "background": "", "description": "King Byteasar believes that Byteotia, a land full of beautiful sights, should attract lots of tourists,    who should spend lots of money, which should eventually find their way to the royal treasury.\n\nBut reality does not live up to his dream.\n\nSo the king instructed his councilor to look into this issue.\n\nThe councilor found out that foreigners keep away from Byteotia due to its sparse road network.\n\nLet us remark that there are $n$ towns in Byteotia, connected by $m$ two way roads, each road linking two different towns.\n\nThe roads may lead through picturesque overflies and somewhat less picturesque tunnels.\n\nThere is no guarantee that every town can be reached from every other town.\n\nThe councilor observed that the current road network does not allow for a long journey.\n\nNamely, wherever one starts the journey, it is impossible to visit more than 10 towns without passing through some town twice.\n\nDue to limited funds in the treasury, no new roads will be constructed at the time.\n\nInstead, Byteasar has decided to build a network of tourist information points (TIPs),    staffed by officers who are to advertise the short trips that are available.\n\nFor each town, there should be a TIP either in this town or one of the towns directly    linked by a road.\n\nMoreover, the cost of building the TIP is known for each town.\n\nHelp the king by finding the cheapest way of building TIPs that will satisfy aforementioned condition.\n\n", "inputFormat": "The first line of the standard input contains two integers $n$, $m$ ($2\\le n\\le 20\\ 000$ ,$0\\le m\\le 25\\ 000$), separated by a single space,    that specify the number of towns and roads in Byteotia respectively.\n\nThe towns are numbered from $1$ to $n$.\n\nThe second line of input contains $n$ integers $c_1,c_2,\\cdots,c_n$ ($0\\le c_i\\le 10\\ 000$),    separated by single spaces; the number $c_i$ specifies the cost of building a TIP in the town no. $i$.\n\nThen, a description of the Byteotian road network follows. The $i$-th of the following $m$ lines contains two integers $a_i$,$b_i$ ($1\\le a_i<b_i\\le n$), separated by a single space, that indicate that the towns no. $a_i$ and $b_i$ are linked by a road. There is at most one (direct) road between any pair of towns.\n", "outputFormat": "Your program should print out one integer to the standard output: the total cost of building all the TIPs.\n\n ![](https://cdn.luogu.com.cn/upload/pic/6974.png) \n\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2014] TUR-Tourism", "background": "", "description": "King Byteasar believes that Byteotia, a land full of beautiful sights, should attract lots of tourists,    who should spend lots of money, which should eventually find their way to the royal treasury.\n\nBut reality does not live up to his dream.\n\nSo the king instructed his councilor to look into this issue.\n\nThe councilor found out that foreigners keep away from Byteotia due to its sparse road network.\n\nLet us remark that there are $n$ towns in Byteotia, connected by $m$ two way roads, each road linking two different towns.\n\nThe roads may lead through picturesque overflies and somewhat less picturesque tunnels.\n\nThere is no guarantee that every town can be reached from every other town.\n\nThe councilor observed that the current road network does not allow for a long journey.\n\nNamely, wherever one starts the journey, it is impossible to visit more than 10 towns without passing through some town twice.\n\nDue to limited funds in the treasury, no new roads will be constructed at the time.\n\nInstead, Byteasar has decided to build a network of tourist information points (TIPs),    staffed by officers who are to advertise the short trips that are available.\n\nFor each town, there should be a TIP either in this town or one of the towns directly    linked by a road.\n\nMoreover, the cost of building the TIP is known for each town.\n\nHelp the king by finding the cheapest way of building TIPs that will satisfy aforementioned condition.\n\n", "inputFormat": "The first line of the standard input contains two integers $n$, $m$ ($2\\le n\\le 20\\ 000$ ,$0\\le m\\le 25\\ 000$), separated by a single space,    that specify the number of towns and roads in Byteotia respectively.\n\nThe towns are numbered from $1$ to $n$.\n\nThe second line of input contains $n$ integers $c_1,c_2,\\cdots,c_n$ ($0\\le c_i\\le 10\\ 000$),    separated by single spaces; the number $c_i$ specifies the cost of building a TIP in the town no. $i$.\n\nThen, a description of the Byteotian road network follows. The $i$-th of the following $m$ lines contains two integers $a_i$,$b_i$ ($1\\le a_i<b_i\\le n$), separated by a single space, that indicate that the towns no. $a_i$ and $b_i$ are linked by a road. There is at most one (direct) road between any pair of towns.\n", "outputFormat": "Your program should print out one integer to the standard output: the total cost of building all the TIPs.\n\n ![](https://cdn.luogu.com.cn/upload/pic/6974.png) \n\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2014] TUR-Tourism", "background": "", "description": "国王 Byteasar 认为 Byteotia 是一个充满美丽景色的地方，应该吸引大量游客，他们应该花很多钱，这些钱最终应该流入皇家国库。\n\n但现实并没有达到他的梦想。\n\n因此，国王指示他的顾问调查这个问题。\n\n顾问发现外国人因为 Byteotia 稀疏的道路网络而避开这里。\n\n我们注意到 Byteotia 有 $n$ 个城镇，由 $m$ 条双向道路连接，每条道路连接两个不同的城镇。\n\n这些道路可能经过风景如画的高架桥和不那么美观的隧道。\n\n不能保证每个城镇都可以从其他城镇到达。\n\n顾问观察到当前的道路网络不允许进行长途旅行。\n\n也就是说，无论从哪里开始旅行，都不可能在不经过某个城镇两次的情况下访问超过 10 个城镇。\n\n由于国库资金有限，目前不会修建新的道路。\n\n相反，Byteasar 决定建立一个旅游信息点（TIPs）网络，由官员负责宣传可用的短途旅行。\n\n对于每个城镇，应该在该城镇或通过道路直接连接的城镇之一设立一个 TIP。\n\n此外，每个城镇建设 TIP 的成本是已知的。\n\n通过找到满足上述条件的最便宜的建设 TIP 的方式来帮助国王。", "inputFormat": "标准输入的第一行包含两个整数 $n$ 和 $m$（$2 \\le n \\le 20\\ 000$，$0 \\le m \\le 25\\ 000$），用一个空格分隔，分别指定 Byteotia 的城镇和道路的数量。\n\n城镇编号从 $1$ 到 $n$。\n\n输入的第二行包含 $n$ 个整数 $c_1,c_2,\\cdots,c_n$（$0 \\le c_i \\le 10\\ 000$），用空格分隔；数字 $c_i$ 指定在第 $i$ 个城镇建设 TIP 的成本。\n\n接下来是 Byteotia 道路网络的描述。接下来的 $m$ 行中的第 $i$ 行包含两个整数 $a_i$ 和 $b_i$（$1 \\le a_i < b_i \\le n$），用一个空格分隔，表示第 $a_i$ 个城镇和第 $b_i$ 个城镇之间有一条道路。任何一对城镇之间最多只有一条（直接）道路。", "outputFormat": "你的程序应输出一个整数到标准输出：建设所有 TIP 的总成本。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3578", "type": "P", "difficulty": 6, "samples": [["5\n3 1 1 3\n2 1\n1 4\n3 4\n5 6\n5 2\n1 2 1 3 2\n", "1 2 1 2 5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "POI（波兰）", "树套树", "线性代数"], "title": "[POI 2014] LAM-Solar lamps", "background": "", "description": "Byteasar has a large and pretty garden.\n\nAs he would like to be able to appreciate its beauty even after dusk,he installed lamps across the garden.\n\nThe lamps are directional, i.e., they illuminate only a certain angle, common to them all.\n\nMoreover, Byteasar has aligned them so that they all face the same direction.\n\nLast but not least, these are solar lamps, i.e., they come with solar panelsbut no batteries, strangely enough!  You might think the panels are thus useless,and each lamp will require electricity at night, but not quite: A lamp will produce lightif a sufficient number of lamps illuminate it.\n\nBy now, Byteasar has even come up with an order he is going supply the lamps with electricity,thus turning them on.\n\nFor simplicity, we number the lamps from 1 to $n$ in this order, i.e., the lamp no. $i$ is supplied with electricity at time $i$.  The only thing left for Byteasar (and you, of course!) is tofigure out when exactly each lamp will start emitting light.  Help Byteasar by writing a programthat will determine the answer to this question.\n\n给N盏灯，没盏灯能照到的角度范围是相同的，第i盏灯在第i秒或者被ki盏灯照到后都会亮起，问所有灯都在什么时刻亮起\n", "inputFormat": "The first line of the standard input contains a single integer $n$($1\\le n\\le 200\\ 000$): the number of lamps Byteasar installed.\n\nIn the second line of input, there are four integers $X_1,Y_1,X_2,Y_2$ ($-10^9\\le X_i,Y_i\\le 10^9$, $(X_i,Y_i)\\ne(0,0)$), separated by single spaces,that describe the area illuminated by every lamp.\n\nNamely, if there is a lamp located at the point $(x,y)$, then it illuminatesthe area (together with its edge) within the smaller of the two angles formed by tworays that both originate at $(x,y)$ such that the i-th (for $i=1,2$) ray passes through $(x+X_i,y+Y_i)$. This angle is always smaller than 180 degrees.\n\nThe $n$ input lines that follow specify the locations of the lamps: the $i$-th such line contains two integers $x_i,y_i$ ($-10^9\\le x_i,y_i\\le 10^9$) separated by a single space, that indicate that the lamp no.$i$ is located at the point $(x_i,y_i)$. You may assume that no two lamps share their location.\n\nThe last line of the input contains $n$ integers $k_1,k_2,\\cdots,k_n$ ($1\\le k_i\\le n$), separated by single spaces, that signify that if the lamp no. i is in the area illuminated by at least $k_i$ other lamps, then it will start emitting light as well.\n", "outputFormat": "Your program should print out to the standard output a single line with $n$ integers $t_1,t_2,\\cdots,t_n$, separated by single spaces.\n\nThe number $t_i$ should be the time when the lamp no. $i$ starts producing light.\n", "hint": "给N盏灯，没盏灯能照到的角度范围是相同的，第i盏灯在第i秒或者被ki盏灯照到后都会亮起，问所有灯都在什么时刻亮起\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] LAM-Solar lamps", "background": "", "description": "Byteasar has a large and pretty garden.\n\nAs he would like to be able to appreciate its beauty even after dusk, he installed lamps across the garden.\n\nThe lamps are directional, i.e., they illuminate only a certain angle, common to them all. Moreover, Byteasar has aligned them so that they all face the same direction.\n\nLast but not least, these are solar lamps, i.e., they come with solar panels but no batteries, strangely enough! You might think the panels are thus useless, and each lamp will require electricity at night, but not quite: a lamp will produce light if a sufficient number of lamps illuminate it.\n\nBy now, Byteasar has even come up with an order in which he is going to supply the lamps with electricity, thus turning them on. For simplicity, we number the lamps from 1 to $n$ in this order, i.e., lamp no. $i$ is supplied with electricity at time $i$. The only thing left for Byteasar (and you, of course!) is to figure out when exactly each lamp will start emitting light. Help Byteasar by writing a program that determines the answer to this question.", "inputFormat": "The first line contains a single integer $n$ ($1 \\le n \\le 200\\,000$): the number of lamps Byteasar installed.\n\nThe second line contains four integers $X_1, Y_1, X_2, Y_2$ ($-10^9 \\le X_i, Y_i \\le 10^9$, $(X_i, Y_i) \\ne (0, 0)$), separated by single spaces, that describe the area illuminated by every lamp.\n\nNamely, if there is a lamp located at the point $(x, y)$, then it illuminates the area (together with its edge) within the smaller of the two angles formed by two rays that both originate at $(x, y)$ such that the $i$-th (for $i = 1, 2$) ray passes through $(x + X_i, y + Y_i)$. This angle is always smaller than 180 degrees.\n\nEach of the next $n$ lines specifies the location of a lamp: the $i$-th such line contains two integers $x_i, y_i$ ($-10^9 \\le x_i, y_i \\le 10^9$), separated by a single space, indicating that lamp no. $i$ is located at the point $(x_i, y_i)$. You may assume that no two lamps share their location.\n\nThe last line contains $n$ integers $k_1, k_2, \\cdots, k_n$ ($1 \\le k_i \\le n$), separated by single spaces, signifying that if lamp no. $i$ is in the area illuminated by at least $k_i$ other lamps, then it will start emitting light as well.", "outputFormat": "Print a single line with $n$ integers $t_1, t_2, \\cdots, t_n$, separated by single spaces.\n\nThe number $t_i$ should be the time when lamp no. $i$ starts producing light.", "hint": "There are $n$ lamps. Each lamp has the same angular illumination range and faces the same direction. Lamp $i$ lights up at time $i$, or earlier if it is illuminated by at least $k_i$ other lamps. Determine the time when each lamp lights up.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] LAM-Solar lamps", "background": "", "description": "Byteasar has a large and pretty garden.\n\nAs he would like to be able to appreciate its beauty even after dusk,he installed lamps across the garden.\n\nThe lamps are directional, i.e., they illuminate only a certain angle, common to them all.\n\nMoreover, Byteasar has aligned them so that they all face the same direction.\n\nLast but not least, these are solar lamps, i.e., they come with solar panelsbut no batteries, strangely enough!  You might think the panels are thus useless,and each lamp will require electricity at night, but not quite: A lamp will produce lightif a sufficient number of lamps illuminate it.\n\nBy now, Byteasar has even come up with an order he is going supply the lamps with electricity,thus turning them on.\n\nFor simplicity, we number the lamps from 1 to $n$ in this order, i.e., the lamp no. $i$ is supplied with electricity at time $i$.  The only thing left for Byteasar (and you, of course!) is tofigure out when exactly each lamp will start emitting light.  Help Byteasar by writing a programthat will determine the answer to this question.\n\n给N盏灯，没盏灯能照到的角度范围是相同的，第i盏灯在第i秒或者被ki盏灯照到后都会亮起，问所有灯都在什么时刻亮起\n", "inputFormat": "The first line of the standard input contains a single integer $n$($1\\le n\\le 200\\ 000$): the number of lamps Byteasar installed.\n\nIn the second line of input, there are four integers $X_1,Y_1,X_2,Y_2$ ($-10^9\\le X_i,Y_i\\le 10^9$, $(X_i,Y_i)\\ne(0,0)$), separated by single spaces,that describe the area illuminated by every lamp.\n\nNamely, if there is a lamp located at the point $(x,y)$, then it illuminatesthe area (together with its edge) within the smaller of the two angles formed by tworays that both originate at $(x,y)$ such that the i-th (for $i=1,2$) ray passes through $(x+X_i,y+Y_i)$. This angle is always smaller than 180 degrees.\n\nThe $n$ input lines that follow specify the locations of the lamps: the $i$-th such line contains two integers $x_i,y_i$ ($-10^9\\le x_i,y_i\\le 10^9$) separated by a single space, that indicate that the lamp no.$i$ is located at the point $(x_i,y_i)$. You may assume that no two lamps share their location.\n\nThe last line of the input contains $n$ integers $k_1,k_2,\\cdots,k_n$ ($1\\le k_i\\le n$), separated by single spaces, that signify that if the lamp no. i is in the area illuminated by at least $k_i$ other lamps, then it will start emitting light as well.\n", "outputFormat": "Your program should print out to the standard output a single line with $n$ integers $t_1,t_2,\\cdots,t_n$, separated by single spaces.\n\nThe number $t_i$ should be the time when the lamp no. $i$ starts producing light.\n", "hint": "给N盏灯，没盏灯能照到的角度范围是相同的，第i盏灯在第i秒或者被ki盏灯照到后都会亮起，问所有灯都在什么时刻亮起\n", "locale": "zh-CN"}}}
{"pid": "P3579", "type": "P", "difficulty": 5, "samples": [["4\n3 9 8 8\n1 10 11 15\n4 7 22 23\n2 5 19 24\n", "8\n7\n2\n5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2014", "POI（波兰）", "最大公约数 gcd", "整除分块"], "title": "[POI 2014] PAN-Solar Panels", "background": "", "description": "对于 $n$ 组询问，每组询问给定四个整数 $a,b,c,d$，从区间 $[a,b]$ 和 $[c,d]$ 中任意选取两个整数 $x$ 和 $y$，求 $\\gcd(x,y)$ 的最大值是多少。", "inputFormat": "第一行一个整数 $n$ 代表询问数。   \n接下来 $n$ 行每行代表一个询问，四个整数 $a,b,c,d$ 代表两个区间的范围。", "outputFormat": "$n$ 行每行一个整数代表区间 $[a,b]$ 和 $[c,d]$ 中任意选取两个整数 $x$ 和 $y$，$\\gcd(x,y)$ 的最大值。", "hint": "### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 1000$，$1 \\le a \\le b \\le 10^9$，$1 \\le c\\le d \\le 10^9$。\n\n### 说明\n\nTranslated by @一只书虫仔。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] PAN-Solar Panels", "background": "", "description": "For $n$ queries, each query is given four integers $a, b, c, d$. Choose any two integers $x$ and $y$ from the intervals $[a, b]$ and $[c, d]$, respectively, and find the maximum possible value of $\\gcd(x, y)$.", "inputFormat": "The first line contains an integer $n$ representing the number of queries.  \nThe next $n$ lines each contain a query: four integers $a, b, c, d$ specifying the two intervals.", "outputFormat": "Output $n$ lines, each containing a single integer: the maximum possible value of $\\gcd(x, y)$ when choosing $x$ from $[a, b]$ and $y$ from $[c, d]$.", "hint": "### Constraints\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 1000$, $1 \\le a \\le b \\le 10^9$, $1 \\le c \\le d \\le 10^9$.\n\n### Notes\n\nTranslated by @一只书虫仔。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] PAN-Solar Panels", "background": "", "description": "对于 $n$ 组询问，每组询问给定四个整数 $a,b,c,d$，从区间 $[a,b]$ 和 $[c,d]$ 中任意选取两个整数 $x$ 和 $y$，求 $\\gcd(x,y)$ 的最大值是多少。", "inputFormat": "第一行一个整数 $n$ 代表询问数。   \n接下来 $n$ 行每行代表一个询问，四个整数 $a,b,c,d$ 代表两个区间的范围。", "outputFormat": "$n$ 行每行一个整数代表区间 $[a,b]$ 和 $[c,d]$ 中任意选取两个整数 $x$ 和 $y$，$\\gcd(x,y)$ 的最大值。", "hint": "### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 1000$，$1 \\le a \\le b \\le 10^9$，$1 \\le c\\le d \\le 10^9$。\n\n### 说明\n\nTranslated by @一只书虫仔。", "locale": "zh-CN"}}}
{"pid": "P3580", "type": "P", "difficulty": 6, "samples": [["3 4\n1 8 11\n", "20\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2014", "二分", "树状数组", "POI（波兰）"], "title": "[POI 2014] ZAL-Freight", "background": "", "description": "The train stations in Upper Bytown and Lower Bytown are connected with a single track rail link.\n\nIt takes the train $s$ minutes to travel between them in either direction.\n\nHowever, the trains departing a station have to be spaced at least one minute apart.\n\nMoreover, at all times, all the trains on the rail link have to go in the same direction.\n\nAccording to the timetable at our disposal, $n$ cargo trains destined for Lower Bytown are to pass  through the Upper Bytown.  They are to be loaded with goods in Lower Bytown and then return to  Upper Bytown.  For simplicity, we assume that loading the goods on the train takes virtually no time.\n\nWe are to determine the minimum possible time of the last train returning to Upper Bytown.\n\n有两个城镇，从A到B需要的时间为S，然后有N辆列车需要从A到B再回来，任何时刻铁路上只能有向着同一个方向前进的列车，然后每辆列车有一个从A出发的最早出站时间，问所有列车全部回到A站的最早时间\n", "inputFormat": "The first line of the standard input contains two integers $n$, $s$($1\\le n\\le 1\\ 000\\ 000$, $1\\le s\\le 10^9$),    separated by a single space, that specify the number of trains and the one-way travel time respectively.\n\nThe second line contains $n$ integers $t_1,t_2,\\cdots,t_n$ ($0\\le t_1\\le t_2\\le\\cdots\\le t_n\\le 10^9$),separated by a single space, that specify the arrival times of successive trains at the Upper Bytown station.\n", "outputFormat": "Your program should print out a single line with a single integer to the standard output:\n\nthe minimum possible time of the last train returning to Upper Bytown.\n", "hint": "\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2014] ZAL-Freight", "background": "", "description": "The train stations in Upper Bytown and Lower Bytown are connected with a single-track rail link.\n\nIt takes the train $s$ minutes to travel between them in either direction.\n\nHowever, the trains departing a station have to be spaced at least one minute apart.\n\nMoreover, at all times, all the trains on the rail link have to go in the same direction.\n\nAccording to the timetable at our disposal, $n$ cargo trains destined for Lower Bytown are to pass through Upper Bytown. They are to be loaded with goods in Lower Bytown and then return to Upper Bytown. For simplicity, we assume that loading the goods on the train takes virtually no time.\n\nWe are to determine the minimum possible time of the last train returning to Upper Bytown.\n\nIn summary: there are two towns. It takes $s$ minutes to go from A to B. There are $n$ trains that need to go from A to B and then come back. At any moment, only trains moving in the same direction may be on the track. Each train has an earliest departure time from A. Find the earliest time by which all trains have returned to station A.", "inputFormat": "The first line of the standard input contains two integers $n$, $s$ ($1\\le n\\le 1\\ 000\\ 000$, $1\\le s\\le 10^9$), separated by a single space, that specify the number of trains and the one-way travel time respectively.\n\nThe second line contains $n$ integers $t_1,t_2,\\cdots,t_n$ ($0\\le t_1\\le t_2\\le\\cdots\\le t_n\\le 10^9$), separated by a single space, that specify the arrival times of successive trains at the Upper Bytown station.", "outputFormat": "Print a single integer: the minimum possible time of the last train returning to Upper Bytown.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2014] ZAL-Freight", "background": "", "description": "The train stations in Upper Bytown and Lower Bytown are connected with a single track rail link.\n\nIt takes the train $s$ minutes to travel between them in either direction.\n\nHowever, the trains departing a station have to be spaced at least one minute apart.\n\nMoreover, at all times, all the trains on the rail link have to go in the same direction.\n\nAccording to the timetable at our disposal, $n$ cargo trains destined for Lower Bytown are to pass  through the Upper Bytown.  They are to be loaded with goods in Lower Bytown and then return to  Upper Bytown.  For simplicity, we assume that loading the goods on the train takes virtually no time.\n\nWe are to determine the minimum possible time of the last train returning to Upper Bytown.\n\n有两个城镇，从A到B需要的时间为S，然后有N辆列车需要从A到B再回来，任何时刻铁路上只能有向着同一个方向前进的列车，然后每辆列车有一个从A出发的最早出站时间，问所有列车全部回到A站的最早时间\n", "inputFormat": "The first line of the standard input contains two integers $n$, $s$($1\\le n\\le 1\\ 000\\ 000$, $1\\le s\\le 10^9$),    separated by a single space, that specify the number of trains and the one-way travel time respectively.\n\nThe second line contains $n$ integers $t_1,t_2,\\cdots,t_n$ ($0\\le t_1\\le t_2\\le\\cdots\\le t_n\\le 10^9$),separated by a single space, that specify the arrival times of successive trains at the Upper Bytown station.\n", "outputFormat": "Your program should print out a single line with a single integer to the standard output:\n\nthe minimum possible time of the last train returning to Upper Bytown.\n", "hint": "\n", "locale": "zh-CN"}}}
{"pid": "P3581", "type": "P", "difficulty": 7, "samples": [["5 2 3\n1 3\n5 4", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2015", "POI（波兰）", "哈希 hashing"], "title": "[POI 2015 R1] 圆桌巫师 Sorcerers of the Round Table", "background": "", "description": "$n$ 个人（编号为 $1 \\sim n$）围着圆桌坐成一圈。座位相邻的两个人，其编号之差的绝对值不可以超过 $p$。他们之中有些人不喜欢别人。如果 $a$ 不喜欢 $b$，那么 $b$ 不能坐在 $a$ 右边的那一个位置上。现在，假设第 $n$ 个人的座位已经固定，要给剩下的人安排座位，共有几种合法方案？", "inputFormat": "第一行包含三个整数 $n,k,p$（$1\\le n\\le {10}^6$，$0\\le k\\le {10}^5$，$0\\le p\\le 3$）。接下来 $k$ 行，每行含两个整数 $a_i, b_i$（$1\\le a_i, b_i \\le n$，$a_i \\neq b_i$），表示 $a_i$ 不喜欢 $b_i$。同一组 $a_i,b_i$ 不会重复输入。\n", "outputFormat": "输出一个整数，表示方案数模 ${10}^9+7$ 后的值。", "hint": "原题名称：Czarnoksiężnicy okrągłego stołu。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R1] Sorcerers of the Round Table", "background": "", "description": "There are $n$ people (numbered $1 \\sim n$) sitting in a circle around a round table. For any two people sitting in adjacent seats, the absolute difference of their numbers must not exceed $p$. Among them, some people dislike others. If $a$ dislikes $b$, then $b$ cannot sit in the seat immediately to the right of $a$. Now, assuming the seat of person $n$ has been fixed, how many valid seating arrangements are there for the remaining people?", "inputFormat": "The first line contains three integers $n,k,p$ ($1\\le n\\le {10}^6$, $0\\le k\\le {10}^5$, $0\\le p\\le 3$).  \nThe next $k$ lines each contain two integers $a_i, b_i$ ($1\\le a_i, b_i \\le n$, $a_i \\neq b_i$), meaning $a_i$ dislikes $b_i$. The same pair $a_i,b_i$ will not be repeated.", "outputFormat": "Output a single integer, which is the number of valid arrangements modulo ${10}^9+7$.", "hint": "Original title: Czarnoksiężnicy okrągłego stołu.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R1] 圆桌巫师 Sorcerers of the Round Table", "background": "", "description": "$n$ 个人（编号为 $1 \\sim n$）围着圆桌坐成一圈。座位相邻的两个人，其编号之差的绝对值不可以超过 $p$。他们之中有些人不喜欢别人。如果 $a$ 不喜欢 $b$，那么 $b$ 不能坐在 $a$ 右边的那一个位置上。现在，假设第 $n$ 个人的座位已经固定，要给剩下的人安排座位，共有几种合法方案？", "inputFormat": "第一行包含三个整数 $n,k,p$（$1\\le n\\le {10}^6$，$0\\le k\\le {10}^5$，$0\\le p\\le 3$）。接下来 $k$ 行，每行含两个整数 $a_i, b_i$（$1\\le a_i, b_i \\le n$，$a_i \\neq b_i$），表示 $a_i$ 不喜欢 $b_i$。同一组 $a_i,b_i$ 不会重复输入。\n", "outputFormat": "输出一个整数，表示方案数模 ${10}^9+7$ 后的值。", "hint": "原题名称：Czarnoksiężnicy okrągłego stołu。", "locale": "zh-CN"}}}
{"pid": "P3582", "type": "P", "difficulty": 5, "samples": [["9 4\n2 3 1 1 4 1 2 4 1\n5 3 6 6", "15"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "线段树", "POI（波兰）", "扫描线"], "title": "[POI 2015 R1] 影迷 Movie-goer", "background": "", "description": "共有 $m$ 部电影，编号为 $1,2,\\ldots,m$，第 $i$ 部电影的好看值为 $w_i$。\n\n在 $n$ 天之中，每天会放映一部电影，第 $i$ 天放映的是第 $f_i$ 部。\n\n你可以选择 $l,r$（$1\\le l\\le r\\le n$），并观看第 $l,l+1,\\ldots,r$ 天内所有的电影。\n\n但如果同一部电影你观看多于一次，你会感到无聊，于是无法获得这部电影的好看值。\n\n现在，您需要最大化观看且仅观看过一次的电影的好看值的总和。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行包含 $n$ 个整数，第 $i$ 个表示 $f_i$。\n\n第三行包含 $m$ 个整数，第 $i$ 个表示 $w_i$。", "outputFormat": "一行一个整数，表示仅观看过一次的电影的好看值的总和的最大值。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\le m\\le n\\le 10^6$，$1\\le f_i\\le m$，$1\\le w_i\\le 10^6$。\n\n----\n\n原题名称：Kinoman。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R1] Movie-goer", "background": "", "description": "There are $m$ movies, numbered $1, 2, \\ldots, m$. The $i$-th movie has value $w_i$.\n\nOver $n$ days, exactly one movie is shown per day; on day $i$, movie $f_i$ is shown.\n\nYou may choose $l, r$ ($1 \\le l \\le r \\le n$) and watch all movies shown on days $l, l+1, \\ldots, r$.\n\nHowever, if you watch the same movie more than once, you get bored and therefore cannot obtain this movie’s value.\n\nNow you need to maximize the total value of the movies that are watched exactly once.", "inputFormat": "The first line contains two integers $n, m$.\n\nThe second line contains $n$ integers; the $i$-th is $f_i$.\n\nThe third line contains $m$ integers; the $i$-th is $w_i$.", "outputFormat": "Print one integer, the maximum possible sum of values of movies watched exactly once.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $1 \\le m \\le n \\le 10^6$, $1 \\le f_i \\le m$, and $1 \\le w_i \\le 10^6$.\n\n----\n\nOriginal problem name: Kinoman.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R1] 影迷 Movie-goer", "background": "", "description": "共有 $m$ 部电影，编号为 $1,2,\\ldots,m$，第 $i$ 部电影的好看值为 $w_i$。\n\n在 $n$ 天之中，每天会放映一部电影，第 $i$ 天放映的是第 $f_i$ 部。\n\n你可以选择 $l,r$（$1\\le l\\le r\\le n$），并观看第 $l,l+1,\\ldots,r$ 天内所有的电影。\n\n但如果同一部电影你观看多于一次，你会感到无聊，于是无法获得这部电影的好看值。\n\n现在，您需要最大化观看且仅观看过一次的电影的好看值的总和。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行包含 $n$ 个整数，第 $i$ 个表示 $f_i$。\n\n第三行包含 $m$ 个整数，第 $i$ 个表示 $w_i$。", "outputFormat": "一行一个整数，表示仅观看过一次的电影的好看值的总和的最大值。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\le m\\le n\\le 10^6$，$1\\le f_i\\le m$，$1\\le w_i\\le 10^6$。\n\n----\n\n原题名称：Kinoman。", "locale": "zh-CN"}}}
{"pid": "P3583", "type": "P", "difficulty": 7, "samples": [["30", "4 15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2015", "POI（波兰）"], "title": "[POI 2015 R1] 平方和 Squares", "background": "", "description": "考虑将正整数 $n$ 拆分成几个不同的平方数之和，比如 $30 = 1^2 + 2^2 + 5^2 = 1^2 + 2^2 + 3^2 + 4^2$，而 $8$ 不存在这样的拆分。\n\n用 $k(n)$ 表示 $n$ 的拆分中，最大的底数最小可能是多少。如果 $n$ 不存在这样的拆分，则令 $k(n) = \\infty$。例如：$k(1) = 1$，$k(8) = \\infty$，$k(378) = 12$，$k(380) = 10$。\n\n定义一个数 $x$ 被称为“超重”的，当且仅当存在 $y > x$，使得 $k(y) < k(x)$。从上面的例子可知，$378$ 是一个“超重”的数。\n\n给定 $n$，你需要：\n\n1. 求出 $k(n)$。\n2. 求出 $1 \\sim n$ 中有几个“超重”的数。", "inputFormat": "输入仅一行，包含一个正整数 $n$。", "outputFormat": "输出一行包含两个整数，分别为对上述两个问题的答案。如果 $k(n) = \\infty$，则输出一个减号 `-` 代替。", "hint": "**【数据范围】**\n\n对于 $100 \\%$ 的数据，$1 \\le n \\le {10}^{18}$。\n\n----\n\n原题名称：Kwadraty。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R1] Sum of Squares", "background": "", "description": "Consider expressing a positive integer $n$ as a sum of several distinct squares. For example, $30 = 1^2 + 2^2 + 5^2 = 1^2 + 2^2 + 3^2 + 4^2$, while $8$ has no such decomposition.\n\nLet $k(n)$ denote the minimal possible value of the largest base among all such decompositions of $n$. If no such decomposition exists, set $k(n) = \\infty$. For example: $k(1) = 1$, $k(8) = \\infty$, $k(378) = 12$, $k(380) = 10$.\n\nA number $x$ is called \"overweight\" if and only if there exists $y > x$ such that $k(y) < k(x)$. From the examples above, $378$ is an \"overweight\" number.\n\nGiven $n$, you need to:\n1. Compute $k(n)$.\n2. Count how many \"overweight\" numbers are in the range from $1$ to $n$.", "inputFormat": "The input contains a single line with a positive integer $n$.", "outputFormat": "Output one line containing two integers, which are the answers to the two questions above. If $k(n) = \\infty$, output a minus sign `-` instead.", "hint": "Constraints\n\nFor 100 % of the testdata, $1 \\le n \\le 10^{18}$.\n\nOriginal title: Kwadraty.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R1] 平方和 Squares", "background": "", "description": "考虑将正整数 $n$ 拆分成几个不同的平方数之和，比如 $30 = 1^2 + 2^2 + 5^2 = 1^2 + 2^2 + 3^2 + 4^2$，而 $8$ 不存在这样的拆分。\n\n用 $k(n)$ 表示 $n$ 的拆分中，最大的底数最小可能是多少。如果 $n$ 不存在这样的拆分，则令 $k(n) = \\infty$。例如：$k(1) = 1$，$k(8) = \\infty$，$k(378) = 12$，$k(380) = 10$。\n\n定义一个数 $x$ 被称为“超重”的，当且仅当存在 $y > x$，使得 $k(y) < k(x)$。从上面的例子可知，$378$ 是一个“超重”的数。\n\n给定 $n$，你需要：\n\n1. 求出 $k(n)$。\n2. 求出 $1 \\sim n$ 中有几个“超重”的数。", "inputFormat": "输入仅一行，包含一个正整数 $n$。", "outputFormat": "输出一行包含两个整数，分别为对上述两个问题的答案。如果 $k(n) = \\infty$，则输出一个减号 `-` 代替。", "hint": "**【数据范围】**\n\n对于 $100 \\%$ 的数据，$1 \\le n \\le {10}^{18}$。\n\n----\n\n原题名称：Kwadraty。", "locale": "zh-CN"}}}
{"pid": "P3584", "type": "P", "difficulty": 5, "samples": [["5\n5 3 7 2 9\n", "2 3 3 5 1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2015", "POI（波兰）", "Special Judge"], "title": "[POI 2015 R1] 贪吃鬼 Gluttons", "background": "", "description": "圆桌上摆放着 $n$ 份食物，围成一圈，第 $i$ 份食物所含热量为 $c_i$。相邻两份食物之间坐着一个人，共有 $n$ 个人。每个人有两种选择，吃自己左边或者右边的食物。如果两个人选择了同一份食物，这两个人会平分这份食物，每人获得一半的热量。 假如某个人改变自己的选择后（其他 $n-1$ 个人的选择不变），可以使自己获得比原先更多的热量，那么这个人会不满意。请你给每个人指定应该吃哪一份食物，使得所有人都能够满意。", "inputFormat": "第一行一个整数 $n$，表示食物的数量（即人数，食物和人都从 $1\\sim n$ 编号）。  \n第二行包含 $n$ 个整数 $c_1,c_2,\\dots,c_n$。这里约定，第 $i$（$1\\le i<n$）个人左边是第 $i$ 份食物，右边是第 $i+1$ 份食物；而第 $n$ 个人左边是第 $n$ 份食物，右边是第 $1$ 份食物。", "outputFormat": "如果不存在这样的方案，仅输出一行 `NIE`。  \n如果存在这样的方案，输出一行共 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个人选择的食物的编号。如果有多组这样的方案，输出任意一个即可。", "hint": "**【数据范围】**\n\n对于所有数据，$2\\leqslant n\\leqslant 10^6$，$1\\leqslant c_i\\leqslant 10^9$。\n\n----\n\n原题名称：Łasuchy\n\n感谢 @KSkun 为本题提供 SPJ。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R1] Gluttons", "background": "", "description": "There are $n$ dishes placed around a round table, forming a circle. The $i$-th dish contains $c_i$ calories. Between every pair of adjacent dishes sits one person, so there are $n$ people in total. Each person can choose to eat either the dish on their left or the dish on their right. If two people choose the same dish, they split it equally, and each receives half of that dish’s calories. If a person can obtain strictly more calories than before by changing only their own choice (while the choices of the other $n-1$ people remain unchanged), then that person is dissatisfied. Please assign which dish each person should eat so that everyone is satisfied.", "inputFormat": "The first line contains an integer $n$, the number of dishes (which is also the number of people; both dishes and people are numbered from $1$ to $n$).  \nThe second line contains $n$ integers $c_1, c_2, \\dots, c_n$. We stipulate that for person $i$ ($1 \\le i < n$), the dish on the left is dish $i$, and the dish on the right is dish $i+1$; for person $n$, the dish on the left is dish $n$, and the dish on the right is dish $1$.", "outputFormat": "If no such assignment exists, output a single line NIE.  \nIf such an assignment exists, output one line with $n$ integers, where the $i$-th integer is the index of the dish chosen by person $i$. If multiple valid assignments exist, output any one of them.", "hint": "Constraints\n\nFor all testdata, $2 \\leqslant n \\leqslant 10^6$, $1 \\leqslant c_i \\leqslant 10^9$.\n\n----\n\nOriginal title: Łasuchy.\n\nThanks to @KSkun for providing the SPJ for this problem.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R1] 贪吃鬼 Gluttons", "background": "", "description": "圆桌上摆放着 $n$ 份食物，围成一圈，第 $i$ 份食物所含热量为 $c_i$。相邻两份食物之间坐着一个人，共有 $n$ 个人。每个人有两种选择，吃自己左边或者右边的食物。如果两个人选择了同一份食物，这两个人会平分这份食物，每人获得一半的热量。 假如某个人改变自己的选择后（其他 $n-1$ 个人的选择不变），可以使自己获得比原先更多的热量，那么这个人会不满意。请你给每个人指定应该吃哪一份食物，使得所有人都能够满意。", "inputFormat": "第一行一个整数 $n$，表示食物的数量（即人数，食物和人都从 $1\\sim n$ 编号）。  \n第二行包含 $n$ 个整数 $c_1,c_2,\\dots,c_n$。这里约定，第 $i$（$1\\le i<n$）个人左边是第 $i$ 份食物，右边是第 $i+1$ 份食物；而第 $n$ 个人左边是第 $n$ 份食物，右边是第 $1$ 份食物。", "outputFormat": "如果不存在这样的方案，仅输出一行 `NIE`。  \n如果存在这样的方案，输出一行共 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个人选择的食物的编号。如果有多组这样的方案，输出任意一个即可。", "hint": "**【数据范围】**\n\n对于所有数据，$2\\leqslant n\\leqslant 10^6$，$1\\leqslant c_i\\leqslant 10^9$。\n\n----\n\n原题名称：Łasuchy\n\n感谢 @KSkun 为本题提供 SPJ。", "locale": "zh-CN"}}}
{"pid": "P3585", "type": "P", "difficulty": 3, "samples": [["2\n3 4 4 2\nxx..\n.xx.\nxx..\nx.\n.x\nx.\n..\n2 2 2 2\nxx\nxx\n.x\nx.\n", "TAK\nNIE\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2015", "POI（波兰）"], "title": "[POI 2015 R1] 印章 Seal", "background": "", "description": "一张 $n\\times m$ 的方格纸，有些格子需要印成黑色，剩下的格子需要保留白色。\n\n你有一个 $a\\times b$ 的印章，有些格子是凸起（会沾上墨水）的。你需要判断能否用这个印章印出纸上的图案。印的过程中需要满足以下要求： \n\n1. 印章不可以旋转。 \n2. 不能把墨水印到纸外面。 \n3. 纸上的同一个格子不可以印多次。 ", "inputFormat": "第一行一个整数 $q$（$1\\leq q\\leq 10$），表示测试点数量。 \n\n接下来 $q$ 个测试点，每个测试点中： \n\n第一行包含 $4$ 个整数 $n,m,a,b$（$1\\leq n,m,a,b\\leq 10^3$）。 \n\n接下来 $n$ 行，每行 $m$ 个字符，描述纸上的图案。`.` 表示留白，`x` 表示需要染黑。 \n\n接下来 $a$ 行，每行 $b$ 个字符，描述印章。`.` 表示不沾墨水，`x` 表示沾墨水。 ", "outputFormat": "对于每个测试点，输出 `TAK`（是）或 `NIE`（否）。 ", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R1] Seal", "background": "", "description": "On an $n\\times m$ grid paper, some cells should be stamped black, and the remaining cells should be left white.\n\nYou have an $a\\times b$ stamp in which some cells are raised (will pick up ink). Determine whether you can use this stamp to produce the pattern on the paper, under the following rules:\n1. The stamp cannot be rotated.\n2. You cannot stamp outside the paper.\n3. No cell on the paper may be stamped more than once.", "inputFormat": "The first line contains an integer $q$ ($1\\leq q\\leq 10$), the number of test cases.\n\nThen for each of the $q$ test cases:\n- The first line contains $4$ integers $n, m, a, b$ ($1\\leq n, m, a, b\\leq 10^3$).\n- The next $n$ lines, each with $m$ characters, describe the target pattern on the paper. `.` means blank, `x` means black.\n- The next $a$ lines, each with $b$ characters, describe the stamp. `.` means not inked, `x` means inked.", "outputFormat": "For each test case, output `TAK` (yes) or `NIE` (no).", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R1] 印章 Seal", "background": "", "description": "一张 $n\\times m$ 的方格纸，有些格子需要印成黑色，剩下的格子需要保留白色。\n\n你有一个 $a\\times b$ 的印章，有些格子是凸起（会沾上墨水）的。你需要判断能否用这个印章印出纸上的图案。印的过程中需要满足以下要求： \n\n1. 印章不可以旋转。 \n2. 不能把墨水印到纸外面。 \n3. 纸上的同一个格子不可以印多次。 ", "inputFormat": "第一行一个整数 $q$（$1\\leq q\\leq 10$），表示测试点数量。 \n\n接下来 $q$ 个测试点，每个测试点中： \n\n第一行包含 $4$ 个整数 $n,m,a,b$（$1\\leq n,m,a,b\\leq 10^3$）。 \n\n接下来 $n$ 行，每行 $m$ 个字符，描述纸上的图案。`.` 表示留白，`x` 表示需要染黑。 \n\n接下来 $a$ 行，每行 $b$ 个字符，描述印章。`.` 表示不沾墨水，`x` 表示沾墨水。 ", "outputFormat": "对于每个测试点，输出 `TAK`（是）或 `NIE`（否）。 ", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3586", "type": "P", "difficulty": 6, "samples": [["3 8\nU 1 5\nU 2 7\nZ 2 6\nU 3 1\nZ 2 6\nU 2 2\nZ 2 6\nZ 2 1\n", "NIE\nTAK\nNIE\nTAK\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "平衡树", "树状数组", "POI（波兰）"], "title": "[POI 2015 R2] 物流 Logistics", "background": "", "description": "维护一个长度为 $n$ 的序列，一开始都是 $0$，支持以下两种操作：\n\n1. `U k a` 将序列中第 $k$ 个数修改为 $a$。\n2. `Z c s` 在这个序列上，每次选出 $c$ 个正数，并将它们都减去 $1$，询问能否进行 $s$ 次操作。\n\n每次询问独立，即每次询问不会对序列进行修改。\n", "inputFormat": "第一行包含两个正整数 $n,m$，分别表示序列长度和操作次数。\n\n接下来 $m$ 行为 $m$ 个操作。", "outputFormat": "包含若干行，对于每个 `Z` 询问，若可行，输出 `TAK`，否则输出 `NIE`。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\leq n,m\\leq 10^6$，$1\\leq k,c\\leq n$，$0\\leq a\\leq 10^9$，$1\\leq s\\leq 10^9$。\n\n----\n\n原题名称：Logistyka。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R2] Logistics", "background": "", "description": "Maintain a sequence of length $n$, initially all $0$, supporting the following two operations:\n\n1. `U k a`: set the $k$-th number in the sequence to $a$.\n2. `Z c s`: on this sequence, each time choose $c$ positive numbers and subtract $1$ from each; ask whether it is possible to perform $s$ such operations.\n\nEach query is independent, i.e., each query does not modify the sequence.", "inputFormat": "The first line contains two positive integers $n, m$, denoting the length of the sequence and the number of operations.\n\nThe next $m$ lines contain the $m$ operations.", "outputFormat": "Output several lines. For each `Z` query, print `TAK` if it is possible; otherwise, print `NIE`.", "hint": "**Constraints**\n\nFor $100\\%$ of the testdata, $1\\leq n,m\\leq 10^6$, $1\\leq k,c\\leq n$, $0\\leq a\\leq 10^9$, $1\\leq s\\leq 10^9$.\n\nOriginal title: Logistyka.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R2] 物流 Logistics", "background": "", "description": "维护一个长度为 $n$ 的序列，一开始都是 $0$，支持以下两种操作：\n\n1. `U k a` 将序列中第 $k$ 个数修改为 $a$。\n2. `Z c s` 在这个序列上，每次选出 $c$ 个正数，并将它们都减去 $1$，询问能否进行 $s$ 次操作。\n\n每次询问独立，即每次询问不会对序列进行修改。\n", "inputFormat": "第一行包含两个正整数 $n,m$，分别表示序列长度和操作次数。\n\n接下来 $m$ 行为 $m$ 个操作。", "outputFormat": "包含若干行，对于每个 `Z` 询问，若可行，输出 `TAK`，否则输出 `NIE`。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\leq n,m\\leq 10^6$，$1\\leq k,c\\leq n$，$0\\leq a\\leq 10^9$，$1\\leq s\\leq 10^9$。\n\n----\n\n原题名称：Logistyka。", "locale": "zh-CN"}}}
{"pid": "P3587", "type": "P", "difficulty": 6, "samples": [["9 5\n2 5 3 2 2 4 1 1 3", "4 3"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "线段树", "二分", "单调队列", "POI（波兰）", "哈希 hashing"], "title": "[POI 2015 R2] 项链分割 Necklace partition", "background": "", "description": "长度为 $n$ 的一串项链，每颗珠子是 $k$ 种颜色之一。第 $i$ 颗与第 $i-1,i+1$ 颗珠子相邻，第 $n$ 颗与第 $1$ 颗也相邻。\n\n切两刀，把项链断成两条链。要求每种颜色的珠子只能出现在其中一条链中。\n\n求方案数量（保证至少存在一种），以及切成的两段长度之差绝对值的最小值。", "inputFormat": "第一行 $n,k$（$2\\leq k\\leq n\\leq 10^6$）。颜色从 $1$ 到 $k$ 标号。\n\n接下来 $n$ 个数，按顺序表示每颗珠子的颜色。（保证 $k$ 种颜色各出现至少一次）。 ", "outputFormat": "一行两个整数：方案数量，和长度差的最小值。", "hint": "**【样例解释】**\n\n四种方法中较短的一条分别是 $(5),(4),(1,1),(4,1,1)$。相差最小值 $6-3=3$。 \n\n----\n\n原题名称：Podział naszyjnika。 ", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R2] Necklace Partition", "background": "", "description": "There is a circular necklace with $n$ beads, each bead being one of $k$ colors. Bead $i$ is adjacent to beads $i - 1$ and $i + 1$, and bead $n$ is also adjacent to bead $1$.\n\nCut the necklace at two positions to split it into two linear segments. For each color, all beads of that color must appear in exactly one of the two segments.\n\nCompute the number of valid ways (it is guaranteed that at least one exists), and the minimum absolute difference between the lengths of the two segments.", "inputFormat": "The first line contains $n, k$ ($2 \\leq k \\leq n \\leq 10^6$). Colors are labeled from $1$ to $k$.\n\nThe next $n$ integers, in order, give the color of each bead. (It is guaranteed that each of the $k$ colors appears at least once.)", "outputFormat": "Output one line with two integers: the number of valid ways, and the minimum absolute difference between the lengths of the two segments.", "hint": "【Sample Explanation】\n\nAmong the four ways, the shorter segment is respectively $(5)$, $(4)$, $(1,1)$, $(4,1,1)$. The minimum difference is $6 - 3 = 3$.\n\n----\n\nOriginal title: Podział naszyjnika.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R2] 项链分割 Necklace partition", "background": "", "description": "长度为 $n$ 的一串项链，每颗珠子是 $k$ 种颜色之一。第 $i$ 颗与第 $i-1,i+1$ 颗珠子相邻，第 $n$ 颗与第 $1$ 颗也相邻。\n\n切两刀，把项链断成两条链。要求每种颜色的珠子只能出现在其中一条链中。\n\n求方案数量（保证至少存在一种），以及切成的两段长度之差绝对值的最小值。", "inputFormat": "第一行 $n,k$（$2\\leq k\\leq n\\leq 10^6$）。颜色从 $1$ 到 $k$ 标号。\n\n接下来 $n$ 个数，按顺序表示每颗珠子的颜色。（保证 $k$ 种颜色各出现至少一次）。 ", "outputFormat": "一行两个整数：方案数量，和长度差的最小值。", "hint": "**【样例解释】**\n\n四种方法中较短的一条分别是 $(5),(4),(1,1),(4,1,1)$。相差最小值 $6-3=3$。 \n\n----\n\n原题名称：Podział naszyjnika。 ", "locale": "zh-CN"}}}
{"pid": "P3588", "type": "P", "difficulty": 6, "samples": [["5 2 2\n2 7\n5 3\n1 4 2 2 3\n4 5 1 4", "TAK\n6 7 1000000000 6 3"], ["3 2 1\n2 3\n3 5\n1 3 1 2\n", "NIE\n"], ["2 1 1\n1 1000000000\n1 2 1 2", "NIE\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2015", "线段树", "POI（波兰）", "Special Judge", "记忆化搜索", "拓扑排序"], "title": "[POI 2015 R2] 沙漠 Desert", "background": null, "description": "给定一个长度为 $n$ 的正整数序列 $a$，每个数都在 $1$ 到 $10^9$ 范围内，告诉你其中 $s$ 个数，并给出 $m$ 条信息，每条信息包含三个数 $l,r,k$ 以及接下来 $k$ 个正整数，表示 $a_l, a_{l+1}, \\ldots, a_{r-1}, a_r$ 里这 $k$ 个数中的任意一个都比任意一个剩下的 $r-l+1-k$ 个数大（严格大于，即没有等号）。\n\n请任意构造出一组满足条件的方案，或者判断无解。", "inputFormat": "第一行包含三个正整数 $n,s,m$（$1 \\leq s \\leq n  \\leq 10^5$，$1 \\leq m \\leq 2 \\times 10^5$）。接下来 $s$ 行，每行包含两个正整数 $p_i,d_i$,表示已知 $a_{p_i}=d_i$，保证 $p_i$ 递增。\n\n接下来 $m$ 行,每行一开始为三个正整数 $l_i,r_i,k_i$（$1 \\leq l_i < r_i \\leq n$，$1 \\leq k_i \\leq r_i-l_i$），接下来 $k_i$ 个正整数 $x_1..x_2...x_{k_i}$（$l_i \\leq x_1 < x_2 < ... < x_{k_i} \\leq r_i$），表示这 $k_i$ 个数中的任意一个都比任意一个剩下的 $r_i-l_i+1-k_i$ 个数大。（$\\sum k \\leq 3 \\times 10^5$）", "outputFormat": "若无解，则输出 `NIE`。否则第一行输出 `TAK`，第二行输出 $n$ 个正整数，依次输出序列 $a$ 中每个数。", "hint": "原题名称：Pustynia。\n\n本题另外提供两组额外样例，可以在附件中下载。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R2] Desert", "background": "", "description": "Given a positive integer sequence $a$ of length $n$, where each number is in the range $1$ to $10^9$. You are told $s$ of the numbers, and given $m$ pieces of information. Each piece contains three numbers $l, r, k$ followed by $k$ positive integers, meaning that among $a_l, a_{l+1}, \\ldots, a_{r-1}, a_r$, each of the values at those $k$ positions is strictly greater than each of the values at the remaining $r - l + 1 - k$ positions (strictly greater; no equality).\n\nConstruct any sequence that satisfies all the conditions, or determine that there is no solution.", "inputFormat": "The first line contains three positive integers $n, s, m$ ($1 \\leq s \\leq n \\leq 10^5$, $1 \\leq m \\leq 2 \\times 10^5$). The next $s$ lines each contain two positive integers $p_i, d_i$, meaning $a_{p_i} = d_i$. It is guaranteed that the $p_i$ are in increasing order.\n\nThe next $m$ lines: each line begins with three positive integers $l_i, r_i, k_i$ ($1 \\leq l_i < r_i \\leq n$, $1 \\leq k_i \\leq r_i - l_i$), followed by $k_i$ positive integers $x_1, x_2, \\ldots, x_{k_i}$ ($l_i \\leq x_1 < x_2 < \\cdots < x_{k_i} \\leq r_i$), indicating that in $a_{l_i}, a_{l_i+1}, \\ldots, a_{r_i}$, each of these $k_i$ positions has a value strictly greater than each of the other $r_i - l_i + 1 - k_i$ positions. ($\\sum k_i \\leq 3 \\times 10^5$.)", "outputFormat": "If there is no solution, output `NIE`. Otherwise, output `TAK` on the first line, and on the second line output $n$ positive integers, the sequence $a$ in order.", "hint": "Original title: Pustynia.\n\nTwo additional sample tests are provided and can be downloaded from the attachments.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R2] 沙漠 Desert", "background": null, "description": "给定一个长度为 $n$ 的正整数序列 $a$，每个数都在 $1$ 到 $10^9$ 范围内，告诉你其中 $s$ 个数，并给出 $m$ 条信息，每条信息包含三个数 $l,r,k$ 以及接下来 $k$ 个正整数，表示 $a_l, a_{l+1}, \\ldots, a_{r-1}, a_r$ 里这 $k$ 个数中的任意一个都比任意一个剩下的 $r-l+1-k$ 个数大（严格大于，即没有等号）。\n\n请任意构造出一组满足条件的方案，或者判断无解。", "inputFormat": "第一行包含三个正整数 $n,s,m$（$1 \\leq s \\leq n  \\leq 10^5$，$1 \\leq m \\leq 2 \\times 10^5$）。接下来 $s$ 行，每行包含两个正整数 $p_i,d_i$,表示已知 $a_{p_i}=d_i$，保证 $p_i$ 递增。\n\n接下来 $m$ 行,每行一开始为三个正整数 $l_i,r_i,k_i$（$1 \\leq l_i < r_i \\leq n$，$1 \\leq k_i \\leq r_i-l_i$），接下来 $k_i$ 个正整数 $x_1..x_2...x_{k_i}$（$l_i \\leq x_1 < x_2 < ... < x_{k_i} \\leq r_i$），表示这 $k_i$ 个数中的任意一个都比任意一个剩下的 $r_i-l_i+1-k_i$ 个数大。（$\\sum k \\leq 3 \\times 10^5$）", "outputFormat": "若无解，则输出 `NIE`。否则第一行输出 `TAK`，第二行输出 $n$ 个正整数，依次输出序列 $a$ 中每个数。", "hint": "原题名称：Pustynia。\n\n本题另外提供两组额外样例，可以在附件中下载。", "locale": "zh-CN"}}}
{"pid": "P3589", "type": "P", "difficulty": 5, "samples": [["9 5 6 4 3\n101\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "2015", "POI（波兰）"], "title": "[POI 2015 R2] 快速阅读课程 Speed reading course", "background": "", "description": "给定 $n,a,b,p$，其中 $n,a$ 互质。 \n\n定义一个长度为 $n$ 的 01 串 $c_0c_1\\cdots c_{n-1}$，其中 $c_i$ 等于 0 当且仅当 $(ai+b) \\bmod n < p$。 \n\n给定一个长为 $m$ 的小 01 串，求出小串在大串中出现了几次。 ", "inputFormat": "第一行包含整数 $n,a,b,p,m$（$2\\leq n\\leq 10^9$，$1\\le p,a,b,m<n$，$1\\le m\\le 10^6$）。保证 $n$ 和 $a$ 互质。 \n\n第二行一个长度为 $m$ 的 01 串。 ", "outputFormat": "一个整数，表示小串在大串中出现了几次。 ", "hint": "**【样例解释】**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qd6imu53.png)\n\n----\n\n原题名称：Kurs szybkiego czytania ", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R2] Speed Reading Course", "background": "", "description": "Given $n,a,b,p$, where $n$ and $a$ are coprime.\n\nDefine a binary string $c_0 c_1 \\cdots c_{n-1}$ of length $n$, where $c_i$ equals $0$ if and only if $(ai+b) \\bmod n < p$.\n\nGiven a binary string of length $m$, count how many times the small string appears in the big string.", "inputFormat": "The first line contains integers $n,a,b,p,m$ ($2\\leq n\\leq 10^9$, $1\\le p,a,b,m<n$, $1\\le m\\le 10^6$). It is guaranteed that $n$ and $a$ are coprime.\n\nThe second line contains a binary string of length $m$.", "outputFormat": "Output a single integer, the number of occurrences of the small string in the big string.", "hint": "Bold Sample Explanation\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qd6imu53.png)\n\n----\n\nOriginal title: Kurs szybkiego czytania.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R2] 快速阅读课程 Speed reading course", "background": "", "description": "给定 $n,a,b,p$，其中 $n,a$ 互质。 \n\n定义一个长度为 $n$ 的 01 串 $c_0c_1\\cdots c_{n-1}$，其中 $c_i$ 等于 0 当且仅当 $(ai+b) \\bmod n < p$。 \n\n给定一个长为 $m$ 的小 01 串，求出小串在大串中出现了几次。 ", "inputFormat": "第一行包含整数 $n,a,b,p,m$（$2\\leq n\\leq 10^9$，$1\\le p,a,b,m<n$，$1\\le m\\le 10^6$）。保证 $n$ 和 $a$ 互质。 \n\n第二行一个长度为 $m$ 的 01 串。 ", "outputFormat": "一个整数，表示小串在大串中出现了几次。 ", "hint": "**【样例解释】**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qd6imu53.png)\n\n----\n\n原题名称：Kurs szybkiego czytania ", "locale": "zh-CN"}}}
{"pid": "P3590", "type": "P", "difficulty": 6, "samples": [["9\nCBBSSBCSC", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2015", "线段树", "树状数组", "POI（波兰）"], "title": "[POI 2015 R2] 三座塔 Three towers", "background": "", "description": "给定一个长度为 $n$ 的仅包含 $\\texttt B$、$\\texttt C$、$\\texttt S$ 三种字符的字符串，请找到最长的一段连续子串，使得这一段要么只有一种字符，要么有多种字符，但是没有任意两种字符出现次数相同。", "inputFormat": "第一行包含一个正整数 $n$（$1\\leq n\\leq 10^6$），表示字符串的长度。\n\n第二行一个长度为 $n$ 的字符串。", "outputFormat": "包含一行一个正整数，即最长的满足条件的子串的长度。", "hint": "**【样例解释】**\n\n选择 $\\texttt {BSSBCS}$ 这个子串。\n\n----\n\n原题名称：Trzy wieże。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R2] Three Towers", "background": "", "description": "Given a string of length $n$ containing only the characters $\\texttt B$, $\\texttt C$, and $\\texttt S$, find the longest contiguous substring such that it either contains only one kind of character, or it contains multiple kinds of characters but no two characters occur the same number of times.", "inputFormat": "The first line contains a positive integer $n$ ($1 \\leq n \\leq 10^6$), the length of the string.\nThe second line contains a string of length $n$.", "outputFormat": "Output a single positive integer: the length of the longest substring that satisfies the condition.", "hint": "**Sample Explanation**\n\nChoose the substring $\\texttt {BSSBCS}$.\n\n----\n\nOriginal title: Trzy wieże.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R2] 三座塔 Three towers", "background": "", "description": "给定一个长度为 $n$ 的仅包含 $\\texttt B$、$\\texttt C$、$\\texttt S$ 三种字符的字符串，请找到最长的一段连续子串，使得这一段要么只有一种字符，要么有多种字符，但是没有任意两种字符出现次数相同。", "inputFormat": "第一行包含一个正整数 $n$（$1\\leq n\\leq 10^6$），表示字符串的长度。\n\n第二行一个长度为 $n$ 的字符串。", "outputFormat": "包含一行一个正整数，即最长的满足条件的子串的长度。", "hint": "**【样例解释】**\n\n选择 $\\texttt {BSSBCS}$ 这个子串。\n\n----\n\n原题名称：Trzy wieże。", "locale": "zh-CN"}}}
{"pid": "P3591", "type": "P", "difficulty": 6, "samples": [["5\n1 2 3 4 5\n1 2\n2 3\n3 4\n3 5\n4 1 5 2 3\n1 3 1 1\n", "10\n6\n10\n5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "POI（波兰）", "分块", "根号分治"], "title": "[POI 2015 R3] 访问 Visits", "background": "", "description": "给定一棵 $n$ 个点的树，树上每条边的长度都为 $1$，第 $i$ 个点的权值为 $a_i$。 \n\nByteasar 想要走遍这整棵树，他会按照某个 $1$ 到 $n$ 的全排列 $b$ 走 $n-1$ 次，第 $i$ 次他会从 $b_i$ 点走到 $b_{i + 1}$ 点，并且这一次的步伐大小为 $c_i$。 \n\n对于一次行走，假设起点为 $x$，终点为 $y$，步伐为 $k$，那么 Byteasar 会从 $x$ 开始，每步往前走 $k$ 条边，数据保证了每次行走的距离是 $k$ 的倍数。 \n\n请帮助 Byteasar 统计出每一次行走时经过的所有点的权值和。", "inputFormat": "第一行包含一个正整数 $n$（$2 \\le n \\le 50000$）。表示节点的个数。 \n\n第二行包含 $n$ 个正整数，其中第 $i$ 个数为 $a_i$（$1 \\le a_i \\le 10000$），分别表示每个点的权值。 \n\n接下来 $n-1$ 行，每行包含两个正整数 $u,v$（$1 \\le u,v \\le n$），表示 $u$ 与 $v$ 之间有一条边。 \n\n接下来一行包含 $n$ 个互不相同的正整数，其中第 $i$ 个数为 $b_i$（$1 \\le b_i \\le n$），表示行走路线。 \n\n接下来一行包含 $n-1$ 个正整数，其中第 $i$ 个数为 $c_i$（$1 \\le c_i < n$），表示每次行走的步伐大小。", "outputFormat": "包含 $n-1$ 行，每行一个正整数，依次输出每次行走时经过的所有点的权值和。", "hint": "原题名称：Odwiedziny。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R3] Visits", "background": "", "description": "You are given a tree with $n$ vertices. Each edge has length $1$, and the weight of vertex $i$ is $a_i$.\n\nByteasar wants to traverse the whole tree. He will follow a permutation $b$ of $1$ to $n$ and make $n-1$ walks. On the $i$-th walk, he goes from vertex $b_i$ to vertex $b_{i+1}$, and the step size for this walk is $c_i$.\n\nFor a single walk, suppose the start is $x$, the end is $y$, and the step size is $k$. Byteasar starts at $x$ and moves forward along the unique path from $x$ to $y$, taking steps of exactly $k$ edges each time. The testdata guarantees that the distance of each walk is a multiple of $k$.\n\nPlease help Byteasar compute, for each walk, the sum of the weights of all vertices he visits during that walk.", "inputFormat": "- The first line contains a positive integer $n$ ($2 \\le n \\le 50000$), the number of vertices.\n- The second line contains $n$ positive integers, where the $i$-th number is $a_i$ ($1 \\le a_i \\le 10000$), the weight of vertex $i$.\n- The next $n-1$ lines each contain two positive integers $u, v$ ($1 \\le u, v \\le n$), indicating that there is an edge between $u$ and $v$.\n- The next line contains $n$ distinct positive integers, where the $i$-th number is $b_i$ ($1 \\le b_i \\le n$), describing the route (a permutation).\n- The next line contains $n-1$ positive integers, where the $i$-th number is $c_i$ ($1 \\le c_i < n$), the step size for the $i$-th walk.", "outputFormat": "Output $n-1$ lines. The $i$-th line should contain one positive integer: the sum of the weights of all vertices visited during the $i$-th walk.", "hint": "Original title: Odwiedziny.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R3] 访问 Visits", "background": "", "description": "给定一棵 $n$ 个点的树，树上每条边的长度都为 $1$，第 $i$ 个点的权值为 $a_i$。 \n\nByteasar 想要走遍这整棵树，他会按照某个 $1$ 到 $n$ 的全排列 $b$ 走 $n-1$ 次，第 $i$ 次他会从 $b_i$ 点走到 $b_{i + 1}$ 点，并且这一次的步伐大小为 $c_i$。 \n\n对于一次行走，假设起点为 $x$，终点为 $y$，步伐为 $k$，那么 Byteasar 会从 $x$ 开始，每步往前走 $k$ 条边，数据保证了每次行走的距离是 $k$ 的倍数。 \n\n请帮助 Byteasar 统计出每一次行走时经过的所有点的权值和。", "inputFormat": "第一行包含一个正整数 $n$（$2 \\le n \\le 50000$）。表示节点的个数。 \n\n第二行包含 $n$ 个正整数，其中第 $i$ 个数为 $a_i$（$1 \\le a_i \\le 10000$），分别表示每个点的权值。 \n\n接下来 $n-1$ 行，每行包含两个正整数 $u,v$（$1 \\le u,v \\le n$），表示 $u$ 与 $v$ 之间有一条边。 \n\n接下来一行包含 $n$ 个互不相同的正整数，其中第 $i$ 个数为 $b_i$（$1 \\le b_i \\le n$），表示行走路线。 \n\n接下来一行包含 $n-1$ 个正整数，其中第 $i$ 个数为 $c_i$（$1 \\le c_i < n$），表示每次行走的步伐大小。", "outputFormat": "包含 $n-1$ 行，每行一个正整数，依次输出每次行走时经过的所有点的权值和。", "hint": "原题名称：Odwiedziny。", "locale": "zh-CN"}}}
{"pid": "P3592", "type": "P", "difficulty": 6, "samples": [["7 5\n1 4 7\n3 7 13\n5 6 20\n6 7 1\n1 2 5", "43\n5 5 13 13 20 20 13"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2015", "POI（波兰）", "Special Judge", "区间 DP"], "title": "[POI 2015 R3] 洗车 Car washes", "background": "", "description": "有 $n$ 家洗车店从左往右排成一排，每家店都有一个正整数价格 $p_i$。有 $m$ 个人要来消费，第 $i$ 个人会驶过第 $a_i$ 个开始一直到第 $b_i$ 个洗车店，且会选择这些店中最便宜的一个进行一次消费。但是如果这个最便宜的价格大于 $c_i$，那么这个人就不洗车了。请给每家店指定一个价格，使得所有人花的钱的总和最大。", "inputFormat": "第一行包含两个正整数 $n,m$（$1 \\le n \\le 50$，$1 \\le m \\le 4000$）。接下来 $m$ 行，每行包含三个正整数 $a_i,b_i,c_i$（$1 \\le a_i \\le b_i \\le n$，$1 \\le c_i \\le 5\\times 10^5$）。", "outputFormat": "第一行输出一个正整数，即消费总额的最大值。第二行输出 $n$ 个正整数，依次表示每家洗车店的价格 $p_i$，要求 $1 \\le p_i \\le 5\\times 10^5$。若有多组最优解，输出任意一组。", "hint": "原题名称：Myjnie。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R3] Car Washes", "background": "", "description": "There are $n$ car wash shops arranged in a row from left to right. Each shop has a positive integer price $p_i$. There are $m$ customers. The $i$-th customer will drive past shops from the $a_i$-th to the $b_i$-th, inclusive, and will choose the cheapest shop among these to buy one wash. However, if this cheapest price is greater than $c_i$, then this person does not buy a wash. Assign a price to each shop so that the total amount spent by all customers is maximized.", "inputFormat": "The first line contains two positive integers $n, m$ ($1 \\le n \\le 50$, $1 \\le m \\le 4000$).  \nThe next $m$ lines each contain three positive integers $a_i, b_i, c_i$ ($1 \\le a_i \\le b_i \\le n$, $1 \\le c_i \\le 5\\times 10^5$).", "outputFormat": "On the first line, output a single positive integer — the maximum total spending.  \nOn the second line, output $n$ positive integers, representing the prices $p_i$ of each shop from left to right, with $1 \\le p_i \\le 5\\times 10^5$. If there are multiple optimal solutions, output any of them.", "hint": "Original title: Myjnie.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R3] 洗车 Car washes", "background": "", "description": "有 $n$ 家洗车店从左往右排成一排，每家店都有一个正整数价格 $p_i$。有 $m$ 个人要来消费，第 $i$ 个人会驶过第 $a_i$ 个开始一直到第 $b_i$ 个洗车店，且会选择这些店中最便宜的一个进行一次消费。但是如果这个最便宜的价格大于 $c_i$，那么这个人就不洗车了。请给每家店指定一个价格，使得所有人花的钱的总和最大。", "inputFormat": "第一行包含两个正整数 $n,m$（$1 \\le n \\le 50$，$1 \\le m \\le 4000$）。接下来 $m$ 行，每行包含三个正整数 $a_i,b_i,c_i$（$1 \\le a_i \\le b_i \\le n$，$1 \\le c_i \\le 5\\times 10^5$）。", "outputFormat": "第一行输出一个正整数，即消费总额的最大值。第二行输出 $n$ 个正整数，依次表示每家洗车店的价格 $p_i$，要求 $1 \\le p_i \\le 5\\times 10^5$。若有多组最优解，输出任意一组。", "hint": "原题名称：Myjnie。", "locale": "zh-CN"}}}
{"pid": "P3594", "type": "P", "difficulty": 5, "samples": [["9 7 2\n3 4 1 9 4 1 7 1 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2015", "二分", "单调队列", "POI（波兰）", "双指针 two-pointer"], "title": "[POI 2015 R3] 狼坑 Trous de loup", "background": "", "description": "给定一个长度为 $n$ 的序列，你有一次机会选中一段连续的长度不超过 $d$ 的区间，将里面所有数字全部修改为 $0$。请找到最长的一段连续区间，使得该区间内所有数字之和不超过 $p$。", "inputFormat": "输入的第一行包含三个整数，分别代表 $n,p,d$。\n\n第二行包含 $n$ 个整数，第 $i$ 个整数代表序列中第 $i$ 个数 $w_i$。", "outputFormat": "包含一行一个整数，即修改后能找到的最长的符合条件的区间的长度。\n", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1 \\le d \\le n \\le 2 \\times 10^6$，$0 \\le p \\le 10^{16}$，$1 \\leq w_i \\leq 10^9$。\n\n----\n\n原题名称：Wilcze doły。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R3] Wolf Pits (Trous de loup)", "background": "", "description": "Given a sequence of length $n$, you have one chance to choose a contiguous segment of length at most $d$ and change all numbers inside it to $0$. Find the longest contiguous segment such that the sum of all numbers within this segment does not exceed $p$.", "inputFormat": "The first line contains three integers, $n, p, d$.\n\nThe second line contains $n$ integers; the $i$-th integer is $w_i$, the $i$-th number in the sequence.", "outputFormat": "Output a single integer, the length of the longest valid segment after the modification.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $1 \\le d \\le n \\le 2 \\times 10^6$, $0 \\le p \\le 10^{16}$, $1 \\leq w_i \\leq 10^9$.\n\n----\n\nOriginal title: Wilcze doły.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R3] 狼坑 Trous de loup", "background": "", "description": "给定一个长度为 $n$ 的序列，你有一次机会选中一段连续的长度不超过 $d$ 的区间，将里面所有数字全部修改为 $0$。请找到最长的一段连续区间，使得该区间内所有数字之和不超过 $p$。", "inputFormat": "输入的第一行包含三个整数，分别代表 $n,p,d$。\n\n第二行包含 $n$ 个整数，第 $i$ 个整数代表序列中第 $i$ 个数 $w_i$。", "outputFormat": "包含一行一个整数，即修改后能找到的最长的符合条件的区间的长度。\n", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1 \\le d \\le n \\le 2 \\times 10^6$，$0 \\le p \\le 10^{16}$，$1 \\leq w_i \\leq 10^9$。\n\n----\n\n原题名称：Wilcze doły。", "locale": "zh-CN"}}}
{"pid": "P3596", "type": "P", "difficulty": 6, "samples": [["6\n1 2\n2 3\n2 4\n4 5\n6 5", "3 4 2 2 5\n5 2 1 1 6"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2015", "POI（波兰）", "Special Judge", "树形 DP", "树的直径"], "title": "[POI 2015 R3] 高速公路现代化 Highway modernization", "background": "", "description": "给定一棵无根树，边权都是 $1$，请去掉一条边并加上一条新边，定义直径为最远的两个点的距离，请输出所有可能的新树的直径的最小值和最大值。\n", "inputFormat": "第一行包含一个正整数 $n$，表示这棵树的点数。  \n接下来 $n-1$ 行，每行包含两个正整数，表示 $u,v$ 之间有一条边。", "outputFormat": "第一行输出五个正整数 $k,x_1,y_1,x_2,y_2$，其中 $k$表示新树直径的最小值，$x_1,y_1$ 表示这种情况下要去掉的边的两端点，$x_2,y_2$ 表示这种情况下要加上的边的两端点。\n\n第二行输出五个正整数 $k,x_1,y_1,x_2,y_2$，其中 $k$ 表示新树直径的最大值，$x_1,y_1$ 表示这种情况下要去掉的边的两端点，$x_2,y_2$ 表示这种情况下要加上的边的两端点。若有多组最优解，输出任意一组。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 5 \\times 10 ^ 5$。\n\n----\n\n原题名称：Modernizacja autostrady。\n\n感谢 @cn：苏卿念 提供 spj", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R3] Highway Modernization", "background": "", "description": "You are given an unrooted tree with all edge weights equal to $1$. Remove one edge and add one new edge. The diameter is defined as the distance between the farthest pair of nodes. Among all possible new trees obtained this way, output the minimum and the maximum possible diameter.", "inputFormat": "The first line contains a positive integer $n$, the number of nodes in the tree.  \nThe next $n-1$ lines each contain two positive integers, indicating that there is an edge between $u$ and $v$.", "outputFormat": "On the first line, output five positive integers $k, x_1, y_1, x_2, y_2$, where $k$ is the minimum possible diameter of the new tree, $(x_1, y_1)$ are the endpoints of the edge to remove in this case, and $(x_2, y_2)$ are the endpoints of the edge to add in this case.\n\nOn the second line, output five positive integers $k, x_1, y_1, x_2, y_2$, where $k$ is the maximum possible diameter of the new tree, $(x_1, y_1)$ are the endpoints of the edge to remove in this case, and $(x_2, y_2)$ are the endpoints of the edge to add in this case. If there are multiple optimal solutions, output any one of them.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $2 \\le n \\le 5 \\times 10^5$.\n\n----\n\nOriginal title: Modernizacja autostrady.\n\nThanks to @cn：苏卿念 for providing the spj.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R3] 高速公路现代化 Highway modernization", "background": "", "description": "给定一棵无根树，边权都是 $1$，请去掉一条边并加上一条新边，定义直径为最远的两个点的距离，请输出所有可能的新树的直径的最小值和最大值。\n", "inputFormat": "第一行包含一个正整数 $n$，表示这棵树的点数。  \n接下来 $n-1$ 行，每行包含两个正整数，表示 $u,v$ 之间有一条边。", "outputFormat": "第一行输出五个正整数 $k,x_1,y_1,x_2,y_2$，其中 $k$表示新树直径的最小值，$x_1,y_1$ 表示这种情况下要去掉的边的两端点，$x_2,y_2$ 表示这种情况下要加上的边的两端点。\n\n第二行输出五个正整数 $k,x_1,y_1,x_2,y_2$，其中 $k$ 表示新树直径的最大值，$x_1,y_1$ 表示这种情况下要去掉的边的两端点，$x_2,y_2$ 表示这种情况下要加上的边的两端点。若有多组最优解，输出任意一组。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 5 \\times 10 ^ 5$。\n\n----\n\n原题名称：Modernizacja autostrady。\n\n感谢 @cn：苏卿念 提供 spj", "locale": "zh-CN"}}}
{"pid": "P3597", "type": "P", "difficulty": 6, "samples": [["6 6 11\n1 2 1\n2 3 2\n3 4 2\n4 5 1\n5 3 1\n4 6 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "POI（波兰）", "矩阵乘法"], "title": "[POI 2015 R3] 旅行 Trips", "background": "", "description": "给定一张 $n$ 个点 $m$ 条边的带权有向图，每条边的边权只可能是 $1$，$2$，$3$ 中的一种。\n\n将所有可能的路径按路径长度排序，请输出第 $k$ 小的路径的长度，注意路径不一定是简单路径，即可以重复走同一个点。", "inputFormat": "第一行包含三个整数 $n,m,k$（$1\\le n\\le 40$，$1\\le m\\le 1000$，$1\\le k\\le 10^{18}$）。\n\n接下来 $m$ 行，每行三个整数 $u,v,c$（$1\\leq u,v\\leq n$，$u\\neq v$，$1\\le c\\le 3$），表示从 $u$ 出发有一条到 $v$ 的单向边，边长为 $c$。\n\n**可能有重边**。", "outputFormat": "包含一行一个正整数，即第 $k$ 短的路径的长度，如果不存在，输出 $-1$。", "hint": "**【样例解释】**\n\n长度为 $1$ 的路径有 $1\\to 2$，$5\\to 3$，$4\\to 5$。长度为 $2$ 的路径有 $2\\to3$，$3\\to4$，$4\\to5\\to3$。长度为 $3$ 的路径有 $4\\to6$，$1\\to2\\to3$，$3\\to4\\to5$，$5\\to3\\to4$。长度为 $4$ 的路径有 $5\\to3\\to4\\to5$。\n\n----\n\n原题名称：Wycieczki。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2015 R3] Trips", "background": "", "description": "Given a weighted directed graph with $n$ vertices and $m$ edges, where each edge weight is one of $1$, $2$, or $3$.\n\nSort all possible paths by their total length and output the length of the $k$-th shortest path. Note that a path does not have to be simple; the same vertex may be visited multiple times.", "inputFormat": "The first line contains three integers $n, m, k$ ($1 \\le n \\le 40$, $1 \\le m \\le 1000$, $1 \\le k \\le 10^{18}$).\n\nEach of the next $m$ lines contains three integers $u, v, c$ ($1 \\le u, v \\le n$, $u \\ne v$, $1 \\le c \\le 3$), indicating there is a directed edge from $u$ to $v$ with length $c$.\n\n**Parallel edges may exist.**", "outputFormat": "Output a single positive integer: the length of the $k$-th shortest path. If it does not exist, output $-1$.", "hint": "Sample explanation:\n\nPaths of length $1$: $1\\to 2$, $5\\to 3$, $4\\to 5$. Paths of length $2$: $2\\to 3$, $3\\to 4$, $4\\to 5\\to 3$. Paths of length $3$: $4\\to 6$, $1\\to 2\\to 3$, $3\\to 4\\to 5$, $5\\to 3\\to 4$. Paths of length $4$: $5\\to 3\\to 4\\to 5$.\n\n----\n\nOriginal title: Wycieczki.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2015 R3] 旅行 Trips", "background": "", "description": "给定一张 $n$ 个点 $m$ 条边的带权有向图，每条边的边权只可能是 $1$，$2$，$3$ 中的一种。\n\n将所有可能的路径按路径长度排序，请输出第 $k$ 小的路径的长度，注意路径不一定是简单路径，即可以重复走同一个点。", "inputFormat": "第一行包含三个整数 $n,m,k$（$1\\le n\\le 40$，$1\\le m\\le 1000$，$1\\le k\\le 10^{18}$）。\n\n接下来 $m$ 行，每行三个整数 $u,v,c$（$1\\leq u,v\\leq n$，$u\\neq v$，$1\\le c\\le 3$），表示从 $u$ 出发有一条到 $v$ 的单向边，边长为 $c$。\n\n**可能有重边**。", "outputFormat": "包含一行一个正整数，即第 $k$ 短的路径的长度，如果不存在，输出 $-1$。", "hint": "**【样例解释】**\n\n长度为 $1$ 的路径有 $1\\to 2$，$5\\to 3$，$4\\to 5$。长度为 $2$ 的路径有 $2\\to3$，$3\\to4$，$4\\to5\\to3$。长度为 $3$ 的路径有 $4\\to6$，$1\\to2\\to3$，$3\\to4\\to5$，$5\\to3\\to4$。长度为 $4$ 的路径有 $5\\to3\\to4\\to5$。\n\n----\n\n原题名称：Wycieczki。", "locale": "zh-CN"}}}
{"pid": "P3598", "type": "P", "difficulty": 6, "samples": [["3 5\n1 2 4 5 0", "44044"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "洛谷原创", "洛谷月赛"], "title": "Koishi Loves Number Theory", "background": "", "description": "Koishi 十分喜欢数论。\n\n\n她的朋友 Flandre 为了检测她和数论是不是真爱，给了她一个问题。\n\n\n已知 $f(n)=\\sum_{i=0}^nx^i$\n\n给定 $x$ 和 $N$ 个数 $a_i$，求 $\\mathrm{lcm}(f(a_1),f(a_2),...,f(a_N))$ 对 $10^9+7$ 取模。\n\n\n按照套路，呆萌的 Koishi 当然假装不会做了，于是她来向你请教这个问题，希望你能在 $1$ 秒内给她答案。\n", "inputFormat": "第一行包含两个整数 $x$ 和 $N$，接下来一行 $N$ 个整数表示 $a_i$。\n", "outputFormat": "一个整数，表示答案。\n", "hint": "$\\mathrm{lcm}$ 表示若干个数的**最小公倍数**。\n\n\n对于 $10\\%$ 的数据，$1\\leq N\\leq 100$，$0\\leq a_i\\leq 9$，$x=2$。\n\n对于另外 $20\\%$ 的数据，$1\\leq N\\leq 50$，$0\\leq a_i\\leq 100$，$2\\leq x\\leq 10$。\n\n对于另外 $30\\%$ 的数据，$1\\leq N\\leq 16$，$0\\leq a_i\\leq 10^9$，$2\\leq x\\leq 10^{18}$。\n\n对于 $100\\%$ 的数据，$1\\leq N\\leq 100$，$0\\leq a_i\\leq 10^9$，$2\\leq x\\leq 10^{18}$，且 $x\\not\\equiv 1\\pmod{10^9+7}$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Koishi Loves Number Theory", "background": "", "description": "Koishi loves number theory.\n\nHer friend Flandre, to check whether her love for number theory is true, gave her a problem.\n\nGiven $f(n)=\\sum_{i=0}^n x^i$.\n\nGiven $x$ and $N$ numbers $a_i$, compute $\\mathrm{lcm}(f(a_1),f(a_2),...,f(a_N))$ modulo $10^9+7$.\n\nAs usual, the naive Koishi pretended she could not solve it and came to ask you, hoping you can give the answer within 1 second.", "inputFormat": "The first line contains two integers $x$ and $N$. The next line contains $N$ integers representing $a_i$.", "outputFormat": "One integer, the answer.", "hint": "$\\mathrm{lcm}$ denotes the least common multiple of several numbers.\n\nConstraints:\n- For $10\\%$ of the testdata, $1 \\leq N \\leq 100$, $0 \\leq a_i \\leq 9$, $x=2$.\n- For another $20\\%$ of the testdata, $1 \\leq N \\leq 50$, $0 \\leq a_i \\leq 100$, $2 \\leq x \\leq 10$.\n- For another $30\\%$ of the testdata, $1 \\leq N \\leq 16$, $0 \\leq a_i \\leq 10^9$, $2 \\leq x \\leq 10^{18}$.\n- For $100\\%$ of the testdata, $1 \\leq N \\leq 100$, $0 \\leq a_i \\leq 10^9$, $2 \\leq x \\leq 10^{18}$, and $x \\not\\equiv 1 \\pmod{10^9+7}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Koishi Loves Number Theory", "background": "", "description": "Koishi 十分喜欢数论。\n\n\n她的朋友 Flandre 为了检测她和数论是不是真爱，给了她一个问题。\n\n\n已知 $f(n)=\\sum_{i=0}^nx^i$\n\n给定 $x$ 和 $N$ 个数 $a_i$，求 $\\mathrm{lcm}(f(a_1),f(a_2),...,f(a_N))$ 对 $10^9+7$ 取模。\n\n\n按照套路，呆萌的 Koishi 当然假装不会做了，于是她来向你请教这个问题，希望你能在 $1$ 秒内给她答案。\n", "inputFormat": "第一行包含两个整数 $x$ 和 $N$，接下来一行 $N$ 个整数表示 $a_i$。\n", "outputFormat": "一个整数，表示答案。\n", "hint": "$\\mathrm{lcm}$ 表示若干个数的**最小公倍数**。\n\n\n对于 $10\\%$ 的数据，$1\\leq N\\leq 100$，$0\\leq a_i\\leq 9$，$x=2$。\n\n对于另外 $20\\%$ 的数据，$1\\leq N\\leq 50$，$0\\leq a_i\\leq 100$，$2\\leq x\\leq 10$。\n\n对于另外 $30\\%$ 的数据，$1\\leq N\\leq 16$，$0\\leq a_i\\leq 10^9$，$2\\leq x\\leq 10^{18}$。\n\n对于 $100\\%$ 的数据，$1\\leq N\\leq 100$，$0\\leq a_i\\leq 10^9$，$2\\leq x\\leq 10^{18}$，且 $x\\not\\equiv 1\\pmod{10^9+7}$。\n", "locale": "zh-CN"}}}
{"pid": "P3599", "type": "P", "difficulty": 6, "samples": [["1 1\n8", "2 8 7 6 5 4 3 2 1"], ["2 1\n11", "2 1 2 3 5 10 6 7 4 9 8 11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "洛谷原创", "Special Judge", "构造", "洛谷月赛"], "title": "Koishi Loves Construction", "background": "", "description": "Koishi 决定走出幻想乡成为数学大师！\n\nFlandre 听说她数学学的很好，就给 Koishi 出了这样一道构造题：\n\nTask1：试判断能否构造并构造一个长度为 $n$ 的 $1 \\dots n$ 的排列，满足其 $n$ 个前缀和在模 $n$ 的意义下互不相同。\n\nTask2：试判断能否构造并构造一个长度为 $n$ 的 $1 \\dots n$ 的排列，满足其 $n$ 个前缀积在模 $n$ 的意义下互不相同。\n\n按照套路，Koishi 假装自己根本不会捉，就来找你帮忙辣。", "inputFormat": "第一行两个整数 $X$ 和 $T$，分别表示 Task 类型和测试点内的数据组数。\n\n接下来 $T$ 行，每行一个整数表示每组数据中的 $n$。", "outputFormat": "为了方便 SPJ 的编写，您需要**遵从以下格式**输出。\n\n\n对于每组数据仅包含**一行**输出：\n\n1. 如果您认为当前数据不存在符合题意的构造，只需输出一个整数 $0$。\n2. 如果您认为当前数据存在符合题意的构造却不会构造，只需输出一个整数 $1$。\n3.  如果您认为当前数据存在符合题意的构造并成功构造，则需要先输出一个整数 $2$，再输出 $n$ 个整数表示构造的方案。\n\n**每两个整数之间需要有空格作为分隔符**。", "hint": "对于每组数据：\n\n1. 如果您对于构造的存在性判断正确，您将会得到 $30\\%$ 的分数，若您的构造符合题意或者确实不存在符合题意的构造，您将会得到剩余的 $70\\%$ 的分数。\n2. 如果您对于构造的存在性判断不正确，您将不会得到任何分数。\n\n对于每组测试点，您的得分将是本组数据点中得分的最小值。\n\n测试点类型 $1$：$10$ 分，满足 $X = 1$，$1 \\leq n \\leq 10$。  \n测试点类型 $2$：$40$ 分，满足 $X = 1$，$1 \\leq n \\leq {10}^5$。  \n测试点类型 $3$：$10$ 分，满足 $X = 2$，$1 \\leq n \\leq 10$。  \n测试点类型 $4$：$40$ 分，满足 $X = 2$，$1 \\leq n \\leq {10}^5$。\n\n对于所有测试点，满足 $1 \\leq T \\leq 10$。", "locale": "zh-CN", "translations": {"en": {"title": "Koishi Loves Construction", "background": "", "description": "Koishi decided to leave Gensokyo and become a math master!\n\nFlandre heard that her math is excellent, so she gave Koishi the following construction problem:\n\nTask 1: Determine whether it is possible, and if so construct, a permutation of $1 \\dots n$ of length $n$ such that its $n$ prefix sums are pairwise distinct modulo $n$.\n\nTask 2: Determine whether it is possible, and if so construct, a permutation of $1 \\dots n$ of length $n$ such that its $n$ prefix products are pairwise distinct modulo $n$.\n\nAs usual, Koishi pretended she could not do it and came to ask you for help.", "inputFormat": "The first line contains two integers $X$ and $T$, denoting the task type and the number of test cases in the test point, respectively.\n\nThen follow $T$ lines, each containing one integer $n$ for a test case.", "outputFormat": "For the convenience of the SPJ, you must follow the format below.\n\nFor each test case, output exactly one line:\n\n1. If you believe no valid construction exists, output a single integer $0$.\n2. If you believe a valid construction exists but you cannot construct it, output a single integer $1$.\n3. If you believe a valid construction exists and you successfully construct it, first output a single integer $2$, then output $n$ integers giving your construction.\n\nSeparate every two integers with a space.", "hint": "For each test case:\n\n1. If your existence judgment is correct, you will receive $30\\%$ of the score. If your construction satisfies the requirements or there truly is no valid construction, you will receive the remaining $70\\%$.\n2. If your existence judgment is incorrect, you will receive no points.\n\nTest point type $1$: $10$ points, with $X = 1$, $1 \\leq n \\leq 10$.\nTest point type $2$: $40$ points, with $X = 1$, $1 \\leq n \\leq {10}^5$.\nTest point type $3$: $10$ points, with $X = 2$, $1 \\leq n \\leq 10$.\nTest point type $4$: $40$ points, with $X = 2$, $1 \\leq n \\leq {10}^5$.\n\nFor all test points, it holds that $1 \\leq T \\leq 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Koishi Loves Construction", "background": "", "description": "Koishi 决定走出幻想乡成为数学大师！\n\nFlandre 听说她数学学的很好，就给 Koishi 出了这样一道构造题：\n\nTask1：试判断能否构造并构造一个长度为 $n$ 的 $1 \\dots n$ 的排列，满足其 $n$ 个前缀和在模 $n$ 的意义下互不相同。\n\nTask2：试判断能否构造并构造一个长度为 $n$ 的 $1 \\dots n$ 的排列，满足其 $n$ 个前缀积在模 $n$ 的意义下互不相同。\n\n按照套路，Koishi 假装自己根本不会捉，就来找你帮忙辣。", "inputFormat": "第一行两个整数 $X$ 和 $T$，分别表示 Task 类型和测试点内的数据组数。\n\n接下来 $T$ 行，每行一个整数表示每组数据中的 $n$。", "outputFormat": "为了方便 SPJ 的编写，您需要**遵从以下格式**输出。\n\n\n对于每组数据仅包含**一行**输出：\n\n1. 如果您认为当前数据不存在符合题意的构造，只需输出一个整数 $0$。\n2. 如果您认为当前数据存在符合题意的构造却不会构造，只需输出一个整数 $1$。\n3.  如果您认为当前数据存在符合题意的构造并成功构造，则需要先输出一个整数 $2$，再输出 $n$ 个整数表示构造的方案。\n\n**每两个整数之间需要有空格作为分隔符**。", "hint": "对于每组数据：\n\n1. 如果您对于构造的存在性判断正确，您将会得到 $30\\%$ 的分数，若您的构造符合题意或者确实不存在符合题意的构造，您将会得到剩余的 $70\\%$ 的分数。\n2. 如果您对于构造的存在性判断不正确，您将不会得到任何分数。\n\n对于每组测试点，您的得分将是本组数据点中得分的最小值。\n\n测试点类型 $1$：$10$ 分，满足 $X = 1$，$1 \\leq n \\leq 10$。  \n测试点类型 $2$：$40$ 分，满足 $X = 1$，$1 \\leq n \\leq {10}^5$。  \n测试点类型 $3$：$10$ 分，满足 $X = 2$，$1 \\leq n \\leq 10$。  \n测试点类型 $4$：$40$ 分，满足 $X = 2$，$1 \\leq n \\leq {10}^5$。\n\n对于所有测试点，满足 $1 \\leq T \\leq 10$。", "locale": "zh-CN"}}}
{"pid": "P3600", "type": "P", "difficulty": 6, "samples": [["2 2 1\n1 2", "499967501"], ["6 6 6\n1 3\n2 4\n3 5\n4 6\n5 6\n3 4", "88571635"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "洛谷原创", "O2优化", "期望", "洛谷月赛"], "title": "随机数生成器", "background": "", "description": "sol 研发了一个神奇的随机数系统，可以自动按照环境噪音生成真·随机数。\n\n现在 sol 打算生成 $n$ 个 $[1,x]$ 的整数 $a_1, ..., a_n$，然后进行一些询问。\n\n$q$ 次询问，每次询问 $i$ 有两个参数 $l_i$ 和 $r_i$，sol 会计算 $\\min_{l_i \\leq j \\leq r_i} a_j$（$a$ 数组中下标在 $l_i, r_i$ 之间的数的最小值）。\n\n最后测试结果会是这些询问得到的结果的最大值。\n\nsol 进行了很多次实验，现在他想问问你测试结果的期望大小是多少，对 $666623333$ 取模。\n", "inputFormat": "第一行三个数 $n, x, q$。\n\n下面 $q$ 行，第 $i$ 行两个数表示 $l_i$ 和 $r_i$。\n", "outputFormat": "一行一个数，表示答案。\n", "hint": "提示：一个分数 $\\frac{a}{b}$ 对 $666623333$ 取模的结果为 $a\\times b^{666623331}~\\mod~666623333$。\n\n对于 $10\\%$ 的数据，$n,x,q \\leq 6$。\n\n对于另外 $20\\%$ 的数据，$q=1$。\n\n对于 $50\\%$ 的数据，$n,x,q \\leq 300$。\n\n对于 $70\\%$ 的数据，$n,x,q \\leq 800$。\n\n对于 $100\\%$ 的数据，$1 \\leq n,x,q \\leq 2000$，对于每个 $i$，$1 \\leq l_i \\leq r_i \\leq n$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Random Number Generator", "background": "", "description": "sol developed a magical random number system that can automatically generate true random numbers from environmental noise.\n\nNow sol plans to generate $n$ integers in $[1,x]$, namely $a_1, ..., a_n$, and then handle some queries.\n\nThere are $q$ queries. For each query $i$ with parameters $l_i$ and $r_i$, sol will compute $\\min_{l_i \\leq j \\leq r_i} a_j$ (the minimum value of the numbers in the array $a$ whose indices are between $l_i$ and $r_i$).\n\nFinally, the test result is the maximum among the results of these queries.\n\nsol has conducted many experiments. Now he wants to ask you for the expected value of the test result, modulo $666623333$.", "inputFormat": "The first line contains three integers $n, x, q$.\n\nEach of the next $q$ lines contains two integers $l_i$ and $r_i$.", "outputFormat": "Output a single integer, the answer.", "hint": "Tip: The result of a fraction $\\frac{a}{b}$ modulo $666623333$ is $a\\times b^{666623331}~\\mod~666623333$.\n\nFor $10\\%$ of the testdata, $n,x,q \\leq 6$.\n\nFor another $20\\%$ of the testdata, $q=1$.\n\nFor $50\\%$ of the testdata, $n,x,q \\leq 300$.\n\nFor $70\\%$ of the testdata, $n,x,q \\leq 800$.\n\nFor $100\\%$ of the testdata, $1 \\leq n,x,q \\leq 2000$, and for each $i$, $1 \\leq l_i \\leq r_i \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "随机数生成器", "background": "", "description": "sol 研发了一个神奇的随机数系统，可以自动按照环境噪音生成真·随机数。\n\n现在 sol 打算生成 $n$ 个 $[1,x]$ 的整数 $a_1, ..., a_n$，然后进行一些询问。\n\n$q$ 次询问，每次询问 $i$ 有两个参数 $l_i$ 和 $r_i$，sol 会计算 $\\min_{l_i \\leq j \\leq r_i} a_j$（$a$ 数组中下标在 $l_i, r_i$ 之间的数的最小值）。\n\n最后测试结果会是这些询问得到的结果的最大值。\n\nsol 进行了很多次实验，现在他想问问你测试结果的期望大小是多少，对 $666623333$ 取模。\n", "inputFormat": "第一行三个数 $n, x, q$。\n\n下面 $q$ 行，第 $i$ 行两个数表示 $l_i$ 和 $r_i$。\n", "outputFormat": "一行一个数，表示答案。\n", "hint": "提示：一个分数 $\\frac{a}{b}$ 对 $666623333$ 取模的结果为 $a\\times b^{666623331}~\\mod~666623333$。\n\n对于 $10\\%$ 的数据，$n,x,q \\leq 6$。\n\n对于另外 $20\\%$ 的数据，$q=1$。\n\n对于 $50\\%$ 的数据，$n,x,q \\leq 300$。\n\n对于 $70\\%$ 的数据，$n,x,q \\leq 800$。\n\n对于 $100\\%$ 的数据，$1 \\leq n,x,q \\leq 2000$，对于每个 $i$，$1 \\leq l_i \\leq r_i \\leq n$。\n", "locale": "zh-CN"}}}
{"pid": "P3601", "type": "P", "difficulty": 5, "samples": [["233 2333", "1056499"], ["2333333333 2333666666", "153096296"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "洛谷原创", "O2优化", "洛谷月赛", "欧拉函数"], "title": "签到题", "background": "这是一道签到题！\n\n**建议做题之前仔细阅读数据范围！**\n", "description": "我们定义一个函数：$\\operatorname{qiandao}(x)$ 为小于等于 $x$ 的数中，与 $x$ **不互质**的数的个数。\n\n这题作为签到题，给出 $l$ 和 $r$，求出：\n\n$$\\sum_{i=l}^r \\operatorname{qiandao}(i)\\bmod 666623333$$\n", "inputFormat": "一行两个整数，$l$、$r$。\n", "outputFormat": "一行一个整数表示答案。\n", "hint": "- 对于 $30\\%$ 的数据，$l,r\\leq 10^3$。\n- 对于 $60\\%$ 的数据，$l,r\\leq 10^7$。\n- 对于 $100\\%$ 的数据，$1 \\leq l \\leq r \\leq 10^{12}$，$r-l \\leq 10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Check-in Problem", "background": "This is a check-in problem.\nIt is recommended to carefully read the Constraints before solving.", "description": "We define a function $\\operatorname{qiandao}(x)$ as the number of integers less than or equal to $x$ that are not coprime with $x$.\nGiven $l$ and $r$, compute:\n$$\\sum_{i=l}^r \\operatorname{qiandao}(i)\\bmod 666623333.$$", "inputFormat": "One line with two integers, $l$ and $r$.", "outputFormat": "One line with one integer representing the answer.", "hint": "- For 30% of the testdata, $l,r\\leq 10^3$.\n- For 60% of the testdata, $l,r\\leq 10^7$.\n- For 100% of the testdata, $1 \\leq l \\leq r \\leq 10^{12}$, $r-l \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "签到题", "background": "这是一道签到题！\n\n**建议做题之前仔细阅读数据范围！**\n", "description": "我们定义一个函数：$\\operatorname{qiandao}(x)$ 为小于等于 $x$ 的数中，与 $x$ **不互质**的数的个数。\n\n这题作为签到题，给出 $l$ 和 $r$，求出：\n\n$$\\sum_{i=l}^r \\operatorname{qiandao}(i)\\bmod 666623333$$\n", "inputFormat": "一行两个整数，$l$、$r$。\n", "outputFormat": "一行一个整数表示答案。\n", "hint": "- 对于 $30\\%$ 的数据，$l,r\\leq 10^3$。\n- 对于 $60\\%$ 的数据，$l,r\\leq 10^7$。\n- 对于 $100\\%$ 的数据，$1 \\leq l \\leq r \\leq 10^{12}$，$r-l \\leq 10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P3602", "type": "P", "difficulty": 5, "samples": [["4 3\n1 3\n2 4\n5 7\n6 8\n2 5\n3 1\n6 2", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "线段树", "离散化", "洛谷原创", "O2优化", "洛谷月赛"], "title": "Koishi Loves Segments", "background": "", "description": "Koishi 喜欢线段。\n\n她的 $n$ 条线段都能表示成数轴上的某个闭区间 $[l,r]$。Koishi 喜欢在把所有线段都放在数轴上，然后数出某些点被多少线段覆盖了。\n\nFlandre 看她和线段玩得很起开心，就抛给她一个问题：\n\n数轴上有 $m$ 个点突然兴奋，如果自己被身上覆盖了超过 $x$ 条线段，这个点就会浑身难受然后把 Koishi 批判一番。\n\nKoishi 十分善良，为了不让数轴上的点浑身难受，也为了让自己开心，她想在数轴上放入尽量多的线段。\n\n按照套路，Koishi 假装自己并不会做这道题，所以她就来求你帮忙。并承诺如果你解决了问题就给你打一通电话。", "inputFormat": "第一行两个个整数 $n,m$，分别表示插入的线段数和关键点数。\n\n接下来 $n$ 行，每行两个整数 $l,r(l\\leq r)$，表示线段 $[l,r]$ 的端点。\n\n接下来 $m$ 行，每行两个整数 $p,x$，表示有个位于 $p$ 的点突然兴奋，并认为自己身上不得覆盖超过 $x$ 条线段\n", "outputFormat": "一个整数，表示最多能放入的线段数。\n", "hint": "对于 $20\\%$ 的数据，满足$1\\leq n,m\\leq 20$。\n\n对于 $60\\%$ 的数据，满足$1\\leq n,m\\leq 100$。\n\n对于 $80\\%$的数据，满足$1\\leq n,m\\leq 5000$。\n\n对于 $100\\%$ 的数据，满足$1\\leq x\\leq n\\leq 2\\times 10^5,1\\leq m\\leq 4\\times 10^5,|l|,|r|,|p|\\leq 10^7$\n\n如果一个点兴奋了两次，那么 Koishi 应当满足它的**较严苛的要求**（也就是 $p$ 相同时 $x$ 取最小值啦）\n\n请适当使用读入优化。", "locale": "zh-CN", "translations": {"en": {"title": "Koishi Loves Segments", "background": "", "description": "Koishi likes segments.\n\nEach of her $n$ segments can be represented as a closed interval $[l, r]$ on the number line. Koishi likes to put all the segments on the number line and then count how many segments cover certain points.\n\nSeeing how happily she plays with segments, Flandre throws her a problem:\n\nThere are $m$ points on the number line that suddenly get excited. If a point is covered by more than $x$ segments, it will feel terrible and criticize Koishi.\n\nKoishi is very kind. To avoid making the points feel bad and to make herself happy, she wants to place as many segments on the number line as possible.\n\nAs usual, Koishi pretends she cannot solve this problem, so she asks you for help, and promises to give you a phone call if you solve it.", "inputFormat": "The first line contains two integers $n, m$, denoting the number of segments to insert and the number of excited points.\n\nEach of the next $n$ lines contains two integers $l, r$ ($l \\le r$), denoting the endpoints of a segment $[l, r]$.\n\nEach of the next $m$ lines contains two integers $p, x$, meaning that the point at position $p$ gets excited and requires that it should not be covered by more than $x$ segments.", "outputFormat": "Output a single integer, denoting the maximum number of segments that can be placed.", "hint": "- For 20% of the testdata, $1 \\le n, m \\le 20$.\n- For 60% of the testdata, $1 \\le n, m \\le 100$.\n- For 80% of the testdata, $1 \\le n, m \\le 5000$.\n- Constraints: $1 \\le x \\le n \\le 2\\times 10^5$, $1 \\le m \\le 4\\times 10^5$, $|l|, |r|, |p| \\le 10^7$.\n- If a point gets excited multiple times, Koishi should satisfy its stricter requirement (i.e., when $p$ is the same, take the minimum $x$).\n- Please use fast I/O appropriately.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Koishi Loves Segments", "background": "", "description": "Koishi 喜欢线段。\n\n她的 $n$ 条线段都能表示成数轴上的某个闭区间 $[l,r]$。Koishi 喜欢在把所有线段都放在数轴上，然后数出某些点被多少线段覆盖了。\n\nFlandre 看她和线段玩得很起开心，就抛给她一个问题：\n\n数轴上有 $m$ 个点突然兴奋，如果自己被身上覆盖了超过 $x$ 条线段，这个点就会浑身难受然后把 Koishi 批判一番。\n\nKoishi 十分善良，为了不让数轴上的点浑身难受，也为了让自己开心，她想在数轴上放入尽量多的线段。\n\n按照套路，Koishi 假装自己并不会做这道题，所以她就来求你帮忙。并承诺如果你解决了问题就给你打一通电话。", "inputFormat": "第一行两个个整数 $n,m$，分别表示插入的线段数和关键点数。\n\n接下来 $n$ 行，每行两个整数 $l,r(l\\leq r)$，表示线段 $[l,r]$ 的端点。\n\n接下来 $m$ 行，每行两个整数 $p,x$，表示有个位于 $p$ 的点突然兴奋，并认为自己身上不得覆盖超过 $x$ 条线段\n", "outputFormat": "一个整数，表示最多能放入的线段数。\n", "hint": "对于 $20\\%$ 的数据，满足$1\\leq n,m\\leq 20$。\n\n对于 $60\\%$ 的数据，满足$1\\leq n,m\\leq 100$。\n\n对于 $80\\%$的数据，满足$1\\leq n,m\\leq 5000$。\n\n对于 $100\\%$ 的数据，满足$1\\leq x\\leq n\\leq 2\\times 10^5,1\\leq m\\leq 4\\times 10^5,|l|,|r|,|p|\\leq 10^7$\n\n如果一个点兴奋了两次，那么 Koishi 应当满足它的**较严苛的要求**（也就是 $p$ 相同时 $x$ 取最小值啦）\n\n请适当使用读入优化。", "locale": "zh-CN"}}}
{"pid": "P3603", "type": "P", "difficulty": 6, "samples": [["10 1 0\n0 0 0 1 1 0 2 2 1 2 \n2 3\n1 2\n4 5\n3 4\n7 8\n6 7\n5 6\n9 10\n8 9\n1\n6 8", "2 1"], ["10 1 1\n0 0 1 0 0 2 2 0 0 0 \n2 3\n1 2\n4 5\n3 4\n7 8\n6 7\n5 6\n9 10\n8 9\n4\n1 7\n3 3\n1 1\n9 3\n", "3 3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["倍增", "洛谷原创", "O2优化", "最近公共祖先 LCA", "树链剖分", "分块", "洛谷月赛", "bitset"], "title": "雪辉", "background": "**时间限制3s，空间限制512MB**\n\n\n三周目的由乃被钦定成为了卡密，她立刻赶去二周目的世界寻找雪辉\n\n但是按照设定，两个平行世界是没法互相影响的，也就是原则上由乃是没法去二周目世界的\n\n这时候Deus又跳出来说，其实设定是作者骗你的，只要爱的力量足够强大什么都可以做到（好狗血）\n\n\nDeus：由乃你为了雪辉是不是什么都可以做呀\n\nyuno：当然啦这还用想\n\nDeus：那你帮我做个题吧\n\nyuno：只要不是数据结构，什么题我都做\n\nDeus：出题人是那个n????????呀，他出（抄）的题除了傻逼数据结构还有啥。。。\n\nyuno：你说的很有道理。。。\n\nDeus：上次那个题你不是两分钟就秒了吗，这个题比那个还简单\n\nyuno：（小声）其实那个是bzoj上面的大佬帮我做的\n\nDeus：好吧就这么愉快的钦定了\n\n![](https://cdn.luogu.com.cn/upload/pic/4134.png)\n", "description": "给一个n个点的树，点有点权，有m次询问，每次询问多条链的并有多少种不同的点权以及它的mex\n\nmex就是一个集合中最小的没有出现的非负整数，注意0要算\n\n比如说集合是1,9,2,6,0,8,1,7，则出现了0,1,2,6,7,8,9这7种不同的点权，因为没有3所以mex是3\n\n![](https://cdn.luogu.com.cn/upload/pic/4132.png)\n", "inputFormat": "第一行三个数n，m，意义如题所述，和一个数f\n\n如果f是0，代表Deus没有使用膜法，如果f是1，代表Deus使用了膜法\n\n之后一行n个数，表示点权\n\n之后n-1行，每行两个数x，y，表示x和y节点之间有一条边，保证是一个树\n\n之后m行，每行先是一个数a，表示这次输入a条链，紧接着2a个数(x1,y1)(x2,y2)...表示每条树链\n\n如果数据被Deus施了膜法，这2a个数都要异或上上一个询问的答案lastans，如果是第一次询问则这个lastans = 0，因为每次询问有两个答案，lastans为这两个答案的和\n\n如果没有膜法，则-1s并且不异或\n", "outputFormat": "m行，每行两个数表示点权种类数以及mex\n", "hint": "设a的和为q\n\n对于20%的数据，n,q<=1000，f=0\n\n对于另外30%的数据，n,q<=100000，树是一条链，f=0\n\n对于所有数据n,q<=100000,且点权<=30000\n\n\n最后，由乃祝大家新年快乐\n\n![](https://cdn.luogu.com.cn/upload/pic/4135.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "Yukiteru", "background": "Time limit 3 s, memory limit 512 MB.\n\nIn the third loop, Yuno was appointed as the kamisama, and she immediately rushed to the second loop to find Yukiteru.\n\nHowever, according to the setting, two parallel worlds cannot affect each other, which means in principle Yuno cannot go to the second world.\n\nAt this moment Deus popped out again and said, actually the setting was the author lying to you; as long as the power of love is strong enough, anything can be done (what a melodrama).\n\nDeus: Yuno, will you do anything for Yukiteru?\n\nYuno: Of course, that goes without saying.\n\nDeus: Then help me solve a problem.\n\nYuno: As long as it’s not data structures, I’ll do any problem.\n\nDeus: The problem setter is that n???????? guy. Besides dumb data structures, what else does he write (copy)...\n\nYuno: You have a point...\n\nDeus: Didn’t you insta-solve the last one in two minutes? This one is even easier.\n\nYuno: (quietly) Actually that one was done by a big shot on bzoj.\n\nDeus: Fine, it’s happily decided then.\n\n![](https://cdn.luogu.com.cn/upload/pic/4134.png)", "description": "Given a tree with n nodes. Each node has a weight. There are m queries. For each query, you are given multiple paths. Consider the union of these paths, and ask:\n- how many distinct node weights appear, and\n- the mex of those weights.\n\nThe mex of a set is the smallest non-negative integer that does not appear; note that 0 counts.\n\nFor example, if the set is 1, 9, 2, 6, 0, 8, 1, 7, then the distinct weights that appear are 0, 1, 2, 6, 7, 8, 9 (7 kinds). Since 3 does not appear, the mex is 3.\n\n![](https://cdn.luogu.com.cn/upload/pic/4132.png)", "inputFormat": "- The first line contains three integers n and m as described above, and an integer f.\n  - If f = 0, it means Deus did not use magic.\n  - If f = 1, it means Deus used magic.\n- The second line contains n integers, the node weights.\n- The next n − 1 lines each contain two integers x and y, indicating there is an edge between nodes x and y. It is guaranteed to be a tree.\n- The next m lines each describe a query:\n  - Each line starts with an integer a, the number of paths in this query.\n  - Then follow 2a integers representing the a pairs (x1, y1) (x2, y2) ... corresponding to the paths.\n  - If the testdata has been blessed by Deus’s magic (f = 1), then all these 2a integers must be xor-ed with the previous query’s answer lastans. For the first query, lastans = 0. Since each query has two answers, lastans is the sum of those two answers.\n  - If there is no magic (f = 0), then −1 s and do not xor.", "outputFormat": "Output m lines. Each line contains two integers: the number of distinct node weights and the mex.", "hint": "Let the sum of all a over all queries be q.\n\nConstraints:\n- For 20% of the testdata: n, q ≤ 1000, f = 0.\n- For an additional 30% of the testdata: n, q ≤ 100000, the tree is a path, f = 0.\n- For all testdata: n, q ≤ 100000, and node weights ≤ 30000.\n\nFinally, Yuno wishes everyone a Happy New Year.\n\n![](https://cdn.luogu.com.cn/upload/pic/4135.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "雪辉", "background": "**时间限制3s，空间限制512MB**\n\n\n三周目的由乃被钦定成为了卡密，她立刻赶去二周目的世界寻找雪辉\n\n但是按照设定，两个平行世界是没法互相影响的，也就是原则上由乃是没法去二周目世界的\n\n这时候Deus又跳出来说，其实设定是作者骗你的，只要爱的力量足够强大什么都可以做到（好狗血）\n\n\nDeus：由乃你为了雪辉是不是什么都可以做呀\n\nyuno：当然啦这还用想\n\nDeus：那你帮我做个题吧\n\nyuno：只要不是数据结构，什么题我都做\n\nDeus：出题人是那个n????????呀，他出（抄）的题除了傻逼数据结构还有啥。。。\n\nyuno：你说的很有道理。。。\n\nDeus：上次那个题你不是两分钟就秒了吗，这个题比那个还简单\n\nyuno：（小声）其实那个是bzoj上面的大佬帮我做的\n\nDeus：好吧就这么愉快的钦定了\n\n![](https://cdn.luogu.com.cn/upload/pic/4134.png)\n", "description": "给一个n个点的树，点有点权，有m次询问，每次询问多条链的并有多少种不同的点权以及它的mex\n\nmex就是一个集合中最小的没有出现的非负整数，注意0要算\n\n比如说集合是1,9,2,6,0,8,1,7，则出现了0,1,2,6,7,8,9这7种不同的点权，因为没有3所以mex是3\n\n![](https://cdn.luogu.com.cn/upload/pic/4132.png)\n", "inputFormat": "第一行三个数n，m，意义如题所述，和一个数f\n\n如果f是0，代表Deus没有使用膜法，如果f是1，代表Deus使用了膜法\n\n之后一行n个数，表示点权\n\n之后n-1行，每行两个数x，y，表示x和y节点之间有一条边，保证是一个树\n\n之后m行，每行先是一个数a，表示这次输入a条链，紧接着2a个数(x1,y1)(x2,y2)...表示每条树链\n\n如果数据被Deus施了膜法，这2a个数都要异或上上一个询问的答案lastans，如果是第一次询问则这个lastans = 0，因为每次询问有两个答案，lastans为这两个答案的和\n\n如果没有膜法，则-1s并且不异或\n", "outputFormat": "m行，每行两个数表示点权种类数以及mex\n", "hint": "设a的和为q\n\n对于20%的数据，n,q<=1000，f=0\n\n对于另外30%的数据，n,q<=100000，树是一条链，f=0\n\n对于所有数据n,q<=100000,且点权<=30000\n\n\n最后，由乃祝大家新年快乐\n\n![](https://cdn.luogu.com.cn/upload/pic/4135.png)\n", "locale": "zh-CN"}}}
{"pid": "P3604", "type": "P", "difficulty": 6, "samples": [["6 6\nzzqzzq\n1 6\n2 4\n3 4\n2 3\n4 5\n1 1", "16\n4\n2\n2\n3\n1"], ["6 6\naaabbb\n1 2\n2 3\n3 4\n4 5\n5 6\n1 6", "3\n3\n2\n3\n3\n17"], ["4 1\nyuno\n1 4", "4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [162000, 162000, 162000, 162000, 162000, 162000, 162000, 162000, 162000, 162000]}, "tags": ["莫队", "洛谷原创", "洛谷月赛", "状压 DP"], "title": "美好的每一天", "background": "时间限制 $\\texttt{3s}$，空间限制 $\\texttt{158.2MB}$.\n\n\n素晴らしき日々\n\n我们的情人，不过是随便借个名字，用幻想吹出来的肥皂泡，把信拿去吧，你可以使假戏成真。我本来是无病呻吟，漫无目的的吐露爱情---现在这些漂泊不定的鸟儿有地方栖息了，你可以从信里看出来。拿去吧---由于不是出自真心，话就说得格外动听，拿去吧，就这么办吧……\n\n\n由于世界会在 $7$ 月 $20$ 日完结，作为救世主，间宫卓司要在 $19$ 日让所有人回归天空。\n\n现在已经是 $19$ 日傍晚，大家集合在 C 栋的天台上，一共 $n$ 个人。\n\n在他们面前，便是终之空，那终结的天空。\n\n![](https://cdn.luogu.com.cn/upload/pic/4139.png)", "description": "回归天空是一件庄重的事情，所以卓司决定让大家分批次进行，给每个人给了一个小写字母 $\\texttt{a}\\sim\\texttt{z}$ 作为编号。\n\n一个区间的人如果满足他们的**编号重排之后可以成为一个回文串**，则他们可以一起回归天空，即这个区间可以回归天空。\n\n由于卓司是一个喜欢妄想的人，他妄想了 $m$ 个区间，每次他想知道每个区间中有多少个子区间可以回归天空。\n\n因为世界末日要来了，所以卓司的信徒很多。\n\n![](https://cdn.luogu.com.cn/upload/pic/4138.png)", "inputFormat": "第一行，两个数 $n,m$。\n\n之后一行，一个长为 $n$ 的字符串，代表每个人的编号。\n\n之后 $m$ 行，每行两个数 $l,r$，代表每次卓司妄想的区间。", "outputFormat": "$m$ 行，每行一个数表示答案。", "hint": "对于 $10\\%$ 的数据，$n,m\\le 100$。\n\n对于 $30\\%$ 的数据，$n,m \\le 2000$。\n\n对于 $100\\%$ 的数据，$n,m\\le 60000$。\n\n**字符集大小有梯度**。\n\n\n在大家回归天空之后，彩名露出了阴冷的笑容。\n\n![](https://cdn.luogu.com.cn/upload/pic/4137.png)", "locale": "zh-CN", "translations": {"en": {"title": "Wonderful Everyday", "background": "Time limit $\\texttt{3s}$, memory limit $\\texttt{158.2MB}$.\n\nSubarashiki Hibi.\n\nOur lovers are just names we casually borrow, soap bubbles blown by imagination. Take the letter; you can turn make-believe into reality. I was lamenting without an illness, aimlessly pouring out love—now these drifting birds have a perch, as you can see in the letter. Take it—precisely because it isn’t from the heart, the words sound all the more charming. Take it; let’s do it this way....\n\nSince the world will end on $7$ 月 $20$ 日, as the savior, Mamiya Takuji must let everyone return to the sky on $19$ 日.\n\nIt is already the evening of $19$ 日; everyone has gathered on the rooftop of Building C, $n$ people in total.\n\nIn front of them lies the Terminal Sky, the sky of the end.\n\n![](https://cdn.luogu.com.cn/upload/pic/4139.png)", "description": "Returning to the sky is a solemn matter, so Takuji decides to proceed in batches, giving each person a lowercase letter $\\texttt{a}\\sim\\texttt{z}$ as an identifier.\n\nIf a contiguous interval of people satisfies that their **identifiers, after reordering, can form a palindrome**, then they may return to the sky together; that is, this interval can return to the sky.\n\nBecause Takuji is fond of delusions, he imagines $m$ intervals; for each, he wants to know how many subintervals within it can return to the sky.\n\nSince the end of the world is coming, Takuji has many followers.\n\n![](https://cdn.luogu.com.cn/upload/pic/4138.png)", "inputFormat": "The first line contains two integers $n, m$.\n\nThe next line contains a string of length $n$ representing each person’s identifier.\n\nThen follow $m$ lines; each line contains two integers $l, r$, representing one of Takuji’s imagined intervals.", "outputFormat": "Output $m$ lines, each containing one integer, the answer.", "hint": "For $10\\%$ of the testdata, $n, m \\le 100$.\n\nFor $30\\%$ of the testdata, $n, m \\le 2000$.\n\nFor $100\\%$ of the testdata, $n, m \\le 60000$.\n\nThe character set size varies across the testdata.\n\nAfter everyone returns to the sky, Ayana reveals a chilling smile.\n\n![](https://cdn.luogu.com.cn/upload/pic/4137.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "美好的每一天", "background": "时间限制 $\\texttt{3s}$，空间限制 $\\texttt{158.2MB}$.\n\n\n素晴らしき日々\n\n我们的情人，不过是随便借个名字，用幻想吹出来的肥皂泡，把信拿去吧，你可以使假戏成真。我本来是无病呻吟，漫无目的的吐露爱情---现在这些漂泊不定的鸟儿有地方栖息了，你可以从信里看出来。拿去吧---由于不是出自真心，话就说得格外动听，拿去吧，就这么办吧……\n\n\n由于世界会在 $7$ 月 $20$ 日完结，作为救世主，间宫卓司要在 $19$ 日让所有人回归天空。\n\n现在已经是 $19$ 日傍晚，大家集合在 C 栋的天台上，一共 $n$ 个人。\n\n在他们面前，便是终之空，那终结的天空。\n\n![](https://cdn.luogu.com.cn/upload/pic/4139.png)", "description": "回归天空是一件庄重的事情，所以卓司决定让大家分批次进行，给每个人给了一个小写字母 $\\texttt{a}\\sim\\texttt{z}$ 作为编号。\n\n一个区间的人如果满足他们的**编号重排之后可以成为一个回文串**，则他们可以一起回归天空，即这个区间可以回归天空。\n\n由于卓司是一个喜欢妄想的人，他妄想了 $m$ 个区间，每次他想知道每个区间中有多少个子区间可以回归天空。\n\n因为世界末日要来了，所以卓司的信徒很多。\n\n![](https://cdn.luogu.com.cn/upload/pic/4138.png)", "inputFormat": "第一行，两个数 $n,m$。\n\n之后一行，一个长为 $n$ 的字符串，代表每个人的编号。\n\n之后 $m$ 行，每行两个数 $l,r$，代表每次卓司妄想的区间。", "outputFormat": "$m$ 行，每行一个数表示答案。", "hint": "对于 $10\\%$ 的数据，$n,m\\le 100$。\n\n对于 $30\\%$ 的数据，$n,m \\le 2000$。\n\n对于 $100\\%$ 的数据，$n,m\\le 60000$。\n\n**字符集大小有梯度**。\n\n\n在大家回归天空之后，彩名露出了阴冷的笑容。\n\n![](https://cdn.luogu.com.cn/upload/pic/4137.png)", "locale": "zh-CN"}}}
{"pid": "P3605", "type": "P", "difficulty": 5, "samples": [["5\n804289384\n846930887\n681692778\n714636916\n957747794\n1\n1\n2\n3", "2\n0\n1\n0\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2017", "线段树", "USACO", "树状数组", "树上启发式合并", "离散化", "深度优先搜索 DFS", "线段树合并"], "title": "[USACO17JAN] Promotion Counting P", "background": null, "description": "奶牛们又一次试图创建一家创业公司，还是没有从过去的经验中吸取教训——牛是可怕的管理者！\n\n为了方便，把奶牛从 $1\\sim n$ 编号，把公司组织成一棵树，1 号奶牛作为总裁（这棵树的根节点）。除了总裁以外的每头奶牛都有一个单独的上司（它在树上的 “双亲结点”）。  \n\n所有的第 $i$ 头牛都有一个不同的能力指数 $p_i$，描述了她对其工作的擅长程度。如果奶牛 $i$ 是奶牛 $j$ 的祖先节点，那么我们把奶牛 $j$ 叫做 $i$ 的下属。\n\n不幸地是，奶牛们发现经常发生一个上司比她的一些下属能力低的情况，在这种情况下，上司应当考虑晋升她的一些下属。你的任务是帮助奶牛弄清楚这是什么时候发生的。简而言之，对于公司的中的每一头奶牛 $i$，请计算其下属 $j$ 的数量满足 $p_j > p_i$。", "inputFormat": "输入的第一行包括一个整数 $n$。\n\n接下来的 $n$ 行包括奶牛们的能力指数 $p_1,p_2 \\dots p_n$。保证所有数互不相同。\n\n接下来的 $n-1$ 行描述了奶牛 $2 \\sim n$ 的上司的编号。再次提醒，1 号奶牛作为总裁，没有上司。", "outputFormat": "输出包括 $n$ 行。输出的第 $i$ 行应当给出有多少奶牛 $i$ 的下属比奶牛 $i$ 能力高。", "hint": "对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，$1 \\le p_i \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO17JAN] Promotion Counting P", "background": null, "description": "The cows have once again tried to form a startup company, failing to remember from past experience that cows make terrible managers!\n\nThe cows, conveniently numbered $1 \\ldots N (1 \\leq N \\leq 100,000)$, organize the company as a tree, with cow 1 as the president (the root of the tree). Each cow except the president has a single manager (its \"parent\" in the tree). Each cow i has a distinct proficiency rating, $p(i)$, which describes how good she is at her job. If cow i is an ancestor (e.g., a manager of a manager of a manager) of cow $j$, then we say $j$ is a subordinate of $i$.\n\nUnfortunately, the cows find that it is often the case that a manager has less proficiency than several of her subordinates, in which case the manager should consider promoting some of her subordinates. Your task is to help the cows figure out when this is happening. For each cow $i$ in the company, please count the number of subordinates $j$ where $p(j) \\gt p(i)$.", "inputFormat": "The first line of input contains $N$.\n\nThe next $N$ lines of input contain the proficiency ratings $p(1) \\ldots p(N)$ for the cows. Each is a distinct integer in the range $1 \\ldots 1,000,000,000$.\n\nThe next $N-1$ lines describe the manager (parent) for cows $2 \\ldots N$. Recall that cow 1 has no manager, being the president.", "outputFormat": "Please print $N$ lines of output. The $i$-th line of output should tell the number of subordinates of cow $i$ with higher proficiency than cow $i$.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO17JAN] Promotion Counting P", "background": null, "description": "奶牛们又一次试图创建一家创业公司，还是没有从过去的经验中吸取教训——牛是可怕的管理者！\n\n为了方便，把奶牛从 $1\\sim n$ 编号，把公司组织成一棵树，1 号奶牛作为总裁（这棵树的根节点）。除了总裁以外的每头奶牛都有一个单独的上司（它在树上的 “双亲结点”）。  \n\n所有的第 $i$ 头牛都有一个不同的能力指数 $p_i$，描述了她对其工作的擅长程度。如果奶牛 $i$ 是奶牛 $j$ 的祖先节点，那么我们把奶牛 $j$ 叫做 $i$ 的下属。\n\n不幸地是，奶牛们发现经常发生一个上司比她的一些下属能力低的情况，在这种情况下，上司应当考虑晋升她的一些下属。你的任务是帮助奶牛弄清楚这是什么时候发生的。简而言之，对于公司的中的每一头奶牛 $i$，请计算其下属 $j$ 的数量满足 $p_j > p_i$。", "inputFormat": "输入的第一行包括一个整数 $n$。\n\n接下来的 $n$ 行包括奶牛们的能力指数 $p_1,p_2 \\dots p_n$。保证所有数互不相同。\n\n接下来的 $n-1$ 行描述了奶牛 $2 \\sim n$ 的上司的编号。再次提醒，1 号奶牛作为总裁，没有上司。", "outputFormat": "输出包括 $n$ 行。输出的第 $i$ 行应当给出有多少奶牛 $i$ 的下属比奶牛 $i$ 能力高。", "hint": "对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，$1 \\le p_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3606", "type": "P", "difficulty": 5, "samples": [["2 5\n10\n4", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "贪心", "2017", "二分", "USACO"], "title": "[USACO17JAN] Building a Tall Barn P", "background": "", "description": "Farmer John is building a brand new, $N$-story barn, with the help of his $K$ cows ($1 \\leq N \\leq K \\leq 10^{12}$ and $N \\leq 10^5$). To build it as quickly as possible, he needs your help to figure out how to allocate work among the cows.\n\nEach cow must be assigned to work on exactly one specific floor out of the $N$ total floors in the barn, and each floor must have at least one cow assigned to it. The $i$th floor requires $a_i$ units of total work, and each cow completes one unit of work per hour, so if $c$ cows work on floor $i$, it will be completed in $a_i / c$ units of time. For safety reasons, floor $i$ must be completed before construction can begin on floor $i+1$.\n\nPlease compute the minimum total time in which the barn can be completed, if the cows are allocated to work on floors in an optimal fashion. Output this number rounded to the nearest integer; it is guaranteed that the solution will be more than 0.1 from the boundary between two integers.", "inputFormat": "The first line of input contains $N$ and $K$.\n\nThe next $N$ lines contain $a_1 \\ldots a_N$, each a positive integer of size at most $10^{12}$.", "outputFormat": "Please output the minimum time required to build the barn, rounded to the\n\nnearest integer.\n\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17JAN] Building a Tall Barn P", "background": "", "description": "Farmer John is building a brand new, $N$-story barn, with the help of his $K$ cows ($1 \\leq N \\leq K \\leq 10^{12}$ and $N \\leq 10^5$). To build it as quickly as possible, he needs your help to figure out how to allocate work among the cows.\n\nEach cow must be assigned to work on exactly one specific floor out of the $N$ total floors in the barn, and each floor must have at least one cow assigned to it. The $i$th floor requires $a_i$ units of total work, and each cow completes one unit of work per hour, so if $c$ cows work on floor $i$, it will be completed in $a_i / c$ units of time. For safety reasons, floor $i$ must be completed before construction can begin on floor $i+1$.\n\nPlease compute the minimum total time in which the barn can be completed, if the cows are allocated to work on floors in an optimal fashion. Output this number rounded to the nearest integer; it is guaranteed that the solution will be more than 0.1 from the boundary between two integers.", "inputFormat": "The first line of input contains $N$ and $K$.\n\nThe next $N$ lines contain $a_1 \\ldots a_N$, each a positive integer of size at most $10^{12}$.", "outputFormat": "Please output the minimum time required to build the barn, rounded to the\n\nnearest integer.\n\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17JAN] Building a Tall Barn P", "background": null, "description": "### 题目大意\nFJ 正在他的 $K$ 头奶牛的帮助下建造一个全新的 $N$ 层谷仓（$1\\le N\\le K\\le 10^{12}，N\\le 10^5$)。为了能够尽快的建造它，他需要你帮助他来找出如何在奶牛间分配工作。\n\n每一头牛必须分配到 $N$ 层中的某一个特定楼层中，并且每一层楼必须至少有一头牛在其中工作。第 $i$ 层楼需要 $a_i$ 个单位的工作，并且每一头牛完成每一单位的工作需要一个单位时间。所以如果有 $C$ 头牛在第 $i$ 层工作，那么第 $i$ 层需要 $\\frac{a_i}{c}$ 个单位时间。为了安全起见，在开始施工第 $i+1$ 层楼之前，必须先完成第 $i$ 层。\n\n如果奶牛被分配以最佳方式在楼层上工作，请计算完成谷仓的最小总时间。输出这个时间四舍五入到整数的结果；数据保证答案离两个整数间的中界大于 $0.1$。", "inputFormat": "第一行包括两个数 $N$ 和 $K$。\n\n接下来 $N$ 行包括了$a_1\\dots a_n$，每行一个不大于 $10^{12}$ 的正整数。", "outputFormat": "请输出完成谷仓的最小总时间（四舍五入至整数）。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3607", "type": "P", "difficulty": 6, "samples": [["9\n1\n2\n3\n9\n5\n6\n8\n7\n4", "9\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2017", "USACO", "枚举"], "title": "[USACO17JAN] Subsequence Reversal P", "background": "", "description": "Farmer John is arranging his $N$ cows in a line to take a photo ($1 \\leq N \\leq 50$). The height of the $i$th cow in sequence is $a(i)$, and Farmer John thinks it would make for an aesthetically pleasing photo if the cow lineup has a large increasing subsequence of cows by height.\n\nTo recall, a subsequence is a subset $a(i_1), a(i_2), \\ldots, a(i_k)$ of elements from the cow sequence, found at some series of indices $i_1 < i_2 < \\ldots < i_k$. We say the subsequence is increasing if $a(i_1) \\leq a(i_2) \\leq \\ldots \\leq a(i_k)$.\n\nFJ would like there to be a long increasing subsequence within his ordering of the cows. In order to ensure this, he allows himself initially to choose any subsequence and reverse its elements.\n\nFor example, if we had the list\n\n```\n1 6 2 3 4 3 5 3 4\n```\n\nWe can reverse the chosen elements\n\n```\n1 6 2 3 4 3 5 3 4\n  ^         ^ ^ ^\n```\nto get\n\n```\n1 4 2 3 4 3 3 5 6\n  ^         ^ ^ ^\n```\nObserve how the subsequence being reversed ends up using the same indices as it initially occupied, leaving the other elements unchanged.\n\nPlease find the maximum possible length of an increasing subsequence, given that you can choose to reverse an arbitrary subsequence once.", "inputFormat": "The first line of input contains $N$. The remaining $N$ lines contain $a(1) \\ldots a(N)$, each an integer in the range $1 \\ldots 50$.", "outputFormat": "Output the number of elements that can possibly form a longest increasing subsequence after reversing the contents of at most one subsequence.", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17JAN] Subsequence Reversal P", "background": "", "description": "Farmer John is arranging his $N$ cows in a line to take a photo ($1 \\leq N \\leq 50$). The height of the $i$th cow in sequence is $a(i)$, and Farmer John thinks it would make for an aesthetically pleasing photo if the cow lineup has a large increasing subsequence of cows by height.\n\nTo recall, a subsequence is a subset $a(i_1), a(i_2), \\ldots, a(i_k)$ of elements from the cow sequence, found at some series of indices $i_1 < i_2 < \\ldots < i_k$. We say the subsequence is increasing if $a(i_1) \\leq a(i_2) \\leq \\ldots \\leq a(i_k)$.\n\nFJ would like there to be a long increasing subsequence within his ordering of the cows. In order to ensure this, he allows himself initially to choose any subsequence and reverse its elements.\n\nFor example, if we had the list\n\n```\n1 6 2 3 4 3 5 3 4\n```\n\nWe can reverse the chosen elements\n\n```\n1 6 2 3 4 3 5 3 4\n  ^         ^ ^ ^\n```\nto get\n\n```\n1 4 2 3 4 3 3 5 6\n  ^         ^ ^ ^\n```\nObserve how the subsequence being reversed ends up using the same indices as it initially occupied, leaving the other elements unchanged.\n\nPlease find the maximum possible length of an increasing subsequence, given that you can choose to reverse an arbitrary subsequence once.", "inputFormat": "The first line of input contains $N$. The remaining $N$ lines contain $a(1) \\ldots a(N)$, each an integer in the range $1 \\ldots 50$.", "outputFormat": "Output the number of elements that can possibly form a longest increasing subsequence after reversing the contents of at most one subsequence.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17JAN] Subsequence Reversal P", "background": "", "description": "Farmer John 正在将他的 $N$ 头奶牛排成一列拍照（$1 \\leq N \\leq 50$）。序列中第 $i$ 头奶牛的高度为 $a(i)$，Farmer John 认为如果奶牛队列中存在一个较长的按高度递增的子序列，那么这张照片会更具美感。\n\n回顾一下，子序列是指从奶牛序列中选出的一组元素 $a(i_1), a(i_2), \\ldots, a(i_k)$，这些元素位于一系列索引 $i_1 < i_2 < \\ldots < i_k$ 处。如果满足 $a(i_1) \\leq a(i_2) \\leq \\ldots \\leq a(i_k)$，则称该子序列是递增的。\n\nFJ 希望在他的奶牛排列中存在一个较长的递增子序列。为了确保这一点，他允许自己最初选择任意一个子序列并将其元素反转。\n\n例如，如果我们有以下序列：\n\n```\n1 6 2 3 4 3 5 3 4\n```\n\n我们可以反转选中的元素：\n\n```\n1 6 2 3 4 3 5 3 4\n  ^         ^ ^ ^\n```\n\n得到：\n\n```\n1 4 2 3 4 3 3 5 6\n  ^         ^ ^ ^\n```\n\n注意被反转的子序列最终仍然使用最初占据的索引，而其他元素保持不变。\n\n请找出在最多反转一个子序列的情况下，可能的最长递增子序列的长度。", "inputFormat": "输入的第一行包含 $N$。接下来的 $N$ 行包含 $a(1) \\ldots a(N)$，每个数均为 $1$ 到 $50$ 之间的整数。", "outputFormat": "输出在最多反转一个子序列后，可能形成的最长递增子序列的元素个数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3608", "type": "P", "difficulty": 4, "samples": [["7\n34\n6\n23\n0\n5\n99\n2", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "USACO", "树状数组", "枚举", "前缀和"], "title": "[USACO17JAN] Balanced Photo G", "background": "", "description": "Farmer John is arranging his $N$ cows in a line to take a photo ($1 \\leq N \\leq 100,000$). The height of the $i$th cow in sequence is $h_i$, and the heights of all cows are distinct.\n\nAs with all photographs of his cows, FJ wants this one to come out looking as nice as possible. He decides that cow $i$ looks \"unbalanced\" if $L_i$ and $R_i$ differ by more than factor of 2, where $L_i$ and $R_i$ are the number of cows taller than $i$ on her left and right, respectively. That is, $i$ is unbalanced if the larger of $L_i$ and $R_i$ is strictly more than twice the smaller of these two numbers. FJ is hoping that not too many of his cows are unbalanced.\n\nPlease help FJ compute the total number of unbalanced cows.\n\n", "inputFormat": "The first line of input contains $N$.  The next $N$ lines contain $h_1 \\ldots h_N$, each a nonnegative integer at most 1,000,000,000.\n\n", "outputFormat": "Please output a count of the number of cows that are unbalanced.\n\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17JAN] Balanced Photo G", "background": "", "description": "Farmer John is arranging his $N$ cows in a line to take a photo ($1 \\leq N \\leq 100,000$). The height of the $i$th cow in sequence is $h_i$, and the heights of all cows are distinct.\n\nAs with all photographs of his cows, FJ wants this one to come out looking as nice as possible. He decides that cow $i$ looks \"unbalanced\" if $L_i$ and $R_i$ differ by more than factor of 2, where $L_i$ and $R_i$ are the number of cows taller than $i$ on her left and right, respectively. That is, $i$ is unbalanced if the larger of $L_i$ and $R_i$ is strictly more than twice the smaller of these two numbers. FJ is hoping that not too many of his cows are unbalanced.\n\nPlease help FJ compute the total number of unbalanced cows.\n\n", "inputFormat": "The first line of input contains $N$.  The next $N$ lines contain $h_1 \\ldots h_N$, each a nonnegative integer at most 1,000,000,000.\n\n", "outputFormat": "Please output a count of the number of cows that are unbalanced.\n\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17JAN] Balanced Photo G", "background": null, "description": "FJ 正在安排他的 $N$ 头奶牛站成一排来拍照（$1\\le N \\le 10^5$）。序列中的第 $i$ 头奶牛的高度是 $h_i$，且序列中所有的奶牛的身高都不同。\n\n就像他的所有牛的照片一样，FJ 希望这张照片看上去尽可能好。他认为，如果 $L_i$ 和 $R_i$ 的数目相差 $1$ 倍以上，第 $i$ 头奶牛就是不平衡的（$L_i$ 和 $R_i$ 分别代表第 $i$ 头奶牛左右两边比她高的奶牛的数量）。也就是说，如果 $L_i$ 和 $R_i$ 中的较大数大于较小数的 $2$ 倍，第 $i$ 头奶牛就是不平衡的。FJ 不希望他有太多的奶牛不平衡。\n\n请帮助 FJ 计算不平衡的奶牛数量。", "inputFormat": "第一行一个整数 $N$。\n\n接下 $N$ 行包括 $H_1$ 到 $H_n$，每行一个不超过 $10^9$ 的非负整数。", "outputFormat": "请输出不平衡的奶牛数量。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3609", "type": "P", "difficulty": 4, "samples": [["5 1\nP\nP\nH\nP\nS", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "动态规划 DP", "搜索", "2017", "USACO", "枚举", "记忆化搜索"], "title": "[USACO17JAN] Hoof, Paper, Scissor G", "background": "*本题与 [银组同名题目](/problem/P6120) 在题意上一致，唯一的差别在于对变手势次数的限制。*\n", "description": "你可能玩过“石头，剪刀，布”，这个游戏在奶牛中同样流行，不过它的名字变成了“蹄子，剪刀，布”。\n\n“蹄子，剪刀，布”和“石头，剪刀，布”的规则十分类似，两只奶牛数到三，然后出一个代表蹄子，剪刀或布的手势。蹄子胜过剪刀，剪刀胜过布，布胜过蹄子。特别地，如果两只奶牛的手势相同，则视为平局。\n\n现在 FJ 和 Bassie 要进行 $N$ 轮对抗。Bassie 已经预测了 FJ 每一轮要出的手势。然而 Bassie 很懒，她最多只想变换 $K$ 次手势。\n\n现在请你帮 Bassie 求出她最多能赢多少轮。", "inputFormat": "第一行输入两个整数 $N,K$（$1 \\leq N \\leq 10^5$，$0 \\leq K \\leq 20$）。\n\n接下来 $N$ 行，每行一个字母，代表 FJ 这一轮出的手势。`H` 代表蹄子（Hoof），`S` 代表剪刀（Scissors），`P` 代表布（Paper）。", "outputFormat": "输出一个整数，代表 Bassie 在最多变换 $K$ 次手势的前提下最多赢多少轮。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO17JAN] Hoof, Paper, Scissors G", "background": "*This problem has the same statement as the [problem with the same name in the Silver division](/problem/P6120). The only difference is the limit on how many times the gesture can be changed.*", "description": "You might have played “Rock, Paper, Scissors.” This game is also popular among cows, but it is called “Hoof, Scissors, Paper.”\n\nThe rules of “Hoof, Scissors, Paper” are very similar to “Rock, Paper, Scissors.” Two cows count to three, then show one of the gestures representing hoof, scissors, or paper. Hoof beats scissors, scissors beat paper, and paper beats hoof. In particular, if both cows show the same gesture, it is a tie.\n\nNow FJ and Bessie will play $N$ rounds. Bessie has already predicted FJ’s gesture in each round. However, Bessie is lazy and wants to change her gesture at most $K$ times.\n\nPlease help Bessie determine the maximum number of rounds she can win.", "inputFormat": "The first line contains two integers $N,K$ ($1 \\leq N \\leq 10^5$, $0 \\leq K \\leq 20$).\n\nThe next $N$ lines each contain one letter, representing FJ’s gesture in that round. `H` stands for hoof (Hoof), `S` stands for scissors (Scissors), and `P` stands for paper (Paper).", "outputFormat": "Output a single integer, the maximum number of rounds Bessie can win if she can change her gesture at most $K$ times.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO17JAN] Hoof, Paper, Scissor G", "background": "*本题与 [银组同名题目](/problem/P6120) 在题意上一致，唯一的差别在于对变手势次数的限制。*\n", "description": "你可能玩过“石头，剪刀，布”，这个游戏在奶牛中同样流行，不过它的名字变成了“蹄子，剪刀，布”。\n\n“蹄子，剪刀，布”和“石头，剪刀，布”的规则十分类似，两只奶牛数到三，然后出一个代表蹄子，剪刀或布的手势。蹄子胜过剪刀，剪刀胜过布，布胜过蹄子。特别地，如果两只奶牛的手势相同，则视为平局。\n\n现在 FJ 和 Bassie 要进行 $N$ 轮对抗。Bassie 已经预测了 FJ 每一轮要出的手势。然而 Bassie 很懒，她最多只想变换 $K$ 次手势。\n\n现在请你帮 Bassie 求出她最多能赢多少轮。", "inputFormat": "第一行输入两个整数 $N,K$（$1 \\leq N \\leq 10^5$，$0 \\leq K \\leq 20$）。\n\n接下来 $N$ 行，每行一个字母，代表 FJ 这一轮出的手势。`H` 代表蹄子（Hoof），`S` 代表剪刀（Scissors），`P` 代表布（Paper）。", "outputFormat": "输出一个整数，代表 Bassie 在最多变换 $K$ 次手势的前提下最多赢多少轮。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3610", "type": "P", "difficulty": 3, "samples": [["3\nEHE\nEEE\nEEE", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "USACO", "广度优先搜索 BFS", "栈", "队列"], "title": "[USACO17JAN] Cow Navigation G", "background": "", "description": "Bessie has gotten herself stuck on the wrong side of Farmer John's barn again, and since her vision is so poor, she needs your help navigating across the barn.\n\nThe barn is described by an $N \\times N$ grid of square cells ($2 \\leq N \\leq 20$), some being empty and some containing impassable haybales. Bessie starts in the lower-left corner (cell 1,1) and wants to move to the upper-right corner (cell $N,N$). You can guide her by telling her a sequence of instructions, each of which is either \"forward\", \"turn left 90 degrees\", or \"turn right 90 degrees\". You want to issue the shortest sequence of instructions that will guide her to her destination. If you instruct Bessie to move off the grid (i.e., into the barn wall) or into a haybale, she will not move and will skip to the next command in your sequence.\n\nUnfortunately, Bessie doesn't know if she starts out facing up (towards cell 1,2) or right (towards cell 2,1). You need to give the shortest sequence of directions that will guide her to the goal regardless of which case is true. Once she reaches the goal she will ignore further commands.\n\n", "inputFormat": "The first line of input contains $N$.\n\nEach of the $N$ following lines contains a string of exactly $N$ characters, representing the barn. The first character of the last line is cell 1,1. The last character of the first line is cell N, N.\n\nEach character will either be an H to represent a haybale or an E to represent an empty square.\n\nIt is guaranteed that cells 1,1 and $N,N$ will be empty, and furthermore it is guaranteed that there is a path of empty squares from cell 1,1 to cell $N, N$.\n", "outputFormat": "On a single line of output, output the length of the shortest sequence of directions that will guide Bessie to the goal, irrespective whether she starts facing up or right.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17JAN] Cow Navigation G", "background": "", "description": "Bessie has gotten herself stuck on the wrong side of Farmer John's barn again, and since her vision is so poor, she needs your help navigating across the barn.\n\nThe barn is described by an $N \\times N$ grid of square cells ($2 \\leq N \\leq 20$), some being empty and some containing impassable haybales. Bessie starts in the lower-left corner (cell 1,1) and wants to move to the upper-right corner (cell $N,N$). You can guide her by telling her a sequence of instructions, each of which is either \"forward\", \"turn left 90 degrees\", or \"turn right 90 degrees\". You want to issue the shortest sequence of instructions that will guide her to her destination. If you instruct Bessie to move off the grid (i.e., into the barn wall) or into a haybale, she will not move and will skip to the next command in your sequence.\n\nUnfortunately, Bessie doesn't know if she starts out facing up (towards cell 1,2) or right (towards cell 2,1). You need to give the shortest sequence of directions that will guide her to the goal regardless of which case is true. Once she reaches the goal she will ignore further commands.\n\n", "inputFormat": "The first line of input contains $N$.\n\nEach of the $N$ following lines contains a string of exactly $N$ characters, representing the barn. The first character of the last line is cell 1,1. The last character of the first line is cell N, N.\n\nEach character will either be an H to represent a haybale or an E to represent an empty square.\n\nIt is guaranteed that cells 1,1 and $N,N$ will be empty, and furthermore it is guaranteed that there is a path of empty squares from cell 1,1 to cell $N, N$.\n", "outputFormat": "On a single line of output, output the length of the shortest sequence of directions that will guide Bessie to the goal, irrespective whether she starts facing up or right.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17JAN] Cow Navigation G", "background": null, "description": "Bessie 又一次被困在了 Farmer John 的谷仓的错误一侧，由于她的视力很差，她需要你的帮助来穿过谷仓。\n\n谷仓由一个 $N \\times N$ 的方格网格描述（$2 \\leq N \\leq 20$），其中一些格子是空的，另一些则包含无法通过的干草堆。Bessie 从左下角（格子 1,1）开始，想要移动到右上角（格子 $N,N$）。你可以通过告诉她一系列指令来引导她，每条指令可以是“前进”、“向左转 90 度”或“向右转 90 度”。你需要给出最短的指令序列，以引导她到达目的地。如果你指示 Bessie 移动到网格外（即撞到谷仓墙壁）或进入干草堆，她将不会移动，并跳到你序列中的下一条指令。\n\n不幸的是，Bessie 不知道她最初是面朝上（朝向格子 1,2）还是面朝右（朝向格子 2,1）。你需要给出一个最短的指令序列，无论她最初面朝哪个方向，都能引导她到达目标。一旦她到达目标，她将忽略后续的指令。", "inputFormat": "输入的第一行包含 $N$。\n\n接下来的 $N$ 行每行包含一个长度为 $N$ 的字符串，表示谷仓。最后一行的第一个字符是格子 1,1，第一行的最后一个字符是格子 $N,N$。\n\n每个字符要么是 H 表示干草堆，要么是 E 表示空方格。\n\n保证格子 1,1 和 $N,N$ 是空的，并且保证存在一条从格子 1,1 到格子 $N,N$ 的空方格路径。", "outputFormat": "输出一行，表示无论 Bessie 最初面朝哪个方向，都能引导她到达目标的最短指令序列的长度。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3611", "type": "P", "difficulty": 4, "samples": [["5 8\n4\n7\n8\n6\n4", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2017", "线段树", "二分", "USACO", "优先队列", "队列"], "title": "[USACO17JAN] Cow Dance Show S", "background": "", "description": "After several months of rehearsal, the cows are just about ready to put on their annual dance performance; this year they are performing the famous bovine ballet \"Cowpelia\".\n\nThe only aspect of the show that remains to be determined is the size of the stage. A stage of size $K$ can support $K$ cows dancing simultaneously. The $N$ cows in the herd ($1 \\leq N \\leq 10,000$) are conveniently numbered $1 \\ldots N$ in the order in which they must appear in the dance. Each cow $i$ plans to dance for a specific duration of time $d(i)$. Initially, cows $1 \\ldots K$ appear on stage and start dancing. When the first of these cows completes her part, she leaves the stage and cow $K+1$ immediately starts dancing, and so on, so there are always $K$ cows dancing (until the end of the show, when we start to run out of cows). The show ends when the last cow completes her dancing part, at time $T$.\n\nClearly, the larger the value of $K$, the smaller the value of $T$. Since the show cannot last too long, you are given as input an upper bound $T_{max}$ specifying the largest possible value of $T$. Subject to this constraint, please determine the smallest possible value of $K$.\n\n", "inputFormat": "The first line of input contains $N$ and $T_{max}$, where $T_{max}$ is an integer of value at most 1 million.\n\nThe next $N$ lines give the durations $d(1) \\ldots d(N)$ of the dancing parts for cows $1 \\ldots N$. Each $d(i)$ value is an integer in the range $1 \\ldots 100,000$.\n\nIt is guaranteed that if $K=N$, the show will finish in time.\n\n", "outputFormat": "Print out the smallest possible value of $K$ such that the dance performance will take no more than $T_{max}$ units of time.\n\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17JAN] Cow Dance Show S", "background": "", "description": "After several months of rehearsal, the cows are just about ready to put on their annual dance performance; this year they are performing the famous bovine ballet \"Cowpelia\".\n\nThe only aspect of the show that remains to be determined is the size of the stage. A stage of size $K$ can support $K$ cows dancing simultaneously. The $N$ cows in the herd ($1 \\leq N \\leq 10,000$) are conveniently numbered $1 \\ldots N$ in the order in which they must appear in the dance. Each cow $i$ plans to dance for a specific duration of time $d(i)$. Initially, cows $1 \\ldots K$ appear on stage and start dancing. When the first of these cows completes her part, she leaves the stage and cow $K+1$ immediately starts dancing, and so on, so there are always $K$ cows dancing (until the end of the show, when we start to run out of cows). The show ends when the last cow completes her dancing part, at time $T$.\n\nClearly, the larger the value of $K$, the smaller the value of $T$. Since the show cannot last too long, you are given as input an upper bound $T_{max}$ specifying the largest possible value of $T$. Subject to this constraint, please determine the smallest possible value of $K$.\n\n", "inputFormat": "The first line of input contains $N$ and $T_{max}$, where $T_{max}$ is an integer of value at most 1 million.\n\nThe next $N$ lines give the durations $d(1) \\ldots d(N)$ of the dancing parts for cows $1 \\ldots N$. Each $d(i)$ value is an integer in the range $1 \\ldots 100,000$.\n\nIt is guaranteed that if $K=N$, the show will finish in time.\n\n", "outputFormat": "Print out the smallest possible value of $K$ such that the dance performance will take no more than $T_{max}$ units of time.\n\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17JAN] Cow Dance Show S", "background": "", "description": "经过几个月的排练，奶牛们基本准备好展出她们的年度舞蹈表演。今年她们要表演的是著名的奶牛芭蕾——“cowpelia”。\n\n表演唯一有待决定的是舞台的尺寸。一个大小为 $K$ 的舞台可以支持 $K$ 头牛同时在舞台上跳舞。在牛群中的 $N$ 头牛按照她们必须出现在舞蹈中的顺序方便地编号为 $1,2,\\dots,N$。第 $i$ 头牛计划跳 $d_i$ 的特定持续时间。\n一开始，第 $1,2,\\dots,K$ 头牛出现在舞台上并开始跳舞。当这些牛中的某一头牛首先完成了她的部分，她会马上离开舞台并且第 $K+1$ 头牛会出现在舞台上并开始跳舞。所以，舞台上总有 $K$ 头奶牛在跳舞（直到表演的尾声，奶牛不够的时候）。当最后一头奶牛完成了她的舞蹈部分，表演结束，共花了 $T$ 个单位时间。\n\n显然，$K$ 的值越大，$T$ 就越小。由于表演不能拖太长，你得知了指定 $T$ 的最大可能值的上限 $T_{max}$。请根据这个约束，确定 $K$ 的最小值。", "inputFormat": "第一行包括 $N$ 和 $T_{max}$ 两个整数。\n\n接下来的 $N$ 行，第 $i$ 行给出了第 $i$ 头牛跳舞的持续时间 $d_i$。第 $i$ 行包括一个整数 $d_i$。\n\n保证 $K=N$ 时表演会按时完成。", "outputFormat": "输出在表演时间不大于 $T_{max}$ 时的 $K$ 的最小可能值。", "hint": "对于 $100\\%$ 的数据，$1 \\le N \\le 10^4$，$T_{max} \\le 10^6$，$1 \\le d_i \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3612", "type": "P", "difficulty": 2, "samples": [["COW 8", "C"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2017", "USACO", "递归", "分治", "栈"], "title": "[USACO17JAN] Secret Cow Code S", "background": "", "description": "The cows are experimenting with secret codes, and have devised a method for creating an infinite-length string to be used as part of one of their codes.\n\nGiven a string $s$, let $F(s)$ be $s$ followed by $s$ \"rotated\" one character to the right (in a right rotation, the last character of $s$ rotates around and becomes the new first character). Given an initial string $s$, the cows build their infinite-length code string by repeatedly applying $F$; each step therefore doubles the length of the current string.\n\n\nGiven the initial string and an index $N$, please help the cows compute the character at the $N$th position within the infinite code string.\n\n", "inputFormat": "The input consists of a single line containing a string followed by $N$. The string consists of at most 30 uppercase characters, and $N \\leq 10^{18}$.\n\nNote that $N$ may be too large to fit into a standard 32-bit integer, so you may want to use a 64-bit integer type (e.g., a \"long long\" in C/C++).\n\n", "outputFormat": "Please output the $N$th character of the infinite code built from the initial string. The first character is $N=1$.\n\n\n", "hint": "In this example, the initial string COW expands as follows:\n\n\nCOW -> COWWCO -> COWWCOOCOWWC\n\n12345678\n\n\n", "locale": "en", "translations": {"en": {"title": "[USACO17JAN] Secret Cow Code S", "background": "", "description": "The cows are experimenting with secret codes, and have devised a method for creating an infinite-length string to be used as part of one of their codes.\n\nGiven a string $s$, let $F(s)$ be $s$ followed by $s$ \"rotated\" one character to the right (in a right rotation, the last character of $s$ rotates around and becomes the new first character). Given an initial string $s$, the cows build their infinite-length code string by repeatedly applying $F$; each step therefore doubles the length of the current string.\n\n\nGiven the initial string and an index $N$, please help the cows compute the character at the $N$th position within the infinite code string.\n\n", "inputFormat": "The input consists of a single line containing a string followed by $N$. The string consists of at most 30 uppercase characters, and $N \\leq 10^{18}$.\n\nNote that $N$ may be too large to fit into a standard 32-bit integer, so you may want to use a 64-bit integer type (e.g., a \"long long\" in C/C++).\n\n", "outputFormat": "Please output the $N$th character of the infinite code built from the initial string. The first character is $N=1$.\n\n\n", "hint": "In this example, the initial string COW expands as follows:\n\n\nCOW -> COWWCO -> COWWCOOCOWWC\n\n12345678\n\n\n", "locale": "en"}, "zh-CN": {"title": "[USACO17JAN] Secret Cow Code S", "background": "", "description": "奶牛们正在实验秘密代码，并设计了一种方法用于生成无限长度的字符串，作为他们代码的一部分。\n\n给定一个字符串 $s$，令 $F(s)$ 为 $s$ 后接 $s$ 向右“旋转”一个字符的结果（在右旋转中，$s$ 的最后一个字符旋转并成为新的第一个字符）。给定初始字符串 $s$，奶牛们通过重复应用 $F$ 来构建他们的无限长度代码字符串；因此每一步都会使当前字符串的长度翻倍。\n\n给定初始字符串和一个索引 $N$，请帮助奶牛计算无限代码字符串中第 $N$ 个位置的字符。", "inputFormat": "输入由一行组成，包含一个字符串和 $N$。字符串最多由 30 个大写字母组成，且 $N \\leq 10^{18}$。\n\n请注意，$N$ 可能太大，无法放入标准的 32 位整数中，因此你可能需要使用 64 位整数类型（例如，C/C++ 中的 \"long long\"）。", "outputFormat": "请输出从初始字符串构建的无限代码字符串的第 $N$ 个字符。第一个字符的位置为 $N=1$。", "hint": "在这个例子中，初始字符串 COW 按以下方式扩展：\n\nCOW -> COWWCO -> COWWCOOCOWWC", "locale": "zh-CN"}}}
{"pid": "P3613", "type": "P", "difficulty": 2, "samples": [["5 4\n1 3 10000 118014\n1 1 1 1\n2 3 10000\n2 1 1", "118014\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["STL"], "title": "【深基15.例2】寄包柜", "background": null, "description": "超市里有 $n(1\\le n\\le10^5)$ 个寄包柜。每个寄包柜格子数量不一，第 $i$ 个寄包柜有 $a_i(0\\le a_i\\le10^5)$ 个格子，不过我们并不知道各个 $a_i$ 的值。对于每个寄包柜，格子编号从 1 开始，一直到 $a_i$。现在有 $q(1 \\le q\\le10^5)$ 次操作：\n\n- `1 i j k`：在第 $i$ 个柜子的第 $j$ 个格子存入物品 $k(0\\le k\\le 10^9)$。当 $k=0$ 时说明清空该格子。\n- `2 i j`：查询第 $i$ 个柜子的第 $j$ 个格子中的物品是什么，保证查询的柜子有存过东西。\n\n已知超市里共计不会超过 $10^7$ 个寄包格子，$a_i$ 是确定然而未知的，但是保证一定不小于该柜子存物品请求的格子编号的最大值。当然也有可能某些寄包柜中一个格子都没有。", "inputFormat": "第一行 2 个整数 $n$ 和 $q$，寄包柜个数和询问次数。\n\n接下来 $q$ 个行，每行有若干个整数，表示一次操作。", "outputFormat": "对于查询操作时，输出答案，以换行隔开。", "hint": "$\\text{upd 2022.7.26}$：新增加一组 Hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "[Shenji 15. Example 2] Parcel Locker", "background": "", "description": "There are $n(1\\le n\\le10^5)$ parcel lockers in a supermarket. Each locker has a different number of compartments. The $i$-th locker has $a_i(0\\le a_i\\le10^5)$ compartments, but we do not know the values of $a_i$. For each locker, the compartments are numbered from 1 to $a_i$. Now there are $q(1 \\le q\\le10^5)$ operations:\n\n- `1 i j k`: Put item $k(0\\le k\\le 10^9)$ into compartment $j$ of locker $i$. When $k=0$, it means clearing that compartment.\n- `2 i j`: Query what item is in compartment $j$ of locker $i$. It is guaranteed that the queried locker has had items stored in it.\n\nIt is known that the total number of compartments in the supermarket will not exceed $10^7$. The values $a_i$ are fixed but unknown, and it is guaranteed that $a_i$ is at least the maximum compartment index ever used in a store-item request for that locker. Of course, it is also possible that some lockers do not have even a single compartment.", "inputFormat": "The first line contains 2 integers $n$ and $q$, the number of parcel lockers and the number of queries.\n\nThe next $q$ lines each contain several integers, representing one operation.", "outputFormat": "For each query operation, output the answer, one per line.", "hint": "$\\text{upd 2022.7.26}$: A new set of hack testdata has been added.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【深基15.例2】寄包柜", "background": null, "description": "超市里有 $n(1\\le n\\le10^5)$ 个寄包柜。每个寄包柜格子数量不一，第 $i$ 个寄包柜有 $a_i(0\\le a_i\\le10^5)$ 个格子，不过我们并不知道各个 $a_i$ 的值。对于每个寄包柜，格子编号从 1 开始，一直到 $a_i$。现在有 $q(1 \\le q\\le10^5)$ 次操作：\n\n- `1 i j k`：在第 $i$ 个柜子的第 $j$ 个格子存入物品 $k(0\\le k\\le 10^9)$。当 $k=0$ 时说明清空该格子。\n- `2 i j`：查询第 $i$ 个柜子的第 $j$ 个格子中的物品是什么，保证查询的柜子有存过东西。\n\n已知超市里共计不会超过 $10^7$ 个寄包格子，$a_i$ 是确定然而未知的，但是保证一定不小于该柜子存物品请求的格子编号的最大值。当然也有可能某些寄包柜中一个格子都没有。", "inputFormat": "第一行 2 个整数 $n$ 和 $q$，寄包柜个数和询问次数。\n\n接下来 $q$ 个行，每行有若干个整数，表示一次操作。", "outputFormat": "对于查询操作时，输出答案，以换行隔开。", "hint": "$\\text{upd 2022.7.26}$：新增加一组 Hack 数据。", "locale": "zh-CN"}}}
{"pid": "P3614", "type": "P", "difficulty": 6, "samples": [["7\n0\nxxoooxx\nxxoyoxx\noooyooo\nooooooo\nooooooo\nxxoooxx\nxxoooxx", "2 4 D"], ["7\n2\n2 4\n3 4", "3 4 U"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创", "提交答案", "Special Judge", "洛谷月赛"], "title": "yyy 棋 II", "background": "本题是提交答案题，所有测试数据的输入均开放下载。选手需要提供输出数据。洛谷评测机会根据提交的数据来评分。\n\n输入数据和 windows 的 checker\n\nhttp://pan.baidu.com/s/1jHU2UwQ\n\nlinux 的 checker\n\nhttp://pan.baidu.com/s/1nv8Yuy1\n\n#udp1：所有答案文件末尾必须有且只有一个回车", "description": "我们的英明的 yyy 某日无聊，发明了一款风靡世界的游戏。为了纪念这个伟大的发明，自己起名为“yyy棋”。\n\n在其中的一种情况下棋盘是长这样的：\n\n```\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n．．．．．．．\n．．．．．．．\n．．．．．．．\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n```\n这种情况下一个 $7\\times7$ 的棋盘，`.` 上可以走棋，而 `x` 上不能。只有1种棋子，我们假设是 `Y`。\n\n最开始的初始棋子和障碍都是系统给定的。我们假设是这个样子：\n\n```\nｘｘ．．．ｘｘ\nｘｘ．Ｙ．ｘｘ\n．．．Ｙ．．．\n．．．．．．．\n．．．．．．．\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n```\n走棋的规则很简单。任意一个棋子可以而且仅可以跳过它相邻的上下左右的一颗棋子而移动两格，而且目的地没有棋子且不是 `x`。跳过之后，被跳的那个棋子就会消失。所以像刚刚给出的的那个，我们可以将上方的一个棋子跳到下方，然后就成了这样：\n\n```\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n．．．．．．．\n．．．Ｙ．．．\n．．．．．．．\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n```\n我们的目标是通过一系列运动，消除尽可能多的棋子。希望最后可以只留下一个棋子。由于 yyy 有强迫症，他还希望最后的这一个棋子能够停留在**中央**。", "inputFormat": "所有输入数据 `yyychess1.in`~`yyychess10.in` ，分别对应 $10$ 个任务。\n\n对于每一个任务：\n\n第一行一个整数 $N$，表示棋盘的大小。\n\n为了方便选手，我们定义坐标 $(i,j)$ 为第 $i$ 行第 $j$ 列。\n\n接下来一行，一个自然数 $M$。\n\n- 如果 $M=0$，那么\n\n接下来是 $N\\times N$ 的矩阵序列。我们用 `x` 表示不可走的地方，`o` 表示可以走但是没有放棋的地方，`y` 表示放棋的地方。每个字符不用空格隔开。\n\n- 如果 $M>0$，那么\n\n接下来是 $M$ 行，每行两个数字，依次表示每个棋子的坐标。这种情况下，没有障碍点。", "outputFormat": "输出若干行，表示走法。\n\n对于每一行，输出两个数字和一个字母。两个数字代表 $(i,j)$ 也就是棋子的坐标，剩下的一个字母是 `UDLR` 中的一个，分别表示上下左右跳。", "hint": "### 样例解释\n\n两个样例描述的是同一个棋盘，只是第二个没有障碍点。\n\n第一个样例输出，可以拿 $100\\%$ 的分数。\n\n第二个样例输出，只能拿 $90\\%$ 的分数，因为最后没有在中心 $(\\frac{n+1}{2},\\frac{n+1}{2})$。\n\n### 评分标准\n\n当你的答案是合法的，并且最后只剩下一个棋子，而且这个棋子在最中心，得该点 $100\\%$ 的分数。\n\n当你的答案是合法的，并且最后只剩下一个棋子，而且这个棋子不在最中心，得该点 $90\\%$ 的分数。\n\n当你的答案是合法的，并且最后剩下 $2$ 个，$3$ 个，$4/5$ 个棋子，分别得该点 $80\\%$，$60\\%$，$40\\%$的分数。\n\n除此之外，包括有非法的走法以及剩下超过 $5$ 个棋子的，该点不得分。\n\n压缩文件提供 `checker.exe` 可供预先使用。\n\n#### 方法\n\n所有文件解压，在命令行中输入 `checker.exe yyychess1.in youranswer.txt youranswer.txt` (最后两个是你的输出文件，请输入两次)\n\n就会告诉你结果。", "locale": "zh-CN", "translations": {"en": {"title": "yyy Chess II", "background": "This is an output-only problem. All input testdata are available for download. Contestants need to provide output data. The Luogu judge will score based on the submitted data.\n\nInput testdata and checker for Windows:\nhttp://pan.baidu.com/s/1jHU2UwQ\n\nChecker for Linux:\nhttp://pan.baidu.com/s/1nv8Yuy1\n\nUpdate 1: All answer files must have exactly one trailing newline.", "description": "Our brilliant yyy once got bored and invented a game that took the world by storm. To commemorate this great invention, he named it “yyy Chess.”\n\nIn one scenario, the board looks like this:\n\n```\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n．．．．．．．\n．．．．．．．\n．．．．．．．\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n```\nIn this case, it is a $7\\times7$ board. You can move on `.`, but not on `x`. There is only one type of piece, which we denote as `Y`.\n\nThe initial pieces and obstacles are given by the system. Suppose it looks like this:\n\n```\nｘｘ．．．ｘｘ\nｘｘ．Ｙ．ｘｘ\n．．．Ｙ．．．\n．．．．．．．\n．．．．．．．\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n```\nThe rules are simple. Any piece can, and only can, jump over one adjacent piece in the up, down, left, or right direction, moving two squares, and the destination must be empty and not `x`. After the jump, the jumped-over piece disappears. For example, in the configuration above, we can jump the upper piece downward, after which it becomes:\n\n```\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n．．．．．．．\n．．．Ｙ．．．\n．．．．．．．\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n```\nOur goal is to eliminate as many pieces as possible through a sequence of moves, ideally leaving exactly one piece. Since yyy has OCD, he also wants the last piece to stay at the **center**.", "inputFormat": "All input data `yyychess1.in` ~ `yyychess10.in` correspond to $10$ tasks.\n\nFor each task:\n\nThe first line contains an integer $N$, the size of the board.\n\nFor convenience, we define coordinate $(i, j)$ as row $i$, column $j$.\n\nThe next line contains a natural number $M$.\n\n- If $M=0$, then\n\nNext comes an $N\\times N$ matrix. We use `x` to denote an unplayable cell, `o` for an empty playable cell, and `y` for a cell with a piece. Characters are not separated by spaces.\n\n- If $M>0$, then\n\nNext come $M$ lines, each with two numbers, giving the coordinates of each piece. In this case, there are no obstacle cells.", "outputFormat": "Output several lines, each representing a move.\n\nFor each line, output two numbers and one letter. The two numbers represent $(i,j)$, i.e., the coordinate of the piece, and the letter is one of `UDLR`, representing a jump in the up, down, left, or right direction, respectively.", "hint": "### Sample Explanation\n\nThe two samples describe the same board; the second one simply has no obstacle cells.\n\nWith the first sample output, you can score $100\\%$.\n\nWith the second sample output, you can only score $90\\%$, because the final piece is not at the center $(\\frac{n+1}{2},\\frac{n+1}{2})$.\n\n### Scoring Rules\n\nIf your answer is valid, and exactly one piece remains at the very center, you score $100\\%$ for that testcase.\n\nIf your answer is valid, and exactly one piece remains but not at the center, you score $90\\%$ for that testcase.\n\nIf your answer is valid, and $2$, $3$, or $4$/$5$ pieces remain, you score $80\\%$, $60\\%$, or $40\\%$ for that testcase, respectively.\n\nOtherwise, including having illegal moves or more than $5$ pieces remaining, you score $0$ for that testcase.\n\nThe archive provides `checker.exe` for preliminary use.\n\n#### Method\n\nUnzip all files, then run on the command line:\n`checker.exe yyychess1.in youranswer.txt youranswer.txt` (the last two are your output file; please enter it twice),\nand it will tell you the result.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "yyy 棋 II", "background": "本题是提交答案题，所有测试数据的输入均开放下载。选手需要提供输出数据。洛谷评测机会根据提交的数据来评分。\n\n输入数据和 windows 的 checker\n\nhttp://pan.baidu.com/s/1jHU2UwQ\n\nlinux 的 checker\n\nhttp://pan.baidu.com/s/1nv8Yuy1\n\n#udp1：所有答案文件末尾必须有且只有一个回车", "description": "我们的英明的 yyy 某日无聊，发明了一款风靡世界的游戏。为了纪念这个伟大的发明，自己起名为“yyy棋”。\n\n在其中的一种情况下棋盘是长这样的：\n\n```\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n．．．．．．．\n．．．．．．．\n．．．．．．．\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n```\n这种情况下一个 $7\\times7$ 的棋盘，`.` 上可以走棋，而 `x` 上不能。只有1种棋子，我们假设是 `Y`。\n\n最开始的初始棋子和障碍都是系统给定的。我们假设是这个样子：\n\n```\nｘｘ．．．ｘｘ\nｘｘ．Ｙ．ｘｘ\n．．．Ｙ．．．\n．．．．．．．\n．．．．．．．\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n```\n走棋的规则很简单。任意一个棋子可以而且仅可以跳过它相邻的上下左右的一颗棋子而移动两格，而且目的地没有棋子且不是 `x`。跳过之后，被跳的那个棋子就会消失。所以像刚刚给出的的那个，我们可以将上方的一个棋子跳到下方，然后就成了这样：\n\n```\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n．．．．．．．\n．．．Ｙ．．．\n．．．．．．．\nｘｘ．．．ｘｘ\nｘｘ．．．ｘｘ\n```\n我们的目标是通过一系列运动，消除尽可能多的棋子。希望最后可以只留下一个棋子。由于 yyy 有强迫症，他还希望最后的这一个棋子能够停留在**中央**。", "inputFormat": "所有输入数据 `yyychess1.in`~`yyychess10.in` ，分别对应 $10$ 个任务。\n\n对于每一个任务：\n\n第一行一个整数 $N$，表示棋盘的大小。\n\n为了方便选手，我们定义坐标 $(i,j)$ 为第 $i$ 行第 $j$ 列。\n\n接下来一行，一个自然数 $M$。\n\n- 如果 $M=0$，那么\n\n接下来是 $N\\times N$ 的矩阵序列。我们用 `x` 表示不可走的地方，`o` 表示可以走但是没有放棋的地方，`y` 表示放棋的地方。每个字符不用空格隔开。\n\n- 如果 $M>0$，那么\n\n接下来是 $M$ 行，每行两个数字，依次表示每个棋子的坐标。这种情况下，没有障碍点。", "outputFormat": "输出若干行，表示走法。\n\n对于每一行，输出两个数字和一个字母。两个数字代表 $(i,j)$ 也就是棋子的坐标，剩下的一个字母是 `UDLR` 中的一个，分别表示上下左右跳。", "hint": "### 样例解释\n\n两个样例描述的是同一个棋盘，只是第二个没有障碍点。\n\n第一个样例输出，可以拿 $100\\%$ 的分数。\n\n第二个样例输出，只能拿 $90\\%$ 的分数，因为最后没有在中心 $(\\frac{n+1}{2},\\frac{n+1}{2})$。\n\n### 评分标准\n\n当你的答案是合法的，并且最后只剩下一个棋子，而且这个棋子在最中心，得该点 $100\\%$ 的分数。\n\n当你的答案是合法的，并且最后只剩下一个棋子，而且这个棋子不在最中心，得该点 $90\\%$ 的分数。\n\n当你的答案是合法的，并且最后剩下 $2$ 个，$3$ 个，$4/5$ 个棋子，分别得该点 $80\\%$，$60\\%$，$40\\%$的分数。\n\n除此之外，包括有非法的走法以及剩下超过 $5$ 个棋子的，该点不得分。\n\n压缩文件提供 `checker.exe` 可供预先使用。\n\n#### 方法\n\n所有文件解压，在命令行中输入 `checker.exe yyychess1.in youranswer.txt youranswer.txt` (最后两个是你的输出文件，请输入两次)\n\n就会告诉你结果。", "locale": "zh-CN"}}}
{"pid": "P3615", "type": "P", "difficulty": 6, "samples": [["5\n3\nFFF 1\nM 5\nFF 1", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2016", "JOISC/JOIST（日本）"], "title": "[JOISC 2016] 如厕计划 / Toilets", "background": null, "description": "竞赛比完之后，水箱里充满水的选手们鱼贯而出。凡华中学的厕所规划的很糟，只有两个厕位，于是厕所门前排起了长长的队伍。\n\n\n厕所有两个，一个是女生专用厕所，另一个是男女混用厕所。**一共有 $2N$ 个选手正在排队**，男女生数量可能不同。如果队头的是妹子，只要某个厕所是空的就可以进入，但是如果两个厕所都是空的，那么优先进入女性专用厕所。而如果队头是个绅♂士，只有在男女混用厕所是空的时候才能使用；如果只有女性专用厕所是空的，那么队伍中最靠前的妹子就可以不用继续等直接如厕。我们假设所有人如厕都需要花 $1$ 分钟，不考虑切换的时间。\n\n\n然而，**$N$ 分钟后，就要开饭了，所有人必须如厕完**，不过看样子似乎来不及。主办方可以重新调换顺序，不过有些人会因为新的顺序中自己更加后面了而感到不满，不满度是自己相比于原队列后退了几个顺序（除此之外跟自己的实际如厕顺序无关）。\n\n\n主办方发现了这一点，所以希望你帮助他们解决这个问题，设计出一种方案，对于其中不满意度最大的学生，尽可能让他的不满意度最小。你只需要告诉他们最不满意的学生的不满意度是多少。", "inputFormat": "由于人相当多，我们用几段字符串来描述这个队列。\n\n第一行一个整数 $N$ ；\n\n第二行一个整数 $M$ ；\n\n接下来 $M$ 行，由一个字符串 $S_i$ 和一个整数 $K_i$ 构成，中间有空格隔开，字符串中只有```M```（男）和```F```（女）。最后的字符串就是 $S_1$ 拼接 $K_1$次 + $S_2$ 拼接 $K_2$ 次+ ... + $S_M$ 拼接 $K_M$ 次。", "outputFormat": "输出一个整数，表示答案。如果无论怎么样都没办法在 $N$ 分钟之内达成，请输出 ```-1``` 。", "hint": "原队列是 ```FFFMMMMMFF``` ，\n\n改进后的队列是 ```FMMFFMMMFF``` ，\n\n所以厕所会按照下面的时间使用：\n\n```cpp\n分钟 1   2   3   4   5\n共用 2   3   6   7   8\n女用 1   4   5   9   10\n```\n两个妹子往后面移动了 $2$ 位，所以不满意度是 $2$ 。\n\n对于 $20 \\%$ 的数据，$N \\le 10,M=1,K_1=1$ ；\n\n对于 $40 \\%$ 的数据， $N\\le100000,M=1,K_1=1$；\n\n对于 $100 \\%$ 的数据， $1\\le N,K_i\\le10^{18},1\\le M\\le100000, \\sum |S_i| \\le 200000$。", "locale": "zh-CN", "translations": {"en": {"title": "[JOISC 2016] Toilet Plan / Toilets", "background": "", "description": "After the contest, the contestants with full bladders file out. The restroom planning at Fanhua High School is terrible: there are only two stalls, so a long line forms in front of the restroom.\n\nThere are two restrooms: one is female-only, and the other is unisex. There are $2N$ contestants in total waiting in line, and the numbers of males and females may differ. If the head of the queue is female, she may enter as soon as any restroom is free; if both restrooms are free, she prefers the female-only restroom. If the head of the queue is male, he can only use the unisex restroom when it is free; if only the female-only restroom is free, then the earliest female in the queue may immediately enter without waiting. Assume each person occupies a restroom for $1$ minute, and ignore switching time.\n\nHowever, after $N$ minutes dinner starts, and everyone must have finished using the restroom, which seems impossible. The organizers may reorder the queue, but some people will be unhappy because they are placed later than before. A person’s dissatisfaction is the number of positions they move backward compared to the original queue (it is otherwise unrelated to their actual time of using the restroom).\n\nThe organizers want your help to design a plan that minimizes the maximum dissatisfaction among all students. You only need to report the dissatisfaction of the most dissatisfied student.", "inputFormat": "Because there are many people, we describe the queue using several string blocks.\n\n- The first line contains an integer $N$.\n- The second line contains an integer $M$.\n- The next $M$ lines each contain a string $S_i$ and an integer $K_i$, separated by a space. The string contains only ```M``` (male) and ```F``` (female). The final string equals $S_1$ repeated $K_1$ times + $S_2$ repeated $K_2$ times + ... + $S_M$ repeated $K_M$ times.", "outputFormat": "Output a single integer, the answer. If it is impossible to finish within $N$ minutes no matter how you reorder, output ```-1```.", "hint": "The original queue is ```FFFMMMMMFF```,\n\nthe improved queue is ```FMMFFMMMFF```,\n\nso the restrooms are used as follows:\n\n```cpp\n分钟 1   2   3   4   5\n共用 2   3   6   7   8\n女用 1   4   5   9   10\n```\nTwo females move backward by $2$ positions, so the dissatisfaction is $2$.\n\nFor $20\\%$ of the testdata, $N \\le 10$, $M = 1$, $K_1 = 1$.\n\nFor $40\\%$ of the testdata, $N \\le 100000$, $M = 1$, $K_1 = 1$.\n\nFor $100\\%$ of the testdata, $1 \\le N, K_i \\le 10^{18}$, $1 \\le M \\le 100000$, $\\sum |S_i| \\le 200000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JOISC 2016] 如厕计划 / Toilets", "background": null, "description": "竞赛比完之后，水箱里充满水的选手们鱼贯而出。凡华中学的厕所规划的很糟，只有两个厕位，于是厕所门前排起了长长的队伍。\n\n\n厕所有两个，一个是女生专用厕所，另一个是男女混用厕所。**一共有 $2N$ 个选手正在排队**，男女生数量可能不同。如果队头的是妹子，只要某个厕所是空的就可以进入，但是如果两个厕所都是空的，那么优先进入女性专用厕所。而如果队头是个绅♂士，只有在男女混用厕所是空的时候才能使用；如果只有女性专用厕所是空的，那么队伍中最靠前的妹子就可以不用继续等直接如厕。我们假设所有人如厕都需要花 $1$ 分钟，不考虑切换的时间。\n\n\n然而，**$N$ 分钟后，就要开饭了，所有人必须如厕完**，不过看样子似乎来不及。主办方可以重新调换顺序，不过有些人会因为新的顺序中自己更加后面了而感到不满，不满度是自己相比于原队列后退了几个顺序（除此之外跟自己的实际如厕顺序无关）。\n\n\n主办方发现了这一点，所以希望你帮助他们解决这个问题，设计出一种方案，对于其中不满意度最大的学生，尽可能让他的不满意度最小。你只需要告诉他们最不满意的学生的不满意度是多少。", "inputFormat": "由于人相当多，我们用几段字符串来描述这个队列。\n\n第一行一个整数 $N$ ；\n\n第二行一个整数 $M$ ；\n\n接下来 $M$ 行，由一个字符串 $S_i$ 和一个整数 $K_i$ 构成，中间有空格隔开，字符串中只有```M```（男）和```F```（女）。最后的字符串就是 $S_1$ 拼接 $K_1$次 + $S_2$ 拼接 $K_2$ 次+ ... + $S_M$ 拼接 $K_M$ 次。", "outputFormat": "输出一个整数，表示答案。如果无论怎么样都没办法在 $N$ 分钟之内达成，请输出 ```-1``` 。", "hint": "原队列是 ```FFFMMMMMFF``` ，\n\n改进后的队列是 ```FMMFFMMMFF``` ，\n\n所以厕所会按照下面的时间使用：\n\n```cpp\n分钟 1   2   3   4   5\n共用 2   3   6   7   8\n女用 1   4   5   9   10\n```\n两个妹子往后面移动了 $2$ 位，所以不满意度是 $2$ 。\n\n对于 $20 \\%$ 的数据，$N \\le 10,M=1,K_1=1$ ；\n\n对于 $40 \\%$ 的数据， $N\\le100000,M=1,K_1=1$；\n\n对于 $100 \\%$ 的数据， $1\\le N,K_i\\le10^{18},1\\le M\\le100000, \\sum |S_i| \\le 200000$。", "locale": "zh-CN"}}}
{"pid": "P3616", "type": "P", "difficulty": 5, "samples": [["5 4\n8 6 3 5 4\n1 5\n2 4 1\n1 5\n1 3", "2\n1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "树状数组", "离散化", "洛谷月赛"], "title": "富金森林公园", "background": "", "description": "博艾的富金森林公园里有一个长长的富金山脉，山脉是由一块块巨石并列构成的，编号从 $1$ 到 $N$ 。每一个巨石有一个海拔高度。而这个山脉又在一个盆地中，盆地里可能会积水，积水也有一个海拔高度，所有**严格低于**这个海拔高度的巨石，就会在水面下隐藏。\n\n\n由于地壳运动，巨石的海拔高度可能会随时变化，每次一块的巨石会变成新的海拔高度。当然，水面的高度也会随时发生变化。\n\n\n因为有这样奇妙的地质奇观，吸引了很多游客来游玩。uim 作为一个游客，可以告诉你此时水位海拔，你得告诉他，能看到有几个连续露出水面的部分。（与水面持平我们也认为是露出）", "inputFormat": "第一行两个整数 $N$ 和 $M$,分别表示 $N$ 块石头，$M$ 个询问。\n\n接下来一行，$N$ 个整数 $A_i$ 表示每个巨石的初始海拔。\n\n接下来 $M$ 行，每行有两个或者三个数，每一行如果第一个数是 `1`，那么后面跟一个 $B_j$，表示水面海拔。如果第一个数是 `2`，后面跟两个整数，$C_j$ 和 $D_j$，表示编号 $C_j$ 的巨石海拔变为 $D_j$。", "outputFormat": "对于每个 `1` 询问，给出一个整数答案，也就是露出了几部分的山峰。", "hint": "$10\\%$ 的数据，$N,M<=2000$。\n\n另外 $30\\%$ 的数据， 只有 `1` 的询问。\n\n$100\\%$ 的数据，$1<=N,M<=200000,1<=A_i,B_j,D_j<=10^9$，一定有 `1` 询问。\n", "locale": "zh-CN", "translations": {"en": {"title": "Fujin Forest Park", "background": "", "description": "In Boai’s Fujin Forest Park, there is a long Fujin mountain range made up of giant rocks lined up and numbered from $1$ to $N$. Each rock has an elevation. The mountain range lies in a basin that can hold water, and the water has its own elevation. All rocks strictly lower than this water elevation will be submerged and hidden beneath the surface.\n\nDue to crustal movements, rock elevations may change at any time, with a single rock taking on a new elevation. Of course, the water level may also change at any time.\n\nBecause of this geological wonder, many tourists visit. As a visitor, uim can tell you the current water level elevation, and you must tell him how many contiguous visible parts there are on the mountain range. (Rocks exactly at the water level are also considered visible.)", "inputFormat": "The first line contains two integers $N$ and $M$, representing $N$ rocks and $M$ queries.\n\nThe next line contains $N$ integers $A_i$ representing the initial elevation of each rock.\n\nThen follow $M$ lines. Each line has two or three numbers:\n- If the first number is `1`, it is followed by a single $B_j$, representing the water level elevation.\n- If the first number is `2`, it is followed by two integers $C_j$ and $D_j$, meaning the elevation of rock numbered $C_j$ becomes $D_j$.", "outputFormat": "For each `1` query, output a single integer: the number of contiguous visible segments.", "hint": "- For $10\\%$ of the testdata, $N, M \\le 2000$.\n- Additionally, for $30\\%$ of the testdata, there are only `1` queries.\n- For $100\\%$ of the testdata, $1 \\le N, M \\le 200000$, $1 \\le A_i, B_j, D_j \\le 10^9$, and there is at least one `1` query.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "富金森林公园", "background": "", "description": "博艾的富金森林公园里有一个长长的富金山脉，山脉是由一块块巨石并列构成的，编号从 $1$ 到 $N$ 。每一个巨石有一个海拔高度。而这个山脉又在一个盆地中，盆地里可能会积水，积水也有一个海拔高度，所有**严格低于**这个海拔高度的巨石，就会在水面下隐藏。\n\n\n由于地壳运动，巨石的海拔高度可能会随时变化，每次一块的巨石会变成新的海拔高度。当然，水面的高度也会随时发生变化。\n\n\n因为有这样奇妙的地质奇观，吸引了很多游客来游玩。uim 作为一个游客，可以告诉你此时水位海拔，你得告诉他，能看到有几个连续露出水面的部分。（与水面持平我们也认为是露出）", "inputFormat": "第一行两个整数 $N$ 和 $M$,分别表示 $N$ 块石头，$M$ 个询问。\n\n接下来一行，$N$ 个整数 $A_i$ 表示每个巨石的初始海拔。\n\n接下来 $M$ 行，每行有两个或者三个数，每一行如果第一个数是 `1`，那么后面跟一个 $B_j$，表示水面海拔。如果第一个数是 `2`，后面跟两个整数，$C_j$ 和 $D_j$，表示编号 $C_j$ 的巨石海拔变为 $D_j$。", "outputFormat": "对于每个 `1` 询问，给出一个整数答案，也就是露出了几部分的山峰。", "hint": "$10\\%$ 的数据，$N,M<=2000$。\n\n另外 $30\\%$ 的数据， 只有 `1` 的询问。\n\n$100\\%$ 的数据，$1<=N,M<=200000,1<=A_i,B_j,D_j<=10^9$，一定有 `1` 询问。\n", "locale": "zh-CN"}}}
{"pid": "P3617", "type": "P", "difficulty": 5, "samples": [["7 7\n1 2 0\n1 3 0\n2 4 1\n3 5 1\n4 6 0\n5 6 0\n6 7 1\n", "1.500"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心", "递归", "洛谷原创", "分治"], "title": "电阻网络", "background": "什么是电阻？这个大家应该都知道。什么是电路？大家也应该知道。但是本题当中，电路的定义或许有点不同：\n\n电路都带有正、负极接点，正极在左，负极在右。具体地：电路分为以下几类：\n\n单独的一个 $1\\Omega$ 电阻（及其两端的接点）是电路（虽然导线也可以被视为 $0\\Omega$ 的电阻，但是单独的导线不是电路）\n\n如果 $A$ 和 $B$ 都是电路，设 $1,2,3$ 是从左到右的三个接点，那么将 $A$ 的正负极分别接在 $1$ 与 $2$ 上，将 $B$ 的正负极分别接在 $2$ 与 $3$ 上，那么 $1$ 到 $3$ 的部分是电路，其中 $1$ 为正极，$3$ 为负极。\n\n如果A和B都是电路,设 $1,2,3,2',3',1'$ 是六个接点，其中 $1$ 在 $2$ 和 $3$ 的左侧，$2$ 在 $2'$ 的左侧，$3$ 在 $3'$ 的左侧，$2'$和 $3'$ 在 $1'$的左侧，并且 $1$ 与 $2$，$1'$ 与 $3'$，$2'$与 $1$，$3'$与$1'$间均连有导线, 那么将 $A$ 的正负极分别接在 $2$ 与 $2'$ 上，将 $B$ 的正负极分别接在 $3$ 与 $3'$ 上，那么 $1$ 到 $1'$ 的部分是电路，其中 $1$ 为正极，$1'$ 为负极。\n\n现在给出一个电路，求它正负极之间的电阻。", "description": "Cjwssb 最近在物理学科上遇到了难题，他不会计算一个电路中的总电阻，现在他找到了你，希望你能帮助他。\n\n这个电路有如下限：\n1. 电路只由导线以及电阻为一欧的电阻组成。\n\n2.    保证电路从左到右连接，即每个电阻或导线的两个连接点 $x,y$，保证 $x<y$。\n\n3.    保证接线柱 $1$ 为电源正极，接线柱 $n$ 为电源负极。\n\n3.    保证每个接线柱只会被串联或者并联两个分支电路或者不接任何电线或电阻。", "inputFormat": "第一行为两个正整数 $n,m$，分别代表接点数和电阻数。保证编号小的接点在编号大的接点的左侧。\n\n接下来 $m$ 行，每行三个整数 $a_i,b_i,c_i$，代表这个电阻连接了 $a_i$ 与 $b_i$ 接点，其阻值为 $c_i$ ，其中 $c_i$ 只可能是 $0$ 或 $1$，且对于任意的 $i$，保证$a_i<b_i$。", "outputFormat": "输出一个实数，表示总的电阻值，保留三位小数输出。", "hint": "【样例解释】\n\n画出图来，答案是显然的。\n\n【数据规模与约定】\n\n|得分占比|$n$|$m$|\n|:-:|:-:|:-:|\n|$20\\%$|$n\\le5$|$m\\le5$|\n|$50\\%$|$n\\le100$|$m\\le120$|\n|$70\\%$|$n\\le1000$|$m\\le1200$|\n|$100\\%$|$n\\le10^5$|$m\\le1.2\\times10^6$|\n\np.s.数据是在人工指定的 $n$ 下随机生成的，保证答案不会超过 $10\\ 000$。\n\nBy：saffah。", "locale": "zh-CN", "translations": {"en": {"title": "Resistor Network", "background": "What is a resistor? Everyone should know. What is a circuit? You probably know as well. However, in this problem, the definition of a circuit is a bit different:\n\nEvery circuit has a positive terminal on the left and a negative terminal on the right. Specifically, circuits are defined as follows:\n\n- A single $1\\Omega$ resistor (together with its two endpoints) is a circuit. (Although a wire can be regarded as a $0\\Omega$ resistor, a wire alone is not a circuit.)\n- If $A$ and $B$ are both circuits, let $1,2,3$ be three nodes from left to right. Connect the positive and negative terminals of $A$ to $1$ and $2$, respectively, and those of $B$ to $2$ and $3$, respectively. Then the part from $1$ to $3$ is a circuit, with $1$ as the positive terminal and $3$ as the negative terminal.\n- If $A$ and $B$ are both circuits, let $1,2,3,2',3',1'$ be six nodes, where $1$ is to the left of $2$ and $3$, $2$ is to the left of $2'$, $3$ is to the left of $3'$, and $2'$ and $3'$ are to the left of $1'$. There are wires between $1$ and $2$, between $1$ and $3$, between $2'$ and $1'$, and between $3'$ and $1'$. Connect the positive and negative terminals of $A$ to $2$ and $2'$, respectively, and those of $B$ to $3$ and $3'$, respectively. Then the part from $1$ to $1'$ is a circuit, with $1$ as the positive terminal and $1'$ as the negative terminal.\n\nNow you are given a circuit. Find the resistance between its positive and negative terminals.", "description": "Cjwssb recently encountered a tough problem in physics. He does not know how to compute the equivalent resistance of a circuit. He turned to you for help.\n\nThis circuit satisfies the following constraints:\n1. The circuit consists only of wires and resistors of $1\\Omega$.\n2. The circuit is connected from left to right, that is, for every resistor or wire with endpoints $x,y$, it holds that $x<y$.\n3. Node $1$ is the positive terminal of the power supply, and node $n$ is the negative terminal.\n4. Each node is either unused, or serves as the junction of exactly two branch subcircuits that are connected either in series or in parallel.", "inputFormat": "The first line contains two positive integers $n,m$, the numbers of nodes and resistors. Nodes are numbered from left to right, so a smaller index is to the left of a larger index.\n\nEach of the next $m$ lines contains three integers $a_i,b_i,c_i$, meaning there is a resistor between nodes $a_i$ and $b_i$ with resistance $c_i$, where $c_i$ is either $0$ or $1$, and for every $i$ it is guaranteed that $a_i<b_i$.", "outputFormat": "Output a real number, the total resistance, rounded to three decimal places.", "hint": "[Sample Explanation]\n\nDraw the diagram and the answer is obvious.\n\n[Constraints]\n\n| Score | $n$ | $m$ |\n|:-:|:-:|:-:|\n| $20\\%$ | $n\\le 5$ | $m\\le 5$ |\n| $50\\%$ | $n\\le 100$ | $m\\le 120$ |\n| $70\\%$ | $n\\le 1000$ | $m\\le 1200$ |\n| $100\\%$ | $n\\le 10^5$ | $m\\le 1.2\\times 10^6$ |\n\nP.S. The testdata are randomly generated under a fixed $n$, and the answer is guaranteed not to exceed 10 000.\n\nBy: saffah.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "电阻网络", "background": "什么是电阻？这个大家应该都知道。什么是电路？大家也应该知道。但是本题当中，电路的定义或许有点不同：\n\n电路都带有正、负极接点，正极在左，负极在右。具体地：电路分为以下几类：\n\n单独的一个 $1\\Omega$ 电阻（及其两端的接点）是电路（虽然导线也可以被视为 $0\\Omega$ 的电阻，但是单独的导线不是电路）\n\n如果 $A$ 和 $B$ 都是电路，设 $1,2,3$ 是从左到右的三个接点，那么将 $A$ 的正负极分别接在 $1$ 与 $2$ 上，将 $B$ 的正负极分别接在 $2$ 与 $3$ 上，那么 $1$ 到 $3$ 的部分是电路，其中 $1$ 为正极，$3$ 为负极。\n\n如果A和B都是电路,设 $1,2,3,2',3',1'$ 是六个接点，其中 $1$ 在 $2$ 和 $3$ 的左侧，$2$ 在 $2'$ 的左侧，$3$ 在 $3'$ 的左侧，$2'$和 $3'$ 在 $1'$的左侧，并且 $1$ 与 $2$，$1'$ 与 $3'$，$2'$与 $1$，$3'$与$1'$间均连有导线, 那么将 $A$ 的正负极分别接在 $2$ 与 $2'$ 上，将 $B$ 的正负极分别接在 $3$ 与 $3'$ 上，那么 $1$ 到 $1'$ 的部分是电路，其中 $1$ 为正极，$1'$ 为负极。\n\n现在给出一个电路，求它正负极之间的电阻。", "description": "Cjwssb 最近在物理学科上遇到了难题，他不会计算一个电路中的总电阻，现在他找到了你，希望你能帮助他。\n\n这个电路有如下限：\n1. 电路只由导线以及电阻为一欧的电阻组成。\n\n2.    保证电路从左到右连接，即每个电阻或导线的两个连接点 $x,y$，保证 $x<y$。\n\n3.    保证接线柱 $1$ 为电源正极，接线柱 $n$ 为电源负极。\n\n3.    保证每个接线柱只会被串联或者并联两个分支电路或者不接任何电线或电阻。", "inputFormat": "第一行为两个正整数 $n,m$，分别代表接点数和电阻数。保证编号小的接点在编号大的接点的左侧。\n\n接下来 $m$ 行，每行三个整数 $a_i,b_i,c_i$，代表这个电阻连接了 $a_i$ 与 $b_i$ 接点，其阻值为 $c_i$ ，其中 $c_i$ 只可能是 $0$ 或 $1$，且对于任意的 $i$，保证$a_i<b_i$。", "outputFormat": "输出一个实数，表示总的电阻值，保留三位小数输出。", "hint": "【样例解释】\n\n画出图来，答案是显然的。\n\n【数据规模与约定】\n\n|得分占比|$n$|$m$|\n|:-:|:-:|:-:|\n|$20\\%$|$n\\le5$|$m\\le5$|\n|$50\\%$|$n\\le100$|$m\\le120$|\n|$70\\%$|$n\\le1000$|$m\\le1200$|\n|$100\\%$|$n\\le10^5$|$m\\le1.2\\times10^6$|\n\np.s.数据是在人工指定的 $n$ 下随机生成的，保证答案不会超过 $10\\ 000$。\n\nBy：saffah。", "locale": "zh-CN"}}}
{"pid": "P3618", "type": "P", "difficulty": 4, "samples": [["4\nhehehe\nhehe\nwoquxizaolehehe\nwoquxizaole\nhehehehe\nhehe\nowoadiuhzgneninougur\niehiehieh\n", "Case #1: 3\nCase #2: 2\nCase #3: 5\nCase #4: 1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "洛谷原创", "哈希 hashing", "KMP 算法"], "title": "误会", "background": null, "description": "Cjwssb 得到了你的帮助，显得很开心，跟你道谢，你回谢了他。但随后他由于少听了一些词，对你的回谢造成了误会，这使你们两个产生了隔阂，你很不甘心，于是打算告诉他这句话有几种理解方式，以告诉他他误解你了。一句话的理解方式如下：\n\n对于一句原句和听到的句子，理解方式是将听到的句子替换掉原句的相同部分，替换成 `*`，使得原句形成一个新的句子，以达到新的意思，你的任务是统计有多少种意思。", "inputFormat": "第一行一个整数 $T$，表示 $T$ 组测试点。\n\n每组测试点两个字符串，一个字符串一行，第一行字符串是原句，第二行是听到的句子。", "outputFormat": "对于每一个测试点，输出一行 `Case #x: y`，$x$ 表示测试点，$y$ 表示答案，由于答案可能很大，你只需要输出答案取模 $10^9+7$。", "hint": "在第一个测试点，`hehehe` 有三个理解意思，分别是 `*he`，`he*`，`hehehe`。\n\n在第三个测试点，`hehehehe` 有五个理解意思，分别是 `*hehe`，`he*he`，`hehe*`，`**`，`hehehehe`。\n\n对于 $100\\%$ 的数据\n\n$T\\le 30$\n\n$|A|\\le 10^5$\n\n$|B|\\le |A|$\n\nBy：2016 Mul", "locale": "zh-CN", "translations": {"en": {"title": "Misunderstanding", "background": "", "description": "Cjwssb was very happy after receiving your help and thanked you, and you thanked him back. However, because he missed some words, he misunderstood your reply. This created a rift between you. Unwilling to accept this, you decide to tell him how many different ways that sentence can be understood, to show that he misunderstood you.\n\nGiven an original sentence and the heard sentence, an interpretation is formed by choosing any set of pairwise non-overlapping occurrences of the heard sentence inside the original sentence and replacing each chosen occurrence with a single `*`, thereby turning the original sentence into a new sentence to convey a new meaning. Your task is to count how many different meanings there are.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nFor each test case, there are two strings, one per line. The first line is the original sentence, and the second line is the heard sentence.", "outputFormat": "For each test case, output one line in the form `Case #x: y`, where $x$ is the test case number and $y$ is the answer. Since the answer may be large, output it modulo $10^9+7$.", "hint": "In the first test case, `hehehe` has three interpretations: `*he`, `he*`, `hehehe`.\n\nIn the third test case, `hehehehe` has five interpretations: `*hehe`, `he*he`, `hehe*`, `**`, `hehehehe`.\n\nConstraints for $100\\%$ of the testdata:\n\n$T \\le 30$.\n\n$|A| \\le 10^5$.\n\n$|B| \\le |A|$.\n\nBy: 2016 Mul.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "误会", "background": null, "description": "Cjwssb 得到了你的帮助，显得很开心，跟你道谢，你回谢了他。但随后他由于少听了一些词，对你的回谢造成了误会，这使你们两个产生了隔阂，你很不甘心，于是打算告诉他这句话有几种理解方式，以告诉他他误解你了。一句话的理解方式如下：\n\n对于一句原句和听到的句子，理解方式是将听到的句子替换掉原句的相同部分，替换成 `*`，使得原句形成一个新的句子，以达到新的意思，你的任务是统计有多少种意思。", "inputFormat": "第一行一个整数 $T$，表示 $T$ 组测试点。\n\n每组测试点两个字符串，一个字符串一行，第一行字符串是原句，第二行是听到的句子。", "outputFormat": "对于每一个测试点，输出一行 `Case #x: y`，$x$ 表示测试点，$y$ 表示答案，由于答案可能很大，你只需要输出答案取模 $10^9+7$。", "hint": "在第一个测试点，`hehehe` 有三个理解意思，分别是 `*he`，`he*`，`hehehe`。\n\n在第三个测试点，`hehehehe` 有五个理解意思，分别是 `*hehe`，`he*he`，`hehe*`，`**`，`hehehehe`。\n\n对于 $100\\%$ 的数据\n\n$T\\le 30$\n\n$|A|\\le 10^5$\n\n$|B|\\le |A|$\n\nBy：2016 Mul", "locale": "zh-CN"}}}
{"pid": "P3619", "type": "P", "difficulty": 4, "samples": [["1\n2 13\n1 -9\n5 -3\n", "+1s\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "洛谷原创", "排序"], "title": "魔法", "background": "", "description": "cjwssb 知道是误会之后，跟你道了歉。你为了逗笑他，准备和他一起开始魔法。不过你的时间不多了，但是更惨的是你还需要完成 $n$ 个魔法任务。假设你当前的时间为 $T$，每个任务需要有一定的限制 $t_i$ 表示只有当你的 $T$ 严格大于 $t_i$ 时你才能完成这个任务，完成任务并不需要消耗时间。当你完成第 $i$ 个任务时，你的时间 $T$ 会加上 $b_i$，此时要保证 $T$ 在任何时刻都大于 $0$，那么请问你是否能完成这 $n$ 个魔法任务，如果可以，输出 $\\texttt{+1}\\texttt{s}$，如果不行，输出 $\\texttt{-1}\\texttt{s}$。\n", "inputFormat": "第一行：一个整数 $Z$，表示有 $Z$ 个测试点。\n\n对于每个测试点：\n\n第一行：两个整数 $n,T$，表示有 $n$ 个任务,你一开始有 $T$ 的时间。\n\n接下来 $n$ 行，每行 $2$ 个数字，$t_i$ 与 $b_i$。\n", "outputFormat": "对于每个测试点，输出 $\\texttt{+1}\\texttt{s}$ 或者 $\\texttt{-1}\\texttt{s}$。\n", "hint": "对于 $20\\%$ 的数据，$n\\leq10$；\n\n对于 $100\\%$ 的数据，$n\\leq10^5,Z\\leq10,t_i\\leq10^5,T\\leq10^5,-10^5\\leq b_i\\leq 10^5$。\n\nBy lantian\n\n$\\LaTeX$ By ⚡炭治郎⚡\n\n## 因为历史遗留问题，博客讨论可能无法发出样例输出的字符串，可以考虑使用其他方式规避。\n", "locale": "zh-CN", "translations": {"en": {"title": "Magic", "background": "", "description": "After cjwssb realized it was a misunderstanding, he apologized to you. To cheer him up, you plan to start doing magic together. However, your time is running out, and worse, you still need to complete $n$ magic tasks. Suppose your current time is $T$. Each task has a constraint $t_i$, meaning you can complete this task only when your $T$ is strictly greater than $t_i$. Completing a task does not consume time. When you complete the $i$-th task, your time $T$ increases by $b_i$. At all times, $T$ must remain greater than $0$. Determine whether you can complete all $n$ magic tasks. If yes, output $\\texttt{+1}\\texttt{s}$; otherwise, output $\\texttt{-1}\\texttt{s}$.", "inputFormat": "The first line contains an integer $Z$, the number of test cases.\n\nFor each test case:\n\n- The first line contains two integers $n, T$, meaning there are $n$ tasks and your initial time is $T$.\n- The next $n$ lines each contain two integers, $t_i$ and $b_i$.", "outputFormat": "For each test case, output $\\texttt{+1}\\texttt{s}$ or $\\texttt{-1}\\texttt{s}$.", "hint": "- For $20\\%$ of the testdata, $n \\leq 10$.\n- For $100\\%$ of the testdata, $n \\leq 10^5$, $Z \\leq 10$, $t_i \\leq 10^5$, $T \\leq 10^5$, $-10^5 \\leq b_i \\leq 10^5$.\n\nBy lantian.\n\n$\\LaTeX$ By ⚡炭治郎⚡.\n\nDue to historical reasons, the blog discussion may not be able to post the sample output strings. You may consider other ways to work around this.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "魔法", "background": "", "description": "cjwssb 知道是误会之后，跟你道了歉。你为了逗笑他，准备和他一起开始魔法。不过你的时间不多了，但是更惨的是你还需要完成 $n$ 个魔法任务。假设你当前的时间为 $T$，每个任务需要有一定的限制 $t_i$ 表示只有当你的 $T$ 严格大于 $t_i$ 时你才能完成这个任务，完成任务并不需要消耗时间。当你完成第 $i$ 个任务时，你的时间 $T$ 会加上 $b_i$，此时要保证 $T$ 在任何时刻都大于 $0$，那么请问你是否能完成这 $n$ 个魔法任务，如果可以，输出 $\\texttt{+1}\\texttt{s}$，如果不行，输出 $\\texttt{-1}\\texttt{s}$。\n", "inputFormat": "第一行：一个整数 $Z$，表示有 $Z$ 个测试点。\n\n对于每个测试点：\n\n第一行：两个整数 $n,T$，表示有 $n$ 个任务,你一开始有 $T$ 的时间。\n\n接下来 $n$ 行，每行 $2$ 个数字，$t_i$ 与 $b_i$。\n", "outputFormat": "对于每个测试点，输出 $\\texttt{+1}\\texttt{s}$ 或者 $\\texttt{-1}\\texttt{s}$。\n", "hint": "对于 $20\\%$ 的数据，$n\\leq10$；\n\n对于 $100\\%$ 的数据，$n\\leq10^5,Z\\leq10,t_i\\leq10^5,T\\leq10^5,-10^5\\leq b_i\\leq 10^5$。\n\nBy lantian\n\n$\\LaTeX$ By ⚡炭治郎⚡\n\n## 因为历史遗留问题，博客讨论可能无法发出样例输出的字符串，可以考虑使用其他方式规避。\n", "locale": "zh-CN"}}}
{"pid": "P3620", "type": "P", "difficulty": 5, "samples": [["5 2 \n1 \n3 \n4 \n6 \n12 ", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2007", "APIO", "优先队列", "差分", "CTSC/CTS", "反悔贪心"], "title": "[APIO/CTSC2007] 数据备份", "background": "", "description": "你在一家 IT 公司为大型写字楼或办公楼的计算机数据做备份。然而数据备份的工作是枯燥乏味的，因此你想设计一个系统让不同的办公楼彼此之间互相备份，而你则坐在家中尽享计算机游戏的乐趣。\n\n已知办公楼都位于同一条街上。你决定给这些办公楼配对（两个一组）。每一对办公楼可以通过在这两个建筑物之间铺设网络电缆使得它们可以互相备份。\n\n然而，网络电缆的费用很高。当地电信公司仅能为你提供 $K$ 条网络电缆，这意味着你仅能为 $K$ 对办公楼（或总计 $2K$ 个办公楼）安排备份。任一个办公楼都属于唯一的配对组（换句话说，这 $2K$ 个办公楼一定是相异的）。\n\n此外，电信公司需按网络电缆的长度（公里数）收费。因而，你需要选择这 $K$ 对办公楼使得电缆的总长度尽可能短。换句话说，你需要选择这 $K$ 对办公楼，使得每一对办公楼之间的距离之和（总距离）尽可能小。\n\n下面给出一个示例，假定你有 $5$ 个客户，其办公楼都在一条街上，如下图所示。这 $5$ 个办公楼分别位于距离大街起点 $1\\rm km$, $3\\rm km$, $4\\rm km$, $6\\rm km$ 和 $12\\rm km$ 处。电信公司仅为你提供 $K=2$ 条电缆。\n\n  ![](https://cdn.luogu.com.cn/upload/pic/4386.png) \n\n上例中最好的配对方案是将第 $1$ 个和第 $2$ 个办公楼相连，第 $3$ 个和第 $4$ 个办公楼相连。这样可按要求使用 $K=2$ 条电缆。第 $1$ 条电缆的长度是 $\\rm 3km-1km = 2km$，第 2 条电缆的长度是 $\\rm 6km―4km = 2 km$。这种配对方案需要总长 $4\\rm km$ 的网络电缆，满足距离之和最小的要求。", "inputFormat": "输入文件的第一行包含整数 $N$ 和 $K$，其中 $N$（$1\\leq N \\leq 10^5$）表示办公楼的数目，$K$（$\\displaystyle 1\\leq K \\leq \\frac{N}{2}$）表示可利用的网络电缆的数目。\n\n接下来的 $N$ 行每行仅包含一个整数 $s$（$0\\leq s \\leq 10^9$）, 表示每个办公楼到大街起点处的距离。这些整数将按照从小到大的顺序依次出现。", "outputFormat": "输出文件应当由一个正整数组成，给出将 $2K$ 个相异的办公楼连成 $K$ 对所需的网络电缆的最小总长度。", "hint": "$30\\%$ 的输入数据满足 $N\\leq 20$。\n\n$60\\%$ 的输入数据满足 $N\\leq 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[APIO/CTSC2007] Data Backup", "background": "", "description": "You work at an IT company backing up computer data for large office buildings. However, data backup is boring, so you want to design a system that lets different office buildings back up each other’s data while you sit at home enjoying computer games.\n\nAll the office buildings are located on the same street. You decide to pair the buildings (two per group). Each pair can back up each other by laying a network cable between the two buildings.\n\nHowever, network cables are expensive. The local telecom company can provide only $K$ cables, which means you can arrange backups for only $K$ pairs of buildings (or a total of $2K$ buildings). Each building belongs to exactly one pair (in other words, those $2K$ buildings are all distinct).\n\nAdditionally, the telecom company charges by the length of the cable in kilometers. Hence, you need to choose the $K$ pairs of buildings so that the total cable length is as short as possible. In other words, you need to choose the $K$ pairs so that the sum of the distances between each pair (the total distance) is minimized.\n\nHere is an example. Suppose you have $5$ clients whose buildings lie on a single street, as shown below. The $5$ buildings are located at distances $1\\rm km$, $3\\rm km$, $4\\rm km$, $6\\rm km$, and $12\\rm km$ from the start of the street. The telecom company provides only $K=2$ cables.\n\n  ![](https://cdn.luogu.com.cn/upload/pic/4386.png) \n\nIn this example, the best pairing is to connect the $1$st and $2$nd buildings, and the $3$rd and $4$th buildings. This uses exactly $K=2$ cables as required. The length of the first cable is $\\rm 3km-1km = 2km$, and the length of the second cable is $\\rm 6km―4km = 2 km$. This pairing requires a total of $4\\rm km$ of cable, achieving the minimum possible sum of distances.", "inputFormat": "The first line of input contains integers $N$ and $K$, where $N$ ($1 \\leq N \\leq 10^5$) is the number of office buildings, and $K$ ($\\displaystyle 1\\leq K \\leq \\frac{N}{2}$) is the number of cables available.\n\nEach of the next $N$ lines contains a single integer $s$ ($0 \\leq s \\leq 10^9$), the distance of each building from the start of the street. These integers are given in increasing order.", "outputFormat": "Output a single positive integer: the minimum total cable length required to connect $2K$ distinct buildings into $K$ pairs.", "hint": "$30\\%$ of the testdata satisfy $N \\leq 20$.\n\n$60\\%$ of the testdata satisfy $N \\leq 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO/CTSC2007] 数据备份", "background": "", "description": "你在一家 IT 公司为大型写字楼或办公楼的计算机数据做备份。然而数据备份的工作是枯燥乏味的，因此你想设计一个系统让不同的办公楼彼此之间互相备份，而你则坐在家中尽享计算机游戏的乐趣。\n\n已知办公楼都位于同一条街上。你决定给这些办公楼配对（两个一组）。每一对办公楼可以通过在这两个建筑物之间铺设网络电缆使得它们可以互相备份。\n\n然而，网络电缆的费用很高。当地电信公司仅能为你提供 $K$ 条网络电缆，这意味着你仅能为 $K$ 对办公楼（或总计 $2K$ 个办公楼）安排备份。任一个办公楼都属于唯一的配对组（换句话说，这 $2K$ 个办公楼一定是相异的）。\n\n此外，电信公司需按网络电缆的长度（公里数）收费。因而，你需要选择这 $K$ 对办公楼使得电缆的总长度尽可能短。换句话说，你需要选择这 $K$ 对办公楼，使得每一对办公楼之间的距离之和（总距离）尽可能小。\n\n下面给出一个示例，假定你有 $5$ 个客户，其办公楼都在一条街上，如下图所示。这 $5$ 个办公楼分别位于距离大街起点 $1\\rm km$, $3\\rm km$, $4\\rm km$, $6\\rm km$ 和 $12\\rm km$ 处。电信公司仅为你提供 $K=2$ 条电缆。\n\n  ![](https://cdn.luogu.com.cn/upload/pic/4386.png) \n\n上例中最好的配对方案是将第 $1$ 个和第 $2$ 个办公楼相连，第 $3$ 个和第 $4$ 个办公楼相连。这样可按要求使用 $K=2$ 条电缆。第 $1$ 条电缆的长度是 $\\rm 3km-1km = 2km$，第 2 条电缆的长度是 $\\rm 6km―4km = 2 km$。这种配对方案需要总长 $4\\rm km$ 的网络电缆，满足距离之和最小的要求。", "inputFormat": "输入文件的第一行包含整数 $N$ 和 $K$，其中 $N$（$1\\leq N \\leq 10^5$）表示办公楼的数目，$K$（$\\displaystyle 1\\leq K \\leq \\frac{N}{2}$）表示可利用的网络电缆的数目。\n\n接下来的 $N$ 行每行仅包含一个整数 $s$（$0\\leq s \\leq 10^9$）, 表示每个办公楼到大街起点处的距离。这些整数将按照从小到大的顺序依次出现。", "outputFormat": "输出文件应当由一个正整数组成，给出将 $2K$ 个相异的办公楼连成 $K$ 对所需的网络电缆的最小总长度。", "hint": "$30\\%$ 的输入数据满足 $N\\leq 20$。\n\n$60\\%$ 的输入数据满足 $N\\leq 10^4$。", "locale": "zh-CN"}}}
{"pid": "P3621", "type": "P", "difficulty": 4, "samples": [["6 \n2 3 \n-1 4 \n5 6 \n-1 -1 \n-1 -1 \n-1 -1 \n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "贪心", "2007", "APIO"], "title": "[APIO2007] 风铃", "background": null, "description": "你准备给弟弟 Ike 买一件礼物，但是，Ike 挑选礼物的方式很特别：他只喜欢那些能被他排成有序形状的东西。\n\n你准备给 Ike 买一个风铃。风铃是一种多层的装饰品，一般挂在天花板上。\n\n每个风铃都包含一些由竖直线连起来的水平杆。每根杆的两头都有线连接，下面或者挂着另一根水平杆，或者挂着一个玩具。下面是一个风铃的例子：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e1m223hc.png)\n\n为了满足弟弟，你需要选一个满足下面两个条件的风铃：\n\n1. 所有的玩具都在同一层(也就是说，每个玩具到天花板之间的杆的个数是一样的)或至多相差一层。\n2. 对于两个相差一层的玩具，左边的玩具比右边的玩具要更靠下一点。\n\n风铃可以按照下面的规则重新排列：任选一根杆，将杆两头的线“交换”。也就是解开一根杆左右两头的线，然后将它们绑到杆的另一头。这个操作不会改变更下面的杆上线的排列顺序。\n\n正在训练信息学奥林匹克的你，决定设计一个算法，判断能否通过重新排列，将一个给定的风铃变为 Ike 喜欢的样子。\n\n考虑上面的例子，上图中的风铃满足条件 $1$，却不满足条件 $2$ ——最左边的那个玩具比它右边的要高。\n\n但是，我们可以通过下面的步骤把这个风铃变成一个 Ike 喜欢的：\n\n 1.   第一步，将杆 $1$ 的左右两边交换，这使得杆 $2$ 和杆 $3$ 的位置互换，交换的结果如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/4388.png)\n\n 2.   第二步，也是最后一步，将杆 $2$ 的左右两边交换，这使得杆 $4$ 到了左边，原来在左边的玩具到了右边，交换的结果发下图所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/4389.png)\n\n现在的这个风铃就满足 Ike 的条件了。\n\n你的任务是：给定一个风铃的描述，求出最少需要多少次交换才能使这风铃满足 Ike 的条件(如果可能)。", "inputFormat": "输入的第一行包含一个整数 $n$，表示风铃中有多少根杆。\n\n接下来的 $n$ 行描述杆的连接信息。这部分的第 $i$ 行包含两个由空格分隔的整数 $l_i$ 和 $r_i$，描述杆 $i$ 的左右两边悬挂的东西。如果挂的是一个玩具，则对应的值为``-1``，否则为挂在下面的杆的编号。", "outputFormat": "输出仅包含一个整数。表示最少需要多少次交换能使风铃满足 Ike 的条件。如果不可能满足，输出``-1``。", "hint": "#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，满足 $1 \\le n \\le 10^5$，$-1 \\leq l_i, r_i \\leq n$，$l_i, r_i \\neq 0$。", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2007] Wind Chime", "background": "", "description": "You want to buy a gift for your younger brother Ike, but Ike has a special way of choosing gifts: he only likes things that he can arrange into an ordered shape.\n\nYou plan to buy Ike a wind chime. A wind chime is a multi-layered ornament that is usually hung from the ceiling.\n\nEach wind chime consists of several horizontal bars connected by vertical strings. Each end of a bar has a string attached; below it hangs either another horizontal bar or a toy. Here is an example of a wind chime:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e1m223hc.png)\n\nTo satisfy Ike, you need to choose a wind chime that meets the following two conditions:\n\n1. All toys are on the same level (that is, the number of bars between each toy and the ceiling is the same), or they differ by at most one level.\n2. For any two toys that differ by one level, the left toy must hang lower than the right toy.\n\nA wind chime can be rearranged using the following rule: choose any bar and “swap” the strings at its two ends. That is, detach the strings from the left and right ends of the bar and reattach them to the opposite ends. This operation does not change the relative order of the strings on any bars below.\n\nAs a trainee in informatics, you decide to design an algorithm to determine whether a given wind chime can be rearranged to satisfy Ike’s preferences.\n\nConsider the example above. The wind chime in the figure satisfies condition 1 but not condition 2 — the leftmost toy is higher than the one to its right.\n\nHowever, we can transform this wind chime into one that Ike likes through the following steps:\n\n1. First, swap the left and right ends of bar $1$, which swaps the positions of bars $2$ and $3$. The result is shown below:\n\n![](https://cdn.luogu.com.cn/upload/pic/4388.png)\n\n2. Second, and final, swap the left and right ends of bar $2$, which moves bar $4$ to the left and moves the toy that was on the left to the right. The result is shown below:\n\n![](https://cdn.luogu.com.cn/upload/pic/4389.png)\n\nNow this wind chime satisfies Ike’s conditions.\n\nYour task is: given a description of a wind chime, compute the minimum number of swaps needed to make it satisfy Ike’s conditions (if possible).", "inputFormat": "The first line contains an integer $n$, the number of bars in the wind chime.\n\nThe next $n$ lines describe the connections of the bars. The $i$-th of these lines contains two integers $l_i$ and $r_i$, separated by a space, describing what is attached to the left and right ends of bar $i$. If a toy is attached, the value is ``-1``; otherwise, it is the index of the bar hanging below.", "outputFormat": "Output a single integer: the minimum number of swaps needed to make the wind chime satisfy Ike’s conditions. If it is impossible, output ``-1``.", "hint": "Constraints\n\n- For $100\\%$ of the testdata, $1 \\le n \\le 10^5$, $-1 \\le l_i, r_i \\le n$, and $l_i, r_i \\ne 0$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2007] 风铃", "background": null, "description": "你准备给弟弟 Ike 买一件礼物，但是，Ike 挑选礼物的方式很特别：他只喜欢那些能被他排成有序形状的东西。\n\n你准备给 Ike 买一个风铃。风铃是一种多层的装饰品，一般挂在天花板上。\n\n每个风铃都包含一些由竖直线连起来的水平杆。每根杆的两头都有线连接，下面或者挂着另一根水平杆，或者挂着一个玩具。下面是一个风铃的例子：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e1m223hc.png)\n\n为了满足弟弟，你需要选一个满足下面两个条件的风铃：\n\n1. 所有的玩具都在同一层(也就是说，每个玩具到天花板之间的杆的个数是一样的)或至多相差一层。\n2. 对于两个相差一层的玩具，左边的玩具比右边的玩具要更靠下一点。\n\n风铃可以按照下面的规则重新排列：任选一根杆，将杆两头的线“交换”。也就是解开一根杆左右两头的线，然后将它们绑到杆的另一头。这个操作不会改变更下面的杆上线的排列顺序。\n\n正在训练信息学奥林匹克的你，决定设计一个算法，判断能否通过重新排列，将一个给定的风铃变为 Ike 喜欢的样子。\n\n考虑上面的例子，上图中的风铃满足条件 $1$，却不满足条件 $2$ ——最左边的那个玩具比它右边的要高。\n\n但是，我们可以通过下面的步骤把这个风铃变成一个 Ike 喜欢的：\n\n 1.   第一步，将杆 $1$ 的左右两边交换，这使得杆 $2$ 和杆 $3$ 的位置互换，交换的结果如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/4388.png)\n\n 2.   第二步，也是最后一步，将杆 $2$ 的左右两边交换，这使得杆 $4$ 到了左边，原来在左边的玩具到了右边，交换的结果发下图所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/4389.png)\n\n现在的这个风铃就满足 Ike 的条件了。\n\n你的任务是：给定一个风铃的描述，求出最少需要多少次交换才能使这风铃满足 Ike 的条件(如果可能)。", "inputFormat": "输入的第一行包含一个整数 $n$，表示风铃中有多少根杆。\n\n接下来的 $n$ 行描述杆的连接信息。这部分的第 $i$ 行包含两个由空格分隔的整数 $l_i$ 和 $r_i$，描述杆 $i$ 的左右两边悬挂的东西。如果挂的是一个玩具，则对应的值为``-1``，否则为挂在下面的杆的编号。", "outputFormat": "输出仅包含一个整数。表示最少需要多少次交换能使风铃满足 Ike 的条件。如果不可能满足，输出``-1``。", "hint": "#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，满足 $1 \\le n \\le 10^5$，$-1 \\leq l_i, r_i \\leq n$，$l_i, r_i \\neq 0$。", "locale": "zh-CN"}}}
{"pid": "P3622", "type": "P", "difficulty": 6, "samples": [["14 5 \n2 1 2 4 2 6 \n3 1 1 6 4 \n6 1 2 9 6 8\n8 1 1 9 12 \n12 3 0 12 13 2 ", "5"], ["12 7 \n1 1 1 1 5 \n5 1 1 5 7 \n5 0 3 5 7 9 \n7 1 1 7 9 \n9 1 1 9 11 \n9 3 0 9 11 1\n11 1 1 11 1", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "APIO", "枚举", "深度优先搜索 DFS", "状压 DP"], "title": "[APIO2007] 动物园", "background": "", "description": "新建的圆形动物园是亚太地区的骄傲。圆形动物园坐落于太平洋的一个小岛上，包含一大圈围栏，每个围栏里有一\n种动物。如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8pr43p86.png)\n\n你是动物园的公共主管。你要做的是，让每个来动物园的人都尽可能高兴。今天有一群小朋友来动物园参观，你希望能让他们在动物园度过一段美好的时光。但这并不是一件容易的事——有的动物有一些小朋友喜欢，有的动物有一些小朋友害怕。如，Alex 喜欢可爱的猴子和考拉，而害怕拥牙齿锋利的狮子。而 Polly 会因狮子有美丽的鬃毛而喜欢它，但害怕有臭味的考拉。你可以选择将一些动物从围栏中移走以使得小朋友不会害怕。但你不能移走太多动物，否则小朋友们就没有动物可看了。每个小朋友站在大围栏圈的外面，可以看到连续的 $5$ 个围栏。你得到了所有小朋友喜欢和害怕的动物信息。当下面两处情况之一发生时，小朋友就会高兴：\n- 至少有一个他害怕的动物被移走\n- 至少有一个他喜欢的动物没被移走\n\n例如，考虑下图中的小朋友和动物：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n69iqfv6.png)\n\n- 假如你将围栏 $4$ 和 $12$ 的动物移走。Alex 和 Ka-Shu 将很高兴，因为至少有一个他们害怕的动物被移走了。这也会使 Chaitanya 高兴，因为他喜欢的围栏  $6$ 和 $8$ 中的动物都保留了。但是，Polly 和 Hwan 将不高兴，因为他们看不到任何他们喜欢的动物，而他们害怕的动物都还在。这种安排方式使得三个小朋友高兴。\n- 现在，换一种方法，如果你将围栏 $4$ 和 $6$ 中的动物移走，Alex 和 Polly 将很高兴，因为他们害怕的动物被移走了。Chaitanya 也会高兴，虽然他喜欢的动物 $6$ 被移走了，他仍可以看到围栏 $8$ 里面他喜欢的动物。同样的 Hwan 也会因可以看到自己喜欢的动物 $12$ 而高兴。唯一不高兴的只有 Ka-Shu。\n- 如果你只移走围栏 $13$ 中的动物，Ka-Shu 将高兴，因为有一个他害怕的动物被移走了，Alex, Polly, Chaitanya 和 Hwan 也会高兴，因为他们都可以看到至少一个他们喜欢的动物。所以有 $5$ 个小朋友会高兴。这种方法使得了最多的小朋友高兴。", "inputFormat": "输入的第一行包含两个整数 $N$，$C$，用空格分隔。\n\n$N$ 是围栏数（$10 \\le N \\le 10^4$），$C$ 是小朋友的个数（$1 \\le C \\le 5\\times 10^4$）。\n\n围栏按照顺时针的方向编号为 $1,2,3,\\cdots,N$。\n\n接下来的 $C$ 行，每行描述一个小朋友的信息，以下面的形式给出： $E, F, L ,X_1, X_2 ,\\cdots ,X_F ,Y_1 ,Y_2 ,\\cdots ,Y_L$。 \n\n其中： $E$ 表示这个小朋友可以看到的第一个围栏的编号（$1 \\le E \\le N$），换句话说，该小朋友可以看到的围栏为 $E$， $E+1$， $E+2$， $E+3$， $E+4$。\n\n注意，如果编号超过 $N$ 将继续从 $1$ 开始算。\n\n如：当 $N=14$，$ E=13$ 时，这个小朋友可以看到的围栏为 $13,14,1, 2$ 和 $3$。\n\n$F$ 表示该小朋友害怕的动物数。\n\n$L$ 表示该小朋友喜欢的动物数。\n\n围栏 $X_1, X_2, \\cdots, X_F$ 中包含该小朋友害怕的动物。\n\n围栏 $Y_1, Y_2, \\cdots, Y_L$ 中包含该小朋友喜欢的动物。 \n\n$X_1, X_2, \\cdots, X_F, Y_1, Y_2, \\cdots, Y_L$ 是两两不同的整数，而且所表示的围栏都是该小朋友可以看到的。\n\n小朋友已经按照他们可以看到的第一个围栏的编号从小到大的顺序排好了（这样最小的 $E$ 对应的小朋友排在第一个，最大的 $E$ 对应的小朋友排在最后一个）。\n\n注意可能有多于一个小朋友对应的 $E$ 是相同的。", "outputFormat": "仅输出一个数，表示最多可以让多少个小朋友高兴。\n", "hint": "**数据范围**\n对于 $100\\%$ 的数据，$10 \\le N \\le 10^4$，$1 \\le C \\le 5\\times 10^4$，$1 \\le E \\le N$。\n\n**样例说明**\n- 第一个样例是题目描述中的例子，所有的 $C=5$ 个小朋友都能高兴。\n- 第二个样例是一个不能使得所有 $C=7$ 个小朋友都高兴的例子。", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2007] Zoo", "background": "", "description": "The newly built circular zoo is the pride of the Asia-Pacific region. The zoo stands on a small island in the Pacific Ocean and consists of a large ring of enclosures, each containing one species of animal. As shown below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8pr43p86.png)\n\nYou are the zoo’s public manager. Your job is to make every visitor as happy as possible. Today a group of children is visiting the zoo, and you hope they will have a wonderful time there. But this is not easy — some animals are liked by some children, while others are feared by some children. For example, Alex likes the cute monkeys and koalas but is afraid of sharp-toothed lions. Polly, however, likes lions because of their beautiful manes but is afraid of smelly koalas. You may choose to remove some animals from their enclosures so that the children are not scared. However, you cannot remove too many animals, or the children will have nothing to see. Each child stands outside the circular ring of enclosures and can see $5$ consecutive enclosures. You are given, for each child, which animals they like and which they fear. A child is happy if at least one of the following holds:\n- At least one animal they fear is removed.\n- At least one animal they like is not removed.\n\nFor example, consider the children and animals shown below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n69iqfv6.png)\n\n- Suppose you remove the animals in enclosures 4 and 12. Alex and Ka-Shu will be happy because at least one animal they fear has been removed. This also makes Chaitanya happy because the animals he likes in enclosures 6 and 8 both remain. However, Polly and Hwan will not be happy because they cannot see any animals they like, and the animals they fear are still there. This arrangement makes three children happy.\n- Now try another plan: if you remove the animals in enclosures 4 and 6, Alex and Polly will be happy because the animals they fear have been removed. Chaitanya will also be happy: although the animal he likes in enclosure 6 is removed, he can still see the animal he likes in enclosure 8. Similarly, Hwan is happy because he can see the animal he likes in enclosure 12. The only unhappy child is Ka-Shu.\n- If you remove only the animal in enclosure 13, Ka-Shu will be happy because one animal he fears has been removed, and Alex, Polly, Chaitanya, and Hwan will also be happy because each of them can see at least one animal they like. Thus $5$ children are happy. This plan makes the maximum number of children happy.", "inputFormat": "The first line contains two integers $N$, $C$, separated by a space.\n\n$N$ is the number of enclosures ($10 \\le N \\le 10^4$), and $C$ is the number of children ($1 \\le C \\le 5 \\times 10^4$).\n\nThe enclosures are numbered clockwise as $1, 2, 3, \\cdots, N$.\n\nEach of the next $C$ lines describes one child in the following format: $E, F, L, X_1, X_2, \\cdots, X_F, Y_1, Y_2, \\cdots, Y_L$.\n\nHere, $E$ is the index of the first enclosure this child can see ($1 \\le E \\le N$). In other words, the child can see enclosures $E$, $E+1$, $E+2$, $E+3$, and $E+4$.\n\nNote that if the numbering exceeds $N$, it wraps around starting from $1$ again.\n\nFor example, when $N=14$ and $E=13$, the enclosures the child can see are $13, 14, 1, 2$, and $3$.\n\n$F$ is the number of animals this child fears.\n\n$L$ is the number of animals this child likes.\n\nEnclosures $X_1, X_2, \\cdots, X_F$ contain animals the child fears.\n\nEnclosures $Y_1, Y_2, \\cdots, Y_L$ contain animals the child likes.\n\n$X_1, X_2, \\cdots, X_F, Y_1, Y_2, \\cdots, Y_L$ are pairwise distinct integers, and all referenced enclosures are among the five enclosures the child can see.\n\nThe children are listed in nondecreasing order of their $E$ values (that is, the child with the smallest $E$ appears first, and the one with the largest $E$ appears last).\n\nNote that there may be multiple children with the same $E$.", "outputFormat": "Output a single integer: the maximum number of children that can be made happy.", "hint": "Constraints\nFor $100\\%$ of the testdata, $10 \\le N \\le 10^4$, $1 \\le C \\le 5 \\times 10^4$, $1 \\le E \\le N$.\n\nSample Explanation\n- In the first sample (the example from the statement), all $C=5$ children can be made happy.\n- In the second sample, it is impossible to make all $C=7$ children happy.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2007] 动物园", "background": "", "description": "新建的圆形动物园是亚太地区的骄傲。圆形动物园坐落于太平洋的一个小岛上，包含一大圈围栏，每个围栏里有一\n种动物。如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8pr43p86.png)\n\n你是动物园的公共主管。你要做的是，让每个来动物园的人都尽可能高兴。今天有一群小朋友来动物园参观，你希望能让他们在动物园度过一段美好的时光。但这并不是一件容易的事——有的动物有一些小朋友喜欢，有的动物有一些小朋友害怕。如，Alex 喜欢可爱的猴子和考拉，而害怕拥牙齿锋利的狮子。而 Polly 会因狮子有美丽的鬃毛而喜欢它，但害怕有臭味的考拉。你可以选择将一些动物从围栏中移走以使得小朋友不会害怕。但你不能移走太多动物，否则小朋友们就没有动物可看了。每个小朋友站在大围栏圈的外面，可以看到连续的 $5$ 个围栏。你得到了所有小朋友喜欢和害怕的动物信息。当下面两处情况之一发生时，小朋友就会高兴：\n- 至少有一个他害怕的动物被移走\n- 至少有一个他喜欢的动物没被移走\n\n例如，考虑下图中的小朋友和动物：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n69iqfv6.png)\n\n- 假如你将围栏 $4$ 和 $12$ 的动物移走。Alex 和 Ka-Shu 将很高兴，因为至少有一个他们害怕的动物被移走了。这也会使 Chaitanya 高兴，因为他喜欢的围栏  $6$ 和 $8$ 中的动物都保留了。但是，Polly 和 Hwan 将不高兴，因为他们看不到任何他们喜欢的动物，而他们害怕的动物都还在。这种安排方式使得三个小朋友高兴。\n- 现在，换一种方法，如果你将围栏 $4$ 和 $6$ 中的动物移走，Alex 和 Polly 将很高兴，因为他们害怕的动物被移走了。Chaitanya 也会高兴，虽然他喜欢的动物 $6$ 被移走了，他仍可以看到围栏 $8$ 里面他喜欢的动物。同样的 Hwan 也会因可以看到自己喜欢的动物 $12$ 而高兴。唯一不高兴的只有 Ka-Shu。\n- 如果你只移走围栏 $13$ 中的动物，Ka-Shu 将高兴，因为有一个他害怕的动物被移走了，Alex, Polly, Chaitanya 和 Hwan 也会高兴，因为他们都可以看到至少一个他们喜欢的动物。所以有 $5$ 个小朋友会高兴。这种方法使得了最多的小朋友高兴。", "inputFormat": "输入的第一行包含两个整数 $N$，$C$，用空格分隔。\n\n$N$ 是围栏数（$10 \\le N \\le 10^4$），$C$ 是小朋友的个数（$1 \\le C \\le 5\\times 10^4$）。\n\n围栏按照顺时针的方向编号为 $1,2,3,\\cdots,N$。\n\n接下来的 $C$ 行，每行描述一个小朋友的信息，以下面的形式给出： $E, F, L ,X_1, X_2 ,\\cdots ,X_F ,Y_1 ,Y_2 ,\\cdots ,Y_L$。 \n\n其中： $E$ 表示这个小朋友可以看到的第一个围栏的编号（$1 \\le E \\le N$），换句话说，该小朋友可以看到的围栏为 $E$， $E+1$， $E+2$， $E+3$， $E+4$。\n\n注意，如果编号超过 $N$ 将继续从 $1$ 开始算。\n\n如：当 $N=14$，$ E=13$ 时，这个小朋友可以看到的围栏为 $13,14,1, 2$ 和 $3$。\n\n$F$ 表示该小朋友害怕的动物数。\n\n$L$ 表示该小朋友喜欢的动物数。\n\n围栏 $X_1, X_2, \\cdots, X_F$ 中包含该小朋友害怕的动物。\n\n围栏 $Y_1, Y_2, \\cdots, Y_L$ 中包含该小朋友喜欢的动物。 \n\n$X_1, X_2, \\cdots, X_F, Y_1, Y_2, \\cdots, Y_L$ 是两两不同的整数，而且所表示的围栏都是该小朋友可以看到的。\n\n小朋友已经按照他们可以看到的第一个围栏的编号从小到大的顺序排好了（这样最小的 $E$ 对应的小朋友排在第一个，最大的 $E$ 对应的小朋友排在最后一个）。\n\n注意可能有多于一个小朋友对应的 $E$ 是相同的。", "outputFormat": "仅输出一个数，表示最多可以让多少个小朋友高兴。\n", "hint": "**数据范围**\n对于 $100\\%$ 的数据，$10 \\le N \\le 10^4$，$1 \\le C \\le 5\\times 10^4$，$1 \\le E \\le N$。\n\n**样例说明**\n- 第一个样例是题目描述中的例子，所有的 $C=5$ 个小朋友都能高兴。\n- 第二个样例是一个不能使得所有 $C=7$ 个小朋友都高兴的例子。", "locale": "zh-CN"}}}
{"pid": "P3623", "type": "P", "difficulty": 4, "samples": [["5 7 2 \n1 3 0 \n4 5 1 \n3 2 0 \n5 3 1 \n4 3 0 \n1 2 1 \n4 2 1", "3 2 0 \n4 3 0 \n5 3 1 \n1 2 1 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "并查集", "APIO", "Special Judge", "凸完全单调性（wqs 二分）", "生成树"], "title": "[APIO2008] 免费道路", "background": null, "description": "新亚（New Asia）王国有 $N$ 个村庄，由 $M$ 条道路连接。其中一些道路是鹅卵石路，而其它道路是水泥路。保持道路免费运行需要一大笔费用，并且看上去王国不可能保持所有道路免费。为此亟待制定一个新的道路维护计划。\n\n国王已决定保持尽可能少的道路免费，但是两个不同的村庄之间都应该有且仅有一条免费道路的路径连接。同时，虽然水泥路更适合现代交通的需要，但国王也认为走在鹅卵石路上是一件有趣的事情。所以，国王决定保持刚好 $K$ 条鹅卵石路免费。\n\n举例来说，假定新亚王国的村庄和道路如图 3(a) 所示。如果国王希望保持两 条鹅卵石路免费，那么可以如图 3(b) 中那样保持道路 $(1, 2)$，$(2, 3)$，$(3, 4)$ 和 $(3, 5)$ 免费。该方案满足了国王的要求，因为：\n1. 两个村庄之间都有一条由免费道路组成的路径。\n2. 免费的道路已尽可能少。\n3. 方案中刚好有两条鹅卵石道路 $(2, 3)$ 和 $(3, 4)$。\n\n ![](https://cdn.luogu.com.cn/upload/pic/4393.png) \n\n图 3：(a) 新亚王国中村庄和道路的一个示例。实线标注的是水泥路，虚线标注的是鹅卵石路。(b) 一个保持两条鹅卵石路免费的维护方案。图中仅标出了免费道路。\n\n\n给定一个关于新亚王国村庄和道路的述以及国王决定保持免费的鹅卵石道路数目，写一个程序确定是否存在一个道路维护计划以满足国王的要求，如果存在则任意输出一个方案。", "inputFormat": "输入第一行包含三个由空格隔开的整数：\n\n$N$，村庄的数目 $(1 \\le N \\le 2 \\times 10^4)$；\n\n$M$，道路的数目 $(1 \\le M \\le 10^5)$；\n\n$K$，国王希望保持免费的鹅卵石道路数目 $(0 \\le K \\le N - 1)$。\n\n此后 $M$ 行述了新亚王国的道路，编号分别为 $1$ 到 $M$。第 $(i+1)$ 行述了第 $i$ 条道路的情况。用 3 个由空格隔开的整数述：\n\n$u_i$ 和 $v_i$，为第 $i$ 条道路连接的两个村庄的编号，村庄编号为 $1$ 到 $N$；\n\n$c_i$，表示第 $i$ 条道路的类型。$c_i = 0$ 表示第 $i$ 条道路是鹅卵石路，$c_i = 1$ 表示第 $i$ 条道路是水泥路。\n\n输入数据保证一对村庄之间至多有一条道路连接。", "outputFormat": "如果满足国王要求的道路维护方案不存在，你的程序应该在输出第一行打印 `no solution`。 否则，你的程序应该输出一个符合要求的道路维护方案，也就是保持免费的道路列表。按照输入中给定的那样输出免费的道路。如果有多种合法方案，你可以任意输出一种。", "hint": "### 数据范围\n\n对于 $100\\%$ 的数据。保证 $1 \\le N \\le 2 \\times 10^4$，$1 \\le M \\le 10^5$，$0 \\le K \\le N-1$。", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2008] Free Roads", "background": "", "description": "The kingdom of New Asia has $N$ villages connected by $M$ roads. Some roads are cobblestone, while others are cement. Keeping roads toll-free requires a large expense, and it seems impossible for the kingdom to keep all roads free. Therefore, a new road maintenance plan is urgently needed.\n\nThe king has decided to keep as few roads free as possible, but there must be exactly one path consisting of free roads between any two distinct villages. At the same time, although cement roads are better suited to modern traffic, the king also thinks that walking along cobblestone roads is interesting. So the king decides to keep exactly $K$ cobblestone roads free.\n\nFor example, suppose the villages and roads in New Asia are as shown in Figure 3(a). If the king wants to keep two cobblestone roads free, one possible plan is to keep roads $(1, 2)$, $(2, 3)$, $(3, 4)$, and $(3, 5)$ free, as shown in Figure 3(b). This plan satisfies the king’s requirements because:\n1. There is a path consisting of free roads between any two villages.\n2. The number of free roads is as small as possible.\n3. There are exactly two cobblestone roads, $(2, 3)$ and $(3, 4)$, in the plan.\n\n ![](https://cdn.luogu.com.cn/upload/pic/4393.png) \n\nFigure 3: (a) An example of villages and roads in New Asia. Solid lines denote cement roads, and dashed lines denote cobblestone roads. (b) A maintenance plan that keeps two cobblestone roads free. Only the free roads are shown.\n\nGiven a description of the villages and roads in New Asia and the number of cobblestone roads the king wants to keep free, write a program to determine whether there exists a road maintenance plan that satisfies the king’s requirements. If it exists, output any one such plan.", "inputFormat": "The first line of input contains three integers separated by spaces:\n\n$N$, the number of villages $(1 \\le N \\le 2 \\times 10^4)$;\n\n$M$, the number of roads $(1 \\le M \\le 10^5)$;\n\n$K$, the number of cobblestone roads the king wants to keep free $(0 \\le K \\le N - 1)$.\n\nThe following $M$ lines describe the roads in New Asia, numbered from $1$ to $M$. The $(i+1)$-th line describes the $i$-th road with 3 space-separated integers:\n\n$u_i$ and $v_i$, the indices of the two villages connected by the $i$-th road, where villages are numbered from $1$ to $N$;\n\n$c_i$, indicating the type of the $i$-th road. $c_i = 0$ means the $i$-th road is a cobblestone road, and $c_i = 1$ means the $i$-th road is a cement road.\n\nIt is guaranteed that between any pair of villages there is at most one connecting road.", "outputFormat": "If no road maintenance plan satisfies the king’s requirements, your program should print `no solution` on the first line. Otherwise, your program should output a valid road maintenance plan, i.e., the list of roads to remain free. Output the free roads in the same way as they are given in the input. If there are multiple valid plans, you may output any one of them.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\le N \\le 2 \\times 10^4$, $1 \\le M \\le 10^5$, $0 \\le K \\le N - 1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2008] 免费道路", "background": null, "description": "新亚（New Asia）王国有 $N$ 个村庄，由 $M$ 条道路连接。其中一些道路是鹅卵石路，而其它道路是水泥路。保持道路免费运行需要一大笔费用，并且看上去王国不可能保持所有道路免费。为此亟待制定一个新的道路维护计划。\n\n国王已决定保持尽可能少的道路免费，但是两个不同的村庄之间都应该有且仅有一条免费道路的路径连接。同时，虽然水泥路更适合现代交通的需要，但国王也认为走在鹅卵石路上是一件有趣的事情。所以，国王决定保持刚好 $K$ 条鹅卵石路免费。\n\n举例来说，假定新亚王国的村庄和道路如图 3(a) 所示。如果国王希望保持两 条鹅卵石路免费，那么可以如图 3(b) 中那样保持道路 $(1, 2)$，$(2, 3)$，$(3, 4)$ 和 $(3, 5)$ 免费。该方案满足了国王的要求，因为：\n1. 两个村庄之间都有一条由免费道路组成的路径。\n2. 免费的道路已尽可能少。\n3. 方案中刚好有两条鹅卵石道路 $(2, 3)$ 和 $(3, 4)$。\n\n ![](https://cdn.luogu.com.cn/upload/pic/4393.png) \n\n图 3：(a) 新亚王国中村庄和道路的一个示例。实线标注的是水泥路，虚线标注的是鹅卵石路。(b) 一个保持两条鹅卵石路免费的维护方案。图中仅标出了免费道路。\n\n\n给定一个关于新亚王国村庄和道路的述以及国王决定保持免费的鹅卵石道路数目，写一个程序确定是否存在一个道路维护计划以满足国王的要求，如果存在则任意输出一个方案。", "inputFormat": "输入第一行包含三个由空格隔开的整数：\n\n$N$，村庄的数目 $(1 \\le N \\le 2 \\times 10^4)$；\n\n$M$，道路的数目 $(1 \\le M \\le 10^5)$；\n\n$K$，国王希望保持免费的鹅卵石道路数目 $(0 \\le K \\le N - 1)$。\n\n此后 $M$ 行述了新亚王国的道路，编号分别为 $1$ 到 $M$。第 $(i+1)$ 行述了第 $i$ 条道路的情况。用 3 个由空格隔开的整数述：\n\n$u_i$ 和 $v_i$，为第 $i$ 条道路连接的两个村庄的编号，村庄编号为 $1$ 到 $N$；\n\n$c_i$，表示第 $i$ 条道路的类型。$c_i = 0$ 表示第 $i$ 条道路是鹅卵石路，$c_i = 1$ 表示第 $i$ 条道路是水泥路。\n\n输入数据保证一对村庄之间至多有一条道路连接。", "outputFormat": "如果满足国王要求的道路维护方案不存在，你的程序应该在输出第一行打印 `no solution`。 否则，你的程序应该输出一个符合要求的道路维护方案，也就是保持免费的道路列表。按照输入中给定的那样输出免费的道路。如果有多种合法方案，你可以任意输出一种。", "hint": "### 数据范围\n\n对于 $100\\%$ 的数据。保证 $1 \\le N \\le 2 \\times 10^4$，$1 \\le M \\le 10^5$，$0 \\le K \\le N-1$。", "locale": "zh-CN"}}}
{"pid": "P3624", "type": "P", "difficulty": 4, "samples": [["9 3 5 \nACANNCNNG", "ACAAACCCG"], ["5 4 10 \nACANN", "ACAGC "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "APIO", "前缀和"], "title": "[APIO2008] DNA", "background": "", "description": "分析如DNA序列这样的生命科学数据是计算机的一个有趣应用。从生物学的角度上说，DNA是一种由腺嘌呤、胞嘧啶、鸟嘌呤和胸腺嘧啶这四种核苷酸组成的链式结构。这四种核苷酸分别用大写字母A、C、G、T表示。这样，一条DNA单链可以被表示为一个只含以上四种字符的字符串。我们将这样的字符串称作一个DNA序列。\n\n有时生物学家可能无法确定一条DNA单链中的某些核苷酸。在这种情况下，字符N将被用来表示一个不确定的核苷酸。换句话说，N可以用来表示A、C、G、T中的任何一个字符。我们称包含一个或者多个N的DNA序列为未完成序列；反之，就称作完成序列。如果一个完成序列可以通过将一个未完成序列中的个N任意替换成A、C、G、T得到的话，就称完成序列适合这个未完成序列。举例来说，ACCCT适合ACNNT，但是AGGAT不适合。\n\n研究者们常按照如下方式排序四种核苷酸：A优先于C，C优先于G，G优先于T。如果一个DNA序列中的个核苷酸都与其右边的相同或者优先，就将其归类为范式-1。举例来说，AACCGT是范式-1，但是AACGTC不是。\n\n一般来说，一个DNA序列属于范式-j(j>1)，只要它属于范式-(j-1)或者是一个范式-(j-1)和一个范式-1的连接。举例来说，AACCC、ACACC和ACACA都是范式-3，但GCACAC和ACACACA不是。\n\n同样，研究者们按照字典序对DNA序列进行排序。按照这个定义，最小的属于范式-3的DNA序列是AAAAA，最大的是TTTTT。这里是另外一个例子，考虑未完成序列ACANNCNNG。那么前7个适合这个未完成序列的DNA序列是：\n```\nACAAACAAG\nACAAACACG\nACAAACAGG\nACAAACCAG\nACAAACCCG\nACAAACCGG\nACAAACCTG\n```", "inputFormat": "输入第一行包含三个由空格隔开的整数：M(1≤M≤50,000)，K(1≤K≤10)和 R(1≤R≤2×$10^{12}$)。\n\n第二行包含一个长度为 M 的字符串，表示未完成序列。\n\n保证适 合该未完成序列的范式-K 的总数不超过 4×10^18，因此该数可以用 C 和 C++中的 long long 类型或者 Pascal 中的 Int64 类型表示。同时，R 不会超过适合给定未完 成序列的范式-K 的总数。\n", "outputFormat": " 在第一行中输出第R个适合输入中的未完成序列的范式-K。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2008] DNA", "background": "# Description\n\nAnalyzing life science data such as DNA sequences is an interesting application of computers. Biologically, DNA is a chain structure composed of four nucleotides: adenine, cytosine, guanine, and thymine. These four nucleotides are denoted by uppercase letters A, C, G, and T. Thus, a single-stranded DNA can be represented as a string containing only these four characters. We call such a string a DNA sequence.\n\nSometimes biologists cannot determine certain nucleotides in a single-stranded DNA. In such cases, the character N is used to denote an undetermined nucleotide. In other words, N can represent any one of A, C, G, or T. We call a DNA sequence that contains one or more N an incomplete sequence; otherwise, it is called a complete sequence. If a complete sequence can be obtained by arbitrarily replacing each N in an incomplete sequence with A, C, G, or T, then the complete sequence is said to be compatible with this incomplete sequence. For example, ACCCT is compatible with ACNNT, but AGGAT is not.\n\nResearchers often order the four nucleotides as follows: A precedes C, C precedes G, and G precedes T. If in a DNA sequence every nucleotide is the same as or precedes the one to its right, we classify it as form-1. For example, AACCGT is form-1, but AACGTC is not.\n\nIn general, a DNA sequence belongs to form-j (j > 1) if and only if it belongs to form-(j−1), or it is a concatenation of a form-(j−1) and a form-1. For example, AACCC, ACACC, and ACACA are all form-3, but GCACAC and ACACACA are not.\n\nSimilarly, researchers sort DNA sequences in lexicographic order. Under this definition, the smallest DNA sequence belonging to form-3 is AAAAA, and the largest is TTTTT. Here is another example. Consider the incomplete sequence ACANNCNNG. Then the first 7 DNA sequences compatible with this incomplete sequence are:\n```\nACAAACAAG\nACAAACACG\nACAAACAGG\nACAAACCAG\nACAAACCCG\nACAAACCGG\nACAAACCTG\n```\n\n# Input Format\n\nThe first line contains three integers separated by spaces: M ($1 \\le M \\le 50{,}000$), K ($1 \\le K \\le 10$), and R ($1 \\le R \\le 2 \\times 10^{12}$).\n\nThe second line contains a string of length M, representing the incomplete sequence.\n\nIt is guaranteed that the total number of form-K sequences compatible with the given incomplete sequence does not exceed $4 \\times 10^{18}$; therefore, this number fits in type long long in C/C++ or Int64 in Pascal. Also, R will not exceed the total number of form-K sequences compatible with the given incomplete sequence.", "description": "Analyzing life science data such as DNA sequences is an interesting application of computers. Biologically, DNA is a chain structure composed of four nucleotides: adenine, cytosine, guanine, and thymine. These four nucleotides are denoted by uppercase letters A, C, G, and T. Thus, a single-stranded DNA can be represented as a string containing only these four characters. We call such a string a DNA sequence.\n\nSometimes biologists cannot determine certain nucleotides in a single-stranded DNA. In such cases, the character N is used to denote an undetermined nucleotide. In other words, N can represent any one of A, C, G, or T. We call a DNA sequence that contains one or more N an incomplete sequence; otherwise, it is called a complete sequence. If a complete sequence can be obtained by arbitrarily replacing each N in an incomplete sequence with A, C, G, or T, then the complete sequence is said to be compatible with this incomplete sequence. For example, ACCCT is compatible with ACNNT, but AGGAT is not.\n\nResearchers often order the four nucleotides as follows: A precedes C, C precedes G, and G precedes T. If in a DNA sequence every nucleotide is the same as or precedes the one to its right, we classify it as form-1. For example, AACCGT is form-1, but AACGTC is not.\n\nIn general, a DNA sequence belongs to form-j (j > 1) if and only if it belongs to form-(j−1), or it is a concatenation of a form-(j−1) and a form-1. For example, AACCC, ACACC, and ACACA are all form-3, but GCACAC and ACACACA are not.\n\nSimilarly, researchers sort DNA sequences in lexicographic order. Under this definition, the smallest DNA sequence belonging to form-3 is AAAAA, and the largest is TTTTT. Here is another example. Consider the incomplete sequence ACANNCNNG. Then the first 7 DNA sequences compatible with this incomplete sequence are:\n```\nACAAACAAG\nACAAACACG\nACAAACAGG\nACAAACCAG\nACAAACCCG\nACAAACCGG\nACAAACCTG\n```", "inputFormat": "The first line contains three integers separated by spaces: M ($1 \\le M \\le 50{,}000$), K ($1 \\le K \\le 10$), and R ($1 \\le R \\le 2 \\times 10^{12}$).\n\nThe second line contains a string of length M, representing the incomplete sequence.\n\nIt is guaranteed that the total number of form-K sequences compatible with the given incomplete sequence does not exceed $4 \\times 10^{18}$; therefore, this number fits in type long long in C/C++ or Int64 in Pascal. Also, R will not exceed the total number of form-K sequences compatible with the given incomplete sequence.\n\n# Description\n\n\n\n# Input Format", "outputFormat": "Output the R-th form-K sequence that is compatible with the given incomplete sequence on the first line.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2008] DNA", "background": "", "description": "分析如DNA序列这样的生命科学数据是计算机的一个有趣应用。从生物学的角度上说，DNA是一种由腺嘌呤、胞嘧啶、鸟嘌呤和胸腺嘧啶这四种核苷酸组成的链式结构。这四种核苷酸分别用大写字母A、C、G、T表示。这样，一条DNA单链可以被表示为一个只含以上四种字符的字符串。我们将这样的字符串称作一个DNA序列。\n\n有时生物学家可能无法确定一条DNA单链中的某些核苷酸。在这种情况下，字符N将被用来表示一个不确定的核苷酸。换句话说，N可以用来表示A、C、G、T中的任何一个字符。我们称包含一个或者多个N的DNA序列为未完成序列；反之，就称作完成序列。如果一个完成序列可以通过将一个未完成序列中的个N任意替换成A、C、G、T得到的话，就称完成序列适合这个未完成序列。举例来说，ACCCT适合ACNNT，但是AGGAT不适合。\n\n研究者们常按照如下方式排序四种核苷酸：A优先于C，C优先于G，G优先于T。如果一个DNA序列中的个核苷酸都与其右边的相同或者优先，就将其归类为范式-1。举例来说，AACCGT是范式-1，但是AACGTC不是。\n\n一般来说，一个DNA序列属于范式-j(j>1)，只要它属于范式-(j-1)或者是一个范式-(j-1)和一个范式-1的连接。举例来说，AACCC、ACACC和ACACA都是范式-3，但GCACAC和ACACACA不是。\n\n同样，研究者们按照字典序对DNA序列进行排序。按照这个定义，最小的属于范式-3的DNA序列是AAAAA，最大的是TTTTT。这里是另外一个例子，考虑未完成序列ACANNCNNG。那么前7个适合这个未完成序列的DNA序列是：\n```\nACAAACAAG\nACAAACACG\nACAAACAGG\nACAAACCAG\nACAAACCCG\nACAAACCGG\nACAAACCTG\n```", "inputFormat": "输入第一行包含三个由空格隔开的整数：M(1≤M≤50,000)，K(1≤K≤10)和 R(1≤R≤2×$10^{12}$)。\n\n第二行包含一个长度为 M 的字符串，表示未完成序列。\n\n保证适 合该未完成序列的范式-K 的总数不超过 4×10^18，因此该数可以用 C 和 C++中的 long long 类型或者 Pascal 中的 Int64 类型表示。同时，R 不会超过适合给定未完 成序列的范式-K 的总数。\n", "outputFormat": " 在第一行中输出第R个适合输入中的未完成序列的范式-K。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3625", "type": "P", "difficulty": 5, "samples": [["9 9 3\n1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 \n1 8 8 8 8 8 1 1 1 \n1 8 8 8 8 8 1 1 1 \n1 8 8 8 8 8 1 1 1 \n1 1 1 1 8 8 8 1 1 \n1 1 1 1 1 1 8 8 8 \n1 1 1 1 1 1 9 9 9 \n1 1 1 1 1 1 9 9 9 ", "208"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "2009", "APIO", "前缀和"], "title": "[APIO2009] 采油区域", "background": "", "description": "Siruseri 政府决定将石油资源丰富的 Navalur 省的土地拍卖给私人承包商以 建立油井。被拍卖的整块土地为一个矩形区域，被划分为 $M \\times N$ 个小块。 Siruseri 地质调查局有关于 Navalur 土地石油储量的估测数据。这些数据表示 为 $M \\times N$ 个正整数，即对每一小块土地石油储量的估计值。 为了避免出现垄断，政府规定每一个承包商只能承包一个由 $K\\times K$ 块相连的土地构成的正方形区域。 AoE 石油联合公司由三个承包商组成，他们想选择三块互不相交的 $K\\times K$ 的 区域使得总的收益最大。 例如，假设石油储量的估计值如下：\n\n```\n1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 \n1 8 8 8 8 8 1 1 1 \n1 8 8 8 8 8 1 1 1 \n1 8 8 8 8 8 1 1 1 \n1 1 1 1 8 8 8 1 1 \n1 1 1 1 1 1 8 8 8 \n1 1 1 1 1 1 9 9 9 \n1 1 1 1 1 1 9 9 9 \n```\n\n- 如果 $K = 2$，AoE 公司可以承包的区域的石油储量总和为 $100$；\n- 如果 $K = 3$，AoE 公司可以承包的区域的石油储量总和为 $208$。\n\nAoE 公司雇佣你来写一个程序，帮助计算出他们可以承包的区域的石油储量之和的最大值。\n", "inputFormat": "输入第一行包含三个正整数 $M, N, K$，其中 $M$ 和 $N$ 是矩形区域的行数和列数，$K$ 是每一个承包商承包的正方形的大小（边长的块数）。接下来 $M$ 行，每行有 $N$ 个正整数表示这一行每一小块土地的石油储量的估计值。\n", "outputFormat": "输出只包含一个正整数，表示 AoE 公司可以承包的区域的石油储量之和的最大值。\n", "hint": "数据保证 $K\\le M$ 且 $K\\le N$ 并且至少有三个 $K\\times K$ 的互不相交的正方形区域。\n\n其中 $30\\%$ 的输入数据，$M, N \\le 12$。所有的输入数据, $M, N\\le 1500$。每一小块土地的石油储量的估计值是非负整数且小于等于 $500$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2009] Oil Extraction Area", "background": "", "description": "The Siruseri government has decided to auction off land in the oil-rich province of Navalur to private contractors for building oil wells. The land to be auctioned is a rectangular area divided into $M \\times N$ blocks. The Siruseri Geological Survey has estimates of the oil reserves in Navalur. These are given as $M \\times N$ positive integers, i.e., the estimated yield for each block.\n\nTo avoid monopoly, the government stipulates that each contractor may lease only one square region consisting of $K \\times K$ adjacent blocks. The AoE Oil Consortium consists of three contractors. They want to choose three pairwise non-overlapping $K \\times K$ regions so that the total yield is maximized.\n\nFor example, suppose the estimated yields are as follows:\n\n```\n1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 \n1 8 8 8 8 8 1 1 1 \n1 8 8 8 8 8 1 1 1 \n1 8 8 8 8 8 1 1 1 \n1 1 1 1 8 8 8 1 1 \n1 1 1 1 1 1 8 8 8 \n1 1 1 1 1 1 9 9 9 \n1 1 1 1 1 1 9 9 9 \n```\n\n- If $K = 2$, the total yield the AoE company can get is $100$.\n- If $K = 3$, the total yield the AoE company can get is $208$.\n\nAoE hires you to write a program to compute the maximum possible sum of yields of the regions they can lease.", "inputFormat": "The first line contains three positive integers $M$, $N$, $K$, where $M$ and $N$ are the numbers of rows and columns of the rectangle, and $K$ is the side length (in blocks) of each contractor’s square region. The next $M$ lines each contain $N$ positive integers giving the estimated yield for each block in that row.", "outputFormat": "Output a single integer: the maximum possible total yield of the three leased regions.", "hint": "It is guaranteed that $K \\le M$ and $K \\le N$, and that there exist at least three pairwise disjoint $K \\times K$ square regions.\n\nFor $30\\%$ of the testdata, $M, N \\le 12$. For all testdata, $M, N \\le 1500$. The estimate for each block is a non-negative integer not exceeding $500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2009] 采油区域", "background": "", "description": "Siruseri 政府决定将石油资源丰富的 Navalur 省的土地拍卖给私人承包商以 建立油井。被拍卖的整块土地为一个矩形区域，被划分为 $M \\times N$ 个小块。 Siruseri 地质调查局有关于 Navalur 土地石油储量的估测数据。这些数据表示 为 $M \\times N$ 个正整数，即对每一小块土地石油储量的估计值。 为了避免出现垄断，政府规定每一个承包商只能承包一个由 $K\\times K$ 块相连的土地构成的正方形区域。 AoE 石油联合公司由三个承包商组成，他们想选择三块互不相交的 $K\\times K$ 的 区域使得总的收益最大。 例如，假设石油储量的估计值如下：\n\n```\n1 1 1 1 1 1 1 1 1 \n1 1 1 1 1 1 1 1 1 \n1 8 8 8 8 8 1 1 1 \n1 8 8 8 8 8 1 1 1 \n1 8 8 8 8 8 1 1 1 \n1 1 1 1 8 8 8 1 1 \n1 1 1 1 1 1 8 8 8 \n1 1 1 1 1 1 9 9 9 \n1 1 1 1 1 1 9 9 9 \n```\n\n- 如果 $K = 2$，AoE 公司可以承包的区域的石油储量总和为 $100$；\n- 如果 $K = 3$，AoE 公司可以承包的区域的石油储量总和为 $208$。\n\nAoE 公司雇佣你来写一个程序，帮助计算出他们可以承包的区域的石油储量之和的最大值。\n", "inputFormat": "输入第一行包含三个正整数 $M, N, K$，其中 $M$ 和 $N$ 是矩形区域的行数和列数，$K$ 是每一个承包商承包的正方形的大小（边长的块数）。接下来 $M$ 行，每行有 $N$ 个正整数表示这一行每一小块土地的石油储量的估计值。\n", "outputFormat": "输出只包含一个正整数，表示 AoE 公司可以承包的区域的石油储量之和的最大值。\n", "hint": "数据保证 $K\\le M$ 且 $K\\le N$ 并且至少有三个 $K\\times K$ 的互不相交的正方形区域。\n\n其中 $30\\%$ 的输入数据，$M, N \\le 12$。所有的输入数据, $M, N\\le 1500$。每一小块土地的石油储量的估计值是非负整数且小于等于 $500$。\n", "locale": "zh-CN"}}}
{"pid": "P3626", "type": "P", "difficulty": 5, "samples": [["4 \n4 9\n9 11 \n13 19 \n10 17", "2\n1 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2009", "线段树", "倍增", "颜色段均摊（珂朵莉树 ODT）", "APIO", "排序", "前缀和"], "title": "[APIO2009] 会议中心", "background": "", "description": "Siruseri 政府建造了一座新的会议中心。许多公司对租借会议中心的会堂很 感兴趣，他们希望能够在里面举行会议。\n\n对于一个客户而言，仅当在开会时能够独自占用整个会堂，他才会租借会堂。 会议中心的销售主管认为：最好的策略应该是将会堂租借给尽可能多的客户。\n\n显 然，有可能存在不止一种满足要求的策略。 例如下面的例子。总共有 4 个公司。他们对租借会堂发出了请求，并提出了 他们所需占用会堂的起止日期（如下表所示）。\n\n```cpp\n       开始日期 结束日期 \n 公司1    4        9 \n 公司2    9        11 \n 公司3    13       19 \n 公司4    10       17 \n```\n上例中，最多将会堂租借给两家公司。租借策略分别是租给公司 1 和公司 3， 或是公司 2 和公司 3，也可以是公司 1 和公司 4。注意会议中心一天最多租借给 一个公司，所以公司 1 和公司 2 不能同时租借会议中心，因为他们在第九天重合 了。\n\n销售主管为了公平起见，决定按照如下的程序来确定选择何种租借策略：首 先，将租借给客户数量最多的策略作为候选，将所有的公司按照他们发出请求的 顺序编号。对于候选策略，将策略中的每家公司的编号按升序排列。最后，选出 其中字典序最小1的候选策略作为最终的策略。\n\n例中，会堂最终将被租借给公司 1 和公司 3：3 个候选策略是 {(1,3),(2,3),(1,4)}。而在字典序中(1,3)<(1,4)<(2,3)。 你的任务是帮助销售主管确定应该将会堂租借给哪些公司。\n", "inputFormat": "输入的第一行有一个整数 N，表示发出租借会堂申请的公司的个数。第 2 到 第 N+1 行每行有 2 个整数。第 i+1 行的整数表示第 i 家公司申请租借的起始和终 止日期。对于每个公司的申请，起始日期为不小于 1 的整数，终止日期为不大于 10^9 的整数。\n", "outputFormat": "输出的第一行应有一个整数 M，表示最多可以租借给多少家公司。第二行应列出 M 个数，表示最终将会堂租借给哪些公司。\n", "hint": "对于 50%的输入，N≤3000。\n\n在所有输入中，N≤200000。\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2009] Conference Center", "background": "", "description": "The Siruseri government has built a new conference center. Many companies are interested in renting its hall and wish to hold meetings there.\n\nA client will rent the hall only if they can exclusively occupy the entire hall during their meeting. The sales manager believes the best strategy is to rent the hall to as many clients as possible.\n\nObviously, there may be more than one valid strategy. For example, consider the following case with 4 companies. They have requested to rent the hall with given start and end dates (as shown in the table below).\n\n```cpp\n       开始日期 结束日期 \n 公司1    4        9 \n 公司2    9        11 \n 公司3    13       19 \n 公司4    10       17 \n```\nIn this example, the hall can be rented to at most two companies. Possible strategies include renting to companies 1 and 3, companies 2 and 3, or companies 1 and 4. Note that the conference center can be rented to at most one company per day, so companies 1 and 2 cannot both rent the hall because they overlap on day 9.\n\nTo be fair, the sales manager decides to determine the final strategy as follows: first, consider all strategies that rent to the maximum number of clients; number all companies according to the order of their requests. For each candidate strategy, sort the selected company indices in ascending order. Finally, choose the lexicographically smallest candidate strategy as the final strategy.\n\nIn the example, the hall will be rented to companies 1 and 3: the 3 candidate strategies are {(1, 3), (2, 3), (1, 4)}, and in lexicographic order, (1, 3) < (1, 4) < (2, 3). Your task is to help the sales manager determine which companies should be granted the rental.", "inputFormat": "The first line contains an integer $N$, the number of companies that requested to rent the hall. Each of the next $N$ lines contains 2 integers. The integers on line $i + 1$ give the requested start and end dates for company $i$. For each request, the start date is an integer not less than 1, and the end date is an integer not greater than $10^9$.", "outputFormat": "The first line should contain an integer $M$, the maximum number of companies that can be served. The second line should list $M$ integers, indicating which companies will be granted the rental (in ascending order, forming the final strategy).", "hint": "- For 50% of the input, $N \\le 3000$.\n- For all inputs, $N \\le 200000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2009] 会议中心", "background": "", "description": "Siruseri 政府建造了一座新的会议中心。许多公司对租借会议中心的会堂很 感兴趣，他们希望能够在里面举行会议。\n\n对于一个客户而言，仅当在开会时能够独自占用整个会堂，他才会租借会堂。 会议中心的销售主管认为：最好的策略应该是将会堂租借给尽可能多的客户。\n\n显 然，有可能存在不止一种满足要求的策略。 例如下面的例子。总共有 4 个公司。他们对租借会堂发出了请求，并提出了 他们所需占用会堂的起止日期（如下表所示）。\n\n```cpp\n       开始日期 结束日期 \n 公司1    4        9 \n 公司2    9        11 \n 公司3    13       19 \n 公司4    10       17 \n```\n上例中，最多将会堂租借给两家公司。租借策略分别是租给公司 1 和公司 3， 或是公司 2 和公司 3，也可以是公司 1 和公司 4。注意会议中心一天最多租借给 一个公司，所以公司 1 和公司 2 不能同时租借会议中心，因为他们在第九天重合 了。\n\n销售主管为了公平起见，决定按照如下的程序来确定选择何种租借策略：首 先，将租借给客户数量最多的策略作为候选，将所有的公司按照他们发出请求的 顺序编号。对于候选策略，将策略中的每家公司的编号按升序排列。最后，选出 其中字典序最小1的候选策略作为最终的策略。\n\n例中，会堂最终将被租借给公司 1 和公司 3：3 个候选策略是 {(1,3),(2,3),(1,4)}。而在字典序中(1,3)<(1,4)<(2,3)。 你的任务是帮助销售主管确定应该将会堂租借给哪些公司。\n", "inputFormat": "输入的第一行有一个整数 N，表示发出租借会堂申请的公司的个数。第 2 到 第 N+1 行每行有 2 个整数。第 i+1 行的整数表示第 i 家公司申请租借的起始和终 止日期。对于每个公司的申请，起始日期为不小于 1 的整数，终止日期为不大于 10^9 的整数。\n", "outputFormat": "输出的第一行应有一个整数 M，表示最多可以租借给多少家公司。第二行应列出 M 个数，表示最终将会堂租借给哪些公司。\n", "hint": "对于 50%的输入，N≤3000。\n\n在所有输入中，N≤200000。\n", "locale": "zh-CN"}}}
{"pid": "P3627", "type": "P", "difficulty": 4, "samples": [["6 7 \n1 2 \n2 3 \n3 5 \n2 4 \n4 1 \n2 6 \n6 5 \n10 \n12 \n8 \n16 \n1 \n5 \n1 4 \n4 3 5 6", "47"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "APIO", "强连通分量", "栈"], "title": "[APIO2009] 抢掠计划", "background": "", "description": "Siruseri 城中的道路都是单向的。不同的道路由路口连接。按照法律的规定，在每个路口都设立了一个 Siruseri 银行的 ATM 取款机。令人奇怪的是，Siruseri 的酒吧也都设在路口，虽然并不是每个路口都设有酒吧。  \n\nBanditji 计划实施 Siruseri 有史以来最惊天动地的 ATM 抢劫。他将从市中心出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆祝他的胜利。  \n\n使用高超的黑客技术，他获知了每个 ATM 机中可以掠取的现金数额。他希望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可以经过同一路口或道路任意多次。但只要他抢劫过某个 ATM 机后，该 ATM 机里面就不会再有钱了。 例如，假设该城中有 $6$ 个路口，道路的连接情况如下图所示：  \n\n![](https://cdn.luogu.com.cn/upload/pic/4396.png)  \n\n市中心在路口 $1$，由一个入口符号 → 来标识，那些有酒吧的路口用双圈来表示。每个 ATM 机中可取的钱数标在了路口的上方。在这个例子中，Banditji 能抢劫的现金总数为 $47$，实施的抢劫路线是：$1-2-4-1-2-3-5$。", "inputFormat": "第一行包含两个整数 $N,M$。$N$ 表示路口的个数，$M$ 表示道路条数。  \n\n接下来 $M$ 行，每行两个整数，这两个整数都在 $1$ 到 $N$ 之间，第 $i+1$ 行的两个整数表示第 $i$ 条道路的起点和终点的路口编号。  \n\n接下来 $N$ 行，每行一个整数，按顺序表示每个路口处的 ATM 机中的钱数 $a_i$。  \n\n接下来一行包含两个整数 $S,P$，$S$ 表示市中心的编号，也就是出发的路口。$P$ 表示酒吧数目。  \n\n接下来的一行中有 $P$ 个整数，表示 $P$ 个有酒吧的路口的编号。", "outputFormat": "输出一个整数，表示 Banditji 从市中心开始到某个酒吧结束所能抢劫的最多的现金总数。", "hint": "对于 $50\\%$ 的数据，保证 $N, M \\le 3000$。  \n\n对于 $100\\%$ 的数据，保证 $N, M \\le 5\\times 10^5$，$0 \\le a_i \\le 4000$。保证可以从市中心沿着 Siruseri 的单向的道路到达其中的至少一个酒吧。", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2009] Robbery Plan", "background": "", "description": "All roads in the city of Siruseri are one-way. Different roads are connected by intersections. By law, a Siruseri Bank ATM is installed at every intersection. Curiously, Siruseri’s bars are also located at intersections, although not every intersection has a bar.\n\nBanditji is planning the most spectacular ATM heist in the history of Siruseri. He will start from the city center, travel along one-way roads, rob all ATMs he passes, and finally celebrate his success at a bar.\n\nUsing advanced hacking skills, he has learned the amount of cash that can be looted from each ATM. He wants you to help him calculate the maximum total cash he can rob, starting from the city center and ending at some bar. He may pass through the same intersection or road any number of times. However, once he has robbed an ATM, that ATM will no longer have any money. For example, suppose the city has $6$ intersections, and the road connections are as shown below:\n\n![](https://cdn.luogu.com.cn/upload/pic/4396.png)\n\nThe city center is at intersection $1$, marked by an entry arrow symbol →, and intersections with bars are shown with double circles. The amount of money available at each ATM is labeled above its intersection. In this example, the maximum total cash Banditji can rob is $47$, and one optimal robbery route is: $1-2-4-1-2-3-5$.", "inputFormat": "The first line contains two integers $N,M$. Here $N$ is the number of intersections, and $M$ is the number of roads.\n\nThe next $M$ lines each contain two integers, both between $1$ and $N$. On the $(i+1)$-th line, the two integers denote the starting and ending intersection indices of the $i$-th road.\n\nThe next $N$ lines each contain one integer, in order, representing the amount of money $a_i$ available at the ATM on each intersection.\n\nThe next line contains two integers $S,P$. Here $S$ is the index of the city center, i.e., the starting intersection. $P$ is the number of bars.\n\nThe next line contains $P$ integers, denoting the indices of the $P$ intersections that have bars.", "outputFormat": "Output a single integer, the maximum total cash Banditji can rob when starting from the city center and ending at some bar.", "hint": "For $50\\%$ of the testdata, it is guaranteed that $N, M \\le 3000$.\n\nFor $100\\%$ of the testdata, it is guaranteed that $N, M \\le 5\\times 10^5$, $0 \\le a_i \\le 4000$. It is guaranteed that from the city center, along Siruseri’s one-way roads, at least one bar is reachable.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2009] 抢掠计划", "background": "", "description": "Siruseri 城中的道路都是单向的。不同的道路由路口连接。按照法律的规定，在每个路口都设立了一个 Siruseri 银行的 ATM 取款机。令人奇怪的是，Siruseri 的酒吧也都设在路口，虽然并不是每个路口都设有酒吧。  \n\nBanditji 计划实施 Siruseri 有史以来最惊天动地的 ATM 抢劫。他将从市中心出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆祝他的胜利。  \n\n使用高超的黑客技术，他获知了每个 ATM 机中可以掠取的现金数额。他希望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可以经过同一路口或道路任意多次。但只要他抢劫过某个 ATM 机后，该 ATM 机里面就不会再有钱了。 例如，假设该城中有 $6$ 个路口，道路的连接情况如下图所示：  \n\n![](https://cdn.luogu.com.cn/upload/pic/4396.png)  \n\n市中心在路口 $1$，由一个入口符号 → 来标识，那些有酒吧的路口用双圈来表示。每个 ATM 机中可取的钱数标在了路口的上方。在这个例子中，Banditji 能抢劫的现金总数为 $47$，实施的抢劫路线是：$1-2-4-1-2-3-5$。", "inputFormat": "第一行包含两个整数 $N,M$。$N$ 表示路口的个数，$M$ 表示道路条数。  \n\n接下来 $M$ 行，每行两个整数，这两个整数都在 $1$ 到 $N$ 之间，第 $i+1$ 行的两个整数表示第 $i$ 条道路的起点和终点的路口编号。  \n\n接下来 $N$ 行，每行一个整数，按顺序表示每个路口处的 ATM 机中的钱数 $a_i$。  \n\n接下来一行包含两个整数 $S,P$，$S$ 表示市中心的编号，也就是出发的路口。$P$ 表示酒吧数目。  \n\n接下来的一行中有 $P$ 个整数，表示 $P$ 个有酒吧的路口的编号。", "outputFormat": "输出一个整数，表示 Banditji 从市中心开始到某个酒吧结束所能抢劫的最多的现金总数。", "hint": "对于 $50\\%$ 的数据，保证 $N, M \\le 3000$。  \n\n对于 $100\\%$ 的数据，保证 $N, M \\le 5\\times 10^5$，$0 \\le a_i \\le 4000$。保证可以从市中心沿着 Siruseri 的单向的道路到达其中的至少一个酒吧。", "locale": "zh-CN"}}}
{"pid": "P3628", "type": "P", "difficulty": 6, "samples": [["4 \n-1 10 -20 \n2 2 3 4 ", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2010", "单调队列", "APIO", "斜率优化", "前缀和", "队列"], "title": "[APIO2010] 特别行动队", "background": null, "description": "你有一支由 $n$ 名预备役士兵组成的部队，士兵从 $1$ 到 $n$ 编号，你要将他们拆分成若干特别行动队调入战场。出于默契的考虑，同一支特别行动队中队员的编号**应该连续**，即为形如 $(i, i + 1, \\cdots,i + k)$ 的序列。所有的队员都应该属于且仅属于一支特别行动队。\n\n编号为 $i$ 的士兵的初始战斗力为 $x_i$，一支特别行动队的初始战斗力 $X$ 为队内士兵初始战斗力之和，即 $X = x_i + x_{i+1} + \\cdots + x_{i+k}$。\n\n通过长期的观察，你总结出对于一支初始战斗力为 $X$ 的特别行动队，其修正战斗力 $X'= aX^2+bX+c$，其中 $a,b,c$ 是已知的系数（$a < 0$）。 作为部队统帅，现在你要为这支部队进行编队，使得所有特别行动队的修正战斗力之和最大。试求出这个最大和。", "inputFormat": "输入的第一行是一个整数 $n$，代表士兵的人数。\n\n输入的第二行有三个用空格隔开的整数，依次代表 $a,b,c$，即修正战斗力的系数。\n\n输入的第三行有 $n$ 个用空格隔开的整数，第 $i$ 个整数代表编号为 $i$ 的士兵的初始战斗力 $x_i$。", "outputFormat": "输出一行一个整数，代表最大的所有特别行动队战斗力之和。", "hint": "#### 样例输入输出 $1$ 解释\n\n你有 $4$ 名士兵，$x_1 = 2,~x_2 = 2,~x_3 = 3,~x_4=4$。修正战斗力公式中的参数为  $a = -1,~b = 10,~c = -20$。\n\n此时，最佳方案是将士兵组成 $3$ 个特别行动队：第一队包含士兵 $1$ 和士兵 $2$，第二队包含士兵 $3$，第三队包含士兵 $4$。特别行动队的初始战斗力分别为 $4,~3,~4$，修正后的战斗力分别为 $-4^2 + 10 \\times 4 -20 = 4$，$-3^2 + 10 \\times 3 - 20 = 1$，$-4^2 + 10 \\times 4 -20 = 4$。修正后的战斗力和为 $4 + 1 + 4 = 9$，没有其它方案能使修正后的战斗力和更大。\n\n\n#### 数据范围与约定\n\n对于 $20\\%$ 的数据，$n \\leq 10^3$。\n\n对于 $50\\%$ 的数据，$n \\leq 10^4$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^6$，$-5 \\leq a \\leq -1$，$-10^7 \\leq b \\leq 10^7$，$-10^7 \\leq c \\leq 10^7$，$1 \\leq x_i \\leq 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2010] Commando", "background": "", "description": "You command a unit consisting of $n$ reserve soldiers, numbered from $1$ to $n$. You need to split them into several commando teams to be deployed to the battlefield. For teamwork reasons, the indices of the members within the same commando team must be consecutive, i.e., a sequence of the form $(i, i + 1, \\cdots,i + k)$. Every soldier must belong to exactly one commando team.\n\nThe initial combat power of soldier $i$ is $x_i$. The initial combat power $X$ of a commando team is the sum of the initial combat power of its members, i.e., $X = x_i + x_{i+1} + \\cdots + x_{i+k}$.\n\nFrom long-term observation, you have summarized that for a commando team with initial combat power $X$, its adjusted combat power is $X' = aX^2 + bX + c$, where $a, b, c$ are known coefficients ($a < 0$). As the commander, you must form the teams so that the sum of adjusted combat power over all commando teams is maximized. Find this maximum sum.", "inputFormat": "The first line contains an integer $n$, the number of soldiers.\n\nThe second line contains three space-separated integers, $a, b, c$, which are the coefficients of the adjusted combat power formula.\n\nThe third line contains $n$ space-separated integers, where the $i$-th integer is the initial combat power $x_i$ of soldier $i$.", "outputFormat": "Output a single integer on one line, the maximum possible sum of adjusted combat power over all commando teams.", "hint": "#### Explanation of Sample Input/Output 1\n\nYou have $4$ soldiers, $x_1 = 2,~x_2 = 2,~x_3 = 3,~x_4 = 4$. The parameters in the adjusted combat power formula are $a = -1,~b = 10,~c = -20$.\n\nThe optimal plan is to form $3$ commando teams: the first team contains soldiers $1$ and $2$, the second team contains soldier $3$, and the third team contains soldier $4$. The initial combat powers of the teams are $4,~3,~4$, and the adjusted combat powers are $-4^2 + 10 \\times 4 - 20 = 4$, $-3^2 + 10 \\times 3 - 20 = 1$, $-4^2 + 10 \\times 4 - 20 = 4$. The sum of adjusted combat powers is $4 + 1 + 4 = 9$, and no other plan yields a larger sum.\n\n#### Constraints\n\nFor $20\\%$ of the testdata, $n \\leq 10^3$.\n\nFor $50\\%$ of the testdata, $n \\leq 10^4$.\n\nFor $100\\%$ of the testdata, $1 \\leq n \\leq 10^6$, $-5 \\leq a \\leq -1$, $-10^7 \\leq b \\leq 10^7$, $-10^7 \\leq c \\leq 10^7$, $1 \\leq x_i \\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2010] 特别行动队", "background": null, "description": "你有一支由 $n$ 名预备役士兵组成的部队，士兵从 $1$ 到 $n$ 编号，你要将他们拆分成若干特别行动队调入战场。出于默契的考虑，同一支特别行动队中队员的编号**应该连续**，即为形如 $(i, i + 1, \\cdots,i + k)$ 的序列。所有的队员都应该属于且仅属于一支特别行动队。\n\n编号为 $i$ 的士兵的初始战斗力为 $x_i$，一支特别行动队的初始战斗力 $X$ 为队内士兵初始战斗力之和，即 $X = x_i + x_{i+1} + \\cdots + x_{i+k}$。\n\n通过长期的观察，你总结出对于一支初始战斗力为 $X$ 的特别行动队，其修正战斗力 $X'= aX^2+bX+c$，其中 $a,b,c$ 是已知的系数（$a < 0$）。 作为部队统帅，现在你要为这支部队进行编队，使得所有特别行动队的修正战斗力之和最大。试求出这个最大和。", "inputFormat": "输入的第一行是一个整数 $n$，代表士兵的人数。\n\n输入的第二行有三个用空格隔开的整数，依次代表 $a,b,c$，即修正战斗力的系数。\n\n输入的第三行有 $n$ 个用空格隔开的整数，第 $i$ 个整数代表编号为 $i$ 的士兵的初始战斗力 $x_i$。", "outputFormat": "输出一行一个整数，代表最大的所有特别行动队战斗力之和。", "hint": "#### 样例输入输出 $1$ 解释\n\n你有 $4$ 名士兵，$x_1 = 2,~x_2 = 2,~x_3 = 3,~x_4=4$。修正战斗力公式中的参数为  $a = -1,~b = 10,~c = -20$。\n\n此时，最佳方案是将士兵组成 $3$ 个特别行动队：第一队包含士兵 $1$ 和士兵 $2$，第二队包含士兵 $3$，第三队包含士兵 $4$。特别行动队的初始战斗力分别为 $4,~3,~4$，修正后的战斗力分别为 $-4^2 + 10 \\times 4 -20 = 4$，$-3^2 + 10 \\times 3 - 20 = 1$，$-4^2 + 10 \\times 4 -20 = 4$。修正后的战斗力和为 $4 + 1 + 4 = 9$，没有其它方案能使修正后的战斗力和更大。\n\n\n#### 数据范围与约定\n\n对于 $20\\%$ 的数据，$n \\leq 10^3$。\n\n对于 $50\\%$ 的数据，$n \\leq 10^4$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^6$，$-5 \\leq a \\leq -1$，$-10^7 \\leq b \\leq 10^7$，$-10^7 \\leq c \\leq 10^7$，$1 \\leq x_i \\leq 100$。", "locale": "zh-CN"}}}
{"pid": "P3629", "type": "P", "difficulty": 6, "samples": [["8 1 \n1 2 \n3 1 \n3 4 \n5 3 \n7 5 \n8 5 \n5 6 ", "11"], ["8 2 \n1 2 \n3 1 \n3 4 \n5 3 \n7 5 \n8 5 \n5 6 ", "10"], ["5 2 \n1 2 \n2 3 \n3 4 \n4 5 ", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2010", "APIO", "深度优先搜索 DFS", "树形 DP", "树的直径"], "title": "[APIO2010] 巡逻", "background": "", "description": "在一个地区中有 $n$ 个村庄，编号为 $1, 2, \\dots, n$。有 $n-1$ 条道路连接着这些村庄，每条道路刚好连接两个村庄，从任何一个村庄，都可以通过这些道路到达其他任何一个村庄。每条道路的长度均为 $1$ 个单位。为保证该地区的安全，巡警车每天要到所有的道路上巡逻。警察局设在编号为 $1$ 的村庄里，每天巡警车总是从警察局出发，最终又回到警察局。下图表示一个有 $8$ 个村庄的地区，其中村庄用圆表示（其中村庄 $1$ 用黑色的圆表示），道路是连接这些圆的线段。为了遍历所有的道路，巡警车需要走的距离为 $14$ 个单位，每条道路都需要经过两次。\n\n![](https://cdn.luogu.com.cn/upload/pic/4401.png)\n\n为了减少总的巡逻距离，该地区准备在这些村庄之间建立 $K$ 条新的道路，每条新道路可以连接任意两个村庄。两条新道路可以在同一个村庄会合或结束，如下面的图例 (c)。一条新道路甚至可以是一个环，即其两端连接到同一个村庄。由于资金有限，$K$ 只能是 $1$ 或 $2$。同时，为了不浪费资金，每天巡警车必须经过新建的道路正好一次。下图给出了一些建立新道路的例子：\n\n![](https://cdn.luogu.com.cn/upload/pic/4402.png) \n\n在 (a) 中，新建了一条道路，总的距离是 $11$。在 (b) 中，新建了两条道路，总的巡逻距离是 $10$。在 (c) 中，新建了两条道路，但由于巡警车要经过每条新道路正好一次，总的距离变为了 $15$。试编写一个程序，读取村庄间道路的信息和需要新建的道路数，计算出最佳的新建道路的方案使得总的巡逻距离最小，并输出这个最小的巡逻距离。\n\n", "inputFormat": "第一行包含两个整数 $n, K(1 ≤ K ≤ 2)$。接下来 $n-1$ 行，每行两个整数 $a,b$，表示村庄 $a$ 与 $b$ 之间有一条道路 $(1 ≤ a, b ≤ n)$。\n", "outputFormat": "输出一个整数，表示新建了 $K$ 条道路后能达到的最小巡逻距离。\n", "hint": "- $10\\%$ 的数据中，$1≤n≤1000,K=1$；\n- $30\\%$ 的数据中，$K=1$；\n- $80\\%$ 的数据中，每个村庄相邻的村庄数不超过 $25$；\n- $90\\%$ 的数据中，每个村庄相邻的村庄数不超过 $150$；\n- $100\\%$ 的数据中，$3≤n≤10^5,1≤K≤2$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2010] Patrol", "background": "", "description": "In a region, there are $n$ villages, numbered $1, 2, \\dots, n$. There are $n-1$ roads connecting these villages. Each road connects exactly two villages, and from any village you can reach any other village via these roads. Each road has length $1$ unit. To ensure safety, a patrol car must patrol all roads every day. The police station is located in village $1$. Every day the patrol car always starts from the police station and finally returns to the police station. The figure below shows a region with $8$ villages, where villages are represented by circles (village $1$ is the black circle) and roads are the line segments connecting the circles. To traverse all the roads, the patrol car needs to travel a distance of $14$ units, and each road must be traversed twice.\n\n![](https://cdn.luogu.com.cn/upload/pic/4401.png)\n\nTo reduce the total patrol distance, the region plans to build $K$ new roads between the villages, and each new road can connect any two villages. Two new roads may meet at or end at the same village, as in figure (c) below. A new road can even be a loop, i.e., both ends connect to the same village. Due to limited budget, $K$ can only be $1$ or $2$. Meanwhile, to avoid wasting funds, every day the patrol car must traverse each newly built road exactly once. The following are some examples:\n\n![](https://cdn.luogu.com.cn/upload/pic/4402.png)\n\nIn (a), one new road is built, and the total distance is $11$. In (b), two new roads are built, and the total patrol distance is $10$. In (c), two new roads are built, but since the patrol car must traverse each new road exactly once, the total distance becomes $15$. Write a program that reads the information about the roads between villages and the number of roads to be built, computes the best plan for adding new roads to minimize the total patrol distance, and outputs this minimum patrol distance.", "inputFormat": "The first line contains two integers $n, K(1 ≤ K ≤ 2)$. Then follow $n-1$ lines, each with two integers $a,b$, indicating that there is a road between villages $a$ and $b$ $(1 ≤ a, b ≤ n)$.", "outputFormat": "Output a single integer, the minimum total patrol distance after adding $K$ new roads.", "hint": "- In $10\\%$ of the testdata, $1≤n≤1000,K=1$.\n- In $30\\%$ of the testdata, $K=1$.\n- In $80\\%$ of the testdata, the number of adjacent villages for each village does not exceed $25$.\n- In $90\\%$ of the testdata, the number of adjacent villages for each village does not exceed $150$.\n- In $100\\%$ of the testdata, $3≤n≤10^5,1≤K≤2$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2010] 巡逻", "background": "", "description": "在一个地区中有 $n$ 个村庄，编号为 $1, 2, \\dots, n$。有 $n-1$ 条道路连接着这些村庄，每条道路刚好连接两个村庄，从任何一个村庄，都可以通过这些道路到达其他任何一个村庄。每条道路的长度均为 $1$ 个单位。为保证该地区的安全，巡警车每天要到所有的道路上巡逻。警察局设在编号为 $1$ 的村庄里，每天巡警车总是从警察局出发，最终又回到警察局。下图表示一个有 $8$ 个村庄的地区，其中村庄用圆表示（其中村庄 $1$ 用黑色的圆表示），道路是连接这些圆的线段。为了遍历所有的道路，巡警车需要走的距离为 $14$ 个单位，每条道路都需要经过两次。\n\n![](https://cdn.luogu.com.cn/upload/pic/4401.png)\n\n为了减少总的巡逻距离，该地区准备在这些村庄之间建立 $K$ 条新的道路，每条新道路可以连接任意两个村庄。两条新道路可以在同一个村庄会合或结束，如下面的图例 (c)。一条新道路甚至可以是一个环，即其两端连接到同一个村庄。由于资金有限，$K$ 只能是 $1$ 或 $2$。同时，为了不浪费资金，每天巡警车必须经过新建的道路正好一次。下图给出了一些建立新道路的例子：\n\n![](https://cdn.luogu.com.cn/upload/pic/4402.png) \n\n在 (a) 中，新建了一条道路，总的距离是 $11$。在 (b) 中，新建了两条道路，总的巡逻距离是 $10$。在 (c) 中，新建了两条道路，但由于巡警车要经过每条新道路正好一次，总的距离变为了 $15$。试编写一个程序，读取村庄间道路的信息和需要新建的道路数，计算出最佳的新建道路的方案使得总的巡逻距离最小，并输出这个最小的巡逻距离。\n\n", "inputFormat": "第一行包含两个整数 $n, K(1 ≤ K ≤ 2)$。接下来 $n-1$ 行，每行两个整数 $a,b$，表示村庄 $a$ 与 $b$ 之间有一条道路 $(1 ≤ a, b ≤ n)$。\n", "outputFormat": "输出一个整数，表示新建了 $K$ 条道路后能达到的最小巡逻距离。\n", "hint": "- $10\\%$ 的数据中，$1≤n≤1000,K=1$；\n- $30\\%$ 的数据中，$K=1$；\n- $80\\%$ 的数据中，每个村庄相邻的村庄数不超过 $25$；\n- $90\\%$ 的数据中，每个村庄相邻的村庄数不超过 $150$；\n- $100\\%$ 的数据中，$3≤n≤10^5,1≤K≤2$。\n", "locale": "zh-CN"}}}
{"pid": "P3630", "type": "P", "difficulty": 6, "samples": [["4\n0 2 \n4 4 \n0 0 \n2 0", "3.500 "]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "APIO", "Special Judge", "枚举", "排序"], "title": "[APIO2010] 信号覆盖", "background": "", "description": "一家电信公司正在北京城搭建一个 GSM 网络。城市里共有 n 个房子需要被 信号覆盖。由于经费的限制，电信公司只能安装一个天线。 这里将每个房子用一个点坐标来表示。为了简化天线的放置，电信公司将会 选择其中的 3 个房子作一个外接圆，然后将天线放在圆的中心，所有位于这个圆 内或者圆的边界上的房子都将被天线的信号所覆盖。 电信公司将会随机选择城市中的 3 个房子来搭建天线，他们想知道在所有可 能放置天线的方案中平均会有多少个房子被信号覆盖。 例如，假设共有 4 个房子 A, B, C, D，它们的位置如下图：\n\n  ![](https://cdn.luogu.com.cn/upload/pic/4405.png) \n\n如果我们选择ABC或者BCD三个点搭建的外接圆，所有的房子都会被覆盖。 如果我们选择 ACD 或者 ABD，剩下的房子将不会在天线的信号覆盖范围内。因 此平均有(4 + 4 + 3 + 3) / 4 = 3.50 个房子被信号覆盖。 给定所有房子的位置，你的任务是计算平均有多少个房子被信号覆盖。假定 每一个房子都有一个二维的整数坐标，并且保证任何三个房子都不在同一条直线 上，任何四个房子都不在同一个圆上。\n", "inputFormat": "输入第一行包含一个正整数 n, 表示房子的总数。接下来有 n 行，分别表示 每一个房子的位置。对于 i = 1, 2, .., n, 第 i 个房子的坐标用一对整数 xi和 yi来表 示，中间用空格隔开。\n", "outputFormat": "输出文件包含一个实数，表示平均有多少个房子被信号所覆盖，需保证输出 结果与精确值的绝对误差不超过 0.01。\n", "hint": "【样例说明】\n\n3.5, 3.50, 3.500, … 中的任何一个输出均为正确。此外，3.49, 3.51, 3.499999，…等也都是可被接受的输出。\n\n【数据范围】\n\n100%的数据保证，对于 i = 1, 2, .., n, 第 i 个房子的坐标(xi, yi)为整数且 –1,000,000 ≤ xi, yi ≤ 1,000,000. 任何三个房子不在同一条直线上，任何四个房子不 在同一个圆上；\n\n40%的数据，n ≤ 100；\n\n70%的数据，n ≤ 500；\n\n100%的数据，3 ≤ n ≤ 1,500。\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2010] Signal Coverage", "background": "", "description": "A telecom company is building a GSM network in Beijing. There are $n$ houses in the city that need signal coverage. Due to budget constraints, the company can install only one antenna. Each house is represented by a point in the plane.\n\nTo simplify placement, the company will choose 3 houses and take their circumcircle, then place the antenna at the center of that circle. Every house that lies on or inside this circle will be covered by the antenna.\n\nThe company will choose 3 houses uniformly at random from all houses in the city. They want to know, over all possible antenna placements, the average number of houses that will be covered.\n\nFor example, suppose there are 4 houses $A, B, C, D$, positioned as in the figure:\n\n![](https://cdn.luogu.com.cn/upload/pic/4405.png)\n\nIf we choose the circumcircle of $A, B, C$ or $B, C, D$, then all houses are covered. If we choose $A, C, D$ or $A, B, D$, the remaining house will not be covered. Therefore, the average is $(4 + 4 + 3 + 3) / 4 = 3.50$.\n\nGiven the positions of all houses, your task is to compute the average number of houses covered. Assume every house has integer 2D coordinates, no three houses are collinear, and no four houses are cocircular.", "inputFormat": "The first line contains a positive integer $n$, the total number of houses. The next $n$ lines describe the positions of the houses. For $i = 1, 2, \\ldots, n$, the $i$-th house has coordinates given by a pair of integers $x_i$ and $y_i$, separated by a space.", "outputFormat": "Output a real number: the average number of houses covered by the antenna. The absolute error from the exact value must not exceed $0.01$.", "hint": "Sample note:\n\nAny of 3.5, 3.50, 3.500, … is correct. In addition, 3.49, 3.51, 3.499999, … are also acceptable.\n\nConstraints:\n\n- For all $i = 1, 2, \\ldots, n$, the coordinates $(x_i, y_i)$ are integers and $-1{,}000{,}000 \\le x_i, y_i \\le 1{,}000{,}000$. No three houses are collinear, and no four houses are cocircular.\n- 40% of the testdata: $n \\le 100$.\n- 70% of the testdata: $n \\le 500$.\n- 100% of the testdata: $3 \\le n \\le 1{,}500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2010] 信号覆盖", "background": "", "description": "一家电信公司正在北京城搭建一个 GSM 网络。城市里共有 n 个房子需要被 信号覆盖。由于经费的限制，电信公司只能安装一个天线。 这里将每个房子用一个点坐标来表示。为了简化天线的放置，电信公司将会 选择其中的 3 个房子作一个外接圆，然后将天线放在圆的中心，所有位于这个圆 内或者圆的边界上的房子都将被天线的信号所覆盖。 电信公司将会随机选择城市中的 3 个房子来搭建天线，他们想知道在所有可 能放置天线的方案中平均会有多少个房子被信号覆盖。 例如，假设共有 4 个房子 A, B, C, D，它们的位置如下图：\n\n  ![](https://cdn.luogu.com.cn/upload/pic/4405.png) \n\n如果我们选择ABC或者BCD三个点搭建的外接圆，所有的房子都会被覆盖。 如果我们选择 ACD 或者 ABD，剩下的房子将不会在天线的信号覆盖范围内。因 此平均有(4 + 4 + 3 + 3) / 4 = 3.50 个房子被信号覆盖。 给定所有房子的位置，你的任务是计算平均有多少个房子被信号覆盖。假定 每一个房子都有一个二维的整数坐标，并且保证任何三个房子都不在同一条直线 上，任何四个房子都不在同一个圆上。\n", "inputFormat": "输入第一行包含一个正整数 n, 表示房子的总数。接下来有 n 行，分别表示 每一个房子的位置。对于 i = 1, 2, .., n, 第 i 个房子的坐标用一对整数 xi和 yi来表 示，中间用空格隔开。\n", "outputFormat": "输出文件包含一个实数，表示平均有多少个房子被信号所覆盖，需保证输出 结果与精确值的绝对误差不超过 0.01。\n", "hint": "【样例说明】\n\n3.5, 3.50, 3.500, … 中的任何一个输出均为正确。此外，3.49, 3.51, 3.499999，…等也都是可被接受的输出。\n\n【数据范围】\n\n100%的数据保证，对于 i = 1, 2, .., n, 第 i 个房子的坐标(xi, yi)为整数且 –1,000,000 ≤ xi, yi ≤ 1,000,000. 任何三个房子不在同一条直线上，任何四个房子不 在同一个圆上；\n\n40%的数据，n ≤ 100；\n\n70%的数据，n ≤ 500；\n\n100%的数据，3 ≤ n ≤ 1,500。\n", "locale": "zh-CN"}}}
{"pid": "P3631", "type": "P", "difficulty": 6, "samples": [["3 4 3\n2 2 1\n1 2 0\n2 3 1", "8"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "2011", "并查集", "APIO", "枚举", "位运算"], "title": "[APIO2011] 方格染色", "background": "", "description": "Sam 和他的妹妹 Sara 有一个包含 $n \\times m$ 个方格的表格。他们想要将其中的每个方格都染成红色或蓝色。出于个人喜好，他们想要表格中每个 $2 \\times 2$ 的方形区域都包含奇数个（ $1$ 个或 $3$ 个）红色方格。例如，下面是一个合法的表格染色方案（`R` 代表红色，`B` 代表蓝色）：\n```\nB B R B R\nR B B B B\nR R B R B\n```\n可是昨天晚上，有人已经给表格中的一些方格染上了颜色！现在 Sam 和 Sara 非常生气。不过，他们想要知道是否可能给剩下的方格染上颜色，使得整个表格依然满足他们的要求。如果可能的话，满足他们要求的染色方案数有多少呢？", "inputFormat": "输入的第一行包含三个整数 $n,m,k$，分别代表表格的行数，列数和已被染色的方格数目。\n\n之后的 $k$ 行描述已被染色的方格。其中第i行包含三个整数 $x_i,y_i,c_i$，分表代表第 $i$ 个已被染色的方格的行编号、列编号和颜色。$c_i$ 为 $1$ 表示方格被染成红色，$c_i$ 为 $0$ 表示方格被染成蓝色。", "outputFormat": "输出一个整数，表示可能的染色方案数 $w$ 对于 $10^9$ 取模后得到的值。\n", "hint": "对于 $20\\%$ 的测试数据，$n,m,k \\leqslant 5$。\n\n对于 $50\\%$ 的测试数据，$n,m \\leqslant 5000$，$k \\leqslant 25$。\n\n对于 $100\\%$ 的测试数据，$2 \\leqslant n,m \\leqslant 10^5$，$0 \\leqslant k \\leqslant 10^5$，$1 \\leqslant x_i \\leqslant n$，$1 \\leqslant y_i \\leqslant m$，$\\forall c_i \\in \\{0,1\\}$。", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2011] Grid Coloring", "background": "", "description": "Sam and his sister Sara have a grid with $n \\times m$ cells. They want to color each cell either red or blue. Due to personal preference, they want every $2 \\times 2$ square in the grid to contain an odd number ($1$ or $3$) of red cells. For example, the following is a valid coloring (R stands for red, B stands for blue):\n```\nB B R B R\nR B B B B\nR R B R B\n```\nHowever, last night, someone already colored some cells! Now Sam and Sara are very upset. Still, they want to know whether it is possible to color the remaining cells so that the entire grid still satisfies their requirement. If it is possible, how many such colorings are there?", "inputFormat": "The first line contains three integers $n, m, k$, representing the number of rows, the number of columns, and the number of precolored cells, respectively.\n\nThe next $k$ lines describe the precolored cells. The $i$-th line contains three integers $x_i, y_i, c_i$, representing the row index, the column index, and the color of the $i$-th precolored cell, respectively. $c_i = 1$ means the cell is red, and $c_i = 0$ means the cell is blue.", "outputFormat": "Output a single integer: the value of $w$ modulo $10^9$, where $w$ is the number of valid colorings.", "hint": "For $20\\%$ of the testdata, $n, m, k \\leqslant 5$.\n\nFor $50\\%$ of the testdata, $n, m \\leqslant 5000$, $k \\leqslant 25$.\n\nFor $100\\%$ of the testdata, $2 \\leqslant n, m \\leqslant 10^5$, $0 \\leqslant k \\leqslant 10^5$, $1 \\leqslant x_i \\leqslant n$, $1 \\leqslant y_i \\leqslant m$, $\\forall c_i \\in \\{0, 1\\}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2011] 方格染色", "background": "", "description": "Sam 和他的妹妹 Sara 有一个包含 $n \\times m$ 个方格的表格。他们想要将其中的每个方格都染成红色或蓝色。出于个人喜好，他们想要表格中每个 $2 \\times 2$ 的方形区域都包含奇数个（ $1$ 个或 $3$ 个）红色方格。例如，下面是一个合法的表格染色方案（`R` 代表红色，`B` 代表蓝色）：\n```\nB B R B R\nR B B B B\nR R B R B\n```\n可是昨天晚上，有人已经给表格中的一些方格染上了颜色！现在 Sam 和 Sara 非常生气。不过，他们想要知道是否可能给剩下的方格染上颜色，使得整个表格依然满足他们的要求。如果可能的话，满足他们要求的染色方案数有多少呢？", "inputFormat": "输入的第一行包含三个整数 $n,m,k$，分别代表表格的行数，列数和已被染色的方格数目。\n\n之后的 $k$ 行描述已被染色的方格。其中第i行包含三个整数 $x_i,y_i,c_i$，分表代表第 $i$ 个已被染色的方格的行编号、列编号和颜色。$c_i$ 为 $1$ 表示方格被染成红色，$c_i$ 为 $0$ 表示方格被染成蓝色。", "outputFormat": "输出一个整数，表示可能的染色方案数 $w$ 对于 $10^9$ 取模后得到的值。\n", "hint": "对于 $20\\%$ 的测试数据，$n,m,k \\leqslant 5$。\n\n对于 $50\\%$ 的测试数据，$n,m \\leqslant 5000$，$k \\leqslant 25$。\n\n对于 $100\\%$ 的测试数据，$2 \\leqslant n,m \\leqslant 10^5$，$0 \\leqslant k \\leqslant 10^5$，$1 \\leqslant x_i \\leqslant n$，$1 \\leqslant y_i \\leqslant m$，$\\forall c_i \\in \\{0,1\\}$。", "locale": "zh-CN"}}}
{"pid": "P3632", "type": "P", "difficulty": 6, "samples": [["2\n\n1 7 7 8\n2\n2 5 3 8\n4 10 6 7\n\n2 1 5 4\n1\n3 1 4 3\n", "9\nNo Path\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2011", "APIO", "最短路"], "title": "[APIO2011] 寻路", "background": "", "description": "TooDee 是一块二维格子状的土地（就像著名的笛卡尔坐标系那样），在这里生活着很多可爱的 Dee。Dee 是像蜜蜂一样的小动物，它们只在二维活动，而且他们非常的 文明开化。TooDee 的蜂窝和正常世界的蜂窝也是很不一样的，他们是矩形的且它们的边平行于 TooDee 的地理坐标系，就是说矩形的边或者是东西走向， 或者是南北走向。\n\n因为 Dees 是很高级的生物，他们有很多固定的飞行轨道，这些轨道由一些平行于坐标轴的线段组成，线段只会在经纬度都是整数的点相交。Dee 在 TooDee 飞行时必须遵守以下规则（请记住 TooDee 中所有点的经纬度都是整数）：\n\n1. 如果当前在点 $(X, Y)$，则下一步只能飞到四个邻点 $(X, Y - 1), (X, Y + 1), (X - 1, Y), (X + 1, Y)$；\n\n2. 不可以进入蜂巢；\n\n3. 只能在蜂巢的角上或者边上改变飞行方向；\n\n4. 开始的时候可以向任何方向飞；\n\n今晚是公共财政大臣 Deeficer 的女儿的生日，她想尽早回家，请帮她找到最快的回家路径。假设她每秒可以飞行一个单位的距离。", "inputFormat": "每个测试点包含多组数据。\n\n输入的第一行包含一个整数 $T$，表示测试数据的组数。接下来依次描述这 $T$ 组数据，相邻的两组之间使用一个空行分隔，测试数据不多于 $20$ 组。\n\n对 于每组数据，第一行包含四个整数 $x_s,y_s,x_t,y_t$，表示 Deeficer 的办公室和家的坐标分别是 $(x_s, y_s)$ 和 $(x_t, y_t)$。第二行包含一个整数 $n$，表示蜂巢的个数。接下来的 $n$ 行描述所有的蜂巢，其中第 $i$ 行包含四个整数 $x_{i_1}, y_{i_1}, x_{i_2}, y_{i_2}$，表示第 $i$ 个蜂巢两个对角的坐标分别为 $(x_{i_1}, y_{i_1})$ 和 $(x_{i_2}, y_{i_2})$。\n\n任何两个蜂巢不会相交，也不会接触（在角上也不会接触）。办公室和家处在不同的位置。每个蜂巢的面积为正。", "outputFormat": "对于每一组数据，输出一个整数，表示 Deeficer 最快回家的时间（单位为秒），如果她无法按规则回家，则输出 `No Path`。\n", "hint": "对于 $20\\%$ 的测试数据，$n\\leq 10$，所有的坐标都是小于 $100$ 的非负整数；\n\n对于 $60\\%$ 的测试数据，$n\\leq 100$，所有坐标的绝对值都小于 $10^3$；\n\n对于 $100\\%$ 的测试数据，$0\\leq n\\leq 10^3$，所有坐标的绝对值都是不超过 $10^9$ 的整数。", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2011] Pathfinding", "background": "", "description": "TooDee is a two-dimensional grid-like land (just like the well-known Cartesian coordinate system), home to many adorable Dees. Dees are small bee-like creatures that move only in 2D, and they are very civilized and advanced. The hives in TooDee are quite different from those in the ordinary world: they are rectangles whose sides are parallel to TooDee’s geographic coordinate axes, meaning each rectangle’s sides run either east–west or north–south.\n\nBecause Dees are advanced beings, they have many fixed flight corridors. These corridors are composed of axis-parallel line segments, and line segments intersect only at points whose coordinates are integers. When a Dee flies in TooDee, it must follow the rules below (remember that in TooDee all points have integer coordinates):\n\n1. If currently at point $(X, Y)$, the next step may go only to one of the four neighboring points $(X, Y - 1), (X, Y + 1), (X - 1, Y), (X + 1, Y)$.\n2. Entering a hive is not allowed.\n3. A change of direction is allowed only at a hive’s corners or along its edges.\n4. At the start, one may fly in any direction.\n\nTonight is the birthday of the daughter of the Minister of Public Finance, Deeficer. She wants to get home as soon as possible. Please help her find the fastest route home. Assume she can fly a distance of 1 unit per second.", "inputFormat": "Each test file contains multiple test cases.\n\nThe first line contains an integer $T$, the number of test cases. Then the $T$ test cases follow, with a blank line separating consecutive cases. There are at most $20$ test cases.\n\nFor each test case, the first line contains four integers $x_s, y_s, x_t, y_t$, meaning the coordinates of Deeficer’s office and home are $(x_s, y_s)$ and $(x_t, y_t)$, respectively. The second line contains an integer $n$, the number of hives. The next $n$ lines describe all hives; on the $i$-th of these lines there are four integers $x_{i_1}, y_{i_1}, x_{i_2}, y_{i_2}$, giving the coordinates of two opposite corners of the $i$-th hive as $(x_{i_1}, y_{i_1})$ and $(x_{i_2}, y_{i_2})$.\n\nNo two hives intersect or touch (not even at a corner). The office and home are at different locations. Each hive has positive area.", "outputFormat": "For each test case, output one integer: the minimum time (in seconds) for Deeficer to get home. If she cannot get home under the rules, output `No Path`.", "hint": "For $20\\%$ of the testdata, $n\\leq 10$, and all coordinates are non-negative integers less than $100$.\n\nFor $60\\%$ of the testdata, $n\\leq 100$, and the absolute value of every coordinate is less than $10^3$.\n\nFor $100\\%$ of the testdata, $0\\leq n\\leq 10^3$, and the absolute value of every coordinate is at most $10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2011] 寻路", "background": "", "description": "TooDee 是一块二维格子状的土地（就像著名的笛卡尔坐标系那样），在这里生活着很多可爱的 Dee。Dee 是像蜜蜂一样的小动物，它们只在二维活动，而且他们非常的 文明开化。TooDee 的蜂窝和正常世界的蜂窝也是很不一样的，他们是矩形的且它们的边平行于 TooDee 的地理坐标系，就是说矩形的边或者是东西走向， 或者是南北走向。\n\n因为 Dees 是很高级的生物，他们有很多固定的飞行轨道，这些轨道由一些平行于坐标轴的线段组成，线段只会在经纬度都是整数的点相交。Dee 在 TooDee 飞行时必须遵守以下规则（请记住 TooDee 中所有点的经纬度都是整数）：\n\n1. 如果当前在点 $(X, Y)$，则下一步只能飞到四个邻点 $(X, Y - 1), (X, Y + 1), (X - 1, Y), (X + 1, Y)$；\n\n2. 不可以进入蜂巢；\n\n3. 只能在蜂巢的角上或者边上改变飞行方向；\n\n4. 开始的时候可以向任何方向飞；\n\n今晚是公共财政大臣 Deeficer 的女儿的生日，她想尽早回家，请帮她找到最快的回家路径。假设她每秒可以飞行一个单位的距离。", "inputFormat": "每个测试点包含多组数据。\n\n输入的第一行包含一个整数 $T$，表示测试数据的组数。接下来依次描述这 $T$ 组数据，相邻的两组之间使用一个空行分隔，测试数据不多于 $20$ 组。\n\n对 于每组数据，第一行包含四个整数 $x_s,y_s,x_t,y_t$，表示 Deeficer 的办公室和家的坐标分别是 $(x_s, y_s)$ 和 $(x_t, y_t)$。第二行包含一个整数 $n$，表示蜂巢的个数。接下来的 $n$ 行描述所有的蜂巢，其中第 $i$ 行包含四个整数 $x_{i_1}, y_{i_1}, x_{i_2}, y_{i_2}$，表示第 $i$ 个蜂巢两个对角的坐标分别为 $(x_{i_1}, y_{i_1})$ 和 $(x_{i_2}, y_{i_2})$。\n\n任何两个蜂巢不会相交，也不会接触（在角上也不会接触）。办公室和家处在不同的位置。每个蜂巢的面积为正。", "outputFormat": "对于每一组数据，输出一个整数，表示 Deeficer 最快回家的时间（单位为秒），如果她无法按规则回家，则输出 `No Path`。\n", "hint": "对于 $20\\%$ 的测试数据，$n\\leq 10$，所有的坐标都是小于 $100$ 的非负整数；\n\n对于 $60\\%$ 的测试数据，$n\\leq 100$，所有坐标的绝对值都小于 $10^3$；\n\n对于 $100\\%$ 的测试数据，$0\\leq n\\leq 10^3$，所有坐标的绝对值都是不超过 $10^9$ 的整数。", "locale": "zh-CN"}}}
{"pid": "P3633", "type": "P", "difficulty": 5, "samples": [["2\n12\nSI ME AND AI ARE MD AS WHEN ED IS DE HAPY\n5\nA B AB AC AD", "Yes\nNo"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["博弈论", "2011", "APIO"], "title": "[APIO2011] 猜单词", "background": "", "description": "“猜单词”是一个双人游戏，在伊朗的青年学生中广为流行。假设有两个游戏者A和B，A作为先手，首先在一个双方都知道的语料库中选出一个单词，并记在脑海中。随后，他在一张小纸片上划下与单词字母数相等的小横线（不妨设为n条）。\n\n接下来，B尝试猜出这个单词。每一轮，B选择一个字母并告诉A。A按如下规则回应：\n\n一、若B所说的字母在单词中出现，A就把它写在对应的横线上。如果整个单词已经完整（所有的字母都已经被猜出），B获胜。\n\n二、否则，如果字母没有在单词中出现，A就把它写在最左侧的下方仍为空白的横线下。如果所有横线下的空白处都已经有字母（也就是说，在这一轮前B已经猜了n个错误字母），那么B就输了，A获胜。\n\n例如，A从语料库中选出了单词RED，且B已经依次猜了字母A，E，C，D，B和R。每一步的结果都在下图中展现，最终B获胜。但如果B在最后一步猜了S而不是R，他就输了。\n\n```cpp\n\n- - - （第一步，B选A）\nA\n\n  E \n- - - （第二步，B选E）\nA\n\n  E\n- - - （第三步，B选C）\nA C\n\n  E D\n- - - （第四步，B选D）\nA C\n\n  E D\n- - - （第五步，B选B）\nA C B\n\nR E D\n- - - （第六步，B选R）\nA C B\n```\nAidin 是猜单词游戏迷。他相信，如果给定的语料库足够大，且其中的单词相对好，那么玩家A（先手）可以采取一种不公平的行动——修改选择的单词。也就是说，既然 玩家A只将单词记在脑海中而不写下来，那他能够在游戏过程中随时变化这个单词，只要使得和当前已经给出的结果依然一致即可。例如，在上面的游戏中，如果单 词RED，BED，LED和TED都在语料库中，那么在第4步之后，A就可以确信他将胜利。他将总是把B给出的字母写在横线下（也就是认定其为错误的字 母），那么每一次他将至多在集合{RED，BED，LED，TED}中失去一个备选单词，最终他将向B宣布：“这个单词是，嗯……”，然后再他的集合中说 出一个剩下的单词。\n\nAidin想，如果语料库足够好，那么A甚至可能在游戏一开始就确定获胜。例如，如果选择的单词长度为2，而集合{ME，MD，DE，ED，AS，IS，AI，SI}中的单词都在语料库中，那么A总能获胜。请自己找出A获胜的策略。\n\n给定一个语料库，Aidin想知道是否无论B如何进行游戏，玩家A一定能获胜？\n\n请注意在任何一次游戏结束时，如果A获胜，A需要能够给出一个语料库中的单词作为被选出的单词，这个单词应当与A所有给出的回答一致。\n", "inputFormat": "输入包含若干个语料库，每个语料库应该被独立地处理。\n\n输入的第一行是一个整数C，代表语料库的数目。随后C个语料库以C个模块的形式出现在输入中，每两个模块之间以一个空行隔开。1<=C<=20。\n\n对于每个输入模块，第一行包含一个正整数k，表示语料库中单词的个数。接下来的若干行中包含k个单词。相邻的单词以空格、制表符或换行符分隔。每个单词由小于7个大写英语字母组成。\n\n每个单词都由不同的字母组成，也就是说，同一个字母在一个单词中出现的次数不会超过一次。\n", "outputFormat": "对于每个语料库，如果玩家A有必胜策略（也就是说，不论B按什么办法猜，A总能获胜），输出一行“Yes”。否则输出一行“No”。输出不包含引号。\n", "hint": "对于20%的测试数据，k<=100，每个单词的长度不超过3。\n\n对于50%的测试数据，k<=300，每个单词的长度不超过4。\n\n对于100%的测试数据，k<=1000。输入文件小于500KB。\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2011] Guess the Word", "background": "", "description": "“Guess the Word” is a two-player game popular among young students in Iran. Suppose there are two players, A and B. A moves first and secretly chooses a word from a corpus known to both players, remembering it in his mind. Then he draws a row of short dashes on a small piece of paper, as many as the number of letters in the word (say $n$ dashes).\n\nNext, B tries to guess the word. In each round, B chooses a letter and tells A. A responds according to the following rules:\n\n1. If the letter B said appears in the word, A writes it on the corresponding dashes. If the entire word becomes complete (all letters have been guessed), B wins.\n\n2. Otherwise, if the letter does not appear in the word, A writes it below the leftmost dash whose underneath is still blank. If all the positions below the dashes are already filled (that is, before this round, B has already guessed $n$ wrong letters), then B loses and A wins.\n\nFor example, A chose the word RED from the corpus, and B has guessed the letters A, E, C, D, B, and R in order. The outcome of each step is shown below, and B wins in the end. But if B had guessed S instead of R in the last step, he would have lost.\n\n```cpp\n\n- - - （第一步，B选A）\nA\n\n  E \n- - - （第二步，B选E）\nA\n\n  E\n- - - （第三步，B选C）\nA C\n\n  E D\n- - - （第四步，B选D）\nA C\n\n  E D\n- - - （第五步，B选B）\nA C B\n\nR E D\n- - - （第六步，B选R）\nA C B\n```\nAidin is a fan of the Guess the Word game. He believes that if the given corpus is large enough and its words are “nice,” player A (the first mover) can take an unfair action—changing the chosen word. That is, since player A keeps the word only in his mind and does not write it down, he can change the word at any time during the game, as long as all current revealed information remains consistent. For example, in the game above, if the words RED, BED, LED, and TED are all in the corpus, then after the 4th move, A can be sure he will win. He will always write B’s letters under the dashes (i.e., treat them as wrong letters), so each time he loses at most one candidate from the set {RED, BED, LED, TED}. Finally, he will announce to B: “The word is, uh…,” and then name one of the remaining words in his set.\n\nAidin wonders whether, if the corpus is good enough, A can even be certain of victory from the very beginning. For example, if the word length is 2 and all words in the set {ME, MD, DE, ED, AS, IS, AI, SI} are in the corpus, then A can always win. Please find a winning strategy for A yourself.\n\nGiven a corpus, Aidin wants to know whether player A is guaranteed to win no matter how B plays.\n\nNote that at the end of any game, if A wins, A must be able to name a word from the corpus as the chosen word, and this word must be consistent with all of A’s responses.", "inputFormat": "The input contains several corpora, each of which should be processed independently.\n\nThe first line contains an integer C, the number of corpora. Then C corpora follow, each as a separate module, and modules are separated by one empty line. 1 ≤ C ≤ 20.\n\nFor each module, the first line contains a positive integer k, the number of words in the corpus. The next lines contain k words. Adjacent words are separated by spaces, tabs, or newlines. Each word consists of fewer than 7 uppercase English letters.\n\nEach word consists of distinct letters; that is, no letter appears more than once in a single word.", "outputFormat": "For each corpus, if player A has a guaranteed winning strategy (that is, no matter how B guesses, A can always win), output a line “Yes”. Otherwise, output a line “No”. Do not include quotes.", "hint": "- For 20% of the testdata, k ≤ 100, and each word’s length is at most 3.\n- For 50% of the testdata, k ≤ 300, and each word’s length is at most 4.\n- For 100% of the testdata, k ≤ 1000. The input file is smaller than 500 KB.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2011] 猜单词", "background": "", "description": "“猜单词”是一个双人游戏，在伊朗的青年学生中广为流行。假设有两个游戏者A和B，A作为先手，首先在一个双方都知道的语料库中选出一个单词，并记在脑海中。随后，他在一张小纸片上划下与单词字母数相等的小横线（不妨设为n条）。\n\n接下来，B尝试猜出这个单词。每一轮，B选择一个字母并告诉A。A按如下规则回应：\n\n一、若B所说的字母在单词中出现，A就把它写在对应的横线上。如果整个单词已经完整（所有的字母都已经被猜出），B获胜。\n\n二、否则，如果字母没有在单词中出现，A就把它写在最左侧的下方仍为空白的横线下。如果所有横线下的空白处都已经有字母（也就是说，在这一轮前B已经猜了n个错误字母），那么B就输了，A获胜。\n\n例如，A从语料库中选出了单词RED，且B已经依次猜了字母A，E，C，D，B和R。每一步的结果都在下图中展现，最终B获胜。但如果B在最后一步猜了S而不是R，他就输了。\n\n```cpp\n\n- - - （第一步，B选A）\nA\n\n  E \n- - - （第二步，B选E）\nA\n\n  E\n- - - （第三步，B选C）\nA C\n\n  E D\n- - - （第四步，B选D）\nA C\n\n  E D\n- - - （第五步，B选B）\nA C B\n\nR E D\n- - - （第六步，B选R）\nA C B\n```\nAidin 是猜单词游戏迷。他相信，如果给定的语料库足够大，且其中的单词相对好，那么玩家A（先手）可以采取一种不公平的行动——修改选择的单词。也就是说，既然 玩家A只将单词记在脑海中而不写下来，那他能够在游戏过程中随时变化这个单词，只要使得和当前已经给出的结果依然一致即可。例如，在上面的游戏中，如果单 词RED，BED，LED和TED都在语料库中，那么在第4步之后，A就可以确信他将胜利。他将总是把B给出的字母写在横线下（也就是认定其为错误的字 母），那么每一次他将至多在集合{RED，BED，LED，TED}中失去一个备选单词，最终他将向B宣布：“这个单词是，嗯……”，然后再他的集合中说 出一个剩下的单词。\n\nAidin想，如果语料库足够好，那么A甚至可能在游戏一开始就确定获胜。例如，如果选择的单词长度为2，而集合{ME，MD，DE，ED，AS，IS，AI，SI}中的单词都在语料库中，那么A总能获胜。请自己找出A获胜的策略。\n\n给定一个语料库，Aidin想知道是否无论B如何进行游戏，玩家A一定能获胜？\n\n请注意在任何一次游戏结束时，如果A获胜，A需要能够给出一个语料库中的单词作为被选出的单词，这个单词应当与A所有给出的回答一致。\n", "inputFormat": "输入包含若干个语料库，每个语料库应该被独立地处理。\n\n输入的第一行是一个整数C，代表语料库的数目。随后C个语料库以C个模块的形式出现在输入中，每两个模块之间以一个空行隔开。1<=C<=20。\n\n对于每个输入模块，第一行包含一个正整数k，表示语料库中单词的个数。接下来的若干行中包含k个单词。相邻的单词以空格、制表符或换行符分隔。每个单词由小于7个大写英语字母组成。\n\n每个单词都由不同的字母组成，也就是说，同一个字母在一个单词中出现的次数不会超过一次。\n", "outputFormat": "对于每个语料库，如果玩家A有必胜策略（也就是说，不论B按什么办法猜，A总能获胜），输出一行“Yes”。否则输出一行“No”。输出不包含引号。\n", "hint": "对于20%的测试数据，k<=100，每个单词的长度不超过3。\n\n对于50%的测试数据，k<=300，每个单词的长度不超过4。\n\n对于100%的测试数据，k<=1000。输入文件小于500KB。\n", "locale": "zh-CN"}}}
{"pid": "P3634", "type": "P", "difficulty": 6, "samples": [["5 3 4 \n1 2 1 \n3 4 1 \n4 4 0 \n4 5 1", "3\n5\n"], ["5 1 1 \n1 5 1", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2012", "线段树", "APIO", "差分"], "title": "[APIO2012] 守卫", "background": "APIO 王国正被忍者攻击！忍者非常厉害，因为他们在进攻的时候可以躲在 阴影里面使得其他人看不到他们。整个王国除了国王居住的 APIO 城堡以外都已经被占领了。", "description": "在城堡前，有 $N$ 个灌木丛，从 $1$ 到 $N$ 编号，有 $K$ 个忍者躲在恰好 $K$ 个灌木丛后面。\n\nAPIO 城堡里有 $M$ 个守卫。守卫 $i$ 监视着编号从 $A_i$ 到 $B_i$ 的连续的一段灌木丛。每个守卫都向国王报告在他所监视范围内是否有忍者出现。\n\n作为国王的仆人，你需要告诉国王，基于守卫的报告，哪些灌木丛后面一定躲着一个忍者，即对于任何和守卫报告不矛盾的忍者排列方式，在这个灌木丛后面都躲着一个忍者。\n\n输出所有的这些灌木丛的编号。", "inputFormat": "第一行包含三个用空格分隔的整数 $N, K, M$。$N$ 是灌木丛的个数，$K$ 是忍者 的个数，$M$ 是守卫的个数。\n\n接下来 $M$ 行，每行描述一个守卫的信息。其中的第 $i$ 行包含三个整数 $A_i, B_i, C_i$，表示第 $i$ 个守卫的监视范围是从 $A_i$ 到 $B_i(A_i \\leq B_i)$。$C_i$ 是 $0$ 或者 $1$，若是 $0$ 表示范围内没有看到忍者，$1$ 表示范围内有至少一个忍者。\n\n输入数据保证至少存在一种忍者排列方式满足所有条件。", "outputFormat": "若存在灌木丛，在其后面一定躲着忍者，则将这些灌木丛按照编号从小到大的顺序依次输出，每个一行。即若有 $X$ 个这样的灌木丛，则需要输出 $X$ 行。\n\n若不存在，则输出一行一个 `-1`。", "hint": "#### 【样例说明 $1$】\n\n在这个样例中，有两种可能的安排方式：$1,3,5$ 或者 $2,3,5$。即 $3$ 和 $5$ 后面必然躲着一个忍者。考虑第一个灌木丛，存在一种安排方案使得它的后面躲着忍者，但也存在一种安排方案使得它后面没有躲忍者，因此不应该输出 $1$。同理，不应该输出 $2$。\n\n#### 【样例说明 $2$】\n\n在这个样例中，没有灌木丛后面一定躲着忍者。\n\n#### 数据范围\n\n$1 \\leq N \\leq 10^5$；$1 \\leq K \\leq N$；$0 \\leq M < 10^5$。\n\n \n对于 $10\\%$ 的数据，$N \\leq 20， M \\leq 100$；\n\n对于 $50\\%$ 的数据，$N \\leq 1000， M \\leq 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2012] Guard", "background": "The APIO Kingdom is under attack by ninjas! Ninjas are very skilled, because during their attack they can hide in the shadows so that others cannot see them. The entire kingdom has been occupied except for the APIO castle where the king resides.", "description": "In front of the castle, there are $N$ bushes, numbered from $1$ to $N$. There are $K$ ninjas hiding behind exactly $K$ bushes.\n\nThere are $M$ guards in the APIO castle. Guard $i$ watches a contiguous segment of bushes numbered from $A_i$ to $B_i$. Each guard reports to the king whether there is a ninja within their monitored range.\n\nAs the king’s servant, you need to tell the king, based on the guards’ reports, which bushes must contain a ninja; that is, for any placement of ninjas that is consistent with the reports, there is a ninja behind that bush.\n\nOutput all such bush indices.", "inputFormat": "The first line contains three space-separated integers $N, K, M$. $N$ is the number of bushes, $K$ is the number of ninjas, and $M$ is the number of guards.\n\nThe next $M$ lines each describe one guard. The $i$-th line contains three integers $A_i, B_i, C_i$, meaning that the $i$-th guard monitors the range from $A_i$ to $B_i$ (with $A_i \\leq B_i$). $C_i$ is $0$ or $1$: $0$ means no ninja is seen within the range; $1$ means there is at least one ninja within the range.\n\nThe input guarantees that at least one placement of ninjas satisfies all constraints.", "outputFormat": "If there exist bushes that must contain a ninja, output their indices in increasing order, one per line. If there are $X$ such bushes, output $X$ lines.\n\nOtherwise, output a single line containing `-1`.", "hint": "#### Sample Explanation $1$\n\nIn this sample, there are two possible placements: $1, 3, 5$ or $2, 3, 5$. Therefore, $3$ and $5$ must contain a ninja. For bush $1$, there exists a placement where it has a ninja and another where it does not, so $1$ should not be output. Similarly, $2$ should not be output.\n\n#### Sample Explanation $2$\n\nIn this sample, no bush is guaranteed to contain a ninja.\n\n#### Constraints\n\n$1 \\leq N \\leq 10^5$; $1 \\leq K \\leq N$; $0 \\leq M < 10^5$.\n\nFor $10\\%$ of the testdata, $N \\leq 20$, $M \\leq 100$.\n\nFor $50\\%$ of the testdata, $N \\leq 1000$, $M \\leq 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2012] 守卫", "background": "APIO 王国正被忍者攻击！忍者非常厉害，因为他们在进攻的时候可以躲在 阴影里面使得其他人看不到他们。整个王国除了国王居住的 APIO 城堡以外都已经被占领了。", "description": "在城堡前，有 $N$ 个灌木丛，从 $1$ 到 $N$ 编号，有 $K$ 个忍者躲在恰好 $K$ 个灌木丛后面。\n\nAPIO 城堡里有 $M$ 个守卫。守卫 $i$ 监视着编号从 $A_i$ 到 $B_i$ 的连续的一段灌木丛。每个守卫都向国王报告在他所监视范围内是否有忍者出现。\n\n作为国王的仆人，你需要告诉国王，基于守卫的报告，哪些灌木丛后面一定躲着一个忍者，即对于任何和守卫报告不矛盾的忍者排列方式，在这个灌木丛后面都躲着一个忍者。\n\n输出所有的这些灌木丛的编号。", "inputFormat": "第一行包含三个用空格分隔的整数 $N, K, M$。$N$ 是灌木丛的个数，$K$ 是忍者 的个数，$M$ 是守卫的个数。\n\n接下来 $M$ 行，每行描述一个守卫的信息。其中的第 $i$ 行包含三个整数 $A_i, B_i, C_i$，表示第 $i$ 个守卫的监视范围是从 $A_i$ 到 $B_i(A_i \\leq B_i)$。$C_i$ 是 $0$ 或者 $1$，若是 $0$ 表示范围内没有看到忍者，$1$ 表示范围内有至少一个忍者。\n\n输入数据保证至少存在一种忍者排列方式满足所有条件。", "outputFormat": "若存在灌木丛，在其后面一定躲着忍者，则将这些灌木丛按照编号从小到大的顺序依次输出，每个一行。即若有 $X$ 个这样的灌木丛，则需要输出 $X$ 行。\n\n若不存在，则输出一行一个 `-1`。", "hint": "#### 【样例说明 $1$】\n\n在这个样例中，有两种可能的安排方式：$1,3,5$ 或者 $2,3,5$。即 $3$ 和 $5$ 后面必然躲着一个忍者。考虑第一个灌木丛，存在一种安排方案使得它的后面躲着忍者，但也存在一种安排方案使得它后面没有躲忍者，因此不应该输出 $1$。同理，不应该输出 $2$。\n\n#### 【样例说明 $2$】\n\n在这个样例中，没有灌木丛后面一定躲着忍者。\n\n#### 数据范围\n\n$1 \\leq N \\leq 10^5$；$1 \\leq K \\leq N$；$0 \\leq M < 10^5$。\n\n \n对于 $10\\%$ 的数据，$N \\leq 20， M \\leq 100$；\n\n对于 $50\\%$ 的数据，$N \\leq 1000， M \\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P3635", "type": "P", "difficulty": 6, "samples": [["5 4 \n5 \n3 3 2 \n3 2 0 \n4 2 2 \n5 4 1 \n1 1 3 ", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "APIO"], "title": "[APIO2012] 苦无", "background": "", "description": "苦无 (Kunai) 是一种忍者使用的形状像刀的武器，忍者通过投掷苦无攻击对手。现在有 $N$ 名忍者聚集在一块 $H$ 行 $W$ 列的棋盘式的广场上。每个忍者都站在其所在方块的中心处，任何两个忍者都不在同一个方块上。每个忍者都拿着一个苦无，面朝上、下、左、右四个方向中的一个方向站着。在时刻 $0$，所有忍者同时向其所朝向的方向投掷苦无。\n\n每个苦无将会一直保持其初始的方向，并以单位速度飞行。如果某个时刻一个位置上多于一个的苦无，它们将会相撞并且消失。苦无特别小，可以看成质点。同时，由于忍者的移动速度特别快，他们不会被苦无击中。\n\n在下面的例子中，我们用箭头来表示苦无，而箭头的方向即为苦无的方向。在这些图中，所有的苦无都会相撞后消失。\n\n  ![](https://cdn.luogu.com.cn/upload/pic/4414.png) \n\n在下面的图中，两个粗线箭头表示的苦无不会相撞。其中在第二个和第三个图中，其中一个粗线表示的苦无会与细线表示的苦无相撞后消失，因此不会撞上另一个粗线表示的苦无。\n\n  ![](https://cdn.luogu.com.cn/upload/pic/4415.png) \n\n你的任务是计算经过足够长的时间之后，在这个 $W × H$ 的广场中有多少格子被苦无经过。", "inputFormat": "第一行包含两个被空格隔开的整数 $W$, $H$，表示广场的尺寸为 $W$ 列 $H$ 行。第二行包含一个整数 $N$，表示忍者的数量。\n\n接下来 $N$ 行中，第 $i$ 行有三个以空格分隔的整数 $X_i, Y_i, D_i$, 表示第 $i$ 个忍者处在从左往右的 $X_i$ 列、从上往下的第 $Y_i$ 行，任何两个忍者不在同一个位置。第 $i$ 个忍者面向的方向由 $D_i$ 表示，分别为： \n\n- $D_i = 0$，表示忍者向右；\n- $D_i = 1$，表示忍者向上； \n- $D_i = 2$，表示忍者向左； \n- $D_i = 3$，表示忍者向下。", "outputFormat": "输出一个整数，表示经过足够长的时间之后，在这个 $W × H$ 的广场中被苦无经过的格子数量。", "hint": "对于全部数据，忍者数 $1 \\le N \\le 10^5$，列数 $1 \\le W \\le 10^9$，行数 $1 \\le H \\le 10^9$；\n坐标范围 $1 \\le X_i \\le W$，$1 \\le Y_i \\le H$。\n\n \n- 在 $10\\%$ 的数据中，$N \\le 1000$, $W \\le 1000$, $H \\le 1000$。\n- 在 $40\\%$ 的数据中，$N \\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2012] Kunai", "background": "", "description": "Kunai is a knife-shaped weapon used by ninjas, who attack by throwing it. There are $N$ ninjas gathered on a chessboard-like plaza with $H$ rows and $W$ columns. Each ninja stands at the center of a cell, and no two ninjas share the same cell. Each ninja holds one kunai and faces one of the four directions: up, down, left, or right. At time $0$, all ninjas simultaneously throw their kunai in the direction they are facing.\n\nEach kunai keeps its initial direction and flies at unit speed. If, at some moment, more than one kunai is at the same position, they collide and disappear. Kunai are very small and can be treated as point masses. Also, because ninjas move extremely fast, they will not be hit by any kunai.\n\nIn the following example, we use arrows to represent kunai, and the direction of an arrow is the direction of the corresponding kunai. In these figures, all kunai collide and disappear.\n\n  ![](https://cdn.luogu.com.cn/upload/pic/4414.png) \n\nIn the figures below, the two bold arrows represent kunai that will not collide. In the second and third figures, one of the bold-arrow kunai collides with a thin-arrow kunai and disappears, so it will not collide with the other bold-arrow kunai.\n\n  ![](https://cdn.luogu.com.cn/upload/pic/4415.png) \n\nYour task is to compute, after sufficient time has passed, how many cells in this $W \\times H$ plaza are traversed by at least one kunai.", "inputFormat": "The first line contains two integers $W$, $H$ separated by a space, indicating the plaza has $W$ columns and $H$ rows. The second line contains an integer $N$, the number of ninjas.\n\nThe next $N$ lines each contain three integers $X_i$, $Y_i$, $D_i$ separated by spaces. The $i$-th ninja is at column $X_i$ (counted from left to right) and row $Y_i$ (counted from top to bottom). No two ninjas share the same position. The facing direction of the $i$-th ninja is given by $D_i$:\n- $D_i = 0$: facing right;\n- $D_i = 1$: facing up;\n- $D_i = 2$: facing left;\n- $D_i = 3$: facing down.", "outputFormat": "Output one integer: after sufficient time has passed, the number of cells in the $W \\times H$ plaza that are traversed by at least one kunai.", "hint": "For all testdata, $1 \\le N \\le 10^5$, $1 \\le W \\le 10^9$, $1 \\le H \\le 10^9$; coordinate ranges are $1 \\le X_i \\le W$, $1 \\le Y_i \\le H$.\n\n- In $10\\%$ of the testdata, $N \\le 1000$, $W \\le 1000$, $H \\le 1000$.\n- In $40\\%$ of the testdata, $N \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2012] 苦无", "background": "", "description": "苦无 (Kunai) 是一种忍者使用的形状像刀的武器，忍者通过投掷苦无攻击对手。现在有 $N$ 名忍者聚集在一块 $H$ 行 $W$ 列的棋盘式的广场上。每个忍者都站在其所在方块的中心处，任何两个忍者都不在同一个方块上。每个忍者都拿着一个苦无，面朝上、下、左、右四个方向中的一个方向站着。在时刻 $0$，所有忍者同时向其所朝向的方向投掷苦无。\n\n每个苦无将会一直保持其初始的方向，并以单位速度飞行。如果某个时刻一个位置上多于一个的苦无，它们将会相撞并且消失。苦无特别小，可以看成质点。同时，由于忍者的移动速度特别快，他们不会被苦无击中。\n\n在下面的例子中，我们用箭头来表示苦无，而箭头的方向即为苦无的方向。在这些图中，所有的苦无都会相撞后消失。\n\n  ![](https://cdn.luogu.com.cn/upload/pic/4414.png) \n\n在下面的图中，两个粗线箭头表示的苦无不会相撞。其中在第二个和第三个图中，其中一个粗线表示的苦无会与细线表示的苦无相撞后消失，因此不会撞上另一个粗线表示的苦无。\n\n  ![](https://cdn.luogu.com.cn/upload/pic/4415.png) \n\n你的任务是计算经过足够长的时间之后，在这个 $W × H$ 的广场中有多少格子被苦无经过。", "inputFormat": "第一行包含两个被空格隔开的整数 $W$, $H$，表示广场的尺寸为 $W$ 列 $H$ 行。第二行包含一个整数 $N$，表示忍者的数量。\n\n接下来 $N$ 行中，第 $i$ 行有三个以空格分隔的整数 $X_i, Y_i, D_i$, 表示第 $i$ 个忍者处在从左往右的 $X_i$ 列、从上往下的第 $Y_i$ 行，任何两个忍者不在同一个位置。第 $i$ 个忍者面向的方向由 $D_i$ 表示，分别为： \n\n- $D_i = 0$，表示忍者向右；\n- $D_i = 1$，表示忍者向上； \n- $D_i = 2$，表示忍者向左； \n- $D_i = 3$，表示忍者向下。", "outputFormat": "输出一个整数，表示经过足够长的时间之后，在这个 $W × H$ 的广场中被苦无经过的格子数量。", "hint": "对于全部数据，忍者数 $1 \\le N \\le 10^5$，列数 $1 \\le W \\le 10^9$，行数 $1 \\le H \\le 10^9$；\n坐标范围 $1 \\le X_i \\le W$，$1 \\le Y_i \\le H$。\n\n \n- 在 $10\\%$ 的数据中，$N \\le 1000$, $W \\le 1000$, $H \\le 1000$。\n- 在 $40\\%$ 的数据中，$N \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P3636", "type": "P", "difficulty": 6, "samples": [["3 3", "300"], ["64 19260817", "9932"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": [], "title": "曲面", "background": "xht喜欢研究数学函数，他特别喜欢反比例函数。\n", "description": "我们知道，反比例函数xy=a的图象是双曲线。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4375.png) \n\nxht于是想：把它推广到三维是什么样的呢？\n\n\n定义曲面C(k)为**方程xyz=k所确定的曲面**。\n\n\n又定义曲面的美观程度P(k)为曲面C(k)上所有**整点**（x,y,z坐标均为整数）到原点的曼哈顿距离的**平方**之和。\n\n\n（点（x,y,z）到原点的曼哈顿距离为|x|+|y|+|z|）。\n\n现在，xht把一些曲面{C(a),C(a+1)...C(b)}排成一列，你要求出它们美观程度之**和**对10007取模的结果。\n", "inputFormat": "一行两个正整数数a，b\n", "outputFormat": "一行一个数\n\n![](https://cdn.luogu.com.cn/upload/pic/4376.png)\n", "hint": "样例1的解释：\n\n\n在曲面xyz=3上共有12个整点(1,1,3),(1,3,1),(3,1,1),(-1-1,3),(-1,-3,1),(-3,-1,1),(1,-1,-3),(1,-3,-1),(3,-1,-1),(-1,1,-3),(-1,3,-1),(-3,1,-1)。它们到原点的曼哈顿距离的平方之和为5^2\\*12=300。\n\n\n对于20%的数据，a=b<=100\n\n对于另外40%的数据，a,b<=3\\*10^5\n\n对于100%的数据，1<=a,b<=3\\*10^8\n", "locale": "zh-CN", "translations": {"en": {"title": "Surface", "background": "xht likes studying mathematical functions, and he especially likes the inverse proportional function.", "description": "We know that the graph of the inverse proportional function $xy = a$ is a hyperbola.\n\n![](https://cdn.luogu.com.cn/upload/pic/4375.png)\n\nxht then wondered: what would it look like if we extend it to three dimensions?\n\nDefine the surface $C(k)$ as the surface determined by the equation $xyz = k$.\n\nDefine the aesthetic value $P(k)$ of the surface as the sum of the squares of the Manhattan distances to the origin of all lattice points (points whose $x$, $y$, and $z$ coordinates are all integers) on $C(k)$.\n\n(The Manhattan distance from $(x, y, z)$ to the origin is $|x| + |y| + |z|$.)\n\nNow, xht arranges the surfaces $\\{C(a), C(a+1), \\dots, C(b)\\}$ in a row. You are required to compute the sum of their aesthetic values, that is $P(a) + P(a+1) + \\dots + P(b)$, modulo $10007$.", "inputFormat": "One line containing two positive integers $a$, $b$.", "outputFormat": "One line containing a single integer.\n\n![](https://cdn.luogu.com.cn/upload/pic/4376.png)", "hint": "Explanation of Sample 1:\n\nOn the surface $xyz = 3$, there are $12$ lattice points:\n$(1, 1, 3)$, $(1, 3, 1)$, $(3, 1, 1)$, $(-1, -1, 3)$, $(-1, -3, 1)$, $(-3, -1, 1)$, $(1, -1, -3)$, $(1, -3, -1)$, $(3, -1, -1)$, $(-1, 1, -3)$, $(-1, 3, -1)$, $(-3, 1, -1)$. The sum of the squares of their Manhattan distances to the origin is $5^2 \\times 12 = 300$.\n\nConstraints:\n- For $20\\%$ of the testdata, $a = b \\le 100$.\n- For another $40\\%$ of the testdata, $a, b \\le 3 \\times 10^5$.\n- For $100\\%$ of the testdata, $1 \\le a, b \\le 3 \\times 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "曲面", "background": "xht喜欢研究数学函数，他特别喜欢反比例函数。\n", "description": "我们知道，反比例函数xy=a的图象是双曲线。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4375.png) \n\nxht于是想：把它推广到三维是什么样的呢？\n\n\n定义曲面C(k)为**方程xyz=k所确定的曲面**。\n\n\n又定义曲面的美观程度P(k)为曲面C(k)上所有**整点**（x,y,z坐标均为整数）到原点的曼哈顿距离的**平方**之和。\n\n\n（点（x,y,z）到原点的曼哈顿距离为|x|+|y|+|z|）。\n\n现在，xht把一些曲面{C(a),C(a+1)...C(b)}排成一列，你要求出它们美观程度之**和**对10007取模的结果。\n", "inputFormat": "一行两个正整数数a，b\n", "outputFormat": "一行一个数\n\n![](https://cdn.luogu.com.cn/upload/pic/4376.png)\n", "hint": "样例1的解释：\n\n\n在曲面xyz=3上共有12个整点(1,1,3),(1,3,1),(3,1,1),(-1-1,3),(-1,-3,1),(-3,-1,1),(1,-1,-3),(1,-3,-1),(3,-1,-1),(-1,1,-3),(-1,3,-1),(-3,1,-1)。它们到原点的曼哈顿距离的平方之和为5^2\\*12=300。\n\n\n对于20%的数据，a=b<=100\n\n对于另外40%的数据，a,b<=3\\*10^5\n\n对于100%的数据，1<=a,b<=3\\*10^8\n", "locale": "zh-CN"}}}
{"pid": "P3637", "type": "P", "difficulty": 6, "samples": [["3 2 100 3\n1 2 1\n2 3 2\n3 1 3 0\n2 1 2\n3 1 3 0", "97\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": [], "title": "方程组", "background": "从小学开始，我们就一直做各种各样的应用题，其中大多数的题目都可以抽象为解方程组。\n\n为了提高效率，省下时间~~打隔膜~~学习OI，xht 准备开发一个自动解题器。其中的一个核心组件就是解方程组的程序，xht 决定将这个任务交给你。", "description": "一开始，xht 有 $N$ 个变量，记为 $x_1,x_2,\\cdots,x_n$。另有一个常数 $K$，以及 $M$ 个方程，每个方程都形如 $x_a-x_b≡c\\pmod K$。\n\n由于题目可能会变化，xht 需要不时增加一个新的方程，或者删掉一个方程。\n\n同时，xht 会给你一些这样的询问：令变量 $x_a=c$，求另一个变量 $x_b \\bmod K$ 的值。当然，有的时候会因为条件不足，无法解出 $x_b$，那么就输出 $-1$。\n\n数据保证任意时刻两个变量之间最多存在一个方程。保证不会出现自相矛盾的方程组，也不会出现多余的条件（某个方程可以通过其他一些方程推出来）。", "inputFormat": "第一行四个整数 $N,M,K,Q$，含义如上。$Q$ 代表操作的条数。\n\n接下来 $M$ 行，每行三个整数 $a,b,c$，表示方程 $x_a-x_b≡c\\pmod K$。\n\n接下来 $Q$ 行，每行第一个数 $t$ 代表操作种类，\n\n\\* $t=1$，接下来输入 $a,b,c$，代表增加一条方程 $x_a-x_b≡c\\pmod K$；\n\n\\* $t=2$，接下来输入 $a,b$，代表删除 $a,b$ 之间的方程，如果这条方程不存在，则什么也不做；\n\n\\* $t=3$，接下来输入 $a,b,c$，代表询问：令 $x_a=c$，求 $x_b \\bmod K$ 的值；", "outputFormat": "对于每一个 $3$ 操作（询问），输出一行一个数 $x$（$0\\le x<K$），表示 $x_b \\bmod K$，如果条件不足，则输出 $-1$。", "hint": "样例的解释：\n\n一开始有两条方程：$x_1-x_2=1$，$x_2-x_3=2$。\n\n第一次询问，令$x_1=0$，解得$x_3=(-3)\\bmod100=97$。\n\n第二次询问时，删掉了第二条方程，导致条件不足，无法解出 $x_3$，输出 $-1$。\n\n对于 $40\\%$ 的数据，只有询问操作。\n\n对于 $100\\%$ 的数据，$1\\le M<N\\le10^5$，$1\\le Q\\le10^5$，$2\\le K\\le10^3$，$1\\le a,b\\le N$，$0\\le c<K$。\n\n保证所有的 $a\\ne b$。", "locale": "zh-CN", "translations": {"en": {"title": "System of Equations", "background": "Since primary school, we have been doing all kinds of word problems, most of which can be abstracted as solving systems of equations.\n\nTo improve efficiency and save time to ~~play games~~ study OI, xht plans to develop an automatic problem solver. One of its core components is a program for solving systems of equations, and xht has decided to assign this task to you.", "description": "Initially, xht has $N$ variables, denoted by $x_1,x_2,\\cdots,x_n$. There is also a constant $K$, and $M$ equations, each of the form $x_a-x_b≡c\\pmod K$.\n\nSince the problem may change, xht sometimes needs to add a new equation or delete an existing one.\n\nAt the same time, xht will give you some queries: set the variable $x_a=c$, and find the value of another variable $x_b \\bmod K$. Of course, sometimes $x_b$ cannot be determined due to insufficient conditions; in that case, output $-1$.\n\nThe testdata guarantees that at any time there is at most one equation between any two variables. It is guaranteed that no contradictory systems will appear, and no redundant conditions will appear (no equation can be derived from some others).\n\n# Description", "inputFormat": "The first line contains four integers $N,M,K,Q$, as described above. $Q$ is the number of operations.\n\nThe next $M$ lines each contain three integers $a,b,c$, representing the equation $x_a-x_b≡c\\pmod K$.\n\nThe next $Q$ lines, each starting with an integer $t$ indicating the type of operation:\n\n- $t=1$: followed by $a,b,c$, meaning to add an equation $x_a-x_b≡c\\pmod K$;\n- $t=2$: followed by $a,b$, meaning to delete the equation between $a$ and $b$. If this equation does not exist, do nothing;\n- $t=3$: followed by $a,b,c$, meaning a query: set $x_a=c$, and ask for the value of $x_b \\bmod K$.", "outputFormat": "For each operation of type $3$ (query), output one integer $x$ ($0\\le x<K$), representing $x_b \\bmod K$. If the conditions are insufficient, output $-1$.", "hint": "Explanation of the sample:\n\nInitially there are two equations: $x_1-x_2=1$, $x_2-x_3=2$.\n\nIn the first query, set $x_1=0$, and obtain $x_3=(-3)\\bmod100=97$.\n\nIn the second query, the second equation has been deleted, leading to insufficient conditions, so $x_3$ cannot be determined. Output $-1$.\n\nFor $40\\%$ of the testdata, there are only query operations.\n\nFor $100\\%$ of the testdata, $1\\le M<N\\le10^5$, $1\\le Q\\le10^5$, $2\\le K\\le10^3$, $1\\le a,b\\le N$, $0\\le c<K$.\n\nIt is guaranteed that all $a\\ne b$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "方程组", "background": "从小学开始，我们就一直做各种各样的应用题，其中大多数的题目都可以抽象为解方程组。\n\n为了提高效率，省下时间~~打隔膜~~学习OI，xht 准备开发一个自动解题器。其中的一个核心组件就是解方程组的程序，xht 决定将这个任务交给你。", "description": "一开始，xht 有 $N$ 个变量，记为 $x_1,x_2,\\cdots,x_n$。另有一个常数 $K$，以及 $M$ 个方程，每个方程都形如 $x_a-x_b≡c\\pmod K$。\n\n由于题目可能会变化，xht 需要不时增加一个新的方程，或者删掉一个方程。\n\n同时，xht 会给你一些这样的询问：令变量 $x_a=c$，求另一个变量 $x_b \\bmod K$ 的值。当然，有的时候会因为条件不足，无法解出 $x_b$，那么就输出 $-1$。\n\n数据保证任意时刻两个变量之间最多存在一个方程。保证不会出现自相矛盾的方程组，也不会出现多余的条件（某个方程可以通过其他一些方程推出来）。", "inputFormat": "第一行四个整数 $N,M,K,Q$，含义如上。$Q$ 代表操作的条数。\n\n接下来 $M$ 行，每行三个整数 $a,b,c$，表示方程 $x_a-x_b≡c\\pmod K$。\n\n接下来 $Q$ 行，每行第一个数 $t$ 代表操作种类，\n\n\\* $t=1$，接下来输入 $a,b,c$，代表增加一条方程 $x_a-x_b≡c\\pmod K$；\n\n\\* $t=2$，接下来输入 $a,b$，代表删除 $a,b$ 之间的方程，如果这条方程不存在，则什么也不做；\n\n\\* $t=3$，接下来输入 $a,b,c$，代表询问：令 $x_a=c$，求 $x_b \\bmod K$ 的值；", "outputFormat": "对于每一个 $3$ 操作（询问），输出一行一个数 $x$（$0\\le x<K$），表示 $x_b \\bmod K$，如果条件不足，则输出 $-1$。", "hint": "样例的解释：\n\n一开始有两条方程：$x_1-x_2=1$，$x_2-x_3=2$。\n\n第一次询问，令$x_1=0$，解得$x_3=(-3)\\bmod100=97$。\n\n第二次询问时，删掉了第二条方程，导致条件不足，无法解出 $x_3$，输出 $-1$。\n\n对于 $40\\%$ 的数据，只有询问操作。\n\n对于 $100\\%$ 的数据，$1\\le M<N\\le10^5$，$1\\le Q\\le10^5$，$2\\le K\\le10^3$，$1\\le a,b\\le N$，$0\\le c<K$。\n\n保证所有的 $a\\ne b$。", "locale": "zh-CN"}}}
{"pid": "P3638", "type": "P", "difficulty": 6, "samples": [["4 10 5 \n1.........\nAA...x4...\n..A..x....\n2....x....\n..C.3.A...", "5"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["搜索", "2013", "APIO", "记忆化搜索", "队列"], "title": "[APIO2013] 机器人", "background": null, "description": "VRI（Voltron 机器人学会）的工程师建造了 n 个机器人。任意两个兼容的机器人站在同一个格子时可以合并为一个复合机器人。\n\n我们把机器人用 1 至 n 编号（n ≤ 9）。如果两个机器人的编号是连续的，那么它们是兼容的，可以合并成一个复合机器人。最初这 n 个机器人各自都只有唯一的编号。而一个由两个或以上的机器人合并构成的复合机器人拥有两个编号，分别是构成它的所有机器人中最小和最大的编号。\n\n例如，2 号机器人只可以与 1 号或 3 号机器人合并。若 2 号机器人与 3 号机器人合并，可构成编号为 2-3 的复合机器人。如果编号为 2-3 的复合机器人与编 号为 4-6 的复合机器人合并，可构成编号为 2-6 的复合机器人。当所有机器人合并以后则构成 1-n 复合机器人。\n\n工程师把这 n 个机器人放在了一个封闭的房间中，房间四周均是墙。该房间被划分成 w × h 个方格。有些方格有障碍物，机器人不可经过或停留；其余方格允许多个机器人停留，同时允许机器人经过。任何时候一个机器人只占用一个方格。初始时刻，所有机器人均在不同的方格中。\n\n这些原始的机器人不会自发地移动。它们只有被工程师沿 x 轴或 y 轴推动后，才会沿推动的方向不断向前直线移动，直至碰到障碍物或墙停止移动。停止移动后，它会扫描当前的格子是否存在可以与它合并的机器人，如果有，则合并并继续检查，直至不能再合并为止。工程师只能沿水平向左、水平向右、竖直向上、竖直向下四个方向推动机器人，并且，在机器人尚未停止移动时，不允许推动其它机器人，因此任何时刻，房间中都只能有一个机器人移动。\n\n为了帮助机器人转向，工程师在一些格子中放置了转向器。具体地说，转向器分为顺时针转向器（右转器）和逆时针转向器（左转器），顺时针转向器可以使到达该格子的机器人沿顺时针方向转向 90°；逆时针转向器可以使到达该格子的机器人沿逆时针方向转向 90°。\n\n现在，我们将告诉你初始时刻房间内的信息。请你计算工程师最少共计需要推动机器人多少次，才能把所有的 n 个机器人全部合并（如果可能的话）。", "inputFormat": "你的程序必须从标准输入读入。\n\n输入的第 1 行包含 3 个整数 n、w 和 h，用 空格隔开。\n\n输入文件中接下来的 h 行描述初始时刻房间内的信息，每行包含 w 个字符。 这 w × h 个字符中每一个表示房间中的一个格子，意义如下：\n\n‘1’至‘9’：表示该方格中有一个机器人，编号为这个数字；\n\n‘x’：表示该方格有障碍物；\n\n‘A’：表示该方格中有一个逆时针转向器；\n\n‘C’：表示该方格中有一个顺时针转向器；\n\n‘.’：表示该方格为空地。", "outputFormat": "你的程序必须输出到标准输出。输出仅一个整数，表示最少需要推动的次数。 若不能使所有机器人全部合并，输出-1。", "hint": "第一步：向右推动 3 号机器人，当它碰到转向器后会向上继续移动，直至碰 到墙壁停止移动。\n\n第二步：向上推动 4 号机器人，当它碰到墙壁后停止移动，与 3 号机器人合 并，构成 3-4 号机器人\n\n第三步：向上推动 2 号机器人，当它碰到转向器后会向左移动，由于左侧为 墙壁，故停留在原地。\n\n第四步：向右推动 2 号机器人，由于它在一个转向器上，故它会向上移动， 直至碰到墙壁停止移动，与 1 号机器人合并，构成 1-2 号机器人。\n\n第五步：向左推动 3-4 号机器人，当它碰到墙壁后停止移动，与 1-2 号机器 人合并，构成 1-4 号机器人。\n\n\n我们将使用以下 4 类输入测例测试你的程序。\n\n1. （10 分）测例满足 n = 2，w ≤ 10 且 h ≤ 10，没有任何转向器。\n\n2. （20 分）测例满足 n = 2，w ≤ 10 且 h ≤ 10。\n\n3. （30 分）测例满足 n ≤ 9，w ≤ 300 且 h ≤ 300。\n\n4. （40 分）测例满足 n ≤ 9，w ≤ 500 且 h ≤ 500。", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2013] Robots", "background": "", "description": "Engineers of VRI (Voltron Robotics Institute) built $n$ robots. Any two compatible robots standing in the same cell can merge into a composite robot.\n\nWe number the robots from $1$ to $n$ ($n \\le 9$). Two robots are compatible if their numbers are consecutive, in which case they can merge into a composite robot. Initially, each of the $n$ robots has a unique number. A composite robot formed by two or more robots carries two numbers: the minimum and maximum among the numbers of all robots that compose it.\n\nFor example, robot $2$ can merge only with robot $1$ or robot $3$. If robot $2$ merges with robot $3$, they form the composite robot $2$–$3$. If the composite robot $2$–$3$ merges with the composite robot $4$–$6$, they form the composite robot $2$–$6$. Once all robots have merged, they form the composite robot $1$–$n$.\n\nThe engineers placed these $n$ robots in a closed room bounded by walls. The room is divided into $w \\times h$ grid cells. Some cells contain obstacles that robots cannot pass through or stop on; other cells allow multiple robots to stop in or pass through. At any time, a robot occupies exactly one cell. Initially, all robots are in distinct cells.\n\nThese original robots do not move on their own. They only move when an engineer pushes them along the $x$-axis or $y$-axis. After being pushed, a robot continues moving straight in that direction until it hits an obstacle or a wall, where it stops. After stopping, it checks whether there are robots in the current cell that it can merge with; if so, it merges and continues checking until no further merge is possible. Engineers may push robots only in four directions: left, right, up, and down. Also, while a robot is still moving, no other robot may be pushed; therefore, at any moment, at most one robot is moving in the room.\n\nTo help robots turn, the engineers placed turners in some cells. Specifically, there are clockwise turners (right-turners) and counterclockwise turners (left-turners). A clockwise turner makes a robot that arrives at that cell turn $90^\\circ$ clockwise; a counterclockwise turner makes it turn $90^\\circ$ counterclockwise.\n\nGiven the initial state of the room, compute the minimum number of pushes needed to merge all $n$ robots (if possible).", "inputFormat": "Your program must read from standard input.\n\nThe first line contains three integers $n$, $w$, and $h$, separated by spaces.\n\nEach of the next $h$ lines describes the initial state of the room and contains $w$ characters. Each of these $w \\times h$ characters represents one cell of the room, with the following meanings:\n- '1' to '9': there is a robot in this cell with that number.\n- 'x': there is an obstacle in this cell.\n- 'A': there is a counterclockwise turner in this cell.\n- 'C': there is a clockwise turner in this cell.\n- '.': this cell is empty.", "outputFormat": "Your program must write to standard output. Output a single integer: the minimum number of pushes required. If it is impossible to merge all robots, output -1.", "hint": "Step 1: Push robot 3 to the right. After it hits a turner, it will continue moving upward until it hits the wall and stops.\n\nStep 2: Push robot 4 upward. After it hits the wall, it stops and merges with robot 3 to form the composite robot 3–4.\n\nStep 3: Push robot 2 upward. After it hits a turner, it moves left. Because there is a wall to the left, it stays in place.\n\nStep 4: Push robot 2 to the right. Since it is on a turner, it will move upward until it hits the wall and stops, then merges with robot 1 to form the composite robot 1–2.\n\nStep 5: Push the composite robot 3–4 to the left. After it hits the wall, it stops and merges with the composite robot 1–2 to form the composite robot 1–4.\n\nWe will use the following four classes of input test cases to test your program.\n1. (10 points) $n = 2$, $w \\le 10$, $h \\le 10$, with no turners.\n2. (20 points) $n = 2$, $w \\le 10$, $h \\le 10$.\n3. (30 points) $n \\le 9$, $w \\le 300$, $h \\le 300$.\n4. (40 points) $n \\le 9$, $w \\le 500$, $h \\le 500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2013] 机器人", "background": null, "description": "VRI（Voltron 机器人学会）的工程师建造了 n 个机器人。任意两个兼容的机器人站在同一个格子时可以合并为一个复合机器人。\n\n我们把机器人用 1 至 n 编号（n ≤ 9）。如果两个机器人的编号是连续的，那么它们是兼容的，可以合并成一个复合机器人。最初这 n 个机器人各自都只有唯一的编号。而一个由两个或以上的机器人合并构成的复合机器人拥有两个编号，分别是构成它的所有机器人中最小和最大的编号。\n\n例如，2 号机器人只可以与 1 号或 3 号机器人合并。若 2 号机器人与 3 号机器人合并，可构成编号为 2-3 的复合机器人。如果编号为 2-3 的复合机器人与编 号为 4-6 的复合机器人合并，可构成编号为 2-6 的复合机器人。当所有机器人合并以后则构成 1-n 复合机器人。\n\n工程师把这 n 个机器人放在了一个封闭的房间中，房间四周均是墙。该房间被划分成 w × h 个方格。有些方格有障碍物，机器人不可经过或停留；其余方格允许多个机器人停留，同时允许机器人经过。任何时候一个机器人只占用一个方格。初始时刻，所有机器人均在不同的方格中。\n\n这些原始的机器人不会自发地移动。它们只有被工程师沿 x 轴或 y 轴推动后，才会沿推动的方向不断向前直线移动，直至碰到障碍物或墙停止移动。停止移动后，它会扫描当前的格子是否存在可以与它合并的机器人，如果有，则合并并继续检查，直至不能再合并为止。工程师只能沿水平向左、水平向右、竖直向上、竖直向下四个方向推动机器人，并且，在机器人尚未停止移动时，不允许推动其它机器人，因此任何时刻，房间中都只能有一个机器人移动。\n\n为了帮助机器人转向，工程师在一些格子中放置了转向器。具体地说，转向器分为顺时针转向器（右转器）和逆时针转向器（左转器），顺时针转向器可以使到达该格子的机器人沿顺时针方向转向 90°；逆时针转向器可以使到达该格子的机器人沿逆时针方向转向 90°。\n\n现在，我们将告诉你初始时刻房间内的信息。请你计算工程师最少共计需要推动机器人多少次，才能把所有的 n 个机器人全部合并（如果可能的话）。", "inputFormat": "你的程序必须从标准输入读入。\n\n输入的第 1 行包含 3 个整数 n、w 和 h，用 空格隔开。\n\n输入文件中接下来的 h 行描述初始时刻房间内的信息，每行包含 w 个字符。 这 w × h 个字符中每一个表示房间中的一个格子，意义如下：\n\n‘1’至‘9’：表示该方格中有一个机器人，编号为这个数字；\n\n‘x’：表示该方格有障碍物；\n\n‘A’：表示该方格中有一个逆时针转向器；\n\n‘C’：表示该方格中有一个顺时针转向器；\n\n‘.’：表示该方格为空地。", "outputFormat": "你的程序必须输出到标准输出。输出仅一个整数，表示最少需要推动的次数。 若不能使所有机器人全部合并，输出-1。", "hint": "第一步：向右推动 3 号机器人，当它碰到转向器后会向上继续移动，直至碰 到墙壁停止移动。\n\n第二步：向上推动 4 号机器人，当它碰到墙壁后停止移动，与 3 号机器人合 并，构成 3-4 号机器人\n\n第三步：向上推动 2 号机器人，当它碰到转向器后会向左移动，由于左侧为 墙壁，故停留在原地。\n\n第四步：向右推动 2 号机器人，由于它在一个转向器上，故它会向上移动， 直至碰到墙壁停止移动，与 1 号机器人合并，构成 1-2 号机器人。\n\n第五步：向左推动 3-4 号机器人，当它碰到墙壁后停止移动，与 1-2 号机器 人合并，构成 1-4 号机器人。\n\n\n我们将使用以下 4 类输入测例测试你的程序。\n\n1. （10 分）测例满足 n = 2，w ≤ 10 且 h ≤ 10，没有任何转向器。\n\n2. （20 分）测例满足 n = 2，w ≤ 10 且 h ≤ 10。\n\n3. （30 分）测例满足 n ≤ 9，w ≤ 300 且 h ≤ 300。\n\n4. （40 分）测例满足 n ≤ 9，w ≤ 500 且 h ≤ 500。", "locale": "zh-CN"}}}
{"pid": "P3639", "type": "P", "difficulty": 6, "samples": [["5 5 1 \n3 5 2 \n1 2 3 \n2 3 5 \n2 4 4 \n4 3 6 \n1 3 \n10 20 30 40 50", "400"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "APIO", "生成树", "连通块"], "title": "[APIO2013] 道路费用", "background": null, "description": "幸福国度可以用 $N$ 个城镇（用 $1$ 到 $N$ 编号）构成的集合来描述，这些城镇 最开始由 $M$ 条双向道路（用 $1$ 到 $M$ 编号）连接。城镇 $1$ 是中央城镇。保证一个人从城镇 $1$ 出发，经过这些道路，可以到达其他的任何一个城市。这些道路都是收费道路，道路 $i$ 的使用者必须向道路的主人支付 $c_i$ 分钱的费用。已知所有的这些 $c_i$ 是互不相等的。最近有 $K$ 条新道路建成，这些道路都属于亿万富豪 $\\text{Mr. Greedy}$。$\\text{Mr. Greedy}$ 可以决定每条新道路的费用（费用可以相同），并且他必须在明天宣布这些费用。\n\n两周以后，幸福国度将举办一个盛况空前的嘉年华！大量的参与者将沿着这些道路前往中央城镇。共计 $p_j$ 个参与者将从城镇 $j$ 出发前往中央城镇。这些人只会沿着一个选出的道路集合前行，并且这些选出的道路将在这件事的前一天公布。根据一个古老的习俗，这些道路将由幸福国度中最有钱的人选出，也就是 $\\text{Mr. Greedy}$。同样根据这个习俗，$\\text{Mr. Greedy}$ 选出的这个道路集合必须使所有选出道路的费用之和最小，并且仍要保证任何人可以从城镇 $j$ 前往城镇 $1$（因此， 这些选出的道路来自将费用作为相应边边权的“最小生成树”）。如果有多个这样的道路集合，$\\text{Mr. Greedy}$ 可以选其中的任何一个，只要满足费用和是最小的。\n\n$\\text{Mr. Greedy}$ 很明确地知道，他从 $K$ 条新道路中获得的收入不只是与费用有关。一条道路的收入等于所有经过这条路的人的花费之和。更准确地讲，如果 $p$ 个人经过道路 $i$，道路 $i$ 产生的收入为 $c_i \\times p$ 的积。注意 $\\text{Mr. Greedy}$ 只能从新道路收取费用，因为原来的道路都不属于他。\n\n$\\text{Mr. Greedy}$ 有一个阴谋。他计划通过操纵费用和道路的选择来最大化他的收入。他希望指定每条新道路的费用（将在明天公布），并且选择嘉年华用的道路（将在嘉年华的前一天公布），使得他在 $K$ 条新道路的收入最大。注意 $\\text{Mr. Greedy}$ 仍然需要遵循选出花费之和最小的道路集合的习俗。\n\n你是一个记者，你想揭露他的计划。为了做成这件事，你必须先写一个程序来确定 $\\text{Mr. Greedy}$ 可以通过他的阴谋获取多少收入。", "inputFormat": "你的程序必须从标准输入读入。第一行包含三个由空格隔开的整数 $N,M,K$。接下来的 $M$ 行描述最开始的 $M$ 条道路。这 $M$ 行中的第 $i$ 行包含由空格隔开的整数 $a_i,b_i,c_i$，表示有一条在 $a_i$ 和 $b_i$ 之间，费用为 $c_i$ 的双向道路。接下来的 $K$ 行描述新建的 $K$ 条道路。这 $K$ 行中的第 $i$ 行包含由空格隔开的整数 $x_i$ 和 $y_i$，表示有一条连接城镇 $x_i$ 和 $y_i$ 的新道路。最后一行包含 $N$ 个由空格隔开的整数，其中的第 $j$ 个为 $p_j$，表示从城镇 $j$ 前往城镇 $1$ 的人数。\n\n输入也满足以下约束条件：$1 \\leq N \\leq 10^5,1 \\leq K \\leq 20,1 \\leq M \\leq 3\\times 10^5$，对每个 $i$ 和 $j$，$1 \\leq c_i,p_j \\leq 10^6$，如果 $i \\neq i'$，则 $c_i \\neq c_{i'}$； \n\n在任意两个城市之间，最多只有一条道路（包括新建的道路）。", "outputFormat": "你的程序必须输出恰好一个整数到标准输出，表示能获得的最大的收入。", "hint": "在样例中，$\\text{Mr. Greedy}$ 应该将新道路 $(1,3)$ 的费用设置为 $5$ 分钱。在这个费用下，他可以选择道路 $(3,5),(1,2),(2,4),(1,3)$ 来最小化总费用，这个费用为 $14$。 从城镇 $3$ 出发的 $30$ 个人和从城镇 $5$ 出发的 $50$ 个人将经过新道路前往城镇 $1$，因此他可以获得为 $(30+50)×5=400$ 分钱的最好收入。\n\n如果我们这样做，将新道路 $(1,3)$ 的费用设置为 $10$ 分钱。根据传统的限制，$\\text{Mr. Greedy}$ 必须选择 $(3,5),(1,2),(2,4),(2,3)$，因为这是唯一费用最小的集合。 因此，在嘉年华的过程中道路 $(1,3)$ 将没有任何收入。\n\n\n我们将使用以下 $5$ 类测例测试你的程序。\n\n1. （国际 $16$ 分，国内 $15$ 分）$N ≤ 10,M ≤ 20,K = 1$；\n\n2. （国际 $18$ 分，国内 $20$ 分）$N ≤ 30,M ≤ 50, K ≤ 10$；\n\n3. （国际 $22$ 分，国内 $20$ 分）$N ≤ 10^3,M ≤ 5\\times 10^3,K ≤ 10$;\n\n4. （国际 $22$ 分，国内 $20$ 分）$N ≤ 10^5,M ≤ 3\\times 10^5, K ≤ 15$；\n\n5. （国际 $22$ 分，国内 $25$ 分）$N ≤ 10^5，M ≤ 3\\times 10^5, K ≤ 20$。\n\n**update: 2024/07/04 删除了两个测试点，并且改为捆绑。**", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2013] Toll", "background": "", "description": "The Kingdom of Happiness can be described as a set of $N$ towns (numbered $1$ to $N$), initially connected by $M$ bidirectional roads (numbered $1$ to $M$). Town $1$ is the central town. It is guaranteed that starting from town $1$, one can reach any other town using these roads. All roads are toll roads: for road $i$, a user must pay $c_i$ cents to the road’s owner. It is known that all $c_i$ are pairwise distinct. Recently, $K$ new roads were built, all owned by $\\text{Mr. Greedy}$. $\\text{Mr. Greedy}$ can decide the toll for each new road (these tolls may be equal), and he must announce these tolls tomorrow.\n\nTwo weeks later, the Kingdom of Happiness will host a grand carnival. A large number of participants will travel along the roads to the central town. In total, $p_j$ participants will start from town $j$ and head to town $1$. These people will travel only along a selected set of roads, and this selected set of roads will be announced the day before the event. According to an ancient custom, this set is chosen by the richest person in the kingdom, namely $\\text{Mr. Greedy}$. By the same custom, the chosen set must minimize the sum of tolls of all selected roads and still ensure that everyone can travel from town $j$ to town $1$ (therefore, the selected roads form a “minimum spanning tree” with respect to the tolls as edge weights). If there are multiple such sets, $\\text{Mr. Greedy}$ may choose any of them, as long as the total toll is minimal.\n\n$\\text{Mr. Greedy}$ understands clearly that his revenue from the $K$ new roads depends not only on the toll values. The revenue of a road equals the total amount paid by all people who pass through it. More precisely, if $p$ people pass through road $i$, the revenue of road $i$ is the product $c_i \\times p$. Note that $\\text{Mr. Greedy}$ can only collect tolls from the new roads, since the original roads are not his.\n\n$\\text{Mr. Greedy}$ has a scheme. He plans to maximize his revenue by manipulating the tolls and the choice of roads. He wants to set the toll for each new road (to be announced tomorrow) and choose the roads used for the carnival (to be announced the day before the carnival) so that his total revenue from the $K$ new roads is maximized. Note that $\\text{Mr. Greedy}$ must still follow the custom of selecting a road set with the minimum total toll.\n\nYou are a journalist and you want to expose his plan. To do this, you must first write a program to determine how much revenue $\\text{Mr. Greedy}$ can obtain through his scheme.", "inputFormat": "Your program must read from standard input. The first line contains three space-separated integers $N, M, K$. The next $M$ lines describe the initial $M$ roads. In these $M$ lines, the $i$-th line contains space-separated integers $a_i, b_i, c_i$, indicating a bidirectional road between $a_i$ and $b_i$ with toll $c_i$. The next $K$ lines describe the $K$ newly built roads. In these $K$ lines, the $i$-th line contains space-separated integers $x_i$ and $y_i$, indicating a new road connecting towns $x_i$ and $y_i$. The last line contains $N$ space-separated integers, where the $j$-th is $p_j$, the number of people traveling from town $j$ to town $1$.\n\nConstraints: $1 \\leq N \\leq 10^5, 1 \\leq K \\leq 20, 1 \\leq M \\leq 3 \\times 10^5$. For each $i$ and $j$, $1 \\leq c_i, p_j \\leq 10^6$, and if $i \\neq i'$, then $c_i \\neq c_{i'}$. Between any two towns, there is at most one road (including newly built roads).", "outputFormat": "Your program must output exactly one integer to standard output, which is the maximum obtainable revenue.", "hint": "In the sample, $\\text{Mr. Greedy}$ should set the toll of the new road $(1,3)$ to $5$ cents. With this toll, he can choose roads $(3,5), (1,2), (2,4), (1,3)$ to minimize the total toll, which is $14$. The $30$ people from town $3$ and the $50$ people from town $5$ will pass through the new road on their way to town $1$, so he can obtain the best revenue of $(30+50)×5=400$ cents.\n\nIf instead we set the toll of the new road $(1,3)$ to $10$ cents, then by the customary constraint $\\text{Mr. Greedy}$ must choose $(3,5), (1,2), (2,4), (2,3)$, because this is the unique set with minimum total toll. Therefore, during the carnival the road $(1,3)$ will bring no revenue.\n\nWe will use the following $5$ types of test cases to evaluate your program.\n\n1. (International $16$ points, Domestic $15$ points) $N \\leq 10, M \\leq 20, K = 1$.\n2. (International $18$ points, Domestic $20$ points) $N \\leq 30, M \\leq 50, K \\leq 10$.\n3. (International $22$ points, Domestic $20$ points) $N \\leq 10^3, M \\leq 5 \\times 10^3, K \\leq 10$.\n4. (International $22$ points, Domestic $20$ points) $N \\leq 10^5, M \\leq 3 \\times 10^5, K \\leq 15$.\n5. (International $22$ points, Domestic $25$ points) $N \\leq 10^5, M \\leq 3 \\times 10^5, K \\leq 20$.\n\nupdate: 2024/07/04 Two test points were removed, and the tests were changed to bundled.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2013] 道路费用", "background": null, "description": "幸福国度可以用 $N$ 个城镇（用 $1$ 到 $N$ 编号）构成的集合来描述，这些城镇 最开始由 $M$ 条双向道路（用 $1$ 到 $M$ 编号）连接。城镇 $1$ 是中央城镇。保证一个人从城镇 $1$ 出发，经过这些道路，可以到达其他的任何一个城市。这些道路都是收费道路，道路 $i$ 的使用者必须向道路的主人支付 $c_i$ 分钱的费用。已知所有的这些 $c_i$ 是互不相等的。最近有 $K$ 条新道路建成，这些道路都属于亿万富豪 $\\text{Mr. Greedy}$。$\\text{Mr. Greedy}$ 可以决定每条新道路的费用（费用可以相同），并且他必须在明天宣布这些费用。\n\n两周以后，幸福国度将举办一个盛况空前的嘉年华！大量的参与者将沿着这些道路前往中央城镇。共计 $p_j$ 个参与者将从城镇 $j$ 出发前往中央城镇。这些人只会沿着一个选出的道路集合前行，并且这些选出的道路将在这件事的前一天公布。根据一个古老的习俗，这些道路将由幸福国度中最有钱的人选出，也就是 $\\text{Mr. Greedy}$。同样根据这个习俗，$\\text{Mr. Greedy}$ 选出的这个道路集合必须使所有选出道路的费用之和最小，并且仍要保证任何人可以从城镇 $j$ 前往城镇 $1$（因此， 这些选出的道路来自将费用作为相应边边权的“最小生成树”）。如果有多个这样的道路集合，$\\text{Mr. Greedy}$ 可以选其中的任何一个，只要满足费用和是最小的。\n\n$\\text{Mr. Greedy}$ 很明确地知道，他从 $K$ 条新道路中获得的收入不只是与费用有关。一条道路的收入等于所有经过这条路的人的花费之和。更准确地讲，如果 $p$ 个人经过道路 $i$，道路 $i$ 产生的收入为 $c_i \\times p$ 的积。注意 $\\text{Mr. Greedy}$ 只能从新道路收取费用，因为原来的道路都不属于他。\n\n$\\text{Mr. Greedy}$ 有一个阴谋。他计划通过操纵费用和道路的选择来最大化他的收入。他希望指定每条新道路的费用（将在明天公布），并且选择嘉年华用的道路（将在嘉年华的前一天公布），使得他在 $K$ 条新道路的收入最大。注意 $\\text{Mr. Greedy}$ 仍然需要遵循选出花费之和最小的道路集合的习俗。\n\n你是一个记者，你想揭露他的计划。为了做成这件事，你必须先写一个程序来确定 $\\text{Mr. Greedy}$ 可以通过他的阴谋获取多少收入。", "inputFormat": "你的程序必须从标准输入读入。第一行包含三个由空格隔开的整数 $N,M,K$。接下来的 $M$ 行描述最开始的 $M$ 条道路。这 $M$ 行中的第 $i$ 行包含由空格隔开的整数 $a_i,b_i,c_i$，表示有一条在 $a_i$ 和 $b_i$ 之间，费用为 $c_i$ 的双向道路。接下来的 $K$ 行描述新建的 $K$ 条道路。这 $K$ 行中的第 $i$ 行包含由空格隔开的整数 $x_i$ 和 $y_i$，表示有一条连接城镇 $x_i$ 和 $y_i$ 的新道路。最后一行包含 $N$ 个由空格隔开的整数，其中的第 $j$ 个为 $p_j$，表示从城镇 $j$ 前往城镇 $1$ 的人数。\n\n输入也满足以下约束条件：$1 \\leq N \\leq 10^5,1 \\leq K \\leq 20,1 \\leq M \\leq 3\\times 10^5$，对每个 $i$ 和 $j$，$1 \\leq c_i,p_j \\leq 10^6$，如果 $i \\neq i'$，则 $c_i \\neq c_{i'}$； \n\n在任意两个城市之间，最多只有一条道路（包括新建的道路）。", "outputFormat": "你的程序必须输出恰好一个整数到标准输出，表示能获得的最大的收入。", "hint": "在样例中，$\\text{Mr. Greedy}$ 应该将新道路 $(1,3)$ 的费用设置为 $5$ 分钱。在这个费用下，他可以选择道路 $(3,5),(1,2),(2,4),(1,3)$ 来最小化总费用，这个费用为 $14$。 从城镇 $3$ 出发的 $30$ 个人和从城镇 $5$ 出发的 $50$ 个人将经过新道路前往城镇 $1$，因此他可以获得为 $(30+50)×5=400$ 分钱的最好收入。\n\n如果我们这样做，将新道路 $(1,3)$ 的费用设置为 $10$ 分钱。根据传统的限制，$\\text{Mr. Greedy}$ 必须选择 $(3,5),(1,2),(2,4),(2,3)$，因为这是唯一费用最小的集合。 因此，在嘉年华的过程中道路 $(1,3)$ 将没有任何收入。\n\n\n我们将使用以下 $5$ 类测例测试你的程序。\n\n1. （国际 $16$ 分，国内 $15$ 分）$N ≤ 10,M ≤ 20,K = 1$；\n\n2. （国际 $18$ 分，国内 $20$ 分）$N ≤ 30,M ≤ 50, K ≤ 10$；\n\n3. （国际 $22$ 分，国内 $20$ 分）$N ≤ 10^3,M ≤ 5\\times 10^3,K ≤ 10$;\n\n4. （国际 $22$ 分，国内 $20$ 分）$N ≤ 10^5,M ≤ 3\\times 10^5, K ≤ 15$；\n\n5. （国际 $22$ 分，国内 $25$ 分）$N ≤ 10^5，M ≤ 3\\times 10^5, K ≤ 20$。\n\n**update: 2024/07/04 删除了两个测试点，并且改为捆绑。**", "locale": "zh-CN"}}}
{"pid": "P3640", "type": "P", "difficulty": 6, "samples": [["3\n2 1 4 2 1\n0\n1 1 2\n2\n0 1\n1 0\n//以上为问题1", "3\n1000000000\nThe value of counter is: 5"], ["4 5\n0 1\n0 2\n0 3\n1 2\n2 3\n//以上为问题2", "3\n0 1 2 1\nThe value of counter is: 18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "APIO", "提交答案", "Special Judge", "最短路", "构造"], "title": "[APIO2013] 出题人", "background": "", "description": "当今世界上各类程序设计竞赛层出不穷。而设计一场好比赛绝非易事，比如给题目设计测试数据就是一项挑战。一组好的测试数据需要对不同的程序有区分度：满足所有要求的程序自然应该得到满分，而那些貌似正确的程序则会在某些特殊数据上出错。\n\n在本题中，你在比赛中的角色反转啦！作为一名久经百战的程序员，你将帮助 Happy Programmer Contest 的命题委员会设计这次比赛的测试数据。本次比赛命题委员会选择了两个图论问题，分为 $8$ 个子任务。委员会写了一些貌似可以解决这些子任务的代码。在给任务设计数据的时候，命题委员会期望其中的一些源程序能够得到满分，而另外的一些则只能得到 $0$ 分或者少许的部分分。现在你将会获得这些源程序（C, C++, Pascal 版本）。对于每个子任务，你需要去产生一组数据 $X$ 使得它能将该任务给定的 $2$ 种源程序 $A$ 和 $B$ 区分开来。更具体地说，生成的数据必须满足如下两个条件:\n\n输入 $X$ 对于源程序 $A$ 一定不会出现超出时间限制（TLE）的问题。\n\n输入 $X$ 一定会导致源程序 $B$ 产生超出时间限制的问题。\n\n此外,命题委员喜欢较小规模的测试数据，希望测试数据最好能够包含不超过 $T$ 个整数。\n\n本题中只关心源程序 $A$ 和 $B$ 是否超时，不关心是否结果正确。\n\n命题委员会选择了单源最短路（SSSP）以及一个被称之为神秘问题（Mystery）的两个图论问题来作为比赛的题目。我们将命题委员会完成的伪代码列在了附录中，而具体的 C、C++ 和 Pascal 源程序被我们放在了下发的文件当中。\n\n### 子任务\n\n参见下表。表中每一行描述了一个子任务。其中前六个子任务与单源最短路相关，子任务 7,8 与神秘问题相关。每个任务所占分数见下表。\n\n ![](https://cdn.luogu.com.cn/upload/pic/4428.png) \n\n对于每个子任务，你的程序给出的输入 $X$ 需要能够将源程序 $A$ 和 $B$ 区分开来，这有这样你才能够得到相应的分数。具体说来，你的分数将由输入 $X$ 中数的个数决定。假设 $X$ 中包含了 $F$ 个整数，子任务的满分为 $S,T$ 是该任务的目标大小，则该测试点的分数将由下式给出:\n\n$$S \\times \\min\\{T / F, 1\\}$$\n\n也就是说，如果你的测试数据 $X$ 中含有不超过 $T$ 个整数，则你将得到该任务的全部得分。\n\n你需要把你的 $8$ 个测试数据命名为 `1.txt` ~ `8.txt`。对于每个子任务 $X$，评测系统将根据如下步骤来确定你将会得到多少分:\n\n- 如果未提交数据，则不得分；\n- 若数据不满足输入格式要求，则不得分；\n- 对源程序 $A$ 运行输入，若发生超时现象，则不得分；\n- 对源程序 $B$ 运行输入，若发生超时现象，则按照前文所述的公式给出该测试点的分数。\n\n题目提供的所有源代码均会维护一个计数器来统计程序的操作次数。在源程序的运行过程中，当该计数器超过了 $10^6$ 次时，那么我们认为程序运行超时。\n\n### 问题 1：单源最短路（SSSP）\n\n给定一个带权有向图 $G$，以及 $G$ 中的两个节点 $s$ 与 $t$，令 $p(s, t)$ 为 $G$ 中从 $s$ 至 $t$ 的最短路长度。如果 $s$ 与 $t$ 不连通，则认为 $p(s, t)=10^9$。在本题中，输入为图 $G$ 以及 $Q$ 个询问 $(s_1, t_1), (s_2, t_2), \\dots, (s_Q, t_Q)$ 。输出则是对这 $Q$ 个询问的相应输出 $p(s_1, t_1), p(s_2 , t_2), \\cdots, p(s_Q, t_Q)$。\n\n\n### 问题 2：神秘问题\n\n给定一个包含 $V$ 个节点 $E$ 条边的无向图 $G$，要求将所有的节点进行编号（编号范围为 $[0, X-1]$），使得所有直接相连的节点均有不同的编号。找出符合题意的最小的 $X$。\n", "inputFormat": "### 问题 1\n\n输入数据包含两部分，其中第一部分使用邻接表来描述带权有向图 $G$。第二部分则描述对 $G$ 的最短路径的查询。\n\n数据第一部分的第一行包含一个整数 $V$，表示 $G$ 中点的个数，所有点的编号为 $0, 1, \\cdots, V - 1$。\n\n接下来 $V$ 行，每行描述一个点的所有边。行中的第一个整数 $n_i$ 描述了节点 $i$ 的出边数量，接下来有 $n_i$ 个整数对 $(j, w)$ 表示有一条从 $i$ 到 $j$，边权为 $w$ 的边。\n\n数据第二部分的第一行包含一个整数 $Q$，表示询问的组数。\n\n接下来 $Q$ 行，第 $k$ 行包含两个整数 $s_k, t_k$，为该询问对应的起点与终点位置。\n\n同一行中任意两个相邻的整数均需要至少一个空格将他们分开。除此之外，数据还需满足如下条件:\n\n- $0 < V \\leq 300$，$n_i$ 是一个非负整数，$0 \\leq j < V$，$\\lvert w \\rvert < 10^6$，$0 \\leq \\sum\\limits_{i = 0}^{V-1} n_i \\leq 5000$，$0 < Q \\leq 10$，$0 \\leq s_k < V, 0 \\leq t_k < V$；\n- 图中没有负权圈。\n\n\n\n### 问题 2\n\n输入数据的第一行包含两个整数 $V$ 和 $E$。\n\n接下来 $E$ 行,每行两个整数 $a, b$，表示 $a$ 与 $b$ 在 $G$ 中直接相连。此外,输入数据应满足如下限制条件:\n\n- $70 < V < 1000$，$1500 < E < 10^6$；\n- 对于所有的边 $(a, b)$，有 $a \\neq b, 0 \\leq a < V, 0 \\leq b < V$，不会重复描述一条边。\n\n", "outputFormat": "### 问题 1\n\n程序将会输出 $Q$ 行，每行一个整数，表示对应的 $p(s_k , t_k)$。而在输出的最后，所有提供的程序都会给出计数器对此输入的数值。\n\n### 问题 2\n\n程序将在第一行输出 $X$，即最小的编号范围，接下来在第二行中给出 $V$ 个整数，依次描述节点 $0$ 至 $V - 1$ 的编号。在输出的最后，所有提供的程序都会给出计数器对此输入的数值。", "hint": "**源代码见附件**。\n\n### 附录：伪代码\n\n接下来是我们提供的所有程序的伪代码；变量 counter 近似描述出了程序的运行时间。评测时将会使用这些伪代码的 C++ 版本来进行评测。\n\n\nFloydWarshall\n\n```cpp\n// pre-condition: the graph is stored in an adjacency matrix M\ncounter = 0\nfor k = 0 to V-1\n    for i = 0 to V-1\n        for j = 0 to V-1\n            increase counter by 1;\n            M[i][j] = min(M[i][j], M[i][k] + M[k][j]);\nfor each query p(s,t)\n    output M[s][t];\n```\n\nOptimizedBellmanFord\n\n```cpp\n// pre-condition: the graph is stored in an adjacency list L\ncounter = 0\nfor each query p(s,t);\n    dist[s] = 0; // s is the source vertex\n    loop V-1 times\n        change = false;\n        for each edge (u,v) in L\n            increase counter by 1;\n            if dist[u] + weight(u,v) < dist[v]\n                dist[v] = dist[u] + weight(u,v);\n                change = true;\n        if change is false // this is the ’optimized’ Bellman Ford\n            break from the outermost loop;\n    output dist[t];\n```\n\nModifiedDijkstra\n\n```cpp\n// pre-condition: the graph is stored in an adjacency list L\ncounter = 0;\nfor each query p(s,t)\n    dist[s] = 0;\n    pq.push(pair(0, s)); // pq is a priority queue\n    while pq is not empty\n        increase counter by 1;\n        (d, u) = the top element of pq;\n        remove the top element from pq;\n        if (d == dist[u])\n            for each edge (u,v) in L\n                if (dist[u] + weight(u,v) ) < dist[v]\n                    dist[v] = dist[u] + weight(u,v);\n                    insert pair (dist[v], v) into the pq;\n    output dist[t];\n```\n\nGamble1\n\n```cpp\nSets X = V;\nlabels vertex i in [0..V-1] with i;\nSets counter = 0; // will never get TLE\n```\nGamble2\n\n```cpp\nSets X = V;\nlabels vertex i in [0..V-1] with i;\nSets counter = 1000001; // force this to get TLE\n```\n\nRecursiveBacktracking\n\n```cpp\nThis algorithm tries X from 2 to V one by one and stops at the first valid X.  \nFor each X, the backtracking routine label vertex 0 with 0, then for each vertex u that has been assigned a label, the backtracking routine tries to assign \nthe smallest possible label up to label X-1 to its neighbor v, and backtracks if necessary.  \n// Please check RecursiveBacktracking.cpp/pas to see \n// the exact lines where the iteration counter is increased by 1\n```\n\n感谢zhouyonglong修改spj\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2013] Problem Setter", "background": "", "description": "All kinds of programming contests are flourishing nowadays. Designing a good contest is by no means easy; for example, creating testdata for problems is a challenge. A good set of testdata should differentiate between different programs: programs that meet all requirements should naturally get full score, while those that look correct may fail on some special data.\n\nIn this problem, your role in the contest is reversed. As a seasoned programmer, you will help the Happy Programmer Contest problem-setting committee design the testdata for this contest. The committee chose two graph problems, split into $8$ subtasks. They wrote some code that seems to solve these subtasks. When designing testdata, the committee expects some of these source programs to receive full score, while others should get $0$ or only a small amount of partial score. You will be given these source programs (C, C++, Pascal versions). For each subtask, you need to produce a dataset $X$ that distinguishes the two given source programs $A$ and $B$ for that subtask. More specifically, the generated data must satisfy the following two conditions:\n\n- On input $X$, source program $A$ will definitely not exceed the time limit (TLE).\n- On input $X$, source program $B$ will definitely exceed the time limit (TLE).\n\nIn addition, the committee prefers small-scale testdata and hopes the testdata contains at most $T$ integers.\n\nIn this problem, we only care whether source programs $A$ and $B$ time out; we do not care whether their results are correct.\n\nThe problem-setting committee chose two graph problems as the contest tasks: Single-Source Shortest Path (SSSP) and a problem called the “Mystery” problem. We list the pseudocode completed by the committee in the appendix, and the specific C, C++ and Pascal source programs are included in the provided files.\n\nSubtasks\n\nSee the table below. Each row describes one subtask. The first six subtasks are related to SSSP, and subtasks 7 and 8 are related to the Mystery problem. The score of each subtask is shown in the table.\n\n![](https://cdn.luogu.com.cn/upload/pic/4428.png)\n\nFor each subtask, the input $X$ produced by your program must be able to distinguish the source programs $A$ and $B$ for that task; only then can you get the corresponding score. Specifically, your score is determined by the number of integers in $X$. Suppose $X$ contains $F$ integers, the full score of the subtask is $S$, and $T$ is the target size for that task. Then the score for this test will be given by:\n\n$$S \\times \\min\\{T / F, 1\\}.$$\n\nThat is, if your testdata $X$ contains at most $T$ integers, you will receive the full score for that subtask.\n\nYou need to name your $8$ test files as 1.txt ~ 8.txt. For each subtask data $X$, the judging system will determine your score according to the following steps:\n\n- If no data is submitted, you receive no score.\n- If the data does not meet the input format requirements, you receive no score.\n- Run source program $A$ on the input; if a timeout occurs, you receive no score.\n- Run source program $B$ on the input; if a timeout occurs, the score for this test is given by the formula above.\n\nAll provided source programs maintain a counter to count the number of operations performed by the program. During execution, when this counter exceeds $10^6$, we consider the program to have timed out.\n\nProblem 1: Single-Source Shortest Path (SSSP)\n\nGiven a weighted directed graph $G$ and two vertices $s$ and $t$ in $G$, let $p(s, t)$ be the length of the shortest path from $s$ to $t$ in $G$. If $s$ and $t$ are not connected, then $p(s, t) = 10^9$. In this problem, the input is the graph $G$ and $Q$ queries $(s_1, t_1), (s_2, t_2), \\dots, (s_Q, t_Q)$. The output is the corresponding values $p(s_1, t_1), p(s_2, t_2), \\cdots, p(s_Q, t_Q)$ for these $Q$ queries.\n\nProblem 2: Mystery\n\nGiven an undirected graph $G$ with $V$ vertices and $E$ edges, you are required to assign labels to all vertices (labels range from $[0, X-1]$), such that any two adjacent vertices have different labels. Find the minimum feasible $X$.\n\nAppendix: Pseudocode\n\nBelow is the pseudocode for all programs we provide; the variable counter roughly describes the running time of the programs. The C++ versions of these pseudocode programs will be used for judging.\n\nFloydWarshall\n\n```cpp\n// pre-condition: the graph is stored in an adjacency matrix M\ncounter = 0\nfor k = 0 to V-1\n    for i = 0 to V-1\n        for j = 0 to V-1\n            increase counter by 1;\n            M[i][j] = min(M[i][j], M[i][k] + M[k][j]);\nfor each query p(s,t)\n    output M[s][t];\n```\n\nOptimizedBellmanFord\n\n```cpp\n// pre-condition: the graph is stored in an adjacency list L\ncounter = 0\nfor each query p(s,t);\n    dist[s] = 0; // s is the source vertex\n    loop V-1 times\n        change = false;\n        for each edge (u,v) in L\n            increase counter by 1;\n            if dist[u] + weight(u,v) < dist[v]\n                dist[v] = dist[u] + weight(u,v);\n                change = true;\n        if change is false // this is the ’optimized’ Bellman Ford\n            break from the outermost loop;\n    output dist[t];\n```\n\nModifiedDijkstra\n\n```cpp\n// pre-condition: the graph is stored in an adjacency list L\ncounter = 0;\nfor each query p(s,t)\n    dist[s] = 0;\n    pq.push(pair(0, s)); // pq is a priority queue\n    while pq is not empty\n        increase counter by 1;\n        (d, u) = the top element of pq;\n        remove the top element from pq;\n        if (d == dist[u])\n            for each edge (u,v) in L\n                if (dist[u] + weight(u,v) ) < dist[v]\n                    dist[v] = dist[u] + weight(u,v);\n                    insert pair (dist[v], v) into the pq;\n    output dist[t];\n```\n\nGamble1\n\n```cpp\nSets X = V;\nlabels vertex i in [0..V-1] with i;\nSets counter = 0; // will never get TLE\n```\nGamble2\n\n```cpp\nSets X = V;\nlabels vertex i in [0..V-1] with i;\nSets counter = 1000001; // force this to get TLE\n```\n\nRecursiveBacktracking\n\n```cpp\nThis algorithm tries X from 2 to V one by one and stops at the first valid X.  \nFor each X, the backtracking routine label vertex 0 with 0, then for each vertex u that has been assigned a label, the backtracking routine tries to assign \nthe smallest possible label up to label X-1 to its neighbor v, and backtracks if necessary.  \n// Please check RecursiveBacktracking.cpp/pas to see \n// the exact lines where the iteration counter is increased by 1\n```", "inputFormat": "Problem 1\n\nThe input consists of two parts. The first part uses an adjacency list to describe the weighted directed graph $G$. The second part describes shortest path queries on $G$.\n\n- The first line of the first part contains an integer $V$, the number of vertices in $G$. All vertices are labeled $0, 1, \\cdots, V - 1$.\n- The next $V$ lines each describe all outgoing edges of one vertex. In the $i$-th line, the first integer $n_i$ is the out-degree of vertex $i$. Then there are $n_i$ integer pairs $(j, w)$, each indicating a directed edge from $i$ to $j$ with weight $w$.\n\nThe first line of the second part contains an integer $Q$, the number of queries.\n\nThen follow $Q$ lines. In the $k$-th line, there are two integers $s_k$ and $t_k$, the source and the target of that query.\n\nAny two adjacent integers on the same line must be separated by at least one space. In addition, the data must satisfy the following constraints:\n\n- $0 < V \\leq 300$, $n_i$ is a non-negative integer, $0 \\leq j < V$, $\\lvert w \\rvert < 10^6$, $0 \\leq \\sum\\limits_{i = 0}^{V-1} n_i \\leq 5000$, $0 < Q \\leq 10$, $0 \\leq s_k < V$, $0 \\leq t_k < V$.\n- The graph contains no negative-weight cycles.\n\nProblem 2\n\n- The first line contains two integers $V$ and $E$.\n- Then follow $E$ lines; each line contains two integers $a$ and $b$, indicating that $a$ and $b$ are adjacent in $G$.\n\nIn addition, the input must satisfy the following constraints:\n\n- $70 < V < 1000$, $1500 < E < 10^6$.\n- For every edge $(a, b)$, we have $a \\neq b$, $0 \\leq a < V$, $0 \\leq b < V$, and no edge is repeated.", "outputFormat": "Problem 1\n\nThe program will output $Q$ lines, one integer per line, representing the corresponding $p(s_k, t_k)$. At the very end, all provided programs will print the value of the counter for this input.\n\nProblem 2\n\nThe program will output $X$ in the first line, i.e., the minimum label range. In the second line, it will output $V$ integers, giving the labels of vertices $0$ to $V - 1$ in order. At the very end, all provided programs will print the value of the counter for this input.", "hint": "Source code is in the attachment.\n\nThanks to zhouyonglong for modifying the SPJ.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2013] 出题人", "background": "", "description": "当今世界上各类程序设计竞赛层出不穷。而设计一场好比赛绝非易事，比如给题目设计测试数据就是一项挑战。一组好的测试数据需要对不同的程序有区分度：满足所有要求的程序自然应该得到满分，而那些貌似正确的程序则会在某些特殊数据上出错。\n\n在本题中，你在比赛中的角色反转啦！作为一名久经百战的程序员，你将帮助 Happy Programmer Contest 的命题委员会设计这次比赛的测试数据。本次比赛命题委员会选择了两个图论问题，分为 $8$ 个子任务。委员会写了一些貌似可以解决这些子任务的代码。在给任务设计数据的时候，命题委员会期望其中的一些源程序能够得到满分，而另外的一些则只能得到 $0$ 分或者少许的部分分。现在你将会获得这些源程序（C, C++, Pascal 版本）。对于每个子任务，你需要去产生一组数据 $X$ 使得它能将该任务给定的 $2$ 种源程序 $A$ 和 $B$ 区分开来。更具体地说，生成的数据必须满足如下两个条件:\n\n输入 $X$ 对于源程序 $A$ 一定不会出现超出时间限制（TLE）的问题。\n\n输入 $X$ 一定会导致源程序 $B$ 产生超出时间限制的问题。\n\n此外,命题委员喜欢较小规模的测试数据，希望测试数据最好能够包含不超过 $T$ 个整数。\n\n本题中只关心源程序 $A$ 和 $B$ 是否超时，不关心是否结果正确。\n\n命题委员会选择了单源最短路（SSSP）以及一个被称之为神秘问题（Mystery）的两个图论问题来作为比赛的题目。我们将命题委员会完成的伪代码列在了附录中，而具体的 C、C++ 和 Pascal 源程序被我们放在了下发的文件当中。\n\n### 子任务\n\n参见下表。表中每一行描述了一个子任务。其中前六个子任务与单源最短路相关，子任务 7,8 与神秘问题相关。每个任务所占分数见下表。\n\n ![](https://cdn.luogu.com.cn/upload/pic/4428.png) \n\n对于每个子任务，你的程序给出的输入 $X$ 需要能够将源程序 $A$ 和 $B$ 区分开来，这有这样你才能够得到相应的分数。具体说来，你的分数将由输入 $X$ 中数的个数决定。假设 $X$ 中包含了 $F$ 个整数，子任务的满分为 $S,T$ 是该任务的目标大小，则该测试点的分数将由下式给出:\n\n$$S \\times \\min\\{T / F, 1\\}$$\n\n也就是说，如果你的测试数据 $X$ 中含有不超过 $T$ 个整数，则你将得到该任务的全部得分。\n\n你需要把你的 $8$ 个测试数据命名为 `1.txt` ~ `8.txt`。对于每个子任务 $X$，评测系统将根据如下步骤来确定你将会得到多少分:\n\n- 如果未提交数据，则不得分；\n- 若数据不满足输入格式要求，则不得分；\n- 对源程序 $A$ 运行输入，若发生超时现象，则不得分；\n- 对源程序 $B$ 运行输入，若发生超时现象，则按照前文所述的公式给出该测试点的分数。\n\n题目提供的所有源代码均会维护一个计数器来统计程序的操作次数。在源程序的运行过程中，当该计数器超过了 $10^6$ 次时，那么我们认为程序运行超时。\n\n### 问题 1：单源最短路（SSSP）\n\n给定一个带权有向图 $G$，以及 $G$ 中的两个节点 $s$ 与 $t$，令 $p(s, t)$ 为 $G$ 中从 $s$ 至 $t$ 的最短路长度。如果 $s$ 与 $t$ 不连通，则认为 $p(s, t)=10^9$。在本题中，输入为图 $G$ 以及 $Q$ 个询问 $(s_1, t_1), (s_2, t_2), \\dots, (s_Q, t_Q)$ 。输出则是对这 $Q$ 个询问的相应输出 $p(s_1, t_1), p(s_2 , t_2), \\cdots, p(s_Q, t_Q)$。\n\n\n### 问题 2：神秘问题\n\n给定一个包含 $V$ 个节点 $E$ 条边的无向图 $G$，要求将所有的节点进行编号（编号范围为 $[0, X-1]$），使得所有直接相连的节点均有不同的编号。找出符合题意的最小的 $X$。\n", "inputFormat": "### 问题 1\n\n输入数据包含两部分，其中第一部分使用邻接表来描述带权有向图 $G$。第二部分则描述对 $G$ 的最短路径的查询。\n\n数据第一部分的第一行包含一个整数 $V$，表示 $G$ 中点的个数，所有点的编号为 $0, 1, \\cdots, V - 1$。\n\n接下来 $V$ 行，每行描述一个点的所有边。行中的第一个整数 $n_i$ 描述了节点 $i$ 的出边数量，接下来有 $n_i$ 个整数对 $(j, w)$ 表示有一条从 $i$ 到 $j$，边权为 $w$ 的边。\n\n数据第二部分的第一行包含一个整数 $Q$，表示询问的组数。\n\n接下来 $Q$ 行，第 $k$ 行包含两个整数 $s_k, t_k$，为该询问对应的起点与终点位置。\n\n同一行中任意两个相邻的整数均需要至少一个空格将他们分开。除此之外，数据还需满足如下条件:\n\n- $0 < V \\leq 300$，$n_i$ 是一个非负整数，$0 \\leq j < V$，$\\lvert w \\rvert < 10^6$，$0 \\leq \\sum\\limits_{i = 0}^{V-1} n_i \\leq 5000$，$0 < Q \\leq 10$，$0 \\leq s_k < V, 0 \\leq t_k < V$；\n- 图中没有负权圈。\n\n\n\n### 问题 2\n\n输入数据的第一行包含两个整数 $V$ 和 $E$。\n\n接下来 $E$ 行,每行两个整数 $a, b$，表示 $a$ 与 $b$ 在 $G$ 中直接相连。此外,输入数据应满足如下限制条件:\n\n- $70 < V < 1000$，$1500 < E < 10^6$；\n- 对于所有的边 $(a, b)$，有 $a \\neq b, 0 \\leq a < V, 0 \\leq b < V$，不会重复描述一条边。\n\n", "outputFormat": "### 问题 1\n\n程序将会输出 $Q$ 行，每行一个整数，表示对应的 $p(s_k , t_k)$。而在输出的最后，所有提供的程序都会给出计数器对此输入的数值。\n\n### 问题 2\n\n程序将在第一行输出 $X$，即最小的编号范围，接下来在第二行中给出 $V$ 个整数，依次描述节点 $0$ 至 $V - 1$ 的编号。在输出的最后，所有提供的程序都会给出计数器对此输入的数值。", "hint": "**源代码见附件**。\n\n### 附录：伪代码\n\n接下来是我们提供的所有程序的伪代码；变量 counter 近似描述出了程序的运行时间。评测时将会使用这些伪代码的 C++ 版本来进行评测。\n\n\nFloydWarshall\n\n```cpp\n// pre-condition: the graph is stored in an adjacency matrix M\ncounter = 0\nfor k = 0 to V-1\n    for i = 0 to V-1\n        for j = 0 to V-1\n            increase counter by 1;\n            M[i][j] = min(M[i][j], M[i][k] + M[k][j]);\nfor each query p(s,t)\n    output M[s][t];\n```\n\nOptimizedBellmanFord\n\n```cpp\n// pre-condition: the graph is stored in an adjacency list L\ncounter = 0\nfor each query p(s,t);\n    dist[s] = 0; // s is the source vertex\n    loop V-1 times\n        change = false;\n        for each edge (u,v) in L\n            increase counter by 1;\n            if dist[u] + weight(u,v) < dist[v]\n                dist[v] = dist[u] + weight(u,v);\n                change = true;\n        if change is false // this is the ’optimized’ Bellman Ford\n            break from the outermost loop;\n    output dist[t];\n```\n\nModifiedDijkstra\n\n```cpp\n// pre-condition: the graph is stored in an adjacency list L\ncounter = 0;\nfor each query p(s,t)\n    dist[s] = 0;\n    pq.push(pair(0, s)); // pq is a priority queue\n    while pq is not empty\n        increase counter by 1;\n        (d, u) = the top element of pq;\n        remove the top element from pq;\n        if (d == dist[u])\n            for each edge (u,v) in L\n                if (dist[u] + weight(u,v) ) < dist[v]\n                    dist[v] = dist[u] + weight(u,v);\n                    insert pair (dist[v], v) into the pq;\n    output dist[t];\n```\n\nGamble1\n\n```cpp\nSets X = V;\nlabels vertex i in [0..V-1] with i;\nSets counter = 0; // will never get TLE\n```\nGamble2\n\n```cpp\nSets X = V;\nlabels vertex i in [0..V-1] with i;\nSets counter = 1000001; // force this to get TLE\n```\n\nRecursiveBacktracking\n\n```cpp\nThis algorithm tries X from 2 to V one by one and stops at the first valid X.  \nFor each X, the backtracking routine label vertex 0 with 0, then for each vertex u that has been assigned a label, the backtracking routine tries to assign \nthe smallest possible label up to label X-1 to its neighbor v, and backtracks if necessary.  \n// Please check RecursiveBacktracking.cpp/pas to see \n// the exact lines where the iteration counter is increased by 1\n```\n\n感谢zhouyonglong修改spj\n", "locale": "zh-CN"}}}
{"pid": "P3641", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2016", "APIO", "交互题", "Special Judge", "O2优化"], "title": "[APIO2016] 最大差分", "background": "## 评测方式\n以下是本题评测方式，与题面不符时以这里为准。\n\n你的代码中不应该包含 `gap.h` 库。\n\n你的代码中需如下进行 `findGap` 和 `MinMax` 函数的声明：\n```cpp\nextern \"C\" void MinMax(long long,long long,long long*,long long*);\nextern \"C\" long long findGap(int,int);\n```\n\n[spj 与交互库](https://www.luogu.com.cn/paste/c4olee2x)\n\n不保证没锅，要是有锅请私信供题人然后 D 死他。", "description": "有 $N$ 个严格递增的非负整数 $a_1, a_2, \\dots, a_N$（$0 \\leq a_1 < a_2 < \\cdots < a_N \\leq 10^{18}$）。你需要找出 $a_{i + 1} - a_i$（$1 \\leq i \\leq N - 1$）里的最大的值。\n\n你的程序不能直接读入这个整数序列，但是你可以通过给定的函数来查询该序列的信息。关于查询函数的细节，请根据你所使用的语言，参考下面的实现细节部分。\n\n你需要实现一个函数,该函数返回 $a_{i + 1} - a_i$（$1 \\leq i \\leq N - 1$）中的最大值。\n\n## 实现细节\n\n**本题只支持 C++（包括 cpp11，cpp14，cpp17）**。\n\n### C/C++\n你需要包含头文件 `gap.h`。\n\n你需要实现一个函数 `findGap(T, N)`，该函数接受下面的参数，并返回一个 `long long` 类型的整数：\n\n- $T$：子任务的编号（$1$ 或者 $2$）\n- $N$：序列的长度\n\n你的函数 `findGap` 可以调用系统提供的查询函数 `MinMax(s, t, &mn, &mx)`，该函数的前两个参数 $s$ 和 $t$ 是 `long long` 类型的整数，后两个参数 `&mn` 和 `&mx` 是 `long long` 类型的整数的指针（`mn` 和 `mx` 是 `long long` 类型的整数）。当 `MinMax(s, t, &mn, &mx)` 返回时，变量 `mn` 将会存储满足 $a_i \\in [s, t]$ 中 $a_i$ 的最小值，变量 `mx` 将会存储满足 $a_i \\in [s, t]$，$a_i$ 的最大值。如果区间 $[s, t]$ 中没有序列中的数，则 `mn` 和 `mx` 都将存储 $-1$。在查询时需要满足 $s \\leq t$，否则程序将会终止，该测试点计为 $0$ 分。\n\n### Pascal\n你需要使用单元 `graderhelperlib`。\n\n你需要实现一个函数 `findGap(T, N)`，该函数接受下面的参数，并返回一个 `Int64` 类型的整数：\n\n- $T$：子任务的编号（$1$ 或者 $2$）（`Integer` 类型）\n- $N$：序列的长度（`LongInt` 类型）\n\n你的函数 `findGap` 可以调用系统提供的查询函数 `MinMax(s, t, mn, mx)`，该函数的前两个参数 $s$ 和 $t$ 是 `Int64` 类型的整数，后两个参数 `mn` 和 `mx` 是传引用方式的 `Int64` 类型的整数（过程内部对这两个变量的修改会影响到外部的对应变量的值）。当 `MinMax(s, t, mn, mx)` 执行完毕时，变量 `mn` 将会存储满足 $a_i \\in [s, t]$ 中 $a_i$ 的最小值，变量 `mx` 将会存储满足 $a_i \\in [s, t]$，$a_i$ 的最大值。如果区间 $[s, t]$ 中没有序列中的数，则 `mn` 和 `mx` 都将存储 $-1$。在查询时需要满足 $s \\leq t$，否则程序将会终止，该测试点计为 $0$ 分。", "inputFormat": "## 样例一\n\n### C/C++\n\n考虑 $N = 4, a_1 = 2, a_2 = 3, a_3 = 6, a_4 = 8$。\n\n则答案应该是 $3$，可以通过下面的几组对 `MinMax` 的询问获得：\n\n调用 `MinMax(1, 2, &mn, &mx)`，则 `mn` 和 `mx` 皆返回 $2$。\n\n调用 `MinMax(3, 7, &mn, &mx)`，则 `mn` 返回 $3$，`mx` 返回 $6$。\n\n调用 `MinMax(8, 9, &mn, &mx)`，则 `mn` 和 `mx` 皆返回 $8$。\n\n### Pascal\n考虑 $N = 4, a_1 = 2, a_2 = 3, a_3 = 6, a_4 = 8$。\n\n则答案应该是 $3$，可以通过下面的几组对 `MinMax` 的询问获得：\n\n调用 `MinMax(1, 2, mn, mx)`，则 `mn` 和 `mx` 皆返回 $2$。\n\n调用 `MinMax(3, 7, mn, mx)`，则 `mn` 返回 $3$，`mx` 返回 $6$。\n\n调用 `MinMax(8, 9, mn, mx)`，则 `mn` 和 `mx` 皆返回 $8$。\n\n## 样例评测方式\n\n样例测评系统从标准输入中读入两行。第一行包含两个整数，子任务编号 $T$，和序列长度 $N$。第二行包含 $N$ 个严格递增的非负整数。然后该程序会向标准输出中写入两行，第一行为 `findGap` 的返回值，第二行为花费 $M$ 的值。\n\n下面的输入描述了上面的样例：\n\n```plane\n2 4\n2 3 6 8\n```\n注意实际使用的交互库和 spj 对数据进行了加密。", "outputFormat": "", "hint": "## 限制与约定\n\n对于所有的测试点，有 $2 \\leq N \\leq 100000$。\n\n每一个测试点开始测试之前，$M$ 都将被初始化为 $0$。\n\n子任务 1（$30$ 分）：每一次调用 `MinMax` 都将使 $M$ 加 $1$。为了获得所有分数，需要满足对于该子任务下的所有测试点，都有 $M \\leq \\frac{N + 1}{2}$。\n\n子任务 2（$70$ 分）：定义 $k$ 为调用 `MinMax` 时，区间 $[s, t]$ 中的序列中数的数量。每次调用 `MinMax`，将使 $M$ 加上 $k + 1$。对于每一个测试点，如果 $M \\leq 3N$，你将得到 70 分，否则将得到 $\\dfrac{60}{\\sqrt{\\frac MN + 1} - 1}$ 分。你的该子任务的得分是其下所有测试点中的最低分。\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2016] Maximum Gap", "background": "", "description": "There are $N$ strictly increasing nonnegative integers $a_1, a_2, \\dots, a_N$ with $0 \\leq a_1 < a_2 < \\cdots < a_N \\leq 10^{18}$. You need to find the maximum value among $a_{i + 1} - a_i$ for $1 \\leq i \\leq N - 1$.\n\nYour program cannot read this integer sequence directly, but you can query information about the sequence through the provided function. Please refer to the implementation details below for your language.\n\nYou must implement a function that returns the maximum value of $a_{i + 1} - a_i$ for $1 \\leq i \\leq N - 1$.\n\nJudging method\nThe following judging method applies. If this differs from the main statement, this section prevails.\n\n- Your code must not include the gap.h library.\n- You must declare the functions findGap and MinMax as follows:\n```cpp\nextern \"C\" void MinMax(long long,long long,long long*,long long*);\nextern \"C\" long long findGap(int,int);\n```\n- [spj and interaction library](https://www.luogu.com.cn/paste/c4olee2x)\n- If you encounter issues, please contact the problem provider.\n\nImplementation details\n\nThis problem only supports C++ (including cpp11, cpp14, cpp17).\n\nYou must implement a function findGap(T, N), which takes the following parameters and returns a value of type long long:\n\n- $T$: subtask ID ($1$ or $2$).\n- $N$: the length of the sequence.\n\nYour function findGap may call the system-provided query function MinMax(s, t, &mn, &mx). The first two parameters $s$ and $t$ are of type long long, and the last two parameters &mn and &mx are pointers to long long (mn and mx are long long variables). When MinMax(s, t, &mn, &mx) returns, mn will store the minimum $a_i$ such that $a_i \\in [s, t]$, and mx will store the maximum $a_i$ such that $a_i \\in [s, t]$. If there is no number from the sequence in the interval $[s, t]$, both mn and mx will be set to $-1$. You must ensure $s \\leq t$ when querying; otherwise, the program will terminate and the test will receive a score of $0$.\n\nSample 1\n\nC/C++\n\nConsider $N = 4, a_1 = 2, a_2 = 3, a_3 = 6, a_4 = 8$.\n\nThe answer should be $3$, which can be obtained using the following queries to MinMax:\n\n- Call MinMax(1, 2, &mn, &mx), then both mn and mx return $2$.\n- Call MinMax(3, 7, &mn, &mx), then mn returns $3$, and mx returns $6$.\n- Call MinMax(8, 9, &mn, &mx), then both mn and mx return $8$.\n\nSample judging method\n\nThe sample judge reads two lines from standard input. The first line contains two integers, the subtask ID $T$ and the sequence length $N$. The second line contains $N$ strictly increasing nonnegative integers. Then the program writes two lines to standard output: the first line is the return value of findGap, and the second line is the value of the cost $M$.\n\nThe following input describes the sample above:\n```plane\n2 4\n2 3 6 8\n```\nNote that the actual interaction library and spj encrypt the testdata.\n\nConstraints and agreements\n\nFor all test cases, $2 \\leq N \\leq 100000$.\n\nBefore each test case starts, $M$ will be initialized to $0$.\n\nSubtask 1 (30 points): Each call to MinMax increases $M$ by $1$. To receive full points, you must ensure $M \\leq \\frac{N + 1}{2}$ for all test cases in this subtask.\n\nSubtask 2 (70 points): Let $k$ be the number of sequence elements within the interval $[s, t]$ for a MinMax call. Each call to MinMax increases $M$ by $k + 1$. For each test case, if $M \\leq 3N$, you will receive 70 points; otherwise, you will receive $\\dfrac{60}{\\sqrt{\\frac MN + 1} - 1}$ points. Your score for this subtask is the minimum over all its test cases.", "inputFormat": "", "outputFormat": "", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2016] 最大差分", "background": "## 评测方式\n以下是本题评测方式，与题面不符时以这里为准。\n\n你的代码中不应该包含 `gap.h` 库。\n\n你的代码中需如下进行 `findGap` 和 `MinMax` 函数的声明：\n```cpp\nextern \"C\" void MinMax(long long,long long,long long*,long long*);\nextern \"C\" long long findGap(int,int);\n```\n\n[spj 与交互库](https://www.luogu.com.cn/paste/c4olee2x)\n\n不保证没锅，要是有锅请私信供题人然后 D 死他。", "description": "有 $N$ 个严格递增的非负整数 $a_1, a_2, \\dots, a_N$（$0 \\leq a_1 < a_2 < \\cdots < a_N \\leq 10^{18}$）。你需要找出 $a_{i + 1} - a_i$（$1 \\leq i \\leq N - 1$）里的最大的值。\n\n你的程序不能直接读入这个整数序列，但是你可以通过给定的函数来查询该序列的信息。关于查询函数的细节，请根据你所使用的语言，参考下面的实现细节部分。\n\n你需要实现一个函数,该函数返回 $a_{i + 1} - a_i$（$1 \\leq i \\leq N - 1$）中的最大值。\n\n## 实现细节\n\n**本题只支持 C++（包括 cpp11，cpp14，cpp17）**。\n\n### C/C++\n你需要包含头文件 `gap.h`。\n\n你需要实现一个函数 `findGap(T, N)`，该函数接受下面的参数，并返回一个 `long long` 类型的整数：\n\n- $T$：子任务的编号（$1$ 或者 $2$）\n- $N$：序列的长度\n\n你的函数 `findGap` 可以调用系统提供的查询函数 `MinMax(s, t, &mn, &mx)`，该函数的前两个参数 $s$ 和 $t$ 是 `long long` 类型的整数，后两个参数 `&mn` 和 `&mx` 是 `long long` 类型的整数的指针（`mn` 和 `mx` 是 `long long` 类型的整数）。当 `MinMax(s, t, &mn, &mx)` 返回时，变量 `mn` 将会存储满足 $a_i \\in [s, t]$ 中 $a_i$ 的最小值，变量 `mx` 将会存储满足 $a_i \\in [s, t]$，$a_i$ 的最大值。如果区间 $[s, t]$ 中没有序列中的数，则 `mn` 和 `mx` 都将存储 $-1$。在查询时需要满足 $s \\leq t$，否则程序将会终止，该测试点计为 $0$ 分。\n\n### Pascal\n你需要使用单元 `graderhelperlib`。\n\n你需要实现一个函数 `findGap(T, N)`，该函数接受下面的参数，并返回一个 `Int64` 类型的整数：\n\n- $T$：子任务的编号（$1$ 或者 $2$）（`Integer` 类型）\n- $N$：序列的长度（`LongInt` 类型）\n\n你的函数 `findGap` 可以调用系统提供的查询函数 `MinMax(s, t, mn, mx)`，该函数的前两个参数 $s$ 和 $t$ 是 `Int64` 类型的整数，后两个参数 `mn` 和 `mx` 是传引用方式的 `Int64` 类型的整数（过程内部对这两个变量的修改会影响到外部的对应变量的值）。当 `MinMax(s, t, mn, mx)` 执行完毕时，变量 `mn` 将会存储满足 $a_i \\in [s, t]$ 中 $a_i$ 的最小值，变量 `mx` 将会存储满足 $a_i \\in [s, t]$，$a_i$ 的最大值。如果区间 $[s, t]$ 中没有序列中的数，则 `mn` 和 `mx` 都将存储 $-1$。在查询时需要满足 $s \\leq t$，否则程序将会终止，该测试点计为 $0$ 分。", "inputFormat": "## 样例一\n\n### C/C++\n\n考虑 $N = 4, a_1 = 2, a_2 = 3, a_3 = 6, a_4 = 8$。\n\n则答案应该是 $3$，可以通过下面的几组对 `MinMax` 的询问获得：\n\n调用 `MinMax(1, 2, &mn, &mx)`，则 `mn` 和 `mx` 皆返回 $2$。\n\n调用 `MinMax(3, 7, &mn, &mx)`，则 `mn` 返回 $3$，`mx` 返回 $6$。\n\n调用 `MinMax(8, 9, &mn, &mx)`，则 `mn` 和 `mx` 皆返回 $8$。\n\n### Pascal\n考虑 $N = 4, a_1 = 2, a_2 = 3, a_3 = 6, a_4 = 8$。\n\n则答案应该是 $3$，可以通过下面的几组对 `MinMax` 的询问获得：\n\n调用 `MinMax(1, 2, mn, mx)`，则 `mn` 和 `mx` 皆返回 $2$。\n\n调用 `MinMax(3, 7, mn, mx)`，则 `mn` 返回 $3$，`mx` 返回 $6$。\n\n调用 `MinMax(8, 9, mn, mx)`，则 `mn` 和 `mx` 皆返回 $8$。\n\n## 样例评测方式\n\n样例测评系统从标准输入中读入两行。第一行包含两个整数，子任务编号 $T$，和序列长度 $N$。第二行包含 $N$ 个严格递增的非负整数。然后该程序会向标准输出中写入两行，第一行为 `findGap` 的返回值，第二行为花费 $M$ 的值。\n\n下面的输入描述了上面的样例：\n\n```plane\n2 4\n2 3 6 8\n```\n注意实际使用的交互库和 spj 对数据进行了加密。", "outputFormat": "", "hint": "## 限制与约定\n\n对于所有的测试点，有 $2 \\leq N \\leq 100000$。\n\n每一个测试点开始测试之前，$M$ 都将被初始化为 $0$。\n\n子任务 1（$30$ 分）：每一次调用 `MinMax` 都将使 $M$ 加 $1$。为了获得所有分数，需要满足对于该子任务下的所有测试点，都有 $M \\leq \\frac{N + 1}{2}$。\n\n子任务 2（$70$ 分）：定义 $k$ 为调用 `MinMax` 时，区间 $[s, t]$ 中的序列中数的数量。每次调用 `MinMax`，将使 $M$ 加上 $k + 1$。对于每一个测试点，如果 $M \\leq 3N$，你将得到 70 分，否则将得到 $\\dfrac{60}{\\sqrt{\\frac MN + 1} - 1}$ 分。你的该子任务的得分是其下所有测试点中的最低分。\n", "locale": "zh-CN"}}}
{"pid": "P3642", "type": "P", "difficulty": 7, "samples": [["4 6\n1 5\n2 5\n2 8\n3 3\n3 2\n3 3\n2 9\n4 4\n4 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "APIO", "可并堆", "斜率维护技巧 slope trick"], "title": "[APIO2016] 烟花表演", "background": "", "description": "烟花表演是最引人注目的节日活动之一。在表演中,所有的烟花必须同时爆炸。为了确保安全，烟花被安置在远离开关的位置上，通过一些导火索与开关相连。导火索的连接方式形成一棵树，烟花是树叶，如图所示。火花从开关出发，沿导火索移动。每当火花抵达一个分叉点时，它会扩散到与之相连的所有导火索，继续燃烧。导火索燃烧的速度是一个固定常数。图中展示了六枚烟花 $\\{E_1, E_2, \\dots, E_6\\}$ 的连线布局，以及每根导火索的长度。图中还标注了当在时刻 $0$ 从开关点燃火花时，每一发烟花的爆炸时间。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4429.png) \n\nHyunmin 为烟花表演设计了导火索的连线布局。不幸的是，在他设计的布局中，烟花不一定同时爆炸。我们希望修改一些导火索的长度，让所有烟花在同一时刻爆炸。例如，为了让图中的所有烟花在时刻 $13$ 爆炸，我们可以像下图中左边那样调整导火索长度。类似地，为了让图中的所有烟花在时刻 $14$ 爆炸，我们可以像下图中右边那样调整长度。\n\n ![](https://cdn.luogu.com.cn/upload/pic/4430.png) \n\n修改导火索长度的代价等于修改前后长度之差的绝对值。例如，将上面那副图中布局修改为下面那副图的左边布局的总代价为 $6$，而修改为右边布局的总代价为 $5$。\n\n导火索的长度可以被减为 $0$，同时保持连通性不变。\n\n给定一个导火索的连线布局，你需要编写一个程序，去调整导火索长度，让所有的烟花在同一时刻爆炸，并使得代价最小。\n", "inputFormat": "所有的输入均为正整数。令 $N$ 代表分叉点的数量，$M$ 代表烟花的数量。分叉点从 $1$ 到 $N$ 编号，编号为 $1$ 的分叉点是开关。烟花从 $N + 1$ 到 $N + M$ 编号。\n\n输入第一行为 $N, M$。后面 $N + M - 1$ 行，第 $i$ 行两个整数 $P_{i + 1}, C_{i + 1}$。其中 $P_i$ 满足 $1 \\leq P_i < i$，代表和分叉点或烟花 $i$ 相连的分叉点。$C_i$ 代表连接它们的导火索长度（$1 \\leq C_i \\leq 10^9$）除开关外，每个分叉点和多于 $1$ 条导火索相连，而每发烟花恰好与 $1$ 条导火索相连。\n", "outputFormat": "输出调整导火索长度，让所有烟花同时爆炸，所需要的最小代价。\n", "hint": "【数据规模】\n\n子任务 1（7 分）：$N = 1$，$1 \\leq M \\leq 100$。\n\n子任务 2（19 分）：$1 \\leq N+M \\leq 300$，且开关到任一烟花的距离不超过 $300$。\n\n子任务 3（29 分）：$1 \\leq N+M \\leq 5000$。\n\n子任务 4（45 分）：$1 \\leq N+M \\leq 300000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2016] Fireworks Show", "background": "", "description": "A fireworks show is one of the most eye-catching festival activities. In the show, all fireworks must explode at the same time. For safety, the fireworks are placed away from the switch and connected to the switch by fuses. The fuses form a tree, and the fireworks are the leaves, as shown in the figure. A spark starts at the switch and travels along the fuses. Whenever the spark reaches a junction, it splits and continues burning along all incident fuses. The burning speed of every fuse is a fixed constant. The figure shows the layout connecting six fireworks $\\{E_1, E_2, \\dots, E_6\\}$ and the length of each fuse. It also shows the explosion time of each firework when the spark is ignited at time $0$ at the switch.\n\n![](https://cdn.luogu.com.cn/upload/pic/4429.png)\n\nHyunmin designed the fuse layout for the fireworks show. Unfortunately, in his design, the fireworks do not necessarily explode simultaneously. We want to adjust some fuse lengths so that all fireworks explode at the same time. For example, to make all fireworks in the figure explode at time $13$, we can adjust the fuse lengths as shown on the left below. Similarly, to make all fireworks explode at time $14$, we can adjust the lengths as shown on the right.\n\n![](https://cdn.luogu.com.cn/upload/pic/4430.png)\n\nThe cost of modifying a fuse is the absolute difference between its new length and its original length. For example, changing the top layout to the layout on the left below has a total cost of $6$, while changing it to the layout on the right has a total cost of $5$.\n\nFuse lengths may be reduced to $0$ without changing the connectivity.\n\nGiven a fuse layout, write a program to adjust the fuse lengths so that all fireworks explode at the same time, while minimizing the total cost.", "inputFormat": "All input values are positive integers. Let $N$ be the number of junctions, and $M$ be the number of fireworks. Junctions are numbered from $1$ to $N$, where junction $1$ is the switch. Fireworks are numbered from $N + 1$ to $N + M$.\n\nThe first line contains $N, M$. Each of the next $N + M - 1$ lines describes one edge. For every node $v$ with $2 \\leq v \\leq N + M$, the line for $v$ gives two integers $P_v, C_v$, where $1 \\leq P_v < v$ specifies the junction to which node $v$ is connected, and $C_v$ is the length of the connecting fuse ($1 \\leq C_v \\leq 10^9$). Except for the switch, every junction is connected to more than $1$ fuse, and each firework is connected to exactly $1$ fuse.", "outputFormat": "Output the minimum total cost to adjust the fuse lengths so that all fireworks explode simultaneously.", "hint": "Constraints\n\n- Subtask 1 (7 points): $N = 1$, $1 \\leq M \\leq 100$.\n- Subtask 2 (19 points): $1 \\leq N + M \\leq 300$, and the distance from the switch to any firework is at most $300$.\n- Subtask 3 (29 points): $1 \\leq N + M \\leq 5000$.\n- Subtask 4 (45 points): $1 \\leq N + M \\leq 300000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2016] 烟花表演", "background": "", "description": "烟花表演是最引人注目的节日活动之一。在表演中,所有的烟花必须同时爆炸。为了确保安全，烟花被安置在远离开关的位置上，通过一些导火索与开关相连。导火索的连接方式形成一棵树，烟花是树叶，如图所示。火花从开关出发，沿导火索移动。每当火花抵达一个分叉点时，它会扩散到与之相连的所有导火索，继续燃烧。导火索燃烧的速度是一个固定常数。图中展示了六枚烟花 $\\{E_1, E_2, \\dots, E_6\\}$ 的连线布局，以及每根导火索的长度。图中还标注了当在时刻 $0$ 从开关点燃火花时，每一发烟花的爆炸时间。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4429.png) \n\nHyunmin 为烟花表演设计了导火索的连线布局。不幸的是，在他设计的布局中，烟花不一定同时爆炸。我们希望修改一些导火索的长度，让所有烟花在同一时刻爆炸。例如，为了让图中的所有烟花在时刻 $13$ 爆炸，我们可以像下图中左边那样调整导火索长度。类似地，为了让图中的所有烟花在时刻 $14$ 爆炸，我们可以像下图中右边那样调整长度。\n\n ![](https://cdn.luogu.com.cn/upload/pic/4430.png) \n\n修改导火索长度的代价等于修改前后长度之差的绝对值。例如，将上面那副图中布局修改为下面那副图的左边布局的总代价为 $6$，而修改为右边布局的总代价为 $5$。\n\n导火索的长度可以被减为 $0$，同时保持连通性不变。\n\n给定一个导火索的连线布局，你需要编写一个程序，去调整导火索长度，让所有的烟花在同一时刻爆炸，并使得代价最小。\n", "inputFormat": "所有的输入均为正整数。令 $N$ 代表分叉点的数量，$M$ 代表烟花的数量。分叉点从 $1$ 到 $N$ 编号，编号为 $1$ 的分叉点是开关。烟花从 $N + 1$ 到 $N + M$ 编号。\n\n输入第一行为 $N, M$。后面 $N + M - 1$ 行，第 $i$ 行两个整数 $P_{i + 1}, C_{i + 1}$。其中 $P_i$ 满足 $1 \\leq P_i < i$，代表和分叉点或烟花 $i$ 相连的分叉点。$C_i$ 代表连接它们的导火索长度（$1 \\leq C_i \\leq 10^9$）除开关外，每个分叉点和多于 $1$ 条导火索相连，而每发烟花恰好与 $1$ 条导火索相连。\n", "outputFormat": "输出调整导火索长度，让所有烟花同时爆炸，所需要的最小代价。\n", "hint": "【数据规模】\n\n子任务 1（7 分）：$N = 1$，$1 \\leq M \\leq 100$。\n\n子任务 2（19 分）：$1 \\leq N+M \\leq 300$，且开关到任一烟花的距离不超过 $300$。\n\n子任务 3（29 分）：$1 \\leq N+M \\leq 5000$。\n\n子任务 4（45 分）：$1 \\leq N+M \\leq 300000$。\n", "locale": "zh-CN"}}}
{"pid": "P3643", "type": "P", "difficulty": 6, "samples": [["2\n1 2\n2 3", "7\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2016", "APIO", "动态规划优化", "排列组合", "前缀和"], "title": "[APIO2016] 划艇", "background": "", "description": "在首尔城中，汉江横贯东西。在汉江的北岸，从西向东星星点点地分布着 $N$ 个划艇学校，编号依次为 $1$ 到 $N$。每个学校都拥有若干艘划艇。同一所学校的所有划艇颜色相同，不同的学校的划艇颜色互不相同。颜色相同的划艇被认为是一样的。每个学校可以选择派出一些划艇参加节日的庆典，也可以选择不派出任何划艇参加。如果编号为 $i$ 的学校选择派出划艇参加庆典，那么，派出的划艇数量可以在 $a_i$ 至 $b_i$ 之间任意选择（$a_i \\leq b_i$）。\n\n值得注意的是，编号为 $i$ 的学校如果选择派出划艇参加庆典，那么它派出的划艇数量必须大于任意一所编号小于它的学校派出的划艇数量。\n\n输入所有学校的 $a_i,b_i$ 的值，求出参加庆典的划艇有多少种可能的情况，必须有至少一艘划艇参加庆典。两种情况不同当且仅当有参加庆典的某种颜色的划艇数量不同。\n", "inputFormat": "第一行包括一个整数 $N$，表示学校的数量。\n\n接下来 $N$ 行，每行包括两个正整数，用来描述一所学校。其中第 $i$ 行包括的两个正整数分别表示 $a_i,b_i$（$1 \\leq a_i \\leq b_i \\leq 10^9$）。\n", "outputFormat": "输出一行，一个整数，表示所有可能的派出划艇的方案数除以 $1,000,000,007$ 得到的余数。\n", "hint": "【样例解释】\n\n在只有一所学校派出划艇的情况下有 $4$ 种方案，两所学校都派出划艇的情况下有 $3$ 种方案，所以答案为 $7$。\n\n【数据范围】\n\n子任务 $1$（$9$ 分）：$1 \\leq N \\leq 500$ 且对于所有的 $1 \\leq i \\leq N$，保证 $a_i=b_i$。\n\n子任务 $2$（$22$ 分）：$1 \\leq N \\leq 500$ 且 $\\sum_{i=1}^N (b_i-a_i) \\leq 10^6$。\n\n子任务 $3$（$27$ 分）：$1 \\leq N \\leq 100$。\n\n子任务 $4$（$42$ 分）：$1 \\leq N \\leq 500$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2016] Boat", "background": "", "description": "In the city of Seoul, the Han River runs east to west. On its north bank, from west to east, there are $N$ rowing schools, numbered $1$ to $N$. Each school owns several boats. All boats from the same school share the same color, and different schools have different colors. Boats of the same color are considered identical. Each school may choose to send some boats to the festival, or choose not to send any. If school $i$ chooses to participate, it may send any number of boats between $a_i$ and $b_i$ inclusive ($a_i \\leq b_i$).\n\nImportantly, if school $i$ participates, the number of boats it sends must be greater than the number sent by any participating school with a smaller index.\n\nGiven all $a_i$ and $b_i$, determine how many possible participation configurations there are, with at least one boat participating. Two configurations are different if and only if there exists some color (i.e., some school) for which the number of participating boats differs.", "inputFormat": "The first line contains an integer $N$, the number of schools.\n\nThe next $N$ lines each describe one school. Line $i$ contains two positive integers $a_i$ and $b_i$ ($1 \\leq a_i \\leq b_i \\leq 10^9$).", "outputFormat": "Output a single line with one integer: the number of possible configurations modulo $1{,}000{,}000{,}007$.", "hint": "Sample explanation:\n\n- When only one school participates, there are $4$ configurations.\n- When both schools participate, there are $3$ configurations.\n- Therefore, the answer is $7$.\n\nConstraints:\n\n- Subtask $1$ (9 points): $1 \\leq N \\leq 500$ and $a_i = b_i$ for all $1 \\leq i \\leq N$.\n- Subtask $2$ (22 points): $1 \\leq N \\leq 500$ and $\\sum_{i=1}^N (b_i - a_i) \\leq 10^6$.\n- Subtask $3$ (27 points): $1 \\leq N \\leq 100$.\n- Subtask $4$ (42 points): $1 \\leq N \\leq 500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2016] 划艇", "background": "", "description": "在首尔城中，汉江横贯东西。在汉江的北岸，从西向东星星点点地分布着 $N$ 个划艇学校，编号依次为 $1$ 到 $N$。每个学校都拥有若干艘划艇。同一所学校的所有划艇颜色相同，不同的学校的划艇颜色互不相同。颜色相同的划艇被认为是一样的。每个学校可以选择派出一些划艇参加节日的庆典，也可以选择不派出任何划艇参加。如果编号为 $i$ 的学校选择派出划艇参加庆典，那么，派出的划艇数量可以在 $a_i$ 至 $b_i$ 之间任意选择（$a_i \\leq b_i$）。\n\n值得注意的是，编号为 $i$ 的学校如果选择派出划艇参加庆典，那么它派出的划艇数量必须大于任意一所编号小于它的学校派出的划艇数量。\n\n输入所有学校的 $a_i,b_i$ 的值，求出参加庆典的划艇有多少种可能的情况，必须有至少一艘划艇参加庆典。两种情况不同当且仅当有参加庆典的某种颜色的划艇数量不同。\n", "inputFormat": "第一行包括一个整数 $N$，表示学校的数量。\n\n接下来 $N$ 行，每行包括两个正整数，用来描述一所学校。其中第 $i$ 行包括的两个正整数分别表示 $a_i,b_i$（$1 \\leq a_i \\leq b_i \\leq 10^9$）。\n", "outputFormat": "输出一行，一个整数，表示所有可能的派出划艇的方案数除以 $1,000,000,007$ 得到的余数。\n", "hint": "【样例解释】\n\n在只有一所学校派出划艇的情况下有 $4$ 种方案，两所学校都派出划艇的情况下有 $3$ 种方案，所以答案为 $7$。\n\n【数据范围】\n\n子任务 $1$（$9$ 分）：$1 \\leq N \\leq 500$ 且对于所有的 $1 \\leq i \\leq N$，保证 $a_i=b_i$。\n\n子任务 $2$（$22$ 分）：$1 \\leq N \\leq 500$ 且 $\\sum_{i=1}^N (b_i-a_i) \\leq 10^6$。\n\n子任务 $3$（$27$ 分）：$1 \\leq N \\leq 100$。\n\n子任务 $4$（$42$ 分）：$1 \\leq N \\leq 500$。\n", "locale": "zh-CN"}}}
{"pid": "P3644", "type": "P", "difficulty": 6, "samples": [["1 5\nB 0 A 4\nB 1 B 3\nA 5 B 7\nB 2 A 6\nB 1 A 7", "24\n"], ["2 5\nB 0 A 4\nB 1 B 3\nA 5 B 7\nB 2 A 6\nB 1 A 7", "22"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "线段树", "堆", "APIO"], "title": "[APIO2015] 巴邻旁之桥", "background": "", "description": "一条东西走向的穆西河将巴邻旁市一分为二，分割成了区域 $A$ 和区域 $B$。\n\n每一块区域沿着河岸都建了恰好 $1000000001$ 栋的建筑，每条岸边的建筑都从 $0$ 编号到 $1000000000$。相邻的每对建筑相隔 $1$ 个单位距离，河的宽度也是 $1$ 个单位长度。区域 $A$ 中的 $i$ 号建筑物恰好与区域 $B$ 中的 $i$ 号建筑物隔河相对。\n\n城市中有 $N$ 个居民。第 $i$ 个居民的房子在区域 $P_i$ 的 $S_i$ 号建筑上，同时他的办公室坐落在 $Q_i$ 区域的 $T_i$ 号建筑上。一个居民的房子和办公室可能分布在河的两岸，这样他就必须要搭乘船只才能从家中去往办公室，这种情况让很多人都觉得不方便。为了使居民们可以开车去工作，政府决定建造不超过 $K$ 座横跨河流的大桥。\n\n由于技术上的原因，每一座桥必须刚好连接河的两岸，桥梁必须严格垂直于河流，并且桥与桥之间不能相交。\n\n当政府建造最多 $K$ 座桥之后，设 $D_i$ 表示第 $i$ 个居民此时开车从家里到办公室的最短距离。请帮助政府建造桥梁，使得 $D_1 + D_2 + \\cdots + D_N$ 最小。\n", "inputFormat": "输入的第一行包含两个正整数 $K$ 和 $N$，分别表示桥的上限数量和居民的数量。\n\n接下来 $N$ 行，每一行包含四个参数：$P_i, S_i, Q_i$ 和 $T_i$，表示第 $i$ 个居民的房子在区域 $P_i$ 的 $S_i$ 号建筑上，且他的办公室位于 $Q_i$ 区域的 $T_i$ 号建筑上。\n\n", "outputFormat": "输出仅为一行，包含一个整数，表示 $D_1 + D_2 + \\cdots + D_N$ 的最小值。\n", "hint": "【数据范围】\n\n所有数据都保证：$P_i$ 和 $Q_i$ 为字符 “A” 和 “B” 中的一个， $0 \\leq S_i, T_i \\leq 1000000000$，同一栋建筑内可能有超过 $1$ 间房子或办公室（或二者的组合，即房子或办公室的数量同时大于等于 $1$）。\n\n子任务 1 （8 分）$K = 1$\n\n$1 \\leq N \\leq 1000$\n\n\n子任务 2 （14 分）$K = 1$\n\n$1 \\leq N \\leq 100000$\n\n\n子任务 3 （9 分）$K = 2$\n\n$1 \\leq N \\leq 100$\n\n\n子任务 4 （32 分）$K = 2$\n\n$1 \\leq N \\leq 1000$\n\n\n子任务 5 （37 分）$K = 2$\n\n$1 \\leq N \\leq 100000$\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2015] Palembang Bridges", "background": "", "description": "An east–west Mu Xi River divides Palembang City into two parts, region $A$ and region $B$.\n\nExactly $1000000001$ buildings are built along each bank. Along each bank, buildings are numbered from $0$ to $1000000000$. Every pair of adjacent buildings is $1$ unit apart, and the river is $1$ unit wide. In region $A$, building $i$ is directly opposite building $i$ in region $B$.\n\nThere are $N$ residents in the city. The $i$-th resident’s home is at building $S_i$ in region $P_i$, and their office is at building $T_i$ in region $Q_i$. A resident’s home and office may lie on different banks of the river, in which case they must take a boat to commute, which many people find inconvenient. To allow residents to drive to work, the government decides to build at most $K$ bridges across the river.\n\nDue to technical reasons, each bridge must connect the two banks exactly, be strictly perpendicular to the river, and no two bridges may intersect.\n\nAfter the government builds at most $K$ bridges, let $D_i$ be the shortest driving distance from the $i$-th resident’s home to their office. Help the government build the bridges to minimize $D_1 + D_2 + \\cdots + D_N$.", "inputFormat": "The first line contains two positive integers $K$ and $N$, the maximum number of bridges and the number of residents.\n\nEach of the next $N$ lines contains four parameters: $P_i$, $S_i$, $Q_i$, and $T_i$, meaning that the $i$-th resident’s home is at building $S_i$ in region $P_i$, and their office is at building $T_i$ in region $Q_i$.", "outputFormat": "Output a single line containing one integer, the minimum value of $D_1 + D_2 + \\cdots + D_N$.", "hint": "Constraints\n\nFor all testdata, it is guaranteed that $P_i$ and $Q_i$ are one of the characters \"A\" and \"B\", $0 \\leq S_i, T_i \\leq 1000000000$, and there may be more than $1$ home or office (or both) in the same building.\n\nSubtask 1 (8 points) $K = 1$  \n$1 \\leq N \\leq 1000$.\n\nSubtask 2 (14 points) $K = 1$  \n$1 \\leq N \\leq 100000$.\n\nSubtask 3 (9 points) $K = 2$  \n$1 \\leq N \\leq 100$.\n\nSubtask 4 (32 points) $K = 2$  \n$1 \\leq N \\leq 1000$.\n\nSubtask 5 (37 points) $K = 2$  \n$1 \\leq N \\leq 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2015] 巴邻旁之桥", "background": "", "description": "一条东西走向的穆西河将巴邻旁市一分为二，分割成了区域 $A$ 和区域 $B$。\n\n每一块区域沿着河岸都建了恰好 $1000000001$ 栋的建筑，每条岸边的建筑都从 $0$ 编号到 $1000000000$。相邻的每对建筑相隔 $1$ 个单位距离，河的宽度也是 $1$ 个单位长度。区域 $A$ 中的 $i$ 号建筑物恰好与区域 $B$ 中的 $i$ 号建筑物隔河相对。\n\n城市中有 $N$ 个居民。第 $i$ 个居民的房子在区域 $P_i$ 的 $S_i$ 号建筑上，同时他的办公室坐落在 $Q_i$ 区域的 $T_i$ 号建筑上。一个居民的房子和办公室可能分布在河的两岸，这样他就必须要搭乘船只才能从家中去往办公室，这种情况让很多人都觉得不方便。为了使居民们可以开车去工作，政府决定建造不超过 $K$ 座横跨河流的大桥。\n\n由于技术上的原因，每一座桥必须刚好连接河的两岸，桥梁必须严格垂直于河流，并且桥与桥之间不能相交。\n\n当政府建造最多 $K$ 座桥之后，设 $D_i$ 表示第 $i$ 个居民此时开车从家里到办公室的最短距离。请帮助政府建造桥梁，使得 $D_1 + D_2 + \\cdots + D_N$ 最小。\n", "inputFormat": "输入的第一行包含两个正整数 $K$ 和 $N$，分别表示桥的上限数量和居民的数量。\n\n接下来 $N$ 行，每一行包含四个参数：$P_i, S_i, Q_i$ 和 $T_i$，表示第 $i$ 个居民的房子在区域 $P_i$ 的 $S_i$ 号建筑上，且他的办公室位于 $Q_i$ 区域的 $T_i$ 号建筑上。\n\n", "outputFormat": "输出仅为一行，包含一个整数，表示 $D_1 + D_2 + \\cdots + D_N$ 的最小值。\n", "hint": "【数据范围】\n\n所有数据都保证：$P_i$ 和 $Q_i$ 为字符 “A” 和 “B” 中的一个， $0 \\leq S_i, T_i \\leq 1000000000$，同一栋建筑内可能有超过 $1$ 间房子或办公室（或二者的组合，即房子或办公室的数量同时大于等于 $1$）。\n\n子任务 1 （8 分）$K = 1$\n\n$1 \\leq N \\leq 1000$\n\n\n子任务 2 （14 分）$K = 1$\n\n$1 \\leq N \\leq 100000$\n\n\n子任务 3 （9 分）$K = 2$\n\n$1 \\leq N \\leq 100$\n\n\n子任务 4 （32 分）$K = 2$\n\n$1 \\leq N \\leq 1000$\n\n\n子任务 5 （37 分）$K = 2$\n\n$1 \\leq N \\leq 100000$\n", "locale": "zh-CN"}}}
{"pid": "P3645", "type": "P", "difficulty": 4, "samples": [["5 3\n0 2\n1 1\n4 1", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "APIO", "枚举", "最短路", "分块", "根号分治", "bitset"], "title": "[APIO2015] 雅加达的摩天楼", "background": "", "description": "印尼首都雅加达市有 $N$ 座摩天楼，它们排列成一条直线，我们从左到右依次将它们编号为 $0$ 到 $N − 1$。除了这 $N$ 座摩天楼外，雅加达市没有其他摩天楼。\n\n有 $M$ 只叫做 “doge” 的神秘生物在雅加达市居住，它们的编号依次是 $0$ 到 $M − 1$。编号为 $i$ 的 doge 最初居住于编号为 $B_i$ 的摩天楼。每只 doge 都有一种神秘的力量，使它们能够在摩天楼之间跳跃，编号为 $i$ 的 doge 的跳跃能力为 $P_i$ （$P_i > 0$）。\n\n在一次跳跃中，位于摩天楼 $b$ 而跳跃能力为 $p$ 的 doge 可以跳跃到编号为 $b - p$ （如果 $0 \\leq b - p < N$）或 $b + p$ （如果 $0 \\leq b + p < N$）的摩天楼。\n\n编号为 $0$ 的 doge 是所有 doge 的首领，它有一条紧急的消息要尽快传送给编号为 $1$ 的 doge。任何一个收到消息的 doge 有以下两个选择:\n\n- 跳跃到其他摩天楼上；\n- 将消息传递给它当前所在的摩天楼上的其他 doge。\n\n请帮助 doge 们计算将消息从 $0$ 号 doge 传递到 $1$ 号 doge 所需要的最少总跳跃步数，或者告诉它们消息永远不可能传递到 $1$ 号 doge。\n", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$。\n\n接下来 $M$ 行，每行包含两个整数 $B_i$ 和 $P_i$。\n", "outputFormat": "输出一行，表示所需要的最少步数。如果消息永远无法传递到 $1$ 号 doge，输出 $−1$。\n", "hint": "【样例解释】\n\n下面是一种步数为 $5$ 的解决方案：\n\n$0$ 号 doge 跳跃到 $2$ 号摩天楼，再跳跃到 $4$ 号摩天楼（$2$ 步）。\n\n$0$ 号 doge 将消息传递给 $2$ 号 doge。\n\n$2$ 号 doge 跳跃到 $3$ 号摩天楼,接着跳跃到 $2$ 号摩天楼，再跳跃到 $1$ 号摩天楼（$3$ 步）。\n\n$2$ 号 doge 将消息传递给 $1$ 号 doge。\n\n【数据范围】\n\n所有数据都保证 $0 \\leq B_i < N$。\n\n子任务 1 （10 分）$1 \\leq N \\leq 10$\n\n$1 \\leq P_i \\leq 10$\n\n$2 \\leq M \\leq 3$\n\n\n子任务 2 （12 分）$1 \\leq N \\leq 100$\n\n$1 \\leq P_i \\leq 100$\n\n$2 \\leq M \\leq 2000$\n\n\n子任务 3 （14 分）$1 \\leq N \\leq 2000$\n\n$1 \\leq P i ≤ 2000$\n\n$2 \\leq M \\leq 2000$\n\n\n子任务 4 （21 分）$1 \\leq N \\leq 2000$\n\n$1 \\leq P_i \\leq 2000$\n\n$2 \\leq M \\leq 30000$\n\n\n子任务 5 （43 分）$1 \\leq N \\leq 30000$\n\n$1 \\leq P_i \\leq 30000$\n\n$2 \\leq M \\leq 30000$\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2015] Jakarta Skyscrapers", "background": "", "description": "There are $N$ skyscrapers in Jakarta, the capital of Indonesia, arranged in a straight line and numbered from $0$ to $N - 1$ from left to right. There are no other skyscrapers in Jakarta besides these $N$.\n\nThere are $M$ mysterious creatures called \"doge\" living in Jakarta, numbered from $0$ to $M - 1$. Doge $i$ initially lives at skyscraper $B_i$. Each doge has a mysterious power that allows it to jump between skyscrapers. The jumping ability of doge $i$ is $P_i$ ($P_i > 0$).\n\nIn one jump, a doge at skyscraper $b$ with jump ability $p$ can jump to skyscraper $b - p$ (if $0 \\leq b - p < N$) or to skyscraper $b + p$ (if $0 \\leq b + p < N$).\n\nDoge $0$ is the leader of all doges, and it needs to deliver an urgent message to doge $1$ as soon as possible. Any doge that has received the message has two options:\n- Jump to another skyscraper.\n- Pass the message to another doge currently on the same skyscraper.\n\nPlease help the doges compute the minimum total number of jumps required to deliver the message from doge $0$ to doge $1$, or determine that the message can never reach doge $1$.", "inputFormat": "The first line contains two integers $N$ and $M$.\n\nEach of the next $M$ lines contains two integers $B_i$ and $P_i$.", "outputFormat": "Output one line with the minimum number of steps required. If the message can never reach doge $1$, output $-1$.", "hint": "Sample explanation:\n\nBelow is a solution with a total of $5$ jumps:\n\n- Doge $0$ jumps to skyscraper $2$, then jumps to skyscraper $4$ ($2$ jumps).\n- Doge $0$ passes the message to doge $2$.\n- Doge $2$ jumps to skyscraper $3$, then jumps to skyscraper $2$, and then jumps to skyscraper $1$ ($3$ jumps).\n- Doge $2$ passes the message to doge $1$.\n\nConstraints:\n\nAll testdata guarantee $0 \\leq B_i < N$.\n\nSubtask 1 (10 points)\n- $1 \\leq N \\leq 10$\n- $1 \\leq P_i \\leq 10$\n- $2 \\leq M \\leq 3$\n\nSubtask 2 (12 points)\n- $1 \\leq N \\leq 100$\n- $1 \\leq P_i \\leq 100$\n- $2 \\leq M \\leq 2000$\n\nSubtask 3 (14 points)\n- $1 \\leq N \\leq 2000$\n- $1 \\leq P_i \\leq 2000$\n- $2 \\leq M \\leq 2000$\n\nSubtask 4 (21 points)\n- $1 \\leq N \\leq 2000$\n- $1 \\leq P_i \\leq 2000$\n- $2 \\leq M \\leq 30000$\n\nSubtask 5 (43 points)\n- $1 \\leq N \\leq 30000$\n- $1 \\leq P_i \\leq 30000$\n- $2 \\leq M \\leq 30000$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2015] 雅加达的摩天楼", "background": "", "description": "印尼首都雅加达市有 $N$ 座摩天楼，它们排列成一条直线，我们从左到右依次将它们编号为 $0$ 到 $N − 1$。除了这 $N$ 座摩天楼外，雅加达市没有其他摩天楼。\n\n有 $M$ 只叫做 “doge” 的神秘生物在雅加达市居住，它们的编号依次是 $0$ 到 $M − 1$。编号为 $i$ 的 doge 最初居住于编号为 $B_i$ 的摩天楼。每只 doge 都有一种神秘的力量，使它们能够在摩天楼之间跳跃，编号为 $i$ 的 doge 的跳跃能力为 $P_i$ （$P_i > 0$）。\n\n在一次跳跃中，位于摩天楼 $b$ 而跳跃能力为 $p$ 的 doge 可以跳跃到编号为 $b - p$ （如果 $0 \\leq b - p < N$）或 $b + p$ （如果 $0 \\leq b + p < N$）的摩天楼。\n\n编号为 $0$ 的 doge 是所有 doge 的首领，它有一条紧急的消息要尽快传送给编号为 $1$ 的 doge。任何一个收到消息的 doge 有以下两个选择:\n\n- 跳跃到其他摩天楼上；\n- 将消息传递给它当前所在的摩天楼上的其他 doge。\n\n请帮助 doge 们计算将消息从 $0$ 号 doge 传递到 $1$ 号 doge 所需要的最少总跳跃步数，或者告诉它们消息永远不可能传递到 $1$ 号 doge。\n", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$。\n\n接下来 $M$ 行，每行包含两个整数 $B_i$ 和 $P_i$。\n", "outputFormat": "输出一行，表示所需要的最少步数。如果消息永远无法传递到 $1$ 号 doge，输出 $−1$。\n", "hint": "【样例解释】\n\n下面是一种步数为 $5$ 的解决方案：\n\n$0$ 号 doge 跳跃到 $2$ 号摩天楼，再跳跃到 $4$ 号摩天楼（$2$ 步）。\n\n$0$ 号 doge 将消息传递给 $2$ 号 doge。\n\n$2$ 号 doge 跳跃到 $3$ 号摩天楼,接着跳跃到 $2$ 号摩天楼，再跳跃到 $1$ 号摩天楼（$3$ 步）。\n\n$2$ 号 doge 将消息传递给 $1$ 号 doge。\n\n【数据范围】\n\n所有数据都保证 $0 \\leq B_i < N$。\n\n子任务 1 （10 分）$1 \\leq N \\leq 10$\n\n$1 \\leq P_i \\leq 10$\n\n$2 \\leq M \\leq 3$\n\n\n子任务 2 （12 分）$1 \\leq N \\leq 100$\n\n$1 \\leq P_i \\leq 100$\n\n$2 \\leq M \\leq 2000$\n\n\n子任务 3 （14 分）$1 \\leq N \\leq 2000$\n\n$1 \\leq P i ≤ 2000$\n\n$2 \\leq M \\leq 2000$\n\n\n子任务 4 （21 分）$1 \\leq N \\leq 2000$\n\n$1 \\leq P_i \\leq 2000$\n\n$2 \\leq M \\leq 30000$\n\n\n子任务 5 （43 分）$1 \\leq N \\leq 30000$\n\n$1 \\leq P_i \\leq 30000$\n\n$2 \\leq M \\leq 30000$\n", "locale": "zh-CN"}}}
{"pid": "P3646", "type": "P", "difficulty": 5, "samples": [["6 1 3\n8 1 2 1 5 4", "11\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2015", "APIO", "枚举", "进制", "位运算"], "title": "[APIO2015] 巴厘岛的雕塑", "background": "", "description": "印尼巴厘岛的公路上有许多的雕塑,我们来关注它的一条主干道。\n\n在这条主干道上一共有 $N$ 座雕塑，为方便起见，我们把这些雕塑从 $1$ 到 $N$ 连续地进行标号，其中第 $i$ 座雕塑的年龄是 $Y_i$ 年。为了使这条路的环境更加优美，政府想把这些雕塑分成若干组，并通过在组与组之间种上一些树，来吸引更多的游客来巴厘岛。\n\n下面是将雕塑分组的规则：\n\n这些雕塑必须被分为恰好 $X$ 组，其中 $A \\leq X \\leq B$，每组必须含有至少一个雕塑，每个雕塑也必须属于且只属于一个组。同一组中的所有雕塑必须位于这条路的连续一段上。\n\n当雕塑被分好组后，对于每个组，我们首先计算出该组所有雕塑的年龄和。\n\n计算所有年龄和按位取或的结果。我们这个值把称为这一分组的最终优美度。\n\n请问政府能得到的最小的最终优美度是多少?\n\n备注：将两个非负数 $P$ 和 $Q$ 按位取或是这样进行计算的：\n\n首先把 $P$ 和 $Q$ 转换成二进制。\n\n设 $n_P$ 是 $P$ 的二进制位数，$n_Q$ 是 $Q$ 的二进制位数，$M$ 为 $n_P$ 和 $n_Q$ 中的最大值。$P$ 的二进制表示为 $p_{M-1}p_{M-2} \\dots p_1p_0$，$Q$ 的二进制表示为 $q_{M-1}q_{M-2} \\dots q_1 q_0$，其中 $p_i$ 和 $q_i$ 分别是 $P$ 和 $Q$ 二进制表示下的第 $i$ 位，第 $M -1$ 位是数的最高位，第 $0$ 位是数的最低位。\n\n$P$ 与 $Q$ 按位取或后的结果是： $(p_{M-1}\\mathbin{\\mathrm{OR}} q_{M-1})(p_{M-2}\\mathbin{\\mathrm{OR}}q_{M-2})\\dots (p_1\\mathbin{\\mathrm{OR}} q_1) (p_0\\mathbin{\\mathrm{OR}}q_0)$。其中：$0 \\mathbin{\\mathrm{OR}} 0 = 0$\n\n$0 \\mathbin{\\mathrm{OR}} 1 = 1$\n\n$1 \\mathbin{\\mathrm{OR}} 0 = 1$\n\n$1 \\mathbin{\\mathrm{OR}} 1 = 1$\n", "inputFormat": "输入的第一行包含三个用空格分开的整数 $N, A, B$。\n\n第二行包含 $N$ 个用空格分开的整数 $Y_1, Y_2, \\dots, Y_N$。\n", "outputFormat": "输出一行一个数，表示最小的最终优美度。\n", "hint": "【样例解释】\n\n将这些雕塑分为 $2$ 组，$(8, 1, 2)$ 和 $(1, 5, 4)$，它们的和是 $(11)$ 和 $(10)$，最终优美度是 $(11 \\mathbin{\\mathrm{OR}} 10) = 11$。（不难验证，这也是最终优美度的最小值。）\n\n【数据范围】\n\n子任务 1 （9 分）$1 \\leq N \\leq 20$\n\n$1 \\leq A \\leq B \\leq N$\n\n$0 \\leq Y_i \\leq 1000000000$\n\n\n子任务 2 （16 分）$1 \\leq N \\leq 50$\n\n$1 \\leq A \\leq B \\leq \\min\\{20, N\\}$\n\n$0 \\leq Y_i \\leq 10$\n\n\n子任务 3 （21 分）$1 ≤ N ≤ 100$\n\n$A = 1$\n\n$1 \\leq B \\leq N$\n\n$0 \\leq Y_i \\leq 20$\n\n\n子任务 4 （25 分）$1 \\leq N \\leq 100$\n\n$1 \\leq A \\leq B \\leq N$\n\n$0 \\leq Y_i \\leq 1000000000$\n\n\n子任务 5 （29 分）$1 \\leq N \\leq 2000$\n\n$A = 1$\n\n$1 \\leq B \\leq N$\n\n$0 \\leq Y_i \\leq 1000000000$\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2015] Sculptures in Bali", "background": "", "description": "There are many sculptures along the highways of Bali, Indonesia; we focus on one main road.\n\nThere are $N$ sculptures on this road. For convenience, we number them continuously from $1$ to $N$, and the age of the $i$-th sculpture is $Y_i$ years. To make the environment of this road more beautiful, the government wants to divide these sculptures into several groups and plant some trees between groups to attract more tourists to Bali.\n\nThe rules for grouping the sculptures are as follows:\n\nThe sculptures must be divided into exactly $X$ groups, where $A \\leq X \\leq B$. Each group must contain at least one sculpture, and each sculpture must belong to exactly one group. All sculptures within the same group must occupy a contiguous segment along the road.\n\nAfter the sculptures are grouped, for each group we first compute the sum of ages of all sculptures in that group.\n\nThen we compute the bitwise OR of all these sums. We call this value the final aesthetic value of the grouping.\n\nWhat is the minimum possible final aesthetic value the government can obtain?\n\nNote: The bitwise OR of two nonnegative numbers $P$ and $Q$ is computed as follows:\n\nFirst convert $P$ and $Q$ to binary.\n\nLet $n_P$ be the number of binary digits of $P$, $n_Q$ be that of $Q$, and $M$ be the maximum of $n_P$ and $n_Q$. The binary representation of $P$ is $p_{M-1}p_{M-2} \\dots p_1p_0$, and that of $Q$ is $q_{M-1}q_{M-2} \\dots q_1 q_0$, where $p_i$ and $q_i$ are the $i$-th bits in the binary representations of $P$ and $Q$, respectively. The $(M - 1)$-th bit is the most significant bit, and the $0$-th bit is the least significant bit.\n\nThe result of bitwise OR of $P$ and $Q$ is: $(p_{M-1}\\mathbin{\\mathrm{OR}} q_{M-1})(p_{M-2}\\mathbin{\\mathrm{OR}}q_{M-2})\\dots (p_1\\mathbin{\\mathrm{OR}} q_1) (p_0\\mathbin{\\mathrm{OR}}q_0)$. Where: $0 \\mathbin{\\mathrm{OR}} 0 = 0$\n\n$0 \\mathbin{\\mathrm{OR}} 1 = 1$\n\n$1 \\mathbin{\\mathrm{OR}} 0 = 1$\n\n$1 \\mathbin{\\mathrm{OR}} 1 = 1$.", "inputFormat": "The first line contains three integers $N, A, B$ separated by spaces.\n\nThe second line contains $N$ integers $Y_1, Y_2, \\dots, Y_N$ separated by spaces.", "outputFormat": "Output a single line with one number, the minimum possible final aesthetic value.", "hint": "Sample Explanation:\n\nDivide the sculptures into $2$ groups, $(8, 1, 2)$ and $(1, 5, 4)$. Their sums are $(11)$ and $(10)$, and the final aesthetic value is $(11 \\mathbin{\\mathrm{OR}} 10) = 11$. (It is not hard to verify that this is also the minimum final aesthetic value.)\n\nConstraints:\n\nSubtask 1 (9 points) $1 \\leq N \\leq 20$; $1 \\leq A \\leq B \\leq N$; $0 \\leq Y_i \\leq 1000000000$.\n\nSubtask 2 (16 points) $1 \\leq N \\leq 50$; $1 \\leq A \\leq B \\leq \\min\\{20, N\\}$; $0 \\leq Y_i \\leq 10$.\n\nSubtask 3 (21 points) $1 \\leq N \\leq 100$; $A = 1$; $1 \\leq B \\leq N$; $0 \\leq Y_i \\leq 20$.\n\nSubtask 4 (25 points) $1 \\leq N \\leq 100$; $1 \\leq A \\leq B \\leq N$; $0 \\leq Y_i \\leq 1000000000$.\n\nSubtask 5 (29 points) $1 \\leq N \\leq 2000$; $A = 1$; $1 \\leq B \\leq N$; $0 \\leq Y_i \\leq 1000000000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2015] 巴厘岛的雕塑", "background": "", "description": "印尼巴厘岛的公路上有许多的雕塑,我们来关注它的一条主干道。\n\n在这条主干道上一共有 $N$ 座雕塑，为方便起见，我们把这些雕塑从 $1$ 到 $N$ 连续地进行标号，其中第 $i$ 座雕塑的年龄是 $Y_i$ 年。为了使这条路的环境更加优美，政府想把这些雕塑分成若干组，并通过在组与组之间种上一些树，来吸引更多的游客来巴厘岛。\n\n下面是将雕塑分组的规则：\n\n这些雕塑必须被分为恰好 $X$ 组，其中 $A \\leq X \\leq B$，每组必须含有至少一个雕塑，每个雕塑也必须属于且只属于一个组。同一组中的所有雕塑必须位于这条路的连续一段上。\n\n当雕塑被分好组后，对于每个组，我们首先计算出该组所有雕塑的年龄和。\n\n计算所有年龄和按位取或的结果。我们这个值把称为这一分组的最终优美度。\n\n请问政府能得到的最小的最终优美度是多少?\n\n备注：将两个非负数 $P$ 和 $Q$ 按位取或是这样进行计算的：\n\n首先把 $P$ 和 $Q$ 转换成二进制。\n\n设 $n_P$ 是 $P$ 的二进制位数，$n_Q$ 是 $Q$ 的二进制位数，$M$ 为 $n_P$ 和 $n_Q$ 中的最大值。$P$ 的二进制表示为 $p_{M-1}p_{M-2} \\dots p_1p_0$，$Q$ 的二进制表示为 $q_{M-1}q_{M-2} \\dots q_1 q_0$，其中 $p_i$ 和 $q_i$ 分别是 $P$ 和 $Q$ 二进制表示下的第 $i$ 位，第 $M -1$ 位是数的最高位，第 $0$ 位是数的最低位。\n\n$P$ 与 $Q$ 按位取或后的结果是： $(p_{M-1}\\mathbin{\\mathrm{OR}} q_{M-1})(p_{M-2}\\mathbin{\\mathrm{OR}}q_{M-2})\\dots (p_1\\mathbin{\\mathrm{OR}} q_1) (p_0\\mathbin{\\mathrm{OR}}q_0)$。其中：$0 \\mathbin{\\mathrm{OR}} 0 = 0$\n\n$0 \\mathbin{\\mathrm{OR}} 1 = 1$\n\n$1 \\mathbin{\\mathrm{OR}} 0 = 1$\n\n$1 \\mathbin{\\mathrm{OR}} 1 = 1$\n", "inputFormat": "输入的第一行包含三个用空格分开的整数 $N, A, B$。\n\n第二行包含 $N$ 个用空格分开的整数 $Y_1, Y_2, \\dots, Y_N$。\n", "outputFormat": "输出一行一个数，表示最小的最终优美度。\n", "hint": "【样例解释】\n\n将这些雕塑分为 $2$ 组，$(8, 1, 2)$ 和 $(1, 5, 4)$，它们的和是 $(11)$ 和 $(10)$，最终优美度是 $(11 \\mathbin{\\mathrm{OR}} 10) = 11$。（不难验证，这也是最终优美度的最小值。）\n\n【数据范围】\n\n子任务 1 （9 分）$1 \\leq N \\leq 20$\n\n$1 \\leq A \\leq B \\leq N$\n\n$0 \\leq Y_i \\leq 1000000000$\n\n\n子任务 2 （16 分）$1 \\leq N \\leq 50$\n\n$1 \\leq A \\leq B \\leq \\min\\{20, N\\}$\n\n$0 \\leq Y_i \\leq 10$\n\n\n子任务 3 （21 分）$1 ≤ N ≤ 100$\n\n$A = 1$\n\n$1 \\leq B \\leq N$\n\n$0 \\leq Y_i \\leq 20$\n\n\n子任务 4 （25 分）$1 \\leq N \\leq 100$\n\n$1 \\leq A \\leq B \\leq N$\n\n$0 \\leq Y_i \\leq 1000000000$\n\n\n子任务 5 （29 分）$1 \\leq N \\leq 2000$\n\n$A = 1$\n\n$1 \\leq B \\leq N$\n\n$0 \\leq Y_i \\leq 1000000000$\n", "locale": "zh-CN"}}}
{"pid": "P3647", "type": "P", "difficulty": 6, "samples": [["5\n1 2 10\n1 3 40\n1 4 15\n1 5 20", "60"], ["10\n4 10 2\n1 2 21\n1 3 13\n6 7 1\n7 9 5\n2 4 3\n2 5 8\n1 6 55\n6 8 34", "140"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2014", "APIO", "枚举", "树形 DP"], "title": "[APIO2014] 连珠线", "background": "", "description": "在达芬奇时代，有一个流行的儿童游戏称为连珠线。当然，这个游戏是关于珠子和线的。线是红色或蓝色的，珠子被编号为 $1$ 到 $n$。这个游戏从一个珠子开始，每次会用如下方式添加一个新的珠子：\n\n`Append(w, v)`：一个新的珠子 $w$ 和一个已经添加的珠子 $v$ 用红线连接起来。\n\n`Insert(w, u, v)`：一个新的珠子 $w$ 插入到用红线连起来的两个珠子 $u, v$ 之间。具体过程是删去 $u, v$ 之间红线，分别用蓝线连接 $u, w$ 和 $w, v$。\n\n每条线都有一个长度。游戏结束后，你的最终得分为蓝线长度之和。\n\n给你连珠线游戏结束后的游戏局面，只告诉了你珠子和链的连接方式以及每条线的长度，没有告诉你每条线分别是什么颜色。\n\n你需要写一个程序来找出最大可能得分。即，在所有以给出的最终局面结束的连珠线游戏中找出那个得分最大的，然后输出最大可能得分。\n", "inputFormat": "第一行一个正整数 $n$，表示珠子的数量。珠子从 $1$ 到 $n$ 编号。\n\n接下来 $n - 1$ 行每行三个整数 $a_i, b_i, c_i$。保证 $1 \\leq a_i < b_i \\leq n$。$1 \\leq c_i \\leq 10000$。表示 $a_i$ 号珠子和 $b_i$ 号珠子间连了长度为 $c_i$ 的线。\n", "outputFormat": "输出一个整数，表示最大可能得分。\n", "hint": "【样例描述1】\n\n可以通过如下方式获得 $60$ 分：首先从 $3$ 号珠子开始。\n\n把 $5$ 和 $3$ 连起来。（线长度任意）\n\n在 $3$ 和 $5$ 之间插入 $1$。（线长分别为 $40$ 和 $20$）。\n\n把 $2$ 和 $1$ 用长度为 $10$ 的线连起来。\n\n把 $4$ 和 $1$ 用长度为 $15$ 的线连起来。\n\n\n【限制与约定】\n\n第一个子任务共 13 分，满足 $1 \\leq n \\leq 10$。\n\n第二个子任务共 15 分，满足 $1 \\leq n \\leq 200$。\n\n第三个子任务共 29 分，满足 $1 \\leq n \\leq 10000$。\n\n第四个子任务共 43 分，满足 $1 \\leq n \\leq 200000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2014] Beads and Wires", "background": "", "description": "In the era of Da Vinci, there was a popular children's game called Beads and Wires. As the name suggests, the game involves beads and wires. The wires are either red or blue, and the beads are numbered from $1$ to $n$. The game starts with a single bead, and each time a new bead is added using one of the following operations:\n\n`Append(w, v)`: Connect a new bead $w$ to an already added bead $v$ with a red wire.\n\n`Insert(w, u, v)`: Insert a new bead $w$ between two beads $u$ and $v$ that are connected by a red wire. Specifically, remove the red wire between $u$ and $v$, and connect $u$ to $w$ and $w$ to $v$ with blue wires.\n\nEach wire has a length. After the game ends, your final score is the sum of the lengths of all blue wires.\n\nYou are given the final configuration of the Beads and Wires game: which beads are connected and the length of each wire. However, you are not told the color of each wire.\n\nYour task is to write a program to find the maximum possible score. That is, among all games that could lead to the given final configuration, find the one with the highest score and output that maximum possible score.", "inputFormat": "The first line contains a positive integer $n$, the number of beads. The beads are numbered from $1$ to $n$.\n\nEach of the next $n - 1$ lines contains three integers $a_i, b_i, c_i$. It is guaranteed that $1 \\leq a_i < b_i \\leq n$ and $1 \\leq c_i \\leq 10000$. This means there is a wire of length $c_i$ between beads $a_i$ and $b_i$.", "outputFormat": "Output a single integer, the maximum possible score.", "hint": "[Sample Description 1]\n\nA score of $60$ can be achieved as follows: start from bead $3$.\n\n- Connect $5$ and $3$. (length arbitrary)\n- Insert $1$ between $3$ and $5$. (the lengths are $40$ and $20$ respectively)\n- Connect $2$ to $1$ with a wire of length $10$.\n- Connect $4$ to $1$ with a wire of length $15$.\n\n[Constraints]\n\n- Subtask 1 (13 points): $1 \\leq n \\leq 10$.\n- Subtask 2 (15 points): $1 \\leq n \\leq 200$.\n- Subtask 3 (29 points): $1 \\leq n \\leq 10000$.\n- Subtask 4 (43 points): $1 \\leq n \\leq 200000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2014] 连珠线", "background": "", "description": "在达芬奇时代，有一个流行的儿童游戏称为连珠线。当然，这个游戏是关于珠子和线的。线是红色或蓝色的，珠子被编号为 $1$ 到 $n$。这个游戏从一个珠子开始，每次会用如下方式添加一个新的珠子：\n\n`Append(w, v)`：一个新的珠子 $w$ 和一个已经添加的珠子 $v$ 用红线连接起来。\n\n`Insert(w, u, v)`：一个新的珠子 $w$ 插入到用红线连起来的两个珠子 $u, v$ 之间。具体过程是删去 $u, v$ 之间红线，分别用蓝线连接 $u, w$ 和 $w, v$。\n\n每条线都有一个长度。游戏结束后，你的最终得分为蓝线长度之和。\n\n给你连珠线游戏结束后的游戏局面，只告诉了你珠子和链的连接方式以及每条线的长度，没有告诉你每条线分别是什么颜色。\n\n你需要写一个程序来找出最大可能得分。即，在所有以给出的最终局面结束的连珠线游戏中找出那个得分最大的，然后输出最大可能得分。\n", "inputFormat": "第一行一个正整数 $n$，表示珠子的数量。珠子从 $1$ 到 $n$ 编号。\n\n接下来 $n - 1$ 行每行三个整数 $a_i, b_i, c_i$。保证 $1 \\leq a_i < b_i \\leq n$。$1 \\leq c_i \\leq 10000$。表示 $a_i$ 号珠子和 $b_i$ 号珠子间连了长度为 $c_i$ 的线。\n", "outputFormat": "输出一个整数，表示最大可能得分。\n", "hint": "【样例描述1】\n\n可以通过如下方式获得 $60$ 分：首先从 $3$ 号珠子开始。\n\n把 $5$ 和 $3$ 连起来。（线长度任意）\n\n在 $3$ 和 $5$ 之间插入 $1$。（线长分别为 $40$ 和 $20$）。\n\n把 $2$ 和 $1$ 用长度为 $10$ 的线连起来。\n\n把 $4$ 和 $1$ 用长度为 $15$ 的线连起来。\n\n\n【限制与约定】\n\n第一个子任务共 13 分，满足 $1 \\leq n \\leq 10$。\n\n第二个子任务共 15 分，满足 $1 \\leq n \\leq 200$。\n\n第三个子任务共 29 分，满足 $1 \\leq n \\leq 10000$。\n\n第四个子任务共 43 分，满足 $1 \\leq n \\leq 200000$。\n", "locale": "zh-CN"}}}
{"pid": "P3648", "type": "P", "difficulty": 6, "samples": [["7 3\n4 1 3 4 0 2 3", "108\n1 3 5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "APIO", "Special Judge", "枚举", "斜率优化", "前缀和"], "title": "[APIO2014] 序列分割", "background": "", "description": "你正在玩一个关于长度为 $n$ 的非负整数序列的游戏。这个游戏中你需要把序列分成 $k + 1$ 个非空的块。为了得到 $k + 1$ 块，你需要重复下面的操作 $k$ 次：\n\n选择一个有超过一个元素的块（初始时你只有一块，即整个序列）。\n\n选择两个相邻元素把这个块从中间分开，得到两个非空的块。\n\n每次操作后你将获得那两个新产生的块的元素和的乘积的分数。你想要最大化最后的总得分。", "inputFormat": "第一行包含两个整数 $n$ 和 $k$。保证 $k + 1 \\leq n$。\n\n第二行包含 $n$ 个非负整数 $a_1, a_2, \\cdots, a_n$ $(0 \\leq a_i \\leq 10^4)$，表示前文所述的序列。", "outputFormat": "第一行输出你能获得的最大总得分。\n\n第二行输出 $k$ 个介于 $1$ 到 $n - 1$ 之间的整数，表示为了使得总得分最大，你每次操作中分开两个块的位置。第 $i$ 个整数 $s_i$ 表示第 $i$ 次操作将在 $s_i$ 和 $s_{i} + 1$ 之间把块分开。\n\n如果有多种方案使得总得分最大，输出任意一种方案即可。", "hint": "你可以通过下面这些操作获得 $108$ 分：\n\n初始时你有一块 $(4, 1, 3, 4, 0, 2, 3)$。在第 $1$ 个元素后面分开，获得 $4 \\times (1 + 3 + 4 + 0 + 2 + 3) = 52$ 分。\n\n你现在有两块 $(4), (1, 3, 4, 0, 2, 3)$。在第 $3$ 个元素后面分开，获得 $(1 + 3) \\times (4 + 0 + 2 + 3) = 36$ 分。\n\n你现在有三块 $(4), (1, 3), (4, 0, 2, 3)$。在第 $5$ 个元素后面分开，获得 $(4 + 0) \\times (2 + 3) = 20$ 分。\n\n所以，经过这些操作后你可以获得四块 $(4), (1, 3), (4, 0), (2, 3)$ 并获得 $52 + 36 + 20 = 108$ 分。\n\n**【限制与约定】**\n\n第一个子任务共 11 分，满足 $1 \\leq k < n \\leq 10$。\n\n第二个子任务共 11 分，满足 $1 \\leq k < n \\leq 50$。\n\n第三个子任务共 11 分，满足 $1 \\leq k < n \\leq 200$。\n\n第四个子任务共 17 分，满足 $2 \\leq n \\leq 1000, 1 \\leq k \\leq \\min\\{n - 1, 200\\}$。\n\n第五个子任务共 21 分，满足 $2 \\leq n \\leq 10000, 1 \\leq k \\leq \\min\\{n - 1, 200\\}$。\n\n第六个子任务共 29 分，满足 $2 \\leq n \\leq 100000, 1 \\leq k \\leq \\min\\{n - 1, 200\\}$。\n\n感谢 @larryzhong  提供的加强数据。", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2014] Split the Sequence", "background": "", "description": "You are playing a game on a sequence of non-negative integers of length $n$. In this game, you need to split the sequence into $k + 1$ non-empty blocks. To obtain $k + 1$ blocks, repeat the following operation $k$ times:\n\n- Choose a block that has more than one element (initially, you have a single block, i.e., the entire sequence).\n- Choose two adjacent elements and split this block between them into two non-empty blocks.\n- After each operation, you gain a score equal to the product of the sums of elements in the two newly created blocks. You want to maximize the final total score.", "inputFormat": "The first line contains two integers $n$ and $k$. It is guaranteed that $k + 1 \\leq n$.\n\nThe second line contains $n$ non-negative integers $a_1, a_2, \\cdots, a_n$ ($0 \\leq a_i \\leq 10^4$), representing the sequence described above.", "outputFormat": "On the first line, output the maximum total score you can obtain.\n\nOn the second line, output $k$ integers between $1$ and $n - 1$, indicating the positions where you split between two elements in each operation to maximize the total score. The $i$-th integer $s_i$ means that at the $i$-th operation you split between positions $s_i$ and $s_i + 1$.\n\nIf there are multiple optimal solutions, output any of them.", "hint": "You can obtain a score of $108$ by the following operations:\n\nInitially, you have one block $(4, 1, 3, 4, 0, 2, 3)$. Split after the 1st element to gain $4 \\times (1 + 3 + 4 + 0 + 2 + 3) = 52$ points.\n\nYou now have two blocks $(4), (1, 3, 4, 0, 2, 3)$. Split after the 3rd element to gain $(1 + 3) \\times (4 + 0 + 2 + 3) = 36$ points.\n\nYou now have three blocks $(4), (1, 3), (4, 0, 2, 3)$. Split after the 5th element to gain $(4 + 0) \\times (2 + 3) = 20$ points.\n\nTherefore, after these operations you obtain four blocks $(4), (1, 3), (4, 0), (2, 3)$ and a total score of $52 + 36 + 20 = 108$.\n\nConstraints:\n- Subtask 1 (11 points): $1 \\leq k < n \\leq 10$.\n- Subtask 2 (11 points): $1 \\leq k < n \\leq 50$.\n- Subtask 3 (11 points): $1 \\leq k < n \\leq 200$.\n- Subtask 4 (17 points): $2 \\leq n \\leq 1000$, $1 \\leq k \\leq \\min\\{n - 1, 200\\}$.\n- Subtask 5 (21 points): $2 \\leq n \\leq 10000$, $1 \\leq k \\leq \\min\\{n - 1, 200\\}$.\n- Subtask 6 (29 points): $2 \\leq n \\leq 100000$, $1 \\leq k \\leq \\min\\{n - 1, 200\\}$.\n\nThanks to @larryzhong for providing strengthened testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2014] 序列分割", "background": "", "description": "你正在玩一个关于长度为 $n$ 的非负整数序列的游戏。这个游戏中你需要把序列分成 $k + 1$ 个非空的块。为了得到 $k + 1$ 块，你需要重复下面的操作 $k$ 次：\n\n选择一个有超过一个元素的块（初始时你只有一块，即整个序列）。\n\n选择两个相邻元素把这个块从中间分开，得到两个非空的块。\n\n每次操作后你将获得那两个新产生的块的元素和的乘积的分数。你想要最大化最后的总得分。", "inputFormat": "第一行包含两个整数 $n$ 和 $k$。保证 $k + 1 \\leq n$。\n\n第二行包含 $n$ 个非负整数 $a_1, a_2, \\cdots, a_n$ $(0 \\leq a_i \\leq 10^4)$，表示前文所述的序列。", "outputFormat": "第一行输出你能获得的最大总得分。\n\n第二行输出 $k$ 个介于 $1$ 到 $n - 1$ 之间的整数，表示为了使得总得分最大，你每次操作中分开两个块的位置。第 $i$ 个整数 $s_i$ 表示第 $i$ 次操作将在 $s_i$ 和 $s_{i} + 1$ 之间把块分开。\n\n如果有多种方案使得总得分最大，输出任意一种方案即可。", "hint": "你可以通过下面这些操作获得 $108$ 分：\n\n初始时你有一块 $(4, 1, 3, 4, 0, 2, 3)$。在第 $1$ 个元素后面分开，获得 $4 \\times (1 + 3 + 4 + 0 + 2 + 3) = 52$ 分。\n\n你现在有两块 $(4), (1, 3, 4, 0, 2, 3)$。在第 $3$ 个元素后面分开，获得 $(1 + 3) \\times (4 + 0 + 2 + 3) = 36$ 分。\n\n你现在有三块 $(4), (1, 3), (4, 0, 2, 3)$。在第 $5$ 个元素后面分开，获得 $(4 + 0) \\times (2 + 3) = 20$ 分。\n\n所以，经过这些操作后你可以获得四块 $(4), (1, 3), (4, 0), (2, 3)$ 并获得 $52 + 36 + 20 = 108$ 分。\n\n**【限制与约定】**\n\n第一个子任务共 11 分，满足 $1 \\leq k < n \\leq 10$。\n\n第二个子任务共 11 分，满足 $1 \\leq k < n \\leq 50$。\n\n第三个子任务共 11 分，满足 $1 \\leq k < n \\leq 200$。\n\n第四个子任务共 17 分，满足 $2 \\leq n \\leq 1000, 1 \\leq k \\leq \\min\\{n - 1, 200\\}$。\n\n第五个子任务共 21 分，满足 $2 \\leq n \\leq 10000, 1 \\leq k \\leq \\min\\{n - 1, 200\\}$。\n\n第六个子任务共 29 分，满足 $2 \\leq n \\leq 100000, 1 \\leq k \\leq \\min\\{n - 1, 200\\}$。\n\n感谢 @larryzhong  提供的加强数据。", "locale": "zh-CN"}}}
{"pid": "P3649", "type": "P", "difficulty": 6, "samples": [["abacaba\n", "7\n"], ["www", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "2014", "APIO", "后缀自动机 SAM", "后缀数组 SA", "回文自动机 PAM"], "title": "[APIO2014] 回文串", "background": "", "description": "给你一个由小写拉丁字母组成的字符串 $s$。我们定义 $s$ 的一个子串的存在值为这个子串在 $s$ 中出现的次数乘以这个子串的长度。\n\n对于给你的这个字符串 $s$，求所有回文子串中的最大存在值。\n", "inputFormat": "一行，一个由小写拉丁字母（a~z）组成的非空字符串 $s$。\n", "outputFormat": "输出一个整数，表示所有回文子串中的最大存在值。\n", "hint": "【样例解释1】\n\n用 $\\lvert s \\rvert$ 表示字符串 $s$ 的长度。\n\n一个字符串 $s_1 s_2 \\dots s_{\\lvert s \\rvert}$ 的子串是一个非空字符串 $s_i s_{i+1} \\dots s_j$，其中 $1 \\leq i \\leq j \\leq \\lvert s \\rvert$。每个字符串都是自己的子串。\n\n一个字符串被称作回文串当且仅当这个字符串从左往右读和从右往左读都是相同的。\n\n这个样例中，有 $7$ 个回文子串 a，b，c，aba，aca，bacab，abacaba。他们的存在值分别为 $4, 2, 1, 6, 3, 5, 7$。\n\n所以回文子串中最大的存在值为 $7$。\n\n\n\n第一个子任务共 8 分，满足 $1 \\leq \\lvert s \\rvert \\leq 100$。\n\n第二个子任务共 15 分，满足 $1 \\leq \\lvert s \\rvert \\leq 1000$。\n\n第三个子任务共 24 分，满足 $1 \\leq \\lvert s \\rvert \\leq 10000$。\n\n第四个子任务共 26 分，满足 $1 \\leq \\lvert s \\rvert \\leq 100000$。\n\n第五个子任务共 27 分，满足 $1 \\leq \\lvert s \\rvert \\leq 300000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2014] Palindrome", "background": "", "description": "You are given a string $s$ consisting of lowercase Latin letters. We define the existence value of a substring of $s$ as the number of occurrences of this substring in $s$ multiplied by its length.\n\nFor the given string $s$, find the maximum existence value among all palindromic substrings.", "inputFormat": "One line, a non-empty string $s$ consisting of lowercase Latin letters (a~z).", "outputFormat": "Output a single integer, the maximum existence value among all palindromic substrings.", "hint": "Sample Explanation 1\n\nUse $\\lvert s \\rvert$ to denote the length of string $s$.\n\nA substring of a string $s_1 s_2 \\dots s_{\\lvert s \\rvert}$ is a non-empty string $s_i s_{i+1} \\dots s_j$, where $1 \\leq i \\leq j \\leq \\lvert s \\rvert$. Every string is a substring of itself.\n\nA string is called a palindrome if and only if it reads the same from left to right and from right to left.\n\nIn this sample, there are $7$ palindromic substrings a, b, c, aba, aca, bacab, abacaba. Their existence values are $4, 2, 1, 6, 3, 5, 7$, respectively.\n\nTherefore, the maximum existence value among palindromic substrings is $7$.\n\nSubtasks\n\n- Subtask 1 (8 points): $1 \\leq \\lvert s \\rvert \\leq 100$.\n- Subtask 2 (15 points): $1 \\leq \\lvert s \\rvert \\leq 1000$.\n- Subtask 3 (24 points): $1 \\leq \\lvert s \\rvert \\leq 10000$.\n- Subtask 4 (26 points): $1 \\leq \\lvert s \\rvert \\leq 100000$.\n- Subtask 5 (27 points): $1 \\leq \\lvert s \\rvert \\leq 300000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2014] 回文串", "background": "", "description": "给你一个由小写拉丁字母组成的字符串 $s$。我们定义 $s$ 的一个子串的存在值为这个子串在 $s$ 中出现的次数乘以这个子串的长度。\n\n对于给你的这个字符串 $s$，求所有回文子串中的最大存在值。\n", "inputFormat": "一行，一个由小写拉丁字母（a~z）组成的非空字符串 $s$。\n", "outputFormat": "输出一个整数，表示所有回文子串中的最大存在值。\n", "hint": "【样例解释1】\n\n用 $\\lvert s \\rvert$ 表示字符串 $s$ 的长度。\n\n一个字符串 $s_1 s_2 \\dots s_{\\lvert s \\rvert}$ 的子串是一个非空字符串 $s_i s_{i+1} \\dots s_j$，其中 $1 \\leq i \\leq j \\leq \\lvert s \\rvert$。每个字符串都是自己的子串。\n\n一个字符串被称作回文串当且仅当这个字符串从左往右读和从右往左读都是相同的。\n\n这个样例中，有 $7$ 个回文子串 a，b，c，aba，aca，bacab，abacaba。他们的存在值分别为 $4, 2, 1, 6, 3, 5, 7$。\n\n所以回文子串中最大的存在值为 $7$。\n\n\n\n第一个子任务共 8 分，满足 $1 \\leq \\lvert s \\rvert \\leq 100$。\n\n第二个子任务共 15 分，满足 $1 \\leq \\lvert s \\rvert \\leq 1000$。\n\n第三个子任务共 24 分，满足 $1 \\leq \\lvert s \\rvert \\leq 10000$。\n\n第四个子任务共 26 分，满足 $1 \\leq \\lvert s \\rvert \\leq 100000$。\n\n第五个子任务共 27 分，满足 $1 \\leq \\lvert s \\rvert \\leq 300000$。\n", "locale": "zh-CN"}}}
{"pid": "P3650", "type": "P", "difficulty": 2, "samples": [["5\n20\n4\n1\n24\n21", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "贪心", "USACO", "三分", "枚举"], "title": "[USACO1.3] 滑雪课程设计Ski Course Design", "background": null, "description": "农民约翰的农场里有 $n$ 座山峰，每座山都有一个在 $0$ 到 $100$ 之间的整数的海拔高度。在冬天,因为山上有丰富的积雪，约翰经常开办滑雪训练营。\n\n不幸的是，约翰刚刚得知税法在滑雪训练营方面有新变化，明年开始实施。在仔细阅读法律后，他发现如果滑雪训练营的最高和最低的山峰海拔高度差大于 $17$ 就要收税。因此，如果他改变山峰的高度（使最高与最低的山峰海拔高度差不超过 $17$ ），约翰可以避免支付税收。\n\n如果改变一座山 $x$ 单位的高度成本是 $x^2$ 单位，约翰最少需要付多少钱才能使海拔最高的山峰与海拔最低的山峰的高度之差不超过 $17$。约翰只愿意改变整数单位的高度。", "inputFormat": "输入的第一行是一个整数，代表山峰的数量 $n$。\n\n第 $2$ 行到$(n + 1)$ 行，每行一个整数。第 $i$ 行的整数 $a_i$ 代表第 $i$ 座山的海拔高度。", "outputFormat": "输出一行一个整数，代表约翰需要支付修改山海拔高度的总金额。", "hint": "#### 样例输入输出 1 解释\n\n约翰保持高度为 $4$、$20$ 和 $21$ 的山的高度。他增高高度为 $1$ 的山，变成高度 $4$ ，花费 $3^2 = 9$。他降低了高度为 $24$ 的山变成高度 $21$，也花费 $3 ^ 2 = 9$。因此总共花费 $9 + 9 = 18$。\n\n---\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 1000$，$0 \\leq a_i \\leq 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.3] Ski Course Design", "background": "", "description": "Farmer John has $n$ hills on his farm, each with an integer elevation between $0$ and $100$. In winter, thanks to the abundant snow, he often runs ski training camps.\n\nUnfortunately, John has just learned of a new tax law related to ski training camps that will take effect next year. After carefully reading the law, he found that if the difference between the highest and lowest hill elevations in a camp exceeds $17$, he must pay tax. Therefore, if he adjusts the hill elevations so that the difference between the highest and lowest elevations does not exceed $17$, John can avoid paying the tax.\n\nIf changing a hill’s elevation by $x$ units costs $x^2$ units, what is the minimum total cost for John to ensure that the difference between the highest and lowest elevations does not exceed $17$? John only changes heights by integer amounts.", "inputFormat": "The first line contains an integer $n$, the number of hills.\n\nLines $2$ to $(n + 1)$ each contain one integer. The integer on the $i$-th line $a_i$ represents the elevation of the $i$-th hill.", "outputFormat": "Output a single integer, the total cost John must pay to adjust the hill elevations.", "hint": "Sample 1 explanation:\nJohn keeps the hills of elevations $4$, $20$, and $21$. He raises the hill of elevation $1$ to $4$, costing $3^2 = 9$. He lowers the hill of elevation $24$ to $21$, also costing $3^2 = 9$. Therefore, the total cost is $9 + 9 = 18$.\n\nConstraints:\nFor $100\\%$ of the testdata, $1 \\le n \\le 1000$, $0 \\le a_i \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.3] 滑雪课程设计Ski Course Design", "background": null, "description": "农民约翰的农场里有 $n$ 座山峰，每座山都有一个在 $0$ 到 $100$ 之间的整数的海拔高度。在冬天,因为山上有丰富的积雪，约翰经常开办滑雪训练营。\n\n不幸的是，约翰刚刚得知税法在滑雪训练营方面有新变化，明年开始实施。在仔细阅读法律后，他发现如果滑雪训练营的最高和最低的山峰海拔高度差大于 $17$ 就要收税。因此，如果他改变山峰的高度（使最高与最低的山峰海拔高度差不超过 $17$ ），约翰可以避免支付税收。\n\n如果改变一座山 $x$ 单位的高度成本是 $x^2$ 单位，约翰最少需要付多少钱才能使海拔最高的山峰与海拔最低的山峰的高度之差不超过 $17$。约翰只愿意改变整数单位的高度。", "inputFormat": "输入的第一行是一个整数，代表山峰的数量 $n$。\n\n第 $2$ 行到$(n + 1)$ 行，每行一个整数。第 $i$ 行的整数 $a_i$ 代表第 $i$ 座山的海拔高度。", "outputFormat": "输出一行一个整数，代表约翰需要支付修改山海拔高度的总金额。", "hint": "#### 样例输入输出 1 解释\n\n约翰保持高度为 $4$、$20$ 和 $21$ 的山的高度。他增高高度为 $1$ 的山，变成高度 $4$ ，花费 $3^2 = 9$。他降低了高度为 $24$ 的山变成高度 $21$，也花费 $3 ^ 2 = 9$。因此总共花费 $9 + 9 = 18$。\n\n---\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 1000$，$0 \\leq a_i \\leq 100$。", "locale": "zh-CN"}}}
{"pid": "P3651", "type": "P", "difficulty": 5, "samples": [["4\n2 2\n1 6\n1 3\n3 1", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "枚举", "基环树", "洛谷月赛"], "title": "展翅翱翔之时 (はばたきのとき)", "background": "**船が往くよミライへ旅立とう**\n\n**船只启航 朝未来展开旅途**\n\n**青い空笑ってる（なにがしたい?）**\n\n**湛蓝天空露出微笑（想做些什么?）**\n\n**ヒカリになろうミライを照らしたい**\n\n**化作光芒吧 想就此照亮未来**\n\n**輝きは心からあふれ出してもっと先の景色望むんだ**\n\n**光辉自内心满溢而出 愿能望见更加前方的景色**\n\n**Ah!やっと手にしたミライチケットかざして…！**\n\n**Ah!挥舞起终于得手的未来门票…！**\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4529.png) \n\n我们Aqours，终于闪闪发亮了！\n\n\n2月25和26日，将是我们登上横滨ARENA演唱的日子！\n\n\n而且，还要在全日本、甚至全世界的好多影院进行转播呢！\n\n\n转播好像还是通过中继卫星传输的呢！\n\n\n未来ずら！\n", "description": "不过，好像中继卫星上，出了一些问题呢……\n\n我们的中继卫星一共有 $N$ 颗，编号成 $1$ 到 $N$。不过，好像一个中继卫星可以且仅可以单向地从另一颗中继卫星那儿接收数据。\n\n第 $i$ 颗卫星现在已经被设定到了从第 $A_i$ 颗卫星（称为接收源）那儿接受数据。\n\n不过这些中继卫星的接收源是可以修改的，只不过每次修改要花一定的资金呢。\n\n听说要达成中继的话，这些卫星之间必须**两两之间能够互相（直接或间接）通信**才行啊。\n\n虽然鞠莉家里很有钱，可是这么大的花费，也得提前准备一下呢。\n\n所以，你能帮我们算算这样子一共最少要花多少钱吗？", "inputFormat": "第一行一个整数 $N$。\n\n接下来 $N$ 行，每行 $2$ 个整数 $A_i,C_i$，表示初始时，第 $i$ 个中继卫星从第 $A_i$ 颗卫星处接收数据，以及该卫星调整接收源的所需花费。", "outputFormat": "输出一个整数，表示鞠莉所需准备的最小的花费。\n", "hint": "### 数据范围及约定\n\n- 对于 $10\\%$ 的数据，满足 $N \\le 10$。\n- 对于 $40\\%$ 的数据，满足 $N \\le 15$。\n- 对于 $70\\%$ 的数据，满足 $N \\le 3000$。\n- 对于 $100\\%$ 的数据，满足 $2 \\le N \\le 100000,1 \\le C_i \\le 10^9$。\n\n### 以下是彩蛋\n\n事实上 LoveLive 的直播卫星中继只有一颗星，而且永远都是不加密的。\n\n导致只要有一个卫星锅就可以在家偷偷看直播，也就是传说中的卫星源。\n\nlin_toto：万代南梦宫都把浅水湾给买了，居然只有回放，只好跑到香港 the sky 去看 + 手动滑稽。\n\n至于为什么看转播，eplus 表示 LoveLive 系列演唱会的票大家尽管抽选尽管抢，买得到算我输。\n\n于是 lin_toto 在去年 μ's Final LoveLive 的时候拿肉鸡把 eplus 搞趴下了，然后就买到了。\n\n于是今年 eplus 连抢票都不让抢了，全抽选，抽得到算我输。\n\n然后 lin_toto 就去看转播了。\n", "locale": "zh-CN", "translations": {"en": {"title": "Time to Spread Wings (はばたきのとき)", "background": "**The ship sails on, let's set off toward the future.**\n\n**The ship sets sail, embarking on a journey toward the future.**\n\n**The blue sky is smiling (what do you want to do?).**\n\n**The azure sky is smiling (what do you want to do?).**\n\n**Let's become light; I want to illuminate the future.**\n\n**Become a ray of light; I want to shine on the future.**\n\n**Radiance overflows from the heart; I long to see the scenery even farther ahead.**\n\n**Brilliance wells up from the heart; I wish to behold the view farther ahead.**\n\n**Ah! Raise the future ticket we've finally gotten…!**\n\n**Ah! Wave the future ticket we've finally obtained…!**\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4529.png) \n\nWe, Aqours, have finally begun to shine!\n\nFebruary 25 and 26 will be the days we perform at Yokohama ARENA!\n\nAnd it will be broadcast in many theaters across all of Japan, and even around the world!\n\nIt seems the broadcast is relayed via satellites!\n\nMirai zura!", "description": "However, it seems there is some trouble with the relay satellites…\n\nWe have a total of $N$ relay satellites, numbered $1$ to $N$. Each relay satellite can and only can receive data unidirectionally from exactly one other relay satellite.\n\nThe $i$-th satellite is currently set to receive data from the $A_i$-th satellite (called the source).\n\nThe source of these relay satellites can be modified, but each modification costs some money.\n\nIt is said that to achieve relaying, these satellites must be able to communicate with each other pairwise (directly or indirectly).\n\nAlthough Mari is very rich, expenses this large still need to be planned in advance.\n\nSo, can you help us calculate the minimum total amount of money needed?", "inputFormat": "The first line contains an integer $N$.\n\nThen $N$ lines follow. Each line contains $2$ integers $A_i, C_i$, indicating that initially the $i$-th relay satellite receives data from the $A_i$-th satellite, and the cost required to adjust the source of this satellite.", "outputFormat": "Output a single integer, which is the minimum cost that Mari needs to prepare.", "hint": "### Constraints and Notes\n\n- For $10\\%$ of the testdata, $N \\le 10$.\n- For $40\\%$ of the testdata, $N \\le 15$.\n- For $70\\%$ of the testdata, $N \\le 3000$.\n- For $100\\%$ of the testdata, $2 \\le N \\le 100000$, $1 \\le C_i \\le 10^9$.\n\n### Easter egg\n\nIn fact, LoveLive’s live satellite relay uses only one satellite, and it is never encrypted.\n\nAs a result, as long as you have a satellite dish, you can secretly watch the live broadcast at home — the legendary satellite source.\n\nlin_toto: Bandai Namco even bought out Shallow Water Bay, yet there was only a replay, so I had to go to Hong Kong’s the sky to watch (wry smile).\n\nAs for why watch a relay screening, eplus says for LoveLive series concerts, everyone can enter lotteries and try to buy; if you manage to buy a ticket, I lose.\n\nSo last year during μ's Final LoveLive, lin_toto took down eplus with a botnet and then managed to buy tickets.\n\nThis year, eplus didn’t even allow rush purchases; it was all lotteries. If you get selected, I lose.\n\nSo lin_toto went to watch the relay screening.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "展翅翱翔之时 (はばたきのとき)", "background": "**船が往くよミライへ旅立とう**\n\n**船只启航 朝未来展开旅途**\n\n**青い空笑ってる（なにがしたい?）**\n\n**湛蓝天空露出微笑（想做些什么?）**\n\n**ヒカリになろうミライを照らしたい**\n\n**化作光芒吧 想就此照亮未来**\n\n**輝きは心からあふれ出してもっと先の景色望むんだ**\n\n**光辉自内心满溢而出 愿能望见更加前方的景色**\n\n**Ah!やっと手にしたミライチケットかざして…！**\n\n**Ah!挥舞起终于得手的未来门票…！**\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4529.png) \n\n我们Aqours，终于闪闪发亮了！\n\n\n2月25和26日，将是我们登上横滨ARENA演唱的日子！\n\n\n而且，还要在全日本、甚至全世界的好多影院进行转播呢！\n\n\n转播好像还是通过中继卫星传输的呢！\n\n\n未来ずら！\n", "description": "不过，好像中继卫星上，出了一些问题呢……\n\n我们的中继卫星一共有 $N$ 颗，编号成 $1$ 到 $N$。不过，好像一个中继卫星可以且仅可以单向地从另一颗中继卫星那儿接收数据。\n\n第 $i$ 颗卫星现在已经被设定到了从第 $A_i$ 颗卫星（称为接收源）那儿接受数据。\n\n不过这些中继卫星的接收源是可以修改的，只不过每次修改要花一定的资金呢。\n\n听说要达成中继的话，这些卫星之间必须**两两之间能够互相（直接或间接）通信**才行啊。\n\n虽然鞠莉家里很有钱，可是这么大的花费，也得提前准备一下呢。\n\n所以，你能帮我们算算这样子一共最少要花多少钱吗？", "inputFormat": "第一行一个整数 $N$。\n\n接下来 $N$ 行，每行 $2$ 个整数 $A_i,C_i$，表示初始时，第 $i$ 个中继卫星从第 $A_i$ 颗卫星处接收数据，以及该卫星调整接收源的所需花费。", "outputFormat": "输出一个整数，表示鞠莉所需准备的最小的花费。\n", "hint": "### 数据范围及约定\n\n- 对于 $10\\%$ 的数据，满足 $N \\le 10$。\n- 对于 $40\\%$ 的数据，满足 $N \\le 15$。\n- 对于 $70\\%$ 的数据，满足 $N \\le 3000$。\n- 对于 $100\\%$ 的数据，满足 $2 \\le N \\le 100000,1 \\le C_i \\le 10^9$。\n\n### 以下是彩蛋\n\n事实上 LoveLive 的直播卫星中继只有一颗星，而且永远都是不加密的。\n\n导致只要有一个卫星锅就可以在家偷偷看直播，也就是传说中的卫星源。\n\nlin_toto：万代南梦宫都把浅水湾给买了，居然只有回放，只好跑到香港 the sky 去看 + 手动滑稽。\n\n至于为什么看转播，eplus 表示 LoveLive 系列演唱会的票大家尽管抽选尽管抢，买得到算我输。\n\n于是 lin_toto 在去年 μ's Final LoveLive 的时候拿肉鸡把 eplus 搞趴下了，然后就买到了。\n\n于是今年 eplus 连抢票都不让抢了，全抽选，抽得到算我输。\n\n然后 lin_toto 就去看转播了。\n", "locale": "zh-CN"}}}
{"pid": "P3652", "type": "P", "difficulty": 6, "samples": [["2 3 1 1\n2 2 2\n4 4 4\n2 1 1\n1 1 1\n1 2 1\n1 3 1\n2 3 4", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["网络流", "洛谷原创"], "title": "csh和zzy的战争", "background": "（背景~~有点~~长，你可以选择读完，也可以选择跳过。）\n\n公元 2040 年，csh 和 zzy 在丑国蛙谷展开了关于非线性配微分方程的正确性与否的相关辩论，史称第四次数学危机。两个人近千页的非人类学术性论文，使整个世界没有其他人听得懂他们在说什么，于是，以 csh 为首的 A 派科学家和以 zzy 为首的 B 派科学家展开了在多次对抗无果之后开始使用武装革命解决，进而引发了全球性的第三次世界大战。作为战争中立派的居润国不想卷入任何一方的斗争，只想喝完手中的咖啡，然而两方元首在多次对抛出橄榄枝无果之后，对居润国提出了一个要求：解决他们在战争中的运送物资问题，当然这个问题早就在 $10^0$ s 内被他们解决，但是居润国却不知道怎么办，而且也不能报上错误的答案，于是就求助了聪明的你们。", "description": "现在有 $n$ 个货物发源地，里面是一些待运送的货物。前方有 $m$ 个中转小岛，而你的目的是将所有货物运到战争前沿的军事基地，其运送规则如下：\n\n1. 小岛只能由特定的货物发源地发货，其中只有几个指定的小岛可以向军事基地发货。\n2. 小岛与小岛之间有 $e$ 条航道，每条航道上有一个权值 $v$ 代表这条道路开通的代价，而两个小岛之间开通货运的代价 $K$ 是两个小岛之间的最短路径长度。\n3. 每个小岛上同时最多不能超过 $w$ 个货物。\n4. 每个小岛一次性至多对外运输 $d$ 个货物，小岛对每个目的地至多送货一次。\n5. 有 $x$ 个特殊货物发源地（不包含在 $n$ 内）会运送 csh 和 zzy 两个人的一些私人的货物，这些货物会被任何一个小岛无条件接受和送出，即不受 3，4 法则的影响。\n6. 整条航路的开发费用为每对小岛开通费用 $K$ 中的最大值 $V$。\n\n请你寻找一个最小的 $V$ 使得所有货物都能按照要求运送到军事基地。", "inputFormat": "第一行 $n$，$m$，$x$，$e$，分别表示货物发源地数目，小岛中转站数目，特殊货物发源地数目和航道数目，货物发源地和特殊货物发源地依次标号为 $1$，$2$，$ \\dots $，$n+x$。\n\n第二行是 $n+x$ 个数 $a_i$，分别每个货物发源地待发送的货物数量。\n\n第三行是 $m$ 个数，分别表示小岛的限制存货量 $w$。\n\n第四行也是 $m$ 个数，分别表示小岛的限制出货量 $d$。\n\n接下来 $m$ 行，每行开头是一个数 $k$ ，表示有 $k$ 个货物发源地（包括特殊货物发源地）与小岛相连，然后是 $k$ 个数，分别表示货物发源地的编号，最后一个数表示小岛是否与军事基地相连，是则为$1$，否则为$0$。\n\n接下来 $e$ 行，每行是三个数 $u$，$v$，$p$ 表示小岛 $u$，$v$ 之间航道的权值为 $p$。", "outputFormat": "一个整数 $V$ ，表示使得所有货物都能按照要求运送到军事基地最小开通费用。", "hint": "对于 $100\\%$ 的数据， $n \\le 3 \\times 10^2$，$e \\le 10^3$。\n\n几个提示：[https://www.luogu.com.cn/discuss/47710](https://www.luogu.com.cn/discuss/47710)。", "locale": "zh-CN", "translations": {"en": {"title": "The War of csh and zzy", "background": "(The background is a bit long. You may read it through or skip it.)\n\nIn A.D. 2040, csh and zzy held a debate in the Frog Valley of the Ugly Country about the correctness of nonlinear partial differential equations, later known as the Fourth Crisis in Mathematics. Their nearly thousand-page, inhumanly academic papers left everyone else unable to understand what they were saying. Consequently, scientists of faction A led by csh and faction B led by zzy, after many fruitless confrontations, turned to armed revolution, triggering the global Third World War. The neutral country Jurun, not wishing to be dragged into the struggle, only wanted to finish its coffee. However, after repeatedly extending an olive branch in vain, the two leaders提出了一个要求: to resolve their logistics problem during the war. Of course, they solved this problem within $10^0$ s, but Jurun did not know what to do and could not submit a wrong answer, so they turned to you smart people for help.", "description": "There are $n$ cargo origins, each with some goods to be shipped. Ahead are $m$ transfer islands, and your goal is to deliver all goods to the front-line military base. The shipping rules are as follows:\n\n1. Each island can accept goods only from specific cargo origins, and only certain designated islands can ship to the military base.\n2. There are $e$ sea lanes between islands. Each sea lane has a weight $p$ representing the cost to open that lane. For any two islands, the cost $K$ to enable cargo shipping between them equals the length of the shortest path between them (sum of edge weights).\n3. At any time, the number of goods simultaneously stored on an island must not exceed its storage limit $w_i$.\n4. Each island can ship out at most $d_i$ goods in total, and to each destination it can deliver at most once.\n5. There are $x$ special cargo origins (not included in $n$) that carry some private goods of csh and zzy. These goods will be unconditionally accepted and forwarded by any island, i.e., they are not subject to rules 3 and 4.\n6. The development cost of the entire route equals $V$, the maximum $K$ among all pairs of islands for which shipping is enabled.\n\nFind the minimal $V$ such that all goods can be delivered to the military base in accordance with the above rules.", "inputFormat": "- The first line contains $n$, $m$, $x$, $e$, denoting the number of cargo origins, the number of transfer islands, the number of special cargo origins, and the number of sea lanes, respectively. The cargo origins and special cargo origins are indexed $1, 2, \\dots, n + x$ in order.\n- The second line contains $n + x$ integers $a_i$, the amount of goods pending shipment at each cargo origin.\n- The third line contains $m$ integers, the storage limits $w_i$ of the islands.\n- The fourth line contains $m$ integers, the outbound shipping limits $d_i$ of the islands.\n- The next $m$ lines describe the connections from origins to islands. Each line starts with an integer $k$, the number of cargo origins (including special ones) connected to this island, followed by $k$ integers listing the indices of those origins, and finally one integer indicating whether this island is connected to the military base (1 for yes, 0 for no).\n- The next $e$ lines each contain three integers $u$, $v$, $p$, indicating there is a sea lane between islands $u$ and $v$ with weight $p$.", "outputFormat": "Output a single integer $V$, the minimal development cost that allows all goods to be delivered to the military base while satisfying the rules.", "hint": "Constraints: For $100\\%$ of the testdata, $n \\le 3 \\times 10^2$, $e \\le 10^3$.\n\nSeveral tips: https://www.luogu.com.cn/discuss/47710.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "csh和zzy的战争", "background": "（背景~~有点~~长，你可以选择读完，也可以选择跳过。）\n\n公元 2040 年，csh 和 zzy 在丑国蛙谷展开了关于非线性配微分方程的正确性与否的相关辩论，史称第四次数学危机。两个人近千页的非人类学术性论文，使整个世界没有其他人听得懂他们在说什么，于是，以 csh 为首的 A 派科学家和以 zzy 为首的 B 派科学家展开了在多次对抗无果之后开始使用武装革命解决，进而引发了全球性的第三次世界大战。作为战争中立派的居润国不想卷入任何一方的斗争，只想喝完手中的咖啡，然而两方元首在多次对抛出橄榄枝无果之后，对居润国提出了一个要求：解决他们在战争中的运送物资问题，当然这个问题早就在 $10^0$ s 内被他们解决，但是居润国却不知道怎么办，而且也不能报上错误的答案，于是就求助了聪明的你们。", "description": "现在有 $n$ 个货物发源地，里面是一些待运送的货物。前方有 $m$ 个中转小岛，而你的目的是将所有货物运到战争前沿的军事基地，其运送规则如下：\n\n1. 小岛只能由特定的货物发源地发货，其中只有几个指定的小岛可以向军事基地发货。\n2. 小岛与小岛之间有 $e$ 条航道，每条航道上有一个权值 $v$ 代表这条道路开通的代价，而两个小岛之间开通货运的代价 $K$ 是两个小岛之间的最短路径长度。\n3. 每个小岛上同时最多不能超过 $w$ 个货物。\n4. 每个小岛一次性至多对外运输 $d$ 个货物，小岛对每个目的地至多送货一次。\n5. 有 $x$ 个特殊货物发源地（不包含在 $n$ 内）会运送 csh 和 zzy 两个人的一些私人的货物，这些货物会被任何一个小岛无条件接受和送出，即不受 3，4 法则的影响。\n6. 整条航路的开发费用为每对小岛开通费用 $K$ 中的最大值 $V$。\n\n请你寻找一个最小的 $V$ 使得所有货物都能按照要求运送到军事基地。", "inputFormat": "第一行 $n$，$m$，$x$，$e$，分别表示货物发源地数目，小岛中转站数目，特殊货物发源地数目和航道数目，货物发源地和特殊货物发源地依次标号为 $1$，$2$，$ \\dots $，$n+x$。\n\n第二行是 $n+x$ 个数 $a_i$，分别每个货物发源地待发送的货物数量。\n\n第三行是 $m$ 个数，分别表示小岛的限制存货量 $w$。\n\n第四行也是 $m$ 个数，分别表示小岛的限制出货量 $d$。\n\n接下来 $m$ 行，每行开头是一个数 $k$ ，表示有 $k$ 个货物发源地（包括特殊货物发源地）与小岛相连，然后是 $k$ 个数，分别表示货物发源地的编号，最后一个数表示小岛是否与军事基地相连，是则为$1$，否则为$0$。\n\n接下来 $e$ 行，每行是三个数 $u$，$v$，$p$ 表示小岛 $u$，$v$ 之间航道的权值为 $p$。", "outputFormat": "一个整数 $V$ ，表示使得所有货物都能按照要求运送到军事基地最小开通费用。", "hint": "对于 $100\\%$ 的数据， $n \\le 3 \\times 10^2$，$e \\le 10^3$。\n\n几个提示：[https://www.luogu.com.cn/discuss/47710](https://www.luogu.com.cn/discuss/47710)。", "locale": "zh-CN"}}}
{"pid": "P3653", "type": "P", "difficulty": 6, "samples": [["1 233", "-1"], ["99999999999899999 99999999999999999", "421"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化", "枚举", "素数判断,质数,筛法", "前缀和"], "title": "小清新数学题", "background": "**本题时限 3s**\n\n友情提示：https://www.luogu.com.cn/problem/P3601\n", "description": "题目还是简单一点好。\n\n\n我们定义莫比乌斯函数 $\\mu(x)$，如果 $x$ 的每个素因子只出现一次，有 $p$ 个素因子，那么 $\\mu(x)=(-1)^p$，否则 $\\mu(x)=0$。\n\n\n这题要求你求出 $\\sum_{i=l}^r \\mu(i)$。\n", "inputFormat": "一行两个整数 $l,r$。\n", "outputFormat": "一行一个整数表示答案。\n", "hint": "对于 $10\\%$ 的数据，$l,r \\leq 10^6$。\n\n对于 $30\\%$ 的数据，$l,r \\leq 10^{12}$。\n\n对于 $100\\%$ 的数据，$1 \\leq l \\leq r \\leq 10^{18}$，$r-l \\leq 10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "A Fresh Math Problem", "background": "Time limit: 3 s.\n\nFriendly reminder: https://www.luogu.com.cn/problem/P3601.", "description": "Let's keep the problem simple.\n\nWe define the Möbius function $\\mu(x)$. If each prime factor of $x$ appears only once and there are $p$ prime factors, then $\\mu(x)=(-1)^p$; otherwise, $\\mu(x)=0$.\n\nYou are asked to compute $\\sum_{i=l}^r \\mu(i)$.", "inputFormat": "One line contains two integers $l,r$.", "outputFormat": "One line contains one integer representing the answer.", "hint": "For $10\\%$ of the testdata, $l,r \\leq 10^6$.\n\nFor $30\\%$ of the testdata, $l,r \\leq 10^{12}$.\n\nFor $100\\%$ of the testdata, $1 \\leq l \\leq r \\leq 10^{18}$, $r-l \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小清新数学题", "background": "**本题时限 3s**\n\n友情提示：https://www.luogu.com.cn/problem/P3601\n", "description": "题目还是简单一点好。\n\n\n我们定义莫比乌斯函数 $\\mu(x)$，如果 $x$ 的每个素因子只出现一次，有 $p$ 个素因子，那么 $\\mu(x)=(-1)^p$，否则 $\\mu(x)=0$。\n\n\n这题要求你求出 $\\sum_{i=l}^r \\mu(i)$。\n", "inputFormat": "一行两个整数 $l,r$。\n", "outputFormat": "一行一个整数表示答案。\n", "hint": "对于 $10\\%$ 的数据，$l,r \\leq 10^6$。\n\n对于 $30\\%$ 的数据，$l,r \\leq 10^{12}$。\n\n对于 $100\\%$ 的数据，$1 \\leq l \\leq r \\leq 10^{18}$，$r-l \\leq 10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P3654", "type": "P", "difficulty": 2, "samples": [["5 5 2\n.###.\n##.#.\n..#..\n#..#.\n#.###\n", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "枚举", "洛谷月赛"], "title": "First Step (ファーストステップ)", "background": "> **知らないことばかりなにもかもが（どうしたらいいの？）**    \n**一切的一切 尽是充满了未知数（该如何是好）**   \n**それでも期待で足が軽いよ（ジャンプだ！）**     \n**但我仍因满怀期待而步伐轻盈（起跳吧！）**       \n**温度差なんていつか消しちゃえってね**     \n**冷若冰霜的态度 有朝一日将会消失得无影无踪**      \n**元気だよ元気をだしていくよ**     \n**拿出活力 打起精神向前迈进吧**     \n\n ![](https://cdn.luogu.com.cn/upload/pic/4471.png) \n\n我们 Aqours，要第一次举办演唱会啦！\n\n虽然学生会长看上去不怎么支持我们的样子，可是有了理事长的支持，我们还是被允许在校内的篮球场里歌唱！\n\n歌曲也好好地准备过了，名字叫“[最喜欢的话就没问题！ (ダイスキだったらダイジョウブ！)](https://zh.moegirl.org/%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E8%AF%9D%E5%B0%B1%E6%B2%A1%E9%97%AE%E9%A2%98)“，大家一定会喜欢的吧！\n\n演唱会一定会顺利进行的！\n\n希望不要发生**停电**什么的事故哦……！\n", "description": "可是……这个篮球场，好像很久没有使用过的样子啊……\n\n里面堆满了学校的各种杂物呢……\n\n我们 Aqours 的成员要怎么在里面列队站下呢？\n\n\n我们浦之星女子学院的篮球场是一个 $R$ 行 $C$ 列的矩阵，其中堆满了各种学校的杂物 (用 `#` 表示)，空地 (用 `.` 表示) 好像并不多的样子呢……\n\n我们 Aqours 现在已经一共有 $K$ 个队员了，要歌唱舞蹈起来的话，我们得排成一条 $1\\times K$ 的直线，一个接一个地站在篮球场的空地上呢 (横竖均可)。\n\n我们想知道一共有多少种可行的站位方式呢。\n\nAqours 的真正的粉丝的你，能帮我们算算吗？\n", "inputFormat": "第一行三个整数 $R, C, K$。\n\n接下来的 $R$ 行 $C$ 列，表示浦之星女子学院篮球场。\n", "outputFormat": "总共的站位方式数量。\n", "hint": "|  | $R$ | $C$ | $K$ | 备注 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n|$1\\sim2$|$\\leq 10$|$\\leq 10$|$\\leq \\min(R,C)$|无|\n|$3\\sim4$|$\\leq 100$|$\\leq 100$|$\\leq 1$|无|\n|$5\\sim6$|$\\leq 100$|$\\leq 100$|$\\leq \\min(R,C)$|没有障碍|\n|$7\\sim10$|$\\leq 100$|$\\leq 100$|$\\leq \\min(R,C)$|无|\n\n对于所有数据，$1 \\leq R,C \\leq 100$，$1 \\leq k \\leq \\min(R,C)$。\n\n#### 以下是彩蛋\n\n在 LoveLive!Sunshine!! 动画第一季第三集中，Aqours 队长高海千歌演唱“最喜欢的话就没问题！”到副歌前时，学校因为雷击停电。\n", "locale": "zh-CN", "translations": {"en": {"title": "First Step (ファーストステップ)", "background": "> Everything is full of things I don't know (what should I do?).  \nEverything is entirely full of unknowns (what should I do?).  \nEven so, my steps feel light with anticipation (jump!).  \nBut I still have light steps because I’m full of expectation (jump!).  \nSomeday we’ll make this gap in enthusiasm disappear.  \nThat cold attitude will one day disappear without a trace.  \nI’m fine—I’ll cheer up and keep going.  \nShow your energy, lift your spirits, and move forward.\n\n![](https://cdn.luogu.com.cn/upload/pic/4471.png)\n\nWe, Aqours, are going to hold our first concert!\n\nAlthough the student council president doesn’t seem very supportive, with the chairwoman’s backing, we’ve been allowed to sing on the school’s basketball court!\n\nThe song is ready, titled “[If you really love it, it will be all right! (ダイスキだったらダイジョウブ！)](https://zh.moegirl.org/%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E8%AF%9D%E5%B0%B1%E6%B2%A1%E9%97%AE%E9%A2%98)”, and I’m sure everyone will like it!\n\nThe concert will definitely go smoothly!\n\nI hope nothing like a power outage happens...!", "description": "However... this basketball court seems like it hasn’t been used for a long time.\n\nIt’s piled high with all kinds of school odds and ends.\n\nHow can the members of Aqours line up inside?\n\nOur basketball court at Uranohoshi Girls’ High School is an $R$-by-$C$ grid. It is filled with various school items (denoted by `#`), and it looks like there isn’t much open space (denoted by `.`).\n\nWe now have $K$ members in Aqours. To sing and dance, we need to form a straight line of size $1 \\times K$, standing one after another on empty cells in the court (either horizontally or vertically).\n\nWe want to know how many possible ways there are to stand.\n\nAs a true fan of Aqours, can you help us count?", "inputFormat": "The first line contains three integers $R$, $C$, and $K$.\n\nThe following $R$ lines each contain $C$ characters, representing the basketball court of Uranohoshi Girls’ High School.", "outputFormat": "Output the total number of possible placements.", "hint": "|  | $R$ | $C$ | $K$ | Notes |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1\\sim2$ | $\\leq 10$ | $\\leq 10$ | $\\leq \\min(R, C)$ | None |\n| $3\\sim4$ | $\\leq 100$ | $\\leq 100$ | $\\leq 1$ | None |\n| $5\\sim6$ | $\\leq 100$ | $\\leq 100$ | $\\leq \\min(R, C)$ | No obstacles |\n| $7\\sim10$ | $\\leq 100$ | $\\leq 100$ | $\\leq \\min(R, C)$ | None |\n\nFor all testdata, $1 \\leq R, C \\leq 100$, $1 \\leq K \\leq \\min(R, C)$.\n\nEaster egg: In episode 3 of LoveLive! Sunshine!! season 1, when Chika Takami, the leader of Aqours, sings “If you really love it, it will be all right!” up to just before the chorus, the school loses power due to a lightning strike.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "First Step (ファーストステップ)", "background": "> **知らないことばかりなにもかもが（どうしたらいいの？）**    \n**一切的一切 尽是充满了未知数（该如何是好）**   \n**それでも期待で足が軽いよ（ジャンプだ！）**     \n**但我仍因满怀期待而步伐轻盈（起跳吧！）**       \n**温度差なんていつか消しちゃえってね**     \n**冷若冰霜的态度 有朝一日将会消失得无影无踪**      \n**元気だよ元気をだしていくよ**     \n**拿出活力 打起精神向前迈进吧**     \n\n ![](https://cdn.luogu.com.cn/upload/pic/4471.png) \n\n我们 Aqours，要第一次举办演唱会啦！\n\n虽然学生会长看上去不怎么支持我们的样子，可是有了理事长的支持，我们还是被允许在校内的篮球场里歌唱！\n\n歌曲也好好地准备过了，名字叫“[最喜欢的话就没问题！ (ダイスキだったらダイジョウブ！)](https://zh.moegirl.org/%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E8%AF%9D%E5%B0%B1%E6%B2%A1%E9%97%AE%E9%A2%98)“，大家一定会喜欢的吧！\n\n演唱会一定会顺利进行的！\n\n希望不要发生**停电**什么的事故哦……！\n", "description": "可是……这个篮球场，好像很久没有使用过的样子啊……\n\n里面堆满了学校的各种杂物呢……\n\n我们 Aqours 的成员要怎么在里面列队站下呢？\n\n\n我们浦之星女子学院的篮球场是一个 $R$ 行 $C$ 列的矩阵，其中堆满了各种学校的杂物 (用 `#` 表示)，空地 (用 `.` 表示) 好像并不多的样子呢……\n\n我们 Aqours 现在已经一共有 $K$ 个队员了，要歌唱舞蹈起来的话，我们得排成一条 $1\\times K$ 的直线，一个接一个地站在篮球场的空地上呢 (横竖均可)。\n\n我们想知道一共有多少种可行的站位方式呢。\n\nAqours 的真正的粉丝的你，能帮我们算算吗？\n", "inputFormat": "第一行三个整数 $R, C, K$。\n\n接下来的 $R$ 行 $C$ 列，表示浦之星女子学院篮球场。\n", "outputFormat": "总共的站位方式数量。\n", "hint": "|  | $R$ | $C$ | $K$ | 备注 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n|$1\\sim2$|$\\leq 10$|$\\leq 10$|$\\leq \\min(R,C)$|无|\n|$3\\sim4$|$\\leq 100$|$\\leq 100$|$\\leq 1$|无|\n|$5\\sim6$|$\\leq 100$|$\\leq 100$|$\\leq \\min(R,C)$|没有障碍|\n|$7\\sim10$|$\\leq 100$|$\\leq 100$|$\\leq \\min(R,C)$|无|\n\n对于所有数据，$1 \\leq R,C \\leq 100$，$1 \\leq k \\leq \\min(R,C)$。\n\n#### 以下是彩蛋\n\n在 LoveLive!Sunshine!! 动画第一季第三集中，Aqours 队长高海千歌演唱“最喜欢的话就没问题！”到副歌前时，学校因为雷击停电。\n", "locale": "zh-CN"}}}
{"pid": "P3655", "type": "P", "difficulty": 3, "samples": [["4 3 2 3\n0\n5\n2\n4\n6\n1 2 1\n3 4 -3\n1 4 2\n", "-9\n-1\n-5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "差分", "洛谷月赛"], "title": "不成熟的梦想家 (未熟 DREAMER)", "background": "**どんな未来かは 誰もまだ知らない**\n\n**那是个任谁也不会知晓的未来**\n\n**でも楽しくなるはずだよ**\n\n**但应该会充满乐趣吧**\n\n**みんなとなら乗りこえられる**\n\n**只要大伙儿同在 就能跨越难关**\n\n**これからなんだねお互いがんばろうよ**\n\n**现在才正要开始 彼此互相加油吧**\n\n**どんな未来かは 誰もまだ知らない**\n\n**那是个任谁也不会知晓的未来**\n\n**でも楽しくしたホントに**\n\n**不过真心期望能够充满着乐趣**\n\n**みんなとなら無理したくなる**\n\n**只要大伙儿同在 就会想将顾虑抛诸脑后**\n\n**成長したいなまだまだ未熟DREAMER**\n\n**愿能有所成长 如今还只是尚未成熟的梦想家**\n\n ![](https://cdn.luogu.com.cn/upload/pic/4493.png) \n\nAqours的成员终于到齐了。\n\n\n今天，是我们全员在一起的第一场演唱会。\n\n\n大家都好好练习过了，相信一定会表现得很出色的。\n\n\n不过，每个人的唱功也要尽量地接近才可以呢，如果太突出或者太落后，也是会影响表现的样子。\n\n\n所以我们从隔壁的学园都市借来了一个发明，可以改变我们成员的唱功呢。\n", "description": "我们Aqours的成员共有N+1人，他们会列成一队。\n\n他们的唱功以A[0]到A[N]表示，A[i]$(0\\le i \\le N)$均给出。\n\n学园都市的机器可以改变队列中连续多个成员的唱功值，并将其加上一个数Z，当然当Z是负数的时候就变成减去了。\n\n我打算一共使用这个机器Q次，每次把第X到第Y号（$1\\le X,Y\\le10^6$）的成员都加上Z点唱功值。\n\n而我们队伍的魅力值B，是这么算的：\n\n一开始B=0，然后从第1号到第N号成员，\n\n- 当$A_{i-1}<A_i$：$B = B-S\\cdot|A_{i-1} - A_i|$\n- 当$A_{i-1}>A_i$：$B = B+T\\cdot|A_{i-1} - A_i|$\n其中S和T是LoveLive组委会给我们的常数。\n\n果然，我是バカチカ（笨蛋千歌）呢，所以作为领导我永远排在队伍的开头，唱功永远是0，机器也不会改到我头上呢。\n\n你能帮我们算算，我**每次**使用完这个机器之后，成员的魅力B是多少吗？\n", "inputFormat": "第一行4个整数，N，Q，S，T，各个变量在描述中已经解释\n\n接下来N+1行，每行一个数整数Ai，其中A0=0\n\n接下来Q行，每行3个整数，X，Y，Z各个变量在描述中已经解释\n", "outputFormat": "Q个整数，表示答案。\n", "hint": "30% 的数据 $N,Q\\le 2000$,\n\n另外20% 的数据 $S=T$\n\n100%的数据 $N,Q\\le 200000$；$1\\le S,T,A_i\\le10^6$；$|Z|\\le 10^6$\n请注意可能需要使用int64，cin/cout可能超时。\n\n样例解释：\n\n第一次变化后，\n\nA 0 6 3 4 6\n\nB -12 -3 -5 -9\n\n\n#### 以下是彩蛋\n\n没有。\n\n哪来的那么多彩蛋？\n", "locale": "zh-CN", "translations": {"en": {"title": "Immature Dreamer (Mijuku DREAMER)", "background": "What kind of future it is, nobody knows yet.\n\nBut it should be fun.\n\nIf we’re all together, we can overcome anything.\n\nIt’s just the beginning—let’s encourage each other.\n\nWhat kind of future it is, nobody knows yet.\n\nBut I really hope it will be full of fun.\n\nIf we’re all together, we’ll even want to push our limits.\n\nI want to grow—I’m still just an immature DREAMER.\n\n![](https://cdn.luogu.com.cn/upload/pic/4493.png)\n\nThe members of Aqours have finally gathered.\n\nToday is our very first concert with everyone together.\n\nEveryone has practiced well; I’m sure we’ll perform great.\n\nHowever, everyone’s singing skills should be as close as possible. If someone is too outstanding or too far behind, it will affect the performance.\n\nSo we borrowed an invention from the neighboring Academy City that can change our members’ singing skills.", "description": "There are $N+1$ members in Aqours, lined up in a row.\n\nTheir singing skills are denoted by $A[0]$ to $A[N]$, and all $A[i]$ for $0 \\le i \\le N$ are given.\n\nThe machine from Academy City can change the singing skills of a consecutive segment in the line by adding a number $Z$ to each of them. Of course, if $Z$ is negative, it means subtracting.\n\nI plan to use this machine $Q$ times. Each time, I add $Z$ to the singing skills of all members from index $X$ to index $Y$ (with $1 \\le X, Y \\le 10^6$).\n\nOur team’s charm value $B$ is computed as follows:\n\nInitially, $B = 0$. Then, for members from index $1$ to $N$:\n\n- If $A_{i-1} < A_i$: $B = B - S \\cdot |A_{i-1} - A_i|$.\n- If $A_{i-1} > A_i$: $B = B + T \\cdot |A_{i-1} - A_i|$.\n\nHere $S$ and $T$ are constants given by the Love Live committee.\n\nAs the leader, I (Chika) am always at the front of the line, with singing skill always $0$. The machine will never modify me. Thus $A_0 = 0$ at all times.\n\nCan you help us compute the charm value $B$ after each use of the machine?", "inputFormat": "- The first line contains four integers $N$, $Q$, $S$, $T$ (as described above).\n- The next $N+1$ lines each contain one integer $A_i$, with $A_0 = 0$.\n- The next $Q$ lines each contain three integers $X$, $Y$, $Z$ (as described above).", "outputFormat": "Output $Q$ integers, one per line, where the $i$-th line is the value of $B$ after the $i$-th operation.", "hint": "- For 30% of the testdata, $N, Q \\le 2000$.\n- Additionally, for another 20% of the testdata, $S = T$.\n- For 100% of the testdata, $N, Q \\le 200000$; $1 \\le S, T, A_i \\le 10^6$; $|Z| \\le 10^6$.\n- Note that a 64-bit integer may be required, and using std::cin/std::cout may time out.\n\nExplanation of the sample:\n\nAfter the first change,\n\nA: 0 6 3 4 6\n\nB: -12 -3 -5 -9\n\nEaster egg:\n\nNone.\n\nWhy would there be so many easter eggs?\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "不成熟的梦想家 (未熟 DREAMER)", "background": "**どんな未来かは 誰もまだ知らない**\n\n**那是个任谁也不会知晓的未来**\n\n**でも楽しくなるはずだよ**\n\n**但应该会充满乐趣吧**\n\n**みんなとなら乗りこえられる**\n\n**只要大伙儿同在 就能跨越难关**\n\n**これからなんだねお互いがんばろうよ**\n\n**现在才正要开始 彼此互相加油吧**\n\n**どんな未来かは 誰もまだ知らない**\n\n**那是个任谁也不会知晓的未来**\n\n**でも楽しくしたホントに**\n\n**不过真心期望能够充满着乐趣**\n\n**みんなとなら無理したくなる**\n\n**只要大伙儿同在 就会想将顾虑抛诸脑后**\n\n**成長したいなまだまだ未熟DREAMER**\n\n**愿能有所成长 如今还只是尚未成熟的梦想家**\n\n ![](https://cdn.luogu.com.cn/upload/pic/4493.png) \n\nAqours的成员终于到齐了。\n\n\n今天，是我们全员在一起的第一场演唱会。\n\n\n大家都好好练习过了，相信一定会表现得很出色的。\n\n\n不过，每个人的唱功也要尽量地接近才可以呢，如果太突出或者太落后，也是会影响表现的样子。\n\n\n所以我们从隔壁的学园都市借来了一个发明，可以改变我们成员的唱功呢。\n", "description": "我们Aqours的成员共有N+1人，他们会列成一队。\n\n他们的唱功以A[0]到A[N]表示，A[i]$(0\\le i \\le N)$均给出。\n\n学园都市的机器可以改变队列中连续多个成员的唱功值，并将其加上一个数Z，当然当Z是负数的时候就变成减去了。\n\n我打算一共使用这个机器Q次，每次把第X到第Y号（$1\\le X,Y\\le10^6$）的成员都加上Z点唱功值。\n\n而我们队伍的魅力值B，是这么算的：\n\n一开始B=0，然后从第1号到第N号成员，\n\n- 当$A_{i-1}<A_i$：$B = B-S\\cdot|A_{i-1} - A_i|$\n- 当$A_{i-1}>A_i$：$B = B+T\\cdot|A_{i-1} - A_i|$\n其中S和T是LoveLive组委会给我们的常数。\n\n果然，我是バカチカ（笨蛋千歌）呢，所以作为领导我永远排在队伍的开头，唱功永远是0，机器也不会改到我头上呢。\n\n你能帮我们算算，我**每次**使用完这个机器之后，成员的魅力B是多少吗？\n", "inputFormat": "第一行4个整数，N，Q，S，T，各个变量在描述中已经解释\n\n接下来N+1行，每行一个数整数Ai，其中A0=0\n\n接下来Q行，每行3个整数，X，Y，Z各个变量在描述中已经解释\n", "outputFormat": "Q个整数，表示答案。\n", "hint": "30% 的数据 $N,Q\\le 2000$,\n\n另外20% 的数据 $S=T$\n\n100%的数据 $N,Q\\le 200000$；$1\\le S,T,A_i\\le10^6$；$|Z|\\le 10^6$\n请注意可能需要使用int64，cin/cout可能超时。\n\n样例解释：\n\n第一次变化后，\n\nA 0 6 3 4 6\n\nB -12 -3 -5 -9\n\n\n#### 以下是彩蛋\n\n没有。\n\n哪来的那么多彩蛋？\n", "locale": "zh-CN"}}}
{"pid": "P3656", "type": "P", "difficulty": 5, "samples": [["5\n5\n4\n1\n3\n2\n1\n3\n2\n5\n4", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2017", "USACO", "树状数组"], "title": "[USACO17FEB] Why Did the Cow Cross the Road I P", "background": "", "description": "Why did the cow cross the road? We may never know the full reason, but it is certain that Farmer John's cows do end up crossing the road quite frequently. In fact, they end up crossing the road so often that they often bump into each-other when their paths cross, a situation Farmer John would like to remedy.\n\nFarmer John raises $N$ breeds of cows ($1 \\leq N \\leq 100,000$), and each of his fields is dedicated to grazing for one specific breed; for example, a field dedicated to breed 12 can only be used for cows of breed 12 and not of any other breed. A long road runs through his farm. There is a sequence of $N$ fields on one side of the road (one for each breed), and a sequence of $N$ fields on the other side of the road (also one for each breed). When a cow crosses the road, she therefore crosses between the two fields designated for her specific breed.\n\n\nHad Farmer John planned more carefully, he would have ordered the fields by breed the same way on both sides of the road, so the two fields for each breed would be directly across the road from each-other. This would have allowed cows to cross the road without any cows from different breeds bumping into one-another. Alas, the orderings on both sides of the road might be different, so Farmer John observes that there might be pairs of breeds that cross. A pair of different breeds $(a,b)$ is \"crossing\" if any path across the road for breed $a$ must intersect any path across the road for breed $b$.\n\n\nFarmer John would like to minimize the number of crossing pairs of breeds. For logistical reasons, he figures he can move cows around on one side of the road so the fields on that side undergo a \"cyclic shift\". That is, for some $0 \\leq k < N$, every cow re-locates to the field $k$ fields ahead of it, with the cows in the last $k$ fields moving so they now populate the first $k$ fields. For example, if the fields on one side of the road start out ordered by breed as 3, 7, 1, 2, 5, 4, 6 and undergo a cyclic shift by $k=2$, the new order will be 4, 6, 3, 7, 1, 2, 5. Please determine the minimum possible number of crossing pairs of breeds that can exist after an appropriate cyclic shift of the fields on one side of the road.\n", "inputFormat": "The first line of input contains $N$. The next $N$ lines describe the order, by breed ID, of fields on one side of the road; each breed ID is an integer in the range $1 \\ldots N$. The last $N$ lines describe the order, by breed ID, of the fields on the other side of the road.\n", "outputFormat": "Please output the minimum number of crossing pairs of breeds after a cyclic shift of the fields on one side of the road (either side can be shifted).\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17FEB] Why Did the Cow Cross the Road I P", "background": "", "description": "Why did the cow cross the road? We may never know the full reason, but it is certain that Farmer John's cows do end up crossing the road quite frequently. In fact, they end up crossing the road so often that they often bump into each-other when their paths cross, a situation Farmer John would like to remedy.\n\nFarmer John raises $N$ breeds of cows ($1 \\leq N \\leq 100,000$), and each of his fields is dedicated to grazing for one specific breed; for example, a field dedicated to breed 12 can only be used for cows of breed 12 and not of any other breed. A long road runs through his farm. There is a sequence of $N$ fields on one side of the road (one for each breed), and a sequence of $N$ fields on the other side of the road (also one for each breed). When a cow crosses the road, she therefore crosses between the two fields designated for her specific breed.\n\n\nHad Farmer John planned more carefully, he would have ordered the fields by breed the same way on both sides of the road, so the two fields for each breed would be directly across the road from each-other. This would have allowed cows to cross the road without any cows from different breeds bumping into one-another. Alas, the orderings on both sides of the road might be different, so Farmer John observes that there might be pairs of breeds that cross. A pair of different breeds $(a,b)$ is \"crossing\" if any path across the road for breed $a$ must intersect any path across the road for breed $b$.\n\n\nFarmer John would like to minimize the number of crossing pairs of breeds. For logistical reasons, he figures he can move cows around on one side of the road so the fields on that side undergo a \"cyclic shift\". That is, for some $0 \\leq k < N$, every cow re-locates to the field $k$ fields ahead of it, with the cows in the last $k$ fields moving so they now populate the first $k$ fields. For example, if the fields on one side of the road start out ordered by breed as 3, 7, 1, 2, 5, 4, 6 and undergo a cyclic shift by $k=2$, the new order will be 4, 6, 3, 7, 1, 2, 5. Please determine the minimum possible number of crossing pairs of breeds that can exist after an appropriate cyclic shift of the fields on one side of the road.\n", "inputFormat": "The first line of input contains $N$. The next $N$ lines describe the order, by breed ID, of fields on one side of the road; each breed ID is an integer in the range $1 \\ldots N$. The last $N$ lines describe the order, by breed ID, of the fields on the other side of the road.\n", "outputFormat": "Please output the minimum number of crossing pairs of breeds after a cyclic shift of the fields on one side of the road (either side can be shifted).\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17FEB] Why Did the Cow Cross the Road I P", "background": "", "description": "为什么奶牛要过马路？我们可能永远无法知道完整的原因，但可以肯定的是，Farmer John 的奶牛确实经常过马路。事实上，它们过马路的频率如此之高，以至于它们的路径交叉时经常会撞到彼此，这种情况 Farmer John 希望能够改善。\n\nFarmer John 饲养了 $N$ 种奶牛（$1 \\leq N \\leq 100,000$），他的每一块田地都专门用于放牧某一种特定的奶牛品种；例如，专门用于品种 12 的田地只能用于品种 12 的奶牛，而不能用于其他品种。一条长长的马路贯穿他的农场。马路的一侧有一系列 $N$ 块田地（每块田地对应一种品种），马路的另一侧也有一系列 $N$ 块田地（同样每块田地对应一种品种）。当一头奶牛过马路时，它会在为其特定品种指定的两块田地之间穿行。\n\n如果 Farmer John 当初计划得更仔细，他可能会在马路两侧按相同的品种顺序排列田地，这样每块品种的田地就会直接相对。这将使奶牛过马路时，不同品种的奶牛不会撞到彼此。然而，马路两侧的田地顺序可能不同，因此 Farmer John 观察到可能存在一些品种对会交叉。一对不同的品种 $(a,b)$ 是“交叉的”，如果品种 $a$ 的任何过马路路径都必须与品种 $b$ 的任何过马路路径相交。\n\nFarmer John 希望最小化交叉品种对的数量。出于物流原因，他决定可以通过对马路一侧的田地进行“循环移位”来重新安排奶牛的位置。也就是说，对于某个 $0 \\leq k < N$，每头奶牛都会移动到其前方 $k$ 块田地，最后 $k$ 块田地的奶牛会移动到前 $k$ 块田地。例如，如果马路一侧的田地最初按品种顺序为 3, 7, 1, 2, 5, 4, 6，并进行 $k=2$ 的循环移位，新的顺序将为 4, 6, 3, 7, 1, 2, 5。请确定在对马路一侧的田地进行适当的循环移位后，可能存在的交叉品种对的最小数量。", "inputFormat": "输入的第一行包含 $N$。接下来的 $N$ 行描述了马路一侧田地的品种 ID 顺序；每个品种 ID 是 $1$ 到 $N$ 之间的整数。最后的 $N$ 行描述了马路另一侧田地的品种 ID 顺序。", "outputFormat": "请输出在对马路一侧的田地进行循环移位后（可以移位任意一侧），交叉品种对的最小数量。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3657", "type": "P", "difficulty": 4, "samples": [["6\n1\n2\n3\n4\n5\n6\n6\n5\n4\n3\n2\n1", "5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "USACO", "树状数组", "离散化", "枚举"], "title": "[USACO17FEB] Why Did the Cow Cross the Road II P", "background": "*本题与 [金组同名题目](/problem/P6119) 在题意上一致，唯一的差别是数据范围。*", "description": "Farmer John 饲养了 $N$ 种奶牛，编号从 $1$ 到 $N$。一些品种的奶牛和其他奶牛间相处良好，事实证明，如果两个品种的奶牛编号分别为 $a,b$，当 $|a-b| \\leq 4$ 时，这两个品种的奶牛能友好相处，否则不能友好相处。\n\n一条长长的道路贯穿整个农场，道路的左侧有 $N$ 个牧场（每个品种的奶牛恰好占据一个牧场），道路的右侧也有 $N$ 个牧场（每个品种的奶牛恰好占据一个牧场）。为了让奶牛们安全穿过马路，Farmer John 希望能在马路上画出一些人行道（牛行道？），要求这些人行道满足如下条件：\n\n1. 人行道从左侧的某个牧场出发，连接到右侧的某个牧场；\n2. 人行道连接的两个牧场的奶牛要能友好相处；\n3. 人行道不能在道路中间相交；\n4. 每个牧场只能与一条人行道相连。\n\n你需要帮 FJ 求出最多能有多少条人行道。", "inputFormat": "输入第一行一个整数 $N$（$1 \\leq N \\leq 10^5$）。\n\n接下来 $N$ 行，每行一个整数 $a_i$，代表道路左侧第 $i$ 个牧场的奶牛品种编号。\n\n接下来 $N$ 行，每行一个整数 $b_i$，代表道路右侧第 $i$ 个牧场的奶牛品种编号。", "outputFormat": "输出最多能画多少条人行道。", "hint": "保证 $a_i,b_i$ 均为从 $1$ 到 $N$ 的排列。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO17FEB] Why Did the Cow Cross the Road II P", "background": "This problem shares the same statement as the problem with the same name in the Gold division ([金组同名题目](/problem/P6119)); the only difference lies in the constraints.", "description": "Farmer John raises $N$ breeds of cows, numbered from $1$ to $N$. Some breeds get along well with others; it turns out that if two breeds are numbered $a, b$, then when $|a - b| \\leq 4$, these two breeds can get along, otherwise they cannot.\n\nA long road runs through the farm. There are $N$ pastures on the left side of the road (each occupied by exactly one breed), and $N$ pastures on the right side of the road (each occupied by exactly one breed). To help the cows safely cross the road, Farmer John wants to paint some crosswalks (cow-walks?) on the road, subject to the following conditions:\n\n1. Each crosswalk connects a pasture on the left to a pasture on the right.\n2. The breeds of the two connected pastures must get along.\n3. No two crosswalks may intersect in the middle of the road.\n4. Each pasture can be connected to at most one crosswalk.\n\nYou need to help FJ determine the maximum possible number of crosswalks.", "inputFormat": "The first line contains an integer $N$ ($1 \\leq N \\leq 10^5$).\n\nThe next $N$ lines each contain an integer $a_i$, representing the breed in the $i$-th pasture on the left side of the road.\n\nThe next $N$ lines each contain an integer $b_i$, representing the breed in the $i$-th pasture on the right side of the road.", "outputFormat": "Output the maximum number of crosswalks.", "hint": "It is guaranteed that both $a_i$ and $b_i$ are permutations of $1$ to $N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO17FEB] Why Did the Cow Cross the Road II P", "background": "*本题与 [金组同名题目](/problem/P6119) 在题意上一致，唯一的差别是数据范围。*", "description": "Farmer John 饲养了 $N$ 种奶牛，编号从 $1$ 到 $N$。一些品种的奶牛和其他奶牛间相处良好，事实证明，如果两个品种的奶牛编号分别为 $a,b$，当 $|a-b| \\leq 4$ 时，这两个品种的奶牛能友好相处，否则不能友好相处。\n\n一条长长的道路贯穿整个农场，道路的左侧有 $N$ 个牧场（每个品种的奶牛恰好占据一个牧场），道路的右侧也有 $N$ 个牧场（每个品种的奶牛恰好占据一个牧场）。为了让奶牛们安全穿过马路，Farmer John 希望能在马路上画出一些人行道（牛行道？），要求这些人行道满足如下条件：\n\n1. 人行道从左侧的某个牧场出发，连接到右侧的某个牧场；\n2. 人行道连接的两个牧场的奶牛要能友好相处；\n3. 人行道不能在道路中间相交；\n4. 每个牧场只能与一条人行道相连。\n\n你需要帮 FJ 求出最多能有多少条人行道。", "inputFormat": "输入第一行一个整数 $N$（$1 \\leq N \\leq 10^5$）。\n\n接下来 $N$ 行，每行一个整数 $a_i$，代表道路左侧第 $i$ 个牧场的奶牛品种编号。\n\n接下来 $N$ 行，每行一个整数 $b_i$，代表道路右侧第 $i$ 个牧场的奶牛品种编号。", "outputFormat": "输出最多能画多少条人行道。", "hint": "保证 $a_i,b_i$ 均为从 $1$ 到 $N$ 的排列。", "locale": "zh-CN"}}}
{"pid": "P3658", "type": "P", "difficulty": 6, "samples": [["4 1\n4\n3\n2\n1\n1\n4\n2\n3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "USACO", "树状数组", "cdq 分治"], "title": "[USACO17FEB] Why Did the Cow Cross the Road III P", "background": "", "description": "Farmer John is continuing to ponder the issue of cows crossing the road through his farm, introduced in the preceding two problems. He realizes now that the threshold for friendliness is a bit more subtle than he previously considered -- breeds $a$ and $b$ are now friendly if $|a - b| \\leq K$, and unfriendly otherwise.\nGiven the orderings of fields on either side of the road through FJ's farm, please count the number of unfriendly crossing pairs of breeds, where a crossing pair of breeds is defined as in the preceding problems.\n\n", "inputFormat": "The first line of input contains $N$ ($1 \\leq N \\leq 100,000$) and $K$ ($0 \\leq K < N$). The next $N$ lines describe the order, by breed ID, of fields on one side of the road; each breed ID is an integer in the range $1 \\ldots N$. The last $N$ lines describe the order, by breed ID, of the fields on the other side of the road. Each breed ID appears exactly once in each ordering.\n", "outputFormat": "Please output the number of unfriendly crossing pairs of breeds.\n\n", "hint": "In this example, breeds 1 and 4 are unfriendly and crossing, as are breeds 1 and 3.\n\n", "locale": "en", "translations": {"en": {"title": "[USACO17FEB] Why Did the Cow Cross the Road III P", "background": "", "description": "Farmer John is continuing to ponder the issue of cows crossing the road through his farm, introduced in the preceding two problems. He realizes now that the threshold for friendliness is a bit more subtle than he previously considered -- breeds $a$ and $b$ are now friendly if $|a - b| \\leq K$, and unfriendly otherwise.\nGiven the orderings of fields on either side of the road through FJ's farm, please count the number of unfriendly crossing pairs of breeds, where a crossing pair of breeds is defined as in the preceding problems.\n\n", "inputFormat": "The first line of input contains $N$ ($1 \\leq N \\leq 100,000$) and $K$ ($0 \\leq K < N$). The next $N$ lines describe the order, by breed ID, of fields on one side of the road; each breed ID is an integer in the range $1 \\ldots N$. The last $N$ lines describe the order, by breed ID, of the fields on the other side of the road. Each breed ID appears exactly once in each ordering.\n", "outputFormat": "Please output the number of unfriendly crossing pairs of breeds.\n\n", "hint": "In this example, breeds 1 and 4 are unfriendly and crossing, as are breeds 1 and 3.\n\n", "locale": "en"}, "zh-CN": {"title": "[USACO17FEB] Why Did the Cow Cross the Road III P", "background": null, "description": "Farmer John 继续思考奶牛穿过他农场道路的问题，这个问题在前两个问题中已经介绍过。他现在意识到，友好度的阈值比他之前考虑的要微妙一些——现在，品种 $a$ 和 $b$ 是友好的当且仅当 $|a - b| \\leq K$，否则就是不友好的。给定 FJ 农场道路两侧田地的品种顺序，请计算不友好的交叉品种对的数量，其中交叉品种对的定义与 [前两个问题](https://www.luogu.com.cn/problem/P3657) 相同。\n\n形式化题面：给出两个排列 $A,B$ ，相等的数之间连线，求数对 $(i,j)$ 的个数。其中 $(i,j)$ 满足：它们所在两个排列间对应的线交叉且 $|i-j| > k$ 。", "inputFormat": "输入的第一行包含 $N$ ($1 \\leq N \\leq 100,000$) 和 $K$ ($0 \\leq K < N$)。接下来的 $N$ 行描述了道路一侧的每块田地里牛的品种ID；每个品种 ID 是一个在 $1 \\ldots N$ 范围内的整数。最后的 $N$ 行描述了道路另一侧的每块田地里牛的品种ID。每个品种 ID 在每个顺序中恰好出现一次。", "outputFormat": "请输出不友好的交叉品种对的数量。", "hint": "在这个例子中，品种 1 和 4 是不友好的且交叉的，品种 1 和 3 也是不友好的且交叉的。", "locale": "zh-CN"}}}
{"pid": "P3659", "type": "P", "difficulty": 5, "samples": [["4 2\n30 92 36 10\n38 85 60 16\n41 13 5 68\n20 97 13 80", "31"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "USACO", "广度优先搜索 BFS", "深度优先搜索 DFS", "最短路"], "title": "[USACO17FEB] Why Did the Cow Cross the Road I G", "background": "", "description": "Why did the cow cross the road? Well, one reason is that Farmer John's farm simply has a lot of roads, making it impossible for his cows to travel around without crossing many of them.\n\nFJ's farm is arranged as an $N \\times N$ square grid of fields ($3 \\leq N \\leq 100$), with a set of $N-1$ north-south roads and $N-1$ east-west roads running through the interior of the farm serving as dividers between the fields. A tall fence runs around the external perimeter, preventing cows from leaving the farm. Bessie the cow can move freely from any field to any other adjacent field (north, east, south, or west), as long as she carefully looks both ways before crossing the road separating the two fields. It takes her $T$ units of time to cross a road ($0 \\leq T \\leq 1,000,000$).\n\nOne day, FJ invites Bessie to visit his house for a friendly game of chess. Bessie starts out in the north-west corner field and FJ's house is in the south-east corner field, so Bessie has quite a walk ahead of her. Since she gets hungry along the way, she stops at every third field she visits to eat grass (not including her starting field, but including possibly the final field in which FJ's house resides). Some fields are grassier than others, so the amount of time required for stopping to eat depends on the field in which she stops.\n\nPlease help Bessie determine the minimum amount of time it will take to reach FJ's house.", "inputFormat": "The first line of input contains $N$ and $T$. The next $N$ lines each contain $N$ positive integers (each at most 100,000) describing the amount of time required to eat grass in each field. The first number of the first line is the north-west corner.\n", "outputFormat": "Print the minimum amount of time required for Bessie to travel to FJ's house.", "hint": "The optimal solution for this example involves moving east 3 squares (eating the \"10\"), then moving south twice and west once (eating the \"5\"), and finally moving south and east to the goal.", "locale": "en", "translations": {"en": {"title": "[USACO17FEB] Why Did the Cow Cross the Road I G", "background": "", "description": "Why did the cow cross the road? Well, one reason is that Farmer John's farm simply has a lot of roads, making it impossible for his cows to travel around without crossing many of them.\n\nFJ's farm is arranged as an $N \\times N$ square grid of fields ($3 \\leq N \\leq 100$), with a set of $N-1$ north-south roads and $N-1$ east-west roads running through the interior of the farm serving as dividers between the fields. A tall fence runs around the external perimeter, preventing cows from leaving the farm. Bessie the cow can move freely from any field to any other adjacent field (north, east, south, or west), as long as she carefully looks both ways before crossing the road separating the two fields. It takes her $T$ units of time to cross a road ($0 \\leq T \\leq 1,000,000$).\n\nOne day, FJ invites Bessie to visit his house for a friendly game of chess. Bessie starts out in the north-west corner field and FJ's house is in the south-east corner field, so Bessie has quite a walk ahead of her. Since she gets hungry along the way, she stops at every third field she visits to eat grass (not including her starting field, but including possibly the final field in which FJ's house resides). Some fields are grassier than others, so the amount of time required for stopping to eat depends on the field in which she stops.\n\nPlease help Bessie determine the minimum amount of time it will take to reach FJ's house.", "inputFormat": "The first line of input contains $N$ and $T$. The next $N$ lines each contain $N$ positive integers (each at most 100,000) describing the amount of time required to eat grass in each field. The first number of the first line is the north-west corner.\n", "outputFormat": "Print the minimum amount of time required for Bessie to travel to FJ's house.", "hint": "The optimal solution for this example involves moving east 3 squares (eating the \"10\"), then moving south twice and west once (eating the \"5\"), and finally moving south and east to the goal.", "locale": "en"}, "zh-CN": {"title": "[USACO17FEB] Why Did the Cow Cross the Road I G", "background": "", "description": "奶牛为什么要过马路？其中一个原因是 Farmer John 的农场有很多道路，使得他的奶牛在四处走动时不可避免地要穿过许多道路。\n\nFJ 的农场被安排成一个 $N \\times N$ 的方形网格田地（$3 \\leq N \\leq 100$），其中有 $N-1$ 条南北向的道路和 $N-1$ 条东西向的道路穿过农场内部，作为田地之间的分隔。农场外部有一圈高高的围栏，防止奶牛离开农场。奶牛 Bessie 可以自由地从任何田地移动到相邻的田地（北、东、南或西），只要她在穿过分隔两块田地的道路时小心地左右看看。她穿过一条道路需要花费 $T$ 单位时间（$0 \\leq T \\leq 1,000,000$）。\n\n有一天，FJ 邀请 Bessie 去他家进行一场友好的国际象棋比赛。Bessie 从西北角的田地出发，而 FJ 的家在东南角的田地，因此 Bessie 需要走很长一段路。由于她在路上会感到饥饿，她会在每经过第三个田地时停下来吃草（不包括她的起始田地，但可能包括最终到达的 FJ 家的田地）。有些田地的草比其他田地更茂盛，因此停下来吃草所需的时间取决于她停下的田地。\n\n请帮助 Bessie 确定她到达 FJ 家所需的最少时间。", "inputFormat": "输入的第一行包含 $N$ 和 $T$。接下来的 $N$ 行每行包含 $N$ 个正整数（每个数不超过 100,000），描述了每个田地中吃草所需的时间。第一行的第一个数是西北角的田地。", "outputFormat": "输出 Bessie 到达 FJ 家所需的最少时间。", "hint": "这个例子的最优解是向东移动 3 个方格（吃“10”），然后向南移动两次，向西移动一次（吃“5”），最后向南和向东移动到目的地。", "locale": "zh-CN"}}}
{"pid": "P3660", "type": "P", "difficulty": 5, "samples": [["4\n3\n2\n4\n4\n1\n3\n2\n1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "USACO", "树状数组", "枚举", "排序", "前缀和"], "title": "[USACO17FEB] Why Did the Cow Cross the Road III G", "background": "", "description": "The layout of Farmer John's farm is quite peculiar, with a large circular road running around the perimeter of the main field on which his cows graze during the day. Every morning, the cows cross this road on their way towards the field, and every evening they all cross again as they leave the field and return to the barn.\n\nAs we know, cows are creatures of habit, and they each cross the road the same way every day. Each cow crosses into the field at a different point from where she crosses out of the field, and all of these crossing points are distinct from each-other. Farmer John owns $N$ cows, conveniently identified with the integer IDs $1 \\ldots N$, so there are precisely $2N$ crossing points around the road. Farmer John records these crossing points concisely by scanning around the circle clockwise, writing down the ID of the cow for each crossing point, ultimately forming a sequence with $2N$ numbers in which each number appears exactly twice. He does not record which crossing points are entry points and which are exit points.\n\nLooking at his map of crossing points, Farmer John is curious how many times various pairs of cows might cross paths during the day. He calls a pair of cows $(a,b)$ a \"crossing\" pair if cow $a$'s path from entry to exit must cross cow $b$'s path from entry to exit. Please help Farmer John count the total number of crossing pairs.", "inputFormat": "The first line of input contains $N$ ($1 \\leq N \\leq 50,000$), and the next $2N$ lines describe the cow IDs for the sequence of entry and exit points around the field.\n", "outputFormat": "Please print the total number of crossing pairs.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17FEB] Why Did the Cow Cross the Road III G", "background": "", "description": "The layout of Farmer John's farm is quite peculiar, with a large circular road running around the perimeter of the main field on which his cows graze during the day. Every morning, the cows cross this road on their way towards the field, and every evening they all cross again as they leave the field and return to the barn.\n\nAs we know, cows are creatures of habit, and they each cross the road the same way every day. Each cow crosses into the field at a different point from where she crosses out of the field, and all of these crossing points are distinct from each-other. Farmer John owns $N$ cows, conveniently identified with the integer IDs $1 \\ldots N$, so there are precisely $2N$ crossing points around the road. Farmer John records these crossing points concisely by scanning around the circle clockwise, writing down the ID of the cow for each crossing point, ultimately forming a sequence with $2N$ numbers in which each number appears exactly twice. He does not record which crossing points are entry points and which are exit points.\n\nLooking at his map of crossing points, Farmer John is curious how many times various pairs of cows might cross paths during the day. He calls a pair of cows $(a,b)$ a \"crossing\" pair if cow $a$'s path from entry to exit must cross cow $b$'s path from entry to exit. Please help Farmer John count the total number of crossing pairs.", "inputFormat": "The first line of input contains $N$ ($1 \\leq N \\leq 50,000$), and the next $2N$ lines describe the cow IDs for the sequence of entry and exit points around the field.\n", "outputFormat": "Please print the total number of crossing pairs.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17FEB] Why Did the Cow Cross the Road III G", "background": "", "description": "Farmer John 的农场布局非常独特，主田地的外围有一条环形道路，他的奶牛白天在这里吃草。每天早上，奶牛们都会穿过这条道路进入田地，每天晚上它们又会再次穿过这条道路离开田地返回牛棚。\n\n众所周知，奶牛是习惯性动物，它们每天都会以相同的方式穿过道路。每头奶牛进入田地的点和离开田地的点不同，并且所有这些穿过点都彼此不同。Farmer John 拥有 $N$ 头奶牛，方便地用整数 ID $1 \\ldots N$ 标识，因此道路周围恰好有 $2N$ 个穿过点。Farmer John 通过顺时针扫描环形道路，记录每个穿过点的奶牛 ID，最终形成一个包含 $2N$ 个数字的序列，其中每个数字恰好出现两次。他并未记录哪些穿过点是进入点，哪些是离开点。\n\n看着他的穿过点地图，Farmer John 好奇一天中不同奶牛对之间可能会交叉多少次。如果奶牛 $a$ 从进入点到离开点的路径必须与奶牛 $b$ 从进入点到离开点的路径交叉，那么他称奶牛对 $(a,b)$ 为“交叉”对。请帮助 Farmer John 计算交叉对的总数。", "inputFormat": "输入的第一行包含 $N$ ($1 \\leq N \\leq 50,000$)，接下来的 $2N$ 行描述了田地周围进入和离开点的奶牛 ID 序列。", "outputFormat": "请输出交叉对的总数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3661", "type": "P", "difficulty": 3, "samples": [["5 4\n7\n8\n6\n2\n9\n2 5\n4 9\n0 3\n8 13", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2017", "USACO", "排序", "优先队列"], "title": "[USACO17FEB] Why Did the Cow Cross the Road I S", "background": "", "description": "Farmer John's cows are trying to learn to cross the road effectively. Remembering the old \"why did the chicken cross the road?\" joke, they figure the chickens must be experts on crossing the road, and go off in search of chickens to help them.\n\nAs it turns out, chickens are very busy creatures and have limited time to help the cows. There are $C$ chickens on the farm ($1 \\leq C \\leq 20,000$), conveniently numbered $1 \\ldots C$, and each chicken $i$ is only willing to help a cow at precisely time $T_i$. The cows, never in a hurry, have more flexibility in their schedules. There are $N$ cows on the farm ($1 \\leq N \\leq 20,000$), conveniently numbered $1 \\ldots N$, where cow $j$ is able to cross the road between time $A_j$ and time $B_j$. Figuring the \"buddy system\" is the best way to proceed, each cow $j$ would ideally like to find a chicken $i$ to help her cross the road; in order for their schedules to be compatible, $i$ and $j$ must satisfy $A_j \\leq T_i \\leq B_j$.\n\nIf each cow can be paired with at most one chicken and each chicken with at most one cow, please help compute the maximum number of cow-chicken pairs that can be constructed.", "inputFormat": "The first line of input contains $C$ and $N$. The next $C$ lines contain $T_1 \\ldots T_C$, and the next $N$ lines contain $A_j$ and $B_j$ ($A_j \\leq B_j$) for $j = 1 \\ldots N$. The $A$'s, $B$'s, and $T$'s are all non-negative integers (not necessarily distinct) of size at most 1,000,000,000", "outputFormat": "Please compute the maximum possible number of cow-chicken pairs.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17FEB] Why Did the Cow Cross the Road I S", "background": "", "description": "Farmer John's cows are trying to learn to cross the road effectively. Remembering the old \"why did the chicken cross the road?\" joke, they figure the chickens must be experts on crossing the road, and go off in search of chickens to help them.\n\nAs it turns out, chickens are very busy creatures and have limited time to help the cows. There are $C$ chickens on the farm ($1 \\leq C \\leq 20,000$), conveniently numbered $1 \\ldots C$, and each chicken $i$ is only willing to help a cow at precisely time $T_i$. The cows, never in a hurry, have more flexibility in their schedules. There are $N$ cows on the farm ($1 \\leq N \\leq 20,000$), conveniently numbered $1 \\ldots N$, where cow $j$ is able to cross the road between time $A_j$ and time $B_j$. Figuring the \"buddy system\" is the best way to proceed, each cow $j$ would ideally like to find a chicken $i$ to help her cross the road; in order for their schedules to be compatible, $i$ and $j$ must satisfy $A_j \\leq T_i \\leq B_j$.\n\nIf each cow can be paired with at most one chicken and each chicken with at most one cow, please help compute the maximum number of cow-chicken pairs that can be constructed.", "inputFormat": "The first line of input contains $C$ and $N$. The next $C$ lines contain $T_1 \\ldots T_C$, and the next $N$ lines contain $A_j$ and $B_j$ ($A_j \\leq B_j$) for $j = 1 \\ldots N$. The $A$'s, $B$'s, and $T$'s are all non-negative integers (not necessarily distinct) of size at most 1,000,000,000", "outputFormat": "Please compute the maximum possible number of cow-chicken pairs.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17FEB] Why Did the Cow Cross the Road S", "background": null, "description": "Farmer John 的奶牛们正在学习如何有效地过马路。回想起古老的“鸡为什么要过马路？”笑话，他们认为鸡一定是过马路的专家，于是去寻找鸡来帮助它们。\n\n事实上，鸡是非常忙碌的生物，它们只有有限的时间来帮助奶牛。农场上有 $C$ 只鸡（$1 \\leq C \\leq 20,000$），方便地用编号 $1 \\ldots C$ 标识，每只鸡 $i$ 只愿意在确切的时间 $T_i$ 帮助一头奶牛。奶牛们从不着急，它们的日程安排更加灵活。农场上有 $N$ 头奶牛（$1 \\leq N \\leq 20,000$），方便地用编号 $1 \\ldots N$ 标识，其中奶牛 $j$ 能够在时间 $A_j$ 到时间 $B_j$ 之间过马路。考虑到“伙伴系统”是最好的方式，每头奶牛 $j$ 理想情况下希望找到一只鸡 $i$ 来帮助她过马路；为了使它们的日程安排兼容，$i$ 和 $j$ 必须满足 $A_j \\leq T_i \\leq B_j$。\n\n如果每头奶牛最多只能与一只鸡配对，每只鸡也最多只能与一头奶牛配对，请计算可以构建的最大奶牛-鸡配对数。", "inputFormat": "输入的第一行包含 $C$ 和 $N$。接下来的 $C$ 行包含 $T_1 \\ldots T_C$，接下来的 $N$ 行包含 $A_j$ 和 $B_j$（$A_j \\leq B_j$），其中 $j = 1 \\ldots N$。$A$、$B$ 和 $T$ 都是不超过 1,000,000,000 的非负整数（不一定互不相同）。", "outputFormat": "请计算可能的奶牛-鸡配对的最大数量。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3662", "type": "P", "difficulty": 3, "samples": [["10 6 5\n2\n10\n1\n5\n9", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "USACO", "枚举", "前缀和", "队列"], "title": "[USACO17FEB] Why Did the Cow Cross the Road II S", "background": "", "description": "The long road through Farmer John's farm has $N$ crosswalks across it, conveniently numbered $1 \\ldots N$ ($1 \\leq N \\leq 100,000$). To allow cows to cross at these crosswalks, FJ installs electric crossing signals, which light up with a green cow icon when it is ok for the cow to cross, and red otherwise. Unfortunately, a large electrical storm has damaged some of his signals. Given a list of the damaged signals, please compute the minimum number of signals that FJ needs to repair in order for there to exist some contiguous block of at least $K$ working signals.", "inputFormat": "The first line of input contains $N$, $K$, and $B$ ($1 \\leq B, K \\leq N$). The next $B$ lines each describe the ID number of a broken signal.", "outputFormat": "Please compute the minimum number of signals that need to be repaired in order for there to be a contiguous block of $K$ working signals somewhere along the road.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17FEB] Why Did the Cow Cross the Road II S", "background": "", "description": "The long road through Farmer John's farm has $N$ crosswalks across it, conveniently numbered $1 \\ldots N$ ($1 \\leq N \\leq 100,000$). To allow cows to cross at these crosswalks, FJ installs electric crossing signals, which light up with a green cow icon when it is ok for the cow to cross, and red otherwise. Unfortunately, a large electrical storm has damaged some of his signals. Given a list of the damaged signals, please compute the minimum number of signals that FJ needs to repair in order for there to exist some contiguous block of at least $K$ working signals.", "inputFormat": "The first line of input contains $N$, $K$, and $B$ ($1 \\leq B, K \\leq N$). The next $B$ lines each describe the ID number of a broken signal.", "outputFormat": "Please compute the minimum number of signals that need to be repaired in order for there to be a contiguous block of $K$ working signals somewhere along the road.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17FEB] Why Did the Cow Cross the Road II S", "background": "", "description": "穿过 Farmer John 农场的长路上有 $N$ 个人行横道，方便地用编号 $1 \\ldots N$ 标识（$1 \\leq N \\leq 100,000$）。为了让奶牛能够通过这些横道过马路，FJ 安装了电子过马路信号灯，当奶牛可以安全过马路时，信号灯会显示绿色的奶牛图标，否则显示红色。不幸的是，一场大雷暴损坏了他的一些信号灯。给定损坏信号灯的列表，请计算 FJ 需要修复的最少信号灯数量，以便存在至少 $K$ 个连续的信号灯正常工作。", "inputFormat": "输入的第一行包含 $N$、$K$ 和 $B$（$1 \\leq B, K \\leq N$）。接下来的 $B$ 行每行描述一个损坏信号灯的 ID 编号。", "outputFormat": "请计算需要修复的最少信号灯数量，以便在道路上某处存在一个长度为 $K$ 的连续正常工作信号灯块。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3663", "type": "P", "difficulty": 4, "samples": [["3 3 3\n2 2 2 3\n3 3 3 2\n3 3 2 3\n3 3\n2 2\n2 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "USACO", "广度优先搜索 BFS", "深度优先搜索 DFS", "连通块"], "title": "[USACO17FEB] Why Did the Cow Cross the Road III S", "background": "", "description": "Why did the cow cross the road? Well, one reason is that Farmer John's farm simply has a lot of roads, making it impossible for his cows to travel around without crossing many of them.\n\nFJ's farm is arranged as an $N \\times N$ square grid of fields ($2 \\leq N \\leq 100$), Certain pairs of adjacent fields (e.g., north-south or east-west) are separated by roads, and a tall fence runs around the external perimeter of the entire grid, preventing cows from leaving the farm. Cows can move freely from any field to any other adjacent field (north, east, south, or west), although they prefer not to cross roads unless absolutely necessary.\n\nThere are $K$ cows ($1 \\leq K \\leq 100, K \\leq N^2$) on FJ's farm, each located in a different field. A pair of cows is said to be \"distant\" if, in order for one cow to visit the other, it is necessary to cross at least one road. Please help FJ count the number of distant pairs of cows.", "inputFormat": "The first line of input contains $N$, $K$, and $R$. The next $R$ lines describe $R$ roads that exist between pairs of adjacent fields. Each line is of the form $r$ $c$ $r'$ $c'$ (integers in the range $1 \\ldots N$), indicating a road between the field in (row $r$, column $c$) and the adjacent field in (row $r'$, column $c'$). The final $K$ lines indicate the locations of the $K$ cows, each specified in terms of a row and column.", "outputFormat": "Print the number of pairs of cows that are distant.", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17FEB] Why Did the Cow Cross the Road III S", "background": "", "description": "Why did the cow cross the road? Well, one reason is that Farmer John's farm simply has a lot of roads, making it impossible for his cows to travel around without crossing many of them.\n\nFJ's farm is arranged as an $N \\times N$ square grid of fields ($2 \\leq N \\leq 100$), Certain pairs of adjacent fields (e.g., north-south or east-west) are separated by roads, and a tall fence runs around the external perimeter of the entire grid, preventing cows from leaving the farm. Cows can move freely from any field to any other adjacent field (north, east, south, or west), although they prefer not to cross roads unless absolutely necessary.\n\nThere are $K$ cows ($1 \\leq K \\leq 100, K \\leq N^2$) on FJ's farm, each located in a different field. A pair of cows is said to be \"distant\" if, in order for one cow to visit the other, it is necessary to cross at least one road. Please help FJ count the number of distant pairs of cows.", "inputFormat": "The first line of input contains $N$, $K$, and $R$. The next $R$ lines describe $R$ roads that exist between pairs of adjacent fields. Each line is of the form $r$ $c$ $r'$ $c'$ (integers in the range $1 \\ldots N$), indicating a road between the field in (row $r$, column $c$) and the adjacent field in (row $r'$, column $c'$). The final $K$ lines indicate the locations of the $K$ cows, each specified in terms of a row and column.", "outputFormat": "Print the number of pairs of cows that are distant.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17FEB] Why Did the Cow Cross the Road III S", "background": "", "description": "奶牛为什么要过马路？其中一个原因是 Farmer John 的农场有很多道路，使得他的奶牛在四处走动时不可避免地要穿过许多道路。\n\nFJ 的农场被安排成一个 $N \\times N$ 的方形网格田地（$2 \\leq N \\leq 100$），某些相邻的田地（例如南北向或东西向）被道路分隔，整个网格的外部有一圈高高的围栏，防止奶牛离开农场。奶牛可以从任何田地自由移动到相邻的田地（北、东、南或西），尽管它们除非绝对必要，否则不愿意穿过道路。\n\n农场上有 $K$ 头奶牛（$1 \\leq K \\leq 100, K \\leq N^2$），每头奶牛位于不同的田地。如果一头奶牛要拜访另一头奶牛时必须至少穿过一条道路，那么这对奶牛被称为“远距离”对。请帮助 FJ 计算远距离奶牛对的数量。", "inputFormat": "输入的第一行包含 $N$、$K$ 和 $R$。接下来的 $R$ 行描述了 $R$ 条存在于相邻田地之间的道路。每行的格式为 $r$ $c$ $r'$ $c'$（范围为 $1 \\ldots N$ 的整数），表示位于（行 $r$，列 $c$）的田地与相邻的（行 $r'$，列 $c'$）的田地之间有一条道路。最后的 $K$ 行表示 $K$ 头奶牛的位置，每行用行和列指定。", "outputFormat": "输出远距离奶牛对的数量。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3664", "type": "P", "difficulty": 5, "samples": [["4\n2 2 3 0\n2 7 3 7\n2 7 7 7\n0 0 0 0", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2017", "USACO", "前缀和", "差分"], "title": "[USACO17OPEN] Modern Art P", "background": "", "description": "Art critics worldwide have only recently begun to recognize the creative genius behind the great bovine painter, Picowso.\n\n\nPicowso paints in a very particular way. She starts with an $N \\times N$ blank canvas, represented by an $N \\times N$ grid of zeros, where a zero indicates an empty cell of the canvas. She then draws $N^2$ rectangles on the canvas, one in each of $N^2$ colors (conveniently numbered $1 \\ldots N^2$). For example, she might start by painting a rectangle in color 2, giving this intermediate canvas:\n\n\n```\n2 2 2 0\n\n2 2 2 0\n\n2 2 2 0\n\n0 0 0 0\n```\n\n\n\n\nShe might then paint a rectangle in color 7:\n\n```\n2 2 2 0\n\n2 7 7 7\n\n2 7 7 7\n\n0 0 0 0\n```\n\n\n\n\nAnd then she might paint a small rectangle in color 3:\n\n```\n2 2 3 0\n\n2 7 3 7\n\n2 7 7 7\n\n0 0 0 0\n```\n\n\nEach rectangle has sides parallel to the edges of the canvas, and a rectangle could be as large as the entire canvas or as small as a single cell. Each color from $1 \\ldots N^2$ is used exactly once, although later colors might completely cover up some of the earlier colors.\n\n\nGiven the final state of the canvas, please count how many of the $N^2$ colors could have possibly been the first to be painted.", "inputFormat": "The first line of input contains $N$, the size of the canvas ($1 \\leq N \\leq 1000$).\n\nThe next $N$ lines describe the final picture of the canvas, each containing $N$ integers that are in the range $0 \\ldots N^2$. The input is guaranteed to have been drawn as described above, by painting successive rectangles in different colors.\n", "outputFormat": "Please output a count of the number of colors that could have been drawn first.\n", "hint": "In this example, color 2 could have been the first to be painted. Color 3 clearly had to have been painted after color 7, and color 7 clearly had to have been painted after color 2. Since we don't see the other colors, we deduce that they also could have been painted first.", "locale": "en", "translations": {"en": {"title": "[USACO17OPEN] Modern Art P", "background": "", "description": "Art critics worldwide have only recently begun to recognize the creative genius behind the great bovine painter, Picowso.\n\n\nPicowso paints in a very particular way. She starts with an $N \\times N$ blank canvas, represented by an $N \\times N$ grid of zeros, where a zero indicates an empty cell of the canvas. She then draws $N^2$ rectangles on the canvas, one in each of $N^2$ colors (conveniently numbered $1 \\ldots N^2$). For example, she might start by painting a rectangle in color 2, giving this intermediate canvas:\n\n\n```\n2 2 2 0\n\n2 2 2 0\n\n2 2 2 0\n\n0 0 0 0\n```\n\n\n\n\nShe might then paint a rectangle in color 7:\n\n```\n2 2 2 0\n\n2 7 7 7\n\n2 7 7 7\n\n0 0 0 0\n```\n\n\n\n\nAnd then she might paint a small rectangle in color 3:\n\n```\n2 2 3 0\n\n2 7 3 7\n\n2 7 7 7\n\n0 0 0 0\n```\n\n\nEach rectangle has sides parallel to the edges of the canvas, and a rectangle could be as large as the entire canvas or as small as a single cell. Each color from $1 \\ldots N^2$ is used exactly once, although later colors might completely cover up some of the earlier colors.\n\n\nGiven the final state of the canvas, please count how many of the $N^2$ colors could have possibly been the first to be painted.", "inputFormat": "The first line of input contains $N$, the size of the canvas ($1 \\leq N \\leq 1000$).\n\nThe next $N$ lines describe the final picture of the canvas, each containing $N$ integers that are in the range $0 \\ldots N^2$. The input is guaranteed to have been drawn as described above, by painting successive rectangles in different colors.\n", "outputFormat": "Please output a count of the number of colors that could have been drawn first.\n", "hint": "In this example, color 2 could have been the first to be painted. Color 3 clearly had to have been painted after color 7, and color 7 clearly had to have been painted after color 2. Since we don't see the other colors, we deduce that they also could have been painted first.", "locale": "en"}, "zh-CN": {"title": "[USACO17OPEN] Modern Art P", "background": "", "description": "世界各地的艺术评论家最近才开始认识到伟大的奶牛画家 Picowso 的创作天才。\n\nPicowso 以一种非常独特的方式作画。她从一个 $N \\times N$ 的空白画布开始，画布用一个 $N \\times N$ 的零网格表示，其中零表示画布的一个空单元格。然后她在画布上绘制 $N^2$ 个矩形，每个矩形使用 $N^2$ 种颜色中的一种（方便地用编号 $1 \\ldots N^2$ 标识）。例如，她可能首先用颜色 2 绘制一个矩形，得到以下中间画布：\n\n```\n2 2 2 0\n\n2 2 2 0\n\n2 2 2 0\n\n0 0 0 0\n```\n\n然后她可能用颜色 7 绘制一个矩形：\n\n```\n2 2 2 0\n\n2 7 7 7\n\n2 7 7 7\n\n0 0 0 0\n```\n\n接着她可能用颜色 3 绘制一个小矩形：\n\n```\n2 2 3 0\n\n2 7 3 7\n\n2 7 7 7\n\n0 0 0 0\n```\n\n每个矩形的边都与画布的边缘平行，矩形可以大到整个画布，也可以小到一个单元格。每种颜色从 $1 \\ldots N^2$ 恰好使用一次，尽管后来的颜色可能会完全覆盖一些先前的颜色。\n\n给定画布的最终状态，请计算有多少种颜色可能是第一个被绘制的。", "inputFormat": "输入的第一行包含 $N$，表示画布的大小（$1 \\leq N \\leq 1000$）。\n\n接下来的 $N$ 行描述画布的最终状态，每行包含 $N$ 个整数，范围在 $0 \\ldots N^2$。输入保证是按照上述方式通过连续绘制不同颜色的矩形生成的。", "outputFormat": "请输出可能是第一个被绘制的颜色的数量。", "hint": "在这个例子中，颜色 2 可能是第一个被绘制的。颜色 3 显然必须在颜色 7 之后绘制，而颜色 7 显然必须在颜色 2 之后绘制。由于我们没有看到其他颜色，我们推断它们也可能是第一个被绘制的。", "locale": "zh-CN"}}}
{"pid": "P3665", "type": "P", "difficulty": 6, "samples": [["3 2 3 4\n1 2 3\n2 3 1\n1 1 2\n3 3\n2 3\n1 2\n2 2", "1\n3\n3\n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "线段树", "USACO", "Kruskal 重构树", "生成树"], "title": "[USACO17OPEN] Switch Grass P", "background": "", "description": "Farmer John has recently been experimenting with cultivating different types of grass on his farm, realizing that different types of cows like different types of grass. However, he must be careful to ensure that different types of grass are planted sufficiently far away from each-other, in order to prevent them from being inextricably mixed.\n\n\nFJ's farm consists of $N$ fields ($1 \\leq N \\leq 200,000$), where $M$ pairs of  fields are connected by bi-directional pathways ($1 \\leq M \\leq 200,000$).  Using these pathways, it is possible to walk from any field to any other field. Each pathway has an integer length in the range $1 \\ldots 1,000,000$. Any pair of fields will be linked by at most one direct pathway.\n\n\nIn each field, FJ initially plants one of $K$ types of grass ($1 \\leq K \\leq N$). Over time, however, he might decide to switch the grass in some field to a different type. He calls this an \"update\"  peration. He might perform several updates over the course of time, which are all cumulative in nature.\n\n\nAfter each update, FJ would like to know the length of the shortest path between two fields having different grass types. That is, among all pairs of fields having different grass types, he wants to know which two are closest. Ideally,\n\nthis number is large, so he can prevent grass of one type from mixing with grass of another type. It is guaranteed that the farm will always have at least two fields with different grass types.\n\n\nIn 30 percent of the input cases, each field will be directly connected to at most 10 pathways.\n\n\n", "inputFormat": "The first line of input contains four integers, $N$, $M$, $K$, and $Q$, where $Q$ is the number of updates ($1 \\leq Q \\leq 200,000$).\n\nThe next $M$ lines describe the paths; each one contains three integers $A$, $B$, and $L$, indicating a path from field $A$ to field $B$ (both integers in the range $1 \\ldots N$) of length $L$.\n\nThe next line indicates the initial type of grass growing in each field ($N$ integers in the range $1 \\ldots K$).\n\nFinally, the last $Q$ lines each describe an update, specified by two integers $A$ and $B$, where the grass in field $A$ is to be updated to type $B$.\n", "outputFormat": "For each update, print the length of the shortest path between two fields with different types of grass, after the update is applied.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17OPEN] Switch Grass P", "background": "", "description": "Farmer John has recently been experimenting with cultivating different types of grass on his farm, realizing that different types of cows like different types of grass. However, he must be careful to ensure that different types of grass are planted sufficiently far away from each-other, in order to prevent them from being inextricably mixed.\n\n\nFJ's farm consists of $N$ fields ($1 \\leq N \\leq 200,000$), where $M$ pairs of  fields are connected by bi-directional pathways ($1 \\leq M \\leq 200,000$).  Using these pathways, it is possible to walk from any field to any other field. Each pathway has an integer length in the range $1 \\ldots 1,000,000$. Any pair of fields will be linked by at most one direct pathway.\n\n\nIn each field, FJ initially plants one of $K$ types of grass ($1 \\leq K \\leq N$). Over time, however, he might decide to switch the grass in some field to a different type. He calls this an \"update\"  peration. He might perform several updates over the course of time, which are all cumulative in nature.\n\n\nAfter each update, FJ would like to know the length of the shortest path between two fields having different grass types. That is, among all pairs of fields having different grass types, he wants to know which two are closest. Ideally,\n\nthis number is large, so he can prevent grass of one type from mixing with grass of another type. It is guaranteed that the farm will always have at least two fields with different grass types.\n\n\nIn 30 percent of the input cases, each field will be directly connected to at most 10 pathways.\n\n\n", "inputFormat": "The first line of input contains four integers, $N$, $M$, $K$, and $Q$, where $Q$ is the number of updates ($1 \\leq Q \\leq 200,000$).\n\nThe next $M$ lines describe the paths; each one contains three integers $A$, $B$, and $L$, indicating a path from field $A$ to field $B$ (both integers in the range $1 \\ldots N$) of length $L$.\n\nThe next line indicates the initial type of grass growing in each field ($N$ integers in the range $1 \\ldots K$).\n\nFinally, the last $Q$ lines each describe an update, specified by two integers $A$ and $B$, where the grass in field $A$ is to be updated to type $B$.\n", "outputFormat": "For each update, print the length of the shortest path between two fields with different types of grass, after the update is applied.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17OPEN] Switch Grass P", "background": "", "description": "Farmer John 最近在他的农场尝试种植不同类型的草，发现不同类型的奶牛喜欢不同类型的草。然而，他必须小心确保不同类型的草种植得足够远，以防止它们不可分割地混合在一起。\n\nFJ 的农场由 $N$ 块田地组成（$1 \\leq N \\leq 200,000$），其中 $M$ 对田地通过双向路径连接（$1 \\leq M \\leq 200,000$）。使用这些路径，可以从任何田地走到任何其他田地。每条路径的长度是一个在 $1 \\ldots 1,000,000$ 范围内的整数。任何一对田地之间最多只有一条直接路径。\n\n在每块田地中，FJ 最初种植了 $K$ 种草中的一种（$1 \\leq K \\leq N$）。然而，随着时间的推移，他可能会决定将某块田地的草更换为另一种类型。他称这种操作为“更新”操作。他可能会在一段时间内执行多次更新，这些更新都是累积性质的。\n\n每次更新后，FJ 想知道种植不同草类型的两块田地之间的最短路径长度。也就是说，在所有种植不同草类型的田地对中，他希望知道哪两块田地最接近。理想情况下，这个数字应该较大，以便他可以防止一种类型的草与另一种类型的草混合。保证农场中始终至少有两块田地种植不同的草类型。\n\n在 30% 的输入案例中，每块田地最多直接连接 10 条路径。", "inputFormat": "输入的第一行包含四个整数 $N$、$M$、$K$ 和 $Q$，其中 $Q$ 是更新的次数（$1 \\leq Q \\leq 200,000$）。\n\n接下来的 $M$ 行描述路径；每行包含三个整数 $A$、$B$ 和 $L$，表示从田地 $A$ 到田地 $B$（两者都是 $1 \\ldots N$ 范围内的整数）的长度为 $L$ 的路径。\n\n接下来的一行表示每块田地最初种植的草类型（$N$ 个 $1 \\ldots K$ 范围内的整数）。\n\n最后，最后的 $Q$ 行每行描述一个更新，由两个整数 $A$ 和 $B$ 指定，表示将田地 $A$ 的草更新为类型 $B$。", "outputFormat": "对于每次更新，输出更新后种植不同草类型的两块田地之间的最短路径长度。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3666", "type": "P", "difficulty": 6, "samples": [["x = 1\n10 MOO {\nx = ( x ) + ( x )\n}\nRETURN x", "1024"], ["n = 1\nnsq = 1\n100000 MOO {\n100000 MOO {\nnsq = ( nsq ) + ( ( n ) + ( ( n ) + ( 1 ) ) )\nn = ( n ) + ( 1 )\n}\n}\nRETURN nsq", "4761"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2017", "USACO", "矩阵乘法", "栈", "构造"], "title": "[USACO17OPEN] COWBASIC P", "background": "", "description": "Bessie has invented a new programming language, but since there is no compiler yet, she needs your help to actually run her programs.\n\n\nCOWBASIC is a simple, elegant language. It has two key features: addition and MOO loops. Bessie has devised a clever solution to overflow: all addition is done modulo $10^9+7$. But Bessie's real achievement is the MOO loop, which runs a block of code a fixed number of times. MOO loops and addition can, of course, be nested.\n\n\nGiven a COWBASIC program, please help Bessie determine what number it returns.\n", "inputFormat": "You are given a COWBASIC program at most 100 lines long, with each line being at most 350 characters long. A COWBASIC program is a list of statements.\n\nThere are three types of statements:\n\n```cpp\n<variable> = <expression>\n\n<literal> MOO {\n<list of statements>\n}\n\nRETURN <variable>\n```\n\nThere are three types of expressions:\n\n```cpp\n<literal>\n\n<variable>\n\n( <expression> ) + ( <expression> )\n```\n\nA literal is a positive integer at most 100,000.\n\nA variable is a string of at most 10 lowercase English letters.\n\nIt is guaranteed that no variable will be used or RETURNed before it is defined. It is guaranteed that RETURN will happen exactly once, on the last line of the program.", "outputFormat": "Output a single positive integer, giving the value of the RETURNed variable.\n", "hint": "Scoring\n\nIn 20 percent of all test cases - MOO loops are not nested.\n\nIn another 20 percent of all test cases - The program only has 1 variable. MOO loops can be nested.\n\nIn the remaining test cases, there are no further restrictions.", "locale": "en", "translations": {"en": {"title": "[USACO17OPEN] COWBASIC P", "background": "", "description": "Bessie has invented a new programming language, but since there is no compiler yet, she needs your help to actually run her programs.\n\n\nCOWBASIC is a simple, elegant language. It has two key features: addition and MOO loops. Bessie has devised a clever solution to overflow: all addition is done modulo $10^9+7$. But Bessie's real achievement is the MOO loop, which runs a block of code a fixed number of times. MOO loops and addition can, of course, be nested.\n\n\nGiven a COWBASIC program, please help Bessie determine what number it returns.\n", "inputFormat": "You are given a COWBASIC program at most 100 lines long, with each line being at most 350 characters long. A COWBASIC program is a list of statements.\n\nThere are three types of statements:\n\n```cpp\n<variable> = <expression>\n\n<literal> MOO {\n<list of statements>\n}\n\nRETURN <variable>\n```\n\nThere are three types of expressions:\n\n```cpp\n<literal>\n\n<variable>\n\n( <expression> ) + ( <expression> )\n```\n\nA literal is a positive integer at most 100,000.\n\nA variable is a string of at most 10 lowercase English letters.\n\nIt is guaranteed that no variable will be used or RETURNed before it is defined. It is guaranteed that RETURN will happen exactly once, on the last line of the program.", "outputFormat": "Output a single positive integer, giving the value of the RETURNed variable.\n", "hint": "Scoring\n\nIn 20 percent of all test cases - MOO loops are not nested.\n\nIn another 20 percent of all test cases - The program only has 1 variable. MOO loops can be nested.\n\nIn the remaining test cases, there are no further restrictions.", "locale": "en"}, "zh-CN": {"title": "[USACO17OPEN] COWBASIC P", "background": "", "description": "Bessie 发明了一种新的编程语言，但由于还没有编译器，她需要你的帮助来实际运行她的程序。\n\nCOWBASIC 是一种简单而优雅的语言。它有两个关键特性：加法和 MOO 循环。Bessie 设计了一个巧妙的解决方案来处理溢出：所有的加法都是在模 $10^9+7$ 下进行的。但 Bessie 的真正成就是 MOO 循环，它可以固定次数地运行一段代码。当然，MOO 循环和加法可以嵌套。\n\n给定一个 COWBASIC 程序，请帮助 Bessie 确定它返回的数字。", "inputFormat": "你将获得一个最多 100 行的 COWBASIC 程序，每行最多 350 个字符。一个 COWBASIC 程序是一个语句列表。\n\n有三种类型的语句：\n\n```cpp\n<variable> = <expression>\n\n<literal> MOO {\n<list of statements>\n}\n\nRETURN <variable>\n```\n\n有三种类型的表达式：\n\n```cpp\n<literal>\n\n<variable>\n\n( <expression> ) + ( <expression> )\n```\n\n字面量是一个最多为 100,000 的正整数。\n\n变量是一个最多由 10 个小写英文字母组成的字符串。\n\n保证在定义之前不会使用或 RETURN 任何变量。保证 RETURN 恰好发生一次，并且在程序的最后一行。", "outputFormat": "输出一个正整数，表示 RETURN 的变量的值。", "hint": "评分\n\n在 20% 的测试用例中，MOO 循环不会嵌套。\n\n在另外 20% 的测试用例中，程序只有一个变量。MOO 循环可以嵌套。\n\n在剩余的测试用例中，没有进一步的限制。", "locale": "zh-CN"}}}
{"pid": "P3667", "type": "P", "difficulty": 5, "samples": [["3 8\nAATCCCAT\nACTTGCAA\nGGTCGCAA\nACTCCCAG\nACTCGCAT\nACTTCCAT", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "二分", "USACO", "哈希 hashing"], "title": "[USACO17OPEN] Bovine Genomics G", "background": "", "description": "Farmer John owns $N$ cows with spots and $N$ cows without spots. Having just completed a course in bovine genetics, he is convinced that the spots on his cows are caused by mutations in the bovine genome.\n\n\nAt great expense, Farmer John sequences the genomes of his cows. Each genome is a string of length $M$ built from the four characters A, C, G, and T. When he lines up the genomes of his cows, he gets a table like the following, shown here\n\nfor $N=3$ and $M=8$:\n\n\n```cpp\nPositions: 1 2 3 4 5 6 7 8\n\nSpotty Cow 1: A A T C C C A T\nSpotty Cow 2: A C T T G C A A\nSpotty Cow 3: G G T C G C A A\n\nPlain Cow 1: A C T C C C A G\nPlain Cow 2: A C T C G C A T\nPlain Cow 3: A C T T C C A T\n```\n\nLooking carefully at this table, he surmises that the sequence from position 2 through position 5 is sufficient to explain spottiness. That is, by looking at the characters in just these these positions (that is, positions $2 \\ldots 5$), Farmer John can predict which of his cows are spotty and which are not. For example, if he sees the characters GTCG in these locations, he knows the cow must be spotty.\n\n\nPlease help FJ find the length of the shortest sequence of positions that can explain spottiness.\n\n", "inputFormat": "The first line of input contains $N$ ($1 \\leq N \\leq 500$) and $M$ ($3 \\leq M \\leq 500$). The next $N$ lines each contain a string of $M$ characters; these describe the genomes of the spotty cows.\n\nThe final $N$ lines describe the genomes of the plain cows. No spotty cow has the same exact  genome as a plain cow.\n", "outputFormat": "Please print the length of the shortest sequence of positions that is sufficient to explain spottiness. A sequence of positions explains spottiness if the spottiness trait can be predicted with perfect accuracy among Farmer John's population of cows by looking at just those locations in the genome.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17OPEN] Bovine Genomics G", "background": "", "description": "Farmer John owns $N$ cows with spots and $N$ cows without spots. Having just completed a course in bovine genetics, he is convinced that the spots on his cows are caused by mutations in the bovine genome.\n\n\nAt great expense, Farmer John sequences the genomes of his cows. Each genome is a string of length $M$ built from the four characters A, C, G, and T. When he lines up the genomes of his cows, he gets a table like the following, shown here\n\nfor $N=3$ and $M=8$:\n\n\n```cpp\nPositions: 1 2 3 4 5 6 7 8\n\nSpotty Cow 1: A A T C C C A T\nSpotty Cow 2: A C T T G C A A\nSpotty Cow 3: G G T C G C A A\n\nPlain Cow 1: A C T C C C A G\nPlain Cow 2: A C T C G C A T\nPlain Cow 3: A C T T C C A T\n```\n\nLooking carefully at this table, he surmises that the sequence from position 2 through position 5 is sufficient to explain spottiness. That is, by looking at the characters in just these these positions (that is, positions $2 \\ldots 5$), Farmer John can predict which of his cows are spotty and which are not. For example, if he sees the characters GTCG in these locations, he knows the cow must be spotty.\n\n\nPlease help FJ find the length of the shortest sequence of positions that can explain spottiness.\n\n", "inputFormat": "The first line of input contains $N$ ($1 \\leq N \\leq 500$) and $M$ ($3 \\leq M \\leq 500$). The next $N$ lines each contain a string of $M$ characters; these describe the genomes of the spotty cows.\n\nThe final $N$ lines describe the genomes of the plain cows. No spotty cow has the same exact  genome as a plain cow.\n", "outputFormat": "Please print the length of the shortest sequence of positions that is sufficient to explain spottiness. A sequence of positions explains spottiness if the spottiness trait can be predicted with perfect accuracy among Farmer John's population of cows by looking at just those locations in the genome.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17OPEN] Bovine Genomics G", "background": "", "description": "Farmer John 拥有 $N$ 头有斑点的牛和 $N$ 头没有斑点的牛。他刚刚完成了一门关于牛遗传学的课程，并确信他牛身上的斑点是由牛基因组中的突变引起的。\n\nFarmer John 花费巨资对他的牛进行了基因组测序。每个基因组是一个由字符 A、C、G 和 T 组成的长度为 $M$ 的字符串。当他将牛的基因组排列起来时，会得到如下表格，这里展示的是 $N=3$ 和 $M=8$ 的情况：\n\n```\n位置：   1 2 3 4 5 6 7 8\n\n斑点牛 1：A A T C C C A T  \n斑点牛 2：A C T T G C A A  \n斑点牛 3：G G T C G C A A  \n\n普通牛 1：A C T C C C A G  \n普通牛 2：A C T C G C A T  \n普通牛 3：A C T T C C A T  \n```\n\n仔细观察这个表格后，他推测从位置 2 到位置 5 的序列足以解释斑点现象。也就是说，通过仅查看这些位置（即位置 $2 \\ldots 5$）的字符，Farmer John 可以预测哪些牛是有斑点的，哪些是没有斑点的。例如，如果他在这些位置看到字符 GTCG，他就知道这头牛一定是有斑点的。\n\n请帮助 Farmer John 找到能够解释斑点现象的最短位置序列的长度。", "inputFormat": "输入的第一行包含 $N$（$1 \\leq N \\leq 500$）和 $M$（$3 \\leq M \\leq 500$）。接下来的 $N$ 行每行包含一个长度为 $M$ 的字符串，这些字符串描述了斑点牛的基因组。\n\n最后的 $N$ 行描述了普通牛的基因组。没有任何一头斑点牛的基因组与普通牛的完全相同。", "outputFormat": "请输出能够解释斑点现象的最短位置序列的长度。如果通过查看基因组中这些位置的字符，可以在 Farmer John 的牛群中完美准确地预测斑点性状，那么这个位置序列就解释了斑点现象。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3668", "type": "P", "difficulty": 4, "samples": [["7\n0\n1\n4\n5\n1\n3\n3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2017", "USACO", "栈"], "title": "[USACO17OPEN] Modern Art 2 G", "background": "", "description": "Having become bored with standard 2-dimensional artwork (and also frustrated at others copying her work), the great bovine artist Picowso has decided to switch to a more minimalist, 1-dimensional style.\n\n\nAlthough, her paintings can now be described by a 1-dimensional array of colors of length $N$ ($1 \\leq N \\leq 100,000$), her painting style remains unchanged: she starts with a blank canvas and layers upon it a sequence of \"rectangles\" of paint, which in this 1-dimensional case are simply intervals. She uses each of the colors $1 \\ldots N$ exactly once, although just as before, some colors might end up being completely covered up by the end.\n\n\nTo Picowso's great dismay, her competitor Moonet seems to have figured out how to copy even these 1-dimensional paintings, using a similar strategy to the preceding problem: Moonet will paint a set of disjoint intervals, wait for them to dry, then paint another set of disjoint intervals, and so on. Moonet can only paint at most one interval of each color over the entire process. Please compute\n\nthe number of such rounds needed for Moonet to copy a given 1-dimensional Picowso painting.", "inputFormat": "The first line of input contains $N$, and the next $N$ lines contain an integer in the range $0 \\ldots N$ indicating the color of each cell in the 1-dimensional painting (0 for a blank cell).", "outputFormat": "Please output the minimum number of rounds needed to copy this painting, or -1 if this could not have possibly been an authentic work of Picowso (i.e., if she could not have painted it using a layered sequence of intervals, one of each color).\n", "hint": "In this example, the interval of color 1 must be painted in an earlier round than the intervals of colors 4 and 5, so at least two rounds are needed.", "locale": "en", "translations": {"en": {"title": "[USACO17OPEN] Modern Art 2 G", "background": "", "description": "Having become bored with standard 2-dimensional artwork (and also frustrated at others copying her work), the great bovine artist Picowso has decided to switch to a more minimalist, 1-dimensional style.\n\n\nAlthough, her paintings can now be described by a 1-dimensional array of colors of length $N$ ($1 \\leq N \\leq 100,000$), her painting style remains unchanged: she starts with a blank canvas and layers upon it a sequence of \"rectangles\" of paint, which in this 1-dimensional case are simply intervals. She uses each of the colors $1 \\ldots N$ exactly once, although just as before, some colors might end up being completely covered up by the end.\n\n\nTo Picowso's great dismay, her competitor Moonet seems to have figured out how to copy even these 1-dimensional paintings, using a similar strategy to the preceding problem: Moonet will paint a set of disjoint intervals, wait for them to dry, then paint another set of disjoint intervals, and so on. Moonet can only paint at most one interval of each color over the entire process. Please compute\n\nthe number of such rounds needed for Moonet to copy a given 1-dimensional Picowso painting.", "inputFormat": "The first line of input contains $N$, and the next $N$ lines contain an integer in the range $0 \\ldots N$ indicating the color of each cell in the 1-dimensional painting (0 for a blank cell).", "outputFormat": "Please output the minimum number of rounds needed to copy this painting, or -1 if this could not have possibly been an authentic work of Picowso (i.e., if she could not have painted it using a layered sequence of intervals, one of each color).\n", "hint": "In this example, the interval of color 1 must be painted in an earlier round than the intervals of colors 4 and 5, so at least two rounds are needed.", "locale": "en"}, "zh-CN": {"title": "[USACO17OPEN] Modern Art 2 G", "background": "", "description": "伟大的牛艺术家 Picowso 对标准的二维艺术作品感到厌倦（同时也对其他人抄袭她的作品感到沮丧），于是决定转向一种更极简主义的一维风格。\n\n尽管她的画作现在可以用一个长度为 $N$（$1 \\leq N \\leq 100,000$）的一维颜色数组来描述，但她的绘画风格保持不变：她从一个空白画布开始，并在其上叠加一系列“矩形”颜料，而在这种一维情况下，这些矩形仅仅是区间。她使用每种颜色 $1 \\ldots N$ 恰好一次，尽管和以前一样，某些颜色最终可能会被完全覆盖。\n\n令 Picowso 非常沮丧的是，她的竞争对手 Moonet 似乎已经找到了如何复制这些一维画作的方法，使用的策略与之前的问题类似：Moonet 会绘制一组不相交的区间，等待它们干燥，然后再绘制另一组不相交的区间，依此类推。在整个过程中，Moonet 只能为每种颜色绘制最多一个区间。请计算 Moonet 复制给定的一维 Picowso 画作所需的最少轮数。", "inputFormat": "输入的第一行包含 $N$，接下来的 $N$ 行每行包含一个范围在 $0 \\ldots N$ 的整数，表示一维画作中每个单元格的颜色（0 表示空白单元格）。", "outputFormat": "请输出复制这幅画作所需的最少轮数，如果这幅画作不可能是 Picowso 的真实作品（即她无法通过叠加一系列区间、每种颜色一个区间的方式绘制它），则输出 -1。", "hint": "在这个例子中，颜色 1 的区间必须在颜色 4 和 5 的区间之前绘制，因此至少需要两轮。", "locale": "zh-CN"}}}
{"pid": "P3669", "type": "P", "difficulty": 2, "samples": [["3\n1 8\n2 5\n1 2", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2017", "USACO", "排序"], "title": "[USACO17OPEN] Paired Up S", "background": "", "description": "Farmer John finds that his cows are each easier to milk when they have another cow nearby for moral support. He therefore wants to take his $M$ cows ($M \\leq 1,000,000,000$, $M$ even) and partition them into $M/2$ pairs. Each pair of cows will then be ushered off to a separate stall in the barn for milking. The milking in each of these $M/2$ stalls will take place simultaneously.\n\n\nTo make matters a bit complicated, each of Farmer John's cows has a different milk output. If cows of milk outputs $A$ and $B$ are paired up, then it takes a total of $A+B$ units of time to milk them both.\n\n\nPlease help Farmer John determine the minimum possible amount of time the entire milking process will take to complete, assuming he pairs the cows up in the best possible way.", "inputFormat": "The first line of input contains $N$ ($1 \\leq N \\leq 100,000$).\n\nEach of the next $N$ lines contains two integers $x$ and $y$, indicating that FJ has $x$ cows each with milk output $y$ ($1 \\leq y \\leq 1,000,000,000$). The sum of the $x$'s is $M$, the total number of cows.", "outputFormat": "Print out the minimum amount of time it takes FJ's cows to be milked, assuming they are optimally paired up.", "hint": "Here, if the cows with outputs 8+2 are paired up, and those with outputs 5+5 are paired up, the both stalls take 10 units of time for milking. Since milking takes place simultaneously, the entire process would therefore complete after 10 units of time. Any other pairing would be sub-optimal, resulting in a stall taking more than 10 units of time to milk.", "locale": "en", "translations": {"en": {"title": "[USACO17OPEN] Paired Up S", "background": "", "description": "Farmer John finds that his cows are each easier to milk when they have another cow nearby for moral support. He therefore wants to take his $M$ cows ($M \\leq 1,000,000,000$, $M$ even) and partition them into $M/2$ pairs. Each pair of cows will then be ushered off to a separate stall in the barn for milking. The milking in each of these $M/2$ stalls will take place simultaneously.\n\n\nTo make matters a bit complicated, each of Farmer John's cows has a different milk output. If cows of milk outputs $A$ and $B$ are paired up, then it takes a total of $A+B$ units of time to milk them both.\n\n\nPlease help Farmer John determine the minimum possible amount of time the entire milking process will take to complete, assuming he pairs the cows up in the best possible way.", "inputFormat": "The first line of input contains $N$ ($1 \\leq N \\leq 100,000$).\n\nEach of the next $N$ lines contains two integers $x$ and $y$, indicating that FJ has $x$ cows each with milk output $y$ ($1 \\leq y \\leq 1,000,000,000$). The sum of the $x$'s is $M$, the total number of cows.", "outputFormat": "Print out the minimum amount of time it takes FJ's cows to be milked, assuming they are optimally paired up.", "hint": "Here, if the cows with outputs 8+2 are paired up, and those with outputs 5+5 are paired up, the both stalls take 10 units of time for milking. Since milking takes place simultaneously, the entire process would therefore complete after 10 units of time. Any other pairing would be sub-optimal, resulting in a stall taking more than 10 units of time to milk.", "locale": "en"}, "zh-CN": {"title": "[USACO17OPEN] Paired Up S", "background": "", "description": "Farmer John 发现，当他的奶牛附近有另一头奶牛提供精神支持时，每头奶牛挤奶会更容易。因此，他希望将他的 $M$ 头奶牛（$M \\leq 1,000,000,000$，$M$ 为偶数）分成 $M/2$ 对。每对奶牛将被引导到谷仓中一个单独的隔间进行挤奶。这些 $M/2$ 个隔间中的挤奶过程将同时进行。\n\n为了增加一些复杂性，Farmer John 的每头奶牛都有不同的产奶量。如果产奶量分别为 $A$ 和 $B$ 的两头奶牛被配对，那么挤完它们总共需要 $A+B$ 单位时间。\n\n请帮助 Farmer John 确定整个挤奶过程完成所需的最少时间，假设他以最佳方式配对奶牛。", "inputFormat": "输入的第一行包含 $N$（$1 \\leq N \\leq 100,000$）。\n\n接下来的 $N$ 行每行包含两个整数 $x$ 和 $y$，表示 Farmer John 有 $x$ 头产奶量为 $y$ 的奶牛（$1 \\leq y \\leq 1,000,000,000$）。所有 $x$ 的总和为 $M$，即奶牛的总数。", "outputFormat": "输出 Farmer John 的奶牛挤奶所需的最少时间，假设它们以最佳方式配对。", "hint": "在这里，如果产奶量为 8 和 2 的奶牛配对，产奶量为 5 和 5 的奶牛配对，那么两个隔间的挤奶时间均为 10 单位时间。由于挤奶是同时进行的，因此整个挤奶过程将在 10 单位时间后完成。任何其他配对方式都会导致某个隔间的挤奶时间超过 10 单位时间，因此不是最优的。", "locale": "zh-CN"}}}
{"pid": "P3670", "type": "P", "difficulty": 3, "samples": [["3 8\nAATCCCAT\nGATTGCAA\nGGTCGCAA\nACTCCCAG\nACTCGCAT\nACTTCCAT", "22"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "USACO", "离散化", "枚举"], "title": "[USACO17OPEN] Bovine Genomics S", "background": "", "description": "Farmer John owns $N$ cows with spots and $N$ cows without spots. Having just completed a course in bovine genetics, he is convinced that the spots on his cows are caused by mutations in the bovine genome.\n\n\nAt great expense, Farmer John sequences the genomes of his cows. Each genome is a string of length $M$ built from the four characters A, C, G, and T. When he lines up the genomes of his cows, he gets a table like the following, shown here\n\n\nfor $N=3$:\n\n\n```cpp\nPositions: 1 2 3 4 5 6 7 ... M\n\nSpotty Cow 1: A A T C C C A ... T\nSpotty Cow 2: G A T T G C A ... A\nSpotty Cow 3: G G T C G C A ... A\n\nPlain Cow 1: A C T C C C A ... G\nPlain Cow 2: A G T T G C A ... T\nPlain Cow 3: A G T T C C A ... T\n```\n\nLooking carefully at this table, he surmises that positions 2 and 4 are sufficient to explain spottiness. That is, by looking at the characters in just these two positions, Farmer John can predict which of his cows are spotty and which are not (for example, if he sees G and C, the cow must be spotty).\n\n\nFarmer John is convinced that spottiness can be explained not by just one or two positions in the genome, but by looking at a set of three distinct positions.  Please help him count the number of sets of three distinct positions that can each explain spottiness.", "inputFormat": "The first line of input contains $N$ ($1 \\leq N \\leq 500$) and $M$ ($3 \\leq M \\leq 50$). The next $N$ lines each contain a string of $M$ characters; these describe the genomes of the spotty cows. The final $N$ lines describe the genomes of the plain cows.\n", "outputFormat": "Please count the number of sets of three distinct positions that can explain spottiness. A set of three positions explains spottiness if the spottiness trait can be predicted with perfect accuracy among Farmer John's population of cows by looking at just those three locations in the genome.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO17OPEN] Bovine Genomics S", "background": "", "description": "Farmer John owns $N$ cows with spots and $N$ cows without spots. Having just completed a course in bovine genetics, he is convinced that the spots on his cows are caused by mutations in the bovine genome.\n\n\nAt great expense, Farmer John sequences the genomes of his cows. Each genome is a string of length $M$ built from the four characters A, C, G, and T. When he lines up the genomes of his cows, he gets a table like the following, shown here\n\n\nfor $N=3$:\n\n\n```cpp\nPositions: 1 2 3 4 5 6 7 ... M\n\nSpotty Cow 1: A A T C C C A ... T\nSpotty Cow 2: G A T T G C A ... A\nSpotty Cow 3: G G T C G C A ... A\n\nPlain Cow 1: A C T C C C A ... G\nPlain Cow 2: A G T T G C A ... T\nPlain Cow 3: A G T T C C A ... T\n```\n\nLooking carefully at this table, he surmises that positions 2 and 4 are sufficient to explain spottiness. That is, by looking at the characters in just these two positions, Farmer John can predict which of his cows are spotty and which are not (for example, if he sees G and C, the cow must be spotty).\n\n\nFarmer John is convinced that spottiness can be explained not by just one or two positions in the genome, but by looking at a set of three distinct positions.  Please help him count the number of sets of three distinct positions that can each explain spottiness.", "inputFormat": "The first line of input contains $N$ ($1 \\leq N \\leq 500$) and $M$ ($3 \\leq M \\leq 50$). The next $N$ lines each contain a string of $M$ characters; these describe the genomes of the spotty cows. The final $N$ lines describe the genomes of the plain cows.\n", "outputFormat": "Please count the number of sets of three distinct positions that can explain spottiness. A set of three positions explains spottiness if the spottiness trait can be predicted with perfect accuracy among Farmer John's population of cows by looking at just those three locations in the genome.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO17OPEN] Bovine Genomics S", "background": "", "description": "Farmer John 拥有 $N$ 头有斑点的牛和 $N$ 头没有斑点的牛。他刚刚完成了一门关于牛遗传学的课程，并确信他牛身上的斑点是由牛基因组中的突变引起的。\n\nFarmer John 花费巨资对他的牛进行了基因组测序。每个基因组是一个由字符 A、C、G 和 T 组成的长度为 $M$ 的字符串。当他将牛的基因组排列起来时，会得到如下表格，这里展示的是 $N=3$ 的情况：\n\n```\n位置：1 2 3 4 5 6 7 ... M\n\n斑点牛 1：A A T C C C A ... T  \n斑点牛 2：G A T T G C A ... A  \n斑点牛 3：G G T C G C A ... A  \n\n普通牛 1：A C T C C C A ... G  \n普通牛 2：A G T T G C A ... T  \n普通牛 3：A G T T C C A ... T \n```\n\n仔细观察这个表格后，他推测位置 2 和 4 足以解释斑点现象。也就是说，通过仅查看这两个位置的字符，Farmer John 可以预测哪些牛是有斑点的，哪些是没有斑点的（例如，如果他看到 G 和 C，这头牛一定是有斑点的）。\n\nFarmer John 确信，斑点现象不仅仅可以通过基因组中的一个或两个位置来解释，而是可以通过查看三个不同的位置来解释。请帮助他计算能够解释斑点现象的三个不同位置集合的数量。", "inputFormat": "输入的第一行包含 $N$（$1 \\leq N \\leq 500$）和 $M$（$3 \\leq M \\leq 50$）。接下来的 $N$ 行每行包含一个长度为 $M$ 的字符串，这些字符串描述了斑点牛的基因组。最后的 $N$ 行描述了普通牛的基因组。", "outputFormat": "请计算能够解释斑点现象的三个不同位置集合的数量。如果通过查看基因组中这三个位置的字符，可以在 Farmer John 的牛群中完美准确地预测斑点性状，那么这个三个位置的集合就解释了斑点现象。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3671", "type": "P", "difficulty": 4, "samples": [["4\nABBC\nBBBC\nAABB\nABBC", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2017", "USACO", "枚举", "连通块"], "title": "[USACO17OPEN] Where's Bessie? S", "background": "", "description": "Always known for being quite tech-savy, Farmer John is testing out his new automated drone-mounted cow locator camera, which supposedly can take a picture of his field and automatically figure out the location of cows. Unfortunately, the camera does not include a very good algorithm for finding cows, so FJ needs your help developing a better one.\n\n\nThe overhead image of his farm taken by the camera is described by an $N \\times N$ grid of characters, each in the range $A \\ldots Z$, representing one of 26 possible colors. Farmer John figures the best way to define a potential cow location (PCL) is as follows: A PCL is a rectangular sub-grid (possibly the entire image) with sides parallel to the image sides, not contained within any other PCL (so no smaller subset of a PCL is also a PCL).  Furthermore, a PCL must satisfy the following property: focusing on just the contents of the rectangle and ignoring the rest of the image, exactly two colors must be present, one forming a contiguous region and one forming two or more contiguous regions.\n\n\n\n```cpp\nAAAAA\nABABA\nAAABB\n```\n\n\n\nFor example, a rectangle with contents would constitute a PCL, since the A's form a single contiguous region and the B's form more than one contiguous region. The interpretation is a cow of color A with spots of color B. \n\nA region is \"contiguous\" if you can traverse the entire region by moving repeatedly from one cell in the region to another cell in the region taking steps up, down, left, or right. \n\nGiven the image returned by FJ's camera, please count the number of PCLs.\n", "inputFormat": "The first line of input contains $N$, the size of the grid ($1 \\leq N \\leq 20$).\n\nThe next $N$ lines describe the image, each consisting of $N$ characters.\n", "outputFormat": "Print a count of the number of PCLs in the image.\n", "hint": "In this example, the two PCLs are the rectangles with contents\n\n```cpp\nABB\nBBB\nAAB\nABB\n```\n\n\nand\n\n```\nBC\nBC\nBB\nBC\n```", "locale": "en", "translations": {"en": {"title": "[USACO17OPEN] Where's Bessie? S", "background": "", "description": "Always known for being quite tech-savy, Farmer John is testing out his new automated drone-mounted cow locator camera, which supposedly can take a picture of his field and automatically figure out the location of cows. Unfortunately, the camera does not include a very good algorithm for finding cows, so FJ needs your help developing a better one.\n\n\nThe overhead image of his farm taken by the camera is described by an $N \\times N$ grid of characters, each in the range $A \\ldots Z$, representing one of 26 possible colors. Farmer John figures the best way to define a potential cow location (PCL) is as follows: A PCL is a rectangular sub-grid (possibly the entire image) with sides parallel to the image sides, not contained within any other PCL (so no smaller subset of a PCL is also a PCL).  Furthermore, a PCL must satisfy the following property: focusing on just the contents of the rectangle and ignoring the rest of the image, exactly two colors must be present, one forming a contiguous region and one forming two or more contiguous regions.\n\n\n\n```cpp\nAAAAA\nABABA\nAAABB\n```\n\n\n\nFor example, a rectangle with contents would constitute a PCL, since the A's form a single contiguous region and the B's form more than one contiguous region. The interpretation is a cow of color A with spots of color B. \n\nA region is \"contiguous\" if you can traverse the entire region by moving repeatedly from one cell in the region to another cell in the region taking steps up, down, left, or right. \n\nGiven the image returned by FJ's camera, please count the number of PCLs.\n", "inputFormat": "The first line of input contains $N$, the size of the grid ($1 \\leq N \\leq 20$).\n\nThe next $N$ lines describe the image, each consisting of $N$ characters.\n", "outputFormat": "Print a count of the number of PCLs in the image.\n", "hint": "In this example, the two PCLs are the rectangles with contents\n\n```cpp\nABB\nBBB\nAAB\nABB\n```\n\n\nand\n\n```\nBC\nBC\nBB\nBC\n```", "locale": "en"}, "zh-CN": {"title": "[USACO17OPEN] Where's Bessie? S", "background": "", "description": "Farmer John 一直以精通技术而闻名，他正在测试他的新型无人机搭载的奶牛定位相机。这款相机据说可以拍摄他的田地并自动确定奶牛的位置。不幸的是，相机的算法并不擅长寻找奶牛，因此 Farmer John 需要你的帮助来开发一个更好的算法。\n\n相机拍摄的农场俯视图由一个 $N \\times N$ 的字符网格描述，每个字符在 $A \\ldots Z$ 范围内，代表 26 种可能的颜色之一。Farmer John 认为，定义潜在奶牛位置（PCL）的最佳方式如下：一个 PCL 是一个矩形子网格（可能是整个图像），其边与图像的边平行，并且不包含在任何其他 PCL 中（因此 PCL 的较小子集不能也是 PCL）。此外，PCL 必须满足以下属性：仅关注矩形内的内容并忽略图像的其余部分，必须恰好存在两种颜色，其中一种颜色形成一个连续区域，另一种颜色形成两个或更多连续区域。\n\n例如，一个矩形的内容如下：\n\n```\nAAAAA  \nABABA  \nAAABB  \n```\n\n这将构成一个 PCL，因为 A 形成一个连续区域，而 B 形成多个连续区域。解释为一只颜色为 A 的奶牛带有颜色为 B 的斑点。\n\n一个区域是“连续的”，如果可以通过向上、向下、向左或向右移动，从一个区域中的单元格反复移动到另一个区域中的单元格来遍历整个区域。\n\n给定 Farmer John 的相机返回的图像，请计算 PCL 的数量。", "inputFormat": "输入的第一行包含 $N$，表示网格的大小（$1 \\leq N \\leq 20$）。\n\n接下来的 $N$ 行描述图像，每行包含 $N$ 个字符。", "outputFormat": "输出图像中 PCL 的数量。", "hint": "在这个例子中，两个 PCL 分别是内容如下的矩形：\n\n```\nABB  \nBBB  \nAAB  \nABB\n```\n\n和\n\n```\nBC  \nBC  \nBB  \nBC  \n```", "locale": "zh-CN"}}}
{"pid": "P3672", "type": "P", "difficulty": 5, "samples": [["3 2 2", "3 1 2"], ["10 6 4", "1 2 3 4 5 7 6 10 9 8"], ["50 233 233", "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 32 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 33 35 34 31 30 29 28"], ["50 233333333 333", "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 43 49 50 47 46 45 48 44 41 42 40 39 37 38 36 35 34 33 32 30 29 31 28 25 26 27 24"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "洛谷原创", "O2优化", "枚举", "前缀和", "洛谷月赛"], "title": "小清新签到题", "background": "", "description": "题目还是简单一点好。\n\n给定自然数 $n$、$k$、$x$，你要求出第 $k$ 小的长度为 $n$ 的逆序对对数为 $x$ 的 $1\\sim n$ 的排列 $a_1,a_2 ... a_n$ ~~，然后用仙人图上在线分支定界启发式带花树上下界最小费用流解决问题~~，保证存在。\n\n注：逆序对为满足 $i<j$、$a_i>a_j$ 的 $(i,j)$。比较为字典序比较，即比较从前往后第一个不同的位置。第 $k$ 小从 $1$ 开始标号。一个 $1\\sim n$ 的排列定义为一个长度为 $n$ 的数列，排序完可以得到 $1\\sim n$。\n", "inputFormat": "一行三个自然数 $n$、$k$、$x$。\n", "outputFormat": "输出满足条件的排列，一行n个数，用空格分隔。\n", "hint": "对于 $10\\%$ 的数据，$n \\leq 8$。\n\n对于 $30\\%$ 的数据，$n \\leq 10$。\n\n对于 $50\\%$ 的数据，$n \\leq 50$。\n\n对于另外 $20\\%$ 的数据，$k=1$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 300$，$1 \\leq k \\leq 10^{13}$，保证存在符合题意的排列。\n", "locale": "zh-CN", "translations": {"en": {"title": "A Simple Sign-in Problem", "background": "", "description": "Let's keep the problem simple.\n\nGiven natural numbers $n$, $k$, $x$, you are required to find the $k$-th smallest permutation $a_1,a_2 ... a_n$ of $1\\sim n$ of length $n$ whose number of inversions is $x$ ~~and then solve the problem using an on-cactus online branch-and-bound heuristic blossom-tree min-cost flow with bounds~~, and it is guaranteed to exist.\n\nNote: An inversion is a pair $(i,j)$ such that $i<j$ and $a_i>a_j$. The comparison is lexicographical, i.e., compare from left to right at the first position where they differ. The $k$-th smallest is 1-indexed. A permutation of $1\\sim n$ is defined as a length-$n$ sequence that, after sorting, becomes $1\\sim n$.", "inputFormat": "One line with three natural numbers $n$, $k$, $x$.", "outputFormat": "Output a permutation that satisfies the conditions: one line with $n$ numbers, separated by spaces.", "hint": "For $10\\%$ of the testdata, $n \\leq 8$.\n\nFor $30\\%$ of the testdata, $n \\leq 10$.\n\nFor $50\\%$ of the testdata, $n \\leq 50$.\n\nFor an additional $20\\%$ of the testdata, $k=1$.\n\nFor $100\\%$ of the testdata, $1 \\leq n \\leq 300$, $1 \\leq k \\leq 10^{13}$, and a valid permutation is guaranteed to exist.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小清新签到题", "background": "", "description": "题目还是简单一点好。\n\n给定自然数 $n$、$k$、$x$，你要求出第 $k$ 小的长度为 $n$ 的逆序对对数为 $x$ 的 $1\\sim n$ 的排列 $a_1,a_2 ... a_n$ ~~，然后用仙人图上在线分支定界启发式带花树上下界最小费用流解决问题~~，保证存在。\n\n注：逆序对为满足 $i<j$、$a_i>a_j$ 的 $(i,j)$。比较为字典序比较，即比较从前往后第一个不同的位置。第 $k$ 小从 $1$ 开始标号。一个 $1\\sim n$ 的排列定义为一个长度为 $n$ 的数列，排序完可以得到 $1\\sim n$。\n", "inputFormat": "一行三个自然数 $n$、$k$、$x$。\n", "outputFormat": "输出满足条件的排列，一行n个数，用空格分隔。\n", "hint": "对于 $10\\%$ 的数据，$n \\leq 8$。\n\n对于 $30\\%$ 的数据，$n \\leq 10$。\n\n对于 $50\\%$ 的数据，$n \\leq 50$。\n\n对于另外 $20\\%$ 的数据，$k=1$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 300$，$1 \\leq k \\leq 10^{13}$，保证存在符合题意的排列。\n", "locale": "zh-CN"}}}
{"pid": "P3673", "type": "P", "difficulty": 6, "samples": [["01", "1"], ["10101", "1154"], ["10101101010111110100110100101010110001010010101001", "322173207"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创", "O2优化", "枚举", "生成树", "基环树", "洛谷月赛"], "title": "小清新计数题", "background": null, "description": "小 A 正在电脑上玩一个叫做 Truth or Lie 的游戏。\n\n游戏开始时电脑会给出 $n$ 句话，每句话形如“第 $x$ 句话为真”或“第 $x$ 句话为假”，其中 $x$ 是一个 $1$ 到 $n$ 的整数，你只要选择“Good”或者“Bad”，“Good”表示可以决定每句话的真假使每句话的内容都成立，“Bad”反之。\n\n作为一个菜鸡，小 A 只会不停地点“Good”，靠脸过关。\n\n在无数次失败后，非洲人小 A 发现游戏每关中，每句话包含的是“真”还是“假”是固定的，但是每句话中的 $x$ 是在 $1$ 到 $n$ 均匀随机的。\n\n现在小 A 告诉了你某一关每句话的真假，用一个 $01$ 序列表示。第 $i$ 位为 $0$ 表示第 $i$ 句话包含“假”，否则表示包含“真”。现在他想要知道使得点击“Good”正确的方案数。\n\n由于方案数可能比较大，你需要输出方案数对 $998244353$ 取模的结果。\n\n（读不懂题的请移步样例解释）", "inputFormat": "一行一个 $01$ 序列，它的长度即为 $n$。", "outputFormat": "输出方案数对 $998244353$ 取模的结果。", "hint": "### 样例解释\n\n第一句话的内容为“某句话为假”，第二句话的内容为“某句话为真”。所有可能情况如下：\n\n1. 第一句话的内容为“第一句话为假”，第二句话的内容为“第一句话为真”，结果应为 Bad。\n\n2. 第一句话的内容为“第一句话为假”，第二句话的内容为“第二句话为真”，结果应为 Bad。\n\n3. 第一句话的内容为“第二句话为假”，第二句话的内容为“第一句话为真”，结果应为 Bad。\n\n4. 第一句话的内容为“第二句话为假”，第二句话的内容为“第二句话为真”，结果应为 Good，因为只需认为第一句话为假，第二句话为真就符合两句话，所以是 Good。\n\n所以共有一种合法方案。\n\n### 数据范围\n\n- 对于 $10\\%$ 的数据，$n \\leq 7$；\n- 对于 $20\\%$ 的数据，$n \\leq 9$；\n- 对于 $60\\%$ 的数据，$n \\leq 20$；\n- 对于 $100\\%$ 的数据，$1 \\leq n \\leq 50$。", "locale": "zh-CN", "translations": {"en": {"title": "A Fresh Counting Problem", "background": "", "description": "Xiao A is playing a game on the computer called Truth or Lie.\n\nAt the start of the game, the computer gives $n$ sentences. Each sentence is of the form “Statement $x$ is true” or “Statement $x$ is false,” where $x$ is an integer from $1$ to $n$. You only need to choose either \"Good\" or \"Bad.\" \"Good\" means that you can determine the truth value of each statement so that the content of every sentence holds. \"Bad\" means the opposite.\n\nAs a newbie, Xiao A keeps clicking \"Good\" and hopes to pass by luck.\n\nAfter countless failures, Xiao A discovers that in each level, whether a sentence contains the word “true” or “false” is fixed, but the $x$ in each sentence is chosen uniformly at random from $1$ to $n$.\n\nNow Xiao A tells you, for a certain level, which word each sentence contains, represented by a $01$ sequence. The $i$-th bit being $0$ means the $i$-th sentence contains “false,” otherwise it contains “true.” He wants to know the number of assignments of the $x$’s that make clicking \"Good\" correct.\n\nSince the number of valid assignments may be large, you need to output the result modulo $998244353$.\n\n(If you do not understand the problem, please refer to the sample explanation.)", "inputFormat": "A single line containing a $01$ sequence, whose length is $n$.", "outputFormat": "Output the number of valid assignments modulo $998244353$.", "hint": "### Sample Explanation\n\nThe first sentence says “Some statement is false,” and the second sentence says “Some statement is true.” All possible cases are as follows:\n\n1. The first sentence says “Statement 1 is false,” the second says “Statement 1 is true.” The result should be Bad.\n2. The first sentence says “Statement 1 is false,” the second says “Statement 2 is true.” The result should be Bad.\n3. The first sentence says “Statement 2 is false,” the second says “Statement 1 is true.” The result should be Bad.\n4. The first sentence says “Statement 2 is false,” the second says “Statement 2 is true.” The result should be Good, because setting the first statement to false and the second statement to true satisfies both sentences, so it is Good.\n\nTherefore, there is exactly one valid assignment.\n\n### Constraints\n\n- For $10\\%$ of the testdata, $n \\leq 7$.\n- For $20\\%$ of the testdata, $n \\leq 9$.\n- For $60\\%$ of the testdata, $n \\leq 20$.\n- For $100\\%$ of the testdata, $1 \\leq n \\leq 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小清新计数题", "background": null, "description": "小 A 正在电脑上玩一个叫做 Truth or Lie 的游戏。\n\n游戏开始时电脑会给出 $n$ 句话，每句话形如“第 $x$ 句话为真”或“第 $x$ 句话为假”，其中 $x$ 是一个 $1$ 到 $n$ 的整数，你只要选择“Good”或者“Bad”，“Good”表示可以决定每句话的真假使每句话的内容都成立，“Bad”反之。\n\n作为一个菜鸡，小 A 只会不停地点“Good”，靠脸过关。\n\n在无数次失败后，非洲人小 A 发现游戏每关中，每句话包含的是“真”还是“假”是固定的，但是每句话中的 $x$ 是在 $1$ 到 $n$ 均匀随机的。\n\n现在小 A 告诉了你某一关每句话的真假，用一个 $01$ 序列表示。第 $i$ 位为 $0$ 表示第 $i$ 句话包含“假”，否则表示包含“真”。现在他想要知道使得点击“Good”正确的方案数。\n\n由于方案数可能比较大，你需要输出方案数对 $998244353$ 取模的结果。\n\n（读不懂题的请移步样例解释）", "inputFormat": "一行一个 $01$ 序列，它的长度即为 $n$。", "outputFormat": "输出方案数对 $998244353$ 取模的结果。", "hint": "### 样例解释\n\n第一句话的内容为“某句话为假”，第二句话的内容为“某句话为真”。所有可能情况如下：\n\n1. 第一句话的内容为“第一句话为假”，第二句话的内容为“第一句话为真”，结果应为 Bad。\n\n2. 第一句话的内容为“第一句话为假”，第二句话的内容为“第二句话为真”，结果应为 Bad。\n\n3. 第一句话的内容为“第二句话为假”，第二句话的内容为“第一句话为真”，结果应为 Bad。\n\n4. 第一句话的内容为“第二句话为假”，第二句话的内容为“第二句话为真”，结果应为 Good，因为只需认为第一句话为假，第二句话为真就符合两句话，所以是 Good。\n\n所以共有一种合法方案。\n\n### 数据范围\n\n- 对于 $10\\%$ 的数据，$n \\leq 7$；\n- 对于 $20\\%$ 的数据，$n \\leq 9$；\n- 对于 $60\\%$ 的数据，$n \\leq 20$；\n- 对于 $100\\%$ 的数据，$1 \\leq n \\leq 50$。", "locale": "zh-CN"}}}
{"pid": "P3674", "type": "P", "difficulty": 6, "samples": [["10 10\n1 1 8 9 9 1 1 1 1 9 \n3 5 9 42\n2 1 3 14\n2 3 5 2\n2 3 3 6\n1 6 10 18\n3 4 9 14\n2 1 4 22\n3 1 3 32\n2 5 6 32\n3 1 9 17", "bi\nbi\nbi\nbi\nbi\nbi\nbi\nbi\nbi\nbi\n"], ["5 5\n1 1 2 3 4\n2 1 1 2\n1 1 2 2\n3 1 1 1\n3 5 5 16\n1 2 3 4", "hana\nbi\nhana\nhana\nbi"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["莫队", "洛谷原创", "O2优化", "枚举", "洛谷月赛", "bitset"], "title": "小清新人渣的本愿", "background": "**本题时限3s，空间128MB**\n\n我感觉我要挂省选\n\n人渣的本愿是一个有趣的番\n\n可爱的花火喜欢从小和她谈♂笑♂风♂生的欧♂尼♂酱鸣海，欧尼酱特别想当老师，然后剧本安排当了花火的班主任。\n\n然而有个叫做皆川茜的奇怪的人抢走了欧尼酱！\n\n花火就很失落呀，然后看到一个叫做麦的人也很失落，原来麦喜欢茜老师。。。\n\n花火和麦从此天天谈笑风生，然后决定在一起，把对方当做自己喜欢的人的替代品\n\n因为花火很可爱，所以有许多奇怪的人喜欢花火，比如一个叫做绘鸠早苗的妹子\n\n因为麦长的也不错，所以有许多奇怪的人喜欢麦，比如一个叫做最可的妹子\n\n然后就开始愉快的生♂活了~\n\n以上内容如果你没有看过这个番可以无视掉\n\n\n按照套路，现在欧尼酱会问花火一个OI问题（一般是数据结构），然后花火肯定不会OI，所以会来请教您这位IOI Au选手，然后您肯定会帮助她\n\n但是\n这个套路太无聊了，我们来换一个（但是不会改变您是IOI Au选手的事实）\n\n花火有一天看了几个有趣的番，叫做“在W??身上寻找女装是否搞错了什么”，“从女装开始的?X?”，“我家大佬不可能那么可爱”，然后发现??H太厉害了，然后就穿越到了异世界，和???谈笑风生\n\n花火就和???做了一个交♂易，花火帮???做一道题，然后???帮花火改写地球online的程序，让花火和欧尼酱在♂一♂起\n\n???虽然非常厉害，但是不会数据结构题，他最近刚刚遇到一道有趣的数据结构题，于是他接受了交易\n\n但是花火也不会数据结构题呀\n\n所以又回到了这个老套路，就靠您这个IOI Au选手来帮她了！\n\n以上内容如果你没有看过这个番还是可以无视掉\n\n这里用一个经典的图来解释这个关系（其实没那么蛋疼的）\n\n![](https://cdn.luogu.com.cn/upload/pic/4628.png)", "description": "这个题是这样的：\n\n给你一个序列 $a$，长度为 $n$，有 $m$ 次操作，每次询问一个区间是否可以选出两个数它们的差为 $x$，或者询问一个区间是否可以选出两个数它们的和为 $x$，或者询问一个区间是否可以选出两个数它们的乘积为 $x$ ，这三个操作分别为操作 $1,2,3$。\n\n选出的这两个数可以是同一个位置的数。\n\n![](https://cdn.luogu.com.cn/upload/pic/4629.png)", "inputFormat": "第一行两个数 $n,m$。\n\n后面一行 $n$ 个数表示 $a_i$。\n\n后面 $m$ 行每行四个数 `opt l r x`。\n\n$opt$ 表示这个是第几种操作，$l,r$ 表示操作的区间，$x$ 表示这次操作的 $x$。", "outputFormat": "对于每个询问，如果可以，输出 `hana`，否则输出 `bi`。", "hint": "定义 $c$ 为每次的 $x$ 和 $a_i$ 中的最大值，$a_i \\geq 0$，每次的 $x\\geq 0$。\n\n对于 $10\\%$ 的数据，$n,m,c \\leq 100$。\n\n对于另外 $10\\%$ 的数据，$n,m,c \\leq 3\\times 10^3$。\n\n对于另外 $10\\%$ 的数据，只有 $1$ 操作。\n\n对于另外 $10\\%$ 的数据，只有 $2$ 操作。\n \n对于另外 $10\\%$ 的数据，只有 $3$ 操作。\n\n对于 $100\\%$ 的数据，$n,m,c \\leq 10^5$。\n\n![](https://cdn.luogu.com.cn/upload/pic/4630.png)", "locale": "zh-CN", "translations": {"en": {"title": "A Fresh Newbie's Scum's Wish", "background": "Time limit 3 s, memory 128 MB.\n\nI feel I am going to fail the NOI Qualifier.\n\nScum's Wish is an interesting anime.\n\nThe cute Hanabi likes her onii-chan Narumi, who has chatted and joked with her since childhood. Onii-chan really wants to be a teacher, and as the plot goes, he becomes Hanabi’s homeroom teacher.\n\nHowever, someone strange named Akane Minagawa steals onii-chan away!\n\nHanabi feels very down, and then she sees someone named Mugi also feeling down. It turns out Mugi likes Teacher Akane.\n\nFrom then on, Hanabi and Mugi chat and joke every day and decide to be together, treating each other as substitutes for the people they actually like.\n\nBecause Hanabi is very cute, many strange people like her, such as a girl named Sanae Ebato.\n\nBecause Mugi also looks good, many strange people like him, such as a girl named Most Kawaii.\n\nAnd then their cheerful life begins.\n\nIf you haven’t watched this anime, you can ignore the above.\n\nFollowing the usual trope, now onii-chan would ask Hanabi an OI problem (usually data structures). Hanabi definitely doesn’t do OI, so she comes to ask you, an IOI Au contestant, and you will surely help her.\n\nBut this trope is too boring, so let’s change it (without changing the fact that you are an IOI Au contestant).\n\nOne day Hanabi watched a few interesting anime called “Is It Wrong to Look for Crossdressing on W??,” “Starting from Crossdressing, ?X?,” and “My Big Boss Can’t Possibly Be This Cute,” and then discovered ??H is amazing. She then traveled to another world and bantered with ???.\n\nHanabi made a deal with ???: Hanabi helps ??? solve a problem, and ??? helps Hanabi rewrite the program of Earth Online so Hanabi and onii-chan can be together.\n\nAlthough ??? is very powerful, he doesn’t know data structure problems. He recently encountered an interesting data structure problem, so he accepted the deal.\n\nBut Hanabi also doesn’t know data structure problems.\n\nSo we’re back to the old trope—she relies on you, the IOI Au contestant, to help her!\n\nIf you haven’t watched these anime, you can still ignore the above.\n\nHere is a classic diagram to explain this relationship (it’s actually not that silly).\n\n![](https://cdn.luogu.com.cn/upload/pic/4628.png)", "description": "The problem is as follows:\n\nYou are given a sequence $a$ of length $n$, with $m$ operations. Each operation asks whether, in a given interval, you can choose two numbers whose difference equals $x$, or two numbers whose sum equals $x$, or two numbers whose product equals $x$. These three operations correspond to operations $1, 2, 3$, respectively.\n\nThe two chosen numbers may come from the same position.\n\n![](https://cdn.luogu.com.cn/upload/pic/4629.png)", "inputFormat": "The first line contains two numbers $n, m$.\n\nThe second line contains $n$ numbers representing $a_i$.\n\nEach of the next $m$ lines contains four numbers `opt l r x`.\n\n$opt$ indicates which operation it is, $l, r$ specify the interval, and $x$ is the value for this operation.", "outputFormat": "For each query, if it is possible, output `hana`; otherwise, output `bi`.", "hint": "Define $c$ as the maximum of each $x$ and all $a_i$. Assume $a_i \\geq 0$ and each $x \\geq 0$.\n\nFor $10\\%$ of the testdata, $n, m, c \\leq 100$.\n\nFor another $10\\%$ of the testdata, $n, m, c \\leq 3 \\times 10^3$.\n\nFor another $10\\%$ of the testdata, only operation $1$ appears.\n\nFor another $10\\%$ of the testdata, only operation $2$ appears.\n\nFor another $10\\%$ of the testdata, only operation $3$ appears.\n\nFor $100\\%$ of the testdata, $n, m, c \\leq 10^5$.\n\n![](https://cdn.luogu.com.cn/upload/pic/4630.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小清新人渣的本愿", "background": "**本题时限3s，空间128MB**\n\n我感觉我要挂省选\n\n人渣的本愿是一个有趣的番\n\n可爱的花火喜欢从小和她谈♂笑♂风♂生的欧♂尼♂酱鸣海，欧尼酱特别想当老师，然后剧本安排当了花火的班主任。\n\n然而有个叫做皆川茜的奇怪的人抢走了欧尼酱！\n\n花火就很失落呀，然后看到一个叫做麦的人也很失落，原来麦喜欢茜老师。。。\n\n花火和麦从此天天谈笑风生，然后决定在一起，把对方当做自己喜欢的人的替代品\n\n因为花火很可爱，所以有许多奇怪的人喜欢花火，比如一个叫做绘鸠早苗的妹子\n\n因为麦长的也不错，所以有许多奇怪的人喜欢麦，比如一个叫做最可的妹子\n\n然后就开始愉快的生♂活了~\n\n以上内容如果你没有看过这个番可以无视掉\n\n\n按照套路，现在欧尼酱会问花火一个OI问题（一般是数据结构），然后花火肯定不会OI，所以会来请教您这位IOI Au选手，然后您肯定会帮助她\n\n但是\n这个套路太无聊了，我们来换一个（但是不会改变您是IOI Au选手的事实）\n\n花火有一天看了几个有趣的番，叫做“在W??身上寻找女装是否搞错了什么”，“从女装开始的?X?”，“我家大佬不可能那么可爱”，然后发现??H太厉害了，然后就穿越到了异世界，和???谈笑风生\n\n花火就和???做了一个交♂易，花火帮???做一道题，然后???帮花火改写地球online的程序，让花火和欧尼酱在♂一♂起\n\n???虽然非常厉害，但是不会数据结构题，他最近刚刚遇到一道有趣的数据结构题，于是他接受了交易\n\n但是花火也不会数据结构题呀\n\n所以又回到了这个老套路，就靠您这个IOI Au选手来帮她了！\n\n以上内容如果你没有看过这个番还是可以无视掉\n\n这里用一个经典的图来解释这个关系（其实没那么蛋疼的）\n\n![](https://cdn.luogu.com.cn/upload/pic/4628.png)", "description": "这个题是这样的：\n\n给你一个序列 $a$，长度为 $n$，有 $m$ 次操作，每次询问一个区间是否可以选出两个数它们的差为 $x$，或者询问一个区间是否可以选出两个数它们的和为 $x$，或者询问一个区间是否可以选出两个数它们的乘积为 $x$ ，这三个操作分别为操作 $1,2,3$。\n\n选出的这两个数可以是同一个位置的数。\n\n![](https://cdn.luogu.com.cn/upload/pic/4629.png)", "inputFormat": "第一行两个数 $n,m$。\n\n后面一行 $n$ 个数表示 $a_i$。\n\n后面 $m$ 行每行四个数 `opt l r x`。\n\n$opt$ 表示这个是第几种操作，$l,r$ 表示操作的区间，$x$ 表示这次操作的 $x$。", "outputFormat": "对于每个询问，如果可以，输出 `hana`，否则输出 `bi`。", "hint": "定义 $c$ 为每次的 $x$ 和 $a_i$ 中的最大值，$a_i \\geq 0$，每次的 $x\\geq 0$。\n\n对于 $10\\%$ 的数据，$n,m,c \\leq 100$。\n\n对于另外 $10\\%$ 的数据，$n,m,c \\leq 3\\times 10^3$。\n\n对于另外 $10\\%$ 的数据，只有 $1$ 操作。\n\n对于另外 $10\\%$ 的数据，只有 $2$ 操作。\n \n对于另外 $10\\%$ 的数据，只有 $3$ 操作。\n\n对于 $100\\%$ 的数据，$n,m,c \\leq 10^5$。\n\n![](https://cdn.luogu.com.cn/upload/pic/4630.png)", "locale": "zh-CN"}}}
{"pid": "P3675", "type": "P", "difficulty": 0, "samples": [["4 233 1 1 2\n3 3 1 1\n5 2 1 -1", "m 1\ng 45\n（仅为一种可能输出）"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创", "提交答案", "Special Judge", "模拟退火", "遗传算法", "背包 DP", "洛谷月赛"], "title": "小清新提交答案题", "background": null, "description": "这是一道提交答案题。\n\n\n相信大家都玩过黄金矿工这款游戏吧！不过如果没有玩过建议**赛后**再玩。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4469.png) \n\n这道题与原游戏**有一些不同**，请仔细阅读规则。\n\n\n将矿区抽象为一个 $2s \\times s$ 的矩形，以左上角作为坐标原点，向右为 $x$ 轴正方向，向下为 $y$ 轴正方向，建立平面直角坐标系。\n\n\n矿工开始在 $(s,0)$，矿工可以在 $x$ 轴一部分：原点与 $(2s,0)$ 的连线（线段）上随意移动。\n\n\n把矿区中的黄金等物品抽象为坐标系中此矩形内一个个不相交的圆，每个圆有一个价值，可正可负。\n\n\n这里我们将抓取的过程抽象为以矿工为一端射出一条射线，如果不与任何圆相交（相切不算），那么这次抓取是无效的；否则矿工将会抓取到相交的圆中最早碰到的一个（较近的交点与矿工距离最近的一个圆）。\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s966cayn.png)\n\n\n黄金矿工这款游戏的目的是在规定时间上抓取价值尽量高的物品。\n\n\n移动与抓取都需要时间，移动 $1$ 单位距离需要花费 $k_1$ 的时间，将一次有效抓取的距离定义为抓取到的圆与射线较近的交点与矿工的距离，有效抓取每 $1$ 单位距离需要花费 $k_2$ 的时间（无效抓取将会被忽略）。\n\n\n你将要操纵这位矿工，给出移动和抓取指令，使得获取的价值尽量大。如果某次操作后你所用的总时间超过了规定时限，这次及以后操作将会被忽略。详细格式可见输出描述。\n\n\n**由于矿工比较懒，矿工只接受 $2n$ 次操作（$n$ 为圆的个数，无论是否是无效抓取），多余操作将被忽略。**\n\n\n判定时的 eps 为 $10^{-7}$。若你射出的射线与圆两交点的距离不超过该 eps，那么将不会判定为相交。若你的用时与时限的差不超过 eps，那么也不会被判定为超过时限。\n\n\n由于这是提交答案题，我们会提供输入数据、评分参数和 checker 下载，链接在最后。", "inputFormat": "第一行五个数 $s,t,k_1,k_2,n$，$s,k_1,k_2$ 的含义见题面，$t$ 为规定时限，$n$ 为圆的个数。\n\n\n以下 $n$ 行每行四个数 $x_i,y_i,r_i,v_i$，分别表示编号为 $i$ 的圆圆心 $x$ 坐标、圆心 $y$ 坐标、半径和价值。\n\n\n$n$ 和 $v_i$ 一定为整数，其余量可能为实数。", "outputFormat": "若干行，表示你的操作。\n\n\n每行开头一个字符为 `m` 或 `g`，然后一个空格。（`m`：move，`g`：grab）\n\n\n如果字符是 `m`，接下来应该接一个实数 $p(0 \\leq p \\leq 2s)$，表示将矿工移动到 $(p,0)$。\n\n\n如果字符是 `g`，接下来应该接一个实数 $a(0.2 \\leq a \\leq 179.8)$，表示抓取的射线与 $x$ 轴正方向夹角为 $a^{\\circ}$。\n\n\n**这两个实数建议保留 $10$ 位小数。**\n\n\n超过时限和超过 $2n$ 次的操作将被忽略。如果在输出文件中包含不合法信息该点可能会直接被判为 $0$ 分。", "hint": "#### 样例解释\n\n\n开始矿工在 $(4,0)$，移动到 $(1,0)$，花费 $3$ 时间。\n\n\n如图，矿工发射出一条射线，抓取到第一个圆，获取到 $1$ 价值，花费 $2\\sqrt{2}$ 时间。\n\n\n当然这不是花费时间最小的解，存在其他解。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4318.png) \n\n#### 评分标准\n\n\n对于每个点，如果你的输出不符合输出格式，得 $0$ 分。\n\n\n否则，假设你获得的价值为 $a$，每个点有三个评分参数，标准答案 $b$、一个实数 $w$、一个 $0$ 或 $1$ 的整数 $f$。\n\n\n若 $a<0$ ，你将获得 $0$ 分。\n\n\n若 $a>b$，你将获得 $10+f$ 分（这意味着部分点你可能会获得 $11$ 分）。\n\n\n否则你将获得 $\\lfloor 10(\\frac{a}{b})^w\\rfloor$ 分。（$\\lfloor x \\rfloor$ 表示不大于 $x$ 的最大整数）\n\n\n#### 如何测试和提交\n\n\n下载下发文件（见附件），里面有 mine1.in ~ mine10.in、mine1.ans ~ mine10.ans 和 checker.cpp、checker\\_win32.exe、tester.bat、testlib.h，**in、ans 和 checker.cpp 与洛谷上实际测试使用的完全相同**。windows 以外的系统，可以自行编译 checker.cpp。\n\n\n测试时在同一目录下放置 mine1.out ~ mine10.out，对于 windows 用户，运行 tester.bat，会自动调用 checker\\_win32.exe 返回每个点的结果。对于其它系统的用户，手动调用 `checker mine1.in mine1.out mine1.ans` 即可返回第一个点的评测结果，其它点同理。\n\n\nchecker 会返回形如 `points 0.9 Your ans is aaa, done bbb attempts, time used ccc, ddd remained` 的结果，表示这个点你可以获得 $9$ 分，你得到的价值是 aaa，成功进行了开始 bbb 个操作，用了 ccc 的时间，剩下 ddd 的时间。如果剩下的时间为负，表示最后一个（没有成功执行的）操作超时了。\n\n\n提交时可以直接将 mine1.out ~ mine10.out 打包上传，一个一个点输入提交亦可。", "locale": "zh-CN", "translations": {"en": {"title": "A \"Xiao Qingxin\" Output-Only Problem", "background": "", "description": "This is an output-only problem.\n\nI believe most of you have played the game Gold Miner. If you have not, it is recommended to try it after the contest.\n\n![](https://cdn.luogu.com.cn/upload/pic/4469.png)\n\nThis problem is a bit different from the original game. Please read the rules carefully.\n\nAbstract the mining area as a rectangle of size $2s \\times s$. Take the upper-left corner as the origin, the positive $x$-axis to the right, and the positive $y$-axis downward, forming a Cartesian coordinate system.\n\nThe miner starts at $(s, 0)$. The miner can move freely along part of the $x$-axis: the line segment from the origin to $(2s, 0)$.\n\nAbstract gold and other items in the mining area as pairwise disjoint circles within this rectangle, each circle having a value, which may be positive or negative.\n\nWe abstract a grab as shooting a ray with the miner at one end. If the ray does not intersect any circle (tangency does not count), then the grab is invalid; otherwise, the miner will grab the first circle hit along the ray (i.e., the circle whose nearer intersection point with the ray has the smallest distance to the miner).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s966cayn.png)\n\nThe goal of Gold Miner is to grab items with as high a total value as possible within the time limit.\n\nBoth moving and grabbing take time. Moving 1 unit of distance costs $k_1$ time. Define the distance of a successful grab as the distance from the miner to the nearer intersection point between the ray and the grabbed circle; each unit of this distance costs $k_2$ time for a valid grab (invalid grabs are ignored for time cost).\n\nYou will control the miner by issuing move and grab commands to maximize the total value obtained. If after some operation your total time exceeds the time limit, that operation and all subsequent operations will be ignored. See the Output Format for details.\n\nBecause the miner is lazy, he accepts only $2n$ operations ($n$ is the number of circles, regardless of whether grabs are invalid). Extra operations will be ignored.\n\nThe judging eps is $10^{-7}$. If the distance between the two intersection points of your ray and a circle does not exceed this eps, it will not be considered an intersection. If the difference between your time used and the time limit does not exceed eps, it will not be considered as exceeding the time limit.\n\nSince this is an output-only problem, we will provide the input data, scoring parameters, and the checker for download. See the link at the end.", "inputFormat": "The first line contains five numbers $s, t, k_1, k_2, n$. The meanings of $s, k_1, k_2$ are as above; $t$ is the time limit; $n$ is the number of circles.\n\nEach of the next $n$ lines contains four numbers $x_i, y_i, r_i, v_i$, representing the $x$-coordinate of the center, the $y$-coordinate of the center, the radius, and the value of the circle with index $i$.\n\n$n$ and $v_i$ are integers; the other quantities may be real numbers.", "outputFormat": "Several lines, each describing one of your operations.\n\nEach line starts with a character `m` or `g`, followed by a space. (`m`: move, `g`: grab)\n\nIf the character is `m`, it should be followed by a real number $p$ ($0 \\leq p \\leq 2s$), meaning move the miner to $(p, 0)$.\n\nIf the character is `g`, it should be followed by a real number $a$ ($0.2 \\leq a \\leq 179.8$), meaning the grab ray makes an angle of $a^\\circ$ with the positive $x$-axis.\n\nIt is recommended to keep 10 decimal places for these two real numbers.\n\nOperations that exceed the time limit and operations beyond $2n$ will be ignored. If your output file contains illegal information, this test may be judged as 0 points.", "hint": "#### Sample Explanation\n\nThe miner starts at $(4, 0)$, moves to $(1, 0)$, costing time $3$.\n\nAs shown, the miner shoots a ray, grabs the first circle hit, gains value $1$, costing time $2\\sqrt{2}$.\n\nOf course, this is not the minimum-time solution; other solutions exist.\n\n![](https://cdn.luogu.com.cn/upload/pic/4318.png)\n\n#### Scoring\n\nFor each test, if your output does not conform to the output format, you get 0 points.\n\nOtherwise, suppose your total value is $a$. Each test has three scoring parameters: the standard answer $b$, a real number $w$, and an integer $f \\in \\{0, 1\\}$.\n\nIf $a < 0$, you get 0 points.\n\nIf $a > b$, you get $10 + f$ points (this means you may get 11 points on some tests).\n\nOtherwise, you get $\\lfloor 10 (\\frac{a}{b})^w \\rfloor$ points. (Here $\\lfloor x \\rfloor$ is the greatest integer not exceeding $x$.)\n\n#### How to Test and Submit\n\nDownload the provided files (see attachments). They include mine1.in ~ mine10.in, mine1.ans ~ mine10.ans, and checker.cpp, checker_win32.exe, tester.bat, testlib.h. The in, ans, and checker.cpp are exactly the same as those actually used on Luogu. For systems other than Windows, you can compile checker.cpp yourself.\n\nFor testing, put mine1.out ~ mine10.out in the same directory. For Windows users, run tester.bat, which will automatically invoke checker_win32.exe and return the result for each test. For other systems, manually run `checker mine1.in mine1.out mine1.ans` to get the result for the first test; similarly for the others.\n\nThe checker will return a message like `points 0.9 Your ans is aaa, done bbb attempts, time used ccc, ddd remained`, meaning you can get 9 points on this test; your obtained value is aaa; you successfully executed the first bbb operations; time used is ccc; and ddd time remains. If the remaining time is negative, it means the last operation (which did not successfully execute) exceeded the time limit.\n\nWhen submitting, you can directly pack and upload mine1.out ~ mine10.out, or submit outputs for each test one by one.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小清新提交答案题", "background": null, "description": "这是一道提交答案题。\n\n\n相信大家都玩过黄金矿工这款游戏吧！不过如果没有玩过建议**赛后**再玩。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4469.png) \n\n这道题与原游戏**有一些不同**，请仔细阅读规则。\n\n\n将矿区抽象为一个 $2s \\times s$ 的矩形，以左上角作为坐标原点，向右为 $x$ 轴正方向，向下为 $y$ 轴正方向，建立平面直角坐标系。\n\n\n矿工开始在 $(s,0)$，矿工可以在 $x$ 轴一部分：原点与 $(2s,0)$ 的连线（线段）上随意移动。\n\n\n把矿区中的黄金等物品抽象为坐标系中此矩形内一个个不相交的圆，每个圆有一个价值，可正可负。\n\n\n这里我们将抓取的过程抽象为以矿工为一端射出一条射线，如果不与任何圆相交（相切不算），那么这次抓取是无效的；否则矿工将会抓取到相交的圆中最早碰到的一个（较近的交点与矿工距离最近的一个圆）。\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s966cayn.png)\n\n\n黄金矿工这款游戏的目的是在规定时间上抓取价值尽量高的物品。\n\n\n移动与抓取都需要时间，移动 $1$ 单位距离需要花费 $k_1$ 的时间，将一次有效抓取的距离定义为抓取到的圆与射线较近的交点与矿工的距离，有效抓取每 $1$ 单位距离需要花费 $k_2$ 的时间（无效抓取将会被忽略）。\n\n\n你将要操纵这位矿工，给出移动和抓取指令，使得获取的价值尽量大。如果某次操作后你所用的总时间超过了规定时限，这次及以后操作将会被忽略。详细格式可见输出描述。\n\n\n**由于矿工比较懒，矿工只接受 $2n$ 次操作（$n$ 为圆的个数，无论是否是无效抓取），多余操作将被忽略。**\n\n\n判定时的 eps 为 $10^{-7}$。若你射出的射线与圆两交点的距离不超过该 eps，那么将不会判定为相交。若你的用时与时限的差不超过 eps，那么也不会被判定为超过时限。\n\n\n由于这是提交答案题，我们会提供输入数据、评分参数和 checker 下载，链接在最后。", "inputFormat": "第一行五个数 $s,t,k_1,k_2,n$，$s,k_1,k_2$ 的含义见题面，$t$ 为规定时限，$n$ 为圆的个数。\n\n\n以下 $n$ 行每行四个数 $x_i,y_i,r_i,v_i$，分别表示编号为 $i$ 的圆圆心 $x$ 坐标、圆心 $y$ 坐标、半径和价值。\n\n\n$n$ 和 $v_i$ 一定为整数，其余量可能为实数。", "outputFormat": "若干行，表示你的操作。\n\n\n每行开头一个字符为 `m` 或 `g`，然后一个空格。（`m`：move，`g`：grab）\n\n\n如果字符是 `m`，接下来应该接一个实数 $p(0 \\leq p \\leq 2s)$，表示将矿工移动到 $(p,0)$。\n\n\n如果字符是 `g`，接下来应该接一个实数 $a(0.2 \\leq a \\leq 179.8)$，表示抓取的射线与 $x$ 轴正方向夹角为 $a^{\\circ}$。\n\n\n**这两个实数建议保留 $10$ 位小数。**\n\n\n超过时限和超过 $2n$ 次的操作将被忽略。如果在输出文件中包含不合法信息该点可能会直接被判为 $0$ 分。", "hint": "#### 样例解释\n\n\n开始矿工在 $(4,0)$，移动到 $(1,0)$，花费 $3$ 时间。\n\n\n如图，矿工发射出一条射线，抓取到第一个圆，获取到 $1$ 价值，花费 $2\\sqrt{2}$ 时间。\n\n\n当然这不是花费时间最小的解，存在其他解。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4318.png) \n\n#### 评分标准\n\n\n对于每个点，如果你的输出不符合输出格式，得 $0$ 分。\n\n\n否则，假设你获得的价值为 $a$，每个点有三个评分参数，标准答案 $b$、一个实数 $w$、一个 $0$ 或 $1$ 的整数 $f$。\n\n\n若 $a<0$ ，你将获得 $0$ 分。\n\n\n若 $a>b$，你将获得 $10+f$ 分（这意味着部分点你可能会获得 $11$ 分）。\n\n\n否则你将获得 $\\lfloor 10(\\frac{a}{b})^w\\rfloor$ 分。（$\\lfloor x \\rfloor$ 表示不大于 $x$ 的最大整数）\n\n\n#### 如何测试和提交\n\n\n下载下发文件（见附件），里面有 mine1.in ~ mine10.in、mine1.ans ~ mine10.ans 和 checker.cpp、checker\\_win32.exe、tester.bat、testlib.h，**in、ans 和 checker.cpp 与洛谷上实际测试使用的完全相同**。windows 以外的系统，可以自行编译 checker.cpp。\n\n\n测试时在同一目录下放置 mine1.out ~ mine10.out，对于 windows 用户，运行 tester.bat，会自动调用 checker\\_win32.exe 返回每个点的结果。对于其它系统的用户，手动调用 `checker mine1.in mine1.out mine1.ans` 即可返回第一个点的评测结果，其它点同理。\n\n\nchecker 会返回形如 `points 0.9 Your ans is aaa, done bbb attempts, time used ccc, ddd remained` 的结果，表示这个点你可以获得 $9$ 分，你得到的价值是 aaa，成功进行了开始 bbb 个操作，用了 ccc 的时间，剩下 ddd 的时间。如果剩下的时间为负，表示最后一个（没有成功执行的）操作超时了。\n\n\n提交时可以直接将 mine1.out ~ mine10.out 打包上传，一个一个点输入提交亦可。", "locale": "zh-CN"}}}
{"pid": "P3676", "type": "P", "difficulty": 6, "samples": [["4 5\n1 2\n2 3\n2 4\n4 3 2 1\n2 2\n1 1 3\n2 3\n1 2 4\n2 4", "121\n140\n194"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["点分治", "洛谷原创", "O2优化", "树链剖分", "动态树 LCT", "洛谷月赛"], "title": "小清新数据结构题", "background": "**本题时限 2s，内存限制 250M。**", "description": "在很久很久以前，有一棵 $n$ 个点的树，每个点有一个点权。\n\n现在有 $q$ 次操作，每次操作是修改一个点的点权或指定一个点，询问以这个点为根时每棵子树点权和的平方和。\n\n（题目不是很好懂，没看太懂的可以看看样例解释）", "inputFormat": "第一行两个整数 $n,q$。\n\n接下来 $n-1$ 行每行两个整数 $a$ 和 $b$，表示树中 $a$ 与 $b$ 之间有一条边，保证给出的边不会重复。\n\n接下来一行 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个点的点权。\n\n接下来 $q$ 行每行两或三个数，如果第一个数为 $1$，那么接下来有两个数 $x$ 和 $y$，表示将第 $x$ 个点的点权修改为 $y$，如果第一个数为 $2$，那么接下来有一个数 $x$，表示询问以 $x$ 为根时每棵子树点权和的平方和。", "outputFormat": "对于每个询问输出答案。", "hint": "##### 样例解释\n\n这是一个菊花图，$2$ 与 $1,3,4$ 间有边。\n\n一开始每个点点权分别为 $4,3,2,1$。\n\n第一个询问以 $2$ 为根，$1,3,4$ 子树中都只有本身一个点，$2$ 子树中有所有点，那么 $1,3,4$ 子树中的点权和就分别是自己的点权 $4,2,1$，$2$ 子树中的点权和就是 $4+3+2+1=10$，$4^2+2^2+1^1+10^2=121$。\n\n接下来将第一个点点权修改为 $3$，每个点点权分别为 $3,3,2,1$。\n\n第二个询问以 $3$ 为根，$1,4$ 子树中只有自己，$2$ 子树中有 $1,2,4,3$ 子树中有所有点，$1,4$ 子树点权和就是自己的点权 $3,1$，$2$ 子树点权和就是 $3+3+1=7$，$3$ 子树点权和为 $3+3+2+1=9$，$3^2+1^2+7^2+9^2=140$。\n\n接下来把第二个点点权修改为 $4$，每个点点权分别为 $3,4,2,1$。\n\n第三个询问以 $4$ 为根，$1,3$ 子树点权和就是 $3$ 和 $2$，$2$ 子树点权和就是 $3+4+2=9$，$4$ 子树点权和为 $3+4+2+1=10$，$3^2+2^2+9^2+10^2=194$。\n\n##### 数据范围\n\n对于 $10\\%$ 的数据，$n,q \\leq 2000$。\n\n对于 $40\\%$ 的数据，$n,q \\leq 6\\times 10^4$。\n\n对于另外 $30\\%$ 的数据，保证每次询问的根都为 $1$。\n\n对于 $100\\%$ 的数据，$1 \\leq n,q \\leq 2\\times 10^5$，$-10 \\leq$ 输入的每个点权 $\\leq 10$。\n\n建议使用输入优化，~~虽然标程没加读入优化也能过。~~", "locale": "zh-CN", "translations": {"en": {"title": "A Simple and Neat Data Structure Problem", "background": "Time limit: 2 s, memory limit: 256 MB.", "description": "Long long ago, there was a tree with $n$ nodes, and each node had a weight.\n\nThere are $q$ operations. Each operation either modifies the weight of a node or, given a node, asks for the sum of squares of the subtree weight sums when this node is taken as the root.\n\n(If this statement is not very clear, please refer to the sample explanation.)", "inputFormat": "The first line contains two integers $n, q$.\n\nThe next $n - 1$ lines each contain two integers $a$ and $b$, indicating there is an edge between $a$ and $b$ in the tree. It is guaranteed that no edges are duplicated.\n\nThe next line contains $n$ integers, where the $i$-th integer is the weight of node $i$.\n\nThe next $q$ lines each contain two or three numbers. If the first number is $1$, then there are two more numbers $x$ and $y$, meaning the weight of node $x$ is modified to $y$. If the first number is $2$, then there is one more number $x$, meaning you should query the sum of squares of the subtree weight sums when $x$ is the root.", "outputFormat": "For each query, output the answer.", "hint": "Sample explanation:\n\nThis is a star graph, with edges between $2$ and $1, 3, 4$.\n\nInitially, the node weights are $4, 3, 2, 1$.\n\nFor the first query with root $2$, the subtrees of $1, 3, 4$ each contain only themselves, and the subtree of $2$ contains all nodes. Therefore, the subtree weight sums of $1, 3, 4$ are their own weights $4, 2, 1$, and the subtree weight sum of $2$ is $4 + 3 + 2 + 1 = 10$. Thus $4^2 + 2^2 + 1^2 + 10^2 = 121$.\n\nNext, modify the weight of node $1$ to $3$, so the node weights become $3, 3, 2, 1$.\n\nFor the second query with root $3$, the subtrees of $1$ and $4$ each contain only themselves; the subtree of $2$ contains $1, 2, 4$; and the subtree of $3$ contains all nodes. The subtree weight sums are $3, 1, 7, 9$, so $3^2 + 1^2 + 7^2 + 9^2 = 140$.\n\nNext, modify the weight of node $2$ to $4$, so the node weights become $3, 4, 2, 1$.\n\nFor the third query with root $4$, the subtree weight sums of $1$ and $3$ are $3$ and $2$, the subtree weight sum of $2$ is $3 + 4 + 2 = 9$, and the subtree weight sum of $4$ is $3 + 4 + 2 + 1 = 10$. Thus $3^2 + 2^2 + 9^2 + 10^2 = 194$.\n\nConstraints:\n- For 10% of the testdata, $n, q \\leq 2000$.\n- For 40% of the testdata, $n, q \\leq 6 \\times 10^4$.\n- For another 30% of the testdata, the root in every query is $1$.\n- For 100% of the testdata, $1 \\leq n, q \\leq 2 \\times 10^5$, and each input node weight satisfies $-10 \\leq \\text{weight} \\leq 10$.\n\nIt is recommended to use fast I/O, although the official solution without fast I/O can also pass.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小清新数据结构题", "background": "**本题时限 2s，内存限制 250M。**", "description": "在很久很久以前，有一棵 $n$ 个点的树，每个点有一个点权。\n\n现在有 $q$ 次操作，每次操作是修改一个点的点权或指定一个点，询问以这个点为根时每棵子树点权和的平方和。\n\n（题目不是很好懂，没看太懂的可以看看样例解释）", "inputFormat": "第一行两个整数 $n,q$。\n\n接下来 $n-1$ 行每行两个整数 $a$ 和 $b$，表示树中 $a$ 与 $b$ 之间有一条边，保证给出的边不会重复。\n\n接下来一行 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个点的点权。\n\n接下来 $q$ 行每行两或三个数，如果第一个数为 $1$，那么接下来有两个数 $x$ 和 $y$，表示将第 $x$ 个点的点权修改为 $y$，如果第一个数为 $2$，那么接下来有一个数 $x$，表示询问以 $x$ 为根时每棵子树点权和的平方和。", "outputFormat": "对于每个询问输出答案。", "hint": "##### 样例解释\n\n这是一个菊花图，$2$ 与 $1,3,4$ 间有边。\n\n一开始每个点点权分别为 $4,3,2,1$。\n\n第一个询问以 $2$ 为根，$1,3,4$ 子树中都只有本身一个点，$2$ 子树中有所有点，那么 $1,3,4$ 子树中的点权和就分别是自己的点权 $4,2,1$，$2$ 子树中的点权和就是 $4+3+2+1=10$，$4^2+2^2+1^1+10^2=121$。\n\n接下来将第一个点点权修改为 $3$，每个点点权分别为 $3,3,2,1$。\n\n第二个询问以 $3$ 为根，$1,4$ 子树中只有自己，$2$ 子树中有 $1,2,4,3$ 子树中有所有点，$1,4$ 子树点权和就是自己的点权 $3,1$，$2$ 子树点权和就是 $3+3+1=7$，$3$ 子树点权和为 $3+3+2+1=9$，$3^2+1^2+7^2+9^2=140$。\n\n接下来把第二个点点权修改为 $4$，每个点点权分别为 $3,4,2,1$。\n\n第三个询问以 $4$ 为根，$1,3$ 子树点权和就是 $3$ 和 $2$，$2$ 子树点权和就是 $3+4+2=9$，$4$ 子树点权和为 $3+4+2+1=10$，$3^2+2^2+9^2+10^2=194$。\n\n##### 数据范围\n\n对于 $10\\%$ 的数据，$n,q \\leq 2000$。\n\n对于 $40\\%$ 的数据，$n,q \\leq 6\\times 10^4$。\n\n对于另外 $30\\%$ 的数据，保证每次询问的根都为 $1$。\n\n对于 $100\\%$ 的数据，$1 \\leq n,q \\leq 2\\times 10^5$，$-10 \\leq$ 输入的每个点权 $\\leq 10$。\n\n建议使用输入优化，~~虽然标程没加读入优化也能过。~~", "locale": "zh-CN"}}}
{"pid": "P3677", "type": "P", "difficulty": 5, "samples": [["111001000111\n", "2\n3 9\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心", "2016", "Special Judge", "构造", "ICPC", "CERC"], "title": "[CERC2016] 关键的膝盖 Key Knocking", "background": "", "description": "Goran正在从他的膝盖手术中恢复，并正在试验用于存储的智能卡加密密钥。在这个问题中，一个密钥是指一个长度为3n的二进制序列，其中n是正整数。序列的每一位从左往右依次被编号为1到3n。一个密钥的权值是指相邻位不同的位置个数再加上1。比如：“000”的权值是1，“011010100”的权值是7。\n\n\n他发现他可以发送小型脉冲电流来修改智能卡的电路，从而修改密钥。确切地说，他可以不断进行下面的操作：选择任意两个相邻的位，然后同时取反它们。比如他可以通过一次操作把“000”修改为“110”。\n\n\n给定一个长度为3n的密钥，请操作不超过n次，将其修改为一个权值不少于2n的密钥。你可以认为合法解必然存在。\n", "inputFormat": "包含一行一个01序列，表示初始密钥，保证长度一定为3n，且1<=n<=100000。\n", "outputFormat": "第一行包含一个整数m，表示操作的次数，你需要保证0<=m<=n。\n\n第二行包含m个正整数a\\_1,a\\_2,...,a\\_m(1<=a\\_i<n)，依次表示每次翻转第a\\_i和第(a\\_i)+1位。\n\n如果初始密钥的权值已经不小于2n，你可以仅输出一行一个整数0。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[CERC2016] Key Knocking", "background": "", "description": "Goran is recovering from knee surgery and is experimenting with smart card encryption keys for storage. In this problem, a key is a binary sequence of length $3n$, where $n$ is a positive integer. The bits of the sequence are numbered from left to right as $1$ to $3n$. The weight of a key is defined as the number of positions where adjacent bits differ, plus $1$. For example, the weight of \"000\" is $1$, and the weight of \"011010100\" is $7$.\n\nHe finds that he can send small current pulses to modify the circuits of the smart card, thereby modifying the key. Specifically, he can repeatedly perform the following operation: choose any two adjacent bits and flip them both. For example, he can change \"000\" to \"110\" in one operation.\n\nGiven a key of length $3n$, perform at most $n$ operations to transform it into a key with weight at least $2n$. You may assume that a valid solution always exists.", "inputFormat": "One line containing a binary string representing the initial key. Its length is exactly $3n$, where $1 \\le n \\le 100000$.", "outputFormat": "The first line contains an integer $m$ denoting the number of operations, with $0 \\le m \\le n$.\n\nThe second line contains $m$ positive integers $a_1, a_2, \\ldots, a_m$ ($1 \\le a_i < 3n$), in order indicating that in the $i$-th operation you flip bits at positions $a_i$ and $a_i + 1$.\n\nIf the initial key already has weight at least $2n$, you may output a single line containing the integer $0$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2016] 关键的膝盖 Key Knocking", "background": "", "description": "Goran正在从他的膝盖手术中恢复，并正在试验用于存储的智能卡加密密钥。在这个问题中，一个密钥是指一个长度为3n的二进制序列，其中n是正整数。序列的每一位从左往右依次被编号为1到3n。一个密钥的权值是指相邻位不同的位置个数再加上1。比如：“000”的权值是1，“011010100”的权值是7。\n\n\n他发现他可以发送小型脉冲电流来修改智能卡的电路，从而修改密钥。确切地说，他可以不断进行下面的操作：选择任意两个相邻的位，然后同时取反它们。比如他可以通过一次操作把“000”修改为“110”。\n\n\n给定一个长度为3n的密钥，请操作不超过n次，将其修改为一个权值不少于2n的密钥。你可以认为合法解必然存在。\n", "inputFormat": "包含一行一个01序列，表示初始密钥，保证长度一定为3n，且1<=n<=100000。\n", "outputFormat": "第一行包含一个整数m，表示操作的次数，你需要保证0<=m<=n。\n\n第二行包含m个正整数a\\_1,a\\_2,...,a\\_m(1<=a\\_i<n)，依次表示每次翻转第a\\_i和第(a\\_i)+1位。\n\n如果初始密钥的权值已经不小于2n，你可以仅输出一行一个整数0。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3678", "type": "P", "difficulty": 4, "samples": [["11 16\n################\n#....#++++#+...#\n#....#++.+#+...#\n#....#.++.#++.+#\n#....#....#++++#\n################\n#....#.+..#++++#\n#..++#.+..#++.+#\n#+...#....#.++.#\n#+...#..++#....#\n################", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2016", "哈希 hashing", "ICPC", "CERC"], "title": "[CERC2016] 外观分析 Appearance Analysis", "background": "", "description": "你在萨格勒布拍摄了一张电气工程与计算机“C”楼的照片，它的尺寸相同的窗户整齐地排列在行列上。一些窗户上画着美妙的图案，你现在正在尝试分析有多少本质不同的创意画。\n\n\n我们用一个r行c列的矩形格子图来描述一张照片。每个窗户都占据了一个矩形区域，并且所有窗户都有着相同的尺寸。一个窗户里的每个格子要么是空白的（用“.”表示），要么是被画过的（用“+”表示）。两个窗户的图案被认为是相同的，当且仅当其中有一个窗户旋转90度、180度、270度或360度后，放在另一个窗户上会完全匹配（包括边框）。当比较图案时，我们不允许翻转窗户。\n\n\n所有窗户都规则地分布在行列中，窗户之间的边框用一格“#”字符表示。确切地说，在上下相邻的两个窗户之间，有恰好一行“#”字符，同时在第一行窗户之上或者最后一行窗户之下，也有恰好一行“#”字符。同理，在左右相邻的两个窗户之间，有恰好一列“#”字符，同时在第一列窗户之左或者最后一列窗户之右，也有恰好一列“#”字符。窗户的行数与列数是任意的，窗户的长宽也是任意的，不一定是正方形。但是，每个窗户至少占据一个格子，而且所有窗户的尺寸都是相同的。\n\n\n请统计有多少本质不同的创意画。\n", "inputFormat": "第一行包含两个正整数r,c(3<=r,c<=111)，分别表示照片的行数和列数。\n\n接下来r行，每行c个字符，分别表示照片的每一行。\n", "outputFormat": "输出一行一个整数，即本质不同的创意画的数量。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[CERC2016] Appearance Analysis", "background": "", "description": "You took a photo in Zagreb of the \"C\" building of Electrical Engineering and Computing, where same-sized windows are neatly arranged in rows and columns. Some windows contain beautiful designs, and you are trying to analyze how many essentially different creative drawings there are.\n\nWe describe a photo using a rectangular grid with $r$ rows and $c$ columns. Each window occupies a rectangular region, and all windows have the same dimensions. In a window, each cell is either blank (denoted by \".\") or painted (denoted by \"+\"). Two windows are considered to have the same design if and only if, after rotating one window by $90^\\circ$, $180^\\circ$, $270^\\circ$, or $360^\\circ$, it matches the other exactly (including borders). Flipping windows is not allowed when comparing designs.\n\nAll windows are regularly placed in rows and columns, and the borders between windows are represented by the character \"#\". Specifically, between two vertically adjacent windows there is exactly one row of \"#\" characters, and there is also exactly one row of \"#\" characters above the first row of windows and below the last row of windows. Similarly, between two horizontally adjacent windows there is exactly one column of \"#\" characters, and there is also exactly one column of \"#\" characters to the left of the first column of windows and to the right of the last column of windows. The numbers of window rows and window columns are arbitrary, and the window width and height are arbitrary; windows are not necessarily square. However, each window occupies at least one cell, and all windows have the same size.\n\nPlease count how many essentially different creative drawings there are.", "inputFormat": "The first line contains two positive integers $r, c$ ($3 \\le r, c \\le 111$), the numbers of rows and columns of the photo.\n\nEach of the next $r$ lines contains $c$ characters, describing the photo.", "outputFormat": "Output a single integer, the number of essentially different creative drawings.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2016] 外观分析 Appearance Analysis", "background": "", "description": "你在萨格勒布拍摄了一张电气工程与计算机“C”楼的照片，它的尺寸相同的窗户整齐地排列在行列上。一些窗户上画着美妙的图案，你现在正在尝试分析有多少本质不同的创意画。\n\n\n我们用一个r行c列的矩形格子图来描述一张照片。每个窗户都占据了一个矩形区域，并且所有窗户都有着相同的尺寸。一个窗户里的每个格子要么是空白的（用“.”表示），要么是被画过的（用“+”表示）。两个窗户的图案被认为是相同的，当且仅当其中有一个窗户旋转90度、180度、270度或360度后，放在另一个窗户上会完全匹配（包括边框）。当比较图案时，我们不允许翻转窗户。\n\n\n所有窗户都规则地分布在行列中，窗户之间的边框用一格“#”字符表示。确切地说，在上下相邻的两个窗户之间，有恰好一行“#”字符，同时在第一行窗户之上或者最后一行窗户之下，也有恰好一行“#”字符。同理，在左右相邻的两个窗户之间，有恰好一列“#”字符，同时在第一列窗户之左或者最后一列窗户之右，也有恰好一列“#”字符。窗户的行数与列数是任意的，窗户的长宽也是任意的，不一定是正方形。但是，每个窗户至少占据一个格子，而且所有窗户的尺寸都是相同的。\n\n\n请统计有多少本质不同的创意画。\n", "inputFormat": "第一行包含两个正整数r,c(3<=r,c<=111)，分别表示照片的行数和列数。\n\n接下来r行，每行c个字符，分别表示照片的每一行。\n", "outputFormat": "输出一行一个整数，即本质不同的创意画的数量。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3679", "type": "P", "difficulty": 6, "samples": [["3 3\n010\n111\n010\n1 2 3\n8 5 13\n21\n", "3\n"], ["3 2\n01\n11\n10\n1 2 3\n4 5\n8\n", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "ICPC", "CERC"], "title": "[CERC2016] 二分毯 Bipartite Blanket", "background": "", "description": "在二分图中，所有点被划分成了两个不相交的集合 $A$ 和 $B$，每条边都恰好连接着某个 $A$ 和某个 $B$。一个匹配是一个边集，满足没有任何两条边有相同的端点。我们称一个匹配 $M$ 覆盖了点集 $V$ 当且仅当 $V$ 中的每个点都是 $M$ 中至少一条边的端点。\n\n\n给定一个二分图，每个点有一个正整数权值。定义一个点集的权值为其中所有点的权值之和。\n\n\n给定一个参数 $t$，请统计有多少点集 $V$，满足 $V$ 的权值不小于 $t$，且 $V$ 被至少一个匹配 $M$ 覆盖。\n", "inputFormat": "第一行包含两个正整数 $n,m$，分别表示 $A$ 集合的点数和 $B$ 集合的点数。\n\n接下来 $n$ 行，每行 $m$ 个 01 字符，其中第 $i$ 行第 $j$ 列为 $1$ 表示 $A_i$ 和 $B_j$ 之间有一条边。\n\n接下来一行包含 $n$ 个正整数 $v_1,v_2,\\cdots,v_n$，分别表示 $A$ 中每个点的权值。\n\n接下来一行包含 $m$ 个正整数 $w_1,w_2,\\cdots,w_m$，分别表示 $B$ 中每个点的权值。\n\n最后一行包含一个正整数 $t$，表示参数 $t$。\n", "outputFormat": "输出一行一个整数，即满足条件的点集个数。\n", "hint": "$1\\leq n,m\\leq 20$，$1\\leq v_i,w_i\\leq 10^7$，$1\\leq t\\leq 4\\times 10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "[CERC2016] Bipartite Blanket", "background": "", "description": "In a bipartite graph, all vertices are split into two disjoint sets $A$ and $B$, and every edge connects some vertex in $A$ to some vertex in $B$. A matching is a set of edges such that no two edges share an endpoint. We say a matching $M$ covers a vertex set $V$ if and only if every vertex in $V$ is an endpoint of at least one edge in $M$.\n\nGiven a bipartite graph where each vertex has a positive integer weight, define the weight of a vertex set as the sum of the weights of its vertices.\n\nGiven a parameter $t$, count how many vertex sets $V$ satisfy that the weight of $V$ is at least $t$, and $V$ is covered by at least one matching $M$.", "inputFormat": "The first line contains two positive integers $n, m$, denoting the number of vertices in set $A$ and set $B$, respectively.\n\nThe next $n$ lines each contain $m$ binary characters '0' or '1'. In the $i$-th row and the $j$-th column, a $1$ indicates there is an edge between $A_i$ and $B_j$.\n\nThe next line contains $n$ positive integers $v_1, v_2, \\cdots, v_n$, denoting the weight of each vertex in $A$.\n\nThe next line contains $m$ positive integers $w_1, w_2, \\cdots, w_m$, denoting the weight of each vertex in $B$.\n\nThe last line contains a positive integer $t$, representing the parameter $t$.", "outputFormat": "Output a single integer on one line, the number of vertex sets that satisfy the condition.", "hint": "$1 \\leq n, m \\leq 20$, $1 \\leq v_i, w_i \\leq 10^7$, $1 \\leq t \\leq 4 \\times 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2016] 二分毯 Bipartite Blanket", "background": "", "description": "在二分图中，所有点被划分成了两个不相交的集合 $A$ 和 $B$，每条边都恰好连接着某个 $A$ 和某个 $B$。一个匹配是一个边集，满足没有任何两条边有相同的端点。我们称一个匹配 $M$ 覆盖了点集 $V$ 当且仅当 $V$ 中的每个点都是 $M$ 中至少一条边的端点。\n\n\n给定一个二分图，每个点有一个正整数权值。定义一个点集的权值为其中所有点的权值之和。\n\n\n给定一个参数 $t$，请统计有多少点集 $V$，满足 $V$ 的权值不小于 $t$，且 $V$ 被至少一个匹配 $M$ 覆盖。\n", "inputFormat": "第一行包含两个正整数 $n,m$，分别表示 $A$ 集合的点数和 $B$ 集合的点数。\n\n接下来 $n$ 行，每行 $m$ 个 01 字符，其中第 $i$ 行第 $j$ 列为 $1$ 表示 $A_i$ 和 $B_j$ 之间有一条边。\n\n接下来一行包含 $n$ 个正整数 $v_1,v_2,\\cdots,v_n$，分别表示 $A$ 中每个点的权值。\n\n接下来一行包含 $m$ 个正整数 $w_1,w_2,\\cdots,w_m$，分别表示 $B$ 中每个点的权值。\n\n最后一行包含一个正整数 $t$，表示参数 $t$。\n", "outputFormat": "输出一行一个整数，即满足条件的点集个数。\n", "hint": "$1\\leq n,m\\leq 20$，$1\\leq v_i,w_i\\leq 10^7$，$1\\leq t\\leq 4\\times 10^8$。", "locale": "zh-CN"}}}
{"pid": "P3680", "type": "P", "difficulty": 6, "samples": [["4\nTSTC", "9.088434417\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "数学", "计算几何", "2016", "Special Judge", "凸包", "ICPC", "CERC"], "title": "[CERC2016] 凸轮廓线 Convex Contour", "background": "", "description": "一些几何图形整齐地在一个网格图上从左往右排成一列。它们占据了连续的一段横行，每个位置恰好一个几何图形。每个图形是以下的三种之一：\n\n\n1. 一个恰好充满单个格子的正方形。\n\n\n2. 一个内切于单个格子的圆。\n\n\n3. 一个底边与格子重合的等边三角形。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4685.png) \n\n已知每个格子的边长都为 $1$，请求出这些几何图形的凸包的周长。", "inputFormat": "第一行包含一个正整数 $n$，表示几何图形的个数。\n\n第二行包含 $n$ 个字符，从左往右依次表示每个图形，`S` 表示正方形，`C` 表示圆形，`T` 表示等边三角形。\n", "outputFormat": "输出一行一个实数，即凸包的周长。与答案的绝对或相对误差不超过 $10^{-6}$ 时被认为是正确的。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 20$。", "locale": "zh-CN", "translations": {"en": {"title": "[CERC2016] Convex Contour", "background": "", "description": "Some geometric figures are arranged neatly from left to right in a single row on a square grid. They occupy a consecutive segment of one row, with exactly one figure in each cell. Each figure is one of the following three:\n\n1. A square that exactly fills a single cell.\n2. A circle inscribed in a single cell.\n3. An equilateral triangle whose base coincides with the bottom edge of the cell.\n\n![](https://cdn.luogu.com.cn/upload/pic/4685.png)\n\nThe side length of each cell is $1$. Compute the perimeter of the convex hull of these figures.", "inputFormat": "The first line contains a positive integer $n$, the number of figures.\n\nThe second line contains $n$ characters, describing each figure from left to right: `S` denotes a square, `C` denotes a circle, and `T` denotes an equilateral triangle.", "outputFormat": "Output a single real number, the perimeter of the convex hull. Your answer will be accepted if the absolute or relative error does not exceed $10^{-6}$.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2016] 凸轮廓线 Convex Contour", "background": "", "description": "一些几何图形整齐地在一个网格图上从左往右排成一列。它们占据了连续的一段横行，每个位置恰好一个几何图形。每个图形是以下的三种之一：\n\n\n1. 一个恰好充满单个格子的正方形。\n\n\n2. 一个内切于单个格子的圆。\n\n\n3. 一个底边与格子重合的等边三角形。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4685.png) \n\n已知每个格子的边长都为 $1$，请求出这些几何图形的凸包的周长。", "inputFormat": "第一行包含一个正整数 $n$，表示几何图形的个数。\n\n第二行包含 $n$ 个字符，从左往右依次表示每个图形，`S` 表示正方形，`C` 表示圆形，`T` 表示等边三角形。\n", "outputFormat": "输出一行一个实数，即凸包的周长。与答案的绝对或相对误差不超过 $10^{-6}$ 时被认为是正确的。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 20$。", "locale": "zh-CN"}}}
{"pid": "P3681", "type": "P", "difficulty": 6, "samples": [["6\n1 6 5 4 3 2", "1 1 D 6\n2 1 D 6\n3 1 D 6\n4 1 D 6\n5 1 D 6\n6 1 R 6\n6 2 R 6\n6 3 R 6\n6 4 R 6\n6 5 R 5\n6 5 R 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "Special Judge", "ICPC", "CERC"], "title": "[CERC2016] 舞动的盘子 Dancing Disks", "background": null, "description": "Luka 非常擅长解决汉诺塔问题，他发明了一种类似汉诺塔的使用盘子和柱子的游戏。这个游戏有 $n$ 个不同大小的盘子以及 $36$ 根柱子。盘子按照大小从小到大依次被编号为 $1$ 到 $n$。柱子形成了 $6$ 行 $6$ 列的矩阵，从上到下每行依次被编号为 $1$ 到 $6$，从左到右每列依次被编号为1到 $6$。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4686.png) \n\n游戏一开始，$n$ 个盘子都被堆叠在左上角坐标为 $(1,1)$ 的柱子上。对于每一次操作，玩家可以选择一个柱子，取出最顶上若干个盘子，然后选择右边或者下面的某个柱子，将取出的盘子全部堆叠在其顶上（不会翻转顺序）。游戏的目标是把所有盘子都移动到 $(6,6)$ ，且自底向上大小依次递减。\n\n\n给定游戏的初始局面，请找到任意一组玩通关的方法。数据保证解必定存在。", "inputFormat": "第一行包含一个正整数 $n(1\\le n\\le 40000)$，表示盘子的数目。\n\n第二行包含 $n$ 个正整数 $d_1,d_2,\\cdots,d_n(1\\le d_i\\le n)$，自底向上表示 $(1,1)$ 柱子上每个盘子的编号。\n\n输入数据保证不存在两个盘子的编号相同。", "outputFormat": "输出 $m$ 行，$m$ 表示你的解中游戏操作的次数。\n\n其中第 $i$ 行包含 $4$ 个参数 $r_i,c_i,p_i,n_i$，表示第 $i$ 步操作，即你选择了 $(r_i,c_i)$ 最上方的 $n_i(n_i\\ge1)$ 个盘子，然后往 $p_i$ 方向移动。\n\n如果向右移动，那么 $p_i$ 为 `R`；如果向下移动，那么 $p_i$ 为 `D`。\n\n若有多组方案，输出任意一组。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[CERC2016] Dancing Disks", "background": "", "description": "Luka is very good at solving the Tower of Hanoi problem, and he invented a similar game that uses disks and pegs. The game has $n$ disks of different sizes and $36$ pegs. The disks are numbered from $1$ to $n$ from smallest to largest. The pegs form a $6 \\times 6$ grid: rows are numbered $1$ to $6$ from top to bottom, and columns are numbered $1$ to $6$ from left to right.\n\n![](https://cdn.luogu.com.cn/upload/pic/4686.png)\n\nAt the beginning, all $n$ disks are stacked on the peg at $(1,1)$. In each move, you may choose a peg, take the top several disks, then choose some peg to its right in the same row or some peg below it in the same column, and place all the taken disks on top of that peg (their order is preserved; they are not reversed). The goal is to move all disks to $(6,6)$, with strictly decreasing sizes from bottom to top.\n\nGiven the initial configuration, find any sequence of moves that completes the game. It is guaranteed that a solution exists.", "inputFormat": "The first line contains a positive integer $n$ ($1 \\le n \\le 40000$), the number of disks.\n\nThe second line contains $n$ positive integers $d_1, d_2, \\cdots, d_n$ ($1 \\le d_i \\le n$), listing from bottom to top the labels of the disks on the peg at $(1,1)$.\n\nIt is guaranteed that no two disks have the same label.", "outputFormat": "Output $m$ lines, where $m$ is the number of moves in your solution.\n\nIn the $i$-th line, output $4$ items $r_i, c_i, p_i, n_i$, meaning that in the $i$-th move you choose the top $n_i$ ($n_i \\ge 1$) disks from $(r_i, c_i)$ and move them in direction $p_i$.\n\nIf you move to the right, then $p_i$ is `R`; if you move downward, then $p_i$ is `D`.\n\nIf there are multiple valid solutions, output any one.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2016] 舞动的盘子 Dancing Disks", "background": null, "description": "Luka 非常擅长解决汉诺塔问题，他发明了一种类似汉诺塔的使用盘子和柱子的游戏。这个游戏有 $n$ 个不同大小的盘子以及 $36$ 根柱子。盘子按照大小从小到大依次被编号为 $1$ 到 $n$。柱子形成了 $6$ 行 $6$ 列的矩阵，从上到下每行依次被编号为 $1$ 到 $6$，从左到右每列依次被编号为1到 $6$。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4686.png) \n\n游戏一开始，$n$ 个盘子都被堆叠在左上角坐标为 $(1,1)$ 的柱子上。对于每一次操作，玩家可以选择一个柱子，取出最顶上若干个盘子，然后选择右边或者下面的某个柱子，将取出的盘子全部堆叠在其顶上（不会翻转顺序）。游戏的目标是把所有盘子都移动到 $(6,6)$ ，且自底向上大小依次递减。\n\n\n给定游戏的初始局面，请找到任意一组玩通关的方法。数据保证解必定存在。", "inputFormat": "第一行包含一个正整数 $n(1\\le n\\le 40000)$，表示盘子的数目。\n\n第二行包含 $n$ 个正整数 $d_1,d_2,\\cdots,d_n(1\\le d_i\\le n)$，自底向上表示 $(1,1)$ 柱子上每个盘子的编号。\n\n输入数据保证不存在两个盘子的编号相同。", "outputFormat": "输出 $m$ 行，$m$ 表示你的解中游戏操作的次数。\n\n其中第 $i$ 行包含 $4$ 个参数 $r_i,c_i,p_i,n_i$，表示第 $i$ 步操作，即你选择了 $(r_i,c_i)$ 最上方的 $n_i(n_i\\ge1)$ 个盘子，然后往 $p_i$ 方向移动。\n\n如果向右移动，那么 $p_i$ 为 `R`；如果向下移动，那么 $p_i$ 为 `D`。\n\n若有多组方案，输出任意一组。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3682", "type": "P", "difficulty": 5, "samples": [["7\n3 5 4 0 7 0 0\n3 5 0 6 7 0 0\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2016", "ICPC", "CERC"], "title": "[CERC2016] 自由的套娃 Free Figurines", "background": null, "description": "俄罗斯套娃是一些尺寸递增的木制雕像，它们可以嵌套在一起。每个套娃可以放进一个更大的套娃，也可以被放入一个更小的套娃。每个套娃内部最多只能直接嵌套一个套娃，但是那个套娃内部还可以继续嵌套。\n\n\n给定 $n$ 个尺寸互不相同的套娃，按尺寸从小到大依次编号为 $1$ 到 $n$。如果套娃 $a$ 被直接嵌入套娃 $b$，那么我们称 $b$ 是 $a$ 的父亲，如果一个套娃没有父亲，那么我们称它是自由的。一组镶嵌方案可以用每个套娃的父亲来表示。\n\n\n我们可以每步可以做以下两种操作中的任意一种：\n\n\n1. 把一个自由的套娃直接嵌入一个更大的没有被放入东西的套娃。\n\n\n2. 选择一个不自由的套娃，将其从其父亲中取出。\n\n\n给定初始局面，请计算达到目标局面的最小的操作步数。", "inputFormat": "第一行包含一个正整数 $n(1 \\le n \\le 100000)$，表示套娃的个数。\n\n第二行包含 $n$ 个整数 $p_1,p_2,...,p_n(0 \\le p_i \\le n)$，依次表示初始局面中每个套娃的父亲，$0$ 表示自由套娃。\n\n第三行包含 $n$ 个整数 $q_1,q_2,...,q_n(0 \\le q_i \\le n)$，依次表示目标局面中每个套娃的父亲，$0$ 表示自由套娃。\n\n输入数据保证初始局面和目标局面均合法。", "outputFormat": "输出一行一个整数，即最小操作步数。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[CERC2016] Free Figurines", "background": "", "description": "Russian nesting dolls are wooden figurines of strictly increasing sizes that can be nested inside one another. Each figurine can be put into a larger figurine, and can itself contain a smaller figurine. At most one figurine can be directly nested inside any figurine, but that inner figurine can itself contain another, and so on.\n\nGiven $n$ figurines with distinct sizes, they are numbered $1$ to $n$ in increasing order of size. If figurine $a$ is directly nested inside figurine $b$, then we say $b$ is the parent of $a$. If a figurine has no parent, we say it is free. A nesting configuration can be represented by specifying the parent of each figurine.\n\nIn each step, you may perform exactly one of the following two operations:\n\n1. Take a free figurine and directly place it into a larger figurine that currently contains nothing.\n2. Choose a figurine that is not free (i.e., has a parent) and remove it from its parent.\n\nGiven the initial configuration, compute the minimum number of steps to reach the target configuration.", "inputFormat": "The first line contains a positive integer $n(1 \\le n \\le 100000)$, the number of figurines.\n\nThe second line contains $n$ integers $p_1,p_2,...,p_n(0 \\le p_i \\le n)$, giving the parent of each figurine in the initial configuration, where $0$ denotes a free figurine.\n\nThe third line contains $n$ integers $q_1,q_2,...,q_n(0 \\le q_i \\le n)$, giving the parent of each figurine in the target configuration, where $0$ denotes a free figurine.\n\nThe input guarantees that both the initial and the target configurations are valid.", "outputFormat": "Output a single integer, the minimum number of operations.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2016] 自由的套娃 Free Figurines", "background": null, "description": "俄罗斯套娃是一些尺寸递增的木制雕像，它们可以嵌套在一起。每个套娃可以放进一个更大的套娃，也可以被放入一个更小的套娃。每个套娃内部最多只能直接嵌套一个套娃，但是那个套娃内部还可以继续嵌套。\n\n\n给定 $n$ 个尺寸互不相同的套娃，按尺寸从小到大依次编号为 $1$ 到 $n$。如果套娃 $a$ 被直接嵌入套娃 $b$，那么我们称 $b$ 是 $a$ 的父亲，如果一个套娃没有父亲，那么我们称它是自由的。一组镶嵌方案可以用每个套娃的父亲来表示。\n\n\n我们可以每步可以做以下两种操作中的任意一种：\n\n\n1. 把一个自由的套娃直接嵌入一个更大的没有被放入东西的套娃。\n\n\n2. 选择一个不自由的套娃，将其从其父亲中取出。\n\n\n给定初始局面，请计算达到目标局面的最小的操作步数。", "inputFormat": "第一行包含一个正整数 $n(1 \\le n \\le 100000)$，表示套娃的个数。\n\n第二行包含 $n$ 个整数 $p_1,p_2,...,p_n(0 \\le p_i \\le n)$，依次表示初始局面中每个套娃的父亲，$0$ 表示自由套娃。\n\n第三行包含 $n$ 个整数 $q_1,q_2,...,q_n(0 \\le q_i \\le n)$，依次表示目标局面中每个套娃的父亲，$0$ 表示自由套娃。\n\n输入数据保证初始局面和目标局面均合法。", "outputFormat": "输出一行一个整数，即最小操作步数。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3683", "type": "P", "difficulty": 7, "samples": [["3 8\n1 1\n5 1\n5 4\n3 4\n3 8\n0 8\n0 5\n1 5\n4 2 3 5 7", "32\n30\n26\n24\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "ICPC", "CERC"], "title": "[CERC2016] 地理哈希网格 Geohash Grid", "background": "", "description": "“地理哈希”是一个将二维平面坐标编码为整数的过程，这将为数据库中地理数据的存储和查询带来方便。在这个问题中，一个地图是一个建立在标准二维笛卡尔坐标系上的2^n行2^n列的矩形网格，越往右x坐标越大，越往上y坐标越大。一个地图格子是一个单位正方形，满足其左下角的点的坐标为(x,y)，其中0<=x,y<2^n。\n\n\n在2^n行2^n列的地图上一共有2^(2n)个格子。对于一个格子c，它的地理哈希值h(c)是一个2n位的非负二进制整数。从最高位开始考虑整个地图，然后重复下面两个步骤n次，即可得到c的地理哈希值h(c)：\n\n\n1.把地图分成左右两个面积相等的区域，如果格子c在左半边，那么这一位是0，否则是1。然后将考虑范围缩小到c所在的那半边地图。\n\n\n2.把地图分成上下两个面积相等的区域，如果格子c在下半边，那么这一位是0，否则是1。然后将考虑范围缩小到c所在的那半边地图。\n\n\n一个“地理哈希区间”[a,b]表示所有哈希值在[a,b]之间的格子。通常应用中，我们会用一些地理哈希区间去近似表示地图。给定一个格子集合C，以及一个正整数t，那么C的最优t近似是指使用不超过t个地理哈希区间，覆盖住所有C中的格子（覆盖其它格子是允许的），同时满足覆盖住的区域的面积最小。\n\n\n给定一个地图以及一个格子集合C，C用一个边平行于坐标轴的简单多边形来表示。然后给定q个询问t\\_1,t\\_2,...,t\\_q，对于每个询问t\\_k，你需要求出C的最优t\\_k近似覆盖住的区域的面积。\n", "inputFormat": "第一行包含一个正整数n(1<=n<=30)，表示地图的尺寸的以2为底的对数。\n\n第二行包含一个正整数m(4<=m<=200)，表示多边形顶点的个数。\n\n接下来m行，每行两个整数x\\_i,y\\_i(0<=x\\_i,y\\_i<=2^n)，按逆时针依次表示多边形每个顶点的坐标。\n\n输入数据保证多边形不自交，边平行于坐标轴，且不存在相邻两条边是平行的。\n\n接下来一行包含一个正整数q(1<=q<=100000)，表示询问的个数。\n\n接下来q行，每行一个正整数t\\_1,t\\_2,...,t\\_q(1<=t\\_i<=10^9)，依次表示每个询问。\n", "outputFormat": "输出q行，每行一个正整数，依次回答每个询问。\n", "hint": " ![](https://cdn.luogu.com.cn/upload/pic/4687.png) \n\n区间[3,29]、[33,33]和[36,37]组成最优3近似，其覆盖住的总面积为30。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CERC2016] Geohash Grid", "background": "", "description": "A \"geohash\" encodes 2D planar coordinates into integers, which facilitates storing and querying geographic data in databases. In this problem, a map is a $2^n \\times 2^n$ rectangular grid built on the standard 2D Cartesian coordinate system, where $x$ increases to the right and $y$ increases upward. A map cell is a unit square whose lower-left corner has integer coordinates $(x, y)$, where $0 \\le x, y < 2^n$.\n\nThere are $2^{2n}$ cells on the $2^n \\times 2^n$ map. For a cell $c$, its geohash value $h(c)$ is a non-negative $2n$-bit binary integer. Starting from the most significant bit and considering the entire map, repeat the following two steps $n$ times to obtain $h(c)$:\n\n1. Split the map into left and right regions of equal area. If cell $c$ lies in the left half, this bit is $0$; otherwise it is $1$. Then restrict the scope to the half that contains $c$.\n2. Split the map into bottom and top regions of equal area. If cell $c$ lies in the bottom half, this bit is $0$; otherwise it is $1$. Then restrict the scope to the half that contains $c$.\n\nA \"geohash interval\" $[a, b]$ denotes all cells whose hash values lie in $[a, b]$ (inclusive). In practice, we approximate a set on the map using a few geohash intervals. Given a set of cells $C$ and a positive integer $t$, the optimal $t$-approximation of $C$ is to use at most $t$ geohash intervals to cover all cells in $C$ (covering other cells is allowed) while minimizing the total covered area.\n\nYou are given a map and a cell set $C$, where $C$ is represented by a simple polygon whose edges are parallel to the coordinate axes. Then you are given $q$ queries $t_1, t_2, \\ldots, t_q$. For each query $t_k$, you need to output the area of the optimal $t_k$-approximation that covers $C$.", "inputFormat": "The first line contains a positive integer $n$ $(1 \\le n \\le 30)$, the base-2 logarithm of the map size.\n\nThe second line contains a positive integer $m$ $(4 \\le m \\le 200)$, the number of polygon vertices.\n\nEach of the next $m$ lines contains two integers $x_i, y_i$ $(0 \\le x_i, y_i \\le 2^n)$, giving the coordinates of the polygon’s vertices in counterclockwise order.\n\nThe input guarantees that the polygon is simple, its edges are parallel to the coordinate axes, and no two consecutive edges are parallel.\n\nThe next line contains a positive integer $q$ $(1 \\le q \\le 100000)$, the number of queries.\n\nEach of the next $q$ lines contains a positive integer $t_i$ $(1 \\le t_i \\le 10^9)$, the parameter of a query.", "outputFormat": "Output $q$ lines. For each query, output a single positive integer: the answer to that query.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/4687.png)\n\nThe intervals $[3, 29]$, $[33, 33]$, and $[36, 37]$ form an optimal $3$-approximation, whose total covered area is $30$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2016] 地理哈希网格 Geohash Grid", "background": "", "description": "“地理哈希”是一个将二维平面坐标编码为整数的过程，这将为数据库中地理数据的存储和查询带来方便。在这个问题中，一个地图是一个建立在标准二维笛卡尔坐标系上的2^n行2^n列的矩形网格，越往右x坐标越大，越往上y坐标越大。一个地图格子是一个单位正方形，满足其左下角的点的坐标为(x,y)，其中0<=x,y<2^n。\n\n\n在2^n行2^n列的地图上一共有2^(2n)个格子。对于一个格子c，它的地理哈希值h(c)是一个2n位的非负二进制整数。从最高位开始考虑整个地图，然后重复下面两个步骤n次，即可得到c的地理哈希值h(c)：\n\n\n1.把地图分成左右两个面积相等的区域，如果格子c在左半边，那么这一位是0，否则是1。然后将考虑范围缩小到c所在的那半边地图。\n\n\n2.把地图分成上下两个面积相等的区域，如果格子c在下半边，那么这一位是0，否则是1。然后将考虑范围缩小到c所在的那半边地图。\n\n\n一个“地理哈希区间”[a,b]表示所有哈希值在[a,b]之间的格子。通常应用中，我们会用一些地理哈希区间去近似表示地图。给定一个格子集合C，以及一个正整数t，那么C的最优t近似是指使用不超过t个地理哈希区间，覆盖住所有C中的格子（覆盖其它格子是允许的），同时满足覆盖住的区域的面积最小。\n\n\n给定一个地图以及一个格子集合C，C用一个边平行于坐标轴的简单多边形来表示。然后给定q个询问t\\_1,t\\_2,...,t\\_q，对于每个询问t\\_k，你需要求出C的最优t\\_k近似覆盖住的区域的面积。\n", "inputFormat": "第一行包含一个正整数n(1<=n<=30)，表示地图的尺寸的以2为底的对数。\n\n第二行包含一个正整数m(4<=m<=200)，表示多边形顶点的个数。\n\n接下来m行，每行两个整数x\\_i,y\\_i(0<=x\\_i,y\\_i<=2^n)，按逆时针依次表示多边形每个顶点的坐标。\n\n输入数据保证多边形不自交，边平行于坐标轴，且不存在相邻两条边是平行的。\n\n接下来一行包含一个正整数q(1<=q<=100000)，表示询问的个数。\n\n接下来q行，每行一个正整数t\\_1,t\\_2,...,t\\_q(1<=t\\_i<=10^9)，依次表示每个询问。\n", "outputFormat": "输出q行，每行一个正整数，依次回答每个询问。\n", "hint": " ![](https://cdn.luogu.com.cn/upload/pic/4687.png) \n\n区间[3,29]、[33,33]和[36,37]组成最优3近似，其覆盖住的总面积为30。\n", "locale": "zh-CN"}}}
{"pid": "P3684", "type": "P", "difficulty": 6, "samples": [["7\n.....#.\n...#.#.\n....#..\n....###\n....#..\n#......\n.......\n5\n2 5 5 2\n2 5 3 6\n2 2 6 3\n2 2 6 6\n1 1 7 7", "1\n0\n3\n1\n1"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2016", "Kruskal 重构树", "广度优先搜索 BFS", "生成树", "树链剖分", "ICPC", "CERC"], "title": "[CERC2016] 机棚障碍 Hangar Hurdles", "background": "", "description": "你正在评估一些关于一个巨型飞机仓库的建设计划。飞机仓库的地面可以表示为 $n$ 行 $n$ 列的网格图，其中每个格子要么是空的，要么有障碍物。行从上到下依次被编号为 $1$ 到 $n$，列从左到右依次被编号为 $1$ 到 $n$。\n\n存放飞机零件的大型集装箱能在飞机仓库的地面上自由移动是很重要的。我们可以将每个集装箱看作一个以某个格子为中心的边平行于坐标轴的正方形。对于一个奇数 $k$，一个尺寸为 $k$ 的集装箱是一个包含 $k$ 行 $k$ 列的正方形。一个集装箱的坐标为其中心格子的坐标。集装箱可以向上下左右移动，但不能碰到障碍物，且不能移出仓库的边界。\n\n给定 $q$ 对格子 $A_k$ 和 $B_k$，对于每对格子，请找到能从 $A_k$ 移动到 $B_k$ 的集装箱的最大尺寸，注意这个尺寸也要是一个奇数。", "inputFormat": "第一行包含一个正整数 $n$（$2\\le n \\le 1000$），表示仓库的尺寸。\n\n接下来 $n$ 行，每行 $n$ 个字符，描述整个仓库，其中 `.` 表示空格子，`#` 表示障碍物。\n\n接下来一行包含一个正整数 $q$（$1\\le q\\le 300000$），表示询问的个数。\n\n接下来 $q$ 行，每行四个正整数 $A_x,A_y,B_x,B_y$（$1\\le A_x,A_y,B_x,B_y\\le n$），分别表示 $A$ 和 $B$ 的坐标。\n\n输入数据保证 $A$ 和 $B$ 是不同的空格子。", "outputFormat": "输出 $q$ 行，每行一个整数，对于每个询问输出最大尺寸，如果不存在解，那么输出 $0$。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[CERC2016] Hangar Hurdles", "background": "", "description": "You are evaluating construction plans for a giant airplane hangar. The hangar floor can be represented as an $n \\times n$ grid, where each cell is either empty or contains an obstacle. Rows are numbered from $1$ to $n$ from top to bottom, and columns are numbered from $1$ to $n$ from left to right.\n\nIt is important that large containers for storing airplane parts can move freely on the floor. Each container can be seen as an axis-aligned square centered at some cell. For an odd integer $k$, a container of size $k$ is a square covering $k$ rows and $k$ columns. The coordinate of a container is the coordinate of its center cell. A container can move up, down, left, or right, but it cannot touch obstacles and cannot move outside the hangar boundary.\n\nGiven $q$ pairs of cells $A_k$ and $B_k$, for each pair, find the maximum size (also an odd integer) of a container that can move from $A_k$ to $B_k$.", "inputFormat": "The first line contains a positive integer $n$ ($2 \\le n \\le 1000$), the size of the hangar.\n\nThe next $n$ lines each contain $n$ characters describing the hangar, where `.` denotes an empty cell and `#` denotes an obstacle.\n\nThe next line contains a positive integer $q$ ($1 \\le q \\le 300000$), the number of queries.\n\nEach of the next $q$ lines contains four positive integers $A_x, A_y, B_x, B_y$ ($1 \\le A_x, A_y, B_x, B_y \\le n$), the coordinates of $A$ and $B$.\n\nIt is guaranteed that $A$ and $B$ are distinct empty cells.", "outputFormat": "Output $q$ lines, each with one integer. For each query, output the maximum size. If no solution exists, output $0$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2016] 机棚障碍 Hangar Hurdles", "background": "", "description": "你正在评估一些关于一个巨型飞机仓库的建设计划。飞机仓库的地面可以表示为 $n$ 行 $n$ 列的网格图，其中每个格子要么是空的，要么有障碍物。行从上到下依次被编号为 $1$ 到 $n$，列从左到右依次被编号为 $1$ 到 $n$。\n\n存放飞机零件的大型集装箱能在飞机仓库的地面上自由移动是很重要的。我们可以将每个集装箱看作一个以某个格子为中心的边平行于坐标轴的正方形。对于一个奇数 $k$，一个尺寸为 $k$ 的集装箱是一个包含 $k$ 行 $k$ 列的正方形。一个集装箱的坐标为其中心格子的坐标。集装箱可以向上下左右移动，但不能碰到障碍物，且不能移出仓库的边界。\n\n给定 $q$ 对格子 $A_k$ 和 $B_k$，对于每对格子，请找到能从 $A_k$ 移动到 $B_k$ 的集装箱的最大尺寸，注意这个尺寸也要是一个奇数。", "inputFormat": "第一行包含一个正整数 $n$（$2\\le n \\le 1000$），表示仓库的尺寸。\n\n接下来 $n$ 行，每行 $n$ 个字符，描述整个仓库，其中 `.` 表示空格子，`#` 表示障碍物。\n\n接下来一行包含一个正整数 $q$（$1\\le q\\le 300000$），表示询问的个数。\n\n接下来 $q$ 行，每行四个正整数 $A_x,A_y,B_x,B_y$（$1\\le A_x,A_y,B_x,B_y\\le n$），分别表示 $A$ 和 $B$ 的坐标。\n\n输入数据保证 $A$ 和 $B$ 是不同的空格子。", "outputFormat": "输出 $q$ 行，每行一个整数，对于每个询问输出最大尺寸，如果不存在解，那么输出 $0$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3685", "type": "P", "difficulty": 7, "samples": [["5\n1 2 0\n3 4 0\n1 4 3 0\n3 1 4 2 0\n1 2 4 3 0", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2016", "ICPC", "CERC"], "title": "[CERC2016] 不可见的整数 Invisible Integers", "background": "", "description": "《隐形的整数》是一个简单的猜数游戏。在这个游戏中，给定n个提示，玩家将尝试去猜一个仅包含自然数1到9的数字序列，满足所有n个提示。每个提示是一个包含若干互不相同的1到9之间的整数序列，它是这样生成的：\n\n\n1.随机选择一个序列中的位置作为起点。\n\n\n2.随机选择任意一个方向，左或者右。\n\n\n3.从起点开始沿着选定的方向走，遍历完这个方向的每个数字，将每个数字第一次出现的顺序记录下来。\n\n\n请找到长度最短的满足所有n个提示的序列。\n", "inputFormat": "第一行包含一个正整数n(1<=n<=10)，表示提示的个数。\n\n接下来n行，每行若干个互不相同的1到9之间的整数，依次表示每个提示，每一行以0为终止。\n", "outputFormat": "输出一行一个整数，即最短长度，若无解则输出-1。\n", "hint": "一个可行的序列是(1,2,1,4,1,3,4)。\n\n对于提示序列(1,2)，可以选择位置3，然后往左走。\n\n对于提示序列(3,4)，可以选择位置6，然后往右走。\n\n对于提示序列(1,4,3)，可以选择位置3，然后往右走。\n\n对于提示序列(3,1,4,2)，可以选择位置6，然后往左走。\n\n对于提示序列(1,2,4,3)，可以选择位置1，然后往右走。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CERC2016] Invisible Integers", "background": "", "description": "“Invisible Integers” is a simple number-guessing game. In this game, given $n$ hints, the player tries to guess a sequence consisting only of the digits 1 to 9, such that all $n$ hints are satisfied. Each hint is a sequence of pairwise distinct integers between 1 and 9, generated as follows:\n\n1. Randomly choose a position in the sequence as the starting point.\n2. Randomly choose a direction, either left or right.\n3. Starting from the chosen position and moving along the chosen direction to the end, record, in order, the first time each digit is seen.\n\nFind a sequence of minimum length that satisfies all $n$ hints.", "inputFormat": "The first line contains a positive integer $n$ ($1 \\le n \\le 10$), the number of hints.\n\nEach of the next $n$ lines contains a hint: several pairwise distinct integers between 1 and 9, terminated by a 0.", "outputFormat": "Output a single integer: the minimum possible length. If there is no solution, output $-1$.", "hint": "One feasible sequence is (1, 2, 1, 4, 1, 3, 4).\n\nFor the hint (1, 2), you can choose position 3 and then walk to the left.\n\nFor the hint (3, 4), you can choose position 6 and then walk to the right.\n\nFor the hint (1, 4, 3), you can choose position 3 and then walk to the right.\n\nFor the hint (3, 1, 4, 2), you can choose position 6 and then walk to the left.\n\nFor the hint (1, 2, 4, 3), you can choose position 1 and then walk to the right.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2016] 不可见的整数 Invisible Integers", "background": "", "description": "《隐形的整数》是一个简单的猜数游戏。在这个游戏中，给定n个提示，玩家将尝试去猜一个仅包含自然数1到9的数字序列，满足所有n个提示。每个提示是一个包含若干互不相同的1到9之间的整数序列，它是这样生成的：\n\n\n1.随机选择一个序列中的位置作为起点。\n\n\n2.随机选择任意一个方向，左或者右。\n\n\n3.从起点开始沿着选定的方向走，遍历完这个方向的每个数字，将每个数字第一次出现的顺序记录下来。\n\n\n请找到长度最短的满足所有n个提示的序列。\n", "inputFormat": "第一行包含一个正整数n(1<=n<=10)，表示提示的个数。\n\n接下来n行，每行若干个互不相同的1到9之间的整数，依次表示每个提示，每一行以0为终止。\n", "outputFormat": "输出一行一个整数，即最短长度，若无解则输出-1。\n", "hint": "一个可行的序列是(1,2,1,4,1,3,4)。\n\n对于提示序列(1,2)，可以选择位置3，然后往左走。\n\n对于提示序列(3,4)，可以选择位置6，然后往右走。\n\n对于提示序列(1,4,3)，可以选择位置3，然后往右走。\n\n对于提示序列(3,1,4,2)，可以选择位置6，然后往左走。\n\n对于提示序列(1,2,4,3)，可以选择位置1，然后往右走。\n", "locale": "zh-CN"}}}
{"pid": "P3686", "type": "P", "difficulty": 5, "samples": [["2 5\n1 2 1 2 1\n4\n1 2 R 6\n1 2 O 3\n2 1 O 3\n1 2 R 5", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2016", "哈希 hashing", "ICPC", "CERC"], "title": "[CERC2016] 爵士之旅 Jazz Journey", "background": "", "description": "Ivan 正在为他的爵士乐队计划一场规模盛大的欧洲巡演。在欧洲一共有 $n$ 个城市，编号依次为 $1 \\sim n$。Ivan 计划举办 $d$ 场演出，分别在城市 $a_1$，$a_2$，$\\dots$，$a_d$，并且严格遵循这个顺序，而且不会在同一个城市连续巡演两次（即 $a_i \\ne a_{i+1}$），但在整个过程中，他可能在一个城市巡演多次。最终，他一定会回到开始的城市进行巡演（即 $a_1 = a_d$）。\n\n\nIvan 每次总是选择搭乘一趟从 $a_i$ 到 $a_{i+1}$ 的直达航班。然而，他希望变得聪明一些，尽量节省机票的开支。你也知道，机票的价格取决于供给和需求，比如一张单程票可能会比相同目的地的双程票还要贵。\n\n\n一共有两种可以购买的机票：\n\n\n1.从 $a$ 到 $b$ 的单程票，每张只能从 $a$ 飞到 $b$ 一次，但不能从 $b$ 飞到 $a$。\n\n\n2.从a到b的双程票，只需购买一张，就能从 $a$ 飞到 $b$ 一次，然后从 $b$ 飞回 $a$ 一次，但先从 $b$ 飞回 $a$ 是不允许的。当然，你也可以选择从 $a$ 飞到 $b$ 之后就再也不返回 $a$。\n\n\n给定可以购买的机票集合，每种机票都是无限量供应的。请帮助 Ivan 找到一种最省钱的方案。你可以认为合法方案必然存在。", "inputFormat": "第一行包含两个正整数 $n$,$d$($2 \\le n,d \\le 3 \\times 10^5$)，分别表示城市的个数和巡演的次数。\n\n第二行包含 $d$ 个正整数 $a_1,a_2,\\dots,a_d$($1 \\le a_i \\le n,a_i \\ne a_{i+1},a_1 = a_d$)，依次表示巡演计划中每一场所在的城市。\n\n接下来一行包含一个正整数 $m$($3 \\le m \\le 3 \\times 10^5$)，表示机票的种类数。\n\n接下来 $m$ 行，每行首先是两个正整数 $s_i,d_i$($1 \\le s_i,d_i \\le n,s_i \\ne d_i$)，分别表示起点与终点；接下来一个字符 $t_i$，表示机票的类型，其中“O”表示单程票，“R”表示双程票；最后是一个正整数 $p_i$($1 \\le p_i \\le 10^9$)，表示票价。", "outputFormat": "输出一行一个整数，即完成巡演所需支付的最小机票总费用。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[CERC2016] Jazz Journey", "background": "", "description": "Ivan is planning a grand European tour for his jazz band. There are $n$ cities in Europe, labeled $1 \\sim n$. Ivan plans to hold $d$ concerts in cities $a_1, a_2, \\dots, a_d$ in this exact order, and he will never perform in the same city twice in a row (that is, $a_i \\ne a_{i+1}$). However, over the whole tour, he may visit the same city multiple times. In the end, he will return to the starting city to perform (that is, $a_1 = a_d$).\n\nEach time, Ivan takes a direct flight from $a_i$ to $a_{i+1}$. He wants to be smart and minimize the total cost of tickets. As you know, prices depend on supply and demand: for example, a one-way ticket might even be more expensive than a round-trip ticket for the same pair of cities.\n\nThere are two types of tickets available:\n\n1. A one-way ticket from $a$ to $b$, which allows exactly one flight from $a$ to $b$, but not from $b$ to $a$.\n\n2. A round-trip ticket from $a$ to $b$: buying one allows one flight from $a$ to $b$, and then one flight from $b$ back to $a$, but you are not allowed to use it in the reverse order. Of course, you may choose not to fly back after going from $a$ to $b$.\n\nYou are given the set of available tickets, with unlimited supply of each type. Please help Ivan find the minimum possible total cost. You may assume that at least one valid plan exists.", "inputFormat": "The first line contains two positive integers $n, d$ ($2 \\le n, d \\le 3 \\times 10^5$), the number of cities and the number of concerts.\n\nThe second line contains $d$ positive integers $a_1, a_2, \\dots, a_d$ ($1 \\le a_i \\le n, a_i \\ne a_{i+1}, a_1 = a_d$), indicating the city of each concert in order.\n\nThe next line contains a positive integer $m$ ($3 \\le m \\le 3 \\times 10^5$), the number of ticket types.\n\nEach of the next $m$ lines contains two positive integers $s_i, d_i$ ($1 \\le s_i, d_i \\le n, s_i \\ne d_i$), the start and end cities; followed by a character $t_i$ indicating the ticket type, where \"O\" means a one-way ticket and \"R\" means a round-trip ticket; and finally a positive integer $p_i$ ($1 \\le p_i \\le 10^9$), the ticket price.", "outputFormat": "Output a single integer: the minimum total ticket cost to complete the tour.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC2016] 爵士之旅 Jazz Journey", "background": "", "description": "Ivan 正在为他的爵士乐队计划一场规模盛大的欧洲巡演。在欧洲一共有 $n$ 个城市，编号依次为 $1 \\sim n$。Ivan 计划举办 $d$ 场演出，分别在城市 $a_1$，$a_2$，$\\dots$，$a_d$，并且严格遵循这个顺序，而且不会在同一个城市连续巡演两次（即 $a_i \\ne a_{i+1}$），但在整个过程中，他可能在一个城市巡演多次。最终，他一定会回到开始的城市进行巡演（即 $a_1 = a_d$）。\n\n\nIvan 每次总是选择搭乘一趟从 $a_i$ 到 $a_{i+1}$ 的直达航班。然而，他希望变得聪明一些，尽量节省机票的开支。你也知道，机票的价格取决于供给和需求，比如一张单程票可能会比相同目的地的双程票还要贵。\n\n\n一共有两种可以购买的机票：\n\n\n1.从 $a$ 到 $b$ 的单程票，每张只能从 $a$ 飞到 $b$ 一次，但不能从 $b$ 飞到 $a$。\n\n\n2.从a到b的双程票，只需购买一张，就能从 $a$ 飞到 $b$ 一次，然后从 $b$ 飞回 $a$ 一次，但先从 $b$ 飞回 $a$ 是不允许的。当然，你也可以选择从 $a$ 飞到 $b$ 之后就再也不返回 $a$。\n\n\n给定可以购买的机票集合，每种机票都是无限量供应的。请帮助 Ivan 找到一种最省钱的方案。你可以认为合法方案必然存在。", "inputFormat": "第一行包含两个正整数 $n$,$d$($2 \\le n,d \\le 3 \\times 10^5$)，分别表示城市的个数和巡演的次数。\n\n第二行包含 $d$ 个正整数 $a_1,a_2,\\dots,a_d$($1 \\le a_i \\le n,a_i \\ne a_{i+1},a_1 = a_d$)，依次表示巡演计划中每一场所在的城市。\n\n接下来一行包含一个正整数 $m$($3 \\le m \\le 3 \\times 10^5$)，表示机票的种类数。\n\n接下来 $m$ 行，每行首先是两个正整数 $s_i,d_i$($1 \\le s_i,d_i \\le n,s_i \\ne d_i$)，分别表示起点与终点；接下来一个字符 $t_i$，表示机票的类型，其中“O”表示单程票，“R”表示双程票；最后是一个正整数 $p_i$($1 \\le p_i \\le 10^9$)，表示票价。", "outputFormat": "输出一行一个整数，即完成巡演所需支付的最小机票总费用。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3687", "type": "P", "difficulty": 6, "samples": [["2\n3 2\n1 2\n1 3\n5 4\n1 2\n2 3\n2 4\n1 5", "2\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "各省省选", "浙江", "O2优化", "枚举", "仙人掌"], "title": "[ZJOI2017] 仙人掌", "background": null, "description": "如果一个**无自环无重边无向连通图**的任意一条边最多属于一个简单环，我们就称之为仙人掌。所谓简单环即不经过重复的结点的环。\n\n ![](https://cdn.luogu.com.cn/upload/pic/4742.png) \n\n现在九条可怜手上有一张**无自环无重边的无向连通图**，但是她觉得这张图中的边数太少了，所以她想要在图上连上一些新的边。同时为了方便的存储这张无向图，图中的边数又不能太多。经过权衡，她想要加边后得到的图为一棵仙人掌。\n\n不难发现合法的加边方案有很多，可怜想要知道总共有多少不同的加边方案。\n\n两个加边方案是不同的当且仅当一个方案中存在一条另一个方案中没有的边。", "inputFormat": "多组数据，第一行输入一个整数 $T$ 表示数据组数。\n\n每组数据第一行输入两个整数 $n,m$，表示图中的点数与边数。\n\n接下来 m 行，每行两个整数 $u,v(1\\le u,v\\le n,u\\ne v)$ 表示图中的一条边。保证输入的图联通且没有自环与重边。", "outputFormat": "对于每组数据，输出一个整数表示方案数，当然方案数可能很大，请对 $998244353$ 取模后输出。", "hint": "**样例说明**\n\n对于第一组样例合法加边的方案有 $\\{\\},\\{(2,3)\\}$，共 $2$ 种。\n\n**数据范围**\n\n![](https://cdn.luogu.com.cn/upload/pic/4743.png)", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2017] Cactus", "background": "", "description": "If, in an undirected connected graph with no self-loops and no multiple edges, every edge belongs to at most one simple cycle, we call it a cactus. A simple cycle is a cycle that does not pass through any vertex more than once.\n\n![](https://cdn.luogu.com.cn/upload/pic/4742.png)\n\nNow Jiutiao Kelian has an undirected connected graph with no self-loops and no multiple edges, but she thinks the graph has too few edges, so she wants to add some new edges to it. Meanwhile, to store this undirected graph conveniently, the number of edges should not be too large. After weighing these factors, she wants the graph obtained after adding edges to be a cactus.\n\nIt is not hard to see that there are many valid ways to add edges. She wants to know how many different ways there are in total.\n\nTwo ways of adding edges are different if and only if there exists an edge that is in one way but not in the other.", "inputFormat": "Multiple test cases. The first line contains an integer $T$ denoting the number of test cases.\n\nFor each test case, the first line contains two integers $n, m$, denoting the number of vertices and the number of edges.\n\nThen $m$ lines follow. Each line contains two integers $u, v$ ($1 \\le u, v \\le n, u \\ne v$) describing an edge. It is guaranteed that the input graph is connected and has no self-loops or multiple edges.", "outputFormat": "For each test case, output one integer denoting the number of valid ways. Since the answer may be large, output it modulo $998244353$.", "hint": "Sample explanation.\n\nFor the first sample, the valid ways are $\\{\\}, \\{(2,3)\\}$, for a total of $2$.\n\nConstraints\n\n![](https://cdn.luogu.com.cn/upload/pic/4743.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2017] 仙人掌", "background": null, "description": "如果一个**无自环无重边无向连通图**的任意一条边最多属于一个简单环，我们就称之为仙人掌。所谓简单环即不经过重复的结点的环。\n\n ![](https://cdn.luogu.com.cn/upload/pic/4742.png) \n\n现在九条可怜手上有一张**无自环无重边的无向连通图**，但是她觉得这张图中的边数太少了，所以她想要在图上连上一些新的边。同时为了方便的存储这张无向图，图中的边数又不能太多。经过权衡，她想要加边后得到的图为一棵仙人掌。\n\n不难发现合法的加边方案有很多，可怜想要知道总共有多少不同的加边方案。\n\n两个加边方案是不同的当且仅当一个方案中存在一条另一个方案中没有的边。", "inputFormat": "多组数据，第一行输入一个整数 $T$ 表示数据组数。\n\n每组数据第一行输入两个整数 $n,m$，表示图中的点数与边数。\n\n接下来 m 行，每行两个整数 $u,v(1\\le u,v\\le n,u\\ne v)$ 表示图中的一条边。保证输入的图联通且没有自环与重边。", "outputFormat": "对于每组数据，输出一个整数表示方案数，当然方案数可能很大，请对 $998244353$ 取模后输出。", "hint": "**样例说明**\n\n对于第一组样例合法加边的方案有 $\\{\\},\\{(2,3)\\}$，共 $2$ 种。\n\n**数据范围**\n\n![](https://cdn.luogu.com.cn/upload/pic/4743.png)", "locale": "zh-CN"}}}
{"pid": "P3688", "type": "P", "difficulty": 6, "samples": [["5 5\n1 3 3\n2 3 5\n2 4 5\n1 1 3\n2 2 5", "1\n0\n665496236"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "线段树", "各省省选", "树状数组", "浙江"], "title": "[ZJOI2017] 树状数组", "background": "", "description": "漆黑的晚上，九条可怜躺在床上辗转反侧。难以入眠的她想起了若干年前她的一次悲惨的 OI 比赛经历。那是一道基础的树状数组题。\n\n给出一个长度为 $n$ 的数组 $A$，初始值都为 $0$，接下来进行 $m$ 次操作，操作有两种：\n\n* $1\\ x$，表示将 $A_x$  变成 $(A_x + 1) \\bmod 2$。\n* $2\\ l\\ r$，表示询问 $(\\sum_{i=l}^r A_i) \\bmod 2$。\n\n尽管那个时候的可怜非常的 simple，但是她还是发现这题可以用树状数组做。当时非常 young 的她写了如下的算法：\n\n![](https://cdn.luogu.com.cn/upload/pic/4744.png)\n\n其中 $\\mathrm{lowbit}(x)$ 表示数字 $x$ **最低**的非 $0$ 二进制位，例如 $\\text{lowbit}(5) = 1, \\text{lowbit}(12) = 4$。进行第一类操作的时候就调用 $\\mathrm{Add}(x)$，第二类操作的时候答案就是 $\\mathrm{Query}(l, r)$。\n\n如果你对树状数组比较熟悉，不难发现可怜把树状数组写错了：**$\\text{Add}$ 和 $\\text{Find}$ 中 $x$  变化的方向反了**。因此这个程序在最终测试时华丽的爆 0 了。\n\n然而奇怪的是，在当时，这个程序通过了出题人给出的大样例——这也是可怜没有进行对拍的原因。\n\n现在，可怜想要算一下，这个程序回答对每一个询问的概率是多少，这样她就可以再次的感受到自己是一个多么非的人了。然而时间已经过去了很多年，即使是可怜也没有办法完全回忆起当时的大样例。幸运的是，她回忆起了大部分内容，唯一遗忘的是每一次第一类操作的 $x$ 的值，因此她假定这次操作的 $x$ 是在 $[l_i, r_i]$  范围内**等概率随机**的。\n\n具体来说，可怜给出了一个长度为 $n$ 的数组 $A$，初始为 $0$，接下来进行了 $m$ 次操作：\n\n* $1\\ l\\ r$，表示在区间 $[l, r]$ 中等概率选取一个 $x$ 并执行 $\\text{Add}(x)$ 。\n\n* $2\\ l\\ r$，表示询问执行 $\\text{Query}(l, r)$ 得到的结果是正确的概率是多少。", "inputFormat": "第一行输入两个整数 $n,m$。\n\n接下来 $m$ 行每行描述一个操作，格式如题目中所示。\n", "outputFormat": "对于每组询问，输出一个整数表示答案。如果答案化为最简分数后形如 $\\frac x y$，那么你只需要输出 $x\\times y^{-1} \\bmod 998244353$ 后的值（即输出答案模 $998244353$）。", "hint": "#### 样例说明\n\n在进行完 $\\mathrm{Add}(3)$ 之后，$A$ 数组变成了 $[0, 1, 1, 0, 0]$。所以前两次询问可怜的程序答案都是 $1$，因此第一次询问可怜一定正确，第二次询问可怜一定错误。\n\n#### 数据范围\n\n| 测试点编号 |        $n$         |              $m$               |      其他约定      |\n| :--------: | :----------------: | :----------------------------: | :----------------: |\n|    $1$     |      $\\le 5$       |            $\\le 10$            |         无         |\n|    $2$     |      $\\le 50$      |      $\\le 50$      |         无         |\n|    $3$     |      $\\le 50$      |      $\\le 50$      |         无         |\n|    $4$     | $\\le 3\\times 10^3$ | $\\le 3\\times 10^3$ |         无         |\n|    $5$     | $\\le 3\\times 10^3$ | $\\le 3\\times 10^3$ |         无         |\n|    $6$     |       $10^5$       |       $10^5$       | 所有询问都在修改后 |\n|    $7$     |       $10^5$       |       $10^5$       | 所有询问都在修改后 |\n|    $8$     |       $10^5$       |       $10^5$       |         无         |\n|    $9$     |       $10^5$       |       $10^5$       |         无         |\n|    $10$    |       $10^5$       |       $10^5$       |         无         |\n\n\n对于 $100\\%$ 的数据，保证 $1\\leq l\\leq r\\leq n$。\n\n更新：2018/05/13 @larryzhong 提供了 5 组强的数据。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2017] Binary Indexed Tree", "background": "", "description": "On a dark night, Kurousagi Kotori tossed and turned in bed. Unable to sleep, she remembered a tragic OI contest experience years ago. It was a basic Binary Indexed Tree problem.\n\nGiven an array $A$ of length $n$, initially all $0$, perform $m$ operations of two types:\n\n- $1\\ x$: set $A_x$ to $(A_x + 1) \\bmod 2$.\n- $2\\ l\\ r$: ask for $(\\sum_{i=l}^r A_i) \\bmod 2$.\n\nAlthough Kotori was quite simple back then, she still noticed that this problem could be solved using a Binary Indexed Tree. When she was very young, she wrote the following algorithm:\n\n![](https://cdn.luogu.com.cn/upload/pic/4744.png)\n\nHere $\\mathrm{lowbit}(x)$ denotes the lowest nonzero binary bit of number $x$, e.g., $\\text{lowbit}(5) = 1, \\text{lowbit}(12) = 4$. For the first type of operation she calls $\\mathrm{Add}(x)$, and for the second type the answer is $\\mathrm{Query}(l, r)$.\n\nIf you are familiar with Binary Indexed Trees, it is not hard to see that Kotori wrote it incorrectly: the direction in which $x$ changes in $\\text{Add}$ and $\\text{Find}$ is reversed. Therefore, this program spectacularly got a score of $0$ in the final test.\n\nStrangely, at that time, this program passed the large sample test provided by the problem setter—this is also why Kotori did not conduct stress testing.\n\nNow, Kotori wants to compute the probability that this program answers each query correctly, so she can once again feel how “fei” she was. However, many years have passed, and even Kotori cannot fully remember the large sample. Fortunately, she recalls most of it; the only thing she forgot is the value of $x$ for each type 1 operation, so she assumes that $x$ is chosen uniformly at random from the range $[l_i, r_i]$ for that operation.\n\nSpecifically, Kotori gives an array $A$ of length $n$, initially $0$, and then performs $m$ operations:\n\n- $1\\ l\\ r$: uniformly at random pick an $x$ in the interval $[l, r]$ and execute $\\text{Add}(x)$.\n- $2\\ l\\ r$: ask for the probability that executing $\\text{Query}(l, r)$ yields the correct result.", "inputFormat": "The first line contains two integers $n, m$.\n\nEach of the next $m$ lines describes one operation in the format specified above.", "outputFormat": "For each query, output one integer representing the answer. If the simplified fraction of the answer is $\\frac x y$, you only need to output the value of $x \\times y^{-1} \\bmod 998244353$ (that is, output the answer modulo $998244353$).", "hint": "- Sample Explanation:\n\n  After performing $\\mathrm{Add}(3)$, the array $A$ becomes $[0, 1, 1, 0, 0]$. Therefore, the program’s answers for the first two queries are both $1$. Hence, the first query is certainly correct, and the second query is certainly incorrect.\n\n- Constraints:\n\n  - Test point 1: $n \\le 5$, $m \\le 10$, no additional constraints.\n  - Test point 2: $n \\le 50$, $m \\le 50$, no additional constraints.\n  - Test point 3: $n \\le 50$, $m \\le 50$, no additional constraints.\n  - Test point 4: $n \\le 3 \\times 10^3$, $m \\le 3 \\times 10^3$, no additional constraints.\n  - Test point 5: $n \\le 3 \\times 10^3$, $m \\le 3 \\times 10^3$, no additional constraints.\n  - Test point 6: $n = 10^5$, $m = 10^5$, all queries occur after updates.\n  - Test point 7: $n = 10^5$, $m = 10^5$, all queries occur after updates.\n  - Test point 8: $n = 10^5$, $m = 10^5$, no additional constraints.\n  - Test point 9: $n = 10^5$, $m = 10^5$, no additional constraints.\n  - Test point 10: $n = 10^5$, $m = 10^5$, no additional constraints.\n\n  For $100\\%$ of the testdata, it is guaranteed that $1 \\le l \\le r \\le n$.\n\n  Update: 2018/05/13 @larryzhong provided 5 stronger testdata sets.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2017] 树状数组", "background": "", "description": "漆黑的晚上，九条可怜躺在床上辗转反侧。难以入眠的她想起了若干年前她的一次悲惨的 OI 比赛经历。那是一道基础的树状数组题。\n\n给出一个长度为 $n$ 的数组 $A$，初始值都为 $0$，接下来进行 $m$ 次操作，操作有两种：\n\n* $1\\ x$，表示将 $A_x$  变成 $(A_x + 1) \\bmod 2$。\n* $2\\ l\\ r$，表示询问 $(\\sum_{i=l}^r A_i) \\bmod 2$。\n\n尽管那个时候的可怜非常的 simple，但是她还是发现这题可以用树状数组做。当时非常 young 的她写了如下的算法：\n\n![](https://cdn.luogu.com.cn/upload/pic/4744.png)\n\n其中 $\\mathrm{lowbit}(x)$ 表示数字 $x$ **最低**的非 $0$ 二进制位，例如 $\\text{lowbit}(5) = 1, \\text{lowbit}(12) = 4$。进行第一类操作的时候就调用 $\\mathrm{Add}(x)$，第二类操作的时候答案就是 $\\mathrm{Query}(l, r)$。\n\n如果你对树状数组比较熟悉，不难发现可怜把树状数组写错了：**$\\text{Add}$ 和 $\\text{Find}$ 中 $x$  变化的方向反了**。因此这个程序在最终测试时华丽的爆 0 了。\n\n然而奇怪的是，在当时，这个程序通过了出题人给出的大样例——这也是可怜没有进行对拍的原因。\n\n现在，可怜想要算一下，这个程序回答对每一个询问的概率是多少，这样她就可以再次的感受到自己是一个多么非的人了。然而时间已经过去了很多年，即使是可怜也没有办法完全回忆起当时的大样例。幸运的是，她回忆起了大部分内容，唯一遗忘的是每一次第一类操作的 $x$ 的值，因此她假定这次操作的 $x$ 是在 $[l_i, r_i]$  范围内**等概率随机**的。\n\n具体来说，可怜给出了一个长度为 $n$ 的数组 $A$，初始为 $0$，接下来进行了 $m$ 次操作：\n\n* $1\\ l\\ r$，表示在区间 $[l, r]$ 中等概率选取一个 $x$ 并执行 $\\text{Add}(x)$ 。\n\n* $2\\ l\\ r$，表示询问执行 $\\text{Query}(l, r)$ 得到的结果是正确的概率是多少。", "inputFormat": "第一行输入两个整数 $n,m$。\n\n接下来 $m$ 行每行描述一个操作，格式如题目中所示。\n", "outputFormat": "对于每组询问，输出一个整数表示答案。如果答案化为最简分数后形如 $\\frac x y$，那么你只需要输出 $x\\times y^{-1} \\bmod 998244353$ 后的值（即输出答案模 $998244353$）。", "hint": "#### 样例说明\n\n在进行完 $\\mathrm{Add}(3)$ 之后，$A$ 数组变成了 $[0, 1, 1, 0, 0]$。所以前两次询问可怜的程序答案都是 $1$，因此第一次询问可怜一定正确，第二次询问可怜一定错误。\n\n#### 数据范围\n\n| 测试点编号 |        $n$         |              $m$               |      其他约定      |\n| :--------: | :----------------: | :----------------------------: | :----------------: |\n|    $1$     |      $\\le 5$       |            $\\le 10$            |         无         |\n|    $2$     |      $\\le 50$      |      $\\le 50$      |         无         |\n|    $3$     |      $\\le 50$      |      $\\le 50$      |         无         |\n|    $4$     | $\\le 3\\times 10^3$ | $\\le 3\\times 10^3$ |         无         |\n|    $5$     | $\\le 3\\times 10^3$ | $\\le 3\\times 10^3$ |         无         |\n|    $6$     |       $10^5$       |       $10^5$       | 所有询问都在修改后 |\n|    $7$     |       $10^5$       |       $10^5$       | 所有询问都在修改后 |\n|    $8$     |       $10^5$       |       $10^5$       |         无         |\n|    $9$     |       $10^5$       |       $10^5$       |         无         |\n|    $10$    |       $10^5$       |       $10^5$       |         无         |\n\n\n对于 $100\\%$ 的数据，保证 $1\\leq l\\leq r\\leq n$。\n\n更新：2018/05/13 @larryzhong 提供了 5 组强的数据。", "locale": "zh-CN"}}}
{"pid": "P3689", "type": "P", "difficulty": 7, "samples": [["1\n3 3 2 1 10\n1011\n01", "2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "各省省选", "浙江", "O2优化"], "title": "[ZJOI2017] 多项式", "background": "", "description": "九条可怜最近研究了一下多项式在系数模 2 意义下的性质。她发现可以用多项式在模 2 意义下的乘法得到一个很长的字符串：\n\n对于一个 $n$ 次的系数为 0 或 1 的多项式 $f\\left ( x \\right )$，我们在模 2 意义下计算 $g\\left ( x \\right ) = f\\left ( x \\right )^{m}$，则\n\n$g\\left ( x \\right )$ 为一个 $nm$ 次的多项式，它有 $nm + 1$ 个系数，将这些系数从**高位到低位**写下来，就可以得到一个长度为 $nm + 1$ 的 01 字符串。\n\n例如对于多项式 $f\\left ( x \\right ) = x^{3} + x + 1$，计算 $g\\left( x \\right ) = f\\left( x \\right)^{3} = x^{9} + x^{7} + x^{6} + x^{5} + x^{2} + x^{1} + 1 $，这样我们得到了一个长度为 10 的字符串 1011100111。\n\n现在可怜有一个次数为 $n$ 的多项式 $f\\left( x \\right )$，整数 $m$, $L$, $R$ 以及一个长度为 $K$ 的 01 串 $t$。令 $s$为 $f\\left( x \\right )^{m}$得到的字符串， $s\\left[L, R\\right]$ 为 $s$ 的第 $L$ 个字符到第 $R$ 个字符，可怜想要知道 $t$ 在 $s\\left[L, R\\right]$中出现了多少次。\n", "inputFormat": "第一行输入一个整数 T 表示数据组数。\n\n每组数据第一行输入五个整数 $n, m, K, L, R$。\n\n第二行输入一个长度为 $n + 1$ 的 01 串表示多项式 $f\\left( x \\right )$ 的系数，其中第 $i$ 位表示 $f\\left( x \\right )$ 的第 $n − i + 1$ 次系数。\n\n第三行输入一个长度为 $K$ 的字符串表示字符串 $t$。\n", "outputFormat": "对于每组数据输出一个整数表示答案。\n", "hint": "**时空限制**\n\n时间限制3s，空间限制512M\n\n**数据范围**\n\n![](https://cdn.luogu.com.cn/upload/pic/4746.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2017] Polynomial", "background": "", "description": "Kotori Itsuka recently studied the properties of polynomials with coefficients modulo 2. She found that one can obtain a very long string using multiplication of polynomials modulo 2:\n\nFor an $n$-degree polynomial $f\\left( x \\right)$ with coefficients 0 or 1, we compute $g\\left( x \\right) = f\\left( x \\right)^{m}$ modulo 2. Then $g\\left( x \\right)$ is an $nm$-degree polynomial with $nm + 1$ coefficients. Writing these coefficients from the highest degree to the lowest degree gives a 01 string of length $nm + 1$.\n\nFor example, for the polynomial $f\\left( x \\right) = x^{3} + x + 1$, we compute $g\\left( x \\right) = f\\left( x \\right)^{3} = x^{9} + x^{7} + x^{6} + x^{5} + x^{2} + x^{1} + 1$, thus we obtain a string of length 10: 1011100111.\n\nNow given a polynomial $f\\left( x \\right)$ of degree $n$, integers $m$, $L$, $R$, and a 01 string $t$ of length $K$. Let $s$ be the string obtained from $f\\left( x \\right)^{m}$, and let $s\\left[ L, R \\right]$ denote the substring from the $L$-th character to the $R$-th character of $s$. Kotori wants to know how many times $t$ appears in $s\\left[ L, R \\right]$.", "inputFormat": "The first line contains an integer $T$ denoting the number of test cases.\n\nFor each test case, the first line contains five integers $n, m, K, L, R$.\n\nThe second line contains a 01 string of length $n + 1$ representing the coefficients of the polynomial $f\\left( x \\right)$. The $i$-th character represents the coefficient of degree $n - i + 1$ of $f\\left( x \\right)$.\n\nThe third line contains a string of length $K$ representing the string $t$.", "outputFormat": "For each test case, output a single integer denoting the answer.", "hint": "Time and Space Limit\n\nTime limit: 3 s, Memory limit: 512 MB.\n\nConstraints\n\n![](https://cdn.luogu.com.cn/upload/pic/4746.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2017] 多项式", "background": "", "description": "九条可怜最近研究了一下多项式在系数模 2 意义下的性质。她发现可以用多项式在模 2 意义下的乘法得到一个很长的字符串：\n\n对于一个 $n$ 次的系数为 0 或 1 的多项式 $f\\left ( x \\right )$，我们在模 2 意义下计算 $g\\left ( x \\right ) = f\\left ( x \\right )^{m}$，则\n\n$g\\left ( x \\right )$ 为一个 $nm$ 次的多项式，它有 $nm + 1$ 个系数，将这些系数从**高位到低位**写下来，就可以得到一个长度为 $nm + 1$ 的 01 字符串。\n\n例如对于多项式 $f\\left ( x \\right ) = x^{3} + x + 1$，计算 $g\\left( x \\right ) = f\\left( x \\right)^{3} = x^{9} + x^{7} + x^{6} + x^{5} + x^{2} + x^{1} + 1 $，这样我们得到了一个长度为 10 的字符串 1011100111。\n\n现在可怜有一个次数为 $n$ 的多项式 $f\\left( x \\right )$，整数 $m$, $L$, $R$ 以及一个长度为 $K$ 的 01 串 $t$。令 $s$为 $f\\left( x \\right )^{m}$得到的字符串， $s\\left[L, R\\right]$ 为 $s$ 的第 $L$ 个字符到第 $R$ 个字符，可怜想要知道 $t$ 在 $s\\left[L, R\\right]$中出现了多少次。\n", "inputFormat": "第一行输入一个整数 T 表示数据组数。\n\n每组数据第一行输入五个整数 $n, m, K, L, R$。\n\n第二行输入一个长度为 $n + 1$ 的 01 串表示多项式 $f\\left( x \\right )$ 的系数，其中第 $i$ 位表示 $f\\left( x \\right )$ 的第 $n − i + 1$ 次系数。\n\n第三行输入一个长度为 $K$ 的字符串表示字符串 $t$。\n", "outputFormat": "对于每组数据输出一个整数表示答案。\n", "hint": "**时空限制**\n\n时间限制3s，空间限制512M\n\n**数据范围**\n\n![](https://cdn.luogu.com.cn/upload/pic/4746.png)\n", "locale": "zh-CN"}}}
{"pid": "P3690", "type": "P", "difficulty": 6, "samples": [["3 3 \n1\n2\n3\n1 1 2\n0 1 2 \n0 1 1", "3\n1\n"], ["5 14\n114\n514\n19\n19\n810\n1 1 2\n0 1 2\n2 1 2\n1 1 2\n1 2 3\n2 1 3\n1 1 3\n1 4 5\n1 2 5\n0 3 5\n0 3 4\n3 5 233333\n0 1 5\n0 2 5\n", "624\n315\n296\n232709\n232823\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化", "树链剖分", "动态树 LCT", "模板题"], "title": "【模板】动态树（LCT）", "background": "", "description": "给定 $n$ 个点以及每个点的权值，要你处理接下来的 $m$ 个操作。  \n操作有四种，操作从 $0$ 到 $3$ 编号。点从 $1$ 到 $n$ 编号。\n\n\n- `0 x y` 代表询问从 $x$ 到 $y$ 的路径上的点的权值的 $\\text{xor}$ 和。保证 $x$ 到 $y$ 是联通的。\n- `1 x y` 代表连接 $x$ 到 $y$，若 $x$ 到 $y$ 已经联通则无需连接。\n- `2 x y` 代表删除边 $(x,y)$，不保证边 $(x,y)$ 存在。\n- `3 x y` 代表将点 $x$ 上的权值变成 $y$。\n", "inputFormat": "第一行两个整数，分别为 $n$ 和 $m$，代表点数和操作数。\n\n接下来 $n$ 行，每行一个整数，第 $(i + 1)$ 行的整数 $a_i$ 表示节点 $i$ 的权值。\n\n接下来 $m$ 行，每行三个整数，分别代表操作类型和操作所需的量。\n", "outputFormat": "对于每一个 $0$ 号操作，你须输出一行一个整数，表示 $x$ 到 $y$ 的路径上点权的 $\\text{xor}$ 和。\n", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n- $1 \\leq n \\leq 10^5$，$1 \\leq m \\leq 3 \\times 10^5$，$1 \\leq a_i \\leq 10^9$。\n- 对于操作 $0, 1, 2$，保证 $1 \\leq x, y \\leq n$。\n- 对于操作 $3$，保证 $1 \\leq x \\leq n$，$1 \\leq y \\leq 10^9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "【Template】Dynamic Tree (LCT)", "background": "", "description": "Given $n$ nodes and each node’s weight, you need to process the next $m$ operations.  \nThere are four types of operations, numbered from $0$ to $3$. Nodes are numbered from $1$ to $n$.\n\n- `0 x y` asks for the $\\text{xor}$ sum of the weights of the nodes on the path from $x$ to $y$. It is guaranteed that $x$ and $y$ are connected.\n- `1 x y` connects $x$ to $y$. If $x$ and $y$ are already connected, do nothing.\n- `2 x y` deletes the edge $(x, y)$. The existence of edge $(x, y)$ is not guaranteed.\n- `3 x y` sets the weight of node $x$ to $y$.", "inputFormat": "The first line contains two integers $n$ and $m$, representing the number of nodes and the number of operations.\n\nThe next $n$ lines each contain one integer. On the $(i + 1)$-th line, the integer $a_i$ denotes the weight of node $i$.\n\nThe next $m$ lines each contain three integers, representing the operation type and its parameters.", "outputFormat": "For each operation of type $0$, output one line with one integer, the $\\text{xor}$ sum of the node weights on the path from $x$ to $y$.", "hint": "Constraints and Conventions\n\nFor all testdata, it is guaranteed that:\n- $1 \\leq n \\leq 10^5$, $1 \\leq m \\leq 3 \\times 10^5$, $1 \\leq a_i \\leq 10^9$.\n- For operations $0, 1, 2$, it holds that $1 \\leq x, y \\leq n$.\n- For operation $3$, it holds that $1 \\leq x \\leq n$, $1 \\leq y \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】动态树（LCT）", "background": "", "description": "给定 $n$ 个点以及每个点的权值，要你处理接下来的 $m$ 个操作。  \n操作有四种，操作从 $0$ 到 $3$ 编号。点从 $1$ 到 $n$ 编号。\n\n\n- `0 x y` 代表询问从 $x$ 到 $y$ 的路径上的点的权值的 $\\text{xor}$ 和。保证 $x$ 到 $y$ 是联通的。\n- `1 x y` 代表连接 $x$ 到 $y$，若 $x$ 到 $y$ 已经联通则无需连接。\n- `2 x y` 代表删除边 $(x,y)$，不保证边 $(x,y)$ 存在。\n- `3 x y` 代表将点 $x$ 上的权值变成 $y$。\n", "inputFormat": "第一行两个整数，分别为 $n$ 和 $m$，代表点数和操作数。\n\n接下来 $n$ 行，每行一个整数，第 $(i + 1)$ 行的整数 $a_i$ 表示节点 $i$ 的权值。\n\n接下来 $m$ 行，每行三个整数，分别代表操作类型和操作所需的量。\n", "outputFormat": "对于每一个 $0$ 号操作，你须输出一行一个整数，表示 $x$ 到 $y$ 的路径上点权的 $\\text{xor}$ 和。\n", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n- $1 \\leq n \\leq 10^5$，$1 \\leq m \\leq 3 \\times 10^5$，$1 \\leq a_i \\leq 10^9$。\n- 对于操作 $0, 1, 2$，保证 $1 \\leq x, y \\leq n$。\n- 对于操作 $3$，保证 $1 \\leq x \\leq n$，$1 \\leq y \\leq 10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P3691", "type": "P", "difficulty": 3, "samples": [["4 4 0\n3.000 4.000 1\n3.000 3.000 -1\n8.000 3.000 -1\n8.000 4.000 1\n100.000 100.000\n0.000 0.000\n3.141 5.926\n0.618 1.618", "1\n-1\n1\n-1"]], "limits": {"time": [2000, 1000, 1000, 1000, 1000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创", "Special Judge", "随机化"], "title": "妖精大战争", "background": " ![](https://cdn.luogu.com.cn/upload/pic/4726.png) \n\n琪露诺一如既往忙碌地生活着。\n\n某天，在外出时她的家被人破坏了。\n\n损坏的家插着一面奇怪的旗。\n\n旗上画着似曾相识的几个妖精的图案。\n\n狂怒的琪露诺对旗的主人贴出了宣战告示。\n\n就这样，妖精们的大战争开始了。\n\n(摘自《妖精大战争》manual)\n", "description": "三月精 Sunny Milk, Lunar Child, Star Sapphire 为了让冰之妖精琪露诺加入她们的恶作剧计划，破坏了琪露诺的房子。琪露诺当然不会就此罢休，于是她找到了三月精准备进行复仇，复仇的方式是进行一场弹幕对决。 在Normal 难度下，Star Sapphire 在此次对战中不会出场，因此只有 Sunny Milk, Lunar Child两只妖精出场和琪露诺对决了。\n\n在一张符卡中，Sunny Milk 和 Lunar Child 发射的弹幕几乎填满了整个 $100\\times 100$ 的正方形战斗场地，并且恰好可以被一条静止不动，非垂直的直线划分成两部分，其中直线上方的部分是 Sunny Milk 发射的日光弹幕，直线下方的部分是 Lunar Child 发射的月光弹幕。\n\n琪露诺是最强的妖精，但她面对两只妖精密集的弹幕也会有些紧张。在她的干劲快要被消磨完时，琪露诺忽然发现，如果能用两种不同的策略来对付两种弹幕，获胜的希望将会大大增加。因此，她想知道一些关键的位置会出现什么弹幕。\n\n不幸的是，琪露诺无法判断出分界线在哪里，她只知道当前在战斗场地中每个弹幕的位置，和这个弹幕是月光弹幕还是日光弹幕。在极少情况下(至多 $0.1\\%$)，琪露诺可能会错误识别弹幕的类型，因为它们实在太像了。琪露诺想要了解的是，对于接下来可能出现弹幕的位置，如果出现了弹幕，它是月光弹幕还是日光弹幕。你能帮帮她吗？\n", "inputFormat": "第一行三个正整数 $n,m,x$。分别表示当前场地上弹幕的数量，和琪露诺想要了解情况的位置的数量，$x$ 表示当前是第几个测试点。\n\n接下来 $n$ 行，每行两个实数 $x,y$ 和一个整数 $k$，用空格隔开。表示在 $(x,y)$ 有一个种类为 $k$ 的弹幕，$k=1$ 为日光弹幕，$k=-1$ 为月光弹幕。\n\n接下来 $m$ 行，每行两个实数 $x,y$，表示琪露诺想知道这个位置如果出现弹幕，会出现什么类型的弹幕。", "outputFormat": "$m$ 行，每行一个整数 $1$ 或者 $-1$，对应每个询问的结果。\n\n$1$ 为日光弹幕，$-1$ 为月光弹幕。", "hint": "【样例解释】\n\n注：该数据因量过小，信息量不足而不合法，可能会发生无法得到准确答案的情况。因此仅供理解题意使用，不可用来测试程序。\n\n观察输入数据，我们发现当 $y=3$ 时，都是月光弹幕 $,y=4$ 时，都是日光弹幕。可以猜想直线在 $y=3 \\sim y=4$ 之间。\n\n因此对于四个询问分别回答 $1,-1,1,-1$。\n\n【数据范围和提示】\n\n单个弹幕的面积可视为 $0$。\n\n若询问的位置恰好落在分界线上，当做在分界线的下方处理。\n\n本题有 SpecialJudge。\n\n- 对于第 $1$ 个测试点：\n\n$N=100000$，$m=100000$。\n\n若你输出的答案中，正确回答的询问数量大于等于总询问数量的 $30\\%$，则可以获得该测试点的全部分数，否则得 $0$ 分。\n\n- 对于第 $2 \\sim 5$ 个测试点：\n\n$n=1000$，$m=1000$。\n\n若你输出的答案中，正确回答的询问数量大于等于总询问数量的 $60\\%$，则可以获得该测试点的全部分数，否则得 $0$ 分。\n\n- 对于第 $6 \\sim 7$ 个测试点，\n\n$n=100000$，$m=100000$。\n\n若你输出的答案中，正确回答的询问数量大于等于总询问数量的 $70\\%$，则可以获得该测试点的全部分数，否则得 $0$ 分。\n\n- 对于第 $8 \\sim 10$ 个测试点，\n\n$n=100000$，$m=100000$。\n\n若你输出的答案中，正确回答的询问数量大于等于总询问数量的 $80\\%$，则可以获得该测试点的全部分数，否则得 $0$ 分。\n\n- 对于 $100\\%$ 的数据：\n\n$0.000 \\le x,y \\le 100.000$。\n\n所有输入的实数均保留 $3$ 位小数。\n\n保证输入数据有合法的解能够满足题目要求的判定准确率。\n\n评测时限：对于测试点 $2 \\sim 5,$ 时限为 $1s$，其他测试点时限为 $2s$。", "locale": "zh-CN", "translations": {"en": {"title": "Fairy Wars", "background": "![](https://cdn.luogu.com.cn/upload/pic/4726.png)\n\nCirno lives a busy life as always.\n\nOne day, while she was out, her home was destroyed.\n\nA strange flag was planted in the ruins.\n\nThe flag showed patterns of a few familiar fairies.\n\nEnraged, Cirno posted a declaration of war against the owner of the flag.\n\nAnd thus, the great war of the fairies began.\n\n(Excerpted from the Fairy Wars manual.)", "description": "The Three Fairies of Light Sunny Milk, Lunar Child, and Star Sapphire destroyed the ice fairy Cirno’s house to lure her into their prank plan. Of course, Cirno would not let it go. She found the Three Fairies to take revenge, in the form of a danmaku duel. On Normal difficulty, Star Sapphire does not appear in this duel, so only Sunny Milk and Lunar Child face off against Cirno.\n\nIn one spell card, the danmaku fired by Sunny Milk and Lunar Child almost fills the entire $100\\times 100$ square battlefield, and can be exactly divided into two parts by a stationary, non-vertical straight line. The region above the line is Sunny Milk’s sunlight danmaku, and the region below the line is Lunar Child’s moonlight danmaku.\n\nCirno is the strongest fairy, but even she gets nervous in the face of dense danmaku from two fairies. Just as her motivation is about to run out, she realizes that if she can use two different strategies for the two kinds of danmaku, her chances of winning will greatly increase. Therefore, she wants to know what kind of danmaku will appear at some key positions.\n\nUnfortunately, Cirno cannot determine where the separating line is. She only knows the current positions of every danmaku on the battlefield and whether each one is moonlight or sunlight. In rare cases (at most $0.1\\%$), Cirno may misidentify the type of danmaku because they look so similar. What Cirno wants to know is: for positions where danmaku may appear next, if danmaku does appear, will it be moonlight or sunlight? Can you help her?", "inputFormat": "The first line contains three positive integers $n, m, x$, denoting the number of danmaku currently on the field, the number of positions Cirno wants to query, and that $x$ is the index of the current test point.\n\nThe next $n$ lines each contain two real numbers $x,y$ and an integer $k$, separated by spaces. This means there is a danmaku of type $k$ at $(x,y)$. Here $k=1$ represents sunlight danmaku, and $k=-1$ represents moonlight danmaku.\n\nThe next $m$ lines each contain two real numbers $x,y$, representing positions where Cirno wants to know what type of danmaku would appear if danmaku appears there.", "outputFormat": "Output $m$ lines, each containing one integer $1$ or $-1$, corresponding to the result for each query.\n\n$1$ means sunlight danmaku, and $-1$ means moonlight danmaku.", "hint": "[Sample explanation]\n\nNote: This testdata is invalid due to being too small and lacking sufficient information to determine an accurate answer. It is only for understanding the problem statement and should not be used to test your program.\n\nFrom the input, we observe that when $y=3$, they are all moonlight danmaku, and when $y=4$, they are all sunlight danmaku. We may guess that the separating line lies between $y=3 \\sim y=4$.\n\nTherefore, for the four queries, answer $1,-1,1,-1$ respectively.\n\n[Constraints and notes]\n\n- The area of a single danmaku can be considered $0$.\n- If a query position lies exactly on the separating line, treat it as being below the line.\n- This problem uses a Special Judge.\n\n- For test point $1$:\n\n$n=100000$, $m=100000$.\n\nIf the number of correctly answered queries in your output is at least $30\\%$ of all queries, you will receive full score for this test point; otherwise, $0$ points.\n\n- For test points $2 \\sim 5$:\n\n$n=1000$, $m=1000$.\n\nIf the number of correctly answered queries in your output is at least $60\\%$ of all queries, you will receive full score for this test point; otherwise, $0$ points.\n\n- For test points $6 \\sim 7$:\n\n$n=100000$, $m=100000$.\n\nIf the number of correctly answered queries in your output is at least $70\\%$ of all queries, you will receive full score for this test point; otherwise, $0$ points.\n\n- For test points $8 \\sim 10$:\n\n$n=100000$, $m=100000$.\n\nIf the number of correctly answered queries in your output is at least $80\\%$ of all queries, you will receive full score for this test point; otherwise, $0$ points.\n\n- For $100\\%$ of the testdata:\n\n$0.000 \\le x,y \\le 100.000$.\n\nAll input real numbers have exactly $3$ decimal places.\n\nIt is guaranteed that the input has a valid solution that can meet the required accuracy thresholds.\n\nTime limit: for test points $2 \\sim 5$, the limit is $1\\ \\mathrm{s}$; for the other test points, the limit is $2\\ \\mathrm{s}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "妖精大战争", "background": " ![](https://cdn.luogu.com.cn/upload/pic/4726.png) \n\n琪露诺一如既往忙碌地生活着。\n\n某天，在外出时她的家被人破坏了。\n\n损坏的家插着一面奇怪的旗。\n\n旗上画着似曾相识的几个妖精的图案。\n\n狂怒的琪露诺对旗的主人贴出了宣战告示。\n\n就这样，妖精们的大战争开始了。\n\n(摘自《妖精大战争》manual)\n", "description": "三月精 Sunny Milk, Lunar Child, Star Sapphire 为了让冰之妖精琪露诺加入她们的恶作剧计划，破坏了琪露诺的房子。琪露诺当然不会就此罢休，于是她找到了三月精准备进行复仇，复仇的方式是进行一场弹幕对决。 在Normal 难度下，Star Sapphire 在此次对战中不会出场，因此只有 Sunny Milk, Lunar Child两只妖精出场和琪露诺对决了。\n\n在一张符卡中，Sunny Milk 和 Lunar Child 发射的弹幕几乎填满了整个 $100\\times 100$ 的正方形战斗场地，并且恰好可以被一条静止不动，非垂直的直线划分成两部分，其中直线上方的部分是 Sunny Milk 发射的日光弹幕，直线下方的部分是 Lunar Child 发射的月光弹幕。\n\n琪露诺是最强的妖精，但她面对两只妖精密集的弹幕也会有些紧张。在她的干劲快要被消磨完时，琪露诺忽然发现，如果能用两种不同的策略来对付两种弹幕，获胜的希望将会大大增加。因此，她想知道一些关键的位置会出现什么弹幕。\n\n不幸的是，琪露诺无法判断出分界线在哪里，她只知道当前在战斗场地中每个弹幕的位置，和这个弹幕是月光弹幕还是日光弹幕。在极少情况下(至多 $0.1\\%$)，琪露诺可能会错误识别弹幕的类型，因为它们实在太像了。琪露诺想要了解的是，对于接下来可能出现弹幕的位置，如果出现了弹幕，它是月光弹幕还是日光弹幕。你能帮帮她吗？\n", "inputFormat": "第一行三个正整数 $n,m,x$。分别表示当前场地上弹幕的数量，和琪露诺想要了解情况的位置的数量，$x$ 表示当前是第几个测试点。\n\n接下来 $n$ 行，每行两个实数 $x,y$ 和一个整数 $k$，用空格隔开。表示在 $(x,y)$ 有一个种类为 $k$ 的弹幕，$k=1$ 为日光弹幕，$k=-1$ 为月光弹幕。\n\n接下来 $m$ 行，每行两个实数 $x,y$，表示琪露诺想知道这个位置如果出现弹幕，会出现什么类型的弹幕。", "outputFormat": "$m$ 行，每行一个整数 $1$ 或者 $-1$，对应每个询问的结果。\n\n$1$ 为日光弹幕，$-1$ 为月光弹幕。", "hint": "【样例解释】\n\n注：该数据因量过小，信息量不足而不合法，可能会发生无法得到准确答案的情况。因此仅供理解题意使用，不可用来测试程序。\n\n观察输入数据，我们发现当 $y=3$ 时，都是月光弹幕 $,y=4$ 时，都是日光弹幕。可以猜想直线在 $y=3 \\sim y=4$ 之间。\n\n因此对于四个询问分别回答 $1,-1,1,-1$。\n\n【数据范围和提示】\n\n单个弹幕的面积可视为 $0$。\n\n若询问的位置恰好落在分界线上，当做在分界线的下方处理。\n\n本题有 SpecialJudge。\n\n- 对于第 $1$ 个测试点：\n\n$N=100000$，$m=100000$。\n\n若你输出的答案中，正确回答的询问数量大于等于总询问数量的 $30\\%$，则可以获得该测试点的全部分数，否则得 $0$ 分。\n\n- 对于第 $2 \\sim 5$ 个测试点：\n\n$n=1000$，$m=1000$。\n\n若你输出的答案中，正确回答的询问数量大于等于总询问数量的 $60\\%$，则可以获得该测试点的全部分数，否则得 $0$ 分。\n\n- 对于第 $6 \\sim 7$ 个测试点，\n\n$n=100000$，$m=100000$。\n\n若你输出的答案中，正确回答的询问数量大于等于总询问数量的 $70\\%$，则可以获得该测试点的全部分数，否则得 $0$ 分。\n\n- 对于第 $8 \\sim 10$ 个测试点，\n\n$n=100000$，$m=100000$。\n\n若你输出的答案中，正确回答的询问数量大于等于总询问数量的 $80\\%$，则可以获得该测试点的全部分数，否则得 $0$ 分。\n\n- 对于 $100\\%$ 的数据：\n\n$0.000 \\le x,y \\le 100.000$。\n\n所有输入的实数均保留 $3$ 位小数。\n\n保证输入数据有合法的解能够满足题目要求的判定准确率。\n\n评测时限：对于测试点 $2 \\sim 5,$ 时限为 $1s$，其他测试点时限为 $2s$。", "locale": "zh-CN"}}}
{"pid": "P3692", "type": "P", "difficulty": 2, "samples": [["2 5\nABCAD\n0000000011111111\n01\n1000\n0010\n0100\n1000\n0010\n1001001001001001\n01\n0001\n1010\n0111\n1111\n0000", "ID: 255\nType Correct\n40.0\n\nWrong ID"], ["3 3\nABC\n0000000000000000\n01\n1111\n0001\n0100\n0000000000000010\n10\n1000\n0100\n0010\n0000000000000011\n11\n0001\n0000\n0010\n", "Wrong ID\n\nID: 2\nType Correct\n100.0\n\nID: 3\nType Incorrect\n33.3\n"], ["5 31\nACAACCDDBBDADDCBCACCDBCAACAAAAC\n0000101111000001\n10\n1000\n0010\n1000\n1111\n0010\n0010\n0001\n0001\n0100\n0100\n0001\n1000\n0001\n0001\n0010\n1111\n0010\n1000\n0010\n0010\n0001\n0100\n1111\n1000\n1000\n0010\n1000\n0100\n1000\n1000\n0010\n0000010101001111\n10\n1000\n0010\n1000\n1000\n0010\n0010\n0001\n0001\n0100\n0100\n0001\n1000\n0001\n0001\n0010\n0100\n1000\n1000\n0000\n0010\n0001\n0100\n0010\n1000\n1000\n0010\n1000\n1000\n0000\n0000\n0010\n0001110001100110\n11\n1000\n0010\n1000\n1000\n0010\n0010\n0001\n0001\n0100\n0100\n0001\n1000\n0010\n0100\n0010\n0100\n0010\n0100\n0010\n0010\n0001\n0100\n0010\n1000\n1000\n0010\n1000\n1111\n1000\n1000\n0010\n0001001111110001\n10\n1010\n0010\n1000\n1000\n0010\n0010\n0001\n0001\n0100\n0100\n0010\n1000\n0001\n0001\n0010\n0100\n0010\n1000\n0010\n0010\n0001\n0100\n0010\n1000\n1000\n0010\n1000\n1000\n1000\n1000\n0010\n0001110010000100\n10\n1000\n0010\n1000\n1000\n0000\n0010\n0001\n0001\n0100\n0100\n0001\n1000\n0001\n0001\n0001\n0100\n0010\n1000\n0010\n0010\n0001\n0100\n0010\n1000\n1000\n0010\n1000\n1000\n0000\n1000\n0001\n", "ID: 3009\nType Incorrect\n87.1\n\nID: 1359\nType Incorrect\n87.1\n\nID: 7270\nType Incorrect\n87.1\n\nID: 5105\nType Incorrect\n93.5\n\nID: 7300\nType Correct\n87.1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "洛谷原创", "进制"], "title": "夏幻的考试", "background": "夏之幻是软件工程系的大神，学校把举办考试的任务交给她了。", "description": "某大学软工专业要举办一场笔试，学生们要在机读答题卡上填写答案来进行答题。学校把机读卡识别任务交给了夏之幻，但是这套系统的需求太复杂了，她还要做自己的其他项(you)目(xi)，所以她想让你来帮忙实现一部分功能。\n\n试卷分卷头，单选题两部分。\n\n夏幻大神已经写好了识别程序，因此卷头和答案将直接以数字信息的形式呈现给你，你要实现下面几个功能:\n\n需要处理 $T$ 张试卷，按顺序检查下列选项。\n\n1.检查考号的填写是否准确。\n\n输入信息的格式:\n\n一行，一个 $16$ 位无符号二进制数id。表示考生的考号为id，正确的考号范围在十进制下是 $1 \\sim 10000$。\n\n如果考号有错误，输出一行 `Wrong ID` 并结束对这张试卷的处理(剩下两个选项的数据依然要读入，但不输出任何内容)。如果考号正确，输出一行,`ID: `+ 一个整数，表示考号的十进制形式。\n\n无需考虑考号是否重复，只要在范围内均为正确。\n\n2.检查试卷类型是否正确。\n\n输入信息格式:\n\n一行，两个整数，中间无分隔，只能是 $0$ 或者 $1$。第一个整数表示试卷类型A是否被涂黑($0$ 表示未涂黑，$1$ 表示涂黑)，第二个整数表示试卷类型B是否涂黑。其实试卷类型可以由二进制考号的最后一位得到，$0$ 表示A卷，$1$ 表示B卷，你只需要检查考生填涂的是否正确。\n\n如果考生将试卷类型正确填涂(填涂且只填涂了正确的那一项)，输出一行 `Type Correct`，否则输出一行 `Type Incorrect`。无论试卷类型是否填涂正确，你还需要接着处理这张试卷。\n\n3.给单选题打分。\n\n单选题的数量 $n$ 和标准答案将会在录入第一张试卷前给出。\n\n考生答案的输入格式:\n\n$n$ 行，每行 $4$ 个整数，中间无分隔。每个整数是 $0$ 或 $1$。\n\n按顺序分别代表 $A,B,C,D$ 是否被涂黑($0$ 表示未涂黑，$1$ 表示涂黑)。考生回答正确当且仅当该题正确答案的位置被涂黑，且错误答案的位置未被涂黑。\n\n输出一行，一个四舍五入到小数点后 $1$ 位的浮点数，表示考生的得分，满分为 $100$ 分，每个题的分数相同。", "inputFormat": "第一行两个整数 $T$、$n$，空格分开，含义见题目描述。\n\n接下来一行一个字符串 $s$，长度为 $n$，每个字符是大写字母 $A,B,C,D$ 中的一个，第 $i$ 个字符表示单选题 $i$ 的答案。\n\n接下来 $T \\times (n+2)$ 行含有 $T$ 组信息，表示每张试卷的内容，格式见题目描述。", "outputFormat": "对于每张试卷，输出评判结果，格式见题目描述。两张试卷的评判结果之间空一行。", "hint": "对于100%的数据\n\n$1 \\le T \\le 1000$\n\n$1 \\le n \\le 50$\n\n注意:\n\n1.请在最后一个试卷处理完后也加上一个换行\n\n2.由于win系统和linux系统换行的不同，建议不要使用scanf读入char", "locale": "zh-CN", "translations": {"en": {"title": "Xia Huan's Exam", "background": "Xia Huan is a guru in the Software Engineering department, and the school has assigned her to organize an exam.", "description": "A university's Software Engineering program is holding a written test. Students fill answers on a machine-readable answer sheet. The school assigned the recognition task to Xia Huan, but the system requirements are too complex and she also has other projects to work on, so she wants you to help implement part of the functionality.\n\nThe paper has two parts: the header and single-choice questions.\n\nXia Huan has already written the recognition program, so the header and answers will be provided directly as numeric information. You need to implement the following features:\n\nYou need to process $T$ papers and check the following items in order.\n\n1. Check whether the examinee ID is filled in correctly.\n\nInput format:\nOne line: a 16-bit unsigned binary number id. The examinee's ID is id, and the correct ID range in decimal is $1 \\sim 10000$.\n\nIf the ID is invalid, output one line `Wrong ID` and stop processing this paper (you still need to read the remaining two parts' input for this paper, but do not output anything else). If the ID is valid, output one line: `ID: ` + an integer, which is the decimal form of the ID.\n\nYou do not need to consider whether IDs are duplicated; as long as the value is within the range, it is considered valid.\n\n2. Check whether the paper type is filled in correctly.\n\nInput format:\nOne line: two digits with no separator, each must be $0$ or $1$. The first digit indicates whether paper type A is bubbled ($0$ means not bubbled, $1$ means bubbled), and the second digit indicates whether paper type B is bubbled. In fact, the paper type can be determined by the last bit of the binary ID: $0$ means type A, $1$ means type B. You only need to check whether the student filled it correctly.\n\nIf the student filled the paper type correctly (bubbled, and only bubbled, the correct one), output one line `Type Correct`; otherwise, output one line `Type Incorrect`. Regardless of correctness, you must continue processing this paper.\n\n3. Score the single-choice questions.\n\nThe number of single-choice questions $n$ and the answer key will be provided before entering the first paper.\n\nCandidate answers input format:\n$n$ lines, each with 4 digits and no separator. Each digit is $0$ or $1$.\n\nIn order, they represent whether $A, B, C, D$ are bubbled ($0$ means not bubbled, $1$ means bubbled). A student's answer to a question is correct if and only if the correct option is bubbled and all incorrect options are not bubbled.\n\nOutput one line: a floating-point number rounded to 1 decimal place, representing the student's score. The full score is $100$, and each question has the same weight.", "inputFormat": "The first line contains two integers $T$ and $n$, separated by a space, as described above.\n\nThe next line contains a string $s$ of length $n$. Each character is one of the uppercase letters $A, B, C, D$, and the $i$-th character is the answer to single-choice question $i$.\n\nThen the next $T \\times (n+2)$ lines contain $T$ groups of information, representing the content of each paper, with the format as described above.", "outputFormat": "For each paper, output the judgment results as described. Insert one blank line between the results of two papers.", "hint": "For 100% of the testdata\n\n$1 \\le T \\le 1000$\n\n$1 \\le n \\le 50$\n\nNotes:\n1. Please also add a newline after processing the last paper.\n2. Due to differences in line endings between Windows and Linux, it is recommended not to use scanf to read char.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "夏幻的考试", "background": "夏之幻是软件工程系的大神，学校把举办考试的任务交给她了。", "description": "某大学软工专业要举办一场笔试，学生们要在机读答题卡上填写答案来进行答题。学校把机读卡识别任务交给了夏之幻，但是这套系统的需求太复杂了，她还要做自己的其他项(you)目(xi)，所以她想让你来帮忙实现一部分功能。\n\n试卷分卷头，单选题两部分。\n\n夏幻大神已经写好了识别程序，因此卷头和答案将直接以数字信息的形式呈现给你，你要实现下面几个功能:\n\n需要处理 $T$ 张试卷，按顺序检查下列选项。\n\n1.检查考号的填写是否准确。\n\n输入信息的格式:\n\n一行，一个 $16$ 位无符号二进制数id。表示考生的考号为id，正确的考号范围在十进制下是 $1 \\sim 10000$。\n\n如果考号有错误，输出一行 `Wrong ID` 并结束对这张试卷的处理(剩下两个选项的数据依然要读入，但不输出任何内容)。如果考号正确，输出一行,`ID: `+ 一个整数，表示考号的十进制形式。\n\n无需考虑考号是否重复，只要在范围内均为正确。\n\n2.检查试卷类型是否正确。\n\n输入信息格式:\n\n一行，两个整数，中间无分隔，只能是 $0$ 或者 $1$。第一个整数表示试卷类型A是否被涂黑($0$ 表示未涂黑，$1$ 表示涂黑)，第二个整数表示试卷类型B是否涂黑。其实试卷类型可以由二进制考号的最后一位得到，$0$ 表示A卷，$1$ 表示B卷，你只需要检查考生填涂的是否正确。\n\n如果考生将试卷类型正确填涂(填涂且只填涂了正确的那一项)，输出一行 `Type Correct`，否则输出一行 `Type Incorrect`。无论试卷类型是否填涂正确，你还需要接着处理这张试卷。\n\n3.给单选题打分。\n\n单选题的数量 $n$ 和标准答案将会在录入第一张试卷前给出。\n\n考生答案的输入格式:\n\n$n$ 行，每行 $4$ 个整数，中间无分隔。每个整数是 $0$ 或 $1$。\n\n按顺序分别代表 $A,B,C,D$ 是否被涂黑($0$ 表示未涂黑，$1$ 表示涂黑)。考生回答正确当且仅当该题正确答案的位置被涂黑，且错误答案的位置未被涂黑。\n\n输出一行，一个四舍五入到小数点后 $1$ 位的浮点数，表示考生的得分，满分为 $100$ 分，每个题的分数相同。", "inputFormat": "第一行两个整数 $T$、$n$，空格分开，含义见题目描述。\n\n接下来一行一个字符串 $s$，长度为 $n$，每个字符是大写字母 $A,B,C,D$ 中的一个，第 $i$ 个字符表示单选题 $i$ 的答案。\n\n接下来 $T \\times (n+2)$ 行含有 $T$ 组信息，表示每张试卷的内容，格式见题目描述。", "outputFormat": "对于每张试卷，输出评判结果，格式见题目描述。两张试卷的评判结果之间空一行。", "hint": "对于100%的数据\n\n$1 \\le T \\le 1000$\n\n$1 \\le n \\le 50$\n\n注意:\n\n1.请在最后一个试卷处理完后也加上一个换行\n\n2.由于win系统和linux系统换行的不同，建议不要使用scanf读入char", "locale": "zh-CN"}}}
{"pid": "P3693", "type": "P", "difficulty": 6, "samples": [["8\n10\n4 0 4 4\n63\nICE_BARRAGE 2 1 1 3\nICE_BARRAGE 0 1 3 1\nMAKE_ICE_BLOCK\nPUT_ICE_BLOCK 3 2 0\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 2 0 6 7\nICE_BARRAGE 3 0 6 7\nICE_BARRAGE 4 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nMAKE_ICE_BLOCK\nPUT_ICE_BLOCK 4 0 1\nPUT_ICE_BLOCK 4 0 0\nPUT_ICE_BLOCK 4 0 1\nPUT_ICE_BLOCK 3 0 1\nREMOVE_ICE_BLOCK 4 0 1\nPUT_ICE_BLOCK 4 2 0\nPUT_ICE_BLOCK 6 1 0\nPUT_ICE_BLOCK 4 3 0\nPUT_ICE_BLOCK 5 3 0\nPUT_ICE_BLOCK 6 3 0\nPUT_ICE_BLOCK 7 3 0\nICE_BARRAGE 0 1 4 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nMAKE_ICE_BLOCK\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nMAKE_ICE_BLOCK\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nMAKE_ICE_BLOCK\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nICE_BARRAGE 1 0 6 7\nMAKE_ICE_BLOCK\nREMOVE_ICE_BLOCK 6 1 0\nPUT_ICE_BLOCK 5 0 0\nPUT_ICE_BLOCK 6 0 0\nPUT_ICE_BLOCK 7 0 0\nPUT_ICE_BLOCK 7 1 0\nPUT_ICE_BLOCK 7 2 0\nPUT_ICE_BLOCK 4 0 1\nPUT_ICE_BLOCK 5 0 1\nPUT_ICE_BLOCK 6 0 1\nPUT_ICE_BLOCK 7 0 1\nPUT_ICE_BLOCK 7 1 1\nPUT_ICE_BLOCK 7 2 1\nPUT_ICE_BLOCK 7 3 1\nPUT_ICE_BLOCK 6 3 1\nPUT_ICE_BLOCK 5 3 1\nPUT_ICE_BLOCK 4 3 1\nPUT_ICE_BLOCK 4 2 1\nMAKE_ROOF\n", "CIRNO FREEZED 2 BLOCK(S)\nCIRNO FREEZED 2 BLOCK(S)\nCIRNO MADE 0 ICE BLOCK(S),NOW SHE HAS 0 ICE BLOCK(S)\nCIRNO HAS NO ICE_BLOCK\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 7 BLOCK(S)\nCIRNO FREEZED 7 BLOCK(S)\nCIRNO FREEZED 0 BLOCK(S)\nCIRNO MADE 8 ICE BLOCK(S),NOW SHE HAS 8 ICE BLOCK(S)\nBAKA CIRNO,CAN'T PUT HERE\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 7 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 6 ICE_BLOCK(S)\nCIRNO MISSED THE PLACE\nCIRNO REMOVED AN ICE_BLOCK,AND 1 BLOCK(S) ARE BROKEN\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 5 ICE_BLOCK(S)\nCIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 3 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 2 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 1 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 0 ICE_BLOCK(S)\nCIRNO FREEZED 6 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 7 BLOCK(S)\nCIRNO MADE 8 ICE BLOCK(S),NOW SHE HAS 8 ICE BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO MADE 8 ICE BLOCK(S),NOW SHE HAS 16 ICE BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO MADE 8 ICE BLOCK(S),NOW SHE HAS 24 ICE BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO FREEZED 8 BLOCK(S)\nCIRNO MADE 8 ICE BLOCK(S),NOW SHE HAS 32 ICE BLOCK(S)\nCIRNO REMOVED AN ICE_BLOCK\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 32 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 31 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 30 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 29 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 28 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 27 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 26 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 25 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 24 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 23 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 22 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 21 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 20 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 19 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 18 ICE_BLOCK(S)\nCIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 17 ICE_BLOCK(S)\n0 ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED\n0 ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED\nGOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE\nDOOR IS OK\nWALL IS OK\nCORNER IS OK\nCIRNO FINALLY HAS 1 ICE_BLOCK(S)\nCIRNO IS PERFECT!\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "洛谷原创", "枚举", "广度优先搜索 BFS", "连通块"], "title": "琪露诺的冰雪小屋", "background": "琪露诺有一片正方形的雪地，她想在上面盖一栋小冰屋。", "description": "琪露诺偶然间得到了一片 $N\\times N$ 大小的正方形的雪地，她想在上面盖一栋冰雪小屋。\n\n但调皮的⑨才不会认真地收集冰块呢，她要在这片土地上使用冰雪弹幕来制造冰砖，然后一块一块地搭起一个房子。\n\n琪露诺制造冰砖的方式是这样的：她会站在某个方格上，然后向上，下，左，右，左上，左下，右上，右下这八个方向之一发射强力的冰雪弹幕，弹幕能影响到该方向一条直线上一定的距离以内的所有方格。\n\n地面的每个方格都有一个冷冻度，初始为 $0$。被冰雪弹幕影响一次，冷冻度 $+1$，冷冻度的上限为 $4$。\n\n在发射弹幕的间隙中，琪露诺会来到所有冷冻度为 $4$ 的格子，把那里的雪堆到一起，制作一个冰砖（大小为 $1\\times1\\times1$ 方格），并且将冷冻度重新归零。\n\n琪露诺会拿着这些冰砖来盖房子。这个房子的长度、宽度和坐落位置她在一开始就已经规划好了，但她并不愿意提早确定房子的高度。\n\n琪露诺是这样计划的：这个房子外观上看起来是一个长方体。\n\n她会先盖起这个房子的四面墙（厚度为 $1$ 个方格），并在贴近地面的位置（废话）留一个宽度和高度分别为 $1$ 和 $2$ 的空位不放冰砖，作为房门。（显然，门无法开在墙的拐角处，但可以紧贴拐角）。\n\n在她喜欢的时候，她会结束四面墙的建造，并一次性在墙顶部盖上一个厚度为 $1$ 方格的屋顶，使房子成为一个空心有顶的长方体。\n\n计划已经非常充分了，但琪露诺还是不放心，所以她想请你帮她写一个程序，来随时提醒着她别出什么差错。这个程序需要具备的功能将在下文详细介绍。\n\n----------------------\n雪地由 $N$ 行 $N$ 列，$N\\times N$ 个方格组成。（下标从 $0$ 开始，也就是说，存在第 $0$ 行第 $0$ 列，但不存在第 $N$ 行第 $N$ 列）每个方格都有一个冷冻度,范围 $[0,4]$，初始为 $0$。注意，空间是三维的，而冷冻度只是地面的属性。\n\n琪露诺想将房子的左上角放在第 $H_R$ 行，$H_C$ 列（外墙也是房子的一部分，因此左上角位置不应该是房子的内部,而是外墙,并且是墙的拐角）。\n\n这个房子的长度（平行于每列）是 $H_X$，宽度（平行于每行）是 $H_Y$，包含墙。保证房子所占空间不会超出雪地的范围。\n\n除了最后搭建屋顶，琪露诺只会在高度 $[0,H_M-1]$ 放置冰砖。\n\n一开始，琪露诺一个冰砖也没有。\n在以下的介绍中，我们用俯视图来作示意：\n```plain\n0000\n0000\n4x90\n0x01\n```\n数字代表当前该格子的冷冻度。如果位置紧贴地面（高度为 $0$）的地方放上了冰砖，那么用字母 $x$ 表示。\n\n如果紧贴地面的位置没有冰砖，但是位置正上方的高空存在冰砖，那么仍然用数字表示地面的冷冻度，但这个数字会增加 $5$。即如果在示意图中看到了一个数字 $t\\ge5$，表示该位置地面是空的，但高处有冰砖，且地面的冷冻度为 $t-5$。\n\n第一个操作：`ICE_BARRAGE R C D S`  \n---------------\n表示琪露诺站在第 $R$ 行 $C$ 列的位置，朝着方向 $D$ 发射了一个强度为 $S$ 的弹幕。  \n$R,C,D,S\\in\\Z,0\\le D\\le7,0\\le R,C,S<N$。  \n方向编号 $0$ 表示上 $(R-1,C)$，$1$ 表示左上 $(R-1,C-1)$，   \n$2$ 表示左 $(R,C-1)$，$3$ 表示左下 $(R+1,C-1)$，  \n$4$ 表示下 $(R+1,C)$，$5$ 表示右下 $(R+1,C+1)$，  \n$6$ 表示右 $(R,C+1)$，$7$ 表示右上 $(R-1,C+1)$。  \n强度为 $S$ 的弹幕，可以使“处在发射方向直线上，距离琪露诺不超过 $S$ 格的所有格子（包括她站的格子）”的冷冻度都 $+1$。有以下几种特殊情况：\n\n1. 如果某个格子冷冻度为 $4$，那么该格子冷冻度不变。\n2. 如果弹幕所经路途上，有一个位置的地面上（高度为 $0$）已经放了冰砖（就是弹幕撞上了琪露诺已经盖了一半的房子），那么弹幕将被阻挡，无法影响到冰砖所在的格子以及冰砖后面被挡住的格子。\n3. 弹幕超出雪地的部分忽略不计。\n\n对于这个操作，需要如下输出一行：`CIRNO FREEZED k BLOCK(S)`  \n如果这个弹幕将某个方格的冷冻度成功增加了 $1$，那么认为这个弹幕冻住了该方格。\n\n`k` 表示这个弹幕总共冻住了多少方格。\n\n如图：发射弹幕前地图如下：\n```plain\n00000\n00000\n00000\n000x0\n00000\n```\n执行操作 `ICE_BARRAGE 1 1 5 4`，地图变为：\n```plain\n00000\n01000\n00100\n000x0\n00000\n```\n输出：`CIRNO FREEZED 2 BLOCK(S)`  \n解释：琪露诺站在第一行第一列，面对右下角发射了一个强度为 $4$ 的弹幕，但弹幕被 `x` 所阻挡，只能影响到 `x` 之前的格子。\n\n第二个操作：`MAKE_ICE_BLOCK`  \n-------------------------\n琪露诺走遍地图上所有冷冻度为 $4$ 的方格，每个方格可以收集一个冰砖，然后将它们的冷冻度归零。 \n\n对于这个操作，你需要给出如下输出一行：`CIRNO MADE x ICE BLOCK(S),NOW SHE HAS y ICE BLOCK(S)`  \n表示琪露诺制造了 $x$ 个冰砖，目前她有 $y$ 个冰砖。  \n比如琪露诺一开始有 $0$ 个冰砖，并且状态如下：\n```plain\n0xxx\n0x4x\n0x9x\n0400\n```\n执行操作 `MAKE_ICE_BLOCK` 后变为\n```plain\n0xxx\n0x0x\n0x5x\n0000\n```\n输出：`CIRNO MADE 3 ICE BLOCK(S),NOW SHE HAS 3 ICE BLOCK(S)`  \n在这个示例中，房子已经完成了一部分，`x` 表示墙，`9` 这个位置地面没有冰砖，但高处有（可以猜出是门）。房间内唯一一块空地、门的位置，以及房间外的一个位置的冷冻度都达到了 $4$，因此可以收集到 $3$ 块冰砖，收集后将三个位置冷冻度都归零。\n\n第三个操作：`PUT_ICE_BLOCK R C H` \n-----------------\n表示在第 $R$ 行，第 $C$ 列，高度为 $H$ 的地方放一个冰砖。$0\\le R,C<N,0\\le H<H_M$。\n\n贴近地面的位置高度为 $0$。如果冰砖放置成功，那么琪露诺库存的冰砖数量将减 $1$。\n\n如果放置的位置贴近地面，该位置冷冻度立即归 $0$。\n\n有以下几种情况，序号越小优先级越高，并且只能满足一种情况。\n\n如果满足 $1$ 的话就忽视后面的，不满足 $1$ 的前提下才可能满足 $2\\cdots\\cdots$ 以此类推。\n\n1. 琪露诺目前没有任何冰砖，无法放置。这种情况下你需要输出：`CIRNO HAS NO ICE_BLOCK`\n2. 冰砖将放在半空中，无法依附其他任何冰砖，或者目标位置已有冰砖了。  \n这种情况下你需要输出一行：`BAKA CIRNO,CAN'T PUT HERE`，并无视此次操作，不做任何工作。\n3. 冰砖放在了规划建造房子的区域之外，即\n$R<H_R$ 或 $R>H_R+H_x-1$  \n或 $C<H_C$ 或 $C>H_C+H_Y-1$。请输出一行：`CIRNO MISSED THE PLACE`  \n尽管琪露诺放错了地方，但你并不能阻止她放置这个冰砖。  \n4. 冰砖留在了房子的内部，本应留空的地方被占用了，即  \n$H_R+1\\le R\\le H_R+H_X-2$ 且 $H_C+1\\le C\\le H_C+H_Y-2$  \n在屋顶的高度固定下来前，我们将所有满足上式的情况都认为是放在了房屋内部。  \n请输出一行：`CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE`  \n尽管琪露诺放错了地方，但你并不能阻止她放置这个冰砖。\n5. 冰砖放在了正确的位置（不必考虑是否堵住了留给门的地方）  \n请输出一行：`CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS x ICE_BLOCK(S)`  \n`x` 表示放过这块冰砖后琪露诺剩余的冰砖。\n\n第四个操作：`REMOVE_ICE_BLOCK R C H` \n---------\n表示取走第 $R$ 行，第 $C$ 列，高度为 $H$ 处的冰砖。  \n有以下几种情况，序号越小优先级越高，并且只能满足一种情况。\n\n如果满足 $1$ 的话就忽视后面的，不满足 $1$ 的前提下才可能满足 $2\\cdots\\cdots$ 以此类推。\n\n1. 目标位置没有冰砖，输出一行：`BAKA CIRNO,THERE IS NO ICE_BLOCK`\n2. 目标位置有冰砖，并且在这个冰砖被移走后，至少有一个冰砖形成了一个悬空的块。  \n如下面的“侧视图”，`x` 表示冰砖，`0` 表示空位。\n```plain\nxxxx\nx000\nx000\nx000\n```\n$\\ \\ $在移走左上角的冰砖后，第一行右边三个冰砖没有了依靠，形成了一个悬空的连通块，就属于这种情况。  \n$\\ \\ $这个冰砖将成功移走，琪露诺的冰砖库存将会 $+1$。并且所有的悬空连通块都会掉下来摔碎并消失  \n$\\ \\ $（既不会进入冰砖库存，也不会在地面上留有任何痕迹）。  \n$\\ \\ $输出一行：`CIRNO REMOVED AN ICE_BLOCK,AND k BLOCK(S) ARE BROKEN`，`k` 表示摔碎的冰砖数量。  \n3. 琪露诺挪走了冰砖，并且其他冰砖不受任何影响。    \n$\\ \\ \\ $琪露诺的冰砖库存 $+1$，输出一行：`CIRNO REMOVED AN ICE_BLOCK`\n    \n第五个操作：`MAKE_ROOF` \n--------\n这个操作只会出现一次，并且只会作为最后一个操作。  \n这个操作表明琪露诺已经完成了冰雪小屋的四墙，只剩屋顶了！  \n\n一般情况下，琪露诺将放置最后的 $H_X\\times H_Y$ 个冰砖，把它们放置在墙壁最高的高度 $+1$ 的那一层，  \n形成一个屋顶。然后她移除所有多余的冰砖，接下来补好所有残缺的墙壁。\n\n你需要按顺序来执行整个过程，一旦遇到某种用 $\\bullet$ 标识的特殊情况，则执行完该情况后退出流程。\n\n在特殊情况之间所描述的均为一般情况，只要之前没有因为满足某种特殊情况而退出流程，均认为满足了一般情况。\n\n首先，琪露诺将会一次性放置最多 $H_X\\times H_Y$ 个冰砖来建造屋顶。\n\n为什么是最多呢？请注意一点：如果之前错误放置在房子内部的冰砖恰好充当了屋顶的一部分，那么就不用在这个位置再放冰砖了。并且，所有比屋顶高的冰砖在之后将视为错误放置在了房子外部。\n\n注意，放屋顶的时候可能会触及到高度为 $H_M$ 的那个平面。\n\n建造屋顶前后将会碰到两种特殊情况：\n- 琪露诺剩余的冰砖不足以建造屋顶。输出一行：`SORRY CIRNO,NOT ENOUGH ICE_BLOCK(S) TO MAKE ROOF`\n- 墙壁的最高高度小于 $2$ 个方格，或者内部有效空间小于两个方格。  \n墙壁所在的一圈不算内部空间。计算内部有效空间时请忽视错误放置的冰砖，因为它们将来要被移除。  \n输出一行：`SORRY CIRNO,HOUSE IS TOO SMALL`\n\n（特殊情况结束）\n\n此后，我们认为琪露诺已经造好了屋顶，接下来该移除所有多余冰砖了。在移除过程中，琪露诺会尽可能让更少的冰砖摔碎。如果墙壁上某个冰砖因为移走了多余的冰砖而将要摔碎，那么她会先拆掉墙壁上的那个冰砖，然后在填补墙壁残缺时重新补回来（显然，这种行为不会影响到墙壁有无残缺的定性，但可以少损失一个冰砖）。她不会故意拆掉一个处在墙壁上且不会摔碎的冰砖。  \n输出两行：  \n`K1 ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED`  \n`K2 ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED`  \n`K1`表示房子内部错误放置的冰砖数量，`K2`表示房子外部错误放置的冰砖数量。\n\n将有可能遭遇一种特殊情况：\n- 琪露诺移除了所有多余的冰砖，但在移除过程中，屋顶塌陷了。  \n输出一行：`SORRY CIRNO,HOUSE IS BROKEN WHEN REMOVING BLOCKS`\n\n（特殊情况结束）\n\n此后，我们认为琪露诺已经移除了所有多余的冰砖，接下来该填补墙壁的残缺了。\n\n墙壁有残缺的定义是：除了宽为 $1$，高为 $2$ 的门以外，\n在房子内部看外面还能看到其他缺口。\n\n如果某个空位将来要作为门的一部分，则不属于残缺。并且房子只能有一个门。\n\n如果墙壁没有残缺，则不要填补，否则需要填补。你需要记下墙壁是否有残缺，之后会用到。\n\n填补的策略是：使用尽可能少的冰砖，在正确的位置填补墙壁，使房屋的状态不满足墙壁有残缺的定义（即不能放置多余的冰砖，通过遮挡视线来达到目的）。在此定义下，**大多数**情况我们无需考虑四角的柱子是否完整，因为在房间里看不到。\n\n将有可能遭遇一种特殊情况：\n- 琪露诺剩余的冰砖不足以填补墙壁的残缺。  \n输出一行：`SORRY CIRNO,NOT ENOUGH ICE_BLOCKS TO FIX THE WALL`\n\n（特殊情况结束）\n\n此后，我们认为房子被成功建成了，这时你需要输出几行内容来对房子进行评价。\n\n首先输出这么一行来庆祝房子的建成：`GOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE`  \n1. 在贴近地面的位置找不到一个宽度为 $1$，高度为 $2$ 的位置留给门。  \n\t输出一行：`HOUSE HAS NO DOOR`，然后琪露诺会尽可能利用墙壁上的残缺来开一个门。  \n    否则，输出一行：`DOOR IS OK`\n2. 接下来输出一行表示填补之前墙壁的完整程度  \n\t2.1. 在之前的记录中，墙壁不完整而需要修补。输出：`WALL NEED TO BE FIXED`  \n    2.2. 在之前的记录中，墙壁完整而无需修补。输出：`WALL IS OK`  \n3. 接下来一行表示四角的完整程度。  \n\t如果四个角的柱子有不完整的地方，就输出：`CORNER NEED TO BE FIXED`  \n    在这种情况下，如果琪露诺剩余的冰砖足够修复拐角的空缺，那么她直接会修复这个空缺。  \n    如果不够的话，她会再多收集几个冰砖，数量恰好修复这个空缺，然后修复这个空缺。  \n    否则，输出：`CORNER IS OK`\n    \n接下来，输出一行：`CIRNO FINALLY HAS k ICE_BLOCK(S)`  \n`k` 表示琪露诺最后剩余的冰砖的数量。\n\n最后，如果在之前的记录中，墙壁完整无缺，没有一个位置需要填补。房子内外都无任何多余的方块，没有一个位置需要移除。没有出现房子没门的情况，房子四角的柱子也在造屋顶前完全造好，而不是通过修补完善的。并且门恰好开在了某面墙的正中央（如果长度为偶数，中间的两个都算），输出一行：   \n`CIRNO IS PERFECT!`", "inputFormat": "第一行一个正整数 $N$，表示雪地的大小。\n\n第二行一个正整数 $H_M$，表示琪露诺放置方块的最大高度。\n\n第三行四个正整数 $H_R,H_C,H_X,H_Y$，表示房子左上角位置的行列坐标，房子的长度以及宽度。\n\n第四行一个正整数 $M$，表示操作的数量。\n\n接下来 $M$ 行，每行表示一个操作，输入格式见题目描述。", "outputFormat": "在题目描述中已经介绍。", "hint": "共分为 $6$ 个 **Subtask**，每个 **Subtask** 的数据都满足一定条件，并且同时满足序号更大的 **Subtask** 的条件。  \n如 **Subtask #0** 同时满足 **Subtask #0~5** 的条件。  \n每一个 **Subtask** 的得分取所有测试点的最低分。\n\n**Subtask #0** $20\\%$  \n琪露诺只想玩玩冰雪弹幕，她不会放置任何冰砖，也不会盖房子(即只有操作一和操作二)。  \n\n\n**Subtask #1** $10\\%$  \n琪露诺不会移除已经放置的冰砖。\n\n**Subtask #2** $20\\%$  \n琪露诺很有信心，她将在没有 `MAKE_ROOF` 的情况下建造她的冰屋(这种情况下，放置方块的高度仍然会小于 $H_M$ 且没有 `MAKE_ROOF` 操作)。\n\n**Subtask #3** $20\\%$  \n琪露诺在移除方块时会谨慎考虑,不会造成任何冰砖摔落。`MAKE_ROOF` 操作移除多余冰砖时，也不会造成屋顶塌陷。\n\n**Subtask #4** $20\\%$  \n琪露诺不喜欢把门开到四角的柱子旁边(数据保证在所有可能作为门的墙壁空缺中，有一种可能使得门不紧贴四角的柱子)。 \n\n**Subtask #5** $10\\%$  \n$4\\le N\\le 16$，$5\\le H_M\\le 20$，$10\\le M\\le 10^3$，保证不属于冰屋范围内的所有空地至多构成一个连通块。\n\n注意：判断墙壁是否有残缺时，候选的开门位如果被方块堵住，在当时还未被清空。\"能看到残缺\"以当时的情况作为判断依据。", "locale": "zh-CN", "translations": {"en": {"title": "Cirno’s Little Ice House", "background": "Cirno has a square snowy field, and she wants to build a small igloo on it.", "description": "Cirno happens to get a square snowy field of size $N \\times N$, and she wants to build an ice house on it.\n\nBut the mischievous ⑨ won’t seriously collect ice blocks; instead, she will use ice barrages on this land to make ice blocks and then stack them one by one to build a house.\n\nCirno makes ice blocks as follows: she stands on some cell, then fires a powerful ice barrage in one of the eight directions: up, down, left, right, up-left, down-left, up-right, down-right. The barrage affects all cells along that straight line within a certain distance.\n\nEach ground cell has a freezing level, initially $0$. When a cell is affected once by an ice barrage, its freezing level increases by $1$, capped at $4$.\n\nBetween shots, Cirno visits all cells whose freezing level is $4$, gathers the snow there to make one ice block (size $1 \\times 1 \\times 1$), and resets their freezing levels to $0$.\n\nCirno will use these ice blocks to build the house. She has already planned the house’s length, width, and placement at the start, but she is unwilling to decide the house’s height in advance.\n\nCirno’s plan: the house should look like a rectangular cuboid.\n\nShe will first build the four walls (thickness $1$ cell), and near the ground (of course) leave a $1$-wide and $2$-high opening as a door. (Obviously, the door cannot be at a wall corner, but it can be adjacent to a corner.)\n\nWhenever she likes, she will stop building the walls and put a $1$-thick roof over the top in one go, making the house a hollow, roofed cuboid.\n\nThe plan is well prepared, yet Cirno still wants your help to write a program to remind her not to mess up. The required features of this program are described below.\n\n----------------------\nThe field consists of $N$ rows and $N$ columns, $N \\times N$ cells in total. (Indexing starts from $0$, i.e., row $0$ and column $0$ exist, while row $N$ and column $N$ do not.) Each cell has a freezing level in $[0,4]$, initially $0$. Note that space is three-dimensional, while the freezing level is an attribute of the ground.\n\nCirno wants to place the top-left corner of the house at row $H_R$, column $H_C$ (the outer wall is part of the house, so the top-left corner is not inside the house; it is on the outer wall and is the corner of the wall).\n\nThe house’s length (parallel to columns) is $H_X$, and its width (parallel to rows) is $H_Y$, including the walls. It is guaranteed that the house stays within the field.\n\nExcept for placing the final roof, Cirno will only place ice blocks at heights in $[0, H_M - 1]$.\n\nInitially, Cirno has no ice blocks.\nIn the following illustrations, we use a top-down view:\n```plain\n0000\n0000\n4x90\n0x01\n```\nNumbers represent the current freezing level of a ground cell. If an ice block is placed at ground level (height $0$), we mark it by the letter x.\n\nIf there is no ice block at ground level, but there is an ice block somewhere directly above that position, we still use a number to indicate the ground freezing level, but add $5$ to it. That is, if you see a number $t \\ge 5$, it means the ground is empty, but there is an ice block above, and the ground freezing level is $t - 5$.\n\nFirst operation: ICE_BARRAGE R C D S  \n---------------\nCirno stands at row $R$, column $C$, and fires a barrage of strength $S$ toward direction $D$.  \n$R, C, D, S \\in \\Z, 0 \\le D \\le 7, 0 \\le R, C, S < N$.  \nDirection indices: $0$ means up $(R-1, C)$, $1$ means up-left $(R-1, C-1)$,  \n$2$ means left $(R, C-1)$, $3$ means down-left $(R+1, C-1)$,  \n$4$ means down $(R+1, C)$, $5$ means down-right $(R+1, C+1)$,  \n$6$ means right $(R, C+1)$, $7$ means up-right $(R-1, C+1)$.  \nA barrage of strength $S$ increases by $1$ the freezing level of every cell “on the shooting line in that direction, within distance at most $S$ from Cirno (including the cell she stands on).” Special cases:\n\n1. If a cell’s freezing level is $4$, it does not change.\n2. If the barrage path encounters an ice block placed on the ground (height $0$) at some position (i.e., the barrage hits a partially built house), the barrage is blocked and cannot affect that cell or any cells behind it.\n3. Any portion of the barrage outside the field is ignored.\n\nFor this operation, output one line: CIRNO FREEZED k BLOCK(S)  \nIf this barrage successfully increases a cell’s freezing level by $1$, we say the barrage has frozen that cell.\n\nk is the total number of cells frozen by this barrage.\n\nExample: Before firing, the map is:\n```plain\n00000\n00000\n00000\n000x0\n00000\n```\nAfter executing ICE_BARRAGE 1 1 5 4, the map becomes:\n```plain\n00000\n01000\n00100\n000x0\n00000\n```\nOutput: CIRNO FREEZED 2 BLOCK(S)  \nExplanation: Cirno stands at row $1$, column $1$, fires a barrage of strength $4$ toward down-right, but it is blocked by x and only affects cells before x.\n\nSecond operation: MAKE_ICE_BLOCK  \n-------------------------\nCirno traverses all cells with freezing level $4$, gathers one ice block from each, and resets their freezing levels to $0$.\n\nFor this operation, output one line: CIRNO MADE x ICE BLOCK(S),NOW SHE HAS y ICE BLOCK(S)  \nThis means Cirno made x ice blocks and now has y ice blocks.  \nFor example, Cirno initially has $0$ ice blocks, and the map is:\n```plain\n0xxx\n0x4x\n0x9x\n0400\n```\nAfter executing MAKE_ICE_BLOCK, it becomes:\n```plain\n0xxx\n0x0x\n0x5x\n0000\n```\nOutput: CIRNO MADE 3 ICE BLOCK(S),NOW SHE HAS 3 ICE BLOCK(S)  \nIn this example, part of the house is already built, x denotes walls, and the 9 indicates that the ground at that position is empty but there is an ice block above (you can guess it’s the door). The only empty cell inside the room, the door position, and one position outside the room have freezing level $4$, so $3$ ice blocks can be collected. After collecting, these three cells are reset to $0$.\n\nThird operation: PUT_ICE_BLOCK R C H \n-----------------\nPlace an ice block at row $R$, column $C$, height $H$. $0 \\le R, C < N, 0 \\le H < H_M$.\n\nGround level is height $0$. If placement succeeds, Cirno’s stock decreases by $1$.\n\nIf the block is placed at ground level, the cell’s freezing level is immediately reset to $0$.\n\nThere are several cases; smaller indices have higher priority, and exactly one case applies.\n\nOnly if case 1 is not satisfied can case 2 be considered, and so on.\n\n1. Cirno currently has no ice blocks and cannot place one. Output: CIRNO HAS NO ICE_BLOCK\n2. The ice block would be floating in the air, not attached to any other ice block, or the target position is already occupied.  \nIn this case, output one line: BAKA CIRNO,CAN'T PUT HERE, and ignore this operation entirely.\n3. The ice block is placed outside the planned house area, i.e.,\n$R < H_R$ or $R > H_R + H_X - 1$  \nor $C < H_C$ or $C > H_C + H_Y - 1$. Output one line: CIRNO MISSED THE PLACE  \nEven though Cirno misplaced the block, you cannot stop her from placing it.\n4. The ice block is placed inside the house, occupying a space that should be kept empty, i.e.,  \n$H_R + 1 \\le R \\le H_R + H_X - 2$ and $H_C + 1 \\le C \\le H_C + H_Y - 2$  \nBefore the roof height is finalized, we consider all positions satisfying the above as inside the house.  \nOutput one line: CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE  \nEven though Cirno misplaced the block, you cannot stop her from placing it.\n5. The ice block is placed at a correct position (ignore whether it blocks the reserved door space).  \nOutput one line: CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS x ICE_BLOCK(S)  \nx is the remaining number of ice blocks after placing this one.\n\nFourth operation: REMOVE_ICE_BLOCK R C H \n---------\nRemove the ice block at row $R$, column $C$, height $H$.  \nThere are several cases; smaller indices have higher priority, and exactly one case applies.\n\nOnly if case 1 is not satisfied can case 2 be considered, and so on.\n\n1. There is no ice block at the target position. Output: BAKA CIRNO,THERE IS NO ICE_BLOCK\n2. There is an ice block at the target position, and after removing it, at least one connected component of ice blocks becomes floating.  \nAs in the following “side view,” x denotes an ice block and 0 denotes empty:\n```plain\nxxxx\nx000\nx000\nx000\n```\nAfter removing the top-left ice block, the three blocks to its right in the top row lose support and form a floating connected component, which belongs to this case.  \nThis ice block is successfully removed, Cirno’s stock increases by $1$, and all floating connected components fall and shatter, disappearing completely  \n(neither added to the stock nor leaving any trace on the ground).  \nOutput: CIRNO REMOVED AN ICE_BLOCK,AND k BLOCK(S) ARE BROKEN, where k is the number of shattered blocks.\n3. Cirno removes the ice block and no other block is affected.  \nCirno’s stock increases by $1$. Output: CIRNO REMOVED AN ICE_BLOCK\n\nFifth operation: MAKE_ROOF \n--------\nThis operation appears exactly once and only as the last operation.  \nIt indicates that Cirno has finished the four walls and only the roof remains!\n\nIn the general case, Cirno places the final $H_X \\times H_Y$ ice blocks at the layer one unit above the highest height of the walls to form a roof. Then she removes all excessive blocks and repairs any defects in the walls.\n\nYou must execute the entire process in order. As soon as one of the special cases marked with • occurs, finish that special case and then terminate the process.\n\nEverything described between special cases is the general case, and is assumed to occur unless a special case has already caused an early exit.\n\nFirst, Cirno will place at most $H_X \\times H_Y$ ice blocks at once to build the roof.\n\nWhy “at most”? Note that if previously misplaced blocks inside the house happen to serve as part of the roof, then no additional block is needed at those positions. Also, any blocks above the roof will later be treated as misplaced outside the house.\n\nNote: while placing the roof, the plane at height $H_M$ might be touched.\n\nTwo special cases may occur before or after building the roof:\n- Cirno does not have enough ice blocks to build the roof. Output: SORRY CIRNO,NOT ENOUGH ICE_BLOCK(S) TO MAKE ROOF\n- The highest wall height is less than $2$ cells, or the interior usable space is less than two cells.  \nThe ring occupied by the walls is not counted as interior space. When computing interior usable space, ignore misplaced blocks because they will be removed later.  \nOutput: SORRY CIRNO,HOUSE IS TOO SMALL\n\n(Special cases end.)\n\nAfter this, assume Cirno has built the roof. Next, remove all excessive blocks. During removal, Cirno will try to minimize the number of blocks that shatter. If some wall block would shatter as a consequence of removing excessive blocks, she will first take down that wall block and then restore it when repairing the wall (clearly, this does not change whether the wall has defects, but it saves a block). She will not deliberately remove a wall block that would not shatter.  \nOutput two lines:  \nK1 ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED  \nK2 ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED  \nK1 is the number of misplaced blocks inside the house; K2 is the number outside the house.\n\nOne special case may occur:\n- Cirno removes all excessive blocks, but the roof collapses during removal.  \nOutput: SORRY CIRNO,HOUSE IS BROKEN WHEN REMOVING BLOCKS\n\n(Special cases end.)\n\nAfter this, assume all excessive blocks have been removed. Next, repair any defects in the walls.\n\nDefinition of having wall defects: excluding the $1$-wide and $2$-high door, if from inside the house you can still see the outside through other openings, then the wall has defects.\n\nIf an empty spot is intended to be part of the door, it is not a defect. The house can have only one door.\n\nIf the walls have no defects, do not repair; otherwise, repair. You must record whether the walls had defects; this will be used later.\n\nRepair strategy: use as few blocks as possible, at correct positions, to make the house no longer meet the definition of having wall defects (i.e., do not place extra blocks just to block line of sight). Under this definition, in most cases we can ignore the completeness of the four corner pillars because they are not visible from inside the room.\n\nOne special case may occur:\n- Cirno does not have enough ice blocks to fix the wall defects.  \nOutput: SORRY CIRNO,NOT ENOUGH ICE_BLOCKS TO FIX THE WALL\n\n(Special cases end.)\n\nAfter this, assume the house has been successfully built. You must output several lines to evaluate the house.\n\nFirst, celebrate the completion: GOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE  \n1. If at ground level no $1$-wide and $2$-high opening can be reserved for the door,  \n\toutput: HOUSE HAS NO DOOR, and then Cirno will try to utilize wall defects to open a door.  \n    Otherwise, output: DOOR IS OK\n2. Next, output one line describing the wall’s completeness before repairs:  \n\t2.1. If the earlier record says the wall was incomplete and needed repairs, output: WALL NEED TO BE FIXED  \n    2.2. If the earlier record says the wall was complete and needed no repairs, output: WALL IS OK\n3. Next, one line about the completeness of the four corners.  \n\tIf any of the four corner pillars is incomplete, output: CORNER NEED TO BE FIXED  \n    In this case, if Cirno has enough blocks to fix the corner gaps, she will fix them immediately.  \n    If not, she will collect just enough additional blocks and then fix the gaps.  \n    Otherwise, output: CORNER IS OK\n    \nFinally, output: CIRNO FINALLY HAS k ICE_BLOCK(S)  \nk is the number of ice blocks Cirno has in the end.\n\nLastly, if the earlier record shows the walls were flawless with no positions to repair, there were no extra blocks either inside or outside the house with no positions to remove, no “house has no door” situation occurred, the four corners were fully built before making the roof (not completed via later repairs), and the door is exactly at the center of some wall (if even length, either of the two middle positions counts), then output:  \nCIRNO IS PERFECT!", "inputFormat": "The first line contains a positive integer $N$, the size of the field.\n\nThe second line contains a positive integer $H_M$, the maximum height at which Cirno may place blocks.\n\nThe third line contains four positive integers $H_R, H_C, H_X, H_Y$, the row and column of the top-left corner of the house, and the house’s length and width.\n\nThe fourth line contains a positive integer $M$, the number of operations.\n\nThe next $M$ lines each contain one operation; see the Description for formats.", "outputFormat": "As described in the problem statement.", "hint": "There are $6$ Subtasks. Each Subtask’s testdata satisfies certain conditions and also satisfies those of all Subtasks with larger indices.  \nFor example, Subtask #0 also satisfies the conditions of Subtasks #0–5.  \nEach Subtask’s score is the minimum across all its test points.\n\nSubtask #0 20%  \nCirno only wants to play with ice barrages. She will not place any ice blocks and will not build the house (i.e., only operations 1 and 2).\n\nSubtask #1 10%  \nCirno will not remove already placed ice blocks.\n\nSubtask #2 20%  \nCirno is confident; she will build her igloo without MAKE_ROOF (in this case, the placement heights are still less than $H_M$, and there is no MAKE_ROOF operation).\n\nSubtask #3 20%  \nCirno will be cautious when removing blocks and will not cause any ice blocks to fall. During MAKE_ROOF, removing excessive blocks will not cause the roof to collapse.\n\nSubtask #4 20%  \nCirno dislikes placing the door next to a corner pillar (the testdata guarantees that among all possible wall openings for the door, there exists an option where the door is not adjacent to a corner pillar).\n\nSubtask #5 10%  \n$4 \\le N \\le 16$, $5 \\le H_M \\le 20$, $10 \\le M \\le 10^3$, and all empty ground cells outside the house area form at most one connected component.\n\nNote: When judging whether the wall has defects, if a candidate door opening is blocked by a block at that time, it is still considered blocked. “Can see the defect” is judged based on the state at that moment.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "琪露诺的冰雪小屋", "background": "琪露诺有一片正方形的雪地，她想在上面盖一栋小冰屋。", "description": "琪露诺偶然间得到了一片 $N\\times N$ 大小的正方形的雪地，她想在上面盖一栋冰雪小屋。\n\n但调皮的⑨才不会认真地收集冰块呢，她要在这片土地上使用冰雪弹幕来制造冰砖，然后一块一块地搭起一个房子。\n\n琪露诺制造冰砖的方式是这样的：她会站在某个方格上，然后向上，下，左，右，左上，左下，右上，右下这八个方向之一发射强力的冰雪弹幕，弹幕能影响到该方向一条直线上一定的距离以内的所有方格。\n\n地面的每个方格都有一个冷冻度，初始为 $0$。被冰雪弹幕影响一次，冷冻度 $+1$，冷冻度的上限为 $4$。\n\n在发射弹幕的间隙中，琪露诺会来到所有冷冻度为 $4$ 的格子，把那里的雪堆到一起，制作一个冰砖（大小为 $1\\times1\\times1$ 方格），并且将冷冻度重新归零。\n\n琪露诺会拿着这些冰砖来盖房子。这个房子的长度、宽度和坐落位置她在一开始就已经规划好了，但她并不愿意提早确定房子的高度。\n\n琪露诺是这样计划的：这个房子外观上看起来是一个长方体。\n\n她会先盖起这个房子的四面墙（厚度为 $1$ 个方格），并在贴近地面的位置（废话）留一个宽度和高度分别为 $1$ 和 $2$ 的空位不放冰砖，作为房门。（显然，门无法开在墙的拐角处，但可以紧贴拐角）。\n\n在她喜欢的时候，她会结束四面墙的建造，并一次性在墙顶部盖上一个厚度为 $1$ 方格的屋顶，使房子成为一个空心有顶的长方体。\n\n计划已经非常充分了，但琪露诺还是不放心，所以她想请你帮她写一个程序，来随时提醒着她别出什么差错。这个程序需要具备的功能将在下文详细介绍。\n\n----------------------\n雪地由 $N$ 行 $N$ 列，$N\\times N$ 个方格组成。（下标从 $0$ 开始，也就是说，存在第 $0$ 行第 $0$ 列，但不存在第 $N$ 行第 $N$ 列）每个方格都有一个冷冻度,范围 $[0,4]$，初始为 $0$。注意，空间是三维的，而冷冻度只是地面的属性。\n\n琪露诺想将房子的左上角放在第 $H_R$ 行，$H_C$ 列（外墙也是房子的一部分，因此左上角位置不应该是房子的内部,而是外墙,并且是墙的拐角）。\n\n这个房子的长度（平行于每列）是 $H_X$，宽度（平行于每行）是 $H_Y$，包含墙。保证房子所占空间不会超出雪地的范围。\n\n除了最后搭建屋顶，琪露诺只会在高度 $[0,H_M-1]$ 放置冰砖。\n\n一开始，琪露诺一个冰砖也没有。\n在以下的介绍中，我们用俯视图来作示意：\n```plain\n0000\n0000\n4x90\n0x01\n```\n数字代表当前该格子的冷冻度。如果位置紧贴地面（高度为 $0$）的地方放上了冰砖，那么用字母 $x$ 表示。\n\n如果紧贴地面的位置没有冰砖，但是位置正上方的高空存在冰砖，那么仍然用数字表示地面的冷冻度，但这个数字会增加 $5$。即如果在示意图中看到了一个数字 $t\\ge5$，表示该位置地面是空的，但高处有冰砖，且地面的冷冻度为 $t-5$。\n\n第一个操作：`ICE_BARRAGE R C D S`  \n---------------\n表示琪露诺站在第 $R$ 行 $C$ 列的位置，朝着方向 $D$ 发射了一个强度为 $S$ 的弹幕。  \n$R,C,D,S\\in\\Z,0\\le D\\le7,0\\le R,C,S<N$。  \n方向编号 $0$ 表示上 $(R-1,C)$，$1$ 表示左上 $(R-1,C-1)$，   \n$2$ 表示左 $(R,C-1)$，$3$ 表示左下 $(R+1,C-1)$，  \n$4$ 表示下 $(R+1,C)$，$5$ 表示右下 $(R+1,C+1)$，  \n$6$ 表示右 $(R,C+1)$，$7$ 表示右上 $(R-1,C+1)$。  \n强度为 $S$ 的弹幕，可以使“处在发射方向直线上，距离琪露诺不超过 $S$ 格的所有格子（包括她站的格子）”的冷冻度都 $+1$。有以下几种特殊情况：\n\n1. 如果某个格子冷冻度为 $4$，那么该格子冷冻度不变。\n2. 如果弹幕所经路途上，有一个位置的地面上（高度为 $0$）已经放了冰砖（就是弹幕撞上了琪露诺已经盖了一半的房子），那么弹幕将被阻挡，无法影响到冰砖所在的格子以及冰砖后面被挡住的格子。\n3. 弹幕超出雪地的部分忽略不计。\n\n对于这个操作，需要如下输出一行：`CIRNO FREEZED k BLOCK(S)`  \n如果这个弹幕将某个方格的冷冻度成功增加了 $1$，那么认为这个弹幕冻住了该方格。\n\n`k` 表示这个弹幕总共冻住了多少方格。\n\n如图：发射弹幕前地图如下：\n```plain\n00000\n00000\n00000\n000x0\n00000\n```\n执行操作 `ICE_BARRAGE 1 1 5 4`，地图变为：\n```plain\n00000\n01000\n00100\n000x0\n00000\n```\n输出：`CIRNO FREEZED 2 BLOCK(S)`  \n解释：琪露诺站在第一行第一列，面对右下角发射了一个强度为 $4$ 的弹幕，但弹幕被 `x` 所阻挡，只能影响到 `x` 之前的格子。\n\n第二个操作：`MAKE_ICE_BLOCK`  \n-------------------------\n琪露诺走遍地图上所有冷冻度为 $4$ 的方格，每个方格可以收集一个冰砖，然后将它们的冷冻度归零。 \n\n对于这个操作，你需要给出如下输出一行：`CIRNO MADE x ICE BLOCK(S),NOW SHE HAS y ICE BLOCK(S)`  \n表示琪露诺制造了 $x$ 个冰砖，目前她有 $y$ 个冰砖。  \n比如琪露诺一开始有 $0$ 个冰砖，并且状态如下：\n```plain\n0xxx\n0x4x\n0x9x\n0400\n```\n执行操作 `MAKE_ICE_BLOCK` 后变为\n```plain\n0xxx\n0x0x\n0x5x\n0000\n```\n输出：`CIRNO MADE 3 ICE BLOCK(S),NOW SHE HAS 3 ICE BLOCK(S)`  \n在这个示例中，房子已经完成了一部分，`x` 表示墙，`9` 这个位置地面没有冰砖，但高处有（可以猜出是门）。房间内唯一一块空地、门的位置，以及房间外的一个位置的冷冻度都达到了 $4$，因此可以收集到 $3$ 块冰砖，收集后将三个位置冷冻度都归零。\n\n第三个操作：`PUT_ICE_BLOCK R C H` \n-----------------\n表示在第 $R$ 行，第 $C$ 列，高度为 $H$ 的地方放一个冰砖。$0\\le R,C<N,0\\le H<H_M$。\n\n贴近地面的位置高度为 $0$。如果冰砖放置成功，那么琪露诺库存的冰砖数量将减 $1$。\n\n如果放置的位置贴近地面，该位置冷冻度立即归 $0$。\n\n有以下几种情况，序号越小优先级越高，并且只能满足一种情况。\n\n如果满足 $1$ 的话就忽视后面的，不满足 $1$ 的前提下才可能满足 $2\\cdots\\cdots$ 以此类推。\n\n1. 琪露诺目前没有任何冰砖，无法放置。这种情况下你需要输出：`CIRNO HAS NO ICE_BLOCK`\n2. 冰砖将放在半空中，无法依附其他任何冰砖，或者目标位置已有冰砖了。  \n这种情况下你需要输出一行：`BAKA CIRNO,CAN'T PUT HERE`，并无视此次操作，不做任何工作。\n3. 冰砖放在了规划建造房子的区域之外，即\n$R<H_R$ 或 $R>H_R+H_x-1$  \n或 $C<H_C$ 或 $C>H_C+H_Y-1$。请输出一行：`CIRNO MISSED THE PLACE`  \n尽管琪露诺放错了地方，但你并不能阻止她放置这个冰砖。  \n4. 冰砖留在了房子的内部，本应留空的地方被占用了，即  \n$H_R+1\\le R\\le H_R+H_X-2$ 且 $H_C+1\\le C\\le H_C+H_Y-2$  \n在屋顶的高度固定下来前，我们将所有满足上式的情况都认为是放在了房屋内部。  \n请输出一行：`CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE`  \n尽管琪露诺放错了地方，但你并不能阻止她放置这个冰砖。\n5. 冰砖放在了正确的位置（不必考虑是否堵住了留给门的地方）  \n请输出一行：`CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS x ICE_BLOCK(S)`  \n`x` 表示放过这块冰砖后琪露诺剩余的冰砖。\n\n第四个操作：`REMOVE_ICE_BLOCK R C H` \n---------\n表示取走第 $R$ 行，第 $C$ 列，高度为 $H$ 处的冰砖。  \n有以下几种情况，序号越小优先级越高，并且只能满足一种情况。\n\n如果满足 $1$ 的话就忽视后面的，不满足 $1$ 的前提下才可能满足 $2\\cdots\\cdots$ 以此类推。\n\n1. 目标位置没有冰砖，输出一行：`BAKA CIRNO,THERE IS NO ICE_BLOCK`\n2. 目标位置有冰砖，并且在这个冰砖被移走后，至少有一个冰砖形成了一个悬空的块。  \n如下面的“侧视图”，`x` 表示冰砖，`0` 表示空位。\n```plain\nxxxx\nx000\nx000\nx000\n```\n$\\ \\ $在移走左上角的冰砖后，第一行右边三个冰砖没有了依靠，形成了一个悬空的连通块，就属于这种情况。  \n$\\ \\ $这个冰砖将成功移走，琪露诺的冰砖库存将会 $+1$。并且所有的悬空连通块都会掉下来摔碎并消失  \n$\\ \\ $（既不会进入冰砖库存，也不会在地面上留有任何痕迹）。  \n$\\ \\ $输出一行：`CIRNO REMOVED AN ICE_BLOCK,AND k BLOCK(S) ARE BROKEN`，`k` 表示摔碎的冰砖数量。  \n3. 琪露诺挪走了冰砖，并且其他冰砖不受任何影响。    \n$\\ \\ \\ $琪露诺的冰砖库存 $+1$，输出一行：`CIRNO REMOVED AN ICE_BLOCK`\n    \n第五个操作：`MAKE_ROOF` \n--------\n这个操作只会出现一次，并且只会作为最后一个操作。  \n这个操作表明琪露诺已经完成了冰雪小屋的四墙，只剩屋顶了！  \n\n一般情况下，琪露诺将放置最后的 $H_X\\times H_Y$ 个冰砖，把它们放置在墙壁最高的高度 $+1$ 的那一层，  \n形成一个屋顶。然后她移除所有多余的冰砖，接下来补好所有残缺的墙壁。\n\n你需要按顺序来执行整个过程，一旦遇到某种用 $\\bullet$ 标识的特殊情况，则执行完该情况后退出流程。\n\n在特殊情况之间所描述的均为一般情况，只要之前没有因为满足某种特殊情况而退出流程，均认为满足了一般情况。\n\n首先，琪露诺将会一次性放置最多 $H_X\\times H_Y$ 个冰砖来建造屋顶。\n\n为什么是最多呢？请注意一点：如果之前错误放置在房子内部的冰砖恰好充当了屋顶的一部分，那么就不用在这个位置再放冰砖了。并且，所有比屋顶高的冰砖在之后将视为错误放置在了房子外部。\n\n注意，放屋顶的时候可能会触及到高度为 $H_M$ 的那个平面。\n\n建造屋顶前后将会碰到两种特殊情况：\n- 琪露诺剩余的冰砖不足以建造屋顶。输出一行：`SORRY CIRNO,NOT ENOUGH ICE_BLOCK(S) TO MAKE ROOF`\n- 墙壁的最高高度小于 $2$ 个方格，或者内部有效空间小于两个方格。  \n墙壁所在的一圈不算内部空间。计算内部有效空间时请忽视错误放置的冰砖，因为它们将来要被移除。  \n输出一行：`SORRY CIRNO,HOUSE IS TOO SMALL`\n\n（特殊情况结束）\n\n此后，我们认为琪露诺已经造好了屋顶，接下来该移除所有多余冰砖了。在移除过程中，琪露诺会尽可能让更少的冰砖摔碎。如果墙壁上某个冰砖因为移走了多余的冰砖而将要摔碎，那么她会先拆掉墙壁上的那个冰砖，然后在填补墙壁残缺时重新补回来（显然，这种行为不会影响到墙壁有无残缺的定性，但可以少损失一个冰砖）。她不会故意拆掉一个处在墙壁上且不会摔碎的冰砖。  \n输出两行：  \n`K1 ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED`  \n`K2 ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED`  \n`K1`表示房子内部错误放置的冰砖数量，`K2`表示房子外部错误放置的冰砖数量。\n\n将有可能遭遇一种特殊情况：\n- 琪露诺移除了所有多余的冰砖，但在移除过程中，屋顶塌陷了。  \n输出一行：`SORRY CIRNO,HOUSE IS BROKEN WHEN REMOVING BLOCKS`\n\n（特殊情况结束）\n\n此后，我们认为琪露诺已经移除了所有多余的冰砖，接下来该填补墙壁的残缺了。\n\n墙壁有残缺的定义是：除了宽为 $1$，高为 $2$ 的门以外，\n在房子内部看外面还能看到其他缺口。\n\n如果某个空位将来要作为门的一部分，则不属于残缺。并且房子只能有一个门。\n\n如果墙壁没有残缺，则不要填补，否则需要填补。你需要记下墙壁是否有残缺，之后会用到。\n\n填补的策略是：使用尽可能少的冰砖，在正确的位置填补墙壁，使房屋的状态不满足墙壁有残缺的定义（即不能放置多余的冰砖，通过遮挡视线来达到目的）。在此定义下，**大多数**情况我们无需考虑四角的柱子是否完整，因为在房间里看不到。\n\n将有可能遭遇一种特殊情况：\n- 琪露诺剩余的冰砖不足以填补墙壁的残缺。  \n输出一行：`SORRY CIRNO,NOT ENOUGH ICE_BLOCKS TO FIX THE WALL`\n\n（特殊情况结束）\n\n此后，我们认为房子被成功建成了，这时你需要输出几行内容来对房子进行评价。\n\n首先输出这么一行来庆祝房子的建成：`GOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE`  \n1. 在贴近地面的位置找不到一个宽度为 $1$，高度为 $2$ 的位置留给门。  \n\t输出一行：`HOUSE HAS NO DOOR`，然后琪露诺会尽可能利用墙壁上的残缺来开一个门。  \n    否则，输出一行：`DOOR IS OK`\n2. 接下来输出一行表示填补之前墙壁的完整程度  \n\t2.1. 在之前的记录中，墙壁不完整而需要修补。输出：`WALL NEED TO BE FIXED`  \n    2.2. 在之前的记录中，墙壁完整而无需修补。输出：`WALL IS OK`  \n3. 接下来一行表示四角的完整程度。  \n\t如果四个角的柱子有不完整的地方，就输出：`CORNER NEED TO BE FIXED`  \n    在这种情况下，如果琪露诺剩余的冰砖足够修复拐角的空缺，那么她直接会修复这个空缺。  \n    如果不够的话，她会再多收集几个冰砖，数量恰好修复这个空缺，然后修复这个空缺。  \n    否则，输出：`CORNER IS OK`\n    \n接下来，输出一行：`CIRNO FINALLY HAS k ICE_BLOCK(S)`  \n`k` 表示琪露诺最后剩余的冰砖的数量。\n\n最后，如果在之前的记录中，墙壁完整无缺，没有一个位置需要填补。房子内外都无任何多余的方块，没有一个位置需要移除。没有出现房子没门的情况，房子四角的柱子也在造屋顶前完全造好，而不是通过修补完善的。并且门恰好开在了某面墙的正中央（如果长度为偶数，中间的两个都算），输出一行：   \n`CIRNO IS PERFECT!`", "inputFormat": "第一行一个正整数 $N$，表示雪地的大小。\n\n第二行一个正整数 $H_M$，表示琪露诺放置方块的最大高度。\n\n第三行四个正整数 $H_R,H_C,H_X,H_Y$，表示房子左上角位置的行列坐标，房子的长度以及宽度。\n\n第四行一个正整数 $M$，表示操作的数量。\n\n接下来 $M$ 行，每行表示一个操作，输入格式见题目描述。", "outputFormat": "在题目描述中已经介绍。", "hint": "共分为 $6$ 个 **Subtask**，每个 **Subtask** 的数据都满足一定条件，并且同时满足序号更大的 **Subtask** 的条件。  \n如 **Subtask #0** 同时满足 **Subtask #0~5** 的条件。  \n每一个 **Subtask** 的得分取所有测试点的最低分。\n\n**Subtask #0** $20\\%$  \n琪露诺只想玩玩冰雪弹幕，她不会放置任何冰砖，也不会盖房子(即只有操作一和操作二)。  \n\n\n**Subtask #1** $10\\%$  \n琪露诺不会移除已经放置的冰砖。\n\n**Subtask #2** $20\\%$  \n琪露诺很有信心，她将在没有 `MAKE_ROOF` 的情况下建造她的冰屋(这种情况下，放置方块的高度仍然会小于 $H_M$ 且没有 `MAKE_ROOF` 操作)。\n\n**Subtask #3** $20\\%$  \n琪露诺在移除方块时会谨慎考虑,不会造成任何冰砖摔落。`MAKE_ROOF` 操作移除多余冰砖时，也不会造成屋顶塌陷。\n\n**Subtask #4** $20\\%$  \n琪露诺不喜欢把门开到四角的柱子旁边(数据保证在所有可能作为门的墙壁空缺中，有一种可能使得门不紧贴四角的柱子)。 \n\n**Subtask #5** $10\\%$  \n$4\\le N\\le 16$，$5\\le H_M\\le 20$，$10\\le M\\le 10^3$，保证不属于冰屋范围内的所有空地至多构成一个连通块。\n\n注意：判断墙壁是否有残缺时，候选的开门位如果被方块堵住，在当时还未被清空。\"能看到残缺\"以当时的情况作为判断依据。", "locale": "zh-CN"}}}
{"pid": "P3694", "type": "P", "difficulty": 5, "samples": [["12 4\n1\n3\n2\n4\n2\n1\n2\n3\n1\n1\n3\n4", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["枚举", "前缀和", "洛谷月赛", "状压 DP"], "title": "邦邦的大合唱站队", "background": "BanG Dream! 里的所有偶像乐队要一起大合唱，不过在排队上出了一些问题。", "description": "$N$ 个偶像排成一列，他们来自 $M$ 个不同的乐队。每个团队至少有一个偶像。\n\n现在要求重新安排队列，使来自同一乐队的偶像连续的站在一起。重新安排的办法是，让若干偶像出列（剩下的偶像不动），然后让出列的偶像一个个归队到原来的空位，归队的位置任意。\n\n请问最少让多少偶像出列？", "inputFormat": "第一行 $2$ 个整数 $N,M$。\n\n接下来 $N$ 行，每行一个整数 $a_i(1\\le a_i \\le M)$，表示队列中第 $i$ 个偶像的团队编号。", "outputFormat": "一个整数，表示答案。", "hint": "【样例解释】\n\n```cpp\n1  3   √\n3  3\n2  3   √\n4  4\n2  4   √\n1  2   √\n2  2\n3  2   √\n1  1\n1  1\n3  1   √\n4  1   √\n```\n【数据规模】\n\n对于 $20\\%$ 的数据，$N\\le 20, M=2$；\n\n对于 $40\\%$ 的数据，$N\\le 100, M\\le 4$；\n\n对于 $70\\%$ 的数据，$N\\le 2000, M\\le 10$；\n\n对于全部数据，$1\\le N\\le 10^5, M\\le 20$。", "locale": "zh-CN", "translations": {"en": {"title": "BanG Dream!'s Mass Chorus Lineup", "background": "All idol bands in BanG Dream! are going to sing a chorus together, but there are some issues with the lineup.", "description": "There are $N$ idols standing in a line, coming from $M$ different bands. Each band has at least one idol.\n\nWe want to rearrange the line so that idols from the same band stand together contiguously. The way to rearrange is: let some idols leave the line (the remaining idols do not move), then let the removed idols return one by one to fill the vacated positions; they may return to any empty positions.\n\nWhat is the minimum number of idols that must leave the line?", "inputFormat": "The first line contains $2$ integers $N$ and $M$.\n\nThen there are $N$ lines, each containing an integer $a_i(1\\le a_i \\le M)$, representing the band ID of the $i$-th idol in the line.", "outputFormat": "Output a single integer, the answer.", "hint": "Sample explanation:\n\n```cpp\n1  3   √\n3  3\n2  3   √\n4  4\n2  4   √\n1  2   √\n2  2\n3  2   √\n1  1\n1  1\n3  1   √\n4  1   √\n```\n\nConstraints:\n\n- For $20\\%$ of the testdata, $N\\le 20, M=2$.\n- For $40\\%$ of the testdata, $N\\le 100, M\\le 4$.\n- For $70\\%$ of the testdata, $N\\le 2000, M\\le 10$.\n- For all testdata, $1\\le N\\le 10^5, M\\le 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "邦邦的大合唱站队", "background": "BanG Dream! 里的所有偶像乐队要一起大合唱，不过在排队上出了一些问题。", "description": "$N$ 个偶像排成一列，他们来自 $M$ 个不同的乐队。每个团队至少有一个偶像。\n\n现在要求重新安排队列，使来自同一乐队的偶像连续的站在一起。重新安排的办法是，让若干偶像出列（剩下的偶像不动），然后让出列的偶像一个个归队到原来的空位，归队的位置任意。\n\n请问最少让多少偶像出列？", "inputFormat": "第一行 $2$ 个整数 $N,M$。\n\n接下来 $N$ 行，每行一个整数 $a_i(1\\le a_i \\le M)$，表示队列中第 $i$ 个偶像的团队编号。", "outputFormat": "一个整数，表示答案。", "hint": "【样例解释】\n\n```cpp\n1  3   √\n3  3\n2  3   √\n4  4\n2  4   √\n1  2   √\n2  2\n3  2   √\n1  1\n1  1\n3  1   √\n4  1   √\n```\n【数据规模】\n\n对于 $20\\%$ 的数据，$N\\le 20, M=2$；\n\n对于 $40\\%$ 的数据，$N\\le 100, M\\le 4$；\n\n对于 $70\\%$ 的数据，$N\\le 2000, M\\le 10$；\n\n对于全部数据，$1\\le N\\le 10^5, M\\le 20$。", "locale": "zh-CN"}}}
{"pid": "P3695", "type": "P", "difficulty": 6, "samples": [["{ vars\n    a:int\n    b:int\n}\n\n:set a, 1\n:set b, 2\n:yosoro a+b\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "洛谷原创", "O2优化", "洛谷月赛"], "title": "CYaRon!语", "background": "「千歌です」（我是千歌）、「曜です」（我是曜）、「ルビィです」（我是露比）、「3人合わせて、We are CYaRon！ よろしくね！」（三人在一起，我们是CYaRon！多多指教哦！）\n\n\nCYaRon!的三人在学习了编程之后，决定发明一种自己的编程语言，她们称为CYaRon!语。\n\n\n\n(ltt: 明明是我帮她们发明的。)\n\n可是，因为洛谷评测机这时候突然爆了，ltt没有时间再帮CYaRon!的三位小姐姐写CYaRon!语的解释器了。\n\n\n于是ltt就出了这样一道题，然后等着有人交了AC程序就偷走给小姐姐们。\n", "description": "以下是一个典型的CYaRon! 语程序。\n\n\n```cpp\n{ vars\n    chika:int\n    you:int\n    ruby:array[int, 1..2]\n    i:int\n}\n# 以上变量默认值均为0\n# 变量名只可是英文字母。\n\n# yosoro语句可以输出一个数字，随后跟一个空格。\n:yosoro 2\n# 输出2和一个空格(以下不再提到空格)。\n\n# set语句可以为变量赋值。\n# 运算符只支持加减号即可。\n:set chika, 1\n:set you, 2\n:yosoro chika + you\n# 上一条语句将输出3\n\n# 以下的判断语句均使用以下的格式：\n# 操作符，表达式，表达式\n# 例如eq, a, 1即C语言中 a==1\n# 所有操作符包括: lt: < gt: > le: <= ge: >= eq: == neq: !=\n\n# 日本来的CYaRon三人没法正确地发出if这个音，因此她们就改成了ihu。\n{ ihu eq, chika, 1\n    :set you, 3\n    :yosoro 1\n}\n# 输出1\n# 以上是ihu语句，无需支持else。\n\n# hor语句同理，\n# for i=1 to you如下\n{ hor i, 1, you\n    :yosoro i\n}\n# 输出1 2 3\n\n# 如下是while和数组的使用方法。\n:set i, 1\n{ while le, i, 2\n    :yosoro i\n    :set ruby[i], i+1\n    :yosoro ruby[i]\n    :set i, i+1\n}\n# 输出1 2 2 3\n\n# 数组不会出现嵌套，即只会有a[i]、a[i+2]而不会有类似于a[i+b[i]]这样的。\n\n# CYaRon语的最后一行，一定是一个换行。\n \n```\n\n你的任务是写一个CYaRon!语的解释器，实现输入CYaRon!语的程序，解释之执行后输出执行结果。\n", "inputFormat": "输入文件全部为CYaRon!语程序，最后一行保证是个空行。\n\n请处理输入的时候，一直读到EOF为止。\n", "outputFormat": "该CYaRon!语程序的执行结果。\n\n具体上，是该CYaRon!语程序所有:yosoro语句的输出。\n", "hint": "对数据做出以下保证：\n\n1. 输入数据一定是合法的CYaRon!语程序，不包含注释，代码、缩进风格 （四个空格）与上述样例相同。**但不保证逗号、运算符前面的空格数量和有无一定相同**。\n\n2. 变量名在10个字符以下，仅包含小写英文，数组最大大小为1000，变量最多50个，所有表达式的运算结果，包括变量的值一定在int范围内。 （但数组可能是类似于[2001..3000]的，下标可能范围为0到1亿）\n\n3. 所有指令小写。\n\n4. 该程序一定能够在合理的时间、内存限制内执行完毕。\n\n5. hor语句执行过程中，循环变量、初始值、结束值不会被循环中的代码改变。\n\n6. **该程序最多500行**\n\n![](https://cdn.luogu.com.cn/upload/pic/4595.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "CYaRon! Language", "background": "「千歌です」 (I am Chika), 「曜です」 (I am You), 「ルビィです」 (I am Ruby), 「3人合わせて、We are CYaRon！ よろしくね！」 (Together we are CYaRon! Nice to meet you!).\n\nAfter learning programming, the three members of CYaRon! decided to invent their own programming language, which they call the CYaRon! language.\n\n(ltt: Clearly I was the one who invented it for them.)\n\nHowever, because the Luogu judge suddenly exploded at this time, ltt did not have time to help the three young ladies of CYaRon! write an interpreter for the CYaRon! language.\n\nSo ltt made this problem and is waiting to steal an AC submission to give to the young ladies.", "description": "Below is a typical CYaRon! language program.\n\n```cpp\n{ vars\n    chika:int\n    you:int\n    ruby:array[int, 1..2]\n    i:int\n}\n# All the above variables have a default value of 0.\n# Variable names can only be English letters.\n\n# The yosoro statement outputs a number followed by a space.\n:yosoro 2\n# Outputs 2 and a space (we will no longer mention the space below).\n\n# The set statement assigns a value to a variable.\n# Only addition and subtraction operators are supported.\n:set chika, 1\n:set you, 2\n:yosoro chika + you\n# The previous statement outputs 3.\n\n# The following conditional statements all use this format:\n# operator, expression, expression\n# For example, eq, a, 1 means a == 1 in the C language.\n# All operators include: lt: < gt: > le: <= ge: >= eq: == neq: !=\n\n# The three from Japan cannot pronounce \"if\" correctly, so they changed it to \"ihu\".\n{ ihu eq, chika, 1\n    :set you, 3\n    :yosoro 1\n}\n# Outputs 1.\n# The above is an ihu statement; else is not required.\n\n# The hor statement is similar,\n# it corresponds to: for i = 1 to you\n{ hor i, 1, you\n    :yosoro i\n}\n# Outputs 1 2 3\n\n# Below is how to use while and arrays.\n:set i, 1\n{ while le, i, 2\n    :yosoro i\n    :set ruby[i], i+1\n    :yosoro ruby[i]\n    :set i, i+1\n}\n# Outputs 1 2 2 3\n\n# Arrays will not be nested, i.e., you will only have a[i], a[i+2], and not something like a[i + b[i]].\n\n# The last line of a CYaRon! program must be a newline.\n \n```\n\nYour task is to write an interpreter for the CYaRon! language. Read a CYaRon! program from input, execute it by interpretation, and output the execution result.", "inputFormat": "The input file is entirely a CYaRon! language program, and the last line is guaranteed to be an empty line.\n\nWhen reading the input, keep reading until EOF.", "outputFormat": "The execution result of the CYaRon! language program.\n\nSpecifically, it is the outputs of all :yosoro statements in the program.", "hint": "We guarantee the following about the testdata:\n\n1. The input is guaranteed to be a valid CYaRon! language program, without comments. The code style and indentation (four spaces) match the sample above. However, the number and presence of spaces before commas and operators are not guaranteed to be the same.\n\n2. Variable names are fewer than 10 characters and contain only lowercase English letters. The maximum array size is 1000. The maximum number of variables is 50. The result of every expression, including variable values, is guaranteed to fit in the int range. (However, arrays may have ranges like [2001..3000], and indices may range from 0 up to 1e8.)\n\n3. All instructions are lowercase.\n\n4. The program is guaranteed to finish within reasonable time and memory limits.\n\n5. During the execution of a hor statement, the loop variable, the initial value, and the end value will not be changed by the code inside the loop.\n\n6. The program has at most 500 lines.\n\n![](https://cdn.luogu.com.cn/upload/pic/4595.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "CYaRon!语", "background": "「千歌です」（我是千歌）、「曜です」（我是曜）、「ルビィです」（我是露比）、「3人合わせて、We are CYaRon！ よろしくね！」（三人在一起，我们是CYaRon！多多指教哦！）\n\n\nCYaRon!的三人在学习了编程之后，决定发明一种自己的编程语言，她们称为CYaRon!语。\n\n\n\n(ltt: 明明是我帮她们发明的。)\n\n可是，因为洛谷评测机这时候突然爆了，ltt没有时间再帮CYaRon!的三位小姐姐写CYaRon!语的解释器了。\n\n\n于是ltt就出了这样一道题，然后等着有人交了AC程序就偷走给小姐姐们。\n", "description": "以下是一个典型的CYaRon! 语程序。\n\n\n```cpp\n{ vars\n    chika:int\n    you:int\n    ruby:array[int, 1..2]\n    i:int\n}\n# 以上变量默认值均为0\n# 变量名只可是英文字母。\n\n# yosoro语句可以输出一个数字，随后跟一个空格。\n:yosoro 2\n# 输出2和一个空格(以下不再提到空格)。\n\n# set语句可以为变量赋值。\n# 运算符只支持加减号即可。\n:set chika, 1\n:set you, 2\n:yosoro chika + you\n# 上一条语句将输出3\n\n# 以下的判断语句均使用以下的格式：\n# 操作符，表达式，表达式\n# 例如eq, a, 1即C语言中 a==1\n# 所有操作符包括: lt: < gt: > le: <= ge: >= eq: == neq: !=\n\n# 日本来的CYaRon三人没法正确地发出if这个音，因此她们就改成了ihu。\n{ ihu eq, chika, 1\n    :set you, 3\n    :yosoro 1\n}\n# 输出1\n# 以上是ihu语句，无需支持else。\n\n# hor语句同理，\n# for i=1 to you如下\n{ hor i, 1, you\n    :yosoro i\n}\n# 输出1 2 3\n\n# 如下是while和数组的使用方法。\n:set i, 1\n{ while le, i, 2\n    :yosoro i\n    :set ruby[i], i+1\n    :yosoro ruby[i]\n    :set i, i+1\n}\n# 输出1 2 2 3\n\n# 数组不会出现嵌套，即只会有a[i]、a[i+2]而不会有类似于a[i+b[i]]这样的。\n\n# CYaRon语的最后一行，一定是一个换行。\n \n```\n\n你的任务是写一个CYaRon!语的解释器，实现输入CYaRon!语的程序，解释之执行后输出执行结果。\n", "inputFormat": "输入文件全部为CYaRon!语程序，最后一行保证是个空行。\n\n请处理输入的时候，一直读到EOF为止。\n", "outputFormat": "该CYaRon!语程序的执行结果。\n\n具体上，是该CYaRon!语程序所有:yosoro语句的输出。\n", "hint": "对数据做出以下保证：\n\n1. 输入数据一定是合法的CYaRon!语程序，不包含注释，代码、缩进风格 （四个空格）与上述样例相同。**但不保证逗号、运算符前面的空格数量和有无一定相同**。\n\n2. 变量名在10个字符以下，仅包含小写英文，数组最大大小为1000，变量最多50个，所有表达式的运算结果，包括变量的值一定在int范围内。 （但数组可能是类似于[2001..3000]的，下标可能范围为0到1亿）\n\n3. 所有指令小写。\n\n4. 该程序一定能够在合理的时间、内存限制内执行完毕。\n\n5. hor语句执行过程中，循环变量、初始值、结束值不会被循环中的代码改变。\n\n6. **该程序最多500行**\n\n![](https://cdn.luogu.com.cn/upload/pic/4595.png)\n", "locale": "zh-CN"}}}
{"pid": "P3696", "type": "P", "difficulty": 6, "samples": [["3\n3 500\n2 200\n1 100\n1 1000\n3 700\n3 400", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "排序", "洛谷月赛"], "title": "Bushiroad的偶像派对", "background": "Bushiroad又叫不许摸。\n", "description": "Bushiroad的派对有N个校园偶像团体，可能来自编号1-N的学校。每个学校可能有多个团体参加，也有可能没有团体参加。在所有的团体都演出完后，进行人气投票。\n\n我们已经掌握了中场时和结束时的两张人气排行表。给出排行表从人气高到低排序，并给出每个组的学校编号（你却不知道具体是哪个团体）\n\n可是，结束时的表是不太准确的。因为基于这样的一个事实：某个团体的结束时的人气不会低于中场的人气，而且每个团体的学校不会改变。结束的表产生一些矛盾。\n\n负责统计的人为了不想背锅，希望尽可能少修改结束时的排行表的某些团体的学校（人气值不能改），使其不矛盾，请问至少要修改多少个呢？\n", "inputFormat": "第一行一个整数N，表示有N个团体。\n\n接下来N行，每行两个整数，$Ta_i, Pa_i$，表示中场时的人气值排行，$Ta_i$表示学校名。$Pa_i$表示人气值，按照人气值高往低排列。\n\n接下来N行，每行两个整数，$Tb_i, Pb_i$，表示结束时的人气值排行。\n", "outputFormat": "一个整数表示答案。\n", "hint": "【数据范围】\n\n对于20%的数据， $N\\le16$，时限0.5s。\n\n对于40%的数据， $N\\le50$，时限0.5s。\n\n对于70%的数据， $N\\le5000$，时限1s。\n\n对于全部测试数据， $N\\le200000, A\\le10^9$。最后3个点时限3s。\n", "locale": "zh-CN", "translations": {"en": {"title": "Bushiroad's Idol Party", "background": "Bushiroad is also called \"bu xu mo\".", "description": "There are $N$ school idol groups, possibly from schools numbered $1$ to $N$. Each school may have multiple groups participating, or none. After all groups finish performing, a popularity vote is held.\n\nWe have two popularity rankings: one at halftime and one at the end. Each ranking is sorted from higher to lower popularity, and shows each group's school ID (but you do not know which specific group).\n\nHowever, the final ranking is not quite correct. Based on the facts that a group's final popularity is not lower than its halftime popularity, and a group's school does not change, the final ranking produces contradictions.\n\nThe statistician, trying to avoid blame, wants to modify as few school IDs in the final ranking as possible (popularity values cannot be changed) to eliminate contradictions. What is the minimum number of modifications?", "inputFormat": "- The first line contains an integer $N$, the number of groups.\n- The next $N$ lines each contain two integers, $Ta_i, Pa_i$, representing the halftime popularity ranking. $Ta_i$ is the school ID, and $Pa_i$ is the popularity value. These lines are sorted in descending order by popularity.\n- The next $N$ lines each contain two integers, $Tb_i, Pb_i$, representing the final popularity ranking. These lines are also sorted in descending order by popularity.", "outputFormat": "Output a single integer: the answer.", "hint": "Constraints\n\n- For 20% of the testdata, $N \\le 16$, time limit 0.5 s.\n- For 40% of the testdata, $N \\le 50$, time limit 1 s.\n- For 70% of the testdata, $N \\le 5000$, time limit 1 s.\n- For all testdata, $N \\le 200000$, and all popularity values are $\\le 10^9$. The last 3 test points have a 3 s time limit.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Bushiroad的偶像派对", "background": "Bushiroad又叫不许摸。\n", "description": "Bushiroad的派对有N个校园偶像团体，可能来自编号1-N的学校。每个学校可能有多个团体参加，也有可能没有团体参加。在所有的团体都演出完后，进行人气投票。\n\n我们已经掌握了中场时和结束时的两张人气排行表。给出排行表从人气高到低排序，并给出每个组的学校编号（你却不知道具体是哪个团体）\n\n可是，结束时的表是不太准确的。因为基于这样的一个事实：某个团体的结束时的人气不会低于中场的人气，而且每个团体的学校不会改变。结束的表产生一些矛盾。\n\n负责统计的人为了不想背锅，希望尽可能少修改结束时的排行表的某些团体的学校（人气值不能改），使其不矛盾，请问至少要修改多少个呢？\n", "inputFormat": "第一行一个整数N，表示有N个团体。\n\n接下来N行，每行两个整数，$Ta_i, Pa_i$，表示中场时的人气值排行，$Ta_i$表示学校名。$Pa_i$表示人气值，按照人气值高往低排列。\n\n接下来N行，每行两个整数，$Tb_i, Pb_i$，表示结束时的人气值排行。\n", "outputFormat": "一个整数表示答案。\n", "hint": "【数据范围】\n\n对于20%的数据， $N\\le16$，时限0.5s。\n\n对于40%的数据， $N\\le50$，时限0.5s。\n\n对于70%的数据， $N\\le5000$，时限1s。\n\n对于全部测试数据， $N\\le200000, A\\le10^9$。最后3个点时限3s。\n", "locale": "zh-CN"}}}
{"pid": "P3697", "type": "P", "difficulty": 5, "samples": [["10 3 5\n10 3 5\n30\n1\n6\n10\n", "8\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "优先队列", "洛谷月赛"], "title": "开心派对小火车", "background": null, "description": "Aqours 铁路公司旗下有 $N$ 个站，编号 $1,2,\\dots,N$。\n\n有各停（各站停车）电车特急电车两种。特急车会在 $S_1,S_2,...,S_M (1=S_1<S_2 <...<S_M=N)$，一共 $M$ 个车站停车。\n\n相邻的两站 (即编号为 $i$ 的车站和编号为 $i+1$ 的车站，而不是特急电车停车的相邻的两站) 之间，各停电车要运行 $A$ 分钟，特急需要 $B$ 分钟。我们认为列车一直匀速运行，不考虑停车和加减速。\n\n现在要加一种快速电车，要求其停站覆盖所有的特急电车的停站，而相邻的两站要运行 $C$ 分钟。为了要快，决定刚好停 $K$ 个站（$K>M$，包括特急的所有车站）。如果一个站可以停多种电车，那么旅客可以在这一站换乘。不过只能向前坐车，不能往回坐。\n\n你需要设计一种快速列车的设站方案，要求旅客在 $T$ 分钟**乘车时间（等车和换乘时间不计）** 内，可以从 $1$ 号站到尽可能多数量的站。你只需要告知能有几站可以达到。", "inputFormat": "第一行 $3$ 个整数，$N$，$M$，$K$，其意义已经在描述中给出。\n\n第二行 $3$ 个整数，$A$，$B$，$C$，其意义也已经在描述中给出。\n\n第三行 $1$ 个整数 $T$，表示乘车时间。\n\n接下来 $M$ 行，每行一个整数。其中第 $i$ 个整数为 $S_i$。", "outputFormat": "一个整数，表示限定时间内能够达到的最多站的数量。", "hint": "【样例解释】\n\n可以设快速列车站为 1/5/6/8/10。\n\n2,3,4 可以直接乘坐各停慢车，5 可以乘坐快速列车，6,10 可以乘坐特急列车，7 可以到 6 转慢车，8 可以到 6 传快速列车。9 没办法在 30 分钟的乘车时间内到达。\n\n【数据范围】\n\n对于 $20\\%$ 的数据，$N \\le 300, K-M=2, A \\le 10^6 , T \\le 10^9$\n\n对于 $50\\%$ 的数据，$N \\le 1000$\n\n对于 $100\\%$ 的数据，$2 \\le N \\le 10^9, 2 \\le M \\le K \\le 3000, 1 \\le B < C < A \\le 10^9, i \\le T \\le 10^{18}$", "locale": "zh-CN", "translations": {"en": {"title": "Happy Party Little Train", "background": "", "description": "Aqours Railway Company has $N$ stations, numbered 1, 2, ..., $N$.\n\nThere are two types of trains: Local (stops at every station) and Express. The express train stops at $S_1, S_2, ..., S_M$ ($1 = S_1 < S_2 < ... < S_M = N$), for a total of $M$ stations.\n\nBetween two adjacent stations (i.e., the station numbered $i$ and the station numbered $i+1$, not two consecutive express stops), the local takes $A$ minutes and the express takes $B$ minutes. We assume trains run at constant speed, ignoring dwell times and acceleration/deceleration.\n\nNow we add a new Rapid train. It must include all express stops among its stops, and it takes $C$ minutes to travel between two adjacent stations. To be faster, it will stop at exactly $K$ stations ($K > M$), including all express stations. If a station is served by multiple train types, passengers can transfer at that station. However, they can only travel forward, not backward.\n\nYou need to design a stopping pattern for the rapid train so that, within $T$ minutes of in-train time (waiting and transfer times are not counted), a passenger starting from station 1 can reach as many stations as possible. You only need to report how many stations can be reached.", "inputFormat": "The first line contains three integers $N$, $M$, $K$, as described above.\n\nThe second line contains three integers $A$, $B$, $C$, as described above.\n\nThe third line contains one integer $T$, the riding time.\n\nThen $M$ lines follow, each containing one integer. The $i$-th integer is $S_i$.", "outputFormat": "Output a single integer, the maximum number of stations that can be reached within the time limit.", "hint": "[Sample explanation]\n\nYou can set the rapid stops to be 1/5/6/8/10.\n\nStations 2, 3, 4 can be reached directly by taking the local. Station 5 can be reached by taking the rapid. Stations 6 and 10 can be reached by taking the express. Station 7 can be reached by transferring at 6 to the local, and station 8 can be reached by transferring at 6 to the rapid. Station 9 cannot be reached within 30 minutes of riding time.\n\nConstraints\n\n- For 20% of the testdata, $N \\le 300$, $K - M = 2$, $A \\le 10^6$, $T \\le 10^9$.\n- For 50% of the testdata, $N \\le 1000$.\n- For 100% of the testdata, $2 \\le N \\le 10^9$, $2 \\le M \\le K \\le 3000$, $1 \\le B < C < A \\le 10^9$, $1 \\le T \\le 10^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "开心派对小火车", "background": null, "description": "Aqours 铁路公司旗下有 $N$ 个站，编号 $1,2,\\dots,N$。\n\n有各停（各站停车）电车特急电车两种。特急车会在 $S_1,S_2,...,S_M (1=S_1<S_2 <...<S_M=N)$，一共 $M$ 个车站停车。\n\n相邻的两站 (即编号为 $i$ 的车站和编号为 $i+1$ 的车站，而不是特急电车停车的相邻的两站) 之间，各停电车要运行 $A$ 分钟，特急需要 $B$ 分钟。我们认为列车一直匀速运行，不考虑停车和加减速。\n\n现在要加一种快速电车，要求其停站覆盖所有的特急电车的停站，而相邻的两站要运行 $C$ 分钟。为了要快，决定刚好停 $K$ 个站（$K>M$，包括特急的所有车站）。如果一个站可以停多种电车，那么旅客可以在这一站换乘。不过只能向前坐车，不能往回坐。\n\n你需要设计一种快速列车的设站方案，要求旅客在 $T$ 分钟**乘车时间（等车和换乘时间不计）** 内，可以从 $1$ 号站到尽可能多数量的站。你只需要告知能有几站可以达到。", "inputFormat": "第一行 $3$ 个整数，$N$，$M$，$K$，其意义已经在描述中给出。\n\n第二行 $3$ 个整数，$A$，$B$，$C$，其意义也已经在描述中给出。\n\n第三行 $1$ 个整数 $T$，表示乘车时间。\n\n接下来 $M$ 行，每行一个整数。其中第 $i$ 个整数为 $S_i$。", "outputFormat": "一个整数，表示限定时间内能够达到的最多站的数量。", "hint": "【样例解释】\n\n可以设快速列车站为 1/5/6/8/10。\n\n2,3,4 可以直接乘坐各停慢车，5 可以乘坐快速列车，6,10 可以乘坐特急列车，7 可以到 6 转慢车，8 可以到 6 传快速列车。9 没办法在 30 分钟的乘车时间内到达。\n\n【数据范围】\n\n对于 $20\\%$ 的数据，$N \\le 300, K-M=2, A \\le 10^6 , T \\le 10^9$\n\n对于 $50\\%$ 的数据，$N \\le 1000$\n\n对于 $100\\%$ 的数据，$2 \\le N \\le 10^9, 2 \\le M \\le K \\le 3000, 1 \\le B < C < A \\le 10^9, i \\le T \\le 10^{18}$", "locale": "zh-CN"}}}
{"pid": "P3698", "type": "P", "difficulty": 4, "samples": [["5 2\n1 0\n2 1\n3 2\n4 3", "3"], ["9 5\n0 1\n0 2\n2 6\n4 2\n8 1\n1 3\n3 7\n3 5", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2017", "重庆", "各省省选", "枚举", "背包 DP", "连通块"], "title": "[CQOI2017] 小Q的棋盘", "background": null, "description": "小 Q 正在设计一种棋类游戏。\n\n在小 Q 设计的游戏中，棋子可以放在棋盘上的格点中。某些格点之间有连线，棋子只能在有连线的格点之间移动。整个棋盘上共有 $V$ 个格点，编号为 $0,1,2,\\cdots, V- 1$，它们是连通的，也就是说棋子从任意格点出发，总能到达所有的格点。小 Q 在设计棋盘时，还保证棋子从一个格点移动到另外任一格点的路径是唯一的。\n\n小 Q 现在想知道，当棋子从格点 $0$ 出发，移动 $N$ 步最多能经过多少格点。格点可以重复经过多次，但不重复计数。", "inputFormat": "第一行包含 $2$ 个正整数 $V, N$，其中 $V$ 表示格点总数，$N$ 表示移动步数。\n\n接下来 $V-1$ 行，每行两个数 $a_i,b_i$，表示编号为 $a_i,b_i$ 的两个格点之间有连线。", "outputFormat": "输出一行一个整数，表示最多经过的格点数量。", "hint": "【输入输出样例 1 说明】\n\n从格点 $0$ 出发移动 $2$ 步。经过 $0, 1, 2$ 这 $3$ 个格点。\n\n【输入输出样例 2 说明】\n\n一种可行的移动路径为 $0 \\to 1 \\to 3 \\to 5 \\to 3 \\to 7$，经过 $0, 1, 3, 5, 7$ 这 $5$ 个格点。\n\n【数据规模与约定】\n\n对于 $100\\%$ 的测试点，$1\\le N,V \\le 100$，$0 \\le a_i,b_i< V$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2017] Xiao Q's Chessboard", "background": "", "description": "Xiao Q is designing a board game.\n\nIn the game he designed, pieces can be placed on the grid points on the board. Some pairs of grid points are connected by lines, and a piece may move only between grid points that are connected by a line. There are $V$ grid points in total, labeled $0, 1, 2, \\cdots, V - 1$, and they are connected; that is, starting from any grid point, the piece can reach all grid points. Xiao Q also guarantees that the path between any two grid points is unique.\n\nXiao Q now wants to know: starting from grid point $0$, after moving $N$ steps, what is the maximum number of grid points that can be visited? A grid point may be visited multiple times, but is counted only once.", "inputFormat": "The first line contains $2$ positive integers $V, N$, where $V$ is the total number of grid points and $N$ is the number of moves.\n\nEach of the next $V - 1$ lines contains two integers $a_i, b_i$, indicating that there is a line connecting grid points $a_i$ and $b_i$.", "outputFormat": "Output a single integer, the maximum number of grid points that can be visited.", "hint": "[Explanation for Sample 1]\n\nFrom grid point $0$, move $2$ steps. The piece visits $0, 1, 2$, i.e., $3$ grid points.\n\n[Explanation for Sample 2]\n\nOne feasible path is $0 \\to 1 \\to 3 \\to 5 \\to 3 \\to 7$, visiting $0, 1, 3, 5, 7$, i.e., $5$ grid points.\n\nConstraints\n\nFor $100\\%$ of the testdata, $1 \\le N, V \\le 100$, and $0 \\le a_i, b_i < V$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2017] 小Q的棋盘", "background": null, "description": "小 Q 正在设计一种棋类游戏。\n\n在小 Q 设计的游戏中，棋子可以放在棋盘上的格点中。某些格点之间有连线，棋子只能在有连线的格点之间移动。整个棋盘上共有 $V$ 个格点，编号为 $0,1,2,\\cdots, V- 1$，它们是连通的，也就是说棋子从任意格点出发，总能到达所有的格点。小 Q 在设计棋盘时，还保证棋子从一个格点移动到另外任一格点的路径是唯一的。\n\n小 Q 现在想知道，当棋子从格点 $0$ 出发，移动 $N$ 步最多能经过多少格点。格点可以重复经过多次，但不重复计数。", "inputFormat": "第一行包含 $2$ 个正整数 $V, N$，其中 $V$ 表示格点总数，$N$ 表示移动步数。\n\n接下来 $V-1$ 行，每行两个数 $a_i,b_i$，表示编号为 $a_i,b_i$ 的两个格点之间有连线。", "outputFormat": "输出一行一个整数，表示最多经过的格点数量。", "hint": "【输入输出样例 1 说明】\n\n从格点 $0$ 出发移动 $2$ 步。经过 $0, 1, 2$ 这 $3$ 个格点。\n\n【输入输出样例 2 说明】\n\n一种可行的移动路径为 $0 \\to 1 \\to 3 \\to 5 \\to 3 \\to 7$，经过 $0, 1, 3, 5, 7$ 这 $5$ 个格点。\n\n【数据规模与约定】\n\n对于 $100\\%$ 的测试点，$1\\le N,V \\le 100$，$0 \\le a_i,b_i< V$。", "locale": "zh-CN"}}}
{"pid": "P3699", "type": "P", "difficulty": 7, "samples": [["3 0\n0 0\n2 0\n2 2", "3"], ["3 1\n0 0\n2 0\n2 2\n1 0 1 1 2 1", "0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "重庆", "各省省选"], "title": "[CQOI2017] 小Q的草稿", "background": null, "description": "Q 是个程序员。\n\n众所周知，程序员在写程序的时候经常需要草稿纸。小 Q 现在需要一张草稿纸用来画图，但是桌上只有一张草稿纸，而且是一张被用过很多次的草稿纸。\n\n草稿纸可以看作一个二维平面，小 Q 甚至已经给它建立了直角坐标系。以前每一次草稿使用过的区域，都可以近似的看作一个平面上的一个三角形，这个三角形区域的内部和边界都不能再使用。当然了，以前的草稿也没有出现区域重叠的情况。\n\n小 Q 已经在草稿纸上画上了一些关键点，这些关键点都在没使用过的区域。小 Q 想把这些关键点两两之间尽可能的用线段连接起来。连接两个关键点的线段有可能会穿过已经用过的草稿区域，这样显然不允许。于是小 Q 就想知道，有多少对关键点可以被线段连接起来，而且还不会穿过已经用过的区域。为了方便，小 Q 保证任意三个关键点不会共线。", "inputFormat": "第一行包含两个整数 $V, T$，表示草稿纸上的关键点数量和三角形区域数量。\n\n接下来 $V$ 行，每行两个整数 $x, y$，表示一个关键点的坐标 $(x,y)$。\n\n接下来 $T$ 行，每行六个整数 $x_1,y_1,x_2,y_2,x_3,y_3$，表示一个三角形区域的三个顶点坐标分别是 $(x_1,y_1),(x_2,y_2),(x_3,y_3)$，保证三角形的面积大于 $0$。", "outputFormat": "输出一行，一个整数，表示能够被线段连接起来的关键点有多少对。", "hint": "【输入输出样例 1 说明】\n\n整个草稿纸是全新的，任意两个关键点都可以连线。\n\n【输入输出样例 2 说明】\n\n如图所示，任意两个关键点的连线都被挡住了。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5011.png) \n\n【数据规模与约定】\n\n对于 $100\\%$ 的测试点，$0 \\le x,y,x_1,y_1,x_2,y_2,x_3,y_3 \\le 10^8$，且都是整数。\n\n|测试点编号|$V\\le$|$T\\le$|\n|:-:|:-:|:-:|\n|$1$|$10$|$10$|\n|$2$|$20$|$20$|\n|$3$|$50$|$50$|\n|$4$|$100$|$100$|\n|$5$|$200$|$200$|\n|$6$|$400$|$400$|\n|$7$|$600$|$600$|\n|$8\\sim10$|$1000$|$1000$|", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2017] Xiao Q's Scratch Paper", "background": "", "description": "Q is a programmer.\n\nAs we all know, programmers often need scratch paper when writing programs. Xiao Q now needs a sheet of scratch paper to draw a figure, but there is only one sheet on the desk, and it has already been used many times.\n\nWe can regard the scratch paper as a 2D plane, and Xiao Q has even set up a Cartesian coordinate system on it. Each previously used region can be approximated as a triangle on the plane. The interior and boundary of such a triangular region cannot be used again. Also, previously used regions do not overlap.\n\nXiao Q has already marked several key points on the scratch paper, all lying in unused regions. He wants to connect as many pairs of these key points as possible with straight segments. A segment connecting two key points may pass through an already used triangular region, which is not allowed. Therefore, Xiao Q wants to know how many pairs of key points can be connected by a straight segment without intersecting the interior or boundary of any used triangular region. For convenience, it is guaranteed that no three key points are collinear.", "inputFormat": "The first line contains two integers V, T, denoting the number of key points and the number of triangular regions on the scratch paper.\n\nThe next V lines each contain two integers x, y, representing the coordinates of a key point $(x, y)$.\n\nThen T lines follow. Each line contains six integers $x_1, y_1, x_2, y_2, x_3, y_3$, indicating that the three vertices of a triangular region are $(x_1, y_1)$, $(x_2, y_2)$, $(x_3, y_3)$, and the area of the triangle is greater than $0$.", "outputFormat": "Output one line with a single integer, the number of pairs of key points that can be connected by a straight segment without intersecting any used triangular region.", "hint": "[Explanation for Sample 1]\n\nThe entire scratch paper is unused, so any two key points can be connected.\n\n[Explanation for Sample 2]\n\nAs shown in the figure, the segment between any two key points is blocked.\n\n![](https://cdn.luogu.com.cn/upload/pic/5011.png)\n\nConstraints\n\nFor 100% of the test points, all coordinates are integers and satisfy $0 \\le  \\text{coordinate} \\le 10^8$.\n\n```cpp\nNO 1  2  3   4   5   6   7    8    9   10\nV 10 20 50 100 200 400 600 1000 1000 1000\nT 10 20 50 100 200 400 600 1000 1000 1000\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2017] 小Q的草稿", "background": null, "description": "Q 是个程序员。\n\n众所周知，程序员在写程序的时候经常需要草稿纸。小 Q 现在需要一张草稿纸用来画图，但是桌上只有一张草稿纸，而且是一张被用过很多次的草稿纸。\n\n草稿纸可以看作一个二维平面，小 Q 甚至已经给它建立了直角坐标系。以前每一次草稿使用过的区域，都可以近似的看作一个平面上的一个三角形，这个三角形区域的内部和边界都不能再使用。当然了，以前的草稿也没有出现区域重叠的情况。\n\n小 Q 已经在草稿纸上画上了一些关键点，这些关键点都在没使用过的区域。小 Q 想把这些关键点两两之间尽可能的用线段连接起来。连接两个关键点的线段有可能会穿过已经用过的草稿区域，这样显然不允许。于是小 Q 就想知道，有多少对关键点可以被线段连接起来，而且还不会穿过已经用过的区域。为了方便，小 Q 保证任意三个关键点不会共线。", "inputFormat": "第一行包含两个整数 $V, T$，表示草稿纸上的关键点数量和三角形区域数量。\n\n接下来 $V$ 行，每行两个整数 $x, y$，表示一个关键点的坐标 $(x,y)$。\n\n接下来 $T$ 行，每行六个整数 $x_1,y_1,x_2,y_2,x_3,y_3$，表示一个三角形区域的三个顶点坐标分别是 $(x_1,y_1),(x_2,y_2),(x_3,y_3)$，保证三角形的面积大于 $0$。", "outputFormat": "输出一行，一个整数，表示能够被线段连接起来的关键点有多少对。", "hint": "【输入输出样例 1 说明】\n\n整个草稿纸是全新的，任意两个关键点都可以连线。\n\n【输入输出样例 2 说明】\n\n如图所示，任意两个关键点的连线都被挡住了。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5011.png) \n\n【数据规模与约定】\n\n对于 $100\\%$ 的测试点，$0 \\le x,y,x_1,y_1,x_2,y_2,x_3,y_3 \\le 10^8$，且都是整数。\n\n|测试点编号|$V\\le$|$T\\le$|\n|:-:|:-:|:-:|\n|$1$|$10$|$10$|\n|$2$|$20$|$20$|\n|$3$|$50$|$50$|\n|$4$|$100$|$100$|\n|$5$|$200$|$200$|\n|$6$|$400$|$400$|\n|$7$|$600$|$600$|\n|$8\\sim10$|$1000$|$1000$|", "locale": "zh-CN"}}}
{"pid": "P3700", "type": "P", "difficulty": 7, "samples": [["3 3\n1 1 1 2\n2 2 4 3\n1 2 4 2\n", "9\n36\n14\n"], ["4 125\n1 2 4 8\n1 3 9 27\n1 4 16 64\n1 5 25 125\n", "2073\n316642\n12157159\n213336861\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "重庆", "各省省选", "数论", "最大公约数 gcd", "莫比乌斯反演", "分块"], "title": "[CQOI2017] 小 Q 的表格", "background": "", "description": "小 Q 是个程序员。\n\n作为一个年轻的程序员，小 Q 总是被老 C 欺负，老 C 经常把一些麻烦的任务交给小 Q 来处理。每当小 Q 不知道如何解决时，就只好向你求助。\n\n为了完成任务，小 Q 需要列一个表格，表格有无穷多行，无穷多列，行和列都从 $1$ 开始标号。为了完成任务，表格里面每个格子都填了一个整数，为了方便描述，小 Q 把第 $a$ 行第 $b$ 列的整数记为 $f(a, b)$。为了完成任务，这个表格要满足一些条件：\n\n1. 对任意的正整数 $a, b$，都要满足 $f(a, b) = f(b, a)$；\n2. 对任意的正整数 $a, b$，都要满足 $b \\times f(a, a + b) = (a + b) \\times f(a, b)$。\n\n为了完成任务，一开始表格里面的数很有规律，第 $a$ 行第 $b$ 列的数恰好等于 $a \\times b$，显然一开始是满足上述两个条件的。为了完成任务，小 Q 需要不断的修改表格里面的数，每当修改了一个格子的数之后，为了让表格继续满足上述两个条件，小 Q 还需要把这次修改能够波及到的全部格子里都改为恰当的数。由于某种神奇的力量驱使，已经确保了每一轮修改之后所有格子里的数仍然都是整数。为了完成任务，小 Q 还需要随时获取前 $k$ 行前 $k$ 列这个有限区域内所有数的和是多少，答案可能比较大，只需要算出答案 ${} \\bmod 1,000,000,007$ 之后的结果。", "inputFormat": "输入文件第一行包含两个整数 $m, n$，表示共有 $m$ 次操作，所有操作和查询涉及到的行编号和列编号都不超过 $n$。\n\n接下来 $m$ 行，每行四个整数 $a, b, x, k$，表示把第 $a$ 行 $b$ 列的数改成 $x$，然后把它能够波及到的所有格子全部修改，保证修改之后所有格子的数仍然都是整数，修改完成后计算前 $k$ 行前 $k$ 列里所有数的和。", "outputFormat": "输出共 $m$ 行，每次操作之后输出一行，表示答案 ${} \\bmod 1,000,000,007$ 之后的结果。", "hint": "**【样例解释 #1】**\n\n一开始，表格的前 $3$ 行前 $3$ 列如图中左边所示。前 $2$ 次操作后表格没有变化，第 $3$ 次操作之后的表格如右边所示。\n\n```cpp\n1 2 3     2  4  6\n2 4 6     4  4 12\n3 6 9     6 12  9\n```\n\n**【数据范围】**\n\n对于 $100 \\%$ 的测试点，$1 \\le m \\le {10}^4$，$1 \\le a, b, k \\le n \\le 4 \\times {10}^6$，$0 \\le x \\le {10}^{18}$。\n\n![](https://cdn.luogu.com.cn/upload/pic/5012.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2017] Xiao Q's Table", "background": "", "description": "Xiao Q is a programmer.\n\nAs a young programmer, Xiao Q is always bullied by old C, who often assigns him troublesome tasks. Whenever Xiao Q does not know how to solve them, he has to ask you for help.\n\nTo complete the task, Xiao Q needs to make a table with infinitely many rows and infinitely many columns, both indexed starting from $1$. Every cell in the table contains an integer. For convenience, Xiao Q denotes the integer in row $a$, column $b$ as $f(a, b)$. The table must satisfy the following conditions:\n\n1. For any positive integers $a, b$, it must hold that $f(a, b) = f(b, a)$.\n2. For any positive integers $a, b$, it must hold that $b \\times f(a, a + b) = (a + b) \\times f(a, b)$.\n\nInitially, the numbers in the table are very regular: the number in row $a$, column $b$ is exactly $a \\times b$, which obviously satisfies the two conditions above. To complete the task, Xiao Q will keep modifying the numbers in the table. Each time a cell is changed, in order to keep the table satisfying the two conditions, Xiao Q must also update all cells that can be affected by this modification to appropriate values. By some mysterious power, it is guaranteed that after each round of modification all entries remain integers. Xiao Q also needs to query, at any time, the sum of all numbers in the finite region of the first $k$ rows and first $k$ columns; since the answer may be large, it suffices to output the result ${} \\bmod 1,000,000,007$.", "inputFormat": "The first line contains two integers $m, n$, indicating that there are $m$ operations, and that all row and column indices mentioned in the operations and queries do not exceed $n$.\n\nThen follow $m$ lines, each containing four integers $a, b, x, k$, meaning: set the number in row $a$, column $b$ to $x$, then update all cells that can be affected by this change, with the guarantee that after the modification all entries are still integers. After the modification is completed, compute the sum of all numbers in the first $k$ rows and first $k$ columns.", "outputFormat": "Output $m$ lines. After each operation, output one line containing the answer modulo $1,000,000,007$.", "hint": "**Sample Explanation #1**\n\nInitially, the top-left $3 \\times 3$ submatrix is as shown on the left. There is no change after the first $2$ operations. After the $3$rd operation, the table becomes as shown on the right.\n\n```cpp\n1 2 3     2  4  6\n2 4 6     4  4 12\n3 6 9     6 12  9\n```\n\n**Constraints**\n\nFor $100\\%$ of the testdata, $1 \\le m \\le 10^4$, $1 \\le a, b, k \\le n \\le 4 \\times 10^6$, $0 \\le x \\le 10^{18}$.\n\n![](https://cdn.luogu.com.cn/upload/pic/5012.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2017] 小 Q 的表格", "background": "", "description": "小 Q 是个程序员。\n\n作为一个年轻的程序员，小 Q 总是被老 C 欺负，老 C 经常把一些麻烦的任务交给小 Q 来处理。每当小 Q 不知道如何解决时，就只好向你求助。\n\n为了完成任务，小 Q 需要列一个表格，表格有无穷多行，无穷多列，行和列都从 $1$ 开始标号。为了完成任务，表格里面每个格子都填了一个整数，为了方便描述，小 Q 把第 $a$ 行第 $b$ 列的整数记为 $f(a, b)$。为了完成任务，这个表格要满足一些条件：\n\n1. 对任意的正整数 $a, b$，都要满足 $f(a, b) = f(b, a)$；\n2. 对任意的正整数 $a, b$，都要满足 $b \\times f(a, a + b) = (a + b) \\times f(a, b)$。\n\n为了完成任务，一开始表格里面的数很有规律，第 $a$ 行第 $b$ 列的数恰好等于 $a \\times b$，显然一开始是满足上述两个条件的。为了完成任务，小 Q 需要不断的修改表格里面的数，每当修改了一个格子的数之后，为了让表格继续满足上述两个条件，小 Q 还需要把这次修改能够波及到的全部格子里都改为恰当的数。由于某种神奇的力量驱使，已经确保了每一轮修改之后所有格子里的数仍然都是整数。为了完成任务，小 Q 还需要随时获取前 $k$ 行前 $k$ 列这个有限区域内所有数的和是多少，答案可能比较大，只需要算出答案 ${} \\bmod 1,000,000,007$ 之后的结果。", "inputFormat": "输入文件第一行包含两个整数 $m, n$，表示共有 $m$ 次操作，所有操作和查询涉及到的行编号和列编号都不超过 $n$。\n\n接下来 $m$ 行，每行四个整数 $a, b, x, k$，表示把第 $a$ 行 $b$ 列的数改成 $x$，然后把它能够波及到的所有格子全部修改，保证修改之后所有格子的数仍然都是整数，修改完成后计算前 $k$ 行前 $k$ 列里所有数的和。", "outputFormat": "输出共 $m$ 行，每次操作之后输出一行，表示答案 ${} \\bmod 1,000,000,007$ 之后的结果。", "hint": "**【样例解释 #1】**\n\n一开始，表格的前 $3$ 行前 $3$ 列如图中左边所示。前 $2$ 次操作后表格没有变化，第 $3$ 次操作之后的表格如右边所示。\n\n```cpp\n1 2 3     2  4  6\n2 4 6     4  4 12\n3 6 9     6 12  9\n```\n\n**【数据范围】**\n\n对于 $100 \\%$ 的测试点，$1 \\le m \\le {10}^4$，$1 \\le a, b, k \\le n \\le 4 \\times {10}^6$，$0 \\le x \\le {10}^{18}$。\n\n![](https://cdn.luogu.com.cn/upload/pic/5012.png)\n", "locale": "zh-CN"}}}
{"pid": "P3701", "type": "P", "difficulty": 5, "samples": [["3 3\nJ W YYY\nJ HK E\n2 2 2\n2 2 2\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["网络流", "洛谷原创", "图论建模"], "title": "主主树", "background": "byx 和诗乃酱都非常都非常喜欢种树。有一天，他们得到了两颗奇怪的树种，于是各自取了一颗回家种树，并约定几年后比一比谁种出来的树更加牛 X。", "description": "很快，这棵树就开花结果了。byx 和诗乃酱惊讶的发现，这是一棵主主树，树上长满了主主和主主的朋友们。这棵树上一共有五种人，主主（$\\verb!J!$），记记（$\\verb!HK!$），高高（$\\verb!W!$），王王（$\\verb!E!$）和歪歪（$\\verb!YYY!$）。他们发现，他们的主主树上的人数相同，都为 $N$。\n\n ![](https://cdn.luogu.com.cn/upload/image_hosting/0vklm8ow.png) \n\n研究发现，这五种人的输赢如上图所示（一样的人不能 PK），箭头指向输的人。至于为什么，留给同学们自己思考。\n\n比赛如期进行。\n\nbyx 和诗乃酱要进行 $M$ 场比赛，每一场比赛他们会选出树上的两个人来比较看谁更牛 X。\n\n第 $i$ 个人寿命为 $\\text{Life}_i$ 秒，每次比完赛比赛的二人就会 $-1$s。当他们生命为 $0$s 时他们就不能再比赛了。\n\n同时，当 $\\verb!J!$ 的寿命为 $0$ 时，同一棵树上的 $\\verb!YYY!$ 可以为他 $+1$s。每个 $\\verb!YYY!$ 只能给每个 $\\verb!J!$ 续一次。\n\n那么问题来了：\n\n现在给定 $N,M(1\\le N\\le 100,1\\le M\\le 1000)$，诗乃酱和 byx 每一个人所属种类（$\\verb!J!,\\verb!HK!,\\verb!W!,\\verb!YYY!$ 或 $\\verb!E!$）以及每一个人的生命，生命不超过 $50$。请你算算 byx 最多能够赢得多少场比赛呢。\n\n数据保证每一场一定都有人用。两个人之间只能比一场。", "inputFormat": "第一行包含两个数 $N,M$，含义看上面。  \n\n第二行 $N$ 个字串（$\\verb!J!,\\verb!HK!,\\verb!W!,\\verb!YYY!$ 或 $\\verb!E!$），表示 byx 的人所属种类，用空格隔开。  \n\n第三行 $N$ 个字串（$\\verb!J!,\\verb!HK!,\\verb!W!,\\verb!YYY!$ 或 $\\verb!E!$），表示诗乃酱的人所属种类，用空格隔开。  \n\n第四行 $N$ 个数，表示 byx 的人的生命。  \n\n第五行 $N$ 个数，表示诗乃酱的人的生命。", "outputFormat": "一个数，byx 能赢的场次。", "hint": "第一场主主赢记记，第二场高高赢王王，第三场歪歪赢记记。", "locale": "zh-CN", "translations": {"en": {"title": "Zhuzhu Tree", "background": "byx and Shino-chan both love planting trees. One day, they got two strange seeds, each took one home to grow a tree, and agreed to compare in a few years to see whose tree is cooler.", "description": "Soon, the trees blossomed and bore fruit. byx and Shino-chan were surprised to find that theirs were Zhuzhu Trees, full of Zhuzhu and Zhuzhu’s friends. There are five kinds of people on the tree: Zhuzhu ($\\verb!J!$), Jiji ($\\verb!HK!$), Gaogao ($\\verb!W!$), Wangwang ($\\verb!E!$), and Waiwai ($\\verb!YYY!$). They found that the numbers of people on their Zhuzhu Trees are the same, both equal to $N$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0vklm8ow.png)\n\nResearch shows that the win–lose relationships among the five kinds are as in the figure above (two people of the same kind cannot “PK”). Arrows point to the loser. As for why, think about it yourself.\n\nThe contest begins as scheduled.\n\nbyx and Shino-chan will play $M$ matches. In each match, they will each choose one person from their own tree to see who is stronger.\n\nThe $i$-th person has a lifetime of $\\text{Life}_i$ seconds. After each match, both participants lose $-1\\text{s}$. When someone’s lifetime reaches $0\\text{s}$, they can no longer play.\n\nAlso, when a $\\verb!J!$’s lifetime is $0$, any $\\verb!YYY!$ on the same tree can add $+1\\text{s}$ to that $\\verb!J!$. Each $\\verb!YYY!$ can extend each $\\verb!J!$ at most once.\n\nThe problem:\n\nGiven $N, M (1\\le N\\le 100, 1\\le M\\le 1000)$, the kind of each person for Shino-chan and byx (one of $\\verb!J!, \\verb!HK!, \\verb!W!, \\verb!YYY!, \\verb!E!$), and each person’s lifetime (not exceeding $50$), compute the maximum number of matches that byx can win.\n\nThe testdata guarantees that there will be available participants for every match. Any pair of two specific people can play at most one match.", "inputFormat": "The first line contains two integers $N, M$, as described above.  \nThe second line contains $N$ strings ($\\verb!J!, \\verb!HK!, \\verb!W!, \\verb!YYY!$ or $\\verb!E!$), the kinds of byx’s people, separated by spaces.  \nThe third line contains $N$ strings ($\\verb!J!, \\verb!HK!, \\verb!W!, \\verb!YYY!$ or $\\verb!E!$), the kinds of Shino-chan’s people, separated by spaces.  \nThe fourth line contains $N$ integers, the lifetimes of byx’s people.  \nThe fifth line contains $N$ integers, the lifetimes of Shino-chan’s people.", "outputFormat": "Output a single integer: the number of matches byx can win.", "hint": "In the first match, $\\verb!J!$ beats $\\verb!HK!$. In the second match, $\\verb!W!$ beats $\\verb!E!$. In the third match, $\\verb!YYY!$ beats $\\verb!HK!$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "主主树", "background": "byx 和诗乃酱都非常都非常喜欢种树。有一天，他们得到了两颗奇怪的树种，于是各自取了一颗回家种树，并约定几年后比一比谁种出来的树更加牛 X。", "description": "很快，这棵树就开花结果了。byx 和诗乃酱惊讶的发现，这是一棵主主树，树上长满了主主和主主的朋友们。这棵树上一共有五种人，主主（$\\verb!J!$），记记（$\\verb!HK!$），高高（$\\verb!W!$），王王（$\\verb!E!$）和歪歪（$\\verb!YYY!$）。他们发现，他们的主主树上的人数相同，都为 $N$。\n\n ![](https://cdn.luogu.com.cn/upload/image_hosting/0vklm8ow.png) \n\n研究发现，这五种人的输赢如上图所示（一样的人不能 PK），箭头指向输的人。至于为什么，留给同学们自己思考。\n\n比赛如期进行。\n\nbyx 和诗乃酱要进行 $M$ 场比赛，每一场比赛他们会选出树上的两个人来比较看谁更牛 X。\n\n第 $i$ 个人寿命为 $\\text{Life}_i$ 秒，每次比完赛比赛的二人就会 $-1$s。当他们生命为 $0$s 时他们就不能再比赛了。\n\n同时，当 $\\verb!J!$ 的寿命为 $0$ 时，同一棵树上的 $\\verb!YYY!$ 可以为他 $+1$s。每个 $\\verb!YYY!$ 只能给每个 $\\verb!J!$ 续一次。\n\n那么问题来了：\n\n现在给定 $N,M(1\\le N\\le 100,1\\le M\\le 1000)$，诗乃酱和 byx 每一个人所属种类（$\\verb!J!,\\verb!HK!,\\verb!W!,\\verb!YYY!$ 或 $\\verb!E!$）以及每一个人的生命，生命不超过 $50$。请你算算 byx 最多能够赢得多少场比赛呢。\n\n数据保证每一场一定都有人用。两个人之间只能比一场。", "inputFormat": "第一行包含两个数 $N,M$，含义看上面。  \n\n第二行 $N$ 个字串（$\\verb!J!,\\verb!HK!,\\verb!W!,\\verb!YYY!$ 或 $\\verb!E!$），表示 byx 的人所属种类，用空格隔开。  \n\n第三行 $N$ 个字串（$\\verb!J!,\\verb!HK!,\\verb!W!,\\verb!YYY!$ 或 $\\verb!E!$），表示诗乃酱的人所属种类，用空格隔开。  \n\n第四行 $N$ 个数，表示 byx 的人的生命。  \n\n第五行 $N$ 个数，表示诗乃酱的人的生命。", "outputFormat": "一个数，byx 能赢的场次。", "hint": "第一场主主赢记记，第二场高高赢王王，第三场歪歪赢记记。", "locale": "zh-CN"}}}
{"pid": "P3702", "type": "P", "difficulty": 5, "samples": [["3 5 3", "33"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2017", "各省省选", "山东", "素数判断,质数,筛法", "容斥原理", "矩阵乘法", "快速傅里叶变换 FFT"], "title": "[SDOI2017] 序列计数", "background": "", "description": "Alice 想要得到一个长度为 $n$ 的序列，序列中的数都是不超过 $m$ 的正整数，而且这 $n$ 个数的和是 $p$ 的倍数。\n\nAlice 还希望，这 $n$ 个数中，至少有一个数是质数。\n\nAlice 想知道，有多少个序列满足她的要求。", "inputFormat": "一行三个数，$n,m,p$。\n", "outputFormat": "一行一个数，满足 Alice 的要求的序列数量，答案对 $20170408$ 取模。", "hint": "对 $20\\%$ 的数据，$1\\leq n,m\\leq100$。\n\n\n对 $50\\%$ 的数据，$1\\leq m \\leq 100$。\n\n\n对 $80\\%$ 的数据，$1\\leq m\\leq 10^6$。\n\n\n对 $100\\%$ 的数据，$1\\leq n \\leq 10^9,1\\leq m \\leq 2\\times 10^7,1\\leq p\\leq 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2017] Sequence Counting", "background": "", "description": "Alice wants to obtain a sequence of length $n$, where all elements are positive integers not exceeding $m$, and the sum of these $n$ numbers is a multiple of $p$.\n\nAlice also wants at least one of these $n$ numbers to be a prime number.\n\nAlice wants to know how many sequences satisfy her requirements.", "inputFormat": "One line with three integers, $n, m, p$.", "outputFormat": "One line with a single number: the number of sequences that satisfy Alice’s requirements, taken modulo $20170408$.", "hint": "For $20\\%$ of the testdata, $1 \\leq n, m \\leq 100$.\n\nFor $50\\%$ of the testdata, $1 \\leq m \\leq 100$.\n\nFor $80\\%$ of the testdata, $1 \\leq m \\leq 10^6$.\n\nFor $100\\%$ of the testdata, $1 \\leq n \\leq 10^9, 1 \\leq m \\leq 2 \\times 10^7, 1 \\leq p \\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2017] 序列计数", "background": "", "description": "Alice 想要得到一个长度为 $n$ 的序列，序列中的数都是不超过 $m$ 的正整数，而且这 $n$ 个数的和是 $p$ 的倍数。\n\nAlice 还希望，这 $n$ 个数中，至少有一个数是质数。\n\nAlice 想知道，有多少个序列满足她的要求。", "inputFormat": "一行三个数，$n,m,p$。\n", "outputFormat": "一行一个数，满足 Alice 的要求的序列数量，答案对 $20170408$ 取模。", "hint": "对 $20\\%$ 的数据，$1\\leq n,m\\leq100$。\n\n\n对 $50\\%$ 的数据，$1\\leq m \\leq 100$。\n\n\n对 $80\\%$ 的数据，$1\\leq m\\leq 10^6$。\n\n\n对 $100\\%$ 的数据，$1\\leq n \\leq 10^9,1\\leq m \\leq 2\\times 10^7,1\\leq p\\leq 100$。", "locale": "zh-CN"}}}
{"pid": "P3703", "type": "P", "difficulty": 6, "samples": [["5 6\n1 2\n2 3\n3 4\n3 5\n2 4 5\n3 3\n1 4\n2 4 5\n1 5\n2 4 5", "3\n4\n2\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "线段树", "各省省选", "山东", "树链剖分", "动态树 LCT"], "title": "[SDOI2017] 树点涂色", "background": "", "description": "Bob 有一棵 $n$ 个点的有根树，其中 $1$ 号点是根节点。Bob 在每个点上涂了颜色，并且每个点上的颜色不同。\n\n定义一条路径的权值是：这条路径上的点（包括起点和终点）共有多少种不同的颜色。\n\nBob可能会进行这几种操作：\n\n- `1 x` 表示把点 $x$ 到根节点的路径上所有的点染上一种没有用过的新颜色。\n\n\n- `2 x y` 求 $x$ 到 $y$ 的路径的权值。\n\n- `3 x` 在以 $x$ 为根的子树中选择一个点，使得这个点到根节点的路径权值最大，求最大权值。\n\n\nBob一共会进行 $m$ 次操作\n", "inputFormat": "第一行两个数 $n,m$。\n\n接下来 $n-1$ 行，每行两个数 $a,b$，表示 $a$ 与 $b$ 之间有一条边。\n\n接下来 $m$ 行，表示操作，格式见题目描述", "outputFormat": "每当出现 $2,3$ 操作，输出一行。\n\n如果是 $2$ 操作，输出一个数表示路径的权值\n\n如果是 $3$ 操作，输出一个数表示权值的最大值\n", "hint": "共 $10$ 个测试点。\n\n测试点 $1$，$1\\leq n,m\\leq1000$；\n\n测试点 $2,3$，没有 $2$ 操作；\n\n测试点 $4,5$，没有 $3$ 操作；\n\n测试点 $6$，树的生成方式是，对于 $i(2\\leq i \\leq n)$，在 $1 \\sim i-1$ 中随机选一个点作为 $i$ 的父节点；\n\n测试点 $7$，$1\\leq n,m\\leq 5\\times 10^4$；\n\n测试点 $8$，$1\\leq n \\leq 5 \\times 10^4$；\n\n测试点9,10，无特殊限制\n\n对所有数据，$1\\leq n \\leq 10^5$，$1\\leq m \\leq 10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2017] Tree Node Coloring", "background": "", "description": "Bob has a rooted tree with $n$ nodes, where node $1$ is the root. Bob painted each node with a color, and all nodes have pairwise distinct colors.\n\nDefine the weight of a path as the number of distinct colors among the nodes on this path (including both endpoints).\n\nBob may perform the following operations:\n\n- `1 x` Recolor all nodes on the path from $x$ to the root with a brand-new color that has never been used before.\n- `2 x y` Query the weight of the path from $x$ to $y$.\n- `3 x` Within the subtree rooted at $x$, choose a node so that the weight of its path to the root is maximized; output that maximum weight.\n\nBob will perform $m$ operations in total.", "inputFormat": "The first line contains two integers $n, m$.\n\nThe next $n-1$ lines each contain two integers $a, b$, indicating an edge between $a$ and $b$.\n\nThe next $m$ lines describe the operations, in the format given in the statement.", "outputFormat": "For each operation of type 2 or 3, output one line.\n\nFor type 2, output one integer: the weight of the path.\n\nFor type 3, output one integer: the maximum weight.", "hint": "There are 10 test points.\n\nTest point 1: $1 \\leq n, m \\leq 1000$.\n\nTest points 2 and 3: no type 2 operations.\n\nTest points 4 and 5: no type 3 operations.\n\nTest point 6: the tree is generated as follows — for $i$ ($2 \\leq i \\leq n$), randomly choose a node from $1$ to $i-1$ as the parent of $i$.\n\nTest point 7: $1 \\leq n, m \\leq 5 \\times 10^4$.\n\nTest point 8: $1 \\leq n \\leq 5 \\times 10^4$.\n\nTest points 9 and 10: no special restrictions.\n\nFor all testdata: $1 \\leq n \\leq 10^5$, $1 \\leq m \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2017] 树点涂色", "background": "", "description": "Bob 有一棵 $n$ 个点的有根树，其中 $1$ 号点是根节点。Bob 在每个点上涂了颜色，并且每个点上的颜色不同。\n\n定义一条路径的权值是：这条路径上的点（包括起点和终点）共有多少种不同的颜色。\n\nBob可能会进行这几种操作：\n\n- `1 x` 表示把点 $x$ 到根节点的路径上所有的点染上一种没有用过的新颜色。\n\n\n- `2 x y` 求 $x$ 到 $y$ 的路径的权值。\n\n- `3 x` 在以 $x$ 为根的子树中选择一个点，使得这个点到根节点的路径权值最大，求最大权值。\n\n\nBob一共会进行 $m$ 次操作\n", "inputFormat": "第一行两个数 $n,m$。\n\n接下来 $n-1$ 行，每行两个数 $a,b$，表示 $a$ 与 $b$ 之间有一条边。\n\n接下来 $m$ 行，表示操作，格式见题目描述", "outputFormat": "每当出现 $2,3$ 操作，输出一行。\n\n如果是 $2$ 操作，输出一个数表示路径的权值\n\n如果是 $3$ 操作，输出一个数表示权值的最大值\n", "hint": "共 $10$ 个测试点。\n\n测试点 $1$，$1\\leq n,m\\leq1000$；\n\n测试点 $2,3$，没有 $2$ 操作；\n\n测试点 $4,5$，没有 $3$ 操作；\n\n测试点 $6$，树的生成方式是，对于 $i(2\\leq i \\leq n)$，在 $1 \\sim i-1$ 中随机选一个点作为 $i$ 的父节点；\n\n测试点 $7$，$1\\leq n,m\\leq 5\\times 10^4$；\n\n测试点 $8$，$1\\leq n \\leq 5 \\times 10^4$；\n\n测试点9,10，无特殊限制\n\n对所有数据，$1\\leq n \\leq 10^5$，$1\\leq m \\leq 10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P3704", "type": "P", "difficulty": 6, "samples": [["3\n2 3\n4 5\n6 7", "1\n6\n960"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "各省省选", "山东", "O2优化", "枚举", "莫比乌斯反演", "分块"], "title": "[SDOI2017] 数字表格", "background": "Doris 刚刚学习了 fibonacci 数列。用 $f_i$ 表示数列的第 $i$ 项，那么\n\n$$f_0=0,f_1=1$$\n\n$$f_n=f_{n-1}+f_{n-2},n\\geq 2$$", "description": "Doris 用老师的超级计算机生成了一个 $n\\times m$ 的表格，\n\n第 $i$ 行第 $j$ 列的格子中的数是 $f_{\\gcd(i,j)}$，其中 $\\gcd(i,j)$ 表示 $i,j$ 的最大公约数。\n\n\nDoris 的表格中共有 $n\\times m$ 个数，她想知道这些数的乘积是多少。\n\n答案对 $10^9+7$ 取模。\n", "inputFormat": "**本题单个测试点内有多组测试数据**。\n\n输入的第一行是一个整数 $T$，表示测试数据的组数。\n\n接下来 $T$ 行，每行两个整数 $n, m$，表示一组数据。", "outputFormat": "对于每组数据，输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n- 对于 $10\\%$ 的数据，保证 $n,m\\leq 10^2$。\n- 对于 $30\\%$ 的数据，保证 $n,m\\leq 10^3$。\n- 另有 $30\\%$ 的数据，保证 $T\\leq 3$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq T\\leq 10^3$，$1\\leq n,m\\leq 10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2017] Number Table", "background": "Doris just learned the Fibonacci sequence. Let $f_i$ denote the $i$-th term of the sequence, then\n\n$$f_0=0,f_1=1$$\n\n$$f_n=f_{n-1}+f_{n-2},n\\geq 2$$", "description": "Doris used her teacher’s supercomputer to generate an $n \\times m$ table.\n\nThe number in the $i$-th row and the $j$-th column is $f_{\\gcd(i,j)}$, where $\\gcd(i,j)$ denotes the greatest common divisor of $i$ and $j$.\n\nThere are $n \\times m$ numbers in total in Doris’s table. She wants to know the product of all these numbers.\n\nOutput the answer modulo $10^9+7$.", "inputFormat": "There are multiple test cases in a single test file.\n\nThe first line contains an integer $T$, the number of test cases.\n\nEach of the next $T$ lines contains two integers $n, m$, describing one test case.", "outputFormat": "For each test case, output one integer on a separate line representing the answer.", "hint": "Constraints:\n- For $10\\%$ of the testdata, $n, m \\leq 10^2$.\n- For $30\\%$ of the testdata, $n, m \\leq 10^3$.\n- For another $30\\%$ of the testdata, $T \\leq 3$.\n- For $100\\%$ of the testdata, $1 \\leq T \\leq 10^3$, $1 \\leq n, m \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2017] 数字表格", "background": "Doris 刚刚学习了 fibonacci 数列。用 $f_i$ 表示数列的第 $i$ 项，那么\n\n$$f_0=0,f_1=1$$\n\n$$f_n=f_{n-1}+f_{n-2},n\\geq 2$$", "description": "Doris 用老师的超级计算机生成了一个 $n\\times m$ 的表格，\n\n第 $i$ 行第 $j$ 列的格子中的数是 $f_{\\gcd(i,j)}$，其中 $\\gcd(i,j)$ 表示 $i,j$ 的最大公约数。\n\n\nDoris 的表格中共有 $n\\times m$ 个数，她想知道这些数的乘积是多少。\n\n答案对 $10^9+7$ 取模。\n", "inputFormat": "**本题单个测试点内有多组测试数据**。\n\n输入的第一行是一个整数 $T$，表示测试数据的组数。\n\n接下来 $T$ 行，每行两个整数 $n, m$，表示一组数据。", "outputFormat": "对于每组数据，输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n- 对于 $10\\%$ 的数据，保证 $n,m\\leq 10^2$。\n- 对于 $30\\%$ 的数据，保证 $n,m\\leq 10^3$。\n- 另有 $30\\%$ 的数据，保证 $T\\leq 3$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq T\\leq 10^3$，$1\\leq n,m\\leq 10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P3705", "type": "P", "difficulty": 6, "samples": [["3\n19 17 16\n25 24 23\n35 36 31\n9 5 6\n3 4 2\n7 8 9", "5.357143"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "二分", "各省省选", "山东", "O2优化", "分数规划", "费用流"], "title": "[SDOI2017] 新生舞会", "background": null, "description": "学校组织了一次新生舞会，Cathy 作为经验丰富的老学姐，负责为同学们安排舞伴。\n\n\n有 $n$ 个男生和 $n$ 个女生参加舞会，一个男生和一个女生一起跳舞，互为舞伴。\n\n\nCathy 收集了这些同学之间的关系，比如两个人之前认识没，计算得出 $a_{i,j}$。\n\nCathy 还需要考虑两个人一起跳舞是否方便，比如身高体重差别会不会太大，计算得出 $b_{i,j}$，表示第 $i$ 个男生和第 $j$ 个女生一起跳舞时的不协调程度。\n\n\n当然，还需要考虑很多其他问题。\n\n\nCathy 想先用一个程序通过 $a_{i,j}$ 和 $b_{i,j}$ 求出一种方案，再手动对方案进行微调。\n\nCathy 找到你，希望你帮她写那个程序。\n\n\n一个方案中有 $n$ 对舞伴，假设每对舞伴的喜悦程度分别是 $a'_1,a'_2,...,a'_n$，假设每对舞伴的不协调程度分别是 $b'_1,b'_2,...,b'_n$。令\n\n$C=\\frac {a'_1+a'_2+...+a'_n}{b'_1+b'_2+...+b'_n}$\n\nCathy 希望 $C$ 值最大。", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行，每行 $n$ 个整数，第 $i$ 行第 $j$ 个数表示 $a_{i,j}$。\n\n接下来 $n$ 行，每行 $n$ 个整数，第 $i$ 行第 $j$ 个数表示 $b_{i,j}$。", "outputFormat": "一行一个数，表示 $C$ 的最大值。四舍五入保留 $6$ 位小数，选手输出的小数需要与标准输出相等。", "hint": "对于 $10\\%$ 的数据，$1 \\le n \\le 5$。\n\n对于 $40\\%$ 的数据，$1 \\le n \\le 18$。\n\n另有 $20\\%$ 的数据，$b_{i,j} = 1$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 100,1 \\le a_{i,j},b_{i,j} \\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2017] Freshmen Welcome Ball", "background": "", "description": "The school is holding a freshmen welcome ball. As an experienced senior, Cathy is responsible for pairing up dance partners.\n\nThere are $n$ boys and $n$ girls at the ball. Each pair consists of one boy and one girl, forming a one-to-one matching.\n\nCathy collected relationship information between these students, such as whether two people knew each other before, and computed $a_{i,j}$.\n\nCathy also needs to consider how convenient it is for two people to dance together, for example whether their height and weight differences are too large, and computed $b_{i,j}$, which represents the incompatibility when the $i$-th boy dances with the $j$-th girl.\n\nOf course, there are many other issues to consider.\n\nCathy wants to first use a program to find a plan based on $a_{i,j}$ and $b_{i,j}$, and then manually fine-tune the result.\n\nA plan consists of $n$ pairs of partners. Suppose the joy levels of the pairs are $a'_1, a'_2, ..., a'_n$, and the incompatibility levels are $b'_1, b'_2, ..., b'_n$. Let\n$C=\\frac {a'_1+a'_2+...+a'_n}{b'_1+b'_2+...+b'_n}$.\nCathy wants to maximize the value of $C$.", "inputFormat": "The first line contains an integer $n$.\n\nThe next $n$ lines each contain $n$ integers. In the $i$-th line, the $j$-th number denotes $a_{i,j}$.\n\nThe next $n$ lines each contain $n$ integers. In the $i$-th line, the $j$-th number denotes $b_{i,j}$.", "outputFormat": "Output a single number, the maximum value of $C$. Round to $6$ decimal places. Your output must exactly match the standard output.", "hint": "Constraints:\n- For $10\\%$ of the testdata, $1 \\le n \\le 5$.\n- For $40\\%$ of the testdata, $1 \\le n \\le 18$.\n- Additionally, for $20\\%$ of the testdata, $b_{i,j} = 1$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 100, 1 \\le a_{i,j}, b_{i,j} \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2017] 新生舞会", "background": null, "description": "学校组织了一次新生舞会，Cathy 作为经验丰富的老学姐，负责为同学们安排舞伴。\n\n\n有 $n$ 个男生和 $n$ 个女生参加舞会，一个男生和一个女生一起跳舞，互为舞伴。\n\n\nCathy 收集了这些同学之间的关系，比如两个人之前认识没，计算得出 $a_{i,j}$。\n\nCathy 还需要考虑两个人一起跳舞是否方便，比如身高体重差别会不会太大，计算得出 $b_{i,j}$，表示第 $i$ 个男生和第 $j$ 个女生一起跳舞时的不协调程度。\n\n\n当然，还需要考虑很多其他问题。\n\n\nCathy 想先用一个程序通过 $a_{i,j}$ 和 $b_{i,j}$ 求出一种方案，再手动对方案进行微调。\n\nCathy 找到你，希望你帮她写那个程序。\n\n\n一个方案中有 $n$ 对舞伴，假设每对舞伴的喜悦程度分别是 $a'_1,a'_2,...,a'_n$，假设每对舞伴的不协调程度分别是 $b'_1,b'_2,...,b'_n$。令\n\n$C=\\frac {a'_1+a'_2+...+a'_n}{b'_1+b'_2+...+b'_n}$\n\nCathy 希望 $C$ 值最大。", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行，每行 $n$ 个整数，第 $i$ 行第 $j$ 个数表示 $a_{i,j}$。\n\n接下来 $n$ 行，每行 $n$ 个整数，第 $i$ 行第 $j$ 个数表示 $b_{i,j}$。", "outputFormat": "一行一个数，表示 $C$ 的最大值。四舍五入保留 $6$ 位小数，选手输出的小数需要与标准输出相等。", "hint": "对于 $10\\%$ 的数据，$1 \\le n \\le 5$。\n\n对于 $40\\%$ 的数据，$1 \\le n \\le 18$。\n\n另有 $20\\%$ 的数据，$b_{i,j} = 1$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 100,1 \\le a_{i,j},b_{i,j} \\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P3706", "type": "P", "difficulty": 7, "samples": [["3 3\nTHT\nTTH\nHTT", "0.3333333333\n0.2500000000\n0.4166666667"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["字符串", "2017", "各省省选", "山东", "Special Judge", "枚举", "构造"], "title": "[SDOI2017] 硬币游戏", "background": "", "description": "周末同学们非常无聊，有人提议，咱们扔硬币玩吧，谁扔的硬币正面次数多谁胜利。\n\n\n大家纷纷觉得这个游戏非常符合同学们的特色，但只是扔硬币实在是太单调了。\n\n\n同学们觉得要加强趣味性，所以要找一个同学扔很多很多次硬币，其他同学记录下正反面情况。\n\n\n用 $\\texttt H$ 表示正面朝上，用 $\\texttt T$ 表示反面朝上，扔很多次硬币后，会得到一个硬币序列。比如 $\\texttt{HTT}$ 表示第一次正面朝上，后两次反面朝上。\n\n\n但扔到什么时候停止呢？大家提议，选出 $n$ 个同学，每个同学猜一个长度为 $m$ 的序列，当某一个同学猜的序列在硬币序列中出现时，就不再扔硬币了，并且这个同学胜利，为了保证只有一个同学胜利，同学们猜的 $n$ 个序列两两不同。\n\n\n很快，$n$ 个同学猜好序列，然后进入了紧张而又刺激的扔硬币环节。你想知道，如果硬币正反面朝上的概率相同，每个同学胜利的概率是多少。\n", "inputFormat": "第一行两个整数 $n,m$。\n\n\n接下里 $n$ 行，每行一个长度为 $m$ 的字符串，表示第 $i$ 个同学猜的序列。\n", "outputFormat": "输出 $n$ 行，第 $i$ 行表示第 $i$ 个同学胜利的概率。选手输出与标准输出的绝对误差不超过 $10^{-6}$ 即视为正确。\n", "hint": "对于 $10\\%$ 的数据，$1\\le n,m\\le 3$。\n\n对于 $40\\%$ 的数据，$1\\le n,m\\le 18$。\n\n另有 $20\\%$ 的数据，$n=2$。\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 300$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2017] Coin Game", "background": "", "description": "On the weekend, the students were very bored. Someone suggested: let’s toss coins; whoever gets more heads wins.\n\nEveryone thought this game suited the students’ style, but simply tossing coins was too monotonous.\n\nTo make it more interesting, they decided that one student would toss the coin many times, while the others would record the sequence of heads and tails.\n\nUse $\\texttt H$ to denote heads and $\\texttt T$ to denote tails. After many tosses, we obtain a coin sequence. For example, $\\texttt{HTT}$ means heads on the first toss and tails on the next two.\n\nWhen should we stop tossing? They proposed that $n$ students each guess a sequence of length $m$. When some student’s guessed sequence appears in the coin sequence, they stop tossing and that student wins. To ensure a unique winner, the $n$ sequences are pairwise distinct.\n\nThe $n$ students quickly made their guesses, and the exciting coin-tossing began. You want to know, assuming the coin is fair (heads and tails are equally likely), what is the probability that each student wins.", "inputFormat": "The first line contains two integers $n, m$.\n\nThe next $n$ lines each contain a string of length $m$, representing the sequence guessed by the $i$-th student.", "outputFormat": "Output $n$ lines. The $i$-th line contains the probability that the $i$-th student wins. Your answer is accepted if the absolute error does not exceed $10^{-6}$.", "hint": "For $10\\%$ of the testdata, $1 \\le n, m \\le 3$.\n\nFor $40\\%$ of the testdata, $1 \\le n, m \\le 18$.\n\nAdditionally, for $20\\%$ of the testdata, $n = 2$.\n\nFor $100\\%$ of the testdata, $1 \\le n, m \\le 300$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2017] 硬币游戏", "background": "", "description": "周末同学们非常无聊，有人提议，咱们扔硬币玩吧，谁扔的硬币正面次数多谁胜利。\n\n\n大家纷纷觉得这个游戏非常符合同学们的特色，但只是扔硬币实在是太单调了。\n\n\n同学们觉得要加强趣味性，所以要找一个同学扔很多很多次硬币，其他同学记录下正反面情况。\n\n\n用 $\\texttt H$ 表示正面朝上，用 $\\texttt T$ 表示反面朝上，扔很多次硬币后，会得到一个硬币序列。比如 $\\texttt{HTT}$ 表示第一次正面朝上，后两次反面朝上。\n\n\n但扔到什么时候停止呢？大家提议，选出 $n$ 个同学，每个同学猜一个长度为 $m$ 的序列，当某一个同学猜的序列在硬币序列中出现时，就不再扔硬币了，并且这个同学胜利，为了保证只有一个同学胜利，同学们猜的 $n$ 个序列两两不同。\n\n\n很快，$n$ 个同学猜好序列，然后进入了紧张而又刺激的扔硬币环节。你想知道，如果硬币正反面朝上的概率相同，每个同学胜利的概率是多少。\n", "inputFormat": "第一行两个整数 $n,m$。\n\n\n接下里 $n$ 行，每行一个长度为 $m$ 的字符串，表示第 $i$ 个同学猜的序列。\n", "outputFormat": "输出 $n$ 行，第 $i$ 行表示第 $i$ 个同学胜利的概率。选手输出与标准输出的绝对误差不超过 $10^{-6}$ 即视为正确。\n", "hint": "对于 $10\\%$ 的数据，$1\\le n,m\\le 3$。\n\n对于 $40\\%$ 的数据，$1\\le n,m\\le 18$。\n\n另有 $20\\%$ 的数据，$n=2$。\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 300$。\n", "locale": "zh-CN"}}}
{"pid": "P3707", "type": "P", "difficulty": 6, "samples": [["3 5\n1 2 3\n1 2 3\n1 1 3\n2 2 3 -3 2\n1 1 2\n3 1 2 2 1\n1 1 3\n", "1.0000000000\n-1.5000000000\n-0.6153846154\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "线段树", "各省省选", "山东", "Special Judge", "前缀和", "分块"], "title": "[SDOI2017] 相关分析", "background": "", "description": "Frank 对天文学非常感兴趣，他经常用望远镜看星星，同时记录下它们的信息，比如亮度、颜色等等，进而估算出星星的距离，半径等等。\n\nFrank 不仅喜欢观测，还喜欢分析观测到的数据。他经常分析两个参数之间（比如亮度和半径）是否存在某种关系。\n\n现在 Frank 要分析参数 $X$ 与 $Y$ 之间的关系。他有 $n$ 组观测数据，第 $i$ 组观测数据记录了 $x_i$ 和 $y_i$。他需要一下几种操作。\n\n###  $\\verb!1 L R!$\n\n用直线拟合第 $L$ 组到第 $R$ 组观测数据。用 $\\overline{x}$ 表示这些观测数据中 $x$ 的平均数，用 $\\overline{y}$ 表示这些观测数据中 $y$ 的平均数，即\n \n$$\\begin{aligned}\\overline{x}&={1 \\over R-L+1} \\sum _{i=L} ^R x_i \\\\\\overline{y}&={1 \\over R-L+1} \\sum _{i=L} ^R y_i\\end{aligned}$$\n\n如果直线方程是 $y=ax+b$，那么 $a$ 应当这样计算：\n\n$$a={\\displaystyle\\sum_{i=L} ^R (x_i-\\overline{x})(y_i-\\overline{y}) \\over \\displaystyle\\sum _{i=L} ^R (x_i -\\overline{x})^2}$$\n\n \n你需要帮助 Frank 计算 $a$。\n\n \n###  $\\verb!2 L R S T!$\n\nFrank 发现测量数据第 $L$ 组到第 $R$ 组数据有误差，对每个 $i$ 满足 $L \\leq i \\leq R$，$x_i$ 需要加上 $S$，$y_i$ 需要加上 $T$。\n \n###  $\\verb!3 L R S T!$\n\nFrank 发现第 $L$ 组到第 $R$ 组数据需要修改，对于每个 $i$ 满足 $L \\leq i \\leq R$，$x_i$ 需要修改为 $(S+i)$，$y_i$ 需要修改为 $(T+i)$。\n", "inputFormat": "第一行两个数 $n,m$，表示观测数据组数和操作次数。\n\n接下来一行 $n$ 个数，第 $i$ 个数是 $x_i$。\n\n接下来一行 $n$ 个数，第 $i$ 个数是 $y_i$。\n\n接下来 $m$ 行，表示操作，格式见题目描述。\n", "outputFormat": "对于每个 $1$ 操作，输出一行，表示直线斜率 $a$。选手输出与标准输出的绝对误差或相对误差不超过 $10^{-5}$ 即为正确。\n", "hint": "### 数据范围及约定\n\n- 对于 $20\\%$ 的数据 $1 \\leq n,m \\leq 1000$；\n- 另有 $20\\%$ 的数据，没有 $3$ 操作，且 $2$ 操作中 $S=0$；\n- 另有 $30\\%$ 的数据，没有 $3$ 操作。\n\n对于 $100\\%$ 的数据，$1 \\leq n,m \\leq 10^5$，$0 \\leq |S|,|T| \\leq 10^5$，$0 \\leq |x_i|,|y_i| \\leq 10^5$。\n\n保证 $1$ 操作不会出现分母为 $0$ 的情况。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2017] Correlation Analysis", "background": "", "description": "Frank is very interested in astronomy. He often observes stars with a telescope and records their information, such as brightness and color, and then estimates properties like distance and radius.\n\nFrank not only enjoys observing but also analyzing the data he collects. He often checks whether there is some relationship between two parameters (for example, brightness and radius).\n\nNow Frank wants to analyze the relationship between parameters $X$ and $Y$. He has $n$ groups of observations. The $i$-th group records $x_i$ and $y_i$. He needs to perform the following types of operations.\n\n###  $\\verb!1 L R!$\n\nFit a line to the observations from group $L$ to group $R$. Let $\\overline{x}$ denote the mean of $x$ among these observations, and let $\\overline{y}$ denote the mean of $y$, that is,\n \n$$\\begin{aligned}\\overline{x}&={1 \\over R-L+1} \\sum _{i=L} ^R x_i \\\\\\overline{y}&={1 \\over R-L+1} \\sum _{i=L} ^R y_i\\end{aligned}$$\n\nIf the line equation is $y=ax+b$, then $a$ should be computed as:\n\n$$a={\\displaystyle\\sum_{i=L} ^R (x_i-\\overline{x})(y_i-\\overline{y}) \\over \\displaystyle\\sum _{i=L} ^R (x_i -\\overline{x})^2}$$\n\nYou need to help Frank compute $a$.\n\n###  $\\verb!2 L R S T!$\n\nFrank found that the measurements from group $L$ to group $R$ have errors. For each $i$ with $L \\leq i \\leq R$, add $S$ to $x_i$ and add $T$ to $y_i$.\n \n###  $\\verb!3 L R S T!$\n\nFrank needs to modify the data from group $L$ to group $R$. For each $i$ with $L \\leq i \\leq R$, set $x_i$ to $(S+i)$ and set $y_i$ to $(T+i)$.", "inputFormat": "The first line contains two numbers $n,m$, denoting the number of observation groups and the number of operations.\n\nThe next line contains $n$ numbers, where the $i$-th number is $x_i$.\n\nThe next line contains $n$ numbers, where the $i$-th number is $y_i$.\n\nThe next $m$ lines describe the operations. See the formats in the problem statement.", "outputFormat": "For each operation of type $1$, output one line containing the slope $a$. Your output is considered correct if the absolute or relative error does not exceed $10^{-5}$.", "hint": "### Constraints and Notes\n\n- For $20\\%$ of the testdata, $1 \\leq n,m \\leq 1000$.\n- For another $20\\%$ of the testdata, there is no operation $3$, and in operation $2$ we have $S=0$.\n- For another $30\\%$ of the testdata, there is no operation $3$.\n\nFor $100\\%$ of the testdata, $1 \\leq n,m \\leq 10^5$, $0 \\leq |S|,|T| \\leq 10^5$, $0 \\leq |x_i|,|y_i| \\leq 10^5$.\n\nIt is guaranteed that in operation $1$ the denominator will not be $0$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2017] 相关分析", "background": "", "description": "Frank 对天文学非常感兴趣，他经常用望远镜看星星，同时记录下它们的信息，比如亮度、颜色等等，进而估算出星星的距离，半径等等。\n\nFrank 不仅喜欢观测，还喜欢分析观测到的数据。他经常分析两个参数之间（比如亮度和半径）是否存在某种关系。\n\n现在 Frank 要分析参数 $X$ 与 $Y$ 之间的关系。他有 $n$ 组观测数据，第 $i$ 组观测数据记录了 $x_i$ 和 $y_i$。他需要一下几种操作。\n\n###  $\\verb!1 L R!$\n\n用直线拟合第 $L$ 组到第 $R$ 组观测数据。用 $\\overline{x}$ 表示这些观测数据中 $x$ 的平均数，用 $\\overline{y}$ 表示这些观测数据中 $y$ 的平均数，即\n \n$$\\begin{aligned}\\overline{x}&={1 \\over R-L+1} \\sum _{i=L} ^R x_i \\\\\\overline{y}&={1 \\over R-L+1} \\sum _{i=L} ^R y_i\\end{aligned}$$\n\n如果直线方程是 $y=ax+b$，那么 $a$ 应当这样计算：\n\n$$a={\\displaystyle\\sum_{i=L} ^R (x_i-\\overline{x})(y_i-\\overline{y}) \\over \\displaystyle\\sum _{i=L} ^R (x_i -\\overline{x})^2}$$\n\n \n你需要帮助 Frank 计算 $a$。\n\n \n###  $\\verb!2 L R S T!$\n\nFrank 发现测量数据第 $L$ 组到第 $R$ 组数据有误差，对每个 $i$ 满足 $L \\leq i \\leq R$，$x_i$ 需要加上 $S$，$y_i$ 需要加上 $T$。\n \n###  $\\verb!3 L R S T!$\n\nFrank 发现第 $L$ 组到第 $R$ 组数据需要修改，对于每个 $i$ 满足 $L \\leq i \\leq R$，$x_i$ 需要修改为 $(S+i)$，$y_i$ 需要修改为 $(T+i)$。\n", "inputFormat": "第一行两个数 $n,m$，表示观测数据组数和操作次数。\n\n接下来一行 $n$ 个数，第 $i$ 个数是 $x_i$。\n\n接下来一行 $n$ 个数，第 $i$ 个数是 $y_i$。\n\n接下来 $m$ 行，表示操作，格式见题目描述。\n", "outputFormat": "对于每个 $1$ 操作，输出一行，表示直线斜率 $a$。选手输出与标准输出的绝对误差或相对误差不超过 $10^{-5}$ 即为正确。\n", "hint": "### 数据范围及约定\n\n- 对于 $20\\%$ 的数据 $1 \\leq n,m \\leq 1000$；\n- 另有 $20\\%$ 的数据，没有 $3$ 操作，且 $2$ 操作中 $S=0$；\n- 另有 $30\\%$ 的数据，没有 $3$ 操作。\n\n对于 $100\\%$ 的数据，$1 \\leq n,m \\leq 10^5$，$0 \\leq |S|,|T| \\leq 10^5$，$0 \\leq |x_i|,|y_i| \\leq 10^5$。\n\n保证 $1$ 操作不会出现分母为 $0$ 的情况。\n", "locale": "zh-CN"}}}
{"pid": "P3708", "type": "P", "difficulty": 5, "samples": [["10\n", "9 16 22 25 29 27 29 24 21 13\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "洛谷原创", "枚举", "前缀和", "洛谷月赛"], "title": "koishi的数学题", "background": "", "description": "Koishi 在 Flandre 的指导下成为了一名数学大师，她想了一道简单的数学题。\n\n输入一个整数 $n$，设 $\\displaystyle f(x) = \\sum_{i=1}^n x \\bmod i$，你需要输出 $f(1), f(2), \\ldots , f(n)$。\n\n按照套路，Koishi 假装自己并不会做这道题，就来求你帮忙辣。", "inputFormat": "一个正整数 $n$。\n", "outputFormat": "一行用空格分隔的 $n$ 个整数 $f(1), f(2), \\ldots , f(n)$。\n", "hint": "对于 $20\\%$ 的数据，$n \\le 1000$。  \n对于 $60\\%$ 的数据，$n \\le 10^5$。  \n对于 $100\\%$ 的数据，$1 \\le n \\le 10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Koishi's Math Problem", "background": "", "description": "Under Flandre's guidance, Koishi has become a math master, and she came up with a simple math problem.\n\nGiven an integer $n$, let $\\displaystyle f(x) = \\sum_{i=1}^n x \\bmod i$. You need to output $f(1), f(2), \\ldots, f(n)$.\n\nAs usual, Koishi pretends she cannot solve this problem and asks you for help.", "inputFormat": "A positive integer $n$.", "outputFormat": "One line containing $n$ integers $f(1), f(2), \\ldots, f(n)$ separated by spaces.", "hint": "For $20\\%$ of the testdata, $n \\le 1000$.  \nFor $60\\%$ of the testdata, $n \\le 10^5$.  \nFor $100\\%$ of the testdata, $1 \\le n \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "koishi的数学题", "background": "", "description": "Koishi 在 Flandre 的指导下成为了一名数学大师，她想了一道简单的数学题。\n\n输入一个整数 $n$，设 $\\displaystyle f(x) = \\sum_{i=1}^n x \\bmod i$，你需要输出 $f(1), f(2), \\ldots , f(n)$。\n\n按照套路，Koishi 假装自己并不会做这道题，就来求你帮忙辣。", "inputFormat": "一个正整数 $n$。\n", "outputFormat": "一行用空格分隔的 $n$ 个整数 $f(1), f(2), \\ldots , f(n)$。\n", "hint": "对于 $20\\%$ 的数据，$n \\le 1000$。  \n对于 $60\\%$ 的数据，$n \\le 10^5$。  \n对于 $100\\%$ 的数据，$1 \\le n \\le 10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P3709", "type": "P", "difficulty": 5, "samples": [["3 3\n3 3 3\n3 3\n3 3\n3 3", "-1\n-1\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["莫队", "离散化", "洛谷原创", "O2优化", "洛谷月赛"], "title": "大爷的字符串题", "background": "在那遥远的西南有一所学校，\n\n/\\*被和谐部分\\*/\n\n然后去参加该省省选虐场，\n\n然后某蒟蒻不会做，所以也出了一个字符串题：", "description": "给你一个字符串 $a$，每次询问一段区间的贡献。\n\n贡献定义：\n\n每次从这个区间中拿出一个字符 $x$ ，然后把 $x$ 从这个区间中删除，直到区间为空。你要维护一个集合 $S$。\n\n- 如果 $S$ 为空，你 rp 减 $1$。 \n- 如果 $S$ 中有一个元素不小于 $x$，则你 rp 减 $1$，清空 $S$。\n- 之后将 $x$ 插入 $S$。\n\n由于你是大爷，平时做过的题考试都会考到，所以每次询问你搞完这段区间的字符之后最多还有多少 rp？rp 初始为 $0$。\n\n询问之间不互相影响~", "inputFormat": "第一行两个整数 $n$，$m$，表示字符串长度与询问次数。\n\n之后一行 $n$ 个数，第 $i$ 个整数表示给出的字符串的第 $i$ 个字符 $a_i$。\n\n接下来 $m$ 行，每行两个整数 $l, r$，表示一次询问的区间。", "outputFormat": "对于每次询问，输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n- 对于 $10\\%$ 的数据，是样例。\n- 对于另外 $10\\%$ 的数据，保证 $n,m \\le 100$；\n- 对于另外 $10\\%$ 的数据，保证 $n,m \\le 10^3$；\n- 对于另外 $10\\%$ 的数据，保证 $n,m \\le 10^4$；\n- 对于另外 $10\\%$ 的数据，保证 $n,m \\le 10^5$；\n- 对于 $100\\%$ 的数据，$1 \\leq n,m \\le 2 \\times10^5$，$1 \\leq a_i \\leq 10^9$，$1 \\leq l, r \\leq n$。\n\n保证数据像某省省选 day1T2 一样 sb，大家尽情用暴力水过题吧！\n\n没事，你只要在一个好学校，就算这题只能拿到 10 分，也可以进队了。", "locale": "zh-CN", "translations": {"en": {"title": "The Boss's String Problem", "background": "In the distant southwest, there is a school.\n\n/* censored part */\n\nThen they went to that province's NOI Qualifier and crushed the contest.\n\nA newbie (juruo) could not solve it, so they made a string problem.", "description": "You are given a string $a$. For each query, you are asked about the contribution of a sub-interval.\n\nDefinition of contribution:\n\nEach time, pick a character $x$ from this interval (the order is up to you), then delete $x$ from the interval. Repeat until the interval is empty. You need to maintain a set $S$.\n\n- If $S$ is empty, your rp decreases by $1$.\n- If there exists an element in $S$ that is not less than $x$, then your rp decreases by $1$, and you clear $S$.\n- After that, insert $x$ into $S$.\n\nSince you are the boss, problems you have done usually appear in exams. After you process all characters in this interval, what is the maximum rp you can still have? The initial rp is $0$.\n\nQueries are independent.", "inputFormat": "The first line contains two integers $n, m$, the length of the string and the number of queries.\n\nThe next line contains $n$ numbers. The $i$-th integer is the $i$-th character $a_i$ of the given string.\n\nThen $m$ lines follow. Each line contains two integers $l, r$, meaning a query interval.", "outputFormat": "For each query, output a single integer on one line representing the answer.", "hint": "#### Constraints\n\n- For $10\\%$ of the testdata, they are the sample.\n- For another $10\\%$ of the testdata, $n, m \\le 100$.\n- For another $10\\%$ of the testdata, $n, m \\le 10^3$.\n- For another $10\\%$ of the testdata, $n, m \\le 10^4$.\n- For another $10\\%$ of the testdata, $n, m \\le 10^5$.\n- For $100\\%$ of the testdata, $1 \\leq n, m \\le 2 \\times 10^5$, $1 \\leq a_i \\leq 10^9$, $1 \\leq l, r \\leq n$.\n\nThe testdata is as easy as a certain province’s NOI Qualifier Day 1 T2. Feel free to pass it with brute force.\n\nIt’s okay. As long as you are in a good school, even if you can only get 10 points on this problem, you can still make the team.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "大爷的字符串题", "background": "在那遥远的西南有一所学校，\n\n/\\*被和谐部分\\*/\n\n然后去参加该省省选虐场，\n\n然后某蒟蒻不会做，所以也出了一个字符串题：", "description": "给你一个字符串 $a$，每次询问一段区间的贡献。\n\n贡献定义：\n\n每次从这个区间中拿出一个字符 $x$ ，然后把 $x$ 从这个区间中删除，直到区间为空。你要维护一个集合 $S$。\n\n- 如果 $S$ 为空，你 rp 减 $1$。 \n- 如果 $S$ 中有一个元素不小于 $x$，则你 rp 减 $1$，清空 $S$。\n- 之后将 $x$ 插入 $S$。\n\n由于你是大爷，平时做过的题考试都会考到，所以每次询问你搞完这段区间的字符之后最多还有多少 rp？rp 初始为 $0$。\n\n询问之间不互相影响~", "inputFormat": "第一行两个整数 $n$，$m$，表示字符串长度与询问次数。\n\n之后一行 $n$ 个数，第 $i$ 个整数表示给出的字符串的第 $i$ 个字符 $a_i$。\n\n接下来 $m$ 行，每行两个整数 $l, r$，表示一次询问的区间。", "outputFormat": "对于每次询问，输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n- 对于 $10\\%$ 的数据，是样例。\n- 对于另外 $10\\%$ 的数据，保证 $n,m \\le 100$；\n- 对于另外 $10\\%$ 的数据，保证 $n,m \\le 10^3$；\n- 对于另外 $10\\%$ 的数据，保证 $n,m \\le 10^4$；\n- 对于另外 $10\\%$ 的数据，保证 $n,m \\le 10^5$；\n- 对于 $100\\%$ 的数据，$1 \\leq n,m \\le 2 \\times10^5$，$1 \\leq a_i \\leq 10^9$，$1 \\leq l, r \\leq n$。\n\n保证数据像某省省选 day1T2 一样 sb，大家尽情用暴力水过题吧！\n\n没事，你只要在一个好学校，就算这题只能拿到 10 分，也可以进队了。", "locale": "zh-CN"}}}
{"pid": "P3710", "type": "P", "difficulty": 6, "samples": [["6 14\n1 1 5 1\n2 2 4 3\n1 2 6 5\n3 2\n4 1\n3 3\n2 1 3 4\n3 3\n1 2 2 3\n3 2\n4 7\n3 1\n3 2\n3 3", "8\n5\n20\n23\n0\n8\n5"]], "limits": {"time": [4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "平衡树", "洛谷原创", "O2优化", "枚举", "分块", "K-D Tree", "洛谷月赛"], "title": "方方方的数据结构", "background": "", "description": "在很久很久以前，有一个长度为 $n$ 的数列，一开始数列全是 $0$。\n\n方方方觉得这个数列太单调了，打算对它进行 $m$ 次操作，每次操作为区间加法或者区间乘法。\n\n方方方进行一些操作之后，还可能会对某个数进行询问。\n\n但是进行过一些操作之后，方方方可能会发现之前某次操作失误了，需要撤销这次操作，其它操作和其它操作的前后顺序保持不变。\n\n方方方想好这些操作之后，马上想到了一个优秀的数据结构可以维护这些东西，可是他懒得写标程了，就生成了 $10$ 个**随机数据**，就把这道题扔给了你。\n\n**数据全是随机的，生成方式见最下方的提示。**\n", "inputFormat": "第一行两个数 $n,m$，表示数列的长度和操作个数。\n\n接下来 $m$ 行每行 $2$ 或 $4$ 个数。\n\n1. 如果第一个数为 $1$，接下来跟三个数 $l,r,d$，表示把区间 $[l,r]$ 中的数加上 $d$。\n2. 如果第一个数为 $2$，接下来跟三个数 $l,r,d$，表示把区间 $[l,r]$ 中的数乘上 $d$。\n3. 如果第一个数为 $3$，接下来跟一个数 $p$，表示询问 $p$ 位置的数 $\\bmod\\ 998244353$。\n4. 如果第一个数为 $4$，接下来跟一个数 $p$，表示将第 $p$ 行输入的操作撤销（保证为加或者乘操作，一个操作不会被撤销两次）。\n", "outputFormat": "对于每个 $3$ 操作输出一行表示答案。\n", "hint": "对于 $20\\%$ 的数据，$n,m \\leq 500$，时限 1s。\n\n对于 $50\\%$ 的数据，$n,m \\leq 30000$，时限 1s。\n\n对于 $100\\%$ 的数据，$1 \\leq n,m \\leq 150000$，$1 \\le l \\le r \\le n$，$3$ 操作的 $p$ 满足 $1 \\le p \\le n$，$4$ 操作的 $p$ 满足 $1 \\le p \\le m$，$0 \\leq d \\leq 1073741823$（原因见数据生成器），时限 4.5s。\n\n\n数据生成器：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint rand_() {return rand()&32767;} \nint br() {return rand_()*32768+rand_();}\nvector<int> cs;\nint main()\n{\n    srand(...); //这里要填一个种子 \n    int n=...,m=...; //这里要填n、m\n    cout<<n<<\" \"<<m<<\"\\n\";\n    for(int i=1;i<=m;i++)\n    {\n        int o=rand()%4+1;\n        if(o<=2)\n        {\n            cout<<o<<\" \";\n            int l=br()%n+1,r=br()%n+1;\n            if(l>r) swap(l,r); cs.push_back(i);\n            cout<<l<<\" \"<<r<<\" \"<<br()<<\"\\n\";\n        }\n        else if(o==3) cout<<o<<\" \"<<br()%n+1<<\"\\n\";\n        else\n        {\n            if(!cs.size()) {--i; continue;}\n            int s=br()%cs.size(),g=cs[s];\n            cs.erase(cs.begin()+s);\n            cout<<o<<\" \"<<g<<\"\\n\";\n        }\n    }\n}\n```", "locale": "zh-CN", "translations": {"en": {"title": "Fangfangfang's Data Structure", "background": "", "description": "A long time ago, there was a sequence of length $n$, initially all zeros.\n\nFangfangfang thought the sequence was too monotonous and planned to perform $m$ operations on it. Each operation is either a range addition or a range multiplication.\n\nAfter performing some operations, Fangfangfang might also query a certain number.\n\nHowever, after some operations, Fangfangfang might find that a previous operation was mistaken and needs to undo that operation. The other operations and their relative order remain unchanged.\n\nAfter planning these operations, Fangfangfang immediately thought of an excellent data structure to maintain them. But he was too lazy to write the solution, so he generated $10$ random testdata and threw this problem to you.\n\nAll the testdata are random; see the generator in the hint below.", "inputFormat": "The first line contains two integers $n, m$, the length of the sequence and the number of operations.\n\nEach of the next $m$ lines contains $2$ or $4$ integers.\n\n1. If the first integer is $1$, then three integers $l, r, d$ follow, meaning add $d$ to every number in the range $[l, r]$.\n2. If the first integer is $2$, then three integers $l, r, d$ follow, meaning multiply every number in the range $[l, r]$ by $d$.\n3. If the first integer is $3$, then one integer $p$ follows, meaning query the number at position $p$ $\\bmod\\ 998244353$.\n4. If the first integer is $4$, then one integer $p$ follows, meaning undo the operation given on input line $p$ (guaranteed to be an addition or multiplication; no operation will be undone twice).", "outputFormat": "For each type $3$ operation, output one line with the answer.", "hint": "For $20\\%$ of the testdata, $n, m \\leq 500$, time limit $1$ s.\n\nFor $50\\%$ of the testdata, $n, m \\leq 30000$, time limit $1$ s.\n\nFor $100\\%$ of the testdata, $1 \\leq n, m \\leq 150000$, $1 \\le l \\le r \\le n$, for type $3$ operations $1 \\le p \\le n$, for type $4$ operations $1 \\le p \\le m$, $0 \\leq d \\leq 1073741823$ (reason shown in the data generator), time limit $4.5$ s.\n\nData generator:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint rand_() {return rand()&32767;} \nint br() {return rand_()*32768+rand_();}\nvector<int> cs;\nint main()\n{\n    srand(...); //这里要填一个种子 \n    int n=...,m=...; //这里要填n、m\n    cout<<n<<\" \"<<m<<\"\\n\";\n    for(int i=1;i<=m;i++)\n    {\n        int o=rand()%4+1;\n        if(o<=2)\n        {\n            cout<<o<<\" \";\n            int l=br()%n+1,r=br()%n+1;\n            if(l>r) swap(l,r); cs.push_back(i);\n            cout<<l<<\" \"<<r<<\" \"<<br()<<\"\\n\";\n        }\n        else if(o==3) cout<<o<<\" \"<<br()%n+1<<\"\\n\";\n        else\n        {\n            if(!cs.size()) {--i; continue;}\n            int s=br()%cs.size(),g=cs[s];\n            cs.erase(cs.begin()+s);\n            cout<<o<<\" \"<<g<<\"\\n\";\n        }\n    }\n}\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "方方方的数据结构", "background": "", "description": "在很久很久以前，有一个长度为 $n$ 的数列，一开始数列全是 $0$。\n\n方方方觉得这个数列太单调了，打算对它进行 $m$ 次操作，每次操作为区间加法或者区间乘法。\n\n方方方进行一些操作之后，还可能会对某个数进行询问。\n\n但是进行过一些操作之后，方方方可能会发现之前某次操作失误了，需要撤销这次操作，其它操作和其它操作的前后顺序保持不变。\n\n方方方想好这些操作之后，马上想到了一个优秀的数据结构可以维护这些东西，可是他懒得写标程了，就生成了 $10$ 个**随机数据**，就把这道题扔给了你。\n\n**数据全是随机的，生成方式见最下方的提示。**\n", "inputFormat": "第一行两个数 $n,m$，表示数列的长度和操作个数。\n\n接下来 $m$ 行每行 $2$ 或 $4$ 个数。\n\n1. 如果第一个数为 $1$，接下来跟三个数 $l,r,d$，表示把区间 $[l,r]$ 中的数加上 $d$。\n2. 如果第一个数为 $2$，接下来跟三个数 $l,r,d$，表示把区间 $[l,r]$ 中的数乘上 $d$。\n3. 如果第一个数为 $3$，接下来跟一个数 $p$，表示询问 $p$ 位置的数 $\\bmod\\ 998244353$。\n4. 如果第一个数为 $4$，接下来跟一个数 $p$，表示将第 $p$ 行输入的操作撤销（保证为加或者乘操作，一个操作不会被撤销两次）。\n", "outputFormat": "对于每个 $3$ 操作输出一行表示答案。\n", "hint": "对于 $20\\%$ 的数据，$n,m \\leq 500$，时限 1s。\n\n对于 $50\\%$ 的数据，$n,m \\leq 30000$，时限 1s。\n\n对于 $100\\%$ 的数据，$1 \\leq n,m \\leq 150000$，$1 \\le l \\le r \\le n$，$3$ 操作的 $p$ 满足 $1 \\le p \\le n$，$4$ 操作的 $p$ 满足 $1 \\le p \\le m$，$0 \\leq d \\leq 1073741823$（原因见数据生成器），时限 4.5s。\n\n\n数据生成器：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint rand_() {return rand()&32767;} \nint br() {return rand_()*32768+rand_();}\nvector<int> cs;\nint main()\n{\n    srand(...); //这里要填一个种子 \n    int n=...,m=...; //这里要填n、m\n    cout<<n<<\" \"<<m<<\"\\n\";\n    for(int i=1;i<=m;i++)\n    {\n        int o=rand()%4+1;\n        if(o<=2)\n        {\n            cout<<o<<\" \";\n            int l=br()%n+1,r=br()%n+1;\n            if(l>r) swap(l,r); cs.push_back(i);\n            cout<<l<<\" \"<<r<<\" \"<<br()<<\"\\n\";\n        }\n        else if(o==3) cout<<o<<\" \"<<br()%n+1<<\"\\n\";\n        else\n        {\n            if(!cs.size()) {--i; continue;}\n            int s=br()%cs.size(),g=cs[s];\n            cs.erase(cs.begin()+s);\n            cout<<o<<\" \"<<g<<\"\\n\";\n        }\n    }\n}\n```", "locale": "zh-CN"}}}
{"pid": "P3711", "type": "P", "difficulty": 7, "samples": [["2\n3 3 3", "3 5 3 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["多项式", "洛谷原创", "O2优化", "生成函数", "逆元", "快速数论变换 NTT", "洛谷月赛"], "title": "仓鼠的数学题", "background": "请注意本题时限 1s，开启 O2 优化，你可能需要输入输出优化。\n", "description": "仓鼠在某 oj 上看到了一个问题，设 $S_k(x)=\\sum_{i=0}^x i^k$，这个题输入 $a_0,a_1...a_n$，假设 $0^0=1$，要求计算 $\\sum_{k=0}^{n}S_k(x)a_k$。\n\n仓鼠想了两秒就秒了这个题，他发现数据范围居然只有 $1000$，就顺手加了两个 $0$。\n\n但是仓鼠懒得造数据了，就把这道题丢给了你。\n", "inputFormat": "第一行输入一个整数 $n$。\n\n第一行输入 $n+1$ 个空格分隔的非负整数。分别是 $a_0, \\cdots, a_n$。\n", "outputFormat": "输出 $n+2$ 个空格分隔的整数，表示答案多项式的各项系数 $c_0,\\cdots,c_{n+1}$，表示答案多项式为 $\\sum_{i=0}^{n+1}c_ix^i$。多项式的系数对 $998244353$ 取模。\n\n可以证明多项式的次数 $\\leq n+1$。\n", "hint": "对于 $10\\%$ 的数据，$n \\leq 500$。\n\n对于 $30\\%$ 的数据，$n \\leq 3000$。\n\n对于 $70\\%$ 的数据，$n \\leq 100000$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 250000$。\n\n输入和输出多项式系数均为模 $998244353$ 意义下，为 $[0,998244352]$ 的非负整数。\n", "locale": "zh-CN", "translations": {"en": {"title": "Hamster's Math Problem", "background": "Please note that the time limit is 1 s and O2 optimization is enabled. You may need fast I/O.", "description": "A hamster saw a problem on some OJ. Let $S_k(x)=\\sum_{i=0}^x i^k$. This problem inputs $a_0, a_1 \\ldots a_n$. Suppose $0^0=1$. You are asked to compute $\\sum_{k=0}^{n} S_k(x) a_k$.\n\nThe hamster thought for two seconds and solved it in a flash. He found the constraints were only $1000$, so he casually added two zeros.\n\nBut the hamster was too lazy to make testdata, so he threw this problem to you.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains $n+1$ space-separated non-negative integers: $a_0, \\cdots, a_n$.", "outputFormat": "Output $n+2$ space-separated integers, the coefficients $c_0, \\cdots, c_{n+1}$ of the answer polynomial, meaning the polynomial is $\\sum_{i=0}^{n+1} c_i x^i$. The coefficients are taken modulo $998244353$.\n\nIt can be proved that the degree of the polynomial is $\\leq n+1$.", "hint": "For $10\\%$ of the testdata, $n \\leq 500$.\n\nFor $30\\%$ of the testdata, $n \\leq 3000$.\n\nFor $70\\%$ of the testdata, $n \\leq 100000$.\n\nFor $100\\%$ of the testdata, $1 \\leq n \\leq 250000$.\n\nBoth the input and output polynomial coefficients are taken modulo $998244353$ and are non-negative integers in $[0, 998244352]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "仓鼠的数学题", "background": "请注意本题时限 1s，开启 O2 优化，你可能需要输入输出优化。\n", "description": "仓鼠在某 oj 上看到了一个问题，设 $S_k(x)=\\sum_{i=0}^x i^k$，这个题输入 $a_0,a_1...a_n$，假设 $0^0=1$，要求计算 $\\sum_{k=0}^{n}S_k(x)a_k$。\n\n仓鼠想了两秒就秒了这个题，他发现数据范围居然只有 $1000$，就顺手加了两个 $0$。\n\n但是仓鼠懒得造数据了，就把这道题丢给了你。\n", "inputFormat": "第一行输入一个整数 $n$。\n\n第一行输入 $n+1$ 个空格分隔的非负整数。分别是 $a_0, \\cdots, a_n$。\n", "outputFormat": "输出 $n+2$ 个空格分隔的整数，表示答案多项式的各项系数 $c_0,\\cdots,c_{n+1}$，表示答案多项式为 $\\sum_{i=0}^{n+1}c_ix^i$。多项式的系数对 $998244353$ 取模。\n\n可以证明多项式的次数 $\\leq n+1$。\n", "hint": "对于 $10\\%$ 的数据，$n \\leq 500$。\n\n对于 $30\\%$ 的数据，$n \\leq 3000$。\n\n对于 $70\\%$ 的数据，$n \\leq 100000$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 250000$。\n\n输入和输出多项式系数均为模 $998244353$ 意义下，为 $[0,998244352]$ 的非负整数。\n", "locale": "zh-CN"}}}
{"pid": "P3712", "type": "P", "difficulty": 6, "samples": [["3 5 3\n1 3\n2 3\n1 1 3\n2 3 3\n1 1 3\n2 1 2\n1 1 3", "6\n9\n11"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["洛谷原创", "O2优化"], "title": "少女与战车", "background": "如果你对山口丁和 G&P 没有兴趣，可以无视题目背景，因为你估计看不懂 ……\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4760.png) \n\n在第 63 回战车道全国高中生大赛中，军神西住美穗带领大洗女子学院的大家打败了其他所有高中，取得了胜利，当然也就不用废校了。\n\n然而一群战车道的领导表示他们是口胡的，废校还是要废的。\n\n军神的母亲西住志穗怒斥废校男，为了不造个大新闻，废校男承诺如果大洗学院可以打败大学队，就不用废校。\n\n（有种 OI 选手 PK ACM 选手的感觉呀）\n\n然而实力差距太大了，大洗女子学院最强的车是虎式 P 型，而大学队清一色的 M26 潘兴，M24 霞飞，还有能跑到 20 的 T95 和卡尔臼炮，感觉根本没法打呀。\n\n这时候一个光头的胖子谢尔盖 • 布尔卡托夫斯基和一个身患癌症急需钱来治病的王姓 CEO 来帮助她们了。\n\n他们把一堆真实性堪忧的坦克图纸给了大洗学院的妹子们，并说这些图纸是真的，而且还原了历史。\n\n大洗学院汽车部的大家看到了这些图纸后非常高兴，开始膜改她们的战车。\n\n\n虎式P型 -> 蟋蟀17\n\n四号D型 -> 四号坦克武器运载车\n\n38(t)型 -> 莱茵金属公司武器运载车\n\nB1-bis  -> 105leFH18B2\n\n即使这样，只有 8 辆战车的大洗女子学院仍然无法打败有 30 辆战车的大学队。\n\n这时候按照剧本其他高中的小伙伴要来帮忙了，然而她们最近正在学习 OI，碰到了一道很神奇的数据结构题，不会做所以来不了。\n\n你作为一个三次元的国家队选手，当然能秒杀二次元的 OI 题啦。\n\n请帮帮她们吧！\n", "description": " ![](https://cdn.luogu.com.cn/upload/pic/4761.png) \n\n给你一个 $n$ 个点的有根树， $1$ 为根，带边权，有 $m$ 次操作。\n\n\n1、求 $x$ 的子树中第 $k$ 小的深度的值，如果子树中没有 $k$ 个点则输出 $-1$；\n\n2、将 $x$ 与 $x$ 父亲的边权加上 $k$。\n\n保证每次操作 2 的 $k$ 以及原树的边权小于等于一个数 $len$。\n\n\n如果操作 2 中 $x$ 为 $1$，那么视为将 $x$ 的基础深度加上了 $k$。\n", "inputFormat": " ![](https://cdn.luogu.com.cn/upload/pic/4763.png) \n\n第一行三个数 $n$、 $m$、$len$。\n\n之后 $n - 1$ 行每行两个数表示 $2$~$n$ 每个点的父亲编号，以及他们到父亲的边权。\n\n之后 $m$ 行每行三个数 $opt$、 $x$、$k$， $opt$ 表示操作种类， $x$、 $k$ 意义如题所述。\n", "outputFormat": "对于每个操作 1，输出一个数表示答案。\n", "hint": "数据范围与提示\n\n对于 10% 的数据， $n, m \\leq 1000$；\n\n对于 30% 的数据， $n, m \\leq 30000$；\n\n对于 100% 的数据，$ n, m \\leq 100000,len \\leq 10$。\n\n\n本水题采用捆绑测试，你只有通过该部分分的所有数据才可以得到该部分分的分数。\n\n\n如果你对山口丁和 G&P 没有兴趣，可以无视结局。\n\n\n\n如果你做出来了这个题\n\n\n妹子们看了你的 STD 之后都 A 了这个题，然后去帮助军神。\n\n她们找了 30 个 183 射了对面一脸。\n\n\n如果你没做出来这个题\n\n\n妹子们虽然很想帮助军神，但是也爱莫能助，毕竟学战车道不能保送。\n\n没有办法，只能 8 打 30 了。\n\n莱茵蹲在草里，大学队没有人发现它，成功击杀五辆敌方坦克后因为车体无法承受火炮后坐力而解体。\n\n三突也蹲在草里，大学队没有人发现它，它也没有发现任何人，最后蹲不住了去突击，击毁一辆潘兴后被击毁。\n\n四运文艺倒车，大学队看到之后目瞪口呆，成功击杀八辆敌方坦克后因为车体无法承受火炮后坐力而解体。\n\n虎P炮一发带走了 95，然后因为转场的时候发动机故障而烧毁。\n\n最后法五金刺刀了 15 个，成功翻盘。\n\n![](https://cdn.luogu.com.cn/upload/pic/4762.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "Girls und Panzer", "background": "If you are not interested in Shankouding (pinyin) and G&P, you can ignore the background, because you probably won’t understand it anyway.\n\n![](https://cdn.luogu.com.cn/upload/pic/4760.png)\n\nIn the 63rd National High School Sensha-dō Tournament, the war goddess Miho Nishizumi led the Ōarai Girls’ Academy to defeat all other high schools and win the championship, which meant the school would not be shut down.\n\nHowever, a group of Sensha-dō officials said they were just kidding, and the shutdown would still proceed.\n\nMiho’s mother, Shiho Nishizumi, scolded the shutdown guy. To avoid making big news, the shutdown guy promised that if Ōarai could defeat the University Team, the school would not be shut down.\n\n(It feels like an OI contestant versus an ACM contestant.)\n\nBut the strength gap was huge. Ōarai’s strongest tank was the Tiger (P), while the University Team fielded all M26 Pershings, M24 Chaffees, plus a T95 that could go 20 and the Karl-Gerät mortar. It felt unwinnable.\n\nAt this moment, a bald fat man named Sergei • Burkatovsky and a CEO surnamed Wang, who was suffering from cancer and urgently needed money for treatment, came to help them.\n\nThey gave the Ōarai girls a pile of tank blueprints of dubious authenticity and claimed they were real and historically accurate.\n\nThe Ōarai Automotive Club was thrilled upon seeing these blueprints and began modding their tanks.\n\nTiger (P) -> Grille 17\n\nPanzer IV Ausf. D -> Panzer IV Waffenträger\n\n38(t) -> Rheinmetall Waffenträger\n\nB1-bis -> 105 leFH18B2\n\nEven so, with only 8 tanks, Ōarai still couldn’t defeat the University Team with 30 tanks.\n\nAccording to the script, friends from other high schools were supposed to help, but they were currently studying OI and had stumbled upon a very magical data structure problem. They couldn’t solve it, so they couldn’t come.\n\nAs a real-world national team member, you can certainly crush a 2D OI problem in seconds.\n\nPlease help them!", "description": "![](https://cdn.luogu.com.cn/upload/pic/4761.png)\n\nYou are given a rooted tree with $n$ nodes, rooted at $1$, with edge weights, and there are $m$ operations.\n\n1. Query the $k$-th smallest depth value among nodes in the subtree of $x$. If the subtree has fewer than $k$ nodes, output $-1$.\n2. Add $k$ to the weight of the edge between $x$ and its parent.\n\nIt is guaranteed that in every operation 2, the value $k$ and all original edge weights in the tree are less than or equal to a number $len$.\n\nIf $x$ is $1$ in operation 2, then it is treated as adding $k$ to the base depth of $x$.", "inputFormat": "![](https://cdn.luogu.com.cn/upload/pic/4763.png)\n\nThe first line contains three integers $n$, $m$, and $len$.\n\nThe next $n - 1$ lines each contain two integers, describing for nodes $2$~$n$ the parent of each node and the weight of the edge to its parent.\n\nThe next $m$ lines each contain three integers $opt$, $x$, and $k$. Here $opt$ denotes the operation type, and $x$, $k$ have the meanings described above.", "outputFormat": "For each operation of type 1, output a single integer representing the answer.", "hint": "Constraints and Hints\n\nFor 10% of the testdata, $n, m \\leq 1000$.\n\nFor 30% of the testdata, $n, m \\leq 30000$.\n\nFor 100% of the testdata, $n, m \\leq 100000, len \\leq 10$.\n\nThis easy problem uses bundled testdata. You can only receive the points for a subtask if you pass all testdata in that subtask.\n\nIf you are not interested in Shankouding (pinyin) and G&P, you can ignore the ending.\n\nIf you solved this problem:\n\nThe girls read your STD and all got AC on this problem, then went to help the war goddess.\n\nThey found 30 “183”s and blasted the enemy in the face.\n\nIf you didn’t solve this problem:\n\nAlthough the girls really wanted to help the war goddess, they couldn’t. After all, learning Sensha-dō doesn’t grant direct admissions.\n\nThere was no other way; they had to fight 8 versus 30.\n\nThe Rheinmetall camped in the bushes. No one on the University Team spotted it. After it destroyed five enemy tanks, its hull couldn’t withstand the gun’s recoil and it fell apart.\n\nThe StuG III also camped in the bushes. No one on the University Team spotted it, and it didn’t spot anyone either. In the end it couldn’t sit still, charged forward, destroyed a Pershing, and was then destroyed.\n\nThe Waffenträger reversed artistically. The University Team was dumbfounded when they saw it. After it destroyed eight enemy tanks, its hull couldn’t withstand the gun’s recoil and it fell apart.\n\nThe Tiger (P) took out the 95 with a single shot, then burned down due to an engine failure during repositioning.\n\nFinally, the French B1 fixed bayonets and stabbed 15 of them, turning the game around.\n\n![](https://cdn.luogu.com.cn/upload/pic/4762.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "少女与战车", "background": "如果你对山口丁和 G&P 没有兴趣，可以无视题目背景，因为你估计看不懂 ……\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4760.png) \n\n在第 63 回战车道全国高中生大赛中，军神西住美穗带领大洗女子学院的大家打败了其他所有高中，取得了胜利，当然也就不用废校了。\n\n然而一群战车道的领导表示他们是口胡的，废校还是要废的。\n\n军神的母亲西住志穗怒斥废校男，为了不造个大新闻，废校男承诺如果大洗学院可以打败大学队，就不用废校。\n\n（有种 OI 选手 PK ACM 选手的感觉呀）\n\n然而实力差距太大了，大洗女子学院最强的车是虎式 P 型，而大学队清一色的 M26 潘兴，M24 霞飞，还有能跑到 20 的 T95 和卡尔臼炮，感觉根本没法打呀。\n\n这时候一个光头的胖子谢尔盖 • 布尔卡托夫斯基和一个身患癌症急需钱来治病的王姓 CEO 来帮助她们了。\n\n他们把一堆真实性堪忧的坦克图纸给了大洗学院的妹子们，并说这些图纸是真的，而且还原了历史。\n\n大洗学院汽车部的大家看到了这些图纸后非常高兴，开始膜改她们的战车。\n\n\n虎式P型 -> 蟋蟀17\n\n四号D型 -> 四号坦克武器运载车\n\n38(t)型 -> 莱茵金属公司武器运载车\n\nB1-bis  -> 105leFH18B2\n\n即使这样，只有 8 辆战车的大洗女子学院仍然无法打败有 30 辆战车的大学队。\n\n这时候按照剧本其他高中的小伙伴要来帮忙了，然而她们最近正在学习 OI，碰到了一道很神奇的数据结构题，不会做所以来不了。\n\n你作为一个三次元的国家队选手，当然能秒杀二次元的 OI 题啦。\n\n请帮帮她们吧！\n", "description": " ![](https://cdn.luogu.com.cn/upload/pic/4761.png) \n\n给你一个 $n$ 个点的有根树， $1$ 为根，带边权，有 $m$ 次操作。\n\n\n1、求 $x$ 的子树中第 $k$ 小的深度的值，如果子树中没有 $k$ 个点则输出 $-1$；\n\n2、将 $x$ 与 $x$ 父亲的边权加上 $k$。\n\n保证每次操作 2 的 $k$ 以及原树的边权小于等于一个数 $len$。\n\n\n如果操作 2 中 $x$ 为 $1$，那么视为将 $x$ 的基础深度加上了 $k$。\n", "inputFormat": " ![](https://cdn.luogu.com.cn/upload/pic/4763.png) \n\n第一行三个数 $n$、 $m$、$len$。\n\n之后 $n - 1$ 行每行两个数表示 $2$~$n$ 每个点的父亲编号，以及他们到父亲的边权。\n\n之后 $m$ 行每行三个数 $opt$、 $x$、$k$， $opt$ 表示操作种类， $x$、 $k$ 意义如题所述。\n", "outputFormat": "对于每个操作 1，输出一个数表示答案。\n", "hint": "数据范围与提示\n\n对于 10% 的数据， $n, m \\leq 1000$；\n\n对于 30% 的数据， $n, m \\leq 30000$；\n\n对于 100% 的数据，$ n, m \\leq 100000,len \\leq 10$。\n\n\n本水题采用捆绑测试，你只有通过该部分分的所有数据才可以得到该部分分的分数。\n\n\n如果你对山口丁和 G&P 没有兴趣，可以无视结局。\n\n\n\n如果你做出来了这个题\n\n\n妹子们看了你的 STD 之后都 A 了这个题，然后去帮助军神。\n\n她们找了 30 个 183 射了对面一脸。\n\n\n如果你没做出来这个题\n\n\n妹子们虽然很想帮助军神，但是也爱莫能助，毕竟学战车道不能保送。\n\n没有办法，只能 8 打 30 了。\n\n莱茵蹲在草里，大学队没有人发现它，成功击杀五辆敌方坦克后因为车体无法承受火炮后坐力而解体。\n\n三突也蹲在草里，大学队没有人发现它，它也没有发现任何人，最后蹲不住了去突击，击毁一辆潘兴后被击毁。\n\n四运文艺倒车，大学队看到之后目瞪口呆，成功击杀八辆敌方坦克后因为车体无法承受火炮后坐力而解体。\n\n虎P炮一发带走了 95，然后因为转场的时候发动机故障而烧毁。\n\n最后法五金刺刀了 15 个，成功翻盘。\n\n![](https://cdn.luogu.com.cn/upload/pic/4762.png)\n", "locale": "zh-CN"}}}
{"pid": "P3713", "type": "P", "difficulty": 6, "samples": [["2 2\n.*\n*.", "72"], ["2 3\n.*.\n*.*", "418"], ["4 4\nabba\nbaab\nbaab\nabba", "44512"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "搜索", "2017", "各省省选", "北京", "记忆化搜索"], "title": "[BJOI2017] 机动训练", "background": "> AM 4:45\n>\n> 又是晴朗的好天气。\n>\n> AM 5:00\n>\n> 不要嘛，再睡一会\n>\n> AM 5:05\n>\n> 呜……欺负人", "description": "睡眼朦胧的菜酱 (?) 已经被二爷拉起来晨跑了。而这个时间你在做什么呢？\n\n咳咳，言归正传，最近菜酱的训练遇到了点小麻烦。\n\n凌晨绕格瑞赛亚岛跑一圈是基本，在那之后，菜酱还要接受严格的机动训练。所谓机动训练，就是在紧急情况 (?) 下，高速且隐蔽地从位置 $s$ 移动到位置 $t$ 的训练。一般来说，$s$ 和 $t$ 是根据二爷的心情随机决定的，但是由于菜酱已经熟悉了地形，每次总是能找到不太费劲的路径，二爷决定增大难度。所谓增大难度，其实就是指定整条路径，这样菜酱就没办法抄近道了。当然，由于是为了实战而进行的训练，二爷也不会随便乱指定路径，至少不会故意绕路。然后发生的问题就是，如何才能「随机」一整条路径出来？二爷统计了全岛所有的合法路径，打算每次在这个表格里随机抽一条出来。但是很快二爷发现，许多路径所经过的地形是完全相同的，这类路径的训练会更加有用。于是二爷修改了随机策略，地形较为常见的路径权重会变得更大。\n\n一次偶然的机会，菜酱看到了二爷的随机策略，并发动技能「过目不忘 (?)」记了下来。现在你要帮菜酱分析数据。\n\n为什么是你？当然是因为否则就会被菜酱爆头 (并不)。\n\n整个岛可以看作一片 $m\\times n$ 的区域，每个格子有自己的地形。\n\n一条路径由一系列八连通的格子组成，两个格子八连通当且仅当这两个格子拥有公共的顶点。\n\n定义一条“机动路径”如下：\n\n1. 它是一条不自交的路径，即路径上任意两个格子都不是同一个。\n2. 它的起点和终点处于不同位置，换言之这条路径至少包含 $2$ 个格子。\n3. 从起点开始，任何一步只能向不远离终点的方向移动，这里不远离指的是 $x$ 和 $y$ 两个方向都不远离。\n\n举例说明：\n\n```plain\n.....t    ......    .---.\n-++...    ---...    .-s-.\n-s+...    -s+..t    .-+-.\n---...    ---...    ..t..\n```\n\n图中加号和减号标明了与 $s$ 八连通的所有格子，其中加号是“不远离 $t$”的方向。\n\n因此可以看出，如下路径是机动路径：\n\n```plain\n++++++t    ......+t    .......t\n+......    .....++.    ......+.\n+......    ..++++..    ...+++..\ns......    s++.....    s+++....\n```\n\n而如下路径不是机动路径：\n\n```plain\n\\../---t    .......t    .s.\n|--.....    ....../.    /..\n|.......    s..../..    \\..\ns.......    .\\--/...    .t.\n```\n\n需要注意的是，某些不合法的路径甚至比机动路径还要短，这是因为机动路径不是按照长度来定义的。\n\n接下来定义一条机动路径的地形，岛上的地形由一个矩阵给出，如：\n\n```plain\n.**.\n*..*\n*..*\n.**.\n```\n\n那么，一条机动路径的地形序列就是它所经过的地形排成一列，如：\n\n```plain\ns-\\.\n...\\\n...|\n...t\n```\n\n地形序列就是 `.****.`。\n\n每条机动路径的权重就是与之拥有相同地形序列的机动路径数量之和，例如与这条路径拥有相同地形序列的路径有\n\n```plain\n./-t    t...    ...s    s-\\.    ./-s    s...    ...t    t-\\.\n/...    |...    ...|    ...\\    /...    |...    ...|    ...\\\n|...    \\...    .../    ...|    |...    \\...    .../    ...|\ns...    .\\-s    t-/.    ...t    t...    .\\-t    s-/.    ...s\n```\n\n共 $8$ 条，注意回文时正反算两条，以及自己也算一条。\n\n所以这条机动路径的权重是 $8$，同时所有这 $8$ 条机动路径的权重都是 $8$。\n\n现在你需要统计所有的机动路径权重之和。\n\n如果对这种统计方式没有直观的感受，可以查看样例说明。\n", "inputFormat": "第一行两个整数 $m,n$，表示岛的大小。\n\n接下来 $m$ 行，每行 $n$ 个字符，表示岛的地形。", "outputFormat": "仅一个数，表示所有机动路径的权重之和。\n\n由于这个数可能很大，你只需要输出它对 $10^9+9$ 取模的结果。", "hint": "### 样例解释 1\n用中括号括起来的一些数对表示一条机动路径，坐标先行后列：\n\n- 地形序列 `.*`：$[(1, 1), (1, 2)],\\ [(1, 1), (2, 1)],\\ [(2, 2), (2, 1)],\\ [(2, 2), (1, 2)]$，共 $4$ 条，每条权重为 $4$，计 $16$。\n- 地形序列 `*.`：$[(1, 2), (1, 1)],\\ [(2, 1), (1, 1)],\\ [(2, 1), (2, 2)],\\ [(1, 2), (2, 2)]$，共 $4$ 条，每条权重为 $4$，计 $16$。\n- 地形序列 `..`：$[(1, 1), (2, 2)],\\ [(2, 2), (1, 1)]$，共 $2$ 条，每条权重为 $2$，计 $4$。\n- 地形序列 `**`：$[(1, 2), (2, 1)],\\ [(2, 1), (1, 2)]$，共 $2$ 条，每条权重为 $2$，计 $4$。\n- 地形序列 `.*.`：$[(1, 1), (1, 2), (2, 2)],\\ [(1, 1), (2, 1), (2, 2)],\\ [(2, 2), (2, 1), (1, 1)],\\ [(2, 2), (1, 2), (1, 1)]$，共 $4$ 条，每条权重为 $4$，计 $16$。\n- 地形序列 `*.*`：$[(1, 2), (1, 1), (2, 1)],\\ [(2, 1), (1, 1), (1, 2)],\\ [(1, 2), (2, 2), (2, 1)],\\ [(2, 1), (2, 2), (1, 2)]$，共 $4$ 条，每条权重为 $4$，计 $16$。\n\n共计 $16+16+4+4+16+16=72$。\n\n### 样例解释 2\n- 地形序列 `.*`：$7$ 条，每条权重为 $7$，计 $49$。\n- 地形序列 `*.`：$7$ 条，每条权重为 $7$，计 $49$。\n- 地形序列 `..`：$4$ 条，每条权重为 $4$，计 $16$。\n- 地形序列 `**`：$4$ 条，每条权重为 $4$，计 $16$。\n- 地形序列 `..*`：$2$ 条，每条权重为 $2$，计 $4$。\n- 地形序列 `.*.`：$10$ 条，每条权重为 $10$，计 $100$。\n- 地形序列 `.**`：$2$ 条，每条权重为 $2$，计 $4$。\n- 地形序列 `*..`：$2$ 条，每条权重为 $2$，计 $4$。\n- 地形序列 `*.*`：$10$ 条，每条权重为 $10$，计 $100$。\n- 地形序列 `**.`：$2$ 条，每条权重为 $2$，计 $4$。\n- 地形序列 `.*.*`：$6$ 条，每条权重为 $6$，计 $36$。\n- 地形序列 `*.*.`：$6$ 条，每条权重为 $6$，计 $36$。\n\n共计 $49+49+16+16+4+100+4+4+100+4+36+36=418$。\n\n### 数据范围\n\n- 对于 $10\\%$ 的数据，$m\\times n \\le 4$。\n- 对于 $30\\%$ 的数据，$m, n \\le 5$。\n- 对于 $60\\%$ 的数据，$m, n \\le 10$。\n- 另有 $20\\%$ 的数据，所有地形均相同。\n- 对于 $100\\%$ 的数据，$1 \\le m, n \\le 30$，字符集由大小写字母，数字和 `.` `*` 构成。", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2017] Mobility Training", "background": "> AM 4:45\n>\n> Another clear, sunny day.\n>\n> AM 5:00\n>\n> Nooo, let me sleep a bit more.\n>\n> AM 5:05\n>\n> Ugh... bullying me.\n\nSleepy Caijiang (?) has already been dragged out by Er-ye for a morning run. And what are you doing at this time?\n\nAhem, back to the topic. Caijiang’s recent training has run into a small problem.\n\nRunning one lap around Grisaia Island before dawn is basic. After that, Caijiang must also undergo strict mobility training. “Mobility training” means, under an emergency situation (?), moving quickly and covertly from position $s$ to position $t$. In general, $s$ and $t$ are chosen at random according to Er-ye’s mood. But since Caijiang has already learned the terrain, she always finds a not-so-hard path, so Er-ye decided to increase the difficulty. Increasing the difficulty basically means specifying the entire path so that Caijiang cannot take shortcuts. Of course, because this is training for real combat, Er-ye will not assign paths arbitrarily, at least not deliberately detouring. The problem that arises is: how to “randomly” pick an entire path? Er-ye counted all legal paths on the whole island and planned to randomly draw one each time from this table. But he soon found that many paths go through exactly the same terrains, and such paths are more useful for training. So he changed the random strategy: paths with more common terrain sequences get larger weights.\n\nBy chance, Caijiang saw Er-ye’s random strategy and used the skill “photographic memory (?)” to memorize it. Now you need to help Caijiang analyze the data.\n\nWhy you? Because otherwise Caijiang will headshot you (not really).\n\nThe entire island can be seen as an $m\\times n$ area, each cell with its own terrain.\n\nA path is a sequence of 8-connected cells; two cells are 8-connected if and only if the two cells share a common corner.\n\nDefine a “mobility path” as follows:\n\n1. It is a simple path, that is, no two cells on the path are the same.\n2. Its start and end are in different positions; in other words, the path contains at least $2$ cells.\n3. Starting from the beginning, each step can only move in a direction that does not move away from the destination; here “not moving away” means that in both the $x$ and $y$ directions you do not move away.\n\nIllustration:\n\n```plain\n.....t    ......    .---.\n-++...    ---...    .-s-.\n-s+...    -s+..t    .-+-.\n---...    ---...    ..t..\n```\n\nIn the figure, plus and minus signs mark all cells that are 8-connected to $s$, where plus signs indicate directions that are “not moving away from $t$.”\n\nTherefore, the following paths are mobility paths:\n\n```plain\n++++++t    ......+t    .......t\n+......    .....++.    ......+.\n+......    ..++++..    ...+++..\ns......    s++.....    s+++....\n```\n\nAnd the following are not mobility paths:\n\n```plain\n\\../---t    .......t    .s.\n|--.....    ....../.    /..\n|.......    s..../..    \\..\ns.......    .\\--/...    .t.\n```\n\nNote that some illegal paths can even be shorter than mobility paths, because mobility paths are not defined by their length.\n\nNext, define the terrain of a mobility path. The island’s terrain is given by a matrix, for example:\n\n```plain\n.**.\n*..*\n*..*\n.**.\n```\n\nThen the terrain sequence of a mobility path is the terrains it passes through listed in order, such as:\n\n```plain\ns-\\.\n...\\\n...|\n...t\n```\n\nThe terrain sequence is `.****.`.\n\nThe weight of each mobility path is the total number of mobility paths that have the same terrain sequence. For example, the paths that have the same terrain sequence as this path are\n\n```plain\n./-t    t...    ...s    s-\\.    ./-s    s...    ...t    t-\\.\n/...    |...    ...|    ...\\    /...    |...    ...|    ...\\\n|...    \\...    .../    ...|    |...    \\...    .../    ...|\ns...    .\\-s    t-/.    ...t    t...    .\\-t    s-/.    ...s\n```\n\nThere are $8$ of them. Note that when the sequence is a palindrome, forward and reverse still count as two, and the path itself also counts.\n\nSo the weight of this mobility path is $8$, and all these $8$ mobility paths have weight $8$ as well.\n\nNow you need to sum the weights of all mobility paths.\n\nIf this counting method is not intuitive, see the sample explanations.", "description": "Input the island’s terrain grid and compute the sum of weights over all mobility paths, where the weight of a mobility path is the number of mobility paths sharing the same terrain sequence. Output the result modulo $10^9+9$.", "inputFormat": "The first line contains two integers $m, n$, the size of the island.\n\nThen follow $m$ lines, each containing $n$ characters, describing the island’s terrain.", "outputFormat": "Output a single number, the sum of weights over all mobility paths, modulo $10^9+9$.", "hint": "### Sample Explanation 1\nPairs in square brackets denote a mobility path, with coordinates in the order row, column:\n\n- Terrain sequence `.*`: $[(1, 1), (1, 2)],\\ [(1, 1), (2, 1)],\\ [(2, 2), (2, 1)],\\ [(2, 2), (1, 2)]$, $4$ paths in total, each with weight $4$, contributing $16$.\n- Terrain sequence `*.`: $[(1, 2), (1, 1)],\\ [(2, 1), (1, 1)],\\ [(2, 1), (2, 2)],\\ [(1, 2), (2, 2)]$, $4$ paths in total, each with weight $4$, contributing $16$.\n- Terrain sequence `..`: $[(1, 1), (2, 2)],\\ [(2, 2), (1, 1)]$, $2$ paths in total, each with weight $2$, contributing $4$.\n- Terrain sequence `**`: $[(1, 2), (2, 1)],\\ [(2, 1), (1, 2)]$, $2$ paths in total, each with weight $2$, contributing $4$.\n- Terrain sequence `.*.`: $[(1, 1), (1, 2), (2, 2)],\\ [(1, 1), (2, 1), (2, 2)],\\ [(2, 2), (2, 1), (1, 1)],\\ [(2, 2), (1, 2), (1, 1)]$, $4$ paths in total, each with weight $4$, contributing $16$.\n- Terrain sequence `*.*`: $[(1, 2), (1, 1), (2, 1)],\\ [(2, 1), (1, 1), (1, 2)],\\ [(1, 2), (2, 2), (2, 1)],\\ [(2, 1), (2, 2), (1, 2)]$, $4$ paths in total, each with weight $4$, contributing $16$.\n\nTotal: $16+16+4+4+16+16=72$.\n\n### Sample Explanation 2\n- Terrain sequence `.*`: $7$ paths, each with weight $7$, contributing $49$.\n- Terrain sequence `*.`: $7$ paths, each with weight $7$, contributing $49$.\n- Terrain sequence `..`: $4$ paths, each with weight $4$, contributing $16$.\n- Terrain sequence `**`: $4$ paths, each with weight $4$, contributing $16$.\n- Terrain sequence `..*`: $2$ paths, each with weight $2$, contributing $4$.\n- Terrain sequence `.*.`: $10$ paths, each with weight $10$, contributing $100$.\n- Terrain sequence `.**`: $2$ paths, each with weight $2$, contributing $4$.\n- Terrain sequence `*..`: $2$ paths, each with weight $2$, contributing $4$.\n- Terrain sequence `*.*`: $10$ paths, each with weight $10$, contributing $100$.\n- Terrain sequence `**.`: $2$ paths, each with weight $2$, contributing $4$.\n- Terrain sequence `.*.*`: $6$ paths, each with weight $6$, contributing $36$.\n- Terrain sequence `*.*.`: $6$ paths, each with weight $6$, contributing $36$.\n\nTotal: $49+49+16+16+4+100+4+4+100+4+36+36=418$.\n\n### Constraints\n\n- For $10\\%$ of the testdata, $m\\times n \\le 4$.\n- For $30\\%$ of the testdata, $m, n \\le 5$.\n- For $60\\%$ of the testdata, $m, n \\le 10$.\n- In an additional $20\\%$ of the testdata, all terrains are the same.\n- For $100\\%$ of the testdata, $1 \\le m, n \\le 30$, and the character set consists of uppercase letters, lowercase letters, digits, and `.` `*`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2017] 机动训练", "background": "> AM 4:45\n>\n> 又是晴朗的好天气。\n>\n> AM 5:00\n>\n> 不要嘛，再睡一会\n>\n> AM 5:05\n>\n> 呜……欺负人", "description": "睡眼朦胧的菜酱 (?) 已经被二爷拉起来晨跑了。而这个时间你在做什么呢？\n\n咳咳，言归正传，最近菜酱的训练遇到了点小麻烦。\n\n凌晨绕格瑞赛亚岛跑一圈是基本，在那之后，菜酱还要接受严格的机动训练。所谓机动训练，就是在紧急情况 (?) 下，高速且隐蔽地从位置 $s$ 移动到位置 $t$ 的训练。一般来说，$s$ 和 $t$ 是根据二爷的心情随机决定的，但是由于菜酱已经熟悉了地形，每次总是能找到不太费劲的路径，二爷决定增大难度。所谓增大难度，其实就是指定整条路径，这样菜酱就没办法抄近道了。当然，由于是为了实战而进行的训练，二爷也不会随便乱指定路径，至少不会故意绕路。然后发生的问题就是，如何才能「随机」一整条路径出来？二爷统计了全岛所有的合法路径，打算每次在这个表格里随机抽一条出来。但是很快二爷发现，许多路径所经过的地形是完全相同的，这类路径的训练会更加有用。于是二爷修改了随机策略，地形较为常见的路径权重会变得更大。\n\n一次偶然的机会，菜酱看到了二爷的随机策略，并发动技能「过目不忘 (?)」记了下来。现在你要帮菜酱分析数据。\n\n为什么是你？当然是因为否则就会被菜酱爆头 (并不)。\n\n整个岛可以看作一片 $m\\times n$ 的区域，每个格子有自己的地形。\n\n一条路径由一系列八连通的格子组成，两个格子八连通当且仅当这两个格子拥有公共的顶点。\n\n定义一条“机动路径”如下：\n\n1. 它是一条不自交的路径，即路径上任意两个格子都不是同一个。\n2. 它的起点和终点处于不同位置，换言之这条路径至少包含 $2$ 个格子。\n3. 从起点开始，任何一步只能向不远离终点的方向移动，这里不远离指的是 $x$ 和 $y$ 两个方向都不远离。\n\n举例说明：\n\n```plain\n.....t    ......    .---.\n-++...    ---...    .-s-.\n-s+...    -s+..t    .-+-.\n---...    ---...    ..t..\n```\n\n图中加号和减号标明了与 $s$ 八连通的所有格子，其中加号是“不远离 $t$”的方向。\n\n因此可以看出，如下路径是机动路径：\n\n```plain\n++++++t    ......+t    .......t\n+......    .....++.    ......+.\n+......    ..++++..    ...+++..\ns......    s++.....    s+++....\n```\n\n而如下路径不是机动路径：\n\n```plain\n\\../---t    .......t    .s.\n|--.....    ....../.    /..\n|.......    s..../..    \\..\ns.......    .\\--/...    .t.\n```\n\n需要注意的是，某些不合法的路径甚至比机动路径还要短，这是因为机动路径不是按照长度来定义的。\n\n接下来定义一条机动路径的地形，岛上的地形由一个矩阵给出，如：\n\n```plain\n.**.\n*..*\n*..*\n.**.\n```\n\n那么，一条机动路径的地形序列就是它所经过的地形排成一列，如：\n\n```plain\ns-\\.\n...\\\n...|\n...t\n```\n\n地形序列就是 `.****.`。\n\n每条机动路径的权重就是与之拥有相同地形序列的机动路径数量之和，例如与这条路径拥有相同地形序列的路径有\n\n```plain\n./-t    t...    ...s    s-\\.    ./-s    s...    ...t    t-\\.\n/...    |...    ...|    ...\\    /...    |...    ...|    ...\\\n|...    \\...    .../    ...|    |...    \\...    .../    ...|\ns...    .\\-s    t-/.    ...t    t...    .\\-t    s-/.    ...s\n```\n\n共 $8$ 条，注意回文时正反算两条，以及自己也算一条。\n\n所以这条机动路径的权重是 $8$，同时所有这 $8$ 条机动路径的权重都是 $8$。\n\n现在你需要统计所有的机动路径权重之和。\n\n如果对这种统计方式没有直观的感受，可以查看样例说明。\n", "inputFormat": "第一行两个整数 $m,n$，表示岛的大小。\n\n接下来 $m$ 行，每行 $n$ 个字符，表示岛的地形。", "outputFormat": "仅一个数，表示所有机动路径的权重之和。\n\n由于这个数可能很大，你只需要输出它对 $10^9+9$ 取模的结果。", "hint": "### 样例解释 1\n用中括号括起来的一些数对表示一条机动路径，坐标先行后列：\n\n- 地形序列 `.*`：$[(1, 1), (1, 2)],\\ [(1, 1), (2, 1)],\\ [(2, 2), (2, 1)],\\ [(2, 2), (1, 2)]$，共 $4$ 条，每条权重为 $4$，计 $16$。\n- 地形序列 `*.`：$[(1, 2), (1, 1)],\\ [(2, 1), (1, 1)],\\ [(2, 1), (2, 2)],\\ [(1, 2), (2, 2)]$，共 $4$ 条，每条权重为 $4$，计 $16$。\n- 地形序列 `..`：$[(1, 1), (2, 2)],\\ [(2, 2), (1, 1)]$，共 $2$ 条，每条权重为 $2$，计 $4$。\n- 地形序列 `**`：$[(1, 2), (2, 1)],\\ [(2, 1), (1, 2)]$，共 $2$ 条，每条权重为 $2$，计 $4$。\n- 地形序列 `.*.`：$[(1, 1), (1, 2), (2, 2)],\\ [(1, 1), (2, 1), (2, 2)],\\ [(2, 2), (2, 1), (1, 1)],\\ [(2, 2), (1, 2), (1, 1)]$，共 $4$ 条，每条权重为 $4$，计 $16$。\n- 地形序列 `*.*`：$[(1, 2), (1, 1), (2, 1)],\\ [(2, 1), (1, 1), (1, 2)],\\ [(1, 2), (2, 2), (2, 1)],\\ [(2, 1), (2, 2), (1, 2)]$，共 $4$ 条，每条权重为 $4$，计 $16$。\n\n共计 $16+16+4+4+16+16=72$。\n\n### 样例解释 2\n- 地形序列 `.*`：$7$ 条，每条权重为 $7$，计 $49$。\n- 地形序列 `*.`：$7$ 条，每条权重为 $7$，计 $49$。\n- 地形序列 `..`：$4$ 条，每条权重为 $4$，计 $16$。\n- 地形序列 `**`：$4$ 条，每条权重为 $4$，计 $16$。\n- 地形序列 `..*`：$2$ 条，每条权重为 $2$，计 $4$。\n- 地形序列 `.*.`：$10$ 条，每条权重为 $10$，计 $100$。\n- 地形序列 `.**`：$2$ 条，每条权重为 $2$，计 $4$。\n- 地形序列 `*..`：$2$ 条，每条权重为 $2$，计 $4$。\n- 地形序列 `*.*`：$10$ 条，每条权重为 $10$，计 $100$。\n- 地形序列 `**.`：$2$ 条，每条权重为 $2$，计 $4$。\n- 地形序列 `.*.*`：$6$ 条，每条权重为 $6$，计 $36$。\n- 地形序列 `*.*.`：$6$ 条，每条权重为 $6$，计 $36$。\n\n共计 $49+49+16+16+4+100+4+4+100+4+36+36=418$。\n\n### 数据范围\n\n- 对于 $10\\%$ 的数据，$m\\times n \\le 4$。\n- 对于 $30\\%$ 的数据，$m, n \\le 5$。\n- 对于 $60\\%$ 的数据，$m, n \\le 10$。\n- 另有 $20\\%$ 的数据，所有地形均相同。\n- 对于 $100\\%$ 的数据，$1 \\le m, n \\le 30$，字符集由大小写字母，数字和 `.` `*` 构成。", "locale": "zh-CN"}}}
{"pid": "P3714", "type": "P", "difficulty": 6, "samples": [["5 3 1 4\n-1 -5 -2\n1 2 1\n1 3 1\n2 4 2\n2 5 3", "-1"], ["8 4 3 4\n-7 9 6 1\n1 2 1\n1 3 2\n1 4 1\n2 5 1\n5 6 2\n3 7 1\n3 8 3", "11"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "各省省选", "点分治", "单调队列", "北京", "分治", "深度优先搜索 DFS"], "title": "[BJOI2017] 树的难题", "background": "", "description": "给你一棵 $n$ 个点的无根树。\n\n树上的每条边具有颜色。一共有 $m$ 种颜色，编号为 $1$ 到 $m$，第 $i$ 种颜色的权值为 $c_i$。\n\n对于一条树上的简单路径，路径上经过的所有边按顺序组成一个颜色序列，序列可以划分成若干个相同颜色段。定义路径权值为颜色序列上每个同颜色段的颜色权值之和。\n\n请你计算，经过边数在 $l$ 到 $r$ 之间的所有简单路径中，路径权值的最大值。", "inputFormat": "第一行，四个整数 $n, m, l, r$。\n\n第二行，$m$ 个整数 $c_1, c_2, \\ldots, c_m$，由空格隔开，依次表示每个颜色的权值。\n\n接下来 $n-1$ 行，每行三个整数 $u, v, c$，表示点 $u$ 和点 $v$ 之间有一条颜色为 $c$ 的边。", "outputFormat": "输出一行，一个整数，表示答案。\n", "hint": "### 样例解释 1\n颜色权值均为负，最优路径为 $(1, 2)$ 或 $(1, 3)$。\n\n### 样例解释 2\n最优路径为 $(3, 1, 2, 5, 6)$，其颜色序列为 $(2, 1, 1, 2)$。\n\n### 数据范围\n| 测试点编号 | $n$ | $m$ | 特殊限制 |\n|-|-|-|-|\n| $1$ | $=10^3$ | $\\le n$ | 无特殊限制 |\n| $2$ | $=10^4$ | $=2$ | 无特殊限制 |\n| $3$ | $=10^5$ | $\\le n$ | 所有点的度数不超过 $2$ |\n| $4$ | $=2\\times10^5$ | $\\le n$ | 所有点的度数不超过 $2$ |\n| $5$ | $=10^5$ | $=10$ | $l=1$，$r=n-1$ |\n| $6$ | $=2\\times10^5$ | $\\le n$ | $l=1$，$r=n-1$ |\n| $7$ | $=10^5$ | $=50$ | 无特殊限制 |\n| $8$ | $=10^5$ | $\\le n$ | 无特殊限制 |\n| $9$ | $=2\\times 10^5$ | $=100$ | 无特殊限制 |\n| $10$ | $=2\\times 10^5$ | $\\le n$ | 无特殊限制 |\n\n对于 $100\\%$ 的数据，$1 \\leq n, m \\leq 2 \\times 10^5$，$1 \\leq l \\leq r \\leq n$，$\\mid c_i \\mid \\leq 10^4$。保证树上至少存在一条经过边数在 $l$ 到 $r$ 之间的路径。", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2017] A Hard Problem on Trees", "background": "", "description": "You are given an unrooted tree with $n$ nodes.\n\nEach edge of the tree has a color. There are $m$ colors, numbered from $1$ to $m$, and the weight of the $i$-th color is $c_i$.\n\nFor a simple path on the tree, the edges along the path form a color sequence in order, which can be split into several segments of the same color. Define the path value as the sum of the color weights of each same-color segment in the sequence.\n\nPlease compute the maximum path value among all simple paths whose number of edges is between $l$ and $r$.", "inputFormat": "The first line contains four integers $n, m, l, r$.\n\nThe second line contains $m$ integers $c_1, c_2, \\ldots, c_m$, separated by spaces, representing the weight of each color in order.\n\nThe next $n-1$ lines each contain three integers $u, v, c$, indicating that there is an edge between node $u$ and node $v$ with color $c$.", "outputFormat": "Output one line with a single integer, the answer.", "hint": "Sample explanation 1:\nAll color weights are negative, and the optimal path is $(1, 2)$ or $(1, 3)$.\n\nSample explanation 2:\nThe optimal path is $(3, 1, 2, 5, 6)$, and its color sequence is $(2, 1, 1, 2)$.\n\nConstraints\n| Testpoint ID | $n$ | $m$ | Special constraints |\n|-|-|-|-|\n| $1$ | $=10^3$ | $\\le n$ | None |\n| $2$ | $=10^4$ | $=2$ | None |\n| $3$ | $=10^5$ | $\\le n$ | The degree of every node is at most $2$ |\n| $4$ | $=2\\times10^5$ | $\\le n$ | The degree of every node is at most $2$ |\n| $5$ | $=10^5$ | $=10$ | $l=1$, $r=n-1$ |\n| $6$ | $=2\\times10^5$ | $\\le n$ | $l=1$, $r=n-1$ |\n| $7$ | $=10^5$ | $=50$ | None |\n| $8$ | $=10^5$ | $\\le n$ | None |\n| $9$ | $=2\\times 10^5$ | $=100$ | None |\n| $10$ | $=2\\times 10^5$ | $\\le n$ | None |\n\nFor $100\\%$ of the testdata, $1 \\leq n, m \\leq 2 \\times 10^5$, $1 \\leq l \\leq r \\leq n$, and $\\lvert c_i \\rvert \\leq 10^4$. It is guaranteed that there exists at least one path whose number of edges is between $l$ and $r$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2017] 树的难题", "background": "", "description": "给你一棵 $n$ 个点的无根树。\n\n树上的每条边具有颜色。一共有 $m$ 种颜色，编号为 $1$ 到 $m$，第 $i$ 种颜色的权值为 $c_i$。\n\n对于一条树上的简单路径，路径上经过的所有边按顺序组成一个颜色序列，序列可以划分成若干个相同颜色段。定义路径权值为颜色序列上每个同颜色段的颜色权值之和。\n\n请你计算，经过边数在 $l$ 到 $r$ 之间的所有简单路径中，路径权值的最大值。", "inputFormat": "第一行，四个整数 $n, m, l, r$。\n\n第二行，$m$ 个整数 $c_1, c_2, \\ldots, c_m$，由空格隔开，依次表示每个颜色的权值。\n\n接下来 $n-1$ 行，每行三个整数 $u, v, c$，表示点 $u$ 和点 $v$ 之间有一条颜色为 $c$ 的边。", "outputFormat": "输出一行，一个整数，表示答案。\n", "hint": "### 样例解释 1\n颜色权值均为负，最优路径为 $(1, 2)$ 或 $(1, 3)$。\n\n### 样例解释 2\n最优路径为 $(3, 1, 2, 5, 6)$，其颜色序列为 $(2, 1, 1, 2)$。\n\n### 数据范围\n| 测试点编号 | $n$ | $m$ | 特殊限制 |\n|-|-|-|-|\n| $1$ | $=10^3$ | $\\le n$ | 无特殊限制 |\n| $2$ | $=10^4$ | $=2$ | 无特殊限制 |\n| $3$ | $=10^5$ | $\\le n$ | 所有点的度数不超过 $2$ |\n| $4$ | $=2\\times10^5$ | $\\le n$ | 所有点的度数不超过 $2$ |\n| $5$ | $=10^5$ | $=10$ | $l=1$，$r=n-1$ |\n| $6$ | $=2\\times10^5$ | $\\le n$ | $l=1$，$r=n-1$ |\n| $7$ | $=10^5$ | $=50$ | 无特殊限制 |\n| $8$ | $=10^5$ | $\\le n$ | 无特殊限制 |\n| $9$ | $=2\\times 10^5$ | $=100$ | 无特殊限制 |\n| $10$ | $=2\\times 10^5$ | $\\le n$ | 无特殊限制 |\n\n对于 $100\\%$ 的数据，$1 \\leq n, m \\leq 2 \\times 10^5$，$1 \\leq l \\leq r \\leq n$，$\\mid c_i \\mid \\leq 10^4$。保证树上至少存在一条经过边数在 $l$ 到 $r$ 之间的路径。", "locale": "zh-CN"}}}
{"pid": "P3715", "type": "P", "difficulty": 6, "samples": [["4 2 10\nboom\noo\nooh\nbang\nob\nmo", "14"], ["3 1 3\na\nab\naba\naaa", "3"], ["3 1 14\nban\nan\nanalysis\nbanana", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP", "2017", "各省省选", "北京", "矩阵加速", "矩阵乘法", "AC 自动机", "构造"], "title": "[BJOI2017] 魔法咒语", "background": "", "description": "Chandra 是一个魔法天才。\n\n从一岁时接受火之教会洗礼之后，Chandra 就显示出对火元素无与伦比的亲和力，轻而易举地学会种种晦涩难解的法术。这也多亏 Chandra 有着常人难以企及的语言天赋，让她能轻松流利地说出咒语中那些极其拗口的魔法词汇。\n\n直到十四岁，开始学习威力强大的禁咒法术时，Chandra 才遇到了障碍。\n\n根据火之魔法规则，禁咒的构成单位是 $N$ 个基本词汇。施法时只要凝聚精神力，说出一段用这些词语组成的长度恰好等于 $L$ 的语言，就能释放威力超乎想象的火法术。过去的魔法师们总结了几种表达起来最连贯的组合方式，方便施法者以最快语速完成法术。\n\n但具有魔法和语言双重天才的 Chandra 不满足于这几种流传下来的禁咒，因为她可以毫无困难地说出普通人几乎不可能表达的禁咒语句。然而，在实际施法时，Chandra 发现有些自创禁咒念出后不但没有预期效果，反而会使自己的精神力迅速枯竭，十分难受。\n\n这个问题令 Chandra 万分不解。她大量阅读典籍，到处走访魔法学者，并且不顾精神折磨一次又一次尝试新咒语，希望找出问题的答案。\n\n很多年过去了，在一次远古遗迹探险中，Chandra 意外闯进了火之神艾利克斯的不知名神殿。根据岩土特征分析，神殿应该有上万年的历史，这是极其罕见的。Chandra 小心翼翼地四处探索，沿着魔力流动来到一间密室。她看见密室中央悬浮着一本书籍。在魔法保护下书籍状况完好。精通上古语言的 Chandra 读过此书，终于解开了多年的困惑。\n\n\n禁咒法术之所以威力强大，是因为咒语借用了火之神艾利克斯的神力。这本书里记载了艾利克斯生平忌讳的 $M$ 个词语，比如情敌的名字、讨厌的植物等等。使用禁咒法术时，如果语言中含有任何忌讳词语，就会触怒神力而失效，施法者也一并遭受惩罚。\n\n例如，若 `banana` 是唯一的忌讳词语，`an`、`ban`、`analysis` 是基本词汇，禁咒长度须是 $11$，则 `bananalysis` 是无效法术，`analysisban`、`anbanbanban` 是两个有效法术。注意：一个基本词汇在禁咒法术中可以出现零次、一次或多次；只要组成方式不同就认为是不同的禁咒法术，即使书写形式相同。\n\n谜题破解，Chandra 心情大好。她决定计算一共有多少种有效的禁咒法术。\n\n由于答案可能很大，你只需要输出答案模 $10 ^ 9 + 7$ 的结果。\n", "inputFormat": "第一行，三个正整数 $N, M, L$。\n\n接下来 $N$ 行，每行一个只含小写英文字母的字符串，表示一个基本词汇。\n\n接下来 $M$ 行，每行一个只含小写英文字母的字符串，表示一个忌讳词语。\n", "outputFormat": "仅一行，一个整数，表示答案（模 $10^9+7$）。\n", "hint": "【样例解释 1】\n\n有效的禁咒法术共有 $14$ 种：`boom/bang/oo`，`oo/oo/oo/oo/oo`，`oo/oo/ooh/ooh`，`oo/ooh/oo/ooh`，`oo/ooh/ooh/oo`，`ooh/oo/oo/ooh`，`ooh/oo/ooh/oo`，`\nooh/ooh/boom`，`ooh/ooh/oo/oo`，`ooh/ooh/bang`，`ooh/bang/ooh`，`bang/oo/oo/oo`，`bang/ooh/ooh`，`bang/bang/oo`。\n\n【样例解释 2】\n\n有效的禁咒法术有 `a/ab`，`ab/a`，`aba` 共三种。注意，`ab/a` 和 `aba` 算成两种不同的禁咒法术。\n\n【数据规模与约定】\n\n本题一共有 $10$ 个测试点。\n\n下表是每个测试点的数据规模和约定：\n\n ![](https://cdn.luogu.com.cn/upload/pic/5191.png) \n\n对于 $100\\%$ 的数据，$1 \\le N, M \\le 50，1 \\le L \\le 10^8$，基本词汇的长度之和不超过 $100$，忌讳词语的长度之和不超过 $100$。保证基本词汇不重复，忌讳词语不重复。\n", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2017] Magic Incantations", "background": "", "description": "Chandra is a prodigy of magic.\n\nSince receiving the baptism of the Church of Fire at the age of one, Chandra has shown unparalleled affinity for the fire element and easily mastered various obscure spells. This also owes to Chandra’s extraordinary talent for languages, which lets her fluently pronounce the very awkward magical words in incantations.\n\nShe did not encounter obstacles until the age of fourteen, when she began studying powerful forbidden spells.\n\nAccording to the rules of fire magic, a forbidden spell is composed of $N$ basic words. During casting, as long as she concentrates and speaks an utterance of length exactly $L$ formed by these words, she can unleash a fire spell of unimaginable power. Magicians in the past summarized several of the most fluent composition methods to help the caster complete the spell at the fastest speaking speed.\n\nHowever, Chandra, a genius in both magic and language, was not satisfied with those handed‑down forbidden spells, because she could effortlessly speak forbidden utterances that ordinary people could hardly pronounce. Yet in actual casting, Chandra found that some of her self‑created forbidden spells not only failed to produce the expected effect after being chanted, but also rapidly drained her mental strength, causing great discomfort.\n\nThis problem puzzled Chandra greatly. She read many classics, consulted magic scholars everywhere, and, despite the mental torment, tried new incantations again and again, hoping to find the answer.\n\nMany years later, during an expedition to ancient ruins, Chandra accidentally entered an unknown shrine of the fire god Ailikesi (pinyin). Based on the geomorphic features, the shrine should be tens of thousands of years old, which is extremely rare. Chandra carefully explored, followed the flow of magic, and came to a secret chamber. She saw a book floating at the center of the chamber. Protected by magic, the book was in perfect condition. Proficient in ancient languages, Chandra read it and finally solved her years‑long confusion.\n\nForbidden spells are so powerful because the incantation borrows the divine power of the fire god Ailikesi. This book recorded $M$ taboo words that Ailikesi hated in life, such as the name of a rival in love, a disliked plant, and so on. When using a forbidden spell, if the utterance contains any taboo word, the divine power will be angered and the spell will fail, and the caster will suffer punishment as well.\n\nFor example, if `banana` is the only taboo word, `an`, `ban`, `analysis` are the basic words, and the forbidden spell length must be $11$, then `bananalysis` is an invalid spell, while `analysisban` and `anbanbanban` are two valid spells. Note: a basic word can appear zero, one, or multiple times in a forbidden spell; as long as the composition (sequence of basic words) is different, they are considered different forbidden spells, even if the written string is the same.\n\nWith the puzzle solved, Chandra was delighted. She decided to compute how many valid forbidden spells there are in total.\n\nSince the answer can be large, you only need to output the result modulo $10 ^ 9 + 7$.", "inputFormat": "The first line contains three positive integers $N, M, L$.\n\nThe next $N$ lines each contain a string consisting only of lowercase English letters, representing a basic word.\n\nThe next $M$ lines each contain a string consisting only of lowercase English letters, representing a taboo word.", "outputFormat": "A single line containing one integer, the answer (mod $10^9+7$).", "hint": "[Sample Explanation 1]\n\nThere are $14$ valid forbidden spells: `boom/bang/oo`, `oo/oo/oo/oo/oo`, `oo/oo/ooh/ooh`, `oo/ooh/oo/ooh`, `oo/ooh/ooh/oo`, `ooh/oo/oo/ooh`, `ooh/oo/ooh/oo`, `ooh/ooh/boom`, `ooh/ooh/oo/oo`, `ooh/ooh/bang`, `ooh/bang/ooh`, `bang/oo/oo/oo`, `bang/ooh/ooh`, `bang/bang/oo`.\n\n[Sample Explanation 2]\n\nThe valid forbidden spells are `a/ab`, `ab/a`, and `aba`, three in total. Note that `ab/a` and `aba` count as two different forbidden spells.\n\n[Constraints and Agreements]\n\nThis problem has $10$ test points.\n\nThe following table shows the data scale and agreements for each test point:\n\n ![](https://cdn.luogu.com.cn/upload/pic/5191.png) \n\nFor $100\\%$ of the testdata, $1 \\le N, M \\le 50$, $1 \\le L \\le 10^8$, the sum of lengths of the basic words does not exceed $100$, and the sum of lengths of the taboo words does not exceed $100$. It is guaranteed that the basic words are distinct and the taboo words are distinct.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2017] 魔法咒语", "background": "", "description": "Chandra 是一个魔法天才。\n\n从一岁时接受火之教会洗礼之后，Chandra 就显示出对火元素无与伦比的亲和力，轻而易举地学会种种晦涩难解的法术。这也多亏 Chandra 有着常人难以企及的语言天赋，让她能轻松流利地说出咒语中那些极其拗口的魔法词汇。\n\n直到十四岁，开始学习威力强大的禁咒法术时，Chandra 才遇到了障碍。\n\n根据火之魔法规则，禁咒的构成单位是 $N$ 个基本词汇。施法时只要凝聚精神力，说出一段用这些词语组成的长度恰好等于 $L$ 的语言，就能释放威力超乎想象的火法术。过去的魔法师们总结了几种表达起来最连贯的组合方式，方便施法者以最快语速完成法术。\n\n但具有魔法和语言双重天才的 Chandra 不满足于这几种流传下来的禁咒，因为她可以毫无困难地说出普通人几乎不可能表达的禁咒语句。然而，在实际施法时，Chandra 发现有些自创禁咒念出后不但没有预期效果，反而会使自己的精神力迅速枯竭，十分难受。\n\n这个问题令 Chandra 万分不解。她大量阅读典籍，到处走访魔法学者，并且不顾精神折磨一次又一次尝试新咒语，希望找出问题的答案。\n\n很多年过去了，在一次远古遗迹探险中，Chandra 意外闯进了火之神艾利克斯的不知名神殿。根据岩土特征分析，神殿应该有上万年的历史，这是极其罕见的。Chandra 小心翼翼地四处探索，沿着魔力流动来到一间密室。她看见密室中央悬浮着一本书籍。在魔法保护下书籍状况完好。精通上古语言的 Chandra 读过此书，终于解开了多年的困惑。\n\n\n禁咒法术之所以威力强大，是因为咒语借用了火之神艾利克斯的神力。这本书里记载了艾利克斯生平忌讳的 $M$ 个词语，比如情敌的名字、讨厌的植物等等。使用禁咒法术时，如果语言中含有任何忌讳词语，就会触怒神力而失效，施法者也一并遭受惩罚。\n\n例如，若 `banana` 是唯一的忌讳词语，`an`、`ban`、`analysis` 是基本词汇，禁咒长度须是 $11$，则 `bananalysis` 是无效法术，`analysisban`、`anbanbanban` 是两个有效法术。注意：一个基本词汇在禁咒法术中可以出现零次、一次或多次；只要组成方式不同就认为是不同的禁咒法术，即使书写形式相同。\n\n谜题破解，Chandra 心情大好。她决定计算一共有多少种有效的禁咒法术。\n\n由于答案可能很大，你只需要输出答案模 $10 ^ 9 + 7$ 的结果。\n", "inputFormat": "第一行，三个正整数 $N, M, L$。\n\n接下来 $N$ 行，每行一个只含小写英文字母的字符串，表示一个基本词汇。\n\n接下来 $M$ 行，每行一个只含小写英文字母的字符串，表示一个忌讳词语。\n", "outputFormat": "仅一行，一个整数，表示答案（模 $10^9+7$）。\n", "hint": "【样例解释 1】\n\n有效的禁咒法术共有 $14$ 种：`boom/bang/oo`，`oo/oo/oo/oo/oo`，`oo/oo/ooh/ooh`，`oo/ooh/oo/ooh`，`oo/ooh/ooh/oo`，`ooh/oo/oo/ooh`，`ooh/oo/ooh/oo`，`\nooh/ooh/boom`，`ooh/ooh/oo/oo`，`ooh/ooh/bang`，`ooh/bang/ooh`，`bang/oo/oo/oo`，`bang/ooh/ooh`，`bang/bang/oo`。\n\n【样例解释 2】\n\n有效的禁咒法术有 `a/ab`，`ab/a`，`aba` 共三种。注意，`ab/a` 和 `aba` 算成两种不同的禁咒法术。\n\n【数据规模与约定】\n\n本题一共有 $10$ 个测试点。\n\n下表是每个测试点的数据规模和约定：\n\n ![](https://cdn.luogu.com.cn/upload/pic/5191.png) \n\n对于 $100\\%$ 的数据，$1 \\le N, M \\le 50，1 \\le L \\le 10^8$，基本词汇的长度之和不超过 $100$，忌讳词语的长度之和不超过 $100$。保证基本词汇不重复，忌讳词语不重复。\n", "locale": "zh-CN"}}}
{"pid": "P3716", "type": "P", "difficulty": 5, "samples": [["2\n1 1\n5 5\n1 3 3 3\n6 2 8 4", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2000", "枚举", "广度优先搜索 BFS", "最短路", "CTSC/CTS"], "title": "[CTSC2000] 冰原探险", "background": "", "description": "传说中，南极有一片广阔的冰原，在冰原下藏有史前文明的遗址。整个冰原被横竖划分成了很多个大小相等的方格。在这个冰原上有 $N$ 个大小不等的矩形冰山，这些巨大的冰山有着和南极一样古老的历史。\n\n每个矩形冰山至少占据一个方格，且其必定完整地占据方格。冰山和冰山之间不会重叠，也不会有边或点相连。以下两种情况均是不可能出现的：\n\n![](https://cdn.luogu.com.cn/upload/pic/5096.png)\n\n$\\text{ACM}$ 探险队在经过多年准备之后决定在这个冰原上寻找遗址。根据他们掌握的资料，在这个冰原上一个大小为一格的深洞中，藏有一个由史前人类制作的开关。而唯一可以打开这个开关的是一个占据接近一格的可移动的小冰块。显然，在南极是不可能有这样小的独立冰块的，所以这块冰块也一定是史前文明的产物。他们在想办法把这个冰块推到洞里去，这样就可以打开一条通往冰原底部的通道，发掘史前文明的秘密。冰块的起始位置与深洞的位置均不和任何冰山相邻。\n\n这个冰原上的冰面和冰山都是完全光滑的，轻轻的推动冰块就可以使这个冰块向前滑行，直到撞到一座冰山就在它的边上停下来。冰块可以穿过冰面上所有没有冰山的区域，也可以从两座冰山之间穿过（见下图）。冰块只能沿网格方向推动。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/5097.png) \n\n请你帮助他们以最少的推动次数将冰块推入深洞中。\n", "inputFormat": "输入文件第一行为冰山的个数 $N$ ，第二行为冰块开始所在的方格坐标 $X_{1}$ , $Y_{1}$ ，第三行为深洞所在的方格坐标 $X_{2}, Y_{2}$ ，以下 $N$ 行每行有四个数，分别是每个冰山所占的格子左上角和右下角坐标 $X_{i_{1}}, Y_{i_{1}}, X_{i_{2}}, Y_{i_{2}}$ ", "outputFormat": "输出文件包含一个整数，为最少推动冰块的次数。如果无法将冰块推入深洞中，则输出 $0$ 。", "hint": "$1 \\leq N \\leq 4000$\n\n样例解释：移动方案如图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y6sx7ya7.png)", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2000] Icefield Exploration", "background": "", "description": "Legend says there is a vast icefield in Antarctica, under which lie ruins of a prehistoric civilization. The entire icefield is divided into many equal-sized grid cells. On this icefield there are $N$ rectangular icebergs of different sizes, each as ancient as Antarctica itself.\n\nEach rectangular iceberg occupies at least one cell and always fully occupies cells. Icebergs neither overlap nor touch each other at edges or points. The following two cases cannot occur:\n\n![](https://cdn.luogu.com.cn/upload/pic/5096.png)\n\nAfter years of preparation, the $\\text{ACM}$ exploration team decided to search for the ruins on this icefield. According to their information, there is a one-cell-deep pit on the icefield that hides a switch made by prehistoric humans. The only thing that can activate this switch is a movable small ice block that is almost one cell in size. Obviously, such a small independent ice block could not naturally exist in Antarctica, so it must also be a product of the prehistoric civilization. They want to push this block into the pit to open a passage to the bottom of the icefield and excavate the secrets of the prehistoric civilization. Neither the starting position of the ice block nor the position of the deep pit is adjacent to any iceberg.\n\nBoth the ice surface and the icebergs are perfectly smooth. A gentle push makes the ice block slide forward until it hits an iceberg and stops next to its side. The ice block can slide through any area of the ice surface without icebergs and can pass between two icebergs (see the figure below). The ice block can only be pushed along the grid directions.\n\n![](https://cdn.luogu.com.cn/upload/pic/5097.png)\n\nPlease help them push the ice block into the deep pit with the minimum number of pushes.", "inputFormat": "The first line contains the number of icebergs $N$.  \nThe second line contains the coordinates of the starting cell of the ice block, $X_{1}, Y_{1}$.  \nThe third line contains the coordinates of the deep pit, $X_{2}, Y_{2}$.  \nEach of the next $N$ lines contains four integers, the coordinates of the upper-left and lower-right cells of an iceberg, $X_{i_{1}}, Y_{i_{1}}, X_{i_{2}}, Y_{i_{2}}$.", "outputFormat": "Output a single integer: the minimum number of pushes. If it is impossible to push the ice block into the deep pit, output 0.", "hint": "$1 \\leq N \\leq 4000$.\n\nSample explanation: The moving plan is shown in the figure.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y6sx7ya7.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2000] 冰原探险", "background": "", "description": "传说中，南极有一片广阔的冰原，在冰原下藏有史前文明的遗址。整个冰原被横竖划分成了很多个大小相等的方格。在这个冰原上有 $N$ 个大小不等的矩形冰山，这些巨大的冰山有着和南极一样古老的历史。\n\n每个矩形冰山至少占据一个方格，且其必定完整地占据方格。冰山和冰山之间不会重叠，也不会有边或点相连。以下两种情况均是不可能出现的：\n\n![](https://cdn.luogu.com.cn/upload/pic/5096.png)\n\n$\\text{ACM}$ 探险队在经过多年准备之后决定在这个冰原上寻找遗址。根据他们掌握的资料，在这个冰原上一个大小为一格的深洞中，藏有一个由史前人类制作的开关。而唯一可以打开这个开关的是一个占据接近一格的可移动的小冰块。显然，在南极是不可能有这样小的独立冰块的，所以这块冰块也一定是史前文明的产物。他们在想办法把这个冰块推到洞里去，这样就可以打开一条通往冰原底部的通道，发掘史前文明的秘密。冰块的起始位置与深洞的位置均不和任何冰山相邻。\n\n这个冰原上的冰面和冰山都是完全光滑的，轻轻的推动冰块就可以使这个冰块向前滑行，直到撞到一座冰山就在它的边上停下来。冰块可以穿过冰面上所有没有冰山的区域，也可以从两座冰山之间穿过（见下图）。冰块只能沿网格方向推动。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/5097.png) \n\n请你帮助他们以最少的推动次数将冰块推入深洞中。\n", "inputFormat": "输入文件第一行为冰山的个数 $N$ ，第二行为冰块开始所在的方格坐标 $X_{1}$ , $Y_{1}$ ，第三行为深洞所在的方格坐标 $X_{2}, Y_{2}$ ，以下 $N$ 行每行有四个数，分别是每个冰山所占的格子左上角和右下角坐标 $X_{i_{1}}, Y_{i_{1}}, X_{i_{2}}, Y_{i_{2}}$ ", "outputFormat": "输出文件包含一个整数，为最少推动冰块的次数。如果无法将冰块推入深洞中，则输出 $0$ 。", "hint": "$1 \\leq N \\leq 4000$\n\n样例解释：移动方案如图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y6sx7ya7.png)", "locale": "zh-CN"}}}
{"pid": "P3717", "type": "P", "difficulty": 1, "samples": [["5 2 1\n3 3\n4 2", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "2017", "安徽", "枚举", "差分"], "title": "[AHOI2017初中组] cover", "background": "以下为不影响题意的简化版题目。", "description": "一个 $n\\times n$ 的网格图（标号由 $1$ 开始）上有 $m$ 个探测器，每个探测器有个探测半径 $r$ ，问这 $n\\times n$ 个点中有多少个点能被探测到。", "inputFormat": "第一行 $3$ 个整数 $n,m,r$。\n\n接下来 $m$ 行，每行两个整数 $x,y$表示第 $i$ 个探测器的坐标。", "outputFormat": "能被探测到的点的个数。", "hint": "$1\\le n,m\\le 100$", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2017 Middle School Division] cover", "background": "The following is a simplified version that does not change the meaning of the problem.", "description": "On an $n\\times n$ grid (indexed from $1$), there are $m$ detectors, each with a detection radius $r$. Among these $n\\times n$ points, how many points can be detected.", "inputFormat": "The first line contains $3$ integers $n,m,r$.\nEach of the next $m$ lines contains two integers $x,y$, representing the coordinates of the $i$-th detector.", "outputFormat": "Output the number of points that can be detected.", "hint": "Constraints: $1\\le n,m\\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2017初中组] cover", "background": "以下为不影响题意的简化版题目。", "description": "一个 $n\\times n$ 的网格图（标号由 $1$ 开始）上有 $m$ 个探测器，每个探测器有个探测半径 $r$ ，问这 $n\\times n$ 个点中有多少个点能被探测到。", "inputFormat": "第一行 $3$ 个整数 $n,m,r$。\n\n接下来 $m$ 行，每行两个整数 $x,y$表示第 $i$ 个探测器的坐标。", "outputFormat": "能被探测到的点的个数。", "hint": "$1\\le n,m\\le 100$", "locale": "zh-CN"}}}
{"pid": "P3718", "type": "P", "difficulty": 4, "samples": [["8 1\nNNNFFNNN", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "贪心", "2017", "二分", "安徽", "枚举", "队列"], "title": "[AHOI2017初中组] alter", "background": "", "description": "有 $n$ 盏灯排成一列，其中有些灯开着，有些灯关着。小可可希望灯是错落有致的，他定义一列灯的状态的不优美度为这些灯中最长的连续的开着或关着的灯的个数。小可可最多可以按开关 $k$ 次，每次操作可以使该盏灯的状态取反：原来开着的就关着，反之开着。现在给出这些灯的状态，求操作后最小的不优美度。", "inputFormat": "第一行两个整数 $n,k$。\n\n第二行是一个长度为 $n$ 的字符串，其中有两种字符：`N` 和 `F`。其中 `N` 表示该灯开着，`F` 表示该灯关着。", "outputFormat": "最小的不优美度。", "hint": "$30\\%$ 的数据：$1\\le k \\le n\\le20$；\n\n$50\\%$ 的数据：$1\\le k \\le n\\le300$；\n\n另有 $15\\%$ 的数据：$1\\le k \\le n\\le 10^5$，字符串为全 `N` 或全 `F`；\n\n$100\\%$ 的数据：$1\\le k \\le n\\le 10^5$。\n\n本题已经加入 hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2017 Middle School Division] alter", "background": "", "description": "There are $n$ lamps in a row. Some lamps are on, and some are off. Keke wants the lamps to be alternating. He defines the ugliness of a row of lamps as the number of lamps in the longest consecutive segment that are all on or all off. Keke can press switches at most $k$ times. Each operation toggles the state of one lamp: if it was on, it becomes off; otherwise, it becomes on. Given the current states of the lamps, find the minimal ugliness after the operations.", "inputFormat": "The first line contains two integers $n, k$.\n\nThe second line is a string of length $n$ consisting of two characters: `N` and `F`. Here, `N` means the lamp is on, and `F` means the lamp is off.", "outputFormat": "Output the minimal ugliness.", "hint": "$30\\%$ of the testdata: $1\\le k \\le n\\le 20$.\n\n$50\\%$ of the testdata: $1\\le k \\le n\\le 300$.\n\nAnother $15\\%$ of the testdata: $1\\le k \\le n\\le 10^5$, and the string is all `N` or all `F`.\n\n$100\\%$ of the testdata: $1\\le k \\le n\\le 10^5$.\n\nThis problem includes hack testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2017初中组] alter", "background": "", "description": "有 $n$ 盏灯排成一列，其中有些灯开着，有些灯关着。小可可希望灯是错落有致的，他定义一列灯的状态的不优美度为这些灯中最长的连续的开着或关着的灯的个数。小可可最多可以按开关 $k$ 次，每次操作可以使该盏灯的状态取反：原来开着的就关着，反之开着。现在给出这些灯的状态，求操作后最小的不优美度。", "inputFormat": "第一行两个整数 $n,k$。\n\n第二行是一个长度为 $n$ 的字符串，其中有两种字符：`N` 和 `F`。其中 `N` 表示该灯开着，`F` 表示该灯关着。", "outputFormat": "最小的不优美度。", "hint": "$30\\%$ 的数据：$1\\le k \\le n\\le20$；\n\n$50\\%$ 的数据：$1\\le k \\le n\\le300$；\n\n另有 $15\\%$ 的数据：$1\\le k \\le n\\le 10^5$，字符串为全 `N` 或全 `F`；\n\n$100\\%$ 的数据：$1\\le k \\le n\\le 10^5$。\n\n本题已经加入 hack 数据。", "locale": "zh-CN"}}}
{"pid": "P3719", "type": "P", "difficulty": 4, "samples": [["(aaa)aa|aa|(a(aa)a)", "5\n"], ["((a|aaa)|aa)|a", "3"], ["(a(aa|aaa)a|(a|aa))aa", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "2017", "递归", "安徽", "栈"], "title": "[AHOI2017初中组] rexp", "background": "为了解决形形色色的字符串匹配问题，正则表达式是一个强有力的工具。正则表达式通过定义一套符号体系，能够表示出需要查找的字符串所具有的性质。如 `a|aa` 能匹配 `a` 或 `aa`，`(a|b)c` 能匹配 `ac` 或 `bc`。\n", "description": "完整的正则表达式过于复杂，在这里我们只考虑由 `(`、`)`、`|` 和 `a` 组成的正则表达式。运算遵循下列法则：\n\n1. 有括号时，我们总是先算括号内的部分；\n\n2. 当两个字符串（或由括号定义的子串）间没有符号时，我们总把它们连起来作为一个整体；\n\n3. `|` 是或连接符，表示两边的字符串任取其一，若同一层里有多个或连接符，可以看作在这些或连接符所分开的若干字符串里任取其一。\n\n例如，`(aaa)aa|aa|(a(aa)a)`、`(aaaaa)|(aa)|aaaa` 和 `aaaaa|aaaa|aa` 是等价的，它们都能匹配长度为 $2,4$ 或 $5$ 的全 `a` 字符串。\n\n下面给定一个简化正则表达式，试编程计算它最多能匹配多长的全 `a` 字符串。", "inputFormat": "输入一行一个合法的简化正则表达式。\n", "outputFormat": "一行一个整数，表示能匹配的最长全 `a` 字符串长度。", "hint": "**【数据范围】**\n\n对于 $20\\%$ 数据，表达式长度不超过 $100$，且不存在括号。\n\n对于 $40\\%$ 数据，表达式长度不超过 $100$。\n\n对于 $70\\%$ 数据，表达式长度不超过 $2 \\times 10^3$。\n\n对于 $100\\%$ 的数据，表达式长度不超过 $10^5$。\n\n保证表达式合法（即 `|` 两端和括号内运算结果均非空字符串）。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2017 Middle School Division] rexp", "background": "To solve various string matching problems, regular expressions are a powerful tool. By defining a system of symbols, regular expressions can describe the properties of the strings to be found. For example, `a|aa` can match `a` or `aa`, and `(a|b)c` can match `ac` or `bc`.", "description": "Full regular expressions are too complex. Here, we only consider regular expressions composed of `(`, `)`, `|`, and `a`. The operations follow the rules below:\n\n1. When there are parentheses, we always evaluate the part inside the parentheses first.\n2. When two strings (or substrings defined by parentheses) have no symbol between them, we concatenate them as a whole.\n3. `|` is the OR operator, meaning you can choose either string on its two sides. If there are multiple OR operators at the same level, it can be viewed as choosing any one of the strings separated by these OR operators.\n\nFor example, `(aaa)aa|aa|(a(aa)a)`, `(aaaaa)|(aa)|aaaa`, and `aaaaa|aaaa|aa` are equivalent. They all match all-`a` strings of length $2,4$ or $5$.\n\nGiven a simplified regular expression, write a program to compute the maximum length of an all-`a` string it can match.", "inputFormat": "One line containing a valid simplified regular expression.", "outputFormat": "One line containing an integer, which is the maximum length of an all-`a` string that can be matched.", "hint": "[Constraints]\n\nFor $20\\%$ of the testdata, the expression length does not exceed $100$, and there are no parentheses.\n\nFor $40\\%$ of the testdata, the expression length does not exceed $100$.\n\nFor $70\\%$ of the testdata, the expression length does not exceed $2 \\times 10^3$.\n\nFor $100\\%$ of the testdata, the expression length does not exceed $10^5$.\n\nThe expression is guaranteed to be valid (i.e., the results on both sides of `|` and inside parentheses are non-empty strings).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2017初中组] rexp", "background": "为了解决形形色色的字符串匹配问题，正则表达式是一个强有力的工具。正则表达式通过定义一套符号体系，能够表示出需要查找的字符串所具有的性质。如 `a|aa` 能匹配 `a` 或 `aa`，`(a|b)c` 能匹配 `ac` 或 `bc`。\n", "description": "完整的正则表达式过于复杂，在这里我们只考虑由 `(`、`)`、`|` 和 `a` 组成的正则表达式。运算遵循下列法则：\n\n1. 有括号时，我们总是先算括号内的部分；\n\n2. 当两个字符串（或由括号定义的子串）间没有符号时，我们总把它们连起来作为一个整体；\n\n3. `|` 是或连接符，表示两边的字符串任取其一，若同一层里有多个或连接符，可以看作在这些或连接符所分开的若干字符串里任取其一。\n\n例如，`(aaa)aa|aa|(a(aa)a)`、`(aaaaa)|(aa)|aaaa` 和 `aaaaa|aaaa|aa` 是等价的，它们都能匹配长度为 $2,4$ 或 $5$ 的全 `a` 字符串。\n\n下面给定一个简化正则表达式，试编程计算它最多能匹配多长的全 `a` 字符串。", "inputFormat": "输入一行一个合法的简化正则表达式。\n", "outputFormat": "一行一个整数，表示能匹配的最长全 `a` 字符串长度。", "hint": "**【数据范围】**\n\n对于 $20\\%$ 数据，表达式长度不超过 $100$，且不存在括号。\n\n对于 $40\\%$ 数据，表达式长度不超过 $100$。\n\n对于 $70\\%$ 数据，表达式长度不超过 $2 \\times 10^3$。\n\n对于 $100\\%$ 的数据，表达式长度不超过 $10^5$。\n\n保证表达式合法（即 `|` 两端和括号内运算结果均非空字符串）。", "locale": "zh-CN"}}}
{"pid": "P3720", "type": "P", "difficulty": 5, "samples": [["5 7 \n3 4 7 1\n1 3 2 20\n1 4 17 18\n4 5 25 3\n1 2 10 1\n3 5 4 14\n2 4 6 5", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "安徽", "最短路"], "title": "[AHOI2017初中组] guide", "background": null, "description": "农场主 John 最近在网上买了一辆新车，在购买汽车配件时，John 不小心点了两次“提交”按钮。导致汽车上安装了两套 GPS 系统，更糟糕的是 John 在使用 GPS 导航时，两套系统常常给出不同的路线。从地图上看，John 居住的地区有 $N$（$2 \\le N \\le 10^5$）个十字路口和 $M$（$1 \\le M \\le 5 \\times 10^5$）条限定通行方向的道路。第 $i$ 条道路连接路口 $A_i$（$1 \\le A_i \\le N$）和 $B_i$（$1 \\le B_i \\le N$），两个路口之间可能连接有多条道路。允许双向通⾏的道路是将两条单向通⾏的道路隔开所形成的。\n\n\nJohn 的家在路口 $1$ 位置，农场在路口 $N$ 的位置。John 可以沿着⼀系列单向道路从家驾车到农场。所有 GPS 系统的底层地图信息都是⼀样的，区别仅在于对每一条道路的通⾏时间计算不同。对于第 $i$ 条道路第一套 GPS 系统计算通行时间为 $P_i$ 个单位时间，而第二套 GPS 系统则给出 $Q_i$ 个单位时间。（所有道路的通行时间都是范围在 $1$ 到 $10^5$ 之间的整数）John 想要驾车从家到农场。可是，一路上 GPS 系统总是不厌其烦的提醒 John（请从路口 $X$ 开往路口 $Y$），这是由于 John 选取了某套 GPS 系统建议的路径，而另一套 GPS 系统则认为这不是从路口 $X$ 到农场的最短路径。我们称之为 GPS 系统的抱怨。\n\n\n请你计算一下如果 John 选择合适的路径到达农场能听到的最少 GPS 系统的抱怨数。如果 John 经过某条道路两套 GPS 系统都发出抱怨，则抱怨总数加 $2$。", "inputFormat": "第一行，两个整数 $N$ 和 $M$。\n\n接下来 $M$ 行，其中第 $i$ 行描述了道路 $i$ 的信息：$A_i,B_i,P_i,Q_i$。", "outputFormat": "一个整数，表示 John 一路上能听到的最小抱怨数。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2017 Middle School] guide", "background": "", "description": "Farmer John recently bought a new car online. While ordering accessories, he accidentally clicked the “Submit” button twice, so the car was fitted with two GPS systems. Even worse, the two systems often suggest different routes during navigation. The region where John lives has $N$ ($2 \\le N \\le 10^5$) intersections and $M$ ($1 \\le M \\le 5 \\times 10^5$) directed roads. The $i$-th road goes from intersection $A_i$ ($1 \\le A_i \\le N$) to $B_i$ ($1 \\le B_i \\le N$). There may be multiple roads between the same pair of intersections. A bidirectional road can be modeled as two directed roads in opposite directions.\n\nJohn’s home is at intersection $1$, and the farm is at intersection $N$. John can drive from home to the farm along a sequence of directed roads. Both GPS systems share the same base map; the only difference is how they compute travel times for each road. For the $i$-th road, the first GPS estimates a travel time of $P_i$ units, and the second GPS estimates $Q_i$ units. All road travel times are integers in the range $1$ to $10^5$.\n\nJohn wants to drive from home to the farm. Along the way, the GPS systems keep nagging him with prompts like “Please go from intersection $X$ to intersection $Y$.” This happens because John follows the route recommended by one GPS, while the other GPS considers this not to be a shortest path from $X$ to the farm. We call each such event a complaint from a GPS.\n\nPlease compute the minimum total number of complaints John will hear if he chooses an appropriate route to the farm. If, on some road, both GPS systems complain, then the total number of complaints increases by $2$.", "inputFormat": "The first line contains two integers $N$ and $M$.\n\nThe next $M$ lines describe the roads. The $i$-th line contains $A_i, B_i, P_i, Q_i$.", "outputFormat": "Output a single integer, the minimum total number of complaints along John’s route.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2017初中组] guide", "background": null, "description": "农场主 John 最近在网上买了一辆新车，在购买汽车配件时，John 不小心点了两次“提交”按钮。导致汽车上安装了两套 GPS 系统，更糟糕的是 John 在使用 GPS 导航时，两套系统常常给出不同的路线。从地图上看，John 居住的地区有 $N$（$2 \\le N \\le 10^5$）个十字路口和 $M$（$1 \\le M \\le 5 \\times 10^5$）条限定通行方向的道路。第 $i$ 条道路连接路口 $A_i$（$1 \\le A_i \\le N$）和 $B_i$（$1 \\le B_i \\le N$），两个路口之间可能连接有多条道路。允许双向通⾏的道路是将两条单向通⾏的道路隔开所形成的。\n\n\nJohn 的家在路口 $1$ 位置，农场在路口 $N$ 的位置。John 可以沿着⼀系列单向道路从家驾车到农场。所有 GPS 系统的底层地图信息都是⼀样的，区别仅在于对每一条道路的通⾏时间计算不同。对于第 $i$ 条道路第一套 GPS 系统计算通行时间为 $P_i$ 个单位时间，而第二套 GPS 系统则给出 $Q_i$ 个单位时间。（所有道路的通行时间都是范围在 $1$ 到 $10^5$ 之间的整数）John 想要驾车从家到农场。可是，一路上 GPS 系统总是不厌其烦的提醒 John（请从路口 $X$ 开往路口 $Y$），这是由于 John 选取了某套 GPS 系统建议的路径，而另一套 GPS 系统则认为这不是从路口 $X$ 到农场的最短路径。我们称之为 GPS 系统的抱怨。\n\n\n请你计算一下如果 John 选择合适的路径到达农场能听到的最少 GPS 系统的抱怨数。如果 John 经过某条道路两套 GPS 系统都发出抱怨，则抱怨总数加 $2$。", "inputFormat": "第一行，两个整数 $N$ 和 $M$。\n\n接下来 $M$ 行，其中第 $i$ 行描述了道路 $i$ 的信息：$A_i,B_i,P_i,Q_i$。", "outputFormat": "一个整数，表示 John 一路上能听到的最小抱怨数。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3721", "type": "P", "difficulty": 6, "samples": [["5\n1 2\n1 1\n1 3\n4 \n5", "1 \n2 \n2\n2 \n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2017", "线段树", "各省省选", "离散化", "安徽", "湖南", "动态树 LCT"], "title": "[AHOI2017/HNOI2017] 单旋", "background": null, "description": "H 国是一个热爱写代码的国家，那里的人们很小去学校学习写各种各样的数据结构。伸展树（splay）是一种数据结构，因为代码好写，功能多，效率高，掌握这种数据结构成为了 H 国的必修技能。有一天，邪恶的“卡”带着他的邪恶的“常数” 来企图毁灭 H 国。“卡” 给 H 国的人洗脑说，splay 如果写成单旋的，将会更快。“卡”称“单旋 splay”为“spaly”。虽说他说的很没道理，但还是有 H 国的人相信了，小 H 就是其中之一，spaly 马上成为他的信仰。而 H 国的国王，自然不允许这样的风气蔓延，国王构造了一组数据，数据由 $m$（不超过 $10^5$）个操作构成，他知道这样的数据肯定打垮 spaly，但是国王还有很多很多其他的事情要做，所以统计每个操作所需要的实际代价的任务就交给你啦。\n\n数据中的操作分为 $5$ 种：\n\n1. 插入操作：向当前非空 spaly 中插入一个关键码为 $key$ 的新孤立节点。插入方法为，先让 $key$ 和根比较，如果 $key$ 比根小，则往左子树走，否则往右子树走，如此反复，直到某个时刻，$key$ 比当前子树根 $x$ 小，而 $x$ 的左子树为空，那就让 $key$ 成为 $x$ 的左孩子；或者 $key$ 比当前子树根 $x$ 大，而 $x$ 的右子树为空，那就让 $key$ 成为 $x$ 的右孩子。该操作的代价为：插入后，$key$ 的深度。特别地，若树为空，则直接让新节点成为一个单个节点的树。（各节点关键码互不相等。对于“深度” 的解释见末尾对 spaly 的描述。）\n\n2. 单旋最小值：将 spaly 中关键码最小的元素 $x \\min$ 单旋到根。操作代价为：单旋前 $x \\min$ 的深度。（对于单旋操作的解释见末尾对 spaly 的描述。）\n\n3. 单旋最大值：将 spaly 中关键码最大的元素 $x \\max$ 单旋到根。操作代价为：单旋前 $x \\max$ 的深度。\n\n4. 单旋删除最小值：先执行 $2$ 号操作，然后把根删除。由于 $2$ 号操作之后，根没有左子树，所以直接切断根和右子树的联系即可。（具体见样例解释）。操作代价同 $2$ 号操作。\n\n5. 单旋删除最大值：先执行 $3$ 号操作，然后把根删除。操作代价同 $3$ 号操作。\n\n![](https://cdn.luogu.com.cn/upload/pic/5106.png)\n\n对于不是 H 国的人，你可能需要了解一些 spaly 的知识，才能完成国王的任务：\n\n1. spaly 是一棵二叉树，满足对于任意一个节点 $x$，它如果有左孩子 $lx$，那么 $lx$ 的关键码小于 $x$ 的关键码。如果有右孩子 $rx$，那么 $rx$ 的关键码大于 $x$ 的关键码。\n\n2. 一个节点在 spaly 的深度定义为：从根节点到该节点的路径上一共有多少个节点（包括自己）。\n\n3. 单旋操作是对于一棵树上的节点 $x$ 来说的。一开始，设 $f$ 为 $x$ 在树上的父亲。如果 $x$ 为 $f$ 的左孩子，那么执行 $zig (x)$ 操作（如上图中，左边的树经过 $zig (x)$ 变为了右边的树）, 否则执行 $zag (x)$ 操作（在上图中，将右边的树经过 $zag (f)$ 就变成了左边的树）。每当执行一次 $zig (x)$ 或者 $zag (x)$,$x$ 的深度减小 $1$，如此反复，直到 $x$ 为根。总之，单旋 $x$ 就是通过反复执行 $zig$ 和 $zag$ 将 $x$ 变为根。", "inputFormat": "输入文件名为 ```splay.in```。\n\n第一行单独一个正整数 $m$ ($1 \\leq m \\leq 10^5$)。\n\n接下来 $m$ 行，每行描述一个操作：首先是一个操作编号 $c$（ $1 \\leq c \\leq 5$），既问题描述中给出的 $5$ 种操作中的编号，若 $c= 1$，则再输入一个非负整数 key，表示新插入节点的关键码。", "outputFormat": "输出文件名为 ```splay.out```。\n\n输出共 $m$ 行，每行一个整数，第 $i$ 行对应第 $i$ 个输入的操作的代价。", "hint": "$20 \\%$ 的数据满足： $1 \\leq m \\leq 1000$。\n\n另外 $30\\%$ 的数据满足：不存在 $4,5$ 操作。\n\n$100\\%$ 的数据满足：$1 \\leq m \\leq 10^5,1 \\leq key \\leq 10^9$。 所有出现的关键码互不相同。 任何一个非插入操作，一定保证树非空。 在未执行任何操作之前，树为空。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2017/HNOI2017] Single Rotation", "background": "", "description": "The Kingdom of H is a nation passionate about coding. People there go to school from a young age to learn all kinds of data structures. The splay tree (splay) is a data structure that is easy to implement, feature-rich, and efficient; mastering it is a required skill in the Kingdom of H. One day, the evil \"Ka\" (Kǎ) came with his evil \"constant factor\" to try to destroy the kingdom. \"Ka\" brainwashed the people of H by saying that if a splay is implemented using only single rotations, it would be faster. \"Ka\" called this \"single-rotation splay\" a \"spaly\". Although this makes little sense, some people in H believed him—Little H was one of them—and \"spaly\" immediately became his faith. The king of H, of course, would not allow such a trend to spread. The king constructed a piece of testdata consisting of $m$ (no more than $10^5$) operations. He knows this testdata will surely defeat spaly, but the king has many other things to do, so the task of computing the actual cost of each operation is handed over to you.\n\nThere are $5$ types of operations in the testdata:\n\n1. Insert: Insert a new isolated node with key $key$ into the current non-empty spaly. The insertion method is: first compare $key$ with the root. If $key$ is smaller than the root, go to the left subtree; otherwise go to the right subtree. Repeat this until, at some point, $key$ is smaller than the current subtree root $x$ and $x$’s left subtree is empty—then make $key$ the left child of $x$; or $key$ is larger than the current subtree root $x$ and $x$’s right subtree is empty—then make $key$ the right child of $x$. The cost of this operation is: the depth of $key$ after insertion. In particular, if the tree is empty, directly make the new node the entire one-node tree. (All keys are distinct. For the definition of “depth,” see the spaly description at the end.)\n\n2. Single-rotate minimum: Single-rotate the element with the minimum key $x_{\\min}$ in the spaly to the root. The operation cost is: the depth of $x_{\\min}$ before the single rotation. (For single rotation, see the spaly description at the end.)\n\n3. Single-rotate maximum: Single-rotate the element with the maximum key $x_{\\max}$ in the spaly to the root. The operation cost is: the depth of $x_{\\max}$ before the single rotation.\n\n4. Single-rotate delete minimum: First perform operation 2, then delete the root. After operation 2, the root has no left subtree, so simply replace the root with its right subtree (see the sample explanation for details). The operation cost is the same as in operation 2.\n\n5. Single-rotate delete maximum: First perform operation 3, then delete the root. The operation cost is the same as in operation 3.\n\n![](https://cdn.luogu.com.cn/upload/pic/5106.png)\n\nIf you are not from the Kingdom of H, you may need to know some spaly knowledge to complete the king’s task:\n\n1. A spaly is a binary tree that satisfies: for any node $x$, if it has a left child $lx$, then the key of $lx$ is less than the key of $x$; if it has a right child $rx$, then the key of $rx$ is greater than the key of $x$.\n\n2. The depth of a node in a spaly is defined as: the number of nodes on the path from the root to that node (including itself).\n\n3. The single rotation operation is defined for a node $x$ in a tree. Initially, let $f$ be the parent of $x$ in the tree. If $x$ is the left child of $f$, then perform zig(x) (as in the figure above, the left tree becomes the right tree after zig(x)); otherwise perform zag(x) (in the figure above, applying zag(f) to the right tree turns it back into the left tree). Each time you perform zig(x) or zag(x), the depth of $x$ decreases by $1$. Repeat this until $x$ becomes the root. In short, single-rotating $x$ means repeatedly performing zig and zag to make $x$ the root.", "inputFormat": "The input file is named ```splay.in```.\n\nThe first line contains a single positive integer $m$ ($1 \\leq m \\leq 10^5$).\n\nThen follow $m$ lines, each describing an operation: first an operation code $c$ ($1 \\leq c \\leq 5$), which is one of the $5$ types above. If $c = 1$, then an additional non-negative integer $key$ is given, representing the key of the newly inserted node.", "outputFormat": "The output file is named ```splay.out```.\n\nOutput $m$ lines, one integer per line. The $i$-th line corresponds to the cost of the $i$-th input operation.", "hint": "$20\\%$ of the testdata satisfies: $1 \\leq m \\leq 1000$.\n\nAdditionally, $30\\%$ of the testdata satisfies: operations 4 and 5 do not appear.\n\n$100\\%$ of the testdata satisfies: $1 \\leq m \\leq 10^5$, $1 \\leq key \\leq 10^9$. All keys that appear are distinct. For any non-insert operation, the tree is guaranteed to be non-empty. Before any operation, the tree is empty.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2017/HNOI2017] 单旋", "background": null, "description": "H 国是一个热爱写代码的国家，那里的人们很小去学校学习写各种各样的数据结构。伸展树（splay）是一种数据结构，因为代码好写，功能多，效率高，掌握这种数据结构成为了 H 国的必修技能。有一天，邪恶的“卡”带着他的邪恶的“常数” 来企图毁灭 H 国。“卡” 给 H 国的人洗脑说，splay 如果写成单旋的，将会更快。“卡”称“单旋 splay”为“spaly”。虽说他说的很没道理，但还是有 H 国的人相信了，小 H 就是其中之一，spaly 马上成为他的信仰。而 H 国的国王，自然不允许这样的风气蔓延，国王构造了一组数据，数据由 $m$（不超过 $10^5$）个操作构成，他知道这样的数据肯定打垮 spaly，但是国王还有很多很多其他的事情要做，所以统计每个操作所需要的实际代价的任务就交给你啦。\n\n数据中的操作分为 $5$ 种：\n\n1. 插入操作：向当前非空 spaly 中插入一个关键码为 $key$ 的新孤立节点。插入方法为，先让 $key$ 和根比较，如果 $key$ 比根小，则往左子树走，否则往右子树走，如此反复，直到某个时刻，$key$ 比当前子树根 $x$ 小，而 $x$ 的左子树为空，那就让 $key$ 成为 $x$ 的左孩子；或者 $key$ 比当前子树根 $x$ 大，而 $x$ 的右子树为空，那就让 $key$ 成为 $x$ 的右孩子。该操作的代价为：插入后，$key$ 的深度。特别地，若树为空，则直接让新节点成为一个单个节点的树。（各节点关键码互不相等。对于“深度” 的解释见末尾对 spaly 的描述。）\n\n2. 单旋最小值：将 spaly 中关键码最小的元素 $x \\min$ 单旋到根。操作代价为：单旋前 $x \\min$ 的深度。（对于单旋操作的解释见末尾对 spaly 的描述。）\n\n3. 单旋最大值：将 spaly 中关键码最大的元素 $x \\max$ 单旋到根。操作代价为：单旋前 $x \\max$ 的深度。\n\n4. 单旋删除最小值：先执行 $2$ 号操作，然后把根删除。由于 $2$ 号操作之后，根没有左子树，所以直接切断根和右子树的联系即可。（具体见样例解释）。操作代价同 $2$ 号操作。\n\n5. 单旋删除最大值：先执行 $3$ 号操作，然后把根删除。操作代价同 $3$ 号操作。\n\n![](https://cdn.luogu.com.cn/upload/pic/5106.png)\n\n对于不是 H 国的人，你可能需要了解一些 spaly 的知识，才能完成国王的任务：\n\n1. spaly 是一棵二叉树，满足对于任意一个节点 $x$，它如果有左孩子 $lx$，那么 $lx$ 的关键码小于 $x$ 的关键码。如果有右孩子 $rx$，那么 $rx$ 的关键码大于 $x$ 的关键码。\n\n2. 一个节点在 spaly 的深度定义为：从根节点到该节点的路径上一共有多少个节点（包括自己）。\n\n3. 单旋操作是对于一棵树上的节点 $x$ 来说的。一开始，设 $f$ 为 $x$ 在树上的父亲。如果 $x$ 为 $f$ 的左孩子，那么执行 $zig (x)$ 操作（如上图中，左边的树经过 $zig (x)$ 变为了右边的树）, 否则执行 $zag (x)$ 操作（在上图中，将右边的树经过 $zag (f)$ 就变成了左边的树）。每当执行一次 $zig (x)$ 或者 $zag (x)$,$x$ 的深度减小 $1$，如此反复，直到 $x$ 为根。总之，单旋 $x$ 就是通过反复执行 $zig$ 和 $zag$ 将 $x$ 变为根。", "inputFormat": "输入文件名为 ```splay.in```。\n\n第一行单独一个正整数 $m$ ($1 \\leq m \\leq 10^5$)。\n\n接下来 $m$ 行，每行描述一个操作：首先是一个操作编号 $c$（ $1 \\leq c \\leq 5$），既问题描述中给出的 $5$ 种操作中的编号，若 $c= 1$，则再输入一个非负整数 key，表示新插入节点的关键码。", "outputFormat": "输出文件名为 ```splay.out```。\n\n输出共 $m$ 行，每行一个整数，第 $i$ 行对应第 $i$ 个输入的操作的代价。", "hint": "$20 \\%$ 的数据满足： $1 \\leq m \\leq 1000$。\n\n另外 $30\\%$ 的数据满足：不存在 $4,5$ 操作。\n\n$100\\%$ 的数据满足：$1 \\leq m \\leq 10^5,1 \\leq key \\leq 10^9$。 所有出现的关键码互不相同。 任何一个非插入操作，一定保证树非空。 在未执行任何操作之前，树为空。", "locale": "zh-CN"}}}
{"pid": "P3722", "type": "P", "difficulty": 6, "samples": [["10 5 2 3\n7 9 5 1 3 10 6 8 2 4\n1 7\n1 9\n1 3\n5 9\n1 5", "30\n39\n4\n13\n16"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "线段树", "各省省选", "安徽", "湖南", "排序", "栈"], "title": "[AHOI2017/HNOI2017] 影魔", "background": "影魔，奈文摩尔，据说有着一个诗人的灵魂。事实上，他吞噬的诗人灵魂早已成千上万。\n\n千百年来，他收集了各式各样的灵魂，包括诗人、牧师、帝王、乞丐、奴隶、罪人，当然，还有英雄。\n\n每一个灵魂，都有着自己的战斗力，而影魔，靠这些战斗力提升自己的攻击。", "description": "奈文摩尔有 $n$ 个灵魂，他们在影魔宽广的体内可以排成一排，从左至右标号 $1$ 到 $n$。第 $i$ 个灵魂的战斗力为 $k_i$，灵魂们以点对的形式为影魔提供攻击力。对于灵魂对 $i, j\\ (i<j)$ 来说，若不存在 $k_s\\ (i<s<j)$ 大于 $k_i$ 或者 $k_j$，则会为影魔提供 $p_1$ 的攻击力。另一种情况，令 $c$ 为 $k_{i + 1}, k_{i + 2}, \\cdots, k_{j -1}$ 的最大值，若 $c$ 满足：$k_i < c < k_j$，或者 $k_j < c < k_i$，则会为影魔提供 $p_2$ 的攻击力，当这样的 $c$ 不存在时，自然不会提供这 $p_2$ 的攻击力；其他情况的点对，均不会为影魔提供攻击力。\n\n影魔的挚友噬魂鬼在一天造访影魔体内时被这些灵魂吸引住了，他想知道，对于任意一段区间 $[a, b]$，位于这些区间中的灵魂对会为影魔提供多少攻击力，即考虑所有满足 $a\\le i<j\\le b$ 的灵魂对 $i, j$ 提供的攻击力之和。\n\n顺带一提，灵魂的战斗力组成一个 $1$ 到 $n$ 的排列：$k_1, k_2, \\cdots, k_n$。", "inputFormat": "第一行四个整数 $n,m,p_1,p_2$。  \n\n第二行 $n$ 个整数 $k_1, k_2,\\cdots, k_n$。\n\n接下来 $m$ 行,每行两个数 $a,b$，表示询问区间 $[a,b]$ 中的灵魂对会为影魔提供多少攻击力。", "outputFormat": "共输出 $m$ 行，每行一个答案，依次对应 $m$ 个询问。", "hint": "对于 $30\\%$ 的数据，$1\\le n, m\\le 500$。\n\n另有 $30\\%$ 的数据，$p_1 = 2p_2$。\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 200000, 1\\le p_1, p_2\\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2017/HNOI2017] Shadow Fiend", "background": "Shadow Fiend, Nevermore, is said to have the soul of a poet. In fact, the poet souls he has devoured already number in the tens of thousands.\n\nFor hundreds of years, he has collected all kinds of souls, including poets, priests, emperors, beggars, slaves, sinners, and of course, heroes.\n\nEach soul has its own combat power, and Shadow Fiend increases his attack power by relying on these combat powers.", "description": "Nevermore has $n$ souls. Inside the vast body of the Shadow Fiend, they can line up in a row, labeled from left to right $1$ to $n$. The $i$-th soul has combat power $k_i$, and souls provide attack power for the Shadow Fiend in the form of pairs. For a soul pair $i, j$ with $i < j$, if there is no $k_s$ with $i < s < j$ that is greater than $k_i$ or greater than $k_j$, then it provides $p_1$ attack power. In another case, let $c$ be the maximum of $k_{i + 1}, k_{i + 2}, \\cdots, k_{j - 1}$. If $c$ satisfies $k_i < c < k_j$, or $k_j < c < k_i$, then it provides $p_2$ attack power. When such a $c$ does not exist, it naturally does not provide this $p_2$ attack power. In all other cases, the pair does not provide any attack power.\n\nShadow Fiend’s close friend Lifestealer visited him one day and was captivated by these souls. He wants to know, for any interval $[a, b]$, how much attack power is provided by the soul pairs within these intervals, that is, consider the sum of the attack power provided by all soul pairs $i, j$ satisfying $a \\le i < j \\le b$.\n\nIncidentally, the souls’ combat powers form a permutation of $1$ to $n$: $k_1, k_2, \\cdots, k_n$.", "inputFormat": "The first line contains four integers $n, m, p_1, p_2$.\n\nThe second line contains $n$ integers $k_1, k_2, \\cdots, k_n$.\n\nThen there are $m$ lines. Each line contains two integers $a, b$, representing a query asking how much attack power is provided by the soul pairs within the interval $[a, b]$.", "outputFormat": "Output $m$ lines, each containing one answer, corresponding to the $m$ queries in order.", "hint": "For $30\\%$ of the testdata, $1 \\le n, m \\le 500$.\n\nFor another $30\\%$ of the testdata, $p_1 = 2 p_2$.\n\nFor $100\\%$ of the testdata, $1 \\le n, m \\le 200000$, $1 \\le p_1, p_2 \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2017/HNOI2017] 影魔", "background": "影魔，奈文摩尔，据说有着一个诗人的灵魂。事实上，他吞噬的诗人灵魂早已成千上万。\n\n千百年来，他收集了各式各样的灵魂，包括诗人、牧师、帝王、乞丐、奴隶、罪人，当然，还有英雄。\n\n每一个灵魂，都有着自己的战斗力，而影魔，靠这些战斗力提升自己的攻击。", "description": "奈文摩尔有 $n$ 个灵魂，他们在影魔宽广的体内可以排成一排，从左至右标号 $1$ 到 $n$。第 $i$ 个灵魂的战斗力为 $k_i$，灵魂们以点对的形式为影魔提供攻击力。对于灵魂对 $i, j\\ (i<j)$ 来说，若不存在 $k_s\\ (i<s<j)$ 大于 $k_i$ 或者 $k_j$，则会为影魔提供 $p_1$ 的攻击力。另一种情况，令 $c$ 为 $k_{i + 1}, k_{i + 2}, \\cdots, k_{j -1}$ 的最大值，若 $c$ 满足：$k_i < c < k_j$，或者 $k_j < c < k_i$，则会为影魔提供 $p_2$ 的攻击力，当这样的 $c$ 不存在时，自然不会提供这 $p_2$ 的攻击力；其他情况的点对，均不会为影魔提供攻击力。\n\n影魔的挚友噬魂鬼在一天造访影魔体内时被这些灵魂吸引住了，他想知道，对于任意一段区间 $[a, b]$，位于这些区间中的灵魂对会为影魔提供多少攻击力，即考虑所有满足 $a\\le i<j\\le b$ 的灵魂对 $i, j$ 提供的攻击力之和。\n\n顺带一提，灵魂的战斗力组成一个 $1$ 到 $n$ 的排列：$k_1, k_2, \\cdots, k_n$。", "inputFormat": "第一行四个整数 $n,m,p_1,p_2$。  \n\n第二行 $n$ 个整数 $k_1, k_2,\\cdots, k_n$。\n\n接下来 $m$ 行,每行两个数 $a,b$，表示询问区间 $[a,b]$ 中的灵魂对会为影魔提供多少攻击力。", "outputFormat": "共输出 $m$ 行，每行一个答案，依次对应 $m$ 个询问。", "hint": "对于 $30\\%$ 的数据，$1\\le n, m\\le 500$。\n\n另有 $30\\%$ 的数据，$p_1 = 2p_2$。\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 200000, 1\\le p_1, p_2\\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P3723", "type": "P", "difficulty": 6, "samples": [["5 6\n1 2 3 4 5\n6 3 3 4 5", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "各省省选", "递归", "安徽", "湖南", "进制", "快速傅里叶变换 FFT"], "title": "[AHOI2017/HNOI2017] 礼物", "background": null, "description": "我的室友最近喜欢上了一个可爱的小女生。马上就要到她的生日了，他决定买一对情侣手环，一个留给自己，一个送给她。每个手环上各有 $n$ 个装饰物，并且每个装饰物都有一定的亮度。\n\n但是在她生日的前一天，我的室友突然发现他好像拿错了一个手环，而且已经没时间去更换它了！他只能使用一种特殊的方法，将其中一个手环中所有装饰物的亮度增加一个相同的非负整数 $c$。并且由于这个手环是一个圆，可以以任意的角度旋转它，但是由于上面装饰物的方向是固定的，所以手环不能翻转。需要在经过亮度改造和旋转之后，使得两个手环的差异值最小。\n\n在将两个手环旋转且装饰物对齐了之后，从对齐的某个位置开始逆时针方向对装饰物编号 $1 \\sim n$，其中 $n$ 为每个手环的装饰物个数， 第 $1$ 个手环的 $i$ 号位置装饰物亮度为 $x_i$，第 $2$ 个手环的 $i$ 号位置装饰物亮度为 $y_i$，两个手环之间的差异值为（参见输入输出样例和样例解释）：\n\n$$\\sum_{i=1}^{n} (x_i-y_i)^2$$\n\n麻烦你帮他计算一下，进行调整（亮度改造和旋转），使得两个手环之间的差异值最小，这个最小值是多少呢？", "inputFormat": "输入数据的第一行有两个数 $n,m$，代表每条手环的装饰物的数量为 $n$，每个装饰物的初始亮度小于等于 $m$。\n\n接下来两行，每行各有 $n$ 个数，分别代表第一条手环和第二条手环上从某个位置开始逆时针方向上各装饰物的亮度。", "outputFormat": "输出一个数，表示两个手环能产生的最小差异值。注意在将手环改造之后，装饰物的亮度可以大于 $m$。", "hint": "【样例解释】\n\n需要将第一个手环的亮度增加 $1$，第一个手环的亮度变为：$2,3,4,5,6$\n\n旋转一下第二个手环。对于该样例，是将第二个手环的亮度 $6,3,3,4,5$ 向左循环移动一个位置，使得第二手环的最终的亮度为：$3,3,4,5,6$。\n\n此时两个手环的亮度差异值为 $1$。\n\n【数据范围】\n\n对于 $30\\%$ 的数据，$n \\le 500$，$m \\le 10$；\n\n对于 $70\\%$ 的数据，$n \\le 5000$；\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 50000$, $1 \\le x_i,y_i \\le m \\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2017/HNOI2017] Gift", "background": "", "description": "My roommate recently fell for a cute girl. Her birthday is coming up, and he decided to buy a pair of couple bracelets: one for himself and one for her. Each bracelet has $n$ decorations, and each decoration has a certain brightness.\n\nHowever, on the day before her birthday, my roommate suddenly realized that he might have picked up the wrong bracelet, and there is no time to replace it. He can only use a special method: increase the brightness of all decorations on one of the bracelets by the same non-negative integer $c$. Since a bracelet is a circle, it can be rotated by any angle, but because the orientation of the decorations is fixed, the bracelet cannot be flipped. After applying the brightness modification and rotation, we want to minimize the difference value between the two bracelets.\n\nAfter rotating both bracelets and aligning the decorations, starting from some aligned position and numbering the decorations from $1$ to $n$ in counterclockwise order (where $n$ is the number of decorations on each bracelet), the brightness of the decoration at position $i$ on the first bracelet is $x_i$, and that on the second bracelet is $y_i$. The difference value between the two bracelets is:\n$$\\sum_{i=1}^{n} (x_i-y_i)^2$$\n\nPlease help compute the minimal possible difference value after applying the allowed brightness modification and rotation.", "inputFormat": "The first line contains two integers $n, m$, where each bracelet has $n$ decorations, and the initial brightness of each decoration is at most $m$.\n\nThe next two lines each contain $n$ integers, representing the brightness of the decorations on the first and second bracelets, respectively, listed in counterclockwise order starting from some position.", "outputFormat": "Output a single integer: the minimal difference value that can be achieved between the two bracelets. Note that after the modification, the brightness of decorations may exceed $m$.", "hint": "Sample explanation:\n\nIncrease the brightness of the first bracelet by $1$, making it $2, 3, 4, 5, 6$.\n\nRotate the second bracelet. In this sample, cyclically shift the second bracelet $6, 3, 3, 4, 5$ left by one position, making it $3, 3, 4, 5, 6$.\n\nThe difference value is $1$.\n\nConstraints:\n\n- For $30\\%$ of the testdata, $n \\le 500$, $m \\le 10$.\n- For $70\\%$ of the testdata, $n \\le 5000$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 50000$, $1 \\le x_i, y_i \\le m \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2017/HNOI2017] 礼物", "background": null, "description": "我的室友最近喜欢上了一个可爱的小女生。马上就要到她的生日了，他决定买一对情侣手环，一个留给自己，一个送给她。每个手环上各有 $n$ 个装饰物，并且每个装饰物都有一定的亮度。\n\n但是在她生日的前一天，我的室友突然发现他好像拿错了一个手环，而且已经没时间去更换它了！他只能使用一种特殊的方法，将其中一个手环中所有装饰物的亮度增加一个相同的非负整数 $c$。并且由于这个手环是一个圆，可以以任意的角度旋转它，但是由于上面装饰物的方向是固定的，所以手环不能翻转。需要在经过亮度改造和旋转之后，使得两个手环的差异值最小。\n\n在将两个手环旋转且装饰物对齐了之后，从对齐的某个位置开始逆时针方向对装饰物编号 $1 \\sim n$，其中 $n$ 为每个手环的装饰物个数， 第 $1$ 个手环的 $i$ 号位置装饰物亮度为 $x_i$，第 $2$ 个手环的 $i$ 号位置装饰物亮度为 $y_i$，两个手环之间的差异值为（参见输入输出样例和样例解释）：\n\n$$\\sum_{i=1}^{n} (x_i-y_i)^2$$\n\n麻烦你帮他计算一下，进行调整（亮度改造和旋转），使得两个手环之间的差异值最小，这个最小值是多少呢？", "inputFormat": "输入数据的第一行有两个数 $n,m$，代表每条手环的装饰物的数量为 $n$，每个装饰物的初始亮度小于等于 $m$。\n\n接下来两行，每行各有 $n$ 个数，分别代表第一条手环和第二条手环上从某个位置开始逆时针方向上各装饰物的亮度。", "outputFormat": "输出一个数，表示两个手环能产生的最小差异值。注意在将手环改造之后，装饰物的亮度可以大于 $m$。", "hint": "【样例解释】\n\n需要将第一个手环的亮度增加 $1$，第一个手环的亮度变为：$2,3,4,5,6$\n\n旋转一下第二个手环。对于该样例，是将第二个手环的亮度 $6,3,3,4,5$ 向左循环移动一个位置，使得第二手环的最终的亮度为：$3,3,4,5,6$。\n\n此时两个手环的亮度差异值为 $1$。\n\n【数据范围】\n\n对于 $30\\%$ 的数据，$n \\le 500$，$m \\le 10$；\n\n对于 $70\\%$ 的数据，$n \\le 5000$；\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 50000$, $1 \\le x_i,y_i \\le m \\le 100$。", "locale": "zh-CN"}}}
{"pid": "P3724", "type": "P", "difficulty": 7, "samples": [["30 20 30\n15 5 24 14 13 4 14 21 3 16 7 4 7 8 13 19 16 5 6 13 21 12 7 9 4 15 20 4 13 12\n22 21 15 16 17 1 21 19 11 8 3 28 7 10 19 3 27 17 28 3 26 4 22 28 15 5 26 9 5 26\n30\n10\n18\n29\n18\n29\n3\n12\n28\n11\n28\n6\n1\n6\n27\n27\n18\n11\n26\n1", "0\n1\n1\n0\n1\n0\n1\n1\n0\n0\n0\n1\n1\n1\n1\n1\n1\n0\n0\n1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "2017", "各省省选", "安徽", "湖南", "枚举", "栈"], "title": "[AHOI2017/HNOI2017] 大佬", "background": "", "description": "人们总是难免会碰到大佬。他们趾高气昂地谈论凡人不能理解的算法和数据结构，走到任何一个地方，大佬的气场就能让周围的人吓得瑟瑟发抖，不敢言语。你作为一个 OIer，面对这样的事情非常不开心，于是发表了对大佬不敬的言论。 大佬便对你开始了报复，你也不示弱，扬言要打倒大佬。现在给你讲解一下什么是大佬，大佬除了是神犇以外，还有着强大的自信心，自信程度可以被量化为一个正整数 $C$，想要打倒一个大佬的唯一方法是摧毁 Ta 的自信心，也就是让大佬的自信值**等于** $0$（恰好等于 $0$，不能小于 $0$）。由于你被大佬盯上了，所以你需要准备好 $n$ 天来和大佬较量，因为这 $n$ 天大佬只会嘲讽你动摇你的自信，到了第 $n+1$ 天，如果大佬发现你还不服，就会直接虐到你服，这样你就丧失斗争的能力了。\n\n你的自信程度同样也可以被量化，我们用 $\\mathrm{mc}$ 来表示你的自信值**上限**。在第 $i \\ (i\\ge 1)$ 天，大佬会对你发动一次嘲讽，使你的自信值减小 $a_i$，如果这个时刻你的自信值**小于** $0$ 了，那么你就丧失斗争能力，也就**失败**了（特别注意你的自信值为 $0$ 的时候还可以继续和大佬斗争）。 在这一天，大佬对你发动嘲讽之后，如果你的自信值仍大于等于 $0$，你**能且仅能**选择如下的行为**之一**：\n\n1. 还一句嘴，大佬会有点惊讶，导致大佬的自信值 $C$ 减小 $1$。\n2. 做一天的水题，使得自己的当前自信值增加 $w_i$，并将新自信值和自信值上限 $\\mathrm{mc}$ 比较，若新自信值大于 $\\mathrm{mc}$，则新自信值更新为 $\\mathrm{mc}$。例如，$\\mathrm{mc} = 50$，当前自信值为 $40$，若 $w_i = 5$，则新自信值为 $45$，若 $w_i = 11$，则新自信值为 $50$。\n3. 让自己的等级值 $L$ 加 $1$。\n4. 让自己的讽刺能力 $F$ 乘以自己当前等级 $L$，使讽刺能力 $F$ 更新为 $F\\cdot L$。\n5. 怼大佬，让大佬的自信值 $C$ 减小 $F$。并在怼完大佬之后，你自己的等级 $L$ 自动降为 $0$，讽刺能力 $F$ 降为 $1$。由于怼大佬比较掉人品，所以这个操作只能做**不超过两次**。\n\n**特别注意**的是，在任何时候，你**不能**让大佬的自信值**为负**，因为自信值为负，对大佬来说意味着屈辱，而大佬但凡遇到屈辱就会进化为更厉害的大佬直接虐飞你。在第 $1$ 天，在你被攻击之前，你的自信是满的（初始自信值等于自信值上限 $\\mathrm{mc}$），你的讽刺能力 $F$ 是 $1$，等级是 $0$。\n\n\n现在由于你得罪了大佬，你需要准备和大佬正面杠，你知道世界上一共有 $m$ 个大佬，他们的嘲讽时间都是 $n$ 天，而且第 $i$ 天的嘲讽值都是 $a_i$。不管和哪个大佬较量，你在第 $i$ 天做水题的自信回涨都是 $w_i$。这 $m$ 个大佬中**只会有一个**来和你较量（$n$ 天里都是这个大佬和你较量），但是作为你，你需要知道对于任意一个大佬，你是否能摧毁他的自信，也就是让他的自信值恰好等于 $0$。和某一个大佬较量时，其他大佬不会插手。", "inputFormat": "第一行三个正整数 $n,m,\\mathrm{mc}$。分别表示有 $n$ 天和 $m$ 个大佬，你的自信上限为 $\\mathrm{mc}$。\n\n接下来一行是用空格隔开的 $n$ 个数，其中第 $i(1\\le i\\le n)$ 个表示 $a_i$。\n\n接下来一行是用空格隔开的 $n$ 个数，其中第 $i(1\\le i\\le n)$ 个表示 $w_i$。\n\n接下来 $m$ 行，每行一个正整数，其中第 $k(1\\le k\\le m)$ 行的正整数 $C_k$ 表示第 $k$ 个大佬的初始自信值。", "outputFormat": "共 $m$ 行，如果能战胜第 $k$ 个大佬（让他的自信值恰好等于 0），那么第 $k$ 行输出 $1$，否则输出 $0$。", "hint": "- 对于 $20\\%$ 的数据，$1\\le n\\le 10$；\n- 另有 $20\\%$ 数据，$1\\le C_i,n,\\mathrm{mc}\\le 30$；\n- 对于 $100\\%$ 的数据，$1\\le n, \\mathrm{mc}\\le 100, 1\\le m\\le 20; 1\\le a_i, w_i\\le\\mathrm{mc}, 1\\le C_i\\le 10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2017/HNOI2017] Dalao", "background": "", "description": "People inevitably run into “dalao.” They swagger around, talking about algorithms and data structures that ordinary folks cannot grasp. Wherever they go, their presence makes others tremble and fall silent. As an OIer, you are very unhappy about this and make some disrespectful remarks. The dalao starts to take revenge on you, and you refuse to back down, vowing to bring them down. Let us explain what a dalao is: besides being a “shen niu,” a dalao also has strong self-confidence, which can be quantified by a positive integer $C$. The only way to defeat a dalao is to destroy their self-confidence, i.e., make the dalao’s confidence value equal to $0$ (exactly $0$, not less than $0$). Since you are targeted, you must prepare for $n$ days to contend with the dalao: during these $n$ days the dalao will only mock you to shake your confidence. On day $n+1$, if the dalao finds you still unconvinced, they will crush you directly, and you will lose the ability to fight.\n\nYour confidence can also be quantified. Let $\\mathrm{mc}$ be your confidence upper bound. On day $i$ ($i \\ge 1$), the dalao taunts you once, decreasing your confidence by $a_i$. If at that moment your confidence becomes less than $0$, you lose the ability to fight and thus fail (note in particular that when your confidence is $0$, you can still continue to fight the dalao). On that day, after the dalao’s taunt, if your confidence is still at least $0$, you can and only can choose exactly one of the following actions:\n\n1. Talk back once. The dalao is a bit surprised, so the dalao’s confidence $C$ decreases by $1$.\n2. Solve easy problems for a day, increasing your current confidence by $w_i$, then compare the new confidence with the upper bound $\\mathrm{mc}$. If the new confidence exceeds $\\mathrm{mc}$, set it to $\\mathrm{mc}$. For example, if $\\mathrm{mc} = 50$, your current confidence is $40$, and $w_i = 5$, then the new confidence is $45$; if $w_i = 11$, then the new confidence is $50$.\n3. Increase your level $L$ by $1$.\n4. Multiply your taunt power $F$ by your current level $L$, i.e., update $F$ to $F \\cdot L$.\n5. Roast the dalao, decreasing the dalao’s confidence $C$ by $F$. After roasting the dalao, your level $L$ automatically drops to $0$, and your taunt power $F$ becomes $1$. Since roasting the dalao costs reputation, this operation can be performed at most twice.\n\nPay special attention: at any time, you must not make the dalao’s confidence negative. A negative confidence value is a humiliation to the dalao, and whenever humiliated, the dalao evolves into an even stronger dalao who instantly crushes you. On day $1$, before you are attacked, your confidence is full (initial confidence equals the upper bound $\\mathrm{mc}$), your taunt power $F$ is $1$, and your level $L$ is $0$.\n\nSince you have offended the dalao, you must prepare to confront them head-on. You know there are $m$ dalao in the world. Their taunting lasts $n$ days, and the taunt value on day $i$ is $a_i$. No matter which dalao you face, the confidence recovery from solving easy problems on day $i$ is $w_i$. Among these $m$ dalao, exactly one will fight you (the same one for all $n$ days). But you need to know, for each dalao, whether you can destroy their confidence, i.e., make their confidence value exactly $0$. When you fight one dalao, the others do not interfere.", "inputFormat": "The first line contains three positive integers $n, m, \\mathrm{mc}$, denoting that there are $n$ days and $m$ dalao, and your confidence upper bound is $\\mathrm{mc}$.\n\nThe next line contains $n$ integers separated by spaces. The $i$-th ($1 \\le i \\le n$) denotes $a_i$.\n\nThe next line contains $n$ integers separated by spaces. The $i$-th ($1 \\le i \\le n$) denotes $w_i$.\n\nThen follow $m$ lines, each containing one positive integer. On the $k$-th ($1 \\le k \\le m$) line, the integer $C_k$ denotes the initial confidence of the $k$-th dalao.", "outputFormat": "Output $m$ lines. If you can defeat the $k$-th dalao (make their confidence exactly $0$), output $1$ on the $k$-th line; otherwise, output $0$.", "hint": "- For $20\\%$ of the testdata, $1 \\le n \\le 10$.\n- For another $20\\%$ of the testdata, $1 \\le C_i, n, \\mathrm{mc} \\le 30$.\n- For $100\\%$ of the testdata, $1 \\le n, \\mathrm{mc} \\le 100$, $1 \\le m \\le 20$, $1 \\le a_i, w_i \\le \\mathrm{mc}$, $1 \\le C_i \\le 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2017/HNOI2017] 大佬", "background": "", "description": "人们总是难免会碰到大佬。他们趾高气昂地谈论凡人不能理解的算法和数据结构，走到任何一个地方，大佬的气场就能让周围的人吓得瑟瑟发抖，不敢言语。你作为一个 OIer，面对这样的事情非常不开心，于是发表了对大佬不敬的言论。 大佬便对你开始了报复，你也不示弱，扬言要打倒大佬。现在给你讲解一下什么是大佬，大佬除了是神犇以外，还有着强大的自信心，自信程度可以被量化为一个正整数 $C$，想要打倒一个大佬的唯一方法是摧毁 Ta 的自信心，也就是让大佬的自信值**等于** $0$（恰好等于 $0$，不能小于 $0$）。由于你被大佬盯上了，所以你需要准备好 $n$ 天来和大佬较量，因为这 $n$ 天大佬只会嘲讽你动摇你的自信，到了第 $n+1$ 天，如果大佬发现你还不服，就会直接虐到你服，这样你就丧失斗争的能力了。\n\n你的自信程度同样也可以被量化，我们用 $\\mathrm{mc}$ 来表示你的自信值**上限**。在第 $i \\ (i\\ge 1)$ 天，大佬会对你发动一次嘲讽，使你的自信值减小 $a_i$，如果这个时刻你的自信值**小于** $0$ 了，那么你就丧失斗争能力，也就**失败**了（特别注意你的自信值为 $0$ 的时候还可以继续和大佬斗争）。 在这一天，大佬对你发动嘲讽之后，如果你的自信值仍大于等于 $0$，你**能且仅能**选择如下的行为**之一**：\n\n1. 还一句嘴，大佬会有点惊讶，导致大佬的自信值 $C$ 减小 $1$。\n2. 做一天的水题，使得自己的当前自信值增加 $w_i$，并将新自信值和自信值上限 $\\mathrm{mc}$ 比较，若新自信值大于 $\\mathrm{mc}$，则新自信值更新为 $\\mathrm{mc}$。例如，$\\mathrm{mc} = 50$，当前自信值为 $40$，若 $w_i = 5$，则新自信值为 $45$，若 $w_i = 11$，则新自信值为 $50$。\n3. 让自己的等级值 $L$ 加 $1$。\n4. 让自己的讽刺能力 $F$ 乘以自己当前等级 $L$，使讽刺能力 $F$ 更新为 $F\\cdot L$。\n5. 怼大佬，让大佬的自信值 $C$ 减小 $F$。并在怼完大佬之后，你自己的等级 $L$ 自动降为 $0$，讽刺能力 $F$ 降为 $1$。由于怼大佬比较掉人品，所以这个操作只能做**不超过两次**。\n\n**特别注意**的是，在任何时候，你**不能**让大佬的自信值**为负**，因为自信值为负，对大佬来说意味着屈辱，而大佬但凡遇到屈辱就会进化为更厉害的大佬直接虐飞你。在第 $1$ 天，在你被攻击之前，你的自信是满的（初始自信值等于自信值上限 $\\mathrm{mc}$），你的讽刺能力 $F$ 是 $1$，等级是 $0$。\n\n\n现在由于你得罪了大佬，你需要准备和大佬正面杠，你知道世界上一共有 $m$ 个大佬，他们的嘲讽时间都是 $n$ 天，而且第 $i$ 天的嘲讽值都是 $a_i$。不管和哪个大佬较量，你在第 $i$ 天做水题的自信回涨都是 $w_i$。这 $m$ 个大佬中**只会有一个**来和你较量（$n$ 天里都是这个大佬和你较量），但是作为你，你需要知道对于任意一个大佬，你是否能摧毁他的自信，也就是让他的自信值恰好等于 $0$。和某一个大佬较量时，其他大佬不会插手。", "inputFormat": "第一行三个正整数 $n,m,\\mathrm{mc}$。分别表示有 $n$ 天和 $m$ 个大佬，你的自信上限为 $\\mathrm{mc}$。\n\n接下来一行是用空格隔开的 $n$ 个数，其中第 $i(1\\le i\\le n)$ 个表示 $a_i$。\n\n接下来一行是用空格隔开的 $n$ 个数，其中第 $i(1\\le i\\le n)$ 个表示 $w_i$。\n\n接下来 $m$ 行，每行一个正整数，其中第 $k(1\\le k\\le m)$ 行的正整数 $C_k$ 表示第 $k$ 个大佬的初始自信值。", "outputFormat": "共 $m$ 行，如果能战胜第 $k$ 个大佬（让他的自信值恰好等于 0），那么第 $k$ 行输出 $1$，否则输出 $0$。", "hint": "- 对于 $20\\%$ 的数据，$1\\le n\\le 10$；\n- 另有 $20\\%$ 数据，$1\\le C_i,n,\\mathrm{mc}\\le 30$；\n- 对于 $100\\%$ 的数据，$1\\le n, \\mathrm{mc}\\le 100, 1\\le m\\le 20; 1\\le a_i, w_i\\le\\mathrm{mc}, 1\\le C_i\\le 10^8$。", "locale": "zh-CN"}}}
{"pid": "P3725", "type": "P", "difficulty": 7, "samples": [["7 20 -5\n4 3 -2.875\n5 7 -1.314\n10 -2 0.666\n16 1 -1.571\n16 1 1.571\n23 -3 -2.130\n14 -5 3.073", "33.3380422500"], ["7 20 0\n5 2 1.155\n5 2 1.987\n5 2 -1.571\n11 -4 1.765\n11 -4 1.377\n15 -4 1.765\n15 -4 1.377", "24.2735704188"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "各省省选", "安徽", "湖南", "Special Judge", "排序", "最短路", "队列"], "title": "[AHOI2017/HNOI2017] 队长快跑", "background": null, "description": "众所周知，在 P 国外不远处盘踞着巨龙大 Y。传说中，在远古时代，巨龙大 Y 将 P 国的镇国之宝窃走并藏在了其巢穴中，这吸引着整个 P 国的所有冒险家前去夺回，尤其是皇家卫士队的队长小 W。在 P 国量子科技实验室的帮助下，队长小 W 通过量子传输进入了巨龙大 Y 的藏宝室，并成功夺回了镇国之宝。但此时巨龙布下的攻击性防壁启动，将小 W 困在了美杜莎的迷宫当中。\n\n被困在迷宫 $(0,0)$ 处的队长小 W 快速观察了美杜莎的迷宫的构造，发现迷宫的出口位于 $(p,q)$ 处。巨龙大 Y 在迷宫当中布置了 $n$ 火焰吐息机关，每个机关可以用三个参数 $(x,y,\\theta)$ 表示，分别指明机关位于平面的坐标 $(x,y)$，以及火焰吐息的方向相对于 $x$ 正方向的倾角 $\\theta$。巨龙强大的力量使得火焰吐息有无穷长，且队长小  W 不能通过被火焰吐息覆盖的射线（注意，机关所处的坐标若没有被其他火焰吐息覆盖，则是可以通过的）。同时，迷宫在沿 $x$ 负方向无穷远的地方放置了美杜莎之眼，使得队长小 W 必须倾向于向 $x$ 正方向行动（即队长小 W 的移动方向在 $x$ 正方向上的投影必须为正，不能是负数或零），否则队长小 W 将被瞬间石化而无法逃离。\n\n心急如焚的队长小 W 需要趁着巨龙大 Y 还没将其抓住前逃离美杜莎的迷宫，所以他立马向 P 国智囊团求助，作为智囊团团长的你，一定可以帮队长小 W 找出安全逃至迷宫出口的最短道路。", "inputFormat": "第一行为三个整数 $n,p,q$ 分别表示火焰吐息机关总数以及出口坐标。\n\n接下来 $n$ 行，每行两个整数与一个实数 $(x,y,\\theta)$ 分别表示机关所处的坐标以及火焰吐息的关于 $x$ 正方向的倾角。", "outputFormat": "输出文件仅包含一行一个小数，表示最短道路的长度。当你的答案和标准答案的相对误差不超过 $10^{-8}$ 时（ 即 $\\frac{|a-o|}{a}\\leq10^{-8}$ 时， 其中 $a$ 是标准答案，$o$ 是输出）认为你的答案正确。", "hint": "【样例解释】\n\n ![](https://cdn.luogu.com.cn/upload/pic/5107.png) \n\n$30\\%$ 的数据满足 $n\\leq 300$；\n\n$60\\%$ 的数据满足 $n\\leq 2000$；\n\n$80\\%$ 的数据满足 $n\\leq 10^5$；\n\n$100\\%$ 的数据满足： $0 \\leq n,p, |q|, |x|, |y| \\leq 10^6； \\theta \\in [−\\pi, \\pi]$。\n数据保证至少存在一条合法路径，且起点和终点均不会被火焰路径覆盖。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2017/HNOI2017] Captain, Run", "background": "", "description": "As is well known, not far from Country P lurks the great dragon Da Y. Legend has it that in ancient times, the great dragon Da Y stole Country P’s national treasure and hid it in its lair, attracting all adventurers of Country P to try to take it back—especially Captain Xiao W of the Royal Guards. With the help of Country P’s Quantum Technology Laboratory, Captain Xiao W used quantum teleportation to enter the dragon’s treasury and successfully retrieved the national treasure. But at that moment, the dragon’s offensive barrier activated and trapped Xiao W in Medusa’s Labyrinth.\n\nTrapped at $(0, 0)$, Captain Xiao W quickly examined the structure of Medusa’s Labyrinth and found that the exit is at $(p, q)$. The great dragon Da Y has placed $n$ flame-breath devices in the labyrinth. Each device is described by three parameters $(x, y, \\theta)$, indicating that the device is at coordinate $(x, y)$ on the plane, and that the direction of its breath has inclination angle $\\theta$ relative to the positive $x$-axis. Owing to the dragon’s power, each flame breath is an infinite ray, and Captain Xiao W may not pass through any ray covered by a flame breath (note that the device’s own coordinate is passable if it is not covered by other flame breath). Meanwhile, an Eye of Medusa is placed at negative infinity along the $x$-direction, which forces Captain Xiao W to always move “favoring” the positive $x$-direction (that is, the projection of his movement direction onto the positive $x$-direction must be strictly positive; it cannot be negative or zero), otherwise he will be instantly petrified and unable to escape.\n\nIn a panic, Captain Xiao W must escape Medusa’s Labyrinth before the great dragon Da Y catches him. He turns to the think tank of Country P for help. As the head of the think tank, you must find the shortest safe path to the exit of the labyrinth.", "inputFormat": "The first line contains three integers $n, p, q$, denoting the total number of flame-breath devices and the exit coordinates.\n\nEach of the next $n$ lines contains two integers and one real number $(x, y, \\theta)$, denoting the device’s coordinates and the inclination angle of its flame breath relative to the positive $x$-axis.", "outputFormat": "Output a single real number on one line, the length of the shortest path. Your answer is accepted if its relative error does not exceed $10^{-8}$ (i.e., if $\\frac{|a - o|}{a} \\le 10^{-8}$, where $a$ is the standard answer and $o$ is your output).", "hint": "[Sample Explanation]\n\n![](https://cdn.luogu.com.cn/upload/pic/5107.png)\n\n$30\\%$ of the testdata satisfy $n \\le 300$;\n$60\\%$ of the testdata satisfy $n \\le 2000$;\n$80\\%$ of the testdata satisfy $n \\le 10^5$;\n$100\\%$ of the testdata satisfy $0 \\le n, p, |q|, |x|, |y| \\le 10^6;\\ \\theta \\in [-\\pi, \\pi]$.\nIt is guaranteed that at least one valid path exists, and neither the start point nor the end point lies on any flame ray.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2017/HNOI2017] 队长快跑", "background": null, "description": "众所周知，在 P 国外不远处盘踞着巨龙大 Y。传说中，在远古时代，巨龙大 Y 将 P 国的镇国之宝窃走并藏在了其巢穴中，这吸引着整个 P 国的所有冒险家前去夺回，尤其是皇家卫士队的队长小 W。在 P 国量子科技实验室的帮助下，队长小 W 通过量子传输进入了巨龙大 Y 的藏宝室，并成功夺回了镇国之宝。但此时巨龙布下的攻击性防壁启动，将小 W 困在了美杜莎的迷宫当中。\n\n被困在迷宫 $(0,0)$ 处的队长小 W 快速观察了美杜莎的迷宫的构造，发现迷宫的出口位于 $(p,q)$ 处。巨龙大 Y 在迷宫当中布置了 $n$ 火焰吐息机关，每个机关可以用三个参数 $(x,y,\\theta)$ 表示，分别指明机关位于平面的坐标 $(x,y)$，以及火焰吐息的方向相对于 $x$ 正方向的倾角 $\\theta$。巨龙强大的力量使得火焰吐息有无穷长，且队长小  W 不能通过被火焰吐息覆盖的射线（注意，机关所处的坐标若没有被其他火焰吐息覆盖，则是可以通过的）。同时，迷宫在沿 $x$ 负方向无穷远的地方放置了美杜莎之眼，使得队长小 W 必须倾向于向 $x$ 正方向行动（即队长小 W 的移动方向在 $x$ 正方向上的投影必须为正，不能是负数或零），否则队长小 W 将被瞬间石化而无法逃离。\n\n心急如焚的队长小 W 需要趁着巨龙大 Y 还没将其抓住前逃离美杜莎的迷宫，所以他立马向 P 国智囊团求助，作为智囊团团长的你，一定可以帮队长小 W 找出安全逃至迷宫出口的最短道路。", "inputFormat": "第一行为三个整数 $n,p,q$ 分别表示火焰吐息机关总数以及出口坐标。\n\n接下来 $n$ 行，每行两个整数与一个实数 $(x,y,\\theta)$ 分别表示机关所处的坐标以及火焰吐息的关于 $x$ 正方向的倾角。", "outputFormat": "输出文件仅包含一行一个小数，表示最短道路的长度。当你的答案和标准答案的相对误差不超过 $10^{-8}$ 时（ 即 $\\frac{|a-o|}{a}\\leq10^{-8}$ 时， 其中 $a$ 是标准答案，$o$ 是输出）认为你的答案正确。", "hint": "【样例解释】\n\n ![](https://cdn.luogu.com.cn/upload/pic/5107.png) \n\n$30\\%$ 的数据满足 $n\\leq 300$；\n\n$60\\%$ 的数据满足 $n\\leq 2000$；\n\n$80\\%$ 的数据满足 $n\\leq 10^5$；\n\n$100\\%$ 的数据满足： $0 \\leq n,p, |q|, |x|, |y| \\leq 10^6； \\theta \\in [−\\pi, \\pi]$。\n数据保证至少存在一条合法路径，且起点和终点均不会被火焰路径覆盖。", "locale": "zh-CN"}}}
{"pid": "P3726", "type": "P", "difficulty": 7, "samples": [["2 1 9\n3 2 1", "000000004\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "各省省选", "安徽", "湖南", "O2优化", "枚举", "中国剩余定理 CRT", "逆元"], "title": "[AHOI2017/HNOI2017] 抛硬币", "background": null, "description": "小 A 和小 B 是一对好朋友，他们经常一起愉快的玩耍。最近小 B 沉迷于**师手游，天天刷本，根本无心搞学习。但是已经入坑了几个月，却一次都没有抽到 SSR，让他非常怀疑人生。勤勉的小 A 为了劝说小 B 早日脱坑，认真学习，决定以抛硬币的形式让小 B 明白他是一个彻彻底底的非洲人，从而对这个游戏绝望。两个人同时抛 b 次硬币，如果小 A 的正面朝上的次数大于小 B 正面朝上的次数，则小 A 获胜。\n\n但事实上，小 A 也曾经沉迷过拉拉游戏，而且他一次 UR 也没有抽到过，所以他对于自己的运气也没有太大把握。所以他决定在小 B 没注意的时候作弊，悄悄地多抛几次硬币，当然，为了不让小 B 怀疑，他不会抛太多次。现在小 A 想问你，在多少种可能的情况下，他能够胜过小 B 呢？由于答案可能太大，所以你只需要输出答案在十进制表示下的最后 $k$ 位即可。", "inputFormat": "有多组数据，对于每组数据输入三个数 $a,b,k$，分别代表小 A 抛硬币的次数，小 B 抛硬币的次数，以及最终答案保留多少位整数。", "outputFormat": "对于每组数据，输出一个数，表示最终答案的最后 $k$ 位为多少，若不足 $k$ 位以 $0$ 补全。", "hint": "对于第一组数据，当小 A 抛 $2$ 次硬币，小 B 抛 $1$ 次硬币时，共有 $4$ 种方案使得小 A 正面朝上的次数比小 B 多。\n\n$(01,0), (10,0), (11,0), (11,1)$\n\n对于第二组数据，当小 A 抛 $3$ 次硬币，小 B 抛 $2$ 次硬币时，共有 $16$ 种方案使得小 A 正面朝上的次数比小 B 多。\n\n$(001,00), (010,00), (100,00), (011,00), (101,00), (110,00), (111,00), (011,01)$\n\n$(101,01), (110,01),(111,01), (011,10), (101,10), (110,10), (111,10), (111,11)$\n\n### 数据范围\n\n$10\\%$ 的数据满足 $a,b\\leq 20$。\n\n\n$30\\%$ 的数据满足 $a,b\\leq 100$。\n\n\n$70\\%$ 的数据满足 $a,b\\leq 10^5$，其中有 $20\\%$ 的数据满足 $a=b$。\n\n\n$100\\%$ 的数据满足 $1\\le a,b\\le 10^{15}$，$b\\le a\\le b+10^4$，$1\\le k\\le 9$，数据组数小于等于 $10$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2017/HNOI2017] Coin Tossing", "background": "", "description": "A and B are good friends who often play together. Recently, B has been addicted to a mobile gacha game, grinding every day and not studying at all. After several months, he has never drawn an SSR, which makes him doubt life. The diligent A wants to persuade B to quit the game and study, so he decides to use coin tossing to show B that he is thoroughly unlucky. They would toss coins at the same time; if the number of heads A gets is greater than the number of heads B gets, then A wins.\n\nHowever, A was also once addicted to a gacha game and has never drawn a UR, so he is not confident in his luck. He decides to cheat by secretly tossing a few extra times; to avoid suspicion, he will not toss too many extra times. Let $a$ be the total number of times A tosses, and $b$ be the total number of times B tosses. In how many possible outcomes can A defeat B? Since the answer can be large, you only need to output the last $k$ digits in decimal.", "inputFormat": "Multiple test cases. For each test case, input three integers $a, b, k$, representing the number of times A tosses, the number of times B tosses, and how many digits of the final answer to keep.", "outputFormat": "For each test case, output one number: the last $k$ digits of the answer. If it has fewer than $k$ digits, pad with leading zeros.", "hint": "For the first test case, when A tosses $2$ times and B tosses $1$ time, there are $4$ favorable outcomes in which A gets more heads than B.\n$(01, 0), (10, 0), (11, 0), (11, 1)$.\n\nFor the second test case, when A tosses $3$ times and B tosses $2$ times, there are $16$ favorable outcomes in which A gets more heads than B.\n$(001, 00), (010, 00), (100, 00), (011, 00), (101, 00), (110, 00), (111, 00), (011, 01)$\n$(101, 01), (110, 01), (111, 01), (011, 10), (101, 10), (110, 10), (111, 10), (111, 11)$.\n\nConstraints\n\n$10\\%$ of the testdata satisfies $a, b \\le 20$.\n\n$30\\%$ of the testdata satisfies $a, b \\le 100$.\n\n$70\\%$ of the testdata satisfies $a, b \\le 10^5$, among which $20\\%$ satisfies $a = b$.\n\n$100\\%$ of the testdata satisfies $1 \\le a, b \\le 10^{15}$, $b \\le a \\le b + 10^4$, $1 \\le k \\le 9$, and the number of test cases is at most $10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2017/HNOI2017] 抛硬币", "background": null, "description": "小 A 和小 B 是一对好朋友，他们经常一起愉快的玩耍。最近小 B 沉迷于**师手游，天天刷本，根本无心搞学习。但是已经入坑了几个月，却一次都没有抽到 SSR，让他非常怀疑人生。勤勉的小 A 为了劝说小 B 早日脱坑，认真学习，决定以抛硬币的形式让小 B 明白他是一个彻彻底底的非洲人，从而对这个游戏绝望。两个人同时抛 b 次硬币，如果小 A 的正面朝上的次数大于小 B 正面朝上的次数，则小 A 获胜。\n\n但事实上，小 A 也曾经沉迷过拉拉游戏，而且他一次 UR 也没有抽到过，所以他对于自己的运气也没有太大把握。所以他决定在小 B 没注意的时候作弊，悄悄地多抛几次硬币，当然，为了不让小 B 怀疑，他不会抛太多次。现在小 A 想问你，在多少种可能的情况下，他能够胜过小 B 呢？由于答案可能太大，所以你只需要输出答案在十进制表示下的最后 $k$ 位即可。", "inputFormat": "有多组数据，对于每组数据输入三个数 $a,b,k$，分别代表小 A 抛硬币的次数，小 B 抛硬币的次数，以及最终答案保留多少位整数。", "outputFormat": "对于每组数据，输出一个数，表示最终答案的最后 $k$ 位为多少，若不足 $k$ 位以 $0$ 补全。", "hint": "对于第一组数据，当小 A 抛 $2$ 次硬币，小 B 抛 $1$ 次硬币时，共有 $4$ 种方案使得小 A 正面朝上的次数比小 B 多。\n\n$(01,0), (10,0), (11,0), (11,1)$\n\n对于第二组数据，当小 A 抛 $3$ 次硬币，小 B 抛 $2$ 次硬币时，共有 $16$ 种方案使得小 A 正面朝上的次数比小 B 多。\n\n$(001,00), (010,00), (100,00), (011,00), (101,00), (110,00), (111,00), (011,01)$\n\n$(101,01), (110,01),(111,01), (011,10), (101,10), (110,10), (111,10), (111,11)$\n\n### 数据范围\n\n$10\\%$ 的数据满足 $a,b\\leq 20$。\n\n\n$30\\%$ 的数据满足 $a,b\\leq 100$。\n\n\n$70\\%$ 的数据满足 $a,b\\leq 10^5$，其中有 $20\\%$ 的数据满足 $a=b$。\n\n\n$100\\%$ 的数据满足 $1\\le a,b\\le 10^{15}$，$b\\le a\\le b+10^4$，$1\\le k\\le 9$，数据组数小于等于 $10$。", "locale": "zh-CN"}}}
{"pid": "P3727", "type": "P", "difficulty": 6, "samples": [["1\n3\n1 2\n2 3\n1 2 3\n1", "Mutalisk ride face how to lose?"], ["1\n3\n1 2\n2 3\n1 2 4\n1", "The commentary cannot go on!"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["点分治", "洛谷原创", "枚举", "分治", "深度优先搜索 DFS"], "title": "曼哈顿计划E", "background": "1942 年 6 月，美国开始实施利用核裂变反应来研制原子弹的计划，亦称曼哈顿计划。后来两颗原子弹在广岛和长崎爆炸，世界见证了核武器的威力，并在它的威胁下颤抖不已。2200 年，dedsec 组织利用美国军方的网络安全漏洞渗入了美国的和武器系统，并密谋使用隐藏在曼哈顿的核武器储备毁灭世界。然而 dedsec 的一名成员 Badboy17 反对这一计划，她把这一计划告知了艾登。为了拯救他的家人，避免地球变为废土，艾登不得不再次发挥他的黑客能力拯救世界。\n\n![](https://cdn.luogu.com.cn/upload/pic/5119.png)\n", "description": "艾登尝试黑入 dedsec 的系统并取得控制权，然而 dedsec 有所反应并予以反击。\n\ndedsec 的网络可以看做是一个 $n$ 个点 $n-1$ 条边的连通图（一棵树），每个节点有一个稳定值。\n\n艾登可以选择网络中上的一条链，并对那一条链上的节点进行破解（把这一条链从树上拆下来）。\n\n假设这一条链长度为 $m$，现在你会得到 $m$ 个节点。\n\n然后艾登要和 dedsec 开始攻防战，双方轮流行动，每次可以从任意一个稳定值大于 $0$ 的节点里依照计算规则进行一些操作，操作后，稳定值不能小于 $0$，否则计算机会爆炸，最后不能进行操作的一方算作失败\n\n由于 dedsec 占据了防守的地理优势，dedsec 先进行操作\n\n\n艾登虽然精于黑客技术，但他的手机没电了。现在他把这个消息告诉了你，希望你帮他拯救世界，所以你需要写一个程序，来帮你判断是否存在一种方式，艾登可以取胜。当然，dedsec 的防守可能完美无缺，艾登根本无法取胜，你只好跑到 shelter 里去当试验品。\n", "inputFormat": "输入包含多组测试数据，输入第一行包含一个整数 $T$，表示数据组数。\n\n对于每组测试数据，第一行一个整数 $n$，表示有 $n$ 个点。\n\n第二行至第 $n$ 行，每行两个整数 $u,v$，表示网络中有一条边连接 $u,v$。\n\n第 $n+1$ 行 $n$ 个整数 $w$，第 $w_i$ 表示 $i$ 号节点的稳定值。\n\n第 $n+2$ 行一个整数 $k$，描述操作的规则：\n\n- 如果 $k=1$，你可以减少任意正整数的稳定值。\n- 如果 $k=2$，接下来一行一个正整数 $s$，表示双方每次可以减少 $s$ 的非负整数幂的稳定值。\n- 如果 $k=3$，接下来一行一个正整数 $s$，表示双方每次可以减少大于等于 $s$ 的稳定值。\n- 如果 $k=4$，表示双方每次可以减少任意正整数的稳定值，或者把一个稳定值数量大于等于 $2$ 的节点分裂成两个，分开后的两个节点的稳定值之和等于原来的节点（比如 $7$ 分成 $3+4$）。\n- 如果 $k=5$，双方都不能进行操作。\n", "outputFormat": "对于每一组测试数据，输出一行：\n\n如果存在一种方式，你可以获胜，输出 `Mutalisk ride face how to lose?`。\n\n如果不存在一种方式可以取胜，输出 `The commentary cannot go on!`。\n", "hint": "|测试点|$n\\le$|$k$|$w_i\\le$|\n|:-:|:-:|:-:|:-:|\n|$1$|$50$|$1$|$10^3$|\n|$2$|$3\\times 10^4$|$1$|$10^3$|\n|$3$|$300$|$3$|$10^6$|\n|$4$|$10^3$|$4$|$10^6$|\n|$5$|$3\\times 10^4$|$1$|$10^9$|\n|$6$|$3\\times 10^4$|$2$|$10^9$|\n|$7$|$3\\times 10^4$|$3$|$10^9$|\n|$8$|$3\\times 10^4$|$3$|$10^9$|\n|$9$|$3\\times 10^4$|$4$|$10^9$|\n|$10$|$3\\times 10^4$|$4$|$10^9$|\n\n对于 $100\\%$ 的数据，$T\\le 5$。\n\n保证输入均为正整数\n", "locale": "zh-CN", "translations": {"en": {"title": "Manhattan Project E", "background": "In June 1942, the United States began the plan to develop an atomic bomb using nuclear fission reactions, also known as the Manhattan Project. Later, two atomic bombs exploded in Hiroshima and Nagasaki. The world witnessed the power of nuclear weapons and trembled under their threat. In the year 2200, the dedsec organization infiltrated the U.S. nuclear weapon system by exploiting cybersecurity vulnerabilities, plotting to use the nuclear stockpile hidden in Manhattan to destroy the world. However, a dedsec member, Badboy17, opposed the plan and informed Aiden. To save his family and prevent Earth from becoming a wasteland, Aiden had to once again use his hacking skills to save the world.\n\n![](https://cdn.luogu.com.cn/upload/pic/5119.png)", "description": "Aiden tries to hack into dedsec’s system and seize control, but dedsec responds and fights back.\n\nThe dedsec network can be regarded as a connected graph with $n$ nodes and $n-1$ edges (a tree). Each node has a stability value.\n\nAiden may choose a chain (a simple path) in the network and hack all nodes on that chain (i.e., detach that chain from the tree).\n\nSuppose the chain has length $m$ (i.e., it contains $m$ nodes). You will then obtain $m$ nodes, and the game is played only on these $m$ nodes.\n\nAiden and dedsec then start a battle of moves. They take turns. Each move, a player may choose any node with a stability value greater than $0$ and perform an operation according to the rules below. After the operation, the stability value of that node must not become less than $0$, otherwise the computer will explode. The player who cannot make a move loses.\n\nBecause dedsec has the advantage of defense, dedsec moves first.\n\nAlthough Aiden is skilled at hacking, his phone ran out of battery. He has sent this information to you, hoping you can help save the world. You need to write a program to determine whether there exists a way for Aiden to win. Of course, dedsec’s defense might be flawless, and Aiden may not be able to win at all—in that case, you’ll have to run to the shelter and become a test subject.", "inputFormat": "The input contains multiple test cases. The first line contains an integer $T$, the number of test cases.\n\nFor each test case:\n- The first line contains an integer $n$, the number of nodes.\n- The next $n-1$ lines each contain two integers $u, v$, indicating an edge between $u$ and $v$ in the network.\n- The next line contains $n$ integers $w_1, w_2, \\dots, w_n$, where $w_i$ denotes the stability value of node $i$.\n- The next line contains an integer $k$, describing the move rules:\n  - If $k=1$, you may decrease the stability by any positive integer.\n  - If $k=2$, the next line contains a positive integer $s$, and each move may decrease the stability by a non-negative integer power of $s$.\n  - If $k=3$, the next line contains a positive integer $s$, and each move may decrease the stability by any integer greater than or equal to $s$.\n  - If $k=4$, each move you may either decrease the stability by any positive integer, or split a node with stability at least $2$ into two nodes whose stability values sum to the original (for example, split $7$ into $3+4$).\n  - If $k=5$, neither player can make any move.", "outputFormat": "For each test case, output one line:\n\nIf there exists a way for you to win, output `Mutalisk ride face how to lose?`.\n\nIf there is no way to win, output `The commentary cannot go on!`.", "hint": "| Test point | $n \\le$ | $k$ | $w_i \\le$ |\n|:-:|:-:|:-:|:-:|\n| $1$ | $50$ | $1$ | $10^3$ |\n| $2$ | $3 \\times 10^4$ | $1$ | $10^3$ |\n| $3$ | $300$ | $3$ | $10^6$ |\n| $4$ | $10^3$ | $4$ | $10^6$ |\n| $5$ | $3 \\times 10^4$ | $1$ | $10^9$ |\n| $6$ | $3 \\times 10^4$ | $2$ | $10^9$ |\n| $7$ | $3 \\times 10^4$ | $3$ | $10^9$ |\n| $8$ | $3 \\times 10^4$ | $3$ | $10^9$ |\n| $9$ | $3 \\times 10^4$ | $4$ | $10^9$ |\n| $10$ | $3 \\times 10^4$ | $4$ | $10^9$ |\n\nFor $100\\%$ of the testdata, $T \\le 5$.\n\nAll inputs are positive integers.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "曼哈顿计划E", "background": "1942 年 6 月，美国开始实施利用核裂变反应来研制原子弹的计划，亦称曼哈顿计划。后来两颗原子弹在广岛和长崎爆炸，世界见证了核武器的威力，并在它的威胁下颤抖不已。2200 年，dedsec 组织利用美国军方的网络安全漏洞渗入了美国的和武器系统，并密谋使用隐藏在曼哈顿的核武器储备毁灭世界。然而 dedsec 的一名成员 Badboy17 反对这一计划，她把这一计划告知了艾登。为了拯救他的家人，避免地球变为废土，艾登不得不再次发挥他的黑客能力拯救世界。\n\n![](https://cdn.luogu.com.cn/upload/pic/5119.png)\n", "description": "艾登尝试黑入 dedsec 的系统并取得控制权，然而 dedsec 有所反应并予以反击。\n\ndedsec 的网络可以看做是一个 $n$ 个点 $n-1$ 条边的连通图（一棵树），每个节点有一个稳定值。\n\n艾登可以选择网络中上的一条链，并对那一条链上的节点进行破解（把这一条链从树上拆下来）。\n\n假设这一条链长度为 $m$，现在你会得到 $m$ 个节点。\n\n然后艾登要和 dedsec 开始攻防战，双方轮流行动，每次可以从任意一个稳定值大于 $0$ 的节点里依照计算规则进行一些操作，操作后，稳定值不能小于 $0$，否则计算机会爆炸，最后不能进行操作的一方算作失败\n\n由于 dedsec 占据了防守的地理优势，dedsec 先进行操作\n\n\n艾登虽然精于黑客技术，但他的手机没电了。现在他把这个消息告诉了你，希望你帮他拯救世界，所以你需要写一个程序，来帮你判断是否存在一种方式，艾登可以取胜。当然，dedsec 的防守可能完美无缺，艾登根本无法取胜，你只好跑到 shelter 里去当试验品。\n", "inputFormat": "输入包含多组测试数据，输入第一行包含一个整数 $T$，表示数据组数。\n\n对于每组测试数据，第一行一个整数 $n$，表示有 $n$ 个点。\n\n第二行至第 $n$ 行，每行两个整数 $u,v$，表示网络中有一条边连接 $u,v$。\n\n第 $n+1$ 行 $n$ 个整数 $w$，第 $w_i$ 表示 $i$ 号节点的稳定值。\n\n第 $n+2$ 行一个整数 $k$，描述操作的规则：\n\n- 如果 $k=1$，你可以减少任意正整数的稳定值。\n- 如果 $k=2$，接下来一行一个正整数 $s$，表示双方每次可以减少 $s$ 的非负整数幂的稳定值。\n- 如果 $k=3$，接下来一行一个正整数 $s$，表示双方每次可以减少大于等于 $s$ 的稳定值。\n- 如果 $k=4$，表示双方每次可以减少任意正整数的稳定值，或者把一个稳定值数量大于等于 $2$ 的节点分裂成两个，分开后的两个节点的稳定值之和等于原来的节点（比如 $7$ 分成 $3+4$）。\n- 如果 $k=5$，双方都不能进行操作。\n", "outputFormat": "对于每一组测试数据，输出一行：\n\n如果存在一种方式，你可以获胜，输出 `Mutalisk ride face how to lose?`。\n\n如果不存在一种方式可以取胜，输出 `The commentary cannot go on!`。\n", "hint": "|测试点|$n\\le$|$k$|$w_i\\le$|\n|:-:|:-:|:-:|:-:|\n|$1$|$50$|$1$|$10^3$|\n|$2$|$3\\times 10^4$|$1$|$10^3$|\n|$3$|$300$|$3$|$10^6$|\n|$4$|$10^3$|$4$|$10^6$|\n|$5$|$3\\times 10^4$|$1$|$10^9$|\n|$6$|$3\\times 10^4$|$2$|$10^9$|\n|$7$|$3\\times 10^4$|$3$|$10^9$|\n|$8$|$3\\times 10^4$|$3$|$10^9$|\n|$9$|$3\\times 10^4$|$4$|$10^9$|\n|$10$|$3\\times 10^4$|$4$|$10^9$|\n\n对于 $100\\%$ 的数据，$T\\le 5$。\n\n保证输入均为正整数\n", "locale": "zh-CN"}}}
{"pid": "P3728", "type": "P", "difficulty": 6, "samples": [["3 3\nabb\n", "abb\n"], ["3 5\nabb\n", "bb\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创", "有限状态自动机"], "title": "曼哈顿序列", "background": "为了研究**一类动态仙人掌图上基于完全可持久化后缀全局平衡树维护的按操作序分治的分支定界启发式带花树上下界最小费用流最后输出两点曼哈顿距离的问题**，will需要生成一些字母序列。\n\n\n在写生成器的过程中，因为will太弱了，他遇到了一些问题。现在，需要机智的你来帮他解决这些问题。\n", "description": "序列生成器的工作流程如下：\n\n\n- will先钦定了一个母序列，长度为N，序列里都是小写字母。\n\n- 子序列定义为：将母序列在任意位置删掉零或多个字符剩下的**非空**序列。例如：ab和ac是abc的子序列，但ca不是。\n\n- 显然，长度为N的序列有$2^N-1$个子序列。\n\n- 将这$2^N-1$个子序列按照字典序排列。will会按照字典序依次生成子序列。\n\n- will希望去掉重复的子序列，如果几个子序列重复（按照字典序大小相等），只生成一个。\n\n- 现在，他想知道，生成器第K次生成的子序列是什么？\n", "inputFormat": "- 第一行两个正整数N，K。N表示母序列长度，K表示询问；\n\n- 接下来一行N个小写字母，表示母序列；\n", "outputFormat": "- 一行若干个小写字母表示一个序列，为生成器第K次生成的序列。\n", "hint": "## 样例的解释\n\n对于母序列abb，有7个子序列，按字典序排列：\n\n\n- a\n- ab\n- ab\n- abb\n- b\n- b\n- bb\n\n去重后的第3个是abb；\n\n\n## 数据范围\n\n- 对于20%的数据，$N\\leq 15$；\n\n- 对于50%的数据，$N\\leq 1000$；\n\n- 对于80%的数据，$N\\leq 200000$；\n\n- 对于100%的数据，$N\\leq 1000000, K\\leq 10^9$，且保证存在第K次的输出；\n\n- 前80%数据的时限为1s，后20%的数据时限为2s。\n", "locale": "zh-CN", "translations": {"en": {"title": "Manhattan Sequence", "background": "To study the problem of computing the Manhattan distance between two points as the final output in a \"dynamic cactus graph\" using a branch-and-bound heuristic based on operation-order divide-and-conquer with blossom-tree bounds, maintained by a fully persistent suffix global balanced tree, will needs to generate some letter sequences.\n\nDuring the process of writing the generator, because will is too weak, he encountered some problems. Now, he needs your help to solve them.", "description": "The sequence generator works as follows:\n\n- will first fixes a mother sequence of length $N$, consisting of lowercase letters.\n- A subsequence is defined as a non-empty sequence obtained by deleting zero or more characters at arbitrary positions from the mother sequence. For example: \"a b\" and \"a c\" are subsequences of \"a b c\", but \"c a\" is not.\n- Obviously, a sequence of length $N$ has $2^N - 1$ subsequences.\n- Sort these $2^N - 1$ subsequences in lexicographical order. will will generate subsequences in this order.\n- will wants to remove duplicate subsequences. If several subsequences are identical (i.e., equal in lexicographical order), only one is generated.\n- Now, he wants to know: what is the subsequence generated on the $K$-th time?", "inputFormat": "- The first line contains two positive integers $N$, $K$. $N$ is the length of the mother sequence, and $K$ is the query.\n- The second line contains $N$ lowercase letters, representing the mother sequence.", "outputFormat": "Output one line consisting of lowercase letters: the subsequence generated on the $K$-th time.", "hint": "Sample Explanation:\n\nFor the mother sequence \"a b b\", there are 7 subsequences, sorted in lexicographical order:\n\n- a.\n- a b.\n- a b.\n- a b b.\n- b.\n- b.\n- b b.\n\nAfter removing duplicates, the 3rd one is \"a b b\".\n\nConstraints:\n\n- For 20% of the testdata, $N \\leq 15$.\n- For 50% of the testdata, $N \\leq 1000$.\n- For 80% of the testdata, $N \\leq 200000$.\n- For 100% of the testdata, $N \\leq 1000000$, $K \\leq 10^9$, and it is guaranteed that the $K$-th output exists.\n- The time limit for the first 80% of the testdata is 1 s, and for the last 20% of the testdata is 2 s.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "曼哈顿序列", "background": "为了研究**一类动态仙人掌图上基于完全可持久化后缀全局平衡树维护的按操作序分治的分支定界启发式带花树上下界最小费用流最后输出两点曼哈顿距离的问题**，will需要生成一些字母序列。\n\n\n在写生成器的过程中，因为will太弱了，他遇到了一些问题。现在，需要机智的你来帮他解决这些问题。\n", "description": "序列生成器的工作流程如下：\n\n\n- will先钦定了一个母序列，长度为N，序列里都是小写字母。\n\n- 子序列定义为：将母序列在任意位置删掉零或多个字符剩下的**非空**序列。例如：ab和ac是abc的子序列，但ca不是。\n\n- 显然，长度为N的序列有$2^N-1$个子序列。\n\n- 将这$2^N-1$个子序列按照字典序排列。will会按照字典序依次生成子序列。\n\n- will希望去掉重复的子序列，如果几个子序列重复（按照字典序大小相等），只生成一个。\n\n- 现在，他想知道，生成器第K次生成的子序列是什么？\n", "inputFormat": "- 第一行两个正整数N，K。N表示母序列长度，K表示询问；\n\n- 接下来一行N个小写字母，表示母序列；\n", "outputFormat": "- 一行若干个小写字母表示一个序列，为生成器第K次生成的序列。\n", "hint": "## 样例的解释\n\n对于母序列abb，有7个子序列，按字典序排列：\n\n\n- a\n- ab\n- ab\n- abb\n- b\n- b\n- bb\n\n去重后的第3个是abb；\n\n\n## 数据范围\n\n- 对于20%的数据，$N\\leq 15$；\n\n- 对于50%的数据，$N\\leq 1000$；\n\n- 对于80%的数据，$N\\leq 200000$；\n\n- 对于100%的数据，$N\\leq 1000000, K\\leq 10^9$，且保证存在第K次的输出；\n\n- 前80%数据的时限为1s，后20%的数据时限为2s。\n", "locale": "zh-CN"}}}
{"pid": "P3729", "type": "P", "difficulty": 6, "samples": [["4 5 3\n1 1 1 1\n1 2\n1 3\n2 3\n1 4\n2 4\n1\n3\n5", "nan\n2\nNuclear launch detected"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创", "枚举"], "title": "曼哈顿计划EX", "background": "- 曼哈顿计划EX， The X Makes It Sound Cool\n\n- 艾登黑进了dedsec的系统以后，发现核弹发射已经进入了倒计时，他必须停止核弹的发射进程。\n\n![](https://cdn.luogu.com.cn/upload/pic/5120.png)\n", "description": "- 艾登拥有一个计算机网络，每一台计算机都至少有着Intel Xeon E50 v40 + 40路GTX10800Titan的恐怖配置，并由无线网络直接或间接连接，这可以用一个无向连通图来表示。但是他的计算机网络有一个问题——不够安全，dedsec可能会攻击他的网络，切断一些无线连接，从而导致整个计算机网络不连通。为了避免这种情况，艾登决定从这些计算机中挑出一些计算机作为计算节点，其他计算机作为信息的中转站，进行停止核弹发射进程的任务。虽然台台都是顶配，但是艾登的计算机也会有从山寨厂买回的配件和原装正版配件的差别——每台电脑的工作能力是不同的，记为$ w_{i}$。现在艾登想知道，对于一个工作能力的要求，整个网络的安全系数最大是多少？\n\n\n- 设给出的图为$G = (V , E)$，其中$V$ = $V_{1}$（计算节点） + $V_{2}$（中转节点）\n\n- 我们定义安全系数k为：最大的k，使得任意两点$u,v\\in V_{1}$都至少有k条互不相交的u到v的链（互不相交定义为：没有重复的边，可以重复有重复的点）\n\n- 我们定义整个图的工作能力$W = \\sum_{v \\in V_{1}}{w_{v}}$\n", "inputFormat": "- 第1行，三个整数n,m,q表示有n台计算机，m个无线网络，q次询问\n\n- 第2行，n个整数，表示计算机的$w_{i}$\n\n- 第3行到m+2行，每行两个整数u,v，表示有u，v之间存在直接的无线网络，什么都不保证\n\n- 第m+3行到m+q+2行，每行一个整数k，表示一个询问\n", "outputFormat": "- 一共q行，每行一个整数，表示要达到k的工作能力的前提下，整个网络最大的安全系数，如果只用一台计算机就能满足要求，输出\"nan\"\n\n- 如果没有办法满足需求，输出\"Nuclear launch detected\"\n\n- 仅输出nan并不能得分\n", "hint": " ![](https://cdn.luogu.com.cn/upload/pic/5114.png) \n\n## 样例解释\n\n- 对于询问1，选择任何一台计算机作为计算节点都是一个合法答案\n\n- 对于询问2，至少要选择3台计算机，任选三个都是合法方案。选出的三个点构成三角形，对于任意两个点都有两种相互到达的方法（在三角形上顺时针和逆时针走），所以答案是2\n\n- 对于询问3，选择所有的计算机都不足以满足任务\n\n\n## 数据规模\n\n- 对于30%的数据，n<=20，保证 $qn^{4}$ 不大于1e8\n\n- 对于100%的数据，n<=550,m<=3000,q<=2017,询问以及$w_{i}$均不超过$10^{6}$\n\n- 所有数字均为正整数\n", "locale": "zh-CN", "translations": {"en": {"title": "Manhattan Project EX", "background": "- Manhattan Project EX, The X Makes It Sound Cool.\n- After Aiden hacked into DedSec’s system, he discovered that the nuclear launch had entered its countdown. He must stop the launch process.\n\n![](https://cdn.luogu.com.cn/upload/pic/5120.png)", "description": "- Aiden has a computer network. Each computer has an insane configuration of at least Intel Xeon E50 v40 + 40-way GTX10800Titan, and they are connected directly or indirectly by wireless links, which can be represented by an undirected connected graph. However, his network is not secure enough: DedSec may attack it and cut some wireless links, causing the network to become disconnected. To prevent this, Aiden decides to select some computers as computing nodes, and use the others as relay nodes, to carry out the task of stopping the nuclear launch. Although every machine is high-end, there are differences between knockoff parts and genuine parts—each computer has a different work capacity, denoted $ w_{i}$. Now Aiden wants to know: given a required work capacity, what is the maximum safety coefficient of the entire network?\n\n- Let the given graph be $G = (V , E)$, where $V$ = $V_{1}$ (computing nodes) + $V_{2}$ (relay nodes).\n\n- We define the safety coefficient $k$ as the largest $k$ such that for any two vertices $u, v \\in V_{1}$, there are at least $k$ edge-disjoint paths from $u$ to $v$ (edge-disjoint means no repeated edges; repeated vertices are allowed).\n\n- We define the total work capacity of the selected nodes as $W = \\sum_{v \\in V_{1}}{w_{v}}$.\n\n- Constraints:\n  - For 30% of the testdata, $qn^{4}$ is no greater than 1e8.\n  - For 100% of the testdata, $n \\le 550$, $m \\le 3000$, $q \\le 2017$, and each query and $w_{i}$ are no more than $10^{6}$.\n  - All numbers are positive integers.", "inputFormat": "- The first line contains three integers $n, m, q$, the number of computers, wireless links, and queries.\n- The second line contains $n$ integers, the $w_{i}$ of the computers.\n- Lines 3 to $m+2$: each line contains two integers $u, v$, indicating a direct wireless link between $u$ and $v$; no other guarantees.\n- Lines $m+3$ to $m+q+2$: each line contains one integer $K$, representing the required total work capacity for that query.", "outputFormat": "- Output $q$ lines. For each query, output one integer: under the requirement that the total work capacity is at least $K$, the maximum safety coefficient of the network. If the requirement can be met using only one computer, output \"nan\".\n- If it is impossible to meet the requirement, output \"Nuclear launch detected\".\n- Outputting only \"nan\" will not score.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/5114.png)\n\n- For query 1, choosing any single computer as a computing node is a valid solution.\n- For query 2, at least three computers must be selected; any three form a valid solution. The three selected vertices form a triangle; for any two vertices there are two ways to reach each other (clockwise and counterclockwise along the triangle), so the answer is 2.\n- For query 3, selecting all computers is still insufficient.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "曼哈顿计划EX", "background": "- 曼哈顿计划EX， The X Makes It Sound Cool\n\n- 艾登黑进了dedsec的系统以后，发现核弹发射已经进入了倒计时，他必须停止核弹的发射进程。\n\n![](https://cdn.luogu.com.cn/upload/pic/5120.png)\n", "description": "- 艾登拥有一个计算机网络，每一台计算机都至少有着Intel Xeon E50 v40 + 40路GTX10800Titan的恐怖配置，并由无线网络直接或间接连接，这可以用一个无向连通图来表示。但是他的计算机网络有一个问题——不够安全，dedsec可能会攻击他的网络，切断一些无线连接，从而导致整个计算机网络不连通。为了避免这种情况，艾登决定从这些计算机中挑出一些计算机作为计算节点，其他计算机作为信息的中转站，进行停止核弹发射进程的任务。虽然台台都是顶配，但是艾登的计算机也会有从山寨厂买回的配件和原装正版配件的差别——每台电脑的工作能力是不同的，记为$ w_{i}$。现在艾登想知道，对于一个工作能力的要求，整个网络的安全系数最大是多少？\n\n\n- 设给出的图为$G = (V , E)$，其中$V$ = $V_{1}$（计算节点） + $V_{2}$（中转节点）\n\n- 我们定义安全系数k为：最大的k，使得任意两点$u,v\\in V_{1}$都至少有k条互不相交的u到v的链（互不相交定义为：没有重复的边，可以重复有重复的点）\n\n- 我们定义整个图的工作能力$W = \\sum_{v \\in V_{1}}{w_{v}}$\n", "inputFormat": "- 第1行，三个整数n,m,q表示有n台计算机，m个无线网络，q次询问\n\n- 第2行，n个整数，表示计算机的$w_{i}$\n\n- 第3行到m+2行，每行两个整数u,v，表示有u，v之间存在直接的无线网络，什么都不保证\n\n- 第m+3行到m+q+2行，每行一个整数k，表示一个询问\n", "outputFormat": "- 一共q行，每行一个整数，表示要达到k的工作能力的前提下，整个网络最大的安全系数，如果只用一台计算机就能满足要求，输出\"nan\"\n\n- 如果没有办法满足需求，输出\"Nuclear launch detected\"\n\n- 仅输出nan并不能得分\n", "hint": " ![](https://cdn.luogu.com.cn/upload/pic/5114.png) \n\n## 样例解释\n\n- 对于询问1，选择任何一台计算机作为计算节点都是一个合法答案\n\n- 对于询问2，至少要选择3台计算机，任选三个都是合法方案。选出的三个点构成三角形，对于任意两个点都有两种相互到达的方法（在三角形上顺时针和逆时针走），所以答案是2\n\n- 对于询问3，选择所有的计算机都不足以满足任务\n\n\n## 数据规模\n\n- 对于30%的数据，n<=20，保证 $qn^{4}$ 不大于1e8\n\n- 对于100%的数据，n<=550,m<=3000,q<=2017,询问以及$w_{i}$均不超过$10^{6}$\n\n- 所有数字均为正整数\n", "locale": "zh-CN"}}}
{"pid": "P3730", "type": "P", "difficulty": 6, "samples": [["4 4  \n2 3 3 3  \n1 4 1  \n1 4 2  \n1 3 2\n1 3 3", "1  \n3  \n2  \n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["莫队", "二分", "离散化", "洛谷原创", "分块"], "title": "曼哈顿交易", "background": "will 在曼哈顿开了一家交易所，每天，前来买卖股票的人络绎不绝。\n\n\n现在，will 想要了解持股的情况。由于来交♂易的人实在是太多了，需要你写一个程序来帮他完成这个任务。\n", "description": "- 前来交易的 $N$ 个人排成了一行，为了简便起见，每个人都只持有一种股票。\n- 不同的的人可能会持有相同的股票。\n- 定义一种股票的热度为持有该股票的人数。\n- 每次，will 会给出这样的询问：在一段连续区间的人之中，热度第 $k$ 小的股票的热度是多少？\n", "inputFormat": "- 第一行两个正整数 $N,M$，分别表示人数和询问的次数。\n- 接下来一行 $N$ 个正整数，表示每个人所持的股票 $a_i$。\n- 接下来 $M$ 行，每行三个正整数 $l,r,k$，表示询问区间 $[l, r]$ 中的第 $k$ 小的热度，保证 $l\\leq r$。\n", "outputFormat": "- 对于每个询问，输出一行一个数，表示区间 $[l, r]$ 中的第 $k$ 小的热度值。\n- 如果 $k$ 大于区间里股票的种类数，输出 $-1$。\n", "hint": "对于 $20\\%$ 的数据，$N,M\\leq 1000$。\n\n对于另外 $10\\%$ 的数据，所有的 $l=1, r=N$。\n\n对于 $100\\%$ 的数据，$1\\leq N, M\\leq 10^5$，$1\\leq a_i\\leq 10^9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Manhattan Trading", "background": "Will opened an exchange in Manhattan. Every day, people come in a steady stream to buy and sell stocks.\n\nNow, Will wants to understand the stock holdings. Because there are simply too many people coming to trade, he needs you to write a program to help him with this task.", "description": "- $N$ people line up in a row. For simplicity, each person holds exactly one stock.\n- Different people may hold the same stock.\n- Define the popularity of a stock as the number of people who hold that stock.\n- Each time, Will will ask a query: among the people in a contiguous interval, what is the popularity of the stock with the $k$-th smallest popularity?", "inputFormat": "- The first line contains two positive integers $N,M$, representing the number of people and the number of queries.\n- The next line contains $N$ positive integers, where $a_i$ is the stock held by the $i$-th person.\n- The next $M$ lines each contain three positive integers $l,r,k$, representing a query asking for the $k$-th smallest popularity in the interval $[l, r]$. It is guaranteed that $l\\leq r$.", "outputFormat": "- For each query, output one integer on a separate line, which is the $k$-th smallest popularity value in the interval $[l, r]$.\n- If $k$ is greater than the number of distinct stocks in the interval, output $-1$.", "hint": "For $20\\%$ of the testdata, $N,M\\leq 1000$.\n\nFor another $10\\%$ of the testdata, all queries have $l=1, r=N$.\n\nFor $100\\%$ of the testdata, $1\\leq N, M\\leq 10^5$，$1\\leq a_i\\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "曼哈顿交易", "background": "will 在曼哈顿开了一家交易所，每天，前来买卖股票的人络绎不绝。\n\n\n现在，will 想要了解持股的情况。由于来交♂易的人实在是太多了，需要你写一个程序来帮他完成这个任务。\n", "description": "- 前来交易的 $N$ 个人排成了一行，为了简便起见，每个人都只持有一种股票。\n- 不同的的人可能会持有相同的股票。\n- 定义一种股票的热度为持有该股票的人数。\n- 每次，will 会给出这样的询问：在一段连续区间的人之中，热度第 $k$ 小的股票的热度是多少？\n", "inputFormat": "- 第一行两个正整数 $N,M$，分别表示人数和询问的次数。\n- 接下来一行 $N$ 个正整数，表示每个人所持的股票 $a_i$。\n- 接下来 $M$ 行，每行三个正整数 $l,r,k$，表示询问区间 $[l, r]$ 中的第 $k$ 小的热度，保证 $l\\leq r$。\n", "outputFormat": "- 对于每个询问，输出一行一个数，表示区间 $[l, r]$ 中的第 $k$ 小的热度值。\n- 如果 $k$ 大于区间里股票的种类数，输出 $-1$。\n", "hint": "对于 $20\\%$ 的数据，$N,M\\leq 1000$。\n\n对于另外 $10\\%$ 的数据，所有的 $l=1, r=N$。\n\n对于 $100\\%$ 的数据，$1\\leq N, M\\leq 10^5$，$1\\leq a_i\\leq 10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P3731", "type": "P", "difficulty": 6, "samples": [["5 3\n1 5\n2 4\n2 5", "2\n1 5\n2 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "河南", "各省省选", "强连通分量", "二分图"], "title": "[HAOI2017] 新型城市化", "background": "", "description": "Anihc 国有 $n$ 座城市。城市之间存在一些贸易合作关系，如果城市 $x$ 与城市 $y$ 之间存在贸易协定，那么城市 $x$ 和城市 $y$ 则是一对贸易伙伴（注意： $(x,y)$ 和 $(y,x)$ 是同一对城市）。\n\n为了实现新型城市化，实现统筹城乡一体化以及发挥城市群辐射与带动作用，国家决定规划新型城市关系。一些城市能够被称为城市群的条件是：这些城市两两都是贸易伙伴。由于Anihc 国之前也一直很重视城市关系建设，所以可以保证在目前已存在的贸易合作关系的情况下 Anihc 的 $n$ 座城市可以恰好被划分为不超过两个城市群。\n\n为了建设新型城市关系 Anihc 国想要选出两个之前并不是贸易伙伴的城市，使这两个城市成为贸易伙伴，并且要求在这两个城市成为贸易伙伴之后，最大城市群的大小至少比他们成为贸易伙伴之前的最大城市群的大小增加 $1$。\n\nAnihc 国需要在下一次会议上讨论扩大建设新型城市关系的问题，所以要请你求出在哪些城市之间建立贸易伙伴关系可以使得这个条件成立，即建立此关系前后的最大城市群的大小至少相差 $1$。", "inputFormat": "第一行 $2$ 个整数 $n,m$，表示城市的个数，目前还没有建立贸易伙伴关系的城市的对数。\n\n接下来 $m$ 行，每行 $2$ 个整数 $x,y$ 表示城市 $x,y$ 之间目前还没有建立贸易伙伴关系。", "outputFormat": "第一行 $1$ 个整数 $\\text{ans}$，表示符合条件的城市的对数。\n\n接下来 $\\text{ans}$ 行，每行两个整数，表示一对可以选择来建立贸易伙伴关系的城市。对于一对城市 $x,y$，请先输出编号更小的那一个。最后城市对与城市对之间顺序请按照字典序从小到大输出。", "hint": "数据点 $1$：$n\\le 16$；\n\n数据点 $2$：$n\\le 16$；\n\n数据点 $3\\sim 5$：$n\\le 100$；\n\n数据点 $6$：$n\\le 500$；\n\n数据点 $7\\sim10$：$n\\le 10^4$。\n\n对于所有的数据保证： $n \\le 10^4,0 \\le m \\le \\min(1.5\\times 10^5,\\dfrac{n(n-1)}{2})$。保证输入的城市关系中不会出现 $(x,x)$ 这样的关系，同一对城市也不会出现两次（无重边，无自环）。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2017] New-type Urbanization", "background": "", "description": "There are $n$ cities in Anihc. Some cities have trade cooperation relations: if there is a trade agreement between city $x$ and city $y$, then city $x$ and city $y$ are a pair of trade partners (note: $(x,y)$ and $(y,x)$ denote the same pair of cities).\n\nTo implement new-type urbanization, integrate urban and rural development, and leverage the radiation and driving role of city clusters, the country decides to plan new city relations. A set of cities can be called a city cluster if every pair among them are trade partners. Since Anihc has long attached importance to building city relations, it is guaranteed that, under the currently existing trade cooperation relations, the $n$ cities can be partitioned into at most two city clusters.\n\nTo build new city relations, Anihc wants to select two cities that are not yet trade partners, make them trade partners, and requires that after these two cities become trade partners, the size of the largest city cluster is at least $1$ larger than the size of the largest city cluster before they became partners.\n\nAnihc needs to discuss expanding the construction of new city relations at the next meeting, so you are asked to find all pairs of cities between which establishing a trade partnership would satisfy this condition, i.e., the size of the largest city cluster after establishing the partnership is at least $1$ greater than before.", "inputFormat": "The first line contains $2$ integers $n, m$, the number of cities and the number of unordered city pairs that have not yet established a trade partnership.\n\nThe next $m$ lines each contain $2$ integers $x, y$, indicating that cities $x$ and $y$ have not yet established a trade partnership.", "outputFormat": "Output one integer $\\text{ans}$ on the first line, the number of qualifying city pairs.\n\nThen output $\\text{ans}$ lines, each containing two integers, representing a pair of cities that can be chosen to establish a trade partnership. For a pair of cities $x, y$, output the smaller index first. Finally, sort the pairs in ascending lexicographic order.", "hint": "Test point $1$: $n \\le 16$.\n\nTest point $2$: $n \\le 16$.\n\nTest points $3 \\sim 5$: $n \\le 100$.\n\nTest point $6$: $n \\le 500$.\n\nTest points $7 \\sim 10$: $n \\le 10^4$.\n\nFor all testdata, it is guaranteed that $n \\le 10^4, 0 \\le m \\le \\min(1.5 \\times 10^5, \\dfrac{n(n-1)}{2})$. It is guaranteed that there is no relation of the form $(x, x)$ in the input, and no pair of cities appears twice (no multiple edges, no self-loops).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2017] 新型城市化", "background": "", "description": "Anihc 国有 $n$ 座城市。城市之间存在一些贸易合作关系，如果城市 $x$ 与城市 $y$ 之间存在贸易协定，那么城市 $x$ 和城市 $y$ 则是一对贸易伙伴（注意： $(x,y)$ 和 $(y,x)$ 是同一对城市）。\n\n为了实现新型城市化，实现统筹城乡一体化以及发挥城市群辐射与带动作用，国家决定规划新型城市关系。一些城市能够被称为城市群的条件是：这些城市两两都是贸易伙伴。由于Anihc 国之前也一直很重视城市关系建设，所以可以保证在目前已存在的贸易合作关系的情况下 Anihc 的 $n$ 座城市可以恰好被划分为不超过两个城市群。\n\n为了建设新型城市关系 Anihc 国想要选出两个之前并不是贸易伙伴的城市，使这两个城市成为贸易伙伴，并且要求在这两个城市成为贸易伙伴之后，最大城市群的大小至少比他们成为贸易伙伴之前的最大城市群的大小增加 $1$。\n\nAnihc 国需要在下一次会议上讨论扩大建设新型城市关系的问题，所以要请你求出在哪些城市之间建立贸易伙伴关系可以使得这个条件成立，即建立此关系前后的最大城市群的大小至少相差 $1$。", "inputFormat": "第一行 $2$ 个整数 $n,m$，表示城市的个数，目前还没有建立贸易伙伴关系的城市的对数。\n\n接下来 $m$ 行，每行 $2$ 个整数 $x,y$ 表示城市 $x,y$ 之间目前还没有建立贸易伙伴关系。", "outputFormat": "第一行 $1$ 个整数 $\\text{ans}$，表示符合条件的城市的对数。\n\n接下来 $\\text{ans}$ 行，每行两个整数，表示一对可以选择来建立贸易伙伴关系的城市。对于一对城市 $x,y$，请先输出编号更小的那一个。最后城市对与城市对之间顺序请按照字典序从小到大输出。", "hint": "数据点 $1$：$n\\le 16$；\n\n数据点 $2$：$n\\le 16$；\n\n数据点 $3\\sim 5$：$n\\le 100$；\n\n数据点 $6$：$n\\le 500$；\n\n数据点 $7\\sim10$：$n\\le 10^4$。\n\n对于所有的数据保证： $n \\le 10^4,0 \\le m \\le \\min(1.5\\times 10^5,\\dfrac{n(n-1)}{2})$。保证输入的城市关系中不会出现 $(x,x)$ 这样的关系，同一对城市也不会出现两次（无重边，无自环）。", "locale": "zh-CN"}}}
{"pid": "P3732", "type": "P", "difficulty": 6, "samples": [["6 3\n010110\n2 5\n1 6\n1 2", "4\n6\n0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "河南", "各省省选", "排序", "进制", "字典树 Trie"], "title": "[HAOI2017] 供给侧改革", "background": "", "description": "你调查了某个产业近来 $n$ 个时期的供求关系平衡情况，每个时期的情况都用 $0$ 或 $1$ 中的一个数字来表示。于是这就是—个长度为 $n$ 的 $\\texttt{01}$ 字符串 $S$。为了更好的了解这一些数据，你需要解决一些询问，我们令 $\\text{data}(L,R)$ 表示：在字符串 $S$ 中，起始位置在 $[L,R]$ 之间的这些后缀之中，具有最长公共前缀的两个后缀的最长公共前缀的长度。\n\n对于每一个询问 $L,R$，求：\n\n$$ans = \\sum_{L \\leqslant i < R} \\text{data}(i,R)$$\n\n数据范围保证，串 $S$ 中的每一位都是在 $0$ 和 $1$ 之间随机产生的。", "inputFormat": "第一行 $2$ 个整数 $n,Q$，表示字符串的长度，以及询问个数。\n\n接下来一行长度为 $n$ 的一个 $\\texttt{01}$ 串 $S$。\n\n接下来 $Q$ 行，每行 $2$ 个整数 $L,R$，一个询问 $L,R$。", "outputFormat": "\n共 $Q$ 行，每行一个整数，表示对应询问的答案。", "hint": "【数据规模与约定】\n\n|数据点|$n$ 的规模|$Q$ 的规模|\n|:-:|:-:|:-:|\n|$1,2$|$\\leqslant 20$|$\\leqslant 20$|\n|$3,4$|$\\leqslant 100$|$\\leqslant 100$|\n|$5,6$|$\\leqslant 5 \\times 10^3$|$\\leqslant 5 \\times 10^3$|\n|$7,8,9,10$|$\\leqslant 10^5$|$\\leqslant 10^5$|\n\n\n\n对于所有的数据保证：$n \\leqslant 10^5$，$Q \\leqslant 10^5$，$1 \\leqslant L < R \\leqslant n$，$\\texttt{01}$ 串随机生成。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2017] Supply-side Reform", "background": "# Description\n\nYou investigated the supply-demand balance of an industry over the past $ n $ periods. Each period is represented by a single digit, either $ 0 $ or $ 1 $. Thus, this forms a $ \\texttt{01} $ string $ S $ of length $ n $. To better understand the data, you need to answer several queries. Let $ \\text{data}(L, R) $ denote: among all suffixes of $ S $ whose starting positions lie in $ [L, R] $, the length of the longest common prefix of the two suffixes that achieve the maximum common prefix.\n\nFor each query $ L, R $, compute:\n$$\nans = \\sum_{L \\leqslant i < R} \\text{data}(i, R).\n$$\n\nIt is guaranteed that each character of $ S $ is randomly generated as $ 0 $ or $ 1 $.", "description": "", "inputFormat": "", "outputFormat": "Output $ Q $ lines, each containing a single integer, the answer to the corresponding query.", "hint": "[Constraints and Notes]\n\n| Data Point | Scale of $ n $ | Scale of $ Q $ |\n|:-:|:-:|:-:|\n| $1, 2$ | $ \\leqslant 20 $ | $ \\leqslant 20 $ |\n| $3, 4$ | $ \\leqslant 100 $ | $ \\leqslant 100 $ |\n| $5, 6$ | $ \\leqslant 5 \\times 10^3 $ | $ \\leqslant 5 \\times 10^3 $ |\n| $7, 8, 9, 10$ | $ \\leqslant 10^5 $ | $ \\leqslant 10^5 $ |\n\nFor all testdata, it is guaranteed that $ n \\leqslant 10^5 $, $ Q \\leqslant 10^5 $, $ 1 \\leqslant L < R \\leqslant n $, and the $ \\texttt{01} $ string is randomly generated.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2017] 供给侧改革", "background": "", "description": "你调查了某个产业近来 $n$ 个时期的供求关系平衡情况，每个时期的情况都用 $0$ 或 $1$ 中的一个数字来表示。于是这就是—个长度为 $n$ 的 $\\texttt{01}$ 字符串 $S$。为了更好的了解这一些数据，你需要解决一些询问，我们令 $\\text{data}(L,R)$ 表示：在字符串 $S$ 中，起始位置在 $[L,R]$ 之间的这些后缀之中，具有最长公共前缀的两个后缀的最长公共前缀的长度。\n\n对于每一个询问 $L,R$，求：\n\n$$ans = \\sum_{L \\leqslant i < R} \\text{data}(i,R)$$\n\n数据范围保证，串 $S$ 中的每一位都是在 $0$ 和 $1$ 之间随机产生的。", "inputFormat": "第一行 $2$ 个整数 $n,Q$，表示字符串的长度，以及询问个数。\n\n接下来一行长度为 $n$ 的一个 $\\texttt{01}$ 串 $S$。\n\n接下来 $Q$ 行，每行 $2$ 个整数 $L,R$，一个询问 $L,R$。", "outputFormat": "\n共 $Q$ 行，每行一个整数，表示对应询问的答案。", "hint": "【数据规模与约定】\n\n|数据点|$n$ 的规模|$Q$ 的规模|\n|:-:|:-:|:-:|\n|$1,2$|$\\leqslant 20$|$\\leqslant 20$|\n|$3,4$|$\\leqslant 100$|$\\leqslant 100$|\n|$5,6$|$\\leqslant 5 \\times 10^3$|$\\leqslant 5 \\times 10^3$|\n|$7,8,9,10$|$\\leqslant 10^5$|$\\leqslant 10^5$|\n\n\n\n对于所有的数据保证：$n \\leqslant 10^5$，$Q \\leqslant 10^5$，$1 \\leqslant L < R \\leqslant n$，$\\texttt{01}$ 串随机生成。", "locale": "zh-CN"}}}
{"pid": "P3733", "type": "P", "difficulty": 6, "samples": [["4 4 3\n1 2 1110\n1 3 10\n2 4 1110\n2 3 100\nAdd 3 4 11\nChange 1 101\nCancel 1", "1000\n1001\n1111\n1000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "河南", "线段树", "各省省选", "分治", "线性基", "线段树分治"], "title": "[HAOI2017] 八纵八横", "background": "", "description": "Anihc 国有 $n$ 个城市，这 $n$ 个城市从 $1$ 到 $n$ 编号，$1$ 号城市为首都。城市间初始时有 $m$ 条高速公路，每条高速公路都有一个非负整数的经济影响因子，每条高速公路的两端都是城市（可能两端是同一个城市），保证任意两个城市都可以通过高速公路互达。\n\n国正在筹划“八纵八横”的高铁建设计划，计划要修建一些高速铁路，每条高速铁路两端也都是城市（可能两端是同一个城市)，也都有一个非负整数的经济影响因子。国家还计划在“八纵八横”计划建成之后，将“一带一路”扩展为“一带一路一环”，增加“内陆城市经济环”即选择一条从首都出发沿若一系列高铁与高速公路走的路径，每条高铁或高速公路可以经过多次，每座城市也可以经过多次，最后路径又在首都结束。令“内陆城市经济环”的 GDP 为依次将这条路径上所经过的高铁或高速公路的经济影响因子异或起来（一条路经过多次则会被计算多次）。\n\n现在 Anihc 在会议上讨论“八纵八横”的建设计划方案，他们会不断地修改计划方案，希望你能实时反馈对于当前的“八纵八横”的建设计划的方案“内陆城市经济环”的最大是多少。\n\n初始时，八纵八横计划中不包含任何一条高铁，有以下 $3$ 种操作：\n\n`Add x y z`\n\n在计划中给在城市 $x$ 和城市 $y$ 之间建设一条高铁，其经济影响因子为 $z$，如果这是第 $k$ 个 `Add` 操作，则将这条高铁命名为 $k$ 号高铁。\n\n`Cancel k`\n\n将计划中的 $k$ 号高铁取消掉，保证此时 $k$ 号高铁一定存在。\n\n`Change k z`\n\n表示将第 $k$ 号高铁的经济影响因子更改为 $z$，保证此时 $k$ 号高铁一定存在。\n", "inputFormat": "第一行 $3$ 个整数 $n,m,Q$，表示城市个数，高速公路条数，操作个数。\n\n接下来 $m$ 行，每行 $3$ 个整数表示高速公路的信息。\n\n接下来 $Q$ 行，每行为一个操作。\n\n注意：输入的所有经济影响因子都将以二进制的形式从高位到低位给出。\n", "outputFormat": "第一行一个整数。表示如果不修建任何高铁，“内陆城市经济环”的 GDP 最大值。\n\n接下 $Q$ 行每行一个整数，表示进行了对应的每一个操作之后，对于当前的计划，“内陆城市经济环”的 GDP 最大值。\n\n注意：输出的答案也要以二进制的形式从高位到低位给出。\n", "hint": "### 数据规模与约定\n\n令所有的经济因子二进制表示的最多位数为 $len$。数据满足以下表格：\n\n| 数据点 | $n$ | $m$ | $Q$ | $len$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| 1 | $\\leq 5$ | $\\leq 8$ | $0$ | $\\leq 31$ |  |\n| 2 | $\\leq 100$ | $=n + 1$ | $0$ | $\\leq 100$ |  |\n| 3 | $\\leq 100$ | $\\leq 100$ | $0$ | $\\leq 100$ |  |\n| 4 | $\\leq 500$ | $\\leq 500$ | $0$ | $\\leq 1000$ |  |\n| 5 |$\\leq 100$ | $\\leq 100$ | $\\leq 100$ | $\\leq 200$ | 只存在 `Add` 操作 |\n| 6 | $\\leq 500$ | $\\leq 500$ | $\\leq 200$ | $\\leq 1000$ |  |\n| 7 | $\\leq 100$ | $\\leq 100$ | $\\leq 1000$ | $\\leq 200$ |  |\n| 8 | $\\leq 500$ | $\\leq 500$ | $\\leq 1000$ | $\\leq 1000$ |  |\n| 9 | $\\leq 500$ | $\\leq 500$ | $\\leq 1000$ | $\\leq 1000$ |  |\n| 10 | $\\leq 500$ | $\\leq 500$ | $\\leq 1000$ | $\\leq 1000$ |  |\n\n对于所有的数据保证：$1\\leq n,m\\leq 500$，$0\\leq Q\\leq 1000$，$1\\leq len\\leq 1000$，$1\\leq x,y\\leq n$。且 `Add` 操作不超过 $550$ 个。两个城市之间可能有多条高速公路或高铁，高速公路或高铁的两端可能是同一个城市（即：有重边，有自环）。\n", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2017] Eight Verticals and Eight Horizontals", "background": "", "description": "The country of Anihc has $n$ cities, numbered from $1$ to $n$, with city $1$ being the capital. Initially, there are $m$ highways between cities. Each highway has a non-negative integer economic impact factor, and each highway connects two cities (the endpoints may be the same city). It is guaranteed that any two cities are mutually reachable via highways.\n\nThe country is planning the \"Eight Verticals and Eight Horizontals\" high-speed railway program, which will build some high-speed railways. Each railway also connects two cities (the endpoints may be the same city) and has a non-negative integer economic impact factor. After this program is completed, the country plans to extend the \"Belt and Road\" to \"Belt and Road and Ring\" by adding an \"Inland Cities Economic Ring,\" i.e., choosing a path that starts from the capital and follows a sequence of railways and highways, where each railway or highway may be traversed multiple times, and each city may be visited multiple times, finally returning to the capital. Let the GDP of the \"Inland Cities Economic Ring\" be the XOR of the economic impact factors of the railways and highways traversed along this path in order (an edge traversed multiple times is counted multiple times).\n\nAnihc is discussing the construction plan for \"Eight Verticals and Eight Horizontals\" and will keep modifying the plan. You are asked to report, in real time, the maximum possible GDP of the \"Inland Cities Economic Ring\" for the current plan.\n\nInitially, the plan contains no railways. There are the following $3$ types of operations:\n\n`Add x y z`\n\nAdd a high-speed railway between cities $x$ and $y$ with economic impact factor $z$. If this is the $k$-th `Add` operation, then this railway is named railway $k$.\n\n`Cancel k`\n\nCancel railway $k$ from the plan. It is guaranteed that railway $k$ exists at this moment.\n\n`Change k z`\n\nChange the economic impact factor of railway $k$ to $z$. It is guaranteed that railway $k$ exists at this moment.", "inputFormat": "The first line contains $3$ integers $n, m, Q$, denoting the number of cities, the number of highways, and the number of operations.\n\nThe next $m$ lines each contain $3$ integers, describing a highway.\n\nThe next $Q$ lines each contain one operation, in one of the following forms: `Add x y z`, `Cancel k`, or `Change k z`.\n\nNote: All economic impact factors in the input are given in binary, from the most significant bit to the least significant bit.", "outputFormat": "Output one integer on the first line: the maximum possible GDP of the \"Inland Cities Economic Ring\" if no railway is built.\n\nThen output $Q$ lines, each containing one integer, where the $i$-th line is the maximum possible GDP of the \"Inland Cities Economic Ring\" after performing the $i$-th operation with respect to the current plan.\n\nNote: All answers must be output in binary, from the most significant bit to the least significant bit.", "hint": "Constraints and Notes.\n\nLet $len$ be the maximum number of bits among the binary representations of all economic impact factors. The testdata satisfies the following table:\n\n| Data Point | $n$ | $m$ | $Q$ | $len$ | Special Property |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| 1 | $\\leq 5$ | $\\leq 8$ | $0$ | $\\leq 31$ |  |\n| 2 | $\\leq 100$ | $= n + 1$ | $0$ | $\\leq 100$ |  |\n| 3 | $\\leq 100$ | $\\leq 100$ | $0$ | $\\leq 100$ |  |\n| 4 | $\\leq 500$ | $\\leq 500$ | $0$ | $\\leq 1000$ |  |\n| 5 | $\\leq 100$ | $\\leq 100$ | $\\leq 100$ | $\\leq 200$ | Only `Add` operations |\n| 6 | $\\leq 500$ | $\\leq 500$ | $\\leq 200$ | $\\leq 1000$ |  |\n| 7 | $\\leq 100$ | $\\leq 100$ | $\\leq 1000$ | $\\leq 200$ |  |\n| 8 | $\\leq 500$ | $\\leq 500$ | $\\leq 1000$ | $\\leq 1000$ |  |\n| 9 | $\\leq 500$ | $\\leq 500$ | $\\leq 1000$ | $\\leq 1000$ |  |\n| 10 | $\\leq 500$ | $\\leq 500$ | $\\leq 1000$ | $\\leq 1000$ |  |\n\nFor all testdata it is guaranteed that $1 \\leq n, m \\leq 500$, $0 \\leq Q \\leq 1000$, $1 \\leq len \\leq 1000$, $1 \\leq x, y \\leq n$. Moreover, the number of `Add` operations does not exceed $550$. There may be multiple highways or railways between two cities, and an edge may have both endpoints at the same city (i.e., multiedges and self-loops).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2017] 八纵八横", "background": "", "description": "Anihc 国有 $n$ 个城市，这 $n$ 个城市从 $1$ 到 $n$ 编号，$1$ 号城市为首都。城市间初始时有 $m$ 条高速公路，每条高速公路都有一个非负整数的经济影响因子，每条高速公路的两端都是城市（可能两端是同一个城市），保证任意两个城市都可以通过高速公路互达。\n\n国正在筹划“八纵八横”的高铁建设计划，计划要修建一些高速铁路，每条高速铁路两端也都是城市（可能两端是同一个城市)，也都有一个非负整数的经济影响因子。国家还计划在“八纵八横”计划建成之后，将“一带一路”扩展为“一带一路一环”，增加“内陆城市经济环”即选择一条从首都出发沿若一系列高铁与高速公路走的路径，每条高铁或高速公路可以经过多次，每座城市也可以经过多次，最后路径又在首都结束。令“内陆城市经济环”的 GDP 为依次将这条路径上所经过的高铁或高速公路的经济影响因子异或起来（一条路经过多次则会被计算多次）。\n\n现在 Anihc 在会议上讨论“八纵八横”的建设计划方案，他们会不断地修改计划方案，希望你能实时反馈对于当前的“八纵八横”的建设计划的方案“内陆城市经济环”的最大是多少。\n\n初始时，八纵八横计划中不包含任何一条高铁，有以下 $3$ 种操作：\n\n`Add x y z`\n\n在计划中给在城市 $x$ 和城市 $y$ 之间建设一条高铁，其经济影响因子为 $z$，如果这是第 $k$ 个 `Add` 操作，则将这条高铁命名为 $k$ 号高铁。\n\n`Cancel k`\n\n将计划中的 $k$ 号高铁取消掉，保证此时 $k$ 号高铁一定存在。\n\n`Change k z`\n\n表示将第 $k$ 号高铁的经济影响因子更改为 $z$，保证此时 $k$ 号高铁一定存在。\n", "inputFormat": "第一行 $3$ 个整数 $n,m,Q$，表示城市个数，高速公路条数，操作个数。\n\n接下来 $m$ 行，每行 $3$ 个整数表示高速公路的信息。\n\n接下来 $Q$ 行，每行为一个操作。\n\n注意：输入的所有经济影响因子都将以二进制的形式从高位到低位给出。\n", "outputFormat": "第一行一个整数。表示如果不修建任何高铁，“内陆城市经济环”的 GDP 最大值。\n\n接下 $Q$ 行每行一个整数，表示进行了对应的每一个操作之后，对于当前的计划，“内陆城市经济环”的 GDP 最大值。\n\n注意：输出的答案也要以二进制的形式从高位到低位给出。\n", "hint": "### 数据规模与约定\n\n令所有的经济因子二进制表示的最多位数为 $len$。数据满足以下表格：\n\n| 数据点 | $n$ | $m$ | $Q$ | $len$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| 1 | $\\leq 5$ | $\\leq 8$ | $0$ | $\\leq 31$ |  |\n| 2 | $\\leq 100$ | $=n + 1$ | $0$ | $\\leq 100$ |  |\n| 3 | $\\leq 100$ | $\\leq 100$ | $0$ | $\\leq 100$ |  |\n| 4 | $\\leq 500$ | $\\leq 500$ | $0$ | $\\leq 1000$ |  |\n| 5 |$\\leq 100$ | $\\leq 100$ | $\\leq 100$ | $\\leq 200$ | 只存在 `Add` 操作 |\n| 6 | $\\leq 500$ | $\\leq 500$ | $\\leq 200$ | $\\leq 1000$ |  |\n| 7 | $\\leq 100$ | $\\leq 100$ | $\\leq 1000$ | $\\leq 200$ |  |\n| 8 | $\\leq 500$ | $\\leq 500$ | $\\leq 1000$ | $\\leq 1000$ |  |\n| 9 | $\\leq 500$ | $\\leq 500$ | $\\leq 1000$ | $\\leq 1000$ |  |\n| 10 | $\\leq 500$ | $\\leq 500$ | $\\leq 1000$ | $\\leq 1000$ |  |\n\n对于所有的数据保证：$1\\leq n,m\\leq 500$，$0\\leq Q\\leq 1000$，$1\\leq len\\leq 1000$，$1\\leq x,y\\leq n$。且 `Add` 操作不超过 $550$ 个。两个城市之间可能有多条高速公路或高铁，高速公路或高铁的两端可能是同一个城市（即：有重边，有自环）。\n", "locale": "zh-CN"}}}
{"pid": "P3734", "type": "P", "difficulty": 6, "samples": [["1 1 1\n0", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "河南", "各省省选"], "title": "[HAOI2017] 方案数", "background": "", "description": "考虑定义非负整数间的“$ \\subseteq $”，如果 $ a \\subseteq b $，那么 $ a \\land b = a $，其中 $ \\land $ 表示二进制下的“与”操作。\n\n\n考虑现在有一个无限大的空间，现在你在 $ (0, 0, 0) $，有三种位移操作。\n\n\n一、$(x,y,z)\\to(x',y,z)$ if $x\\subseteq x'$  \n二、$(x,y,z)\\to(x,y',z)$ if $y\\subseteq y'$  \n三、$(x,y,z)\\to(x,y,z')$ if $z\\subseteq z'$  \n\n由于来自东方的神秘力量，有些点被屏蔽了，也就是不能经过了。现在问你到某个点 $ (n, m, r) $ 的方案数，答案对 $ 998244353 $ 取模。\n", "inputFormat": "第一行三个整数 $ n, m, r $。\n\n\n接下来一行一个整数 $ o $，表示障碍物的数量。\n\n\n接下来 $ o $ 行，每行三个整数 $ x, y, z $ 表示障碍物的坐标，$ 0 \\le x \\le n, 0 \\le y \\le m, 0 \\le z \\le r $，且障碍物不在 $ (0, 0, 0) $ 和 $ (n, m, r) $ 上，障碍物不会重复。\n\n", "outputFormat": "一行一个整数，代表要求的答案。\n", "hint": "【样例解释】\n\n有8种状态（0,0,0),(0,0,1),(0,1,0),(0,1,1),(1,0,0),(1,0,1),(1,1,0),(1,1,1),分别方案数为 1,1,1,2,1,2,2,6。\n\n【数据规模和约定】\n\n对于 $ 20\\% $ 的数据，满足：$ n, m, r \\le 100 $\n\n\n对于 $ 50\\% $ 的数据，满足：$ n, m, r \\le 10^6 $\n\n\n对于另外 $ 20\\% $ 的数据，满足：$ o \\le 10 $\n\n\n对于 $ 100\\% $ 的数据，满足：$ n, m, r \\le 10^{18}, o \\le 10^4 $\n", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2017] Number of Plans", "background": "", "description": "Define a relation $ \\subseteq $ on non-negative integers: if $ a \\subseteq b $, then $ a \\land b = a $, where $ \\land $ denotes the bitwise AND.\n\nConsider an infinite space. You start at $ (0, 0, 0) $, and you have three types of moves:\n\n1. $ (x, y, z) \\to (x', y, z) $ if $ x \\subseteq x' $.\n2. $ (x, y, z) \\to (x, y', z) $ if $ y \\subseteq y' $.\n3. $ (x, y, z) \\to (x, y, z') $ if $ z \\subseteq z' $.\n\nDue to a mysterious force, some points are blocked, i.e., you cannot pass through them. Find the number of ways to reach the point $ (n, m, r) $. Output the answer modulo $ 998244353 $.", "inputFormat": "The first line contains three integers $ n, m, r $.\n\nThe next line contains a single integer $ o $, the number of obstacles.\n\nEach of the next $ o $ lines contains three integers $ x, y, z $ giving the coordinates of an obstacle, where $ 0 \\le x \\le n $, $ 0 \\le y \\le m $, $ 0 \\le z \\le r $. No obstacle is at $ (0, 0, 0) $ or $ (n, m, r) $, and obstacles are pairwise distinct.", "outputFormat": "Output a single integer, the required answer.", "hint": "[Sample explanation]\n\nThere are 8 states: $ (0, 0, 0) $, $ (0, 0, 1) $, $ (0, 1, 0) $, $ (0, 1, 1) $, $ (1, 0, 0) $, $ (1, 0, 1) $, $ (1, 1, 0) $, $ (1, 1, 1) $. The corresponding numbers of ways are $ 1, 1, 1, 2, 1, 2, 2, 6 $.\n\n[Constraints]\n\n- For $ 20\\% $ of the testdata: $ n, m, r \\le 100 $.\n- For $ 50\\% $ of the testdata: $ n, m, r \\le 10^6 $.\n- For another $ 20\\% $ of the testdata: $ o \\le 10 $.\n- For $ 100\\% $ of the testdata: $ n, m, r \\le 10^{18} $, $ o \\le 10^4 $.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2017] 方案数", "background": "", "description": "考虑定义非负整数间的“$ \\subseteq $”，如果 $ a \\subseteq b $，那么 $ a \\land b = a $，其中 $ \\land $ 表示二进制下的“与”操作。\n\n\n考虑现在有一个无限大的空间，现在你在 $ (0, 0, 0) $，有三种位移操作。\n\n\n一、$(x,y,z)\\to(x',y,z)$ if $x\\subseteq x'$  \n二、$(x,y,z)\\to(x,y',z)$ if $y\\subseteq y'$  \n三、$(x,y,z)\\to(x,y,z')$ if $z\\subseteq z'$  \n\n由于来自东方的神秘力量，有些点被屏蔽了，也就是不能经过了。现在问你到某个点 $ (n, m, r) $ 的方案数，答案对 $ 998244353 $ 取模。\n", "inputFormat": "第一行三个整数 $ n, m, r $。\n\n\n接下来一行一个整数 $ o $，表示障碍物的数量。\n\n\n接下来 $ o $ 行，每行三个整数 $ x, y, z $ 表示障碍物的坐标，$ 0 \\le x \\le n, 0 \\le y \\le m, 0 \\le z \\le r $，且障碍物不在 $ (0, 0, 0) $ 和 $ (n, m, r) $ 上，障碍物不会重复。\n\n", "outputFormat": "一行一个整数，代表要求的答案。\n", "hint": "【样例解释】\n\n有8种状态（0,0,0),(0,0,1),(0,1,0),(0,1,1),(1,0,0),(1,0,1),(1,1,0),(1,1,1),分别方案数为 1,1,1,2,1,2,2,6。\n\n【数据规模和约定】\n\n对于 $ 20\\% $ 的数据，满足：$ n, m, r \\le 100 $\n\n\n对于 $ 50\\% $ 的数据，满足：$ n, m, r \\le 10^6 $\n\n\n对于另外 $ 20\\% $ 的数据，满足：$ o \\le 10 $\n\n\n对于 $ 100\\% $ 的数据，满足：$ n, m, r \\le 10^{18}, o \\le 10^4 $\n", "locale": "zh-CN"}}}
{"pid": "P3735", "type": "P", "difficulty": 7, "samples": [["1\nxyz\n3\nxz\ny\nxzy", "2\n3\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "河南", "各省省选"], "title": "[HAOI2017] 字符串", "background": "", "description": "给出一个字符串 $ s $ 和 $ n $ 个字符串 $ p_i $，求每个字符串 $ p_i $ 在 $ s $ 中出现的次数。注意这里两个字符串相等的定义稍作改变。\n\n\n给定一个常数 $ k $，对于两个字符串 $ a, b $，如果 $ a = b $，那么满足：\n\n\n一、$ |a| = |b| $\n\n二、对于所有 $ a_i \\neq b_i $ 以及 $ a_j \\neq b_j $，满足 $ |i-j| < k $\n\n如果 $ |a| = |b| \\le k $，那么认为 $ a = b $。", "inputFormat": "第一行一个整数 $ k $。\n\n\n第二行一个字符串 $ s $。\n\n\n第三行一个整数 $ n $，接下来 $ n $ 行每行一个字符串表示 $ p_i $。\n\n\n所有的字符 ASCII 码在 $ 33 $ 至 $ 126 $ 之间。\n", "outputFormat": "输出 $ n $ 行，表示每个 $ p_i $ 在 $ s $ 中出现的次数。\n", "hint": "对于 $ p_1 $，$ xz = xy, xz = yz $，因为都只有一个位置差异。\n\n\n对于 $ p_2 $，$ y = x, y = y, y = z $，同理。\n\n\n对于 $ p_3 $，$ xzy \\neq xyz $，最大差 $ = 1 $ 不满足 $ < k = 1 $。\n\n\n数据范围与提示\n\n\n对于 $ 20\\% $ 的数据，满足：$ |s|, \\Sigma |p_i| \\le 10^3 $\n\n对于另外 $ 20\\% $ 的数据，满足：$ n \\le 100 $\n\n\n对于另外 $ 20\\% $ 的数据，满足：$ |s|, \\Sigma |p_i| \\le 5 \\cdot 10^4 $\n\n对于 $ 100\\% $ 的数据，满足：$ |s|, \\Sigma |p_i| \\le 2 \\cdot 10^5 $\n", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2017] String", "background": "", "description": "Given a string $ s $ and $ n $ strings $ p_i $, for each string $ p_i $ count the number of its occurrences in $ s $. Note that the definition of equality between two strings is slightly modified here.\n\nGiven a constant $ k $, for two strings $ a, b $, we define $ a = b $ if the following hold:\n1. $ |a| = |b| $.\n2. For all $ a_i \\ne b_i $ and $ a_j \\ne b_j $, it holds that $ |i - j| < k $.\n\nIf $ |a| = |b| \\le k $, then we regard $ a = b $.", "inputFormat": "The first line contains an integer $ k $.\n\nThe second line contains a string $ s $.\n\nThe third line contains an integer $ n $, followed by $ n $ lines, each containing a string denoting $ p_i $.\n\nAll characters have ASCII codes in the range $ 33 $ to $ 126 $.", "outputFormat": "Output $ n $ lines, where the $ i $-th line is the number of occurrences of $ p_i $ in $ s $.", "hint": "For $ p_1 $, $ xz = xy, xz = yz $, because there is only one differing position.\n\nFor $ p_2 $, $ y = x, y = y, y = z $, similarly.\n\nFor $ p_3 $, $ xzy \\ne xyz $, the maximum difference $ = 1 $ does not satisfy $ < k = 1 $.\n\nConstraints\n\n- For $ 20\\% $ of the testdata, it holds that: $ |s|, \\Sigma |p_i| \\le 10^3 $.\n- For another $ 20\\% $ of the testdata, it holds that: $ n \\le 100 $.\n- For another $ 20\\% $ of the testdata, it holds that: $ |s|, \\Sigma |p_i| \\le 5 \\cdot 10^4 $.\n- For $ 100\\% $ of the testdata, it holds that: $ |s|, \\Sigma |p_i| \\le 2 \\cdot 10^5 $.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2017] 字符串", "background": "", "description": "给出一个字符串 $ s $ 和 $ n $ 个字符串 $ p_i $，求每个字符串 $ p_i $ 在 $ s $ 中出现的次数。注意这里两个字符串相等的定义稍作改变。\n\n\n给定一个常数 $ k $，对于两个字符串 $ a, b $，如果 $ a = b $，那么满足：\n\n\n一、$ |a| = |b| $\n\n二、对于所有 $ a_i \\neq b_i $ 以及 $ a_j \\neq b_j $，满足 $ |i-j| < k $\n\n如果 $ |a| = |b| \\le k $，那么认为 $ a = b $。", "inputFormat": "第一行一个整数 $ k $。\n\n\n第二行一个字符串 $ s $。\n\n\n第三行一个整数 $ n $，接下来 $ n $ 行每行一个字符串表示 $ p_i $。\n\n\n所有的字符 ASCII 码在 $ 33 $ 至 $ 126 $ 之间。\n", "outputFormat": "输出 $ n $ 行，表示每个 $ p_i $ 在 $ s $ 中出现的次数。\n", "hint": "对于 $ p_1 $，$ xz = xy, xz = yz $，因为都只有一个位置差异。\n\n\n对于 $ p_2 $，$ y = x, y = y, y = z $，同理。\n\n\n对于 $ p_3 $，$ xzy \\neq xyz $，最大差 $ = 1 $ 不满足 $ < k = 1 $。\n\n\n数据范围与提示\n\n\n对于 $ 20\\% $ 的数据，满足：$ |s|, \\Sigma |p_i| \\le 10^3 $\n\n对于另外 $ 20\\% $ 的数据，满足：$ n \\le 100 $\n\n\n对于另外 $ 20\\% $ 的数据，满足：$ |s|, \\Sigma |p_i| \\le 5 \\cdot 10^4 $\n\n对于 $ 100\\% $ 的数据，满足：$ |s|, \\Sigma |p_i| \\le 2 \\cdot 10^5 $\n", "locale": "zh-CN"}}}
{"pid": "P3736", "type": "P", "difficulty": 6, "samples": [["3 2\n1 0 1\n1 10\n1 10\n0 20\n1 30\n", "40"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2016", "河南", "各省省选", "枚举", "状压 DP"], "title": "[HAOI2016] 字符合并", "background": null, "description": "有一个长度为 $n$ 的 $01$ 串，你可以每次将相邻的 $k$ 个字符合并，得到一个新的字符并获得一定分数。\n\n得到的新字符和分数由这 $k$ 个字符确定。你需要求出你能获得的最大分数。", "inputFormat": "输入的第一行是两个整数，分别代表字符串长度 $n$ 和参数 $k$。  \n\n输入的第二行有 $n$ 个用空格隔开的非零即一的字符，第 $i$ 个字符表示初始串的第 $i$ 个字符。\n\n第 $3$ 到第 $(2^k + 2)$ 行，每行有一个字符和一个整数，第 $(i + 2)$ 行的字符 $c_i$ 表示长度为 $k$ 的 $01$ 串连成二进制后按从小到大顺序得到的第 $i$ 种合并方案得到的新字符, 整数 $w_i$ 表示对应的第 $i$ 种方案对应获得的分数。", "outputFormat": "输出一个整数表示答案。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n\n- $1\\leq n\\leq 300$，$1 \\lt k \\leq 8$。\n- $c_i\\in\\{0,1\\}$，$1 \\leq w_i \\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2016] Character Merge", "background": "", "description": "You are given a $01$ string of length $n$. Each time, you may merge $k$ adjacent characters to obtain a new character and gain a certain score.\n\nThe resulting character and the score are determined by these $k$ characters. You need to find the maximum total score you can obtain.", "inputFormat": "The first line contains two integers, the string length $n$ and the parameter $k$.\n\nThe second line contains $n$ space-separated characters, each either $0$ or $1$. The $i$-th character is the $i$-th character of the initial string.\n\nFrom the $3$-rd to the $(2^k + 2)$-th lines, each line contains one character and one integer. On line $(i + 2)$, the character $c_i$ is the resulting character for the $i$-th length-$k$ $01$ string when these $k$-bit strings are interpreted as binary numbers and ordered increasingly; the integer $w_i$ is the score for the corresponding $i$-th pattern.", "outputFormat": "Output a single integer denoting the answer.", "hint": "Constraints\n\n- For $100\\%$ of the testdata, it is guaranteed that:\n  - $1 \\leq n \\leq 300$, $1 < k \\leq 8$.\n  - $c_i \\in \\{0, 1\\}$, $1 \\leq w_i \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2016] 字符合并", "background": null, "description": "有一个长度为 $n$ 的 $01$ 串，你可以每次将相邻的 $k$ 个字符合并，得到一个新的字符并获得一定分数。\n\n得到的新字符和分数由这 $k$ 个字符确定。你需要求出你能获得的最大分数。", "inputFormat": "输入的第一行是两个整数，分别代表字符串长度 $n$ 和参数 $k$。  \n\n输入的第二行有 $n$ 个用空格隔开的非零即一的字符，第 $i$ 个字符表示初始串的第 $i$ 个字符。\n\n第 $3$ 到第 $(2^k + 2)$ 行，每行有一个字符和一个整数，第 $(i + 2)$ 行的字符 $c_i$ 表示长度为 $k$ 的 $01$ 串连成二进制后按从小到大顺序得到的第 $i$ 种合并方案得到的新字符, 整数 $w_i$ 表示对应的第 $i$ 种方案对应获得的分数。", "outputFormat": "输出一个整数表示答案。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n\n- $1\\leq n\\leq 300$，$1 \\lt k \\leq 8$。\n- $c_i\\in\\{0,1\\}$，$1 \\leq w_i \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3737", "type": "P", "difficulty": 3, "samples": [["3 2\n1 2\n-3 1\n2 1\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "贪心", "2014", "河南", "各省省选"], "title": "[HAOI2014] 遥感监测", "background": "", "description": "外星人指的是地球以外的智慧生命。外星人长的是不是与地球上的人一样并不重要，但起码应该符合我们目前对生命基本形式的认识。比如，我们所知的任何生命都离不开液态水，并且都是基于化学元素碳（C）的有机分子组合成的复杂有机体。\n\nZDM 实验室的天文学家们已经执著地观测 ZDM-99 星球十多年了，这个被称为“战神”的红色星球让他们如此着迷。在过去的十多年中，他们经常有一些令人激动的发现。ZDM-99 星球表面有着明显的明暗变化。对这些明暗区域，天文学家们已经细致地研究了很多年，并且绘制出了较为详尽的地图，那些暗区是陆地，而亮区则是湖泊和海洋。他们一直坚信有水的地方，一定有生命的痕迹。\n\n这天晚上的观测条件实在是空前的好，ZDM-99 星球也十分明亮，不时呈现出若干个激光点，天文学家们推定这些激光点极有可能存在地球以外的智慧生命。遗憾的是仅持续很短的一段时间，这些激光点就消失了。\n\nZDM 实验室的射电望远镜观测的区域有限，只可以遥感检测到一个半径为 $R$ 的圆形区域。为了能同时能检测到所有的激光点，ZDM 实验室需要要在一个水平的直线上尽快地安装多个的射电望远镜来。\n\n不妨设，这条安放射电望远镜的水平直线为 X 轴，ZDM-99 星球激光点就处在 $P_1(x_1,y_1),P_1(x_1,y_1),\\cdots,P_1(x_n,y_n)$（忽略 Z 坐标）\n\n ![](https://cdn.luogu.com.cn/upload/pic/5206.png) \n\nZDM 实验室的天文学家们想知道，至少需要安装多少个射电望远镜才能检测到所有激光点。\n", "inputFormat": "第 1 行，$N, R$ 分别表示激光点的个数和射电望远镜能检测到的半径。\n\n第 $2$ 到 $N+1$ 行，$X_i,Y_i$ 表示 激光点的坐标位置。", "outputFormat": "输出一行： 最少需要安装的射电望远镜数。\n", "hint": "$1≤R≤50$，$1≤N≤100$，$-1000≤ X_i,Y_i ≤ 1000$， $|Y_i| ≤ R$。\n\n保证输入都是整数。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2014] Remote Sensing Monitoring", "background": "", "description": "Aliens are intelligent life beyond Earth. Whether aliens look like humans is not important, but at least they should fit our current understanding of basic life forms. For example, every life form we know depends on liquid water and is composed of complex organisms based on organic molecules of the chemical element carbon (C).\n\nAstronomers at the ZDM Laboratory have persistently observed the planet ZDM-99 for more than ten years. This red planet, nicknamed the “War God,” fascinates them. Over the years, they have made many exciting discoveries. The surface of ZDM-99 shows obvious variations in brightness. After years of detailed study and mapping, astronomers have concluded that the dark regions are land, while the bright regions are lakes and oceans. They firmly believe that where there is water, there must be traces of life.\n\nThe observing conditions on this night were unprecedentedly good. ZDM-99 was very bright, and several laser points appeared from time to time. The astronomers inferred that these laser points were very likely signs of intelligent life beyond Earth. Unfortunately, the laser points disappeared after only a short time.\n\nThe radio telescopes of the ZDM Laboratory can each remotely sense a circular region with radius $R$. To detect all laser points simultaneously, the laboratory plans to install multiple radio telescopes along a single horizontal straight line.\n\nAssume this horizontal line for placing radio telescopes is the $x$-axis. The laser points on ZDM-99 are located at\n$P_1(x_1, y_1), P_2(x_2, y_2), \\cdots, P_n(x_n, y_n)$ (ignore the $z$ coordinate).\n\n ![](https://cdn.luogu.com.cn/upload/pic/5206.png) \n\nThe astronomers at the ZDM Laboratory want to know the minimum number of radio telescopes needed to detect all the laser points.", "inputFormat": "The first line contains $N, R$, denoting the number of laser points and the detection radius of a radio telescope.\n\nLines $2$ to $N+1$ contain $X_i, Y_i$, the coordinates of the $i$-th laser point.", "outputFormat": "Output a single line: the minimum number of radio telescopes required.", "hint": "Constraints: $1 \\le R \\le 50$, $1 \\le N \\le 100$, $-1000 \\le X_i, Y_i \\le 1000$, $|Y_i| \\le R$.\n\nAll inputs are guaranteed to be integers.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2014] 遥感监测", "background": "", "description": "外星人指的是地球以外的智慧生命。外星人长的是不是与地球上的人一样并不重要，但起码应该符合我们目前对生命基本形式的认识。比如，我们所知的任何生命都离不开液态水，并且都是基于化学元素碳（C）的有机分子组合成的复杂有机体。\n\nZDM 实验室的天文学家们已经执著地观测 ZDM-99 星球十多年了，这个被称为“战神”的红色星球让他们如此着迷。在过去的十多年中，他们经常有一些令人激动的发现。ZDM-99 星球表面有着明显的明暗变化。对这些明暗区域，天文学家们已经细致地研究了很多年，并且绘制出了较为详尽的地图，那些暗区是陆地，而亮区则是湖泊和海洋。他们一直坚信有水的地方，一定有生命的痕迹。\n\n这天晚上的观测条件实在是空前的好，ZDM-99 星球也十分明亮，不时呈现出若干个激光点，天文学家们推定这些激光点极有可能存在地球以外的智慧生命。遗憾的是仅持续很短的一段时间，这些激光点就消失了。\n\nZDM 实验室的射电望远镜观测的区域有限，只可以遥感检测到一个半径为 $R$ 的圆形区域。为了能同时能检测到所有的激光点，ZDM 实验室需要要在一个水平的直线上尽快地安装多个的射电望远镜来。\n\n不妨设，这条安放射电望远镜的水平直线为 X 轴，ZDM-99 星球激光点就处在 $P_1(x_1,y_1),P_1(x_1,y_1),\\cdots,P_1(x_n,y_n)$（忽略 Z 坐标）\n\n ![](https://cdn.luogu.com.cn/upload/pic/5206.png) \n\nZDM 实验室的天文学家们想知道，至少需要安装多少个射电望远镜才能检测到所有激光点。\n", "inputFormat": "第 1 行，$N, R$ 分别表示激光点的个数和射电望远镜能检测到的半径。\n\n第 $2$ 到 $N+1$ 行，$X_i,Y_i$ 表示 激光点的坐标位置。", "outputFormat": "输出一行： 最少需要安装的射电望远镜数。\n", "hint": "$1≤R≤50$，$1≤N≤100$，$-1000≤ X_i,Y_i ≤ 1000$， $|Y_i| ≤ R$。\n\n保证输入都是整数。", "locale": "zh-CN"}}}
{"pid": "P3738", "type": "P", "difficulty": 5, "samples": [["7 \n0 1 \n2 0\n4 1\n2 2 \n4 3 \n2 4 \n0 3 \n3 -1", "2"], ["4\n10 100\n10 0\n100 0\n100 100\n100 -80", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2014", "河南", "各省省选"], "title": "[HAOI2014] 穿越封锁线", "background": null, "description": "某敌占区是一个封闭的多边形，用相邻的顶点集合 $P_1(x_1,y_1)$，$P_2(x_2,y_2)$，$\\cdots$，$P_n(x_n,y_n)$ 表示。\n\n我方侦察员 ZDM-007 要穿越敌占区的封锁线，为了安全起见，ZDM-007 行走的路线垂直于 X 坐标轴，从南向北穿越。\n\n现在已知侦察员 ZDM-007 所处的位置，你能算出他在穿越封锁线时，其路线在敌占区内的总长度？\n\n![](https://cdn.luogu.com.cn/upload/pic/5207.png)", "inputFormat": "第一行：$n$ 表示多边形顶点的个数\n\n接下来 $n$ 行：$x_i,y_i$ 表示多边形的顶点坐标。（按逆时针顺序给出）\n\n最后一行：$X,Y$ 表示侦察员初始时所处的位置。", "outputFormat": "侦察员穿越封锁线时，在敌占区内的总长度。（输出仅保留整数部分）", "hint": "【约束条件】\n\n$3\\le n\\le 50,0\\le x_i,y_i\\le1000,0\\le X \\le1000,-100\\le Y < 0$。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2014] Crossing the Blockade Line", "background": "", "description": "An enemy-occupied area is a closed polygon represented by consecutive vertices $P_1(x_1,y_1)$, $P_2(x_2,y_2)$, $\\cdots$, $P_n(x_n,y_n)$.\n\nOur scout ZDM-007 needs to cross the blockade line of the enemy-occupied area. For safety, ZDM-007 travels along a path perpendicular to the $X$-axis, moving from south to north.\n\nGiven the current position of ZDM-007, can you compute the total length of his route that lies inside the enemy-occupied area while he crosses the blockade line?\n\n![](https://cdn.luogu.com.cn/upload/pic/5207.png)", "inputFormat": "The first line: $n$, the number of polygon vertices.\n\nThe next $n$ lines: $x_i, y_i$, the coordinates of the polygon vertices (given in counterclockwise order).\n\nThe last line: $X, Y$, the scout’s initial position.", "outputFormat": "Output the total length of the scout’s path that lies inside the enemy-occupied area while crossing the blockade line. Print only the integer part.", "hint": "Constraints\n\n$3\\le n\\le 50, 0\\le x_i, y_i \\le 1000, 0\\le X \\le 1000, -100\\le Y < 0$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2014] 穿越封锁线", "background": null, "description": "某敌占区是一个封闭的多边形，用相邻的顶点集合 $P_1(x_1,y_1)$，$P_2(x_2,y_2)$，$\\cdots$，$P_n(x_n,y_n)$ 表示。\n\n我方侦察员 ZDM-007 要穿越敌占区的封锁线，为了安全起见，ZDM-007 行走的路线垂直于 X 坐标轴，从南向北穿越。\n\n现在已知侦察员 ZDM-007 所处的位置，你能算出他在穿越封锁线时，其路线在敌占区内的总长度？\n\n![](https://cdn.luogu.com.cn/upload/pic/5207.png)", "inputFormat": "第一行：$n$ 表示多边形顶点的个数\n\n接下来 $n$ 行：$x_i,y_i$ 表示多边形的顶点坐标。（按逆时针顺序给出）\n\n最后一行：$X,Y$ 表示侦察员初始时所处的位置。", "outputFormat": "侦察员穿越封锁线时，在敌占区内的总长度。（输出仅保留整数部分）", "hint": "【约束条件】\n\n$3\\le n\\le 50,0\\le x_i,y_i\\le1000,0\\le X \\le1000,-100\\le Y < 0$。", "locale": "zh-CN"}}}
{"pid": "P3739", "type": "P", "difficulty": 4, "samples": [["4 2 2 10\n2 1\n3 5\n4 4", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "河南", "各省省选"], "title": "[HAOI2014] 走出金字塔", "background": "", "description": "在探险的过程中，考古学家 Dr. Kong 无意地被困在一个金字塔中。金字塔中的每个房间都是三角形。Dr. Kong 可以破壁走到相邻的房间去。例如，如果他目前处于三角形 $(2,2)$ 房间，那么他可以破壁走到三角形 $(2,1)$、$(2,3)$ 或 $(1,1)$ 房间。但破壁一面墙需要花费 $K$ 分钟时间，而考古学家 Dr. Kong 的体能只能支持他 $S$ 分钟。\n\n\n好在 Dr. Kong 手中有这个金字塔地图，他发现金字塔有许多出口，一旦他进入一个有出口的三角形房间，他再用 $1$ 分钟就可以走出金字塔。\n\n现在，你能否帮助 Dr. Kong 找到一个走出金字塔花费时间最少的出口？若能，输出 Dr. Kong 走出金字塔后还剩下的体能时间（应当大于或等于 $0$）；若不能，输出 $-1$。\n\n![](https://cdn.luogu.com.cn/upload/pic/5208.png)\n", "inputFormat": "第一行共四个整数，$N,M,K,S$，其中，\n\n- $N$ 表示金字塔的层数；\n- $M$ 表示出口数；\n- $K$ 表示破壁一面墙的时间；\n- $S$ 表示考古学家 Dr. Kong 体能维持分钟数。\n\n第二行有两个整数 $X_a,Y_a$ 表示考古学家 Dr. Kong 所在的位置；\n\n第三行至第 $M+2$ 行，每行有两个整数 $X_i,Y_i$，表示有出口的三角形坐标位置。\n", "outputFormat": "输出 Dr. Kong 走出金字塔后还剩下的体能时间；若不能，输出 $-1$。\n", "hint": "### 数据范围及约定\n\n对于全部数据，$1 \\le N \\le 10^6$，$0\\le M\\le 10^4$，$0<K\\le 20$，$10\\le S\\le 10^4$。\n\n所有的数据都是整数，且数据之间有一个空格。\n", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2014] Escape from the Pyramid", "background": "", "description": "During an expedition, the archaeologist Dr. Kong was accidentally trapped inside a pyramid. Each room in the pyramid is triangular. Dr. Kong can break through a wall to move to an adjacent room. For example, if he is currently in triangular room $(2,2)$, he can break through to triangular room $(2,1)$, $(2,3)$, or $(1,1)$. However, breaking through one wall takes $K$ minutes, and Dr. Kong’s stamina only lasts for $S$ minutes.\n\nFortunately, Dr. Kong has a map of the pyramid and finds that there are many exits. Once he enters a triangular room that has an exit, he can leave the pyramid in $1$ minute.\n\nNow, can you help Dr. Kong find an exit that minimizes the total time to escape? If possible, output the remaining stamina time after Dr. Kong escapes (it should be greater than or equal to $0$); otherwise, output $-1$.\n\n![](https://cdn.luogu.com.cn/upload/pic/5208.png)", "inputFormat": "The first line contains four integers $N, M, K, S$, where:\n\n- $N$ is the number of layers of the pyramid.\n- $M$ is the number of exits.\n- $K$ is the time to break through one wall.\n- $S$ is the number of minutes Dr. Kong’s stamina lasts.\n\nThe second line contains two integers $X_a, Y_a$ indicating Dr. Kong’s current position.\n\nFrom the third line to the $(M+2)$-th line, each line contains two integers $X_i, Y_i$ indicating the coordinates of a triangular room that has an exit.", "outputFormat": "Output the remaining stamina time after Dr. Kong escapes; if it is impossible, output $-1$.", "hint": "Constraints and Conventions\n\nFor all testdata, $1 \\le N \\le 10^6$, $0 \\le M \\le 10^4$, $0 < K \\le 20$, $10 \\le S \\le 10^4$.\n\nAll numbers are integers, and values are separated by a single space.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2014] 走出金字塔", "background": "", "description": "在探险的过程中，考古学家 Dr. Kong 无意地被困在一个金字塔中。金字塔中的每个房间都是三角形。Dr. Kong 可以破壁走到相邻的房间去。例如，如果他目前处于三角形 $(2,2)$ 房间，那么他可以破壁走到三角形 $(2,1)$、$(2,3)$ 或 $(1,1)$ 房间。但破壁一面墙需要花费 $K$ 分钟时间，而考古学家 Dr. Kong 的体能只能支持他 $S$ 分钟。\n\n\n好在 Dr. Kong 手中有这个金字塔地图，他发现金字塔有许多出口，一旦他进入一个有出口的三角形房间，他再用 $1$ 分钟就可以走出金字塔。\n\n现在，你能否帮助 Dr. Kong 找到一个走出金字塔花费时间最少的出口？若能，输出 Dr. Kong 走出金字塔后还剩下的体能时间（应当大于或等于 $0$）；若不能，输出 $-1$。\n\n![](https://cdn.luogu.com.cn/upload/pic/5208.png)\n", "inputFormat": "第一行共四个整数，$N,M,K,S$，其中，\n\n- $N$ 表示金字塔的层数；\n- $M$ 表示出口数；\n- $K$ 表示破壁一面墙的时间；\n- $S$ 表示考古学家 Dr. Kong 体能维持分钟数。\n\n第二行有两个整数 $X_a,Y_a$ 表示考古学家 Dr. Kong 所在的位置；\n\n第三行至第 $M+2$ 行，每行有两个整数 $X_i,Y_i$，表示有出口的三角形坐标位置。\n", "outputFormat": "输出 Dr. Kong 走出金字塔后还剩下的体能时间；若不能，输出 $-1$。\n", "hint": "### 数据范围及约定\n\n对于全部数据，$1 \\le N \\le 10^6$，$0\\le M\\le 10^4$，$0<K\\le 20$，$10\\le S\\le 10^4$。\n\n所有的数据都是整数，且数据之间有一个空格。\n", "locale": "zh-CN"}}}
{"pid": "P3740", "type": "P", "difficulty": 4, "samples": [["100 5\n1 4\n2 6\n8 10\n3 4\n7 10\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "河南", "线段树", "各省省选", "颜色段均摊（珂朵莉树 ODT）", "离散化", "枚举"], "title": "[HAOI2014] 贴海报", "background": "", "description": "Bytetown 城市要进行市长竞选，所有的选民可以畅所欲言地对竞选市长的候选人发表言论。为了统一管理，城市委员会为选民准备了一个张贴海报的 electoral 墙。\n\n张贴规则如下：\n\n1. electoral 墙是一个长度为 $N$ 个单位的长方形，每个单位记为一个格子；\n\n2. 所有张贴的海报的高度必须与 electoral 墙的高度一致的；\n\n3. 每张海报以 `A B` 表示，即从第 $A$ 个格子到第 $B$ 个格子张贴海报；\n\n4. 后贴的海报可以覆盖前面已贴的海报或部分海报。\n\n现在请你判断，张贴完所有海报后，在 electoral 墙上还可以看见多少张海报。", "inputFormat": "第一行，两个正整数 $N,M$，分别表示 electoral 墙的长度和海报个数。\n\n接下来 $M$ 行，每行两个正整数 $A_i,B_i$，表示每张海报张贴的位置。\n", "outputFormat": "输出贴完所有海报后，在 electoral 墙上还可以看见的海报数。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/5209.png) \n\n**约束条件**\n\n$10\\le N \\le 10000000,1\\le M\\le 1000,1\\le A_i \\le B_i \\le 10000000$\n\n所有的数据都是正整数，数据之间有一个空格。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2014] Posters", "background": "", "description": "The city of Bytetown is holding a mayoral election, and all voters can freely express their opinions about the candidates. For unified management, the city committee has prepared an electoral wall for voters to post posters.\n\nThe posting rules are as follows:\n1. The electoral wall is a rectangle of length $N$ units, with each unit being a cell.\n2. The height of every posted poster must be the same as the height of the electoral wall.\n3. Each poster is denoted by `A B`, meaning it covers from cell $A$ to cell $B$.\n4. A later poster may cover earlier posters or parts of them.\n\nPlease determine how many posters are still visible on the electoral wall after all posters have been posted.", "inputFormat": "The first line contains two positive integers $N$ and $M$, the length of the electoral wall and the number of posters, respectively.\n\nEach of the next $M$ lines contains two positive integers $A_i$ and $B_i$, denoting the position covered by a poster.\n\nAll numbers are positive integers, separated by a single space.", "outputFormat": "Output the number of posters that remain visible after all posters have been posted.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/5209.png)\n\n**Constraints**\n\n$10 \\le N \\le 10000000$, $1 \\le M \\le 1000$, $1 \\le A_i \\le B_i \\le 10000000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2014] 贴海报", "background": "", "description": "Bytetown 城市要进行市长竞选，所有的选民可以畅所欲言地对竞选市长的候选人发表言论。为了统一管理，城市委员会为选民准备了一个张贴海报的 electoral 墙。\n\n张贴规则如下：\n\n1. electoral 墙是一个长度为 $N$ 个单位的长方形，每个单位记为一个格子；\n\n2. 所有张贴的海报的高度必须与 electoral 墙的高度一致的；\n\n3. 每张海报以 `A B` 表示，即从第 $A$ 个格子到第 $B$ 个格子张贴海报；\n\n4. 后贴的海报可以覆盖前面已贴的海报或部分海报。\n\n现在请你判断，张贴完所有海报后，在 electoral 墙上还可以看见多少张海报。", "inputFormat": "第一行，两个正整数 $N,M$，分别表示 electoral 墙的长度和海报个数。\n\n接下来 $M$ 行，每行两个正整数 $A_i,B_i$，表示每张海报张贴的位置。\n", "outputFormat": "输出贴完所有海报后，在 electoral 墙上还可以看见的海报数。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/5209.png) \n\n**约束条件**\n\n$10\\le N \\le 10000000,1\\le M\\le 1000,1\\le A_i \\le B_i \\le 10000000$\n\n所有的数据都是正整数，数据之间有一个空格。", "locale": "zh-CN"}}}
{"pid": "P3741", "type": "P", "difficulty": 1, "samples": [["2\nVK\n", "1"], ["2\nVV", "1"], ["1\nV", "0"], ["20\nVKKKKKKKKKVVVVVVVVVK", "3"], ["4\nKVKV\n", "1\n"]], "limits": {"time": [400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "搜索"], "title": "小果的键盘", "background": "小果有一个只有两个键的键盘。\n", "description": "一天，她打出了一个只有这两个字符的字符串。当这个字符串里含有 `VK` 这个字符串的时候，小果就特别喜欢这个字符串。所以，她想改变至多一个字符（或者不做任何改变）来最大化这个字符串内 `VK` 出现的次数。给出原来的字符串，请计算她最多能使这个字符串内出现多少次 `VK`（只有当 `V` 和 `K` 正好相邻时，我们认为出现了 `VK`。）", "inputFormat": "第一行给出一个数字 $n$，代表字符串的长度。\n\n第二行给出一个字符串 $s$。", "outputFormat": "第一行输出一个整数代表所求答案。\n", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "Xiao Guo's Keyboard", "background": "Xiao Guo has a keyboard with only two keys.", "description": "One day, she typed a string consisting of only these two characters. She especially likes a string when it contains the substring `VK`. Therefore, she wants to change at most one character (or do nothing) to maximize the number of occurrences of `VK` in the string. Given the original string, compute the maximum number of times `VK` can appear in the string. We consider `VK` to occur only when `V` and `K` are exactly adjacent.", "inputFormat": "The first line contains an integer $n$, the length of the string.\n\nThe second line contains a string $s$.", "outputFormat": "Output a single integer, the answer.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小果的键盘", "background": "小果有一个只有两个键的键盘。\n", "description": "一天，她打出了一个只有这两个字符的字符串。当这个字符串里含有 `VK` 这个字符串的时候，小果就特别喜欢这个字符串。所以，她想改变至多一个字符（或者不做任何改变）来最大化这个字符串内 `VK` 出现的次数。给出原来的字符串，请计算她最多能使这个字符串内出现多少次 `VK`（只有当 `V` 和 `K` 正好相邻时，我们认为出现了 `VK`。）", "inputFormat": "第一行给出一个数字 $n$，代表字符串的长度。\n\n第二行给出一个字符串 $s$。", "outputFormat": "第一行输出一个整数代表所求答案。\n", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 100$。", "locale": "zh-CN"}}}
{"pid": "P3742", "type": "P", "difficulty": 1, "samples": [["2\nab\naa", "ba"], ["5\nnzwzl\nniwel", "xiyez\n"], ["2\nab\nba\n", "-1"]], "limits": {"time": [800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "字符串", "贪心", "Special Judge", "构造"], "title": "umi的函数", "background": "umi 找到了一个神秘的函数 $f$。\n", "description": "这个函数接受两个字符串 $s1,s2$。这些字符串只能由小写字母组成，并且具有相同的长度。这个函数的输出是另一个长度与 $s1,s2$ 相同的字符串 $g$。$g$ 的第 $i$ 个字符等于 $s1$ 的第 $i$ 个字符和 $s2$ 的第 $i$ 个字符的最小值，简单来说，$g_i=min(s1_i,s2_i)$。\n\n例如：$f(\\verb!ab!,\\verb!ba!)= \\verb!aa!$，$f(\\verb!nzwzl!,\\verb!zizez!)=\\verb!niwel!$。\n\n她现在有两个相同长度的只有小写字母的字符串 $x,y$。找出任何一个满足 $f(x,z)=y$ 的字符串 $z$。如果找不到这样的字符串的话，请输出 $-1$。\n", "inputFormat": "第一行给出以下两个字符串的长度 $n$。\n\n第二行给出一个字符串 $x$。\n\n第三行给出一个字符串 $y$。\n", "outputFormat": "第一行输出一个字符串，代表你找到的符合条件的字符串。找不到的话，请输出 $-1$。\n", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 100$。\n", "locale": "zh-CN", "translations": {"en": {"title": "{{umi's Function}}", "background": "{{umi found a mysterious function $f$.}}", "description": "{{This function takes two strings $s1, s2$. These strings consist only of lowercase letters and have the same length. The output of this function is another string $g$ whose length is the same as $s1$ and $s2$. The $i$-th character of $g$ equals the minimum of the $i$-th character of $s1$ and $s2$; simply put, $g_i=min(s1_i,s2_i)$.\n\nFor example: $f(\\verb!ab!,\\verb!ba!)= \\verb!aa!$, $f(\\verb!nzwzl!,\\verb!zizez!)=\\verb!niwel!$.\n\nShe now has two strings $x, y$ of the same length, consisting only of lowercase letters. Find any string $z$ such that $f(x,z)=y$. If no such string exists, please output -1.}}", "inputFormat": "{{The first line contains the length $n$ of the two strings.\nThe second line contains the string $x$.\nThe third line contains the string $y$.}}", "outputFormat": "{{Output one string in the first line, representing a valid string you found. If none exists, output -1.}}", "hint": "{{Constraints: For 100% of the testdata, $1 \\le n \\le 100$.}}\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "umi的函数", "background": "umi 找到了一个神秘的函数 $f$。\n", "description": "这个函数接受两个字符串 $s1,s2$。这些字符串只能由小写字母组成，并且具有相同的长度。这个函数的输出是另一个长度与 $s1,s2$ 相同的字符串 $g$。$g$ 的第 $i$ 个字符等于 $s1$ 的第 $i$ 个字符和 $s2$ 的第 $i$ 个字符的最小值，简单来说，$g_i=min(s1_i,s2_i)$。\n\n例如：$f(\\verb!ab!,\\verb!ba!)= \\verb!aa!$，$f(\\verb!nzwzl!,\\verb!zizez!)=\\verb!niwel!$。\n\n她现在有两个相同长度的只有小写字母的字符串 $x,y$。找出任何一个满足 $f(x,z)=y$ 的字符串 $z$。如果找不到这样的字符串的话，请输出 $-1$。\n", "inputFormat": "第一行给出以下两个字符串的长度 $n$。\n\n第二行给出一个字符串 $x$。\n\n第三行给出一个字符串 $y$。\n", "outputFormat": "第一行输出一个字符串，代表你找到的符合条件的字符串。找不到的话，请输出 $-1$。\n", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 100$。\n", "locale": "zh-CN"}}}
{"pid": "P3743", "type": "P", "difficulty": 3, "samples": [["2 1\n2 2\n2 1000\n", "2.0000000000"], ["1 100\n1 1", "-1 "], ["3 5\n4 3\n5 2\n6 1", "0.5000000000 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "二分", "Special Judge"], "title": "小鸟的设备", "background": null, "description": "小鸟有 $n$ 个可同时使用的设备，第 $i$ 个设备每秒消耗 $a_i$ 个单位能量。能量的使用是连续的，也就是说能量不是某时刻突然消耗的，而是匀速消耗。也就是说，对于任意实数，在 $k$ 秒内消耗的能量均为 $k\\times a_i$ 单位。在开始的时候第 $i$ 个设备里存储着 $b_i$ 个单位能量。\n\n同时小鸟又有一个可以给任意一个设备充电的充电宝，每秒可以给接通的设备充能 $p$ 个单位，充能也是连续的，不再赘述。你可以在任意时间给任意一个设备充能，从一个设备切换到另一个设备的时间忽略不计。\n\n小鸟想把这些设备一起使用，直到其中有设备能量降为  $0$。所以小鸟想知道，在充电器的作用下，她最多能将这些设备一起使用多久。", "inputFormat": "第一行给出两个整数 $n,p$。\n\n接下来 $n$ 行，每行表示一个设备，给出两个整数，分别是这个设备的 $a_i$ 和 $b_i$。", "outputFormat": "如果小鸟可以无限使用这些设备，输出 $-1$。\n\n否则输出小鸟在其中一个设备能量降为 $0$ 之前最多能使用多久。\n\n设你的答案为 $a$，标准答案为 $b$，只有当 $a,b$ 满足 \n$\\dfrac{|a-b|}{\\max(1,b)} \\leq 10^{-4}$ 的时候，你能得到本测试点的满分。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 10^5$，$1\\leq p\\leq 10^5$，$1\\leq a_i,b_i\\leq 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Little Bird's Devices", "background": "", "description": "Little Bird has $n$ devices that can be used simultaneously. The $i$-th device consumes $a_i$ units of energy per second. Energy usage is continuous; that is, energy is not consumed instantaneously at a moment but at a constant rate. In other words, for any real number $k$, the amount of energy consumed in $k$ seconds is $k \\times a_i$ units. Initially, the $i$-th device stores $b_i$ units of energy.\n\nLittle Bird also has a power bank that can charge any one device, supplying $p$ units of energy per second. Charging is also continuous. You can charge any device at any time, and the time to switch from one device to another is negligible.\n\nLittle Bird wants to use all these devices together until some device’s energy drops to $0$. Given the power bank, she wants to know the maximum duration she can keep all devices running together.", "inputFormat": "The first line contains two integers $n, p$.\n\nThe next $n$ lines each describe one device, giving two integers: the device’s $a_i$ and $b_i$.", "outputFormat": "If Little Bird can use these devices indefinitely, output $-1$.\n\nOtherwise, output the maximum duration before some device’s energy becomes $0$.\n\nLet your answer be $a$ and the standard answer be $b$. You will receive full credit on a test point only if $a, b$ satisfy $\\dfrac{|a-b|}{\\max(1,b)} \\leq 10^{-4}$.", "hint": "For $100\\%$ of the testdata, $1 \\leq n \\leq 10^5$, $1 \\leq p \\leq 10^5$, $1 \\leq a_i, b_i \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小鸟的设备", "background": null, "description": "小鸟有 $n$ 个可同时使用的设备，第 $i$ 个设备每秒消耗 $a_i$ 个单位能量。能量的使用是连续的，也就是说能量不是某时刻突然消耗的，而是匀速消耗。也就是说，对于任意实数，在 $k$ 秒内消耗的能量均为 $k\\times a_i$ 单位。在开始的时候第 $i$ 个设备里存储着 $b_i$ 个单位能量。\n\n同时小鸟又有一个可以给任意一个设备充电的充电宝，每秒可以给接通的设备充能 $p$ 个单位，充能也是连续的，不再赘述。你可以在任意时间给任意一个设备充能，从一个设备切换到另一个设备的时间忽略不计。\n\n小鸟想把这些设备一起使用，直到其中有设备能量降为  $0$。所以小鸟想知道，在充电器的作用下，她最多能将这些设备一起使用多久。", "inputFormat": "第一行给出两个整数 $n,p$。\n\n接下来 $n$ 行，每行表示一个设备，给出两个整数，分别是这个设备的 $a_i$ 和 $b_i$。", "outputFormat": "如果小鸟可以无限使用这些设备，输出 $-1$。\n\n否则输出小鸟在其中一个设备能量降为 $0$ 之前最多能使用多久。\n\n设你的答案为 $a$，标准答案为 $b$，只有当 $a,b$ 满足 \n$\\dfrac{|a-b|}{\\max(1,b)} \\leq 10^{-4}$ 的时候，你能得到本测试点的满分。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 10^5$，$1\\leq p\\leq 10^5$，$1\\leq a_i,b_i\\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3744", "type": "P", "difficulty": 5, "samples": [["4\n0 0\n0 1\n1 1\n1 0\n", "0.3535533906\n"], ["6\n5 0\n10 0\n12 -4\n10 -8\n5 -8\n3 -4", "1.0000000000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "贪心", "计算几何", "Special Judge", "枚举", "叉积"], "title": "李彬的几何", "background": "李彬有一个凸多边形 $P$。", "description": "$P$ 有 $N$ 个顶点 $P_1,P_2,P_3 \\cdots P_N$。顶点 $P_i$ 在二维平面上的坐标为 $(x_i,y_i)$。这些顶点是按照顺时针顺序给出的。\n\n李彬可以指定一个实数 $D$，然后将每个顶点最多移动 $D$ 个单位距离。现在李彬想知道，如果他想使这个凸多边形不再是凸多边形，那么 $D$ 的最小值是多少。", "inputFormat": "第一行给出 $1$ 个整数 $N$。\n\n接下来 $N$ 行，每行给出一个顶点，给出两个整数，分别是这个顶点的 $x_i$ 和 $y_i$。保证以顺时针顺序给出，并且形成一个严格的凸多边形。", "outputFormat": "输出一个实数 $D$，代表使这个凸多边形不再凸的最小 $D$ 值。\n\n设你的答案为 $a$,标准答案为 $b$,只有当 $a,b$ 满足$\\frac{|a-b|}{max(1,b)} \\le 10^{-4}$的时候，你是对的。", "hint": "对于 $100 \\%$ 的数据，$4 \\le N \\le 1000$，$-10^9 \\le x_i,y_i \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "Li Bin's Geometry", "background": "Li Bin has a convex polygon $P$.", "description": "$P$ has $N$ vertices $P_1, P_2, P_3, \\dots, P_N$. The coordinates of vertex $P_i$ in the 2D plane are $(x_i, y_i)$. The vertices are given in clockwise order.\n\nLi Bin may choose a real number $D$, then move each vertex by at most $D$ units. Now he wants to know the minimal value of $D$ that makes this convex polygon no longer convex.", "inputFormat": "The first line contains $1$ integer $N$.\n\nThe next $N$ lines each describe a vertex with two integers, the $x_i$ and $y_i$ of that vertex. The vertices are given in clockwise order and form a strictly convex polygon.", "outputFormat": "Output a real number $D$, representing the minimal $D$ that makes this polygon non-convex.\n\nLet your answer be $a$ and the standard answer be $b$. You are correct if and only if $\\frac{|a - b|}{\\max(1, b)} \\le 10^{-4}$.", "hint": "Constraints: For $100\\%$ of the testdata, $4 \\le N \\le 1000$, $-10^9 \\le x_i, y_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "李彬的几何", "background": "李彬有一个凸多边形 $P$。", "description": "$P$ 有 $N$ 个顶点 $P_1,P_2,P_3 \\cdots P_N$。顶点 $P_i$ 在二维平面上的坐标为 $(x_i,y_i)$。这些顶点是按照顺时针顺序给出的。\n\n李彬可以指定一个实数 $D$，然后将每个顶点最多移动 $D$ 个单位距离。现在李彬想知道，如果他想使这个凸多边形不再是凸多边形，那么 $D$ 的最小值是多少。", "inputFormat": "第一行给出 $1$ 个整数 $N$。\n\n接下来 $N$ 行，每行给出一个顶点，给出两个整数，分别是这个顶点的 $x_i$ 和 $y_i$。保证以顺时针顺序给出，并且形成一个严格的凸多边形。", "outputFormat": "输出一个实数 $D$，代表使这个凸多边形不再凸的最小 $D$ 值。\n\n设你的答案为 $a$,标准答案为 $b$,只有当 $a,b$ 满足$\\frac{|a-b|}{max(1,b)} \\le 10^{-4}$的时候，你是对的。", "hint": "对于 $100 \\%$ 的数据，$4 \\le N \\le 1000$，$-10^9 \\le x_i,y_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3745", "type": "P", "difficulty": 5, "samples": [["100 100 2\n4 5\n5 1 2 3\n1 1 2 3 3", "6"], ["3 5 4\n5 6\n1 1 4 7 8\n2 3 3 1 8 2", "33"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "贪心", "2017", "各省省选", "三分", "枚举", "前缀和"], "title": "[六省联考 2017] 期末考试", "background": "", "description": "有 $n$ 位同学，每位同学都参加了全部的 $m$ 门课程的期末考试，都在焦急的等待成绩的公布。\n\n第 $i$ 位同学希望在第 $t_i$ 天或之前得知**所有**课程的成绩。如果在第 $t_i$ 天，有至少一门课程的成绩没有公布，他就会等待最后公布成绩的课程公布成绩，每等待一天就会产生 $C$ 不愉快度。\n\n对于第 $i$ 门课程，按照原本的计划，会在第 $b_i$ 天公布成绩。\n\n有如下两种操作可以调整公布成绩的时间:\n1. 将负责课程 $X$ 的部分老师调整到课程 $Y$，调整之后公布课程 $X$ 成绩的时间推迟一天，公布课程 $Y$ 成绩的时间提前一天；每次操作产生 $A$ 不愉快度。\n2. 增加一部分老师负责学科 $Z$，这将导致学科 $Z$ 的出成绩时间提前一天；每次操作产生 $B$ 不愉快度。\n\n上面两种操作中的参数 $X, Y, Z$ 均可任意指定，每种操作均可以执行多次，每次执行时都可以重新指定参数。\n\n现在希望你通过合理的操作，使得最后总的不愉快度之和最小，输出最小的不愉快度之和即可。", "inputFormat": "第一行三个非负整数 $A, B, C$，描述三种不愉快度，详见【题目描述】；  \n第二行两个正整数 $n, m$，分别表示学生的数量和课程的数量；  \n第三行 $n$ 个正整数 $t_i$，表示每个学生希望的公布成绩的时间；  \n第四行 $m$ 个正整数 $b_i$，表示按照原本的计划，每门课程公布成绩的时间。", "outputFormat": "输出一行一个整数，表示最小的不愉快度之和。", "hint": "### 样例解释 1\n\n由于调整操作产生的不愉快度太大，所以在本例中最好的方案是不进行调整；全部的 $5$ 门课程中，最慢的在第 $3$ 天出成绩；  \n同学 $1$ 希望在第 $5$ 天或之前出成绩，所以不会产生不愉快度；  \n同学 $2$ 希望在第 $1$ 天或之前出成绩，产生的不愉快度为 $(3 - 1) \\times 2 = 4$；  \n同学 $3$ 希望在第 $2$ 天或之前出成绩，产生的不愉快度为 $(3 - 2) \\times 2 = 2$；  \n同学 $4$ 希望在第 $3$ 天或之前出成绩，所以不会产生不愉快度；  \n不愉快度之和为 $4 + 2 = 6$。\n\n### 数据范围\n\n| Case # | $n, m, t_i, b_i$ | $A, B, C$ |\n|:-:|:-:|:-:|\n| 1, 2 | $1 \\leq n, m, t_i, b_i \\leq 2000$ | $A = 10^9; B = 10^9; 0 \\leq C \\leq 10^2$ |\n| 3, 4 | $1 \\leq n, m, t_i, b_i \\leq 2000$ | $0 \\leq A; C \\leq 10^2; B = 10^9$ |\n| 5, 6, 7, 8 | $1 \\leq n, m, t_i, b_i \\leq 2000$ | $0 \\leq B \\leq A \\leq 10^2; 0 \\leq C \\leq 10^2$ |\n| 9 - 12 | $1 \\leq n, m, t_i, b_i \\leq 2000$ | $0 \\leq A, B, C \\leq 10^2$ |\n| 13, 14 | $1 \\leq n, m, t_i, b_i \\leq 10^5$ | $0 \\leq A, B \\leq 10^5; C = 10^{16}$ |\n| 15 - 20 | $1 \\leq n, m, t_i, b_i \\leq 10^5$ | $0 \\leq A, B, C \\leq 10^5$ |", "locale": "zh-CN", "translations": {"en": {"title": "[Six-Province Joint Exam 2017] Final Exam", "background": "", "description": "There are $n$ students. Each student took the final exams of all $m$ courses and is anxiously waiting for the results to be announced.\n\nStudent $i$ hopes to know the results of all courses on or before day $t_i$. If on day $t_i$ at least one course has not been announced, the student will wait until the last course is announced; each day of waiting incurs $C$ unhappiness.\n\nFor course $i$, according to the original plan, its result will be announced on day $b_i$.\n\nYou can adjust announcement days using the following two operations:\n1. Move some teachers from course $X$ to course $Y$. After the adjustment, the announcement day of course $X$ is delayed by one day, and that of course $Y$ is moved one day earlier. Each such operation incurs $A$ unhappiness.\n2. Add some teachers to course $Z$, which moves the announcement day of course $Z$ one day earlier. Each such operation incurs $B$ unhappiness.\n\nIn both operations, the parameters $X$, $Y$, and $Z$ can be chosen arbitrarily. Each operation can be performed multiple times, and the parameters can be re-chosen each time.\n\nPlease minimize the total unhappiness by applying operations reasonably, and output the minimum possible total unhappiness.", "inputFormat": "- The first line contains three non-negative integers $A, B, C$, which are the unhappiness costs, as described in the Description.\n- The second line contains two positive integers $n, m$, the numbers of students and courses, respectively.\n- The third line contains $n$ positive integers $t_i$, the desired announcement days for each student.\n- The fourth line contains $m$ positive integers $b_i$, the originally planned announcement days for each course.", "outputFormat": "Output a single integer on one line, the minimum total unhappiness.", "hint": "### Sample Explanation 1\n\nBecause the unhappiness caused by adjustments is too large, the best plan here is to make no adjustments. Among all $5$ courses, the slowest is announced on day $3$.  \nStudent $1$ hopes for results by day $5$, so no unhappiness is incurred.  \nStudent $2$ hopes for results by day $1$, so the incurred unhappiness is $(3 - 1) \\times 2 = 4$.  \nStudent $3$ hopes for results by day $2$, so the incurred unhappiness is $(3 - 2) \\times 2 = 2$.  \nStudent $4$ hopes for results by day $3$, so no unhappiness is incurred.  \nThe total unhappiness is $4 + 2 = 6$.\n\n### Constraints\n\n| Case # | $n, m, t_i, b_i$ | $A, B, C$ |\n|:-:|:-:|:-:|\n| 1, 2 | $1 \\leq n, m, t_i, b_i \\leq 2000$ | $A = 10^9; B = 10^9; 0 \\leq C \\leq 10^2$ |\n| 3, 4 | $1 \\leq n, m, t_i, b_i \\leq 2000$ | $0 \\leq A, C \\leq 10^2; B = 10^9$ |\n| 5, 6, 7, 8 | $1 \\leq n, m, t_i, b_i \\leq 2000$ | $0 \\leq B \\leq A \\leq 10^2; 0 \\leq C \\leq 10^2$ |\n| 9 - 12 | $1 \\leq n, m, t_i, b_i \\leq 2000$ | $0 \\leq A, B, C \\leq 10^2$ |\n| 13, 14 | $1 \\leq n, m, t_i, b_i \\leq 10^5$ | $0 \\leq A, B \\leq 10^5; C = 10^{16}$ |\n| 15 - 20 | $1 \\leq n, m, t_i, b_i \\leq 10^5$ | $0 \\leq A, B, C \\leq 10^5$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[六省联考 2017] 期末考试", "background": "", "description": "有 $n$ 位同学，每位同学都参加了全部的 $m$ 门课程的期末考试，都在焦急的等待成绩的公布。\n\n第 $i$ 位同学希望在第 $t_i$ 天或之前得知**所有**课程的成绩。如果在第 $t_i$ 天，有至少一门课程的成绩没有公布，他就会等待最后公布成绩的课程公布成绩，每等待一天就会产生 $C$ 不愉快度。\n\n对于第 $i$ 门课程，按照原本的计划，会在第 $b_i$ 天公布成绩。\n\n有如下两种操作可以调整公布成绩的时间:\n1. 将负责课程 $X$ 的部分老师调整到课程 $Y$，调整之后公布课程 $X$ 成绩的时间推迟一天，公布课程 $Y$ 成绩的时间提前一天；每次操作产生 $A$ 不愉快度。\n2. 增加一部分老师负责学科 $Z$，这将导致学科 $Z$ 的出成绩时间提前一天；每次操作产生 $B$ 不愉快度。\n\n上面两种操作中的参数 $X, Y, Z$ 均可任意指定，每种操作均可以执行多次，每次执行时都可以重新指定参数。\n\n现在希望你通过合理的操作，使得最后总的不愉快度之和最小，输出最小的不愉快度之和即可。", "inputFormat": "第一行三个非负整数 $A, B, C$，描述三种不愉快度，详见【题目描述】；  \n第二行两个正整数 $n, m$，分别表示学生的数量和课程的数量；  \n第三行 $n$ 个正整数 $t_i$，表示每个学生希望的公布成绩的时间；  \n第四行 $m$ 个正整数 $b_i$，表示按照原本的计划，每门课程公布成绩的时间。", "outputFormat": "输出一行一个整数，表示最小的不愉快度之和。", "hint": "### 样例解释 1\n\n由于调整操作产生的不愉快度太大，所以在本例中最好的方案是不进行调整；全部的 $5$ 门课程中，最慢的在第 $3$ 天出成绩；  \n同学 $1$ 希望在第 $5$ 天或之前出成绩，所以不会产生不愉快度；  \n同学 $2$ 希望在第 $1$ 天或之前出成绩，产生的不愉快度为 $(3 - 1) \\times 2 = 4$；  \n同学 $3$ 希望在第 $2$ 天或之前出成绩，产生的不愉快度为 $(3 - 2) \\times 2 = 2$；  \n同学 $4$ 希望在第 $3$ 天或之前出成绩，所以不会产生不愉快度；  \n不愉快度之和为 $4 + 2 = 6$。\n\n### 数据范围\n\n| Case # | $n, m, t_i, b_i$ | $A, B, C$ |\n|:-:|:-:|:-:|\n| 1, 2 | $1 \\leq n, m, t_i, b_i \\leq 2000$ | $A = 10^9; B = 10^9; 0 \\leq C \\leq 10^2$ |\n| 3, 4 | $1 \\leq n, m, t_i, b_i \\leq 2000$ | $0 \\leq A; C \\leq 10^2; B = 10^9$ |\n| 5, 6, 7, 8 | $1 \\leq n, m, t_i, b_i \\leq 2000$ | $0 \\leq B \\leq A \\leq 10^2; 0 \\leq C \\leq 10^2$ |\n| 9 - 12 | $1 \\leq n, m, t_i, b_i \\leq 2000$ | $0 \\leq A, B, C \\leq 10^2$ |\n| 13, 14 | $1 \\leq n, m, t_i, b_i \\leq 10^5$ | $0 \\leq A, B \\leq 10^5; C = 10^{16}$ |\n| 15 - 20 | $1 \\leq n, m, t_i, b_i \\leq 10^5$ | $0 \\leq A, B, C \\leq 10^5$ |", "locale": "zh-CN"}}}
{"pid": "P3746", "type": "P", "difficulty": 6, "samples": [["2 10007 2 0", "8"], ["20 10007 20 0", "176"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "递推", "2017", "各省省选", "矩阵乘法"], "title": "[六省联考 2017] 组合数问题", "background": "", "description": "组合数 $C_n^m$ 表示的是从 $n$ 个互不相同的物品中选出 $m$ 个物品的方案数。举个例子， 从 $(1, 2, 3)$ 三个物品中选择两个物品可以有 $(1, 2)$，$(1, 3)$，$(2, 3)$ 这三种选择方法。根据组合数的定义，我们可以给出计算组合数  $C_n^m$  的一般公式：\n\n$$ C_n^m = \\frac {n!} {m! \\ (n - m)!}  $$\n\n其中 $n! = 1 \\times 2 \\times \\cdots \\times n$。（特别地，当 $n = 0$ 时，$n! = 1$；当 $m > n$ 时，$C_n^m = 0$。）\n\n小葱在 NOIP 的时候学习了 $C_i^j$ 和 $k$ 的倍数关系，现在他想更进一步，研究更多关于组合数的性质。小葱发现，$C_i^j$ 是否是 $k$ 的倍数，取决于 $C_i^j \\bmod k$ 是否等于 $0$，这个神奇的性质引发了小葱对 $\\mathrm{mod}$ 运算（取余数运算）的兴趣。现在小葱选择了是四个整数 $n, p, k, r$，他希望知道\n\n$$\\left( \\sum_{i = 0}^\\infty C_{nk}^{ik + r} \\right) \\bmod p,$$\n\n即\n\n$$\\left( C_{nk}^{r} + C_{nk}^{k + r} + C_{nk}^{2k + r} + \\cdots + C_{nk}^{(n - 1)k + r}  + C_{nk}^{nk + r} + \\cdots \\right) \\bmod p$$\n\n的值。", "inputFormat": "第一行有四个整数 $n, p, k, r$，所有整数含义见问题描述。", "outputFormat": "一行一个整数代表答案。", "hint": "对于 $30\\%$ 的测试点，$1 \\leq n, k \\leq 30$，$p$ 是质数；   \n对于另外 $5\\%$ 的测试点，$p = 2$；  \n对于另外 $5\\%$ 的测试点，$k = 1$；  \n对于另外 $10\\%$ 的测试点，$k = 2$；  \n对于另外 $15\\%$ 的测试点，$1 \\leq n \\leq 10^3, 1 \\leq k \\leq 50$，$p$ 是质数；  \n对于另外 $15\\%$ 的测试点，$1 \\leq n \\times k \\leq 10^6$，$p$ 是质数；  \n对于另外 $10\\%$ 的测试点，$1 \\leq n \\leq 10^9, 1 \\leq k \\leq 50$，$p$ 是质数；  \n对于 $100\\%$ 的测试点，$1 \\leq n \\leq 10^9, 0 \\leq r < k \\leq 50, 2 \\leq p \\leq 2^{30} - 1$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Six-Province Joint Exam 2017] Binomial Coefficients Problem", "background": "", "description": "The binomial coefficient $C_n^m$ denotes the number of ways to choose $m$ items from $n$ distinct items. For example, choosing two items from $(1, 2, 3)$ has three possibilities: $(1, 2)$, $(1, 3)$, $(2, 3)$. By definition, a general formula to compute $C_n^m$ is:\n\n$$ C_n^m = \\frac {n!} {m! \\ (n - m)!} $$\n\nwhere $n! = 1 \\times 2 \\times \\cdots \\times n$. (In particular, when $n = 0$, $n! = 1$; when $m > n$, $C_n^m = 0$.)\n\nXiaocong learned about the divisibility relationship between $C_i^j$ and $k$ during NOIP, and now he wants to go further and study more properties of binomial coefficients. He noticed that whether $C_i^j$ is a multiple of $k$ depends on whether $C_i^j \\bmod k$ equals $0$. This intriguing fact sparked his interest in the $\\mathrm{mod}$ operation (the remainder operation). Now Xiaocong chose four integers $n, p, k, r$, and he wants to know\n\n$$\\left( \\sum_{i = 0}^\\infty C_{nk}^{ik + r} \\right) \\bmod p,$$\n\nthat is,\n\n$$\\left( C_{nk}^{r} + C_{nk}^{k + r} + C_{nk}^{2k + r} + \\cdots + C_{nk}^{(n - 1)k + r}  + C_{nk}^{nk + r} + \\cdots \\right) \\bmod p.$$", "inputFormat": "The first line contains four integers $n, p, k, r$. All symbols have the meanings given in the problem statement.", "outputFormat": "Output a single integer, the answer.", "hint": "For $30\\%$ of the test points, $1 \\leq n, k \\leq 30$, and $p$ is prime.  \nFor another $5\\%$ of the test points, $p = 2$.  \nFor another $5\\%$ of the test points, $k = 1$.  \nFor another $10\\%$ of the test points, $k = 2$.  \nFor another $15\\%$ of the test points, $1 \\leq n \\leq 10^3$, $1 \\leq k \\leq 50$, and $p$ is prime.  \nFor another $15\\%$ of the test points, $1 \\leq n \\times k \\leq 10^6$, and $p$ is prime.  \nFor another $10\\%$ of the test points, $1 \\leq n \\leq 10^9$, $1 \\leq k \\leq 50$, and $p$ is prime.  \nFor $100\\%$ of the test points, $1 \\leq n \\leq 10^9$, $0 \\leq r < k \\leq 50$, $2 \\leq p \\leq 2^{30} - 1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[六省联考 2017] 组合数问题", "background": "", "description": "组合数 $C_n^m$ 表示的是从 $n$ 个互不相同的物品中选出 $m$ 个物品的方案数。举个例子， 从 $(1, 2, 3)$ 三个物品中选择两个物品可以有 $(1, 2)$，$(1, 3)$，$(2, 3)$ 这三种选择方法。根据组合数的定义，我们可以给出计算组合数  $C_n^m$  的一般公式：\n\n$$ C_n^m = \\frac {n!} {m! \\ (n - m)!}  $$\n\n其中 $n! = 1 \\times 2 \\times \\cdots \\times n$。（特别地，当 $n = 0$ 时，$n! = 1$；当 $m > n$ 时，$C_n^m = 0$。）\n\n小葱在 NOIP 的时候学习了 $C_i^j$ 和 $k$ 的倍数关系，现在他想更进一步，研究更多关于组合数的性质。小葱发现，$C_i^j$ 是否是 $k$ 的倍数，取决于 $C_i^j \\bmod k$ 是否等于 $0$，这个神奇的性质引发了小葱对 $\\mathrm{mod}$ 运算（取余数运算）的兴趣。现在小葱选择了是四个整数 $n, p, k, r$，他希望知道\n\n$$\\left( \\sum_{i = 0}^\\infty C_{nk}^{ik + r} \\right) \\bmod p,$$\n\n即\n\n$$\\left( C_{nk}^{r} + C_{nk}^{k + r} + C_{nk}^{2k + r} + \\cdots + C_{nk}^{(n - 1)k + r}  + C_{nk}^{nk + r} + \\cdots \\right) \\bmod p$$\n\n的值。", "inputFormat": "第一行有四个整数 $n, p, k, r$，所有整数含义见问题描述。", "outputFormat": "一行一个整数代表答案。", "hint": "对于 $30\\%$ 的测试点，$1 \\leq n, k \\leq 30$，$p$ 是质数；   \n对于另外 $5\\%$ 的测试点，$p = 2$；  \n对于另外 $5\\%$ 的测试点，$k = 1$；  \n对于另外 $10\\%$ 的测试点，$k = 2$；  \n对于另外 $15\\%$ 的测试点，$1 \\leq n \\leq 10^3, 1 \\leq k \\leq 50$，$p$ 是质数；  \n对于另外 $15\\%$ 的测试点，$1 \\leq n \\times k \\leq 10^6$，$p$ 是质数；  \n对于另外 $10\\%$ 的测试点，$1 \\leq n \\leq 10^9, 1 \\leq k \\leq 50$，$p$ 是质数；  \n对于 $100\\%$ 的测试点，$1 \\leq n \\leq 10^9, 0 \\leq r < k \\leq 50, 2 \\leq p \\leq 2^{30} - 1$。\n", "locale": "zh-CN"}}}
{"pid": "P3747", "type": "P", "difficulty": 6, "samples": [["4 4 7 2\n1 2 3 4\n0 1 4\n1 2 4\n0 1 4\n1 1 3", "0\n3"], ["1 40 19910626 2\n0\n0 1 1\n1 1 1\n0 1 1\n1 1 1\n0 1 1\n1 1 1\n0 1 1\n1 1 1\n0 1 1\n1 1 1\n0 1 1\n1 1 1\n0 1 1\n1 1 1\n0 1 1\n1 1 1\n0 1 1\n1 1 1\n0 1 1\n1 1 1\n0 1 1\n1 1 1\n0 1 1\n1 1 1\n0 1 1\n1 1 1\n0 1 1\n1 1 1\n0 1 1\n1 1 1\n0 1 1\n1 1 1\n0 1 1\n1 1 1\n0 1 1\n1 1 1\n0 1 1\n1 1 1\n0 1 1\n1 1 1", "1\n2\n4\n16\n65536\n11418102\n18325590\n13700558\n13700558\n13700558\n13700558\n13700558\n13700558\n13700558\n13700558\n13700558\n13700558\n13700558\n13700558\n13700558"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2017", "线段树", "并查集", "各省省选", "树状数组", "颜色段均摊（珂朵莉树 ODT）", "O2优化", "枚举", "素数判断,质数,筛法", "分块", "欧拉函数"], "title": "[六省联考 2017] 相逢是问候", "background": null, "description": "> Informatik verbindet dich und mich.  \n> 信息将你我连结。\n\nB 君希望你维护一个长度为 $n$ 的数组，这个数组的下标为从 $1$ 到 $n$ 的正整数。\n\n一共有 $m$ 个操作，可以分为两种：\n\n- `0 l r` 表示将第 $l$ 个到第 $r$ 个数（ $a_l,a_{l+1} ...a_r$）中的每一个数 $a_i$ 替换为 $c^{a_i}$，即 $c$ 的 $a_i$ 次方，其中 $c$ 是输入的一个常数，也就是执行赋值 $a_i = c^{a_i}$。\n\n- `1 l r` 求第 $l$ 个到第 $r$ 个数的和，也就是输出： $\\sum_{i=l}^{r}a_i$\n\n因为这个结果可能会很大，所以你只需要输出结果 $\\bmod \\space p$ 的值即可。", "inputFormat": "第一行有四个整数 $n, m, p, c$，所有整数含义见问题描述。  \n接下来一行 $n$ 个整数，表示 $a$ 数组的初始值。  \n接下来 $m$ 行，每行三个整数，其中第一个整数表示了操作的类型。  \n\n- 如果是 $0$ 的话，表示这是一个修改操作，操作的参数为 $l, r$。\n- 如果是 $1$ 的话，表示这是一个询问操作，操作的参数为 $l, r$。", "outputFormat": "对于每个询问操作，输出一行，包括一个整数表示答案 $\\bmod \\space p$ 的值。", "hint": "【数据范围】  \n\n对于 $0\\%$ 的测试点，和样例一模一样；\n\n对于另外 $10\\%$ 的测试点，没有修改；\n\n对于另外 $20\\%$ 的测试点，每次修改操作只会修改一个位置（也就是 $l = r$ ），并且每个位置至多被修改一次；\n\n• 对于另外 $10\\%$ 的测试点， $p = 2$；\n\n对于另外 $10\\%$ 的测试点， $p = 3$；\n\n对于另外 $10\\%$ 的测试点， $p = 4$；\n\n对于另外 $20\\%$ 的测试点， $1\\le n,m \\le 100$；\n\n对于 $100\\%$ 的测试点， $1\\le n,m \\le 5\\times 10^4$，$1 \\le p \\le 10^8$，$0< c < p$，$0 \\le a_i < p$。", "locale": "zh-CN", "translations": {"en": {"title": "[Six Provinces Joint Exam 2017] Greeting Upon Meeting", "background": "", "description": "> Informatik verbindet dich und mich.  \n> Information connects you and me.\n\nMr. B wants to maintain an array of length $n$, whose indices are the positive integers from $1$ to $n$.\n\nThere are $m$ operations, of two types:\n\n- `0 l r` means: for each number $a_i$ among the $l$-th to the $r$-th numbers ($a_l,a_{l+1} ...a_r$), replace $a_i$ with $c^{a_i}$, i.e., assign $a_i = c^{a_i}$, where $c$ is a given constant in the input.\n\n- `1 l r` asks for the sum of the $l$-th to the $r$-th numbers, i.e., output $\\sum_{i=l}^{r} a_i$.\n\nBecause the result can be very large, you only need to output the result $\\bmod \\space p$.", "inputFormat": "The first line contains four integers $n, m, p, c$, whose meanings are given in the problem statement.  \nThe next line contains $n$ integers, the initial values of the array $a$.  \nThe next $m$ lines each contain three integers; the first integer indicates the type of operation.\n\n- If it is `0`, this is an update operation with parameters $l, r$.\n- If it is `1`, this is a query operation with parameters $l, r$.", "outputFormat": "For each query operation, output one line with a single integer: the answer $\\bmod \\space p$.", "hint": "Constraints\n\n- For $0\\%$ of the test points, identical to the sample.\n- For another $10\\%$ of the test points, there are no updates.\n- For another $20\\%$ of the test points, each update modifies only one position (i.e., $l = r$), and each position is updated at most once.\n- For another $10\\%$ of the test points, $p = 2$.\n- For another $10\\%$ of the test points, $p = 3$.\n- For another $10\\%$ of the test points, $p = 4$.\n- For another $20\\%$ of the test points, $1\\le n, m \\le 100$.\n- For $100\\%$ of the test points, $1\\le n, m \\le 5\\times 10^4$, $1 \\le p \\le 10^8$, $0< c < p$, $0 \\le a_i < p$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[六省联考 2017] 相逢是问候", "background": null, "description": "> Informatik verbindet dich und mich.  \n> 信息将你我连结。\n\nB 君希望你维护一个长度为 $n$ 的数组，这个数组的下标为从 $1$ 到 $n$ 的正整数。\n\n一共有 $m$ 个操作，可以分为两种：\n\n- `0 l r` 表示将第 $l$ 个到第 $r$ 个数（ $a_l,a_{l+1} ...a_r$）中的每一个数 $a_i$ 替换为 $c^{a_i}$，即 $c$ 的 $a_i$ 次方，其中 $c$ 是输入的一个常数，也就是执行赋值 $a_i = c^{a_i}$。\n\n- `1 l r` 求第 $l$ 个到第 $r$ 个数的和，也就是输出： $\\sum_{i=l}^{r}a_i$\n\n因为这个结果可能会很大，所以你只需要输出结果 $\\bmod \\space p$ 的值即可。", "inputFormat": "第一行有四个整数 $n, m, p, c$，所有整数含义见问题描述。  \n接下来一行 $n$ 个整数，表示 $a$ 数组的初始值。  \n接下来 $m$ 行，每行三个整数，其中第一个整数表示了操作的类型。  \n\n- 如果是 $0$ 的话，表示这是一个修改操作，操作的参数为 $l, r$。\n- 如果是 $1$ 的话，表示这是一个询问操作，操作的参数为 $l, r$。", "outputFormat": "对于每个询问操作，输出一行，包括一个整数表示答案 $\\bmod \\space p$ 的值。", "hint": "【数据范围】  \n\n对于 $0\\%$ 的测试点，和样例一模一样；\n\n对于另外 $10\\%$ 的测试点，没有修改；\n\n对于另外 $20\\%$ 的测试点，每次修改操作只会修改一个位置（也就是 $l = r$ ），并且每个位置至多被修改一次；\n\n• 对于另外 $10\\%$ 的测试点， $p = 2$；\n\n对于另外 $10\\%$ 的测试点， $p = 3$；\n\n对于另外 $10\\%$ 的测试点， $p = 4$；\n\n对于另外 $20\\%$ 的测试点， $1\\le n,m \\le 100$；\n\n对于 $100\\%$ 的测试点， $1\\le n,m \\le 5\\times 10^4$，$1 \\le p \\le 10^8$，$0< c < p$，$0 \\le a_i < p$。", "locale": "zh-CN"}}}
{"pid": "P3748", "type": "P", "difficulty": 6, "samples": [["1 0\n13\n1 2\n2 3\n2 4\n4 5\n4 6\n4 7\n7 8\n7 9\n9 10\n10 11\n10 12\n12 13", "8"], ["8 0\n1\n2\n1 2\n3\n1 2\n2 3\n4\n1 3\n2 3\n2 4\n5\n1 5\n2 5\n3 5\n4 5\n16\n1 2\n1 3\n1 4\n1 5\n5 6\n5 7\n5 8\n5 9\n9 10\n9 11\n9 12\n9 13\n13 14\n13 15\n13 16\n17\n1 2\n1 3\n1 4\n1 5\n5 6\n5 7\n5 8\n5 17\n17 9\n9 10\n9 11\n9 12\n9 13\n13 14\n13 15\n13 16\n17\n8 6\n2 6\n11 6\n4 6\n14 2\n10 2\n5 4\n1 4\n9 8\n17 11\n12 5\n3 6\n13 6\n16 8\n7 11\n15 16\n", "0\n1\n2\n2\n4\n12\n13\n10\n"], ["8 1\n1 1 1\n2 1 1\n1 2\n3 2 2\n1 2\n2 3\n4 2 2\n1 3\n2 3\n2 4\n5 5 5\n1 5\n2 5\n3 5\n4 5\n16 1 5\n1 2\n1 3\n1 4\n1 5\n5 6\n5 7\n5 8\n5 9\n9 10\n9 11\n9 12\n9 13\n13 14\n13 15\n13 16\n17 1 5\n1 2\n1 3\n1 4\n1 5\n5 6\n5 7\n5 8\n5 17\n17 9\n9 10\n9 11\n9 12\n9 13\n13 14\n13 15\n13 16\n17 2 4\n8 6\n2 6\n11 6\n4 6\n14 2\n10 2\n5 4\n1 4\n9 8\n17 11\n12 5\n3 6\n13 6\n16 8\n7 11\n15 16\n", "0\n1\n2\n2\n4\n12\n13\n10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2017", "各省省选", "枚举"], "title": "[六省联考 2017] 摧毁“树状图”", "background": "", "description": "自从上次神刀手帮助蚯蚓国增添了上千万人口（蚯口？），蚯蚓国发展得越来越繁荣了！最近，他们在地下发现了一些神奇的纸张，经过仔细研究，居然是 D 国 X 市的超级计算机设计图纸！\n\n这台计算机叫做 “树状图”，由 $n$ 个计算节点与 $n - 1$ 条可以双向通信的网线连接而成，所有计算节点用不超过 $n$ 的正整数编号。顾名思义，这形成了一棵树的结构。\n\n蚯蚓国王已在图纸上掌握了这棵树的完整信息，包括 $n$ 的值与 $n - 1$ 条网线的连接信息。于是蚯蚓国王决定，派出蚯蚓国最强大的两个黑客，小 P 和小 H，入侵 “树状图”，尽可能地摧毁它。\n\n小 P 和小 H 精通世界上最好的编程语言，经过一番商量后，他们决定依次采取如 下的步骤：\n* 小 P 选择某个计算节点，作为他入侵的起始点，并在该节点上添加一个 **P** 标记。\n* 重复以下操作若干次（可以是 $0$ 次）：\n    * 小 P 从他当前所在的计算节点出发，选择一条没有被标记过的网线，入侵到该网线的另一端的计算节点，并在路过的网线与目的计算节点上均添加一个 **P** 标记。\n* 小 H 选择某个计算节点，作为她入侵的起始点，并在该节点上添加一个 **H** 标记。\n* 重复以下操作若干次（可以是 $0$ 次）：\n    * 小 H 从她当前所在的计算节点出发，选择一条没有被标记过的网线，入侵到该网线的另一端的计算节点，并在路过的网线与目的计算节点上均添加一个 **H** 标记。（注意，小 H 不能经过带有 **P** 标记的网线，但是可以经过带有 **P** 标记的计算节点）\n* 删除所有被标记过的计算节点和网线。\n* 对于剩下的每条网线，如果其一端或两端的计算节点在上一步被删除了，则也删除这条网线。\n\n经过以上操作后，“树状图” 会被断开，剩下若干个（可能是 $0$ 个）连通块。为了达到摧毁的目的，蚯蚓国王希望，连通块的个数越多越好。于是他找到了你，希望你能帮他计算这个最多的个数。\n\n小 P 和小 H 非常心急，在你计算方案之前，他们可能就已经算好了最优方案或最优方案的一部分。你能得到一个值 $x$：\n* 若 $x = 0$，则说明小 P 和小 H 没有算好最优方案，你需要确定他们两个的入侵路线。\n* 若 $x = 1$，则说明小 P 已经算好了某种两人合作的最优方案中，他的入侵路线。他将选择初始点 $p_0$，并沿着网线一路入侵到了目标点 $p_1$，并且他不会再沿着网线入侵；你只需要确定小 H 的入侵路线。\n* 若 $x = 2$，则说明小 P 和小 H 算好了一种两人合作的最优方案，小 P 从点 $p_0$ 入侵到了 $p_1$ 并停下，小 H 从点 $h_0$ 入侵到了 $h_1$ 并停下。此时你不需要指挥他们入侵了，只需要计算最后两步删除计算节点与网线后，剩下的连通块个数即可。", "inputFormat": "每个输入文件包含多个输入数据。输入文件的第一行为两个整数 $T$ 和 $x$，$T$ 表示该文件包含的输入数据个数，$x$ 的含义见上述。（同一个输入文件的所有数据的 x 都是相同的。）\n\n接下来依次输入每个数据。", "outputFormat": "对于每个数据，输出一行，表示在给定条件下，剩下连通块的最大个数。", "hint": "* 若 $x = 0$，则该行只有一个整数 $n$。\n* 若 $x = 1$，则该行依次有三个整数 $n, p_0, p_1$。\n* 若 $x = 2$，则该行依次有五个整数 $n, p_0, p_1, h_0, h_1$。\n\n保证 $p_0, p_1, h_0, h_1$ 均为不超过 $n$ 的正整数。\n\n每个数据接下来有 $n - 1$ 行，每行有两个不超过 $n$ 的正整数，表示这两个编号的计算节点之间有一条网线将其相连。保证输入的是一棵树。\n\n同一行相邻的整数之间用恰好一个空格隔开。\n\n**数据文件可能较大，请避免使用过慢的输入输出方法。**\n\n【样例 1 说明】\n\n这个输入文件只有一个输入数据。一种最优的方案如下：\n\n- 小 P 从节点 $2$ 开始入侵，节点 $2$ 被小 P 标记。\n\n- 小 P 从节点 $2$ 入侵到节点 $4$，节点 $4$ 和经过的网线被小 P 标记。\n\n- 小 P 从节点 $4$ 入侵到节点 $7$，节点 $7$ 和经过的网线被小 P 标记。\n\n- 小 H 从节点 $10$ 开始入侵，节点 $10$ 被小 H 标记。\n\n- 删除被标记的节点 $2,4,7,10$ 和被标记的网线 $(2,4)$ 和 $(4,7)$。\n\n- 删除任意一端在上一步被删除的网线。\n\n此时还剩下 $8$ 个连通块。其中节点 $1,3,5,6,8,9,11$ 各自形成一个连通块，节点$12,13$形成了一个连通块。\n\n\n【样例 2 说明】\n\n- 数据 1：只有 $1$ 个计算节点，唯一可行的方案是小 P 从节点 $1$ 开始入侵（并马上停止），小 H 也从节点 $1$ 入侵到节点 $1$。所有的节点都被删去，剩下 $0$ 个连通块。\n\n- 数据 2：一种最优方案是，小 P 从节点 $1$ 入侵到节点 $1$，小 H 也从节点 $1$ 入侵到节点 $1$。在删除操作后，剩下 $1$ 个连通块（只有节点 $2$）。\n\n- 数据 3：唯一的最优方案是，小 P 从节点 $2$ 入侵到节点 $2$，小 H 也从节点 $2$ 入侵到节点 $2$，剩下 $2$ 个连通块。\n\n- 数据 4：一种最优方案是，小 P 从节点 $2$ 入侵到节点 $2$，小 H 也从节点 $2$ 入侵到节点 $2$，剩下 $2$ 个连通块。\n\n- 数据 5：唯一的最优方案是，小 P 从节点 $5$ 入侵到节点 $5$，小 H 也从节点 $5$ 入侵到节点 $5$，剩下 $4$ 个连通块。\n\n\n\n![](https://cdn.luogu.com.cn/upload/pic/38934.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/38935.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/38936.png)\n\n对于整数 $k$，设$\\sum n^k$ 为某个输入文件中，其$ T$ 个输入数据的 $n^k$ 之和。\n\n对于所有数据，$T \\leq 10^5, \\sum n^1 <5 \\times 10^5$\n\n请注意初始化的时间复杂度，避免输入大量小数据时超时。\n\n每个测试点的详细数据范围见下表。如果表中 “完全二叉” 为 Yes，则该输入文件的每个数据满足：网线信息的第 $j$ 行 $(1 \\leq j < n)$ 输入的两个数依次是 $\\left\\lfloor \\frac {j + 1} {2} \\right\\rfloor$ 和 $j + 1$。\n\n![](https://cdn.luogu.com.cn/upload/pic/38937.png)", "locale": "zh-CN", "translations": {"en": {"title": "[Six-Province Joint Exam 2017] Destroy the \"Tree Diagram\"", "background": "", "description": "Since the last time the divine knife master helped Earthworm Country gain tens of millions of citizens (earth-citizens?), the country has become more and more prosperous! Recently, they discovered some magical papers underground. After careful study, it turned out to be the design blueprints of a supercomputer in City X of Country D!\n\nThis computer is called the \"Tree Diagram.\" It consists of $n$ computing nodes connected by $n - 1$ bidirectional communication links, and all computing nodes are labeled with positive integers not exceeding $n$. As the name suggests, this forms a tree structure.\n\nThe Earthworm King has fully mastered the information of this tree from the blueprints, including the value of $n$ and the connectivity of the $n - 1$ links. He decided to send the two most powerful hackers of Earthworm Country, P and H, to infiltrate the \"Tree Diagram\" and destroy it as much as possible.\n\nP and H are masters of the world's best programming language. After some discussion, they decided to proceed in the following steps:\n- P chooses a computing node as his starting point and adds a P mark to that node.\n- Repeat the following operation any number of times (possibly $0$ times):\n    - From his current computing node, P chooses a link that has not been marked, infiltrates to the computing node at the other end of that link, and adds a P mark to both the traversed link and the destination node.\n- H chooses a computing node as her starting point and adds an H mark to that node.\n- Repeat the following operation any number of times (possibly $0$ times):\n    - From her current computing node, H chooses a link that has not been marked, infiltrates to the computing node at the other end of that link, and adds an H mark to both the traversed link and the destination node. (Note: H cannot traverse links that have a P mark, but she may traverse nodes that have a P mark.)\n- Delete all computing nodes and links that have been marked.\n- For each remaining link, if one or both endpoints were deleted in the previous step, delete that link as well.\n\nAfter these operations, the \"Tree Diagram\" will be disconnected into several (possibly $0$) connected components. To maximize the damage, the Earthworm King hopes that the number of connected components is as large as possible. He turns to you to compute this maximum number.\n\nP and H are very impatient, and before you compute the plan, they may have already computed the optimal plan or part of it. You are given a value $x$:\n- If $x = 0$, then P and H have not computed the optimal plan. You need to determine the infiltration routes for both of them.\n- If $x = 1$, then P has already computed his infiltration route in some optimal cooperative plan. He will choose the starting point $p_0$ and infiltrate along links to the target point $p_1$, and then he will stop infiltrating. You only need to determine H’s infiltration route.\n- If $x = 2$, then P and H have computed an optimal cooperative plan. P infiltrates from $p_0$ to $p_1$ and stops, and H infiltrates from $h_0$ to $h_1$ and stops. In this case, you do not need to direct their infiltration; you only need to compute the number of connected components remaining after the last two deletion steps.", "inputFormat": "Each input file contains multiple datasets. The first line contains two integers $T$ and $x$, where $T$ is the number of datasets in the file, and the meaning of $x$ is as described above. (The same $x$ applies to all datasets in the same input file.)\n\nThen, for each dataset in order:\n- If $x = 0$: the first line of the dataset contains a single integer $n$.\n- If $x = 1$: the first line of the dataset contains three integers $n, p_0, p_1$.\n- If $x = 2$: the first line of the dataset contains five integers $n, p_0, p_1, h_0, h_1$.\n\nThis is followed by $n - 1$ lines, each containing two positive integers not exceeding $n$, indicating that there is a link connecting the two nodes with those labels. The input is guaranteed to form a tree.\n\nAdjacent integers on the same line are separated by exactly one space.", "outputFormat": "For each dataset, output one line containing the maximum possible number of connected components remaining under the given conditions.", "hint": "The values $p_0, p_1, h_0, h_1$ are guaranteed to be positive integers not exceeding $n$.\n\nThe data file may be large; please avoid overly slow input/output methods.\n\n[Sample 1 Explanation]\n\nThis input file contains only one dataset. One optimal plan is as follows:\n- P starts infiltrating from node $2$, and node $2$ is marked by P.\n- P infiltrates from node $2$ to node $4$, and node $4$ and the traversed link are marked by P.\n- P infiltrates from node $4$ to node $7$, and node $7$ and the traversed link are marked by P.\n- H starts infiltrating from node $10$, and node $10$ is marked by H.\n- Delete the marked nodes $2, 4, 7, 10$ and the marked links $(2, 4)$ and $(4, 7)$.\n- Delete any link with at least one endpoint deleted in the previous step.\n\nAt this point, there are $8$ connected components remaining. Nodes $1, 3, 5, 6, 8, 9, 11$ each form a connected component of their own, and nodes $12, 13$ form one connected component.\n\n[Sample 2 Explanation]\n- Dataset 1: There is only $1$ computing node. The only feasible plan is that P starts from node $1$ (and stops immediately), and H also infiltrates from node $1$ to node $1$. All nodes are deleted, leaving $0$ connected components.\n- Dataset 2: One optimal plan is that P infiltrates from node $1$ to node $1$, and H also infiltrates from node $1$ to node $1$. After the deletions, $1$ connected component remains (only node $2$).\n- Dataset 3: The only optimal plan is that P infiltrates from node $2$ to node $2$, and H also infiltrates from node $2$ to node $2$, leaving $2$ connected components.\n- Dataset 4: One optimal plan is that P infiltrates from node $2$ to node $2$, and H also infiltrates from node $2$ to node $2$, leaving $2$ connected components.\n- Dataset 5: The only optimal plan is that P infiltrates from node $5$ to node $5$, and H also infiltrates from node $5$ to node $5$, leaving $4$ connected components.\n\n![](https://cdn.luogu.com.cn/upload/pic/38934.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/38935.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/38936.png)\n\nFor an integer $k$, let $\\sum n^k$ denote the sum of $n^k$ over the $T$ datasets in an input file.\n\nConstraints for all data: $T \\leq 10^5$, $\\sum n^1 < 5 \\times 10^5$.\n\nPlease pay attention to initialization time complexity to avoid timeouts when there are many small datasets.\n\nFor each test point, the detailed constraints are shown in the table below. If “Complete Binary” is Yes in the table, then each dataset in the input file satisfies: on the $j$-th line of the link list $(1 \\leq j < n)$, the two numbers given are $\\left\\lfloor \\frac {j + 1} {2} \\right\\rfloor$ and $j + 1$, respectively.\n\n![](https://cdn.luogu.com.cn/upload/pic/38937.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[六省联考 2017] 摧毁“树状图”", "background": "", "description": "自从上次神刀手帮助蚯蚓国增添了上千万人口（蚯口？），蚯蚓国发展得越来越繁荣了！最近，他们在地下发现了一些神奇的纸张，经过仔细研究，居然是 D 国 X 市的超级计算机设计图纸！\n\n这台计算机叫做 “树状图”，由 $n$ 个计算节点与 $n - 1$ 条可以双向通信的网线连接而成，所有计算节点用不超过 $n$ 的正整数编号。顾名思义，这形成了一棵树的结构。\n\n蚯蚓国王已在图纸上掌握了这棵树的完整信息，包括 $n$ 的值与 $n - 1$ 条网线的连接信息。于是蚯蚓国王决定，派出蚯蚓国最强大的两个黑客，小 P 和小 H，入侵 “树状图”，尽可能地摧毁它。\n\n小 P 和小 H 精通世界上最好的编程语言，经过一番商量后，他们决定依次采取如 下的步骤：\n* 小 P 选择某个计算节点，作为他入侵的起始点，并在该节点上添加一个 **P** 标记。\n* 重复以下操作若干次（可以是 $0$ 次）：\n    * 小 P 从他当前所在的计算节点出发，选择一条没有被标记过的网线，入侵到该网线的另一端的计算节点，并在路过的网线与目的计算节点上均添加一个 **P** 标记。\n* 小 H 选择某个计算节点，作为她入侵的起始点，并在该节点上添加一个 **H** 标记。\n* 重复以下操作若干次（可以是 $0$ 次）：\n    * 小 H 从她当前所在的计算节点出发，选择一条没有被标记过的网线，入侵到该网线的另一端的计算节点，并在路过的网线与目的计算节点上均添加一个 **H** 标记。（注意，小 H 不能经过带有 **P** 标记的网线，但是可以经过带有 **P** 标记的计算节点）\n* 删除所有被标记过的计算节点和网线。\n* 对于剩下的每条网线，如果其一端或两端的计算节点在上一步被删除了，则也删除这条网线。\n\n经过以上操作后，“树状图” 会被断开，剩下若干个（可能是 $0$ 个）连通块。为了达到摧毁的目的，蚯蚓国王希望，连通块的个数越多越好。于是他找到了你，希望你能帮他计算这个最多的个数。\n\n小 P 和小 H 非常心急，在你计算方案之前，他们可能就已经算好了最优方案或最优方案的一部分。你能得到一个值 $x$：\n* 若 $x = 0$，则说明小 P 和小 H 没有算好最优方案，你需要确定他们两个的入侵路线。\n* 若 $x = 1$，则说明小 P 已经算好了某种两人合作的最优方案中，他的入侵路线。他将选择初始点 $p_0$，并沿着网线一路入侵到了目标点 $p_1$，并且他不会再沿着网线入侵；你只需要确定小 H 的入侵路线。\n* 若 $x = 2$，则说明小 P 和小 H 算好了一种两人合作的最优方案，小 P 从点 $p_0$ 入侵到了 $p_1$ 并停下，小 H 从点 $h_0$ 入侵到了 $h_1$ 并停下。此时你不需要指挥他们入侵了，只需要计算最后两步删除计算节点与网线后，剩下的连通块个数即可。", "inputFormat": "每个输入文件包含多个输入数据。输入文件的第一行为两个整数 $T$ 和 $x$，$T$ 表示该文件包含的输入数据个数，$x$ 的含义见上述。（同一个输入文件的所有数据的 x 都是相同的。）\n\n接下来依次输入每个数据。", "outputFormat": "对于每个数据，输出一行，表示在给定条件下，剩下连通块的最大个数。", "hint": "* 若 $x = 0$，则该行只有一个整数 $n$。\n* 若 $x = 1$，则该行依次有三个整数 $n, p_0, p_1$。\n* 若 $x = 2$，则该行依次有五个整数 $n, p_0, p_1, h_0, h_1$。\n\n保证 $p_0, p_1, h_0, h_1$ 均为不超过 $n$ 的正整数。\n\n每个数据接下来有 $n - 1$ 行，每行有两个不超过 $n$ 的正整数，表示这两个编号的计算节点之间有一条网线将其相连。保证输入的是一棵树。\n\n同一行相邻的整数之间用恰好一个空格隔开。\n\n**数据文件可能较大，请避免使用过慢的输入输出方法。**\n\n【样例 1 说明】\n\n这个输入文件只有一个输入数据。一种最优的方案如下：\n\n- 小 P 从节点 $2$ 开始入侵，节点 $2$ 被小 P 标记。\n\n- 小 P 从节点 $2$ 入侵到节点 $4$，节点 $4$ 和经过的网线被小 P 标记。\n\n- 小 P 从节点 $4$ 入侵到节点 $7$，节点 $7$ 和经过的网线被小 P 标记。\n\n- 小 H 从节点 $10$ 开始入侵，节点 $10$ 被小 H 标记。\n\n- 删除被标记的节点 $2,4,7,10$ 和被标记的网线 $(2,4)$ 和 $(4,7)$。\n\n- 删除任意一端在上一步被删除的网线。\n\n此时还剩下 $8$ 个连通块。其中节点 $1,3,5,6,8,9,11$ 各自形成一个连通块，节点$12,13$形成了一个连通块。\n\n\n【样例 2 说明】\n\n- 数据 1：只有 $1$ 个计算节点，唯一可行的方案是小 P 从节点 $1$ 开始入侵（并马上停止），小 H 也从节点 $1$ 入侵到节点 $1$。所有的节点都被删去，剩下 $0$ 个连通块。\n\n- 数据 2：一种最优方案是，小 P 从节点 $1$ 入侵到节点 $1$，小 H 也从节点 $1$ 入侵到节点 $1$。在删除操作后，剩下 $1$ 个连通块（只有节点 $2$）。\n\n- 数据 3：唯一的最优方案是，小 P 从节点 $2$ 入侵到节点 $2$，小 H 也从节点 $2$ 入侵到节点 $2$，剩下 $2$ 个连通块。\n\n- 数据 4：一种最优方案是，小 P 从节点 $2$ 入侵到节点 $2$，小 H 也从节点 $2$ 入侵到节点 $2$，剩下 $2$ 个连通块。\n\n- 数据 5：唯一的最优方案是，小 P 从节点 $5$ 入侵到节点 $5$，小 H 也从节点 $5$ 入侵到节点 $5$，剩下 $4$ 个连通块。\n\n\n\n![](https://cdn.luogu.com.cn/upload/pic/38934.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/38935.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/38936.png)\n\n对于整数 $k$，设$\\sum n^k$ 为某个输入文件中，其$ T$ 个输入数据的 $n^k$ 之和。\n\n对于所有数据，$T \\leq 10^5, \\sum n^1 <5 \\times 10^5$\n\n请注意初始化的时间复杂度，避免输入大量小数据时超时。\n\n每个测试点的详细数据范围见下表。如果表中 “完全二叉” 为 Yes，则该输入文件的每个数据满足：网线信息的第 $j$ 行 $(1 \\leq j < n)$ 输入的两个数依次是 $\\left\\lfloor \\frac {j + 1} {2} \\right\\rfloor$ 和 $j + 1$。\n\n![](https://cdn.luogu.com.cn/upload/pic/38937.png)", "locale": "zh-CN"}}}
{"pid": "P3749", "type": "P", "difficulty": 6, "samples": [["3 1\n2 3 2\n5 -10 15\n-10 15\n15", "12"], ["5 0\n1 4 1 3 4\n50 99 8 -39 30\n68 27 -75 -32\n70 24 72\n-10 81\n-95", "381"], ["10 1\n5 5 4 4 1 2 5 1 5 3\n83 91 72 29 22 -5 57 -14 -36 -3\n-11 34 45 96 32 73 -1 0 29\n-48 68 44 -5 96 66 17 74\n88 47 69 -9 2 25 -49\n86 -9 -77 62 -10 -30\n2 40 95 -74 46\n49 -52 2 -51\n-55 50 -44\n72 22\n-68", "1223"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "各省省选", "广度优先搜索 BFS", "深度优先搜索 DFS", "最小割"], "title": "[六省联考 2017] 寿司餐厅", "background": "", "description": "Kiana 最近喜欢到一家非常美味的寿司餐厅用餐。\n\n每天晚上，这家餐厅都会按顺序提供 $n$ 种寿司，第 $i$ 种寿司有一个代号 $a_i$ 和美味度 $d_{i, i}$，不同种类的寿司有可能使用相同的代号。每种寿司的份数都是无限的，Kiana 也可以无限次取寿司来吃，但每种寿司每次只能取一份，且每次取走的寿司必须是按餐厅提供寿司的顺序连续的一段，即 Kiana 可以一次取走第 $1, 2$ 种寿司各一份，也可以一次取走第 $2, 3$ 种寿司各一份，但不可以一次取走第 $1, 3$ 种寿司。\n\n由于餐厅提供的寿司种类繁多，而不同种类的寿司之间相互会有影响：三文鱼寿司和鱿鱼寿司一起吃或许会很棒，但和水果寿司一起吃就可能会肚子痛。因此，Kiana 定义了一个综合美味度 $d_{i, j} \\ (i < j)$，表示在一次取的寿司中，如果包含了餐厅提供的从第 $i$ 份到第 $j$ 份的所有寿司，吃掉这次取的所有寿司后将获得的额外美味度。由于取寿司需要花费一些时间，所以我们认为分两次取来的寿司之间相互不会影响。注意在吃一次取的寿司时，不止一个综合美味度会被累加，比如若 Kiana 一次取走了第 $1, 2, 3$ 种寿司各一份，除了 $d_{1, 3}$ 以外，$d_{1, 2}, d_{2, 3}$ 也会被累加进总美味度中。\n\n神奇的是，Kiana 的美食评判标准是有记忆性的，无论是单种寿司的美味度，还是多种寿司组合起来的综合美味度，在计入 Kiana 的总美味度时都只会被累加一次。比如，若 Kiana 某一次取走了第 $1, 2$ 种寿司各一份，另一次取走了第 $2, 3$ 种寿司各一份，那么这两次取寿司的总美味度为 $d_{1, 1} + d_{2, 2} + d_{3, 3} + d_{1, 2} + d_{2, 3}$，其中 $d_{2, 2}$ 只会计算一次。\n\n奇怪的是，这家寿司餐厅的收费标准很不同寻常。具体来说，如果 Kiana 一共吃过了 $c \\ (c > 0)$ **种**代号为 $x$ 的寿司，则她需要为这些寿司付出 $mx^2 + cx$ 元钱，其中 $m$ 是餐厅给出的一个常数。\n\n现在 Kiana 想知道，在这家餐厅吃寿司，自己能获得的总美味度（包括所有吃掉的单种寿司的美味度和所有被累加的综合美味度）减去花费的总钱数的最大值是多少。由于她不会算，所以希望由你告诉她。", "inputFormat": "第一行包含两个正整数 $n, m$，分别表示这家餐厅提供的寿司总数和计算寿司价格中使用的常数。  \n第二行包含 $n$ 个正整数，其中第 $k$ 个数 $a_k$ 表示第 $k$ 份寿司的代号。  \n接下来 $n$ 行，第 $i$ 行包含 $n - i + 1$ 个整数，其中第 $j$ 个数 $d_{i, i+j-1}$ 表示吃掉寿司能获得的相应的美味度，具体含义见问题描述。", "outputFormat": "输出共一行包含一个正整数，表示 Kiana 能获得的总美味度减去花费的总钱数的最大值。", "hint": "### 样例解释 1\n\n在这组样例中，餐厅一共提供了 $3$ 份寿司，它们的代号依次为 $a_1 = 2, a_2 = 3, a_3 = 2$，计算价格时的常数 $m = 1$。\n\n在保证每次取寿司都能获得新的美味度的前提下，Kiana 一共有 $14$ 种不同的吃寿司方案。以下列出其中几种：\n1. Kiana 一个寿司也不吃，这样她获得的总美味度和花费的总钱数都是 $0$，两者相减也是 $0$；\n2. Kiana 只取 $1$ 次寿司，且只取第 $1$ 个寿司，即她取寿司的情况为 $\\{[1, 1]\\}$，这样获得的总美味度为 $5$，花费的总钱数为 $1 \\times 2^2 + 1 \\times 2 = 6$，两者相减为 $-1$；\n3. Kiana 取 $2$ 次寿司，第一次取第 $1, 2$ 个寿司，第二次取第 $2, 3$ 个寿司，即她取寿司的情况为 $\\{[1, 2], [2, 3]\\}$，这样获得的总美味度为 $5 + (-10) + 15 + (-10) + 15 = 15$，花费的总钱数为 $(1 \\times 2^2 + 2 \\times 2) + (1 \\times 3^2 + 1 \\times 3) = 20$，两者相减为 $-5$；\n4. Kiana 取 $2$ 次寿司，第一次取第 $1$ 个寿司，第二次取第 $3$ 个寿司，即她取寿司的情况为 $\\{[1, 1], [3, 3]\\}$，这样获得的总美味度为 $5 + 15 = 20$，花费的总钱数为 $1 \\times 2^2 + 2 \\times 2 = 8$，两者相减为 $12$。\n\n在 $14$ 种方案中，惟一的最优方案是列出的最后一种方案，这时她获得的总美味度减去花费的总钱数的值最大为 $12$。\n\n### 数据范围\n\n对于所有数据，保证 $-500 \\leq d_{i, j} \\leq 500$。\n\n数据的一些特殊约定如下表：\n\n| Case # | $n$ | $a_i$ | $m$ | 附加限制 |\n|:-:|:-:|:-:|:-:|:-:|\n| 1 | $\\leq 2$ | $\\leq 30$ | $= 0$ | - |\n| 2 | $\\leq 2$ | $\\leq 30$ | $= 1$ | - |\n| 3 | $\\leq 3$ | $\\leq 30$ | $= 0$ | - |\n| 4 | $\\leq 3$ | $\\leq 30$ | $= 1$ | - |\n| 5 | $\\leq 5$ | $\\leq 30$ | $= 0$ | - |\n| 6 | $\\leq 5$ | $\\leq 30$ | $= 1$ | - |\n| 7 | $\\leq 10$ | $\\leq 30$ | $= 0$ | 所有的 $a_i$ 相同 |\n| 8 | $\\leq 10$ | $\\leq 30$ | $= 1$ | - |\n| 9 | $\\leq 15$ | $\\leq 30$ | $= 0$ | 所有的 $a_i$ 相同 |\n| 10 | $\\leq 15$ | $\\leq 30$ | $= 1$ | - |\n| 11 | $\\leq 30$ | $\\leq 1000$ | $= 0$ | 所有的 $a_i$ 相同 |\n| 12 | $\\leq 30$ | $\\leq 30$ | $= 0$ | 所有的 $a_i$ 相同 |\n| 13 | $\\leq 30$ | $\\leq 1000$ | $= 0$ | - |\n| 14 | $\\leq 30$ | $\\leq 1000$ | $= 1$ | - |\n| 15 | $\\leq 50$ | $\\leq 1000$ | $= 0$ | 所有的 $a_i$ 相同 |\n| 16 | $\\leq 50$ | $\\leq 30$ | $= 0$ | 所有的 $a_i$ 相同 |\n| 17 | $\\leq 50$ | $\\leq 1000$ | $= 0$ | - |\n| 18 | $\\leq 50$ | $\\leq 1000$ | $= 1$ | - |\n| 19 | $\\leq 100$ | $\\leq 1000$ | $= 0$ | - |\n| 20 | $\\leq 100$ | $\\leq 1000$ | $= 1$ | - |", "locale": "zh-CN", "translations": {"en": {"title": "[Six-Province Joint Exam 2017] Sushi Restaurant", "background": "", "description": "Kiana has recently been dining at a very delicious sushi restaurant.\n\nEvery evening, the restaurant serves $n$ types of sushi in order. The $i$-th sushi has a code $a_i$ and a deliciousness $d_{i, i}$. Different types of sushi may share the same code. Each type has an unlimited number of servings, and Kiana can take sushi an unlimited number of times; however, in each take she can take at most one serving of each type, and the taken sushi in a single take must form a contiguous segment in the serving order. That is, Kiana may take one serving each of types $1$ and $2$ in one take, or types $2$ and $3$ in one take, but she may not take types $1$ and $3$ together in a single take.\n\nBecause there are many types and they may interact: salmon and squid together might be great, but together with fruit sushi might cause a stomachache. Therefore, Kiana defines a comprehensive deliciousness $d_{i, j}$ for $i < j$, meaning that if, in a single take, she includes all sushi from the $i$-th to the $j$-th served by the restaurant, then after eating all sushi taken in that take she will gain an extra deliciousness of $d_{i, j}$. Since taking sushi takes some time, we assume that sushi taken in different takes do not interact. Note that when eating sushi from a single take, more than one comprehensive deliciousness will be added. For example, if Kiana takes one serving each of types $1, 2, 3$ in a single take, then besides $d_{1, 3}$, $d_{1, 2}$ and $d_{2, 3}$ will also be added to the total deliciousness.\n\nMagically, Kiana’s evaluation of food has memory: whether it is the deliciousness of a single type of sushi or the comprehensive deliciousness of a combination, each will be added to Kiana’s total deliciousness at most once. For example, if Kiana once takes one serving each of types $1$ and $2$, and another time takes one serving each of types $2$ and $3$, then the total deliciousness of these two takes is $d_{1, 1} + d_{2, 2} + d_{3, 3} + d_{1, 2} + d_{2, 3}$, where $d_{2, 2}$ is counted only once.\n\nStrangely, the restaurant’s pricing policy is unusual. Specifically, if Kiana has eaten in total $c \\ (c > 0)$ kinds of sushi with code $x$, she must pay $m x^2 + c x$ yuan for those sushi, where $m$ is a constant given by the restaurant.\n\nNow Kiana wants to know, when eating at this restaurant, what is the maximum value of the total deliciousness (including the deliciousness of all eaten single types and all accumulated comprehensive deliciousness) minus the total amount of money paid. Since she cannot compute it, she asks you to tell her.", "inputFormat": "The first line contains two positive integers $n, m$, denoting the total number of sushi types served by the restaurant and the constant used in pricing.  \nThe second line contains $n$ positive integers, where the $k$-th number $a_k$ is the code of the $k$-th sushi.  \nThen follow $n$ lines. The $i$-th of these lines contains $n - i + 1$ integers, where the $j$-th number is $d_{i, i + j - 1}$, representing the corresponding deliciousness obtained by eating the sushi, as described above.", "outputFormat": "Output a single line containing a positive integer, which is the maximum value of the total deliciousness Kiana can obtain minus the total amount of money paid.", "hint": "### Sample Explanation 1\n\nIn this sample, the restaurant serves $3$ sushi in total, with codes $a_1 = 2, a_2 = 3, a_3 = 2$, and the constant for pricing is $m = 1$.\n\nUnder the requirement that each take must yield new deliciousness, Kiana has $14$ distinct ways to eat. Some of them are listed below:\n1. Kiana eats nothing. Then her total deliciousness and total payment are both $0$, and their difference is also $0$.\n2. Kiana takes sushi exactly once, and only takes the $1$-st sushi, i.e., her takes are $\\{[1, 1]\\}$. Then the total deliciousness is $5$, the total payment is $1 \\times 2^2 + 1 \\times 2 = 6$, and the difference is $-1$.\n3. Kiana takes sushi twice: the first time the $1$-st and $2$-nd sushi, and the second time the $2$-nd and $3$-rd sushi, i.e., her takes are $\\{[1, 2], [2, 3]\\}$. Then the total deliciousness is $5 + (-10) + 15 + (-10) + 15 = 15$, the total payment is $(1 \\times 2^2 + 2 \\times 2) + (1 \\times 3^2 + 1 \\times 3) = 20$, and the difference is $-5$.\n4. Kiana takes sushi twice: the first time the $1$-st sushi, and the second time the $3$-rd sushi, i.e., her takes are $\\{[1, 1], [3, 3]\\}$. Then the total deliciousness is $5 + 15 = 20$, the total payment is $1 \\times 2^2 + 2 \\times 2 = 8$, and the difference is $12$.\n\nAmong the $14$ plans, the unique optimal plan is the last one listed, where the maximum value of total deliciousness minus total payment is $12$.\n\n### Constraints\n\nFor all testdata, it is guaranteed that $-500 \\leq d_{i, j} \\leq 500$.\n\nAdditional special constraints on the data are as follows:\n\n| Case # | $n$ | $a_i$ | $m$ | Additional constraint |\n|:-:|:-:|:-:|:-:|:-:|\n| 1 | $\\leq 2$ | $\\leq 30$ | $= 0$ | - |\n| 2 | $\\leq 2$ | $\\leq 30$ | $= 1$ | - |\n| 3 | $\\leq 3$ | $\\leq 30$ | $= 0$ | - |\n| 4 | $\\leq 3$ | $\\leq 30$ | $= 1$ | - |\n| 5 | $\\leq 5$ | $\\leq 30$ | $= 0$ | - |\n| 6 | $\\leq 5$ | $\\leq 30$ | $= 1$ | - |\n| 7 | $\\leq 10$ | $\\leq 30$ | $= 0$ | All $a_i$ are the same |\n| 8 | $\\leq 10$ | $\\leq 30$ | $= 1$ | - |\n| 9 | $\\leq 15$ | $\\leq 30$ | $= 0$ | All $a_i$ are the same |\n| 10 | $\\leq 15$ | $\\leq 30$ | $= 1$ | - |\n| 11 | $\\leq 30$ | $\\leq 1000$ | $= 0$ | All $a_i$ are the same |\n| 12 | $\\leq 30$ | $\\leq 30$ | $= 0$ | All $a_i$ are the same |\n| 13 | $\\leq 30$ | $\\leq 1000$ | $= 0$ | - |\n| 14 | $\\leq 30$ | $\\leq 1000$ | $= 1$ | - |\n| 15 | $\\leq 50$ | $\\leq 1000$ | $= 0$ | All $a_i$ are the same |\n| 16 | $\\leq 50$ | $\\leq 30$ | $= 0$ | All $a_i$ are the same |\n| 17 | $\\leq 50$ | $\\leq 1000$ | $= 0$ | - |\n| 18 | $\\leq 50$ | $\\leq 1000$ | $= 1$ | - |\n| 19 | $\\leq 100$ | $\\leq 1000$ | $= 0$ | - |\n| 20 | $\\leq 100$ | $\\leq 1000$ | $= 1$ | - |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[六省联考 2017] 寿司餐厅", "background": "", "description": "Kiana 最近喜欢到一家非常美味的寿司餐厅用餐。\n\n每天晚上，这家餐厅都会按顺序提供 $n$ 种寿司，第 $i$ 种寿司有一个代号 $a_i$ 和美味度 $d_{i, i}$，不同种类的寿司有可能使用相同的代号。每种寿司的份数都是无限的，Kiana 也可以无限次取寿司来吃，但每种寿司每次只能取一份，且每次取走的寿司必须是按餐厅提供寿司的顺序连续的一段，即 Kiana 可以一次取走第 $1, 2$ 种寿司各一份，也可以一次取走第 $2, 3$ 种寿司各一份，但不可以一次取走第 $1, 3$ 种寿司。\n\n由于餐厅提供的寿司种类繁多，而不同种类的寿司之间相互会有影响：三文鱼寿司和鱿鱼寿司一起吃或许会很棒，但和水果寿司一起吃就可能会肚子痛。因此，Kiana 定义了一个综合美味度 $d_{i, j} \\ (i < j)$，表示在一次取的寿司中，如果包含了餐厅提供的从第 $i$ 份到第 $j$ 份的所有寿司，吃掉这次取的所有寿司后将获得的额外美味度。由于取寿司需要花费一些时间，所以我们认为分两次取来的寿司之间相互不会影响。注意在吃一次取的寿司时，不止一个综合美味度会被累加，比如若 Kiana 一次取走了第 $1, 2, 3$ 种寿司各一份，除了 $d_{1, 3}$ 以外，$d_{1, 2}, d_{2, 3}$ 也会被累加进总美味度中。\n\n神奇的是，Kiana 的美食评判标准是有记忆性的，无论是单种寿司的美味度，还是多种寿司组合起来的综合美味度，在计入 Kiana 的总美味度时都只会被累加一次。比如，若 Kiana 某一次取走了第 $1, 2$ 种寿司各一份，另一次取走了第 $2, 3$ 种寿司各一份，那么这两次取寿司的总美味度为 $d_{1, 1} + d_{2, 2} + d_{3, 3} + d_{1, 2} + d_{2, 3}$，其中 $d_{2, 2}$ 只会计算一次。\n\n奇怪的是，这家寿司餐厅的收费标准很不同寻常。具体来说，如果 Kiana 一共吃过了 $c \\ (c > 0)$ **种**代号为 $x$ 的寿司，则她需要为这些寿司付出 $mx^2 + cx$ 元钱，其中 $m$ 是餐厅给出的一个常数。\n\n现在 Kiana 想知道，在这家餐厅吃寿司，自己能获得的总美味度（包括所有吃掉的单种寿司的美味度和所有被累加的综合美味度）减去花费的总钱数的最大值是多少。由于她不会算，所以希望由你告诉她。", "inputFormat": "第一行包含两个正整数 $n, m$，分别表示这家餐厅提供的寿司总数和计算寿司价格中使用的常数。  \n第二行包含 $n$ 个正整数，其中第 $k$ 个数 $a_k$ 表示第 $k$ 份寿司的代号。  \n接下来 $n$ 行，第 $i$ 行包含 $n - i + 1$ 个整数，其中第 $j$ 个数 $d_{i, i+j-1}$ 表示吃掉寿司能获得的相应的美味度，具体含义见问题描述。", "outputFormat": "输出共一行包含一个正整数，表示 Kiana 能获得的总美味度减去花费的总钱数的最大值。", "hint": "### 样例解释 1\n\n在这组样例中，餐厅一共提供了 $3$ 份寿司，它们的代号依次为 $a_1 = 2, a_2 = 3, a_3 = 2$，计算价格时的常数 $m = 1$。\n\n在保证每次取寿司都能获得新的美味度的前提下，Kiana 一共有 $14$ 种不同的吃寿司方案。以下列出其中几种：\n1. Kiana 一个寿司也不吃，这样她获得的总美味度和花费的总钱数都是 $0$，两者相减也是 $0$；\n2. Kiana 只取 $1$ 次寿司，且只取第 $1$ 个寿司，即她取寿司的情况为 $\\{[1, 1]\\}$，这样获得的总美味度为 $5$，花费的总钱数为 $1 \\times 2^2 + 1 \\times 2 = 6$，两者相减为 $-1$；\n3. Kiana 取 $2$ 次寿司，第一次取第 $1, 2$ 个寿司，第二次取第 $2, 3$ 个寿司，即她取寿司的情况为 $\\{[1, 2], [2, 3]\\}$，这样获得的总美味度为 $5 + (-10) + 15 + (-10) + 15 = 15$，花费的总钱数为 $(1 \\times 2^2 + 2 \\times 2) + (1 \\times 3^2 + 1 \\times 3) = 20$，两者相减为 $-5$；\n4. Kiana 取 $2$ 次寿司，第一次取第 $1$ 个寿司，第二次取第 $3$ 个寿司，即她取寿司的情况为 $\\{[1, 1], [3, 3]\\}$，这样获得的总美味度为 $5 + 15 = 20$，花费的总钱数为 $1 \\times 2^2 + 2 \\times 2 = 8$，两者相减为 $12$。\n\n在 $14$ 种方案中，惟一的最优方案是列出的最后一种方案，这时她获得的总美味度减去花费的总钱数的值最大为 $12$。\n\n### 数据范围\n\n对于所有数据，保证 $-500 \\leq d_{i, j} \\leq 500$。\n\n数据的一些特殊约定如下表：\n\n| Case # | $n$ | $a_i$ | $m$ | 附加限制 |\n|:-:|:-:|:-:|:-:|:-:|\n| 1 | $\\leq 2$ | $\\leq 30$ | $= 0$ | - |\n| 2 | $\\leq 2$ | $\\leq 30$ | $= 1$ | - |\n| 3 | $\\leq 3$ | $\\leq 30$ | $= 0$ | - |\n| 4 | $\\leq 3$ | $\\leq 30$ | $= 1$ | - |\n| 5 | $\\leq 5$ | $\\leq 30$ | $= 0$ | - |\n| 6 | $\\leq 5$ | $\\leq 30$ | $= 1$ | - |\n| 7 | $\\leq 10$ | $\\leq 30$ | $= 0$ | 所有的 $a_i$ 相同 |\n| 8 | $\\leq 10$ | $\\leq 30$ | $= 1$ | - |\n| 9 | $\\leq 15$ | $\\leq 30$ | $= 0$ | 所有的 $a_i$ 相同 |\n| 10 | $\\leq 15$ | $\\leq 30$ | $= 1$ | - |\n| 11 | $\\leq 30$ | $\\leq 1000$ | $= 0$ | 所有的 $a_i$ 相同 |\n| 12 | $\\leq 30$ | $\\leq 30$ | $= 0$ | 所有的 $a_i$ 相同 |\n| 13 | $\\leq 30$ | $\\leq 1000$ | $= 0$ | - |\n| 14 | $\\leq 30$ | $\\leq 1000$ | $= 1$ | - |\n| 15 | $\\leq 50$ | $\\leq 1000$ | $= 0$ | 所有的 $a_i$ 相同 |\n| 16 | $\\leq 50$ | $\\leq 30$ | $= 0$ | 所有的 $a_i$ 相同 |\n| 17 | $\\leq 50$ | $\\leq 1000$ | $= 0$ | - |\n| 18 | $\\leq 50$ | $\\leq 1000$ | $= 1$ | - |\n| 19 | $\\leq 100$ | $\\leq 1000$ | $= 0$ | - |\n| 20 | $\\leq 100$ | $\\leq 1000$ | $= 1$ | - |", "locale": "zh-CN"}}}
{"pid": "P3750", "type": "P", "difficulty": 6, "samples": [["4 0\n0 0 1 1\n", "512"], ["5 0\n1 0 1 1 1", "5120"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "递推", "2017", "各省省选", "枚举", "期望"], "title": "[六省联考 2017] 分手是祝愿", "background": "", "description": "> Zeit und Raum trennen dich und mich.\n时空将你我分开。\n\nB 君在玩一个游戏，这个游戏由 $n$ 个灯和 $n$ 个开关组成，给定这 $n$ 个灯的初始状态，下标为从 $1$ 到 $n$ 的正整数。\n\n每个灯有两个状态亮和灭，我们用 $1$ 来表示这个灯是亮的，用 $0$ 表示这个灯是灭的，游戏的目标是使所有灯都灭掉。\n\n但是当操作第 $i$ 个开关时，所有编号为 $i$ 的约数（包括 $1$ 和 $i$）的灯的状态都会被改变，即从亮变成灭，或者是从灭变成亮。\n\nB 君发现这个游戏很难，于是想到了这样的一个策略，每次等概率随机操作一个开关，直到所有灯都灭掉。\n\n这个策略需要的操作次数很多，B 君想到这样的一个优化。如果当前局面，可以通过操作小于等于 $k$ 个开关使所有灯都灭掉，那么他将不再随机，直接选择操作次数最小的操作方法（这个策略显然小于等于 $k$ 步）操作这些开关。\n\nB 君想知道按照这个策略（也就是先随机操作，最后小于等于 $k$ 步，使用操作次数最小的操作方法）的操作次数的期望。\n\n这个期望可能很大，但是 B 君发现这个期望乘以 $n$ 的阶乘一定是整数，所以他只需要知道这个整数对 $100003$ 取模之后的结果。\n", "inputFormat": "第一行两个整数 $n, k$。\n接下来一行 $n$ 个整数，每个整数是 $0$ 或者 $1$，其中第 $i$ 个整数表示第 $i$ 个灯的初始情况。\n", "outputFormat": "输出一行，为操作次数的期望乘以 $n$ 的阶乘对 $100003$ 取模之后的结果。\n", "hint": "对于 $0\\%$ 的测试点，和样例一模一样；  \n对于另外 $30\\%$ 的测试点，$n \\leq 10$；  \n对于另外 $20\\%$ 的测试点，$n \\leq 100$；  \n对于另外 $30\\%$ 的测试点，$n \\leq 1000$；  \n对于 $100\\%$ 的测试点，$1 \\leq n \\leq 100000, 0 \\leq k \\leq n$；  \n对于以上每部分测试点，均有一半的数据满足 $k = n$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Six-Province Joint Exam 2017] Breakup Is a Blessing", "background": "", "description": "> Zeit und Raum trennen dich und mich.\nTime and space separate you and me.\n\nB-kun is playing a game with $n$ lights and $n$ switches. The $n$ lights have initial states and are indexed by the positive integers from $1$ to $n$.\n\nEach light has two states, on and off. We use $1$ to indicate the light is on and $0$ to indicate it is off. The goal of the game is to turn all lights off.\n\nWhen operating the $i$-th switch, the states of all lights whose indices are divisors of $i$ (including $1$ and $i$) are toggled, i.e., on becomes off, and off becomes on.\n\nB-kun finds this game difficult, so he considers the following strategy: at each step, uniformly at random choose one switch to operate, until all lights are off.\n\nThis strategy may require many operations, so B-kun thinks of the following optimization. If, in the current state, it is possible to turn all lights off by pressing at most $k$ switches, then he will stop acting randomly and directly choose a method with the minimum number of operations (which is clearly at most $k$) to press those switches.\n\nB-kun wants to know the expected number of operations under this strategy (that is, act randomly first, and finally, if at most $k$ steps suffice, use the method with the minimum number of operations).\n\nThis expectation may be large, but B-kun observes that the expectation multiplied by $n!$ is always an integer, so he only needs this integer modulo $100003$.", "inputFormat": "The first line contains two integers $n, k$.  \nThe next line contains $n$ integers, each being $0$ or $1$, where the $i$-th integer indicates the initial state of the $i$-th light.", "outputFormat": "Output one line: the expectation of the number of operations multiplied by $n!$, modulo $100003$.", "hint": "For $0\\%$ of the testdata, the input is identical to the sample.  \nFor an additional $30\\%$ of the testdata, $n \\leq 10$.  \nFor an additional $20\\%$ of the testdata, $n \\leq 100$.  \nFor an additional $30\\%$ of the testdata, $n \\leq 1000$.  \nFor $100\\%$ of the testdata, $1 \\leq n \\leq 100000, 0 \\leq k \\leq n$.  \nFor each of the above parts of the testdata, half of the testdata satisfies $k = n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[六省联考 2017] 分手是祝愿", "background": "", "description": "> Zeit und Raum trennen dich und mich.\n时空将你我分开。\n\nB 君在玩一个游戏，这个游戏由 $n$ 个灯和 $n$ 个开关组成，给定这 $n$ 个灯的初始状态，下标为从 $1$ 到 $n$ 的正整数。\n\n每个灯有两个状态亮和灭，我们用 $1$ 来表示这个灯是亮的，用 $0$ 表示这个灯是灭的，游戏的目标是使所有灯都灭掉。\n\n但是当操作第 $i$ 个开关时，所有编号为 $i$ 的约数（包括 $1$ 和 $i$）的灯的状态都会被改变，即从亮变成灭，或者是从灭变成亮。\n\nB 君发现这个游戏很难，于是想到了这样的一个策略，每次等概率随机操作一个开关，直到所有灯都灭掉。\n\n这个策略需要的操作次数很多，B 君想到这样的一个优化。如果当前局面，可以通过操作小于等于 $k$ 个开关使所有灯都灭掉，那么他将不再随机，直接选择操作次数最小的操作方法（这个策略显然小于等于 $k$ 步）操作这些开关。\n\nB 君想知道按照这个策略（也就是先随机操作，最后小于等于 $k$ 步，使用操作次数最小的操作方法）的操作次数的期望。\n\n这个期望可能很大，但是 B 君发现这个期望乘以 $n$ 的阶乘一定是整数，所以他只需要知道这个整数对 $100003$ 取模之后的结果。\n", "inputFormat": "第一行两个整数 $n, k$。\n接下来一行 $n$ 个整数，每个整数是 $0$ 或者 $1$，其中第 $i$ 个整数表示第 $i$ 个灯的初始情况。\n", "outputFormat": "输出一行，为操作次数的期望乘以 $n$ 的阶乘对 $100003$ 取模之后的结果。\n", "hint": "对于 $0\\%$ 的测试点，和样例一模一样；  \n对于另外 $30\\%$ 的测试点，$n \\leq 10$；  \n对于另外 $20\\%$ 的测试点，$n \\leq 100$；  \n对于另外 $30\\%$ 的测试点，$n \\leq 1000$；  \n对于 $100\\%$ 的测试点，$1 \\leq n \\leq 100000, 0 \\leq k \\leq n$；  \n对于以上每部分测试点，均有一半的数据满足 $k = n$。\n", "locale": "zh-CN"}}}
{"pid": "P3752", "type": "P", "difficulty": 4, "samples": [["4\nQzrian yy ghy qzr\nYugoslavian mihailova petrozavodsk saint-petersburg\nSuissvia yugoslavia korse mais kohnin\nMohaian Jzm Wallace Zhangbaohua djh \n\nyy,qzr and ghy are i don't know\nmihailova saZk amOmlio\nmais c'est pas Ca\nwallace is good\n", "Qzrian\nYugoslavian\nSuissvia\nMohaian\n\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创", "洛谷比赛"], "title": "语言普查", "background": "“Kiaosmaonsnai Assi fi wais.”\n\n“Kjamqosoaksi mais pas?”\n\n“Oci! Asia olo mnai naso!”\n\n“2333 在说什么啊根本听不懂……”\n\n这是 Yugo 国的日常……\n\nYugo 国的人民在进行一次人口普查，由于 Yugo 国是典型的多民族国家，所以拥有许多种语言。", "description": "Yugo 国有许多不同的种族，总共有 $N$ 种不同的语言，但是主![]()席扔给了你几本字典，这样，你就知道他们在说什么语了。你的任务就是判断他们在说什么语并填上户口本。\n\n具体的，给出 $N$ 种语言的名称以及已知的来自该语言的若干个单词，保证每个单词最多出现在一种语言中。同时你还会得到若干个句子，对于每个句子，你都需要判断它属于哪种语言（单词匹配不区分大小写）。\n\n一个句子是一个仅包含大小写字母、空格、`-`、`'`、`.`、`,`、`?`、`!`、`;`、`(` 和 `)` 的字符串，其中有且仅有 `.`、`,`、`?`、`!`、`;`、`(` 和 `)` 是分隔符。一个句子由若干个单词和分隔符构成。\n\n句子中每个极大的不包含分隔符的子串都是一个单词。即：若一个句子的子串 $S$ 不包含分隔符，且不存在该句子的另一个子串 $T$ 满足 $T$ 不包含分隔符、$S$ 是 $T$ 的子串且 $S\\ne T$，则 $S$ 是该句子中的一个单词。\n\n同时，输入数据中的句子有以下性质：\n\n- 一个句子中不会同时包含来自不同语言的两个单词。\n- 一个句子中包含至少一个来自一种语言的单词。\n- 一个句子中可能出现在任何一个语言的已知词语中都没有出现过的词语。\n\n一个句子属于一种语言当且仅当该句子中存在一个单词 $S$ 来自该语言。", "inputFormat": "第一行一个整数 $N$，表示不同语言的数量。\n\n接下来 $N$ 行，依次是该语言的名称和该语言中的若干个单词，单词之间用空格隔开。\n\n接下来一行为空行。\n\n接下来若干行（不超过 $10^3$ 行），每行一个句子。", "outputFormat": "对于每个句子，输出一行一个字符串，表示该句子属于的语言的名称。", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le 100$，输入数据每行不超过 $256$ 个字符。", "locale": "zh-CN", "translations": {"en": {"title": "Language Census", "background": "“Kiaosmaonsnai Assi fi wais.”\n\n“Kjamqosoaksi mais pas?”\n\n“Oci! Asia olo mnai naso!”\n\n“2333 what are they even saying, I can’t understand at all...”\n\nThis is everyday life in Yugo.\n\nThe people of Yugo are conducting a population census. Since Yugo is a typical multi-ethnic country, it has many languages.", "description": "There are many different ethnic groups in Yugo. In total there are $N$ different languages, but the chairperson threw you a few dictionaries, so now you can understand what they are speaking. Your task is to determine which language they are speaking and fill it in the register.\n\nSpecifically, you are given the names of $N$ languages and several known words from each language. It is guaranteed that each word appears in at most one language. You are also given several sentences. For each sentence, you need to determine which language it belongs to (word matching is case-insensitive).\n\nA sentence is a string that contains only uppercase and lowercase letters, spaces, `-`, `'`, `.`, `,`, `?`, `!`, `;`, `(` and `)`, among which, and only among which, space, `.`, `,`, `?`, `!`, `;`, `(` and `)` are separators. A sentence consists of several words and separators.\n\nEach maximal substring that does not contain separators is a word. That is, if a substring $S$ of a sentence contains no separators, and there does not exist another substring $T$ of the sentence such that $T$ contains no separators, $S$ is a substring of $T$, and $S \\ne T$, then $S$ is a word in that sentence.\n\nAdditionally, the sentences in the input have the following properties:\n- A sentence will not contain two words from different languages at the same time.\n- A sentence contains at least one word from some language.\n- A sentence may contain words that do not appear in any language’s known word list.\n\nA sentence belongs to a language if and only if there exists a word $S$ in the sentence that comes from that language.", "inputFormat": "The first line contains an integer $N$, the number of different languages.\n\nThen follow $N$ lines. Each line contains the name of a language and several known words from that language, separated by spaces.\n\nThen there is a blank line.\n\nThen several lines (no more than $10^3$ lines), one sentence per line.", "outputFormat": "For each sentence, output a single line with the name of the language it belongs to.", "hint": "For $100\\%$ of the testdata, $1 \\le N \\le 100$, and each input line does not exceed 256 characters.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "语言普查", "background": "“Kiaosmaonsnai Assi fi wais.”\n\n“Kjamqosoaksi mais pas?”\n\n“Oci! Asia olo mnai naso!”\n\n“2333 在说什么啊根本听不懂……”\n\n这是 Yugo 国的日常……\n\nYugo 国的人民在进行一次人口普查，由于 Yugo 国是典型的多民族国家，所以拥有许多种语言。", "description": "Yugo 国有许多不同的种族，总共有 $N$ 种不同的语言，但是主![]()席扔给了你几本字典，这样，你就知道他们在说什么语了。你的任务就是判断他们在说什么语并填上户口本。\n\n具体的，给出 $N$ 种语言的名称以及已知的来自该语言的若干个单词，保证每个单词最多出现在一种语言中。同时你还会得到若干个句子，对于每个句子，你都需要判断它属于哪种语言（单词匹配不区分大小写）。\n\n一个句子是一个仅包含大小写字母、空格、`-`、`'`、`.`、`,`、`?`、`!`、`;`、`(` 和 `)` 的字符串，其中有且仅有 `.`、`,`、`?`、`!`、`;`、`(` 和 `)` 是分隔符。一个句子由若干个单词和分隔符构成。\n\n句子中每个极大的不包含分隔符的子串都是一个单词。即：若一个句子的子串 $S$ 不包含分隔符，且不存在该句子的另一个子串 $T$ 满足 $T$ 不包含分隔符、$S$ 是 $T$ 的子串且 $S\\ne T$，则 $S$ 是该句子中的一个单词。\n\n同时，输入数据中的句子有以下性质：\n\n- 一个句子中不会同时包含来自不同语言的两个单词。\n- 一个句子中包含至少一个来自一种语言的单词。\n- 一个句子中可能出现在任何一个语言的已知词语中都没有出现过的词语。\n\n一个句子属于一种语言当且仅当该句子中存在一个单词 $S$ 来自该语言。", "inputFormat": "第一行一个整数 $N$，表示不同语言的数量。\n\n接下来 $N$ 行，依次是该语言的名称和该语言中的若干个单词，单词之间用空格隔开。\n\n接下来一行为空行。\n\n接下来若干行（不超过 $10^3$ 行），每行一个句子。", "outputFormat": "对于每个句子，输出一行一个字符串，表示该句子属于的语言的名称。", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le 100$，输入数据每行不超过 $256$ 个字符。", "locale": "zh-CN"}}}
{"pid": "P3753", "type": "P", "difficulty": 4, "samples": [["4 4\n1 2 1\n1 3 0\n2 3 1\n3 4 1", "3\n"]], "limits": {"time": [500, 500, 500, 500, 500], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创", "洛谷比赛"], "title": "国事访问", "background": "这是战火纷飞的2333年，世界被分为XC联盟和WJ联盟，两个联盟互相开火。\n", "description": "这是战火纷飞的2333年，世界被分为XC联盟和WJ联盟，两个联盟互相开火。Q国总统ZR想到Yugo国进行十分紧急的国事访问，但不能坐飞机，只能坐车。由于路上有许多不同的国家而且有些无政府国，所以有许多路是坏的。路没有从自己通向自己的（作死吗。。。）。你需要确定一条具体的路线，并且由于WJ联盟的人随时可能过来，你需要把这条路线经过的所有城市周围的其他路都毁掉。你是上帝视角，你需要帮助ZR总统到达Yugo，你可以毁掉一些原本是好的路，也可以把坏的路修好，但不能新修路。给你一份地图，地图上，ZR国坐落在1城，Yugo首都在n城。帮助ZR总统尽快到达Yugo，你可以获得ZR总统在WJ联邦银行的30亿存款和1000万人的军队，和ZR总统一起瓜分地球（以上是诈骗内容。。。）。\n", "inputFormat": "第一行，n，m，（2<=n<=1000,0<=m<=1000），n是Yugo首都，m是公路数量。\n\n第2至m+1行，a，b，c，a是公路起始城市，b是公路结束城市，c是路的情况（1：能通行/0：不能通行）。\n", "outputFormat": "第一行，k，需要改变路状态的最小数量。\n", "hint": "把 1 2 1 路径变成不可用\n\n把 1 3 0 路径变成可用\n\n把 2 3 1 路径变成不可用\n\n即可", "locale": "zh-CN", "translations": {"en": {"title": "State Visit", "background": "It is the war-torn year 2333. The world is divided into the XC alliance and the WJ alliance, and the two alliances are firing at each other.", "description": "It is the war-torn year 2333. The world is divided into the XC alliance and the WJ alliance, and the two alliances are firing at each other. President ZR of country Q wants to make a very urgent state visit to the country of Yugo, but he cannot fly and can only travel by car. Because there are many different countries along the way and some are in anarchy, many roads are broken. There is no road that goes from a city to itself (who would do that...).\n\nYou need to determine a specific route. Since people from the WJ alliance may show up at any time, you must destroy all other roads incident to every city that the route passes through. You have a god’s-eye view and must help President ZR reach Yugo. You may change the state of some roads: you can close roads that are currently open or repair roads that are currently closed, but you cannot build new roads. You are given a map where ZR’s country is at city 1 and Yugo’s capital is at city $n$. Help President ZR reach Yugo as soon as possible. You will receive President ZR’s 3 billion deposit in the WJ Federal Bank and an army of 10 million people, and divide the Earth together with President ZR (the above is a scam...).\n\n# Description", "inputFormat": "- The first line contains two integers $n$, $m$ ($2 \\le n \\le 1000$, $0 \\le m \\le 1000$). City $n$ is the capital of Yugo, and $m$ is the number of roads.\n- The next $m$ lines each contain three integers $a$, $b$, $c$: $a$ is the start city, $b$ is the end city, and $c$ indicates the road’s state (1: passable / 0: impassable).", "outputFormat": "The first line contains an integer $k$, the minimal number of road-state changes required.", "hint": "Make road 1 2 1 impassable.\n\nMake road 1 3 0 passable.\n\nMake road 2 3 1 impassable.\n\nAnd that will do.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "国事访问", "background": "这是战火纷飞的2333年，世界被分为XC联盟和WJ联盟，两个联盟互相开火。\n", "description": "这是战火纷飞的2333年，世界被分为XC联盟和WJ联盟，两个联盟互相开火。Q国总统ZR想到Yugo国进行十分紧急的国事访问，但不能坐飞机，只能坐车。由于路上有许多不同的国家而且有些无政府国，所以有许多路是坏的。路没有从自己通向自己的（作死吗。。。）。你需要确定一条具体的路线，并且由于WJ联盟的人随时可能过来，你需要把这条路线经过的所有城市周围的其他路都毁掉。你是上帝视角，你需要帮助ZR总统到达Yugo，你可以毁掉一些原本是好的路，也可以把坏的路修好，但不能新修路。给你一份地图，地图上，ZR国坐落在1城，Yugo首都在n城。帮助ZR总统尽快到达Yugo，你可以获得ZR总统在WJ联邦银行的30亿存款和1000万人的军队，和ZR总统一起瓜分地球（以上是诈骗内容。。。）。\n", "inputFormat": "第一行，n，m，（2<=n<=1000,0<=m<=1000），n是Yugo首都，m是公路数量。\n\n第2至m+1行，a，b，c，a是公路起始城市，b是公路结束城市，c是路的情况（1：能通行/0：不能通行）。\n", "outputFormat": "第一行，k，需要改变路状态的最小数量。\n", "hint": "把 1 2 1 路径变成不可用\n\n把 1 3 0 路径变成可用\n\n把 2 3 1 路径变成不可用\n\n即可", "locale": "zh-CN"}}}
{"pid": "P3754", "type": "P", "difficulty": 5, "samples": [["100 111", "68"], ["233 233", "14"], ["1 9", "45"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["洛谷原创", "洛谷比赛"], "title": "首都效应", "background": "Yugo 的最大城市就是它的首都，Yugo 国的城市差异十分大：边缘城市几乎没人，但中心城市全是人。", "description": "Jace 是 Alara 的总统，和 Q 国总统一样，因为战乱，他必须乘坐车来 Yugo 首都。随行的记录员 Tezzeret 负责调查 Yugo 的真正实力，他的任务是数清沿途的城市的房子数量。\n\nYugo 的城市已经被编号，他数着数着，发现了一个规律：把城市编号分为几个连续的数字段，对每一数段，该数字乘上这个数段的长度的平方再全部相加，就能得到这个城市的房子数量。例：第 $233$ 城房子数量：$2\\times1^2+3\\times2^2=14$。\n\nTezzeret 被告知他需要计算沿途的房子数总量（从进入 Yugo 的 A 城一直到首都 Y 城的房子总数），然而计算量太大，你能不能用 PC 帮他解决这个计算量巨大的问题？", "inputFormat": "一行两个整数 $A,B(1 \\le A \\le B \\le 10^{15})$，分别表示进入 Yugo 的第一城和首都。", "outputFormat": "一行一个整数，表示房子总量。", "hint": "样例 $1$ 房子总量：$1\\times1^2+1\\times1^2+1\\times1^2+2\\times1^2+1\\times1^2+3\\times1^2+\\ldots+1\\times1^2+9\\times1^2+1\\times2^2+1\\times3^2=68$。", "locale": "zh-CN", "translations": {"en": {"title": "Capital Effect", "background": "Yugo’s largest city is its capital. The disparity among Yugo’s cities is huge: the peripheral cities are almost empty, while the central cities are packed with people.", "description": "Jace is the president of Alara. Like the president of country Q, due to war, he must travel by car to Yugo’s capital. The accompanying recorder Tezzeret is responsible for assessing Yugo’s true strength. His task is to count the number of houses in the cities along the way.\n\nThe cities of Yugo are already numbered. While counting, he discovered a rule: split the city number into several consecutive “digit runs” (each run consists of the same digit). For each run, multiply that digit by the square of the run’s length, then sum all these values to obtain the number of houses in that city. Example: for city $233$, the number of houses is $2\\times1^2+3\\times2^2=14$.\n\nTezzeret was told to compute the total number of houses along the route (from city $A$, where they enter Yugo, up to the capital city $B$), but the computation is too heavy. Can you use a PC to help him solve this large-scale calculation?", "inputFormat": "One line with two integers $A, B(1 \\le A \\le B \\le 10^{15})$, representing the first city upon entering Yugo and the capital city, respectively.", "outputFormat": "One line with one integer, the total number of houses.", "hint": "In Sample $1$, the total number of houses is: $1\\times1^2+1\\times1^2+1\\times1^2+2\\times1^2+1\\times1^2+3\\times1^2+\\ldots+1\\times1^2+9\\times1^2+1\\times2^2+1\\times3^2=68$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "首都效应", "background": "Yugo 的最大城市就是它的首都，Yugo 国的城市差异十分大：边缘城市几乎没人，但中心城市全是人。", "description": "Jace 是 Alara 的总统，和 Q 国总统一样，因为战乱，他必须乘坐车来 Yugo 首都。随行的记录员 Tezzeret 负责调查 Yugo 的真正实力，他的任务是数清沿途的城市的房子数量。\n\nYugo 的城市已经被编号，他数着数着，发现了一个规律：把城市编号分为几个连续的数字段，对每一数段，该数字乘上这个数段的长度的平方再全部相加，就能得到这个城市的房子数量。例：第 $233$ 城房子数量：$2\\times1^2+3\\times2^2=14$。\n\nTezzeret 被告知他需要计算沿途的房子数总量（从进入 Yugo 的 A 城一直到首都 Y 城的房子总数），然而计算量太大，你能不能用 PC 帮他解决这个计算量巨大的问题？", "inputFormat": "一行两个整数 $A,B(1 \\le A \\le B \\le 10^{15})$，分别表示进入 Yugo 的第一城和首都。", "outputFormat": "一行一个整数，表示房子总量。", "hint": "样例 $1$ 房子总量：$1\\times1^2+1\\times1^2+1\\times1^2+2\\times1^2+1\\times1^2+3\\times1^2+\\ldots+1\\times1^2+9\\times1^2+1\\times2^2+1\\times3^2=68$。", "locale": "zh-CN"}}}
{"pid": "P3755", "type": "P", "difficulty": 4, "samples": [["4 2   \n0 0 1 \n0 1 2  \n2 2 4  \n1 0 8  \n0 0 1 1 \n1 1 5 6 ", "11\n4"], ["3 2\n-100 0 16 \n1 -10 32 \n1000 100 64 \n0 0 0 1 \n-1000 -1000 10000 10000 ", "0\n112"]], "limits": {"time": [3000, 1000, 1000, 1000, 1000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "重庆", "线段树", "各省省选", "树状数组", "离散化", "cdq 分治", "树套树", "可持久化线段树"], "title": "[CQOI2017] 老C的任务", "background": "", "description": "老 C 是个程序员。\n\n\n最近老 C 从老板那里接到了一个任务——给城市中的手机基站写个管理系统。作为经验丰富的程序员，老 C 轻松地完成了系统的大部分功能，并把其中一个功能交给你来实现。\n\n由于一个基站的面积相对于整个城市面积来说非常的小，因此每个的基站都可以看作坐标系中的一个点，其位置可以用坐标 $(x,y)$ 来表示。此外，每个基站还有很多属性，例如高度、功率等。运营商经常会划定一个区域，并查询区域中所有基站的信息。\n\n现在你需要实现的功能就是，对于一个给定的矩形区域，回答该区域中（包括区域边界上的）所有基站的功率总和。如果区域中没有任何基站，则回答 $0$。\n", "inputFormat": "第一行两个整数 $n,m$，表示一共有 $n$ 个基站和 $m$ 次查询。接下来一共有 $n$ 行，每行由 $x_i,y_i,p_i$ 三个空格隔开的整数构成，表示一个基站的坐标 $(x_i,y_i)$ 和功率 $p_i$。不会有两个基站位于同一坐标。\n\n接下来一共有 $m$ 行，每行由 $x_1,y_1,x_2,y_2$ 四个空格隔开的整数构成，表示一次查询的矩形区域。该矩形对角坐标为 $(x_1,y_1)$ 和 $(x_2,y_2)$，且边与坐标轴平行。\n", "outputFormat": "输出 $m$ 行，每行一个整数，对应每次查询的结果。\n", "hint": "对于第 $1\\sim2$ 个测试点，$1≤n,m≤100$；\n\n对于第 $3\\sim5$ 个测试点，$1≤n≤50000,1≤m≤10000$；\n\n对于第 $6\\sim10$ 个测试点，$1≤n≤100000,1≤m≤100000$，数据有梯度；\n\n对于所有测试点，$-2^{31}\\le x_i,y_i,p_i,x_1,y_1,x_2,y_2<2^{31},x_1\\le x_2,y_1\\le y_2$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2017] Old C's Task", "background": "", "description": "Old C is a programmer.\n\nRecently, Old C received a task from his boss — to write a management system for mobile base stations in the city. As an experienced programmer, Old C easily completed most of the system and left one feature for you to implement.\n\nSince the area covered by one base station is very small compared to the whole city, each base station can be regarded as a point in the coordinate plane, with its position represented by coordinates $(x,y)$. In addition, each base station has many attributes, such as height and power. The operator often specifies a region and queries the information of all base stations in that region.\n\nYour task is: for a given rectangular region, answer the sum of the power values of all base stations inside the region (including those on the boundary). If the region contains no base stations, output $0$.", "inputFormat": "The first line contains two integers $n,m$, meaning there are $n$ base stations and $m$ queries. The next $n$ lines each contain three space-separated integers $x_i,y_i,p_i$, representing a base station at coordinates $(x_i,y_i)$ with power $p_i$. No two base stations share the same coordinates.\n\nThen follow $m$ lines, each containing four space-separated integers $x_1,y_1,x_2,y_2$, denoting one query rectangle. The rectangle has diagonally opposite corners at $(x_1,y_1)$ and $(x_2,y_2)$, and its sides are parallel to the coordinate axes.", "outputFormat": "Output $m$ lines, each containing one integer, the answer for the corresponding query.", "hint": "For testdata $1 \\sim 2$, $1 \\le n,m \\le 100$.\n\nFor testdata $3 \\sim 5$, $1 \\le n \\le 50000$, $1 \\le m \\le 10000$.\n\nFor testdata $6 \\sim 10$, $1 \\le n \\le 100000$, $1 \\le m \\le 100000$, and the testdata has a gradient.\n\nFor all testdata, $-2^{31} \\le x_i,y_i,p_i,x_1,y_1,x_2,y_2 < 2^{31}$, $x_1 \\le x_2$, $y_1 \\le y_2$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2017] 老C的任务", "background": "", "description": "老 C 是个程序员。\n\n\n最近老 C 从老板那里接到了一个任务——给城市中的手机基站写个管理系统。作为经验丰富的程序员，老 C 轻松地完成了系统的大部分功能，并把其中一个功能交给你来实现。\n\n由于一个基站的面积相对于整个城市面积来说非常的小，因此每个的基站都可以看作坐标系中的一个点，其位置可以用坐标 $(x,y)$ 来表示。此外，每个基站还有很多属性，例如高度、功率等。运营商经常会划定一个区域，并查询区域中所有基站的信息。\n\n现在你需要实现的功能就是，对于一个给定的矩形区域，回答该区域中（包括区域边界上的）所有基站的功率总和。如果区域中没有任何基站，则回答 $0$。\n", "inputFormat": "第一行两个整数 $n,m$，表示一共有 $n$ 个基站和 $m$ 次查询。接下来一共有 $n$ 行，每行由 $x_i,y_i,p_i$ 三个空格隔开的整数构成，表示一个基站的坐标 $(x_i,y_i)$ 和功率 $p_i$。不会有两个基站位于同一坐标。\n\n接下来一共有 $m$ 行，每行由 $x_1,y_1,x_2,y_2$ 四个空格隔开的整数构成，表示一次查询的矩形区域。该矩形对角坐标为 $(x_1,y_1)$ 和 $(x_2,y_2)$，且边与坐标轴平行。\n", "outputFormat": "输出 $m$ 行，每行一个整数，对应每次查询的结果。\n", "hint": "对于第 $1\\sim2$ 个测试点，$1≤n,m≤100$；\n\n对于第 $3\\sim5$ 个测试点，$1≤n≤50000,1≤m≤10000$；\n\n对于第 $6\\sim10$ 个测试点，$1≤n≤100000,1≤m≤100000$，数据有梯度；\n\n对于所有测试点，$-2^{31}\\le x_i,y_i,p_i,x_1,y_1,x_2,y_2<2^{31},x_1\\le x_2,y_1\\le y_2$。\n", "locale": "zh-CN"}}}
{"pid": "P3756", "type": "P", "difficulty": 7, "samples": [["2 2 4\n1 1 5 \n1 2 6 \n2 1 7 \n2 2 8 ", "5"], ["3 3 7 \n1 1 10 \n1 2 15 \n1 3 10 \n2 1 10 \n2 2 10 \n2 3 10 \n3 1 10 ", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "重庆", "各省省选", "网络流", "图论建模", "最小割"], "title": "[CQOI2017] 老C的方块", "background": "", "description": "老 C 是个程序员。\n\n作为一个懒惰的程序员，老 C 经常在电脑上玩方块游戏消磨时间。游戏被限定在一个由小方格排成的 $R$ 行 $C$ 列网格上，如果两个小方格有公共的边，就称它们是相邻的，而且有些相邻的小方格之间的公共边比较特殊。特殊的公共边排列得有很强的规律。首先规定，第 $1$ 行的前两个小方格之间的边是特殊边。然后，特殊边在水平方向上每 $4$ 个小方格为一个周期，在竖直方向上每 $2$ 个小方格为一个周期。所有的奇数列与下一列之间都有特殊边，且所在行的编号从左到右奇偶交替。\n\n下图所示是一个 $R=C=8$ 的网格，蓝色标注的边是特殊边。首先，在第 $1$ 行，第 $1$ 列和第 $2$ 列之间有一条特殊边。因为竖直方向周期为 $2$，所以所有的奇数行，第 $1$ 列和第 $2$ 列之间都有特殊边。因为水平方向周期为 $4$，所以所有奇数行的第 $5$ 列和第 $6$ 列之间也有特殊边，如果网格足够大，所有奇数行的第 $9$ 列和第 $10$ 列、第 $13$ 列和第 $14$ 列之间都有特殊边。因为所有的奇数列和下一列之间都有特殊边，所以第 $3$ 列和第 $4$ 列、第 $7$ 列和第 $8$ 列之间也有特殊边，而所在行的编号从左到右奇偶交替，所以它们的特殊边在偶数行。如果网格的规模更大，我们可以用同样的方法找出所有的特殊边。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5092.png) \n\n网格的每个小方格刚好可以放入一个小方块，在游戏的一开始，有些小方格已经放上了小方块，另外的小方格没有放。老 C 很讨厌下图所示的图形，如果他发现有一些小方块排列成了它讨厌的形状（特殊边的位置也要如图中所示），就很容易弃疗，即使是经过任意次旋转、翻转后排列成讨厌的形状，老 C 也同样容易弃疗。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5093.png) \n\n为了防止弃疗，老 C 决定趁自己还没有弃疗，赶紧移除一些格子里小方块，使得剩下的小方块不能构成它讨厌的形状。但是游戏里每移除一个方块都是要花费一些金币的，每个方块需要花费的金币有多有少参差不齐。老 C 当然希望尽可能少的使用游戏里的金币，但是最少要花费多少金币呢？老 C 懒得思考，就把这个问题交给你了。\n", "inputFormat": "第一行有 $3$ 个正整数 $C,R,n$，表示 $C$ 列 $R$ 行的网格中，有 $n$ 个小方格放了小方块。\n\n接下来 $n$ 行，每行 $3$ 个正整数 $x,y,w$，表示在第 $x$ 列第 $y$ 行的小方格里放了小方块，移除它需要花费 $w$ 个金币。保证不会重复，且都在网格范围内。\n", "outputFormat": "输出一行，包含一个整数，表示最少花费的金币数量。\n", "hint": "【输入输出样例 2 说明】 如图所示。容易发现，如果不移除第 $1$ 列第 $2$ 行的小方块，则至少要移除两个小方块，才能不包含老 C 讨厌的图形，花费至少 $20$ 个金币；而删除第 $1$ 列第 $2$ 行的小方块后，原有的讨厌图形全都不存在了，只需要花费 $15$ 个金币。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/5094.png) \n\n【数据规模与约定】\n\n对于第 $1\\sim 2$ 个测试点，$1\\le C, R \\le 100$，$1\\leq n \\leq 20$。\n\n对于第 $3\\sim 6$ 个测试点，$1 \\leq C, R\\leq 10^5$，$2000\\le n\\leq 5000$，数据有梯度。\n\n对于第 $7\\sim 10$ 个测试点，$1\\leq C, R\\leq 10^5$，$30000 \\leq n\\leq 10^5$，数据有梯度。\n\n对于所有测试点，$1 \\leq C, R, n \\leq 10^5$，$ 1 \\leq w \\leq 10^4$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2017] Old C's Blocks", "background": "", "description": "Old C (Lao C) is a programmer.\n\nAs a lazy programmer, Old C often plays a block game on his computer to kill time. The game is played on a grid with $R$ rows and $C$ columns of unit cells. Two cells are called adjacent if they share a side, and among adjacent pairs, some shared edges are marked as special. These special edges follow a very regular pattern. First, in row $1$, the edge between the first two cells is a special edge. Then, the special edges have period $4$ in the horizontal direction and period $2$ in the vertical direction. Between every odd-numbered column and the next column there are special edges, and the parity of the rows carrying these edges alternates from left to right.\n\nThe figure below shows a grid with $R = C = 8$, where the special edges are marked in blue. First, in row $1$, the edge between column $1$ and column $2$ is special. Because the vertical period is $2$, the edge between column $1$ and column $2$ is special in all odd-numbered rows. Because the horizontal period is $4$, the edge between column $5$ and column $6$ is also special in all odd-numbered rows; if the grid is large enough, so are the edges between columns $9$ and $10$, $13$ and $14$, etc. Because every odd-numbered column and the next column have special edges, the edges between columns $3$ and $4$, and between $7$ and $8$, are also special; since the row parity alternates from left to right, these special edges lie in even-numbered rows. If the grid is larger, we can find all special edges in the same way.\n\n ![](https://cdn.luogu.com.cn/upload/pic/5092.png) \n\nEach cell can hold exactly one block. At the beginning of the game, some cells already contain blocks, while others are empty. Old C hates the pattern shown below. If he finds some blocks arranged in that hated shape (the positions of the special edges must also match those in the figure), he will immediately rage quit. Even if the hated shape appears after any number of rotations or reflections, he will still rage quit.\n\n ![](https://cdn.luogu.com.cn/upload/pic/5093.png) \n\nTo avoid rage quitting, Old C decides to remove some blocks while he still can, so that the remaining blocks cannot form the hated shape. However, removing a block costs some coins, and the cost may differ from block to block. Of course, Old C wants to spend as few coins as possible. What is the minimum total number of coins needed? Old C is too lazy to think about it and leaves the problem to you.", "inputFormat": "The first line contains three positive integers $C, R, n$, meaning that in a grid with $C$ columns and $R$ rows, there are $n$ cells that contain blocks.\n\nEach of the next $n$ lines contains three positive integers $x, y, w$, meaning that the cell at column $x$, row $y$ contains a block, and removing it costs $w$ coins. All entries are distinct and within the grid.", "outputFormat": "Output one line containing a single integer, the minimum total number of coins required.", "hint": "[Explanation for Sample 2] As shown in the figure. It is easy to see that if we do not remove the block at column 1, row 2, then we must remove at least two blocks to avoid containing the hated shape, costing at least 20 coins; whereas after deleting the block at column 1, row 2, all existing hated shapes disappear, and we only need to spend 15 coins.\n\n ![](https://cdn.luogu.com.cn/upload/pic/5094.png) \n\nConstraints\n\nFor test points $1 \\sim 2$, $1 \\leq C, R \\leq 100$, $1 \\leq n \\leq 20$.\n\nFor test points $3 \\sim 6$, $1 \\leq C, R \\leq 10^5$, $2000 \\leq n \\leq 5000$, with graded testdata.\n\nFor test points $7 \\sim 10$, $1 \\leq C, R \\leq 10^5$, $30000 \\leq n \\leq 10^5$, with graded testdata.\n\nFor all test points, $1 \\leq C, R, n \\leq 10^5$, $1 \\leq w \\leq 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2017] 老C的方块", "background": "", "description": "老 C 是个程序员。\n\n作为一个懒惰的程序员，老 C 经常在电脑上玩方块游戏消磨时间。游戏被限定在一个由小方格排成的 $R$ 行 $C$ 列网格上，如果两个小方格有公共的边，就称它们是相邻的，而且有些相邻的小方格之间的公共边比较特殊。特殊的公共边排列得有很强的规律。首先规定，第 $1$ 行的前两个小方格之间的边是特殊边。然后，特殊边在水平方向上每 $4$ 个小方格为一个周期，在竖直方向上每 $2$ 个小方格为一个周期。所有的奇数列与下一列之间都有特殊边，且所在行的编号从左到右奇偶交替。\n\n下图所示是一个 $R=C=8$ 的网格，蓝色标注的边是特殊边。首先，在第 $1$ 行，第 $1$ 列和第 $2$ 列之间有一条特殊边。因为竖直方向周期为 $2$，所以所有的奇数行，第 $1$ 列和第 $2$ 列之间都有特殊边。因为水平方向周期为 $4$，所以所有奇数行的第 $5$ 列和第 $6$ 列之间也有特殊边，如果网格足够大，所有奇数行的第 $9$ 列和第 $10$ 列、第 $13$ 列和第 $14$ 列之间都有特殊边。因为所有的奇数列和下一列之间都有特殊边，所以第 $3$ 列和第 $4$ 列、第 $7$ 列和第 $8$ 列之间也有特殊边，而所在行的编号从左到右奇偶交替，所以它们的特殊边在偶数行。如果网格的规模更大，我们可以用同样的方法找出所有的特殊边。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5092.png) \n\n网格的每个小方格刚好可以放入一个小方块，在游戏的一开始，有些小方格已经放上了小方块，另外的小方格没有放。老 C 很讨厌下图所示的图形，如果他发现有一些小方块排列成了它讨厌的形状（特殊边的位置也要如图中所示），就很容易弃疗，即使是经过任意次旋转、翻转后排列成讨厌的形状，老 C 也同样容易弃疗。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5093.png) \n\n为了防止弃疗，老 C 决定趁自己还没有弃疗，赶紧移除一些格子里小方块，使得剩下的小方块不能构成它讨厌的形状。但是游戏里每移除一个方块都是要花费一些金币的，每个方块需要花费的金币有多有少参差不齐。老 C 当然希望尽可能少的使用游戏里的金币，但是最少要花费多少金币呢？老 C 懒得思考，就把这个问题交给你了。\n", "inputFormat": "第一行有 $3$ 个正整数 $C,R,n$，表示 $C$ 列 $R$ 行的网格中，有 $n$ 个小方格放了小方块。\n\n接下来 $n$ 行，每行 $3$ 个正整数 $x,y,w$，表示在第 $x$ 列第 $y$ 行的小方格里放了小方块，移除它需要花费 $w$ 个金币。保证不会重复，且都在网格范围内。\n", "outputFormat": "输出一行，包含一个整数，表示最少花费的金币数量。\n", "hint": "【输入输出样例 2 说明】 如图所示。容易发现，如果不移除第 $1$ 列第 $2$ 行的小方块，则至少要移除两个小方块，才能不包含老 C 讨厌的图形，花费至少 $20$ 个金币；而删除第 $1$ 列第 $2$ 行的小方块后，原有的讨厌图形全都不存在了，只需要花费 $15$ 个金币。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/5094.png) \n\n【数据规模与约定】\n\n对于第 $1\\sim 2$ 个测试点，$1\\le C, R \\le 100$，$1\\leq n \\leq 20$。\n\n对于第 $3\\sim 6$ 个测试点，$1 \\leq C, R\\leq 10^5$，$2000\\le n\\leq 5000$，数据有梯度。\n\n对于第 $7\\sim 10$ 个测试点，$1\\leq C, R\\leq 10^5$，$30000 \\leq n\\leq 10^5$，数据有梯度。\n\n对于所有测试点，$1 \\leq C, R, n \\leq 10^5$，$ 1 \\leq w \\leq 10^4$。\n", "locale": "zh-CN"}}}
{"pid": "P3757", "type": "P", "difficulty": 6, "samples": [["5 <>><", "3"], ["5 <<<<", "8"], ["5 <<>>", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2017", "重庆", "线段树", "各省省选", "树形 DP", "前缀和"], "title": "[CQOI2017] 老C的键盘", "background": "", "description": "老 C 是个程序员。\n\n作为一个优秀的程序员，老 C 拥有一个别具一格的键盘，据说这样可以大幅提升写程序的速度，还能让写出来的程序在某种神奇力量的驱使之下跑得非常快。\n\n小 Q 也是一个程序员。有一天他悄悄潜入了老 C 的家中，想要看看这个键盘究竟有何妙处。他发现，这个键盘共有 $n$ 个按键，这 $n$ 个按键虽然整齐的排成一列，但是每个键的高度却互不相同。聪明的小 Q 马上将每个键的高度用 $1 \\sim n$ 的整数表示了出来，得到一个 $1 \\sim n$ 的排列 $h_1,h_2, \\cdots ,h_n$。\n\n为了回去之后可以仿造一个新键盘（新键盘每个键的高度也是一个 $1 \\sim n$ 的排列），又不要和老 C 的键盘完全一样，小 Q 决定记录下若干对按键的高度关系。作为一个程序员，小 Q 当然不会随便选几对就记下来，而是选了非常有规律的一些按键对：对于 $i=2,3, \\cdots ,n$，小 Q 都记录下了一个字符 `<` 或者 `>`，表示 $h_{\\frac i2}<h_i$ 或者$h_{\\frac i2}>h_i$。于是，小 Q 得到了一个长度为 $n-1$ 的字符串，开开心心的回家了。\n\n现在，小 Q 想知道满足他所记录的高度关系的键盘有多少个。虽然小 Q 不希望自己的键盘和老 C 的完全相同，但是完全相同也算一个满足要求的键盘。答案可能很大，你只需要告诉小 Q 答案 $\\bmod ~ 1,000,000,007$ 之后的结果即可。\n", "inputFormat": "输入共一行，包含一个正整数 $n$ 和一个长度为 $n - 1$ 的只包含 `<` 和 `>` 的字符串，分别表示键盘上按键的数量，和小 Q 记录的信息，整数和字符串之间有一个空格间隔。\n", "outputFormat": "输出共一行，包含一个整数，表示答案 $\\bmod      ~ 1,000,000,007$ 后的结果。\n", "hint": "\n\n![](https://cdn.luogu.com.cn/upload/pic/5095.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2017] Lao C's Keyboard", "background": "", "description": "Lao C is a programmer.\n\nAs an excellent programmer, Lao C owns a distinctive keyboard, which is said to greatly increase the speed of writing programs and, driven by some mysterious power, make the programs run very fast.\n\nLittle Q is also a programmer. One day he sneaked into Lao C's home to see what was so special about the keyboard. He found that the keyboard has $n$ keys. Although these $n$ keys are neatly arranged in a single row, the height of each key is different. The clever Little Q immediately represented the height of each key with the integers $1 \\sim n$, obtaining a permutation $h_1, h_2, \\cdots , h_n$ of $1 \\sim n$.\n\nIn order to later build an imitation keyboard (the heights of its keys also form a permutation of $1 \\sim n$), and also to avoid being exactly the same as Lao C's keyboard, Little Q decided to record several pairs of height relations between keys. As a programmer, Little Q of course did not just pick a few pairs at random, but chose them in a very regular way: for $i=2,3, \\cdots ,n$, Little Q recorded a character '<' or '>', indicating $h_{\\frac i2}<h_i$ or $h_{\\frac i2}>h_i$. Thus, Little Q obtained a string of length $n-1$ and happily went home.\n\nNow Little Q wants to know how many keyboards satisfy the height relations he recorded. Although Little Q does not want his keyboard to be completely identical to Lao C's, the completely identical one also counts as satisfying the requirement. The answer may be large; you only need to tell Little Q the result modulo $1,000,000,007$.", "inputFormat": "The input consists of a single line containing a positive integer $n$ and a string of length $n - 1$ consisting only of '<' and '>', representing the number of keys on the keyboard and the information recorded by Little Q, separated by a space.", "outputFormat": "Output a single line containing an integer, the answer modulo $1,000,000,007$.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/5095.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2017] 老C的键盘", "background": "", "description": "老 C 是个程序员。\n\n作为一个优秀的程序员，老 C 拥有一个别具一格的键盘，据说这样可以大幅提升写程序的速度，还能让写出来的程序在某种神奇力量的驱使之下跑得非常快。\n\n小 Q 也是一个程序员。有一天他悄悄潜入了老 C 的家中，想要看看这个键盘究竟有何妙处。他发现，这个键盘共有 $n$ 个按键，这 $n$ 个按键虽然整齐的排成一列，但是每个键的高度却互不相同。聪明的小 Q 马上将每个键的高度用 $1 \\sim n$ 的整数表示了出来，得到一个 $1 \\sim n$ 的排列 $h_1,h_2, \\cdots ,h_n$。\n\n为了回去之后可以仿造一个新键盘（新键盘每个键的高度也是一个 $1 \\sim n$ 的排列），又不要和老 C 的键盘完全一样，小 Q 决定记录下若干对按键的高度关系。作为一个程序员，小 Q 当然不会随便选几对就记下来，而是选了非常有规律的一些按键对：对于 $i=2,3, \\cdots ,n$，小 Q 都记录下了一个字符 `<` 或者 `>`，表示 $h_{\\frac i2}<h_i$ 或者$h_{\\frac i2}>h_i$。于是，小 Q 得到了一个长度为 $n-1$ 的字符串，开开心心的回家了。\n\n现在，小 Q 想知道满足他所记录的高度关系的键盘有多少个。虽然小 Q 不希望自己的键盘和老 C 的完全相同，但是完全相同也算一个满足要求的键盘。答案可能很大，你只需要告诉小 Q 答案 $\\bmod ~ 1,000,000,007$ 之后的结果即可。\n", "inputFormat": "输入共一行，包含一个正整数 $n$ 和一个长度为 $n - 1$ 的只包含 `<` 和 `>` 的字符串，分别表示键盘上按键的数量，和小 Q 记录的信息，整数和字符串之间有一个空格间隔。\n", "outputFormat": "输出共一行，包含一个整数，表示答案 $\\bmod      ~ 1,000,000,007$ 后的结果。\n", "hint": "\n\n![](https://cdn.luogu.com.cn/upload/pic/5095.png)\n", "locale": "zh-CN"}}}
{"pid": "P3758", "type": "P", "difficulty": 4, "samples": [["3 2\n1 2\n2 3\n2", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2017", "倍增", "各省省选", "矩阵加速", "天津"], "title": "[TJOI2017] 可乐", "background": "", "description": "加里敦星球的人们特别喜欢喝可乐。因而，他们的敌对星球研发出了一个可乐机器人，并且放在了加里敦星球的 $1$ 号城市上。这个可乐机器人有三种行为： 停在原地，去下一个相邻的城市，自爆。它每一秒都会随机触发一种行为。现在给加里敦星球城市图，在第 $0$ 秒时可乐机器人在 $1$ 号城市，问经过了 $t$ 秒，可乐机器人的行为方案数是多少？\n", "inputFormat": "第一行输入两个正整数 $N$，$M$。$N$ 表示城市个数，$M$ 表示道路个数。\n\n接下来 $M$ 行每行两个整数 $u$，$v$，表示 $u$，$v$ 之间有一条道路。保证两座城市之间只有一条路相连，且没有任何一条道路连接两个相同的城市。\n\n最后一行是一个整数 $t$，表示经过的时间。", "outputFormat": "输出可乐机器人的行为方案数，答案可能很大，请输出对 $2017$ 取模后的结果。", "hint": "#### 样例输入输出 1 解释\n\n\n- $1$ ->爆炸。\n- $1$ -> $1$ ->爆炸。\n- $1$ -> $2$ ->爆炸。\n- $1$ -> $1$ -> $1$。\n- $1$ -> $1$ -> $2$。\n- $1$ -> $2$ -> $1$。\n- $1$ -> $2$ -> $2$。\n- $1$ -> $2$ -> $3$。\n\n---\n\n#### 数据范围与约定\n\n- 对于 $20\\%$ 的数据，保证 $t \\leq 1000$。\n- 对于$100\\%$的数据，保证 $1 < t \\leq 10^6$，$1 \\leq N \\leq30$，$0 < M < 100$，$1 \\leq u, v \\leq N$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2017] Cola", "background": "", "description": "The people on the planet Jialidun (pinyin) love drinking cola. Therefore, their enemy planet developed a cola robot and placed it in city $1$ of planet Jialidun. This cola robot has three possible actions: stay where it is, go to an adjacent city, or self-destruct. Every second, it randomly triggers one of these actions. Given the city graph of planet Jialidun, and that at time $0$ the cola robot is in city $1$, after $t$ seconds, how many behavior sequences could the cola robot have?", "inputFormat": "The first line contains two positive integers $N$, $M$. $N$ is the number of cities, and $M$ is the number of roads.\nThen $M$ lines follow, each containing two integers $u$, $v$, indicating there is a road between $u$ and $v$. There is at most one road between any pair of cities, and no road connects a city to itself.\nThe last line contains an integer $t$, the elapsed time.", "outputFormat": "Output the number of behavior sequences of the cola robot. Since the answer can be large, output the result modulo $2017$.", "hint": "#### Sample Input/Output 1 Explanation\n\n- $1$ -> self-destructs.\n- $1$ -> $1$ -> self-destructs.\n- $1$ -> $2$ -> self-destructs.\n- $1$ -> $1$ -> $1$.\n- $1$ -> $1$ -> $2$.\n- $1$ -> $2$ -> $1$.\n- $1$ -> $2$ -> $2$.\n- $1$ -> $2$ -> $3$.\n\n---\n\n#### Constraints\n\n- For $20\\%$ of the testdata, $t \\leq 1000$.\n- For $100\\%$ of the testdata, $1 < t \\leq 10^6$, $1 \\leq N \\leq 30$, $0 < M < 100$, $1 \\leq u, v \\leq N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2017] 可乐", "background": "", "description": "加里敦星球的人们特别喜欢喝可乐。因而，他们的敌对星球研发出了一个可乐机器人，并且放在了加里敦星球的 $1$ 号城市上。这个可乐机器人有三种行为： 停在原地，去下一个相邻的城市，自爆。它每一秒都会随机触发一种行为。现在给加里敦星球城市图，在第 $0$ 秒时可乐机器人在 $1$ 号城市，问经过了 $t$ 秒，可乐机器人的行为方案数是多少？\n", "inputFormat": "第一行输入两个正整数 $N$，$M$。$N$ 表示城市个数，$M$ 表示道路个数。\n\n接下来 $M$ 行每行两个整数 $u$，$v$，表示 $u$，$v$ 之间有一条道路。保证两座城市之间只有一条路相连，且没有任何一条道路连接两个相同的城市。\n\n最后一行是一个整数 $t$，表示经过的时间。", "outputFormat": "输出可乐机器人的行为方案数，答案可能很大，请输出对 $2017$ 取模后的结果。", "hint": "#### 样例输入输出 1 解释\n\n\n- $1$ ->爆炸。\n- $1$ -> $1$ ->爆炸。\n- $1$ -> $2$ ->爆炸。\n- $1$ -> $1$ -> $1$。\n- $1$ -> $1$ -> $2$。\n- $1$ -> $2$ -> $1$。\n- $1$ -> $2$ -> $2$。\n- $1$ -> $2$ -> $3$。\n\n---\n\n#### 数据范围与约定\n\n- 对于 $20\\%$ 的数据，保证 $t \\leq 1000$。\n- 对于$100\\%$的数据，保证 $1 < t \\leq 10^6$，$1 \\leq N \\leq30$，$0 < M < 100$，$1 \\leq u, v \\leq N$。", "locale": "zh-CN"}}}
{"pid": "P3759", "type": "P", "difficulty": 6, "samples": [["5 5\n1 1\n2 2\n3 3\n4 4\n5 5\n1 5\n1 5\n2 4\n5 3\n1 3", "42\n0\n18\n28\n48"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "线段树", "各省省选", "cdq 分治", "枚举", "树套树", "天津"], "title": "[TJOI2017] 不勤劳的图书管理员", "background": "", "description": "加里敦大学有个帝国图书馆，小豆是图书馆阅览室的一个书籍管理员。\n\n他的任务是把书排成有序的，所以无序的书让他产生厌烦。\n\n两本乱序的书会让小豆产生这两本书页数的和的厌烦度。\n\n现在有 $n$ 本被打乱顺序的书，在接下来 $m$ 天中每天都会因为读者的阅览导致书籍顺序改变位置。\n\n因为小豆被要求在接下来的 $m$ 天中至少要整理一次图书。\n\n小豆想知道，如果他前 $i$ 天不去整理，第 $i$ 天他的厌烦度是多少，这样他好选择厌烦度最小的那天去整理。", "inputFormat": "第一行会有两个数，$n,m$ 分别表示有 $n$ 本书，$m$ 天。\n\n接下来 $n$ 行，每行两个数，$a_i,v_i$，分别表示第 $i$ 本书本来应该放在 $a_i$ 的位置，这本书有 $v_i$ 页，保证不会有放置同一个位置的书。\n\n接下来 $m$ 行，每行两个数，$x_j$ 和 $y_j$，表示在第 $j$ 天的第 $x_j$ 本书会和第 $y_j$ 本书会因为读者阅读交换位置。", "outputFormat": "一共 $m$ 行，每行一个数，第 $i$ 行表示前 $i$ 天不去整理，第 $i$ 天小豆的厌烦度，因为这个数可能很大，所以将结果模 $10^9 +7$ 后输出。", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，$1\\le a_i,x_j,y_j\\le n \\le 5\\times 10^3$，$1\\le m\\le 5\\times 10^3$， $1\\le v_i\\le10^5$。\n- 对于 $100\\%$ 的数据，$1\\le a_i,x_j,y_j\\le n\\le 5\\times 10^4$，$1\\le m\\le 5\\times 10^4$，$1\\le v_i\\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2017] The Lazy Librarian", "background": "", "description": "At Jialidun University, there is an Imperial Library. Xiao Dou is a librarian in the library’s reading room.\nHis job is to keep the books in order, so disorder annoys him.\nA pair of books that are out of order causes an annoyance equal to the sum of their page counts.\nThere are $n$ books currently in a jumbled order. During the next $m$ days, readers’ use will cause the books’ positions to change each day.\nXiao Dou is required to tidy the books at least once during these $m$ days.\nHe wants to know, if he does not tidy during the first $i$ days, what his annoyance will be on day $i$, so that he can choose the day with the minimum annoyance to tidy.", "inputFormat": "The first line contains two integers $n,m$, denoting $n$ books and $m$ days.\nThe next $n$ lines each contain two integers $a_i,v_i$, meaning that book $i$ should be placed at position $a_i$, and this book has $v_i$ pages. It is guaranteed that no two books have the same intended position.\nThe next $m$ lines each contain two integers $x_j$ and $y_j$, meaning that on day $j$, book $x_j$ and book $y_j$ swap positions due to readers’ usage.", "outputFormat": "Output $m$ lines. The $i$-th line is the annoyance on day $i$ if he does not tidy during the first $i$ days. Since this number can be large, output the result modulo $10^9 +7$.", "hint": "#### Constraints\n\n- For $20\\%$ of the testdata, $1\\le a_i,x_j,y_j\\le n \\le 5\\times 10^3$, $1\\le m\\le 5\\times 10^3$, $1\\le v_i\\le10^5$.\n- For $100\\%$ of the testdata, $1\\le a_i,x_j,y_j\\le n\\le 5\\times 10^4$, $1\\le m\\le 5\\times 10^4$, $1\\le v_i\\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2017] 不勤劳的图书管理员", "background": "", "description": "加里敦大学有个帝国图书馆，小豆是图书馆阅览室的一个书籍管理员。\n\n他的任务是把书排成有序的，所以无序的书让他产生厌烦。\n\n两本乱序的书会让小豆产生这两本书页数的和的厌烦度。\n\n现在有 $n$ 本被打乱顺序的书，在接下来 $m$ 天中每天都会因为读者的阅览导致书籍顺序改变位置。\n\n因为小豆被要求在接下来的 $m$ 天中至少要整理一次图书。\n\n小豆想知道，如果他前 $i$ 天不去整理，第 $i$ 天他的厌烦度是多少，这样他好选择厌烦度最小的那天去整理。", "inputFormat": "第一行会有两个数，$n,m$ 分别表示有 $n$ 本书，$m$ 天。\n\n接下来 $n$ 行，每行两个数，$a_i,v_i$，分别表示第 $i$ 本书本来应该放在 $a_i$ 的位置，这本书有 $v_i$ 页，保证不会有放置同一个位置的书。\n\n接下来 $m$ 行，每行两个数，$x_j$ 和 $y_j$，表示在第 $j$ 天的第 $x_j$ 本书会和第 $y_j$ 本书会因为读者阅读交换位置。", "outputFormat": "一共 $m$ 行，每行一个数，第 $i$ 行表示前 $i$ 天不去整理，第 $i$ 天小豆的厌烦度，因为这个数可能很大，所以将结果模 $10^9 +7$ 后输出。", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，$1\\le a_i,x_j,y_j\\le n \\le 5\\times 10^3$，$1\\le m\\le 5\\times 10^3$， $1\\le v_i\\le10^5$。\n- 对于 $100\\%$ 的数据，$1\\le a_i,x_j,y_j\\le n\\le 5\\times 10^4$，$1\\le m\\le 5\\times 10^4$，$1\\le v_i\\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3760", "type": "P", "difficulty": 5, "samples": [["3\n1 2 3", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "各省省选", "树状数组", "进制", "前缀和", "天津"], "title": "[TJOI2017] 异或和", "background": "", "description": "在加里敦中学的小明最近爱上了数学竞赛，很多数学竞赛的题都是与序列的连续和相关的。  所以对于一个序列，求出它们所有的连续和来说，小明觉得十分的简单。  \n\n但今天小明遇到了一个序列和的难题，这个题目不仅要求你快速的求出所有的连续和（即子串和），还要快速的求出这些连续和的异或值。  \n\n小明很快的就求出了所有的连续和，但是小明要考考你，在不告诉连续和的情况下，让你快速求是序列所有连续和的异或值。\n", "inputFormat": "第一行输入一个 $n$，表示这序列的数序列。\n\n第二行输入 $n$ 个非负整数 $a_1,a_2 \\dots a_n$ 代表这个序列。", "outputFormat": "输出这个序列所有的连续和的异或值。\n", "hint": "【样例解释】\n\n序列 $[1,2,3]$ 有 $6$ 个连续和，它们分别是 $1,2,3,3,5,6$，而 $1 \\text{ xor } 2 \\text{ xor } 3 \\text{ xor } 3 \\text{ xor } 5 \\text{ xor } 6 = 0$。\n\n【数据范围】\n\n- 对于 $20\\%$ 的数据，$1\\le n \\le 100$；\n- 对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，$\\sum a_i \\le 10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2017] XOR Sum", "background": "", "description": "Xiao Ming from Garidon High School has recently fallen in love with math contests. Many problems are related to the sums of contiguous segments of a sequence. For a sequence, computing all of its contiguous sums (i.e., subarray sums) is very easy for Xiao Ming.\n\nBut today he encountered a tougher problem: not only do you need to quickly obtain all subarray sums, you also need to quickly compute the XOR of these sums.\n\nXiao Ming has already computed all subarray sums. However, without telling you these sums, he challenges you to quickly compute the XOR of all subarray sums of the sequence.", "inputFormat": "The first line contains an integer $n$, indicating the length of the sequence.\n\nThe second line contains $n$ non-negative integers $a_1, a_2 \\dots a_n$ representing the sequence.", "outputFormat": "Output the XOR of all subarray sums of the sequence.", "hint": "Sample Explanation:\n\nThe sequence [1, 2, 3] has 6 subarray sums: 1, 2, 3, 3, 5, 6, and $1 \\text{ xor } 2 \\text{ xor } 3 \\text{ xor } 3 \\text{ xor } 5 \\text{ xor } 6 = 0$.\n\nConstraints:\n\n- For $20\\%$ of the testdata, $1 \\le n \\le 100$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 10^5$, $\\sum a_i \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2017] 异或和", "background": "", "description": "在加里敦中学的小明最近爱上了数学竞赛，很多数学竞赛的题都是与序列的连续和相关的。  所以对于一个序列，求出它们所有的连续和来说，小明觉得十分的简单。  \n\n但今天小明遇到了一个序列和的难题，这个题目不仅要求你快速的求出所有的连续和（即子串和），还要快速的求出这些连续和的异或值。  \n\n小明很快的就求出了所有的连续和，但是小明要考考你，在不告诉连续和的情况下，让你快速求是序列所有连续和的异或值。\n", "inputFormat": "第一行输入一个 $n$，表示这序列的数序列。\n\n第二行输入 $n$ 个非负整数 $a_1,a_2 \\dots a_n$ 代表这个序列。", "outputFormat": "输出这个序列所有的连续和的异或值。\n", "hint": "【样例解释】\n\n序列 $[1,2,3]$ 有 $6$ 个连续和，它们分别是 $1,2,3,3,5,6$，而 $1 \\text{ xor } 2 \\text{ xor } 3 \\text{ xor } 3 \\text{ xor } 5 \\text{ xor } 6 = 0$。\n\n【数据范围】\n\n- 对于 $20\\%$ 的数据，$1\\le n \\le 100$；\n- 对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，$\\sum a_i \\le 10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P3761", "type": "P", "difficulty": 5, "samples": [["5\n1 2 1\n2 3 2\n3 4 3\n4 5 4", "7"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "各省省选", "枚举", "树的直径", "天津"], "title": "[TJOI2017] 城市", "background": null, "description": "从加里敦大学城市规划专业毕业的小明来到了一个地区城市规划局工作。这个地区一共有 $n$ 座城市，$n-1$ 条高速公路，保证了任意两座城市之间都可以通过高速公路相互可达，但是通过一条高速公路需要收取一定的交通费用。小明对这个地区深入研究后，觉得这个地区的交通费用太贵。\n\n小明想彻底改造这个地区，但是由于上司给他的资源有限，因而小明现在只能对一条高速公路进行改造，改造的方式就是去掉一条高速公路，并且重新修建一条一样的高速公路（即交通费用一样），使得这个地区的两个城市之间的最大交通费用最小（即使得交通费用最大的两座城市之间的交通费用最小），并且保证修建完之后任意两座城市相互可达。如果你是小明，你怎么解决这个问题？", "inputFormat": "输入数据的第一行为一个整数 $n$，代表城市个数。\n\n接下来的 $n - 1$ 行分别代表了最初的 $n-1$ 条公路情况。每一行都有三个整数 $u,v,d$。$u,v$ 代表这条公路的两端城市标号，$d$ 代表这条公路的交通费用。\n\n$1 \\leq u,v \\leq n$，$1\\leq d \\leq 2000$。", "outputFormat": "输出数据仅有一行，一个整数，表示进行了最优的改造之后，该地区两城市 之间最大交通费用。", "hint": "对于 $30\\%$ 的数据，$1\\leq n\\leq 500$。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 5000$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2017] City", "background": "", "description": "After graduating from the Urban Planning program at Gariton University, Xiao Ming joined a regional Urban Planning Bureau. This region has $n$ cities and $n-1$ highways, ensuring that any two cities are mutually reachable via highways. However, traveling through a highway requires paying a transportation cost. After careful study, Xiao Ming thinks the transportation cost in this region is too high.\n\nXiao Ming wants to completely overhaul the region, but due to limited resources from his supervisor, he can only modify exactly one highway. The modification is to remove one highway and rebuild one identical highway (i.e., with the same transportation cost), so that the maximum transportation cost between any two cities is minimized (that is, the transportation cost between the pair of cities with the largest cost is as small as possible), and it must still be guaranteed that any two cities remain mutually reachable after reconstruction. If you were Xiao Ming, how would you solve this problem?", "inputFormat": "The first line contains an integer $n$, the number of cities.\n\nThe next $n-1$ lines describe the initial $n-1$ highways. Each line contains three integers $u, v, d$. Here $u, v$ are the labels of the two endpoint cities of this highway, and $d$ is its transportation cost.\n\n$1 \\leq u, v \\leq n$, $1 \\leq d \\leq 2000$.", "outputFormat": "Output a single integer: after the optimal reconstruction, the maximum transportation cost between any two cities.", "hint": "For 30% of the testdata, $1 \\leq n \\leq 500$.\n\nFor 100% of the testdata, $1 \\leq n \\leq 5000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2017] 城市", "background": null, "description": "从加里敦大学城市规划专业毕业的小明来到了一个地区城市规划局工作。这个地区一共有 $n$ 座城市，$n-1$ 条高速公路，保证了任意两座城市之间都可以通过高速公路相互可达，但是通过一条高速公路需要收取一定的交通费用。小明对这个地区深入研究后，觉得这个地区的交通费用太贵。\n\n小明想彻底改造这个地区，但是由于上司给他的资源有限，因而小明现在只能对一条高速公路进行改造，改造的方式就是去掉一条高速公路，并且重新修建一条一样的高速公路（即交通费用一样），使得这个地区的两个城市之间的最大交通费用最小（即使得交通费用最大的两座城市之间的交通费用最小），并且保证修建完之后任意两座城市相互可达。如果你是小明，你怎么解决这个问题？", "inputFormat": "输入数据的第一行为一个整数 $n$，代表城市个数。\n\n接下来的 $n - 1$ 行分别代表了最初的 $n-1$ 条公路情况。每一行都有三个整数 $u,v,d$。$u,v$ 代表这条公路的两端城市标号，$d$ 代表这条公路的交通费用。\n\n$1 \\leq u,v \\leq n$，$1\\leq d \\leq 2000$。", "outputFormat": "输出数据仅有一行，一个整数，表示进行了最优的改造之后，该地区两城市 之间最大交通费用。", "hint": "对于 $30\\%$ 的数据，$1\\leq n\\leq 500$。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 5000$。", "locale": "zh-CN"}}}
{"pid": "P3762", "type": "P", "difficulty": 6, "samples": [["2 3 3\n5 2 3\n3 2 3\n2 3 2\n1 4\n2 4\n1 7", "3\n-1\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 5000, 5000, 5000, 5000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "各省省选", "天津"], "title": "[TJOI2017] 龙舟", "background": "", "description": "加里敦大学有一个龙舟队，龙舟队有 $n$ 支队伍，每只队伍有 $m$ 个划手。龙舟比赛是一个集体项目，和每个人的能力息息相关，但由于龙舟讲究配合，所以评价队伍的能力的是一个值 $C=\\frac{b_1 \\times b_2 \\times \\cdots \\times b_m}{a_1 \\times a_2 \\times \\cdots \\times a_m}$，其中 $b_i$ 表示第 $i$ 个位置的标准能力值，$a_i$ 表示在队伍中第 $i$ 个位置的划手的能力值。最后通过约分，我们会得到 $C=\\frac{B}{A}$，其中 $\\gcd(B,A)=1$，即 $A,B$ 互质。\n\n但是由于比赛现场的情况不一样，我们认为在现场压力为 $M$ 的情况下，队伍最后的表现情况是 $C^{-1}\\mod M$。我们规定在模 $M$ 的条件下 $\\frac{1}{x}=y$，其中 $y$ 满足 $xy \\equiv 1\\pmod M$，并且 $y$ 大于等于 $0$ 小于 $M$。如果不存在这样的 $y$ 我们就认为在压力为 $M$ 的条件下这支队伍会发挥失常（即 $y$ 是 $x$ 在模 $M$ 意义下的逆元，如果不存在逆元我们认为队伍发挥失常）。给出这个赛季的比赛安排情况，现在教练组想知道各队在比赛中的表现情况。", "inputFormat": "\n第一行输入三个整数 $n,m,k$，表示有 $n$ 支队伍，每支队伍由 $m$ 个人组成，有 $k$ 场比赛。\n\n第二行输入 $m$ 个整数，第 $i$ 个整数表示第 $i$ 个位置的标准能力值为 $b_i$。\n\n第三行到第 $n+2$ 行，共 $n$ 行，每行有 $m$ 个数，第 $2+i$ 行第 $j$ 个数表示第 $i$ 支队伍第 $j$ 个位置划手的能力值。\n\n第 $n+3$ 行到第 $n+k+2$ 行，共 $k$ 行，每行有两个数 $x,M$，分别表示第 $x$ 支队伍会在压力为 $M$ 的比赛中出战。", "outputFormat": "共 $k$ 行，第 $i$ 行表示在第 $i$ 个参赛安排中队伍的现场表现情况 $C$，如果出现队伍发挥失常，输出 `-1`。", "hint": "对于 $20\\%$ 的数据，$1<M,a_i,b_i<10^8$，$m \\le 100$。\n\n对于 $100\\%$ 的数据，$1<M,a_i,b_i<2 \\times 10^{18}$，$m \\le 10000$，$n \\le 20$，$k \\le 50$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2017] Dragon Boat", "background": "# Description\n\nJialidun University has a dragon boat club with $n$ teams, each consisting of $m$ paddlers. Dragon boat racing is a team sport, and while it depends on each individual’s ability, coordination is crucial. Therefore, the ability of a team is evaluated by the value $C=\\frac{b_1 \\times b_2 \\times \\cdots \\times b_m}{a_1 \\times a_2 \\times \\cdots \\times a_m}$, where $b_i$ is the standard ability value for position $i$, and $a_i$ is the ability value of the paddler in position $i$ in the team. After cancellation, we obtain $C=\\frac{B}{A}$ with $\\gcd(B,A)=1$, i.e., $A$ and $B$ are coprime.\n\nHowever, due to varying conditions at the venue, we consider that under pressure $M$, the team’s final performance is $C^{-1} \\bmod M$. We define that under modulo $M$, $\\frac{1}{x}=y$, where $y$ satisfies $xy \\equiv 1\\pmod M$ and $0 \\le y < M$. If no such $y$ exists, we say the team will underperform under pressure $M$ (that is, $y$ is the modular inverse of $x$ modulo $M$; if the inverse does not exist, the team underperforms). Given this season’s schedule, the coaching staff wants to know each team’s performance in the matches.", "description": "", "inputFormat": "", "outputFormat": "Output $k$ lines. For the $i$-th scheduled match, output the team’s on-site performance value $C^{-1} \\bmod M$. If the team underperforms (i.e., the inverse does not exist), output `-1`.", "hint": "For $20\\%$ of the testdata, $1<M,a_i,b_i<10^8$, $m \\le 100$.\n\nFor $100\\%$ of the testdata, $1<M,a_i,b_i<2 \\times 10^{18}$, $m \\le 10000$, $n \\le 20$, $k \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2017] 龙舟", "background": "", "description": "加里敦大学有一个龙舟队，龙舟队有 $n$ 支队伍，每只队伍有 $m$ 个划手。龙舟比赛是一个集体项目，和每个人的能力息息相关，但由于龙舟讲究配合，所以评价队伍的能力的是一个值 $C=\\frac{b_1 \\times b_2 \\times \\cdots \\times b_m}{a_1 \\times a_2 \\times \\cdots \\times a_m}$，其中 $b_i$ 表示第 $i$ 个位置的标准能力值，$a_i$ 表示在队伍中第 $i$ 个位置的划手的能力值。最后通过约分，我们会得到 $C=\\frac{B}{A}$，其中 $\\gcd(B,A)=1$，即 $A,B$ 互质。\n\n但是由于比赛现场的情况不一样，我们认为在现场压力为 $M$ 的情况下，队伍最后的表现情况是 $C^{-1}\\mod M$。我们规定在模 $M$ 的条件下 $\\frac{1}{x}=y$，其中 $y$ 满足 $xy \\equiv 1\\pmod M$，并且 $y$ 大于等于 $0$ 小于 $M$。如果不存在这样的 $y$ 我们就认为在压力为 $M$ 的条件下这支队伍会发挥失常（即 $y$ 是 $x$ 在模 $M$ 意义下的逆元，如果不存在逆元我们认为队伍发挥失常）。给出这个赛季的比赛安排情况，现在教练组想知道各队在比赛中的表现情况。", "inputFormat": "\n第一行输入三个整数 $n,m,k$，表示有 $n$ 支队伍，每支队伍由 $m$ 个人组成，有 $k$ 场比赛。\n\n第二行输入 $m$ 个整数，第 $i$ 个整数表示第 $i$ 个位置的标准能力值为 $b_i$。\n\n第三行到第 $n+2$ 行，共 $n$ 行，每行有 $m$ 个数，第 $2+i$ 行第 $j$ 个数表示第 $i$ 支队伍第 $j$ 个位置划手的能力值。\n\n第 $n+3$ 行到第 $n+k+2$ 行，共 $k$ 行，每行有两个数 $x,M$，分别表示第 $x$ 支队伍会在压力为 $M$ 的比赛中出战。", "outputFormat": "共 $k$ 行，第 $i$ 行表示在第 $i$ 个参赛安排中队伍的现场表现情况 $C$，如果出现队伍发挥失常，输出 `-1`。", "hint": "对于 $20\\%$ 的数据，$1<M,a_i,b_i<10^8$，$m \\le 100$。\n\n对于 $100\\%$ 的数据，$1<M,a_i,b_i<2 \\times 10^{18}$，$m \\le 10000$，$n \\le 20$，$k \\le 50$。", "locale": "zh-CN"}}}
{"pid": "P3763", "type": "P", "difficulty": 6, "samples": [["1\nATCGCCCTA\nCTTCA", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "二分", "各省省选", "哈希 hashing", "后缀数组 SA", "快速傅里叶变换 FFT", "天津"], "title": "[TJOI2017] DNA", "background": "", "description": "加里敦大学的生物研究所，发现了决定人喜不喜欢吃藕的基因序列 $S$,有这个序列的碱基序列就会表现出喜欢吃藕的性状，但是研究人员发现对碱基序列 $S$，任意修改其中不超过 $3$ 个碱基，依然能够表现出吃藕的性状。现在研究人员想知道这个基因在 DNA 链 $S_0$ 上的位置。所以你需要统计在一个表现出吃藕性状的人的 DNA 序列 $S_0$ 上，有多少个连续子串可能是该基因，即有多少个 $S_0$ 的连续子串修改小于等于三个字母能够变成 $S$。\n", "inputFormat": "第一行有一个整数 $T$，表示有几组数据。\n\n每组数据第一行一个长度不超过 $10^5$ 的碱基序列 $S_0$。\n\n每组数据第二行一个长度不超过 $10^5$ 的吃藕基因序列 $S$。\n", "outputFormat": "共 $T$ 行，第 $i$ 行表示第 $i$ 组数据中，在 $S_0$中有多少个与 $S$ 等长的连续子串可能是表现吃藕性状的碱基序列。\n", "hint": "对于 $20\\%$ 的数据，$S_0,S$ 的长度不超过 $10^4$。\n\n对于 $100\\%$ 的数据，$S_0,S$ 的长度不超过 $10^5$，$0\\lt T\\leq 10$。\n\n注：DNA 碱基序列只有 ATCG 四种字符。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2017] DNA", "background": "", "description": "Researchers at the Biology Institute of Garitun University discovered a gene sequence $S$ that determines whether a person likes eating lotus root. Any DNA segment with this sequence exhibits the \"likes lotus root\" trait. Moreover, they found that for the base sequence $S$, modifying at most $3$ bases still results in the trait. Now the researchers want to locate this gene on a DNA strand $S_0$. Therefore, you need to count, on the DNA sequence $S_0$ of a person who exhibits the trait, how many contiguous substrings could be this gene, i.e., how many contiguous substrings of $S_0$ can be changed into $S$ by modifying at most three letters.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nFor each test case, the first line contains a base sequence $S_0$ of length not exceeding $10^5$.\n\nThe second line contains the \"lotus-root gene\" sequence $S$ of length not exceeding $10^5$.", "outputFormat": "Output $T$ lines. The $i$-th line indicates, in the $i$-th test case, how many contiguous substrings in $S_0$ of the same length as $S$ could be a base sequence exhibiting the \"likes lotus root\" trait.", "hint": "For $20\\%$ of the testdata, the lengths of $S_0$ and $S$ do not exceed $10^4$.\n\nFor $100\\%$ of the testdata, the lengths of $S_0$ and $S$ do not exceed $10^5$, $0\\lt T\\leq 10$.\n\nNote: DNA base sequences only contain the four characters A, T, C, and G.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2017] DNA", "background": "", "description": "加里敦大学的生物研究所，发现了决定人喜不喜欢吃藕的基因序列 $S$,有这个序列的碱基序列就会表现出喜欢吃藕的性状，但是研究人员发现对碱基序列 $S$，任意修改其中不超过 $3$ 个碱基，依然能够表现出吃藕的性状。现在研究人员想知道这个基因在 DNA 链 $S_0$ 上的位置。所以你需要统计在一个表现出吃藕性状的人的 DNA 序列 $S_0$ 上，有多少个连续子串可能是该基因，即有多少个 $S_0$ 的连续子串修改小于等于三个字母能够变成 $S$。\n", "inputFormat": "第一行有一个整数 $T$，表示有几组数据。\n\n每组数据第一行一个长度不超过 $10^5$ 的碱基序列 $S_0$。\n\n每组数据第二行一个长度不超过 $10^5$ 的吃藕基因序列 $S$。\n", "outputFormat": "共 $T$ 行，第 $i$ 行表示第 $i$ 组数据中，在 $S_0$中有多少个与 $S$ 等长的连续子串可能是表现吃藕性状的碱基序列。\n", "hint": "对于 $20\\%$ 的数据，$S_0,S$ 的长度不超过 $10^4$。\n\n对于 $100\\%$ 的数据，$S_0,S$ 的长度不超过 $10^5$，$0\\lt T\\leq 10$。\n\n注：DNA 碱基序列只有 ATCG 四种字符。", "locale": "zh-CN"}}}
{"pid": "P3764", "type": "P", "difficulty": 6, "samples": [["100", "1124"], ["2000", "68204"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "递归", "洛谷原创", "O2优化", "枚举", "洛谷月赛"], "title": "签到题 III", "background": "pj 组选手 zzq 近日学会了求最大公约数的辗转相除法。", "description": "类比辗转相除法，zzq 定义了一个奇怪的函数：\n\n```cpp\ntypedef long long ll;\nll f(ll a,ll b)\n{\n    if(a==b) return 0;\n    if(a>b) return f(a-b,b+b)+1;\n    else return f(a+a,b-a)+1;\n}\n```\nzzq 定义完这个函数兴高采烈，随便输入了两个数，打算计算 $f$ 值，发现这个函数死循环了……于是 zzq 定义这个函数递归死循环的情况下 $f$ 值为 $0$。\n\n现在 zzq 输入了一个数 $n$，想要求出 $\\sum_{i=1}^n \\sum_{j=1}^n f(i,j)$。", "inputFormat": "一行一个数 $n$。", "outputFormat": "一行一个数 $\\sum_{i=1}^n \\sum_{j=1}^n f(i,j)$。", "hint": "对 $10\\%$ 的数据，$n \\leq 300$。\n\n对于 $40\\%$ 的数据，$n \\leq 2000$。\n\n对于 $70\\%$ 的数据，$n \\leq 5 \\times 10^5$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 5 \\times 10^{11}$。", "locale": "zh-CN", "translations": {"en": {"title": "Check-in Problem III", "background": "The Junior contestant zzq recently learned the Euclidean algorithm for computing the greatest common divisor (GCD).", "description": "By analogy with the Euclidean algorithm, zzq defined a strange function:\n\n```cpp\ntypedef long long ll;\nll f(ll a,ll b)\n{\n    if(a==b) return 0;\n    if(a>b) return f(a-b,b+b)+1;\n    else return f(a+a,b-a)+1;\n}\n```\nAfter defining this function, zzq excitedly entered two numbers to compute the value of $f$, but found that the function fell into an infinite recursion... Therefore, zzq defines the value of $f$ to be $0$ in cases where the recursion would loop infinitely.\n\nNow zzq inputs a number $n$, and wants to compute $\\sum_{i=1}^n \\sum_{j=1}^n f(i,j)$.", "inputFormat": "One line containing an integer $n$.", "outputFormat": "One line containing an integer $\\sum_{i=1}^n \\sum_{j=1}^n f(i,j)$.", "hint": "For 10% of the testdata, $n \\leq 300$.\n\nFor 40% of the testdata, $n \\leq 2000$.\n\nFor 70% of the testdata, $n \\leq 5 \\times 10^5$.\n\nFor 100% of the testdata, $1 \\leq n \\leq 5 \\times 10^{11}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "签到题 III", "background": "pj 组选手 zzq 近日学会了求最大公约数的辗转相除法。", "description": "类比辗转相除法，zzq 定义了一个奇怪的函数：\n\n```cpp\ntypedef long long ll;\nll f(ll a,ll b)\n{\n    if(a==b) return 0;\n    if(a>b) return f(a-b,b+b)+1;\n    else return f(a+a,b-a)+1;\n}\n```\nzzq 定义完这个函数兴高采烈，随便输入了两个数，打算计算 $f$ 值，发现这个函数死循环了……于是 zzq 定义这个函数递归死循环的情况下 $f$ 值为 $0$。\n\n现在 zzq 输入了一个数 $n$，想要求出 $\\sum_{i=1}^n \\sum_{j=1}^n f(i,j)$。", "inputFormat": "一行一个数 $n$。", "outputFormat": "一行一个数 $\\sum_{i=1}^n \\sum_{j=1}^n f(i,j)$。", "hint": "对 $10\\%$ 的数据，$n \\leq 300$。\n\n对于 $40\\%$ 的数据，$n \\leq 2000$。\n\n对于 $70\\%$ 的数据，$n \\leq 5 \\times 10^5$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 5 \\times 10^{11}$。", "locale": "zh-CN"}}}
{"pid": "P3765", "type": "P", "difficulty": 6, "samples": [["5 4\n1 2 3 4 5\n1 2 1 1 3\n5 5 1 2 2 4\n2 4 2 0\n3 4 2 1 4", "1\n5\n5\n2\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 3000, 3000, 3000, 3000, 5000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "平衡树", "洛谷原创", "O2优化", "枚举", "构造", "洛谷月赛"], "title": "总统选举", "background": "黑恶势力的反攻计划被小 C 成功摧毁，黑恶势力只好投降。秋之国的人民解放了，举国欢庆。此时，原秋之国总统因没能守护好国土，申请辞职，并请秋之国人民的大救星小 C 钦定下一任。\n\n作为一名民主人士，小 C 决定举行全民大选来决定下一任。为了使最后成为总统的人得到绝大多数人认同，小 C 认为，一个人必须获得超过全部人总数的一半的票数才能成为总统。如果不存在符合条件的候选人，小 C 只好自己来当临时大总统。为了尽可能避免这种情况，小 C 决定先进行几次小规模预选，根据预选的情况，选民可以重新决定自己选票的去向。\n\n由于秋之国人数较多，统计投票结果和选票变更也成为了麻烦的事情，小 C 找到了你，让你帮他解决这个问题。", "description": "秋之国共有 $n$ 个人，分别编号为 $1,2,…,n$，一开始每个人都投了一票，范围 $1 \\sim n$，表示支持对应编号的人当总统。\n\n共有 $m$ 次预选，每次选取编号 $[l_i,r_i]$ 内的选民展开小规模预选，在该区间内获得超过区间大小一半的票的人获胜。如果没有人获胜，则由小 C 钦定一位候选者获得此次预选的胜利（获胜者可以不在该区间内），每次预选的结果需要公布出来，并且每次会有 $k_i$ 个人决定将票改投向该次预选的获胜者。\n\n全部预选结束后，公布最后成为总统的候选人。", "inputFormat": "第一行两个整数 $n,m$，表示秋之国人数和预选次数。\n\n第二行 $n$ 个整数，分别表示编号 $1 \\sim n$ 的选民投的票。\n\n接下来 $m$ 行，每行先有四个整数，分别表示 $l_i,r_i,s_i,k_i$，$s_i$ 表示若此次预选无人胜选，视作编号为 $s_i$ 的人获得胜利，接下来 $k_i$ 个整数，分别表示决定改投的选民。", "outputFormat": "共 $m+1$ 行，前 $m$ 行表示各次预选的结果，最后一行表示最后成为总统的候选人，若最后仍无人胜选，输出 $-1$。", "hint": "对于前 $20 \\%$ 的数据，$1 \\leq n,m \\leq 5000$。\n\n对于前 $40 \\%$ 的数据，$1 \\leq n,m \\leq 50000$，$\\sum k_i \\leq 50000$。\n\n对于前 $50 \\%$ 的数据，$1 \\leq n,m \\leq {10}^5$，$\\sum k_i \\leq 2 \\times {10}^5$。\n\n对于数据点 6~7，保证所有选票始终在 $1 \\sim 10$ 之间。\n\n对于 $100 \\%$ 的数据，$1 \\leq n,m \\leq 5 \\times {10}^5$，$\\sum k_i \\leq 10^6$，$1 \\leq l_i \\leq r_i \\leq n$，$1 \\leq s_i \\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "Presidential Election", "background": "The counterattack plan of the criminal forces was successfully crushed by Xiao C, and they had no choice but to surrender. The people of the State of Qiu were liberated, and the whole country celebrated. At this moment, the former president of Qiu, having failed to protect the nation, resigned and asked the great savior of the people, Xiao C, to designate the next president.\n\nAs a democrat, Xiao C decided to hold a nationwide election to determine the next president. To ensure the final president is recognized by the vast majority, Xiao C believes that one must receive more than half of all votes to become president. If no candidate meets this condition, Xiao C will have to serve as the interim president himself. To minimize this possibility, Xiao C decided to hold several small-scale primaries first; based on the results of these primaries, voters may change their votes.\n\nSince Qiu has a large population, tallying votes and tracking changes became troublesome. Xiao C turned to you for help to solve this problem.", "description": "There are $n$ people in the State of Qiu, numbered $1, 2, \\dots, n$. Initially, each person casts one vote in the range $1 \\sim n$, indicating support for the person with that ID to become president.\n\nThere are $m$ primaries. In each primary, voters with indices $[l_i, r_i]$ are selected for a small-scale primary. Within that interval, the person who gets more than half of the votes in the interval wins. If no one wins, Xiao C designates a candidate with ID $s_i$ as the winner (the winner may be outside the interval). The result of each primary must be announced, and after each primary, $k_i$ people decide to switch their votes to the winner of that primary.\n\nAfter all primaries end, announce the candidate who finally becomes president.", "inputFormat": "The first line contains two integers $n, m$, the population of Qiu and the number of primaries.\n\nThe second line contains $n$ integers, representing the votes cast by voters numbered $1 \\sim n$.\n\nThen follow $m$ lines. Each line first contains four integers $l_i, r_i, s_i, k_i$, where $s_i$ means that if no one wins this primary, the person with ID $s_i$ is considered the winner. Then follow $k_i$ integers, representing the voters who decide to switch their votes.", "outputFormat": "Output $m+1$ lines in total. The first $m$ lines represent the result of each primary. The last line represents the candidate who finally becomes president. If in the end no one still meets the winning condition, output $-1$.", "hint": "For the first $20 \\%$ of the testdata, $1 \\leq n, m \\leq 5000$.\n\nFor the first $40 \\%$ of the testdata, $1 \\leq n, m \\leq 50000$, $\\sum k_i \\leq 50000$.\n\nFor the first $50 \\%$ of the testdata, $1 \\leq n, m \\leq {10}^5$, $\\sum k_i \\leq 2 \\times {10}^5$.\n\nFor data points 6~7, it is guaranteed that all votes always remain in $1 \\sim 10$.\n\nFor $100 \\%$ of the testdata, $1 \\leq n, m \\leq 5 \\times {10}^5$, $\\sum k_i \\leq 10^6$, $1 \\leq l_i \\leq r_i \\leq n$, $1 \\leq s_i \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "总统选举", "background": "黑恶势力的反攻计划被小 C 成功摧毁，黑恶势力只好投降。秋之国的人民解放了，举国欢庆。此时，原秋之国总统因没能守护好国土，申请辞职，并请秋之国人民的大救星小 C 钦定下一任。\n\n作为一名民主人士，小 C 决定举行全民大选来决定下一任。为了使最后成为总统的人得到绝大多数人认同，小 C 认为，一个人必须获得超过全部人总数的一半的票数才能成为总统。如果不存在符合条件的候选人，小 C 只好自己来当临时大总统。为了尽可能避免这种情况，小 C 决定先进行几次小规模预选，根据预选的情况，选民可以重新决定自己选票的去向。\n\n由于秋之国人数较多，统计投票结果和选票变更也成为了麻烦的事情，小 C 找到了你，让你帮他解决这个问题。", "description": "秋之国共有 $n$ 个人，分别编号为 $1,2,…,n$，一开始每个人都投了一票，范围 $1 \\sim n$，表示支持对应编号的人当总统。\n\n共有 $m$ 次预选，每次选取编号 $[l_i,r_i]$ 内的选民展开小规模预选，在该区间内获得超过区间大小一半的票的人获胜。如果没有人获胜，则由小 C 钦定一位候选者获得此次预选的胜利（获胜者可以不在该区间内），每次预选的结果需要公布出来，并且每次会有 $k_i$ 个人决定将票改投向该次预选的获胜者。\n\n全部预选结束后，公布最后成为总统的候选人。", "inputFormat": "第一行两个整数 $n,m$，表示秋之国人数和预选次数。\n\n第二行 $n$ 个整数，分别表示编号 $1 \\sim n$ 的选民投的票。\n\n接下来 $m$ 行，每行先有四个整数，分别表示 $l_i,r_i,s_i,k_i$，$s_i$ 表示若此次预选无人胜选，视作编号为 $s_i$ 的人获得胜利，接下来 $k_i$ 个整数，分别表示决定改投的选民。", "outputFormat": "共 $m+1$ 行，前 $m$ 行表示各次预选的结果，最后一行表示最后成为总统的候选人，若最后仍无人胜选，输出 $-1$。", "hint": "对于前 $20 \\%$ 的数据，$1 \\leq n,m \\leq 5000$。\n\n对于前 $40 \\%$ 的数据，$1 \\leq n,m \\leq 50000$，$\\sum k_i \\leq 50000$。\n\n对于前 $50 \\%$ 的数据，$1 \\leq n,m \\leq {10}^5$，$\\sum k_i \\leq 2 \\times {10}^5$。\n\n对于数据点 6~7，保证所有选票始终在 $1 \\sim 10$ 之间。\n\n对于 $100 \\%$ 的数据，$1 \\leq n,m \\leq 5 \\times {10}^5$，$\\sum k_i \\leq 10^6$，$1 \\leq l_i \\leq r_i \\leq n$，$1 \\leq s_i \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P3766", "type": "P", "difficulty": 7, "samples": [["2\n5\n15", "0.25000000000000\n0.48611111111111"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "洛谷原创", "Special Judge", "O2优化", "优先队列", "微积分", "洛谷月赛"], "title": "核心密码B", "background": "懒得拷题目背景了，参见核心密码 A...\n\n请注意两道题的唯一差别。\n", "description": "令 $g(n)$ 表示 $n$ 能表示成几种不同的完全 $k$ 次方数（$k>1$），求 $f(n)=\\sum_{i=2}^n \\frac{g(i)}{i}$。\n\n例如，$64=2^6=4^3=8^2$，所以 $g(64)=3$。\n", "inputFormat": "多组询问，第一行一个整数 $T$ 表示询问组数。\n\n接下来 $T$ 行，每行一个整数 $n$，表示询问 $f(n)$。\n", "outputFormat": "$T$ 行，每行一个实数，表示 $f(n)$，保留十四位小数。\n\n**由于精度误差，你的答案和标准答案差的绝对值在 $2 \\times 10^{-14}$ 以内即可通过。**\n", "hint": "对于 $20\\%$ 的数据，$n \\leq 1000$。\n\n对于 $40\\%$ 的数据，$n \\leq 10^6$，$T \\leq 5$。\n\n对于 $100\\%$ 的数据，$2 \\leq n \\leq 10^{18}$，$1 \\leq T \\leq 50000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Core Cipher B", "background": "Please refer to \"Core Cipher A\" for the background. Note the only difference between the two problems.", "description": "Let $g(n)$ denote the number of different ways $n$ can be expressed as a perfect $k$-th power ($k > 1$). Compute $f(n)=\\sum_{i=2}^n \\frac{g(i)}{i}$.\n\nFor example, $64=2^6=4^3=8^2$, so $g(64)=3$.", "inputFormat": "Multiple queries. The first line contains an integer $T$ indicating the number of queries.\n\nEach of the next $T$ lines contains an integer $n$, asking for $f(n)$.", "outputFormat": "Output $T$ lines. Each line contains a real number representing $f(n)$, with fourteen decimal places.\n\nDue to precision error, your answer will be accepted if the absolute difference from the standard answer is within $2 \\times 10^{-14}$.", "hint": "For $20\\%$ of the testdata, $n \\leq 1000$.\n\nFor $40\\%$ of the testdata, $n \\leq 10^6$, $T \\leq 5$.\n\nFor $100\\%$ of the testdata, $2 \\leq n \\leq 10^{18}$, $1 \\leq T \\leq 50000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "核心密码B", "background": "懒得拷题目背景了，参见核心密码 A...\n\n请注意两道题的唯一差别。\n", "description": "令 $g(n)$ 表示 $n$ 能表示成几种不同的完全 $k$ 次方数（$k>1$），求 $f(n)=\\sum_{i=2}^n \\frac{g(i)}{i}$。\n\n例如，$64=2^6=4^3=8^2$，所以 $g(64)=3$。\n", "inputFormat": "多组询问，第一行一个整数 $T$ 表示询问组数。\n\n接下来 $T$ 行，每行一个整数 $n$，表示询问 $f(n)$。\n", "outputFormat": "$T$ 行，每行一个实数，表示 $f(n)$，保留十四位小数。\n\n**由于精度误差，你的答案和标准答案差的绝对值在 $2 \\times 10^{-14}$ 以内即可通过。**\n", "hint": "对于 $20\\%$ 的数据，$n \\leq 1000$。\n\n对于 $40\\%$ 的数据，$n \\leq 10^6$，$T \\leq 5$。\n\n对于 $100\\%$ 的数据，$2 \\leq n \\leq 10^{18}$，$1 \\leq T \\leq 50000$。\n", "locale": "zh-CN"}}}
{"pid": "P3767", "type": "P", "difficulty": 6, "samples": [["3 6  \n0 1 1 2  \n1 1 2 3  \n2 2 1 3  \n2 1 3 1  \n2 3 1  \n5 1 3 1", "excited  \nexcited  \nexcited  \nnaive  \nexcited  \nexcited  "]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "线段树", "并查集", "洛谷原创", "分治", "洛谷月赛"], "title": "魔法", "background": "小 Y 在 AK 曼哈顿 OI 之后，开始研究膜法。\n\n一个精心构造的魔法阵可以产生强大的魔力，但是也有非常严苛的要求。\n\n魔法阵的强度与咒语的数目相关，但是咒语太多可能会产生冲突，小Y当然会解决这个问题啦，但是他想考一考你。\n", "description": "魔法阵由 $N$ 个枢纽组成。\n\n每个枢纽可以有五种属性：金、木、水、火、土。它们之间满足相生相克的关系。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5349.png) \n\n一开始，魔法阵中没有咒语。\n\n每次，小 Y 会添加一条咒语，它会要求两个枢纽的属性满足相生/相克的关系。然后你需要回答：是否存在一种为每个枢纽分配一个属性的方案，满足所有的要求。\n\n为了调整法阵，小 Y 有时候需要删除一条写过的咒语。\n\n小 Y 觉得这个问题太简单了，于是他使用改变时间线的能力，让每一次操作在之前某一次操作后形成的魔法阵的基础上进行。", "inputFormat": "第一行两个正整数 $N,M$，表示枢纽的个数和操作个数。\n\n接下来 $M$ 行，每行四个数表示一次操作。\n\n第一个数 $k$ 表示这次操作在第 $k$ 次操作结束后的魔法阵上进行，如果 $k=0$，则表示在初始的魔法阵上进行。\n\n第二个数 $t$ 表示操作类型。\n\n- $t=1$：接下来输入 $u,v$，表示加入一条咒语，要求 $u$ 生 $v$。\n\n- $t=2$：接下来输入 $u,v$，表示加入一条咒语，要求 $u$ 克 $v$。\n\n- $t=3$: 接下来输入 $x$，表示删除第 $x$ 次操作加入的咒语。", "outputFormat": "对于每一次操作，如果操作后存在为每个枢纽分配一个属性的方案，满足所有的要求，输出 `excited`，否则输出 `naive`。\n", "hint": "对于 $30\\%$ 的数据，满足 $N,M\\leq 100$;\n\n对于另 $30\\%$ 的数据，满足 $k_i=i-1$;\n\n对于100%的数据，满足 $N,M \\leq 100000, 0\\leq k_i < i, u_i \\neq v_i, 1 \\leq u_i,v_i \\leq N$，保证所有删除操作都合法。\n", "locale": "zh-CN", "translations": {"en": {"title": "Magic", "background": "After Xiao Y AK'd Manhattan OI, he began to study magic.\n\nA carefully constructed magic array can generate great power, but it also has very strict requirements.\n\nThe strength of the magic array is related to the number of spells, but too many spells may cause conflicts. Of course Xiao Y can solve this, but he wants to test you.", "description": "The magic array consists of $N$ nodes.\n\nEach node can have one of five attributes: metal, wood, water, fire, earth. They satisfy the generate/overcome relationships.\n\n ![](https://cdn.luogu.com.cn/upload/pic/5349.png) \n\nAt the beginning, there are no spells in the magic array.\n\nEach time, Xiao Y will add a spell that requires the attributes of two nodes to satisfy a generate/overcome relationship. Then you need to answer whether there exists an assignment of an attribute to each node that satisfies all the requirements.\n\nTo adjust the array, Xiao Y sometimes needs to delete a previously written spell.\n\nXiao Y thinks this problem is too easy, so he uses the ability to change the timeline, making each operation be applied on the magic array resulting right after some previous operation.", "inputFormat": "The first line contains two positive integers $N, M$, the number of nodes and the number of operations.\n\nThen follow $M$ lines, each containing four numbers describing one operation.\n\nThe first number $k$ means this operation is applied to the magic array obtained right after the $k$-th operation. If $k = 0$, it is applied to the initial magic array.\n\nThe second number $t$ indicates the operation type.\n\n- $t = 1$: then input $u, v$, meaning to add a spell requiring $u$ generates $v$.\n- $t = 2$: then input $u, v$, meaning to add a spell requiring $u$ overcomes $v$.\n- $t = 3$: then input $x$, meaning to delete the spell added by the $x$-th operation.", "outputFormat": "For each operation, if after the operation there exists an assignment of attributes to all nodes that satisfies all the requirements, output `excited`; otherwise, output `naive`.", "hint": "For $30\\%$ of the testdata, $N, M \\leq 100$.\n\nFor another $30\\%$ of the testdata, $k_i = i - 1$.\n\nFor $100\\%$ of the testdata, $N, M \\leq 100000$, $0 \\leq k_i < i$, $u_i \\neq v_i$, $1 \\leq u_i, v_i \\leq N$, and all delete operations are guaranteed to be valid.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "魔法", "background": "小 Y 在 AK 曼哈顿 OI 之后，开始研究膜法。\n\n一个精心构造的魔法阵可以产生强大的魔力，但是也有非常严苛的要求。\n\n魔法阵的强度与咒语的数目相关，但是咒语太多可能会产生冲突，小Y当然会解决这个问题啦，但是他想考一考你。\n", "description": "魔法阵由 $N$ 个枢纽组成。\n\n每个枢纽可以有五种属性：金、木、水、火、土。它们之间满足相生相克的关系。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5349.png) \n\n一开始，魔法阵中没有咒语。\n\n每次，小 Y 会添加一条咒语，它会要求两个枢纽的属性满足相生/相克的关系。然后你需要回答：是否存在一种为每个枢纽分配一个属性的方案，满足所有的要求。\n\n为了调整法阵，小 Y 有时候需要删除一条写过的咒语。\n\n小 Y 觉得这个问题太简单了，于是他使用改变时间线的能力，让每一次操作在之前某一次操作后形成的魔法阵的基础上进行。", "inputFormat": "第一行两个正整数 $N,M$，表示枢纽的个数和操作个数。\n\n接下来 $M$ 行，每行四个数表示一次操作。\n\n第一个数 $k$ 表示这次操作在第 $k$ 次操作结束后的魔法阵上进行，如果 $k=0$，则表示在初始的魔法阵上进行。\n\n第二个数 $t$ 表示操作类型。\n\n- $t=1$：接下来输入 $u,v$，表示加入一条咒语，要求 $u$ 生 $v$。\n\n- $t=2$：接下来输入 $u,v$，表示加入一条咒语，要求 $u$ 克 $v$。\n\n- $t=3$: 接下来输入 $x$，表示删除第 $x$ 次操作加入的咒语。", "outputFormat": "对于每一次操作，如果操作后存在为每个枢纽分配一个属性的方案，满足所有的要求，输出 `excited`，否则输出 `naive`。\n", "hint": "对于 $30\\%$ 的数据，满足 $N,M\\leq 100$;\n\n对于另 $30\\%$ 的数据，满足 $k_i=i-1$;\n\n对于100%的数据，满足 $N,M \\leq 100000, 0\\leq k_i < i, u_i \\neq v_i, 1 \\leq u_i,v_i \\leq N$，保证所有删除操作都合法。\n", "locale": "zh-CN"}}}
{"pid": "P3768", "type": "P", "difficulty": 6, "samples": [["998244353 2000", "883968974"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 3000, 3000, 4000, 4000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["洛谷原创", "O2优化", "莫比乌斯反演", "洛谷月赛", "杜教筛"], "title": "简单的数学题", "background": "", "description": "由于出题人懒得写背景了，题目还是简单一点好。\n\n\n输入一个整数 $n$ 和一个整数 $p$，你需要求出：\n\n$$\\left(\\sum_{i=1}^n\\sum_{j=1}^n ij \\gcd(i,j)\\right) \\bmod p$$\n\n其中 $\\gcd(a,b)$ 表示 $a$ 与 $b$ 的最大公约数。\n", "inputFormat": "一行两个整数 $p,n$。\n", "outputFormat": "一行一个整数表示答案。", "hint": "对于 $20\\%$ 的数据，$n \\leq 1000$。\n\n\n对于 $30\\%$ 的数据，$n \\leq 5000$。\n\n\n对于 $60\\%$ 的数据，$n \\leq 10^6$，时限 1s。\n\n\n对于另外 $20\\%$ 的数据，$n \\leq 10^9$，时限 3s。\n\n\n对于最后 $20\\%$ 的数据，$n \\leq 10^{10}$，时限 4s。\n\n\n对于 $100\\%$ 的数据，$5 \\times 10^8 \\leq p \\leq 1.1 \\times 10^9$ 且 $p$ 为质数。\n", "locale": "zh-CN", "translations": {"en": {"title": "A Simple Math Problem", "background": "", "description": "Since the problem setter is too lazy to write a background, let's keep the problem simple.\n\nGiven two integers $p$ and $n$, compute:\n$$\\left(\\sum_{i=1}^n\\sum_{j=1}^n ij \\gcd(i,j)\\right) \\bmod p$$\nHere $\\gcd(a,b)$ denotes the greatest common divisor of $a$ and $b$.", "inputFormat": "A single line containing two integers $p$ and $n$.", "outputFormat": "Output a single integer on one line, the answer.", "hint": "For 20% of the testdata, $n \\leq 1000$.\n\nFor 30% of the testdata, $n \\leq 5000$.\n\nFor 60% of the testdata, $n \\leq 10^6$, time limit 1 s.\n\nFor another 20% of the testdata, $n \\leq 10^9$, time limit 3 s.\n\nFor the last 20% of the testdata, $n \\leq 10^{10}$, time limit 4 s.\n\nFor 100% of the testdata, $5 \\times 10^8 \\leq p \\leq 1.1 \\times 10^9$ and $p$ is prime.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "简单的数学题", "background": "", "description": "由于出题人懒得写背景了，题目还是简单一点好。\n\n\n输入一个整数 $n$ 和一个整数 $p$，你需要求出：\n\n$$\\left(\\sum_{i=1}^n\\sum_{j=1}^n ij \\gcd(i,j)\\right) \\bmod p$$\n\n其中 $\\gcd(a,b)$ 表示 $a$ 与 $b$ 的最大公约数。\n", "inputFormat": "一行两个整数 $p,n$。\n", "outputFormat": "一行一个整数表示答案。", "hint": "对于 $20\\%$ 的数据，$n \\leq 1000$。\n\n\n对于 $30\\%$ 的数据，$n \\leq 5000$。\n\n\n对于 $60\\%$ 的数据，$n \\leq 10^6$，时限 1s。\n\n\n对于另外 $20\\%$ 的数据，$n \\leq 10^9$，时限 3s。\n\n\n对于最后 $20\\%$ 的数据，$n \\leq 10^{10}$，时限 4s。\n\n\n对于 $100\\%$ 的数据，$5 \\times 10^8 \\leq p \\leq 1.1 \\times 10^9$ 且 $p$ 为质数。\n", "locale": "zh-CN"}}}
{"pid": "P3769", "type": "P", "difficulty": 6, "samples": [["4\n2 3 33 2333\n2 3 33 2333\n2 3 33 2333\n2 3 33 2333\n", "4\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "平衡树", "cdq 分治", "分治", "排序", "K-D Tree"], "title": "[CH弱省胡策R2] TATT", "background": "", "description": "四维空间真是美妙。现在有 $n$ 个四维空间中的点，请求出一条最长的路径，满足任意一维坐标都是单调不降的。\n\n注意路径起点是任意选择的，并且路径与输入顺序无关（路径顺序不一定要满足在输入中是升序）。\n\n**路径的长度是经过的点的数量，任意点只能经过一次。**", "inputFormat": "第一行一个整数 $n$。接下来 $n$ 行，每行四个整数 $a_i,b_i,c_i,d_i$。表示四维坐标。", "outputFormat": "一行一个整数，表示最长路径的长度。", "hint": "记 $m_i=\\max(|a_i|,|b_i|,|c_i|,|d_i|),m=\\max(m_i)$\n|  测试点编号| $n\\le$ | $m\\le$ | 特殊说明 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $2000$ | $10^9$ |  |\n| $2$ |$5\\times 10^4$  | $8$ |  |\n| $3\\sim 4$ | $5\\times 10^4$ | $10^5$ |  所有点的第三，四维坐标相同|\n| $5\\sim 6$| $5\\times 10^4$ | $10^5$ |  所有点的第四维坐标相同 |\n| $7\\sim 8$ | $5\\times 10^4$ |$100$  |  |\n|  $9\\sim 10$| $5\\times 10^4$ | $10^9$ |  |", "locale": "zh-CN", "translations": {"en": {"title": "[CH弱省胡策R2] TATT", "background": "", "description": "Four-dimensional space is truly wonderful. Now there are $n$ points in four-dimensional space. Find a longest path such that, along the path, each coordinate in every dimension is monotonically non-decreasing.\n\nNote that the starting point of the path can be chosen arbitrarily, and the path is independent of the input order (the order along the path does not need to be increasing in the input).\n\nThe length of a path is the number of points visited, and any point can be visited at most once.", "inputFormat": "The first line contains an integer $n$. The next $n$ lines each contain four integers $a_i,b_i,c_i,d_i$, representing a 4D coordinate.", "outputFormat": "Output one integer in a single line, the length of a longest path.", "hint": "Let $m_i=\\max(|a_i|,|b_i|,|c_i|,|d_i|),m=\\max(m_i)$.\n|  Test point index | $n\\le$ | $m\\le$ | Special note |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $2000$ | $10^9$ |  |\n| $2$ | $5\\times 10^4$ | $8$ |  |\n| $3\\sim 4$ | $5\\times 10^4$ | $10^5$ | The 3rd and 4th coordinates of all points are the same |\n| $5\\sim 6$ | $5\\times 10^4$ | $10^5$ | The 4th coordinate of all points is the same |\n| $7\\sim 8$ | $5\\times 10^4$ | $100$ |  |\n| $9\\sim 10$ | $5\\times 10^4$ | $10^9$ |  |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CH弱省胡策R2] TATT", "background": "", "description": "四维空间真是美妙。现在有 $n$ 个四维空间中的点，请求出一条最长的路径，满足任意一维坐标都是单调不降的。\n\n注意路径起点是任意选择的，并且路径与输入顺序无关（路径顺序不一定要满足在输入中是升序）。\n\n**路径的长度是经过的点的数量，任意点只能经过一次。**", "inputFormat": "第一行一个整数 $n$。接下来 $n$ 行，每行四个整数 $a_i,b_i,c_i,d_i$。表示四维坐标。", "outputFormat": "一行一个整数，表示最长路径的长度。", "hint": "记 $m_i=\\max(|a_i|,|b_i|,|c_i|,|d_i|),m=\\max(m_i)$\n|  测试点编号| $n\\le$ | $m\\le$ | 特殊说明 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $2000$ | $10^9$ |  |\n| $2$ |$5\\times 10^4$  | $8$ |  |\n| $3\\sim 4$ | $5\\times 10^4$ | $10^5$ |  所有点的第三，四维坐标相同|\n| $5\\sim 6$| $5\\times 10^4$ | $10^5$ |  所有点的第四维坐标相同 |\n| $7\\sim 8$ | $5\\times 10^4$ |$100$  |  |\n|  $9\\sim 10$| $5\\times 10^4$ | $10^9$ |  |", "locale": "zh-CN"}}}
{"pid": "P3770", "type": "P", "difficulty": 6, "samples": [["5\n3344\n2", "10\n1\n2"], ["500000\n4545\n234567", "999992\n246922\n753067"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "Special Judge", "枚举", "前缀和", "CTSC/CTS"], "title": "[CTSC2017] 密钥", "background": "", "description": "一个密钥是一个长度为 n = 2k + 1 的字符串，它包含 1 个字母 X、k 个字母 A 和k 个字母 B。例如 k = 3 时，BAXABAB 就是一个密钥。\n\n如下图所示，可以按顺时针顺序把这 2k+1 个字母排成一个圈：\n\n ![](https://cdn.luogu.com.cn/upload/pic/5481.png) \n\n在 k 个字母 A 中，有一部分可以定义为 “强的’’。具体来说，从 X 出发顺时针走到某个 A 时，如果途中 A 的数目**严格多于**B的数目，则称此字母 A 为强的。\n\n对于上面的例子来说，顺时针方向从字母 X 数起第 1 个和第 2 个字母 A 是强的，而第 3 个字母 A 不是强的。\n\n一个密钥的**特征值**就是其中包含的强的字母 A 的个数。\n\n天才小朋友 KT 给出了一个结论：\n\n假设 k 个字母 A 所在的位置已经固定，但是剩下的 k 个 B 和 1 个 X 的位置是未知的。（注意，满足这样要求的密钥一共有 k + 1 个，因为字母 X 还剩下 k + 1 个可能的位置。）\n\n可以证明：所有这 k + 1 个可能的密钥的特征值是各不相同的，它们恰好为0, 1, 2, …, k。\n\n下面的图是一个具体的示例，从左到右的四个子图中分别有 3 个，2 个，1 个，0个字母 A 是强的。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5482.png) \n\n类似地，如果固定 k 个字母 B 的位置，那满足条件的所有 k + 1 个密钥的特征值也各不相同，恰好为 0, 1, …, k。\n\n现在你需要解决以下三个问题：\n\n1. 给定密钥中所有 A 的位置，当密钥的特征值为 0 时，请问 X 在哪个位置。\n\n2. 给定密钥中所有 A 的位置，当密钥的特征值为 S 时，请问 X 在哪个位置。\n\n3. 给定密钥中所有 B 的位置，当密钥的特征值为 S 时，请问 X 在哪个位置。\n\n注意：字符串的 2k + 1 个字母的位置由 1 到 2k + 1 编号。\n\n\n【例子 1】\n\n假定 k = 3, S = 2。那么：\n\n当 A 的位置是 {2,4,6} 且特征值为 0 时，X 的位置在 7；\n\n当 A 的位置是 {2,4,6} 且特征值为 2 时，X 的位置在 3；\n\n当 B 的位置是 {2,4,6} 且特征值为 2 时，X 的位置在 5。\n\n【例子 2】\n\n假定 k=9。S=7。那么：\n\n当 A 的位置是 {3,4,5,9,10,12,13,16,19} 且特征值为 0 时，X 的位置在 14；\n\n当 A 的位置是 {3,4,5,9,10,12,13,16,19} 且特征值为 7 时，X 的位置在 18；\n\n当 B 的位置是 {3,4,5,9,10,12,13,16,19} 且特征值为 7 时，X 的位置在 17。\n", "inputFormat": "只包含一组测试数据。\n\n第一行包含一个整数 k，意义如题所述。\n\n第二行包含一个整数 seed，这个数将用于生成一个 k 元集合 P。\n\n第三行包含一个整数 S，意义如题所述。\n\n保证 0 ≤ S ≤ k ≤ 10^7。1 ≤ seed ≤ 10000。\n\n在 cipher/下，包含两个用于生成输入数据的文件 cipher.cpp/pas。其中读入部分已经完成，在数组 p[] 中，若 p[i] = 0，表示 i 不属于集合 P，否则，i 属于集合P。\n\n[百度网盘链接>>   密码：9vr3](http://pan.baidu.com/s/1i55NdWx) 请自行编译\n\n```cpp\n#include <stdio.h>\n#include <string.h>\nint p[20000005];\nint seed, n, k, S;\nint getrand() {\n\tseed = ((seed * 12321) ^ 9999) % 32768;\n\treturn seed;\n}\nvoid generateData() {\n\tscanf( \"%d%d%d\", &k, &seed, &S );\n\tint t = 0;\n\tn = k * 2 + 1;\n\tmemset(p, 0, sizeof(p));\n\tfor( int i = 1; i <= n; ++i ) {\n\t\tp[i] = (getrand() / 128) % 2;\n\t\tt += p[i];\n\t}\n\tint i = 1;\n\twhile( t > k ) {\n\t\twhile ( p[i] == 0 ) ++i;\n\t\tp[i] = 0;\n\t\t--t;\n\t}\n\twhile( t < k ) {\n\t\twhile( p[i] == 1 ) ++i;\n\t\tp[i] = 1;\n\t\t++t;\n\t}\n}\nint main() {\n\tgenerateData();\n\treturn 0;\n}\n```\n", "outputFormat": "输出三行，每行一个数，依次对应问题描述中的三个子问题的答案。\n\n即：\n1. 第一个数表示当 k 元集合 P 代表 A 的位置且特征值为 0 时 X 的位置。\n\n2. 第二个数表示当 k 元集合 P 代表 A 的位置且特征值为 S 时 X 的位置。\n\n3. 第三个数表示当 k 元集合 P 代表 B 的位置且特征值为 S 时 X 的位置。\n", "hint": "【样例解释】\n\n第一个样例中, P 数组为 1 的元素的下标分别为 5, 6, 7, 8, 9。\n\n\n【数据范围与约定】\n\n对于 30% 的数据，k ≤ 10^3。\n\n对于 50% 的数据，k ≤ 10^5。\n\n对于 100% 的数据，k ≤ 10^7。\n\n对于每个测试点, 得分为以下三部分得分之和：\n\n1. 如果第一问回答正确，你将获得 3 分。\n\n2. 如果第二问回答正确，你将获得 4 分。\n\n3. 如果第三问回答正确，你将获得 3 分。\n\n**如果你仅仅知道部分答案，请也务必按此格式要求输出三个数。否则你可能会因格式错误无法得分。**\n", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2017] Key", "background": "", "description": "A key is a string of length $n = 2k + 1$ that contains 1 letter X, $k$ letters A, and $k$ letters B. For example, when $k = 3$, BAXABAB is a key.\n\nAs shown in the figure below, these $2k + 1$ letters can be arranged in a circle in clockwise order:\n\n ![](https://cdn.luogu.com.cn/upload/pic/5481.png) \n\nAmong the $k$ letters A, some can be defined as \"strong\". Specifically, starting from X and walking clockwise to some A, if along the way the number of A is strictly greater than the number of B, then that letter A is called strong.\n\nIn the above example, the 1st and 2nd letters A counted clockwise from X are strong, while the 3rd letter A is not strong.\n\nThe characteristic value of a key is the number of strong letters A it contains.\n\nThe genius child KT gave the following result:\n\nAssume the positions of the $k$ letters A are fixed, but the positions of the remaining $k$ letters B and 1 letter X are unknown. (Note that there are exactly $k + 1$ keys that meet this condition, because X still has $k + 1$ possible positions.)\n\nIt can be proved that the characteristic values of all these $k + 1$ possible keys are pairwise distinct and are exactly $0, 1, 2, \\dots, k$.\n\nThe following figure is a concrete example. From left to right, the four sub-figures have 3, 2, 1, and 0 strong letters A, respectively.\n\n ![](https://cdn.luogu.com.cn/upload/pic/5482.png) \n\nSimilarly, if the positions of the $k$ letters B are fixed, then the characteristic values of all $k + 1$ keys that meet the condition are also pairwise distinct and are exactly $0, 1, \\dots, k$.\n\nNow you need to solve the following three problems:\n\n1. Given the positions of all A in the key, when the characteristic value is $0$, where is X located?\n2. Given the positions of all A in the key, when the characteristic value is $S$, where is X located?\n3. Given the positions of all B in the key, when the characteristic value is $S$, where is X located?\n\nNote: The positions of the $2k + 1$ letters of the string are numbered from $1$ to $2k + 1$.\n\n[Example 1]\n\nAssume $k = 3$, $S = 2$. Then:\n\n- When the positions of A are {2, 4, 6} and the characteristic value is $0$, the position of X is $7$.\n- When the positions of A are {2, 4, 6} and the characteristic value is $2$, the position of X is $3$.\n- When the positions of B are {2, 4, 6} and the characteristic value is $2$, the position of X is $5$.\n\n[Example 2]\n\nAssume $k = 9$, $S = 7$. Then:\n\n- When the positions of A are {3, 4, 5, 9, 10, 12, 13, 16, 19} and the characteristic value is $0$, the position of X is $14$.\n- When the positions of A are {3, 4, 5, 9, 10, 12, 13, 16, 19} and the characteristic value is $7$, the position of X is $18$.\n- When the positions of B are {3, 4, 5, 9, 10, 12, 13, 16, 19} and the characteristic value is $7$, the position of X is $17$.", "inputFormat": "There is only one set of testdata.\n\nThe first line contains an integer $k$, as described above.\n\nThe second line contains an integer seed, which will be used to generate a $k$-element set $P$.\n\nThe third line contains an integer $S$, as described above.\n\nIt is guaranteed that $0 \\le S \\le k \\le 10^7$. $1 \\le \\text{seed} \\le 10000$.\n\nUnder cipher/, there are two files for generating the input data, cipher.cpp/pas. The reading part has been completed. In the array $p[]$, if $p[i] = 0$, it means $i$ is not in set $P$; otherwise, $i$ is in set $P$.\n\n[Baidu Netdisk link>>   Password: 9vr3](http://pan.baidu.com/s/1i55NdWx) Please compile it yourself.\n\n```cpp\n#include <stdio.h>\n#include <string.h>\nint p[20000005];\nint seed, n, k, S;\nint getrand() {\n\tseed = ((seed * 12321) ^ 9999) % 32768;\n\treturn seed;\n}\nvoid generateData() {\n\tscanf( \"%d%d%d\", &k, &seed, &S );\n\tint t = 0;\n\tn = k * 2 + 1;\n\tmemset(p, 0, sizeof(p));\n\tfor( int i = 1; i <= n; ++i ) {\n\t\tp[i] = (getrand() / 128) % 2;\n\t\tt += p[i];\n\t}\n\tint i = 1;\n\twhile( t > k ) {\n\t\twhile ( p[i] == 0 ) ++i;\n\t\tp[i] = 0;\n\t\t--t;\n\t}\n\twhile( t < k ) {\n\t\twhile( p[i] == 1 ) ++i;\n\t\tp[i] = 1;\n\t\t++t;\n\t}\n}\nint main() {\n\tgenerateData();\n\treturn 0;\n}\n```", "outputFormat": "Output three lines, one number per line, corresponding to the answers to the three subproblems in the description.\n\nThat is:\n1. The first number indicates the position of X when the $k$-element set $P$ represents the positions of A and the characteristic value is $0$.\n2. The second number indicates the position of X when the $k$-element set $P$ represents the positions of A and the characteristic value is $S$.\n3. The third number indicates the position of X when the $k$-element set $P$ represents the positions of B and the characteristic value is $S$.", "hint": "[Sample Explanation]\n\nIn the first sample, the indices of elements where array $P$ is $1$ are $5, 6, 7, 8, 9$.\n\n[Constraints and Conventions]\n\n- For 30% of the testdata, $k \\le 10^3$.\n- For 50% of the testdata, $k \\le 10^5$.\n- For 100% of the testdata, $k \\le 10^7$.\n\nFor each test point, the score is the sum of the following three parts:\n\n1. If you answer the first question correctly, you will get 3 points.\n2. If you answer the second question correctly, you will get 4 points.\n3. If you answer the third question correctly, you will get 3 points.\n\nIf you only know part of the answers, please still output three numbers in this required format. Otherwise, you may lose points due to formatting errors.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2017] 密钥", "background": "", "description": "一个密钥是一个长度为 n = 2k + 1 的字符串，它包含 1 个字母 X、k 个字母 A 和k 个字母 B。例如 k = 3 时，BAXABAB 就是一个密钥。\n\n如下图所示，可以按顺时针顺序把这 2k+1 个字母排成一个圈：\n\n ![](https://cdn.luogu.com.cn/upload/pic/5481.png) \n\n在 k 个字母 A 中，有一部分可以定义为 “强的’’。具体来说，从 X 出发顺时针走到某个 A 时，如果途中 A 的数目**严格多于**B的数目，则称此字母 A 为强的。\n\n对于上面的例子来说，顺时针方向从字母 X 数起第 1 个和第 2 个字母 A 是强的，而第 3 个字母 A 不是强的。\n\n一个密钥的**特征值**就是其中包含的强的字母 A 的个数。\n\n天才小朋友 KT 给出了一个结论：\n\n假设 k 个字母 A 所在的位置已经固定，但是剩下的 k 个 B 和 1 个 X 的位置是未知的。（注意，满足这样要求的密钥一共有 k + 1 个，因为字母 X 还剩下 k + 1 个可能的位置。）\n\n可以证明：所有这 k + 1 个可能的密钥的特征值是各不相同的，它们恰好为0, 1, 2, …, k。\n\n下面的图是一个具体的示例，从左到右的四个子图中分别有 3 个，2 个，1 个，0个字母 A 是强的。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5482.png) \n\n类似地，如果固定 k 个字母 B 的位置，那满足条件的所有 k + 1 个密钥的特征值也各不相同，恰好为 0, 1, …, k。\n\n现在你需要解决以下三个问题：\n\n1. 给定密钥中所有 A 的位置，当密钥的特征值为 0 时，请问 X 在哪个位置。\n\n2. 给定密钥中所有 A 的位置，当密钥的特征值为 S 时，请问 X 在哪个位置。\n\n3. 给定密钥中所有 B 的位置，当密钥的特征值为 S 时，请问 X 在哪个位置。\n\n注意：字符串的 2k + 1 个字母的位置由 1 到 2k + 1 编号。\n\n\n【例子 1】\n\n假定 k = 3, S = 2。那么：\n\n当 A 的位置是 {2,4,6} 且特征值为 0 时，X 的位置在 7；\n\n当 A 的位置是 {2,4,6} 且特征值为 2 时，X 的位置在 3；\n\n当 B 的位置是 {2,4,6} 且特征值为 2 时，X 的位置在 5。\n\n【例子 2】\n\n假定 k=9。S=7。那么：\n\n当 A 的位置是 {3,4,5,9,10,12,13,16,19} 且特征值为 0 时，X 的位置在 14；\n\n当 A 的位置是 {3,4,5,9,10,12,13,16,19} 且特征值为 7 时，X 的位置在 18；\n\n当 B 的位置是 {3,4,5,9,10,12,13,16,19} 且特征值为 7 时，X 的位置在 17。\n", "inputFormat": "只包含一组测试数据。\n\n第一行包含一个整数 k，意义如题所述。\n\n第二行包含一个整数 seed，这个数将用于生成一个 k 元集合 P。\n\n第三行包含一个整数 S，意义如题所述。\n\n保证 0 ≤ S ≤ k ≤ 10^7。1 ≤ seed ≤ 10000。\n\n在 cipher/下，包含两个用于生成输入数据的文件 cipher.cpp/pas。其中读入部分已经完成，在数组 p[] 中，若 p[i] = 0，表示 i 不属于集合 P，否则，i 属于集合P。\n\n[百度网盘链接>>   密码：9vr3](http://pan.baidu.com/s/1i55NdWx) 请自行编译\n\n```cpp\n#include <stdio.h>\n#include <string.h>\nint p[20000005];\nint seed, n, k, S;\nint getrand() {\n\tseed = ((seed * 12321) ^ 9999) % 32768;\n\treturn seed;\n}\nvoid generateData() {\n\tscanf( \"%d%d%d\", &k, &seed, &S );\n\tint t = 0;\n\tn = k * 2 + 1;\n\tmemset(p, 0, sizeof(p));\n\tfor( int i = 1; i <= n; ++i ) {\n\t\tp[i] = (getrand() / 128) % 2;\n\t\tt += p[i];\n\t}\n\tint i = 1;\n\twhile( t > k ) {\n\t\twhile ( p[i] == 0 ) ++i;\n\t\tp[i] = 0;\n\t\t--t;\n\t}\n\twhile( t < k ) {\n\t\twhile( p[i] == 1 ) ++i;\n\t\tp[i] = 1;\n\t\t++t;\n\t}\n}\nint main() {\n\tgenerateData();\n\treturn 0;\n}\n```\n", "outputFormat": "输出三行，每行一个数，依次对应问题描述中的三个子问题的答案。\n\n即：\n1. 第一个数表示当 k 元集合 P 代表 A 的位置且特征值为 0 时 X 的位置。\n\n2. 第二个数表示当 k 元集合 P 代表 A 的位置且特征值为 S 时 X 的位置。\n\n3. 第三个数表示当 k 元集合 P 代表 B 的位置且特征值为 S 时 X 的位置。\n", "hint": "【样例解释】\n\n第一个样例中, P 数组为 1 的元素的下标分别为 5, 6, 7, 8, 9。\n\n\n【数据范围与约定】\n\n对于 30% 的数据，k ≤ 10^3。\n\n对于 50% 的数据，k ≤ 10^5。\n\n对于 100% 的数据，k ≤ 10^7。\n\n对于每个测试点, 得分为以下三部分得分之和：\n\n1. 如果第一问回答正确，你将获得 3 分。\n\n2. 如果第二问回答正确，你将获得 4 分。\n\n3. 如果第三问回答正确，你将获得 3 分。\n\n**如果你仅仅知道部分答案，请也务必按此格式要求输出三个数。否则你可能会因格式错误无法得分。**\n", "locale": "zh-CN"}}}
{"pid": "P3771", "type": "P", "difficulty": 7, "samples": [["7 1\n1 2 1\n2 3 1\n3 4 1\n4 5 1\n5 6 1\n6 7 1\n0 0", "3"], ["6 26\n1 2 66\n2 3 11\n3 4 73\n2 5 77\n3 6 33\n10 47\n1 2 86\n2 3 69\n3 4 41\n4 5 26\n5 6 41\n2 7 73\n3 8 77\n4 9 2\n5 10 65\n0 0", "143\n232"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "CTSC/CTS"], "title": "[CTSC2017] 网络", "background": null, "description": "一个一般的网络系统可以被描述成一张无向连通图。图上的每个节点为一个服务器，连接服务器与服务器的数据线则看作图上的一条边，边权为该数据线的长度。两个服务器之间的通讯距离定义为其对应节点之间最短路的长度。\n\n现在，考虑一个当前图结构为树的网络系统。你作为该网络系统的管理员，被要求在这个系统中新加入一条给定长度的数据线。数据线可以连在任意两个服务器上。你的任务是，求出在所有合法的方案中，通讯距离最远的两个服务器之间的最小距离。", "inputFormat": "输入包含多组数据。对于每组数据，输入的第一行包含二个正整数 $N,L$，其中 $N$ 表示服务器个数，$L$ 为新加入数据线的长度。\n\n接下来 $n-1$ 行，第 $i$ 行有三个正整数 $a_i, b_i, l_i$，表示有一条长度为 $l_i$ 的数据线连接服务器 $a_i,b_i$。服务器的编号为 $1\\sim N$。\n\n输入的末尾以 `0 0` 作为结束。", "outputFormat": "对于每组数据，输出一行一个整数，描述在所有合法的方案中，通讯距离最远的两个服务器之间的最小距离。", "hint": "一共有 $20$ 个测试点。编号为 $1 \\sim 20$。每个测试点为 $5$ 分。\n\n保证在任一测试点中，数据的组数不会超过 $15$，且所有数据的 $N$ 之和不超过数据范围中标明的 $N$ 的最大值的 $5$ 倍。\n\n保证所有的输入数据均为不超过 $2^{31} − 1$ 的非负整数，保证 $N \\geq 1$。\n\n保证数据合法。\n\n对于给定的测试点，其限制条件如下表所示。\n\n![](https://cdn.luogu.com.cn/upload/pic/5483.png)", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2017] Network", "background": "", "description": "A general network system can be described as an undirected connected graph. Each node is a server; each edge represents a data cable connecting two servers, and the edge weight equals the length of that cable. The communication distance between two servers is defined as the length of the shortest path between their corresponding nodes.\n\nNow consider a network system whose current graph structure is a tree. As the administrator of this network system, you are required to add one new data cable of a given length to this system. The cable can connect any two servers. Your task is to find, among all valid plans, the minimum possible distance between the farthest pair of servers.", "inputFormat": "The input contains multiple test cases. For each test case, the first line contains two positive integers $N, L$, where $N$ is the number of servers and $L$ is the length of the new data cable.\n\nThe next $N - 1$ lines, the $i$-th line contains three positive integers $a_i, b_i, l_i$, indicating there is a data cable of length $l_i$ connecting servers $a_i$ and $b_i$. Servers are numbered $1 \\sim N$.\n\nThe input ends with `0 0`.", "outputFormat": "For each test case, output one line with a single integer: the minimum possible distance between the farthest pair of servers over all valid plans.", "hint": "There are $20$ test points, numbered $1 \\sim 20$. Each test point is worth $5$ points.\n\nIt is guaranteed that, within any single test point, the number of groups of testdata does not exceed $15$, and the sum of $N$ over all testdata does not exceed $5$ times the maximum $N$ specified in Constraints.\n\nAll input numbers are non-negative integers not exceeding $2^{31} - 1$, and $N \\geq 1$.\n\nAll testdata are valid.\n\nFor the given test points, their constraints are shown in the table below.\n\n![](https://cdn.luogu.com.cn/upload/pic/5483.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2017] 网络", "background": null, "description": "一个一般的网络系统可以被描述成一张无向连通图。图上的每个节点为一个服务器，连接服务器与服务器的数据线则看作图上的一条边，边权为该数据线的长度。两个服务器之间的通讯距离定义为其对应节点之间最短路的长度。\n\n现在，考虑一个当前图结构为树的网络系统。你作为该网络系统的管理员，被要求在这个系统中新加入一条给定长度的数据线。数据线可以连在任意两个服务器上。你的任务是，求出在所有合法的方案中，通讯距离最远的两个服务器之间的最小距离。", "inputFormat": "输入包含多组数据。对于每组数据，输入的第一行包含二个正整数 $N,L$，其中 $N$ 表示服务器个数，$L$ 为新加入数据线的长度。\n\n接下来 $n-1$ 行，第 $i$ 行有三个正整数 $a_i, b_i, l_i$，表示有一条长度为 $l_i$ 的数据线连接服务器 $a_i,b_i$。服务器的编号为 $1\\sim N$。\n\n输入的末尾以 `0 0` 作为结束。", "outputFormat": "对于每组数据，输出一行一个整数，描述在所有合法的方案中，通讯距离最远的两个服务器之间的最小距离。", "hint": "一共有 $20$ 个测试点。编号为 $1 \\sim 20$。每个测试点为 $5$ 分。\n\n保证在任一测试点中，数据的组数不会超过 $15$，且所有数据的 $N$ 之和不超过数据范围中标明的 $N$ 的最大值的 $5$ 倍。\n\n保证所有的输入数据均为不超过 $2^{31} − 1$ 的非负整数，保证 $N \\geq 1$。\n\n保证数据合法。\n\n对于给定的测试点，其限制条件如下表所示。\n\n![](https://cdn.luogu.com.cn/upload/pic/5483.png)", "locale": "zh-CN"}}}
{"pid": "P3772", "type": "P", "difficulty": 7, "samples": [["3 3 A\n0.3\n0.5 0.2\n0.9 0.8\nadd 1 1\nadd 3 0\ndel 1", "2.350000\n1.333333\n0.432749"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "线段树", "Special Judge", "CTSC/CTS"], "title": "[CTSC2017] 游戏", "background": null, "description": "小 R 和室友小 B 在寝室里玩游戏。他们一共玩了 n 局游戏，每局游戏的结果要么是小 R 获胜，要么是小 B 获胜。\n\n第 1 局游戏小 R 获胜的概率是 $p_1$，小 B 获胜的概率是 $1-p_1$。除了第一局游戏之外，每一局游戏小 R 获胜的概率与上一局游戏小 R 是否获胜有关。\n\n具体来说：\n\n1. 如果第 $i − 1$（$1 < i ≤ n$）局游戏小 R 获胜，那么第 $i$ 局游戏小 R 获胜的概率为 $p_i$，小 B 获胜的概率为 $1 − p_i$。\n\n2. 如果第 $i − 1$（$1 < i ≤ n$）局游戏小 B 获胜，那么第 $i$ 局游戏小 R 获胜的概率为 $q_i$，小 B 获胜的概率为 $1 − q_i$。\n\n小 D 时常过来看小 R 和小 B 玩游戏，因此他知道某几局游戏的结果。他想知道在他已知信息的条件下，小 R 在 $n$ 局游戏中总共获胜的局数的期望是多少。\n\n小 D 记性不太好，有时他会回忆起某局游戏的结果，并把它加入到已知信息中；\n\n有时他会忘记之前某局游戏结果，并把它从已知信息中删除。你的任务是：每当小 D 在已知信息中增加或删除一条信息时，根据小 D 记得的已知信息，帮助小 D 计算小 R 在 $n$ 局游戏中总共获胜局数的期望是多少。\n\n需要注意的是：如果小 D 忘了一局游戏的结果，之后又重新记起，两次记忆中的游戏结果不一定是相同的。你不需要关心小 D 的记忆是否与实际情况相符，你只需要根据他的记忆计算相应的答案。", "inputFormat": "第一行两个正整数 $n, m$ 和一个字符串 $\\textrm{type}$。表示小 R 和小 B 一共玩了 $n$ 局游戏，\n\n小 D 一共进行了 $m$ 次修改已知信息的操作，该数据的类型为 $\\textrm{type}$。$\\textrm{type}$ 字符串是为了能让大家更方便地获得部分分，你可能不需要用到这个输入，其具体含义见【限制与约定】。\n\n接下来 $n$ 行，第 1 行包含一个实数 $p_1$，表示第一局比赛小 R 获胜的概率是 $p_1$。第 $i$（$1 < i ≤ n$）行包含两个实数 $p_i, q_i$。表示在第 $i − 1$ 局游戏小 R 获胜的情况下，第 $i$ 局游戏小 R 获胜的概率是 $p_i$；$q_i$ 表示在第 $i − 1$ 局游戏小 B 获胜的情况下，第 $i$ 局游戏小 R 获胜的概率是 $q_i$。\n\n接下来 $m$ 行，每行描述一个小 D 已知信息的变化，操作分为两类。\n\n1. `add i c` 表示小 D 回忆起了第 $i$ 局比赛的结果，并把它加入到已知信息中。若 $c = 0$ 表示第 $i$ 局比赛小 B 获胜，若 $c = 1$ 表示第 $i$ 局比赛小 R 获胜。数据保证 $i, c$ 均为整数且 $1 ≤ i ≤ n, 0 ≤ c ≤ 1$，如果这个操作不是第一个操作，保证在上一个操作结束后的已知信息中没有第 $i$ 局比赛的结果。\n\n2. `del i` 表示小 D 忘记了第 $i$ 局比赛的结果，并把它从已知信息中删除。数据保证 $i$ 是整数且 $1 ≤ i ≤ n$，保证在上一个操作结束后的已知信息中有第 $i$ 局比赛的结果。", "outputFormat": "对于每个操作，输出一行实数，表示操作结束后，在当前已知信息的条件下，小 R 在 $n$ 局游戏中总共获胜的局数的期望是多少。", "hint": "【评分标准】\n\n如果你的答案与正确答案的绝对误差在 $10^{-4}$ 以内，则被判定为正确。\n\n如果你的所有答案均为正确，则得满分，否则得 $0$ 分。\n\n请注意输出格式：每行输出一个答案，答案只能为一个实数。每行的长度不得超过 $50$。错误输出格式会被判定为 $0$ 分。\n\n\n【限制与约定】\n\n对于 $100\\%$ 的数据，$1 ≤ n ≤ 200000$，$1 ≤ m ≤ 200000$，$0 < p_i, q_i < 1$。\n\n对于 $100\\%$ 的数据，输入保留最多四位小数。\n\n本题共有 $20$ 个数据点，每个数据点 $5$ 分, 每个测试点的具体约定如下表：\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/5484.png) \n\n【小 R 教你学数学】\n\n你可. 能. 会用到以下公式\n\n1. 条件概率的计算方法\n\n我们记 $p(A|B)$ 表示在已知事件 $B$ 发生时事件 $A$ 发生的概率，条件概率可以用以下公式计算：\n\n$p(A|B)=\\frac {p(AB)}{p(B)}$\n\n其中 $p(AB)$ 表示事件 $B$ 和事件 $A$ 同时发生的概率，$p(B)$ 表示事件 $B$ 发生的概率。\n\n2. 贝叶斯公式 (bayes)\n\n由条件概率的计算方法，我们容易得到贝叶斯公式\n\n$p(A|B)=\\frac {p(B|A)p(A)}{p(B)}$\n\n3. 全概率公式\n\n如果随机变量 $x$ 有 $k$ 个取值，分别为 $x_1, x_2,\\ldots , x_k$ 那么\n\n$p(A)=\\sum^{k}_{i=1} {p(A|x=x_i)p(x=x_i)}$\n\n ![](https://cdn.luogu.com.cn/upload/pic/5486.png) \n\n【温馨提示】\n\n在本题中，如果你希望获得全部的分数，你可能需要考虑由于浮点数运算引入的误差。只使用加法和乘法运算不会引入太大的误差，但请谨慎使用减法和除法。\n\n1. 两个大小相近的数相减可以引入非常大的相对误差。\n\n2. 如果一个矩阵的行列式值非常小，那么求解该矩阵的逆可以带来相当大的误差。\n\n当然，如果你的算法在数学上是正确的，但没有考虑浮点数运算的误差问题，可能仍然可以获得一部分的分数。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2017] Game", "background": "", "description": "Xiao R and his roommate Xiao B are playing a game in their dorm. They play a total of $n$ games, and each game ends with either Xiao R winning or Xiao B winning.\n\nIn game 1, the probability that Xiao R wins is $p_1$, and the probability that Xiao B wins is $1 - p_1$. Except for the first game, in each game the probability that Xiao R wins depends on whether Xiao R won the previous game.\n\nSpecifically:\n\n1. If in game $i − 1$ ($1 < i ≤ n$) Xiao R won, then in game $i$ the probability that Xiao R wins is $p_i$, and the probability that Xiao B wins is $1 − p_i$.\n\n2. If in game $i − 1$ ($1 < i ≤ n$) Xiao B won, then in game $i$ the probability that Xiao R wins is $q_i$, and the probability that Xiao B wins is $1 − q_i$.\n\nXiao D often comes to watch Xiao R and Xiao B play, so he knows the outcomes of some games. He wants to know, under the information he currently knows, what the expected total number of games won by Xiao R is among the $n$ games.\n\nXiao D does not have a good memory: sometimes he recalls the outcome of some game and adds it to his known information; sometimes he forgets a previously remembered outcome and removes it from his known information. Your task is: whenever Xiao D adds or deletes one piece of information, compute, based on Xiao D’s current known information, the expected total number of games won by Xiao R among the $n$ games.\n\nNote: If Xiao D forgets the result of a game and later recalls it again, the two remembered outcomes are not necessarily the same. You do not need to care whether his memory matches the actual situation; you only need to compute the answers according to his memory.", "inputFormat": "The first line contains two positive integers $n, m$ and a string $\\textrm{type}$. They indicate that Xiao R and Xiao B play $n$ games in total, Xiao D performs $m$ operations of modifying his known information, and the data is of type $\\textrm{type}$. The string $\\textrm{type}$ is provided to help obtain partial scores; you may not need this input. See [Constraints] for its meaning.\n\nThe next $n$ lines: the 1st line contains a real number $p_1$, meaning that in the first game the probability that Xiao R wins is $p_1$. Line $i$ ($1 < i ≤ n$) contains two real numbers $p_i, q_i$. Here, $p_i$ means that if Xiao R won game $i − 1$, then in game $i$ the probability that Xiao R wins is $p_i$; $q_i$ means that if Xiao B won game $i − 1$, then in game $i$ the probability that Xiao R wins is $q_i$.\n\nThe next $m$ lines each describe one change to Xiao D’s known information. There are two types of operations.\n\n1. `add i c` means Xiao D recalls the outcome of game $i$ and adds it to his known information. If $c = 0$ it means Xiao B won game $i$; if $c = 1$ it means Xiao R won game $i$. It is guaranteed that $i, c$ are integers with $1 ≤ i ≤ n, 0 ≤ c ≤ 1$. If this is not the first operation, it is guaranteed that after the previous operation the known information does not contain the result of game $i$.\n\n2. `del i` means Xiao D forgets the outcome of game $i$ and removes it from his known information. It is guaranteed that $i$ is an integer with $1 ≤ i ≤ n$, and that after the previous operation the known information contains the result of game $i$.", "outputFormat": "For each operation, output one real number on a single line: after the operation, under the current known information, the expected total number of games won by Xiao R among the $n$ games.", "hint": "[Scoring]\n\nYour answer is judged correct if its absolute error from the correct answer is within $10^{-4}$.\n\nYou receive full score only if all your answers are correct; otherwise you receive $0$ points.\n\nPlease note the output format: output exactly one answer per line, and each answer must be a single real number. The length of each line must not exceed $50$. Wrong output formats will be judged as $0$ points.\n\n[Constraints]\n\nFor $100\\%$ of the data, $1 ≤ n ≤ 200000$, $1 ≤ m ≤ 200000$, $0 < p_i, q_i < 1$.\n\nFor $100\\%$ of the data, input values have at most four decimal places.\n\nThere are $20$ test data points in total, each worth $5$ points. The specific assumptions for each test point are shown in the table below:\n\n![](https://cdn.luogu.com.cn/upload/pic/5484.png) \n\n[Xiao R teaches you math]\n\nYou may use the following formulas.\n\n1. Conditional probability\n\nWe write $p(A|B)$ to denote the probability that event $A$ occurs given that event $B$ occurs. Conditional probability can be computed by:\n$p(A|B)=\\frac {p(AB)}{p(B)}$\nwhere $p(AB)$ denotes the probability that both event $B$ and event $A$ occur, and $p(B)$ denotes the probability that event $B$ occurs.\n\n2. Bayes’ formula (Bayes)\n\nFrom conditional probability, we can derive Bayes’ formula:\n$p(A|B)=\\frac {p(B|A)p(A)}{p(B)}$\n\n3. Law of total probability\n\nIf a random variable $x$ has $k$ possible values, namely $x_1, x_2,\\ldots , x_k$, then\n$p(A)=\\sum^{k}_{i=1} {p(A|x=x_i)p(x=x_i)}$\n\n![](https://cdn.luogu.com.cn/upload/pic/5486.png) \n\n[Warm reminder]\n\nIn this problem, if you want to get full score, you may need to consider errors introduced by floating-point arithmetic. Using only addition and multiplication will not introduce large errors, but please be cautious with subtraction and division.\n\n1. Subtracting two numbers that are close in value can introduce very large relative error.\n\n2. If the determinant of a matrix is very small, computing the inverse of that matrix can introduce considerable error.\n\nOf course, even if your algorithm is mathematically correct but does not consider floating-point errors, you may still obtain partial scores.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2017] 游戏", "background": null, "description": "小 R 和室友小 B 在寝室里玩游戏。他们一共玩了 n 局游戏，每局游戏的结果要么是小 R 获胜，要么是小 B 获胜。\n\n第 1 局游戏小 R 获胜的概率是 $p_1$，小 B 获胜的概率是 $1-p_1$。除了第一局游戏之外，每一局游戏小 R 获胜的概率与上一局游戏小 R 是否获胜有关。\n\n具体来说：\n\n1. 如果第 $i − 1$（$1 < i ≤ n$）局游戏小 R 获胜，那么第 $i$ 局游戏小 R 获胜的概率为 $p_i$，小 B 获胜的概率为 $1 − p_i$。\n\n2. 如果第 $i − 1$（$1 < i ≤ n$）局游戏小 B 获胜，那么第 $i$ 局游戏小 R 获胜的概率为 $q_i$，小 B 获胜的概率为 $1 − q_i$。\n\n小 D 时常过来看小 R 和小 B 玩游戏，因此他知道某几局游戏的结果。他想知道在他已知信息的条件下，小 R 在 $n$ 局游戏中总共获胜的局数的期望是多少。\n\n小 D 记性不太好，有时他会回忆起某局游戏的结果，并把它加入到已知信息中；\n\n有时他会忘记之前某局游戏结果，并把它从已知信息中删除。你的任务是：每当小 D 在已知信息中增加或删除一条信息时，根据小 D 记得的已知信息，帮助小 D 计算小 R 在 $n$ 局游戏中总共获胜局数的期望是多少。\n\n需要注意的是：如果小 D 忘了一局游戏的结果，之后又重新记起，两次记忆中的游戏结果不一定是相同的。你不需要关心小 D 的记忆是否与实际情况相符，你只需要根据他的记忆计算相应的答案。", "inputFormat": "第一行两个正整数 $n, m$ 和一个字符串 $\\textrm{type}$。表示小 R 和小 B 一共玩了 $n$ 局游戏，\n\n小 D 一共进行了 $m$ 次修改已知信息的操作，该数据的类型为 $\\textrm{type}$。$\\textrm{type}$ 字符串是为了能让大家更方便地获得部分分，你可能不需要用到这个输入，其具体含义见【限制与约定】。\n\n接下来 $n$ 行，第 1 行包含一个实数 $p_1$，表示第一局比赛小 R 获胜的概率是 $p_1$。第 $i$（$1 < i ≤ n$）行包含两个实数 $p_i, q_i$。表示在第 $i − 1$ 局游戏小 R 获胜的情况下，第 $i$ 局游戏小 R 获胜的概率是 $p_i$；$q_i$ 表示在第 $i − 1$ 局游戏小 B 获胜的情况下，第 $i$ 局游戏小 R 获胜的概率是 $q_i$。\n\n接下来 $m$ 行，每行描述一个小 D 已知信息的变化，操作分为两类。\n\n1. `add i c` 表示小 D 回忆起了第 $i$ 局比赛的结果，并把它加入到已知信息中。若 $c = 0$ 表示第 $i$ 局比赛小 B 获胜，若 $c = 1$ 表示第 $i$ 局比赛小 R 获胜。数据保证 $i, c$ 均为整数且 $1 ≤ i ≤ n, 0 ≤ c ≤ 1$，如果这个操作不是第一个操作，保证在上一个操作结束后的已知信息中没有第 $i$ 局比赛的结果。\n\n2. `del i` 表示小 D 忘记了第 $i$ 局比赛的结果，并把它从已知信息中删除。数据保证 $i$ 是整数且 $1 ≤ i ≤ n$，保证在上一个操作结束后的已知信息中有第 $i$ 局比赛的结果。", "outputFormat": "对于每个操作，输出一行实数，表示操作结束后，在当前已知信息的条件下，小 R 在 $n$ 局游戏中总共获胜的局数的期望是多少。", "hint": "【评分标准】\n\n如果你的答案与正确答案的绝对误差在 $10^{-4}$ 以内，则被判定为正确。\n\n如果你的所有答案均为正确，则得满分，否则得 $0$ 分。\n\n请注意输出格式：每行输出一个答案，答案只能为一个实数。每行的长度不得超过 $50$。错误输出格式会被判定为 $0$ 分。\n\n\n【限制与约定】\n\n对于 $100\\%$ 的数据，$1 ≤ n ≤ 200000$，$1 ≤ m ≤ 200000$，$0 < p_i, q_i < 1$。\n\n对于 $100\\%$ 的数据，输入保留最多四位小数。\n\n本题共有 $20$ 个数据点，每个数据点 $5$ 分, 每个测试点的具体约定如下表：\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/5484.png) \n\n【小 R 教你学数学】\n\n你可. 能. 会用到以下公式\n\n1. 条件概率的计算方法\n\n我们记 $p(A|B)$ 表示在已知事件 $B$ 发生时事件 $A$ 发生的概率，条件概率可以用以下公式计算：\n\n$p(A|B)=\\frac {p(AB)}{p(B)}$\n\n其中 $p(AB)$ 表示事件 $B$ 和事件 $A$ 同时发生的概率，$p(B)$ 表示事件 $B$ 发生的概率。\n\n2. 贝叶斯公式 (bayes)\n\n由条件概率的计算方法，我们容易得到贝叶斯公式\n\n$p(A|B)=\\frac {p(B|A)p(A)}{p(B)}$\n\n3. 全概率公式\n\n如果随机变量 $x$ 有 $k$ 个取值，分别为 $x_1, x_2,\\ldots , x_k$ 那么\n\n$p(A)=\\sum^{k}_{i=1} {p(A|x=x_i)p(x=x_i)}$\n\n ![](https://cdn.luogu.com.cn/upload/pic/5486.png) \n\n【温馨提示】\n\n在本题中，如果你希望获得全部的分数，你可能需要考虑由于浮点数运算引入的误差。只使用加法和乘法运算不会引入太大的误差，但请谨慎使用减法和除法。\n\n1. 两个大小相近的数相减可以引入非常大的相对误差。\n\n2. 如果一个矩阵的行列式值非常小，那么求解该矩阵的逆可以带来相当大的误差。\n\n当然，如果你的算法在数学上是正确的，但没有考虑浮点数运算的误差问题，可能仍然可以获得一部分的分数。", "locale": "zh-CN"}}}
{"pid": "P3773", "type": "P", "difficulty": 6, "samples": [["4\n15\n7\n3\n1", "11"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000]}, "tags": ["2017", "递归", "O2优化", "枚举", "进制", "组合数学", "CTSC/CTS"], "title": "[CTSC2017] 吉夫特", "background": "", "description": "简单的题目，既是礼物，也是毒药。\n\nB 君设计了一道简单的题目，准备作为 gift 送给大家。\n\n输入一个长度为  $n$  的数列  $a_1, a_2, \\cdots , a_n$  问有多少个长度大于等于  $2$  的不上升的子序列满足：\n\n $$\\prod _{i=2}^{k} \\binom{a_{b_{i-1}}}{a_{b_i}} \\bmod 2 = \\binom{a_{b_1}}{a_{b_2}} \\times \\binom{a_{b_2}}{a_{b_3}} \\times \\cdots \\binom{a_{b_{k-1}}}{a_{b_k}} \\bmod 2 > 0$$ \n\n输出这个个数对  $1000000007$  取模的结果。\n\nG 君看到题目后，为大家解释了一些基本概念。\n\n我们选择任意多个整数  $b_i$  满足\n\n $$1 \\leq b_1 < b_2 < \\dots < b_{k-1} < b_k \\leq n$$ \n\n我们称  $a_{b_1}, a_{b_2}, \\cdots, a_{b_k} $  是  $a$  的一个子序列。\n\n如果这个子序列同时还满足\n\n $$a_{b_1} \\geq a_{b_2} \\geq \\cdots \\geq a_{b_{k-1}}\\geq a_{b_k}$$ \n\n我们称这个子序列是不上升的。\n\n组合数  $\\binom {n} {m} $  是从  $n$  个互不相同的元素中取  $m$  个元素的方案数，具体计算方案如下：\n\n $$\\binom {n}{m}=\\frac{n!}{m!(n-m)!}=\\frac{n \\times (n-1) \\times \\cdots \\times 2 \\times 1}{(m \\times (m-1) \\cdots \\times 2 \\times 1)((n-m)\\times(n-m-1)\\times \\cdots \\times 2 \\times 1)}$$ \n\n这里要特别注意，因为我们只考虑不上升子序列，所以在求组合数的过程中，一定满足  $n \\geq m$ ，也就是 $\\binom {a_{b_{i-1}}}{a_{b_i}}$ 中一定有 $a_{b_{i-1}} \\geq a_{b_i}$ 。\n\n我们在这里强调取模  $x \\mod y$  的定义：\n\n $x \\bmod y = x -\\left \\lfloor \\frac{x}{y} \\right \\rfloor \\times y$ \n\n其中  $\\left \\lfloor n \\right \\rfloor$  表示小于等于  $n$  的最大整数。\n\n $x \\bmod 2 > 0$  ，就是在说  $x$  是奇数。\n\n与此同时，经验告诉我们一个长度为  $n$  的序列，子序列个数有  $O(2^n)$  个，所以我们通过对答案取模来避免输出过大。\n\nB 君觉得 G 君说的十分有道理，于是再次强调了这些基本概念。\n\n最后， G 君听说这个题是作为 gift 送给大家，她有一句忠告。\n\n“Vorsicht, Gift!”\n\n“小心. . . . . .剧毒！ ”", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行，每行一个整数，这 $n$ 行中的第 $i$ 行，表示 $a_i$。\n", "outputFormat": "一行一个整数表示答案。\n", "hint": "对于前 $10\\%$ 的测试点，$n \\leq 9$，$1\\leq a_i\\leq 13$。\n\n对于前 $20\\%$ 的测试点，$n\\leq 17$，$1\\leq a_i\\leq 20$。\n\n对于前 $40\\%$ 的测试点，$n\\leq 1911$，$1\\leq a_i\\leq 4000$。\n\n对于前 $70\\%$ 的测试点，$n\\leq 2017$。\n\n对于前 $85\\%$ 的测试点，$n\\leq 100084$。\n\n对于 $100\\%$ 的测试点，$1\\leq n\\leq 211985$，$1\\leq a_i\\leq 233333$。所有的 $a_i$ 互不相同，也就是说不存在 $i, j$ 同时满足 $1\\leq i < j\\leq n$ 和 $a_i = a_j$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2017] Gift", "background": "", "description": "A simple problem, both a gift and a poison.\n\nB designed a simple problem to give as a \"gift\" to everyone.\n\nGiven a sequence of length $n$, $a_1, a_2, \\cdots , a_n$, ask how many non-increasing subsequences of length at least $2$ satisfy:\n $$\\prod _{i=2}^{k} \\binom{a_{b_{i-1}}}{a_{b_i}} \\bmod 2 = \\binom{a_{b_1}}{a_{b_2}} \\times \\binom{a_{b_2}}{a_{b_3}} \\times \\cdots \\binom{a_{b_{k-1}}}{a_{b_k}} \\bmod 2 > 0$$ \nOutput this count modulo $1000000007$.\n\nG, after seeing the problem, explained some basic concepts for everyone.\n\nWe choose any number of integers $b_i$ satisfying\n $$1 \\leq b_1 < b_2 < \\dots < b_{k-1} < b_k \\leq n$$ \nWe call $a_{b_1}, a_{b_2}, \\cdots, a_{b_k}$ a subsequence of $a$.\n\nIf this subsequence also satisfies\n $$a_{b_1} \\geq a_{b_2} \\geq \\cdots \\geq a_{b_{k-1}}\\geq a_{b_k}$$ \nwe call the subsequence non-increasing.\n\nThe binomial coefficient $\\binom {n} {m}$ is the number of ways to choose $m$ elements from $n$ distinct elements, computed as follows:\n $$\\binom {n}{m}=\\frac{n!}{m!(n-m)!}=\\frac{n \\times (n-1) \\times \\cdots \\times 2 \\times 1}{(m \\times (m-1) \\cdots \\times 2 \\times 1)((n-m)\\times(n-m-1)\\times \\cdots \\times 2 \\times 1)}$$ \nNote in particular that since we only consider non-increasing subsequences, it must hold during binomial computation that $n \\geq m$, i.e., in $\\binom {a_{b_{i-1}}}{a_{b_i}}$ we always have $a_{b_{i-1}} \\geq a_{b_i}$.\n\nWe emphasize the definition of $x \\mod y$:\n $x \\bmod y = x -\\left \\lfloor \\frac{x}{y} \\right \\rfloor \\times y$ \nwhere $\\left \\lfloor n \\right \\rfloor$ denotes the greatest integer less than or equal to $n$.\n\n$x \\bmod 2 > 0$ means that $x$ is odd.\n\nMeanwhile, experience tells us that a sequence of length $n$ has $O(2^n)$ subsequences, so we take the answer modulo to avoid an overly large output.\n\nB felt that G’s points were very reasonable and reiterated these basics.\n\nFinally, upon hearing that this problem is a \"gift\" to everyone, G had a piece of advice.\n\n“Vorsicht, Gift!”\n\n“Careful... highly toxic!”", "inputFormat": "The first line contains an integer $n$.\n\nThen follow $n$ lines, each containing one integer. The $i$-th of these $n$ lines is $a_i$.", "outputFormat": "Output a single integer, the answer.", "hint": "For the first $10\\%$ of the test points, $n \\leq 9$, $1\\leq a_i\\leq 13$.\n\nFor the first $20\\%$ of the test points, $n\\leq 17$, $1\\leq a_i\\leq 20$.\n\nFor the first $40\\%$ of the test points, $n\\leq 1911$, $1\\leq a_i\\leq 4000$.\n\nFor the first $70\\%$ of the test points, $n\\leq 2017$.\n\nFor the first $85\\%$ of the test points, $n\\leq 100084$.\n\nFor $100\\%$ of the test points, $1\\leq n\\leq 211985$, $1\\leq a_i\\leq 233333$. All $a_i$ are pairwise distinct, that is, there do not exist $i, j$ such that $1\\leq i < j\\leq n$ and $a_i = a_j$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2017] 吉夫特", "background": "", "description": "简单的题目，既是礼物，也是毒药。\n\nB 君设计了一道简单的题目，准备作为 gift 送给大家。\n\n输入一个长度为  $n$  的数列  $a_1, a_2, \\cdots , a_n$  问有多少个长度大于等于  $2$  的不上升的子序列满足：\n\n $$\\prod _{i=2}^{k} \\binom{a_{b_{i-1}}}{a_{b_i}} \\bmod 2 = \\binom{a_{b_1}}{a_{b_2}} \\times \\binom{a_{b_2}}{a_{b_3}} \\times \\cdots \\binom{a_{b_{k-1}}}{a_{b_k}} \\bmod 2 > 0$$ \n\n输出这个个数对  $1000000007$  取模的结果。\n\nG 君看到题目后，为大家解释了一些基本概念。\n\n我们选择任意多个整数  $b_i$  满足\n\n $$1 \\leq b_1 < b_2 < \\dots < b_{k-1} < b_k \\leq n$$ \n\n我们称  $a_{b_1}, a_{b_2}, \\cdots, a_{b_k} $  是  $a$  的一个子序列。\n\n如果这个子序列同时还满足\n\n $$a_{b_1} \\geq a_{b_2} \\geq \\cdots \\geq a_{b_{k-1}}\\geq a_{b_k}$$ \n\n我们称这个子序列是不上升的。\n\n组合数  $\\binom {n} {m} $  是从  $n$  个互不相同的元素中取  $m$  个元素的方案数，具体计算方案如下：\n\n $$\\binom {n}{m}=\\frac{n!}{m!(n-m)!}=\\frac{n \\times (n-1) \\times \\cdots \\times 2 \\times 1}{(m \\times (m-1) \\cdots \\times 2 \\times 1)((n-m)\\times(n-m-1)\\times \\cdots \\times 2 \\times 1)}$$ \n\n这里要特别注意，因为我们只考虑不上升子序列，所以在求组合数的过程中，一定满足  $n \\geq m$ ，也就是 $\\binom {a_{b_{i-1}}}{a_{b_i}}$ 中一定有 $a_{b_{i-1}} \\geq a_{b_i}$ 。\n\n我们在这里强调取模  $x \\mod y$  的定义：\n\n $x \\bmod y = x -\\left \\lfloor \\frac{x}{y} \\right \\rfloor \\times y$ \n\n其中  $\\left \\lfloor n \\right \\rfloor$  表示小于等于  $n$  的最大整数。\n\n $x \\bmod 2 > 0$  ，就是在说  $x$  是奇数。\n\n与此同时，经验告诉我们一个长度为  $n$  的序列，子序列个数有  $O(2^n)$  个，所以我们通过对答案取模来避免输出过大。\n\nB 君觉得 G 君说的十分有道理，于是再次强调了这些基本概念。\n\n最后， G 君听说这个题是作为 gift 送给大家，她有一句忠告。\n\n“Vorsicht, Gift!”\n\n“小心. . . . . .剧毒！ ”", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行，每行一个整数，这 $n$ 行中的第 $i$ 行，表示 $a_i$。\n", "outputFormat": "一行一个整数表示答案。\n", "hint": "对于前 $10\\%$ 的测试点，$n \\leq 9$，$1\\leq a_i\\leq 13$。\n\n对于前 $20\\%$ 的测试点，$n\\leq 17$，$1\\leq a_i\\leq 20$。\n\n对于前 $40\\%$ 的测试点，$n\\leq 1911$，$1\\leq a_i\\leq 4000$。\n\n对于前 $70\\%$ 的测试点，$n\\leq 2017$。\n\n对于前 $85\\%$ 的测试点，$n\\leq 100084$。\n\n对于 $100\\%$ 的测试点，$1\\leq n\\leq 211985$，$1\\leq a_i\\leq 233333$。所有的 $a_i$ 互不相同，也就是说不存在 $i, j$ 同时满足 $1\\leq i < j\\leq n$ 和 $a_i = a_j$。\n", "locale": "zh-CN"}}}
{"pid": "P3774", "type": "P", "difficulty": 7, "samples": [["11 6\n9 6 3 1 5 12 8 4 2 2 2\n5 1\n7 2\n9 1\n9 2\n11 1\n11 11", "4 \n6 \n5 \n8 \n7\n11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "网络流", "O2优化", "杨表", "CTSC/CTS"], "title": "[CTSC2017] 最长上升子序列", "background": "", "description": "猪小侠最近学习了最长上升子序列的相关知识。对于一个整数序列 $A =(a_1, a_2,\\ldots , a_k)$，定义 $A$ 的子序列为：从 $A$ 中删除若干个元素后（允许不删，也允许将所有 $k$ 个元素都删除），剩下的元素按照原来的顺序所组成的序列。如果这个子序列的元素从左到右严格递增，则称它为 $A$ 的一个上升子序列。其中包含元素数量最多的上升子序列称为 $A$ 的最长上升子序列。例如，$(2, 4, 5, 6)$ 和 $(1, 4, 5, 6)$ 都是 $(2, 1, 1, 4, 7, 5, 6)$ 的最长上升子序列，长度都为 $4$。\n\n现在猪小侠遇到了这样一个问题：给定一个序列 $B_m = (b_1, b_2, \\ldots, b_m)$，设 $C$ 是 $B_m$ 的子序列，且 $C$ 的最长上升子序列的长度不超过 $k$，则 $C$ 的长度最大能是多少？\n\n猪小侠觉得这个问题太简单了，缺乏挑战，他决定提出一个更难的问题。于是他给了你这样一个序列 $B = (b_1, b_2,\\ldots , b_n)$，以及若干次询问。每次询问会给定两个整数 $m$ 和 $k$，你需要对于 $B$ 序列的前 $m$ 个元素构成的序列 $B_m = (b_1, b_2, \\ldots, b_m)$ 和 $k$ 回答上述问题。\n", "inputFormat": "第一行两个整数 $n, q$，其中 $n$ 是序列 $B$ 的长度，$q$ 是询问次数。\n\n第二行是空格隔开的 $n$ 个正整数 $b_1, b_2, \\ldots, b_n$。\n\n接下来 $q$ 行，其中第 $i$ 行包含两个整数 $m_i, k_i$，表示对 $m = m_i, k = k_i$ 进行询问。\n", "outputFormat": "输出共 $q$ 行，按顺序每行一个整数作为回答。\n", "hint": "【样例解释】\n\n询问 $1$：对于序列 $(9,6,3,1,5)$，可以选取子序列 $(9,6,3,1)$，它的最长上升子序列长度为 $1$。\n\n询问 $2$：对于序列 $(9,6,3,1,5,12,8)$，可以选取子序列 $(9,6,3,1,12,8)$，它的最长上升子序列长度为 $2$。\n\n询问 $3$：对于序列 $(9,6,3,1,5,12,8,4,2)$，可以选取子序列 $(9,6,5,4,2)$，它的最长上升子序列长度为 $1$。\n\n询问 $4$：对于序列 $(9,6,3,1,5,12,8,4,2)$，可以选取子序列 $(9,6,3,1,12,8,4,2)$，它的最长上升子序列长度为 $2$。\n\n询问 $5$：对于序列 $(9,6,3,1,5,12,8,4,2,2,2)$，可以选取子序列 $(9,6,5,4,2,2,2)$，它的最长上升子序列长度为 $1$。\n\n询问 $6$：对于序列 $(9,6,3,1,5,12,8,4,2,2,2)$，可以选取子序列 $(9,6,3,1,5,12,8,4,2,2,2)$，它的最长上升子序列长度为 $3$。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/5487.png) \n\n对于 $100\\%$ 的数据， $1\\leq n\\leq 5\\times 10^4$，$1\\leq b_i\\leq 5\\times 10^4$，$1\\leq q \\leq 2\\times 10^5$，$1\\leq k_i \\leq m_i \\leq n$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2017] Longest Increasing Subsequence", "background": "", "description": "Zhu Xiaoxia recently studied the longest increasing subsequence (LIS). For an integer sequence $A =(a_1, a_2,\\ldots , a_k)$, a subsequence of $A$ is defined as the sequence formed by deleting some elements from $A$ (deleting none or all $k$ elements is allowed) while keeping the remaining elements in their original order. If the elements of this subsequence are strictly increasing from left to right, it is called an increasing subsequence of $A$. Among them, an increasing subsequence with the largest number of elements is called a longest increasing subsequence of $A$. For example, $(2, 4, 5, 6)$ and $(1, 4, 5, 6)$ are both longest increasing subsequences of $(2, 1, 1, 4, 7, 5, 6)$, and their lengths are both $4$.\n\nNow Zhu Xiaoxia encounters the following problem: given a sequence $B_m = (b_1, b_2, \\ldots, b_m)$, let $C$ be a subsequence of $B_m$. If the length of the LIS of $C$ does not exceed $k$, what is the maximum possible length of $C$?\n\nZhu Xiaoxia thinks this problem is too easy and lacks challenge, so he proposes a harder one. He gives you a sequence $B = (b_1, b_2,\\ldots , b_n)$ and several queries. Each query gives two integers $m$ and $k$. For the sequence formed by the first $m$ elements of $B$, namely $B_m = (b_1, b_2, \\ldots, b_m)$, and the given $k$, you need to answer the problem above.", "inputFormat": "The first line contains two integers $n, q$, where $n$ is the length of the sequence $B$, and $q$ is the number of queries.\n\nThe second line contains $n$ space-separated positive integers $b_1, b_2, \\ldots, b_n$.\n\nThe next $q$ lines follow. The $i$-th line contains two integers $m_i, k_i$, representing a query with $m = m_i$ and $k = k_i$.", "outputFormat": "Output $q$ lines. For each query, print one integer as the answer, in order.", "hint": "Sample explanation:\n\nQuery $1$: For the sequence $(9,6,3,1,5)$, one may choose the subsequence $(9,6,3,1)$, whose LIS length is $1$.\n\nQuery $2$: For the sequence $(9,6,3,1,5,12,8)$, one may choose the subsequence $(9,6,3,1,12,8)$, whose LIS length is $2$.\n\nQuery $3$: For the sequence $(9,6,3,1,5,12,8,4,2)$, one may choose the subsequence $(9,6,5,4,2)$, whose LIS length is $1$.\n\nQuery $4$: For the sequence $(9,6,3,1,5,12,8,4,2)$, one may choose the subsequence $(9,6,3,1,12,8,4,2)$, whose LIS length is $2$.\n\nQuery $5$: For the sequence $(9,6,3,1,5,12,8,4,2,2,2)$, one may choose the subsequence $(9,6,5,4,2,2,2)$, whose LIS length is $1$.\n\nQuery $6$: For the sequence $(9,6,3,1,5,12,8,4,2,2,2)$, one may choose the subsequence $(9,6,3,1,5,12,8,4,2,2,2)$, whose LIS length is $3$.\n\n![](https://cdn.luogu.com.cn/upload/pic/5487.png)\n\nConstraints:\nFor $100\\%$ of the testdata, $1 \\le n \\le 5 \\times 10^4$, $1 \\le b_i \\le 5 \\times 10^4$, $1 \\le q \\le 2 \\times 10^5$, $1 \\le k_i \\le m_i \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2017] 最长上升子序列", "background": "", "description": "猪小侠最近学习了最长上升子序列的相关知识。对于一个整数序列 $A =(a_1, a_2,\\ldots , a_k)$，定义 $A$ 的子序列为：从 $A$ 中删除若干个元素后（允许不删，也允许将所有 $k$ 个元素都删除），剩下的元素按照原来的顺序所组成的序列。如果这个子序列的元素从左到右严格递增，则称它为 $A$ 的一个上升子序列。其中包含元素数量最多的上升子序列称为 $A$ 的最长上升子序列。例如，$(2, 4, 5, 6)$ 和 $(1, 4, 5, 6)$ 都是 $(2, 1, 1, 4, 7, 5, 6)$ 的最长上升子序列，长度都为 $4$。\n\n现在猪小侠遇到了这样一个问题：给定一个序列 $B_m = (b_1, b_2, \\ldots, b_m)$，设 $C$ 是 $B_m$ 的子序列，且 $C$ 的最长上升子序列的长度不超过 $k$，则 $C$ 的长度最大能是多少？\n\n猪小侠觉得这个问题太简单了，缺乏挑战，他决定提出一个更难的问题。于是他给了你这样一个序列 $B = (b_1, b_2,\\ldots , b_n)$，以及若干次询问。每次询问会给定两个整数 $m$ 和 $k$，你需要对于 $B$ 序列的前 $m$ 个元素构成的序列 $B_m = (b_1, b_2, \\ldots, b_m)$ 和 $k$ 回答上述问题。\n", "inputFormat": "第一行两个整数 $n, q$，其中 $n$ 是序列 $B$ 的长度，$q$ 是询问次数。\n\n第二行是空格隔开的 $n$ 个正整数 $b_1, b_2, \\ldots, b_n$。\n\n接下来 $q$ 行，其中第 $i$ 行包含两个整数 $m_i, k_i$，表示对 $m = m_i, k = k_i$ 进行询问。\n", "outputFormat": "输出共 $q$ 行，按顺序每行一个整数作为回答。\n", "hint": "【样例解释】\n\n询问 $1$：对于序列 $(9,6,3,1,5)$，可以选取子序列 $(9,6,3,1)$，它的最长上升子序列长度为 $1$。\n\n询问 $2$：对于序列 $(9,6,3,1,5,12,8)$，可以选取子序列 $(9,6,3,1,12,8)$，它的最长上升子序列长度为 $2$。\n\n询问 $3$：对于序列 $(9,6,3,1,5,12,8,4,2)$，可以选取子序列 $(9,6,5,4,2)$，它的最长上升子序列长度为 $1$。\n\n询问 $4$：对于序列 $(9,6,3,1,5,12,8,4,2)$，可以选取子序列 $(9,6,3,1,12,8,4,2)$，它的最长上升子序列长度为 $2$。\n\n询问 $5$：对于序列 $(9,6,3,1,5,12,8,4,2,2,2)$，可以选取子序列 $(9,6,5,4,2,2,2)$，它的最长上升子序列长度为 $1$。\n\n询问 $6$：对于序列 $(9,6,3,1,5,12,8,4,2,2,2)$，可以选取子序列 $(9,6,3,1,5,12,8,4,2,2,2)$，它的最长上升子序列长度为 $3$。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/5487.png) \n\n对于 $100\\%$ 的数据， $1\\leq n\\leq 5\\times 10^4$，$1\\leq b_i\\leq 5\\times 10^4$，$1\\leq q \\leq 2\\times 10^5$，$1\\leq k_i \\leq m_i \\leq n$。\n", "locale": "zh-CN"}}}
{"pid": "P3775", "type": "P", "difficulty": 7, "samples": [["2 1\n0 0 0\n1 1 0\n0 1 0\n1 0 0\n-1 -1", "0.70710678118655"], ["4 2\n0 0 0\n0 1 1\n1 0 1\n1 1 0\n0 0 1\n0 1 0\n1 0 0\n1 1 1\n-1 -1", "0.73883404559321"]], "limits": {"time": [1000, 1000, 2000, 2000, 3000, 3000, 4000, 4000, 5000, 5000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "Special Judge", "O2优化", "CTSC/CTS"], "title": "[CTSC2017] 投影", "background": "无", "description": "换一个角度看，世界可能就不同。 —— 小强\n\nk 维空间中有 n 个黑点与 n 个白点。我们为每一个黑点确定一个互不相同的对应的白点，这样一共有 n! 种对应方法。我们定义这 n 个黑点与 n 个白点之间的 “移动距离”为，在所有的对应方法中，对应的黑点与白点之间的 n 个欧几里德距离的和的最小值。\n\n例如; 考虑一维中的三个黑点 {1,5,6} 与三个白点 {2,3,4}，那么它们之间的移动距离为; |1 − 2| + |5 − 3| + |6 − 4| = 4。你可以验证一下这确实是距离和最小的一种对应方法。\n你得到了三维空间中的 n 个黑点与 n 个白点。你想把它们投影到一个 k(1 ≤ k ≤ 2)维子空间上。一维子空间就是三维空间中的一条直线，二维子空间则是三维空间中的一个平面。一个点在一个子空间中的投影点就是这个子空间中距离它最近的点。例如，(0, 0, 0), (1, 1, 0), (1, 0, 0), (0, 1, 0) 这四个点投影到 x − y = 0,z = 0 这条直线上之后，得到的投影点是 (0, 0, 0), (1, 1, 0), (0;5, 0;5, 0), (0;5, 0;5, 0)。\n\n你希望这 n 个黑点和 n 个白点投影到这个 k 维子空间之后的移动距离最大。请你计算这个最大值除以 n。\n", "inputFormat": "每个测试文件中可能有多个测试用例，每个测试用例的格式如下：\n\n第一行两个数 n 和 k，表示点数以及降到的维度。\n\n后面 2n 行，每行三个数，表示点的坐标。\n\n文件最后有一行包含两个数 −1 − 1。\n", "outputFormat": "对文件中的每个测试用例，输出一行一个数 (长度不要超过 30)，表示结果。\n\n你的答案与参考答案的相对误差不超过 10^−7 时被认为是正确的。\n\n只有一个文件中所有的测试用例的结果都是正确的才能获得这个测试文件所对应的分数。\n", "hint": "对于 30% 的数据， k = 1， n ≤ 1000, 所有的点的 z 都是 0。一个文件中最多包含一个测试用例。\n\n对于另外 40% 的数据， k = 1， n ≤ 1000，所有的点的坐标都是 [−1, 1] 之间均匀独立随机生成的，一个文件中最多包含十个测试用例。\n\n对于另外 30% 的数据， k = 2， n ≤ 20，所有的点的坐标都是 [−1, 1] 之间均匀独立随机生成的，一个文件中最多包含十个测试用例。\n\n对于 100% 的数据，点的坐标的范围都是 −1 到 +1 之间的，答案不小于 0.01。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2017] Projection", "background": "None.", "description": "", "inputFormat": "", "outputFormat": "For each test case in the file, output one number on a single line (its length should not exceed 30), representing the result.\n\nYour answer will be considered correct if its relative error does not exceed $10^{-7}$ compared to the reference answer.\n\nYou will receive points for a test file only if all test cases in that file are answered correctly.", "hint": "- For 30% of the testdata, $k = 1$, $n \\le 1000$, and all points have $z = 0$. At most one test case appears in a file.\n- For another 40% of the testdata, $k = 1$, $n \\le 1000$, and all point coordinates are independently and uniformly generated in $[-1, 1]$. At most ten test cases appear in a file.\n- For the remaining 30% of the testdata, $k = 2$, $n \\le 20$, and all point coordinates are independently and uniformly generated in $[-1, 1]$. At most ten test cases appear in a file.\n- For 100% of the testdata, all coordinates lie in $[-1, 1]$, and the answer is at least $0.01$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2017] 投影", "background": "无", "description": "换一个角度看，世界可能就不同。 —— 小强\n\nk 维空间中有 n 个黑点与 n 个白点。我们为每一个黑点确定一个互不相同的对应的白点，这样一共有 n! 种对应方法。我们定义这 n 个黑点与 n 个白点之间的 “移动距离”为，在所有的对应方法中，对应的黑点与白点之间的 n 个欧几里德距离的和的最小值。\n\n例如; 考虑一维中的三个黑点 {1,5,6} 与三个白点 {2,3,4}，那么它们之间的移动距离为; |1 − 2| + |5 − 3| + |6 − 4| = 4。你可以验证一下这确实是距离和最小的一种对应方法。\n你得到了三维空间中的 n 个黑点与 n 个白点。你想把它们投影到一个 k(1 ≤ k ≤ 2)维子空间上。一维子空间就是三维空间中的一条直线，二维子空间则是三维空间中的一个平面。一个点在一个子空间中的投影点就是这个子空间中距离它最近的点。例如，(0, 0, 0), (1, 1, 0), (1, 0, 0), (0, 1, 0) 这四个点投影到 x − y = 0,z = 0 这条直线上之后，得到的投影点是 (0, 0, 0), (1, 1, 0), (0;5, 0;5, 0), (0;5, 0;5, 0)。\n\n你希望这 n 个黑点和 n 个白点投影到这个 k 维子空间之后的移动距离最大。请你计算这个最大值除以 n。\n", "inputFormat": "每个测试文件中可能有多个测试用例，每个测试用例的格式如下：\n\n第一行两个数 n 和 k，表示点数以及降到的维度。\n\n后面 2n 行，每行三个数，表示点的坐标。\n\n文件最后有一行包含两个数 −1 − 1。\n", "outputFormat": "对文件中的每个测试用例，输出一行一个数 (长度不要超过 30)，表示结果。\n\n你的答案与参考答案的相对误差不超过 10^−7 时被认为是正确的。\n\n只有一个文件中所有的测试用例的结果都是正确的才能获得这个测试文件所对应的分数。\n", "hint": "对于 30% 的数据， k = 1， n ≤ 1000, 所有的点的 z 都是 0。一个文件中最多包含一个测试用例。\n\n对于另外 40% 的数据， k = 1， n ≤ 1000，所有的点的坐标都是 [−1, 1] 之间均匀独立随机生成的，一个文件中最多包含十个测试用例。\n\n对于另外 30% 的数据， k = 2， n ≤ 20，所有的点的坐标都是 [−1, 1] 之间均匀独立随机生成的，一个文件中最多包含十个测试用例。\n\n对于 100% 的数据，点的坐标的范围都是 −1 到 +1 之间的，答案不小于 0.01。\n", "locale": "zh-CN"}}}
{"pid": "P3776", "type": "P", "difficulty": 7, "samples": [["6 4 9 4\n3 3\nNWESSWEWS\n2 3 2 3\n3 2 4 4\n5 3 6 4\n1 2 5 3", "0\n2\n1\n3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "APIO"], "title": "[APIO2017] 斑斓之地", "background": "本题原为交互题，这里采用传统题形式进行评测。", "description": "在很久以前的黄金时代，澳大利亚的土地是矩形的，它可以被划分成 $R$ 行 $C$ 列的网格状，行的编号从北到南依次为 $1$ 到 $R$ ，列的编号从西到东依次为 $1$ 到 $C$，$(r,c)$ 表示第 $r$ 行第 $c$ 列的土地。一天，伟大的彩虹蛇从 $(s_r,s_c)$ 出发在澳大利亚的土地上移动，彩虹蛇连续进行了 $M$ 次移动，每次它会向正北 (`N`)、正南 (`S`)、正东 (`E`) 或正西 (`W`) 方向移动一格，其经过的所有的格子（包括起点和终点）都会变成河流。保证在任一时刻，彩虹蛇都不会离开这片 $R$ 行 $C$ 列的矩形土地。\n\n数百万年之后，你想购买一块矩形区域纪念伟大的彩虹蛇。你想给所购买矩形区域内每一块不是河流的格子都染上颜色，要求相邻的格子颜色必须相同，两个格子相邻当且仅当两个格子有一条公共边，你所购买区域之外的格子无须染色。\n\n现在给出彩虹蛇 $M$ 次移动的方向，你有 $Q$ 个购买矩形区域的方案，问每个方案最多能够将土地染上多少种不同的颜色。", "inputFormat": "第一行：四个整数 $R$，$C$，$M$ 和 $Q$；\n\n第二行：两个整数 $s_r$ 和 $s_c$；\n\n第三行: 一个包含 $M$ 个字符的字符串 $S$，每个字符是 `N`、`S`、`E`、`W` 之一（如果 $M=0$ 则此行留空）；\n\n第四到 $Q+3$ 行: 每行四个整数 $a_r,a_c,b_r$ 和 $b_c$，表示你购买的土地范围，左上角是 $(a_r,a_c)$，右下角是 $(b_r,b_c)$。", "outputFormat": "对于每个询问做出回答，输出最多能够将土地染上多少种不同的颜色。", "hint": "### 样例解释\n\n样例对应下图，其中蓝色代表河流。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1mhty5m8.png)\n\n### 数据范围\n\n对于所有测试数据，$0\\le M\\le 10^5$，并且 $R,C,Q\\ge 1$，对于每个购买矩形土地的方案，都有 $1 \\le a_r \\le b_r \\le R, 1 \\le a_c \\le b_c \\le C$。\n\n详细子任务分值及附加条件如下表。\n\n|子任务编号|分值|$R$|$C$|$Q$|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$11$|$R\\le 50$|$C\\le 50$|$Q\\le 1000$|\n|$2$|$12$|$R=2$|$C\\le 2\\times 10^5$|$Q\\le 10^5$|\n|$3$|$24$|$R\\le 2\\times 10^5$|$C\\le 2\\times 10^5$|$Q=1$|\n|$4$|$27$|$R\\le 1000$|$C\\le 1000$|$Q\\le 10^5$|\n|$5$|$26$|$R\\le 2\\times 10^5$|$C\\le 2\\times 10^5$|$Q\\le 10^5$|\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2017] The Colorful Land", "background": "This problem was originally interactive; here it is evaluated in the traditional (non-interactive) format.", "description": "In the distant Golden Age, the land of Australia was rectangular and could be divided into a grid with $R$ rows and $C$ columns. Rows are numbered $1$ to $R$ from north to south, and columns are numbered $1$ to $C$ from west to east. The cell $(r, c)$ denotes the land in row $r$ and column $c$. One day, the great Rainbow Serpent started at $(s_r, s_c)$ and moved across Australia. The serpent made $M$ consecutive moves, each time moving one cell to the north (`N`), south (`S`), east (`E`), or west (`W`). Every cell it passed through (including the start and end cells) turned into river. It is guaranteed that the Rainbow Serpent never leaves the $R \\times C$ rectangular land at any time.\n\nMillions of years later, you want to buy a rectangular area to commemorate the great Rainbow Serpent. You want to color every non-river cell inside the purchased rectangle, with the requirement that adjacent cells must have the same color. Two cells are adjacent if and only if they share a common side. Cells outside your purchased area do not need to be colored.\n\nYou are given the $M$ movement directions of the Rainbow Serpent and $Q$ candidate rectangular regions to purchase. For each region, determine the maximum number of different colors you can use.", "inputFormat": "The first line contains four integers $R$, $C$, $M$, and $Q$.\n\nThe second line contains two integers $s_r$ and $s_c$.\n\nThe third line contains a string $S$ of $M$ characters, each being one of `N`, `S`, `E`, or `W` (if $M=0$, this line is left blank).\n\nLines $4$ through $Q+3$: each line contains four integers $a_r$, $a_c$, $b_r$, and $b_c$, describing the land you intend to purchase, whose top-left corner is $(a_r, a_c)$ and bottom-right corner is $(b_r, b_c)$.", "outputFormat": "For each query, output the maximum number of different colors that the land can be painted with.", "hint": "### Sample Explanation\n\nThe sample corresponds to the figure below, where blue cells represent rivers.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1mhty5m8.png)\n\n### Constraints\n\nFor all testdata, $0 \\le M \\le 10^5$, and $R, C, Q \\ge 1$. For every purchased rectangle, $1 \\le a_r \\le b_r \\le R$ and $1 \\le a_c \\le b_c \\le C$.\n\nThe detailed subtask scores and additional conditions are as follows.\n\n| Subtask ID | Score | $R$ | $C$ | $Q$ |\n|:-:|:-:|:-:|:-:|:-:|\n| $1$ | $11$ | $R \\le 50$ | $C \\le 50$ | $Q \\le 1000$ |\n| $2$ | $12$ | $R = 2$ | $C \\le 2 \\times 10^5$ | $Q \\le 10^5$ |\n| $3$ | $24$ | $R \\le 2 \\times 10^5$ | $C \\le 2 \\times 10^5$ | $Q = 1$ |\n| $4$ | $27$ | $R \\le 1000$ | $C \\le 1000$ | $Q \\le 10^5$ |\n| $5$ | $26$ | $R \\le 2 \\times 10^5$ | $C \\le 2 \\times 10^5$ | $Q \\le 10^5$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2017] 斑斓之地", "background": "本题原为交互题，这里采用传统题形式进行评测。", "description": "在很久以前的黄金时代，澳大利亚的土地是矩形的，它可以被划分成 $R$ 行 $C$ 列的网格状，行的编号从北到南依次为 $1$ 到 $R$ ，列的编号从西到东依次为 $1$ 到 $C$，$(r,c)$ 表示第 $r$ 行第 $c$ 列的土地。一天，伟大的彩虹蛇从 $(s_r,s_c)$ 出发在澳大利亚的土地上移动，彩虹蛇连续进行了 $M$ 次移动，每次它会向正北 (`N`)、正南 (`S`)、正东 (`E`) 或正西 (`W`) 方向移动一格，其经过的所有的格子（包括起点和终点）都会变成河流。保证在任一时刻，彩虹蛇都不会离开这片 $R$ 行 $C$ 列的矩形土地。\n\n数百万年之后，你想购买一块矩形区域纪念伟大的彩虹蛇。你想给所购买矩形区域内每一块不是河流的格子都染上颜色，要求相邻的格子颜色必须相同，两个格子相邻当且仅当两个格子有一条公共边，你所购买区域之外的格子无须染色。\n\n现在给出彩虹蛇 $M$ 次移动的方向，你有 $Q$ 个购买矩形区域的方案，问每个方案最多能够将土地染上多少种不同的颜色。", "inputFormat": "第一行：四个整数 $R$，$C$，$M$ 和 $Q$；\n\n第二行：两个整数 $s_r$ 和 $s_c$；\n\n第三行: 一个包含 $M$ 个字符的字符串 $S$，每个字符是 `N`、`S`、`E`、`W` 之一（如果 $M=0$ 则此行留空）；\n\n第四到 $Q+3$ 行: 每行四个整数 $a_r,a_c,b_r$ 和 $b_c$，表示你购买的土地范围，左上角是 $(a_r,a_c)$，右下角是 $(b_r,b_c)$。", "outputFormat": "对于每个询问做出回答，输出最多能够将土地染上多少种不同的颜色。", "hint": "### 样例解释\n\n样例对应下图，其中蓝色代表河流。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1mhty5m8.png)\n\n### 数据范围\n\n对于所有测试数据，$0\\le M\\le 10^5$，并且 $R,C,Q\\ge 1$，对于每个购买矩形土地的方案，都有 $1 \\le a_r \\le b_r \\le R, 1 \\le a_c \\le b_c \\le C$。\n\n详细子任务分值及附加条件如下表。\n\n|子任务编号|分值|$R$|$C$|$Q$|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$11$|$R\\le 50$|$C\\le 50$|$Q\\le 1000$|\n|$2$|$12$|$R=2$|$C\\le 2\\times 10^5$|$Q\\le 10^5$|\n|$3$|$24$|$R\\le 2\\times 10^5$|$C\\le 2\\times 10^5$|$Q=1$|\n|$4$|$27$|$R\\le 1000$|$C\\le 1000$|$Q\\le 10^5$|\n|$5$|$26$|$R\\le 2\\times 10^5$|$C\\le 2\\times 10^5$|$Q\\le 10^5$|\n", "locale": "zh-CN"}}}
{"pid": "P3777", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "APIO", "交互题", "Special Judge"], "title": "[APIO2017] 考拉的游戏", "background": "### 特别提示\n\n**在洛谷提交本题时的一些注意事项（与原题面不同之处请以此处为准）：**\n\n1. 提交时请在程序里加入以下函数声明语句：\n\n```cpp\nvoid playRound(int*,int*);\n```\n\n2. 程序开头不用，也不应该包含 `koala.h` 头文件。\n3. 仅支持 `C++`（含 `C++`，`C++11`，`C++14`，`C++17`）提交。", "description": "Koala 发明了一个新游戏，来邀请你一起玩！游戏的开始，她会在桌上放 $N$ 个物品，物品从 $0$ 到 $N - 1$ 标号。接着，她会秘密地给每个物品分配一个 $1$ 到 $N$ 之间的整数权值，且任意两个物品不会被分配到相同的权值。其中，第 $i$ 个物品的权值为 $P_i$。她请你来确定由这些权值构成的序列 $P=P_0,P_1,\\dots ,P_{N-1}$ 的一些特征。\n\n为了回答她的问题，你可以请 Koala 玩若干轮游戏。每一轮中，你会得到 $W$ 个蓝色石子，Koala 会得到 $W$ 个红色石子。首先，你可以选择若干个物品，再把你的一些（或全部）石子放在这些物品的旁边。Koala 会观察你的石子分配，然后类似地把她的一些（或全部）石子放在若干个物品旁边。如果一个物品旁边的红色石子数严格大于蓝色石子数，那么，Koala可以获得这个物品。Koala 分配她的石子时，总会选择使她获得的物品的权值和最大的方案，如果有多种方案可以做到这一点，她会选择一种获得的物品数最多的方案，如果仍然有多种方案，她会选择其中任意一种。\n\nKoala 非常懒，如果你和她玩太多轮游戏，她就会睡着。你的任务是通过尽可能少轮数的游戏，确定 Koala 的序列 $P$ 的相关特征。\n\n### 任务\n\n在这个任务中，你需要实现 $4$ 个函数：`minValue`, `maxValue`, `greaterValue` 和 `allValues`。\n\n每个函数需要你确定序列 $P$ 的不同特征。我们强烈推荐在我们提供的模版的基础上进行作答。注意，即使你只想获得部分子任务的分数，你也必须为四个函数都提供一个实现（尽管一些函数的内部可能为空）。你的程序禁止从标准输入读数据、向标准输出写数据或与任何文件交互。\n\n在每个函数中，参数 `N` 表示游戏中物品的个数，参数 `W` 表示你和 Koala 在每一轮游戏中拥有的石子数。\n\n* `minValue(N, W)` --- 这个函数需要返回权值最小的物品的标号 $i$，即 $P_i=1$\n* `maxValue(N, W)` --- 这个函数需要返回权值最大的物品的标号 $i$，即 $P_i=N$\n* `greaterValue(N, W)` --- 这个函数需要比较物品 $0$ 和物品 $1$ 的权值，返回权值较大的物品的标号。具体来说，若 $P_0>P_1$​，它应该返回 $0$ ，否则返回 $1$ 。\n* `allValues(N, W, P)` --- 这个函数需要确定整个排列，并将其存放在给定的数组 $P$ 中：具体来说，$P[i]$ 应该保存物品 $i$ 的权值 $P_i (0 \\leq i \\leq N-1)$。\n\n在每个测试点中，交互库会一次或多次调用这些函数中的一个。每次函数调用代表不同的任务，哪个函数会被调用、以及最多被调用多少次取决于子任务（见下文）。你可以认为 Koala 在每次函数调用前确定了她的序列 $P$，并且序列不会在一次函数的调用过程中改变。一次调用结束后，她可以在下次函数调用之前改变她的序列。\n\n你实现的四个函数可以通过调用函数 `playRound` 来获取 Koala 的序列的相关信息。\n\n* `playRound(B, R)`，请 Koala 和你玩一轮游戏。\n\n数组 `B` 描述你在每个物品旁边放了多少蓝色石子。具体来说，对任意 $0 \\leq i \\leq N-1$，$B[i]$ 个蓝色石子将会被放在物品 $i$ 旁边。每个 $B[i]$ 必须是一个非负整数，且 $B[0]+B[1]+\\cdots +B[N-1]$ 不能超过 $W$ 。\n\n交互库会把 Koala 的回应存放在你提供的数组 `R` 中。具体来说，对任意 $0 \\leq i \\leq N-1$，Koala 会在物品 $i$ 旁边放 $R[i]$ 个红色石子。\n\n每个子任务对你在每次游戏中调用 `playRound` 的次数有所限制。注意，调用次数越少你的得分可能会越高。（具体限制和评分方式参见下文）", "inputFormat": "", "outputFormat": "", "hint": "### 子任务\n\n#### 样例数据：$0$ 分\n\n**因为特殊原因（不支持设置 $0$ 分测试点），评测时将不测样例**。\n\n* 有 $5$ 个「样例数据」测试点，每个测试点恰好调用一次 $4$ 个函数中的某一个。请看下文的「样例」获取各测试点的详细信息。\n* $N=6$\n* $P=5,3,2,1,6,4$\n\n每次游戏中，你可以调用 `playRound `至多 $3200$ 次。\n\n#### 子任务 1：$4$ 分\n* 在这个子任务中，交互库只会调用函数 `minValue`，每个测试点中，这个函数最多会被调用 $100$ 次。\n* $N=100$\n* $W=100$\n* 每一次游戏中，你可以调用 `playRound` 至多 $2$ 次。\n\n#### 子任务 2：$15$ 分\n* 在这个子任务中，交互库只会调用函数 `maxValue`。每个测试点中，这个函数最多会被调用 $100$ 次。\n* $N=100$\n* $W=100$\n* 每一次游戏中，你可以调用 `playRound` 至多 $13$ 次。\n* 这个子任务中，一个测试点的分数取决于每一轮游戏中 `playRound` 被调用次数的最大值 $C_{max}$，具体来说，你的得分为：\n  - 若 $C_{max}\\leq 4$，获得 $15$ 分。\n  - 若 $5 \\leq C_{max} \\leq 13$，获得 $7$ 分。\n\n#### 子任务 3：$18$ 分\n* 在这个子任务中，交互库只会调用函数 `greaterValue`。每个测试点中，这个函数最多会被调用 $1100$ 次。\n* $N=100$\n* $W=100$\n* 每一次游戏中，你可以调用 `playRound` 至多 $14$ 次。\n* 这个子任务中，一个测试点的分数取决于每一轮游戏中 `playRound` 被调用次数的最大值 $C_{max}$，具体来说，你的得分为：\n  - 若 $C_{max}\\leq 3$，获得 $18$ 分。\n  - 若 $C_{max}=4$，获得 $14$ 分。\n  - 若 $C_{max}=5$，获得 $11$ 分。\n  - 若 $6 \\leq C_{max}\\leq 14$，获得 $5$ 分。\n\n#### 子任务 4：$10$ 分\n* 在这个子任务中，交互库只会调用函数 `allValues`，每个测试点中，这个函数会被调用恰好一次。\n* $N=100$\n* $W=200$\n* 你可以调用 `playRound` 至多 $700$ 次。\n\n#### 子任务 5：$53$ 分\n* 在这个子任务中，交互库只会调用函数 `allValues`，每个测试点中，这个函数会被调用恰好一次。\n* $N=100$\n* $W=100$\n* 你可以调用 `playRound` 至多 $3200$ 次。\n* 这个子任务中，一个测试点的分数取决于 `playRound` 被调用的次数 $C$ ，具体来说，你的得分为：\n  - 若 $C \\leq 100$，获得 $53$ 分。\n  - 若 $101 \\leq C \\leq 3200$，获得 $\\lfloor 53-8 \\log_2 (c/100) \\rfloor$ 分。其中，$\\lfloor x \\rfloor$ 为不大于 $x$ 的最大整数。举例来说，若 $C=3200$，那么你的解答将获得 $13$ 分。\n\n### 评分方式\n\n- 和传统题一样，你的程序的运行时间和空间不能超过时间和空间限制。**交互库运行的时间和空间也会算入你的程序的总时间和空间当中**。当你估算这一部分的时空消耗时，你可以认为，在评测时使用的交互库与我们提供的样例交互库有**相同的函数**和**相似的实现**。\n- 在一个测试点中，若你在调用 `playRound` 时传入了非法的数组 B，或调用 `playRound` 的总次数超过了上限，那么该测试点记 $0$ 分。\n- 在一个测试点的任意一次游戏中，若一个函数没有正确地回答所要求的 Koala 的序列的特征，那么该测试点记 $0$ 分。\n- 子任务 4 和子任务 5 均要求你实现函数 `allValues`，但在调用时传入了不同的 $W$。你可以利用两个子任务在这个参数上的不同，从而在你的实现中区分两个子任务。你可以参考你的语言的模板实现获取更详细的信息。\n- 比赛时，你可以提交本题目最多 60 次，连续两次的提交至少间隔 2 分钟。\n- **你在一个子任务上的得分，等于你在该子任务所有测试点中的最低得分**。\n\n### 如何测试你的程序\n\n在终端下输入如下命令进行编译：\n\n```bash\ng++ grader.cpp koala.cpp -o grader -g -Wall --std=c++11\n```\n\n样例交互库将按如下格式从标准输入读入数据：\n\n第一行两个整数 $F,G$，其中 $F$ 代表交互库调用的函数类型，$G$ 代表调用函数的次数；\n\n接下来 $G$ 行，每行开头两个整数 $N,W$，后跟 $N$ 个整数 $P_0,P_1,\\ldots,P_{N-1}$。\n\n$F$ 对应的样例交互库调用的函数类型如下表所示：\n\n| $F$ | 调用的函数类型 |\n| ----------- | ----------- |\n| $1$ | `minValue` |\n| $2$ | `maxValue` |\n| $3$ | `greaterValue` |\n| $4$ | `allValues` |\n\n对于每次函数调用，样例交互库将向标准输出输出两行。第一行代表你调用 `playRound` 的次数，第二行代表函数调用后返回的结构（对于 $F=4$ 的情况，将输出调用 `allValues` 时返回的数组，对于其他情况，将输出函数的返回值）。\n\n### 样例\n\n考虑如下的排列：\n\n| $i$ | 0 | 1 | 2 | 3 | 4 | 5 |\n| ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- |\n| $P_i$ | 5 | 3 | 2 | 1 | 6 | 4 |\n\n下表展示了几次调用函数 `playRound` 的例子，以及交互库对每个调用的有效反馈（注意，一次 `playRound` 的调用，可能会有多种可能的有效反馈） 。\n\n| $W$ | 调用 | 可能的交互库反馈 | 解释 |\n| ----------- | ----------- | ----------- | ----------- |\n| 6 | `playRound([0,3,0,2,1,0],R)` | `R=[1,1,1,0,2,1]` | Koala 获得了物品 $0,2,4,5$，总权值为 $17$，这是一种可能的权值最大的方案。 |\n| 6 | `playRound([1,2,3,1,2,0],R)` | 非法调用 | 你总共放了 $9$ 个石子，超过了 $W$ 的限制。 |\n| 12 | `playRound([0,3,0,2,1,0],R)` | `R=[2,3,0,2,3,1]` | 你不用放完 $W$ 个石子，Koala 也不用放完 $W$ 个石子。 |\n| 6 | `playRound([0,1,0,0,1,0],R)` | `R=[1,0,1,1,2,1]` | 若 Koala 有多种方案最大化获得物品的权值，她会选择使自己获得物品最多的方案。因此 `R=[1,2,0,0,2,1]` 不是一个合法的返回值。 |\n\n下面是样例数据的返回值，请注意在样例数据中，你可以调用 `playRound` 至多 $3200$ 次。\n\n| # | 交互库调用 | 期望返回值 | 解释 |\n| ----------- | ----------- | ----------- | ----------- |\n| 1 | `minValue(6,6)` | 3 | $P_3=1$ |\n| 2 | `maxValue(6,6)` | 4 | $P_4=6$ |\n| 3 | `greaterValue(6,6)` | 0 | $P_0=5,P_1=3$ |\n| 4 | `allValues(6,12,P)` | `P=[5,3,2,1,6,4]` | 注意 `allValues` 无返回值，而是将正确结果放入 P 中。 |\n| 5 | `allValues(6,12,P)` | `P=[5,3,2,1,6,4]` | 同上。 |\n\n\n### 附加文件\n\n附加文件包含样例输入输出，C++ 样例交互库和程序模板，我们推荐您在模板的基础上实现您的程序。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[APIO2017] 考拉的游戏", "background": "### 特别提示\n\n**在洛谷提交本题时的一些注意事项（与原题面不同之处请以此处为准）：**\n\n1. 提交时请在程序里加入以下函数声明语句：\n\n```cpp\nvoid playRound(int*,int*);\n```\n\n2. 程序开头不用，也不应该包含 `koala.h` 头文件。\n3. 仅支持 `C++`（含 `C++`，`C++11`，`C++14`，`C++17`）提交。", "description": "Koala 发明了一个新游戏，来邀请你一起玩！游戏的开始，她会在桌上放 $N$ 个物品，物品从 $0$ 到 $N - 1$ 标号。接着，她会秘密地给每个物品分配一个 $1$ 到 $N$ 之间的整数权值，且任意两个物品不会被分配到相同的权值。其中，第 $i$ 个物品的权值为 $P_i$。她请你来确定由这些权值构成的序列 $P=P_0,P_1,\\dots ,P_{N-1}$ 的一些特征。\n\n为了回答她的问题，你可以请 Koala 玩若干轮游戏。每一轮中，你会得到 $W$ 个蓝色石子，Koala 会得到 $W$ 个红色石子。首先，你可以选择若干个物品，再把你的一些（或全部）石子放在这些物品的旁边。Koala 会观察你的石子分配，然后类似地把她的一些（或全部）石子放在若干个物品旁边。如果一个物品旁边的红色石子数严格大于蓝色石子数，那么，Koala可以获得这个物品。Koala 分配她的石子时，总会选择使她获得的物品的权值和最大的方案，如果有多种方案可以做到这一点，她会选择一种获得的物品数最多的方案，如果仍然有多种方案，她会选择其中任意一种。\n\nKoala 非常懒，如果你和她玩太多轮游戏，她就会睡着。你的任务是通过尽可能少轮数的游戏，确定 Koala 的序列 $P$ 的相关特征。\n\n### 任务\n\n在这个任务中，你需要实现 $4$ 个函数：`minValue`, `maxValue`, `greaterValue` 和 `allValues`。\n\n每个函数需要你确定序列 $P$ 的不同特征。我们强烈推荐在我们提供的模版的基础上进行作答。注意，即使你只想获得部分子任务的分数，你也必须为四个函数都提供一个实现（尽管一些函数的内部可能为空）。你的程序禁止从标准输入读数据、向标准输出写数据或与任何文件交互。\n\n在每个函数中，参数 `N` 表示游戏中物品的个数，参数 `W` 表示你和 Koala 在每一轮游戏中拥有的石子数。\n\n* `minValue(N, W)` --- 这个函数需要返回权值最小的物品的标号 $i$，即 $P_i=1$\n* `maxValue(N, W)` --- 这个函数需要返回权值最大的物品的标号 $i$，即 $P_i=N$\n* `greaterValue(N, W)` --- 这个函数需要比较物品 $0$ 和物品 $1$ 的权值，返回权值较大的物品的标号。具体来说，若 $P_0>P_1$​，它应该返回 $0$ ，否则返回 $1$ 。\n* `allValues(N, W, P)` --- 这个函数需要确定整个排列，并将其存放在给定的数组 $P$ 中：具体来说，$P[i]$ 应该保存物品 $i$ 的权值 $P_i (0 \\leq i \\leq N-1)$。\n\n在每个测试点中，交互库会一次或多次调用这些函数中的一个。每次函数调用代表不同的任务，哪个函数会被调用、以及最多被调用多少次取决于子任务（见下文）。你可以认为 Koala 在每次函数调用前确定了她的序列 $P$，并且序列不会在一次函数的调用过程中改变。一次调用结束后，她可以在下次函数调用之前改变她的序列。\n\n你实现的四个函数可以通过调用函数 `playRound` 来获取 Koala 的序列的相关信息。\n\n* `playRound(B, R)`，请 Koala 和你玩一轮游戏。\n\n数组 `B` 描述你在每个物品旁边放了多少蓝色石子。具体来说，对任意 $0 \\leq i \\leq N-1$，$B[i]$ 个蓝色石子将会被放在物品 $i$ 旁边。每个 $B[i]$ 必须是一个非负整数，且 $B[0]+B[1]+\\cdots +B[N-1]$ 不能超过 $W$ 。\n\n交互库会把 Koala 的回应存放在你提供的数组 `R` 中。具体来说，对任意 $0 \\leq i \\leq N-1$，Koala 会在物品 $i$ 旁边放 $R[i]$ 个红色石子。\n\n每个子任务对你在每次游戏中调用 `playRound` 的次数有所限制。注意，调用次数越少你的得分可能会越高。（具体限制和评分方式参见下文）", "inputFormat": "", "outputFormat": "", "hint": "### 子任务\n\n#### 样例数据：$0$ 分\n\n**因为特殊原因（不支持设置 $0$ 分测试点），评测时将不测样例**。\n\n* 有 $5$ 个「样例数据」测试点，每个测试点恰好调用一次 $4$ 个函数中的某一个。请看下文的「样例」获取各测试点的详细信息。\n* $N=6$\n* $P=5,3,2,1,6,4$\n\n每次游戏中，你可以调用 `playRound `至多 $3200$ 次。\n\n#### 子任务 1：$4$ 分\n* 在这个子任务中，交互库只会调用函数 `minValue`，每个测试点中，这个函数最多会被调用 $100$ 次。\n* $N=100$\n* $W=100$\n* 每一次游戏中，你可以调用 `playRound` 至多 $2$ 次。\n\n#### 子任务 2：$15$ 分\n* 在这个子任务中，交互库只会调用函数 `maxValue`。每个测试点中，这个函数最多会被调用 $100$ 次。\n* $N=100$\n* $W=100$\n* 每一次游戏中，你可以调用 `playRound` 至多 $13$ 次。\n* 这个子任务中，一个测试点的分数取决于每一轮游戏中 `playRound` 被调用次数的最大值 $C_{max}$，具体来说，你的得分为：\n  - 若 $C_{max}\\leq 4$，获得 $15$ 分。\n  - 若 $5 \\leq C_{max} \\leq 13$，获得 $7$ 分。\n\n#### 子任务 3：$18$ 分\n* 在这个子任务中，交互库只会调用函数 `greaterValue`。每个测试点中，这个函数最多会被调用 $1100$ 次。\n* $N=100$\n* $W=100$\n* 每一次游戏中，你可以调用 `playRound` 至多 $14$ 次。\n* 这个子任务中，一个测试点的分数取决于每一轮游戏中 `playRound` 被调用次数的最大值 $C_{max}$，具体来说，你的得分为：\n  - 若 $C_{max}\\leq 3$，获得 $18$ 分。\n  - 若 $C_{max}=4$，获得 $14$ 分。\n  - 若 $C_{max}=5$，获得 $11$ 分。\n  - 若 $6 \\leq C_{max}\\leq 14$，获得 $5$ 分。\n\n#### 子任务 4：$10$ 分\n* 在这个子任务中，交互库只会调用函数 `allValues`，每个测试点中，这个函数会被调用恰好一次。\n* $N=100$\n* $W=200$\n* 你可以调用 `playRound` 至多 $700$ 次。\n\n#### 子任务 5：$53$ 分\n* 在这个子任务中，交互库只会调用函数 `allValues`，每个测试点中，这个函数会被调用恰好一次。\n* $N=100$\n* $W=100$\n* 你可以调用 `playRound` 至多 $3200$ 次。\n* 这个子任务中，一个测试点的分数取决于 `playRound` 被调用的次数 $C$ ，具体来说，你的得分为：\n  - 若 $C \\leq 100$，获得 $53$ 分。\n  - 若 $101 \\leq C \\leq 3200$，获得 $\\lfloor 53-8 \\log_2 (c/100) \\rfloor$ 分。其中，$\\lfloor x \\rfloor$ 为不大于 $x$ 的最大整数。举例来说，若 $C=3200$，那么你的解答将获得 $13$ 分。\n\n### 评分方式\n\n- 和传统题一样，你的程序的运行时间和空间不能超过时间和空间限制。**交互库运行的时间和空间也会算入你的程序的总时间和空间当中**。当你估算这一部分的时空消耗时，你可以认为，在评测时使用的交互库与我们提供的样例交互库有**相同的函数**和**相似的实现**。\n- 在一个测试点中，若你在调用 `playRound` 时传入了非法的数组 B，或调用 `playRound` 的总次数超过了上限，那么该测试点记 $0$ 分。\n- 在一个测试点的任意一次游戏中，若一个函数没有正确地回答所要求的 Koala 的序列的特征，那么该测试点记 $0$ 分。\n- 子任务 4 和子任务 5 均要求你实现函数 `allValues`，但在调用时传入了不同的 $W$。你可以利用两个子任务在这个参数上的不同，从而在你的实现中区分两个子任务。你可以参考你的语言的模板实现获取更详细的信息。\n- 比赛时，你可以提交本题目最多 60 次，连续两次的提交至少间隔 2 分钟。\n- **你在一个子任务上的得分，等于你在该子任务所有测试点中的最低得分**。\n\n### 如何测试你的程序\n\n在终端下输入如下命令进行编译：\n\n```bash\ng++ grader.cpp koala.cpp -o grader -g -Wall --std=c++11\n```\n\n样例交互库将按如下格式从标准输入读入数据：\n\n第一行两个整数 $F,G$，其中 $F$ 代表交互库调用的函数类型，$G$ 代表调用函数的次数；\n\n接下来 $G$ 行，每行开头两个整数 $N,W$，后跟 $N$ 个整数 $P_0,P_1,\\ldots,P_{N-1}$。\n\n$F$ 对应的样例交互库调用的函数类型如下表所示：\n\n| $F$ | 调用的函数类型 |\n| ----------- | ----------- |\n| $1$ | `minValue` |\n| $2$ | `maxValue` |\n| $3$ | `greaterValue` |\n| $4$ | `allValues` |\n\n对于每次函数调用，样例交互库将向标准输出输出两行。第一行代表你调用 `playRound` 的次数，第二行代表函数调用后返回的结构（对于 $F=4$ 的情况，将输出调用 `allValues` 时返回的数组，对于其他情况，将输出函数的返回值）。\n\n### 样例\n\n考虑如下的排列：\n\n| $i$ | 0 | 1 | 2 | 3 | 4 | 5 |\n| ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- |\n| $P_i$ | 5 | 3 | 2 | 1 | 6 | 4 |\n\n下表展示了几次调用函数 `playRound` 的例子，以及交互库对每个调用的有效反馈（注意，一次 `playRound` 的调用，可能会有多种可能的有效反馈） 。\n\n| $W$ | 调用 | 可能的交互库反馈 | 解释 |\n| ----------- | ----------- | ----------- | ----------- |\n| 6 | `playRound([0,3,0,2,1,0],R)` | `R=[1,1,1,0,2,1]` | Koala 获得了物品 $0,2,4,5$，总权值为 $17$，这是一种可能的权值最大的方案。 |\n| 6 | `playRound([1,2,3,1,2,0],R)` | 非法调用 | 你总共放了 $9$ 个石子，超过了 $W$ 的限制。 |\n| 12 | `playRound([0,3,0,2,1,0],R)` | `R=[2,3,0,2,3,1]` | 你不用放完 $W$ 个石子，Koala 也不用放完 $W$ 个石子。 |\n| 6 | `playRound([0,1,0,0,1,0],R)` | `R=[1,0,1,1,2,1]` | 若 Koala 有多种方案最大化获得物品的权值，她会选择使自己获得物品最多的方案。因此 `R=[1,2,0,0,2,1]` 不是一个合法的返回值。 |\n\n下面是样例数据的返回值，请注意在样例数据中，你可以调用 `playRound` 至多 $3200$ 次。\n\n| # | 交互库调用 | 期望返回值 | 解释 |\n| ----------- | ----------- | ----------- | ----------- |\n| 1 | `minValue(6,6)` | 3 | $P_3=1$ |\n| 2 | `maxValue(6,6)` | 4 | $P_4=6$ |\n| 3 | `greaterValue(6,6)` | 0 | $P_0=5,P_1=3$ |\n| 4 | `allValues(6,12,P)` | `P=[5,3,2,1,6,4]` | 注意 `allValues` 无返回值，而是将正确结果放入 P 中。 |\n| 5 | `allValues(6,12,P)` | `P=[5,3,2,1,6,4]` | 同上。 |\n\n\n### 附加文件\n\n附加文件包含样例输入输出，C++ 样例交互库和程序模板，我们推荐您在模板的基础上实现您的程序。", "locale": "zh-CN"}}}
{"pid": "P3778", "type": "P", "difficulty": 6, "samples": [["4 5 2\n10 9 5 2\n6 4 20 15\n9 7 10 9\n-1 -1 16 11\n1 2 3\n2 3 3\n1 4 1\n4 3 1\n3 1 1", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2017", "APIO"], "title": "[APIO2017] 商旅", "background": "", "description": "在广阔的澳大利亚内陆地区长途跋涉后，你孤身一人带着一个背包来到了科巴。你被这个城市发达而美丽的市场所深深吸引，决定定居于此，做一个商人。科巴有 $N$ 个集市，集市用从 $1$ 到 $N$ 的整数编号，集市之间通过 $M$ 条 **单向** 道路连接，通过每条道路都需要消耗一定的时间。\n\n在科巴的集市上，有 $K$ 种不同的商品，商品用从 $1$ 到 $K$ 的整数编号。每个集市对每种商品都有自己的定价，买入和卖出商品的价格可以是不同的。并非每个集市都可以买卖所有的商品：一个集市可能只提供部分商品的双向交易服务；对于一种商品，一个集市也可能只收购而不卖出该商品或只卖出而不收购该商品。如果一个集市收购一种商品，它收购这种商品的数量是不限的，同样，一个集市如果卖出一种商品，则它卖出这种商品的数量也是不限的。\n\n为了更快地获得收益，你决定寻找一条盈利效率最高的环路。环路是指带着空的背包从一个集市出发，沿着道路前进，经过若干个市场并最终回到出发点。在环路中，允许 **多次** 经过同一个集市或同一条道路。在经过集市时，你可以购买或者卖出商品，一旦你购买了一个商品，你需要把它装在背包里带走。由于你的背包非常小，任何时候你最多只能持有一个商品。在购买一个商品时，你不需要考虑你是否有足够的金钱，但在卖出时，需要注意只能卖出你拥有的商品。\n\n从环路中得到的收益为在环路中卖出商品得到的金钱减去购买商品花费的金钱，而一条环路上消耗的时间则是依次通过环路上所有道路所需要花费的时间的总和。环路的 *盈利效率* 是指从环路中得到的收益除以花费的时间。需要注意的是，一条没有任何交易的环路的盈利效率为 $0$ 。\n\n你需要求出所有 **消耗时间为正数** 的环路中，盈利效率 **最高** 的环路的盈利效率。答案 **向下取整** 保留到整数。如果没有任何一条环路可以盈利，则输出 $0$ 。", "inputFormat": "第一行包含 $3$ 个正整数，$N$ , $M$ 和 $K$，分别表示集市数量、道路数量和商品种类数量。\n\n接下来的 $N$ 行，第 $i$ 行中包含 $2K$ 个整数 $B_{i,1},S_{i,1},B_{i,2},S_{i,2},\\cdots ,B_{i,K},S_{i,K}$ 描述一个集市。对于任意的 $1\\leq j\\leq K$ ，整数 $B_{i,j},S_{i,j}$ 分别表示在编号为 $i$ 的集市上购买、卖出编号为 $j$ 的商品时的交易价格。如果一个交易价格为 $-1$，则表示这个商品在这个集市上不能进行这种交易。\n\n接下来 $M$ 行，第 $p$ 行包含 $3$ 个整数 $V_p,W_p,T_p$，表示存在一条从编号为 $V_p$ 的市场出发前往编号为 $W_p$ 的市场的路径花费 $T_p$ 分钟。\n", "outputFormat": "输出包含一个整数，表示盈利效率最高的环路盈利效率，答案 **向下取整** 保留到整数。如果没有任何一条环路可以盈利，则输出 $0$ 。\n", "hint": "### 样例解释\n\n在样例中，我们考虑下面两条环路，`1−2−3−1` 和 `1−4−3−1`。\n\n考虑环路 `1−2−3−1`：这条环路消耗的总时间是 $(3+3+1)=7$ 分钟。在这条环路中，最佳的交易方式是：在编号为 $1$ 的集市中购买编号为 $2$ 的商品（花费的金钱为 $5$）；在编号为 $2$ 的集市中卖出编号为 $2$ 的商品（得到的金钱为 $15$），然后立即购买编号为 $1$ 的商品（花费的金钱为 $6$）；带着编号为 1 的商品经过编号为 3 的集市，在回到编号为 $1$ 的城市后卖出（得到的金钱为 $9$）。在这个环路中，总盈利为 $−5+15−6+9=13$。这个环路的盈利效率为 $\\frac{13}{7}$，向下取整后为 $1$ 。\n\n考虑环路 `1−4−3−1`：这条环路消耗的总时间是 $(1+1+1)=3$ 分钟。在这条环路中，最佳的交易方式是：在编号为 $1$ 的集市中购买编号为 $2$ 的商品（花费的金钱为 $5$）；在编号为 $4$ 的集市中卖出编号为 $2$ 的商品（得到的金钱为 $11$）；然后经过编号为 $3$ 的集市回到编号为 $1$ 的城市。在这个环路中，总盈利为 $−5+11=6$ 。 这个环路的盈利效率为 $\\frac 6 3$，向下取整后为 $2$ 。\n\n综上所述，盈利效率最高的环路的盈利效率为 $2$。\n\n### 子任务\n\n在所有数据中，满足：$ 1\\le N \\le 100,1\\le M \\le 9900,1\\le K \\le 1000$，如果在编号为 $i (1\\le i\\le N)$ 的集市中，编号为 $j(1\\le j\\le K)$ 的商品既可以购买又可以卖出，则 $0\\le S_{ij}\\le B_{ij}\\le 10^9$​。\n\n对于编号为 $p (1\\le p\\le M)$ 的道路，保证 $V_p\\neq W_p$，且 $1\\le T_p\\le 10^7$。\n\n不存在满足 $1\\le p\\le q\\le M$ 的 $p,q$ 使得 $(V_p,W_p)=(V_q,W_q)$。\n\n详细子任务如下表：\n\n| 子任务编号 | 分值 |                      附加条件                       |                             解释                             |\n| :--------: | :--: | :-------------------------------------------------: | :----------------------------------------------------------: |\n|    $1$     | $12$ |       $B_{i,j}=-1\\ (2\\le i\\le N,1\\le j\\le K)$       |                   你只能在市场 $1$ 买东西                    |\n|    $2$     | $21$ |          $N,K\\le 50,T_p=1\\ (1\\le p\\le M)$           |                 所有道路通过只需要 $1$ 分钟                  |\n|    $3$     | $33$ | $B_{i,j}=S_{i,j}\\neq -1\\ (1\\le i\\le N,1\\le j\\le K)$ | 对于每个市场，在其中买卖物品的价格都是一样的（在不同市场价格可能不同） |\n|    $4$     | $34$ |                         无                          |                              无                             |\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2017] Merchant", "background": "", "description": "After a long trek across the vast Australian outback, you arrive alone in Cobar with a backpack. Captivated by the city’s prosperous and beautiful markets, you decide to settle down and become a merchant. Cobar has $N$ markets, numbered from $1$ to $N$, connected by $M$ directed roads. Traversing each road takes some amount of time.\n\nThere are $K$ different types of goods in Cobar, numbered from $1$ to $K$. Each market has its own prices for each good, and the buy and sell prices may differ. Not every market buys and sells every good: a market may support both buying and selling only for a subset of goods; for a particular good, a market may only buy but not sell, or only sell but not buy. If a market buys a certain good, the quantity it buys is unlimited; similarly, if a market sells a certain good, the quantity it sells is unlimited.\n\nTo gain profit more quickly, you decide to find the cycle with the highest profit efficiency. A cycle means starting from some market with an empty backpack, traveling along roads through several markets, and finally returning to the starting point. It is allowed to pass through the same market or the same road multiple times within the cycle. When passing a market, you may buy or sell goods. Once you buy a good, you must carry it in your backpack. Because your backpack is very small, you can hold at most one good at any time. When buying a good, you do not need to consider whether you have enough money; when selling, note that you can only sell the good you currently hold.\n\nThe profit gained from a cycle is the total money obtained from selling minus the total money spent on buying during the cycle. The time spent on a cycle is the sum of the traversal times of all roads along the cycle. The profit efficiency of a cycle is the profit divided by the time spent. Note that the profit efficiency of a cycle with no transactions is $0$.\n\nYou need to find, among all cycles with strictly positive total time, the maximum profit efficiency. Output the value floored to an integer. If no cycle can yield a positive profit, output $0$.", "inputFormat": "The first line contains $3$ positive integers $N$, $M$, and $K$, denoting the number of markets, the number of roads, and the number of goods, respectively.\n\nThe next $N$ lines describe the markets. In line $i$, there are $2K$ integers $B_{i,1}, S_{i,1}, B_{i,2}, S_{i,2}, \\cdots, B_{i,K}, S_{i,K}$. For any $1 \\le j \\le K$, the integers $B_{i,j}$ and $S_{i,j}$ denote the buying and selling price at market $i$ for good $j$, respectively. If a transaction price is $-1$, then that transaction is not available for that good at that market.\n\nThen follow $M$ lines. In line $p$, there are $3$ integers $V_p, W_p, T_p$, indicating there is a directed road from market $V_p$ to market $W_p$ with travel time $T_p$ minutes.", "outputFormat": "Output a single integer: the maximum profit efficiency over all cycles, floored to an integer. If no cycle can be profitable, output $0$.", "hint": "Sample explanation.\n\nIn the sample, consider the two cycles `1−2−3−1` and `1−4−3−1`.\n\nConsider the cycle `1−2−3−1`: the total time is $(3+3+1)=7$ minutes. The best sequence of transactions is: at market $1$, buy good $2$ (spending $5$); at market $2$, sell good $2$ (gaining $15$), then immediately buy good $1$ (spending $6$); pass through market $3$ carrying good $1$, and upon returning to market $1$, sell it (gaining $9$). The total profit is $-5+15-6+9=13$. The profit efficiency is $\\frac{13}{7}$, whose floor is $1$.\n\nConsider the cycle `1−4−3−1`: the total time is $(1+1+1)=3$ minutes. The best sequence of transactions is: at market $1$, buy good $2$ (spending $5$); at market $4$, sell good $2$ (gaining $11$); then pass through market $3$ and return to market $1$. The total profit is $-5+11=6$. The profit efficiency is $\\frac 6 3$, whose floor is $2$.\n\nTherefore, the maximum profit efficiency over all cycles is $2$.\n\nSubtasks.\n\nAcross all testdata, the following hold: $1 \\le N \\le 100$, $1 \\le M \\le 9900$, $1 \\le K \\le 1000$. If in market $i$ for good $j$ both buying and selling are available, then $0 \\le S_{i,j} \\le B_{i,j} \\le 10^9$. For road $p$ ($1 \\le p \\le M$), it is guaranteed that $V_p \\ne W_p$ and $1 \\le T_p \\le 10^7$. There do not exist indices $p, q$ with $1 \\le p \\le q \\le M$ such that $(V_p, W_p) = (V_q, W_q)$.\n\n| Subtask | Score | Additional conditions | Explanation |\n| :-----: | :---: | :-------------------: | :---------: |\n| $1$ | $12$ | $B_{i,j}=-1\\ (2\\le i\\le N, 1\\le j\\le K)$ | You can only buy goods at market $1$. |\n| $2$ | $21$ | $N, K \\le 50, \\ T_p=1\\ (1\\le p\\le M)$ | All roads take $1$ minute to traverse. |\n| $3$ | $33$ | $B_{i,j}=S_{i,j}\\neq -1\\ (1\\le i\\le N, 1\\le j\\le K)$ | At each market, the buy and sell prices are the same (prices may differ across markets). |\n| $4$ | $34$ | None | None. |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2017] 商旅", "background": "", "description": "在广阔的澳大利亚内陆地区长途跋涉后，你孤身一人带着一个背包来到了科巴。你被这个城市发达而美丽的市场所深深吸引，决定定居于此，做一个商人。科巴有 $N$ 个集市，集市用从 $1$ 到 $N$ 的整数编号，集市之间通过 $M$ 条 **单向** 道路连接，通过每条道路都需要消耗一定的时间。\n\n在科巴的集市上，有 $K$ 种不同的商品，商品用从 $1$ 到 $K$ 的整数编号。每个集市对每种商品都有自己的定价，买入和卖出商品的价格可以是不同的。并非每个集市都可以买卖所有的商品：一个集市可能只提供部分商品的双向交易服务；对于一种商品，一个集市也可能只收购而不卖出该商品或只卖出而不收购该商品。如果一个集市收购一种商品，它收购这种商品的数量是不限的，同样，一个集市如果卖出一种商品，则它卖出这种商品的数量也是不限的。\n\n为了更快地获得收益，你决定寻找一条盈利效率最高的环路。环路是指带着空的背包从一个集市出发，沿着道路前进，经过若干个市场并最终回到出发点。在环路中，允许 **多次** 经过同一个集市或同一条道路。在经过集市时，你可以购买或者卖出商品，一旦你购买了一个商品，你需要把它装在背包里带走。由于你的背包非常小，任何时候你最多只能持有一个商品。在购买一个商品时，你不需要考虑你是否有足够的金钱，但在卖出时，需要注意只能卖出你拥有的商品。\n\n从环路中得到的收益为在环路中卖出商品得到的金钱减去购买商品花费的金钱，而一条环路上消耗的时间则是依次通过环路上所有道路所需要花费的时间的总和。环路的 *盈利效率* 是指从环路中得到的收益除以花费的时间。需要注意的是，一条没有任何交易的环路的盈利效率为 $0$ 。\n\n你需要求出所有 **消耗时间为正数** 的环路中，盈利效率 **最高** 的环路的盈利效率。答案 **向下取整** 保留到整数。如果没有任何一条环路可以盈利，则输出 $0$ 。", "inputFormat": "第一行包含 $3$ 个正整数，$N$ , $M$ 和 $K$，分别表示集市数量、道路数量和商品种类数量。\n\n接下来的 $N$ 行，第 $i$ 行中包含 $2K$ 个整数 $B_{i,1},S_{i,1},B_{i,2},S_{i,2},\\cdots ,B_{i,K},S_{i,K}$ 描述一个集市。对于任意的 $1\\leq j\\leq K$ ，整数 $B_{i,j},S_{i,j}$ 分别表示在编号为 $i$ 的集市上购买、卖出编号为 $j$ 的商品时的交易价格。如果一个交易价格为 $-1$，则表示这个商品在这个集市上不能进行这种交易。\n\n接下来 $M$ 行，第 $p$ 行包含 $3$ 个整数 $V_p,W_p,T_p$，表示存在一条从编号为 $V_p$ 的市场出发前往编号为 $W_p$ 的市场的路径花费 $T_p$ 分钟。\n", "outputFormat": "输出包含一个整数，表示盈利效率最高的环路盈利效率，答案 **向下取整** 保留到整数。如果没有任何一条环路可以盈利，则输出 $0$ 。\n", "hint": "### 样例解释\n\n在样例中，我们考虑下面两条环路，`1−2−3−1` 和 `1−4−3−1`。\n\n考虑环路 `1−2−3−1`：这条环路消耗的总时间是 $(3+3+1)=7$ 分钟。在这条环路中，最佳的交易方式是：在编号为 $1$ 的集市中购买编号为 $2$ 的商品（花费的金钱为 $5$）；在编号为 $2$ 的集市中卖出编号为 $2$ 的商品（得到的金钱为 $15$），然后立即购买编号为 $1$ 的商品（花费的金钱为 $6$）；带着编号为 1 的商品经过编号为 3 的集市，在回到编号为 $1$ 的城市后卖出（得到的金钱为 $9$）。在这个环路中，总盈利为 $−5+15−6+9=13$。这个环路的盈利效率为 $\\frac{13}{7}$，向下取整后为 $1$ 。\n\n考虑环路 `1−4−3−1`：这条环路消耗的总时间是 $(1+1+1)=3$ 分钟。在这条环路中，最佳的交易方式是：在编号为 $1$ 的集市中购买编号为 $2$ 的商品（花费的金钱为 $5$）；在编号为 $4$ 的集市中卖出编号为 $2$ 的商品（得到的金钱为 $11$）；然后经过编号为 $3$ 的集市回到编号为 $1$ 的城市。在这个环路中，总盈利为 $−5+11=6$ 。 这个环路的盈利效率为 $\\frac 6 3$，向下取整后为 $2$ 。\n\n综上所述，盈利效率最高的环路的盈利效率为 $2$。\n\n### 子任务\n\n在所有数据中，满足：$ 1\\le N \\le 100,1\\le M \\le 9900,1\\le K \\le 1000$，如果在编号为 $i (1\\le i\\le N)$ 的集市中，编号为 $j(1\\le j\\le K)$ 的商品既可以购买又可以卖出，则 $0\\le S_{ij}\\le B_{ij}\\le 10^9$​。\n\n对于编号为 $p (1\\le p\\le M)$ 的道路，保证 $V_p\\neq W_p$，且 $1\\le T_p\\le 10^7$。\n\n不存在满足 $1\\le p\\le q\\le M$ 的 $p,q$ 使得 $(V_p,W_p)=(V_q,W_q)$。\n\n详细子任务如下表：\n\n| 子任务编号 | 分值 |                      附加条件                       |                             解释                             |\n| :--------: | :--: | :-------------------------------------------------: | :----------------------------------------------------------: |\n|    $1$     | $12$ |       $B_{i,j}=-1\\ (2\\le i\\le N,1\\le j\\le K)$       |                   你只能在市场 $1$ 买东西                    |\n|    $2$     | $21$ |          $N,K\\le 50,T_p=1\\ (1\\le p\\le M)$           |                 所有道路通过只需要 $1$ 分钟                  |\n|    $3$     | $33$ | $B_{i,j}=S_{i,j}\\neq -1\\ (1\\le i\\le N,1\\le j\\le K)$ | 对于每个市场，在其中买卖物品的价格都是一样的（在不同市场价格可能不同） |\n|    $4$     | $34$ |                         无                          |                              无                             |\n\n", "locale": "zh-CN"}}}
{"pid": "P3779", "type": "P", "difficulty": 7, "samples": [["1\n2 19\n0 0\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n0 7\n0 8\n0 9", "0.000002\n0.000038\n0.000364\n0.002213\n0.009605\n0.031784\n0.083534\n0.179642\n0.323803\n0.500000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1500, 2000, 2000, 3000, 3500, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "各省省选", "山东", "Special Judge", "O2优化", "期望", "积分"], "title": "[SDOI2017] 龙与地下城", "background": "", "description": "小 Q 同学是一个热爱学习的人，但是他最近沉迷于各种游戏，龙与地下城就是其中之一。\n\n在这个游戏中，很多场合需要通过掷骰子来产生随机数，并由此决定角色未来的命运，因此骰子堪称该游戏的标志性道具。\n\n骰子也分为许多种类，比如 $4$ 面骰、$6$ 面骰、$8$ 面骰、$12$ 面骰、$20$ 面骰，其中 $20$ 面骰用到的机会非常多。当然，现在科技发达，可以用一个随机数生成器来取代真实的骰子，所以这里**认为骰子就是一个随机数生成器**。\n\n在战斗中，骰子主要用来决定角色的攻击是否命中，以及命中后造成的伤害值。举个例子，假设现在已经确定能够命中敌人，那么 $YdX$（也就是掷出 $Y$ 个 $X$ 面骰子之后所有骰子显示的数字之和）就是对敌人的基础伤害。在敌人没有防御的情况下，这个基础伤害就是真实伤害。\n\n众所周知，骰子显示每个数的概率应该是相等的，也就是说，对于一个 $X$ 面骰子，显示 $0, 1, 2,\\dots ,X−1$ 中每一个数字的概率都是 $\\dfrac {1}{X}$。\n\n更形式化地说，这个骰子显示的数 $W$ 满足离散的均匀分布，其分布列为\n\n| $H$ | $0$ | $1$ | $2$ | $\\cdots$ | $X-1$ |\n| :--: | :--: | :--: | :--: | :--: | :--: |\n| $P$ | $\\dfrac {1}{X}$ | $\\dfrac {1}{X}$ | $\\dfrac {1}{X}$ | $\\cdots$ | $\\dfrac {1}{X}$ |\n\n\n除此之外还有一些性质：\n\n- $W$ 的**一阶原点矩**（**期望**）为\n\n$$v_1(W)=E(W)=\\sum_{i=0}^{X-1}i\\cdot P(W=i)=\\frac {X-1}{2}$$\n\n- $W$ 的**二阶中心矩**（**方差**）为\n\n$$\\mu_2(W)=E((W-E(W))^2)=\\sum_{i=0}^{X-1}(i-E(W))^2\\cdot P(W=i)=\\frac {X^2-1}{12}$$\n\n言归正传，现在小 Q 同学面对着一个生命值为 A 的没有防御的敌人，能够发动一次必中的 $YdX$ 攻击，显然只有造成的伤害不少于敌人的生命值才能打倒敌人。但是另一方面，小 Q 同学作为强迫症患者，不希望出现 overkill，也就是造成的伤害大于 $B$ 的情况，因此**只有在打倒敌人并且不发生 overkill 的情况下小 Q 同学才会认为取得了属于他的胜利**。\n\n因为小 Q 同学非常谨慎，他会进行 $10$ 次模拟战，每次给出敌人的生命值 $A$以及 overkill 的标准 $B$，他想知道此时取得属于他的胜利的概率是多少，你能帮帮他吗？\n", "inputFormat": "第一行是一个正整数 $T$，表示测试数据的组数，\n\n对于每组测试数据：\n\n第一行是两个整数 $X,Y$，分别表示骰子的面数以及骰子的个数；\n\n接下来 $10$ 行，每行包含两个整数 $A,B$，分别表示敌人的生命值 $A$ 以及 overkill 的标准 $B$。", "outputFormat": "对于每组测试数据，输出 $10$ 行，对每个询问输出一个实数，要求绝对误差不超过 $0.013\\, 579$。\n\n也就是说，记输出为 $a$，答案为 $b$，若满足 $|a-b|\\leq 0.013\\,579$，则认为输出是正确的。", "hint": "对于 $100\\%$ 的数据，$T \\leq 10$，$2 \\leq X \\leq 20$，$1 \\leq Y \\leq 200000$，$0 \\leq A \\leq B \\leq (X-1)Y$。\n\n**保证满足 $Y > 800$ 的数据不超过 $2$ 组。**\n\n| 测试点编号 | $X$ | $Y$ | 备注 |\n| :--: | :--: | :--: | :--: |\n| $1$ | $\\le 20$ | $\\le 40$ | $X^Y\\le 10^7$ |\n| $2\\sim 4$ | $\\le 20$ | $\\le 1\\, 600$ | - |\n| $5\\sim 10$ | $\\le 20$ | $\\le 8\\, 000$ | - |\n| $11,12$ | $=2$ | $\\le 200\\, 000$ | - |\n| $13\\sim 20$ | $\\le 20$ | $\\le 200\\, 000$ | - |\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2017] Dungeons and Dragons", "background": "", "description": "Xiao Q is a student who loves studying, but he has recently been obsessed with various games, and Dungeons and Dragons is one of them.\n\nIn this game, many situations require rolling dice to generate random numbers, which then determine the character’s fate. Therefore, dice are iconic props in this game.\n\nThere are many kinds of dice, such as the $4$-sided die, $6$-sided die, $8$-sided die, $12$-sided die, and $20$-sided die, among which the $20$-sided die is used very often. Of course, with modern technology, a random number generator can replace a real die, so here we assume that a die is a random number generator.\n\nIn battles, dice are mainly used to determine whether an attack hits and, if it hits, the damage dealt. For example, suppose we already know the attack will hit; then $YdX$ (i.e., roll $Y$ $X$-sided dice and sum all numbers shown) is the base damage dealt to the enemy. If the enemy has no defense, this base damage is the actual damage.\n\nIt is well known that each face of a die has the same probability. That is, for an $X$-sided die, each number among $0, 1, 2, \\dots, X-1$ appears with probability $\\dfrac{1}{X}$.\n\nMore formally, the number shown by this die, $W$, follows a discrete uniform distribution, with the following distribution table:\n\n| $W$ | $0$ | $1$ | $2$ | $\\cdots$ | $X-1$ |\n| :--: | :--: | :--: | :--: | :--: | :--: |\n| $P$ | $\\dfrac {1}{X}$ | $\\dfrac {1}{X}$ | $\\dfrac {1}{X}$ | $\\cdots$ | $\\dfrac {1}{X}$ |\n\nIn addition, it has the following properties:\n\n- The first raw moment (expectation) of $W$ is\n$$v_1(W)=E(W)=\\sum_{i=0}^{X-1}i\\cdot P(W=i)=\\frac {X-1}{2}.$$\n\n- The second central moment (variance) of $W$ is\n$$\\mu_2(W)=E((W-E(W))^2)=\\sum_{i=0}^{X-1}(i-E(W))^2\\cdot P(W=i)=\\frac {X^2-1}{12}.$$\n\nBack to the point: Now Xiao Q faces an enemy with health $A$, has no defense, and he can make one guaranteed-hit $YdX$ attack. Obviously, only damage not less than the enemy’s health can defeat the enemy. On the other hand, as a perfectionist, Xiao Q does not want “overkill,” i.e., dealing damage greater than $B$. Therefore, Xiao Q considers it his victory only if he both defeats the enemy and does not have “overkill.”\n\nBecause Xiao Q is very cautious, he will run $10$ mock battles. Each time, he gives the enemy’s health $A$ and the overkill threshold $B$. He wants to know the probability of achieving his own victory under these conditions. Can you help him?", "inputFormat": "The first line contains a positive integer $T$, the number of test cases.\n\nFor each test case:\n\n- The first line contains two integers $X, Y$, the number of faces of the die and the number of dice, respectively.\n- Then follow $10$ lines, each containing two integers $A, B$, representing the enemy’s health $A$ and the overkill threshold $B$.", "outputFormat": "For each test case, output $10$ lines. For each query, output a real number. The absolute error must not exceed $0.013\\, 579$.\n\nThat is, let the output be $a$ and the correct answer be $b$. If $|a-b|\\leq 0.013\\,579$, the output is considered correct.", "hint": "For $100\\%$ of the testdata, $T \\leq 10$, $2 \\leq X \\leq 20$, $1 \\leq Y \\leq 200000$, $0 \\leq A \\leq B \\leq (X-1)Y$.\n\n**It is guaranteed that there are at most $2$ test cases with $Y > 800$.**\n\n| Test point ID | $X$ | $Y$ | Note |\n| :--: | :--: | :--: | :--: |\n| $1$ | $\\le 20$ | $\\le 40$ | $X^Y\\le 10^7$ |\n| $2\\sim 4$ | $\\le 20$ | $\\le 1\\, 600$ | - |\n| $5\\sim 10$ | $\\le 20$ | $\\le 8\\, 000$ | - |\n| $11,12$ | $=2$ | $\\le 200\\, 000$ | - |\n| $13\\sim 20$ | $\\le 20$ | $\\le 200\\, 000$ | - |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2017] 龙与地下城", "background": "", "description": "小 Q 同学是一个热爱学习的人，但是他最近沉迷于各种游戏，龙与地下城就是其中之一。\n\n在这个游戏中，很多场合需要通过掷骰子来产生随机数，并由此决定角色未来的命运，因此骰子堪称该游戏的标志性道具。\n\n骰子也分为许多种类，比如 $4$ 面骰、$6$ 面骰、$8$ 面骰、$12$ 面骰、$20$ 面骰，其中 $20$ 面骰用到的机会非常多。当然，现在科技发达，可以用一个随机数生成器来取代真实的骰子，所以这里**认为骰子就是一个随机数生成器**。\n\n在战斗中，骰子主要用来决定角色的攻击是否命中，以及命中后造成的伤害值。举个例子，假设现在已经确定能够命中敌人，那么 $YdX$（也就是掷出 $Y$ 个 $X$ 面骰子之后所有骰子显示的数字之和）就是对敌人的基础伤害。在敌人没有防御的情况下，这个基础伤害就是真实伤害。\n\n众所周知，骰子显示每个数的概率应该是相等的，也就是说，对于一个 $X$ 面骰子，显示 $0, 1, 2,\\dots ,X−1$ 中每一个数字的概率都是 $\\dfrac {1}{X}$。\n\n更形式化地说，这个骰子显示的数 $W$ 满足离散的均匀分布，其分布列为\n\n| $H$ | $0$ | $1$ | $2$ | $\\cdots$ | $X-1$ |\n| :--: | :--: | :--: | :--: | :--: | :--: |\n| $P$ | $\\dfrac {1}{X}$ | $\\dfrac {1}{X}$ | $\\dfrac {1}{X}$ | $\\cdots$ | $\\dfrac {1}{X}$ |\n\n\n除此之外还有一些性质：\n\n- $W$ 的**一阶原点矩**（**期望**）为\n\n$$v_1(W)=E(W)=\\sum_{i=0}^{X-1}i\\cdot P(W=i)=\\frac {X-1}{2}$$\n\n- $W$ 的**二阶中心矩**（**方差**）为\n\n$$\\mu_2(W)=E((W-E(W))^2)=\\sum_{i=0}^{X-1}(i-E(W))^2\\cdot P(W=i)=\\frac {X^2-1}{12}$$\n\n言归正传，现在小 Q 同学面对着一个生命值为 A 的没有防御的敌人，能够发动一次必中的 $YdX$ 攻击，显然只有造成的伤害不少于敌人的生命值才能打倒敌人。但是另一方面，小 Q 同学作为强迫症患者，不希望出现 overkill，也就是造成的伤害大于 $B$ 的情况，因此**只有在打倒敌人并且不发生 overkill 的情况下小 Q 同学才会认为取得了属于他的胜利**。\n\n因为小 Q 同学非常谨慎，他会进行 $10$ 次模拟战，每次给出敌人的生命值 $A$以及 overkill 的标准 $B$，他想知道此时取得属于他的胜利的概率是多少，你能帮帮他吗？\n", "inputFormat": "第一行是一个正整数 $T$，表示测试数据的组数，\n\n对于每组测试数据：\n\n第一行是两个整数 $X,Y$，分别表示骰子的面数以及骰子的个数；\n\n接下来 $10$ 行，每行包含两个整数 $A,B$，分别表示敌人的生命值 $A$ 以及 overkill 的标准 $B$。", "outputFormat": "对于每组测试数据，输出 $10$ 行，对每个询问输出一个实数，要求绝对误差不超过 $0.013\\, 579$。\n\n也就是说，记输出为 $a$，答案为 $b$，若满足 $|a-b|\\leq 0.013\\,579$，则认为输出是正确的。", "hint": "对于 $100\\%$ 的数据，$T \\leq 10$，$2 \\leq X \\leq 20$，$1 \\leq Y \\leq 200000$，$0 \\leq A \\leq B \\leq (X-1)Y$。\n\n**保证满足 $Y > 800$ 的数据不超过 $2$ 组。**\n\n| 测试点编号 | $X$ | $Y$ | 备注 |\n| :--: | :--: | :--: | :--: |\n| $1$ | $\\le 20$ | $\\le 40$ | $X^Y\\le 10^7$ |\n| $2\\sim 4$ | $\\le 20$ | $\\le 1\\, 600$ | - |\n| $5\\sim 10$ | $\\le 20$ | $\\le 8\\, 000$ | - |\n| $11,12$ | $=2$ | $\\le 200\\, 000$ | - |\n| $13\\sim 20$ | $\\le 20$ | $\\le 200\\, 000$ | - |\n", "locale": "zh-CN"}}}
{"pid": "P3780", "type": "P", "difficulty": 7, "samples": [["2\n5 1\n0 1 1\n1 1 1\n1 1 3\n2 1 10\n3 1 4\n9 15\n0 1 1\n1 7 2\n2 5 10\n1 3 1\n4 3 17\n4 3 18\n4 4 19\n1 1 1\n8 1 100", "15\n316"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "各省省选", "单调队列", "山东", "O2优化", "枚举", "背包 DP"], "title": "[SDOI2017] 苹果树", "background": "**提示：第三档部分分中正确的数据范围应为 $v_i=1$，为尊重原题未进行数据范围修改**。", "description": "夏天近了，又到了恋爱的季节，小 Q 家门前的苹果树上结满了红红圆圆的苹果。\n\n这株苹果树是一个有着 $n$ 个结点的有根树，其中结点被依次编号为 $1$ 至 $n$。$1$ 号结点为根，其余每一个结点的父结点一定是某个编号较小的结点。每一个结点上都有一些苹果，第 $i$ 个结点上有 $a_i (a_i > 0)$ 个苹果，每取走其中一个苹果就可以得到 $v_i (v_i > 0)$ 的幸福度（若在这个结点取走 $k \\leq a_i$ 个苹果，则可以收获 $kv_i$ 的幸福度）。如果在一个结点取走了至少一个苹果，则必须要在其父结点处取走至少一个苹果。\n\n现在，给定正整数 $k$，请从树上取走若干苹果。如果总计取走了 $t$ 个苹果，且所有取了至少一个苹果的那些结点的最大深度为 $h$（这里规定根结点的深度为 $1$），则要求 $t-h \\leq k$。问最大可以收获多少的幸福度？（这些幸福度全都归属于恋爱中的小 Q。）", "inputFormat": "本题有多组测试数据，输入的第一行给定整数 $Q$，表示有 $Q$ 组数据。之后依次给出 $Q$ 组数据。\n\n对于每一组数据来说，第一行包含两个整数 $n$ 和 $k$。\n\n之后 $n$ 行，每行给出三个整数，描述了每一个结点。其中第 $i$ 行的第一个整数给出了 $i$ 的父结点标号（如果 $i = 1$，则其父结点为 $0$），第二个整数为 $a_i$，第三个整数为 $v_i$。", "outputFormat": "输出一共有 $Q$ 行，对应了 $Q$ 组数据。\n\n对于每一组数据，输出一个整数，表示最大可以收获的幸福度。", "hint": "- 有 $10\\%$ 的数据，满足 $nk \\leq 3000000$ 且给定的树的高度为 $2$。\n- 有 $20\\%$ 的数据，满足 $nk \\leq 25000000$ 且给定的树的高度为 $2$。\n- 有 $20\\%$ 的数据，满足 $nk \\leq 25000000$ 且所有 $a_i$ 均为 $1$。\n- 还有 $20\\%$ 的数据，满足 $nk \\leq 3000000$，没有上述额外限制。\n- 对于 $100\\%$ 的数据，满足 $1 \\leq Q \\leq 5$；$1 \\leq n \\leq 20000$；$1 \\leq k \\leq 500000$；$1 \\leq nk \\leq 25000000$；$1 \\leq a_i \\leq 10^8$；$1 \\leq v_i \\leq 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2017] Apple Tree", "background": "**Tip: In the third partial score, the correct constraint should be $v_i=1$. To respect the original problem, the constraints are not modified.**", "description": "Summer is coming, and it is the season of love. The apple tree in front of Little Q’s house is full of bright red round apples.\n\nThis apple tree is a rooted tree with $n$ nodes, numbered $1$ to $n$. Node $1$ is the root. For every other node, its parent is guaranteed to be a node with a smaller index. Each node has some apples. The $i$-th node has $a_i (a_i > 0)$ apples, and taking one apple from this node gives $v_i (v_i > 0)$ happiness (if you take $k \\leq a_i$ apples from this node, you gain $kv_i$ happiness). If you take at least one apple from a node, then you must also take at least one apple from its parent.\n\nYou are given a positive integer $k$. Pick some apples from the tree. If in total you pick $t$ apples, and among all nodes from which at least one apple is picked, the maximum depth is $h$ (the root has depth $1$), then you must satisfy $t-h \\leq k$. Find the maximum total happiness you can obtain.", "inputFormat": "There are multiple testcases. The first line contains an integer $Q$, the number of testcases.\n\nFor each testcase, the first line contains two integers $n$ and $k$.\n\nThen $n$ lines follow, each describing one node. On the $i$-th line, the first integer is the index of the parent of node $i$ (if $i = 1$, its parent is $0$), the second integer is $a_i$, and the third integer is $v_i$.", "outputFormat": "Output $Q$ lines, one per testcase.\n\nFor each testcase, output a single integer, the maximum total happiness that can be obtained.", "hint": "- For $10\\%$ of the testdata, $nk \\leq 3000000$ and the height of the tree is $2$.\n- For $20\\%$ of the testdata, $nk \\leq 25000000$ and the height of the tree is $2$.\n- For $20\\%$ of the testdata, $nk \\leq 25000000$ and all $a_i$ are $1$.\n- For another $20\\%$ of the testdata, $nk \\leq 3000000$ with no additional restrictions.\n- Constraints for $100\\%$ of the testdata: $1 \\leq Q \\leq 5$; $1 \\leq n \\leq 20000$; $1 \\leq k \\leq 500000$; $1 \\leq nk \\leq 25000000$; $1 \\leq a_i \\leq 10^8$; $1 \\leq v_i \\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2017] 苹果树", "background": "**提示：第三档部分分中正确的数据范围应为 $v_i=1$，为尊重原题未进行数据范围修改**。", "description": "夏天近了，又到了恋爱的季节，小 Q 家门前的苹果树上结满了红红圆圆的苹果。\n\n这株苹果树是一个有着 $n$ 个结点的有根树，其中结点被依次编号为 $1$ 至 $n$。$1$ 号结点为根，其余每一个结点的父结点一定是某个编号较小的结点。每一个结点上都有一些苹果，第 $i$ 个结点上有 $a_i (a_i > 0)$ 个苹果，每取走其中一个苹果就可以得到 $v_i (v_i > 0)$ 的幸福度（若在这个结点取走 $k \\leq a_i$ 个苹果，则可以收获 $kv_i$ 的幸福度）。如果在一个结点取走了至少一个苹果，则必须要在其父结点处取走至少一个苹果。\n\n现在，给定正整数 $k$，请从树上取走若干苹果。如果总计取走了 $t$ 个苹果，且所有取了至少一个苹果的那些结点的最大深度为 $h$（这里规定根结点的深度为 $1$），则要求 $t-h \\leq k$。问最大可以收获多少的幸福度？（这些幸福度全都归属于恋爱中的小 Q。）", "inputFormat": "本题有多组测试数据，输入的第一行给定整数 $Q$，表示有 $Q$ 组数据。之后依次给出 $Q$ 组数据。\n\n对于每一组数据来说，第一行包含两个整数 $n$ 和 $k$。\n\n之后 $n$ 行，每行给出三个整数，描述了每一个结点。其中第 $i$ 行的第一个整数给出了 $i$ 的父结点标号（如果 $i = 1$，则其父结点为 $0$），第二个整数为 $a_i$，第三个整数为 $v_i$。", "outputFormat": "输出一共有 $Q$ 行，对应了 $Q$ 组数据。\n\n对于每一组数据，输出一个整数，表示最大可以收获的幸福度。", "hint": "- 有 $10\\%$ 的数据，满足 $nk \\leq 3000000$ 且给定的树的高度为 $2$。\n- 有 $20\\%$ 的数据，满足 $nk \\leq 25000000$ 且给定的树的高度为 $2$。\n- 有 $20\\%$ 的数据，满足 $nk \\leq 25000000$ 且所有 $a_i$ 均为 $1$。\n- 还有 $20\\%$ 的数据，满足 $nk \\leq 3000000$，没有上述额外限制。\n- 对于 $100\\%$ 的数据，满足 $1 \\leq Q \\leq 5$；$1 \\leq n \\leq 20000$；$1 \\leq k \\leq 500000$；$1 \\leq nk \\leq 25000000$；$1 \\leq a_i \\leq 10^8$；$1 \\leq v_i \\leq 100$。", "locale": "zh-CN"}}}
{"pid": "P3781", "type": "P", "difficulty": 7, "samples": [["4 4\n2 0 1 3\n1 2\n1 3\n1 4\n12\nQuery 0\nQuery 1\nQuery 2\nQuery 3\nChange 1 0\nChange 2 1\nChange 3 3\nChange 4 1\nQuery 0\nQuery 1\nQuery 2\nQuery 3", "3\n3\n2\n3\n2\n4\n2\n3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "线段树", "各省省选", "山东", "树链剖分", "矩阵乘法", "动态 DP", "全局平衡二叉树"], "title": "[SDOI2017] 切树游戏", "background": "hack数据 by boshi & Remmina", "description": "小Q是一个热爱学习的人，他经常去维基百科学习计算机科学。\n\n就在刚才，小Q认真地学习了一系列位运算符，其中按位异或的运算符$\\oplus$对他影响很大。按位异或的运算符是双目运算符。按位异或具有交换律，即$i \\oplus j = j \\oplus i$。\n\n他发现，按位异或可以理解成被运算的数字的二进制位对应位如果相同，则结果的该位置为$0$，否则为$1$，例如：$1(01) \\oplus 2(10) = 3(11)$。\n\n他还发现，按位异或可以理解成参与运算的数字的每个二进制位都进行了不进位的加法，例如：$3(11) \\oplus 3(11) = 0(00)$。\n\n现在小Q有一棵$n$个结点的无根树$T$，结点依次编号为$1$到$n$，其中结点$i$的权值为$v_i$。\n\n定义一棵树的价值为它所有点的权值的异或和，一棵树$T$的连通子树就是它的一个连通子图，并且这个图也是一棵树。\n\n小Q想要在这棵树上玩切树游戏，他会不断做以下两种操作：\n\n- `Change x y` 将编号为$x$的结点的权值修改为$y$。\n\n- `Query k` 询问有多少棵$T$的非空连通子树，满足其价值恰好为$k$。\n\n小Q非常喜(bu)欢(hui)数学，他希望你能快速回答他的问题，你能写个程序帮帮他吗？\n", "inputFormat": "第一行包含两个正整数$n$ , $m$，分别表示结点的个数以及权值的上限。\n\n第二行包含$n$个非负整数$v_1, v_2,\\dots , v_n$，分别表示每个结点一开始的权值。\n\n接下来$n-1$行，每行包含两个正整数$a_i , b_i$，表示有一条连接$a_i$和$b_i$的无向树边。\n\n接下来一行包含一个正整数$q$，表示小Q操作的次数。\n\n接下来$q$行每行依次表示每个操作。\n", "outputFormat": "输出若干行，每行一个整数，依次回答每个询问。因为答案可能很大，所以请对$10007$取模输出。\n", "hint": "对于$100\\%$的数据，$1 \\leq a_i,b_i,x \\leq n$ , $0 \\leq v_i,y,k < m$，修改操作不超过$10000$个。\n\n![](https://cdn.luogu.com.cn/upload/pic/5534.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2017] Cut Tree Game", "background": "Hack testdata by boshi & Remmina.", "description": "Xiao Q is someone who loves to learn. He often goes to Wikipedia to study computer science.\n\nJust now, Xiao Q carefully studied a series of bitwise operators, among which the bitwise XOR operator $\\oplus$ impressed him a lot. The bitwise XOR operator is a binary operator. Bitwise XOR is commutative, i.e., $i \\oplus j = j \\oplus i$.\n\nHe found that bitwise XOR can be understood as: for the binary representations of the numbers being operated on, if the corresponding bits are the same, then the result’s bit is $0$, otherwise it is $1$, for example: $1(01) \\oplus 2(10) = 3(11)$.\n\nHe also found that bitwise XOR can be understood as performing addition without carry on each binary bit of the numbers involved, for example: $3(11) \\oplus 3(11) = 0(00)$.\n\nNow Xiao Q has an unrooted tree $T$ with $n$ nodes, numbered from $1$ to $n$, where the weight of node $i$ is $v_i$.\n\nDefine the value of a tree as the XOR of the weights of all its nodes. A connected subtree of a tree $T$ is a connected subgraph of $T$ that is also a tree.\n\nXiao Q wants to play a cut-tree game on this tree. He will repeatedly perform the following two operations:\n\n- Change x y: change the weight of node $x$ to $y$.\n- Query k: ask how many nonempty connected subtrees of $T$ have value exactly $k$.\n\nXiao Q really likes (but is not good at) math, and he hopes you can answer his questions quickly. Can you write a program to help him?", "inputFormat": "- The first line contains two positive integers $n$, $m$, representing the number of nodes and the upper bound of weights.\n- The second line contains $n$ nonnegative integers $v_1, v_2, \\dots, v_n$, representing the initial weight of each node.\n- The next $n - 1$ lines each contain two positive integers $a_i$, $b_i$, indicating that there is an undirected tree edge connecting $a_i$ and $b_i$.\n- The next line contains a positive integer $q$, representing the number of operations Xiao Q performs.\n- The next $q$ lines each describe one operation in order.", "outputFormat": "Output several lines, each containing one integer, answering each query in order. Since the answer may be large, output it modulo $10007$.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\leq a_i, b_i, x \\leq n$, $0 \\leq v_i, y, k < m$, and the number of Change operations does not exceed $10000$.\n\n![](https://cdn.luogu.com.cn/upload/pic/5534.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2017] 切树游戏", "background": "hack数据 by boshi & Remmina", "description": "小Q是一个热爱学习的人，他经常去维基百科学习计算机科学。\n\n就在刚才，小Q认真地学习了一系列位运算符，其中按位异或的运算符$\\oplus$对他影响很大。按位异或的运算符是双目运算符。按位异或具有交换律，即$i \\oplus j = j \\oplus i$。\n\n他发现，按位异或可以理解成被运算的数字的二进制位对应位如果相同，则结果的该位置为$0$，否则为$1$，例如：$1(01) \\oplus 2(10) = 3(11)$。\n\n他还发现，按位异或可以理解成参与运算的数字的每个二进制位都进行了不进位的加法，例如：$3(11) \\oplus 3(11) = 0(00)$。\n\n现在小Q有一棵$n$个结点的无根树$T$，结点依次编号为$1$到$n$，其中结点$i$的权值为$v_i$。\n\n定义一棵树的价值为它所有点的权值的异或和，一棵树$T$的连通子树就是它的一个连通子图，并且这个图也是一棵树。\n\n小Q想要在这棵树上玩切树游戏，他会不断做以下两种操作：\n\n- `Change x y` 将编号为$x$的结点的权值修改为$y$。\n\n- `Query k` 询问有多少棵$T$的非空连通子树，满足其价值恰好为$k$。\n\n小Q非常喜(bu)欢(hui)数学，他希望你能快速回答他的问题，你能写个程序帮帮他吗？\n", "inputFormat": "第一行包含两个正整数$n$ , $m$，分别表示结点的个数以及权值的上限。\n\n第二行包含$n$个非负整数$v_1, v_2,\\dots , v_n$，分别表示每个结点一开始的权值。\n\n接下来$n-1$行，每行包含两个正整数$a_i , b_i$，表示有一条连接$a_i$和$b_i$的无向树边。\n\n接下来一行包含一个正整数$q$，表示小Q操作的次数。\n\n接下来$q$行每行依次表示每个操作。\n", "outputFormat": "输出若干行，每行一个整数，依次回答每个询问。因为答案可能很大，所以请对$10007$取模输出。\n", "hint": "对于$100\\%$的数据，$1 \\leq a_i,b_i,x \\leq n$ , $0 \\leq v_i,y,k < m$，修改操作不超过$10000$个。\n\n![](https://cdn.luogu.com.cn/upload/pic/5534.png)\n", "locale": "zh-CN"}}}
{"pid": "P3782", "type": "P", "difficulty": 7, "samples": [["0\n1\n3 5 4\n1 2 5 3 4\n3 4 5 1 2\n3 1 4 2 5", "7\n1 2 1\n3 4 1\n2 3 2\n4 5 2\n1 2 3\n3 4 3\n2 3 4"]], "limits": {"time": [7500, 7500, 7500, 7500, 7500, 7500, 7500, 7500], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "提交答案", "Special Judge", "WC"], "title": "[WC2017] 排序", "background": "**本题暂时只能使用代码提交。**\n\n", "description": "牛牛最近学习了排序的相关知识。他对排序算法的运行效率产生了浓厚的兴趣并对此展开了一系列的研究。\n\n为了优化排序的运行时间，牛牛找到了来参加冬令营的你，希望你帮助他设计一台计算机进行排序（**升序**）。\n\n这台计算机的设计方法如下：\n\n- 需要进行排序的序列存储在大小为 $n$ 的数组 $Q$ 中。\n\n- 进行计算的最小单元是比较器，一个比较器可以用一个三元组 $(i,j,t)$ 表示（$i,j,t$ 均为整数），其中 $1 \\le i<j \\le n$，$1 \\le t \\le m$。它的功能是：在时刻 $t$ 比较 $Q_{i}$ 与 $Q_{j}$ 的大小，若 $Q_{i}>Q_{j}$，就交换 $Q_{i}$ 与 $Q_{j}$ 的值，否则什么也不做。\n\n- 若要让计算机**工作**（**但不一定解决问题**），则需要任意两个比较器之间**不能发生冲突**。两个比较器 $(A,B,S)$ 与 $(C,D,T)$ **会发生冲突**当且仅当 $A,B,C,D$ 中有**至少两个相等的数**，**并且** $S=T$。例如：比较器 $(1,3,1)$ 和 $(2,4,1)$ 不会发生冲突，而比较器 $(1,2,3)$ 和 $(2,3,3)$ 会发生冲突。\n\n在运行时，这台计算机中的每个比较器都会按照预先设定好的参数在指定的时间进行相应的操作。这台计算机运行时需要消耗的时间为所有的比较器中参数 $t$ 的**最大值** $w$，该值越小意味着运行时间越短。\n\n为了检验你设计的计算机，牛牛提供了测试数据。**每组测试数据**包含 $q$ 个**问题**，即 $q$ 个长度为 $n$ 的排列 $P$。请你为**每组测试数据**设计一台运行时间不超过 $m$ 的计算机（否则计算机将**超时**），使得这台计算机能对**测试数据中所有的** $P$ 排序。\n\n", "inputFormat": "为了方便你区分不同的子任务，每个输入文件第一行为一个整数 $I$，表示当前测试点的编号。\n\n第二行一个整数 $J$ 表示**这个测试点**中的**测试数据**组数。\n\n**每组测试数据**第一行三个整数 $q,n,m$。\n\n接下来 $q$ 行每行 $n$ 个整数，描述一个 $1$ 到 $n$ 的排列 $P$。\n\n**数据保证有解。**", "outputFormat": "对于**每组测试数据**，第一行输出一个整数 $f$ 表示你设计的计算机中比较器个数。\n\n接下来 $f$ 行，每行 $3$ 个整数 $i,j,t$，描述你的计算机的一个比较器 $(i,j,t)$。\n\n若 $i,j \\notin [1,n]$，则计算机**不能工作**。", "hint": "### 输入数据及 checker 下载\n\n在[这里](http://pan.baidu.com/s/1miBgJ3q)下载。\n\n**警告：所有数据（包括 SPJ）均为 Windows（64 位）格式。**\n\n### 关于 UKE 的问题\n\n由于本题 SPJ 的时间复杂度较高，请用比较器个数尽量少的方案来通过该题，否则可能出现 SPJ TLE 的问题，导致评测结果为 UKE。\n\nSPJ 的时间复杂度为：\n$$O\\left ( \\sum_{i=1}^{J}q_i\\times (n_i+f_i) \\right )$$\n\n### 评分方式\n\n共 $8$ 个**测试点**，分别有 $6,12,13,10,10,10,19,20$ 组**测试数据**，共 $100$ 组，**每组测试数据满分 $1$ 分。**\n\n在**每组测试数据**中，若 $1 \\le w\\le m$ 且 $f\\le 10^{6}$，比较器之间不会发生冲突，计算机能对**测试数据中所有的** $P$ 排序，则该**测试数据**得分，否则不得分。\n\n如果你输出了不足 $J$ 个计算机，那么我们将默认你输出的第 $i$ 个计算机对应第 $i$ 组测试数据。\n\n如果你的输出不符合格式要求，我们不保证你能得到该测试点的分数。\n\n### 数据特性\n\n对于 $100\\%$ 的数据，$1 \\le m \\le 150$，$J \\in \\{1,6,10,12,13,19,20\\}$，$0 \\le I \\le 8$，其余请自行下载数据查看。\n\n这里给出部分数据的部分特性：\n\n- **测试点 $4$（$10$ 分）** 中，对于输入的每一个排列 $P$，它每一个环的大小都互不相同。循环可以理解为，将一个长度为 $n$ 的排列 $P$ 看成一张 $n$ 个点 $n$ 条边的无向图（**基环森林**），其中 $i$ 号点和 $P_{i}$ 号点之间有一条边，这张图中的**每一个联通块都是一个环**（**即该图由若干个环组成**），如 $P=\\{\\color{blue}1,\\color{green}3,2,\\color{purple}6,\\color{red}10,\\color{purple}7,4,\\color{red}5,8,9\\color{black}\\}$（**每个颜色代表一个环**）。\n\n- **测试点 $7$（$19$ 分）** 中，对于输入的每一个排列 $P$，都存在若干个互不相交的区间 $[l_i,r_i]$，使得在对每一个区间 $[l_i,r_i]$ 循环左移一次后，数组有序，如 $P=\\{\\color{blue}3,1,2,\\color{green}7,4,5,6,\\color{purple}8,\\color{red}9\\color{black}\\}$（**每个颜色代表一个区间**）。循环左移的例子为：$(1,2,3,4)$ 循环左移一步为 $(2,3,4,1)$。\n- **测试点 $7$ 的前 $8$ 组测试数据（$8$ 分）** 中，满足对于输入的每一个排列 $P$，都存在整数 $i$，使得对区间 $[1,i]$ 循环左移一次后，数组有序，如 $P=\\{\\color{red}5,1,2,3,4\\color{black},6,7,8\\}$。\n\n### 测试你的输出\n\n我们在文件中提供了 `checker`（**Windows x64**）来检测你的输出的得分，使用这个工具的方法为：\n\n`checker.exe sort<I>.in sort<I>.out sort<I>.out`\n\n其中 $I$ 为**测试点**编号（**输入时不带尖括号**），`checker.exe` 为校验器，`sort<I>.in` 为题目提供的输入文件，`sort<I>.out` 为你的对应的输出文件（**输入两遍**）。运行此命令将给出以 `sort<I>.in` 为输入文件，以 `sort<I>.out` 为输出文件时你的得分情况。\n\n在你调用这个程序后，`checker` 将根据你给出的输出文件给出每一个**测试数据**的测试结果，其中包括（如果你输出的计算机同时出现了多种错误，将会返回其中一种）：\n\n| 测试结果 | 含义 |\n| :----------- | :----------- |\n| `FAIL!` | 未知错误：SPJ 运行失败。 |\n| `Input error!` | 输入文件非法：你改动了输入文件。 |\n| `The number of the comparators is invalid!` | 检测到 $f>10^6$。 |\n| `Unexpected EOF` | 给出的计算机不完整。 |\n| `The running time of the comparator should be in [1, 150]` | 检测到 $w \\notin [1,150]$。 |\n| `Invalid sorting network!` | 给出的计算机不能工作。 |\n| `The answer is incorrect` | 给出的计算机不能解决所有问题。 |\n| `Invalid! m=(X) but M=(X)` | 给出的计算机超时：$w=Y,m=X$（$Y>X$）。 |\n| `Correct! m=(X) and M=(X)` | 给出的计算机正确：$w=Y,m=X$（$Y\\le X$）。 |\n\n最后，如果 `checker` 正常运行到了最后，将会额外输出一行 `Total points: (Z)`，表示你在**这个测试点**一共得了 $Z$ 分。\n\n### 提醒\n\n**请注意「测试点」、「测试数据」和「问题」的区别！**\n\n**请牢记下面的图示：**\n\n- 整道题目\n\n  - 测试点 $1$\n    \n    - 测试数据 $1.1$\n    \n      - 问题 $1.1.1$\n      \n    - 测试数据 $1.2$\n    \n      - 问题 $1.2.1$\n      \n    - 测试数据 $1.3$\n    \n      - 问题 $1.3.1$\n      \n      - 问题 $1.3.2$\n      \n      - ……\n      \n      - 问题 $1.3.5$\n      \n    - ……\n    \n    - 测试数据 $1.6$\n    \n  - 测试点 $2$\n  \n  - ……\n  \n  - 测试点 $8$\n", "locale": "zh-CN", "translations": {"en": {"title": "[WC2017] Sorting", "background": "This problem currently only allows code submissions.", "description": "Niuniu has recently learned about sorting and has become very interested in the efficiency of sorting algorithms. To optimize sorting time, Niuniu turned to you at the winter camp to help design a computer to perform sorting (ascending).\n\nThe computer is designed as follows:\n\n- The sequence to be sorted is stored in an array $Q$ of size $n$.\n\n- The smallest unit of computation is a comparator, represented by a triple $(i, j, t)$ (all integers), where $1 \\le i < j \\le n$, $1 \\le t \\le m$. Its function is: at time $t$, compare $Q_{i}$ and $Q_{j}$. If $Q_{i} > Q_{j}$, swap $Q_{i}$ and $Q_{j}$; otherwise do nothing.\n\n- For the computer to work (but not necessarily solve the problem), any two comparators must not conflict. Two comparators $(A, B, S)$ and $(C, D, T)$ conflict if and only if at least two numbers among $A, B, C, D$ are equal and $S = T$. For example, comparators $(1, 3, 1)$ and $(2, 4, 1)$ do not conflict, while $(1, 2, 3)$ and $(2, 3, 3)$ do conflict.\n\nAt runtime, each comparator in the computer performs its operation at its preset time. The running time of the computer is the maximum value $w$ of parameter $t$ among all comparators; the smaller this value, the shorter the running time.\n\nTo test your computer design, Niuniu provides testdata. Each group of testdata contains $q$ queries, i.e., $q$ permutations $P$ of length $n$. For each group of testdata, please design a computer with running time at most $m$ (otherwise the computer will time out) that can sort all $P$ in the testdata.", "inputFormat": "To help you distinguish sub-tasks, each input file begins with an integer $I$, the current test point index.\n\nThe second line contains an integer $J$, the number of testdata groups in this test point.\n\nFor each group of testdata, the first line contains three integers $q, n, m$.\n\nThen follow $q$ lines, each containing $n$ integers describing a permutation $P$ of $1$ to $n$.\n\nIt is guaranteed that a solution exists.", "outputFormat": "For each group of testdata, output an integer $f$ in the first line, the number of comparators in your computer.\n\nThen output $f$ lines, each with $3$ integers $i, j, t$, describing a comparator $(i, j, t)$ of your computer.\n\nIf $i, j \\notin [1, n]$, then the computer cannot work.", "hint": "### Download input data and checker\n\nDownload from [here](http://pan.baidu.com/s/1miBgJ3q).\n\nWarning: All files (including the SPJ) are in Windows (64-bit) format.\n\n### About the UKE issue\n\nBecause the SPJ has high time complexity, please use as few comparators as possible. Otherwise the SPJ may TLE, causing the verdict to be UKE.\n\nThe SPJ time complexity is:\n$$O\\left ( \\sum_{i=1}^{J}q_i\\times (n_i+f_i) \\right )$$\n\n### Scoring\n\nThere are 8 test points with $6, 12, 13, 10, 10, 10, 19, 20$ groups of testdata respectively, 100 groups in total, and each group of testdata is worth 1 point.\n\nIn each group of testdata, if $1 \\le w \\le m$ and $f \\le 10^{6}$, the comparators do not conflict, and the computer can sort all $P$ in the testdata, then that testdata scores; otherwise it scores 0.\n\nIf you output fewer than $J$ computers, we assume your $i$-th computer corresponds to the $i$-th group of testdata.\n\nIf your output format is invalid, we do not guarantee you can get points for that test point.\n\n### Data characteristics\n\nFor $100\\%$ of the data, $1 \\le m \\le 150$, $J \\in \\{1, 6, 10, 12, 13, 19, 20\\}$, $0 \\le I \\le 8$. See the downloadable data for the rest.\n\nSome partial characteristics:\n\n- Test point $4$ (10 points): For every input permutation $P$, all its cycle sizes are pairwise distinct. You can think of a permutation $P$ of length $n$ as an undirected graph with $n$ nodes and $n$ edges (a functional graph consisting only of cycles), where there is an edge between node $i$ and node $P_{i}$. Every connected component in this graph is a cycle (i.e., the graph consists of several cycles), e.g., $P=\\{\\color{blue}1,\\color{green}3,2,\\color{purple}6,\\color{red}10,\\color{purple}7,4,\\color{red}5,8,9\\color{black}\\}$ (each color indicates a cycle).\n\n- Test point $7$ (19 points): For every input permutation $P$, there exist several pairwise disjoint intervals $[l_i, r_i]$ such that after rotating each interval $[l_i, r_i]$ left by one step, the array becomes sorted, e.g., $P=\\{\\color{blue}3,1,2,\\color{green}7,4,5,6,\\color{purple}8,\\color{red}9\\color{black}\\}$ (each color indicates an interval). Example of a left cyclic shift: $(1, 2, 3, 4)$ rotated left by one step becomes $(2, 3, 4, 1)$.\n- In the first 8 groups of testdata of test point $7$ (8 points), for every input permutation $P$, there exists an integer $i$ such that after rotating the interval $[1, i]$ left by one step, the array becomes sorted, e.g., $P=\\{\\color{red}5,1,2,3,4\\color{black},6,7,8\\}$.\n\n### Test your output\n\nWe provide a checker (Windows x64) in the files to evaluate your output. Usage:\n\n`checker.exe sort<I>.in sort<I>.out sort<I>.out`\n\nHere $I$ is the test point index (do not include angle brackets in the input), `checker.exe` is the checker, `sort<I>.in` is the provided input file, and `sort<I>.out` is your corresponding output file (input twice). Running this command will show your score on the input file `sort<I>.in` with your output file `sort<I>.out`.\n\nAfter you invoke the program, the checker prints the result for each group of testdata, including (if multiple errors occur simultaneously, one of them is reported):\n\n| Result | Meaning |\n| :----------- | :----------- |\n| `FAIL!` | Unknown error: SPJ runtime failure. |\n| `Input error!` | Invalid input file: you modified the input. |\n| `The number of the comparators is invalid!` | Detected $f>10^6$. |\n| `Unexpected EOF` | The computer you provided is incomplete. |\n| `The running time of the comparator should be in [1, 150]` | Detected $w \\notin [1, 150]$. |\n| `Invalid sorting network!` | The computer you provided cannot work. |\n| `The answer is incorrect` | The computer you provided cannot solve all queries. |\n| `Invalid! m=(X) but M=(X)` | The computer timed out: $w=Y, m=X$ ($Y>X$). |\n| `Correct! m=(X) and M=(X)` | The computer is correct: $w=Y, m=X$ ($Y \\le X$). |\n\nFinally, if the checker finishes normally, it additionally prints `Total points: (Z)`, which is the total points you scored on this test point.\n\n### Reminder\n\nPlease pay attention to the difference between “test point”, “testdata”, and “query”.\n\nPlease keep in mind the structure below:\n\n- The whole problem\n\n  - Test point $1$\n    \n    - Testdata $1.1$\n    \n      - Query $1.1.1$\n      \n    - Testdata $1.2$\n    \n      - Query $1.2.1$\n      \n    - Testdata $1.3$\n      \n      - Query $1.3.1$\n      \n      - Query $1.3.2$\n      \n      - …\n      \n      - Query $1.3.5$\n      \n    - …\n    \n    - Testdata $1.6$\n    \n  - Test point $2$\n  \n  - …\n  \n  - Test point $8$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2017] 排序", "background": "**本题暂时只能使用代码提交。**\n\n", "description": "牛牛最近学习了排序的相关知识。他对排序算法的运行效率产生了浓厚的兴趣并对此展开了一系列的研究。\n\n为了优化排序的运行时间，牛牛找到了来参加冬令营的你，希望你帮助他设计一台计算机进行排序（**升序**）。\n\n这台计算机的设计方法如下：\n\n- 需要进行排序的序列存储在大小为 $n$ 的数组 $Q$ 中。\n\n- 进行计算的最小单元是比较器，一个比较器可以用一个三元组 $(i,j,t)$ 表示（$i,j,t$ 均为整数），其中 $1 \\le i<j \\le n$，$1 \\le t \\le m$。它的功能是：在时刻 $t$ 比较 $Q_{i}$ 与 $Q_{j}$ 的大小，若 $Q_{i}>Q_{j}$，就交换 $Q_{i}$ 与 $Q_{j}$ 的值，否则什么也不做。\n\n- 若要让计算机**工作**（**但不一定解决问题**），则需要任意两个比较器之间**不能发生冲突**。两个比较器 $(A,B,S)$ 与 $(C,D,T)$ **会发生冲突**当且仅当 $A,B,C,D$ 中有**至少两个相等的数**，**并且** $S=T$。例如：比较器 $(1,3,1)$ 和 $(2,4,1)$ 不会发生冲突，而比较器 $(1,2,3)$ 和 $(2,3,3)$ 会发生冲突。\n\n在运行时，这台计算机中的每个比较器都会按照预先设定好的参数在指定的时间进行相应的操作。这台计算机运行时需要消耗的时间为所有的比较器中参数 $t$ 的**最大值** $w$，该值越小意味着运行时间越短。\n\n为了检验你设计的计算机，牛牛提供了测试数据。**每组测试数据**包含 $q$ 个**问题**，即 $q$ 个长度为 $n$ 的排列 $P$。请你为**每组测试数据**设计一台运行时间不超过 $m$ 的计算机（否则计算机将**超时**），使得这台计算机能对**测试数据中所有的** $P$ 排序。\n\n", "inputFormat": "为了方便你区分不同的子任务，每个输入文件第一行为一个整数 $I$，表示当前测试点的编号。\n\n第二行一个整数 $J$ 表示**这个测试点**中的**测试数据**组数。\n\n**每组测试数据**第一行三个整数 $q,n,m$。\n\n接下来 $q$ 行每行 $n$ 个整数，描述一个 $1$ 到 $n$ 的排列 $P$。\n\n**数据保证有解。**", "outputFormat": "对于**每组测试数据**，第一行输出一个整数 $f$ 表示你设计的计算机中比较器个数。\n\n接下来 $f$ 行，每行 $3$ 个整数 $i,j,t$，描述你的计算机的一个比较器 $(i,j,t)$。\n\n若 $i,j \\notin [1,n]$，则计算机**不能工作**。", "hint": "### 输入数据及 checker 下载\n\n在[这里](http://pan.baidu.com/s/1miBgJ3q)下载。\n\n**警告：所有数据（包括 SPJ）均为 Windows（64 位）格式。**\n\n### 关于 UKE 的问题\n\n由于本题 SPJ 的时间复杂度较高，请用比较器个数尽量少的方案来通过该题，否则可能出现 SPJ TLE 的问题，导致评测结果为 UKE。\n\nSPJ 的时间复杂度为：\n$$O\\left ( \\sum_{i=1}^{J}q_i\\times (n_i+f_i) \\right )$$\n\n### 评分方式\n\n共 $8$ 个**测试点**，分别有 $6,12,13,10,10,10,19,20$ 组**测试数据**，共 $100$ 组，**每组测试数据满分 $1$ 分。**\n\n在**每组测试数据**中，若 $1 \\le w\\le m$ 且 $f\\le 10^{6}$，比较器之间不会发生冲突，计算机能对**测试数据中所有的** $P$ 排序，则该**测试数据**得分，否则不得分。\n\n如果你输出了不足 $J$ 个计算机，那么我们将默认你输出的第 $i$ 个计算机对应第 $i$ 组测试数据。\n\n如果你的输出不符合格式要求，我们不保证你能得到该测试点的分数。\n\n### 数据特性\n\n对于 $100\\%$ 的数据，$1 \\le m \\le 150$，$J \\in \\{1,6,10,12,13,19,20\\}$，$0 \\le I \\le 8$，其余请自行下载数据查看。\n\n这里给出部分数据的部分特性：\n\n- **测试点 $4$（$10$ 分）** 中，对于输入的每一个排列 $P$，它每一个环的大小都互不相同。循环可以理解为，将一个长度为 $n$ 的排列 $P$ 看成一张 $n$ 个点 $n$ 条边的无向图（**基环森林**），其中 $i$ 号点和 $P_{i}$ 号点之间有一条边，这张图中的**每一个联通块都是一个环**（**即该图由若干个环组成**），如 $P=\\{\\color{blue}1,\\color{green}3,2,\\color{purple}6,\\color{red}10,\\color{purple}7,4,\\color{red}5,8,9\\color{black}\\}$（**每个颜色代表一个环**）。\n\n- **测试点 $7$（$19$ 分）** 中，对于输入的每一个排列 $P$，都存在若干个互不相交的区间 $[l_i,r_i]$，使得在对每一个区间 $[l_i,r_i]$ 循环左移一次后，数组有序，如 $P=\\{\\color{blue}3,1,2,\\color{green}7,4,5,6,\\color{purple}8,\\color{red}9\\color{black}\\}$（**每个颜色代表一个区间**）。循环左移的例子为：$(1,2,3,4)$ 循环左移一步为 $(2,3,4,1)$。\n- **测试点 $7$ 的前 $8$ 组测试数据（$8$ 分）** 中，满足对于输入的每一个排列 $P$，都存在整数 $i$，使得对区间 $[1,i]$ 循环左移一次后，数组有序，如 $P=\\{\\color{red}5,1,2,3,4\\color{black},6,7,8\\}$。\n\n### 测试你的输出\n\n我们在文件中提供了 `checker`（**Windows x64**）来检测你的输出的得分，使用这个工具的方法为：\n\n`checker.exe sort<I>.in sort<I>.out sort<I>.out`\n\n其中 $I$ 为**测试点**编号（**输入时不带尖括号**），`checker.exe` 为校验器，`sort<I>.in` 为题目提供的输入文件，`sort<I>.out` 为你的对应的输出文件（**输入两遍**）。运行此命令将给出以 `sort<I>.in` 为输入文件，以 `sort<I>.out` 为输出文件时你的得分情况。\n\n在你调用这个程序后，`checker` 将根据你给出的输出文件给出每一个**测试数据**的测试结果，其中包括（如果你输出的计算机同时出现了多种错误，将会返回其中一种）：\n\n| 测试结果 | 含义 |\n| :----------- | :----------- |\n| `FAIL!` | 未知错误：SPJ 运行失败。 |\n| `Input error!` | 输入文件非法：你改动了输入文件。 |\n| `The number of the comparators is invalid!` | 检测到 $f>10^6$。 |\n| `Unexpected EOF` | 给出的计算机不完整。 |\n| `The running time of the comparator should be in [1, 150]` | 检测到 $w \\notin [1,150]$。 |\n| `Invalid sorting network!` | 给出的计算机不能工作。 |\n| `The answer is incorrect` | 给出的计算机不能解决所有问题。 |\n| `Invalid! m=(X) but M=(X)` | 给出的计算机超时：$w=Y,m=X$（$Y>X$）。 |\n| `Correct! m=(X) and M=(X)` | 给出的计算机正确：$w=Y,m=X$（$Y\\le X$）。 |\n\n最后，如果 `checker` 正常运行到了最后，将会额外输出一行 `Total points: (Z)`，表示你在**这个测试点**一共得了 $Z$ 分。\n\n### 提醒\n\n**请注意「测试点」、「测试数据」和「问题」的区别！**\n\n**请牢记下面的图示：**\n\n- 整道题目\n\n  - 测试点 $1$\n    \n    - 测试数据 $1.1$\n    \n      - 问题 $1.1.1$\n      \n    - 测试数据 $1.2$\n    \n      - 问题 $1.2.1$\n      \n    - 测试数据 $1.3$\n    \n      - 问题 $1.3.1$\n      \n      - 问题 $1.3.2$\n      \n      - ……\n      \n      - 问题 $1.3.5$\n      \n    - ……\n    \n    - 测试数据 $1.6$\n    \n  - 测试点 $2$\n  \n  - ……\n  \n  - 测试点 $8$\n", "locale": "zh-CN"}}}
{"pid": "P3783", "type": "P", "difficulty": 7, "samples": [["1\n4 4 6\n1 2 2 5\n2 3 2 5\n2 4 1 6\n4 2 1 6\n1 2 1\n2 3 1\n3 4 1\n4 5 2\n1 6 2", "2\n7\n3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["字符串", "2017", "线段树", "各省省选", "山东", "O2优化", "虚树", "字典树 Trie"], "title": "[SDOI2017] 天才黑客", "background": "$\\text{SD0062}$ 号选手小 Q 同学为了偷到 SDOI7012 的试题，利用高超的黑客技术潜入了 SDOI 出题组的内联网的中央控制系统，然而这个内联网除了配备有中央控制系统，还为内联网中的每条单向网线设定了特殊的通信口令，这里通信口令是一个字符串，不同网线的口令可能不同。这让小 Q 同学感觉有些棘手，不过这根本难不倒他，很快他就分析出了整个内联网的结构。\n", "description": "内联网中有 $n$ 个节点（从 $1$ 到 $n$ 标号）和 $m$ 条**单向**网线，中央控制系统在第 $1$ 个节点上，每条网线单向连接内联网中的某两个节点，从 $1$ 号节点出发经过若干条网线总能到达其他任意一个节点。每个节点都可以运行任意的应用程序，应用程序会携带一条通信口令，当且仅当程序的口令与网线的口令相同时，程序才能通过这条网线到达另一端的节点继续运行，并且通过每条网线都需要花费一定的时间。\n\n每个应用程序可以在任意一个节点修改通信口令，修改通信口令花费的时间可以忽略不计，但是为了减小修改量，需要先调用一个子程序来计算当前程序的口令和网线的口令的最长公共前缀（记其长度为 $\\mathrm{len}$），由于获取网线的口令的某个字符会比较耗时，调用一次这个子程序需要花费 $\\mathrm{len}$ 个单位时间。\n\n除此之外，小 Q 同学还在中央控制系统中发现了一个字典，每条网线的口令都是字典中的某个字符串。具体来说，这个字典是一棵 $k$ 个节点（从 $1$ 到 $k$ 标号）的有根树，其中根是第 $1$ 个节点，每条**边**上有一个字符，字符串 $S$ 在字典中当且仅当存在某个点 $u$ 使得从根节点出发往下走到 $u$ 的这条路径上的字符顺次拼接构成 $S$。\n\n现在小 Q 同学在 $1$ 号节点同时开启了 $(n-1)$ 个应用程序，这些应用程序同时运行且互不干扰，每个程序的通信口令都为空，他希望用最短的时间把这些程序分别发送到其他节点上，你需要帮小 Q 同学分别计算出发送到第 $i$（$i=2,3,\\dots ,n$）个节点的程序完成任务的最短时间。\n", "inputFormat": "第一行是一个正整数 $T$，表示测试数据的组数，\n\n对于每组测试数据，第一行是三个整数 $n,m,k$，分别表示内联网的节点数、内联网的网线条数、字典树的节点数，\n\n接下来 $m$ 行，每行包含四个整数 $a_i,b_i,c_i,d_i$，表示沿着这条网线可以从第 $a_i$ 个节点花费 $c_i$ 个单位时间到达第 $b_i$ 个节点，网线的口令是由从字典树的根到 $d_i $这个点的路径上的字符顺次拼接构成的字符串（**可能为空**），需要注意的是**这个内联网可能有自环和重边**。\n\n接下来 $(k-1)$ 行，每行包含三个整数 $u_i,v_i,w_i$，表示字典树上有一条 $u_i \\rightarrow v_i$ 的边，边上有字符 $w_i$，保证给出的边构成一棵以 $1$ 为根的有根树，并且每个点连出去的边上的字符互不相同。\n", "outputFormat": "对于每组测试数据，输出 $(n-1)$ 行，第 $i$ 行表示发送到第 $(i+1)$ 个节点的程序完成任务的最短时间。\n", "hint": "样例解释：下图展示了样例中内联网的结构。字符串用红色字体标出。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/btzomagx.png)\n\n记 $\\mathrm{LCP}(S,T)$ 为字符串 $S,T$ 的**最长公共前缀**的长度。例如，$\\mathrm{LCP}(\\texttt{\\textcolor{red}{starry}killer},\\texttt{\\textcolor{red}{starry}dust})=6$。记 $\\epsilon$ 为空字符串。\n\n从 $1$ 到 $3$ 的一条可行路径是 $1 \\rightarrow 2 \\rightarrow 3$，所需时间是$(2 + \\mathrm{LCP}(\\epsilon , \\texttt{1112})) + (2 +\\mathrm{LCP}(\\texttt{1112} ,\\texttt{1112})) = 8$。\n\n但这条路径不是最优的，最优路径是 $1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 2 \\rightarrow 3$。\n\n\n \n\n| 测试点编号 | $n\\le $ | $m\\le $|  $k\\le$ | 备注 |\n| :--: | :--: | :--: | :--: | :--: |\n| $1\\sim 5$ | $5\\,000$ | $5\\,000$ | $20\\,000$ | - |\n| $6\\sim 14$ | $50\\,000$ | $50\\,000$ | $20\\,000$ | $nk\\le 200\\,000$ |\n| $15\\sim 20$ | $50\\,000$ | $50\\,000$ | $20\\,000$ | - |\n\n对于 $100\\%$ 的数据，保证：\n\n- $T \\leq 10$；\n- $2 \\leq n \\leq 50000$，$1 \\leq m \\leq 50000$，$1 \\leq k \\leq 20000$；\n- $n>5000$ 或 $m > 5000$ 的数据不超过 $2$ 组；\n- $1 \\leq a_i,b_i \\leq n$，$0 \\leq c_i \\leq 20000$，$1 \\leq d_i \\leq k$；\n- $1 \\leq u_i,v_i \\leq k$，$1 \\leq w_i \\leq 20000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2017] Genius Hacker", "background": "Contestant $\\text{SD0062}$, Xiao Q, in order to steal the SDOI7012 problems, infiltrated the SDOI problem setters’ intranet central control system using superb hacking skills. However, besides the central control system, this intranet also assigns a special communication passcode to each directed network cable. A passcode is a string, and different cables may have different passcodes. This looks tricky to Xiao Q, but it cannot stop him. Soon, he analyzed the entire structure of the intranet.", "description": "The intranet has $n$ nodes (numbered from $1$ to $n$) and $m$ directed cables. The central control system is at node $1$. Each cable connects an ordered pair of nodes, and starting from node $1$ you can reach any other node by following some cables. Any node can run any application. An application carries a communication passcode. A program can traverse a cable if and only if its current passcode equals the cable’s passcode. Traversing any cable takes some amount of time.\n\nEach application can modify its communication passcode at any node. The time to change the passcode itself can be neglected. However, to minimize the amount of modification, you must first call a subroutine to compute the longest common prefix (denote its length by $\\mathrm{len}$) between the program’s current passcode and the cable’s passcode. Because obtaining any character of the cable’s passcode is time‑consuming, calling this subroutine once costs $\\mathrm{len}$ time units.\n\nIn addition, Xiao Q found a dictionary in the central control system. Every cable’s passcode is some string from this dictionary. Specifically, this dictionary is a rooted tree with $k$ nodes (numbered from $1$ to $k$), rooted at node $1$. Each edge carries a character. A string $S$ is in the dictionary if and only if there exists a node $u$ such that the characters along the path from the root to $u$ concatenated in order form $S$.\n\nNow Xiao Q simultaneously starts $(n-1)$ applications at node $1$. These programs run concurrently without interference. Each program’s initial passcode is empty. He wants to send these programs to the other nodes in the shortest possible time. You need to help Xiao Q compute, for each $i$ ($i=2,3,\\dots ,n$), the minimal time for the program destined for node $i$ to finish its task.", "inputFormat": "The first line contains a positive integer $T$, the number of test cases.\n\nFor each test case, the first line contains three integers $n, m, k$, the number of intranet nodes, the number of cables, and the number of dictionary tree nodes, respectively.\n\nThe next $m$ lines each contain four integers $a_i, b_i, c_i, d_i$, meaning that there is a directed cable from node $a_i$ to node $b_i$ whose traversal time is $c_i$, and whose passcode equals the string formed by the characters along the path from the dictionary root to node $d_i$ (which can be empty). Note that the intranet may have self‑loops and multiple edges.\n\nThe next $(k-1)$ lines each contain three integers $u_i, v_i, w_i$, indicating there is an edge $u_i \\rightarrow v_i$ in the dictionary tree whose label is a character $w_i$. It is guaranteed that the given edges form a rooted tree with root $1$, and the labels on the outgoing edges of any node are pairwise distinct.", "outputFormat": "For each test case, output $(n-1)$ lines. The $i$‑th line is the minimal time for the program to reach node $(i+1)$.", "hint": "Sample explanation: The following figure shows the intranet structure in the sample. Strings are marked in red.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/btzomagx.png)\n\nLet $\\mathrm{LCP}(S,T)$ be the length of the longest common prefix of strings $S$ and $T$. For example, $\\mathrm{LCP}(\\texttt{\\textcolor{red}{starry}killer},\\texttt{\\textcolor{red}{starry}dust})=6$. Let $\\epsilon$ be the empty string.\n\nOne feasible path from $1$ to $3$ is $1 \\rightarrow 2 \\rightarrow 3$. The required time is $(2 + \\mathrm{LCP}(\\epsilon , \\texttt{1112})) + (2 + \\mathrm{LCP}(\\texttt{1112} , \\texttt{1112})) = 8$.\n\nHowever, this path is not optimal. The optimal path is $1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 2 \\rightarrow 3$.\n\n| Test point index | $n \\le$ | $m \\le$ | $k \\le$ | Remarks |\n| :--: | :--: | :--: | :--: | :--: |\n| $1 \\sim 5$ | $5\\,000$ | $5\\,000$ | $20\\,000$ | - |\n| $6 \\sim 14$ | $50\\,000$ | $50\\,000$ | $20\\,000$ | $nk \\le 200\\,000$ |\n| $15 \\sim 20$ | $50\\,000$ | $50\\,000$ | $20\\,000$ | - |\n\nFor $100\\%$ of the testdata, it is guaranteed that:\n- $T \\leq 10$.\n- $2 \\leq n \\leq 50000$, $1 \\leq m \\leq 50000$, $1 \\leq k \\leq 20000$.\n- The number of test cases with $n > 5000$ or $m > 5000$ does not exceed $2$.\n- $1 \\leq a_i, b_i \\leq n$, $0 \\leq c_i \\leq 20000$, $1 \\leq d_i \\leq k$.\n- $1 \\leq u_i, v_i \\leq k$, $1 \\leq w_i \\leq 20000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2017] 天才黑客", "background": "$\\text{SD0062}$ 号选手小 Q 同学为了偷到 SDOI7012 的试题，利用高超的黑客技术潜入了 SDOI 出题组的内联网的中央控制系统，然而这个内联网除了配备有中央控制系统，还为内联网中的每条单向网线设定了特殊的通信口令，这里通信口令是一个字符串，不同网线的口令可能不同。这让小 Q 同学感觉有些棘手，不过这根本难不倒他，很快他就分析出了整个内联网的结构。\n", "description": "内联网中有 $n$ 个节点（从 $1$ 到 $n$ 标号）和 $m$ 条**单向**网线，中央控制系统在第 $1$ 个节点上，每条网线单向连接内联网中的某两个节点，从 $1$ 号节点出发经过若干条网线总能到达其他任意一个节点。每个节点都可以运行任意的应用程序，应用程序会携带一条通信口令，当且仅当程序的口令与网线的口令相同时，程序才能通过这条网线到达另一端的节点继续运行，并且通过每条网线都需要花费一定的时间。\n\n每个应用程序可以在任意一个节点修改通信口令，修改通信口令花费的时间可以忽略不计，但是为了减小修改量，需要先调用一个子程序来计算当前程序的口令和网线的口令的最长公共前缀（记其长度为 $\\mathrm{len}$），由于获取网线的口令的某个字符会比较耗时，调用一次这个子程序需要花费 $\\mathrm{len}$ 个单位时间。\n\n除此之外，小 Q 同学还在中央控制系统中发现了一个字典，每条网线的口令都是字典中的某个字符串。具体来说，这个字典是一棵 $k$ 个节点（从 $1$ 到 $k$ 标号）的有根树，其中根是第 $1$ 个节点，每条**边**上有一个字符，字符串 $S$ 在字典中当且仅当存在某个点 $u$ 使得从根节点出发往下走到 $u$ 的这条路径上的字符顺次拼接构成 $S$。\n\n现在小 Q 同学在 $1$ 号节点同时开启了 $(n-1)$ 个应用程序，这些应用程序同时运行且互不干扰，每个程序的通信口令都为空，他希望用最短的时间把这些程序分别发送到其他节点上，你需要帮小 Q 同学分别计算出发送到第 $i$（$i=2,3,\\dots ,n$）个节点的程序完成任务的最短时间。\n", "inputFormat": "第一行是一个正整数 $T$，表示测试数据的组数，\n\n对于每组测试数据，第一行是三个整数 $n,m,k$，分别表示内联网的节点数、内联网的网线条数、字典树的节点数，\n\n接下来 $m$ 行，每行包含四个整数 $a_i,b_i,c_i,d_i$，表示沿着这条网线可以从第 $a_i$ 个节点花费 $c_i$ 个单位时间到达第 $b_i$ 个节点，网线的口令是由从字典树的根到 $d_i $这个点的路径上的字符顺次拼接构成的字符串（**可能为空**），需要注意的是**这个内联网可能有自环和重边**。\n\n接下来 $(k-1)$ 行，每行包含三个整数 $u_i,v_i,w_i$，表示字典树上有一条 $u_i \\rightarrow v_i$ 的边，边上有字符 $w_i$，保证给出的边构成一棵以 $1$ 为根的有根树，并且每个点连出去的边上的字符互不相同。\n", "outputFormat": "对于每组测试数据，输出 $(n-1)$ 行，第 $i$ 行表示发送到第 $(i+1)$ 个节点的程序完成任务的最短时间。\n", "hint": "样例解释：下图展示了样例中内联网的结构。字符串用红色字体标出。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/btzomagx.png)\n\n记 $\\mathrm{LCP}(S,T)$ 为字符串 $S,T$ 的**最长公共前缀**的长度。例如，$\\mathrm{LCP}(\\texttt{\\textcolor{red}{starry}killer},\\texttt{\\textcolor{red}{starry}dust})=6$。记 $\\epsilon$ 为空字符串。\n\n从 $1$ 到 $3$ 的一条可行路径是 $1 \\rightarrow 2 \\rightarrow 3$，所需时间是$(2 + \\mathrm{LCP}(\\epsilon , \\texttt{1112})) + (2 +\\mathrm{LCP}(\\texttt{1112} ,\\texttt{1112})) = 8$。\n\n但这条路径不是最优的，最优路径是 $1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 2 \\rightarrow 3$。\n\n\n \n\n| 测试点编号 | $n\\le $ | $m\\le $|  $k\\le$ | 备注 |\n| :--: | :--: | :--: | :--: | :--: |\n| $1\\sim 5$ | $5\\,000$ | $5\\,000$ | $20\\,000$ | - |\n| $6\\sim 14$ | $50\\,000$ | $50\\,000$ | $20\\,000$ | $nk\\le 200\\,000$ |\n| $15\\sim 20$ | $50\\,000$ | $50\\,000$ | $20\\,000$ | - |\n\n对于 $100\\%$ 的数据，保证：\n\n- $T \\leq 10$；\n- $2 \\leq n \\leq 50000$，$1 \\leq m \\leq 50000$，$1 \\leq k \\leq 20000$；\n- $n>5000$ 或 $m > 5000$ 的数据不超过 $2$ 组；\n- $1 \\leq a_i,b_i \\leq n$，$0 \\leq c_i \\leq 20000$，$1 \\leq d_i \\leq k$；\n- $1 \\leq u_i,v_i \\leq k$，$1 \\leq w_i \\leq 20000$。", "locale": "zh-CN"}}}
{"pid": "P3784", "type": "P", "difficulty": 7, "samples": [["5 1000003\n1 2 3 5 7", "5\n1 2 3 4 5"], ["9 1000003\n1 2 2 3 4 5 6 7 8", "3\n1 2 5"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "各省省选", "山东", "O2优化", "莫比乌斯反演", "生成函数", "快速傅里叶变换 FFT", "快速数论变换 NTT"], "title": "[SDOI2017] 遗忘的集合", "background": "", "description": "小 Q 在他的个人主页上放出了一个悬赏：征集只含正整数的非空集合 $S$，其中的每个元素都不超过 $n$，并且满足一些附加条件。\n\n众所周知，我们可以很轻松地对于任意不超过 $n$ 的正整数 $x$，计算出把 $x$ 表示成 $S$ 中元素之和的方案数 $f(x)$，在这里我们约定，在任意方案中每个数字可以出现多次，但是不考虑数字出现的顺序。\n\n例如，当 $S=\\{1,2,3,4,5\\}$ 时，我们可以计算出 $f(2) = 2, f(3) = 3, f(4) = 5, f(5) = 7$。\n\n再例如，当 $S=\\{1,2,5\\}$ 时，我们可以计算出 $f(4) = 3, f(5) = 4, f(6) = 5, f(7) = 6$。\n\n麻烦地是现在小 Q 忘记了 $S$ 里有哪些元素，幸运地是他用存储设备记录下了所有 $f(i)\\bmod p$ 的值，小 Q 希望你能利用这些信息帮他恢复出 $S$ 原来的样子。\n\n具体来说，他希望你找到这样一个正整数的**非空**集合 $S$，其中的每个元素都不超过 $n$，并且对于任意的 $i = 1, 2,\\cdots ,n$，满足把 $i$ 表示成 $S$ 中元素之和的方案数在模 $p$ 意义下等于 $f(i)$，其中 $p$ 是记录在存储设备中的一个质数。他向你保证：**一定存在**这样的集合$S$。\n\n然而，小 Q 觉得他存储的信息并不足以恢复出唯一的 $S$，也就是说，可能会存在多个这样的集合 $S$，所以小 Q 希望你能给出所有解中**字典序最小**的解。\n\n对于满足条件的两个不同的集合 $S_1$ 和 $S_2$，我们认为 $S_1$ 的字典序比 $S_2$ 的字典序小，当且仅当存在非负整数 $k$，使得 $S_1$ 的前 $k$ 小元素与 $S_2$ 的前 $k$ 小元素完全相等，并且，要么 $S_1$ 的元素个数为 $k$，且 $S_2$ 的元素个数至少为 $(k + 1)$，要么 $S_1$ 和 $S_2$ 都有至少 $(k + 1)$ 个元素，且 $S_1$ 的第 $(k + 1)$ 小元素比 $S_2$ 的第 $(k + 1)$ 小元素小。\n", "inputFormat": "第一行包含两个整数 $n$ 和 $p$，满足 $p$ 是质数。\n\n第二行包含 $n$ 个整数 $f(1), f(2),\\cdots , f(n)$，含义见题目描述。\n\n保证每一行中相邻的整数由恰好一个空格隔开，并且末尾没有多余的空格。\n", "outputFormat": "你需要输出两行信息来描述字典序最小的解，其中第一行包含一个整数 $m\\ (m > 0)$，表示 $S$ 的元素个数，第二行包含 $m$ 个正整数 $s_1, s_2,\\cdots ,s_m$，表示将 $S$ 的所有元素按升序排序后得到的序列。\n\n你需要保证输出的每一行中相邻的整数由恰好一个空格隔开，并且每一行的末尾没有多余的空格。\n", "hint": "对于 $100\\%$ 的数据，有 $1 \\leq n < 2^{18} , 10^6 \\leq p < 2^{30} , 0 \\leq f(i) < p\\quad (i=1,2, \\cdots , n)$。\n\n![](https://cdn.luogu.com.cn/upload/pic/5548.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2017] The Forgotten Set", "background": "", "description": "Little Q posted a bounty on his personal homepage: collect a **non-empty** set $S$ containing only positive integers, each not exceeding $n$, and satisfying some additional conditions.\n\nAs is well known, for any positive integer $x$ not exceeding $n$, we can easily compute the number of ways $f(x)$ to express $x$ as a sum of elements from $S$. Here, in any representation, each number may be used multiple times, and the order of numbers is ignored.\n\nFor example, when $S=\\{1,2,3,4,5\\}$, we can compute $f(2) = 2, f(3) = 3, f(4) = 5, f(5) = 7$.\n\nAnother example: when $S=\\{1,2,5\\}$, we can compute $f(4) = 3, f(5) = 4, f(6) = 5, f(7) = 6$.\n\nThe trouble is that Little Q has forgotten which elements are in $S$. Fortunately, he recorded all the values of $f(i) \\bmod p$ on a storage device, and he hopes you can use this information to reconstruct the original $S$.\n\nSpecifically, he wants you to find a **non-empty** set $S$ of positive integers, each at most $n$, such that for every $i = 1, 2, \\cdots , n$, the number of ways to represent $i$ as a sum of elements from $S$ is congruent to $f(i)$ modulo $p$, where $p$ is a prime stored on the device. He guarantees that such an $S$ exists.\n\nHowever, Little Q believes the stored information is not enough to recover a unique $S$; that is, there may be multiple such sets $S$. So he wants the lexicographically smallest one among all solutions.\n\nFor two different sets $S_1$ and $S_2$ that satisfy the conditions, we say $S_1$ is lexicographically smaller than $S_2$ if and only if there exists a non-negative integer $k$ such that the first $k$ smallest elements of $S_1$ are exactly the same as those of $S_2$, and either $S_1$ has exactly $k$ elements and $S_2$ has at least $(k + 1)$ elements, or both $S_1$ and $S_2$ have at least $(k + 1)$ elements and the $(k + 1)$-th smallest element of $S_1$ is smaller than that of $S_2$.", "inputFormat": "The first line contains two integers $n$ and $p$, where $p$ is prime.\n\nThe second line contains $n$ integers $f(1), f(2), \\cdots , f(n)$, as defined in the statement.\n\nIt is guaranteed that in each line adjacent integers are separated by exactly one space, and there is no trailing space at the end of any line.", "outputFormat": "Output two lines describing the lexicographically smallest solution. The first line contains an integer $m\\ (m > 0)$, the number of elements in $S$. The second line contains $m$ positive integers $s_1, s_2, \\cdots , s_m$, which are the elements of $S$ sorted in ascending order.\n\nYou must ensure that in each output line, adjacent integers are separated by exactly one space, and there is no trailing space at the end of any line.", "hint": "For $100\\%$ of the testdata, we have $1 \\le n < 2^{18}$, $10^6 \\le p < 2^{30}$, $0 \\le f(i) < p \\ (i = 1, 2, \\cdots , n)$.\n\n![](https://cdn.luogu.com.cn/upload/pic/5548.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2017] 遗忘的集合", "background": "", "description": "小 Q 在他的个人主页上放出了一个悬赏：征集只含正整数的非空集合 $S$，其中的每个元素都不超过 $n$，并且满足一些附加条件。\n\n众所周知，我们可以很轻松地对于任意不超过 $n$ 的正整数 $x$，计算出把 $x$ 表示成 $S$ 中元素之和的方案数 $f(x)$，在这里我们约定，在任意方案中每个数字可以出现多次，但是不考虑数字出现的顺序。\n\n例如，当 $S=\\{1,2,3,4,5\\}$ 时，我们可以计算出 $f(2) = 2, f(3) = 3, f(4) = 5, f(5) = 7$。\n\n再例如，当 $S=\\{1,2,5\\}$ 时，我们可以计算出 $f(4) = 3, f(5) = 4, f(6) = 5, f(7) = 6$。\n\n麻烦地是现在小 Q 忘记了 $S$ 里有哪些元素，幸运地是他用存储设备记录下了所有 $f(i)\\bmod p$ 的值，小 Q 希望你能利用这些信息帮他恢复出 $S$ 原来的样子。\n\n具体来说，他希望你找到这样一个正整数的**非空**集合 $S$，其中的每个元素都不超过 $n$，并且对于任意的 $i = 1, 2,\\cdots ,n$，满足把 $i$ 表示成 $S$ 中元素之和的方案数在模 $p$ 意义下等于 $f(i)$，其中 $p$ 是记录在存储设备中的一个质数。他向你保证：**一定存在**这样的集合$S$。\n\n然而，小 Q 觉得他存储的信息并不足以恢复出唯一的 $S$，也就是说，可能会存在多个这样的集合 $S$，所以小 Q 希望你能给出所有解中**字典序最小**的解。\n\n对于满足条件的两个不同的集合 $S_1$ 和 $S_2$，我们认为 $S_1$ 的字典序比 $S_2$ 的字典序小，当且仅当存在非负整数 $k$，使得 $S_1$ 的前 $k$ 小元素与 $S_2$ 的前 $k$ 小元素完全相等，并且，要么 $S_1$ 的元素个数为 $k$，且 $S_2$ 的元素个数至少为 $(k + 1)$，要么 $S_1$ 和 $S_2$ 都有至少 $(k + 1)$ 个元素，且 $S_1$ 的第 $(k + 1)$ 小元素比 $S_2$ 的第 $(k + 1)$ 小元素小。\n", "inputFormat": "第一行包含两个整数 $n$ 和 $p$，满足 $p$ 是质数。\n\n第二行包含 $n$ 个整数 $f(1), f(2),\\cdots , f(n)$，含义见题目描述。\n\n保证每一行中相邻的整数由恰好一个空格隔开，并且末尾没有多余的空格。\n", "outputFormat": "你需要输出两行信息来描述字典序最小的解，其中第一行包含一个整数 $m\\ (m > 0)$，表示 $S$ 的元素个数，第二行包含 $m$ 个正整数 $s_1, s_2,\\cdots ,s_m$，表示将 $S$ 的所有元素按升序排序后得到的序列。\n\n你需要保证输出的每一行中相邻的整数由恰好一个空格隔开，并且每一行的末尾没有多余的空格。\n", "hint": "对于 $100\\%$ 的数据，有 $1 \\leq n < 2^{18} , 10^6 \\leq p < 2^{30} , 0 \\leq f(i) < p\\quad (i=1,2, \\cdots , n)$。\n\n![](https://cdn.luogu.com.cn/upload/pic/5548.png)\n", "locale": "zh-CN"}}}
{"pid": "P3785", "type": "P", "difficulty": 7, "samples": [["3\n5 3\n2 1 1 1 1\n1 1 1 1 2\n5 5\n5 2 3 3 4\n2 5 3 4 3\n5 5\n4 5 2 1 4\n5 4 2 1 4", "YES\n5 5\n1 3\n4 4\nNO\nYES\n2 2\n1 1\n3 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "各省省选", "山东", "Special Judge", "O2优化", "KMP 算法", "Manacher 算法", "分类讨论", "Z 函数"], "title": "[SDOI2017] 文本校正", "background": "", "description": "小Q在研发一种数据混淆的算法时不慎将重要的文档都给混淆了。幸运的是，将这些文档校正对于他来说并不是难事。他凭借着敏锐的观察力成功地用肉眼完成了校正。\n\n为了防止这种情况再次发生，小Q希望开发一种文本校正工具，他的目标是将一个文本串$T$分成连续的$3$段，要求每段都不能为空，然后按一定顺序将这$3$段从左往右拼接起来，将其还原为初始文本串$S$。\n\n在进行了大量肉眼校正工作之后，小Q需要休息一下，因此他把这个任务交给了你。请写一个程序，判断是否可以还原，并给出一个合法的还原方案。\n", "inputFormat": "第一行包含一个正整数$Case$，表示需要进行的校正次数。\n\n接下来$Case$个部分依次表示每次校正工作，每个部分第一行包含两个正整数$n$，$m$，分别表示文本串的长度以及字符集的大小。\n\n每个部分第二行包含$n$个正整数$S_1,S_2,\\dots ,S_n$，表示$S$串。\n\n每个部分第三行包含$n$个正整数$T_1,T_2,\\dots ,T_n$，表示$T$串。\n", "outputFormat": "对于每次校正工作，若无解，则仅输出一行\"NO\"(不含引号)，否则第一行输出\"YES\"(不含引号)，接下来三行每行两个正整数$l_i$，$r_i$，按拼接顺序依次表示$T$的$3$个子串。\n\n若存在多种还原方案，请输出任意一种。\n", "hint": "对于$100\\%$的数据，$3 \\leq n \\leq 1000000$，$1 \\leq Si,Ti \\leq m \\leq 1000000$。\n\n![](https://cdn.luogu.com.cn/upload/pic/5550.png)\n\nspj by @Wen_kr \n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2017] Text Correction", "background": "", "description": "While developing a data obfuscation algorithm, Xiao Q accidentally obfuscated some important documents. Fortunately, correcting these documents is not difficult for him. With keen observation, he managed to correct them by eye.\n\nTo prevent this from happening again, Xiao Q wants to develop a text correction tool. His goal is to split a string $T$ into three consecutive segments, each of which must be non-empty, then concatenate these 3 segments from left to right in some order to restore the original string $S$.\n\nAfter a lot of manual correction, Xiao Q needs a break, so he assigns this task to you. Please write a program to determine whether restoration is possible, and if so, output a valid restoration plan.", "inputFormat": "The first line contains a positive integer $Case$, the number of correction tasks.\n\nThen follow $Case$ parts, each describing one task. The first line of each part contains two positive integers $n$, $m$, denoting the length of the string and the size of the character set, respectively.\n\nThe second line of each part contains $n$ positive integers $S_1, S_2, \\dots, S_n$, representing the string $S$.\n\nThe third line of each part contains $n$ positive integers $T_1, T_2, \\dots, T_n$, representing the string $T$.", "outputFormat": "For each task, if there is no solution, output a single line \"NO\" (without quotes). Otherwise, output \"YES\" (without quotes) on the first line, and then output three lines, each containing two positive integers $l_i$, $r_i$, representing the 3 substrings of $T$ in the concatenation order.\n\nIf multiple restoration plans exist, output any one of them.", "hint": "Constraints: For $100\\%$ of the testdata, $3 \\leq n \\leq 1000000$, $1 \\leq S_i, T_i \\leq m \\leq 1000000$.\n\n![](https://cdn.luogu.com.cn/upload/pic/5550.png)\n\nspj by @Wen_kr.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2017] 文本校正", "background": "", "description": "小Q在研发一种数据混淆的算法时不慎将重要的文档都给混淆了。幸运的是，将这些文档校正对于他来说并不是难事。他凭借着敏锐的观察力成功地用肉眼完成了校正。\n\n为了防止这种情况再次发生，小Q希望开发一种文本校正工具，他的目标是将一个文本串$T$分成连续的$3$段，要求每段都不能为空，然后按一定顺序将这$3$段从左往右拼接起来，将其还原为初始文本串$S$。\n\n在进行了大量肉眼校正工作之后，小Q需要休息一下，因此他把这个任务交给了你。请写一个程序，判断是否可以还原，并给出一个合法的还原方案。\n", "inputFormat": "第一行包含一个正整数$Case$，表示需要进行的校正次数。\n\n接下来$Case$个部分依次表示每次校正工作，每个部分第一行包含两个正整数$n$，$m$，分别表示文本串的长度以及字符集的大小。\n\n每个部分第二行包含$n$个正整数$S_1,S_2,\\dots ,S_n$，表示$S$串。\n\n每个部分第三行包含$n$个正整数$T_1,T_2,\\dots ,T_n$，表示$T$串。\n", "outputFormat": "对于每次校正工作，若无解，则仅输出一行\"NO\"(不含引号)，否则第一行输出\"YES\"(不含引号)，接下来三行每行两个正整数$l_i$，$r_i$，按拼接顺序依次表示$T$的$3$个子串。\n\n若存在多种还原方案，请输出任意一种。\n", "hint": "对于$100\\%$的数据，$3 \\leq n \\leq 1000000$，$1 \\leq Si,Ti \\leq m \\leq 1000000$。\n\n![](https://cdn.luogu.com.cn/upload/pic/5550.png)\n\nspj by @Wen_kr \n", "locale": "zh-CN"}}}
