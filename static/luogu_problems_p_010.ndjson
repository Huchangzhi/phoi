{"pid": "P1201", "type": "P", "difficulty": 2, "samples": [["5\ndave\nlaura\nowen\nvick\namr\ndave\n200 3\nlaura\nowen\nvick\nowen\n500 1\ndave\namr\n150 2\nvick\nowen\nlaura\n0 2\namr\nvick\nvick\n0 0\n", "dave 302\nlaura 66\nowen -359\nvick 141\namr -150\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "USACO"], "title": "[USACO1.1] 贪婪的送礼者 Greedy Gift Givers", "background": null, "description": "对于一群 $n$ 个要互送礼物的朋友，GY 要确定每个人送出的钱比收到的多多少。在这一个问题中，每个人都准备了一些钱来送礼物，而这些钱将会被平均分给那些将收到他的礼物的人。  \n\n然而，在任何一群朋友中，有些人将送出较多的礼物(可能是因为有较多的朋友)，有些人有准备了较多的钱。  \n\n给出一群朋友，没有人的名字会长于 $14$ 字符，给出每个人将花在送礼上的钱，和将收到他的礼物的人的列表，请确定每个人收到的比送出的钱多的数目。", "inputFormat": "第一行一个正整数 $n$，表示人数。\n接下来 $n$ 行，每行一个字符串表示人名。\n\n接下来有 $n$ 段内容，对于每一段：\n第一行是将会送出礼物人的名字。  \n第二行包含二个非负整数，第一个是原有的钱的数目 ( $\\in [0,2000]$ )，第二个 $g_i$ 是将收到这个人礼物的人的个数 如果 $g_i \\neq 0$, 在下面 $g_i$ 行列出礼物的接受者的名字，一个名字一行。", "outputFormat": "输出共 $n$ 行，每行输出一个人的名字和该人收到的钱比送出的钱多的数目。名字的顺序应该与输入第 $ 2 $ 行至 $ n+1 $ 行的顺序相同。\n\n送出的钱永远是整数，即假设送礼人一次向 $ m $ 人送出 $ n $ 元，每个人应该得到 $ \\lfloor n/m \n\\rfloor $ 元。剩余未送出的钱应返还给送礼者。", "hint": "【数据范围】  \n$1\\le n \\le 10$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.1", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.1] Greedy Gift Givers", "background": "", "description": "In a group of $n$ friends who exchange gifts, GY wants to determine, for each person, how much more money they received than they gave.\n\nIn this problem, each person prepares some money for gifts, and that money is evenly divided among the people who will receive gifts from them.\n\nHowever, in any group of friends, some people will give gifts to more recipients (perhaps because they have more friends), and some people prepare more money.\n\nGiven a group of friends (no name is longer than 14 characters), along with how much each person spends on gifts and the list of recipients for each giver, determine for each person the amount of money received minus the amount of money given.", "inputFormat": "- The first line contains a positive integer $n$, the number of people.\n- The next $n$ lines each contain a string, the name of a person.\n\nThen there are $n$ blocks. For each block:\n- The first line is the name of the person who will give gifts.\n- The second line contains two non-negative integers: the first is the initial amount of money in $[0, 2000]$, and the second is $g_i$, the number of recipients of this person's gifts.  \n  If $g_i \\neq 0$, the next $g_i$ lines list the recipients' names, one per line.", "outputFormat": "Output $n$ lines. Each line contains a person's name and the amount of money they received minus the amount they gave. The order of names must be the same as in lines 2 through $n+1$ of the input.\n\nThe amount given out is always an integer. Specifically, suppose a giver distributes $n$ dollars to $m$ people at once; then each person should receive $\\lfloor n/m \\rfloor$ dollars. Any leftover money is returned to the giver.", "hint": "Constraints  \n$1 \\le n \\le 10$.\n\nTranslation adapted from NOCOW.  \nUSACO Training Section 1.1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.1] 贪婪的送礼者 Greedy Gift Givers", "background": null, "description": "对于一群 $n$ 个要互送礼物的朋友，GY 要确定每个人送出的钱比收到的多多少。在这一个问题中，每个人都准备了一些钱来送礼物，而这些钱将会被平均分给那些将收到他的礼物的人。  \n\n然而，在任何一群朋友中，有些人将送出较多的礼物(可能是因为有较多的朋友)，有些人有准备了较多的钱。  \n\n给出一群朋友，没有人的名字会长于 $14$ 字符，给出每个人将花在送礼上的钱，和将收到他的礼物的人的列表，请确定每个人收到的比送出的钱多的数目。", "inputFormat": "第一行一个正整数 $n$，表示人数。\n接下来 $n$ 行，每行一个字符串表示人名。\n\n接下来有 $n$ 段内容，对于每一段：\n第一行是将会送出礼物人的名字。  \n第二行包含二个非负整数，第一个是原有的钱的数目 ( $\\in [0,2000]$ )，第二个 $g_i$ 是将收到这个人礼物的人的个数 如果 $g_i \\neq 0$, 在下面 $g_i$ 行列出礼物的接受者的名字，一个名字一行。", "outputFormat": "输出共 $n$ 行，每行输出一个人的名字和该人收到的钱比送出的钱多的数目。名字的顺序应该与输入第 $ 2 $ 行至 $ n+1 $ 行的顺序相同。\n\n送出的钱永远是整数，即假设送礼人一次向 $ m $ 人送出 $ n $ 元，每个人应该得到 $ \\lfloor n/m \n\\rfloor $ 元。剩余未送出的钱应返还给送礼者。", "hint": "【数据范围】  \n$1\\le n \\le 10$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.1", "locale": "zh-CN"}}}
{"pid": "P1202", "type": "P", "difficulty": 2, "samples": [["20\n", "36 33 34 33 35 35 34\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "数学", "USACO"], "title": "[USACO1.1] 黑色星期五 Friday the Thirteenth", "background": null, "description": "$13$ 号又是一个星期五，那么 $13$ 号在星期五比在其他日子少吗？  \n\n为了回答这个问题，写一个程序，要求计算每个月的十三号落在周一到周日的次数。给出 $n$ 年的一个周期，要求计算 $1900$ 年 $1$ 月 $1$ 日至 $1900+n-1$ 年 $12$ 月 $31$ 日中十三号落在周一到周日的次数。\n\n这里有一些你要知道的：\n1. $1900$ 年 $1$ 月 $1$ 日是星期一。\n2. $4,6,9$ 和 $11$ 月有 $30$ 天，其他月份除了 $2$ 月都有 $31$ 天，闰年 $2$ 月有 $29$ 天，平年 $2$ 月有 $28$ 天。\n3. 年份可以被 $4$ 整除的为闰年（$1992=4\\times 498$ 所以 $1992$ 年是闰年，但是 $1990$ 年不是闰年）。\n4. 以上规则不适合于世纪年。可以被 $400$ 整除的世纪年为闰年，否则为平年。所以，$1700,1800,1900,2100$ 年是平年，而 $2000$ 年是闰年。", "inputFormat": "一个正整数 $n$。", "outputFormat": "依次输出周六、日、一、二、三、四、五在 $13$ 日出现的次数。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 400$。\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 1.1", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.1] Friday the Thirteenth", "background": "", "description": "It is Friday the $13$th again. Does the $13$th fall on Friday less often than on other days?\n\nTo answer this question, write a program that counts, for each month, how many times the $13$th falls on each day of the week. Given a period of $n$ years, compute the counts for dates from January $1$, $1900$ to December $31$, $1900 + n - 1$.\n\nHere are some things you need to know:\n1. January $1$, $1900$ was a Monday.\n2. Months $4$, $6$, $9$ and $11$ have $30$ days; all other months except month $2$ have $31$ days. In a leap year, February has $29$ days; in a common year, February has $28$ days.\n3. A year divisible by $4$ is a leap year ($1992 = 4 \\times 498$, so $1992$ is a leap year, but $1990$ is not).\n4. The above rule does not apply to century years. A century year divisible by $400$ is a leap year; otherwise, it is a common year. Thus, $1700$, $1800$, $1900$, and $2100$ are common years, while $2000$ is a leap year.", "inputFormat": "A single positive integer $n$.", "outputFormat": "Output, in order, the counts of Saturday, Sunday, Monday, Tuesday, Wednesday, Thursday, and Friday on which the $13$th occurs. Print them on one line, separated by spaces.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n \\le 400$.\n\nTranslation from NOCOW.  \nUSACO Training Section $1.1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.1] 黑色星期五 Friday the Thirteenth", "background": null, "description": "$13$ 号又是一个星期五，那么 $13$ 号在星期五比在其他日子少吗？  \n\n为了回答这个问题，写一个程序，要求计算每个月的十三号落在周一到周日的次数。给出 $n$ 年的一个周期，要求计算 $1900$ 年 $1$ 月 $1$ 日至 $1900+n-1$ 年 $12$ 月 $31$ 日中十三号落在周一到周日的次数。\n\n这里有一些你要知道的：\n1. $1900$ 年 $1$ 月 $1$ 日是星期一。\n2. $4,6,9$ 和 $11$ 月有 $30$ 天，其他月份除了 $2$ 月都有 $31$ 天，闰年 $2$ 月有 $29$ 天，平年 $2$ 月有 $28$ 天。\n3. 年份可以被 $4$ 整除的为闰年（$1992=4\\times 498$ 所以 $1992$ 年是闰年，但是 $1990$ 年不是闰年）。\n4. 以上规则不适合于世纪年。可以被 $400$ 整除的世纪年为闰年，否则为平年。所以，$1700,1800,1900,2100$ 年是平年，而 $2000$ 年是闰年。", "inputFormat": "一个正整数 $n$。", "outputFormat": "依次输出周六、日、一、二、三、四、五在 $13$ 日出现的次数。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 400$。\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 1.1", "locale": "zh-CN"}}}
{"pid": "P1203", "type": "P", "difficulty": 2, "samples": [["29 \nwwwbbrwrbrbrrbrbrwrwwrbwrwrrb\n", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP", "搜索", "USACO", "单调队列", "IOI"], "title": "[IOI 1993 / USACO1.1] 坏掉的项链 Broken Necklace", "background": null, "description": "你有一条由 $n$ 个红色的，白色的，或蓝色的珠子组成的项链，珠子是随意安排的。这里是 $n=29$ 的两个例子:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i7imvc0g.png) \n\n第一和第二个珠子在图片中已经被作记号。\n\n图片 A 中的项链可以用下面的字符串表示：`brbrrrbbbrrrrrbrrbbrbbbbrrrrb`\n\n假如你要在一些点打破项链，展开成一条直线，然后从一端开始收集同颜色的珠子直到你遇到一个不同的颜色珠子，在另一端做同样的事（颜色可能与在这之前收集的不同）。确定应该在哪里打破项链来收集到最大数目的珠子。\n\n例如，在图片 A 中的项链中，在珠子 $9$ 和珠子 $10$ 或珠子 $24$ 和珠子 $25$ 之间打断项链可以收集到 $8$ 个珠子。\n\n表现含有白珠项链的字符串将会包括三个符号 `r`，`b`，`w`。\n\n写一个程序来确定从一条被给出的项链可以收集到的珠子最大数目。\n\n::::info[白色珠子是什么？]\n\n在一些项链中还包括白色的珠子（如图片 B）所示。\n\n当收集珠子的时候，一个被遇到的白色珠子可以被当做红色也可以被当做蓝色。\n::::", "inputFormat": "第一行一个正整数 $n$，表示珠子数目。\n\n第二行一串长度为 $n$ 的字符串，每个字符是 `r`，`b` 或 `w`。", "outputFormat": "输出一行一个整数，表示从给出的项链中可以收集到的珠子的最大数量。", "hint": "**【数据范围】** \n\n对于 $100\\%$ 的数据，$3\\le n \\le 350$。\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 1.1", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 1993 / USACO1.1] Broken Necklace", "background": null, "description": "You have a necklace made of $n$ beads that are red, white, or blue, arranged arbitrarily. Here are two examples for $n=29$:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i7imvc0g.png)\n\nThe first and second beads are marked in the picture.\n\nThe necklace in Figure A can be represented by the string: `brbrrrbbbrrrrrbrrbbrbbbbrrrrb`.\n\nSuppose you break the necklace at some point, lay it out in a line, then from one end start collecting beads of a single color until you encounter a bead of a different color, and do the same from the other end (the color you collect on the two sides may differ). Determine where to break the necklace to collect the maximum number of beads.\n\nFor example, for the necklace in Figure A, breaking between bead $9$ and bead $10$, or between bead $24$ and bead $25$, allows you to collect $8$ beads.\n\nA string representing a necklace that may include white beads will use exactly the three symbols `r`, `b`, `w`.\n\nWrite a program to determine the maximum number of beads that can be collected from the given necklace.\n\n::::info[白色珠子是什么？]\nIn some necklaces, there are also white beads (as in Figure B).\n\nWhen collecting beads, any white bead you encounter may be treated as red or as blue.\n::::", "inputFormat": "The first line contains a positive integer $n$, the number of beads.\n\nThe second line contains a string of length $n$, where each character is `r`, `b`, or `w`.", "outputFormat": "Output a single integer on one line: the maximum number of beads that can be collected from the given necklace.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $3\\le n \\le 350$.\n\nTranslated from NOCOW.\n\nUSACO Training Section 1.1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 1993 / USACO1.1] 坏掉的项链 Broken Necklace", "background": null, "description": "你有一条由 $n$ 个红色的，白色的，或蓝色的珠子组成的项链，珠子是随意安排的。这里是 $n=29$ 的两个例子:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i7imvc0g.png) \n\n第一和第二个珠子在图片中已经被作记号。\n\n图片 A 中的项链可以用下面的字符串表示：`brbrrrbbbrrrrrbrrbbrbbbbrrrrb`\n\n假如你要在一些点打破项链，展开成一条直线，然后从一端开始收集同颜色的珠子直到你遇到一个不同的颜色珠子，在另一端做同样的事（颜色可能与在这之前收集的不同）。确定应该在哪里打破项链来收集到最大数目的珠子。\n\n例如，在图片 A 中的项链中，在珠子 $9$ 和珠子 $10$ 或珠子 $24$ 和珠子 $25$ 之间打断项链可以收集到 $8$ 个珠子。\n\n表现含有白珠项链的字符串将会包括三个符号 `r`，`b`，`w`。\n\n写一个程序来确定从一条被给出的项链可以收集到的珠子最大数目。\n\n::::info[白色珠子是什么？]\n\n在一些项链中还包括白色的珠子（如图片 B）所示。\n\n当收集珠子的时候，一个被遇到的白色珠子可以被当做红色也可以被当做蓝色。\n::::", "inputFormat": "第一行一个正整数 $n$，表示珠子数目。\n\n第二行一串长度为 $n$ 的字符串，每个字符是 `r`，`b` 或 `w`。", "outputFormat": "输出一行一个整数，表示从给出的项链中可以收集到的珠子的最大数量。", "hint": "**【数据范围】** \n\n对于 $100\\%$ 的数据，$3\\le n \\le 350$。\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 1.1", "locale": "zh-CN"}}}
{"pid": "P1204", "type": "P", "difficulty": 2, "samples": [["3\n300 1000\n700 1200\n1500 2100\n", "900 300\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "线段树", "USACO", "排序", "差分"], "title": "[USACO1.2] 挤牛奶 Milking Cows", "background": null, "description": "三个农民每天清晨 $5$ 点起床，然后去牛棚给三头牛挤奶。\n\n第一个农民在 $300$ 秒（从 $5$ 点开始计时）给他的牛挤奶，一直到 $1000$ 秒。第二个农民在 $700$ 秒开始，在 $1200$ 秒结束。第三个农民在 $1500$ 秒开始，$2100$ 秒结束。  \n\n期间最长的至少有一个农民在挤奶的连续时间为 $900$ 秒（从 $300$ 秒到 $1200$ 秒），而最长的无人挤奶的连续时间（从挤奶开始一直到挤奶结束）为 $300$ 秒（从 $1200$ 秒到 $1500$ 秒）。\n\n---\n你的任务是编一个程序，读入一个有 $n$ 个农民挤 $n$ 头牛的工作时间列表，计算以下两点（均以秒为单位）：\n\n1. 最长至少有一人在挤奶的时间段。\n2. 最长的无人挤奶的时间段。（从有人挤奶开始算起）", "inputFormat": "第一行一个正整数 $n$。\n\n接下来 $n$ 行，每行两个非负整数 $l,r$，表示一个农民的开始时刻与结束时刻。", "outputFormat": "仅一行两个整数，以一个空格分隔，即题目所要求的两个答案。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 5000$，$0 \\le l \\le r \\le 10^6$。\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 1.2", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.2] Milking Cows", "background": "", "description": "Three farmers get up at $5$ a.m. every morning and go to the barn to milk three cows.\n\nThe first farmer starts milking at $300$ seconds (counted from $5$ o'clock) and continues until $1000$ seconds. The second farmer starts at $700$ seconds and ends at $1200$ seconds. The third farmer starts at $1500$ seconds and ends at $2100$ seconds.  \n\nThe longest continuous time during which at least one farmer is milking is $900$ seconds (from $300$ seconds to $1200$ seconds), and the longest continuous time during which no one is milking (from the beginning of any milking to the end of all milking) is $300$ seconds (from $1200$ seconds to $1500$ seconds).\n\nYour task is to write a program that reads a list of working times for $n$ farmers milking $n$ cows and computes the following two values (both in seconds):\n\n1. The longest interval during which at least one person is milking.\n2. The longest interval during which no one is milking (counted from when milking begins).", "inputFormat": "The first line contains a positive integer $n$.\n\nThe next $n$ lines each contain two non-negative integers $l, r$, representing one farmer’s start time and end time.", "outputFormat": "Output a single line with two integers separated by a single space: the two answers required by the problem.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n \\le 5000$, $0 \\le l \\le r \\le 10^6$.\n\nProblem translation from NOCOW.\n\nUSACO Training Section $1.2$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.2] 挤牛奶 Milking Cows", "background": null, "description": "三个农民每天清晨 $5$ 点起床，然后去牛棚给三头牛挤奶。\n\n第一个农民在 $300$ 秒（从 $5$ 点开始计时）给他的牛挤奶，一直到 $1000$ 秒。第二个农民在 $700$ 秒开始，在 $1200$ 秒结束。第三个农民在 $1500$ 秒开始，$2100$ 秒结束。  \n\n期间最长的至少有一个农民在挤奶的连续时间为 $900$ 秒（从 $300$ 秒到 $1200$ 秒），而最长的无人挤奶的连续时间（从挤奶开始一直到挤奶结束）为 $300$ 秒（从 $1200$ 秒到 $1500$ 秒）。\n\n---\n你的任务是编一个程序，读入一个有 $n$ 个农民挤 $n$ 头牛的工作时间列表，计算以下两点（均以秒为单位）：\n\n1. 最长至少有一人在挤奶的时间段。\n2. 最长的无人挤奶的时间段。（从有人挤奶开始算起）", "inputFormat": "第一行一个正整数 $n$。\n\n接下来 $n$ 行，每行两个非负整数 $l,r$，表示一个农民的开始时刻与结束时刻。", "outputFormat": "仅一行两个整数，以一个空格分隔，即题目所要求的两个答案。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 5000$，$0 \\le l \\le r \\le 10^6$。\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 1.2", "locale": "zh-CN"}}}
{"pid": "P1205", "type": "P", "difficulty": 3, "samples": [["3\n@-@\n---\n@@-\n@-@\n@--\n--@\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "USACO"], "title": "[USACO1.2] 方块转换 Transformations", "background": "", "description": "一块 $n \\times n$ 正方形的黑白瓦片的图案要被转换成新的正方形图案。写一个程序来找出将原始图案按照以下列转换方法转换成新图案的最小方式：\n\n- 转 $90\\degree$：图案按顺时针转 $90\\degree$。\n\n- 转 $180\\degree$：图案按顺时针转 $180\\degree$。\n\n- 转 $270\\degree$：图案按顺时针转 $270\\degree$。\n\n- 反射：图案在水平方向翻转（以中央铅垂线为中心形成原图案的镜像）。\n\n- 组合：图案在水平方向翻转，然后再按照 $1 \\sim 3$ 之间的一种再次转换。\n\n- 不改变：原图案不改变。\n\n- 无效转换：无法用以上方法得到新图案。\n\n如果有多种可用的转换方法，请选择序号最小的那个。\n\n只使用上述 $7$ 个中的一个步骤来完成这次转换。\n", "inputFormat": "第一行一个正整数 $n$。   \n\n然后 $n$ 行，每行 $n$ 个字符，全部为 `@` 或 `-`，表示初始的正方形。\n\n接下来 $n$ 行，每行 $n$ 个字符，全部为 `@` 或 `-`，表示最终的正方形。\n\n", "outputFormat": "单独的一行包括 $1 \\sim 7$ 之间的一个数字（在上文已描述）表明需要将转换前的正方形变为转换后的正方形的转换方法。\n\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 10$。\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 1.2\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.2] Transformations", "background": "", "description": "A black-and-white pattern on an $n \\times n$ square of tiles is to be transformed into a new square pattern. Write a program to find the minimal method to convert the original pattern into the new one using the following transformations:\n\n- Rotate $90\\degree$: Rotate the pattern $90\\degree$ clockwise.\n- Rotate $180\\degree$: Rotate the pattern $180\\degree$ clockwise.\n- Rotate $270\\degree$: Rotate the pattern $270\\degree$ clockwise.\n- Reflect: Flip the pattern horizontally (mirror over the central vertical line).\n- Combination: First reflect horizontally, then apply one of the transformations in $1 \\sim 3$.\n- No change: The original pattern is unchanged.\n- Invalid transformation: The new pattern cannot be obtained by the above methods.\n\nIf more than one method works, choose the one with the smallest index.\n\nUse exactly one of the above $7$ steps to accomplish this transformation.", "inputFormat": "The first line contains a positive integer $n$.\n\nThen follow $n$ lines, each containing $n$ characters, all `@` or `-`, representing the initial square.\n\nThen follow another $n$ lines, each containing $n$ characters, all `@` or `-`, representing the target square.", "outputFormat": "A single line containing a number between $1 \\sim 7$ (as described above) indicating the transformation method required to convert the original square into the target square.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n \\le 10$.\n\nProblem translation from NOCOW.\n\nUSACO Training Section 1.2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.2] 方块转换 Transformations", "background": "", "description": "一块 $n \\times n$ 正方形的黑白瓦片的图案要被转换成新的正方形图案。写一个程序来找出将原始图案按照以下列转换方法转换成新图案的最小方式：\n\n- 转 $90\\degree$：图案按顺时针转 $90\\degree$。\n\n- 转 $180\\degree$：图案按顺时针转 $180\\degree$。\n\n- 转 $270\\degree$：图案按顺时针转 $270\\degree$。\n\n- 反射：图案在水平方向翻转（以中央铅垂线为中心形成原图案的镜像）。\n\n- 组合：图案在水平方向翻转，然后再按照 $1 \\sim 3$ 之间的一种再次转换。\n\n- 不改变：原图案不改变。\n\n- 无效转换：无法用以上方法得到新图案。\n\n如果有多种可用的转换方法，请选择序号最小的那个。\n\n只使用上述 $7$ 个中的一个步骤来完成这次转换。\n", "inputFormat": "第一行一个正整数 $n$。   \n\n然后 $n$ 行，每行 $n$ 个字符，全部为 `@` 或 `-`，表示初始的正方形。\n\n接下来 $n$ 行，每行 $n$ 个字符，全部为 `@` 或 `-`，表示最终的正方形。\n\n", "outputFormat": "单独的一行包括 $1 \\sim 7$ 之间的一个数字（在上文已描述）表明需要将转换前的正方形变为转换后的正方形的转换方法。\n\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 10$。\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 1.2\n", "locale": "zh-CN"}}}
{"pid": "P1206", "type": "P", "difficulty": 2, "samples": [["10\n", "1 1\n2 4\n3 9\n11 121\n22 484\n26 676\n101 10201\n111 12321\n121 14641\n202 40804\n212 44944\n264 69696\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO", "进制"], "title": "[USACO1.2] 回文平方数 Palindromic Squares", "background": "", "description": "回文数是指从左向右念和从右向左念都一样的数。如 $12321$ 就是一个典型的回文数。\n\n给定一个用十进制表示的正整数 $B$，输出所有 $[1,300]$ 中，它的平方用 $B$ 进制表示时是回文数的数。\n", "inputFormat": "共一行，一个单独的正整数 $B$。\n", "outputFormat": "每行两个 $B$ 进制的符合要求的数字，第二个数是第一个数的平方，且第二个数是回文数。\n\n注意大于 $9$ 的数，用字母表示。如用 `A` 表示 $10$，`B` 表示 $11$，用第 $n$ 个大写字母表示 $n+9$。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$2 \\le B \\le 20$\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.2\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.2] Palindromic Squares", "background": "", "description": "A palindromic number is a number that reads the same from left to right and from right to left. For example, $12321$ is a typical palindrome.\n\nGiven a positive integer $B$ written in decimal, output all integers in $[1, 300]$ whose squares, when written in base $B$, are palindromes.", "inputFormat": "One line containing a single positive integer $B$.", "outputFormat": "Each line contains two base-$B$ numbers: the first number and its square. The second number must be a palindrome.\n\nNote that digits greater than $9$ are represented by letters. For example, use `A` for $10$, `B` for $11$, and use the $n$-th uppercase letter to represent $n + 9$.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $2 \\le B \\le 20$.\n\nTranslation from NOCOW.\n\nUSACO Training Section 1.2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.2] 回文平方数 Palindromic Squares", "background": "", "description": "回文数是指从左向右念和从右向左念都一样的数。如 $12321$ 就是一个典型的回文数。\n\n给定一个用十进制表示的正整数 $B$，输出所有 $[1,300]$ 中，它的平方用 $B$ 进制表示时是回文数的数。\n", "inputFormat": "共一行，一个单独的正整数 $B$。\n", "outputFormat": "每行两个 $B$ 进制的符合要求的数字，第二个数是第一个数的平方，且第二个数是回文数。\n\n注意大于 $9$ 的数，用字母表示。如用 `A` 表示 $10$，`B` 表示 $11$，用第 $n$ 个大写字母表示 $n+9$。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$2 \\le B \\le 20$\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.2\n", "locale": "zh-CN"}}}
{"pid": "P1207", "type": "P", "difficulty": 2, "samples": [["3 25\n", "26\n27\n28\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO", "进制"], "title": "[USACO1.2] 双重回文数 Dual Palindromes", "background": "如果一个数从左往右读和从右往左读都是一样，那么这个数就叫做“回文数”。例如，$12321$ 就是一个回文数，而 $77778$ 就不是。当然，回文数的首和尾都应是非零的，因此 $0220$ 就不是回文数。\n\n事实上，有一些数（如 $21$ ），在十进制时不是回文数，但在其它进制（如二进制时为 $10101$ ）时就是回文数。", "description": "给定两个十进制数 $n,s$，然后找出前 $n$ 个满足大于 $s$ 且在不少于两种进制（二进制至十进制）上是回文数的十进制数，输出到文件上。\n\n本问题的解决方案不需要使用大于 $32$ 位的整型数\n\n", "inputFormat": "只有一行，用空格隔开的两个正整数 $n,s$。\n", "outputFormat": "$n$ 行, 每行一个满足上述要求的数，并按从小到大的顺序输出。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 15$，$1\\le s \\le 9999$\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.2\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.2] Dual Palindromes", "background": "If a number reads the same from left to right and from right to left, then it is called a \"palindrome.\" For example, $12321$ is a palindrome, while $77778$ is not. We do not allow leading zeros in the representation; therefore, $0220$ is not considered a palindrome.\n\nIn fact, some numbers (such as $21$) are not palindromes in base $10$, but they are palindromes in other bases (for example, in base $2$ it is $10101$).", "description": "Given two decimal integers $n, s$, find the first $n$ decimal numbers greater than $s$ that are palindromic in at least two bases among base $2$ through base $10$, and output them.\n\nA solution to this problem does not need integers wider than $32$ bits.", "inputFormat": "One line containing two positive integers $n, s$ separated by a space.", "outputFormat": "Output $n$ lines. Each line contains one number that satisfies the requirement, in ascending order.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n \\le 15$, $1 \\le s \\le 9999$.\n\nProblem translation from NOCOW.\n\nUSACO Training Section 1.2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.2] 双重回文数 Dual Palindromes", "background": "如果一个数从左往右读和从右往左读都是一样，那么这个数就叫做“回文数”。例如，$12321$ 就是一个回文数，而 $77778$ 就不是。当然，回文数的首和尾都应是非零的，因此 $0220$ 就不是回文数。\n\n事实上，有一些数（如 $21$ ），在十进制时不是回文数，但在其它进制（如二进制时为 $10101$ ）时就是回文数。", "description": "给定两个十进制数 $n,s$，然后找出前 $n$ 个满足大于 $s$ 且在不少于两种进制（二进制至十进制）上是回文数的十进制数，输出到文件上。\n\n本问题的解决方案不需要使用大于 $32$ 位的整型数\n\n", "inputFormat": "只有一行，用空格隔开的两个正整数 $n,s$。\n", "outputFormat": "$n$ 行, 每行一个满足上述要求的数，并按从小到大的顺序输出。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 15$，$1\\le s \\le 9999$\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.2\n", "locale": "zh-CN"}}}
{"pid": "P1208", "type": "P", "difficulty": 2, "samples": [["100 5\n5 20\n9 40\n3 10\n8 80\n6 30\n", "630\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "USACO"], "title": "[USACO1.3] 混合牛奶 Mixing Milk", "background": null, "description": "由于乳制品产业利润很低，所以降低原材料（牛奶）价格就变得十分重要。帮助 Marry 乳业找到最优的牛奶采购方案。\n\nMarry 乳业从一些奶农手中采购牛奶，并且每一位奶农为乳制品加工企业提供的价格可能相同。此外，就像每头奶牛每天只能挤出固定数量的奶，每位奶农每天能提供的牛奶数量是一定的。每天 Marry 乳业可以从奶农手中采购到小于或者等于奶农最大产量的整数数量的牛奶。\n\n给出 Marry 乳业每天对牛奶的需求量，还有每位奶农提供的牛奶单价和产量。计算采购足够数量的牛奶所需的最小花费。\n\n注：每天所有奶农的总产量不少于 Marry 乳业的需求量。", "inputFormat": "第一行二个整数 $n,m$，表示需要牛奶的总量，和提供牛奶的农民个数。\n\n接下来 $m$ 行，每行两个整数 $p_i,a_i$，表示第 $i$ 个农民牛奶的单价，和农民 $i$ 一天最多能卖出的牛奶量。", "outputFormat": "单独的一行包含单独的一个整数，表示 Marry 的牛奶制造公司拿到所需的牛奶所要的最小费用。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据：  \n$0 \\le n,a_i \\le 2 \\times 10^6$，$0\\le m \\le 5000$，$0 \\le p_i \\le 1000$。\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 1.3", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.3] Mixing Milk", "background": "", "description": "Because the profit margin in the dairy industry is very low, reducing the price of raw materials (milk) becomes very important. Help Marry Dairy find the optimal milk purchasing plan.\n\nMarry Dairy purchases milk from several farmers, and the price offered by each farmer to the dairy processor may be the same. Also, just as each cow can only produce a fixed amount of milk per day, each farmer can provide a fixed amount of milk per day. Each day, Marry Dairy can purchase an integer amount of milk from each farmer, not exceeding that farmer’s maximum daily output.\n\nGiven Marry Dairy’s daily milk demand, as well as each farmer’s unit price and maximum supply, compute the minimum cost to purchase enough milk.\n\nNote: The total daily supply of all farmers is at least Marry Dairy’s demand.", "inputFormat": "The first line contains two integers $n,m$, representing the total amount of milk needed and the number of farmers.\n\nThe next $m$ lines each contain two integers $p_i,a_i$, representing the unit price of milk from the $i$-th farmer and the maximum amount of milk the $i$-th farmer can sell in one day.", "outputFormat": "A single line containing a single integer, representing the minimum cost for Marry Dairy to obtain the required amount of milk.", "hint": "Constraints  \nFor $100\\%$ of the testdata:  \n$0 \\le n,a_i \\le 2 \\times 10^6$，$0\\le m \\le 5000$，$0 \\le p_i \\le 1000$.\n\nTranslation adapted from NOCOW.\n\nUSACO Training Section 1.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.3] 混合牛奶 Mixing Milk", "background": null, "description": "由于乳制品产业利润很低，所以降低原材料（牛奶）价格就变得十分重要。帮助 Marry 乳业找到最优的牛奶采购方案。\n\nMarry 乳业从一些奶农手中采购牛奶，并且每一位奶农为乳制品加工企业提供的价格可能相同。此外，就像每头奶牛每天只能挤出固定数量的奶，每位奶农每天能提供的牛奶数量是一定的。每天 Marry 乳业可以从奶农手中采购到小于或者等于奶农最大产量的整数数量的牛奶。\n\n给出 Marry 乳业每天对牛奶的需求量，还有每位奶农提供的牛奶单价和产量。计算采购足够数量的牛奶所需的最小花费。\n\n注：每天所有奶农的总产量不少于 Marry 乳业的需求量。", "inputFormat": "第一行二个整数 $n,m$，表示需要牛奶的总量，和提供牛奶的农民个数。\n\n接下来 $m$ 行，每行两个整数 $p_i,a_i$，表示第 $i$ 个农民牛奶的单价，和农民 $i$ 一天最多能卖出的牛奶量。", "outputFormat": "单独的一行包含单独的一个整数，表示 Marry 的牛奶制造公司拿到所需的牛奶所要的最小费用。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据：  \n$0 \\le n,a_i \\le 2 \\times 10^6$，$0\\le m \\le 5000$，$0 \\le p_i \\le 1000$。\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 1.3", "locale": "zh-CN"}}}
{"pid": "P1209", "type": "P", "difficulty": 3, "samples": [["4 50 18\n3 \n4 \n6 \n8 \n14\n15 \n16 \n17 \n21\n25 \n26 \n27 \n30 \n31 \n40 \n41 \n42 \n43\n", "25\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "贪心", "USACO", "排序"], "title": "[USACO1.3] 修理牛棚 Barn Repair", "background": "", "description": "在一个月黑风高的暴风雨夜，Farmer John 的牛棚的屋顶、门被吹飞了 好在许多牛正在度假，所以牛棚没有住满。   \n\n牛棚一个紧挨着另一个被排成一行，牛就住在里面过夜。有些牛棚里有牛，有些没有。 所有的牛棚有相同的宽度。   \n\n自门遗失以后，Farmer John 必须尽快在牛棚之前竖立起新的木板。他的新木材供应商将会供应他任何他想要的长度，但是吝啬的供应商只能提供有限数目的木板。 Farmer John 想将他购买的木板总长度减到最少。\n\n给出 $m,s,c$，表示木板最大的数目、牛棚的总数、牛的总数；以及每头牛所在牛棚的编号，请算出拦住所有有牛的牛棚所需木板的最小总长度。\n", "inputFormat": "一行三个整数 $m,s,c$，意义如题目描述。   \n接下来 $c$ 行，每行包含一个整数，表示牛所占的牛棚的编号。\n", "outputFormat": "输出一行一个整数，表示所需木板的最小总长度。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le m \\le 50$，$1\\le c \\le s \\le 200$。 \n\nUSACO Training Section 1.3\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.3] Barn Repair", "background": "", "description": "On a dark and stormy night, the roof and doors of Farmer John's barn were blown off. Fortunately, many cows are on vacation, so the barn is not full.\n\nThe stalls are arranged in a single row, one right next to another, and cows stay in them overnight. Some stalls are occupied, others are empty. All stalls have the same width.\n\nSince the doors were lost, Farmer John must quickly put up new wooden boards in front of the stalls. His new lumber supplier can provide boards of any length he wants, but, being stingy, can supply only a limited number of boards. Farmer John wants to minimize the total length of the boards he buys.\n\nGiven $m, s, c$ — the maximum number of boards, the total number of stalls, and the total number of cows — and the index of the stall occupied by each cow, compute the minimal total length of boards required to block all stalls that contain cows. Each board covers a consecutive range of stalls.", "inputFormat": "One line with three integers $m, s, c$, as described above.  \nThen $c$ lines follow, each containing one integer, the index of a stall that contains a cow.", "outputFormat": "Output a single line with one integer, the minimal total length of boards required.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le m \\le 50$, $1 \\le c \\le s \\le 200$.\n\nUSACO Training Section 1.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.3] 修理牛棚 Barn Repair", "background": "", "description": "在一个月黑风高的暴风雨夜，Farmer John 的牛棚的屋顶、门被吹飞了 好在许多牛正在度假，所以牛棚没有住满。   \n\n牛棚一个紧挨着另一个被排成一行，牛就住在里面过夜。有些牛棚里有牛，有些没有。 所有的牛棚有相同的宽度。   \n\n自门遗失以后，Farmer John 必须尽快在牛棚之前竖立起新的木板。他的新木材供应商将会供应他任何他想要的长度，但是吝啬的供应商只能提供有限数目的木板。 Farmer John 想将他购买的木板总长度减到最少。\n\n给出 $m,s,c$，表示木板最大的数目、牛棚的总数、牛的总数；以及每头牛所在牛棚的编号，请算出拦住所有有牛的牛棚所需木板的最小总长度。\n", "inputFormat": "一行三个整数 $m,s,c$，意义如题目描述。   \n接下来 $c$ 行，每行包含一个整数，表示牛所占的牛棚的编号。\n", "outputFormat": "输出一行一个整数，表示所需木板的最小总长度。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le m \\le 50$，$1\\le c \\le s \\le 200$。 \n\nUSACO Training Section 1.3\n", "locale": "zh-CN"}}}
{"pid": "P1210", "type": "P", "difficulty": 3, "samples": [["Confucius say: Madam, I'm Adam. ", "11\nMadam, I'm Adam"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "搜索", "USACO", "枚举"], "title": "[USACO1.3] 最长的回文 Calf Flac", "background": "", "description": "据说如果你给无限只母牛和无限台巨型便携式电脑（有非常大的键盘 ), 那么母牛们会制造出世上最棒的回文。你的工作就是去寻找这些牛制造的奇观（最棒的回文）。\n\n在寻找回文时不用理睬那些标点符号、空格（但应该保留下来以便做为答案输出）, 只用考虑字母 ${\\tt A}\\sim {\\tt Z}$ 和 ${\\tt a}\\sim {\\tt z}$。要你寻找的最长的回文的文章是一个不超过 $20{,}000$ 个字符的字符串。我们将保证最长的回文不会超过 $2{,}000$ 个字符（在除去标点符号、空格之前）。", "inputFormat": "输入文件不会超过 $20,000$ 字符。这个文件可能一行或多行，但是每行都不超过 $80$ 个字符（不包括最后的换行符）。", "outputFormat": "输出的第一行应该包括找到的最长的回文的长度。\n\n下一行或几行应该包括这个回文的原文（没有除去标点符号、空格），把这个回文输出到一行或多行（如果回文中包括换行符）。\n\n如果有多个回文长度都等于最大值，输出最前面出现的那一个。\n", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 1.3\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.3] Longest Palindrome Calf Flac", "background": "", "description": "It is said that if you give infinitely many cows and infinitely many giant portable computers (with very large keyboards), the cows will create the best palindrome in the world. Your job is to find this marvel (the finest palindrome) produced by the cows.\n\nWhen searching for the palindrome, ignore punctuation and spaces (but keep them so they can be printed in the answer). Only consider the letters ${\\tt A}\\sim {\\tt Z}$ and ${\\tt a}\\sim {\\tt z}$. The text in which you must find the longest palindrome is a string of at most $20{,}000$ characters. We guarantee that the longest palindrome will not exceed $2{,}000$ characters (before removing punctuation and spaces).", "inputFormat": "The input file will not exceed $20{,}000$ characters. This file may have one or more lines, but each line will not exceed $80$ characters (excluding the final newline).", "outputFormat": "The first line should contain the length of the longest palindrome found.\n\nThe next line or lines should contain this palindrome in its original text (without removing punctuation and spaces), printed across one or more lines (if the palindrome contains newline characters).\n\nIf multiple palindromes have the same maximal length, output the one that appears earliest.", "hint": "The problem translation comes from NOCOW.\n\nUSACO Training Section 1.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.3] 最长的回文 Calf Flac", "background": "", "description": "据说如果你给无限只母牛和无限台巨型便携式电脑（有非常大的键盘 ), 那么母牛们会制造出世上最棒的回文。你的工作就是去寻找这些牛制造的奇观（最棒的回文）。\n\n在寻找回文时不用理睬那些标点符号、空格（但应该保留下来以便做为答案输出）, 只用考虑字母 ${\\tt A}\\sim {\\tt Z}$ 和 ${\\tt a}\\sim {\\tt z}$。要你寻找的最长的回文的文章是一个不超过 $20{,}000$ 个字符的字符串。我们将保证最长的回文不会超过 $2{,}000$ 个字符（在除去标点符号、空格之前）。", "inputFormat": "输入文件不会超过 $20,000$ 字符。这个文件可能一行或多行，但是每行都不超过 $80$ 个字符（不包括最后的换行符）。", "outputFormat": "输出的第一行应该包括找到的最长的回文的长度。\n\n下一行或几行应该包括这个回文的原文（没有除去标点符号、空格），把这个回文输出到一行或多行（如果回文中包括换行符）。\n\n如果有多个回文长度都等于最大值，输出最前面出现的那一个。\n", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 1.3\n", "locale": "zh-CN"}}}
{"pid": "P1211", "type": "P", "difficulty": 2, "samples": [["5\n2 3 4 6 8\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO", "枚举"], "title": "[USACO1.3] 牛式 Prime Cryptarithm", "background": "", "description": "下面是一个乘法竖式，如果用我们给定的那 $n$ 个数字来取代 `*`，可以使式子成立的话，我们就叫这个式子为牛式。\n\n```cpp\n          ***\n    x      **\n   ----------\n         ***\n        ***\n   ----------\n        ****\n```\n\n数字只能取代 `*`，当然第一位不能为 $0$，况且给定的数字里不包括 $0$。\n\n\n注意一下在美国的学校中教的“部分乘积”，第一部分乘积是第二个数的个位和第一个数的积，第二部分乘积是第二个数的十位和第一个数的乘积。\n\n请计算出牛式的数量。\n\n", "inputFormat": "第一行一个正整数 $n$，表示可用的数集。   \n第二行 $n$ 个正整数 $a_i$，表示可用的数。\n", "outputFormat": "输出一行一个整数，表示牛式的总数。\n", "hint": "### 样例解释\n\n```\n          222\n    x      22\n   ----------\n         444\n        444\n   ----------\n        4884\n```\n\n不需要别的数，严格符合上图的数位情况，可以证明没有其他情况。\n\n\n\n不加入样例解释：做题人如果理解错题意会进入误区\n\n比如不用填中间的数，位数没有要求 `34*2=68` 符合要求等误区。\n\n### 数据规模  \n对于 $100\\%$ 的数据，$1\\le n \\le 9$，$a_i \\in [1,9] \\cap \\mathbb Z$ 且 $a_i$ 不重复。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.4\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.3] Cow-Style Prime Cryptarithm", "background": "", "description": "Below is a vertical multiplication. If we can replace each `*` with one of the given $n$ digits so that the equation is correct, we call it a \"cow-style\" multiplication.\n\n```cpp\n          ***\n    x      **\n   ----------\n         ***\n        ***\n   ----------\n        ****\n```\n\nDigits may only replace `*`. The leading digit of any number cannot be $0$; besides, $0$ is not among the given digits.\n\nNote the \"partial products\" as taught in U.S. schools: the first partial product is the product of the units digit of the second number and the first number; the second partial product is the product of the tens digit of the second number and the first number.\n\nCompute the number of such \"cow-style\" cryptarithms.\n\nProblem translation from NOCOW. USACO Training Section 1.4.", "inputFormat": "The first line contains a positive integer $n$, the size of the available digit set.  \nThe second line contains $n$ positive integers $a_i$, the available digits.", "outputFormat": "Output a single line with one integer, the total number of cow-style cryptarithms.", "hint": "### Sample Explanation\n\n```\n          222\n    x      22\n   ----------\n         444\n        444\n   ----------\n        4884\n```\n\nNo other digits are needed. This strictly follows the digit layout shown above, and it can be proved there are no other cases.\n\nWithout the sample explanation, solvers may misunderstand the statement and fall into traps, such as thinking the middle partial products need not be present or that the number of digits is unrestricted (e.g., wrongly accepting `34*2=68`).\n\n### Constraints\nFor $100\\%$ of the testdata, $1\\le n \\le 9$, $a_i \\in [1,9] \\cap \\mathbb Z$, and all $a_i$ are distinct.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.3] 牛式 Prime Cryptarithm", "background": "", "description": "下面是一个乘法竖式，如果用我们给定的那 $n$ 个数字来取代 `*`，可以使式子成立的话，我们就叫这个式子为牛式。\n\n```cpp\n          ***\n    x      **\n   ----------\n         ***\n        ***\n   ----------\n        ****\n```\n\n数字只能取代 `*`，当然第一位不能为 $0$，况且给定的数字里不包括 $0$。\n\n\n注意一下在美国的学校中教的“部分乘积”，第一部分乘积是第二个数的个位和第一个数的积，第二部分乘积是第二个数的十位和第一个数的乘积。\n\n请计算出牛式的数量。\n\n", "inputFormat": "第一行一个正整数 $n$，表示可用的数集。   \n第二行 $n$ 个正整数 $a_i$，表示可用的数。\n", "outputFormat": "输出一行一个整数，表示牛式的总数。\n", "hint": "### 样例解释\n\n```\n          222\n    x      22\n   ----------\n         444\n        444\n   ----------\n        4884\n```\n\n不需要别的数，严格符合上图的数位情况，可以证明没有其他情况。\n\n\n\n不加入样例解释：做题人如果理解错题意会进入误区\n\n比如不用填中间的数，位数没有要求 `34*2=68` 符合要求等误区。\n\n### 数据规模  \n对于 $100\\%$ 的数据，$1\\le n \\le 9$，$a_i \\in [1,9] \\cap \\mathbb Z$ 且 $a_i$ 不重复。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.4\n", "locale": "zh-CN"}}}
{"pid": "P1212", "type": "P", "difficulty": 4, "samples": [["1 2\n2 3\n3 4\n4 5\n", "40\n4 10\n5 8\n"]], "limits": {"time": [952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952, 952], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO"], "title": "[USACO1.4] 铺放矩形块 Packing Rectangles", "background": "", "description": "给定 $4$ 个矩形块，找出一个最小的封闭矩形将这 $4$ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)\n\n$4$ 个矩形块中任一个矩形的边都与封闭矩形的边相平行，上图显示出了铺放 $4$ 个矩形块的 $6$ 种方案。  \n\n这 $6$ 种方案是唯一可能的基本铺放方案。因为其它方案能由基本方案通过旋转和镜像反射得到。\n\n可能存在满足条件且有着同样面积的各种不同的封闭矩形，你应该输出所有这些封闭矩形的边长。\n\n", "inputFormat": "共有 $4$ 行，每行两个正整数，表示每个矩形的边长。\n", "outputFormat": "总行数为解的总数加一。  \n\n第一行是一个整数，代表封闭矩形的最小面积。  \n接下来的每一行都表示一个解，由 $p,q\\space (p \\leqslant q)$ 来表示。这些行必须根据 $p$ 的大小按升序排列，且所有行都应是不同的。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，输入的所有数在 $[1,50]$ 内。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.4\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.4] Packing Rectangles", "background": "", "description": "Given $4$ rectangles, find a smallest enclosing rectangle that can contain all $4$ rectangles without overlap. By “smallest” we mean the area is minimal.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)\n\nFor any of the $4$ rectangles, its sides must be parallel to the sides of the enclosing rectangle. The figure above shows $6$ ways to pack the $4$ rectangles.\n\nThese $6$ layouts are the only possible basic layouts. Any other layout can be obtained from a basic one by rotation or mirror reflection.\n\nThere may be multiple enclosing rectangles that satisfy the conditions and have the same area; you should output the side lengths of all such enclosing rectangles.", "inputFormat": "There are $4$ lines, each containing two positive integers, representing the side lengths of each rectangle.", "outputFormat": "The total number of lines equals the number of solutions plus one.\n\nThe first line is an integer, representing the minimal area of the enclosing rectangle.  \nEach of the following lines describes one solution, represented by $p,q\\space (p \\leqslant q)$. These lines must be sorted in ascending order by $p$, and all lines must be distinct.", "hint": "Constraints  \nFor $100\\%$ of the testdata, all input numbers are in [1, 50].\n\nProblem translation from NOCOW.\n\nUSACO Training Section 1.4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.4] 铺放矩形块 Packing Rectangles", "background": "", "description": "给定 $4$ 个矩形块，找出一个最小的封闭矩形将这 $4$ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)\n\n$4$ 个矩形块中任一个矩形的边都与封闭矩形的边相平行，上图显示出了铺放 $4$ 个矩形块的 $6$ 种方案。  \n\n这 $6$ 种方案是唯一可能的基本铺放方案。因为其它方案能由基本方案通过旋转和镜像反射得到。\n\n可能存在满足条件且有着同样面积的各种不同的封闭矩形，你应该输出所有这些封闭矩形的边长。\n\n", "inputFormat": "共有 $4$ 行，每行两个正整数，表示每个矩形的边长。\n", "outputFormat": "总行数为解的总数加一。  \n\n第一行是一个整数，代表封闭矩形的最小面积。  \n接下来的每一行都表示一个解，由 $p,q\\space (p \\leqslant q)$ 来表示。这些行必须根据 $p$ 的大小按升序排列，且所有行都应是不同的。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，输入的所有数在 $[1,50]$ 内。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.4\n", "locale": "zh-CN"}}}
{"pid": "P1213", "type": "P", "difficulty": 4, "samples": [["9 9 12\n6 6 6\n6 3 6 \n", "4 5 8 9\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO", "IOI", "枚举", "剪枝"], "title": "[IOI 1994 / USACO1.4] 时钟 The Clocks", "background": null, "description": "考虑将如此安排在一个 $3 \\times 3$ 行列中的九个时钟:\n\n```plain\n|-------|   |-------|   |-------|\n|       |   |       |   |   |   |\n|---o   |   |---o   |   |   o   |\n|       |   |       |   |       |\n|-------|   |-------|   |-------|\n    A           B           C\n\n|-------|   |-------|   |-------|\n|       |   |       |   |       |\n|   o   |   |   o   |   |   o   |\n|   |   |   |   |   |   |   |   |\n|-------|   |-------|   |-------|\n    D           E           F\n\n|-------|   |-------|   |-------|\n|       |   |       |   |       |\n|   o   |   |   o---|   |   o   |\n|   |   |   |       |   |   |   |\n|-------|   |-------|   |-------|\n    G           H           I\n```\n\n目标要找一个最小的移动顺序将所有的指针指向 $12$ 点。下面的表格列出了 $9$ 种不同的旋转指针的方法，每一种方法都叫一次移动，选择 $1 \\sim 9$ 号移动方法，将会使在表格中对应的时钟的指针顺时针旋转 \n $90$ 度。\n\n\n|移动方法  | 受影响的时钟 |\n| :----------: | :----------: |\n| 1 | ABDE |\n| 2 | ABC |\n| 3 | BCEF |\n| 4 | ADG |\n| 5 | BDEFH |\n| 6 | CFI |\n| 7 | DEGH |\n| 8 | GHI |\n| 9 | EFHI |\n\n例如：\n\n```plain\n9 9 12       9 12 12        9 12 12        12 12 12        12 12 12\n6 6 6   5 -> 9  9  9   8 -> 9  9  9   4 -> 12  9  9   9 -> 12 12 12\n6 3 6        6  6  6        9  9  9        12  9  9        12 12 12\n```\n\n**但这可能不是正确的方法，请看下文。**", "inputFormat": "输入三行，每行三个正整数，表示一个时钟的初始时间（样例中数字的含义和上面 d 的例子一样）。", "outputFormat": "单独的一行包括一个用空格分开的将所有指针指向 $12$ 点的最短移动顺序的列表。\n\n如果有多种方案，输出字典序最小的方案。（例如 `5 2 4 6` 的字典序小于 `9 3 1 1`）。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 1.4", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 1994 / USACO1.4] The Clocks", "background": "", "description": "Consider nine clocks arranged in a $3 \\times 3$ grid:\n\n```plain\n|-------|   |-------|   |-------|\n|       |   |       |   |   |   |\n|---o   |   |---o   |   |   o   |\n|       |   |       |   |       |\n|-------|   |-------|   |-------|\n    A           B           C\n\n|-------|   |-------|   |-------|\n|       |   |       |   |       |\n|   o   |   |   o   |   |   o   |\n|   |   |   |   |   |   |   |   |\n|-------|   |-------|   |-------|\n    D           E           F\n\n|-------|   |-------|   |-------|\n|       |   |       |   |       |\n|   o   |   |   o---|   |   o   |\n|   |   |   |       |   |   |   |\n|-------|   |-------|   |-------|\n    G           H           I\n```\n\nThe goal is to find a shortest sequence of moves that sets all hands to $12$ o'clock. The table below lists $9$ different methods of rotating hands; each method is called a move. Applying moves $1 \\sim 9$ rotates the hands of the indicated clocks by $90$ degrees clockwise.\n\n| Move | Affected clocks |\n| :--: | :-------------: |\n| 1 | ABDE |\n| 2 | ABC |\n| 3 | BCEF |\n| 4 | ADG |\n| 5 | BDEFH |\n| 6 | CFI |\n| 7 | DEGH |\n| 8 | GHI |\n| 9 | EFHI |\n\nFor example:\n\n```plain\n9 9 12       9 12 12        9 12 12        12 12 12        12 12 12\n6 6 6   5 -> 9  9  9   8 -> 9  9  9   4 -> 12  9  9   9 -> 12 12 12\n6 3 6        6  6  6        9  9  9        12  9  9        12 12 12\n```\n\n**But this might not be the correct method; see below.**", "inputFormat": "Three lines, each containing three positive integers, giving the initial time of each clock (the meaning of the numbers is the same as in the example above).", "outputFormat": "A single line containing the shortest sequence of moves that sets all hands to $12$ o'clock, listed in order and separated by single spaces.\n\nIf there are multiple solutions, output the lexicographically smallest one. (For example, `5 2 4 6` is lexicographically smaller than `9 3 1 1`.)", "hint": "Problem translation from NOCOW.\n\nUSACO Training Section 1.4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 1994 / USACO1.4] 时钟 The Clocks", "background": null, "description": "考虑将如此安排在一个 $3 \\times 3$ 行列中的九个时钟:\n\n```plain\n|-------|   |-------|   |-------|\n|       |   |       |   |   |   |\n|---o   |   |---o   |   |   o   |\n|       |   |       |   |       |\n|-------|   |-------|   |-------|\n    A           B           C\n\n|-------|   |-------|   |-------|\n|       |   |       |   |       |\n|   o   |   |   o   |   |   o   |\n|   |   |   |   |   |   |   |   |\n|-------|   |-------|   |-------|\n    D           E           F\n\n|-------|   |-------|   |-------|\n|       |   |       |   |       |\n|   o   |   |   o---|   |   o   |\n|   |   |   |       |   |   |   |\n|-------|   |-------|   |-------|\n    G           H           I\n```\n\n目标要找一个最小的移动顺序将所有的指针指向 $12$ 点。下面的表格列出了 $9$ 种不同的旋转指针的方法，每一种方法都叫一次移动，选择 $1 \\sim 9$ 号移动方法，将会使在表格中对应的时钟的指针顺时针旋转 \n $90$ 度。\n\n\n|移动方法  | 受影响的时钟 |\n| :----------: | :----------: |\n| 1 | ABDE |\n| 2 | ABC |\n| 3 | BCEF |\n| 4 | ADG |\n| 5 | BDEFH |\n| 6 | CFI |\n| 7 | DEGH |\n| 8 | GHI |\n| 9 | EFHI |\n\n例如：\n\n```plain\n9 9 12       9 12 12        9 12 12        12 12 12        12 12 12\n6 6 6   5 -> 9  9  9   8 -> 9  9  9   4 -> 12  9  9   9 -> 12 12 12\n6 3 6        6  6  6        9  9  9        12  9  9        12 12 12\n```\n\n**但这可能不是正确的方法，请看下文。**", "inputFormat": "输入三行，每行三个正整数，表示一个时钟的初始时间（样例中数字的含义和上面 d 的例子一样）。", "outputFormat": "单独的一行包括一个用空格分开的将所有指针指向 $12$ 点的最短移动顺序的列表。\n\n如果有多种方案，输出字典序最小的方案。（例如 `5 2 4 6` 的字典序小于 `9 3 1 1`）。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 1.4", "locale": "zh-CN"}}}
{"pid": "P1214", "type": "P", "difficulty": 4, "samples": [["5\n7\n", "1 4\n37 4\n2 8\n29 8\n1 12\n5 12\n13 12\n17 12\n5 20\n2 24\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "USACO"], "title": "[USACO1.4] 等差数列 Arithmetic Progressions", "background": "", "description": "一个等差数列是一个能表示成 $a, a+b, a+2b, \\dots ,a+nb\\space (n \\in \\mathbb N)$ 的数列。\n\n在这个问题中 $a$ 是一个非负的整数，$b$ 是正整数。  \n写一个程序来找出在双平方数集合：  \n$$\\{ x | x = p^2 + q^2 \\wedge p,q \\in \\mathbb N \\cap [0,m]\\}$$\n中长度为 $n$ 的等差数列。\n\n", "inputFormat": "第一行一个正整数 $n$，表示要找的数列长度。  \n第二行一个非负整数 $m$，表示 $p,q$ 的上界。", "outputFormat": "如果没有找到数列，输出 `NONE`。\n\n如果找到了，输出一行或多行，每行由二个整数组成：$a,b$。\n\n这些行应该以 $b$ 为第一关键字，$a$ 为第二关键字升序排序。\n\n所求的等差数列将不会多于10,000个。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$3 \\le n \\le 25$，$0 \\le m \\le 250$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.4\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.4] Arithmetic Progressions", "background": "", "description": "An arithmetic progression is a sequence that can be written as $a, a+b, a+2b, \\dots ,a+nb\\space (n \\in \\mathbb N)$.\n\nIn this problem, $a$ is a non-negative integer and $b$ is a positive integer.\nWrite a program to find arithmetic progressions of length $n$ within the set of bisquares:\n$$\\{ x | x = p^2 + q^2 \\wedge p,q \\in \\mathbb N \\cap [0,m]\\}$$", "inputFormat": "The first line contains a positive integer $n$, the required length of the progression.\nThe second line contains a non-negative integer $m$, the upper bound for $p, q$.", "outputFormat": "If no progression is found, output `NONE`.\n\nIf found, output one or more lines, each containing two integers: $a, b$.\n\nThese lines should be sorted in ascending order by $b$ as the primary key and by $a$ as the secondary key.\n\nThere will be no more than 10,000 such arithmetic progressions.", "hint": "Constraints\nFor 100% of the testdata, $3 \\le n \\le 25$, $0 \\le m \\le 250$.\n\nProblem translation from NOCOW.\n\nUSACO Training Section 1.4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.4] 等差数列 Arithmetic Progressions", "background": "", "description": "一个等差数列是一个能表示成 $a, a+b, a+2b, \\dots ,a+nb\\space (n \\in \\mathbb N)$ 的数列。\n\n在这个问题中 $a$ 是一个非负的整数，$b$ 是正整数。  \n写一个程序来找出在双平方数集合：  \n$$\\{ x | x = p^2 + q^2 \\wedge p,q \\in \\mathbb N \\cap [0,m]\\}$$\n中长度为 $n$ 的等差数列。\n\n", "inputFormat": "第一行一个正整数 $n$，表示要找的数列长度。  \n第二行一个非负整数 $m$，表示 $p,q$ 的上界。", "outputFormat": "如果没有找到数列，输出 `NONE`。\n\n如果找到了，输出一行或多行，每行由二个整数组成：$a,b$。\n\n这些行应该以 $b$ 为第一关键字，$a$ 为第二关键字升序排序。\n\n所求的等差数列将不会多于10,000个。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$3 \\le n \\le 25$，$0 \\le m \\le 250$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.4\n", "locale": "zh-CN"}}}
{"pid": "P1215", "type": "P", "difficulty": 3, "samples": [["8 9 10\n", "1 2 8 9 10\n"], ["2 5 10", "5 6 7 8 9 10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO"], "title": "[USACO1.4] 母亲的牛奶 Mother's Milk", "background": "", "description": "农民约翰有三个容量分别是 $a,b,c$ 升的桶。  \n\n最初，$a,b$ 桶都是空的，而 $c$ 桶是装满牛奶的。有时，农民把牛奶从一个桶倒到另一个桶中，直到被灌桶装满或原桶空了。  \n\n当然每一次灌注都是完全的。由于节约，牛奶不会有丢失。\n\n写一个程序去帮助农民找出当 $a$ 桶是空的时候，$c$ 桶中牛奶所剩量的所有可能性。\n", "inputFormat": "单独的一行包括三个整数 $a,b,c$。\n", "outputFormat": "只有一行，升序地列出当 $a$ 桶是空的时候，$c$ 桶牛奶所剩量的所有可能性。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le a,b,c \\le 20$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.4\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.4] Mother's Milk", "background": "", "description": "Farmer John has three buckets with capacities of $a, b, c$ liters.\n\nInitially, buckets $a$ and $b$ are empty, and bucket $c$ is full of milk. From time to time, the farmer pours milk from one bucket to another until either the receiving bucket is full or the source bucket is empty.\n\nEach pour is complete. No milk is lost.\n\nWrite a program to help the farmer find all possible amounts of milk remaining in bucket $c$ when bucket $a$ is empty.", "inputFormat": "A single line containing three integers $a, b, c$.", "outputFormat": "Output a single line listing, in ascending order, all possible amounts of milk in bucket $c$ when bucket $a$ is empty.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le a, b, c \\le 20$.\n\nProblem translation from NOCOW.\n\nUSACO Training Section 1.4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.4] 母亲的牛奶 Mother's Milk", "background": "", "description": "农民约翰有三个容量分别是 $a,b,c$ 升的桶。  \n\n最初，$a,b$ 桶都是空的，而 $c$ 桶是装满牛奶的。有时，农民把牛奶从一个桶倒到另一个桶中，直到被灌桶装满或原桶空了。  \n\n当然每一次灌注都是完全的。由于节约，牛奶不会有丢失。\n\n写一个程序去帮助农民找出当 $a$ 桶是空的时候，$c$ 桶中牛奶所剩量的所有可能性。\n", "inputFormat": "单独的一行包括三个整数 $a,b,c$。\n", "outputFormat": "只有一行，升序地列出当 $a$ 桶是空的时候，$c$ 桶牛奶所剩量的所有可能性。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le a,b,c \\le 20$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.4\n", "locale": "zh-CN"}}}
{"pid": "P1216", "type": "P", "difficulty": 2, "samples": [["5\n7\n3 8\n8 1 0\n2 7 4 4\n4 5 2 6 5 \n", "30\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "USACO", "IOI"], "title": "[IOI 1994 / USACO1.5] 数字三角形 Number Triangles", "background": null, "description": "观察下面的数字金字塔。\n\n\n写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/95pzs0ne.png)\n\n在上面的样例中，从 $7 \\to 3 \\to 8 \\to 7 \\to 5$ 的路径产生了最大权值。", "inputFormat": "第一个行一个正整数 $r$，表示行的数目。\n\n后面每行为这个数字金字塔特定行包含的整数。", "outputFormat": "单独的一行，包含那个可能得到的最大的和。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le r\\le 1000$，所有输入在 $[0,100]$ 范围内。\n\n题目翻译来自 NOCOW。\n\nIOI1994 Day1T1 / USACO Training Section 1.5。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 1994 / USACO1.5] Number Triangles", "background": "", "description": "Look at the number pyramid below.\n\nWrite a program to find a path from the top to any position on the bottom that yields the maximum possible sum of the numbers along the path. At each step, you may move to the left-down or right-down adjacent position.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/95pzs0ne.png)\n\nIn the sample above, the path $7 \\to 3 \\to 8 \\to 7 \\to 5$ produces the maximum sum.", "inputFormat": "The first line contains a single integer $r$, the number of rows.\n\nEach of the next $r$ lines describes one row of the number triangle: for each $i$ from $1$ to $r$, the $i$-th line contains $i$ integers.", "outputFormat": "Output a single line containing the maximum possible sum.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le r \\le 1000$, and all input integers are in the range $[0, 100]$.\n\nProblem translation from NOCOW.  \nIOI 1994 Day 1 T1 / USACO Training Section 1.5.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 1994 / USACO1.5] 数字三角形 Number Triangles", "background": null, "description": "观察下面的数字金字塔。\n\n\n写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/95pzs0ne.png)\n\n在上面的样例中，从 $7 \\to 3 \\to 8 \\to 7 \\to 5$ 的路径产生了最大权值。", "inputFormat": "第一个行一个正整数 $r$，表示行的数目。\n\n后面每行为这个数字金字塔特定行包含的整数。", "outputFormat": "单独的一行，包含那个可能得到的最大的和。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le r\\le 1000$，所有输入在 $[0,100]$ 范围内。\n\n题目翻译来自 NOCOW。\n\nIOI1994 Day1T1 / USACO Training Section 1.5。", "locale": "zh-CN"}}}
{"pid": "P1217", "type": "P", "difficulty": 2, "samples": [["5 500\n", "5\n7\n11\n101\n131\n151\n181\n191\n313\n353\n373\n383\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["USACO", "枚举", "素数判断,质数,筛法"], "title": "[USACO1.5] 回文质数 Prime Palindromes", "background": "", "description": "因为 $151$ 既是一个质数又是一个回文数（从左到右和从右到左是看一样的），所以 $151$ 是回文质数。\n\n写一个程序来找出范围 $[a,b] (5 \\le a < b \\le 100,000,000)$（一亿）间的所有回文质数。", "inputFormat": "第一行输入两个正整数 $a$ 和 $b$。", "outputFormat": "输出一个回文质数的列表，一行一个。\n", "hint": "Hint 1: Generate the palindromes and see if they are prime.\n\n提示 1: 找出所有的回文数再判断它们是不是质数（素数）.\n\n\nHint 2: Generate palindromes by combining digits properly. You might need more than one of the loops like below.\n\n提示 2: 要产生正确的回文数，你可能需要几个像下面这样的循环。\n\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.5\n\n\n产生长度为 $5$ 的回文数：\n\n```cpp\nfor (d1 = 1; d1 <= 9; d1+=2) {    // 只有奇数才会是素数\n     for (d2 = 0; d2 <= 9; d2++) {\n         for (d3 = 0; d3 <= 9; d3++) {\n           palindrome = 10000*d1 + 1000*d2 +100*d3 + 10*d2 + d1;//(处理回文数...)\n         }\n     }\n }\n\n```", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.5] Prime Palindromes", "background": "", "description": "Since $151$ is both a prime and a palindrome (it reads the same from left to right and from right to left), $151$ is a palindromic prime.\n\nWrite a program to find all palindromic primes in the range $[a, b]$ with $5 \\le a < b \\le 100,000,000$ (one hundred million).", "inputFormat": "The first line contains two positive integers $a$ and $b$.", "outputFormat": "Output a list of palindromic primes, one per line.", "hint": "Hint 1: Generate palindromes and then check whether they are prime (also called “primes” or “sùshù” in pinyin).\n\nHint 2: Generate palindromes by combining digits properly. You might need several loops like the one below.\n\nProblem translation from NOCOW.\n\nUSACO Training Section 1.5.\n\nGenerating palindromes of length $5$:\n\n```cpp\nfor (d1 = 1; d1 <= 9; d1+=2) {    // 只有奇数才会是素数\n     for (d2 = 0; d2 <= 9; d2++) {\n         for (d3 = 0; d3 <= 9; d3++) {\n           palindrome = 10000*d1 + 1000*d2 +100*d3 + 10*d2 + d1;//(处理回文数...)\n         }\n     }\n }\n\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.5] 回文质数 Prime Palindromes", "background": "", "description": "因为 $151$ 既是一个质数又是一个回文数（从左到右和从右到左是看一样的），所以 $151$ 是回文质数。\n\n写一个程序来找出范围 $[a,b] (5 \\le a < b \\le 100,000,000)$（一亿）间的所有回文质数。", "inputFormat": "第一行输入两个正整数 $a$ 和 $b$。", "outputFormat": "输出一个回文质数的列表，一行一个。\n", "hint": "Hint 1: Generate the palindromes and see if they are prime.\n\n提示 1: 找出所有的回文数再判断它们是不是质数（素数）.\n\n\nHint 2: Generate palindromes by combining digits properly. You might need more than one of the loops like below.\n\n提示 2: 要产生正确的回文数，你可能需要几个像下面这样的循环。\n\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.5\n\n\n产生长度为 $5$ 的回文数：\n\n```cpp\nfor (d1 = 1; d1 <= 9; d1+=2) {    // 只有奇数才会是素数\n     for (d2 = 0; d2 <= 9; d2++) {\n         for (d3 = 0; d3 <= 9; d3++) {\n           palindrome = 10000*d1 + 1000*d2 +100*d3 + 10*d2 + d1;//(处理回文数...)\n         }\n     }\n }\n\n```", "locale": "zh-CN"}}}
{"pid": "P1218", "type": "P", "difficulty": 2, "samples": [["4\n", "2333\n2339\n2393\n2399\n2939\n3119\n3137\n3733\n3739\n3793\n3797\n5939\n7193\n7331\n7333\n7393\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "递推", "USACO", "素数判断,质数,筛法"], "title": "[USACO1.5] 特殊的质数肋骨 Superprime Rib", "background": null, "description": "农民约翰的母牛总是产生最好的肋骨。你能通过农民约翰和美国农业部标记在每根肋骨上的数字认出它们。 \n\n农民约翰确定他卖给买方的是真正的质数肋骨，是因为从右边开始依次取走肋骨，每次还剩下的肋骨上的数字都组成一个质数。  \n\n举例来说：$7\\ 3\\ 3\\ 1$ 全部肋骨上的数字 $7331$ 是质数；三根肋骨 $733$ 是质数；二根肋骨 $73$ 是质数；当然,最后一根肋骨 $7$ 也是质数。$7331$ 被叫做长度 $4$ 的特殊质数。  \n\n写一个程序对给定的肋骨的数目 $n$，求出所有的特殊质数。$1$ 不是质数。", "inputFormat": "一行一个正整数 $n$。", "outputFormat": "按顺序输出长度为 $n$ 的特殊质数,每行一个。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 8$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.5", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.5] Superprime Rib", "background": "", "description": "Farmer John’s cows always produce the best ribs. You can recognize them by the numbers stamped on each rib by Farmer John and the USDA.\n\nFarmer John is sure he sells genuine superprime ribs because, starting from the right and removing one rib at a time, the digits on the ribs that remain always form a prime number.\n\nFor example: for $7\\ 3\\ 3\\ 1$, the digits of all ribs $7331$ form a prime; with three ribs $733$ it is still prime; with two ribs $73$ it is prime; and, of course, the last rib $7$ is also prime. $7331$ is called a superprime of length $4$.\n\nWrite a program that, given the number of ribs $n$, finds all superprimes of length $n$. $1$ is not a prime.", "inputFormat": "A single line containing a positive integer $n$.", "outputFormat": "Output, in increasing order, all superprimes of length $n$, one per line.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n \\le 8$.\n\nProblem translation from NOCOW.  \nUSACO Training Section 1.5.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.5] 特殊的质数肋骨 Superprime Rib", "background": null, "description": "农民约翰的母牛总是产生最好的肋骨。你能通过农民约翰和美国农业部标记在每根肋骨上的数字认出它们。 \n\n农民约翰确定他卖给买方的是真正的质数肋骨，是因为从右边开始依次取走肋骨，每次还剩下的肋骨上的数字都组成一个质数。  \n\n举例来说：$7\\ 3\\ 3\\ 1$ 全部肋骨上的数字 $7331$ 是质数；三根肋骨 $733$ 是质数；二根肋骨 $73$ 是质数；当然,最后一根肋骨 $7$ 也是质数。$7331$ 被叫做长度 $4$ 的特殊质数。  \n\n写一个程序对给定的肋骨的数目 $n$，求出所有的特殊质数。$1$ 不是质数。", "inputFormat": "一行一个正整数 $n$。", "outputFormat": "按顺序输出长度为 $n$ 的特殊质数,每行一个。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 8$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.5", "locale": "zh-CN"}}}
{"pid": "P1219", "type": "P", "difficulty": 3, "samples": [["6\n", "2 4 6 1 3 5\n3 6 2 5 1 4\n4 1 5 2 6 3\n4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO", "深度优先搜索 DFS"], "title": "[USACO1.5] 八皇后 Checker Challenge", "background": "", "description": "一个如下的 $6 \\times 6$ 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3h71x0yf.png)\n\n上面的布局可以用序列 $2\\ 4\\ 6\\ 1\\ 3\\ 5$ 来描述，第 $i$ 个数字表示在第 $i$ 行的相应位置有一个棋子，如下：\n\n行号 $1\\ 2\\ 3\\ 4\\ 5\\ 6$\n\n列号 $2\\ 4\\ 6\\ 1\\ 3\\ 5$\n\n这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。  \n并把它们以上面的序列方法输出，解按字典顺序排列。  \n请输出前 $3$ 个解。最后一行是解的总个数。\n\n", "inputFormat": "一行一个正整数 $n$，表示棋盘是 $n \\times n$ 大小的。\n\n", "outputFormat": "前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$6 \\le n \\le 13$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.5\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.5] Eight Queens Checker Challenge", "background": "", "description": "On a $6 \\times 6$ checkerboard, six pieces are placed so that there is exactly one in each row and each column, and at most one on each diagonal (including all lines parallel to the two main diagonals).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3h71x0yf.png)\n\nThe layout above can be described by the sequence $2\\ 4\\ 6\\ 1\\ 3\\ 5$, where the $i$-th number indicates that there is a piece in row $i$ at the corresponding position, as follows:\n\nRow numbers $1\\ 2\\ 3\\ 4\\ 5\\ 6$\n\nColumn numbers $2\\ 4\\ 6\\ 1\\ 3\\ 5$\n\nThis is just one solution. Write a program to find all valid placements of the pieces. Output them using the sequence representation above, in lexicographical order. Output the first $3$ solutions. The last line is the total number of solutions.", "inputFormat": "One line with a positive integer $n$, indicating the board is of size $n \\times n$.", "outputFormat": "The first three lines are the first three solutions; within each solution, separate the numbers with a single space. The fourth line contains a single number, which is the total number of solutions.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $6 \\le n \\le 13$.\n\nProblem translation is from NOCOW.  \nUSACO Training Section 1.5.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.5] 八皇后 Checker Challenge", "background": "", "description": "一个如下的 $6 \\times 6$ 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3h71x0yf.png)\n\n上面的布局可以用序列 $2\\ 4\\ 6\\ 1\\ 3\\ 5$ 来描述，第 $i$ 个数字表示在第 $i$ 行的相应位置有一个棋子，如下：\n\n行号 $1\\ 2\\ 3\\ 4\\ 5\\ 6$\n\n列号 $2\\ 4\\ 6\\ 1\\ 3\\ 5$\n\n这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。  \n并把它们以上面的序列方法输出，解按字典顺序排列。  \n请输出前 $3$ 个解。最后一行是解的总个数。\n\n", "inputFormat": "一行一个正整数 $n$，表示棋盘是 $n \\times n$ 大小的。\n\n", "outputFormat": "前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$6 \\le n \\le 13$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.5\n", "locale": "zh-CN"}}}
{"pid": "P1220", "type": "P", "difficulty": 4, "samples": [["5 3\n2 10\n3 20\n5 20\n6 30\n8 10", "270  "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "搜索", "区间 DP", "前缀和"], "title": "关路灯", "background": "", "description": "某一村庄在一条路线上安装了 $n$ 盏路灯，每盏灯的功率有大有小（即同一段时间内消耗的电量有多有少）。老张就住在这条路中间某一路灯旁，他有一项工作就是每天早上天亮时一盏一盏地关掉这些路灯。\n\n为了给村里节省电费，老张记录下了每盏路灯的位置和功率，他每次关灯时也都是尽快地去关，但是老张不知道怎样去关灯才能够最节省电。他每天都是在天亮时首先关掉自己所处位置的路灯，然后可以向左也可以向右去关灯。开始他以为先算一下左边路灯的总功率再算一下右边路灯的总功率，然后选择先关掉功率大的一边，再回过头来关掉另一边的路灯，而事实并非如此，因为在关的过程中适当地调头有可能会更省一些。\n\n现在已知老张走的速度为 $1m/s$，每个路灯的位置（是一个整数，即距路线起点的距离，单位：$m$）、功率（$W$），老张关灯所用的时间很短而可以忽略不计。\n\n请你为老张编一程序来安排关灯的顺序，使从老张开始关灯时刻算起所有灯消耗电最少（灯关掉后便不再消耗电了）。", "inputFormat": "第一行是两个数字 $n$（表示路灯的总数）和 $c$（老张所处位置的路灯号）；\n\n接下来 $n$ 行，每行两个数据，表示第 $1$ 盏到第 $n$ 盏路灯的位置和功率。数据保证路灯位置单调递增。", "outputFormat": "一个数据，即最少的功耗（单位：$J$，$1J=1W\\times s$）。", "hint": "### 样例解释\n\n此时关灯顺序为 `3 4 2 1 5`。\n\n### 数据范围\n\n$1\\le n\\le50$，$1\\le c\\le n$，$1\\le W_i \\le 100$，$1 \\leq \\text{路灯位置} \\leq 100$", "locale": "zh-CN", "translations": {"en": {"title": "Turning Off Streetlights", "background": "", "description": "A village installed $n$ streetlights along a road. Each light has a different power rating (that is, they consume different amounts of electricity over the same period). Old Zhang lives next to one of the streetlights somewhere in the middle of this road. His job is to turn off these streetlights one by one every morning at daybreak.\n\nTo save electricity for the village, Old Zhang recorded each streetlight’s position and power. Whenever he turns off the lights, he always walks as fast as possible. However, he does not know the order that minimizes the total electricity consumption. Every day at daybreak, he first turns off the streetlight at his own location, then he may go left or right to turn off other lights. At first, he thought to first sum the total power on the left and on the right, choose the side with the larger total power to turn off first, then go back to turn off the other side. In fact, this is not always optimal, because turning back at suitable moments during the process may save more.\n\nYou are given that Old Zhang’s walking speed is $1m/s$, and each streetlight’s position (an integer, the distance from the starting point of the route, in $m$) and power ($W$). The time he spends switching off a light is very short and can be ignored.\n\nPlease write a program to arrange the order of turning off the lights so that, measured from the moment Old Zhang starts, the total energy consumed by all lights is minimized (after a light is turned off, it no longer consumes power).", "inputFormat": "The first line contains two numbers $n$ (the total number of streetlights) and $c$ (the index of the streetlight where Old Zhang is located).\n\nThe next $n$ lines each contain two values, giving the position and power of the $1$-st through $n$-th streetlight. The positions are guaranteed to be strictly increasing.", "outputFormat": "Output one number: the minimal energy consumption (unit: $J$, $1J=1W\\times s$).", "hint": "### Sample Explanation\n\nIn this case, the turning-off order is `3 4 2 1 5`.\n\n### Constraints\n\n$1\\le n\\le 50$，$1\\le c\\le n$，$1\\le W_i \\le 100$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "关路灯", "background": "", "description": "某一村庄在一条路线上安装了 $n$ 盏路灯，每盏灯的功率有大有小（即同一段时间内消耗的电量有多有少）。老张就住在这条路中间某一路灯旁，他有一项工作就是每天早上天亮时一盏一盏地关掉这些路灯。\n\n为了给村里节省电费，老张记录下了每盏路灯的位置和功率，他每次关灯时也都是尽快地去关，但是老张不知道怎样去关灯才能够最节省电。他每天都是在天亮时首先关掉自己所处位置的路灯，然后可以向左也可以向右去关灯。开始他以为先算一下左边路灯的总功率再算一下右边路灯的总功率，然后选择先关掉功率大的一边，再回过头来关掉另一边的路灯，而事实并非如此，因为在关的过程中适当地调头有可能会更省一些。\n\n现在已知老张走的速度为 $1m/s$，每个路灯的位置（是一个整数，即距路线起点的距离，单位：$m$）、功率（$W$），老张关灯所用的时间很短而可以忽略不计。\n\n请你为老张编一程序来安排关灯的顺序，使从老张开始关灯时刻算起所有灯消耗电最少（灯关掉后便不再消耗电了）。", "inputFormat": "第一行是两个数字 $n$（表示路灯的总数）和 $c$（老张所处位置的路灯号）；\n\n接下来 $n$ 行，每行两个数据，表示第 $1$ 盏到第 $n$ 盏路灯的位置和功率。数据保证路灯位置单调递增。", "outputFormat": "一个数据，即最少的功耗（单位：$J$，$1J=1W\\times s$）。", "hint": "### 样例解释\n\n此时关灯顺序为 `3 4 2 1 5`。\n\n### 数据范围\n\n$1\\le n\\le50$，$1\\le c\\le n$，$1\\le W_i \\le 100$，$1 \\leq \\text{路灯位置} \\leq 100$", "locale": "zh-CN"}}}
