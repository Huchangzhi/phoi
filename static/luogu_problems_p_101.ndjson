{"pid": "P3048", "type": "P", "difficulty": 5, "samples": [["7 3 \n", "10110 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "USACO", "组合数学", "位运算"], "title": "[USACO12FEB] Cow IDs S", "background": "", "description": "\nBeing a secret computer geek, Farmer John labels all of his cows with binary numbers. However, he is a bit superstitious, and only labels cows with binary numbers that have exactly K \"1\" bits $(1 \\le K \\le 10)$. The leading bit of each label is always a \"1\" bit, of course. FJ assigns labels in increasing numeric order, starting from the smallest possible valid label -- a K-bit number consisting of all \"1\" bits. Unfortunately, he loses track of his labeling and needs your help: please determine the Nth label he should assign $(1 \\le N \\le 10^7)$.", "inputFormat": "\n* Line $1$: Two space-separated integers, $N$ and $K$.", "outputFormat": "", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO12FEB] Cow IDs S", "background": "", "description": "\nBeing a secret computer geek, Farmer John labels all of his cows with binary numbers. However, he is a bit superstitious, and only labels cows with binary numbers that have exactly K \"1\" bits $(1 \\le K \\le 10)$. The leading bit of each label is always a \"1\" bit, of course. FJ assigns labels in increasing numeric order, starting from the smallest possible valid label -- a K-bit number consisting of all \"1\" bits. Unfortunately, he loses track of his labeling and needs your help: please determine the Nth label he should assign $(1 \\le N \\le 10^7)$.", "inputFormat": "\n* Line $1$: Two space-separated integers, $N$ and $K$.", "outputFormat": "", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO12FEB] Cow IDs S", "background": null, "description": "作为一个神秘的电脑极客，Farmer John 使用二进制数字给他的所有奶牛编号。但是，他有一点儿迷信，因此他只会使用包含 $K$ 个 \"1\" 的二进制数字给奶牛编号。当然，每个编号的前导位始终是 \"1\"。\n\nFJ 从最小的编号，也就是由 $K$ 个 \"1\" 组成的二进制数开始，以递增的顺序给每头奶牛分配编号。非常不幸的是，他忘记了奶牛们的编号。现在，请你帮他确定第 $N$ 个编号。", "inputFormat": "* 第 $1$ 行：两个用空格隔开的整数，$N$ 和 $K$。", "outputFormat": "* 第 $1$ 行：一个二进制数，代表第 $N$ 个二进制编码。", "hint": "对于 $100\\%$ 的数据：\n\n$1 \\le N \\le 10^7$，$1 \\le K \\le 10$。", "locale": "zh-CN"}}}
{"pid": "P3049", "type": "P", "difficulty": 4, "samples": [["4 100 200 1 \n1 4 \n2 3 \n3 2 \n4 0 \n", "210 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "USACO"], "title": "[USACO12MAR] Landscaping S", "background": "*本题与 [2016 年公开赛白金组同名题目](/problem/P2748) 在题意上一致，唯一的差别是数据范围。*", "description": "Farmer John 打算修建一座花园，他需要移动不少泥土。\n\n花园由 $N$ 个花坛组成（$1 \\leq N \\leq 100$），其中花坛 $i$ 包含 $A_i$ 单位的泥土。FJ 希望花坛 $i$ 包含 $B_i$ 单位的泥土，保证 $0 \\leq A_i,B_i \\leq 10$。\n\n为了达到这个目标，他可以做这几件事情：\n\n- 购买一单位的泥土，放在指定的花坛中，费用为 $X$。\n- 从任意一个花坛中移走一单位泥土，费用为 $Y$。\n- 从花坛 $i$ 运送一单位泥土到花坛 $j$，费用为 $Z|i-j|$。\n\n请你帮 FJ 计算移动泥土的最小开销。", "inputFormat": "第一行四个整数 $N,X,Y,Z$（$0 \\leq X,Y,Z \\leq 1000$）。\n\n接下来 $N$ 行，第 $i$ 行两个整数 $A_i,B_i$。", "outputFormat": "输出移动泥土的最小开销。", "hint": "按下面的方案，最小花费为 $210$，可以证明不存在开销更小的方案。\n\n- 移除 $4$ 号花坛的一单位泥土，花费 $200$。\n- 将 $4$ 号花坛的三单位泥土移到 $1$ 号花坛，花费 $3 \\times 3=9$。\n- 将 $3$ 号花坛的一单位泥土移到 $2$ 号花坛，花费 $1 \\times 1=1$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO12MAR] Landscaping S", "background": "*This problem has the same statement as the [problem of the same name in the 2016 Open Contest Platinum](/problem/P2748), with the only difference being the testdata constraints.*", "description": "Farmer John (FJ) plans to build a garden and needs to move quite a bit of soil.\n\nThe garden consists of $N$ flowerbeds ($1 \\leq N \\leq 100$), where flowerbed $i$ contains $A_i$ units of soil. FJ wants flowerbed $i$ to contain $B_i$ units of soil, and it is guaranteed that $0 \\leq A_i, B_i \\leq 10$.\n\nTo achieve this goal, he can do the following:\n\n- Buy one unit of soil and place it in a specified flowerbed, at a cost of $X$.\n- Remove one unit of soil from any flowerbed, at a cost of $Y$.\n- Transport one unit of soil from flowerbed $i$ to flowerbed $j$, at a cost of $Z|i-j|$.\n\nPlease help FJ compute the minimum cost to move the soil.", "inputFormat": "The first line contains four integers $N, X, Y, Z$ ($0 \\leq X, Y, Z \\leq 1000$).\n\nThe next $N$ lines each contain two integers $A_i, B_i$ for the $i$-th line.", "outputFormat": "Output the minimum cost to move the soil.", "hint": "With the following plan, the minimum cost is $210$, and you can prove that no cheaper plan exists.\n\n- Remove one unit of soil from flowerbed $4$, costing $200$.\n- Move three units of soil from flowerbed $4$ to flowerbed $1$, costing $3 \\times 3=9$.\n- Move one unit of soil from flowerbed $3$ to flowerbed $2$, costing $1 \\times 1=1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO12MAR] Landscaping S", "background": "*本题与 [2016 年公开赛白金组同名题目](/problem/P2748) 在题意上一致，唯一的差别是数据范围。*", "description": "Farmer John 打算修建一座花园，他需要移动不少泥土。\n\n花园由 $N$ 个花坛组成（$1 \\leq N \\leq 100$），其中花坛 $i$ 包含 $A_i$ 单位的泥土。FJ 希望花坛 $i$ 包含 $B_i$ 单位的泥土，保证 $0 \\leq A_i,B_i \\leq 10$。\n\n为了达到这个目标，他可以做这几件事情：\n\n- 购买一单位的泥土，放在指定的花坛中，费用为 $X$。\n- 从任意一个花坛中移走一单位泥土，费用为 $Y$。\n- 从花坛 $i$ 运送一单位泥土到花坛 $j$，费用为 $Z|i-j|$。\n\n请你帮 FJ 计算移动泥土的最小开销。", "inputFormat": "第一行四个整数 $N,X,Y,Z$（$0 \\leq X,Y,Z \\leq 1000$）。\n\n接下来 $N$ 行，第 $i$ 行两个整数 $A_i,B_i$。", "outputFormat": "输出移动泥土的最小开销。", "hint": "按下面的方案，最小花费为 $210$，可以证明不存在开销更小的方案。\n\n- 移除 $4$ 号花坛的一单位泥土，花费 $200$。\n- 将 $4$ 号花坛的三单位泥土移到 $1$ 号花坛，花费 $3 \\times 3=9$。\n- 将 $3$ 号花坛的一单位泥土移到 $2$ 号花坛，花费 $1 \\times 1=1$。", "locale": "zh-CN"}}}
{"pid": "P3050", "type": "P", "difficulty": 6, "samples": [["2 2 1 3 100 \n", "28 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "USACO"], "title": "[USACO12MAR] Large Banner G", "background": null, "description": "给定 $M,N,L,H$。求有多少对整点 $A(x_A,y_A),B(x_B,y_B)$ 满足：\n\n* $0\\leq x_A,x_B\\leq M,0\\leq y_A,y_B\\leq N$\n* 线段 $AB$ 上没有其它整点。\n* 线段的长度 $|AB|$ 满足 $L\\leq |AB|\\leq H$。\n\n答案对给定的 $P$ 取模（$P$ 不一定是质数）。", "inputFormat": "一行五个整数 $M,N,L,H,P$。", "outputFormat": "一行一个整数，表示答案对 $P$ 取模的结果。", "hint": "$1\\leq N,M\\leq 10^5,1\\leq L\\leq H\\leq 1.5\\times 10^5,1\\leq P\\leq 10^9.$", "locale": "zh-CN", "translations": {"en": {"title": null, "background": null, "description": "Bessie is returning from a long trip abroad to the Isle of Guernsey, and Farmer John wants to mount a nice \"Welcome Home\" banner for her arrival. Farmer John's field has integer dimensions $M \\times N (1 \\leq M, N \\leq 10^5)$, and he has installed a post at every possible point in the field with integer coordinates (if we assign a coordinate system to the field so that $(0,0)$ is in the lower-left corner and $(M,N)$ is in the upper-right corner). Of these $(M+1) \\times (N+1)$ points, Farmer John must pick two as the endpoints of the banner.\n\nFarmer John, being the perfectionist that he is, insists that the banner must be completely straight. This means that, for the two posts he chooses, there cannot be any other post on the line segment that the banner will form between them. Additionally, Farmer John wants the banner to have length at least $L$ and at most $H (1 \\leq  L \\leq  H \\leq  1.5\\times 10^5)$. Farmer John needs your help to figure out how many possible ways he can hang the banner. The banner is reversible, so switching the two endpoints of the banner counts as the same way to hang the banner. As this number may be very large, Farmer John simply wants to know what it is modulo $B(1\\leq B\\leq 10^9)$.\n\nConsider the example below, with $M = N=2$ :\n\n$$\n\\begin{matrix}\n*&*&*\\\\\n*&*&*\\\\\n*&*&*\\\\\n\\end{matrix}\n$$\n\nFarmer John wants the length of the banner to be between $1$ and $3$ inclusive. Any choice of posts satisfies this length requirement, but note that eight pairs cannot be picked:\n\n$(0, 0)$ and $(2, 0)$: $(1, 0)$ is on the line segment between them\n\n$(0, 1)$ and $(2, 1)$: $(1, 1)$ is on the line segment between them\n\n$(0, 2)$ and $(2, 2)$: $(1, 2)$ is on the line segment between them\n\n$(0, 0)$ and $(2, 2)$: $(1, 1)$ is on the line segment between them\n\n$(0, 0)$ and $(0, 2)$: $(0, 1)$ is on the line segment between them\n\n$(1, 0)$ and $(1, 2)$: $(1, 1)$ is on the line segment between them\n\n$(2, 0)$ and $(2, 2)$: $(2, 1)$ is on the line segment between them\n\n$(0, 2)$ and $(2, 0)$: $(1, 1)$ is on the line segment between them\n\nTherefore, there are a total of $\\binom 9 2-8=28$ possible locations.", "inputFormat": "Line 1: Five space-separated integers: $M, N, L, H\n$ and $B$.", "outputFormat": "Line 1: One integer denoting the number of possible banners (modulo $B$).", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO12MAR] Large Banner G", "background": null, "description": "给定 $M,N,L,H$。求有多少对整点 $A(x_A,y_A),B(x_B,y_B)$ 满足：\n\n* $0\\leq x_A,x_B\\leq M,0\\leq y_A,y_B\\leq N$\n* 线段 $AB$ 上没有其它整点。\n* 线段的长度 $|AB|$ 满足 $L\\leq |AB|\\leq H$。\n\n答案对给定的 $P$ 取模（$P$ 不一定是质数）。", "inputFormat": "一行五个整数 $M,N,L,H,P$。", "outputFormat": "一行一个整数，表示答案对 $P$ 取模的结果。", "hint": "$1\\leq N,M\\leq 10^5,1\\leq L\\leq H\\leq 1.5\\times 10^5,1\\leq P\\leq 10^9.$", "locale": "zh-CN"}}}
{"pid": "P3051", "type": "P", "difficulty": 5, "samples": [["4 \n7 1 \n3 4 \n9 2 \n1 13 \n", "13 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "贪心", "2012", "USACO"], "title": "[USACO12MAR] Haybale Restacking G", "background": "", "description": "Farmer John has just ordered a large number of bales of hay.  He would like to organize these into $N$ piles ($1 \\le N \\le 100{,}000$) arranged in a circle, where pile $i$ contains $B_i$ bales of hay. Unfortunately, the truck driver delivering the hay was not listening carefully when Farmer John provided this information, and only remembered to leave the hay in $N$ piles arranged in a circle. After delivery, Farmer John notes that pile $i$ contains $A_i$ bales of hay.  Of course, the $A_i$'s and the $B_i$'s have the same sum.\n\nFarmer John would like to move the bales of hay from their current configuration (described by the $A_i$'s) into his desired target configuration (described by the $B_i$'s).  It takes him $x$ units of work to move one hay bale from one pile to a pile that is $x$ steps away around the circle. Please help him compute the minimum amount of work he will need to spend.", "inputFormat": "* Line $1$: The single integer $N$.\n\n* Lines $2\\cdots1+N$: Line $i+1$ contains the two integers $A_i$ and $B_i$ ($1 \\le A_i, B_i \\le 1000$).", "outputFormat": "", "hint": "There are $4$ piles around a circle.  Initially, the piles contain $7$, $3$, $9$, and $1$ bales of hay. Farmer John would like to move them so the piles contain $1$, $4$, $2$, and $13$ bales of hay.\n\nA minimum of $13$ units of work is required (move $6$ bales from pile $1$ to pile $4$, move $1$ bale from pile $3$ to pile $2$, and move $6$ bales from pile $3$ to pile $4$).", "locale": "en", "translations": {"en": {"title": "[USACO12MAR] Haybale Restacking G", "background": "", "description": "Farmer John has just ordered a large number of bales of hay.  He would like to organize these into $N$ piles ($1 \\le N \\le 100{,}000$) arranged in a circle, where pile $i$ contains $B_i$ bales of hay. Unfortunately, the truck driver delivering the hay was not listening carefully when Farmer John provided this information, and only remembered to leave the hay in $N$ piles arranged in a circle. After delivery, Farmer John notes that pile $i$ contains $A_i$ bales of hay.  Of course, the $A_i$'s and the $B_i$'s have the same sum.\n\nFarmer John would like to move the bales of hay from their current configuration (described by the $A_i$'s) into his desired target configuration (described by the $B_i$'s).  It takes him $x$ units of work to move one hay bale from one pile to a pile that is $x$ steps away around the circle. Please help him compute the minimum amount of work he will need to spend.", "inputFormat": "* Line $1$: The single integer $N$.\n\n* Lines $2\\cdots1+N$: Line $i+1$ contains the two integers $A_i$ and $B_i$ ($1 \\le A_i, B_i \\le 1000$).", "outputFormat": "", "hint": "There are $4$ piles around a circle.  Initially, the piles contain $7$, $3$, $9$, and $1$ bales of hay. Farmer John would like to move them so the piles contain $1$, $4$, $2$, and $13$ bales of hay.\n\nA minimum of $13$ units of work is required (move $6$ bales from pile $1$ to pile $4$, move $1$ bale from pile $3$ to pile $2$, and move $6$ bales from pile $3$ to pile $4$).", "locale": "en"}, "zh-CN": {"title": "[USACO12MAR] Haybale Restacking G", "background": null, "description": "Farmer John 刚订购了大量干草捆。他希望把这些干草分成 $N$ 堆（$1 \\le N \\le 100{,}000$）围成一个圆，其中第 $i$ 堆应包含 $B_i$ 捆干草。不幸的是，运送干草的卡车司机在 John 提供这些信息时没有认真听，只记得把干草分成围成一圈的 $N$ 堆。送达后，John 发现第 $i$ 堆包含 $A_i$ 捆干草。显然，所有 $A_i$ 与所有 $B_i$ 的总和相同。\n\nFarmer John 想把当前的分法（由 $A_i$ 描述）调整为目标分法（由 $B_i$ 描述）。将一捆干草从某一堆搬到沿圆周相距 $x$ 个位置的另一堆需要 $x$ 个单位的工作量。请帮助他计算所需的最小总工作量。", "inputFormat": "第 $1$ 行：一个整数 $N$。\n\n第 $2\\cdots1+N$ 行：第 $i+1$ 行包含两个整数 $A_i$ 和 $B_i$（$1 \\le A_i, B_i \\le 1000$）。", "outputFormat": null, "hint": "圆周上共有 $4$ 堆。初始时，各堆分别包含 $7$、$3$、$9$、$1$ 捆干草。约翰希望将其调整为各堆分别包含 $1$、$4$、$2$、$13$ 捆干草。\n\n所需最小工作量为 $13$（从第 $1$ 堆移动 $6$ 捆到第 $4$ 堆，从第 $3$ 堆移动 $1$ 捆到第 $2$ 堆，从第 $3$ 堆再移动 $6$ 捆到第 $4$ 堆）。", "locale": "zh-CN"}}}
{"pid": "P3052", "type": "P", "difficulty": 2, "samples": [["4 10 \n5 \n6 \n3 \n7 \n", "3 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2012", "USACO", "深度优先搜索 DFS", "状压 DP"], "title": "[USACO12MAR] Cows in a Skyscraper G", "background": null, "description": "A little known fact about Bessie and friends is that they love stair climbing races.  A better known fact is that cows really don't like going down stairs.  So after the cows finish racing to the top of their favorite skyscraper, they had a problem.  Refusing to climb back down using the stairs, the cows are forced to use the elevator in order to get back to the ground floor.\n\nThe elevator has a maximum weight capacity of $W$ ($1 <= W <= 100,000,000$) pounds and cow $i$ weighs $C_i$ ($1 <= C_i <= W$) pounds.  Please help Bessie figure out how to get all the N ($1 <= N <= 18$) of the cows to the ground floor using the least number of elevator rides.  The sum of the weights of the cows on each elevator ride must be no larger than W.", "inputFormat": "\\* Line $1$: $N$ and $W$ separated by a space.\n\n\\* Lines $2$ ~ $N+1$: Line $i+1$ contains the integer $C_i$, giving the weight of one of the cows.", "outputFormat": "\\* A single integer, $R$, indicating the minimum number of elevator rides needed.", "hint": "There are four cows weighing 5, 6, 3, and 7 pounds.  The elevator has a maximum weight capacity of 10 pounds.\n\n\nWe can put the cow weighing 3 on the same elevator as any other cow but the other three cows are too heavy to be combined.  For the solution above, elevator ride 1 involves cow #1 and #3, elevator ride 2 involves cow #2, and elevator ride 3 involves cow #4.  Several other solutions are possible for this input.", "locale": "en", "translations": {"en": {"title": "[USACO12MAR] Cows in a Skyscraper G", "background": null, "description": "A little known fact about Bessie and friends is that they love stair climbing races.  A better known fact is that cows really don't like going down stairs.  So after the cows finish racing to the top of their favorite skyscraper, they had a problem.  Refusing to climb back down using the stairs, the cows are forced to use the elevator in order to get back to the ground floor.\n\nThe elevator has a maximum weight capacity of $W$ ($1 <= W <= 100,000,000$) pounds and cow $i$ weighs $C_i$ ($1 <= C_i <= W$) pounds.  Please help Bessie figure out how to get all the N ($1 <= N <= 18$) of the cows to the ground floor using the least number of elevator rides.  The sum of the weights of the cows on each elevator ride must be no larger than W.", "inputFormat": "\\* Line $1$: $N$ and $W$ separated by a space.\n\n\\* Lines $2$ ~ $N+1$: Line $i+1$ contains the integer $C_i$, giving the weight of one of the cows.", "outputFormat": "\\* A single integer, $R$, indicating the minimum number of elevator rides needed.", "hint": "There are four cows weighing 5, 6, 3, and 7 pounds.  The elevator has a maximum weight capacity of 10 pounds.\n\n\nWe can put the cow weighing 3 on the same elevator as any other cow but the other three cows are too heavy to be combined.  For the solution above, elevator ride 1 involves cow #1 and #3, elevator ride 2 involves cow #2, and elevator ride 3 involves cow #4.  Several other solutions are possible for this input.", "locale": "en"}, "zh-CN": {"title": "[USACO12MAR] Cows in a Skyscraper G", "background": null, "description": "一个鲜为人知的事实是，Bessie 和她的朋友们喜欢爬楼梯比赛。一个更为人知的事实是，奶牛们真的不喜欢下楼梯。因此，当奶牛们比赛到达她们最喜欢的摩天大楼的顶层后，她们遇到了一个问题。拒绝使用楼梯下楼，奶牛们被迫使用电梯返回地面层。\n\n电梯的最大载重量为 $W$ 磅 $(1 \\leq W \\leq 100,000,000)$，奶牛 $i$ 的体重为 $C_i$ 磅 $(1 \\leq C_i \\leq W)$。请帮助 Bessie 找出如何用最少的电梯次数将所有 $N$ 头奶牛 $(1 \\leq N \\leq 18)$ 送到地面层。每次电梯的总重量不能超过 $W$。", "inputFormat": "\\* 第 1 行：用空格分隔的 $N$ 和 $W$。\n\n\\* 第 2 行到第 $1+N$ 行：第 $i+1$ 行包含一个整数 $C_i$，表示一头奶牛的体重。", "outputFormat": "\\* 一个整数 $R$，表示所需的最少电梯次数。", "hint": "有四头奶牛，体重分别为 5、6、3 和 7 磅。电梯的最大载重量为 10 磅。\n\n\n我们可以将体重为 3 的奶牛与其他任何一头奶牛放在同一个电梯上，但其他三头奶牛太重，无法组合在一起。对于上述解决方案，电梯行程 1 包括奶牛 #1 和 #3，电梯行程 2 包括奶牛 #2，电梯行程 3 包括奶牛 #4。对于此输入，还有其他几种可能的解决方案。\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3053", "type": "P", "difficulty": 5, "samples": [["12 3 5 \n0 0 \n1 0 \n2 0 \n3 0 \n3 1 \n0 1 \n0 2 \n0 3 \n0 4 \n1 4 \n2 4 \n3 4 \n2 1 \n2 2 \n1 2 \n2 3 \n3 3 \n4 3 \n4 4 \n4 2 \n", "5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2012", "USACO", "枚举", "最短路"], "title": "[USACO12OPEN] Unlocking Blocks S", "background": "", "description": "A little-known fact about cows is that they love puzzles! For Bessie's birthday, Farmer John gives her an interesting mechanical puzzle for her to solve.  The puzzle consists of three solid objects, each of which is built from 1x1 unit squares glued together.  Each of these objects is a \"connected\" shape,  in the sense that you can get from one square on the object to any other square on the object by stepping north, south, east, or west, through squares on the object.\n\nAn object can be moved by repeatedly sliding it either north, south, east, or west one unit.  The goal of the puzzle is to move the objects so that they are separated -- where their bounding boxes no longer share any positive overlap with each-other.  Given the shapes and locations of the three objects, your task is to help Bessie decide what is the minimum number of individual slides required to separate the objects.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/flelqdzu.png)\n\n", "inputFormat": "\\* Line 1: Three space-separated integers: N1, N2, and N3, describing respectively the number of unit squares making up objects 1, 2, and 3.\n\n\\* Lines 2..1+N1: Each of these lines describes the (x,y) location of the south-west corner of single square that is part of object 1.  All coordinates lie in the range 0..9.\n\n\\* Lines 2+N1..1+N1+N2: Each of these lines describes the (x,y) location of the south-west corner of single square that is part of object 2.  All coordinates lie in the range 0..9.\n\n\\* Lines 2+N1+N2..1+N1+N2+N3: Each of these lines describes the (x,y) location of the south-west corner of single square that is part of object 3.  All coordinates lie in the range 0..9.\n\n\n第1行：三个整数N1,N2,N3，表示组成模块1,2,3的小正方体数目。\n\n\n第2行到第N1+1行：读入一对坐标（x，y），每对坐标表示组成模块1的一个小正方体西南角落的位置。所有坐标在0..9之间。\n\n\n第N1+2行到第N1+N2+1行：读入一对坐标（x，y），每对坐标表示组成模块2的一个小正方体西南角落的位置。所有坐标在0..9之间。\n\n\n第N1+N2+2行到第N1+N2+N3+…\n", "outputFormat": "\\* Line 1: The minimum number of moves necessary to separate the three objects, or -1 if the objects cannot be separated.\n", "hint": "Object 1 is made from 12 squares, object 2 is made from 3 squares, and object 3 is made from 5 squares.  The shapes of the objects are those in the figure above.\n\n\nIf we slide object 3 to the east by one position, then slide object 2 north by one position, then slide object 1 west by three positions, then the bounding boxes of the three objects will no longer share any overlap in common.\n\n模块1由12块小正方体制造，模块2由3块小正方体制造，模块3由5块小正方体制造。最后的图像在如上。（吃图？！）\n\n```cpp\nA：模块1方块 B：模块2方块 C：模块3方块 *：啥都木有\nA A A A C\nA * C C C\nA B B * C\nA * B A *\nA A A A *\n```\n假如我们把模块3向东移一个单位，然后把模块2向北移一个单位，然后把模块1向西移三个单位，就满足了条件。\n\n感谢 @姚起龙 提供翻译\n", "locale": "en", "translations": {"en": {"title": "[USACO12OPEN] Unlocking Blocks S", "background": "", "description": "A little-known fact about cows is that they love puzzles! For Bessie's birthday, Farmer John gives her an interesting mechanical puzzle for her to solve.  The puzzle consists of three solid objects, each of which is built from 1x1 unit squares glued together.  Each of these objects is a \"connected\" shape,  in the sense that you can get from one square on the object to any other square on the object by stepping north, south, east, or west, through squares on the object.\n\nAn object can be moved by repeatedly sliding it either north, south, east, or west one unit.  The goal of the puzzle is to move the objects so that they are separated -- where their bounding boxes no longer share any positive overlap with each-other.  Given the shapes and locations of the three objects, your task is to help Bessie decide what is the minimum number of individual slides required to separate the objects.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/flelqdzu.png)\n\n", "inputFormat": "\\* Line 1: Three space-separated integers: N1, N2, and N3, describing respectively the number of unit squares making up objects 1, 2, and 3.\n\n\\* Lines 2..1+N1: Each of these lines describes the (x,y) location of the south-west corner of single square that is part of object 1.  All coordinates lie in the range 0..9.\n\n\\* Lines 2+N1..1+N1+N2: Each of these lines describes the (x,y) location of the south-west corner of single square that is part of object 2.  All coordinates lie in the range 0..9.\n\n\\* Lines 2+N1+N2..1+N1+N2+N3: Each of these lines describes the (x,y) location of the south-west corner of single square that is part of object 3.  All coordinates lie in the range 0..9.\n\n\n第1行：三个整数N1,N2,N3，表示组成模块1,2,3的小正方体数目。\n\n\n第2行到第N1+1行：读入一对坐标（x，y），每对坐标表示组成模块1的一个小正方体西南角落的位置。所有坐标在0..9之间。\n\n\n第N1+2行到第N1+N2+1行：读入一对坐标（x，y），每对坐标表示组成模块2的一个小正方体西南角落的位置。所有坐标在0..9之间。\n\n\n第N1+N2+2行到第N1+N2+N3+…\n", "outputFormat": "\\* Line 1: The minimum number of moves necessary to separate the three objects, or -1 if the objects cannot be separated.\n", "hint": "Object 1 is made from 12 squares, object 2 is made from 3 squares, and object 3 is made from 5 squares.  The shapes of the objects are those in the figure above.\n\n\nIf we slide object 3 to the east by one position, then slide object 2 north by one position, then slide object 1 west by three positions, then the bounding boxes of the three objects will no longer share any overlap in common.\n\n模块1由12块小正方体制造，模块2由3块小正方体制造，模块3由5块小正方体制造。最后的图像在如上。（吃图？！）\n\n```cpp\nA：模块1方块 B：模块2方块 C：模块3方块 *：啥都木有\nA A A A C\nA * C C C\nA B B * C\nA * B A *\nA A A A *\n```\n假如我们把模块3向东移一个单位，然后把模块2向北移一个单位，然后把模块1向西移三个单位，就满足了条件。\n\n感谢 @姚起龙 提供翻译\n", "locale": "en"}, "zh-CN": {"title": "[USACO12OPEN] Unlocking Blocks S", "background": "", "description": "一个鲜为人知的事实是，奶牛非常喜欢解谜！为了庆祝贝西的生日，农夫约翰给了她一个有趣的机械谜题让她来解决。这个谜题由三个实心物体组成，每个物体都是由 1x1 的单位正方形粘合在一起构成的。每个物体都是一个「连通」的形状，也就是说，你可以通过在物体上的正方形向北、南、东或西移动，从物体上的一个正方形到达另一个正方形。\n\n一个物体可以通过不断地向北、南、东或西滑动一个单位来移动。谜题的目标是移动这些物体，使它们分开——即它们的边界框不再有任何正重叠。给定三个物体的形状和位置，你的任务是帮助贝西决定分开这些物体所需的最少滑动次数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/flelqdzu.png)\n\n", "inputFormat": "\\* 第 1 行：三个用空格分隔的整数 $N_1$，$N_2$ 和 $N_3$，分别表示组成物体 1、2 和 3 的单位正方形的数量。\n\n\\* 第 2 行到第 $1+N_1$ 行：每行描述一个 (x,y) 坐标，表示组成物体 1 的一个单位正方形的西南角的位置。所有坐标都在 0 到 9 的范围内。\n\n\\* 第 $2+N_1$ 行到第 $1+N_1+N_2$ 行：每行描述一个 (x,y) 坐标，表示组成物体 2 的一个单位正方形的西南角的位置。所有坐标都在 0 到 9 的范围内。\n\n\\* 第 $2+N_1+N_2$ 行到第 $1+N_1+N_2+N_3$ 行：每行描述一个 (x,y) 坐标，表示组成物体 3 的一个单位正方形的西南角的位置。所有坐标都在 0 到 9 的范围内。\n", "outputFormat": "\\* 第 1 行：分开三个物体所需的最少移动次数，或者如果物体无法分开则输出 -1。\n", "hint": "物体 1 由 12 个正方形组成，物体 2 由 3 个正方形组成，物体 3 由 5 个正方形组成。物体的形状如上图所示。\n\n如果我们将物体 3 向东滑动一个位置，然后将物体 2 向北滑动一个位置，然后将物体 1 向西滑动三个位置，那么三个物体的边界框将不再有任何重叠。\n\n物体 1 由 12 块小正方体制成，物体 2 由 3 块小正方体制成，物体 3 由 5 块小正方体制成。最后的图像如上所示。（吃图？！）\n\n```cpp\nA：物体 1 方块 B：物体 2 方块 C：物体 3 方块 *：什么都没有\nA A A A C\nA * C C C\nA B B * C\nA * B A *\nA A A A *\n```\n假如我们把物体 3 向东移一个单位，然后把物体 2 向北移一个单位，然后把物体 1 向西移三个单位，就满足了条件。\n\n感谢 @姚起龙 提供翻译\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3054", "type": "P", "difficulty": 4, "samples": [["4 2 100 \n20 \n100 \n70 \n1 \n", "4 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "USACO"], "title": "[USACO12OPEN] Running Laps S", "background": "", "description": "Bored with horse racing, Farmer John decides to investigate the feasibility of cow racing as a sport.  He sets up his N cows (1 <= N <= 100,000) to run a race of L laps around a circular track of length C.  The cows all start at the same point on the track and run at different speeds, with the race ending when the fastest cow has run the total distance of LC.\n\nFJ notices several occurrences of one cow overtaking another, and wonders how many times this sort of \"crossing event\" happens during the entire race.  More specifically, a crossing event is defined by a pair of cows (x,y) and a time t (less than or equal to the ending time of the race), where cow x crosses in front of cow y at time t.  Please help FJ count the total number of crossing events during the entire race.\n\n有n头牛要在长为c的跑道上跑l圈，每头牛有一个速度s\\_i. 某头牛跑完时，所有的牛都停下来，问此之前发生了多少次超越。\n", "inputFormat": "\\* Line 1: Three space-separated integers: N, L, and C.  (1 <= L,C <= 25,000).\n\n\\* Lines 2..1+N: Line i+1 contains the speed of cow i, an integer in the range 1..1,000,000.\n", "outputFormat": "\\* Line 1: The total number of crossing events during the entire race.\n", "hint": "There are 4 cows running 2 laps on a circular track of length 100.  The speeds of the cows are 20, 100, 70, and 1.\n\n\nThe race lasts 2 units of time, since this is the time it takes the fastest cow (cow 2) to finish.  Within that time, there are 4 crossing events: cow 2 overtakes cows 1 and 4, and cow 3 overtakes cows 1 and 4.\n", "locale": "en", "translations": {"en": {"title": "[USACO12OPEN] Running Laps S", "background": "", "description": "Bored with horse racing, Farmer John decides to investigate the feasibility of cow racing as a sport.  He sets up his N cows (1 <= N <= 100,000) to run a race of L laps around a circular track of length C.  The cows all start at the same point on the track and run at different speeds, with the race ending when the fastest cow has run the total distance of LC.\n\nFJ notices several occurrences of one cow overtaking another, and wonders how many times this sort of \"crossing event\" happens during the entire race.  More specifically, a crossing event is defined by a pair of cows (x,y) and a time t (less than or equal to the ending time of the race), where cow x crosses in front of cow y at time t.  Please help FJ count the total number of crossing events during the entire race.\n\n有n头牛要在长为c的跑道上跑l圈，每头牛有一个速度s\\_i. 某头牛跑完时，所有的牛都停下来，问此之前发生了多少次超越。\n", "inputFormat": "\\* Line 1: Three space-separated integers: N, L, and C.  (1 <= L,C <= 25,000).\n\n\\* Lines 2..1+N: Line i+1 contains the speed of cow i, an integer in the range 1..1,000,000.\n", "outputFormat": "\\* Line 1: The total number of crossing events during the entire race.\n", "hint": "There are 4 cows running 2 laps on a circular track of length 100.  The speeds of the cows are 20, 100, 70, and 1.\n\n\nThe race lasts 2 units of time, since this is the time it takes the fastest cow (cow 2) to finish.  Within that time, there are 4 crossing events: cow 2 overtakes cows 1 and 4, and cow 3 overtakes cows 1 and 4.\n", "locale": "en"}, "zh-CN": {"title": "[USACO12OPEN] Running Laps S", "background": null, "description": "农夫约翰让他的 $n$（$1 \\le n \\le 100,000$）头牛在长度为 $c$ 的跑道上进行跑 $l$ 圈的比赛，所有牛从同一起点，以不同的速度开始跑。直到当跑得最快的那一头牛跑完 $l$ 圈时，所有牛才同时停下。\n\n约翰发现在跑圈过程中发生了几次“超越事件”。其定义是：在比赛结束前某时刻，奶牛 $x$ 已经超越了奶牛 $y$ **整整一圈**，则称做一次“超越事件”。（注：**至少一圈**，超越了 $\\frac{1}{2}$ 圈，或者超越了 $\\frac{1}{4}$ 圈等等都不算。且对于同一对奶牛 $(x,y)$ 不会重复计算次数。）\n\n约翰想知道比赛过程中发生了多少次“超越事件”。\n\n（注：可能原文章表达有误或某些其他原因，各种翻译方式过来的题意都有问题，给人误导很大，这里是根据题目数据和样例解释写的正确的题意，而不是原文）", "inputFormat": "第一行：三个整数：$n,l,c$（$1 \\le l,c \\le 25,000$）。\n\n第二行到第 $n+1$ 行：每行一个整数 $v_i$，表示奶牛 $i$ 的速度（$1 \\le v_i \\le 1,000,000$）。", "outputFormat": "第一行：一个整数，表示总共发生的“超越事件”的次数。\n\n感谢@远藤沙椰 提供的翻译", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3055", "type": "P", "difficulty": 5, "samples": [["2 10 6 1 \n2 3 \n2 1 \n6 1 \n2 4 \n1 1 \n2 0 \n3 1 \n1 3 \n5 4 \n3 0 \n0 1 \n3 2 \n6 1 \n \n", "1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "USACO"], "title": "[USACO12OPEN] Tied Down G", "background": "", "description": "As we all know, Bessie the cow likes nothing more than causing mischief on the farm.  To keep her from causing too much trouble, Farmer John decides to tie Bessie down to a fence with a long rope.  When viewed from above, the fence consists of N posts (1 <= N <= 10) that are arranged along vertical line, with Bessie's position (bx, by) located to the right of this vertical line.  The rope FJ uses to tie down Bessie is described by a sequence of M line segments (3 <= M <= 10,000), where the first segment starts at Bessie's position and the last ends at Bessie's position. No fence post lies on any of these line segments.  However, line segments may cross, and multiple line segments may overlap at their endpoints.\n\nHere is an example of the scene, viewed from above:\n\n![](https://cdn.luogu.com.cn/upload/pic/41461.png)\n\nTo help Bessie escape, the rest of the cows have stolen a saw from the barn.  Please determine the minimum number of fence posts they must cut through and remove in order for Bessie to be able to pull free (meaning she can run away to the right without the rope catching on any of the fence posts). \n\nAll (x,y) coordinates in the input (fence posts, Bessie, and line segment endpoints) lie in the range 0..10,000.  All fence posts have the same x coordinate, and bx is larger than this value. \n\n牛被拴着。平面上有n个柱子，x坐标相等，且都小于牛的x坐标。牛在由m条边形成的闭合多边形组成的绳子上。问最少要锯掉几个柱子牛才能逃脱。\n", "inputFormat": "\\* Line 1: Four space-separated integers: N, M, bx, by.\n\n\\* Lines 2..1+N: Line i+1 contains the space-separated x and y\n\ncoordinates of fence post i.\n\n\\* Lines 2+N..2+N+M: Each of these M+1 lines contains, in sequence, the space-separated x and y coordinates of a point along the rope. The first and last points are always the same as Bessie's location (bx, by).\n", "outputFormat": "\\* Line 1: The minimum number of posts that need to be removed in order for Bessie to escape by running to the right.\n", "hint": "There are two posts at (2,3) and (2,1).  Bessie is at (6,1).  The rope goes from (6,1) to (2,4) to (1,1), and so on, ending finally at (6,1). The shape of the rope is the same as in the figure above.\n\n\nRemoving either post 1 or post 2 will allow Bessie to escape.\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO12OPEN] Tied Down G", "background": "", "description": "As we all know, Bessie the cow likes nothing more than causing mischief on the farm. To keep her from causing too much trouble, Farmer John ties Bessie to a fence with a long rope. Viewed from above, the fence consists of $N$ posts with $1 \\le N \\le 10$, arranged along a vertical line, with Bessie’s position $(b_x, b_y)$ located to the right of this vertical line. The rope that ties Bessie is described by a sequence of $M$ line segments with $3 \\le M \\le 10{,}000$, where the polyline starts and ends at Bessie’s position. No fence post lies on any rope segment. However, segments may cross, and multiple segments may overlap at their endpoints.\n\nHere is an example of the scene, viewed from above:\n![](https://cdn.luogu.com.cn/upload/pic/41461.png)\n\nTo help Bessie escape, the other cows have stolen a saw. Determine the minimum number of fence posts they must cut and remove so that Bessie can pull free, meaning she can run to the right without the rope catching on any fence post.\n\nAll $(x, y)$ coordinates in the input (fence posts, Bessie, and rope endpoints) lie in the range $0 \\ldots 10{,}000$. All fence posts share the same $x$ coordinate, and $b_x$ is larger than this value.", "inputFormat": "- Line 1: Four space-separated integers: $N$, $M$, $b_x$, $b_y$.\n- Lines $2 \\ldots 1+N$: Line $i+1$ contains the space-separated $x$ and $y$ coordinates of fence post $i$.\n- Lines $2+N \\ldots 2+N+M$: Each of these $M+1$ lines gives, in order, the space-separated $x$ and $y$ coordinates of a point along the rope. The first and last points are both Bessie’s location $(b_x, b_y)$.", "outputFormat": "- Line 1: The minimum number of posts that need to be removed for Bessie to escape by running to the right.", "hint": "There are two posts at (2, 3) and (2, 1). Bessie is at (6, 1). The rope goes from (6, 1) to (2, 4) to (1, 1), and so on, finally ending at (6, 1). The shape of the rope is the same as in the figure above.\n\nRemoving either post 1 or post 2 will allow Bessie to escape.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO12OPEN] Tied Down G", "background": "", "description": "As we all know, Bessie the cow likes nothing more than causing mischief on the farm.  To keep her from causing too much trouble, Farmer John decides to tie Bessie down to a fence with a long rope.  When viewed from above, the fence consists of N posts (1 <= N <= 10) that are arranged along vertical line, with Bessie's position (bx, by) located to the right of this vertical line.  The rope FJ uses to tie down Bessie is described by a sequence of M line segments (3 <= M <= 10,000), where the first segment starts at Bessie's position and the last ends at Bessie's position. No fence post lies on any of these line segments.  However, line segments may cross, and multiple line segments may overlap at their endpoints.\n\nHere is an example of the scene, viewed from above:\n\n![](https://cdn.luogu.com.cn/upload/pic/41461.png)\n\nTo help Bessie escape, the rest of the cows have stolen a saw from the barn.  Please determine the minimum number of fence posts they must cut through and remove in order for Bessie to be able to pull free (meaning she can run away to the right without the rope catching on any of the fence posts). \n\nAll (x,y) coordinates in the input (fence posts, Bessie, and line segment endpoints) lie in the range 0..10,000.  All fence posts have the same x coordinate, and bx is larger than this value. \n\n牛被拴着。平面上有n个柱子，x坐标相等，且都小于牛的x坐标。牛在由m条边形成的闭合多边形组成的绳子上。问最少要锯掉几个柱子牛才能逃脱。\n", "inputFormat": "\\* Line 1: Four space-separated integers: N, M, bx, by.\n\n\\* Lines 2..1+N: Line i+1 contains the space-separated x and y\n\ncoordinates of fence post i.\n\n\\* Lines 2+N..2+N+M: Each of these M+1 lines contains, in sequence, the space-separated x and y coordinates of a point along the rope. The first and last points are always the same as Bessie's location (bx, by).\n", "outputFormat": "\\* Line 1: The minimum number of posts that need to be removed in order for Bessie to escape by running to the right.\n", "hint": "There are two posts at (2,3) and (2,1).  Bessie is at (6,1).  The rope goes from (6,1) to (2,4) to (1,1), and so on, ending finally at (6,1). The shape of the rope is the same as in the figure above.\n\n\nRemoving either post 1 or post 2 will allow Bessie to escape.\n", "locale": "zh-CN"}}}
{"pid": "P3056", "type": "P", "difficulty": 2, "samples": [["())( \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心", "2012", "USACO", "前缀和", "栈"], "title": "[USACO12NOV] Clumsy Cows S", "background": null, "description": "奶牛 Bessie 正试图在她的新笔记本电脑上输入一个平衡的括号字符串，但由于她的蹄子很大（因此非常笨拙），她不断地输入错误的字符。 请通过计算要使该字符串变为平衡，最少需要反转多少个字符（例如，将左括号变为右括号，或反之）来帮助她。\n\n对于“括号字符串平衡”有几种定义方法。 或许最简单的定义是，字符串中的 `(` 和 `)` 总数必须相同，并且对于字符串的任何前缀，`(` 的数量必须不少于 `)` 的数量。 例如，以下字符串都是平衡的：\n\n`()`\n\n`(())`\n\n`()(()())`\n\n而以下则不平衡：\n\n`)(`\n\n`())(`\n\n`((())))`", "inputFormat": "一个只包含`(`和`)`的字符串，长度为偶数，最多 $100000$ 个字符。", "outputFormat": "一个整数，表示要将该字符串变为平衡字符串，最少需要反转的括号数量。", "hint": "### 样例解释\n\n最后一个括号必须被反转，两个中间的右括号中也必须有一个被反转。", "locale": "zh-CN", "translations": {"en": {"title": null, "background": null, "description": "Bessie the cow is trying to type a balanced string of parentheses into her new laptop, but she is sufficiently clumsy (due to her large hooves) that she keeps mis-typing characters.  Please help her by computing the minimum number of characters in the string that one must reverse (e.g., changing a left parenthesis to a right parenthesis, or vice versa) so that the string would become balanced.\n\nThere are several ways to define what it means for a string of parentheses to be \"balanced\".  Perhaps the simplest definition is that there must be the same total number of `(`s and `)`s, and for any prefix of the string, there must be at least as many `(`s as `)`s.  For example, the following strings are all balanced:\n\n`()`\n\n`(())`\n\n`()(()())`\n\nwhile these are not:\n\n`)(`\n\n`())(`\n\n`((())))`", "inputFormat": "Line 1: A string of parentheses of even length at most $100000$ characters.", "outputFormat": "Line 1: A single integer giving the minimum number of parentheses that must be toggled to convert the string into a balanced string.", "hint": "The last parenthesis must be toggled, and so must one of the two middle right parentheses.", "locale": "en"}, "zh-CN": {"title": "[USACO12NOV] Clumsy Cows S", "background": null, "description": "奶牛 Bessie 正试图在她的新笔记本电脑上输入一个平衡的括号字符串，但由于她的蹄子很大（因此非常笨拙），她不断地输入错误的字符。 请通过计算要使该字符串变为平衡，最少需要反转多少个字符（例如，将左括号变为右括号，或反之）来帮助她。\n\n对于“括号字符串平衡”有几种定义方法。 或许最简单的定义是，字符串中的 `(` 和 `)` 总数必须相同，并且对于字符串的任何前缀，`(` 的数量必须不少于 `)` 的数量。 例如，以下字符串都是平衡的：\n\n`()`\n\n`(())`\n\n`()(()())`\n\n而以下则不平衡：\n\n`)(`\n\n`())(`\n\n`((())))`", "inputFormat": "一个只包含`(`和`)`的字符串，长度为偶数，最多 $100000$ 个字符。", "outputFormat": "一个整数，表示要将该字符串变为平衡字符串，最少需要反转的括号数量。", "hint": "### 样例解释\n\n最后一个括号必须被反转，两个中间的右括号中也必须有一个被反转。", "locale": "zh-CN"}}}
{"pid": "P3057", "type": "P", "difficulty": 4, "samples": [["3 1 2 \n((( \n()( \n(() \n", "5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "USACO"], "title": "[USACO12NOV] Distant Pastures S", "background": "", "description": "Farmer John's farm is made up of an N x N grid of pastures, where each pasture contains one of two different types of grass.  To specify these two types of grass, we use the characters ( and ), so for example FJ's farm might look like the following grid:\n\n(()) \n)()( \n)((( \n))))\nWhen Bessie the cow travels around the farm, it takes her A units of time to move from a pasture to an adjacent pasture (one step north, south, east, or west) with the same grass type, or B units of time to move to an adjacent pasture with a different grass type.  Whenever Bessie travels from one pasture to a distant pasture, she always uses a sequence of steps that takes the minimum amount of time.  Please compute the greatest amount of time Bessie will ever need to take while traveling between some pair of pastures on the farm.\n\n给出一个n\\*n的括号矩阵，从一个点走到相邻的同字符点需付出A的代价，到不同字符点需付出B的代价。求所有点对之间最短路的最大值。\n", "inputFormat": "\\* Line 1: Three integers: N (1 <= N <= 30), A (0 <= A <= 1,000,000), and B (0 <= B <= 1,000,000).\n\n\\* Lines 1..N+1: Each line contains a string of parentheses of length N.  Collectively, these N lines form an N x N grid of\n\nparentheses.\n", "outputFormat": "\\* Line 1: A single integer specifying the maximum amount of time Bessie can spend traveling between a pair of pastures (given that she always follows a route that takes a minimum amount of time).\n", "hint": "It takes Bessie 5 units of time to travel between the upper-left corner and the lower-right corner of the grid.  No other pair of pastures causes her to travel for more time than this.\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO12NOV] Distant Pastures S", "background": "", "description": "Farmer John's farm is made up of an $N \\times N$ grid of pastures, where each pasture contains one of two different types of grass. To specify these two types of grass, we use the characters ( and ), so for example FJ's farm might look like the following grid:\n(())\n)()(\n)((( \n))))\nWhen Bessie the cow travels around the farm, it takes her $A$ units of time to move from a pasture to an adjacent pasture (one step north, south, east, or west) with the same grass type, or $B$ units of time to move to an adjacent pasture with a different grass type. Whenever Bessie travels from one pasture to a distant pasture, she always uses a sequence of steps that takes the minimum amount of time. Please compute the greatest amount of time Bessie will ever need to take while traveling between some pair of pastures on the farm.", "inputFormat": "- Line 1: Three integers: $N$ ($1 \\le N \\le 30$), $A$ ($0 \\le A \\le 1{,}000{,}000$), and $B$ ($0 \\le B \\le 1{,}000{,}000$).\n- Lines 2..$N+1$: Each of the next $N$ lines contains a string of parentheses of length $N$. Together, these $N$ lines form an $N \\times N$ grid of parentheses.", "outputFormat": "- Line 1: A single integer specifying the maximum amount of time Bessie can spend traveling between a pair of pastures (given that she always follows a route that takes a minimum amount of time).", "hint": "It takes Bessie 5 units of time to travel between the upper-left corner and the lower-right corner of the grid. No other pair of pastures causes her to travel for more time than this.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO12NOV] Distant Pastures S", "background": "", "description": "Farmer John's farm is made up of an N x N grid of pastures, where each pasture contains one of two different types of grass.  To specify these two types of grass, we use the characters ( and ), so for example FJ's farm might look like the following grid:\n\n(()) \n)()( \n)((( \n))))\nWhen Bessie the cow travels around the farm, it takes her A units of time to move from a pasture to an adjacent pasture (one step north, south, east, or west) with the same grass type, or B units of time to move to an adjacent pasture with a different grass type.  Whenever Bessie travels from one pasture to a distant pasture, she always uses a sequence of steps that takes the minimum amount of time.  Please compute the greatest amount of time Bessie will ever need to take while traveling between some pair of pastures on the farm.\n\n给出一个n\\*n的括号矩阵，从一个点走到相邻的同字符点需付出A的代价，到不同字符点需付出B的代价。求所有点对之间最短路的最大值。\n", "inputFormat": "\\* Line 1: Three integers: N (1 <= N <= 30), A (0 <= A <= 1,000,000), and B (0 <= B <= 1,000,000).\n\n\\* Lines 1..N+1: Each line contains a string of parentheses of length N.  Collectively, these N lines form an N x N grid of\n\nparentheses.\n", "outputFormat": "\\* Line 1: A single integer specifying the maximum amount of time Bessie can spend traveling between a pair of pastures (given that she always follows a route that takes a minimum amount of time).\n", "hint": "It takes Bessie 5 units of time to travel between the upper-left corner and the lower-right corner of the grid.  No other pair of pastures causes her to travel for more time than this.\n", "locale": "zh-CN"}}}
{"pid": "P3058", "type": "P", "difficulty": 4, "samples": [["(()) \n", "6 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "USACO"], "title": "[USACO12NOV] Balanced Cow Breeds G/S", "background": "", "description": "Farmer John usually brands his cows with a circular mark, but his branding iron is broken, so he instead must settle for branding each cow with a mark in the shape of a parenthesis -- (.  He has two breeds of cows on his farm: Holsteins and Guernseys.  He brands each of his cows with a\n\nparenthesis-shaped mark.  Depending on which direction the cow is facing, this might look like either a left parenthesis or a right parenthesis.\n\nFJ's N cows are all standing in a row, each facing an arbitrary direction, so the marks on the cows look like a string of parentheses of length N. Looking at this lineup, FJ sees a remarkable pattern: if he scans from left to right through just the Holsteins (in the order they appear in the sequence), this gives a balanced string of parentheses; moreover, the same is true for the Guernseys!  To see if this is truly a rare event, please help FJ compute the number of possible ways he could assign breeds to his N cows so that this property holds.\n\nThere are several ways to define what it means for a string of parentheses to be \"balanced\".  Perhaps the simplest definition is that there must be the same total number of ('s and )'s, and for any prefix of the string, there must be at least as many ('s as )'s.  For example, the following strings are all balanced:\n\n() \n(()) \n()(()()) \n\nwhile these are not:\n\n)( \n())( \n((()))) \n\n给一个只有左右括号的字符串，然后用 `H`、`G` 两种字符来标记这个序列，所有标记 `H` 的括号可以组成一个正确的括号序列，所有 `G` 标记的括号也组成一个正确的括号序列，然后输出这种标记方案的总数 $\\operatorname{mod} 2012$ 的值。", "inputFormat": "\\* Line 1: A string of parentheses of length N (1 <= N <= 1000).\n", "outputFormat": "\\* Line 1: A single integer, specifying the number of ways FJ can assign breeds to cows so that the Holsteins form a balanced subsequence of parentheses, and likewise for the Guernseys. Since the answer might be a very large number, please print the remainder of this number when divided by 2012 (i.e., print the number mod 2012).  Breed assignments involving only one breed type are valid.\n", "hint": "The following breed assignments work:\n\n(()) \nHHHH\n(()) \nGGGG\n(()) \nHGGH\n(()) \nGHHG\n(()) \nHGHG\n(()) \nGHGH\n \n感谢@CREEPER\\_ 提供翻译\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO12NOV] Balanced Cow Breeds G/S", "background": "", "description": "Farmer John usually brands his cows with a circular mark, but his branding iron is broken, so he instead must settle for branding each cow with a mark in the shape of a parenthesis — (. He has two breeds of cows on his farm: Holsteins and Guernseys. He brands each of his cows with a parenthesis-shaped mark. Depending on which direction the cow is facing, this might look like either a left parenthesis or a right parenthesis.\n\nFJ’s N cows are all standing in a row, each facing an arbitrary direction, so the marks on the cows look like a string of parentheses of length N. Looking at this lineup, FJ sees a remarkable pattern: if he scans from left to right through just the Holsteins (in the order they appear in the sequence), this gives a balanced string of parentheses; moreover, the same is true for the Guernseys. To see if this is truly a rare event, please help FJ compute the number of possible ways he could assign breeds to his N cows so that this property holds.\n\nThere are several ways to define what it means for a string of parentheses to be \"balanced\". Perhaps the simplest definition is that there must be the same total number of (’s and )’s, and for any prefix of the string, there must be at least as many (’s as )’s. For example, the following strings are all balanced:\n()\n(())\n()(()())\nwhile these are not:\n)(\n())(\n((())))\n\nGiven a string consisting only of left and right parentheses, label the sequence with two characters, H and G, such that the parentheses labeled H form a correct (balanced) parentheses sequence and the parentheses labeled G also form a correct parentheses sequence. Output the total number of such labeling schemes $\\operatorname{mod} 2012$.", "inputFormat": "- Line 1: A string of parentheses of length $N$ ($1 \\le N \\le 1000$).", "outputFormat": "- Line 1: A single integer, specifying the number of ways FJ can assign breeds to cows so that the Holsteins form a balanced subsequence of parentheses, and likewise for the Guernseys. Since the answer might be a very large number, please print the remainder of this number when divided by 2012 (i.e., print the number mod 2012). Breed assignments involving only one breed type are valid.", "hint": "The following breed assignments work:\n(())\nHHHH\n(())\nGGGG\n(())\nHGGH\n(())\nGHHG\n(())\nHGHG\n(())\nGHGH\n\nThanks to @CREEPER_ for providing the translation.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO12NOV] Balanced Cow Breeds G/S", "background": "", "description": "Farmer John usually brands his cows with a circular mark, but his branding iron is broken, so he instead must settle for branding each cow with a mark in the shape of a parenthesis -- (.  He has two breeds of cows on his farm: Holsteins and Guernseys.  He brands each of his cows with a\n\nparenthesis-shaped mark.  Depending on which direction the cow is facing, this might look like either a left parenthesis or a right parenthesis.\n\nFJ's N cows are all standing in a row, each facing an arbitrary direction, so the marks on the cows look like a string of parentheses of length N. Looking at this lineup, FJ sees a remarkable pattern: if he scans from left to right through just the Holsteins (in the order they appear in the sequence), this gives a balanced string of parentheses; moreover, the same is true for the Guernseys!  To see if this is truly a rare event, please help FJ compute the number of possible ways he could assign breeds to his N cows so that this property holds.\n\nThere are several ways to define what it means for a string of parentheses to be \"balanced\".  Perhaps the simplest definition is that there must be the same total number of ('s and )'s, and for any prefix of the string, there must be at least as many ('s as )'s.  For example, the following strings are all balanced:\n\n() \n(()) \n()(()()) \n\nwhile these are not:\n\n)( \n())( \n((()))) \n\n给一个只有左右括号的字符串，然后用 `H`、`G` 两种字符来标记这个序列，所有标记 `H` 的括号可以组成一个正确的括号序列，所有 `G` 标记的括号也组成一个正确的括号序列，然后输出这种标记方案的总数 $\\operatorname{mod} 2012$ 的值。", "inputFormat": "\\* Line 1: A string of parentheses of length N (1 <= N <= 1000).\n", "outputFormat": "\\* Line 1: A single integer, specifying the number of ways FJ can assign breeds to cows so that the Holsteins form a balanced subsequence of parentheses, and likewise for the Guernseys. Since the answer might be a very large number, please print the remainder of this number when divided by 2012 (i.e., print the number mod 2012).  Breed assignments involving only one breed type are valid.\n", "hint": "The following breed assignments work:\n\n(()) \nHHHH\n(()) \nGGGG\n(()) \nHGGH\n(()) \nGHHG\n(()) \nHGHG\n(()) \nGHGH\n \n感谢@CREEPER\\_ 提供翻译\n", "locale": "zh-CN"}}}
{"pid": "P3059", "type": "P", "difficulty": 6, "samples": [["3 14 \n)()((())))(()) \n()(()()()((()) \n)))(()()))(()) \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "USACO"], "title": "[USACO12NOV] Concurrently Balanced Strings G", "background": null, "description": "农夫约翰养了一只非常特殊的奶牛品种，以其独特的外貌而闻名，每只奶牛的皮上都有一个巨大的圆形斑点（根据奶牛的朝向不同，这可能看起来像左括号或右括号）。\n\n一天早上，约翰把他的奶牛们分成了 $K$ 行，每行 $N$ 头奶牛（$1 \\leq K \\leq 10, 1 \\leq N \\leq 50,000$）。由于奶牛们朝向任意方向，所以这个队列可以用 $K$ 个长度为 $N$ 的括号字符串 $S_1,..., S_k$ 来描述。约翰非常激动地注意到他的牛群中有一些“并发平衡”的范围，其中范围 $i...j$ 的奶牛只有在每个字符串 $S_1,..., S_k$ 在该范围内都是平衡的情况下才能同时平衡（我们将在下面定义单个括号字符串平衡的含义）。例如，如果 $K = 3$ ，我们有\n\n- $S_1 = \\texttt{)()((())))(())}$\n- $S_2 = \\texttt{()(()()()((())}$\n- $S_3 = \\texttt{)))(()()))(())}$\n\n那么范围 $[3...8]$ 是并发平衡的，因为 $S_1[3...8] = \\texttt{((()))}$ ，$S_2[3...8] = \\texttt{()()()}$ ，$S_3[3...8] = \\texttt{(()())}$ 。范围 $[10...13]$ 和 $[11...12]$ 也是并发平衡的。\n\n给定 $K$ 个长度为 $N$ 的括号字符串，帮助约翰计算范围 $(i,j)$ 的数量，使得范围 $i...j$ 在 $K$ 个字符串中都是并发平衡的。\n\n对于单个括号字符串的“平衡”的定义有几种方式。也许最简单的定义是括号的数量必须相等，并且对于字符串的任何前缀，左括号的数量必须至少和右括号的数量一样多。例如，以下字符串都是平衡的：\n\n- $\\texttt{()}$\n- $\\texttt{(())}$\n- $\\texttt{()(()())}$\n\n而这些字符串则不是平衡的：\n\n- $\\texttt{)(}$\n- $\\texttt{())(}$\n- $\\texttt{((())))}$\n\n给出 $K$ 个长度为 $N$ 的括号序列，问有多少个区间在 $K$ 个序列中对应的子串均平衡。", "inputFormat": "第一行：两个整数 $K$ 和 $N$。\n\n第二行至第 $K+1$ 行：每行包含一个长度为 $N$ 的括号字符串。", "outputFormat": "第一行：一个整数，表示并发平衡的范围的数量。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[USACO12NOV] Concurrently Balanced Strings G", "background": "", "description": "Farmer John raises a very special breed of cows known for their distinctive appearance, where each cow has a huge circular spot on its hide that, depending on the cow’s orientation, may look like a left parenthesis or a right parenthesis.\n\nOne morning, John arranges his cows into $K$ rows, each with $N$ cows ($1 \\leq K \\leq 10, 1 \\leq N \\leq 50{,}000$). Since the cows face arbitrary directions, this formation can be described by $K$ parenthesis strings $S_1, ..., S_k$ of length $N$. John is excited to notice that his herd has some “concurrently balanced” ranges, where the range $i...j$ is concurrently balanced only if in each string $S_1, ..., S_k$ the substring over that range is balanced (we will define the meaning of a single parenthesis string being balanced below). For example, if $K = 3$, we have\n\n- $S_1 = \\texttt{)()((())))(())}$\n- $S_2 = \\texttt{()(()()()((())}$\n- $S_3 = \\texttt{)))(()()))(())}$\n\nThen the range $[3...8]$ is concurrently balanced because $S_1[3...8] = \\texttt{((()))}$, $S_2[3...8] = \\texttt{()()()}$, and $S_3[3...8] = \\texttt{(()())}$. The ranges $[10...13]$ and $[11...12]$ are also concurrently balanced.\n\nGiven $K$ parenthesis strings of length $N$, help John count the number of pairs $(i, j)$ such that the range $i...j$ is concurrently balanced across all $K$ strings.\n\nThere are several equivalent ways to define “balanced” for a single parenthesis string. Perhaps the simplest is that the total numbers of parentheses must be equal, and for any prefix of the string, the number of left parentheses must be at least as many as the number of right parentheses. For example, the following strings are balanced:\n\n- $\\texttt{()}$\n- $\\texttt{(())}$\n- $\\texttt{()(()())}$\n\nAnd these strings are not balanced:\n\n- $\\texttt{)(}$\n- $\\texttt{())(}$\n- $\\texttt{((())))}$\n\nGiven $K$ sequences of length $N$ consisting of parentheses, how many intervals are there such that the corresponding substrings are balanced in all $K$ sequences?", "inputFormat": "The first line contains two integers $K$ and $N$.\n\nThe second through the $(K+1)$-th lines: each line contains a parenthesis string of length $N$.", "outputFormat": "The first line contains a single integer, the number of concurrently balanced ranges.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO12NOV] Concurrently Balanced Strings G", "background": null, "description": "农夫约翰养了一只非常特殊的奶牛品种，以其独特的外貌而闻名，每只奶牛的皮上都有一个巨大的圆形斑点（根据奶牛的朝向不同，这可能看起来像左括号或右括号）。\n\n一天早上，约翰把他的奶牛们分成了 $K$ 行，每行 $N$ 头奶牛（$1 \\leq K \\leq 10, 1 \\leq N \\leq 50,000$）。由于奶牛们朝向任意方向，所以这个队列可以用 $K$ 个长度为 $N$ 的括号字符串 $S_1,..., S_k$ 来描述。约翰非常激动地注意到他的牛群中有一些“并发平衡”的范围，其中范围 $i...j$ 的奶牛只有在每个字符串 $S_1,..., S_k$ 在该范围内都是平衡的情况下才能同时平衡（我们将在下面定义单个括号字符串平衡的含义）。例如，如果 $K = 3$ ，我们有\n\n- $S_1 = \\texttt{)()((())))(())}$\n- $S_2 = \\texttt{()(()()()((())}$\n- $S_3 = \\texttt{)))(()()))(())}$\n\n那么范围 $[3...8]$ 是并发平衡的，因为 $S_1[3...8] = \\texttt{((()))}$ ，$S_2[3...8] = \\texttt{()()()}$ ，$S_3[3...8] = \\texttt{(()())}$ 。范围 $[10...13]$ 和 $[11...12]$ 也是并发平衡的。\n\n给定 $K$ 个长度为 $N$ 的括号字符串，帮助约翰计算范围 $(i,j)$ 的数量，使得范围 $i...j$ 在 $K$ 个字符串中都是并发平衡的。\n\n对于单个括号字符串的“平衡”的定义有几种方式。也许最简单的定义是括号的数量必须相等，并且对于字符串的任何前缀，左括号的数量必须至少和右括号的数量一样多。例如，以下字符串都是平衡的：\n\n- $\\texttt{()}$\n- $\\texttt{(())}$\n- $\\texttt{()(()())}$\n\n而这些字符串则不是平衡的：\n\n- $\\texttt{)(}$\n- $\\texttt{())(}$\n- $\\texttt{((())))}$\n\n给出 $K$ 个长度为 $N$ 的括号序列，问有多少个区间在 $K$ 个序列中对应的子串均平衡。", "inputFormat": "第一行：两个整数 $K$ 和 $N$。\n\n第二行至第 $K+1$ 行：每行包含一个长度为 $N$ 的括号字符串。", "outputFormat": "第一行：一个整数，表示并发平衡的范围的数量。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3060", "type": "P", "difficulty": 6, "samples": [["15 \n1 \n2 \n1 \n4 \n4 \n6 \n7 \n5 \n9 \n9 \n11 \n12 \n13 \n14 \n( \n) \n) \n( \n) \n) \n( \n) \n( \n( \n( \n) \n) \n) \n( \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2012", "USACO", "点分治"], "title": "[USACO12NOV] Balanced Trees G", "background": null, "description": "Farmer John 对之前解决平衡括号串问题的经历非常着迷，现在 Farmer John 想请你帮忙解决最后一个问题。\n\nFJ 的农场是由 $N$ 个牧场组成的一棵大树，每个牧场都被他标记为了 `(` 或 `)`。例如：\n```\n'('--'('--')'--'('--')'\n |         |\n')'       ')'--'('--'(' \n |              |\n')'            '('--')'--')'--')'--'('\n```\n\n由于农场是一棵树，这意味着某些牧场之间通过路径连接，任意两个牧场之间有且只有一条唯一的路径。\n\nFJ 相信，这些路径中的某些路径代表了一串平衡括号字符串。具体来说，他想知道在所有由树中路径表示的平衡字符串中，最大嵌套深度是多少。\n\n一个平衡括号字符串的嵌套深度是指该字符串所有前缀中左括号比右括号多出的最大数目。\n\n例如，字符串 `()()()` 的嵌套深度为 $1$，而字符串 ((()))() 的嵌套深度为 $3$。我们可以通过计算每个前缀中左括号的超出数量来清楚地看到这一点：\n```\n((()))()\n12321010\n```\n对于上面的示例，拥有最大嵌套深度的字符串是 ((()))，其深度为 $3$，可以通过如下的从 $A$ 到 $B$ 的路径获得：\n```\n'('--'('--')'--'('--')' \n|         | \n')'       ')'--'('--'(' < A \n|              | \n')'            '('--')'--')'--')'--'(' \n^C                            ^B \n```\n\n注意：最深的字符串与最长的平衡字符串不同。例如，从 $A$ 到 $C$ 的路径 `(())(())` 的长度为 $8$，然而，它不是拥有最大嵌套深度的字符串。\n\n你的任务是，输出树中拥有最大嵌套深度的路径的嵌套深度。", "inputFormat": "第 $1$ 行包含一个整数 $N$，表示树中节点的数量。\n\n第 $2\\sim N$ 行，第 $i+1$ 行包含一个整数 $p_{i+1}$（$1\\le p_{i+1}\\le i$），表示节点 $i+1$ 和节点 $p_{i+1}$ 之间有一条边。\n\n第 $N+1\\sim 2N$ 行：第 $N+i$ 行包含一个字符 `(` 或 `)`，表示节点 $i$ 对应的标记。", "outputFormat": "输出包含一行。输出一个整数，表示树中拥有最大嵌套深度的路径的嵌套深度。", "hint": "### 【样例说明】\n题目样例中的树形图如下所示：\n\n```\n1'('--4'('--6')'--7'('--8')' \n|     |\n2')'  5')'--9'('--10'(' \n|           |\n3')'       11'('--12')'--13')'--14')'--15'(' \n```\n### 【数据范围】\n对于 $100\\%$ 的数据，$1\\le N\\le40000$。\n\n翻译 & 格式修复 by FakzianQwQ。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO12NOV] Balanced Trees G", "background": null, "description": "Fascinated by his experience with balanced parentheses so far, Farmer John is curious if you can help him solve one final problem. As it turns out, FJ's farm is in the shape of a giant tree of N pastures $(1\\le N\\le40,000)$, each of which he has labeled with either `(` or `)`. For example:\n```\n'('--'('--')'--'('--')'\n |         |\n')'       ')'--'('--'(' \n |              |\n')'            '('--')'--')'--')'--'('\n```\n\nRecall that since his farm is a tree, this means that certain pairs of pastures are connected by corridors so that there is one unique path between any given pair of pastures. FJ believes that some of these paths represent balanced strings of parentheses. In particular, he would like to know, among all such balanced strings represented by paths through the tree, what is the maximum nesting depth one can find. The nesting depth of a balanced string of parentheses is the maximum, over all prefixes of the string, of the excess number of `(`'s within the prefix. For example, the string `()()()` has nesting depth $1$, but the string `((()))()` has nesting depth $3$, as we can see clearly if we count excess `(`'s for every prefix of the string:\n```\n((()))()\n12321010\n```\n\nFor the example farm above, the deepest string is `((()))` with a depth of $3$, and can be obtained by taking the path from $A$ to $B$ below:\n```\n'('--'('--')'--'('--')' \n|         | \n')'       ')'--'('--'(' < A \n|              | \n')'            '('--')'--')'--')'--'(' \n^C                            ^B\n```\n\nNote that this is different than the longest balanced string; for instance `(())(())`, starting at $A$ and ending at $C$, has length $8$.\n\nYour task is to output the nesting depth of the deepest balanced path in the tree.", "inputFormat": "\\* Line $1$: A single integer $N$, the number of nodes in the tree.\n\n\\* Lines $2\\dots N$: Line $i+1$: A single integer $p_{i+1}(1\\le p_{i+1}\\le i)$, denoting an edge between nodes $i+1$ and $p_{i+1}$ in the tree.\n\n\\* Lines $N+1\\dots 2N$: Line $N+i$: Either `(` or `)`, the label of node $i$.", "outputFormat": "\\* Line $1$: A single integer, giving the maximum nesting depth of a balanced path.", "hint": "This is the example from the problem description, with the following node labels:\n```\n1'('--4'('--6')'--7'('--8')' \n|     |\n2')'  5')'--9'('--10'(' \n|           |\n3')'       11'('--12')'--13')'--14')'--15'(' \n```", "locale": "en"}, "zh-CN": {"title": "[USACO12NOV] Balanced Trees G", "background": null, "description": "Farmer John 对之前解决平衡括号串问题的经历非常着迷，现在 Farmer John 想请你帮忙解决最后一个问题。\n\nFJ 的农场是由 $N$ 个牧场组成的一棵大树，每个牧场都被他标记为了 `(` 或 `)`。例如：\n```\n'('--'('--')'--'('--')'\n |         |\n')'       ')'--'('--'(' \n |              |\n')'            '('--')'--')'--')'--'('\n```\n\n由于农场是一棵树，这意味着某些牧场之间通过路径连接，任意两个牧场之间有且只有一条唯一的路径。\n\nFJ 相信，这些路径中的某些路径代表了一串平衡括号字符串。具体来说，他想知道在所有由树中路径表示的平衡字符串中，最大嵌套深度是多少。\n\n一个平衡括号字符串的嵌套深度是指该字符串所有前缀中左括号比右括号多出的最大数目。\n\n例如，字符串 `()()()` 的嵌套深度为 $1$，而字符串 ((()))() 的嵌套深度为 $3$。我们可以通过计算每个前缀中左括号的超出数量来清楚地看到这一点：\n```\n((()))()\n12321010\n```\n对于上面的示例，拥有最大嵌套深度的字符串是 ((()))，其深度为 $3$，可以通过如下的从 $A$ 到 $B$ 的路径获得：\n```\n'('--'('--')'--'('--')' \n|         | \n')'       ')'--'('--'(' < A \n|              | \n')'            '('--')'--')'--')'--'(' \n^C                            ^B \n```\n\n注意：最深的字符串与最长的平衡字符串不同。例如，从 $A$ 到 $C$ 的路径 `(())(())` 的长度为 $8$，然而，它不是拥有最大嵌套深度的字符串。\n\n你的任务是，输出树中拥有最大嵌套深度的路径的嵌套深度。", "inputFormat": "第 $1$ 行包含一个整数 $N$，表示树中节点的数量。\n\n第 $2\\sim N$ 行，第 $i+1$ 行包含一个整数 $p_{i+1}$（$1\\le p_{i+1}\\le i$），表示节点 $i+1$ 和节点 $p_{i+1}$ 之间有一条边。\n\n第 $N+1\\sim 2N$ 行：第 $N+i$ 行包含一个字符 `(` 或 `)`，表示节点 $i$ 对应的标记。", "outputFormat": "输出包含一行。输出一个整数，表示树中拥有最大嵌套深度的路径的嵌套深度。", "hint": "### 【样例说明】\n题目样例中的树形图如下所示：\n\n```\n1'('--4'('--6')'--7'('--8')' \n|     |\n2')'  5')'--9'('--10'(' \n|           |\n3')'       11'('--12')'--13')'--14')'--15'(' \n```\n### 【数据范围】\n对于 $100\\%$ 的数据，$1\\le N\\le40000$。\n\n翻译 & 格式修复 by FakzianQwQ。", "locale": "zh-CN"}}}
{"pid": "P3061", "type": "P", "difficulty": 6, "samples": [["10 4 \n0 0 10 0 \n10 0 10 10 \n0 0 0 10 \n10 10 0 10 \n8 8 9 8 \n9 8 8 9 \n8 9 8 8 \n2 7 3 2 \n3 2 7 5 \n7 5 2 7 \n15 3 \n1 4 \n4 5 \n7 1 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2012", "USACO"], "title": "[USACO12DEC] Crazy Fences S", "background": null, "description": "在访问了一个现代美术馆后，约翰农夫决定移动 $N$ 个在他的牧场之间的栅栏来\n\n\n重新设计他的农场。每个栅栏用一个 2D 平面的线段来描述。两个栅栏只有在他们的端点才会相遇。每个栅栏在两个端点接触其他的两个栅栏。\n\n\n约翰农夫有 $C$ 头牛在他的农场。每头牛住在 2D 平面的不在任何栅栏的一个点，并且没有两头牛在同一个点。如果两头牛可以不接触任何栅栏地走到一起，他们就是在同一个社区。请确定最大的社区的牛的数量。", "inputFormat": "第一行包含两个整数 $N$ 和 $C$。\n\n接下来 $N$ 行，每行包含四个整数 $x_1,y_1,x_2,y_2$，表示一个栅栏的两个端点为 $(x_1,y_1)$ 和 $(x_2,y_2)$。所有坐标都是 $0...1,000,000$ 范围内的整数。\n\n接下来 $C$ 行，每行包含两个整数 $x,y$，表示一头牛的所在位置为 $(x,y)$。所有坐标都是 $0...1,000,000$ 范围内的整数。", "outputFormat": "输出最大社区的牛的数量。", "hint": "奶牛 $2$ 和 $4$ 在一个社区中。\n\n奶牛 $1$ 和 $3$ 各自在一个社区中。\n\n最大社区的牛的数量为 $2$。", "locale": "zh-CN", "translations": {"en": {"title": "P3061 [USACO12DEC] Crazy Fences S", "background": null, "description": "After visiting a modern art museum, Farmer John decides to re-design his farm by moving all of the $N$ ($1 \\le N \\le 1000$) fences between his pastures! Each fence is describe by a line segment in the 2D plane. If two fences meet, they do so only at their endpoints. Each fence touches exactly two other fences, one at both endpoints.\n\nFJ has $C$ cows ($1 \\le C \\le 1000$) on his farm. Each cow resides at a point in the 2D plane that is not on any fence, and no two cows reside at the same point. Two cows are said to be in the same community if one could walk to the other without touching any fences. Please help FJ determine the size of the largest community.", "inputFormat": "Line $1$: Two space-separated integers $N$ and $C$.\n\nLines $2...N+1$: Each line contains four integers: $x_1$, $y_1$, $x_2$, $y_2$, indicating a fence from point $(x_1,y_1)$ to point $(x_2,y_2)$. All coordinates are integers in the range $0..1,000,000$.\n\nLines $2+N...1+N+C$: Each line contains two integers $x$ and $y$ describing the location of a cow. All coordinates are integers in the range $0..1,000,000$.", "outputFormat": "Line $1$: The number of cows in the largest community.", "hint": "There are $10$ fences and $4$ cows. The fences form a square containing two triangles.\n\nCows $2$ and $4$ belong to the same community. Cows $1$ and $3$ are each members of a community of size $1$.", "locale": "en"}, "zh-CN": {"title": "[USACO12DEC] Crazy Fences S", "background": null, "description": "在访问了一个现代美术馆后，约翰农夫决定移动 $N$ 个在他的牧场之间的栅栏来\n\n\n重新设计他的农场。每个栅栏用一个 2D 平面的线段来描述。两个栅栏只有在他们的端点才会相遇。每个栅栏在两个端点接触其他的两个栅栏。\n\n\n约翰农夫有 $C$ 头牛在他的农场。每头牛住在 2D 平面的不在任何栅栏的一个点，并且没有两头牛在同一个点。如果两头牛可以不接触任何栅栏地走到一起，他们就是在同一个社区。请确定最大的社区的牛的数量。", "inputFormat": "第一行包含两个整数 $N$ 和 $C$。\n\n接下来 $N$ 行，每行包含四个整数 $x_1,y_1,x_2,y_2$，表示一个栅栏的两个端点为 $(x_1,y_1)$ 和 $(x_2,y_2)$。所有坐标都是 $0...1,000,000$ 范围内的整数。\n\n接下来 $C$ 行，每行包含两个整数 $x,y$，表示一头牛的所在位置为 $(x,y)$。所有坐标都是 $0...1,000,000$ 范围内的整数。", "outputFormat": "输出最大社区的牛的数量。", "hint": "奶牛 $2$ 和 $4$ 在一个社区中。\n\n奶牛 $1$ 和 $3$ 各自在一个社区中。\n\n最大社区的牛的数量为 $2$。", "locale": "zh-CN"}}}
{"pid": "P3062", "type": "P", "difficulty": 3, "samples": [["3 20 5 \n7 \n0 \n100 \n", "57.5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "USACO"], "title": "[USACO12DEC] Wifi Setup S", "background": "", "description": "Farmer John's N cows (1 <= N <= 2000) are all standing at various positions along the straight path from the barn to the pasture, which we can think of as a one-dimensional number line.  Since his cows like to stay in email contact with each-other, FJ wants to install Wifi base stations at various positions so that all of the cows have wireless coverage.\n\nAfter shopping around, FJ learns that the cost of a Wifi base station depends on distance it can transmit: a base station of power r costs A + B\\*r, where A is a fixed cost for installing the base station and B is a cost per unit of transmission distance.  If FJ installs such a device at position x, then it can transmit data to any cow located in the range x-r ... x+r.  A base station with transmission power of r=0 is allowed, but this only provides coverage to a cow located at the same position as the transmitter.\n\nGiven the values of A and B, as well as the locations of FJ's cows, please determine the least expensive way FJ can provide wireless coverage for all his cows.\n\n给出在同一条直线上的n个点和两个数A，B，现在要在这条直线上放置若干个信号塔，每个信号塔有一个r值，假设它的位置是x，则它能覆盖的范围是x-r~x+r，放置一个信号塔的花费是A+B\\*r，问要覆盖所有的点最小的花费是多少。\n", "inputFormat": "\\* Line 1: Three space-separated integers: N A B (0 <= A, B <= 1000).\n\n\\* Lines 2..1+N: Each line contains an integer in the range\n\n0..1,000,000 describing the location of one of FJ's cows.\n", "outputFormat": "\\* Line 1: The minimum cost of providing wireless coverage to all cows.\n", "hint": "There are 3 cows at positions 7, 0, and 100.  Installation of a base station of power r costs 20 + 5\\*r.\n\n\nThe optimal solution is to build a base station at position 3.5 (with power 3.5) and another at position 100 (with power 0).  The first base station covers cows 1 and 2, and the second covers cow 3.\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO12DEC] Wifi Setup S", "background": "", "description": "Farmer John’s $N$ cows ($1 \\le N \\le 2000$) stand at various positions along a straight path, which we can regard as a one-dimensional number line. Since his cows want to stay in email contact with each other, FJ plans to install Wifi base stations at positions of his choosing so that all cows have wireless coverage.\n\nThe cost of a Wifi base station depends on its transmission distance: a base station with power $r$ costs $A + B \\times r$, where $A$ is the fixed installation cost and $B$ is the cost per unit distance. If a base station is installed at position $x$, it provides coverage to any cow located in the interval $[x - r, x + r]$. A base station with $r = 0$ is allowed, but it only covers a cow located exactly at $x$.\n\nGiven $A$, $B$, and the locations of FJ’s cows, determine the minimum total cost to provide wireless coverage for all cows. Base stations may be placed at any real position on the line.", "inputFormat": "- Line 1: Three space-separated integers $N$, $A$, $B$, where $1 \\le N \\le 2000$ and $0 \\le A, B \\le 1000$.\n- Lines $2$ to $N + 1$: Each line contains an integer in $[0, 1{,}000{,}000]$ describing the location of one cow.", "outputFormat": "- Line 1: The minimum total cost to provide wireless coverage to all cows.", "hint": "There are $3$ cows at positions $7$, $0$, and $100$. Installing a base station of power $r$ costs $20 + 5 \\times r$.\n\nAn optimal solution is to build one base station at position $3.5$ (power $r = 3.5$) and another at position $100$ (power $r = 0$). The first base station covers cows $1$ and $2$, and the second covers cow $3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO12DEC] Wifi Setup S", "background": "", "description": "Farmer John's N cows (1 <= N <= 2000) are all standing at various positions along the straight path from the barn to the pasture, which we can think of as a one-dimensional number line.  Since his cows like to stay in email contact with each-other, FJ wants to install Wifi base stations at various positions so that all of the cows have wireless coverage.\n\nAfter shopping around, FJ learns that the cost of a Wifi base station depends on distance it can transmit: a base station of power r costs A + B\\*r, where A is a fixed cost for installing the base station and B is a cost per unit of transmission distance.  If FJ installs such a device at position x, then it can transmit data to any cow located in the range x-r ... x+r.  A base station with transmission power of r=0 is allowed, but this only provides coverage to a cow located at the same position as the transmitter.\n\nGiven the values of A and B, as well as the locations of FJ's cows, please determine the least expensive way FJ can provide wireless coverage for all his cows.\n\n给出在同一条直线上的n个点和两个数A，B，现在要在这条直线上放置若干个信号塔，每个信号塔有一个r值，假设它的位置是x，则它能覆盖的范围是x-r~x+r，放置一个信号塔的花费是A+B\\*r，问要覆盖所有的点最小的花费是多少。\n", "inputFormat": "\\* Line 1: Three space-separated integers: N A B (0 <= A, B <= 1000).\n\n\\* Lines 2..1+N: Each line contains an integer in the range\n\n0..1,000,000 describing the location of one of FJ's cows.\n", "outputFormat": "\\* Line 1: The minimum cost of providing wireless coverage to all cows.\n", "hint": "There are 3 cows at positions 7, 0, and 100.  Installation of a base station of power r costs 20 + 5\\*r.\n\n\nThe optimal solution is to build a base station at position 3.5 (with power 3.5) and another at position 100 (with power 0).  The first base station covers cows 1 and 2, and the second covers cow 3.\n", "locale": "zh-CN"}}}
{"pid": "P3063", "type": "P", "difficulty": 4, "samples": [["3 3 15 \n1 2 10 3 \n3 2 10 2 \n1 3 14 1 \n", "27 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["图论", "2012", "USACO", "最短路"], "title": "[USACO12DEC] Milk Routing S", "background": "", "description": "Farmer John's farm has an outdated network of M pipes (1 <= M <= 500) for pumping milk from the barn to his milk storage tank.  He wants to remove and update most of these over the next year, but he wants to leave exactly one path worth of pipes intact, so that he can still pump milk from the barn to the storage tank.\n\nThe pipe network is described by N junction points (1 <= N <= 500), each of which can serve as the endpoint of a set of pipes.  Junction point 1 is the barn, and junction point N is the storage tank.  Each of the M bi-directional pipes runs between a pair of junction points, and has an associated latency (the amount of time it takes milk to reach one end of the pipe from the other) and capacity (the amount of milk per unit time that can be pumped through the pipe in steady state).  Multiple pipes can connect between the same pair of junction points.\n\nFor a path of pipes connecting from the barn to the tank, the latency of the path is the sum of the latencies of the pipes along the path, and the capacity of the path is the minimum of the capacities of the pipes along the path (since this is the \"bottleneck\" constraining the overall rate at which milk can be pumped through the path).  If FJ wants to send a total of X units of milk through a path of pipes with latency L and capacity C, the time this takes is therefore L + X/C.\n\nGiven the structure of FJ's pipe network, please help him select a single path from the barn to the storage tank that will allow him to pump X units of milk in a minimum amount of total time.\n\n\n", "inputFormat": "\\* Line 1: Three space-separated integers: N M X (1 <= X <= 1,000,000).\n\n\\* Lines 2..1+M: Each line describes a pipe using 4 integers: I J L C. I and J (1 <= I,J <= N) are the junction points at both ends of the pipe.  L and C (1 <= L,C <= 1,000,000) give the latency and capacity of the pipe.\n\n\n第1行：三个空格分隔的整数:N M X(1<=X<=1000000)。\n\n\n第2行到第M+1行：每一行描述一条管道，有4个整数：I J L C。I和J(1<=I,J<=N)是这条管道连接的两个点。L和C(1<=L，C<=1000000)是这条管道的延迟和容量。\n", "outputFormat": "\\* Line 1: The minimum amount of time it will take FJ to send milk along a single path, rounded down to the nearest integer.\n\n第1行:约翰沿着一条路径送牛奶花费的最少的时间，向下取整到最近的整数。\n", "hint": "FJ wants to send 15 units of milk through his pipe network.  Pipe #1 connects junction point 1 (the barn) to junction point 2, and has a latency of 10 and a capacity of 3.  Pipes #2 and #3 are similarly defined.\n\n\nThe path 1->3 takes 14 + 15/1 = 29 units of time.  The path 1->2->3 takes 20 + 15/2 = 27.5 units of time, and is therefore optimal.\n\n\n约翰想要通过管网运送15个单位的牛奶。管道1连接节点1（谷仓）和节点2，延迟为10，容量为3。管道2和管道3也以相似的方式来定义。\n\n\n路径1->3花费14+15/1=29个单位的时间。路径1->2->3花费20+15/2=27.5个单位的时间，用时最少。\n", "locale": "en", "translations": {"en": {"title": "[USACO12DEC] Milk Routing S", "background": "", "description": "Farmer John's farm has an outdated network of M pipes (1 <= M <= 500) for pumping milk from the barn to his milk storage tank.  He wants to remove and update most of these over the next year, but he wants to leave exactly one path worth of pipes intact, so that he can still pump milk from the barn to the storage tank.\n\nThe pipe network is described by N junction points (1 <= N <= 500), each of which can serve as the endpoint of a set of pipes.  Junction point 1 is the barn, and junction point N is the storage tank.  Each of the M bi-directional pipes runs between a pair of junction points, and has an associated latency (the amount of time it takes milk to reach one end of the pipe from the other) and capacity (the amount of milk per unit time that can be pumped through the pipe in steady state).  Multiple pipes can connect between the same pair of junction points.\n\nFor a path of pipes connecting from the barn to the tank, the latency of the path is the sum of the latencies of the pipes along the path, and the capacity of the path is the minimum of the capacities of the pipes along the path (since this is the \"bottleneck\" constraining the overall rate at which milk can be pumped through the path).  If FJ wants to send a total of X units of milk through a path of pipes with latency L and capacity C, the time this takes is therefore L + X/C.\n\nGiven the structure of FJ's pipe network, please help him select a single path from the barn to the storage tank that will allow him to pump X units of milk in a minimum amount of total time.\n\n\n", "inputFormat": "\\* Line 1: Three space-separated integers: N M X (1 <= X <= 1,000,000).\n\n\\* Lines 2..1+M: Each line describes a pipe using 4 integers: I J L C. I and J (1 <= I,J <= N) are the junction points at both ends of the pipe.  L and C (1 <= L,C <= 1,000,000) give the latency and capacity of the pipe.\n\n\n第1行：三个空格分隔的整数:N M X(1<=X<=1000000)。\n\n\n第2行到第M+1行：每一行描述一条管道，有4个整数：I J L C。I和J(1<=I,J<=N)是这条管道连接的两个点。L和C(1<=L，C<=1000000)是这条管道的延迟和容量。\n", "outputFormat": "\\* Line 1: The minimum amount of time it will take FJ to send milk along a single path, rounded down to the nearest integer.\n\n第1行:约翰沿着一条路径送牛奶花费的最少的时间，向下取整到最近的整数。\n", "hint": "FJ wants to send 15 units of milk through his pipe network.  Pipe #1 connects junction point 1 (the barn) to junction point 2, and has a latency of 10 and a capacity of 3.  Pipes #2 and #3 are similarly defined.\n\n\nThe path 1->3 takes 14 + 15/1 = 29 units of time.  The path 1->2->3 takes 20 + 15/2 = 27.5 units of time, and is therefore optimal.\n\n\n约翰想要通过管网运送15个单位的牛奶。管道1连接节点1（谷仓）和节点2，延迟为10，容量为3。管道2和管道3也以相似的方式来定义。\n\n\n路径1->3花费14+15/1=29个单位的时间。路径1->2->3花费20+15/2=27.5个单位的时间，用时最少。\n", "locale": "en"}, "zh-CN": {"title": "[USACO12DEC] Milk Routing S", "background": null, "description": "约翰农场的牛奶输送网络由 $M$ 条管道（$1\\le M\\le 500$）组成，这些管道用于将牛奶从牛棚输送到牛奶储存罐。他计划在未来一年内移除并更新大部分管道，但希望保留一条完整的管道路径，以便仍能将牛奶从牛棚输送到储存罐。\n\n该管道网络由 $N$ 个连接点（$1\\le N\\le 500$）描述，每个连接点可以作为一组管道的端点。连接点 $1$ 是牛棚，连接点 $N$ 是储存罐。每条双向管道连接一对连接点，并具有相关的延迟（牛奶从管道一端到达另一端所需的时间）和容量（在稳定状态下每单位时间可以通过管道输送的牛奶量）。同一对连接点之间可以有多条管道连接。\n\n对于从牛棚到储存罐的管道路径，路径的延迟是路径上各管道延迟的总和，路径的容量是路径上各管道容量的最小值（因为这是限制牛奶通过路径的整体速率的「瓶颈」）。如果约翰想通过一条延迟为 $L$、容量为 $C$ 的管道路径输送总量为 $X$ 的牛奶，则所需时间为 $L + X\\div C$。\n\n给定约翰的管道网络结构，请帮助他选择一条从牛棚到储存罐的路径，使他能够在最短的总时间内输送 $X$ 单位的牛奶。", "inputFormat": "第 $1$ 行：\\\n三个用空格分隔的整数：$N$ $M$ $X$ ($1\\le X\\le 10^6$)。\n\n第 $2$ 行到第 $M+1$ 行：\\\n每行描述一条管道，包含 $4$ 个整数：$I$ $J$ $L$ $C$。\\\n$I$ 和 $J$ ($1\\le I, J\\le N$) 是管道连接的两个连接点。\\\n$L$ 和 $C$ ($1\\le L, C\\le 10^6$) 分别是管道的延迟和容量。", "outputFormat": "仅有一行、一个整数：\\\n约翰沿着一条路径送牛奶所花费的最少时间（**向下取整到最近的整数**）。", "hint": "约翰想通过他的管道网络输送 $15$ 单位的牛奶。管道 $1$ 连接连接点 $1$（牛棚）和连接点 $2$，延迟为 $10$，容量为 $3$。管道 $2$ 和 $3$ 也以类似的方式定义。\n\n\n路径 $1\\to3$ 需要 $14 + 15\\div1 = 29$ 单位的时间。路径 $1\\to 2\\to 3$ 需要 $20 + 15\\div2 = 27.5$ 单位的时间，因此是最优的。\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3064", "type": "P", "difficulty": 5, "samples": [["5 3 \n2 \n1 \n2 \n", "YES \n1 \n1 \n3 \n2 \n3 \n1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "USACO"], "title": "[USACO12DEC] Gangs of Istanbull/Cowstantinople G", "background": "", "description": "Life is tough on the farm, and when life is tough you have to get tough. The cows have formed gangs (conveniently numbered 1 to M).  The gangs coexisted in peace for a while, but now things are really getting out of control!\n\nThe cows are competing over control of a great grazing field.  This conflict happens over a series of minutes.  Each minute a single cow walks into the field.  If the field is empty the new cow's gang is considered to take control of the field.  If the field is already controlled by the new cow's gang then the cow just starts grazing.  Otherwise, a single cow from the controlling gang that is grazing confronts the new cow.\n\nThese confrontations between two cows start with some arguing and inevitably end up with the pair coming to realize how much more more alike than different they are.  The cows, seeing the error in their ways, leave the gang and the field and get a cold glass of soy milk at FJ's tavern.  If after this confrontation the field is empty than no gang controls the field.\n\nBessie realizes how these confrontations will occur.  She knows how many cows are in each gang.  Bessie really wants her gang to control the field after the conflict is over and all cows are either on the field or at FJ's tavern.  Help Bessie determine if it is possible for her gang, labeled 1, to control the field in the end.\n\nIf it is possible, Bessie wants to know the maximum number of cows from her gang that could be on the field at the end.  Output this number and the lexicographically earliest ordering of cows that results in this number of cows from Bessie's gang at the end.  An ordering X is said to be lexicographically earlier than Y if there is some k such that X[k] < Y[k] and X[i] = Y[i] for i < k.\n\nn头牛结成了m个帮派，现在它们争夺一块草地。每个单位时间内会有一头牛来。如果草地上还没有牛或者只有自己帮派的牛，他会留在这里。但如果已经有别的帮派的牛，它们会打一架，这使得当前牛和草地上的一头牛去找农夫思考人生。问如何安排来的牛的编号顺序，能使一  号帮派最后有最多的牛留在草地上，如果不为0，还要输出字典序最小的一组方案。\n", "inputFormat": "\\* Line 1: N (1 <= N <= 100) and M (1 <= M <= N) separated by a space. The total number of cows in all the gangs will be N.  The total number of gangs is M.\n\n\\* Lines 2..1+M: The (1+i)th line indicates how many members are in gang i.  Each gang has at least 1 member.\n", "outputFormat": "\\* Line 1: Output YES on a single line if Bessie's gang can control the field after the conflict.  Otherwise output NO on a single line.\n\n\\* Line 2: If Bessie's gang can control the field after the conflict output the maximum number of cows that could be on the field on a single line.\n\n\\* Lines 3..2+N: On the (i+2)th line output the index of the gang of the cow that appears in the ith minute in the\n\nlexicographically earliest ordering that leaves the maximum number of cows on the field after the conflict.\n", "hint": "There are 5 cows and 3 gangs.  Bessie's gang (gang 1) has 2 members, gang 2 has 1 member, and gang 3 has 2 members.\n\n\nOnly one cow from Bessie's gang can end up on the field. \n\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO12DEC] Gangs of Istanbull/Cowstantinople G", "background": "", "description": "Life is tough on the farm, and when life is tough you have to get tough. The cows have formed gangs (conveniently numbered $1$ to $M$). The gangs coexisted in peace for a while, but now things are really getting out of control.\n\nThe cows are competing for control of a great grazing field. This conflict happens over a series of minutes. Each minute a single cow walks into the field. If the field is empty, the new cow’s gang is considered to take control of the field. If the field is already controlled by the new cow’s gang, then the cow just starts grazing. Otherwise, a single cow from the controlling gang that is grazing confronts the new cow.\n\nThese confrontations between two cows start with some arguing and inevitably end with the pair realizing how much more alike than different they are. The cows, seeing the error in their ways, leave the gang and the field and get a cold glass of soy milk at FJ’s tavern. If, after this confrontation, the field is empty, then no gang controls the field.\n\nBessie realizes how these confrontations will occur. She knows how many cows are in each gang. Bessie really wants her gang to control the field after the conflict is over and all cows are either on the field or at FJ’s tavern. Help Bessie determine if it is possible for her gang, labeled $1$, to control the field in the end.\n\nIf it is possible, Bessie wants to know the maximum number of cows from her gang that could be on the field at the end. Output this number and the lexicographically earliest ordering of cows that results in this number of cows from Bessie’s gang at the end. An ordering $X$ is said to be lexicographically earlier than $Y$ if there is some $k$ such that $X[k] < Y[k]$ and $X[i] = Y[i]$ for all $i < k$.\n\nThere are $N$ cows split into $M$ gangs, and they are fighting over a pasture. Each unit of time, one cow arrives. If the pasture is empty or currently controlled by the arriving cow’s own gang, the cow stays. Otherwise, the arriving cow and one grazing cow from the controlling gang fight, and both leave to reflect at Farmer John’s tavern. Determine an arrival order of cow gang indices that maximizes the number of gang $1$ cows remaining on the field at the end. If this maximum is not $0$, also output the lexicographically smallest such ordering.", "inputFormat": "- Line $1$: Two integers $N$ and $M$ ($1 \\le N \\le 100$, $1 \\le M \\le N$). The total number of cows across all gangs is $N$. The total number of gangs is $M$.\n- Lines $2$ to $1+M$: The $(1+i)$-th line contains the number of members in gang $i$. Each gang has at least $1$ member.", "outputFormat": "- Line $1$: Output YES if Bessie’s gang can control the field after the conflict; otherwise, output NO.\n- Line $2$: If YES, output the maximum number of cows from Bessie’s gang that could be on the field at the end.\n- Lines $3$ to $2+N$: If YES, output the lexicographically earliest ordering that achieves this maximum. On the $(i+2)$-th line, output the index of the gang of the cow that appears in the $i$-th minute.", "hint": "There are $5$ cows and $3$ gangs. Bessie’s gang (gang $1$) has $2$ members, gang $2$ has $1$ member, and gang $3$ has $2$ members.\n\nOnly one cow from Bessie’s gang can end up on the field.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO12DEC] Gangs of Istanbull/Cowstantinople G", "background": "", "description": "Life is tough on the farm, and when life is tough you have to get tough. The cows have formed gangs (conveniently numbered 1 to M).  The gangs coexisted in peace for a while, but now things are really getting out of control!\n\nThe cows are competing over control of a great grazing field.  This conflict happens over a series of minutes.  Each minute a single cow walks into the field.  If the field is empty the new cow's gang is considered to take control of the field.  If the field is already controlled by the new cow's gang then the cow just starts grazing.  Otherwise, a single cow from the controlling gang that is grazing confronts the new cow.\n\nThese confrontations between two cows start with some arguing and inevitably end up with the pair coming to realize how much more more alike than different they are.  The cows, seeing the error in their ways, leave the gang and the field and get a cold glass of soy milk at FJ's tavern.  If after this confrontation the field is empty than no gang controls the field.\n\nBessie realizes how these confrontations will occur.  She knows how many cows are in each gang.  Bessie really wants her gang to control the field after the conflict is over and all cows are either on the field or at FJ's tavern.  Help Bessie determine if it is possible for her gang, labeled 1, to control the field in the end.\n\nIf it is possible, Bessie wants to know the maximum number of cows from her gang that could be on the field at the end.  Output this number and the lexicographically earliest ordering of cows that results in this number of cows from Bessie's gang at the end.  An ordering X is said to be lexicographically earlier than Y if there is some k such that X[k] < Y[k] and X[i] = Y[i] for i < k.\n\nn头牛结成了m个帮派，现在它们争夺一块草地。每个单位时间内会有一头牛来。如果草地上还没有牛或者只有自己帮派的牛，他会留在这里。但如果已经有别的帮派的牛，它们会打一架，这使得当前牛和草地上的一头牛去找农夫思考人生。问如何安排来的牛的编号顺序，能使一  号帮派最后有最多的牛留在草地上，如果不为0，还要输出字典序最小的一组方案。\n", "inputFormat": "\\* Line 1: N (1 <= N <= 100) and M (1 <= M <= N) separated by a space. The total number of cows in all the gangs will be N.  The total number of gangs is M.\n\n\\* Lines 2..1+M: The (1+i)th line indicates how many members are in gang i.  Each gang has at least 1 member.\n", "outputFormat": "\\* Line 1: Output YES on a single line if Bessie's gang can control the field after the conflict.  Otherwise output NO on a single line.\n\n\\* Line 2: If Bessie's gang can control the field after the conflict output the maximum number of cows that could be on the field on a single line.\n\n\\* Lines 3..2+N: On the (i+2)th line output the index of the gang of the cow that appears in the ith minute in the\n\nlexicographically earliest ordering that leaves the maximum number of cows on the field after the conflict.\n", "hint": "There are 5 cows and 3 gangs.  Bessie's gang (gang 1) has 2 members, gang 2 has 1 member, and gang 3 has 2 members.\n\n\nOnly one cow from Bessie's gang can end up on the field. \n\n", "locale": "zh-CN"}}}
{"pid": "P3065", "type": "P", "difficulty": 5, "samples": [["4\nomm\nmoo\nmom\nommnom\n", "2\nomm\nmom\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2012", "USACO", "拓扑排序", "Tarjan", "字典树 Trie"], "title": "[USACO12DEC] First! G", "background": null, "description": "Bessie 一直在研究字符串。她发现，通过改变字母表的顺序，她可以按改变后的字母表来排列字符串（字典序大小排列）。\n\n例如，Bessie 发现，对于字符串 $\\texttt{omm},\\texttt{moo},\\texttt{mom}$ 和 $\\texttt{ommnom}$，她可以使用标准字母表使 $\\texttt{mom}$ 排在第一个（即字典序最小），她也可以使用字母表 $\\texttt{abcdefghijklonmpqrstuvwxyz}$ 使得 $\\texttt{omm}$ 排在第一个。然而，Bessie 想不出任何方法（改变字母表顺序）使得 $\\texttt{moo}$ 或 $\\texttt{ommnom}$ 排在第一个。\n\n接下来让我们通过重新排列字母表的顺序来计算输入中有哪些字符串可以排在第一个（即字典序最小），从而帮助 Bessie。\n\n要计算字符串 $X$ 和字符串 $Y$ 按照重新排列过的字母表顺序来排列的顺序，先找到它们第一个不同的字母 $X_i$ 与 $Y_i$，按重排后的字母表顺序比较，若 $X_i$ 比 $Y_i$ 先，则 $X$ 的字典序比 $Y$ 小，即 $X$ 排在 $Y$ 前；若没有不同的字母，则比较 $X$ 与 $Y$ 长度，若 $X$ 比 $Y$ 短，则 $X$ 的字典序比 $Y$ 小，即 $X$ 排在 $Y$ 前。", "inputFormat": "第 $1$ 行：一个数字 $N$（$1\\le N \\le 30,000$），表示 Bessie 正在研究字符串的数量。\n\n第 $2\\sim N+1$ 行：每行包含一个非空字符串。所有字符串包含的字符总数不会超过 $300,000$。输入中的所有字符都是小写字母，即 $a\\sim z$。输入不包含重复的字符串。", "outputFormat": "第 $1$ 行：一个数字 $K$，表示按重排的字母表顺序排列后可以排在第一个的字符串数量。\n\n第 $2\\sim K+1$ 行：第 $i+1$ 行包含第 $i$ 个按重排的字母表顺序排列后可以排在第一个的字符串。字符串应该按照它们在输入中的顺序来输出。", "hint": "样例即题目描述中给出的例子，只有 $\\texttt{omm}$ 和 $\\texttt{mom}$ 在各自特定的字典序下可以被排列在第一个。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO12DEC] First! G", "background": null, "description": "Bessie has been playing with strings again. She found that by changing the order of the alphabet she could make some strings come before all the others lexicographically (dictionary ordering).\n\nFor instance Bessie found that for the strings `omm`, `moo`, `mom`, and `ommnom` she could make `mom` appear first using the standard alphabet and that she could make `omm` appear first using the alphabet `abcdefghijklonmpqrstuvwxyz`. However, Bessie couldn't figure out any way to make `moo` or `ommnom` appear first.\n\nHelp Bessie by computing which strings in the input could be lexicographically first by rearranging the order of the alphabet. To compute if string $X$ is lexicographically before string $Y$ find the index of the first character in which they differ, $j$. If no such index exists then $X$ is lexicographically before $Y$ if $X$ is shorter than $Y$. Otherwise $X$ is lexicographically before $Y$ if $X_j$ occurs earlier in the alphabet than $Y_j$.", "inputFormat": "\\* Line $1$: A single line containing $N (1 \\le N \\le 30,000)$, the number of strings Bessie is playing with.\n\n\\* Lines $2\\sim 1+N$: Each line contains a non-empty string. The total number of characters in all strings will be no more than $300,000$. All characters in input will be lowercase characters `a` through `z`. Input will contain no duplicate strings.", "outputFormat": "\\* Line $1$: A single line containing $K$, the number of strings that could be lexicographically first.\n\n\\* Lines $2 \\sim 1+K$: The $(1+i)$ th line should contain the ith string that could be lexicographically first. Strings should be output in the same order they were given in the input.", "hint": "The example from the problem statement.\n\nOnly `omm` and `mom` can be ordered first.", "locale": "en"}, "zh-CN": {"title": "[USACO12DEC] First! G", "background": null, "description": "Bessie 一直在研究字符串。她发现，通过改变字母表的顺序，她可以按改变后的字母表来排列字符串（字典序大小排列）。\n\n例如，Bessie 发现，对于字符串 $\\texttt{omm},\\texttt{moo},\\texttt{mom}$ 和 $\\texttt{ommnom}$，她可以使用标准字母表使 $\\texttt{mom}$ 排在第一个（即字典序最小），她也可以使用字母表 $\\texttt{abcdefghijklonmpqrstuvwxyz}$ 使得 $\\texttt{omm}$ 排在第一个。然而，Bessie 想不出任何方法（改变字母表顺序）使得 $\\texttt{moo}$ 或 $\\texttt{ommnom}$ 排在第一个。\n\n接下来让我们通过重新排列字母表的顺序来计算输入中有哪些字符串可以排在第一个（即字典序最小），从而帮助 Bessie。\n\n要计算字符串 $X$ 和字符串 $Y$ 按照重新排列过的字母表顺序来排列的顺序，先找到它们第一个不同的字母 $X_i$ 与 $Y_i$，按重排后的字母表顺序比较，若 $X_i$ 比 $Y_i$ 先，则 $X$ 的字典序比 $Y$ 小，即 $X$ 排在 $Y$ 前；若没有不同的字母，则比较 $X$ 与 $Y$ 长度，若 $X$ 比 $Y$ 短，则 $X$ 的字典序比 $Y$ 小，即 $X$ 排在 $Y$ 前。", "inputFormat": "第 $1$ 行：一个数字 $N$（$1\\le N \\le 30,000$），表示 Bessie 正在研究字符串的数量。\n\n第 $2\\sim N+1$ 行：每行包含一个非空字符串。所有字符串包含的字符总数不会超过 $300,000$。输入中的所有字符都是小写字母，即 $a\\sim z$。输入不包含重复的字符串。", "outputFormat": "第 $1$ 行：一个数字 $K$，表示按重排的字母表顺序排列后可以排在第一个的字符串数量。\n\n第 $2\\sim K+1$ 行：第 $i+1$ 行包含第 $i$ 个按重排的字母表顺序排列后可以排在第一个的字符串。字符串应该按照它们在输入中的顺序来输出。", "hint": "样例即题目描述中给出的例子，只有 $\\texttt{omm}$ 和 $\\texttt{mom}$ 在各自特定的字典序下可以被排列在第一个。", "locale": "zh-CN"}}}
{"pid": "P3066", "type": "P", "difficulty": 5, "samples": [["4 5 \n1 4 \n2 3 \n1 5 \n", "3 \n2 \n1 \n1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "USACO", "O2优化", "差分"], "title": "[USACO12DEC] Running Away From the Barn G", "background": "", "description": "给定一颗 $n$ 个点的有根树，边有边权，节点从 $1$ 至 $n$ 编号，$1$ 号节点是这棵树的根。\n\n再给出一个参数 $t$，对于树上的每个节点 $u$，请求出 $u$ 的子树中有多少节点满足该节点到 $u$ 的距离不大于 $t$。", "inputFormat": "输入的第一行是两个整数，分别表示节点数 $n$ 和给出的参数 $t$。\n\n第 $2$ 到第 $n$ 行，每行两个整数，第 $i$ 行的整数 $p_i, w_i$ 表示节点 $i$ 的父节点为 $p_i$，连结 $i$ 与 $p_i$ 的边的边权为 $w_i$。", "outputFormat": "输出 $n$ 行，每行一个整数，第 $i$ 行的整数表示 $i$ 的子树内到 $i$ 的距离不大于 $t$ 的节点个数。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n- $1 \\leq n \\leq 2 \\times 10^5$，$1 \\leq t \\leq 10^{18}$。\n- $1 \\leq p_i \\lt i$，$1 \\leq w_i \\leq 10^{12}$。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO12DEC] Running Away From the Barn G", "background": "", "description": "Given a rooted tree with $n$ nodes and weighted edges. Nodes are numbered from $1$ to $n$, and node $1$ is the root.\n\nGiven a parameter $t$, for each node $u$, find how many nodes in the subtree of $u$ have distance to $u$ not greater than $t$.", "inputFormat": "The first line contains two integers, the number of nodes $n$ and the parameter $t$.\n\nFor each $i$ from $2$ to $n$, the $i$-th line contains two integers $p_i, w_i$, meaning the parent of node $i$ is $p_i$, and the weight of the edge connecting $i$ and $p_i$ is $w_i$.", "outputFormat": "Output $n$ lines. The $i$-th line contains an integer, the number of nodes in the subtree of $i$ whose distance to $i$ is at most $t$.", "hint": "#### Constraints\n\n- $1 \\leq n \\leq 2 \\times 10^5$, $1 \\leq t \\leq 10^{18}$.\n- $1 \\leq p_i \\lt i$, $1 \\leq w_i \\leq 10^{12}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO12DEC] Running Away From the Barn G", "background": "", "description": "给定一颗 $n$ 个点的有根树，边有边权，节点从 $1$ 至 $n$ 编号，$1$ 号节点是这棵树的根。\n\n再给出一个参数 $t$，对于树上的每个节点 $u$，请求出 $u$ 的子树中有多少节点满足该节点到 $u$ 的距离不大于 $t$。", "inputFormat": "输入的第一行是两个整数，分别表示节点数 $n$ 和给出的参数 $t$。\n\n第 $2$ 到第 $n$ 行，每行两个整数，第 $i$ 行的整数 $p_i, w_i$ 表示节点 $i$ 的父节点为 $p_i$，连结 $i$ 与 $p_i$ 的边的边权为 $w_i$。", "outputFormat": "输出 $n$ 行，每行一个整数，第 $i$ 行的整数表示 $i$ 的子树内到 $i$ 的距离不大于 $t$ 的节点个数。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n- $1 \\leq n \\leq 2 \\times 10^5$，$1 \\leq t \\leq 10^{18}$。\n- $1 \\leq p_i \\lt i$，$1 \\leq w_i \\leq 10^{12}$。\n\n", "locale": "zh-CN"}}}
{"pid": "P3067", "type": "P", "difficulty": 5, "samples": [["4 \n1 \n2 \n3 \n4 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2012", "USACO", "折半搜索 meet in the middle"], "title": "[USACO12OPEN] Balanced Cow Subsets G", "background": "", "description": "Farmer John's owns N cows (2 <= N <= 20), where cow i produces M(i) units of milk each day (1 <= M(i) <= 100,000,000).  FJ wants to streamline the process of milking his cows every day, so he installs a brand new milking machine in his barn.  Unfortunately, the machine turns out to be far too sensitive: it only works properly if the cows on the left side of the barn have the exact same total milk output as the cows on the right side of the barn!\n\nLet us call a subset of cows \"balanced\" if it can be partitioned into two groups having equal milk output.  Since only a balanced subset of cows can make the milking machine work, FJ wonders how many subsets of his N cows are balanced.  Please help him compute this quantity.\n", "inputFormat": "\\* Line 1: The integer N.\n\n\\* Lines 2..1+N: Line i+1 contains M(i). \n\n", "outputFormat": "\\* Line 1: The number of balanced subsets of cows.\n", "hint": "There are 4 cows, with milk outputs 1, 2, 3, and 4.\n\n\nThere are three balanced subsets: the subset {1,2,3}, which can be partitioned into {1,2} and {3}, the subset {1,3,4}, which can be partitioned into {1,3} and {4}, and the subset {1,2,3,4} which can be partitioned into {1,4} and {2,3}.\n", "locale": "en", "translations": {"en": {"title": "[USACO12OPEN] Balanced Cow Subsets G", "background": "", "description": "Farmer John's owns N cows (2 <= N <= 20), where cow i produces M(i) units of milk each day (1 <= M(i) <= 100,000,000).  FJ wants to streamline the process of milking his cows every day, so he installs a brand new milking machine in his barn.  Unfortunately, the machine turns out to be far too sensitive: it only works properly if the cows on the left side of the barn have the exact same total milk output as the cows on the right side of the barn!\n\nLet us call a subset of cows \"balanced\" if it can be partitioned into two groups having equal milk output.  Since only a balanced subset of cows can make the milking machine work, FJ wonders how many subsets of his N cows are balanced.  Please help him compute this quantity.\n", "inputFormat": "\\* Line 1: The integer N.\n\n\\* Lines 2..1+N: Line i+1 contains M(i). \n\n", "outputFormat": "\\* Line 1: The number of balanced subsets of cows.\n", "hint": "There are 4 cows, with milk outputs 1, 2, 3, and 4.\n\n\nThere are three balanced subsets: the subset {1,2,3}, which can be partitioned into {1,2} and {3}, the subset {1,3,4}, which can be partitioned into {1,3} and {4}, and the subset {1,2,3,4} which can be partitioned into {1,4} and {2,3}.\n", "locale": "en"}, "zh-CN": {"title": "[USACO12OPEN] Balanced Cow Subsets G", "background": "", "description": "我们定义一个奶牛集合 $S$ 是平衡的，当且仅当满足以下两个条件：\n\n- $S$ 非空。\n- $S$ 可以被**划分**成两个集合 $A,B$，满足 $A$ 里的奶牛产奶量之和等于 $B$ 里的奶牛产奶量之和。划分的含义是，$A\\cup B=S$ 且 $A\\cap B=\\varnothing$。\n\n现在给定大小为 $n$ 的奶牛集合 $S$，询问它有多少个子集是平衡的。请注意，奶牛之间是互不相同的，但是它们的产奶量可能出现相同。", "inputFormat": "第一行一个整数 $n$，表示奶牛的数目。\n\n第 $2$ 至 $n+1$ 行，每行一个数 $a_i$，表示每头奶牛的产奶量。", "outputFormat": "输出一个数表示方案总数。\n\n### 样例解释\n\n共存在三种方案。集合 $\\{1,2,3\\}$ 可以划分为 $\\{1,2\\}$ 与 $\\{3\\}$；集合 $\\{1,3,4\\}$ 可以划分为 $\\{1,3\\}$ 与 $\\{4\\}$；集合 $\\{1,2,3,4\\}$ 可以划分为 $\\{1,4\\}$ 与 $\\{2,3\\}$，共 $3$ 种子集。", "hint": "对于全部数据，保证 $1\\le n\\le 20$，$1\\le a_i\\le 10^8$。", "locale": "zh-CN"}}}
