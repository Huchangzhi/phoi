{"pid": "P6015", "type": "P", "difficulty": 4, "samples": [["5\n1 4 3 2 2\n5\n", "3\n1 2 3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷月赛"], "title": "[CSGRound3] 游戏", "background": "小 Y 和小 Z 是一对好朋友，他们在玩一个游戏。**游戏只有一个回合**。", "description": "有一个牌堆，一共有 $n$ 张牌，第 $i$ 张牌上有一个数 $a_i$，其中第一张牌是堆顶。\n\n小 Z 先取牌，他可以从堆顶开始取连续若干张牌（**可以取 $0$ 张**），取完的牌拿在手上，也就是不在牌堆里了。\n\n然后小 Y 取牌，同样，她也可以从堆顶开始取连续若干张牌（**可以取 $0$ 张**）。\n\n如果一个人手上的牌的数字和大于 $X$，那么他的分数就是 $0$，否则分数就是数字和。\n\n分数高的人获胜，**如果一样高，则无人获胜**。\n\n小 Z 为了获胜，使用了透视挂，即他知道牌堆里每张牌上写的数。\n\n现在问你对于满足 $1 \\leq X \\leq K$ 的所有整数 $X$，哪些可以使得小 Z 有必胜策略，即小 Z 取完后，不管小 Y 怎么取都一定会**输**。", "inputFormat": "第一行一个整数 $n$，表示牌堆里有几张牌。\n\n第二行 $n$ 个整数 $a_{1\\dots n}$，表示每张牌上写的数。\n\n第三行一个正整数 $K$，含义见题目描述。", "outputFormat": "第一行一个整数，表示满足要求的 $X$ 的个数。\n\n第二行从小到大依次输出满足要求的 $X$，用空格隔开。", "hint": "**【样例解释】**\n\n$X=1,2,3$ 时，小 Z 取一张牌，小 Y 不管怎么取都是零分。\n\n$X=4$ 时，小 Z 如果取 $1$ 张，那么小 Y 取 $1$ 张小 Y 就赢了；否则小 Z 只能是零分。\n\n$X=5$ 时，小 Z 如果取 $1$ 张，那么小 Y 取 $1$ 张小 Y 就赢了；小 Z 如果取了 $2$ 张，小 Y 也取 $2$ 张，平局；否则小 Z 只能是零分。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（3 points）：$n = 1$。\n- Subtask 2（14 points）：$K= 1$。\n- Subtask 3（20 points）：$n,K \\le 100$。\n- Subtask 4（33 points）：$n , K \\le 3333$。\n- Subtask 5（30 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\leq n,K \\leq 10^6$，$1\\leq a_i \\leq K$。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[CSGRound3] Game", "background": "Player Y and Player Z are a pair of good friends, and they are playing a game. **The game has only one round**.", "description": "There is a deck with a total of $n$ cards. The $i$-th card has a number $a_i$ written on it, where the first card is the top of the deck.\n\nPlayer Z draws first. He may draw a consecutive number of cards starting from the top of the deck (**he may draw $0$ cards**). The drawn cards are held in his hand, meaning they are removed from the deck.\n\nThen Player Y draws. Similarly, she may draw a consecutive number of cards starting from the top of the deck (**she may draw $0$ cards**).\n\nIf the sum of the numbers on a player's hand is greater than $X$, then their score is $0$; otherwise, their score equals the sum.\n\nThe player with the higher score wins; **if the scores are equal, then nobody wins**.\n\nIn order to win, Player Z uses a cheating tool (x-ray vision), meaning he knows the number written on every card in the deck.\n\nNow, for all integers $X$ satisfying $1 \\leq X \\leq K$, determine which values of $X$ allow Player Z to have a winning strategy, i.e., after Player Z finishes drawing, no matter how Player Y draws, Player Y will definitely **lose**.", "inputFormat": "The first line contains an integer $n$, representing the number of cards in the deck.\n\nThe second line contains $n$ integers $a_{1\\dots n}$, representing the number written on each card.\n\nThe third line contains a positive integer $K$, as described in the statement.", "outputFormat": "The first line contains an integer, representing the number of values $X$ that satisfy the requirement.\n\nThe second line outputs the values of $X$ that satisfy the requirement in increasing order, separated by spaces.", "hint": "**[Sample Explanation]**\n\nWhen $X=1,2,3$, Player Z draws one card, and no matter how Player Y draws, Player Y will get a score of $0$.\n\nWhen $X=4$, if Player Z draws $1$ card, then if Player Y draws $1$ card, Player Y will win; otherwise, Player Z can only get a score of $0$.\n\nWhen $X=5$, if Player Z draws $1$ card, then if Player Y draws $1$ card, Player Y will win. If Player Z draws $2$ cards, then Player Y also draws $2$ cards, resulting in a tie. Otherwise, Player Z can only get a score of $0$.\n\n---\n\n**[Constraints]**\n\n**This problem uses bundled testdata.**\n\n- Subtask 1 (3 points): $n = 1$.\n- Subtask 2 (14 points): $K = 1$.\n- Subtask 3 (20 points): $n, K \\le 100$.\n- Subtask 4 (33 points): $n, K \\le 3333$.\n- Subtask 5 (30 points): no special restrictions.\n\nFor $100\\%$ of the testdata, $1 \\leq n, K \\leq 10^6$, $1 \\leq a_i \\leq K$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CSGRound3] 游戏", "background": "小 Y 和小 Z 是一对好朋友，他们在玩一个游戏。**游戏只有一个回合**。", "description": "有一个牌堆，一共有 $n$ 张牌，第 $i$ 张牌上有一个数 $a_i$，其中第一张牌是堆顶。\n\n小 Z 先取牌，他可以从堆顶开始取连续若干张牌（**可以取 $0$ 张**），取完的牌拿在手上，也就是不在牌堆里了。\n\n然后小 Y 取牌，同样，她也可以从堆顶开始取连续若干张牌（**可以取 $0$ 张**）。\n\n如果一个人手上的牌的数字和大于 $X$，那么他的分数就是 $0$，否则分数就是数字和。\n\n分数高的人获胜，**如果一样高，则无人获胜**。\n\n小 Z 为了获胜，使用了透视挂，即他知道牌堆里每张牌上写的数。\n\n现在问你对于满足 $1 \\leq X \\leq K$ 的所有整数 $X$，哪些可以使得小 Z 有必胜策略，即小 Z 取完后，不管小 Y 怎么取都一定会**输**。", "inputFormat": "第一行一个整数 $n$，表示牌堆里有几张牌。\n\n第二行 $n$ 个整数 $a_{1\\dots n}$，表示每张牌上写的数。\n\n第三行一个正整数 $K$，含义见题目描述。", "outputFormat": "第一行一个整数，表示满足要求的 $X$ 的个数。\n\n第二行从小到大依次输出满足要求的 $X$，用空格隔开。", "hint": "**【样例解释】**\n\n$X=1,2,3$ 时，小 Z 取一张牌，小 Y 不管怎么取都是零分。\n\n$X=4$ 时，小 Z 如果取 $1$ 张，那么小 Y 取 $1$ 张小 Y 就赢了；否则小 Z 只能是零分。\n\n$X=5$ 时，小 Z 如果取 $1$ 张，那么小 Y 取 $1$ 张小 Y 就赢了；小 Z 如果取了 $2$ 张，小 Y 也取 $2$ 张，平局；否则小 Z 只能是零分。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（3 points）：$n = 1$。\n- Subtask 2（14 points）：$K= 1$。\n- Subtask 3（20 points）：$n,K \\le 100$。\n- Subtask 4（33 points）：$n , K \\le 3333$。\n- Subtask 5（30 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\leq n,K \\leq 10^6$，$1\\leq a_i \\leq K$。\n\n", "locale": "zh-CN"}}}
{"pid": "P6016", "type": "P", "difficulty": 5, "samples": [["3 1\n1 2 2 3\n0 1 3\n499122177 1 2", "1"], ["3 3\n1 2 2 3\n0 1 3\n233 1 2", "466\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化", "洛谷月赛"], "title": "[CSGRound3] 出游", "background": "", "description": "学校组织了一次暑期出游活动，报名将在第 $T$ 天截止。\n\n一共有 $n$ 位同学，第 $i$ 位同学有 $a_i$ 位朋友。朋友关系是单向的，换句话说，小 Z 有一个朋友是小 Y，并不意味着小 Y 一定也有一个朋友是小 Z。另外，自己也可能是自己的朋友。\n\n第 $0$ 天时，每位同学会决定自己是否参加活动。第 $i$ 位同学有 $p_i$ 的概率决定参加，$1-p_i$ 的概率决定不参加。\n\n接下来的 $T$ 天里，每位同学会重新决定自己是否参加活动。第 $i$ 位同学这一天决定参加活动，当且仅当至少有一个他的朋友在前一天决定参加，否则便不参加。\n\n你需要求出参加活动的同学人数期望，答案对 $998244353$ 取模。", "inputFormat": "第一行两个整数 $n,T$，含义见题目描述。\n\n接下来 $n$ 行，每行首先两个整数 $p_i, a_i$，$p_i$ 表示模 $998244353$ 意义下第 $i$ 位同学在第 $0$ 天决定参加的概率，$a_i$ 表示他的朋友数量，接下来 $a_i$ 个整数，表示他的朋友。", "outputFormat": "一行一个整数，表示答案对 $998244353$ 取模后的值。", "hint": "**【样例 1 解释】**\n\n| 天数 | 第一位同学去的概率 | 第二位同学去的概率 | 第三位同学去的概率 |\n| :--: | :----------------: | :----------------: | :----------------: |\n| $0$  |        $1$         |        $0$         |     $\\frac 12$     |\n| $1$  |    $\\frac 12 $     |    $\\frac 12 $     |        $0$         |\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（3 points）：$T = 0$。\n- Subtask 2（14 points）：$T = 1$。\n- Subtask 3（33 points）：$n \\le 10$。\n- Subtask 4（20 points）：$T \\le 5 \\times 10^3$。\n- Subtask 5（15 points）：$n \\le 100$。\n- Subtask 6（15 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 500$，$0 \\le T \\le 10^9$，$0 \\le p_i < 998244353$，$0 \\le a_i \\le n$ 且朋友互不相同。", "locale": "zh-CN", "translations": {"en": {"title": "[CSGRound3] Trip", "background": "", "description": "The school organized a summer trip, and registration will close on day $T$.\n\nThere are $n$ students. Student $i$ has $a_i$ friends. The friendship relation is directed. In other words, if student Z has student Y as a friend, it does not mean student Y must have student Z as a friend. Also, a student may be their own friend.\n\nOn day $0$, each student decides whether to join the trip. Student $i$ decides to join with probability $p_i$, and decides not to join with probability $1-p_i$.\n\nDuring the next $T$ days, each student will decide again whether to join. On that day, student $i$ decides to join if and only if at least one of their friends decided to join on the previous day; otherwise, they do not join.\n\nYou need to compute the expected number of students who join the trip. Output the answer modulo $998244353$.", "inputFormat": "The first line contains two integers $n, T$, as described above.\n\nThe next $n$ lines each start with two integers $p_i, a_i$. Here, $p_i$ is the probability (under modulo $998244353$) that student $i$ decides to join on day $0$, and $a_i$ is the number of their friends. Then follow $a_i$ integers indicating their friends.", "outputFormat": "Output one integer, the answer modulo $998244353$.", "hint": "**[Sample 1 Explanation]**\n\n| Day | Probability that the first student goes | Probability that the second student goes | Probability that the third student goes |\n| :--: | :------------------------------------: | :-------------------------------------: | :------------------------------------: |\n| $0$  |                  $1$                   |                  $0$                    |              $\\frac 12$                |\n| $1$  |               $\\frac 12 $              |               $\\frac 12 $               |                  $0$                   |\n\n---\n\n**[Constraints]**\n\n**This problem uses bundled testdata.**\n\n- Subtask 1 (3 points): $T = 0$.\n- Subtask 2 (14 points): $T = 1$.\n- Subtask 3 (33 points): $n \\le 10$.\n- Subtask 4 (20 points): $T \\le 5 \\times 10^3$.\n- Subtask 5 (15 points): $n \\le 100$.\n- Subtask 6 (15 points): No special constraints.\n\nFor $100\\%$ of the testdata: $1 \\le n \\le 500$, $0 \\le T \\le 10^9$, $0 \\le p_i < 998244353$, $0 \\le a_i \\le n$, and all friends are distinct.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CSGRound3] 出游", "background": "", "description": "学校组织了一次暑期出游活动，报名将在第 $T$ 天截止。\n\n一共有 $n$ 位同学，第 $i$ 位同学有 $a_i$ 位朋友。朋友关系是单向的，换句话说，小 Z 有一个朋友是小 Y，并不意味着小 Y 一定也有一个朋友是小 Z。另外，自己也可能是自己的朋友。\n\n第 $0$ 天时，每位同学会决定自己是否参加活动。第 $i$ 位同学有 $p_i$ 的概率决定参加，$1-p_i$ 的概率决定不参加。\n\n接下来的 $T$ 天里，每位同学会重新决定自己是否参加活动。第 $i$ 位同学这一天决定参加活动，当且仅当至少有一个他的朋友在前一天决定参加，否则便不参加。\n\n你需要求出参加活动的同学人数期望，答案对 $998244353$ 取模。", "inputFormat": "第一行两个整数 $n,T$，含义见题目描述。\n\n接下来 $n$ 行，每行首先两个整数 $p_i, a_i$，$p_i$ 表示模 $998244353$ 意义下第 $i$ 位同学在第 $0$ 天决定参加的概率，$a_i$ 表示他的朋友数量，接下来 $a_i$ 个整数，表示他的朋友。", "outputFormat": "一行一个整数，表示答案对 $998244353$ 取模后的值。", "hint": "**【样例 1 解释】**\n\n| 天数 | 第一位同学去的概率 | 第二位同学去的概率 | 第三位同学去的概率 |\n| :--: | :----------------: | :----------------: | :----------------: |\n| $0$  |        $1$         |        $0$         |     $\\frac 12$     |\n| $1$  |    $\\frac 12 $     |    $\\frac 12 $     |        $0$         |\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（3 points）：$T = 0$。\n- Subtask 2（14 points）：$T = 1$。\n- Subtask 3（33 points）：$n \\le 10$。\n- Subtask 4（20 points）：$T \\le 5 \\times 10^3$。\n- Subtask 5（15 points）：$n \\le 100$。\n- Subtask 6（15 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 500$，$0 \\le T \\le 10^9$，$0 \\le p_i < 998244353$，$0 \\le a_i \\le n$ 且朋友互不相同。", "locale": "zh-CN"}}}
{"pid": "P6017", "type": "P", "difficulty": 7, "samples": [["7\n4 4\n5 6\n50 70\n90 102\n40 41\n2000 1999\n1785 2425", "13\n5\n442759796\n851878741\n292277388\n943337434\n183253103"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["洛谷月赛"], "title": "[CSGRound3] 仙人掌", "background": "ckw 是一个非常菜的菜鸡。", "description": "ckw 有好多边仙人掌。边仙人掌是一个每条边至多在一个简单环里的简单无向连通图。 \n\nckw 定义了无向图的度数序列，度数序列的长度为图中点的个数，度数序列中第 $i$ 个元素是图中编号为 $i$ 的节点的度数。\n\nckw 想知道，对于所有 $n$ 个点 $m$ 条边的边仙人掌，其不同的度数序列有多少种。\n\n输出答案模 $998244353$ 之后的结果即可。（如果不存在合法仙人掌输出 $0$ 即可）", "inputFormat": "**本题有多组数据**\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据，一行两个整数 $n,m$，分别表示点数和边数。", "outputFormat": "对于每组数据，一行一个整数，表示答案对 $998244353$ 取模后的值。", "hint": "**【样例解释】**\n\n对于第一组数据，这里给出其中四个合法的度数序列：$\\{2,2,2,2\\},\\{1,2,2,3\\},\\{1,2,3,2\\},\\{2,1,3,2\\}$。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（8 points）：$n \\le 5$。\n- Subtask 2（10 points）：$n \\le 10 $。\n- Subtask 3（18 points）：$n \\le 35$。\n- Subtask 4（12 points）：$n \\le 90$。\n- Subtask 5（8 points）：$m = n - 1$。\n- Subtask 6（10 points）：$m = n$。\n- Subtask 7（16 points）：$m = n + 1$。\n- Subtask 8（18 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 10$，$0 \\le n \\le 2 \\times 10^3$，$0 \\le m \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[CSGRound3] Cactus", "background": "ckw is a very weak newbie.", "description": "ckw has many edge-cactus graphs. An edge-cactus graph is a simple undirected connected graph in which each edge belongs to at most one simple cycle.\n\nckw defines the degree sequence of an undirected graph. The length of the degree sequence is the number of vertices in the graph, and the $i$-th element of the degree sequence is the degree of the vertex numbered $i$.\n\nckw wants to know: among all edge-cactus graphs with $n$ vertices and $m$ edges, how many different degree sequences are there.\n\nOutput the answer modulo $998244353$. (If no valid cactus exists, output $0$.)", "inputFormat": "**This problem has multiple test cases.**\n\nThe first line contains an integer $T$, the number of test cases.\n\nFor each test case, one line contains two integers $n, m$, representing the number of vertices and the number of edges.", "outputFormat": "For each test case, output one integer per line, the answer modulo $998244353$.", "hint": "**[Sample Explanation]**\n\nFor the first test case, here are four valid degree sequences: $\\{2,2,2,2\\},\\{1,2,2,3\\},\\{1,2,3,2\\},\\{2,1,3,2\\}$.\n\n---\n\n**[Constraints]**\n\n**This problem uses bundled testdata.**\n\n- Subtask 1 (8 points): $n \\le 5$.\n- Subtask 2 (10 points): $n \\le 10$.\n- Subtask 3 (18 points): $n \\le 35$.\n- Subtask 4 (12 points): $n \\le 90$.\n- Subtask 5 (8 points): $m = n - 1$.\n- Subtask 6 (10 points): $m = n$.\n- Subtask 7 (16 points): $m = n + 1$.\n- Subtask 8 (18 points): no special constraints.\n\nFor $100\\%$ of the testdata, $1 \\le T \\le 10$, $0 \\le n \\le 2 \\times 10^3$, $0 \\le m \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CSGRound3] 仙人掌", "background": "ckw 是一个非常菜的菜鸡。", "description": "ckw 有好多边仙人掌。边仙人掌是一个每条边至多在一个简单环里的简单无向连通图。 \n\nckw 定义了无向图的度数序列，度数序列的长度为图中点的个数，度数序列中第 $i$ 个元素是图中编号为 $i$ 的节点的度数。\n\nckw 想知道，对于所有 $n$ 个点 $m$ 条边的边仙人掌，其不同的度数序列有多少种。\n\n输出答案模 $998244353$ 之后的结果即可。（如果不存在合法仙人掌输出 $0$ 即可）", "inputFormat": "**本题有多组数据**\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据，一行两个整数 $n,m$，分别表示点数和边数。", "outputFormat": "对于每组数据，一行一个整数，表示答案对 $998244353$ 取模后的值。", "hint": "**【样例解释】**\n\n对于第一组数据，这里给出其中四个合法的度数序列：$\\{2,2,2,2\\},\\{1,2,2,3\\},\\{1,2,3,2\\},\\{2,1,3,2\\}$。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（8 points）：$n \\le 5$。\n- Subtask 2（10 points）：$n \\le 10 $。\n- Subtask 3（18 points）：$n \\le 35$。\n- Subtask 4（12 points）：$n \\le 90$。\n- Subtask 5（8 points）：$m = n - 1$。\n- Subtask 6（10 points）：$m = n$。\n- Subtask 7（16 points）：$m = n + 1$。\n- Subtask 8（18 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 10$，$0 \\le n \\le 2 \\times 10^3$，$0 \\le m \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P6018", "type": "P", "difficulty": 6, "samples": [["3 2\n1 2\n2 3\n1 1 4\n1 1\n3 2", "5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["树形数据结构", "2010", "O2优化", "字典树 Trie", "Ynoi"], "title": "[Ynoi2010] Fusion tree", "background": "题目背景和题意无关，可以跳过\n\n## 1.前言：\nFusion Tree，中文译作融合树，是一种亚log的数据结构，与1993年由Michael L.Fredman和Dan E.Willard提出。\n\n用途：$O( \\log n/ \\log w+ \\log w )$时间复杂度支持插入，删除，前驱，后继，min，max，以及用于整数排序。\n\n信息论断言对$n$个数的排序在最坏情况下需要$n\\log n$次比较，不过对这个界我们还需要一些研究。\n\n有人证明了任意unit cost RAM算法，其中只包含加法，减法，乘法，和0比较（但是不包含除法和位运算）最坏情况下需要$\\Omega(n\\log n)$的时间去对$n$个数排序。\n\n如果允许使用除法和位运算，他们有一个线性时间复杂度的算法，但是这个算法对unit cost滥用。\n\n这里我们规定我们使用的计算模型的字长是w，每个输入的数都是在$[0,2^w-1]$中的整数。\n\n## 2.一些记号：\n对于一个集合$S$和一个整数$x$，定义$rank(S,x)$为S集合中$\\le x$的元素个数。\n对于一些非负整数$a$，定义$bin(a_1,...,a_n)=2^{a_i}+...+2^{a_n}$。\n\n对于两个非负整数$a,b$，定义$msb(u,v)$为$u$和$v$最高的不相同的位。\n\n## 3.概述：\nFusion Tree大概可以看做是一棵特殊的B-Tree，特性：\n\n1. 叉数$B=O(w^{1/5})$\n\n2. 在一次搜索时，每个在搜索路径上的节点的正确的儿子可以被$O(1)$确定\n\n从这些特性我们可以看出Fusion Tree单次操作的时间复杂度是$O( \\log _w(n) + \\log w) = O( \\log n/\\log w +\\log  w)$的，比$O( \\log n )$低。\n\n但是由于其实现方式，Fusion Tree每次对内部节点的更新复杂度是$O( B^4 )$的。\n为了控制Fusion Tree均摊的更新复杂度，我们将这棵B-Tree的每对叶子节点之间的部分替换为一个大小大约为$O( B^4 )$的Weight Balanced Tree，只在WBT根节点发生变化的时候更新Fusion Tree的内部节点。\n\n具体来说，我们B-Tree维护的是一个排序后的数组的分块，其中每个块都由一棵平衡二叉搜索树维护，fusion tree上只维护一个值来表示块边界，用途是指引每次插入，删除，查询在哪个块中。\n\n可以发现这样我们把内部节点的变化次数除掉了一个$B^4$。\n\n## 4.压缩key的表示：\n\n如何$O(1)$确定搜索路径上的一个节点的正确的儿子：\n\n考虑一个B-Tree的节点，其上面包含了$k$个key，其中$B/2 \\le k \\le B$，记作$S={u_1,u_2,...u_k}$。\n\n然后我们定义出$B(S)$表示\"有区别的位的位置\"，用人话来说就是我们把这$k$个key的trie建出来，然后所有有超过$1$个儿子的节点的高度构成的集合\n（当然这里我们不用把trie建出来，只是这么解释比较直观，而且更能反映出其的一些性质）。\n\n再定义一个集合$K(S)$，为$S$只保留$B(S)$中那些位之后的值，记作$K(S)={u'_1,u'_2,...u'_k}$，发现这个压缩操作对于原集合是保序的。\n\n对于一个任意的$w-bit$的数$u$，我们记$u'(S)$表示$u$只保留$B(S)$中那些位，即把非$B(S)$中的位都置为$0$之后的值。\n\n下面引理表达了一个压缩key的重要性质：\n\n### 引理1：\n设$B(S)$排序后为$c_1<c_2<...<c_r$，定义边界$c_0=-1,c_{r+1}=b$。\n\n定义$u'_i$为$K(S)$中任意的一个压缩后的key。\n\n对于一个任意的$w-bit$的数$u$，满足$u \\neq u_i$，\n\n设$msb(u'(S),u'_i)=c_m$，即$u$和$u_i$在bit位置$c_{m+1},...,c_r$位置处相等，但是在$c_m$处不相等，如果$u'(S)=u'_i$，则我们记$m=0$。\n\n如果$u$和$u_i$不同的最高位$p$满足$p>c_m$，那么我们可以通过：\n\n1. 唯一的一个区间$[c_{j-1},c_j]$满足$p$属于这个区间\n\n2. $u$和$u_i$的大小关系\n\n来确定$rank(S,u)$的值。\n\n证明平凡，把trie画出来，显然可以画成一个平面图，然后可以发现这两个可以唯一地确定出一个平面区域，这个区域中的$S$集合元素个数就是$rank(S,u)$（感觉这种东西光写一堆自然语言也不能说明正确性，需要形式化证明一下？）。\n\n注意到这个引理虽然是对任意$u_i$成立的，但是要求$u$和$u_i$不相同的最高位不是$B(S)$中的一个点，可以发现这个$u_i$其实必须在$u$\"脱离\"这个trie的位置，也就是$p$的父亲子树中。\n\n引理$1$使得我们可以将$rank(S,u)$的计算规模降低到$rank(K(S),u'(S))$，通过计算$rank(K(S),u'(S))$，我们可以确定$u'(S)$在$K(S)$中的前驱后继$u'_j$和$u'_{j+1}$（这两个值不一定存在，但经过平凡的讨论就可以解决。\n\n如果$u_j \\le u \\le u_{j+1}$，那我们已经解决了这个问题\n否则我们令$i=j$或者$i=j+1$，计算出$msb(u_i,u)=p$，然后只要我们知道了包含$p$的区间$[c_j,c_{j+1}]$，我们就可以通过引理$1$来确定出$rank(S,u)$的值。\n\n这里如果我们$u_j \\le u \\le u_{j+1}$，那我们已经达成了目的，不用继续考虑了。\n\n否则如果不满足$u_j \\le u \\le u_{j+1}$，也就是说我们在这个sketch的过程中丢失了信息，即说明保留$K(S)$这些位的信息是不够的，那么$p$一定不在$K(S)$中，也就是说$i=j$和$i=j+1$中$p$较小的$i$满足$p>c_m$，故可以使用引理$1$。\n\n计算$K(S)$和$u'(S)$：\n我们发现没有平凡的方法可以将一个$w-bit$的数$u$在$O(1)$时间把$B(S)$那些位提取出来之后放到连续的一段中（可能可以通过硬件支持实现？），即使经过了一定预处理。\n\n其实我们不需要做到这个，可以用具有：\n\n1. 将需要提取出的位提取出，并放到（可以不连续）的更短的一段中\n\n2. 保序性\n\n的其他变化来实现我们需要的效果。\n\n我们可以通过一次恰当的乘法和一次与运算来实现这个：\n\n沿用引理$1$的定义，设我们需要从$u$中提取这些位，令$C=bin(c_1,...,c_r)$。\n\n假设我们已经算出了$C$，我们先通过令$v=u\\;\\mathrm{AND}\\;C$来将$u$中不需要的那些位置$0$。\n\n然后我们将$v$乘以一个量$M$，从而把$v$中我们需要的那些$bit$转化到一个狭窄的范围内，然后再通过一次$\\mathrm{AND}$来清除掉不需要的位置\n这里给出对一个量$M$的存在性证明和构造：\n\n记$M=bin(m_1,...,m_r)$，如果我们暂时忽略交叉和进位造成的影响，那么可以认为$v$乘$M$是把$c_1,...c_r$这些位置的位重新定位到了。\n\n$c_1+m_1,...,c_r+m_r$上。\n\n如果对任意$1 \\le i,j \\le r$，这$r^2$个$c_i+m_j$都是不同的，那么就不会发生交叉和进位了。\n\n我们现在的目标是构造一个整数集合${m_1,...,m_r}$，使得：\n\n1. $c_1+m_1<c_2+m_2<...<c_r+m_r$\n\n2. 对任意$1 \\le i,j \\le r$，$c_i+m_j$都是两两不同的。\n\n3. 变换后的区间$[c_1+m_1,c_r+m_r]$\"相对较小\"，这里的相对较小其实只要是$O( poly(r) )$的即可，因为这样我们可以通过调整树的叉数来满足后续的条件。\n\n### 引理2：\n\n给一个$r$个整数的序列，$c_1<...<c_r$，存在一个$r$个整数的序列，$m_1,...m_r$，满足：\n\n1. $c_1+m_1<c_2+m_2<...<c_r+m_r$\n\n2. 对任意$1 \\le i,j \\le r$，$c_i+m_j$都是两两不同的。\n\n3. $(c_r+m_r)-(c_1+m_1) \\le r^4$\n\n证明：\n\n先考虑证明存在整数序列$m'_1,...,m'_r$，使得对任意$i,j,a,b$，$m'_i+c_a$与$m'_j+c_b$在模$r^3$的意义下不同余。\n\n如果我们找到了这样的整数序列，那么所有$r^2$个$c_i+m'_j$都是两两不同的，并且由于这个是在模$r^3$意义下两两不同的，所以我们可以对第$i$个$c_i+m'_i$加上$(i-1)*r^3$，这样就可以保证对所有$i$满足$c_i+m'_i<c_{i+1}+m'_{i+1}$了。\n\n关于$m'_1,...,m'_r$的存在性：\n\n使用数学归纳法来证明，显然我们可以找到$m'_1$，这个平凡。\n\n假设结论对$t$成立，即我们已经找到了$m'_1,...,m'_t$，满足对任意$1 \\le i,j \\le t$，$a,b$,有$m'_i+c_a$与$m'_j+c_b$在模$r^3$的意义下不同余。\n可以观察到$m'_{t+1}+c_i \\equiv m'_s+c_j (\\mod r^3\\;)$，即$m'_{t+1} \\equiv m'_s+c_j-c_i (\\mod r^3\\;)$。\n\n\n我们可以令$m'_{t+1}$是$[0,r^3)$中最小的和所有$m'_s+c_j-c_i$不同余的数，这里$1 \\le s \\le t,1 \\le i,j \\le r$。\n\n由鸽巢原理，由于$t*r^2<r^3$，所以我们一定可以找到$m'_{t+1}$。\n\n故当$t+1 \\le s$时，结论对$t+1$成立\n由数学归纳法知结论对$s$成立，同时我们这里给出了一个暴力的$O( r^4 )$的构造算法（$r$轮，每轮最坏枚举$O( r^3 )$个位置）。\n\n## 5.融合：\n融合树的\"融合\"即指将每个节点上的key放到同一个$w-bit$的word上，通过对这个word进行运算来一起处理这些key。\n\n沿用之前$u_i$和$B(S)=\\{c_i\\}$的记号：\n\n我们这个B-Tree的每个节点存了$C=bin(c_1,...c_r)$和$M=bin(m_1,...,m_r)$这两个量，用于计算$u'(S)$，同时还存了$D=bin(c_1+m_1,...,c_r+m_r)$这个量，用于清空$u'(S)$的计算中不需要的位。\n\n同时还需要两个数组，存排序后的$u_i$和$u'_i$，和一个表$f[i][j][2]$表示引理$1$中，如果知道了$u_i$和$j$，还有$u$和$u_i$的大小关系，我们唯一确定的答案是多少。\n\n回顾之前的内容，当我们算出了$j=rank(K(S),u'(S))$后，如果$u$不在$[u_j,u_{j+1}]$的区间中，那么我们把$u'(S) \\;\\mathrm{XOR}\\; u'_j$和$u'(S) \\;\\mathrm{XOR}\\; u'_{j+1}$比较一下，较小的值所对应的$u'_h$，$h=j$或$j+1$，和$u$有更长的公共前缀，即$msb$更小。\n\n令$m=msb(u,u_h)$，然后我们需要知道$m$被哪个$B(S)$中的区间$[c_i,c_{i+1}]$包含，所以需要进行一次$i=rank(B(S),m)$的计算\n还需要进行一次$u$和$u_h$的比较，这个平凡，当这些都做完了，我们查一下表$f$即可得到$rank(S,u)$。\n\n可以发现fusion tree的每个内部节点需要存下$O( B^2 )$大小的表，内部节点个数是$O( n/B^4 )$个，所以是$O( n )$空间的。\n\n下面给出对\n\n1. $rank(K(S),u'(S))$\n\n2. $rank(B(S),m)$，其中$m$是在$[0,w]$中的整数\n\n3. 两个$w-bit$的整数$u,v$，$msb(u,v)$\n\n的计算方法：\n\n### $O(1)$计算$rank(K(S),u'(S))$：\n我们把每个$K(S)$中的元素前面补一个$1$，然后从小到大拼到一起来，这个拼起来的操作就是所谓的\"融合\"。\n\n由于我们$K(S)$中有$k$个元素，每个元素有$r^4$位，所以这里总共用了$k(r^4+1)$位，由于$B/2 \\le k \\le B$，所以我们总的位数是$O( B^5 )$的，由于$B=O( w^{1/5} )$，所以总的位数是$O( w )$的。\n\n所以我们拼起来的这个东西是$O( 1 )$个word的，这里将其定义为$A$。\n\n令$C=\\sum \\limits _{i = 0} ^ {B} 2^{(r^4+1)i}$\n通过$u'(S) \\times C$，可以将$u'(S)$前面补一个$0$之后复制$B$遍，然后拼到一起\n通过$A-u'(S) \\times C$，可以发现对每个$A$中补$1$的位置，其对应的那个$u_i(S)$如果$<u'(S)$，则这个$1$变成$0$，否则$1$不变\n所以我们通过$(A-u'(S) \\times C)\\&C$，然后对这个word数$1$的个数即可知道$rank(K(S),u'(S))$。\n\n由于这个word只在$2^{(r^4+1)i}$这样的位置有$1$，我们可以通过一次对$2^{r^4+1}-1$的取模来得到其中$1$的个数，虽然对常数取模可以用乘法和位运算$O(1)$实现，但我们这里可以给出一个更合适的构造。\n\n我们可以通过将其乘$C \\& (2^{(r^4+1)k}-1)$，这样相当于把其叠加了$k$次之后加起来，可以发现其中有一个长为$r^4+1$的段，这段的二进制表示的值等于这个word在$2^{(r^4+1)i}$这些位置的元素的和。\n\n通过位移和$\\mathrm{AND}$我们可以取出这个长$r^4+1$的段，于是就完成了。\n\n答案即$((((A-u'(S) \\times C) \\& C) \\times (C \\& (2^{(r^4+1)k}-1))) \\& C)>>((k(r^4+1)-1)$\n\n### $O(1)$计算$rank(B(S),m)$，$m$是在$[0,w]$中的整数：\n\n由于我们可以$O(1)$计算$rank(K(S),u'(S))$，所以把这个查出来然后判断那一个数的大小，并且进行一次查表即可。\n\n### $O(1)$计算$msb(u,v)$：\n等价于求$u \\;\\mathrm{XOR}\\; v$的最高位$1$的位置，设$A=u \\;\\mathrm{XOR}\\; v$。\n\n我们将$A$分为$r^c$大小的块，总共$r$块，这里$c$是一个常数,$c>1$\n令$C=(100...0100...0......)_2$，这里每两个$1$之间有$r-1$个$1$，$C$是一个常数。\n\n注意到：\n\n$((100...0)_2-0)\\&(1<<(r^c)-1)=(1<<(r^c)-1)$\n\n$((100...0)_2-y)\\&(1<<(r^c)-1)=0$，这里$y>0$\n\n先考虑对每个块去掉首位，块内是否有$1$。\n\n我们用$A\\& \\sim C$可以去掉每一块的首位。\n\n然后用$C-(A\\& \\sim C)$可以使得每一块中除首位外如果有$1$，则其在该块首位为$0$，否则为$1$。\n\n然后用$(C-(A\\& \\sim C))\\&C$去掉了$C-(A\\& \\sim C)$中每一块中除首位外的部分。\n\n然后用$(C-((C-(A\\& \\sim C))\\&C))$可以得到：如果一块中除首位外有$1$，则块首位为$1$，否则为$0$，且块首位外所有位置都是$0$的一个数\n再考虑对每个块只保留首位，块内是否有$1$。\n\n这个用$A\\&C$即可。\n\n最后$(A\\&C)|(C-((C-(A\\& \\sim C))\\&C))$可以得到：如果一块中有$1$，则块首位为$1$，否则为$0$，且块首位外所有位置都是$0$的一个数。\n\n令$D= \\sum \\limits _{k=0}^{r-1} 2^{k(r^c-1)}$，\n\n通过$(((A\\&C)|(C-((C-(A\\& \\sim C))\\&C))) \\times D)>>(w-r)$可以将每块首位的数字拼到一个长$r$的二进制数中。\n\n然后我们可以使用前面的$O(1)$计算$rank$的方法，令$B'(S)={2^i}$，$i$在$[0,r-1]$间，是整数。\n\n通过$rank(B'(S),(((A\\&C)|(C-((C-(A\\& \\sim C))\\&C))) \\times D)>>(w-r))$就可以得到这个长$r$的二进制数中第一个非0的首位的位置了。\n\n我们知道了第一个非$0$位在哪个块中，然后查这个块里面第一个非$0$位的位置就可以了。\n\n由于我们每个块是$r^c$的大小，所以对一个大小为$r^c$，包含了$2^i$的集合用一次rank即找到了块内第一个非$0$的首位位置。\n\n取$c=4,r=w^{1/5}$，$r^c=w^{4/5}$，我们便$O(1)$查询，$O(w^{4/5})$预处理时间复杂度解决了这个问题，由于预处理次数是$O( n/B^4 )$，所以这里也是线性的。\n\n综上所述，我们得到了一个单次操作复杂度$O( \\log n/\\log w + \\log w )$的数据结构，这里**据说**可以通过一些优化做到$O( \\log n/\\log w )$，但在这里由于我还没看所以暂时不做介绍。\n\n## 6.一些拓展\n如果我们允许下列中的一个：\n\n1. 放松线性空间的限制\n\n2. 保留线性空间的限制，但是使用随机化和整数除法\n\n那么我们可以得到一个$O( \\sqrt{ \\log n } )$的动态搜索的时间复杂度上界。\n\n当$n$超过$2^{(\\log w)^2/36}$时（这里$1/36$的常数是论文中给出的，由于我的部分细节和论文中不同，可能是不同的常数），\n\n对于1的case，可以通过使用vEB树来实现，对于2的case，可以通过使用Y-fast trie实现。\n\n对于这样的$n$，这两个数据结构可以在$O( \\log \\log U )=O( \\log w )=O( \\sqrt{\\log n} )$的时间完成一次搜索操作。\n\n当$n$小于这个数时，\n\n对于较小的$n$，我们使用fusion tree，通过调节$B=Θ(2^ {\\sqrt{\\log n}})$。\n\n在这个$B$下，我们的时间复杂度是$O( \\log n/\\log B + \\log B ) = O( \\sqrt{\\log n} )$。\n\n综上所述，如果引入随机化和整数除法，可以$O( n \\sqrt{\\log n} )$时间，线性空间整数排序。\n\n## 7.总结\n由信息论可以证明基于比较的排序下界是$\\Omega( n\\log n )$的，但整数排序其实是非常复杂的一个问题，还有待研究。", "description": "魔法森林里有一颗大树，下面经常有小孩召开法。\n\n大树可以看做一个有 $n$ 个节点，$n - 1$ 条边的无向连通图。大树的每个节点都有若干瓶矿泉水，初始第 $i$ 个节点有 $a_i$ 瓶矿泉水。\n\n麦杰斯住在大树顶端，有一天他想改造一下大树，方便他巨大多喝水之后可以垃圾分类矿泉水瓶。\n\n麦杰斯喜欢二进制运算，所以他会有以下三种操作：\n\n1. 将树上与一个节点 $x$ 距离为 $1$ 的节点上的矿泉水数量 $+1$。这里树上两点间的距离定义为从一点出发到另外一点的最短路径上边的条数。\n2. 在一个节点 $x$ 上喝掉 $v$ 瓶水。\n3. 询问树上与一个节点 $x$ 距离为 $1$ 的所有节点上的矿泉水数量的异或和。\n\n麦杰斯共有 $m$ 次操作，他希望你在每次 $3$ 操作后告诉他答案。", "inputFormat": "第一行两个正整数 $n,m$，分别表示树的节点个数和麦杰斯的询问个数。\n\n第二行到第 $n$ 行，每行两个整数表示有一条连接这两个节点的边。\n\n第 $n + 1$ 行 $n$ 个整数，第 $i$ 个整数表示初始第 $i$ 个节点上的矿泉水数量。\n\n第 $n + 2$ 行到第 $n + m + 1$ 行，每行先读入一个整数 $opt$ 表示操作类型。\n\n如果 $opt = 1$ 或 $3$ ，接下来读入一个整数 $x$ 表示麦杰斯操作的节点标号。\n\n否则接下来读入两个整数 $x, v$ 表示麦杰斯操作的节点标号和他喝的水的数量。", "outputFormat": "对于每一个 $3$ 操作，输出一行一个整数表示答案。", "hint": "Idea：dangxingyu，Solution：dangxingyu，Code：dangxingyu，Data：dangxingyu\n\n对于 $30\\%$ 的数据，满足 $n \\le 10^3$，$m\\le 10^3$。\n\n对于 $60\\%$ 的数据，满足 $n \\le 10^5$，$m \\le 10^5$。\n\n对于另外 $10\\%$ 的数据，存在一个点满足所有点到该节点的距离 $\\le 1$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n \\le 5\\times 10^5$，$1\\le m \\le 5\\times 10^5$，$0\\le a_i \\le 10^5$，$1 \\le x \\le n$，$opt\\in\\{1,2,3\\}$。\n\n保证任意时刻每个节点的矿泉水数非负。\n\n温馨提示：矿泉水瓶不是干垃圾也不是湿垃圾，而是可回收垃圾。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Ynoi2010] Fusion tree", "background": "", "description": "There is a big tree in a magic forest, and children often hold gatherings under it.\n\nThe tree can be seen as an undirected connected graph with $n$ nodes and $n - 1$ edges. Each node of the tree has some bottles of mineral water. Initially, node $i$ has $a_i$ bottles.\n\nMajies lives at the top of the tree. One day, he wants to remodel the tree so that it will be convenient for him to sort the empty mineral water bottles for recycling after he drinks a lot of water.\n\nMajies likes binary operations, so he will perform the following three types of operations:\n\n1. Add $1$ to the number of mineral water bottles on every node whose distance to a node $x$ is $1$. The distance between two nodes on the tree is defined as the number of edges on the shortest path between them.\n2. Drink $v$ bottles of water at node $x$.\n3. Query the xor sum of the numbers of mineral water bottles on all nodes whose distance to a node $x$ is $1$.\n\nMajies has $m$ operations in total. You need to output the answer after each operation of type $3$.", "inputFormat": "The first line contains two positive integers $n, m$, which represent the number of nodes in the tree and the number of queries.\n\nLines $2$ to $n$ each contain two integers, indicating an edge connecting these two nodes.\n\nLine $n + 1$ contains $n$ integers. The $i$-th integer indicates the initial number of mineral water bottles at node $i$.\n\nLines $n + 2$ to $n + m + 1$ each start with an integer $opt$ representing the operation type.\n\nIf $opt = 1$ or $opt = 3$, then an integer $x$ follows, indicating the node that Majies operates on.\n\nOtherwise, two integers $x, v$ follow, indicating the node that Majies operates on and the number of bottles he drinks.", "outputFormat": "For each operation of type $3$, output one line containing one integer, which is the answer.", "hint": "Idea: dangxingyu, Solution: dangxingyu, Code: dangxingyu, Data: dangxingyu.\n\nFor $30\\%$ of the testdata, $n \\le 10^3$, $m \\le 10^3$.\n\nFor $60\\%$ of the testdata, $n \\le 10^5$, $m \\le 10^5$.\n\nFor another $10\\%$ of the testdata, there exists a node such that the distance from every node to this node is $\\le 1$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 5\\times 10^5$, $1 \\le m \\le 5\\times 10^5$, $0 \\le a_i \\le 10^5$, $1 \\le x \\le n$, $opt\\in\\{1,2,3\\}$.\n\nIt is guaranteed that the number of mineral water bottles at each node is non-negative at any time.\n\nFriendly reminder: mineral water bottles are neither dry waste nor wet waste; they are recyclable waste.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Ynoi2010] Fusion tree", "background": "题目背景和题意无关，可以跳过\n\n## 1.前言：\nFusion Tree，中文译作融合树，是一种亚log的数据结构，与1993年由Michael L.Fredman和Dan E.Willard提出。\n\n用途：$O( \\log n/ \\log w+ \\log w )$时间复杂度支持插入，删除，前驱，后继，min，max，以及用于整数排序。\n\n信息论断言对$n$个数的排序在最坏情况下需要$n\\log n$次比较，不过对这个界我们还需要一些研究。\n\n有人证明了任意unit cost RAM算法，其中只包含加法，减法，乘法，和0比较（但是不包含除法和位运算）最坏情况下需要$\\Omega(n\\log n)$的时间去对$n$个数排序。\n\n如果允许使用除法和位运算，他们有一个线性时间复杂度的算法，但是这个算法对unit cost滥用。\n\n这里我们规定我们使用的计算模型的字长是w，每个输入的数都是在$[0,2^w-1]$中的整数。\n\n## 2.一些记号：\n对于一个集合$S$和一个整数$x$，定义$rank(S,x)$为S集合中$\\le x$的元素个数。\n对于一些非负整数$a$，定义$bin(a_1,...,a_n)=2^{a_i}+...+2^{a_n}$。\n\n对于两个非负整数$a,b$，定义$msb(u,v)$为$u$和$v$最高的不相同的位。\n\n## 3.概述：\nFusion Tree大概可以看做是一棵特殊的B-Tree，特性：\n\n1. 叉数$B=O(w^{1/5})$\n\n2. 在一次搜索时，每个在搜索路径上的节点的正确的儿子可以被$O(1)$确定\n\n从这些特性我们可以看出Fusion Tree单次操作的时间复杂度是$O( \\log _w(n) + \\log w) = O( \\log n/\\log w +\\log  w)$的，比$O( \\log n )$低。\n\n但是由于其实现方式，Fusion Tree每次对内部节点的更新复杂度是$O( B^4 )$的。\n为了控制Fusion Tree均摊的更新复杂度，我们将这棵B-Tree的每对叶子节点之间的部分替换为一个大小大约为$O( B^4 )$的Weight Balanced Tree，只在WBT根节点发生变化的时候更新Fusion Tree的内部节点。\n\n具体来说，我们B-Tree维护的是一个排序后的数组的分块，其中每个块都由一棵平衡二叉搜索树维护，fusion tree上只维护一个值来表示块边界，用途是指引每次插入，删除，查询在哪个块中。\n\n可以发现这样我们把内部节点的变化次数除掉了一个$B^4$。\n\n## 4.压缩key的表示：\n\n如何$O(1)$确定搜索路径上的一个节点的正确的儿子：\n\n考虑一个B-Tree的节点，其上面包含了$k$个key，其中$B/2 \\le k \\le B$，记作$S={u_1,u_2,...u_k}$。\n\n然后我们定义出$B(S)$表示\"有区别的位的位置\"，用人话来说就是我们把这$k$个key的trie建出来，然后所有有超过$1$个儿子的节点的高度构成的集合\n（当然这里我们不用把trie建出来，只是这么解释比较直观，而且更能反映出其的一些性质）。\n\n再定义一个集合$K(S)$，为$S$只保留$B(S)$中那些位之后的值，记作$K(S)={u'_1,u'_2,...u'_k}$，发现这个压缩操作对于原集合是保序的。\n\n对于一个任意的$w-bit$的数$u$，我们记$u'(S)$表示$u$只保留$B(S)$中那些位，即把非$B(S)$中的位都置为$0$之后的值。\n\n下面引理表达了一个压缩key的重要性质：\n\n### 引理1：\n设$B(S)$排序后为$c_1<c_2<...<c_r$，定义边界$c_0=-1,c_{r+1}=b$。\n\n定义$u'_i$为$K(S)$中任意的一个压缩后的key。\n\n对于一个任意的$w-bit$的数$u$，满足$u \\neq u_i$，\n\n设$msb(u'(S),u'_i)=c_m$，即$u$和$u_i$在bit位置$c_{m+1},...,c_r$位置处相等，但是在$c_m$处不相等，如果$u'(S)=u'_i$，则我们记$m=0$。\n\n如果$u$和$u_i$不同的最高位$p$满足$p>c_m$，那么我们可以通过：\n\n1. 唯一的一个区间$[c_{j-1},c_j]$满足$p$属于这个区间\n\n2. $u$和$u_i$的大小关系\n\n来确定$rank(S,u)$的值。\n\n证明平凡，把trie画出来，显然可以画成一个平面图，然后可以发现这两个可以唯一地确定出一个平面区域，这个区域中的$S$集合元素个数就是$rank(S,u)$（感觉这种东西光写一堆自然语言也不能说明正确性，需要形式化证明一下？）。\n\n注意到这个引理虽然是对任意$u_i$成立的，但是要求$u$和$u_i$不相同的最高位不是$B(S)$中的一个点，可以发现这个$u_i$其实必须在$u$\"脱离\"这个trie的位置，也就是$p$的父亲子树中。\n\n引理$1$使得我们可以将$rank(S,u)$的计算规模降低到$rank(K(S),u'(S))$，通过计算$rank(K(S),u'(S))$，我们可以确定$u'(S)$在$K(S)$中的前驱后继$u'_j$和$u'_{j+1}$（这两个值不一定存在，但经过平凡的讨论就可以解决。\n\n如果$u_j \\le u \\le u_{j+1}$，那我们已经解决了这个问题\n否则我们令$i=j$或者$i=j+1$，计算出$msb(u_i,u)=p$，然后只要我们知道了包含$p$的区间$[c_j,c_{j+1}]$，我们就可以通过引理$1$来确定出$rank(S,u)$的值。\n\n这里如果我们$u_j \\le u \\le u_{j+1}$，那我们已经达成了目的，不用继续考虑了。\n\n否则如果不满足$u_j \\le u \\le u_{j+1}$，也就是说我们在这个sketch的过程中丢失了信息，即说明保留$K(S)$这些位的信息是不够的，那么$p$一定不在$K(S)$中，也就是说$i=j$和$i=j+1$中$p$较小的$i$满足$p>c_m$，故可以使用引理$1$。\n\n计算$K(S)$和$u'(S)$：\n我们发现没有平凡的方法可以将一个$w-bit$的数$u$在$O(1)$时间把$B(S)$那些位提取出来之后放到连续的一段中（可能可以通过硬件支持实现？），即使经过了一定预处理。\n\n其实我们不需要做到这个，可以用具有：\n\n1. 将需要提取出的位提取出，并放到（可以不连续）的更短的一段中\n\n2. 保序性\n\n的其他变化来实现我们需要的效果。\n\n我们可以通过一次恰当的乘法和一次与运算来实现这个：\n\n沿用引理$1$的定义，设我们需要从$u$中提取这些位，令$C=bin(c_1,...,c_r)$。\n\n假设我们已经算出了$C$，我们先通过令$v=u\\;\\mathrm{AND}\\;C$来将$u$中不需要的那些位置$0$。\n\n然后我们将$v$乘以一个量$M$，从而把$v$中我们需要的那些$bit$转化到一个狭窄的范围内，然后再通过一次$\\mathrm{AND}$来清除掉不需要的位置\n这里给出对一个量$M$的存在性证明和构造：\n\n记$M=bin(m_1,...,m_r)$，如果我们暂时忽略交叉和进位造成的影响，那么可以认为$v$乘$M$是把$c_1,...c_r$这些位置的位重新定位到了。\n\n$c_1+m_1,...,c_r+m_r$上。\n\n如果对任意$1 \\le i,j \\le r$，这$r^2$个$c_i+m_j$都是不同的，那么就不会发生交叉和进位了。\n\n我们现在的目标是构造一个整数集合${m_1,...,m_r}$，使得：\n\n1. $c_1+m_1<c_2+m_2<...<c_r+m_r$\n\n2. 对任意$1 \\le i,j \\le r$，$c_i+m_j$都是两两不同的。\n\n3. 变换后的区间$[c_1+m_1,c_r+m_r]$\"相对较小\"，这里的相对较小其实只要是$O( poly(r) )$的即可，因为这样我们可以通过调整树的叉数来满足后续的条件。\n\n### 引理2：\n\n给一个$r$个整数的序列，$c_1<...<c_r$，存在一个$r$个整数的序列，$m_1,...m_r$，满足：\n\n1. $c_1+m_1<c_2+m_2<...<c_r+m_r$\n\n2. 对任意$1 \\le i,j \\le r$，$c_i+m_j$都是两两不同的。\n\n3. $(c_r+m_r)-(c_1+m_1) \\le r^4$\n\n证明：\n\n先考虑证明存在整数序列$m'_1,...,m'_r$，使得对任意$i,j,a,b$，$m'_i+c_a$与$m'_j+c_b$在模$r^3$的意义下不同余。\n\n如果我们找到了这样的整数序列，那么所有$r^2$个$c_i+m'_j$都是两两不同的，并且由于这个是在模$r^3$意义下两两不同的，所以我们可以对第$i$个$c_i+m'_i$加上$(i-1)*r^3$，这样就可以保证对所有$i$满足$c_i+m'_i<c_{i+1}+m'_{i+1}$了。\n\n关于$m'_1,...,m'_r$的存在性：\n\n使用数学归纳法来证明，显然我们可以找到$m'_1$，这个平凡。\n\n假设结论对$t$成立，即我们已经找到了$m'_1,...,m'_t$，满足对任意$1 \\le i,j \\le t$，$a,b$,有$m'_i+c_a$与$m'_j+c_b$在模$r^3$的意义下不同余。\n可以观察到$m'_{t+1}+c_i \\equiv m'_s+c_j (\\mod r^3\\;)$，即$m'_{t+1} \\equiv m'_s+c_j-c_i (\\mod r^3\\;)$。\n\n\n我们可以令$m'_{t+1}$是$[0,r^3)$中最小的和所有$m'_s+c_j-c_i$不同余的数，这里$1 \\le s \\le t,1 \\le i,j \\le r$。\n\n由鸽巢原理，由于$t*r^2<r^3$，所以我们一定可以找到$m'_{t+1}$。\n\n故当$t+1 \\le s$时，结论对$t+1$成立\n由数学归纳法知结论对$s$成立，同时我们这里给出了一个暴力的$O( r^4 )$的构造算法（$r$轮，每轮最坏枚举$O( r^3 )$个位置）。\n\n## 5.融合：\n融合树的\"融合\"即指将每个节点上的key放到同一个$w-bit$的word上，通过对这个word进行运算来一起处理这些key。\n\n沿用之前$u_i$和$B(S)=\\{c_i\\}$的记号：\n\n我们这个B-Tree的每个节点存了$C=bin(c_1,...c_r)$和$M=bin(m_1,...,m_r)$这两个量，用于计算$u'(S)$，同时还存了$D=bin(c_1+m_1,...,c_r+m_r)$这个量，用于清空$u'(S)$的计算中不需要的位。\n\n同时还需要两个数组，存排序后的$u_i$和$u'_i$，和一个表$f[i][j][2]$表示引理$1$中，如果知道了$u_i$和$j$，还有$u$和$u_i$的大小关系，我们唯一确定的答案是多少。\n\n回顾之前的内容，当我们算出了$j=rank(K(S),u'(S))$后，如果$u$不在$[u_j,u_{j+1}]$的区间中，那么我们把$u'(S) \\;\\mathrm{XOR}\\; u'_j$和$u'(S) \\;\\mathrm{XOR}\\; u'_{j+1}$比较一下，较小的值所对应的$u'_h$，$h=j$或$j+1$，和$u$有更长的公共前缀，即$msb$更小。\n\n令$m=msb(u,u_h)$，然后我们需要知道$m$被哪个$B(S)$中的区间$[c_i,c_{i+1}]$包含，所以需要进行一次$i=rank(B(S),m)$的计算\n还需要进行一次$u$和$u_h$的比较，这个平凡，当这些都做完了，我们查一下表$f$即可得到$rank(S,u)$。\n\n可以发现fusion tree的每个内部节点需要存下$O( B^2 )$大小的表，内部节点个数是$O( n/B^4 )$个，所以是$O( n )$空间的。\n\n下面给出对\n\n1. $rank(K(S),u'(S))$\n\n2. $rank(B(S),m)$，其中$m$是在$[0,w]$中的整数\n\n3. 两个$w-bit$的整数$u,v$，$msb(u,v)$\n\n的计算方法：\n\n### $O(1)$计算$rank(K(S),u'(S))$：\n我们把每个$K(S)$中的元素前面补一个$1$，然后从小到大拼到一起来，这个拼起来的操作就是所谓的\"融合\"。\n\n由于我们$K(S)$中有$k$个元素，每个元素有$r^4$位，所以这里总共用了$k(r^4+1)$位，由于$B/2 \\le k \\le B$，所以我们总的位数是$O( B^5 )$的，由于$B=O( w^{1/5} )$，所以总的位数是$O( w )$的。\n\n所以我们拼起来的这个东西是$O( 1 )$个word的，这里将其定义为$A$。\n\n令$C=\\sum \\limits _{i = 0} ^ {B} 2^{(r^4+1)i}$\n通过$u'(S) \\times C$，可以将$u'(S)$前面补一个$0$之后复制$B$遍，然后拼到一起\n通过$A-u'(S) \\times C$，可以发现对每个$A$中补$1$的位置，其对应的那个$u_i(S)$如果$<u'(S)$，则这个$1$变成$0$，否则$1$不变\n所以我们通过$(A-u'(S) \\times C)\\&C$，然后对这个word数$1$的个数即可知道$rank(K(S),u'(S))$。\n\n由于这个word只在$2^{(r^4+1)i}$这样的位置有$1$，我们可以通过一次对$2^{r^4+1}-1$的取模来得到其中$1$的个数，虽然对常数取模可以用乘法和位运算$O(1)$实现，但我们这里可以给出一个更合适的构造。\n\n我们可以通过将其乘$C \\& (2^{(r^4+1)k}-1)$，这样相当于把其叠加了$k$次之后加起来，可以发现其中有一个长为$r^4+1$的段，这段的二进制表示的值等于这个word在$2^{(r^4+1)i}$这些位置的元素的和。\n\n通过位移和$\\mathrm{AND}$我们可以取出这个长$r^4+1$的段，于是就完成了。\n\n答案即$((((A-u'(S) \\times C) \\& C) \\times (C \\& (2^{(r^4+1)k}-1))) \\& C)>>((k(r^4+1)-1)$\n\n### $O(1)$计算$rank(B(S),m)$，$m$是在$[0,w]$中的整数：\n\n由于我们可以$O(1)$计算$rank(K(S),u'(S))$，所以把这个查出来然后判断那一个数的大小，并且进行一次查表即可。\n\n### $O(1)$计算$msb(u,v)$：\n等价于求$u \\;\\mathrm{XOR}\\; v$的最高位$1$的位置，设$A=u \\;\\mathrm{XOR}\\; v$。\n\n我们将$A$分为$r^c$大小的块，总共$r$块，这里$c$是一个常数,$c>1$\n令$C=(100...0100...0......)_2$，这里每两个$1$之间有$r-1$个$1$，$C$是一个常数。\n\n注意到：\n\n$((100...0)_2-0)\\&(1<<(r^c)-1)=(1<<(r^c)-1)$\n\n$((100...0)_2-y)\\&(1<<(r^c)-1)=0$，这里$y>0$\n\n先考虑对每个块去掉首位，块内是否有$1$。\n\n我们用$A\\& \\sim C$可以去掉每一块的首位。\n\n然后用$C-(A\\& \\sim C)$可以使得每一块中除首位外如果有$1$，则其在该块首位为$0$，否则为$1$。\n\n然后用$(C-(A\\& \\sim C))\\&C$去掉了$C-(A\\& \\sim C)$中每一块中除首位外的部分。\n\n然后用$(C-((C-(A\\& \\sim C))\\&C))$可以得到：如果一块中除首位外有$1$，则块首位为$1$，否则为$0$，且块首位外所有位置都是$0$的一个数\n再考虑对每个块只保留首位，块内是否有$1$。\n\n这个用$A\\&C$即可。\n\n最后$(A\\&C)|(C-((C-(A\\& \\sim C))\\&C))$可以得到：如果一块中有$1$，则块首位为$1$，否则为$0$，且块首位外所有位置都是$0$的一个数。\n\n令$D= \\sum \\limits _{k=0}^{r-1} 2^{k(r^c-1)}$，\n\n通过$(((A\\&C)|(C-((C-(A\\& \\sim C))\\&C))) \\times D)>>(w-r)$可以将每块首位的数字拼到一个长$r$的二进制数中。\n\n然后我们可以使用前面的$O(1)$计算$rank$的方法，令$B'(S)={2^i}$，$i$在$[0,r-1]$间，是整数。\n\n通过$rank(B'(S),(((A\\&C)|(C-((C-(A\\& \\sim C))\\&C))) \\times D)>>(w-r))$就可以得到这个长$r$的二进制数中第一个非0的首位的位置了。\n\n我们知道了第一个非$0$位在哪个块中，然后查这个块里面第一个非$0$位的位置就可以了。\n\n由于我们每个块是$r^c$的大小，所以对一个大小为$r^c$，包含了$2^i$的集合用一次rank即找到了块内第一个非$0$的首位位置。\n\n取$c=4,r=w^{1/5}$，$r^c=w^{4/5}$，我们便$O(1)$查询，$O(w^{4/5})$预处理时间复杂度解决了这个问题，由于预处理次数是$O( n/B^4 )$，所以这里也是线性的。\n\n综上所述，我们得到了一个单次操作复杂度$O( \\log n/\\log w + \\log w )$的数据结构，这里**据说**可以通过一些优化做到$O( \\log n/\\log w )$，但在这里由于我还没看所以暂时不做介绍。\n\n## 6.一些拓展\n如果我们允许下列中的一个：\n\n1. 放松线性空间的限制\n\n2. 保留线性空间的限制，但是使用随机化和整数除法\n\n那么我们可以得到一个$O( \\sqrt{ \\log n } )$的动态搜索的时间复杂度上界。\n\n当$n$超过$2^{(\\log w)^2/36}$时（这里$1/36$的常数是论文中给出的，由于我的部分细节和论文中不同，可能是不同的常数），\n\n对于1的case，可以通过使用vEB树来实现，对于2的case，可以通过使用Y-fast trie实现。\n\n对于这样的$n$，这两个数据结构可以在$O( \\log \\log U )=O( \\log w )=O( \\sqrt{\\log n} )$的时间完成一次搜索操作。\n\n当$n$小于这个数时，\n\n对于较小的$n$，我们使用fusion tree，通过调节$B=Θ(2^ {\\sqrt{\\log n}})$。\n\n在这个$B$下，我们的时间复杂度是$O( \\log n/\\log B + \\log B ) = O( \\sqrt{\\log n} )$。\n\n综上所述，如果引入随机化和整数除法，可以$O( n \\sqrt{\\log n} )$时间，线性空间整数排序。\n\n## 7.总结\n由信息论可以证明基于比较的排序下界是$\\Omega( n\\log n )$的，但整数排序其实是非常复杂的一个问题，还有待研究。", "description": "魔法森林里有一颗大树，下面经常有小孩召开法。\n\n大树可以看做一个有 $n$ 个节点，$n - 1$ 条边的无向连通图。大树的每个节点都有若干瓶矿泉水，初始第 $i$ 个节点有 $a_i$ 瓶矿泉水。\n\n麦杰斯住在大树顶端，有一天他想改造一下大树，方便他巨大多喝水之后可以垃圾分类矿泉水瓶。\n\n麦杰斯喜欢二进制运算，所以他会有以下三种操作：\n\n1. 将树上与一个节点 $x$ 距离为 $1$ 的节点上的矿泉水数量 $+1$。这里树上两点间的距离定义为从一点出发到另外一点的最短路径上边的条数。\n2. 在一个节点 $x$ 上喝掉 $v$ 瓶水。\n3. 询问树上与一个节点 $x$ 距离为 $1$ 的所有节点上的矿泉水数量的异或和。\n\n麦杰斯共有 $m$ 次操作，他希望你在每次 $3$ 操作后告诉他答案。", "inputFormat": "第一行两个正整数 $n,m$，分别表示树的节点个数和麦杰斯的询问个数。\n\n第二行到第 $n$ 行，每行两个整数表示有一条连接这两个节点的边。\n\n第 $n + 1$ 行 $n$ 个整数，第 $i$ 个整数表示初始第 $i$ 个节点上的矿泉水数量。\n\n第 $n + 2$ 行到第 $n + m + 1$ 行，每行先读入一个整数 $opt$ 表示操作类型。\n\n如果 $opt = 1$ 或 $3$ ，接下来读入一个整数 $x$ 表示麦杰斯操作的节点标号。\n\n否则接下来读入两个整数 $x, v$ 表示麦杰斯操作的节点标号和他喝的水的数量。", "outputFormat": "对于每一个 $3$ 操作，输出一行一个整数表示答案。", "hint": "Idea：dangxingyu，Solution：dangxingyu，Code：dangxingyu，Data：dangxingyu\n\n对于 $30\\%$ 的数据，满足 $n \\le 10^3$，$m\\le 10^3$。\n\n对于 $60\\%$ 的数据，满足 $n \\le 10^5$，$m \\le 10^5$。\n\n对于另外 $10\\%$ 的数据，存在一个点满足所有点到该节点的距离 $\\le 1$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n \\le 5\\times 10^5$，$1\\le m \\le 5\\times 10^5$，$0\\le a_i \\le 10^5$，$1 \\le x \\le n$，$opt\\in\\{1,2,3\\}$。\n\n保证任意时刻每个节点的矿泉水数非负。\n\n温馨提示：矿泉水瓶不是干垃圾也不是湿垃圾，而是可回收垃圾。\n", "locale": "zh-CN"}}}
{"pid": "P6019", "type": "P", "difficulty": 7, "samples": [["10 12\n6 9 9 4 7 8 10 4 9 2\n2 1 4\n1 0 5 0\n2 3 6\n2 10 9\n1 7 9 2\n2 7 9\n1 2 7 1\n1 2 11 4\n2 6 10\n1 3 12 0\n1 14 14 15\n2 7 12\n", "1\n3\n0\n3\n6\n16"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2010", "O2优化", "洛谷月赛", "Ynoi"], "title": "[Ynoi2010] Brodal queue", "background": "题目背景和题意无关，可以跳过\n\n## 1.前言：\nBrodal queue 在 1996 年由 Brodal 提出，是第一个满足每个操作都 worst case 而且达到了基于比较的堆的下界的数据结构\n\n这里给出的 Brodal queue 是一个小根堆\n\n该数据结构的一些特性：\n\n1. 维护了两棵树。\n\n2. Brodal queue 是一种 violation heap，即允许存在一些节点不满足堆性质。\n\n3. 实现真的很复杂，常数真的很大。\n\n## 2.一些记号：\nBrodal queue 维护了两棵树 $T1$ , $T2$，他们的根是 $t1$ 和 $t2$。\n\n定义：\n\n$p(x)$：$x$ 的父亲节点，默认 $x \\neq t1$ 且 $x \\neq t2$。\n\n$rank(x)$：和 $log( subtree\\;size )$ 相关的一个权值。\n\n$n(x,i)$：$x$ 的孩子中满足其 $rank$ 为 $i$ 的个数。\n\n$w(x,i)$：$W(x)$ 中 $rank$ 为 $i$ 的元素个数。\n\n$V$ 和 $W$ 列表：维护所有违反堆性质的节点。\n\n## 3.概述：\n每个曾经作为 $T1$ 的根的点都维护 $V$ 和 $W$，我们用 $V(x)$ 表示 $x$ 节点的 $V$ 集合，$W(x)$ 表示 $x$ 节点的 $W$ 集合。\n\n$V$ 维护的是 $rank \\ge rank(t1)$ 的节点，$W$ 维护的是 $rank<rank(t1)$ 的节点，这个是对插入当时的情况成立的，也就是说在经过结构修改操作之后不一定还满足这个性质。\n\n$V$ 是只加不删的， $W$ 是需要维护平衡的，所以只需要保证 $t1$ 的 $W$ 中的点的 $rank<rank(t1)$。\n\n有以下的一些性质：\n\n$rank$ 的性质：\n\nS1. 叶子节点的 $rank$ 为 $0$。\n\nS2. $rank(x) < rank( p(x) )$。\n\nS3. 如果 $rank(x) > 0$，则 $n(x,rank(x)-1) \\ge 2$。\n\nS4. $n(x,i)$ 只可能为 ${0,2,3,4,5,6,7}$ 中的元素。\n\nS5. 当 $T2 \\neq null$ 时 $rank(t1) \\leq rank(t2)$。\n\n解释：\n\nS1. 边界定义。\n\nS2. $rank$ 构成大根堆。\n\nS3. 一个点有至少两个孩子的 $rank$ 是其 $rank-1$，所以 $x$ 的子树大小关于 $x$ 的 $rank$ 至少是指数级的，所以 $rank$ 最多是 $O( \\log n )$ 的。\n\nS4. $n(x,i)$ 有 $O(1)$ 上界，非 $1$ ，而总共有 $O( \\log n )$ 种 $rank$，所以每个节点的度数都是 $O(\\log n )$ 的。\n\nS5. 要么 $T1$ 比 $T2$ 小，要么 $T2$ 为空。\n\n$V$ 和 $W$ 列表的性质：\n\nO1. $t1$ 是所有元素中的最小元。\n\nO2. 如果 $y$ 在 $V(x)$ 或者 $W(x)$ 中，则 $x \\leq y$，即这个元素在被插入列表时是违背了堆性质的。\n\nO3. 如果 $y<p(y)$ ，那么存在一个 $x$ 使得 $x \\neq y$，$y$ 属于 $V(x)$ 或 $W(x)$，即所有违背堆性质的节点都在某个节点的 $V$ 或 $W$ 列表中。\n\nO4. 对于所有 $x$，有 $w(x,i) \\leq 6$。\n\nO5. 记 $V(x) = (y_|V(x)|,...,y_2,y_1)$ , 则 $rank(y_i) \\ge floor((i-1)/α)$，$α$ 是一个常数。\n\n解释：\n\nO1. 我们要 $O(1)$ 求出最小值，所以规定了最小元是 $t1$。\n\nO2. $x$ 被插入的时候是被插到 $V(t1)$ 或者 $W(t1)$ 中。\n\nO3. 违反堆性质的点一定在另一个点的 $V$ 或者 $W$ 集合中。\n\nO4. $w(x,i)$ 有常数上界，所以 $V$ 和 $W$ 列表的大小是 $O( \\log n )$ 的。\n\nO5. $V$ 列表中的 $rank$ 有一个阶梯的下界。\n\n对于 $t1$，$t2$ 的额外性质：\n\nR1. 对 $i = 0 \\sim rank(tj) - 1$，有 $n(tj,i) \\ne 0$。\n\nR2. $|V(t1)| \\leq α \\times rank(t1)$ ，和前面提到的是同一个 $α$。\n\nR3. 如果 $y$ 属于 $W(t1)$ 则 $rank(y)<rank(t1)$。\n\n解释：\n\nR1. 对于 $t1$，$t2$，每个 $rank$ 的孩子至少有 $2$ 个。\n\nR2. $V(t1)$ 的大小 $|V(t1)|$ 有 $α \\times rank(t1)$ 的上界。\n\nR3. 属于 $W(t1)$ 的点比 $t1$ 小。\n\nR2+O5可以推出如果 $t1$ 的 $rank$ 增大 $1$ ，我们就可以增加 $α$ 个大的违反堆性质的节点，把他们加入 $V(t1)$，并且不违反 $O5$。\n\n每次 DECREASEKEY 时 ，我们直接加一个新的违反堆性质的点到 $V(t1)$ 或者$W(t1)$。\n\n为了避免有太多的违反堆性质的节点，我们递增地做两种不同的变换，主要为了维护 R2 和 O4 性质。\n\n第一种：把 $t2$ 的儿子移动进入 $T1$ ，变成 $t1$ 的孩子，使得 $rank(t1)$ 变大。\n\n第二种：通过把 $2$ 个 $rank$ 为 $k$ 的违反堆性质的节点换成了 $\\leq 1$个$rank$ 为 $k+1$ 的违反堆性质的节点，从而减少 $W(t1)$ 的大小。\n\nNote：我们这里用到了很多可变长数组，默认可变长数组是严格 $O(1)$ 的，这个是平凡的所以不详细讲怎么实现了。\n\n这里给出了一个作者称为 guide 的数据结构的实现。\n\n## 4.Guide Data Structure：\n\n用途：维护 $R1$，$O4$ 性质，即对 $n(t1,i),n(t2,i),w(t1,i)$ 的上界进行维护，大概是一个维护 $O(1)$ 进位的东西。\n\n抽象出这部分要维护的东西，也就是我们这里讲的 guide 数据结构是要维护什么：\n\n维护：一个长为 $k$ 的 int 数组，$x_k,x_{k-1},...x_1$ （这里我们从右往左写序列）。\n\n需要满足：$max(x_i) \\leq T$ , $T$ 是预设的一个阈值常数。\n\n我们只能在这个数组上实现 REDUCE(i) 的操作，即 $x_i$ 至少减少 $2$，$x_{i+1}$ 至多增加 $1$（实际上这里我们 $x_i$ 只能减少 $2$ 或者 $3$，$x_{i+1}$ 只能增加 $0$ 或者 $1$）。\n\n每次可能发生对一个任意位置 $i$ 的 $x_i$ 的 $+1$ 或者 $-1$ 操作，每次操作之后我们被允许通过 $O(1)$ 次 REDUCE 操作，使得我们需要维护的数组仍旧满足性质。\n\nguide 干的事情就是 guide（向导） ，也就是说告诉我们要做什么样的 REDUCE 操作使得这个数组仍旧满足性质。\n\n定义 $x'$ 是 $[T-2,T]$ ，当 $x_i$ 碰到进入 $x'$ 的范围之前我们不考虑对其进行调整。\n\n不妨设 $T=2$，我们对 $T=2$ 维护这个 guide 即可。\n\n把原序列分成一些块，考虑形如 $2$ $1*$ $0$ 这样的连续段，不在段内的元素只可能是单独的 $0$ 或 $1$。\n\n对每个块我们新建一个节点，然后段内的每个元素都指向这个节点。\n\n每个节点上记录块的开头位置。\n\n不在块内的节点直接指向一个 null。\n\n这里我们多个点共用一个 null ，存在多个 null。\n\n有两个重要的性质：\n\n1. 给一个位置 $x$ ，我们可以最坏复杂度 $O(1)$ 找到 $x$ 所属于的块内最左边的元素，\n并且——\n\n2. 我们可以最坏复杂度 $O(1)$ 销毁掉一个给定的块，直接把那个存有值的点改成 null 即可。\n\n这里写一下变换是如何实现的，由于是按照自己的理解写的，所以可能和原论文\n有出入。\n\n注意到我们可以 $O(1)$ 拆掉一个块。\n\n前驱不在块内：\n\n```\ncase1：\n\n0 0\n\n0 1\n\ntrivial\n```\n```\ncase2：\n\n0 1\n\n0 2\n\n1 1\n\ntrivial\n\n```\n```\ncase3:\n\n0 [2 1* 0]\n\n0 [3 1* 0]\n\n1 [1 1* 0]\n\n拆掉这个块\n\n1 1 1* 0\n```\n```\ncase4:\n\n1 0\n\n1 1\n\ntrivial\n```\n```\ncase5:\n\n1 1\n\n1 2\n\n[2 0]\n\ntrivial\n```\n```\ncase6:\n\n1 [2 1* 0]\n\n1 [3 1* 0]\n\n2 [1 1* 0]\n\n[2 1 1* 0]\n```\n前驱是块尾：\n```\ncase7:\n\n[2 1* 0] 0\n\n[2 1* 0] 1\n\ntrivial\n```\n```\ncase8:\n\n[2 1* 0] 1\n\n[2 1* 0] 2\n\n[2 1* 1] 0\n\n[2 1* 1 0]\n```\n```\ncase9:\n\n[2 1* 0] [2 1* 0]\n\n[2 1* 0] [3 1* 0]\n\n[2 1* 1] [1 1* 0]\n\n拆后面的块\n\n[2 1* 1] 1 1* 0\n\n拆前面的块\n\n2 1* 1 1 1* 0\n\n递归成块外的1加1的情况case 2,5,8\n```\n前驱在块内：\n```\ncase10:\n\n[2 1* 0]\n\n[2 1* 1]\n\n拆块\n\n2 1* 1\n\n递归成块外的1加1的情况case 2,5,8\n```\n```\ncase11:\n\n[2 1* 1 1* 0]\n\n[2 1* 2 1* 0]\n\n拆部分块，通过把指针指到第二个2的位置\n\n2 1* [2 1* 0]\n\n递归成块外的1加1的情况case 2,5,8\n```\n\n注意到这里 $2$ 是单调向右走的，除了每次操作可能可以往左边走一格，所以把一个块端点往右移动一段，或者向左移动 $O(1)$ 个位置是可行的。\n\n加个内存池，我们需要的空间不超过 $O(k)$。\n\n（*可能可以四毛子优化一下？）\n\n## 5.link 和 delink\n\n这个是两个基本操作，用于调节 Brodal queue。\n\nlink：\n\n假设我们有 $3$ 个节点 $x_1,x_2,x_3$ ，这三个节点不是根，且有相同的 $rank$。\n\n经过 $O(1)$ 次比较之后，不妨我们设 $x_1$ 是这三个中最小的。\n\n然后我们可以把 $x_2$，$x_3$ 变成 $x_1$ 的最左儿子（因为是链表，只能在头插入），并且 $x_1$ 的 $rank$ 自增 $1$。\n\n然后 $x_2$ 和 $x_3$ 都不是违反堆性质的节点，并且 $x_1$ 仍然满足所有 S1-S5 和 O1-O5 的性质。\n\ndelink：\n\n对一个点 $x$ ，如果 $n(x,rank(x)-1)$ 是 $2$ 或者 $3$，那么把 $x$ 的 $rank$ 为 $rank(x)-1$ 的孩子和父亲的边断开，把它\"切出来\"，然后 $rank(x)$ 变成剩余孩子中的 $max(rank)+1$，这里切出来之后怎么办需要特殊说明。\n\n如果 $n(x,rank(x)-1) \\ge 4$，那么把 $2$ 个 $rank$ 为 $rank(x)-1$ 的孩子切出来。\n\ndelink 一个根节点的 $rank$ 为 $k$ 的树总是会得到 $2$ 或者 $3$ 个根节点的$rank$ 为 $k-1$ 的树，和一个额外的根节点的 $rank \\leq k$ 的树（这个树根节点的 $rank$ 可以是 $[0,k]$ 的任意数）。\n\n考虑如何维护 $t1$ 的孩子，使其满足R1（ $t1$ 对于 $[0,rank(t1)-1]$ 中每个 $rank$ 有$[2,7]$个孩子）。\n\n对 $[0,rank(t1)-3]$ 中每个 $rank$ 的孩子个数，使用两个guide，一个处理个数在 $[2,4]$ 的孩子保证其个数 $ \\ge 2$，一个处理个数在 $[5,7]$ 的孩子保证其个数 $\\leq 7$。\n\n对于 $rank$ 为 $rank(t1)-1$ 和 $rank(t1)-2$ 的孩子需要特判处理。\n\n\n\n对 $t1$ 的孩子用两个 guide 来维护,设其为 guide1 和 guide2。\n\nguide1 维护的是 $rank$ 在 $[T-2,T]$ 中的孩子，guide2 维护的是 $rank$ 在$[2,4]$ 中的孩子，这里我们令 $T=9$，是一个常数。\n\n我们用 guide 中的元素 $a_k$ 代指这个 guide 里面 $rank$ 为 $k$ 的节点个数。\n\nlink 操作会让 guide1 里面的一个元素 $a_k$ 减少 $3$ , 另一个元素 $a_{k+1}$ 增加 $1$ ，注意到这里我们维护的是一个上界的形式，所以减少 $3$ 和减少 $2$是类似的。\n\ndelink 操作会让 guide2 里面的一个元素 $a_k$ 减少 $1$, $a_{k-1}$ 增加 $2$ 或 $3$ , 还会多出一个 $rank$ 在 $[0,k]$ 中的元素，这里维护的是下界形式，所以只用考虑 $+2$。\n\n注：这里其实 $-3$ 会比 $-2$ 容易破坏下界，$+3$ 会比 $+2$容易破坏上界，把 $T$ 改成 $10$ ，或者加一些特判之后这个问题可以被解决，所以不专门讨论这两种情况了。\n\n注：这里原论文给的界是 $T=7$ ，但是我们不知道如何达成，所以在这里讲$T=9$ 的情况。\n\n$t1$ 新增孩子：\n\n如果导致同 $rank$ 的孩子数 $=9$ ，则从处理上界的 guide 得到需要执行的 $O(1)$ 次 reduce 操作（这导致了 guide 的实现的微小变化），对应于用 link 合并 $3$ 个 $rank$为 $k$ 的孩子，得到 $1$ 个 $rank$ 为 $k+1$ 的孩子。\n\n注意此时孩子数减少 $3$ 后变成 $6 > 4$ ，不影响处理下界的 guide。\n\n如果这导致 $rank$ 为 $rank(t1)-2$，$rank(t1)-1$ 的孩子过多，同样用 link 操作进行调整，这时就可能需要增加 $t1$ 的 $rank$ 了。\n\n这里由于我们每次都是把\"切出来\"的节点变成 $t1$ 的孩子，所以不产生额外的违反堆性质的节点。\n\n$t1$ 删除孩子：\n\n类似于新增孩子，但此时 reduce 对应于 delink 操作（这里只考虑 $rank=k$ 的树变为 $rank=k-1$ 的 $2$ 或 $3$ 棵树），delink 产生的额外的 rank 不固定的树会在删除孩子完成之后被新增为 $t1$ 的孩子。\n\n关于这里的常数 $T$ 的解释：\n\n我们考虑一个 guide 中维护的元素到了和这个 guide 的界差 $1$ 的情况才需要\n REDUCE ，不然不需要。\n\n对于 guide1，这个界限就是 $T-1$，对于 guide2，这个界限就是 $3$。\n\n然后我们要让这次 REDUCE 之后不会导致另一个 guide 需要调整。\n\n所以 $T-1\\;-\\;3 > 4$，$3 + 3 < T-2$，可以解出 $T > 8$，故取 $T=9$。\n\n这里和原论文的 $T=7$ 不一样，但也只是常数差别，不会对复杂度和正确性产生影响，所以不仔细讨论这个了。\n\n对于 $t2$ 的新增/删除孩子，情况和 $t1$ 类似，不同之处是 delink 产生了 $O(1)$ 个新的破坏堆性质的点，这部分的详细内容会在后面提到。\n\n定义 $pv$ 集合为 $V$ 集合和 $W$ 集合的并集，即潜在的违反堆性质的点的集合。\n\n设计一个变换，用于减少 $pv$：\n\n这一段是 $W(t1)$ 的 guide 的 REDUCE 的方法，这个变换将 $pv$ 减少了至少 $1$：\n\n假设 $x1,x2$ 是潜在的违反堆性质的点，满足 $k=rank(x1)=rank(x2)<rank(t1)$，且 $x1,x2$不是根或根的孩子。\n\n首先检查 $x1,x2$ 是否满足堆性质，若满足则从 $V$ 或 $W$ 列表中移除，否则：\n\n若 $x1,x2$ 不是兄弟：\n\n不失一般性，设 $p(x1) \\leq p(x2)$，交换 $x1$ 所在子树和 $x2$ 的某个$rank=k$ 的兄弟 $x3$（由 S4 性质可知这样的 $x3$ 一定存在）所在子树（此操作不会增加 $pv$，$x1$ 仍是 $pv$，$x3$ 可能从 $pv$ 变为非 $pv$ 也可能状态不变），之后可设 $y=p(x1)=p(x2)$。\n\n若存在 $rank=k$ 的第三个兄弟，则将 $x1$ 移除并新增为 $t1$的孩子，这样 $y$ 的 $rank=k$ 的儿子减少了一个，而且至少为 $2$ 个，不违反 S4 性质。\n\n若不存在 $rank=k$ 的第三个兄弟，则将 $x1,x2$ 移除并新增为 $t1$ 的孩子，这样 $y$ 的 $rank=k$ 的儿子个数变成 $0$ 了，不违反 S4 性质。\n\n若 $rank(y)=k+1$ 则还需要移除 $y$，更新 $y$ 的 $rank$，并新增 $y$ 为 $t1$的孩子，$y$ 子树原先的位置被从 $t1$ 移除的一个 $rank=k+1$ 的子树代替。\n\n（这可能增加一个违反堆性质的点（需要加入 $W(t1)$ 中），但同时 $x1,x2$ \n 由于父亲变成了 $t1$，所以将符合堆性质），这里还需要对 $W(t1)$ 的 guide 进行一个 $rank=k+1$ 的位置 $+1$ 的操作。\n\n所以至少减少 $2$ 个 $pv$ 中的点，至多增加 $1$ 个点到 $pv$ 中。\n\n（由于 S2 性质保证了等 $rank$ 替换时，被替换的点和用于替换的点没有祖先关系，因此不会成环）\n\n避免过多的违反堆性质的点出现：\n\n当新增一个违反堆性质的点 $x$ 时，若 $rank(x) \\ge rank(t1)$ 则将其加入到 $V(t1)$ 中，否则加入到 $W(t1)$ 中。\n\n对 $W(t1)$ 也开个 guide，里面第 $i$ 个元素就是 $w(t1,i)$。\n\n向 $W(t1)$ 加点时，插入一个点 $k$ 时，让 guide 中的第 $k$ 个元素 $+1$，然后通过 guide 得到需要进行的 reduce(k) 操作。\n\n在 $w(t1,k)=6$，且其中至少 $2$ 个不是 $t2$ 的孩子时，执行上述变换减少 $pv$。\n\n若有超过 $4$ 个是 $t2$ 的孩子，则将多出的点切下并新增为 $t1$ 的孩子（这不影响 $W(t2)$ 的 guide）。\n\n每次进行优先队列操作时：\n\n若 $T2$ 非空，则通过将 $O(1)$ 个孩子从 $t2$ 移到 $t1$，使 $t1$ 的 $rank$ 增加至少 $1$，这使得我们可以支付 $V(t1)$ 新增的不超过 $α$ 个 $pv$。\n\n具体地，若 $rank(t2) \\leq rank(t1)+2$，则把 $t2$ 的 $rank$ 最大的孩子切下并新增为 $t1$ 的孩子，最终当 $t2$ 没有孩子的时候，把 $t2$ 新增为 $t1$ 的孩子。\n\n若 $rank(t2)>rank(t1)+2$，则切下 $t2$ 的一个 $rank$ 为 $rank(t1)+2$ 的孩子，将其delink并新增为 $t1$ 的孩子。\n\n若 $T2$ 为空，则 $V(t1)$ 不会有新增的 $pv$。\n\n## 6.抽象数据结构\n对于一个抽象数据结构——优先队列，我们可以使用 Brodal queue 实现，具体进行的操作为：\n```\nMakeQueue：T1=T2=null\n```\n```\nFindMin(Q): return t1\n```\n```\nInsert(Q,e): 转为Meld(Q,{T1=e,T2=null})\n```\n\n```\nMeld(Q1,Q2):\n\n不失一般性，设 $Q1.t1<Q2.t1$。\n\n若 Q1.T1 的 rank 最大，则把其余的 $3$ 棵树新增为 Q1.t1 的孩子，Q1.T2 设为空，这个过程中不产生新的 $pv$\n\n否则让 Q1.T2，Q2.T2 中 rank 最大的树成为新的 Q1.T2，其余的 $2$ 棵树新增为 Q1.t2 的孩子。\n```\n\n解释：如果 $min$ 所在的那个树的 $rank$ 是这四个里面最大的，那就把其他几个树都插入到 $min$ 所在的那个树的孩子里面，新的树里面 $T2$ 为空\n\n否则 $rank$ 最大的那个树成为新的 $T2$，除了 $min$ 所在的树都插入这个的孩子里面，$min$ 所在的树成为 $T1$\n\n\n```\nDecreaseKey(Q,e,e'):\n\n修改权值后检查是否违反堆性质\n\n如果违反堆性质，则将其加入pv中，此时pv大小+1\n\n然后按前文避免过多的违反堆性质的点出现的方法来让pv减少至少1，使得pv大\n小平衡\n```\n```\nDeleteMin(Q):\n\n将 t2 的孩子（O(log n) 个）全部切下，新增为 t1 的孩子；将 t2 变为 t1 的孩子；\n\n删除 t1 得到 t1 的孩子，总共有 O(log n) 个。\n\n遍历 t1 的孩子，V(t1) 和 W(t1)，从而得到新的最小值t1'\n\n若 t1' 不是 t1 的孩子，则与等 rank 的孩子交换，这可能产生 O(1) 个 pv。\n\n然后将 V(t1),V(t1'),W(t1),W(t1') 合并为 W(t1')：\n\n先将 V(t1') 置为空，然后使用变换令 w(t1',i)<=1，最后使 t1' 成为新的 t1\n```\n\n```\nDelete(Q),e: 转为DecreaseKey(Q,e,-inf),DeleteMin(Q)\n```", "description": "给定一个长为 $n$ 的序列 $a$ ，每个位置有一种颜色，有 $m$ 次操作，支持：\n\n`1 l r x`：区间 $[l,r]$ 的数都变成 $x$。\n\n`2 l r`：查询有多少二元组 $(i,j)$ 满足 $l \\leq i < j \\leq r$ ，且 $a_i = a_j$。\n\n本题强制在线，每次的 $l,r,x$ 需要 $\\operatorname{xor}$ 上（上次答案 $\\bmod 2^{32}$），也就是说使用 `unsigned int` 数据类型存储上次的答案即可，如果之前没有询问，则上次答案为 $0$。这里输出的答案不对 $\\bmod 2^{32}$ 取模。", "inputFormat": "第一行两个整数 $n, m$。\n\n第二行 $n$ 个整数表示序列 $a$。\n\n之后 $m$ 行，每行形如 `1 l r x` 或 `2 l r`，表示上述的操作。", "outputFormat": "对于每个 $2$ 操作，输出一行一个整数表示答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477&ccz181078，Code：ccz181078，Data：nzhtl1477\n\n注意：本题采用**捆绑测试**，只有当你通过一个 subtask 中的所有测试点后，你才能拿到这个 subtask 的分数。\n\n对于其中 $1\\%$ 的数据，为样例 1。\n\n对于另外 $9\\%$ 的数据，没有修改操作。\n\n对于另外 $19\\%$ 的数据，$n,m\\leq 500$。\n\n对于另外 $19\\%$ 的数据，每次修改的区间长度不超过 $5$。\n\n对于另外 $19\\%$ 的数据，保证数据随机。\n\n对于 $100\\%$ 的数据，$1\\leq n,m\\leq 2\\times 10^5$，$1\\leq a_{i},x\\leq n$，$1\\leq l\\leq r\\leq n$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2010] Brodal queue", "background": "题目背景和题意无关，可以跳过\n\n## 1.前言：\nBrodal queue 在 1996 年由 Brodal 提出，是第一个满足每个操作都 worst case 而且达到了基于比较的堆的下界的数据结构\n\n这里给出的 Brodal queue 是一个小根堆\n\n该数据结构的一些特性：\n\n1. 维护了两棵树。\n\n2. Brodal queue 是一种 violation heap，即允许存在一些节点不满足堆性质。\n\n3. 实现真的很复杂，常数真的很大。\n\n## 2.一些记号：\nBrodal queue 维护了两棵树 $T1$ , $T2$，他们的根是 $t1$ 和 $t2$。\n\n定义：\n\n$p(x)$：$x$ 的父亲节点，默认 $x \\neq t1$ 且 $x \\neq t2$。\n\n$rank(x)$：和 $log( subtree\\;size )$ 相关的一个权值。\n\n$n(x,i)$：$x$ 的孩子中满足其 $rank$ 为 $i$ 的个数。\n\n$w(x,i)$：$W(x)$ 中 $rank$ 为 $i$ 的元素个数。\n\n$V$ 和 $W$ 列表：维护所有违反堆性质的节点。\n\n## 3.概述：\n每个曾经作为 $T1$ 的根的点都维护 $V$ 和 $W$，我们用 $V(x)$ 表示 $x$ 节点的 $V$ 集合，$W(x)$ 表示 $x$ 节点的 $W$ 集合。\n\n$V$ 维护的是 $rank \\ge rank(t1)$ 的节点，$W$ 维护的是 $rank<rank(t1)$ 的节点，这个是对插入当时的情况成立的，也就是说在经过结构修改操作之后不一定还满足这个性质。\n\n$V$ 是只加不删的， $W$ 是需要维护平衡的，所以只需要保证 $t1$ 的 $W$ 中的点的 $rank<rank(t1)$。\n\n有以下的一些性质：\n\n$rank$ 的性质：\n\nS1. 叶子节点的 $rank$ 为 $0$。\n\nS2. $rank(x) < rank( p(x) )$。\n\nS3. 如果 $rank(x) > 0$，则 $n(x,rank(x)-1) \\ge 2$。\n\nS4. $n(x,i)$ 只可能为 ${0,2,3,4,5,6,7}$ 中的元素。\n\nS5. 当 $T2 \\neq null$ 时 $rank(t1) \\leq rank(t2)$。\n\n解释：\n\nS1. 边界定义。\n\nS2. $rank$ 构成大根堆。\n\nS3. 一个点有至少两个孩子的 $rank$ 是其 $rank-1$，所以 $x$ 的子树大小关于 $x$ 的 $rank$ 至少是指数级的，所以 $rank$ 最多是 $O( \\log n )$ 的。\n\nS4. $n(x,i)$ 有 $O(1)$ 上界，非 $1$ ，而总共有 $O( \\log n )$ 种 $rank$，所以每个节点的度数都是 $O(\\log n )$ 的。\n\nS5. 要么 $T1$ 比 $T2$ 小，要么 $T2$ 为空。\n\n$V$ 和 $W$ 列表的性质：\n\nO1. $t1$ 是所有元素中的最小元。\n\nO2. 如果 $y$ 在 $V(x)$ 或者 $W(x)$ 中，则 $x \\leq y$，即这个元素在被插入列表时是违背了堆性质的。\n\nO3. 如果 $y<p(y)$ ，那么存在一个 $x$ 使得 $x \\neq y$，$y$ 属于 $V(x)$ 或 $W(x)$，即所有违背堆性质的节点都在某个节点的 $V$ 或 $W$ 列表中。\n\nO4. 对于所有 $x$，有 $w(x,i) \\leq 6$。\n\nO5. 记 $V(x) = (y_|V(x)|,...,y_2,y_1)$ , 则 $rank(y_i) \\ge floor((i-1)/α)$，$α$ 是一个常数。\n\n解释：\n\nO1. 我们要 $O(1)$ 求出最小值，所以规定了最小元是 $t1$。\n\nO2. $x$ 被插入的时候是被插到 $V(t1)$ 或者 $W(t1)$ 中。\n\nO3. 违反堆性质的点一定在另一个点的 $V$ 或者 $W$ 集合中。\n\nO4. $w(x,i)$ 有常数上界，所以 $V$ 和 $W$ 列表的大小是 $O( \\log n )$ 的。\n\nO5. $V$ 列表中的 $rank$ 有一个阶梯的下界。\n\n对于 $t1$，$t2$ 的额外性质：\n\nR1. 对 $i = 0 \\sim rank(tj) - 1$，有 $n(tj,i) \\ne 0$。\n\nR2. $|V(t1)| \\leq α \\times rank(t1)$ ，和前面提到的是同一个 $α$。\n\nR3. 如果 $y$ 属于 $W(t1)$ 则 $rank(y)<rank(t1)$。\n\n解释：\n\nR1. 对于 $t1$，$t2$，每个 $rank$ 的孩子至少有 $2$ 个。\n\nR2. $V(t1)$ 的大小 $|V(t1)|$ 有 $α \\times rank(t1)$ 的上界。\n\nR3. 属于 $W(t1)$ 的点比 $t1$ 小。\n\nR2+O5可以推出如果 $t1$ 的 $rank$ 增大 $1$ ，我们就可以增加 $α$ 个大的违反堆性质的节点，把他们加入 $V(t1)$，并且不违反 $O5$。\n\n每次 DECREASEKEY 时 ，我们直接加一个新的违反堆性质的点到 $V(t1)$ 或者$W(t1)$。\n\n为了避免有太多的违反堆性质的节点，我们递增地做两种不同的变换，主要为了维护 R2 和 O4 性质。\n\n第一种：把 $t2$ 的儿子移动进入 $T1$ ，变成 $t1$ 的孩子，使得 $rank(t1)$ 变大。\n\n第二种：通过把 $2$ 个 $rank$ 为 $k$ 的违反堆性质的节点换成了 $\\leq 1$个$rank$ 为 $k+1$ 的违反堆性质的节点，从而减少 $W(t1)$ 的大小。\n\nNote：我们这里用到了很多可变长数组，默认可变长数组是严格 $O(1)$ 的，这个是平凡的所以不详细讲怎么实现了。\n\n这里给出了一个作者称为 guide 的数据结构的实现。\n\n## 4.Guide Data Structure：\n\n用途：维护 $R1$，$O4$ 性质，即对 $n(t1,i),n(t2,i),w(t1,i)$ 的上界进行维护，大概是一个维护 $O(1)$ 进位的东西。\n\n抽象出这部分要维护的东西，也就是我们这里讲的 guide 数据结构是要维护什么：\n\n维护：一个长为 $k$ 的 int 数组，$x_k,x_{k-1},...x_1$ （这里我们从右往左写序列）。\n\n需要满足：$max(x_i) \\leq T$ , $T$ 是预设的一个阈值常数。\n\n我们只能在这个数组上实现 REDUCE(i) 的操作，即 $x_i$ 至少减少 $2$，$x_{i+1}$ 至多增加 $1$（实际上这里我们 $x_i$ 只能减少 $2$ 或者 $3$，$x_{i+1}$ 只能增加 $0$ 或者 $1$）。\n\n每次可能发生对一个任意位置 $i$ 的 $x_i$ 的 $+1$ 或者 $-1$ 操作，每次操作之后我们被允许通过 $O(1)$ 次 REDUCE 操作，使得我们需要维护的数组仍旧满足性质。\n\nguide 干的事情就是 guide（向导） ，也就是说告诉我们要做什么样的 REDUCE 操作使得这个数组仍旧满足性质。\n\n定义 $x'$ 是 $[T-2,T]$ ，当 $x_i$ 碰到进入 $x'$ 的范围之前我们不考虑对其进行调整。\n\n不妨设 $T=2$，我们对 $T=2$ 维护这个 guide 即可。\n\n把原序列分成一些块，考虑形如 $2$ $1*$ $0$ 这样的连续段，不在段内的元素只可能是单独的 $0$ 或 $1$。\n\n对每个块我们新建一个节点，然后段内的每个元素都指向这个节点。\n\n每个节点上记录块的开头位置。\n\n不在块内的节点直接指向一个 null。\n\n这里我们多个点共用一个 null ，存在多个 null。\n\n有两个重要的性质：\n\n1. 给一个位置 $x$ ，我们可以最坏复杂度 $O(1)$ 找到 $x$ 所属于的块内最左边的元素，\n并且——\n\n2. 我们可以最坏复杂度 $O(1)$ 销毁掉一个给定的块，直接把那个存有值的点改成 null 即可。\n\n这里写一下变换是如何实现的，由于是按照自己的理解写的，所以可能和原论文\n有出入。\n\n注意到我们可以 $O(1)$ 拆掉一个块。\n\n前驱不在块内：\n\n```\ncase1：\n\n0 0\n\n0 1\n\ntrivial\n```\n```\ncase2：\n\n0 1\n\n0 2\n\n1 1\n\ntrivial\n\n```\n```\ncase3:\n\n0 [2 1* 0]\n\n0 [3 1* 0]\n\n1 [1 1* 0]\n\n拆掉这个块\n\n1 1 1* 0\n```\n```\ncase4:\n\n1 0\n\n1 1\n\ntrivial\n```\n```\ncase5:\n\n1 1\n\n1 2\n\n[2 0]\n\ntrivial\n```\n```\ncase6:\n\n1 [2 1* 0]\n\n1 [3 1* 0]\n\n2 [1 1* 0]\n\n[2 1 1* 0]\n```\n前驱是块尾：\n```\ncase7:\n\n[2 1* 0] 0\n\n[2 1* 0] 1\n\ntrivial\n```\n```\ncase8:\n\n[2 1* 0] 1\n\n[2 1* 0] 2\n\n[2 1* 1] 0\n\n[2 1* 1 0]\n```\n```\ncase9:\n\n[2 1* 0] [2 1* 0]\n\n[2 1* 0] [3 1* 0]\n\n[2 1* 1] [1 1* 0]\n\n拆后面的块\n\n[2 1* 1] 1 1* 0\n\n拆前面的块\n\n2 1* 1 1 1* 0\n\n递归成块外的1加1的情况case 2,5,8\n```\n前驱在块内：\n```\ncase10:\n\n[2 1* 0]\n\n[2 1* 1]\n\n拆块\n\n2 1* 1\n\n递归成块外的1加1的情况case 2,5,8\n```\n```\ncase11:\n\n[2 1* 1 1* 0]\n\n[2 1* 2 1* 0]\n\n拆部分块，通过把指针指到第二个2的位置\n\n2 1* [2 1* 0]\n\n递归成块外的1加1的情况case 2,5,8\n```\n\n注意到这里 $2$ 是单调向右走的，除了每次操作可能可以往左边走一格，所以把一个块端点往右移动一段，或者向左移动 $O(1)$ 个位置是可行的。\n\n加个内存池，我们需要的空间不超过 $O(k)$。\n\n（*可能可以四毛子优化一下？）\n\n## 5.link 和 delink\n\n这个是两个基本操作，用于调节 Brodal queue。\n\nlink：\n\n假设我们有 $3$ 个节点 $x_1,x_2,x_3$ ，这三个节点不是根，且有相同的 $rank$。\n\n经过 $O(1)$ 次比较之后，不妨我们设 $x_1$ 是这三个中最小的。\n\n然后我们可以把 $x_2$，$x_3$ 变成 $x_1$ 的最左儿子（因为是链表，只能在头插入），并且 $x_1$ 的 $rank$ 自增 $1$。\n\n然后 $x_2$ 和 $x_3$ 都不是违反堆性质的节点，并且 $x_1$ 仍然满足所有 S1-S5 和 O1-O5 的性质。\n\ndelink：\n\n对一个点 $x$ ，如果 $n(x,rank(x)-1)$ 是 $2$ 或者 $3$，那么把 $x$ 的 $rank$ 为 $rank(x)-1$ 的孩子和父亲的边断开，把它\"切出来\"，然后 $rank(x)$ 变成剩余孩子中的 $max(rank)+1$，这里切出来之后怎么办需要特殊说明。\n\n如果 $n(x,rank(x)-1) \\ge 4$，那么把 $2$ 个 $rank$ 为 $rank(x)-1$ 的孩子切出来。\n\ndelink 一个根节点的 $rank$ 为 $k$ 的树总是会得到 $2$ 或者 $3$ 个根节点的$rank$ 为 $k-1$ 的树，和一个额外的根节点的 $rank \\leq k$ 的树（这个树根节点的 $rank$ 可以是 $[0,k]$ 的任意数）。\n\n考虑如何维护 $t1$ 的孩子，使其满足R1（ $t1$ 对于 $[0,rank(t1)-1]$ 中每个 $rank$ 有$[2,7]$个孩子）。\n\n对 $[0,rank(t1)-3]$ 中每个 $rank$ 的孩子个数，使用两个guide，一个处理个数在 $[2,4]$ 的孩子保证其个数 $ \\ge 2$，一个处理个数在 $[5,7]$ 的孩子保证其个数 $\\leq 7$。\n\n对于 $rank$ 为 $rank(t1)-1$ 和 $rank(t1)-2$ 的孩子需要特判处理。\n\n\n\n对 $t1$ 的孩子用两个 guide 来维护,设其为 guide1 和 guide2。\n\nguide1 维护的是 $rank$ 在 $[T-2,T]$ 中的孩子，guide2 维护的是 $rank$ 在$[2,4]$ 中的孩子，这里我们令 $T=9$，是一个常数。\n\n我们用 guide 中的元素 $a_k$ 代指这个 guide 里面 $rank$ 为 $k$ 的节点个数。\n\nlink 操作会让 guide1 里面的一个元素 $a_k$ 减少 $3$ , 另一个元素 $a_{k+1}$ 增加 $1$ ，注意到这里我们维护的是一个上界的形式，所以减少 $3$ 和减少 $2$是类似的。\n\ndelink 操作会让 guide2 里面的一个元素 $a_k$ 减少 $1$, $a_{k-1}$ 增加 $2$ 或 $3$ , 还会多出一个 $rank$ 在 $[0,k]$ 中的元素，这里维护的是下界形式，所以只用考虑 $+2$。\n\n注：这里其实 $-3$ 会比 $-2$ 容易破坏下界，$+3$ 会比 $+2$容易破坏上界，把 $T$ 改成 $10$ ，或者加一些特判之后这个问题可以被解决，所以不专门讨论这两种情况了。\n\n注：这里原论文给的界是 $T=7$ ，但是我们不知道如何达成，所以在这里讲$T=9$ 的情况。\n\n$t1$ 新增孩子：\n\n如果导致同 $rank$ 的孩子数 $=9$ ，则从处理上界的 guide 得到需要执行的 $O(1)$ 次 reduce 操作（这导致了 guide 的实现的微小变化），对应于用 link 合并 $3$ 个 $rank$为 $k$ 的孩子，得到 $1$ 个 $rank$ 为 $k+1$ 的孩子。\n\n注意此时孩子数减少 $3$ 后变成 $6 > 4$ ，不影响处理下界的 guide。\n\n如果这导致 $rank$ 为 $rank(t1)-2$，$rank(t1)-1$ 的孩子过多，同样用 link 操作进行调整，这时就可能需要增加 $t1$ 的 $rank$ 了。\n\n这里由于我们每次都是把\"切出来\"的节点变成 $t1$ 的孩子，所以不产生额外的违反堆性质的节点。\n\n$t1$ 删除孩子：\n\n类似于新增孩子，但此时 reduce 对应于 delink 操作（这里只考虑 $rank=k$ 的树变为 $rank=k-1$ 的 $2$ 或 $3$ 棵树），delink 产生的额外的 rank 不固定的树会在删除孩子完成之后被新增为 $t1$ 的孩子。\n\n关于这里的常数 $T$ 的解释：\n\n我们考虑一个 guide 中维护的元素到了和这个 guide 的界差 $1$ 的情况才需要\n REDUCE ，不然不需要。\n\n对于 guide1，这个界限就是 $T-1$，对于 guide2，这个界限就是 $3$。\n\n然后我们要让这次 REDUCE 之后不会导致另一个 guide 需要调整。\n\n所以 $T-1\\;-\\;3 > 4$，$3 + 3 < T-2$，可以解出 $T > 8$，故取 $T=9$。\n\n这里和原论文的 $T=7$ 不一样，但也只是常数差别，不会对复杂度和正确性产生影响，所以不仔细讨论这个了。\n\n对于 $t2$ 的新增/删除孩子，情况和 $t1$ 类似，不同之处是 delink 产生了 $O(1)$ 个新的破坏堆性质的点，这部分的详细内容会在后面提到。\n\n定义 $pv$ 集合为 $V$ 集合和 $W$ 集合的并集，即潜在的违反堆性质的点的集合。\n\n设计一个变换，用于减少 $pv$：\n\n这一段是 $W(t1)$ 的 guide 的 REDUCE 的方法，这个变换将 $pv$ 减少了至少 $1$：\n\n假设 $x1,x2$ 是潜在的违反堆性质的点，满足 $k=rank(x1)=rank(x2)<rank(t1)$，且 $x1,x2$不是根或根的孩子。\n\n首先检查 $x1,x2$ 是否满足堆性质，若满足则从 $V$ 或 $W$ 列表中移除，否则：\n\n若 $x1,x2$ 不是兄弟：\n\n不失一般性，设 $p(x1) \\leq p(x2)$，交换 $x1$ 所在子树和 $x2$ 的某个$rank=k$ 的兄弟 $x3$（由 S4 性质可知这样的 $x3$ 一定存在）所在子树（此操作不会增加 $pv$，$x1$ 仍是 $pv$，$x3$ 可能从 $pv$ 变为非 $pv$ 也可能状态不变），之后可设 $y=p(x1)=p(x2)$。\n\n若存在 $rank=k$ 的第三个兄弟，则将 $x1$ 移除并新增为 $t1$的孩子，这样 $y$ 的 $rank=k$ 的儿子减少了一个，而且至少为 $2$ 个，不违反 S4 性质。\n\n若不存在 $rank=k$ 的第三个兄弟，则将 $x1,x2$ 移除并新增为 $t1$ 的孩子，这样 $y$ 的 $rank=k$ 的儿子个数变成 $0$ 了，不违反 S4 性质。\n\n若 $rank(y)=k+1$ 则还需要移除 $y$，更新 $y$ 的 $rank$，并新增 $y$ 为 $t1$的孩子，$y$ 子树原先的位置被从 $t1$ 移除的一个 $rank=k+1$ 的子树代替。\n\n（这可能增加一个违反堆性质的点（需要加入 $W(t1)$ 中），但同时 $x1,x2$ \n 由于父亲变成了 $t1$，所以将符合堆性质），这里还需要对 $W(t1)$ 的 guide 进行一个 $rank=k+1$ 的位置 $+1$ 的操作。\n\n所以至少减少 $2$ 个 $pv$ 中的点，至多增加 $1$ 个点到 $pv$ 中。\n\n（由于 S2 性质保证了等 $rank$ 替换时，被替换的点和用于替换的点没有祖先关系，因此不会成环）\n\n避免过多的违反堆性质的点出现：\n\n当新增一个违反堆性质的点 $x$ 时，若 $rank(x) \\ge rank(t1)$ 则将其加入到 $V(t1)$ 中，否则加入到 $W(t1)$ 中。\n\n对 $W(t1)$ 也开个 guide，里面第 $i$ 个元素就是 $w(t1,i)$。\n\n向 $W(t1)$ 加点时，插入一个点 $k$ 时，让 guide 中的第 $k$ 个元素 $+1$，然后通过 guide 得到需要进行的 reduce(k) 操作。\n\n在 $w(t1,k)=6$，且其中至少 $2$ 个不是 $t2$ 的孩子时，执行上述变换减少 $pv$。\n\n若有超过 $4$ 个是 $t2$ 的孩子，则将多出的点切下并新增为 $t1$ 的孩子（这不影响 $W(t2)$ 的 guide）。\n\n每次进行优先队列操作时：\n\n若 $T2$ 非空，则通过将 $O(1)$ 个孩子从 $t2$ 移到 $t1$，使 $t1$ 的 $rank$ 增加至少 $1$，这使得我们可以支付 $V(t1)$ 新增的不超过 $α$ 个 $pv$。\n\n具体地，若 $rank(t2) \\leq rank(t1)+2$，则把 $t2$ 的 $rank$ 最大的孩子切下并新增为 $t1$ 的孩子，最终当 $t2$ 没有孩子的时候，把 $t2$ 新增为 $t1$ 的孩子。\n\n若 $rank(t2)>rank(t1)+2$，则切下 $t2$ 的一个 $rank$ 为 $rank(t1)+2$ 的孩子，将其delink并新增为 $t1$ 的孩子。\n\n若 $T2$ 为空，则 $V(t1)$ 不会有新增的 $pv$。\n\n## 6.抽象数据结构\n对于一个抽象数据结构——优先队列，我们可以使用 Brodal queue 实现，具体进行的操作为：\n```\nMakeQueue：T1=T2=null\n```\n```\nFindMin(Q): return t1\n```\n```\nInsert(Q,e): 转为Meld(Q,{T1=e,T2=null})\n```\n\n```\nMeld(Q1,Q2):\n\n不失一般性，设 $Q1.t1<Q2.t1$。\n\n若 Q1.T1 的 rank 最大，则把其余的 $3$ 棵树新增为 Q1.t1 的孩子，Q1.T2 设为空，这个过程中不产生新的 $pv$\n\n否则让 Q1.T2，Q2.T2 中 rank 最大的树成为新的 Q1.T2，其余的 $2$ 棵树新增为 Q1.t2 的孩子。\n```\n\n解释：如果 $min$ 所在的那个树的 $rank$ 是这四个里面最大的，那就把其他几个树都插入到 $min$ 所在的那个树的孩子里面，新的树里面 $T2$ 为空\n\n否则 $rank$ 最大的那个树成为新的 $T2$，除了 $min$ 所在的树都插入这个的孩子里面，$min$ 所在的树成为 $T1$\n\n\n```\nDecreaseKey(Q,e,e'):\n\n修改权值后检查是否违反堆性质\n\n如果违反堆性质，则将其加入pv中，此时pv大小+1\n\n然后按前文避免过多的违反堆性质的点出现的方法来让pv减少至少1，使得pv大\n小平衡\n```\n```\nDeleteMin(Q):\n\n将 t2 的孩子（O(log n) 个）全部切下，新增为 t1 的孩子；将 t2 变为 t1 的孩子；\n\n删除 t1 得到 t1 的孩子，总共有 O(log n) 个。\n\n遍历 t1 的孩子，V(t1) 和 W(t1)，从而得到新的最小值t1'\n\n若 t1' 不是 t1 的孩子，则与等 rank 的孩子交换，这可能产生 O(1) 个 pv。\n\n然后将 V(t1),V(t1'),W(t1),W(t1') 合并为 W(t1')：\n\n先将 V(t1') 置为空，然后使用变换令 w(t1',i)<=1，最后使 t1' 成为新的 t1\n```\n\n```\nDelete(Q),e: 转为DecreaseKey(Q,e,-inf),DeleteMin(Q)\n```", "description": "给定一个长为 $n$ 的序列 $a$ ，每个位置有一种颜色，有 $m$ 次操作，支持：\n\n`1 l r x`：区间 $[l,r]$ 的数都变成 $x$。\n\n`2 l r`：查询有多少二元组 $(i,j)$ 满足 $l \\leq i < j \\leq r$ ，且 $a_i = a_j$。\n\n本题强制在线，每次的 $l,r,x$ 需要 $\\operatorname{xor}$ 上（上次答案 $\\bmod 2^{32}$），也就是说使用 `unsigned int` 数据类型存储上次的答案即可，如果之前没有询问，则上次答案为 $0$。这里输出的答案不对 $\\bmod 2^{32}$ 取模。", "inputFormat": "第一行两个整数 $n, m$。\n\n第二行 $n$ 个整数表示序列 $a$。\n\n之后 $m$ 行，每行形如 `1 l r x` 或 `2 l r`，表示上述的操作。", "outputFormat": "对于每个 $2$ 操作，输出一行一个整数表示答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477&ccz181078，Code：ccz181078，Data：nzhtl1477\n\n注意：本题采用**捆绑测试**，只有当你通过一个 subtask 中的所有测试点后，你才能拿到这个 subtask 的分数。\n\n对于其中 $1\\%$ 的数据，为样例 1。\n\n对于另外 $9\\%$ 的数据，没有修改操作。\n\n对于另外 $19\\%$ 的数据，$n,m\\leq 500$。\n\n对于另外 $19\\%$ 的数据，每次修改的区间长度不超过 $5$。\n\n对于另外 $19\\%$ 的数据，保证数据随机。\n\n对于 $100\\%$ 的数据，$1\\leq n,m\\leq 2\\times 10^5$，$1\\leq a_{i},x\\leq n$，$1\\leq l\\leq r\\leq n$。\n", "locale": "zh-CN"}}}
{"pid": "P6020", "type": "P", "difficulty": 7, "samples": [["3 2", "1\n0 2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2010", "Special Judge", "O2优化", "Ynoi"], "title": "[Ynoi2010] Exponential tree", "background": "", "description": "对于给定的 $n,k$，你需要构造一个只含 $0,1$ 的矩阵 $A_{i,j}$，$0\\le i,j\\le n$，满足：\n\n1. $A_{i,i}=1$\n2. $A_{i,i+1}=1$\n3. 对 $i>j$ 有 $A_{i,j}=0$\n4. 若 $A_{i,j}=1$，$j-i>1$，则存在 $i<t<j$，满足 $A_{i,t}=A_{t,j}=1$\n5. 对 $i\\le j$ 有 $(A^k)_{i,j}>0$。\n\n你需要输出满足 $A_{i,j}=1$ 且 $j-i>1$ 的每个 $(i,j)$，设这样的 $(i,j)$ 共有 $m$ 个。\n\n若输出不满足要求，则不能得到该测试点的任何分数。若输出满足要求，则根据 $m$ 进行评分。", "inputFormat": "一行，两个整数 $n,k$。\n", "outputFormat": "第一行一个整数 $m$，接下来 $m$ 行，每行两个整数 $i,j$，依次表示每个满足 $A_{i,j}=1$ 且 $j-i>1$ 的二元组 $(i,j)$。", "hint": "对于 $100\\%$ 的数据，满足 $1900\\le n\\le 2000$\n$2\\le k\\le 15$。\n\n\n| $k$  | $f(n,k)$ |\n| ---- | -------- |\n| 2    | 7.987    |\n| 3    | 3.8085   |\n| 4    | 2.396    |\n| 5    | 1.961    |\n| 6    | 1.6065   |\n| 7    | 1.451    |\n| 8    | 1.2535   |\n| 9    | 1.1975   |\n| 10   | 1.099    |\n| 11   | 1.07     |\n| 12   | 1.034    |\n| 13   | 1.0115   |\n| 14   | 1.001    |\n| 15   | 0.994    |\n\n\n\n每个 $2\\le k\\le 15$ 对应一个总分为 $s(k)$ 的子任务，每个子任务的得分是子任务中每个测试点的得分的最小值。\n\n每个测试点的得分为所在子任务的总分的 $\\max\\left(0,1-\\sqrt{\\max\\left(0,\\frac{m}{n\\cdot f(k)}-1\\right)}\\right)$ 倍。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2010] Exponential tree", "background": "", "description": "对于给定的 $n,k$，你需要构造一个只含 $0,1$ 的矩阵 $A_{i,j}$，$0\\le i,j\\le n$，满足：\n\n1. $A_{i,i}=1$\n2. $A_{i,i+1}=1$\n3. 对 $i>j$ 有 $A_{i,j}=0$\n4. 若 $A_{i,j}=1$，$j-i>1$，则存在 $i<t<j$，满足 $A_{i,t}=A_{t,j}=1$\n5. 对 $i\\le j$ 有 $(A^k)_{i,j}>0$。\n\n你需要输出满足 $A_{i,j}=1$ 且 $j-i>1$ 的每个 $(i,j)$，设这样的 $(i,j)$ 共有 $m$ 个。\n\n若输出不满足要求，则不能得到该测试点的任何分数。若输出满足要求，则根据 $m$ 进行评分。", "inputFormat": "一行，两个整数 $n,k$。\n", "outputFormat": "第一行一个整数 $m$，接下来 $m$ 行，每行两个整数 $i,j$，依次表示每个满足 $A_{i,j}=1$ 且 $j-i>1$ 的二元组 $(i,j)$。", "hint": "对于 $100\\%$ 的数据，满足 $1900\\le n\\le 2000$\n$2\\le k\\le 15$。\n\n\n| $k$  | $f(n,k)$ |\n| ---- | -------- |\n| 2    | 7.987    |\n| 3    | 3.8085   |\n| 4    | 2.396    |\n| 5    | 1.961    |\n| 6    | 1.6065   |\n| 7    | 1.451    |\n| 8    | 1.2535   |\n| 9    | 1.1975   |\n| 10   | 1.099    |\n| 11   | 1.07     |\n| 12   | 1.034    |\n| 13   | 1.0115   |\n| 14   | 1.001    |\n| 15   | 0.994    |\n\n\n\n每个 $2\\le k\\le 15$ 对应一个总分为 $s(k)$ 的子任务，每个子任务的得分是子任务中每个测试点的得分的最小值。\n\n每个测试点的得分为所在子任务的总分的 $\\max\\left(0,1-\\sqrt{\\max\\left(0,\\frac{m}{n\\cdot f(k)}-1\\right)}\\right)$ 倍。", "locale": "zh-CN"}}}
{"pid": "P6021", "type": "P", "difficulty": 6, "samples": [["4\n4 3 2 1\n1 2\n1 3\n4 2\n4\nQ 1\nQ 2\nC 4 10\nQ 1", "3\n1\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "线段树", "树链剖分", "动态树 LCT", "矩阵乘法", "动态 DP", "全局平衡二叉树"], "title": "洪水", "background": null, "description": "小 A 走到一个山脚下，准备给自己造一个小屋。这时候，小 A 的朋友（`op`，又叫管理员）打开了创造模式，然后飞到山顶放了格水。于是小 A 面前出现了一个瀑布。作为平民的小 A 只好老实巴交地爬山堵水。那么问题来了：我们把这个瀑布看成是一个 $n$ 个节点的树，**其中树根为 $1$，** 每个节点有权值（爬上去的代价）。小 A 要选择一些节点，以其权值和作为代价将这些点删除（堵上），使得根节点与所有叶子结点不连通。问最小代价。不过到这还没结束。小 A 的朋友觉得这样子太便宜小 A 了，于是他还会不断地修改地形，使得某个节点的权值发生变化。不过到这还没结束。小 A 觉得朋友做得太绝了，于是放弃了分离所有叶子节点的方案。取而代之的是，每次他只要在某个子树中（和子树之外的点完全无关）。于是他找到你。", "inputFormat": "输入文件第一行包含一个数 $n$，表示树的大小。\n\n接下来一行包含 $n$ 个数，表示第 $i$ 个点的权值。\n\n接下来 $n-1$ 行每行包含两个数 $fr,to$ 。表示树中有一条边 $(fr,to)$ 。\n\n接下来一行一个整数，表示操作的个数。\n\n接下来 $m$ 行每行表示一个操作，若该行第一个数为 $Q$，则表示询问操作，后面跟一个参数 $x$ ，表示对应子树的根；若为 $C$ ，则表示修改操作，后面接两个参数 $x,t$ ，表示将点 $x$ 的权值加上 $t$。", "outputFormat": "对于每次询问操作，输出对应的答案，答案之间用换行隔开。", "hint": "$1 \\leq n \\leq 200000,1 \\leq fr,to \\leq n,1 \\leq x \\leq n$，权值和 $t$ 均在 `int` 范围内且非负。\n\nBZOJ4712", "locale": "zh-CN", "translations": {"zh-CN": {"title": "洪水", "background": null, "description": "小 A 走到一个山脚下，准备给自己造一个小屋。这时候，小 A 的朋友（`op`，又叫管理员）打开了创造模式，然后飞到山顶放了格水。于是小 A 面前出现了一个瀑布。作为平民的小 A 只好老实巴交地爬山堵水。那么问题来了：我们把这个瀑布看成是一个 $n$ 个节点的树，**其中树根为 $1$，** 每个节点有权值（爬上去的代价）。小 A 要选择一些节点，以其权值和作为代价将这些点删除（堵上），使得根节点与所有叶子结点不连通。问最小代价。不过到这还没结束。小 A 的朋友觉得这样子太便宜小 A 了，于是他还会不断地修改地形，使得某个节点的权值发生变化。不过到这还没结束。小 A 觉得朋友做得太绝了，于是放弃了分离所有叶子节点的方案。取而代之的是，每次他只要在某个子树中（和子树之外的点完全无关）。于是他找到你。", "inputFormat": "输入文件第一行包含一个数 $n$，表示树的大小。\n\n接下来一行包含 $n$ 个数，表示第 $i$ 个点的权值。\n\n接下来 $n-1$ 行每行包含两个数 $fr,to$ 。表示树中有一条边 $(fr,to)$ 。\n\n接下来一行一个整数，表示操作的个数。\n\n接下来 $m$ 行每行表示一个操作，若该行第一个数为 $Q$，则表示询问操作，后面跟一个参数 $x$ ，表示对应子树的根；若为 $C$ ，则表示修改操作，后面接两个参数 $x,t$ ，表示将点 $x$ 的权值加上 $t$。", "outputFormat": "对于每次询问操作，输出对应的答案，答案之间用换行隔开。", "hint": "$1 \\leq n \\leq 200000,1 \\leq fr,to \\leq n,1 \\leq x \\leq n$，权值和 $t$ 均在 `int` 范围内且非负。\n\nBZOJ4712", "locale": "zh-CN"}}}
{"pid": "P6022", "type": "P", "difficulty": 2, "samples": [["5 2\n2 4\n", "15"], ["2 2\n2 2\n", "Inf"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2020"], "title": "快乐水", "background": "小 W 要去买快乐水。", "description": "他来到了一家商店门前。\n\n这家商店为了吸引顾客来买快乐水，搞了这么一个活动：「$5$ 个瓶盖换一瓶快乐水」。于是，人们纷纷来他的店里买快乐水。\n\n买完快乐水，他想到了一个问题：\n\n如果一瓶快乐水有 $m$ 个附属品，对于第 $i$ 个附属品，每 $a_i$ 个可以换一瓶全新的快乐水，现在我有买 $n$ 瓶快乐水的钱，我最多能喝多少快乐水呢？", "inputFormat": "第一行两个整数 $n,m$，意义如上。\n\n接下来一行 $m$ 个整数 $a_1,a_2,\\cdots,a_m$，意义如上。", "outputFormat": "如果小 W 可以无限白嫖快乐水，那么输出一行一个字符串 `Inf`。\n\n否则，输出一行一个整数 $s$，表示小 W 最多能喝的快乐水数量。", "hint": "样例一解释：\n\n| 步数 | 已喝 | 未喝 | 附属品一 | 附属品二 |\n| ---- | ---- | ---- | -------- | -------- |\n| 1    | 0    | 5    | 0        | 0        |\n| 2    | 5    | 0    | 5        | 5        |\n| 3    | 5    | 3    | 1        | 1        |\n| 4    | 8    | 0    | 4        | 4        |\n| 5    | 8    | 3    | 0        | 0        |\n| 6    | 11   | 0    | 3        | 3        |\n| 7    | 11   | 1    | 1        | 3        |\n| 8    | 12   | 0    | 2        | 4        |\n| 9    | 12   | 2    | 0        | 0        |\n| 10   | 14   | 0    | 2        | 2        |\n| 11   | 14   | 1    | 0        | 2        |\n| 12   | 15   | 0    | 1        | 3        |\n\n样例二解释：\n\n| 步数 | 已喝     | 未喝     | 附属品一 | 附属品二 |\n| ---- | -------- | -------- | -------- | -------- |\n| 1    | 0        | 2        | 0        | 0        |\n| 2    | 2        | 0        | 2        | 2        |\n| 3    | 2        | 2        | 0        | 0        |\n| 4    | 4        | 0        | 2        | 2        |\n| 5    | 4        | 2        | 0        | 0        |\n| 6    | 6        | 0        | 2        | 2        |\n| 7    | 6        | 2        | 0        | 0        |\n| 8    | 8        | 0        | 2        | 2        |\n| 9    | $\\vdots$ | $\\vdots$ | $\\vdots$ | $\\vdots$ |\n\n很显然小 W 可以像这样无限白嫖快乐水。\n\n**注意：本题中，我们认为无法借还/赊账。**\n********\n数据范围：  \n\n测试点一与样例二相同。\n\n对于其中 $30\\%$ 的数据，$n\\le 100$，$m\\le 2$。\n\n对于 $100\\%$ 的数据，$1\\le n\\le 10^4$，$1\\le m\\le 5$，$1\\le a_i\\le 2\\times10^3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "快乐水", "background": "小 W 要去买快乐水。", "description": "他来到了一家商店门前。\n\n这家商店为了吸引顾客来买快乐水，搞了这么一个活动：「$5$ 个瓶盖换一瓶快乐水」。于是，人们纷纷来他的店里买快乐水。\n\n买完快乐水，他想到了一个问题：\n\n如果一瓶快乐水有 $m$ 个附属品，对于第 $i$ 个附属品，每 $a_i$ 个可以换一瓶全新的快乐水，现在我有买 $n$ 瓶快乐水的钱，我最多能喝多少快乐水呢？", "inputFormat": "第一行两个整数 $n,m$，意义如上。\n\n接下来一行 $m$ 个整数 $a_1,a_2,\\cdots,a_m$，意义如上。", "outputFormat": "如果小 W 可以无限白嫖快乐水，那么输出一行一个字符串 `Inf`。\n\n否则，输出一行一个整数 $s$，表示小 W 最多能喝的快乐水数量。", "hint": "样例一解释：\n\n| 步数 | 已喝 | 未喝 | 附属品一 | 附属品二 |\n| ---- | ---- | ---- | -------- | -------- |\n| 1    | 0    | 5    | 0        | 0        |\n| 2    | 5    | 0    | 5        | 5        |\n| 3    | 5    | 3    | 1        | 1        |\n| 4    | 8    | 0    | 4        | 4        |\n| 5    | 8    | 3    | 0        | 0        |\n| 6    | 11   | 0    | 3        | 3        |\n| 7    | 11   | 1    | 1        | 3        |\n| 8    | 12   | 0    | 2        | 4        |\n| 9    | 12   | 2    | 0        | 0        |\n| 10   | 14   | 0    | 2        | 2        |\n| 11   | 14   | 1    | 0        | 2        |\n| 12   | 15   | 0    | 1        | 3        |\n\n样例二解释：\n\n| 步数 | 已喝     | 未喝     | 附属品一 | 附属品二 |\n| ---- | -------- | -------- | -------- | -------- |\n| 1    | 0        | 2        | 0        | 0        |\n| 2    | 2        | 0        | 2        | 2        |\n| 3    | 2        | 2        | 0        | 0        |\n| 4    | 4        | 0        | 2        | 2        |\n| 5    | 4        | 2        | 0        | 0        |\n| 6    | 6        | 0        | 2        | 2        |\n| 7    | 6        | 2        | 0        | 0        |\n| 8    | 8        | 0        | 2        | 2        |\n| 9    | $\\vdots$ | $\\vdots$ | $\\vdots$ | $\\vdots$ |\n\n很显然小 W 可以像这样无限白嫖快乐水。\n\n**注意：本题中，我们认为无法借还/赊账。**\n********\n数据范围：  \n\n测试点一与样例二相同。\n\n对于其中 $30\\%$ 的数据，$n\\le 100$，$m\\le 2$。\n\n对于 $100\\%$ 的数据，$1\\le n\\le 10^4$，$1\\le m\\le 5$，$1\\le a_i\\le 2\\times10^3$。", "locale": "zh-CN"}}}
{"pid": "P6023", "type": "P", "difficulty": 3, "samples": [["5 1 3\n1 0\n1 2\n1 4\n", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2020"], "title": "走路", "background": "小 W 下载了一款运动软件。", "description": "小 W 准备在接下来的 $m$ 天中锻炼，由于他不能走得太多以至于累死（怎么可能呢），所以他这 $m$ 天最多一共只能走 $n$ 步。  \n这个运动软件为了激励小 W 走路，推出了 $k$ 种激励措施，每种激励措施都形如“如果你第 $p$ 天中走完了 $q$ 步，那么第 $p$ 天中接下来的每一步都会给你加 $1$ 积分”。**激励措施可以叠加，即走一步你可能可以获得多于 $1$ 积分。**  \n现在小 W 想知道，他总计最多可以获取多少积分呢？", "inputFormat": "第一行三个整数 $n,m,k$，意义如上。  \n接下来 $k$ 行，每行两个整数 $p,q$，表示一个激励措施，意义如上。", "outputFormat": "一行 $1$ 个整数，表示 $m$ 天后最多可以获得的积分。", "hint": "样例解释：  \n只有一种方案，即在第一天走 $5$ 步，第一、二步各获得 $1$ 积分，第三、四步各获得 $2$ 积分，第五步获得 $3$ 积分，总计 $9$ 积分。  \n********\n数据范围：  \n对于 $10\\%$ 的数据，$n,m,k\\le10$。  \n对于 $40\\%$ 的数据，$n,m,k \\le 10^3$。  \n对于 $100\\%$ 的数据，$1\\le n\\le 10^{12}$，$1\\le m,k\\le 10^5$，$1\\le p\\le m$，$0\\le q\\le n$。", "locale": "zh-CN", "translations": {"en": {"title": "Walking", "background": "Xiao W downloaded a fitness app.", "description": "Xiao W plans to work out over the next $m$ days. Since he cannot walk too much and get exhausted (how could that happen), over these $m$ days he can walk at most $n$ steps in total.  \nTo encourage Xiao W to walk, the app provides $k$ incentive rules. Each rule is of the form: “If on day $p$ you finish walking $q$ steps, then on day $p$ every subsequent step will give you an additional $1$ point.” **Incentive rules can stack, meaning that for one step you may gain more than $1$ point.**  \nNow Xiao W wants to know: what is the maximum total number of points he can get?", "inputFormat": "The first line contains three integers $n,m,k$, with meanings as above.  \nThe next $k$ lines each contain two integers $p,q$, describing an incentive rule as above.", "outputFormat": "Output one integer, the maximum points that can be obtained after $m$ days.", "hint": "Explanation for the sample:  \nThere is only one plan: walk $5$ steps on the first day. The first and second steps each gain $1$ point, the third and fourth steps each gain $2$ points, and the fifth step gains $3$ points, for a total of $9$ points.\n\nConstraints:  \nFor $10\\%$ of the testdata, $n,m,k \\le 10$.  \nFor $40\\%$ of the testdata, $n,m,k \\le 10^3$.  \nFor $100\\%$ of the testdata, $1 \\le n \\le 10^{12}$, $1 \\le m,k \\le 10^5$, $1 \\le p \\le m$, $0 \\le q \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "走路", "background": "小 W 下载了一款运动软件。", "description": "小 W 准备在接下来的 $m$ 天中锻炼，由于他不能走得太多以至于累死（怎么可能呢），所以他这 $m$ 天最多一共只能走 $n$ 步。  \n这个运动软件为了激励小 W 走路，推出了 $k$ 种激励措施，每种激励措施都形如“如果你第 $p$ 天中走完了 $q$ 步，那么第 $p$ 天中接下来的每一步都会给你加 $1$ 积分”。**激励措施可以叠加，即走一步你可能可以获得多于 $1$ 积分。**  \n现在小 W 想知道，他总计最多可以获取多少积分呢？", "inputFormat": "第一行三个整数 $n,m,k$，意义如上。  \n接下来 $k$ 行，每行两个整数 $p,q$，表示一个激励措施，意义如上。", "outputFormat": "一行 $1$ 个整数，表示 $m$ 天后最多可以获得的积分。", "hint": "样例解释：  \n只有一种方案，即在第一天走 $5$ 步，第一、二步各获得 $1$ 积分，第三、四步各获得 $2$ 积分，第五步获得 $3$ 积分，总计 $9$ 积分。  \n********\n数据范围：  \n对于 $10\\%$ 的数据，$n,m,k\\le10$。  \n对于 $40\\%$ 的数据，$n,m,k \\le 10^3$。  \n对于 $100\\%$ 的数据，$1\\le n\\le 10^{12}$，$1\\le m,k\\le 10^5$，$1\\le p\\le m$，$0\\le q\\le n$。", "locale": "zh-CN"}}}
{"pid": "P6024", "type": "P", "difficulty": 5, "samples": [["2\n999 1\n5000 10000\n", "1 2"], ["1\n1\n0\n", "Impossible"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "Special Judge"], "title": "机器人", "background": "小 W 购买了一个机器人。", "description": "现在，小 W 希望机器人去帮他完成 $n$ 个任务。\n\n每个任务有两种属性：完成需要花的钱 $w_i$，成功率 $p_i$。\n\n小 W 需要将任务按一定顺序排序，随后，机器人会按如下方式做任务：\n\n- 从第一个任务开始做；\n- 花费代价做完第 $i$ 个任务后，如果成功，则继续做第 $i+1$ 个任务，否则重新从第一个任务开始做；\n- 成功做完第 $n$ 个任务后，流程结束。\n\n例如，当 $n=2$ 时，一个可能的流程为：\n- 做任务 $1$，失败；\n- 做任务 $1$，成功；\n- 做任务 $2$，失败；\n- 做任务 $1$，成功；\n- 做任务 $2$，成功；\n- 流程结束，总花费为 $3w_1+2w_2$。\n\n现在，小 W 希望学 OI 的你帮他找到一种排列顺序，使得他的期望花费最小。", "inputFormat": "第一行一个整数 $n$，表示任务的数量。\n\n接下来一行 $n$ 个整数 $w_1,w_2,\\cdots,w_n$，意义如上。\n\n接下来一行 $n$ 个整数 $P_1,P_2,\\cdots,P_n$，其中 $P_i=p_i\\times10^4$，\n$p_i$ 的意义如上。", "outputFormat": "如果无论如何也不可能完成任务，那么输出一行一个字符串`Impossible`。\n\n否则，输出一行 $n$ 个整数 $c_1,c_2,\\cdots,c_n$，其为 $1,2,\\cdots,n$ 的一个排列，表示任务的安排顺序，安排的第 $i$ 件任务是输入中的第 $c_i$  件任务。", "hint": "样例一解释：可以感性理解。既然任务 $2$ 一定成功，那放到最后做肯定不劣。\n\n样例二解释：显然这个任务不可能完成，它的成功率为 $0$。\n\n**注意：无论任务是否成功，总是要花费 $w_i$ 的代价去做。**\n********\n本题带有 $\\text{SPJ}$。如果你的输出与答案的输出一样优（或者都是`Impossible`），那么你将在这个测试点获得满分，否则你将在这个测试点不获得任何分数。\n\n由于某种原因，本题不提供 $\\text{SPJ}$ 给选手。\n********\n数据范围：  \n对于 $10\\%$ 的数据，$1\\le n\\le 10$。  \n对于另外 $20\\%$ 的数据，所有 $w_i$ 相等。  \n对于另外 $20\\%$ 的数据，所有 $p_i$ 相等。  \n对于所有数据，$1\\le n\\le 2\\times10^5$，$1\\le w_i\\le 10^9$，$0\\le P_i\\le10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "机器人", "background": "小 W 购买了一个机器人。", "description": "现在，小 W 希望机器人去帮他完成 $n$ 个任务。\n\n每个任务有两种属性：完成需要花的钱 $w_i$，成功率 $p_i$。\n\n小 W 需要将任务按一定顺序排序，随后，机器人会按如下方式做任务：\n\n- 从第一个任务开始做；\n- 花费代价做完第 $i$ 个任务后，如果成功，则继续做第 $i+1$ 个任务，否则重新从第一个任务开始做；\n- 成功做完第 $n$ 个任务后，流程结束。\n\n例如，当 $n=2$ 时，一个可能的流程为：\n- 做任务 $1$，失败；\n- 做任务 $1$，成功；\n- 做任务 $2$，失败；\n- 做任务 $1$，成功；\n- 做任务 $2$，成功；\n- 流程结束，总花费为 $3w_1+2w_2$。\n\n现在，小 W 希望学 OI 的你帮他找到一种排列顺序，使得他的期望花费最小。", "inputFormat": "第一行一个整数 $n$，表示任务的数量。\n\n接下来一行 $n$ 个整数 $w_1,w_2,\\cdots,w_n$，意义如上。\n\n接下来一行 $n$ 个整数 $P_1,P_2,\\cdots,P_n$，其中 $P_i=p_i\\times10^4$，\n$p_i$ 的意义如上。", "outputFormat": "如果无论如何也不可能完成任务，那么输出一行一个字符串`Impossible`。\n\n否则，输出一行 $n$ 个整数 $c_1,c_2,\\cdots,c_n$，其为 $1,2,\\cdots,n$ 的一个排列，表示任务的安排顺序，安排的第 $i$ 件任务是输入中的第 $c_i$  件任务。", "hint": "样例一解释：可以感性理解。既然任务 $2$ 一定成功，那放到最后做肯定不劣。\n\n样例二解释：显然这个任务不可能完成，它的成功率为 $0$。\n\n**注意：无论任务是否成功，总是要花费 $w_i$ 的代价去做。**\n********\n本题带有 $\\text{SPJ}$。如果你的输出与答案的输出一样优（或者都是`Impossible`），那么你将在这个测试点获得满分，否则你将在这个测试点不获得任何分数。\n\n由于某种原因，本题不提供 $\\text{SPJ}$ 给选手。\n********\n数据范围：  \n对于 $10\\%$ 的数据，$1\\le n\\le 10$。  \n对于另外 $20\\%$ 的数据，所有 $w_i$ 相等。  \n对于另外 $20\\%$ 的数据，所有 $p_i$ 相等。  \n对于所有数据，$1\\le n\\le 2\\times10^5$，$1\\le w_i\\le 10^9$，$0\\le P_i\\le10^4$。", "locale": "zh-CN"}}}
{"pid": "P6025", "type": "P", "difficulty": 5, "samples": [["6 6\n", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2020"], "title": "线段树", "background": "小 W 学习了一种叫做线段树的数据结构。", "description": "很快，小 W 就发现：线段树实在是太浪费空间了！\n\n比如，一棵 $n=6$ 的线段树长下面这样：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/laie1is5.png)\n\n可以发现，只有 $11$ 个节点存储了有用信息，但使用的数组下标到了 $13$。\n\n令 $f(n)$ 表示一棵 $n$ 个叶子节点的线段树所占的最大数组下标，现在小 W 想让你求出：\n$$f(l)\\;\\oplus\\;f(l+1)\\;\\oplus\\;f(l+2)\\;\\oplus\\cdots \\oplus\\;f(r)$$\n其中，$\\oplus$ 表示异或运算，相当于 C++ 中的`^`符号。", "inputFormat": "一行两个整数，表示 $l,r$，意义如上。", "outputFormat": "一行一个整数，表示结果。", "hint": "## 样例解释\n$f(6)=13$，故答案为 $13$。\n## 提示\n如果你不知道什么是线段树：\n```cpp\nvoid build(int k,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\t//do something\n\t\t//e.g. tree[k]=a[l]\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(k<<1,l,mid);\n\tbuild(k<<1|1,mid+1,r);\n\t//do something\n\t//e.g. tree[k]=tree[k<<1]+tree[k<<1|1]\n}\n```\n翻译成人话就是：编号为 $k$ 节点有一个线段 $[l,r]$，如果 $l\\neq r$，那么令 $mid=\\lfloor\\dfrac{l+r}2\\rfloor$，它有两个子节点，左儿子编号为 $2k$，线段为 $[l,mid]$；右儿子编号为 $2k+1$，线段为 $[mid+1,r]$，然后在子节点上递归建树。\n\n调用`build(1,1,n)`后就建好了一棵线段树，即编号为 $1$ 的结点的线段为 $[1,n]$。\n## 数据范围  \n对于 $10\\%$ 的数据，$1\\le l\\le r\\le10^3$。  \n对于 $40\\%$ 的数据，$1\\le l\\le r\\le 10^6$。  \n对于 $100\\%$ 的数据，$1\\le l\\le r\\le10^{15}$，答案在`long long`范围内。  ", "locale": "zh-CN", "translations": {"en": {"title": "Segment Tree", "background": "Little W learned a data structure called the segment tree.", "description": "Soon, Little W discovered that segment trees waste far too much space.\n\nFor example, a segment tree with $n=6$ looks like this:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/laie1is5.png)\n\nYou can see that only $11$ nodes store useful information, but the array indices used go up to $13$.\n\nLet $f(n)$ be the maximum array index occupied by a segment tree with $n$ leaf nodes. Now Little W wants you to compute:\n$$f(l)\\;\\oplus\\;f(l+1)\\;\\oplus\\;f(l+2)\\;\\oplus\\cdots \\oplus\\;f(r)$$\nHere, $\\oplus$ denotes the bitwise XOR operation, which is the `^` operator in C++.", "inputFormat": "One line with two integers $l, r$, with the meaning described above.", "outputFormat": "One line with one integer, the result.", "hint": "# Sample Explanation\n\n$f(6)=13$, so the answer is $13$.\n\n# Hint\n\nIf you do not know what a segment tree is:\n```cpp\nvoid build(int k,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\t//do something\n\t\t//e.g. tree[k]=a[l]\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(k<<1,l,mid);\n\tbuild(k<<1|1,mid+1,r);\n\t//do something\n\t//e.g. tree[k]=tree[k<<1]+tree[k<<1|1]\n}\n```\nIn plain words: node $k$ corresponds to a segment $[l,r]$. If $l\\neq r$, let $mid=\\lfloor\\dfrac{l+r}2\\rfloor$. It has two children: the left child has index $2k$ and segment $[l,mid]$; the right child has index $2k+1$ and segment $[mid+1,r]$. Then build the tree recursively on the child nodes.\n\nAfter calling `build(1,1,n)`, the segment tree is built. That is, node $1$ corresponds to segment $[1,n]$.\n\n## Constraints  \nFor $10\\%$ of the testdata, $1\\le l\\le r\\le10^3$.  \nFor $40\\%$ of the testdata, $1\\le l\\le r\\le 10^6$.  \nFor $100\\%$ of the testdata, $1\\le l\\le r\\le10^{15}$, and the answer fits in `long long`.\n\n# Input Format\n\nOne line with two integers $l, r$, with the meaning described above.\n\n# Output Format\n\nOne line with one integer, the result.\n\n# Hint\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "线段树", "background": "小 W 学习了一种叫做线段树的数据结构。", "description": "很快，小 W 就发现：线段树实在是太浪费空间了！\n\n比如，一棵 $n=6$ 的线段树长下面这样：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/laie1is5.png)\n\n可以发现，只有 $11$ 个节点存储了有用信息，但使用的数组下标到了 $13$。\n\n令 $f(n)$ 表示一棵 $n$ 个叶子节点的线段树所占的最大数组下标，现在小 W 想让你求出：\n$$f(l)\\;\\oplus\\;f(l+1)\\;\\oplus\\;f(l+2)\\;\\oplus\\cdots \\oplus\\;f(r)$$\n其中，$\\oplus$ 表示异或运算，相当于 C++ 中的`^`符号。", "inputFormat": "一行两个整数，表示 $l,r$，意义如上。", "outputFormat": "一行一个整数，表示结果。", "hint": "## 样例解释\n$f(6)=13$，故答案为 $13$。\n## 提示\n如果你不知道什么是线段树：\n```cpp\nvoid build(int k,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\t//do something\n\t\t//e.g. tree[k]=a[l]\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(k<<1,l,mid);\n\tbuild(k<<1|1,mid+1,r);\n\t//do something\n\t//e.g. tree[k]=tree[k<<1]+tree[k<<1|1]\n}\n```\n翻译成人话就是：编号为 $k$ 节点有一个线段 $[l,r]$，如果 $l\\neq r$，那么令 $mid=\\lfloor\\dfrac{l+r}2\\rfloor$，它有两个子节点，左儿子编号为 $2k$，线段为 $[l,mid]$；右儿子编号为 $2k+1$，线段为 $[mid+1,r]$，然后在子节点上递归建树。\n\n调用`build(1,1,n)`后就建好了一棵线段树，即编号为 $1$ 的结点的线段为 $[1,n]$。\n## 数据范围  \n对于 $10\\%$ 的数据，$1\\le l\\le r\\le10^3$。  \n对于 $40\\%$ 的数据，$1\\le l\\le r\\le 10^6$。  \n对于 $100\\%$ 的数据，$1\\le l\\le r\\le10^{15}$，答案在`long long`范围内。  ", "locale": "zh-CN"}}}
{"pid": "P6026", "type": "P", "difficulty": 5, "samples": [["10 1\n", "1"], ["2 2\n", "250000002"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2020", "组合数学"], "title": "餐馆", "background": "小 W 家新开了一家餐馆。", "description": "这家餐馆提供 $n$ 种特色菜，它们被标号为 $1,2,\\cdots,n$。\n\n有一天，餐馆里来了 $k$ 个客人，他们没有想好要吃什么。于是，小 W 给他们出了个主意：每个人先从 $1,2,\\cdots,n$ 中等概率随机一个数 $r$，再从\n $1,2,\\cdots,r$ 中等概率随机一个数 $l$，这个人就点标号在 $l$ 和 $r$ 之间（包括 $l$ 和 $r$）的菜。\n\n于是，客人们按小 W 说的做了。在所有客人都点完单之后，小 W 突然发现：没有两个人都点了相同的一道菜，他每种菜至多做一份就够了！为了证明他是多么的欧皇，他找到了学编程的你，请你帮他计算这种情况发生的概率。", "inputFormat": "两个整数 $n$ 和 $k$，意义如题目描述。", "outputFormat": "一个整数 $p$，表示所求概率对 $10^9+7$ 取模后的结果。", "hint": "样例解释：  \n样例 $1$ 解释：因为只有一位客人，所以无论如何不会有两个人点同样的菜，故所求概率为 $1$。\n\n样例 $2$ 解释：每位客人只点 $1$ 号菜的概率为 $\\dfrac12$，只点 $2$ 号菜的概率为 $\\dfrac14$，两个菜都点的概率为 $\\dfrac14$，两人不点同一道菜即一人只点 $1$ 号菜，一人只点 $2$ 号菜，概率为\n $\\dfrac14\\times\\dfrac12+\\dfrac12\\times\\dfrac14=\\dfrac14$，模 $10^9+7$ 意义下为\n $250000002$。\n*********\n\n提示：如果你不知道如何对有理数取余，请看 [P2613](https://www.luogu.com.cn/problem/P2613)。\n\n********\n数据范围：  \n对于 $10\\%$ 的数据， $k=1$。  \n对于另外 $10\\%$ 的数据， $1\\le k\\le n\\le5$。  \n对于另外 $20\\%$ 的数据， $1\\le k\\le3$。  \n对于另外 $30\\%$ 的数据， $1\\le k\\le n\\le10^3$。  \n对于所有数据， $1\\le k\\le n\\le 10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "Restaurant", "background": "Xiao W’s family has just opened a new restaurant.", "description": "The restaurant offers $n$ signature dishes, numbered $1,2,\\cdots,n$.\n\nOne day, $k$ customers came to the restaurant, and they had not decided what to eat. So Xiao W gave them an idea: each person first randomly chooses a number $r$ from $1,2,\\cdots,n$ with equal probability, then randomly chooses a number $l$ from $1,2,\\cdots,r$ with equal probability. This person then orders all dishes with numbers between $l$ and $r$ (including $l$ and $r$).\n\nSo the customers did as Xiao W said. After all customers finished ordering, Xiao W suddenly realized: no two people ordered the same dish, so he only needs to cook at most one portion of each dish. To prove how lucky he is, he found you, who studies programming, and asks you to help compute the probability that this situation happens.", "inputFormat": "Two integers $n$ and $k$, as described in the statement.", "outputFormat": "Output one integer $p$, which is the required probability modulo $10^9+7$.", "hint": "Explanation of the samples:  \nSample $1$: Because there is only one customer, no matter what happens, there cannot be two people ordering the same dish. Therefore, the required probability is $1$.\n\nSample $2$: For each customer, the probability of ordering only dish $1$ is $\\dfrac12$, the probability of ordering only dish $2$ is $\\dfrac14$, and the probability of ordering both dishes is $\\dfrac14$. For the two people to not order any common dish, one must order only dish $1$ and the other must order only dish $2$. The probability is $\\dfrac14\\times\\dfrac12+\\dfrac12\\times\\dfrac14=\\dfrac14$, which modulo $10^9+7$ is $250000002$.\n\n*********\n\nHint: If you do not know how to take a rational number modulo, please see [P2613](https://www.luogu.com.cn/problem/P2613).\n\n********\n\nConstraints:  \nFor $10\\%$ of the testdata, $k=1$.  \nFor another $10\\%$ of the testdata, $1\\le k\\le n\\le5$.  \nFor another $20\\%$ of the testdata, $1\\le k\\le3$.  \nFor another $30\\%$ of the testdata, $1\\le k\\le n\\le10^3$.  \nFor all testdata, $1\\le k\\le n\\le 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "餐馆", "background": "小 W 家新开了一家餐馆。", "description": "这家餐馆提供 $n$ 种特色菜，它们被标号为 $1,2,\\cdots,n$。\n\n有一天，餐馆里来了 $k$ 个客人，他们没有想好要吃什么。于是，小 W 给他们出了个主意：每个人先从 $1,2,\\cdots,n$ 中等概率随机一个数 $r$，再从\n $1,2,\\cdots,r$ 中等概率随机一个数 $l$，这个人就点标号在 $l$ 和 $r$ 之间（包括 $l$ 和 $r$）的菜。\n\n于是，客人们按小 W 说的做了。在所有客人都点完单之后，小 W 突然发现：没有两个人都点了相同的一道菜，他每种菜至多做一份就够了！为了证明他是多么的欧皇，他找到了学编程的你，请你帮他计算这种情况发生的概率。", "inputFormat": "两个整数 $n$ 和 $k$，意义如题目描述。", "outputFormat": "一个整数 $p$，表示所求概率对 $10^9+7$ 取模后的结果。", "hint": "样例解释：  \n样例 $1$ 解释：因为只有一位客人，所以无论如何不会有两个人点同样的菜，故所求概率为 $1$。\n\n样例 $2$ 解释：每位客人只点 $1$ 号菜的概率为 $\\dfrac12$，只点 $2$ 号菜的概率为 $\\dfrac14$，两个菜都点的概率为 $\\dfrac14$，两人不点同一道菜即一人只点 $1$ 号菜，一人只点 $2$ 号菜，概率为\n $\\dfrac14\\times\\dfrac12+\\dfrac12\\times\\dfrac14=\\dfrac14$，模 $10^9+7$ 意义下为\n $250000002$。\n*********\n\n提示：如果你不知道如何对有理数取余，请看 [P2613](https://www.luogu.com.cn/problem/P2613)。\n\n********\n数据范围：  \n对于 $10\\%$ 的数据， $k=1$。  \n对于另外 $10\\%$ 的数据， $1\\le k\\le n\\le5$。  \n对于另外 $20\\%$ 的数据， $1\\le k\\le3$。  \n对于另外 $30\\%$ 的数据， $1\\le k\\le n\\le10^3$。  \n对于所有数据， $1\\le k\\le n\\le 10^8$。", "locale": "zh-CN"}}}
{"pid": "P6027", "type": "P", "difficulty": 6, "samples": [["2\n1.000000 1.000000\n2.000000 2.000000\n4.000000 4.000000\n3.000000 3.000000\n", "1\n1.000000 1.000000 -5.000000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2020", "Special Judge"], "title": "轴对称", "background": "小 W 学习了轴对称变换。", "description": "小 W 觉得轴对称变换实在太好玩了，于是在平面上随机点了 $n$ 个点 $A_1,A_2,\\cdots,A_n$，然后进行了一系列轴对称变换，得到了 $B_1,B_2,\\cdots,B_n$ 这 $n$ 个点，其中 $A_1$ 得到 $B_1$，以此类推。\n\n可是他突然忘记自己是怎么变换到的了，所以他请你帮他找到一组步数尽量少的合法的变换。", "inputFormat": "第一行一个整数 $n$，表示点的个数。\n\n接下来 $n$ 行，第 $i+1$ 行两个实数 $x,y$，表示 $A_i$ 的横、纵坐标。\n\n接下来 $n$ 行，第 $i+n+1$ 行两个实数 $x,y$，表示 $B_i$ 的横、纵坐标。", "outputFormat": "第一行一个整数 $k$ ，表示最少的步数。\n\n接下来 $k$ 行，第 $i+1$ 行三个实数 $A,B,C$，表示第 $i$ 次轴对称变换的轴为直线 $Ax+By+C=0$。", "hint": "## 样例解释\n![](https://cdn.luogu.com.cn/upload/image_hosting/8msdygxi.png)\n## 提示\n对于直线 $Ax+By+C=0$，如果 $B$ 非零，那么它就是一次函数 $y=-\\dfrac ABx-\\dfrac CB$ 的图像；否则，它表示一条垂直于 $x$ 轴的直线 $x=-\\dfrac CA$。\n\n本题带有 $\\text{SPJ}$。**因为某种原因，本题不提供** $\\text{SPJ}$ **给选手。**\n\n对于每个测试点，如果你的 $k$ 正确，则获得 $30\\%$ 的分数；\n\n接下来，我们将对 $A_1,A_2,\\cdots,A_n$ 分别进行你给的 $k$ 次轴对称变换，记 $A_i$ 得到的点为 $C_i$。如果对于所有的 $i$，$B_i$ 与 $C_i$ 的 $x,y$ 坐标之差的绝对值都不超过 $10^{-2}$，则你获得 $100\\%$ 的分数。\n\n如果你只想输出 $k$，也请在后面随意输出一些值，防止 $\\text{UKE}$。\n## 数据范围\n\n| 测试点编号 | $n=$ | 构造数据时翻折的次数 |\n| ---------- | ---- | -------------------- |\n| 1,2        | $1$  | $\\le1$               |\n| 3,4        | $2$  | $\\le10$              |\n| 5,6        | $5$  | $\\le10^3$            |\n| 7,8,9,10   | $10$ | $\\le10^5$            |\n\n对于所有数据，$1\\le n\\le10$，$|x|,|y|\\le 10^5$。\n\n所有数据点已经经过 $\\text{SPJ}$ 验证无误。 \n\n请保证你的输出中的所有 $A,B,C$ 满足 $|A|,|B|,|C|\\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Axial Symmetry", "background": "Little W learned axial symmetry transformations.", "description": "Little W thinks axial symmetry transformations are really fun, so he randomly picked $n$ points $A_1,A_2,\\cdots,A_n$ on the plane, and then performed a series of axial symmetry transformations to obtain $n$ points $B_1,B_2,\\cdots,B_n$, where $A_1$ becomes $B_1$, and so on.\n\nHowever, he suddenly forgot how he transformed them, so he asks you to help him find a valid sequence of transformations with as few steps as possible.", "inputFormat": "The first line contains an integer $n$, the number of points.\n\nThe next $n$ lines, line $i+1$ contains two real numbers $x,y$, representing the $x$- and $y$-coordinates of $A_i$.\n\nThe next $n$ lines, line $i+n+1$ contains two real numbers $x,y$, representing the $x$- and $y$-coordinates of $B_i$.", "outputFormat": "The first line contains an integer $k$, the minimum number of steps.\n\nThe next $k$ lines, line $i+1$ contains three real numbers $A,B,C$, indicating that the axis of the $i$-th axial symmetry transformation is the line $Ax+By+C=0$.", "hint": "## Sample Explanation\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8msdygxi.png)\n\n## Hint\n\nFor the line $Ax+By+C=0$, if $B$ is non-zero, then it is the graph of the linear function $y=-\\dfrac ABx-\\dfrac CB$; otherwise, it represents a line perpendicular to the $x$-axis, namely $x=-\\dfrac CA$.\n\nThis problem uses an $\\text{SPJ}$. **For some reason, this problem does not provide** the $\\text{SPJ}$ **to contestants.**\n\nFor each test case, if your $k$ is correct, you will get $30\\%$ of the score.\n\nNext, we will apply your $k$ axial symmetry transformations to $A_1,A_2,\\cdots,A_n$ respectively, and let the resulting point of $A_i$ be $C_i$. If for all $i$, the absolute differences between the $x,y$ coordinates of $B_i$ and $C_i$ are both no more than $10^{-2}$, then you will get $100\\%$ of the score.\n\nIf you only want to output $k$, please also output some arbitrary values afterwards to avoid $\\text{UKE}$.\n\n## Constraints\n\n| Test Point ID | $n=$ | Number of folds used when constructing the testdata |\n| ---------- | ---- | -------------------- |\n| 1,2        | $1$  | $\\le1$               |\n| 3,4        | $2$  | $\\le10$              |\n| 5,6        | $5$  | $\\le10^3$            |\n| 7,8,9,10   | $10$ | $\\le10^5$            |\n\nFor all data, $1\\le n\\le10$, $|x|,|y|\\le 10^5$.\n\nAll data points have been verified by the $\\text{SPJ}$ and are correct.\n\nPlease ensure that all $A,B,C$ in your output satisfy $|A|,|B|,|C|\\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "轴对称", "background": "小 W 学习了轴对称变换。", "description": "小 W 觉得轴对称变换实在太好玩了，于是在平面上随机点了 $n$ 个点 $A_1,A_2,\\cdots,A_n$，然后进行了一系列轴对称变换，得到了 $B_1,B_2,\\cdots,B_n$ 这 $n$ 个点，其中 $A_1$ 得到 $B_1$，以此类推。\n\n可是他突然忘记自己是怎么变换到的了，所以他请你帮他找到一组步数尽量少的合法的变换。", "inputFormat": "第一行一个整数 $n$，表示点的个数。\n\n接下来 $n$ 行，第 $i+1$ 行两个实数 $x,y$，表示 $A_i$ 的横、纵坐标。\n\n接下来 $n$ 行，第 $i+n+1$ 行两个实数 $x,y$，表示 $B_i$ 的横、纵坐标。", "outputFormat": "第一行一个整数 $k$ ，表示最少的步数。\n\n接下来 $k$ 行，第 $i+1$ 行三个实数 $A,B,C$，表示第 $i$ 次轴对称变换的轴为直线 $Ax+By+C=0$。", "hint": "## 样例解释\n![](https://cdn.luogu.com.cn/upload/image_hosting/8msdygxi.png)\n## 提示\n对于直线 $Ax+By+C=0$，如果 $B$ 非零，那么它就是一次函数 $y=-\\dfrac ABx-\\dfrac CB$ 的图像；否则，它表示一条垂直于 $x$ 轴的直线 $x=-\\dfrac CA$。\n\n本题带有 $\\text{SPJ}$。**因为某种原因，本题不提供** $\\text{SPJ}$ **给选手。**\n\n对于每个测试点，如果你的 $k$ 正确，则获得 $30\\%$ 的分数；\n\n接下来，我们将对 $A_1,A_2,\\cdots,A_n$ 分别进行你给的 $k$ 次轴对称变换，记 $A_i$ 得到的点为 $C_i$。如果对于所有的 $i$，$B_i$ 与 $C_i$ 的 $x,y$ 坐标之差的绝对值都不超过 $10^{-2}$，则你获得 $100\\%$ 的分数。\n\n如果你只想输出 $k$，也请在后面随意输出一些值，防止 $\\text{UKE}$。\n## 数据范围\n\n| 测试点编号 | $n=$ | 构造数据时翻折的次数 |\n| ---------- | ---- | -------------------- |\n| 1,2        | $1$  | $\\le1$               |\n| 3,4        | $2$  | $\\le10$              |\n| 5,6        | $5$  | $\\le10^3$            |\n| 7,8,9,10   | $10$ | $\\le10^5$            |\n\n对于所有数据，$1\\le n\\le10$，$|x|,|y|\\le 10^5$。\n\n所有数据点已经经过 $\\text{SPJ}$ 验证无误。 \n\n请保证你的输出中的所有 $A,B,C$ 满足 $|A|,|B|,|C|\\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P6028", "type": "P", "difficulty": 5, "samples": [["2\n", "2.5000000000"], ["5", "6.7833333333"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["数学", "2020", "Special Judge", "O2优化", "调和级数", "整除分块"], "title": "算术", "background": "小 W 去上算术课了。", "description": "> 众所周知，高斯在小学的时候，有一天他的数学老师留了一道题：$1+2+\\cdots+100=?$，他认为学生们算 $100$ 个数相加要算很久，然后就准备溜去喝咖啡，但是这个时候高斯却举手说他算完了——他用了我们今天众所周知的等差数列求和公式。\n\n但是，这个算术课的老师就像高斯的老师一样不负责任，他在黑板上留了一道算术题就溜去泡妹子了。但小 W 可没高斯那么聪明，而且这个式子看起来没有巧算方法。于是，他通过电话联系上了学 $\\text{OI}$ 的你，希望你给他帮助。作为回报，他会给你 $100$ 分作为奖励。\n\n具体来讲，黑板上的式子是这样的：\n\n设 $n$ 的质因数分解结果为 $n=\\prod\\limits_{i=1}^kp_i^{\\alpha_i}$，则定义 $f(n)=\\prod\\limits_{i=1}^k{\\dfrac{p_i^{\\alpha_i+1}-1}{p_i^{\\alpha_i+1}-p_i^{\\alpha_i}}}$，求 $\\sum\\limits_{i=1}^nf(i)$ 的值（精度要求参见提示与说明）。\n\n**注意：特别地，我们定义** $f(1)=1$。", "inputFormat": "一行一个整数 $n$，意义如上。", "outputFormat": "一行一个实数表示结果。", "hint": "样例二解释：$f(1)=1,f(2)=\\dfrac{2^2-1}{2^2-2^1}=1.5,f(3)=\\dfrac{3^2-1}{3^2-3^1}=1.3333333333,f(4)=\\dfrac{2^3-1}{2^3-2^2}=1.75,f(5)=\\dfrac{5^2-1}{5^2-5^1}=1.2$。\n********\n本题带有 $\\text{SPJ}$。设你的答案为 $a$，标准答案为 $b$。  \n如果 $ |{a-b}|\\le \\min(\\dfrac b{10^4},10) $，则获得这个测试点的所有分数；  \n否则，如果$|{a-b}|\\le \\min(\\dfrac b{10^3},100)$，则获得这个测试点的分数的 $40\\%$；  \n否则，你将不会获得任何分数。  \n标准答案将会保留 10 位小数。  \n**注意：虽然此题对精度要求较低，但仍建议用更为精确的`long double`存储答案。**\n********\n数据范围：  \n对于 $10\\%$ 的数据，$n\\le10$。  \n对于 $30\\%$ 的数据，$n\\le10^3$。  \n对于 $60\\%$ 的数据，$n\\le10^7$。  \n对于 $100\\%$ 的数据，$1\\le n\\le10^{13}$。", "locale": "zh-CN", "translations": {"en": {"title": "Arithmetic", "background": "Little W went to an arithmetic class.", "description": "> As everyone knows, when Gauss was in elementary school, one day his math teacher gave a problem: $1+2+\\cdots+100=?$. He thought the students would take a long time to add $100$ numbers, so he planned to slip away for coffee. But at that moment, Gauss raised his hand and said he was done—he used the arithmetic progression sum formula that we all know today.\n\nHowever, the arithmetic teacher in this class is just as irresponsible as Gauss’s teacher. After leaving an arithmetic problem on the blackboard, he ran off to flirt. But Little W is not as smart as Gauss, and this expression does not seem to have any clever trick. So he called you, who study $\\text{OI}$, hoping you can help him. In return, he will give you $100$ points as a reward.\n\nSpecifically, the expression on the blackboard is:\n\nLet the prime factorization of $n$ be $n=\\prod\\limits_{i=1}^kp_i^{\\alpha_i}$. Define $f(n)=\\prod\\limits_{i=1}^k{\\dfrac{p_i^{\\alpha_i+1}-1}{p_i^{\\alpha_i+1}-p_i^{\\alpha_i}}}$. Find the value of $\\sum\\limits_{i=1}^nf(i)$ (see the Hint and Notes for precision requirements).\n\n**Note: In particular, we define** $f(1)=1$.", "inputFormat": "One line with an integer $n$, as described above.", "outputFormat": "One line with a real number representing the result.", "hint": "Explanation of Sample 2: $f(1)=1,f(2)=\\dfrac{2^2-1}{2^2-2^1}=1.5,f(3)=\\dfrac{3^2-1}{3^2-3^1}=1.3333333333,f(4)=\\dfrac{2^3-1}{2^3-2^2}=1.75,f(5)=\\dfrac{5^2-1}{5^2-5^1}=1.2$.\n********\nThis problem uses $\\text{SPJ}$. Let your answer be $a$, and the standard answer be $b$.  \nIf $ |{a-b}|\\le \\min(\\dfrac b{10^4},10) $, you will get full score for this test point;  \notherwise, if $|{a-b}|\\le \\min(\\dfrac b{10^3},100)$, you will get $40\\%$ of the score for this test point;  \notherwise, you will get no score.  \nThe standard answer will keep 10 digits after the decimal point.  \n**Note: Although the precision requirement is not strict, it is still recommended to use more accurate `long double` to store the answer.**\n********\nConstraints:  \nFor $10\\%$ of the testdata, $n\\le10$.  \nFor $30\\%$ of the testdata, $n\\le10^3$.  \nFor $60\\%$ of the testdata, $n\\le10^7$.  \nFor $100\\%$ of the testdata, $1\\le n\\le10^{13}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "算术", "background": "小 W 去上算术课了。", "description": "> 众所周知，高斯在小学的时候，有一天他的数学老师留了一道题：$1+2+\\cdots+100=?$，他认为学生们算 $100$ 个数相加要算很久，然后就准备溜去喝咖啡，但是这个时候高斯却举手说他算完了——他用了我们今天众所周知的等差数列求和公式。\n\n但是，这个算术课的老师就像高斯的老师一样不负责任，他在黑板上留了一道算术题就溜去泡妹子了。但小 W 可没高斯那么聪明，而且这个式子看起来没有巧算方法。于是，他通过电话联系上了学 $\\text{OI}$ 的你，希望你给他帮助。作为回报，他会给你 $100$ 分作为奖励。\n\n具体来讲，黑板上的式子是这样的：\n\n设 $n$ 的质因数分解结果为 $n=\\prod\\limits_{i=1}^kp_i^{\\alpha_i}$，则定义 $f(n)=\\prod\\limits_{i=1}^k{\\dfrac{p_i^{\\alpha_i+1}-1}{p_i^{\\alpha_i+1}-p_i^{\\alpha_i}}}$，求 $\\sum\\limits_{i=1}^nf(i)$ 的值（精度要求参见提示与说明）。\n\n**注意：特别地，我们定义** $f(1)=1$。", "inputFormat": "一行一个整数 $n$，意义如上。", "outputFormat": "一行一个实数表示结果。", "hint": "样例二解释：$f(1)=1,f(2)=\\dfrac{2^2-1}{2^2-2^1}=1.5,f(3)=\\dfrac{3^2-1}{3^2-3^1}=1.3333333333,f(4)=\\dfrac{2^3-1}{2^3-2^2}=1.75,f(5)=\\dfrac{5^2-1}{5^2-5^1}=1.2$。\n********\n本题带有 $\\text{SPJ}$。设你的答案为 $a$，标准答案为 $b$。  \n如果 $ |{a-b}|\\le \\min(\\dfrac b{10^4},10) $，则获得这个测试点的所有分数；  \n否则，如果$|{a-b}|\\le \\min(\\dfrac b{10^3},100)$，则获得这个测试点的分数的 $40\\%$；  \n否则，你将不会获得任何分数。  \n标准答案将会保留 10 位小数。  \n**注意：虽然此题对精度要求较低，但仍建议用更为精确的`long double`存储答案。**\n********\n数据范围：  \n对于 $10\\%$ 的数据，$n\\le10$。  \n对于 $30\\%$ 的数据，$n\\le10^3$。  \n对于 $60\\%$ 的数据，$n\\le10^7$。  \n对于 $100\\%$ 的数据，$1\\le n\\le10^{13}$。", "locale": "zh-CN"}}}
{"pid": "P6029", "type": "P", "difficulty": 7, "samples": [["5 5 2\n1 2 10\n2 5 10\n1 3 4\n3 4 2\n4 5 1", "3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2010", "各省省选", "江苏"], "title": "[JSOI2010] 旅行", "background": "", "description": "WJJ 喜欢旅游，这次她打算去一个据说有很多漂亮瀑布的山谷玩。\n\nWJJ 事先得到了一张地图，上面标注了 $N$ 个小动物的聚居地，也就是一个个的小村落。其中第 $1$ 个村庄是 WJJ 现在住的地方，第 $N$ 个村庄是 WJJ 打算去的地方。\n\n这些村庄之间有 $M$ 条双向道路连接着，第 $i$ 条双向道路恰好直接连接两个小村庄 $A_i$，$B_i$，长度为 $C_i$。道路有的是隧道，有的是栈桥，地图上那些看起来在村庄之外交叉的路实际上并不相交——也就是说，如果把这些小村落和双向道路构成的道路网看作图论意义上的图，我们不保证它是平面图，也不保证它没有重边。不过，有一点还是可以保证的：WJJ  细心地验证过，从它居住的村落一定能走到她想去的那个山谷。\n\n在 WJJ 所在的神奇世界中，每只小动物都可以借助仙人掌来施放魔法，其中之一是，交换世界中任意两条双向道路的长度，同时保持其他道路的长度不变。按 WJJ 目前的魔法水平，她最多能使用 $K$ 次这种道路长度交换魔法。可惜的是，由于仙人掌刺比较多，WJJ 并不打算带着它旅行，于是她会在家里完成想要的道路交换后再出门。\n\n假设 WJJ 的旅行途中不会有其他小动物进行道路交换来破坏她设计好的路线。为了尽快达到目的地，WJJ 希望她需要走的总距离越短越好。也就是说，使用最多 $K$ 次魔法后，从村落 $1$ 到村落 $N$ 的最短距离是多少？", "inputFormat": "第一行为 $3$ 个用空格隔开的整数 $N,M,K$。\n\n接下来 $M$ 行，每行 $3$ 个整数，用空格隔开，分别表示 $A_i,B_i,C_i$。", "outputFormat": "一个整数，表示使用最多 $K$ 次魔法后，村落 $1$ 和村落 $N$ 之间的最短距离。", "hint": "### 样例解释\n\n一个可行的方案是，对调第 $1$ 条边和第 $4$ 条边的长度，再对调第 $2$ 条边和第 $5$ 条边的长度。对调后的最短路径为 $1\\rightarrow 2\\rightarrow 5$，长度为 $3$。可以证明，没有比这更优的方案了。\n\n### 数据范围\n\n对于 $100\\%$ 的数据，$1\\leq N\\leq 50$，$1\\leq M\\leq 150$，$1\\leq K\\leq 20$，$1\\leq A_i,B_i\\leq N$，$A_i\\neq B_i$，$1\\leq C_i\\leq 1000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JSOI2010] 旅行", "background": "", "description": "WJJ 喜欢旅游，这次她打算去一个据说有很多漂亮瀑布的山谷玩。\n\nWJJ 事先得到了一张地图，上面标注了 $N$ 个小动物的聚居地，也就是一个个的小村落。其中第 $1$ 个村庄是 WJJ 现在住的地方，第 $N$ 个村庄是 WJJ 打算去的地方。\n\n这些村庄之间有 $M$ 条双向道路连接着，第 $i$ 条双向道路恰好直接连接两个小村庄 $A_i$，$B_i$，长度为 $C_i$。道路有的是隧道，有的是栈桥，地图上那些看起来在村庄之外交叉的路实际上并不相交——也就是说，如果把这些小村落和双向道路构成的道路网看作图论意义上的图，我们不保证它是平面图，也不保证它没有重边。不过，有一点还是可以保证的：WJJ  细心地验证过，从它居住的村落一定能走到她想去的那个山谷。\n\n在 WJJ 所在的神奇世界中，每只小动物都可以借助仙人掌来施放魔法，其中之一是，交换世界中任意两条双向道路的长度，同时保持其他道路的长度不变。按 WJJ 目前的魔法水平，她最多能使用 $K$ 次这种道路长度交换魔法。可惜的是，由于仙人掌刺比较多，WJJ 并不打算带着它旅行，于是她会在家里完成想要的道路交换后再出门。\n\n假设 WJJ 的旅行途中不会有其他小动物进行道路交换来破坏她设计好的路线。为了尽快达到目的地，WJJ 希望她需要走的总距离越短越好。也就是说，使用最多 $K$ 次魔法后，从村落 $1$ 到村落 $N$ 的最短距离是多少？", "inputFormat": "第一行为 $3$ 个用空格隔开的整数 $N,M,K$。\n\n接下来 $M$ 行，每行 $3$ 个整数，用空格隔开，分别表示 $A_i,B_i,C_i$。", "outputFormat": "一个整数，表示使用最多 $K$ 次魔法后，村落 $1$ 和村落 $N$ 之间的最短距离。", "hint": "### 样例解释\n\n一个可行的方案是，对调第 $1$ 条边和第 $4$ 条边的长度，再对调第 $2$ 条边和第 $5$ 条边的长度。对调后的最短路径为 $1\\rightarrow 2\\rightarrow 5$，长度为 $3$。可以证明，没有比这更优的方案了。\n\n### 数据范围\n\n对于 $100\\%$ 的数据，$1\\leq N\\leq 50$，$1\\leq M\\leq 150$，$1\\leq K\\leq 20$，$1\\leq A_i,B_i\\leq N$，$A_i\\neq B_i$，$1\\leq C_i\\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P6030", "type": "P", "difficulty": 6, "samples": [["6 6 1 6\n1 2\n1 3\n2 4\n3 5\n4 6\n5 6", "3.000"], ["9 12 1 9\n1 2\n2 3\n3 1\n3 4\n3 7\n4 5\n5 6\n6 4\n6 7\n7 8\n8 9\n9 7", "9.500"], ["2 0 1 2", "INF"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "各省省选", "山东", "拓扑排序", "Tarjan", "期望", "高斯消元"], "title": "[SDOI2012] 走迷宫", "background": null, "description": "Morenan 被困在了一个迷宫里。迷宫可以视为 $n$ 个点 $m$ 条边的有向图，其中 Morenan 处于起点 $s$，迷宫的终点设为 $t$。可惜的是，Morenan 非常的脑小，他只会从一个点出发随机沿着一条从该点出发的有向边，到达另一个点。这样，Morenan 走的步数可能很长，也可能是无限，更可能到不了终点。若到不了终点，则步数视为无穷大。但你必须想方设法求出 Morenan 所走步数的期望值。", "inputFormat": "第一行四个整数，$n,m,s,t$。\n\n接下来 $m$ 行，每行两个整数 $u, v$ ，表示有一条从 $u$ 到 $v$ 的边。", "outputFormat": "一个浮点数，保留小数点后 $3$ 位，为步数的期望值。若期望值为无穷大，则输出 `INF`。", "hint": "| 测试点 | $n\\leq$ | $m\\leq$ |\n| :----------: | :----------: | :----------: |\n| $1\\sim 6$ | $10$ | $100$ |\n| $7\\sim 12$ | $200$ | $10^4$ |\n| $13\\sim 20$ | $10^4$ | $10^6$ |\n\n另外，均匀分布着 $40\\%$ 的数据，图中没有环，也没有自环。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 10^4$，$0\\leq m \\leq 10^6$，**保证强连通分量的大小不超过** $\\boldsymbol{100}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[SDOI2012] 走迷宫", "background": null, "description": "Morenan 被困在了一个迷宫里。迷宫可以视为 $n$ 个点 $m$ 条边的有向图，其中 Morenan 处于起点 $s$，迷宫的终点设为 $t$。可惜的是，Morenan 非常的脑小，他只会从一个点出发随机沿着一条从该点出发的有向边，到达另一个点。这样，Morenan 走的步数可能很长，也可能是无限，更可能到不了终点。若到不了终点，则步数视为无穷大。但你必须想方设法求出 Morenan 所走步数的期望值。", "inputFormat": "第一行四个整数，$n,m,s,t$。\n\n接下来 $m$ 行，每行两个整数 $u, v$ ，表示有一条从 $u$ 到 $v$ 的边。", "outputFormat": "一个浮点数，保留小数点后 $3$ 位，为步数的期望值。若期望值为无穷大，则输出 `INF`。", "hint": "| 测试点 | $n\\leq$ | $m\\leq$ |\n| :----------: | :----------: | :----------: |\n| $1\\sim 6$ | $10$ | $100$ |\n| $7\\sim 12$ | $200$ | $10^4$ |\n| $13\\sim 20$ | $10^4$ | $10^6$ |\n\n另外，均匀分布着 $40\\%$ 的数据，图中没有环，也没有自环。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 10^4$，$0\\leq m \\leq 10^6$，**保证强连通分量的大小不超过** $\\boldsymbol{100}$。", "locale": "zh-CN"}}}
{"pid": "P6031", "type": "P", "difficulty": 7, "samples": [["1234 2345 3456", "398700213"], ["998244352 1337 5000", "326459680"], ["233333333 114514 9982443", "825888958"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "递推", "期望"], "title": "CF1278F Cards 加强版", "background": "[原题链接](https://www.luogu.com.cn/problem/CF1278F)", "description": "有 $m$ 张牌，其中有一张是王牌。将这些牌均匀随机打乱 $n$ 次，设有 $x$ 次第一张为王牌，求 $x^k$ 的期望值。\n\n答案对 $998244353$ 取模。", "inputFormat": "一行三个正整数 $n,m,k$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "【数据范围】  \n对于 $20\\%$ 的数据，$1\\le k \\le 5000$；  \n对于 $40\\%$ 的数据，$1\\le k \\le 10^5$；  \n对于 $100\\%$ 的数据，$1\\le k \\le 10^7$，$1\\le n,m \\le 998244352$。\n\nSolution：iostream  \nData：NaCly\\_Fish", "locale": "zh-CN", "translations": {"zh-CN": {"title": "CF1278F Cards 加强版", "background": "[原题链接](https://www.luogu.com.cn/problem/CF1278F)", "description": "有 $m$ 张牌，其中有一张是王牌。将这些牌均匀随机打乱 $n$ 次，设有 $x$ 次第一张为王牌，求 $x^k$ 的期望值。\n\n答案对 $998244353$ 取模。", "inputFormat": "一行三个正整数 $n,m,k$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "【数据范围】  \n对于 $20\\%$ 的数据，$1\\le k \\le 5000$；  \n对于 $40\\%$ 的数据，$1\\le k \\le 10^5$；  \n对于 $100\\%$ 的数据，$1\\le k \\le 10^7$，$1\\le n,m \\le 998244352$。\n\nSolution：iostream  \nData：NaCly\\_Fish", "locale": "zh-CN"}}}
{"pid": "P6032", "type": "P", "difficulty": 4, "samples": [["5 2 3\n0 5\n1 3\n0 2\n1 4\n1 5", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["递推"], "title": "选择客栈 加强版", "background": "", "description": "丽江河边有 $n$ 家很有特色的客栈，客栈按照其位置顺序从 $1$ 到 $n$ 编号。\n\n每家客栈都按照某一种色调进行装饰（总共 $k$ 种，用整数 $0 \\sim k-1$ 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。\n\n两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。\n\n晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 $p$ 。\n\n他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 $p$ 元的咖啡店小聚。 ", "inputFormat": "输入共 $n+1$ 行。\n\n第一行三个整数 $n,k,p$，每两个整数之间用一个空格隔开，分别表示客栈的个数，色调的数目和能接受的最低消费的最高值。\n\n接下来的 $n$ 行，第 $i+1$ 行两个整数，之间用一个空格隔开，分别表示 $i$ 号客栈的装饰色调和 $i$ 号客栈的咖啡店的最低消费。", "outputFormat": "输出一行一个整数，表示可选的住宿方案的总数。", "hint": "【样例解释】 \n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|}\\hline\n\\textsf{客栈编号} & \\text{①} & \\text{②} & \\text{③} & \\text{④} & \\text{⑤} \\\\\\hline\n\\textsf{色调} & 0 & 1 & 0 & 1 & 1 \\\\\\hline\n\\textsf{最低消费} & 5 & 3 & 2 & 4 & 5 \\\\ \\hline\n\\end{array}$$\n\n\n二人要住同样色调的客栈，所有可选的住宿方案包括：住客栈①③，②④，②⑤，④⑤。\n\n但是若选择住 ④⑤ 号客栈的话，④⑤ 号客栈之间的咖啡店的最低消费是 $4$，而两人能承受的最低消费是 $3$ 元，所以不满足要求。因此只有前 $3$ 种方案可选。\n\n【数据范围】  \n对于 $25\\%$ 的数据，$n\\leq 100$；  \n对于 $40\\%$ 的数据，$n\\leq 1000$；   \n对于 $80\\%$ 的数据，$n\\leq 2 \\times 10^5$，$k \\leq 50$；   \n对于 $100\\%$ 的数据，$2\\leq n\\leq2\\times 10^6$，$1 \\le k\\leq 10^4$，$0\\leq p\\leq 100$，$0\\leq$ 最低消费 $\\leq 100$ 。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "选择客栈 加强版", "background": "", "description": "丽江河边有 $n$ 家很有特色的客栈，客栈按照其位置顺序从 $1$ 到 $n$ 编号。\n\n每家客栈都按照某一种色调进行装饰（总共 $k$ 种，用整数 $0 \\sim k-1$ 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。\n\n两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。\n\n晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 $p$ 。\n\n他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 $p$ 元的咖啡店小聚。 ", "inputFormat": "输入共 $n+1$ 行。\n\n第一行三个整数 $n,k,p$，每两个整数之间用一个空格隔开，分别表示客栈的个数，色调的数目和能接受的最低消费的最高值。\n\n接下来的 $n$ 行，第 $i+1$ 行两个整数，之间用一个空格隔开，分别表示 $i$ 号客栈的装饰色调和 $i$ 号客栈的咖啡店的最低消费。", "outputFormat": "输出一行一个整数，表示可选的住宿方案的总数。", "hint": "【样例解释】 \n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|c|c|}\\hline\n\\textsf{客栈编号} & \\text{①} & \\text{②} & \\text{③} & \\text{④} & \\text{⑤} \\\\\\hline\n\\textsf{色调} & 0 & 1 & 0 & 1 & 1 \\\\\\hline\n\\textsf{最低消费} & 5 & 3 & 2 & 4 & 5 \\\\ \\hline\n\\end{array}$$\n\n\n二人要住同样色调的客栈，所有可选的住宿方案包括：住客栈①③，②④，②⑤，④⑤。\n\n但是若选择住 ④⑤ 号客栈的话，④⑤ 号客栈之间的咖啡店的最低消费是 $4$，而两人能承受的最低消费是 $3$ 元，所以不满足要求。因此只有前 $3$ 种方案可选。\n\n【数据范围】  \n对于 $25\\%$ 的数据，$n\\leq 100$；  \n对于 $40\\%$ 的数据，$n\\leq 1000$；   \n对于 $80\\%$ 的数据，$n\\leq 2 \\times 10^5$，$k \\leq 50$；   \n对于 $100\\%$ 的数据，$2\\leq n\\leq2\\times 10^6$，$1 \\le k\\leq 10^4$，$0\\leq p\\leq 100$，$0\\leq$ 最低消费 $\\leq 100$ 。", "locale": "zh-CN"}}}
{"pid": "P6033", "type": "P", "difficulty": 4, "samples": [["3 \n1 2 9 \n", "15\n"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2004", "NOIP 提高组", "O2优化", "排序", "队列"], "title": "[NOIP 2004 提高组] 合并果子 加强版", "background": "本题除【数据范围与约定】外与 [P1090](https://www.luogu.com.cn/problem/P1090) **完  全  一  致**。", "description": "在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。\n\n每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $(n - 1)$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。\n\n因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。\n\n例如有 $3$ 堆果子，数目依次为 $1,~2,~9$。可以先将 $1$、$2$ 堆合并，新堆数目为 $3$，耗费体力为 $3$。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$，耗费体力为 $12$。所以多多总共耗费体力为 $3+12=15$。可以证明 $15$ 为最小的体力耗费值。\n", "inputFormat": "输入的第一行是一个整数 $n$，代表果子的堆数。\\\n输入的第二行有 $n$ 个用空格隔开的整数，第 $i$ 个整数代表第 $i$ 堆果子的个数 $a_i$。", "outputFormat": "输出一行一个整数，表示最小耗费的体力值。", "hint": "**【数据规模与约定】**\n\n**本题采用多测试点捆绑测试，共有四个子任务**。\n\n- Subtask 1（10 points）：$1 \\leq n \\leq 8$。\n- Subtask 2（20 points）：$1 \\leq n \\leq 10^3$。\n- Subtask 3（30 points）：$1 \\leq n \\leq 10^5$。\n- Subtask 4（40 points）：$1 \\leq n \\leq 10^7$。\n\n对于全部的测试点，保证 $1 \\leq a_i \\leq 10^5$。\n\n**【提示】**\n\n- 请注意常数因子对程序效率造成的影响。\n- 请使用类型合适的变量来存储本题的结果。\n- 本题输入规模较大，请注意数据读入对程序效率造成的影响。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOIP 2004 提高组] 合并果子 加强版", "background": "本题除【数据范围与约定】外与 [P1090](https://www.luogu.com.cn/problem/P1090) **完  全  一  致**。", "description": "在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。\n\n每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $(n - 1)$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。\n\n因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。\n\n例如有 $3$ 堆果子，数目依次为 $1,~2,~9$。可以先将 $1$、$2$ 堆合并，新堆数目为 $3$，耗费体力为 $3$。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$，耗费体力为 $12$。所以多多总共耗费体力为 $3+12=15$。可以证明 $15$ 为最小的体力耗费值。\n", "inputFormat": "输入的第一行是一个整数 $n$，代表果子的堆数。\\\n输入的第二行有 $n$ 个用空格隔开的整数，第 $i$ 个整数代表第 $i$ 堆果子的个数 $a_i$。", "outputFormat": "输出一行一个整数，表示最小耗费的体力值。", "hint": "**【数据规模与约定】**\n\n**本题采用多测试点捆绑测试，共有四个子任务**。\n\n- Subtask 1（10 points）：$1 \\leq n \\leq 8$。\n- Subtask 2（20 points）：$1 \\leq n \\leq 10^3$。\n- Subtask 3（30 points）：$1 \\leq n \\leq 10^5$。\n- Subtask 4（40 points）：$1 \\leq n \\leq 10^7$。\n\n对于全部的测试点，保证 $1 \\leq a_i \\leq 10^5$。\n\n**【提示】**\n\n- 请注意常数因子对程序效率造成的影响。\n- 请使用类型合适的变量来存储本题的结果。\n- 本题输入规模较大，请注意数据读入对程序效率造成的影响。\n\n", "locale": "zh-CN"}}}
{"pid": "P6034", "type": "P", "difficulty": 5, "samples": [["2", "2"], ["42", "274"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2020"], "title": "Ryoku 与最初之人笔记", "background": "Ryoku 在阅读「最初之人」的笔记的时候，发现了一个有趣的运算：$\\rm xor$，这个运算的输入是两个数，输出是一个数，对应的运算时将输入的两个数化为二进制，再把每一位进行比较，若相同则输出的二进制中的这一位为 $0$，否则为 $1$。 \n\n在关于运算 $\\text{xor}$ 笔记的下面有一道习题。Ryoku 很快就得出了答案，她想要考考你。", "description": "Ryoku 向你复述了题目：求：\n\n$$\\sum_{a = 0}^n \\sum_{b = a + 1}^n [a\\equiv b\\pmod {a \\text{ xor } b}]$$\n\n即：求满足 $a\\equiv b\\pmod {a \\text{ xor } b}$，且 $a,b$ 均为小于等于 $n$ 的非负整数，$a<b$，的有序二元组 $(a,b)$ 个数。", "inputFormat": "输入包含一个整数 $n$。", "outputFormat": "输出包含一个整数，为上式的值，答案对 $10^9 + 7$ 取模。", "hint": "**【样例 1 说明】**\n\n符合题意的数对 $(a,b)$ 的有：$(0,1), (0,2)$。\n\n---\n\n**【数据规模与约定】**\n\n对于 $20\\%$ 的数据，$n\\le 10^3$。  \n对于 $60\\%$ 的数据，$n\\le 10^6$。  \n对于 $70\\%$ 的数据，$n\\le 10^9$。  \n对于 $100\\%$ 的数据，$2\\le n \\le 10^{18}$。  ", "locale": "zh-CN", "translations": {"en": {"title": "Ryoku and the Notes of the First Person", "background": "When Ryoku was reading the notes of the “First Person”, she found an interesting operation: $\\rm xor$. This operation takes two numbers as input and outputs one number. It works by converting the two input numbers into binary, then comparing each bit: if the bits are the same, that bit in the output is $0$; otherwise it is $1$.\n\nBelow the notes about the $\\text{xor}$ operation, there is an exercise. Ryoku quickly got the answer, and she wants to test you.", "description": "Ryoku retold the problem to you: compute:\n\n$$\\sum_{a = 0}^n \\sum_{b = a + 1}^n [a\\equiv b\\pmod {a \\text{ xor } b}]$$\n\nThat is, count the number of ordered pairs $(a,b)$ such that $a\\equiv b\\pmod {a \\text{ xor } b}$, where $a,b$ are non-negative integers not greater than $n$, and $a<b$.", "inputFormat": "The input contains one integer $n$.", "outputFormat": "Output one integer, the value of the expression above, modulo $10^9 + 7$.", "hint": "**[Sample 1 Explanation]**\n\nThe pairs $(a,b)$ that satisfy the condition are: $(0,1), (0,2)$.\n\n---\n\n**[Constraints]**\n\nFor $20\\%$ of the testdata, $n\\le 10^3$.  \nFor $60\\%$ of the testdata, $n\\le 10^6$.  \nFor $70\\%$ of the testdata, $n\\le 10^9$.  \nFor $100\\%$ of the testdata, $2\\le n \\le 10^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Ryoku 与最初之人笔记", "background": "Ryoku 在阅读「最初之人」的笔记的时候，发现了一个有趣的运算：$\\rm xor$，这个运算的输入是两个数，输出是一个数，对应的运算时将输入的两个数化为二进制，再把每一位进行比较，若相同则输出的二进制中的这一位为 $0$，否则为 $1$。 \n\n在关于运算 $\\text{xor}$ 笔记的下面有一道习题。Ryoku 很快就得出了答案，她想要考考你。", "description": "Ryoku 向你复述了题目：求：\n\n$$\\sum_{a = 0}^n \\sum_{b = a + 1}^n [a\\equiv b\\pmod {a \\text{ xor } b}]$$\n\n即：求满足 $a\\equiv b\\pmod {a \\text{ xor } b}$，且 $a,b$ 均为小于等于 $n$ 的非负整数，$a<b$，的有序二元组 $(a,b)$ 个数。", "inputFormat": "输入包含一个整数 $n$。", "outputFormat": "输出包含一个整数，为上式的值，答案对 $10^9 + 7$ 取模。", "hint": "**【样例 1 说明】**\n\n符合题意的数对 $(a,b)$ 的有：$(0,1), (0,2)$。\n\n---\n\n**【数据规模与约定】**\n\n对于 $20\\%$ 的数据，$n\\le 10^3$。  \n对于 $60\\%$ 的数据，$n\\le 10^6$。  \n对于 $70\\%$ 的数据，$n\\le 10^9$。  \n对于 $100\\%$ 的数据，$2\\le n \\le 10^{18}$。  ", "locale": "zh-CN"}}}
