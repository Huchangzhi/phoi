{"pid": "P5469", "type": "P", "difficulty": 7, "samples": [["5\n3 3\n3 3\n3 4\n2 2\n3 3", "1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "NOI", "O2优化"], "title": "[NOI2019] 机器人", "background": "时限 3 秒，内存 512MB", "description": "小 R 喜欢研究机器人。\n\n最近，小 R 新研制出了两种机器人，分别是 `P` 型机器人和 `Q` 型机器人。现在他要测试这两种机器人的移动能力，测试在从左到右排成一排的 $n$ 个柱子上进行，柱子用$1 - n$ 依次编号，$i$ 号柱子的高度为一个正整数 $h_i$。机器人**只能在相邻柱子间移动**，即：若机器人当前在 $i$ 号柱子上，它只能尝试移动到 $i - 1$ 号和 $i + 1$ 号柱子上。\n\n每次测试，小 R 会选取一个起点 $s$，并将两种机器人均放置在 $s$ 号柱子上。随后它们会按自己的规则移动。\n\n`P` 型机器人会一直**向左**移动，但它**无法**移动到比起点 $s$ **更高**的柱子上。更具体地，`P` 型机器人在 $l (l \\leq s)$ 号柱子停止移动，**当且仅当**下列两个条件均成立：\n\n- $l = 1$ 或 $h_{l-1} > h_s$。\n\n- 对于满足 $l \\leq j \\leq s$ 的 $j$，有 $h_j \\leq h_s$。\n\n`Q` 型机器人会一直**向右**移动，但它**只能**移动到比起点 $s$ **更低**的柱子上。更具体地，`Q` 型机器人在 $r (r \\geq s)$ 号柱子停止移动，**当且仅当**下列两个条件均成立：\n\n- $r = n$ 或 $h_{r+1} \\geq h_s$。\n\n- 对于满足 $s < j \\leq r$ 的 $j$，有 $h_j < h_s$。\n\n现在，小 R 可以设置每根柱子的高度，$i$ 号柱子可选择的高度范围为 $[A_i, B_i]$，即$A_i \\leq h_i \\leq B_i$。小 R 希望**无论**测试的起点 $s$ 选在哪里，两种机器人移动过的柱子数量的差的绝对值都**小于等于**$2$。他想知道有多少种柱子高度的设置方案满足要求，小 R 认为两种方案不同当且仅当存在一个 $k$，使得两种方案中 $k$ 号柱子的高度不同。请你告诉他满足要求的方案数模 $10^9 + 7$ 后的结果。", "inputFormat": "第一行一个正整数 $n$，表示柱子的数量。\n\n接下来 $n$ 行，第 $i$ 行两个正整数 $A_i, B_i$，分别表示 $i$ 号柱子的最小和最大高度。", "outputFormat": "仅一行一个整数，表示答案模 $10^9 + 7$ 的值。", "hint": "### 更多样例\n\n您可以通过附加文件获得更多样例。\n\n#### 样例 2\n\n见附加文件的 `robot/robot2.in` 与 `robot/robot2.ans`。\n\n#### 样例 3\n\n见附加文件的 `robot/robot3.in` 与 `robot/robot3.ans`。\n\n#### 样例 4\n\n见附加文件的 `robot/robot4.in` 与 `robot/robot4.ans`。\n\n### 样例 1 解释\n\n柱子高度共两种情况：\n\n- 高度为：`3 2 3 2 3`。此时若起点设置在 $5$，`P` 型机器人将停在 $1$ 号柱子，共移动$4$ 个柱子。`Q` 型机器人停在 $5$ 号柱子，共移动 $0$ 个柱子，不符合条件。\n\n- 高度为：`3 2 4 2 3`。此时无论起点选在哪，都满足条件，具体见下表：\n\n::cute-table{tuack}\n\n| 起点编号 | P 型机器人 | Q 型机器人 |\n| :----------: | :----------: | :----------: |\n| $1$ | 停在 $1$ 号柱子，移动过 $0$ 个 | 停在 $2$ 号柱子，移动过 $1$ 个 |\n| $2$ | 停在 $2$ 号柱子，移动过 $0$ 个 | 停在 $2$ 号柱子，移动过 $0$ 个 |\n| $3$ | 停在 $1$ 号柱子，移动过 $2$ 个 |停在 $5$ 号柱子，移动过 $2$ 个  |\n| $4$ | 停在 $4$ 号柱子，移动过 $0$ 个 | 停在 $4$ 号柱子，移动过 $0$ 个 |\n| $5$ |停在 $4$ 号柱子，移动过 $1$ 个  | 停在 $5$ 号柱子，移动过 $0$ 个 |\n\n### 数据范围\n\n对于所有测试数据：$1 \\leq n \\leq 300$ , $1 \\leq A_i \\leq B_i \\leq 10^9$。\n\n每个测试点的具体限制见下表：\n\n::cute-table{tuack}\n\n| 测试点编号 | $n\\le$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1,2$ | $7$ | $A_i=B_i,B_i\\le 7$ |\n| $3,4$ | $7$ | $B_i\\le 7$ |\n| $5,6,7$ | $50$ | $B_i\\le 100$ |\n| $8,9,10$ | $300$ | $B_i\\le 10^4$ |\n| $11,12$ | $50$ | $A_i=1,B_i=10^9$ |\n| $13,14,15$ | $50$ | 无 |\n| $16,17$ | $150$ | ^ |\n| $18,19$ | $200$ | ^ |\n| $20$ | $300$ | ^ |", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2019] Robot.", "background": "Time limit: 3 seconds, memory limit: 512MB.", "description": "Little R likes studying robots.\n\nRecently, Little R developed two new types of robots, `P`-type robots and `Q`-type robots. Now he wants to test their moving abilities. The test is done on $n$ pillars arranged in a line from left to right, numbered $1 - n$ in order. The height of pillar $i$ is a positive integer $h_i$. Robots **can only move between adjacent pillars**, that is: if a robot is currently on pillar $i$, it can only try to move to pillar $i - 1$ and pillar $i + 1$.\n\nIn each test, Little R chooses a starting point $s$ and places both types of robots on pillar $s$. Then they move according to their own rules.\n\nThe `P`-type robot keeps moving **to the left**, but it **cannot** move onto a pillar that is **higher** than the starting pillar $s$. More specifically, the `P`-type robot stops at pillar $l \\ (l \\leq s)$ **if and only if** both of the following conditions hold:\n\n- $l = 1$ or $h_{l-1} > h_s$.\n\n- For every $j$ with $l \\leq j \\leq s$, we have $h_j \\leq h_s$.\n\nThe `Q`-type robot keeps moving **to the right**, but it **can only** move onto pillars that are **lower** than the starting pillar $s$. More specifically, the `Q`-type robot stops at pillar $r \\ (r \\geq s)$ **if and only if** both of the following conditions hold:\n\n- $r = n$ or $h_{r+1} \\geq h_s$.\n\n- For every $j$ with $s < j \\leq r$, we have $h_j < h_s$.\n\nNow, Little R can set the height of each pillar. The selectable height range for pillar $i$ is $[A_i, B_i]$, that is, $A_i \\leq h_i \\leq B_i$. Little R hopes that **no matter** where the test starting point $s$ is chosen, the absolute value of the difference between the numbers of pillars moved over by the two robots is always **less than or equal to** $2$. He wants to know how many height-setting schemes satisfy this requirement. Little R considers two schemes different if and only if there exists some $k$ such that the height of pillar $k$ is different in the two schemes. Please output the number of valid schemes modulo $10^9 + 7$.", "inputFormat": "The first line contains a positive integer $n$, representing the number of pillars.\n\nThe next $n$ lines each contain two positive integers $A_i, B_i$, representing the minimum and maximum height of pillar $i$.", "outputFormat": "Output one line with one integer, the answer modulo $10^9 + 7$.", "hint": "### More Samples\n\nYou can get more samples through the additional files.\n\n#### Sample 2\n\nSee `robot/robot2.in` and `robot/robot2.ans` in the additional files.\n\n#### Sample 3\n\nSee `robot/robot3.in` and `robot/robot3.ans` in the additional files.\n\n#### Sample 4\n\nSee `robot/robot4.in` and `robot/robot4.ans` in the additional files.\n\n### Explanation for Sample 1\n\nThere are two possible pillar height settings:\n\n- Heights: `3 2 3 2 3`. If the starting point is set to $5$, the `P`-type robot will stop at pillar $1$, moving across $4$ pillars. The `Q`-type robot stops at pillar $5$, moving across $0$ pillars. This does not satisfy the condition.\n\n- Heights: `3 2 4 2 3`. In this case, no matter where the starting point is chosen, the condition is satisfied. Details are shown in the table below:\n\n::cute-table{tuack}\n\n| Starting index | P-type robot | Q-type robot |\n| :----------: | :----------: | :----------: |\n| $1$ | Stops at pillar $1$, moves across $0$ | Stops at pillar $2$, moves across $1$ |\n| $2$ | Stops at pillar $2$, moves across $0$ | Stops at pillar $2$, moves across $0$ |\n| $3$ | Stops at pillar $1$, moves across $2$ | Stops at pillar $5$, moves across $2$ |\n| $4$ | Stops at pillar $4$, moves across $0$ | Stops at pillar $4$, moves across $0$ |\n| $5$ | Stops at pillar $4$, moves across $1$ | Stops at pillar $5$, moves across $0$ |\n\n### Constraints\n\nFor all testdata: $1 \\leq n \\leq 300$, $1 \\leq A_i \\leq B_i \\leq 10^9$.\n\nThe detailed limits for each test point are shown in the table below:\n\n::cute-table{tuack}\n\n| Test point ID | $n\\le$ | Special property |\n| :----------: | :----------: | :----------: |\n| $1,2$ | $7$ | $A_i=B_i,B_i\\le 7$ |\n| $3,4$ | $7$ | $B_i\\le 7$ |\n| $5,6,7$ | $50$ | $B_i\\le 100$ |\n| $8,9,10$ | $300$ | $B_i\\le 10^4$ |\n| $11,12$ | $50$ | $A_i=1,B_i=10^9$ |\n| $13,14,15$ | $50$ | None. |\n| $16,17$ | $150$ | ^ |\n| $18,19$ | $200$ | ^ |\n| $20$ | $300$ | ^ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2019] 机器人", "background": "时限 3 秒，内存 512MB", "description": "小 R 喜欢研究机器人。\n\n最近，小 R 新研制出了两种机器人，分别是 `P` 型机器人和 `Q` 型机器人。现在他要测试这两种机器人的移动能力，测试在从左到右排成一排的 $n$ 个柱子上进行，柱子用$1 - n$ 依次编号，$i$ 号柱子的高度为一个正整数 $h_i$。机器人**只能在相邻柱子间移动**，即：若机器人当前在 $i$ 号柱子上，它只能尝试移动到 $i - 1$ 号和 $i + 1$ 号柱子上。\n\n每次测试，小 R 会选取一个起点 $s$，并将两种机器人均放置在 $s$ 号柱子上。随后它们会按自己的规则移动。\n\n`P` 型机器人会一直**向左**移动，但它**无法**移动到比起点 $s$ **更高**的柱子上。更具体地，`P` 型机器人在 $l (l \\leq s)$ 号柱子停止移动，**当且仅当**下列两个条件均成立：\n\n- $l = 1$ 或 $h_{l-1} > h_s$。\n\n- 对于满足 $l \\leq j \\leq s$ 的 $j$，有 $h_j \\leq h_s$。\n\n`Q` 型机器人会一直**向右**移动，但它**只能**移动到比起点 $s$ **更低**的柱子上。更具体地，`Q` 型机器人在 $r (r \\geq s)$ 号柱子停止移动，**当且仅当**下列两个条件均成立：\n\n- $r = n$ 或 $h_{r+1} \\geq h_s$。\n\n- 对于满足 $s < j \\leq r$ 的 $j$，有 $h_j < h_s$。\n\n现在，小 R 可以设置每根柱子的高度，$i$ 号柱子可选择的高度范围为 $[A_i, B_i]$，即$A_i \\leq h_i \\leq B_i$。小 R 希望**无论**测试的起点 $s$ 选在哪里，两种机器人移动过的柱子数量的差的绝对值都**小于等于**$2$。他想知道有多少种柱子高度的设置方案满足要求，小 R 认为两种方案不同当且仅当存在一个 $k$，使得两种方案中 $k$ 号柱子的高度不同。请你告诉他满足要求的方案数模 $10^9 + 7$ 后的结果。", "inputFormat": "第一行一个正整数 $n$，表示柱子的数量。\n\n接下来 $n$ 行，第 $i$ 行两个正整数 $A_i, B_i$，分别表示 $i$ 号柱子的最小和最大高度。", "outputFormat": "仅一行一个整数，表示答案模 $10^9 + 7$ 的值。", "hint": "### 更多样例\n\n您可以通过附加文件获得更多样例。\n\n#### 样例 2\n\n见附加文件的 `robot/robot2.in` 与 `robot/robot2.ans`。\n\n#### 样例 3\n\n见附加文件的 `robot/robot3.in` 与 `robot/robot3.ans`。\n\n#### 样例 4\n\n见附加文件的 `robot/robot4.in` 与 `robot/robot4.ans`。\n\n### 样例 1 解释\n\n柱子高度共两种情况：\n\n- 高度为：`3 2 3 2 3`。此时若起点设置在 $5$，`P` 型机器人将停在 $1$ 号柱子，共移动$4$ 个柱子。`Q` 型机器人停在 $5$ 号柱子，共移动 $0$ 个柱子，不符合条件。\n\n- 高度为：`3 2 4 2 3`。此时无论起点选在哪，都满足条件，具体见下表：\n\n::cute-table{tuack}\n\n| 起点编号 | P 型机器人 | Q 型机器人 |\n| :----------: | :----------: | :----------: |\n| $1$ | 停在 $1$ 号柱子，移动过 $0$ 个 | 停在 $2$ 号柱子，移动过 $1$ 个 |\n| $2$ | 停在 $2$ 号柱子，移动过 $0$ 个 | 停在 $2$ 号柱子，移动过 $0$ 个 |\n| $3$ | 停在 $1$ 号柱子，移动过 $2$ 个 |停在 $5$ 号柱子，移动过 $2$ 个  |\n| $4$ | 停在 $4$ 号柱子，移动过 $0$ 个 | 停在 $4$ 号柱子，移动过 $0$ 个 |\n| $5$ |停在 $4$ 号柱子，移动过 $1$ 个  | 停在 $5$ 号柱子，移动过 $0$ 个 |\n\n### 数据范围\n\n对于所有测试数据：$1 \\leq n \\leq 300$ , $1 \\leq A_i \\leq B_i \\leq 10^9$。\n\n每个测试点的具体限制见下表：\n\n::cute-table{tuack}\n\n| 测试点编号 | $n\\le$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1,2$ | $7$ | $A_i=B_i,B_i\\le 7$ |\n| $3,4$ | $7$ | $B_i\\le 7$ |\n| $5,6,7$ | $50$ | $B_i\\le 100$ |\n| $8,9,10$ | $300$ | $B_i\\le 10^4$ |\n| $11,12$ | $50$ | $A_i=1,B_i=10^9$ |\n| $13,14,15$ | $50$ | 无 |\n| $16,17$ | $150$ | ^ |\n| $18,19$ | $200$ | ^ |\n| $20$ | $300$ | ^ |", "locale": "zh-CN"}}}
{"pid": "P5470", "type": "P", "difficulty": 7, "samples": [["5\n1 1 1\n7\n7\n3 2 1\n4 1 2\n1 4 2\n5 2 1\n4 5 5 8 4\n2 1 7 2 7\n6 4 1\n1 5 8 3 2 4\n2 6 9 3 1 7\n7 5 4\n1 6 6 6 5 9 1\n9 5 3 9 1 4 2", "14\n12\n27\n45\n62\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2019", "NOI", "O2优化", "优先队列", "模拟费用流", "反悔贪心"], "title": "[NOI2019] 序列", "background": "", "description": "给定两个长度为 $n$ 的正整数序列 $\\{a_i\\}$ 与 $\\{b_i\\}$，序列的下标为 $1, 2, \\cdots , n$。现在你需要分别对两个序列各指定**恰好** $K$ 个下标，要求**至少**有 $L$ 个下标在两个序列中都被指定，使得这 $2K$ 个下标在序列中对应的元素的总和**最大**。\n\n形式化地说，你需要确定两个长度为 $K$ 的序列 $\\{c_i\\}, \\{d_i\\}$，其中\n$1 \\leq c_1 < c_2 < \\cdots < c_K \\leq n , 1 \\leq d_1 < d_2 < \\cdots < d_K \\leq n$\n\n并要求 $\\left \\lvert \\{c_1, c_2, \\cdots , c_K\\} \\cap \\{d_1, d_2, · · · , d_K\\} \\right \\rvert \\geq L$\n\n目标是最大化 $\\sum^{K}_{i=1} a_{c_i} +\\sum^{K}_{i=1} b_{d_i}$", "inputFormat": "**本题输入文件包含多组数据**。\n\n第一行一个正整数 $T$ 表示数据组数。接下来每三行表示一组数据。\n\n每组数据第一行三个整数 $n, K, L$，变量意义见题目描述。\n\n每组数据第二行 $n$ 个整数表示序列 $\\{a_i\\}$。\n\n每组数据第三行 $n$ 个整数表示序列 $\\{b_i\\}$。", "outputFormat": "对于每组数据输出一行一个整数表示答案。", "hint": "### 更多样例\n\n您可以通过附加文件获得更多样例。\n\n#### 样例 2\n\n见选手目录下的 `sequence/sequence2.in` 与 `sequence/sequence2.ans`。\n\n#### 样例 3\n\n见选手目录下的 `sequence/sequence3.in` 与 `sequence/sequence3.ans`。\n\n### 样例 1 解释\n\n第一组数据选择的下标为：$\\{c_i\\} = \\{1\\} , \\{d_i\\} = \\{1\\}$。\n\n第二组数据选择的下标为：$\\{c_i\\} = \\{1, 3\\} , \\{d_i\\} = \\{2, 3\\}$\n\n第三组数据选择的下标为：$\\{c_i\\} = \\{3, 4\\} , \\{d_i\\} = \\{3, 5\\}$。\n\n第四组数据选择的下标为：$\\{c_i\\} = \\{2, 3, 4, 6\\} , \\{d_i\\} = \\{2, 3, 4, 6\\}$。\n\n第五组数据选择的下标为：$\\{c_i\\} = \\{2, 3, 4, 5, 6\\} , \\{d_i\\} = \\{1, 2, 3, 4, 6\\}$。\n\n### 数据范围\n\n对于所有测试点：$T \\leq 10 , 1 \\leq \\sum n \\leq 10^6, 1 \\leq L \\leq K \\leq n \\leq 2 \\times 10^5, 1 \\leq a_i, b_i \\leq 10^9$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n\\le$ | $\\sum n \\le$ |\n| :----------: | :----------: | :----------: |\n| $1\\sim3$ | $10$ | $3\\times 10^5$ |\n| $4\\sim5$ | $18$ | ^ |\n| $6\\sim7$ | $30$ | ^ |\n| $8\\sim10$ | $150$ | ^ |\n| $11\\sim16$ | $2\\times 10^3$ | ^ |\n| $17\\sim21$ | $2\\times 10^5$ | ^ |\n| $22\\sim25$ | ^ | $10^6$ |", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2019] Sequence", "background": "", "description": "Given two positive integer sequences $\\{a_i\\}$ and $\\{b_i\\}$ of length $n$, where the indices are $1, 2, \\cdots , n$. You now need to choose **exactly** $K$ indices for each sequence, requiring that **at least** $L$ indices are chosen in both sequences, so that the total sum of the corresponding elements of these $2K$ indices is **maximized**.\n\nFormally, you need to determine two sequences $\\{c_i\\}$ and $\\{d_i\\}$ of length $K$, where\n$1 \\leq c_1 < c_2 < \\cdots < c_K \\leq n , 1 \\leq d_1 < d_2 < \\cdots < d_K \\leq n$\n\nand require that $\\left \\lvert \\{c_1, c_2, \\cdots , c_K\\} \\cap \\{d_1, d_2, · · · , d_K\\} \\right \\rvert \\geq L$.\n\nThe goal is to maximize $\\sum^{K}_{i=1} a_{c_i} +\\sum^{K}_{i=1} b_{d_i}$.", "inputFormat": "**This input file contains multiple test cases**.\n\nThe first line contains a positive integer $T$ indicating the number of test cases. Then every three lines describe one test case.\n\nFor each test case, the first line contains three integers $n, K, L$, with meanings as described in the statement.\n\nFor each test case, the second line contains $n$ integers representing the sequence $\\{a_i\\}$.\n\nFor each test case, the third line contains $n$ integers representing the sequence $\\{b_i\\}$.", "outputFormat": "For each test case, output one line containing one integer, the answer.", "hint": "### More Samples\n\nYou can get more samples from the additional files.\n\n#### Sample 2\n\nSee `sequence/sequence2.in` and `sequence/sequence2.ans` in the contestant directory.\n\n#### Sample 3\n\nSee `sequence/sequence3.in` and `sequence/sequence3.ans` in the contestant directory.\n\n### Explanation for Sample 1\n\nIn the first test case, the chosen indices are: $\\{c_i\\} = \\{1\\} , \\{d_i\\} = \\{1\\}$.\n\nIn the second test case, the chosen indices are: $\\{c_i\\} = \\{1, 3\\} , \\{d_i\\} = \\{2, 3\\}$.\n\nIn the third test case, the chosen indices are: $\\{c_i\\} = \\{3, 4\\} , \\{d_i\\} = \\{3, 5\\}$.\n\nIn the fourth test case, the chosen indices are: $\\{c_i\\} = \\{2, 3, 4, 6\\} , \\{d_i\\} = \\{2, 3, 4, 6\\}$.\n\nIn the fifth test case, the chosen indices are: $\\{c_i\\} = \\{2, 3, 4, 5, 6\\} , \\{d_i\\} = \\{1, 2, 3, 4, 6\\}$.\n\n### Constraints\n\nFor all test points: $T \\leq 10 , 1 \\leq \\sum n \\leq 10^6, 1 \\leq L \\leq K \\leq n \\leq 2 \\times 10^5, 1 \\leq a_i, b_i \\leq 10^9$.\n\n::cute-table{tuack}\n\n| Test Point ID | $n\\le$ | $\\sum n \\le$ |\n| :----------: | :----------: | :----------: |\n| $1\\sim3$ | $10$ | $3\\times 10^5$ |\n| $4\\sim5$ | $18$ | ^ |\n| $6\\sim7$ | $30$ | ^ |\n| $8\\sim10$ | $150$ | ^ |\n| $11\\sim16$ | $2\\times 10^3$ | ^ |\n| $17\\sim21$ | $2\\times 10^5$ | ^ |\n| $22\\sim25$ | ^ | $10^6$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2019] 序列", "background": "", "description": "给定两个长度为 $n$ 的正整数序列 $\\{a_i\\}$ 与 $\\{b_i\\}$，序列的下标为 $1, 2, \\cdots , n$。现在你需要分别对两个序列各指定**恰好** $K$ 个下标，要求**至少**有 $L$ 个下标在两个序列中都被指定，使得这 $2K$ 个下标在序列中对应的元素的总和**最大**。\n\n形式化地说，你需要确定两个长度为 $K$ 的序列 $\\{c_i\\}, \\{d_i\\}$，其中\n$1 \\leq c_1 < c_2 < \\cdots < c_K \\leq n , 1 \\leq d_1 < d_2 < \\cdots < d_K \\leq n$\n\n并要求 $\\left \\lvert \\{c_1, c_2, \\cdots , c_K\\} \\cap \\{d_1, d_2, · · · , d_K\\} \\right \\rvert \\geq L$\n\n目标是最大化 $\\sum^{K}_{i=1} a_{c_i} +\\sum^{K}_{i=1} b_{d_i}$", "inputFormat": "**本题输入文件包含多组数据**。\n\n第一行一个正整数 $T$ 表示数据组数。接下来每三行表示一组数据。\n\n每组数据第一行三个整数 $n, K, L$，变量意义见题目描述。\n\n每组数据第二行 $n$ 个整数表示序列 $\\{a_i\\}$。\n\n每组数据第三行 $n$ 个整数表示序列 $\\{b_i\\}$。", "outputFormat": "对于每组数据输出一行一个整数表示答案。", "hint": "### 更多样例\n\n您可以通过附加文件获得更多样例。\n\n#### 样例 2\n\n见选手目录下的 `sequence/sequence2.in` 与 `sequence/sequence2.ans`。\n\n#### 样例 3\n\n见选手目录下的 `sequence/sequence3.in` 与 `sequence/sequence3.ans`。\n\n### 样例 1 解释\n\n第一组数据选择的下标为：$\\{c_i\\} = \\{1\\} , \\{d_i\\} = \\{1\\}$。\n\n第二组数据选择的下标为：$\\{c_i\\} = \\{1, 3\\} , \\{d_i\\} = \\{2, 3\\}$\n\n第三组数据选择的下标为：$\\{c_i\\} = \\{3, 4\\} , \\{d_i\\} = \\{3, 5\\}$。\n\n第四组数据选择的下标为：$\\{c_i\\} = \\{2, 3, 4, 6\\} , \\{d_i\\} = \\{2, 3, 4, 6\\}$。\n\n第五组数据选择的下标为：$\\{c_i\\} = \\{2, 3, 4, 5, 6\\} , \\{d_i\\} = \\{1, 2, 3, 4, 6\\}$。\n\n### 数据范围\n\n对于所有测试点：$T \\leq 10 , 1 \\leq \\sum n \\leq 10^6, 1 \\leq L \\leq K \\leq n \\leq 2 \\times 10^5, 1 \\leq a_i, b_i \\leq 10^9$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n\\le$ | $\\sum n \\le$ |\n| :----------: | :----------: | :----------: |\n| $1\\sim3$ | $10$ | $3\\times 10^5$ |\n| $4\\sim5$ | $18$ | ^ |\n| $6\\sim7$ | $30$ | ^ |\n| $8\\sim10$ | $150$ | ^ |\n| $11\\sim16$ | $2\\times 10^3$ | ^ |\n| $17\\sim21$ | $2\\times 10^5$ | ^ |\n| $22\\sim25$ | ^ | $10^6$ |", "locale": "zh-CN"}}}
{"pid": "P5471", "type": "P", "difficulty": 6, "samples": [["5 3 5 5\n1 1\n3 1\n4 1\n2 2\n3 3\n1 123 1 5 1 5\n1 50 1 5 1 1\n3 10 2 2 2 2", "50\n50\n60\n123\n"]], "limits": {"time": [2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2019", "NOI", "O2优化", "图论建模", "最短路"], "title": "[NOI2019] 弹跳", "background": "原题时限 2s\n\n内存 128MB", "description": "跳蚤国有 $n$ 座城市，分别编号为 $1 - n$，$1$ 号城市为首都。所有城市分布在一个$w \\times h$ 范围的网格上。每座城市都有一个整数坐标 $(x, y) (1 \\leq x \\leq w, 1 \\leq y \\leq h)$，不同城市的坐标不相同。\n\n在跳蚤国中共有 $m$ 个弹跳装置，分别编号为 $1 - m$，其中 $i$ 号弹跳装置位于 $p_i$ 号城市，并具有参数 $t_i, L_i, R_i, D_i, U_i$。利用该弹跳装置，跳蚤可花费 $t_i (t_i > 0)$ 个单位时间，从 $p_i$ 号城市跳至坐标满足 $L_i \\leq x \\leq R_i, D_i \\leq y \\leq U_i (1 \\leq L_i \\leq R_i \\leq w, 1 \\leq D_i \\leq U_i \\leq h)$ 的任意一座城市。需要注意的是，一座城市中可能存在多个弹跳装置，也可能没有弹跳装置。\n\n由于城市间距离较远，跳蚤们必须依靠弹跳装置出行。具体来说，一次出行将经过\n若干座城市，依次经过的城市的编号可用序列 $a_0, a_1, \\cdots , a_k$ 表示；在此次出行中，依次利用的弹跳装置的编号可用序列 $b_1, b_2, \\cdots , b_k$ 表示。其中每座城市可在序列 $\\{a_j\\}$ 中出现任意次，每个弹跳装置也可在序列 $\\{b_j\\}$ 中出现任意次，且满足，对于每个 $j (1 \\leq j \\leq k)$，编号为 $b_j$ 的弹跳装置位于城市 $a_{j-1}$，且跳蚤能通过该弹跳装置跳至城市 $a_j$。我们称这是一次从城市 $a_0$ 到城市 $a_k$ 的出行，其进行了 $k$ 次弹跳，共花费 $\\sum^k_{i=1} t_{b_{i}}$ 个单位时间。\n\n现在跳蚤国王想知道，对于跳蚤国除首都（$1$ 号城市）外的每座城市，从首都出发，到达该城市最少需要花费的单位时间。跳蚤国王保证，对每座城市，均存在从首都到它的出行方案。\n", "inputFormat": "第一行包含四个整数 $n, m,w, h$，变量的具体意义见题目描述。\n\n接下来 $n$ 行，第 $i$ 行包含两个整数 $x_i, y_i$，表示 $i$ 号城市的坐标。\n\n接下来 $m$ 行，第 $i$ 行包含六个整数 $p_i, t_i, L_i, R_i, D_i, U_i$，分别表示 $i$ 号弹跳装置所在的城市编号、弹跳所需的时间、可到达的矩形范围。这些整数的具体意义见题目描述。", "outputFormat": "输出 $n - 1$ 行，第 $i$ 行包含一个整数，表示从跳蚤国首都到 $i + 1$ 号城市最少需要花费的单位时间。\n", "hint": "### 更多样例\n\n您可以通过附加文件获得更多样例。\n\n#### 样例 2\n\n见附加文件中的 `jump/jump2.in` 与 `jump/jump2.ans`。\n\n这组样例的数据范围为 $n = 10^4 , m = 2\\times 10^4 , w = 10^4 , h = 1$。\n\n#### 样例 3\n\n见附加文件中的 `jump/jump3.in` 与 `jump/jump3.ans`。\n\n这组样例的数据范围为 $n = 10^4 , m = 2\\times 10^4 , w = 10^4 , h = 10^4$。\n\n### 数据范围\n\n对于所有测试点和样例满足：\n\n$1 \\leq n \\leq 70000 , 1 \\leq m \\leq 150000 , 1 \\leq w, h \\leq n , 1 \\leq t_i \\leq 10000$。\n\n每个测试点的具体限制见下表。\n\n| 测试点编号 | $1\\le n\\le$ | $1\\le m\\le$ | 特殊限制 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1\\sim8$ | $100$ | $100$ | 无 |\n| $9\\sim13$ | $5\\times 10^4$ | $10^5$ | 每个弹跳装置恰好可达一座城市，且 $L_i=R_i$，$D_i=U_i$ |\n| $14\\sim18$ | $5\\times 10^4$ | $10^5$ | $h=1$ | \n| $19\\sim22$ | $2.5\\times 10^4$ | $5\\times 10^4$ | 无 | \n| $23\\sim25$ | $7\\times 10^4$ | $1.5\\times 10^5$ | 无 | ", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2019] Jumping", "background": "The original time limit is 2 s.\n\nThe memory limit is 128 MB.", "description": "There are $n$ cities in Flea Kingdom, numbered from $1$ to $n$, and city $1$ is the capital. All cities are located on a grid within a $w \\times h$ area. Each city has integer coordinates $(x, y) (1 \\leq x \\leq w, 1 \\leq y \\leq h)$, and no two cities share the same coordinates.\n\nThere are $m$ jumping devices in Flea Kingdom, numbered from $1$ to $m$. Device $i$ is located in city $p_i$ and has parameters $t_i, L_i, R_i, D_i, U_i$. By using this device, a flea can spend $t_i (t_i > 0)$ units of time to jump from city $p_i$ to any city whose coordinates satisfy $L_i \\leq x \\leq R_i, D_i \\leq y \\leq U_i (1 \\leq L_i \\leq R_i \\leq w, 1 \\leq D_i \\leq U_i \\leq h)$. Note that a city may have multiple jumping devices, or none.\n\nBecause cities are far apart, fleas must rely on jumping devices to travel. Specifically, a trip will pass through several cities; the city numbers in order can be written as a sequence $a_0, a_1, \\cdots , a_k$. The jumping device numbers used in order can be written as a sequence $b_1, b_2, \\cdots , b_k$. Each city may appear in the sequence $\\{a_j\\}$ any number of times, and each jumping device may appear in the sequence $\\{b_j\\}$ any number of times. For each $j (1 \\leq j \\leq k)$, device $b_j$ is located in city $a_{j-1}$, and the flea can use this device to jump to city $a_j$. We call this a trip from city $a_0$ to city $a_k$. It makes $k$ jumps in total, and costs $\\sum^k_{i=1} t_{b_{i}}$ units of time.\n\nNow the flea king wants to know, for every city other than the capital (city $1$), the minimum number of time units needed to start from the capital and reach that city. The king guarantees that for every city, there exists at least one trip from the capital to it.", "inputFormat": "The first line contains four integers $n, m, w, h$. The meanings of the variables are described in the statement.\n\nThe next $n$ lines: line $i$ contains two integers $x_i, y_i$, indicating the coordinates of city $i$.\n\nThe next $m$ lines: line $i$ contains six integers $p_i, t_i, L_i, R_i, D_i, U_i$, indicating the city where device $i$ is located, the time needed for the jump, and the reachable rectangular region. The meanings of these integers are described in the statement.", "outputFormat": "Output $n - 1$ lines. Line $i$ contains one integer, representing the minimum number of time units needed to travel from the capital of Flea Kingdom to city $i + 1$.", "hint": "### More Samples\n\nYou can obtain more samples through the additional files.\n\n#### Sample 2\n\nSee `jump/jump2.in` and `jump/jump2.ans` in the additional files.\n\nThe Constraints for this sample are $n = 10^4 , m = 2\\times 10^4 , w = 10^4 , h = 1$.\n\n#### Sample 3\n\nSee `jump/jump3.in` and `jump/jump3.ans` in the additional files.\n\nThe Constraints for this sample are $n = 10^4 , m = 2\\times 10^4 , w = 10^4 , h = 10^4$.\n\n### Constraints\n\nFor all test points and samples:\n\n$1 \\leq n \\leq 70000 , 1 \\leq m \\leq 150000 , 1 \\leq w, h \\leq n , 1 \\leq t_i \\leq 10000$.\n\nThe detailed limits for each test point are shown in the table below.\n\n| Test Point ID | $1\\le n\\le$ | $1\\le m\\le$ | Special Constraints |\n| :----------: | :----------: | :----------: | :----------: |\n| $1\\sim8$ | $100$ | $100$ | None |\n| $9\\sim13$ | $5\\times 10^4$ | $10^5$ | Each jumping device can reach exactly one city, and $L_i=R_i$, $D_i=U_i$ |\n| $14\\sim18$ | $5\\times 10^4$ | $10^5$ | $h=1$ | \n| $19\\sim22$ | $2.5\\times 10^4$ | $5\\times 10^4$ | None | \n| $23\\sim25$ | $7\\times 10^4$ | $1.5\\times 10^5$ | None |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2019] 弹跳", "background": "原题时限 2s\n\n内存 128MB", "description": "跳蚤国有 $n$ 座城市，分别编号为 $1 - n$，$1$ 号城市为首都。所有城市分布在一个$w \\times h$ 范围的网格上。每座城市都有一个整数坐标 $(x, y) (1 \\leq x \\leq w, 1 \\leq y \\leq h)$，不同城市的坐标不相同。\n\n在跳蚤国中共有 $m$ 个弹跳装置，分别编号为 $1 - m$，其中 $i$ 号弹跳装置位于 $p_i$ 号城市，并具有参数 $t_i, L_i, R_i, D_i, U_i$。利用该弹跳装置，跳蚤可花费 $t_i (t_i > 0)$ 个单位时间，从 $p_i$ 号城市跳至坐标满足 $L_i \\leq x \\leq R_i, D_i \\leq y \\leq U_i (1 \\leq L_i \\leq R_i \\leq w, 1 \\leq D_i \\leq U_i \\leq h)$ 的任意一座城市。需要注意的是，一座城市中可能存在多个弹跳装置，也可能没有弹跳装置。\n\n由于城市间距离较远，跳蚤们必须依靠弹跳装置出行。具体来说，一次出行将经过\n若干座城市，依次经过的城市的编号可用序列 $a_0, a_1, \\cdots , a_k$ 表示；在此次出行中，依次利用的弹跳装置的编号可用序列 $b_1, b_2, \\cdots , b_k$ 表示。其中每座城市可在序列 $\\{a_j\\}$ 中出现任意次，每个弹跳装置也可在序列 $\\{b_j\\}$ 中出现任意次，且满足，对于每个 $j (1 \\leq j \\leq k)$，编号为 $b_j$ 的弹跳装置位于城市 $a_{j-1}$，且跳蚤能通过该弹跳装置跳至城市 $a_j$。我们称这是一次从城市 $a_0$ 到城市 $a_k$ 的出行，其进行了 $k$ 次弹跳，共花费 $\\sum^k_{i=1} t_{b_{i}}$ 个单位时间。\n\n现在跳蚤国王想知道，对于跳蚤国除首都（$1$ 号城市）外的每座城市，从首都出发，到达该城市最少需要花费的单位时间。跳蚤国王保证，对每座城市，均存在从首都到它的出行方案。\n", "inputFormat": "第一行包含四个整数 $n, m,w, h$，变量的具体意义见题目描述。\n\n接下来 $n$ 行，第 $i$ 行包含两个整数 $x_i, y_i$，表示 $i$ 号城市的坐标。\n\n接下来 $m$ 行，第 $i$ 行包含六个整数 $p_i, t_i, L_i, R_i, D_i, U_i$，分别表示 $i$ 号弹跳装置所在的城市编号、弹跳所需的时间、可到达的矩形范围。这些整数的具体意义见题目描述。", "outputFormat": "输出 $n - 1$ 行，第 $i$ 行包含一个整数，表示从跳蚤国首都到 $i + 1$ 号城市最少需要花费的单位时间。\n", "hint": "### 更多样例\n\n您可以通过附加文件获得更多样例。\n\n#### 样例 2\n\n见附加文件中的 `jump/jump2.in` 与 `jump/jump2.ans`。\n\n这组样例的数据范围为 $n = 10^4 , m = 2\\times 10^4 , w = 10^4 , h = 1$。\n\n#### 样例 3\n\n见附加文件中的 `jump/jump3.in` 与 `jump/jump3.ans`。\n\n这组样例的数据范围为 $n = 10^4 , m = 2\\times 10^4 , w = 10^4 , h = 10^4$。\n\n### 数据范围\n\n对于所有测试点和样例满足：\n\n$1 \\leq n \\leq 70000 , 1 \\leq m \\leq 150000 , 1 \\leq w, h \\leq n , 1 \\leq t_i \\leq 10000$。\n\n每个测试点的具体限制见下表。\n\n| 测试点编号 | $1\\le n\\le$ | $1\\le m\\le$ | 特殊限制 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1\\sim8$ | $100$ | $100$ | 无 |\n| $9\\sim13$ | $5\\times 10^4$ | $10^5$ | 每个弹跳装置恰好可达一座城市，且 $L_i=R_i$，$D_i=U_i$ |\n| $14\\sim18$ | $5\\times 10^4$ | $10^5$ | $h=1$ | \n| $19\\sim22$ | $2.5\\times 10^4$ | $5\\times 10^4$ | 无 | \n| $23\\sim25$ | $7\\times 10^4$ | $1.5\\times 10^5$ | 无 | ", "locale": "zh-CN"}}}
{"pid": "P5472", "type": "P", "difficulty": 7, "samples": [["4 1 1\n3\n1\n1", "249561090\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "NOI", "O2优化"], "title": "[NOI2019] 斗主地", "background": "时限 4 秒 内存 512MB", "description": "小 S 在和小 F 玩一个叫“斗地主”的游戏。\n\n可怜的小 S 发现自己打牌并打不过小 F，所以他想要在洗牌环节动动手脚。\n\n一副牌一共有 $n$ 张牌，从上到下依次标号为 $1 \\sim n$。标号为 $i$ 的牌**分数**是 $f(i)$。在本题，$f(i)$ 有且仅有两种可能：$f(i) = i$ 或 $f(i) = i^2$。\n\n洗牌的方式和我们日常生活中的比较类似，以下我们用形式化的语言来定义： 洗牌环节一共分 $m$ 轮，这 $m$ 轮洗牌依次进行。第 $i$ 轮洗牌时：\n\n1. 小 S 会拿出从最上面往下数的前 $A_i$ 张牌。这样这副牌就被分成了两堆：第一堆 是最上面的 $A_i$ 张牌，第二堆是剩下的 $n-A_i$ 张牌，且这两堆牌内相对顺序不变。 特别地，当$A_i = n$ 或 $A_i = 0$ 时，有一堆牌是空的。\n2. 接下来对两堆牌进行合并，从而产生新的第三堆牌。当第一堆牌还剩下 $X$ 张，第二堆牌还剩下 $Y$ 张的时候，以 $\\dfrac{X}{X+Y}$ 的概率取出第一堆牌的最下面的牌，并将它 放入新的第三堆牌的最上面， $\\dfrac{Y}{X+Y}$  的概率取出第二堆牌的最下面的牌，并将它放入新的第三堆牌的最上面\n3. 重复操作 $2$，一直取到两堆牌都为空为止。这样我们就完成了一轮洗牌。\n\n因为洗牌过程是随机的，所以小 S 发现自己没法知道某个位置上具体是哪张牌。但小 S 想问你在经历了这 $m$ 轮洗牌后，某个位置上的牌的**期望分数**是多少。小 S 一共会问你 $Q$ 个这样的问题。", "inputFormat": "输入的第一行包含三个正整数 $n, m, type$，分别表示牌的数量，洗牌的轮数与 $f(i)$ 的类型。当 $type = 1$ 时，$f(i) = i$。当 $type = 2$ 时，$f(i) = i^2$。\n\n接下来一行，一共 $m$ 个整数，表示 $A_1 \\sim A_m$。\n\n接下来一行一个正整数 $Q$，表示小 S 的询问个数。 接下来 $Q$ 行，每行一个正整数 $c_i$，表示小 S 想要知道从上往下第 $c_i$ 个位置上的牌的**期望分数**。\n\n保证 $1 \\leq c_i \\leq n$。", "outputFormat": "输出一共 $Q$ 行，每行一个整数，表示答案在模 $998244353$ 意义下的取值。\n\n\n即设答案化为最简分式后的形式为 $\\dfrac{a}\n{b}$，其中 $a$ 和 $b$ 互质。输出整数 $x$ 使得 $bx \\equiv a \\pmod{998244353}$ 且 $0 ≤ x < 998244353$。可以证明这样的整数 $x$ 是唯一的。", "hint": "### 更多样例\n\n您可以通过附加文件获得更多样例。\n\n#### 样例 2\n\n见附加文件中的 `landlords/landlords2.in` 与 `landlords/landlords2.ans`。\n\n#### 样例 3\n\n见附加文件中的 `landlords/landlords3.in` 与 `landlords/landlords3.ans`。\n\n### 样例输入输出 1 解释\n\n- 有 $\\dfrac{1}{4}$ 的概率从上到下的最终结果是 $\\{1, 2, 3, 4\\}$。\n- 有 $\\dfrac{1}{4}$ 的概率从上到下的最终结果是 $\\{1, 2, 4, 3\\}$。\n- 有 $\\dfrac{1}{4}$ 的概率从上到下的最终结果是 $\\{1, 4, 2, 3\\}$。\n- 有 $\\dfrac{1}{4}$ 的概率从上到下的最终结果是 $\\{4, 1, 2, 3\\}$。\n\n所以最终有 $\\dfrac{1}{4}$ 的概率第一个位置是 $4$，有 $\\dfrac{3}\n{4}$ 的概率第一个位置是 $1$，所以第一个位置的期望分数是 $\\dfrac{7}{\n4}$。\n\n为了帮助你们更直观地了解洗牌的过程，我们在下面画出了结果是 $\\{1, 4, 2, 3\\}$ 的过程。\n\n![](https://cdn.luogu.com.cn/upload/pic/64318.png)\n\n### 数据规模与约定\n\n对于全部的测试点，保证 $3\\le n \\le 10^7$，$1\\le m,Q\\le5\\times 10^5$，$0\\le A_i\\le n$，$type\\in \\{1,2\\}$。\n\n每个测试点的具体限制见下表：\n\n| 测试点 | $n$ | $m$ | $type=$ | 其他性质 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\le 10$ | $\\le 1$ | $1$ | 无 |\n| $2$ | $\\le 80$ | $\\le 80$ | $1$ | 无 |\n| $3$ | $\\le 80$ | $\\le 80$ | $2$ | 无 |\n| $4$ | $\\le 100$ | $\\le 5\\times 10^5$ | $2$ | 所有 $A_i$ 相同 |\n| $5$ | $\\le 10^7$ | $\\le 5\\times 10^5$ | $1$ | 无 |\n| $6$ | $\\le 10^7$ | $\\le 5\\times 10^5$ | $1$ | 无 |\n| $7$ | $\\le 10^7$ | $\\le 5\\times 10^5$ | $1$ | 无 |\n| $8$ | $\\le 10^7$ | $\\le 5\\times 10^5$ | $2$ |无  |\n| $9$ | $\\le 10^7$ | $\\le 5\\times 10^5$ | $2$ | 无 |\n| $10$ | $\\le 10^7$ | $\\le 5\\times 10^5$ | $2$  | 无 |\n\n请注意我们并没有保证 $Q\\le n$。\n\n### 提示\n\n这里我们给出离散型随机变量 $X$ 的期望 $\\mathbb{E}[x]$ 的定义：\n\n设离散随机变量 $X$ 的可能值是 $X_1,X_2,\\ldots X_k$，$Pr[X_1],Pr[X_2],\\ldots,Pr[X_k]$ 为 $X$ 取对应值的概率，则 $X$ 的期望为：\n$$\\mathbb{E}[x]=\\sum^k_{i=1}X_i\\times Pr[X_i]$$\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2019] Douzhu Di", "background": "Time limit: 4 seconds. Memory limit: 512MB.", "description": "Xiao S is playing a game called “Dou Dizhu” with Xiao F.\n\nPoor Xiao S finds that he cannot beat Xiao F at playing cards, so he wants to do something during the shuffling stage.\n\nA deck has $n$ cards, numbered from top to bottom as $1 \\sim n$. The **score** of the card numbered $i$ is $f(i)$. In this problem, $f(i)$ has exactly two possibilities: $f(i) = i$ or $f(i) = i^2$.\n\nThe shuffling method is similar to what we do in daily life. We define it formally as follows: the shuffling stage consists of $m$ rounds, performed in order. In round $i$:\n\n1. Xiao S takes the top $A_i$ cards from the deck. Then the deck is split into two piles: the first pile is the top $A_i$ cards, and the second pile is the remaining $n-A_i$ cards, and the relative order within each pile remains unchanged. In particular, when $A_i = n$ or $A_i = 0$, one pile is empty.\n2. Next, merge the two piles to produce a new third pile. When the first pile has $X$ cards left and the second pile has $Y$ cards left, with probability $\\dfrac{X}{X+Y}$ take the bottom card of the first pile and put it on the top of the new third pile; with probability $\\dfrac{Y}{X+Y}$ take the bottom card of the second pile and put it on the top of the new third pile.\n3. Repeat step $2$ until both piles are empty. This completes one round of shuffling.\n\nBecause the shuffling process is random, Xiao S cannot know exactly which card is at a certain position. But after these $m$ rounds of shuffling, Xiao S wants to ask what the **expected score** of the card at a certain position is. Xiao S will ask you $Q$ such questions.", "inputFormat": "The first line contains three positive integers $n, m, type$, representing the number of cards, the number of shuffling rounds, and the type of $f(i)$. When $type = 1$, $f(i) = i$. When $type = 2$, $f(i) = i^2$.\n\nThe next line contains $m$ integers, representing $A_1 \\sim A_m$.\n\nThe next line contains a positive integer $Q$, the number of queries from Xiao S. The next $Q$ lines each contain a positive integer $c_i$, meaning Xiao S wants to know the **expected score** of the card at the $c_i$-th position from top to bottom.\n\nIt is guaranteed that $1 \\leq c_i \\leq n$.", "outputFormat": "Output $Q$ lines. Each line contains one integer, which is the answer modulo $998244353$.\n\nThat is, suppose the answer in lowest terms is $\\dfrac{a}{b}$, where $a$ and $b$ are coprime. Output an integer $x$ such that $bx \\equiv a \\pmod{998244353}$ and $0 \\le x < 998244353$. It can be proven that such an integer $x$ is unique.", "hint": "### More Samples\n\nYou can obtain more samples through the additional files.\n\n#### Sample 2\n\nSee `landlords/landlords2.in` and `landlords/landlords2.ans` in the additional files.\n\n#### Sample 3\n\nSee `landlords/landlords3.in` and `landlords/landlords3.ans` in the additional files.\n\n### Explanation for Sample Input/Output 1\n\n- With probability $\\dfrac{1}{4}$, the final result from top to bottom is $\\{1, 2, 3, 4\\}$.\n- With probability $\\dfrac{1}{4}$, the final result from top to bottom is $\\{1, 2, 4, 3\\}$.\n- With probability $\\dfrac{1}{4}$, the final result from top to bottom is $\\{1, 4, 2, 3\\}$.\n- With probability $\\dfrac{1}{4}$, the final result from top to bottom is $\\{4, 1, 2, 3\\}$.\n\nSo in the end, with probability $\\dfrac{1}{4}$ the first position is $4$, and with probability $\\dfrac{3}{4}$ the first position is $1$. Therefore, the expected score of the first position is $\\dfrac{7}{4}$.\n\nTo help you understand the shuffling process more intuitively, we draw below the process where the result is $\\{1, 4, 2, 3\\}$.\n\n![](https://cdn.luogu.com.cn/upload/pic/64318.png)\n\n### Constraints and Notes\n\nFor all test points, it is guaranteed that $3\\le n \\le 10^7$, $1\\le m,Q\\le5\\times 10^5$, $0\\le A_i\\le n$, $type\\in \\{1,2\\}$.\n\nThe specific limits for each test point are shown in the table below:\n\n| Test Point | $n$ | $m$ | $type=$ | Other Properties |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\le 10$ | $\\le 1$ | $1$ | None |\n| $2$ | $\\le 80$ | $\\le 80$ | $1$ | None |\n| $3$ | $\\le 80$ | $\\le 80$ | $2$ | None |\n| $4$ | $\\le 100$ | $\\le 5\\times 10^5$ | $2$ | All $A_i$ are the same |\n| $5$ | $\\le 10^7$ | $\\le 5\\times 10^5$ | $1$ | None |\n| $6$ | $\\le 10^7$ | $\\le 5\\times 10^5$ | $1$ | None |\n| $7$ | $\\le 10^7$ | $\\le 5\\times 10^5$ | $1$ | None |\n| $8$ | $\\le 10^7$ | $\\le 5\\times 10^5$ | $2$ | None |\n| $9$ | $\\le 10^7$ | $\\le 5\\times 10^5$ | $2$ | None |\n| $10$ | $\\le 10^7$ | $\\le 5\\times 10^5$ | $2$ | None |\n\nPlease note that we do not guarantee $Q\\le n$.\n\n### Hint\n\nHere we give the definition of the expectation $\\mathbb{E}[x]$ of a discrete random variable $X$:\n\nSuppose the possible values of $X$ are $X_1,X_2,\\ldots X_k$, and $Pr[X_1],Pr[X_2],\\ldots,Pr[X_k]$ are the probabilities that $X$ takes the corresponding values. Then the expectation of $X$ is:\n$$\\mathbb{E}[x]=\\sum^k_{i=1}X_i\\times Pr[X_i]$$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2019] 斗主地", "background": "时限 4 秒 内存 512MB", "description": "小 S 在和小 F 玩一个叫“斗地主”的游戏。\n\n可怜的小 S 发现自己打牌并打不过小 F，所以他想要在洗牌环节动动手脚。\n\n一副牌一共有 $n$ 张牌，从上到下依次标号为 $1 \\sim n$。标号为 $i$ 的牌**分数**是 $f(i)$。在本题，$f(i)$ 有且仅有两种可能：$f(i) = i$ 或 $f(i) = i^2$。\n\n洗牌的方式和我们日常生活中的比较类似，以下我们用形式化的语言来定义： 洗牌环节一共分 $m$ 轮，这 $m$ 轮洗牌依次进行。第 $i$ 轮洗牌时：\n\n1. 小 S 会拿出从最上面往下数的前 $A_i$ 张牌。这样这副牌就被分成了两堆：第一堆 是最上面的 $A_i$ 张牌，第二堆是剩下的 $n-A_i$ 张牌，且这两堆牌内相对顺序不变。 特别地，当$A_i = n$ 或 $A_i = 0$ 时，有一堆牌是空的。\n2. 接下来对两堆牌进行合并，从而产生新的第三堆牌。当第一堆牌还剩下 $X$ 张，第二堆牌还剩下 $Y$ 张的时候，以 $\\dfrac{X}{X+Y}$ 的概率取出第一堆牌的最下面的牌，并将它 放入新的第三堆牌的最上面， $\\dfrac{Y}{X+Y}$  的概率取出第二堆牌的最下面的牌，并将它放入新的第三堆牌的最上面\n3. 重复操作 $2$，一直取到两堆牌都为空为止。这样我们就完成了一轮洗牌。\n\n因为洗牌过程是随机的，所以小 S 发现自己没法知道某个位置上具体是哪张牌。但小 S 想问你在经历了这 $m$ 轮洗牌后，某个位置上的牌的**期望分数**是多少。小 S 一共会问你 $Q$ 个这样的问题。", "inputFormat": "输入的第一行包含三个正整数 $n, m, type$，分别表示牌的数量，洗牌的轮数与 $f(i)$ 的类型。当 $type = 1$ 时，$f(i) = i$。当 $type = 2$ 时，$f(i) = i^2$。\n\n接下来一行，一共 $m$ 个整数，表示 $A_1 \\sim A_m$。\n\n接下来一行一个正整数 $Q$，表示小 S 的询问个数。 接下来 $Q$ 行，每行一个正整数 $c_i$，表示小 S 想要知道从上往下第 $c_i$ 个位置上的牌的**期望分数**。\n\n保证 $1 \\leq c_i \\leq n$。", "outputFormat": "输出一共 $Q$ 行，每行一个整数，表示答案在模 $998244353$ 意义下的取值。\n\n\n即设答案化为最简分式后的形式为 $\\dfrac{a}\n{b}$，其中 $a$ 和 $b$ 互质。输出整数 $x$ 使得 $bx \\equiv a \\pmod{998244353}$ 且 $0 ≤ x < 998244353$。可以证明这样的整数 $x$ 是唯一的。", "hint": "### 更多样例\n\n您可以通过附加文件获得更多样例。\n\n#### 样例 2\n\n见附加文件中的 `landlords/landlords2.in` 与 `landlords/landlords2.ans`。\n\n#### 样例 3\n\n见附加文件中的 `landlords/landlords3.in` 与 `landlords/landlords3.ans`。\n\n### 样例输入输出 1 解释\n\n- 有 $\\dfrac{1}{4}$ 的概率从上到下的最终结果是 $\\{1, 2, 3, 4\\}$。\n- 有 $\\dfrac{1}{4}$ 的概率从上到下的最终结果是 $\\{1, 2, 4, 3\\}$。\n- 有 $\\dfrac{1}{4}$ 的概率从上到下的最终结果是 $\\{1, 4, 2, 3\\}$。\n- 有 $\\dfrac{1}{4}$ 的概率从上到下的最终结果是 $\\{4, 1, 2, 3\\}$。\n\n所以最终有 $\\dfrac{1}{4}$ 的概率第一个位置是 $4$，有 $\\dfrac{3}\n{4}$ 的概率第一个位置是 $1$，所以第一个位置的期望分数是 $\\dfrac{7}{\n4}$。\n\n为了帮助你们更直观地了解洗牌的过程，我们在下面画出了结果是 $\\{1, 4, 2, 3\\}$ 的过程。\n\n![](https://cdn.luogu.com.cn/upload/pic/64318.png)\n\n### 数据规模与约定\n\n对于全部的测试点，保证 $3\\le n \\le 10^7$，$1\\le m,Q\\le5\\times 10^5$，$0\\le A_i\\le n$，$type\\in \\{1,2\\}$。\n\n每个测试点的具体限制见下表：\n\n| 测试点 | $n$ | $m$ | $type=$ | 其他性质 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\le 10$ | $\\le 1$ | $1$ | 无 |\n| $2$ | $\\le 80$ | $\\le 80$ | $1$ | 无 |\n| $3$ | $\\le 80$ | $\\le 80$ | $2$ | 无 |\n| $4$ | $\\le 100$ | $\\le 5\\times 10^5$ | $2$ | 所有 $A_i$ 相同 |\n| $5$ | $\\le 10^7$ | $\\le 5\\times 10^5$ | $1$ | 无 |\n| $6$ | $\\le 10^7$ | $\\le 5\\times 10^5$ | $1$ | 无 |\n| $7$ | $\\le 10^7$ | $\\le 5\\times 10^5$ | $1$ | 无 |\n| $8$ | $\\le 10^7$ | $\\le 5\\times 10^5$ | $2$ |无  |\n| $9$ | $\\le 10^7$ | $\\le 5\\times 10^5$ | $2$ | 无 |\n| $10$ | $\\le 10^7$ | $\\le 5\\times 10^5$ | $2$  | 无 |\n\n请注意我们并没有保证 $Q\\le n$。\n\n### 提示\n\n这里我们给出离散型随机变量 $X$ 的期望 $\\mathbb{E}[x]$ 的定义：\n\n设离散随机变量 $X$ 的可能值是 $X_1,X_2,\\ldots X_k$，$Pr[X_1],Pr[X_2],\\ldots,Pr[X_k]$ 为 $X$ 取对应值的概率，则 $X$ 的期望为：\n$$\\mathbb{E}[x]=\\sum^k_{i=1}X_i\\times Pr[X_i]$$\n\n", "locale": "zh-CN"}}}
{"pid": "P5473", "type": "P", "difficulty": 7, "samples": [["100 200 300\n3 2\n0 1\n1 2\n", "见“提示与说明”"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "NOI", "交互题", "Special Judge", "O2优化"], "title": "[NOI2019] I 君的探险", "background": "附加文件可在页面底部「附件」中下载。\n\n### 特别提示\n\n**在洛谷提交本题时的一些注意事项（与原题面不同之处请以此处为准）：**\n\n1. 与原题不同的是，你不需要，也不应该在程序开头包含 `explore.h` 头文件。\n\n2. 为了确保程序正常编译，你需要在你提交的程序开头加上如下函数声明语句：\n\n```cpp\nvoid modify(int x);\nint query(int x);\nvoid report(int x, int y);\nint check(int x);\n```\n\n3. 本题仅支持 C++ 语言（包括 `C++`，`C++11`，`C++14`，`C++17`）提交。", "description": "时隔半年，I 君的商店终于开不下去了，他决定转让商店，做一名探险家去探索未知的广阔世界。\n\n根据古书记载，他在一个大荒漠的腹地找到了未知文明创造的地下宫殿，宫殿由 $N$ 个大型洞穴和 $M$ 条连接这些洞穴的双向通路构成。I 君能借助古书分辨所处的洞穴，但书中并没有记录 $M$ 条通路的连接结构，因此他难以搜寻传说中藏在宫殿里的无尽财宝。\n\n不过现在 I 君发现了一个神秘机关，通过它可以获知宫殿的信息，I 君决定利用这个机关来得到宫殿的连接结构，请你来协助他。\n\n地下宫殿可以抽象成一张 $N$ 个点、$M$ 条边的无向简单图（简单图满足任意两点之间至多存在一条直接相连的边），洞穴从 $0 \\sim n - 1$ 编号。目前你并不知道边有哪些。\n\n每个洞穴都拥有一个光源，光源有开启、关闭两种状态，只有当光源处于开启状态时它所在的洞穴才会被照亮。初始时所有的光源都处于关闭状态，而光源的状态只能用I 君发现的神秘机关改变。更具体的，使用神秘机关可以进行如下四种操作：\n\n1. 向机关给定一个编号 $x$，机关将会改变$x$ 号洞穴，以及与$x$ 号洞穴有通路直接相连的洞穴的光源状态。即原来开启的光源将会关闭；原来关闭的光源将会开启。\n\n2. 向机关给定一个编号 $x$，机关将会显示当前$x$ 号洞穴光源的状态。\n\n3. 向机关给定两个编号 $x, y$，表示你确定有一条连接 $x$ 号洞穴与 $y$ 号洞穴的通路，并让机关记录。\n\n4. 向机关给定一个编号 $x$，机关将会判断与 $x$ 号洞穴相连的通路是否都已被记录。\n\n机关在完成上一次操作后才能进行下一次操作。机关不能随意使用，因此每种操作的使用次数都有限制，分别为 $L_m, L_q, M, L_c$。你的任务是，编写一个程序，帮助 I 君决定如何合理利用神秘机关，从而正确地找到这 $M$ 条通路。\n\n### 实现细节\n\n你不需要，也不应该实现主函数，你只需要实现函数 `explore(N, M)`，这里的 $N$和 $M$ 分别表示洞穴和通路的个数。你可以通过调用如下四个函数来和交互库进行交互：\n\n1. `modify(x)`\n\n- 这个函数可以令机关执行操作 $1$，给定的编号为 $x$。\n\n- 你需要保证 $0 \\leq x < N$，这个函数没有返回值。\n\n2. `query(x)`\n\n- 这个函数可以令机关执行操作 $2$，给定的编号为 $x$。\n\n- 你需要保证 $0 \\leq x < N$，这个函数返回 $0$ 或 $1$，表示目前 $x$ 号洞穴的光源为关闭（$0$ 表示）或开启（$1$ 表示）状态。\n\n3. `report(x, y)`\n\n- 这个函数可以令机关执行操作 $3$，给定的编号为 $x, y$。\n\n- 你需要保证 $0 \\leq x, y < N$ 且 $x \\neq y$，这个函数没有返回值。\n\n4. `check(x)`\n\n- 这个函数可以令机关执行操作 $4$，给定的编号为 $x$。\n\n- 你需要保证 $0 \\leq x < N$，这个函数返回 $0$ 或 $1$，其中返回 $1$ 当且仅当与 $x$ 号洞穴相连的所有通路都已通过操作 3 被记录。\n\n评测时，交互库会恰好调用 `explore` 一次。\n\n本题保证所使用的图在交互开始之前已经完全确定，不会根据和你的程序的交互过程动态构造，因此题目中的交互操作都是确定性的，你不需要关心这些操作在交互库中的具体实现。\n\n数据保证在调用次数限制下，交互库运行所需的时间不超过1s；交互库使用的内存大小固定，且不超过128MB。\n\n### 实现方法\n\n选手工作目录下已经提供了一个 `template_explore.cpp/c/pas`，请将这个文件拷贝一份，重命名为 `explore.cpp/c/pas`，然后在其基础上答题。\n\n1. 对 C++ / C 语言选手\n\n- 请确保你的程序开头有 \n```\n#include \"explore.h\"。\n```\n- 你需要实现的函数 `explore` 的接口信息如下：\n```\nvoid explore(int N, int M);\n```\n- 你可以调用的交互函数的接口如下：\n```\nvoid modify(int x);\nint query(int x);\nvoid report(int x, int y);\nint check(int x);\n```\n\n2. 对 Pascal 语言选手\n\n- 注意：Pascal 的代码中实现接口的语法较为复杂，请选手直接在下发的.\n`template_explore.pas` 的基础上进行答题，而不是自己从头实现代码。\n\n- 你需要实现的函数 `explore` 的接口信息如下：\n```\nprocedure _explore(N, M : longint);\n```\n- 注意：这里的函数名称是`_explore` 而非`explore`，如果使用`explore` 将导致编译失败。\n\n- 你可以调用的交互函数的接口如下：\n```\nprocedure modify(x : longint);\nfunction query(x : longint) : longint;\nprocedure report(x : longint; y : longint);\nfunction check(x : longint) : longint;\n```\n\n试题目录下的 `grader.cpp/c` 以及 `graderhelperlib.pas` 是我们提供的交互库参考实现，最终测试时所用的交互库实现与该参考实现有所不同，因此选手的解法不应该依赖交互库实现。\n\n1. 对 `C/C++` 语言的选手：\n\n- 你需要在本题目录下使用如下命令编译得到可执行程序：\n\n- 对于 C 语言：\n```\ngcc grader.c explore.c -o explore -O2 -lm\n```\n- 对于 C++ 语言：\n```\ng++ grader.cpp explore.cpp -o explore -O2 -lm\n```\n\n2. 对于 `Pascal` 语言的选手：\n\n- 你需要在本题目录下使用如下命令编译得到可执行程序：\n```\nfpc grader.pas -o\"explore\" -O2\n```\n\n3. 对于编译得到的可执行程序：\n\n- 可执行文件将从标准输入读入以下格式的数据：\n\n第一行包含三个整数 $L_m, L_q, L_c$ ，第二行包含两个整数 $N, M$，意义如题面描述。\n\n接下来 $M$ 行，每行两个整数 $x, y$，描述一条连接 $x$ 号洞穴与 $y$ 号洞穴的通路。\n\n- 读入完成之后，交互库将调用恰好一次函数 `explore`，用输入的数据测试你的函数。你的函数正确返回后，交互库会判断你的计算是否正确，若正确则会输出 `Correct` 和交互函数调用次数相关信息，否则会输出相应的错误信息。", "inputFormat": "", "outputFormat": "", "hint": "数据第一行的三个整数分别表示三种操作的调用次数限制，即 `modify(x)` 调用次数不能超过 $100$，`query(x)` 调用次数不能超过 $200$，`check(x)` 调用次数不能超过 $300$。\n\n数据第二行的两个整数分别表示洞穴数和通路条数，即 $N = 3 , M = 2$。\n\n`report(x, y)` 调用次数不能超过 $M$，该例子中即不超过 $2$ 次。\n\n下面是一个正确的交互过程：\n\n| 选手程序 | 交互库 | 说明 |\n| :----------: | :----------: | :----------: |\n|  | 调用 $\\text{explore}(3,2)$ | 开始测试 |\n| 调用 $\\text{modify}(0)$ |  | 对 $0$ 号洞穴做操作 $1$ |\n| 调用 $\\text{query}(2)$ | 返回 $0$ | 目前 $2$ 号洞穴的光源状态是关闭 |\n| 调用 $\\text{report}(0,1)$ |  | 发现了道路 $(0,1)$ 并记录 |\n| 调用 $\\text{check}(0)$ | 返回 $1$ | 与 $0$ 号洞穴相关的道路都已被记录 |\n| 调用 $\\text{report}(2,1)$ |  | 发现了道路 $(2,1)$ 并记录 |\n| 运行结束并返回 | 向屏幕打印 $\\text{Correct}$ | 交互结束，结果正确 |\n\n### 下发文件说明\n\n在本试题目录下：\n\n1. `grader.cpp/c` 以及 `graderhelperlib.pas` 是我们提供的交互库参考实现。\n\n2. `explore.h` 和 `grader.pas` 是头文件，选手不用关心具体内容。\n\n3. `template_explore.cpp/c/pas` 是我们提供的样例解题源代码。\n\n4. `explore1.in`、`explore2.in`、`explore3.in` 是样例输入，可供测试。\n\n选手注意对所有下发文件做好备份。评测只收取本试题目录下的`explore.c/cpp/pas`，并且对该程序以外的文件的修改无效。\n\n最终评测只会收取 `explore.cpp/c/pas`，修改选手目录下其他文件对评测无效。\n\n本题首先会受到和传统题相同的限制。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。你只能访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。\n\n在上述条件基础上，在一个测试点中，你得到满分，当且仅当：\n\n1. 你的每次函数调用均合法，且调用 `modify`、`query` 和 `check` 的次数分别不超过$L_m, L_q, L_c$。\n\n2. 由于 `report` 的调用次数限制为 $M$，你的每次调用都必须记录一条新的且存在的边；即每次调用 `report(x, y)` 时，应满足：有一条连接 $x$ 号洞穴和 $y$ 号洞穴的通路，且在这次调用之前从未调用过 `report(x, y)` 或 `report(y, x)`。\n\n3. 你实现的函数 `explore` 正常返回。\n\n4. 在 `explore` 函数返回时，你已经通过调用 `report` 记录了全部 $M$ 条通路。\n\n本题共 $25$ 个测试点，每个测试点 $4$ 分。每个测试点的数据规模和相关限制见下表。\n| 测试点编号 | $N=$ | $M=$ | $L_m=$ | $L_q=$ | $L_c=$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $3$ | $2$ | $100$ | $100$ | $100$ | 无 |\n| $2$ | $100$ | $10\\times N$ | $200$ | $10^4$ | $2\\times M$ | 无 |\n| $3$ | $200$ | $10\\times N$ | $200$ | $4\\times 10^4$ | $2\\times M$ | 无 |\n| $4$ | $300$ | $10\\times N$ |$299$  | $9\\times 10^4$ | $2\\times M$ | 无 |\n| $5$ | $500$ | $10\\times N$ | $499$ | $1.5\\times 10^5$ | $2\\times M$ | 无 |\n| $6$ | $59998$ | $\\frac{N}{2}$ | $17\\times N$ | $17\\times N$ | $0$ | $A$ |\n| $7$ | $99998$ | $\\frac{N}{2}$ | $18\\times N$ | $18\\times N$ | $0$ | $A$ |\n| $8$ | $199998$ | $\\frac{N}{2}$ | $19\\times N$ | $19\\times N$ | $0$ | $A$ |\n| $9$ | $199998$ | $\\frac{N}{2}$ | $19\\times N$ | $19\\times N$ | $0$ | $A$ |\n| $10$ | $99997$ | $N-1$ | $18\\times N$ | $18\\times N$ | $0$ | $B$ |\n| $11$ | $199997$ | $N-1$ | $19\\times N$ | $19\\times N$ | $0$ | $B$ |\n| $12$ | $99996$ | $N-1$ | $10^7$ | $10^7$ | $2\\times M$ | $C$ |\n| $13$ | $199996$ | $N-1$ | $10^7$ | $10^7$ | $2\\times M$ | $C$ |\n| $14$ | $199996$ | $N-1$ | $10^7$ | $10^7$ | $2\\times M$ | $C$ |\n| $15$ | $99995$ | $N-1$ | $10^7$ | $10^7$ | $2\\times M$ | $D$ |\n| $16$ | $99995$ | $N-1$ | $10^7$ | $10^7$ | $2\\times M$ | $D$ |\n| $17$ | $199995$ | $N-1$ | $10^7$ | $10^7$ | $2\\times M$ | $D$ |\n| $18$ | $1004$ | $2\\times 10^3$ | $10^7$ | $5\\times 10^4$ | $2\\times M$ | 无 |\n| $19$ | $1004$ | $3\\times 10^3$ | $10^7$ | $5\\times 10^4$ | $2\\times M$ | 无 |\n| $20$ | $1004$ | $3\\times 10^3$ | $10^7$ | $5\\times 10^4$ | $2\\times M$ | 无 |\n| $21$ | $5\\times 10^4$ | $2\\times N$ | $10^7$ | $10^7$ | $2\\times M$ |  无|\n| $22$ | $10^5$ | $2\\times N$ | $10^7$ | $10^7$ | $2\\times M$ | 无 |\n| $23$ | $1.5\\times 10^5$ | $2\\times 10^5$ | $10^7$ | $10^7$ | $2\\times M$ | 无 |\n| $24$ | $2\\times 10^5$ | $2.5\\times 10^5$ | $10^7$ | $10^7$ | $2\\times M$ | 无 |\n| $25$ | $2\\times 10^5$ | $3\\times 10^5$ | $10^7$ | $10^7$ | $2\\times M$ | 无 |\n\n再次提醒，题目保证测试所使用的图在交互开始之前已经完全确定，而不会根据和你的程序的交互动态构造。\n\n表中特殊性质栏中变量的含义如下：\n\nA：保证每个点的度数恰好为 $1$。\n\nB：保证对于每个 $x > 0$，存在恰好一个 $y < x$ 的 $y$ 使得 $x$ 号洞穴与 $y$ 号洞穴有通路直接相连。\n\nC：存在 $0 \\sim N - 1$ 的一个排列 $p_0, p_1, \\cdots , p_{N-1}$，使得对任意 $1 \\leq i < N$，存在一条连接洞穴编号分别为 $p_{i-1}$ 与 $p_i$ 的通路。\n\nD：保证图连通。\n\n- 提示：你的程序可以通过判断传入的 $N$ 的个位来区分上述不同的数据类型。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2019] Mr. I's Adventure.", "background": "Additional files can be downloaded from “Attachments” at the bottom of the page.\n\n### Special Notes\n\n**Notes for submitting this problem on Luogu (if it differs from the original statement, follow what is written here):**\n\n1. Unlike the original problem, you do not need to, and should not, include the header file `explore.h` at the beginning of your program.\n\n2. To ensure your program compiles correctly, you need to add the following function declarations at the beginning of your submitted program:\n\n```cpp\nvoid modify(int x);\nint query(int x);\nvoid report(int x, int y);\nint check(int x);\n```\n\n3. This problem only supports submissions in C++ (including `C++`, `C++11`, `C++14`, `C++17`).", "description": "Half a year later, Mr. I’s shop finally could not stay open anymore. He decided to transfer the shop and become an explorer to explore the vast unknown world.\n\nAccording to ancient books, he found an underground palace created by an unknown civilization deep in a great desert. The palace consists of $N$ large caves and $M$ bidirectional passages connecting these caves. Mr. I can use the ancient book to identify which cave he is in, but the book does not record the connection structure of the $M$ passages, so it is difficult for him to search for the endless treasure said to be hidden in the palace.\n\nHowever, Mr. I has now found a mysterious mechanism that can reveal information about the palace. Mr. I decides to use this mechanism to obtain the connection structure of the palace, and asks you to assist him.\n\nThe underground palace can be abstracted as an undirected simple graph with $N$ vertices and $M$ edges (a simple graph means there is at most one directly connected edge between any two vertices). The caves are numbered from $0 \\sim n - 1$. Currently, you do not know what the edges are.\n\nEach cave has a light source, which has two states: on and off. A cave is lit only when its light source is on. Initially, all light sources are off, and the light states can only be changed using the mysterious mechanism discovered by Mr. I. More specifically, the mechanism supports the following four operations:\n\n1. Given an index $x$, the mechanism will toggle the light state of cave $x$ and all caves that are directly connected to cave $x$ by a passage. That is, lights that were on will be turned off, and lights that were off will be turned on.\n\n2. Given an index $x$, the mechanism will display the current light state of cave $x$.\n\n3. Given two indices $x, y$, it means you confirm that there is a passage connecting cave $x$ and cave $y$, and you ask the mechanism to record it.\n\n4. Given an index $x$, the mechanism will determine whether all passages incident to cave $x$ have already been recorded.\n\nThe mechanism can perform the next operation only after finishing the previous one. The mechanism cannot be used freely, so the number of times each operation can be used is limited to $L_m, L_q, M, L_c$, respectively. Your task is to write a program to help Mr. I decide how to use the mechanism properly, so that all $M$ passages can be found correctly.\n\n### Implementation Details\n\nYou do not need to, and should not, implement the main function. You only need to implement the function `explore(N, M)`, where $N$ and $M$ are the numbers of caves and passages. You can interact with the interactive library by calling the following four functions:\n\n1. `modify(x)`\n\n- This function makes the mechanism perform operation $1$ with the given index $x$.\n\n- You must ensure $0 \\leq x < N$. This function has no return value.\n\n2. `query(x)`\n\n- This function makes the mechanism perform operation $2$ with the given index $x$.\n\n- You must ensure $0 \\leq x < N$. This function returns $0$ or $1$, meaning the light source of cave $x$ is currently off ($0$) or on ($1$).\n\n3. `report(x, y)`\n\n- This function makes the mechanism perform operation $3$ with the given indices $x, y$.\n\n- You must ensure $0 \\leq x, y < N$ and $x \\neq y$. This function has no return value.\n\n4. `check(x)`\n\n- This function makes the mechanism perform operation $4$ with the given index $x$.\n\n- You must ensure $0 \\leq x < N$. This function returns $0$ or $1$, where it returns $1$ if and only if all passages incident to cave $x$ have already been recorded via operation 3.\n\nDuring judging, the interactive library will call `explore` exactly once.\n\nThis problem guarantees that the graph used has been fully determined before the interaction starts, and will not be constructed dynamically based on the interaction process. Therefore, all interactive operations in the statement are deterministic, and you do not need to care about their internal implementation in the library.\n\nThe testdata guarantees that under the call limits, the time needed for the interactive library to run does not exceed 1 s. The memory used by the interactive library is fixed and does not exceed 128 MB.\n\n### Implementation Method\n\nA `template_explore.cpp/c/pas` has already been provided in the contestant working directory. Please copy this file and rename it to `explore.cpp/c/pas`, then solve the problem based on it.\n\n1. For C++ / C contestants\n\n- Please make sure your program starts with\n```\n#include \"explore.h\"。\n```\n- The interface of the function `explore` you need to implement is:\n```\nvoid explore(int N, int M);\n```\n- The interfaces of the interactive functions you can call are:\n```\nvoid modify(int x);\nint query(int x);\nvoid report(int x, int y);\nint check(int x);\n```\n\n2. For Pascal contestants\n\n- Note: The syntax for implementing the interface in Pascal code is relatively complex. Please solve the problem directly based on the provided `template_explore.pas`, rather than implementing everything from scratch.\n\n- The interface of the function you need to implement is:\n```\nprocedure _explore(N, M : longint);\n```\n- Note: The function name here is `_explore` rather than `explore`. Using `explore` will cause compilation failure.\n\n- The interfaces of the interactive functions you can call are:\n```\nprocedure modify(x : longint);\nfunction query(x : longint) : longint;\nprocedure report(x : longint; y : longint);\nfunction check(x : longint) : longint;\n```\n\nThe `grader.cpp/c` and `graderhelperlib.pas` in the problem directory are a reference implementation of the interactive library provided by us. The interactive library used in the final test is different from this reference implementation, so your solution should not depend on the library implementation.\n\n1. For `C/C++` contestants:\n\n- You need to compile the executable in this problem directory using the following commands:\n\n- For C:\n```\ngcc grader.c explore.c -o explore -O2 -lm\n```\n- For C++:\n```\ng++ grader.cpp explore.cpp -o explore -O2 -lm\n```\n\n2. For `Pascal` contestants:\n\n- You need to compile the executable in this problem directory using the following command:\n```\nfpc grader.pas -o\"explore\" -O2\n```\n\n3. For the compiled executable:\n\n- The executable will read input from standard input in the following format:\n\nThe first line contains three integers $L_m, L_q, L_c$. The second line contains two integers $N, M$, with the meanings as described above.\n\nThe next $M$ lines each contain two integers $x, y$, describing a passage connecting cave $x$ and cave $y$.\n\n- After reading is finished, the interactive library will call the function `explore` exactly once, and test your function with the input data. After your function returns correctly, the interactive library will check whether your result is correct. If it is correct, it will output `Correct` and information related to the number of interactive calls; otherwise it will output the corresponding error information.", "inputFormat": "", "outputFormat": "", "hint": "The three integers on the first line of the testdata are the call limits of the three operations: the number of calls to `modify(x)` must not exceed $100$, the number of calls to `query(x)` must not exceed $200$, and the number of calls to `check(x)` must not exceed $300$.\n\nThe two integers on the second line of the testdata are the number of caves and the number of passages, i.e. $N = 3 , M = 2$.\n\nThe number of calls to `report(x, y)` must not exceed $M$, so in this example it must not exceed $2$ calls.\n\nBelow is a correct interaction process:\n\n| Contestant Program | Interactive Library | Explanation |\n| :----------: | :----------: | :----------: |\n|  | Calls $\\text{explore}(3,2)$ | Start testing. |\n| Calls $\\text{modify}(0)$ |  | Perform operation $1$ on cave $0$. |\n| Calls $\\text{query}(2)$ | Returns $0$ | The current light state of cave $2$ is off. |\n| Calls $\\text{report}(0,1)$ |  | Found and recorded the passage $(0,1)$. |\n| Calls $\\text{check}(0)$ | Returns $1$ | All passages incident to cave $0$ have been recorded. |\n| Calls $\\text{report}(2,1)$ |  | Found and recorded the passage $(2,1)$. |\n| Ends and returns | Prints $\\text{Correct}$ | Interaction ends, and the result is correct. |\n\n### Notes on Provided Files\n\nIn this problem directory:\n\n1. `grader.cpp/c` and `graderhelperlib.pas` are the reference implementation of the interactive library provided by us.\n\n2. `explore.h` and `grader.pas` are header files; contestants do not need to care about their contents.\n\n3. `template_explore.cpp/c/pas` is the sample solution source code provided by us.\n\n4. `explore1.in`, `explore2.in`, `explore3.in` are sample inputs for testing.\n\nPlease back up all provided files. The judge only collects `explore.c/cpp/pas` in this problem directory, and any modifications to other files are ignored.\n\nThe final judging will only collect `explore.cpp/c/pas`. Modifying other files in your directory does not affect judging.\n\nThis problem is first subject to the same limits as traditional problems. For example, compilation errors will make the whole problem score $0$ points, runtime errors, time limit exceeded, memory limit exceeded, etc. will make the corresponding test point score $0$ points. You may only access variables you define and those provided by the interactive library, as well as their corresponding memory space. Attempting to access other memory may cause compilation errors or runtime errors.\n\nUnder the above conditions, for each test point, you get full score if and only if:\n\n1. Every function call you make is valid, and the numbers of calls to `modify`, `query`, and `check` do not exceed $L_m, L_q, L_c$, respectively.\n\n2. Since the call limit of `report` is $M$, each call must record a new edge that exists. That is, each time you call `report(x, y)`, it must satisfy: there is a passage connecting caves $x$ and $y$, and before this call you have never called `report(x, y)` or `report(y, x)`.\n\n3. The function `explore` you implemented returns normally.\n\n4. When `explore` returns, you have recorded all $M$ passages by calling `report`.\n\nThere are $25$ test points in total, each worth $4$ points. The data size and related limits for each test point are shown in the table below.\n| Test Point ID | $N=$ | $M=$ | $L_m=$ | $L_q=$ | $L_c=$ | Special Property |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $3$ | $2$ | $100$ | $100$ | $100$ | None |\n| $2$ | $100$ | $10\\times N$ | $200$ | $10^4$ | $2\\times M$ | None |\n| $3$ | $200$ | $10\\times N$ | $200$ | $4\\times 10^4$ | $2\\times M$ | None |\n| $4$ | $300$ | $10\\times N$ |$299$  | $9\\times 10^4$ | $2\\times M$ | None |\n| $5$ | $500$ | $10\\times N$ | $499$ | $1.5\\times 10^5$ | $2\\times M$ | None |\n| $6$ | $59998$ | $\\frac{N}{2}$ | $17\\times N$ | $17\\times N$ | $0$ | $A$ |\n| $7$ | $99998$ | $\\frac{N}{2}$ | $18\\times N$ | $18\\times N$ | $0$ | $A$ |\n| $8$ | $199998$ | $\\frac{N}{2}$ | $19\\times N$ | $19\\times N$ | $0$ | $A$ |\n| $9$ | $199998$ | $\\frac{N}{2}$ | $19\\times N$ | $19\\times N$ | $0$ | $A$ |\n| $10$ | $99997$ | $N-1$ | $18\\times N$ | $18\\times N$ | $0$ | $B$ |\n| $11$ | $199997$ | $N-1$ | $19\\times N$ | $19\\times N$ | $0$ | $B$ |\n| $12$ | $99996$ | $N-1$ | $10^7$ | $10^7$ | $2\\times M$ | $C$ |\n| $13$ | $199996$ | $N-1$ | $10^7$ | $10^7$ | $2\\times M$ | $C$ |\n| $14$ | $199996$ | $N-1$ | $10^7$ | $10^7$ | $2\\times M$ | $C$ |\n| $15$ | $99995$ | $N-1$ | $10^7$ | $10^7$ | $2\\times M$ | $D$ |\n| $16$ | $99995$ | $N-1$ | $10^7$ | $10^7$ | $2\\times M$ | $D$ |\n| $17$ | $199995$ | $N-1$ | $10^7$ | $10^7$ | $2\\times M$ | $D$ |\n| $18$ | $1004$ | $2\\times 10^3$ | $10^7$ | $5\\times 10^4$ | $2\\times M$ | None |\n| $19$ | $1004$ | $3\\times 10^3$ | $10^7$ | $$5\\times 10^4$$ | $2\\times M$ | None |\n| $20$ | $1004$ | $3\\times 10^3$ | $10^7$ | $5\\times 10^4$ | $2\\times M$ | None |\n| $21$ | $5\\times 10^4$ | $2\\times N$ | $10^7$ | $10^7$ | $2\\times M$ |  None |\n| $22$ | $10^5$ | $2\\times N$ | $10^7$ | $10^7$ | $2\\times M$ | None |\n| $23$ | $1.5\\times 10^5$ | $2\\times 10^5$ | $10^7$ | $10^7$ | $2\\times M$ | None |\n| $24$ | $2\\times 10^5$ | $2.5\\times 10^5$ | $10^7$ | $10^7$ | $2\\times M$ | None |\n| $25$ | $2\\times 10^5$ | $3\\times 10^5$ | $10^7$ | $10^7$ | $2\\times M$ | None |\n\nReminder again: the problem guarantees that the graph used for testing has been fully determined before the interaction starts, and will not be constructed dynamically based on the interaction with your program.\n\nThe meanings of the variables in the “Special Property” column are as follows:\n\nA: It is guaranteed that the degree of every vertex is exactly $1$.\n\nB: It is guaranteed that for every $x > 0$, there exists exactly one $y < x$ such that cave $x$ is directly connected to cave $y$ by a passage.\n\nC: There exists a permutation $p_0, p_1, \\cdots , p_{N-1}$ of $0 \\sim N - 1$ such that for any $1 \\leq i < N$, there exists a passage connecting caves $p_{i-1}$ and $p_i$.\n\nD: It is guaranteed that the graph is connected.\n\n- Hint: Your program can distinguish the different data types above by checking the last digit of the given $N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2019] I 君的探险", "background": "附加文件可在页面底部「附件」中下载。\n\n### 特别提示\n\n**在洛谷提交本题时的一些注意事项（与原题面不同之处请以此处为准）：**\n\n1. 与原题不同的是，你不需要，也不应该在程序开头包含 `explore.h` 头文件。\n\n2. 为了确保程序正常编译，你需要在你提交的程序开头加上如下函数声明语句：\n\n```cpp\nvoid modify(int x);\nint query(int x);\nvoid report(int x, int y);\nint check(int x);\n```\n\n3. 本题仅支持 C++ 语言（包括 `C++`，`C++11`，`C++14`，`C++17`）提交。", "description": "时隔半年，I 君的商店终于开不下去了，他决定转让商店，做一名探险家去探索未知的广阔世界。\n\n根据古书记载，他在一个大荒漠的腹地找到了未知文明创造的地下宫殿，宫殿由 $N$ 个大型洞穴和 $M$ 条连接这些洞穴的双向通路构成。I 君能借助古书分辨所处的洞穴，但书中并没有记录 $M$ 条通路的连接结构，因此他难以搜寻传说中藏在宫殿里的无尽财宝。\n\n不过现在 I 君发现了一个神秘机关，通过它可以获知宫殿的信息，I 君决定利用这个机关来得到宫殿的连接结构，请你来协助他。\n\n地下宫殿可以抽象成一张 $N$ 个点、$M$ 条边的无向简单图（简单图满足任意两点之间至多存在一条直接相连的边），洞穴从 $0 \\sim n - 1$ 编号。目前你并不知道边有哪些。\n\n每个洞穴都拥有一个光源，光源有开启、关闭两种状态，只有当光源处于开启状态时它所在的洞穴才会被照亮。初始时所有的光源都处于关闭状态，而光源的状态只能用I 君发现的神秘机关改变。更具体的，使用神秘机关可以进行如下四种操作：\n\n1. 向机关给定一个编号 $x$，机关将会改变$x$ 号洞穴，以及与$x$ 号洞穴有通路直接相连的洞穴的光源状态。即原来开启的光源将会关闭；原来关闭的光源将会开启。\n\n2. 向机关给定一个编号 $x$，机关将会显示当前$x$ 号洞穴光源的状态。\n\n3. 向机关给定两个编号 $x, y$，表示你确定有一条连接 $x$ 号洞穴与 $y$ 号洞穴的通路，并让机关记录。\n\n4. 向机关给定一个编号 $x$，机关将会判断与 $x$ 号洞穴相连的通路是否都已被记录。\n\n机关在完成上一次操作后才能进行下一次操作。机关不能随意使用，因此每种操作的使用次数都有限制，分别为 $L_m, L_q, M, L_c$。你的任务是，编写一个程序，帮助 I 君决定如何合理利用神秘机关，从而正确地找到这 $M$ 条通路。\n\n### 实现细节\n\n你不需要，也不应该实现主函数，你只需要实现函数 `explore(N, M)`，这里的 $N$和 $M$ 分别表示洞穴和通路的个数。你可以通过调用如下四个函数来和交互库进行交互：\n\n1. `modify(x)`\n\n- 这个函数可以令机关执行操作 $1$，给定的编号为 $x$。\n\n- 你需要保证 $0 \\leq x < N$，这个函数没有返回值。\n\n2. `query(x)`\n\n- 这个函数可以令机关执行操作 $2$，给定的编号为 $x$。\n\n- 你需要保证 $0 \\leq x < N$，这个函数返回 $0$ 或 $1$，表示目前 $x$ 号洞穴的光源为关闭（$0$ 表示）或开启（$1$ 表示）状态。\n\n3. `report(x, y)`\n\n- 这个函数可以令机关执行操作 $3$，给定的编号为 $x, y$。\n\n- 你需要保证 $0 \\leq x, y < N$ 且 $x \\neq y$，这个函数没有返回值。\n\n4. `check(x)`\n\n- 这个函数可以令机关执行操作 $4$，给定的编号为 $x$。\n\n- 你需要保证 $0 \\leq x < N$，这个函数返回 $0$ 或 $1$，其中返回 $1$ 当且仅当与 $x$ 号洞穴相连的所有通路都已通过操作 3 被记录。\n\n评测时，交互库会恰好调用 `explore` 一次。\n\n本题保证所使用的图在交互开始之前已经完全确定，不会根据和你的程序的交互过程动态构造，因此题目中的交互操作都是确定性的，你不需要关心这些操作在交互库中的具体实现。\n\n数据保证在调用次数限制下，交互库运行所需的时间不超过1s；交互库使用的内存大小固定，且不超过128MB。\n\n### 实现方法\n\n选手工作目录下已经提供了一个 `template_explore.cpp/c/pas`，请将这个文件拷贝一份，重命名为 `explore.cpp/c/pas`，然后在其基础上答题。\n\n1. 对 C++ / C 语言选手\n\n- 请确保你的程序开头有 \n```\n#include \"explore.h\"。\n```\n- 你需要实现的函数 `explore` 的接口信息如下：\n```\nvoid explore(int N, int M);\n```\n- 你可以调用的交互函数的接口如下：\n```\nvoid modify(int x);\nint query(int x);\nvoid report(int x, int y);\nint check(int x);\n```\n\n2. 对 Pascal 语言选手\n\n- 注意：Pascal 的代码中实现接口的语法较为复杂，请选手直接在下发的.\n`template_explore.pas` 的基础上进行答题，而不是自己从头实现代码。\n\n- 你需要实现的函数 `explore` 的接口信息如下：\n```\nprocedure _explore(N, M : longint);\n```\n- 注意：这里的函数名称是`_explore` 而非`explore`，如果使用`explore` 将导致编译失败。\n\n- 你可以调用的交互函数的接口如下：\n```\nprocedure modify(x : longint);\nfunction query(x : longint) : longint;\nprocedure report(x : longint; y : longint);\nfunction check(x : longint) : longint;\n```\n\n试题目录下的 `grader.cpp/c` 以及 `graderhelperlib.pas` 是我们提供的交互库参考实现，最终测试时所用的交互库实现与该参考实现有所不同，因此选手的解法不应该依赖交互库实现。\n\n1. 对 `C/C++` 语言的选手：\n\n- 你需要在本题目录下使用如下命令编译得到可执行程序：\n\n- 对于 C 语言：\n```\ngcc grader.c explore.c -o explore -O2 -lm\n```\n- 对于 C++ 语言：\n```\ng++ grader.cpp explore.cpp -o explore -O2 -lm\n```\n\n2. 对于 `Pascal` 语言的选手：\n\n- 你需要在本题目录下使用如下命令编译得到可执行程序：\n```\nfpc grader.pas -o\"explore\" -O2\n```\n\n3. 对于编译得到的可执行程序：\n\n- 可执行文件将从标准输入读入以下格式的数据：\n\n第一行包含三个整数 $L_m, L_q, L_c$ ，第二行包含两个整数 $N, M$，意义如题面描述。\n\n接下来 $M$ 行，每行两个整数 $x, y$，描述一条连接 $x$ 号洞穴与 $y$ 号洞穴的通路。\n\n- 读入完成之后，交互库将调用恰好一次函数 `explore`，用输入的数据测试你的函数。你的函数正确返回后，交互库会判断你的计算是否正确，若正确则会输出 `Correct` 和交互函数调用次数相关信息，否则会输出相应的错误信息。", "inputFormat": "", "outputFormat": "", "hint": "数据第一行的三个整数分别表示三种操作的调用次数限制，即 `modify(x)` 调用次数不能超过 $100$，`query(x)` 调用次数不能超过 $200$，`check(x)` 调用次数不能超过 $300$。\n\n数据第二行的两个整数分别表示洞穴数和通路条数，即 $N = 3 , M = 2$。\n\n`report(x, y)` 调用次数不能超过 $M$，该例子中即不超过 $2$ 次。\n\n下面是一个正确的交互过程：\n\n| 选手程序 | 交互库 | 说明 |\n| :----------: | :----------: | :----------: |\n|  | 调用 $\\text{explore}(3,2)$ | 开始测试 |\n| 调用 $\\text{modify}(0)$ |  | 对 $0$ 号洞穴做操作 $1$ |\n| 调用 $\\text{query}(2)$ | 返回 $0$ | 目前 $2$ 号洞穴的光源状态是关闭 |\n| 调用 $\\text{report}(0,1)$ |  | 发现了道路 $(0,1)$ 并记录 |\n| 调用 $\\text{check}(0)$ | 返回 $1$ | 与 $0$ 号洞穴相关的道路都已被记录 |\n| 调用 $\\text{report}(2,1)$ |  | 发现了道路 $(2,1)$ 并记录 |\n| 运行结束并返回 | 向屏幕打印 $\\text{Correct}$ | 交互结束，结果正确 |\n\n### 下发文件说明\n\n在本试题目录下：\n\n1. `grader.cpp/c` 以及 `graderhelperlib.pas` 是我们提供的交互库参考实现。\n\n2. `explore.h` 和 `grader.pas` 是头文件，选手不用关心具体内容。\n\n3. `template_explore.cpp/c/pas` 是我们提供的样例解题源代码。\n\n4. `explore1.in`、`explore2.in`、`explore3.in` 是样例输入，可供测试。\n\n选手注意对所有下发文件做好备份。评测只收取本试题目录下的`explore.c/cpp/pas`，并且对该程序以外的文件的修改无效。\n\n最终评测只会收取 `explore.cpp/c/pas`，修改选手目录下其他文件对评测无效。\n\n本题首先会受到和传统题相同的限制。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。你只能访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。\n\n在上述条件基础上，在一个测试点中，你得到满分，当且仅当：\n\n1. 你的每次函数调用均合法，且调用 `modify`、`query` 和 `check` 的次数分别不超过$L_m, L_q, L_c$。\n\n2. 由于 `report` 的调用次数限制为 $M$，你的每次调用都必须记录一条新的且存在的边；即每次调用 `report(x, y)` 时，应满足：有一条连接 $x$ 号洞穴和 $y$ 号洞穴的通路，且在这次调用之前从未调用过 `report(x, y)` 或 `report(y, x)`。\n\n3. 你实现的函数 `explore` 正常返回。\n\n4. 在 `explore` 函数返回时，你已经通过调用 `report` 记录了全部 $M$ 条通路。\n\n本题共 $25$ 个测试点，每个测试点 $4$ 分。每个测试点的数据规模和相关限制见下表。\n| 测试点编号 | $N=$ | $M=$ | $L_m=$ | $L_q=$ | $L_c=$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $3$ | $2$ | $100$ | $100$ | $100$ | 无 |\n| $2$ | $100$ | $10\\times N$ | $200$ | $10^4$ | $2\\times M$ | 无 |\n| $3$ | $200$ | $10\\times N$ | $200$ | $4\\times 10^4$ | $2\\times M$ | 无 |\n| $4$ | $300$ | $10\\times N$ |$299$  | $9\\times 10^4$ | $2\\times M$ | 无 |\n| $5$ | $500$ | $10\\times N$ | $499$ | $1.5\\times 10^5$ | $2\\times M$ | 无 |\n| $6$ | $59998$ | $\\frac{N}{2}$ | $17\\times N$ | $17\\times N$ | $0$ | $A$ |\n| $7$ | $99998$ | $\\frac{N}{2}$ | $18\\times N$ | $18\\times N$ | $0$ | $A$ |\n| $8$ | $199998$ | $\\frac{N}{2}$ | $19\\times N$ | $19\\times N$ | $0$ | $A$ |\n| $9$ | $199998$ | $\\frac{N}{2}$ | $19\\times N$ | $19\\times N$ | $0$ | $A$ |\n| $10$ | $99997$ | $N-1$ | $18\\times N$ | $18\\times N$ | $0$ | $B$ |\n| $11$ | $199997$ | $N-1$ | $19\\times N$ | $19\\times N$ | $0$ | $B$ |\n| $12$ | $99996$ | $N-1$ | $10^7$ | $10^7$ | $2\\times M$ | $C$ |\n| $13$ | $199996$ | $N-1$ | $10^7$ | $10^7$ | $2\\times M$ | $C$ |\n| $14$ | $199996$ | $N-1$ | $10^7$ | $10^7$ | $2\\times M$ | $C$ |\n| $15$ | $99995$ | $N-1$ | $10^7$ | $10^7$ | $2\\times M$ | $D$ |\n| $16$ | $99995$ | $N-1$ | $10^7$ | $10^7$ | $2\\times M$ | $D$ |\n| $17$ | $199995$ | $N-1$ | $10^7$ | $10^7$ | $2\\times M$ | $D$ |\n| $18$ | $1004$ | $2\\times 10^3$ | $10^7$ | $5\\times 10^4$ | $2\\times M$ | 无 |\n| $19$ | $1004$ | $3\\times 10^3$ | $10^7$ | $5\\times 10^4$ | $2\\times M$ | 无 |\n| $20$ | $1004$ | $3\\times 10^3$ | $10^7$ | $5\\times 10^4$ | $2\\times M$ | 无 |\n| $21$ | $5\\times 10^4$ | $2\\times N$ | $10^7$ | $10^7$ | $2\\times M$ |  无|\n| $22$ | $10^5$ | $2\\times N$ | $10^7$ | $10^7$ | $2\\times M$ | 无 |\n| $23$ | $1.5\\times 10^5$ | $2\\times 10^5$ | $10^7$ | $10^7$ | $2\\times M$ | 无 |\n| $24$ | $2\\times 10^5$ | $2.5\\times 10^5$ | $10^7$ | $10^7$ | $2\\times M$ | 无 |\n| $25$ | $2\\times 10^5$ | $3\\times 10^5$ | $10^7$ | $10^7$ | $2\\times M$ | 无 |\n\n再次提醒，题目保证测试所使用的图在交互开始之前已经完全确定，而不会根据和你的程序的交互动态构造。\n\n表中特殊性质栏中变量的含义如下：\n\nA：保证每个点的度数恰好为 $1$。\n\nB：保证对于每个 $x > 0$，存在恰好一个 $y < x$ 的 $y$ 使得 $x$ 号洞穴与 $y$ 号洞穴有通路直接相连。\n\nC：存在 $0 \\sim N - 1$ 的一个排列 $p_0, p_1, \\cdots , p_{N-1}$，使得对任意 $1 \\leq i < N$，存在一条连接洞穴编号分别为 $p_{i-1}$ 与 $p_i$ 的通路。\n\nD：保证图连通。\n\n- 提示：你的程序可以通过判断传入的 $N$ 的个位来区分上述不同的数据类型。", "locale": "zh-CN"}}}
{"pid": "P5474", "type": "P", "difficulty": 4, "samples": [["5 5\n.....\n.E.S.\n.....\n.....\n.N.E.", "(4,3)\n(1,3)\n(1,1)\n(4,1)"], ["4 3\n...\n.N.\n.S.\n...", "(1,1)\n(2,1)"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "Special Judge", "CCO（加拿大）"], "title": "[CCO 2015] 冰上车", "background": null, "description": "**本题译自 [CCO 2015](https://cemc.math.uwaterloo.ca/contests/computing/2015/index.html) Day2 T1「[Cars on Ice](https://cemc.math.uwaterloo.ca/contests/computing/2015/stage%202/day2.pdf)」**\n\n在圣诞夜守卫银行是一件非常无聊的事情。这就是 Barry 想要去停车场附近溜冰的原因。然而因为其他守卫把车停在了那里，停车场并不是空的。所以 Barry 决定把他们的车推出停车场。他注意到那些停着的车面对的方向是东南西北之一。因为停车场结冰了，所以推一辆车将会使得他滑行直至离开停车场或撞上其他的车。这些车只能朝他们面向的方向推。为了不撞车，Barry 找你帮忙，让你帮他计算出将车推出停车场的顺序，以便他清空停车场。", "inputFormat": "第一行包括两个整数 $N,M$，表示停车场的行列数。  \n接下来 $N$ 行每行 $M$ 个字符，描述一个停车场。其中 `.` 代表这是一个空的车位，而 `N`, `E`, `W`, `S` 表示一辆车，分别表示这辆车面朝北、东、西、南。", "outputFormat": "输出在不发生撞车的情况下将车推出的顺序，每辆车按格式 $(r,c)$ 输出，其中 $(r,c)$ 是车在停车场中的坐标，$(0,0)$ 为左上角，$(N-1,M-1)$ 为右下角。  \n保证至少有一个有效解，如果有多个解，输出任意一个。", "hint": "#### 样例解释 1\n\n唯一一辆在开始时没有被其他车挡住的是在 $(4,3)$ 的车，当这架车被推到停车场右边后，在它上面的车（在 $(1,3)$ 的车）可以被推出，然后是在 $(1,1)$ 的车，最后是在 $(4,1)$ 的车，停车场得以清空。\n\n#### 样例解释 2\n\n两辆车都可以作为第一个被推出停车场的车，所以样例输出 2 是正确的，同时顺序与其相反的输出也是正确的。\n\n#### 数据范围\n\n对于 $70\\%$ 的数据，$1\\le N,M \\le 100$；\n\n对于 $100\\%$ 的数据，$1\\le N,M \\le 2000$。", "locale": "zh-CN", "translations": {"en": {"title": "[CCO 2015] Cars on Ice", "background": "", "description": "**This problem is translated from [CCO 2015](https://cemc.math.uwaterloo.ca/contests/computing/2015/index.html) Day2 T1 \"[Cars on Ice](https://cemc.math.uwaterloo.ca/contests/computing/2015/stage%202/day2.pdf)\".**\n\nGuarding a bank on Christmas Eve is very boring. That is why Barry wants to go skating near the parking lot. However, because other guards parked their cars there, the parking lot is not empty. So Barry decides to push their cars out of the parking lot. He notices that the parked cars are facing one of the four directions: north, south, east, or west. Since the parking lot is icy, pushing a car will make it slide until it leaves the parking lot or crashes into another car. Each car can only be pushed in the direction it is facing. To avoid crashes, Barry asks you for help: compute an order to push the cars out of the parking lot so that he can clear the entire lot.", "inputFormat": "The first line contains two integers $N, M$, representing the number of rows and columns of the parking lot.  \nThe next $N$ lines each contain $M$ characters describing the parking lot. `.` means an empty space, and `N`, `E`, `W`, `S` indicate a car, meaning the car is facing north, east, west, and south, respectively.", "outputFormat": "Output an order to push the cars out without any crashes. Output each car in the format $(r,c)$, where $(r,c)$ is the car’s coordinate in the parking lot. $(0,0)$ is the top-left corner and $(N-1,M-1)$ is the bottom-right corner.  \nIt is guaranteed that there is at least one valid solution. If there are multiple solutions, output any one.", "hint": "#### Sample Explanation 1\n\nThe only car that is not blocked by any other car at the start is the car at $(4,3)$. After this car is pushed out through the right side of the parking lot, the car above it (the car at $(1,3)$) can be pushed out, then the car at $(1,1)$, and finally the car at $(4,1)$. The parking lot is then cleared.\n\n#### Sample Explanation 2\n\nEither car can be the first car pushed out of the parking lot, so Sample Output 2 is correct. The output in the reverse order is also correct.\n\n#### Constraints\n\nFor $70\\%$ of the testdata, $1 \\le N, M \\le 100$.\n\nFor $100\\%$ of the testdata, $1 \\le N, M \\le 2000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CCO 2015] 冰上车", "background": null, "description": "**本题译自 [CCO 2015](https://cemc.math.uwaterloo.ca/contests/computing/2015/index.html) Day2 T1「[Cars on Ice](https://cemc.math.uwaterloo.ca/contests/computing/2015/stage%202/day2.pdf)」**\n\n在圣诞夜守卫银行是一件非常无聊的事情。这就是 Barry 想要去停车场附近溜冰的原因。然而因为其他守卫把车停在了那里，停车场并不是空的。所以 Barry 决定把他们的车推出停车场。他注意到那些停着的车面对的方向是东南西北之一。因为停车场结冰了，所以推一辆车将会使得他滑行直至离开停车场或撞上其他的车。这些车只能朝他们面向的方向推。为了不撞车，Barry 找你帮忙，让你帮他计算出将车推出停车场的顺序，以便他清空停车场。", "inputFormat": "第一行包括两个整数 $N,M$，表示停车场的行列数。  \n接下来 $N$ 行每行 $M$ 个字符，描述一个停车场。其中 `.` 代表这是一个空的车位，而 `N`, `E`, `W`, `S` 表示一辆车，分别表示这辆车面朝北、东、西、南。", "outputFormat": "输出在不发生撞车的情况下将车推出的顺序，每辆车按格式 $(r,c)$ 输出，其中 $(r,c)$ 是车在停车场中的坐标，$(0,0)$ 为左上角，$(N-1,M-1)$ 为右下角。  \n保证至少有一个有效解，如果有多个解，输出任意一个。", "hint": "#### 样例解释 1\n\n唯一一辆在开始时没有被其他车挡住的是在 $(4,3)$ 的车，当这架车被推到停车场右边后，在它上面的车（在 $(1,3)$ 的车）可以被推出，然后是在 $(1,1)$ 的车，最后是在 $(4,1)$ 的车，停车场得以清空。\n\n#### 样例解释 2\n\n两辆车都可以作为第一个被推出停车场的车，所以样例输出 2 是正确的，同时顺序与其相反的输出也是正确的。\n\n#### 数据范围\n\n对于 $70\\%$ 的数据，$1\\le N,M \\le 100$；\n\n对于 $100\\%$ 的数据，$1\\le N,M \\le 2000$。", "locale": "zh-CN"}}}
{"pid": "P5475", "type": "P", "difficulty": 5, "samples": [["7 1\n100 1\n120 3\n130 5\n140 6\n150 8\n165 10\n170 12", "5.00"], ["12 4\n0 1\n2 1\n3 3\n6 1\n9 6\n12 5\n21 1\n23 1\n24 3\n27 1\n30 8\n33 6", "4.50"], ["2 4\n40287 8\n20338194 8", "0.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2015", "CCO（加拿大）"], "title": "[CCO 2015] 定音鼓手", "background": "", "description": "**本题译自 [CCO 2015](https://cemc.math.uwaterloo.ca/contests/computing/2015/index.html) Day2 T2「[Tiampist](https://cemc.math.uwaterloo.ca/contests/computing/2015/stage%202/day2.pdf)」**\n\n计算机科学家不常帮助打击乐家，但今天，这将改变。既然我们没法同时帮助所有打击乐家，那么就先设法帮助定音鼓手。\n\n定音鼓是一种能被调整至特定音调的大鼓。定音鼓手用编号为 $1\\dots D$ 的 $D$ 个定音鼓演奏。现在，他们在演奏一个有 $N$ 个音符的小节，第 $i$ 个音符演奏 $T_i$ 秒，它的音调是 $P_i$，而 $P_i$ 属于 $\\{\\text{F},$ $\\text{F}^♯,$ $\\text{G,}$ $\\text{G}^♯,$ $\\text{A},$ $\\text{A}^♯,$ $\\text{B},$ $\\text{C},$ $\\text{C}^♯,$ $\\text{D},$ $\\text{D}^♯,$ $\\text{E}\\}$ 这 12 个音符中的一个音符。\n\n在一个时刻，一个定音鼓必须先被调到某个音调，才能用来弹奏这个音调，因此定音鼓手能演奏音符 $i$ 当且仅当这个定音鼓在时间 $T_i$ 调到了音调 $P_i$。\n\n在这个片段当中的每个音符都是在一个八度的范围内，从 $\\text{F}$ 上至 $\\text{E}$，这就意味着上面可能的音符的音调是升序排序的。为了使你的计算更加方便，我们将使用整数 $1$ 到 $12$ 来表示这十二个音符。\n\n| 1 | 2 | 3 |4 | 5 | 6 |7 | 8 |9 |10 | 11 | 12 |\n| ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |\n| $\\text{F}$ | $\\text{F}^♯$ | $\\text{G}$|$\\text{G}^♯$ |$\\text{A}$ | $\\text{A}^♯$ |$\\text{B}$| $\\text{C}$ |$\\text{C}^♯$ |$\\text{D}$ | $\\text{D}^♯$ |$\\text{E}$ |\n\n以上是所有定音鼓能调到的音调。\n\n在演奏开始前，定音鼓手可以随意调整各个定音鼓到任意他们想要的音调。然而，在演奏时，他们可能需要在音符间隙快速地调整他们，这样他们才能在正确的时候演奏出正确的音符。这些鼓从 $1$ 到 $D$ 编号，在任意时刻，鼓 $i+1$ 的音调必须比鼓 $i$ 的音调高。鼓手必须在（当前时刻）不需要演奏时才能调整一个鼓的音高，并且鼓手一次只能调整一个鼓的音高（假设没有人帮他调节）。\n\n因此，这并不是一件简单的事，定音鼓手想要让他们有尽可能多的时间调节。具体来说，他们想要最大化在演奏过程中的调整时间以便使他们可以在演奏中以最快速度做必要的音调调节。", "inputFormat": "第一行两个整数 $N,D$，分别表示被弹奏的音符和鼓的数量。\n\n接下来 $N$ 行每行两个整数 $T_i$ 和 $P_i$，表示第 $i$ 个音符演奏的时间和音调。", "outputFormat": "输出一行包含一个实数，下取整至两位小数，表示最大的调整时间。输出 $0.00$ 表示没有必要重新调节。", "hint": "> 【样例解释 1】\n\n> 如果只有一个鼓，定音鼓手为了可以演奏下一个音符，必须在每个音符弹奏后重新调节。\n\n> 如果有两个鼓，答案应该是 $10.00$，当留下高音鼓调到音调 $12$ 时达到这个答案。\n\n> 【样例解释 2】\n\n> 前六个音符里只有四个音调：$1$，$3$，$5$，$6$，类似的，最后六个音符里只有 $1$，$3$，$6$，$8$ 四个音调。\n\n> 一个最佳策略是，预先调整四个鼓到 $1$，$3$，$5$，$6$，在第六个音符后，定音鼓手可以花 $4.50$ 秒调整最高音的鼓到音调 $8$，然后另外 $4.50$ 秒调整次高音鼓到音调 $6$，完成时刚好是时候去弹奏第七个音符。\n\n> 【样例解释 3】\n\n> 则是一个更为典型的定音鼓片段，只包含一个音符，因此不需要重新调节。\n\n【数据范围】\n\n对于 $60\\%$ 的数据，$1\\le N \\le 50,1\\le D\\le 3$；\n\n对于 $100\\%$ 的数据，$1\\le N \\le 100,$ $1\\le D\\le 4,$ $0\\le T_1<T_2<...<T_{N-1}<T_N\\le 10^9,$ $1\\le P_i \\le 12(1\\le i \\le N)$。", "locale": "zh-CN", "translations": {"en": {"title": "[CCO 2015] Timpanist", "background": "", "description": "**This problem is translated from [CCO 2015](https://cemc.math.uwaterloo.ca/contests/computing/2015/index.html) Day2 T2 \"[Tiampist](https://cemc.math.uwaterloo.ca/contests/computing/2015/stage%202/day2.pdf)\".**\n\nComputer scientists do not often help percussionists, but today that will change. Since we cannot help all percussionists at once, let us help the timpanist first.\n\nA timpani is a large drum that can be tuned to a specific pitch. A timpanist performs using $D$ timpani numbered $1 \\dots D$. Now they are playing a measure with $N$ notes. The $i$-th note is played at time $T_i$ seconds, and its pitch is $P_i$, where $P_i$ is one of the following 12 notes: $\\{\\text{F},$ $\\text{F}^♯,$ $\\text{G,}$ $\\text{G}^♯,$ $\\text{A},$ $\\text{A}^♯,$ $\\text{B},$ $\\text{C},$ $\\text{C}^♯,$ $\\text{D},$ $\\text{D}^♯,$ $\\text{E}\\}$.\n\nAt any moment, a timpani must be tuned to a pitch before it can be used to play that pitch. Therefore, the timpanist can play note $i$ if and only if, at time $T_i$, some timpani is tuned to pitch $P_i$.\n\nAll notes in this excerpt are within one octave, from $\\text{F}$ up to $\\text{E}$, which means the possible pitches above are in increasing order. To make computation easier, we will use integers $1$ to $12$ to represent these twelve notes.\n\n| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |\n| ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |\n| $\\text{F}$ | $\\text{F}^♯$ | $\\text{G}$ | $\\text{G}^♯$ | $\\text{A}$ | $\\text{A}^♯$ | $\\text{B}$ | $\\text{C}$ | $\\text{C}^♯$ | $\\text{D}$ | $\\text{D}^♯$ | $\\text{E}$ |\n\nThese are all the pitches that each timpani can be tuned to.\n\nBefore the performance starts, the timpanist may freely tune each timpani to any pitch they want. However, during the performance, they may need to quickly retune them in the gaps between notes, so that they can play the correct note at the correct time. The drums are numbered from $1$ to $D$. At any time, the pitch of drum $i+1$ must be higher than the pitch of drum $i$. The timpanist may retune a drum only when they are not required to play at that moment, and they can retune only one drum at a time (assume no one helps them tune).\n\nTherefore, this is not easy. The timpanist wants to have as much time as possible for retuning. More specifically, they want to maximize the retuning time during the performance so that they can make necessary pitch changes as quickly as possible while playing.", "inputFormat": "The first line contains two integers $N, D$, representing the number of notes played and the number of drums.\n\nThe next $N$ lines each contain two integers $T_i$ and $P_i$, representing the time and pitch of the $i$-th note.", "outputFormat": "Output a single line containing one real number, floored to two decimal places, representing the maximum retuning time. Output $0.00$ if no retuning is necessary.", "hint": "> [Sample Explanation 1]\n\n> If there is only one drum, then to play the next note, the timpanist must retune after every note.\n\n> If there are two drums, the answer should be $10.00$, achieved when the higher-pitched drum is left tuned to pitch $12$.\n\n> [Sample Explanation 2]\n\n> Among the first six notes, there are only four pitches: $1$, $3$, $5$, $6$. Similarly, among the last six notes, there are only four pitches: $1$, $3$, $6$, $8$.\n\n> One optimal strategy is to pre-tune four drums to $1$, $3$, $5$, $6$. After the sixth note, the timpanist can spend $4.50$ seconds tuning the highest-pitched drum to pitch $8$, then another $4.50$ seconds tuning the second-highest drum to pitch $6$, finishing exactly in time to play the seventh note.\n\n> [Sample Explanation 3]\n\n> This is a more typical timpani excerpt: it contains only one note, so no retuning is needed.\n\nConstraints\n\nFor $60\\%$ of the testdata, $1\\le N \\le 50, 1\\le D\\le 3$.\n\nFor $100\\%$ of the testdata, $1\\le N \\le 100,$ $1\\le D\\le 4,$ $0\\le T_1<T_2<...<T_{N-1}<T_N\\le 10^9,$ $1\\le P_i \\le 12(1\\le i \\le N)$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CCO 2015] 定音鼓手", "background": "", "description": "**本题译自 [CCO 2015](https://cemc.math.uwaterloo.ca/contests/computing/2015/index.html) Day2 T2「[Tiampist](https://cemc.math.uwaterloo.ca/contests/computing/2015/stage%202/day2.pdf)」**\n\n计算机科学家不常帮助打击乐家，但今天，这将改变。既然我们没法同时帮助所有打击乐家，那么就先设法帮助定音鼓手。\n\n定音鼓是一种能被调整至特定音调的大鼓。定音鼓手用编号为 $1\\dots D$ 的 $D$ 个定音鼓演奏。现在，他们在演奏一个有 $N$ 个音符的小节，第 $i$ 个音符演奏 $T_i$ 秒，它的音调是 $P_i$，而 $P_i$ 属于 $\\{\\text{F},$ $\\text{F}^♯,$ $\\text{G,}$ $\\text{G}^♯,$ $\\text{A},$ $\\text{A}^♯,$ $\\text{B},$ $\\text{C},$ $\\text{C}^♯,$ $\\text{D},$ $\\text{D}^♯,$ $\\text{E}\\}$ 这 12 个音符中的一个音符。\n\n在一个时刻，一个定音鼓必须先被调到某个音调，才能用来弹奏这个音调，因此定音鼓手能演奏音符 $i$ 当且仅当这个定音鼓在时间 $T_i$ 调到了音调 $P_i$。\n\n在这个片段当中的每个音符都是在一个八度的范围内，从 $\\text{F}$ 上至 $\\text{E}$，这就意味着上面可能的音符的音调是升序排序的。为了使你的计算更加方便，我们将使用整数 $1$ 到 $12$ 来表示这十二个音符。\n\n| 1 | 2 | 3 |4 | 5 | 6 |7 | 8 |9 |10 | 11 | 12 |\n| ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |\n| $\\text{F}$ | $\\text{F}^♯$ | $\\text{G}$|$\\text{G}^♯$ |$\\text{A}$ | $\\text{A}^♯$ |$\\text{B}$| $\\text{C}$ |$\\text{C}^♯$ |$\\text{D}$ | $\\text{D}^♯$ |$\\text{E}$ |\n\n以上是所有定音鼓能调到的音调。\n\n在演奏开始前，定音鼓手可以随意调整各个定音鼓到任意他们想要的音调。然而，在演奏时，他们可能需要在音符间隙快速地调整他们，这样他们才能在正确的时候演奏出正确的音符。这些鼓从 $1$ 到 $D$ 编号，在任意时刻，鼓 $i+1$ 的音调必须比鼓 $i$ 的音调高。鼓手必须在（当前时刻）不需要演奏时才能调整一个鼓的音高，并且鼓手一次只能调整一个鼓的音高（假设没有人帮他调节）。\n\n因此，这并不是一件简单的事，定音鼓手想要让他们有尽可能多的时间调节。具体来说，他们想要最大化在演奏过程中的调整时间以便使他们可以在演奏中以最快速度做必要的音调调节。", "inputFormat": "第一行两个整数 $N,D$，分别表示被弹奏的音符和鼓的数量。\n\n接下来 $N$ 行每行两个整数 $T_i$ 和 $P_i$，表示第 $i$ 个音符演奏的时间和音调。", "outputFormat": "输出一行包含一个实数，下取整至两位小数，表示最大的调整时间。输出 $0.00$ 表示没有必要重新调节。", "hint": "> 【样例解释 1】\n\n> 如果只有一个鼓，定音鼓手为了可以演奏下一个音符，必须在每个音符弹奏后重新调节。\n\n> 如果有两个鼓，答案应该是 $10.00$，当留下高音鼓调到音调 $12$ 时达到这个答案。\n\n> 【样例解释 2】\n\n> 前六个音符里只有四个音调：$1$，$3$，$5$，$6$，类似的，最后六个音符里只有 $1$，$3$，$6$，$8$ 四个音调。\n\n> 一个最佳策略是，预先调整四个鼓到 $1$，$3$，$5$，$6$，在第六个音符后，定音鼓手可以花 $4.50$ 秒调整最高音的鼓到音调 $8$，然后另外 $4.50$ 秒调整次高音鼓到音调 $6$，完成时刚好是时候去弹奏第七个音符。\n\n> 【样例解释 3】\n\n> 则是一个更为典型的定音鼓片段，只包含一个音符，因此不需要重新调节。\n\n【数据范围】\n\n对于 $60\\%$ 的数据，$1\\le N \\le 50,1\\le D\\le 3$；\n\n对于 $100\\%$ 的数据，$1\\le N \\le 100,$ $1\\le D\\le 4,$ $0\\le T_1<T_2<...<T_{N-1}<T_N\\le 10^9,$ $1\\le P_i \\le 12(1\\le i \\le N)$。", "locale": "zh-CN"}}}
{"pid": "P5476", "type": "P", "difficulty": 6, "samples": [["4 2\n3\n3 1 1 2 3 4 2\n3 1 4 2 3 3 2\n4 2 1 2 4 4 1 4 4\n6\n2 2\n2 3\n1 2 3\n2 2\n2 3\n2 4", "0.88889\n0.33333\n0.44444\n0.11111\n0.00000"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2015", "Special Judge", "CCO（加拿大）"], "title": "[CCO 2015] 挖掘", "background": "", "description": "**本题译自 [CCO 2015](https://cemc.math.uwaterloo.ca/contests/computing/2015/index.html) Day2 T3「[Eggscavation](https://cemc.math.uwaterloo.ca/contests/computing/2015/stage%202/day2.pdf)」**\n\n度假时间到了！你厌倦了 C shell（编程语言），所以你决定去收集贝壳（Seashell，与 C Shell 同音）。\n\n你决定去游览 Cartesia 国的岛度假。该岛以拥有优美的方形沙滩而著名。该沙滩被划分成 $N\\times N$ 的矩阵组成，你带上了你可靠的铲子，你可以用铲子在岛上挖最多 $K\\times K$的正方形子矩阵。为了保证你的铲子是可靠的，你所挖的正方形子矩阵要保证所挖的 $K\\times K$ 的范围都在沙滩上。\n\n在岛下，有 $M$ 种未探索过的贝壳种类。具体来说，对于每个贝壳种类 $i$，有 $S_i$ 个贝壳在不同的位置。对于每个不同的种类的贝壳，你把它挖出来，然后带回家，然后以每个 $1$ 美元的价格卖给一个科学家。多个同种类的贝壳没有附加价值。\n\n麻烦的是，一种华丽的渡渡鸟在沙滩上跑来跑去。在一个给定时刻，他可能会在一个网格里埋一个蛋，包括那些已经有蛋或者网格的网格。坏消息是，如果你铲子挖出来的 $K\\times K$ 的子正方形矩阵里包含渡渡鸟的蛋，科学家会因为你正在危害濒危物种而非常着急，因此没人会给你钱。\n\n想到这些，你决定坐下来，开始写程序，进行模拟挖掘。你将会去计算你的挖掘的可能性，当你在不同时间点以均等可能性选择一个挖掘方案时，需要保证至少一个收入值来偿还你的学生贷款。谁想白忙活一场呢？", "inputFormat": "第一行包括两个整数 $N,K$，表示岛和铲子的尺寸\n\n第二行一个数 $M$，表示贝壳种类数。接下来 $M$ 行每行表示一个种类 $i$，包含一个整数 $S_i$，接着 $2\\times S_i$ 个数，为一些在 $(1,1)$ 与 $(N,M)$ 之间的坐标，表示 $S_i$ 个贝壳埋的位置。\n\n接下来 $T$ 行每行表示一个时间点，按时间由最远到最近排序，每行为如下格式之一：\n- $1$ $A_i$ $B_i$，表示渡渡鸟在 $(A_i,B_i)$ 下了一个蛋\n- $2$ $V_i$，表示我们想计算一个在该时间点获利 $\\geq V_i$ 的随机挖掘的可能性。注意贝壳和蛋在计算时都没有没有被真正地挖出来。", "outputFormat": "对于每个询问，输出一行表示一次获得至少指定利润的随机挖掘的可能性。你的答案与标准答案之间的差值的绝对值不能大于 $10^{-4}$。", "hint": "【样例解释】\n\n初始时，贝壳的排布如下所示：\n\n![CCO2015D2T3Pic1](http://miao.su/images/2018/08/16/aaa6d86f.png)\n\n我们将用铲子挖至多 $2\\times 2$ 的格子，因此我们有 $9$ 种可能的挖掘。\n当没有蛋出现时，$8$ 种挖掘包含至少两种贝壳，$3$ 种挖掘包含三种贝壳。\n\n一个蛋掉进了有贝壳 $1,2$ 的方格。\n\n在这种情况下，$\\frac{4}{9}$ 的挖掘包含至少两种贝壳且没有蛋，仅有一种挖掘会包含所有种类的贝壳并且没有蛋，那就是挖掘左下角。最终输出指明没有任何一种挖掘包含四种贝壳。\n\n【数据范围】\n\n对于至少 $15\\%$ 的数据，$1\\le N \\le 40$；\n\n对于另外 $25\\%$ 的数据，所有的更新操作在询问操作前出现；\n\n对于 $100\\%$ 的数据，$1\\le K \\le N\\le 2500,$ $0\\le M \\le 10^5,$ $1\\le S_i\\le 4,$ $0\\le T\\le 10000,$ $1\\le A_i,B_i \\le N,$ $1\\le V_i\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[CCO 2015] Excavation.", "background": "", "description": "**This problem is translated from [CCO 2015](https://cemc.math.uwaterloo.ca/contests/computing/2015/index.html) Day 2 T3 “[Eggscavation](https://cemc.math.uwaterloo.ca/contests/computing/2015/stage%202/day2.pdf)”.**\n\nVacation time has arrived. You are tired of C shell (a programming language), so you decide to collect seashells (“Seashell”, a homophone of “C Shell”).\n\nYou decide to visit the island nation of Cartesia for a vacation. The island is famous for its beautiful square beach. The beach is divided into an $N \\times N$ grid. You bring your trusty shovel, and you can dig out a square submatrix of size at most $K \\times K$ on the island. To ensure your shovel is reliable, the $K \\times K$ area you dig must lie entirely within the beach.\n\nUnder the island, there are $M$ unexplored species of shells. Specifically, for each species $i$, there are $S_i$ shells at distinct positions. For each different species of shell, you dig it up, take it home, and sell it to a scientist for $1$ dollar each. Multiple shells of the same species have no extra value.\n\nUnfortunately, a fancy dodo bird runs around on the beach. At a given moment, it may bury an egg in a grid cell, including cells that already have an egg or shells. The bad news is: if the $K \\times K$ square submatrix you dig contains a dodo egg, the scientist will get very upset because you are harming an endangered species, and nobody will pay you.\n\nAfter thinking about this, you decide to sit down and write a program to simulate the excavation. You need to compute the probability of your excavation outcomes: when you choose a digging plan uniformly at random at different times, what is the probability that you can earn at least some amount to repay your student loans? Nobody wants to work for nothing.", "inputFormat": "The first line contains two integers $N, K$, representing the size of the island and the shovel.\n\nThe second line contains an integer $M$, the number of shell species. The next $M$ lines each describe a species $i$: they contain an integer $S_i$, followed by $2 \\times S_i$ numbers representing coordinates between $(1,1)$ and $(N,N)$, indicating the positions where the $S_i$ shells are buried.\n\nThen there are $T$ lines, each representing a time point, sorted from the farthest time to the most recent. Each line is in one of the following formats:\n- $1$ $A_i$ $B_i$, meaning the dodo lays an egg at $(A_i, B_i)$.\n- $2$ $V_i$, meaning we want to compute the probability that a random excavation at this time point yields profit $\\ge V_i$. Note that shells and eggs are not actually dug up during these computations.", "outputFormat": "For each query, output one line giving the probability that a random excavation yields at least the specified profit. The absolute error between your answer and the standard answer must not exceed $10^{-4}$.", "hint": "[Sample Explanation.]\n\nInitially, the shells are arranged as shown below:\n\n![CCO2015D2T3Pic1](http://miao.su/images/2018/08/16/aaa6d86f.png)\n\nWe will dig at most a $2 \\times 2$ area, so there are $9$ possible excavations. When there are no eggs, $8$ excavations contain at least two species of shells, and $3$ excavations contain three species of shells.\n\nAn egg falls into the cell that contains shells $1$ and $2$.\n\nIn this case, $\\frac{4}{9}$ of the excavations contain at least two species of shells and no egg. Only one excavation contains all species of shells and no egg: digging the bottom-left corner. The final output indicates that there is no excavation that contains four species of shells.\n\n[Constraints.]\n\nFor at least $15\\%$ of the testdata, $1 \\le N \\le 40$.\n\nFor another $25\\%$ of the testdata, all update operations appear before any query operations.\n\nFor $100\\%$ of the testdata, $1 \\le K \\le N \\le 2500$, $0 \\le M \\le 10^5$, $1 \\le S_i \\le 4$, $0 \\le T \\le 10000$, $1 \\le A_i, B_i \\le N$, $1 \\le V_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CCO 2015] 挖掘", "background": "", "description": "**本题译自 [CCO 2015](https://cemc.math.uwaterloo.ca/contests/computing/2015/index.html) Day2 T3「[Eggscavation](https://cemc.math.uwaterloo.ca/contests/computing/2015/stage%202/day2.pdf)」**\n\n度假时间到了！你厌倦了 C shell（编程语言），所以你决定去收集贝壳（Seashell，与 C Shell 同音）。\n\n你决定去游览 Cartesia 国的岛度假。该岛以拥有优美的方形沙滩而著名。该沙滩被划分成 $N\\times N$ 的矩阵组成，你带上了你可靠的铲子，你可以用铲子在岛上挖最多 $K\\times K$的正方形子矩阵。为了保证你的铲子是可靠的，你所挖的正方形子矩阵要保证所挖的 $K\\times K$ 的范围都在沙滩上。\n\n在岛下，有 $M$ 种未探索过的贝壳种类。具体来说，对于每个贝壳种类 $i$，有 $S_i$ 个贝壳在不同的位置。对于每个不同的种类的贝壳，你把它挖出来，然后带回家，然后以每个 $1$ 美元的价格卖给一个科学家。多个同种类的贝壳没有附加价值。\n\n麻烦的是，一种华丽的渡渡鸟在沙滩上跑来跑去。在一个给定时刻，他可能会在一个网格里埋一个蛋，包括那些已经有蛋或者网格的网格。坏消息是，如果你铲子挖出来的 $K\\times K$ 的子正方形矩阵里包含渡渡鸟的蛋，科学家会因为你正在危害濒危物种而非常着急，因此没人会给你钱。\n\n想到这些，你决定坐下来，开始写程序，进行模拟挖掘。你将会去计算你的挖掘的可能性，当你在不同时间点以均等可能性选择一个挖掘方案时，需要保证至少一个收入值来偿还你的学生贷款。谁想白忙活一场呢？", "inputFormat": "第一行包括两个整数 $N,K$，表示岛和铲子的尺寸\n\n第二行一个数 $M$，表示贝壳种类数。接下来 $M$ 行每行表示一个种类 $i$，包含一个整数 $S_i$，接着 $2\\times S_i$ 个数，为一些在 $(1,1)$ 与 $(N,M)$ 之间的坐标，表示 $S_i$ 个贝壳埋的位置。\n\n接下来 $T$ 行每行表示一个时间点，按时间由最远到最近排序，每行为如下格式之一：\n- $1$ $A_i$ $B_i$，表示渡渡鸟在 $(A_i,B_i)$ 下了一个蛋\n- $2$ $V_i$，表示我们想计算一个在该时间点获利 $\\geq V_i$ 的随机挖掘的可能性。注意贝壳和蛋在计算时都没有没有被真正地挖出来。", "outputFormat": "对于每个询问，输出一行表示一次获得至少指定利润的随机挖掘的可能性。你的答案与标准答案之间的差值的绝对值不能大于 $10^{-4}$。", "hint": "【样例解释】\n\n初始时，贝壳的排布如下所示：\n\n![CCO2015D2T3Pic1](http://miao.su/images/2018/08/16/aaa6d86f.png)\n\n我们将用铲子挖至多 $2\\times 2$ 的格子，因此我们有 $9$ 种可能的挖掘。\n当没有蛋出现时，$8$ 种挖掘包含至少两种贝壳，$3$ 种挖掘包含三种贝壳。\n\n一个蛋掉进了有贝壳 $1,2$ 的方格。\n\n在这种情况下，$\\frac{4}{9}$ 的挖掘包含至少两种贝壳且没有蛋，仅有一种挖掘会包含所有种类的贝壳并且没有蛋，那就是挖掘左下角。最终输出指明没有任何一种挖掘包含四种贝壳。\n\n【数据范围】\n\n对于至少 $15\\%$ 的数据，$1\\le N \\le 40$；\n\n对于另外 $25\\%$ 的数据，所有的更新操作在询问操作前出现；\n\n对于 $100\\%$ 的数据，$1\\le K \\le N\\le 2500,$ $0\\le M \\le 10^5,$ $1\\le S_i\\le 4,$ $0\\le T\\le 10000,$ $1\\le A_i,B_i \\le N,$ $1\\le V_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5477", "type": "P", "difficulty": 5, "samples": [["4 7\n2 1 1\n2 1 2\n2 1 3\n2 1 4\n3\n3 4\n2 3\n1 2", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "2018", "洛谷原创", "O2优化"], "title": "[MtOI2018] 刷题？作业狂魔！", "background": "在临听到暑假的尾声以后，神奇的 cz 终于发觉自己的作业不能完成了。\n\n在他写完作业之前，你需要将他做作业的顺序告诉给他听，这样你们就可以一起玩了。", "description": "你拥有 $T$ 分钟的时间。\n\n做作业的顺序可以根据重要度 $v_i$ 来排序，但可能这不是最佳方案。且每项作业可能不止有一项，所以每项作业还有一个数量 $c_i$，每项 $t_i$ 分钟可以完成。\n\n而在做某作业之前可能要先写完某个作业，所以还给出 $M$ 个关系，每个关系包含两个数 $a,b$，代表 $a$ 是 $b$ 完成的前提，不存在 $a=b$ 的情况。\n\n关系不排除环的情况，cz 不想重做一遍作业，只好不做在环上的作业。\n\n当某作业做到一半但时间结束，则失去该作业重要度；当该作业只做了 $k$ 个，但 $k\\leq c_i$，则得到 $k\\times v_i$ 重要度，如果该作业没把 $c_i$ 个做完，则不得做其他作业。\n\n可存在 $b$ 有多个 $a$，但请注意一个作业的 **一个** 前提被做了以后，该作业就可以被做了。但 cz 非常专注，他写完一个作业以后就必须写**以该作业为前提的**作业。", "inputFormat": "输入共 $N+M+2$ 行\n\n第 $1$ 行输入 $2$ 个正整数 $N,T$。\n\n接下来共 $N$ 行输入，第 $i$ 行输入 $3$ 个正整数 $v_i,c_i,t_i$。\n\n第 $N+2$ 行输入 $1$ 个正整数 $1$ 行。\n\n接下来共 $M$ 行输入，意义同上。", "outputFormat": "输出共 $1$ 行 $1$ 个数，表示价值（重要度）最大值。", "hint": "### 子任务\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 10000,1 \\leq M \\leq 100000$\n\n其他值均在 long long 范围内。\n\n\n### 题目来源\n\n[MtOI2018 迷途の家の水题大赛](https://www.luogu.org/contest/11260) T1\n\n出题人：Doubleen\n\n56432", "locale": "zh-CN", "translations": {"en": {"title": "[MtOI2018] Grinding Problems? Homework Maniac!", "background": "After hearing that summer vacation is coming to an end, the magical cz finally realized that he cannot finish his homework.\n\nBefore he finishes the homework, you need to tell him the order in which to do it, so that you can play together.", "description": "You have $T$ minutes.\n\nThe order of doing homework can be sorted by importance $v_i$, but this may not be the best strategy. Also, each type of homework may have more than one item, so each homework also has a quantity $c_i$, and each item takes $t_i$ minutes to complete.\n\nBefore doing some homework, it may be necessary to finish some other homework first, so $M$ relations are given. Each relation contains two numbers $a$, $b$, meaning that $a$ is a prerequisite for completing $b$. There is no case where $a=b$.\n\nThe relations may contain cycles. cz does not want to redo homework, so he can only skip the homework that lies on cycles.\n\nIf the time ends when a homework is only half done, then you gain no importance from that homework. If for a homework you finish only $k$ items, and $k\\leq c_i$, then you gain $k\\times v_i$ importance. If you do not finish all $c_i$ items of that homework, then you are not allowed to do any other homework.\n\nA homework $b$ may have multiple prerequisites $a$. However, note that once **one** prerequisite of a homework is done, that homework can be done. But cz is very focused: after finishing one homework, he must do the homework **that uses this homework as a prerequisite**.", "inputFormat": "The input has $N+M+2$ lines.\n\nLine $1$ contains two positive integers $N,T$.\n\nThe next $N$ lines follow. Line $i$ contains three positive integers $v_i,c_i,t_i$.\n\nLine $N+2$ contains one positive integer $1$.\n\nThe next $M$ lines describe the relations, with the same meaning as above.", "outputFormat": "Output one line with one number, the maximum value (importance).", "hint": "### Subtasks\n\nFor $100\\%$ of the testdata, $1<=N<=10000,1<=M<=100000$.\n\nAll other values are within the range of $long long$.\n\n### Source\n\n[MtOI2018 迷途の家の水题大赛](https://www.luogu.org/contest/11260) T1\n\nProblem setter: Doubleen\n\n56432\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[MtOI2018] 刷题？作业狂魔！", "background": "在临听到暑假的尾声以后，神奇的 cz 终于发觉自己的作业不能完成了。\n\n在他写完作业之前，你需要将他做作业的顺序告诉给他听，这样你们就可以一起玩了。", "description": "你拥有 $T$ 分钟的时间。\n\n做作业的顺序可以根据重要度 $v_i$ 来排序，但可能这不是最佳方案。且每项作业可能不止有一项，所以每项作业还有一个数量 $c_i$，每项 $t_i$ 分钟可以完成。\n\n而在做某作业之前可能要先写完某个作业，所以还给出 $M$ 个关系，每个关系包含两个数 $a,b$，代表 $a$ 是 $b$ 完成的前提，不存在 $a=b$ 的情况。\n\n关系不排除环的情况，cz 不想重做一遍作业，只好不做在环上的作业。\n\n当某作业做到一半但时间结束，则失去该作业重要度；当该作业只做了 $k$ 个，但 $k\\leq c_i$，则得到 $k\\times v_i$ 重要度，如果该作业没把 $c_i$ 个做完，则不得做其他作业。\n\n可存在 $b$ 有多个 $a$，但请注意一个作业的 **一个** 前提被做了以后，该作业就可以被做了。但 cz 非常专注，他写完一个作业以后就必须写**以该作业为前提的**作业。", "inputFormat": "输入共 $N+M+2$ 行\n\n第 $1$ 行输入 $2$ 个正整数 $N,T$。\n\n接下来共 $N$ 行输入，第 $i$ 行输入 $3$ 个正整数 $v_i,c_i,t_i$。\n\n第 $N+2$ 行输入 $1$ 个正整数 $1$ 行。\n\n接下来共 $M$ 行输入，意义同上。", "outputFormat": "输出共 $1$ 行 $1$ 个数，表示价值（重要度）最大值。", "hint": "### 子任务\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 10000,1 \\leq M \\leq 100000$\n\n其他值均在 long long 范围内。\n\n\n### 题目来源\n\n[MtOI2018 迷途の家の水题大赛](https://www.luogu.org/contest/11260) T1\n\n出题人：Doubleen\n\n56432", "locale": "zh-CN"}}}
{"pid": "P5478", "type": "P", "difficulty": 6, "samples": [["5  \n1 2  \n1 3  \n2 4  \n2 5  \n4  \n10 1  \n6 1  \n14 5  \n7 3  \n5 3  \n1 2 3  \n1 5 3  \n1 4 4  \n2 1 4  \n1 2 3", "10 7 6  \n14 10 7  \n-1  \n7 6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "线段树", "各省省选", "北京", "O2优化", "树链剖分", "STL"], "title": "[BJOI2015] 骑士的旅行", "background": "在一片古老的土地上，有一个繁荣的文明。\n\n这片大地几乎被森林覆盖，有N座城坐落其中。巧合的是，这N座城由恰好N-1条双向道路连接起来，使得任意两座城都是连通的。也就是说，这些城形成了树的结构，任意两座城之间有且仅有一条简单路径。\n\n在这个文明中，骑士是尤其受到尊崇的职业。任何一名骑士，都是其家族乃至家乡的荣耀。Henry从小就渴望成为一名能守护家乡、驱逐敌人的骑士。勤奋训练许多年后，Henry终于满18岁了。他决定离开家乡，向那些成名已久的骑士们发起挑战！\n", "description": "根据Henry的调查，大陆上一共有 $M$ 名受封骑士，不妨编号为 $1$ 到 $M$。第 $i$ 个骑士居住在城 $P_i$，武力值为 $F_i$。\n\nHenry计划进行若干次旅行，每次从某座城出发沿着唯一的简单路径前往另一座城，同时会挑战路线上武力值最高的 $K$ 个骑士（Henry的体力有限，为了提高水平，当然要挑战最强的骑士）。如果路线上的骑士不足 $K$ 人，Henry会挑战遇到的所有人。\n\n每次旅行前，可能会有某些骑士的武力值或定居地发生变化，Henry自然会打听消息，并对计划做出调整。\n\n为了在每次旅行时做好充分准备，Henry希望你能帮忙在每次旅行前计算出这条路线上他将挑战哪些对手。", "inputFormat": "第一行，一个整数 $N$ ，表示有 $N$ 座城，编号为 $1 \\sim N$。\n\n接下来 $N-1$ 行，每行两个整数 $u_i$ 和 $v_i$，表示城 $u_i$ 和城 $v_i$ 之间有一条道路相连。\n\n第 $N+1$ 行，一个整数 $M$，表示有 $M$ 个骑士。\n\n接下来M行，每行两个整数 $F_i$ 和 $P_i$ 。按顺序依次表示编号为 $1 \\sim M$ 的每名骑士的武力值和居住地。\n\n第 $N+M+2$ 行，两个整数 $Q,~K$，分别表示操作次数和每次旅行挑战的骑士数目上限。\n\n接下来 $Q$ 行，每行三个整数 $T_i,~X_i,~Y_i$ 。$T_i$ 取值范围为 $\\{1,~2,~3\\}$，表示操作类型。\n\n一共有以下三种类型的操作：\n\n$T_i=1$ 时表示一次旅行，Henry将从城 $X_i$ 出发前往城市 $Y_i$；\n\n$T_i=2$ 时表示编号为 $X_i$ 的骑士的居住地搬到城 $Y_i$；\n\n$T_i=3$ 时表示编号为 $X_i$ 的骑士的武力值修正为 $Y_i$。", "outputFormat": "输出若干行，依次为每个旅行的答案。\n\n对每个 $T_i=1$ 的询问，输出一行，按从大到小的顺序输出Henry在这次旅行中挑战的\n\n所有骑士的武力值。如果路线上没有骑士，输出一行，为一个整数 $-1$。", "hint": "100%的数据中，$1 \\leq N,~M \\leq 40,000,~1 \\leq Ui,~Vi,~Pi \\leq N,~1\\leq Q \\leq 80,000,~1 \\leq K \\leq 20$，旅行次数不超过 40,000 次，武力值为不超过1,000的正整数。", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2015] Knight’s Journey", "background": "On an ancient land, there was a prosperous civilization.\n\nThis land was almost covered by forests, and there were $N$ cities scattered within it. By coincidence, these $N$ cities were connected by exactly $N-1$ bidirectional roads, so that any two cities were connected. In other words, these cities form a tree structure, and between any two cities there exists exactly one simple path.\n\nIn this civilization, being a knight was an especially respected profession. Any knight was the pride of their family and hometown. Henry had long dreamed of becoming a knight who could protect his hometown and drive away enemies. After training hard for many years, Henry finally turned 18. He decided to leave his hometown and challenge those famous knights.", "description": "According to Henry’s investigation, there are a total of $M$ titled knights on the continent, numbered from $1$ to $M$. The $i$-th knight lives in city $P_i$ and has combat power $F_i$.\n\nHenry plans to make several journeys. In each journey, he starts from some city and travels along the unique simple path to another city, and he will challenge the strongest $K$ knights (Henry has limited stamina, and to improve himself, of course he challenges the strongest knights). If there are fewer than $K$ knights on the route, Henry will challenge everyone he meets.\n\nBefore each journey, some knights’ combat power or residence may change. Henry will naturally gather information and adjust his plan.\n\nTo be fully prepared for each journey, Henry wants you to help compute which opponents he will challenge on that route before each journey.", "inputFormat": "The first line contains an integer $N$, meaning there are $N$ cities, numbered from $1$ to $N$.\n\nThe next $N-1$ lines each contain two integers $u_i$ and $v_i$, indicating that there is a road between city $u_i$ and city $v_i$.\n\nLine $N+1$ contains an integer $M$, meaning there are $M$ knights.\n\nThe next $M$ lines each contain two integers $F_i$ and $P_i$, describing in order the combat power and residence of each knight numbered from $1$ to $M$.\n\nLine $N+M+2$ contains two integers $Q$ and $K$, meaning the number of operations and the maximum number of knights challenged in each journey.\n\nThe next $Q$ lines each contain three integers $T_i$, $X_i$, and $Y_i$. $T_i \\in \\{1,~2,~3\\}$ indicates the operation type.\n\nThere are three types of operations:\n\nWhen $T_i=1$, it means a journey: Henry will travel from city $X_i$ to city $Y_i$.\n\nWhen $T_i=2$, it means the residence of knight $X_i$ is moved to city $Y_i$.\n\nWhen $T_i=3$, it means the combat power of knight $X_i$ is changed to $Y_i$.", "outputFormat": "Output several lines, in order, as the answers for each journey.\n\nFor each query with $T_i=1$, output one line listing, in decreasing order, the combat power values of all knights Henry challenges in this journey. If there are no knights on the route, output one line containing the integer $-1$.", "hint": "Constraints: for $100\\%$ of the testdata, $1 \\leq N,~M \\leq 40,000$, $1 \\leq Ui,~Vi,~Pi \\leq N$, $1 \\leq Q \\leq 80,000$, $1 \\leq K \\leq 20$. The number of journeys does not exceed 40,000. Combat power values are positive integers not exceeding 1,000.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2015] 骑士的旅行", "background": "在一片古老的土地上，有一个繁荣的文明。\n\n这片大地几乎被森林覆盖，有N座城坐落其中。巧合的是，这N座城由恰好N-1条双向道路连接起来，使得任意两座城都是连通的。也就是说，这些城形成了树的结构，任意两座城之间有且仅有一条简单路径。\n\n在这个文明中，骑士是尤其受到尊崇的职业。任何一名骑士，都是其家族乃至家乡的荣耀。Henry从小就渴望成为一名能守护家乡、驱逐敌人的骑士。勤奋训练许多年后，Henry终于满18岁了。他决定离开家乡，向那些成名已久的骑士们发起挑战！\n", "description": "根据Henry的调查，大陆上一共有 $M$ 名受封骑士，不妨编号为 $1$ 到 $M$。第 $i$ 个骑士居住在城 $P_i$，武力值为 $F_i$。\n\nHenry计划进行若干次旅行，每次从某座城出发沿着唯一的简单路径前往另一座城，同时会挑战路线上武力值最高的 $K$ 个骑士（Henry的体力有限，为了提高水平，当然要挑战最强的骑士）。如果路线上的骑士不足 $K$ 人，Henry会挑战遇到的所有人。\n\n每次旅行前，可能会有某些骑士的武力值或定居地发生变化，Henry自然会打听消息，并对计划做出调整。\n\n为了在每次旅行时做好充分准备，Henry希望你能帮忙在每次旅行前计算出这条路线上他将挑战哪些对手。", "inputFormat": "第一行，一个整数 $N$ ，表示有 $N$ 座城，编号为 $1 \\sim N$。\n\n接下来 $N-1$ 行，每行两个整数 $u_i$ 和 $v_i$，表示城 $u_i$ 和城 $v_i$ 之间有一条道路相连。\n\n第 $N+1$ 行，一个整数 $M$，表示有 $M$ 个骑士。\n\n接下来M行，每行两个整数 $F_i$ 和 $P_i$ 。按顺序依次表示编号为 $1 \\sim M$ 的每名骑士的武力值和居住地。\n\n第 $N+M+2$ 行，两个整数 $Q,~K$，分别表示操作次数和每次旅行挑战的骑士数目上限。\n\n接下来 $Q$ 行，每行三个整数 $T_i,~X_i,~Y_i$ 。$T_i$ 取值范围为 $\\{1,~2,~3\\}$，表示操作类型。\n\n一共有以下三种类型的操作：\n\n$T_i=1$ 时表示一次旅行，Henry将从城 $X_i$ 出发前往城市 $Y_i$；\n\n$T_i=2$ 时表示编号为 $X_i$ 的骑士的居住地搬到城 $Y_i$；\n\n$T_i=3$ 时表示编号为 $X_i$ 的骑士的武力值修正为 $Y_i$。", "outputFormat": "输出若干行，依次为每个旅行的答案。\n\n对每个 $T_i=1$ 的询问，输出一行，按从大到小的顺序输出Henry在这次旅行中挑战的\n\n所有骑士的武力值。如果路线上没有骑士，输出一行，为一个整数 $-1$。", "hint": "100%的数据中，$1 \\leq N,~M \\leq 40,000,~1 \\leq Ui,~Vi,~Pi \\leq N,~1\\leq Q \\leq 80,000,~1 \\leq K \\leq 20$，旅行次数不超过 40,000 次，武力值为不超过1,000的正整数。", "locale": "zh-CN"}}}
{"pid": "P5479", "type": "P", "difficulty": 6, "samples": [["1\nAAA\nAABBAAB", "5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "2015", "各省省选", "北京", "哈希 hashing", "后缀数组 SA"], "title": "[BJOI2015] 隐身术", "background": null, "description": "给定两个串 $A$、$B$。请问 $B$ 中有多少个非空子串和 $A$ 的编辑距离不超过 $K$？\n\n所谓“子串”，指的是 $B$ 中连续的一段。不同位置的内容相同的子串算作多个。两个串之间的“编辑距离”指的是把一个串变成另一个串需要的最小的操作次数，每次操作可以插入、删除或者替换一个字符。", "inputFormat": "第一行一个非负整数 $K$。接下来两行，每行一个由大写字母组成的字符\n串，分别表示 $A$ 和 $B$。", "outputFormat": "输出一行一个整数，表示所求答案。", "hint": "对 $100\\%$ 的数据，$K\\leq5$，两个字符串均非空，长度和小于 $10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2015] Invisibility", "background": "", "description": "Given two strings $A$ and $B$. How many non-empty substrings of $B$ have an edit distance to $A$ that is at most $K$?\n\nA “substring” means a consecutive segment of $B$. Substrings with the same content but different positions are counted multiple times. The “edit distance” between two strings is the minimum number of operations needed to change one string into the other. Each operation can insert, delete, or replace one character.", "inputFormat": "The first line contains a non-negative integer $K$. The next two lines each contain a string of uppercase letters, representing $A$ and $B$ respectively.", "outputFormat": "Output one line containing an integer, which is the required answer.", "hint": "For $100\\%$ of the data, $K\\leq5$, both strings are non-empty, and the sum of their lengths is less than $10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2015] 隐身术", "background": null, "description": "给定两个串 $A$、$B$。请问 $B$ 中有多少个非空子串和 $A$ 的编辑距离不超过 $K$？\n\n所谓“子串”，指的是 $B$ 中连续的一段。不同位置的内容相同的子串算作多个。两个串之间的“编辑距离”指的是把一个串变成另一个串需要的最小的操作次数，每次操作可以插入、删除或者替换一个字符。", "inputFormat": "第一行一个非负整数 $K$。接下来两行，每行一个由大写字母组成的字符\n串，分别表示 $A$ 和 $B$。", "outputFormat": "输出一行一个整数，表示所求答案。", "hint": "对 $100\\%$ 的数据，$K\\leq5$，两个字符串均非空，长度和小于 $10^5$。", "locale": "zh-CN"}}}
{"pid": "P5480", "type": "P", "difficulty": 0, "samples": [["3 3 1\n1 2 1\n2 3 1\n1 3 2", "2 3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "各省省选", "北京", "Special Judge", "O2优化"], "title": "[BJOI2015] 回家的路【征集spj】", "background": "", "description": "小强和阿米巴是好朋友。连接北京和小强的家乡的是错综复杂的铁路网。一共有$~N~$个站点，站点之间有长短不一的双向的铁路。小强每次回家的时候，会从所有的最短路中随机选择一条。阿米巴门前有一条铁路。他想在不改变北京到小强的家乡的最短路的距离的前提下，给这个铁路网再添一条长度为$~K~$的单向铁路，使得小强路过阿米巴家门口的那条铁路的概率最大。请输出这个最大概率。", "inputFormat": "第一行是三个正整数$~N,M~$和$~K~$，表示站点的数量，铁路线的数量和新开的铁路线的长度。站点从$~1~$编号到$~N~$。北京是$~1~$号点，小强的家乡是$~N~$号。接下来$~M~$行，每行三个正整数$~u,v,s~$表示有一条连接站点$~u~$和$~v~$的铁路线长度是$~s~$。\n\n这$~M~$行中的第一行描述的是阿米巴家门口的铁路。两个点之间可能有多条铁路。也有可能$~u=v~$，即，有自环。你新修建的铁路也可以和已有线路重合，也可以是自环。$~1~$和$~N~$之间一定是连通的。\n\n$~3\\leq N\\leq 100000,M\\leq 400000,1\\leq s,K≤10000~$，保证无论如何加边图中任两点之间的最短路的数量都不超过$2^{16000}~$。", "outputFormat": "输出一行两个正整数$~A,B~$，表示从$~A~$向$~B~$修建一条单向铁路。你的修建方案得出的小强路过的概率和标准答案之间的差距不超过$10^{-6}$即可算对。\n\n//注意：本题因缺少$spj$，请谨慎提交。", "hint": "添加边之后，一共有$~3~$条最短路，小强会路过阿米巴门前的概率由$~1/2~$变为$~2/3~$.", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2015] The Road Home [SPJ Wanted]", "background": "", "description": "Xiaoqiang and Amoeba are good friends. Connecting Beijing and Xiaoqiang's hometown is a complicated railway network. There are $~N~$ stations in total, and between stations there are undirected railways of different lengths. Each time Xiaoqiang goes home, he randomly chooses one path among all shortest paths.\n\nThere is a railway in front of Amoeba's house. Without changing the shortest-path distance from Beijing to Xiaoqiang's hometown, Amoeba wants to add one directed railway of length $~K~$ to the network, so that the probability that Xiaoqiang passes through the railway in front of Amoeba's house is as large as possible. Please output this maximum probability.\n\n## Constraints\n\n$~3\\leq N\\leq 100000,M\\leq 400000,1\\leq s,K≤10000~$. It is guaranteed that no matter how you add the edge, the number of shortest paths between any two nodes in the graph will not exceed $2^{16000}~$.", "inputFormat": "The first line contains three positive integers $~N,M~$ and $~K~$, representing the number of stations, the number of railways, and the length of the new railway. Stations are numbered from $~1~$ to $~N~$. Beijing is node $~1~$, and Xiaoqiang's hometown is node $~N~$.\n\nThe next $~M~$ lines each contain three positive integers $~u,v,s~$, indicating an undirected railway connecting stations $~u~$ and $~v~$ with length $~s~$.\n\nThe first of these $~M~$ lines describes the railway in front of Amoeba's house. There may be multiple railways between the same pair of nodes. It is also possible that $~u=v~$, i.e., a self-loop. The new railway you build may overlap an existing railway, and it may also be a self-loop. Nodes $~1~$ and $~N~$ are guaranteed to be connected.", "outputFormat": "Output one line with two positive integers $~A,B~$, meaning that you build a directed railway from $~A~$ to $~B~$. Your construction is accepted if the difference between the probability that Xiaoqiang passes through the target railway under your plan and the standard answer is at most $10^{-6}$.\n\n// Note: This problem lacks an $spj$, so please submit with caution.", "hint": "After adding an edge, there are $~3~$ shortest paths in total. The probability that Xiaoqiang passes in front of Amoeba's house changes from $~1/2~$ to $~2/3~$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2015] 回家的路【征集spj】", "background": "", "description": "小强和阿米巴是好朋友。连接北京和小强的家乡的是错综复杂的铁路网。一共有$~N~$个站点，站点之间有长短不一的双向的铁路。小强每次回家的时候，会从所有的最短路中随机选择一条。阿米巴门前有一条铁路。他想在不改变北京到小强的家乡的最短路的距离的前提下，给这个铁路网再添一条长度为$~K~$的单向铁路，使得小强路过阿米巴家门口的那条铁路的概率最大。请输出这个最大概率。", "inputFormat": "第一行是三个正整数$~N,M~$和$~K~$，表示站点的数量，铁路线的数量和新开的铁路线的长度。站点从$~1~$编号到$~N~$。北京是$~1~$号点，小强的家乡是$~N~$号。接下来$~M~$行，每行三个正整数$~u,v,s~$表示有一条连接站点$~u~$和$~v~$的铁路线长度是$~s~$。\n\n这$~M~$行中的第一行描述的是阿米巴家门口的铁路。两个点之间可能有多条铁路。也有可能$~u=v~$，即，有自环。你新修建的铁路也可以和已有线路重合，也可以是自环。$~1~$和$~N~$之间一定是连通的。\n\n$~3\\leq N\\leq 100000,M\\leq 400000,1\\leq s,K≤10000~$，保证无论如何加边图中任两点之间的最短路的数量都不超过$2^{16000}~$。", "outputFormat": "输出一行两个正整数$~A,B~$，表示从$~A~$向$~B~$修建一条单向铁路。你的修建方案得出的小强路过的概率和标准答案之间的差距不超过$10^{-6}$即可算对。\n\n//注意：本题因缺少$spj$，请谨慎提交。", "hint": "添加边之后，一共有$~3~$条最短路，小强会路过阿米巴门前的概率由$~1/2~$变为$~2/3~$.", "locale": "zh-CN"}}}
{"pid": "P5481", "type": "P", "difficulty": 6, "samples": [["1 3 3 10", "0"], ["2 2 2 10", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "各省省选", "北京", "O2优化", "组合数学"], "title": "[BJOI2015] 糖果", "background": "Alice 正在教她的弟弟 Bob 学数学。 ", "description": "每天，Alice 画一个 $n$ 行 $m$ 列的表格，要求 Bob 在格子里填数。 \n\nBob已经学会了自然数 $1$ 到 $k$ 的写法。因此他在每个格子里填 $1 \\sim k$ 之间的整数。 \n\nAlice 告诉 Bob，如果 Bob 填写完表格的 $n \\times m$ 个数以后，每行的数从第 $1$ 列到第 $m$ 列单调不减，并且任意两行至少有一列的数不同，而且以前 Bob 没有填写过相同的表格，那么 Alice 就给 Bob 吃一颗糖果。 \n\nBob想知道，如果每天填写一遍表格，最多能吃到多少颗糖果。 \n\n答案对 $p$ 取模。\n", "inputFormat": "输入只有一行四个整数，分别代表 $n, m, k, p$。", "outputFormat": "输出一行，一个整数，表示答案模 $p$ 后的结果。 ", "hint": "#### 样例输入输出 1 解释\n\n共有 $10$ 种方案，取模后为 $0$。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n, m \\leq 10^5$，$1 \\leq k,p \\leq 2 \\times 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2015] Candy", "background": "Alice is teaching her younger brother Bob math.", "description": "Every day, Alice draws a table with $n$ rows and $m$ columns and asks Bob to fill in numbers in the cells.\n\nBob has learned how to write the natural numbers from $1$ to $k$. Therefore, in each cell he writes an integer between $1 \\sim k$.\n\nAlice tells Bob that if, after Bob fills in all $n \\times m$ numbers, the numbers in each row are non-decreasing from column $1$ to column $m$, and for any two rows there is at least one column where the numbers are different, and Bob has never filled in an identical table before, then Alice will give Bob a piece of candy.\n\nBob wants to know: if he fills in the table once per day, what is the maximum number of candies he can get.\n\nThe answer is taken modulo $p$.", "inputFormat": "The input contains only one line with four integers, representing $n, m, k, p$.", "outputFormat": "Output one line with one integer, representing the answer modulo $p$.", "hint": "#### Explanation of Sample Input/Output 1\n\nThere are $10$ valid schemes in total, and after taking modulo, it becomes $0$.\n\n---\n\n#### Constraints\n\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\leq n, m \\leq 10^5$, and $1 \\leq k, p \\leq 2 \\times 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2015] 糖果", "background": "Alice 正在教她的弟弟 Bob 学数学。 ", "description": "每天，Alice 画一个 $n$ 行 $m$ 列的表格，要求 Bob 在格子里填数。 \n\nBob已经学会了自然数 $1$ 到 $k$ 的写法。因此他在每个格子里填 $1 \\sim k$ 之间的整数。 \n\nAlice 告诉 Bob，如果 Bob 填写完表格的 $n \\times m$ 个数以后，每行的数从第 $1$ 列到第 $m$ 列单调不减，并且任意两行至少有一列的数不同，而且以前 Bob 没有填写过相同的表格，那么 Alice 就给 Bob 吃一颗糖果。 \n\nBob想知道，如果每天填写一遍表格，最多能吃到多少颗糖果。 \n\n答案对 $p$ 取模。\n", "inputFormat": "输入只有一行四个整数，分别代表 $n, m, k, p$。", "outputFormat": "输出一行，一个整数，表示答案模 $p$ 后的结果。 ", "hint": "#### 样例输入输出 1 解释\n\n共有 $10$ 种方案，取模后为 $0$。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n, m \\leq 10^5$，$1 \\leq k,p \\leq 2 \\times 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5482", "type": "P", "difficulty": 5, "samples": [["9\nAdd 1 1 1\nAdd -2 4 3\nQuery 0\nDel 1\nQuery 0\nDel 2\nQuery 0\nAdd 8 9 100\nQuery 10", "1\n1\n0\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "各省省选", "平衡树", "树状数组", "吉林"], "title": "[JLOI2011] 不等式组", "background": "", "description": "旺汪与旺喵最近在做一些不等式的练习。这些不等式都是形如 $ax+b>c$ 的一元不等式。当然，解这些不等式对旺汪来说太简单了，所以旺喵想挑战旺汪。旺喵给出一组一元不等式，并给出一个数值。旺汪需要回答的是 $x=k$ 时成立的不等式的数量。聪明的旺汪每次都很快就给出了答案。你的任务是快速的验证旺汪的答案是不是正确的。", "inputFormat": "输入第一行为一个正整数 $n$，代表接下来有 $n$ 行。\n\n接下来每一行可能有 $3$ 种形式：\n\n1. `Add a b c`：表明要往不等式组添加一条不等式 $ax+b>c$。\n2. `Del i`：代表删除第 $i$ 条添加的不等式（最先添加的是第 $1$ 条）。\n3. `Query k`：代表一个询问，即当 $x=k$ 时，在当前不等式组内成立的不等式的数量。\n\n注意：一开始不等式组为空，$a,b,c,i,k$ 均为整数，且保证所有操作均合法，不会出现要求删除尚未添加的不等式的情况，但可能重复删除同一条不等式。", "outputFormat": "对于每一个询问 `Query k`，输出一行一个整数，代表询问的答案。", "hint": "#### 样例 1 说明\n\n第 $1$ 条添加到不等式组的不等式为 $x+1>1$，第 $2$ 条为 $−2x+4>3$。所以第 $1$ 个询问的时候只有第 $2$ 条不等式可以成立，故输出 `1`。\n\n然后删除第 $1$ 条不等式，再询问的时候依然是只有第 $2$ 条不等式可以成立，故输出 $1$ 。\n\n再删除第 $2$ 条不等式后，因为不等式组里面没有不等式了，所以没有不等式可以被满足，故输出 $0$。\n\n继续加入第 $3$ 条不等式 $8x+9>100$，当 $x=k=10$ 时有 $8\\times 10+9=89<100$，故也没有不等式可以被满足，依然输出 $0$。\n\n#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，保证 $n\\leq 10^3$。\n- 对于 $40\\%$ 的数据，保证 $n\\leq 10^4$。\n- 对于 $100\\%$ 的数据，保证 $1\\leq n\\leq 10^5$，$a,b,c\\in[-10^8,10^8]$，$k\\in[-10^6,10^6]$。", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2011] System of Inequalities", "background": "", "description": "Wangwang and Wangmiao have recently been practicing some inequalities. These inequalities are all one-variable inequalities of the form $ax+b>c$. Of course, solving such inequalities is too easy for Wangwang, so Wangmiao wants to challenge him.\n\nWangmiao gives a set of one-variable inequalities and a value. Wangwang needs to answer: when $x=k$, how many inequalities in the set are satisfied. Clever Wangwang can give the answer quickly every time. Your task is to quickly verify whether Wangwang's answers are correct.", "inputFormat": "The first line contains a positive integer $n$, indicating that there will be $n$ lines following.\n\nEach of the next lines can be in one of the following $3$ forms:\n\n1. `Add a b c`: Add an inequality $ax+b>c$ to the system.\n2. `Del i`: Delete the $i$-th added inequality (the first added one is $1$).\n3. `Query k`: A query asking, when $x=k$, how many inequalities in the current system are satisfied.\n\nNote: Initially, the system is empty. $a,b,c,i,k$ are all integers. All operations are guaranteed to be valid: there will be no request to delete an inequality that has not been added, but the same inequality may be deleted repeatedly.", "outputFormat": "For each query `Query k`, output one line with one integer, which is the answer to the query.", "hint": "#### Explanation of Sample 1\n\nThe first inequality added to the system is $x+1>1$, and the second is $-2x+4>3$. Therefore, in the first query, only the second inequality can be satisfied, so output `1`.\n\nThen delete the first inequality. In the next query, still only the second inequality can be satisfied, so output $1$.\n\nAfter deleting the second inequality, since the system contains no inequalities, none can be satisfied, so output $0$.\n\nContinue by adding the third inequality $8x+9>100$. When $x=k=10$, we have $8\\times 10+9=89<100$, so no inequality can be satisfied, and the output is still $0$.\n\n#### Constraints\n\n- For $20\\%$ of the data, $n\\leq 10^3$.\n- For $40\\%$ of the data, $n\\leq 10^4$.\n- For $100\\%$ of the data, $1\\leq n\\leq 10^5$, $a,b,c\\in[-10^8,10^8]$, $k\\in[-10^6,10^6]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2011] 不等式组", "background": "", "description": "旺汪与旺喵最近在做一些不等式的练习。这些不等式都是形如 $ax+b>c$ 的一元不等式。当然，解这些不等式对旺汪来说太简单了，所以旺喵想挑战旺汪。旺喵给出一组一元不等式，并给出一个数值。旺汪需要回答的是 $x=k$ 时成立的不等式的数量。聪明的旺汪每次都很快就给出了答案。你的任务是快速的验证旺汪的答案是不是正确的。", "inputFormat": "输入第一行为一个正整数 $n$，代表接下来有 $n$ 行。\n\n接下来每一行可能有 $3$ 种形式：\n\n1. `Add a b c`：表明要往不等式组添加一条不等式 $ax+b>c$。\n2. `Del i`：代表删除第 $i$ 条添加的不等式（最先添加的是第 $1$ 条）。\n3. `Query k`：代表一个询问，即当 $x=k$ 时，在当前不等式组内成立的不等式的数量。\n\n注意：一开始不等式组为空，$a,b,c,i,k$ 均为整数，且保证所有操作均合法，不会出现要求删除尚未添加的不等式的情况，但可能重复删除同一条不等式。", "outputFormat": "对于每一个询问 `Query k`，输出一行一个整数，代表询问的答案。", "hint": "#### 样例 1 说明\n\n第 $1$ 条添加到不等式组的不等式为 $x+1>1$，第 $2$ 条为 $−2x+4>3$。所以第 $1$ 个询问的时候只有第 $2$ 条不等式可以成立，故输出 `1`。\n\n然后删除第 $1$ 条不等式，再询问的时候依然是只有第 $2$ 条不等式可以成立，故输出 $1$ 。\n\n再删除第 $2$ 条不等式后，因为不等式组里面没有不等式了，所以没有不等式可以被满足，故输出 $0$。\n\n继续加入第 $3$ 条不等式 $8x+9>100$，当 $x=k=10$ 时有 $8\\times 10+9=89<100$，故也没有不等式可以被满足，依然输出 $0$。\n\n#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，保证 $n\\leq 10^3$。\n- 对于 $40\\%$ 的数据，保证 $n\\leq 10^4$。\n- 对于 $100\\%$ 的数据，保证 $1\\leq n\\leq 10^5$，$a,b,c\\in[-10^8,10^8]$，$k\\in[-10^6,10^6]$。", "locale": "zh-CN"}}}
{"pid": "P5483", "type": "P", "difficulty": 3, "samples": [["2\n2 a\na1,b1,c1\na2,b2\n4 b\na1,b1,c1,d1\na2,b2\na3,b3,c3\na4", "a,,,b,,,\na1,b1,c1,a1,b1,c1,d1\na2,b2,,a2,b2,,\n,,,a3,b3,c3,\n,,,a4,,,"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2011", "各省省选", "吉林"], "title": "[JLOI2011] 小A的烦恼", "background": "", "description": "小$A$是$B$公司的一名$PM(product market)$。$B$公司越来越注重产品使用情况分析，而小$A$的工作就是整天对着一堆数据分析来分析去，没完没了。其中有一个操作是小$A$很头疼的，就是要把多个$csv$文件的数据拷到同一个$excel$文件中去。\n有一天小$A$满怀期待地找到了你，一个高级程序员，她想让你写程序帮她完成这个简单重复性工作。这不是坑爹吗，直接操作$excel$还要用到第三方的库，还不如直接写到$csv$文件中，让她再手动去转成$excel$文件。经过内部沟通协调，最终定下了这个方案。\n$csv$是一种$excel$可支持和格式，且存储方式非常简单。它实际上就是用“`,`”来分隔相邻的两个列。比如以下三行数据：  \n```\na,a,a\nb,,b\n,c,c\n```\n表示的就是：  \n\n| a | a | a |\n| ---------- | :----------: | :----------: |\n| b |   | b |\n|   | c | c |\n\n现在小$A$想做的就是把各个文件按照从左往右的顺序拷到同一个文件当中。比如文件$a$的数据是：  \n```\na1,b1,c1\na2,b2\n```\n文件$b$的数据是：  \n```\na1,b1,c1,d1\na2,b2\na3,b3,c3\na4\n```\n那么她所希望的最终结果是：  \n\n| a |  |  | b |  |  |  |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| a1 | b1 | c1 | a1 | b1 | c1 | d1 |\n| a2 | b2 |  | a2 | b2 |  |  |\n|  |  |  | a3 | b3 | c3 |  |\n|  |  |  | a4 |  |  |  |\n\n这个结果在$csv$文件里就是：  \n```\na,,,b,,,\na1,b1,c1,a1,b1,c1,d1\na2,b2,,a2,b2,,\n,,,a3,b3,c3,\n,,,a4,,,\n```\n以上结果的第一行是每一个文件的文件名，文件名与相应文件的第一列对齐。如果相应文件不止一列，那么其它列用空的单元格来补充。  \n输入的$csv$文件里保证了每一行的末尾都没有“`,`”，也就是说像$a$文件的第$2$行的第$3$列一样，如那一格是空的，那么在$b2$后面是没有“`,`”的。  \n输出的$csv$文件里因为是程序的输出结果，为了简化程序，如果末尾是空的，那么还是会显式输出“`,`”，如以上的结果所示。  \n输入文件保证至少有一行一列非空。  \n输出的文件要保证下一个文件的第一列要紧邻着上一文件的最后一个非空列的右面。最后一个文件只输出到最后一个非空列。   ", "inputFormat": "第一行有一个整数$N$（$1\\leq N\\leq 100$），表示有$N$个文件。  \n以下$N$个数据块的第一行有一个整数$M$ ($1\\leq M\\leq 100$)和一个字符串$S$ ($1\\leq length(S)\\leq 100$)，M表示文件的行数，$S$表示文件名。  \n$N$个数据块的下面$M$行中，每一行是一个字符串$T$($1\\leq length(T)\\leq 100$)，$T$只包含小写字母、数字和“`,`”。  ", "outputFormat": "输出把$N$个文件的数据合到一个文件的结果。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2011] Little A's Trouble", "background": "", "description": "Little $A$ is a PM (product market) at company $B$. Company $B$ is paying more and more attention to analyzing product usage, and Little $A$'s job is to stare at piles of data all day and analyze them over and over again, endlessly. One operation that gives Little $A$ a big headache is copying data from multiple $csv$ files into the same $excel$ file.\n\nOne day, Little $A$ came to you with great expectations. As a senior programmer, she wants you to write a program to help her complete this simple, repetitive task. But that is troublesome: directly operating on $excel$ requires third-party libraries. It is better to write directly into a $csv$ file and let her manually convert it into an $excel$ file later. After internal communication and coordination, this plan was finally chosen.\n\n$csv$ is a format supported by $excel$, and its storage is very simple. It uses “,” to separate two adjacent columns. For example, the following three lines of data:\n```\na,a,a\nb,,b\n,c,c\n```\nrepresent:\n\n| a | a | a |\n| ---------- | :----------: | :----------: |\n| b |   | b |\n|   | c | c |\n\nNow, what Little $A$ wants to do is to copy each file into the same file from left to right. For example, file $a$ contains:\n```\na1,b1,c1\na2,b2\n```\nand file $b$ contains:\n```\na1,b1,c1,d1\na2,b2\na3,b3,c3\na4\n```\nThen the final result she wants is:\n\n| a |  |  | b |  |  |  |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| a1 | b1 | c1 | a1 | b1 | c1 | d1 |\n| a2 | b2 |  | a2 | b2 |  |  |\n|  |  |  | a3 | b3 | c3 |  |\n|  |  |  | a4 |  |  |  |\n\nIn a $csv$ file, this result is:\n```\na,,,b,,,\na1,b1,c1,a1,b1,c1,d1\na2,b2,,a2,b2,,\n,,,a3,b3,c3,\n,,,a4,,,\n```\nThe first line of the result above is the file name of each file. Each file name is aligned with the first column of its corresponding file. If the corresponding file has more than one column, the other columns are filled with empty cells.\n\nThe input $csv$ files guarantee that there is no “,” at the end of any line. That is, like the third column in the second line of file $a$: if that cell is empty, then there is no “,” after `b2`.\n\nSince the output $csv$ file is produced by a program, to simplify the program, if the end is empty, it will still explicitly output “,”, as shown in the result above.\n\nThe input guarantees that there is at least one non-empty row and one non-empty column.\n\nIn the output file, the first column of the next file must be immediately to the right of the last non-empty column of the previous file. The last file should only be output up to its last non-empty column.", "inputFormat": "The first line contains an integer $N$ ($1 \\leq N \\leq 100$), meaning there are $N$ files.\n\nFor each of the following $N$ data blocks, the first line contains an integer $M$ ($1 \\leq M \\leq 100$) and a string $S$ ($1 \\leq length(S) \\leq 100$). $M$ is the number of rows in the file, and $S$ is the file name.\n\nIn each data block, the next $M$ lines each contain a string $T$ ($1 \\leq length(T) \\leq 100$). $T$ only contains lowercase letters, digits, and “,”.", "outputFormat": "Output the result of merging the data from the $N$ files into one file.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2011] 小A的烦恼", "background": "", "description": "小$A$是$B$公司的一名$PM(product market)$。$B$公司越来越注重产品使用情况分析，而小$A$的工作就是整天对着一堆数据分析来分析去，没完没了。其中有一个操作是小$A$很头疼的，就是要把多个$csv$文件的数据拷到同一个$excel$文件中去。\n有一天小$A$满怀期待地找到了你，一个高级程序员，她想让你写程序帮她完成这个简单重复性工作。这不是坑爹吗，直接操作$excel$还要用到第三方的库，还不如直接写到$csv$文件中，让她再手动去转成$excel$文件。经过内部沟通协调，最终定下了这个方案。\n$csv$是一种$excel$可支持和格式，且存储方式非常简单。它实际上就是用“`,`”来分隔相邻的两个列。比如以下三行数据：  \n```\na,a,a\nb,,b\n,c,c\n```\n表示的就是：  \n\n| a | a | a |\n| ---------- | :----------: | :----------: |\n| b |   | b |\n|   | c | c |\n\n现在小$A$想做的就是把各个文件按照从左往右的顺序拷到同一个文件当中。比如文件$a$的数据是：  \n```\na1,b1,c1\na2,b2\n```\n文件$b$的数据是：  \n```\na1,b1,c1,d1\na2,b2\na3,b3,c3\na4\n```\n那么她所希望的最终结果是：  \n\n| a |  |  | b |  |  |  |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| a1 | b1 | c1 | a1 | b1 | c1 | d1 |\n| a2 | b2 |  | a2 | b2 |  |  |\n|  |  |  | a3 | b3 | c3 |  |\n|  |  |  | a4 |  |  |  |\n\n这个结果在$csv$文件里就是：  \n```\na,,,b,,,\na1,b1,c1,a1,b1,c1,d1\na2,b2,,a2,b2,,\n,,,a3,b3,c3,\n,,,a4,,,\n```\n以上结果的第一行是每一个文件的文件名，文件名与相应文件的第一列对齐。如果相应文件不止一列，那么其它列用空的单元格来补充。  \n输入的$csv$文件里保证了每一行的末尾都没有“`,`”，也就是说像$a$文件的第$2$行的第$3$列一样，如那一格是空的，那么在$b2$后面是没有“`,`”的。  \n输出的$csv$文件里因为是程序的输出结果，为了简化程序，如果末尾是空的，那么还是会显式输出“`,`”，如以上的结果所示。  \n输入文件保证至少有一行一列非空。  \n输出的文件要保证下一个文件的第一列要紧邻着上一文件的最后一个非空列的右面。最后一个文件只输出到最后一个非空列。   ", "inputFormat": "第一行有一个整数$N$（$1\\leq N\\leq 100$），表示有$N$个文件。  \n以下$N$个数据块的第一行有一个整数$M$ ($1\\leq M\\leq 100$)和一个字符串$S$ ($1\\leq length(S)\\leq 100$)，M表示文件的行数，$S$表示文件名。  \n$N$个数据块的下面$M$行中，每一行是一个字符串$T$($1\\leq length(T)\\leq 100$)，$T$只包含小写字母、数字和“`,`”。  ", "outputFormat": "输出把$N$个文件的数据合到一个文件的结果。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5484", "type": "P", "difficulty": 5, "samples": [["10 3\nCTAGTAGAAG\nTCC", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "高精度", "2011", "各省省选", "吉林"], "title": "[JLOI2011] 基因补全", "background": "", "description": "在生物课中我们学过，碱基组成了$DNA$（脱氧核糖核酸），他们分别可以用大写字母$A,C,T,G$表示，其中$A$总与$T$配对，$C$总与$G$配对。两个碱基序列能相互匹配，当且仅当它们等长，并且任意相同位置的碱基都是能相互配对的。例如$ACGTC$能且仅能与$TGCAG$配对。一个相对短的碱基序列能通过往该序列中任意位置补足碱基来与一个相对长的碱基序列配对。补全碱基的位置、数量不同，都将视为不同的补全方案。现在有两串碱基序列$S$和$T$，分别有$n$和$m$个碱基($n\\geq m$)，问一共有多少种补全方案。", "inputFormat": "数据包括三行。\n第一行有两个整数$n$，$m$，表示碱基序列的长度。\n第二行包含$n$个字符，表示碱基序列$S$。\n第三行包含$m$个字符，表示碱基序列$T$。\n两个碱基序列的字符种类只有$A,C,G,T$这$4$个大写字母。", "outputFormat": "答案只包含一行，表示补全方案的个数。", "hint": "样例解释：  \n$TCC$的$4$种补全方案（括号中字符为补全的碱基）  \n$(GA)TC(AT)C(TTC)$  \n$(GA)TC(ATCTT)C$  \n$(GA)T(CAT)C(TT)C$  \n$(GATCA)TC(TT)C$  \n\n数据范围：  \n对于$30\\% $数据，$n\\leq 1000,m\\leq 2$  \n对于$50\\% $数据，$n\\leq 1000,m\\leq 4$  \n对于$100\\% $数据，$n\\leq 2000,m\\leq n$  ", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2011] Gene Completion", "background": "", "description": "In biology class, we learned that bases make up $DNA$ (deoxyribonucleic acid). They can be represented by the uppercase letters $A, C, T, G$, where $A$ always pairs with $T$, and $C$ always pairs with $G$. Two base sequences can match each other if and only if they have the same length, and at every position, the two bases can pair with each other. For example, $ACGTC$ can and only can pair with $TGCAG$.\n\nA relatively shorter base sequence can be made to pair with a relatively longer base sequence by inserting bases at any positions in the shorter sequence. Different insertion positions or different numbers of inserted bases are considered different completion plans.\n\nNow you are given two base sequences $S$ and $T$, with lengths $n$ and $m$ respectively ($n \\geq m$). Find how many completion plans there are in total.", "inputFormat": "The input has three lines.  \nThe first line contains two integers $n$ and $m$, representing the lengths of the base sequences.  \nThe second line contains $n$ characters, representing the base sequence $S$.  \nThe third line contains $m$ characters, representing the base sequence $T$.  \nThe characters in both sequences are only the $4$ uppercase letters $A, C, G, T$.", "outputFormat": "Output one line containing the number of completion plans.", "hint": "Sample explanation:  \nThe $4$ completion plans for $TCC$ (characters in parentheses are the inserted bases):  \n$(GA)TC(AT)C(TTC)$  \n$(GA)TC(ATCTT)C$  \n$(GA)T(CAT)C(TT)C$  \n$(GATCA)TC(TT)C$  \n\nConstraints:  \nFor $30\\%$ of the testdata, $n \\leq 1000, m \\leq 2$.  \nFor $50\\%$ of the testdata, $n \\leq 1000, m \\leq 4$.  \nFor $100\\%$ of the testdata, $n \\leq 2000, m \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2011] 基因补全", "background": "", "description": "在生物课中我们学过，碱基组成了$DNA$（脱氧核糖核酸），他们分别可以用大写字母$A,C,T,G$表示，其中$A$总与$T$配对，$C$总与$G$配对。两个碱基序列能相互匹配，当且仅当它们等长，并且任意相同位置的碱基都是能相互配对的。例如$ACGTC$能且仅能与$TGCAG$配对。一个相对短的碱基序列能通过往该序列中任意位置补足碱基来与一个相对长的碱基序列配对。补全碱基的位置、数量不同，都将视为不同的补全方案。现在有两串碱基序列$S$和$T$，分别有$n$和$m$个碱基($n\\geq m$)，问一共有多少种补全方案。", "inputFormat": "数据包括三行。\n第一行有两个整数$n$，$m$，表示碱基序列的长度。\n第二行包含$n$个字符，表示碱基序列$S$。\n第三行包含$m$个字符，表示碱基序列$T$。\n两个碱基序列的字符种类只有$A,C,G,T$这$4$个大写字母。", "outputFormat": "答案只包含一行，表示补全方案的个数。", "hint": "样例解释：  \n$TCC$的$4$种补全方案（括号中字符为补全的碱基）  \n$(GA)TC(AT)C(TTC)$  \n$(GA)TC(ATCTT)C$  \n$(GA)T(CAT)C(TT)C$  \n$(GATCA)TC(TT)C$  \n\n数据范围：  \n对于$30\\% $数据，$n\\leq 1000,m\\leq 2$  \n对于$50\\% $数据，$n\\leq 1000,m\\leq 4$  \n对于$100\\% $数据，$n\\leq 2000,m\\leq n$  ", "locale": "zh-CN"}}}
{"pid": "P5485", "type": "P", "difficulty": 4, "samples": [["100 3\n10.0 40.0\n20.0 30.0\n15.0 35.0", "14.29 85.71 612"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2010", "各省省选", "吉林"], "title": "[JLOI2010] 铁人双项比赛", "background": null, "description": "铁人双项比赛是吉林教育学院的一项传统体育项目。该项目比赛由长跑和骑自行车组成，参赛选手必须先完成 $k$ 公里的长跑，然后完成r公里的骑车，才能到达终点。每个参赛选手所擅长的项目不同，有的擅长长跑，有的擅长骑车。如果总赛程 $s=k+r$ 一定，那么 $k$ 越大，对擅长长跑的选手越有利；$k$ 越小，对擅长骑车的选手越有利。\n \n现在给定总赛程 $s$，以及每个选手长跑和骑车的平均速度，请你求出对于某个指定的选手最有利的 $k$ 和 $r$。所谓最有利，是指选择了这个 $k$ 和 $r$ 后，该选手可以获得冠军，且领先第 $2$ 名尽量地多。", "inputFormat": "你的程序从文件读入输入数据。\n输入的第一行是两个正整数 $s$ 和 $n$，$s$ 表示总赛程（单位为公里，$s\\leq 2^{31}$），$n$ 表示参赛总人数（$2\\leq n\\leq 100$）。\n接下来的 $n$ 行每行是两个实数，分别表示每个选手长跑的平均速度和骑车的平均速度（单位为千米/小时）。\n第 $n$ 个选手就是指定的选手，你的任务是求出对他最有利的 $k$ 和 $r$。", "outputFormat": "你的程序的输出包括三个数 $k,r,t$，分别表示对第 $n$ 号选手最有利的 $k$ 和 $r$（浮点数，保留小数点后 $2$ 位），以及在选择 $k$ 和 $r$ 的情况下，第 $n$ 号选手最多可以领先第 $2$ 名多少秒（四舍五入到整数）；如果另一个选手和该选手并列第一，则 $t_i=0$。倘若无论选择什么 $k$，$r$ 都不能使第 $n$ 号选手获胜，则输出 ``NO``。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2010] Ironman Duathlon", "background": "", "description": "The Ironman Duathlon is a traditional sports event of Jilin Institute of Education. The race consists of long-distance running and cycling. Each contestant must first complete a $k$-kilometer run, and then complete an $r$-kilometer bike ride to reach the finish line. Different contestants are good at different events: some are better at running, while others are better at cycling. If the total distance $s=k+r$ is fixed, then the larger $k$ is, the more advantageous it is for contestants who are good at running; the smaller $k$ is, the more advantageous it is for contestants who are good at cycling.\n\nNow you are given the total distance $s$, as well as each contestant’s average speed for running and cycling. Please find the values of $k$ and $r$ that are the most favorable for a specified contestant. “Most favorable” means that after choosing this $k$ and $r$, the contestant can win the championship, and the lead over the second place is as large as possible.", "inputFormat": "Your program reads input from a file.  \nThe first line contains two positive integers $s$ and $n$. $s$ is the total distance (in kilometers, $s\\leq 2^{31}$), and $n$ is the total number of contestants ($2\\leq n\\leq 100$).  \nThe next $n$ lines each contain two real numbers, representing each contestant’s average running speed and average cycling speed (in kilometers per hour).  \nThe $n$-th contestant is the specified contestant. Your task is to find the most favorable $k$ and $r$ for them.", "outputFormat": "Your program should output three numbers $k,r,t$, representing the most favorable $k$ and $r$ for contestant $n$ (floating-point numbers, rounded to $2$ decimal places), and the maximum number of seconds by which contestant $n$ can lead the second place under this choice of $k$ and $r$ (rounded to an integer). If another contestant ties with them for first place, then $t=0$. If contestant $n$ cannot win no matter what $k$ and $r$ are chosen, output ``NO``.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2010] 铁人双项比赛", "background": null, "description": "铁人双项比赛是吉林教育学院的一项传统体育项目。该项目比赛由长跑和骑自行车组成，参赛选手必须先完成 $k$ 公里的长跑，然后完成r公里的骑车，才能到达终点。每个参赛选手所擅长的项目不同，有的擅长长跑，有的擅长骑车。如果总赛程 $s=k+r$ 一定，那么 $k$ 越大，对擅长长跑的选手越有利；$k$ 越小，对擅长骑车的选手越有利。\n \n现在给定总赛程 $s$，以及每个选手长跑和骑车的平均速度，请你求出对于某个指定的选手最有利的 $k$ 和 $r$。所谓最有利，是指选择了这个 $k$ 和 $r$ 后，该选手可以获得冠军，且领先第 $2$ 名尽量地多。", "inputFormat": "你的程序从文件读入输入数据。\n输入的第一行是两个正整数 $s$ 和 $n$，$s$ 表示总赛程（单位为公里，$s\\leq 2^{31}$），$n$ 表示参赛总人数（$2\\leq n\\leq 100$）。\n接下来的 $n$ 行每行是两个实数，分别表示每个选手长跑的平均速度和骑车的平均速度（单位为千米/小时）。\n第 $n$ 个选手就是指定的选手，你的任务是求出对他最有利的 $k$ 和 $r$。", "outputFormat": "你的程序的输出包括三个数 $k,r,t$，分别表示对第 $n$ 号选手最有利的 $k$ 和 $r$（浮点数，保留小数点后 $2$ 位），以及在选择 $k$ 和 $r$ 的情况下，第 $n$ 号选手最多可以领先第 $2$ 名多少秒（四舍五入到整数）；如果另一个选手和该选手并列第一，则 $t_i=0$。倘若无论选择什么 $k$，$r$ 都不能使第 $n$ 号选手获胜，则输出 ``NO``。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P5486", "type": "P", "difficulty": 5, "samples": [["10 7\nXXXXXXX\nXOXXXXO\nXOXXXXO\nXOXXXOX\nOXXOXOX\nXOXOXOX\nOXXOXOX\nOXXXXOX\nXXXXXXX\nXXXXXXX\n2 9\n0 0", "Case 1:\n\nB: 2-5\nF: 5-9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2010", "各省省选", "吉林", "区间 DP"], "title": "[JLOI2010] 世界杯租房", "background": null, "description": "南非世界杯组委会指定了在此期间可提供的一些旅馆供球迷租赁，名为阿凡达的即是其中一所。因为阿凡达旅馆房子的数目不超过 $26$，所以它们可以用 $26$ 个大写字母表示。  \n有一天，刘经理的电话响了，他接到了一个租赁房屋的请求，要求从 $6$ 月 $12$ 日晚起租到 $6$ 月 $19$ 日中午。于是他查看了预定表，但是并没有发现一间房屋能够直接满足要求。比如房主可能因为一些私人原因需要留在自己的房子中，所以这个游客不得不在其中的一间先住上几天再搬到另一间住上几天。他详细检查了预定表后，对旅客说：“我将你先在 $B$ 安置 $3$ 天，再将你安排到 $F$ 去度过剩余的旅途。”  \n你的目标是使得游客从一间房屋搬到另一间房屋的次数最少。  \n注意在旅馆的计费中，总是将某一天的晚上到第二天的中午视作一天。", "inputFormat": "输入文件包括多组数据。每组数据输入文件第一行包括两个整数 $M$ 和 $N$。$M$ 表示日程表上的天数，$N$ 表示公寓的数目。天数不超过 $100$ 天，从 $1$ 开始计数，公寓不超过 $26$ 个，从 $A$ 开始计数。  \n\n接下来 $M$ 行，每行包括 $N$ 个字母，表示从第i天晚到次日中午，该公寓是否已经被出租，$X$ 代表被出租，$O$ 代表未被出租。  \n\n最后一行包括两个整数 $s,t$，代表旅客从第 $s$ 天晚入住到第 $ (t+1) $ 天中午结束旅行。$1\\leq s<t\\leq M+1$。  \n$M=N=0$ 标志着文件的结束。", "outputFormat": "对于每一组数据，首先打印测试数据的编号，冒号和一个空行。接下来输出换房次数最少的方案，每一行使用如下格式：\n\n`<unit>: <start date>-<end date>`\n\n其中 `<unit>` 为房屋编号，`<start date>` 和 `<end date>` 分别为该旅客入住和离开该房屋时间。\n\n注意，如果存在多种方案满足换房次数最少，输出其中字典序最小的方案。\n\n如不存在这样的方案，输出一行“$\\texttt{Not available}$”。\n\n每两组输出之间以一个空行隔开。输出文件的末尾不要加空行。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2010] World Cup House Rental", "background": "", "description": "The South Africa World Cup organizing committee designated some hotels that could provide rooms for fans to rent during this period, and one of them is called Avatar. Since the number of rooms in the Avatar hotel does not exceed $26$, they can be represented by $26$ uppercase letters.  \nOne day, Manager Liu’s phone rang. He received a request to rent a room from the night of June 12 to noon of June 19. He checked the reservation table, but did not find any single room that could satisfy the request directly. For example, the owner might need to stay in their own room for personal reasons, so the tourist has to stay in one room for a few days and then move to another room for the remaining days. After carefully checking the reservation table, he told the traveler: “I will place you in $B$ for $3$ days first, and then arrange you to stay in $F$ for the rest of the trip.”  \nYour goal is to minimize the number of times the traveler needs to move from one room to another.  \nNote that in the hotel’s billing, the time from one night to the next day at noon is always counted as one day.", "inputFormat": "The input contains multiple test cases. For each test case, the first line contains two integers $M$ and $N$. $M$ is the number of days on the schedule, and $N$ is the number of units (rooms). The number of days does not exceed $100$, counted starting from $1$. The number of units does not exceed $26$, labeled starting from $A$.  \n\nThe next $M$ lines each contain $N$ letters, indicating whether the unit has already been rented from the night of day $i$ to noon of the next day. `X` means rented, and `O` means not rented.  \n\nThe last line contains two integers $s, t$, meaning the traveler checks in on the night of day $s$ and ends the trip at noon of day $(t+1)$. $1\\leq s<t\\leq M+1$.  \n$M=N=0$ indicates the end of the file.", "outputFormat": "For each test case, first print the testdata number, followed by a colon and a blank line. Then output a plan with the minimum number of room changes, using the following format on each line:\n\n`<unit>: <start date>-<end date>`\n\nHere, `<unit>` is the unit label, and `<start date>` and `<end date>` are the times when the traveler moves into and leaves that unit, respectively.\n\nNote that if there are multiple plans with the minimum number of room changes, output the lexicographically smallest plan.\n\nIf no such plan exists, output one line: `Not available`.\n\nPrint a blank line between every two test cases. Do not add an extra blank line at the end of the output.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2010] 世界杯租房", "background": null, "description": "南非世界杯组委会指定了在此期间可提供的一些旅馆供球迷租赁，名为阿凡达的即是其中一所。因为阿凡达旅馆房子的数目不超过 $26$，所以它们可以用 $26$ 个大写字母表示。  \n有一天，刘经理的电话响了，他接到了一个租赁房屋的请求，要求从 $6$ 月 $12$ 日晚起租到 $6$ 月 $19$ 日中午。于是他查看了预定表，但是并没有发现一间房屋能够直接满足要求。比如房主可能因为一些私人原因需要留在自己的房子中，所以这个游客不得不在其中的一间先住上几天再搬到另一间住上几天。他详细检查了预定表后，对旅客说：“我将你先在 $B$ 安置 $3$ 天，再将你安排到 $F$ 去度过剩余的旅途。”  \n你的目标是使得游客从一间房屋搬到另一间房屋的次数最少。  \n注意在旅馆的计费中，总是将某一天的晚上到第二天的中午视作一天。", "inputFormat": "输入文件包括多组数据。每组数据输入文件第一行包括两个整数 $M$ 和 $N$。$M$ 表示日程表上的天数，$N$ 表示公寓的数目。天数不超过 $100$ 天，从 $1$ 开始计数，公寓不超过 $26$ 个，从 $A$ 开始计数。  \n\n接下来 $M$ 行，每行包括 $N$ 个字母，表示从第i天晚到次日中午，该公寓是否已经被出租，$X$ 代表被出租，$O$ 代表未被出租。  \n\n最后一行包括两个整数 $s,t$，代表旅客从第 $s$ 天晚入住到第 $ (t+1) $ 天中午结束旅行。$1\\leq s<t\\leq M+1$。  \n$M=N=0$ 标志着文件的结束。", "outputFormat": "对于每一组数据，首先打印测试数据的编号，冒号和一个空行。接下来输出换房次数最少的方案，每一行使用如下格式：\n\n`<unit>: <start date>-<end date>`\n\n其中 `<unit>` 为房屋编号，`<start date>` 和 `<end date>` 分别为该旅客入住和离开该房屋时间。\n\n注意，如果存在多种方案满足换房次数最少，输出其中字典序最小的方案。\n\n如不存在这样的方案，输出一行“$\\texttt{Not available}$”。\n\n每两组输出之间以一个空行隔开。输出文件的末尾不要加空行。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P5487", "type": "P", "difficulty": 7, "samples": [["4 10\n1 1 2 3\n", "1 1 \n89\n"], ["5 10\n3 7 27 95 339", "3 2\n691707\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["O2优化", "线性递推", "Berlekamp-Massey(BM) 算法", "模板题"], "title": "【模板】Berlekamp–Massey 算法", "background": "前置技能：线性递推 $\\&~\\rm BM$ 算法。\n\n同时，请注意优化你的空间。保证最短递推式**唯一**。\n\n出题人为强行二合一感到很抱歉，但是其实也是可以学习一下 $k^2 \\log n$ 线性递推的——保证在 `-O2` 指令下可以过。", "description": "给出一个数列 $P$ 从 $0$ 开始的前 $n$ 项。\n\n求序列 $P$ 在 $\\bmod~998244353$ 下的最短线性递推式，并在 $\\bmod~998244353$ 下输出 $P_m$。", "inputFormat": "第一行共两个数 $n,m$ ，表示将会给出序列 $P$ 的前 $n$ 项，要求 $P_m$。\n\n第二行 $n$ 个数，表示 $P_0,P_1,P_2,\\ldots,P_{n-1}$。", "outputFormat": "第一行输出该最短线性递推式。\n\n第二行输出 $P_m$ 的值。", "hint": "对于 $100 \\%$ 的数据，$n < m \\le {10}^9$，$1 \\le n \\le 10000$，保证递推式最长不超过 $5000$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Berlekamp–Massey Algorithm", "background": "Prerequisite skills: linear recurrence and the $\\&~\\rm BM$ algorithm.\n\nAlso, please pay attention to optimizing your memory usage. The shortest recurrence is guaranteed to be **unique**.\n\nThe problem setter apologizes for forcing two tasks into one, but this is also a chance to learn the $k^2 \\log n$ method for linear recurrences. It is guaranteed to pass under the `-O2` option.", "description": "You are given the first $n$ terms of a sequence $P$ starting from index $0$.\n\nFind the shortest linear recurrence of sequence $P$ modulo $998244353$, and output $P_m$ modulo $998244353$.", "inputFormat": "The first line contains two integers $n,m$, meaning that the first $n$ terms of sequence $P$ will be given, and you need to compute $P_m$.\n\nThe second line contains $n$ integers, which are $P_0,P_1,P_2,\\ldots,P_{n-1}$.", "outputFormat": "On the first line, output the shortest linear recurrence.\n\nOn the second line, output the value of $P_m$.", "hint": "For $100\\%$ of the testdata, $n < m \\le 10^9$, $1 \\le n \\le 10000$, and the length of the recurrence is guaranteed to be at most $5000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】Berlekamp–Massey 算法", "background": "前置技能：线性递推 $\\&~\\rm BM$ 算法。\n\n同时，请注意优化你的空间。保证最短递推式**唯一**。\n\n出题人为强行二合一感到很抱歉，但是其实也是可以学习一下 $k^2 \\log n$ 线性递推的——保证在 `-O2` 指令下可以过。", "description": "给出一个数列 $P$ 从 $0$ 开始的前 $n$ 项。\n\n求序列 $P$ 在 $\\bmod~998244353$ 下的最短线性递推式，并在 $\\bmod~998244353$ 下输出 $P_m$。", "inputFormat": "第一行共两个数 $n,m$ ，表示将会给出序列 $P$ 的前 $n$ 项，要求 $P_m$。\n\n第二行 $n$ 个数，表示 $P_0,P_1,P_2,\\ldots,P_{n-1}$。", "outputFormat": "第一行输出该最短线性递推式。\n\n第二行输出 $P_m$ 的值。", "hint": "对于 $100 \\%$ 的数据，$n < m \\le {10}^9$，$1 \\le n \\le 10000$，保证递推式最长不超过 $5000$。", "locale": "zh-CN"}}}
{"pid": "P5488", "type": "P", "difficulty": 6, "samples": [["8 3 0\n1 9 2 6 0 8 1 7", "1 12 35 76 135 220 332 478 "], ["8 3 1\n1 9 2 6 0 8 1 7", "1 6 1004535787 26 1004535788 24 1004535780 28"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "快速傅里叶变换 FFT", "快速数论变换 NTT"], "title": "差分与前缀和", "background": "", "description": "给定一个长为 $n$ 的序列 $a$，求出其 $k$ 阶差分或前缀和。    \n结果的每一项都需要对 $1004535809$ 取模。", "inputFormat": "第一行三个整数 $n,k,t$，若 $t=0$ 表示求前缀和，$t=1$ 表示求差分。  \n第二行 $n$ 个整数，表示序列 $a$。", "outputFormat": "输出一行 $n$ 个整数，表示 $a$ 的 $k$ 阶差分或前缀和。", "hint": "【数据范围】  \n\n$1 \\le n \\le 10^5$  \n$0 \\le a_i \\le 10^9$   \n$1\\le k \\le 10^{2333}, k \\not \\equiv 0 \\pmod{1004535809}$", "locale": "zh-CN", "translations": {"en": {"title": "Difference and Prefix Sum", "background": "", "description": "Given a sequence $a$ of length $n$, find its $k$-th order difference or prefix sum.  \nEach term of the result needs to be taken modulo $1004535809$.", "inputFormat": "The first line contains three integers $n, k, t$. If $t = 0$, compute the prefix sum; if $t = 1$, compute the difference.  \nThe second line contains $n$ integers representing the sequence $a$.", "outputFormat": "Output one line with $n$ integers, representing the $k$-th order difference or prefix sum of $a$.", "hint": "Constraints  \n\n$1 \\le n \\le 10^5$  \n$0 \\le a_i \\le 10^9$  \n$1 \\le k \\le 10^{2333}, k \\not \\equiv 0 \\pmod{1004535809}$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "差分与前缀和", "background": "", "description": "给定一个长为 $n$ 的序列 $a$，求出其 $k$ 阶差分或前缀和。    \n结果的每一项都需要对 $1004535809$ 取模。", "inputFormat": "第一行三个整数 $n,k,t$，若 $t=0$ 表示求前缀和，$t=1$ 表示求差分。  \n第二行 $n$ 个整数，表示序列 $a$。", "outputFormat": "输出一行 $n$ 个整数，表示 $a$ 的 $k$ 阶差分或前缀和。", "hint": "【数据范围】  \n\n$1 \\le n \\le 10^5$  \n$0 \\le a_i \\le 10^9$   \n$1\\le k \\le 10^{2333}, k \\not \\equiv 0 \\pmod{1004535809}$", "locale": "zh-CN"}}}
