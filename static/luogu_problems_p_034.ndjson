{"pid": "P9619", "type": "P", "difficulty": 4, "samples": [["3\n1 2 3", "12"], ["6\n1 1 4 5 1 4", "19008"], ["10\n1 1 4 5 1 4 1 9 1 9", "567022588"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "生成树", "Prüfer 序列"], "title": "生成树", "background": "> 我们是未成熟的斗士 现在绝不认输\n>\n> 我们是未成熟的梦想家 现在绝不哭泣", "description": "现给定一个无向完全图 $G(V,E)$ 和一个长度为 $|V|$ 的权值数组 $a$．$a_i$ 表示编号为 $i$ 的节点的权值．\n\n定义一条边 $e(u,v)$ 的边值为 $val(e)$，满足 $val(e)=a_u\\oplus a_v$，也就是边连接的两个节点的权值的异或和；定义 $G$ 的一个生成树 $T(V,E_t)$ 的权值为 $Val(T)$，满足 $Val(T)=\\sum_{e\\in E_t}val(e)$，也就是树上边的边权和．\n\n您需要求出 $\\sum_{T}Val(T)$．即 $G$ 中所有不同生成树的权值的和．\n\n我们认为两棵生成树是不同的，当且仅当两棵树的边集 $E_t$ 不完全相同，即至少存在一条边，满足其仅属于两棵生成树中的其中一棵．", "inputFormat": "包括两行．\n\n第一行是一个整数 $n$，表示 $|V|$，即节点个数．\n\n第二行是 $n$ 个整数，依次为 $a_1\\sim a_n$．", "outputFormat": "一行一个整数．表示你的答案对 $998244353$ 取模．", "hint": "### 样例 #1 说明：\n考虑一共存在三个生成树 $\\{1-2-3\\},\\{1-3-2\\},\\{3-1-2\\}$．\n\n它们的权值分别为 $(1\\oplus 2)+(2\\oplus 3)=4,(1\\oplus 3)+(3\\oplus 2)=3,(3\\oplus 1)+(1\\oplus 2)=5$．\n\n有 $4+3+5=12$．\n\n### 数据点约束\n保证对于所有数据，$1\\le n\\le 10^6$，$0\\le a_i\\le 10^9$．\n|测试点编号|数据范围|特殊性质|\n|:-:|:-:|:-:|\n|$1$||所有 $a_i$ 相等|\n|$2\\sim 5$|$n\\le 4$||\n|$6\\sim 10$|$n\\le 300$||\n|$11\\sim 12$|$n\\le 5\\times 10^4$|$a_i=[i=1]$|\n|$11\\sim 15$|$n\\le 5\\times 10^4$||\n|$16\\sim 20$|||", "locale": "zh-CN", "translations": {"zh-CN": {"title": "生成树", "background": "> 我们是未成熟的斗士 现在绝不认输\n>\n> 我们是未成熟的梦想家 现在绝不哭泣", "description": "现给定一个无向完全图 $G(V,E)$ 和一个长度为 $|V|$ 的权值数组 $a$．$a_i$ 表示编号为 $i$ 的节点的权值．\n\n定义一条边 $e(u,v)$ 的边值为 $val(e)$，满足 $val(e)=a_u\\oplus a_v$，也就是边连接的两个节点的权值的异或和；定义 $G$ 的一个生成树 $T(V,E_t)$ 的权值为 $Val(T)$，满足 $Val(T)=\\sum_{e\\in E_t}val(e)$，也就是树上边的边权和．\n\n您需要求出 $\\sum_{T}Val(T)$．即 $G$ 中所有不同生成树的权值的和．\n\n我们认为两棵生成树是不同的，当且仅当两棵树的边集 $E_t$ 不完全相同，即至少存在一条边，满足其仅属于两棵生成树中的其中一棵．", "inputFormat": "包括两行．\n\n第一行是一个整数 $n$，表示 $|V|$，即节点个数．\n\n第二行是 $n$ 个整数，依次为 $a_1\\sim a_n$．", "outputFormat": "一行一个整数．表示你的答案对 $998244353$ 取模．", "hint": "### 样例 #1 说明：\n考虑一共存在三个生成树 $\\{1-2-3\\},\\{1-3-2\\},\\{3-1-2\\}$．\n\n它们的权值分别为 $(1\\oplus 2)+(2\\oplus 3)=4,(1\\oplus 3)+(3\\oplus 2)=3,(3\\oplus 1)+(1\\oplus 2)=5$．\n\n有 $4+3+5=12$．\n\n### 数据点约束\n保证对于所有数据，$1\\le n\\le 10^6$，$0\\le a_i\\le 10^9$．\n|测试点编号|数据范围|特殊性质|\n|:-:|:-:|:-:|\n|$1$||所有 $a_i$ 相等|\n|$2\\sim 5$|$n\\le 4$||\n|$6\\sim 10$|$n\\le 300$||\n|$11\\sim 12$|$n\\le 5\\times 10^4$|$a_i=[i=1]$|\n|$11\\sim 15$|$n\\le 5\\times 10^4$||\n|$16\\sim 20$|||", "locale": "zh-CN"}}}
{"pid": "P9620", "type": "P", "difficulty": 6, "samples": [["7 8\n1 2\n1 5\n2 3\n2 4\n5 6\n5 7\nReal 3\nReal 4\nReal 6\nReal 7\nWant 7\nReal 2\nReal 5\nWant 3\n", "1\n1\n1\n2\n1\n1\n2\n2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": [], "title": "歌姬", "background": "> 你如此一来就满足了吗？\n>\n> 没有想过去实现它吗?\n>\n> 为你而设的 为你而设的\n>\n> 可怜的制度化作温柔的义务", "description": "现在 \\*26 的头脑中想着 $n$ 件事情，它们形成一棵树．事情有现实和妄想两种状态．初始时所有事情都是妄想．不妨将事情 $1$ 假设成头脑中这棵树的根．那么一个事情 $u$ 的深度指从事情 $1$ 到事情 $u$ 的简单路径上的事情数（包含端点）．\n\n我们称一个事情的集合 $S$ 为现实联通体，当其满足对于树上任意两个现实事情，其在树上简单路径（包括端点）中的事情都属于 $S$．极小现实连通体，即包含事情数最少的现实连通体．\n\n随着时间推移，事情的状态可能发生一些变动．下面 \\*26 和您提及了 $m$ 次事情的变动．变动分为以下两种不同的情况：\n\n1. `Real u` 第 $u$ 件事情变成现实．\n2. `Want u` 第 $u$ 件事情变成妄想．\n\n每次变动后，\\*26 会向您询问：目前至少还需要额外让几个事情变成妄想，才能使最小现实联通体中深度最小的事情的位置发生改变，或使当前头脑中不存在现实事情．", "inputFormat": "第一行是两个整数 $n, m$ 表示事情个数和变动个数．\n\n接下来 $n - 1$ 行每行两个整数表示树上的一条边．\n\n接下来 $m$ 行形如：`Real u` 或 `Want u`．表示一次思考．其中 $1\\le u\\le n$．", "outputFormat": "共 $m$ 行，每行一个整数，表示第 $i$ 次变动后，您向 \\*26 提供的答案．", "hint": "### 样例 #1 说明\n举例最后一次变动结束后的情况．\n\n此时树上除了事情 $1,3,7$ 是妄想，其余是现实．那么此时的最小现实联通体就是 $\\{1,2,4,5,6\\}$．\n\n$\\{2,4,5,6\\}$ 不是最小现实连通体，因为存在两个现实事件如 $2,6$，其简单路径经过 $1$，而 $1$ 不在 $\\{2,4,5,6\\}$ 这个集合里；$\\{1,2,3,4,5,6\\}$ 同样不是最小现实联通体，因为存在一个现实联通体 $\\{1,2,4,5,6\\}$ 的大小小于它．\n\n当我们令事情 $2,4$ 变成妄想后，现实事情仅剩下 $5,6$，这时最小现实连通体为 $\\{5,6\\}$．其中深度最小的事情由原来的 $1$ 变成了现在的 $5$．可以证明这个策略是最优策略之一．\n\n### 数据点约束\n|数据点编号|数据范围|\n|:-:|:-:|\n|$1,2$|$1\\le n,m \\le 20$|\n|$3,4,5$|$1\\le n,m \\le 300$|\n|$6,7,8$|$1\\le n,m \\le 3000$|\n|$9,10,11,12$|$1\\le n, m \\le 39393$|\n|$13 \\sim 20$|$1\\le n, m \\le 2 \\times 10^5$|\n\n对于所有数据，保证在任意一次操作时，变动之前和变动之后事情的状态不一样．", "locale": "zh-CN", "translations": {"zh-CN": {"title": "歌姬", "background": "> 你如此一来就满足了吗？\n>\n> 没有想过去实现它吗?\n>\n> 为你而设的 为你而设的\n>\n> 可怜的制度化作温柔的义务", "description": "现在 \\*26 的头脑中想着 $n$ 件事情，它们形成一棵树．事情有现实和妄想两种状态．初始时所有事情都是妄想．不妨将事情 $1$ 假设成头脑中这棵树的根．那么一个事情 $u$ 的深度指从事情 $1$ 到事情 $u$ 的简单路径上的事情数（包含端点）．\n\n我们称一个事情的集合 $S$ 为现实联通体，当其满足对于树上任意两个现实事情，其在树上简单路径（包括端点）中的事情都属于 $S$．极小现实连通体，即包含事情数最少的现实连通体．\n\n随着时间推移，事情的状态可能发生一些变动．下面 \\*26 和您提及了 $m$ 次事情的变动．变动分为以下两种不同的情况：\n\n1. `Real u` 第 $u$ 件事情变成现实．\n2. `Want u` 第 $u$ 件事情变成妄想．\n\n每次变动后，\\*26 会向您询问：目前至少还需要额外让几个事情变成妄想，才能使最小现实联通体中深度最小的事情的位置发生改变，或使当前头脑中不存在现实事情．", "inputFormat": "第一行是两个整数 $n, m$ 表示事情个数和变动个数．\n\n接下来 $n - 1$ 行每行两个整数表示树上的一条边．\n\n接下来 $m$ 行形如：`Real u` 或 `Want u`．表示一次思考．其中 $1\\le u\\le n$．", "outputFormat": "共 $m$ 行，每行一个整数，表示第 $i$ 次变动后，您向 \\*26 提供的答案．", "hint": "### 样例 #1 说明\n举例最后一次变动结束后的情况．\n\n此时树上除了事情 $1,3,7$ 是妄想，其余是现实．那么此时的最小现实联通体就是 $\\{1,2,4,5,6\\}$．\n\n$\\{2,4,5,6\\}$ 不是最小现实连通体，因为存在两个现实事件如 $2,6$，其简单路径经过 $1$，而 $1$ 不在 $\\{2,4,5,6\\}$ 这个集合里；$\\{1,2,3,4,5,6\\}$ 同样不是最小现实联通体，因为存在一个现实联通体 $\\{1,2,4,5,6\\}$ 的大小小于它．\n\n当我们令事情 $2,4$ 变成妄想后，现实事情仅剩下 $5,6$，这时最小现实连通体为 $\\{5,6\\}$．其中深度最小的事情由原来的 $1$ 变成了现在的 $5$．可以证明这个策略是最优策略之一．\n\n### 数据点约束\n|数据点编号|数据范围|\n|:-:|:-:|\n|$1,2$|$1\\le n,m \\le 20$|\n|$3,4,5$|$1\\le n,m \\le 300$|\n|$6,7,8$|$1\\le n,m \\le 3000$|\n|$9,10,11,12$|$1\\le n, m \\le 39393$|\n|$13 \\sim 20$|$1\\le n, m \\le 2 \\times 10^5$|\n\n对于所有数据，保证在任意一次操作时，变动之前和变动之后事情的状态不一样．", "locale": "zh-CN"}}}
{"pid": "P9621", "type": "P", "difficulty": 6, "samples": [["0 0\n4 2\n10 20 20 50\n20 10 20 50\n20 20 10 50\n20 50 10 20\n", "530317523"], ["0 280114129\n5 5\n36 23 30 11\n0 52 25 23\n14 61 23 2\n10 41 37 12\n0 12 78 10\n", "898420164"], ["1 114\n5141 919\n", "800181066"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": [], "title": "下次再见", "background": "> 在逝去的季节中 遗失的宝藏\n>\n> 是缺失一角的 珍贵拼图\n>\n> 就像白雪在街道上 温柔地堆积的样子\n>\n> 也将回忆相簿的空白 全部填满吧", "description": "有一首由 $n$ 个圆圈组成的乐曲．玩家会 **等概率随机选定** $1 \\sim n$ 中的一个位置开始游玩，顺序点击那个位置和之后的所有圆圈来完成乐曲的演奏．\n\n对于每个圆圈的点击精准度存在四种判定，分别是 $\\texttt{GREAT,OK,MEH,MISS}$．\n\n存在一种机制：当连续 $K$ 次 $\\texttt{MISS}$ 后，玩家会强制退出游戏；否则玩家会一直游玩直到点击完所有圆圈．\n\n现在给出对于每个圆圈，玩家达成每一种判定的概率：对于第 $i$ 个圆圈，判定 $\\texttt{GREAT},\\texttt{OK},\\texttt{MEH},\\texttt{MISS}$ 的概率分别为 $P_{i,0}/100,\\ P_{i,1}/100,\\ P_{i,2}/100,\\ P_{i,3}/100$．保证 $P_{i,0}+P_{i,1}+P_{i,2}+P_{i,3}=100$．\n\n得分是衡量整段演奏的指标，它的计算方式是，假设整段演奏中出现了 $a$ 次 $\\texttt{GREAT}$，$b$ 次 $\\texttt{OK}$，$c$ 次 $\\texttt{MEH}$，$d$ 次 $\\texttt{MISS}$，那么演奏的得分为 $300a+100b+50c$．\n\n你需要回答玩家得分的期望．\n\n说明：如果强制退出游戏，那么计算得分时，整段演奏包括从开始的点击到最后一次判定 $\\texttt{MISS}$ 的点击为止所有的点击．\n\n在部分数据大小范围较大的测试点上，为了减小输入输出的交互量，我们采用了不同的输入方式．您需要在您的 c++ 代码中加入题目附件中提供的数据生成器．建议在阅读接下来的内容前先浏览一下生成器中提供的函数名称，这可以帮助您更好地理解输入格式．", "inputFormat": "第一行包含两个整数 $Type,seed$．\n\n当 $Type=1$ 的时候，您需要在读入 $seed$ 之后调用 `Ge.init(seed)` 来设置数据生成器的种子．否则您可以忽视 $seed$．\n\n第二行包括两个整数 $n,K$．\n\n接下来分两种情况：\n\n- $Type=0$．接下来 $n$ 行，每行包括 $4$ 个整数，表示 $P_{i,0}\\ P_{i,1}\\ P_{i,2}\\ P_{i,3}$．\n\n- $Type=1$．接下来没有任何输入．您第 $i$ 次调用 ``Ge.get(a,b,c,d)`` 之后，$a,b,c,d$ 的值分别为 $P_{i,0}\\ P_{i,1}\\ P_{i,2}\\ P_{i,3}$．", "outputFormat": "一行一个整数，表示答案 $\\bmod\\ 998244353$．\n\n说明：可以证明，答案能够表示为 $p/q$．您需要输出 $q$ 在 $\\bmod\\ 998244353$ 意义下的逆元和 $p$ 的乘积对 $998244353$ 取模后的结果．", "hint": "|测试点编号|数据范围|特殊性质|\n|:-:|:-:|:-:|\n|$1\\sim 2$|$n\\le 5$||\n|$3\\sim 4$|$n\\le 50$||\n|$5\\sim 6$|$n\\le 10^3$||\n|$7\\sim 8$|$n\\le 10^5,K\\le 10^3$||\n|$9\\sim 10$||$A$|\n|$11\\sim 12$||$B$|\n|$13\\sim 15$|$n,K\\le 5\\times 10^5$||\n|$16\\sim 20$||\n\n$A$：保证所有位置的 $P_{i,3}$ 相等．\n\n$B$：保证对于所有位置，$P_{i,3}$ 等于 $0$ 或等于 $100$．\n\n---\n对于编号在 $1\\sim 15$ 的测试点，$Type=0$；对于编号在 $16\\sim 20$ 的测试点，$Type=1$．\n\n保证，对于全部数据，$0\\le P_{i,0/1/2/3}\\le 100$，$1\\le K\\le n\\le 5\\times 10^6$，$Type=0/1$，$1\\le seed\\le 10^9$．", "locale": "zh-CN", "translations": {"zh-CN": {"title": "下次再见", "background": "> 在逝去的季节中 遗失的宝藏\n>\n> 是缺失一角的 珍贵拼图\n>\n> 就像白雪在街道上 温柔地堆积的样子\n>\n> 也将回忆相簿的空白 全部填满吧", "description": "有一首由 $n$ 个圆圈组成的乐曲．玩家会 **等概率随机选定** $1 \\sim n$ 中的一个位置开始游玩，顺序点击那个位置和之后的所有圆圈来完成乐曲的演奏．\n\n对于每个圆圈的点击精准度存在四种判定，分别是 $\\texttt{GREAT,OK,MEH,MISS}$．\n\n存在一种机制：当连续 $K$ 次 $\\texttt{MISS}$ 后，玩家会强制退出游戏；否则玩家会一直游玩直到点击完所有圆圈．\n\n现在给出对于每个圆圈，玩家达成每一种判定的概率：对于第 $i$ 个圆圈，判定 $\\texttt{GREAT},\\texttt{OK},\\texttt{MEH},\\texttt{MISS}$ 的概率分别为 $P_{i,0}/100,\\ P_{i,1}/100,\\ P_{i,2}/100,\\ P_{i,3}/100$．保证 $P_{i,0}+P_{i,1}+P_{i,2}+P_{i,3}=100$．\n\n得分是衡量整段演奏的指标，它的计算方式是，假设整段演奏中出现了 $a$ 次 $\\texttt{GREAT}$，$b$ 次 $\\texttt{OK}$，$c$ 次 $\\texttt{MEH}$，$d$ 次 $\\texttt{MISS}$，那么演奏的得分为 $300a+100b+50c$．\n\n你需要回答玩家得分的期望．\n\n说明：如果强制退出游戏，那么计算得分时，整段演奏包括从开始的点击到最后一次判定 $\\texttt{MISS}$ 的点击为止所有的点击．\n\n在部分数据大小范围较大的测试点上，为了减小输入输出的交互量，我们采用了不同的输入方式．您需要在您的 c++ 代码中加入题目附件中提供的数据生成器．建议在阅读接下来的内容前先浏览一下生成器中提供的函数名称，这可以帮助您更好地理解输入格式．", "inputFormat": "第一行包含两个整数 $Type,seed$．\n\n当 $Type=1$ 的时候，您需要在读入 $seed$ 之后调用 `Ge.init(seed)` 来设置数据生成器的种子．否则您可以忽视 $seed$．\n\n第二行包括两个整数 $n,K$．\n\n接下来分两种情况：\n\n- $Type=0$．接下来 $n$ 行，每行包括 $4$ 个整数，表示 $P_{i,0}\\ P_{i,1}\\ P_{i,2}\\ P_{i,3}$．\n\n- $Type=1$．接下来没有任何输入．您第 $i$ 次调用 ``Ge.get(a,b,c,d)`` 之后，$a,b,c,d$ 的值分别为 $P_{i,0}\\ P_{i,1}\\ P_{i,2}\\ P_{i,3}$．", "outputFormat": "一行一个整数，表示答案 $\\bmod\\ 998244353$．\n\n说明：可以证明，答案能够表示为 $p/q$．您需要输出 $q$ 在 $\\bmod\\ 998244353$ 意义下的逆元和 $p$ 的乘积对 $998244353$ 取模后的结果．", "hint": "|测试点编号|数据范围|特殊性质|\n|:-:|:-:|:-:|\n|$1\\sim 2$|$n\\le 5$||\n|$3\\sim 4$|$n\\le 50$||\n|$5\\sim 6$|$n\\le 10^3$||\n|$7\\sim 8$|$n\\le 10^5,K\\le 10^3$||\n|$9\\sim 10$||$A$|\n|$11\\sim 12$||$B$|\n|$13\\sim 15$|$n,K\\le 5\\times 10^5$||\n|$16\\sim 20$||\n\n$A$：保证所有位置的 $P_{i,3}$ 相等．\n\n$B$：保证对于所有位置，$P_{i,3}$ 等于 $0$ 或等于 $100$．\n\n---\n对于编号在 $1\\sim 15$ 的测试点，$Type=0$；对于编号在 $16\\sim 20$ 的测试点，$Type=1$．\n\n保证，对于全部数据，$0\\le P_{i,0/1/2/3}\\le 100$，$1\\le K\\le n\\le 5\\times 10^6$，$Type=0/1$，$1\\le seed\\le 10^9$．", "locale": "zh-CN"}}}
{"pid": "P9622", "type": "P", "difficulty": 6, "samples": [["(No input)", "3 4\n1111\n1010\n1100\n"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["2020", "Special Judge", "O2优化", "构造", "ICPC", "南京"], "title": "[ICPC 2020 Nanjing R] Ah, It's Yesterday Once More", "background": "", "description": "In 2018, hosted by Nanjing University of Aeronautics and Astronautics (NUAA), the $\\textit{International Collegiate Programming Contest}$ (ICPC) regional was held in Nanjing again after a few years' gap. There were over $400$ teams in the contest and team $\\textit{Power of Two}$ from Tsinghua University won the champion.\n\nTwo years have passed and after the great success in 2018 and 2019, NUAA continues to hold the ICPC Nanjing Regional in 2020. Although we can't gather in Nanjing this time due to the pandemic, we should still be grateful for the hard work done by all staff and volunteers for this contest. Thank you all for your great contribution to this contest!\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z82ge8hi.png)\n\nIn the 2018 contest, problem K, $\\textit{Kangaroo Puzzle}$, requires the contestants to construct an operation sequence for the game. Let's first recall the content of that problem:\n\n> The puzzle is a grid with $n$ rows and $m$ columns ($1 \\le n, m \\le 20$) and there are some (at least $2$) kangaroos standing in the puzzle. The player's goal is to control them to get together. There are some walls in some cells and the kangaroos cannot enter the cells with walls. The other cells are empty. The kangaroos can move from an empty cell to an adjacent empty cell in four directions: up, down, left, and right. It's guaranteed that kangaroos can reach from any empty cell to any other empty cells by going through adjacent empty cells. It is also guaranteed that there is no cycle in the puzzle -- that is, it's impossible that one kangaroo can move from an empty cell, pass by several distinct empty cells, and then back to the original cell.\n>\n> There is exactly one kangaroo in every empty cell in the beginning and the player can control the kangaroos by pressing the button U, D, L, R on the keyboard. The kangaroos will move simultaneously according to the button you press. For instance, if you press the button R, a kangaroo would move one cell to the right if it exists and is empty, and will stay still if it does not exist or is not empty.\n>\n> In this problem, the contestant needs to construct an operating sequence of at most $5 \\times 10^4$ steps consisting of U, D, L, R only. If after operating these steps in order there are still two kangaroos standing in different cells, the contestant will be given a `Wrong Answer` verdict.\n\nOur dear friend, Kotori, also took part in the contest and submitted a code of randomized algorithm. To her surprise, this simple solution is judged as a correct answer. We now present her solution as follows:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstring s = \"UDLR\";\nint main()\n{\n  srand(time(NULL));\n  for (int i = 1; i <= 50000; i++) putchar(s[rand() % 4]);\n  return 0;\n}\n```\n\nFor contestants who are not familiar with C and C++: the above code will output a random string of length $5 \\times 10^4$ consisting only of characters `U`, `D`, `L` and `R`, where each character has equal probability to appear in each position in the string.\n\nKotori suspects that things might not be that simple for this problem, so right now, in this $\\textit{2020 ICPC Nanjing Regional}$ contest, you need to construct an input data to hack her solution. Due to the randomness, your input data only needs to satisfy a successful hacking rate of at least $25\\%$. \n\nFormally speaking, we've prepared $500$ randomly generated strings that each character has equal probability to appear in each position and will use them as the controlling sequence against your answer. For your answer to be accepted, there should be at least $125$ times that after using your answer as the map of cells and the whole controlling sequence is executed, there are still kangaroos in different cells.\n\nNote that your input data should be completely legal. That is to say:\n\n- The map in your answer should not be larger than $20 \\times 20$;\n- Your answer should contain at least two empty cells;\n- All empty cells in your answer should be reachable starting from any empty cell;\n- No cycles consisting of empty cells are allowed.", "inputFormat": "There is no input for this problem. You're on your own!", "outputFormat": "You should first output one line containing two integers $n$ and $m$ ($1 \\le n, m \\le 20$) separated by a space, indicating the number of rows and columns of the map in your answer.\n\nYou should then output $n$ lines where the $i$-th line contains a binary string $s_{i,1}s_{i,2}\\cdots s_{i,m}$ ($s_{i,j} \\in \\{\\text{`0'}, \\text{`1'}\\}$) of length $m$. If $s_{i,j} = \\text{`1'}$ then the cell in the $i$-th row and the $j$-th column is empty; Otherwise that corresponding cell contains a wall and cannot be entered.\n\nNote again that your answer only need to achieve a successful hacking rate of at least $25\\%$. Not that hard isn't it?", "hint": "### Note\nThe sample output we provide you is (obviously) incorrect. It only serves the purpose of showing you the output format. This is a $3 \\times 4$ map with $4$ walls, so there will be $8$ kangaroos in the empty cells at the beginning.", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Nanjing R] Ah, It's Yesterday Once More", "background": "", "description": "In 2018, hosted by Nanjing University of Aeronautics and Astronautics (NUAA), the $\\textit{International Collegiate Programming Contest}$ (ICPC) regional was held in Nanjing again after a few years' gap. There were over $400$ teams in the contest and team $\\textit{Power of Two}$ from Tsinghua University won the champion.\n\nTwo years have passed and after the great success in 2018 and 2019, NUAA continues to hold the ICPC Nanjing Regional in 2020. Although we can't gather in Nanjing this time due to the pandemic, we should still be grateful for the hard work done by all staff and volunteers for this contest. Thank you all for your great contribution to this contest!\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z82ge8hi.png)\n\nIn the 2018 contest, problem K, $\\textit{Kangaroo Puzzle}$, requires the contestants to construct an operation sequence for the game. Let's first recall the content of that problem:\n\n> The puzzle is a grid with $n$ rows and $m$ columns ($1 \\le n, m \\le 20$) and there are some (at least $2$) kangaroos standing in the puzzle. The player's goal is to control them to get together. There are some walls in some cells and the kangaroos cannot enter the cells with walls. The other cells are empty. The kangaroos can move from an empty cell to an adjacent empty cell in four directions: up, down, left, and right. It's guaranteed that kangaroos can reach from any empty cell to any other empty cells by going through adjacent empty cells. It is also guaranteed that there is no cycle in the puzzle -- that is, it's impossible that one kangaroo can move from an empty cell, pass by several distinct empty cells, and then back to the original cell.\n>\n> There is exactly one kangaroo in every empty cell in the beginning and the player can control the kangaroos by pressing the button U, D, L, R on the keyboard. The kangaroos will move simultaneously according to the button you press. For instance, if you press the button R, a kangaroo would move one cell to the right if it exists and is empty, and will stay still if it does not exist or is not empty.\n>\n> In this problem, the contestant needs to construct an operating sequence of at most $5 \\times 10^4$ steps consisting of U, D, L, R only. If after operating these steps in order there are still two kangaroos standing in different cells, the contestant will be given a `Wrong Answer` verdict.\n\nOur dear friend, Kotori, also took part in the contest and submitted a code of randomized algorithm. To her surprise, this simple solution is judged as a correct answer. We now present her solution as follows:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstring s = \"UDLR\";\nint main()\n{\n  srand(time(NULL));\n  for (int i = 1; i <= 50000; i++) putchar(s[rand() % 4]);\n  return 0;\n}\n```\n\nFor contestants who are not familiar with C and C++: the above code will output a random string of length $5 \\times 10^4$ consisting only of characters `U`, `D`, `L` and `R`, where each character has equal probability to appear in each position in the string.\n\nKotori suspects that things might not be that simple for this problem, so right now, in this $\\textit{2020 ICPC Nanjing Regional}$ contest, you need to construct an input data to hack her solution. Due to the randomness, your input data only needs to satisfy a successful hacking rate of at least $25\\%$. \n\nFormally speaking, we've prepared $500$ randomly generated strings that each character has equal probability to appear in each position and will use them as the controlling sequence against your answer. For your answer to be accepted, there should be at least $125$ times that after using your answer as the map of cells and the whole controlling sequence is executed, there are still kangaroos in different cells.\n\nNote that your input data should be completely legal. That is to say:\n\n- The map in your answer should not be larger than $20 \\times 20$;\n- Your answer should contain at least two empty cells;\n- All empty cells in your answer should be reachable starting from any empty cell;\n- No cycles consisting of empty cells are allowed.", "inputFormat": "There is no input for this problem. You're on your own!", "outputFormat": "You should first output one line containing two integers $n$ and $m$ ($1 \\le n, m \\le 20$) separated by a space, indicating the number of rows and columns of the map in your answer.\n\nYou should then output $n$ lines where the $i$-th line contains a binary string $s_{i,1}s_{i,2}\\cdots s_{i,m}$ ($s_{i,j} \\in \\{\\text{`0'}, \\text{`1'}\\}$) of length $m$. If $s_{i,j} = \\text{`1'}$ then the cell in the $i$-th row and the $j$-th column is empty; Otherwise that corresponding cell contains a wall and cannot be entered.\n\nNote again that your answer only need to achieve a successful hacking rate of at least $25\\%$. Not that hard isn't it?", "hint": "### Note\nThe sample output we provide you is (obviously) incorrect. It only serves the purpose of showing you the output format. This is a $3 \\times 4$ map with $4$ walls, so there will be $8$ kangaroos in the empty cells at the beginning.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Nanjing R] Ah, It's Yesterday Once More", "background": "", "description": "2018 年，由南京航空航天大学（NUAA）主办的 $\\textit{国际大学生程序设计竞赛}$（ICPC）区域赛在南京再次举行，这是在经过几年的间隔后再次举办。比赛中有超过 $400$ 支队伍参加，清华大学的队伍 $\\textit{Power of Two}$ 获得了冠军。\n\n两年过去了，在 2018 年和 2019 年取得巨大成功后，NUAA 继续在 2020 年举办 ICPC 南京区域赛。尽管由于疫情我们这次无法在南京聚集，但我们仍应感谢所有工作人员和志愿者为这次比赛所做的辛勤工作。感谢你们为这次比赛做出的巨大贡献！\n\n在 2018 年的比赛中，问题 K，$\\textit{袋鼠拼图}$，要求参赛者为游戏构建一个操作序列。让我们先回顾一下该问题的内容：\n\n> 这个拼图是一个有 $n$ 行 $m$ 列的网格（$1 \\le n, m \\le 20$），其中有一些（至少 $2$ 只）袋鼠站在拼图中。玩家的目标是控制它们聚集在一起。某些单元格中有墙，袋鼠不能进入有墙的单元格。其他单元格是空的。袋鼠可以从一个空单元格移动到相邻的空单元格，方向有四个：上、下、左、右。保证袋鼠可以通过相邻的空单元格从任何空单元格到达任何其他空单元格。还保证拼图中没有循环——也就是说，不可能有袋鼠从一个空单元格出发，经过几个不同的空单元格，然后回到原来的单元格。\n\n> 每个空单元格开始时恰好有一只袋鼠，玩家可以通过按键盘上的 U、D、L、R 按钮来控制袋鼠。袋鼠将根据您按下的按钮同时移动。例如，如果您按下按钮 R，袋鼠会向右移动一个单元格，如果存在且为空，否则将保持不动。\n\n> 在这个问题中，参赛者需要构建一个最多包含 $5 \\times 10^4$ 步的操作序列，只能由 U、D、L、R 组成。如果按顺序操作这些步骤后，仍然有两只袋鼠站在不同的单元格中，参赛者将得到一个 `Wrong Answer` 判定。\n\n我们的亲爱朋友 Kotori 也参加了比赛，并提交了一段随机算法的代码。令她惊讶的是，这个简单的解决方案被判定为正确答案。我们现在展示她的解决方案如下：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstring s = \"UDLR\";\nint main()\n{\n  srand(time(NULL));\n  for (int i = 1; i <= 50000; i++) putchar(s[rand() % 4]);\n  return 0;\n}\n```\n\n对于不熟悉 C 和 C++ 的参赛者：上述代码将输出一个长度为 $5 \\times 10^4$ 的随机字符串，仅由字符 `U`、`D`、`L` 和 `R` 组成，其中每个字符在字符串中的每个位置出现的概率相等。\n\nKotori 怀疑这个问题可能没有那么简单，所以现在，在这次 $\\textit{2020 ICPC 南京区域赛}$ 中，你需要构造一个输入数据来破解她的解决方案。由于随机性，您的输入数据只需满足至少 $25\\%$ 的成功破解率。\n\n正式地说，我们准备了 $500$ 个随机生成的字符串，每个字符在每个位置出现的概率相等，并将它们用作控制序列来对抗您的答案。为了使您的答案被接受，在使用您的答案作为单元格地图并执行整个控制序列后，至少有 $125$ 次袋鼠仍在不同的单元格中。\n\n请注意，您的输入数据必须完全合法。也就是说：\n\n- 您答案中的地图不应大于 $20 \\times 20$；\n- 您的答案应至少包含两个空单元格；\n- 您答案中的所有空单元格应从任何空单元格开始是可达的；\n- 不允许存在由空单元格组成的循环。", "inputFormat": "本题没有输入。你需要自己解决！", "outputFormat": "您应首先输出一行，包含两个整数 $n$ 和 $m$（$1 \\le n, m \\le 20$），用空格分隔，表示您答案中的地图的行数和列数。\n\n然后您应输出 $n$ 行，其中第 $i$ 行包含一个长度为 $m$ 的二进制字符串 $s_{i,1}s_{i,2}\\cdots s_{i,m}$（$s_{i,j} \\in \\{\\text{`0'}, \\text{`1'}\\}$）。如果 $s_{i,j} = \\text{`1'}`，则第 $i$ 行第 $j$ 列的单元格是空的；否则，该对应单元格包含墙壁，无法进入。\n\n再次注意，您的答案只需达到至少 $25\\%$ 的成功破解率。不是很难，对吧？", "hint": "### 注意\n\n我们提供的示例输出（显然）是错误的。它仅用于向您展示输出格式。这是一个 $3 \\times 4$ 的地图，开始时有 $4$ 墙，因此在空单元格中将有 $8$ 只袋鼠。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9623", "type": "P", "difficulty": 7, "samples": [["2\n10 4\nbaaabbabba\n2 8 3\n1 1 1\n2 3 2\n2 5 4\n20 3\ncccbccbadaacbbbcccab\n14 17 16\n3 20 17\n17 20 18\n", "2\n1\n2\n3\n4\n15\n3\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["字符串", "2020", "O2优化", "ICPC", "南京"], "title": "[ICPC 2020 Nanjing R] Baby's First Suffix Array Problem", "background": "", "description": "\nA suffix array for string $s$ of length $n$ is a permutation $sa$ of integers from $1$ to $n$ such that $s[sa_1.. n], s[sa_2..n], \\dots, s[sa_n..n]$ is the list of non-empty suffixes of $s$ sorted in lexicographical order. The rank table for suffixex of $s$ is a permutation $rank$ of integers from $1$ to $n$ such that $rank_{sa_i} = i$.\n\nKotori has a string $s=s_1s_2\\dots s_n$. She would like to ask $m$ queries. And in the $i$-th query, a substring $x=s[l_i..r_i]$ of $s$ is given, Kotori would like to know the rank of suffix $s[k_i..r_i]$ of $x$.\n\nNote $s[l..r]$ means the substring of $s$ which starts from the $l$-th position and ends at the $r$-th position, both inclusive.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n, m \\le 5 \\times 10^4$) -- the length of the string and the number of queries.\n\nThe second line contains a string $s$ of length $n$ consisting only of lowercase English letters.\n\nEach of the next $m$ lines contains three integers $l_i$, $r_i$ and $k_i$ ($1 \\le l_i \\le r_i \\le n, l_i \\le k_i \\le r_i$) denoting a query.\n\nIt is guaranteed that neither the sum of $n$ or the sum of $m$ of all test cases will exceed $5 \\times 10^4$.", "outputFormat": "For each query output one line containing one integer denoting the answer.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Nanjing R] Baby's First Suffix Array Problem", "background": "", "description": "\nA suffix array for string $s$ of length $n$ is a permutation $sa$ of integers from $1$ to $n$ such that $s[sa_1.. n], s[sa_2..n], \\dots, s[sa_n..n]$ is the list of non-empty suffixes of $s$ sorted in lexicographical order. The rank table for suffixex of $s$ is a permutation $rank$ of integers from $1$ to $n$ such that $rank_{sa_i} = i$.\n\nKotori has a string $s=s_1s_2\\dots s_n$. She would like to ask $m$ queries. And in the $i$-th query, a substring $x=s[l_i..r_i]$ of $s$ is given, Kotori would like to know the rank of suffix $s[k_i..r_i]$ of $x$.\n\nNote $s[l..r]$ means the substring of $s$ which starts from the $l$-th position and ends at the $r$-th position, both inclusive.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n, m \\le 5 \\times 10^4$) -- the length of the string and the number of queries.\n\nThe second line contains a string $s$ of length $n$ consisting only of lowercase English letters.\n\nEach of the next $m$ lines contains three integers $l_i$, $r_i$ and $k_i$ ($1 \\le l_i \\le r_i \\le n, l_i \\le k_i \\le r_i$) denoting a query.\n\nIt is guaranteed that neither the sum of $n$ or the sum of $m$ of all test cases will exceed $5 \\times 10^4$.", "outputFormat": "For each query output one line containing one integer denoting the answer.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Nanjing R] Baby's First Suffix Array Problem", "background": "", "description": "对于长度为 $n$ 的字符串 $s$ ，它的后缀数组是一个由 $1$ 到 $n$ 的整数组成的排列 $sa$ ，使得 $s[sa_1.. n], s[sa_2..n], \\dots, s[sa_n..n]$ 是按照字典序排序的 $s$ 的非空后缀列表。字符串 $s$ 的后缀的排名表是一个由 $1$ 到 $n$ 的整数组成的排列 $rank$ ，使得 $rank_{sa_i} = i$ 。\n\n小鸟 Kotori 有一个字符串 $s = s_1s_2\\dots s_n$ 。她想要进行 $m$ 次询问。在第 $i$ 次询问中，会给出 $s$ 的一个子串 $x = s[l_i..r_i]$ ，Kotori 想要知道 $x$ 的后缀 $s[k_i..r_i]$ 的排名。\n\n注意，$s[l..r]$ 表示 $s$ 的从第 $l$ 个位置开始到第 $r$ 个位置结束的子串（包括第 $l$ 个和第 $r$ 个位置）。", "inputFormat": "有多组测试数据。输入的第一行包含一个整数 $T$ ，表示测试数据的组数。对于每组测试数据：\n\n第一行包含两个整数 $n$ 和 $m$（$1 \\le n, m \\le 5 \\times 10^4$）—— 字符串的长度和询问的次数。\n\n第二行包含一个长度为 $n$ 且仅由小写英文字母组成的字符串 $s$ 。\n\n接下来 $m$ 行中的每一行都包含三个整数 $l_i$ 、$r_i$ 和 $k_i$（$1 \\le l_i \\le r_i \\le n, l_i \\le k_i \\le r_i$），表示一次询问。\n\n保证所有测试数据的 $n$ 的总和以及 $m$ 的总和都不会超过 $5 \\times 10^4$ 。", "outputFormat": "对于每次询问，输出一行，包含一个整数，表示答案。", "hint": "### 注意\n\n题面翻译由 Doubao 提供。", "locale": "zh-CN"}}}
{"pid": "P9624", "type": "P", "difficulty": 6, "samples": [["3\n2\n0 1\n1 0\n4\n1 1\n-3 -3\n4 -4\n-2 2\n4\n1 100\n3 100\n-100 1\n3 -100\n", "0\n8\n4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "线段树", "二分", "O2优化", "ICPC", "吉司机线段树 segment tree beats", "南京"], "title": "[ICPC 2020 Nanjing R] Certain Scientific Railgun", "background": "", "description": "Misaka Mikoto is the third-ranked Level 5 esper in $\\textit{Academy City}$ and has been nicknamed $\\textit{Railgun}$ due to her signature move. One day, several evil robots invade Academy City and Misaka is planning to terminate all of them.\n\nConsider Academy City as a 2-dimensional plane. There are $n$ robots in total and the position of the $i$-th robot is $(x_i, y_i)$. Misaka will start moving from $(0, 0)$ and her railgun ability will terminate all robots sharing the same $x$- or $y$-coordinate with her. More formally, if Misaka is now located at $(x_m, y_m)$, all robots whose $x_i = x_m$ or $y_i = y_m$ will be terminated.\n\nAs Misaka hates decimals and Euclidean geometry, she will only move from one integer point to another integer point and can only move horizontally (parallel to the $x$-axis) or vertically (parallel to the $y$-axis). As moving among the city is quite tiresome, Misaka asks you to calculate the minimum distance she has to move to terminate all robots.\n\nRecall that an integer point is a point whose $x$-coordinate and $y$-coordinate are both integers.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\leq n \\leq 10^5)$ indicating the number of robots.\n\nFor the following $n$ lines, the $i$-th line contains two integers $x_i$ and $y_i$ ($-10^9 \\le x_i, y_i \\le 10^9$) indicating the position of the $i$-th robot.\n\nIt is guaranteed that the sum of $n$ of all test cases will not exceed $10^5$.", "outputFormat": "For each test case output one line containing one integer indicating the minimum distance Misaka needs to move to terminate all robots.", "hint": "### Note\n\nFor the second sample test case, Misaka should first go to $(0, 1)$, then to $(0, 2)$, then to $(0, -3)$, then to $(0, -4)$.\n\nFor the third sample test case, Misaka should first go to $(1, 0)$, then to $(1, 1)$, then to $(3, 1)$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Nanjing R] Certain Scientific Railgun", "background": "", "description": "Misaka Mikoto is the third-ranked Level 5 esper in $\\textit{Academy City}$ and has been nicknamed $\\textit{Railgun}$ due to her signature move. One day, several evil robots invade Academy City and Misaka is planning to terminate all of them.\n\nConsider Academy City as a 2-dimensional plane. There are $n$ robots in total and the position of the $i$-th robot is $(x_i, y_i)$. Misaka will start moving from $(0, 0)$ and her railgun ability will terminate all robots sharing the same $x$- or $y$-coordinate with her. More formally, if Misaka is now located at $(x_m, y_m)$, all robots whose $x_i = x_m$ or $y_i = y_m$ will be terminated.\n\nAs Misaka hates decimals and Euclidean geometry, she will only move from one integer point to another integer point and can only move horizontally (parallel to the $x$-axis) or vertically (parallel to the $y$-axis). As moving among the city is quite tiresome, Misaka asks you to calculate the minimum distance she has to move to terminate all robots.\n\nRecall that an integer point is a point whose $x$-coordinate and $y$-coordinate are both integers.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\leq n \\leq 10^5)$ indicating the number of robots.\n\nFor the following $n$ lines, the $i$-th line contains two integers $x_i$ and $y_i$ ($-10^9 \\le x_i, y_i \\le 10^9$) indicating the position of the $i$-th robot.\n\nIt is guaranteed that the sum of $n$ of all test cases will not exceed $10^5$.", "outputFormat": "For each test case output one line containing one integer indicating the minimum distance Misaka needs to move to terminate all robots.", "hint": "### Note\n\nFor the second sample test case, Misaka should first go to $(0, 1)$, then to $(0, 2)$, then to $(0, -3)$, then to $(0, -4)$.\n\nFor the third sample test case, Misaka should first go to $(1, 0)$, then to $(1, 1)$, then to $(3, 1)$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Nanjing R] Certain Scientific Railgun", "background": "", "description": "御坂美琴是“学园都市”中排名第三的 Level 5 超能力者，由于她的标志性招式而被昵称为“Railgun”。一天，几个邪恶的机器人入侵了学园都市，御坂计划消灭它们。  \n\n将学园都市视为一个二维平面。总共有 $n$ 个机器人，第 $i$ 个机器人的位置是 $(x_i, y_i)$。御坂将从 $(0, 0)$ 开始移动，她的 Railgun 能力将消灭所有与她共享相同 $x$ 或 $y$ 坐标的机器人。更正式地说，如果御坂现在位于 $(x_m, y_m)$，则所有 $x_i = x_m$ 或 $y_i = y_m$ 的机器人将被消灭。\n\n由于御坂讨厌小数和欧几里得几何，她只会从一个整数点移动到另一个整数点，并且只能水平（平行于 $x$ 轴）或垂直（平行于 $y$ 轴）移动。由于在城市中移动相当累人，御坂请你计算她需要移动的最小距离以消灭所有机器人。\n\n请记住，整数点是指 $x$ 坐标和 $y$ 坐标都是整数的点。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含一个整数 $n$ ($1 \\leq n \\leq 10^5$)，表示机器人的数量。\n\n接下来的 $n$ 行中，第 $i$ 行包含两个整数 $x_i$ 和 $y_i$ ($-10^9 \\le x_i, y_i \\le 10^9$)，表示第 $i$ 个机器人的位置。\n\n保证所有测试用例的 $n$ 之和不超过 $10^5$。", "outputFormat": "对于每个测试用例，输出一行，包含一个整数，表示御坂需要移动的最小距离以消灭所有机器人。", "hint": "### 提示\n\n对于第二个样例测试用例，御坂应该先到 $(0, 1)$，然后到 $(0, 2)$，再到 $(0, -3)$，最后到 $(0, -4)$。\n\n对于第三个样例测试用例，御坂应该先到 $(1, 0)$，然后到 $(1, 1)$，再到 $(3, 1)$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9625", "type": "P", "difficulty": 6, "samples": [["2\n6 9\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n4 5\n4 6\n4 6\n3 4\n1 3\n2 3\n3 3\n1 2\n", "Yes\n1 2\n1 3\n1 4\n4 5\n4 6\nNo\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["图论", "2020", "Special Judge", "O2优化", "构造", "ICPC", "南京"], "title": "[ICPC 2020 Nanjing R] Degree of Spanning Tree", "background": "", "description": "Given an undirected connected graph with $n$ vertices and $m$ edges, your task is to find a spanning tree of the graph such that for every vertex in the spanning tree its degree is not larger than $\\frac{n}{2}$.\n\nRecall that the degree of a vertex is the number of edges it is connected to.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($2 \\le n \\le 10^5$, $n-1 \\le m \\le 2 \\times 10^5$) indicating the number of vertices and edges in the graph.\n\nFor the following $m$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$) indicating that there is an edge connecting vertex $u_i$ and $v_i$. Please note that there might be self loops or multiple edges.\n\nIt's guaranteed that the given graph is connected. It's also guaranteed that the sum of $n$ of all test cases will not exceed $5 \\times 10^5$, also the sum of $m$ of all test cases will not exceed $10^6$.\n", "outputFormat": "For each test case, if such spanning tree exists first output ``Yes`` in one line, then for the following $(n-1)$ lines print two integers $p_i$ and $q_i$ on the $i$-th line separated by one space, indicating that there is an edge connecting vertex $p_i$ and $q_i$ in the spanning tree. If no valid spanning tree exists just output ``No`` in one line.\n", "hint": "### Note\n\nFor the first sample test case, the maximum degree among all vertices in the spanning tree is 3 (both vertex 1 and vertex 4 has a degree of 3). As $3 \\le \\frac{6}{2}$ this is a valid answer.\n\nFor the second sample test case, it's obvious that any spanning tree will have a vertex with degree of 2, as $2 > \\frac{3}{2}$ no valid answer exists.\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Nanjing R] Degree of Spanning Tree", "background": "", "description": "Given an undirected connected graph with $n$ vertices and $m$ edges, your task is to find a spanning tree of the graph such that for every vertex in the spanning tree its degree is not larger than $\\frac{n}{2}$.\n\nRecall that the degree of a vertex is the number of edges it is connected to.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($2 \\le n \\le 10^5$, $n-1 \\le m \\le 2 \\times 10^5$) indicating the number of vertices and edges in the graph.\n\nFor the following $m$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$) indicating that there is an edge connecting vertex $u_i$ and $v_i$. Please note that there might be self loops or multiple edges.\n\nIt's guaranteed that the given graph is connected. It's also guaranteed that the sum of $n$ of all test cases will not exceed $5 \\times 10^5$, also the sum of $m$ of all test cases will not exceed $10^6$.\n", "outputFormat": "For each test case, if such spanning tree exists first output ``Yes`` in one line, then for the following $(n-1)$ lines print two integers $p_i$ and $q_i$ on the $i$-th line separated by one space, indicating that there is an edge connecting vertex $p_i$ and $q_i$ in the spanning tree. If no valid spanning tree exists just output ``No`` in one line.\n", "hint": "### Note\n\nFor the first sample test case, the maximum degree among all vertices in the spanning tree is 3 (both vertex 1 and vertex 4 has a degree of 3). As $3 \\le \\frac{6}{2}$ this is a valid answer.\n\nFor the second sample test case, it's obvious that any spanning tree will have a vertex with degree of 2, as $2 > \\frac{3}{2}$ no valid answer exists.\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Nanjing R] Degree of Spanning Tree", "background": "", "description": "给定一张 $n$ 个点 $m$ 条边的无向图，求一个生成树满足每个点的度数都不大于 $\\frac{n}{2}$。", "inputFormat": "多组数据，第一行，一个整数 $t$ 代表数据组数。\n\n对于每组数据：\n\n- 第一行两个整数 $n$, $m$，代表边数和点数；\n- 接下来 $m$ 行，输入 $u_i,v_i$ 代表一条边（可能有重边和自环）。", "outputFormat": "对于每组数据：\n\n第一行输出 `Yes` 或 `No` 代表是否可行。\n\n若可行，接下来 $n - 1$ 行输出每条生成树的边，顺序随意。", "hint": "$2 \\leq n \\leq 10^5$，$n - 1\\leq m \\leq 2\\times10^5$，$\\sum n\\leq5\\times10^5$，$\\sum m\\leq10^6$。\n\n保证图连通。", "locale": "zh-CN"}}}
{"pid": "P9626", "type": "P", "difficulty": 3, "samples": [["5\n1 1\nRURULLD\n0 5\nUUU\n0 3\nUUU\n0 2\nUUU\n0 0\nUUU\n", "LDLRUUR\nUUU\nImpossible\nImpossible\nImpossible\n"]], "limits": {"time": [1000, 1000, 1000], "memory": [262144, 262144, 262144]}, "tags": ["2020", "Special Judge", "O2优化", "ICPC", "南京"], "title": "[ICPC 2020 Nanjing R] Evil Coordinate", "background": "", "description": "A robot is standing on an infinite 2-dimensional plane. Programmed with a string $s_1s_2\\cdots s_n$ of length $n$, where $s_i \\in \\{\\text{`U'}, \\text{`D'}, \\text{`L'}, \\text{`R'}\\}$, the robot will start moving from $(0, 0)$ and will follow the instructions represented by the characters in the string.\n\nMore formally, let $(x, y)$ be the current coordinate of the robot. Starting from $(0, 0)$, the robot repeats the following procedure $n$ times. During the $i$-th time:\n\n- If $s_i = \\text{`U'}$ the robot moves from $(x, y)$ to $(x, y+1)$;\n- If $s_i = \\text{`D'}$ the robot moves from $(x, y)$ to $(x, y-1)$;\n- If $s_i = \\text{`L'}$ the robot moves from $(x, y)$ to $(x-1, y)$;\n- If $s_i = \\text{`R'}$ the robot moves from $(x, y)$ to $(x+1, y)$.-\n\nHowever, there is a mine buried under the coordinate $(m_x, m_y)$. If the robot steps onto $(m_x, m_y)$ during its movement, it will be blown up into pieces. Poor robot!\n\nYour task is to rearrange the characters in the string in any order, so that the robot will not step onto $(m_x, m_y)$.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $m_x$ and $m_y$ ($-10^9 \\le m_x, m_y \\le 10^9$) indicating the coordinate of the mine.\n\nThe second line contains a string $s_1s_2\\cdots s_n$ of length $n$ ($1 \\le n \\le 10^5$, $s_i \\in \\{\\text{`U'}, \\text{`D'}, \\text{`L'}, \\text{`R'}\\}$) indicating the string programmed into the robot.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line. If a valid answer exists print the rearranged string, otherwise print ``Impossible`` instead. If there are multiple valid answers you can print any of them.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Nanjing R] Evil Coordinate", "background": "", "description": "A robot is standing on an infinite 2-dimensional plane. Programmed with a string $s_1s_2\\cdots s_n$ of length $n$, where $s_i \\in \\{\\text{`U'}, \\text{`D'}, \\text{`L'}, \\text{`R'}\\}$, the robot will start moving from $(0, 0)$ and will follow the instructions represented by the characters in the string.\n\nMore formally, let $(x, y)$ be the current coordinate of the robot. Starting from $(0, 0)$, the robot repeats the following procedure $n$ times. During the $i$-th time:\n\n- If $s_i = \\text{`U'}$ the robot moves from $(x, y)$ to $(x, y+1)$;\n- If $s_i = \\text{`D'}$ the robot moves from $(x, y)$ to $(x, y-1)$;\n- If $s_i = \\text{`L'}$ the robot moves from $(x, y)$ to $(x-1, y)$;\n- If $s_i = \\text{`R'}$ the robot moves from $(x, y)$ to $(x+1, y)$.-\n\nHowever, there is a mine buried under the coordinate $(m_x, m_y)$. If the robot steps onto $(m_x, m_y)$ during its movement, it will be blown up into pieces. Poor robot!\n\nYour task is to rearrange the characters in the string in any order, so that the robot will not step onto $(m_x, m_y)$.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $m_x$ and $m_y$ ($-10^9 \\le m_x, m_y \\le 10^9$) indicating the coordinate of the mine.\n\nThe second line contains a string $s_1s_2\\cdots s_n$ of length $n$ ($1 \\le n \\le 10^5$, $s_i \\in \\{\\text{`U'}, \\text{`D'}, \\text{`L'}, \\text{`R'}\\}$) indicating the string programmed into the robot.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line. If a valid answer exists print the rearranged string, otherwise print ``Impossible`` instead. If there are multiple valid answers you can print any of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Nanjing R] Evil Coordinate", "background": "", "description": "一个机器人站在一个无限的二维平面上。它被编程为一个长度为 $n$ 的字符串 $s_1s_2\\cdots s_n$，其中 $s_i \\in \\{\\text{`U'}, \\text{`D'}, \\text{`L'}, \\text{`R'}\\}$，机器人将从 $(0, 0)$ 开始移动，并按照字符串中的字符指令进行移动。\n\n更正式地说，设 $(x, y)$ 为机器人的当前位置。机器人从 $(0, 0)$ 开始，重复以下过程 $n$ 次。在第 $i$ 次时：\n\n- 如果 $s_i = \\text{U}$，机器人从 $(x, y)$ 移动到 $(x, y+1)$；\n- 如果 $s_i = \\text{D}$，机器人从 $(x, y)$ 移动到 $(x, y-1)$；\n- 如果 $s_i = \\text{L}$，机器人从 $(x, y)$ 移动到 $(x-1, y)$；\n- 如果 $s_i = \\text{R}$，机器人从 $(x, y)$ 移动到 $(x+1, y)$。\n\n然而，在坐标 $(m_x, m_y)$ 下埋有一个地雷。如果机器人在移动过程中踩到 $(m_x, m_y)$，它将被炸成碎片。可怜的机器人！\n\n你的任务是重新排列字符串中的字符，使得机器人不会踩到 $(m_x, m_y)$。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含两个整数 $m_x$ 和 $m_y$ ($-10^9 \\le m_x, m_y \\le 10^9$)，表示地雷的坐标。\n\n第二行包含一个字符串 $s_1s_2\\cdots s_n$，长度为 $n$ ($1 \\le n \\le 10^5$, $s_i \\in \\{\\text{`U'}, \\text{`D'}, \\text{`L'}, \\text{`R'}\\}$)，表示编程到机器人中的字符串。\n\n保证所有测试用例的 $n$ 的总和不超过 $10^6$。", "outputFormat": "对于每个测试用例输出一行。如果存在有效答案，打印重新排列后的字符串，否则打印 \"Impossible\"。如果有多个有效答案，可以打印其中任意一个。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9627", "type": "P", "difficulty": 4, "samples": [["3\n1 1 5000\n1 1 1\n1 2 10000", "4.0000000000\n10141.5852891136\n3.0000000000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "Special Judge", "O2优化", "ICPC", "南京"], "title": "[ICPC 2020 Nanjing R] Fireworks", "background": "", "description": "Kotori is practicing making fireworks for the upcoming hanabi taikai$^1$. It takes her $n$ minutes to make a single firework, and as she is not really proficient in making fireworks, each firework only has a probability of $p \\times 10^{-4}$ to be perfect.\n\nAfter she finishes making a firework, she can just start making the next firework, or take $m$ minutes to light all the remaining fireworks finished before. If there is at least one perfect firework among the lit ones, she will be happy and go to rest. Otherwise, she will continue practicing. Can you tell her the minimum expected practicing time before she goes to rest if she takes the optimal strategy?\n\nNotice that no matter how many fireworks remain, it always takes $m$ minutes to light them all.\n\n$^1$ Hanabi taikai: Romaji of the Japanese word ``花火大會``, which means the firework... err... party?", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 10^4$) indicating the number of test cases. For each test case:\n\nThe first and only line contains three integers $n$, $m$ and $p$ ($1 \\le n, m \\le 10^9$, $1 \\le p \\le 10^4$).", "outputFormat": "For each test case, output one line containing one number indicating the minimum expected practicing time.\n\nYour answer will be considered correct if and only if the absolute or relative error does not exceed $10^{-4}$.", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ICPC 2020 Nanjing R] Fireworks", "background": "", "description": "Kotori is practicing making fireworks for the upcoming hanabi taikai$^1$. It takes her $n$ minutes to make a single firework, and as she is not really proficient in making fireworks, each firework only has a probability of $p \\times 10^{-4}$ to be perfect.\n\nAfter she finishes making a firework, she can just start making the next firework, or take $m$ minutes to light all the remaining fireworks finished before. If there is at least one perfect firework among the lit ones, she will be happy and go to rest. Otherwise, she will continue practicing. Can you tell her the minimum expected practicing time before she goes to rest if she takes the optimal strategy?\n\nNotice that no matter how many fireworks remain, it always takes $m$ minutes to light them all.\n\n$^1$ Hanabi taikai: Romaji of the Japanese word ``花火大會``, which means the firework... err... party?", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 10^4$) indicating the number of test cases. For each test case:\n\nThe first and only line contains three integers $n$, $m$ and $p$ ($1 \\le n, m \\le 10^9$, $1 \\le p \\le 10^4$).", "outputFormat": "For each test case, output one line containing one number indicating the minimum expected practicing time.\n\nYour answer will be considered correct if and only if the absolute or relative error does not exceed $10^{-4}$.", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9628", "type": "P", "difficulty": 6, "samples": [["3\n2\n.o\n..\n3\n.x.\nxoo\nox.\n2\noo\noo", "0\n870527216\n485539347"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "图论", "2020", "O2优化", "ICPC", "南京"], "title": "[ICPC 2020 Nanjing R] Go", "background": "", "description": "$\\textit{Go}$ is an adversarial game with the objective of surrounding a larger total area of the board with one's stones than the opponent's. The core idea of the game is the concept of $\\textit{liberty}$, which is an open point, or rather, an intersection of vertical and horizontal lines on the chessboard with no stones on it, bordering the group.\n\nA stone, white or black, is called $\\textit{alive}$ if it has at least one liberty directly orthogonally adjacent (up, down, left, or right), or must be in the same connected group with a stone of the same color which is alive. We say two stones of the same color are directly connected if they're orthogonally adjacent. We say two stones $s_1$ and $s_k$ of the same color are in the same connected group if there exists a sequence of stones $s_1, s_2,\\cdots, s_k$ such that for all $1 \\le i < k$, $s_{i-1}$ and $s_i$ are of the same color and are directly connected.\n\nFor example, in the left part of the below figure, neither of the two white stones is alive, as they're captured by the surrounding black stones; While in the right part, the rightmost white stone is also not alive, even if the leftmost black stone is also not alive.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zjm3icu0.png)\n\nGiven a chessboard with $n$ vertical and $n$ horizontal lines where some stones might be lying on, please calculate the number of white stones captured by the black ones (that is to say, calcaulate the number of white stones not alive). The results for the above examples are $2$ and $1$, respectively.\n\nHowever, our dear friend Kotori thinks that this problem is too simple for our clever contestants to solve, so she would like to heat things up by instead asking you to flip the color of each stone (that is to say, change a black stone to a white one, or vice versa$^1$) independently and find out the corresponding answer after each flip.\n\nBy flipping independently we mean that before flipping the color of a stone, the other stones should change back to their original color. Also note that the data in this problem is not from the real world, which means that the size of the chessboard is not necesssarily $19 \\times 19$, and the number of white and black stones can be any integer.\n\n$^1$ Vice versa: The reverse is also true. Here it can be replaced with ``change a white stone to a black one``. This is a very common phrase in modern English especially in academic writing, so please bear it in mind.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains one integer $n$ ($2\\le n \\le 10^3$) indicating the length of the board side.\n\nFor the next $n$ lines, the $i$-th line contains a string $s_{i,1},s_{i,2},\\cdots,s_{i,n}$ ($s_{i,j}$ $\\in$ $\\{\\text{`x' (ascii: 120)}$, $\\text{`o' (ascii: 111)}$, $\\text{`.' (ascii: 46)}\\}$), where $s_{i,j} = \\text{`x'}$ indicates that the intersection on the $i$-th row and the $j$-th column contains a black stone. Similarly $s_{i, j} = \\text{`o'}$ for a white stone and $s_{i,j} = \\text{`.'}$ for an empty intersection.\n\nIt's guaranteed that the sum of $n$ over all test cases does not exceed $5 \\times 10^3$.", "outputFormat": "For each test case output an integer $E$ modulo $(10^9 + 7)$ which is the answer encoded as follows:\n- Sort all the stones with their row number (from top to bottom) as the primary sort key and their column number (from left to right) as the secondary sort key;\n- $E=\\sum \\limits_{i=1}^m (10^6 + 7)^{m-i}a_i$, where $m$ is the number of stones and $a_i$ is the number of white stones not alive after flipping the color of the $i$-th stone.\n\n$\\underline{\\text{NOTE that the MODULUS and the BASE are} \\textbf{ DIFFERENT}}$. (We're begging you to notice this sentence. If this is not a pdf file I would rather it flashes and twinkles like crazy.)\n", "hint": "For the second sample test case, after flipping the stones in the order of $(1,2)$, $(2,1)$, $(2,2)$, $(2,3)$, $(3,1)$, $(3,2)$, the number of dead white stones are $1$, $0$, $1$, $2$, $0$, $0$, repectively.\n\nFor the third sample test case all stones on the chessboard, black or white, are not alive.", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Nanjing R] Go", "background": "", "description": "$\\textit{Go}$ is an adversarial game with the objective of surrounding a larger total area of the board with one's stones than the opponent's. The core idea of the game is the concept of $\\textit{liberty}$, which is an open point, or rather, an intersection of vertical and horizontal lines on the chessboard with no stones on it, bordering the group.\n\nA stone, white or black, is called $\\textit{alive}$ if it has at least one liberty directly orthogonally adjacent (up, down, left, or right), or must be in the same connected group with a stone of the same color which is alive. We say two stones of the same color are directly connected if they're orthogonally adjacent. We say two stones $s_1$ and $s_k$ of the same color are in the same connected group if there exists a sequence of stones $s_1, s_2,\\cdots, s_k$ such that for all $1 \\le i < k$, $s_{i-1}$ and $s_i$ are of the same color and are directly connected.\n\nFor example, in the left part of the below figure, neither of the two white stones is alive, as they're captured by the surrounding black stones; While in the right part, the rightmost white stone is also not alive, even if the leftmost black stone is also not alive.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zjm3icu0.png)\n\nGiven a chessboard with $n$ vertical and $n$ horizontal lines where some stones might be lying on, please calculate the number of white stones captured by the black ones (that is to say, calcaulate the number of white stones not alive). The results for the above examples are $2$ and $1$, respectively.\n\nHowever, our dear friend Kotori thinks that this problem is too simple for our clever contestants to solve, so she would like to heat things up by instead asking you to flip the color of each stone (that is to say, change a black stone to a white one, or vice versa$^1$) independently and find out the corresponding answer after each flip.\n\nBy flipping independently we mean that before flipping the color of a stone, the other stones should change back to their original color. Also note that the data in this problem is not from the real world, which means that the size of the chessboard is not necesssarily $19 \\times 19$, and the number of white and black stones can be any integer.\n\n$^1$ Vice versa: The reverse is also true. Here it can be replaced with ``change a white stone to a black one``. This is a very common phrase in modern English especially in academic writing, so please bear it in mind.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains one integer $n$ ($2\\le n \\le 10^3$) indicating the length of the board side.\n\nFor the next $n$ lines, the $i$-th line contains a string $s_{i,1},s_{i,2},\\cdots,s_{i,n}$ ($s_{i,j}$ $\\in$ $\\{\\text{`x' (ascii: 120)}$, $\\text{`o' (ascii: 111)}$, $\\text{`.' (ascii: 46)}\\}$), where $s_{i,j} = \\text{`x'}$ indicates that the intersection on the $i$-th row and the $j$-th column contains a black stone. Similarly $s_{i, j} = \\text{`o'}$ for a white stone and $s_{i,j} = \\text{`.'}$ for an empty intersection.\n\nIt's guaranteed that the sum of $n$ over all test cases does not exceed $5 \\times 10^3$.", "outputFormat": "For each test case output an integer $E$ modulo $(10^9 + 7)$ which is the answer encoded as follows:\n- Sort all the stones with their row number (from top to bottom) as the primary sort key and their column number (from left to right) as the secondary sort key;\n- $E=\\sum \\limits_{i=1}^m (10^6 + 7)^{m-i}a_i$, where $m$ is the number of stones and $a_i$ is the number of white stones not alive after flipping the color of the $i$-th stone.\n\n$\\underline{\\text{NOTE that the MODULUS and the BASE are} \\textbf{ DIFFERENT}}$. (We're begging you to notice this sentence. If this is not a pdf file I would rather it flashes and twinkles like crazy.)\n", "hint": "For the second sample test case, after flipping the stones in the order of $(1,2)$, $(2,1)$, $(2,2)$, $(2,3)$, $(3,1)$, $(3,2)$, the number of dead white stones are $1$, $0$, $1$, $2$, $0$, $0$, repectively.\n\nFor the third sample test case all stones on the chessboard, black or white, are not alive.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Nanjing R] Go", "background": "", "description": "**围棋**是一种对抗性游戏，目的是用自己的石头比对手的石头包围更大的棋盘总面积。游戏的核心理念是**自由**，即一个开放点，或者更确切地说，是棋盘上垂直线和水平线的交叉点，上面没有石头，与群体接壤。\n\n一个白色或黑色的石头，如果它至少有一个直接正交相邻的自由（上、下、左或右），或者必须与一块有生命的相同颜色的石头在同一个连接组中，那么它是有生命的，被称为**活着**。我们说，如果两块颜色相同的石头正交相邻，它们就直接相连。如果存在一系列石头 $s_1,s_2,…,s_k$ ，对于所有 $1\\leq i<k$ ， $s_{i-1}$ 和 $s_i$ 颜色相同且正交相邻，则相同颜色的两块石头 $s_1$ 和 $s_k$ 属于同一连通组。\n\n例如，在下图的左侧，两块白色的石头都没有活着，因为它们被周围的黑色石头捕获了；而在右边的部分，最右边的白色石头也没有生命，即使最左边的黑色石头也没有。\n\n![Go](https://cdn.luogu.com.cn/upload/image_hosting/zjm3icu0.png)\n\n给定一个有 $n$ 条垂直线和 $n$ 条水平线的棋盘，其中可能有一些石头躺在上面，请计算黑色石头捕获的白色石头的数量（也就是说，计算没有生命的白色石头数量）。上述例子的结果分别为 $2$ 和 $1$ 。\n\n然而，我们亲爱的朋友 Kotori 认为这个问题让我们聪明的参赛者解决太简单了，所以她想让你独立翻转每块石头的颜色（也就是说，把黑色的石头变成白色的石头，反之亦然$^1$），并在每次翻转后找到相应的答案。\n\n独立翻转的意思是，在翻转石头的颜色之前，其他石头应该变回原来的颜色。还要注意，这个问题中的数据不是来自真实世界，这意味着棋盘的大小不一定是 $19×19$ ，黑白石头的数量可以是任意整数。\n\n$^1$反之亦然：在这里，它可以用 ```把白色的石头变成黑色的石头``` 来代替。这是现代英语中非常常见的短语，尤其是在学术写作中，所以请记住。", "inputFormat": "有多个测试样例。输入的第一行包含一个整数 $T$ 表示测试样例的数量。对于每个测试样例：\n\n第一行包含一个整数 $n$ ($2\\leq n\\leq 10^3$)，表示棋盘的边长。\n\n对于接下来 $n$ 行，第 $i$ 行包含一个字符串 $s_{i,1},s_{i,2},…,s_{i,n}$ 。其中 $s_{i,j}=‘x’$ 表示第 $i$ 行第 $j$ 列有一个黑石头，$s_{i,j}=‘o’$ 表示第 $i$ 行第 $j$ 列有一个白石头，$s_{i,j}=‘.’$ 表示第 $i$ 行第 $j$ 列是空的。\n\n保证所有测试样例的 $n$ 之和不超过 $5×10^3$ 。", "outputFormat": "对于每个测试用例输出一个整数 $E\\bmod10^9+7$ 作为如下编码的答案：\n\n- 对所有石头进行排序，以其行号（从上到下）为第一关键字，以其列号（从左到右）为第二关键字；\n- $E=\\sum\\limits_{i=1}^m(10^6+7)^{m-i}a_i$ ，其中 $m$ 是石头的数量， $a_i$ 是翻转第 $i$ 次颜色后没有生命的白色石头的数量。\n\n$\\underline{\\textbf{注意}\\text{：\\textsf{模数}和\\textsf{基数}是}\\textbf{不同}{的}}$ 。（我们恳求你注意这句话。如果这不是 pdf 文件，我宁愿它像疯了一样闪烁。）", "hint": "对于第二个测试样例，按照 $(1,2),(2,1),(2,2),(2,3),(3,1),(3,2)$ 的顺序翻转石头后，死亡的白色石头数量分别为 $1,0,1,2,0,0$ 。\n\n对于第三个测试样例，棋盘上的所有石头，无论是黑色还是白色，都不是活着的。", "locale": "zh-CN"}}}
{"pid": "P9629", "type": "P", "difficulty": 5, "samples": [["3\n1 4\n2 2\n3 3", "0\n15\n16485"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144]}, "tags": ["2020", "O2优化", "ICPC", "南京"], "title": "[ICPC 2020 Nanjing R] Harmonious Rectangle", "background": "", "description": "A vertex-colored rectangle is a rectangle whose four vertices are all painted with colors. For a vertex-colored rectangle, it's harmonious if and only if we can find two adjacent vertices with the same color, while the other two vertices also have the same color with each other.\n\nFor example, $\\begin{bmatrix} 1 & 0\\\\ 1 & 0 \\end{bmatrix}$, $\\begin{bmatrix} 0 & 0\\\\ 1 & 1 \\end{bmatrix}$ and $\\begin{bmatrix} 1 & 1\\\\ 1 & 1 \\end{bmatrix}$ are harmonious, while $\\begin{bmatrix} 1 & 0\\\\ 0 & 1 \\end{bmatrix}$ is not (same number for same color, and different numbers for different colors).\n\nFor each point in $\\{(x,y) | 1 \\le x \\le n, 1 \\le y \\le m, x,y \\in \\mathbb{Z}\\}$, where $\\mathbb{Z}$ is the set of all integers, Kotori wants to paint it into one of the three colors: red, blue, yellow. She wonders the number of different ways to color them so that there exists at least one harmonious rectangle formed by the points, whose edges are all parallel to the $x$- or $y$-axis. That is to say, there exists $1 \\le x_1 < x_2 \\le n$ and $1 \\le y_1 < y_2 \\le m$ such that\n\n$$\\begin{cases}\n\\text{color}(x_1, y_1) = \\text{color}(x_1, y_2)\\\\\n\\text{color}(x_2, y_1) = \\text{color}(x_2, y_2)\\\\\n\\end{cases}\n$$ \nor\n$$\\begin{cases}\n\\text{color}(x_1, y_1) = \\text{color}(x_2, y_1)\\\\\n\\text{color}(x_1, y_2) = \\text{color}(x_2, y_2)\\\\\n\\end{cases}\n$$\n\nwhere $\\text{color}(x, y)$ is the color of point $(x, y)$.\n\nTwo coloring plans are considered different if there exists a point having different colors in the two coloring plans.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 10^4$) indicating the number of test cases. For each test case:\n\nThe first and only line contains three integers $n$, $m$($1 \\le n, m \\le 2 \\times 10^3$).", "outputFormat": "For each test case output one line containing one integer indicating the number of different ways of coloring modulo $(10^9 + 7)$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Nanjing R] Harmonious Rectangle", "background": "", "description": "A vertex-colored rectangle is a rectangle whose four vertices are all painted with colors. For a vertex-colored rectangle, it's harmonious if and only if we can find two adjacent vertices with the same color, while the other two vertices also have the same color with each other.\n\nFor example, $\\begin{bmatrix} 1 & 0\\\\ 1 & 0 \\end{bmatrix}$, $\\begin{bmatrix} 0 & 0\\\\ 1 & 1 \\end{bmatrix}$ and $\\begin{bmatrix} 1 & 1\\\\ 1 & 1 \\end{bmatrix}$ are harmonious, while $\\begin{bmatrix} 1 & 0\\\\ 0 & 1 \\end{bmatrix}$ is not (same number for same color, and different numbers for different colors).\n\nFor each point in $\\{(x,y) | 1 \\le x \\le n, 1 \\le y \\le m, x,y \\in \\mathbb{Z}\\}$, where $\\mathbb{Z}$ is the set of all integers, Kotori wants to paint it into one of the three colors: red, blue, yellow. She wonders the number of different ways to color them so that there exists at least one harmonious rectangle formed by the points, whose edges are all parallel to the $x$- or $y$-axis. That is to say, there exists $1 \\le x_1 < x_2 \\le n$ and $1 \\le y_1 < y_2 \\le m$ such that\n\n$$\\begin{cases}\n\\text{color}(x_1, y_1) = \\text{color}(x_1, y_2)\\\\\n\\text{color}(x_2, y_1) = \\text{color}(x_2, y_2)\\\\\n\\end{cases}\n$$ \nor\n$$\\begin{cases}\n\\text{color}(x_1, y_1) = \\text{color}(x_2, y_1)\\\\\n\\text{color}(x_1, y_2) = \\text{color}(x_2, y_2)\\\\\n\\end{cases}\n$$\n\nwhere $\\text{color}(x, y)$ is the color of point $(x, y)$.\n\nTwo coloring plans are considered different if there exists a point having different colors in the two coloring plans.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 10^4$) indicating the number of test cases. For each test case:\n\nThe first and only line contains three integers $n$, $m$($1 \\le n, m \\le 2 \\times 10^3$).", "outputFormat": "For each test case output one line containing one integer indicating the number of different ways of coloring modulo $(10^9 + 7)$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Nanjing R] Harmonious Rectangle", "background": "", "description": "一个顶点着色的矩形是指四个顶点都被涂上颜色的矩形。对于一个顶点着色的矩形来说，如果我们可以找到两个相邻顶点的颜色相同，而另外两个顶点也互相颜色相同，则称这个矩形是和谐的。\n\n例如，矩阵 \n$\\begin{bmatrix} 1 & 0\\\\ 1 & 0 \\end{bmatrix}$，$\\begin{bmatrix} 0 & 0\\\\ 1 & 1 \\end{bmatrix}$ 和 $\\begin{bmatrix} 1 & 1\\\\ 1 & 1 \\end{bmatrix}$ 都是和谐的，而 $\\begin{bmatrix} 1 & 0\\\\ 0 & 1 \\end{bmatrix}$ 不是（相同的颜色有相同的数字，不同的颜色有不同的数字）。\n\n对于集合中的每个点 $\\{(x,y) |\t1 \\le x \\le n, 1 \\le y \\le m, x,y \\in \\mathbb{Z}\\}$，其中 $\\mathbb{Z}$ 是所有整数的集合，Kotori 想将其涂成三种颜色之一：红色、蓝色或黄色。她想知道有多少种不同的着色方案，使得至少存在一个由这些点形成的边都平行于 $x$ 或 $y$ 轴的和谐矩形。也就是说，存在 $1 \\le x_1 < x_2 \\le n$ 和 $1 \\le y_1 < y_2 \\le m $，满足以下条件之一：\n\n$\\begin{cases} \\text{color}(x_1, y_1) = \\text{color}(x_1, y_2)\\\\ \\text{color}(x_2, y_1) = \\text{color}(x_2, y_2)\\\\ \\end{cases}$\n\n或者\n\n$\\begin{cases} \\text{color}(x_1, y_1) = \\text{color}(x_2, y_1)\\\\ \\text{color}(x_1, y_2) = \\text{color}(x_2, y_2)\\\\ \\end{cases}$\n\n其中 $\\text{color}(x, y)$ 表示点 $(x, y)$ 的颜色。\n\n如果两个着色计划中存在一个点在两个着色计划中颜色不同，那么认为这两个着色计划是不同的。", "inputFormat": "输入包含多个测试用例。第一行输入一个整数 $T$ $(1 \\le T \\le 10^4)$，表示测试用例的数量。对于每个测试用例：\n\n第一行输入三个整数 $n, m$ $(1 \\le n, m \\le 2 \\times 10^3)$，表示边界的大小。", "outputFormat": "对于每个测试用例，输出一行，包含一个整数，表示着色的不同方案数量模 $(10^9 + 7)$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9630", "type": "P", "difficulty": 6, "samples": [["3 2 1\n-2 0 1 0\n-1 4 2 4\n0 1 0 3", "1.000000000000000"], ["2 1 2\n-1 0 1 0\n1 1 0 1", "-1"], ["2 3 7\n-3 0 2 2\n3 1 -2 17", "1.866666666666666"], ["1 100 1\n-100 0 99 0\n", "0.000000000000000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["计算几何", "2020", "Special Judge", "O2优化", "ICPC", "南京"], "title": "[ICPC 2020 Nanjing R] Interested in Skiing", "background": "", "description": "Kotori is interested in skiing. The skiing field is an infinite strip going along $y$-axis on the 2-dimensional plane where all points $(x, y)$ in the field satisfies $-m \\le x \\le m$. When skiing, Kotori cannot move out of the field, which means that the absolute value of his $x$-coordinate should always be no more than $m$. There are also $n$ segments on the ground which are the obstacles and Kotori cannot move across the obstacles either.\n\nKotori will start skiing from $(0, -10^{10^{10^{10^{10}}}})$ (you can regard this $y$-coordinate as a negative infinity) and moves towards the positive direction of the $y$-axis. Her vertical (parallel to the $y$-axis) speed is always $v_y$ which cannot be changed, however she can control her horizontal (parallel to the $x$-axis) speed in the interval of $[-v_x, v_x]$. The time that Kotori changes her velocity can be neglected.\n\nYour task is to help Kotori calculate the minimum value of $v_x^*$ that once $v_x>v_x^*$ she can safely ski through the skiing field without running into the obstacles.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains three positive integers $n$, $m$ and $v_y$ ($1 \\le n \\le 100$, $1 \\le m \\le 10^4$, $1 \\le v_y \\le 10$), indicating the number of obstacles, the half width of the skiing field and the vertical speed.\n\nFor the following $n$ lines, the $i$-th line contains four integers $x_1$, $y_1$, $x_2$ and $y_2$ ($-m \\le x_1, x_2 \\le m$, $-10^4 \\le y_1, y_2 \\le 10^4$, $x_1 \\ne x_2$ or $y_1 \\ne y_2$) indicating the $i$-th obstacle which is a segment connecting point $(x_1, y_1)$ and $(x_2, y_2)$, both inclusive (that is to say, these two points are also parts of the obstacle and cannot be touched). It's guaranteed that no two obstacles intersect with each other.", "outputFormat": "Output one line containing one number indicating the minimum value of $v_x^*$. If it is impossible for Kotori to pass through the skiing field, output ``-1`` (without quotes) instead.\n\nYour answer will be considered correct if and only if its absolute or relative error does not exceed $10^{-6}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Nanjing R] Interested in Skiing", "background": "", "description": "Kotori is interested in skiing. The skiing field is an infinite strip going along $y$-axis on the 2-dimensional plane where all points $(x, y)$ in the field satisfies $-m \\le x \\le m$. When skiing, Kotori cannot move out of the field, which means that the absolute value of his $x$-coordinate should always be no more than $m$. There are also $n$ segments on the ground which are the obstacles and Kotori cannot move across the obstacles either.\n\nKotori will start skiing from $(0, -10^{10^{10^{10^{10}}}})$ (you can regard this $y$-coordinate as a negative infinity) and moves towards the positive direction of the $y$-axis. Her vertical (parallel to the $y$-axis) speed is always $v_y$ which cannot be changed, however she can control her horizontal (parallel to the $x$-axis) speed in the interval of $[-v_x, v_x]$. The time that Kotori changes her velocity can be neglected.\n\nYour task is to help Kotori calculate the minimum value of $v_x^*$ that once $v_x>v_x^*$ she can safely ski through the skiing field without running into the obstacles.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains three positive integers $n$, $m$ and $v_y$ ($1 \\le n \\le 100$, $1 \\le m \\le 10^4$, $1 \\le v_y \\le 10$), indicating the number of obstacles, the half width of the skiing field and the vertical speed.\n\nFor the following $n$ lines, the $i$-th line contains four integers $x_1$, $y_1$, $x_2$ and $y_2$ ($-m \\le x_1, x_2 \\le m$, $-10^4 \\le y_1, y_2 \\le 10^4$, $x_1 \\ne x_2$ or $y_1 \\ne y_2$) indicating the $i$-th obstacle which is a segment connecting point $(x_1, y_1)$ and $(x_2, y_2)$, both inclusive (that is to say, these two points are also parts of the obstacle and cannot be touched). It's guaranteed that no two obstacles intersect with each other.", "outputFormat": "Output one line containing one number indicating the minimum value of $v_x^*$. If it is impossible for Kotori to pass through the skiing field, output ``-1`` (without quotes) instead.\n\nYour answer will be considered correct if and only if its absolute or relative error does not exceed $10^{-6}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Nanjing R] Interested in Skiing", "background": null, "description": "Kotori 对滑雪很感兴趣。滑雪场是在二维平面上沿着 $y$ 轴无限延伸的直线，其中场中的所有点 $(x,y)$ 满足 $-m\\le x\\le m$。滑雪时，Kotori 不能离开场地，这意味着他的 $x$ 坐标的绝对值应该始终不超过 $m$。地面上也有 $n$ 个路段是障碍，Kotori 无法越过障碍。\n\nKotori 将从 $(0, -10^{10^{10^{10^{10}}}})$  开始滑雪（你可以将此 $y$ 坐标视为负无穷大），并朝着 $y$ 轴的正方向移动。她的垂直（平行于 $y$ 轴）速度始终是 $v_y$，此值不变，但是她可以在 $[-v_x, v_x]$ 的间隔内控制她的水平（平行于 $x$ 轴的）速度。Kotori 改变速度的时间可以忽略不计。\n\n你的任务是帮助 Kotori 计算 $v_x^*$ 的最小值，即一旦 $v_x>v_x^*$，她就可以安全地穿过滑雪场而不会遇到障碍物。", "inputFormat": "每个测试文件中只有一个测试用例。\n\n输入的第一行包含三个正整数 $n, m$ 和 $v_y$（$1\\le n\\le 100$，$1\\le m\\le 10^4$，$1\\le v_y\\le 10$），分别表示障碍物的数量、滑雪场的半宽和垂直速度。\n\n对于下面的 $n$ 行，第 $i$ 行包含四个整数 $x_1, y_1, x_2$ 和 $y_2$（$-m\\le x_1, x_2\\le m$，$-10^4\\le y_1, y_2\\le 10^4$，$x_1\\ne x_2$ 或 $y_1\\ne y_2$），这四个整数表示第 $i$ 个障碍物，该障碍物是连接点 $(x_1, y_1)$ 和 $(x_2, y_2)$ 的线段，两者都包括在内（也就是说，这两个点也是障碍物的一部分，不能触摸）。保证没有两个障碍物相互交叉。", "outputFormat": "输出一行，其中包含一个数字，表示 $v_x^*$ 的最小值。如果 Kotori 无法通过滑雪场，请输出 `-1`。\n\n当且仅当其绝对或相对误差不超过 $10^{-6}$ 时，您的答案才会被认为是正确的。\n\n------------\n\n翻译来自 [fire_wolf](https://www.luogu.com.cn/user/690669)。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P9631", "type": "P", "difficulty": 6, "samples": [["5 4\n1 2 1 4 1\n2 1 3 1\n1 2 4 3\n2 2 4 4\n2 1 4 4", "1\n0\n3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "线段树", "O2优化", "ICPC", "吉司机线段树 segment tree beats", "南京"], "title": "[ICPC 2020 Nanjing R] Just Another Game of Stones", "background": "", "description": "Kotori and Umi are playing games of stones, which is hosted by Honoka. The rule is the same as the classic one: There are some piles of stones and the players take turns to remove any positive number of stones from one pile. The one who can't make a legal move loses the game.\n\nThis time however, things will be a little different. As the host, Honoka will prepare the games from $n$ candidate piles of stones, where the $i$-th pile initially has $a_i$ stones. Honoka will perform $q$ operations of the following two types:\n\n- Given three integers $l$, $r$ and $x$, for all $l \\le i \\le r$ change the number of stones in the $i$-th candidate pile to $\\max(b_i, x)$, where $b_i$ is the current number of stones in the $i$-th candidate pile.\n- Given three integers $l$, $r$ and $x$, start a game of stones consisting of $(r-l+2)$ piles where the $i$-th pile contains $b_{l-1+i}$ stones for all $1 \\le i < (r-l+2)$, and the $(r-l+2)$-th pile contains $x$ stones. Note that this operation is only querying for answer and will not affect the state of the $n$ candidate piles of stones.\n\nKotori is always the first to move. As a big fan of Kotori, you would like to know, for each game of stones, the number of ways Kotori can play in the first step to ensure her victory if both players use the best strategy. We consider two ways different if Kotori is taking stones from different piles, or from the same pile but is taking different number of stones.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains two integers $n$ and $q$ ($1 \\le n, q \\le 2 \\times 10^5$) indicating the number of candidate piles and the number of operations.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($0 \\le a_i \\le 2^{30}-1$) where $a_i$ indicates the initial number of stones in the $i$-th pile.\n\nFor the following $q$ lines, the $i$-th line contains four integers $op_i$, $l_i$, $r_i$ and $x_i$ ($op_i \\in \\{1, 2\\}$, $1 \\le l_i \\le r_i \\le n$, $0 \\le x_i \\le 2^{30}-1$) indicating the $i$-th operation, where $op_i$ is the type of operation and the others are the parameters of the operation. Operations are given in the order they're performed.", "outputFormat": "For each operation of the second type output one line containing one integer indicating the answer.\n", "hint": "For the first operation the players will play a game of stones consisting of $1$, $2$, $1$ and $1$ stone(s) in each pile respectively. The only winning play for Kotori is reduce the pile with $2$ stones to $1$ stone.\n\nAfter the second operation, number of stones in the candidate piles changes to $1$, $3$, $3$, $4$ and $1$ respectively.\n\nFor the fourth operation the players will play a game of stones consisting of $1$, $3$, $3$, $4$ and $4$ stone(s) in each pile respectively. The winning plays for Kotori is to reduce the pile with $1$ stone to $0$ stone, or to reduce any pile with $3$ stones to $2$ stones.", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Nanjing R] Just Another Game of Stones", "background": "", "description": "Kotori and Umi are playing games of stones, which is hosted by Honoka. The rule is the same as the classic one: There are some piles of stones and the players take turns to remove any positive number of stones from one pile. The one who can't make a legal move loses the game.\n\nThis time however, things will be a little different. As the host, Honoka will prepare the games from $n$ candidate piles of stones, where the $i$-th pile initially has $a_i$ stones. Honoka will perform $q$ operations of the following two types:\n\n- Given three integers $l$, $r$ and $x$, for all $l \\le i \\le r$ change the number of stones in the $i$-th candidate pile to $\\max(b_i, x)$, where $b_i$ is the current number of stones in the $i$-th candidate pile.\n- Given three integers $l$, $r$ and $x$, start a game of stones consisting of $(r-l+2)$ piles where the $i$-th pile contains $b_{l-1+i}$ stones for all $1 \\le i < (r-l+2)$, and the $(r-l+2)$-th pile contains $x$ stones. Note that this operation is only querying for answer and will not affect the state of the $n$ candidate piles of stones.\n\nKotori is always the first to move. As a big fan of Kotori, you would like to know, for each game of stones, the number of ways Kotori can play in the first step to ensure her victory if both players use the best strategy. We consider two ways different if Kotori is taking stones from different piles, or from the same pile but is taking different number of stones.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains two integers $n$ and $q$ ($1 \\le n, q \\le 2 \\times 10^5$) indicating the number of candidate piles and the number of operations.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($0 \\le a_i \\le 2^{30}-1$) where $a_i$ indicates the initial number of stones in the $i$-th pile.\n\nFor the following $q$ lines, the $i$-th line contains four integers $op_i$, $l_i$, $r_i$ and $x_i$ ($op_i \\in \\{1, 2\\}$, $1 \\le l_i \\le r_i \\le n$, $0 \\le x_i \\le 2^{30}-1$) indicating the $i$-th operation, where $op_i$ is the type of operation and the others are the parameters of the operation. Operations are given in the order they're performed.", "outputFormat": "For each operation of the second type output one line containing one integer indicating the answer.\n", "hint": "For the first operation the players will play a game of stones consisting of $1$, $2$, $1$ and $1$ stone(s) in each pile respectively. The only winning play for Kotori is reduce the pile with $2$ stones to $1$ stone.\n\nAfter the second operation, number of stones in the candidate piles changes to $1$, $3$, $3$, $4$ and $1$ respectively.\n\nFor the fourth operation the players will play a game of stones consisting of $1$, $3$, $3$, $4$ and $4$ stone(s) in each pile respectively. The winning plays for Kotori is to reduce the pile with $1$ stone to $0$ stone, or to reduce any pile with $3$ stones to $2$ stones.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Nanjing R] Just Another Game of Stones", "background": "", "description": "Kotori 和 Umi 正在玩由 Honoka 主持的石子游戏。规则与经典游戏相同：有若干堆石子，玩家轮流从一堆中移走任意数量的石子。不能进行合法移动的玩家输掉游戏。\n\n然而这次情况会有些不同。作为主持人，Honoka 将从 $n$ 个候选石子堆中准备游戏，其中第 $i$ 堆最初有 $a_i$ 个石子。Honoka 将执行 $q$ 次以下两种类型的操作：\n\n- 给定三个整数 $l$、$r$ 和 $x$，对于所有 $l \\le i \\le r$，将第 $i$ 个候选石子堆中的石子数量更改为 $\\max(b_i, x)$，其中 $b_i$ 是当前第 $i$ 个候选石子堆中的石子数量。\n- 给定三个整数 $l$、$r$ 和 $x$，开始一个由 $(r-l+2)$ 堆组成的石子游戏，其中第 $i$ 堆包含 $b_{l-1+i}$ 个石子，$1 \\le i < (r-l+2)$，并且第 $(r-l+2)$ 堆包含 $x$ 个石子。注意，此操作仅查询答案，不会影响 $n$ 个候选石子堆的状态。\n\nKotori 总是第一个行动。作为 Kotori 的忠实粉丝，你想知道对于每个石子游戏，如果双方都使用最佳策略，Kotori 在第一步中确保胜利的方法数。我们认为两种方法不同，如果 Kotori 从不同的堆中取石子，或者从同一堆中取不同数量的石子。", "inputFormat": "每个测试文件中只有一个测试用例。\n\n输入的第一行包含两个整数 $n$ 和 $q$ ($1 \\le n, q \\le 2 \\times 10^5$)，表示候选石子堆的数量和操作的数量。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\cdots, a_n$ ($0 \\le a_i \\le 2^{30}-1$)，其中 $a_i$ 表示第 $i$ 堆的初始石子数量。\n\n接下来的 $q$ 行中，第 $i$ 行包含四个整数 $op_i$, $l_i$, $r_i$ 和 $x_i$ ($op_i \\in \\{1, 2\\}$, $1 \\le l_i \\le r_i \\le n$, $0 \\le x_i \\le 2^{30}-1$)，表示第 $i$ 个操作，其中 $op_i$ 是操作类型，其他是操作的参数。操作按执行顺序给出。", "outputFormat": "对于每个第二种类型的操作，输出一行包含一个整数表示答案。", "hint": "对于第一个操作，玩家将进行一个由 $1$、$2$、$1$ 和 $1$ 个石子组成的石子游戏。Kotori 唯一的获胜方式是将有 $2$ 个石子的堆减少到 $1$ 个石子。\n\n在第二个操作之后，候选石子堆中的石子数量变为 $1$、$3$、$3$、$4$ 和 $1$。\n\n对于第四个操作，玩家将进行一个由 $1$、$3$、$3$、$4$ 和 $4$ 个石子组成的石子游戏。Kotori 的获胜方式是将有 $1$ 个石子的堆减少到 $0$ 个石子，或者将任何有 $3$ 个石子的堆减少到 $2$ 个石子。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9632", "type": "P", "difficulty": 2, "samples": [["5 3", "1 4 5 2 3"], ["1 0", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "Special Judge", "O2优化", "ICPC", "南京"], "title": "[ICPC 2020 Nanjing R] K Co-prime Permutation", "background": "", "description": "Kotori is very good at math (really?) and she loves playing with permutations and primes.\n\nOne day, she thinks of a special kind of permutation named $\\textit{k co-prime permutation}$. A permutation $p_1,p_2,\\cdots,p_n$ of $n$ is called a $k$ co-prime permutation of $n$ if there exists exactly $k$ integers $i$ such that $1 \\le i \\le n$ and $\\text{gcd}(p_i,i)=1$, where $\\text{gcd}(x,y)$ indicates the greatest common divisor of $x$ and $y$.\n\nGiven $n$ and $k$, please help Kotori construct a $k$ co-prime permutation of $n$ or just report that there is no such permutation.\n\nRecall that a permutation of $n$ is a sequence of length $n$ containing all integers from $1$ to $n$.", "inputFormat": "There is only one test case in each test file.\n\nThe first and only line contains two integers $n$ and $k$ ($1 \\le n \\le 10^6$, $0 \\le k \\le n$).", "outputFormat": "Output one line containing $n$ integers $p_1, p_2, \\cdots, p_n$ separated by one space, indicating the permutation satisfying the given constraints. If no such permutation exists output ``-1`` (without quotes) instead. If there are multiple valid answers you can print any of them.\n\nPlease, DO NOT output extra spaces at the end of each line, otherwise your answer may be considered incorrect!", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Nanjing R] K Co-prime Permutation", "background": "", "description": "Kotori is very good at math (really?) and she loves playing with permutations and primes.\n\nOne day, she thinks of a special kind of permutation named $\\textit{k co-prime permutation}$. A permutation $p_1,p_2,\\cdots,p_n$ of $n$ is called a $k$ co-prime permutation of $n$ if there exists exactly $k$ integers $i$ such that $1 \\le i \\le n$ and $\\text{gcd}(p_i,i)=1$, where $\\text{gcd}(x,y)$ indicates the greatest common divisor of $x$ and $y$.\n\nGiven $n$ and $k$, please help Kotori construct a $k$ co-prime permutation of $n$ or just report that there is no such permutation.\n\nRecall that a permutation of $n$ is a sequence of length $n$ containing all integers from $1$ to $n$.", "inputFormat": "There is only one test case in each test file.\n\nThe first and only line contains two integers $n$ and $k$ ($1 \\le n \\le 10^6$, $0 \\le k \\le n$).", "outputFormat": "Output one line containing $n$ integers $p_1, p_2, \\cdots, p_n$ separated by one space, indicating the permutation satisfying the given constraints. If no such permutation exists output ``-1`` (without quotes) instead. If there are multiple valid answers you can print any of them.\n\nPlease, DO NOT output extra spaces at the end of each line, otherwise your answer may be considered incorrect!", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Nanjing R] K Co-prime Permutation", "background": "", "description": "给定两个整数 $n$ 和 $k$，构造一个 $1 \\sim n$ 的排列 $p_1,p_2,\\cdots,p_n$，使得存在 $k$ 个整数 $i$ 满足 $1 \\le i \\le n$ 且 $\\text{gcd}(p_i,i)=1$。\n\n$\\text{gcd}(x,y)$ 表示 $x$ 和 $y$ 的最大公约数。", "inputFormat": "只有一组测试数据。\n\n第一行输入两个整数 $n$ 和 $k$ $(1 \\le n \\le 10^6, 0 \\le k \\le n)$。", "outputFormat": "输出一行 $n$ 个整数 $p_1, p_2, \\cdots, p_n$，用空格分隔，表示一个满足给定的约束的排列。如果没有存在的排列则输出 ``-1``。如果有多个有效的答案，输出任意一个均可。\n\n请不要在行末输出多余的空格，否则你的答案可能会被认为是错误的。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n5 3\n```\n\n#### 样例输出 #1\n\n```\n1 4 5 2 3\n```\n\n### 样例 #2\n\n#### 样例输入 #2\n\n```\n1 0\n```\n\n#### 样例输出 #2\n\n```\n-1\n```", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9633", "type": "P", "difficulty": 3, "samples": [["3\n2 2\n2 3\n1 4\n6 5\n2 5 3 7 1 7\n3 4 3 1 10\n1 1\n7\n7", "2\n3\nImpossible"]], "limits": {"time": [1000, 1000], "memory": [262144, 262144]}, "tags": ["2020", "O2优化", "ICPC", "南京"], "title": "[ICPC 2020 Nanjing R] Let's Play Curling", "background": "", "description": "Curling is a sport in which players slide stones on a sheet of ice toward a target area. The team with the nearest stone to the center of the target area wins the game.\n\nTwo teams, Red and Blue, are competing on the number axis. After the game there are $(n+m)$ stones remaining on the axis, $n$ of them for the Red team and the other $m$ of them for the Blue. The $i$-th stone of the Red team is positioned at $a_i$ and the $i$-th stone of the Blue team is positioned at $b_i$.\n\nLet $c$ be the position of the center of the target area. From the description above we know that if there exists some $i$ such that $1 \\le i \\le n$ and for all $1 \\le j \\le m$ we have $|c - a_i| < |c - b_j|$ then Red wins the game. What's more, Red is declared to win $p$ points if the number of $i$ satisfying the constraint is exactly $p$.\n\nGiven the positions of the stones for team Red and Blue, your task is to determine the position $c$ of the center of the target area so that Red wins the game and scores as much as possible. Note that $c$ can be any real number, not necessarily an integer.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n, m \\le 10^5$) indicating the number of stones for Red and the number of stones for Blue.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le 10^9$) indicating the positions of the stones for Red.\n\nThe third line contains $m$ integers $b_1, b_2, \\cdots, b_m$ ($1 \\le b_i \\le 10^9$) indicating the positions of the stones for Blue.\n\nIt's guaranteed that neither the sum of $n$ nor the sum of $m$ will exceed $5 \\times 10^5$.", "outputFormat": "For each test case output one line. If there exists some $c$ so that Red wins and scores as much as possible, output one integer indicating the maximum possible $\\textbf{score}$ of Red (NOT $c$). Otherwise output ``Impossible`` (without quotes) instead.", "hint": "For the first sample test case we can assign $c = 2.5$ so that the stones at position 2 and 3 for Red will score.\n\nFor the second sample test case we can assign $c = 7$ so that the stones at position 5 and 7 for Red will score.", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Nanjing R] Let's Play Curling", "background": "", "description": "Curling is a sport in which players slide stones on a sheet of ice toward a target area. The team with the nearest stone to the center of the target area wins the game.\n\nTwo teams, Red and Blue, are competing on the number axis. After the game there are $(n+m)$ stones remaining on the axis, $n$ of them for the Red team and the other $m$ of them for the Blue. The $i$-th stone of the Red team is positioned at $a_i$ and the $i$-th stone of the Blue team is positioned at $b_i$.\n\nLet $c$ be the position of the center of the target area. From the description above we know that if there exists some $i$ such that $1 \\le i \\le n$ and for all $1 \\le j \\le m$ we have $|c - a_i| < |c - b_j|$ then Red wins the game. What's more, Red is declared to win $p$ points if the number of $i$ satisfying the constraint is exactly $p$.\n\nGiven the positions of the stones for team Red and Blue, your task is to determine the position $c$ of the center of the target area so that Red wins the game and scores as much as possible. Note that $c$ can be any real number, not necessarily an integer.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n, m \\le 10^5$) indicating the number of stones for Red and the number of stones for Blue.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le 10^9$) indicating the positions of the stones for Red.\n\nThe third line contains $m$ integers $b_1, b_2, \\cdots, b_m$ ($1 \\le b_i \\le 10^9$) indicating the positions of the stones for Blue.\n\nIt's guaranteed that neither the sum of $n$ nor the sum of $m$ will exceed $5 \\times 10^5$.", "outputFormat": "For each test case output one line. If there exists some $c$ so that Red wins and scores as much as possible, output one integer indicating the maximum possible $\\textbf{score}$ of Red (NOT $c$). Otherwise output ``Impossible`` (without quotes) instead.", "hint": "For the first sample test case we can assign $c = 2.5$ so that the stones at position 2 and 3 for Red will score.\n\nFor the second sample test case we can assign $c = 7$ so that the stones at position 5 and 7 for Red will score.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Nanjing R] Let's Play Curling", "background": null, "description": "# [ICPC2020 Nanjing R] Let's Play Curling\n\n\n红队和蓝队在冰面上向目标区域滑动冰壶，距离目标区域中心最近的队伍获胜。\n\n两支队伍在一条直线上竞争。比赛结束后，有   $(n+m)$ 个冰壶在直线上, $n$ 个是红队的，剩下 $m$ 个是蓝队的。 红队的第 $i$ 个冰壶被放在 $a_i$ ，蓝队的第 $i$ 个冰壶被放在 $b_i$ 。\n\n设 $c$ 是中心。如果存在一些 $i$ 使得 $1 \\le i \\le n$ 并且对于所有 $1 \\le j \\le m$ 都有 $|c - a_i| < |c - b_j|$ 红队就赢得比赛。另外，如果满足条件的 $i$ 的数目是 $p$ ，则认为红队赢得 $p$ 分。\n\n给你红蓝两队的冰壶的位置，请你确定中心 $c$ 的值，使红队得分最多。注意， $c$ 是任意实数，不一定是整数。", "inputFormat": "有很多测试样例。第一行输入一个整数 $T$ ，表示样例数量。对于每个测试样列：\n\n第一行包括两个整数 $n$ 和 $m$ ($1 \\le n, m \\le 10^5$) 分别表示红队和蓝队的冰壶数量。\n\n第二行包括 $n$ 个整数 $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le 10^9$) 表示红队的冰壶的位置。\n\n第三行包括 $m$ 个整数 $b_1, b_2, \\cdots, b_m$ ($1 \\le b_i \\le 10^9$)表示蓝队的冰壶的位置。\n\n数据保证 $n$ 的总和以及 $m$ 的总和都不会超过 $5 \\times 10^5$ 。", "outputFormat": "每一个测试样列输出一行。如果存在 $c$ 使得红队获胜且得分最多, 输出一个整数表示红队最大 $\\textbf{ 得分 }$ (不是 $c$) 。否则输出 ``Impossible`` ( 不带引号 ) 。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n3\n2 2\n2 3\n1 4\n6 5\n2 5 3 7 1 7\n3 4 3 1 10\n1 1\n7\n7\n```\n\n### 样例输出 #1\n\n```\n2\n3\nImpossible\n```", "hint": "对于第一个样例，当 $c = 2.5$ 时，红队的位于 2 和 3 的冰壶可以得分。\n\n对于第二个样例，当 $c = 7$ 时，红队的位于 5 和 7 的冰壶可以得分。", "locale": "zh-CN"}}}
{"pid": "P9634", "type": "P", "difficulty": 5, "samples": [["3\n5\n1 2 3 4\n1 2 3 4 5\n9\n1 2 3 4 3 4 6 6\n8 4 9 4 4 5 2 4 1\n12\n1 2 2 4 5 3 4 3 8 10 11\n9 1 3 5 10 10 7 3 7 9 4 9", "29 16 9 4 1 0\n74 47 35 25 15 11 7 3 1 0\n145 115 93 73 55 42 32 22 14 8 4 1 0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2020", "Special Judge", "O2优化", "树形 DP", "ICPC", "南京"], "title": "[ICPC 2020 Nanjing R] Monster Hunter", "background": "", "description": "There is a rooted tree with $n$ vertices and the root vertex is $1$. In each vertex, there is a monster. The hit points of the monster in the $i$-th vertex is $hp_i$.\n\nKotori would like to kill all the monsters. The monster in the $i$-th vertex could be killed if the monster in the direct parent of the $i$-th vertex has been killed. The power needed to kill the $i$-th monster is the sum of $hp_i$ and the hit points of all other living monsters who lives in a vertex $j$ whose direct parent is $i$. Formally, the power equals to \n$$\nhp_i + \\sum_{\\begin{array}{c}\\text{the monster in vertex } j \\text{ is \\bf{alive}} \\\\ \\text{and } i \\text{ is the direct parent of } j \\end{array}} hp_j\n$$\n\nIn addition, Kotori can use some magic spells. If she uses one magic spell, she can kill any monster using $0$ power without any restriction. That is, she can choose a monster even if the monster in the direct parent is alive.\n\nFor each $m=0,1,2,\\cdots,n$, Kotori would like to know, respectively, the minimum total power needed to kill all the monsters if she can use $m$ magic spells.", "inputFormat": "There are multiple test cases. The first line of input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($2 \\le n \\le 2 \\times 10^3$), indicating the number of vertices.\n\nThe second line contains $(n-1)$ integers $p_2,p_3,\\cdots,p_n$ ($1 \\le p_i < i$), where $p_i$ means the direct parent of vertex $i$.\n\nThe third line contains $n$ integers $hp_1,hp_2,\\cdots,hp_n$ ($1 \\le hp_i \\le 10^9$) indicating the hit points of each monster.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $2 \\times 10^3$.", "outputFormat": "For each test case output one line containing $(n+1)$ integers $a_0, a_1, \\cdots, a_n$ separated by a space, where $a_m$ indicates the minimum total power needed to kill all the monsters if Kotori can use $m$ magic spells.\n\nPlease, DO NOT output extra spaces at the end of each line, otherwise your answer may be considered incorrect!", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Nanjing R] Monster Hunter", "background": "", "description": "There is a rooted tree with $n$ vertices and the root vertex is $1$. In each vertex, there is a monster. The hit points of the monster in the $i$-th vertex is $hp_i$.\n\nKotori would like to kill all the monsters. The monster in the $i$-th vertex could be killed if the monster in the direct parent of the $i$-th vertex has been killed. The power needed to kill the $i$-th monster is the sum of $hp_i$ and the hit points of all other living monsters who lives in a vertex $j$ whose direct parent is $i$. Formally, the power equals to \n$$\nhp_i + \\sum_{\\begin{array}{c}\\text{the monster in vertex } j \\text{ is \\bf{alive}} \\\\ \\text{and } i \\text{ is the direct parent of } j \\end{array}} hp_j\n$$\n\nIn addition, Kotori can use some magic spells. If she uses one magic spell, she can kill any monster using $0$ power without any restriction. That is, she can choose a monster even if the monster in the direct parent is alive.\n\nFor each $m=0,1,2,\\cdots,n$, Kotori would like to know, respectively, the minimum total power needed to kill all the monsters if she can use $m$ magic spells.", "inputFormat": "There are multiple test cases. The first line of input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($2 \\le n \\le 2 \\times 10^3$), indicating the number of vertices.\n\nThe second line contains $(n-1)$ integers $p_2,p_3,\\cdots,p_n$ ($1 \\le p_i < i$), where $p_i$ means the direct parent of vertex $i$.\n\nThe third line contains $n$ integers $hp_1,hp_2,\\cdots,hp_n$ ($1 \\le hp_i \\le 10^9$) indicating the hit points of each monster.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $2 \\times 10^3$.", "outputFormat": "For each test case output one line containing $(n+1)$ integers $a_0, a_1, \\cdots, a_n$ separated by a space, where $a_m$ indicates the minimum total power needed to kill all the monsters if Kotori can use $m$ magic spells.\n\nPlease, DO NOT output extra spaces at the end of each line, otherwise your answer may be considered incorrect!", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Nanjing R] Monster Hunter", "background": "", "description": "有一棵有根树，包含 $n$ 个顶点，根顶点是 $1$。每个顶点上都有一个怪物。第 $i$ 个顶点上的怪物的生命值为 $hp_i$。\n\nKotori 想要消灭所有的怪物。第 $i$ 个顶点上的怪物可以被消灭，当且仅当其直接父节点上的怪物已经被消灭。消灭第 $i$ 个怪物所需的力量是 $hp_i$ 加上所有其他活着的怪物的生命值，这些怪物位于以 $i$ 为直接父节点的顶点 $j$ 上。形式化地，所需的力量等于\n$$\nhp_i + \\sum_{\\begin{array}{c}\\text{顶点 } j \\text{ 上的怪物是\\textbf{活着的}} \\\\ \\text{且 } i \\text{ 是 } j \\text{ 的直接父节点} \\end{array}} hp_j\n$$\n\n此外，Kotori 可以使用一些魔法咒语。如果她使用一个魔法咒语，她可以在没有任何限制的情况下使用 $0$ 力量消灭任何怪物。也就是说，她可以选择一个怪物，即使其直接父节点上的怪物还活着。\n\n对于每一个 $m=0,1,2,\\cdots,n$，Kotori 想要分别知道如果她可以使用 $m$ 个魔法咒语，消灭所有怪物所需的最小总力量。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含一个整数 $n$ ($2 \\le n \\le 2 \\times 10^3$)，表示顶点的数量。\n\n第二行包含 $(n-1)$ 个整数 $p_2,p_3,\\cdots,p_n$ ($1 \\le p_i < i$)，其中 $p_i$ 表示顶点 $i$ 的直接父节点。\n\n第三行包含 $n$ 个整数 $hp_1,hp_2,\\cdots,hp_n$ ($1 \\le hp_i \\le 10^9$)，表示每个怪物的生命值。\n\n保证所有测试用例的 $n$ 的总和不超过 $2 \\times 10^3$。", "outputFormat": "对于每个测试用例，输出一行包含 $(n+1)$ 个整数 $a_0, a_1, \\cdots, a_n$，用空格分隔，其中 $a_m$ 表示如果 Kotori 可以使用 $m$ 个魔法咒语，消灭所有怪物所需的最小总力量。\n\n请不要在每行的末尾输出多余的空格，否则你的答案可能会被判为不正确！", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9635", "type": "P", "difficulty": 3, "samples": [["3\n1\n2\n5", "1\n3 1\n1 4 5 3 6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["Special Judge", "O2优化", "位运算", "构造", "Ad-hoc"], "title": "「yyOI R1」youyou 的异或", "background": "youyou 非常菜，但是他很喜欢构造奇奇怪怪的数列。", "description": "本题评测方式为 **Special Judge**。\n\nyouyou 很喜欢数列，所以他想让你构造一个长度为 $n$ 的**正整数**序列 $\\{a_i\\}$。\n\nyouyou 很喜欢[异或](https://oi-wiki.org/math/bit/#%E4%B8%8E%E6%88%96%E5%BC%82%E6%88%96)，所以他要求构造出的序列满足 $a_1 \\oplus a_2 \\oplus a_3 \\oplus \\cdots \\oplus a_{n-1} \\oplus a_n = n$（记 $\\oplus$ 表示异或）。\n\nyouyou 非常讨厌相同的数，所以他要求序列中所有数**互不相同**。\n\n但 youyou 不想让这个序列的数太大，所以他要求序列中所有数的总和不超过 $n^2$，即 $\\displaystyle\\sum_{i=1}^n a_i \\le n^2$。\n\n现在你需要构造出一个序列从而满足 youyou 的所有要求。如果无解，输出 `-1` 。如果有多种答案，输出任意一个序列即可。\n\n你需要回答 $T$ 组数据。", "inputFormat": "第一行，一个正整数 $T$。\n\n接下来 $T$ 行，每行一个整数 $n$，表示你需要构造出一个长度为 $n$ 的满足要求的序列。", "outputFormat": "共 $T$ 行。\n\n若第 $i$ 行需要构造长度为 $n$ 的序列，则第 $i$ 行输出恰好 $n$ 个数，表示你所构造出的序列，注意序列中每个数为**正整数**。若无法构造出这样的序列，请在这一行输出 `-1` 。", "hint": "### 样例解释\n对于 $n = 1$ 时，一种可行的解为 $\\{1\\}$。\n\n对于 $n = 2$ 时，一种可行的解为 $\\{3,1\\}$。\n\n对于 $n = 5$ 时，一种可行的解为 $\\{1,4,5,3,6\\}$，因为 $1 ⊕  4 ⊕ 5  ⊕ 3 ⊕ 6 = 5$，且 $1+4+5+3+6 =19\\le 5^2$，序列中每个数也互不相同。\n\n\n### 数据范围\n对于 $5\\%$ 的数据，$n \\le 5$。\n\n对于 $15\\%$ 的数据，$n \\le 10$。\n\n对于 $40\\%$ 的数据，$n \\le 1000$。\n\n对于 $70\\%$ 的数据， $n \\le 10^5$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 5 × 10^5$，$1 \\le T \\le 10$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「yyOI R1」youyou 的异或", "background": "youyou 非常菜，但是他很喜欢构造奇奇怪怪的数列。", "description": "本题评测方式为 **Special Judge**。\n\nyouyou 很喜欢数列，所以他想让你构造一个长度为 $n$ 的**正整数**序列 $\\{a_i\\}$。\n\nyouyou 很喜欢[异或](https://oi-wiki.org/math/bit/#%E4%B8%8E%E6%88%96%E5%BC%82%E6%88%96)，所以他要求构造出的序列满足 $a_1 \\oplus a_2 \\oplus a_3 \\oplus \\cdots \\oplus a_{n-1} \\oplus a_n = n$（记 $\\oplus$ 表示异或）。\n\nyouyou 非常讨厌相同的数，所以他要求序列中所有数**互不相同**。\n\n但 youyou 不想让这个序列的数太大，所以他要求序列中所有数的总和不超过 $n^2$，即 $\\displaystyle\\sum_{i=1}^n a_i \\le n^2$。\n\n现在你需要构造出一个序列从而满足 youyou 的所有要求。如果无解，输出 `-1` 。如果有多种答案，输出任意一个序列即可。\n\n你需要回答 $T$ 组数据。", "inputFormat": "第一行，一个正整数 $T$。\n\n接下来 $T$ 行，每行一个整数 $n$，表示你需要构造出一个长度为 $n$ 的满足要求的序列。", "outputFormat": "共 $T$ 行。\n\n若第 $i$ 行需要构造长度为 $n$ 的序列，则第 $i$ 行输出恰好 $n$ 个数，表示你所构造出的序列，注意序列中每个数为**正整数**。若无法构造出这样的序列，请在这一行输出 `-1` 。", "hint": "### 样例解释\n对于 $n = 1$ 时，一种可行的解为 $\\{1\\}$。\n\n对于 $n = 2$ 时，一种可行的解为 $\\{3,1\\}$。\n\n对于 $n = 5$ 时，一种可行的解为 $\\{1,4,5,3,6\\}$，因为 $1 ⊕  4 ⊕ 5  ⊕ 3 ⊕ 6 = 5$，且 $1+4+5+3+6 =19\\le 5^2$，序列中每个数也互不相同。\n\n\n### 数据范围\n对于 $5\\%$ 的数据，$n \\le 5$。\n\n对于 $15\\%$ 的数据，$n \\le 10$。\n\n对于 $40\\%$ 的数据，$n \\le 1000$。\n\n对于 $70\\%$ 的数据， $n \\le 10^5$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 5 × 10^5$，$1 \\le T \\le 10$。\n", "locale": "zh-CN"}}}
{"pid": "P9636", "type": "P", "difficulty": 3, "samples": [["5 1 1 5 10\n1 2 2 2 2", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化"], "title": "「yyOI R1」youyou 的篡改（Easy Ver.）", "background": "**Easy Version 与 Hard Version 仅最后所求内容不同，其他描述均一致。**", "description": "youyou 准备举办一场比赛，这场比赛有 $n$ 道题，每一道题都有一个难度值 $v_i$。\n\nyouyou 给出一个计数分量 $k(k\\le n)$，他认为，第 $x(x \\geq k)$ 道题的可做性 $a_x$ 应当是第 $1\\sim x$ 题所有题目中将难度值从小到大排序后难度较大的 $k$ 道题目难度值之和。\n\n由于第 $1 \\sim k-1$ 题难度过于简单，youyou 不想考虑这些题目的可做性。\n\n那么这场比赛的总可做性即为第 $k$ 道题至第 $n$ 道题可做性之和，即 $\\sum^{n}_{i=k}a_i$\n 的值。\n\nyouyou 可以篡改题目 $m$ 的难度为任意正整数，但是他并不希望这场比赛过难或者过简单，所以他要求总可做性必须介于 $[l,r]$ 之间。\n\nyouyou 想知道，他通过篡改题目 $m$ 的难度，可以将总可做性最大篡改为多少？\n\n特别的，如不存在一组解请输出 $-1$。", "inputFormat": "第一行输入五个正整数，分别为 $n,m,k,l,r$。\n\n第二行输入 $n$ 个整数，第 $i$ 个数 $v_i$ 为第 $i$ 道题难度值。", "outputFormat": "仅一行，输出一个数，表示在满足条件的前提下，总可做性可改为的最大值。", "hint": "### 样例解释#1\n\n因为 $m=1$，因此 $a_1$ 是可以被篡改的，当 $a_1=2$ 时，总可做性为 $2+2+2+2+2=10$，因为 $10 \\in [5,10]$，因此可以将总可做性最大篡改为 $10$。\n\n## 数据范围\n\n本题启用 **Subtask**，对于每一个 **Subtask**，你需要通过全部测试点才能得到该部分的分数。\n\n| 子任务编号 | $n$ | 分数 |\n| :-----------: | :-----------: | :-----------: |\n| $1$ | $\\le10$ | $15$ |\n| $2$ | $\\le10^3$ | $15$ |\n| $3$ | $\\le10^5$ | $70$ |\n\n\n对于 $100\\%$ 的数据，$1\\le k,t \\le n \\le 10^5$，$1 \\le l \\le r \\le 10^{9}$，$0\\le v_i\\le10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「yyOI R1」youyou 的篡改（Easy Ver.）", "background": "**Easy Version 与 Hard Version 仅最后所求内容不同，其他描述均一致。**", "description": "youyou 准备举办一场比赛，这场比赛有 $n$ 道题，每一道题都有一个难度值 $v_i$。\n\nyouyou 给出一个计数分量 $k(k\\le n)$，他认为，第 $x(x \\geq k)$ 道题的可做性 $a_x$ 应当是第 $1\\sim x$ 题所有题目中将难度值从小到大排序后难度较大的 $k$ 道题目难度值之和。\n\n由于第 $1 \\sim k-1$ 题难度过于简单，youyou 不想考虑这些题目的可做性。\n\n那么这场比赛的总可做性即为第 $k$ 道题至第 $n$ 道题可做性之和，即 $\\sum^{n}_{i=k}a_i$\n 的值。\n\nyouyou 可以篡改题目 $m$ 的难度为任意正整数，但是他并不希望这场比赛过难或者过简单，所以他要求总可做性必须介于 $[l,r]$ 之间。\n\nyouyou 想知道，他通过篡改题目 $m$ 的难度，可以将总可做性最大篡改为多少？\n\n特别的，如不存在一组解请输出 $-1$。", "inputFormat": "第一行输入五个正整数，分别为 $n,m,k,l,r$。\n\n第二行输入 $n$ 个整数，第 $i$ 个数 $v_i$ 为第 $i$ 道题难度值。", "outputFormat": "仅一行，输出一个数，表示在满足条件的前提下，总可做性可改为的最大值。", "hint": "### 样例解释#1\n\n因为 $m=1$，因此 $a_1$ 是可以被篡改的，当 $a_1=2$ 时，总可做性为 $2+2+2+2+2=10$，因为 $10 \\in [5,10]$，因此可以将总可做性最大篡改为 $10$。\n\n## 数据范围\n\n本题启用 **Subtask**，对于每一个 **Subtask**，你需要通过全部测试点才能得到该部分的分数。\n\n| 子任务编号 | $n$ | 分数 |\n| :-----------: | :-----------: | :-----------: |\n| $1$ | $\\le10$ | $15$ |\n| $2$ | $\\le10^3$ | $15$ |\n| $3$ | $\\le10^5$ | $70$ |\n\n\n对于 $100\\%$ 的数据，$1\\le k,t \\le n \\le 10^5$，$1 \\le l \\le r \\le 10^{9}$，$0\\le v_i\\le10^9$。", "locale": "zh-CN"}}}
{"pid": "P9637", "type": "P", "difficulty": 4, "samples": [["5 1 1 5 10\n1 2 2 2 2", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化"], "title": "「yyOI R1」youyou 的篡改（Hard Ver.）", "background": "**Easy Version 与 Hard Version 仅最后所求内容不同，其他描述均一致。**", "description": "youyou 准备举办一场比赛，这场比赛有 $n$ 道题，每一道题都有一个难度值 $v_i$。\n\nyouyou 给出一个计数分量 $k(k\\le n)$，他认为，第 $x(x \\geq k)$ 道题的可做性 $a_x$ 应当是第 $1\\sim x$ 题所有题目中将难度值从小到大排序后难度较大的 $k$ 道题目难度值之和。\n\n由于第 $1 \\sim k-1$ 题难度过于简单，youyou 不想考虑这些题目的可做性。\n\n那么这场比赛的总可做性即为第 $k$ 道题至第 $n$ 道题可做性之和，即 $\\sum^{n}_{i=k}a_i$\n 的值。\n\n他可以篡改题目 $m$ 的难度为任意正整数。\n\n问：总可做性必须满足在区间 $[l,r]$ 的范围内，那么总可做性有几种取值？", "inputFormat": "第一行输入五个正整数，分别为 $n,m,k,l,r$。\n\n第二行输入 $n$ 个整数，第 $i$ 个数 $v_i$ 为第 $i$ 道题难度值。", "outputFormat": "仅一行，输出一个数，表示在满足条件的前提下，总可做性的取值数。", "hint": "### 样例解释#1\n\n你可以改动 $v_1$，$k=1$。\n\n当第一个数改动为 $1$ 时，总难度 $1+2+2+2+2=9$。\n\n当第一个数改动为 $2$ 时，总难度 $2+2+2+2+2=10$。\n\n仅有以上两种取值符合题意，即总难度值等于 $9$ 或 $10$。因此答案为 $2$。\n\n## 数据范围\n\n本题启用 **Subtask**，对于每一个 **Subtask**，你需要通过全部测试点才能得到该部分的分数。\n\n| 子任务编号 | $n$ | 分数 |\n| :-----------: | :-----------: | :-----------: |\n| $1$ | $\\le10$ | $15$ |\n| $2$ | $\\le10^3$ | $15$ |\n| $3$ | $\\le10^5$ | $70$ |\n\n\n对于 $100\\%$ 的数据，$1\\le k,t \\le n \\le 10^5$，$1 \\le l \\le r \\le 10^{9}$，$1\\le v_i\\le10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「yyOI R1」youyou 的篡改（Hard Ver.）", "background": "**Easy Version 与 Hard Version 仅最后所求内容不同，其他描述均一致。**", "description": "youyou 准备举办一场比赛，这场比赛有 $n$ 道题，每一道题都有一个难度值 $v_i$。\n\nyouyou 给出一个计数分量 $k(k\\le n)$，他认为，第 $x(x \\geq k)$ 道题的可做性 $a_x$ 应当是第 $1\\sim x$ 题所有题目中将难度值从小到大排序后难度较大的 $k$ 道题目难度值之和。\n\n由于第 $1 \\sim k-1$ 题难度过于简单，youyou 不想考虑这些题目的可做性。\n\n那么这场比赛的总可做性即为第 $k$ 道题至第 $n$ 道题可做性之和，即 $\\sum^{n}_{i=k}a_i$\n 的值。\n\n他可以篡改题目 $m$ 的难度为任意正整数。\n\n问：总可做性必须满足在区间 $[l,r]$ 的范围内，那么总可做性有几种取值？", "inputFormat": "第一行输入五个正整数，分别为 $n,m,k,l,r$。\n\n第二行输入 $n$ 个整数，第 $i$ 个数 $v_i$ 为第 $i$ 道题难度值。", "outputFormat": "仅一行，输出一个数，表示在满足条件的前提下，总可做性的取值数。", "hint": "### 样例解释#1\n\n你可以改动 $v_1$，$k=1$。\n\n当第一个数改动为 $1$ 时，总难度 $1+2+2+2+2=9$。\n\n当第一个数改动为 $2$ 时，总难度 $2+2+2+2+2=10$。\n\n仅有以上两种取值符合题意，即总难度值等于 $9$ 或 $10$。因此答案为 $2$。\n\n## 数据范围\n\n本题启用 **Subtask**，对于每一个 **Subtask**，你需要通过全部测试点才能得到该部分的分数。\n\n| 子任务编号 | $n$ | 分数 |\n| :-----------: | :-----------: | :-----------: |\n| $1$ | $\\le10$ | $15$ |\n| $2$ | $\\le10^3$ | $15$ |\n| $3$ | $\\le10^5$ | $70$ |\n\n\n对于 $100\\%$ 的数据，$1\\le k,t \\le n \\le 10^5$，$1 \\le l \\le r \\le 10^{9}$，$1\\le v_i\\le10^9$。", "locale": "zh-CN"}}}
{"pid": "P9638", "type": "P", "difficulty": 5, "samples": [["4 3 3\n1 2 156\n1 4 42\n2 3 1\n1 26963\n3 3 40\n2 4", "1"], ["7 6 7\n1 2 292\n1 3 274\n1 4 221\n1 5 156\n3 4 42\n3 6 40\n1 30\n3 4 50\n2 6\n3 3 250\n3 1 298\n1 280\n2 1", "6\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["并查集", "Kruskal 重构树", "O2优化", "生成树"], "title": "「yyOI R1」youyou 的军训", "background": "在 youyou 的班上，身高可能是一个敏感的话题。", "description": "youyou 的班上一共有 $n$ 位同学，$m$ 对朋友，第 $i$ 对朋友关系对于身高有一个敏感值 $k_i$，敏感值可能会改变。\n\n我们定义两位同学如果互为**朋友**，那么必然存在某对关系，将两位同学**直接**相连。\n\n我们定义两位同学如果互为**好友**，那么必然存在直接或间接的关系，将两位同学相连。\n\n例如存在关系 $(1,2)$ 和 $(2,3)$，那么，$1$ 与 $2$ 是朋友，但 $1$ 与 $3$ 就是好友。\n\n现在，马上就要军训了，同学们要去领军训的服装，如果一位同学领到了尺码为 $p$ 的服装，所有同学会与朋友关系敏感值小于 $p$ 的朋友断交。即对于所有的朋友关系，若其敏感值小于 $p$，那么该朋友关系就会断开。不过在下一位同学领到服装时，所有**之前**的断开的朋友关系会恢复。\n\n由于军训领服装是一个复杂的过程，而 youyou 对此十分感兴趣，所以给出 $q$ 次操作，且一共有三种操作:\n\n- 操作 $1$，形如 `1 x`，表示有一位同学领到尺码为 $x$ 的服装。\n\n- 操作 $2$，形如 `2 x`，表示询问第 $x$ 位同学还有多少位好友（包括自己）。\n\n- 操作 $3$，形如 `3 x y`，表示第 $x$ 对朋友的敏感值变为 $y$，特别地，**敏感值的相对大小不会变化$^*$**（详情见下方），同时原来已经断开的关系不会恢复。\n\n**注意：好友跟朋友是两个概念，朋友一定是好友，但好友不一定是朋友。**\n\n$^*$：相对大小不会变化，指对于当前所有的敏感值而言，修改后的敏感值与原来的敏感值**排名相同**。\n\n例如，若原来所有对朋友之间敏感值是 $\\{1,2,3,5,6\\}$，$3$ 的排名为 $3$，因此 $3$ 只能修改为 $3,4$ 中的一个，这样才能保证排名不变，即相对大小位置不会变换。", "inputFormat": "第一行，输入三个正整数 $n,m,q$。\n\n后面 $m$ 行，给定 $m$ 对朋友关系，对于第 $i$ 行给定三个正整数 $x_i,y_i,k_i$。\n\n最后 $q$ 行，给定 $q$ 次操作。对于每次操作，给定一个正整数为 $op$，即操作类型。\n\n当 $op=1$ 时，再给定一个正整数 $x$，表示有一位同学领到尺码为 $x$ 的服装；\n\n当 $op=2$ 时，再给定一个正整数 $x$，表示一次询问；\n\n当 $op=3$ 时，再给定两个正整数 $x,y$，表示一次修改。", "outputFormat": "对于每次询问操作，输出一个 $x$ 表示询问的同学还有几位**好友**（**包括自己**）。保证对于每一个测试点，都会有一个询问操作。", "hint": "## 样例解释 #1\n\n如图所示，这是初始的关系图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/68hzm5mr.png)\n\n第一次操作为：有一位同学领到尺码为 $26963$ 的服装，这样，图中所有的边都会断开。\n\n下一次操作：第三对朋友即边 $(2,3)$ 的权变为 $40$。\n\n下一次操作：询问同学 $4$ 的好友数量，因为没有任何存在的边，因此答案为 $1$。\n \n## 数据范围\n| 测试点编号 | $n$ | $q$ | 特殊性质 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $1,2$ | $\\le 10$ | $\\le 4 \\times 10^5$ | 无 |\n| $3$ | $\\le 10^3$ | $\\le 10^3$ | 无 |\n| $4$ | $\\le 10^5$ | $\\le 4 \\times 10^5$ | 没有操作 $3$ |\n| $5,6$ | $\\le 10^5$ | $\\le 10^3$ | 无 |\n| $7$ | $\\le 10^5$ | $\\le 4 \\times 10^5$ | 没有操作 $1$ |\n| $8,9,10$ | $\\le 4 \\times 10^5$ | $\\le 4 \\times 10^5$ | 无 |\n\n用 $c_i$ 表示询问中同学领到服装尺码的大小，$e_i$ 表示修改后敏感值的大小。\n\n对于 $100\\%$ 的数据，$1 \\le n,m,q,x_i,y_i \\le 4  \\times  10^5$，$1 \\le k_i,c_i,e_i \\le 1 \\times 10^9$，$m\\le \\min\\{\\frac{n(n-1)}{2},4 \\times 10^5\\}$。\n\n同时数据保证在任何时刻，所有对朋友关系之间的敏感值**互不相同**。\n\n**请注意常数因子对时间和空间产生的影响。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「yyOI R1」youyou 的军训", "background": "在 youyou 的班上，身高可能是一个敏感的话题。", "description": "youyou 的班上一共有 $n$ 位同学，$m$ 对朋友，第 $i$ 对朋友关系对于身高有一个敏感值 $k_i$，敏感值可能会改变。\n\n我们定义两位同学如果互为**朋友**，那么必然存在某对关系，将两位同学**直接**相连。\n\n我们定义两位同学如果互为**好友**，那么必然存在直接或间接的关系，将两位同学相连。\n\n例如存在关系 $(1,2)$ 和 $(2,3)$，那么，$1$ 与 $2$ 是朋友，但 $1$ 与 $3$ 就是好友。\n\n现在，马上就要军训了，同学们要去领军训的服装，如果一位同学领到了尺码为 $p$ 的服装，所有同学会与朋友关系敏感值小于 $p$ 的朋友断交。即对于所有的朋友关系，若其敏感值小于 $p$，那么该朋友关系就会断开。不过在下一位同学领到服装时，所有**之前**的断开的朋友关系会恢复。\n\n由于军训领服装是一个复杂的过程，而 youyou 对此十分感兴趣，所以给出 $q$ 次操作，且一共有三种操作:\n\n- 操作 $1$，形如 `1 x`，表示有一位同学领到尺码为 $x$ 的服装。\n\n- 操作 $2$，形如 `2 x`，表示询问第 $x$ 位同学还有多少位好友（包括自己）。\n\n- 操作 $3$，形如 `3 x y`，表示第 $x$ 对朋友的敏感值变为 $y$，特别地，**敏感值的相对大小不会变化$^*$**（详情见下方），同时原来已经断开的关系不会恢复。\n\n**注意：好友跟朋友是两个概念，朋友一定是好友，但好友不一定是朋友。**\n\n$^*$：相对大小不会变化，指对于当前所有的敏感值而言，修改后的敏感值与原来的敏感值**排名相同**。\n\n例如，若原来所有对朋友之间敏感值是 $\\{1,2,3,5,6\\}$，$3$ 的排名为 $3$，因此 $3$ 只能修改为 $3,4$ 中的一个，这样才能保证排名不变，即相对大小位置不会变换。", "inputFormat": "第一行，输入三个正整数 $n,m,q$。\n\n后面 $m$ 行，给定 $m$ 对朋友关系，对于第 $i$ 行给定三个正整数 $x_i,y_i,k_i$。\n\n最后 $q$ 行，给定 $q$ 次操作。对于每次操作，给定一个正整数为 $op$，即操作类型。\n\n当 $op=1$ 时，再给定一个正整数 $x$，表示有一位同学领到尺码为 $x$ 的服装；\n\n当 $op=2$ 时，再给定一个正整数 $x$，表示一次询问；\n\n当 $op=3$ 时，再给定两个正整数 $x,y$，表示一次修改。", "outputFormat": "对于每次询问操作，输出一个 $x$ 表示询问的同学还有几位**好友**（**包括自己**）。保证对于每一个测试点，都会有一个询问操作。", "hint": "## 样例解释 #1\n\n如图所示，这是初始的关系图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/68hzm5mr.png)\n\n第一次操作为：有一位同学领到尺码为 $26963$ 的服装，这样，图中所有的边都会断开。\n\n下一次操作：第三对朋友即边 $(2,3)$ 的权变为 $40$。\n\n下一次操作：询问同学 $4$ 的好友数量，因为没有任何存在的边，因此答案为 $1$。\n \n## 数据范围\n| 测试点编号 | $n$ | $q$ | 特殊性质 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $1,2$ | $\\le 10$ | $\\le 4 \\times 10^5$ | 无 |\n| $3$ | $\\le 10^3$ | $\\le 10^3$ | 无 |\n| $4$ | $\\le 10^5$ | $\\le 4 \\times 10^5$ | 没有操作 $3$ |\n| $5,6$ | $\\le 10^5$ | $\\le 10^3$ | 无 |\n| $7$ | $\\le 10^5$ | $\\le 4 \\times 10^5$ | 没有操作 $1$ |\n| $8,9,10$ | $\\le 4 \\times 10^5$ | $\\le 4 \\times 10^5$ | 无 |\n\n用 $c_i$ 表示询问中同学领到服装尺码的大小，$e_i$ 表示修改后敏感值的大小。\n\n对于 $100\\%$ 的数据，$1 \\le n,m,q,x_i,y_i \\le 4  \\times  10^5$，$1 \\le k_i,c_i,e_i \\le 1 \\times 10^9$，$m\\le \\min\\{\\frac{n(n-1)}{2},4 \\times 10^5\\}$。\n\n同时数据保证在任何时刻，所有对朋友关系之间的敏感值**互不相同**。\n\n**请注意常数因子对时间和空间产生的影响。**", "locale": "zh-CN"}}}
{"pid": "P9639", "type": "P", "difficulty": 5, "samples": [["4 3\n1 5 7 3\n1\n", "12\n13\n13\n"], ["5 5\n7 7 7 7 6\n1", "9\n9\n9\n9\n9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "树状数组", "O2优化"], "title": "「yyOI R1」youyou 的序列", "background": "", "description": "给定一个长度为 $n$ 的序列 $a_{1\\dots n}$，以及 $q$ 次操作。\n\n定义一次操作为：交换 $a_k$ 与 $a_{k+1}$ 的值，并**立即**询问所有以 $a_i \\;( i\\in [1,n])$ 为峰的[子序列](https://oi-wiki.org/string/basic/#%E5%AD%90%E5%BA%8F%E5%88%97)数量之和，对 $4294967296$ 取模。**这里的交换是暂时的，也就是说，它仅在下一次操作前有效。**\n\n在此我们认为，一个长度至少为 $1$ 的序列 $[a_1,a_2 ,\\cdots,a_{s-1},a_s,a_{s+1},\\cdots,a_{n-1},a_n ]$，满足 $a_1<a_2<\\cdots<a_{s-1}<a_s>a_{s+1}>\\cdots >a_{n-1}>a_n$，则称此序列为以 $a_s$ 为峰的序列。\n\n你的任务是回答出所有操作的答案。\n", "inputFormat": "第一行输入两个整数 $n,q$。\n\n第二行输入 $n$ 个正整数，表示一开始的序列 $a_{1\\dots n}$。\n\n第三行，输入一个整数 $k$，表示进行第一次操作（定义见上），保证 $1\\le k <n$。\n\n---\n\n第 $2$ 到第 $q$ 次操作的 $k$ 值由如下方法得到：\n\n```cpp\nint Answer(unsigned int ans)\n{\n    unsigned int BASE=998244353ll*ans+ans*ans+ans/9991+ans%2159;\n    BASE^=9810;\n    BASE^=51971;\n    BASE=BASE>>7;\n    BASE=BASE<<11;\n    BASE^=751669;\n    BASE^=23465695622566ll;\n    return BASE%(n-1)+1;\n}\n```\n当你每完成一次询问后，将你这次询问的答案 $ans$ 作为参数，**恰好**调用一次 `Answer(ans)` 。\n\n得到的返回值即为下一次操作的 $k$。\n\n**注意：本输入方式仅用于减少输入量，标准算法不依赖于此输入方式。**", "outputFormat": "你需要输出所有操作的答案，每个答案输出一行。", "hint": "### 样例解释 #1\n\n第一次操作的 $k$ 为 $1$。\n\n此时序列为 $[5,1,7,3]$。\n\n峰为 $a_1$：$[5]$，$[5,1]$，$[5,3]$。\n\n峰为 $a_2$：$[1]$。\n\n峰为 $a_3$：$[7]$，$[5,7]$，$[1,7]$，$[7,3]$，$[5,7,3]$，$[1,7,3]$。\n\n峰为 $a_4$：$[3]$，$[1,3]$。\n\n共计 $12$ 个不同的子序列，答案输出 $12$。\n\n第二次和第三次操作的 $k$ 均为 $3$ ，此时有 $13$ 个不同的序列满足条件。\n\n### 样例解释 #2\n\n第一次操作的 $k$ 为 $1$。\n\n此时序列为 $[7,7,7,7,6]$。\n\n峰为 $a_1$：$[7]$，$[7,6]$。\n\n峰为 $a_2$：$[7]$，$[7,6]$。\n\n峰为 $a_3$：$[7]$，$[7,6]$。\n\n峰为 $a_4$：$[7]$，$[7,6]$。\n\n峰为 $a_5$：$[6]$。\n\n共计 $9$ 个不同的子序列，答案输出 $9$。\n\n后四次操作同理。\n\n---\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | $n$ | $q$ | 分数 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $\\le 500$ | $\\le 100 $ |$10$ |\n| $2$ | $\\le2\\times10^3$|$ \\le 5\\times10^3$ | $20$ |\n| $3$ | $\\le3\\times10^4$ |$\\le 10^4$ | $30$ |\n| $4$ | $\\le10^6$|$ \\le10^6$ | $40$ |\n\n对于 $100\\%$ 的数据，$2\\le n\\le10^6$，$1\\le q\\le10^6$，$1\\le a_i\\le10^4$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「yyOI R1」youyou 的序列", "background": "", "description": "给定一个长度为 $n$ 的序列 $a_{1\\dots n}$，以及 $q$ 次操作。\n\n定义一次操作为：交换 $a_k$ 与 $a_{k+1}$ 的值，并**立即**询问所有以 $a_i \\;( i\\in [1,n])$ 为峰的[子序列](https://oi-wiki.org/string/basic/#%E5%AD%90%E5%BA%8F%E5%88%97)数量之和，对 $4294967296$ 取模。**这里的交换是暂时的，也就是说，它仅在下一次操作前有效。**\n\n在此我们认为，一个长度至少为 $1$ 的序列 $[a_1,a_2 ,\\cdots,a_{s-1},a_s,a_{s+1},\\cdots,a_{n-1},a_n ]$，满足 $a_1<a_2<\\cdots<a_{s-1}<a_s>a_{s+1}>\\cdots >a_{n-1}>a_n$，则称此序列为以 $a_s$ 为峰的序列。\n\n你的任务是回答出所有操作的答案。\n", "inputFormat": "第一行输入两个整数 $n,q$。\n\n第二行输入 $n$ 个正整数，表示一开始的序列 $a_{1\\dots n}$。\n\n第三行，输入一个整数 $k$，表示进行第一次操作（定义见上），保证 $1\\le k <n$。\n\n---\n\n第 $2$ 到第 $q$ 次操作的 $k$ 值由如下方法得到：\n\n```cpp\nint Answer(unsigned int ans)\n{\n    unsigned int BASE=998244353ll*ans+ans*ans+ans/9991+ans%2159;\n    BASE^=9810;\n    BASE^=51971;\n    BASE=BASE>>7;\n    BASE=BASE<<11;\n    BASE^=751669;\n    BASE^=23465695622566ll;\n    return BASE%(n-1)+1;\n}\n```\n当你每完成一次询问后，将你这次询问的答案 $ans$ 作为参数，**恰好**调用一次 `Answer(ans)` 。\n\n得到的返回值即为下一次操作的 $k$。\n\n**注意：本输入方式仅用于减少输入量，标准算法不依赖于此输入方式。**", "outputFormat": "你需要输出所有操作的答案，每个答案输出一行。", "hint": "### 样例解释 #1\n\n第一次操作的 $k$ 为 $1$。\n\n此时序列为 $[5,1,7,3]$。\n\n峰为 $a_1$：$[5]$，$[5,1]$，$[5,3]$。\n\n峰为 $a_2$：$[1]$。\n\n峰为 $a_3$：$[7]$，$[5,7]$，$[1,7]$，$[7,3]$，$[5,7,3]$，$[1,7,3]$。\n\n峰为 $a_4$：$[3]$，$[1,3]$。\n\n共计 $12$ 个不同的子序列，答案输出 $12$。\n\n第二次和第三次操作的 $k$ 均为 $3$ ，此时有 $13$ 个不同的序列满足条件。\n\n### 样例解释 #2\n\n第一次操作的 $k$ 为 $1$。\n\n此时序列为 $[7,7,7,7,6]$。\n\n峰为 $a_1$：$[7]$，$[7,6]$。\n\n峰为 $a_2$：$[7]$，$[7,6]$。\n\n峰为 $a_3$：$[7]$，$[7,6]$。\n\n峰为 $a_4$：$[7]$，$[7,6]$。\n\n峰为 $a_5$：$[6]$。\n\n共计 $9$ 个不同的子序列，答案输出 $9$。\n\n后四次操作同理。\n\n---\n\n### 数据范围\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | $n$ | $q$ | 分数 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $\\le 500$ | $\\le 100 $ |$10$ |\n| $2$ | $\\le2\\times10^3$|$ \\le 5\\times10^3$ | $20$ |\n| $3$ | $\\le3\\times10^4$ |$\\le 10^4$ | $30$ |\n| $4$ | $\\le10^6$|$ \\le10^6$ | $40$ |\n\n对于 $100\\%$ 的数据，$2\\le n\\le10^6$，$1\\le q\\le10^6$，$1\\le a_i\\le10^4$。\n", "locale": "zh-CN"}}}
{"pid": "P9640", "type": "P", "difficulty": 5, "samples": [["5\n9\n99\n999\n99999\n999999", "45\n615\n6570\n597600\n5689830"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "O2优化", "数位 DP", "陕西", "省赛/邀请赛"], "title": "[SNCPC2019] Digit Mode", "background": "", "description": "Let $m(x)$ be the $\\textit{mode}$ of the digits in decimal representation of positive integer $x$. The mode is the largest value that occurs most frequently in the sequence. For example, $m(15532)=5$, $m(25252)=2$, $m(103000)=0$, $m(364364)=6$, $m(114514)=1$, $m(889464)=8$.\n\nGiven a positive integer $n$, DreamGrid would like to know the value of $(\\sum\\limits_{x=1}^{n} m(x)) \\bmod (10^9+7)$.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains a positive integer $n$ ($1 \\le n < 10^{50}$) without leading zeros.\n\nIt's guaranteed that the sum of $|n|$ of all test cases will not exceed $50$, where $|n|$ indicates the number of digits of $n$ in decimal representation.", "outputFormat": "For each test case output one line containing one integer, indicating the value of $(\\sum\\limits_{x=1}^{n} m(x)) \\bmod (10^9+7)$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] Digit Mode", "background": "", "description": "Let $m(x)$ be the $\\textit{mode}$ of the digits in decimal representation of positive integer $x$. The mode is the largest value that occurs most frequently in the sequence. For example, $m(15532)=5$, $m(25252)=2$, $m(103000)=0$, $m(364364)=6$, $m(114514)=1$, $m(889464)=8$.\n\nGiven a positive integer $n$, DreamGrid would like to know the value of $(\\sum\\limits_{x=1}^{n} m(x)) \\bmod (10^9+7)$.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains a positive integer $n$ ($1 \\le n < 10^{50}$) without leading zeros.\n\nIt's guaranteed that the sum of $|n|$ of all test cases will not exceed $50$, where $|n|$ indicates the number of digits of $n$ in decimal representation.", "outputFormat": "For each test case output one line containing one integer, indicating the value of $(\\sum\\limits_{x=1}^{n} m(x)) \\bmod (10^9+7)$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] Digit Mode", "background": "", "description": "设 $m(x)$ 为正整数 $x$ 的十进制表示中数字的众数。众数是序列中出现频率最高的最大值。例如，$m(15532)=5$，$m(25252)=2$，$m(103000)=0$，$m(364364)=6$，$m(114514)=1$，$m(889464)=8$。\n\n给定一个正整数 $n$，DreamGrid 想知道 $(\\sum\\limits_{x=1}^{n} m(x)) \\bmod (10^9+7)$ 的值。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含一个正整数 $n$ ($1 \\le n < 10^{50}$)，没有前导零。\n\n保证所有测试用例的 $|n|$ 的总和不超过 $50$，其中 $|n|$ 表示 $n$ 的十进制表示中的数字个数。", "outputFormat": "对于每个测试用例，输出一行包含一个整数，表示 $(\\sum\\limits_{x=1}^{n} m(x)) \\bmod (10^9+7)$ 的值。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9641", "type": "P", "difficulty": 3, "samples": [["2\n2 3\nrdd\nurl\n2 1 1\n1 1 2\n2 2\nrr\nrr\n1 1\n1 1", "Yes\nNo"]], "limits": {"time": [2000, 2000], "memory": [262144, 262144]}, "tags": ["2019", "并查集", "O2优化", "陕西", "省赛/邀请赛"], "title": "[SNCPC2019] Grid with Arrows", "background": "", "description": "BaoBao has just found a grid with $n$ rows and $m$ columns in his left pocket, where the cell in the $j$-th column of the $i$-th row (indicated by $(i, j)$) contains an arrow (pointing either upwards, downwards, leftwards or rightwards) and an integer $a_{i, j}$.\n\nBaoBao decides to play a game with the grid. He will first select a cell as the initial cell and tick it. After ticking a cell (let's say BaoBao has just ticked cell $(i, j)$), BaoBao will go on ticking another cell according to the arrow and the integer in cell $(i, j)$.\n\n- If the arrow in cell $(i, j)$ points upwards, BaoBao will go on ticking cell $(i-a_{i, j}, j)$ if it exists.\n- If the arrow in cell $(i, j)$ points downwards, BaoBao will go on ticking cell $(i+a_{i, j}, j)$ if it exists.\n- If the arrow in cell $(i, j)$ points leftwards, BaoBao will go on ticking cell $(i, j-a_{i, j})$ if it exists.\n- If the arrow in cell $(i, j)$ points rightwards, BaoBao will go on ticking cell $(i, j+a_{i, j})$ if it exists.\n\nIf the cell BaoBao decides to tick does not exist, or if the cell is already ticked, the game ends.\n\nBaoBao is wondering if he can select a proper initial cell, so that he can tick every cell in the grid exactly once before the game ends. Please help him find the answer.\n", "inputFormat": "There are multiple test cases. The first line contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\times m \\le 10^5$), indicating the number of rows and columns of the grid.\n\nFor the following $n$ lines, the $i$-th line contains a string $s_i$ consisting of lowercased English letters ($|s_i| = m$, $s_{i, j} \\in \\{\\text{`u' (ascii: 117)}, \\text{`d' (ascii: 100)}, \\text{`l' (ascii: 108)}, \\text{`r'(ascii: 114)}\\}$), where $s_{i, j}$ indicates the direction of arrow in cell $(i, j)$.\n\n- If $s_{i, j} = \\text{`u'}$, the arrow in cell $(i, j)$ points upwards.\n- If $s_{i, j} = \\text{`d'}$, the arrow in cell $(i, j)$ points downwards.\n- If $s_{i, j} = \\text{`l'}$, the arrow in cell $(i, j)$ points leftwards.\n- If $s_{i, j} = \\text{`r'}$, the arrow in cell $(i, j)$ points rightwards.\n\nFor the following $n$ lines, the $i$-th line contains $m$ integers $a_{i, 1}, a_{i, 2}, \\dots, a_{i, m}$ ($1 \\le a_{i, j} \\le \\max(n, m)$), where $a_{i, j}$ indicates the integer in cell $(i, j)$.\n\nIt's guaranteed that the sum of $n \\times m$ of all test cases does not exceed $10^6$.", "outputFormat": "For each test case output one line. If BaoBao can find a proper initial cell, print ``Yes`` (without quotes), otherwise print ``No`` (without quotes).\n", "hint": "For the first sample test case, BaoBao can select cell $(1, 2)$ as the initial cell, so that he can tick all the cells exactly once in the following order: $(1, 2), (2, 2), (2, 3), (2, 1), (1, 1), (1, 3)$.\n\nFor the second sample test case, BaoBao can only tick at most $2$ cells no matter which cell is selected as the initial cell.\n", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] Grid with Arrows", "background": "", "description": "BaoBao has just found a grid with $n$ rows and $m$ columns in his left pocket, where the cell in the $j$-th column of the $i$-th row (indicated by $(i, j)$) contains an arrow (pointing either upwards, downwards, leftwards or rightwards) and an integer $a_{i, j}$.\n\nBaoBao decides to play a game with the grid. He will first select a cell as the initial cell and tick it. After ticking a cell (let's say BaoBao has just ticked cell $(i, j)$), BaoBao will go on ticking another cell according to the arrow and the integer in cell $(i, j)$.\n\n- If the arrow in cell $(i, j)$ points upwards, BaoBao will go on ticking cell $(i-a_{i, j}, j)$ if it exists.\n- If the arrow in cell $(i, j)$ points downwards, BaoBao will go on ticking cell $(i+a_{i, j}, j)$ if it exists.\n- If the arrow in cell $(i, j)$ points leftwards, BaoBao will go on ticking cell $(i, j-a_{i, j})$ if it exists.\n- If the arrow in cell $(i, j)$ points rightwards, BaoBao will go on ticking cell $(i, j+a_{i, j})$ if it exists.\n\nIf the cell BaoBao decides to tick does not exist, or if the cell is already ticked, the game ends.\n\nBaoBao is wondering if he can select a proper initial cell, so that he can tick every cell in the grid exactly once before the game ends. Please help him find the answer.\n", "inputFormat": "There are multiple test cases. The first line contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\times m \\le 10^5$), indicating the number of rows and columns of the grid.\n\nFor the following $n$ lines, the $i$-th line contains a string $s_i$ consisting of lowercased English letters ($|s_i| = m$, $s_{i, j} \\in \\{\\text{`u' (ascii: 117)}, \\text{`d' (ascii: 100)}, \\text{`l' (ascii: 108)}, \\text{`r'(ascii: 114)}\\}$), where $s_{i, j}$ indicates the direction of arrow in cell $(i, j)$.\n\n- If $s_{i, j} = \\text{`u'}$, the arrow in cell $(i, j)$ points upwards.\n- If $s_{i, j} = \\text{`d'}$, the arrow in cell $(i, j)$ points downwards.\n- If $s_{i, j} = \\text{`l'}$, the arrow in cell $(i, j)$ points leftwards.\n- If $s_{i, j} = \\text{`r'}$, the arrow in cell $(i, j)$ points rightwards.\n\nFor the following $n$ lines, the $i$-th line contains $m$ integers $a_{i, 1}, a_{i, 2}, \\dots, a_{i, m}$ ($1 \\le a_{i, j} \\le \\max(n, m)$), where $a_{i, j}$ indicates the integer in cell $(i, j)$.\n\nIt's guaranteed that the sum of $n \\times m$ of all test cases does not exceed $10^6$.", "outputFormat": "For each test case output one line. If BaoBao can find a proper initial cell, print ``Yes`` (without quotes), otherwise print ``No`` (without quotes).\n", "hint": "For the first sample test case, BaoBao can select cell $(1, 2)$ as the initial cell, so that he can tick all the cells exactly once in the following order: $(1, 2), (2, 2), (2, 3), (2, 1), (1, 1), (1, 3)$.\n\nFor the second sample test case, BaoBao can only tick at most $2$ cells no matter which cell is selected as the initial cell.\n", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] Grid with Arrows", "background": "", "description": "宝宝刚刚在他的左口袋里发现了一个 $n$ 行 $m$ 列的网格，其中第 $i$ 行第 $j$ 列的单元格（表示为 $(i, j)$）包含一个箭头（指向上、下、左或右）和一个整数 $a_{i, j}$。\n\n宝宝决定用这个网格玩一个游戏。他首先会选择一个单元格作为初始单元格并标记它。在标记一个单元格之后（假设宝宝刚刚标记了单元格 $(i, j)$），宝宝将根据单元格 $(i, j)$ 中的箭头和整数继续标记另一个单元格。\n\n- 如果单元格 $(i, j)$ 中的箭头指向上方，宝宝将继续标记单元格 $(i-a_{i, j}, j)$，如果该单元格存在的话。\n- 如果单元格 $(i, j)$ 中的箭头指向下方，宝宝将继续标记单元格 $(i+a_{i, j}, j)$，如果该单元格存在的话。\n- 如果单元格 $(i, j)$ 中的箭头指向左方，宝宝将继续标记单元格 $(i, j-a_{i, j})$，如果该单元格存在的话。\n- 如果单元格 $(i, j)$ 中的箭头指向右方，宝宝将继续标记单元格 $(i, j+a_{i, j})$，如果该单元格存在的话。\n如果宝宝决定标记的单元格不存在，或者该单元格已经被标记，游戏结束。\n\n宝宝想知道他是否可以选择一个合适的初始单元格，以便在游戏结束前恰好标记网格中的每一个单元格一次。请帮助他找到答案。", "inputFormat": "有多个测试用例。第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含两个整数 $n$ 和 $m$ ($1 \\le n \\times m \\le 10^5$)，表示网格的行数和列数。\n\n接下来的 $n$ 行中，第 $i$ 行包含一个字符串 $s_i$，由小写英文字母组成（$|s_i| = m$，$s_{i, j} \\in \\{\\text{`u' (ascii: 117)}, \\text{`d' (ascii: 100)}, \\text{`l' (ascii: 108)}, \\text{`r'(ascii: 114)}\\}$），其中 $s_{i, j}$ 表示单元格 $(i, j)$ 中箭头的方向。\n\n- 如果 $s_{i, j} = \\text{`u'}$，单元格 $(i, j)$ 中的箭头指向上方。\n- 如果 $s_{i, j} = \\text{`d'}$，单元格 $(i, j)$ 中的箭头指向下方。\n- 如果 $s_{i, j} = \\text{`l'}$，单元格 $(i, j)$ 中的箭头指向左方。\n- 如果 $s_{i, j} = \\text{`r'}$，单元格 $(i, j)$ 中的箭头指向右方。\n\n接下来的 $n$ 行中，第 $i$ 行包含 $m$ 个整数 $a_{i, 1}, a_{i, 2}, \\dots, a_{i, m}$ ($1 \\le a_{i, j} \\le \\max(n, m)$)，其中 $a_{i, j}$ 表示单元格 $(i, j)$ 中的整数。\n\n保证所有测试用例的 $n \\times m$ 之和不超过 $10^6$。", "outputFormat": "对于每个测试用例输出一行。如果宝宝可以找到一个合适的初始单元格，输出 “Yes”（不含引号），否则输出 “No”（不含引号）。\n\n**【样例解释】**\n\n对于第一个示例测试用例，宝宝可以选择单元格 $(1, 2)$ 作为初始单元格，这样他可以按以下顺序恰好打勾所有单元格：$(1, 2), (2, 2), (2, 3), (2, 1), (1, 1), (1, 3)$。\n\n对于第二个示例测试用例，无论选择哪个单元格作为初始单元格，宝宝最多只能打勾 2 个单元格。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9642", "type": "P", "difficulty": 3, "samples": [["2\n0689\n08", "8\n2"]], "limits": {"time": [2000, 2000], "memory": [262144, 262144]}, "tags": ["2019", "O2优化", "陕西", "前缀和", "省赛/邀请赛"], "title": "[SNCPC2019] 0689", "background": "", "description": "We call a string as a 0689-string if this string only consists of digits `0`, `6`, `8` and `9`. Given a 0689-string $s$ of length $n$, one $\\textbf{must}$ do the following operation exactly once: select a non-empty substring of $s$ and rotate it 180 degrees.\n\nMore formally, let $s_i$ be the $i$-th character in string $s$. After rotating the substring starting from $s_l$ and ending at $s_r$ 180 degrees ($1 \\le l \\le r \\le n$), string $s$ will become string $t$ of length $n$ extracted from the following equation, where $t_i$ indicates the $i$-th character in string $t$:\n\n$$t_i = \\begin{cases}\ns_i & \\text{if } 1 \\le i < l \\text{ or } r < i \\le n \\\\\n\\text{`0'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`0'} \\\\\n\\text{`6'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`9'} \\\\\n\\text{`8'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`8'} \\\\\n\\text{`9'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`6'} \\\\\n\\end{cases}$$\n\nWhat's the number of different strings one can get after the operation?", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first and only line contains a 0689-string $s$ ($1 \\le |s| \\le 10^6$).\n\nIt's guaranteed that the sum of $|s|$ of all test cases will not exceed $10^7$.\n", "outputFormat": "For each test case output one line containing one integer, indicating the number of different strings one can get after applying the operation exactly once.", "hint": "We hereby explain the first sample test case.\n\n$$\\begin{array}{|c|c||c|c|}\\hline \\textbf{Substring} & \\textbf{Result} & \\textbf{Substring} & \\textbf{Result} \\\\ \\hline 0 & 0689 & 68 & 0899 \\\\ \\hline 6 & 0989 & 89 & 0668 \\\\ \\hline 8 & 0689 & 068 & 8909 \\\\ \\hline 9 & 0686 & 689 & 0689 \\\\ \\hline 06 & 9089 & 0689 & 6890 \\\\ \\hline \\end{array}$$\n\nIt's easy to discover that we can get $8$ different strings after the operation.", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] 0689", "background": "", "description": "We call a string as a 0689-string if this string only consists of digits `0`, `6`, `8` and `9`. Given a 0689-string $s$ of length $n$, one $\\textbf{must}$ do the following operation exactly once: select a non-empty substring of $s$ and rotate it 180 degrees.\n\nMore formally, let $s_i$ be the $i$-th character in string $s$. After rotating the substring starting from $s_l$ and ending at $s_r$ 180 degrees ($1 \\le l \\le r \\le n$), string $s$ will become string $t$ of length $n$ extracted from the following equation, where $t_i$ indicates the $i$-th character in string $t$:\n\n$$t_i = \\begin{cases}\ns_i & \\text{if } 1 \\le i < l \\text{ or } r < i \\le n \\\\\n\\text{`0'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`0'} \\\\\n\\text{`6'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`9'} \\\\\n\\text{`8'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`8'} \\\\\n\\text{`9'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`6'} \\\\\n\\end{cases}$$\n\nWhat's the number of different strings one can get after the operation?", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first and only line contains a 0689-string $s$ ($1 \\le |s| \\le 10^6$).\n\nIt's guaranteed that the sum of $|s|$ of all test cases will not exceed $10^7$.\n", "outputFormat": "For each test case output one line containing one integer, indicating the number of different strings one can get after applying the operation exactly once.", "hint": "We hereby explain the first sample test case.\n\n$$\\begin{array}{|c|c||c|c|}\\hline \\textbf{Substring} & \\textbf{Result} & \\textbf{Substring} & \\textbf{Result} \\\\ \\hline 0 & 0689 & 68 & 0899 \\\\ \\hline 6 & 0989 & 89 & 0668 \\\\ \\hline 8 & 0689 & 068 & 8909 \\\\ \\hline 9 & 0686 & 689 & 0689 \\\\ \\hline 06 & 9089 & 0689 & 6890 \\\\ \\hline \\end{array}$$\n\nIt's easy to discover that we can get $8$ different strings after the operation.", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] 0689", "background": "", "description": "我们称一个字符串为 0689-字符串，如果这个字符串只包含数字 0、6、8 和 9。给定一个长度为 $n$ 的 0689-字符串 $s$，必须执行以下操作一次：选择 $s$ 的一个非空子串并将其旋转 180 度。\n\n更正式地说，设 $s_i$ 为字符串 $s$ 的第 $i$ 个字符。在将从 $s_l$ 开始到 $s_r$ 结束的子串旋转180度后 ($1 \\le l \\le r \\le n$)，字符串 $s$ 将变成长度为 $n$ 的字符串 $t$，其通过以下公式得到，其中 $t_i$ 表示字符串 $t$ 中的第 $i$ 个字符：\n\n$$t_i = \\begin{cases}\ns_i & \\text{if } 1 \\le i < l \\text{ or } r < i \\le n \\\\\n\\text{`0'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`0'} \\\\\n\\text{`6'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`9'} \\\\\n\\text{`8'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`8'} \\\\\n\\text{`9'} & \\text{if } l \\le i \\le r \\text{ and } s_{l+r-i} = \\text{`6'} \\\\\n\\end{cases}$$\n\n经过这个操作后，可以得到多少个不同的字符串？", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n- 第一行且唯一一行包含一个 0689-字符串 $s$ ($1 \\le |s| \\le 10^6$)。\n保证所有测试用例的 $|s|$ 之和不超过 $10^7$。", "outputFormat": "对于每个测试用例输出一行，包含一个整数，表示经过一次操作可以得到的不同字符串的数量。\n\n**【样例解释】**\n\n我们在此解释第一个样例测试用例。\n$$\\begin{array}{|c|c||c|c|}\\hline \\textbf{子串} & \\textbf{结果} & \\textbf{子串} & \\textbf{结果} \\\\ \\hline 0 & 0689 & 68 & 0899 \\\\ \\hline 6 & 0989 & 89 & 0668 \\\\ \\hline 8 & 0689 & 068 & 8909 \\\\ \\hline 9 & 0686 & 689 & 0689 \\\\ \\hline 06 & 9089 & 0689 & 6890 \\\\ \\hline \\end{array}$$\n很容易发现，经过这个操作可以得到 8 个不同的字符串。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9643", "type": "P", "difficulty": 5, "samples": [["3\n1 2\n0 2 1 0 2 2\n1 3\n1 1 0 1 3 1\n1 2\n0 0 100 100 1 1", "1.500000000000000\n1.000000000000000\n2.000000000000000"]], "limits": {"time": [2000, 2000], "memory": [262144, 262144]}, "tags": ["2019", "Special Judge", "O2优化", "陕西", "Ad-hoc", "省赛/邀请赛"], "title": "[SNCPC2019] Pick Up", "background": "", "description": "Grid City is a city on an infinite two-dimensional plane, where for all $k \\in \\mathbb{Z}$ ($\\mathbb{Z}$ is the set of all integers) lines $x = k$ and $y = k$ are the streets of the city. People can only move along the roads to go from one position to another. That's why the city is called the Grid City!\n\nTwo friends, BaoBao and DreamGrid, live happily in the city. Today BaoBao is heading from his home positioned at $(x_A, y_A)$ ($x_A, y_A \\in \\mathbb{Z}$) towards the shopping mall positioned at $(x_C, y_C)$ ($x_C, y_C \\in \\mathbb{Z}$). However, it's too far for him to walk there, so he decides to call DreamGrid whose home is positioned at $(x_B, y_B)$ ($x_B, y_B \\in \\mathbb{Z}$) for help.\n\nBaoBao and DreamGrid set out separately from their homes at the same time. Different from BaoBao who walks at a speed of $a$ units per minute, DreamGrid drives a car and moves at a speed of $b$ units per minute. When DreamGrid and BaoBao meet at the same point, DreamGrid can pick up BaoBao and they can then move at a speed of $b$ units per minute together. It takes no time to turn around or pick up BaoBao.\n\nWhat's the minimum time needed for BaoBao to go from his home to the shopping mall? Note that it's NOT necessary for DreamGrid to pick up BaoBao if it will be faster for BaoBao to get to the destination.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$($ 1 \\le T \\le 10^5$), indicating the number of test cases. For each test case:\n\nThe first line contains two integers $a$ and $b$ ($1 \\le a < b \\le 10^9$), indicating the walking speed of BaoBao and the driving speed of DreamGrid.\n\nThe second line contains six integers $x_A$, $y_A$, $x_B$, $y_B$, $x_C$ and $y_C$ ($-10^9 \\le x_A, y_A, x_B, y_B, x_C, y_C \\le 10^9$), indicating the position of BaoBao's home, DreamGrid's home and the shopping mall. It's guaranteed that these three points are different from each other.", "outputFormat": "For each test case output one line containing one number, indicating the shortest time for BaoBao to arrive at the shopping mall. Your answer will be considered correct if its absolute or relative error does not exceed $10^{-6}$.", "hint": "For the first sample test case, BaoBao and DreamGrid will meet at $D(1,2)$ and then DreamGrid drives BaoBao to the shopping mall.\n\nFor the second sample test case, BaoBao and DreamGrid will meet at $D(1.5,1)$ and then DreamGrid drives BaoBao to the shopping mall.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wexb0vmz.png)", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] Pick Up", "background": "", "description": "Grid City is a city on an infinite two-dimensional plane, where for all $k \\in \\mathbb{Z}$ ($\\mathbb{Z}$ is the set of all integers) lines $x = k$ and $y = k$ are the streets of the city. People can only move along the roads to go from one position to another. That's why the city is called the Grid City!\n\nTwo friends, BaoBao and DreamGrid, live happily in the city. Today BaoBao is heading from his home positioned at $(x_A, y_A)$ ($x_A, y_A \\in \\mathbb{Z}$) towards the shopping mall positioned at $(x_C, y_C)$ ($x_C, y_C \\in \\mathbb{Z}$). However, it's too far for him to walk there, so he decides to call DreamGrid whose home is positioned at $(x_B, y_B)$ ($x_B, y_B \\in \\mathbb{Z}$) for help.\n\nBaoBao and DreamGrid set out separately from their homes at the same time. Different from BaoBao who walks at a speed of $a$ units per minute, DreamGrid drives a car and moves at a speed of $b$ units per minute. When DreamGrid and BaoBao meet at the same point, DreamGrid can pick up BaoBao and they can then move at a speed of $b$ units per minute together. It takes no time to turn around or pick up BaoBao.\n\nWhat's the minimum time needed for BaoBao to go from his home to the shopping mall? Note that it's NOT necessary for DreamGrid to pick up BaoBao if it will be faster for BaoBao to get to the destination.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$($ 1 \\le T \\le 10^5$), indicating the number of test cases. For each test case:\n\nThe first line contains two integers $a$ and $b$ ($1 \\le a < b \\le 10^9$), indicating the walking speed of BaoBao and the driving speed of DreamGrid.\n\nThe second line contains six integers $x_A$, $y_A$, $x_B$, $y_B$, $x_C$ and $y_C$ ($-10^9 \\le x_A, y_A, x_B, y_B, x_C, y_C \\le 10^9$), indicating the position of BaoBao's home, DreamGrid's home and the shopping mall. It's guaranteed that these three points are different from each other.", "outputFormat": "For each test case output one line containing one number, indicating the shortest time for BaoBao to arrive at the shopping mall. Your answer will be considered correct if its absolute or relative error does not exceed $10^{-6}$.", "hint": "For the first sample test case, BaoBao and DreamGrid will meet at $D(1,2)$ and then DreamGrid drives BaoBao to the shopping mall.\n\nFor the second sample test case, BaoBao and DreamGrid will meet at $D(1.5,1)$ and then DreamGrid drives BaoBao to the shopping mall.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wexb0vmz.png)", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] Pick Up", "background": "", "description": "格子城是一个位于无限二维平面上的城市，其中对于所有 $k \\in \\mathbb{Z}$（$\\mathbb{Z}$ 是所有整数的集合），直线 $x = k$ 和 $y = k$ 是城市的街道。人们只能沿着道路从一个位置移动到另一个位置。这就是为什么这个城市被称为格子城！\n\n两个朋友，宝宝和梦想格子，快乐地生活在这个城市里。今天宝宝正从他位于 $(x_A, y_A)$（$x_A, y_A \\in \\mathbb{Z}$）的家出发，前往位于 $(x_C, y_C)$（$x_C, y_C \\in \\mathbb{Z}$）的购物中心。然而，这段路对他来说太远了，所以他决定叫住在 $(x_B, y_B)$（$x_B, y_B \\in \\mathbb{Z}$）的梦想格子来帮忙。\n\n宝宝和梦想格子同时从他们的家出发。不同于以每分钟 $a$ 个单位速度步行的宝宝，梦想格子开车并以每分钟 $b$ 个单位速度移动。当梦想格子和宝宝在同一个点相遇时，梦想格子可以接上宝宝，然后他们可以一起以每分钟 $b$ 个单位速度移动。转身或接上宝宝不需要时间。\n\n从宝宝的家到购物中心所需的最短时间是多少？请注意，如果梦想格子接上宝宝会更慢，则不需要梦想格子接宝宝。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$（$1 \\le T \\le 10^5$），表示测试用例的数量。对于每个测试用例：\n\n第一行包含两个整数 $a$ 和 $b$（$1 \\le a < b \\le 10^9$），表示宝宝的步行速度和梦想格子的驾驶速度。\n\n第二行包含六个整数 $x_A$，$y_A$，$x_B$，$y_B$，$x_C$ 和 $y_C$（$-10^9 \\le x_A, y_A, x_B, y_B, x_C, y_C \\le 10^9$），表示宝宝的家、梦想格子的家和购物中心的位置。保证这三点互不相同。", "outputFormat": "对于每个测试用例，输出一行，包含一个数字，表示宝宝到达购物中心的最短时间。如果你的答案的绝对误差或相对误差不超过 $10^{-6}$，则将被视为正确。\n\n**【样例解释】**\n\n对于第一个样例测试用例，宝宝和梦想格子将在 $D(1,2)$ 相遇，然后梦想格子载着宝宝去购物中心。\n\n对于第二个样例测试用例，宝宝和梦想格子将在 $D(1.5,1)$ 相遇，然后梦想格子载着宝宝去购物中心。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9644", "type": "P", "difficulty": 2, "samples": [["2\n10 4\n0101011111\n3 1\n010", "3\n1"]], "limits": {"time": [1000, 1000], "memory": [262144, 262144]}, "tags": ["2019", "二分", "O2优化", "陕西", "省赛/邀请赛"], "title": "[SNCPC2019] Turn It Off", "background": "", "description": "It's already 21:30 now, and it's time for BaoBao to go to bed. To ensure his sleeping quality, BaoBao decides to turn all the lights in his bedroom off.\n\nThere are $n$ lights, numbered from 1 to $n$, arranged in a row in BaoBao's bedroom. Each time BaoBao can select an integer $i$ and turn all the lights numbered from $i$ to $(i+L-1)$ (both inclusive) off, where $L$ is a predefined positive integer. Note that each time the value of $L$ must be the same.\n\nGiven the initial status of all the lights, please help BaoBao determine the smallest possible $L$ so that he can turn all the lights off within $k$ times.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 2 \\times 10^5$).\n\nThe second line contains a string $s$ ($|s| = n$, $s \\in \\{\\text{`0'}, \\text{`1'}\\}$) indicating the initial status of the lights. Let $s_i$ be the $i$-th character in $s$, if $s_i = \\text{`1'}$ then the $i$-th light is initially on, otherwise it's initially off. It's guaranteed that there is at least one `1· in $s$.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $2 \\times 10^6$.", "outputFormat": "For each test case output one line containing one integer, indicating the smallest possible $L$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] Turn It Off", "background": "", "description": "It's already 21:30 now, and it's time for BaoBao to go to bed. To ensure his sleeping quality, BaoBao decides to turn all the lights in his bedroom off.\n\nThere are $n$ lights, numbered from 1 to $n$, arranged in a row in BaoBao's bedroom. Each time BaoBao can select an integer $i$ and turn all the lights numbered from $i$ to $(i+L-1)$ (both inclusive) off, where $L$ is a predefined positive integer. Note that each time the value of $L$ must be the same.\n\nGiven the initial status of all the lights, please help BaoBao determine the smallest possible $L$ so that he can turn all the lights off within $k$ times.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 2 \\times 10^5$).\n\nThe second line contains a string $s$ ($|s| = n$, $s \\in \\{\\text{`0'}, \\text{`1'}\\}$) indicating the initial status of the lights. Let $s_i$ be the $i$-th character in $s$, if $s_i = \\text{`1'}$ then the $i$-th light is initially on, otherwise it's initially off. It's guaranteed that there is at least one `1· in $s$.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $2 \\times 10^6$.", "outputFormat": "For each test case output one line containing one integer, indicating the smallest possible $L$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] Turn It Off", "background": null, "description": "现在已经是 21:30 了，宝宝该上床睡觉了。为了确保他的睡眠质量，宝宝决定关掉卧室里的所有灯。\n\n宝宝的卧室里有 $n$ 盏灯，从 $1$ 到 $n$ 排成一排。每次宝宝可以选择一个整数 $i$，并将从第 $i$ 盏灯到第 $(i+L-1)$ 盏灯（包括两端）之间的所有灯关掉，其中 $L$ 是一个预定义的正整数。注意，每次操作的 $L$ 值必须相同。\n\n给定所有灯的初始状态，请帮助宝宝确定可能的最小 $L$ 使得他能在 $k$ 次操作内关掉所有的灯。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含两个整数 $n$ 和 $k$（$1 \\le k \\le n \\le 2 \\times 10^5$）。\n\n第二行包含一个字符串 $s$（$|s| = n$, $s \\in \\{\\text{`0'}, \\text{`1'}\\}$）表示灯的初始状态。设 $s_i$ 为字符串 $s$ 的第 $i$ 个字符，如果 $s_i = \\text{`1'}$，则第 $i$ 盏灯初始是亮的，否则是灭的。保证 $s$ 中至少有一个 `1`。\n\n保证所有测试用例的 $n$ 之和不超过 $2 \\times 10^6$。", "outputFormat": "对于每个测试用例输出一行，包含一个整数，表示可能的最小 $L$。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P9645", "type": "P", "difficulty": 1, "samples": [["4\n11 18 5\n3 49 4\n1 9 1\n1 3 10", "12\n24\n3\n-1"]], "limits": {"time": [1000, 1000], "memory": [262144, 262144]}, "tags": ["数学", "2019", "Special Judge", "O2优化", "陕西", "省赛/邀请赛"], "title": "[SNCPC2019] K-hour Clock", "background": "", "description": "A $k$-hour clock is a day keeping method which follows the rules below:\n\n- A day is divided into $k$ hours, where the $i$-th hour is called the $(i-1)$ o' clock;\n- If it's $x$ o'clock now, it will be $(x+1)$ o'clock after $1$ hour if $0 \\le x < k - 1$;\n- If it's $(k - 1)$ o'clock now, it will be $0$ o'clock after $1$ hour.\n\nWe know that it's $x$ o'clock now, and after $y$ hours it will be $z$ o'clock. What's the value of $k$?\n", "inputFormat": "There are multiple test cases. The first line of the input is an integer $T$ (about $10^5$), indicating the number of test cases. For each test case:\n\nThe first and only line contains three integers $x$, $y$ and $z$ ($0 \\le x, z \\le 10^9$, $1 \\le y \\le 10^9$).", "outputFormat": "For each test case output one line containing one integer, indicating the value of $k$. Note that there must be $1 \\le k \\le 2 \\times 10^9$. If there are multiple valid answers, you can print any of them; If there is no valid answer, print ``-1`` (without quotes) instead.", "hint": "", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] K-hour Clock", "background": "", "description": "A $k$-hour clock is a day keeping method which follows the rules below:\n\n- A day is divided into $k$ hours, where the $i$-th hour is called the $(i-1)$ o' clock;\n- If it's $x$ o'clock now, it will be $(x+1)$ o'clock after $1$ hour if $0 \\le x < k - 1$;\n- If it's $(k - 1)$ o'clock now, it will be $0$ o'clock after $1$ hour.\n\nWe know that it's $x$ o'clock now, and after $y$ hours it will be $z$ o'clock. What's the value of $k$?\n", "inputFormat": "There are multiple test cases. The first line of the input is an integer $T$ (about $10^5$), indicating the number of test cases. For each test case:\n\nThe first and only line contains three integers $x$, $y$ and $z$ ($0 \\le x, z \\le 10^9$, $1 \\le y \\le 10^9$).", "outputFormat": "For each test case output one line containing one integer, indicating the value of $k$. Note that there must be $1 \\le k \\le 2 \\times 10^9$. If there are multiple valid answers, you can print any of them; If there is no valid answer, print ``-1`` (without quotes) instead.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] K-hour Clock", "background": "", "description": "一个 $k$ 小时制的时钟是一种计时方法，遵循以下规则：\n\n- 一天被分为 $k$ 小时，其中第 $i$ 小时称为 $(i-1)$ 点；\n- 如果现在是 $x$ 点，那么在 $1$ 小时后将是 $(x+1)$ 点，前提是 $0 \\le x < k - 1$；\n- 如果现在是 $(k - 1)$ 点，那么在 $1$ 小时后将是 $0$ 点。\n\n我们知道现在是 $x$ 点，经过 $y$ 小时后将是 $z$ 点。求 $k$ 的值。", "inputFormat": "有多个测试用例。输入的第一行是一个整数 $T$（约 $10^5$），表示测试用例的数量。对于每个测试用例：\n\n第一行包含三个整数 $x$、$y$ 和 $z$（$0 \\le x, z \\le 10^9$，$1 \\le y \\le 10^9$）。", "outputFormat": "对于每个测试用例输出一行，包含一个整数，表示 $k$ 的值。注意必须有 $1 \\le k \\le 2 \\times 10^9$。如果有多个有效答案，可以输出其中任意一个；如果没有有效答案，则输出 “-1”（不带引号）。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9646", "type": "P", "difficulty": 6, "samples": [["3\n2 5\n11001\n11001\n5 7\n1001100\n0110011\n0101101\n0010010\n1000000\n3 2\n11\n11\n11", "1\n4\n0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "O2优化", "陕西", "Manacher 算法", "省赛/邀请赛"], "title": "[SNCPC2019] Paper-cutting", "background": "", "description": "Paper-cutting is one of the oldest and most popular folk arts in China. It can be geographically divided into a southern and a northern style. The southern style, represented by works from Yangzhou in Jiangsu Province and Yueqing in Zhejiang Province, features ingenious and beautiful designs, exquisite carving and interesting shapes. The northern style, mainly from Yuxian and Fengning in Hebei Province and best represented by works from northern Shaanxi, features exaggerated shapes, vigorousness, vivid depictions, and diverse patterns.\n\nThere are basic cut-outs, consisting of a single image, and symmetrical designs, that are usually created by some folding over a proportioned crease, and then cutting a shape, so that when unfolded, it forms a symmetrical design. Chinese paper cuttings are usually symmetrical. The paper cutouts are usually in an even number series of $2$, $4$, $24$, etc.\n\nYou are given a piece of paper in the shape of a matrix of size $n \\times m$. It is partitioned into $n \\times m$ blocks of size $1 \\times 1$. The piece of paper can be folded in the following way:\n\n- You choose a vertical line between two of its columns or a horizontal line between two of its rows. This line splits the paper into two sides. \n- You use the line as the folding axis and fold the smaller side of the paper onto the larger one going over the axis. If both sides of the paper are of equal size, you may fold from either side.\n\nYou would like to make a paper-cutting masterpiece from this paper. At first, you fold the paper using the method above several times (including zero times). Then you use scissors to cut the paper. Each time you cut, you can cut out a connected component from the folded paper (even if the component is not reachable from outside) and throw it away. Note that two $1 \\times 1$ blocks are connected if they share an edge.\n\nGiven the final look of the paper, which is a matrix of size $n \\times m$ containing $0$s and $1$s, you would like to know the minimum number of cuts needed when using the scissors. \n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\times m \\le 10^6$): the size of the paper.\n\nEach of the next $n$ lines contains a binary string of length $m$, where $\\texttt{0}$ means the $1 \\times 1$ block is cut out and $\\texttt{1}$ means the $1 \\times 1$ block remains on the final paper-cutting.\n\nIt is guaranteed that the sum of $n \\times m$ over all test cases does not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer, indicating the minimum number of cuts needed.", "hint": "For the first sample test case, you can fold in the following way and cut the only $0$ out:\n$$\\begin{array}{ccc|cc} 1&1&0&0&1\\\\1&1&0&0&1\\end{array} \\to \\begin{array}{ccc} 1&1&0\\\\ \\hline 1&1&0\\end{array} \\to \\begin{array}{ccc} 1&1&0\\end{array}$$\n\nFor the second sample test case, you can fold in the following way and cut the $4$ connected components of $0$s out:\n$$\\begin{array}{cccc|ccc} 1&0&0&1&1&0&0\\\\0&1&1&0&0&1&1\\\\0&1&0&1&1&0&1\\\\0&0&1&0&0&1&0\\\\1&0&0&0&0&0&0\\end{array} \\to \\begin{array}{cccc} 1&0&0&1\\\\0&1&1&0\\\\0&1&0&1\\\\0&0&1&0\\\\1&0&0&0\\end{array}$$", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] Paper-cutting", "background": "", "description": "Paper-cutting is one of the oldest and most popular folk arts in China. It can be geographically divided into a southern and a northern style. The southern style, represented by works from Yangzhou in Jiangsu Province and Yueqing in Zhejiang Province, features ingenious and beautiful designs, exquisite carving and interesting shapes. The northern style, mainly from Yuxian and Fengning in Hebei Province and best represented by works from northern Shaanxi, features exaggerated shapes, vigorousness, vivid depictions, and diverse patterns.\n\nThere are basic cut-outs, consisting of a single image, and symmetrical designs, that are usually created by some folding over a proportioned crease, and then cutting a shape, so that when unfolded, it forms a symmetrical design. Chinese paper cuttings are usually symmetrical. The paper cutouts are usually in an even number series of $2$, $4$, $24$, etc.\n\nYou are given a piece of paper in the shape of a matrix of size $n \\times m$. It is partitioned into $n \\times m$ blocks of size $1 \\times 1$. The piece of paper can be folded in the following way:\n\n- You choose a vertical line between two of its columns or a horizontal line between two of its rows. This line splits the paper into two sides. \n- You use the line as the folding axis and fold the smaller side of the paper onto the larger one going over the axis. If both sides of the paper are of equal size, you may fold from either side.\n\nYou would like to make a paper-cutting masterpiece from this paper. At first, you fold the paper using the method above several times (including zero times). Then you use scissors to cut the paper. Each time you cut, you can cut out a connected component from the folded paper (even if the component is not reachable from outside) and throw it away. Note that two $1 \\times 1$ blocks are connected if they share an edge.\n\nGiven the final look of the paper, which is a matrix of size $n \\times m$ containing $0$s and $1$s, you would like to know the minimum number of cuts needed when using the scissors. \n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\times m \\le 10^6$): the size of the paper.\n\nEach of the next $n$ lines contains a binary string of length $m$, where $\\texttt{0}$ means the $1 \\times 1$ block is cut out and $\\texttt{1}$ means the $1 \\times 1$ block remains on the final paper-cutting.\n\nIt is guaranteed that the sum of $n \\times m$ over all test cases does not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer, indicating the minimum number of cuts needed.", "hint": "For the first sample test case, you can fold in the following way and cut the only $0$ out:\n$$\\begin{array}{ccc|cc} 1&1&0&0&1\\\\1&1&0&0&1\\end{array} \\to \\begin{array}{ccc} 1&1&0\\\\ \\hline 1&1&0\\end{array} \\to \\begin{array}{ccc} 1&1&0\\end{array}$$\n\nFor the second sample test case, you can fold in the following way and cut the $4$ connected components of $0$s out:\n$$\\begin{array}{cccc|ccc} 1&0&0&1&1&0&0\\\\0&1&1&0&0&1&1\\\\0&1&0&1&1&0&1\\\\0&0&1&0&0&1&0\\\\1&0&0&0&0&0&0\\end{array} \\to \\begin{array}{cccc} 1&0&0&1\\\\0&1&1&0\\\\0&1&0&1\\\\0&0&1&0\\\\1&0&0&0\\end{array}$$", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] Paper-cutting", "background": "", "description": "剪纸是中国最古老、最受欢迎的民间艺术之一。它在地理上可以分为南方风格和北方风格。以江苏扬州、浙江乐清作品为代表的南方风格，设计巧妙美观，雕刻精美，造型有趣。北方风格以河北蔚县、丰宁为主体，以陕北作品为代表，造型夸张、气势恢宏、刻画生动、图案多样。\n\n基本的裁剪由单个图像组成，还有对称的设计，通常是通过在成比例的折痕上折叠，然后裁成一个形状，当展开时，就形成了对称的设计。中国剪纸通常是对称的。剪纸通常是 $2$、 $4$ 、 $24$ 等偶数系列。\n\n你会得到一张大小为 $n \\times m$ 的纸， 它被划分为 $n \\times m$ 个大小为 $1 \\times 1$ 的块在。这张纸可以按以下方式折叠：\n\n- 可以在两列之间选择一条垂直线，也可以在两行之间选择一条水平线。这条线把纸分成两面。\n\n- 你用这条线作为对称轴，把小的一面折到大的一面上。如果纸的两面大小相等，从两边对折。\n\n你想用这张纸做一幅剪纸杰作。首先，使用上述方法将纸张折叠几次（包括零次）。然后你用剪刀剪纸。每次剪切时，都可以从折叠的纸上剪切出一个连接的部分（即使从外面无法接触到该部分并将其扔掉。请注意，如果两个 $ 1\\times 1$ 的块共享一条边，则它们是连接的。\n\n纸张的最终外观是一个包含 $0$ 和 $1$ 的大小为 $n \\times m$ 的矩阵，你想知道需要使用剪刀时的最小裁剪次数。", "inputFormat": "有多个测试数据。输入的第一行包含一个整数 $T$ ，表示测试数据的数量。对于每个测试数据：\n\n第一行包含两个整数 $n$ 和 $m$ ( $1 \\le n \\times m \\le 10^6$ )表示纸张的大小。\n\n接下来的 $n$ 行中的每一行都包含一个长度为 $m$ 的01字符串，其中 $\\texttt{0}$ 表示 $1\\times 1$ 块被剪切掉， $\\texttt{1}$ 意味着 $1 \\times 1$ 块保留在最后的剪纸上。\n\n保证所有测试数据的 $n \\times m$ 之和不超过 $10^6$ 。", "outputFormat": "对于每个测试数据输出一行，其中包含一个整数，表示所需的最小裁剪次数。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n3\n2 5\n11001\n11001\n5 7\n1001100\n0110011\n0101101\n0010010\n1000000\n3 2\n11\n11\n11\n```\n\n### 样例输出 #1\n\n```\n1\n4\n0\n```", "hint": "对于样例一,你可以通过这种方式将唯一的 $0$ 剪出:\n$$\\begin{array}{ccc|cc} 1&1&0&0&1\\\\1&1&0&0&1\\end{array} \\to \\begin{array}{ccc} 1&1&0\\\\ \\hline 1&1&0\\end{array} \\to \\begin{array}{ccc} 1&1&0\\end{array}$$\n\n对于样例二，你可以按照以下方式折叠并裁剪出 $0$ 的 $4$ 个连通块：\n$$\\begin{array}{cccc|ccc} 1&0&0&1&1&0&0\\\\0&1&1&0&0&1&1\\\\0&1&0&1&1&0&1\\\\0&0&1&0&0&1&0\\\\1&0&0&0&0&0&0\\end{array} \\to \\begin{array}{cccc} 1&0&0&1\\\\0&1&1&0\\\\0&1&0&1\\\\0&0&1&0\\\\1&0&0&0\\end{array}$$", "locale": "zh-CN"}}}
{"pid": "P9647", "type": "P", "difficulty": 4, "samples": [["3\n1\n4\n6\n", "0\n1 2 4\n2 2 4 3 6\n"]], "limits": {"time": [1000, 1000], "memory": [262144, 262144]}, "tags": ["2019", "Special Judge", "O2优化", "陕西", "素数判断,质数,筛法", "省赛/邀请赛"], "title": "[SNCPC2019] To the Park", "background": "", "description": "BaoBao and his $(n-1)$ classmates are going to the park. For convenience, their teacher DreamGrid has numbered the students from 1 to $n$ and decides to form the students into some groups, where each group consists of exactly two students.\n\nFor some reason, DreamGrid requires that the indices of the two students in the same group should have a common divisor greater than 1. Note that each student can only belong to at most one group, and it's not necessary that every student belongs to a group.\n\nPlease help DreamGrid form as many groups as possible.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first and only line contains an integer $n$ ($1 \\le n \\le 10^5$), indicating the number of students.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.\n", "outputFormat": "For each test case output one line. The line first contains an integer $k$ indicating the number of groups, then $2k$ integers $a_1, a_2, \\dots, a_{2k}$ follow, indicating that student $a_1$ and $a_2$ belong to the same group, student $a_3$ and $a_4$ belong to the same group, ..., student $a_{2k-1}$ and $a_{2k}$ belong to the same group. The integers in a line are separated by a space. If there are multiple valid answers, you can print any of them.\n\nPlease, DO NOT output extra spaces at the end of each line, or your solution may be considered incorrect!", "hint": "", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] To the Park", "background": "", "description": "BaoBao and his $(n-1)$ classmates are going to the park. For convenience, their teacher DreamGrid has numbered the students from 1 to $n$ and decides to form the students into some groups, where each group consists of exactly two students.\n\nFor some reason, DreamGrid requires that the indices of the two students in the same group should have a common divisor greater than 1. Note that each student can only belong to at most one group, and it's not necessary that every student belongs to a group.\n\nPlease help DreamGrid form as many groups as possible.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first and only line contains an integer $n$ ($1 \\le n \\le 10^5$), indicating the number of students.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.\n", "outputFormat": "For each test case output one line. The line first contains an integer $k$ indicating the number of groups, then $2k$ integers $a_1, a_2, \\dots, a_{2k}$ follow, indicating that student $a_1$ and $a_2$ belong to the same group, student $a_3$ and $a_4$ belong to the same group, ..., student $a_{2k-1}$ and $a_{2k}$ belong to the same group. The integers in a line are separated by a space. If there are multiple valid answers, you can print any of them.\n\nPlease, DO NOT output extra spaces at the end of each line, or your solution may be considered incorrect!", "hint": "", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] To the Park", "background": "", "description": "宝宝和他的 $(n-1)$ 个同学要去公园。为了方便，他们的老师梦想格子将学生从 1 到 $n$ 编号，并决定将学生分成一些小组，每组恰好由两个学生组成。\n\n由于某种原因，梦想格子要求同组的两个学生的编号必须有一个大于 1 的公约数。注意，每个学生最多只能属于一个小组，并且不需要每个学生都属于一个小组。\n\n请帮助梦想格子组成尽可能多的小组。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行且唯一一行包含一个整数 $n$ ($1 \\le n \\le 10^5$)，表示学生的数量。\n\n保证所有测试用例的 $n$ 之和不超过 $10^6$。", "outputFormat": "对于每个测试用例，输出一行。该行首先包含一个整数 $k$，表示小组的数量，然后是 $2k$ 个整数 $a_1, a_2, \\dots, a_{2k}$，表示学生 $a_1$ 和 $a_2$ 属于同一小组，学生 $a_3$ 和 $a_4$ 属于同一小组，以此类推。行内的整数由空格分隔。如果有多个有效答案，可以输出其中任何一个。\n\n请不要在每行的末尾输出多余的空格，否则你的解决方案可能会被认为不正确！\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9648", "type": "P", "difficulty": 4, "samples": [["2\n6\n3 1 a\n3 2 a\n3 4 b\n4 5 c\n4 6 d\n6\n3 1 a\n3 2 a\n3 4 b\n5 4 c\n6 4 c\n", "2\n0\n"]], "limits": {"time": [3000, 3000], "memory": [262144, 262144]}, "tags": ["2019", "O2优化", "陕西", "树的遍历", "省赛/邀请赛"], "title": "[SNCPC2019] Unrooted Trie", "background": "", "description": "Recall the definition of a trie:\n\n- A trie of size $n$ is a rooted tree with $n$ vertices and $(n-1)$ edges, where each edge is marked with a character;\n- Each vertex in a trie represents a string. Let $s(x)$ be the string vertex $x$ represents;\n- The root of the trie represents an empty string. Let vertex $u$ be the parent of vertex $v$, and let $c$ be the character marked on the edge connecting vertex $u$ and $v$, we have $s(v)$ = $s(u) + c$. Here $+$ indicates string concatenation, not the normal addition operation.\n\nWe say a trie is valid, if the string each vertex represents is distinct.\n\nGiven an unrooted tree with $n$ vertices and $(n-1)$ edges, where each edge is marked with a character, how many different vertices can be selected as the root of the tree so that the tree becomes a valid trie?\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$), indicating the size of the tree.\n\nFor the following $(n-1)$ lines, the $i$-th line contains two integers $u_i$, $v_i$ ($1 \\le u_i, v_i \\le n$) and a character $c_i$ separated by a space, indicating that there is an edge marked with a character $c_i$ connecting vertex $u_i$ and $v_i$. It's guaranteed that $c_i$ will only be lower-case English letters.\n\nIt's guaranteed that the given graph is a tree, and the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer, indicating the number of different vertices that can be selected as the root of the tree to make it a valid trie.\n", "hint": "For the first sample test case, we can only select vertex 1 or vertex 2 as the root, otherwise $s(1)$ and $s(2)$ will be the same.\n\nFor the second sample test case, no matter which vertex we select as the root, $s(1)$ and $s(2)$, or $s(5)$ and $s(6)$ will be the same.\n", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] Unrooted Trie", "background": "", "description": "Recall the definition of a trie:\n\n- A trie of size $n$ is a rooted tree with $n$ vertices and $(n-1)$ edges, where each edge is marked with a character;\n- Each vertex in a trie represents a string. Let $s(x)$ be the string vertex $x$ represents;\n- The root of the trie represents an empty string. Let vertex $u$ be the parent of vertex $v$, and let $c$ be the character marked on the edge connecting vertex $u$ and $v$, we have $s(v)$ = $s(u) + c$. Here $+$ indicates string concatenation, not the normal addition operation.\n\nWe say a trie is valid, if the string each vertex represents is distinct.\n\nGiven an unrooted tree with $n$ vertices and $(n-1)$ edges, where each edge is marked with a character, how many different vertices can be selected as the root of the tree so that the tree becomes a valid trie?\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$), indicating the size of the tree.\n\nFor the following $(n-1)$ lines, the $i$-th line contains two integers $u_i$, $v_i$ ($1 \\le u_i, v_i \\le n$) and a character $c_i$ separated by a space, indicating that there is an edge marked with a character $c_i$ connecting vertex $u_i$ and $v_i$. It's guaranteed that $c_i$ will only be lower-case English letters.\n\nIt's guaranteed that the given graph is a tree, and the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer, indicating the number of different vertices that can be selected as the root of the tree to make it a valid trie.\n", "hint": "For the first sample test case, we can only select vertex 1 or vertex 2 as the root, otherwise $s(1)$ and $s(2)$ will be the same.\n\nFor the second sample test case, no matter which vertex we select as the root, $s(1)$ and $s(2)$, or $s(5)$ and $s(6)$ will be the same.\n", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] Unrooted Trie", "background": "", "description": "### 题目背景\n\ntrie 的定义是这样的：\n\n- 一棵大小为 $n$ 的 trie，是一棵有着 $n$ 个节点和 $(n-1)$ 条边的有根树，每一条边上都标有一个字符；\n\n- 在 trie 中，从根结点到树上某一结点的路径代表一个字符串，节点 $x$ 代表的字符串记为 $s(x)$，特别地，根节点代表的字符串为空串。\n\n- 若节点 $u$ 是节点 $v$ 的父节点，且 $c$ 是连接 $u$ 与 $v$ 的边上的字符，则有 $s(v) = s(u) + c$（这里的 $+$ 表示字符串的连接，而非普通的加法运算）。\n\n当每一个节点代表的字符串互不相同时，该 trie 是合法的。\n\n\n给出一个无根的 trie，求其中有多少节点可作为该 trie 的根，使得该 trie 合法。", "inputFormat": "**每个测试点由多组数据组成。**\n\n输入的第一行包含一个正整数 $T$，代表测试数据的组数。\n\n对于每组测试数据：\n\n数据的第一行包含一个正整数 $n$，代表 trie 的大小。\n\n接下来的 $(n-1)$ 行中，第 $i$ 行包含两个正整数 $u_i,v_i$ 以及一个字符 $c_i$，用空格隔开，表示有一条标有 $c_i$ 的边连接着 $u_i$ 和 $v_i$。", "outputFormat": "对于每组测试数据，输出一行一个正整数，表示可以成为根后可以使该 trie 合法的节点的个数。", "hint": "【样例解释】\n\n对于第一组测试数据，只能选择节点 $1$ 或节点 $2$ 作为根，否则 $s(1)$ 和 $s(2)$ 相同。\n\n对于第二组测试数据，无论如何选择节点作为根，$s(1)$ 和 $s(2)$ 或 $s(5)$ 和 $s(6)$ 相同。\n\n\n对于每组数据，$1 \\le n \\le 2 \\times 10^5$，$1 \\le u_i,v_i \\le n$，$c_i$ 都是小写字母。\n\n对于每个测试点，保证给出的图是一棵树，所有的 $n$ 之和不会超过 $10^6$。", "locale": "zh-CN"}}}
{"pid": "P9649", "type": "P", "difficulty": 3, "samples": [["2\n3\n0 8\n2 6\n3 9\n1\n1 100\n", "6\n100\n"]], "limits": {"time": [3000, 3000], "memory": [262144, 262144]}, "tags": ["贪心", "2019", "O2优化", "陕西", "进制", "省赛/邀请赛"], "title": "[SNCPC2019] Coolbits", "background": "", "description": "Given $n$ intervals $[l_1, r_1], [l_2, r_2], \\dots, [l_n, r_n]$, one must select an integer from each of the intervals and calculate their bitwise and value $b$. What's the maximum possible $b$ one can get?\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$), indicating the number of intervals.\n\nFor the following $n$ lines, the $i$-th line contains two integers $l_i$ and $r_i$ ($0 \\le l_i \\le r_i \\le 10^9$), indicating the $i$-th interval.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.\n", "outputFormat": "For each test case output one line containing one integer, indicating the maximum possible $b$ one can get.\n", "hint": "For the first sample test case, one can select 7, 6 and  7 from the three intervals and get their bitwise and value 6.", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] Coolbits", "background": "", "description": "Given $n$ intervals $[l_1, r_1], [l_2, r_2], \\dots, [l_n, r_n]$, one must select an integer from each of the intervals and calculate their bitwise and value $b$. What's the maximum possible $b$ one can get?\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$), indicating the number of intervals.\n\nFor the following $n$ lines, the $i$-th line contains two integers $l_i$ and $r_i$ ($0 \\le l_i \\le r_i \\le 10^9$), indicating the $i$-th interval.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.\n", "outputFormat": "For each test case output one line containing one integer, indicating the maximum possible $b$ one can get.\n", "hint": "For the first sample test case, one can select 7, 6 and  7 from the three intervals and get their bitwise and value 6.", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] Coolbits", "background": "", "description": "给定 $n$ 个区间 $[l_1, r_1], [l_2, r_2], \\dots, [l_n, r_n]$，需要从每个区间中选择一个整数并计算它们的按位与值 $b$。能够得到的最大 $b$ 是多少？", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含一个整数 $n$ ($1 \\le n \\le 10^5$)，表示区间的数量。\n\n接下来的 $n$ 行，第 $i$ 行包含两个整数 $l_i$ 和 $r_i$ ($0 \\le l_i \\le r_i \\le 10^9$)，表示第 $i$ 个区间。\n\n保证所有测试用例的 $n$ 之和不超过 $10^6$。", "outputFormat": "对于每个测试用例输出一行，包含一个整数，表示能得到的最大可能 $b$。\n\n**【样例解释】**\n\n对于第一个样例测试用例，可以从三个区间中选择 7、6 和 7，并得到它们的按位与值 6。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9650", "type": "P", "difficulty": 4, "samples": [["2\n3 4 1\n3\n1 1 1\n1 2 1\n1 2 2\n2 3 1\n2 3 2\n3 2 2\n2 3\n2 0 0\n1 2 1\n1 3 1\n", "4\n-1\n"]], "limits": {"time": [4000, 4000], "memory": [262144, 262144]}, "tags": ["2019", "O2优化", "最短路", "陕西", "省赛/邀请赛"], "title": "[SNCPC2019] Escape Plan", "background": "", "description": "BaoBao, one of the most famous monster hunters, wakes up in the middle of Heltion City dominated by monsters. Having troubles remembering what has happened, BaoBao decides to escape from this horrible city as soon as possible. Despite arming no weapon, he luckily puts his hand on a map in his right pocket, which contains valuable information that can possibly help him find a way out.  \n\nAccording to the map, Heltion City is composed of $n$ spots connected by $m$ undirected paths. Starting from spot $1$, BaoBao must head towards any of the $k$ exits of the city to escape, where the $i$-th of them is located at spot $e_i$.\n\nHowever, it's not an easy task for BaoBao to escape since monsters are everywhere in the city! For all $1 \\le i \\le n$, $d_i$ monsters are wandering near the $i$-th spot, so right after BaoBao arrives at that spot, at most $d_i$ paths connecting the spot will be blocked by monsters and are unable for BaoBao to pass. When BaoBao leaves the $i$-th spot, the monsters will go back to their nests and the blocked paths are clear. Of course, if BaoBao comes back to the spot, at most $d_i$ paths will be again blocked by the monsters. The paths blocked each time may differ.\n\nAs BaoBao doesn't know which paths will be blocked, please help him calculate the shortest time he can escape from the city in the worst case.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ (about $100$), indicating the number of test cases. For each test case:\n\nThe first line contains three integers $n$, $m$ and $k$ ($1 \\le n \\le 10^5$, $1 \\le m \\le 10^6$, $1 \\le k \\le n$), indicating the number of spots, the number of undirected paths and the number of exits of the city.\n\nThe second line contains $k$ distinct integers $e_1, e_2, \\dots, e_k$ ($1 \\le e_i \\le n$), indicating $k$ exits of Heltion City.\n\nThe third line contains $n$ integers $d_1, d_2, \\dots, d_n$ ($0 \\le d_i \\le m$), where $d_i$ indicates the number of monsters at the $i$-th spot.\n\nFor the following $m$ lines, the $i$-th line contains three integers $x_i$, $y_i$ and $w_i$ ($1 \\le x_i,y_i \\le n$, $x_i \\neq y_i$, $1 \\le w_i \\le 10^4$), indicating an undirected edge of length $w_i$ connecting spot $x_i$ and $y_i$.\n\nIt's guaranteed that the total sum of $n$ will not exceed $10^6$ and the total sum of $m$ will not exceed $3 \\times 10^6$. \n", "outputFormat": "For each case output one line containing one integer. If BaoBao can get to some exit in the worst case, output the shortest possible time cost; Otherwise if BaoBao cannot get to any exit in the worst case, output ``-1``  instead.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] Escape Plan", "background": "", "description": "BaoBao, one of the most famous monster hunters, wakes up in the middle of Heltion City dominated by monsters. Having troubles remembering what has happened, BaoBao decides to escape from this horrible city as soon as possible. Despite arming no weapon, he luckily puts his hand on a map in his right pocket, which contains valuable information that can possibly help him find a way out.  \n\nAccording to the map, Heltion City is composed of $n$ spots connected by $m$ undirected paths. Starting from spot $1$, BaoBao must head towards any of the $k$ exits of the city to escape, where the $i$-th of them is located at spot $e_i$.\n\nHowever, it's not an easy task for BaoBao to escape since monsters are everywhere in the city! For all $1 \\le i \\le n$, $d_i$ monsters are wandering near the $i$-th spot, so right after BaoBao arrives at that spot, at most $d_i$ paths connecting the spot will be blocked by monsters and are unable for BaoBao to pass. When BaoBao leaves the $i$-th spot, the monsters will go back to their nests and the blocked paths are clear. Of course, if BaoBao comes back to the spot, at most $d_i$ paths will be again blocked by the monsters. The paths blocked each time may differ.\n\nAs BaoBao doesn't know which paths will be blocked, please help him calculate the shortest time he can escape from the city in the worst case.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ (about $100$), indicating the number of test cases. For each test case:\n\nThe first line contains three integers $n$, $m$ and $k$ ($1 \\le n \\le 10^5$, $1 \\le m \\le 10^6$, $1 \\le k \\le n$), indicating the number of spots, the number of undirected paths and the number of exits of the city.\n\nThe second line contains $k$ distinct integers $e_1, e_2, \\dots, e_k$ ($1 \\le e_i \\le n$), indicating $k$ exits of Heltion City.\n\nThe third line contains $n$ integers $d_1, d_2, \\dots, d_n$ ($0 \\le d_i \\le m$), where $d_i$ indicates the number of monsters at the $i$-th spot.\n\nFor the following $m$ lines, the $i$-th line contains three integers $x_i$, $y_i$ and $w_i$ ($1 \\le x_i,y_i \\le n$, $x_i \\neq y_i$, $1 \\le w_i \\le 10^4$), indicating an undirected edge of length $w_i$ connecting spot $x_i$ and $y_i$.\n\nIt's guaranteed that the total sum of $n$ will not exceed $10^6$ and the total sum of $m$ will not exceed $3 \\times 10^6$. \n", "outputFormat": "For each case output one line containing one integer. If BaoBao can get to some exit in the worst case, output the shortest possible time cost; Otherwise if BaoBao cannot get to any exit in the worst case, output ``-1``  instead.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] Escape Plan", "background": "", "description": "宝宝被困在了 Heltion 城中。\n\n城市可以看做由 $n$ 个点与 $m$ 条边组成的**有权无向图**，最开始宝宝在 $1$ 号节点。城市中存在 $k$ 个出口，第 $i$ 个出口位置在 $e_i$ 号点 ，而宝宝需要以最快的速度到达**这些出口中的任意一个**以逃离 Heltion 城。\n\n不巧的是，城市中有怪物游荡，对于点 $i$，有 $d_i$ 只怪物驻守在此。当宝宝到达点 $i$ 时，怪物会**随机封锁至多** $d_i$ **条**与之相邻的道路，宝宝不能通过这些被封锁的道路。而当宝宝**离开后**，点 $i$ 的怪物会回窝，这时被封锁的**道路会解开**。\n\n请帮帮宝宝，求出最坏情况下，他逃出 Heltion 城需要多久。", "inputFormat": "第一行为一个正整数 $T$，表示有 $T$ 组测试数据。\n\n对于每组数据，第一行包括三个正整数 $n$，$m$，$k$，分别表示城市的点数，边数和城市中出口的数量。\n\n第二行有 $k$ 个正整数 $e_1, e_2,\\dots , e_k$，表示第 $i$ 个出口在 $e_i$ 号节点。\n\n第三行有 $n$ 个正整数 $d_1, d_2,\\dots , d_n$，表示第 $i$ 个节点上有 $d_i$ 只怪物。\n\n接下来的 $m$ 行，一行三个正整数 $x_i$，$y_i$，$w_i$，表示第 $i$ 条双向边所连接的两点与边权。", "outputFormat": "共 $T$ 行，每行一个整数。第 $i$ 行的整数表示第 $i$ 组数据的答案。\n\n对于每组数据，若宝宝不能到达任何一个出口，请输出 `-1`。否则，输出宝宝到达任意一个出口所需要的最少时间。", "hint": "对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，$\\sum n \\le 10^6$，$1\\le m \\le 10^6$，$\\sum m \\le 3\\times 10^6$，$1\\le k \\le n$，$1\\le e_i \\le n$，$0\\le d_i \\le m$，$1\\le x_i,y_i \\le n$，$1\\le w_i \\le 10^4$。数据保证 $x_i \\neq y_i$。", "locale": "zh-CN"}}}
{"pid": "P9651", "type": "P", "difficulty": 1, "samples": [["2\n1 9\n97 99\n", "362880\n367416\n"]], "limits": {"time": [1000, 1000], "memory": [262144, 262144]}, "tags": ["2019", "O2优化", "陕西", "省赛/邀请赛"], "title": "[SNCPC2019] Digit Product", "background": "", "description": "Define the ''digit product'' $f(x)$ of a positive integer $x$ as the product of all its digits. For example, $f(1234) = 1 \\times 2 \\times 3 \\times 4 = 24$, and $f(100) = 1 \\times 0 \\times 0 = 0$.\n\nGiven two integers $l$ and $r$, please calculate the following value:\n$$(\\prod_{i=l}^r f(i)) \\mod (10^9+7)$$ \nIn case that you don't know what $\\prod$ represents, the above expression is the same as \n$$(f(l) \\times f(l+1) \\times \\dots \\times f(r)) \\mod (10^9+7)$$\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ (about $10^5$), indicating the number of test cases. For each test case:\n\nThe first and only line contains two integers $l$ and $r$ ($1 \\le l \\le r \\le 10^9$), indicating the given two integers. The integers are given without leading zeros.\n", "outputFormat": "For each test case output one line containing one integer indicating the answer.", "hint": "For the first sample test case, the answer is $9! \\mod (10^9+7) = 362880$.\n\nFor the second sample test case, the answer is $(f(97) \\times f(98) \\times f(99)) \\mod (10^9+7) = (9 \\times 7 \\times 9 \\times 8 \\times 9 \\times 9) \\mod (10^9+7) = 367416$.\n", "locale": "en", "translations": {"en": {"title": "[SNCPC2019] Digit Product", "background": "", "description": "Define the ''digit product'' $f(x)$ of a positive integer $x$ as the product of all its digits. For example, $f(1234) = 1 \\times 2 \\times 3 \\times 4 = 24$, and $f(100) = 1 \\times 0 \\times 0 = 0$.\n\nGiven two integers $l$ and $r$, please calculate the following value:\n$$(\\prod_{i=l}^r f(i)) \\mod (10^9+7)$$ \nIn case that you don't know what $\\prod$ represents, the above expression is the same as \n$$(f(l) \\times f(l+1) \\times \\dots \\times f(r)) \\mod (10^9+7)$$\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ (about $10^5$), indicating the number of test cases. For each test case:\n\nThe first and only line contains two integers $l$ and $r$ ($1 \\le l \\le r \\le 10^9$), indicating the given two integers. The integers are given without leading zeros.\n", "outputFormat": "For each test case output one line containing one integer indicating the answer.", "hint": "For the first sample test case, the answer is $9! \\mod (10^9+7) = 362880$.\n\nFor the second sample test case, the answer is $(f(97) \\times f(98) \\times f(99)) \\mod (10^9+7) = (9 \\times 7 \\times 9 \\times 8 \\times 9 \\times 9) \\mod (10^9+7) = 367416$.\n", "locale": "en"}, "zh-CN": {"title": "[SNCPC2019] Digit Product", "background": "", "description": "定义正整数 $x$ 的 \"数字乘积\" $f(x)$ 为其所有数字的乘积。例如，$f(1234) = 1 \\times 2 \\times 3 \\times 4 = 24$，$f(100) = 1 \\times 0 \\times 0 = 0$。\n\n给定两个整数 $l$ 和 $r$，请计算以下值：\n$$(\\prod_{i=l}^r f(i)) \\mod (10^9+7)$$ \n如果你不知道 $\\prod$ 表示什么，上述表达式等同于 \n$$(f(l) \\times f(l+1) \\times \\dots \\times f(r)) \\mod (10^9+7)$$", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$（大约 $10^5$），表示测试用例的数量。对于每个测试用例：\n\n第一行且唯一一行包含两个整数 $l$ 和 $r$（$1 \\le l \\le r \\le 10^9$），表示给定的两个整数。这些整数没有前导零。", "outputFormat": "对于每个测试用例，输出一行，包含一个整数，表示答案。\n\n**【样例解释】**\n\n对于第一个样例测试用例，答案是 $9! \\mod (10^9+7) = 362880$。\n\n对于第二个样例测试用例，答案是 $(f(97) \\times f(98) \\times f(99)) \\mod (10^9+7) = (9 \\times 7 \\times 9 \\times 8 \\times 9 \\times 9) \\mod (10^9+7) = 367416$。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9652", "type": "P", "difficulty": 2, "samples": [["5\n1 5 4\n2 3 8\n1 5 10\n2 6 34\n1 3 1", "1 1 1 1 1\n2 2 3\n1 1 1 7 7\n1 1 4 5 1 4\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "洛谷原创", "Special Judge", "O2优化", "构造", "洛谷月赛"], "title": "『GROI-R2』 紫水晶", "background": "", "description": "爱丽丝不曾忘记过她曾经存在于纸牌的世界。\n\n于是魔法让她的手里出现了一些牌，同时魔法也让坦尼尔手里出现了一些牌，而且每张牌上都写着一个正整数——尽管他们如今所处的，是玻璃王国的世界中。\n\n牌张很快一消而散，而他们也准备启程。爱丽丝只记住了每相邻两张牌的**最大公约数之和**，坦尼尔只记住了每相邻两张牌的**最小公倍数之和**。\n\n你还在这个宫殿里，你想重现当时的牌张。\n\n**形式化题面**\n\n给定 $q$ 次询问，每次询问为以下两种之一：\n\n- ``1 n x`` 表示要求输出一长度为 $n$ 的**正整数**序列 $\\{a_n\\}$，使得 $\\sum\\limits_{i=1}^{n-1} \\gcd(a_i,a_{i+1})=x$。\n\n- ``2 n x`` 表示要求输出一长度为 $n$ 的**正整数**序列 $\\{a_n\\}$，使得 $\\sum\\limits_{i=1}^{n-1} \\operatorname{lcm}(a_i,a_{i+1})=x$。\n\n且对于任意输出的 $a_i$ 不应超出 C++ 语言中 ``int`` 的存储范围。\n\n其中 $\\gcd$ 和 $\\operatorname{lcm}$ 分别为最大公约数和最小公倍数，如有多解，输出任意一个即可。如果无解，输出 ``-1``。", "inputFormat": "第一行输入一个正整数 $q$ 表示询问次数。\n\n接下来 $q$ 行，每行输入三个正整数 $op,n,x$。\n\n- 当 $op=1$ 时表示爱丽丝的牌张数为 $n$，她记住的和为 $x$，要求还原她的牌张。\n\n- 当 $op=2$ 时表示坦尼尔的牌张数为 $n$，他记住的和为 $x$，要求还原他的牌张。", "outputFormat": "一共 $q$ 行，每行输出一个整数序列对应每次询问你构造的牌张序列，序列中相邻的两个数用一个空格隔开。\n\n如有多解，你可以输出任意一个。如果无解，输出 ``-1``。", "hint": "**数据范围**\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ | $\\sum n\\le$ | $x\\le$ | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $5$ | $10$ | | $10$ |\n| $2$ | $50$ | $200$ | | $20$ |\n| $3$ | $5\\times 10^5$ | $2^{31}-1$ | $\\text{A}$ | $15$ |\n| $4$ | $5\\times 10^5$ | $2^{31}-1$ | $\\text{B}$ | $15$ |\n| $5$ | $5\\times 10^5$ | $2^{31}-1$ | | $40$ |\n\n特殊性质 $\\text{A}$：保证对于任意询问满足 $op=1$。\n\n特殊性质 $\\text{B}$：保证对于任意询问满足 $op=2$。\n\n对于 $100\\%$ 的数据满足 $2\\le n\\le 5\\times 10^5$，$2\\le \\sum n\\le 5\\times 10^5$，$1\\le x \\le 2^{31}-1$，$op\\in\\{1,2\\}$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『GROI-R2』 紫水晶", "background": "", "description": "爱丽丝不曾忘记过她曾经存在于纸牌的世界。\n\n于是魔法让她的手里出现了一些牌，同时魔法也让坦尼尔手里出现了一些牌，而且每张牌上都写着一个正整数——尽管他们如今所处的，是玻璃王国的世界中。\n\n牌张很快一消而散，而他们也准备启程。爱丽丝只记住了每相邻两张牌的**最大公约数之和**，坦尼尔只记住了每相邻两张牌的**最小公倍数之和**。\n\n你还在这个宫殿里，你想重现当时的牌张。\n\n**形式化题面**\n\n给定 $q$ 次询问，每次询问为以下两种之一：\n\n- ``1 n x`` 表示要求输出一长度为 $n$ 的**正整数**序列 $\\{a_n\\}$，使得 $\\sum\\limits_{i=1}^{n-1} \\gcd(a_i,a_{i+1})=x$。\n\n- ``2 n x`` 表示要求输出一长度为 $n$ 的**正整数**序列 $\\{a_n\\}$，使得 $\\sum\\limits_{i=1}^{n-1} \\operatorname{lcm}(a_i,a_{i+1})=x$。\n\n且对于任意输出的 $a_i$ 不应超出 C++ 语言中 ``int`` 的存储范围。\n\n其中 $\\gcd$ 和 $\\operatorname{lcm}$ 分别为最大公约数和最小公倍数，如有多解，输出任意一个即可。如果无解，输出 ``-1``。", "inputFormat": "第一行输入一个正整数 $q$ 表示询问次数。\n\n接下来 $q$ 行，每行输入三个正整数 $op,n,x$。\n\n- 当 $op=1$ 时表示爱丽丝的牌张数为 $n$，她记住的和为 $x$，要求还原她的牌张。\n\n- 当 $op=2$ 时表示坦尼尔的牌张数为 $n$，他记住的和为 $x$，要求还原他的牌张。", "outputFormat": "一共 $q$ 行，每行输出一个整数序列对应每次询问你构造的牌张序列，序列中相邻的两个数用一个空格隔开。\n\n如有多解，你可以输出任意一个。如果无解，输出 ``-1``。", "hint": "**数据范围**\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ | $\\sum n\\le$ | $x\\le$ | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $5$ | $10$ | | $10$ |\n| $2$ | $50$ | $200$ | | $20$ |\n| $3$ | $5\\times 10^5$ | $2^{31}-1$ | $\\text{A}$ | $15$ |\n| $4$ | $5\\times 10^5$ | $2^{31}-1$ | $\\text{B}$ | $15$ |\n| $5$ | $5\\times 10^5$ | $2^{31}-1$ | | $40$ |\n\n特殊性质 $\\text{A}$：保证对于任意询问满足 $op=1$。\n\n特殊性质 $\\text{B}$：保证对于任意询问满足 $op=2$。\n\n对于 $100\\%$ 的数据满足 $2\\le n\\le 5\\times 10^5$，$2\\le \\sum n\\le 5\\times 10^5$，$1\\le x \\le 2^{31}-1$，$op\\in\\{1,2\\}$。\n", "locale": "zh-CN"}}}
{"pid": "P9653", "type": "P", "difficulty": 3, "samples": [["2\n3 1 3\n2 2 2\n5 2 4\n2 2 2 2 3", "3\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "洛谷原创", "O2优化", "洛谷月赛"], "title": "『GROI-R2』 不空白的画布", "background": "", "description": "我们都知道爱丽丝躲起来之后，坦尼尔坐在了空白画布面前，拿起炭笔开始作画。\n\n但是现在画布已经不再空白，因为画布上已经有了当下的风景。我们设画布的长度是 $n$，每一单位长度上的颜色可以用一个在 $[1,k]$ 范围内的正整数表示。\n\n坦尼尔还要画他已经翻了的茶杯。每一次作画，他可以选定画布上的任意一个位置，然后将这个位置上的颜色涂改成 $[1,k]$ 范围内的任意正整数。\n\n最后，我们都知道这幅画是有记忆的。定义画上留下的记忆碎片数量为画上的**相同颜色连续块个数**。现在坦尼尔想知道，如果给定他作画的次数**上限**，那么画上的记忆碎片个数**最多**有多少。\n\n**形式化题面**\n\n你有连续的 $n$ 个方格，每个方格上有一个初始颜色 $c_i$，且保证 $1\\le c_i \\le k$。\n\n你可以操作**至多** $m$ 次，每个操作为改变某个方格颜色，要求改变后的颜色范围仍在 $[1,k]$ 内。\n\n我们称一个**极长相同颜色连续段**为一块，要求求出经过至多 $m$ 次操作后的**最多**块数。\n", "inputFormat": "本题有多组测试数据。\n\n第一行输入一个正整数 $T$ 表示数据组数。\n\n对于每组测试数据，第一行输入三个正整数 $n,m,k$，表示画布的长度，坦尼尔作画的次数上限和颜色的取值范围。\n\n第二行输入一个长度为 $n$ 的整数序列 $c$，表示画布上每个位置的初始颜色。", "outputFormat": "对于每组测试数据，输出一行一个正整数，表示记忆碎片最多有多少个。", "hint": "**样例解释**\n\n对于第一组测试数据，坦尼尔可以将从左到右的第二个位置涂成颜色 $1$，得到 $\\{c_n\\}=\\{2,1,2\\}$，块数为 $3$。\n\n\n对于第二组测试数据，坦尼尔可以将从左到右的第二个位置涂成颜色 $1$，将从左到右的第三个位置涂成颜色 $3$，得到 $\\{c_n\\}=\\{2,1,3,2,3\\}$，块数为 $5$。\n\n**数据范围**\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ | $\\sum n\\le$ | $m\\le$ | $k\\le$ | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------:  |\n| $1$ | $10$ | $10$ | $3$ | $10$ |\n| $2$ | $5\\times 10^5$ | $1$ | $5\\times 10^5$ | $10$ |\n| $3$ | $10^3$ | $10^3$ | $10^3$ | $15$ |\n| $4$ | $5\\times 10^5$ | $5\\times 10^5$ | $3$ | $25$ |\n| $5$ | $5\\times 10^5$ | $5\\times 10^5$ | $5\\times 10^5$ | $40$ |\n\n对于 $100\\%$ 的数据满足 $1\\le  n\\le 5\\times 10^5$，$1\\le \\sum n\\le 5\\times 10^5$，$1\\le m\\le n$，$3\\le  k \\le 5\\times 10^5$，$1\\le c_i\\le k$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『GROI-R2』 不空白的画布", "background": "", "description": "我们都知道爱丽丝躲起来之后，坦尼尔坐在了空白画布面前，拿起炭笔开始作画。\n\n但是现在画布已经不再空白，因为画布上已经有了当下的风景。我们设画布的长度是 $n$，每一单位长度上的颜色可以用一个在 $[1,k]$ 范围内的正整数表示。\n\n坦尼尔还要画他已经翻了的茶杯。每一次作画，他可以选定画布上的任意一个位置，然后将这个位置上的颜色涂改成 $[1,k]$ 范围内的任意正整数。\n\n最后，我们都知道这幅画是有记忆的。定义画上留下的记忆碎片数量为画上的**相同颜色连续块个数**。现在坦尼尔想知道，如果给定他作画的次数**上限**，那么画上的记忆碎片个数**最多**有多少。\n\n**形式化题面**\n\n你有连续的 $n$ 个方格，每个方格上有一个初始颜色 $c_i$，且保证 $1\\le c_i \\le k$。\n\n你可以操作**至多** $m$ 次，每个操作为改变某个方格颜色，要求改变后的颜色范围仍在 $[1,k]$ 内。\n\n我们称一个**极长相同颜色连续段**为一块，要求求出经过至多 $m$ 次操作后的**最多**块数。\n", "inputFormat": "本题有多组测试数据。\n\n第一行输入一个正整数 $T$ 表示数据组数。\n\n对于每组测试数据，第一行输入三个正整数 $n,m,k$，表示画布的长度，坦尼尔作画的次数上限和颜色的取值范围。\n\n第二行输入一个长度为 $n$ 的整数序列 $c$，表示画布上每个位置的初始颜色。", "outputFormat": "对于每组测试数据，输出一行一个正整数，表示记忆碎片最多有多少个。", "hint": "**样例解释**\n\n对于第一组测试数据，坦尼尔可以将从左到右的第二个位置涂成颜色 $1$，得到 $\\{c_n\\}=\\{2,1,2\\}$，块数为 $3$。\n\n\n对于第二组测试数据，坦尼尔可以将从左到右的第二个位置涂成颜色 $1$，将从左到右的第三个位置涂成颜色 $3$，得到 $\\{c_n\\}=\\{2,1,3,2,3\\}$，块数为 $5$。\n\n**数据范围**\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ | $\\sum n\\le$ | $m\\le$ | $k\\le$ | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------:  |\n| $1$ | $10$ | $10$ | $3$ | $10$ |\n| $2$ | $5\\times 10^5$ | $1$ | $5\\times 10^5$ | $10$ |\n| $3$ | $10^3$ | $10^3$ | $10^3$ | $15$ |\n| $4$ | $5\\times 10^5$ | $5\\times 10^5$ | $3$ | $25$ |\n| $5$ | $5\\times 10^5$ | $5\\times 10^5$ | $5\\times 10^5$ | $40$ |\n\n对于 $100\\%$ 的数据满足 $1\\le  n\\le 5\\times 10^5$，$1\\le \\sum n\\le 5\\times 10^5$，$1\\le m\\le n$，$3\\le  k \\le 5\\times 10^5$，$1\\le c_i\\le k$。\n", "locale": "zh-CN"}}}
{"pid": "P9654", "type": "P", "difficulty": 6, "samples": [["4\n1 3 5 8", "1\n1 3 1 8"], ["3\n3 4 5", "1\n0 4 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "数学", "数论", "洛谷原创", "Special Judge", "O2优化", "构造", "洛谷月赛"], "title": "『GROI-R2』 记忆碎片", "background": "", "description": "记忆的碎片散落在各个角落，而爱丽丝想把它们拼合在一起。\n\n碎片的顺序是给定的，因为记忆显然不能反过来进行。但是，碎片各自的形状和内容是可以打磨和修正的——毕竟所有人的记忆都会歪曲和遗忘。\n\n每个碎片上的记忆都可以用一个**非负整数**来表示。而相邻的两个碎片能够完整地拼合起来，当且仅当它们记忆的和是一个**完全平方数**。\n\n现在，爱丽丝可以打磨若干块碎片，使得每一对相邻的碎片都能够完整地拼合起来。对于每一次打磨，爱丽丝可以选择一块碎片，将这块碎片上的记忆修改为任意一个**非负整数**。爱丽丝想知道，她至少要打磨多少块碎片，才能实现她的目标。同时，她还希望你给出打磨之后，每块碎片上留有的记忆是多少。\n\n**形式化题面**\n\n给定一个**非负整数**序列 $\\{a_n\\}$，我们定义一次操作是任意选择一个 $i\\in [1,n]$ 并将 $a_i$ 改为任意一个**非负整数** $x$。\n\n问至少进行几次操作才可以满足 $\\forall i\\in [1,n-1]$ 有 $a_i+a_{i+1}$ 为**完全平方数**，并给出修改方案。", "inputFormat": "第一行输入一个整数 $n$，表示记忆碎片的个数。\n\n第二行输入一个长度为 $n$ 的非负整数序列 $a$，表示每个记忆碎片上的记忆。", "outputFormat": "第一行输出一个整数，表示最少打磨次数。\n\n第二行输出一个长度为 $n$ 的整数序列，表示所有打磨过后的记忆碎片上的记忆。\n\n你必须保证你打磨后的记忆满足题目条件，且与你给出的最少打磨次数相符，并满足每个碎片上的记忆都在 $[0,10^{18}]$ 的范围内。", "hint": "**样例解释**\n\n对于第一组样例，不难证明爱丽丝至少要打磨一块碎片才能使所有的记忆满足条件。\n\n请一定注意记忆碎片的顺序是不能改变的。\n\n**评分规则**\n\n如果你对于某一测试点输出的最少打磨次数是正确的，你将获得该测试点 $30\\%$ 的分数。\n\n如果你在最少打磨次数正确的基础上给出了正确的构造，你将获得该测试点 $100\\%$ 的分数。\n\n如果你只会求解最少打磨次数，那也请你在第二行输出以空格隔开的 $n$ 个在 $[0,10^{18}]$ 范围内的整数，否则可能被判为 $0$ 分。\n\n请注意，你在每个 subtask 中得到的 $30\\%$ 分数会被下取整计算。\n\n**数据范围**\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ | $n\\le$ | $a_i\\le$ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $2$ | $10^8$ |  | $5$ |\n| $2$ | $3$ | $10^8$ |  | $20$ |\n| $3$ | $4$ | $10^8$ |  | $15$ |\n| $4$ | $10^3$ | $10^8$ |  | $15$ |\n| $5$ | $10^6$ | $10^4$ |  | $10$ |\n| $6$ | $10^6$ | $10^8$ | $\\text{A}$ | $10$ |\n| $7$ | $10^6$ | $10^8$ |  | $25$ |\n\n特殊性质 $\\text{A}$：$\\forall 1\\le i,j\\le n$ 满足 $a_i=a_j$。\n\n对于 $100\\%$ 的数据满足 $1\\le n\\le 10^6$，$0\\le a_i\\le 10^8$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『GROI-R2』 记忆碎片", "background": "", "description": "记忆的碎片散落在各个角落，而爱丽丝想把它们拼合在一起。\n\n碎片的顺序是给定的，因为记忆显然不能反过来进行。但是，碎片各自的形状和内容是可以打磨和修正的——毕竟所有人的记忆都会歪曲和遗忘。\n\n每个碎片上的记忆都可以用一个**非负整数**来表示。而相邻的两个碎片能够完整地拼合起来，当且仅当它们记忆的和是一个**完全平方数**。\n\n现在，爱丽丝可以打磨若干块碎片，使得每一对相邻的碎片都能够完整地拼合起来。对于每一次打磨，爱丽丝可以选择一块碎片，将这块碎片上的记忆修改为任意一个**非负整数**。爱丽丝想知道，她至少要打磨多少块碎片，才能实现她的目标。同时，她还希望你给出打磨之后，每块碎片上留有的记忆是多少。\n\n**形式化题面**\n\n给定一个**非负整数**序列 $\\{a_n\\}$，我们定义一次操作是任意选择一个 $i\\in [1,n]$ 并将 $a_i$ 改为任意一个**非负整数** $x$。\n\n问至少进行几次操作才可以满足 $\\forall i\\in [1,n-1]$ 有 $a_i+a_{i+1}$ 为**完全平方数**，并给出修改方案。", "inputFormat": "第一行输入一个整数 $n$，表示记忆碎片的个数。\n\n第二行输入一个长度为 $n$ 的非负整数序列 $a$，表示每个记忆碎片上的记忆。", "outputFormat": "第一行输出一个整数，表示最少打磨次数。\n\n第二行输出一个长度为 $n$ 的整数序列，表示所有打磨过后的记忆碎片上的记忆。\n\n你必须保证你打磨后的记忆满足题目条件，且与你给出的最少打磨次数相符，并满足每个碎片上的记忆都在 $[0,10^{18}]$ 的范围内。", "hint": "**样例解释**\n\n对于第一组样例，不难证明爱丽丝至少要打磨一块碎片才能使所有的记忆满足条件。\n\n请一定注意记忆碎片的顺序是不能改变的。\n\n**评分规则**\n\n如果你对于某一测试点输出的最少打磨次数是正确的，你将获得该测试点 $30\\%$ 的分数。\n\n如果你在最少打磨次数正确的基础上给出了正确的构造，你将获得该测试点 $100\\%$ 的分数。\n\n如果你只会求解最少打磨次数，那也请你在第二行输出以空格隔开的 $n$ 个在 $[0,10^{18}]$ 范围内的整数，否则可能被判为 $0$ 分。\n\n请注意，你在每个 subtask 中得到的 $30\\%$ 分数会被下取整计算。\n\n**数据范围**\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ | $n\\le$ | $a_i\\le$ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $2$ | $10^8$ |  | $5$ |\n| $2$ | $3$ | $10^8$ |  | $20$ |\n| $3$ | $4$ | $10^8$ |  | $15$ |\n| $4$ | $10^3$ | $10^8$ |  | $15$ |\n| $5$ | $10^6$ | $10^4$ |  | $10$ |\n| $6$ | $10^6$ | $10^8$ | $\\text{A}$ | $10$ |\n| $7$ | $10^6$ | $10^8$ |  | $25$ |\n\n特殊性质 $\\text{A}$：$\\forall 1\\le i,j\\le n$ 满足 $a_i=a_j$。\n\n对于 $100\\%$ 的数据满足 $1\\le n\\le 10^6$，$0\\le a_i\\le 10^8$。", "locale": "zh-CN"}}}
{"pid": "P9655", "type": "P", "difficulty": 6, "samples": [["3\n())\n1 2\n1 3", "3"], ["8\n()))())(\n1 2\n1 3\n3 4\n3 5\n3 6\n5 7\n2 8", "5"]], "limits": {"time": [1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["并查集", "树上启发式合并", "洛谷原创", "O2优化", "树形 DP", "最近公共祖先 LCA", "树论", "虚树", "洛谷月赛"], "title": "『GROI-R2』 Beside You", "background": "記憶の森\n\n始まりの謎 いつか\n\nこの未知の果てに告げ知らせて\n\n——江口孝宏《Beside You》", "description": "我相信所有读过这一段剧情的人都不想让别人也经历一样的痛苦，但是坦尼尔还是只能消失，对吗？\n\n坦尼尔最后留下了一棵以 $1$ 为根的有根树，在树的每个结点上，都有一个记忆碎片。有的碎片表示着一个世界记忆的开始，而另外的碎片表示着一个世界记忆的终结。\n\n这时，树上飞来了一只蝴蝶~~モリモリあつし~~。蝴蝶在树上飞舞的过程中，经过了一些结点。爱丽丝能确定蝴蝶经过的结点个数至少有 $2$ 个，但是她忘记了具体的点数。\n\n爱丽丝发现，蝴蝶经过的所有点都是互相连通的。当她把目光朝向每一条经过点数大于 $1$ 的从连通块**深度最小的结点**通往**连通块的任意一个叶子结点**（一个点是连通块的叶子结点，当且仅当它在树上没有子结点，或者它在树上的任意子结点均不在该连通块内）的简单路径时，她发现这些路径上的记忆都是完整的。爱丽丝认为一条路径上的记忆是完整的，当且仅当这条路径上既没有出现一个世界的记忆**没开始就结束**（路径中途在没有未结束的记忆的时候，出现了表示记忆终结的碎片）的情况，也没有出现一个世界的记忆**开始之后没有终结**（路径结束之后还有没结束的记忆）的情况。\n\n可惜她已经遗忘了蝴蝶经过了哪些点，所以你需要告诉她蝴蝶**最多**可能经过多少点。\n\n**形式化题面**\n\n给定一棵以 $1$ 为根的 $n$ 个节点的树 $T=(V,E)$，每个节点上的点权 $c_i$ 为一个**左括号或一个右括号**，节点编号为 $1\\sim n$。\n\n我们定义点集 $V'\\subseteq V$ 合法，当且仅当 $|V'|>1$（**即 $V'$ 的大小大于 $1$**） 且 $\\forall u,v \\in V'$，从 $u$ 到 $v$ 的简单路径只经过 $V'$ 中的点。\n\n同时我们定义 $E'\\subseteq E$ 为能使得 $\\forall u,v \\in V'$，从 $u$ 到 $v$ 的简单路径，只经过 $E'$ 中的边的大小最小的边集。\n\n定义一个合法点集 $V'$ 的根为 $V'$ 中深度最小的结点。\n\n定义 $u$ 为合法点集 $V'$ 的叶子节点，当且仅当 $u$ 不是 $V'$ 的根，且满足 $v \\in V', (u,v) \\in E'$ 的 $v$ 的数量为 $1$。\n\n求一个合法点集 $S$，**满足其根节点到其任意一个叶子的路径上，每个点的点权顺次相接为一个合法的括号序列**，并**最大化** $|S|$。\n\n我们通过如下规则定义一个合法的括号序列：\n\n- 空串（即长度为 $0$ 的串）是一个合法的括号序列。\n\n- 若串 $\\text{A,B}$ 都是合法的括号序列，则字符串 $\\text{AB}$ （即将字符串 $\\text{A}$ 与 $\\text{B}$ 按顺序拼接起来）也是合法的括号序列。\n\n- 若串 $\\text{A}$ 是合法的括号序列，则字符串 $\\text{(A)}$ 是一个合法的括号序列。\n\n你需要输出符合要求的最大 $|S|$。", "inputFormat": "第一行输入一个正整数 $n$ 表示树上结点个数。\n\n第二行输入一个长度为 $n$ 的字符串 $c$。$c_i$ 为 ``(`` 表示这个结点上有一个标志着记忆开始的碎片，$c_i$ 为 ``)`` 表示这个结点上有一个标志着记忆终结的碎片。\n\n接下来 $n-1$ 行，每行输入两个正整数 $u,v$，表示结点 $u,v$ 之间有一条边。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "**样例解释**\n\n![](https://s1.ax1x.com/2023/08/07/pPEj56K.png)\n\n蝴蝶经过的最大合法点集 $S$ 为 $\\{1,2,3\\}$。\n\n![](https://s1.ax1x.com/2023/08/07/pPEv90g.png)\n\n蝴蝶经过的最大合法点集 $S$ 为 $\\{1,2,3,5,7\\}$。\n\n**数据范围**\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ | $n\\le$ | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $20$ |  | $5$ |\n| $2$ | $3000$ |  | $20$ |\n| $3$ | $5\\times10^5$ | $\\text{A}$ | $15$  |\n| $4$ | $5\\times10^5$ | $\\text{B}$ |  $10$ |\n| $5$ | $2\\times10^5$ |  | $15$ |\n| $6$ | $5\\times10^5$ |  | $35$ |\n\n特殊性质 $\\text{A}$：保证树退化成一条链（不保证 $1$ 号节点为其一个端点）。\n\n特殊性质 $\\text{B}$：保证原树上任意结点到叶子的路径上右括号数量不少于左括号数量。\n\n对于 $100\\%$ 的数据满足 $1\\le n\\le 5\\times 10^5$，$1\\le u,v \\le n$，$c_i$ 为 ``(`` 或 ``)``。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『GROI-R2』 Beside You", "background": "記憶の森\n\n始まりの謎 いつか\n\nこの未知の果てに告げ知らせて\n\n——江口孝宏《Beside You》", "description": "我相信所有读过这一段剧情的人都不想让别人也经历一样的痛苦，但是坦尼尔还是只能消失，对吗？\n\n坦尼尔最后留下了一棵以 $1$ 为根的有根树，在树的每个结点上，都有一个记忆碎片。有的碎片表示着一个世界记忆的开始，而另外的碎片表示着一个世界记忆的终结。\n\n这时，树上飞来了一只蝴蝶~~モリモリあつし~~。蝴蝶在树上飞舞的过程中，经过了一些结点。爱丽丝能确定蝴蝶经过的结点个数至少有 $2$ 个，但是她忘记了具体的点数。\n\n爱丽丝发现，蝴蝶经过的所有点都是互相连通的。当她把目光朝向每一条经过点数大于 $1$ 的从连通块**深度最小的结点**通往**连通块的任意一个叶子结点**（一个点是连通块的叶子结点，当且仅当它在树上没有子结点，或者它在树上的任意子结点均不在该连通块内）的简单路径时，她发现这些路径上的记忆都是完整的。爱丽丝认为一条路径上的记忆是完整的，当且仅当这条路径上既没有出现一个世界的记忆**没开始就结束**（路径中途在没有未结束的记忆的时候，出现了表示记忆终结的碎片）的情况，也没有出现一个世界的记忆**开始之后没有终结**（路径结束之后还有没结束的记忆）的情况。\n\n可惜她已经遗忘了蝴蝶经过了哪些点，所以你需要告诉她蝴蝶**最多**可能经过多少点。\n\n**形式化题面**\n\n给定一棵以 $1$ 为根的 $n$ 个节点的树 $T=(V,E)$，每个节点上的点权 $c_i$ 为一个**左括号或一个右括号**，节点编号为 $1\\sim n$。\n\n我们定义点集 $V'\\subseteq V$ 合法，当且仅当 $|V'|>1$（**即 $V'$ 的大小大于 $1$**） 且 $\\forall u,v \\in V'$，从 $u$ 到 $v$ 的简单路径只经过 $V'$ 中的点。\n\n同时我们定义 $E'\\subseteq E$ 为能使得 $\\forall u,v \\in V'$，从 $u$ 到 $v$ 的简单路径，只经过 $E'$ 中的边的大小最小的边集。\n\n定义一个合法点集 $V'$ 的根为 $V'$ 中深度最小的结点。\n\n定义 $u$ 为合法点集 $V'$ 的叶子节点，当且仅当 $u$ 不是 $V'$ 的根，且满足 $v \\in V', (u,v) \\in E'$ 的 $v$ 的数量为 $1$。\n\n求一个合法点集 $S$，**满足其根节点到其任意一个叶子的路径上，每个点的点权顺次相接为一个合法的括号序列**，并**最大化** $|S|$。\n\n我们通过如下规则定义一个合法的括号序列：\n\n- 空串（即长度为 $0$ 的串）是一个合法的括号序列。\n\n- 若串 $\\text{A,B}$ 都是合法的括号序列，则字符串 $\\text{AB}$ （即将字符串 $\\text{A}$ 与 $\\text{B}$ 按顺序拼接起来）也是合法的括号序列。\n\n- 若串 $\\text{A}$ 是合法的括号序列，则字符串 $\\text{(A)}$ 是一个合法的括号序列。\n\n你需要输出符合要求的最大 $|S|$。", "inputFormat": "第一行输入一个正整数 $n$ 表示树上结点个数。\n\n第二行输入一个长度为 $n$ 的字符串 $c$。$c_i$ 为 ``(`` 表示这个结点上有一个标志着记忆开始的碎片，$c_i$ 为 ``)`` 表示这个结点上有一个标志着记忆终结的碎片。\n\n接下来 $n-1$ 行，每行输入两个正整数 $u,v$，表示结点 $u,v$ 之间有一条边。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "**样例解释**\n\n![](https://s1.ax1x.com/2023/08/07/pPEj56K.png)\n\n蝴蝶经过的最大合法点集 $S$ 为 $\\{1,2,3\\}$。\n\n![](https://s1.ax1x.com/2023/08/07/pPEv90g.png)\n\n蝴蝶经过的最大合法点集 $S$ 为 $\\{1,2,3,5,7\\}$。\n\n**数据范围**\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ | $n\\le$ | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $20$ |  | $5$ |\n| $2$ | $3000$ |  | $20$ |\n| $3$ | $5\\times10^5$ | $\\text{A}$ | $15$  |\n| $4$ | $5\\times10^5$ | $\\text{B}$ |  $10$ |\n| $5$ | $2\\times10^5$ |  | $15$ |\n| $6$ | $5\\times10^5$ |  | $35$ |\n\n特殊性质 $\\text{A}$：保证树退化成一条链（不保证 $1$ 号节点为其一个端点）。\n\n特殊性质 $\\text{B}$：保证原树上任意结点到叶子的路径上右括号数量不少于左括号数量。\n\n对于 $100\\%$ 的数据满足 $1\\le n\\le 5\\times 10^5$，$1\\le u,v \\le n$，$c_i$ 为 ``(`` 或 ``)``。", "locale": "zh-CN"}}}
{"pid": "P9656", "type": "P", "difficulty": 2, "samples": [["1\n2\n4 3\n2 1", "4 3 1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "2021", "Special Judge", "O2优化", "ICPC", "Ad-hoc", "澳门"], "title": "[ICPC 2021 Macao R] So I'll Max Out My Constructive Algorithm Skills", "background": "", "description": "BaoBao the Witch is stuck in a maze with $n$ rows and $n$ columns, where the height of the cell in the $i$-th row and the $j$-th column is $h_{i,j}$. To get out of the maze, BaoBao has to find a path which passes through each cell exactly once. Each time she can only move into the neighboring cell sharing a same edge with the current one. But as we know, BaoBao is super lazy, so every time when she climbs up (that is to say, moving from a cell with a smaller height to another with a larger height) her happiness value will decrease. As her helping hand, your task is to find a valid path so that when moving along the path, the number of times BaoBao climbs up will not be more than the number of times she climbs down.\n\nMore formally, you need to find a sequence $(x_1, y_1), (x_2, y_2), \\cdots, (x_{n^2}, y_{n^2})$ such that:\n- For all $1 \\le i \\le n^2$, $ 1 \\le x_i, y_i \\le n$;\n- For all $1 \\le i, j \\le n^2, i \\neq j$, $ (x_i, y_i) \\neq (x_j, y_j)$;\n- For all $2 \\le i \\le n^2$, $|x_i - x_{i-1}| + |y_i - y_{i-1}| = 1$;\n- $\\sum\\limits_{i=2}^{n^2}{[h_{x_{i-1}, y_{i-1}} < h_{x_i, y_i}]} \\le \\sum\\limits_{i=2}^{n^2}{[h_{x_{i-1}, y_{i-1}} > h_{x_i, y_i}]}$, where $[P]$ equals $1$ when $P$ is true, and equals $0$ when it is false.\n\nAdditionally, you discover that the heights in all cells are a permutation of $n^2$, so you just need to output the height of each cell in a valid path.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 100$) indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($2 \\le n \\le 64$) indicating the size of the maze.\n\nFor the following $n$ lines, the $i$-th line contains $n$ integers $h_{i, 1}, h_{i, 2}, \\cdots, h_{i,n}$ ($1 \\le h_{i, j} \\le n^2$) where $h_{i,j}$ indicates the height of the cell in the $i$-th row and the $j$-th column. It's guaranteed that all integers in the input make up a permutation of $n^2$.", "outputFormat": "For each test case output one line containing $n^2$ separated by a space indicating the heights of each cell in a valid path. If there are multiple valid answers you can output any of them. It's easy to prove that an answer always exists.\n\nPlease, DO NOT output extra spaces at the end of each line, or your answer may be considered incorrect!", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] So I'll Max Out My Constructive Algorithm Skills", "background": "", "description": "BaoBao the Witch is stuck in a maze with $n$ rows and $n$ columns, where the height of the cell in the $i$-th row and the $j$-th column is $h_{i,j}$. To get out of the maze, BaoBao has to find a path which passes through each cell exactly once. Each time she can only move into the neighboring cell sharing a same edge with the current one. But as we know, BaoBao is super lazy, so every time when she climbs up (that is to say, moving from a cell with a smaller height to another with a larger height) her happiness value will decrease. As her helping hand, your task is to find a valid path so that when moving along the path, the number of times BaoBao climbs up will not be more than the number of times she climbs down.\n\nMore formally, you need to find a sequence $(x_1, y_1), (x_2, y_2), \\cdots, (x_{n^2}, y_{n^2})$ such that:\n- For all $1 \\le i \\le n^2$, $ 1 \\le x_i, y_i \\le n$;\n- For all $1 \\le i, j \\le n^2, i \\neq j$, $ (x_i, y_i) \\neq (x_j, y_j)$;\n- For all $2 \\le i \\le n^2$, $|x_i - x_{i-1}| + |y_i - y_{i-1}| = 1$;\n- $\\sum\\limits_{i=2}^{n^2}{[h_{x_{i-1}, y_{i-1}} < h_{x_i, y_i}]} \\le \\sum\\limits_{i=2}^{n^2}{[h_{x_{i-1}, y_{i-1}} > h_{x_i, y_i}]}$, where $[P]$ equals $1$ when $P$ is true, and equals $0$ when it is false.\n\nAdditionally, you discover that the heights in all cells are a permutation of $n^2$, so you just need to output the height of each cell in a valid path.\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 100$) indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($2 \\le n \\le 64$) indicating the size of the maze.\n\nFor the following $n$ lines, the $i$-th line contains $n$ integers $h_{i, 1}, h_{i, 2}, \\cdots, h_{i,n}$ ($1 \\le h_{i, j} \\le n^2$) where $h_{i,j}$ indicates the height of the cell in the $i$-th row and the $j$-th column. It's guaranteed that all integers in the input make up a permutation of $n^2$.", "outputFormat": "For each test case output one line containing $n^2$ separated by a space indicating the heights of each cell in a valid path. If there are multiple valid answers you can output any of them. It's easy to prove that an answer always exists.\n\nPlease, DO NOT output extra spaces at the end of each line, or your answer may be considered incorrect!", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] So I'll Max Out My Constructive Algorithm Skills", "background": "", "description": "宝宝女巫被困在一个 $n$ 行 $n$ 列的迷宫中，其中第 $i$ 行第 $j$ 列的单元格高度为 $h_{i,j}$。要走出迷宫，宝宝必须找到一条路径，该路径穿过每个单元格恰好一次。每次她只能移动到与当前单元格共享边的相邻单元格。但是众所周知，宝宝非常懒，所以每当她爬升（即从高度较低的单元格移动到高度较高的单元格）时，她的幸福值会减少。作为她的帮手，你的任务是找到一条有效的路径，使得沿着路径移动时，宝宝爬升的次数不多于她下降的次数。\n\n更正式地说，你需要找到一个序列 $(x_1, y_1), (x_2, y_2), \\cdots, (x_{n^2}, y_{n^2})$，使得：\n- 对于所有的 $1 \\le i \\le n^2$，$ 1 \\le x_i, y_i \\le n$；\n- 对于所有的 $1 \\le i, j \\le n^2, i \\neq j$，$ (x_i, y_i) \\neq (x_j, y_j)$；\n- 对于所有的 $2 \\le i \\le n^2$，$|x_i - x_{i-1}| + |y_i - y_{i-1}| = 1$；\n- $\\sum\\limits_{i=2}^{n^2}{[h_{x_{i-1}, y_{i-1}} < h_{x_i, y_i}]} \\le \\sum\\limits_{i=2}^{n^2}{[h_{x_{i-1}, y_{i-1}} > h_{x_i, y_i}]}$，其中 $[P]$ 当 $P$ 为真时等于 $1$，当为假时等于 $0$。\n\n此外，你发现所有单元格的高度都是 $n^2$ 的排列，所以你只需要输出有效路径中每个单元格的高度。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$（$1 \\le T \\le 100$），表示测试用例的数量。对于每个测试用例：\n\n第一行包含一个整数 $n$（$2 \\le n \\le 64$），表示迷宫的大小。\n\n接下来的 $n$ 行，第 $i$ 行包含 $n$ 个整数 $h_{i, 1}, h_{i, 2}, \\cdots, h_{i,n}$（$1 \\le h_{i, j} \\le n^2$），其中 $h_{i,j}$ 表示第 $i$ 行第 $j$ 列单元格的高度。保证输入中的所有整数构成 $n^2$ 的排列。", "outputFormat": "对于每个测试用例，输出一行，包含 $n^2$ 个由空格分隔的整数，表示有效路径中每个单元格的高度。如果有多个有效答案，你可以输出其中任何一个。很容易证明答案总是存在。\n\n请不要在每行的末尾输出多余的空格，否则你的答案可能会被认为不正确！\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9657", "type": "P", "difficulty": 7, "samples": [["3", "*0*\n011\n8\n**1\n101\n7"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2021", "Special Judge", "O2优化", "前缀和", "ICPC", "澳门"], "title": "[ICPC 2021 Macao R] the Matching System", "background": "", "description": "As the leader of the safety department, you are asked to check an ancient matching system in your company. \n\nThe system is fed with two strings, a to-be-matched string and a pattern string, and will determine whether the former can match the latter. The former string is a strict binary string(i.e., contains only $\\textbf{0}$ and $\\textbf{1}$), and the latter string consists of four types of characters $\\textbf{0}$, $\\textbf{1}$, $\\textbf{*}$, $^$, where $\\textbf{*}$ means match zero or more arbitrary binary characters, and $^$ means match exactly one binary character. \n\nThe system has two matching methods: maximum matching and minimum matching.\n\nConsider the starting positions of the two strings. The maximum matching method will make different decisions based on the current character of the pattern string:\n- $\\textbf{*}$: The system will enumerate $i$ from $L$ to $0$, where $L$ is the remaining length of the to-be-matched string. Before each enumeration starts, the system consumes 1 unit of energy. Then it temporarily assumes that the current $\\textbf{*}$ in the pattern string matches the consecutive $i$ characters in the to-be-matched string, and tries to match the remaining positions of two strings recursively. As long as one attempt is successful, the system will give up the remaining enumeration and stop the whole system. Otherwise, it will try the next enumeration until all attempts are tried and finally return to the previous $\\textbf{*}$ enumeration.\n- $\\textbf{0,1}$: The system will stop and return to the previous $\\textbf{*}$ enumeration if the to-be-matched string has been exhausted. Otherwise, it consumes $1$ unit of energy to compare the current characters between the pattern string and the to-be-matched string. It will continue analyzing the remaining positions of these two strings if the result is the same, otherwise, return back to the previous $\\textbf{*}$ enumeration.\n- $^$: The system will stop and return to the previous $\\textbf{*}$ enumeration if the to-be-matched string has been exhausted. Otherwise, it consumes $1$ unit of energy and moves on of two strings.\n\nWhen the pattern string is exhausted, the system will check the to-be-matched string at the same time. It will return ``Yes`` and stop the whole process if the to-be-matched string is also exhausted, otherwise, it will return to the previous $\\textbf{*}$ enumeration. After all attempts are tried and no matching method is found, the system will eventually return ``No``.\n\nMinimum matching does a similar thing except for the enumeration order of $\\textbf{*}$ (i.e., enumerate $i$ from $0$ to $L$).\n\nThese two matching methods seem not very effective, so you want to hack them. Please construct both a pattern string and a to-be-matched string of length $n$ for each matching method, so that the system answers ``Yes`` and the energy consumption is as large as possible.\n", "inputFormat": "There is only one test case in each test file.\n\nThe first and only line contains an integer $n$ ($1 \\le n \\le 10^3$) indicating the length of strings need to be constructed.", "outputFormat": "Please output the pattern string, the to-be-matched string, and the energy cost for the maximum matching method in the first $3$ lines. Then output the pattern string, the to-be-matched string, and the energy cost for the minimum matching method in the next $3$ lines.\n\nIf there are multiple constructing ways, you can output any of them.\n\nThe energy cost may be very large, so you need to output the value modulo $(10^9+7)$. Note that this is only for your convenience and you need to maximize the energy cost before the modulus.", "hint": "**【题目描述】**\n\n作为安全部门的负责人，你被要求检查公司的一个古老匹配系统。\n\n该系统输入两个字符串，一个待匹配字符串和一个模式字符串，并确定前者是否能匹配后者。前者字符串是严格的二进制字符串（即仅包含 $\\textbf{0}$ 和 $\\textbf{1}$），而后者字符串由四种类型的字符组成 $\\textbf{0}$、$\\textbf{1}$、$\\textbf{*}$ 和 $^$，其中 $\\textbf{*}$ 表示匹配零个或多个任意二进制字符，$^$ 表示匹配恰好一个二进制字符。\n\n该系统有两种匹配方法：最大匹配和最小匹配。\n\n考虑两个字符串的起始位置。最大匹配方法将根据模式字符串的当前字符做出不同的决定：\n- $\\textbf{*}$: 系统将从 $L$ 到 $0$ 枚举 $i$，其中 $L$ 是待匹配字符串的剩余长度。在每次枚举开始之前，系统消耗 1 单位的能量。然后，它临时假设模式字符串中的当前 $\\textbf{*}$ 匹配待匹配字符串中的连续 $i$ 个字符，并尝试递归地匹配两个字符串的剩余位置。只要有一次尝试成功，系统将放弃剩余的枚举并停止整个系统。否则，它将尝试下一次枚举，直到所有尝试都尝试完毕，最后返回到先前的 $\\textbf{*}$ 枚举。\n- $\\textbf{0,1}$: 如果待匹配字符串已经耗尽，则系统将停止并返回到先前的 $\\textbf{*}$ 枚举。否则，它将消耗 $1$ 单位的能量来比较模式字符串和待匹配字符串之间的当前字符。如果结果相同，它将继续分析这两个字符串的剩余位置，否则，返回到先前的 $\\textbf{*}$ 枚举。\n- $^$: 如果待匹配字符串已经耗尽，则系统将停止并返回到先前的 $\\textbf{*}$ 枚举。否则，它将消耗 $1$ 单位的能量并继续分析两个字符串。\n\n当模式字符串耗尽时，系统将同时检查待匹配字符串。如果待匹配字符串也已经耗尽，则系统将返回“是”并停止整个过程，否则，它将返回到先前的 $\\textbf{*}$ 枚举。在尝试了所有尝试并找不到匹配方法后，系统最终将返回“否”。\n\n最小匹配执行类似的操作，除了 $\\textbf{*}$ 的枚举顺序（即从 $0$ 到 $L$ 枚举 $i$）。\n\n这两种匹配方法似乎不太有效，所以你想黑掉它们。请为每种匹配方法构造一个长度为 $n$ 的模式字符串和待匹配字符串，使得系统返回“是”，能量消耗尽可能大。\n\n**【输入格式】**\n\n每个测试文件中只有一个测试用例。\n\n第一行仅包含一个整数 $n$（$1 \\le n \\le 10^3$），表示需要构造的字符串的长度。\n\n请输出最大匹配方法的模式字符串、待匹配字符串和能量消耗的前 $3$ 行。然后输出最小匹配方法的模式字符串、待匹配字符串和能量消耗的后 $3$ 行。\n\n**【输出格式】**\n\n如果有多种构造方式，你可以输出任何一种。\n\n能量消耗可能非常大，所以你需要输出取模 $(10^9+7)$ 后的值。请注意，这仅供您方便，您需要在取模之前最大化能量消耗。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] the Matching System", "background": "", "description": "As the leader of the safety department, you are asked to check an ancient matching system in your company. \n\nThe system is fed with two strings, a to-be-matched string and a pattern string, and will determine whether the former can match the latter. The former string is a strict binary string(i.e., contains only $\\textbf{0}$ and $\\textbf{1}$), and the latter string consists of four types of characters $\\textbf{0}$, $\\textbf{1}$, $\\textbf{*}$, $^$, where $\\textbf{*}$ means match zero or more arbitrary binary characters, and $^$ means match exactly one binary character. \n\nThe system has two matching methods: maximum matching and minimum matching.\n\nConsider the starting positions of the two strings. The maximum matching method will make different decisions based on the current character of the pattern string:\n- $\\textbf{*}$: The system will enumerate $i$ from $L$ to $0$, where $L$ is the remaining length of the to-be-matched string. Before each enumeration starts, the system consumes 1 unit of energy. Then it temporarily assumes that the current $\\textbf{*}$ in the pattern string matches the consecutive $i$ characters in the to-be-matched string, and tries to match the remaining positions of two strings recursively. As long as one attempt is successful, the system will give up the remaining enumeration and stop the whole system. Otherwise, it will try the next enumeration until all attempts are tried and finally return to the previous $\\textbf{*}$ enumeration.\n- $\\textbf{0,1}$: The system will stop and return to the previous $\\textbf{*}$ enumeration if the to-be-matched string has been exhausted. Otherwise, it consumes $1$ unit of energy to compare the current characters between the pattern string and the to-be-matched string. It will continue analyzing the remaining positions of these two strings if the result is the same, otherwise, return back to the previous $\\textbf{*}$ enumeration.\n- $^$: The system will stop and return to the previous $\\textbf{*}$ enumeration if the to-be-matched string has been exhausted. Otherwise, it consumes $1$ unit of energy and moves on of two strings.\n\nWhen the pattern string is exhausted, the system will check the to-be-matched string at the same time. It will return ``Yes`` and stop the whole process if the to-be-matched string is also exhausted, otherwise, it will return to the previous $\\textbf{*}$ enumeration. After all attempts are tried and no matching method is found, the system will eventually return ``No``.\n\nMinimum matching does a similar thing except for the enumeration order of $\\textbf{*}$ (i.e., enumerate $i$ from $0$ to $L$).\n\nThese two matching methods seem not very effective, so you want to hack them. Please construct both a pattern string and a to-be-matched string of length $n$ for each matching method, so that the system answers ``Yes`` and the energy consumption is as large as possible.\n", "inputFormat": "There is only one test case in each test file.\n\nThe first and only line contains an integer $n$ ($1 \\le n \\le 10^3$) indicating the length of strings need to be constructed.", "outputFormat": "Please output the pattern string, the to-be-matched string, and the energy cost for the maximum matching method in the first $3$ lines. Then output the pattern string, the to-be-matched string, and the energy cost for the minimum matching method in the next $3$ lines.\n\nIf there are multiple constructing ways, you can output any of them.\n\nThe energy cost may be very large, so you need to output the value modulo $(10^9+7)$. Note that this is only for your convenience and you need to maximize the energy cost before the modulus.", "hint": "**【题目描述】**\n\n作为安全部门的负责人，你被要求检查公司的一个古老匹配系统。\n\n该系统输入两个字符串，一个待匹配字符串和一个模式字符串，并确定前者是否能匹配后者。前者字符串是严格的二进制字符串（即仅包含 $\\textbf{0}$ 和 $\\textbf{1}$），而后者字符串由四种类型的字符组成 $\\textbf{0}$、$\\textbf{1}$、$\\textbf{*}$ 和 $^$，其中 $\\textbf{*}$ 表示匹配零个或多个任意二进制字符，$^$ 表示匹配恰好一个二进制字符。\n\n该系统有两种匹配方法：最大匹配和最小匹配。\n\n考虑两个字符串的起始位置。最大匹配方法将根据模式字符串的当前字符做出不同的决定：\n- $\\textbf{*}$: 系统将从 $L$ 到 $0$ 枚举 $i$，其中 $L$ 是待匹配字符串的剩余长度。在每次枚举开始之前，系统消耗 1 单位的能量。然后，它临时假设模式字符串中的当前 $\\textbf{*}$ 匹配待匹配字符串中的连续 $i$ 个字符，并尝试递归地匹配两个字符串的剩余位置。只要有一次尝试成功，系统将放弃剩余的枚举并停止整个系统。否则，它将尝试下一次枚举，直到所有尝试都尝试完毕，最后返回到先前的 $\\textbf{*}$ 枚举。\n- $\\textbf{0,1}$: 如果待匹配字符串已经耗尽，则系统将停止并返回到先前的 $\\textbf{*}$ 枚举。否则，它将消耗 $1$ 单位的能量来比较模式字符串和待匹配字符串之间的当前字符。如果结果相同，它将继续分析这两个字符串的剩余位置，否则，返回到先前的 $\\textbf{*}$ 枚举。\n- $^$: 如果待匹配字符串已经耗尽，则系统将停止并返回到先前的 $\\textbf{*}$ 枚举。否则，它将消耗 $1$ 单位的能量并继续分析两个字符串。\n\n当模式字符串耗尽时，系统将同时检查待匹配字符串。如果待匹配字符串也已经耗尽，则系统将返回“是”并停止整个过程，否则，它将返回到先前的 $\\textbf{*}$ 枚举。在尝试了所有尝试并找不到匹配方法后，系统最终将返回“否”。\n\n最小匹配执行类似的操作，除了 $\\textbf{*}$ 的枚举顺序（即从 $0$ 到 $L$ 枚举 $i$）。\n\n这两种匹配方法似乎不太有效，所以你想黑掉它们。请为每种匹配方法构造一个长度为 $n$ 的模式字符串和待匹配字符串，使得系统返回“是”，能量消耗尽可能大。\n\n**【输入格式】**\n\n每个测试文件中只有一个测试用例。\n\n第一行仅包含一个整数 $n$（$1 \\le n \\le 10^3$），表示需要构造的字符串的长度。\n\n请输出最大匹配方法的模式字符串、待匹配字符串和能量消耗的前 $3$ 行。然后输出最小匹配方法的模式字符串、待匹配字符串和能量消耗的后 $3$ 行。\n\n**【输出格式】**\n\n如果有多种构造方式，你可以输出任何一种。\n\n能量消耗可能非常大，所以你需要输出取模 $(10^9+7)$ 后的值。请注意，这仅供您方便，您需要在取模之前最大化能量消耗。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] the Matching System", "background": "", "description": "作为安全部门的负责人，你被要求检查公司的一古老匹配系统。\n\n该系统输入两个字符串，一个待匹配字符串和一个模式字符串，并确定前者是否能匹配后者。前者字符串是严格的二进制字符串（即仅包含 $\\textbf{0}$ 和 $\\textbf{1}$），而后者字符串由四种类型的字符组成：$\\textbf{0}$、$\\textbf{1}$、$\\textbf{*}$ 和 $^$，其中 $\\textbf{*}$ 表示匹配零个或多个任意二进制字符，$^$ 表示匹配恰好一个二进制字符。\n\n该系统有两种匹配方法：最大匹配和最小匹配。\n\n考虑两个字符串的起始位置。最大匹配方法将根据模式字符串的当前字符做出不同的决定：\n- $\\textbf{*}$: 系统将从 $L$ 到 $0$ 枚举 $i$，其中 $L$ 是待匹配字符串的剩余长度。在每次枚举开始之前，系统消耗 1 单位的能量。然后它暂时假设模式字符串中的当前 $\\textbf{*}$ 匹配待匹配字符串中的连续 $i$ 个字符，并尝试递归地匹配两个字符串的剩余位置。只要有一次尝试成功，系统将放弃剩余的枚举并停止整个系统。否则，它将尝试下一个枚举，直到所有尝试都被尝试完毕，最后返回到先前的 $\\textbf{*}$ 枚举。\n- $\\textbf{0,1}$: 如果待匹配字符串已经耗尽，系统将停止并返回到先前的 $\\textbf{*}$ 枚举。否则，它消耗 $1$ 单位的能量来比较模式字符串和待匹配字符串之间的当前字符。如果结果相同，它将继续分析这两个字符串的剩余位置，否则返回到先前的 $\\textbf{*}$ 枚举。\n- $^$: 如果待匹配字符串已经耗尽，系统将停止并返回到先前的 $\\textbf{*}$ 枚举。否则，它消耗 $1$ 单位的能量并继续分析两个字符串。\n\n当模式字符串耗尽时，系统将同时检查待匹配字符串。如果待匹配字符串也已经耗尽，系统将返回“是”并停止整个过程，否则，它将返回到先前的 $\\textbf{*}$ 枚举。在尝试了所有尝试并找不到匹配方法后，系统最终将返回“否”。\n\n最小匹配执行类似的操作，除了 $\\textbf{*}$ 的枚举顺序（即从 $0$ 到 $L$ 枚举 $i$）。\n\n这两种匹配方法似乎不太有效，所以你想黑掉它们。请为每种匹配方法构造一个长度为 $n$ 的模式字符串和待匹配字符串，使得系统返回“是”，能量消耗尽可能大。", "inputFormat": "每个测试文件中只有一个测试用例。\n\n第一行仅包含一个整数 $n$（$1 \\le n \\le 10^3$），表示需要构造的字符串的长度。", "outputFormat": "请输出最大匹配方法的模式字符串、待匹配字符串和能量消耗的前 $3$ 行。然后输出最小匹配方法的模式字符串、待匹配字符串和能量消耗的后 $3$ 行。\n\n如果有多种构造方式，你可以输出任何一种。\n\n能量消耗可能非常大，所以你需要输出取模 $(10^9+7)$ 后的值。请注意，这仅供你方便，你需要在取模之前最大化能量消耗。", "hint": "题目描述\n\n作为安全部门的负责人，你被要求检查公司的一古老匹配系统。\n\n该系统输入两个字符串，一个待匹配字符串和一个模式字符串，并确定前者是否能匹配后者。前者字符串是严格的二进制字符串（即仅包含 $\\textbf{0}$ 和 $\\textbf{1}$），而后者字符串由四种类型的字符组成：$\\textbf{0}$、$\\textbf{1}$、$\\textbf{*}$ 和 $^$，其中 $\\textbf{*}$ 表示匹配零个或多个任意二进制字符，$^$ 表示匹配恰好一个二进制字符。\n\n该系统有两种匹配方法：最大匹配和最小匹配。\n\n考虑两个字符串的起始位置。最大匹配方法将根据模式字符串的当前字符做出不同的决定：\n- $\\textbf{*}$: 系统将从 $L$ 到 $0$ 枚举 $i$，其中 $L$ 是待匹配字符串的剩余长度。在每次枚举开始之前，系统消耗 1 单位的能量。然后它暂时假设模式字符串中的当前 $\\textbf{*}$ 匹配待匹配字符串中的连续 $i$ 个字符，并尝试递归地匹配两个字符串的剩余位置。只要有一次尝试成功，系统将放弃剩余的枚举并停止整个系统。否则，它将尝试下一个枚举，直到所有尝试都被尝试完毕，最后返回到先前的 $\\textbf{*}$ 枚举。\n- $\\textbf{0,1}$: 如果待匹配字符串已经耗尽，系统将停止并返回到先前的 $\\textbf{*}$ 枚举。否则，它消耗 $1$ 单位的能量来比较模式字符串和待匹配字符串之间的当前字符。如果结果相同，它将继续分析这两个字符串的剩余位置，否则返回到先前的 $\\textbf{*}$ 枚举。\n- $^$: 如果待匹配字符串已经耗尽，系统将停止并返回到先前的 $\\textbf{*}$ 枚举。否则，它消耗 $1$ 单位的能量并继续分析两个字符串。\n\n当模式字符串耗尽时，系统将同时检查待匹配字符串。如果待匹配字符串也已经耗尽，系统将返回“是”并停止整个过程，否则，它将返回到先前的 $\\textbf{*}$ 枚举。在尝试了所有尝试并找不到匹配方法后，系统最终将返回“否”。\n\n最小匹配执行类似的操作，除了 $\\textbf{*}$ 的枚举顺序（即从 $0$ 到 $L$ 枚举 $i$）。\n\n这两种匹配方法似乎不太有效，所以你想黑掉它们。请为每种匹配方法构造一个长度为 $n$ 的模式字符串和待匹配字符串，使得系统返回“是”，能量消耗尽可能大。\n\n输入格式\n\n每个测试文件中只有一个测试用例。\n\n第一行仅包含一个整数 $n$（$1 \\le n \\le 10^3$），表示需要构造的字符串的长度。\n\n输出格式\n\n请输出最大匹配方法的模式字符串、待匹配字符串和能量消耗的前 $3$ 行。然后输出最小匹配方法的模式字符串、待匹配字符串和能量消耗的后 $3$ 行。\n\n如果有多种构造方式，你可以输出任何一种。\n\n能量消耗可能非常大，所以你需要输出取模 $(10^9+7)$ 后的值。请注意，这仅供你方便，你需要在取模之前最大化能量消耗。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9658", "type": "P", "difficulty": 5, "samples": [["3\n2\n1 0\n2 0\n3\n1 0\n0 1\n-1 -1\n5\n2 -1\n1 2\n-1 2\n-2 -1\n0 -2", "0\n1\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["计算几何", "2021", "O2优化", "叉积", "ICPC", "双指针 two-pointer", "澳门"], "title": "[ICPC 2021 Macao R] Laser Trap", "background": "", "description": "BaoBao is playing the famous game $\\textit{Elden Ring}$ these days. It's an open-world game in which you can control your character to travel from places to places. However, your character could also enter a trap and you need to figure out how to escape. Right now, BaoBao's character is stuck in a 2-dimensional plane with deadly lasers. There are $n$ laser generators (each can be regarded as a point) shooting laser beams between every pair of them (so there are $\\frac{n(n-1)}{2}$ laser beams in total). The beams start and end at generator points and do not stretch to infinity.\n\nStarting at point $(0,0)$, BaoBao wants to escape to point $(10^{10^{10^{10^{10}}}}, 10^{10^{10^{10^{10}}}})$ without touching any laser beam or generator. In order to do so, BaoBao can ask her friend DreamGrid to remove any number of laser generators, together with any laser beam that starts or ends at these generators. Output the minimum number of laser generators that need to be erased for the escape.\n\nNote that BaoBao does not need to move in a specific direction to escape. Her escaping route can even be a curve if necessary.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^6$) indicating the number of laser generators.\n\nFor the following $n$ lines, the $i$-th line contains two integers $x_i$ and $y_i$ ($-10^9 \\le x_i, y_i \\le 10^9$) indicating the location of the $i$-th laser generator.\n\nIt is guaranteed that no two generators coincide, and no laser beam or generator will touch $(0,0)$.\n\nIt is also guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the minimum number of generators that need to be removed.", "hint": "The second and the third sample test cases are shown below. Solid dots and lines represent the remaining laser generators and beams, while hollow dots and dashed lines represent the removed laser generators and beams. The arrow is the escaping route.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b0sz7cm0.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dwcsdmj6.png)", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] Laser Trap", "background": "", "description": "BaoBao is playing the famous game $\\textit{Elden Ring}$ these days. It's an open-world game in which you can control your character to travel from places to places. However, your character could also enter a trap and you need to figure out how to escape. Right now, BaoBao's character is stuck in a 2-dimensional plane with deadly lasers. There are $n$ laser generators (each can be regarded as a point) shooting laser beams between every pair of them (so there are $\\frac{n(n-1)}{2}$ laser beams in total). The beams start and end at generator points and do not stretch to infinity.\n\nStarting at point $(0,0)$, BaoBao wants to escape to point $(10^{10^{10^{10^{10}}}}, 10^{10^{10^{10^{10}}}})$ without touching any laser beam or generator. In order to do so, BaoBao can ask her friend DreamGrid to remove any number of laser generators, together with any laser beam that starts or ends at these generators. Output the minimum number of laser generators that need to be erased for the escape.\n\nNote that BaoBao does not need to move in a specific direction to escape. Her escaping route can even be a curve if necessary.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^6$) indicating the number of laser generators.\n\nFor the following $n$ lines, the $i$-th line contains two integers $x_i$ and $y_i$ ($-10^9 \\le x_i, y_i \\le 10^9$) indicating the location of the $i$-th laser generator.\n\nIt is guaranteed that no two generators coincide, and no laser beam or generator will touch $(0,0)$.\n\nIt is also guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the minimum number of generators that need to be removed.", "hint": "The second and the third sample test cases are shown below. Solid dots and lines represent the remaining laser generators and beams, while hollow dots and dashed lines represent the removed laser generators and beams. The arrow is the escaping route.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b0sz7cm0.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dwcsdmj6.png)", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] Laser Trap", "background": "", "description": "最近，BaoBao 正在玩著名的游戏 $Elden Ring$。这是一款开放世界游戏，你可以控制角色在各个地方旅行。然而，你的角色也可能会进入陷阱，你需要想办法逃脱。现在，BaoBao 的角色被困在一个有致命激光的二维平面上。平面上有 $n$ 个激光发生器（每个可以看作一个点），它们之间的每一对都会发射激光束（因此总共有 $\\frac{n(n-1)}{2}$ 条激光束）。这些激光束从发生器点开始并在发生器点结束，不会延伸到无限远。\n\n从点 $(0,0)$ 开始，BaoBao 想要逃到点 $(10^{10^{10^{10^{10}}}}, 10^{10^{10^{10^{10}}}})$，而不触碰任何激光束或发生器。为了做到这一点，BaoBao 可以请求她的朋友 DreamGrid 移除任意数量的激光发生器，以及从这些发生器开始或结束的任何激光束。输出为逃脱所需移除的最小激光发生器数量。\n\n注意，BaoBao 不需要沿特定方向移动以逃脱。如果有必要，她的逃生路线甚至可以是曲线。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含一个整数 $n$ ($1 \\le n \\le 10^6$)，表示激光发生器的数量。\n\n接下来的 $n$ 行中，第 $i$ 行包含两个整数 $x_i$ 和 $y_i$ ($-10^9 \\le x_i, y_i \\le 10^9$)，表示第 $i$ 个激光发生器的位置。\n\n保证没有两个发生器重合，并且没有激光束或发生器会接触到 $(0,0)$。\n\n还保证所有测试用例的 $n$ 的总和不超过 $10^6$。", "outputFormat": "对于每个测试用例，输出一行，包含一个整数，表示需要移除的最小发生器数量。", "hint": "第二个和第三个样例测试用例如下所示。实心点和线代表剩余的激光发生器和光束，而空心点和虚线代表被移除的激光发生器和光束。箭头是逃生路线。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b0sz7cm0.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dwcsdmj6.png)\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9659", "type": "P", "difficulty": 6, "samples": [["1", "4 6\n1 2 1\n2 3 2\n3 4 3\n4 1 4\n1 3 5\n2 4 6"]], "limits": {"time": [1000, 1000], "memory": [262144, 262144]}, "tags": ["2021", "提交答案", "Special Judge", "O2优化", "构造", "ICPC", "澳门"], "title": "[ICPC 2021 Macao R] Shortest Path Fast Algorithm", "background": "", "description": "Recently, BaoBao has learned the Shortest Path Fast Algorithm (SPFA, or more formally, Bellman-Ford-Moore Algorithm) to solve the shortest path problem efficiently. He realizes that the algorithm looks so similar to the Dijkstra's algorithm after replacing the FIFO queue with priority queue, and shows you the below pseudo code.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yunmac9g.png)\n\nBy picking the best vertex from $Q$ we mean picking the vertex with the smallest priority value (in case that multiple vertices have the smallest priority value, pick the vertex with the largest index among them).\n\nYou, the future computer scientist, find the BaoBao-modified SPFA algorithm works so slow in some carefully construted graph. However, BaoBao is sure that his algorithm works well, unless you show him a simple undirected graph that makes the variable $\\tt{cnt}$ in the SPFA function no less than a certain $k$ $\\textbf{at some time}$. For convenience, the source vertex of the SPFA function is specified to be vertex $1$.\n\nJust teach him a lesson!", "inputFormat": "There is only one test case in each test file.\n\nThe first and only line of the input contains a single integer $k$ where $k = 1$ for the sample test case and $k = 10^5$ for the only secret test case.", "outputFormat": "Output several lines in the following format to describe the input data of a simple undirected graph that makes the variable $\\tt{cnt}$ in the SPFA function no less than $k$ $\\textbf{at some time}$.\n\nThe first line contains two integers $n$ ($1 \\le n \\le 100$) and $m$ ($0 \\le m \\le 10^3$), indicating the number of vertices and edges in the graph.\n\nThen $m$ lines follow, the $i$-th of which contains three integers $u_i$, $v_i$ ($1 \\le u_i, v_i \\le n$) and $w_i$ ($1 \\le w_i \\le 10^6$), indicating that the $i$-th edge in the graph has a weight of $w_i$ and connects the $u_i$-th and the $v_i$-th vertices.\n\nNote that a simple graph contains no self-loops and no multiple edges.", "hint": "For your convenience, you can copy the $\\tt{C++}$ code, which corresponds to the given pseudo code, from the contest website. Save the code as $\\tt{spfa.cpp}$, use $\\text{g++ spfa.cpp -O2 -o spfa}$ to compile it and you will get an executable file named $\\tt{spfa}$. Run $\\tt{spfa}$, feed your output to its standard input and it will print out the $\\textbf{final}$ value of $\\tt{cnt}$. Given the sample output it will print out $4$, which means the sample output is not sufficient to pass the secret test case.\n\nNote that the given code does not check the validity of your output (for example it does not check if your output is really a simple graph). You might still fail the test if your output is invalid, even if the executable prints out a large value.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] Shortest Path Fast Algorithm", "background": "", "description": "Recently, BaoBao has learned the Shortest Path Fast Algorithm (SPFA, or more formally, Bellman-Ford-Moore Algorithm) to solve the shortest path problem efficiently. He realizes that the algorithm looks so similar to the Dijkstra's algorithm after replacing the FIFO queue with priority queue, and shows you the below pseudo code.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yunmac9g.png)\n\nBy picking the best vertex from $Q$ we mean picking the vertex with the smallest priority value (in case that multiple vertices have the smallest priority value, pick the vertex with the largest index among them).\n\nYou, the future computer scientist, find the BaoBao-modified SPFA algorithm works so slow in some carefully construted graph. However, BaoBao is sure that his algorithm works well, unless you show him a simple undirected graph that makes the variable $\\tt{cnt}$ in the SPFA function no less than a certain $k$ $\\textbf{at some time}$. For convenience, the source vertex of the SPFA function is specified to be vertex $1$.\n\nJust teach him a lesson!", "inputFormat": "There is only one test case in each test file.\n\nThe first and only line of the input contains a single integer $k$ where $k = 1$ for the sample test case and $k = 10^5$ for the only secret test case.", "outputFormat": "Output several lines in the following format to describe the input data of a simple undirected graph that makes the variable $\\tt{cnt}$ in the SPFA function no less than $k$ $\\textbf{at some time}$.\n\nThe first line contains two integers $n$ ($1 \\le n \\le 100$) and $m$ ($0 \\le m \\le 10^3$), indicating the number of vertices and edges in the graph.\n\nThen $m$ lines follow, the $i$-th of which contains three integers $u_i$, $v_i$ ($1 \\le u_i, v_i \\le n$) and $w_i$ ($1 \\le w_i \\le 10^6$), indicating that the $i$-th edge in the graph has a weight of $w_i$ and connects the $u_i$-th and the $v_i$-th vertices.\n\nNote that a simple graph contains no self-loops and no multiple edges.", "hint": "For your convenience, you can copy the $\\tt{C++}$ code, which corresponds to the given pseudo code, from the contest website. Save the code as $\\tt{spfa.cpp}$, use $\\text{g++ spfa.cpp -O2 -o spfa}$ to compile it and you will get an executable file named $\\tt{spfa}$. Run $\\tt{spfa}$, feed your output to its standard input and it will print out the $\\textbf{final}$ value of $\\tt{cnt}$. Given the sample output it will print out $4$, which means the sample output is not sufficient to pass the secret test case.\n\nNote that the given code does not check the validity of your output (for example it does not check if your output is really a simple graph). You might still fail the test if your output is invalid, even if the executable prints out a large value.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] Shortest Path Fast Algorithm", "background": "", "description": "最近，宝宝学习了最短路径快速算法（SPFA，或更正式地说，贝尔曼-福特-摩尔算法）以有效地解决最短路径问题。他意识到，如果用优先队列代替先进先出队列，该算法看起来与 Dijkstra 算法非常相似，并向你展示了下面的伪代码。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yunmac9g.png)\n\n选择 $Q$ 中最佳顶点意味着选择具有最小优先级值的顶点（如果有多个顶点具有最小优先级值，则选择其中索引最大的顶点）。\n\n作为未来的计算机科学家，你发现宝宝修改后的 SPFA 算法在某些精心构造的图中运行速度非常慢。然而，宝宝确信他的算法很好，除非你向他展示一个简单的无向图，在该图中，SPFA 函数中的变量 $\\tt{cnt}$ 在某个时刻不少于某个 $k$。为方便起见，SPFA 函数的源顶点被指定为顶点 $1$。\n\n就给他个教训吧！", "inputFormat": "每个测试文件中只有一个测试用例。\n\n输入的第一行包含一个整数 $k$，其中 $k = 1$ 为示例测试用例，$k = 10^5$ 为唯一的秘密测试用例。", "outputFormat": "输出几行以以下格式描述简单无向图的输入数据，使得 SPFA 函数中的变量 $\\tt{cnt}$ 在某个时刻不少于 $k$。\n\n第一行包含两个整数 $n$（$1 \\le n \\le 100$）和 $m$（$0 \\le m \\le 10^3$），表示图中的顶点数和边数。\n\n然后，跟着 $m$ 行，第 $i$ 行包含三个整数 $u_i$、$v_i$（$1 \\le u_i, v_i \\le n$）和 $w_i$（$1 \\le w_i \\le 10^6$），表示图中的第 $i$ 条边的权重为 $w_i$，连接了第 $u_i$ 个和第 $v_i$ 个顶点。\n\n注意，简单图不包含自环和重边。", "hint": "为方便起见，你可以从比赛网站上复制与给定伪代码对应的 $\\tt{C++}$ 代码。将代码保存为 $\\tt{spfa.cpp}$，使用 $\\text{g++ spfa.cpp -O2 -o spfa}$ 进行编译，你将得到一个名为 $\\tt{spfa}$ 的可执行文件。运行 $\\tt{spfa}$，将你的输出提供给它的标准输入，它将打印出 $\\tt{cnt}$ 的 $\\textbf{最终}$ 值。给出示例输出后，它将打印出 $4$，这意味着示例输出不足以通过秘密测试用例。\n\n注意，给定的代码不会检查你的输出的有效性（例如，它不会检查你的输出是否真的是一个简单图）。即使可执行文件打印出一个很大的值，如果你的输出无效，你仍然可能失败测试。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "locale": "zh-CN"}}}
{"pid": "P9660", "type": "P", "difficulty": 6, "samples": [["4 4\n2 4 1 3\n1\n2\n3\n4", "25\n20\n25\n30"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2021", "多项式", "O2优化", "快速傅里叶变换 FFT", "快速数论变换 NTT", "ICPC", "澳门"], "title": "[ICPC 2021 Macao R] Pass the Ball!", "background": "", "description": "There are $n$ children playing with $n$ balls. Both children and balls are numbered from $1$ to $n$.\n\nBefore the game, $n$ integers $p_1, p_2, \\cdots, p_n$ are given. In each round of the game, child $i$ will pass the ball he possesses to child $p_i$. It is guaranteed that no child will pass his ball to himself, which means $p_i \\neq i$. Moreover, we also know that after each round, each child will hold exactly one ball.\n\nLet $b_i$ be the ball possessed by child $i$. At the beginning of the game, child $i$ ($1 \\le i \\le n$) will be carrying ball $i$, which means $b_i=i$ initially. You're asked to process $q$ queries. For each query you're given an integer $k$ and you need to compute the value of $\\sum\\limits_{i=1}^{n} i \\times b_i$ after $k$ rounds.", "inputFormat": "There is only one test case for each test file.\n\nThe first line of the input contains two integers $n$ ($2 \\le n \\le 10^5$) and $q$ ($1 \\le q \\le 10^5$), indicating the number of children and the number of queries.\n\nThe second line contains $n$ integers $p_1, p_2, \\cdots, p_n$ ($1 \\le p_i \\le n$) indicating how the children pass the balls around.\n\nFor the following $q$ lines, the $i$-th line contains one integer $k_i$ ($1 \\le k_i \\le 10^9$) indicating a query asking for the result after $k_i$ rounds.", "outputFormat": "For each query output one line containing one integer indicating the answer.", "hint": "The sample test case is explained below.\n\n$$\n\\begin{array}{|c|c|c|c|c|c|} \\hline \\textbf{Round} & \\textbf{b1} & \\textbf{b2} & \\textbf{b3} & \\textbf{b4} & \\textbf{Answer} \\\\\\hline \n1 & 3 & 1 & 4 & 2 & 25 \\\\\\hline\n2 & 4 & 3 & 2 & 1 & 20 \\\\\\hline\n3 & 2 & 4 & 1 & 3 & 25 \\\\\\hline\n4 & 1 & 2 & 3 & 4 & 30 \\\\\\hline\n\\end{array}\n$$", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] Pass the Ball!", "background": "", "description": "There are $n$ children playing with $n$ balls. Both children and balls are numbered from $1$ to $n$.\n\nBefore the game, $n$ integers $p_1, p_2, \\cdots, p_n$ are given. In each round of the game, child $i$ will pass the ball he possesses to child $p_i$. It is guaranteed that no child will pass his ball to himself, which means $p_i \\neq i$. Moreover, we also know that after each round, each child will hold exactly one ball.\n\nLet $b_i$ be the ball possessed by child $i$. At the beginning of the game, child $i$ ($1 \\le i \\le n$) will be carrying ball $i$, which means $b_i=i$ initially. You're asked to process $q$ queries. For each query you're given an integer $k$ and you need to compute the value of $\\sum\\limits_{i=1}^{n} i \\times b_i$ after $k$ rounds.", "inputFormat": "There is only one test case for each test file.\n\nThe first line of the input contains two integers $n$ ($2 \\le n \\le 10^5$) and $q$ ($1 \\le q \\le 10^5$), indicating the number of children and the number of queries.\n\nThe second line contains $n$ integers $p_1, p_2, \\cdots, p_n$ ($1 \\le p_i \\le n$) indicating how the children pass the balls around.\n\nFor the following $q$ lines, the $i$-th line contains one integer $k_i$ ($1 \\le k_i \\le 10^9$) indicating a query asking for the result after $k_i$ rounds.", "outputFormat": "For each query output one line containing one integer indicating the answer.", "hint": "The sample test case is explained below.\n\n$$\n\\begin{array}{|c|c|c|c|c|c|} \\hline \\textbf{Round} & \\textbf{b1} & \\textbf{b2} & \\textbf{b3} & \\textbf{b4} & \\textbf{Answer} \\\\\\hline \n1 & 3 & 1 & 4 & 2 & 25 \\\\\\hline\n2 & 4 & 3 & 2 & 1 & 20 \\\\\\hline\n3 & 2 & 4 & 1 & 3 & 25 \\\\\\hline\n4 & 1 & 2 & 3 & 4 & 30 \\\\\\hline\n\\end{array}\n$$", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] Pass the Ball!", "background": "", "description": "有 $n$ 个孩子和 $n$ 个球在玩游戏。孩子和球都从 $1$ 编号到 $n$。\n\n游戏开始前，给出了 $n$ 个整数 $p_1, p_2, \\cdots, p_n$。在游戏的每一轮中，孩子 $i$ 会把他手里的球传给孩子 $p_i$。保证没有孩子会把他手里的球传给自己，也就是说 $p_i \\neq i$。此外，我们还知道在每一轮之后，每个孩子手里都会正好持有一个球。\n\n设 $b_i$ 表示孩子 $i$ 所持有的球。在游戏开始时，孩子 $i$（$1 \\le i \\le n$）将携带球 $i$，也就是说 $b_i=i$。你需要处理 $q$ 个查询。对于每个查询，你会得到一个整数 $k$，你需要计算在 $k$ 轮后 $\\sum\\limits_{i=1}^{n} i \\times b_i$ 的值。", "inputFormat": "输入的第一行包含两个整数 $n$（$2 \\le n \\le 10^5$）和 $q$（$1 \\le q \\le 10^5$），表示孩子的数量和查询的数量。\n\n第二行包含 $n$ 个整数 $p_1, p_2, \\cdots, p_n$（$1 \\le p_i \\le n$），表示孩子之间传球的方式。\n\n接下来的 $q$ 行中，第 $i$ 行包含一个整数 $k_i$（$1 \\le k_i \\le 10^9$），表示询问在 $k_i$ 轮后的结果。", "outputFormat": "对于每个查询，输出一行包含一个整数，表示答案。\n\n**【样例解释】**\n\n示例测试用例解释如下。\n\n$$\n\\begin{array}{|c|c|c|c|c|c|} \\hline \\textbf{轮次} & \\textbf{b1} & \\textbf{b2} & \\textbf{b3} & \\textbf{b4} & \\textbf{答案} \\\\\\hline \n1 & 3 & 1 & 4 & 2 & 25 \\\\\\hline\n2 & 4 & 3 & 2 & 1 & 20 \\\\\\hline\n3 & 2 & 4 & 1 & 3 & 25 \\\\\\hline\n4 & 1 & 2 & 3 & 4 & 30 \\\\\\hline\n\\end{array}\n$$\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9661", "type": "P", "difficulty": 4, "samples": [["5\n5 0 3 0 3", "3 3 1 3 1"], ["2\n1 0", "Recurrent"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2021", "O2优化", "ICPC", "Ad-hoc", "澳门"], "title": "[ICPC 2021 Macao R] Sandpile on Clique", "background": "", "description": "The $\\textit{Abelian Sandpile Model}$ is a famous dynamical system displaying self-organized criticality. It has been studied for decades since it was introduced by Per Bak, Chao Tang and Kurt Wiesenfeld in a 1987 paper. The sandpile prediction is of wide interest in physics,\ncomputer science, and mathematics, both for its beautiful algebraic structure and for its relevance to applications like load balancing and derandomization of models like internal diffusion-limited aggregation. The sandpile model is related to many other models and physical phenomena, like the rotor-routing model, avalanche models.\n\nIn the sandpile model, we are given an undirected graph $G$ whose vertices are indexed from $1$ to $n$. We're also given $n$ integers $a_1, a_2, \\cdots, a_n$ where $a_i$ indicates that there are $a_i$ chips placed on vertex $i$ initially. Each turn we will pick an arbitrary vertex $v$ such that the number of chips on $v$ is not smaller than the number of edges connecting $v$, denoted as $d_v$. For each neighbor of $v$, it will receive one chip from $v$. Therefore, $v$ will lost $d_v$ chips. This process is called firing or toppling. Firing will keep happening until no vertex $v$ has at least $d_v$ chips.\n\nIt can be proven that the order of firing doesn't affect the result. Meanwhile, it is also possible that the firing will never terminate. This instance is described as ``recurrent``. Now you are given a clique and the initial number of chips. Determine whether this instance is a recurrent one. If not, please output the final number of chips for each node respectively.\n\nA clique (also called a complete graph) is a graph where every two vertices are connected with an edge.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains an integer $n$ ($2 \\leq n \\leq 5 \\times 10^5$) indicating the size of the clique. \n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($0 \\leq a_i \\leq 10^9$) where $a_i$ indicates the initial number of chips placed on vertex $i$.\n", "outputFormat": "Output one line. If the given sandpile instance will terminate, output $n$ integers separated by a space where the $i$-th integer indicates the final number of chips on the $i$-th vertex. Otherwise output ``Recurrent`` (without quotes) instead.\n\nPlease, DO NOT output extra spaces at the end of each line or your solution may be considered incorrect!", "hint": "For the first sample test case:\n\n- We can only select vertex $1$ at the beginning. The number of chips becomes $\\{1, 1, 4, 1, 4\\}$.\n- We can now select vertex $3$ or $5$ because both of them have at least $4$ chips. We select vertex $3$ and the number of chips becomes $\\{2, 2, 0, 2, 5\\}$. Selecting vertex $5$ will lead to the same result.\n- We now select vertex $5$. The number of chips becomes $\\{3, 3, 1, 3, 1\\}$. There is no vertex with at least $4$ chips so the firing terminates.\n\nFor the second sample test case, we can select vertex $1$ and $2$ repeatedly. The firing never terminates.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] Sandpile on Clique", "background": "", "description": "The $\\textit{Abelian Sandpile Model}$ is a famous dynamical system displaying self-organized criticality. It has been studied for decades since it was introduced by Per Bak, Chao Tang and Kurt Wiesenfeld in a 1987 paper. The sandpile prediction is of wide interest in physics,\ncomputer science, and mathematics, both for its beautiful algebraic structure and for its relevance to applications like load balancing and derandomization of models like internal diffusion-limited aggregation. The sandpile model is related to many other models and physical phenomena, like the rotor-routing model, avalanche models.\n\nIn the sandpile model, we are given an undirected graph $G$ whose vertices are indexed from $1$ to $n$. We're also given $n$ integers $a_1, a_2, \\cdots, a_n$ where $a_i$ indicates that there are $a_i$ chips placed on vertex $i$ initially. Each turn we will pick an arbitrary vertex $v$ such that the number of chips on $v$ is not smaller than the number of edges connecting $v$, denoted as $d_v$. For each neighbor of $v$, it will receive one chip from $v$. Therefore, $v$ will lost $d_v$ chips. This process is called firing or toppling. Firing will keep happening until no vertex $v$ has at least $d_v$ chips.\n\nIt can be proven that the order of firing doesn't affect the result. Meanwhile, it is also possible that the firing will never terminate. This instance is described as ``recurrent``. Now you are given a clique and the initial number of chips. Determine whether this instance is a recurrent one. If not, please output the final number of chips for each node respectively.\n\nA clique (also called a complete graph) is a graph where every two vertices are connected with an edge.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains an integer $n$ ($2 \\leq n \\leq 5 \\times 10^5$) indicating the size of the clique. \n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($0 \\leq a_i \\leq 10^9$) where $a_i$ indicates the initial number of chips placed on vertex $i$.\n", "outputFormat": "Output one line. If the given sandpile instance will terminate, output $n$ integers separated by a space where the $i$-th integer indicates the final number of chips on the $i$-th vertex. Otherwise output ``Recurrent`` (without quotes) instead.\n\nPlease, DO NOT output extra spaces at the end of each line or your solution may be considered incorrect!", "hint": "For the first sample test case:\n\n- We can only select vertex $1$ at the beginning. The number of chips becomes $\\{1, 1, 4, 1, 4\\}$.\n- We can now select vertex $3$ or $5$ because both of them have at least $4$ chips. We select vertex $3$ and the number of chips becomes $\\{2, 2, 0, 2, 5\\}$. Selecting vertex $5$ will lead to the same result.\n- We now select vertex $5$. The number of chips becomes $\\{3, 3, 1, 3, 1\\}$. There is no vertex with at least $4$ chips so the firing terminates.\n\nFor the second sample test case, we can select vertex $1$ and $2$ repeatedly. The firing never terminates.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] Sandpile on Clique", "background": "", "description": "阿贝尔沙堆模型（Abelian Sandpile Model）是一个著名的显示自组织临界性的动力学系统。自从它由 Per Bak、Chao Tang 和 Kurt Wiesenfeld 在 1987 年的一篇论文中引入以来，它已经被研究了数十年。沙堆模型的预测引起了物理学、计算机科学和数学的广泛关注，这不仅是因为它美丽的代数结构，还因为它与负载平衡和内部扩散有关的模型的应用，如去随机化。沙堆模型与许多其他模型和物理现象相关，如转子路由模型、雪崩模型。\n\n在沙堆模型中，给定一个顶点编号从 $1$ 到 $n$ 的无向图 $G$。我们还给出了 $n$ 个整数 $a_1, a_2, \\cdots, a_n$，其中 $a_i$ 表示初始时放置在顶点 $i$ 上的筹码数量。每个回合，我们将选择一个任意的顶点 $v$，使得 $v$ 上的筹码数量不小于与 $v$ 相连的边数，记为 $d_v$。对于 $v$ 的每个邻居，它将从 $v$ 接收一枚筹码。因此，$v$ 将失去 $d_v$ 枚筹码。这个过程被称为 ``firing`` 或 ``toppling``。直到没有顶点 $v$ 至少有 $d_v$ 枚筹码时，firing 才会停止。\n\n可以证明，firing 的顺序不会影响结果。同时，也可能 firing 永远不会终止。这种情况被描述为“recurrent”。现在给定一个团和初始筹码数量，请确定这个实例是否是一个 recurrent 实例。如果不是，请分别输出每个节点的最终筹码数量。\n\n团（也称为完全图）是一个图，其中任意两个顶点都有边相连。", "inputFormat": "每个测试文件中只有一个测试用例。\n\n输入的第一行包含一个整数 $n$（$2 \\leq n \\leq 5 \\times 10^5$），表示团的大小。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\cdots, a_n$（$0 \\leq a_i \\leq 10^9$），其中 $a_i$ 表示放置在顶点 $i$ 上的初始筹码数量。", "outputFormat": "输出一行。如果给定的沙堆实例将终止，则输出由空格分隔的 $n$ 个整数，其中第 $i$ 个整数表示第 $i$ 个顶点上的最终筹码数量。否则输出 ``Recurrent``（不包括引号）。\n\n请不要在每行末尾输出额外的空格，否则您的解决方案可能被认为是错误的！\n\n**【样例解释】**\n\n对于第一个样例测试用例：\n\n- 我们只能在开始时选择顶点 $1$。筹码数量变为 $\\{1, 1, 4, 1, 4\\}$。\n- 现在我们可以选择顶点 $3$ 或 $5$，因为它们都至少有 $4$ 枚筹码。我们选择顶点 $3$，筹码数量变为 $\\{2, 2, 0, 2, 5\\}$。选择顶点 $5$ 会得到相同的结果。\n- 现在我们选择顶点 $5$。筹码数量变为 $\\{3, 3, 1, 3, 1\\}$。没有顶点至少有 $4$ 枚筹码，因此 firing 终止。\n\n对于第二个样例测试用例，我们可以重复选择顶点 $1$ 和 $2$。firing 永远不会终止。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9662", "type": "P", "difficulty": 5, "samples": [["2\n5 3\n2 4 3 5 1\n1 1\n1", "3\n0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2021", "O2优化", "ICPC", "澳门"], "title": "[ICPC 2021 Macao R] Cyclic Buffer", "background": "", "description": "There is a cyclic buffer of size $n$ with readers from the $1$-st position to the $k$-th position (both inclusive). Let $a_i$ ($1 \\le i \\le n$) be the integer at the $i$-th position of the buffer initially. What's more, $a_1, a_2, \\cdots, a_n$ form a permutation of $n$.\n\nWe're going to visit all the integers from $1$ to $n$ (both inclusive) in increasing order. An integer can be visited only when it is residing in positions with readers (that is to say, when it is in the first $k$ positions). In case that an integer cannot be visited, we can shift the whole buffer in either directions any number of times.\n\n- If we shift the buffer to the left once, integers in the $i$-th position will be moved to the $(i - 1)$-th position if $i > 1$, and integer in the $1$-st position will be moved to the $n$-th position.\n- If we shift the buffer to the right once, integers in the $i$-th position will be moved to the $(i + 1)$-th position if $i < n$, and integer in the $n$-th position will be moved to the $1$-st position.\n\nWhat's the minimum number of times to shift the buffer so that we can visit all the integers in increasing order?", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 10^6$) indicating the size of the buffer and the number of readers.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le n$) where $a_i$ indicates the integer in the $i$-th position of the buffer initially.\n\nIt's guaranteed that the given $n$ integers form a permutation of $n$. It's also guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the minimum number of times to shift the buffer so that all integers can be visited in increasing order.", "hint": "For the first sample test case:\n- Shift to the right once so the buffer becomes $\\{1, 2, 4, 3, 5\\}$. $1$ and $2$ can now be visited in order as they are in the first $3$ positions.\n- Shift to the left twice so the buffer becomes $\\{4, 3, 5, 1, 2\\}$. $3$, $4$ and $5$ can now be visited in order as they are in the first $3$ positions.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] Cyclic Buffer", "background": "", "description": "There is a cyclic buffer of size $n$ with readers from the $1$-st position to the $k$-th position (both inclusive). Let $a_i$ ($1 \\le i \\le n$) be the integer at the $i$-th position of the buffer initially. What's more, $a_1, a_2, \\cdots, a_n$ form a permutation of $n$.\n\nWe're going to visit all the integers from $1$ to $n$ (both inclusive) in increasing order. An integer can be visited only when it is residing in positions with readers (that is to say, when it is in the first $k$ positions). In case that an integer cannot be visited, we can shift the whole buffer in either directions any number of times.\n\n- If we shift the buffer to the left once, integers in the $i$-th position will be moved to the $(i - 1)$-th position if $i > 1$, and integer in the $1$-st position will be moved to the $n$-th position.\n- If we shift the buffer to the right once, integers in the $i$-th position will be moved to the $(i + 1)$-th position if $i < n$, and integer in the $n$-th position will be moved to the $1$-st position.\n\nWhat's the minimum number of times to shift the buffer so that we can visit all the integers in increasing order?", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 10^6$) indicating the size of the buffer and the number of readers.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le n$) where $a_i$ indicates the integer in the $i$-th position of the buffer initially.\n\nIt's guaranteed that the given $n$ integers form a permutation of $n$. It's also guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the minimum number of times to shift the buffer so that all integers can be visited in increasing order.", "hint": "For the first sample test case:\n- Shift to the right once so the buffer becomes $\\{1, 2, 4, 3, 5\\}$. $1$ and $2$ can now be visited in order as they are in the first $3$ positions.\n- Shift to the left twice so the buffer becomes $\\{4, 3, 5, 1, 2\\}$. $3$, $4$ and $5$ can now be visited in order as they are in the first $3$ positions.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] Cyclic Buffer", "background": "", "description": "有一个大小为 $n$ 的循环缓冲区，读入流从第 $1$ 个位置到第 $k$ 个位置（两者都包含在内）。设 $a_i$ ($1 \\le i \\le n$) 是缓冲区初始时第 $i$ 个位置上的整数。此外，$a_1, a_2, \\cdots, a_n$ 形成 $n$ 的一个排列。\n\n我们将以递增顺序访问从 $1$ 到 $n$ 的所有整数（两者都包含在内）。只有当整数位于具有读入流的位置（即位于前 $k$ 个位置）时，才能访问整数。如果某个整数无法访问，则可以将整个缓冲区向任意方向移动任意次数。\n\n- 如果我们向左移动缓冲区一次，则位于第 $i$ 个位置的整数将移动到第 $(i - 1)$ 个位置（如果 $i > 1$），并且位于第 $1$ 个位置的整数将移动到第 $n$ 个位置。\n- 如果我们向右移动缓冲区一次，则位于第 $i$ 个位置的整数将移动到第 $(i + 1)$ 个位置（如果 $i < n$），并且位于第 $n$ 个位置的整数将移动到第 $1$ 个位置。\n\n我们需要移动缓冲区的最小次数，以便以递增顺序访问所有整数。", "inputFormat": "每个测试文件中包含多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含两个整数 $n$ 和 $k$ ($1 \\le k \\le n \\le 10^6$)，表示缓冲区的大小和读入流的数量。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le n$)，其中 $a_i$ 表示缓冲区初始时第 $i$ 个位置上的整数。\n\n保证给定的 $n$ 个整数构成 $n$ 的一个排列。还保证所有测试用例中 $n$ 的总和不超过 $10^6$。", "outputFormat": "对于每个测试用例，输出一行，包含一个整数，表示移动缓冲区的最小次数，以便所有整数可以以递增顺序访问。\n\n**【样例解释】**\n\n对于第一个样例测试用例：\n- 向右移动一次，使缓冲区变为 $\\{1, 2, 4, 3, 5\\}$。现在 $1$ 和 $2$ 可以按顺序访问，因为它们位于前 $3$ 个位置。\n- 向左移动两次，使缓冲区变为 $\\{4, 3, 5, 1, 2\\}$。现在 $3$、$4$ 和 $5$ 可以按顺序访问，因为它们位于前 $3$ 个位置。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9663", "type": "P", "difficulty": 6, "samples": [["4 2\n1 2\n2 3\n1 4", "15"], ["3 1\n1 2\n2 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2021", "O2优化", "树形 DP", "ICPC", "澳门"], "title": "[ICPC 2021 Macao R] Permutation on Tree", "background": "", "description": "Given a tree with $n$ vertices where vertex $r$ is the root, we say a permutation $p_1, p_2, \\cdots, p_n$ of $n$ is good if it satisfies the following constraint:\n\n- Let $a_x$ be the index of $x$ in the permutation (That is, $p_{a_x} = x$). For all $1 \\le u, v \\le n$, if vertex $u$ is an ancestor of vertex $v$ in the tree, then $a_u < a_v$.\n\nDefine the score of a permutation to be $\\sum\\limits_{i=1}^{n-1} |p_i - p_{i+1}|$ where $|x|$ is the absolute value of $x$. Calculate the sum of scores of all different good permutations.", "inputFormat": "There is only one test case in each test file.\n\nThe first line contains two integers $n$ and $r$ ($2 \\le n \\le 200$, $1 \\le r \\le n$) indicating the size of the tree and the root.\n\nFor the following $(n - 1)$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$) indicating an edge connecting vertex $u_i$ and $v_i$ in the tree.", "outputFormat": "For each test case output one line containing one integer indicating the sum of scores of all different good permutations. As the answer may be large, output the answer modulo $(10^9 + 7)$.", "hint": "For the first sample test case, there are three good permutations: $\\{2, 1, 3, 4\\}$, $\\{2, 1, 4, 3\\}$ and $\\{2, 3, 1, 4\\}$. Their scores are $4$, $5$ and $6$ respectively so the answer is $4 + 5 + 6 = 15$.\n\nFor the second sample test case, there is only one good permutation: $\\{1, 2, 3\\}$. It's score is $2$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] Permutation on Tree", "background": "", "description": "Given a tree with $n$ vertices where vertex $r$ is the root, we say a permutation $p_1, p_2, \\cdots, p_n$ of $n$ is good if it satisfies the following constraint:\n\n- Let $a_x$ be the index of $x$ in the permutation (That is, $p_{a_x} = x$). For all $1 \\le u, v \\le n$, if vertex $u$ is an ancestor of vertex $v$ in the tree, then $a_u < a_v$.\n\nDefine the score of a permutation to be $\\sum\\limits_{i=1}^{n-1} |p_i - p_{i+1}|$ where $|x|$ is the absolute value of $x$. Calculate the sum of scores of all different good permutations.", "inputFormat": "There is only one test case in each test file.\n\nThe first line contains two integers $n$ and $r$ ($2 \\le n \\le 200$, $1 \\le r \\le n$) indicating the size of the tree and the root.\n\nFor the following $(n - 1)$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$) indicating an edge connecting vertex $u_i$ and $v_i$ in the tree.", "outputFormat": "For each test case output one line containing one integer indicating the sum of scores of all different good permutations. As the answer may be large, output the answer modulo $(10^9 + 7)$.", "hint": "For the first sample test case, there are three good permutations: $\\{2, 1, 3, 4\\}$, $\\{2, 1, 4, 3\\}$ and $\\{2, 3, 1, 4\\}$. Their scores are $4$, $5$ and $6$ respectively so the answer is $4 + 5 + 6 = 15$.\n\nFor the second sample test case, there is only one good permutation: $\\{1, 2, 3\\}$. It's score is $2$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] Permutation on Tree", "background": "", "description": "给定一个有 $n$ 个顶点的树，其中顶点 $r$ 是根，如果一个排列 $p_1, p_2, \\cdots, p_n$ 满足以下约束条件，我们称其为好排列：\n\n- 设 $a_x$ 是排列中 $x$ 的索引（即 $p_{a_x} = x$）。对于所有 $1 \\le u, v \\le n$，如果顶点 $u$ 是树中顶点 $v$ 的祖先，则 $a_u < a_v$。\n\n定义排列的分数为 $\\sum\\limits_{i=1}^{n-1} |p_i - p_{i+1}|$，其中 $|x|$ 表示 $x$ 的绝对值。计算所有不同好排列的分数之和。", "inputFormat": "每个测试文件中包含一个测试用例。输入的第一行包含两个整数 $n$ 和 $r$ ($2 \\le n \\le 200$, $1 \\le r \\le n$)，表示树的大小和根。\n\n接下来的 $(n - 1)$ 行，第 $i$ 行包含两个整数 $u_i$ 和 $v_i$ ($1 \\le u_i, v_i \\le n$)，表示树中连接顶点 $u_i$ 和 $v_i$ 的边。", "outputFormat": "对于每个测试用例，输出一行，包含一个整数，表示所有不同好排列的分数之和。由于答案可能很大，输出答案对 $(10^9 + 7)$ 取模的结果。\n\n**【样例解释】**\n\n对于第一个样例测试用例，有三个好排列：$\\{2, 1, 3, 4\\}$、$\\{2, 1, 4, 3\\}$ 和 $\\{2, 3, 1, 4\\}$。它们的分数分别为 $4$、$5$ 和 $6$，因此答案为 $4 + 5 + 6 = 15$。\n\n对于第二个样例测试用例，只有一个好排列：$\\{1, 2, 3\\}$。它的分数为 $2$。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9664", "type": "P", "difficulty": 6, "samples": [["4\nicpc\nmacau\nregional\ncontest", "4"], ["3\nababa\nbabab\naba", "7"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "后缀自动机 SAM", "O2优化", "生成树", "后缀数组 SA", "后缀树", "ICPC", "澳门"], "title": "[ICPC 2021 Macao R] LCS Spanning Tree", "background": "", "description": "Given a complete undirected graph of $n$ vertices and $n$ strings $s_1, s_2, \\cdots, s_n$, the weight of edge connecting vertices $i$ and $j$ is equal to the length of the longest common substring (LCS) between $s_i$ and $s_j$. Compute the maximum total weight of any spanning tree on this graph.\n\nA substring of a string can be obtained by removing some (possibly zero) characters from the beginning and/or the end of that string. For example, ``maca``, ``aca`` and ``cau`` are all substrings of ``macau``, while ``acu`` is not.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains one integer $n$ ($1 \\leq n \\leq 2 \\times 10^6$) indicating the number of vertices and strings.\n\nFor the following $n$ lines, the $i$-th line contains one string $s_i$ ($1 \\le |s_i| \\le 2 \\times 10^6$) consisting only of lowercase English letters.\n\nIt's guaranteed that the sum of lengths of all strings will not exceed $2 \\times 10^6$.", "outputFormat": "Output one line containing one integer indicating the answer.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] LCS Spanning Tree", "background": "", "description": "Given a complete undirected graph of $n$ vertices and $n$ strings $s_1, s_2, \\cdots, s_n$, the weight of edge connecting vertices $i$ and $j$ is equal to the length of the longest common substring (LCS) between $s_i$ and $s_j$. Compute the maximum total weight of any spanning tree on this graph.\n\nA substring of a string can be obtained by removing some (possibly zero) characters from the beginning and/or the end of that string. For example, ``maca``, ``aca`` and ``cau`` are all substrings of ``macau``, while ``acu`` is not.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains one integer $n$ ($1 \\leq n \\leq 2 \\times 10^6$) indicating the number of vertices and strings.\n\nFor the following $n$ lines, the $i$-th line contains one string $s_i$ ($1 \\le |s_i| \\le 2 \\times 10^6$) consisting only of lowercase English letters.\n\nIt's guaranteed that the sum of lengths of all strings will not exceed $2 \\times 10^6$.", "outputFormat": "Output one line containing one integer indicating the answer.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] LCS Spanning Tree", "background": "", "description": "给定一个有 $n$ 个顶点的完全无向图和 $n$ 个字符串 $s_1, s_2, \\cdots, s_n$，连接顶点 $i$ 和 $j$ 的边的权重等于字符串 $s_i$ 和 $s_j$ 的最长公共子串（LCS）的长度。计算此图上任意生成树的最大总权重。\n\n一个字符串的子串可以通过从该字符串的开头和/或结尾删除一些（可能为零）字符来获得。例如，“maca”、“aca” 和“cau”都是“macau”的子串，而“acu”不是。", "inputFormat": "每个测试文件中包含一个测试用例。\n\n输入的第一行包含一个整数 $n$ ($1 \\leq n \\leq 2 \\times 10^6$)，表示顶点和字符串的数量。\n\n接下来的 $n$ 行，第 $i$ 行包含一个字符串 $s_i$ ($1 \\le |s_i| \\le 2 \\times 10^6$)，由小写英文字母组成。\n\n保证所有字符串的长度之和不超过 $2 \\times 10^6$。", "outputFormat": "输出一行，包含一个整数，表示答案。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9665", "type": "P", "difficulty": 6, "samples": [["2\n1 1\n0 1 1 1\n5 1\n0 1 1 1\n0 1 2 1\n0 3 3 1\n1 4 1\n1 3 1", "0\n0\n2\n3\n2\n0"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "2021", "O2优化", "树论", "ICPC", "澳门"], "title": "[ICPC 2021 Macao R] Colorful Tree", "background": "", "description": "Your task is to maintain a colorful tree and process queries.\n\nAt the beginning, there is only one vertex numbered $1$ with color $C$ on the tree. Then there are $q$ operations of two types coming in order:\n- $0$ $x$ $c$ $d$: Add a new vertex indexed $(n+1)$ with color $c$ to the tree, where $n$ is the current number of existing vertices. An edge connecting vertex $x$ and $(n+1)$ with length $d$ will also be added to the tree.\n- $1$ $x$ $c$: Change the color of vertex $x$ to $c$.\n\nAfter each operation, you should find a pair of vertices $u$ and $v$ ($1 \\le u, v \\le n$) with $\\textbf{different}$ colors in the current tree so that the distance between $u$ and $v$ is as large as possible.\n\nThe distance between two vertices $u$ and $v$ is the length of the shortest path from $u$ to $v$ on the tree.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line of the input contains two integers $q$ and $C$ ($1 \\le q \\le 5 \\times 10^5$, $1 \\le C \\le q$) indicating the number of operations and the initial color of vertex $1$.\n\nFor the following $q$ lines, each line describes an operation taking place in order with $3$ or $4$ integers.\n- If the $i$-th line contains $4$ integers $0$, $x_i$, $c_i$ and $d_i$ ($1 \\le x_i \\le n$, $1 \\le c_i \\le q$, $1 \\le d \\le 10^9$), the $i$-th operation will add a new vertex $(n + 1)$ with color $c_i$ to the tree and connect it to vertex $x_i$ with an edge of length $d_i$.\n- If the $i$-th line contains $3$ integers $1$, $x_i$ and $c_i$ ($1 \\le x_i \\le n$, $1 \\le c_i \\le q$), the $i$-th operation will change the color of vertex $x_i$ to $c_i$.\n\nIt's guaranteed that the sum of $q$ of all test cases will not exceed $5 \\times 10^5$.", "outputFormat": "For each operation output the maximum distance between two vertices with different colors. If no valid pair exists output $0$ instead.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] Colorful Tree", "background": "", "description": "Your task is to maintain a colorful tree and process queries.\n\nAt the beginning, there is only one vertex numbered $1$ with color $C$ on the tree. Then there are $q$ operations of two types coming in order:\n- $0$ $x$ $c$ $d$: Add a new vertex indexed $(n+1)$ with color $c$ to the tree, where $n$ is the current number of existing vertices. An edge connecting vertex $x$ and $(n+1)$ with length $d$ will also be added to the tree.\n- $1$ $x$ $c$: Change the color of vertex $x$ to $c$.\n\nAfter each operation, you should find a pair of vertices $u$ and $v$ ($1 \\le u, v \\le n$) with $\\textbf{different}$ colors in the current tree so that the distance between $u$ and $v$ is as large as possible.\n\nThe distance between two vertices $u$ and $v$ is the length of the shortest path from $u$ to $v$ on the tree.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line of the input contains two integers $q$ and $C$ ($1 \\le q \\le 5 \\times 10^5$, $1 \\le C \\le q$) indicating the number of operations and the initial color of vertex $1$.\n\nFor the following $q$ lines, each line describes an operation taking place in order with $3$ or $4$ integers.\n- If the $i$-th line contains $4$ integers $0$, $x_i$, $c_i$ and $d_i$ ($1 \\le x_i \\le n$, $1 \\le c_i \\le q$, $1 \\le d \\le 10^9$), the $i$-th operation will add a new vertex $(n + 1)$ with color $c_i$ to the tree and connect it to vertex $x_i$ with an edge of length $d_i$.\n- If the $i$-th line contains $3$ integers $1$, $x_i$ and $c_i$ ($1 \\le x_i \\le n$, $1 \\le c_i \\le q$), the $i$-th operation will change the color of vertex $x_i$ to $c_i$.\n\nIt's guaranteed that the sum of $q$ of all test cases will not exceed $5 \\times 10^5$.", "outputFormat": "For each operation output the maximum distance between two vertices with different colors. If no valid pair exists output $0$ instead.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] Colorful Tree", "background": null, "description": "你的任务是维护一棵有色树并处理查询。\n\n一开始，树上只有一个编号为 $1$ 的顶点，颜色为 $C$。然后按顺序进行 $q$ 个操作，有两种类型：\n- $0$ $x$ $c$ $d$：向树中添加一个颜色为 $c$ 的新顶点，其编号为 $(n+1)$，其中 $n$ 是当前存在的顶点数。同时，添加一条连接顶点 $x$ 和 $(n+1)$ 的长度为 $d$ 的边。\n- $1$ $x$ $c$：将顶点 $x$ 的颜色更改为 $c$。\n\n在每次操作之后，你应该找到当前树中颜色 $\\textbf{不同}$ 的两个顶点 $u$ 和 $v$（$1 \\le u, v \\le n$），使得它们之间的距离尽可能大。\n\n两个顶点 $u$ 和 $v$ 之间的距离是树上从 $u$ 到 $v$ 的最短路径的长度。", "inputFormat": "存在多个测试用例。输入的第一行包含一个整数 $T$ ，表示测试用例的数量。对于每个测试用例：\n\n输入的第一行包含两个整数 $q$ 和 $C$（$1 \\le q \\le 5 \\times 10^5$，$1 \\le C \\le q$），表示操作的数量和顶点 $1$ 的初始颜色。\n\n接下来的 $q$ 行中，每行描述一个按顺序进行的操作，包含 $3$ 或 $4$ 个整数。\n- 如果第 $i$ 行包含 $4$ 个整数 $0$、$x_i$、$c_i$ 和 $d_i$（$1 \\le x_i \\le n$，$1 \\le c_i \\le q$，$1 \\le d \\le 10^9$），则第 $i$ 个操作将向树中添加一个颜色为 $c_i$ 的新顶点 $(n + 1)$，并将其与顶点 $x_i$ 连接，边的长度为 $d_i$。\n- 如果第 $i$ 行包含 $3$ 个整数 $1$、$x_i$ 和 $c_i$（$1 \\le x_i \\le n$，$1 \\le c_i \\le q$），则第 $i$ 个操作将顶点 $x_i$ 的颜色更改为 $c_i$。\n\n保证所有测试用例中 $q$ 的总和不超过 $5 \\times 10^5$。", "outputFormat": "对于每个操作，输出两个不同颜色顶点之间的最大距离。如果不存在有效的顶点对，则输出 $0$。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": null, "locale": "zh-CN"}}}
{"pid": "P9666", "type": "P", "difficulty": 3, "samples": [["2\n6 8\n1 2\n2 3\n5 6\n3 4\n2 5\n5 4\n5 1\n4 2\n4 2\n1 2\n4 3", "2 4 5 6\n-1"]], "limits": {"time": [2000, 2000, 2000], "memory": [262144, 262144, 262144]}, "tags": ["2021", "O2优化", "生成树", "ICPC", "澳门"], "title": "[ICPC 2021 Macao R] Link-Cut Tree", "background": "", "description": "BaoBao just learned how to use a data structure called link-cut tree to find cycles in a graph and decided to give it a try. BaoBao is given an undirected graph with $n$ vertices and $m$ edges, where the length of the $i$-th edge equals $2^i$. She needs to find a simple cycle with the smallest length.\n\nA simple cycle is a subgraph of the original graph containing $k$ ($3 \\le k \\le n$) vertices $a_1, a_2, \\cdots, a_k$ and $k$ edges such that for all $1 \\le i \\le k$ there is an edge connecting vertices $a_i$ and $a_{(i \\mod k) + 1}$ in the subgraph. The length of a simple cycle is the total length of the edges in the cycle.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($3 \\le n \\le 10^5$, $1 \\le m \\le 10^5$) indicating the number of vertices and edges in the original graph.\n\nFor the following $m$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$) indicating an edge connecting vertices $u_i$ and $v_i$ with length $2^i$. There are no self loops nor multiple edges. Note that the graph is not necessarily connected.\n\nIt's guaranteed that neither the sum of $n$ nor the sum of $m$ of all test cases will exceed $10^6$.", "outputFormat": "For each test case output one line. If there are no simple cycles in the graph output ``-1`` (without quotes); Otherwise output $k$ integers separated by a space in increasing order indicating the indices of the edges in the simple cycle with the smallest length. It can be shown that there is at most one answer.\n\nPlease, DO NOT output extra spaces at the end of each line, or your solution may be considered incorrect!", "hint": "The first sample test case is shown below. The integers beside the edges are their indices (outside the parentheses) and lengths (inside the parentheses). The simple cycle with the smallest length consists of edges $2$, $4$, $5$ and $6$ with a length of $2^2 + 2^4 + 2^5 + 2^6 = 116$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] Link-Cut Tree", "background": "", "description": "BaoBao just learned how to use a data structure called link-cut tree to find cycles in a graph and decided to give it a try. BaoBao is given an undirected graph with $n$ vertices and $m$ edges, where the length of the $i$-th edge equals $2^i$. She needs to find a simple cycle with the smallest length.\n\nA simple cycle is a subgraph of the original graph containing $k$ ($3 \\le k \\le n$) vertices $a_1, a_2, \\cdots, a_k$ and $k$ edges such that for all $1 \\le i \\le k$ there is an edge connecting vertices $a_i$ and $a_{(i \\mod k) + 1}$ in the subgraph. The length of a simple cycle is the total length of the edges in the cycle.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($3 \\le n \\le 10^5$, $1 \\le m \\le 10^5$) indicating the number of vertices and edges in the original graph.\n\nFor the following $m$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$) indicating an edge connecting vertices $u_i$ and $v_i$ with length $2^i$. There are no self loops nor multiple edges. Note that the graph is not necessarily connected.\n\nIt's guaranteed that neither the sum of $n$ nor the sum of $m$ of all test cases will exceed $10^6$.", "outputFormat": "For each test case output one line. If there are no simple cycles in the graph output ``-1`` (without quotes); Otherwise output $k$ integers separated by a space in increasing order indicating the indices of the edges in the simple cycle with the smallest length. It can be shown that there is at most one answer.\n\nPlease, DO NOT output extra spaces at the end of each line, or your solution may be considered incorrect!", "hint": "The first sample test case is shown below. The integers beside the edges are their indices (outside the parentheses) and lengths (inside the parentheses). The simple cycle with the smallest length consists of edges $2$, $4$, $5$ and $6$ with a length of $2^2 + 2^4 + 2^5 + 2^6 = 116$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] Link-Cut Tree", "background": "", "description": "宝宝刚刚学会使用一种称为“链接切割树”的数据结构来寻找图中的环，并决定尝试一下。宝宝得到一个有 $n$ 个顶点和 $m$ 条边的无向图，其中第 $i$ 条边的长度为 $2^i$。她需要找到一个长度最小的简单环。\n\n一个简单环是原始图的一个子图，包含 $k$ ($3 \\le k \\le n$) 个顶点 $a_1, a_2, \\cdots, a_k$ 和 $k$ 条边，使得对于所有 $1 \\le i \\le k$，在子图中存在一条边连接顶点 $a_i$ 和 $a_{(i \\mod k) + 1}$。简单环的长度是环中边的总长度。", "inputFormat": "输入包含多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含两个整数 $n$ 和 $m$ ($3 \\le n \\le 10^5$, $1 \\le m \\le 10^5$)，表示原始图中的顶点数和边数。\n\n接下来的 $m$ 行中，第 $i$ 行包含两个整数 $u_i$ 和 $v_i$ ($1 \\le u_i, v_i \\le n$)，表示连接顶点 $u_i$ 和 $v_i$ 的一条边，其长度为 $2^i$。没有自环或重边。注意，图不一定是连通的。\n\n保证所有测试用例中 $n$ 的总和和 $m$ 的总和都不会超过 $10^6$。", "outputFormat": "对于每个测试用例输出一行。如果图中没有简单环，则输出“-1”（不带引号）；否则输出 $k$ 个以空格分隔的整数，按升序表示简单环中最小长度的边的索引。可以证明最多只有一个答案。\n\n请不要在每行末尾输出多余的空格，否则您的解答可能会被视为不正确！", "hint": "第一个样例测试用例如下。边旁边的整数是它们的索引（括号外）和长度（括号内）。长度最小的简单环由边 $2$、$4$、$5$ 和 $6$ 组成，其长度为 $2^2 + 2^4 + 2^5 + 2^6 = 116$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9667", "type": "P", "difficulty": 4, "samples": [["3\n2 0\n2 6\n5 0\n1 2 3 4 5\n5 3\n1 2 3 4 5", "2\n4\n1"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "枚举", "ICPC", "济南"], "title": "[ICPC 2022 Jinan R] Tower", "background": "", "description": "Prof. Pang built $n$ block towers with different heights. The $i$-th tower has height $a_i$.\n\nProf. Shou doesn't like these towers because of their arbitrary heights. He decides to $\\textbf{first remove exactly \\textit{m} of them}$, and then perform some (or none) of the following operations: \n\n- Choose a tower and increase its height $a_i$ by $1$. \n- Choose a tower and decrease its height $a_i$ by $1$.\n- Choose a tower and divide its height $a_i$ by $2$. If the new height is not an integer, it is rounded down. \n\nProf. Shou can never choose a removed tower. If after an operation, the height of a tower will become $0$, that operation is not allowed. Under these constraints, Prof. Shou can perform an arbitrary number of operations in arbitrary order. \n\nProf. Shou would like all the towers that are not removed to have the same heights. Please calculate the minimum number of operations to achieve this.", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10)$, the number of test cases.\n\nFor each test case, the first line contains two integers $n, m~(1\\le n\\le 500, 0\\le m <n)$, the number of towers, and the number of towers Prof. Shou should delete before performing the operations.\n\nThe next line contains $n$ integers $a_1,\\ldots, a_n~(1\\le a_i\\le 10^9)$, the initial heights of the towers.", "outputFormat": "For each test case, output the minimum number of operations in one line.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Tower", "background": "", "description": "Prof. Pang built $n$ block towers with different heights. The $i$-th tower has height $a_i$.\n\nProf. Shou doesn't like these towers because of their arbitrary heights. He decides to $\\textbf{first remove exactly \\textit{m} of them}$, and then perform some (or none) of the following operations: \n\n- Choose a tower and increase its height $a_i$ by $1$. \n- Choose a tower and decrease its height $a_i$ by $1$.\n- Choose a tower and divide its height $a_i$ by $2$. If the new height is not an integer, it is rounded down. \n\nProf. Shou can never choose a removed tower. If after an operation, the height of a tower will become $0$, that operation is not allowed. Under these constraints, Prof. Shou can perform an arbitrary number of operations in arbitrary order. \n\nProf. Shou would like all the towers that are not removed to have the same heights. Please calculate the minimum number of operations to achieve this.", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10)$, the number of test cases.\n\nFor each test case, the first line contains two integers $n, m~(1\\le n\\le 500, 0\\le m <n)$, the number of towers, and the number of towers Prof. Shou should delete before performing the operations.\n\nThe next line contains $n$ integers $a_1,\\ldots, a_n~(1\\le a_i\\le 10^9)$, the initial heights of the towers.", "outputFormat": "For each test case, output the minimum number of operations in one line.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Tower", "background": "", "description": "庞教授搭了 $n$ 座不同高度的塔。第 $i$ 座塔的高度是 $a _ {i}$。\n\n寿教授不喜欢这些参差不齐的塔。他决定**先去掉它们中的 $m$ 座**，然后执行以下操作中的一些（或不执行）：\n- 选择一座塔并增加它 $1$ 个单位高度。\n- 选择一座塔并减少它 $1$ 个单位高度。\n- 选择一座塔并把它的高度 $a _ {i}$ 除以 $2$，如果它不是整数的话，向下取整。\n\n寿教授永远不会选择被拆除的塔。如果操作后，塔的高度变为 $0$，则不允许操作。在这些约束条件下，寿教授可以按任意顺序执行任意数量的运算。\n\n寿教授希望所有没有被拆除的塔都有相同的高度 $a _ {i}$。请计算实现此目标的最小操作次数。", "inputFormat": "第一行是一个整数 $T(1\\leqslant$ $T$ $\\leqslant$ $10)$,表示有 $T$ 组数据。\n\n对于每组测试数据，第一行包括两个整数 $n,m (1\\leqslant$ $n$ $\\leqslant$ $500$,$0$ $\\leqslant$ $m$ $\\leqslant n$)，表示塔的数量以及寿教授在执行操作之前应该删除的塔的数量。\n\n下一行包括 $n$ 个整数 $a _ {1},\\dots,a _ {n} (1\\leqslant$ $a _ {i}$ $\\leqslant$ $10^9)$，表示塔的最初高度。", "outputFormat": "对于每组测试数据，在一行中输出最小操作数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9668", "type": "P", "difficulty": 6, "samples": [["3\n2 3 2 4 2\n7\n8\n1 1 1 1 2\n3\n4\n9 7 10 3 5\n5\n10\n20\n30\n50", "3\n4\n2\n2\n5\n9\n13\n18\n28"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "ICPC", "济南"], "title": "[ICPC 2022 Jinan R] Torch", "background": "", "description": "Prof. Pang and Prof. Shou go to explore a cave together. Prof. Pang walks ahead of Prof. Shou. \n\nEach of them has a torch for illumination. The torches need fuel to burn. Prof. Pang's torch can burn for $a_1$ seconds once it has been refilled, and it takes $b_1$ seconds to refuel the torch after it burns out. Prof. Shou's torch can burn for $a_2$ seconds once it has been refilled, and it takes $b_2$ seconds to refuel the torch after it burns out. The person who is refueling the torch cannot walk simultaneously. For safety reasons, they cannot refuel the torch until the fuel runs out. \n\nBecause Prof. Pang is too fat and the cave is too narrow, Prof. Shou cannot surpass Prof. Pang during the exploration, which means that Prof. Shou is at least 1 unit behind Prof. Pang. \n\nEach of them can walk forward a distance of 1 unit per second when his torch is burning. Every second, Prof. Pang moves first, then Prof. Shou does. In order to get to their destination earlier, they will move as long as they can walk forward. \n\nNow Prof. Shou has $n$ questions, and for the $i$-th question, he wants to know that at time $q_i$, how many units of the distance he has moved forward from the starting point? Prof. Shou starts 1 unit behind Prof. Pang. The initial time is 0. Both Prof. Pang and Prof. Shou refueled the torch before the initial time.", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10^5)$, the number of test cases.\n\nFor each test case, the first line contains 5 integers $a_1, b_1, a_2, b_2, n~(1 \\le a_1, b_1, a_2, b_2, n \\le 10^6)$ denoting the time Prof. Pang's torch can burn, the time for Prof. Pang to refuel his torch, the time Prof. Shou's torch can burn, the time for Prof. Shou to refuel his torch, and the number of Prof. Shou's queries. Each of the next $n$ lines describes a query. Query $i$ is denoted by one integer $q_i~(1 \\le q_i \\le 10^{16})$.\n\nIt is guaranteed that over all test cases, each of the following numbers is no more than $10^6$:\n\n- the sum of $a_1$, \n- the sum of $a_2$, \n- the sum of $b_1$, \n- the sum of $b_2$, \n- and the sum of $n$.", "outputFormat": "For each query, print one line containing the answer -- the number of units that Prof. Shou has walked forward from the starting point.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Torch", "background": "", "description": "Prof. Pang and Prof. Shou go to explore a cave together. Prof. Pang walks ahead of Prof. Shou. \n\nEach of them has a torch for illumination. The torches need fuel to burn. Prof. Pang's torch can burn for $a_1$ seconds once it has been refilled, and it takes $b_1$ seconds to refuel the torch after it burns out. Prof. Shou's torch can burn for $a_2$ seconds once it has been refilled, and it takes $b_2$ seconds to refuel the torch after it burns out. The person who is refueling the torch cannot walk simultaneously. For safety reasons, they cannot refuel the torch until the fuel runs out. \n\nBecause Prof. Pang is too fat and the cave is too narrow, Prof. Shou cannot surpass Prof. Pang during the exploration, which means that Prof. Shou is at least 1 unit behind Prof. Pang. \n\nEach of them can walk forward a distance of 1 unit per second when his torch is burning. Every second, Prof. Pang moves first, then Prof. Shou does. In order to get to their destination earlier, they will move as long as they can walk forward. \n\nNow Prof. Shou has $n$ questions, and for the $i$-th question, he wants to know that at time $q_i$, how many units of the distance he has moved forward from the starting point? Prof. Shou starts 1 unit behind Prof. Pang. The initial time is 0. Both Prof. Pang and Prof. Shou refueled the torch before the initial time.", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10^5)$, the number of test cases.\n\nFor each test case, the first line contains 5 integers $a_1, b_1, a_2, b_2, n~(1 \\le a_1, b_1, a_2, b_2, n \\le 10^6)$ denoting the time Prof. Pang's torch can burn, the time for Prof. Pang to refuel his torch, the time Prof. Shou's torch can burn, the time for Prof. Shou to refuel his torch, and the number of Prof. Shou's queries. Each of the next $n$ lines describes a query. Query $i$ is denoted by one integer $q_i~(1 \\le q_i \\le 10^{16})$.\n\nIt is guaranteed that over all test cases, each of the following numbers is no more than $10^6$:\n\n- the sum of $a_1$, \n- the sum of $a_2$, \n- the sum of $b_1$, \n- the sum of $b_2$, \n- and the sum of $n$.", "outputFormat": "For each query, print one line containing the answer -- the number of units that Prof. Shou has walked forward from the starting point.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Torch", "background": "", "description": "胖子和瘦子在一个山洞里行走，胖子在瘦子前面。每个人都有一支火把。\n\n胖子的火把填满燃料后可以燃烧 $a_1$ 秒，在熄灭后需要花费 $b_1$ 秒填充燃料。\n\n瘦子的火把填满燃料后可以燃烧 $a_2$ 秒，在熄灭后需要花费 $b_2$ 秒填充燃料。\n\n每个人只能在自己的火把燃烧时前进，速度为 $1\\operatorname{m/s}$。\n\n因为胖子太胖，所以瘦子只能跟在胖子后面而不能超过胖子。\n\n每一秒胖子先移动，之后瘦子再移动。\n\n初始时两个人的火把都已经填满了燃料，瘦子在胖子后面 $1 \\operatorname{m}$。\n\n给定 $n$ 个询问，每次给一个正整数 $q_i$，表示查询第 $q_i$ 秒后，瘦子的移动距离。\n\n\n接下来 $n$ 行，每行一个正整数 $q_i$，表示询问。", "inputFormat": "**本题包含多组测试数据**\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据：", "outputFormat": "每组数据输出 $n$ 行，表示每个询问的答案，即第 $q_i$ 秒后瘦子的移动距离。", "hint": "下面 $\\sum n$ 表示所有数据的 $n$ 之和，$\\sum a_1, \\sum b_1, \\sum a_2, \\sum b_2$ 同理。\n\n$1 \\le T \\le 10^5$，$1 \\le a_1, b_1, a_2, b_2 \\le 10^6$，$\\sum a_1, \\sum b_1, \\sum a_2, \\sum b_2, \\sum n \\le 10^6$，$1 \\le q_i \\le 10^{16}$。", "locale": "zh-CN"}}}
{"pid": "P9669", "type": "P", "difficulty": 6, "samples": [["5\n1 2\n1 3\n3 4\n3 5", "4 0 0 0 0\n0 2 0 0 2\n0 2 2 0 0\n0 0 1 2 1\n0 0 1 2 1"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "背包 DP", "树形 DP", "ICPC", "济南"], "title": "[ICPC 2022 Jinan R] DFS Order 2", "background": "", "description": "Prof. Pang has a rooted tree that is rooted at vertex $1$ and has $n$ nodes. These $n$ nodes are numbered from $1$ to $n$.\n\nNow he wants to start the depth-first search at the root. He wonders for each node $v$, how many ways it can appear in the $j$-th position of $\\textbf{depth-first search order}$. The depth-first search order is the order of nodes visited during the depth-first search. A node appears in the $j$-th ($1\\le j\\le n$) position in this order means it is visited after $j-1$ other nodes. Because sons of a node can be iterated in arbitrary order, multiple possible depth-first orders exist. \n\nProf. Pang wants to know for each node $v$, how many different $\\textbf{depth-first search order}$s such that $v$ appears in the $j$-th position. For each $v, j~(1 \\le v, j \\le n)$, compute the answer. Because the answer can be very large, output it modulo $998244353$.\n\nFollowing is a pseudo-code for the depth-first search on a rooted tree. After calling $\\textbf{main}$(), $\\texttt{dfs\\_order}$ is the depth-first search order.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l3gjstn0.png)", "inputFormat": "The first line contains one integer $n~(1\\le n \\le 500)$, the number of vertices in the tree.\n\nEach of the next $n-1$ lines describes an edge of the tree. Edge $i$ is denoted by two integers $u_i$ and $v_i$, the labels of vertices it connects $(1\\le u_i,v_i\\le n, u_i\\neq v_i)$.\n\nIt is guaranteed that the given edges form a tree.", "outputFormat": "For each vertex $v$ from $1$ to $n$, output one line containing $n$ integers modulo $998244353$. The $j$-th integer in the $v$-th line should be the number of different depth-first search orders such that $v$ appears in the $j$-th position.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] DFS Order 2", "background": "", "description": "Prof. Pang has a rooted tree that is rooted at vertex $1$ and has $n$ nodes. These $n$ nodes are numbered from $1$ to $n$.\n\nNow he wants to start the depth-first search at the root. He wonders for each node $v$, how many ways it can appear in the $j$-th position of $\\textbf{depth-first search order}$. The depth-first search order is the order of nodes visited during the depth-first search. A node appears in the $j$-th ($1\\le j\\le n$) position in this order means it is visited after $j-1$ other nodes. Because sons of a node can be iterated in arbitrary order, multiple possible depth-first orders exist. \n\nProf. Pang wants to know for each node $v$, how many different $\\textbf{depth-first search order}$s such that $v$ appears in the $j$-th position. For each $v, j~(1 \\le v, j \\le n)$, compute the answer. Because the answer can be very large, output it modulo $998244353$.\n\nFollowing is a pseudo-code for the depth-first search on a rooted tree. After calling $\\textbf{main}$(), $\\texttt{dfs\\_order}$ is the depth-first search order.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l3gjstn0.png)", "inputFormat": "The first line contains one integer $n~(1\\le n \\le 500)$, the number of vertices in the tree.\n\nEach of the next $n-1$ lines describes an edge of the tree. Edge $i$ is denoted by two integers $u_i$ and $v_i$, the labels of vertices it connects $(1\\le u_i,v_i\\le n, u_i\\neq v_i)$.\n\nIt is guaranteed that the given edges form a tree.", "outputFormat": "For each vertex $v$ from $1$ to $n$, output one line containing $n$ integers modulo $998244353$. The $j$-th integer in the $v$-th line should be the number of different depth-first search orders such that $v$ appears in the $j$-th position.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] DFS Order 2", "background": "", "description": "P 有一棵树，根节点是 $1$ ，总共有 $n$ 个节点，从 $1$ 到 $n$ 编号。\n\n他想从根节点开始进行深度优先搜索。他想知道对于每个节点 $v$，在深度优先搜索中，它出现在第 $j$ 个位置的方式有多少种。深度优先搜索的顺序是在搜索过程中访问节点的顺序。节点出现在第 $j\\,(1 \\le j \\le n)$ 个位置表示它在访问了 $j - 1$ 个其他节点之后才被访问。因为节点的子节点可以以任意顺序访问，所以有多种可能的深度优先搜索顺序。\n\nP 想知道对于每个节点 $v$，有多少种不同的深度优先搜索顺序，使得 $v$ 出现在第 $j$ 个位置。对于每个 $v$ 和 $j\\,(i \\le v,j \\le n)$，计算答案。答案可能很大，所以输出时要取模 $998\\,244\\,353$。\n\n以下是深度优先搜索的伪代码，用于处理树。在调用 $\\textbf{main()}$ 函数后，$\\texttt{dfs\\_order}$ 将会包含深度优先搜索的顺序。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l3gjstn0.png)", "inputFormat": "第一行包含一个整数 $n\\,(1\\le n\\le 500)$，表示树中的节点数量。\n\n接下来的n-1行描述了树的边。第i行包含两个整数 $u_i$ 和 $v_i$，表示连接的两个节点的标签 $(1\\le u_i,v_i\\le n,u_i\\not=v_i)$。\n\n保证给定的边构成一棵树。", "outputFormat": "对于每个从 $1$ 到 $n$ 的节点 $v$，输出一行，包含 $n$ 个整数，取模 $998\\,244\\,353$。在第 $v$ 行中，第 $j$ 个整数表示不同的深度优先搜索顺序中，节点 $v$ 出现在第 $j$ 个位置的数量。\n\n翻译由 @ayf2192538031 提供。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9670", "type": "P", "difficulty": 4, "samples": [["1 13\n7 951\n+ 1/6\n? 3 4\n+ 4/183\n- 2\n+ 3/217\n.\n.\n.\n+ 2/29\n+ 1/91\n.\n+ 1/22\n.", "Yes\n+ 1/6\n+ 2/263\n+ 4/183\n- 2\n+ 3/217\n.\n.\n.\n+ 2/29\n+ 1/91\n.\n+ 1/22\n."], ["6 2\n1 100\n.\n? 3 4\n2 100\n+ 1/1\n+ 1/2\n0 0\n- 5\n- 6\n2 480\n? 100 100\n? 100 100\n2 480\n? 99 100\n? 100 100\n1 2000\n? 100 100\n? 100 100", "No\nNo\nYes\n- 5\n- 6\nYes\n+ 1/240\n+ 1/240\nNo\nYes\n+ 87/280\n- 100"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "Special Judge", "O2优化", "ICPC", "济南"], "title": "[ICPC 2022 Jinan R] Frozen Scoreboard", "background": "", "description": "There was an ICPC contest two thousand years ago in the Qin dynasty. There were $m$ problems and $n$ teams in the contest. We only know how many problems each team solved and how much total time they used from the historical records. These are called the $\\textbf{final result}$s of the teams. We don't know which problems they solved or their submission times.\n\nRecently, we seem to had a discovery. We found the $\\textbf{frozen scoreboard}$ of the teams. From the frozen scoreboard of a team, we know their submissions during the whole contest, but we don't know the verdicts of the submissions in the last hour. And some people found that for some teams, their frozen scoreboards may contradict their final results in the historical records.\n\nGiven the final results and the frozen scoreboards of the teams, please construct a $\\textbf{final scoreboard}$ for each team that is consistent with both its final result and its frozen scoreboard.\n\nFrom the submissions during the contest, we can calculate the final scoreboard and the final result as follows:\n\nFor a fixed team $i$, its $\\textbf{final scoreboard}$ is an array of $m$ elements where the $j$-th element shows some information about team $i$'s submissions on problem $j$. \n\n- If team $i$ didn't submit to problem $j$, the cell should be a single character ``.`` (without quotes). \n\n- If team $i$ submitted $x$ times to problem $j$ and none of the submissions was accepted, the cell should contain $-\\ x$. \n\n- Otherwise, consider all submissions from team $i$ to problem $j$. Each submission has a submission time. Suppose the earliest accepted submission is the $x$-th one. Then the cell should contain $+\\ x/y$ where $y~(0\\le y\\le 299)$ is the submission time of the $x$-th submission. $y$ is an integer representing the submission time in minutes.\n\nNote that in the final scoreboard, we don't care about submissions after the first accepted one. It is possible that two or more submissions happened in the same minute.\n\nThe $\\textbf{final result}$ of a team is computed from its $\\textbf{final scoreboard}$. For each team, we can calculate the number of problems it solved. This number is equal to the number of ``+`` in the team's final scoreboard.\n\nWe can also calculate its total time. If team $i$ solved problem $j$ in the $y$-th minute after $x-1$ unaccepted submissions (in other words, the $j$-th cell of its final scoreboard is $+\\ x/y$), problem $j$ contributes $20(x-1)+y$ time to team $i$. If team $i$ didn't solve problem $j$, problem $j$ contributes $0$ time to team $i$, no matter team $i$ submitted to problem $j$ or not. The total time of team $i$ is the sum of contributions of each problem.\n\nThe rules for the $\\textbf{frozen scoreboard}$ will be introduced in the input section. We will distinguish submissions in the final hour and other submissions. A submission was in the final hour if its submission time is between $240$ and $299$.", "inputFormat": "The first line contains two integers $n, m~(1\\le n\\le 1000, 1\\le m\\le 13)$, the number of teams in the contest, and the number of problems in the contest.\n\nThen there are $n$ blocks describing the $\\textbf{final result}$ and the $\\textbf{frozen scoreboard}$ of each team.\n\nThe $i$-th block represents team $i$. In the $i$-th block, the first line contains two integers $a_i, b_i~(0\\le a_i\\le m, 0\\le b_i\\le 10^5)$, the number of problems team $i$ solved $\\textbf{during the whole contest}$ and the total time of team $i$ for solving the $a_i$ problems. These two numbers represent the final result of the contest. The next $m$ lines describe the status of team $i$ in the frozen scoreboard. For each $1\\le j\\le m$, \n\n- If the $j$-th line is $+\\ x/y$ $(1\\le x\\le 100, 0\\le y\\le 239)$, team $i$ solved problem $j$ at time $y$ and the accepted solution is their $x$-th submission on problem $j$.\n- If the $j$-th line is $?\\ x\\ y$ $(1\\leq x \\leq y \\leq 100)$, team $i$ didn't solve the problem $j$ in the first four hours. Team $i$ submitted problem $j$ for $y$ times in which $x$ submissions are in the last hour. Note that submissions made in the last hour after the accepted one will count in the $\\textbf{frozen scoreboard}$, but not in the $\\textbf{final scoreboard}$.\n- If the $j$-th line is $-\\ x$, team $i$ didn't solve the problem $j$ in the first four hours. Team $i$ submitted problem $j$ for $x~(1\\le x\\le 100)$ times before the last hour and did not submit problem $j$ in the last hour.\n- If the $j$-th line is a single character ``.`` (without quotes), team $i$ didn't submit problem $j$ at all.", "outputFormat": "For each team $i$, if its final result contradicts its frozen scoreboard, output $\\texttt{No}$ in one line. Otherwise, output $\\texttt{Yes}$ in the first line and then output $m$ lines, describing a final scoreboard that is consistent with both the final result and the frozen scoreboard of team $i$. The $j$-th line should contain \n\n- $+\\ x/y$ $(1\\le x \\le 100, 0\\le y \\le 299)$, if the $x$-th submission from team $i$ to problem $j$ is accepted and is in the $y$-th minute of the contest. All submissions from team $i$ to team $j$ before the $x$-th one was not accepted. Please don't output extra spaces before and after slash ``/``. \n- $-\\ x$ $(1\\le x\\le 100)$, if team $i$ submitted to problem $j$ for $x$ times and none of the submissions was accepted.\n- $.$ if team $i$ didn't submit to problem $j$ at all. \n\nIf there are multiple solutions, output any.\n\n$\\textbf{Please note that in the input and the output, there is always a space following each ?, +, and -.}$", "hint": "Here is an example of the frozen scoreboard in the first sample.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jw4c3965.png)", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Frozen Scoreboard", "background": "", "description": "There was an ICPC contest two thousand years ago in the Qin dynasty. There were $m$ problems and $n$ teams in the contest. We only know how many problems each team solved and how much total time they used from the historical records. These are called the $\\textbf{final result}$s of the teams. We don't know which problems they solved or their submission times.\n\nRecently, we seem to had a discovery. We found the $\\textbf{frozen scoreboard}$ of the teams. From the frozen scoreboard of a team, we know their submissions during the whole contest, but we don't know the verdicts of the submissions in the last hour. And some people found that for some teams, their frozen scoreboards may contradict their final results in the historical records.\n\nGiven the final results and the frozen scoreboards of the teams, please construct a $\\textbf{final scoreboard}$ for each team that is consistent with both its final result and its frozen scoreboard.\n\nFrom the submissions during the contest, we can calculate the final scoreboard and the final result as follows:\n\nFor a fixed team $i$, its $\\textbf{final scoreboard}$ is an array of $m$ elements where the $j$-th element shows some information about team $i$'s submissions on problem $j$. \n\n- If team $i$ didn't submit to problem $j$, the cell should be a single character ``.`` (without quotes). \n\n- If team $i$ submitted $x$ times to problem $j$ and none of the submissions was accepted, the cell should contain $-\\ x$. \n\n- Otherwise, consider all submissions from team $i$ to problem $j$. Each submission has a submission time. Suppose the earliest accepted submission is the $x$-th one. Then the cell should contain $+\\ x/y$ where $y~(0\\le y\\le 299)$ is the submission time of the $x$-th submission. $y$ is an integer representing the submission time in minutes.\n\nNote that in the final scoreboard, we don't care about submissions after the first accepted one. It is possible that two or more submissions happened in the same minute.\n\nThe $\\textbf{final result}$ of a team is computed from its $\\textbf{final scoreboard}$. For each team, we can calculate the number of problems it solved. This number is equal to the number of ``+`` in the team's final scoreboard.\n\nWe can also calculate its total time. If team $i$ solved problem $j$ in the $y$-th minute after $x-1$ unaccepted submissions (in other words, the $j$-th cell of its final scoreboard is $+\\ x/y$), problem $j$ contributes $20(x-1)+y$ time to team $i$. If team $i$ didn't solve problem $j$, problem $j$ contributes $0$ time to team $i$, no matter team $i$ submitted to problem $j$ or not. The total time of team $i$ is the sum of contributions of each problem.\n\nThe rules for the $\\textbf{frozen scoreboard}$ will be introduced in the input section. We will distinguish submissions in the final hour and other submissions. A submission was in the final hour if its submission time is between $240$ and $299$.", "inputFormat": "The first line contains two integers $n, m~(1\\le n\\le 1000, 1\\le m\\le 13)$, the number of teams in the contest, and the number of problems in the contest.\n\nThen there are $n$ blocks describing the $\\textbf{final result}$ and the $\\textbf{frozen scoreboard}$ of each team.\n\nThe $i$-th block represents team $i$. In the $i$-th block, the first line contains two integers $a_i, b_i~(0\\le a_i\\le m, 0\\le b_i\\le 10^5)$, the number of problems team $i$ solved $\\textbf{during the whole contest}$ and the total time of team $i$ for solving the $a_i$ problems. These two numbers represent the final result of the contest. The next $m$ lines describe the status of team $i$ in the frozen scoreboard. For each $1\\le j\\le m$, \n\n- If the $j$-th line is $+\\ x/y$ $(1\\le x\\le 100, 0\\le y\\le 239)$, team $i$ solved problem $j$ at time $y$ and the accepted solution is their $x$-th submission on problem $j$.\n- If the $j$-th line is $?\\ x\\ y$ $(1\\leq x \\leq y \\leq 100)$, team $i$ didn't solve the problem $j$ in the first four hours. Team $i$ submitted problem $j$ for $y$ times in which $x$ submissions are in the last hour. Note that submissions made in the last hour after the accepted one will count in the $\\textbf{frozen scoreboard}$, but not in the $\\textbf{final scoreboard}$.\n- If the $j$-th line is $-\\ x$, team $i$ didn't solve the problem $j$ in the first four hours. Team $i$ submitted problem $j$ for $x~(1\\le x\\le 100)$ times before the last hour and did not submit problem $j$ in the last hour.\n- If the $j$-th line is a single character ``.`` (without quotes), team $i$ didn't submit problem $j$ at all.", "outputFormat": "For each team $i$, if its final result contradicts its frozen scoreboard, output $\\texttt{No}$ in one line. Otherwise, output $\\texttt{Yes}$ in the first line and then output $m$ lines, describing a final scoreboard that is consistent with both the final result and the frozen scoreboard of team $i$. The $j$-th line should contain \n\n- $+\\ x/y$ $(1\\le x \\le 100, 0\\le y \\le 299)$, if the $x$-th submission from team $i$ to problem $j$ is accepted and is in the $y$-th minute of the contest. All submissions from team $i$ to team $j$ before the $x$-th one was not accepted. Please don't output extra spaces before and after slash ``/``. \n- $-\\ x$ $(1\\le x\\le 100)$, if team $i$ submitted to problem $j$ for $x$ times and none of the submissions was accepted.\n- $.$ if team $i$ didn't submit to problem $j$ at all. \n\nIf there are multiple solutions, output any.\n\n$\\textbf{Please note that in the input and the output, there is always a space following each ?, +, and -.}$", "hint": "Here is an example of the frozen scoreboard in the first sample.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jw4c3965.png)", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Frozen Scoreboard", "background": "", "description": "2000 年以前的秦朝，曾举办过一次 ICPC 比赛。比赛中有 $m$ 道题，$n$ 个团队。我们知道每个队完成了多少道题以及其历史记录的总用时。这些称作该团队的结果，但是我们不知道他们每道题是否完成、用时多久。\n\n最近，我们发现了每个队**冻结的计分板**。从该计分板上，我们可以看到每个队在比赛中的提交情况，但是不知道在最后一小时内提交的判分。一些人发现，对于一些队来说，他们冻结的计分板可能与他们在历史记录中的最终成绩相矛盾。\n\n请根据最终得分和冻结的计分板，为各队创建一个与其最终结果和冻结的计分板一致的最终计分板。\n\n按照以下规则来计算计分板和总分：\n\n对于给定的队伍 $i$，它**最终的计分板**是一个 $m$ 元数组，其中第 $j$ 个元素给出队伍 $i$ 在第 $j$ 题上的提交信息。\n\n- 如果队伍 $i$ 没有提交问题 $j$，输出 ```.```。\n\n- 如果队伍 $i$ 对问题 $j$ 提交了 $x$ 次但均未通过，输出 $-x$。\n\n- 否则，考虑队伍 $i$ 在问题 $j$ 的所有评测结果。每次提交都有一个提交时间，设第一个通过的评测是第 $x$ 次评测，在第 $y$ 分钟时提交。输出 $+x/y$，其中 $0\\leq y\\leq299$。\n\n在最终计分板上，只考虑第一次通过的提交。同一分钟内可能有多次提交。\n\n一个队伍的最终得分是该队伍完成了多少道题，即该队最终计分板上 ```+``` 的个数。\n\n一个队伍总用时按如下方式计算。如果队伍 $i$ 在第 $y$ 分钟完成了第 $j$ 道题，在完成前有 $x-1$ 次失败的提交（即最终计分板上第 $j$ 个问题的数为 $+x/y$），该问题的用时记为 $20(x-1)+y$。 如果队伍 $i$ 没有完成第 $j$ 道题，该问题的用时记为 $0$，无论是否提交过。队伍 $i$ 的总时间是每道题用时的总和。", "inputFormat": "第一行包括两个整数 $n,m\\;(1\\leq n\\leq1000,1\\leq m\\leq13)$，为队伍个数和题目个数。\n\n接下来 $n$ 组，描述每个队伍的最终得分和冻结的计分板。\n\n第 $i$ 组表示队伍 $i$。每一组中，第一行包括两个整数 $a_i,b_i\\;(0\\leq a_i\\leq m,0\\leq b_i\\leq10^5)$，为队伍 $i$ 在**整场比赛中**完成的题目个数和每道题的用时。这两个数字是比赛的最终结果。\n\n接下来 $m$ 行，描述队伍 $i$ 在计分板上的内容。对于任意 $1\\leq j\\leq m$，\n\n- 如果第 $j$ 行是 $+\\,x/y\\;(1\\leq x\\leq100,0\\leq y\\leq239)$，表示队伍 $i$ 在第 $y$ 分钟，第 $x$ 次提交时通过了题 $j$。\n\n- 如果第 $j$ 行是 $?\\,x\\,y\\;(1\\leq x\\leq y\\leq100)$，表示队伍 $i$ 没有在前四个小时中作出题 $j$。这个队伍提交了 $y$ 次，其中 $x$ 次在最后一小时内。最后一小时内且通过该题的提交记录会在**冻结的计分板**上显示，但不会在**最终计分板**上显示。\n\n- 如果第 $j$ 行是 $-x$，表示队伍 $i$ 没有在前四小时内作出题 $j$。这个队伍在最后一个小时前提交了 $x\\,(1\\leq x\\leq100)$ 次，且没有在最后一小时内做出题 $j$。\n\n- 如果第 $j$ 行是一个单一的字符 ```.```，表示队伍 $i$ 没有提交过题 $j$。", "outputFormat": "对于每个队伍 $i$，如果最终结果和冻结的计分板相矛盾，输出一行 $\\texttt{No}$。否则，第一行输出 $\\texttt{Yes}$，接下来 $m$ 行，描述一种队伍 $i$ 可能的计分板，满足最终结果和冻结的计分板。其中，第 $j$ 行应该包括：\n\n- $+\\,x/y\\,(1\\leq x\\leq100,0\\leq y\\leq299)$，如果队伍 $i$ 在第 $x$ 次提交，第 $y$ 分钟完成了题 $j$，在这之前没有队伍通过这道题。不要在字符 ```/``` 前后输出多余的空格。\n\n- $-x\\,(1\\leq x\\leq100)$，如果队伍 $i$ 提交了 $x$ 次题 $j$，且均未通过。\n\n- ```.```，如果队伍 $i$ 没有提交题 $j$。\n\n如果有多种可能的答案，任意输出一种即可。\n\n**请注意，在输入和输出中，```?,+,-``` 后总有一个空格。**", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9671", "type": "P", "difficulty": 3, "samples": [["3\n3 1\n4 2\n5 3", "No\nYes\nYes"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "Special Judge", "O2优化", "ICPC", "济南"], "title": "[ICPC 2022 Jinan R] Identical Parity", "background": "", "description": "Let the value of a sequence be the sum of all numbers in it.\n\nDetermine whether there exists a permutation of length $n$ such that the values of all subsegments of length $k$ of the permutation share the same parity. The values share the same parity means that they are all odd numbers or they are all even numbers.\n\nA subsegment of a permutation is a contiguous subsequence of that permutation. A permutation of length $n$ is a sequence in which each integer from $1$ to $n$ appears exactly once.", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10^5)$, the number of test cases.\n\nFor each test case, the only line contains two integers $n,k~(1 \\le k \\le n \\le 10^9)$.", "outputFormat": "For each test case, output $\\texttt{Yes}$ (without quotes) if there exists a valid permutation, or $\\texttt{No}$ (without quotes) otherwise.\n\nYou can output $\\texttt{Yes}$ and $\\texttt{No}$ in any case (for example, strings $\\texttt{YES}$, $\\texttt{yEs}$ and $\\texttt{yes}$ will be recognized as positive responses).", "hint": "In the first test case, it can be shown that there does not exist any valid permutation.\n\nIn the second test case, $[1,2,3,4]$ is one of the valid permutations. Its subsegments of length $2$ are $[1,2],[2,3],[3,4]$. Their values are $3,5,7$, respectively. They share the same parity.\n\nIn the third test case, $[1,2,3,5,4]$ is one of the valid permutations. Its subsegments of length $3$ are $[1,2,3],[2,3,5],[3,5,4]$. Their values are $6,10,12$, respectively. They share the same parity.", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Identical Parity", "background": "", "description": "Let the value of a sequence be the sum of all numbers in it.\n\nDetermine whether there exists a permutation of length $n$ such that the values of all subsegments of length $k$ of the permutation share the same parity. The values share the same parity means that they are all odd numbers or they are all even numbers.\n\nA subsegment of a permutation is a contiguous subsequence of that permutation. A permutation of length $n$ is a sequence in which each integer from $1$ to $n$ appears exactly once.", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10^5)$, the number of test cases.\n\nFor each test case, the only line contains two integers $n,k~(1 \\le k \\le n \\le 10^9)$.", "outputFormat": "For each test case, output $\\texttt{Yes}$ (without quotes) if there exists a valid permutation, or $\\texttt{No}$ (without quotes) otherwise.\n\nYou can output $\\texttt{Yes}$ and $\\texttt{No}$ in any case (for example, strings $\\texttt{YES}$, $\\texttt{yEs}$ and $\\texttt{yes}$ will be recognized as positive responses).", "hint": "In the first test case, it can be shown that there does not exist any valid permutation.\n\nIn the second test case, $[1,2,3,4]$ is one of the valid permutations. Its subsegments of length $2$ are $[1,2],[2,3],[3,4]$. Their values are $3,5,7$, respectively. They share the same parity.\n\nIn the third test case, $[1,2,3,5,4]$ is one of the valid permutations. Its subsegments of length $3$ are $[1,2,3],[2,3,5],[3,5,4]$. Their values are $6,10,12$, respectively. They share the same parity.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Identical Parity", "background": null, "description": "定义一个序列的 **权值** 等于这个序列所有的元素之和。\n\n试判断：是否存在一个长度为 $n$ 的 **排列**，满足以下约束条件？\n\n- 其所有长度为 $k$ 的 **子区间** 的权值具有相同的奇偶性。", "inputFormat": "第一行一个整数 $T$ $(1\\leqslant T\\leqslant 10^5)$，表示测试数据组数。\n\n每组测试数据共一行，包含两个整数 $n,k$ $(1 \\le k \\le  n \\le 10^9)$。", "outputFormat": "对于每组测试数据，输出一行一个字符串。若存在符合题意的排列，输出 $\\texttt{Yes}$；否则，输出 $\\texttt{No}$。\n\n你可以以任意的大小写输出 $\\texttt{Yes}$ 和 $\\texttt{No}$（例如，$\\texttt{YES}$，$\\texttt{yEs}$ 和 $\\texttt{yes}$ 都会被视作合法的输出）。\n\n### 样例解释\n\n对于第一组测试数据，能够证明不存在任何符合题意的排列。\n\n对于第二组测试数据，$[1,2,3,4]$ 是一个符合题意的排列。其所有长度为 $2$ 的子区间分别为 $[1,2],[2,3],[3,4]$，它们的权值分别为 $3,5,7$，具有相同的奇偶性。\n\n对于第三组测试数据，$[1,2,3,5,4]$ 是一个符合题意的排列。其所有长度为 $3$ 的子区间分别为 $[1,2,3],[2,3,5],[3,5,4]$，它们的权值分别为 $6,10,12$，具有相同的奇偶性。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P9672", "type": "P", "difficulty": 7, "samples": [["4\n3 3\n1 1\n3 1\n3 3\n4 500000000000000000\n1 1\n1000000000 1\n1000000000 1000000000\n1 1000000000\n9 22\n9 6\n6 7\n9 7\n10 10\n6 9\n3 9\n1 6\n1 5\n7 3\n5 22447972861454999\n270353376 593874603\n230208698 598303091\n237630296 255016434\n782669452 568066304\n654623868 958264153", "3 2\n500000000 500000000\n7 8\n730715389 644702744"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "ICPC", "类欧几里得算法", "济南"], "title": "[ICPC 2022 Jinan R] Grid Points", "background": null, "description": "You are given a simple polygon in the first quadrant of the Cartesian plane. This means that the coordinate $(x,y)$ of any point in the polygon satisfies $x> 0$ and $y> 0$. \n\nConsider all grid points in the polygon. Order them in increasing order of $\\textbf{slopes}$. Output the $k$-th grid point in this order. \n\nA grid point is a point $(x, y)$ such that $x$ and $y$ are integers. A point on the boundary of a polygon is considered to be in the polygon. The slope of point $(x, y)$ is $y/x$. If two points have the same slope, they are ordered lexicographically first by $x$, then by $y$. In other words, a point $(x_1, y_1)$ is lexicographically less than $(x_2, y_2)$ if $(x_1<x_2)\\vee (x_1=x_2 \\wedge y_1<y_2)$.", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 500)$, the number of test cases.\n\nFor each test case, the first line contains two integers $n, k~(n\\ge 3, 1\\le k)$. Each of the next $n$ lines describes a vertex of the polygon. Each vertex is denoted by two integers $x, y~(1\\le x, y\\le 10^9)$, representing its coordinate $(x, y)$. The vertices are given in counterclockwise order.\n\nIt is guaranteed that the polygon is simple, i.e.~ the vertices are distinct, two edges may overlap only when they are consecutive on the boundary, and the overlap contains exactly $1$ point. It is guaranteed that $k$ is no more than the number of grid points in the polygon.\n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $2000$.", "outputFormat": "For each test case, output two integers $x, y$ in one line representing the coordinate $(x, y)$ of the $k$-th grid point.", "hint": null, "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Grid Points", "background": null, "description": "You are given a simple polygon in the first quadrant of the Cartesian plane. This means that the coordinate $(x,y)$ of any point in the polygon satisfies $x> 0$ and $y> 0$. \n\nConsider all grid points in the polygon. Order them in increasing order of $\\textbf{slopes}$. Output the $k$-th grid point in this order. \n\nA grid point is a point $(x, y)$ such that $x$ and $y$ are integers. A point on the boundary of a polygon is considered to be in the polygon. The slope of point $(x, y)$ is $y/x$. If two points have the same slope, they are ordered lexicographically first by $x$, then by $y$. In other words, a point $(x_1, y_1)$ is lexicographically less than $(x_2, y_2)$ if $(x_1<x_2)\\vee (x_1=x_2 \\wedge y_1<y_2)$.", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 500)$, the number of test cases.\n\nFor each test case, the first line contains two integers $n, k~(n\\ge 3, 1\\le k)$. Each of the next $n$ lines describes a vertex of the polygon. Each vertex is denoted by two integers $x, y~(1\\le x, y\\le 10^9)$, representing its coordinate $(x, y)$. The vertices are given in counterclockwise order.\n\nIt is guaranteed that the polygon is simple, i.e.~ the vertices are distinct, two edges may overlap only when they are consecutive on the boundary, and the overlap contains exactly $1$ point. It is guaranteed that $k$ is no more than the number of grid points in the polygon.\n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $2000$.", "outputFormat": "For each test case, output two integers $x, y$ in one line representing the coordinate $(x, y)$ of the $k$-th grid point.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Grid Points", "background": "", "description": "给你一个在笛卡尔平面第一象限中的多边形。这意味着多边形中任何顶点的坐标 $(x, y)$ 都满足 $x>0$ 和 $y>0$。\n\n考虑多边形中的所有网格点。将它们按**斜率**从小到大排序。输出排序之后的第 $k$ 个网格点。\n\n如果 $x,y\\in \\Z$，那么 $(x,y)$ 就是一个网格点。多边形边界上的一个点也被认为在多边形中。点 $(x,y)$ 的斜率为 $y/x$。如果两个点具有相同的斜率，则先按 $x$ 从小到大排序，再按 $y$ 从小到大排序。换句话说，如果$(x_1<x_2)\\vee(x_1=x_2\\wedge y_1<y_2)$，则点 $(x_1,y_1)$ 在斜率上小于 $(x_2,y_2)$。", "inputFormat": "第一行包含一个整数 $T (1\\le T\\le 500)$，表示数据组数。\n\n对于每组数据，第一行包含两个整数 $n,k(n\\ge 3,1\\le k)$。\n\n接下来 $n$ 行，每行给出了多边形的一个顶点。每个顶点由两个整数 $x,y(1\\le x, y\\le 10^9)$ 表示，表示其坐标 $(x,y)$。顶点按逆时针顺序给出。\n\n保证多边形是简单的，即所有顶点互不相同，两条边只有在相邻时才会重叠，并且恰好重叠 $1$ 次。\n\n保证 $k$ 不超过多边形中的网格点数。\n\n保证 $\\sum n \\le 2000$。", "outputFormat": "对于每组数据，输出一行两个整数 $x,y$，表示第 $k$ 个网格点的坐标。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9673", "type": "P", "difficulty": 5, "samples": [["3\n3\n3 2 1\n5\n2 4 5 3 1\n10\n7 2 4 6 1 9 10 8 5 3", "1\n4\n7"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "ICPC", "济南"], "title": "[ICPC 2022 Jinan R] Quick Sort", "background": "", "description": "When Prof. Pang was young, he wrote the following code for quick sort. Please calculate how many swaps are performed when calling $\\text{quicksort}(A, 1, n)$. $A$ is a given permutation with length $n$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8ig9i3bq.png)", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10^5)$, the number of test cases.\n\nFor each test case, the first line contains one positive integer $n~(1\\le n \\le 5\\times 10^5)$. The next line contains $n$ integers $a_1,\\ldots, a_n~(1 \\le a_i\\le n)$ denoting the permutation $A$. It is guaranteed that $a_1,\\ldots, a_n$ form a permutation, i.e.~$a_i\\neq a_j$ for $i \\neq j$. \n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $5\\times 10^5$.", "outputFormat": "For each test case, output one line containing the number of swaps performed when calling $\\text{quicksort}(A, 1, n)$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Quick Sort", "background": "", "description": "When Prof. Pang was young, he wrote the following code for quick sort. Please calculate how many swaps are performed when calling $\\text{quicksort}(A, 1, n)$. $A$ is a given permutation with length $n$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8ig9i3bq.png)", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10^5)$, the number of test cases.\n\nFor each test case, the first line contains one positive integer $n~(1\\le n \\le 5\\times 10^5)$. The next line contains $n$ integers $a_1,\\ldots, a_n~(1 \\le a_i\\le n)$ denoting the permutation $A$. It is guaranteed that $a_1,\\ldots, a_n$ form a permutation, i.e.~$a_i\\neq a_j$ for $i \\neq j$. \n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $5\\times 10^5$.", "outputFormat": "For each test case, output one line containing the number of swaps performed when calling $\\text{quicksort}(A, 1, n)$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Quick Sort", "background": "", "description": "给定一个长度为 $n$ 的排列 $A$。现使用如下伪代码对 $A$ 进行排序：\n\n```\nprocedure QUICKSORT(A,lo,hi)\n    if lo>=0 and hi>=0 and lo<hi then\n    \tp=PARTITION(A,lo,hi)\n        QUICKSORT(A,lo,p)\n        QUICKSORT(A,p+1,hi)\n    end if\nend procedure\nprocedure PARTITION(A,lo,hi)\n    pivot=A[floor((hi+lo)/2)]\n    i=lo-1\n    j=hi+1\n    while True do\n        repeat\n            i=i+1\n        until A[i]>=pivot\n        repeat\n            j=j-1\n        until A[j]<=pivot\n        if i>=j then\n            return j\n        end if\n        Swap A[i] with A[j]\n    end while\nend procedure\n```\n\n试计算：调用 `QUICKSORT(A,1,n)` 函数过程中，`Swap` 操作执行了多少次。", "inputFormat": "第一行包含一个整数 $T$ $(1\\leqslant T\\leqslant 10^5)$，表示测试数据组数。\n\n对于每组测试数据：\n\n第一行包含一个正整数 $n$ $(1\\leqslant n\\leqslant 5\\times 10^5)$。\n\n第二行包含 $n$ 个整数 $a_1,\\dots,a_n$ $(1\\leqslant a_i\\leqslant n)$，表示排列 $A$。保证 $a_1,\\dots,a_n$ 构成一个排列，即：$\\forall i\\not= j,a_i\\not=a_j$。\n\n保证所有测试数据中 $n$ 的和不超过 $5\\times 10^5$。", "outputFormat": "对于每组测试数据，输出一行一个整数，表示调用 `QUICKSORT(A,1,n)` 函数过程中，`Swap` 操作执行的次数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9674", "type": "P", "difficulty": 6, "samples": [["4\n1\n1 1000000000\n2\n1 1000000000\n1 1000000000\n4\n1 2\n3 4\n5 6\n7 8\n4\n1 3\n2 4\n5 8\n6 7", "1\n499999999500000000\n26\n28"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "ICPC", "Ad-hoc", "分类讨论", "济南"], "title": "[ICPC 2022 Jinan R] Set of Intervals", "background": "", "description": "Prof. Pang has a multi-set of intervals $S=\\{[l_i,r_i]\\}$($l_i<r_i$).\n\nProf. Pang will perform the following operation for $|S|-1$ times:\n\n- Select two intervals $[a,b]$ and $[c,d]$ from $S$, and then choose two integers $x,y$ satisfying $x\\in [a,b], y\\in [c,d], x<y$. After that, delete $[a,b]$ and $[c,d]$ from $S$, and add $[x,y]$ to $S$.\n\nIt's easy to find that $S$ contains exactly one interval after the operations, and Prof. Pang will get the interval as a gift.\n\nNow Prof. Pang wants you to calculate how many different intervals he can get.", "inputFormat": "The first line contains one integer $T~$($1\\le T \\le 10^4$), the number of test cases.\n\nFor each test case, the first line contains one integer $n~$($1\\le n\\le 10^5$) --- the size of $S$. Each of the following $n$ lines contains two integers $l_i$ and $r_i~$($1\\le l_i<r_i\\le 10^9$), describing the $i$-th interval in $S$.\n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $10^5$.", "outputFormat": "For each test case, output one line containing the answer to Prof. Pang's question.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Set of Intervals", "background": "", "description": "Prof. Pang has a multi-set of intervals $S=\\{[l_i,r_i]\\}$($l_i<r_i$).\n\nProf. Pang will perform the following operation for $|S|-1$ times:\n\n- Select two intervals $[a,b]$ and $[c,d]$ from $S$, and then choose two integers $x,y$ satisfying $x\\in [a,b], y\\in [c,d], x<y$. After that, delete $[a,b]$ and $[c,d]$ from $S$, and add $[x,y]$ to $S$.\n\nIt's easy to find that $S$ contains exactly one interval after the operations, and Prof. Pang will get the interval as a gift.\n\nNow Prof. Pang wants you to calculate how many different intervals he can get.", "inputFormat": "The first line contains one integer $T~$($1\\le T \\le 10^4$), the number of test cases.\n\nFor each test case, the first line contains one integer $n~$($1\\le n\\le 10^5$) --- the size of $S$. Each of the following $n$ lines contains two integers $l_i$ and $r_i~$($1\\le l_i<r_i\\le 10^9$), describing the $i$-th interval in $S$.\n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $10^5$.", "outputFormat": "For each test case, output one line containing the answer to Prof. Pang's question.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Set of Intervals", "background": "", "description": "庞教授有一个多重区间集 $S=\\{[l_i,r_i]\\}$（$l_i<r_i$）。\n\n庞教授将对 $|S|-1$ 次执行以下操作：\n\n- 从 $S$ 中选择两个区间 $[a,b]$ 和 $[c,d]$，然后选择两个整数 $x,y$ 满足 $x\\in [a,b], y\\in [c,d], x<y$。之后，从 $S$ 中删除 $[a,b]$ 和 $[c,d]$，并将 $[x,y]$ 添加到 $S$。\n\n很容易发现，经过这些操作后，$S$ 中恰好包含一个区间，庞教授将得到这个区间作为礼物。\n\n现在庞教授希望你计算他可以得到多少个不同的区间。", "inputFormat": "第一行包含一个整数 $T$（$1\\le T \\le 10^4$），表示测试用例的数量。\n\n对于每个测试用例，第一行包含一个整数 $n$（$1\\le n\\le 10^5$）——$S$ 的大小。接下来的 $n$ 行中的每一行包含两个整数 $l_i$ 和 $r_i$（$1\\le l_i<r_i\\le 10^9$），描述 $S$ 中的第 $i$ 个区间。\n\n保证所有测试用例的 $n$ 之和不超过 $10^5$。", "outputFormat": "对于每个测试用例，输出一行，包含庞教授问题的答案。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9675", "type": "P", "difficulty": 7, "samples": [["4\n3 2 10\n1 2 5\n2 3 4\n3 0 1000000000\n3 3 100\n1 2 3\n1 3 4\n2 3 5\n4 6 1000000000\n1 2 244\n1 2 325\n1 4 927\n3 3 248\n2 4 834\n3 4 285", "125\n0\n15300\n840659991"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "半平面交", "ICPC", "李超线段树", "济南"], "title": "[ICPC 2022 Jinan R] Shortest Path", "background": "", "description": "You are given an undirected weighted graph $G$ with vertices $1, 2, \\ldots, n$. Please output the sum of the answers to the following $x$ questions:\n- The $i$-th question $(1\\le i\\le x$): What is the minimum length of path that starts at vertex $1$, ends at vertex $n$, and contains exactly $i$ edges?\n\nFor each question, if such a path does not exist, the answer is considered to be $0$. A path may use one edge multiple times. Output the answer modulo $998244353$. \n", "inputFormat": "The first line contains one integer $T~(1 \\le T\\le 2000)$, the number of test cases.\n\nFor each test case, the first line contains three integers $n, m, x~(1\\le n\\le 2000, 0\\le m\\le 5000, 1\\le x\\le 10^9)$. Each of the next $m$ lines describes an edge of the graph. Edge $i$ is denoted by three integers $a_i, b_i, w_i$ $(1\\le a_i, b_i\\le n, 1\\le w_i\\le 10^9)$, the labels of vertices it connects and its weight. Note that self-loops and parallel edges may exist.\n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $2000$ and the sum of $m$ over all test cases is no more than $5000$.", "outputFormat": "For each test case, output one integer modulo $998244353$ denoting the answer.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Shortest Path", "background": "", "description": "You are given an undirected weighted graph $G$ with vertices $1, 2, \\ldots, n$. Please output the sum of the answers to the following $x$ questions:\n- The $i$-th question $(1\\le i\\le x$): What is the minimum length of path that starts at vertex $1$, ends at vertex $n$, and contains exactly $i$ edges?\n\nFor each question, if such a path does not exist, the answer is considered to be $0$. A path may use one edge multiple times. Output the answer modulo $998244353$. \n", "inputFormat": "The first line contains one integer $T~(1 \\le T\\le 2000)$, the number of test cases.\n\nFor each test case, the first line contains three integers $n, m, x~(1\\le n\\le 2000, 0\\le m\\le 5000, 1\\le x\\le 10^9)$. Each of the next $m$ lines describes an edge of the graph. Edge $i$ is denoted by three integers $a_i, b_i, w_i$ $(1\\le a_i, b_i\\le n, 1\\le w_i\\le 10^9)$, the labels of vertices it connects and its weight. Note that self-loops and parallel edges may exist.\n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $2000$ and the sum of $m$ over all test cases is no more than $5000$.", "outputFormat": "For each test case, output one integer modulo $998244353$ denoting the answer.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Shortest Path", "background": "", "description": "给定一张 $n$ 个点 $m$ 条边的无向图 $G$，边有边权。你要回答 $x$ 个问题，其中第 $i$ $(1\\leqslant i\\leqslant x)$ 个问题形如：\n\n- 从结点 $1$ 出发，经过 **恰好** $i$ 条边，到达结点 $n$ 的最短路径长度为多少？\n\n对于每个询问，若不存在这样的路径，答案应当为 $0$。一条路径可能 **多次** 经过一条边。\n\n求出这 $x$ 个问题所对应的答案之和。输出答案对 $998244353$ 取模后的结果。", "inputFormat": "第一行包含一个整数 $T$ $(1\\leqslant T\\leqslant 2000)$，表示测试数据组数。\n\n对于每组测试数据：\n\n第一行三个整数 $n,m,x$ $(1\\leqslant n\\leqslant 2000,0\\leqslant m\\leqslant 5000,1\\leqslant x\\leqslant 10^9)$。\n\n接下来 $m$ 行，每行三个整数 $a_i,b_i,w_i$ $(1\\leqslant a_i,b_i\\leqslant n,1\\leqslant w_i\\leqslant 10^9)$，分别表示第 $i$ 条边连接的两个结点的编号和其边权。注意 **可能存在自环和重边**。\n\n保证所有测试数据中 $n$ 的总和不超过 $2000$，且 $m$ 的总和不超过 $5000$。", "outputFormat": "对于每组测试数据，输出这组测试数据对应的答案 $\\bmod$ $998244353$ 后的结果。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9676", "type": "P", "difficulty": 6, "samples": [["2\n3\n1 1 10\n1 10 1\n10 1 1\n5\n1 2 3\n6 5 4\n7 8 9\n12 11 10\n13 14 15\n", "26\n41"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2022", "O2优化", "ICPC", "济南"], "title": "[ICPC 2022 Jinan R]  Skills", "background": "", "description": "\nProf. Pang has $3$ different skills to practice, including soda drinking, fox hunting, and stock investing. We call them Skill $1$, Skill $2$, and Skill $3$. In each of the following $n$ days, Prof. Pang can choose one of the three skills to practice. In the $i$-th day ($1\\le i\\le n$), if Prof. Pang chooses Skill $j$ ($1\\le j\\le 3$) to practice, his level of Skill $j$ will increase by $a_{i,j}$. Initially, Prof. Pang's levels of all skills are $0$.\n\nProf. Pang forgets skills if he does not practice. At the end of each day, if he has not practiced Skill $j$ for $k$ days, his level of Skill $j$ will decrease by $k$. For example, if he practices Skill $1$ on day $1$ and Skill $2$ on day $2$, at the end of day $2$, he has not practiced Skill $1$ for $1$ day and has not practiced Skill $3$ for $2$ days. Then his levels of Skill $1$ and Skill $3$ will decrease by $1$ and $2$, respectively. His level of Skill $2$ does not decrease at the end of day $2$ because he practices Skill $2$ on that day. In this example, we also know that his levels of Skill $2$ and Skill $3$ both decrease by $1$ at the end of day $1$.\n\nProf. Pang's level of any skill will not decrease below $0$. For example, if his level of some skill is $3$ and at the end of some day, this level is decreased by $4$, it will become $0$ instead of $-1$.\n\nProf. Pang values all skills equally. Thus, he wants to maximize the sum of his three skill levels after the end of day $n$. \n\nGiven $a_{i,j}$ ($1\\le i\\le n, 1\\le j\\le 3$), find the maximum sum.\n", "inputFormat": "The first line contains a single integer $T~(1 \\le T \\le 1000)$ denoting the number of test cases.\n\nFor each test case, the first line contains an integer $n~(1 \\le n \\le 1000)$. The $(i+1)$-th line contains three integers $a_{i,1}, a_{i,2}, a_{i,3}$ ($0\\le a_{i,j}\\le 10000$ for any $1\\le i\\le n, 1\\le j\\le 3$).\n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $1000$.", "outputFormat": "For each test case, output the maximum possible sum of skill levels in one line. ", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R]  Skills", "background": "", "description": "\nProf. Pang has $3$ different skills to practice, including soda drinking, fox hunting, and stock investing. We call them Skill $1$, Skill $2$, and Skill $3$. In each of the following $n$ days, Prof. Pang can choose one of the three skills to practice. In the $i$-th day ($1\\le i\\le n$), if Prof. Pang chooses Skill $j$ ($1\\le j\\le 3$) to practice, his level of Skill $j$ will increase by $a_{i,j}$. Initially, Prof. Pang's levels of all skills are $0$.\n\nProf. Pang forgets skills if he does not practice. At the end of each day, if he has not practiced Skill $j$ for $k$ days, his level of Skill $j$ will decrease by $k$. For example, if he practices Skill $1$ on day $1$ and Skill $2$ on day $2$, at the end of day $2$, he has not practiced Skill $1$ for $1$ day and has not practiced Skill $3$ for $2$ days. Then his levels of Skill $1$ and Skill $3$ will decrease by $1$ and $2$, respectively. His level of Skill $2$ does not decrease at the end of day $2$ because he practices Skill $2$ on that day. In this example, we also know that his levels of Skill $2$ and Skill $3$ both decrease by $1$ at the end of day $1$.\n\nProf. Pang's level of any skill will not decrease below $0$. For example, if his level of some skill is $3$ and at the end of some day, this level is decreased by $4$, it will become $0$ instead of $-1$.\n\nProf. Pang values all skills equally. Thus, he wants to maximize the sum of his three skill levels after the end of day $n$. \n\nGiven $a_{i,j}$ ($1\\le i\\le n, 1\\le j\\le 3$), find the maximum sum.\n", "inputFormat": "The first line contains a single integer $T~(1 \\le T \\le 1000)$ denoting the number of test cases.\n\nFor each test case, the first line contains an integer $n~(1 \\le n \\le 1000)$. The $(i+1)$-th line contains three integers $a_{i,1}, a_{i,2}, a_{i,3}$ ($0\\le a_{i,j}\\le 10000$ for any $1\\le i\\le n, 1\\le j\\le 3$).\n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $1000$.", "outputFormat": "For each test case, output the maximum possible sum of skill levels in one line. ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R]  Skills", "background": null, "description": "庞博士有 $3$ 项技能：喝汽水、猎狐和炒股，编号分别为 $1,2,3$。初始时，每项技能的熟练度为 $0$。\n\n接下来有 $n$ 天。在第 $i$ 天，庞博士可以选择一项技能（假设是第 $j$ 项）进行练习，然后在这天结束时让这项技能的熟练度增加 $a_{i,j}(0\\leq a_{i,j}\\leq 10000)$。同时，如果某一项技能（假设是第 $k$ 项）已经有 $x$ 天没有练习，那么在这天结束时，这项技能的熟练度会减少 $x$。当然，任何一项技能的熟练度都不可能小于 $0$。\n\n现在，庞博士想知道：在第 $n$ 天结束后，这 $3$ 项技能的熟练度之和最大为多少。由于他非常忙，而且他的日程和对习惯的适应程度可能有变，所以庞博士把这 $T$ 个问题交给了你——每个问题的内容都一样，只是给出的数据可能有所不同而已。", "inputFormat": "第一行，一个正整数 $T~(1 \\leq T \\leq 1000)$，表示数据组数。\n\n对于每组数据，输入 $(n + 1)$ 行。\n\n* 第一行，一个正整数 $n\\ (1 \\leq n \\leq 1000)$，表示天数。\n* 第 $i + 1$ 行，包含三个正整数 $a_{i, 1}, a_{i, 2}, a_{i, 3}\\ (0 \\leq a_{i, j} \\leq 10000,\\ \\forall 1 \\leq i \\leq n,\\ 1 \\leq j \\leq 3)$。\n\n数据保证单个测试点内的 $\\sum n$ 不超过 $1000$。", "outputFormat": "对于每组数据，输出 $1$ 行 $1$ 个数，表示答案。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P9677", "type": "P", "difficulty": 2, "samples": [["3\n3\n1 2 3\n3\n3 2 1\n5\n1 4 2 5 3\n", "3\n1\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "ICPC", "济南"], "title": "[ICPC 2022 Jinan R] Stack Sort", "background": "", "description": "You are given a permutation with $n$ numbers, $a_1, a_2, \\dots, a_n (1\\leq a_i\\leq n, a_i\\neq a_j\\textrm{ when }i\\neq j)$. \n\nYou want to sort these numbers using $m$ stacks. Specifically, you should complete the following task: \n\nInitially, all stacks are empty. You need to push each number $a_i$ to the top of one of the $m$ stacks one by one, in the order of $a_1,a_2,\\ldots, a_n$. $\\textbf{After pushing all numbers in the stacks}$, you pop all the elements from the stacks in a clever order so that the first number you pop is $1$, the second number you pop is $2$, and so on. **If you pop an element from a stack $S$, you cannot pop any element from the other stacks until $S$ becomes empty.**\n\nWhat is the minimum possible $m$ to complete the task?", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10^5)$, the number of test cases.\n\nFor each test case, the first line contains one positive integer $n~(1\\le n \\le 5 \\times 10^5)$. The next line contains $n$ integers $a_1,\\ldots, a_n~(1 \\le a_i\\le n)$ denoting the permutation. It is guaranteed that $a_1,\\ldots, a_n$ form a permutation, i.e. $a_i\\neq a_j$ for $i \\neq j$. \n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $5\\times 10^5$.\n", "outputFormat": "For each test case, output the minimum possible $m$ in one line.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Stack Sort", "background": "", "description": "You are given a permutation with $n$ numbers, $a_1, a_2, \\dots, a_n (1\\leq a_i\\leq n, a_i\\neq a_j\\textrm{ when }i\\neq j)$. \n\nYou want to sort these numbers using $m$ stacks. Specifically, you should complete the following task: \n\nInitially, all stacks are empty. You need to push each number $a_i$ to the top of one of the $m$ stacks one by one, in the order of $a_1,a_2,\\ldots, a_n$. $\\textbf{After pushing all numbers in the stacks}$, you pop all the elements from the stacks in a clever order so that the first number you pop is $1$, the second number you pop is $2$, and so on. **If you pop an element from a stack $S$, you cannot pop any element from the other stacks until $S$ becomes empty.**\n\nWhat is the minimum possible $m$ to complete the task?", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10^5)$, the number of test cases.\n\nFor each test case, the first line contains one positive integer $n~(1\\le n \\le 5 \\times 10^5)$. The next line contains $n$ integers $a_1,\\ldots, a_n~(1 \\le a_i\\le n)$ denoting the permutation. It is guaranteed that $a_1,\\ldots, a_n$ form a permutation, i.e. $a_i\\neq a_j$ for $i \\neq j$. \n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $5\\times 10^5$.\n", "outputFormat": "For each test case, output the minimum possible $m$ in one line.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Stack Sort", "background": "", "description": "给定一个包含 $n$ 个数字的排列 $a_1, a_2, \\dots, a_n (1\\leq a_i\\leq n, a_i\n\\neq a_j\\text{ 当 }i\n\\neq j)$。\n\n你需要使用 $m$ 个栈对这些数字进行排序。具体来说，你需要完成以下任务：\n\n最初，所有栈都是空的。你需要按照 $a_1,a_2,\\ldots, a_n$ 的顺序，将每个数字 $a_i$ 压入 $m$ 个栈中的一个栈的顶部。**在将所有数字压入栈中之后**，你需要以一种巧妙的顺序从栈中弹出所有元素，使得你弹出的第一个数字是 $1$，第二个数字是 $2$，依此类推。**如果你从一个栈 $S$ 中弹出一个元素，那么在 $S$ 变空之前，你不能从其他栈中弹出任何元素。**\n\n完成任务所需的最小 $m$ 是多少？", "inputFormat": "第一行包含一个整数 $T~(1\\le T \\le 10^5)$，表示测试用例的数量。\n\n对于每个测试用例，第一行包含一个正整数 $n~(1\\le n \\le 5 \\times 10^5)$。下一行包含 $n$ 个整数 $a_1,\\ldots, a_n~(1 \\le a_i\\le n)$，表示排列。保证 $a_1,\\ldots, a_n$ 形成一个排列，即 $a_i\n\\neq a_j$ 对于 $i \n\\neq j$。\n\n保证所有测试用例中 $n$ 的总和不超过 $5\\times 10^5$。", "outputFormat": "对于每个测试用例，输出一个整数，表示完成任务所需的最小 $m$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9678", "type": "P", "difficulty": 7, "samples": [["5\n1 2 5\n1 3 3\n1 4 4\n3 5 2\n5\n1 1\n1 4\n2 4\n3 4\n2 5\n", "-1\n3\n7\n7\n2\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["点分治", "2022", "O2优化", "ICPC", "济南"], "title": "[ICPC 2022 Jinan R] Tree Distance", "background": "", "description": "You are given an unrooted weighted tree $T$ with vertices $1, 2, \\ldots, n$. Please answer some queries.\n\nWe define $\\texttt{dist}(i,j)$ as the distance between vertex $i$ and vertex $j$ in $T$.\n\nFor each query, you are given two integers $l, r$. Please answer the value of \n\n$$\\min_{l\\le i< j\\le r}(\\texttt{dist}(i,j)).$$", "inputFormat": "The first line contains one integer $n~(1\\leq n\\le 2 \\times 10^5)$, the number of vertices in the tree. \n\nEach of the next $n-1$ lines describes an edge of the tree. Edge $i$ is denoted by three integers $a_i, b_i, w_i$ $(1\\le a_i, b_i\\le n, 1\\le w_i\\le 10^9)$, the labels of vertices it connects and its weight. \n\nThen one line contains one integer $q~(1\\leq q\\le 10^6)$, the number of queries.\n\nEach of the following $q$ lines contains two integers $l, r~(1\\le l \\le r\\le n)$ describing a query.\n\nIt is guaranteed that the given edges form a tree.", "outputFormat": "\nFor each query, output the answer in one line. If there is no $i,j$ such that $l\\le i<j\\le r$, the answer is $-1$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Tree Distance", "background": "", "description": "You are given an unrooted weighted tree $T$ with vertices $1, 2, \\ldots, n$. Please answer some queries.\n\nWe define $\\texttt{dist}(i,j)$ as the distance between vertex $i$ and vertex $j$ in $T$.\n\nFor each query, you are given two integers $l, r$. Please answer the value of \n\n$$\\min_{l\\le i< j\\le r}(\\texttt{dist}(i,j)).$$", "inputFormat": "The first line contains one integer $n~(1\\leq n\\le 2 \\times 10^5)$, the number of vertices in the tree. \n\nEach of the next $n-1$ lines describes an edge of the tree. Edge $i$ is denoted by three integers $a_i, b_i, w_i$ $(1\\le a_i, b_i\\le n, 1\\le w_i\\le 10^9)$, the labels of vertices it connects and its weight. \n\nThen one line contains one integer $q~(1\\leq q\\le 10^6)$, the number of queries.\n\nEach of the following $q$ lines contains two integers $l, r~(1\\le l \\le r\\le n)$ describing a query.\n\nIt is guaranteed that the given edges form a tree.", "outputFormat": "\nFor each query, output the answer in one line. If there is no $i,j$ such that $l\\le i<j\\le r$, the answer is $-1$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Tree Distance", "background": "", "description": "给定一个无根的加权树 $T$，其顶点为 $1, 2, \\ldots, n$。请回答一些查询。\n\n我们定义 $\\texttt{dist}(i,j)$ 为顶点 $i$ 和顶点 $j$ 在树 $T$ 中的距离。\n\n对于每个查询，给定两个整数 $l, r$。请回答以下值：\n\n$$\\min_{l\\le i< j\\le r}(\\texttt{dist}(i,j)).$$", "inputFormat": "第一行包含一个整数 $n~(1\\leq n\\le 2 \\times 10^5)$，表示树中的顶点数。\n\n接下来的 $n-1$ 行描述了树中的一条边。第 $i$ 条边由三个整数 $a_i, b_i, w_i$ $(1\\le a_i, b_i\\le n, 1\\le w_i\\le 10^9)$ 表示，分别为它连接的顶点的标签及其权重。\n\n然后一行包含一个整数 $q~(1\\leq q\\le 10^6)$，表示查询的数量。\n\n接下来的 $q$ 行中的每一行包含两个整数 $l, r~(1\\le l \\le r\\le n)$，描述一个查询。\n\n保证给定的边构成一棵树。", "outputFormat": "对于每个查询，输出答案一行。如果不存在 $i,j$ 使得 $l\\le i<j\\le r$，则答案为 $-1$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9679", "type": "P", "difficulty": 3, "samples": [["2\n3\n9 99 999\n1\n12345", "5\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "ICPC", "济南"], "title": "[ICPC 2022 Jinan R] Best Carry Player", "background": "", "description": "Prof. Pang is given $n$ numbers $a_1,\\ldots, a_n$. It is easy to add the numbers up using a computer. But Prof. Pang treasures his computer so much and wants to reduce its workload. He decides to simulate the following program by hand. \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ajtj92in.png)\n\n\nUnlike a computer, the time needed for Prof. Pang to simulate the program is proportional to the total number of **carries**(which means “进位” in Chinese) when calculating $s+a[i]$ for each $i$ from $1$ to $n$. Prof. Pang adds numbers **by column addition in base-ten**, just like what we normally do in primary school. For example, there are two carries in the following addition.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/c779jeox.png)\n\nPlease permute the array $a_1,\\ldots, a_n$ so that the total number of carries when Prof. Pang simulates the program is as small as possible. (By ''permute an array'', we mean that you can change the order of the elements arbitrarily.)\n", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10^5)$, the number of test cases.\n\nFor each test case, the first line contains one positive integer $n~(1\\le n \\le 10^5)$. The next line contains $n$ integers $a_1,\\ldots, a_n~(1 \\le a_i\\le 10^9)$ denoting the numbers Prof. Pang is given. \n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $10^5$.", "outputFormat": "For each test case, output one line containing the minimum amount of carries.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Best Carry Player", "background": "", "description": "Prof. Pang is given $n$ numbers $a_1,\\ldots, a_n$. It is easy to add the numbers up using a computer. But Prof. Pang treasures his computer so much and wants to reduce its workload. He decides to simulate the following program by hand. \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ajtj92in.png)\n\n\nUnlike a computer, the time needed for Prof. Pang to simulate the program is proportional to the total number of **carries**(which means “进位” in Chinese) when calculating $s+a[i]$ for each $i$ from $1$ to $n$. Prof. Pang adds numbers **by column addition in base-ten**, just like what we normally do in primary school. For example, there are two carries in the following addition.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/c779jeox.png)\n\nPlease permute the array $a_1,\\ldots, a_n$ so that the total number of carries when Prof. Pang simulates the program is as small as possible. (By ''permute an array'', we mean that you can change the order of the elements arbitrarily.)\n", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10^5)$, the number of test cases.\n\nFor each test case, the first line contains one positive integer $n~(1\\le n \\le 10^5)$. The next line contains $n$ integers $a_1,\\ldots, a_n~(1 \\le a_i\\le 10^9)$ denoting the numbers Prof. Pang is given. \n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $10^5$.", "outputFormat": "For each test case, output one line containing the minimum amount of carries.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Best Carry Player", "background": "", "description": "### 简要题面\n\n这里我们定义一个电脑运行 $a+b$ 的速度是 $a+b$ 中出现的进位的次数。\n\n给定一个数组 $a_1,a_2,...,a_n$，请找出正确的排序使得计算这个数组的和时运行的速度最短，请找出最少的进位次数。", "inputFormat": "**本题有多组数据**。\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行一个整数 $n$。  \n\n接下来一行 $n$ 个整数，表示输入的数组 $a$。", "outputFormat": "对于每组数据，输出最小的进位次数。", "hint": "对于 $100 \\%$ 的数据： $1 \\leq \\sum n \\leq 10^5$， $1 \\leq a_i \\leq 10^9$", "locale": "zh-CN"}}}
{"pid": "P9680", "type": "P", "difficulty": 2, "samples": [["6\nstring a(\"cxyakioi\");\nstring_view b(\"cxyakapio\");\nstring c(b);\nstring_view d(a);\nstring_view cxyakioi(c);\nstring cxyakapio(d);", "25"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "字符串", "洛谷原创", "O2优化", "洛谷月赛"], "title": "string[_view]", "background": "C++ 的 string 类是一个功能强大的字符串类，然而由于其字符串算法和内存管理绑定的机制，所以在处理 C 风格字符串时效率低下。\n\n为了解决这个问题，C++17 标准引入了 string\\_view 类型，将内存管理和字符串算法分离，从而更好地适配了 C 风格字符串的处理。", "description": "你需要模拟一个简单的 C++ 程序，该程序的每一行必然为如下两种形式之一：\n\n- `string <variable-name>(<initializer>);`\n- `string_view <variable-name>(<initializer>);`\n\n其中 `variable-name` 为声明的变量名（保证之前未出现过，且长度不超过 $10$），`initializer` 为初始化该变量的内容，可以是：\n\n- 字符串字面量，即用双引号引起的字符串（形如 `\"abc\"`）；\n- 之前出现过的变量名 `source`，此时应将 `source` 对应的字符串赋给 `variable-name`。\n\n具体而言，将任意一个字符串 $s$ 赋给 string 类型会进行 $|s|$ 次字符拷贝，而赋给 string\\_view 类型不会拷贝字符。其中 $|s|$ 为字符串 $s$ 的长度。\n\n你需要计算出该程序中字符拷贝的总次数。", "inputFormat": "第一行输入一个整数 $L$，代表程序行数。\n\n接下来 $L$ 行，输入一段代码。", "outputFormat": "输出一个整数，代表字符拷贝总次数。", "hint": "  对于每组数据，保证代码长度均不超过 $10^4$（不包括换行符）。\n\n保证字符串字面量（除去两侧引号）和变量名中只有拉丁字母，且给定的代码严格满足题目要求。\n\n### 子任务\n\n|  #   |            特殊性质            | 分值 |\n| :--: | :----------------------------: | :--: |\n|  0   |              样例              | 0  |\n|  1   | 所有变量均为 string\\_view 类型 | 10 |\n|  2   |    只使用字符串字面量初始化    | 20 |\n|  3   |               -                | 70 |\n\n---\n\n好消息：GCC 9.3.0 支持 string_view。\n\n坏消息：NOI 不开 C++17。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "string[_view]", "background": "C++ 的 string 类是一个功能强大的字符串类，然而由于其字符串算法和内存管理绑定的机制，所以在处理 C 风格字符串时效率低下。\n\n为了解决这个问题，C++17 标准引入了 string\\_view 类型，将内存管理和字符串算法分离，从而更好地适配了 C 风格字符串的处理。", "description": "你需要模拟一个简单的 C++ 程序，该程序的每一行必然为如下两种形式之一：\n\n- `string <variable-name>(<initializer>);`\n- `string_view <variable-name>(<initializer>);`\n\n其中 `variable-name` 为声明的变量名（保证之前未出现过，且长度不超过 $10$），`initializer` 为初始化该变量的内容，可以是：\n\n- 字符串字面量，即用双引号引起的字符串（形如 `\"abc\"`）；\n- 之前出现过的变量名 `source`，此时应将 `source` 对应的字符串赋给 `variable-name`。\n\n具体而言，将任意一个字符串 $s$ 赋给 string 类型会进行 $|s|$ 次字符拷贝，而赋给 string\\_view 类型不会拷贝字符。其中 $|s|$ 为字符串 $s$ 的长度。\n\n你需要计算出该程序中字符拷贝的总次数。", "inputFormat": "第一行输入一个整数 $L$，代表程序行数。\n\n接下来 $L$ 行，输入一段代码。", "outputFormat": "输出一个整数，代表字符拷贝总次数。", "hint": "  对于每组数据，保证代码长度均不超过 $10^4$（不包括换行符）。\n\n保证字符串字面量（除去两侧引号）和变量名中只有拉丁字母，且给定的代码严格满足题目要求。\n\n### 子任务\n\n|  #   |            特殊性质            | 分值 |\n| :--: | :----------------------------: | :--: |\n|  0   |              样例              | 0  |\n|  1   | 所有变量均为 string\\_view 类型 | 10 |\n|  2   |    只使用字符串字面量初始化    | 20 |\n|  3   |               -                | 70 |\n\n---\n\n好消息：GCC 9.3.0 支持 string_view。\n\n坏消息：NOI 不开 C++17。", "locale": "zh-CN"}}}
{"pid": "P9681", "type": "P", "difficulty": 4, "samples": [["4 3\n3 -4 -1 2\n1 2\n3 4\n1 4\n", "1\n2\n3\n"], ["7 6\n-1 2 -1 -1 -1 2 -1\n2 5\n4 7\n1 7\n5 5\n1 3\n2 4\n", "1\n2\n4\n0\n2\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "O2优化", "前缀和", "洛谷月赛"], "title": "幽默的世界。", "background": "@【数据删除】 : 大家觉得呢 || @【数据删除】 : oi 生活总是充满了幽默。 不过学文化课或许也好不了多少？", "description": "给定一个长为 $n$ 的序列 $a_1,a_2,\\cdots,a_n$，定义 $a$ 的一个连续子序列 $a_l,a_{l+1},\\cdots,a_r$ 是幽默的，当且仅当：\n\n- $\\sum\\limits_{i=l}^ra_i>0$；\n- 对于所有 $l\\le x\\le y<r$，满足 $\\sum\\limits_{i=x}^y a_i\\le 0$。\n\n$q$ 次询问，每次给定两个整数 $l,r$，查询满足以下条件的数对 $(l',r')$ 个数：\n\n- $l\\le l'\\le r'\\le r$；\n- 连续子序列 $a_{l'},a_{l'+1},\\cdots a_{r'}$ 是幽默的。", "inputFormat": "第一行输入两个整数 $n,q$。\n\n接下来一行输入 $n$ 个整数，第 $i$ 个整数代表 $a_i$。\n\n接下来 $q$ 行，每行输入两个整数 $l,r$，代表一次询问。", "outputFormat": "对于每组询问，输出一行一个整数，代表答案。", "hint": "对于所有数据，保证 $1\\le n,q\\le 2\\times 10^5$，$1\\le l\\le r\\le n$，$|a_i|\\le 10^9$。\n\n### 子任务\n\n|  #   |       特殊性质        | 分值 |\n| :--: | :-------------------: | :--: |\n|  0   |         样例          |  0   |\n|  1   |      $n,q\\le 50$      |  15  |\n|  2   | $n,q\\le 3\\times 10^3$ |  20  |\n|  3   |  对于所有询问，$r=n$  |  15  |\n|  4   |  对于所有询问，$l=1$  |  15  |\n|  5   |           -           |  35  |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "幽默的世界。", "background": "@【数据删除】 : 大家觉得呢 || @【数据删除】 : oi 生活总是充满了幽默。 不过学文化课或许也好不了多少？", "description": "给定一个长为 $n$ 的序列 $a_1,a_2,\\cdots,a_n$，定义 $a$ 的一个连续子序列 $a_l,a_{l+1},\\cdots,a_r$ 是幽默的，当且仅当：\n\n- $\\sum\\limits_{i=l}^ra_i>0$；\n- 对于所有 $l\\le x\\le y<r$，满足 $\\sum\\limits_{i=x}^y a_i\\le 0$。\n\n$q$ 次询问，每次给定两个整数 $l,r$，查询满足以下条件的数对 $(l',r')$ 个数：\n\n- $l\\le l'\\le r'\\le r$；\n- 连续子序列 $a_{l'},a_{l'+1},\\cdots a_{r'}$ 是幽默的。", "inputFormat": "第一行输入两个整数 $n,q$。\n\n接下来一行输入 $n$ 个整数，第 $i$ 个整数代表 $a_i$。\n\n接下来 $q$ 行，每行输入两个整数 $l,r$，代表一次询问。", "outputFormat": "对于每组询问，输出一行一个整数，代表答案。", "hint": "对于所有数据，保证 $1\\le n,q\\le 2\\times 10^5$，$1\\le l\\le r\\le n$，$|a_i|\\le 10^9$。\n\n### 子任务\n\n|  #   |       特殊性质        | 分值 |\n| :--: | :-------------------: | :--: |\n|  0   |         样例          |  0   |\n|  1   |      $n,q\\le 50$      |  15  |\n|  2   | $n,q\\le 3\\times 10^3$ |  20  |\n|  3   |  对于所有询问，$r=n$  |  15  |\n|  4   |  对于所有询问，$l=1$  |  15  |\n|  5   |           -           |  35  |\n", "locale": "zh-CN"}}}
{"pid": "P9682", "type": "P", "difficulty": 6, "samples": [["+?+-", "1"], ["??+-?-+", "11"], ["-????-?+?--????", "2523"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "洛谷原创", "O2优化", "组合数学", "洛谷月赛"], "title": "Electro Master", "background": "I might be wrong.", "description": "考虑一个由四种微观粒子构成的系统：正负 A 子 $\\text{a}^+,\\text{a}^-$，正负 B 子 $\\text{b}^+,\\text{b}^-$。\n\n一开始，一条直线上放置了 $n$ 个 A 子；然后以某种方式给粒子以初速度，使得带正电荷的粒子向左，反之则向右运动。我们忽略粒子之间的相互作用，认为粒子在加速后速率一定，且均沿直线运动。\n\n当两个粒子相撞时，粒子会反弹，沿着相反的方向继续运动。同时满足如下的变换规律：\n\n- 若两种粒子的电荷相同，则无事发生；\n- 若两种粒子的电荷不同，则改变成另一种同电荷的粒子。\n\n例如：$\\text{a}^-$ 和 $\\text{b}^+$ 相撞后，$\\text{a}^-$ 会变成 $\\text{b}^-$，$\\text{b}^+$ 会变成 $\\text{a}^+$，并各自沿着相反的方向运动。\n\n定义一种摆放方式的权值为，经过足够长的时间后，在左侧收集到的 B 子个数。\n\n现在已经确定了一些 A 子的正负性，剩下的 A 子可能带正电，也有可能带负电。请求出对于所有可能方案的权值之和。\n\n你需要将答案对 $998\\,244\\,353$ 取模。", "inputFormat": "输入一行一个长为 $n$ 的字符串 $s$，代表从左到右的 A 子的正负性。具体而言：\n\n- 若 $s_i$ 为 `+`，则第 $i$ 个 A 子带正电；\n- 若 $s_i$ 为 `-`，则第 $i$ 个 A 子带负电；\n- 若 $s_i$ 为 `?`，则第 $i$ 个 A 子可能带正电，也可能带负电。", "outputFormat": "输出一行一个数，代表答案对 $998\\,244\\,353$ 取模后的结果。", "hint": "#### 样例 1 解释\n\n有两种可能的填法：`+++-` 或 `+-+-`。其权值分别为 $0,1$，所以最终的答案即为 $1$。\n\n### 数据规模与约定\n\n对于所有数据，保证 $1\\le n\\le 2000$，$s_i\\in \\{\\texttt{+},\\texttt{-},\\texttt{?}\\}$。\n\n| # | $n\\le $ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: |\n| 0 | - | 样例 | $0$ |\n| 1 | $100$ | $s$ 中没有 `?` | $10$ |\n| 2 | $100$ | - | $20$ |\n| 3 | $300$ | $s$ 中 `?` 不超过 $15$ 个 | $15$ |\n| 4 | $300$ | - | $20$ |\n| 5 | - | - | $35$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Electro Master", "background": "I might be wrong.", "description": "考虑一个由四种微观粒子构成的系统：正负 A 子 $\\text{a}^+,\\text{a}^-$，正负 B 子 $\\text{b}^+,\\text{b}^-$。\n\n一开始，一条直线上放置了 $n$ 个 A 子；然后以某种方式给粒子以初速度，使得带正电荷的粒子向左，反之则向右运动。我们忽略粒子之间的相互作用，认为粒子在加速后速率一定，且均沿直线运动。\n\n当两个粒子相撞时，粒子会反弹，沿着相反的方向继续运动。同时满足如下的变换规律：\n\n- 若两种粒子的电荷相同，则无事发生；\n- 若两种粒子的电荷不同，则改变成另一种同电荷的粒子。\n\n例如：$\\text{a}^-$ 和 $\\text{b}^+$ 相撞后，$\\text{a}^-$ 会变成 $\\text{b}^-$，$\\text{b}^+$ 会变成 $\\text{a}^+$，并各自沿着相反的方向运动。\n\n定义一种摆放方式的权值为，经过足够长的时间后，在左侧收集到的 B 子个数。\n\n现在已经确定了一些 A 子的正负性，剩下的 A 子可能带正电，也有可能带负电。请求出对于所有可能方案的权值之和。\n\n你需要将答案对 $998\\,244\\,353$ 取模。", "inputFormat": "输入一行一个长为 $n$ 的字符串 $s$，代表从左到右的 A 子的正负性。具体而言：\n\n- 若 $s_i$ 为 `+`，则第 $i$ 个 A 子带正电；\n- 若 $s_i$ 为 `-`，则第 $i$ 个 A 子带负电；\n- 若 $s_i$ 为 `?`，则第 $i$ 个 A 子可能带正电，也可能带负电。", "outputFormat": "输出一行一个数，代表答案对 $998\\,244\\,353$ 取模后的结果。", "hint": "#### 样例 1 解释\n\n有两种可能的填法：`+++-` 或 `+-+-`。其权值分别为 $0,1$，所以最终的答案即为 $1$。\n\n### 数据规模与约定\n\n对于所有数据，保证 $1\\le n\\le 2000$，$s_i\\in \\{\\texttt{+},\\texttt{-},\\texttt{?}\\}$。\n\n| # | $n\\le $ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: |\n| 0 | - | 样例 | $0$ |\n| 1 | $100$ | $s$ 中没有 `?` | $10$ |\n| 2 | $100$ | - | $20$ |\n| 3 | $300$ | $s$ 中 `?` 不超过 $15$ 个 | $15$ |\n| 4 | $300$ | - | $20$ |\n| 5 | - | - | $35$ |\n", "locale": "zh-CN"}}}
{"pid": "P9683", "type": "P", "difficulty": 6, "samples": [["2\n2 1 1\n2 3 4", "1\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "交互题", "Special Judge", "O2优化", "构造", "洛谷月赛"], "title": "A Certain Forbidden Index", "background": "**这是一道函数式交互题。本题仅支持 C++ 提交。（出于某些原因，请不要使用 GCC 9 提交）**\n\n**本地编译、提交时请在程序里加入以下函数声明语句：**\n\n```cpp\nint query(int, int);\n```\n\n**任何在赛时攻击交互库而得分的行为均视为作弊。**\n", "description": "有一个长为 $n=2^k$ 的序列，基于这个序列建立了一棵[线段树](https://oi-wiki.org/ds/seg/)。现在线段树上有恰好一个节点被标记了。\n\n你可以进行若干次询问，每次询问给定一个区间 $[l,r]$，交互库会在被修改的线段树上进行一次区间查询，你可以得知在被修改的线段树上这个区间对应的所有节点中，是否有节点被标记。\n\n你需要在尽可能少的询问内找到这个节点。具体而言，若最优策略在最坏情况下需要 $Q$ 次询问，则你最多可以使用 $Q$ 次询问。\n\n### 交互流程\n\n你不需要，也不应该实现主函数，你只需要实现如下函数：\n\n```cpp\nstd::pair<int, int> solve(int k);\n```\n\n该函数需要在得到答案后返回一个数对 $(x,y)$，表示被标记的线段树节点所对应的区间为 $[x,y]$。\n\n你可以调用交互库提供的方法：\n\n```cpp\nint query(int l, int r);\n```\n\n传入的 `l` 和 `r` 代表询问的区间为 $[l,r]$。交互库会返回对应的结果。你需要保证 $1\\le l\\le r\\le n$。具体而言：\n\n- 当没有节点被标记时，交互库返回 $0$；\n- 当有节点被标记时，交互库返回 $1$；\n- 当询问的区间不合法时，交互库会返回 $-1$，此时你需要立即结束这组数据的交互（不是整个测试点），否则可能导致不可预知的错误。\n\n本题无询问次数限制，但过多的询问会导致时间超限，详细信息请看“数据规模与约定”。", "inputFormat": "下面给出样例交互库的输入输出格式：\n\n第一行输入一个整数 $T$，表示数据组数。\n\n对于每组数据，第一行输入三个整数 $k,l,r$ 代表 $n=2^k$，且将对应区间为 $[l,r]$ 的线段树节点修改。\n\n注意样例交互库不会检查输入数据的正确性。", "outputFormat": "对于每组数据，如果你得到的答案正确，输出一个整数表示你使用的交互次数，否则：\n\n- 若你的询问不合法，输出 `Wrong Answer [1]`；\n- 若你返回的区间不正确，输出 `Wrong Answer [2]`。", "hint": "#### 样例 1 解释\n\n下面是一种可能的交互流程：\n\n| 交互库 | 选手程序 | 备注 |\n| :----------: | :----------: | :----------: |\n| 调用 `solve(2)` |  | 开始测试 |\n| 返回 $1$ | 调用 `query(1,1)` | $[1,1]$ 就是答案节点 |\n|  | 返回 $(1,1)$ | 答案正确 |\n| 调用 `solve(2)` |  | 开始下一组数据的评测 |\n| 返回 $1$ | 调用 `query(2,4)` | $[2,4]$ 对应的节点是 $[2,2]$ 和 $[3,4]$，包括了答案节点 |\n| 返回 $0$ | 调用 `query(1,4)` | $[1,4]$ 对应的节点只有 $[1,4]$，不包括答案节点 |\n|  | 返回 $(3,4)$ | 答案正确，评测结束 |\n\n\n### 计分方式\n\n本题首先会受到和传统题相同的限制。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。\n\n如果你找到的节点是错误的，或者你给出的询问不合法，在该测试点将会得到 $0$ 分。\n\n否则，设在一组数据中，答案最坏需要 $x$ 次询问，而你使用了 $y$ 次询问，满分为 $t$，则这组数据的分数是 $t\\times \\min\\left(1,\\mathrm{e}^{-\\frac{y}{x}+1}\\right)$。\n\n每个测试点取所有数据组中得分的最小值，向下保留两位小数。你的得分是所有测试点得分之和。\n\n### 数据规模与约定\n\n对于所有数据，保证 $1\\le k\\le 14$，$1\\le T\\le 300$。\n\n本题共 $14$ 个测试点，对于第 $i$ 个测试点，保证 $k=i$。对于 $1\\le k\\le 4$ 的测试点，满分 $10$ 分。对于 $5\\le k\\le 14$ 的测试点，满分 $6$ 分。\n\n保证在每组数据进行 $2n$ 次询问时，单个测试点内，交互库使用的时间不超过 0.6s，空间不超过 8MiB。\n\n### 下发文件说明\n\n下发文件中有一个可以通过样例的程序示例 `sample.cpp`，以及一个样例交互库 `grader.cpp`。假设你的答案文件为 `answer.cpp`，则可以使用如下命令将其编译成可执行文件 `answer`：\n\n```shell\ng++ grader.cpp answer.cpp -o answer -O2\n```\n\n实际评测时的交互库可能是自适应的，即被修改的节点可能不会在交互一开始时确定。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "A Certain Forbidden Index", "background": "**这是一道函数式交互题。本题仅支持 C++ 提交。（出于某些原因，请不要使用 GCC 9 提交）**\n\n**本地编译、提交时请在程序里加入以下函数声明语句：**\n\n```cpp\nint query(int, int);\n```\n\n**任何在赛时攻击交互库而得分的行为均视为作弊。**\n", "description": "有一个长为 $n=2^k$ 的序列，基于这个序列建立了一棵[线段树](https://oi-wiki.org/ds/seg/)。现在线段树上有恰好一个节点被标记了。\n\n你可以进行若干次询问，每次询问给定一个区间 $[l,r]$，交互库会在被修改的线段树上进行一次区间查询，你可以得知在被修改的线段树上这个区间对应的所有节点中，是否有节点被标记。\n\n你需要在尽可能少的询问内找到这个节点。具体而言，若最优策略在最坏情况下需要 $Q$ 次询问，则你最多可以使用 $Q$ 次询问。\n\n### 交互流程\n\n你不需要，也不应该实现主函数，你只需要实现如下函数：\n\n```cpp\nstd::pair<int, int> solve(int k);\n```\n\n该函数需要在得到答案后返回一个数对 $(x,y)$，表示被标记的线段树节点所对应的区间为 $[x,y]$。\n\n你可以调用交互库提供的方法：\n\n```cpp\nint query(int l, int r);\n```\n\n传入的 `l` 和 `r` 代表询问的区间为 $[l,r]$。交互库会返回对应的结果。你需要保证 $1\\le l\\le r\\le n$。具体而言：\n\n- 当没有节点被标记时，交互库返回 $0$；\n- 当有节点被标记时，交互库返回 $1$；\n- 当询问的区间不合法时，交互库会返回 $-1$，此时你需要立即结束这组数据的交互（不是整个测试点），否则可能导致不可预知的错误。\n\n本题无询问次数限制，但过多的询问会导致时间超限，详细信息请看“数据规模与约定”。", "inputFormat": "下面给出样例交互库的输入输出格式：\n\n第一行输入一个整数 $T$，表示数据组数。\n\n对于每组数据，第一行输入三个整数 $k,l,r$ 代表 $n=2^k$，且将对应区间为 $[l,r]$ 的线段树节点修改。\n\n注意样例交互库不会检查输入数据的正确性。", "outputFormat": "对于每组数据，如果你得到的答案正确，输出一个整数表示你使用的交互次数，否则：\n\n- 若你的询问不合法，输出 `Wrong Answer [1]`；\n- 若你返回的区间不正确，输出 `Wrong Answer [2]`。", "hint": "#### 样例 1 解释\n\n下面是一种可能的交互流程：\n\n| 交互库 | 选手程序 | 备注 |\n| :----------: | :----------: | :----------: |\n| 调用 `solve(2)` |  | 开始测试 |\n| 返回 $1$ | 调用 `query(1,1)` | $[1,1]$ 就是答案节点 |\n|  | 返回 $(1,1)$ | 答案正确 |\n| 调用 `solve(2)` |  | 开始下一组数据的评测 |\n| 返回 $1$ | 调用 `query(2,4)` | $[2,4]$ 对应的节点是 $[2,2]$ 和 $[3,4]$，包括了答案节点 |\n| 返回 $0$ | 调用 `query(1,4)` | $[1,4]$ 对应的节点只有 $[1,4]$，不包括答案节点 |\n|  | 返回 $(3,4)$ | 答案正确，评测结束 |\n\n\n### 计分方式\n\n本题首先会受到和传统题相同的限制。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。\n\n如果你找到的节点是错误的，或者你给出的询问不合法，在该测试点将会得到 $0$ 分。\n\n否则，设在一组数据中，答案最坏需要 $x$ 次询问，而你使用了 $y$ 次询问，满分为 $t$，则这组数据的分数是 $t\\times \\min\\left(1,\\mathrm{e}^{-\\frac{y}{x}+1}\\right)$。\n\n每个测试点取所有数据组中得分的最小值，向下保留两位小数。你的得分是所有测试点得分之和。\n\n### 数据规模与约定\n\n对于所有数据，保证 $1\\le k\\le 14$，$1\\le T\\le 300$。\n\n本题共 $14$ 个测试点，对于第 $i$ 个测试点，保证 $k=i$。对于 $1\\le k\\le 4$ 的测试点，满分 $10$ 分。对于 $5\\le k\\le 14$ 的测试点，满分 $6$ 分。\n\n保证在每组数据进行 $2n$ 次询问时，单个测试点内，交互库使用的时间不超过 0.6s，空间不超过 8MiB。\n\n### 下发文件说明\n\n下发文件中有一个可以通过样例的程序示例 `sample.cpp`，以及一个样例交互库 `grader.cpp`。假设你的答案文件为 `answer.cpp`，则可以使用如下命令将其编译成可执行文件 `answer`：\n\n```shell\ng++ grader.cpp answer.cpp -o answer -O2\n```\n\n实际评测时的交互库可能是自适应的，即被修改的节点可能不会在交互一开始时确定。", "locale": "zh-CN"}}}
{"pid": "P9684", "type": "P", "difficulty": 7, "samples": [["6 3", "324429415\n948332136\n224604980\n224604980\n948332136\n324429415"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "多项式", "洛谷原创", "O2优化", "洛谷月赛"], "title": "Hello, Solitude.", "background": "@【数据删除】 : 我【数据删除】了。 || @【数据删除】 : 你投哪个 || @【数据删除】 : 雪乃对美琴（悲）", "description": "有一张很长的桌子，桌子一边摆了 $n+2$ 张椅子，从左到右依次标号为 $0,1,\\dots,n+1$，任意两张相邻的椅子的距离相同。\n\n初始 $0$ 号和 $n+1$ 号椅子上各坐着一个人。然后有 $m$ 个人依次按照如下的规则入座：\n\n- 先均匀随机选择一个空着的座位。\n- 若移动到相邻的座位，能使其到相邻的人的最小距离增大，则移动到相邻座位。可以证明上述操作进行有限步后一定会停下。\n\n对于 $1\\sim n$ 号的每一张椅子，求出其上面有人坐的概率。", "inputFormat": "第一行输入两个整数 $n,m$。", "outputFormat": "输出 $n$ 行，每行一个整数，第 $i$ 行的整数代表第 $i$ 张椅子上有人坐的概率对 $998\\,244\\,353$ 取模的结果。", "hint": "#### 样例 1 解释\n\n下面是一种可能的落座方法：\n\n0. 初始 $1\\sim n$ 都没有人落座。\n1. 选定 $x=2$，到最近的人（位于座位 $0$）距离为 $2$；\n   1. 向右移动到 $3$ 号椅子后，到最近的人的距离增大至 $3$，所以 $x\\gets x+1$；\n   2. 再向右移动到 $4$ 的话，到最近的人（位于座位 $6$）的距离依旧为 $3$，所以在 $3$ 号椅子落座。\n2. 选定 $x=6$，到最近的人（位于座位 $7$）距离为 $1$；\n   1. 向左移动到 $5$ 号椅子后，到最近的人的距离增大至 $2$，所以 $x\\gets x-1$；\n   2. 再向左/右移动话，到最近的人的距离均会减小，所以在 $5$ 号椅子落座。\n3. 选定 $x=4$，由于无法左右移动，所以直接在 $4$ 号椅子落座。\n\n最终，$3,4,5$ 号椅子上有人坐。\n\n### 数据规模与约定\n\n对于所有数据，$1\\le n\\le 5\\times 10^5$，$0\\le m\\le n$。\n\n### 子任务\n\n| # | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| 0 | 样例 | 0 |\n| 1 | $n\\le20$ | 9 |\n| 2 | $n\\le100$ | 10 |\n| 3 | $n\\le500$ | 12 |\n| 4 | $n\\le2000$ | 11 |\n| 5 | $n\\le5000$ | 12 |\n| 6 | $\\exists k\\in \\mathbb{N}$ 使得 $n=2^k-1$ | 13 |\n| 7 | $n\\le 10^5$ | 15 |\n| 8 | - | 18 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Hello, Solitude.", "background": "@【数据删除】 : 我【数据删除】了。 || @【数据删除】 : 你投哪个 || @【数据删除】 : 雪乃对美琴（悲）", "description": "有一张很长的桌子，桌子一边摆了 $n+2$ 张椅子，从左到右依次标号为 $0,1,\\dots,n+1$，任意两张相邻的椅子的距离相同。\n\n初始 $0$ 号和 $n+1$ 号椅子上各坐着一个人。然后有 $m$ 个人依次按照如下的规则入座：\n\n- 先均匀随机选择一个空着的座位。\n- 若移动到相邻的座位，能使其到相邻的人的最小距离增大，则移动到相邻座位。可以证明上述操作进行有限步后一定会停下。\n\n对于 $1\\sim n$ 号的每一张椅子，求出其上面有人坐的概率。", "inputFormat": "第一行输入两个整数 $n,m$。", "outputFormat": "输出 $n$ 行，每行一个整数，第 $i$ 行的整数代表第 $i$ 张椅子上有人坐的概率对 $998\\,244\\,353$ 取模的结果。", "hint": "#### 样例 1 解释\n\n下面是一种可能的落座方法：\n\n0. 初始 $1\\sim n$ 都没有人落座。\n1. 选定 $x=2$，到最近的人（位于座位 $0$）距离为 $2$；\n   1. 向右移动到 $3$ 号椅子后，到最近的人的距离增大至 $3$，所以 $x\\gets x+1$；\n   2. 再向右移动到 $4$ 的话，到最近的人（位于座位 $6$）的距离依旧为 $3$，所以在 $3$ 号椅子落座。\n2. 选定 $x=6$，到最近的人（位于座位 $7$）距离为 $1$；\n   1. 向左移动到 $5$ 号椅子后，到最近的人的距离增大至 $2$，所以 $x\\gets x-1$；\n   2. 再向左/右移动话，到最近的人的距离均会减小，所以在 $5$ 号椅子落座。\n3. 选定 $x=4$，由于无法左右移动，所以直接在 $4$ 号椅子落座。\n\n最终，$3,4,5$ 号椅子上有人坐。\n\n### 数据规模与约定\n\n对于所有数据，$1\\le n\\le 5\\times 10^5$，$0\\le m\\le n$。\n\n### 子任务\n\n| # | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| 0 | 样例 | 0 |\n| 1 | $n\\le20$ | 9 |\n| 2 | $n\\le100$ | 10 |\n| 3 | $n\\le500$ | 12 |\n| 4 | $n\\le2000$ | 11 |\n| 5 | $n\\le5000$ | 12 |\n| 6 | $\\exists k\\in \\mathbb{N}$ 使得 $n=2^k-1$ | 13 |\n| 7 | $n\\le 10^5$ | 15 |\n| 8 | - | 18 |", "locale": "zh-CN"}}}
{"pid": "P9685", "type": "P", "difficulty": 7, "samples": [["3\n5 2 1\n3 0 1\n-2 2 2\n1 -3 3\n-2 -1 4\n0 0 5\n2\n5\n5 4 2\n3 0 1\n-2 2 2\n1 -3 3\n-2 -1 4\n0 0 5\n2 3\n2 4\n5 1\n3 5\n5 6 3\n3 0 1\n-2 2 2\n1 -3 3\n-2 -1 4\n0 0 5\n3 5 4\n2 5 3\n4 2 1\n2 4 3\n3 1 2\n3 1 4", "10\n0110\n100101"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["计算几何", "洛谷原创", "O2优化", "洛谷月赛"], "title": "三色", "background": "我的心脏还在跳动着啊。", "description": "给定 $n$ 个三元组 $(a_i,b_i,c_i)$。$q$ 次询问，每次给定一个集合 $S$，查询是否存在实数三元组 $(p,q,r)$ 满足：对于所有满足 $pa_i+qb_i+r>0$ 的 $i$，其 $c_i$ 构成的集合恰好为 $S$。", "inputFormat": "第一行输入一个整数 $T$，代表数据组数。\n\n对于每组数据，第一行输入三个数 $n,q,k$，其中 $k=|S|$。\n\n接下来 $n$ 行，每行输入三个整数 $a_i,b_i,c_i$。\n\n接下来 $q$ 行，第 $i$ 行输入 $k$ 个整数 $s_{i,1},s_{i,2},\\dots,s_{i,k}$，代表第 $i$ 组询问中 $S$ 的元素。保证元素不重复。", "outputFormat": "对于每组数据，输出一行一个长为 $q$ 的字符串 $R$，对于第 $i$ 组询问，若答案为存在，则 $R_i$ 为 $\\tt 1$，否则为 $\\tt 0$。", "hint": "### 数据规模与约定\n\n对于所有数据，$1\\le n,\\sum n\\le 10^5$，$1\\le q,\\sum q \\le 3\\times 10^5$，$1\\le k\\le 3$，$1\\le c_i,s_{i,j}\\le n$，$|a_i|,|b_i|\\le 10^9$。\n\n对于任意 $i\\neq j$，保证 $(a_i,b_i)\\neq (a_j,b_j)$，且不存在 $(p,q)$ 和三个不同的下标 $i,j,k$ 满足 $pa_i+qb_i=pa_j+qb_j=pa_k+qb_k$。\n\n### 子任务\n\n| # | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| 0 | 样例 | 0 |\n| 1 | $n\\le 3$ | 2 |\n| 2 | $k=1$ | 11 |\n| 3 | $\\sum n^2\\le 10^6$ | 23 |\n| 4 | $k=2$ | 29 |\n| 5 | $k=3$ | 35 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "三色", "background": "我的心脏还在跳动着啊。", "description": "给定 $n$ 个三元组 $(a_i,b_i,c_i)$。$q$ 次询问，每次给定一个集合 $S$，查询是否存在实数三元组 $(p,q,r)$ 满足：对于所有满足 $pa_i+qb_i+r>0$ 的 $i$，其 $c_i$ 构成的集合恰好为 $S$。", "inputFormat": "第一行输入一个整数 $T$，代表数据组数。\n\n对于每组数据，第一行输入三个数 $n,q,k$，其中 $k=|S|$。\n\n接下来 $n$ 行，每行输入三个整数 $a_i,b_i,c_i$。\n\n接下来 $q$ 行，第 $i$ 行输入 $k$ 个整数 $s_{i,1},s_{i,2},\\dots,s_{i,k}$，代表第 $i$ 组询问中 $S$ 的元素。保证元素不重复。", "outputFormat": "对于每组数据，输出一行一个长为 $q$ 的字符串 $R$，对于第 $i$ 组询问，若答案为存在，则 $R_i$ 为 $\\tt 1$，否则为 $\\tt 0$。", "hint": "### 数据规模与约定\n\n对于所有数据，$1\\le n,\\sum n\\le 10^5$，$1\\le q,\\sum q \\le 3\\times 10^5$，$1\\le k\\le 3$，$1\\le c_i,s_{i,j}\\le n$，$|a_i|,|b_i|\\le 10^9$。\n\n对于任意 $i\\neq j$，保证 $(a_i,b_i)\\neq (a_j,b_j)$，且不存在 $(p,q)$ 和三个不同的下标 $i,j,k$ 满足 $pa_i+qb_i=pa_j+qb_j=pa_k+qb_k$。\n\n### 子任务\n\n| # | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| 0 | 样例 | 0 |\n| 1 | $n\\le 3$ | 2 |\n| 2 | $k=1$ | 11 |\n| 3 | $\\sum n^2\\le 10^6$ | 23 |\n| 4 | $k=2$ | 29 |\n| 5 | $k=3$ | 35 |", "locale": "zh-CN"}}}
{"pid": "P9686", "type": "P", "difficulty": 1, "samples": [["5\nAC\nWA\nAC\nTLE\nMLE", "2 4 5"], ["5\nAC\nAC\nAC\nMLE\nTLE", "4 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "O2优化", "洛谷月赛"], "title": "Judg.", "background": "", "description": "小 M 正在兴致勃勃地敲打着代码，他突然发现提交代码的评测机无响应了。\n\n你查看了后台数据，请你根据这些已有数据判断他没有通过的测试点有哪些。\n\n已知评测结果与测试点是否通过有如下关系：\n\n|评测结果|测试点是否通过|\n| :-----------: | :-----------: |\n| $\\texttt{AC}$ | 是 |\n| $\\texttt{WA}$ | 否 |\n| $\\texttt{TLE}$ | 否 |\n| $\\texttt{MLE}$ | 否 |\n", "inputFormat": "第一行输入一个正整数 $n$，表示评测数据的个数。\n\n第 $2 \\sim n+1$ 行，每行输入一个字符串，依次表示测试点 $1\\sim n$ 的评测结果，数据保证这些字符串一定为 $\\{\\texttt{AC},\\texttt{WA},\\texttt{TLE},\\texttt{MLE}\\}$ 中的一个。", "outputFormat": "输出一行 $m$ 个正整数，其中第 $i$ 个数字 $a_i$ 表示第 $a_i$ 个测试点没有通过。\n\n特别地，你需要保证这 $m$ 个数字递增。", "hint": "#### 【数据范围】\n\n对于所有测试数据，满足 $1 \\le n \\le 10^5$，输入的字符串一定在 $\\{\\texttt{AC},\\texttt{WA},\\texttt{TLE},\\texttt{MLE}\\}$ 之中。\n\n**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\\text{Subtask}$。**\n\n各测试点的附加限制如下表所示。\n\n|测试点 |$n \\le$  |\n| :-----------: | :-----------: |\n| $1 \\sim 5$ | $10$ |\n| $6 \\sim 12$ | $2 \\times 10^3$ |\n| $13 \\sim 20$ | $10^5$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Judg.", "background": "", "description": "小 M 正在兴致勃勃地敲打着代码，他突然发现提交代码的评测机无响应了。\n\n你查看了后台数据，请你根据这些已有数据判断他没有通过的测试点有哪些。\n\n已知评测结果与测试点是否通过有如下关系：\n\n|评测结果|测试点是否通过|\n| :-----------: | :-----------: |\n| $\\texttt{AC}$ | 是 |\n| $\\texttt{WA}$ | 否 |\n| $\\texttt{TLE}$ | 否 |\n| $\\texttt{MLE}$ | 否 |\n", "inputFormat": "第一行输入一个正整数 $n$，表示评测数据的个数。\n\n第 $2 \\sim n+1$ 行，每行输入一个字符串，依次表示测试点 $1\\sim n$ 的评测结果，数据保证这些字符串一定为 $\\{\\texttt{AC},\\texttt{WA},\\texttt{TLE},\\texttt{MLE}\\}$ 中的一个。", "outputFormat": "输出一行 $m$ 个正整数，其中第 $i$ 个数字 $a_i$ 表示第 $a_i$ 个测试点没有通过。\n\n特别地，你需要保证这 $m$ 个数字递增。", "hint": "#### 【数据范围】\n\n对于所有测试数据，满足 $1 \\le n \\le 10^5$，输入的字符串一定在 $\\{\\texttt{AC},\\texttt{WA},\\texttt{TLE},\\texttt{MLE}\\}$ 之中。\n\n**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\\text{Subtask}$。**\n\n各测试点的附加限制如下表所示。\n\n|测试点 |$n \\le$  |\n| :-----------: | :-----------: |\n| $1 \\sim 5$ | $10$ |\n| $6 \\sim 12$ | $2 \\times 10^3$ |\n| $13 \\sim 20$ | $10^5$ |\n", "locale": "zh-CN"}}}
{"pid": "P9687", "type": "P", "difficulty": 2, "samples": [["5\n5 1\n3 1\n5 3\n5 4\n5 5", "00101\n101\n-1\n-1\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "洛谷原创", "O2优化", "构造", "洛谷月赛"], "title": "Maps.", "background": "", "description": "小 Y 希望得到一幅地图，这份地图有些与众不同。\n\n这份地图是一幅长为 $n$ 个单位，宽为一个单位的网格图，每个网格必须被涂鸦成白色（$0$）或者黑色（$1$）。\n\n你希望满足小 Y 的愿望送给他一幅这样的地图，但是这时小 Y 又提出了两点要求：\n\n- 对于每个不在网格图两端的白色格子，恰好有 $p$ 个满足它的左右两个格子都被涂鸦成黑色。\n- 在满足上述所有条件的情况下，这幅地图从左到右的字符构成的字符串的字典序最小。\n\n你心想，这些要求也是小菜一碟，于是开始了你的创作。", "inputFormat": "本题有多组数据。\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据：\n\n输入共一行两个整数 $n,p$，表示你需要构造的地图的长度和小 Y 对你的要求。\n\n", "outputFormat": "对于每组数据：输出一行一个长度为 $n$ 的 01 字符串，表示你构造的地图；如果无法找到任何一幅地图满足小 Y 的要求，输出 $-1$。", "hint": "#### 【样例解释 #1】\n\n对于第一组数据：只有位于第 $4$ 个字符上的数，满足本身是 $0$，不在地图边缘且周围两个都是 $1$，因此符合条件。可以证明这是满足条件的字典序最小的方案。\n\n对于第三组数据：可以证明没有任何一个解满足长度为 $5$ 且有 $3$ 个数本身是 $0$，不在地图边缘且周围两个字符都是 $1$。\n\n#### 【数据范围】\n\n对于所有测试数据，满足 $1 \\le T \\le 100$，$1 \\le n,p \\le 10^5$。\n\n**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\\text{Subtask}$。**\n\n各测试点的附加限制如下表所示。\n\n| 测试点 | $n,p \\le$ |\n| :-----------: | :-----------: |\n| $1 \\sim 3$ | $10$ |\n| $4 \\sim 5$ | $10^3$ |\n| $6\\sim 10$ | $10^5$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Maps.", "background": "", "description": "小 Y 希望得到一幅地图，这份地图有些与众不同。\n\n这份地图是一幅长为 $n$ 个单位，宽为一个单位的网格图，每个网格必须被涂鸦成白色（$0$）或者黑色（$1$）。\n\n你希望满足小 Y 的愿望送给他一幅这样的地图，但是这时小 Y 又提出了两点要求：\n\n- 对于每个不在网格图两端的白色格子，恰好有 $p$ 个满足它的左右两个格子都被涂鸦成黑色。\n- 在满足上述所有条件的情况下，这幅地图从左到右的字符构成的字符串的字典序最小。\n\n你心想，这些要求也是小菜一碟，于是开始了你的创作。", "inputFormat": "本题有多组数据。\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据：\n\n输入共一行两个整数 $n,p$，表示你需要构造的地图的长度和小 Y 对你的要求。\n\n", "outputFormat": "对于每组数据：输出一行一个长度为 $n$ 的 01 字符串，表示你构造的地图；如果无法找到任何一幅地图满足小 Y 的要求，输出 $-1$。", "hint": "#### 【样例解释 #1】\n\n对于第一组数据：只有位于第 $4$ 个字符上的数，满足本身是 $0$，不在地图边缘且周围两个都是 $1$，因此符合条件。可以证明这是满足条件的字典序最小的方案。\n\n对于第三组数据：可以证明没有任何一个解满足长度为 $5$ 且有 $3$ 个数本身是 $0$，不在地图边缘且周围两个字符都是 $1$。\n\n#### 【数据范围】\n\n对于所有测试数据，满足 $1 \\le T \\le 100$，$1 \\le n,p \\le 10^5$。\n\n**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\\text{Subtask}$。**\n\n各测试点的附加限制如下表所示。\n\n| 测试点 | $n,p \\le$ |\n| :-----------: | :-----------: |\n| $1 \\sim 3$ | $10$ |\n| $4 \\sim 5$ | $10^3$ |\n| $6\\sim 10$ | $10^5$ |", "locale": "zh-CN"}}}
{"pid": "P9688", "type": "P", "difficulty": 3, "samples": [["5 2\n1 2 1 3 2\n5 3 1 100 100", "6"], ["10 3\n1 3 4 2 9 3 4 2 5 1\n1 5 2 3 9 8 1 2 3 10", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "洛谷原创", "O2优化", "背包 DP", "洛谷月赛"], "title": "Colo.", "background": "", "description": "小 F 和小 Y 经常在一起玩耍，因为小 F 是一个画家，他喜欢在一个长度为 $n$，宽度为 $1$ 的网格图上画画，从左往右第 $i$ 个方格被涂成了一种颜色 $a_i$。\n\n你觉得他的随意涂鸦太难看了，想要保留恰好 $k$ 种颜色（**你不能保留没在网格图上出现的颜色**），使得网格图上没被涂成任何一种你喜欢的颜色的网格都被剪掉，最后会剩下一些网格，你希望这些网格从左到右颜色的编号是单调不下降的。\n\n此外，小 Y 使用的第 $i$ 种颜色有一个价值 $b_i$，小 Y 看到了你裁剪后的网格图很是高兴，于是决定付给你你选择的颜色的价值总和。\n\n你需要求出你能够获得的最大的价值是多少。", "inputFormat": "第一行两个整数 $n,k$，表示小 Y 画画的网格图的大小和你需要保留颜色的种类数。   \n第二行 $n$ 个整数 $a_i$，表示小 Y 画出来的网格图从左往右第 $i$ 个格子的颜色。  \n第三行 $n$ 个整数 $b_i$，表示第 $i$ 种颜色的价值。", "outputFormat": "一行一个整数，表示你能够获得的最大价值；特别地，如果无法找到选择颜色的方法满足要求，输出 $-1$。", "hint": "#### 【样例解释 #1】\n\n对于第一组样例，我们可以选择 $1$ 号和 $3$ 号颜色保留，剩下的网格图即为 $[1,1,3]$，满足单调不下降这一个限制，获得的价值即为 $b_1+b_3=5+1=6$，可以证明这是最优的办法。\n\n#### 【数据范围】\n\n对于所有测试数据，满足 $1 \\le n \\le 500$，$1 \\le k \\le 500$，$1 \\le a_i \\le n$，$1 \\le b_i \\le 10^9$。\n\n**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\\text{Subtask}$。**\n\n各测试点的附加限制如下表所示。\n\n| 测试点 | $n,k \\le $ | 特殊性质 |\n| :-----------: | :-----------: | :-----------: |\n| $1 \\sim 3$ | $10$ | 无 |\n| $4 \\sim 5$ | $100$ | 无 |\n| $6 \\sim 10$ | $500$ | 不同的颜色不超过 $10$ 种 |\n| $11 \\sim 15$ | $500$ | 每种颜色出现的次数不超过 $2$ 次 |\n| $16 \\sim 20$ | $500$ | 无 |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Colo.", "background": "", "description": "小 F 和小 Y 经常在一起玩耍，因为小 F 是一个画家，他喜欢在一个长度为 $n$，宽度为 $1$ 的网格图上画画，从左往右第 $i$ 个方格被涂成了一种颜色 $a_i$。\n\n你觉得他的随意涂鸦太难看了，想要保留恰好 $k$ 种颜色（**你不能保留没在网格图上出现的颜色**），使得网格图上没被涂成任何一种你喜欢的颜色的网格都被剪掉，最后会剩下一些网格，你希望这些网格从左到右颜色的编号是单调不下降的。\n\n此外，小 Y 使用的第 $i$ 种颜色有一个价值 $b_i$，小 Y 看到了你裁剪后的网格图很是高兴，于是决定付给你你选择的颜色的价值总和。\n\n你需要求出你能够获得的最大的价值是多少。", "inputFormat": "第一行两个整数 $n,k$，表示小 Y 画画的网格图的大小和你需要保留颜色的种类数。   \n第二行 $n$ 个整数 $a_i$，表示小 Y 画出来的网格图从左往右第 $i$ 个格子的颜色。  \n第三行 $n$ 个整数 $b_i$，表示第 $i$ 种颜色的价值。", "outputFormat": "一行一个整数，表示你能够获得的最大价值；特别地，如果无法找到选择颜色的方法满足要求，输出 $-1$。", "hint": "#### 【样例解释 #1】\n\n对于第一组样例，我们可以选择 $1$ 号和 $3$ 号颜色保留，剩下的网格图即为 $[1,1,3]$，满足单调不下降这一个限制，获得的价值即为 $b_1+b_3=5+1=6$，可以证明这是最优的办法。\n\n#### 【数据范围】\n\n对于所有测试数据，满足 $1 \\le n \\le 500$，$1 \\le k \\le 500$，$1 \\le a_i \\le n$，$1 \\le b_i \\le 10^9$。\n\n**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\\text{Subtask}$。**\n\n各测试点的附加限制如下表所示。\n\n| 测试点 | $n,k \\le $ | 特殊性质 |\n| :-----------: | :-----------: | :-----------: |\n| $1 \\sim 3$ | $10$ | 无 |\n| $4 \\sim 5$ | $100$ | 无 |\n| $6 \\sim 10$ | $500$ | 不同的颜色不超过 $10$ 种 |\n| $11 \\sim 15$ | $500$ | 每种颜色出现的次数不超过 $2$ 次 |\n| $16 \\sim 20$ | $500$ | 无 |\n", "locale": "zh-CN"}}}
{"pid": "P9689", "type": "P", "difficulty": 4, "samples": [["6\n3 0\n3 1\n3 2\n3 3\n3 4\n3 5", "5\n3\n3\n1\n1\n-1"], ["10\n5 5\n10 0\n999 155\n135 92\n1000232 234255\n10293845 1239485\n123948 1239454\n12394 2131094\n1000000000 98765432\n1000000000 999999999", "3\n40\n52377\n1161\n27487764480\n5864061665280\n-1\n-1\n19215358392218419\n4969489234738635"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "洛谷原创", "O2优化", "分治", "洛谷月赛"], "title": "Bina.", "background": "", "description": "小 J 家门前有两棵树，一棵是二叉树，一棵是三叉树。\n\n你被小 J 叫来修剪他的二叉树，使得他的二叉树的“美丽值”最大，所谓一棵树的美丽值 $=$ 这棵树的点的编号之和 $\\div$ 这棵树的深度（结果向下取整）。\n\n这棵二叉树有一个构建参数 $n$，构建方式如下：\n\n```cpp\nvoid build(int s,int t,int p){\n  if(s==t) return ;\n  build(s,(s+t)/2,2*p);\n  build((s+t)/2+1,t,2*p+1);\n  add_edge(p,2*p),add_edge(p,2*p+1);\n}\n\nint main(){\n  build(1,n,1);\n  return 0;\n}\n```\n\n其中 `build(s,t,p)` 函数参数中的 $p$ 是当前点的编号，`add_edge(x,y)` 函数是指将编号为 $x$ 的点向编号为 $y$ 的点连接一条有向边。\n\n容易发现这棵树的根节点是 $1$，并且我们规定节点的深度为节点到根节点路径上经过的点的个数（包括自己和根节点），这棵树的深度即为所有节点深度的最大值。\n\n对于 $n=3$ 的情况，最后构建出来的结果如下，这棵树的深度为 $3$，你需要选择一个深度 $k$ 把深度大于 $k$ 的点都剪掉，但是 $k$ 必须**大于等于** $1$ 且**小于等于**这棵树的深度。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ueggbyn8.png)\n\n小 J 还给了你一个要求，你剪去的节点个数一定得大于等于 $m$ 他才会高兴，你需要保证让他高兴的同时树的“美丽值”最大。\n\n现在小 J 给了你构建树的参数 $n$ 和至少剪的节点个数 $m$，要你求出来他的树在你修剪后最大的美丽值是多少，如果无论如何你也不可能让小 J 高兴，输出 $-1$。", "inputFormat": "本题有多组数据。\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据：\n\n输入共一行两个整数 $n,m$，表示构建二叉树的参数和你至少剪掉的节点个数。", "outputFormat": "对于每组数据：输出一行一个整数，表示能够获得的最大的“美丽值”，如果无法让小 J 高兴，输出 $-1$。", "hint": "#### 【样例解释 #1】\n\n对于第一组样例，$n$ 都等于 $3$，构建出来的树同题面所示。\n\n如果我们选择把深度大于 $1$ 的节点全部剪掉，那么我们剪掉了 $2,3,4,5$ 共 $4$ 个节点，美丽值为 $1$。\n\n如果我们选择把深度大于 $2$ 的节点全部剪掉，那么我们剪掉了 $4,5$ 共 $2$ 个节点，美丽值为 $\\lfloor \\dfrac{1+2+3}{2}\\rfloor = 3$。\n\n如果我们选择把深度大于 $3$ 的节点全部剪掉，那么我们没有剪掉任何节点，美丽值为 $\\lfloor \\dfrac{1+2+3+4+5}{3}\\rfloor = 5$。\n\n所以对于 $m=0$ 的情况，答案为 $5$；对于 $1 \\le m \\le 2$ 的情况，答案为 $3$；对于 $3 \\le m \\le 4$ 的情况，答案为 $1$；其它情况，无解输出 $-1$。\n\n#### 【数据范围】\n\n对于所有测试数据，满足 $1 \\le T \\le 10^5$，$1 \\le n \\le 10^9$，$0 \\le m \\le 2 \\times 10^9$。\n\n**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\\text{Subtask}$。**\n\n各测试点的附加限制如下表所示。\n\n| 测试点 | $n \\le$ | $m \\le$ | $T \\le$ | 特殊限制 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $1 \\sim 2$ | $10^3$ | $10^5$ | $10^3$ | 无 |\n| $3 \\sim 4$ | $10^6$ | $2 \\times 10^6$ | $10^5$ | 无 |\n| $5$ | $10^9$ | $1$ | $10^5$ | 无 |\n| $6$ | $10^9$ | $2$ | $10^5$ | 无 |\n| $7 \\sim 8$ | $10^9$ | $3$ | $10^5$ | 无 |\n| $9 \\sim 10$ | $10^9$ | $2 \\times 10^9$ | $10^5$ | $m \\ge 1$ |\n| $11 \\sim 12$ | $10^9$ | $10^3$ | $10^5$ | 无 |\n| $13 \\sim 16$ | $10^9$ | $2 \\times 10^9$ | $10$ | 无 |\n| $17 \\sim 20$ | $10^9$ | $2 \\times 10^9$ | $10^5$ | 所有 $n$ 均相同 |\n| $21 \\sim 25$ | $10^9$ | $2 \\times 10^9$ | $10^5$ | 无 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Bina.", "background": "", "description": "小 J 家门前有两棵树，一棵是二叉树，一棵是三叉树。\n\n你被小 J 叫来修剪他的二叉树，使得他的二叉树的“美丽值”最大，所谓一棵树的美丽值 $=$ 这棵树的点的编号之和 $\\div$ 这棵树的深度（结果向下取整）。\n\n这棵二叉树有一个构建参数 $n$，构建方式如下：\n\n```cpp\nvoid build(int s,int t,int p){\n  if(s==t) return ;\n  build(s,(s+t)/2,2*p);\n  build((s+t)/2+1,t,2*p+1);\n  add_edge(p,2*p),add_edge(p,2*p+1);\n}\n\nint main(){\n  build(1,n,1);\n  return 0;\n}\n```\n\n其中 `build(s,t,p)` 函数参数中的 $p$ 是当前点的编号，`add_edge(x,y)` 函数是指将编号为 $x$ 的点向编号为 $y$ 的点连接一条有向边。\n\n容易发现这棵树的根节点是 $1$，并且我们规定节点的深度为节点到根节点路径上经过的点的个数（包括自己和根节点），这棵树的深度即为所有节点深度的最大值。\n\n对于 $n=3$ 的情况，最后构建出来的结果如下，这棵树的深度为 $3$，你需要选择一个深度 $k$ 把深度大于 $k$ 的点都剪掉，但是 $k$ 必须**大于等于** $1$ 且**小于等于**这棵树的深度。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ueggbyn8.png)\n\n小 J 还给了你一个要求，你剪去的节点个数一定得大于等于 $m$ 他才会高兴，你需要保证让他高兴的同时树的“美丽值”最大。\n\n现在小 J 给了你构建树的参数 $n$ 和至少剪的节点个数 $m$，要你求出来他的树在你修剪后最大的美丽值是多少，如果无论如何你也不可能让小 J 高兴，输出 $-1$。", "inputFormat": "本题有多组数据。\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据：\n\n输入共一行两个整数 $n,m$，表示构建二叉树的参数和你至少剪掉的节点个数。", "outputFormat": "对于每组数据：输出一行一个整数，表示能够获得的最大的“美丽值”，如果无法让小 J 高兴，输出 $-1$。", "hint": "#### 【样例解释 #1】\n\n对于第一组样例，$n$ 都等于 $3$，构建出来的树同题面所示。\n\n如果我们选择把深度大于 $1$ 的节点全部剪掉，那么我们剪掉了 $2,3,4,5$ 共 $4$ 个节点，美丽值为 $1$。\n\n如果我们选择把深度大于 $2$ 的节点全部剪掉，那么我们剪掉了 $4,5$ 共 $2$ 个节点，美丽值为 $\\lfloor \\dfrac{1+2+3}{2}\\rfloor = 3$。\n\n如果我们选择把深度大于 $3$ 的节点全部剪掉，那么我们没有剪掉任何节点，美丽值为 $\\lfloor \\dfrac{1+2+3+4+5}{3}\\rfloor = 5$。\n\n所以对于 $m=0$ 的情况，答案为 $5$；对于 $1 \\le m \\le 2$ 的情况，答案为 $3$；对于 $3 \\le m \\le 4$ 的情况，答案为 $1$；其它情况，无解输出 $-1$。\n\n#### 【数据范围】\n\n对于所有测试数据，满足 $1 \\le T \\le 10^5$，$1 \\le n \\le 10^9$，$0 \\le m \\le 2 \\times 10^9$。\n\n**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\\text{Subtask}$。**\n\n各测试点的附加限制如下表所示。\n\n| 测试点 | $n \\le$ | $m \\le$ | $T \\le$ | 特殊限制 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $1 \\sim 2$ | $10^3$ | $10^5$ | $10^3$ | 无 |\n| $3 \\sim 4$ | $10^6$ | $2 \\times 10^6$ | $10^5$ | 无 |\n| $5$ | $10^9$ | $1$ | $10^5$ | 无 |\n| $6$ | $10^9$ | $2$ | $10^5$ | 无 |\n| $7 \\sim 8$ | $10^9$ | $3$ | $10^5$ | 无 |\n| $9 \\sim 10$ | $10^9$ | $2 \\times 10^9$ | $10^5$ | $m \\ge 1$ |\n| $11 \\sim 12$ | $10^9$ | $10^3$ | $10^5$ | 无 |\n| $13 \\sim 16$ | $10^9$ | $2 \\times 10^9$ | $10$ | 无 |\n| $17 \\sim 20$ | $10^9$ | $2 \\times 10^9$ | $10^5$ | 所有 $n$ 均相同 |\n| $21 \\sim 25$ | $10^9$ | $2 \\times 10^9$ | $10^5$ | 无 |", "locale": "zh-CN"}}}
{"pid": "P9690", "type": "P", "difficulty": 1, "samples": [["4\n2003\n1 2020\n2023\n2003\n1 2020\n2003\n2345\n0\n3456\n3000\n4 3001 3003 3004 3008\n3007", "20\n1\n1112\n5"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "广东", "O2优化", "省赛/邀请赛"], "title": "[GDCPC 2023] Programming Contest", "background": "", "description": "Guangdong Province is one of the earliest province in China which holds its own provincial collegiate programming contest. Sun Yat-sen University hosted the first Guangdong Collegiate Programming Contest in year $2003$. After that, other universities in Guangdong, such as South China Agricultural University, South China University of Technology and South China Normal University, also hosted the contest. The contest is held once a year except for year $2020$ due to the epidemic. In year $2023$, Shenzhen Technology University will host the twentieth Guangdong Collegiate Programming Contest. We are looking forward to seeing participants' outstanding performance!\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nvct1s9o.png)\n\nIn another world, a programming contest has been held once a year since year $y_1$, except for the $n$ years $s_1, s_2, \\cdots, s_n$ when it was not held due to special reasons.\n\nCalculate the number of times the competition has been held up to year $y_2$ (inclusive).", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 20$) indicating the number of test cases. For each test case:\n\nThe first line contains an integer $y_1$ ($1970 \\le y_1 \\le 9999$) indicating the first year when the contest was held.\n\nThe second line first contains an integer $n$ ($0 \\le n \\le 100$) indicating the number of years the contest was not held. Then $n$ integers $s_1, s_2, \\cdots, s_n$ ($y_1 < s_i \\le 9999$) follow, indicating the years when the contest was not held. These years are given in increasing order and have no duplicates.\n\nThe third line contains an integer $y_2$ ($y_1 \\le y_2 \\le 9999$). It's guaranteed that $y_2$ is not a year when the contest was not held.", "outputFormat": "For each test case output one line containing one integer, indicating the number of times the competition has been held up to year $y_2$ (inclusive).\n", "hint": "For the first sample test case, as described in the problem description, the answer is $20$.\n\nFor the second sample test case, because year $2003$ is the $1$-st year when the contest was held, the answer is $1$.\n\nFor the third sample test case, because the contest was held every year, the answer is $3456 - 2345 + 1 = 1112$.\n\nFor the fourth sample test case, the first $5$ years when the contest was held is $3000$, $3002$, $3005$, $3006$ and $3007$. So the answer is $5$.", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] Programming Contest", "background": "", "description": "Guangdong Province is one of the earliest province in China which holds its own provincial collegiate programming contest. Sun Yat-sen University hosted the first Guangdong Collegiate Programming Contest in year $2003$. After that, other universities in Guangdong, such as South China Agricultural University, South China University of Technology and South China Normal University, also hosted the contest. The contest is held once a year except for year $2020$ due to the epidemic. In year $2023$, Shenzhen Technology University will host the twentieth Guangdong Collegiate Programming Contest. We are looking forward to seeing participants' outstanding performance!\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nvct1s9o.png)\n\nIn another world, a programming contest has been held once a year since year $y_1$, except for the $n$ years $s_1, s_2, \\cdots, s_n$ when it was not held due to special reasons.\n\nCalculate the number of times the competition has been held up to year $y_2$ (inclusive).", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 20$) indicating the number of test cases. For each test case:\n\nThe first line contains an integer $y_1$ ($1970 \\le y_1 \\le 9999$) indicating the first year when the contest was held.\n\nThe second line first contains an integer $n$ ($0 \\le n \\le 100$) indicating the number of years the contest was not held. Then $n$ integers $s_1, s_2, \\cdots, s_n$ ($y_1 < s_i \\le 9999$) follow, indicating the years when the contest was not held. These years are given in increasing order and have no duplicates.\n\nThe third line contains an integer $y_2$ ($y_1 \\le y_2 \\le 9999$). It's guaranteed that $y_2$ is not a year when the contest was not held.", "outputFormat": "For each test case output one line containing one integer, indicating the number of times the competition has been held up to year $y_2$ (inclusive).\n", "hint": "For the first sample test case, as described in the problem description, the answer is $20$.\n\nFor the second sample test case, because year $2003$ is the $1$-st year when the contest was held, the answer is $1$.\n\nFor the third sample test case, because the contest was held every year, the answer is $3456 - 2345 + 1 = 1112$.\n\nFor the fourth sample test case, the first $5$ years when the contest was held is $3000$, $3002$, $3005$, $3006$ and $3007$. So the answer is $5$.", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] Programming Contest", "background": "", "description": "广东省是全国较早一批将程序设计竞赛引入省内大学生竞赛体系的省份之一。$2003$ 年，中山大学承办了第一届广东省大学生程序设计竞赛。此后，华南农业大学、华南理工大学、华南师范大学等省内高校也先后承办了此赛事，除 $2020$ 年因疫情停办外，每年一届。$2023$ 年，深圳技术大学将承办第二十届广东省大学生程序设计竞赛，让我们期待选手们出色的表现！\n\n在另一个世界中，某程序设计竞赛自 $y_1$ 年起开始举办。除了 $s_1, s_2, \\cdots, s_n$ 这 $n$ 年由于特殊原因无法举办之外，其他年份每年举办一次。\n\n求 $y_2$ 年是该竞赛的第几次举办。\n\n\n对于第二组样例数据，由于 $2003$ 就是该竞赛第 $1$ 次举办的年份，因此答案为 $1$。\n\n对于第三组样例数据，由于竞赛从未停办，因此答案为 $3456 - 2345 + 1 = 1112$。\n\n对于第四组样例数据，该竞赛前 $5$ 次举办的年份为 $3000$，$3002$，$3005$，$3006$ 与 $3007$。因此答案为 $5$。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$（$1 \\le T \\le 20$）表示测试数据组数。对于每组测试数据：\n\n第一行输入一个整数 $y_1$（$1970 \\le y_1 \\le 9999$），表示该竞赛第一次举办的年份。\n\n第二行首先输入一个整数 $n$（$0 \\le n \\le 100$）表示该竞赛停办的年份数，之后输入 $n$ 个整数 $s_1, s_2, \\cdots, s_n$（$y_1 < s_i \\le 9999$）表示该竞赛的停办年份。停办年份按递增顺序给出，且没有重复的年份。\n\n第三行输入一个整数 $y_2$（$y_1 \\le y_2 \\le 9999$）。保证 $y_2$ 不是停办年份之一。", "outputFormat": "每组数据输出一行一个整数，表示 $y_2$ 年是该竞赛的第几次举办。\n\n**【样例解释】**", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9691", "type": "P", "difficulty": 4, "samples": [["2\n5\n3 2 4 1 100\n3\n1 3\n2 4\n5 5\n5\n7 3 4 2 2\n3\n1 4\n2 3\n4 5", "102\n5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "单调队列", "2023", "广东", "O2优化", "省赛/邀请赛"], "title": "[GDCPC 2023] Base Station Construction", "background": "", "description": "China Mobile Shenzhen Branch was registered in $1999$. Four years later, Guangdong Collegiate Programming Contest was held for the first time. China Mobile Shenzhen Branch, along with Guangdong Collegiate Programming Contest, witnesses the prosperity and development of the computer industry in Guangdong.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/md6qj7fz.png)\n\nDuring the construction of a communication line, it is critical to carefully choose the locations for base stations. The distance from west to east of a city is $n$ kilometers. The engineers have investigated the cost to build a base station at $1, 2, \\cdots, n$ kilometers from west to east, which are $a_1, a_2, \\cdots, a_n$ respectively.\n\nTo ensure communication quality for the residents, the locations of base stations also need to meet $m$ requirements. The $i$-th requirement can be represented as a pair of integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le n$), indicating that there must be at least $1$ base station between $l_i$ kilometers and $r_i$ kilometers (both inclusive) from west to east.\n\nAs the chief engineer, you need to decide the number of base stations to build and their locations, and finally calculate the minimum total cost to satisfy all requirements.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 5 \\times 10^5$) indicating the distance from west to east of the city.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le 10^9$) where $a_i$ indicates the cost to build a base station at $i$ kilometers from west to east.\n\nThe third line contains an integer $m$ ($1 \\le m \\le 5 \\times 10^5$) indicating the number of requirements.\n\nFor the following $m$ lines, the $i$-th line contains two integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le n$) indicating that there must be at least $1$ base station between $l_i$ kilometers and $r_i$ kilometers (both inclusive) from west to east.\n\nIt's guaranteed that neither the sum of $n$ nor the sum of $m$ of all test cases will exceed $5 \\times 10^5$.", "outputFormat": "For each test case output one line containing one integer indicating the minimum total cost to satisfy all requirements.", "hint": "For the first sample test case the optimal solution is to build base stations at $2$ kilometers and $5$ kilometers from west to east. The total cost is $2 + 100 = 102$.\n\nFor the second sample test case the optimal solution is to build base stations at $2$ kilometers and $4$ kilometers from west to east. The total cost is $3 + 2 = 5$.", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] Base Station Construction", "background": "", "description": "China Mobile Shenzhen Branch was registered in $1999$. Four years later, Guangdong Collegiate Programming Contest was held for the first time. China Mobile Shenzhen Branch, along with Guangdong Collegiate Programming Contest, witnesses the prosperity and development of the computer industry in Guangdong.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/md6qj7fz.png)\n\nDuring the construction of a communication line, it is critical to carefully choose the locations for base stations. The distance from west to east of a city is $n$ kilometers. The engineers have investigated the cost to build a base station at $1, 2, \\cdots, n$ kilometers from west to east, which are $a_1, a_2, \\cdots, a_n$ respectively.\n\nTo ensure communication quality for the residents, the locations of base stations also need to meet $m$ requirements. The $i$-th requirement can be represented as a pair of integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le n$), indicating that there must be at least $1$ base station between $l_i$ kilometers and $r_i$ kilometers (both inclusive) from west to east.\n\nAs the chief engineer, you need to decide the number of base stations to build and their locations, and finally calculate the minimum total cost to satisfy all requirements.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 5 \\times 10^5$) indicating the distance from west to east of the city.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le 10^9$) where $a_i$ indicates the cost to build a base station at $i$ kilometers from west to east.\n\nThe third line contains an integer $m$ ($1 \\le m \\le 5 \\times 10^5$) indicating the number of requirements.\n\nFor the following $m$ lines, the $i$-th line contains two integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le n$) indicating that there must be at least $1$ base station between $l_i$ kilometers and $r_i$ kilometers (both inclusive) from west to east.\n\nIt's guaranteed that neither the sum of $n$ nor the sum of $m$ of all test cases will exceed $5 \\times 10^5$.", "outputFormat": "For each test case output one line containing one integer indicating the minimum total cost to satisfy all requirements.", "hint": "For the first sample test case the optimal solution is to build base stations at $2$ kilometers and $5$ kilometers from west to east. The total cost is $2 + 100 = 102$.\n\nFor the second sample test case the optimal solution is to build base stations at $2$ kilometers and $4$ kilometers from west to east. The total cost is $3 + 2 = 5$.", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] Base Station Construction", "background": "", "description": "中国移动通信集团广东有限公司深圳分公司（以下简称``深圳移动``）于 $1999$ 年正式注册。四年后，广东省大学生程序设计竞赛第一次举办。深圳移动与广东省大学生程序设计竞赛一起见证了广东省计算机行业的兴旺与发展。\n\n在建设通信线路的过程中，信号基站的选址是一个非常关键的问题。某城市从西到东的距离为 $n$ 千米，工程师们已经考察了在从西往东 $1, 2, \\cdots, n$ 千米的位置建设基站的成本，分别是 $a_1, a_2, \\cdots, a_n$。\n\n为了保证居民的通信质量，基站的选址还需要满足 $m$ 条需求。第 $i$ 条需求可以用一对整数 $l_i$ 和 $r_i$ 表示（$1 \\le l_i \\le r_i \\le n$），代表从西往东 $l_i$ 千米到 $r_i$ 千米的位置之间（含两端）至少需要建设 $1$ 座基站。\n\n作为总工程师，您需要决定基站的数量与位置，并计算满足所有需求的最小总成本。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数，对于每组测试数据：\n\n第一行输入一个整数 $n$（$1 \\le n \\le 5 \\times 10^5$）表示城市从西到东的距离。\n\n第二行输入 $n$ 个整数 $a_1, a_2, \\cdots, a_n$（$1 \\le a_i \\le 10^9$），其中 $a_i$ 表示在从西往东 $i$ 千米的位置建设基站的成本。\n\n第三行输入一个整数 $m$（$1 \\le m \\le 5 \\times 10^5$）表示需求的数量。\n\n对于接下来 $m$ 行，第 $i$ 行输入两个整数 $l_i$ 和 $r_i$（$1 \\le l_i \\le r_i \\le n$）表示从西往东 $l_i$ 千米到 $r_i$ 千米的位置之间（含两端）至少需要建设 $1$ 座基站。\n\n保证所有数据 $n$ 之和与 $m$ 之和均不超过 $5 \\times 10^5$。", "outputFormat": "每组数据输出一行一个整数，表示满足所有需求的最小总成本。\n\n**【样例解释】**\n\n对于第一组样例数据，最优方案是在从西往东 $2$ 千米和 $5$ 千米的位置建设基站。总成本为 $2 + 100 = 102$。\n\n对于第二组样例数据，最优方案是在从西往东 $2$ 千米和 $4$ 千米的位置建设基站。总成本为 $3 + 2 = 5$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9692", "type": "P", "difficulty": 2, "samples": [["2\n4\n10 2\n30 7\n20 4\n50 1\n2\n1 100\n1 1000", "100\n0"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "广东", "O2优化", "省赛/邀请赛"], "title": "[GDCPC 2023] Trading", "background": "", "description": "Twenty years ago, the northern section of Beijing Road Pedestrian Street in Guangzhou unearthed eleven layers of pavement from the Tang Dynasty to the Republic of China, and the southern section excavated the foundation of Gongbei Building with five layers from the Song Dynasty to the Ming and Qing Dynasties. This proves that Beijing Road has a long history as a commercial pedestrian street since the Song Dynasty. At the same time, the first Guangdong Province Collegiate Programming Contest was also held at Sun Yat-sen University in Guangzhou. Today, twenty years later, Beijing Road Pedestrian Street has become one of Guangzhou's most famous tourist attractions and shopping destinations, and the Guangdong Province Collegiate Programming Contest is also celebrating its twentieth birthday.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qaieoirq.png)\n\nThere are $n$ stores in the pedestrian street which buy and sell the same type of product. The buying and selling price of one such product in the $i$-th store are both $a_i$. To avoid over-trading, the pedestrian street has a regulation, that one can only trade $b_i$ times in the $i$-th store (each buy or each sell both count as a trade) and can only trade one product each time.\n\nYou're going to earn money by buying and selling the products in the pedestrian street. If you have infinite amount of money at the beginning (that is to say, you can't be short of money when buying a product), what's the maximum total profit you can make? More precisely, \\textit{profit} means the total amount of money earned by selling the products, minus the total amount of money spent for buying the products.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$) indicating the number of stores.\n\nFor the following $n$ lines, the $i$-th line contains two integers $a_i$ and $b_i$ ($1 \\le a_i, b_i \\le 10^6$) indicating the price and the maximum number of trades in the $i$-th store.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum total profit.", "hint": "For the first sample test case, the optimal strategy is to buy $2$ products from the $1$-st store, buy $4$ products from the $3$-rd store, sell $5$ products to the $2$-nd store and sell $1$ product to the $4$-th store. The total profit is $30 \\times 5 + 50 \\times 1 - 10 \\times 2 - 20 \\times 4 = 100$.\n\nFor the second sample test case, because all stores have the same price, there is no profit.", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] Trading", "background": "", "description": "Twenty years ago, the northern section of Beijing Road Pedestrian Street in Guangzhou unearthed eleven layers of pavement from the Tang Dynasty to the Republic of China, and the southern section excavated the foundation of Gongbei Building with five layers from the Song Dynasty to the Ming and Qing Dynasties. This proves that Beijing Road has a long history as a commercial pedestrian street since the Song Dynasty. At the same time, the first Guangdong Province Collegiate Programming Contest was also held at Sun Yat-sen University in Guangzhou. Today, twenty years later, Beijing Road Pedestrian Street has become one of Guangzhou's most famous tourist attractions and shopping destinations, and the Guangdong Province Collegiate Programming Contest is also celebrating its twentieth birthday.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qaieoirq.png)\n\nThere are $n$ stores in the pedestrian street which buy and sell the same type of product. The buying and selling price of one such product in the $i$-th store are both $a_i$. To avoid over-trading, the pedestrian street has a regulation, that one can only trade $b_i$ times in the $i$-th store (each buy or each sell both count as a trade) and can only trade one product each time.\n\nYou're going to earn money by buying and selling the products in the pedestrian street. If you have infinite amount of money at the beginning (that is to say, you can't be short of money when buying a product), what's the maximum total profit you can make? More precisely, \\textit{profit} means the total amount of money earned by selling the products, minus the total amount of money spent for buying the products.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$) indicating the number of stores.\n\nFor the following $n$ lines, the $i$-th line contains two integers $a_i$ and $b_i$ ($1 \\le a_i, b_i \\le 10^6$) indicating the price and the maximum number of trades in the $i$-th store.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum total profit.", "hint": "For the first sample test case, the optimal strategy is to buy $2$ products from the $1$-st store, buy $4$ products from the $3$-rd store, sell $5$ products to the $2$-nd store and sell $1$ product to the $4$-th store. The total profit is $30 \\times 5 + 50 \\times 1 - 10 \\times 2 - 20 \\times 4 = 100$.\n\nFor the second sample test case, because all stores have the same price, there is no profit.", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] Trading", "background": "", "description": "二十年前，广州的北京路步行街北段出土了自唐代直到民国时期的十一层路面，南段则发掘出宋代至明清时期共五层的拱北楼建筑基址，佐证了北京路自宋代以来作为商业步行街的悠久历史；同时第一届广东省大学生程序设计竞赛也在位处广州的中山大学举办。二十年后的今天，北京路步行街已成为广州最负盛名的景点和购物胜地之一，而广东省大学生程序设计竞赛也迎来了自己的二十岁生日。\n\n在步行街中，有 $n$ 间商店买卖同一种商品，第 $i$ 间商店一件商品的收购价和出售价均为 $a_i$ 元。为了防止过度交易，步行街有一个规定：您在第 $i$ 间商店最多进行 $b_i$ 次交易（一次买或一次卖均计为一次交易），且每次只能交易一件商品。\n\n您准备通过在步行街中买卖这种商品来赚钱。假如初始时有无限的金钱（也就是说，不会因为钱不够而买不了一件商品），您最多能在步行街中赚到多少总利润？具体来说，``利润``指的是卖出商品获得的金钱总额，减去购买商品花费的金钱总额。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入一个整数 $n$（$1 \\le n \\le 10^5$），表示商店的数量。\n\n对于接下来 $n$ 行，第 $i$ 行输入两个整数 $a_i$ 和 $b_i$（$1 \\le a_i, b_i \\le 10^6$），分别表示第 $i$ 间商店的商品价格，以及该商店可以交易的最大次数。\n\n保证所有数据 $n$ 之和不超过 $10^6$。", "outputFormat": "每组数据输出一行一个整数，表示在步行街中赚到的最大总利润。\n\n**【样例解释】**\n\n对于第一组样例数据，最优方案是在第 $1$ 间商店买入 $2$ 件商品，在第 $3$ 间商店买入 $4$ 件商品，在第 $2$ 间商店卖出 $5$ 件商品，在第 $4$ 间商店卖出 $1$ 件商品。总利润为 $30 \\times 5 + 50 \\times 1 - 10 \\times 2 - 20 \\times 4 = 100$。\n\n对于第二组样例数据，由于所有商店的商品价格都相同，因此无法获得利润。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9693", "type": "P", "difficulty": 3, "samples": [["3\n4 5\n1 100\n100 1\n100 1\n100 1\n2 2\n1 10\n1 10\n2 3\n100 50\n1 1000", "400\n2\n1050"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "广东", "O2优化", "省赛/邀请赛"], "title": "[GDCPC 2023] New Houses", "background": "", "description": "With the construction and development of Guangdong, more and more people choose to come to Guangdong to start a new life. In a recently built community, there will be $n$ people moving into $m$ houses which are arranged in a row. The houses are numbered from $1$ to $m$ (both inclusive). House $u$ and $v$ are neighboring houses, if and only if $|u-v|=1$. We need to assign each person to a house so that no two people will move into the same house. If two people move into a pair of neighboring houses, they will become neighbors of each other.\n\nSome people like to have neighbors while some don't. For the $i$-th person, if he has at least one neighbor, his happiness will be $a_i$; Otherwise if he does not have any neighbor, his happiness will be $b_i$.\n\nAs the planner of this community, you need to maximize the total happiness.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\le 5 \\times 10^5$, $1 \\le m \\le 10^9$, $n \\le m$) indicating the number of people and the number of houses.\n\nFor the following $n$ lines, the $i$-th line contains two integers $a_i$ and $b_i$ ($1 \\le a_i, b_i \\le 10^9$) indicating the happiness of the $i$-th person with and without neighbors.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum total happiness.", "hint": "For the first sample test case, the optimal strategy is to let person $1$ move into house $1$ and let person $2$ to $4$ move into house $3$ to $5$. Thus, person $1$ have no neighbors while person $2$ to $4$ have neighbors. The answer is $100 + 100 + 100 + 100 = 400$. Of course, we can also let person $2$ to $4$ move into house $1$ to $3$ and let person $1$ move into house $5$. This will also give us $400$ total happiness.\n\nFor the second sample test case, as there are only $2$ houses, person $1$ and $2$ have to be neighbors. The answer is $1 + 1 = 2$.\n\nFor the third sample test case, the optimal strategy is to let person $1$ move into house $1$ and let person $2$ move into house $3$. Thus, both of them have no neighbors. The answer is $50 + 1000 = 1050$.", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] New Houses", "background": "", "description": "With the construction and development of Guangdong, more and more people choose to come to Guangdong to start a new life. In a recently built community, there will be $n$ people moving into $m$ houses which are arranged in a row. The houses are numbered from $1$ to $m$ (both inclusive). House $u$ and $v$ are neighboring houses, if and only if $|u-v|=1$. We need to assign each person to a house so that no two people will move into the same house. If two people move into a pair of neighboring houses, they will become neighbors of each other.\n\nSome people like to have neighbors while some don't. For the $i$-th person, if he has at least one neighbor, his happiness will be $a_i$; Otherwise if he does not have any neighbor, his happiness will be $b_i$.\n\nAs the planner of this community, you need to maximize the total happiness.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n \\le 5 \\times 10^5$, $1 \\le m \\le 10^9$, $n \\le m$) indicating the number of people and the number of houses.\n\nFor the following $n$ lines, the $i$-th line contains two integers $a_i$ and $b_i$ ($1 \\le a_i, b_i \\le 10^9$) indicating the happiness of the $i$-th person with and without neighbors.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum total happiness.", "hint": "For the first sample test case, the optimal strategy is to let person $1$ move into house $1$ and let person $2$ to $4$ move into house $3$ to $5$. Thus, person $1$ have no neighbors while person $2$ to $4$ have neighbors. The answer is $100 + 100 + 100 + 100 = 400$. Of course, we can also let person $2$ to $4$ move into house $1$ to $3$ and let person $1$ move into house $5$. This will also give us $400$ total happiness.\n\nFor the second sample test case, as there are only $2$ houses, person $1$ and $2$ have to be neighbors. The answer is $1 + 1 = 2$.\n\nFor the third sample test case, the optimal strategy is to let person $1$ move into house $1$ and let person $2$ move into house $3$. Thus, both of them have no neighbors. The answer is $50 + 1000 = 1050$.", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] New Houses", "background": "", "description": "随着广东的建设与发展，越来越多人选择来到广东开始新生活。在一片新建的小区，有 $n$ 个人要搬进 $m$ 栋排成一行的房子，房子的编号从 $1$ 到 $m$（含两端）。房子 $u$ 和 $v$ 相邻，当且仅当 $|u-v|=1$。我们需要为每一个人安排一栋房子，要求所有人入住的房子互不相同。若两个人住进了一对相邻的房子，则这两个人互为邻居。\n\n有的人喜欢自己有邻居，而有的人不喜欢。对于第 $i$ 个人，如果他有至少一位邻居，则他的满意度为 $a_i$；否则如果他没有邻居，则他的满意度为 $b_i$。\n\n您作为小区的规划者，需要最大化所有人的总满意度。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $m$（$1 \\le n \\le 5 \\times 10^5$，$1 \\le m \\le 10^9$，$n \\le m$），表示人数和房子数。\n\n对于接下来的 $n$ 行，第 $i$ 行输入两个整数 $a_i$ 和 $b_i$（$1 \\le a_i, b_i \\le 10^9$），表示第 $i$ 个人在有邻居和没有邻居时的满意度。\n\n保证所有数据 $n$ 之和不超过 $10^6$。", "outputFormat": "每组数据输出一行一个整数表示最大总满意度。\n\n**【样例解释】**\n\n对于第一组样例数据，最优方案是让第 $1$ 个人入住房子 $1$，第 $2$ 到 $4$ 个人入住房子 $3$ 到 $5$。这样，第 $1$ 个人没有邻居，而第 $2$ 到 $4$ 个人都有邻居。答案为 $100 + 100 + 100 + 100 = 400$。当然，也可以让第 $2$ 到 $4$ 个人入住房子 $1$ 到 $3$，第 $1$ 个人入住房子 $5$，也能得到 $400$ 的总满意度。\n\n对于第二组样例数据，由于只有 $2$ 栋房子，因此第 $1$ 和第 $2$ 个人必须成为邻居。答案为 $1 + 1 = 2$。\n\n对于第三组样例数据，最优方案是让第 $1$ 个人入住房子 $1$，第 $2$ 个人入住房子 $3$。这样，两个人都没有邻居。答案为 $50 + 1000 = 1050$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9694", "type": "P", "difficulty": 5, "samples": [["2\n5 3\ngdcpc\ngdcpcpcp\nsuasua\nsuas\nsususua\n3 3\na\nb\nc", "gdcpc\nEMPTY"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "广东", "O2优化", "字典树 Trie", "省赛/邀请赛"], "title": "[GDCPC 2023] New but Nostalgic Problem", "background": "", "description": "Given $n$ strings $w_1, w_2, \\cdots, w_n$, please select $k$ strings among them, so that the lexicographic order of string $v$ is minimized, and output the optimal string $v$. String $v$ satisfies the following constraint: $v$ is the longest common prefix of two selected strings with different indices. Also, $v$ is the lexicographically largest string among all strings satisfying the constraint.\n\nMore formally, let $\\mathbb{S}$ be a set of size $k$, where all the elements in the set are integers between $1$ and $n$ (both inclusive) and there are no duplicated elements. Let $\\text{lcp}(w_i, w_j)$ be the longest common prefix of string $w_i$ and $w_j$, please find a set $\\mathbb{S}$ to minimize the lexicographic order of the following string $v$ and output the optimal string $v$.\n\n$$\nv = \\max\\limits_{i \\in \\mathbb{S}, j \\in \\mathbb{S}, i \\ne j} \\text{lcp}(w_i, w_j)\n$$\n\nIn the above expression, $\\max$ is calculated by comparing the lexicographic order of strings.\n\nRecall that:\n- String $p$ is a prefix of string $s$, if we can append some number of characters (including zero characters) at the end of $p$ so that it changes to $s$. Specifically, empty string is a prefix of any string.\n- The longest common prefix of string $s$ and string $t$ is the longest string $p$ such that $p$ is a prefix of both $s$ and $t$. For example, the longest common prefix of ``abcde`` and ``abcef`` is ``abc``, while the longest common prefix of ``abcde`` and ``bcdef`` is an empty string.\n- String $s$ is lexicographically smaller than string $t$ ($s \\ne t$), if\n  - $s$ is a prefix of $t$, or\n  - $s_{|p| + 1} < t_{|p| + 1}$, where $p$ is the longest common prefix of $s$ and $t$, $|p|$ is the length of $p$, $s_i$ is the $i$-th character of string $s$, and $t_i$ is the $i$-th character of string $t$.\n- Specifically, empty string is the string with the smallest lexicographic order.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $k$ ($2\\leq n\\leq 10^6$, $2\\leq k\\leq n$) indicating the total number of strings and the number of strings to be selected.\n\nFor the following $n$ lines, the $i$-th line contains a string $w_i$ ($1\\leq |w_i|\\leq 10^6$) consisting of lower-cased English letters.\n\nIt's guaranteed that the total length of all strings of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one string indicating the answer. Specifically, if the answer is an empty string, print $\\texttt{EMPTY}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] New but Nostalgic Problem", "background": "", "description": "Given $n$ strings $w_1, w_2, \\cdots, w_n$, please select $k$ strings among them, so that the lexicographic order of string $v$ is minimized, and output the optimal string $v$. String $v$ satisfies the following constraint: $v$ is the longest common prefix of two selected strings with different indices. Also, $v$ is the lexicographically largest string among all strings satisfying the constraint.\n\nMore formally, let $\\mathbb{S}$ be a set of size $k$, where all the elements in the set are integers between $1$ and $n$ (both inclusive) and there are no duplicated elements. Let $\\text{lcp}(w_i, w_j)$ be the longest common prefix of string $w_i$ and $w_j$, please find a set $\\mathbb{S}$ to minimize the lexicographic order of the following string $v$ and output the optimal string $v$.\n\n$$\nv = \\max\\limits_{i \\in \\mathbb{S}, j \\in \\mathbb{S}, i \\ne j} \\text{lcp}(w_i, w_j)\n$$\n\nIn the above expression, $\\max$ is calculated by comparing the lexicographic order of strings.\n\nRecall that:\n- String $p$ is a prefix of string $s$, if we can append some number of characters (including zero characters) at the end of $p$ so that it changes to $s$. Specifically, empty string is a prefix of any string.\n- The longest common prefix of string $s$ and string $t$ is the longest string $p$ such that $p$ is a prefix of both $s$ and $t$. For example, the longest common prefix of ``abcde`` and ``abcef`` is ``abc``, while the longest common prefix of ``abcde`` and ``bcdef`` is an empty string.\n- String $s$ is lexicographically smaller than string $t$ ($s \\ne t$), if\n  - $s$ is a prefix of $t$, or\n  - $s_{|p| + 1} < t_{|p| + 1}$, where $p$ is the longest common prefix of $s$ and $t$, $|p|$ is the length of $p$, $s_i$ is the $i$-th character of string $s$, and $t_i$ is the $i$-th character of string $t$.\n- Specifically, empty string is the string with the smallest lexicographic order.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $k$ ($2\\leq n\\leq 10^6$, $2\\leq k\\leq n$) indicating the total number of strings and the number of strings to be selected.\n\nFor the following $n$ lines, the $i$-th line contains a string $w_i$ ($1\\leq |w_i|\\leq 10^6$) consisting of lower-cased English letters.\n\nIt's guaranteed that the total length of all strings of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one string indicating the answer. Specifically, if the answer is an empty string, print $\\texttt{EMPTY}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] New but Nostalgic Problem", "background": "", "description": "给定 $n$ 个字符串 $w_1, w_2, \\cdots, w_n$，请选出恰好 $k$ 个字符串，最小化字符串 $v$ 的字典序，并输出这个最优的字符串 $v$。其中 $v$ 满足以下条件：$v$ 是被选出的字符串中，某两个编号不同的字符串的最长公共前缀。而且，$v$ 是所有满足条件的字符串中，字典序最大的字符串。\n\n更正式地，令 $\\mathbb{S}$ 表示一个大小为 $k$ 的集合，集合中的元素均为从 $1$ 到 $n$ 的整数（含两端），且没有重复的元素。令 $\\text{lcp}(w_i, w_j)$ 表示字符串 $w_i$ 和 $w_j$ 的最长公共前缀，您需要找到一个集合 $\\mathbb{S}$ 以最小化下述字符串 $v$ 的字典序，并输出这个最优的字符串 $v$。\n\n$$\nv = \\max\\limits_{i \\in \\mathbb{S}, j \\in \\mathbb{S}, i \\ne j} \\text{lcp}(w_i, w_j)\n$$\n\n上式中的 $\\max$ 通过字典序比较两个字符串。\n\n请回忆：\n- 称字符串 $p$ 是字符串 $s$ 的前缀，若可以在 $p$ 的末尾添加若干个字符（包括零个字符）将它变成 $s$。特别地，空字符串是任意字符串的前缀。\n- 字符串 $s$ 和 $t$ 的最长公共前缀是一个最长的字符串 $p$，满足 $p$ 既是 $s$ 的前缀，又是 $t$ 的前缀。例如，``abcde`` 与``abcef`` 的最长公共前缀为 ``abc``，而 ``abcde`` 与 ``bcdef`` 的最长公共前缀为空字符串。\n- 称字符串 $s$ 的字典序小于字符串 $t$（$s \\ne t$），若\n  - $s$ 是 $t$ 的前缀，或\n  - $s_{|p| + 1} < t_{|p| + 1}$，其中 $p$ 为 $s$ 和 $t$ 的最长公共前缀，$|p|$ 为 $p$ 的长度，$s_i$ 表示字符串 $s$ 的第 $i$ 个字符，$t_i$ 表示字符串 $t$ 的第 $i$ 个字符。\n- 特别地，空字符串是字典序最小的字符串。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $k$（$2\\leq n\\leq 10^6$，$2\\leq k\\leq n$），表示字符串的总数和需要选择的字符串的数量。\n\n对于接下来 $n$ 行，第 $i$ 行输入一个由小写字母构成的字符串 $w_i$（$1\\leq |w_i|\\leq 10^6$）。\n\n保证所有数据中字符串长度之和不超过 $10^6$。", "outputFormat": "每组数据输出一行一个字符串表示答案。特别地，若答案为空字符串，输出 $\\texttt{EMPTY}$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9695", "type": "P", "difficulty": 5, "samples": [["2\n5 10\n1 2 3 1 2\n1 10 100 1000 10000\n3 3 1 3\n3 3 2 2 3\n2 5 20000\n2 3 200\n3 3 2 1 3\n3 3 3 1 2 3\n1 3 4\n2 1 100000\n1 2 2\n3 1 2 1 2\n4 1\n1 2 3 4\n1000000 1000000 1000000 1000000\n3 4 4 1 2 3 4", "100\n110\n1200\n21211\n100010\n4000000"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "树状数组", "2023", "广东", "O2优化", "分块", "省赛/邀请赛"], "title": "[GDCPC 2023] Traveling in Cells", "background": "", "description": "There are $n$ cells arranged in a row. The $i$-th cell has a color $c_i$ and contains a ball with value $v_i$.\n\nYou're going to travel several times in the cells. For each travel, you'll be given an integer $x$ and a set of colors $\\mathbb{A} = \\{a_1, a_2, \\cdots, a_k\\}$ where $c_x \\in \\mathbb{A}$. The travel starts from cell $x$. During the travel, if you're located in cell $i$ you can next move to cell $(i - 1)$ or $(i + 1)$. Note that you can't move out of these $n$ cells. Also at any time, the color of cell you're located in must belong to set $\\mathbb{A}$.\n\nWhen you're in cell $i$, you can choose to remove the ball in the cell and gain its value $v_i$. As there is only one ball in each cell, you can only remove the ball from each cell once.\n\nYour task is to process $q$ operations in order. Each operation is one of the following three types:\n\n- $1\\; p \\; x$: Change $c_p$ to $x$.\n- $2\\; p \\; x$: Change $v_p$ to $x$.\n- $3\\; x\\; k\\; a_1\\; a_2 \\; \\ldots\\; a_k$: Given the starting cell $x$ and the color set $\\mathbb{A} = \\{a_1, a_2, \\cdots, a_k\\}$ of a travel, imagine that you're going on this travel, calculate the maximum total value you can gain. Note that this travel is only an imagination, thus the balls won't be truely removed. That is, all queries are independent.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $q$ ($1 \\leq n \\leq 10^5$, $1 \\leq q \\leq 10^5$) indicating the number of cells and the number of operations.\n\nThe second line contains $n$ integers $c_1, c_2, \\ldots, c_n$ ($1 \\leq c_i \\leq n$) where $c_i$ is the initial color of the $i$-th cell.\n\nThe third line contains $n$ integers $v_1, v_2, \\ldots, v_n$ ($1 \\leq v_i \\leq 10^9$) where $v_i$ is the initial value of ball in the $i$-th cell.\n\nFor the following $q$ lines, the $i$-th line describes the $i$-th operation. The input format is listed as follows:\n\n- $1\\; p\\; x$: $1 \\leq p \\leq n$ and $1 \\leq x \\leq n$.\n- $2\\; p\\; x$: $1 \\leq p \\leq n$ and $1 \\leq x \\leq 10^9$.\n- $3\\; x\\; k\\; a_1\\; a_2\\; \\ldots \\; a_k$: $1 \\leq x \\leq n$, $1 \\leq a_1 < a_2 < \\ldots < a_k \\leq n$ and $c_x \\in \\{a_1, a_2, \\cdots, a_k\\}$.\n\nIt's guaranteed that neither the sum of $n$ nor the sum of $q$ of all test cases will exceed $3 \\times 10^5$. Also the sum of $k$ of all test cases will not exceed $10^6$.", "outputFormat": "For each operation of type $3$ output one line containing one integer, indicating the maximum total value you can gain.", "hint": "", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] Traveling in Cells", "background": "", "description": "There are $n$ cells arranged in a row. The $i$-th cell has a color $c_i$ and contains a ball with value $v_i$.\n\nYou're going to travel several times in the cells. For each travel, you'll be given an integer $x$ and a set of colors $\\mathbb{A} = \\{a_1, a_2, \\cdots, a_k\\}$ where $c_x \\in \\mathbb{A}$. The travel starts from cell $x$. During the travel, if you're located in cell $i$ you can next move to cell $(i - 1)$ or $(i + 1)$. Note that you can't move out of these $n$ cells. Also at any time, the color of cell you're located in must belong to set $\\mathbb{A}$.\n\nWhen you're in cell $i$, you can choose to remove the ball in the cell and gain its value $v_i$. As there is only one ball in each cell, you can only remove the ball from each cell once.\n\nYour task is to process $q$ operations in order. Each operation is one of the following three types:\n\n- $1\\; p \\; x$: Change $c_p$ to $x$.\n- $2\\; p \\; x$: Change $v_p$ to $x$.\n- $3\\; x\\; k\\; a_1\\; a_2 \\; \\ldots\\; a_k$: Given the starting cell $x$ and the color set $\\mathbb{A} = \\{a_1, a_2, \\cdots, a_k\\}$ of a travel, imagine that you're going on this travel, calculate the maximum total value you can gain. Note that this travel is only an imagination, thus the balls won't be truely removed. That is, all queries are independent.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $q$ ($1 \\leq n \\leq 10^5$, $1 \\leq q \\leq 10^5$) indicating the number of cells and the number of operations.\n\nThe second line contains $n$ integers $c_1, c_2, \\ldots, c_n$ ($1 \\leq c_i \\leq n$) where $c_i$ is the initial color of the $i$-th cell.\n\nThe third line contains $n$ integers $v_1, v_2, \\ldots, v_n$ ($1 \\leq v_i \\leq 10^9$) where $v_i$ is the initial value of ball in the $i$-th cell.\n\nFor the following $q$ lines, the $i$-th line describes the $i$-th operation. The input format is listed as follows:\n\n- $1\\; p\\; x$: $1 \\leq p \\leq n$ and $1 \\leq x \\leq n$.\n- $2\\; p\\; x$: $1 \\leq p \\leq n$ and $1 \\leq x \\leq 10^9$.\n- $3\\; x\\; k\\; a_1\\; a_2\\; \\ldots \\; a_k$: $1 \\leq x \\leq n$, $1 \\leq a_1 < a_2 < \\ldots < a_k \\leq n$ and $c_x \\in \\{a_1, a_2, \\cdots, a_k\\}$.\n\nIt's guaranteed that neither the sum of $n$ nor the sum of $q$ of all test cases will exceed $3 \\times 10^5$. Also the sum of $k$ of all test cases will not exceed $10^6$.", "outputFormat": "For each operation of type $3$ output one line containing one integer, indicating the maximum total value you can gain.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] Traveling in Cells", "background": "", "description": "有 $n$ 个格子排成一行，第 $i$ 个格子的颜色为 $c_i$，上面放置着一个权值为 $v_i$ 的球。\n\n您将要在格子中进行若干次旅行。每次旅行时，您会得到旅行的起点 $x$ 与一个颜色集合 $\\mathbb{A} = \\{a_1, a_2, \\cdots, a_k\\}$，且保证 $c_x \\in \\mathbb{A}$。旅行将从第 $x$ 个格子上开始。在旅行期间，如果您在格子 $i$ 处，那么您可以向格子 $(i - 1)$ 或 $(i + 1)$ 处移动，但不能移动到这 $n$ 个格子之外。且在任意时刻，您所处的格子的颜色必须在集合 $\\mathbb{A}$ 中。\n\n当您位于格子 $i$ 时，您可以选择将格子上的球取走，并获得 $v_i$ 的权值。由于每个格子上只有一个球，因此一个格子上的球只能被取走一次。\n\n您的任务是依次处理 $q$ 次操作，每次操作形如以下三种操作之一：\n\n- $1\\; p \\; x$：将 $c_p$ 修改为 $x$。\n- $2\\; p \\; x$：将 $v_p$ 修改为 $x$。\n- $3\\; x\\; k\\; a_1\\; a_2 \\; \\ldots\\; a_k$：给定旅行的起点 $x$ 与一个颜色集合 $\\mathbb{A} = \\{a_1, a_2, \\cdots, a_k\\}$。假设如果进行这样的一次旅行，求出取走的球的权值之和最大是多少。注意，由于我们仅仅假设进行一次旅行，因此并不会真的取走任何球。即，所有询问之间是独立的。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $q$（$1 \\leq n \\leq 10^5$，$1 \\leq q \\leq 10^5$）表示格子的数量和操作的数量。\n\n第二行输入 $n$ 个整数 $c_1, c_2, \\ldots, c_n$（$1 \\leq c_i \\leq n$），其中 $c_i$ 表示第 $i$ 个格子的初始颜色。\n\n第三行输入 $n$ 个整数 $v_1, v_2, \\ldots, v_n$（$1 \\leq v_i \\leq 10^9$），其中 $v_i$ 表示第 $i$ 个格子里的球的初始权值。\n\n对于接下来 $q$ 行，第 $i$ 行描述第 $i$ 次操作，格式如下：\n\n- $1\\; p\\; x$：保证 $1 \\leq p \\leq n$ 且 $1 \\leq x \\leq n$。\n- $2\\; p\\; x$：保证 $1 \\leq p \\leq n$ 且 $1 \\leq x \\leq 10^9$。\n- $3\\; x\\; k\\; a_1\\; a_2\\; \\ldots \\; a_k$：保证 $1 \\leq x \\leq n$ 且 $1 \\leq a_1 < a_2 < \\ldots < a_k \\leq n$ 且 $c_x \\in \\{a_1, a_2, \\cdots, a_k\\}$。\n\n保证所有数据 $n$ 之和与 $q$ 之和均不超过 $3 \\times 10^5$，且所有数据 $k$ 之和不超过 $10^6$。", "outputFormat": "对于每次操作 $3$ 输出一行一个整数，表示取走的球的权值之和的最大值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9696", "type": "P", "difficulty": 6, "samples": [["3\n6\n6 5 4 3 5 6\n6\n1 2 1 1 2 2\n5\n1 1 2 2 2", "7\n3\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "广东", "O2优化", "前缀和", "省赛/邀请赛"], "title": "[GDCPC 2023] Swapping Operation", "background": "", "description": "Given a non-negative integer sequence $A = a_1, a_2, \\dots, a_n$ of length $n$, define\n\n$$\nF(A)=\\max\\limits_{1\\leq k<n} ((a_1 \\,\\&\\, a_2 \\,\\&\\, \\cdots \\,\\&\\, a_k)+(a_{k+1} \\,\\&\\, a_{k+2} \\,\\&\\, \\cdots \\,\\&\\, a_n))\n$$\n\nwhere $\\&$ is the bitwise-and operator.\n\nYou can perform the swapping operation at most once: choose two indices $i$ and $j$ such that $1\\leq i < j\\leq n$ and then swap the values of $a_i$ and $a_j$.\n\nCalculate the maximum possible value of $F(A)$ after performing at most one swapping operation.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($2\\leq n\\leq 10^5$) indicating the length of sequence $A$.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($0\\leq a_i\\leq 10^9$) indicating the given sequence $A$.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^5$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum possible value of $F(A)$ after performing at most one swapping operation.", "hint": "For the first sample test case, we can swap $a_4$ and $a_6$ so the sequence becomes $\\{6, 5, 4, 6, 5, 3\\}$. We can then choose $k = 5$ so that $F(A) = (6 \\,\\&\\, 5 \\,\\&\\, 4 \\,\\&\\, 6 \\,\\&\\, 5) + (3) = 7$.\n\nFor the second sample test case, we can swap $a_2$ and $a_4$ so the sequence becomes $\\{1, 1, 1, 2, 2, 2\\}$. We can then choose $k = 3$ so that $F(A) = (1 \\,\\&\\, 1 \\,\\&\\, 1) + (2 \\,\\&\\, 2 \\,\\&\\, 2) = 3$.\n\nFor the third sample test case we do not perform the swapping operation. We can then choose $k = 2$ so that $F(A) = (1 \\,\\&\\, 1) + (2 \\,\\&\\, 2 \\,\\&\\, 2) = 3$.", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] Swapping Operation", "background": "", "description": "Given a non-negative integer sequence $A = a_1, a_2, \\dots, a_n$ of length $n$, define\n\n$$\nF(A)=\\max\\limits_{1\\leq k<n} ((a_1 \\,\\&\\, a_2 \\,\\&\\, \\cdots \\,\\&\\, a_k)+(a_{k+1} \\,\\&\\, a_{k+2} \\,\\&\\, \\cdots \\,\\&\\, a_n))\n$$\n\nwhere $\\&$ is the bitwise-and operator.\n\nYou can perform the swapping operation at most once: choose two indices $i$ and $j$ such that $1\\leq i < j\\leq n$ and then swap the values of $a_i$ and $a_j$.\n\nCalculate the maximum possible value of $F(A)$ after performing at most one swapping operation.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($2\\leq n\\leq 10^5$) indicating the length of sequence $A$.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($0\\leq a_i\\leq 10^9$) indicating the given sequence $A$.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^5$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum possible value of $F(A)$ after performing at most one swapping operation.", "hint": "For the first sample test case, we can swap $a_4$ and $a_6$ so the sequence becomes $\\{6, 5, 4, 6, 5, 3\\}$. We can then choose $k = 5$ so that $F(A) = (6 \\,\\&\\, 5 \\,\\&\\, 4 \\,\\&\\, 6 \\,\\&\\, 5) + (3) = 7$.\n\nFor the second sample test case, we can swap $a_2$ and $a_4$ so the sequence becomes $\\{1, 1, 1, 2, 2, 2\\}$. We can then choose $k = 3$ so that $F(A) = (1 \\,\\&\\, 1 \\,\\&\\, 1) + (2 \\,\\&\\, 2 \\,\\&\\, 2) = 3$.\n\nFor the third sample test case we do not perform the swapping operation. We can then choose $k = 2$ so that $F(A) = (1 \\,\\&\\, 1) + (2 \\,\\&\\, 2 \\,\\&\\, 2) = 3$.", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] Swapping Operation", "background": "", "description": "给定长度为 $n$ 的非负整数序列 $A = a_1, a_2, \\dots, a_n$，定义\n\n$$\nF(A)=\\max\\limits_{1\\leq k<n} ((a_1 \\,\\&\\, a_2 \\,\\&\\, \\cdots \\,\\&\\, a_k)+(a_{k+1} \\,\\&\\, a_{k+2} \\,\\&\\, \\cdots \\,\\&\\, a_n))\n$$\n\n其中 $\\&$ 表示按位与操作。\n\n您可以进行至多一次交换操作：选择两个下标 $i$ 和 $j$ 满足 $1\\leq i < j\\leq n$，交换 $a_i$ 与 $a_j$ 的值。\n\n求经过至多一次交换后，$F(A)$ 的最大值。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入一个整数 $n$（$2\\leq n\\leq 10^5$)，表示序列 $A$ 的长度。\n\n第二行输入 $n$ 个整数 $a_1, a_2, \\cdots, a_n$（$0\\leq a_i\\leq 10^9$)，表示给定的序列 $A$。\n\n保证所有数据 $n$ 之和不超过 $10^5$。", "outputFormat": "每组数据输出一行一个整数，表示经过至多一次交换后 $F(A)$ 的最大值。\n\n**【样例解释】**\n\n对于第一组样例数据，可以交换 $a_4$ 和 $a_6$ 将序列变为 $\\{6, 5, 4, 6, 5, 3\\}$，然后选择 $k = 5$，就得到了 $F(A) = (6 \\,\\&\\, 5 \\,\\&\\, 4 \\,\\&\\, 6 \\,\\&\\, 5) + (3) = 7$。\n\n对于第二组样例数据，可以交换 $a_2$ 和 $a_4$ 将序列变为 $\\{1, 1, 1, 2, 2, 2\\}$，然后选择 $k = 3$，就得到了 $F(A) = (1 \\,\\&\\, 1 \\,\\&\\, 1) + (2 \\,\\&\\, 2 \\,\\&\\, 2) = 3$。\n\n对于第三组样例数据，不进行交换操作，然后选择 $k = 2$，就得到了 $F(A) = (1 \\,\\&\\, 1) + (2 \\,\\&\\, 2 \\,\\&\\, 2) = 3$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9697", "type": "P", "difficulty": 6, "samples": [["2\n4 4\n1 1 2 2\n3 2 4 1\n1 2 3 2\n2 1 4 1\n4 2\n3 2 4 1\n1 2 3 1", "7\n4 1 3 2\n5\n2 1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["图论", "2023", "广东", "Special Judge", "O2优化", "图论建模", "强连通分量", "省赛/邀请赛"], "title": "[GDCPC 2023] Canvas", "background": "", "description": "There is a sequence of length $n$. At the beginning, all elements in the sequence equal to $0$. There are also $m$ operations, where the $i$-th operation will change the value of the $l_i$-th element in the sequence to $x_i$, and also change the value of the $r_i$-th element in the sequence to $y_i$. Each operation must be performed exactly once.\n\nFind the optimal order to perform the operations, so that after all operations, the sum of all elements in the sequence is maximized.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($2 \\leq n, m \\leq 5 \\times 10^5$) indicating the length of the sequence and the number of operations.\n\nFor the following $m$ lines, the $i$-th line contains four integers $l_i$, $x_i$, $r_i$ and $y_i$ ($1 \\leq l_i<r_i \\leq n$, $1 \\leq x_i,y_i \\leq 2$) indicating the $i$-th operation.\n\nIt's guaranteed that neither the sum of $n$ nor the sum of $m$ of all test cases will exceed $5 \\times 10^5$.", "outputFormat": "For each test case, first output one line containing one integer, indicating the maximum sum of all elements in the sequence after all operations. Then output another line containing $m$ integers $a_1, a_2, \\cdots, a_m$ separated by a space, indicating the optimal order to perform the operations, where $a_i$ is the index of the $i$-th operation to be performed. Each integer from $1$ to $m$ (both inclusive) must appear exactly once. If there are multiple valid answers, you can output any of them.", "hint": "For the first sample test case, after performing operations $4, 1, 3, 2$ in order, the sequence becomes $\\{2, 2, 2, 1\\}$. The sum of all elements is $7$.\n\nFor the second sample test case, after performing operations $2, 1$ in order, the sequence becomes $\\{2, 0, 2, 1\\}$. The sum of all elements is $5$.", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] Canvas", "background": "", "description": "There is a sequence of length $n$. At the beginning, all elements in the sequence equal to $0$. There are also $m$ operations, where the $i$-th operation will change the value of the $l_i$-th element in the sequence to $x_i$, and also change the value of the $r_i$-th element in the sequence to $y_i$. Each operation must be performed exactly once.\n\nFind the optimal order to perform the operations, so that after all operations, the sum of all elements in the sequence is maximized.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($2 \\leq n, m \\leq 5 \\times 10^5$) indicating the length of the sequence and the number of operations.\n\nFor the following $m$ lines, the $i$-th line contains four integers $l_i$, $x_i$, $r_i$ and $y_i$ ($1 \\leq l_i<r_i \\leq n$, $1 \\leq x_i,y_i \\leq 2$) indicating the $i$-th operation.\n\nIt's guaranteed that neither the sum of $n$ nor the sum of $m$ of all test cases will exceed $5 \\times 10^5$.", "outputFormat": "For each test case, first output one line containing one integer, indicating the maximum sum of all elements in the sequence after all operations. Then output another line containing $m$ integers $a_1, a_2, \\cdots, a_m$ separated by a space, indicating the optimal order to perform the operations, where $a_i$ is the index of the $i$-th operation to be performed. Each integer from $1$ to $m$ (both inclusive) must appear exactly once. If there are multiple valid answers, you can output any of them.", "hint": "For the first sample test case, after performing operations $4, 1, 3, 2$ in order, the sequence becomes $\\{2, 2, 2, 1\\}$. The sum of all elements is $7$.\n\nFor the second sample test case, after performing operations $2, 1$ in order, the sequence becomes $\\{2, 0, 2, 1\\}$. The sum of all elements is $5$.", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] Canvas", "background": "", "description": "有一个长度为 $n$ 的序列，一开始序列中的所有元素均为 $0$。另外还有 $m$ 个操作，其中第 $i$ 个操作会将序列中第 $l_i$ 个元素的值改为 $x_i$，以及将序列中第 $r_i$ 个元素的值改为 $y_i$。每个操作必须恰好执行一次。\n\n求执行操作的最优顺序，使得所有操作执行完成后，序列中所有元素之和最大。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $m$（$2 \\leq n, m \\leq 5 \\times 10^5$）表示序列的长度和操作的个数。\n\n对于接下来 $m$ 行，第 $i$ 行输入四个整数 $l_i$，$x_i$，$r_i$ 和 $y_i$（$1 \\leq l_i<r_i \\leq n$，$1 \\leq x_i,y_i \\leq 2$）表示第 $i$ 个操作。\n\n保证所有数据 $n$ 之和与 $m$ 之和均不超过 $5 \\times 10^5$。", "outputFormat": "每组数据首先输出一行一个整数，表示执行操作后，所有元素的最大和。接下来输出一行 $m$ 个由单个空格分隔的整数 $a_1, a_2, \\cdots, a_m$ 表示执行操作的最优顺序，其中 $a_i$ 表示第 $i$ 次执行的操作的编号。从 $1$ 到 $m$ 的每个整数（含两端）必须恰好出现一次。若有多种合法答案，您可以输出任意一种。\n\n**【样例解释】**\n\n对于第一组样例数据，按 $4, 1, 3, 2$ 的顺序执行操作后，序列变为 $\\{2, 2, 2, 1\\}$，元素之和为 $7$。\n\n对于第二组样例数据，按 $2, 1$ 的顺序执行操作后，序列变为 $\\{2, 0, 2, 1\\}$，元素之和为 $5$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9698", "type": "P", "difficulty": 3, "samples": [["2\n2 3\n1 2 4\n3 0 5\n1 5\n1 3 0 4 2", "3\n5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["二分", "2023", "广东", "O2优化", "省赛/邀请赛"], "title": "[GDCPC 2023] Path Planning", "background": "", "description": "There is a grid with $n$ rows and $m$ columns. Each cell of the grid has an integer in it, where $a_{i, j}$ indicates the integer in the cell located at the $i$-th row and the $j$-th column. Each integer from $0$ to $(n \\times m - 1)$ (both inclusive) appears exactly once in the grid.\n\nLet $(i, j)$ be the cell located at the $i$-th row and the $j$-th column. You now start from $(1, 1)$ and need to reach $(n, m)$. When you are in cell $(i, j)$, you can either move to its right cell $(i, j + 1)$ if $j < m$ or move to its bottom cell $(i + 1, j)$ if $i < n$.\n\nLet $\\mathbb{S}$ be the set consisting of integers in each cell on your path, including $a_{1, 1}$ and $a_{n, m}$. Let $\\text{mex}(\\mathbb{S})$ be the smallest non-negative integer which does not belong to $\\mathbb{S}$. Find a path to maximize $\\text{mex}(\\mathbb{S})$ and calculate this maximum possible value.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n, m \\le 10^6$, $1 \\le n \\times m \\le 10^6$) indicating the number of rows and columns of the grid.\n\nFor the following $n$ lines, the $i$-th line contains $m$ integers $a_{i, 1}, a_{i, 2}, \\cdots, a_{i, m}$ ($0 \\le a_{i, j} < n \\times m$) where $a_{i, j}$ indicates the integer in cell $(i, j)$. Each integer from $0$ to $(n \\times m - 1)$ (both inclusive) appears exactly once in the grid.\n\nIt's guaranteed that the sum of $n \\times m$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum possible value of $\\text{mex}(\\mathbb{S})$.", "hint": "For the first sample test case there are $3$ possible paths.\n\n- The first path is $(1, 1) \\to (1, 2) \\to (1, 3) \\to (2, 3)$. $\\mathbb{S} = \\{1, 2, 4, 5\\}$ so $\\text{mex}(\\mathbb{S}) = 0$.\n- The second path is $(1, 1) \\to (1, 2) \\to (2, 2) \\to (2, 3)$. $\\mathbb{S} = \\{1, 2, 0, 5\\}$ so $\\text{mex}(\\mathbb{S}) = 3$.\n- The third path is $(1, 1) \\to (2, 1) \\to (2, 2) \\to (2, 3)$. $\\mathbb{S} = \\{1, 3, 0, 5\\}$ so $\\text{mex}(\\mathbb{S}) = 2$.\n\nSo the answer is $3$.\n\nFor the second sample test case there is only $1$ possible path, which is $(1, 1) \\to (1, 2) \\to (1, 3) \\to (1, 4) \\to (1, 5)$. $\\mathbb{S} = \\{1, 3, 0, 4, 2\\}$ so $\\text{mex}(\\mathbb{S}) = 5$.", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] Path Planning", "background": "", "description": "There is a grid with $n$ rows and $m$ columns. Each cell of the grid has an integer in it, where $a_{i, j}$ indicates the integer in the cell located at the $i$-th row and the $j$-th column. Each integer from $0$ to $(n \\times m - 1)$ (both inclusive) appears exactly once in the grid.\n\nLet $(i, j)$ be the cell located at the $i$-th row and the $j$-th column. You now start from $(1, 1)$ and need to reach $(n, m)$. When you are in cell $(i, j)$, you can either move to its right cell $(i, j + 1)$ if $j < m$ or move to its bottom cell $(i + 1, j)$ if $i < n$.\n\nLet $\\mathbb{S}$ be the set consisting of integers in each cell on your path, including $a_{1, 1}$ and $a_{n, m}$. Let $\\text{mex}(\\mathbb{S})$ be the smallest non-negative integer which does not belong to $\\mathbb{S}$. Find a path to maximize $\\text{mex}(\\mathbb{S})$ and calculate this maximum possible value.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\le n, m \\le 10^6$, $1 \\le n \\times m \\le 10^6$) indicating the number of rows and columns of the grid.\n\nFor the following $n$ lines, the $i$-th line contains $m$ integers $a_{i, 1}, a_{i, 2}, \\cdots, a_{i, m}$ ($0 \\le a_{i, j} < n \\times m$) where $a_{i, j}$ indicates the integer in cell $(i, j)$. Each integer from $0$ to $(n \\times m - 1)$ (both inclusive) appears exactly once in the grid.\n\nIt's guaranteed that the sum of $n \\times m$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum possible value of $\\text{mex}(\\mathbb{S})$.", "hint": "For the first sample test case there are $3$ possible paths.\n\n- The first path is $(1, 1) \\to (1, 2) \\to (1, 3) \\to (2, 3)$. $\\mathbb{S} = \\{1, 2, 4, 5\\}$ so $\\text{mex}(\\mathbb{S}) = 0$.\n- The second path is $(1, 1) \\to (1, 2) \\to (2, 2) \\to (2, 3)$. $\\mathbb{S} = \\{1, 2, 0, 5\\}$ so $\\text{mex}(\\mathbb{S}) = 3$.\n- The third path is $(1, 1) \\to (2, 1) \\to (2, 2) \\to (2, 3)$. $\\mathbb{S} = \\{1, 3, 0, 5\\}$ so $\\text{mex}(\\mathbb{S}) = 2$.\n\nSo the answer is $3$.\n\nFor the second sample test case there is only $1$ possible path, which is $(1, 1) \\to (1, 2) \\to (1, 3) \\to (1, 4) \\to (1, 5)$. $\\mathbb{S} = \\{1, 3, 0, 4, 2\\}$ so $\\text{mex}(\\mathbb{S}) = 5$.", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] Path Planning", "background": "", "description": "有一个 $n$ 行 $m$ 列的网格。网格里的每个格子都写着一个整数，其中第 $i$ 行第 $j$ 列的格子里写着整数 $a_{i, j}$。从 $0$ 到 $(n \\times m - 1)$ 的每个整数（含两端）在网格里都恰好出现一次。\n\n令 $(i, j)$ 表示位于第 $i$ 行第 $j$ 列的格子。您现在需要从 $(1, 1)$ 出发并前往 $(n, m)$。当您位于格子 $(i, j)$ 时，您可以选择走到右方的格子 $(i, j + 1)$（若 $j < m$），也可以选择走到下方的格子 $(i + 1, j)$（若 $i < n$）。\n\n令 $\\mathbb{S}$ 表示路径上每个格子里的整数形成的集合，包括 $a_{1, 1}$ 和 $a_{n, m}$。令 $\\text{mex}(\\mathbb{S})$ 表示不属于 $\\mathbb{S}$ 的最小非负整数。请找出一条路径以最大化 $\\text{mex}(\\mathbb{S})$，并求出这个最大的值。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $m$（$1 \\le n, m \\le 10^6$，$1 \\le n \\times m \\le 10^6$）表示网格的行数和列数。\n\n对于接下来 $n$ 行，第 $i$ 行输入 $m$ 个整数 $a_{i, 1}, a_{i, 2}, \\cdots, a_{i, m}$（$0 \\le a_{i, j} < n \\times m$），其中 $a_{i, j}$ 表示格子 $(i, j)$ 里的整数。从 $0$ 到 $(n \\times m - 1)$ 的每个整数（含两端）在网格里都恰好出现一次。\n\n保证所有数据 $n \\times m$ 之和不超过 $10^6$。", "outputFormat": "每组数据输出一行一个整数，表示最大的 $\\text{mex}(\\mathbb{S})$。\n\n**【样例解释】**\n\n对于第一组样例数据，共有 $3$ 条可能的路径。\n\n- 第一条路径为 $(1, 1) \\to (1, 2) \\to (1, 3) \\to (2, 3)$。$\\mathbb{S} = \\{1, 2, 4, 5\\}$ 因此 $\\text{mex}(\\mathbb{S}) = 0$。\n- 第二条路径为 $(1, 1) \\to (1, 2) \\to (2, 2) \\to (2, 3)$。$\\mathbb{S} = \\{1, 2, 0, 5\\}$ 因此 $\\text{mex}(\\mathbb{S}) = 3$。\n- 第三条路径为 $(1, 1) \\to (2, 1) \\to (2, 2) \\to (2, 3)$。$\\mathbb{S} = \\{1, 3, 0, 5\\}$ 因此 $\\text{mex}(\\mathbb{S}) = 2$。\n\n因此答案为 $3$。\n\n对于第二组样例数据，只有 $1$ 条可能的路径，即 $(1, 1) \\to (1, 2) \\to (1, 3) \\to (1, 4) \\to (1, 5)$。$\\mathbb{S} = \\{1, 3, 0, 4, 2\\}$ 因此 $\\text{mex}(\\mathbb{S}) = 5$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9699", "type": "P", "difficulty": 5, "samples": [["6\n1 1 1000 1000\n1 2 1000 1000\n3 11 1000 1000\n157 291 5 6\n157 291 3 6\n10126 114514 789 12345", "YES\n2 2\nNO\nYES\n2 10\nYES\n4 5\nNO\nYES\n779 9478"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2023", "广东", "Special Judge", "O2优化", "进制", "省赛/邀请赛"], "title": "[GDCPC 2023] X Equals Y", "background": "", "description": "For positive integers $X$ and $b \\geq 2$, define $f(X,b)$ as a sequence which describes the base-$b$ representation of $X$, where the $i$-th element in the sequence is the $i$-th least significant digit in the base-$b$ representation of $X$. For example, $f(6, 2) = \\{0, 1, 1\\}$, while $f(233, 17) = \\{12, 13\\}$.\n\nGiven four positive integers $x$, $y$, $A$ and $B$, please find two positive integers $a$ and $b$ satisfying:\n\n- $2 \\leq a \\leq A$\n- $2 \\leq b \\leq B$\n- $f(x, a) = f(y, b)$", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\leq T \\leq 10^3$) indicating the number of test cases. For each test case:\n\nThe first line contains four integers $x$, $y$, $A$ and $B$ ($1 \\leq x,y \\leq 10^9$, $2 \\leq A,B \\leq 10^9$).\n\nIt's guaranteed that there are at most $50$ test cases satisfying $\\max(x, y) > 10^6$.", "outputFormat": "For each test case, if valid positive integers $a$ and $b$ do not exist, output $\\texttt{NO}$ in one line.\n\nOtherwise, first output $\\texttt{YES}$ in one line. Then in the next line, output two integers $a$ and $b$ separated by a space. If there are multiple valid answers, you can output any of them.", "hint": "", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] X Equals Y", "background": "", "description": "For positive integers $X$ and $b \\geq 2$, define $f(X,b)$ as a sequence which describes the base-$b$ representation of $X$, where the $i$-th element in the sequence is the $i$-th least significant digit in the base-$b$ representation of $X$. For example, $f(6, 2) = \\{0, 1, 1\\}$, while $f(233, 17) = \\{12, 13\\}$.\n\nGiven four positive integers $x$, $y$, $A$ and $B$, please find two positive integers $a$ and $b$ satisfying:\n\n- $2 \\leq a \\leq A$\n- $2 \\leq b \\leq B$\n- $f(x, a) = f(y, b)$", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\leq T \\leq 10^3$) indicating the number of test cases. For each test case:\n\nThe first line contains four integers $x$, $y$, $A$ and $B$ ($1 \\leq x,y \\leq 10^9$, $2 \\leq A,B \\leq 10^9$).\n\nIt's guaranteed that there are at most $50$ test cases satisfying $\\max(x, y) > 10^6$.", "outputFormat": "For each test case, if valid positive integers $a$ and $b$ do not exist, output $\\texttt{NO}$ in one line.\n\nOtherwise, first output $\\texttt{YES}$ in one line. Then in the next line, output two integers $a$ and $b$ separated by a space. If there are multiple valid answers, you can output any of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] X Equals Y", "background": "", "description": "对于正整数 $X$ 与 $b \\geq 2$，定义 $f(X,b)$ 为一个描述了 $X$ 在 $b$ 进制表示下的序列，其中序列的第 $i$ 个元素表示 $X$ 在 $b$ 进制表示下从低到高第 $i$ 位的值。例如，$f(6, 2) = \\{0, 1, 1\\}$，而 $f(233, 17) = \\{12, 13\\}$。\n\n给定的四个正整数 $x$，$y$，$A$ 和 $B$，请找到两个正整数 $a$ 和 $b$，同时满足：\n\n- $2 \\leq a \\leq A$\n- $2 \\leq b \\leq B$\n- $f(x, a) = f(y, b)$", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$（$1 \\leq T \\leq 10^3$）表示测试数据组数。对于每组测试数据：\n\n第一行输入四个整数 $x$，$y$，$A$ 和 $B$（$1 \\leq x,y \\leq 10^9$，$2 \\leq A,B \\leq 10^9$）。\n\n保证至多只有 $50$ 组测试数据满足 $\\max(x, y) > 10^6$。", "outputFormat": "对于每组测试数据，如果不存在合法的正整数 $a$ 和 $b$，则输出一行一个字符串 $\\texttt{NO}$。\n\n否则，首先输出一行一个字符串 $\\texttt{YES}$。下一行输出两个由单个空格分隔的整数 $a$ 和 $b$。如果有多种合法答案，您可以输出任意一种。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9700", "type": "P", "difficulty": 3, "samples": [["3\n3 4 5\n2 2\n1 2\n1 4\n3 4\n1 1\n1 3 3\n1 1\n1 2\n1 3\n2 1 1\n2 1", "2\n3\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["搜索", "2023", "广东", "O2优化", "枚举", "省赛/邀请赛"], "title": "[GDCPC 2023] Peg Solitaire", "background": "", "description": "$\\textit{Peg Solitaire}$ is a single-player boardgame on a chessboard with $n$ rows and $m$ columns. Each cell of the chessboard either is empty, or contains a chesspiece. Initially, there are $k$ chesspieces on the chessboard.\n\nDuring the game, the player can choose a chesspiece, jump it over an adjacent chesspiece into an empty cell, and finally remove the chesspiece which is jumped over. More precisely, let $(i, j)$ be the cell on the $i$-th row and the $j$-th column, the player can perform operations of the following four types.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ugauif68.png)\n\nGiven the initial state of the chessboard, the player can perform the operations any number of times (including zero times). Calculate the minimum possible number of chesspieces remaining on the chessboard.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 20$) indicating the number of test cases. For each test case:\n\nThe first line contains three integers $n$, $m$ and $k$ ($1 \\le n, m \\le 6$, $1 \\le k \\le \\min(6, n \\times m)$) indicating the number of rows and columns of the chessboard and the initial number of chesspieces.\n\nFor the following $k$ lines, the $i$-th line contains two integers $x_i$ and $y_i$ ($1 \\le x_i \\le n$, $1 \\le y_i \\le m$) indicating that there is a chesspiece in the cell on the $x_i$-th row and the $y_i$-th column at the beginning. Except from these $k$ cells, all other cells are empty at the beginning. The positions of these $k$ cells contain no duplicate.", "outputFormat": "For each test case output one line containing one integer indicating the minimum possible number of chesspieces remaining on the chessboard.\n", "hint": "The first sample test case is explained as follows.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/aragowha.png)\n\nFor the second sample test case, as the chessboard does not contain empty cell at the beginning, the player cannot perform any operation.\n\nFor the third sample test case, as the chessboard has less than three cells, the player cannot perform any operation.\n", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] Peg Solitaire", "background": "", "description": "$\\textit{Peg Solitaire}$ is a single-player boardgame on a chessboard with $n$ rows and $m$ columns. Each cell of the chessboard either is empty, or contains a chesspiece. Initially, there are $k$ chesspieces on the chessboard.\n\nDuring the game, the player can choose a chesspiece, jump it over an adjacent chesspiece into an empty cell, and finally remove the chesspiece which is jumped over. More precisely, let $(i, j)$ be the cell on the $i$-th row and the $j$-th column, the player can perform operations of the following four types.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ugauif68.png)\n\nGiven the initial state of the chessboard, the player can perform the operations any number of times (including zero times). Calculate the minimum possible number of chesspieces remaining on the chessboard.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 20$) indicating the number of test cases. For each test case:\n\nThe first line contains three integers $n$, $m$ and $k$ ($1 \\le n, m \\le 6$, $1 \\le k \\le \\min(6, n \\times m)$) indicating the number of rows and columns of the chessboard and the initial number of chesspieces.\n\nFor the following $k$ lines, the $i$-th line contains two integers $x_i$ and $y_i$ ($1 \\le x_i \\le n$, $1 \\le y_i \\le m$) indicating that there is a chesspiece in the cell on the $x_i$-th row and the $y_i$-th column at the beginning. Except from these $k$ cells, all other cells are empty at the beginning. The positions of these $k$ cells contain no duplicate.", "outputFormat": "For each test case output one line containing one integer indicating the minimum possible number of chesspieces remaining on the chessboard.\n", "hint": "The first sample test case is explained as follows.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/aragowha.png)\n\nFor the second sample test case, as the chessboard does not contain empty cell at the beginning, the player cannot perform any operation.\n\nFor the third sample test case, as the chessboard has less than three cells, the player cannot perform any operation.\n", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] Peg Solitaire", "background": "", "description": "``独立钻石``是一种单人桌游。游戏在 $n$ 行 $m$ 列的棋盘上进行，棋盘上的每一格要么是空格，要么有一枚棋子。一开始，棋盘上共有 $k$ 枚棋子。\n\n在游戏中，玩家可以选择一枚棋子，将它跳过相邻棋子到空格上，并移除被跳过的棋子。具体来说，令 $(i, j)$ 表示位于第 $i$ 行第 $j$ 列的格子，玩家可以执行以下四种操作。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pgosoztu.png)\n\n给定一个初始的棋盘，求经过任意次操作（包括零次）之后，棋盘上最少能剩余几枚棋子。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$（$1 \\le T \\le 20$）表示测试数据组数。对于每组测试数据：\n\n第一行输入三个整数 $n$，$m$ 和 $k$（$1 \\le n, m \\le 6$，$1 \\le k \\le \\min(6, n \\times m)$）表示棋盘的行数，列数和初始棋子的数量。\n\n对于接下来 $k$ 行，第 $i$ 行输入两个整数 $x_i$ 和 $y_i$（$1 \\le x_i \\le n$，$1 \\le y_i \\le m$）表示一开始第 $x_i$ 行第 $y_i$ 列的格子里有一枚棋子。除了这 $k$ 个格子之外，其它格子一开始都是空格。这 $k$ 个格子的位置不会重复。", "outputFormat": "每组数据输出一行一个整数，表示经过任意次操作（包括零次）之后，棋盘上最少能剩余几枚棋子。\n\n**【样例解释】**\n\n第一组样例数据解释如下。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/aragowha.png)\n\n对于第二组样例数据，由于初始棋盘不存在空格，因此无法进行任何操作。\n\n对于第三组样例数据，由于棋盘不足三格，因此无法进行任何操作。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9701", "type": "P", "difficulty": 6, "samples": [["3\n5 3\n1 2 5\n2 3 4\n1 5 0\n5 0\n5 4\n1 2 1000000000\n1 3 1000000000\n1 4 1000000000\n1 5 1000000000", "4\n4\n1000000003"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "广东", "O2优化", "生成树", "省赛/邀请赛"], "title": "[GDCPC 2023] Classic Problem", "background": "", "description": "Given an undirected complete graph with $n$ vertices and $m$ triples $P_1, P_2, \\cdots, P_m$ where $P_i = (u_i, v_i, w_i)$, it's guaranteed that $1 \\leq u_i < v_i \\leq n$, and for any two triples $P_i$ and $P_j$ with different indices we have $(u_i, v_i) \\ne (u_j, v_j)$.\n\nFor any two vertices $x$ and $y$ in the graph ($1 \\leq x < y \\leq n$), define the weight of the edge connecting them as follows:\n\n- If there exists a triple $P_i$ satisfying $u_i = x$ and $v_i = y$, the weight of edge will be $w_i$.\n- Otherwise, the weight of edge will be $|x - y|$.\n\nCalculate the total weight of edges in the minimum spanning tree of the graph.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 10^5$) indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\leq n \\leq 10^9$, $0 \\leq m \\leq 10^5$) indicating the number of vertices in the graph and the number of triples.\n\nFor the following $m$ lines, the $i$-th line contains three integers $u_i$, $v_i$ and $w_i$ ($1 \\leq u_i < v_i \\leq n$, $0 \\leq w_i \\leq 10^9$) indicating the $i$-th triple. It's guaranteed that for all $1 \\leq i < j \\leq m$ we have $(u_i, v_i) \\ne (u_j, v_j)$.\n\nIt's guaranteed that the sum of $m$ of all test cases will not exceed $5 \\times 10^5$.", "outputFormat": "For each test case output one line containing one integer indicating the total weight of edges in the minimum spanning tree of the graph.", "hint": "The first sample test case is illustrated as follows. The minimum spanning tree is marked by red segments.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4gvbji8a.png)\n\nThe second sample test case is illustrated as follows. The minimum spanning tree is marked by red segments.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5cfsvoie.png)\n\nThe third sample test case is illustrated as follows. The minimum spanning tree is marked by red segments.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/iyzb4xpg.png)", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] Classic Problem", "background": "", "description": "Given an undirected complete graph with $n$ vertices and $m$ triples $P_1, P_2, \\cdots, P_m$ where $P_i = (u_i, v_i, w_i)$, it's guaranteed that $1 \\leq u_i < v_i \\leq n$, and for any two triples $P_i$ and $P_j$ with different indices we have $(u_i, v_i) \\ne (u_j, v_j)$.\n\nFor any two vertices $x$ and $y$ in the graph ($1 \\leq x < y \\leq n$), define the weight of the edge connecting them as follows:\n\n- If there exists a triple $P_i$ satisfying $u_i = x$ and $v_i = y$, the weight of edge will be $w_i$.\n- Otherwise, the weight of edge will be $|x - y|$.\n\nCalculate the total weight of edges in the minimum spanning tree of the graph.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 10^5$) indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($1 \\leq n \\leq 10^9$, $0 \\leq m \\leq 10^5$) indicating the number of vertices in the graph and the number of triples.\n\nFor the following $m$ lines, the $i$-th line contains three integers $u_i$, $v_i$ and $w_i$ ($1 \\leq u_i < v_i \\leq n$, $0 \\leq w_i \\leq 10^9$) indicating the $i$-th triple. It's guaranteed that for all $1 \\leq i < j \\leq m$ we have $(u_i, v_i) \\ne (u_j, v_j)$.\n\nIt's guaranteed that the sum of $m$ of all test cases will not exceed $5 \\times 10^5$.", "outputFormat": "For each test case output one line containing one integer indicating the total weight of edges in the minimum spanning tree of the graph.", "hint": "The first sample test case is illustrated as follows. The minimum spanning tree is marked by red segments.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4gvbji8a.png)\n\nThe second sample test case is illustrated as follows. The minimum spanning tree is marked by red segments.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5cfsvoie.png)\n\nThe third sample test case is illustrated as follows. The minimum spanning tree is marked by red segments.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/iyzb4xpg.png)", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] Classic Problem", "background": "", "description": "给定一张 $n$ 个点的无向完全图与 $m$ 个三元组 $P_1, P_2, \\cdots, P_m$，其中 $P_i = (u_i, v_i, w_i)$。保证 $1 \\leq u_i < v_i \\leq n$，且对于任意两个编号不同的三元组 $P_i$ 和 $P_j$，有 $(u_i, v_i) \\ne (u_j, v_j)$。\n\n对于图中的任意两个节点 $x$ 与 $y$（$1 \\leq x < y \\leq n$），定义它们之间的无向边的边权如下：\n\n- 如果存在一个三元组 $P_i$ 满足 $u_i = x$ 且 $v_i = y$，那么边权为 $w_i$。\n- 否则，边权为 $|x - y|$。\n\n求这张图的最小生成树的边权之和。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$（$1 \\le T \\le 10^5$）表示测试数据组数。对于每组测试数据：\n\n第一行输入两个整数 $n$ 和 $m$（$1 \\leq n \\leq 10^9$，$0 \\leq m \\leq 10^5$）表示图的点数与三元组的数量。\n\n对于接下来 $m$ 行，第 $i$ 行输入三个整数 $u_i$，$v_i$ 和 $w_i$（$1 \\leq u_i < v_i \\leq n$，$0 \\leq w_i \\leq 10^9$）表示第 $i$ 个三元组。保证对于所有 $1 \\leq i < j \\leq m$ 都有 $(u_i, v_i) \\ne (u_j, v_j)$。\n\n保证所有数据 $m$ 之和不超过 $5 \\times 10^5$。", "outputFormat": "每组数据输出一行一个整数，表示这张图的最小生成树的边权之和。\n\n**【样例解释】**\n\n第一组样例数据如下图所示，最小生成树用红色线段标出。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4gvbji8a.png)\n\n第二组样例数据如下图所示，最小生成树用红色线段标出。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5cfsvoie.png)\n\n第三组样例数据如下图所示，最小生成树用红色线段标出。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/iyzb4xpg.png)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9702", "type": "P", "difficulty": 5, "samples": [["2\n4\n1 0\n2 0\n1 1\n0 0\n6\n10 4\n9 7\n5 7\n4 5\n6 4\n9 3", "4\n44"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["计算几何", "2023", "广东", "O2优化", "凸包", "省赛/邀请赛"], "title": "[GDCPC 2023] Computational Geometry", "background": "", "description": "Given a convex polygon $P$ with $n$ vertices, you need to choose two vertices of $P$, so that the line connecting the two vertices will split $P$ into two smaller polygons $Q$ and $R$, both with positive area.\n\nLet $d(Q)$ be the diameter of polygon $Q$ and $d(R)$ be the diameter of polygon $R$, calculate the minimum value of $(d(Q))^2 + (d(R))^2$.\n\nRecall that the diameter of a polygon is the maximum distance between two points inside or on the border of the polygon.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($4 \\le n \\le 5 \\times 10^3$) indicating the number of vertices of the convex polygon $P$.\n\nFor the following $n$ lines, the $i$-th line contains two integers $x_i$ and $y_i$ ($0 \\le x_i, y_i \\le 10^9$) indicating the $i$-th vertex of the convex polygon $P$. Vertices are given in counter-clockwise order. It's guaranteed that the area of the convex polygon is positive, and there are no two vertices with the same coordinate. It's possible that three vertices lie on the same line.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $5 \\times 10^3$.", "outputFormat": "For each test case output one line containing one integer indicating the answer.", "hint": "The first sample test case is shown as follows. The diameter of smaller polygons are marked by red dashed segments. In fact, $(1, 0)$ and $(1, 1)$ are the only pair of vertices we can choose in this test case. You can't choose $(0, 0)$ and $(2, 0)$, or $(0, 0)$ and $(1, 1)$, because they can't split $P$ into two smaller polygons both with positive area.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6wue7ioc.png)\n\nThe second sample test case is shown as follows. The diameter of smaller polygons are marked by red dashed segments.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/en9mocsw.png)", "locale": "en", "translations": {"en": {"title": "[GDCPC 2023] Computational Geometry", "background": "", "description": "Given a convex polygon $P$ with $n$ vertices, you need to choose two vertices of $P$, so that the line connecting the two vertices will split $P$ into two smaller polygons $Q$ and $R$, both with positive area.\n\nLet $d(Q)$ be the diameter of polygon $Q$ and $d(R)$ be the diameter of polygon $R$, calculate the minimum value of $(d(Q))^2 + (d(R))^2$.\n\nRecall that the diameter of a polygon is the maximum distance between two points inside or on the border of the polygon.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($4 \\le n \\le 5 \\times 10^3$) indicating the number of vertices of the convex polygon $P$.\n\nFor the following $n$ lines, the $i$-th line contains two integers $x_i$ and $y_i$ ($0 \\le x_i, y_i \\le 10^9$) indicating the $i$-th vertex of the convex polygon $P$. Vertices are given in counter-clockwise order. It's guaranteed that the area of the convex polygon is positive, and there are no two vertices with the same coordinate. It's possible that three vertices lie on the same line.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $5 \\times 10^3$.", "outputFormat": "For each test case output one line containing one integer indicating the answer.", "hint": "The first sample test case is shown as follows. The diameter of smaller polygons are marked by red dashed segments. In fact, $(1, 0)$ and $(1, 1)$ are the only pair of vertices we can choose in this test case. You can't choose $(0, 0)$ and $(2, 0)$, or $(0, 0)$ and $(1, 1)$, because they can't split $P$ into two smaller polygons both with positive area.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6wue7ioc.png)\n\nThe second sample test case is shown as follows. The diameter of smaller polygons are marked by red dashed segments.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/en9mocsw.png)", "locale": "en"}, "zh-CN": {"title": "[GDCPC 2023] Computational Geometry", "background": "", "description": "给定一个有 $n$ 个顶点的凸多边形 $P$，您需要选择 $P$ 的两个顶点，并用一条同时穿过这两个顶点的直线，将 $P$ 分成两个面积均为正数的小多边形 $Q$ 和 $R$。\n\n记 $d(Q)$ 表示多边形 $Q$ 的直径，$d(R)$ 表示多边形 $R$ 的直径，求 $(d(Q))^2 + (d(R))^2$ 的最小值。\n\n请回忆：一个多边形的直径，指的是该多边形内部或边界上任意两点之间的距离的最大值。", "inputFormat": "有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：\n\n第一行输入一个整数 $n$（$4 \\le n \\le 5 \\times 10^3$）表示凸多边形 $P$ 的顶点数量。\n\n对于接下来 $n$ 行，第 $i$ 行输入两个整数 $x_i$ 和 $y_i$（$0 \\le x_i, y_i \\le 10^9$），表示凸多边形 $P$ 的第 $i$ 个顶点。顶点按逆时针顺序给出。保证该凸多边形面积为正，且没有顶点会重合。可能存在三个顶点位于同一条直线上的情况。\n\n保证所有数据 $n$ 之和不超过 $5 \\times 10^3$。", "outputFormat": "每组数据输出一行一个整数表示答案。\n\n**【样例解释】**\n\n第一组样例数据如下图所示。小多边形的直径用红色虚线标出。事实上，顶点 $(1, 0)$ 和 $(1, 1)$ 是这一组数据中唯一能选择的一对顶点。您不能选择顶点 $(0, 0)$ 和 $(2, 0)$，或顶点 $(0, 0)$ 和 $(1, 1)$，因为它们无法将 $P$ 分成两个面积均为正数的小多边形。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6wue7ioc.png)\n\n第二组样例数据如下图所示。小多边形的直径用红色虚线标出。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/en9mocsw.png)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9703", "type": "P", "difficulty": 4, "samples": [["3\n2 1 3\n3 1 4\n5 1 3", "4 3\n5 2\n10 7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "O2优化", "枚举"], "title": "「TFOI R1」Average Number", "background": "**题目背景与题意无关，可直接阅读题目描述。**\n\n有一种人叫做「别人家的妹妹」，小 A 对此感触颇深。\n\n小 A 的妹妹——小 L——经常把小 A 的藏书偷走看，小 A 对此很是头疼。\n\n这一次，强迫症小 A 正在收拾他的藏书，小 L 趁小 A 不注意偷走了一本。\n\n「还给我。」\n\n『不给。不过。。。如果你能猜出我手上的书的编号，我就还给你。』\n\n小 A 为了方便拿取和整理他的藏书，特意给每本书从一开始编了号。\n\n「开玩笑，我的书这么多，我怎么猜？」\n\n『嗯。这样吧，我告诉你剩下的那堆书的编号平均值。怎么样，这个提示够了吧。』\n\n「。。。」\n\n小 A 的藏书多到他都不知道有多少本，但是作为一个合格的 OIer，小 A 借助计算机成功算出了答案。只不过，他想要以这个问题来考验你一下。", "description": "你知道 $\\dfrac{\\left(\\sum\\limits^{n}_ {i = 1}i \\right) - m}{n - 1}$ 的值，其中 $m \\in [1, n]$，$n$ 和 $m$ 均为正整数，你要求出 $n$ 和 $m$ 的值，保证有解。\n\n如果有多种可行解，那么请输出 $n$ 较小的那一组解。\n\n多组测试数据。", "inputFormat": "第一行，一个正整数 $T$ 表示数据组数。\n\n接下来 $T$ 行，每行三个非负整数 $a, b, c$ ，表示平均值为 $a + \\dfrac{b}{c}$ 。", "outputFormat": "共 $T$ 行，每行两个正整数，分别表示 $n$ 和 $m$。", "hint": "**本题采用捆绑测试**。\n\n- Subtask 1（5 points）：$T \\leqslant 10$，$n \\leqslant 10^3$。\n- Subtask 2（5 points）：$T \\leqslant 10^3$，$n \\leqslant 10^3$。\n- Subtask 3（5 points）：$T \\leqslant 10$，$n \\leqslant 5\\times 10^5$。\n- Subtask 4（40 points）：$T \\leqslant 10^3$，$n \\leqslant 10^{18}$。\n- Subtask 5（45 points）：无特殊限制。\n\n对于所有数据，$1 \\leqslant m \\leqslant n \\leqslant 10 ^ {18}$，$n \\not = 1$，$1 \\leqslant T \\leqslant 2 \\times 10 ^{5}$，$1 \\leqslant a \\leqslant 10 ^{18}$，$0 \\leqslant b < c \\leqslant 10 ^ {18}$ 。\n\n**保证 $\\dfrac{b}{c}$ 是最简真分数。特别的，当 $b=0$ 时，$c=1$。**\n\n---\n\n**题目背景（续）**\n\n『你。。你是怎么猜出来？』\n\n小 L 说话之际，看着小 A 的眼神中的惊讶又多了一份崇拜。\n\n「呵，这种难度的问题怎么可能难得到我？」\n\n『啊。既然是这样子的话，那就再来玩一次吧！』\n\n「。。。」", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「TFOI R1」Average Number", "background": "**题目背景与题意无关，可直接阅读题目描述。**\n\n有一种人叫做「别人家的妹妹」，小 A 对此感触颇深。\n\n小 A 的妹妹——小 L——经常把小 A 的藏书偷走看，小 A 对此很是头疼。\n\n这一次，强迫症小 A 正在收拾他的藏书，小 L 趁小 A 不注意偷走了一本。\n\n「还给我。」\n\n『不给。不过。。。如果你能猜出我手上的书的编号，我就还给你。』\n\n小 A 为了方便拿取和整理他的藏书，特意给每本书从一开始编了号。\n\n「开玩笑，我的书这么多，我怎么猜？」\n\n『嗯。这样吧，我告诉你剩下的那堆书的编号平均值。怎么样，这个提示够了吧。』\n\n「。。。」\n\n小 A 的藏书多到他都不知道有多少本，但是作为一个合格的 OIer，小 A 借助计算机成功算出了答案。只不过，他想要以这个问题来考验你一下。", "description": "你知道 $\\dfrac{\\left(\\sum\\limits^{n}_ {i = 1}i \\right) - m}{n - 1}$ 的值，其中 $m \\in [1, n]$，$n$ 和 $m$ 均为正整数，你要求出 $n$ 和 $m$ 的值，保证有解。\n\n如果有多种可行解，那么请输出 $n$ 较小的那一组解。\n\n多组测试数据。", "inputFormat": "第一行，一个正整数 $T$ 表示数据组数。\n\n接下来 $T$ 行，每行三个非负整数 $a, b, c$ ，表示平均值为 $a + \\dfrac{b}{c}$ 。", "outputFormat": "共 $T$ 行，每行两个正整数，分别表示 $n$ 和 $m$。", "hint": "**本题采用捆绑测试**。\n\n- Subtask 1（5 points）：$T \\leqslant 10$，$n \\leqslant 10^3$。\n- Subtask 2（5 points）：$T \\leqslant 10^3$，$n \\leqslant 10^3$。\n- Subtask 3（5 points）：$T \\leqslant 10$，$n \\leqslant 5\\times 10^5$。\n- Subtask 4（40 points）：$T \\leqslant 10^3$，$n \\leqslant 10^{18}$。\n- Subtask 5（45 points）：无特殊限制。\n\n对于所有数据，$1 \\leqslant m \\leqslant n \\leqslant 10 ^ {18}$，$n \\not = 1$，$1 \\leqslant T \\leqslant 2 \\times 10 ^{5}$，$1 \\leqslant a \\leqslant 10 ^{18}$，$0 \\leqslant b < c \\leqslant 10 ^ {18}$ 。\n\n**保证 $\\dfrac{b}{c}$ 是最简真分数。特别的，当 $b=0$ 时，$c=1$。**\n\n---\n\n**题目背景（续）**\n\n『你。。你是怎么猜出来？』\n\n小 L 说话之际，看着小 A 的眼神中的惊讶又多了一份崇拜。\n\n「呵，这种难度的问题怎么可能难得到我？」\n\n『啊。既然是这样子的话，那就再来玩一次吧！』\n\n「。。。」", "locale": "zh-CN"}}}
{"pid": "P9704", "type": "P", "difficulty": 4, "samples": [["7 2\n5 1 7 12 5 9 6\n1 2 5\n3 1 1\n6 2 9\n4 6 14\n7 6 4\n5 2 10\n2 4 5 7\n1 1 3 3", "19211\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["线段树", "O2优化", "ST 表"], "title": "「TFOI R1」Tree Home", "background": "阳光开朗大男孩天才 Z 今天要向蕉太狼表白力！\n\n众所周知，蕉太狼是一个很可爱的女孩纸。\n从前的天才 Z 总是担心因为自己表白失败而受到别人的嘲笑。但是今天，天才 Z 就要做出自己一生中最重要的一件事，那就是真诚地表白，无论后果如何。\n\n出乎意料，蕉太狼其实也喜欢着天才 Z！\n\n天才 Z 开心得像个 0#。\n\n但是没过多久，天才 Z 就被甩力，原因蕉太狼发现天才 Z 对自己的闺蜜有非分之想。\n\n天才 Z 拿出了自己的树状家谱，问候起了自己的祖宗们。", "description": "有一个由 $n - 1$ 条**带权无向边**连接成的有 $n$ 个节点的树，每个节点都有它对应的**编号**以及**权值** $v_{i}$，整棵树的根节点为编号为 $1$ 的节点。\n\n令 $f(a, b, c) = (a - b) \\times \\left[a^2 + b^2 + a \\times b + 3 \\times c \\times (a + b + c)\\right]$，其中 $a,b,c$ 可以为任意整数。同时用 $d_i$ 表示 $i$ 到根节点的每条边的**边权**之和。\n\n现在天才 Z 要进行 $T$ 次询问，每次询问给定四个正整数 $l_{1},r_{1},l_{2},r_{2}$，你要从**编号**在区间 $[l_{1}, r_{1}]$ 和 $[l_{2}, r_{2}]$ 的点中各选择一个点 $p$ 和 $q$，当然你选择的两个点需要保证 $p \\neq q$。用 $r$ 表示 $p$ 和 $q$ 的最近公共祖先，要使得 $|f(d_{p} - d_{r}, d_{q} - d_{r}, d_{r})| + |v_{p} - v_{q}|$ 的值最大，而你需要对每次询问输出这个最大值。", "inputFormat": "第一行输入两个正整数 $n$ 和 $T$，表示这棵树的节点个数以及询问次数。\n\n第二行输入 $n$ 个整数，第 $i$ 个数表示编号为 $i$ 的节点的权值。\n\n接下来 $n - 1$ 行，每行输入三个整数 $u,v,w$，表示节点 $u$ 到节点 $v$ 之间有一条边权为 $w$ 的无向边。\n\n接下来 $T$ 行，每行输入四个整数 $l_{1},r_{1},l_{2},r_{2}$，表示一次询问（意义如题面所述）。", "outputFormat": "输出 $T$ 行，每行输出一个整数，表示每次询问的答案。", "hint": "#### 样例解释\n\n对于第一次询问，我们在两个区间分别取 $4$ 号点和 $6$ 号点即可得出答案 $19211$。\n\n对于第二次询问，两个区间都只能取一个节点，所以答案为 $3$。\n\n\n#### 数据范围\n\n**本题采用捆绑测试**。\n\n- Subtask 1（5 points）：$1 \\leqslant n, T \\leqslant 10$。\n- Subtask 2（10 points）：$1 \\leqslant n, T \\leqslant 100$。\n- Subtask 3（30 points）：$1 \\leqslant n, T \\leqslant 3000$。\n- Subtask 4（55 points）：无特殊限制。\n\n对于所有数据，$1 \\leqslant n, T \\leqslant 2 \\times 10^5$，$0 \\leqslant |w| \\leqslant 25$，$1 \\leqslant v_{x} \\leqslant 10^9$，$1 \\leqslant l_{1} \\leqslant r_{1} \\leqslant n$，$1 \\leqslant l_{2} \\leqslant r_{2} \\leqslant n$，保证树中最大深度不超过 $100$。\n\n**注意：两个区间 $[l_{1}, r_{1}]$ 和 $[l_{2}, r_{2}]$ 可能有重合部分。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「TFOI R1」Tree Home", "background": "阳光开朗大男孩天才 Z 今天要向蕉太狼表白力！\n\n众所周知，蕉太狼是一个很可爱的女孩纸。\n从前的天才 Z 总是担心因为自己表白失败而受到别人的嘲笑。但是今天，天才 Z 就要做出自己一生中最重要的一件事，那就是真诚地表白，无论后果如何。\n\n出乎意料，蕉太狼其实也喜欢着天才 Z！\n\n天才 Z 开心得像个 0#。\n\n但是没过多久，天才 Z 就被甩力，原因蕉太狼发现天才 Z 对自己的闺蜜有非分之想。\n\n天才 Z 拿出了自己的树状家谱，问候起了自己的祖宗们。", "description": "有一个由 $n - 1$ 条**带权无向边**连接成的有 $n$ 个节点的树，每个节点都有它对应的**编号**以及**权值** $v_{i}$，整棵树的根节点为编号为 $1$ 的节点。\n\n令 $f(a, b, c) = (a - b) \\times \\left[a^2 + b^2 + a \\times b + 3 \\times c \\times (a + b + c)\\right]$，其中 $a,b,c$ 可以为任意整数。同时用 $d_i$ 表示 $i$ 到根节点的每条边的**边权**之和。\n\n现在天才 Z 要进行 $T$ 次询问，每次询问给定四个正整数 $l_{1},r_{1},l_{2},r_{2}$，你要从**编号**在区间 $[l_{1}, r_{1}]$ 和 $[l_{2}, r_{2}]$ 的点中各选择一个点 $p$ 和 $q$，当然你选择的两个点需要保证 $p \\neq q$。用 $r$ 表示 $p$ 和 $q$ 的最近公共祖先，要使得 $|f(d_{p} - d_{r}, d_{q} - d_{r}, d_{r})| + |v_{p} - v_{q}|$ 的值最大，而你需要对每次询问输出这个最大值。", "inputFormat": "第一行输入两个正整数 $n$ 和 $T$，表示这棵树的节点个数以及询问次数。\n\n第二行输入 $n$ 个整数，第 $i$ 个数表示编号为 $i$ 的节点的权值。\n\n接下来 $n - 1$ 行，每行输入三个整数 $u,v,w$，表示节点 $u$ 到节点 $v$ 之间有一条边权为 $w$ 的无向边。\n\n接下来 $T$ 行，每行输入四个整数 $l_{1},r_{1},l_{2},r_{2}$，表示一次询问（意义如题面所述）。", "outputFormat": "输出 $T$ 行，每行输出一个整数，表示每次询问的答案。", "hint": "#### 样例解释\n\n对于第一次询问，我们在两个区间分别取 $4$ 号点和 $6$ 号点即可得出答案 $19211$。\n\n对于第二次询问，两个区间都只能取一个节点，所以答案为 $3$。\n\n\n#### 数据范围\n\n**本题采用捆绑测试**。\n\n- Subtask 1（5 points）：$1 \\leqslant n, T \\leqslant 10$。\n- Subtask 2（10 points）：$1 \\leqslant n, T \\leqslant 100$。\n- Subtask 3（30 points）：$1 \\leqslant n, T \\leqslant 3000$。\n- Subtask 4（55 points）：无特殊限制。\n\n对于所有数据，$1 \\leqslant n, T \\leqslant 2 \\times 10^5$，$0 \\leqslant |w| \\leqslant 25$，$1 \\leqslant v_{x} \\leqslant 10^9$，$1 \\leqslant l_{1} \\leqslant r_{1} \\leqslant n$，$1 \\leqslant l_{2} \\leqslant r_{2} \\leqslant n$，保证树中最大深度不超过 $100$。\n\n**注意：两个区间 $[l_{1}, r_{1}]$ 和 $[l_{2}, r_{2}]$ 可能有重合部分。**", "locale": "zh-CN"}}}
{"pid": "P9705", "type": "P", "difficulty": 5, "samples": [["4\n2 3 2 3\n2 3 2 3\n1\n1 3", "10\n1 2\n2 1\n2 3\n3 2\n2 4\n4 2\n4 1\n1 4\n4 3\n3 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["网络流", "Special Judge", "O2优化", "图论建模"], "title": "「TFOI R1」Unknown Graph", "background": "小 A 飘到了一个岛屿群里，这些岛屿都有单向桥相连接，没有两座桥连接的起始岛屿和终止岛屿都相同，更不会有桥连接一个岛屿。\n\n但这里全是迷雾，小 A 在一个岛上只能看到这个岛与多少座桥相连。\n\n小 A 想要知道整个岛屿群的形态，但是他并不会，所以找到了你。\n\n如果有多种情况，你只需要告诉小 A 任意一种就行。", "description": "有一张 $n$ 个节点的**无重边无自环的有向图**（可以不连通），每个节点的编号为 $1 \\sim n$，你知道每个节点的入度和出度。\n\n另外还有 $m$ 条限制，每条限制给定两个点 $x_{i}$ 和 $y_{i}$，表示图中不存在有向边 $(x_{i}, y_{i})$，请你求出一种满足要求的图的形态。\n\n若有多种情况，输出任意一种即可，保证有解。", "inputFormat": "第一行一个正整数 $n$ 表示节点数量。\n\n第二行 $n$ 个整数 $a_{i}$，表示编号为 $i$ 的节点的入度为 $a_{i}$。\n\n第三行 $n$ 个整数 $b_{i}$，表示编号为 $i$ 的节点的出度为 $b_{i}$。\n\n第四行一个整数 $m$，表示限制个数。\n\n对于接下来的 $m$ 行，每行两个正整数 $x_{i}, y_{i}$ 表示一组限制。", "outputFormat": "第一行一个正整数 $k$ 表示满足限制的图有多少条边。\n\n接下来 $k$ 行，每行两个正整数 $u_{i}$ 和 $v_{i}$ 表示编号为 $u_{i}$ 的结点和编号为 $v_{i}$ 的结点之间有一条有向边。", "hint": "**本题采用捆绑测试**。\n\n- Subtask 1（10 points）：$n \\leqslant 10$。\n- Subtask 2（10 points）：$n = 10^3$，$a_{i} = b_{i} = 1$，$m = 0$。\n- Subtask 3（20 points）：$n \\leqslant 100$。\n- Subtask 4（60 points）：无特殊限制。\n\n对于所有数据，$2 \\leqslant n \\leqslant 10^{3}$，$0 \\leqslant a_{i}, b_{i} < n$，$1\\leqslant \\sum{a_i} \\leqslant 10^{5}$，$0 \\leqslant m \\leqslant 5 \\times 10^4$，$1 \\leqslant x_i,y_i \\leqslant n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「TFOI R1」Unknown Graph", "background": "小 A 飘到了一个岛屿群里，这些岛屿都有单向桥相连接，没有两座桥连接的起始岛屿和终止岛屿都相同，更不会有桥连接一个岛屿。\n\n但这里全是迷雾，小 A 在一个岛上只能看到这个岛与多少座桥相连。\n\n小 A 想要知道整个岛屿群的形态，但是他并不会，所以找到了你。\n\n如果有多种情况，你只需要告诉小 A 任意一种就行。", "description": "有一张 $n$ 个节点的**无重边无自环的有向图**（可以不连通），每个节点的编号为 $1 \\sim n$，你知道每个节点的入度和出度。\n\n另外还有 $m$ 条限制，每条限制给定两个点 $x_{i}$ 和 $y_{i}$，表示图中不存在有向边 $(x_{i}, y_{i})$，请你求出一种满足要求的图的形态。\n\n若有多种情况，输出任意一种即可，保证有解。", "inputFormat": "第一行一个正整数 $n$ 表示节点数量。\n\n第二行 $n$ 个整数 $a_{i}$，表示编号为 $i$ 的节点的入度为 $a_{i}$。\n\n第三行 $n$ 个整数 $b_{i}$，表示编号为 $i$ 的节点的出度为 $b_{i}$。\n\n第四行一个整数 $m$，表示限制个数。\n\n对于接下来的 $m$ 行，每行两个正整数 $x_{i}, y_{i}$ 表示一组限制。", "outputFormat": "第一行一个正整数 $k$ 表示满足限制的图有多少条边。\n\n接下来 $k$ 行，每行两个正整数 $u_{i}$ 和 $v_{i}$ 表示编号为 $u_{i}$ 的结点和编号为 $v_{i}$ 的结点之间有一条有向边。", "hint": "**本题采用捆绑测试**。\n\n- Subtask 1（10 points）：$n \\leqslant 10$。\n- Subtask 2（10 points）：$n = 10^3$，$a_{i} = b_{i} = 1$，$m = 0$。\n- Subtask 3（20 points）：$n \\leqslant 100$。\n- Subtask 4（60 points）：无特殊限制。\n\n对于所有数据，$2 \\leqslant n \\leqslant 10^{3}$，$0 \\leqslant a_{i}, b_{i} < n$，$1\\leqslant \\sum{a_i} \\leqslant 10^{5}$，$0 \\leqslant m \\leqslant 5 \\times 10^4$，$1 \\leqslant x_i,y_i \\leqslant n$。", "locale": "zh-CN"}}}
{"pid": "P9706", "type": "P", "difficulty": 6, "samples": [["7 1\n1 4 3\n2 1 2\n3 1 6\n4 3 4\n5 2 4\n6 4 1\n7 5 2", "3\n5\n105\n160\n9\n176\n11"], ["7 1\n1 2 3\n2 3 2\n3 1 2\n4 1 3\n5 4 2\n6 2 1\n7 6 4", "18\n32\n46\n36\n48\n40\n72"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "O2优化", "前缀和", "基环树", "差分"], "title": "「TFOI R1」Ride the Wind and Waves", "background": "Z 教授是 C 班的老师。\n\nZ 教授最近发现一个神奇的现象，他的学生竟然都有自己暗恋的对象，但是没有一个人勇于表白。\n\nZ 教授作为过来人，当然懂得每一个学生心里最真实纯真的想法，以及自认为的爱意情愫。Z 教授想起了初恋蕉太狼，他不想让自己的学生在青春年华失去色彩，于是 Z 教授冒着被开除的风险，主动帮助学生表达心意。\n\n然后 Z 教授被开除了。", "description": "有一棵 $n$ 个节点的内向基环树（**保证弱连通**），树上每条边都有一个权值。现有一个特定参数 $k$。\n\n由于基环树是内向的，所以一个点 $x$ 可能会有无法直接到达的节点。但是我们可以翻转树上的一些有向边，这样 $x$ 就可以到达树上每一个节点。如果一个节点 $x$ 需要**至少**翻转 $k$ 条边才能到达 $y$，则称 $y$ 是 $x$ 的乘风破浪点。在翻转了**最少的边**使得 $x$ 可以到达 $y$ 之后，在 $x$ 到 $y$ 的最短路径上，定义 $F(x, y)$ 为**未翻转**的边的权值之和，$R(x, y)$ 为**已翻转**的边的权值之和。\n\n如果 $y$ 是 $x$ 的乘风破浪点，那么有一个值 $G(x, y)$ 表示 $x$ 到 $y$ 的浪涛值，定义 $G(x, y) = F(x, y) \\times  R(x,y)$。\n\n请你对于每一个节点 $i$，输出 $\\sum G(i, y)$ 的值，其中 $y$ 是 $i$ 的乘风破浪点。", "inputFormat": "第一行输入两个正整数 $n, k$，表示基环树大小和一个比较的参数。\n\n接下来 $n$ 行，每行输入 $u, v, w$ 三个正整数，表示树上存在一条边 $(u, v, w)$，表示其起点为 $u$，终点为 $v$，权值为 $w$。", "outputFormat": "输出 $n$ 行，每行一个正整数，表示每个节点到它的所有乘风破浪点的浪涛值之和。", "hint": "#### 样例解释 #1\n\n拿 $3$ 节点的答案为例子，基环树的形状如图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a3ocyi6o.png)\n\n可知 $2,5,6,7$ 为 $3$ 的乘风破浪点，统计答案：\n\n- $G(3, 2) = 6 \\times 2 = 12$。\n\n- $G(3, 5) = 6 \\times 6 = 36$。\n\n- $G(3, 6) = 9 \\times 1 = 9$。\n\n- $G(3, 7) = 6 \\times 8 = 48$。\n\n所以 $\\sum G(3, j) = 12 + 36 + 9 + 48$，答案为 $105$。\n\n#### 数据范围\n\n**本题采用捆绑测试**。\n\n- Subtask 1（5 points）：$1 \\leqslant n \\leqslant 10$，**包含特殊性质**。\n- Subtask 2（10 points）：$1 \\leqslant n \\leqslant 5000$，**包含特殊性质**。\n- Subtask 3（25 points）：$1 \\leqslant n \\leqslant 10^5$，**包含特殊性质**。\n- Subtask 4（60 points）：$1 \\leqslant n \\leqslant 10^6$，无特殊限制。\n\n**特殊性质：保证环上节点的个数在 $10^3$ 以内。**\n\n对于所有数据，$1 \\leqslant n \\leqslant 10^6$，$1 \\leqslant k \\leqslant 10$，保证答案不会超过 $10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「TFOI R1」Ride the Wind and Waves", "background": "Z 教授是 C 班的老师。\n\nZ 教授最近发现一个神奇的现象，他的学生竟然都有自己暗恋的对象，但是没有一个人勇于表白。\n\nZ 教授作为过来人，当然懂得每一个学生心里最真实纯真的想法，以及自认为的爱意情愫。Z 教授想起了初恋蕉太狼，他不想让自己的学生在青春年华失去色彩，于是 Z 教授冒着被开除的风险，主动帮助学生表达心意。\n\n然后 Z 教授被开除了。", "description": "有一棵 $n$ 个节点的内向基环树（**保证弱连通**），树上每条边都有一个权值。现有一个特定参数 $k$。\n\n由于基环树是内向的，所以一个点 $x$ 可能会有无法直接到达的节点。但是我们可以翻转树上的一些有向边，这样 $x$ 就可以到达树上每一个节点。如果一个节点 $x$ 需要**至少**翻转 $k$ 条边才能到达 $y$，则称 $y$ 是 $x$ 的乘风破浪点。在翻转了**最少的边**使得 $x$ 可以到达 $y$ 之后，在 $x$ 到 $y$ 的最短路径上，定义 $F(x, y)$ 为**未翻转**的边的权值之和，$R(x, y)$ 为**已翻转**的边的权值之和。\n\n如果 $y$ 是 $x$ 的乘风破浪点，那么有一个值 $G(x, y)$ 表示 $x$ 到 $y$ 的浪涛值，定义 $G(x, y) = F(x, y) \\times  R(x,y)$。\n\n请你对于每一个节点 $i$，输出 $\\sum G(i, y)$ 的值，其中 $y$ 是 $i$ 的乘风破浪点。", "inputFormat": "第一行输入两个正整数 $n, k$，表示基环树大小和一个比较的参数。\n\n接下来 $n$ 行，每行输入 $u, v, w$ 三个正整数，表示树上存在一条边 $(u, v, w)$，表示其起点为 $u$，终点为 $v$，权值为 $w$。", "outputFormat": "输出 $n$ 行，每行一个正整数，表示每个节点到它的所有乘风破浪点的浪涛值之和。", "hint": "#### 样例解释 #1\n\n拿 $3$ 节点的答案为例子，基环树的形状如图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a3ocyi6o.png)\n\n可知 $2,5,6,7$ 为 $3$ 的乘风破浪点，统计答案：\n\n- $G(3, 2) = 6 \\times 2 = 12$。\n\n- $G(3, 5) = 6 \\times 6 = 36$。\n\n- $G(3, 6) = 9 \\times 1 = 9$。\n\n- $G(3, 7) = 6 \\times 8 = 48$。\n\n所以 $\\sum G(3, j) = 12 + 36 + 9 + 48$，答案为 $105$。\n\n#### 数据范围\n\n**本题采用捆绑测试**。\n\n- Subtask 1（5 points）：$1 \\leqslant n \\leqslant 10$，**包含特殊性质**。\n- Subtask 2（10 points）：$1 \\leqslant n \\leqslant 5000$，**包含特殊性质**。\n- Subtask 3（25 points）：$1 \\leqslant n \\leqslant 10^5$，**包含特殊性质**。\n- Subtask 4（60 points）：$1 \\leqslant n \\leqslant 10^6$，无特殊限制。\n\n**特殊性质：保证环上节点的个数在 $10^3$ 以内。**\n\n对于所有数据，$1 \\leqslant n \\leqslant 10^6$，$1 \\leqslant k \\leqslant 10$，保证答案不会超过 $10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P9707", "type": "P", "difficulty": 1, "samples": [["1 3 4", "2"], ["3 6 10", "6"], ["100 1000 911451407", "911273936"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": [], "title": "[KMOI R1] 音波武器", "background": "在 [对 $Y$ 星的军事行动](/problem/P9709) 中，舰队在攻占城市 $p$ 时遇到了一些困难。", "description": "小袁的舰队采用使用音波武器攻击的方式，但是对方的城墙使用了一种特殊材料——普林，导致音波攻击效果不是很好。\n\n我们定义**削弱系数 $m$** 为：收到强度为 $n$ 的音波时，音波在穿透普林后会被削弱为 $n\\bmod m$ 强度的音波。\n\n现在小袁发射了强度为 $l!,(l+1)!,(l+2)!\\dots (r-1)!,r!$ 的 $r-l+1$ 个音波，对方使用了削弱系数为 $k$ 的普林。现在小袁想知道，经过削弱后强度最大的音波的强度是多少。\n\n符号 $!$ 在这里表示阶乘，$x!=1\\times 2\\times\\dots\\times x$。例如 $4!=1\\times2\\times3\\times4$。特别地， $0!=1$。", "inputFormat": "三个正整数 $l,r,k$，意义如上。", "outputFormat": "一个整数 $ans$，表示最大的强度。", "hint": "## 样例 $1$ 解释\n\n最终强度分别是 $1,2,2$，故输出 $2$。\n\n## 样例 $2$ 解释\n\n最终强度分别是 $6,4,0,0$，故输出 $6$。\n\n## 数据范围\n\n对于 $20\\%$ 的数据：$1\\le l\\le r\\le 20$，$1\\le k\\le 10^2$。\n\n对于 $50\\%$ 的数据：$1\\le l\\le r\\le 2000$，$1\\le k\\le 10^5$。\n\n对于 $100\\%$ 的数据：$1\\le l\\le r\\le 2\\times 10^6$，$1\\le k\\le 10^{12}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KMOI R1] 音波武器", "background": "在 [对 $Y$ 星的军事行动](/problem/P9709) 中，舰队在攻占城市 $p$ 时遇到了一些困难。", "description": "小袁的舰队采用使用音波武器攻击的方式，但是对方的城墙使用了一种特殊材料——普林，导致音波攻击效果不是很好。\n\n我们定义**削弱系数 $m$** 为：收到强度为 $n$ 的音波时，音波在穿透普林后会被削弱为 $n\\bmod m$ 强度的音波。\n\n现在小袁发射了强度为 $l!,(l+1)!,(l+2)!\\dots (r-1)!,r!$ 的 $r-l+1$ 个音波，对方使用了削弱系数为 $k$ 的普林。现在小袁想知道，经过削弱后强度最大的音波的强度是多少。\n\n符号 $!$ 在这里表示阶乘，$x!=1\\times 2\\times\\dots\\times x$。例如 $4!=1\\times2\\times3\\times4$。特别地， $0!=1$。", "inputFormat": "三个正整数 $l,r,k$，意义如上。", "outputFormat": "一个整数 $ans$，表示最大的强度。", "hint": "## 样例 $1$ 解释\n\n最终强度分别是 $1,2,2$，故输出 $2$。\n\n## 样例 $2$ 解释\n\n最终强度分别是 $6,4,0,0$，故输出 $6$。\n\n## 数据范围\n\n对于 $20\\%$ 的数据：$1\\le l\\le r\\le 20$，$1\\le k\\le 10^2$。\n\n对于 $50\\%$ 的数据：$1\\le l\\le r\\le 2000$，$1\\le k\\le 10^5$。\n\n对于 $100\\%$ 的数据：$1\\le l\\le r\\le 2\\times 10^6$，$1\\le k\\le 10^{12}$。", "locale": "zh-CN"}}}
{"pid": "P9708", "type": "P", "difficulty": 3, "samples": [["2", "4"], ["1000", "476463243"], ["1919810", "193840227"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "O2优化", "构造"], "title": "[KMOI R1] 集合 First", "background": "", "description": "有一个集合 $A=\\{1,2,3\\dots,n\\}$。\n\n定义交替和 $G(B)$ 如下：\n\n- 把集合 $B$ 中的元素从大到小排序，得到 $B=\\{b_1,b_2\\dots,b_{cnt}\\}$（$cnt$ 为集合元素个数）。则 $G(B)=\\sum\\limits_{i=1}^{cnt}\\Big((-1)^{i+1}\\times b_i\\Big)$。\n\n例如 $G(\\{1,2,4,6,9\\})=9-6+4-2+1=6$。\n\n特别地，$G(\\empty)=0$。\n\n现在，给定集合 $A=\\{1,2,3,\\dots,n\\}$，小谢想知道对于 $A$ 的**任意子集 $P$**，求出 $G(P)$ 的总和。\n\n由于小谢太菜了，所以请你帮帮忙，**答案对 $911451407$ 取模。**", "inputFormat": "一个正整数 $n$，表示给定的集合 $A=\\{1,2,3,\\dots,n\\}$。", "outputFormat": "一个正整数 $ans$，表示对于 $A$ 的**任意子集 $P$**，$G(P)$ 的总和。\n\n**答案对 $911451407$ 取模。**", "hint": "## 样例 $1$ 解释\n$G(\\empty)=0$\n\n$G(\\{1\\})=1$\n\n$G(\\{1,2\\})=1$\n\n$G(\\{2\\})=2$\n\n故 $ans=G(\\empty)+G(\\{1\\})+G(\\{1,2\\})+G(\\{2\\})=4$。\n\n## 数据范围\n\n**本题采用 subtask 捆绑测试。**\n\n|子任务编号| 测试点 | $n\\le$ | 分值 |\n|:-:| :----------: | :----------: | :----------: |\n|$1$| $1,2$ | $20$ | $15$ |\n|$2$| $3\\sim5$ | $10^3$ | $10$ |\n|$3$| $6\\sim10$ | $10^{9}$ | $30$ |\n|$4$| $11\\sim17$ | $10^{16}$ | $45$ |\n\n对于 $100\\%$ 的数据：$1\\le n\\le 10^{16}$。\n\n## 后记\n\n$$\\color{orange}{小谢：别打我，我下次再也不研究大小超过\\ 30\\ 的集合了。}$$\n\n$$\\color{purple}{你：我*****}$$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KMOI R1] 集合 First", "background": "", "description": "有一个集合 $A=\\{1,2,3\\dots,n\\}$。\n\n定义交替和 $G(B)$ 如下：\n\n- 把集合 $B$ 中的元素从大到小排序，得到 $B=\\{b_1,b_2\\dots,b_{cnt}\\}$（$cnt$ 为集合元素个数）。则 $G(B)=\\sum\\limits_{i=1}^{cnt}\\Big((-1)^{i+1}\\times b_i\\Big)$。\n\n例如 $G(\\{1,2,4,6,9\\})=9-6+4-2+1=6$。\n\n特别地，$G(\\empty)=0$。\n\n现在，给定集合 $A=\\{1,2,3,\\dots,n\\}$，小谢想知道对于 $A$ 的**任意子集 $P$**，求出 $G(P)$ 的总和。\n\n由于小谢太菜了，所以请你帮帮忙，**答案对 $911451407$ 取模。**", "inputFormat": "一个正整数 $n$，表示给定的集合 $A=\\{1,2,3,\\dots,n\\}$。", "outputFormat": "一个正整数 $ans$，表示对于 $A$ 的**任意子集 $P$**，$G(P)$ 的总和。\n\n**答案对 $911451407$ 取模。**", "hint": "## 样例 $1$ 解释\n$G(\\empty)=0$\n\n$G(\\{1\\})=1$\n\n$G(\\{1,2\\})=1$\n\n$G(\\{2\\})=2$\n\n故 $ans=G(\\empty)+G(\\{1\\})+G(\\{1,2\\})+G(\\{2\\})=4$。\n\n## 数据范围\n\n**本题采用 subtask 捆绑测试。**\n\n|子任务编号| 测试点 | $n\\le$ | 分值 |\n|:-:| :----------: | :----------: | :----------: |\n|$1$| $1,2$ | $20$ | $15$ |\n|$2$| $3\\sim5$ | $10^3$ | $10$ |\n|$3$| $6\\sim10$ | $10^{9}$ | $30$ |\n|$4$| $11\\sim17$ | $10^{16}$ | $45$ |\n\n对于 $100\\%$ 的数据：$1\\le n\\le 10^{16}$。\n\n## 后记\n\n$$\\color{orange}{小谢：别打我，我下次再也不研究大小超过\\ 30\\ 的集合了。}$$\n\n$$\\color{purple}{你：我*****}$$", "locale": "zh-CN"}}}
{"pid": "P9709", "type": "P", "difficulty": 4, "samples": [["2 20\n1 1\n1 3", "3"], ["3 150\n1 2\n2 4\n4 3", "4"], ["10 10\n1 4\n2 3\n2 6\n3 6\n10 3\n1 5\n4 2\n5 3\n2 8\n9 2", "23"], ["查看附件的 example4.in", "查看附件的 example4.out"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["O2优化", "广度优先搜索 BFS", "生成树"], "title": "[KMOI R1] 军事行动", "background": "$$\\blue{他们来了。}$$\n\n$$\\purple{集结军队，干掉他们，一个不留。}$$\n\n$$\\blue{是！}$$", "description": "喵星边境局势愈发紧张，导致发生边境冲突。喵星军队总司令小袁立即对 $Y$ 星采取军事行动。\n\n整个宇宙可以看作一个平面直角坐标系，城市 $1,2,\\dots,n$ 的坐标分别为 $(x_1,y_1),(x_2,y_2),\\dots(x_n,y_n)$。\n\n现在小袁率领的**若干支**舰队（可以理解为小袁的军事力量是无限的）驻扎在边境要塞，城市 $1$ 处。他的舰队会进行以下移动：\n\n- 如果舰队的坐标为 $(x,y)$，那么一天之后它可以移动到 $(x-1,y+2)$ 或 $(x+1,y+2)$ 或 $(x+2,y+1)$ 或 $(x-2,y+1)$ 或 $(x-1,y-2)$ 或 $(x+1,y-2)$ 或 $(x+2,y-1)$ 或 $(x-2,y-1)$ 处。\n\n其中环绕在外的还有一条小行星带，当舰队的坐标  $(x,y)$ 且 $x\\le 0$ 或 $y\\le 0$ 或 $m < x$ 或 $m < y$ 时，舰队就会撞到小行星带。这是小袁所不想看到的。\n\n现在小袁要攻打城市 $2,3,\\dots,n$，每一次他都会从一个**已经占领**的城市（城市 $1$ 也算），派出舰队前往城市 $i$ 并攻打它，舰队**到达之后的第二天**城市 $i$ 就被攻占了。\n\n特别的，小袁在一个舰队**前往攻打或攻打一个城市**的时候不会派出另外一支舰队，在**攻占一座城市后当天**可以立即派出另外一支舰队。\n\n小袁想问，最少要花多少时间才能攻占所有的城市。\n\n**攻打顺序可以不按照 $2,3\\dots n$ 的顺序。**", "inputFormat": "第一行一个整数 $n,m$，表示城市个数和小行星带的范围。\n\n接下来 $n$ 行，每一行两个正整数 $(x_i,y_i)$，表示城市 $i$ 的坐标。**保证 $1\\le x_i,y_i \\le m$**。", "outputFormat": "一个整数 $ans$，表示最少要花的时间。", "hint": "## 样例一解释：\n\n舰队在第一天来到了 $(3,2)$ 的位置，第二天到达了城市 $2$ 的位置，第三天占领了城市 $2$。总共花了 $3$ 天。\n\n## 样例二解释：\n\n舰队在第一天到达了城市 $2$ 的位置，第二天占领了城市 $2$。第三天到达了城市 $3$ 的位置，第四天占领了城市 $3$。总共花了 $4$ 天。\n\n## 数据范围\n\n**本题采用 Subtask 捆绑测试。**\n\n|子任务编号|  测试点编号| $n$ | $m$ |特殊性质|分值|\n|:-----:| :----------: | :----------: | :----------: | :----------: |:---:|\n|$1$| $1\\sim2$ | $1\\le n\\le 7$ |$4\\le m\\le 7$|无|$10$|\n|$2$| $3\\sim7$ | $1\\le n\\le 200$ |$4\\le m\\le 70$|无|$25$|\n|$3$| $8\\sim9$ | $1\\le n\\le 150$ |$4\\le m\\le 150$|有|$15$|\n|$4$| $10\\sim20$ | $1\\le n\\le 2000$ |$4\\le m\\le 150$|无|$50$|\n\n特殊性质：对于每一个 $1\\le i\\le n-1$，都有 $x_i = x_{i+1}$。\n\n**数据严格保证不会有不同的城市拥有相同的坐标。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KMOI R1] 军事行动", "background": "$$\\blue{他们来了。}$$\n\n$$\\purple{集结军队，干掉他们，一个不留。}$$\n\n$$\\blue{是！}$$", "description": "喵星边境局势愈发紧张，导致发生边境冲突。喵星军队总司令小袁立即对 $Y$ 星采取军事行动。\n\n整个宇宙可以看作一个平面直角坐标系，城市 $1,2,\\dots,n$ 的坐标分别为 $(x_1,y_1),(x_2,y_2),\\dots(x_n,y_n)$。\n\n现在小袁率领的**若干支**舰队（可以理解为小袁的军事力量是无限的）驻扎在边境要塞，城市 $1$ 处。他的舰队会进行以下移动：\n\n- 如果舰队的坐标为 $(x,y)$，那么一天之后它可以移动到 $(x-1,y+2)$ 或 $(x+1,y+2)$ 或 $(x+2,y+1)$ 或 $(x-2,y+1)$ 或 $(x-1,y-2)$ 或 $(x+1,y-2)$ 或 $(x+2,y-1)$ 或 $(x-2,y-1)$ 处。\n\n其中环绕在外的还有一条小行星带，当舰队的坐标  $(x,y)$ 且 $x\\le 0$ 或 $y\\le 0$ 或 $m < x$ 或 $m < y$ 时，舰队就会撞到小行星带。这是小袁所不想看到的。\n\n现在小袁要攻打城市 $2,3,\\dots,n$，每一次他都会从一个**已经占领**的城市（城市 $1$ 也算），派出舰队前往城市 $i$ 并攻打它，舰队**到达之后的第二天**城市 $i$ 就被攻占了。\n\n特别的，小袁在一个舰队**前往攻打或攻打一个城市**的时候不会派出另外一支舰队，在**攻占一座城市后当天**可以立即派出另外一支舰队。\n\n小袁想问，最少要花多少时间才能攻占所有的城市。\n\n**攻打顺序可以不按照 $2,3\\dots n$ 的顺序。**", "inputFormat": "第一行一个整数 $n,m$，表示城市个数和小行星带的范围。\n\n接下来 $n$ 行，每一行两个正整数 $(x_i,y_i)$，表示城市 $i$ 的坐标。**保证 $1\\le x_i,y_i \\le m$**。", "outputFormat": "一个整数 $ans$，表示最少要花的时间。", "hint": "## 样例一解释：\n\n舰队在第一天来到了 $(3,2)$ 的位置，第二天到达了城市 $2$ 的位置，第三天占领了城市 $2$。总共花了 $3$ 天。\n\n## 样例二解释：\n\n舰队在第一天到达了城市 $2$ 的位置，第二天占领了城市 $2$。第三天到达了城市 $3$ 的位置，第四天占领了城市 $3$。总共花了 $4$ 天。\n\n## 数据范围\n\n**本题采用 Subtask 捆绑测试。**\n\n|子任务编号|  测试点编号| $n$ | $m$ |特殊性质|分值|\n|:-----:| :----------: | :----------: | :----------: | :----------: |:---:|\n|$1$| $1\\sim2$ | $1\\le n\\le 7$ |$4\\le m\\le 7$|无|$10$|\n|$2$| $3\\sim7$ | $1\\le n\\le 200$ |$4\\le m\\le 70$|无|$25$|\n|$3$| $8\\sim9$ | $1\\le n\\le 150$ |$4\\le m\\le 150$|有|$15$|\n|$4$| $10\\sim20$ | $1\\le n\\le 2000$ |$4\\le m\\le 150$|无|$50$|\n\n特殊性质：对于每一个 $1\\le i\\le n-1$，都有 $x_i = x_{i+1}$。\n\n**数据严格保证不会有不同的城市拥有相同的坐标。**", "locale": "zh-CN"}}}
{"pid": "P9710", "type": "P", "difficulty": 2, "samples": [["2\n5 5", "4"], ["4\n1 1 4 5", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["递推", "O2优化"], "title": "[KMOI R1] 五五五五（Easy）", "background": "“迟序之数，非出神怪，有形可检，有数可推。”——祖冲之", "description": "小宋有一个序列 $a_1,a_2\\dots,a_n$，其中对于 $i\\in [1,n]$，满足 $a_i\\in[0,9]$。\n\n对于 $1\\le l\\le r\\le n$，他记 $f(l,r)$ 等于 $\\overline{a_la_{(l+1)}\\dots a_r}$ 的末尾连续 $5$ 的个数。\n\n例如：对于序列 $a=\\{1,1,4,5,1,4\\}$，$f(2,4)=1,f(1,3)=0$。\n\n现在请你求出:\n\n$$\\Big(\\sum\\limits_{l=1}^\n{n}\\sum\\limits_{r=l}^{n} f(l,r)\\Big) \\bmod 10^9+7$$", "inputFormat": "第一行一个正整数 $n$，表示序列的长度。\n\n第二行 $n$ 个整数 $a_1,a_2,\\dots,a_n$，表示序列 $a$。", "outputFormat": "一个正整数 $ans$，表示答案。", "hint": "## 样例 $1$ 解释：\n\n$f(1,1)=1$。\n\n$f(1,2)=2$。\n\n$f(2,2)=1$。\n\n得到答案 $ans=f(1,1)+f(1,2)+f(2,2)=4$，故输出 $4$。\n\n## 数据范围\n\n**本题采用 subtask 捆绑测试。**\n\n令 $m=\\max\\{a_1,a_2,\\dots,a_n\\}$。\n\n| 子任务编号 | 测试点编号 | $n\\le$ | $m\\le$ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $1$ | $100$ | $3$ | 无 | $3$ |\n| $2$ | $2\\sim 4$ | $2\\times 10^5$ | $5$ | $\\mathbf{A}$ | $22$ |\n| $3$ | $5,6$ | $100$ | $5$ | 无 | $10$ |\n| $4$ | $7\\sim 10$ | $2\\times 10^5$ | $5$ | $\\mathbf{B}$ | $25$ |\n| $5$ | $11\\sim 20$ | $2\\times 10^5$ | $9$ | 无 | $40$ |\n\n特殊性质 $\\mathbf{A}:$ 序列平均数为 $5$。\n\n特殊性质 $\\mathbf{B}:$ 序列单调不上升。\n\n对于 $100\\%$ 的数据：$1\\le n\\le 2\\times 10^5$，$0\\le m\\le 9$。\n\n对于 $\\forall i\\in [1,n]$，满足 $a_i\\in[0,9]$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KMOI R1] 五五五五（Easy）", "background": "“迟序之数，非出神怪，有形可检，有数可推。”——祖冲之", "description": "小宋有一个序列 $a_1,a_2\\dots,a_n$，其中对于 $i\\in [1,n]$，满足 $a_i\\in[0,9]$。\n\n对于 $1\\le l\\le r\\le n$，他记 $f(l,r)$ 等于 $\\overline{a_la_{(l+1)}\\dots a_r}$ 的末尾连续 $5$ 的个数。\n\n例如：对于序列 $a=\\{1,1,4,5,1,4\\}$，$f(2,4)=1,f(1,3)=0$。\n\n现在请你求出:\n\n$$\\Big(\\sum\\limits_{l=1}^\n{n}\\sum\\limits_{r=l}^{n} f(l,r)\\Big) \\bmod 10^9+7$$", "inputFormat": "第一行一个正整数 $n$，表示序列的长度。\n\n第二行 $n$ 个整数 $a_1,a_2,\\dots,a_n$，表示序列 $a$。", "outputFormat": "一个正整数 $ans$，表示答案。", "hint": "## 样例 $1$ 解释：\n\n$f(1,1)=1$。\n\n$f(1,2)=2$。\n\n$f(2,2)=1$。\n\n得到答案 $ans=f(1,1)+f(1,2)+f(2,2)=4$，故输出 $4$。\n\n## 数据范围\n\n**本题采用 subtask 捆绑测试。**\n\n令 $m=\\max\\{a_1,a_2,\\dots,a_n\\}$。\n\n| 子任务编号 | 测试点编号 | $n\\le$ | $m\\le$ | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $1$ | $100$ | $3$ | 无 | $3$ |\n| $2$ | $2\\sim 4$ | $2\\times 10^5$ | $5$ | $\\mathbf{A}$ | $22$ |\n| $3$ | $5,6$ | $100$ | $5$ | 无 | $10$ |\n| $4$ | $7\\sim 10$ | $2\\times 10^5$ | $5$ | $\\mathbf{B}$ | $25$ |\n| $5$ | $11\\sim 20$ | $2\\times 10^5$ | $9$ | 无 | $40$ |\n\n特殊性质 $\\mathbf{A}:$ 序列平均数为 $5$。\n\n特殊性质 $\\mathbf{B}:$ 序列单调不上升。\n\n对于 $100\\%$ 的数据：$1\\le n\\le 2\\times 10^5$，$0\\le m\\le 9$。\n\n对于 $\\forall i\\in [1,n]$，满足 $a_i\\in[0,9]$。", "locale": "zh-CN"}}}
{"pid": "P9711", "type": "P", "difficulty": 5, "samples": [["3 4\n1 5 5\n1 3 3\n3\n1 1 5\n4 1 3", "2\n13"], ["6 5\n1 1 4 5 1 4\n3\n2\n3\n1 1 5\n4 1 4", "4\n3\n15"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "平衡树", "树状数组", "O2优化"], "title": "[KMOI R1] 五五五五（Hard）", "background": "“事类相推，各有攸归，故枝条虽分而同本干知，发其一端而已。又所析理以辞，解体用图，庶亦约而能周，通而不黩，览之者思过半矣。”——刘徽\n", "description": "小宋有一个序列 $A=\\{a_1,a_2\\dots,a_n\\}$，其中 $\\forall i\\in [1,n],a_i\\in[0,9]$。\n\n对于 $1\\le l\\le r\\le n$，他记 $f(l,r)$ 等于 $\\overline{a_la_{(l+1)}\\dots a_r}$ 的末尾连续 $5$ 的个数。\n\n例如：对于序列 $a=\\{1,1,4,5,1,4\\}$，$f(2,4)=1,f(1,3)=0$。\n\n不过小宋会对这个序列不断地操作，具体地，他会做以下操作：\n\n- $(1,x,y)$：将第 $x$ 个数改为 $y$（$x\\in[1,n],y\\in[0,9]$）。\n\n- $2$: 将序列 $a$ 反转，例如 $\\{1,1,4,5\\}$ 反转之后就是 $\\{5,4,1,1\\}$。\n\n- $3$：对序列进行询问。\n\n- $(4,l,r)$：对序列进行询问。\n\n对于每一种操作 $3$，请你输出:\n\n$$\\Big(\\sum\\limits_{l=1}^\n{n}\\sum\\limits_{r=l}^{n} f(l,r)\\Big) \\bmod 10^9+7$$\n\n对于每一个操作 $4$，请你输出：\n\n$$\\Big(\\sum\\limits_{i=l}^{r}a_i\\Big) \\bmod 10^9+7$$", "inputFormat": "第一行两个正整数 $n,q$，表示序列的数个数和询问的个数。\n\n第二行 $n$ 个整数 $a_1, a_2,\\dots a_n$，表示序列 $A$。\n\n接下来 $q$ 行，每行一个或三个正整数，表示一次操作。", "outputFormat": "对于每一次操作 $3$ 和操作 $4$，输出答案。", "hint": "## 样例 $1$ 解释：\n\n| 操作 | 操作后的序列 | 答案 |\n| :----------: | :----------: | :----------: |\n| $(1,3,3)$ | $\\{1,5,3\\}$ | $/$ |\n| $3$ | $/$ | $2$ |\n| $(1,1,5)$ | $\\{5,5,3\\}$ | $/$ |\n| $(4,1,3)$ | $/$ | $13$ |\n\n## 样例 $2$ 解释：\n\n| 操作 | 操作后的序列 | 答案 |\n| :----------: | :----------: | :----------: |\n| $3$ | $/$ | $4$ |\n| $2$ | $\\{4,1,5,4,1,1\\}$ | $/$ |\n| $3$ | $/$ | $3$ |\n| $(1,1,5)$ | $\\{5,1,5,4,1,1\\}$ | $/$ |\n|$(4,1,4)$|$/$|$15$|\n## 数据范围\n| 测试点编号 | $n\\le$ |$q\\le$| 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |\n|$1$|$100$|$100$|$/$|\n|$2,3$|$10^3$|$10^3$|$\\mathbf{A}$|\n|$4$|$10^3$|$10^3$|$\\mathbf{B}$|\n|$5\\sim10$|$2\\times 10^5$|$2\\times 10^5$|$/$|\n|$11\\sim13$|$2\\times 10^5$|$2\\times 10^5$|$\\mathbf{A}$|\n|$14,15$|$2\\times 10^5$|$2\\times 10^5$|$/$|\n|$16\\sim18$|$5\\times 10^5$|$5\\times 10^5$|$\\mathbf{B}$|\n|$19\\sim25$|$5\\times 10^5$|$5\\times 10^5$|$/$|\n\n特殊性质 $\\mathbf{A}:$ 没有操作 $2$。\n\n特殊性质 $\\mathbf{B}:$ 没有操作 $3$。\n\n对于 $100\\%$ 的数据：$1\\le n\\le 5\\times 10^5$，$1\\le q\\le 5\\times 10^5$。\n\n $\\forall i\\in [1,n]$，满足 $a_i\\in[0,9]$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KMOI R1] 五五五五（Hard）", "background": "“事类相推，各有攸归，故枝条虽分而同本干知，发其一端而已。又所析理以辞，解体用图，庶亦约而能周，通而不黩，览之者思过半矣。”——刘徽\n", "description": "小宋有一个序列 $A=\\{a_1,a_2\\dots,a_n\\}$，其中 $\\forall i\\in [1,n],a_i\\in[0,9]$。\n\n对于 $1\\le l\\le r\\le n$，他记 $f(l,r)$ 等于 $\\overline{a_la_{(l+1)}\\dots a_r}$ 的末尾连续 $5$ 的个数。\n\n例如：对于序列 $a=\\{1,1,4,5,1,4\\}$，$f(2,4)=1,f(1,3)=0$。\n\n不过小宋会对这个序列不断地操作，具体地，他会做以下操作：\n\n- $(1,x,y)$：将第 $x$ 个数改为 $y$（$x\\in[1,n],y\\in[0,9]$）。\n\n- $2$: 将序列 $a$ 反转，例如 $\\{1,1,4,5\\}$ 反转之后就是 $\\{5,4,1,1\\}$。\n\n- $3$：对序列进行询问。\n\n- $(4,l,r)$：对序列进行询问。\n\n对于每一种操作 $3$，请你输出:\n\n$$\\Big(\\sum\\limits_{l=1}^\n{n}\\sum\\limits_{r=l}^{n} f(l,r)\\Big) \\bmod 10^9+7$$\n\n对于每一个操作 $4$，请你输出：\n\n$$\\Big(\\sum\\limits_{i=l}^{r}a_i\\Big) \\bmod 10^9+7$$", "inputFormat": "第一行两个正整数 $n,q$，表示序列的数个数和询问的个数。\n\n第二行 $n$ 个整数 $a_1, a_2,\\dots a_n$，表示序列 $A$。\n\n接下来 $q$ 行，每行一个或三个正整数，表示一次操作。", "outputFormat": "对于每一次操作 $3$ 和操作 $4$，输出答案。", "hint": "## 样例 $1$ 解释：\n\n| 操作 | 操作后的序列 | 答案 |\n| :----------: | :----------: | :----------: |\n| $(1,3,3)$ | $\\{1,5,3\\}$ | $/$ |\n| $3$ | $/$ | $2$ |\n| $(1,1,5)$ | $\\{5,5,3\\}$ | $/$ |\n| $(4,1,3)$ | $/$ | $13$ |\n\n## 样例 $2$ 解释：\n\n| 操作 | 操作后的序列 | 答案 |\n| :----------: | :----------: | :----------: |\n| $3$ | $/$ | $4$ |\n| $2$ | $\\{4,1,5,4,1,1\\}$ | $/$ |\n| $3$ | $/$ | $3$ |\n| $(1,1,5)$ | $\\{5,1,5,4,1,1\\}$ | $/$ |\n|$(4,1,4)$|$/$|$15$|\n## 数据范围\n| 测试点编号 | $n\\le$ |$q\\le$| 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |\n|$1$|$100$|$100$|$/$|\n|$2,3$|$10^3$|$10^3$|$\\mathbf{A}$|\n|$4$|$10^3$|$10^3$|$\\mathbf{B}$|\n|$5\\sim10$|$2\\times 10^5$|$2\\times 10^5$|$/$|\n|$11\\sim13$|$2\\times 10^5$|$2\\times 10^5$|$\\mathbf{A}$|\n|$14,15$|$2\\times 10^5$|$2\\times 10^5$|$/$|\n|$16\\sim18$|$5\\times 10^5$|$5\\times 10^5$|$\\mathbf{B}$|\n|$19\\sim25$|$5\\times 10^5$|$5\\times 10^5$|$/$|\n\n特殊性质 $\\mathbf{A}:$ 没有操作 $2$。\n\n特殊性质 $\\mathbf{B}:$ 没有操作 $3$。\n\n对于 $100\\%$ 的数据：$1\\le n\\le 5\\times 10^5$，$1\\le q\\le 5\\times 10^5$。\n\n $\\forall i\\in [1,n]$，满足 $a_i\\in[0,9]$。", "locale": "zh-CN"}}}
{"pid": "P9712", "type": "P", "difficulty": 1, "samples": [["P9202", "solution-p9202"], ["CF1797F", "solution-cf1797f"], ["AT_abc312_h", "solution-at-abc312-h"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "洛谷原创", "O2优化", "洛谷月赛"], "title": "「QFOI R1」贴贴", "background": "", "description": "小 R 是一个可爱的女孩子，她希望通过给洛谷题目写题解的方式跟出题人贴贴。\n\n她发现，如果从题解界面点击“提交题解”按钮，博客中会自动生成 URL 标识符，也就是文章的链接。\n\n其中，标识符的生成规则如下：\n\n- 将题号的所有大写字母转为小写。\n- 将上一步结果的所有下划线转为减号。\n- 在上一步结果前面加上 `solution-`。\n\n她准备给一道题目写题解，已知这道题的题号，你能求出 URL 标识符吗？", "inputFormat": "一行，一个字符串 $s$，表示题号。", "outputFormat": "一行，一个字符串，表示 URL 标识符。", "hint": "**样例 $3$ 解释**\n\n根据生成规则：\n\n- 将题号的所有大写字母转为小写：`at_abc312_h`。\n- 将上一步结果的所有下划线转为减号：`at-abc312-h`。\n- 在上一步结果前面加上 `solution-`：`solution-at-abc312-h`。\n\n---\n\n**数据范围**\n\n本题共 $10$ 个测试点，每个测试点 $10$ 分。\n\n对于全部数据，保证题号仅包含大写字母（ASCII $65\\sim 90$）、小写字母（ASCII $97\\sim 122$）、数字（ASCII $48\\sim 57$）、下划线（ASCII $95$），且长度不超过 $20$。\n\n对于全部数据，答案中应当仅包含小写字母（ASCII $97\\sim 122$）、数字（ASCII $48\\sim 57$）、减号（ASCII $45$）。\n\n- 对于测试点 $1$：保证为主题库题目。\n- 对于测试点 $2$：保证为入门与面试题目。\n- 对于测试点 $3\\sim 4$：保证为 CodeForces 题目。\n- 对于测试点 $5\\sim 6$：保证为 SPOJ 题目。\n- 对于测试点 $7\\sim 8$：保证为 AtCoder 题目。\n- 对于测试点 $9\\sim 10$：保证为 UVA 题目。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「QFOI R1」贴贴", "background": "", "description": "小 R 是一个可爱的女孩子，她希望通过给洛谷题目写题解的方式跟出题人贴贴。\n\n她发现，如果从题解界面点击“提交题解”按钮，博客中会自动生成 URL 标识符，也就是文章的链接。\n\n其中，标识符的生成规则如下：\n\n- 将题号的所有大写字母转为小写。\n- 将上一步结果的所有下划线转为减号。\n- 在上一步结果前面加上 `solution-`。\n\n她准备给一道题目写题解，已知这道题的题号，你能求出 URL 标识符吗？", "inputFormat": "一行，一个字符串 $s$，表示题号。", "outputFormat": "一行，一个字符串，表示 URL 标识符。", "hint": "**样例 $3$ 解释**\n\n根据生成规则：\n\n- 将题号的所有大写字母转为小写：`at_abc312_h`。\n- 将上一步结果的所有下划线转为减号：`at-abc312-h`。\n- 在上一步结果前面加上 `solution-`：`solution-at-abc312-h`。\n\n---\n\n**数据范围**\n\n本题共 $10$ 个测试点，每个测试点 $10$ 分。\n\n对于全部数据，保证题号仅包含大写字母（ASCII $65\\sim 90$）、小写字母（ASCII $97\\sim 122$）、数字（ASCII $48\\sim 57$）、下划线（ASCII $95$），且长度不超过 $20$。\n\n对于全部数据，答案中应当仅包含小写字母（ASCII $97\\sim 122$）、数字（ASCII $48\\sim 57$）、减号（ASCII $45$）。\n\n- 对于测试点 $1$：保证为主题库题目。\n- 对于测试点 $2$：保证为入门与面试题目。\n- 对于测试点 $3\\sim 4$：保证为 CodeForces 题目。\n- 对于测试点 $5\\sim 6$：保证为 SPOJ 题目。\n- 对于测试点 $7\\sim 8$：保证为 AtCoder 题目。\n- 对于测试点 $9\\sim 10$：保证为 UVA 题目。", "locale": "zh-CN"}}}
{"pid": "P9713", "type": "P", "difficulty": 2, "samples": [["3 3 3 2\n1 2\n2 1", "9\n6"], ["1000000 1000000 1000000 6\n1 123456\n2 654321\n3 233333\n2 111111\n1 333333\n3 1000000", "876544000000000000\n303002853376000000\n232302288589217792\n232302288589217792\n176680542935560631\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "洛谷原创", "O2优化", "洛谷月赛"], "title": "「QFOI R1」抱抱", "background": "", "description": "小 R 是一个可爱的女孩子，她希望跟大家抱抱，顺便给大家分蛋糕吃。\n\n蛋糕是一个大小为 $a\\times b\\times c$ 的长方体，其中每个单位正方体都被赋予了一个坐标 $(x,y,z)$（$1\\le x\\le a,1\\le y\\le b,1\\le z\\le c$）。\n\n共进行 $m$ 次切蛋糕操作，每次按如下三种方式之一切分：\n\n1. 切出 $x\\le k$ 的部分分给大家。\n2. 切出 $y\\le k$ 的部分分给大家。\n3. 切出 $z\\le k$ 的部分分给大家。\n\n由于她自己也想吃蛋糕，她希望知道在每次切蛋糕后，还剩下多少体积没有分给大家。", "inputFormat": "第一行四个整数 $a,b,c,m$，表示蛋糕的大小和切蛋糕次数。\n\n接下来 $m$ 行，每行两个整数 $op,k$，表示进行【题目描述】中的第 $op$ 种操作，参数为 $k$。", "outputFormat": "$m$ 行，每行一个整数，表示剩余部分体积。", "hint": "**样例 $1$ 解释**\n\n第一次切蛋糕，将所有 $x\\le 2$ 的部分切掉，剩余的单位正方体有 $(3,1,1),(3,1,2),(3,1,3),(3,2,1),(3,2,2),(3,2,3),(3,3,1),(3,3,2),(3,3,3)$ 共 $9$ 个。\n\n第二次切蛋糕，将所有 $y\\le 1$ 的部分切掉，剩余的单位正方体有 $(3,2,1),(3,2,2),(3,2,3),(3,3,1),(3,3,2),(3,3,3)$ 共 $6$ 个。\n\n---\n\n**样例 $2$ 解释**\n\n第四次切蛋糕没有任何作用，因为第二次切蛋糕时 $y\\le 654321$ 的部分已经被切掉，此时已经不存在 $y\\le 111111$ 的单位正方体。\n\n注意每次操作中的参数 $k$ 是初始时决定的绝对坐标，不会随着操作的进行而改变。\n\n---\n\n**数据范围**\n\n本题共 $20$ 个测试点，每个测试点 $5$ 分。\n\n对于全部数据，保证 $1\\le a,b,c\\le 10^6$，$1\\le m\\le 2\\times 10^5$，$op\\in\\{1,2,3\\}$，若 $op=1$ 则 $1\\le k\\le a$，若 $op=2$ 则 $1\\le k\\le b$，若 $op=3$ 则 $1\\le k\\le c$。\n\n- 对于测试点 $1\\sim 5$：保证 $a,b,c,m\\le 100$。\n- 对于测试点 $6\\sim 10$：保证 $b=c=1$，$op=1$。\n- 对于测试点 $11\\sim 15$：保证 $c=1$，$op\\in\\{1,2\\}$。\n- 对于测试点 $16\\sim 20$：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「QFOI R1」抱抱", "background": "", "description": "小 R 是一个可爱的女孩子，她希望跟大家抱抱，顺便给大家分蛋糕吃。\n\n蛋糕是一个大小为 $a\\times b\\times c$ 的长方体，其中每个单位正方体都被赋予了一个坐标 $(x,y,z)$（$1\\le x\\le a,1\\le y\\le b,1\\le z\\le c$）。\n\n共进行 $m$ 次切蛋糕操作，每次按如下三种方式之一切分：\n\n1. 切出 $x\\le k$ 的部分分给大家。\n2. 切出 $y\\le k$ 的部分分给大家。\n3. 切出 $z\\le k$ 的部分分给大家。\n\n由于她自己也想吃蛋糕，她希望知道在每次切蛋糕后，还剩下多少体积没有分给大家。", "inputFormat": "第一行四个整数 $a,b,c,m$，表示蛋糕的大小和切蛋糕次数。\n\n接下来 $m$ 行，每行两个整数 $op,k$，表示进行【题目描述】中的第 $op$ 种操作，参数为 $k$。", "outputFormat": "$m$ 行，每行一个整数，表示剩余部分体积。", "hint": "**样例 $1$ 解释**\n\n第一次切蛋糕，将所有 $x\\le 2$ 的部分切掉，剩余的单位正方体有 $(3,1,1),(3,1,2),(3,1,3),(3,2,1),(3,2,2),(3,2,3),(3,3,1),(3,3,2),(3,3,3)$ 共 $9$ 个。\n\n第二次切蛋糕，将所有 $y\\le 1$ 的部分切掉，剩余的单位正方体有 $(3,2,1),(3,2,2),(3,2,3),(3,3,1),(3,3,2),(3,3,3)$ 共 $6$ 个。\n\n---\n\n**样例 $2$ 解释**\n\n第四次切蛋糕没有任何作用，因为第二次切蛋糕时 $y\\le 654321$ 的部分已经被切掉，此时已经不存在 $y\\le 111111$ 的单位正方体。\n\n注意每次操作中的参数 $k$ 是初始时决定的绝对坐标，不会随着操作的进行而改变。\n\n---\n\n**数据范围**\n\n本题共 $20$ 个测试点，每个测试点 $5$ 分。\n\n对于全部数据，保证 $1\\le a,b,c\\le 10^6$，$1\\le m\\le 2\\times 10^5$，$op\\in\\{1,2,3\\}$，若 $op=1$ 则 $1\\le k\\le a$，若 $op=2$ 则 $1\\le k\\le b$，若 $op=3$ 则 $1\\le k\\le c$。\n\n- 对于测试点 $1\\sim 5$：保证 $a,b,c,m\\le 100$。\n- 对于测试点 $6\\sim 10$：保证 $b=c=1$，$op=1$。\n- 对于测试点 $11\\sim 15$：保证 $c=1$，$op\\in\\{1,2\\}$。\n- 对于测试点 $16\\sim 20$：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P9714", "type": "P", "difficulty": 3, "samples": [["2\n3\n1 2 2\n5 8 7\n3\n1 2 2\n2 4 3", "Yes\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "洛谷原创", "Special Judge", "O2优化", "构造", "洛谷月赛"], "title": "「QFOI R1」摸摸", "background": "", "description": "小 R 是一个可爱的女孩子，她喜欢被摸头。\n\n但是摸头之前，必须答对她提出的一个问题。\n\n她有一个长度为 $n$ 的数列 $a$，初始时所有元素均为 $0$。另有两个长度为 $n$ 的数列 $t,b$。\n\n她可以进行两种操作：\n\n1. 将 $t$ 与 $t$ 的倒序对应元素相加，得到新的 $t$。\n    - 例如，$t=[1,4,2]$ 变为 $t'=[1+2,4+4,2+1]=[3,8,3]$。\n2. 将 $a$ 与 $t$ 对应元素相加，得到新的 $a$。\n    - 例如，$a=[1,2,3],t=[1,4,2]$ 变为 $a'=[1+1,2+4,3+2]=[2,6,5]$。\n\n是否可能通过若干次以上操作将 $a$ 变为 $b$？\n\n你希望摸她的头 $T$ 次，因此有 $T$ 组数据。", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n- 第一行一个整数 $n$，表示数列长度。\n- 第二行 $n$ 个整数，第 $i$ 个整数为 $t_i$。\n- 第三行 $n$ 个整数，第 $i$ 个整数为 $b_i$。", "outputFormat": "共 $T$ 行，每行一个为 `Yes` 或 `No` 的字符串，表示每组数据是否可能将 $a$ 变为 $b$。\n\n字符串不区分大小写，如果答案为 `Yes` 的话，`yes`、`YES`、`yEs` 等都将被判为正确。", "hint": "**样例解释**\n\n对于第一组数据：\n\n- 初始时：$a=[0,0,0]$，$t=[1,2,2]$，$b=[5,8,7]$。\n- 执行操作二：$a=[1,2,2]$，$t=[1,2,2]$，$b=[5,8,7]$。\n- 执行操作二：$a=[2,4,4]$，$t=[1,2,2]$，$b=[5,8,7]$。\n- 执行操作一：$a=[2,4,4]$，$t=[3,4,3]$，$b=[5,8,7]$。\n- 执行操作二：$a=[5,8,7]$，$t=[3,4,3]$，$b=[5,8,7]$。\n\n此时 $a=b$，符合要求。\n\n对于第二组数据，可以证明不存在合法方案。\n\n---\n\n**数据范围**\n\n本题共 $20$ 个测试点，每个测试点 $5$ 分。\n\n记 $\\sum n$ 表示每组数据的 $n$ 之和。\n\n对于全部数据，保证 $1\\le\\sum n\\le 2\\times 10^3$，$n\\ge 1$，$1\\le t_i,b_i\\le 2\\times 10^3$。\n\n- 对于测试点 $1\\sim 4$：保证 $n\\le 2$。\n- 对于测试点 $5\\sim 8$：保证所有 $t_i$ 都相等。\n- 对于测试点 $9\\sim 12$：保证 $b_i=b_{n-i+1}$。\n- 对于测试点 $13\\sim 16$：保证 $\\sum n,t_i,b_i\\le 200$。\n- 对于测试点 $17\\sim 20$：无特殊限制。\n\n---\n\n**Hack 数据**\n\n本题在赛后添加了 Hack 数据，从 $21$ 开始编号。\n\n原有测试点依然计 $5$ 分，Hack 数据计 $0$ 分，但只有通过所有数据才会被判为 Accepted。\n\n为区分原有测试点和 Hack 数据，本题添加了子任务，但子任务的计分方式为“加和”，不会影响正常评测。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「QFOI R1」摸摸", "background": "", "description": "小 R 是一个可爱的女孩子，她喜欢被摸头。\n\n但是摸头之前，必须答对她提出的一个问题。\n\n她有一个长度为 $n$ 的数列 $a$，初始时所有元素均为 $0$。另有两个长度为 $n$ 的数列 $t,b$。\n\n她可以进行两种操作：\n\n1. 将 $t$ 与 $t$ 的倒序对应元素相加，得到新的 $t$。\n    - 例如，$t=[1,4,2]$ 变为 $t'=[1+2,4+4,2+1]=[3,8,3]$。\n2. 将 $a$ 与 $t$ 对应元素相加，得到新的 $a$。\n    - 例如，$a=[1,2,3],t=[1,4,2]$ 变为 $a'=[1+1,2+4,3+2]=[2,6,5]$。\n\n是否可能通过若干次以上操作将 $a$ 变为 $b$？\n\n你希望摸她的头 $T$ 次，因此有 $T$ 组数据。", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n- 第一行一个整数 $n$，表示数列长度。\n- 第二行 $n$ 个整数，第 $i$ 个整数为 $t_i$。\n- 第三行 $n$ 个整数，第 $i$ 个整数为 $b_i$。", "outputFormat": "共 $T$ 行，每行一个为 `Yes` 或 `No` 的字符串，表示每组数据是否可能将 $a$ 变为 $b$。\n\n字符串不区分大小写，如果答案为 `Yes` 的话，`yes`、`YES`、`yEs` 等都将被判为正确。", "hint": "**样例解释**\n\n对于第一组数据：\n\n- 初始时：$a=[0,0,0]$，$t=[1,2,2]$，$b=[5,8,7]$。\n- 执行操作二：$a=[1,2,2]$，$t=[1,2,2]$，$b=[5,8,7]$。\n- 执行操作二：$a=[2,4,4]$，$t=[1,2,2]$，$b=[5,8,7]$。\n- 执行操作一：$a=[2,4,4]$，$t=[3,4,3]$，$b=[5,8,7]$。\n- 执行操作二：$a=[5,8,7]$，$t=[3,4,3]$，$b=[5,8,7]$。\n\n此时 $a=b$，符合要求。\n\n对于第二组数据，可以证明不存在合法方案。\n\n---\n\n**数据范围**\n\n本题共 $20$ 个测试点，每个测试点 $5$ 分。\n\n记 $\\sum n$ 表示每组数据的 $n$ 之和。\n\n对于全部数据，保证 $1\\le\\sum n\\le 2\\times 10^3$，$n\\ge 1$，$1\\le t_i,b_i\\le 2\\times 10^3$。\n\n- 对于测试点 $1\\sim 4$：保证 $n\\le 2$。\n- 对于测试点 $5\\sim 8$：保证所有 $t_i$ 都相等。\n- 对于测试点 $9\\sim 12$：保证 $b_i=b_{n-i+1}$。\n- 对于测试点 $13\\sim 16$：保证 $\\sum n,t_i,b_i\\le 200$。\n- 对于测试点 $17\\sim 20$：无特殊限制。\n\n---\n\n**Hack 数据**\n\n本题在赛后添加了 Hack 数据，从 $21$ 开始编号。\n\n原有测试点依然计 $5$ 分，Hack 数据计 $0$ 分，但只有通过所有数据才会被判为 Accepted。\n\n为区分原有测试点和 Hack 数据，本题添加了子任务，但子任务的计分方式为“加和”，不会影响正常评测。", "locale": "zh-CN"}}}
{"pid": "P9715", "type": "P", "difficulty": 4, "samples": [["5 5 2 4\n1 2 4 1 0\n2 4 5 1 1\n2 2 4 2 0\n1 1 1 2 1", "17 7"], ["5 5 3 6\n2 1 3 3 1\n2 2 4 1 0\n1 4 4 2 0\n2 1 1 1 0\n1 2 5 2 0\n1 1 5 3 0", "5 4 16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线性数据结构", "洛谷原创", "O2优化", "洛谷月赛", "链表"], "title": "「QFOI R1」头", "background": "可以看看这个讨论：<https://www.luogu.com.cn/discuss/703835>。", "description": "小 R 是一个可爱的女孩子。有一天，她在被摸头时，突然灵光乍现，便随手加强了一道题给你做。\n\n这道题的名字叫涂色游戏。初始时你有一个 $n$ 行 $m$ 列的网格，所有格子上都没有颜色。有 $k$ 种颜色的刷子，颜色编号为 $1\\sim k$。然后给出 $q$ 次操作，每次操作给出 $op,l,r,c,t$ 五个参数：\n\n- 如果 $op=1$，表示将第 $l\\sim r$ 行的所有格子涂成颜色 $c$。\n- 如果 $op=2$，表示将第 $l\\sim r$ 列的所有格子涂成颜色 $c$。\n- 如果 $t=0$，意味着如果涂色时遇到已经被染色的格子，就不再进行染色。\n- 如果 $t=1$，意味着如果涂色时遇到已经被染色的格子，就用新的颜色覆盖它。\n\n在所有涂色操作结束以后，对于每种颜色，求出有多少个格子被染成了这种颜色。", "inputFormat": "第一行四个整数 $n,m,k,q$，表示行数、列数、颜色数和操作数。\n\n接下来 $q$ 行，每行五个整数 $op,l,r,c,t$，表示这次操作的参数。", "outputFormat": "一行 $k$ 个整数，第 $i$ 个整数表示被染成颜色 $i$ 的格子数量。", "hint": "**样例 $1$ 解释**\n\n用浅灰色表示颜色 $1$，灰色表示颜色 $2$。\n\n涂色过程如图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gl7dmh5b.png)\n\n共有 $17$ 个区域被染成颜色 $1$，$7$ 个区域被染成颜色 $2$。\n\n---\n\n**数据范围**\n\n本题共 $20$ 个测试点，每个测试点 $5$ 分。\n\n对于全部数据，保证 $1\\le n,m,q\\le 2\\times 10^6$，$1\\le k\\le 5\\times 10^5$，$op\\in\\{1,2\\}$，若 $op=1$ 则 $1\\le l\\le r\\le n$，若 $op=2$ 则 $1\\le l\\le r\\le m$，$1\\le c\\le k$，$t\\in\\{0,1\\}$。\n\n- 对于测试点 $1\\sim 3$：保证 $n,m,k,q\\le 200$。\n- 对于测试点 $4\\sim 6$：保证 $n,m,k,q\\le 2\\times 10^3$。\n- 对于测试点 $7\\sim 9$：保证 $n,m,k,q\\le 10^5$，$op=1$。\n- 对于测试点 $10\\sim 12$：保证 $n,m,k,q\\le 10^5$，$t=1$。\n- 对于测试点 $13\\sim 18$：保证 $n,m,k,q\\le 10^5$。\n- 对于测试点 $19\\sim 20$：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「QFOI R1」头", "background": "可以看看这个讨论：<https://www.luogu.com.cn/discuss/703835>。", "description": "小 R 是一个可爱的女孩子。有一天，她在被摸头时，突然灵光乍现，便随手加强了一道题给你做。\n\n这道题的名字叫涂色游戏。初始时你有一个 $n$ 行 $m$ 列的网格，所有格子上都没有颜色。有 $k$ 种颜色的刷子，颜色编号为 $1\\sim k$。然后给出 $q$ 次操作，每次操作给出 $op,l,r,c,t$ 五个参数：\n\n- 如果 $op=1$，表示将第 $l\\sim r$ 行的所有格子涂成颜色 $c$。\n- 如果 $op=2$，表示将第 $l\\sim r$ 列的所有格子涂成颜色 $c$。\n- 如果 $t=0$，意味着如果涂色时遇到已经被染色的格子，就不再进行染色。\n- 如果 $t=1$，意味着如果涂色时遇到已经被染色的格子，就用新的颜色覆盖它。\n\n在所有涂色操作结束以后，对于每种颜色，求出有多少个格子被染成了这种颜色。", "inputFormat": "第一行四个整数 $n,m,k,q$，表示行数、列数、颜色数和操作数。\n\n接下来 $q$ 行，每行五个整数 $op,l,r,c,t$，表示这次操作的参数。", "outputFormat": "一行 $k$ 个整数，第 $i$ 个整数表示被染成颜色 $i$ 的格子数量。", "hint": "**样例 $1$ 解释**\n\n用浅灰色表示颜色 $1$，灰色表示颜色 $2$。\n\n涂色过程如图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gl7dmh5b.png)\n\n共有 $17$ 个区域被染成颜色 $1$，$7$ 个区域被染成颜色 $2$。\n\n---\n\n**数据范围**\n\n本题共 $20$ 个测试点，每个测试点 $5$ 分。\n\n对于全部数据，保证 $1\\le n,m,q\\le 2\\times 10^6$，$1\\le k\\le 5\\times 10^5$，$op\\in\\{1,2\\}$，若 $op=1$ 则 $1\\le l\\le r\\le n$，若 $op=2$ 则 $1\\le l\\le r\\le m$，$1\\le c\\le k$，$t\\in\\{0,1\\}$。\n\n- 对于测试点 $1\\sim 3$：保证 $n,m,k,q\\le 200$。\n- 对于测试点 $4\\sim 6$：保证 $n,m,k,q\\le 2\\times 10^3$。\n- 对于测试点 $7\\sim 9$：保证 $n,m,k,q\\le 10^5$，$op=1$。\n- 对于测试点 $10\\sim 12$：保证 $n,m,k,q\\le 10^5$，$t=1$。\n- 对于测试点 $13\\sim 18$：保证 $n,m,k,q\\le 10^5$。\n- 对于测试点 $19\\sim 20$：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P9716", "type": "P", "difficulty": 6, "samples": [["3 1\n-1 -1 2\n1 0 0\n3 1 2", "1"], ["10 8\n36175808 53666444 14885614 -14507677 \n-92588511 52375931 -87106420 -7180697 \n-158326918 98234152\n17550389 45695943 55459378 18577244 \n93218347 64719200 84319188 34410268 \n20911746 49221094\n8 1 2 2 8 8 4 7 8 4", "35343360"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2022", "O2优化", "基环树", "ICPC", "EC Final"], "title": "[EC Final 2022] Coloring", "background": "", "description": "You are given $n$ elements numbered from $1$ to $n$. Element $i$ has value $w_i$ and color $c_i$. Each element also has a pointer $a_i$ to some other element.\n\nInitially, the color of element $s$ is $1$, while the color of all the other elements is $0$. More formally, $c_s=1$ and $c_i=0$ for all $i\\neq s$ $(1 \\le i \\le n)$.\n\nYou can perform the following operation for any number of times:\n\n- Assign $c_i\\leftarrow c_{a_i}$ at a cost of $p_i$.\n\nYour score is equal to the sum of values of all the elements with color $1$ after the operations minus the sum of costs of the operations.\n\nFind the maximum possible score you can obtain.", "inputFormat": "The first line contains two integers $n,s$ ($1 \\leq s\\le n \\leq 5\\times 10^3$) $-$ the number of elements and the element with color $1$ initially.\n\nThe second line contains $n$ integers $w_1,w_2,\\dots,w_n$ ($-10^9\\le w_i\\le 10^9$) $-$ the value of the elements.\n\nThe third line contains $n$ integers $p_1,p_2,\\dots,p_n$ ($0\\le p_i\\le 10^9$) $-$ the cost of changing the color of each element.\n\nThe fourth line contains $n$ integers $a_1,a_2,\\dots,a_n$ ($1\\le a_i\\le n$, $a_i\\neq i$).", "outputFormat": "Output one integer representing the answer in one line.", "hint": "(There won’t be extra line breakers \nin the actual test cases.)\n\nIn the first sample, you can successively perform the following operations:\n\n- Assign $c_2\\leftarrow c_{a_2}$ at a cost of $p_2$, then $c=[1,1,0]$;\n- Assign $c_1\\leftarrow c_{a_1}$ at a cost of $p_1$, then $c=[0,1,0]$;\n- Assign $c_3\\leftarrow c_{a_3}$ at a cost of $p_3$, then $c=[0,1,1]$;\n- Assign $c_2\\leftarrow c_{a_2}$ at a cost of $p_2$, then $c=[0,0,1]$.\n\nAfter the operations, only the color of element $3$ is $1$, so your score is equal to $w_3-(p_2+p_1+p_3+p_2)=1$. It can be shown that it is impossible to obtain a score greater than $1$.", "locale": "en", "translations": {"en": {"title": "[EC Final 2022] Coloring", "background": "", "description": "You are given $n$ elements numbered from $1$ to $n$. Element $i$ has value $w_i$ and color $c_i$. Each element also has a pointer $a_i$ to some other element.\n\nInitially, the color of element $s$ is $1$, while the color of all the other elements is $0$. More formally, $c_s=1$ and $c_i=0$ for all $i\\neq s$ $(1 \\le i \\le n)$.\n\nYou can perform the following operation for any number of times:\n\n- Assign $c_i\\leftarrow c_{a_i}$ at a cost of $p_i$.\n\nYour score is equal to the sum of values of all the elements with color $1$ after the operations minus the sum of costs of the operations.\n\nFind the maximum possible score you can obtain.", "inputFormat": "The first line contains two integers $n,s$ ($1 \\leq s\\le n \\leq 5\\times 10^3$) $-$ the number of elements and the element with color $1$ initially.\n\nThe second line contains $n$ integers $w_1,w_2,\\dots,w_n$ ($-10^9\\le w_i\\le 10^9$) $-$ the value of the elements.\n\nThe third line contains $n$ integers $p_1,p_2,\\dots,p_n$ ($0\\le p_i\\le 10^9$) $-$ the cost of changing the color of each element.\n\nThe fourth line contains $n$ integers $a_1,a_2,\\dots,a_n$ ($1\\le a_i\\le n$, $a_i\\neq i$).", "outputFormat": "Output one integer representing the answer in one line.", "hint": "(There won’t be extra line breakers \nin the actual test cases.)\n\nIn the first sample, you can successively perform the following operations:\n\n- Assign $c_2\\leftarrow c_{a_2}$ at a cost of $p_2$, then $c=[1,1,0]$;\n- Assign $c_1\\leftarrow c_{a_1}$ at a cost of $p_1$, then $c=[0,1,0]$;\n- Assign $c_3\\leftarrow c_{a_3}$ at a cost of $p_3$, then $c=[0,1,1]$;\n- Assign $c_2\\leftarrow c_{a_2}$ at a cost of $p_2$, then $c=[0,0,1]$.\n\nAfter the operations, only the color of element $3$ is $1$, so your score is equal to $w_3-(p_2+p_1+p_3+p_2)=1$. It can be shown that it is impossible to obtain a score greater than $1$.", "locale": "en"}, "zh-CN": {"title": "[EC Final 2022] Coloring", "background": "", "description": "给定 $n$ 个元素，编号从 $1$ 到 $n$。元素 $i$ 的值为 $w_i$，颜色为 $c_i$。每个元素还有一个指针 $a_i$ 指向另一个元素。\n\n最初，元素 $s$ 的颜色为 $1$，而所有其他元素的颜色都为 $0$。更正式地说，对于所有 $i\\neq s$ $(1 \\le i \\le n)$，有 $c_s=1$ 和 $c_i=0$。\n\n你可以任意多次执行以下操作：\n\n- 以代价 $p_i$ 将 $c_i\\leftarrow c_{a_i}$。\n\n你的得分等于所有颜色为 $1$ 的元素值的总和减去操作的总代价。\n\n找出你能够获得的最大可能得分。", "inputFormat": "第一行包含两个整数 $n$ 和 $s$（$1 \\leq s\\le n \\leq 5\\times 10^3$）$-$ 元素数量以及初始颜色为 $1$ 的元素。\n\n第二行包含 $n$ 个整数 $w_1,w_2,\\dots,w_n$（$-10^9\\le w_i\\le 10^9$）$-$ 元素的值。\n\n第三行包含 $n$ 个整数 $p_1,p_2,\\dots,p_n$（$0\\le p_i\\le 10^9$）$-$ 改变每个元素颜色的代价。\n\n第四行包含 $n$ 个整数 $a_1,a_2,\\dots,a_n$（$1\\le a_i\\le n$, $a_i\\neq i$）。", "outputFormat": "输出一行一个整数，表示答案。\n\n**【样例解释】**\n\n在第一个样例中，你可以依次执行以下操作：\n\n- 以代价 $p_2$ 将 $c_2\\leftarrow c_{a_2}$，然后 $c=[1,1,0]$；\n- 以代价 $p_1$ 将 $c_1\\leftarrow c_{a_1}$，然后 $c=[0,1,0]$；\n- 以代价 $p_3$ 将 $c_3\\leftarrow c_{a_3}$，然后 $c=[0,1,1]$；\n- 以代价 $p_2$ 将 $c_2\\leftarrow c_{a_2}$，然后 $c=[0,0,1]$。\n\n操作后，只有元素 $3$ 的颜色为 $1$，因此你的得分等于 $w_3-(p_2+p_1+p_3+p_2)=1$。可以证明无法获得大于 $1$ 的得分。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9717", "type": "P", "difficulty": 6, "samples": [["3\n1\n001001\n0001111", "1\n3\n9"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "O2优化", "KMP 算法", "ICPC", "EC Final"], "title": "[EC Final 2022] Binary String", "background": "", "description": "You are given a binary string $a_0a_1a_2\\dots a_{n-1}$ arranged on a cycle. Each second, you will change every $01$ to $10$ simultaneously. In other words, if $a_i = 0$ and $a_{(i+1) \\bmod n} = 1$, you swap $a_i$ and $a_{(i+1)\\bmod n}$. For example, we will change $\\texttt{100101110}$ to $\\texttt{001010111}$.\n\nYou need to answer how many different strings will occur in infinite seconds, modulo $998244353$.\n\nNote: Two strings $a_0a_1\\dots a_{n-1}$ and $b_0b_1\\dots b_{n-1}$ are different if there exists an integer $i\\in \\{0,1,\\ldots, n-1\\}$ such that $a_i\\neq b_i$. Thus, the cyclic shifts of a string may be different from the original string.", "inputFormat": "The first line contains an integer $T$ $(1\\leq T\\leq 10^6)$ $-$ the number of test cases.\n\nFor each test case, the first line contains a binary string $a_0 a_1 \\dots a_{n-1}$ $(a_i \\in \\{0, 1\\})$.\n\nIt is guaranteed that the sum of lengths of strings over all test cases does not exceed $10^7$.", "outputFormat": "For each test case, output one integer representing the answer in one line.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2022] Binary String", "background": "", "description": "You are given a binary string $a_0a_1a_2\\dots a_{n-1}$ arranged on a cycle. Each second, you will change every $01$ to $10$ simultaneously. In other words, if $a_i = 0$ and $a_{(i+1) \\bmod n} = 1$, you swap $a_i$ and $a_{(i+1)\\bmod n}$. For example, we will change $\\texttt{100101110}$ to $\\texttt{001010111}$.\n\nYou need to answer how many different strings will occur in infinite seconds, modulo $998244353$.\n\nNote: Two strings $a_0a_1\\dots a_{n-1}$ and $b_0b_1\\dots b_{n-1}$ are different if there exists an integer $i\\in \\{0,1,\\ldots, n-1\\}$ such that $a_i\\neq b_i$. Thus, the cyclic shifts of a string may be different from the original string.", "inputFormat": "The first line contains an integer $T$ $(1\\leq T\\leq 10^6)$ $-$ the number of test cases.\n\nFor each test case, the first line contains a binary string $a_0 a_1 \\dots a_{n-1}$ $(a_i \\in \\{0, 1\\})$.\n\nIt is guaranteed that the sum of lengths of strings over all test cases does not exceed $10^7$.", "outputFormat": "For each test case, output one integer representing the answer in one line.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2022] Binary String", "background": "", "description": "给定一个排列在环上的二进制字符串 $a_0a_1a_2\\dots a_{n-1}$。每一秒钟，你会同时将每个 $01$ 变为 $10$。换句话说，如果 $a_i = 0$ 且 $a_{(i+1) \\bmod n} = 1$，则交换 $a_i$ 和 $a_{(i+1)\\bmod n}$。例如，我们将 $\\texttt{100101110}$ 变为 $\\texttt{001010111}$。\n\n你需要回答在无限秒内会出现多少种不同的字符串，取模 $998244353$。\n\n注意：如果存在整数 $i\\in \\{0,1,\\ldots, n-1\\}$ 使得 $a_i\\neq b_i$，则两个字符串 $a_0a_1\\dots a_{n-1}$ 和 $b_0b_1\\dots b_{n-1}$ 是不同的。因此，字符串的循环移位可能与原始字符串不同。", "inputFormat": "第一行包含一个整数 $T$ $(1\\leq T\\leq 10^6)$ $-$ 测试用例的数量。\n\n对于每个测试用例，第一行包含一个二进制字符串 $a_0 a_1 \\dots a_{n-1}$ $(a_i \\in \\{0, 1\\})$。\n\n保证所有测试用例中字符串长度的总和不超过 $10^7$。", "outputFormat": "对于每个测试用例，输出一行一个整数，表示答案。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9718", "type": "P", "difficulty": 5, "samples": [["4\n12345678 0\n12345678 5\n12345678 18\n990099 5", "1\n54322\n999999999987654322\n9910"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "O2优化", "数位 DP", "ICPC", "EC Final"], "title": "[EC Final 2022] Best Carry Player 2", "background": "", "description": "Given a positive integer $x$, find the minimum positive integer $y$ such that the number of $\\textbf{carries}^1$ of $x+y$ is exactly $k$.\n\nWe adds numbers $\\textbf{by column addition in base-ten}$, just like what we normally do in primary school. For example, there are two carries in the following addition.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pfnper3r.png)\n\n$^1$ which means ``进位`` in Chinese.", "inputFormat": "The first line contains an integer $T$ $(1\\leq T\\leq 10^5)$ $-$ the number of test cases.\n\nFor each test case, the first line contains two integers $x, k$ $(1\\leq x < 10^{18}, 0\\leq k \\leq 18)$.", "outputFormat": "For each test case, output one integer representing the answer in one line. If there is no solution, output $-1$ instead.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2022] Best Carry Player 2", "background": "", "description": "Given a positive integer $x$, find the minimum positive integer $y$ such that the number of $\\textbf{carries}^1$ of $x+y$ is exactly $k$.\n\nWe adds numbers $\\textbf{by column addition in base-ten}$, just like what we normally do in primary school. For example, there are two carries in the following addition.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pfnper3r.png)\n\n$^1$ which means ``进位`` in Chinese.", "inputFormat": "The first line contains an integer $T$ $(1\\leq T\\leq 10^5)$ $-$ the number of test cases.\n\nFor each test case, the first line contains two integers $x, k$ $(1\\leq x < 10^{18}, 0\\leq k \\leq 18)$.", "outputFormat": "For each test case, output one integer representing the answer in one line. If there is no solution, output $-1$ instead.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2022] Best Carry Player 2", "background": "", "description": "给定一个正整数 $x$，找到最小的正整数 $y$，使得 $x+y$ 的 $\\textbf{进位}$ 数量恰好为 $k$。\n\n我们按照十进制中的列加法进行相加，就像我们在小学时所做的那样。例如，下面的加法中有两次进位。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pfnper3r.png)", "inputFormat": "第一行包含一个整数 $T$ $(1\\leq T\\leq 10^5)$ $-$ 测试用例的数量。\n\n对于每个测试用例，第一行包含两个整数 $x, k$ $(1\\leq x < 10^{18}, 0\\leq k \\leq 18)$。", "outputFormat": "对于每个测试用例，输出一行一个整数，表示答案。如果没有解决方案，则输出 $-1$。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9719", "type": "P", "difficulty": 7, "samples": [["6\n3\n1 1 1\n3\n1 1 2\n3\n1 1 3\n3\n1 2 1\n3\n1 2 2\n3\n1 2 3", "1 2 2\n-1\n1 2 1\n1 1 2\n2 1 2\n1 1 1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["字符串", "2022", "O2优化", "ICPC", "Lyndon 分解", "EC Final"], "title": "[EC Final 2022] Minimum Suffix", "background": "", "description": "For a string $s$ of length $n$, we define $p_j = x$ if $s[x\\ldots j]$ is the minimum suffix of $s[1\\ldots j]$, for all $j=1,\\ldots, n$. (A suffix is the minimum suffix of a string if it is lexicographically smaller than any other suffix of that string.)\n\nYou are to recover $s$ from $p_1,\\ldots, p_n$. If there are multiple answers, find the lexicographically smallest one.", "inputFormat": "The first line contains a single integer $T$ ($1\\le T\\le 10^5$) representing the number of test cases.\n\nFor each test case, the first line contains a single integer $n$ ($1\\le n\\le 3\\times 10^6$) representing the length of $s$. The next line contains $n$ integers $p_1,\\ldots, p_n$ ($1\\le p_i\\le i$ for all $1\\le i\\le n$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3\\times 10^6$.", "outputFormat": "For each test case, output one line. If there is no solution, output $-1$. Otherwise, output the lexicographically smallest $s$. Characters of $s$ are represented by positive integers. Smaller integers represent smaller characters in the lexicographical order.", "hint": "As the input/output can be huge, it is recommended to use fast input/output methods.", "locale": "en", "translations": {"en": {"title": "[EC Final 2022] Minimum Suffix", "background": "", "description": "For a string $s$ of length $n$, we define $p_j = x$ if $s[x\\ldots j]$ is the minimum suffix of $s[1\\ldots j]$, for all $j=1,\\ldots, n$. (A suffix is the minimum suffix of a string if it is lexicographically smaller than any other suffix of that string.)\n\nYou are to recover $s$ from $p_1,\\ldots, p_n$. If there are multiple answers, find the lexicographically smallest one.", "inputFormat": "The first line contains a single integer $T$ ($1\\le T\\le 10^5$) representing the number of test cases.\n\nFor each test case, the first line contains a single integer $n$ ($1\\le n\\le 3\\times 10^6$) representing the length of $s$. The next line contains $n$ integers $p_1,\\ldots, p_n$ ($1\\le p_i\\le i$ for all $1\\le i\\le n$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3\\times 10^6$.", "outputFormat": "For each test case, output one line. If there is no solution, output $-1$. Otherwise, output the lexicographically smallest $s$. Characters of $s$ are represented by positive integers. Smaller integers represent smaller characters in the lexicographical order.", "hint": "As the input/output can be huge, it is recommended to use fast input/output methods.", "locale": "en"}, "zh-CN": {"title": "[EC Final 2022] Minimum Suffix", "background": "", "description": "对于长度为 $n$ 的字符串 $s$，如果 $s[x\\ldots j]$ 是 $s[1\\ldots j]$ 的最小后缀，则我们定义 $p_j = x$，其中 $j=1,\\ldots, n$。（后缀是字符串的最小后缀，如果它在字典序上小于该字符串的任何其他后缀。）\n\n你需要从 $p_1,\\ldots, p_n$ 中恢复出 $s$。如果存在多个答案，则找出字典序最小的那个。", "inputFormat": "第一行包含一个整数 $T$（$1\\le T\\le 10^5$），表示测试用例的数量。\n\n对于每个测试用例，第一行包含一个整数 $n$（$1\\le n\\le 3\\times 10^6$），表示 $s$ 的长度。接下来的一行包含 $n$ 个整数 $p_1,\\ldots, p_n$（$1\\le p_i\\le i$，$1\\le i\\le n$）。\n\n保证所有测试用例中 $n$ 的总和不超过 $3\\times 10^6$。", "outputFormat": "对于每个测试用例，输出一行。如果没有解决方案，则输出 $-1$。否则，输出字典序最小的 $s$。$s$ 中的字符由正整数表示。较小的整数表示字典序较小的字符。", "hint": "本题输入输出规模较大，建议使用快速的输入输出方式。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "locale": "zh-CN"}}}
{"pid": "P9720", "type": "P", "difficulty": 6, "samples": [["2\n0 0 0 2 4 2 4 0\n0 0 0 1 2 1 2 0\n2 1 4 2\n1 1\n0 0 0 3 6 3 6 0\n0 1 1 0 3 2 2 3\n0 0 4 2\n0 3", "1.0000000000\n1.2272623352"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2022", "Special Judge", "O2优化", "ICPC", "EC Final"], "title": "[EC Final 2022] Map", "background": "", "description": "It is a famous math fact that if you drop a map of a park completely inside the park, then there exists a point on the map which overlays with the point it represents.\n\nMio likes this fact a lot so she drops a map of her favorite park completely inside the park. The park $P$ can be represented by a rectangle. A map of the park is just a smaller (or equal) version of the park printed on paper. The map is similar to the original rectangle. Each point on the map corresponds to a point in the park by the similarity transformation.\n\nWe can define a map formally: A map is a rectangle $M$ (of smaller or equal size) together with a positive real number $r$ and a bijective function $f:M \\rightarrow P$ satisfying \n\n- For every pair of different points $a, b\\in M$, $|f(a)-f(b)|/|a-b|=r$.\n\n$|x-y|$ represents the Euclidean distance between points $x$ and $y$. \n\nLike in many games, Mio can teleport using the map. Precisely, when Mio is at some point $x$ on the map (including the boundary), she may teleport to the corresponding point $f(x)$ in the park. She may also choose not to teleport. The reverse is also true. When she is at point $y$ in the park (including the boundary), she may teleport to the point $f^{-1}(y)$ on the map representing her current location. And she may also choose not to teleport.\n\nMio can teleport at most $n$ (and at least $0$) times. Each teleport takes $k$ seconds. Mio can also walk on her foot at a speed of $1$ unit per second. \n\nGiven two points $s$ and $t$, find the minimum time Mio needs to reach $t$ from $s$.\n\nEach teleport can be in any direction (from the map to the park, or from the park to the map). The map may be placed upside down. Since the map is inside the park, it is possible that Mio is on the map and in the park simultaneously. In this case, she may teleport in either direction. \n\nFor example, in the following figure, the park is $ABCD$, and the map is $A'B'C'D'$. When Mio is inside the map, she is on the map and in the park simultaneously. When she is at point $D'$, she can teleport from the map to the park (reaching $D$), and from the park to the map (reaching $D^{\\prime\\prime}$).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hz6nq09e.png)", "inputFormat": "The first line contains a single integer $T$ ($1\\le T\\le 100$) denoting the number of test cases.\n\nFor each test case, the first line contains the $4$ corners of the rectangle representing the park. The corners are given in clockwise or counterclockwise order. It is guaranteed that the $4$ corners are distinct.\n\nThe second line contains the $4$ corners of the rectangle representing the map. The $i$-th corner of the map corresponds to the $i$-th corner of the park for all $1\\le i\\le 4$. Note that you can figure out whether the map is placed upside down or not by the order of the corners. The corners are given in clockwise or counterclockwise order. It is guaranteed that the map is inside the park. (The boundary of the map may intersect with the boundary of the park at $1$ or more points.) It is guaranteed that the map is valid, i.e., there is a positive real number and a bijective function from the map to the park satisfying the definition above.\n\nThe third line contains two points $s$ and $t$. It is guaranteed that $s$ and $t$ are inside (or on the boundary of) the park.\n\nThe fourth line contains two integers $k, n$ ($0\\le k\\le 2\\times 10^6, 0\\le n\\le 100$), the time each teleport needs, and the maximum number of teleports. \n\nEach point in the input is represented by a pair of integers whose absolute values are no more than $2\\times 10^6$. Integers are separated by single spaces.", "outputFormat": "For each test case, output one number representing the answer in one line. Your answer is considered correct if its absolute or relative error does not exceed $10^{-9}$.  ", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2022] Map", "background": "", "description": "It is a famous math fact that if you drop a map of a park completely inside the park, then there exists a point on the map which overlays with the point it represents.\n\nMio likes this fact a lot so she drops a map of her favorite park completely inside the park. The park $P$ can be represented by a rectangle. A map of the park is just a smaller (or equal) version of the park printed on paper. The map is similar to the original rectangle. Each point on the map corresponds to a point in the park by the similarity transformation.\n\nWe can define a map formally: A map is a rectangle $M$ (of smaller or equal size) together with a positive real number $r$ and a bijective function $f:M \\rightarrow P$ satisfying \n\n- For every pair of different points $a, b\\in M$, $|f(a)-f(b)|/|a-b|=r$.\n\n$|x-y|$ represents the Euclidean distance between points $x$ and $y$. \n\nLike in many games, Mio can teleport using the map. Precisely, when Mio is at some point $x$ on the map (including the boundary), she may teleport to the corresponding point $f(x)$ in the park. She may also choose not to teleport. The reverse is also true. When she is at point $y$ in the park (including the boundary), she may teleport to the point $f^{-1}(y)$ on the map representing her current location. And she may also choose not to teleport.\n\nMio can teleport at most $n$ (and at least $0$) times. Each teleport takes $k$ seconds. Mio can also walk on her foot at a speed of $1$ unit per second. \n\nGiven two points $s$ and $t$, find the minimum time Mio needs to reach $t$ from $s$.\n\nEach teleport can be in any direction (from the map to the park, or from the park to the map). The map may be placed upside down. Since the map is inside the park, it is possible that Mio is on the map and in the park simultaneously. In this case, she may teleport in either direction. \n\nFor example, in the following figure, the park is $ABCD$, and the map is $A'B'C'D'$. When Mio is inside the map, she is on the map and in the park simultaneously. When she is at point $D'$, she can teleport from the map to the park (reaching $D$), and from the park to the map (reaching $D^{\\prime\\prime}$).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hz6nq09e.png)", "inputFormat": "The first line contains a single integer $T$ ($1\\le T\\le 100$) denoting the number of test cases.\n\nFor each test case, the first line contains the $4$ corners of the rectangle representing the park. The corners are given in clockwise or counterclockwise order. It is guaranteed that the $4$ corners are distinct.\n\nThe second line contains the $4$ corners of the rectangle representing the map. The $i$-th corner of the map corresponds to the $i$-th corner of the park for all $1\\le i\\le 4$. Note that you can figure out whether the map is placed upside down or not by the order of the corners. The corners are given in clockwise or counterclockwise order. It is guaranteed that the map is inside the park. (The boundary of the map may intersect with the boundary of the park at $1$ or more points.) It is guaranteed that the map is valid, i.e., there is a positive real number and a bijective function from the map to the park satisfying the definition above.\n\nThe third line contains two points $s$ and $t$. It is guaranteed that $s$ and $t$ are inside (or on the boundary of) the park.\n\nThe fourth line contains two integers $k, n$ ($0\\le k\\le 2\\times 10^6, 0\\le n\\le 100$), the time each teleport needs, and the maximum number of teleports. \n\nEach point in the input is represented by a pair of integers whose absolute values are no more than $2\\times 10^6$. Integers are separated by single spaces.", "outputFormat": "For each test case, output one number representing the answer in one line. Your answer is considered correct if its absolute or relative error does not exceed $10^{-9}$.  ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2022] Map", "background": "", "description": "有一个著名的数学定理，如果你把一张公园的地图完全放在公园里，那么地图上存在一个点与它所代表的点重合。\n\nMio 非常喜欢这个定理，所以她把她最喜欢的公园的地图完全放在了公园里。公园 $P$ 可以用一个矩形表示。公园的地图只是一个较小（或相等）版本的公园在纸上的打印。地图与原始矩形相似。地图上的每个点都通过相似变换对应于公园中的一个点。\n\n我们可以正式定义地图：地图是一个矩形 $M$（大小较小或相等），加上一个正实数 $r$ 和一个双射函数 $f:M \\rightarrow P$，满足以下条件：\n\n- 对于 $M$ 中的每对不同的点 $a, b$，$|f(a)-f(b)|/|a-b|=r$。\n\n这里 $|x-y|$ 表示点 $x$ 和点 $y$ 之间的欧几里德距离。\n\n就像许多游戏一样，Mio 可以使用地图进行传送。准确地说，当 Mio 在地图上的某个点 $x$（包括边界）时，她可以传送到公园中相应的点 $f(x)$。她也可以选择不传送。反之亦然。当她在公园中的点 $y$（包括边界）时，她可以传送到代表她当前位置的地图上的点 $f^{-1}(y)$。她也可以选择不传送。\n\nMio 最多可以传送 $n$ 次（最少为 $0$ 次）。每次传送需要 $k$ 秒。Mio 还可以以每秒 $1$ 个单位的速度步行。\n\n给定两个点 $s$ 和 $t$，找出 Mio 从 $s$ 到 $t$ 需要的最短时间。\n\n每次传送可以是任意方向（从地图到公园，或从公园到地图）。地图可以倒置放置。由于地图位于公园内部，所以 Mio 可能同时在地图上和在公园中。在这种情况下，她可以选择传送的方向。\n\n例如，在下图中，公园是 $ABCD$，地图是 $A'B'C'D'$。当 Mio 在地图上时，她同时在地图上和在公园中。当她在点 $D'$ 时，她可以从地图传送到公园（到达 $D$），并从公园传送到地图（到达 $D^{\\prime\\prime}$）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hz6nq09e.png)", "inputFormat": "第一行包含一个整数 $T$（$1\\le T\\le 100$），表示测试用例的数量。\n\n对于每个测试用例，第一行包含表示公园矩形的 $4$ 个角点。角点按顺时针或逆时针顺序给出。保证 $4$ 个角点不相同。\n\n第二行包含表示地图矩形的 $4$ 个角点。地图的第 $i$ 个角点对应于公园的第 $i$ 个角点，对于所有 $1\\le i\\le 4$。请注意，您可以通过角点的顺序确定地图是否倒置放置。角点按顺时针或逆时针顺序给出。保证地图位于公园内部。（地图的边界可能与公园的边界在 $1$ 个或多个点相交。）保证地图是有效的，即存在一个正实数和一个从地图到公园的双射函数，满足上述的定义。\n\n第三行包含两个点 $s$ 和 $t$。保证 $s$ 和 $t$ 在公园内部（或在公园的边界上）。\n\n第四行包含两个整数 $k, n$（$0\\le k\\le 2\\times 10^6, 0\\le n\\le 100$），表示每次传送所需的时间，以及最大传送次数。\n\n输入中的每个点由一对整数表示，其绝对值不超过 $2\\times 10^6$。整数之间用单个空格分隔。", "outputFormat": "对于每个测试用例，输出一行数字表示答案。如果没有解决方案，则输出 $-1$。否则，输出最小的时间。您的答案被认为是正确的，如果其绝对或相对误差不超过 $10^{-9}$。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9721", "type": "P", "difficulty": 5, "samples": [["3\n\n0\n\n0\n\n1\n", "\n? 1 2\n\n? 1 3\n\n? 2 3\n\n! 2 3 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["二分", "2022", "交互题", "Special Judge", "O2优化", "排序", "ICPC", "EC Final"], "title": "[EC Final 2022] Inversion", "background": "", "description": "$\\textbf{This is an interactive problem.}$\n\nThere is a hidden permutation $p_1, p_2, \\dots, p_n$ of $\\{1, 2, \\dots, n\\}$. You want to find it by asking the parity of the number of inversions of $p_l,\\ldots, p_r$.\n\nYou can query in the format ${?~l~r}$, and the interactor will respond you $\\left( \\sum_{l\\leq i < j\\leq r} [p_i > p_j]\\right) \\bmod 2$. $[p_i>p_j]$ is $1$ when $p_i>p_j$ and $0$ when $p_i\\le p_j$.", "inputFormat": "Firstly, you should read the integer $n$ ($1\\le n\\le 2000$).\n\nAfter that, you can make no more than $4 \\times 10^4$ queries. To make a query, output ``${?~l~r}$'' ($1 \\leq l \\leq r \\leq n$) on a separate line, then you should read the response from standard input. \n\nTo give your answer, print ``${!~p_1~p_2~\\dots~p_n}$'' on a separate line. The output of the answer is \\textbf{not} counted towards the limit of $4 \\times 10^4$ queries. \n\nAfter that, your program should terminate. \n\nAfter printing a query, do not forget to output end of line and flush the output. To do this, use $\\texttt{fflush(stdout)}$ or $\\texttt{cout.flush()}$ in C++, $\\texttt{System.out.flush()}$ in Java, $\\texttt{flush(output)}$ in Pascal, or $\\texttt{stdout.flush()}$ in Python. \n\nIt is guaranteed that the permutation is fixed in advance. ", "outputFormat": "", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2022] Inversion", "background": "", "description": "$\\textbf{This is an interactive problem.}$\n\nThere is a hidden permutation $p_1, p_2, \\dots, p_n$ of $\\{1, 2, \\dots, n\\}$. You want to find it by asking the parity of the number of inversions of $p_l,\\ldots, p_r$.\n\nYou can query in the format ${?~l~r}$, and the interactor will respond you $\\left( \\sum_{l\\leq i < j\\leq r} [p_i > p_j]\\right) \\bmod 2$. $[p_i>p_j]$ is $1$ when $p_i>p_j$ and $0$ when $p_i\\le p_j$.", "inputFormat": "Firstly, you should read the integer $n$ ($1\\le n\\le 2000$).\n\nAfter that, you can make no more than $4 \\times 10^4$ queries. To make a query, output ``${?~l~r}$'' ($1 \\leq l \\leq r \\leq n$) on a separate line, then you should read the response from standard input. \n\nTo give your answer, print ``${!~p_1~p_2~\\dots~p_n}$'' on a separate line. The output of the answer is \\textbf{not} counted towards the limit of $4 \\times 10^4$ queries. \n\nAfter that, your program should terminate. \n\nAfter printing a query, do not forget to output end of line and flush the output. To do this, use $\\texttt{fflush(stdout)}$ or $\\texttt{cout.flush()}$ in C++, $\\texttt{System.out.flush()}$ in Java, $\\texttt{flush(output)}$ in Pascal, or $\\texttt{stdout.flush()}$ in Python. \n\nIt is guaranteed that the permutation is fixed in advance. ", "outputFormat": "", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2022] Inversion", "background": "", "description": "**这是一个交互式问题。**\n\n有一个隐藏的排列 $p_1, p_2, \\dots, p_n$，它是 $\\{1, 2, \\dots, n\\}$ 的一个排列。你需要通过询问 $p_l,\\ldots, p_r$ 的逆序数的奇偶性来找到它。\n\n你可以以 ${?~l~r}$ 的格式进行查询，交互器将会返回 $ \\left( \\sum_{l\\leq i < j\\leq r} [p_i > p_j]\\right) \\bmod 2$。当 $p_i > p_j$ 时，$[p_i>p_j]$ 为 $1$，否则为 $0$。", "inputFormat": "首先，你需要读取整数 $n$ ($1\\le n\\le 2000$)。\n\n在此之后，你可以进行不超过 $4 \\times 10^4$ 次查询。要进行一次查询，输出 ``${?~l~r}$'' ($1 \\leq l \\leq r \\leq n$) 在单独的一行上，然后你需要从标准输入读取响应。\n\n为了给出答案，打印 ``${!~p_1~p_2~\\dots~p_n}$'' 在单独的一行上。答案的输出不计入 $4 \\times 10^4$ 次查询的限制。\n\n在打印查询后，不要忘记输出换行并刷新输出。为此，在 C++ 中使用 $\\texttt{fflush(stdout)}$ 或 $\\texttt{cout.flush()}$，在 Java 中使用 $\\texttt{System.out.flush()}$，在 Pascal 中使用 $\\texttt{flush(output)}$，在 Python 中使用 $\\texttt{stdout.flush()}$。\n\n保证排列是预先固定的。", "outputFormat": "", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9722", "type": "P", "difficulty": 7, "samples": [["3\n1\n1 1 1000000000 1000000000\n3\n1 1 2 2\n3 3 4 4\n5 5 6 6\n5\n581574116 47617804 999010750 826131769\n223840663 366320907 613364068 926991396\n267630832 51913575 488301124 223957497\n217461197 492085159 999485867 913732845\n28144453 603781668 912516656 993160442", "230616300\n64\n977066618"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "2022", "O2优化", "ICPC", "吉司机线段树 segment tree beats", "EC Final"], "title": "[EC Final 2022] Rectangle", "background": "", "description": "Prof. Pang has $n$ rectangles, the coordinate of the lower left corner of the $i$-th rectangle is $(x_{i,1}, y_{i,1})$, and the coordinate of the upper right corner is $(x_{i,2}, y_{i,2})$. Rectangles may overlap.\n\nYou need to choose three straight lines such that:\n\n- Each line should be parallel to the $x$-axis or the $y$-axis, which means its formula is $x = a$ or $y = a$.\n- In the formula $x = a$ or $y = a$, $a$ should be an integer in $[1, 10^9]$.\n- These three lines should be distinct.\n- Each rectangle is $\\textbf{touched}$ by at least one line. A line touches a rectangle if it intersects with the boundary and/or the interior of the rectangle.\n\nYou need to compute the number of ways to choose three lines. Since the answer can be very large, output it modulo $998244353$. Two ways are considered the same if only the order of three lines differs in these two ways. ", "inputFormat": "The first line contains a single integer $T~(1 \\le T \\le 10^5)$, denoting the number of test cases.\n\nFor each test case, the first line contains an integer $n~(1 \\le n \\le 10^5)$. The $i$-th line of the next $n$ lines contains four integers $x_{i,1}, y_{i,1},x_{i,2}, y_{i,2}~(1\\le x_{i,1}<x_{i,2}\\le 10^9,1\\le y_{i,1}<y_{i,2}\\le 10^9)$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\times 10^5$.", "outputFormat": "For each test case, output one integer representing the answer in one line.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2022] Rectangle", "background": "", "description": "Prof. Pang has $n$ rectangles, the coordinate of the lower left corner of the $i$-th rectangle is $(x_{i,1}, y_{i,1})$, and the coordinate of the upper right corner is $(x_{i,2}, y_{i,2})$. Rectangles may overlap.\n\nYou need to choose three straight lines such that:\n\n- Each line should be parallel to the $x$-axis or the $y$-axis, which means its formula is $x = a$ or $y = a$.\n- In the formula $x = a$ or $y = a$, $a$ should be an integer in $[1, 10^9]$.\n- These three lines should be distinct.\n- Each rectangle is $\\textbf{touched}$ by at least one line. A line touches a rectangle if it intersects with the boundary and/or the interior of the rectangle.\n\nYou need to compute the number of ways to choose three lines. Since the answer can be very large, output it modulo $998244353$. Two ways are considered the same if only the order of three lines differs in these two ways. ", "inputFormat": "The first line contains a single integer $T~(1 \\le T \\le 10^5)$, denoting the number of test cases.\n\nFor each test case, the first line contains an integer $n~(1 \\le n \\le 10^5)$. The $i$-th line of the next $n$ lines contains four integers $x_{i,1}, y_{i,1},x_{i,2}, y_{i,2}~(1\\le x_{i,1}<x_{i,2}\\le 10^9,1\\le y_{i,1}<y_{i,2}\\le 10^9)$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\times 10^5$.", "outputFormat": "For each test case, output one integer representing the answer in one line.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2022] Rectangle", "background": "", "description": "庞教授有 $n$ 个矩形，第 $i$ 个矩形的左下角坐标是 $(x_{i,1}, y_{i,1})$，右上角坐标是 $(x_{i,2}, y_{i,2})$。矩形可以重叠。\n\n你需要选择三条直线，使得：\n\n- 每条直线应该与 $x$ 轴或 $y$ 轴平行，即其方程为 $x = a$ 或 $y = a$。\n- 在方程 $x = a$ 或 $y = a$ 中，$a$ 应该是 $[1, 10^9]$ 区间内的整数。\n- 这三条直线应该是不同的。\n- 每个矩形至少被一条直线 $\\textbf{触摸}$。如果一条直线与矩形的边界和/或内部相交，则称该直线触摸该矩形。\n\n你需要计算选择三条直线的方法数。由于答案可能非常大，输出对 $998244353$ 取模的结果。如果两种方法只有三条直线的顺序不同，则认为它们是相同的。", "inputFormat": "第一行包含一个整数 $T~(1 \\le T \\le 10^5)$，表示测试用例的数量。\n\n对于每个测试用例，第一行包含一个整数 $n~(1 \\le n \\le 10^5)$。接下来的 $n$ 行中，第 $i$ 行包含四个整数 $x_{i,1}, y_{i,1},x_{i,2}, y_{i,2}~(1\\le x_{i,1}<x_{i,2}\\le 10^9,1\\le y_{i,1}<y_{i,2}\\le 10^9)$。\n\n保证所有测试用例中 $n$ 的总和不超过 $2\\times 10^5$。", "outputFormat": "对于每个测试用例，输出一行整数，表示答案。\n\n**【样例解释】**\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9723", "type": "P", "difficulty": 5, "samples": [["5\n1\n1 1\n2\n1 1\n2 1\n2\n9 4\n9 6\n10\n1 1\n2 1\n2 2\n3 1\n3 2\n3 3\n4 1\n4 2\n4 3\n4 4\n10\n1 1\n2 1\n2 2\n5 7\n3 2\n3 3\n4 1\n4 2\n4 3\n4 4\n", "0\n1\n2\n6\n13\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "O2优化", "广度优先搜索 BFS", "ICPC", "EC Final"], "title": "[EC Final 2022] Chinese Checker", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/krp4wk8f.png)\n\nProf. Pang is playing Chinese Checkers. The game board is the same as the figure shown above. There are $n$ checkers on the board. Prof. Pang wants to know how many different moves there are on the current board.\n\nOne **move** consists of several **steps**. At first, Prof. Pang needs to choose one checker $a$ to move. In each step, Prof. Pang needs to choose another checker $b$ as the pivot, and move the checker $a$ to the symmetrical position about the checker $b$. (In one move, Prof. Pang cannot change his choice of $a$ between steps. **If after a step, the checker $a$ will return to its position before the move, this step is not allowed.**) There are several conditions about the pivot $b$:\n\n- The segment connecting $a$ and $b$ needs to be parallel to one of the coordinate axis. Note: There are three axes on the hexagonal board. One of them is horizontal and any pair of axes intersect at an angle of $\\pi/3$.\n- $a$ and $b$ **do not** need to be adjacent.\n- There cannot be extra checkers other than $b$ on the segment connecting $a$ and its symmetrical position.\n- The symmetrical position should be on the hexagonal board and is not occupied by any other checker.\n\nA move must have at least one step. After the first step, Prof. Pang can stop at any time he wants. And Prof. Pang can choose any checker on the board as the moving checker. Output the number of different moves Prof. Pang can make. Two moves are different if and only if the sets of positions of all checkers are different after these two moves, i.e., the checkers are indistinguishable. ", "inputFormat": "The first line contains an integer $T~(1\\leq T\\leq 100)$ -- the number of test cases.\n\nFor each test case, the first line contains an integer $n~(1\\leq n\\leq 121)$ -- the number of checkers.\n\nEach of the following $n$ lines contains two integers, indicating the position of a checker. The first number indicates which row it is in, and the second number indicates which one of this row it is. They are counting from top to bottom and left to right, starting from $1$.\n\nIt is guaranteed that checkers' positions are different.", "outputFormat": "For each test case, output one integer in a line -- the number of different moves.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2022] Chinese Checker", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/krp4wk8f.png)\n\nProf. Pang is playing Chinese Checkers. The game board is the same as the figure shown above. There are $n$ checkers on the board. Prof. Pang wants to know how many different moves there are on the current board.\n\nOne **move** consists of several **steps**. At first, Prof. Pang needs to choose one checker $a$ to move. In each step, Prof. Pang needs to choose another checker $b$ as the pivot, and move the checker $a$ to the symmetrical position about the checker $b$. (In one move, Prof. Pang cannot change his choice of $a$ between steps. **If after a step, the checker $a$ will return to its position before the move, this step is not allowed.**) There are several conditions about the pivot $b$:\n\n- The segment connecting $a$ and $b$ needs to be parallel to one of the coordinate axis. Note: There are three axes on the hexagonal board. One of them is horizontal and any pair of axes intersect at an angle of $\\pi/3$.\n- $a$ and $b$ **do not** need to be adjacent.\n- There cannot be extra checkers other than $b$ on the segment connecting $a$ and its symmetrical position.\n- The symmetrical position should be on the hexagonal board and is not occupied by any other checker.\n\nA move must have at least one step. After the first step, Prof. Pang can stop at any time he wants. And Prof. Pang can choose any checker on the board as the moving checker. Output the number of different moves Prof. Pang can make. Two moves are different if and only if the sets of positions of all checkers are different after these two moves, i.e., the checkers are indistinguishable. ", "inputFormat": "The first line contains an integer $T~(1\\leq T\\leq 100)$ -- the number of test cases.\n\nFor each test case, the first line contains an integer $n~(1\\leq n\\leq 121)$ -- the number of checkers.\n\nEach of the following $n$ lines contains two integers, indicating the position of a checker. The first number indicates which row it is in, and the second number indicates which one of this row it is. They are counting from top to bottom and left to right, starting from $1$.\n\nIt is guaranteed that checkers' positions are different.", "outputFormat": "For each test case, output one integer in a line -- the number of different moves.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2022] Chinese Checker", "background": "", "description": "棋盘上有 $n$ 个棋子，你需要求对于当前局面，下一次移动有多少种不同的走法。\n\n一次移动由若干步组成。假设当前要移动的棋子为 $a$，在每一步中，首先需要选择另一个棋子 $b$ 作为跳台，然后将 $a$ 走到关于 $b$ 的对称位置（在一次移动中，你无法更改需要移动的棋子 $a$。并且在某一步中，棋子 $a$ 回到此次移动前所在的位置是不被允许的）。\n\n关于跳台 $b$ 的选择有一些条件：\n\n- $a$ 和 $b$ 之间的连线应当平行于棋盘的某条坐标轴。注：棋盘上一共有三条坐标轴，其中一条与水平线平行，并且任意两条坐标轴之间的夹角均为 $\\frac{\\pi}{3}$。\n\n- $a$ 和 $b$ 不必相邻。\n\n- 除了跳台 $b$ 以外，$a$ 和其关于 $b$ 的对称点的连线上不能有其他棋子。\n\n- 对称点的位置应当落在棋盘上，并且没有被其他棋子占据。\n\n一次移动需要至少走一步。在第一步以后，你可以随时停下来。你可以选择棋盘上任意一个棋子作为移动棋子。请输出有多少种不同的走法。\n\n两种走法不同当且仅当两次移动后所有棋子的位置组成的集合不同，并且棋子之间不可区分。", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n对于每组数据，第一行一个整数 $n$，表示棋子数量。\n\n接下来 $n$ 行，每行两个整数，表示棋子位置。第一个整数表示棋子所在行，第二个整数表示棋子所在列（棋子在这一行的第几个位置上，注意每一行的起始位置和列数有可能是不一样的）。行列的编号从 $1$ 开始，分别从上到下，从左到右递增。\n\n保证每个棋子的位置互不相同。", "outputFormat": "输出 $T$ 行，每行一个整数，表示不同走法的数量。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9724", "type": "P", "difficulty": 5, "samples": [["5 5 3 1\n1 2\n2 4\n4 5\n1 3\n3 5\n", "2\n"], ["13 17 12 3\n1 2\n2 3\n3 4\n4 13\n5 13\n7 8\n7 9\n7 10\n7 11\n7 6\n12 7\n1 8\n8 9\n9 10\n10 11\n11 6\n6 13\n", "7\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "O2优化", "最短路", "ICPC", "EC Final"], "title": "[EC Final 2022] Chase Game", "background": "", "description": "Prof. Shou is being chased by Prof. Pang on an undirected unweighted simple graph. Initially, Prof. Shou is at vertex $1$. His destination is vertex $n$. Prof. Pang is at vertex $k$.\n\nIn each second, Prof. Shou may choose an adjacent vertex and walk to that vertex. Then Prof. Shou is attacked by Prof. Pang. The damage of this attack is equal to $d-dis$ where $d$ is Prof. Pang's attack range and $dis$ is the distance (number of edges in the shortest path) between Prof. Shou and Prof. Pang on the graph. However, when $dis$ is greater than or equal to $d$, Prof. Pang cannot deal any positive damage. In this case, instead of attacking with non-positive damage, he will teleport to the vertex where Prof. Shou is and then deal $d$ damage. (When $dis$ is less than $d$, Prof. Pang will stay at his current vertex.)\n\nPlease find the minimum sum of damage Prof. Shou will take to reach vertex $n$ from vertex $1$. Prof. Shou will take the last attack at vertex $n$.", "inputFormat": "The first line contains $4$ integers $n, m, k, d$ ($2\\le n\\le 10^5, n-1\\le m\\le 2\\times 10^5, 1\\le k\\le n, 1\\le d\\le 2\\times 10^5$).\n\nEach of the next $m$ lines contains two integers $a, b$ ($1\\le a, b\\le n, a \\ne b$) representing an edge of the graph. The edges are distinct. ($a\\ b$ and $b\\ a$ represents the same edge. Thus, only one of these two lines may appear in the input.)\n\nIt is guaranteed that the graph is connected.", "outputFormat": "Output one integer representing the answer in one line.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2022] Chase Game", "background": "", "description": "Prof. Shou is being chased by Prof. Pang on an undirected unweighted simple graph. Initially, Prof. Shou is at vertex $1$. His destination is vertex $n$. Prof. Pang is at vertex $k$.\n\nIn each second, Prof. Shou may choose an adjacent vertex and walk to that vertex. Then Prof. Shou is attacked by Prof. Pang. The damage of this attack is equal to $d-dis$ where $d$ is Prof. Pang's attack range and $dis$ is the distance (number of edges in the shortest path) between Prof. Shou and Prof. Pang on the graph. However, when $dis$ is greater than or equal to $d$, Prof. Pang cannot deal any positive damage. In this case, instead of attacking with non-positive damage, he will teleport to the vertex where Prof. Shou is and then deal $d$ damage. (When $dis$ is less than $d$, Prof. Pang will stay at his current vertex.)\n\nPlease find the minimum sum of damage Prof. Shou will take to reach vertex $n$ from vertex $1$. Prof. Shou will take the last attack at vertex $n$.", "inputFormat": "The first line contains $4$ integers $n, m, k, d$ ($2\\le n\\le 10^5, n-1\\le m\\le 2\\times 10^5, 1\\le k\\le n, 1\\le d\\le 2\\times 10^5$).\n\nEach of the next $m$ lines contains two integers $a, b$ ($1\\le a, b\\le n, a \\ne b$) representing an edge of the graph. The edges are distinct. ($a\\ b$ and $b\\ a$ represents the same edge. Thus, only one of these two lines may appear in the input.)\n\nIt is guaranteed that the graph is connected.", "outputFormat": "Output one integer representing the answer in one line.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2022] Chase Game", "background": "", "description": "Shou 教授被 Pang 教授在一个无向无权简单图上追赶。最初，Shou 教授在顶点 $1$。他的目的地是顶点 $n$。Pang 教授在顶点 $k$。\n\n每秒钟，Shou 教授可以选择一个相邻的顶点并走向该顶点。然后，Shou 教授会受到 Pang 教授的攻击。此次攻击的伤害等于 $d-dis$，其中 $d$ 是 Pang 教授的攻击范围，$dis$ 是图上从 Shou 教授到 Pang 教授的距离（最短路径上的边数）。然而，当 $dis$ 大于或等于 $d$ 时，Pang 教授无法造成任何正伤害。在这种情况下，他将不会使用非正的伤害攻击，而是会传送到 Shou 教授所在的顶点，然后造成 $d$ 伤害。（当 $dis$ 小于 $d$ 时，Pang 教授将停留在当前顶点。）\n\n请找出 Shou 教授从顶点 $1$ 到顶点 $n$ 所需的最小伤害总和。Shou 教授将在顶点 $n$ 处受到最后一次攻击。", "inputFormat": "第一行包含 $4$ 个整数 $n, m, k, d$ ($2\\le n\\le 10^5, n-1\\le m\\le 2\\times 10^5, 1\\le k\\le n, 1\\le d\\le 2\\times 10^5$)。\n\n接下来的 $m$ 行中，每行包含两个整数 $a, b$ ($1\\le a, b\\le n, a \\ne b$)，表示图的一条边。边是不同的。($a\\ b$ 和 $b\\ a$ 表示相同的边。因此，在输入中只会出现这两行中的一行。)\n\n保证图是连通的。", "outputFormat": "输出一行整数，表示答案。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9725", "type": "P", "difficulty": 4, "samples": [["4\n2\n1 2\n4\n1 2\n2 3\n3 4\n4\n1 2\n2 3\n2 4\n5\n1 2\n2 3\n3 4\n3 5\n", "-1\n1\n-1\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["图论", "2022", "O2优化", "ICPC", "EC Final"], "title": "[EC Final 2022] Chase Game 2", "background": "", "description": "Prof. Pang and Prof. Shou like playing a chase game.\n\nThe game map consists of $n$ rooms and $n-1$ bi-directional channels. The game map is connected. That means, the map forms a tree.\n\nAt first, Prof. Pang is in room $u$, while Prof. Shou is in room $v$ ($u\\neq v$). Prof. Pang and Prof. Shou take turns to play, and Prof. Shou goes first. In one's turn, the player knows his own position and the other player's position and can decide either to stay in the current room or to move to another room which is connected with the current room directly by a channel. When Prof. Pang and Prof. Shou are in the same room, Prof. Shou is caught by Prof. Pang. \n\nProf. Pang and Prof. Shou are smart enough. Prof. Pang wants to catch Prof. Shou in a finite number of turns. Prof. Shou does not want to be caught by Prof. Pang in any finite number of turns. \n\nProf. Shou gets tired of being caught every time and finds Prof. Fei for help. Prof. Shou asks Prof. Fei to add some channels so that Prof. Pang cannot catch him in finite number of turns for any pair of initial rooms $(u,v)$. Prof. Fei is lazy, so he hopes to add as few channels as possible. If no matter how to add the channels there is always a pair of rooms $(u,v)$ such that Prof. Pang can catch Prof. Shou, output $-1$.", "inputFormat": "The first line contains a single integer $T$ ($1\\le T\\le 10^4$) denoting the number of test cases. \n\nFor each test case, the first line contains a single integer $n$ ($2\\le n\\le 10^5$) denoting the number of rooms.\n\nFor the next $n-1$ lines, each line contains two integers $u$ and $v$ ($1\\le u, v\\le n$) denoting a channel connecting room $u$ and room $v$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\times 10^5$, and the rooms and channels always form a tree.", "outputFormat": "For each test case, print a number denoting the smallest number of added channels, or just print $-1$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2022] Chase Game 2", "background": "", "description": "Prof. Pang and Prof. Shou like playing a chase game.\n\nThe game map consists of $n$ rooms and $n-1$ bi-directional channels. The game map is connected. That means, the map forms a tree.\n\nAt first, Prof. Pang is in room $u$, while Prof. Shou is in room $v$ ($u\\neq v$). Prof. Pang and Prof. Shou take turns to play, and Prof. Shou goes first. In one's turn, the player knows his own position and the other player's position and can decide either to stay in the current room or to move to another room which is connected with the current room directly by a channel. When Prof. Pang and Prof. Shou are in the same room, Prof. Shou is caught by Prof. Pang. \n\nProf. Pang and Prof. Shou are smart enough. Prof. Pang wants to catch Prof. Shou in a finite number of turns. Prof. Shou does not want to be caught by Prof. Pang in any finite number of turns. \n\nProf. Shou gets tired of being caught every time and finds Prof. Fei for help. Prof. Shou asks Prof. Fei to add some channels so that Prof. Pang cannot catch him in finite number of turns for any pair of initial rooms $(u,v)$. Prof. Fei is lazy, so he hopes to add as few channels as possible. If no matter how to add the channels there is always a pair of rooms $(u,v)$ such that Prof. Pang can catch Prof. Shou, output $-1$.", "inputFormat": "The first line contains a single integer $T$ ($1\\le T\\le 10^4$) denoting the number of test cases. \n\nFor each test case, the first line contains a single integer $n$ ($2\\le n\\le 10^5$) denoting the number of rooms.\n\nFor the next $n-1$ lines, each line contains two integers $u$ and $v$ ($1\\le u, v\\le n$) denoting a channel connecting room $u$ and room $v$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\times 10^5$, and the rooms and channels always form a tree.", "outputFormat": "For each test case, print a number denoting the smallest number of added channels, or just print $-1$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2022] Chase Game 2", "background": "", "description": "庞教授和寿教授喜欢玩追逐游戏。\n\n游戏地图由 $n$ 个房间和 $n-1$ 条双向通道组成。游戏地图是连通的。这意味着地图形成一棵树。\n\n一开始，庞教授在房间 $u$，而寿教授在房间 $v$（$u\\neq v$）。庞教授和寿教授轮流玩游戏，寿教授先开始。在自己的回合中，玩家知道自己所在的位置和另一个玩家的位置，可以决定留在当前房间或者移动到与当前房间直接通过通道相连的另一个房间。当庞教授和寿教授在同一个房间时，寿教授被庞教授抓住。\n\n庞教授和寿教授足够聪明。庞教授希望在有限的回合内抓住寿教授。寿教授不希望在任何有限的回合内被庞教授抓住。\n\n寿教授厌倦了每次都被抓住，找到了费教授寻求帮助。寿教授请求费教授添加一些通道，使得无论初始房间对 $(u,v)$ 如何，庞教授都无法在有限的回合内抓住他。费教授很懒，所以他希望尽可能少地添加通道。如果无论如何添加通道，总是存在一对房间 $(u,v)$，使得庞教授能够抓住寿教授，输出 $-1$。", "inputFormat": "第一行包含一个整数 $T$ ($1\\le T\\le 10^4$)，表示测试用例的数量。\n\n对于每个测试用例，第一行包含一个整数 $n$ ($2\\le n\\le 10^5$)，表示房间的数量。\n\n接下来的 $n-1$ 行，每行包含两个整数 $u$ 和 $v$ ($1\\le u, v\\le n$)，表示连接房间 $u$ 和房间 $v$ 的通道。\n\n保证所有测试用例中 $n$ 的总和不超过 $2\\times 10^5$，并且房间和通道始终构成一棵树。\n\n对于每个测试用例，输出一个数字表示添加的通道的最小数量，或者只输出 $-1$。", "outputFormat": "输出一行整数，表示答案。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9726", "type": "P", "difficulty": 7, "samples": [["5\n2 3\n6 7\n1 9\n5 10\n4 8\n", "9\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384]}, "tags": ["2022", "网络流", "O2优化", "ICPC", "bitset", "EC Final"], "title": "[EC Final 2022] Magic", "background": "", "description": "**Warning: Unusual memory limit!**\n\nYou are given a sequence $a_0,\\ldots,a_{2n}$. Initially, all numbers are zero. \n\nThere are $n$ operations. The $i$-th operation is represented by two integers $l_i, r_i$ ($1\\le l_i < r_i\\le 2n, 1\\le i\\le n$), which assigns $i$ to $a_{l_i},\\ldots,a_{r_i-1}$.  It is guaranteed that all the $2n$ integers, $l_1,l_2,\\ldots, l_n, r_1, r_2, \\ldots, r_n$, are distinct.\n\nYou need to perform each operation exactly once, in arbitrary order.\n\nYou want to maximize the number of $i$ $(0\\leq i< 2n)$ such that $a_i\\neq a_{i+1}$ after all $n$ operations. Output the maximum number.", "inputFormat": "The first line contains an integer $n$ ($1\\le n\\le 5\\times 10^3$).\n\nThe $i$-th line of the next $n$ lines contains a pair of integers $l_i, r_i$ ($1\\le l_i < r_i\\le 2n$). It is guaranteed that all the $2n$ integers, $l_1,l_2,\\ldots, l_n, r_1, r_2, \\ldots, r_n$, are distinct.", "outputFormat": "Output one integer representing the answer in one line.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2022] Magic", "background": "", "description": "**Warning: Unusual memory limit!**\n\nYou are given a sequence $a_0,\\ldots,a_{2n}$. Initially, all numbers are zero. \n\nThere are $n$ operations. The $i$-th operation is represented by two integers $l_i, r_i$ ($1\\le l_i < r_i\\le 2n, 1\\le i\\le n$), which assigns $i$ to $a_{l_i},\\ldots,a_{r_i-1}$.  It is guaranteed that all the $2n$ integers, $l_1,l_2,\\ldots, l_n, r_1, r_2, \\ldots, r_n$, are distinct.\n\nYou need to perform each operation exactly once, in arbitrary order.\n\nYou want to maximize the number of $i$ $(0\\leq i< 2n)$ such that $a_i\\neq a_{i+1}$ after all $n$ operations. Output the maximum number.", "inputFormat": "The first line contains an integer $n$ ($1\\le n\\le 5\\times 10^3$).\n\nThe $i$-th line of the next $n$ lines contains a pair of integers $l_i, r_i$ ($1\\le l_i < r_i\\le 2n$). It is guaranteed that all the $2n$ integers, $l_1,l_2,\\ldots, l_n, r_1, r_2, \\ldots, r_n$, are distinct.", "outputFormat": "Output one integer representing the answer in one line.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2022] Magic", "background": null, "description": "**警告：不寻常的内存限制！**\n\n给定一个序列 $a_0, \\ldots, a_{2n}$。最初，所有数字都是零。\n\n有 $n$ 个操作。第 $i$ 个操作由两个整数 $l_i, r_i$ 表示（$1 \\le l_i < r_i \\le 2n, 1 \\le i \\le n$），它将 $i$ 赋值给 $a_{l_i}, \\ldots, a_{r_i-1}$。保证所有 $2n$ 个整数 $l_1, l_2, \\ldots, l_n, r_1, r_2, \\ldots, r_n$ 都是不同的。\n\n你需要以任意顺序执行每个操作恰好一次。\n\n你想要最大化满足 $a_i \n\\neq a_{i+1}$ 的 $i$ 的数量（$0 \\leq i < 2n$）在所有 $n$ 个操作之后。输出最大数量。", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 5 \\times 10^3$）。\n\n接下来的 $n$ 行中的第 $i$ 行包含一对整数 $l_i, r_i$（$1 \\le l_i < r_i \\le 2n$）。保证所有 $2n$ 个整数 $l_1, l_2, \\ldots, l_n, r_1, r_2, \\ldots, r_n$ 都是不同的。", "outputFormat": "输出一个整数，表示答案。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9727", "type": "P", "difficulty": 6, "samples": [["3\n2 2\n3 4\n3 8\n", "4\n11\n11\n9\n1110\n1110\n1110\n18\n11101110\n10111011\n11011011\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "Special Judge", "O2优化", "构造", "ICPC", "EC Final"], "title": "[EC Final 2022] Aqre", "background": "", "description": "Given an $n \\times m$ matrix, you need to fill it with $0$ and $1$, such that:\n\n- There cannot be **four** consecutive horizontal or vertical cells filled with the same number.\n- The cells filled with $1$ form a connected area. (Two cells are adjacent if they share an edge. A group of cells is said to be connected if for every pair of cells it is possible to find a path connecting the two cells which lies completely within the group, and which only travels from one cell to an adjacent cell in each step.)\n\nPlease construct a matrix satisfying the conditions above and has as many $1$s as possible. Output the maximum number of $1$s, and the matrix.", "inputFormat": "The first line contains an integer $T~(1\\leq T\\leq 10^3)$ -- the number of test cases.\n\nFor each test case, the first line contains two integers $n, m~(2\\leq n, m\\leq 10^3)$.\n\n### It is guaranteed that the sum of $n\\cdot m$ over all test cases does not exceed $10^6$.", "outputFormat": "For each test case, output the maximum number of $1$s in the first line. Then output the matrix in the following $n$ lines. If there are multiple solution, output any.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2022] Aqre", "background": "", "description": "Given an $n \\times m$ matrix, you need to fill it with $0$ and $1$, such that:\n\n- There cannot be **four** consecutive horizontal or vertical cells filled with the same number.\n- The cells filled with $1$ form a connected area. (Two cells are adjacent if they share an edge. A group of cells is said to be connected if for every pair of cells it is possible to find a path connecting the two cells which lies completely within the group, and which only travels from one cell to an adjacent cell in each step.)\n\nPlease construct a matrix satisfying the conditions above and has as many $1$s as possible. Output the maximum number of $1$s, and the matrix.", "inputFormat": "The first line contains an integer $T~(1\\leq T\\leq 10^3)$ -- the number of test cases.\n\nFor each test case, the first line contains two integers $n, m~(2\\leq n, m\\leq 10^3)$.\n\n### It is guaranteed that the sum of $n\\cdot m$ over all test cases does not exceed $10^6$.", "outputFormat": "For each test case, output the maximum number of $1$s in the first line. Then output the matrix in the following $n$ lines. If there are multiple solution, output any.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2022] Aqre", "background": null, "description": "给定一个 $n \\times m$ 矩阵，你需要用 $0$ 和 $1$ 填充它，使得满足以下条件：\n\n- 不能有**四个**连续的水平或垂直单元格填有相同的数字。\n- 填有 $1$ 的单元格形成一个连通区域。（如果它们共享一个边，则两个单元格是相邻的。如果对于每对单元格，可以找到一条完全位于该区域内的连接两个单元格的路径，并且每一步只能从一个单元格移动到相邻的单元格，则一组单元格被称为连通的。）\n\n请构造一个满足上述条件且具有尽可能多的 $1$ 的矩阵。输出 $1$ 的最大数量以及该矩阵。", "inputFormat": "第一行包含一个整数 $T~(1\\leq T\\leq 10^3)$，表示测试用例的数量。\n\n对于每个测试用例，第一行包含两个整数 $n, m~(2\\leq n, m\\leq 10^3)$。\n\n保证所有测试用例中 $n\\cdot m$ 的总和不超过 $10^6$。", "outputFormat": "对于每个测试用例，在第一行中输出 $1$ 的最大数量。然后在接下来的 $n$ 行中输出矩阵。如果有多种解决方案，则输出任意一个。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": null, "locale": "zh-CN"}}}
{"pid": "P9728", "type": "P", "difficulty": 3, "samples": [["5 2\n1 0 1 0 1\n", "13\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "2022", "O2优化", "ICPC", "EC Final"], "title": "[EC Final 2022] Dining Professors", "background": "", "description": "Prof. Pang invited $n$ professors to his banquet. The professors sit at a round table. For all $i$ from $1$ to $n$, professor $i$ sits adjacent to professor $(i \\bmod n) + 1$ and $((i + n - 2)\\bmod n) + 1$.\n\nProf. Pang prepared $n$ dishes. There are $n$ positions on the table. Position $i$ is in front of professor $i$. Professor $i$ can access only the dishes placed at positions $i$, $(i \\bmod n) + 1$, and $((i + n - 2)\\bmod n) + 1$. Prof. Pang will place exactly one dish at each position.\n\nAmong the dishes, $a$ of them are spicy and $n-a$ of them are not spicy. Some (possibly $0$) professors are unable to have spicy food. If a professor can have spicy food, his/her **satisfaction level** is the number of dishes (no matter spicy or not) he/she can access. If a professor cannot have spicy food, his/her satisfaction level is the number of not spicy dishes he/she can access.\n\nProf. Pang knows whether each professor can have spicy food or not. Please help him to arrange the dishes on the table so that the sum of satisfaction levels over all the professors is maximized. Output the maximum sum.", "inputFormat": "The first line contains two integers $n, a$ ($3\\le n\\le 10^5, 0\\le a\\le n$). \n\nThe second line contains $n$ integers $b_1, \\ldots, b_n$. $b_i$ is $0$ or $1$. $b_i=1$ means professor $i$ can have spicy food. $b_i=0$ means professor $i$ cannot have spicy food.", "outputFormat": "Output one integer representing the answer in one line.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2022] Dining Professors", "background": "", "description": "Prof. Pang invited $n$ professors to his banquet. The professors sit at a round table. For all $i$ from $1$ to $n$, professor $i$ sits adjacent to professor $(i \\bmod n) + 1$ and $((i + n - 2)\\bmod n) + 1$.\n\nProf. Pang prepared $n$ dishes. There are $n$ positions on the table. Position $i$ is in front of professor $i$. Professor $i$ can access only the dishes placed at positions $i$, $(i \\bmod n) + 1$, and $((i + n - 2)\\bmod n) + 1$. Prof. Pang will place exactly one dish at each position.\n\nAmong the dishes, $a$ of them are spicy and $n-a$ of them are not spicy. Some (possibly $0$) professors are unable to have spicy food. If a professor can have spicy food, his/her **satisfaction level** is the number of dishes (no matter spicy or not) he/she can access. If a professor cannot have spicy food, his/her satisfaction level is the number of not spicy dishes he/she can access.\n\nProf. Pang knows whether each professor can have spicy food or not. Please help him to arrange the dishes on the table so that the sum of satisfaction levels over all the professors is maximized. Output the maximum sum.", "inputFormat": "The first line contains two integers $n, a$ ($3\\le n\\le 10^5, 0\\le a\\le n$). \n\nThe second line contains $n$ integers $b_1, \\ldots, b_n$. $b_i$ is $0$ or $1$. $b_i=1$ means professor $i$ can have spicy food. $b_i=0$ means professor $i$ cannot have spicy food.", "outputFormat": "Output one integer representing the answer in one line.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2022] Dining Professors", "background": "", "description": "庞教授邀请了 $n$ 位教授参加他的宴会。教授们坐在一个圆桌周围。对于所有 $i$，从 $1$ 到 $n$，教授 $i$ 坐在教授 $(i \\bmod n) + 1$ 和 $((i + n - 2)\\bmod n) + 1$ 旁边。\n\n庞教授准备了 $n$ 道菜。桌子上有 $n$ 个位置。位置 $i$ 在教授 $i$ 的前面。教授 $i$ 只能接触到放在位置 $i$、$(i \\bmod n) + 1$ 和 $((i + n - 2)\\bmod n) + 1$ 处的菜。庞教授将在每个位置上放置一道菜。\n\n在这些菜中，有 $a$ 道是辣的，$n-a$ 道是不辣的。有些（可能为 $0$）教授不能吃辣的食物。如果一位教授可以吃辣的食物，他/她的**满意度水平**是他/她可以接触到的菜的数量（无论是辣的还是不辣的）。如果一位教授不能吃辣的食物，他/她的满意度水平是他/她可以接触到的不辣的菜的数量。\n\n庞教授知道每位教授是否可以吃辣的食物。请帮助他安排桌子上的菜，使得所有教授的满意度水平之和最大化。输出最大的总和。", "inputFormat": "第一行包含两个整数 $n, a$ ($3\\le n\\le 10^5, 0\\le a\\le n$)。\n\n第二行包含 $n$ 个整数 $b_1, \\ldots, b_n$。$b_i$ 是 $0$ 或 $1$。$b_i=1$ 表示教授 $i$ 可以吃辣的食物。$b_i=0$ 表示教授 $i$ 不能吃辣的食物。", "outputFormat": "输出一行一个整数，表示答案。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9730", "type": "P", "difficulty": 7, "samples": [["17 2\n42 1 33 1\n42 1 33 7\n", "YES\nNO\n"], ["1 1\n999999999999 999999999999 999999999999 999999999999\n", "YES\n"], ["2 1\n1000000000000 0 1 1000000000000\n", "NO\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "O2优化", "CEOI（中欧）"], "title": "[CEOI 2023] Grading Server", "background": "翻译自 CEOI2023 Day1 T2 [Grading Server](https://www.ceoi2023.de/wp-content/uploads/2023/09/2-grading-server.pdf)。", "description": "竞赛委员会的主席注意到了一些可疑的网络活动 —— 有人想要攻击评测系统！\n\n评测系统拥有特定的算力 $c_G$。黑客会尝试将 $c_G$ 降为 $0$（甚至更低）。系统被 $f_G$ 个防火墙保护着，每个防火墙都会将攻击的影响降低 $S$。\n\n每个时刻，黑客可以进行以下两种操作之一：\n\n- 击破一个防火墙，将 $f_G$ 降低 $1$（但不能低于 $0$），或者\n- 用他所有的算力 $c_H$ 攻击系统，将 $c_G$ 降低 $\\max(c_H - f_G\\cdot S, 0)$。\n\n但委员会主席可以反击：击破黑客的 $f_H$ 个防火墙之一；或者用系统的算力攻击黑客，类似地将 $c_H$ 降低 $\\max(c_G - f_H \\cdot S,0)$。委员会主席和黑客轮流行动，黑客先行动。\n\n为了安排防御，委员会成员需要一个程序告诉他们，在 $Q$ 个不同的 $(c_H, f_H, c_G, f_G)$ 情况下，就算委员会主席采取了最优的行动，黑客是否依然能够击垮评测系统（将 $c_G$ 降低为 $0$ 或更低）。", "inputFormat": "第一行两个整数 $S, Q$。\n\n接下来 $Q$ 行，每行四个整数 $c_H, f_H, c_G, f_G$ 描述一个情况，分别为黑客的算力和防火墙数量，以及评测系统的算力和防火墙数量。", "outputFormat": "你的程序应当输出 $Q$ 行，每行一个字符串 `YES` 或 `NO`。`YES` 表示无论委员会主席的行动如何，采取最优策略的黑客总能够让 $c_G$ 降为 $0$ 或更低；否则输出 `NO`。", "hint": "#### 样例解释\n\n考虑样例一的第一个情况：\n\n- 首先，黑客攻击评测系统，将 $c_G$ 降低 $42 - 1\\cdot 17 = 25$ 为 $8$；\n- 接下来，委员会主席无法通过攻击降低 $c_H$，所以明智的选择是击破黑客的唯一的防火墙；\n- 然而，黑客可以继续攻击评测系统，将 $c_G$ 降低 $25$ 为 $-17\\leq 0$，击垮评测系统并毁掉第一天比赛日。\n\n对于第二个情况：\n\n- 一开始，黑客唯一能做的就是击破一个评测系统的防火墙；\n- 接下来，委员会主席攻击黑客，将 $c_H$ 降低为 $26$；\n- 接下来两轮，黑客同样只能攻击评测系统的防火墙。同时委员会主席每次攻击黑客，将 $c_H$ 降低为不大于 $0$ 的值，成功防御黑客的攻击。\n\n#### 数据范围与约定\n\n- Subtask 1（5 分）：$S, c_H, c_G, f_H, f_G\\leq 75$；\n- Subtask 2（5 分）：$S, c_H, c_G, f_H, f_G\\leq 300$；\n- Subtask 3（10 分）：$S = 1$；\n- Subtask 4（25 分）：$S, c_H, c_G, f_H, f_G\\leq 2000$；\n- Subtask 5（20 分）：$S\\leq 400$；\n- Subtask 6（20 分）：$f_H, f_G\\leq 125$；\n- Subtask 7（15 分）：无特殊限制。\n\n对于所有数据，$1\\leq S\\leq 3\\times 10 ^ 4$，$1\\leq c_H, c_G\\leq 10 ^ {12}$，$0\\leq f_H, f_G\\leq 10 ^ {12}$，$1\\leq Q\\leq 2.5\\times 10 ^ 5$。\n\n#### 限制\n\n时间：4s  \n空间：1GB", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2023] Grading Server", "background": "翻译自 CEOI2023 Day1 T2 [Grading Server](https://www.ceoi2023.de/wp-content/uploads/2023/09/2-grading-server.pdf)。", "description": "竞赛委员会的主席注意到了一些可疑的网络活动 —— 有人想要攻击评测系统！\n\n评测系统拥有特定的算力 $c_G$。黑客会尝试将 $c_G$ 降为 $0$（甚至更低）。系统被 $f_G$ 个防火墙保护着，每个防火墙都会将攻击的影响降低 $S$。\n\n每个时刻，黑客可以进行以下两种操作之一：\n\n- 击破一个防火墙，将 $f_G$ 降低 $1$（但不能低于 $0$），或者\n- 用他所有的算力 $c_H$ 攻击系统，将 $c_G$ 降低 $\\max(c_H - f_G\\cdot S, 0)$。\n\n但委员会主席可以反击：击破黑客的 $f_H$ 个防火墙之一；或者用系统的算力攻击黑客，类似地将 $c_H$ 降低 $\\max(c_G - f_H \\cdot S,0)$。委员会主席和黑客轮流行动，黑客先行动。\n\n为了安排防御，委员会成员需要一个程序告诉他们，在 $Q$ 个不同的 $(c_H, f_H, c_G, f_G)$ 情况下，就算委员会主席采取了最优的行动，黑客是否依然能够击垮评测系统（将 $c_G$ 降低为 $0$ 或更低）。", "inputFormat": "第一行两个整数 $S, Q$。\n\n接下来 $Q$ 行，每行四个整数 $c_H, f_H, c_G, f_G$ 描述一个情况，分别为黑客的算力和防火墙数量，以及评测系统的算力和防火墙数量。", "outputFormat": "你的程序应当输出 $Q$ 行，每行一个字符串 `YES` 或 `NO`。`YES` 表示无论委员会主席的行动如何，采取最优策略的黑客总能够让 $c_G$ 降为 $0$ 或更低；否则输出 `NO`。", "hint": "#### 样例解释\n\n考虑样例一的第一个情况：\n\n- 首先，黑客攻击评测系统，将 $c_G$ 降低 $42 - 1\\cdot 17 = 25$ 为 $8$；\n- 接下来，委员会主席无法通过攻击降低 $c_H$，所以明智的选择是击破黑客的唯一的防火墙；\n- 然而，黑客可以继续攻击评测系统，将 $c_G$ 降低 $25$ 为 $-17\\leq 0$，击垮评测系统并毁掉第一天比赛日。\n\n对于第二个情况：\n\n- 一开始，黑客唯一能做的就是击破一个评测系统的防火墙；\n- 接下来，委员会主席攻击黑客，将 $c_H$ 降低为 $26$；\n- 接下来两轮，黑客同样只能攻击评测系统的防火墙。同时委员会主席每次攻击黑客，将 $c_H$ 降低为不大于 $0$ 的值，成功防御黑客的攻击。\n\n#### 数据范围与约定\n\n- Subtask 1（5 分）：$S, c_H, c_G, f_H, f_G\\leq 75$；\n- Subtask 2（5 分）：$S, c_H, c_G, f_H, f_G\\leq 300$；\n- Subtask 3（10 分）：$S = 1$；\n- Subtask 4（25 分）：$S, c_H, c_G, f_H, f_G\\leq 2000$；\n- Subtask 5（20 分）：$S\\leq 400$；\n- Subtask 6（20 分）：$f_H, f_G\\leq 125$；\n- Subtask 7（15 分）：无特殊限制。\n\n对于所有数据，$1\\leq S\\leq 3\\times 10 ^ 4$，$1\\leq c_H, c_G\\leq 10 ^ {12}$，$0\\leq f_H, f_G\\leq 10 ^ {12}$，$1\\leq Q\\leq 2.5\\times 10 ^ 5$。\n\n#### 限制\n\n时间：4s  \n空间：1GB", "locale": "zh-CN"}}}
{"pid": "P9731", "type": "P", "difficulty": 6, "samples": [["3 2 3\n1 2\n2 3\n2 3", "2 1\n3 2\n2 3"], ["3 4 3\n2 3 2 2\n2 3 3 2\n2 2 3 2", "2 2 2 3\n3 2 3 2\n2 3 2 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "Special Judge", "O2优化", "CEOI（中欧）", "欧拉回路", "构造"], "title": "[CEOI 2023] Balance", "background": "翻译自 CEOI2023 Day1 T3 [Balance](https://www.ceoi2023.de/wp-content/uploads/2023/09/3-balance.pdf)。", "description": "由于黑客对评测机的攻击，组委会决定重测所有提交记录。\n\n有 $N$ 台评测机，$T$ 个题目（编号为 $1, 2, \\cdots, T$）。组委会已经确定，每台评测机要评测哪些提交（数目相同，都是 $S$ 个提交，保证 $S$ 是 $2$ 的整数次幂）。在接下来的 $S$ 分钟内，每分钟每台评测机会评测一个提交。\n\n每个提交都会提交至某个题目。由于存数据的机器太脆弱了，所以要求，对于所有题目和任意两个时刻，在这两个时刻，这个题的被评测的提交的数量之差不超过 $1$。\n\n请构造一组方案，使得满足上面的条件。", "inputFormat": "第一行输入 $N, S, T$。\n\n接下来 $N$ 行，每行输入 $S$ 个整数，表示这个评测机被分配到的提交的题目编号。", "outputFormat": "输出 $N$ 行，每行 $S$ 个数，表示这个评测机按顺序要评测的提交的题目编号。\n\n可以证明，一定存在一组解。", "hint": "保证存在正整数 $k$ 使得 $S = 2 ^ k$，$1 \\le N, S, T \\le 10 ^ 5$，$NS \\le 5 \\times 10 ^ 5$。\n\n- Subtask 1（$10$ 分）：$S = 2$ 且 $N, T \\le 20$。\n- Subtask 2（$15 + 5 + 5$ 分）：$S = 2$。\n- Subtask 3（$15 + 5 + 5$ 分）：$NS \\le 10 ^ 4$。\n- Subtask 4（$20 + 10 + 10$ 分）：没有其它限制。\n\n对于后三个子任务，存在部分分（对应括号中的分数）：\n\n- 第一个数表示如果能解决满足 $T \\le N$ 且对于每个题目的提交数量均整除 $S$ 时的所有测试点能得到的分数。\n- 第二个数表示如果能解决满足 $T \\le N$ 时的所有测试点能多得到的分数。\n- 第三个数表示如果解决了整个 Subtask 时能多得到的分数。\n\n在洛谷上，本题分为 $10$ 个子任务。对于原来的后三个 Subtask，在本题中分别按顺序分为三个子任务（如原 Subtask 3 就是子任务 $5, 6, 7$），有依赖关系。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2023] Balance", "background": "翻译自 CEOI2023 Day1 T3 [Balance](https://www.ceoi2023.de/wp-content/uploads/2023/09/3-balance.pdf)。", "description": "由于黑客对评测机的攻击，组委会决定重测所有提交记录。\n\n有 $N$ 台评测机，$T$ 个题目（编号为 $1, 2, \\cdots, T$）。组委会已经确定，每台评测机要评测哪些提交（数目相同，都是 $S$ 个提交，保证 $S$ 是 $2$ 的整数次幂）。在接下来的 $S$ 分钟内，每分钟每台评测机会评测一个提交。\n\n每个提交都会提交至某个题目。由于存数据的机器太脆弱了，所以要求，对于所有题目和任意两个时刻，在这两个时刻，这个题的被评测的提交的数量之差不超过 $1$。\n\n请构造一组方案，使得满足上面的条件。", "inputFormat": "第一行输入 $N, S, T$。\n\n接下来 $N$ 行，每行输入 $S$ 个整数，表示这个评测机被分配到的提交的题目编号。", "outputFormat": "输出 $N$ 行，每行 $S$ 个数，表示这个评测机按顺序要评测的提交的题目编号。\n\n可以证明，一定存在一组解。", "hint": "保证存在正整数 $k$ 使得 $S = 2 ^ k$，$1 \\le N, S, T \\le 10 ^ 5$，$NS \\le 5 \\times 10 ^ 5$。\n\n- Subtask 1（$10$ 分）：$S = 2$ 且 $N, T \\le 20$。\n- Subtask 2（$15 + 5 + 5$ 分）：$S = 2$。\n- Subtask 3（$15 + 5 + 5$ 分）：$NS \\le 10 ^ 4$。\n- Subtask 4（$20 + 10 + 10$ 分）：没有其它限制。\n\n对于后三个子任务，存在部分分（对应括号中的分数）：\n\n- 第一个数表示如果能解决满足 $T \\le N$ 且对于每个题目的提交数量均整除 $S$ 时的所有测试点能得到的分数。\n- 第二个数表示如果能解决满足 $T \\le N$ 时的所有测试点能多得到的分数。\n- 第三个数表示如果解决了整个 Subtask 时能多得到的分数。\n\n在洛谷上，本题分为 $10$ 个子任务。对于原来的后三个 Subtask，在本题中分别按顺序分为三个子任务（如原 Subtask 3 就是子任务 $5, 6, 7$），有依赖关系。", "locale": "zh-CN"}}}
{"pid": "P9732", "type": "P", "difficulty": 7, "samples": [["5 3\n3 5 2 3 6\n2 1 5 2 3", "-1\n00111"], ["5 2\n1 6 1 5 2\n4 1 6 2 4", "2\n10111"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["线段树", "并查集", "2023", "Special Judge", "O2优化", "CEOI（中欧）", "决策单调性"], "title": "[CEOI 2023] Trade", "background": "译自 CEOI2023 Day2 T1 [Trade](https://www.ceoi2023.de/wp-content/uploads/2023/09/4-trade.pdf)。", "description": "有 $n$ 个机器人排成一排，第 $i$ 个机器人的购买价是 $c_i$ 欧元，卖出价是 $s_i$ 欧元。\n\n给定 $1\\le k\\le n$，你需要购买一段长度至少为 $k$ 的区间中所有的机器人，然后选择其中的恰好 $k$ 个机器人来卖出。\n\n你需要求出：\n1. 你能够得到的最大收益；\n2. 在收益最大化的前提下，哪些机器人可以在某种最优方案中被卖出。", "inputFormat": "第一行包含两个整数 $n,k$。\n\n第二行 $n$ 个正整数 $c_1,\\dots,c_n$。\n\n第三行 $n$ 个正整数 $s_1,\\dots,s_n$。", "outputFormat": "第一行输出一个整数表示最大收益。\n\n第二行输出一个 $01$ 串，第 $i$ 位输出 $1$ 表示第 $i$ 个机器人可以在某种最优方案中被卖出，反之第 $i$ 位输出 $0$。", "hint": "样例一中最优方案是购买第 $3\\sim 5$ 个机器人然后将它们卖出，但仍然会亏损 $1$ 欧元。\n\n样例二中最大收益为 $2$ 欧元，可以购买 $1,2,3$ 并卖出 $1,3$，也可以购买 $3,4$ 并卖出 $3,4$，也可以购买 $3,4,5$ 并卖出 $3,5$，因此 $1,3,4,5$ 都有可能在某种最优方案中被卖出，输出 `10111`。\n\n### 数据规模与约定\n\n对于全部数据，$1\\le k\\le n \\le 250000$，$1\\le c_i,s_i\\le 10^9$。\n\n- Subtask 1（5+5 points）：$n \\le 200$。\n- Subtask 2（5+5 points）：$n \\le 6000$。\n- Subtask 3（5+5 points）：$k=2$。\n- Subtask 4（10+15 points）：$k\\le 200$。\n- Subtask 5（25+20 points）：无特殊限制。\n\n在每个子任务中，如果第一行的输出正确，可以获得子任务前半部分的分数，如果第二行的输出也正确，可以获得子任务全部的分数。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2023] Trade", "background": "译自 CEOI2023 Day2 T1 [Trade](https://www.ceoi2023.de/wp-content/uploads/2023/09/4-trade.pdf)。", "description": "有 $n$ 个机器人排成一排，第 $i$ 个机器人的购买价是 $c_i$ 欧元，卖出价是 $s_i$ 欧元。\n\n给定 $1\\le k\\le n$，你需要购买一段长度至少为 $k$ 的区间中所有的机器人，然后选择其中的恰好 $k$ 个机器人来卖出。\n\n你需要求出：\n1. 你能够得到的最大收益；\n2. 在收益最大化的前提下，哪些机器人可以在某种最优方案中被卖出。", "inputFormat": "第一行包含两个整数 $n,k$。\n\n第二行 $n$ 个正整数 $c_1,\\dots,c_n$。\n\n第三行 $n$ 个正整数 $s_1,\\dots,s_n$。", "outputFormat": "第一行输出一个整数表示最大收益。\n\n第二行输出一个 $01$ 串，第 $i$ 位输出 $1$ 表示第 $i$ 个机器人可以在某种最优方案中被卖出，反之第 $i$ 位输出 $0$。", "hint": "样例一中最优方案是购买第 $3\\sim 5$ 个机器人然后将它们卖出，但仍然会亏损 $1$ 欧元。\n\n样例二中最大收益为 $2$ 欧元，可以购买 $1,2,3$ 并卖出 $1,3$，也可以购买 $3,4$ 并卖出 $3,4$，也可以购买 $3,4,5$ 并卖出 $3,5$，因此 $1,3,4,5$ 都有可能在某种最优方案中被卖出，输出 `10111`。\n\n### 数据规模与约定\n\n对于全部数据，$1\\le k\\le n \\le 250000$，$1\\le c_i,s_i\\le 10^9$。\n\n- Subtask 1（5+5 points）：$n \\le 200$。\n- Subtask 2（5+5 points）：$n \\le 6000$。\n- Subtask 3（5+5 points）：$k=2$。\n- Subtask 4（10+15 points）：$k\\le 200$。\n- Subtask 5（25+20 points）：无特殊限制。\n\n在每个子任务中，如果第一行的输出正确，可以获得子任务前半部分的分数，如果第二行的输出也正确，可以获得子任务全部的分数。", "locale": "zh-CN"}}}
{"pid": "P9733", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "交互题", "Special Judge", "O2优化", "CEOI（中欧）"], "title": "[CEOI 2023] The Ties That Guide Us (incursion)", "background": "", "description": "你用销售机器人的利润雇佣了一名助手，现在你准备好去拿走装有 CEOI 奖章的保险箱了。\n\n保险箱位于一所由 $n$ 个房间所组成的大学建筑内，这些房间由 $n-1$ 扇门连接。每个房间都可以从其他任何房间到达，且每个房间最多与 $3$ 扇门相连。  \n你和你的助手都有描述建筑物内房间相连情况的平面图，但是你们两个各自拥有的平面图虽然描述了相同的房间结构布局，但是房间和门的编号可能不同。\n\n在比赛的第二天，委员会忙于处理赛时通知和选手提问。这将是接近装着奖牌的保险箱的完美机会。\n\n你的助手会首先搜索整栋大楼。一旦他找到保险箱所在的房间，它就会给你留下前往那个房间的提示。由于手机不能带进赛场，他用了去年 BOI 留下的几乎无限供应的领带。由于这些领带完全相同无法区分，你能获得的信息就是他在任何给定房间里所留下的领带数量。由于一个房间内过多的领带非常可疑，因此任何单个房间内领带的最大数量应当尽可能少（参阅评分部分）。\n\n之后，你计划在上厕所的时候溜出去，利用助手留下来的领带找到有保险箱的房间。保险箱藏在房间里，所以你进入带有保险箱的房间时，必须依靠领带识别这个房间；此外，由于“上厕所”时间过长会被发现，你必须尽快找到保险箱。你最多可以走过 $d+30$ 扇门，其中 $d$ 是你的初始位置到保险箱所在位置的最短路径上的门数量。若重复穿过同一扇门，则每次都计入。\n\n因此，你需要编写一个程序，告诉助手需要在每个房间留下多少条领带，并引导你前往带有保险箱的房间。", "inputFormat": "本题为函数交互题。\n\n对于每个测试点，你的程序会运行两次。\n\n你需要实现如下两个函数（函数原型已给出）：\n```\nvector<int> mark(vector<pair<int,int>> F, int safe);\n```\n- $F$: 包含了 $n-1$ 个二元组 $(u,v)$，其中 $1 \\le u,v \\le n$ 并且保证 $u \\neq v$，代表在助手的地图上，$u$ 号房间和 $v$号房间之间由一扇门相连。\n- $\\mathrm{safe}$: 表示你的助手的地图上保险箱所在的房间编号。\n\n该函数应当返回一个长度为 $n$ 的 `vector<int>` $v$，其中每个元素 $v_i$ 代表你的助手应当在他地图上 $i+1$ 号房间留下的领带数量。你应当保证 $0 \\le v_i \\le 10^9$。\n\n```\nvoid locate(vector<pair<int,int>> F,int curr,int t);\n```\n- $F$: 包含了 $n-1$ 个二元组 $(u,v)$，其中 $1 \\le u,v \\le n$ 并且保证 $u \\neq v$，代表在你的地图上，$u$ 号房间和 $v$号房间之间由一扇门相连。\n- $\\mathrm{curr}$: 你目前所在的房间编号。\n- $t$: 在你当前所处的房间中，找到的领带数量。\n\n在如下的叙述中，房间编号采用你地图的编号方案。\n\n在实现函数 `locate` 的过程中，你可以调用如下函数：\n```\nint visit(int v);\n```\n以此来从你目前所在的房间 $u$ 移动到一个相邻的房间 $v$。你需要保证操作合法，即 $1 \\le v \\le n,(u,v) \\in F\\:\\vee (v,u) \\in F$。\n\n该函数返回一个非负整数 $k$，表示你在房间 $v$ 中找到的领带个数。\n\n该函数调用的次数不应超过 $d+30$，其中 $d$ 是你的起点到终点的最短距离。\n\n当函数 `locate` 终止时，你应当处于带有保险箱的房间内。\n\n对于每个测试点，第一次运行程序时调用 `mark`，第二次调用 `locate`。\n\n如果 `visit` 调用次数过多、调用不合法或在 `mark` 中被调用，你的程序将会被终止运行，提交将会被判**错误**。  \n你的程序不得写入或读取 `stdin` 或 `stdout`，否则将会被判**违反安全规定**。  \n但是你可以随便往 `stderr` 输出，没人管这个。\n\n你需要在源代码文件开头加上 `#include \"incursion.h\"`。\n\n你应当将程序与 `sample_grader.cpp` 链接以进行本地测试。\n\n下面是示例评分器的说明，请参阅 `sample_grader.cpp` 以获取操作说明。\n\n为简单起见，本评分器不会运行你的程序两次，而是在一次运行中调用两个函数各一次。附件中包含了一个 `sample_grader.cpp` 的示例实现。\n\n注意：该实现不与评测所用的实现相同，禁止采用 Hack 评分器的方式试图通过本题！\n", "outputFormat": "", "hint": "### 评分细则\n\n共有 4 个 subtask。对于每个测试点，$2 \\le n \\le 45000$。\n\nSubtask 1 (30 points)，保证没有一个房间有三扇门相连。\nSubtask 2 (30 points). 有且仅有一个房间有两扇门相连。\nSubtask 3 (40 points). 没有特殊性质。\n\n对于每个测试点，假设使用领带最多的房间用了 $T_{\\max}$ 条领带，\n- $T_{\\max}<2$，你将会获得该测试点 $100\\%$ 的分数。\n- $T_{\\max}=2$，你将会获得该测试点 $40\\%$ 的分数。\n- $2 < T_{\\max} \\le 10^9$，你将会获得该测试点 $30\\%$ 的分数。\n\n### 交互库使用方法\n**注意洛谷提供的交互库与原版不同。**\n\n请使用 `g++ -std=c++17 -Wall -O2 -o test interactive_lib.cpp xxx.cpp` 编译，其中 `xxx.cpp` 是你的程序名字。\n\n示例交互库首先从标准输入读入三个正整数, $n$, $s$, $seed$，表示点数、起点的原编号、随机数种子。\n\n然后读入 $n-1$ 行，每行两个正整数 $u,v$，表示原树的一条边。其中需保证 $1 \\le u < v \\le n$。\n然后读入一行一个字符串，表示打乱规则。\n\n**你不需要在意打乱序号的具体实现。该实现与最终评测所用交互库不一定相同。**\n\n接下来交互库将会调用一次 `mark`，一次 `locate`。注意交互库可能会打乱序号。\n\n交互库可能向终端输出以下信息：\n\n- `Invalid input.` 输入不合法。\n- `Invalid call to visit. (ALICE CALLED VISIT)` 在 `mark` 中调用 `visit`。\n- `Invalid call to visit. (INDEX ERROR)` 访问了不合法的点。\n- `Invalid call to visit. (NOT CONNECTED)` 访问的点和当前所在的点没有直接的边相连。\n- `Invalid call to visit. (TOO MANY VISITS)` 调用 `visit` 次数过多。\n- `Invalid return value of mark.` `mark` 的返回值不合法。即返回的 `vector` 长度不为 $n$ 或者有小于 $0$ 或大于 $10^9$ 的数。\n- `Not correct: current position is X` 最终并不在目标点，你应该在 $X$ 点（在第二张地图上）。\n- `Correct: at most X tie(s) per room.` 到达目标点，且用领带最多的房间使用了 X 条领带。\n\n最终评测时，只会返回正确与否的信息。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2023] The Ties That Guide Us (incursion)", "background": "", "description": "你用销售机器人的利润雇佣了一名助手，现在你准备好去拿走装有 CEOI 奖章的保险箱了。\n\n保险箱位于一所由 $n$ 个房间所组成的大学建筑内，这些房间由 $n-1$ 扇门连接。每个房间都可以从其他任何房间到达，且每个房间最多与 $3$ 扇门相连。  \n你和你的助手都有描述建筑物内房间相连情况的平面图，但是你们两个各自拥有的平面图虽然描述了相同的房间结构布局，但是房间和门的编号可能不同。\n\n在比赛的第二天，委员会忙于处理赛时通知和选手提问。这将是接近装着奖牌的保险箱的完美机会。\n\n你的助手会首先搜索整栋大楼。一旦他找到保险箱所在的房间，它就会给你留下前往那个房间的提示。由于手机不能带进赛场，他用了去年 BOI 留下的几乎无限供应的领带。由于这些领带完全相同无法区分，你能获得的信息就是他在任何给定房间里所留下的领带数量。由于一个房间内过多的领带非常可疑，因此任何单个房间内领带的最大数量应当尽可能少（参阅评分部分）。\n\n之后，你计划在上厕所的时候溜出去，利用助手留下来的领带找到有保险箱的房间。保险箱藏在房间里，所以你进入带有保险箱的房间时，必须依靠领带识别这个房间；此外，由于“上厕所”时间过长会被发现，你必须尽快找到保险箱。你最多可以走过 $d+30$ 扇门，其中 $d$ 是你的初始位置到保险箱所在位置的最短路径上的门数量。若重复穿过同一扇门，则每次都计入。\n\n因此，你需要编写一个程序，告诉助手需要在每个房间留下多少条领带，并引导你前往带有保险箱的房间。", "inputFormat": "本题为函数交互题。\n\n对于每个测试点，你的程序会运行两次。\n\n你需要实现如下两个函数（函数原型已给出）：\n```\nvector<int> mark(vector<pair<int,int>> F, int safe);\n```\n- $F$: 包含了 $n-1$ 个二元组 $(u,v)$，其中 $1 \\le u,v \\le n$ 并且保证 $u \\neq v$，代表在助手的地图上，$u$ 号房间和 $v$号房间之间由一扇门相连。\n- $\\mathrm{safe}$: 表示你的助手的地图上保险箱所在的房间编号。\n\n该函数应当返回一个长度为 $n$ 的 `vector<int>` $v$，其中每个元素 $v_i$ 代表你的助手应当在他地图上 $i+1$ 号房间留下的领带数量。你应当保证 $0 \\le v_i \\le 10^9$。\n\n```\nvoid locate(vector<pair<int,int>> F,int curr,int t);\n```\n- $F$: 包含了 $n-1$ 个二元组 $(u,v)$，其中 $1 \\le u,v \\le n$ 并且保证 $u \\neq v$，代表在你的地图上，$u$ 号房间和 $v$号房间之间由一扇门相连。\n- $\\mathrm{curr}$: 你目前所在的房间编号。\n- $t$: 在你当前所处的房间中，找到的领带数量。\n\n在如下的叙述中，房间编号采用你地图的编号方案。\n\n在实现函数 `locate` 的过程中，你可以调用如下函数：\n```\nint visit(int v);\n```\n以此来从你目前所在的房间 $u$ 移动到一个相邻的房间 $v$。你需要保证操作合法，即 $1 \\le v \\le n,(u,v) \\in F\\:\\vee (v,u) \\in F$。\n\n该函数返回一个非负整数 $k$，表示你在房间 $v$ 中找到的领带个数。\n\n该函数调用的次数不应超过 $d+30$，其中 $d$ 是你的起点到终点的最短距离。\n\n当函数 `locate` 终止时，你应当处于带有保险箱的房间内。\n\n对于每个测试点，第一次运行程序时调用 `mark`，第二次调用 `locate`。\n\n如果 `visit` 调用次数过多、调用不合法或在 `mark` 中被调用，你的程序将会被终止运行，提交将会被判**错误**。  \n你的程序不得写入或读取 `stdin` 或 `stdout`，否则将会被判**违反安全规定**。  \n但是你可以随便往 `stderr` 输出，没人管这个。\n\n你需要在源代码文件开头加上 `#include \"incursion.h\"`。\n\n你应当将程序与 `sample_grader.cpp` 链接以进行本地测试。\n\n下面是示例评分器的说明，请参阅 `sample_grader.cpp` 以获取操作说明。\n\n为简单起见，本评分器不会运行你的程序两次，而是在一次运行中调用两个函数各一次。附件中包含了一个 `sample_grader.cpp` 的示例实现。\n\n注意：该实现不与评测所用的实现相同，禁止采用 Hack 评分器的方式试图通过本题！\n", "outputFormat": "", "hint": "### 评分细则\n\n共有 4 个 subtask。对于每个测试点，$2 \\le n \\le 45000$。\n\nSubtask 1 (30 points)，保证没有一个房间有三扇门相连。\nSubtask 2 (30 points). 有且仅有一个房间有两扇门相连。\nSubtask 3 (40 points). 没有特殊性质。\n\n对于每个测试点，假设使用领带最多的房间用了 $T_{\\max}$ 条领带，\n- $T_{\\max}<2$，你将会获得该测试点 $100\\%$ 的分数。\n- $T_{\\max}=2$，你将会获得该测试点 $40\\%$ 的分数。\n- $2 < T_{\\max} \\le 10^9$，你将会获得该测试点 $30\\%$ 的分数。\n\n### 交互库使用方法\n**注意洛谷提供的交互库与原版不同。**\n\n请使用 `g++ -std=c++17 -Wall -O2 -o test interactive_lib.cpp xxx.cpp` 编译，其中 `xxx.cpp` 是你的程序名字。\n\n示例交互库首先从标准输入读入三个正整数, $n$, $s$, $seed$，表示点数、起点的原编号、随机数种子。\n\n然后读入 $n-1$ 行，每行两个正整数 $u,v$，表示原树的一条边。其中需保证 $1 \\le u < v \\le n$。\n然后读入一行一个字符串，表示打乱规则。\n\n**你不需要在意打乱序号的具体实现。该实现与最终评测所用交互库不一定相同。**\n\n接下来交互库将会调用一次 `mark`，一次 `locate`。注意交互库可能会打乱序号。\n\n交互库可能向终端输出以下信息：\n\n- `Invalid input.` 输入不合法。\n- `Invalid call to visit. (ALICE CALLED VISIT)` 在 `mark` 中调用 `visit`。\n- `Invalid call to visit. (INDEX ERROR)` 访问了不合法的点。\n- `Invalid call to visit. (NOT CONNECTED)` 访问的点和当前所在的点没有直接的边相连。\n- `Invalid call to visit. (TOO MANY VISITS)` 调用 `visit` 次数过多。\n- `Invalid return value of mark.` `mark` 的返回值不合法。即返回的 `vector` 长度不为 $n$ 或者有小于 $0$ 或大于 $10^9$ 的数。\n- `Not correct: current position is X` 最终并不在目标点，你应该在 $X$ 点（在第二张地图上）。\n- `Correct: at most X tie(s) per room.` 到达目标点，且用领带最多的房间使用了 X 条领带。\n\n最终评测时，只会返回正确与否的信息。", "locale": "zh-CN"}}}
{"pid": "P9734", "type": "P", "difficulty": 7, "samples": [["4 5 20 6\n0 1 3 19\n0 2 2 8\n1 2 4 15\n1 3 5 14\n2 3 1 18\n0 3 5\n0 3 7\n0 3 9\n2 0 6\n3 1 10\n1 2 15", "3\n8\n14\n2\n5\n7"], ["6 10 100 9\n5 3 4 29\n1 0 6 26\n0 4 2 7\n0 5 18 18\n2 0 79 82\n3 4 35 46\n1 2 15 57\n2 4 3 6\n4 1 21 83\n3 2 47 53\n0 2 63\n0 4 70\n0 4 98\n0 5 25\n0 5 19\n0 4 96\n0 5 2\n0 3 62\n0 3 83", "42\n32\n4\n93\n99\n6\n102\n60\n39"], ["8 12 1000000000000000 13\n2 0 4451698272827 120985696255786\n6 5 78520421713825 342652131468508\n2 1 185377268405175 382583457603811\n0 4 54350742205838 133614919589507\n7 0 68486247989149 651590905094148\n0 6 85177550834829 299184420663240\n5 2 442329739732459 926608308293721\n3 7 78020232822359 913548478810253\n1 3 267796317244889 687571310475622\n5 4 90590208828121 910324397566584\n5 7 8414633059584 17796117322043\n4 6 45682367792138 204548471584556\n7 2 44779065000162\n3 5 79376234836942\n4 7 305556687070759\n4 3 927935834343174\n5 1 663284649258985\n2 5 967584209777344\n5 2 963749709374595\n7 4 484562389171308\n1 5 446160773830045\n6 4 801452311055604\n3 1 744524289545354\n0 6 467418420721777\n5 6 371181379240653", "72937946261976\n929038398222642\n702857945988825\n272921388674172\n580895059624855\n181808439529442\n117602869946965\n569788353034530\n1181546234307589\n244230056736534\n513790925121797\n617759130113052\n674500988551485"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2021", "JOISC/JOIST（日本）"], "title": "[JOISC 2021] 逃走経路 (Escape Route) (Day2)", "background": "在洛谷上提交本题**不是**交互题，请注意提交方式。\n\n本题测试数据很大，评测可能需要加载 1-2 分钟。\n\n[英文题面](https://www2.ioi-jp.org/camp/2021/2021-sp-tasks/day2/escape_route-en.pdf)。", "description": "IOI 王国使用 Byou（秒）作为时间单位，将一天划分成 $S$ Byou，分别称为时刻 $0,1,\\dotsc,S-1$。\n\nIOI 王国中有 $N$ 个城市和 $M$ 条双向道路，均从 $0$ 开始标号。保证任两个城市之间均连通。第 $i$ 条道路连接城市 $A_i$ 和 $B_i$，需要恰好 $L_i$ Byou 通过。每天的时刻 $C_i$ 后，第 $i$ 条道路将开始进行检查，直到当天结束。\n\nJOI 组织是一个活跃在 IOI 王国中的秘密团体。出于其保密性，成员不能在道路上受到检查。如果其成员想要通过道路 $i$，最晚要在时刻 $C_i-L_i$ 到达这条路的一端。道路的检查不会影响两端的城市。\n\n现在有 $Q$ 名 JOI 组织的成员，从 $0$ 开始标号。第 $j$ 名成员在某天的时刻 $T_j$，要从城市 $U_j$ 出发去城市 $V_j$。成员可以在任意城市内停留任意长的时间。注意这名成员可能会在路上花费一天以上。\n\n请计算每名成员花费的最短时间，精确到 Byou.", "inputFormat": "第一行四个正整数 $N,M,S,Q$。\n\n接下来 $M$ 行，第 $i$ 行四个正整数表示 $A_{i-1},B_{i-1},L_{i-1},C_{i-1}$。\n\n接下来 $Q$ 行，第 $i$ 行三个正整数表示 $U_{i-1},V_{i-1},T_{i-1}$。", "outputFormat": "输出共 $Q$ 行，第 $i$ 行表示第 $i-1$ 名成员旅行所需的最短时间。", "hint": "对于 $100\\%$ 的数据，保证：\n\n- $2 \\leq N \\leq 90$。\n- $N-1 \\leq M \\leq \\dfrac{N(N-1)}{2}$。\n- $2 \\leq S \\leq 10^{15}$。\n- $1 \\leq Q \\leq 3 \\times 10^6$。\n- $0 \\leq A_i,B_i \\leq N-1$。\n- $A_i \\neq B_i$。\n- $\\forall i,j \\in [0,M-1]$，若 $i \\neq j$，则有 $(A_i,B_i) \\neq (A_j,B_j),(A_i,B_i) \\neq (B_j,A_j)$。\n- $1 \\leq L_i \\leq C_i < S$。\n- 从任意城市出发走过一些边后，可以到达任意其他城市。\n- $0\\leq U_j,V_j \\leq N-1$。\n- $U_j \\neq V_j$。\n- $0 \\leq T_j < S$。\n\n有 $5 \\%$ 的分数，满足 $N \\leq 40,Q \\leq 1000$。\n\n另有 $20 \\%$ 的分数，满足 $N \\leq 40,U_j=0$\n\n另有 $10 \\%$ 的分数，满足 $N \\leq 40$。\n\n另有 $35 \\%$ 的分数，满足 $N \\leq 60$。\n\n**建议使用较快的 IO 方式。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOISC 2021] 逃走経路 (Escape Route) (Day2)", "background": "在洛谷上提交本题**不是**交互题，请注意提交方式。\n\n本题测试数据很大，评测可能需要加载 1-2 分钟。\n\n[英文题面](https://www2.ioi-jp.org/camp/2021/2021-sp-tasks/day2/escape_route-en.pdf)。", "description": "IOI 王国使用 Byou（秒）作为时间单位，将一天划分成 $S$ Byou，分别称为时刻 $0,1,\\dotsc,S-1$。\n\nIOI 王国中有 $N$ 个城市和 $M$ 条双向道路，均从 $0$ 开始标号。保证任两个城市之间均连通。第 $i$ 条道路连接城市 $A_i$ 和 $B_i$，需要恰好 $L_i$ Byou 通过。每天的时刻 $C_i$ 后，第 $i$ 条道路将开始进行检查，直到当天结束。\n\nJOI 组织是一个活跃在 IOI 王国中的秘密团体。出于其保密性，成员不能在道路上受到检查。如果其成员想要通过道路 $i$，最晚要在时刻 $C_i-L_i$ 到达这条路的一端。道路的检查不会影响两端的城市。\n\n现在有 $Q$ 名 JOI 组织的成员，从 $0$ 开始标号。第 $j$ 名成员在某天的时刻 $T_j$，要从城市 $U_j$ 出发去城市 $V_j$。成员可以在任意城市内停留任意长的时间。注意这名成员可能会在路上花费一天以上。\n\n请计算每名成员花费的最短时间，精确到 Byou.", "inputFormat": "第一行四个正整数 $N,M,S,Q$。\n\n接下来 $M$ 行，第 $i$ 行四个正整数表示 $A_{i-1},B_{i-1},L_{i-1},C_{i-1}$。\n\n接下来 $Q$ 行，第 $i$ 行三个正整数表示 $U_{i-1},V_{i-1},T_{i-1}$。", "outputFormat": "输出共 $Q$ 行，第 $i$ 行表示第 $i-1$ 名成员旅行所需的最短时间。", "hint": "对于 $100\\%$ 的数据，保证：\n\n- $2 \\leq N \\leq 90$。\n- $N-1 \\leq M \\leq \\dfrac{N(N-1)}{2}$。\n- $2 \\leq S \\leq 10^{15}$。\n- $1 \\leq Q \\leq 3 \\times 10^6$。\n- $0 \\leq A_i,B_i \\leq N-1$。\n- $A_i \\neq B_i$。\n- $\\forall i,j \\in [0,M-1]$，若 $i \\neq j$，则有 $(A_i,B_i) \\neq (A_j,B_j),(A_i,B_i) \\neq (B_j,A_j)$。\n- $1 \\leq L_i \\leq C_i < S$。\n- 从任意城市出发走过一些边后，可以到达任意其他城市。\n- $0\\leq U_j,V_j \\leq N-1$。\n- $U_j \\neq V_j$。\n- $0 \\leq T_j < S$。\n\n有 $5 \\%$ 的分数，满足 $N \\leq 40,Q \\leq 1000$。\n\n另有 $20 \\%$ 的分数，满足 $N \\leq 40,U_j=0$\n\n另有 $10 \\%$ 的分数，满足 $N \\leq 40$。\n\n另有 $35 \\%$ 的分数，满足 $N \\leq 60$。\n\n**建议使用较快的 IO 方式。**", "locale": "zh-CN"}}}
{"pid": "P9735", "type": "P", "difficulty": 2, "samples": [["4\nPatrik 3\nPatrik 5\nJosip 1 7", "2 2 3"], ["2\nJosip 1 5", "5 1 2"], ["5\nPatrik 4\nJosip 2 4\nJosip 2 6\nJosip 4 2", "2 3 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2022", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #2] Tramvaji", "background": "", "description": "Patrik 和 Josip 在坐电车。他们共坐了 $n$ 站。\n\n除了上车的那一站，其他每一站到站时，都会发生以下事件中的一种：\n\n- Patrik 说：从上车到现在经过了 $t$ 分钟。\n\n- Josip 说：从第 $y$ 站到这里花费了 $t$ 分钟。\n\n现在，请你根据这些信息，求出哪两个站之间所需要的时间最短，以及这个时间。", "inputFormat": "输入共 $n$ 行：\n\n第一行，一个整数 $n$（$2\\le n\\le1000$），表示车站数量。\n\n接下来 $n-1$ 行，第 $i$ 行表示第 $i+1$ 个车站发生的事件：\n\n- 第一种操作：$\\texttt{Patrik } t_i$（$1\\le t_i\\le10^9$）\n\n- 第二种操作：$\\texttt{Josip } y_i\\texttt{ }t_i$（$y_i < i + 1$，$1\\le t_i\\le10^9$）\n\n**每个车站都处在不同的位置。**", "outputFormat": "一行，三个整数 $t$，$x_1$，$x_2$，表示最短时间，以及花费最短时间的起点和终点。\n\n**如果有多组解，输出字典序最小的那一组。**", "hint": "**本题采用捆绑测试。**\n\n|$\\text{Subtask}$|分数|特殊性质|\n|:-:|:-:|:-:|\n|$1$|$12$|$t_i \\le 1000$ |\n|$2$|$13$|只有 $\\texttt{Patrik}$ 事件 |\n|$3$|$25$|无|\n\n**本题满分 $50$ 分。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #2] Tramvaji", "background": "", "description": "Patrik 和 Josip 在坐电车。他们共坐了 $n$ 站。\n\n除了上车的那一站，其他每一站到站时，都会发生以下事件中的一种：\n\n- Patrik 说：从上车到现在经过了 $t$ 分钟。\n\n- Josip 说：从第 $y$ 站到这里花费了 $t$ 分钟。\n\n现在，请你根据这些信息，求出哪两个站之间所需要的时间最短，以及这个时间。", "inputFormat": "输入共 $n$ 行：\n\n第一行，一个整数 $n$（$2\\le n\\le1000$），表示车站数量。\n\n接下来 $n-1$ 行，第 $i$ 行表示第 $i+1$ 个车站发生的事件：\n\n- 第一种操作：$\\texttt{Patrik } t_i$（$1\\le t_i\\le10^9$）\n\n- 第二种操作：$\\texttt{Josip } y_i\\texttt{ }t_i$（$y_i < i + 1$，$1\\le t_i\\le10^9$）\n\n**每个车站都处在不同的位置。**", "outputFormat": "一行，三个整数 $t$，$x_1$，$x_2$，表示最短时间，以及花费最短时间的起点和终点。\n\n**如果有多组解，输出字典序最小的那一组。**", "hint": "**本题采用捆绑测试。**\n\n|$\\text{Subtask}$|分数|特殊性质|\n|:-:|:-:|:-:|\n|$1$|$12$|$t_i \\le 1000$ |\n|$2$|$13$|只有 $\\texttt{Patrik}$ 事件 |\n|$3$|$25$|无|\n\n**本题满分 $50$ 分。**", "locale": "zh-CN"}}}
{"pid": "P9736", "type": "P", "difficulty": 3, "samples": [["1 2", "1\nA A A\nA"], ["3 2", "6\nD C C\nD C C\nD C C\nD C C\nD C C\nD C C\nC\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "Special Judge", "O2优化", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #2] Ekspert", "background": null, "description": "给定四个变量 $\\texttt{A}$，$\\texttt{B}$，$\\texttt{C}$，$\\texttt{D}$，初始值为 $x$，$y$，$0$，$1$。\n\n你可以对它们进行如下操作：\n\n选择两个变量，将他们相加的和存储在一个变量中。\n\n请你使用该种操作不超过 $100$ 次，使任意一个变量的值等于 $x\\times y$。", "inputFormat": "一行，两个整数 $x$，$y$（$1\\le x\\times y\\le10^{18}$），含义如题目所述。", "outputFormat": "第一行，输出一个正整数 $n$（$0\\le n\\le100$），表示操作次数。\n\n接下来 $n$ 行，第 $i$ 行记录第 $i$ 次操作，形如 $\\texttt{R1 R2 R3}$，表示将 $\\texttt{R1}$ 和 $\\texttt{R2}$ 的和存储在 $\\texttt{R3}$ 中。", "hint": "| $\\text{Subtask}$|分值|特殊性质|\n|:-:|:-:|:-:|\n|$1$|$14$|$x,y \\le 50$ |\n|$2$|$14$|$x\\times y \\le 10^4$|\n|$3$|$42$|无|\n\n**本题满分 $70$ 分。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #2] Ekspert", "background": null, "description": "给定四个变量 $\\texttt{A}$，$\\texttt{B}$，$\\texttt{C}$，$\\texttt{D}$，初始值为 $x$，$y$，$0$，$1$。\n\n你可以对它们进行如下操作：\n\n选择两个变量，将他们相加的和存储在一个变量中。\n\n请你使用该种操作不超过 $100$ 次，使任意一个变量的值等于 $x\\times y$。", "inputFormat": "一行，两个整数 $x$，$y$（$1\\le x\\times y\\le10^{18}$），含义如题目所述。", "outputFormat": "第一行，输出一个正整数 $n$（$0\\le n\\le100$），表示操作次数。\n\n接下来 $n$ 行，第 $i$ 行记录第 $i$ 次操作，形如 $\\texttt{R1 R2 R3}$，表示将 $\\texttt{R1}$ 和 $\\texttt{R2}$ 的和存储在 $\\texttt{R3}$ 中。", "hint": "| $\\text{Subtask}$|分值|特殊性质|\n|:-:|:-:|:-:|\n|$1$|$14$|$x,y \\le 50$ |\n|$2$|$14$|$x\\times y \\le 10^4$|\n|$3$|$42$|无|\n\n**本题满分 $70$ 分。**", "locale": "zh-CN"}}}
{"pid": "P9737", "type": "P", "difficulty": 5, "samples": [["2 2 1\n0 0 1 2", "3"], ["3 3 0", "36"], ["3 3 5\n0 0 0 0\n0 0 1 3\n0 0 3 1\n1 3 3 1\n1 3 3 1", "7"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #2] Lampice", "background": "", "description": "Teo 的阳台是一个长 $n+1$，宽 $m+1$ 的矩形平台，上有 $2k$ 盏彩灯，这些彩灯的颜色用 $1 \\sim k$ 之间的一个数字来表示。每种颜色的彩灯都有 $2$ 盏，它们的坐标都为正整数。\n\nTeo 认为阳台上一个区域是好的，当且仅当：\n\n- 这个小区域是矩形，且边都与阳台的边平行。\n\n- 对于每一种颜色的 $2$ 盏彩灯，要么都在小区域内，要么都在小区域外。\n\n- 小区域的左上角，右下角坐标均为整数。\n\n- 小区域的长宽都**至少**为 $2$。\n\n现在，Teo 想请你求出在他的阳台上，有多少个小区域是好的。\n\n**注意：左下角坐标为 $(0,0)$，右上角坐标为 $(n,m)$。**", "inputFormat": "第一行，三个整数 $n$，$m$，$k$（$1\\le n\\le150,1\\le m\\le1000,0\\le k\\le200000$），表示阳台的长，宽，和彩灯的颜色数。\n\n接下来 $k$ 行，每行 $4$ 个整数 $x_1$，$y_1$，$x_2$，$y_2$，第 $i$ 行表示颜色为 $i$ 的两盏彩灯的坐标。", "outputFormat": "一行，一个整数，表示好的小区域个数。", "hint": "|$\\text{Subtask}$|分值|特殊性质|\n|:-:|:-:|:-:|\n|$1$|$26$|对于每种颜色的灯，$x_1=y_1=0$\n|$2$|$12$|$n,m\\le10$，$k\\le1000$|\n|$3$|$35$|$m\\le150$|\n|$4$|$37$|无|\n\n**本题满分 $110$ 分。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #2] Lampice", "background": "", "description": "Teo 的阳台是一个长 $n+1$，宽 $m+1$ 的矩形平台，上有 $2k$ 盏彩灯，这些彩灯的颜色用 $1 \\sim k$ 之间的一个数字来表示。每种颜色的彩灯都有 $2$ 盏，它们的坐标都为正整数。\n\nTeo 认为阳台上一个区域是好的，当且仅当：\n\n- 这个小区域是矩形，且边都与阳台的边平行。\n\n- 对于每一种颜色的 $2$ 盏彩灯，要么都在小区域内，要么都在小区域外。\n\n- 小区域的左上角，右下角坐标均为整数。\n\n- 小区域的长宽都**至少**为 $2$。\n\n现在，Teo 想请你求出在他的阳台上，有多少个小区域是好的。\n\n**注意：左下角坐标为 $(0,0)$，右上角坐标为 $(n,m)$。**", "inputFormat": "第一行，三个整数 $n$，$m$，$k$（$1\\le n\\le150,1\\le m\\le1000,0\\le k\\le200000$），表示阳台的长，宽，和彩灯的颜色数。\n\n接下来 $k$ 行，每行 $4$ 个整数 $x_1$，$y_1$，$x_2$，$y_2$，第 $i$ 行表示颜色为 $i$ 的两盏彩灯的坐标。", "outputFormat": "一行，一个整数，表示好的小区域个数。", "hint": "|$\\text{Subtask}$|分值|特殊性质|\n|:-:|:-:|:-:|\n|$1$|$26$|对于每种颜色的灯，$x_1=y_1=0$\n|$2$|$12$|$n,m\\le10$，$k\\le1000$|\n|$3$|$35$|$m\\le150$|\n|$4$|$37$|无|\n\n**本题满分 $110$ 分。**", "locale": "zh-CN"}}}
{"pid": "P9738", "type": "P", "difficulty": 3, "samples": [["2 1\navokado\ndabar\nbrazil", "Zoe"], ["3 3\nananas\natlas\nbanana\nalbatros\ncikla\nnogomet\n", "Leona"], ["2 2\nhrvatska\nzastava\nbijeli\ngaleb", "Leona"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "2022", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #2] Prijateljice", "background": "", "description": "Leona 和 Zoe 拿到了一些单词。他们打算用这些单词玩一个游戏：\n\n在每一个回合中，两人轮流说单词。这个单词需要满足以下要求：\n\n它比前一个单词的字典序大，且开头字母必须和前一个字母相同，或在字母表上正好在前一个单词的开头字母的后面一个。\n\nLeona 先说，他会选择字典序最小的单词说出来。轮到谁时，他说不出单词了，他就输了。\n\n两人在玩这个游戏时，都会采用最优策略，也就是说，选择符合条件的单词中字典序最小的那个。\n\n现在他们想知道，谁会赢呢。", "inputFormat": "第一行，两个整数 $n$，$m$（$1 \\le n,m \\le 10^5$）。\n\n接下来 $n$ 行，每行一个字符串，表示 Leona 拥有的单词。\n\n接下来 $m$ 行，每行一个字符串，表示 Zoe 拥有的单词。\n\n输入的单词均为小写字母，且互不相同。它们的总长度不超过 $10^6$，且按字典序排序。\n", "outputFormat": "输出一行，一个字符串，为 $\\texttt{Leona}$ 或 $\\texttt{Zoe}$，表示获胜者。", "hint": "|$\\text{Subtask}$|分值|特殊性质|\n|:-:|:-:|:-:|\n|$1$|$20$|$n,m\\le100$，每个单词的长度不超过 $10$|\n|$2$|$30$|$n,m\\le1000$|\n|$3$|$60$|无|\n\n**本题满分 $110$ 分。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #2] Prijateljice", "background": "", "description": "Leona 和 Zoe 拿到了一些单词。他们打算用这些单词玩一个游戏：\n\n在每一个回合中，两人轮流说单词。这个单词需要满足以下要求：\n\n它比前一个单词的字典序大，且开头字母必须和前一个字母相同，或在字母表上正好在前一个单词的开头字母的后面一个。\n\nLeona 先说，他会选择字典序最小的单词说出来。轮到谁时，他说不出单词了，他就输了。\n\n两人在玩这个游戏时，都会采用最优策略，也就是说，选择符合条件的单词中字典序最小的那个。\n\n现在他们想知道，谁会赢呢。", "inputFormat": "第一行，两个整数 $n$，$m$（$1 \\le n,m \\le 10^5$）。\n\n接下来 $n$ 行，每行一个字符串，表示 Leona 拥有的单词。\n\n接下来 $m$ 行，每行一个字符串，表示 Zoe 拥有的单词。\n\n输入的单词均为小写字母，且互不相同。它们的总长度不超过 $10^6$，且按字典序排序。\n", "outputFormat": "输出一行，一个字符串，为 $\\texttt{Leona}$ 或 $\\texttt{Zoe}$，表示获胜者。", "hint": "|$\\text{Subtask}$|分值|特殊性质|\n|:-:|:-:|:-:|\n|$1$|$20$|$n,m\\le100$，每个单词的长度不超过 $10$|\n|$2$|$30$|$n,m\\le1000$|\n|$3$|$60$|无|\n\n**本题满分 $110$ 分。**", "locale": "zh-CN"}}}
{"pid": "P9739", "type": "P", "difficulty": 6, "samples": [["\n\n0\n\n\n1\n\n\n\n0\n", "X\nK\n\nL\nL\nK\n\nX\nD\nD\nK\n\n! 1"], ["\n\n0\n\n0\n\n0\n\n1\n", "X\nK\n\nK\n\nK\n\nK\n\n! 0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "交互题", "Special Judge", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #2] Kruhologija", "background": "**这是一道交互题。**", "description": "你是一只蚂蚁，你现在在一块漂浮在空中的面包上！\n\n面包可以看成由若干个正方体组成的立体图形，这个图形在高度上最多只有一个方块，并且是连通的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k9o74nmn.png)\n\n左图是第一个样例，右图是不合法（不连通）的一个例子。\n\n我们记这些正方体构成的立体图形有 $n$ 个面。你现在正在一个小块的一个面上，面向未知的方向。你可以进行 $q$ 次操作，每次你可以：\n\n- $\\texttt{K}$：向你面向的方向走一格；\n- $\\texttt{L}$：向左转 $90\\degree$；\n- $\\texttt{D}$：向右转 $90\\degree$；\n- $\\texttt{X}$：在当前格子上放置 / 删除标记。\n\n注意：当你走到了边缘时，继续往前走，你会走到另一个面上，所以你可以向任意方向行走任意步。\n\n一个立方体上的洞的定义为：完全被立方体包围的空间的一部分。\n\n你很喜欢洞，所以你想要求出这个立方体上洞的数量。", "inputFormat": "这是一道交互题。你需要输出面包上洞的数量。你可以向交互库发送一次操作，库会返回一个值。值为 $0$ 表示目前格子上没有标记，为 $1$ 则有。如果你的操作次数超过了 $q$ 次，你的答案将会被认为不正确。如果你找到了答案，输出 `! g`，$g$ 表示你在面包上找到了 $g$ 个洞。", "outputFormat": "", "hint": "|$\\text{Subtask}$|分值|特殊性质|\n|:-:|:-:|:-:|\n|$1$|$49$|$n\\le 40$，$q=20000$，面包上最多有一个洞|\n|$2$|$61$|$n\\le 200$，$q=20000$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #2] Kruhologija", "background": "**这是一道交互题。**", "description": "你是一只蚂蚁，你现在在一块漂浮在空中的面包上！\n\n面包可以看成由若干个正方体组成的立体图形，这个图形在高度上最多只有一个方块，并且是连通的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k9o74nmn.png)\n\n左图是第一个样例，右图是不合法（不连通）的一个例子。\n\n我们记这些正方体构成的立体图形有 $n$ 个面。你现在正在一个小块的一个面上，面向未知的方向。你可以进行 $q$ 次操作，每次你可以：\n\n- $\\texttt{K}$：向你面向的方向走一格；\n- $\\texttt{L}$：向左转 $90\\degree$；\n- $\\texttt{D}$：向右转 $90\\degree$；\n- $\\texttt{X}$：在当前格子上放置 / 删除标记。\n\n注意：当你走到了边缘时，继续往前走，你会走到另一个面上，所以你可以向任意方向行走任意步。\n\n一个立方体上的洞的定义为：完全被立方体包围的空间的一部分。\n\n你很喜欢洞，所以你想要求出这个立方体上洞的数量。", "inputFormat": "这是一道交互题。你需要输出面包上洞的数量。你可以向交互库发送一次操作，库会返回一个值。值为 $0$ 表示目前格子上没有标记，为 $1$ 则有。如果你的操作次数超过了 $q$ 次，你的答案将会被认为不正确。如果你找到了答案，输出 `! g`，$g$ 表示你在面包上找到了 $g$ 个洞。", "outputFormat": "", "hint": "|$\\text{Subtask}$|分值|特殊性质|\n|:-:|:-:|:-:|\n|$1$|$49$|$n\\le 40$，$q=20000$，面包上最多有一个洞|\n|$2$|$61$|$n\\le 200$，$q=20000$|", "locale": "zh-CN"}}}
{"pid": "P9740", "type": "P", "difficulty": 1, "samples": [["7\n100 100\n20 20\n25 23\n25 10\n20 14\n25 11\n20 0\n447", "NaN\nNaN\n1\n1\n1\n1\n1"], ["7\n100 100\n20 20\n25 23\n25 10\n20 14\n25 11\n20 0\n446", "Already Au."], ["7\n100 100\n20 20\n20 10\n25 13\n20 20\n25 16\n20 6\n509", "NaN\nNaN\n3\n4\nNaN\n4\n3"], ["7\n100 100\n20 19\n20 20\n25 11\n20 20\n25 25\n20 6\n509", "Already Au."]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2023", "洛谷原创", "O2优化", "枚举", "洛谷月赛"], "title": "「KDOI-06-J」ION 比赛", "background": "", "description": "在 ION 比赛中，总共有 $n$ 道题目。每道题目的满分均为 $100$ 分。\n\n第 $i$ 道题有 $a_i$ 个测试点，且该题的所有测试点分值相等，因此 $a_i$ 一定是 $100$ 的因数。每通过一个测试点，你将会得到与该测试点分值相等的分数。\n\n通过一些技术手段，你了解到 ION 比赛今年的 Au 分数线是 $t$ 分。\n\n现在，你在第 $i$ 道题中已经通过了 $b_i$ 个测试点。作为一名策略选手，你想知道：对于任意 $1\\le j\\le n$，如果你在比赛剩下的时间内死磕第 $j$ 题（不做其他题目），需要至少再多通过几个测试点以获得 Au，也就是说，使你的总分 $\\ge t$。\n\n当然，你有可能无法通过死磕某一道题目翻盘（获得 Au），此时你需要输出 `NaN`。", "inputFormat": "从标准输入读入数据。\n\n输入的第一行包含一个正整数 $n$，表示题目总数。\n\n接下来 $n$ 行，一行两个非负整数 $a_i,b_i$，表示第 $i$ 题的测试点个数和你已经通过的测试点个数。保证 $a_i$ 是 $100$ 的因数且 $b_i\\le a_i$。\n\n最后一行一个整数 $t$，表示 Au 分数线。", "outputFormat": "输出到标准输出。\n\n如果你的分数已经达到 Au 线，请输出一行一个字符串 `Already Au.`。\n\n否则，输出 $n$ 行。在第 $i$ 行中你应该输出以下两种格式之一：\n\n+ 一个正整数 $c_i$，表示在第 $i$ 道题目中你需要至少再通过多少个测试点才可以获得 Au。\n+ 一个字符串 `NaN`，表示你无法通过这题翻盘（获得 Au）。", "hint": "**【样例解释 #1】**\n\n容易发现目前的分数是 $100+100+92+40+70+44=446$，而分数线为 $447$，故在任何一道没有拿到满分的题中多通过一个测试点即可。\n\n**【数据范围】**\n\n对于所有数据保证：$1\\leq n\\leq 7$，$0\\leq b_i\\leq a_i$，$1\\leq a_i\\leq 100$ 且 $a_i$ 为 $100$ 的因数，$0\\leq t\\leq 100n$。\n\n| 测试点编号 | $n$ | $a_i$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\leq7$ | $\\leq100$ | 保证目前分数大于等于 $t$ |\n| $2\\sim3$ | $=1$ | $\\leq100$ | 无 |\n| $4\\sim5$ | $\\leq7$ | $=100$ | 无 |\n| $6\\sim10$ | $\\leq7$ | $\\leq100$ | 无 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KDOI-06-J」ION 比赛", "background": "", "description": "在 ION 比赛中，总共有 $n$ 道题目。每道题目的满分均为 $100$ 分。\n\n第 $i$ 道题有 $a_i$ 个测试点，且该题的所有测试点分值相等，因此 $a_i$ 一定是 $100$ 的因数。每通过一个测试点，你将会得到与该测试点分值相等的分数。\n\n通过一些技术手段，你了解到 ION 比赛今年的 Au 分数线是 $t$ 分。\n\n现在，你在第 $i$ 道题中已经通过了 $b_i$ 个测试点。作为一名策略选手，你想知道：对于任意 $1\\le j\\le n$，如果你在比赛剩下的时间内死磕第 $j$ 题（不做其他题目），需要至少再多通过几个测试点以获得 Au，也就是说，使你的总分 $\\ge t$。\n\n当然，你有可能无法通过死磕某一道题目翻盘（获得 Au），此时你需要输出 `NaN`。", "inputFormat": "从标准输入读入数据。\n\n输入的第一行包含一个正整数 $n$，表示题目总数。\n\n接下来 $n$ 行，一行两个非负整数 $a_i,b_i$，表示第 $i$ 题的测试点个数和你已经通过的测试点个数。保证 $a_i$ 是 $100$ 的因数且 $b_i\\le a_i$。\n\n最后一行一个整数 $t$，表示 Au 分数线。", "outputFormat": "输出到标准输出。\n\n如果你的分数已经达到 Au 线，请输出一行一个字符串 `Already Au.`。\n\n否则，输出 $n$ 行。在第 $i$ 行中你应该输出以下两种格式之一：\n\n+ 一个正整数 $c_i$，表示在第 $i$ 道题目中你需要至少再通过多少个测试点才可以获得 Au。\n+ 一个字符串 `NaN`，表示你无法通过这题翻盘（获得 Au）。", "hint": "**【样例解释 #1】**\n\n容易发现目前的分数是 $100+100+92+40+70+44=446$，而分数线为 $447$，故在任何一道没有拿到满分的题中多通过一个测试点即可。\n\n**【数据范围】**\n\n对于所有数据保证：$1\\leq n\\leq 7$，$0\\leq b_i\\leq a_i$，$1\\leq a_i\\leq 100$ 且 $a_i$ 为 $100$ 的因数，$0\\leq t\\leq 100n$。\n\n| 测试点编号 | $n$ | $a_i$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\leq7$ | $\\leq100$ | 保证目前分数大于等于 $t$ |\n| $2\\sim3$ | $=1$ | $\\leq100$ | 无 |\n| $4\\sim5$ | $\\leq7$ | $=100$ | 无 |\n| $6\\sim10$ | $\\leq7$ | $\\leq100$ | 无 |", "locale": "zh-CN"}}}
{"pid": "P9741", "type": "P", "difficulty": 2, "samples": [["3\n1 1 1\n", "0 0 1 \n"], ["8\n1 0 1 1 1 0 0 1\n", "0 1 0 1 1 1 1 0 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "数学", "2023", "洛谷原创", "O2优化", "洛谷月赛", "分类讨论"], "title": "「KDOI-06-J」翻转与反转", "background": "", "description": "小 W 有一个长度为 $n$ 的 $01$ 序列 $a_1,a_2,\\ldots,a_n$，他将对这个序列按顺序进行 $n$ 次操作。\n\n在第 $i$ 次操作中（$1\\le i\\le n$），小 W 将按顺序执行以下**两种**变换：\n\n1. 将区间 $[1,i]$ 中的数按下标翻转。形式化地说，在这次变换之后，序列 $a$ 将变为 $a_i,a_{i-1},\\ldots,a_{1},a_{i+1},a_{i+2},\\ldots,a_n$。\n2. 将区间 $[1,i]$ 中的数按值翻转。形式化地说，在这次变换之后，对于任意 $1\\le j\\le i$，若 $a_j=0$，则 $a_j$ 将变为 $1$，否则 $a_j$ 将变为 $0$。\n\n小 W 想要知道，在全部 $n$ 次操作结束后，序列 $a$ 中每个元素的值。", "inputFormat": "从标准输入读入数据。\n\n输入的第一行包含一个正整数 $n$，表示序列长度。\n\n接下来一行 $n$ 个整数，表示序列 $a_1,a_2,\\ldots, a_n$。保证 $a_i=0$ 或 $1$。", "outputFormat": "输出到标准输出。\n\n输出包含一行 $n$ 个整数，表示操作结束后序列 $a$ 中每个元素的值。", "hint": "**【样例解释 #1】**\n\n序列 $a$ 的变化如下表所示：\n\n| 操作次数 | 序列 $a$ 的变化 |\n| :--: | :--: |\n| $1$ | $[1,1,1]\\to [1,1,1]\\to[0,1,1]$ |\n| $2$ | $[0,1,1]\\to [1,0,1]\\to[0,1,1]$ |\n| $3$ | $[0,1,1]\\to [1,1,0]\\to[0,0,1]$ |\n\n**【样例解释 #2】**\n\n序列 $a$ 的变化如下表所示：\n\n| 操作次数 | 操作后的序列 $a$ |\n| :--: | :--: |\n| - | $[1,0,1,1,1,0,0,1]$ |\n| $1$ | $[0,0,1,1,1,0,0,1]$ |\n| $2$ | $[1,1,1,1,1,0,0,1]$ |\n| $3$ | $[0,0,0,1,1,0,0,1]$ |\n| $4$ | $[0,1,1,1,1,0,0,1]$ |\n| $5$ | $[0,0,0,0,1,0,0,1]$ |\n| $6$ | $[1,0,1,1,1,1,0,1]$ |\n| $7$ | $[1,0,0,0,0,1,0,1]$ |\n| $8$ | $[0,1,0,1,1,1,1,0]$ |\n\n**【样例 #3】**\n\n见选手文件中的 `revflip/revflip3.in` 与 `revflip/revflip3.ans`。\n\n**【样例 #4】**\n\n见选手文件中的 `revflip/revflip4.in` 与 `revflip/revflip4.ans`。\n\n\n**【数据范围】**\n\n对于所有数据保证：$1\\le n\\le 2\\times 10^6$，且对于任意 $1\\le i\\le n$，$a_i=0$ 或 $1$。\n\n| 测试点编号 | $n\\le$ |  特殊性质 |\n| :-----------: | :-----------: | :----------: |\n| $1\\sim 3$ | $10^3$ | 无 |\n| $4\\sim 5$ | $10^5$ | 无 |\n| $6 \\sim 7$ | $2\\times 10^6$ | $a_i=0$ |\n| $8\\sim 10$ | $2\\times 10^6$ | 无 | \n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KDOI-06-J」翻转与反转", "background": "", "description": "小 W 有一个长度为 $n$ 的 $01$ 序列 $a_1,a_2,\\ldots,a_n$，他将对这个序列按顺序进行 $n$ 次操作。\n\n在第 $i$ 次操作中（$1\\le i\\le n$），小 W 将按顺序执行以下**两种**变换：\n\n1. 将区间 $[1,i]$ 中的数按下标翻转。形式化地说，在这次变换之后，序列 $a$ 将变为 $a_i,a_{i-1},\\ldots,a_{1},a_{i+1},a_{i+2},\\ldots,a_n$。\n2. 将区间 $[1,i]$ 中的数按值翻转。形式化地说，在这次变换之后，对于任意 $1\\le j\\le i$，若 $a_j=0$，则 $a_j$ 将变为 $1$，否则 $a_j$ 将变为 $0$。\n\n小 W 想要知道，在全部 $n$ 次操作结束后，序列 $a$ 中每个元素的值。", "inputFormat": "从标准输入读入数据。\n\n输入的第一行包含一个正整数 $n$，表示序列长度。\n\n接下来一行 $n$ 个整数，表示序列 $a_1,a_2,\\ldots, a_n$。保证 $a_i=0$ 或 $1$。", "outputFormat": "输出到标准输出。\n\n输出包含一行 $n$ 个整数，表示操作结束后序列 $a$ 中每个元素的值。", "hint": "**【样例解释 #1】**\n\n序列 $a$ 的变化如下表所示：\n\n| 操作次数 | 序列 $a$ 的变化 |\n| :--: | :--: |\n| $1$ | $[1,1,1]\\to [1,1,1]\\to[0,1,1]$ |\n| $2$ | $[0,1,1]\\to [1,0,1]\\to[0,1,1]$ |\n| $3$ | $[0,1,1]\\to [1,1,0]\\to[0,0,1]$ |\n\n**【样例解释 #2】**\n\n序列 $a$ 的变化如下表所示：\n\n| 操作次数 | 操作后的序列 $a$ |\n| :--: | :--: |\n| - | $[1,0,1,1,1,0,0,1]$ |\n| $1$ | $[0,0,1,1,1,0,0,1]$ |\n| $2$ | $[1,1,1,1,1,0,0,1]$ |\n| $3$ | $[0,0,0,1,1,0,0,1]$ |\n| $4$ | $[0,1,1,1,1,0,0,1]$ |\n| $5$ | $[0,0,0,0,1,0,0,1]$ |\n| $6$ | $[1,0,1,1,1,1,0,1]$ |\n| $7$ | $[1,0,0,0,0,1,0,1]$ |\n| $8$ | $[0,1,0,1,1,1,1,0]$ |\n\n**【样例 #3】**\n\n见选手文件中的 `revflip/revflip3.in` 与 `revflip/revflip3.ans`。\n\n**【样例 #4】**\n\n见选手文件中的 `revflip/revflip4.in` 与 `revflip/revflip4.ans`。\n\n\n**【数据范围】**\n\n对于所有数据保证：$1\\le n\\le 2\\times 10^6$，且对于任意 $1\\le i\\le n$，$a_i=0$ 或 $1$。\n\n| 测试点编号 | $n\\le$ |  特殊性质 |\n| :-----------: | :-----------: | :----------: |\n| $1\\sim 3$ | $10^3$ | 无 |\n| $4\\sim 5$ | $10^5$ | 无 |\n| $6 \\sim 7$ | $2\\times 10^6$ | $a_i=0$ |\n| $8\\sim 10$ | $2\\times 10^6$ | 无 | \n", "locale": "zh-CN"}}}
{"pid": "P9742", "type": "P", "difficulty": 4, "samples": [["3\n5\n3816 3738 3726 3621 3582\n111 109 -50 -22 208\n8\n8 7 6 5 4 3 2 1\n128 1 0 0 0 0 1 0\n10\n10 9 8 7 6 5 4 3 2 1\n1 1 4 5 1 4 1 9 1 9\n", "280\n1\n34\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2023", "洛谷原创", "O2优化", "洛谷月赛"], "title": "「KDOI-06-J」贡献系统", "background": "", "description": "洛谷贡献系统上线了！\n\n现在有 $n$ 个人即将参加一场洛谷月赛，每个人的等级分**互不相同**。第 $i$ 个人的等级分是 $r_i$，贡献值是 $c_i$。\n\n假设第 $i$ 个人的等级分在这 $n$ 个人中的排名是 $a_i$（排名按等级分从大到小排序），且在月赛中的排名是 $b_i$，没有两个人的排名相同。也就是说，$a$ 和 $b$ 都是 $1$ 到 $n$ 的排列。比赛结束后，每个人都会执行以下操作：\n\n+ 若 $a_i=b_i$，则第 $i$ 个人的等级分不会发生任何变化，因此第 $i$ 个人不会进行任何操作；\n+ 若 $a_i>b_i$，则第 $i$ 个人的等级分会上升，因此第 $i$ 个人会给出题人点赞，导致出题人的贡献值上升 $c_i$（$c_i$ 可能是负数，此时会导致出题人的贡献值下降）；\n+ 若 $a_i<b_i$，则第 $i$ 个人的等级分会下降，因此第 $i$ 个人会给出题人点踩，导致出题人的贡献值下降 $c_i$（$c_i$ 可能是负数，此时会导致出题人的贡献值上升）。\n\n作为这场月赛唯一的出题人，初始时你的贡献值为 $0$。你想知道，对于所有可能的排列 $b$（显然，排列 $a$ 在比赛前已经被确定），在比赛结束后你的贡献值最大是多少。", "inputFormat": "从标准输入读入数据。\n\n**本题有多组测试数据。**\n\n输入的第一行包含一个正整数 $T$，表示数据组数。\n\n对于每组测试数据，第一行一个正整数 $n$，表示参赛选手人数。\n\n第二行包含 $n$ 个非负整数 $r_1,r_2,\\ldots,r_n$，表示参赛选手的等级分。保证对于任意 $1\\le i< n$，$r_i>r_{i+1}$。\n\n第三行包含 $n$ 个整数 $c_1,c_2,\\ldots,c_n$，表示参赛选手的贡献值。 ", "outputFormat": "输出到标准输出。\n\n对于每组测试数据，输出一行一个整数，表示最大的贡献值。", "hint": "**【样例解释 #1】**\n\n对于第一组测试数据，设五个人按输入顺序分别为 A，B，C，D，E，则当月赛中的排名顺序为 ABECD 时贡献值最大，为 $0+0-(-50)-(-22)+208=280$。可以证明，这是唯一能使贡献值达到最大的排名顺序。\n\n对于第二组测试数据，设八个人按输入顺序分别为 A，B，C，D，E，F，G，H，则当月赛中的排名顺序为 ABCDEGFH 时可以使贡献值达到最大值 $1$，注意此时有多种可能的使贡献值最大的排名顺序。\n\n**【样例 #2】**\n\n见选手目录下的 `contrib/contrib2.in` 与 `contrib/contrib2.ans`。\n\n**【样例 #3】**\n\n见选手目录下的 `contrib/contrib3.in` 与 `contrib/contrib3.ans`。\n\n\n\n***\n\n**【数据范围】**\n\n对于所有数据保证：$1\\le T\\le 5$，$1\\le n\\le 2\\times 10^5$，$0\\le r_i\\le 10^9$，$-10^9\\le c_i\\le 10^9$，且对于任意 $1\\le i<n$，$r_i>r_{i+1}$。\n\n| 测试点编号  |    $n\\le $     | 特殊限制 |\n| :---------: | :------------: | :------: |\n|  $1\\sim3$   |      $8$       |    无    |\n|     $4$     |     $100$      |   ABC    |\n|     $5$     |     $100$      |    C     |\n|  $6\\sim 7$  |     $100$      |    无    |\n|  $8\\sim 9$  | $5\\times 10^3$ |    AB    |\n| $10\\sim 11$ | $5\\times 10^3$ |    C     |\n| $12\\sim 14$ | $5\\times 10^3$ |    无    |\n|    $15$     | $2\\times10^5$  |    AB    |\n| $16\\sim 18$ | $2\\times10^5$  |    B     |\n| $19\\sim 21$ | $2\\times10^5$  |    C     |\n| $22\\sim 25$ | $2\\times 10^5$ |    无    |\n\n+ 特殊性质 A：对于任意 $1\\le i<n$，保证 $c_i=c_{i+1}$；\n+ 特殊性质 B：对于任意 $1\\le i<n$，保证 $c_i\\le c_{i+1}$；\n+ 特殊性质 C：对于任意 $1\\le i\\le n$，保证 $c_i\\ge 0$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KDOI-06-J」贡献系统", "background": "", "description": "洛谷贡献系统上线了！\n\n现在有 $n$ 个人即将参加一场洛谷月赛，每个人的等级分**互不相同**。第 $i$ 个人的等级分是 $r_i$，贡献值是 $c_i$。\n\n假设第 $i$ 个人的等级分在这 $n$ 个人中的排名是 $a_i$（排名按等级分从大到小排序），且在月赛中的排名是 $b_i$，没有两个人的排名相同。也就是说，$a$ 和 $b$ 都是 $1$ 到 $n$ 的排列。比赛结束后，每个人都会执行以下操作：\n\n+ 若 $a_i=b_i$，则第 $i$ 个人的等级分不会发生任何变化，因此第 $i$ 个人不会进行任何操作；\n+ 若 $a_i>b_i$，则第 $i$ 个人的等级分会上升，因此第 $i$ 个人会给出题人点赞，导致出题人的贡献值上升 $c_i$（$c_i$ 可能是负数，此时会导致出题人的贡献值下降）；\n+ 若 $a_i<b_i$，则第 $i$ 个人的等级分会下降，因此第 $i$ 个人会给出题人点踩，导致出题人的贡献值下降 $c_i$（$c_i$ 可能是负数，此时会导致出题人的贡献值上升）。\n\n作为这场月赛唯一的出题人，初始时你的贡献值为 $0$。你想知道，对于所有可能的排列 $b$（显然，排列 $a$ 在比赛前已经被确定），在比赛结束后你的贡献值最大是多少。", "inputFormat": "从标准输入读入数据。\n\n**本题有多组测试数据。**\n\n输入的第一行包含一个正整数 $T$，表示数据组数。\n\n对于每组测试数据，第一行一个正整数 $n$，表示参赛选手人数。\n\n第二行包含 $n$ 个非负整数 $r_1,r_2,\\ldots,r_n$，表示参赛选手的等级分。保证对于任意 $1\\le i< n$，$r_i>r_{i+1}$。\n\n第三行包含 $n$ 个整数 $c_1,c_2,\\ldots,c_n$，表示参赛选手的贡献值。 ", "outputFormat": "输出到标准输出。\n\n对于每组测试数据，输出一行一个整数，表示最大的贡献值。", "hint": "**【样例解释 #1】**\n\n对于第一组测试数据，设五个人按输入顺序分别为 A，B，C，D，E，则当月赛中的排名顺序为 ABECD 时贡献值最大，为 $0+0-(-50)-(-22)+208=280$。可以证明，这是唯一能使贡献值达到最大的排名顺序。\n\n对于第二组测试数据，设八个人按输入顺序分别为 A，B，C，D，E，F，G，H，则当月赛中的排名顺序为 ABCDEGFH 时可以使贡献值达到最大值 $1$，注意此时有多种可能的使贡献值最大的排名顺序。\n\n**【样例 #2】**\n\n见选手目录下的 `contrib/contrib2.in` 与 `contrib/contrib2.ans`。\n\n**【样例 #3】**\n\n见选手目录下的 `contrib/contrib3.in` 与 `contrib/contrib3.ans`。\n\n\n\n***\n\n**【数据范围】**\n\n对于所有数据保证：$1\\le T\\le 5$，$1\\le n\\le 2\\times 10^5$，$0\\le r_i\\le 10^9$，$-10^9\\le c_i\\le 10^9$，且对于任意 $1\\le i<n$，$r_i>r_{i+1}$。\n\n| 测试点编号  |    $n\\le $     | 特殊限制 |\n| :---------: | :------------: | :------: |\n|  $1\\sim3$   |      $8$       |    无    |\n|     $4$     |     $100$      |   ABC    |\n|     $5$     |     $100$      |    C     |\n|  $6\\sim 7$  |     $100$      |    无    |\n|  $8\\sim 9$  | $5\\times 10^3$ |    AB    |\n| $10\\sim 11$ | $5\\times 10^3$ |    C     |\n| $12\\sim 14$ | $5\\times 10^3$ |    无    |\n|    $15$     | $2\\times10^5$  |    AB    |\n| $16\\sim 18$ | $2\\times10^5$  |    B     |\n| $19\\sim 21$ | $2\\times10^5$  |    C     |\n| $22\\sim 25$ | $2\\times 10^5$ |    无    |\n\n+ 特殊性质 A：对于任意 $1\\le i<n$，保证 $c_i=c_{i+1}$；\n+ 特殊性质 B：对于任意 $1\\le i<n$，保证 $c_i\\le c_{i+1}$；\n+ 特殊性质 C：对于任意 $1\\le i\\le n$，保证 $c_i\\ge 0$。", "locale": "zh-CN"}}}
{"pid": "P9743", "type": "P", "difficulty": 4, "samples": [["3 3 5\n3 2 1\n2 1 3\n1 3 2\n1 2 3\n2 3 1\n3 1 2", "0 0 0\n0 1 5\n1 3 5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2023", "洛谷原创", "O2优化", "前缀和", "洛谷月赛"], "title": "「KDOI-06-J」旅行", "background": "", "description": "小 C 在 C 国旅行。\n\nC 国有 $n\\times m$ 个城市，可以看做 $n\\times m$ 的网格。定义 $(i,j)$ 表示在网格中第 $i$ 行第 $j$ 列的城市。\n\n该国有 $2$ 种交通系统：\n\n* 对于所有 $1\\leq i<n,1\\leq j\\leq m$，$(i,j)$ 到 $(i+1,j)$ 有一段由 L 公司修的单向铁路；\n* 对于所有 $1\\leq i\\leq n,1\\leq j<m$，$(i,j)$ 到 $(i,j+1)$ 有一段由 Z 公司修的单向铁路；\n\n在每一个城市有一个售票口，$(i,j)$ 城市的售票口可以用 $a_{i,j}$ 元购买一张 L 公司的铁路票，$b_{i,j}$ 元购买一张 Z 公司的铁路票。当你拥有一个公司的一张铁路票时，你可以乘坐这个公司的任意一段铁路，并消耗掉这张铁路票。注意，一张铁路票可以且仅可以使用一次。\n\n小 C 原来在城市 $(1,1)$。他想要在 C 国旅游，但是他不想浪费任何的钱（即，当他旅游完毕时手上不应该有多余的车票）。对于所有 $1\\leq x\\leq n,1\\leq y\\leq m$，求他花 $k$ 元钱并在城市 $(x,y)$ 结束旅行的方案数，对 $998\\ 244\\ 353$ 取模。\n\n两种旅行方案不同，当且仅当小 C 经过的城市不同，或他在某一个城市购买的某家公司的铁路票数量不同。", "inputFormat": "从标准输入读入数据。\n\n输入的第一行包含三个正整数 $n,m,k$，表示网格的大小和钱的数目。\n\n接下来 $n$ 行，每行 $m$ 个正整数，第 $i$ 行第 $j$ 个正整数表示 $a_{i,j}$。\n\n接下来 $n$ 行，每行 $m$ 个正整数，第 $i$ 行第 $j$ 个正整数表示 $b_{i,j}$。", "outputFormat": "输出到标准输出。\n\n输出一共 $n$ 行，每行 $m$ 个整数，表示到每个点钱恰好花完并结束旅行的方案数，对 $998\\ 244\\ 353$ 取模。", "hint": "**【样例解释 #1】**\n\n到 $(3,1)$ 的方案有：\n\n* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；在 $(2,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,1)$。\n\n到 $(2,2)$ 的方案有：\n\n* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；在 $(2,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(2,2)$。\n\n到 $(3,2)$ 的方案有：\n\n* 在 $(1,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；在 $(1,2)$ 购买 $2$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,2)$；乘坐 L 公司的铁路到 $(3,2)$。\n* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；乘坐 L 公司的铁路到 $(2,2)$；在 $(2,2)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,2)$。\n* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；乘坐 Z 公司的铁路到 $(2,2)$；在 $(2,2)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,2)$。\n\n到 $(2,3)$ 的方案有：\n\n* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $2$ 张 Z 公司的铁路票。在此之后，有 $3$ 种方案可以从 $(1,1)$ 乘坐两公司的铁路到 $(2,3)$。\n* 在 $(1,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；在 $(1,2)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票。在此之后，有 $2$ 种方案可以从 $(1,2)$ 乘坐两公司的铁路到 $(2,3)$。\n\n**【样例 #2】**\n\n见选手目录下的 `travel/travel2.in` 与 `travel/travel2.ans`。这个样例满足测试点 $7\\sim 8$ 的条件限制。\n\n**【样例 #3】**\n\n见选手目录下的 `travel/travel3.in` 与 `travel/travel3.ans`。这个样例满足测试点 $11$ 的条件限制。\n\n**【数据范围】**\n\n对于所有数据保证：$1\\leq n,m\\leq45$，$1\\leq k,a_{i,j},b_{i,j}\\leq90$。\n\n| 测试点编号 | $n,m$ | $k$ | $a_{i,j}$ | $b_{i,j}$ |\n|:--:|:--:|:--:|:--:|:--:|\n| $1\\sim3$ | $\\leq3$ | $\\leq5$ | $=1$ | $=1$ |\n| $4\\sim6$ | $\\leq10$ | $\\leq10$ | $=1$ | $=40$ |\n| $7\\sim8$ | $\\leq40$ | $\\leq30$ | $=1$ | $=45$ |\n| $9\\sim10$ | $\\leq15$ | $\\leq15$ | $\\leq15$ | $\\leq15$ |\n| $11$ | $\\leq15$ | $\\leq30$ | $\\leq30$ | $\\leq30$ |\n| $12$ | $\\leq20$ | $\\leq40$ | $\\leq40$ | $\\leq40$ |\n| $13\\sim15$ | $\\leq25$ | $\\leq50$ | $\\leq50$ | $\\leq50$ |\n| $16$ | $\\leq30$ | $\\leq60$ | $\\leq60$ | $\\leq60$ |\n| $17$ | $\\leq35$ | $\\leq70$ | $\\leq70$ | $\\leq70$ |\n| $18\\sim19$ | $\\leq40$ | $\\leq80$ | $\\leq80$ | $\\leq80$ |\n| $20$ | $\\leq45$ | $\\leq90$ | $\\leq90$ | $\\leq90$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KDOI-06-J」旅行", "background": "", "description": "小 C 在 C 国旅行。\n\nC 国有 $n\\times m$ 个城市，可以看做 $n\\times m$ 的网格。定义 $(i,j)$ 表示在网格中第 $i$ 行第 $j$ 列的城市。\n\n该国有 $2$ 种交通系统：\n\n* 对于所有 $1\\leq i<n,1\\leq j\\leq m$，$(i,j)$ 到 $(i+1,j)$ 有一段由 L 公司修的单向铁路；\n* 对于所有 $1\\leq i\\leq n,1\\leq j<m$，$(i,j)$ 到 $(i,j+1)$ 有一段由 Z 公司修的单向铁路；\n\n在每一个城市有一个售票口，$(i,j)$ 城市的售票口可以用 $a_{i,j}$ 元购买一张 L 公司的铁路票，$b_{i,j}$ 元购买一张 Z 公司的铁路票。当你拥有一个公司的一张铁路票时，你可以乘坐这个公司的任意一段铁路，并消耗掉这张铁路票。注意，一张铁路票可以且仅可以使用一次。\n\n小 C 原来在城市 $(1,1)$。他想要在 C 国旅游，但是他不想浪费任何的钱（即，当他旅游完毕时手上不应该有多余的车票）。对于所有 $1\\leq x\\leq n,1\\leq y\\leq m$，求他花 $k$ 元钱并在城市 $(x,y)$ 结束旅行的方案数，对 $998\\ 244\\ 353$ 取模。\n\n两种旅行方案不同，当且仅当小 C 经过的城市不同，或他在某一个城市购买的某家公司的铁路票数量不同。", "inputFormat": "从标准输入读入数据。\n\n输入的第一行包含三个正整数 $n,m,k$，表示网格的大小和钱的数目。\n\n接下来 $n$ 行，每行 $m$ 个正整数，第 $i$ 行第 $j$ 个正整数表示 $a_{i,j}$。\n\n接下来 $n$ 行，每行 $m$ 个正整数，第 $i$ 行第 $j$ 个正整数表示 $b_{i,j}$。", "outputFormat": "输出到标准输出。\n\n输出一共 $n$ 行，每行 $m$ 个整数，表示到每个点钱恰好花完并结束旅行的方案数，对 $998\\ 244\\ 353$ 取模。", "hint": "**【样例解释 #1】**\n\n到 $(3,1)$ 的方案有：\n\n* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；在 $(2,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,1)$。\n\n到 $(2,2)$ 的方案有：\n\n* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；在 $(2,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(2,2)$。\n\n到 $(3,2)$ 的方案有：\n\n* 在 $(1,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；在 $(1,2)$ 购买 $2$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(2,2)$；乘坐 L 公司的铁路到 $(3,2)$。\n* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；乘坐 L 公司的铁路到 $(2,2)$；在 $(2,2)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,2)$。\n* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票；乘坐 L 公司的铁路到 $(2,1)$；乘坐 Z 公司的铁路到 $(2,2)$；在 $(2,2)$ 购买 $1$ 张 L 公司的铁路票；乘坐 L 公司的铁路到 $(3,2)$。\n\n到 $(2,3)$ 的方案有：\n\n* 在 $(1,1)$ 购买 $1$ 张 L 公司的铁路票和 $2$ 张 Z 公司的铁路票。在此之后，有 $3$ 种方案可以从 $(1,1)$ 乘坐两公司的铁路到 $(2,3)$。\n* 在 $(1,1)$ 购买 $1$ 张 Z 公司的铁路票；乘坐 Z 公司的铁路到 $(1,2)$；在 $(1,2)$ 购买 $1$ 张 L 公司的铁路票和 $1$ 张 Z 公司的铁路票。在此之后，有 $2$ 种方案可以从 $(1,2)$ 乘坐两公司的铁路到 $(2,3)$。\n\n**【样例 #2】**\n\n见选手目录下的 `travel/travel2.in` 与 `travel/travel2.ans`。这个样例满足测试点 $7\\sim 8$ 的条件限制。\n\n**【样例 #3】**\n\n见选手目录下的 `travel/travel3.in` 与 `travel/travel3.ans`。这个样例满足测试点 $11$ 的条件限制。\n\n**【数据范围】**\n\n对于所有数据保证：$1\\leq n,m\\leq45$，$1\\leq k,a_{i,j},b_{i,j}\\leq90$。\n\n| 测试点编号 | $n,m$ | $k$ | $a_{i,j}$ | $b_{i,j}$ |\n|:--:|:--:|:--:|:--:|:--:|\n| $1\\sim3$ | $\\leq3$ | $\\leq5$ | $=1$ | $=1$ |\n| $4\\sim6$ | $\\leq10$ | $\\leq10$ | $=1$ | $=40$ |\n| $7\\sim8$ | $\\leq40$ | $\\leq30$ | $=1$ | $=45$ |\n| $9\\sim10$ | $\\leq15$ | $\\leq15$ | $\\leq15$ | $\\leq15$ |\n| $11$ | $\\leq15$ | $\\leq30$ | $\\leq30$ | $\\leq30$ |\n| $12$ | $\\leq20$ | $\\leq40$ | $\\leq40$ | $\\leq40$ |\n| $13\\sim15$ | $\\leq25$ | $\\leq50$ | $\\leq50$ | $\\leq50$ |\n| $16$ | $\\leq30$ | $\\leq60$ | $\\leq60$ | $\\leq60$ |\n| $17$ | $\\leq35$ | $\\leq70$ | $\\leq70$ | $\\leq70$ |\n| $18\\sim19$ | $\\leq40$ | $\\leq80$ | $\\leq80$ | $\\leq80$ |\n| $20$ | $\\leq45$ | $\\leq90$ | $\\leq90$ | $\\leq90$ |", "locale": "zh-CN"}}}
{"pid": "P9744", "type": "P", "difficulty": 4, "samples": [["5\n1 13 6 0 6\n2 4 1 0 5\n3 4 1 2 1\n7\n1 4\n2 1 5\n1 4\n2 2 3\n5 1 2 3 4 5\n1 5\n2 3 4", "7\n3\n7\n6\n0\n0\n8"], ["7\n10 1 6 9 4 2 4 \n0 5 2 3 0 1 4 \n4 1 4 1 5 3 5 \n6\n3 1 3 6 \n2 2 6 \n4 3 4 5 7 \n1 4 \n2 3 7 \n3 3 5 6", "12\n8\n2\n5\n5\n8"], ["10\n6 10 7 2 8 4 6 4 8 7\n4 0 6 7 8 4 8 2 10 5\n4 10 6 1 4 7 5 3 8 7\n1\n0", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["递推", "2023", "洛谷原创", "O2优化", "前缀和", "洛谷月赛"], "title": "「KDOI-06-S」消除序列", "background": "", "description": "小 M 有一个长度为 $n$ 的序列 $v_1,v_2,\\ldots,v_n$，初始时，所有元素的值均为 $1$。\n\n你有 $3$ 种作用在这个序列上的操作：\n\n1. 选择一个下标 $i$（$1\\le i\\le n$），并且将 $v_1,v_2,\\ldots,v_i$ 的值全部设为 $0$，这种操作的代价是 $a_i$；\n2. 选择一个下标 $i$（$1\\le i\\le n$），并且将 $v_i$ 的值设为 $0$，这种操作的代价是 $b_i$；\n3. 选择一个下标 $i$（$1\\le i\\le n$），并且将 $v_i$ 的值设为 $1$，这种操作的代价是 $c_i$。\n\n现在有 $q$ 次询问，每次询问中给定一个集合 $P$，你希望进行若干次操作（可能为 $0$），使得：序列 $v$ 中下标位于该集合的元素的值为 $1$，其余位置的值为 $0$。**形式化地说，对于任意 $\\bm{1\\le i\\le n}$，若 $\\bm{i\\in P}$，则 $\\bm{v_i=1}$，否则 $\\bm{v_i=0}$。** 并且，你需要最小化这次询问中所有操作的总代价。\n\n注意，询问是相互独立的，也就是说，每次询问结束后，序列 $v$ 将会回到初始状态，即所有元素的值全都变为 $1$。", "inputFormat": "从标准输入读入数据。\n\n输入的第一行包含一个正整数 $n$，表示序列 $v$ 的长度。\n\n第二行包含 $n$ 个非负整数 $a_1,a_2,\\ldots,a_n$，表示第一种操作的代价。\n\n第三行包含 $n$ 个非负整数 $b_1,b_2,\\ldots,b_n$，表示第二种操作的代价。\n\n第四行包含 $n$ 个非负整数 $c_1,c_2,\\ldots,c_n$，表示第三种操作的代价。\n\n第五行包含一个正整数 $q$，表示询问次数。\n\n接下来的 $q$ 行中，第 $i$ 行包含以下内容：\n\n+ 开头一个非负整数 $m$，表示第 $i$ 次询问中集合 $P$ 的大小；\n+ 接下来有 $m$ 个正整数 $p_1,p_2,\\ldots,p_m$，依次表示集合 $P$ 中每个元素的值，保证对于任意 $1\\le i<m$，都有 $p_i<p_{i+1}$。", "outputFormat": "输出到标准输出。\n\n输出共 $q$ 行，第 $i$ 行包含一个非负整数，表示第 $i$ 次询问中操作总代价的最小值。", "hint": "**【样例解释 #1】**\n\n对于第一次询问，可以按顺序执行如下操作：\n\n+ 在 $i=4$ 处执行操作 $1$，在这之后，序列 $v$ 变为 $[0,0,0,0,1]$，代价为 $0$；\n+ 在 $i=4$ 处执行操作 $3$，在这之后，序列 $v$ 变为 $[0,0,0,1,1]$，代价为 $2$；\n+ 在 $i=5$ 处执行操作 $2$，在这之后，序列 $v$ 变为 $[0,0,0,1,0]$，代价为 $5$。\n\n所以总代价为 $0+2+5=7$，可以证明，不存在更小的总代价。\n\n**【样例解释 #3】**\n\n对于这个样例中的唯一一次询问，可以选择在 $i=10$ 处执行操作 $1$，总代价为 $a_{10}=7$。\n\n**【样例 #4】**\n\n见选手目录下的 `reserve/reserve4.in` 与 `reserve/reserve4.ans`。\n\n**【样例 #5】**\n\n见选手目录下的 `reserve/reserve5.in` 与 `reserve/reserve5.ans`。\n\n这个样例满足测试点 $8\\sim 11$ 的条件限制。\n\n**【样例 #6】**\n\n见选手目录下的 `reserve/reserve6.in` 与 `reserve/reserve6.ans`。\n\n这个样例满足测试点 $14\\sim 15$ 的条件限制。\n\n**【样例 #7】**\n\n见选手目录下的 `reserve/reserve7.in` 与 `reserve/reserve7.ans`。\n\n这个样例满足测试点 $16$ 的条件限制。\n\n**【样例 #8】**\n\n见选手目录下的 `reserve/reserve8.in` 与 `reserve/reserve8.ans`。\n\n这个样例满足测试点 $17\\sim 20$ 的条件限制。\n\n***\n\n**【数据范围】**\n\n记 $\\sum m$ 为单测试点内所有询问 $m$ 的值之和。\n\n对于所有数据保证：$1 \\leq n \\leq 5\\times 10^5$，$0\\le m \\le n$，$0 \\leq \\sum m \\leq 5 \\times 10^5$，$1\\le q\\le \\max(n,\\sum m)$，$0 \\le a_i, b_i, c_i \\le 10^9$，$1\\le p_i \\le n$。\n\n| 测试点编号 | $n \\le$ | $m \\le$ | $\\sum m \\le$| 是否有特殊性质 |\n|:--:|:--:|:--:|:--:|:--:|\n| $1 \\sim 2$ | $5 \\times 10^5$ | $0$ | $0$ | 否 |\n| $3 \\sim 4$ | $7$ | $7$ | $15$ | 否 |\n| $5 \\sim 6$ | $2 \\times 10^3$ | $1$ | $2 \\times 10^3$ | 否 |\n| $7$ | $2 \\times 10^3$ | $2 \\times 10^3$ | $2 \\times 10^3$ | 是 |\n| $8 \\sim 11$ | $2 \\times 10^3$ | $2\\times 10^3$ | $2 \\times 10^3$ | 否 |\n| $12 \\sim 13$ | $5 \\times 10^4$ | $5 \\times 10^4$ | $5 \\times 10^4$ | 否 |\n| $14 \\sim 15$ | $5 \\times 10^5$ | $1$ | $5 \\times 10^5$ | 否 |\n| $16$ | $5 \\times 10^5$ | $5 \\times 10^5$ | $5 \\times 10^5$ | 是 |\n| $17 \\sim 20$ | $5 \\times 10^5$ | $5 \\times 10^5$ | $5 \\times 10^5$ | 否 |\n\n特殊性质：对于任意 $1\\le i\\le n$，保证 $c_i = 0$。\n\n**【提示】**\n\n本题输入输出量较大，请使用适当的 I/O 方式。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KDOI-06-S」消除序列", "background": "", "description": "小 M 有一个长度为 $n$ 的序列 $v_1,v_2,\\ldots,v_n$，初始时，所有元素的值均为 $1$。\n\n你有 $3$ 种作用在这个序列上的操作：\n\n1. 选择一个下标 $i$（$1\\le i\\le n$），并且将 $v_1,v_2,\\ldots,v_i$ 的值全部设为 $0$，这种操作的代价是 $a_i$；\n2. 选择一个下标 $i$（$1\\le i\\le n$），并且将 $v_i$ 的值设为 $0$，这种操作的代价是 $b_i$；\n3. 选择一个下标 $i$（$1\\le i\\le n$），并且将 $v_i$ 的值设为 $1$，这种操作的代价是 $c_i$。\n\n现在有 $q$ 次询问，每次询问中给定一个集合 $P$，你希望进行若干次操作（可能为 $0$），使得：序列 $v$ 中下标位于该集合的元素的值为 $1$，其余位置的值为 $0$。**形式化地说，对于任意 $\\bm{1\\le i\\le n}$，若 $\\bm{i\\in P}$，则 $\\bm{v_i=1}$，否则 $\\bm{v_i=0}$。** 并且，你需要最小化这次询问中所有操作的总代价。\n\n注意，询问是相互独立的，也就是说，每次询问结束后，序列 $v$ 将会回到初始状态，即所有元素的值全都变为 $1$。", "inputFormat": "从标准输入读入数据。\n\n输入的第一行包含一个正整数 $n$，表示序列 $v$ 的长度。\n\n第二行包含 $n$ 个非负整数 $a_1,a_2,\\ldots,a_n$，表示第一种操作的代价。\n\n第三行包含 $n$ 个非负整数 $b_1,b_2,\\ldots,b_n$，表示第二种操作的代价。\n\n第四行包含 $n$ 个非负整数 $c_1,c_2,\\ldots,c_n$，表示第三种操作的代价。\n\n第五行包含一个正整数 $q$，表示询问次数。\n\n接下来的 $q$ 行中，第 $i$ 行包含以下内容：\n\n+ 开头一个非负整数 $m$，表示第 $i$ 次询问中集合 $P$ 的大小；\n+ 接下来有 $m$ 个正整数 $p_1,p_2,\\ldots,p_m$，依次表示集合 $P$ 中每个元素的值，保证对于任意 $1\\le i<m$，都有 $p_i<p_{i+1}$。", "outputFormat": "输出到标准输出。\n\n输出共 $q$ 行，第 $i$ 行包含一个非负整数，表示第 $i$ 次询问中操作总代价的最小值。", "hint": "**【样例解释 #1】**\n\n对于第一次询问，可以按顺序执行如下操作：\n\n+ 在 $i=4$ 处执行操作 $1$，在这之后，序列 $v$ 变为 $[0,0,0,0,1]$，代价为 $0$；\n+ 在 $i=4$ 处执行操作 $3$，在这之后，序列 $v$ 变为 $[0,0,0,1,1]$，代价为 $2$；\n+ 在 $i=5$ 处执行操作 $2$，在这之后，序列 $v$ 变为 $[0,0,0,1,0]$，代价为 $5$。\n\n所以总代价为 $0+2+5=7$，可以证明，不存在更小的总代价。\n\n**【样例解释 #3】**\n\n对于这个样例中的唯一一次询问，可以选择在 $i=10$ 处执行操作 $1$，总代价为 $a_{10}=7$。\n\n**【样例 #4】**\n\n见选手目录下的 `reserve/reserve4.in` 与 `reserve/reserve4.ans`。\n\n**【样例 #5】**\n\n见选手目录下的 `reserve/reserve5.in` 与 `reserve/reserve5.ans`。\n\n这个样例满足测试点 $8\\sim 11$ 的条件限制。\n\n**【样例 #6】**\n\n见选手目录下的 `reserve/reserve6.in` 与 `reserve/reserve6.ans`。\n\n这个样例满足测试点 $14\\sim 15$ 的条件限制。\n\n**【样例 #7】**\n\n见选手目录下的 `reserve/reserve7.in` 与 `reserve/reserve7.ans`。\n\n这个样例满足测试点 $16$ 的条件限制。\n\n**【样例 #8】**\n\n见选手目录下的 `reserve/reserve8.in` 与 `reserve/reserve8.ans`。\n\n这个样例满足测试点 $17\\sim 20$ 的条件限制。\n\n***\n\n**【数据范围】**\n\n记 $\\sum m$ 为单测试点内所有询问 $m$ 的值之和。\n\n对于所有数据保证：$1 \\leq n \\leq 5\\times 10^5$，$0\\le m \\le n$，$0 \\leq \\sum m \\leq 5 \\times 10^5$，$1\\le q\\le \\max(n,\\sum m)$，$0 \\le a_i, b_i, c_i \\le 10^9$，$1\\le p_i \\le n$。\n\n| 测试点编号 | $n \\le$ | $m \\le$ | $\\sum m \\le$| 是否有特殊性质 |\n|:--:|:--:|:--:|:--:|:--:|\n| $1 \\sim 2$ | $5 \\times 10^5$ | $0$ | $0$ | 否 |\n| $3 \\sim 4$ | $7$ | $7$ | $15$ | 否 |\n| $5 \\sim 6$ | $2 \\times 10^3$ | $1$ | $2 \\times 10^3$ | 否 |\n| $7$ | $2 \\times 10^3$ | $2 \\times 10^3$ | $2 \\times 10^3$ | 是 |\n| $8 \\sim 11$ | $2 \\times 10^3$ | $2\\times 10^3$ | $2 \\times 10^3$ | 否 |\n| $12 \\sim 13$ | $5 \\times 10^4$ | $5 \\times 10^4$ | $5 \\times 10^4$ | 否 |\n| $14 \\sim 15$ | $5 \\times 10^5$ | $1$ | $5 \\times 10^5$ | 否 |\n| $16$ | $5 \\times 10^5$ | $5 \\times 10^5$ | $5 \\times 10^5$ | 是 |\n| $17 \\sim 20$ | $5 \\times 10^5$ | $5 \\times 10^5$ | $5 \\times 10^5$ | 否 |\n\n特殊性质：对于任意 $1\\le i\\le n$，保证 $c_i = 0$。\n\n**【提示】**\n\n本题输入输出量较大，请使用适当的 I/O 方式。", "locale": "zh-CN"}}}
{"pid": "P9745", "type": "P", "difficulty": 5, "samples": [["3\n1 2 3\n1 1", "19"], ["5\n3 4 5 6 7\n1 1 2 2", "5985"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2023", "洛谷原创", "O2优化", "树形 DP", "位运算", "洛谷月赛"], "title": "「KDOI-06-S」树上异或", "background": "", "description": "给定一棵包含 $n$ 个节点的树，第 $i$ 个点有一个点权 $x_i$。\n\n对于树上的 $n-1$ 条边，每条边选择删除或不删除，有 $2^{n-1}$ 种选择是否删除每条边的方案。\n\n对于每种删除边的方案，设删除后的图包含 $k$ 个连通块，定义这个方案的权值为图中连通块点权异或和的乘积。形式化地说，若这张图包含连通块 $C_1,C_2,\\ldots,C_k$，其中 $C_i$ 是第 $i$ 个连通块的顶点集合，设 $v_i=\\bigoplus_{u\\in C_i} x_u$，则这个方案的权值为 $v_1\\times v_2\\times \\cdots\\times v_k$。\n\n求这 $2^{n-1}$ 种删除边的方案的**权值**之和，答案对 $998~244~353$ 取模。", "inputFormat": "从标准输入读入数据。\n\n输入的第一行包含一个正整数 $n$，表示树的节点个数。\n\n第二行 $n$ 个非负整数 $x_1,x_2,\\ldots,x_n$，表示每个点的点权。\n\n第三行 $n-1$ 个正整数 $f_2,f_3,\\ldots,f_n$，表示节点 $i$ 与 $f_{i}$ 之间有一条无向边。", "outputFormat": "输出到标准输出。\n\n输出包含一行一个整数，表示所有 $2^{n-1}$ 种删除边的方案的**权值**之和，答案对 $998~244~353$ 取模。", "hint": "**【样例解释 #1】**\n\n有四种删除边的方案：\n\n* 不删除边：图有且仅有一个连通块，权值为 $1\\oplus2\\oplus3=0$。\n* 删除 $(1,2)$ 一条边：图包含两个连通块，权值为 $(1\\oplus3)\\times2=4$。\n* 删除 $(1,3)$ 一条边：图包含两个连通块，权值为 $(1\\oplus2)\\times3=9$。\n* 删除 $(1,2)$，$(1,3)$ 两条边：图包含三个连通块，权值为 $1\\times2\\times3=6$。\n\n所有方案权值的总和为 $0+4+9+6=19$。\n\n**【样例 #3】**\n\n见选手目录下的 `xor/xor3.in` 与 `xor/xor3.ans`。\n\n这个样例满足测试点 $6\\sim7$ 的条件限制。\n\n**【样例 #4】**\n\n见选手目录下的 `xor/xor4.in` 与 `xor/xor4.ans`。\n\n这个样例满足测试点 $8$ 的条件限制。\n\n**【样例 #5】**\n\n见选手目录下的 `xor/xor5.in` 与 `xor/xor5.ans`。\n\n这个样例满足测试点 $9$ 的条件限制。\n\n**【样例 #6】**\n\n见选手目录下的 `xor/xor6.in` 与 `xor/xor6.ans`。\n\n这个样例满足测试点 $19\\sim21$ 的条件限制。\n\n***\n\n**【数据范围】**\n\n对于所有数据保证：$1\\leq n\\leq5\\times10^5$，$0\\leq x_i\\leq10^{18}$，$1\\leq f_i<i$。\n\n| 测试点编号 | $n\\leq$ | $x_i$ | 特殊性质 |\n|:--:|:--:|:--:|:--:|\n| $1\\sim2$ | $12$ | $\\leq10^9$ | 无 |\n| $3$ | $2000$ | $=1$ | 无 |\n| $4$ | $10^5$ | $=1$ | A |\n| $5$ | $10^5$ | $=1$ | B |\n| $6\\sim7$ | $10^5$ | $=1$ | 无 |\n| $8$ | $10^5$ | $\\leq7$ | A |\n| $9$ | $10^5$ | $\\leq7$ | B |\n| $10\\sim11$ | $10^5$ | $\\leq7$ | 无 |\n| $12\\sim16$ | $200$ | $\\leq8191$ | 无 |\n| $17$ | $10^5$ | $\\leq10^9$ | A |\n| $18$ | $10^5$ | $\\leq10^9$ | B |\n| $19\\sim21$ | $10^5$ | $\\leq10^9$ | 无 |\n| $22\\sim25$ | $5\\times10^5$ | $\\leq10^{18}$ | 无 |\n\n* 特殊性质 A：保证对于任意 $1< i\\le n$，$f_i=i-1$。\n* 特殊性质 B：保证对于任意 $1< i\\le n$，$f_i=1$。\n\n***\n\n**【提示】**\n\n$\\oplus$ 表示按位异或运算。\n\n本题输入输出量较大，请使用适当的 I/O 方式。\n\n**请注意常数因子对程序运行效率产生的影响。**\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KDOI-06-S」树上异或", "background": "", "description": "给定一棵包含 $n$ 个节点的树，第 $i$ 个点有一个点权 $x_i$。\n\n对于树上的 $n-1$ 条边，每条边选择删除或不删除，有 $2^{n-1}$ 种选择是否删除每条边的方案。\n\n对于每种删除边的方案，设删除后的图包含 $k$ 个连通块，定义这个方案的权值为图中连通块点权异或和的乘积。形式化地说，若这张图包含连通块 $C_1,C_2,\\ldots,C_k$，其中 $C_i$ 是第 $i$ 个连通块的顶点集合，设 $v_i=\\bigoplus_{u\\in C_i} x_u$，则这个方案的权值为 $v_1\\times v_2\\times \\cdots\\times v_k$。\n\n求这 $2^{n-1}$ 种删除边的方案的**权值**之和，答案对 $998~244~353$ 取模。", "inputFormat": "从标准输入读入数据。\n\n输入的第一行包含一个正整数 $n$，表示树的节点个数。\n\n第二行 $n$ 个非负整数 $x_1,x_2,\\ldots,x_n$，表示每个点的点权。\n\n第三行 $n-1$ 个正整数 $f_2,f_3,\\ldots,f_n$，表示节点 $i$ 与 $f_{i}$ 之间有一条无向边。", "outputFormat": "输出到标准输出。\n\n输出包含一行一个整数，表示所有 $2^{n-1}$ 种删除边的方案的**权值**之和，答案对 $998~244~353$ 取模。", "hint": "**【样例解释 #1】**\n\n有四种删除边的方案：\n\n* 不删除边：图有且仅有一个连通块，权值为 $1\\oplus2\\oplus3=0$。\n* 删除 $(1,2)$ 一条边：图包含两个连通块，权值为 $(1\\oplus3)\\times2=4$。\n* 删除 $(1,3)$ 一条边：图包含两个连通块，权值为 $(1\\oplus2)\\times3=9$。\n* 删除 $(1,2)$，$(1,3)$ 两条边：图包含三个连通块，权值为 $1\\times2\\times3=6$。\n\n所有方案权值的总和为 $0+4+9+6=19$。\n\n**【样例 #3】**\n\n见选手目录下的 `xor/xor3.in` 与 `xor/xor3.ans`。\n\n这个样例满足测试点 $6\\sim7$ 的条件限制。\n\n**【样例 #4】**\n\n见选手目录下的 `xor/xor4.in` 与 `xor/xor4.ans`。\n\n这个样例满足测试点 $8$ 的条件限制。\n\n**【样例 #5】**\n\n见选手目录下的 `xor/xor5.in` 与 `xor/xor5.ans`。\n\n这个样例满足测试点 $9$ 的条件限制。\n\n**【样例 #6】**\n\n见选手目录下的 `xor/xor6.in` 与 `xor/xor6.ans`。\n\n这个样例满足测试点 $19\\sim21$ 的条件限制。\n\n***\n\n**【数据范围】**\n\n对于所有数据保证：$1\\leq n\\leq5\\times10^5$，$0\\leq x_i\\leq10^{18}$，$1\\leq f_i<i$。\n\n| 测试点编号 | $n\\leq$ | $x_i$ | 特殊性质 |\n|:--:|:--:|:--:|:--:|\n| $1\\sim2$ | $12$ | $\\leq10^9$ | 无 |\n| $3$ | $2000$ | $=1$ | 无 |\n| $4$ | $10^5$ | $=1$ | A |\n| $5$ | $10^5$ | $=1$ | B |\n| $6\\sim7$ | $10^5$ | $=1$ | 无 |\n| $8$ | $10^5$ | $\\leq7$ | A |\n| $9$ | $10^5$ | $\\leq7$ | B |\n| $10\\sim11$ | $10^5$ | $\\leq7$ | 无 |\n| $12\\sim16$ | $200$ | $\\leq8191$ | 无 |\n| $17$ | $10^5$ | $\\leq10^9$ | A |\n| $18$ | $10^5$ | $\\leq10^9$ | B |\n| $19\\sim21$ | $10^5$ | $\\leq10^9$ | 无 |\n| $22\\sim25$ | $5\\times10^5$ | $\\leq10^{18}$ | 无 |\n\n* 特殊性质 A：保证对于任意 $1< i\\le n$，$f_i=i-1$。\n* 特殊性质 B：保证对于任意 $1< i\\le n$，$f_i=1$。\n\n***\n\n**【提示】**\n\n$\\oplus$ 表示按位异或运算。\n\n本题输入输出量较大，请使用适当的 I/O 方式。\n\n**请注意常数因子对程序运行效率产生的影响。**\n", "locale": "zh-CN"}}}
{"pid": "P9746", "type": "P", "difficulty": 6, "samples": [["2\n5\n3 3 1 4 5\n9\n3 4 6 5 4 5 1 2 4", "Huoyu\n2\n3 4 5\n1 2 3\nHuoyu\n3\n1 3 4\n2 3 4\n1 2 4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2023", "洛谷原创", "Special Judge", "O2优化", "区间 DP", "位运算", "洛谷月赛"], "title": "「KDOI-06-S」合并序列", "background": "", "description": "给定一个长度为 $n$ 的序列 $a_1,a_2,\\ldots a_n$。\n\n你可以对这个序列进行若干（可能为 $0$）次操作。在每次操作中，你将会：\n\n* 选择三个正整数 $i<j<k$，满足 $a_i\\oplus a_j\\oplus a_k=0$ 且 $k$ 的值不超过此时序列的长度。记 $s=a_i\\oplus a_{i+1}\\oplus \\cdots\\oplus a_k$。\n* 然后，删除 $a_i\\sim a_k$，并在原来这 $k-i+1$ 个数所在的位置插入 $s$。注意，此时序列 $a$ 的长度将会减少 $(k-i)$。\n\n请你判断是否能够使得序列 $a$ 仅剩一个数，也就是说，在所有操作结束后 $a$ 的长度为 $1$。若可以，你还需要给出一种操作方案。", "inputFormat": "从标准输入读入数据。\n\n**本题含有多组测试数据。**\n\n输入的第一行包含一个正整数 $T$，表示数据组数。\n\n对于每组测试数据，第一行一个正整数 $n$，表示初始序列长度。\n\n第二行 $n$ 个整数 $a_1,a_2,\\ldots,a_n$，表示初始序列中每个元素的值。", "outputFormat": "对于每组测试数据：\n\n+ 若存在一种方案使得序列 $a$ 仅剩一个数，请在输出的第一行输出 `Huoyu`。\n  + 接下来，在第二行你应该输出一个非负整数 $t$，表示你的操作次数。你需要保证 $0\\le t\\le n$。\n  + 接下来 $t$ 行，每行输出三个正整数 $i,j,k$，表示你在这次操作中选择的三个数的值。你需要保证 $i<j<k$ 且 $k$ 的值不超过此时序列的长度。\n+ 否则，请输出一行一个字符串 `Shuiniao`。", "hint": "**【样例解释 #1】**\n\n对于第一组测试数据：\n\n* 第一次操作中，$a_3\\oplus a_4\\oplus a_5=1\\oplus4\\oplus5=0$，操作后的序列为 $[3,3,0]$；\n* 第二次操作中，$a_1\\oplus a_2\\oplus a_3=3\\oplus3\\oplus0=0$，操作后的序列为 $[0]$。\n\n于是，序列 $a$ 在两次操作后仅剩一个数。\n\n对于第二组测试数据：\n\n* 第一次操作，$a_1\\oplus a_3\\oplus a_4=3\\oplus6\\oplus5=0$，$s=4$，操作后的序列为 $[4,4,5,1,2,4]$。\n* 第二次操作，$a_2\\oplus a_3\\oplus a_4=4\\oplus5\\oplus1=0$，操作后的序列为 $[4,0,2,4]$。\n* 第三次操作，$a_1\\oplus a_2\\oplus a_4=4\\oplus0\\oplus4=0$，$s=2$，操作后的序列为 $[2]$。\n\n于是，序列 $a$ 在三次操作后仅剩一个数。\n\n**【样例 #2】**\n\n见选手目录下的 `merge/merge2.in` 与 `merge/merge2.ans`。\n\n这个样例满足测试点 $6\\sim7$ 的条件限制。\n\n**【样例 #3】**\n\n见选手目录下的 `merge/merge3.in` 与 `merge/merge3.ans`。\n\n这个样例满足测试点 $12\\sim13$ 的条件限制。\n\n**【数据范围】**\n\n对于所有数据保证：$1\\leq T\\leq20$，$1\\leq n\\leq500$，$0\\leq a_i<512$。\n\n| 测试点编号 | $n$ | $\\sum n\\leq$ | $a_i<$ |\n|:--:|:--:|:--:|:--:|\n| $1$ | $=1$ | $20$ | $512$ |\n| $2$ | $=2$ | $40$ | $512$ |\n| $3$ | $=3$ | $60$ | $512$ |\n| $4$ | $=4$ | $80$ | $512$ |\n| $5$ | $=5$ | $100$ | $512$ |\n| $6\\sim7$ | $\\leq40$ | $800$ | $512$ |\n| $8\\sim9$ | $\\leq70$ | $1~400$ | $512$ |\n| $10\\sim11$ | $\\leq130$ | $2~600$ | $512$ |\n| $12\\sim13$ | $\\leq300$ | $6~000$ | $128$ |\n| $14\\sim15$ | $\\leq500$ | $3~000$ | $64$ |\n| $16\\sim17$ | $\\leq500$ | $3~000$ | $128$ |\n| $18\\sim20$ | $\\leq500$ | $10~000$ | $512$ |\n\n**【提示】**\n\n$\\oplus$ 表示按位异或运算。\n\n**请对程序的常数以及效率给予充分的信任。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KDOI-06-S」合并序列", "background": "", "description": "给定一个长度为 $n$ 的序列 $a_1,a_2,\\ldots a_n$。\n\n你可以对这个序列进行若干（可能为 $0$）次操作。在每次操作中，你将会：\n\n* 选择三个正整数 $i<j<k$，满足 $a_i\\oplus a_j\\oplus a_k=0$ 且 $k$ 的值不超过此时序列的长度。记 $s=a_i\\oplus a_{i+1}\\oplus \\cdots\\oplus a_k$。\n* 然后，删除 $a_i\\sim a_k$，并在原来这 $k-i+1$ 个数所在的位置插入 $s$。注意，此时序列 $a$ 的长度将会减少 $(k-i)$。\n\n请你判断是否能够使得序列 $a$ 仅剩一个数，也就是说，在所有操作结束后 $a$ 的长度为 $1$。若可以，你还需要给出一种操作方案。", "inputFormat": "从标准输入读入数据。\n\n**本题含有多组测试数据。**\n\n输入的第一行包含一个正整数 $T$，表示数据组数。\n\n对于每组测试数据，第一行一个正整数 $n$，表示初始序列长度。\n\n第二行 $n$ 个整数 $a_1,a_2,\\ldots,a_n$，表示初始序列中每个元素的值。", "outputFormat": "对于每组测试数据：\n\n+ 若存在一种方案使得序列 $a$ 仅剩一个数，请在输出的第一行输出 `Huoyu`。\n  + 接下来，在第二行你应该输出一个非负整数 $t$，表示你的操作次数。你需要保证 $0\\le t\\le n$。\n  + 接下来 $t$ 行，每行输出三个正整数 $i,j,k$，表示你在这次操作中选择的三个数的值。你需要保证 $i<j<k$ 且 $k$ 的值不超过此时序列的长度。\n+ 否则，请输出一行一个字符串 `Shuiniao`。", "hint": "**【样例解释 #1】**\n\n对于第一组测试数据：\n\n* 第一次操作中，$a_3\\oplus a_4\\oplus a_5=1\\oplus4\\oplus5=0$，操作后的序列为 $[3,3,0]$；\n* 第二次操作中，$a_1\\oplus a_2\\oplus a_3=3\\oplus3\\oplus0=0$，操作后的序列为 $[0]$。\n\n于是，序列 $a$ 在两次操作后仅剩一个数。\n\n对于第二组测试数据：\n\n* 第一次操作，$a_1\\oplus a_3\\oplus a_4=3\\oplus6\\oplus5=0$，$s=4$，操作后的序列为 $[4,4,5,1,2,4]$。\n* 第二次操作，$a_2\\oplus a_3\\oplus a_4=4\\oplus5\\oplus1=0$，操作后的序列为 $[4,0,2,4]$。\n* 第三次操作，$a_1\\oplus a_2\\oplus a_4=4\\oplus0\\oplus4=0$，$s=2$，操作后的序列为 $[2]$。\n\n于是，序列 $a$ 在三次操作后仅剩一个数。\n\n**【样例 #2】**\n\n见选手目录下的 `merge/merge2.in` 与 `merge/merge2.ans`。\n\n这个样例满足测试点 $6\\sim7$ 的条件限制。\n\n**【样例 #3】**\n\n见选手目录下的 `merge/merge3.in` 与 `merge/merge3.ans`。\n\n这个样例满足测试点 $12\\sim13$ 的条件限制。\n\n**【数据范围】**\n\n对于所有数据保证：$1\\leq T\\leq20$，$1\\leq n\\leq500$，$0\\leq a_i<512$。\n\n| 测试点编号 | $n$ | $\\sum n\\leq$ | $a_i<$ |\n|:--:|:--:|:--:|:--:|\n| $1$ | $=1$ | $20$ | $512$ |\n| $2$ | $=2$ | $40$ | $512$ |\n| $3$ | $=3$ | $60$ | $512$ |\n| $4$ | $=4$ | $80$ | $512$ |\n| $5$ | $=5$ | $100$ | $512$ |\n| $6\\sim7$ | $\\leq40$ | $800$ | $512$ |\n| $8\\sim9$ | $\\leq70$ | $1~400$ | $512$ |\n| $10\\sim11$ | $\\leq130$ | $2~600$ | $512$ |\n| $12\\sim13$ | $\\leq300$ | $6~000$ | $128$ |\n| $14\\sim15$ | $\\leq500$ | $3~000$ | $64$ |\n| $16\\sim17$ | $\\leq500$ | $3~000$ | $128$ |\n| $18\\sim20$ | $\\leq500$ | $10~000$ | $512$ |\n\n**【提示】**\n\n$\\oplus$ 表示按位异或运算。\n\n**请对程序的常数以及效率给予充分的信任。**", "locale": "zh-CN"}}}
{"pid": "P9747", "type": "P", "difficulty": 6, "samples": [["2 0\n7 2\n0 4 2 6 0 6 6\n1 7\n2 3\n3 1\n1 2 3\n1 3", "7\n1\n3"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2023", "洛谷原创", "O2优化", "洛谷月赛"], "title": "「KDOI-06-S」签到题", "background": "你正在追番，突然家长进来了，于是你假装在写一道数据结构题。\n\n", "description": "定义一个长度为 $m$ 的数组 $v$ 是合法的，当且仅当经过若干次以下操作可以使 $v$ 中的所有元素相等：\n\n* 选择四个整数 $a,b,c,d$（$1\\leq a\\leq b\\leq m$，$1\\leq c\\leq d\\leq m$）满足 $b-a+1=d-c+1$，且 $v_a\\operatorname{~or~}v_{a+1}\\operatorname{~or~}\\cdots\\operatorname{~or~}v_b=v_c\\operatorname{~or~}v_{c+1}\\operatorname{~or~}\\cdots\\operatorname{~or~}v_d$，其中 $\\operatorname{or}$ 表示按位或运算。接下来，将区间 $[a,b]$ 的数**复制下来再覆盖**到区间 $[c,d]$。**注意：区间 $\\bm{[a,b]}$ 和 $\\bm{[c,d]}$ 可能会相交。**\n\n给出一个长度为 $n$ 的序列 $a_1,a_2,\\ldots,a_n$ 以及 $q$ 次询问，每次询问给定两个正整数 $l,r$，你需要回答区间 $[l,r]$ 内的最长合法子区间的长度。", "inputFormat": "从标准输入读入数据。\n\n**本题含有多组测试数据。**\n\n输入的第一行包含两个整数 $T,id$，表示数据组数和测试点编号（样例的测试点编号为 $0$）。\n\n对于每组测试数据数据，第一行两个正整数 $n,q$，表示序列长度与询问次数。\n\n第二行 $n$ 个正整数 $a_1,a_2,\\ldots,a_n$，表示序列 $a$ 中每个元素的值。\n\n接下来 $q$ 行，每行两个正整数 $l,r$，表示询问的区间。", "outputFormat": "输出到标准输出。\n\n对于每组测试数据的每次询问，输出一行一个整数，表示区间 $[l,r]$ 内的最长合法子区间的长度。", "hint": "**【样例解释 #1】**\n\n对于第一组数据的第一个询问，最长的合法子区间为 $[1,7]$，以下是一种可能的操作序列：\n\n1. 选择区间 $[1,4]$ 和 $[2,5]$，将区间 $[1,4]$ 中的数**先复制**下来，再覆盖到 $[2,5]$ 上，此时序列变为 $[0,0,4,2,6,6,6]$。\n\n2. 选择区间 $[5,6]$ 和 $[3,4]$，此时序列变为 $[0,0,6,6,6,6,6]$。\n\n3. 选择区间 $[4,7]$ 和 $[1,4]$，此时序列变为 $[6,6,6,6,6,6,6]$。\n\n注意，操作**并不会**真正的修改原序列中的值。\n\n对于第一组数据的第二个询问，最长的合法子区间为 $[2,2]$ 和 $[3,3]$。\n\n**【样例 #2】**\n\n见选手目录下的 `binary/binary2.in` 与 `binary/binary2.ans`。\n\n这个样例满足测试点 $5\\sim 8$ 的条件限制。\n\n**【样例 #3】**\n\n见选手目录下的 `binary/binary3.in` 与 `binary/binary3.ans`。\n\n这个样例满足测试点 $25\\sim 31$ 的条件限制。\n\n**【样例 #4】**\n\n见选手目录下的 `binary/binary4.in` 与 `binary/binary4.ans`。\n\n这个样例满足测试点 $46\\sim 50$ 的条件限制。\n\n***\n\n**【数据范围】**\n\n对于所有数据保证：$1\\le T\\le 2\\times 10^5$，$1\\le n,q,\\sum n,\\sum q\\le 2\\times 10^6$，$0\\le a_i < 2^{30}$。\n\n| 测试点编号 | $\\sum n\\le$ | $\\sum q\\le$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $5$ | $5$ | 无 |\n| $2\\sim 4$ | $100$ | $100$ | 无 |\n| $5\\sim 8$ | $1000$ | $1000$ | 无 |\n| $9\\sim 14$ | $1000$ | $10^6$ | 无 |\n| $15\\sim 19$ | $6000$ | $10^6$ | 无 |\n| $20\\sim 24$ | $50000$ | $10$ | 无 |\n| $25\\sim 31$ | $10^5$ | $10^5$ | B |\n| $32\\sim 36$ | $2\\times 10^5$ | $2\\times 10^5$ | 无 |\n| $37\\sim 41$ | $5\\times 10^5$ | $10^6$ | B |\n| $42\\sim 44$ | $5\\times 10^5$ | $5\\times 10^5$ | 无 |\n| $45$ | $2\\times 10^6$ | $2\\times 10^6$ | A |\n| $46\\sim 50$ | $2\\times 10^6$ | $2\\times 10^6$ | 无 |\n\n+ 特殊性质 A：保证序列 $a$ 中的每个数均在 $[0,2^{30})$ 之间均匀随机生成。\n+ 特殊性质 B：保证对于任意 $1\\le i\\le n$，$a_i\\le 3$。\n\n***\n\n**【提示】**\n\n本题输入输出量较大，请使用适当的 I/O 方式。\n\n**请注意常数因子对程序运行效率产生的影响。**\n\nKDOI 出题组温馨提示：**多测不清空，爆零两行泪。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KDOI-06-S」签到题", "background": "你正在追番，突然家长进来了，于是你假装在写一道数据结构题。\n\n", "description": "定义一个长度为 $m$ 的数组 $v$ 是合法的，当且仅当经过若干次以下操作可以使 $v$ 中的所有元素相等：\n\n* 选择四个整数 $a,b,c,d$（$1\\leq a\\leq b\\leq m$，$1\\leq c\\leq d\\leq m$）满足 $b-a+1=d-c+1$，且 $v_a\\operatorname{~or~}v_{a+1}\\operatorname{~or~}\\cdots\\operatorname{~or~}v_b=v_c\\operatorname{~or~}v_{c+1}\\operatorname{~or~}\\cdots\\operatorname{~or~}v_d$，其中 $\\operatorname{or}$ 表示按位或运算。接下来，将区间 $[a,b]$ 的数**复制下来再覆盖**到区间 $[c,d]$。**注意：区间 $\\bm{[a,b]}$ 和 $\\bm{[c,d]}$ 可能会相交。**\n\n给出一个长度为 $n$ 的序列 $a_1,a_2,\\ldots,a_n$ 以及 $q$ 次询问，每次询问给定两个正整数 $l,r$，你需要回答区间 $[l,r]$ 内的最长合法子区间的长度。", "inputFormat": "从标准输入读入数据。\n\n**本题含有多组测试数据。**\n\n输入的第一行包含两个整数 $T,id$，表示数据组数和测试点编号（样例的测试点编号为 $0$）。\n\n对于每组测试数据数据，第一行两个正整数 $n,q$，表示序列长度与询问次数。\n\n第二行 $n$ 个正整数 $a_1,a_2,\\ldots,a_n$，表示序列 $a$ 中每个元素的值。\n\n接下来 $q$ 行，每行两个正整数 $l,r$，表示询问的区间。", "outputFormat": "输出到标准输出。\n\n对于每组测试数据的每次询问，输出一行一个整数，表示区间 $[l,r]$ 内的最长合法子区间的长度。", "hint": "**【样例解释 #1】**\n\n对于第一组数据的第一个询问，最长的合法子区间为 $[1,7]$，以下是一种可能的操作序列：\n\n1. 选择区间 $[1,4]$ 和 $[2,5]$，将区间 $[1,4]$ 中的数**先复制**下来，再覆盖到 $[2,5]$ 上，此时序列变为 $[0,0,4,2,6,6,6]$。\n\n2. 选择区间 $[5,6]$ 和 $[3,4]$，此时序列变为 $[0,0,6,6,6,6,6]$。\n\n3. 选择区间 $[4,7]$ 和 $[1,4]$，此时序列变为 $[6,6,6,6,6,6,6]$。\n\n注意，操作**并不会**真正的修改原序列中的值。\n\n对于第一组数据的第二个询问，最长的合法子区间为 $[2,2]$ 和 $[3,3]$。\n\n**【样例 #2】**\n\n见选手目录下的 `binary/binary2.in` 与 `binary/binary2.ans`。\n\n这个样例满足测试点 $5\\sim 8$ 的条件限制。\n\n**【样例 #3】**\n\n见选手目录下的 `binary/binary3.in` 与 `binary/binary3.ans`。\n\n这个样例满足测试点 $25\\sim 31$ 的条件限制。\n\n**【样例 #4】**\n\n见选手目录下的 `binary/binary4.in` 与 `binary/binary4.ans`。\n\n这个样例满足测试点 $46\\sim 50$ 的条件限制。\n\n***\n\n**【数据范围】**\n\n对于所有数据保证：$1\\le T\\le 2\\times 10^5$，$1\\le n,q,\\sum n,\\sum q\\le 2\\times 10^6$，$0\\le a_i < 2^{30}$。\n\n| 测试点编号 | $\\sum n\\le$ | $\\sum q\\le$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $5$ | $5$ | 无 |\n| $2\\sim 4$ | $100$ | $100$ | 无 |\n| $5\\sim 8$ | $1000$ | $1000$ | 无 |\n| $9\\sim 14$ | $1000$ | $10^6$ | 无 |\n| $15\\sim 19$ | $6000$ | $10^6$ | 无 |\n| $20\\sim 24$ | $50000$ | $10$ | 无 |\n| $25\\sim 31$ | $10^5$ | $10^5$ | B |\n| $32\\sim 36$ | $2\\times 10^5$ | $2\\times 10^5$ | 无 |\n| $37\\sim 41$ | $5\\times 10^5$ | $10^6$ | B |\n| $42\\sim 44$ | $5\\times 10^5$ | $5\\times 10^5$ | 无 |\n| $45$ | $2\\times 10^6$ | $2\\times 10^6$ | A |\n| $46\\sim 50$ | $2\\times 10^6$ | $2\\times 10^6$ | 无 |\n\n+ 特殊性质 A：保证序列 $a$ 中的每个数均在 $[0,2^{30})$ 之间均匀随机生成。\n+ 特殊性质 B：保证对于任意 $1\\le i\\le n$，$a_i\\le 3$。\n\n***\n\n**【提示】**\n\n本题输入输出量较大，请使用适当的 I/O 方式。\n\n**请注意常数因子对程序运行效率产生的影响。**\n\nKDOI 出题组温馨提示：**多测不清空，爆零两行泪。**", "locale": "zh-CN"}}}
{"pid": "P9748", "type": "P", "difficulty": 2, "samples": [["8", "5 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "数学", "2023", "O2优化", "CSP-J 入门级"], "title": "[CSP-J 2023] 小苹果", "background": "", "description": "小 Y 的桌子上放着 $n$ 个苹果从左到右排成一列，编号为从 $1$ 到 $n$。\n\n小苞是小 Y 的好朋友，每天她都会从中拿走一些苹果。\n\n每天在拿的时候，小苞都是从左侧第 $1$ 个苹果开始、每隔 $2$ 个苹果拿走 $1$ 个苹果。随后小苞会将剩下的苹果按原先的顺序重新排成一列。\n\n小苞想知道，多少天能拿完所有的苹果，而编号为 $n$ 的苹果是在第几天被拿走的？", "inputFormat": "输入的第一行包含一个正整数 $n$，表示苹果的总数。", "outputFormat": "输出一行包含两个正整数，两个整数之间由一个空格隔开，分别表示小苞拿走所有苹果所需的天数以及拿走编号为 $n$ 的苹果是在第几天。", "hint": "**【样例 $1$ 解释】**\n\n小苞的桌上一共放了 $8$ 个苹果。  \n小苞第一天拿走了编号为 $1$、$4$、$7$ 的苹果。  \n小苞第二天拿走了编号为 $2$、$6$ 的苹果。  \n小苞第三天拿走了编号为 $3$ 的苹果。  \n小苞第四天拿走了编号为 $5$ 的苹果。  \n小苞第五天拿走了编号为 $8$ 的苹果。  \n\n**【样例 $2$】**\n\n见选手目录下的 apple/apple2.in 与 apple/apple2.ans。\n\n**【数据范围】**\n\n对于所有测试数据有：$1\\leq n\\leq 10^9$。\n\n| 测试点 | $n\\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1\\sim 2$ | $10$ | 无 |\n| $3\\sim 5$ | $10^3$ | 无 |\n| $6\\sim 7$ | $10^6$ | 有 |\n| $8\\sim 9$ | $10^6$ | 无 |\n| $10$ | $10^9$ | 无 |\n\n特殊性质：小苞第一天就取走编号为 $n$ 的苹果。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-J 2023] 小苹果", "background": "", "description": "小 Y 的桌子上放着 $n$ 个苹果从左到右排成一列，编号为从 $1$ 到 $n$。\n\n小苞是小 Y 的好朋友，每天她都会从中拿走一些苹果。\n\n每天在拿的时候，小苞都是从左侧第 $1$ 个苹果开始、每隔 $2$ 个苹果拿走 $1$ 个苹果。随后小苞会将剩下的苹果按原先的顺序重新排成一列。\n\n小苞想知道，多少天能拿完所有的苹果，而编号为 $n$ 的苹果是在第几天被拿走的？", "inputFormat": "输入的第一行包含一个正整数 $n$，表示苹果的总数。", "outputFormat": "输出一行包含两个正整数，两个整数之间由一个空格隔开，分别表示小苞拿走所有苹果所需的天数以及拿走编号为 $n$ 的苹果是在第几天。", "hint": "**【样例 $1$ 解释】**\n\n小苞的桌上一共放了 $8$ 个苹果。  \n小苞第一天拿走了编号为 $1$、$4$、$7$ 的苹果。  \n小苞第二天拿走了编号为 $2$、$6$ 的苹果。  \n小苞第三天拿走了编号为 $3$ 的苹果。  \n小苞第四天拿走了编号为 $5$ 的苹果。  \n小苞第五天拿走了编号为 $8$ 的苹果。  \n\n**【样例 $2$】**\n\n见选手目录下的 apple/apple2.in 与 apple/apple2.ans。\n\n**【数据范围】**\n\n对于所有测试数据有：$1\\leq n\\leq 10^9$。\n\n| 测试点 | $n\\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1\\sim 2$ | $10$ | 无 |\n| $3\\sim 5$ | $10^3$ | 无 |\n| $6\\sim 7$ | $10^6$ | 有 |\n| $8\\sim 9$ | $10^6$ | 无 |\n| $10$ | $10^9$ | 无 |\n\n特殊性质：小苞第一天就取走编号为 $n$ 的苹果。", "locale": "zh-CN"}}}
{"pid": "P9749", "type": "P", "difficulty": 2, "samples": [["5 4\n10 10 10 10\n9 8 9 6 5", "79"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "贪心", "2023", "O2优化", "前缀和", "CSP-J 入门级", "反悔贪心"], "title": "[CSP-J 2023] 公路", "background": "", "description": "小苞准备开着车沿着公路自驾。\n\n公路上一共有 $n$ 个站点，编号为从 $1$ 到 $n$。其中站点 $i$ 与站点 $i + 1$ 的距离为 $v_i$ 公里。\n\n公路上每个站点都可以加油，编号为 $i$ 的站点一升油的价格为 $a_i$ 元，且每个站点只出售整数升的油。\n\n小苞想从站点 $1$ 开车到站点 $n$，一开始小苞在站点 $1$ 且车的油箱是空的。已知车的油箱足够大，可以装下任意多的油，且每升油可以让车前进 $d$ 公里。问小苞从站点 $1$ 开到站点 $n$，至少要花多少钱加油？", "inputFormat": "输入的第一行包含两个正整数 $n$ 和 $d$，分别表示公路上站点的数量和车每升油可以前进的距离。\n\n输入的第二行包含 $n - 1$ 个正整数 $v_1, v_2\\dots v_{n-1}$，分别表示站点间的距离。\n\n输入的第三行包含 $n$ 个正整数 $a_1, a_2 \\dots a_n$，分别表示在不同站点加油的价格。", "outputFormat": "输出一行，仅包含一个正整数，表示从站点 $1$ 开到站点 $n$，小苞至少要花多少钱加油。", "hint": "**【样例 1 解释】**\n\n最优方案下：小苞在站点 $1$ 买了 $3$ 升油，在站点 $2$ 购买了 $5$ 升油，在站点 $4$ 购买了 $2$ 升油。\n\n**【样例 2】**\n\n见选手目录下的 `road/road2.in` 与 `road/road2.ans`。\n\n**【数据范围】**\n\n对于所有测试数据保证：$1 \\leq n \\leq 10^5$，$1 \\leq d \\leq 10^5$，$1 \\leq v_i \\leq 10^5$，$1 \\leq a_i \\leq 10^5$。\n\n::cute-table{tuack}\n\n| 测试点 | $n \\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1\\sim 5$ | $8$ | 无 |\n| $6\\sim 10$ | $10^3$ | ^ |\n| $11\\sim 13$ | $10^5$ | A |\n| $14\\sim 16$ | ^ | B |\n| $17\\sim 20$ | ^ | 无 |\n\n- 特殊性质 A：站点 $1$ 的油价最低。\n- 特殊性质 B：对于所有 $1 \\leq i < n$，$v_i$ 为 $d$ 的倍数。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-J 2023] 公路", "background": "", "description": "小苞准备开着车沿着公路自驾。\n\n公路上一共有 $n$ 个站点，编号为从 $1$ 到 $n$。其中站点 $i$ 与站点 $i + 1$ 的距离为 $v_i$ 公里。\n\n公路上每个站点都可以加油，编号为 $i$ 的站点一升油的价格为 $a_i$ 元，且每个站点只出售整数升的油。\n\n小苞想从站点 $1$ 开车到站点 $n$，一开始小苞在站点 $1$ 且车的油箱是空的。已知车的油箱足够大，可以装下任意多的油，且每升油可以让车前进 $d$ 公里。问小苞从站点 $1$ 开到站点 $n$，至少要花多少钱加油？", "inputFormat": "输入的第一行包含两个正整数 $n$ 和 $d$，分别表示公路上站点的数量和车每升油可以前进的距离。\n\n输入的第二行包含 $n - 1$ 个正整数 $v_1, v_2\\dots v_{n-1}$，分别表示站点间的距离。\n\n输入的第三行包含 $n$ 个正整数 $a_1, a_2 \\dots a_n$，分别表示在不同站点加油的价格。", "outputFormat": "输出一行，仅包含一个正整数，表示从站点 $1$ 开到站点 $n$，小苞至少要花多少钱加油。", "hint": "**【样例 1 解释】**\n\n最优方案下：小苞在站点 $1$ 买了 $3$ 升油，在站点 $2$ 购买了 $5$ 升油，在站点 $4$ 购买了 $2$ 升油。\n\n**【样例 2】**\n\n见选手目录下的 `road/road2.in` 与 `road/road2.ans`。\n\n**【数据范围】**\n\n对于所有测试数据保证：$1 \\leq n \\leq 10^5$，$1 \\leq d \\leq 10^5$，$1 \\leq v_i \\leq 10^5$，$1 \\leq a_i \\leq 10^5$。\n\n::cute-table{tuack}\n\n| 测试点 | $n \\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1\\sim 5$ | $8$ | 无 |\n| $6\\sim 10$ | $10^3$ | ^ |\n| $11\\sim 13$ | $10^5$ | A |\n| $14\\sim 16$ | ^ | B |\n| $17\\sim 20$ | ^ | 无 |\n\n- 特殊性质 A：站点 $1$ 的油价最低。\n- 特殊性质 B：对于所有 $1 \\leq i < n$，$v_i$ 为 $d$ 的倍数。", "locale": "zh-CN"}}}
{"pid": "P9750", "type": "P", "difficulty": 3, "samples": [["9 1000\n1 -1 0\n-1 -1 -1\n1 -2 1\n1 5 4\n4 4 1\n1 0 -432\n1 -3 1\n2 -4 1\n1 7 1", "1\nNO\n1\n-1\n-1/2\n12*sqrt(3)\n3/2+sqrt(5)/2\n1+sqrt(2)/2\n-7/2+3*sqrt(5)/2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "数学", "2023", "O2优化", "CSP-J 入门级"], "title": "[CSP-J 2023] 一元二次方程", "background": "众所周知，对一元二次方程 $ax ^ 2 + bx + c = 0(a \\neq 0)$，可以用以下方式求实数解：\n\n- 计算 $\\Delta = b ^ 2 - 4ac$，则:\n\t1. 若 $\\Delta < 0$，则该一元二次方程无实数解。\n  \t2. 否则 $\\Delta \\geq 0$，此时该一元二次方程有两个实数解 $x _ {1, 2} = \\frac{-b \\pm \\sqrt \\Delta}{2a}$。\n \n例如：\n\n- $x ^ 2 + x + 1 = 0$ 无实数解，因为 $\\Delta = 1 ^ 2 - 4 \\times 1 \\times 1 = -3 < 0$。\n- $x ^ 2 - 2x + 1 = 0$ 有两相等实数解 $x _ {1, 2} = 1$。\n- $x ^ 2 - 3x + 2 = 0$ 有两互异实数解 $x _ 1 = 1, x _ 2 = 2$。\n\n在题面描述中 $a$ 和 $b$ 的最大公因数使用 $\\gcd(a, b)$ 表示。例如 $12$ 和 $18$ 的最大公因数是 $6$，即 $\\gcd(12, 18) = 6$。", "description": "现在给定一个一元二次方程的系数 $a, b, c$，其中 $a, b, c$ **均为整数且 $a \\neq 0$**。你需要判断一元二次方程 $a x ^ 2 + bx + c = 0$ 是否有实数解，并按要求的格式输出。\n\n**在本题中输出有理数 $v$ 时须遵循以下规则：**\n\n- 由有理数的定义，存在唯一的两个整数 $p$ 和 $q$，满足 $q > 0$，$\\gcd(p, q) = 1$ 且 $v = \\frac pq$。\n- 若 $q = 1$，**则输出 `{p}`，否则输出 `{p}/{q}`**，其中 `{n}` 代表整数 $n$ 的值；\n- 例如：\n\n\t- 当 $v = -0.5$ 时，$p$ 和 $q$ 的值分别为 $-1$ 和 $2$，则应输出 `-1/2`；\n   - 当 $v = 0$ 时，$p$ 和 $q$ 的值分别为 $0$ 和 $1$，则应输出 `0`。\n   \n**对于方程的求解，分两种情况讨论：**\n\n1. 若 $\\Delta = b ^ 2 - 4ac < 0$，则表明方程无实数解，此时你应当输出 `NO`；\n2. 否则 $\\Delta \\geq 0$，此时方程有两解（可能相等），记其中较大者为 $x$，则：\n\t1. 若 $x$ 为有理数，则按有理数的格式输出 $x$。\n   2. 否则根据上文公式，$x$ 可以被**唯一**表示为 $x = q _ 1 + q _ 2 \\sqrt r$ 的形式，其中：\n   \n   \t\t- $q _ 1, q _ 2$ 为有理数，且 $q _ 2 > 0$；\n      - $r$ 为正整数且 $r > 1$，且不存在正整数 $d > 1$ 使 $d ^ 2 \\mid r$（即 $r$ 不应是 $d ^ 2$ 的倍数）；\n   \n   此时：\n   \n   1. 若 $q _ 1 \\neq 0$，则按有理数的格式输出 $q _ 1$，并再输出一个加号 `+`；\n   2. 否则跳过这一步输出；\n   \n   随后：\n   \n   1. 若 $q _ 2 = 1$，则输出 `sqrt({r})`；\n   2. 否则若 $q _ 2$ 为整数，则输出 `{q2}*sqrt({r})`；\n   3. 否则若 $q _ 3 = \\frac 1{q _ 2}$ 为整数，则输出 `sqrt({r})/{q3}`；\n   4. 否则可以证明存在唯一整数 $c, d$ 满足 $c, d > 1, \\gcd(c, d) = 1$ 且 $q _ 2 = \\frac cd$，此时输出 `{c}*sqrt({r})/{d}`；\n   \n   上述表示中 `{n}` 代表整数 `{n}` 的值，详见样例。\n   \n   如果方程有实数解，则按要求的格式输出两个实数解中的较大者。否则若方程没有实数解，则输出 `NO`。", "inputFormat": "输入的第一行包含两个正整数 $T, M$，分别表示方程数和系数的绝对值上限。\n\n接下来 $T$ 行，每行包含三个整数 $a, b, c$。", "outputFormat": "输出 $T$ 行，每行包含一个字符串，表示对应询问的答案，格式如题面所述。\n\n**每行输出的字符串中间不应包含任何空格**。", "hint": "**【样例 #2】**\n\n见附件中的 `uqe/uqe2.in` 与 `uqe/uqe2.ans`。\n\n**【数据范围】**\n\n对于所有数据有：$1 \\leq T \\leq 5000$，$1 \\leq M \\leq 10 ^ 3$，$|a|,|b|,|c| \\leq M$，$a \\neq 0$。\n\n| 测试点编号 | $M \\leq$ | 特殊性质 A | 特殊性质 B | 特殊性质 C |\n| :-: | :-: | :-: | :-:| :-:|\n| $1$ | $1$ | 是 | 是 | 是 |\n| $2$ | $20$ | 否 | 否 | 否 |\n| $3$ | $10 ^ 3$ | 是 | 否 | 是 |\n| $4$ | $10 ^ 3$  | 是 | 否 | 否 |\n| $5$ | $10 ^ 3$  | 否 | 是 | 是 |\n| $6$ | $10 ^ 3$  | 否 | 是 | 否 |\n| $7, 8$ | $10 ^ 3$  | 否 | 否 | 是 |\n| $9, 10$ | $10 ^ 3$  | 否 | 否 | 否 |\n\n其中：\n\n- 特殊性质 A：保证 $b = 0$；\n- 特殊性质 B：保证 $c = 0$；\n- 特殊性质 C：如果方程有解，那么方程的两个解都是整数。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-J 2023] 一元二次方程", "background": "众所周知，对一元二次方程 $ax ^ 2 + bx + c = 0(a \\neq 0)$，可以用以下方式求实数解：\n\n- 计算 $\\Delta = b ^ 2 - 4ac$，则:\n\t1. 若 $\\Delta < 0$，则该一元二次方程无实数解。\n  \t2. 否则 $\\Delta \\geq 0$，此时该一元二次方程有两个实数解 $x _ {1, 2} = \\frac{-b \\pm \\sqrt \\Delta}{2a}$。\n \n例如：\n\n- $x ^ 2 + x + 1 = 0$ 无实数解，因为 $\\Delta = 1 ^ 2 - 4 \\times 1 \\times 1 = -3 < 0$。\n- $x ^ 2 - 2x + 1 = 0$ 有两相等实数解 $x _ {1, 2} = 1$。\n- $x ^ 2 - 3x + 2 = 0$ 有两互异实数解 $x _ 1 = 1, x _ 2 = 2$。\n\n在题面描述中 $a$ 和 $b$ 的最大公因数使用 $\\gcd(a, b)$ 表示。例如 $12$ 和 $18$ 的最大公因数是 $6$，即 $\\gcd(12, 18) = 6$。", "description": "现在给定一个一元二次方程的系数 $a, b, c$，其中 $a, b, c$ **均为整数且 $a \\neq 0$**。你需要判断一元二次方程 $a x ^ 2 + bx + c = 0$ 是否有实数解，并按要求的格式输出。\n\n**在本题中输出有理数 $v$ 时须遵循以下规则：**\n\n- 由有理数的定义，存在唯一的两个整数 $p$ 和 $q$，满足 $q > 0$，$\\gcd(p, q) = 1$ 且 $v = \\frac pq$。\n- 若 $q = 1$，**则输出 `{p}`，否则输出 `{p}/{q}`**，其中 `{n}` 代表整数 $n$ 的值；\n- 例如：\n\n\t- 当 $v = -0.5$ 时，$p$ 和 $q$ 的值分别为 $-1$ 和 $2$，则应输出 `-1/2`；\n   - 当 $v = 0$ 时，$p$ 和 $q$ 的值分别为 $0$ 和 $1$，则应输出 `0`。\n   \n**对于方程的求解，分两种情况讨论：**\n\n1. 若 $\\Delta = b ^ 2 - 4ac < 0$，则表明方程无实数解，此时你应当输出 `NO`；\n2. 否则 $\\Delta \\geq 0$，此时方程有两解（可能相等），记其中较大者为 $x$，则：\n\t1. 若 $x$ 为有理数，则按有理数的格式输出 $x$。\n   2. 否则根据上文公式，$x$ 可以被**唯一**表示为 $x = q _ 1 + q _ 2 \\sqrt r$ 的形式，其中：\n   \n   \t\t- $q _ 1, q _ 2$ 为有理数，且 $q _ 2 > 0$；\n      - $r$ 为正整数且 $r > 1$，且不存在正整数 $d > 1$ 使 $d ^ 2 \\mid r$（即 $r$ 不应是 $d ^ 2$ 的倍数）；\n   \n   此时：\n   \n   1. 若 $q _ 1 \\neq 0$，则按有理数的格式输出 $q _ 1$，并再输出一个加号 `+`；\n   2. 否则跳过这一步输出；\n   \n   随后：\n   \n   1. 若 $q _ 2 = 1$，则输出 `sqrt({r})`；\n   2. 否则若 $q _ 2$ 为整数，则输出 `{q2}*sqrt({r})`；\n   3. 否则若 $q _ 3 = \\frac 1{q _ 2}$ 为整数，则输出 `sqrt({r})/{q3}`；\n   4. 否则可以证明存在唯一整数 $c, d$ 满足 $c, d > 1, \\gcd(c, d) = 1$ 且 $q _ 2 = \\frac cd$，此时输出 `{c}*sqrt({r})/{d}`；\n   \n   上述表示中 `{n}` 代表整数 `{n}` 的值，详见样例。\n   \n   如果方程有实数解，则按要求的格式输出两个实数解中的较大者。否则若方程没有实数解，则输出 `NO`。", "inputFormat": "输入的第一行包含两个正整数 $T, M$，分别表示方程数和系数的绝对值上限。\n\n接下来 $T$ 行，每行包含三个整数 $a, b, c$。", "outputFormat": "输出 $T$ 行，每行包含一个字符串，表示对应询问的答案，格式如题面所述。\n\n**每行输出的字符串中间不应包含任何空格**。", "hint": "**【样例 #2】**\n\n见附件中的 `uqe/uqe2.in` 与 `uqe/uqe2.ans`。\n\n**【数据范围】**\n\n对于所有数据有：$1 \\leq T \\leq 5000$，$1 \\leq M \\leq 10 ^ 3$，$|a|,|b|,|c| \\leq M$，$a \\neq 0$。\n\n| 测试点编号 | $M \\leq$ | 特殊性质 A | 特殊性质 B | 特殊性质 C |\n| :-: | :-: | :-: | :-:| :-:|\n| $1$ | $1$ | 是 | 是 | 是 |\n| $2$ | $20$ | 否 | 否 | 否 |\n| $3$ | $10 ^ 3$ | 是 | 否 | 是 |\n| $4$ | $10 ^ 3$  | 是 | 否 | 否 |\n| $5$ | $10 ^ 3$  | 否 | 是 | 是 |\n| $6$ | $10 ^ 3$  | 否 | 是 | 否 |\n| $7, 8$ | $10 ^ 3$  | 否 | 否 | 是 |\n| $9, 10$ | $10 ^ 3$  | 否 | 否 | 否 |\n\n其中：\n\n- 特殊性质 A：保证 $b = 0$；\n- 特殊性质 B：保证 $c = 0$；\n- 特殊性质 C：如果方程有解，那么方程的两个解都是整数。", "locale": "zh-CN"}}}
{"pid": "P9751", "type": "P", "difficulty": 4, "samples": [["5 5 3\n1 2 0\n2 5 1\n1 3 0\n3 4 3\n4 5 1", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["图论", "二分", "2023", "O2优化", "广度优先搜索 BFS", "图论建模", "最短路", "CSP-J 入门级"], "title": "[CSP-J 2023] 旅游巴士", "background": null, "description": "小 Z 打算在国庆假期期间搭乘旅游巴士去一处他向往已久的景点旅游。\n\n旅游景点的地图共有 $n$ 处地点，在这些地点之间连有 $m$ 条道路。其中 $1$ 号地点为景区入口，$n$ 号地点为景区出口。我们把一天当中景区开门营业的时间记为 $0$ 时刻，则从 $0$ 时刻起，每间隔 $k$ 单位时间便有一辆旅游巴士到达景区入口，同时有一辆旅游巴士从景区出口驶离景区。\n\n所有道路均只能**单向通行**。对于每条道路，游客步行通过的用时均为恰好 $1$ 单位时间。\n\n小 Z 希望乘坐旅游巴士到达景区入口，并沿着自己选择的任意路径走到景区出口，再乘坐旅游巴士离开，这意味着他到达和离开景区的时间都必须是 **$k$ 的非负整数倍**。由于节假日客流众多，**小 Z 在旅游巴士离开景区前只想一直沿着景区道路移动，而不想在任何地点（包括景区入口和出口）或者道路上停留**。\n\n出发前，小 Z 忽然得知：景区采取了限制客流的方法，对于每条道路均设置了一个\n“开放时间”$a _ i$，游客只有**不早于 $a _ i$ 时刻**才能通过这条道路。\n\n请帮助小 Z 设计一个旅游方案，使得他乘坐旅游巴士离开景区的时间尽量地早。", "inputFormat": "输入的第一行包含 $3$ 个正整数 $n, m, k$，表示旅游景点的地点数、道路数，以及旅游巴士的发车间隔。\n\n输入的接下来 $m$ 行，每行包含 $3$ 个非负整数 $u _ i, v _ i, a_ i$，表示第 $i$ 条道路从地点 $u _ i$ 出发，到达地点 $v _ i$，道路的“开放时间”为 $a _ i$。", "outputFormat": "输出一行，仅包含一个整数，表示小 Z 最早乘坐旅游巴士离开景区的时刻。如果不存在符合要求的旅游方案，输出 `-1`。", "hint": "**【样例 #1 解释】**\n\n小 Z 可以在 $3$ 时刻到达景区入口，沿 $1 \\to 3 \\to 4 \\to 5$ 的顺序走到景区出口，并在 $6$ 时刻离开。\n\n**【样例 #2】**\n\n见附件中的 `bus/bus2.in` 与 `bus/bus2.ans`。\n\n**【数据范围】**\n\n对于所有测试数据有：$2 \\leq n \\leq 10 ^ 4$，$1 \\leq m \\leq 2 \\times 10 ^ 4$，$1 \\leq k \\leq 100$，$1 \\leq u _ i, v _ i \\leq n$，$0 \\leq a _ i \\leq 10 ^ 6$。\n\n| 测试点编号 | $n \\leq$ | $m \\leq$ | $k \\leq$ | 特殊性质 |\n|:-:|:-:|:-:|:-:|:-:|\n| $1 \\sim 2$ | $10$ |$15$ | $100$ | $a _ i = 0$ |\n| $3 \\sim 5$ | $10$ | $15$ | $100$ | 无 |\n| $6 \\sim 7$ | $10 ^ 4$ | $2 \\times 10 ^ 4$ | $1$ | $a _ i = 0$ |\n| $8 \\sim 10$ | $10 ^ 4$ | $2 \\times 10 ^ 4$ | $1$ | 无 |\n| $11 \\sim 13$ | $10 ^ 4$ | $2 \\times 10 ^ 4$ | $100$ | $a _ i = 0$ |\n| $14 \\sim 15$ | $10 ^ 4$ | $2 \\times 10 ^ 4$ | $100$ | $u _ i \\leq v _ i$ |\n| $16 \\sim 20$ | $10 ^ 4$ | $2 \\times 10 ^ 4$ | $100$ | 无 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-J 2023] 旅游巴士", "background": null, "description": "小 Z 打算在国庆假期期间搭乘旅游巴士去一处他向往已久的景点旅游。\n\n旅游景点的地图共有 $n$ 处地点，在这些地点之间连有 $m$ 条道路。其中 $1$ 号地点为景区入口，$n$ 号地点为景区出口。我们把一天当中景区开门营业的时间记为 $0$ 时刻，则从 $0$ 时刻起，每间隔 $k$ 单位时间便有一辆旅游巴士到达景区入口，同时有一辆旅游巴士从景区出口驶离景区。\n\n所有道路均只能**单向通行**。对于每条道路，游客步行通过的用时均为恰好 $1$ 单位时间。\n\n小 Z 希望乘坐旅游巴士到达景区入口，并沿着自己选择的任意路径走到景区出口，再乘坐旅游巴士离开，这意味着他到达和离开景区的时间都必须是 **$k$ 的非负整数倍**。由于节假日客流众多，**小 Z 在旅游巴士离开景区前只想一直沿着景区道路移动，而不想在任何地点（包括景区入口和出口）或者道路上停留**。\n\n出发前，小 Z 忽然得知：景区采取了限制客流的方法，对于每条道路均设置了一个\n“开放时间”$a _ i$，游客只有**不早于 $a _ i$ 时刻**才能通过这条道路。\n\n请帮助小 Z 设计一个旅游方案，使得他乘坐旅游巴士离开景区的时间尽量地早。", "inputFormat": "输入的第一行包含 $3$ 个正整数 $n, m, k$，表示旅游景点的地点数、道路数，以及旅游巴士的发车间隔。\n\n输入的接下来 $m$ 行，每行包含 $3$ 个非负整数 $u _ i, v _ i, a_ i$，表示第 $i$ 条道路从地点 $u _ i$ 出发，到达地点 $v _ i$，道路的“开放时间”为 $a _ i$。", "outputFormat": "输出一行，仅包含一个整数，表示小 Z 最早乘坐旅游巴士离开景区的时刻。如果不存在符合要求的旅游方案，输出 `-1`。", "hint": "**【样例 #1 解释】**\n\n小 Z 可以在 $3$ 时刻到达景区入口，沿 $1 \\to 3 \\to 4 \\to 5$ 的顺序走到景区出口，并在 $6$ 时刻离开。\n\n**【样例 #2】**\n\n见附件中的 `bus/bus2.in` 与 `bus/bus2.ans`。\n\n**【数据范围】**\n\n对于所有测试数据有：$2 \\leq n \\leq 10 ^ 4$，$1 \\leq m \\leq 2 \\times 10 ^ 4$，$1 \\leq k \\leq 100$，$1 \\leq u _ i, v _ i \\leq n$，$0 \\leq a _ i \\leq 10 ^ 6$。\n\n| 测试点编号 | $n \\leq$ | $m \\leq$ | $k \\leq$ | 特殊性质 |\n|:-:|:-:|:-:|:-:|:-:|\n| $1 \\sim 2$ | $10$ |$15$ | $100$ | $a _ i = 0$ |\n| $3 \\sim 5$ | $10$ | $15$ | $100$ | 无 |\n| $6 \\sim 7$ | $10 ^ 4$ | $2 \\times 10 ^ 4$ | $1$ | $a _ i = 0$ |\n| $8 \\sim 10$ | $10 ^ 4$ | $2 \\times 10 ^ 4$ | $1$ | 无 |\n| $11 \\sim 13$ | $10 ^ 4$ | $2 \\times 10 ^ 4$ | $100$ | $a _ i = 0$ |\n| $14 \\sim 15$ | $10 ^ 4$ | $2 \\times 10 ^ 4$ | $100$ | $u _ i \\leq v _ i$ |\n| $16 \\sim 20$ | $10 ^ 4$ | $2 \\times 10 ^ 4$ | $100$ | 无 |", "locale": "zh-CN"}}}
{"pid": "P9752", "type": "P", "difficulty": 2, "samples": [["1\n0 0 1 1 5", "81"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2023", "O2优化", "枚举", "CSP-S 提高级"], "title": "[CSP-S 2023] 密码锁", "background": "", "description": "小 Y 有一把五个拨圈的密码锁。如图所示，每个拨圈上是从 $0$ 到 $9$ 的数字。每个拨圈都是从 $0$ 到 $9$ 的循环，即 $9$ 拨动一个位置后可以变成 $0$ 或 $8$，\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/aku4duog.png)\n\n因为校园里比较安全，小 Y 采用的锁车方式是：从正确密码开始，随机转动密码锁仅一次；每次都是以某个幅度仅转动一个拨圈或者同时转动两个相邻的拨圈。\n\n当小 Y 选择同时转动两个相邻拨圈时，两个拨圈转动的幅度相同，即小 Y 可以将密码锁从 $\\tt{0\\;0\\;1\\;1\\;5}$ 转成 $\\tt{1\\;1\\;1\\;1\\;5}$，但不会转成 $\\tt{1\\;2\\;1\\;1\\;5}$。\n\n时间久了，小 Y 也担心这么锁车的安全性，所以小 Y 记下了自己锁车后密码锁的 $n$ 个状态，注意这 $n$ 个状态都不是正确密码。\n\n为了检验这么锁车的安全性，小 Y 有多少种可能的正确密码，使得每个正确密码都能够按照他所采用的锁车方式产生锁车后密码锁的全部 $n$ 个状态。", "inputFormat": "输入的第一行包含一个正整数 $n$，表示锁车后密码锁的状态数。\n\n接下来 $n$ 行每行包含五个整数，表示一个密码锁的状态。", "outputFormat": "输出一行包含一个整数，表示密码锁的这 $n$ 个状态按照给定的锁车方式能对应多少种正确密码。", "hint": "**【样例 1 解释】**\n\n一共有 $81$ 种可能的方案。\n\n其中转动一个拨圈的方案有 $45$ 种，转动两个拨圈的方案有 $36$ 种。\n\n**【样例 2】**\n\n见选手目录下的 lock/lock2.in 与 lock/lock2.ans。\n\n**【数据范围】**\n\n对于所有测试数据有：$1 \\leq n \\leq 8$。\n\n| 测试点 | $n\\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1\\sim 3$ | $1$ | 无 |\n| $4\\sim 5$ | $2$ | 无 |\n| $6\\sim 8$ | $8$ | A |\n| $9\\sim 10$ | $8$ | 无 |\n\n特殊性质 A：保证所有正确密码都可以通过仅转动一个拨圈得到测试数据给出的 $n$ 个状态。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-S 2023] 密码锁", "background": "", "description": "小 Y 有一把五个拨圈的密码锁。如图所示，每个拨圈上是从 $0$ 到 $9$ 的数字。每个拨圈都是从 $0$ 到 $9$ 的循环，即 $9$ 拨动一个位置后可以变成 $0$ 或 $8$，\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/aku4duog.png)\n\n因为校园里比较安全，小 Y 采用的锁车方式是：从正确密码开始，随机转动密码锁仅一次；每次都是以某个幅度仅转动一个拨圈或者同时转动两个相邻的拨圈。\n\n当小 Y 选择同时转动两个相邻拨圈时，两个拨圈转动的幅度相同，即小 Y 可以将密码锁从 $\\tt{0\\;0\\;1\\;1\\;5}$ 转成 $\\tt{1\\;1\\;1\\;1\\;5}$，但不会转成 $\\tt{1\\;2\\;1\\;1\\;5}$。\n\n时间久了，小 Y 也担心这么锁车的安全性，所以小 Y 记下了自己锁车后密码锁的 $n$ 个状态，注意这 $n$ 个状态都不是正确密码。\n\n为了检验这么锁车的安全性，小 Y 有多少种可能的正确密码，使得每个正确密码都能够按照他所采用的锁车方式产生锁车后密码锁的全部 $n$ 个状态。", "inputFormat": "输入的第一行包含一个正整数 $n$，表示锁车后密码锁的状态数。\n\n接下来 $n$ 行每行包含五个整数，表示一个密码锁的状态。", "outputFormat": "输出一行包含一个整数，表示密码锁的这 $n$ 个状态按照给定的锁车方式能对应多少种正确密码。", "hint": "**【样例 1 解释】**\n\n一共有 $81$ 种可能的方案。\n\n其中转动一个拨圈的方案有 $45$ 种，转动两个拨圈的方案有 $36$ 种。\n\n**【样例 2】**\n\n见选手目录下的 lock/lock2.in 与 lock/lock2.ans。\n\n**【数据范围】**\n\n对于所有测试数据有：$1 \\leq n \\leq 8$。\n\n| 测试点 | $n\\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1\\sim 3$ | $1$ | 无 |\n| $4\\sim 5$ | $2$ | 无 |\n| $6\\sim 8$ | $8$ | A |\n| $9\\sim 10$ | $8$ | 无 |\n\n特殊性质 A：保证所有正确密码都可以通过仅转动一个拨圈得到测试数据给出的 $n$ 个状态。", "locale": "zh-CN"}}}
{"pid": "P9753", "type": "P", "difficulty": 5, "samples": [["8\naccabccb\n", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2023", "O2优化", "哈希 hashing", "栈", "CSP-S 提高级"], "title": "[CSP-S 2023] 消消乐", "background": "", "description": "小 L 现在在玩一个低配版本的消消乐，该版本的游戏是一维的，一次也只能消除两个相邻的元素。\n\n现在，他有一个长度为 $n$ 且仅由小写字母构成的字符串。我们称一个字符串是可消除的，当且仅当可以对这个字符串进行若干次操作，使之成为一个空字符串。\n\n其中每次操作可以从字符串中删除两个相邻的相同字符，操作后剩余字符串会拼接在一起。\n\n小 L 想知道，这个字符串的所有非空连续子串中，有多少个是可消除的。", "inputFormat": "输入的第一行包含一个正整数 $n$，表示字符串的长度。\n\n输入的第二行包含一个长度为 $n$ 且仅由小写字母构成的的字符串，表示题目中询问的字符串。", "outputFormat": "输出一行包含一个整数，表示题目询问的答案。", "hint": "**【样例 1 解释】**\n\n一共有 $5$ 个可消除的连续子串，分别是 `cc`、`acca`、`cc`、`bccb`、`accabccb`。\n\n**【样例 2】**\n\n见选手目录下的 `game/game2.in` 与 `game/game2.ans`。\n\n**【样例 3】**\n\n见选手目录下的 `game/game3.in` 与 `game/game3.ans`。\n\n**【样例 4】**\n\n见选手目录下的 `game/game4.in` 与 `game/game4.ans`。\n\n**【数据范围】**\n\n对于所有测试数据有：$1 \\le n \\le 2 \\times 10^6$，且询问的字符串仅由小写字母构成。\n\n| 测试点 | $n\\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1\\sim 5$ | $10$ | 无 |\n| $6\\sim 7$ | $800$ | 无 |\n| $8\\sim 10$ | $8000$ | 无 |\n| $11\\sim 12$ | $2\\times 10^5$ | A |\n| $13\\sim 14$ | $2\\times 10^5$ | B |\n| $15\\sim 17$ | $2\\times 10^5$ | 无 |\n| $18\\sim 20$ | $2\\times 10^6$ | 无 |\n\n特殊性质 A：字符串中的每个字符独立等概率地从字符集中选择。\n\n特殊性质 B：字符串仅由 `a` 和 `b` 构成。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-S 2023] 消消乐", "background": "", "description": "小 L 现在在玩一个低配版本的消消乐，该版本的游戏是一维的，一次也只能消除两个相邻的元素。\n\n现在，他有一个长度为 $n$ 且仅由小写字母构成的字符串。我们称一个字符串是可消除的，当且仅当可以对这个字符串进行若干次操作，使之成为一个空字符串。\n\n其中每次操作可以从字符串中删除两个相邻的相同字符，操作后剩余字符串会拼接在一起。\n\n小 L 想知道，这个字符串的所有非空连续子串中，有多少个是可消除的。", "inputFormat": "输入的第一行包含一个正整数 $n$，表示字符串的长度。\n\n输入的第二行包含一个长度为 $n$ 且仅由小写字母构成的的字符串，表示题目中询问的字符串。", "outputFormat": "输出一行包含一个整数，表示题目询问的答案。", "hint": "**【样例 1 解释】**\n\n一共有 $5$ 个可消除的连续子串，分别是 `cc`、`acca`、`cc`、`bccb`、`accabccb`。\n\n**【样例 2】**\n\n见选手目录下的 `game/game2.in` 与 `game/game2.ans`。\n\n**【样例 3】**\n\n见选手目录下的 `game/game3.in` 与 `game/game3.ans`。\n\n**【样例 4】**\n\n见选手目录下的 `game/game4.in` 与 `game/game4.ans`。\n\n**【数据范围】**\n\n对于所有测试数据有：$1 \\le n \\le 2 \\times 10^6$，且询问的字符串仅由小写字母构成。\n\n| 测试点 | $n\\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1\\sim 5$ | $10$ | 无 |\n| $6\\sim 7$ | $800$ | 无 |\n| $8\\sim 10$ | $8000$ | 无 |\n| $11\\sim 12$ | $2\\times 10^5$ | A |\n| $13\\sim 14$ | $2\\times 10^5$ | B |\n| $15\\sim 17$ | $2\\times 10^5$ | 无 |\n| $18\\sim 20$ | $2\\times 10^6$ | 无 |\n\n特殊性质 A：字符串中的每个字符独立等概率地从字符集中选择。\n\n特殊性质 B：字符串仅由 `a` 和 `b` 构成。", "locale": "zh-CN"}}}
{"pid": "P9754", "type": "P", "difficulty": 5, "samples": [["5\n1 a 2\nshort aa\nint ab\n1 b 2\na ba\nlong bb\n2 b x\n3 x.ba.ab\n4 10", "8 4\n16 8\n0\n4\nx.bb"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2023", "O2优化", "CSP-S 提高级"], "title": "[CSP-S 2023] 结构体", "background": "在 C++ 等高级语言中，除了 int 和 float 等基本类型外，通常还可以自定义结构体类型。在本题当中，你需要模拟一种类似 C++ 的高级语言的结构体定义方式，并计算出相应的内存占用等信息。", "description": "在这种语言中，基本类型共有 $4$ 种：`byte`、`short`、`int`、`long`，分别占据 $1$、$2$、$4$、$8$ 字节的空间。\n\n定义一个结构体**类型**时，需要给出**类型名**和**成员**，其中每个成员需要按顺序给出**类型**和**名称**。类型可以为基本类型，也可以为**先前定义过**的结构体类型。注意，定义结构体**类型**时不会定义具体元素，即不占用内存。\n\n定义一个**元素**时，需要给出元素的**类型**和**名称**。元素将按照以下规则占据内存：\n\n- 元素内的所有成员将按照**定义时给出的顺序**在内存中排布，对于类型为结构体的成员同理。\n- 为了保证内存访问的效率，元素的地址占用需要满足**对齐规则**，即任何类型的**大小**和该类型元素在内存中的**起始地址**均应对齐到该类型对齐要求的**整数倍**。具体而言：\n  - 对于基本类型：对齐要求等于其占据空间大小，如 `int` 类型需要对齐到 $4$ 字节，其余同理。\n  - 对于结构体类型：对齐要求等于其成员的对齐要求的**最大值**，如一个含有 `int` 和 `short` 的结构体类型需要对齐到 $4$ 字节。\n\n以下是一个例子（以 C++ 语言的格式书写）：\n\n```cpp\nstruct d {\n    short a;\n    int b;\n    short c;\n};\nd e;\n```\n\n该代码定义了结构体类型 `d` 与元素 `e`。元素 `e` 包含三个成员 `e.a`、`e.b`、`e.c`，分别占据第 $0 \\sim 1$、$4 \\sim 7$、$8 \\sim 9$ 字节的地址。由于类型 `d` 需要对齐到 $4$ 字节，因此 `e` 占据了第 $0 \\sim 11$ 字节的地址，大小为 $12$ 字节。\n\n你需要处理 $n$ 次操作，每次操作为以下四种之一：\n\n1. 定义一个结构体类型。具体而言，给定正整数 $k$ 与字符串 $s, t_1, n_1, \\dots, t_k, n_k$，其中 $k$ 表示该类型的成员数量，$s$ 表示该类型的类型名，$t_1, t_2, \\dots, t_k$ 按顺序分别表示每个成员的类型，$n_1, n_2, \\dots, n_k$ 按顺序分别表示每个成员的名称。你需要输出该结构体类型的大小和对齐要求，用一个空格分隔。\n\n2. 定义一个元素，具体而言，给定字符串 $t, n$ 分别表示该元素的类型与名称。所有被定义的元素将按顺序，从内存地址为 $0$ 开始依次排开，并需要满足地址对齐规则。你需要输出新定义的元素的起始地址。\n\n3. 访问某个元素。具体而言，给定字符串 $s$，表示所访问的元素。与 C++ 等语言相同，采用 `.` 来访问结构体类型的成员。如 `a.b.c`，表示 `a` 是一个已定义的元素，它是一个结构体类型，有一个名称为 `b` 的成员，它也是一个结构体类型，有一个名称为 `c` 的成员。你需要输出如上被访问的**最内层**元素的起始地址。\n\n4. 访问某个内存地址。具体而言，给定非负整数 $addr$，表示所访问的地址，你需要判断是否存在一个**基本类型**的元素占据了该地址。若是，则按操作 3 中的访问元素格式输出该元素；否则输出 `ERR`。", "inputFormat": "第 $1$ 行：一个正整数 $n$，表示操作的数量。\n\n接下来若干行，依次描述每个操作，每行第一个正整数 $op$ 表示操作类型：\n\n- 若 $op = 1$，首先输入一个字符串 $s$ 与一个正整数 $k$，表示类型名与成员数量，接下来 $k$ 行每行输入两个字符串 $t_i, n_i$，依次表示每个成员的类型与名称。\n\n- 若 $op = 2$，输入两个字符串 $t, n$，表示该元素的类型与名称。\n\n- 若 $op = 3$，输入一个字符串 $s$，表示所访问的元素。\n\n- 若 $op = 4$，输入一个非负整数 $addr$，表示所访问的地址。", "outputFormat": "输出 $n$ 行，依次表示每个操作的输出结果，输出要求如题目描述中所述。", "hint": "#### 【样例 1 解释】\n\n结构体类型 `a` 中，`short` 类型的成员 `aa` 占据第 $0 \\sim 1$ 字节地址，`int` 类型的成员 `ab` 占据第 $4 \\sim 7$ 字节地址。又由于其对齐要求为 $4$ 字节，可得其大小为 $8$ 字节。由此可同理计算出结构体类型 `b` 的大小为 $16$ 字节，对齐要求为 $8$ 字节。\n\n#### 【样例 2】\n\n见选手目录下的 struct/struct2.in 与 struct/struct2.ans。\n\n#### 【样例 2 解释】\n第二个操作 4 中，访问的内存地址恰好在为了地址对齐而留下的 “洞” 里，因此没有基本类型元素占据它。\n\n#### 【样例 3】\n见选手目录下的 struct/struct3.in 与 struct/struct3.ans。\n\n#### 【数据范围】\n对于全部数据，满足 $1 \\le n \\le 100$，$1 \\le k \\le 100$，$0 \\le addr \\le 10^{18}$。\n\n所有定义的结构体类型名、成员名称和定义的元素名称均由不超过 $10$ 个字符的小写字母组成，且都不是 `byte,short,int,long`（即不与基本类型重名）。\n\n所有定义的结构体类型名和元素名称互不相同，同一结构体内成员名称互不相同。但不同的结构体可能有相同的成员名称，某结构体内的成员名称也可能与定义的结构体或元素名称相同。\n\n保证所有操作均符合题目所述的规范和要求，即结构体的定义不会包含不存在的类型、不会访问不存在的元素或成员等。\n\n保证任意结构体大小及定义的元素占据的最高内存地址均不超过 $10^{18}$。\n\n| 测试点 | 特殊性质 |\n| :----------: | :----------: |\n| $1$ | A、D |\n| $2\\sim 3$ | A |\n| $4\\sim 5$ | B、D |\n| $6\\sim 8$  | B |\n| $9\\sim 10$ | C、D|\n| $11\\sim 13$ | C|\n| $14\\sim 16$ |D|\n|$17\\sim 20$| 无|\n\n特殊性质 A：没有操作 $1$；\n\n特殊性质 B：只有一个操作 $1$；\n\n特殊性质 C：所有操作 $1$ 中给出的成员类型均为基本类型；\n\n特殊性质 D：基本类型只有 `long`。\n\n#### 【提示】\n\n对于结构体类型的对齐要求和大小，形式化的定义方式如下：\n\n- 设该结构体内有 $k$ 个成员，其大小分别为 $s_1,...,s_k$，对齐要求分别为 $a_1,...,a_k$;\n- 则该结构体的对齐要求为 $a=\\max\\{a_1,...,a_k\\}$；\n- 再设这些成员排布时的**地址偏移量**分别为 $o_1,...,o_k$，则：\n  - $o_1 = 0$;\n  - 对于 $i=2,...,k$，$o_i$ 为满足 $o_{i-1}+s_{i-1}\\le o_i$ 且 $a_i$ 整除 $o_i$ 的最小值；\n  - 则该结构体的大小 $s$ 为满足 $o_k+s_k\\le s$ 且 $a$ 整除 $s$ 的最小值；\n\n对于定义元素时的内存排布，形式化的定义方式如下：\n\n- 设第 $i$ 个被定义的元素大小为 $s_i$，对齐要求为 $a_i$，起始地址为 $b_i$;\n- 则 $b_1 = 0$，对于 $2\\le i$， $b_i$ 为满足 $b_{i-1} + s_{i-1}\\le b_i$ 且 $a_i$ 整除 $b_i$ 的最小值。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-S 2023] 结构体", "background": "在 C++ 等高级语言中，除了 int 和 float 等基本类型外，通常还可以自定义结构体类型。在本题当中，你需要模拟一种类似 C++ 的高级语言的结构体定义方式，并计算出相应的内存占用等信息。", "description": "在这种语言中，基本类型共有 $4$ 种：`byte`、`short`、`int`、`long`，分别占据 $1$、$2$、$4$、$8$ 字节的空间。\n\n定义一个结构体**类型**时，需要给出**类型名**和**成员**，其中每个成员需要按顺序给出**类型**和**名称**。类型可以为基本类型，也可以为**先前定义过**的结构体类型。注意，定义结构体**类型**时不会定义具体元素，即不占用内存。\n\n定义一个**元素**时，需要给出元素的**类型**和**名称**。元素将按照以下规则占据内存：\n\n- 元素内的所有成员将按照**定义时给出的顺序**在内存中排布，对于类型为结构体的成员同理。\n- 为了保证内存访问的效率，元素的地址占用需要满足**对齐规则**，即任何类型的**大小**和该类型元素在内存中的**起始地址**均应对齐到该类型对齐要求的**整数倍**。具体而言：\n  - 对于基本类型：对齐要求等于其占据空间大小，如 `int` 类型需要对齐到 $4$ 字节，其余同理。\n  - 对于结构体类型：对齐要求等于其成员的对齐要求的**最大值**，如一个含有 `int` 和 `short` 的结构体类型需要对齐到 $4$ 字节。\n\n以下是一个例子（以 C++ 语言的格式书写）：\n\n```cpp\nstruct d {\n    short a;\n    int b;\n    short c;\n};\nd e;\n```\n\n该代码定义了结构体类型 `d` 与元素 `e`。元素 `e` 包含三个成员 `e.a`、`e.b`、`e.c`，分别占据第 $0 \\sim 1$、$4 \\sim 7$、$8 \\sim 9$ 字节的地址。由于类型 `d` 需要对齐到 $4$ 字节，因此 `e` 占据了第 $0 \\sim 11$ 字节的地址，大小为 $12$ 字节。\n\n你需要处理 $n$ 次操作，每次操作为以下四种之一：\n\n1. 定义一个结构体类型。具体而言，给定正整数 $k$ 与字符串 $s, t_1, n_1, \\dots, t_k, n_k$，其中 $k$ 表示该类型的成员数量，$s$ 表示该类型的类型名，$t_1, t_2, \\dots, t_k$ 按顺序分别表示每个成员的类型，$n_1, n_2, \\dots, n_k$ 按顺序分别表示每个成员的名称。你需要输出该结构体类型的大小和对齐要求，用一个空格分隔。\n\n2. 定义一个元素，具体而言，给定字符串 $t, n$ 分别表示该元素的类型与名称。所有被定义的元素将按顺序，从内存地址为 $0$ 开始依次排开，并需要满足地址对齐规则。你需要输出新定义的元素的起始地址。\n\n3. 访问某个元素。具体而言，给定字符串 $s$，表示所访问的元素。与 C++ 等语言相同，采用 `.` 来访问结构体类型的成员。如 `a.b.c`，表示 `a` 是一个已定义的元素，它是一个结构体类型，有一个名称为 `b` 的成员，它也是一个结构体类型，有一个名称为 `c` 的成员。你需要输出如上被访问的**最内层**元素的起始地址。\n\n4. 访问某个内存地址。具体而言，给定非负整数 $addr$，表示所访问的地址，你需要判断是否存在一个**基本类型**的元素占据了该地址。若是，则按操作 3 中的访问元素格式输出该元素；否则输出 `ERR`。", "inputFormat": "第 $1$ 行：一个正整数 $n$，表示操作的数量。\n\n接下来若干行，依次描述每个操作，每行第一个正整数 $op$ 表示操作类型：\n\n- 若 $op = 1$，首先输入一个字符串 $s$ 与一个正整数 $k$，表示类型名与成员数量，接下来 $k$ 行每行输入两个字符串 $t_i, n_i$，依次表示每个成员的类型与名称。\n\n- 若 $op = 2$，输入两个字符串 $t, n$，表示该元素的类型与名称。\n\n- 若 $op = 3$，输入一个字符串 $s$，表示所访问的元素。\n\n- 若 $op = 4$，输入一个非负整数 $addr$，表示所访问的地址。", "outputFormat": "输出 $n$ 行，依次表示每个操作的输出结果，输出要求如题目描述中所述。", "hint": "#### 【样例 1 解释】\n\n结构体类型 `a` 中，`short` 类型的成员 `aa` 占据第 $0 \\sim 1$ 字节地址，`int` 类型的成员 `ab` 占据第 $4 \\sim 7$ 字节地址。又由于其对齐要求为 $4$ 字节，可得其大小为 $8$ 字节。由此可同理计算出结构体类型 `b` 的大小为 $16$ 字节，对齐要求为 $8$ 字节。\n\n#### 【样例 2】\n\n见选手目录下的 struct/struct2.in 与 struct/struct2.ans。\n\n#### 【样例 2 解释】\n第二个操作 4 中，访问的内存地址恰好在为了地址对齐而留下的 “洞” 里，因此没有基本类型元素占据它。\n\n#### 【样例 3】\n见选手目录下的 struct/struct3.in 与 struct/struct3.ans。\n\n#### 【数据范围】\n对于全部数据，满足 $1 \\le n \\le 100$，$1 \\le k \\le 100$，$0 \\le addr \\le 10^{18}$。\n\n所有定义的结构体类型名、成员名称和定义的元素名称均由不超过 $10$ 个字符的小写字母组成，且都不是 `byte,short,int,long`（即不与基本类型重名）。\n\n所有定义的结构体类型名和元素名称互不相同，同一结构体内成员名称互不相同。但不同的结构体可能有相同的成员名称，某结构体内的成员名称也可能与定义的结构体或元素名称相同。\n\n保证所有操作均符合题目所述的规范和要求，即结构体的定义不会包含不存在的类型、不会访问不存在的元素或成员等。\n\n保证任意结构体大小及定义的元素占据的最高内存地址均不超过 $10^{18}$。\n\n| 测试点 | 特殊性质 |\n| :----------: | :----------: |\n| $1$ | A、D |\n| $2\\sim 3$ | A |\n| $4\\sim 5$ | B、D |\n| $6\\sim 8$  | B |\n| $9\\sim 10$ | C、D|\n| $11\\sim 13$ | C|\n| $14\\sim 16$ |D|\n|$17\\sim 20$| 无|\n\n特殊性质 A：没有操作 $1$；\n\n特殊性质 B：只有一个操作 $1$；\n\n特殊性质 C：所有操作 $1$ 中给出的成员类型均为基本类型；\n\n特殊性质 D：基本类型只有 `long`。\n\n#### 【提示】\n\n对于结构体类型的对齐要求和大小，形式化的定义方式如下：\n\n- 设该结构体内有 $k$ 个成员，其大小分别为 $s_1,...,s_k$，对齐要求分别为 $a_1,...,a_k$;\n- 则该结构体的对齐要求为 $a=\\max\\{a_1,...,a_k\\}$；\n- 再设这些成员排布时的**地址偏移量**分别为 $o_1,...,o_k$，则：\n  - $o_1 = 0$;\n  - 对于 $i=2,...,k$，$o_i$ 为满足 $o_{i-1}+s_{i-1}\\le o_i$ 且 $a_i$ 整除 $o_i$ 的最小值；\n  - 则该结构体的大小 $s$ 为满足 $o_k+s_k\\le s$ 且 $a$ 整除 $s$ 的最小值；\n\n对于定义元素时的内存排布，形式化的定义方式如下：\n\n- 设第 $i$ 个被定义的元素大小为 $s_i$，对齐要求为 $a_i$，起始地址为 $b_i$;\n- 则 $b_1 = 0$，对于 $2\\le i$， $b_i$ 为满足 $b_{i-1} + s_{i-1}\\le b_i$ 且 $a_i$ 整除 $b_i$ 的最小值。\n", "locale": "zh-CN"}}}
{"pid": "P9755", "type": "P", "difficulty": 5, "samples": [["4\n12 1 1\n2 4 -1\n10 3 0\n7 10 -2\n1 2\n1 3\n3 4", "5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "二分", "2023", "O2优化", "CSP-S 提高级"], "title": "[CSP-S 2023] 种树", "background": null, "description": "你是一个森林养护员，有一天，你接到了一个任务：在一片森林内的地块上种树，并养护至树木长到指定的高度。\n\n森林的地图有 $n$ 片地块，其中 $1$ 号地块连接森林的入口。共有 $n-1$ 条道路连接这些地块，使得每片地块都能通过道路互相到达。最开始，每片地块上都没有树木。\n\n你的目标是：在每片地块上均种植一棵树木，并使得 $i$ 号地块上的树的高度生长到不低于 $a_i$ 米。\n\n你每天可以选择一个未种树且**与某个已种树的地块直接邻接**（**即通过单条道路相连**）的地块，种一棵高度为 $0$ 米的树。如果所有地块均已种过树，则你当天不进行任何操作。特别地，第 $1$ 天你只能在 $1$ 号空地种树。\n\n对每个地块而言，从该地块被种下树的当天开始，该地块上的树每天都会生长一定的高度。由于气候和土壤条件不同，在第 $x$ 天，$i$ 号地块上的树会长高 $\\max(b_i + x \\times c_i, 1)$ 米。注意这里的 $x$ 是从整个任务的第一天，而非种下这棵树的第一天开始计算。\n\n你想知道：最少需要多少天能够完成你的任务？", "inputFormat": "输入的第一行包含一个正整数 $n$，表示森林的地块数量。\n\n接下来 $n$ 行：每行包含三个整数 $a_i, b_i, c_i$，分别描述一片地块，含义如题目描述中所述。\n\n接下来 $n-1$ 行：每行包含两个正整数 $u_i, v_i$，表示一条连接地块 $u_i$ 和 $v_i$ 的道路。", "outputFormat": "输出一行仅包含一个正整数，表示完成任务所需的最少天数。", "hint": "**【样例 1 解释】**\n\n第 $1$ 天：在地块 $1$ 种树，地块 $1$ 的树木长高至 $2$ 米。\n\n第 $2$ 天：在地块 $3$ 种树，地块 $1, 3$ 的树木分别长高至 $5, 3$ 米。\n\n第 $3$ 天：在地块 $4$ 种树，地块 $1, 3, 4$ 的树木分别长高至 $9, 6, 4$ 米。\n\n第 $4$ 天：在地块 $2$ 种树，地块 $1, 2, 3, 4$ 的树木分别长高至 $14, 1, 9, 6$ 米。\n\n第 $5$ 天：地块 $1, 2, 3, 4$ 的树木分别长高至 $20, 2, 12, 7$ 米。\n\n**【样例 2】**\n\n见选手目录下的 `tree/tree2.in` 与 `tree/tree2.ans`。\n\n**【样例 3】**\n\n见选手目录下的 `tree/tree3.in` 与 `tree/tree3.ans`。\n\n**【样例 4】**\n\n见选手目录下的 `tree/tree4.in` 与 `tree/tree4.ans`。\n\n**【数据范围】**\n\n对于所有测试数据有：$1 \\le n \\le 10^5,1 \\le a_i \\le 10^{18}, 1 \\le b_i \\le 10^9,0 \\le |c_i| \\le 10^9, 1 \\le u_i, v_i \\le n$。保证存在方案能在 $10^9$ 天内完成任务。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\leq$ | 特殊性质 |\n| :-: | :-: | :-: |\n| $1$ | $20$ | $\\text A$ |\n| $2\\sim4$ | ^ | 无 |\n| $5\\sim6$ | $500$ | $\\text A$ |\n| $7\\sim8$ | $10^5$ | ^ |\n| $9\\sim10$ | ^ | $\\text B$ |\n| $11\\sim13$ | ^ | $\\text C$ |\n| $14\\sim16$ | ^ | $\\text D$ |\n| $17\\sim20$ | ^ | 无 |\n\n特殊性质 $\\text A$：对于所有 $1 ≤ i ≤ n$，均有 $c_i = 0$；\n\n特殊性质 $\\text B$：对于所有 $1 ≤ i < n$，均有 $u_i = i,v_i = i + 1$；\n\n特殊性质 $\\text C$：与任何地块直接相连的道路均不超过 $2$ 条；\n\n特殊性质 $\\text D$：对于所有 $1 ≤ i < n$，均有 $u_i = 1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-S 2023] 种树", "background": null, "description": "你是一个森林养护员，有一天，你接到了一个任务：在一片森林内的地块上种树，并养护至树木长到指定的高度。\n\n森林的地图有 $n$ 片地块，其中 $1$ 号地块连接森林的入口。共有 $n-1$ 条道路连接这些地块，使得每片地块都能通过道路互相到达。最开始，每片地块上都没有树木。\n\n你的目标是：在每片地块上均种植一棵树木，并使得 $i$ 号地块上的树的高度生长到不低于 $a_i$ 米。\n\n你每天可以选择一个未种树且**与某个已种树的地块直接邻接**（**即通过单条道路相连**）的地块，种一棵高度为 $0$ 米的树。如果所有地块均已种过树，则你当天不进行任何操作。特别地，第 $1$ 天你只能在 $1$ 号空地种树。\n\n对每个地块而言，从该地块被种下树的当天开始，该地块上的树每天都会生长一定的高度。由于气候和土壤条件不同，在第 $x$ 天，$i$ 号地块上的树会长高 $\\max(b_i + x \\times c_i, 1)$ 米。注意这里的 $x$ 是从整个任务的第一天，而非种下这棵树的第一天开始计算。\n\n你想知道：最少需要多少天能够完成你的任务？", "inputFormat": "输入的第一行包含一个正整数 $n$，表示森林的地块数量。\n\n接下来 $n$ 行：每行包含三个整数 $a_i, b_i, c_i$，分别描述一片地块，含义如题目描述中所述。\n\n接下来 $n-1$ 行：每行包含两个正整数 $u_i, v_i$，表示一条连接地块 $u_i$ 和 $v_i$ 的道路。", "outputFormat": "输出一行仅包含一个正整数，表示完成任务所需的最少天数。", "hint": "**【样例 1 解释】**\n\n第 $1$ 天：在地块 $1$ 种树，地块 $1$ 的树木长高至 $2$ 米。\n\n第 $2$ 天：在地块 $3$ 种树，地块 $1, 3$ 的树木分别长高至 $5, 3$ 米。\n\n第 $3$ 天：在地块 $4$ 种树，地块 $1, 3, 4$ 的树木分别长高至 $9, 6, 4$ 米。\n\n第 $4$ 天：在地块 $2$ 种树，地块 $1, 2, 3, 4$ 的树木分别长高至 $14, 1, 9, 6$ 米。\n\n第 $5$ 天：地块 $1, 2, 3, 4$ 的树木分别长高至 $20, 2, 12, 7$ 米。\n\n**【样例 2】**\n\n见选手目录下的 `tree/tree2.in` 与 `tree/tree2.ans`。\n\n**【样例 3】**\n\n见选手目录下的 `tree/tree3.in` 与 `tree/tree3.ans`。\n\n**【样例 4】**\n\n见选手目录下的 `tree/tree4.in` 与 `tree/tree4.ans`。\n\n**【数据范围】**\n\n对于所有测试数据有：$1 \\le n \\le 10^5,1 \\le a_i \\le 10^{18}, 1 \\le b_i \\le 10^9,0 \\le |c_i| \\le 10^9, 1 \\le u_i, v_i \\le n$。保证存在方案能在 $10^9$ 天内完成任务。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\leq$ | 特殊性质 |\n| :-: | :-: | :-: |\n| $1$ | $20$ | $\\text A$ |\n| $2\\sim4$ | ^ | 无 |\n| $5\\sim6$ | $500$ | $\\text A$ |\n| $7\\sim8$ | $10^5$ | ^ |\n| $9\\sim10$ | ^ | $\\text B$ |\n| $11\\sim13$ | ^ | $\\text C$ |\n| $14\\sim16$ | ^ | $\\text D$ |\n| $17\\sim20$ | ^ | 无 |\n\n特殊性质 $\\text A$：对于所有 $1 ≤ i ≤ n$，均有 $c_i = 0$；\n\n特殊性质 $\\text B$：对于所有 $1 ≤ i < n$，均有 $u_i = i,v_i = i + 1$；\n\n特殊性质 $\\text C$：与任何地块直接相连的道路均不超过 $2$ 条；\n\n特殊性质 $\\text D$：对于所有 $1 ≤ i < n$，均有 $u_i = 1$。", "locale": "zh-CN"}}}
{"pid": "P9756", "type": "P", "difficulty": 2, "samples": [["7 3\n5 21 9", "DA"], ["5 4\n8 5 10 3", "NE"], ["6 5\n5 5 5 5 5", "NE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #3] Estimathon", "background": "Paula 和 Domagoj 正要组织一场激动人心的名为 Estimathon 的团队比赛。他们已经准备好了问题，现在为此布置房间。", "description": "眨眼间，Domagoj 已经在屋里放置了 $n$ 张桌子。现在他们需要增置椅子。他们有五颜六色的椅子。一共有 $m$ 种颜色并且第 $i$ 种颜色的椅子有 $a_i$ 把。参赛每队由**四**人组成。因此对于每张桌子来说，Paula 和 Domagoj 需要增置 $4$ 把椅子。他们想把房间布置地尽可能好。为此，他们约定以下条件：\n- 每张桌子的椅子颜色需要相同\n- 每种颜色的椅子至少有一张桌子用到了\n\n由于过分关心房间的完美程度，他们突然发现考核其实已然开始了。请你帮他们寻找是否有一种可能的安排方式。", "inputFormat": "第一行包含两个整数 $n,m$，分别表示桌子的数量和椅子的颜色数。\n\n第二行包含 $m$ 个整数 $a_i$，第 $i$ 个数表示第 $i$ 种颜色的椅子的数量。", "outputFormat": "一行一个字符串。\n\n如果可以找到满足条件的方案，输出 `DA`；\n\n否则输出 `NE`。", "hint": "**【样例解释 #2】**\n\n我们可以有 $5$ 张分别拥有相同颜色椅子的桌子，但是我们没法使得一张桌子有第四种颜色，所以第二个条件没法满足。\n\n**【数据范围】**\n\n|$\\text{Subtask}$|分值|特殊性质|\n|:-:|:-:|:-:|\n|$1$|$11$|$a_1=... =a_m=4$\n|$2$|$39$|无特殊限制|\n\n对于 $100\\%$ 的数据，满足 $1\\leq n,m \\leq 100,1\\le a_i\\le 100$。\n\n**本题满分 $50$ 分。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #3] Estimathon", "background": "Paula 和 Domagoj 正要组织一场激动人心的名为 Estimathon 的团队比赛。他们已经准备好了问题，现在为此布置房间。", "description": "眨眼间，Domagoj 已经在屋里放置了 $n$ 张桌子。现在他们需要增置椅子。他们有五颜六色的椅子。一共有 $m$ 种颜色并且第 $i$ 种颜色的椅子有 $a_i$ 把。参赛每队由**四**人组成。因此对于每张桌子来说，Paula 和 Domagoj 需要增置 $4$ 把椅子。他们想把房间布置地尽可能好。为此，他们约定以下条件：\n- 每张桌子的椅子颜色需要相同\n- 每种颜色的椅子至少有一张桌子用到了\n\n由于过分关心房间的完美程度，他们突然发现考核其实已然开始了。请你帮他们寻找是否有一种可能的安排方式。", "inputFormat": "第一行包含两个整数 $n,m$，分别表示桌子的数量和椅子的颜色数。\n\n第二行包含 $m$ 个整数 $a_i$，第 $i$ 个数表示第 $i$ 种颜色的椅子的数量。", "outputFormat": "一行一个字符串。\n\n如果可以找到满足条件的方案，输出 `DA`；\n\n否则输出 `NE`。", "hint": "**【样例解释 #2】**\n\n我们可以有 $5$ 张分别拥有相同颜色椅子的桌子，但是我们没法使得一张桌子有第四种颜色，所以第二个条件没法满足。\n\n**【数据范围】**\n\n|$\\text{Subtask}$|分值|特殊性质|\n|:-:|:-:|:-:|\n|$1$|$11$|$a_1=... =a_m=4$\n|$2$|$39$|无特殊限制|\n\n对于 $100\\%$ 的数据，满足 $1\\leq n,m \\leq 100,1\\le a_i\\le 100$。\n\n**本题满分 $50$ 分。**", "locale": "zh-CN"}}}
{"pid": "P9757", "type": "P", "difficulty": 3, "samples": [["5 2\n2 3 4 5 1\n1 3\n3 1", "NE\nDA"], ["4 2\n2 3 1 4\n4 2\n3 4", "NE\nDA"], ["6 5\n2 1 5 6 3 4\n3 1\n3 4\n3 2\n4 5\n5 4", "NE\nNE\nDA\nNE\nDA"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #3] Dirigent", "background": "", "description": "信息学冬令营以一场传统舞蹈结营。一共有 $n$ 名学生参与。他们每个人都有分别有一个 $1\\sim n$ 之间的编号。\n\n一开始，指挥者 Kreso 要求学生们围成一个圈，使得每个学生都与另外两个学生拉着手。\n\nAlenka 想知道是否有可能通过将且仅将一对相邻同学分开手，使得这样形成的同学序列按照编号排序。例如，如果他们的顺序是 `3 4 1 2`，那么圈可以从 `4` `1` 两个同学间断开；但是如果顺序是 `2 1 4 3`，那么没有一种合理的方式。\n\n在这一晚，Kreso 准备下达 $q$ 条指令。在每条指令中，他会要求两个学生交换位置。在每一次交换之后你需要帮助 Alenka 回答他的问题。\n", "inputFormat": "第一行包含两个整数 $n,q$，表示学生的数量和交换数。\n\n第二行包含 $n$ 个整数 $a_i$，描述第 $i$ 个位置的学生编号。\n\n在接下来的 $q$ 行中，每行两个整数 $x_i,y_i$，描述 Kreso 的第 $i$ 条指令，即标号 $x_i$ 的学生和标号 $y_i$ 的学生交换位置。", "outputFormat": "共 $q$ 行。\n\n在第 $i$ 行输出在第 $i$ 次交换后 Alenka 的问题的答案。\n\n如果答案是肯定的，输出 `DA`，否则输出 `NE`。", "hint": "**【样例解释 #2】**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/382d6t5r.png)\n\n**【数据范围】**\n\n| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $15$ | $n,q \\leq 500$ |\n| $2$ | $20$ | $n,q \\leq 5000$ |\n| $3$ | $35$ | 无特殊性质 |\n\n对于 $100\\%$ 的数据，满足 $1\\leq n,q \\leq 3\\times10^5,1\\le a_i\\le n, 1\\le x_i,y_i\\le n,x_i\\neq y_i$。\n\n本题满分 $70$ 分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #3] Dirigent", "background": "", "description": "信息学冬令营以一场传统舞蹈结营。一共有 $n$ 名学生参与。他们每个人都有分别有一个 $1\\sim n$ 之间的编号。\n\n一开始，指挥者 Kreso 要求学生们围成一个圈，使得每个学生都与另外两个学生拉着手。\n\nAlenka 想知道是否有可能通过将且仅将一对相邻同学分开手，使得这样形成的同学序列按照编号排序。例如，如果他们的顺序是 `3 4 1 2`，那么圈可以从 `4` `1` 两个同学间断开；但是如果顺序是 `2 1 4 3`，那么没有一种合理的方式。\n\n在这一晚，Kreso 准备下达 $q$ 条指令。在每条指令中，他会要求两个学生交换位置。在每一次交换之后你需要帮助 Alenka 回答他的问题。\n", "inputFormat": "第一行包含两个整数 $n,q$，表示学生的数量和交换数。\n\n第二行包含 $n$ 个整数 $a_i$，描述第 $i$ 个位置的学生编号。\n\n在接下来的 $q$ 行中，每行两个整数 $x_i,y_i$，描述 Kreso 的第 $i$ 条指令，即标号 $x_i$ 的学生和标号 $y_i$ 的学生交换位置。", "outputFormat": "共 $q$ 行。\n\n在第 $i$ 行输出在第 $i$ 次交换后 Alenka 的问题的答案。\n\n如果答案是肯定的，输出 `DA`，否则输出 `NE`。", "hint": "**【样例解释 #2】**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/382d6t5r.png)\n\n**【数据范围】**\n\n| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $15$ | $n,q \\leq 500$ |\n| $2$ | $20$ | $n,q \\leq 5000$ |\n| $3$ | $35$ | 无特殊性质 |\n\n对于 $100\\%$ 的数据，满足 $1\\leq n,q \\leq 3\\times10^5,1\\le a_i\\le n, 1\\le x_i,y_i\\le n,x_i\\neq y_i$。\n\n本题满分 $70$ 分。", "locale": "zh-CN"}}}
{"pid": "P9758", "type": "P", "difficulty": 6, "samples": [["3\n6 6\n1 2 2\n1 3 2\n2 4 2\n3 5 2\n4 5 1\n5 6 2\n6 6\n1 2 2\n1 3 2\n2 4 2\n3 5 2\n4 5 3\n5 6 2\n6 7\n1 2 2\n1 3 2\n2 4 2\n3 5 2\n4 5 1\n5 6 2\n1 6 7", "2\n2 4\n0\n\n3\n2 4 6"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #3] Baltazar", "background": "", "description": "Baltazar 准备去度假。他现在在 Baltazargrad，正想去 Primosten 旅游。为了抵达那里，他需要穿过许多个城市。一共有 $n$ 个城市，被 $m$ 条双向道路所联接。Baltazargrad 编号为 $1$，Primosten 编号为 $n$。\n\nBaltazar 不确定从 Baltazargrad 去 Primosten 的路线，所以他将会使用 GPS，这会指引他以最短路线抵达。\n\n但 Blatazar 真的很爱旅游，而且他可以将魔法药水使用在任何一条路上（即使他没有经过），从而将路的长度增长 $2$ 千米。但他仅能使用一次药水。\n\n不久他意识到，他必须在中午之前在 Primosten 的 Zora 旅馆入住。所以他不能过分增加最短路的总长度。他现在想知道，一共有多少条路可以让他使用药水，使得最短路的长度恰好增加 $1$ 千米。", "inputFormat": "多组数据。\n\n第一行一个整数 $t$，表示数据组数。\n\n接下来对于每组数据，第一行两个整数 $n,m$，分别表示城市的数量和城市之间道路的数量。\n\n接下来的 $m$ 行，每行三个整数 $a_i,b_i,w_i$，表示一条连接城市 $a_i,b_i$ 且长度为 $w_i$ 的道路。两个城市间最多只有一条道路。\n\n保证所有城市是相互联通的。也就是说，任何一对城市，都有一条相互可达的路径，但不一定是直接相连。\n\n保证所有数据的 $n, m$ 各自之和均不超过 $300000$。\n\n", "outputFormat": "第一行输出一个整数 $c$，表示 Baltazar 可以使用魔法药水的道路数量。\n\n接下来一行 $c$ 个整数，以编号升序输出所有满足条件的道路。", "hint": "**【样例解释】**\n\n城市和道路如图所示。如果 Baltazar 把他的魔法药水使用在第二条道路上（连接城市 $3$ 和 $5$ 的），那么城市 $1$ 和 $n$ 之间最短的距离将会增加 $1$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jeaidgpn.png)\n\n**【数据范围】**\n\n| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $15$ | $n,m \\leq 1000$ |\n| $2$ | $30$ | 有一条在起点终点之间的道路，这条道路的长度满足恰好比两个城市之间的最短路线长 $1$ 千米。 |\n| $3$ | $65$ | 无特殊性质 |\n\n对于 $100\\%$ 的数据，满足 $1\\le t \\le 10000,2\\leq n \\leq 3\\times10^5,1\\le m\\le \\min(3\\times 10^5,\\dfrac{n\\times (n-1)}{2}), 1\\le a_i,b_i\\le n,a_i\\neq b_i,1\\le w_i\\le 10^9$。\n\n本题满分 $110$ 分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #3] Baltazar", "background": "", "description": "Baltazar 准备去度假。他现在在 Baltazargrad，正想去 Primosten 旅游。为了抵达那里，他需要穿过许多个城市。一共有 $n$ 个城市，被 $m$ 条双向道路所联接。Baltazargrad 编号为 $1$，Primosten 编号为 $n$。\n\nBaltazar 不确定从 Baltazargrad 去 Primosten 的路线，所以他将会使用 GPS，这会指引他以最短路线抵达。\n\n但 Blatazar 真的很爱旅游，而且他可以将魔法药水使用在任何一条路上（即使他没有经过），从而将路的长度增长 $2$ 千米。但他仅能使用一次药水。\n\n不久他意识到，他必须在中午之前在 Primosten 的 Zora 旅馆入住。所以他不能过分增加最短路的总长度。他现在想知道，一共有多少条路可以让他使用药水，使得最短路的长度恰好增加 $1$ 千米。", "inputFormat": "多组数据。\n\n第一行一个整数 $t$，表示数据组数。\n\n接下来对于每组数据，第一行两个整数 $n,m$，分别表示城市的数量和城市之间道路的数量。\n\n接下来的 $m$ 行，每行三个整数 $a_i,b_i,w_i$，表示一条连接城市 $a_i,b_i$ 且长度为 $w_i$ 的道路。两个城市间最多只有一条道路。\n\n保证所有城市是相互联通的。也就是说，任何一对城市，都有一条相互可达的路径，但不一定是直接相连。\n\n保证所有数据的 $n, m$ 各自之和均不超过 $300000$。\n\n", "outputFormat": "第一行输出一个整数 $c$，表示 Baltazar 可以使用魔法药水的道路数量。\n\n接下来一行 $c$ 个整数，以编号升序输出所有满足条件的道路。", "hint": "**【样例解释】**\n\n城市和道路如图所示。如果 Baltazar 把他的魔法药水使用在第二条道路上（连接城市 $3$ 和 $5$ 的），那么城市 $1$ 和 $n$ 之间最短的距离将会增加 $1$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jeaidgpn.png)\n\n**【数据范围】**\n\n| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $15$ | $n,m \\leq 1000$ |\n| $2$ | $30$ | 有一条在起点终点之间的道路，这条道路的长度满足恰好比两个城市之间的最短路线长 $1$ 千米。 |\n| $3$ | $65$ | 无特殊性质 |\n\n对于 $100\\%$ 的数据，满足 $1\\le t \\le 10000,2\\leq n \\leq 3\\times10^5,1\\le m\\le \\min(3\\times 10^5,\\dfrac{n\\times (n-1)}{2}), 1\\le a_i,b_i\\le n,a_i\\neq b_i,1\\le w_i\\le 10^9$。\n\n本题满分 $110$ 分。", "locale": "zh-CN"}}}
{"pid": "P9759", "type": "P", "difficulty": 4, "samples": [["2 2\n3 2\n1 4", "2"], ["3 6\n5 2 -1\n7 3 6\n-1 3 1", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #3] Bomboni", "background": "", "description": "Iva 是一个狂热的糖果迷！在她面前是一块填满糖果和障碍的 $n\\times n$ 的土地。Iva 目前在左上角。通过向右或向下移动，她要前往右下角。Iva 目前所在的格子没有障碍。\n\n在每个格子中写了一个数字表示此地为糖果或障碍。Iva 会吃掉所有经过的糖果（包括起点和终点的糖果）并且将糖果对应的数字相乘。Iva 知道她自己最喜欢的数字是 $k$，所以她希望这个乘积结果能被 $k$ 整除。她想知道一共有多少条这样的路径。由于答案可能很大，她只想知道答案模 $998244353$ 的结果。", "inputFormat": "第一行两个整数 $n,k$，表示土地的边长和 Iva 的最喜欢的数字。\n\n在接下来的 $n$ 行中，每一行 $n$ 个数字，描述这片土地。如果 $a_{i,j}=-1$，那么这块土地就是障碍物，否则满足这块土地包含一个 $1\\le a_{i,j}\\le 10^6$ 的数。", "outputFormat": "一行一个整数表示结果。", "hint": "**【样例解释 #2】**\n\n共有三条这样的路线：\n- 5-2-3-3-1\n- 5-2-3-6-1\n- 5-7-3-6-1\n\n**【数据范围】**\n\n| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $13$ | $n,k,a_{i,j} \\leq 20$ |\n| $2$ | $17$ | $n,k \\leq 20$ |\n| $3$ | $33$ | $k\\le 20$ |\n| $4$ | $47$ | 无特殊性质 |\n\n对于 $100\\%$ 的数据，满足 $1\\leq n \\leq 500,1\\le k\\le 10^6, -1\\le a_{i,j}\\le 10^6$。\n\n本题满分 $110$ 分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #3] Bomboni", "background": "", "description": "Iva 是一个狂热的糖果迷！在她面前是一块填满糖果和障碍的 $n\\times n$ 的土地。Iva 目前在左上角。通过向右或向下移动，她要前往右下角。Iva 目前所在的格子没有障碍。\n\n在每个格子中写了一个数字表示此地为糖果或障碍。Iva 会吃掉所有经过的糖果（包括起点和终点的糖果）并且将糖果对应的数字相乘。Iva 知道她自己最喜欢的数字是 $k$，所以她希望这个乘积结果能被 $k$ 整除。她想知道一共有多少条这样的路径。由于答案可能很大，她只想知道答案模 $998244353$ 的结果。", "inputFormat": "第一行两个整数 $n,k$，表示土地的边长和 Iva 的最喜欢的数字。\n\n在接下来的 $n$ 行中，每一行 $n$ 个数字，描述这片土地。如果 $a_{i,j}=-1$，那么这块土地就是障碍物，否则满足这块土地包含一个 $1\\le a_{i,j}\\le 10^6$ 的数。", "outputFormat": "一行一个整数表示结果。", "hint": "**【样例解释 #2】**\n\n共有三条这样的路线：\n- 5-2-3-3-1\n- 5-2-3-6-1\n- 5-7-3-6-1\n\n**【数据范围】**\n\n| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $13$ | $n,k,a_{i,j} \\leq 20$ |\n| $2$ | $17$ | $n,k \\leq 20$ |\n| $3$ | $33$ | $k\\le 20$ |\n| $4$ | $47$ | 无特殊性质 |\n\n对于 $100\\%$ 的数据，满足 $1\\leq n \\leq 500,1\\le k\\le 10^6, -1\\le a_{i,j}\\le 10^6$。\n\n本题满分 $110$ 分。", "locale": "zh-CN"}}}
{"pid": "P9760", "type": "P", "difficulty": 6, "samples": [["4 4\n3 4 1 2\n1 2\n2 3\n3 4\n4 1", "-1 -1 -1 -1"], ["8 9\n2 3 2 1 6 5 6 7\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6\n6 7\n5 7\n4 8", "1 2 2 2 1 1 1 1"], ["9 8\n1 9 1 1 1 9 9 9 1\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n8 9", "0 1 1 2 1 1 2 1 1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "COCI（克罗地亚）"], "title": "[COCI 2022/2023 #3] Skrivača", "background": "", "description": "Marin 和 Luka 正在他们的房子里玩一个流行的儿童游戏——捉迷藏。这个房子共有 $n$ 个房间，有 $m$ 对房间通过一扇门连接。房间从 $1$ 到 $n$ 编号，并且任意两个房间之间是存在道路相连通的。\n\nLuka 想出了一个躲藏策略：当 Marin 进入房间 $v$ 时，Luka 会躲在房间 $a_v$ 里。在游戏的开始 Marin 选择他开始找人的房间 $v_0$，Luka 躲在房间 $a_{v_0}$里。在游戏的每一个回合，首先由 Marin 选择一个与当前相邻房间 $u$ 并进入。随后 Luka 知道 Marin 在房间 $u$ 中所以参照他的躲藏方式他会躲到房间 $a_u$ 中。注意到 Luka 可以选择任何抵达房间 $a_u$ 的路线并且在游戏的一个回合中他可以经过任意数量的房间。\n\n定义 Marin 找到了 Luka 为当他们两个都在同一个房间中的时候，这时游戏结束。\n\nMarin 发现了 Luka 的躲藏策略，所以她想要你考虑从每一个房间出发时，她是否可以在有限回合找到 Luka。如果可以，计算在理想状态下（Marin 尽可能减少回合数，Luka 尽可能增加回合数）最少需要的回合数。", "inputFormat": "第一行两个整数 $n,m$，分别表示房间的数量和相连房间的对数。\n\n第二行 $n$ 个整数 $a_i$，表示 Luka 的躲藏策略。\n\n在接下来的 $m$ 行中，每行两个整数 $x_i,y_i$，表示这两个房间是相连的。任意两个房间最多只有一条直接相连的道路。", "outputFormat": "一行 $n$ 个数，表示最少需要的回合数。如果无法在有限步中结束游戏，输出 $-1$。", "hint": "**【样例解释 #2】**\n\nMarin 第一回合从房间 $4$ 进入房间 $8$，第二回合回到房间 $4$。Luka 需要经过房间 $4$ 才能从房间 $7$ 到房间 $1$。所以可以在两个回合找到。\n\n**【数据范围】**\n\n| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $15$ | $n\\le 1000,m\\le2000$ |\n| $2$ | $25$ | $m=n-1$ |\n|$3$ | $30$| Luka 的躲藏策略满足他永远不会躲在与 Marin 当前所在房间相邻或相同的房间，并且房子的结构满足游戏可以在最多有 $5$ 个不同房间独立于 Luka 的躲藏策略之外的情况下结束游戏。 \n| $4$ | $40$ | 无特殊性质 |\n\n对于 $100\\%$ 的数据，满足 $1\\leq n \\leq 2\\times10^5,n-1\\le m\\le \\min(5\\times 10^5,\\dfrac{n\\times (n-1)}{2}), 1\\le a_i,x_i,y_i\\le n,x_i\\neq y_i$。\n\n本题满分 $110$ 分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2022/2023 #3] Skrivača", "background": "", "description": "Marin 和 Luka 正在他们的房子里玩一个流行的儿童游戏——捉迷藏。这个房子共有 $n$ 个房间，有 $m$ 对房间通过一扇门连接。房间从 $1$ 到 $n$ 编号，并且任意两个房间之间是存在道路相连通的。\n\nLuka 想出了一个躲藏策略：当 Marin 进入房间 $v$ 时，Luka 会躲在房间 $a_v$ 里。在游戏的开始 Marin 选择他开始找人的房间 $v_0$，Luka 躲在房间 $a_{v_0}$里。在游戏的每一个回合，首先由 Marin 选择一个与当前相邻房间 $u$ 并进入。随后 Luka 知道 Marin 在房间 $u$ 中所以参照他的躲藏方式他会躲到房间 $a_u$ 中。注意到 Luka 可以选择任何抵达房间 $a_u$ 的路线并且在游戏的一个回合中他可以经过任意数量的房间。\n\n定义 Marin 找到了 Luka 为当他们两个都在同一个房间中的时候，这时游戏结束。\n\nMarin 发现了 Luka 的躲藏策略，所以她想要你考虑从每一个房间出发时，她是否可以在有限回合找到 Luka。如果可以，计算在理想状态下（Marin 尽可能减少回合数，Luka 尽可能增加回合数）最少需要的回合数。", "inputFormat": "第一行两个整数 $n,m$，分别表示房间的数量和相连房间的对数。\n\n第二行 $n$ 个整数 $a_i$，表示 Luka 的躲藏策略。\n\n在接下来的 $m$ 行中，每行两个整数 $x_i,y_i$，表示这两个房间是相连的。任意两个房间最多只有一条直接相连的道路。", "outputFormat": "一行 $n$ 个数，表示最少需要的回合数。如果无法在有限步中结束游戏，输出 $-1$。", "hint": "**【样例解释 #2】**\n\nMarin 第一回合从房间 $4$ 进入房间 $8$，第二回合回到房间 $4$。Luka 需要经过房间 $4$ 才能从房间 $7$ 到房间 $1$。所以可以在两个回合找到。\n\n**【数据范围】**\n\n| 子任务 | 分值 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $15$ | $n\\le 1000,m\\le2000$ |\n| $2$ | $25$ | $m=n-1$ |\n|$3$ | $30$| Luka 的躲藏策略满足他永远不会躲在与 Marin 当前所在房间相邻或相同的房间，并且房子的结构满足游戏可以在最多有 $5$ 个不同房间独立于 Luka 的躲藏策略之外的情况下结束游戏。 \n| $4$ | $40$ | 无特殊性质 |\n\n对于 $100\\%$ 的数据，满足 $1\\leq n \\leq 2\\times10^5,n-1\\le m\\le \\min(5\\times 10^5,\\dfrac{n\\times (n-1)}{2}), 1\\le a_i,x_i,y_i\\le n,x_i\\neq y_i$。\n\n本题满分 $110$ 分。", "locale": "zh-CN"}}}
{"pid": "P9761", "type": "P", "difficulty": 2, "samples": [["20\n10 4\n5 3", "65"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "ROIR（俄罗斯）"], "title": "[ROIR 2021] 两台机器 (Day 1)", "background": "**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day1 T1 [ Два станка](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day1.pdf)**。", "description": "有两台机器，第一台机器需要 $a$ 分钟启动，接下来每分钟会制造 $x$ 个零件，第二台机器需要 $b$ 分钟启动，接下来每分钟会制造 $y$ 个零件，两个机器不能同时位于启动过程中。\n\n共有 $k$ 分钟，问最多能制造多少个零件。", "inputFormat": "第一行为一个整数 $k$。\n\n第二行为两个整数 $a,x$。\n\n第三行为两个整数 $b,y$。", "outputFormat": "仅一行一个整数，表示最多能制造的零件个数。", "hint": "【样例解释】：\n\n如果先启动第二台机器，接着启动第一台机器，可制作 $3\\times 15+5\\times 4=65$ 个零件。\n\n【数据范围】：\n\n对于所有子任务，有 $0\\le k,a,x,b,y\\le 10^9$，最终答案可以用 `long long` 存下。\n\n| 子任务编号 | 特殊限制 | 分值 |\n| :-: | :-: | :-: |\n|$1$|$a=x=0$| $17$ |\n|$2$|$a=b=0$| $14$ |\n|$3$|$a=b$| $20$ |\n|$4$|$x=y$| $20$ |\n|$5$|无| $29$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2021] 两台机器 (Day 1)", "background": "**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day1 T1 [ Два станка](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day1.pdf)**。", "description": "有两台机器，第一台机器需要 $a$ 分钟启动，接下来每分钟会制造 $x$ 个零件，第二台机器需要 $b$ 分钟启动，接下来每分钟会制造 $y$ 个零件，两个机器不能同时位于启动过程中。\n\n共有 $k$ 分钟，问最多能制造多少个零件。", "inputFormat": "第一行为一个整数 $k$。\n\n第二行为两个整数 $a,x$。\n\n第三行为两个整数 $b,y$。", "outputFormat": "仅一行一个整数，表示最多能制造的零件个数。", "hint": "【样例解释】：\n\n如果先启动第二台机器，接着启动第一台机器，可制作 $3\\times 15+5\\times 4=65$ 个零件。\n\n【数据范围】：\n\n对于所有子任务，有 $0\\le k,a,x,b,y\\le 10^9$，最终答案可以用 `long long` 存下。\n\n| 子任务编号 | 特殊限制 | 分值 |\n| :-: | :-: | :-: |\n|$1$|$a=x=0$| $17$ |\n|$2$|$a=b=0$| $14$ |\n|$3$|$a=b$| $20$ |\n|$4$|$x=y$| $20$ |\n|$5$|无| $29$ |", "locale": "zh-CN"}}}
{"pid": "P9762", "type": "P", "difficulty": 3, "samples": [["5\n1 3\n4 7\n1 10\n3 3\n3 5", "V 3\nV 5\nV 8\nH 3\nV 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "二分", "2021", "三分", "ROIR（俄罗斯）"], "title": "[ROIR 2021] 分割数表 (Day 1)", "background": "**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day1 T2 [ Разбиение таблицы](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day1.pdf)**。", "description": "有一个 $n\\times m$ 的数表 $a$，$a_{i,j}=(i-1)\\times m+j$。\n\n现在将这个数表分成两个数表 $x,y$，使得 $\\max\\{\\sum x,\\sum y\\}$ 最小。\n\n形象化地来说，您可以确定一个 $i$，然后在数表的第 $i-1$ 列与第 $i$ 列间竖切一刀，或者在第 $i-1$ 行与第 $i$ 行间横切一刀，所得到的两个数表分为 $x,y$。\n\n请构造一组方案。", "inputFormat": "**本题多组数据。**\n\n第一行为一个整数 $t$。\n\n接下来 $t$ 行，一行两个整数 $n,m$，表示本次询问的数表大小。", "outputFormat": "对于每一个询问，输出一个字符 $c$ 和一个整数 $x$。\n\n如果您想要竖切，$c$ 为 `V`，$x$ 为您确定的 $i$。\n\n如果您想要横切，$c$ 为 `H`，$x$ 为您确定的 $i$。\n\n如果有多解，请输出竖切的一种，如果还有多解，输出 $x$ 最小的一种。", "hint": "【数据范围】：\n\n对于所有子任务，有 $1\\le t\\le 10^5$，$1\\le n,m\\le 10^9$，$2\\le n\\times m\\le 10^9$。\n\n| 子任务编号 |数据范围 | 分值 |\n| :-: | :-: | :-: |\n|$1$|$t=1$，$n,m\\le 100$| $20$ |\n|$2$|$t=1$，$n,m\\le 2\\times 10^3$| $14$ |\n|$3$|$t=1$，$n,m\\le 10^7$| $15$ |\n|$4$| $t\\le 10^3$，$n\\times m\\le10^4$ | $16$|\n|$5$|$n=1$| $15$ |\n|$6$|无特殊限制| $20$ |\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2021] 分割数表 (Day 1)", "background": "**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day1 T2 [ Разбиение таблицы](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day1.pdf)**。", "description": "有一个 $n\\times m$ 的数表 $a$，$a_{i,j}=(i-1)\\times m+j$。\n\n现在将这个数表分成两个数表 $x,y$，使得 $\\max\\{\\sum x,\\sum y\\}$ 最小。\n\n形象化地来说，您可以确定一个 $i$，然后在数表的第 $i-1$ 列与第 $i$ 列间竖切一刀，或者在第 $i-1$ 行与第 $i$ 行间横切一刀，所得到的两个数表分为 $x,y$。\n\n请构造一组方案。", "inputFormat": "**本题多组数据。**\n\n第一行为一个整数 $t$。\n\n接下来 $t$ 行，一行两个整数 $n,m$，表示本次询问的数表大小。", "outputFormat": "对于每一个询问，输出一个字符 $c$ 和一个整数 $x$。\n\n如果您想要竖切，$c$ 为 `V`，$x$ 为您确定的 $i$。\n\n如果您想要横切，$c$ 为 `H`，$x$ 为您确定的 $i$。\n\n如果有多解，请输出竖切的一种，如果还有多解，输出 $x$ 最小的一种。", "hint": "【数据范围】：\n\n对于所有子任务，有 $1\\le t\\le 10^5$，$1\\le n,m\\le 10^9$，$2\\le n\\times m\\le 10^9$。\n\n| 子任务编号 |数据范围 | 分值 |\n| :-: | :-: | :-: |\n|$1$|$t=1$，$n,m\\le 100$| $20$ |\n|$2$|$t=1$，$n,m\\le 2\\times 10^3$| $14$ |\n|$3$|$t=1$，$n,m\\le 10^7$| $15$ |\n|$4$| $t\\le 10^3$，$n\\times m\\le10^4$ | $16$|\n|$5$|$n=1$| $15$ |\n|$6$|无特殊限制| $20$ |\n\n", "locale": "zh-CN"}}}
{"pid": "P9763", "type": "P", "difficulty": 4, "samples": [["5AC5A2C", "3 6 A\n1 2 C"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2021", "Special Judge", "ROIR（俄罗斯）"], "title": "[ROIR 2021] 基因突变 (Day 1)", "background": "**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day1 T3 [ Изменённая ДНК](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day1.pdf)**。", "description": "我们规定，一个合法的基因串仅包括 `A`、`G`、`C` 与 `T`。\n\n我们规定，任何一个合法基因串都有一个压缩串，压缩串将原基因字符串中连续的字母压缩成这个字母的个数后跟这个字母，个数如为 $1$，则省略。\n\n例子：`AAAAACAAAAACC` 的压缩串为 `5AC5A2C`。\n\n现在有一个合法基因串 $S$，其压缩串为 $T$，您可以对这个合法基因串做一次操作，操作可以有如下三种：\n\n- 在 $S$ 的第 $x$ 个字符后插入一个字符 $Z$。\n- 删除 $S$ 的第 $x$ 个字符。\n- 将 $S$ 的第 $x$ 个字符替换为另一个字符 $Z$。\n\n设 $S$ 经过操作后变为 $S'$，$S'$ 的压缩串为 $T'$，求使得 $T'$ 的长度最小化或最大化的一种操作方案。", "inputFormat": "一行一个字符串 $T$。", "outputFormat": "输出共两行，第一行为使 $T'$ 长度最小化的一种方案，第二行为使 $T'$ 长度最大化的一种方案。\n\n方案输出格式如下：\n\n- 如果您想要使用 $1$ 操作，输出格式类似 `1 x Z`。\n- 如果您想要使用 $2$ 操作，输出格式类似 `2 x`。\n- 如果您想要使用 $3$ 操作，输出格式类似 `3 x Z`。", "hint": "【样例解释】：\n\n$S=$ `AAAAACAAAAACC`。\n\n使用 `3 6 A` 的操作后 $S'=$ `AAAAAAAAAAACC`，$T'=$ `11A2C`。\n\n使用 `1 2 C` 的操作后 $S'=$ `AACAAACAAAAACC`，$T'=$ `2AC3AC5A2C`。\n\n【数据范围】：\n\n对于所有子任务，有 $1\\le |T|\\le 10^5$，$1\\le |S|\\le 10^9$。\n\n\n| 子任务编号 |数据范围| 分值 |\n|:-:|:-:|:-:|\n|$1$|$\\lvert T\\rvert\\le \\lvert S\\rvert\\le 10$|$9$ |\n|$2$|$\\lvert T\\rvert\\le 100$，$\\lvert S\\rvert\\le 10^4$|$17$|\n|$3$|$\\lvert T\\rvert\\le 10^3$，$\\lvert S\\rvert\\le 10^5$|$21$|\n|$4$|$\\lvert S\\rvert\\le 10^7$|$11$|\n|$5$|无特殊限制|$42$|\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2021] 基因突变 (Day 1)", "background": "**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day1 T3 [ Изменённая ДНК](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day1.pdf)**。", "description": "我们规定，一个合法的基因串仅包括 `A`、`G`、`C` 与 `T`。\n\n我们规定，任何一个合法基因串都有一个压缩串，压缩串将原基因字符串中连续的字母压缩成这个字母的个数后跟这个字母，个数如为 $1$，则省略。\n\n例子：`AAAAACAAAAACC` 的压缩串为 `5AC5A2C`。\n\n现在有一个合法基因串 $S$，其压缩串为 $T$，您可以对这个合法基因串做一次操作，操作可以有如下三种：\n\n- 在 $S$ 的第 $x$ 个字符后插入一个字符 $Z$。\n- 删除 $S$ 的第 $x$ 个字符。\n- 将 $S$ 的第 $x$ 个字符替换为另一个字符 $Z$。\n\n设 $S$ 经过操作后变为 $S'$，$S'$ 的压缩串为 $T'$，求使得 $T'$ 的长度最小化或最大化的一种操作方案。", "inputFormat": "一行一个字符串 $T$。", "outputFormat": "输出共两行，第一行为使 $T'$ 长度最小化的一种方案，第二行为使 $T'$ 长度最大化的一种方案。\n\n方案输出格式如下：\n\n- 如果您想要使用 $1$ 操作，输出格式类似 `1 x Z`。\n- 如果您想要使用 $2$ 操作，输出格式类似 `2 x`。\n- 如果您想要使用 $3$ 操作，输出格式类似 `3 x Z`。", "hint": "【样例解释】：\n\n$S=$ `AAAAACAAAAACC`。\n\n使用 `3 6 A` 的操作后 $S'=$ `AAAAAAAAAAACC`，$T'=$ `11A2C`。\n\n使用 `1 2 C` 的操作后 $S'=$ `AACAAACAAAAACC`，$T'=$ `2AC3AC5A2C`。\n\n【数据范围】：\n\n对于所有子任务，有 $1\\le |T|\\le 10^5$，$1\\le |S|\\le 10^9$。\n\n\n| 子任务编号 |数据范围| 分值 |\n|:-:|:-:|:-:|\n|$1$|$\\lvert T\\rvert\\le \\lvert S\\rvert\\le 10$|$9$ |\n|$2$|$\\lvert T\\rvert\\le 100$，$\\lvert S\\rvert\\le 10^4$|$17$|\n|$3$|$\\lvert T\\rvert\\le 10^3$，$\\lvert S\\rvert\\le 10^5$|$21$|\n|$4$|$\\lvert S\\rvert\\le 10^7$|$11$|\n|$5$|无特殊限制|$42$|\n", "locale": "zh-CN"}}}
{"pid": "P9764", "type": "P", "difficulty": 6, "samples": [["3\n1 7\n3\n1 8\n6\n2 8\n1 6", "Yes\n2 1 3"], ["1\n1 7\n5", "Yes\n1"], ["1\n3 10\n2 5 9", "No"], ["3\n1 5\n3\n1 3\n3\n1 6\n3", "No"], ["4\n1 5\n0\n1 0\n0\n1 3\n3\n1 0\n0", "Yes\n3 2 1 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "图论", "2021", "Special Judge", "图论建模", "欧拉回路", "ROIR（俄罗斯）"], "title": "[ROIR 2021] 绳子 (Day 1)", "background": "**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day1 T4 [ Антенна](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day1.pdf)**。", "description": "有 $n$ 根绳子，第 $i$ 根绳子长 $s_i$ cm，有 $m_i$ 个节点，第 $j$ 个节点在离绳子左端点 $p_{i,j}$ cm 处。\n\n试构造一组从左至右连接绳子的方案，设该方案的绳子顺序为 $q$，$q$ 显然会是 $1\\sim n$ 的一个排列，且满足如下要求：将第 $q_i$ 根绳子的右端点与第 $q_{i+1}$ 根绳子的左端点相接后 $(1\\le i<n)$，相邻的节点间的距离相等。\n\n显然有可能没有方案，这个时候请输出 `No`。", "inputFormat": "第一行为一个整数 $n$。\n\n接下来共 $2\\times n$ 行：\n\n- 第 $2\\times i(1\\le i\\le n)$ 行为两个整数 $m_i$ 与 $s_i$。\n- 第 $2\\times i+1(1\\le i\\le n)$ 行为 $m_i$ 个整数 $p_{i,j}$。", "outputFormat": "若可以构造一组方案，输出 `Yes`，接下来再输出一行 $n$ 个整数 $q_i$。\n\n若无解，输出 `No`。", "hint": "【样例解释1】：\n\n![](https://s1.ax1x.com/2023/04/28/p9lIjVH.png)\n![p9lIOqe.png](https://s1.ax1x.com/2023/04/28/p9lIOqe.png)\n\n【数据范围】：\n\n对于所有子任务，均有 $1\\le n\\le 10^5$，$1\\le m_i\\le 10^5$，$0\\le s_i\\le 10^9$，$0\\le p_{i,1}<p_{i,2}<\\cdots<p_{i,m_i}\\le s_i$，$\\sum m_i\\le 10^5$。\n\n| 子任务编号 |特殊限制| 分值 |\n| :-: | :-: | :--: |\n|$1$| $n\\le 8$，$m_i=1$，$s_i\\le 100$ | $8$  |\n|$2$|$n\\le 8$，$s_i\\le 100$| $8$  |\n|$3$|$n\\le 10^3$| $21$ |\n|$4$|$\\sum m_i>n$| $21$ |\n|$5$|$s_i\\le 100$| $21$ |\n|$6$|无特殊限制| $21$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2021] 绳子 (Day 1)", "background": "**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day1 T4 [ Антенна](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day1.pdf)**。", "description": "有 $n$ 根绳子，第 $i$ 根绳子长 $s_i$ cm，有 $m_i$ 个节点，第 $j$ 个节点在离绳子左端点 $p_{i,j}$ cm 处。\n\n试构造一组从左至右连接绳子的方案，设该方案的绳子顺序为 $q$，$q$ 显然会是 $1\\sim n$ 的一个排列，且满足如下要求：将第 $q_i$ 根绳子的右端点与第 $q_{i+1}$ 根绳子的左端点相接后 $(1\\le i<n)$，相邻的节点间的距离相等。\n\n显然有可能没有方案，这个时候请输出 `No`。", "inputFormat": "第一行为一个整数 $n$。\n\n接下来共 $2\\times n$ 行：\n\n- 第 $2\\times i(1\\le i\\le n)$ 行为两个整数 $m_i$ 与 $s_i$。\n- 第 $2\\times i+1(1\\le i\\le n)$ 行为 $m_i$ 个整数 $p_{i,j}$。", "outputFormat": "若可以构造一组方案，输出 `Yes`，接下来再输出一行 $n$ 个整数 $q_i$。\n\n若无解，输出 `No`。", "hint": "【样例解释1】：\n\n![](https://s1.ax1x.com/2023/04/28/p9lIjVH.png)\n![p9lIOqe.png](https://s1.ax1x.com/2023/04/28/p9lIOqe.png)\n\n【数据范围】：\n\n对于所有子任务，均有 $1\\le n\\le 10^5$，$1\\le m_i\\le 10^5$，$0\\le s_i\\le 10^9$，$0\\le p_{i,1}<p_{i,2}<\\cdots<p_{i,m_i}\\le s_i$，$\\sum m_i\\le 10^5$。\n\n| 子任务编号 |特殊限制| 分值 |\n| :-: | :-: | :--: |\n|$1$| $n\\le 8$，$m_i=1$，$s_i\\le 100$ | $8$  |\n|$2$|$n\\le 8$，$s_i\\le 100$| $8$  |\n|$3$|$n\\le 10^3$| $21$ |\n|$4$|$\\sum m_i>n$| $21$ |\n|$5$|$s_i\\le 100$| $21$ |\n|$6$|无特殊限制| $21$ |", "locale": "zh-CN"}}}
{"pid": "P9765", "type": "P", "difficulty": 1, "samples": [["30 12 7\n18 1 2021", "b"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2021", "ROIR（俄罗斯）"], "title": "[ROIR 2021] 日期 (Day 2)", "background": "**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day2 T1  [Календарь на Альфе Центавра](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day2.pdf)**。", "description": "在一颗外星球上，一年有 $m$ 个月，一个月有 $d$ 天，一周有 $w$ 天。\n\n为了区分每一周的每一天，人类使用了星期几来说明，而这颗外星球上的居民使用小写英文字母 `a`$\\sim$`z` 来表示每一周的每一天。\n\n已知 $1$ 年 $1$ 月 $1$ 日对应星期 `a`，求 $k$ 年 $j$ 月 $i$ 日对应星期几。", "inputFormat": "第一行为三个整数 $d,m,w$。\n\n第二行为三个整数 $i,j,k$。", "outputFormat": "仅一行一个字母，表示 $k$ 年 $j$ 月 $i$ 日对应星期几。", "hint": "【数据范围】：\n\n对于所有子任务，都有 $1\\le d,m\\le 100$，$1\\le w\\le 26$，$1\\le i\\le d$，$1\\le j\\le m$，$1\\le k\\le 10^9$。\n\n| 子任务编号 |      特殊限制      | 分值 |\n| :--------: | :----------------: | :--: |\n|    $1$     |      $d=m=1$       | $16$ |\n|    $2$     | $m=1$，$k\\le 10^7$ | $16$ |\n|    $3$     |      $i=j=1$       | $17$ |\n|    $4$     |       $k=1$        | $17$ |\n|    $5$     |     $k\\le 100$     | $17$ |\n|    $6$     |     无特殊限制     | $17$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2021] 日期 (Day 2)", "background": "**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day2 T1  [Календарь на Альфе Центавра](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day2.pdf)**。", "description": "在一颗外星球上，一年有 $m$ 个月，一个月有 $d$ 天，一周有 $w$ 天。\n\n为了区分每一周的每一天，人类使用了星期几来说明，而这颗外星球上的居民使用小写英文字母 `a`$\\sim$`z` 来表示每一周的每一天。\n\n已知 $1$ 年 $1$ 月 $1$ 日对应星期 `a`，求 $k$ 年 $j$ 月 $i$ 日对应星期几。", "inputFormat": "第一行为三个整数 $d,m,w$。\n\n第二行为三个整数 $i,j,k$。", "outputFormat": "仅一行一个字母，表示 $k$ 年 $j$ 月 $i$ 日对应星期几。", "hint": "【数据范围】：\n\n对于所有子任务，都有 $1\\le d,m\\le 100$，$1\\le w\\le 26$，$1\\le i\\le d$，$1\\le j\\le m$，$1\\le k\\le 10^9$。\n\n| 子任务编号 |      特殊限制      | 分值 |\n| :--------: | :----------------: | :--: |\n|    $1$     |      $d=m=1$       | $16$ |\n|    $2$     | $m=1$，$k\\le 10^7$ | $16$ |\n|    $3$     |      $i=j=1$       | $17$ |\n|    $4$     |       $k=1$        | $17$ |\n|    $5$     |     $k\\le 100$     | $17$ |\n|    $6$     |     无特殊限制     | $17$ |", "locale": "zh-CN"}}}
{"pid": "P9766", "type": "P", "difficulty": 3, "samples": [["700\n0", "777"], ["700\n1", "700"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2021", "ROIR（俄罗斯）"], "title": "[ROIR 2021] 好数 (Day 2)", "background": "**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day2 T2  [Числа](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day2.pdf)**。\n", "description": "定义第一类好数为所有数位上的数字均相同的数。\n\n定义第二类好数为满足如下任意一个条件的数：\n- 为第一类好数。\n- 设 $t$ 为数的位数，则有 $t-1$ 位数上的数字相同，且无前导零。\n\n现给定一个 $x$，求出 $\\ge x$ 的第一个第 $k+1$ 类好数 $y$。", "inputFormat": "第一行一个整数 $x$。\n\n第二行一个整数 $k$。", "outputFormat": "一行一个整数 $y$。", "hint": "对于所有子任务 $1\\le x\\le 10^{17}$，$k\\in\\{0,1\\}$。\n\n| 子任务编号 |        特殊限制         | 分值 |\n| :--------: | :---------------------: | :--: |\n|    $1$     | $1\\le x\\le 10^5$，$k=0$ | $15$ |\n|    $2$     |          $k=0$          | $20$ |\n|    $3$     |    $1\\le x\\le 10^5$     | $21$ |\n|    $4$     |       无特殊限制        | $44$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2021] 好数 (Day 2)", "background": "**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day2 T2  [Числа](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day2.pdf)**。\n", "description": "定义第一类好数为所有数位上的数字均相同的数。\n\n定义第二类好数为满足如下任意一个条件的数：\n- 为第一类好数。\n- 设 $t$ 为数的位数，则有 $t-1$ 位数上的数字相同，且无前导零。\n\n现给定一个 $x$，求出 $\\ge x$ 的第一个第 $k+1$ 类好数 $y$。", "inputFormat": "第一行一个整数 $x$。\n\n第二行一个整数 $k$。", "outputFormat": "一行一个整数 $y$。", "hint": "对于所有子任务 $1\\le x\\le 10^{17}$，$k\\in\\{0,1\\}$。\n\n| 子任务编号 |        特殊限制         | 分值 |\n| :--------: | :---------------------: | :--: |\n|    $1$     | $1\\le x\\le 10^5$，$k=0$ | $15$ |\n|    $2$     |          $k=0$          | $20$ |\n|    $3$     |    $1\\le x\\le 10^5$     | $21$ |\n|    $4$     |       无特殊限制        | $44$ |", "locale": "zh-CN"}}}
{"pid": "P9767", "type": "P", "difficulty": 4, "samples": [["2 2 2", "1 2\n2 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "2021", "Special Judge", "随机化", "Ad-hoc", "ROIR（俄罗斯）"], "title": "[ROIR 2021] 染色 (Day 2)", "background": "**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day2 T3  [Хорошие раскраски](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day2.pdf)**。", "description": "用 $c$ 种颜色对一个 $n\\times m$ 的矩阵染色，要求对于任意 $1\\le x_1<x_2\\le n$，$1\\le y_1<y_2\\le m$，$(x_1,y_1)$，$(x_2,y_1)$，$(x_1,y_2)$，$(x_2,y_2)$ 所染的颜色不完全相同。\n\n试构造一组方案。\n\n数据保证有解。", "inputFormat": "一行三个整数 $n,m,c$。", "outputFormat": "输出 $n$ 行，每一行 $m$ 个范围在 $1\\sim c$ 的整数，表示染色的颜色种类。", "hint": "- 对于 $25\\%$ 的数据，$c=2$。\n- 对于另外 $75\\%$ 的数据，$c=3$。\n- 对于 $100\\%$ 的数据，$2\\le n,m\\le 10$，$2\\le c\\le 3$。\n\n注：附件为本题的 Special Judge，供大家调试。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2021] 染色 (Day 2)", "background": "**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day2 T3  [Хорошие раскраски](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day2.pdf)**。", "description": "用 $c$ 种颜色对一个 $n\\times m$ 的矩阵染色，要求对于任意 $1\\le x_1<x_2\\le n$，$1\\le y_1<y_2\\le m$，$(x_1,y_1)$，$(x_2,y_1)$，$(x_1,y_2)$，$(x_2,y_2)$ 所染的颜色不完全相同。\n\n试构造一组方案。\n\n数据保证有解。", "inputFormat": "一行三个整数 $n,m,c$。", "outputFormat": "输出 $n$ 行，每一行 $m$ 个范围在 $1\\sim c$ 的整数，表示染色的颜色种类。", "hint": "- 对于 $25\\%$ 的数据，$c=2$。\n- 对于另外 $75\\%$ 的数据，$c=3$。\n- 对于 $100\\%$ 的数据，$2\\le n,m\\le 10$，$2\\le c\\le 3$。\n\n注：附件为本题的 Special Judge，供大家调试。", "locale": "zh-CN"}}}
{"pid": "P9768", "type": "P", "difficulty": 5, "samples": [["123\n123\n246", "6"], ["01\n02\n03", "1"], ["01211\n12099\n23300", "4"], ["121\n214\n999", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2021", "ROIR（俄罗斯）"], "title": "[ROIR 2021] A+B (Day 2)", "background": "**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day2 T4  [A+B](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day2.pdf)**。", "description": "有三个长为 $n$ 的可能含前导零的整数 $a,b,c$，按如下方式排成三行 $n$ 列：\n\n```\na\nb\nc\n```\n问有多少种不同的**列**的排列方式，使得被横着念出来的三个整数 $x,y,z$ 有 $x+y=z$ 成立且三个整数均没有前导零。\n\n排列方式的个数可能很多，输出其 $\\bmod \\ 10^9+7$ 即可。", "inputFormat": "第一行为一个长 $n$ 的整数 $a$。\n\n第二行为一个长 $n$ 的整数 $b$。\n\n第三行为一个长 $n$ 的整数 $c$。", "outputFormat": "一行一个整数，表示不同的排列方式的个数对 $10^9+7$ 取模的结果。", "hint": "【样例解释1】：所有排列方式均可。\n\n【样例解释2】：我们只计算 $10+20=30$，而不计算 $01+02=03$，因为 $03$ 含前导零。\n\n【样例解释3】：显然有 $10121 + 21909 = 32030$ 与 $12101 + 20919 = 33020$ 两种合法等式，但由于有两个相同的列，所以它们都有两种方式得到答案，总方案数为 $2\\times 2=4$。\n\n【数据范围】：\n\n对于所有子任务，有 $2\\le n\\le 2\\times 10^5$。\n\n| 子任务编号 |特殊限制| 分值 |\n| :-: | :-: | :-: |\n|$1$|$n\\le 6$| $7$  |\n|$2$|$n\\le 18$| $14$ |\n|$3$| $n\\le 200$，读入的数字中不含 $0$ | $15$ |\n|$4$|$n\\le 200$| $5$  |\n|$5$| $n\\le 750$，读入的数字中不含 $0$ | $17$ |\n|$6$|$n\\le 750$| $5$  |\n|$7$|读入的数字中不含 $0$| $20$ |\n|$8$|无特殊限制| $17$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2021] A+B (Day 2)", "background": "**译自 [ROIR 2021](http://neerc.ifmo.ru/school/archive/2020-2021.html) Day2 T4  [A+B](http://neerc.ifmo.ru/school/archive/2020-2021/ru-olymp-regional-2021-day2.pdf)**。", "description": "有三个长为 $n$ 的可能含前导零的整数 $a,b,c$，按如下方式排成三行 $n$ 列：\n\n```\na\nb\nc\n```\n问有多少种不同的**列**的排列方式，使得被横着念出来的三个整数 $x,y,z$ 有 $x+y=z$ 成立且三个整数均没有前导零。\n\n排列方式的个数可能很多，输出其 $\\bmod \\ 10^9+7$ 即可。", "inputFormat": "第一行为一个长 $n$ 的整数 $a$。\n\n第二行为一个长 $n$ 的整数 $b$。\n\n第三行为一个长 $n$ 的整数 $c$。", "outputFormat": "一行一个整数，表示不同的排列方式的个数对 $10^9+7$ 取模的结果。", "hint": "【样例解释1】：所有排列方式均可。\n\n【样例解释2】：我们只计算 $10+20=30$，而不计算 $01+02=03$，因为 $03$ 含前导零。\n\n【样例解释3】：显然有 $10121 + 21909 = 32030$ 与 $12101 + 20919 = 33020$ 两种合法等式，但由于有两个相同的列，所以它们都有两种方式得到答案，总方案数为 $2\\times 2=4$。\n\n【数据范围】：\n\n对于所有子任务，有 $2\\le n\\le 2\\times 10^5$。\n\n| 子任务编号 |特殊限制| 分值 |\n| :-: | :-: | :-: |\n|$1$|$n\\le 6$| $7$  |\n|$2$|$n\\le 18$| $14$ |\n|$3$| $n\\le 200$，读入的数字中不含 $0$ | $15$ |\n|$4$|$n\\le 200$| $5$  |\n|$5$| $n\\le 750$，读入的数字中不含 $0$ | $17$ |\n|$6$|$n\\le 750$| $5$  |\n|$7$|读入的数字中不含 $0$| $20$ |\n|$8$|无特殊限制| $17$ |", "locale": "zh-CN"}}}
{"pid": "P9769", "type": "P", "difficulty": 3, "samples": [["10 3 1\n2\n", "3\n"], ["100 6 3\n2 3 5\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "单调队列", "2023", "O2优化", "动态规划优化", "高校校赛"], "title": "[HUSTFC 2023] 简单的加法乘法计算题", "background": "", "description": "JokerShaco 有一个数字 $x$，最开始 $x=0$，他想要把 $x$ 变成 $y$。为了达到这个目标，他可以利用两个集合 $A$ 和 $B$。其中集合 $A$ 包含 $n$ 个元素，分别是从 $1$ 到 $n$ 的所有正整数；集合 $B$ 包含 $m$ 个元素。每次它可以对 $x$ 进行如下任意次操作：\n- 选择 $A$ 中的一个元素 $a$，令 $x$ 加上 $a$。\n- 选择 $B$ 中的一个元素 $b$，令 $x$ 乘以 $b$。\n\n已知 $y$，$n$，$m$ 和 $B$ 中 $m$ 个元素的具体值，JokerShaco 想知道让 $x$ 变成 $y$ 的最少操作次数。", "inputFormat": "第一行包含三个整数 $y\\ (1\\le y\\le 5\\cdot 10^6)$，$n\\ (1\\le n\\le 5\\cdot 10^6)$ 和 $m\\ (1\\le m\\le 10)$，其含义如题目所述。\n\n第二行包含 $m$ 个正整数，其中第 $i$ 个表示 $B$ 中的第 $i$ 个元素 $b_i\\ (1\\le b_i\\le 5\\cdot 10^6)$。", "outputFormat": "输出一个整数，表示让 $x$ 变成 $y$ 的最少操作次数。在题目条件下可知一定能将 $x$ 变成 $y$。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[HUSTFC 2023] 简单的加法乘法计算题", "background": "", "description": "JokerShaco 有一个数字 $x$，最开始 $x=0$，他想要把 $x$ 变成 $y$。为了达到这个目标，他可以利用两个集合 $A$ 和 $B$。其中集合 $A$ 包含 $n$ 个元素，分别是从 $1$ 到 $n$ 的所有正整数；集合 $B$ 包含 $m$ 个元素。每次它可以对 $x$ 进行如下任意次操作：\n- 选择 $A$ 中的一个元素 $a$，令 $x$ 加上 $a$。\n- 选择 $B$ 中的一个元素 $b$，令 $x$ 乘以 $b$。\n\n已知 $y$，$n$，$m$ 和 $B$ 中 $m$ 个元素的具体值，JokerShaco 想知道让 $x$ 变成 $y$ 的最少操作次数。", "inputFormat": "第一行包含三个整数 $y\\ (1\\le y\\le 5\\cdot 10^6)$，$n\\ (1\\le n\\le 5\\cdot 10^6)$ 和 $m\\ (1\\le m\\le 10)$，其含义如题目所述。\n\n第二行包含 $m$ 个正整数，其中第 $i$ 个表示 $B$ 中的第 $i$ 个元素 $b_i\\ (1\\le b_i\\le 5\\cdot 10^6)$。", "outputFormat": "输出一个整数，表示让 $x$ 变成 $y$ 的最少操作次数。在题目条件下可知一定能将 $x$ 变成 $y$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9770", "type": "P", "difficulty": 6, "samples": [["5\n0 0 1 2 3\n", "1 2 1 2 1 "], ["11\n0 0 0 0 2 1 0 0 3 0 1\n", "1 2 3 1 2 1 1 2 3 4 1 "]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2023", "O2优化", "高校校赛"], "title": "[HUSTFC 2023] 逆 KMP", "background": "", "description": "Walk Alone 是一个字符串大师，但是他已经对传统的字符串算法感到无聊，如 KMP 算法，所以他最近在思考逆向的 KMP。下面是他提出的问题：\n\n给你一个长度为 $n$ 的整数序列 $a$，对于任意的整数 $i\\ (1\\le i\\le n)$，满足 $0\\le a_i<i$。你需要构造另一个整数序列 $s$，满足以下条件：\n- 序列 $s$ 的长度为 $n$，并且其中任意元素 $s_i$ 满足 $1\\le s_i\\le n$；\n- 对于所有的整数 $i\\ (1\\le i\\le n)$ 和 $j\\ (1\\le j\\le a_i)$，满足 $s_{j}=s_{i-a_i+j}$；\n- 满足上述条件的前提下，序列 $s$ 中出现的不同元素的数量**最多**。\n\n当然，Walk Alone 可以很轻松地解决这道题，但他想把这道题当作对你的考验。\n", "inputFormat": "第一行包含一个整数 $n\\ (1\\le n\\le 2\\cdot 10^5)$，表示序列 $a$ 的长度。\n\n第二行包含 $n$ 个整数，其中第 $i$ 个整数定义为 $a_i\\ (0\\le a_i<i)$。", "outputFormat": "输出用空格间隔的 $n$ 个整数，其中第 $i$ 个整数定义为 $s_i$。如果存在多个合法答案，请输出字典序最小的那个。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[HUSTFC 2023] 逆 KMP", "background": "", "description": "Walk Alone 是一个字符串大师，但是他已经对传统的字符串算法感到无聊，如 KMP 算法，所以他最近在思考逆向的 KMP。下面是他提出的问题：\n\n给你一个长度为 $n$ 的整数序列 $a$，对于任意的整数 $i\\ (1\\le i\\le n)$，满足 $0\\le a_i<i$。你需要构造另一个整数序列 $s$，满足以下条件：\n- 序列 $s$ 的长度为 $n$，并且其中任意元素 $s_i$ 满足 $1\\le s_i\\le n$；\n- 对于所有的整数 $i\\ (1\\le i\\le n)$ 和 $j\\ (1\\le j\\le a_i)$，满足 $s_{j}=s_{i-a_i+j}$；\n- 满足上述条件的前提下，序列 $s$ 中出现的不同元素的数量**最多**。\n\n当然，Walk Alone 可以很轻松地解决这道题，但他想把这道题当作对你的考验。\n", "inputFormat": "第一行包含一个整数 $n\\ (1\\le n\\le 2\\cdot 10^5)$，表示序列 $a$ 的长度。\n\n第二行包含 $n$ 个整数，其中第 $i$ 个整数定义为 $a_i\\ (0\\le a_i<i)$。", "outputFormat": "输出用空格间隔的 $n$ 个整数，其中第 $i$ 个整数定义为 $s_i$。如果存在多个合法答案，请输出字典序最小的那个。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9771", "type": "P", "difficulty": 2, "samples": [["5\n1 2 3 5 4\n", "1\n"], ["3\n3 2 1\n", "0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2023", "O2优化", "高校校赛"], "title": "[HUSTFC 2023] 排列排序问题", "background": "", "description": "JokerShaco 有一个长度为 $n$ 的排列 $p$，他认为一个排列必须是有序的，所以他打算将其进行排序。\n\n他可以对这个排列进行如下操作：\n- 将这个排列切割成若干个序列（也可以不切割，保持原样），每个序列至少含有一个元素；\n- 选择其中一些序列并将它们翻转；\n- 将这些序列按照他的意愿重新组合拼接得到一个新的排列。\n\nJokerShaco 认为切割操作非常累，他想知道如果必须把这个排列变得有序，至少需要切割多少次。\n\n一个长度为 $n$ 的排列的定义为，包含从 $1$ 到 $n$ 这 $n$ 个不同的整数的序列，每个整数恰好出现一次。\n\n序列翻转的定义为，假设存在一个长度为 $m$ 的序列 $[a_1,a_2,\\dots,a_{m-1},a_m]$，那么将这个序列翻转后将会得到 $[a_m,a_{m-1},\\dots,a_2,a_1]$。", "inputFormat": "第一行包含一个整数 $n\\ (1\\le n\\le 10^6$)，表示排列 $p$ 的长度。\n\n第二行包含 $n$ 个整数，其中第 $i$ 个整数定义为 $p_i$。保证输入的 $p$ 一定是长度为 $n$ 的排列。", "outputFormat": "输出一个整数，表示将排列 $p$ 变得有序所需的最少切割次数。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[HUSTFC 2023] 排列排序问题", "background": "", "description": "JokerShaco 有一个长度为 $n$ 的排列 $p$，他认为一个排列必须是有序的，所以他打算将其进行排序。\n\n他可以对这个排列进行如下操作：\n- 将这个排列切割成若干个序列（也可以不切割，保持原样），每个序列至少含有一个元素；\n- 选择其中一些序列并将它们翻转；\n- 将这些序列按照他的意愿重新组合拼接得到一个新的排列。\n\nJokerShaco 认为切割操作非常累，他想知道如果必须把这个排列变得有序，至少需要切割多少次。\n\n一个长度为 $n$ 的排列的定义为，包含从 $1$ 到 $n$ 这 $n$ 个不同的整数的序列，每个整数恰好出现一次。\n\n序列翻转的定义为，假设存在一个长度为 $m$ 的序列 $[a_1,a_2,\\dots,a_{m-1},a_m]$，那么将这个序列翻转后将会得到 $[a_m,a_{m-1},\\dots,a_2,a_1]$。", "inputFormat": "第一行包含一个整数 $n\\ (1\\le n\\le 10^6$)，表示排列 $p$ 的长度。\n\n第二行包含 $n$ 个整数，其中第 $i$ 个整数定义为 $p_i$。保证输入的 $p$ 一定是长度为 $n$ 的排列。", "outputFormat": "输出一个整数，表示将排列 $p$ 变得有序所需的最少切割次数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9772", "type": "P", "difficulty": 3, "samples": [["1\n", "Kelin\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144]}, "tags": ["2023", "O2优化", "高校校赛"], "title": "[HUSTFC 2023] 网格染色", "background": "", "description": "有一个由 $n\\times n$ 个小正方形组成的网格图，其中每个小正方形的边长为 $1$，Walk Alone 和 Kelin 在这上面进行一场染色游戏，游戏的规则如下：\n- Walk Alone 和 Kelin 轮流进行操作，Walk Alone 先手。\n- 当轮到 Walk Alone 操作时，他选择一条尚未被染色的正方形边框并将其染成**红色**。操作结束时，如果这条边框是一个（或两个）正方形最后一条被染色的边框，则自动将该正方形也同样染成**红色**。\n- 当轮到 Kelin 操作时，他选择一条尚未被染色的正方形边框并将其染成**蓝色**。操作结束时，如果这条边框是一个（或两个）正方形最后一条被染色的边框，则自动将该正方形也同样染成**蓝色**。\n- 当所有的边框都被染色后，游戏结束。此时染成自己所属颜色的正方形数量更多的一方获胜；或者当数量相等时，达成平局。\n\n例如，在 $2\\times 2$ 的网格图中，一种可能的游戏过程如下：\n\n![1](https://cdn.luogu.com.cn/upload/image_hosting/zkbfy296.png)\n\n已知网格图的边长 $n$，如果两人都积极进行游戏（按照最优策略，尽可能地让自己获胜，或者在自己无法获胜的前提下尽可能地达成平局），请你推断哪一方会获胜或达成平局。\n", "inputFormat": "一行包含一个整数 $n\\ (1\\le n\\le 10^9$)，表示网格图的边长。", "outputFormat": "如果 Walk Alone 获胜，输出 `Walk Alone`；否则如果 Kelin 获胜，输出 `Kelin`；否则平局输出 `Draw`。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[HUSTFC 2023] 网格染色", "background": "", "description": "有一个由 $n\\times n$ 个小正方形组成的网格图，其中每个小正方形的边长为 $1$，Walk Alone 和 Kelin 在这上面进行一场染色游戏，游戏的规则如下：\n- Walk Alone 和 Kelin 轮流进行操作，Walk Alone 先手。\n- 当轮到 Walk Alone 操作时，他选择一条尚未被染色的正方形边框并将其染成**红色**。操作结束时，如果这条边框是一个（或两个）正方形最后一条被染色的边框，则自动将该正方形也同样染成**红色**。\n- 当轮到 Kelin 操作时，他选择一条尚未被染色的正方形边框并将其染成**蓝色**。操作结束时，如果这条边框是一个（或两个）正方形最后一条被染色的边框，则自动将该正方形也同样染成**蓝色**。\n- 当所有的边框都被染色后，游戏结束。此时染成自己所属颜色的正方形数量更多的一方获胜；或者当数量相等时，达成平局。\n\n例如，在 $2\\times 2$ 的网格图中，一种可能的游戏过程如下：\n\n![1](https://cdn.luogu.com.cn/upload/image_hosting/zkbfy296.png)\n\n已知网格图的边长 $n$，如果两人都积极进行游戏（按照最优策略，尽可能地让自己获胜，或者在自己无法获胜的前提下尽可能地达成平局），请你推断哪一方会获胜或达成平局。\n", "inputFormat": "一行包含一个整数 $n\\ (1\\le n\\le 10^9$)，表示网格图的边长。", "outputFormat": "如果 Walk Alone 获胜，输出 `Walk Alone`；否则如果 Kelin 获胜，输出 `Kelin`；否则平局输出 `Draw`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9773", "type": "P", "difficulty": 6, "samples": [["3\n1 3\n2 3\n1 2\n0", "2\n"], ["6\n2 5\n3 6\n2 5\n4 6\n1 3\n1 4\n8", "28\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "O2优化", "高校校赛"], "title": "[HUSTFC 2023] 序列配对", "background": "", "description": "你有一个长度为 $n$ 的序列 $a_1,a_2,\\dots,a_n$，初始序列内任意元素 $a_i=0$。\n\n之后会告诉你 $n$ 组配对信息，每组配对信息形如整数对 $(l,r)$，表示将 $a_l$ 和 $a_r$ 进行配对。在配对之后，你必须执行下面两种操作之一（不可全选）：\n- 令 $a_l$ 加 $1$，随后 $a_r$ 减 $1$。\n- 令 $a_r$ 加 $1$，随后 $a_l$ 减 $1$。\n\n你得知这些配对信息遵循着一个奇妙的规定：在 $n$ 组整数对内的 $2n$ 个整数中，每个序列的下标都恰好出现 $2$ 次！\n\n此时你想知道，在所有操作方案中，使 $\\sum_{i=1}^n{a_i}^2=k$ 的方案数，由于答案可能会很大，你只需要求出其对 $998\\,244\\,353$ 取模后的结果。\n", "inputFormat": "第一行包含一个整数 $n\\ (1\\le n\\le 2\\cdot 10^5)$，表示序列的长度。\n\n接下来 $n$ 行，其中第 $i$ 行包含两个整数 $l_i,r_i\\ (1\\le l\\le r \\le n)$，表示第 $i$ 组配对信息。保证输入的这 $2n$ 个整数符合题目要求。\n\n最后一行包含一个整数 $k\\ (0\\le k \\le 10^9)$，其含义如题目所述。", "outputFormat": "输出一个整数，表示使 $\\sum_{i=1}^n{a_i}^2=k$ 的方案数对 $998\\,244\\,353$ 取模后的结果。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[HUSTFC 2023] 序列配对", "background": "", "description": "你有一个长度为 $n$ 的序列 $a_1,a_2,\\dots,a_n$，初始序列内任意元素 $a_i=0$。\n\n之后会告诉你 $n$ 组配对信息，每组配对信息形如整数对 $(l,r)$，表示将 $a_l$ 和 $a_r$ 进行配对。在配对之后，你必须执行下面两种操作之一（不可全选）：\n- 令 $a_l$ 加 $1$，随后 $a_r$ 减 $1$。\n- 令 $a_r$ 加 $1$，随后 $a_l$ 减 $1$。\n\n你得知这些配对信息遵循着一个奇妙的规定：在 $n$ 组整数对内的 $2n$ 个整数中，每个序列的下标都恰好出现 $2$ 次！\n\n此时你想知道，在所有操作方案中，使 $\\sum_{i=1}^n{a_i}^2=k$ 的方案数，由于答案可能会很大，你只需要求出其对 $998\\,244\\,353$ 取模后的结果。\n", "inputFormat": "第一行包含一个整数 $n\\ (1\\le n\\le 2\\cdot 10^5)$，表示序列的长度。\n\n接下来 $n$ 行，其中第 $i$ 行包含两个整数 $l_i,r_i\\ (1\\le l\\le r \\le n)$，表示第 $i$ 组配对信息。保证输入的这 $2n$ 个整数符合题目要求。\n\n最后一行包含一个整数 $k\\ (0\\le k \\le 10^9)$，其含义如题目所述。", "outputFormat": "输出一个整数，表示使 $\\sum_{i=1}^n{a_i}^2=k$ 的方案数对 $998\\,244\\,353$ 取模后的结果。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9774", "type": "P", "difficulty": 4, "samples": [["3 7\n11\n45\n14", "4\n1\n2\n"], ["2 10007\n1919\n810", "3152\n3679\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2023", "O2优化", "高校校赛"], "title": "[HUSTFC 2023] 新取模运算", "background": "", "description": "在这道题中，我们定义一个新的运算符号 $\\oplus$ 并将其称为新取模运算。\n\n当计算 $x \\oplus y$ 时，如果 $x$ 不是 $y$ 的倍数，则得到 $x$ 除以 $y$ 的余数; 否则令 $x$ 不断除以 $y$ 直到 $x$ 不再是 $y$ 的倍数，假设它为 $x'$，然后得到 $x'$ 除以 $y$ 的余数。例如，$4\\oplus 5=4$，$20\\oplus 5=4$，$100\\oplus 5=4$。\n\n给定一个质数 $p$，接下来会有多组询问，对于每次询问会给出一个整数 $n$，你需要计算出 $n!\\oplus p$ 的值。其中 $n!$ 是 $n$ 的阶乘，即所有小于等于 $n$ 的正整数的乘积。", "inputFormat": "第一行包含两个整数 $T\\ (1\\le T\\le 10^5)$ 和 $p\\ (2\\le p\\le 10^6)$，分别表示询问的次数和给定的质数。\n\n接下来 $T$ 行，每行包含一个整数 $n\\ (1\\le n\\le 10^{18})$，含义如题目所述。", "outputFormat": "对于每次询问，输出一行包含一个整数，即 $n!\\oplus p$ 的值。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[HUSTFC 2023] 新取模运算", "background": "", "description": "在这道题中，我们定义一个新的运算符号 $\\oplus$ 并将其称为新取模运算。\n\n当计算 $x \\oplus y$ 时，如果 $x$ 不是 $y$ 的倍数，则得到 $x$ 除以 $y$ 的余数; 否则令 $x$ 不断除以 $y$ 直到 $x$ 不再是 $y$ 的倍数，假设它为 $x'$，然后得到 $x'$ 除以 $y$ 的余数。例如，$4\\oplus 5=4$，$20\\oplus 5=4$，$100\\oplus 5=4$。\n\n给定一个质数 $p$，接下来会有多组询问，对于每次询问会给出一个整数 $n$，你需要计算出 $n!\\oplus p$ 的值。其中 $n!$ 是 $n$ 的阶乘，即所有小于等于 $n$ 的正整数的乘积。", "inputFormat": "第一行包含两个整数 $T\\ (1\\le T\\le 10^5)$ 和 $p\\ (2\\le p\\le 10^6)$，分别表示询问的次数和给定的质数。\n\n接下来 $T$ 行，每行包含一个整数 $n\\ (1\\le n\\le 10^{18})$，含义如题目所述。", "outputFormat": "对于每次询问，输出一行包含一个整数，即 $n!\\oplus p$ 的值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9775", "type": "P", "difficulty": 5, "samples": [["4\n1 2 3 4\n2 3 2 3\n2 7\n3 6\n4 5\n", "75 207 390 974 "]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2023", "O2优化", "高校校赛"], "title": "[HUSTFC 2023] 广义线段树", "background": "", "description": "对于任意长度为 $n$ 的序列 $a$，可以基于 $a$ 建立一个广义线段树。广义线段树是一个有 $(2n-1)$ 个节点的带权二叉树，对于每个编号为 $p$ 的节点，都有两个属性 $L_p$ 和 $R_p$，表示其维护的区间为 $[L_p,R_p]$，同时其权值 $M_p =\\prod_{i=L_p}^{R_p}a_i$ 。另外，广义线段树还满足如下性质：\n- 所有编号为 $p\\in [n,2n-1]$ 的节点是叶节点，同时 $L_p = R_p = p + 1 - n$。\n- 所有编号为 $p\\in [1,n-1]$ 的节点是非叶节点，其必定有左儿子 $X_p$ 和右儿子 $Y_p$，且 $p < X_p < Y_p$。节点 $p$ 维护的区间为左右儿子维护区间之并，且保证维护区间连续。形式化地，有 $R_{X_p}=L_{Y_p}-1$，且 $L_p=L_{X_p}$，$R_p=R_{Y_p}$。\n\n例如，下面是一个基于 $n=4$ 的序列 $a=\\{1, 2, 3, 4\\}$ 建立的广义线段树（节点内整数对 $(p,M_p)$ 分别表示编号和权值）。可以发现，广义线段树的形态并不唯一。\n\n![1](https://cdn.luogu.com.cn/upload/image_hosting/de71i68l.png)\n\n对这个广义线段树而言：\n- $[L_7, R_7] = [4, 4]$，故 $M_7 = a_4$\n- $[L_6, R_6] = [3, 3]$，故 $M_6 = a_3$\n- $[L_5, R_5] = [2, 2]$，故 $M_5 = a_2$\n- $[L_4, R_4] = [1, 1]$，故 $M_4 = a_1$\n- $[L_3, R_3] = [L_4, R_5] = [1, 2]$，故 $M_3 = a_1 \\times a_2$\n- $[L_2, R_2] = [L_3, R_6] = [1, 3]$，故 $M_2 = a_1 \\times a_2 \\times a_3$\n- $[L_1, R_1] = [L_2, R_7] = [1, 4]$，故 $M_1 = a_1 \\times a_2 \\times a_3 \\times a_4$\n\n分别给定长度为 $n$ 的序列 $a$，$b$ 以及节点数为 $(2n-1)$ 的广义线段树 $T$ 的形态（即每个节点的左右儿子编号），然后你需要执行 $n$ 次操作，第 $i$ 次操作为将 $a_i$ 变成 $a_i\\times b_i$。\n\n每次操作结束后，你需要基于修改后的序列 $a$ 建立与 $T$ 形态相同的广义线段树，并求出所有节点的权值和，即 $\\sum_{i=1}^{2n-1}M_i$。由于结果可能会非常大，你只需要求出其对 $998\\,244\\,353$ 取模后的值。", "inputFormat": "第一行包含一个整数 $n\\ (1\\le n\\le 5\\cdot 10^5)$，表示序列 $a$ 和 $b$ 的长度。\n\n第二行包含 $n$ 个整数，其中第 $i$ 个整数定义为 $a_i\\ (1 \\le a_i < 998\\,244\\,353)$。\n\n第三行包含 $n$ 个整数，其中第 $i$ 个整数定义为 $b_i\\ (1 \\le b_i < 998\\,244\\,353)$。\n\n接下来 $n-1$ 行，其中第 $i$ 行包含两个整数 $X_i,Y_i\\ (i<X_i<Y_i\\le 2n-1)$，分别表示节点 $i$ 的左右儿子编号。保证输入的广义线段树形态符合题目要求。", "outputFormat": "输出一行用空格间隔的 $n$ 个整数，其中第 $i$ 个整数表示第 $i$ 次修改后的答案对 $998\\,244\\,353$ 取模后的值。", "hint": "样例中广义线段树的形态和题面中的例子相同。\n\n第一次修改后，$a_1$ 变为 $a_1 \\times b_1 = 1 \\times 2 = 2$，因而新的 $a = \\{2, 2, 3, 4\\}$。可以计算出：\n- $M_7 = a_4 = 4$\n- $M_6 = a_3 = 3$\n- $M_5 = a_2 = 2$\n- $M_4 = a_1 = 2$\n- $M_3 = a_1 \\times a_2 = 2 \\times 2 = 4$\n- $M_2 = a_1 \\times a_2 \\times a_3 = 2 \\times 2 \\times 3 = 12$\n- $M_1 = a_1 \\times a_2 \\times a_3 \\times a_4 = 2 \\times 2 \\times 3 \\times 4 = 48$\n\n故权值之和为 $M_1 + M_2 + \\ldots + M_7 = 75$。\n\n第二次修改后，$a_2$ 变为 $a_2 \\times b_2 = 2 \\times 3 = 6$。后续的操作与第一次操作类似，此处不再赘述。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[HUSTFC 2023] 广义线段树", "background": "", "description": "对于任意长度为 $n$ 的序列 $a$，可以基于 $a$ 建立一个广义线段树。广义线段树是一个有 $(2n-1)$ 个节点的带权二叉树，对于每个编号为 $p$ 的节点，都有两个属性 $L_p$ 和 $R_p$，表示其维护的区间为 $[L_p,R_p]$，同时其权值 $M_p =\\prod_{i=L_p}^{R_p}a_i$ 。另外，广义线段树还满足如下性质：\n- 所有编号为 $p\\in [n,2n-1]$ 的节点是叶节点，同时 $L_p = R_p = p + 1 - n$。\n- 所有编号为 $p\\in [1,n-1]$ 的节点是非叶节点，其必定有左儿子 $X_p$ 和右儿子 $Y_p$，且 $p < X_p < Y_p$。节点 $p$ 维护的区间为左右儿子维护区间之并，且保证维护区间连续。形式化地，有 $R_{X_p}=L_{Y_p}-1$，且 $L_p=L_{X_p}$，$R_p=R_{Y_p}$。\n\n例如，下面是一个基于 $n=4$ 的序列 $a=\\{1, 2, 3, 4\\}$ 建立的广义线段树（节点内整数对 $(p,M_p)$ 分别表示编号和权值）。可以发现，广义线段树的形态并不唯一。\n\n![1](https://cdn.luogu.com.cn/upload/image_hosting/de71i68l.png)\n\n对这个广义线段树而言：\n- $[L_7, R_7] = [4, 4]$，故 $M_7 = a_4$\n- $[L_6, R_6] = [3, 3]$，故 $M_6 = a_3$\n- $[L_5, R_5] = [2, 2]$，故 $M_5 = a_2$\n- $[L_4, R_4] = [1, 1]$，故 $M_4 = a_1$\n- $[L_3, R_3] = [L_4, R_5] = [1, 2]$，故 $M_3 = a_1 \\times a_2$\n- $[L_2, R_2] = [L_3, R_6] = [1, 3]$，故 $M_2 = a_1 \\times a_2 \\times a_3$\n- $[L_1, R_1] = [L_2, R_7] = [1, 4]$，故 $M_1 = a_1 \\times a_2 \\times a_3 \\times a_4$\n\n分别给定长度为 $n$ 的序列 $a$，$b$ 以及节点数为 $(2n-1)$ 的广义线段树 $T$ 的形态（即每个节点的左右儿子编号），然后你需要执行 $n$ 次操作，第 $i$ 次操作为将 $a_i$ 变成 $a_i\\times b_i$。\n\n每次操作结束后，你需要基于修改后的序列 $a$ 建立与 $T$ 形态相同的广义线段树，并求出所有节点的权值和，即 $\\sum_{i=1}^{2n-1}M_i$。由于结果可能会非常大，你只需要求出其对 $998\\,244\\,353$ 取模后的值。", "inputFormat": "第一行包含一个整数 $n\\ (1\\le n\\le 5\\cdot 10^5)$，表示序列 $a$ 和 $b$ 的长度。\n\n第二行包含 $n$ 个整数，其中第 $i$ 个整数定义为 $a_i\\ (1 \\le a_i < 998\\,244\\,353)$。\n\n第三行包含 $n$ 个整数，其中第 $i$ 个整数定义为 $b_i\\ (1 \\le b_i < 998\\,244\\,353)$。\n\n接下来 $n-1$ 行，其中第 $i$ 行包含两个整数 $X_i,Y_i\\ (i<X_i<Y_i\\le 2n-1)$，分别表示节点 $i$ 的左右儿子编号。保证输入的广义线段树形态符合题目要求。", "outputFormat": "输出一行用空格间隔的 $n$ 个整数，其中第 $i$ 个整数表示第 $i$ 次修改后的答案对 $998\\,244\\,353$ 取模后的值。", "hint": "样例中广义线段树的形态和题面中的例子相同。\n\n第一次修改后，$a_1$ 变为 $a_1 \\times b_1 = 1 \\times 2 = 2$，因而新的 $a = \\{2, 2, 3, 4\\}$。可以计算出：\n- $M_7 = a_4 = 4$\n- $M_6 = a_3 = 3$\n- $M_5 = a_2 = 2$\n- $M_4 = a_1 = 2$\n- $M_3 = a_1 \\times a_2 = 2 \\times 2 = 4$\n- $M_2 = a_1 \\times a_2 \\times a_3 = 2 \\times 2 \\times 3 = 12$\n- $M_1 = a_1 \\times a_2 \\times a_3 \\times a_4 = 2 \\times 2 \\times 3 \\times 4 = 48$\n\n故权值之和为 $M_1 + M_2 + \\ldots + M_7 = 75$。\n\n第二次修改后，$a_2$ 变为 $a_2 \\times b_2 = 2 \\times 3 = 6$。后续的操作与第一次操作类似，此处不再赘述。", "locale": "zh-CN"}}}
{"pid": "P9776", "type": "P", "difficulty": 6, "samples": [["5\n1 2 3 3 2 1 7 7\n5\n1 2 4 3\n3 1 5\n2 5 7 5\n3 2 5\n3 1 5\n", "18\n29\n38\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2023", "O2优化", "高校校赛"], "title": "[HUSTFC 2023] 狭义线段树", "background": "", "description": "你打算建立一棵有 $(2n - 1)$ 个节点，其中有 $n$ 个叶子节点的二叉树。具体地，建立这棵树的伪代码如图所示。\n\n![1](https://cdn.luogu.com.cn/upload/image_hosting/eex8x40p.png)\n\n不难发现，节点 $1$ 是根节点，并且所有节点的编号与其 DFS 序相同。另外，你认为叶子节点十分重要，因此你按照节点编号从小到大又把这 $n$ 个叶子节点分别称为 $1$ 号叶子，$2$ 号叶子，$\\dots$，$n$ 号叶子。叶子节点会被其上方的节点管辖，具体来说，如果 $i$ 号叶子在节点 $j$ 的子树内，则称节点 $j$ 管辖 $i$ 号叶子，不妨用 $g(j,i)=1$ 表示；否则若节点 $j$ 不管辖 $i$ 号叶子，则 $g(j,i)=0$。注意，叶子节点同时也管辖自己本身。\n\n同时，你认为一个好的二叉树要有点权，于是对于节点 $i$，定义其点权为 $v_i$。初始所有节点的点权都为 $0$。\n\n在一次梦中，你正在改造这棵二叉树。你将会对这棵二叉树依次执行 $q$ 次操作，每次操作的格式和描述如下：\n- $1\\ s\\ t\\ v$：对于所有的整数 $i\\ (i\\in [s,t])$，将节点 $i$ 的点权加 $v$。\n- $2\\ s\\ t\\ v$：令 $\\mathcal{S}={\\textstyle \\bigcup_{i\\in [s,t]}}S_i$，其中 $S_i$ 表示节点 $i$ 管辖的叶子节点的集合。然后对于 $\\mathcal{S}$ 中所有叶子节点，将其点权加 $v$。注意 $\\mathcal{S}$ 是不重复集合，即在本次操作中，每个叶子节点最多被修改一次。\n- $3\\ l\\ r$：计算 $\\sum^{r}_{i=l}f(i)\\bmod 998\\,244\\,353$，其中 $f(i)$ 表示管辖 $i$ 号叶子的所有节点的点权之和，即 $f(i)=\\sum_{g(j,i)=1}{v_j}$。\n\n你还想再加点操作，但是早八的铃声把你吵醒了，不过你还是决定实现一下这个奇思妙想。", "inputFormat": "第一行包含一个整数 $n\\ (3\\le n\\le 10^5)$，表示二叉树中叶子节点的数量。\n\n第二行包含 $(2n-2)$ 个整数，其中第 $i$ 个整数表示节点 $i+1$ 的父亲节点编号。保证给出的树的形态与节点编号和题目所描述的相同。\n\n第三行包含一个整数 $q\\ (3\\le q\\le 10^5)$，表示操作次数。\n\n接下来 $q$ 行，每行第一个整数 $opt\\ (opt\\in [1, 3])$ 表示操作类型，若 $opt=1$ 或 $opt=2$，则紧跟三个整数 $s,t,v\\ (1\\le s\\le t\\le 2n-1,\\ 0\\le v<998\\,244\\,353)$，表示一次修改操作；若 $opt=3$，则紧跟两个整数 $l,r\\ (1\\le l\\le r\\le n)$，表示一次询问操作。所有参数的含义如题目所述。", "outputFormat": "对于每个 $opt=3$ 的操作，输出一行一个整数，表示本次询问的结果。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[HUSTFC 2023] 狭义线段树", "background": "", "description": "你打算建立一棵有 $(2n - 1)$ 个节点，其中有 $n$ 个叶子节点的二叉树。具体地，建立这棵树的伪代码如图所示。\n\n![1](https://cdn.luogu.com.cn/upload/image_hosting/eex8x40p.png)\n\n不难发现，节点 $1$ 是根节点，并且所有节点的编号与其 DFS 序相同。另外，你认为叶子节点十分重要，因此你按照节点编号从小到大又把这 $n$ 个叶子节点分别称为 $1$ 号叶子，$2$ 号叶子，$\\dots$，$n$ 号叶子。叶子节点会被其上方的节点管辖，具体来说，如果 $i$ 号叶子在节点 $j$ 的子树内，则称节点 $j$ 管辖 $i$ 号叶子，不妨用 $g(j,i)=1$ 表示；否则若节点 $j$ 不管辖 $i$ 号叶子，则 $g(j,i)=0$。注意，叶子节点同时也管辖自己本身。\n\n同时，你认为一个好的二叉树要有点权，于是对于节点 $i$，定义其点权为 $v_i$。初始所有节点的点权都为 $0$。\n\n在一次梦中，你正在改造这棵二叉树。你将会对这棵二叉树依次执行 $q$ 次操作，每次操作的格式和描述如下：\n- $1\\ s\\ t\\ v$：对于所有的整数 $i\\ (i\\in [s,t])$，将节点 $i$ 的点权加 $v$。\n- $2\\ s\\ t\\ v$：令 $\\mathcal{S}={\\textstyle \\bigcup_{i\\in [s,t]}}S_i$，其中 $S_i$ 表示节点 $i$ 管辖的叶子节点的集合。然后对于 $\\mathcal{S}$ 中所有叶子节点，将其点权加 $v$。注意 $\\mathcal{S}$ 是不重复集合，即在本次操作中，每个叶子节点最多被修改一次。\n- $3\\ l\\ r$：计算 $\\sum^{r}_{i=l}f(i)\\bmod 998\\,244\\,353$，其中 $f(i)$ 表示管辖 $i$ 号叶子的所有节点的点权之和，即 $f(i)=\\sum_{g(j,i)=1}{v_j}$。\n\n你还想再加点操作，但是早八的铃声把你吵醒了，不过你还是决定实现一下这个奇思妙想。", "inputFormat": "第一行包含一个整数 $n\\ (3\\le n\\le 10^5)$，表示二叉树中叶子节点的数量。\n\n第二行包含 $(2n-2)$ 个整数，其中第 $i$ 个整数表示节点 $i+1$ 的父亲节点编号。保证给出的树的形态与节点编号和题目所描述的相同。\n\n第三行包含一个整数 $q\\ (3\\le q\\le 10^5)$，表示操作次数。\n\n接下来 $q$ 行，每行第一个整数 $opt\\ (opt\\in [1, 3])$ 表示操作类型，若 $opt=1$ 或 $opt=2$，则紧跟三个整数 $s,t,v\\ (1\\le s\\le t\\le 2n-1,\\ 0\\le v<998\\,244\\,353)$，表示一次修改操作；若 $opt=3$，则紧跟两个整数 $l,r\\ (1\\le l\\le r\\le n)$，表示一次询问操作。所有参数的含义如题目所述。", "outputFormat": "对于每个 $opt=3$ 的操作，输出一行一个整数，表示本次询问的结果。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9777", "type": "P", "difficulty": 4, "samples": [["998244353 10 1\n", "10"], ["998244353 2 3\n", "2"], ["100 4 5\n", "24"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2023", "O2优化", "矩阵加速", "高校校赛"], "title": "[HUSTFC 2023] Fujisaki 讨厌数学", "background": "", "description": "众所周知，Fujisaki 在微积分（一）（上）、微积分（一）（下）、线性代数、离散数学（一）、概率论与数理统计这些课程中，只取得了非常低的分数，这导致他十分痛恨高等数学，因此他给大家带来了一道初等数学题。\n\n已知 $x+x^{-1}=k$，其中 $k$ 是一个整数且 $k\\ge 2$，Fujisaki 想让你帮他求出 $x^n+x^{-n}$ 的值。可以证明对于任意的整数 $n \\ge 0$，这个值都是一个整数。由于结果可能会非常大，你只需要求出其对 $M$ 取模后的值。", "inputFormat": "一行包含三个整数 $M\\ (3\\le M\\le 998\\,244\\,353)$，$k\\ (2\\le k<M)$ 和 $n\\ (0\\le n\\le 10^{18})$，其含义如题目所述。", "outputFormat": "输出一个整数，表示答案对 $M$ 取模后的值。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[HUSTFC 2023] Fujisaki 讨厌数学", "background": "", "description": "众所周知，Fujisaki 在微积分（一）（上）、微积分（一）（下）、线性代数、离散数学（一）、概率论与数理统计这些课程中，只取得了非常低的分数，这导致他十分痛恨高等数学，因此他给大家带来了一道初等数学题。\n\n已知 $x+x^{-1}=k$，其中 $k$ 是一个整数且 $k\\ge 2$，Fujisaki 想让你帮他求出 $x^n+x^{-n}$ 的值。可以证明对于任意的整数 $n \\ge 0$，这个值都是一个整数。由于结果可能会非常大，你只需要求出其对 $M$ 取模后的值。", "inputFormat": "一行包含三个整数 $M\\ (3\\le M\\le 998\\,244\\,353)$，$k\\ (2\\le k<M)$ 和 $n\\ (0\\le n\\le 10^{18})$，其含义如题目所述。", "outputFormat": "输出一个整数，表示答案对 $M$ 取模后的值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9778", "type": "P", "difficulty": 5, "samples": [["3\nAAA\nAA\nAA\n", "12"], ["3\nACGC\nCTAT\nACAT\n", "1"], ["4\nA\nC\nT\nG\n", "0"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "O2优化", "高校校赛"], "title": "[HUSTFC 2023] 基因编辑", "background": "", "description": "绮月有 $n$ 条 DNA 碱基序列 $S_1,S_2,\\dots S_n$，每条碱基序列可以用一个仅包含 `A`、`C`、`G` 和 `T` 这四种大写字母的字符串表示。\n\n绮月可以拼合两条 DNA 碱基序列，具体操作为将前一条碱基序列的一个前缀（可以为空）和后一条的一个后缀（可以为空）结合，如 `ACGC` 与 `CTAT` 拼合就有可能得到 `ACGCTAT`、`ACGCCTAT`、`ACAT` 或 `T`。\n\n绮月据此定义，一个三元组 $(i,j,k)$ 是好的，当且仅当 $1\\le i,j,k \\le n$，$i\\ne k$，$j \\ne k$，且 $S_i$ 与 $S_j$ 拼合可以得到 $S_k$。\n\n绮月想知道好的三元组的数量。", "inputFormat": "第一行包含一个整数 $n\\ (3\\le n\\le 2\\times 10^5)$，表示碱基序列的数量。\n\n接下来 $n$ 行，每行包含一个字符串，其中第 $i$ 个字符串定义为碱基序列 $S_i\\ (1\\le |S_i|\\le 2\\times 10^6)$。保证 $\\sum |S_i| \\le 2 \\times 10^6$。", "outputFormat": "输出一个整数，表示好的三元组的数量。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[HUSTFC 2023] 基因编辑", "background": "", "description": "绮月有 $n$ 条 DNA 碱基序列 $S_1,S_2,\\dots S_n$，每条碱基序列可以用一个仅包含 `A`、`C`、`G` 和 `T` 这四种大写字母的字符串表示。\n\n绮月可以拼合两条 DNA 碱基序列，具体操作为将前一条碱基序列的一个前缀（可以为空）和后一条的一个后缀（可以为空）结合，如 `ACGC` 与 `CTAT` 拼合就有可能得到 `ACGCTAT`、`ACGCCTAT`、`ACAT` 或 `T`。\n\n绮月据此定义，一个三元组 $(i,j,k)$ 是好的，当且仅当 $1\\le i,j,k \\le n$，$i\\ne k$，$j \\ne k$，且 $S_i$ 与 $S_j$ 拼合可以得到 $S_k$。\n\n绮月想知道好的三元组的数量。", "inputFormat": "第一行包含一个整数 $n\\ (3\\le n\\le 2\\times 10^5)$，表示碱基序列的数量。\n\n接下来 $n$ 行，每行包含一个字符串，其中第 $i$ 个字符串定义为碱基序列 $S_i\\ (1\\le |S_i|\\le 2\\times 10^6)$。保证 $\\sum |S_i| \\le 2 \\times 10^6$。", "outputFormat": "输出一个整数，表示好的三元组的数量。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9779", "type": "P", "difficulty": 1, "samples": [["1\n", "1\n"], ["2\n", "3\n"], ["3\n", "7\n"], ["15", "32767\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2023", "O2优化", "高校校赛"], "title": "[HUSTFC 2023] 不定项选择题", "background": "![1](https://cdn.luogu.com.cn/upload/image_hosting/4rdg9szz.png)", "description": "有一道共 $n$ 个选项的不定项选择题，它的答案至少包含一个选项，由于题目与选项的内容晦涩难懂，你打算通过尝试每一种可能的答案来通过这道题。\n\n初始时所有选项都没有被勾选，你可以执行任意次下述操作：\n- 勾选一个当前未被勾选的选项。\n- 取消勾选一个当前已被勾选的选项。\n\n当你勾选中的选项与答案一致时，你将会立即通过此题。在开始尝试前，你产生了一个疑问：在最坏的情况下，至少需要操作多少次才可以通过这道题？", "inputFormat": "一行包含一个整数 $n\\ (1\\le n \\le 20)$，表示选项的数量。", "outputFormat": "输出一个整数，表示在最坏情况下通过题目的最少操作次数。", "hint": "图片与题目无关。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[HUSTFC 2023] 不定项选择题", "background": "![1](https://cdn.luogu.com.cn/upload/image_hosting/4rdg9szz.png)", "description": "有一道共 $n$ 个选项的不定项选择题，它的答案至少包含一个选项，由于题目与选项的内容晦涩难懂，你打算通过尝试每一种可能的答案来通过这道题。\n\n初始时所有选项都没有被勾选，你可以执行任意次下述操作：\n- 勾选一个当前未被勾选的选项。\n- 取消勾选一个当前已被勾选的选项。\n\n当你勾选中的选项与答案一致时，你将会立即通过此题。在开始尝试前，你产生了一个疑问：在最坏的情况下，至少需要操作多少次才可以通过这道题？", "inputFormat": "一行包含一个整数 $n\\ (1\\le n \\le 20)$，表示选项的数量。", "outputFormat": "输出一个整数，表示在最坏情况下通过题目的最少操作次数。", "hint": "图片与题目无关。", "locale": "zh-CN"}}}
{"pid": "P9780", "type": "P", "difficulty": 3, "samples": [["3 3\n2 3 1\n", "-1 4 6 "], ["8 4\n3 2 4 2 1 2 3 2\n", "-1 -1 -1 21 22 25 29 36 "]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "O2优化", "高校校赛"], "title": "[HUSTFC 2023] Azur Lane", "background": "", "description": "你是港区的一位指挥官，你可以通过培养指挥喵来增强舰队的实力，指挥喵由对应的喵箱培育。喵箱有 $k$ 个等级，等级越高稀有度越高。你每天会获得若干个喵箱（至少一个），然后再使用 ''一键放入'' 将这些喵箱放到喵窝里进行培育。''一键放入'' 会优先放入稀有度更高的喵箱（即按照稀有度从高到低排序后依次放入），放入的喵箱会排在已放入喵箱的后面，在**每天结束时**系统会自动扣除与喵窝中喵箱数量相等的钱。最开始时你的喵窝里没有喵箱。\n\n因为你非常懒，所以你会等 $n$ 天后才把喵箱一起打开。在你 $n$ 天后进入喵窝时，你看到了 $m$ 个喵箱，用一个长度为 $m$ 的序列 $a$ 表示喵窝里按放入先后顺序排列的喵箱的等级。但是你已经忘了这 $n$ 天里你每天获得了多少喵箱了，你甚至忘了 $n$ 的值是多少，显然这有许多情况。你想知道，对于满足 $1 \\leq n \\leq m$ 的所有整数 $n$，在所有情况中，这 $n$ 天总共扣除的钱数至少为多少？", "inputFormat": "第一行包含两个整数 $m\\ (1 \\leq m \\leq 10^6)$，$k\\ (1 \\leq k \\leq 10^6)$，分别表示喵窝中喵箱的数量和喵箱的最高等级。\n\n第二行包含 $m$ 个整数 $a_{1}, a_{2}, \\ldots, a_{m}\\ (1 \\leq a_i \\leq k)$，表示喵窝中排列着的喵箱的等级。\n\n", "outputFormat": "输出一行用空格间隔的 $m$ 个整数，其中第 $i$ 个整数表示当 $n=i$ 时在所有可能的情况下至少会扣除的钱数。如果没有合法的情况，请输出 $-1$。\n\n", "hint": "样例一解释：\n\n当 $n=1$ 时，无法在一天内获得这 $3$ 个喵箱（第二个喵箱的等级大于第一个喵箱的等级，不符合 ``一键放入'' 从高到低放入的原则），因此输出 $-1$。\n\n当 $n=2$ 时，第一天获得第一个喵箱，此时喵窝内有 $1$ 个喵箱，当天花费为 $1$；第二天获得后两个喵箱，此时喵窝内有 $3$ 个喵箱，当天花费为 $3$。因此总钱数为 $4$。\n\n当 $n=3$ 时，每天依次获得一个喵箱，总钱数为 $1+2+3=6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[HUSTFC 2023] Azur Lane", "background": "", "description": "你是港区的一位指挥官，你可以通过培养指挥喵来增强舰队的实力，指挥喵由对应的喵箱培育。喵箱有 $k$ 个等级，等级越高稀有度越高。你每天会获得若干个喵箱（至少一个），然后再使用 ''一键放入'' 将这些喵箱放到喵窝里进行培育。''一键放入'' 会优先放入稀有度更高的喵箱（即按照稀有度从高到低排序后依次放入），放入的喵箱会排在已放入喵箱的后面，在**每天结束时**系统会自动扣除与喵窝中喵箱数量相等的钱。最开始时你的喵窝里没有喵箱。\n\n因为你非常懒，所以你会等 $n$ 天后才把喵箱一起打开。在你 $n$ 天后进入喵窝时，你看到了 $m$ 个喵箱，用一个长度为 $m$ 的序列 $a$ 表示喵窝里按放入先后顺序排列的喵箱的等级。但是你已经忘了这 $n$ 天里你每天获得了多少喵箱了，你甚至忘了 $n$ 的值是多少，显然这有许多情况。你想知道，对于满足 $1 \\leq n \\leq m$ 的所有整数 $n$，在所有情况中，这 $n$ 天总共扣除的钱数至少为多少？", "inputFormat": "第一行包含两个整数 $m\\ (1 \\leq m \\leq 10^6)$，$k\\ (1 \\leq k \\leq 10^6)$，分别表示喵窝中喵箱的数量和喵箱的最高等级。\n\n第二行包含 $m$ 个整数 $a_{1}, a_{2}, \\ldots, a_{m}\\ (1 \\leq a_i \\leq k)$，表示喵窝中排列着的喵箱的等级。\n\n", "outputFormat": "输出一行用空格间隔的 $m$ 个整数，其中第 $i$ 个整数表示当 $n=i$ 时在所有可能的情况下至少会扣除的钱数。如果没有合法的情况，请输出 $-1$。\n\n", "hint": "样例一解释：\n\n当 $n=1$ 时，无法在一天内获得这 $3$ 个喵箱（第二个喵箱的等级大于第一个喵箱的等级，不符合 ``一键放入'' 从高到低放入的原则），因此输出 $-1$。\n\n当 $n=2$ 时，第一天获得第一个喵箱，此时喵窝内有 $1$ 个喵箱，当天花费为 $1$；第二天获得后两个喵箱，此时喵窝内有 $3$ 个喵箱，当天花费为 $3$。因此总钱数为 $4$。\n\n当 $n=3$ 时，每天依次获得一个喵箱，总钱数为 $1+2+3=6$。", "locale": "zh-CN"}}}
{"pid": "P9781", "type": "P", "difficulty": 6, "samples": [["2", "7\n"], ["5", "26\n"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "O2优化", "高校校赛"], "title": "[HUSTFC 2023] 近似递增序列", "background": "", "description": "对于一个长度为 $m\\ (m\\ge 1)$ 的整数序列 $a_1,a_2,\\cdots,a_m\\ (a_i>0)$，如果**最多**只存在一个整数 $p\\ (1\\le p<m)$ 满足 $a_p\\ge a_{p+1}$，则可以称这样的序列为近似递增序列，同时我们定义这个近似递增序列的权值为 $\\prod_{i=1}^m a_i$。\n\n设 $f(i)$ 表示权值为 $i$ 的近似递增序列的数量，duoluoluo 想知道 $\\sum_{i=1}^n f(i)$ 的值，但是他连 $f(2)$ 都不会计算，你可以帮帮他吗？由于答案可能会非常大，你只需要求出其对 $998\\,244\\,353$ 取模后的值。", "inputFormat": "一行包含一个整数 $n\\ (1\\le n\\le 10^8)$，其含义如题目所述。", "outputFormat": "输出一个整数，表示 $\\sum_{i=1}^n f(i)$ 对 $998\\,244\\,353$ 取模后的值。", "hint": "样例一中 $7$ 个近似递增序列为：$\\{1\\}$，$\\{1,1\\}$，$\\{1,1,2\\}$，$\\{1,2\\}$，$\\{1,2,1\\}$，$\\{2\\}$，$\\{2,1\\}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[HUSTFC 2023] 近似递增序列", "background": "", "description": "对于一个长度为 $m\\ (m\\ge 1)$ 的整数序列 $a_1,a_2,\\cdots,a_m\\ (a_i>0)$，如果**最多**只存在一个整数 $p\\ (1\\le p<m)$ 满足 $a_p\\ge a_{p+1}$，则可以称这样的序列为近似递增序列，同时我们定义这个近似递增序列的权值为 $\\prod_{i=1}^m a_i$。\n\n设 $f(i)$ 表示权值为 $i$ 的近似递增序列的数量，duoluoluo 想知道 $\\sum_{i=1}^n f(i)$ 的值，但是他连 $f(2)$ 都不会计算，你可以帮帮他吗？由于答案可能会非常大，你只需要求出其对 $998\\,244\\,353$ 取模后的值。", "inputFormat": "一行包含一个整数 $n\\ (1\\le n\\le 10^8)$，其含义如题目所述。", "outputFormat": "输出一个整数，表示 $\\sum_{i=1}^n f(i)$ 对 $998\\,244\\,353$ 取模后的值。", "hint": "样例一中 $7$ 个近似递增序列为：$\\{1\\}$，$\\{1,1\\}$，$\\{1,1,2\\}$，$\\{1,2\\}$，$\\{1,2,1\\}$，$\\{2\\}$，$\\{2,1\\}$。", "locale": "zh-CN"}}}
{"pid": "P9782", "type": "P", "difficulty": 1, "samples": [["A A\n", "A\n"], ["B C\n", "D\n"], ["Z B\n", "BA\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2023", "O2优化", "高校校赛"], "title": "[HUSTFC 2023] A+B problem", "background": "", "description": "Walk Alone 是一个字符串大师，在他的眼中每个字符串都表示一个 $26$ 进制的数，具体地说，按照字母表顺序从 $A$ 到 $Z$ 分别对应着十进制下 $0$ 到 $25$，那么 $BA$ 对应十进制下 $26\\ (1\\times 26+0)$，$BB$ 对应十进制下 $27\\ (1\\times 26+1)$，以此类推。\n\nWalk Alone 想考考已经习惯了十进制加法的你，给你两个字符串 $s$ 和 $t$，请你计算出他们所表示的 $26$ 进制数的和，即 $s+t$，并同样以字符串形式告诉他，例如 $A+A=A$，$B+C=D$。为了简化问题，$s$ 和 $t$ 分别只包含一个大写字母，但请注意，答案不一定只包含一个大写字母。", "inputFormat": "一行用空格分隔的两个大写字母，分别表示 $s$ 和 $t$。", "outputFormat": "输出一行只包含大写字母的字符串，表示 $s+t$。输出的答案不包含前导 $0$，即类似 $AA$、$AB$ 的输出都是不合法的。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[HUSTFC 2023] A+B problem", "background": "", "description": "Walk Alone 是一个字符串大师，在他的眼中每个字符串都表示一个 $26$ 进制的数，具体地说，按照字母表顺序从 $A$ 到 $Z$ 分别对应着十进制下 $0$ 到 $25$，那么 $BA$ 对应十进制下 $26\\ (1\\times 26+0)$，$BB$ 对应十进制下 $27\\ (1\\times 26+1)$，以此类推。\n\nWalk Alone 想考考已经习惯了十进制加法的你，给你两个字符串 $s$ 和 $t$，请你计算出他们所表示的 $26$ 进制数的和，即 $s+t$，并同样以字符串形式告诉他，例如 $A+A=A$，$B+C=D$。为了简化问题，$s$ 和 $t$ 分别只包含一个大写字母，但请注意，答案不一定只包含一个大写字母。", "inputFormat": "一行用空格分隔的两个大写字母，分别表示 $s$ 和 $t$。", "outputFormat": "输出一行只包含大写字母的字符串，表示 $s+t$。输出的答案不包含前导 $0$，即类似 $AA$、$AB$ 的输出都是不合法的。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9783", "type": "P", "difficulty": 2, "samples": [["3", "Yes\n2 1"], ["2", "No"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "Special Judge", "ROIR（俄罗斯）"], "title": "[ROIR 2020] 平方 (Day1)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day1 T1.** ***[Разность квадратов](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day1.pdf)，译者 ShineEternal***\n\n你参与了字符计算系统软件模块的开发，将用于求解一类特殊的丢番图方程，具体内容如下：\n\n给定一个非负整数 $n$，正在开发的模块需要找到两个正整数 $x$ 和 $y$，使得 $x^2-y^2=n$，其中 $x,y$ 不超过 $2^{62}-1$。\n\n你需要编写一个程序，对于给定的非负整数 $n$，求出两个自然数 $x$ 和 $y$，使得它们都不超过 $2^{62}-1$ 且其平方差为 $n$。", "inputFormat": "一行一个整数 $n$。", "outputFormat": "如果存在可能的 $x,y$，则打印两行，第一行为一个单独的字符串 `Yes`，第二行打印任意一组 $x,y$。\n\n如果不存在则输出 `No`。", "hint": "对于 $100\\%$ 的数据，$0\\le n\\le 2^{60}$。\n\n| 任务编号 |          $n$           | 分值 |\n| :------: | :--------------------: | :--: |\n|   $1$    | $0 \\leq n \\leq 2^{10}$ | $10$ |\n|   $2$    | $0 \\leq n \\leq 2^{20}$ | $20$ |\n|   $3$    | $0 \\leq n \\leq 2^{30}$ | $30$ |\n|   $4$    | $0 \\leq n \\leq 2^{60}$ | $40$ |\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2020] 平方 (Day1)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day1 T1.** ***[Разность квадратов](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day1.pdf)，译者 ShineEternal***\n\n你参与了字符计算系统软件模块的开发，将用于求解一类特殊的丢番图方程，具体内容如下：\n\n给定一个非负整数 $n$，正在开发的模块需要找到两个正整数 $x$ 和 $y$，使得 $x^2-y^2=n$，其中 $x,y$ 不超过 $2^{62}-1$。\n\n你需要编写一个程序，对于给定的非负整数 $n$，求出两个自然数 $x$ 和 $y$，使得它们都不超过 $2^{62}-1$ 且其平方差为 $n$。", "inputFormat": "一行一个整数 $n$。", "outputFormat": "如果存在可能的 $x,y$，则打印两行，第一行为一个单独的字符串 `Yes`，第二行打印任意一组 $x,y$。\n\n如果不存在则输出 `No`。", "hint": "对于 $100\\%$ 的数据，$0\\le n\\le 2^{60}$。\n\n| 任务编号 |          $n$           | 分值 |\n| :------: | :--------------------: | :--: |\n|   $1$    | $0 \\leq n \\leq 2^{10}$ | $10$ |\n|   $2$    | $0 \\leq n \\leq 2^{20}$ | $20$ |\n|   $3$    | $0 \\leq n \\leq 2^{30}$ | $30$ |\n|   $4$    | $0 \\leq n \\leq 2^{60}$ | $40$ |\n\n", "locale": "zh-CN"}}}
{"pid": "P9784", "type": "P", "difficulty": 3, "samples": [["3\n10 20 30\n400 500 600\n6\n1 5 10 12 16\n100 300 600 800 1000 1500\n3\n10 100\n20 70\n45 100", "0\n800\n600"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "二分", "ROIR（俄罗斯）"], "title": "[ROIR 2020] 超速 (Day1)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day1 T2.** ***[Превышение скорости](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day1.pdf)*** ，译者 ShineEternal\n\n超速行驶是一种危险的犯法行为，大大增加了交通事故导致悲惨后果的可能性。不幸的是使用使用雷达和相机控制速度并不能完全解决问题。为了防止这种行为的出现，根据汽车在一段道路上的行驶时间来罚款，可以对超速行为进行限制。\n\n现在有 $n$ 段从 $1\\sim n$ 编号的公路。第 $i$ 段公路长 $l_i$ 米，其限速为 $v_i$ 米每秒。超速就要罚款，但是为了体现按劳分配，还要对不同程度的超速设置不同的罚款金额。\n\n具体来说，如果不超速则不收罚款；否则，用 $e$ 表示汽车在这段公路上的**最大速度减去限速**的值：\n\n- 如果 $0<e\\leq a_1$，则惩罚为 $f_1$ 个货币单位。\n\n- 如果 $a_1<e\\leq a_2$，则惩罚为 $f_2$ 个货币单位。\n\n- ...\n\n- 如果 $a_{m-2}<e\\leq a_{m-1}$，则惩罚为 $f_{m-1}$ 个货币单位。\n\n- 如果 $a_{m-1}<e$，则惩罚为 $f_m$ 个货币单位。\n\n目前，有 $q$ 辆车要经过这 $n$ 段道路，每辆车在 $s_i$ 时间到达 $1$ 号路段，在 $t_i$ 时间离开 $n$ 号路段。\n\n你需要计算每辆车在**所有路段中最高**被罚款的金额**至少**是多少。\n\n时间从道路开放起计算，即从 $0$ 开始计算。", "inputFormat": "第一行一个正整数 $n$，表示道路段数。\n\n接下来的两行，每行 $n$ 个数，第一行为 $v_i$，第二行为 $l_i$。\n\n第四行为一个正整数 $m$，表示罚款的 $m$ 种不同范围。\n\n接下来的两行，第一行 $m-1$ 个数，为 $a_i$；第二行 $m$ 个数，为 $f_i$。\n\n第七行为一个正整数 $q$，表示共有 $q$ 辆车。\n\n接下来的 $q$ 行，每行两个整数 $s_i,t_i$。", "outputFormat": "输出共 $q$ 行。\n\n对于每辆车，输出它最少被罚款的金额。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 10$，$1\\leq v_i,l_i,a_i,f_i\\leq 10^9$，$1\\leq m\\leq 10^5$，$1\\le q\\le 10^5$，$1\\leq s_i<t_i\\leq 10^9$。\n\n|任务编号|特殊限制|分值|\n|:-:|:-:|:-:|\n|$1$|$n=1,m=1$|$5$|\n|$2$|$m=1$|$10$|\n|$3$|$n=1,m\\leq 10$|$9$|\n|$4$|$n=1$|$12$|\n|$5$|$m\\leq 10,a_i\\leq 10$|$13$|\n|$6$|$m\\leq 10$|$14$|\n|$7$|无特殊限制|$37$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2020] 超速 (Day1)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day1 T2.** ***[Превышение скорости](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day1.pdf)*** ，译者 ShineEternal\n\n超速行驶是一种危险的犯法行为，大大增加了交通事故导致悲惨后果的可能性。不幸的是使用使用雷达和相机控制速度并不能完全解决问题。为了防止这种行为的出现，根据汽车在一段道路上的行驶时间来罚款，可以对超速行为进行限制。\n\n现在有 $n$ 段从 $1\\sim n$ 编号的公路。第 $i$ 段公路长 $l_i$ 米，其限速为 $v_i$ 米每秒。超速就要罚款，但是为了体现按劳分配，还要对不同程度的超速设置不同的罚款金额。\n\n具体来说，如果不超速则不收罚款；否则，用 $e$ 表示汽车在这段公路上的**最大速度减去限速**的值：\n\n- 如果 $0<e\\leq a_1$，则惩罚为 $f_1$ 个货币单位。\n\n- 如果 $a_1<e\\leq a_2$，则惩罚为 $f_2$ 个货币单位。\n\n- ...\n\n- 如果 $a_{m-2}<e\\leq a_{m-1}$，则惩罚为 $f_{m-1}$ 个货币单位。\n\n- 如果 $a_{m-1}<e$，则惩罚为 $f_m$ 个货币单位。\n\n目前，有 $q$ 辆车要经过这 $n$ 段道路，每辆车在 $s_i$ 时间到达 $1$ 号路段，在 $t_i$ 时间离开 $n$ 号路段。\n\n你需要计算每辆车在**所有路段中最高**被罚款的金额**至少**是多少。\n\n时间从道路开放起计算，即从 $0$ 开始计算。", "inputFormat": "第一行一个正整数 $n$，表示道路段数。\n\n接下来的两行，每行 $n$ 个数，第一行为 $v_i$，第二行为 $l_i$。\n\n第四行为一个正整数 $m$，表示罚款的 $m$ 种不同范围。\n\n接下来的两行，第一行 $m-1$ 个数，为 $a_i$；第二行 $m$ 个数，为 $f_i$。\n\n第七行为一个正整数 $q$，表示共有 $q$ 辆车。\n\n接下来的 $q$ 行，每行两个整数 $s_i,t_i$。", "outputFormat": "输出共 $q$ 行。\n\n对于每辆车，输出它最少被罚款的金额。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 10$，$1\\leq v_i,l_i,a_i,f_i\\leq 10^9$，$1\\leq m\\leq 10^5$，$1\\le q\\le 10^5$，$1\\leq s_i<t_i\\leq 10^9$。\n\n|任务编号|特殊限制|分值|\n|:-:|:-:|:-:|\n|$1$|$n=1,m=1$|$5$|\n|$2$|$m=1$|$10$|\n|$3$|$n=1,m\\leq 10$|$9$|\n|$4$|$n=1$|$12$|\n|$5$|$m\\leq 10,a_i\\leq 10$|$13$|\n|$6$|$m\\leq 10$|$14$|\n|$7$|无特殊限制|$37$|", "locale": "zh-CN"}}}
{"pid": "P9785", "type": "P", "difficulty": 4, "samples": [["5\n1 3 2 1 2", "5 8 8 6 3"], ["3\n10 10 10", "3 2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "组合数学", "前缀和", "ROIR（俄罗斯）"], "title": "[ROIR 2020] 对常规的斗争 (Day1)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day1 T3.** ***[Борьба с рутиной\n](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day1.pdf)，译者ShineEternal***\n\n判断员工业绩的一个重要因素就是处理日常事务的能力。\n\n我们考虑员工连续 $n$ 天的工作情况，第 $i$ 天执行的工作为 $a_i$。\n\n为了评估员工的工作业绩，使用以下方法：\n\n选定一个整数 $d$，考虑所有 连续 $d$ 天的日期段，对于每一段这样的日子，我们统计员工完成的不同工作的种类数。\n\n记 $S_d$ 表示每一段这样连续 $d$ 天的日期段完成的不同种类工作数之和。\n\n现在需要你来统计出 $S_{1\\sim n}$ 的值。", "inputFormat": "输入共两行:\n\n第一行为一个整数 $n$，表示工作的总天数。\n\n第二行 $n$ 个整数，表示每天所做的工作种类编号。", "outputFormat": "输出共 $n$ 个数，为 $S_{1\\sim n}$。", "hint": "#### 【样例 1 解释】\n- $S_1$:\n\n| 日期段 | 所有工种 | 不同的工种的数量 |\n| :----: | :------: | :--------------: |\n| $1-1$  |   $1$    |       $1$        |\n| $2-2$  |   $3$    |       $1$        |\n| $3-3$  |   $2$    |       $1$        |\n| $4-4$  |   $1$    |       $1$        |\n| $5-5$  |   $2$    |       $1$        |\n\n\n\n所以 $S_1=1+1+1+1+1=5$。\n\n- $S_2$:\n\n|日期段|所有工种|不同的工种的数量|\n|:-:|:-:|:-:|\n|$1-2$|$1,3$|$2$|\n|$2-3$|$3,2$|$2$|\n|$3-4$|$2,1$|$2$|\n|$4-5$|$1,2$|$2$|\n\n所以 $S_2=2+2+2+2=8$。\n\n- $S_3$:\n\n|日期段|所有工种|不同的工种的数量|\n|:-:|:-:|:-:|\n|$1-3$|$1,3,2$|$3$|\n|$2-4$|$3,2,1$|$3$|\n|$3-5$|$2,1,2$|$2$|\n\n所以 $S_3=3+3+2=8$。\n\n- $S_4$:\n\n|日期段|所有工种|不同的工种的数量|\n|:-:|:-:|:-:|\n|$1-4$|$1,3,2,1$|$3$|\n|$2-5$|$3,2,1,2$|$3$|\n\n所以 $S_4=3+3=6$。\n\n- $S_5$:\n\n|日期段|所有工种|不同的工种的数量|\n|:-:|:-:|:-:|\n|$1-5$|$1,3,2,1,2$|$3$|\n\n所以 $S_5=3$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据， $1\\leq n\\leq 2\\times 10^5$，$1\\leq a_i\\leq 10^9$。\n\n|任务编号|特殊限制|分值|\n|:-:|:-:|:-:|\n|$1$|$1\\leq n \\leq 50, 1 \\leq a_i \\leq 50$|$12$|\n|$2$|$1\\leq n \\leq 50, 1 \\leq a_i \\leq 10^9$|$10$|\n|$3$|$1\\leq n \\leq 500, 1 \\leq a_i \\leq 10^9$|$10$|\n|$4$|$1\\leq n \\leq 5000, 1 \\leq a_i \\leq 5000$|$12$|\n|$5$|$1\\leq n \\leq 5000, 1 \\leq a_i \\leq 10^9$|$10$|\n|$6$|$1\\leq n \\leq 2\\times 10^5, 1 \\leq a_i \\leq 50$|$16$|\n|$7$|无特殊限制|$30$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2020] 对常规的斗争 (Day1)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day1 T3.** ***[Борьба с рутиной\n](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day1.pdf)，译者ShineEternal***\n\n判断员工业绩的一个重要因素就是处理日常事务的能力。\n\n我们考虑员工连续 $n$ 天的工作情况，第 $i$ 天执行的工作为 $a_i$。\n\n为了评估员工的工作业绩，使用以下方法：\n\n选定一个整数 $d$，考虑所有 连续 $d$ 天的日期段，对于每一段这样的日子，我们统计员工完成的不同工作的种类数。\n\n记 $S_d$ 表示每一段这样连续 $d$ 天的日期段完成的不同种类工作数之和。\n\n现在需要你来统计出 $S_{1\\sim n}$ 的值。", "inputFormat": "输入共两行:\n\n第一行为一个整数 $n$，表示工作的总天数。\n\n第二行 $n$ 个整数，表示每天所做的工作种类编号。", "outputFormat": "输出共 $n$ 个数，为 $S_{1\\sim n}$。", "hint": "#### 【样例 1 解释】\n- $S_1$:\n\n| 日期段 | 所有工种 | 不同的工种的数量 |\n| :----: | :------: | :--------------: |\n| $1-1$  |   $1$    |       $1$        |\n| $2-2$  |   $3$    |       $1$        |\n| $3-3$  |   $2$    |       $1$        |\n| $4-4$  |   $1$    |       $1$        |\n| $5-5$  |   $2$    |       $1$        |\n\n\n\n所以 $S_1=1+1+1+1+1=5$。\n\n- $S_2$:\n\n|日期段|所有工种|不同的工种的数量|\n|:-:|:-:|:-:|\n|$1-2$|$1,3$|$2$|\n|$2-3$|$3,2$|$2$|\n|$3-4$|$2,1$|$2$|\n|$4-5$|$1,2$|$2$|\n\n所以 $S_2=2+2+2+2=8$。\n\n- $S_3$:\n\n|日期段|所有工种|不同的工种的数量|\n|:-:|:-:|:-:|\n|$1-3$|$1,3,2$|$3$|\n|$2-4$|$3,2,1$|$3$|\n|$3-5$|$2,1,2$|$2$|\n\n所以 $S_3=3+3+2=8$。\n\n- $S_4$:\n\n|日期段|所有工种|不同的工种的数量|\n|:-:|:-:|:-:|\n|$1-4$|$1,3,2,1$|$3$|\n|$2-5$|$3,2,1,2$|$3$|\n\n所以 $S_4=3+3=6$。\n\n- $S_5$:\n\n|日期段|所有工种|不同的工种的数量|\n|:-:|:-:|:-:|\n|$1-5$|$1,3,2,1,2$|$3$|\n\n所以 $S_5=3$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据， $1\\leq n\\leq 2\\times 10^5$，$1\\leq a_i\\leq 10^9$。\n\n|任务编号|特殊限制|分值|\n|:-:|:-:|:-:|\n|$1$|$1\\leq n \\leq 50, 1 \\leq a_i \\leq 50$|$12$|\n|$2$|$1\\leq n \\leq 50, 1 \\leq a_i \\leq 10^9$|$10$|\n|$3$|$1\\leq n \\leq 500, 1 \\leq a_i \\leq 10^9$|$10$|\n|$4$|$1\\leq n \\leq 5000, 1 \\leq a_i \\leq 5000$|$12$|\n|$5$|$1\\leq n \\leq 5000, 1 \\leq a_i \\leq 10^9$|$10$|\n|$6$|$1\\leq n \\leq 2\\times 10^5, 1 \\leq a_i \\leq 50$|$16$|\n|$7$|无特殊限制|$30$|", "locale": "zh-CN"}}}
{"pid": "P9786", "type": "P", "difficulty": 0, "samples": [["4 3 2\n1 2 1\n3 4 1\n5 6 2\n1 2 2\n3 5 1\n4 6 2\n1 4 1\n2 3 1\n5 6 2\n0 1 2 2\n2 2 1 0\n1 0 0 1", "0 1 2 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "Special Judge", "ROIR（俄罗斯）"], "title": "[ROIR 2020] 机器人锦标赛 (Day1)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day1 T4.** ***[Олимпиада для роботов\n](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day1.pdf)，译者 alpha1022***\n\n机器人高速布尔函数计算锦标赛的任务由评委会准备。\n\n机器人的一个任务是一张 $m$ 行 $n$ 列的表格，其中每个格子有一个整数权值，且记第 $i$ 行 $j$ 列的格子的权值为 $x_{i,j}$。  \n对于每一列，该列中所有格子的权值组成了一个 $0\\ldots m-1$ 的排列。换句话说，每列中所有格子的权值互不相同：  \n若 $i \\ne k$，则对于所有的 $j$ 有 $x_{i,j} \\ne x_{k,j}$，且有 $0 \\le x_{i,j} < m$。\n\n对于每一列，评委会设置了一个阈值 —— 一个在 $[0,m]$ 内的非负整数 $z_j$。你需要以所有形如 $x_{i,j} < z_j$ 的逻辑表达式的值为参数计算布尔函数的值。一个逻辑表达式的值为 $1$ 当且仅当这个表达式成立，否则为 $0$。\n\n在比赛中，选手们需要计算 $m$ 个布尔函数的值 —— 对每一行计算一次。每个布尔函数以一个**非重复单调线性规划**（NMLP）定义。\n\n考虑第 $i$ 行的 NMLP。  \n这是由 $n-1$ 条以 $1 \\ldots n-1$ 编号的指令组成的一个序列，第 $p$ 条指令给定三个数：$a_p, b_p, op_p$。$op_p$ 只有两种取值：$1$ 表示与运算，$2$ 表示或运算。  \n而 $a_p,b_p$ 则是第 $p$ 个指令的参数，满足 $1 \\le a_p,b_p < n+p$。\n\n考虑一个仅包含 $0$ 和 $1$ 的数组 $val[1\\ldots 2n-1]$。对于 $1 \\le j \\le n$，$val[j] = [x_{i,j} < z_j]$，其中 $[P]$ 表示表达式 $P$ 的值。  \n而 $val[n+p]$ 的值通过第 $p$ 条指令计算。\n - 对于 $op_p = 1$，$val[n+p] = (val[a_p]\\ \\texttt{and}\\ val[b_p])$。\n - 对于 $op_p = 2$，$val[n+p] = (val[a_p]\\ \\texttt{or}\\ val[b_p])$。\n\n该规划是非重复的，也就是说，对于 $p = 1\\ldots n-1$，所有 $2n-2$ 个 $a_p,b_p$ 的值互不相同。\n\n程序执行的结果即为 $val[2n-1]$。\n\n目前评委会已经准备好了所有的 $x_{i,j}$，需要由你来确定每一列的阈值才能完整地准备这个任务。  \n评委会认为一个任务是平衡的，当且仅当所有 $m$ 行中恰有 $s$ 行的布尔函数最后得到的结果为 $1$，其余 $m-s$ 行得到 $0$。  \n你的任务即为替评委会找到合适的阈值。\n\n对于此题，可以证明一定存在至少一种选择阈值的方案满足上述条件。", "inputFormat": "第一行，三个整数 $n,m,s$。  \n以下 $m(n-1)$ 行，第 $i \\cdot (n-1) + p\\;(1 \\le p \\le n-1)$ 行包含三个整数 $a_p,b_p,op_p$，表示第 $i$ 行的第 $p$ 个操作。  \n以下 $m$ 行，每行 $n$ 个整数，表示所有的 $x_{i,j}$。", "outputFormat": "输出 $n$ 个整数 $z_1, z_2, \\ldots, z_n\\;(0 \\le z_j \\le m)$。  \n如有多解，任意输出一个即可。", "hint": "#### 【样例解释】\n在此样例中共有 $3$ 行，你需要令其中恰好两行的函数值为 $1$，另一行的函数值为 $0$。\n让我们看看第一行的 $val$ 数组是什么样的。\n前四个值通过格子中的权值和阈值计算：\n- $val[1] = [x_{1,1} < z_1] = [0 < 0] = 0$；\n- $val[2] = [x_{1,2} < z_2] = [1 < 1] = 0$；\n- $val[3] = [x_{1,3} < z_3] = [2 < 2] = 0$；\n- $val[4] = [x_{1,4} < z_4] = [2 < 3] = 1$。\n\n接下来，对第一行执行线性规划：\n- $val[5] = (val[1]\\ \\texttt{and}\\ val[2]) = (0\\ \\texttt{and}\\ 0) = 0$；\n- $val[6] = (val[3]\\ \\texttt{and}\\ val[4]) = (0\\ \\texttt{and}\\ 1) = 0$；\n- $val[7] = (val[5]\\ \\texttt{or}\\ val[6]) = (0\\ \\texttt{or}\\ 0) = 0$。\n\n因此，第一行的函数值为 $0$。\n顺带一提，若我们整理一下这些式子，可得：\n$$\n[((x_{1,1} < z_1)\\ \\texttt{and}\\ (x_{1,2} < z_2))\\ \\texttt{or}\\ ((x_{1,3} < z_3)\\ \\texttt{and}\\ (x_{1,4} < z_4))]\n$$\n\n类似地，第二行和第三行的函数值分别为\n$$\n[(((x_{2,1} < z_1)\\ \\texttt{or}\\ (x_{2,2} < z_2))\\ \\texttt{and}\\ (x_{2,3} < z_3))\\ \\texttt{or}\\ (x_{2,4} < z_4)]\n$$\n\n和\n$$\n[((x_{3,1} < z_1)\\ \\texttt{and}\\ (x_{3,4} < z_4))\\ \\texttt{or}\\ ((x_{3,2} < z_2)\\ \\texttt{and}\\ (x_{3,3} < z_3))]\n$$\n\n当我们令 $z_1 = 0,z_2 = 1,z_3 = 2,z_4 = 3$ 时，我们可以得到以下表达式：\n第二行：\n$$\n[(((2 < 0)\\ \\texttt{or}\\ (2 < 1))\\ \\texttt{and}\\ (1 < 2))\\ \\texttt{or}\\ (0 < 3)] = 1\n$$\n\n第三行：\n$$\n[((1 < 0)\\ \\texttt{and}\\ (1 < 3))\\ \\texttt{or}\\ ((0 < 1)\\ \\texttt{and}\\ (0 < 2))] = 1\n$$\n\n请注意这不是唯一的解，可行的解还包括 $z_1 = 0, z_2 = 0, z_3 = 3, z_4 = 3$。\n\n\n#### 【数据范围】\n对于 $100\\%$ 的数据，$1 \\le n,m \\le 3 \\cdot 10^5,n \\cdot m \\le 3 \\cdot 10^5,0 \\le s \\le m,1 \\le a_p, b_p \\le n+p,0 \\le x_{i,j} < m$。  \n具体数据限制如下表：\n\n|子任务编号|限制|分值|\n|:-:|:-:|:-:|\n|$1$|$n \\le 2,m \\le 10^3$|$10$|\n|$2$|$n \\le 2,m \\le 10^5$|$10$|\n|$3$|$n \\le 10,m \\le 2$|$10$|\n|$4$|$x_{i,j} = i-1$|$5$|\n|$5$|$op_p=1$|$5$|\n|$6$|$n \\le 100$|$20$|\n|$7$|每一行的 NMLP 相同|$10$|\n|$8$|-|$30$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2020] 机器人锦标赛 (Day1)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day1 T4.** ***[Олимпиада для роботов\n](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day1.pdf)，译者 alpha1022***\n\n机器人高速布尔函数计算锦标赛的任务由评委会准备。\n\n机器人的一个任务是一张 $m$ 行 $n$ 列的表格，其中每个格子有一个整数权值，且记第 $i$ 行 $j$ 列的格子的权值为 $x_{i,j}$。  \n对于每一列，该列中所有格子的权值组成了一个 $0\\ldots m-1$ 的排列。换句话说，每列中所有格子的权值互不相同：  \n若 $i \\ne k$，则对于所有的 $j$ 有 $x_{i,j} \\ne x_{k,j}$，且有 $0 \\le x_{i,j} < m$。\n\n对于每一列，评委会设置了一个阈值 —— 一个在 $[0,m]$ 内的非负整数 $z_j$。你需要以所有形如 $x_{i,j} < z_j$ 的逻辑表达式的值为参数计算布尔函数的值。一个逻辑表达式的值为 $1$ 当且仅当这个表达式成立，否则为 $0$。\n\n在比赛中，选手们需要计算 $m$ 个布尔函数的值 —— 对每一行计算一次。每个布尔函数以一个**非重复单调线性规划**（NMLP）定义。\n\n考虑第 $i$ 行的 NMLP。  \n这是由 $n-1$ 条以 $1 \\ldots n-1$ 编号的指令组成的一个序列，第 $p$ 条指令给定三个数：$a_p, b_p, op_p$。$op_p$ 只有两种取值：$1$ 表示与运算，$2$ 表示或运算。  \n而 $a_p,b_p$ 则是第 $p$ 个指令的参数，满足 $1 \\le a_p,b_p < n+p$。\n\n考虑一个仅包含 $0$ 和 $1$ 的数组 $val[1\\ldots 2n-1]$。对于 $1 \\le j \\le n$，$val[j] = [x_{i,j} < z_j]$，其中 $[P]$ 表示表达式 $P$ 的值。  \n而 $val[n+p]$ 的值通过第 $p$ 条指令计算。\n - 对于 $op_p = 1$，$val[n+p] = (val[a_p]\\ \\texttt{and}\\ val[b_p])$。\n - 对于 $op_p = 2$，$val[n+p] = (val[a_p]\\ \\texttt{or}\\ val[b_p])$。\n\n该规划是非重复的，也就是说，对于 $p = 1\\ldots n-1$，所有 $2n-2$ 个 $a_p,b_p$ 的值互不相同。\n\n程序执行的结果即为 $val[2n-1]$。\n\n目前评委会已经准备好了所有的 $x_{i,j}$，需要由你来确定每一列的阈值才能完整地准备这个任务。  \n评委会认为一个任务是平衡的，当且仅当所有 $m$ 行中恰有 $s$ 行的布尔函数最后得到的结果为 $1$，其余 $m-s$ 行得到 $0$。  \n你的任务即为替评委会找到合适的阈值。\n\n对于此题，可以证明一定存在至少一种选择阈值的方案满足上述条件。", "inputFormat": "第一行，三个整数 $n,m,s$。  \n以下 $m(n-1)$ 行，第 $i \\cdot (n-1) + p\\;(1 \\le p \\le n-1)$ 行包含三个整数 $a_p,b_p,op_p$，表示第 $i$ 行的第 $p$ 个操作。  \n以下 $m$ 行，每行 $n$ 个整数，表示所有的 $x_{i,j}$。", "outputFormat": "输出 $n$ 个整数 $z_1, z_2, \\ldots, z_n\\;(0 \\le z_j \\le m)$。  \n如有多解，任意输出一个即可。", "hint": "#### 【样例解释】\n在此样例中共有 $3$ 行，你需要令其中恰好两行的函数值为 $1$，另一行的函数值为 $0$。\n让我们看看第一行的 $val$ 数组是什么样的。\n前四个值通过格子中的权值和阈值计算：\n- $val[1] = [x_{1,1} < z_1] = [0 < 0] = 0$；\n- $val[2] = [x_{1,2} < z_2] = [1 < 1] = 0$；\n- $val[3] = [x_{1,3} < z_3] = [2 < 2] = 0$；\n- $val[4] = [x_{1,4} < z_4] = [2 < 3] = 1$。\n\n接下来，对第一行执行线性规划：\n- $val[5] = (val[1]\\ \\texttt{and}\\ val[2]) = (0\\ \\texttt{and}\\ 0) = 0$；\n- $val[6] = (val[3]\\ \\texttt{and}\\ val[4]) = (0\\ \\texttt{and}\\ 1) = 0$；\n- $val[7] = (val[5]\\ \\texttt{or}\\ val[6]) = (0\\ \\texttt{or}\\ 0) = 0$。\n\n因此，第一行的函数值为 $0$。\n顺带一提，若我们整理一下这些式子，可得：\n$$\n[((x_{1,1} < z_1)\\ \\texttt{and}\\ (x_{1,2} < z_2))\\ \\texttt{or}\\ ((x_{1,3} < z_3)\\ \\texttt{and}\\ (x_{1,4} < z_4))]\n$$\n\n类似地，第二行和第三行的函数值分别为\n$$\n[(((x_{2,1} < z_1)\\ \\texttt{or}\\ (x_{2,2} < z_2))\\ \\texttt{and}\\ (x_{2,3} < z_3))\\ \\texttt{or}\\ (x_{2,4} < z_4)]\n$$\n\n和\n$$\n[((x_{3,1} < z_1)\\ \\texttt{and}\\ (x_{3,4} < z_4))\\ \\texttt{or}\\ ((x_{3,2} < z_2)\\ \\texttt{and}\\ (x_{3,3} < z_3))]\n$$\n\n当我们令 $z_1 = 0,z_2 = 1,z_3 = 2,z_4 = 3$ 时，我们可以得到以下表达式：\n第二行：\n$$\n[(((2 < 0)\\ \\texttt{or}\\ (2 < 1))\\ \\texttt{and}\\ (1 < 2))\\ \\texttt{or}\\ (0 < 3)] = 1\n$$\n\n第三行：\n$$\n[((1 < 0)\\ \\texttt{and}\\ (1 < 3))\\ \\texttt{or}\\ ((0 < 1)\\ \\texttt{and}\\ (0 < 2))] = 1\n$$\n\n请注意这不是唯一的解，可行的解还包括 $z_1 = 0, z_2 = 0, z_3 = 3, z_4 = 3$。\n\n\n#### 【数据范围】\n对于 $100\\%$ 的数据，$1 \\le n,m \\le 3 \\cdot 10^5,n \\cdot m \\le 3 \\cdot 10^5,0 \\le s \\le m,1 \\le a_p, b_p \\le n+p,0 \\le x_{i,j} < m$。  \n具体数据限制如下表：\n\n|子任务编号|限制|分值|\n|:-:|:-:|:-:|\n|$1$|$n \\le 2,m \\le 10^3$|$10$|\n|$2$|$n \\le 2,m \\le 10^5$|$10$|\n|$3$|$n \\le 10,m \\le 2$|$10$|\n|$4$|$x_{i,j} = i-1$|$5$|\n|$5$|$op_p=1$|$5$|\n|$6$|$n \\le 100$|$20$|\n|$7$|每一行的 NMLP 相同|$10$|\n|$8$|-|$30$|", "locale": "zh-CN"}}}
{"pid": "P9787", "type": "P", "difficulty": 2, "samples": [["3\n1 2 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "Special Judge", "ROIR（俄罗斯）"], "title": "[ROIR 2020] 最大乘积 (Day2)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day2 T1.** ***[Максимальное произведение](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day2.pdf)***，译者ShineEternal\n\n给定一个自然数组成的数组 $[a_1,a_2,\\ldots,a_n]$。  \n定义一个数组的权值为这个数组中所有数的和。\n\n请把这个数组划分为两个非空数组 $[a_1,a_2,\\ldots,a_i]$ 和 $[a_{i+1},a_{i+2},\\ldots,a_n]$，使得它们的权值之积尽量大。  \n你需要确定能够使得两个数组权值之积最大的 $i$。", "inputFormat": "第一行，一个整数 $n$，表示元素的个数。  \n第二行，$n$ 个整数 $a_1,a_2,\\ldots,a_n$，表示数组中的元素。", "outputFormat": "输出能使得 $[a_1,a_2,\\ldots,a_i]$ 和 $[a_{i+1},a_{i+2},\\ldots,a_n]$ 权值之积最大的 $i$。  \n若有多解，随意输出一解即可。", "hint": "#### 【样例 1 解释】\n如果你选择 $i=1$，则权值之积为 $1 \\cdot (2+3) = 5$。\n如果你选择 $i=2$，则权值之积为 $(1+2) \\cdot 3 = 9$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据，$2 \\le n \\le 2\\cdot 10^5, 1 \\le a_i \\le 10^9$。  \n具体数据限制如下表：\n\n|子任务编号|分值|限制|附加限制|\n|:-:|:-:|:-:|:-:|\n|$1$|$10$|$2 \\le n \\le 5000$|$\\sum a_i \\le 10^9$|\n|$2$|$10$|$2 \\le n \\le 5000$|$a_1 = a_2 = \\ldots = a_n$|\n|$3$|$20$|$2 \\le n \\le 5000$|$a_i \\le 10^9$|\n|$4$|$20$|$2 \\le n \\le 200000$|$\\sum a_i \\le 10^9$|\n|$5$|$20$|$2 \\le n \\le 200000$|$a_1 = a_2 = \\ldots = a_n$|\n|$6$|$20$|$2 \\le n \\le 200000$|$a_i \\le 10^9$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2020] 最大乘积 (Day2)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day2 T1.** ***[Максимальное произведение](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day2.pdf)***，译者ShineEternal\n\n给定一个自然数组成的数组 $[a_1,a_2,\\ldots,a_n]$。  \n定义一个数组的权值为这个数组中所有数的和。\n\n请把这个数组划分为两个非空数组 $[a_1,a_2,\\ldots,a_i]$ 和 $[a_{i+1},a_{i+2},\\ldots,a_n]$，使得它们的权值之积尽量大。  \n你需要确定能够使得两个数组权值之积最大的 $i$。", "inputFormat": "第一行，一个整数 $n$，表示元素的个数。  \n第二行，$n$ 个整数 $a_1,a_2,\\ldots,a_n$，表示数组中的元素。", "outputFormat": "输出能使得 $[a_1,a_2,\\ldots,a_i]$ 和 $[a_{i+1},a_{i+2},\\ldots,a_n]$ 权值之积最大的 $i$。  \n若有多解，随意输出一解即可。", "hint": "#### 【样例 1 解释】\n如果你选择 $i=1$，则权值之积为 $1 \\cdot (2+3) = 5$。\n如果你选择 $i=2$，则权值之积为 $(1+2) \\cdot 3 = 9$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据，$2 \\le n \\le 2\\cdot 10^5, 1 \\le a_i \\le 10^9$。  \n具体数据限制如下表：\n\n|子任务编号|分值|限制|附加限制|\n|:-:|:-:|:-:|:-:|\n|$1$|$10$|$2 \\le n \\le 5000$|$\\sum a_i \\le 10^9$|\n|$2$|$10$|$2 \\le n \\le 5000$|$a_1 = a_2 = \\ldots = a_n$|\n|$3$|$20$|$2 \\le n \\le 5000$|$a_i \\le 10^9$|\n|$4$|$20$|$2 \\le n \\le 200000$|$\\sum a_i \\le 10^9$|\n|$5$|$20$|$2 \\le n \\le 200000$|$a_1 = a_2 = \\ldots = a_n$|\n|$6$|$20$|$2 \\le n \\le 200000$|$a_i \\le 10^9$|", "locale": "zh-CN"}}}
{"pid": "P9788", "type": "P", "difficulty": 3, "samples": [["3 0", "1"], ["5 0", "5"], ["5 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "剪枝", "扩展欧几里德算法", "ROIR（俄罗斯）"], "title": "[ROIR 2020] 区域规划 (Day2)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day2 T2.** ***[Планировка участка](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day2.pdf)***，译者Alpha1022\n\n*译者注：由于原题面有点令译者难以理解，所以此处直接抽象题意。*\n\n你有四个变量 $a,b,c,d$ 须满足：\n - $a,b,c,d \\in \\mathbb N^*$。\n - $a \\ne x, b \\ne x$。\n - $a > c, b > d$。\n - $a \\cdot b - c \\cdot d = n$。\n\n对于给定的 $x,n$，请求出 $a,b,c,d$ 有多少种取值方案。", "inputFormat": "第一行，两个整数 $n,x$。  \n若 $x=0$，则表示忽略第二个条件。", "outputFormat": "一行，表示 $a,b,c,d$ 的取值方案数。", "hint": "#### 【样例 1 解释】\n此时只有 $a=2,b=2,c=1,d=1$ 是合法的。\n\n#### 【样例 2 解释】\n此时有以下方案是合法的：\n- $a=2,b=3,c=1,d=1$；\n- $a=2,b=4,c=1,d=3$；\n- $a=3,b=2,c=1,d=1$；\n- $a=3,b=3,c=2,d=2$；\n- $a=4,b=2,c=3,d=1$。\n\n#### 【样例 3 解释】\n此时有以下方案是合法的：\n- $a=2,b=4,c=1,d=3$；\n- $a=4,b=2,c=3,d=1$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据，$1 \\le n \\le 3000, 0 \\le x \\le 3000$。  \n具体数据限制如下表：\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$11$|$1 \\le n \\le 50, x=0$|\n|$2$|$10$|$1 \\le n \\le 50$|\n|$3$|$20$|$1 \\le n \\le 500, x=0$|\n|$4$|$22$|$1 \\le n \\le 500$|\n|$5$|$17$|$1 \\le n \\le 3000, x=0$|\n|$6$|$20$|$1 \\le n \\le 3000$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2020] 区域规划 (Day2)", "background": "", "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day2 T2.** ***[Планировка участка](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day2.pdf)***，译者Alpha1022\n\n*译者注：由于原题面有点令译者难以理解，所以此处直接抽象题意。*\n\n你有四个变量 $a,b,c,d$ 须满足：\n - $a,b,c,d \\in \\mathbb N^*$。\n - $a \\ne x, b \\ne x$。\n - $a > c, b > d$。\n - $a \\cdot b - c \\cdot d = n$。\n\n对于给定的 $x,n$，请求出 $a,b,c,d$ 有多少种取值方案。", "inputFormat": "第一行，两个整数 $n,x$。  \n若 $x=0$，则表示忽略第二个条件。", "outputFormat": "一行，表示 $a,b,c,d$ 的取值方案数。", "hint": "#### 【样例 1 解释】\n此时只有 $a=2,b=2,c=1,d=1$ 是合法的。\n\n#### 【样例 2 解释】\n此时有以下方案是合法的：\n- $a=2,b=3,c=1,d=1$；\n- $a=2,b=4,c=1,d=3$；\n- $a=3,b=2,c=1,d=1$；\n- $a=3,b=3,c=2,d=2$；\n- $a=4,b=2,c=3,d=1$。\n\n#### 【样例 3 解释】\n此时有以下方案是合法的：\n- $a=2,b=4,c=1,d=3$；\n- $a=4,b=2,c=3,d=1$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据，$1 \\le n \\le 3000, 0 \\le x \\le 3000$。  \n具体数据限制如下表：\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$11$|$1 \\le n \\le 50, x=0$|\n|$2$|$10$|$1 \\le n \\le 50$|\n|$3$|$20$|$1 \\le n \\le 500, x=0$|\n|$4$|$22$|$1 \\le n \\le 500$|\n|$5$|$17$|$1 \\le n \\le 3000, x=0$|\n|$6$|$20$|$1 \\le n \\le 3000$|", "locale": "zh-CN"}}}
{"pid": "P9789", "type": "P", "difficulty": 5, "samples": [["4\n1 5 10 50\n3\n2\n8\n50", "2 2\n8 4\n49 9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "Special Judge", "ROIR（俄罗斯）"], "title": "[ROIR 2020] ATM (Day 2)", "background": null, "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day2 T3.** ***[Банкомат](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day2.pdf)***,译者ksyx\n\n你正在开发一个多面额 ATM，称为 Universal ATM。具体地说，现在有 $n$ 种升序排序的面额分别为 $a_1,~a_2,~\\ldots,~a_n$ 的纸币，即对于 $i>2$，有 $a_{i-1}<a_i$。除此之外，还保证 $a_1=1$。\n\n假设客户要取总额为 $c$ 的纸币，你开发的 ATM 将使用如下算法进行纸币的分配：每次选取一个选取后发给用户的总金额不超过 $c$ 最大面额，直至总金额达到 $c$。因为存在面额为 $1$ 的纸币，我们可以发现这个算法总是能够结束。\n\n为了评估这个算法的效率，你想知道对于总额不超过 $b$ 的请求最大需要多少张纸币。因为业务场景不同，你总共需要回答 $q$ 个场景下的询问 $b_1,~b_2,~\\ldots,~b_q$。\n\n你的任务是编写一个程序，根据给出的面额列表确定在不同业务场景下最大需要多少张纸币。", "inputFormat": "第一行一个整数 $n$，表示面额的数量。\n\n接下来一行 $n$ 个整数 $a_i$。\n\n第三行一个整数 $q$，表示询问的数量。\n\n接下来 $q$ 行每行一个整数 $b_i$。", "outputFormat": "对于每一个询问，输出两个整数，分别表示取出纸币数量最多的情况下客户取出的总额和取出纸币的数量。如果多个不超过输入中最大总额的取款请求都对应这个纸币数量，输出任意一个。", "hint": "#### 【样例 1 解释】\n各个询问的一种可行解如下：\n\n$2=1+1$，$8=5+1+1+1$，$49=10+10+10+10+5+1+1+1+1$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据，有 $1\\le n\\le 2\\times 10^5$，$1=a_1<a_2<\\ldots<a_n\\le10^{18}$，$1\\le q\\le 2\\times 10^5$，$1\\le b_i\\le 10^{18}$。\n\n各子任务详情如下：\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$13$|$1 \\le n \\le 500,~q\\le 5,~1\\le a_i,b_i\\le500$|\n|$2$|$18$|$n=60,~q\\le 5,~a_i=2^{i-1}$|\n|$3$|$20$|$q\\le 5,~b_i\\le 2\\times 10^5$|\n|$4$|$21$|$q\\le 5$|\n|$5$|$28$||", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2020] ATM (Day 2)", "background": null, "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day2 T3.** ***[Банкомат](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day2.pdf)***,译者ksyx\n\n你正在开发一个多面额 ATM，称为 Universal ATM。具体地说，现在有 $n$ 种升序排序的面额分别为 $a_1,~a_2,~\\ldots,~a_n$ 的纸币，即对于 $i>2$，有 $a_{i-1}<a_i$。除此之外，还保证 $a_1=1$。\n\n假设客户要取总额为 $c$ 的纸币，你开发的 ATM 将使用如下算法进行纸币的分配：每次选取一个选取后发给用户的总金额不超过 $c$ 最大面额，直至总金额达到 $c$。因为存在面额为 $1$ 的纸币，我们可以发现这个算法总是能够结束。\n\n为了评估这个算法的效率，你想知道对于总额不超过 $b$ 的请求最大需要多少张纸币。因为业务场景不同，你总共需要回答 $q$ 个场景下的询问 $b_1,~b_2,~\\ldots,~b_q$。\n\n你的任务是编写一个程序，根据给出的面额列表确定在不同业务场景下最大需要多少张纸币。", "inputFormat": "第一行一个整数 $n$，表示面额的数量。\n\n接下来一行 $n$ 个整数 $a_i$。\n\n第三行一个整数 $q$，表示询问的数量。\n\n接下来 $q$ 行每行一个整数 $b_i$。", "outputFormat": "对于每一个询问，输出两个整数，分别表示取出纸币数量最多的情况下客户取出的总额和取出纸币的数量。如果多个不超过输入中最大总额的取款请求都对应这个纸币数量，输出任意一个。", "hint": "#### 【样例 1 解释】\n各个询问的一种可行解如下：\n\n$2=1+1$，$8=5+1+1+1$，$49=10+10+10+10+5+1+1+1+1$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据，有 $1\\le n\\le 2\\times 10^5$，$1=a_1<a_2<\\ldots<a_n\\le10^{18}$，$1\\le q\\le 2\\times 10^5$，$1\\le b_i\\le 10^{18}$。\n\n各子任务详情如下：\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$13$|$1 \\le n \\le 500,~q\\le 5,~1\\le a_i,b_i\\le500$|\n|$2$|$18$|$n=60,~q\\le 5,~a_i=2^{i-1}$|\n|$3$|$20$|$q\\le 5,~b_i\\le 2\\times 10^5$|\n|$4$|$21$|$q\\le 5$|\n|$5$|$28$||", "locale": "zh-CN"}}}
{"pid": "P9790", "type": "P", "difficulty": 6, "samples": [["6\n1 2 3 4 5 6\n2\n6 0\n2 5", "17\n13\n15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "O2优化", "ROIR（俄罗斯）"], "title": "[ROIR 2020] 海报 (Day 2)", "background": null, "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day2 T4.** ***[Плакаты](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day2.pdf)***,译者ksyx\n\n你的朋友们为了会见 IOI 回来的国家队选手准备了很多漂亮的海报，现在就还差要考虑些细节了。\n\n为了欢迎这些选手，你的 $n$ 个朋友会拿着海报站成一个圈。为了方便描述，我们把他们编号为朋友 $1\\ldots n$，其中对于 $i\\in [1,n-1]$，朋友 $i$ 和朋友 $i+1$ 站在一起，且朋友 $n$ 和朋友 $1$ 站在一起。\n\n每张海报都有一个美观度，其中朋友 $i$ 拿着的海报的美观度为 $a_i$。当开始庆祝时，一些朋友会举起他们的海报。为了美观，不能有 $4$ 个或以上排在一起的朋友同时举起他们的海报。\n\n为了能够丰富节目效果，你的朋友们还打算在庆祝过程中更换 $q$ 次海报。每次更换后，海报 $p_i$ 的美观度将变为 $v_i$。你的朋友想知道每次更换后在符合上述条件下的最大美观度之和。\n\n你的任务是给出初始的美观度，求出初始以及各次更换后的最大美观度之和。\n\n*译者注：题面省略了部分难以理解的不必要细节。*", "inputFormat": "第一行一个整数 $n$，朋友总数。\n\n接下来一行 $n$ 个整数 $a_i$，表示初始美观度。\n\n第三行 $q$ 个整数表示海报更换次数。\n\n接下来 $q$ 行每行两个整数 $p_i,~v_i$，描述一次更换。", "outputFormat": "输出 $q+1$ 行，表示初始时及各次更换后最大的美观度之和。", "hint": "#### 【样例 1 解释】\n初始状态下最佳方案为让朋友 $2,~4,~5,~6$ 举起海报，此时美观度之和为 $17$。\n\n第一次改变后朋友 $6$ 的海报美观度变为 $0$，在此情况下最佳方案为让朋友 $1,~3,~4,~5$ 举起海报，美观度之和为 $13$。\n\n第二次改变后朋友 $2$ 的海报美观度变为 $5$，在此情况下最佳方案为让朋友 $1,~2,~4,~5$ 举起海报，美观度之和为 $15$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据，有 $4\\le n\\le 40000,~0\\le a_i,~v_i\\le 10^9,~1\\le p_i\\le n,~0\\le q\\le 40000$。\n\n\n各子任务如下：\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$11$|$4 \\le n \\le 10,~q=0$|\n|$2$|$12$|$4 \\le n \\le 10,~0\\le q\\le 10$|\n|$3$|$13$|$4 \\le n \\le 1000,~0\\le q\\le 1000$|\n|$4$|$17$|$4 \\le n \\le 40000,~q=0$|\n|$5$|$47$|$4 \\le n \\le 40000, 0\\le q\\le 40000$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2020] 海报 (Day 2)", "background": null, "description": "**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day2 T4.** ***[Плакаты](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day2.pdf)***,译者ksyx\n\n你的朋友们为了会见 IOI 回来的国家队选手准备了很多漂亮的海报，现在就还差要考虑些细节了。\n\n为了欢迎这些选手，你的 $n$ 个朋友会拿着海报站成一个圈。为了方便描述，我们把他们编号为朋友 $1\\ldots n$，其中对于 $i\\in [1,n-1]$，朋友 $i$ 和朋友 $i+1$ 站在一起，且朋友 $n$ 和朋友 $1$ 站在一起。\n\n每张海报都有一个美观度，其中朋友 $i$ 拿着的海报的美观度为 $a_i$。当开始庆祝时，一些朋友会举起他们的海报。为了美观，不能有 $4$ 个或以上排在一起的朋友同时举起他们的海报。\n\n为了能够丰富节目效果，你的朋友们还打算在庆祝过程中更换 $q$ 次海报。每次更换后，海报 $p_i$ 的美观度将变为 $v_i$。你的朋友想知道每次更换后在符合上述条件下的最大美观度之和。\n\n你的任务是给出初始的美观度，求出初始以及各次更换后的最大美观度之和。\n\n*译者注：题面省略了部分难以理解的不必要细节。*", "inputFormat": "第一行一个整数 $n$，朋友总数。\n\n接下来一行 $n$ 个整数 $a_i$，表示初始美观度。\n\n第三行 $q$ 个整数表示海报更换次数。\n\n接下来 $q$ 行每行两个整数 $p_i,~v_i$，描述一次更换。", "outputFormat": "输出 $q+1$ 行，表示初始时及各次更换后最大的美观度之和。", "hint": "#### 【样例 1 解释】\n初始状态下最佳方案为让朋友 $2,~4,~5,~6$ 举起海报，此时美观度之和为 $17$。\n\n第一次改变后朋友 $6$ 的海报美观度变为 $0$，在此情况下最佳方案为让朋友 $1,~3,~4,~5$ 举起海报，美观度之和为 $13$。\n\n第二次改变后朋友 $2$ 的海报美观度变为 $5$，在此情况下最佳方案为让朋友 $1,~2,~4,~5$ 举起海报，美观度之和为 $15$。\n\n#### 【数据范围】\n对于 $100\\%$ 的数据，有 $4\\le n\\le 40000,~0\\le a_i,~v_i\\le 10^9,~1\\le p_i\\le n,~0\\le q\\le 40000$。\n\n\n各子任务如下：\n\n|子任务编号|分值|限制|\n|:-:|:-:|:-:|\n|$1$|$11$|$4 \\le n \\le 10,~q=0$|\n|$2$|$12$|$4 \\le n \\le 10,~0\\le q\\le 10$|\n|$3$|$13$|$4 \\le n \\le 1000,~0\\le q\\le 1000$|\n|$4$|$17$|$4 \\le n \\le 40000,~q=0$|\n|$5$|$47$|$4 \\le n \\le 40000, 0\\le q\\le 40000$|", "locale": "zh-CN"}}}
{"pid": "P9791", "type": "P", "difficulty": 6, "samples": [["6\n75 0\n90 90\n20 0\n0 75\n78 50\n80 100", "3:0\n25:0 25:0 25:0\n3:1\n25:22 25:22 15:25 25:21\nImpossible\n0:3\n0:25 0:25 0:25\n3:0\n25:11 28:26 25:13\n3:2\n25:17 0:25 25:22 15:25 15:11"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2018] Alice the Fan", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) A 题。", "description": "Alice 喜欢看排球比赛，她尤其喜欢看 A 队打球，排球比赛的规则如下：\n\n- 一场比赛最多有 $5$ 局。\n\n- 前面 $4$ 均需获得至少 $25$ 分方可获胜，第 $5$ 局仅需获得 $15$ 分。\n\n- 如果单局内其中一方满足获胜条件**但是**双方比分之差不满 $2$，不算获胜。\n\n- 有一方比分达到 $3$ 即为获胜，此时立刻结束比赛。\n\n现在分别给你 A 队和 B 队赢球的个数，请你帮忙确定 A 队最好的比分是多少，或者确定这场球赛还没有结束。\n\n（注：本题定义最好的比分为，如果 A 队可以赢，要使得它们两队的比分差尽可能大，反之尽可能小。）", "inputFormat": "第一行一个整数 $m(1 \\leq m \\leq 50000)$，表示 A 队打过 $m$ 场不同的比赛。\n\n接下来 $m$ 行，每行两个整数 $a(1 \\leq a \\leq 200)$ 和 $b(1 \\leq b \\leq 200)$，分别表示该场比赛 A 队和 B 队的得分。", "outputFormat": "对于每场比赛，输出 A 队最好的比分情况和一种符合条件的**每场**的比分，或者确定这是不可能的，输出 `Impossible`。", "hint": "测试数据保证 $1 \\leq m \\leq 50000$，$1 \\leq a,b \\leq 200$。\n\n注：由于技术原因，SPJ 在评测时出现 UKE 是因为您的代码存在谬误，造成了 SPJ 读取字符时多/少读取到了，后面便无法正常评测。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018] Alice the Fan", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) A 题。", "description": "Alice 喜欢看排球比赛，她尤其喜欢看 A 队打球，排球比赛的规则如下：\n\n- 一场比赛最多有 $5$ 局。\n\n- 前面 $4$ 均需获得至少 $25$ 分方可获胜，第 $5$ 局仅需获得 $15$ 分。\n\n- 如果单局内其中一方满足获胜条件**但是**双方比分之差不满 $2$，不算获胜。\n\n- 有一方比分达到 $3$ 即为获胜，此时立刻结束比赛。\n\n现在分别给你 A 队和 B 队赢球的个数，请你帮忙确定 A 队最好的比分是多少，或者确定这场球赛还没有结束。\n\n（注：本题定义最好的比分为，如果 A 队可以赢，要使得它们两队的比分差尽可能大，反之尽可能小。）", "inputFormat": "第一行一个整数 $m(1 \\leq m \\leq 50000)$，表示 A 队打过 $m$ 场不同的比赛。\n\n接下来 $m$ 行，每行两个整数 $a(1 \\leq a \\leq 200)$ 和 $b(1 \\leq b \\leq 200)$，分别表示该场比赛 A 队和 B 队的得分。", "outputFormat": "对于每场比赛，输出 A 队最好的比分情况和一种符合条件的**每场**的比分，或者确定这是不可能的，输出 `Impossible`。", "hint": "测试数据保证 $1 \\leq m \\leq 50000$，$1 \\leq a,b \\leq 200$。\n\n注：由于技术原因，SPJ 在评测时出现 UKE 是因为您的代码存在谬误，造成了 SPJ 读取字符时多/少读取到了，后面便无法正常评测。", "locale": "zh-CN"}}}
{"pid": "P9792", "type": "P", "difficulty": 6, "samples": [["2\n2 3\n111\n111\n3 4\n0110\n1100\n0011", "1\n2"], ["1\n3 6\n001100\n111111\n001100", "2"]], "limits": {"time": [1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "ICPC", "NERC/NEERC"], "title": "[NERC 2018]  Bimatching", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) B 题。", "description": "你与一些好友一起举办了一个舞会！\n\n在这个舞会上，有 $n$ 位男性和 $m$ 位女性，本来舞蹈的形式是一男一女跳的，但是由于男性紧缺，你并不能让所有女性都有一个男性舞伴，于是你发明了一种新的舞蹈形式：一个男性，搭配两个女舞伴。\n\n当然，每个女性在挑选舞伴时，都会对那些男性舞伴做出评价，如果评价是 $1$，说明这位女性愿意和这位男性一起跳舞，只有当两位女性都愿意和那位男性跳舞时，才能成为一对舞伴。\n\n你作为一个组织者，自然要为大家着想，你需要求出能凑出的最多的舞伴对数，**每个舞伴不能重叠**。", "inputFormat": "第一行一个数 $t (1 \\leq t \\leq 20)$，表示数据组数。\n\n接下来 $t$ 组数据，每组第一行两个整数 $n$ 和 $m$，此处我们保证 $1 \\leq n,m$ 且 $n + m \\leq 150$。\n\n然后一个 $n \\times m$ 的矩阵，$a_{i,j}$ 表示 $j$ 号女士是否愿意和 $i$ 号男士一起跳舞。", "outputFormat": "对于每组测试数据，输出一行，表示最多能凑出的舞伴对数。", "hint": "数据保证 $1 \\leq t \\leq 20$，$1 \\leq n, m$ 且 $n + m \\leq 150$。\n\n下图是对样例一和样例二的解释，其中加粗部分表示其中的一种可行方案。\n\n样例一：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9dfwv4dr.png)\n\n样例二：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/woscpjcn.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018]  Bimatching", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) B 题。", "description": "你与一些好友一起举办了一个舞会！\n\n在这个舞会上，有 $n$ 位男性和 $m$ 位女性，本来舞蹈的形式是一男一女跳的，但是由于男性紧缺，你并不能让所有女性都有一个男性舞伴，于是你发明了一种新的舞蹈形式：一个男性，搭配两个女舞伴。\n\n当然，每个女性在挑选舞伴时，都会对那些男性舞伴做出评价，如果评价是 $1$，说明这位女性愿意和这位男性一起跳舞，只有当两位女性都愿意和那位男性跳舞时，才能成为一对舞伴。\n\n你作为一个组织者，自然要为大家着想，你需要求出能凑出的最多的舞伴对数，**每个舞伴不能重叠**。", "inputFormat": "第一行一个数 $t (1 \\leq t \\leq 20)$，表示数据组数。\n\n接下来 $t$ 组数据，每组第一行两个整数 $n$ 和 $m$，此处我们保证 $1 \\leq n,m$ 且 $n + m \\leq 150$。\n\n然后一个 $n \\times m$ 的矩阵，$a_{i,j}$ 表示 $j$ 号女士是否愿意和 $i$ 号男士一起跳舞。", "outputFormat": "对于每组测试数据，输出一行，表示最多能凑出的舞伴对数。", "hint": "数据保证 $1 \\leq t \\leq 20$，$1 \\leq n, m$ 且 $n + m \\leq 150$。\n\n下图是对样例一和样例二的解释，其中加粗部分表示其中的一种可行方案。\n\n样例一：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9dfwv4dr.png)\n\n样例二：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/woscpjcn.png)", "locale": "zh-CN"}}}
{"pid": "P9793", "type": "P", "difficulty": 5, "samples": [["5 2\n5 1 2 3 4 5\n2 1 3\n\nFOUND\nGO 4\nFOUND\nGO 2\nFOUND\nGO 1\nFOUND\nGO 4\nGO 5\nFOUND", "\n\n\n\n3\n3\n4\n3\n2\n3\n1\n3\n4\n5"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "交互题", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2018] Cactus Search", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) C 题。\n\n如果你想让数组问题更难解决，可以在树上解决；如果你想让树的问题更难解决，可以在仙人掌上解决。", "description": "在前几年，就有过人提出了许多关于仙人掌——连通无向图的问题，其中每条边最多属于一个简单的循环。更加直观地说，仙人掌是一棵树的概括，在这棵树上允许有一些环。下面的图片给出了仙人掌的一个例子。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a44vr6aa.png)\n\n你和 Chloe 在一个仙人掌上玩游戏，你有一株仙人掌，但是淘气的 Chloe 偷偷拿走了一个顶点 $v$，你需要在 $10$ 次以内猜出 $v$，如果你猜到了 $v$，那你就赢了，如果你猜测的是另一个点 $u$，Chloe 会告诉你一个点 $w$，其中 $w$ 到 $v$ 经过的边数严格小于 $u$ 到 $v$。", "inputFormat": "首先，第一行给你两个整数 $n$ 和 $m$，其中 $n$ 表示一共有 $n$ 个顶点，图的边由一组边不同的路径表示，$m$ 表示它们的数量。\n\n接下来一行，$m$ 个整数 $k_i$，表示该条路径经过了 $k_i$ 个顶点，然后接下来 $k_i$ 个整数，表示一次经过的路径（不会重复经过点）。输入中的图形是一个仙人掌。每次猜测，程序会返回你一些返回值，如果是 `FOUND`，说明你猜对了，否则是 `GO w`，表示 $w$ 到 $v$ 经过的边数严格小于你猜测的点到 $v$ 的边数。你的程序每次询问要猜测不超过 $10$ 次，如果你猜测的次数 $> 10$ 次，那么你就不通过该测试点。\n\n此外为了避免你是蒙对的，需要进行 $n$ 次询问，每次猜测成功后，你直接进行下一轮询问，询问 $n$ 次完直接退出。", "outputFormat": "每次询问，你需要向**标准输出**输出一个整数 $u$，代表你猜测的结果，**然后清空缓冲区**。\n\n你可以使用如下语句来清空缓冲区：\n\n- 对于 C/C++：`fflush(stdout)`；\n- 对于 C++：`std::cout << std::flush`；\n- 对于 Java：`System.out.flush()`；\n- 对于 Python：`stdout.flush()`；\n- 对于 Pascal：`flush(output)`；\n- 对于其他语言，请自行查阅对应语言的帮助文档。", "hint": "数据保证 $1 \\leq n \\leq 500$，$0 \\leq m \\leq 500$，$1 \\leq k_i \\leq 500$。\n\n注：为了方便比对，在样例输入输出上加入了一些空行进行对齐，实际输入输出中没有这些空行。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018] Cactus Search", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) C 题。\n\n如果你想让数组问题更难解决，可以在树上解决；如果你想让树的问题更难解决，可以在仙人掌上解决。", "description": "在前几年，就有过人提出了许多关于仙人掌——连通无向图的问题，其中每条边最多属于一个简单的循环。更加直观地说，仙人掌是一棵树的概括，在这棵树上允许有一些环。下面的图片给出了仙人掌的一个例子。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a44vr6aa.png)\n\n你和 Chloe 在一个仙人掌上玩游戏，你有一株仙人掌，但是淘气的 Chloe 偷偷拿走了一个顶点 $v$，你需要在 $10$ 次以内猜出 $v$，如果你猜到了 $v$，那你就赢了，如果你猜测的是另一个点 $u$，Chloe 会告诉你一个点 $w$，其中 $w$ 到 $v$ 经过的边数严格小于 $u$ 到 $v$。", "inputFormat": "首先，第一行给你两个整数 $n$ 和 $m$，其中 $n$ 表示一共有 $n$ 个顶点，图的边由一组边不同的路径表示，$m$ 表示它们的数量。\n\n接下来一行，$m$ 个整数 $k_i$，表示该条路径经过了 $k_i$ 个顶点，然后接下来 $k_i$ 个整数，表示一次经过的路径（不会重复经过点）。输入中的图形是一个仙人掌。每次猜测，程序会返回你一些返回值，如果是 `FOUND`，说明你猜对了，否则是 `GO w`，表示 $w$ 到 $v$ 经过的边数严格小于你猜测的点到 $v$ 的边数。你的程序每次询问要猜测不超过 $10$ 次，如果你猜测的次数 $> 10$ 次，那么你就不通过该测试点。\n\n此外为了避免你是蒙对的，需要进行 $n$ 次询问，每次猜测成功后，你直接进行下一轮询问，询问 $n$ 次完直接退出。", "outputFormat": "每次询问，你需要向**标准输出**输出一个整数 $u$，代表你猜测的结果，**然后清空缓冲区**。\n\n你可以使用如下语句来清空缓冲区：\n\n- 对于 C/C++：`fflush(stdout)`；\n- 对于 C++：`std::cout << std::flush`；\n- 对于 Java：`System.out.flush()`；\n- 对于 Python：`stdout.flush()`；\n- 对于 Pascal：`flush(output)`；\n- 对于其他语言，请自行查阅对应语言的帮助文档。", "hint": "数据保证 $1 \\leq n \\leq 500$，$0 \\leq m \\leq 500$，$1 \\leq k_i \\leq 500$。\n\n注：为了方便比对，在样例输入输出上加入了一些空行进行对齐，实际输入输出中没有这些空行。", "locale": "zh-CN"}}}
{"pid": "P9794", "type": "P", "difficulty": 6, "samples": [["4 4\n1 2\n2 3\n3 1\n3 4", "8"], ["7 10\n1 2\n2 6\n5 3\n5 4\n5 7\n3 6\n1 7\n5 1\n7 4\n4 1", "34"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2018", "ICPC", "NERC/NEERC"], "title": "[NERC 2018]  Distance Sum", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) D 题。", "description": "给你一个 $n$ 个顶点 $m$ 条边的连通无向图，定义 $u$ 与 $v$ 的距离 $d(u, v)$ 为从 $u$ 到 $v$ 最短路径上经过的边数。\n\n现在请你求出 $\\sum_{u=1}^n \\sum_{v=u+1}^n d(u,v)$。", "inputFormat": "第一行给定两个整数 $n(1 \\leq n \\leq 10^5)$，$m(n - 1 \\leq m \\leq n + 42)$，分别表示点数和边数。\n\n接下来 $m$ 行，每行 $2$ 个整数 $x_i$ 和 $y_i(1 \\leq x_i,y_i \\leq n, x_i \\neq y_i)$，表示 $x_i$ 和 $y_i$ 之间有一条边。\n\n保证没有重边和自环。", "outputFormat": "输出 $\\sum_{u=1}^n \\sum_{v=u+1}^n d(u,v)$。", "hint": "对于所有数据保证 $1 \\leq n \\leq 10^5$，$n-1 \\leq m \\leq n + 42$，$1 \\leq x_i, y_i \\leq n$ 且 $x_i \\neq y_i$。\n\n样例一的图是：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/39wue8qr.png)\n\n其中 $d(1,2) = 1$，$d(1,3) = 1$，$d(1,4) = 2$，$d(2,3) = 1$，$d(2,3) = 2$，$d(3,4) = 1$，总和为 $1 + 1 + 2 + 1 + 2 + 1 = 8$。\n\n样例二为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/89k279bd.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018]  Distance Sum", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) D 题。", "description": "给你一个 $n$ 个顶点 $m$ 条边的连通无向图，定义 $u$ 与 $v$ 的距离 $d(u, v)$ 为从 $u$ 到 $v$ 最短路径上经过的边数。\n\n现在请你求出 $\\sum_{u=1}^n \\sum_{v=u+1}^n d(u,v)$。", "inputFormat": "第一行给定两个整数 $n(1 \\leq n \\leq 10^5)$，$m(n - 1 \\leq m \\leq n + 42)$，分别表示点数和边数。\n\n接下来 $m$ 行，每行 $2$ 个整数 $x_i$ 和 $y_i(1 \\leq x_i,y_i \\leq n, x_i \\neq y_i)$，表示 $x_i$ 和 $y_i$ 之间有一条边。\n\n保证没有重边和自环。", "outputFormat": "输出 $\\sum_{u=1}^n \\sum_{v=u+1}^n d(u,v)$。", "hint": "对于所有数据保证 $1 \\leq n \\leq 10^5$，$n-1 \\leq m \\leq n + 42$，$1 \\leq x_i, y_i \\leq n$ 且 $x_i \\neq y_i$。\n\n样例一的图是：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/39wue8qr.png)\n\n其中 $d(1,2) = 1$，$d(1,3) = 1$，$d(1,4) = 2$，$d(2,3) = 1$，$d(2,3) = 2$，$d(3,4) = 1$，总和为 $1 + 1 + 2 + 1 + 2 + 1 = 8$。\n\n样例二为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/89k279bd.png)", "locale": "zh-CN"}}}
{"pid": "P9795", "type": "P", "difficulty": 4, "samples": [["4", "a1 f1 c1 c8 h8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2018", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2018] Easy Chess", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) E 题。", "description": "Elma 正在学习象棋。\n\nElma 是个新手，她还不特别了解象棋是如何下的，所以，为了更好地让她了解象棋，她的奶奶让她从一个棋盘（如下图）中进行 $n$ 次移动，每次移动只能是水平或垂直地移动若干个格子的，且每个点只能到达一次，使得从 a1 到 h8 处。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zlooykdb.png)", "inputFormat": "输入一个数 $n(2 \\leq n \\leq 63)$，表示你一共需要走的步数。", "outputFormat": "给出一种可行方案且保证停留过的点不重复。", "hint": "对于所有数据保证 $2 \\leq n \\leq 63$ 且保证存在至少一种合法方案。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018] Easy Chess", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) E 题。", "description": "Elma 正在学习象棋。\n\nElma 是个新手，她还不特别了解象棋是如何下的，所以，为了更好地让她了解象棋，她的奶奶让她从一个棋盘（如下图）中进行 $n$ 次移动，每次移动只能是水平或垂直地移动若干个格子的，且每个点只能到达一次，使得从 a1 到 h8 处。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zlooykdb.png)", "inputFormat": "输入一个数 $n(2 \\leq n \\leq 63)$，表示你一共需要走的步数。", "outputFormat": "给出一种可行方案且保证停留过的点不重复。", "hint": "对于所有数据保证 $2 \\leq n \\leq 63$ 且保证存在至少一种合法方案。", "locale": "zh-CN"}}}
{"pid": "P9796", "type": "P", "difficulty": 5, "samples": [["2", "NO"], ["6", "YES\n2\n1 2\n1 3"]], "limits": {"time": [1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2018] Fractions", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) F 题。", "description": "给你一个整数 $n$，你需要构造出若干个形如 $\\dfrac{a_i}{b_i}$ 的真分数，使得 $\\sum^k_{i=1} \\frac{a_i}{b_i} = 1 - \\frac{1}{n}$，且 $b_i$ 可以整除 $n$。", "inputFormat": "一个正整数 $n (2 \\leq n \\leq 10^9)$。", "outputFormat": "如果不能构造，输出一行 `NO`。\n\n否则的话就构造出其中一种的合法方案，输出 `YES`，然后让 $\\sum^k_{i=1} \\frac{a_i}{b_i} = 1 - \\frac{1}{n}$，按第二行第一个整数 $k$，接下来 $k$ 行一行两个整数 $a_i$ 和 $b_i(b_i \\neq n)$。\n\n注意你输出的 $k$ 的范围是 $2 \\leq k \\leq 10^5$。", "hint": "对于所有的数据，保证 $2 \\leq n \\leq 10^9$。\n\n对于第一个样例，不存在一种方案使得答案总和为 $\\frac{1}{2}$。\n\n对于第二个样例，$\\frac{1}{2} + \\frac{1}{3} = \\frac{5}{6}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018] Fractions", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) F 题。", "description": "给你一个整数 $n$，你需要构造出若干个形如 $\\dfrac{a_i}{b_i}$ 的真分数，使得 $\\sum^k_{i=1} \\frac{a_i}{b_i} = 1 - \\frac{1}{n}$，且 $b_i$ 可以整除 $n$。", "inputFormat": "一个正整数 $n (2 \\leq n \\leq 10^9)$。", "outputFormat": "如果不能构造，输出一行 `NO`。\n\n否则的话就构造出其中一种的合法方案，输出 `YES`，然后让 $\\sum^k_{i=1} \\frac{a_i}{b_i} = 1 - \\frac{1}{n}$，按第二行第一个整数 $k$，接下来 $k$ 行一行两个整数 $a_i$ 和 $b_i(b_i \\neq n)$。\n\n注意你输出的 $k$ 的范围是 $2 \\leq k \\leq 10^5$。", "hint": "对于所有的数据，保证 $2 \\leq n \\leq 10^9$。\n\n对于第一个样例，不存在一种方案使得答案总和为 $\\frac{1}{2}$。\n\n对于第二个样例，$\\frac{1}{2} + \\frac{1}{3} = \\frac{5}{6}$。", "locale": "zh-CN"}}}
{"pid": "P9797", "type": "P", "difficulty": 2, "samples": [["3\n2\n0 1 0 0 0 0 0\n100000000\n1 0 0 0 1 0 1\n1\n1 0 0 0 0 0 0", "8\n233333332\n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "ICPC", "NERC/NEERC"], "title": "[NERC 2018]  Guest Student", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) G 题。", "description": "你作为某知名大学的客座学生，你想要在那里学习 $k$ 节课，但同时很遗憾，对于每周，你只有特定的时间才能有空去听课，如果 $a_i = 1$，说明周 $i$ 你有空，反之则没空。\n\n你需要安排一个合理的日程，使得你去听第一节课到最后一节课中间经过的时间最短，当然第一节课听什么的顺序由你决定。", "inputFormat": "第一行一个整数 $t (1 \\leq t \\leq 10000)$，表示数据组数。\n\n接下来每组数据第一行一个整数 $k (1 \\leq k \\leq 10^8)$。\n\n然后 $7$ 个整数 $a_1 \\sim a_7$，$a_i = 1$ 表示有空，$a_i = 0$ 表示没空。", "outputFormat": "对于每组数据，输出一个整数，表示最短的从第一节课到最后一节课所经过的时间。", "hint": "对于所有数据，保证 $1 \\leq t \\leq 10000$，$1 \\leq k \\leq 10^8$ 且 $a_i \\in \\{0,1\\}$。\n\n对于样例一，从周二开始听课听到下周二，经过 $8$ 天。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018]  Guest Student", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) G 题。", "description": "你作为某知名大学的客座学生，你想要在那里学习 $k$ 节课，但同时很遗憾，对于每周，你只有特定的时间才能有空去听课，如果 $a_i = 1$，说明周 $i$ 你有空，反之则没空。\n\n你需要安排一个合理的日程，使得你去听第一节课到最后一节课中间经过的时间最短，当然第一节课听什么的顺序由你决定。", "inputFormat": "第一行一个整数 $t (1 \\leq t \\leq 10000)$，表示数据组数。\n\n接下来每组数据第一行一个整数 $k (1 \\leq k \\leq 10^8)$。\n\n然后 $7$ 个整数 $a_1 \\sim a_7$，$a_i = 1$ 表示有空，$a_i = 0$ 表示没空。", "outputFormat": "对于每组数据，输出一个整数，表示最短的从第一节课到最后一节课所经过的时间。", "hint": "对于所有数据，保证 $1 \\leq t \\leq 10000$，$1 \\leq k \\leq 10^8$ 且 $a_i \\in \\{0,1\\}$。\n\n对于样例一，从周二开始听课听到下周二，经过 $8$ 天。", "locale": "zh-CN"}}}
{"pid": "P9798", "type": "P", "difficulty": 7, "samples": [["3\n2 2\nAE\n1 -2\n-1 2\n2 2\nEA\n1 -2\n-1 2\n3 2\nAEA\n1 -2\n-1 -3\n", "TRUE\nFALSE\nFALSE\n"]], "limits": {"time": [1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "ICPC", "NERC/NEERC"], "title": "[NERC 2018] Harder Satisfiability", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) H 题。", "description": "我们定义一个“完全量化的布尔类型的 2-CNF 公式”（下简称 2-CNF）是以 $Q_1 x_1 \\ldots Q_n x_n F(x_1,\\ldots x_n)$ 构成的，$Q_i$ 只有两种，一种是“通用量词” $\\forall$，另一种是“存在量词” $\\exists$。然后 $F$ 是一个 $m$ 子句的 $s \\lor t$（$\\mathtt{OR}$ 运算） 的连词（$\\mathtt{AND}$ 运算），其中 $s$ 和 $t$ 不一定不同且不一定是否定（为 $\\texttt{false}$）。由于 2-CNF 公式是给定的，所以并没有自由变量（即答案固定为 $\\texttt{true}$ 或 $\\texttt{false}$）。\n\n至于计算 2-CNF 公式的值，我们可以使用一个简单的递归算法来求：\n\n- 如果没有量词（即 $\\forall$ 或 $\\exists$ ），则返回剩余表达式的返回值。\n\n- 否则，我们使用递归计算公式：$F_z = Q_2x_2 \\ldots Q_nx_n F(z,x_2,\\ldots,x_n)$，此处 $z = 0,1$。\n\n- 如果当前符号为 $\\exists$，则返回 $F_0 \\lor F_1$（$\\mathtt{OR}$ 运算）。否则符号为 $\\forall$ 返回 $F_0 \\land F_1$。\n", "inputFormat": "第一行是一个整数 $t (1 \\leq t \\leq 10^5)$，表示数据组数。\n\n接下来 $t$ 组数据，每组数据第一行两个整数 $n(1 \\leq n \\leq 10^5)$ 和 $m (1 \\leq m \\leq 10^5)$，$n$ 表示量词的长度，$m$ 表示在 $F$ 中的元素个数。\n\n然后一行，一串长度为 $n$ 的字符串 $s$，如果 $s_i = $ `A`，则 $Q_i = \\forall$，否则若 $s_i = $ `E`，则 $Q_i = \\exists$。\n\n接下来 $m$ 行，一行两个整数 $u_i,v_i(-n \\leq u_i,v_i \\leq n)$，如果 $u_i \\geq 1$ 则第 $i$ 个变量是 $x_{u_i}$，如果 $u_i \\leq -1$ 则第 $i$ 个变量是 $-(x_{-u_i})$，$v_i$ 同理。", "outputFormat": "对于每组数据，如果 2-CNF 公式为真输出 `TRUE`，否则输出 `FALSE`。", "hint": "数据保证 $1 \\leq t \\leq 10^5$，$1 \\leq n,m \\leq 10^5$，$-n \\leq u_i,v_i \\leq n$。\n\n第一个 2-CNF 公式可以化简为 $\\forall x_1 \\exists x_2(x_1 \\lor \\overline{x_2}) \\land (\\overline{x_1} \\lor x_2) = \\forall x_1 \\exists x_2 x_1 \\oplus x_2$，对于任意的 $x_1$ 都存在 $x_2 = \\overline{x_1}$ 使得答案为真。\n\n第二个 2-CNF 改变了公式的顺序，对于任意的 $x_1$，都可以选择 $x_2 = x_1$，使得表达式为 `FALSE`。\n\n第三个表达式是 $\\forall x_1 \\exists x_2 \\forall x_3 (x_1 \\lor \\overline{x_2}) \\land (\\overline{x_1} \\lor \\overline{x_3})$，如果令 $x_1 = 1$，$x_3 = 1$，则没有 $x_2$ 的值可以使得句子赋值为真，所以公式为假。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018] Harder Satisfiability", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) H 题。", "description": "我们定义一个“完全量化的布尔类型的 2-CNF 公式”（下简称 2-CNF）是以 $Q_1 x_1 \\ldots Q_n x_n F(x_1,\\ldots x_n)$ 构成的，$Q_i$ 只有两种，一种是“通用量词” $\\forall$，另一种是“存在量词” $\\exists$。然后 $F$ 是一个 $m$ 子句的 $s \\lor t$（$\\mathtt{OR}$ 运算） 的连词（$\\mathtt{AND}$ 运算），其中 $s$ 和 $t$ 不一定不同且不一定是否定（为 $\\texttt{false}$）。由于 2-CNF 公式是给定的，所以并没有自由变量（即答案固定为 $\\texttt{true}$ 或 $\\texttt{false}$）。\n\n至于计算 2-CNF 公式的值，我们可以使用一个简单的递归算法来求：\n\n- 如果没有量词（即 $\\forall$ 或 $\\exists$ ），则返回剩余表达式的返回值。\n\n- 否则，我们使用递归计算公式：$F_z = Q_2x_2 \\ldots Q_nx_n F(z,x_2,\\ldots,x_n)$，此处 $z = 0,1$。\n\n- 如果当前符号为 $\\exists$，则返回 $F_0 \\lor F_1$（$\\mathtt{OR}$ 运算）。否则符号为 $\\forall$ 返回 $F_0 \\land F_1$。\n", "inputFormat": "第一行是一个整数 $t (1 \\leq t \\leq 10^5)$，表示数据组数。\n\n接下来 $t$ 组数据，每组数据第一行两个整数 $n(1 \\leq n \\leq 10^5)$ 和 $m (1 \\leq m \\leq 10^5)$，$n$ 表示量词的长度，$m$ 表示在 $F$ 中的元素个数。\n\n然后一行，一串长度为 $n$ 的字符串 $s$，如果 $s_i = $ `A`，则 $Q_i = \\forall$，否则若 $s_i = $ `E`，则 $Q_i = \\exists$。\n\n接下来 $m$ 行，一行两个整数 $u_i,v_i(-n \\leq u_i,v_i \\leq n)$，如果 $u_i \\geq 1$ 则第 $i$ 个变量是 $x_{u_i}$，如果 $u_i \\leq -1$ 则第 $i$ 个变量是 $-(x_{-u_i})$，$v_i$ 同理。", "outputFormat": "对于每组数据，如果 2-CNF 公式为真输出 `TRUE`，否则输出 `FALSE`。", "hint": "数据保证 $1 \\leq t \\leq 10^5$，$1 \\leq n,m \\leq 10^5$，$-n \\leq u_i,v_i \\leq n$。\n\n第一个 2-CNF 公式可以化简为 $\\forall x_1 \\exists x_2(x_1 \\lor \\overline{x_2}) \\land (\\overline{x_1} \\lor x_2) = \\forall x_1 \\exists x_2 x_1 \\oplus x_2$，对于任意的 $x_1$ 都存在 $x_2 = \\overline{x_1}$ 使得答案为真。\n\n第二个 2-CNF 改变了公式的顺序，对于任意的 $x_1$，都可以选择 $x_2 = x_1$，使得表达式为 `FALSE`。\n\n第三个表达式是 $\\forall x_1 \\exists x_2 \\forall x_3 (x_1 \\lor \\overline{x_2}) \\land (\\overline{x_1} \\lor \\overline{x_3})$，如果令 $x_1 = 1$，$x_3 = 1$，则没有 $x_2$ 的值可以使得句子赋值为真，所以公式为假。", "locale": "zh-CN"}}}
{"pid": "P9799", "type": "P", "difficulty": 6, "samples": [["4 998244353\n1\n4\n5\n9", "1\n2\n6\n28146"], ["1 437122297\n20", "67777575"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "ICPC", "NERC/NEERC"], "title": "[NERC 2018]  Interval-Free Permutations", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) I 题。", "description": "我们定义一个从 $1 \\sim n$ 的排列是“间隔排列”的情况是，在这个排列中存在连续的一段长度为 $2 \\sim n-1$ 的子区间使得这段子区间在排序后是一串连续的自然数。比如，$\\{6,7,1,8,5,3,2,4\\}$ 是一个“间隔排列”，因为 $\\{6,7\\}$，$\\{5,3,2,4\\}$，$\\{3,2\\}$ 经过排序后都是一段连续的自然数。\n\n现在已知 $n$，请你输出**不是**“间隔排列”的排列总数，由于输出可能很大，请对 $p$ 取模。", "inputFormat": "第一行两个整数 $t (1 \\leq t \\leq 400)$ 和 $p (10^8 \\leq p \\leq 10^9)$，分别表示数据组数和模数。\n\n接下来 $t$ 行，一行一个整数 $n (1 \\leq n \\leq 400)$。", "outputFormat": "对于每组数据输出 $1 \\sim n$ 的所有排列中**不是**“间隔排列”的排列总数对 $p$ 取模的值。", "hint": "数据保证 $1 \\leq t \\leq 400$，$10^8 \\leq p \\leq 10^9$，$1 \\leq n \\leq 400$。\n\n对于样例一的解释：\n\n第二组数据存在 $\\{2,4,1,3\\}$ 和 $\\{3,1,4,2\\}$ 符合要求。\n\n第三组数据存在 $\\{2,4,1,5,3\\}$，$\\{2,5,3,1,4\\}$，$\\{3,1,5,2,4\\}$，$\\{3,5,1,4,2\\}$，$\\{4,1,3,5,2\\}$ 和 $\\{4,2,5,1,3\\}$ 满足要求。\n\n对于样例二，一共有 $264111424634864638$ 种可能。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018]  Interval-Free Permutations", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) I 题。", "description": "我们定义一个从 $1 \\sim n$ 的排列是“间隔排列”的情况是，在这个排列中存在连续的一段长度为 $2 \\sim n-1$ 的子区间使得这段子区间在排序后是一串连续的自然数。比如，$\\{6,7,1,8,5,3,2,4\\}$ 是一个“间隔排列”，因为 $\\{6,7\\}$，$\\{5,3,2,4\\}$，$\\{3,2\\}$ 经过排序后都是一段连续的自然数。\n\n现在已知 $n$，请你输出**不是**“间隔排列”的排列总数，由于输出可能很大，请对 $p$ 取模。", "inputFormat": "第一行两个整数 $t (1 \\leq t \\leq 400)$ 和 $p (10^8 \\leq p \\leq 10^9)$，分别表示数据组数和模数。\n\n接下来 $t$ 行，一行一个整数 $n (1 \\leq n \\leq 400)$。", "outputFormat": "对于每组数据输出 $1 \\sim n$ 的所有排列中**不是**“间隔排列”的排列总数对 $p$ 取模的值。", "hint": "数据保证 $1 \\leq t \\leq 400$，$10^8 \\leq p \\leq 10^9$，$1 \\leq n \\leq 400$。\n\n对于样例一的解释：\n\n第二组数据存在 $\\{2,4,1,3\\}$ 和 $\\{3,1,4,2\\}$ 符合要求。\n\n第三组数据存在 $\\{2,4,1,5,3\\}$，$\\{2,5,3,1,4\\}$，$\\{3,1,5,2,4\\}$，$\\{3,5,1,4,2\\}$，$\\{4,1,3,5,2\\}$ 和 $\\{4,2,5,1,3\\}$ 满足要求。\n\n对于样例二，一共有 $264111424634864638$ 种可能。", "locale": "zh-CN"}}}
{"pid": "P9800", "type": "P", "difficulty": 6, "samples": [["16\nfun while return var { } ( ) , ; > = + ++ - --\n9\nfun fib(num) { # compute fibs\n  var return_value = 1, prev = 0, temp;\n  while (num > 0) {\n    temp = return_value; return_value = return_value + prev;\n    prev = temp;\n    num--;\n  }\n  return return_value;\n}\n", "fun a(b){var c=1,d=0,e;while(b>0){e=c;c=c+d;d=e;b--;}return c;}\n"], ["10\n( ) + ++ : -> >> >>: b c)\n2\n($val1++ + +4 kb) >> :out\nb-> + 10 >>: t # using >>: \n", "(a+++ +4c )>> :d b->+10>>:e\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "ICPC", "NERC/NEERC"], "title": "[NERC 2018] JS Minification", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) J 题。", "description": "你有一个程序，其中每行包含 $0$ 个或多个可以用空格分隔的标记，你需要将其按下列方法“压行”。\n\n- 在每一行中，如果存在 `#` 开头的部分，说明这是一个注释，其与其同一行后面的东西一起不被执行。\n\n- 通过重复跳过空格并从当前解析位置开始查找可能最长的标识符，将每一行从左到右解析为标识符序列，从而将源代码转换为标识符序列。下面列出了所有可能的标识符：\n\n> - 保留标识符：缩小过程中应保留的任何类型的运算符、分隔符、文字、保留字或库函数的名称。保留标记是不包含 `#` 的非空格 ASCII 字符的固定字符串。\n> - 数字标识符：有数字组成的一连串数字字符串。\n> - 单词标识符：由以下集合中的一系列字符组成：小写字母、大写字母、数字、`_`、`$` 且不以数字开头。\n\n请注意，在压缩过程中，满足数字或单词定义，但出现在保留标记列表中的**最长字符序列**被视为保留标识符。\n\n在压缩过程中，使用以下算法以系统的方式重命名单词：\n\n- 定义 $s$ 为若干个由小写字母组成的字符串按长度为第一关键词，字典序为第二关键词进行排序后的序列。\n\n- 将标识符序列中遇到的第一个单词重命名为目标单词列表中的第一个词，并将标识符顺序中出现的所有相同单词重命名成第一个词。然后将标识符序列中遇到的第二个新词重命名为目标单词列表中的第二单词，依此类推。\n\n此外，你可以删除原本某些不必要的空格与换行符。但是注意，你删除后并不可以使原本不是标识符的某些字符串变成了标识符，或是原本是标识符的变成了不是标识符的。", "inputFormat": "输入的第一行包含一个整数 $n \\ (1 \\leq n \\leq 40)$，代表标识符的数量。\n\n输入的第二行包含由空格分隔的保留标识符的列表，该列表中没有重复，长度不小于 $1$，不大于 $20$。\n\n输入的第三行包含单个整数 $m \\ (1 \\leq m \\leq 40)$，代表输入代码中的行数。\n\n接下来 $m$ 行一行一串代码（可能包含前导空格）。", "outputFormat": "输出一行，是对输入代码进行压缩处理的结果。输出解析后的与具有相应重命名后的标识符序列，并且应包含尽可能少的空格。如果有多种方法，那请输出空格最少且长度最小的。", "hint": "保证数据范围 $1 \\leq n \\leq 40$，$1 \\leq m \\leq 40$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018] JS Minification", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) J 题。", "description": "你有一个程序，其中每行包含 $0$ 个或多个可以用空格分隔的标记，你需要将其按下列方法“压行”。\n\n- 在每一行中，如果存在 `#` 开头的部分，说明这是一个注释，其与其同一行后面的东西一起不被执行。\n\n- 通过重复跳过空格并从当前解析位置开始查找可能最长的标识符，将每一行从左到右解析为标识符序列，从而将源代码转换为标识符序列。下面列出了所有可能的标识符：\n\n> - 保留标识符：缩小过程中应保留的任何类型的运算符、分隔符、文字、保留字或库函数的名称。保留标记是不包含 `#` 的非空格 ASCII 字符的固定字符串。\n> - 数字标识符：有数字组成的一连串数字字符串。\n> - 单词标识符：由以下集合中的一系列字符组成：小写字母、大写字母、数字、`_`、`$` 且不以数字开头。\n\n请注意，在压缩过程中，满足数字或单词定义，但出现在保留标记列表中的**最长字符序列**被视为保留标识符。\n\n在压缩过程中，使用以下算法以系统的方式重命名单词：\n\n- 定义 $s$ 为若干个由小写字母组成的字符串按长度为第一关键词，字典序为第二关键词进行排序后的序列。\n\n- 将标识符序列中遇到的第一个单词重命名为目标单词列表中的第一个词，并将标识符顺序中出现的所有相同单词重命名成第一个词。然后将标识符序列中遇到的第二个新词重命名为目标单词列表中的第二单词，依此类推。\n\n此外，你可以删除原本某些不必要的空格与换行符。但是注意，你删除后并不可以使原本不是标识符的某些字符串变成了标识符，或是原本是标识符的变成了不是标识符的。", "inputFormat": "输入的第一行包含一个整数 $n \\ (1 \\leq n \\leq 40)$，代表标识符的数量。\n\n输入的第二行包含由空格分隔的保留标识符的列表，该列表中没有重复，长度不小于 $1$，不大于 $20$。\n\n输入的第三行包含单个整数 $m \\ (1 \\leq m \\leq 40)$，代表输入代码中的行数。\n\n接下来 $m$ 行一行一串代码（可能包含前导空格）。", "outputFormat": "输出一行，是对输入代码进行压缩处理的结果。输出解析后的与具有相应重命名后的标识符序列，并且应包含尽可能少的空格。如果有多种方法，那请输出空格最少且长度最小的。", "hint": "保证数据范围 $1 \\leq n \\leq 40$，$1 \\leq m \\leq 40$。", "locale": "zh-CN"}}}
{"pid": "P9801", "type": "P", "difficulty": 6, "samples": [["19\n? 3\n+ 2 2\n? 3\n? 4\n+ 5 2\n? 5\n? 6\n+ 1 2\n? 2\n? 3\n? 4\n? 5\n? 6\n? 7\n? 9\n- 8\n? 2\n? 3\n? 6", "0\n1\n0\n2\n1\n3\n2\n1\n2\n1\n0\n0\n2\n1\n1"]], "limits": {"time": [2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600, 2600], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "ICPC", "NERC/NEERC"], "title": "[NERC 2018] King Kog’s Reception", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) K 题。", "description": "有些骑士想要拜访国王，但是由于这里的骑士都很遵守礼节，他们都会提前预约好他要来拜访的时刻和拜访将持续的时间。骑士按照接待处记录的时刻顺序依次拜访国王，每个骑士必须等前面的骑士结束拜访。\n\n很不幸，公主也准备要来拜访国王，但善良的公主并不会为此而打乱骑士们拜访的顺序，而她会等待骑士们拜访完了再来拜访，请你计算公主要等多长时间。", "inputFormat": "共 $q+1$ 行。\n\n第一行一个整数 $q (1 \\leq q \\leq 3 \\times 10^5)$。\n\n然后 $q$ 行，先是一个字符。\n\n- 如果字符是 `+`，紧跟在后面两个数字，表示骑士 $i$ 要于 $t (1 \\leq t \\leq 10^6)$ 时刻到达，拜访时间 $d(1 \\leq d \\leq 10^6)$ 时间单位。\n\n- 如果字符是 `-`，后面一个数字 $i(1 \\leq i \\leq q)$，表示骑士 $i$ 暂时取消了他的预约。\n\n- 如果字符是 `?`，后面一个数字 $t (1 \\leq t \\leq 10^6)$，表示公主将于 $t$ 时刻拜访。", "outputFormat": "对于每个 `?`，输出一行，表示公主要等待多长时间。注意此处公主拜访时骑士的预约记录只有前面的几个，并不包含后面加进来的。", "hint": "对于所有数据，保证 $1 \\leq q \\leq 3 \\times 10^5$，$1 \\leq t \\leq 10^6$，$1 \\leq d \\leq 10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018] King Kog’s Reception", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) K 题。", "description": "有些骑士想要拜访国王，但是由于这里的骑士都很遵守礼节，他们都会提前预约好他要来拜访的时刻和拜访将持续的时间。骑士按照接待处记录的时刻顺序依次拜访国王，每个骑士必须等前面的骑士结束拜访。\n\n很不幸，公主也准备要来拜访国王，但善良的公主并不会为此而打乱骑士们拜访的顺序，而她会等待骑士们拜访完了再来拜访，请你计算公主要等多长时间。", "inputFormat": "共 $q+1$ 行。\n\n第一行一个整数 $q (1 \\leq q \\leq 3 \\times 10^5)$。\n\n然后 $q$ 行，先是一个字符。\n\n- 如果字符是 `+`，紧跟在后面两个数字，表示骑士 $i$ 要于 $t (1 \\leq t \\leq 10^6)$ 时刻到达，拜访时间 $d(1 \\leq d \\leq 10^6)$ 时间单位。\n\n- 如果字符是 `-`，后面一个数字 $i(1 \\leq i \\leq q)$，表示骑士 $i$ 暂时取消了他的预约。\n\n- 如果字符是 `?`，后面一个数字 $t (1 \\leq t \\leq 10^6)$，表示公主将于 $t$ 时刻拜访。", "outputFormat": "对于每个 `?`，输出一行，表示公主要等待多长时间。注意此处公主拜访时骑士的预约记录只有前面的几个，并不包含后面加进来的。", "hint": "对于所有数据，保证 $1 \\leq q \\leq 3 \\times 10^5$，$1 \\leq t \\leq 10^6$，$1 \\leq d \\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P9802", "type": "P", "difficulty": 3, "samples": [["8 7\n1 1 3 1 5 3 7 1\n5 7 4 8 1 3 5 2", "10"], ["3 3\n3 1 2\n5 3 4", "0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2018", "排序", "ICPC", "NERC/NEERC"], "title": "[NERC 2018] Lazyland", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) L 题。", "description": "一个城市里有 $n$ 个人，和 $k$ 种职业，其中，每个人都有一个现在正在从事的职业 $a_i$，但是很遗憾，由于某些职业的空缺，使得这个城市根本无法继续正常生存下去。\n\n你作为一城之主，自然不希望看到自己的城市这样子下去，你决定说服其中的某些人，使得每种职业都有人在做，对于每个人 $i$，你需要耗费 $b_i$ 的时间去说服。\n\n你需要求出你去说服的时间的最小值。", "inputFormat": "第一行两个整数 $n$ 和 $k (1 \\leq k \\leq n \\leq 10^5)$，分别表示 $n$ 个人和 $k$ 种职业。\n\n第二行 $n$ 个整数 $a_i (1 \\leq a_i \\leq k)$，表示第 $i$ 个人正在从事的职业 。\n\n第三行 $n$ 个整数 $b_i (1 \\leq b_i \\leq 10^9)$，表示第 $i$ 个人被说服去做别的职业的时间。", "outputFormat": "输出去说服市民的最小时间。", "hint": "对于所有的数据，保证 $1 \\leq k \\leq n \\leq 10^5$，$1 \\leq a_i \\leq k$，$1 \\leq b_i \\leq 10^9$。\n\n对于样例一，分别令 $1$，$6$，$8$ 号市民去从事 $2$，$4$，$6$ 号职业。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018] Lazyland", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) L 题。", "description": "一个城市里有 $n$ 个人，和 $k$ 种职业，其中，每个人都有一个现在正在从事的职业 $a_i$，但是很遗憾，由于某些职业的空缺，使得这个城市根本无法继续正常生存下去。\n\n你作为一城之主，自然不希望看到自己的城市这样子下去，你决定说服其中的某些人，使得每种职业都有人在做，对于每个人 $i$，你需要耗费 $b_i$ 的时间去说服。\n\n你需要求出你去说服的时间的最小值。", "inputFormat": "第一行两个整数 $n$ 和 $k (1 \\leq k \\leq n \\leq 10^5)$，分别表示 $n$ 个人和 $k$ 种职业。\n\n第二行 $n$ 个整数 $a_i (1 \\leq a_i \\leq k)$，表示第 $i$ 个人正在从事的职业 。\n\n第三行 $n$ 个整数 $b_i (1 \\leq b_i \\leq 10^9)$，表示第 $i$ 个人被说服去做别的职业的时间。", "outputFormat": "输出去说服市民的最小时间。", "hint": "对于所有的数据，保证 $1 \\leq k \\leq n \\leq 10^5$，$1 \\leq a_i \\leq k$，$1 \\leq b_i \\leq 10^9$。\n\n对于样例一，分别令 $1$，$6$，$8$ 号市民去从事 $2$，$4$，$6$ 号职业。", "locale": "zh-CN"}}}
{"pid": "P9803", "type": "P", "difficulty": 5, "samples": [["4\n0 1 0 1\n0 0 1 0\n0 1 0 0\n1 0 0 0", "4 2 3\n..#.\n.4..\n####\n1#.#\n..3.\n#2..\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "Special Judge", "强连通分量", "构造", "ICPC", "NERC/NEERC"], "title": "[NERC 2018] Minegraphed", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) M 题。", "description": "Marika 正在制作一款名为 Minegraphed 的游戏，游戏内容是你在一个三维的长方体上移动。长方体游戏场地的每个单元格都是空单元格或障碍单元格。你总是在一个空单元格里面，要么在最底层，要么在一个障碍的顶部。对于每次移动，你可以选择东南西北中的一项进行移动，移动的规则如下：\n\n- 你不能移动至矩形立方体外面。\n- 如果你面前的单元格是空的，那么你可以向前移动一格，然后向底部落下，直到你到达最底层或者一个障碍。\n- 如果你在非最顶层，你前面的单元格是一个障碍物，你上面的单元格和这个障碍物上面的单元格都是空的，然后你可以爬到该障碍物的顶部。\n- 其余情况，你不能进行移动。\n\n长方体中有 $n$ 个可以站立的特殊空单元格，分别编号为 $1\\sim n$。\n\nMarika 还有一个 $n \\times n$ 的二维数组 $a$，表示一个包含 $n$ 个结点的有向图的邻接矩阵（$a_{i,j}=1$ 表示有一条边 $i\\to j$，反之亦然）。你需要满足 $i$ 在有向图上能通过若干条边到达 $j$，当且仅当在长方体的游戏场地中可以通过移动从编号为 $i$ 的单元格到达编号为 $j$ 的单元格。\n\n请构造一种合法方案。", "inputFormat": "第一行一个整数 $n \\ (1 \\leq n \\leq 9)$。\n\n然后 $n$ 行，每行 $n$ 个数分别为 $a_{i,1},a_{i,2},\\ldots,a_{i,n}$，表示有向图的邻接矩阵。", "outputFormat": "输出第一行 $x,y,z$ 表示你的矩形立方体的长宽高，你需要保证 $x \\times y \\times z \\leq 10^6$。\n\n然后 $z$ 层（自上向下），每层一个 $x \\times y$ 的矩形：$map_{i,j}$ 若为 `#` 表示障碍，若为 `.` 表示普通的空单元格，若为数字则表示一个特殊空单元格，数字表示其对应的编号。\n\n保证存在解法。", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/w4266sez.png)\n\n对于所有数据保证 $1 \\leq n \\leq 9$，$a_{i,j} \\in \\{0, 1\\}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NERC 2018] Minegraphed", "background": "翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) M 题。", "description": "Marika 正在制作一款名为 Minegraphed 的游戏，游戏内容是你在一个三维的长方体上移动。长方体游戏场地的每个单元格都是空单元格或障碍单元格。你总是在一个空单元格里面，要么在最底层，要么在一个障碍的顶部。对于每次移动，你可以选择东南西北中的一项进行移动，移动的规则如下：\n\n- 你不能移动至矩形立方体外面。\n- 如果你面前的单元格是空的，那么你可以向前移动一格，然后向底部落下，直到你到达最底层或者一个障碍。\n- 如果你在非最顶层，你前面的单元格是一个障碍物，你上面的单元格和这个障碍物上面的单元格都是空的，然后你可以爬到该障碍物的顶部。\n- 其余情况，你不能进行移动。\n\n长方体中有 $n$ 个可以站立的特殊空单元格，分别编号为 $1\\sim n$。\n\nMarika 还有一个 $n \\times n$ 的二维数组 $a$，表示一个包含 $n$ 个结点的有向图的邻接矩阵（$a_{i,j}=1$ 表示有一条边 $i\\to j$，反之亦然）。你需要满足 $i$ 在有向图上能通过若干条边到达 $j$，当且仅当在长方体的游戏场地中可以通过移动从编号为 $i$ 的单元格到达编号为 $j$ 的单元格。\n\n请构造一种合法方案。", "inputFormat": "第一行一个整数 $n \\ (1 \\leq n \\leq 9)$。\n\n然后 $n$ 行，每行 $n$ 个数分别为 $a_{i,1},a_{i,2},\\ldots,a_{i,n}$，表示有向图的邻接矩阵。", "outputFormat": "输出第一行 $x,y,z$ 表示你的矩形立方体的长宽高，你需要保证 $x \\times y \\times z \\leq 10^6$。\n\n然后 $z$ 层（自上向下），每层一个 $x \\times y$ 的矩形：$map_{i,j}$ 若为 `#` 表示障碍，若为 `.` 表示普通的空单元格，若为数字则表示一个特殊空单元格，数字表示其对应的编号。\n\n保证存在解法。", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/w4266sez.png)\n\n对于所有数据保证 $1 \\leq n \\leq 9$，$a_{i,j} \\in \\{0, 1\\}$。", "locale": "zh-CN"}}}
{"pid": "P9804", "type": "P", "difficulty": 4, "samples": [["6 5 14\n1 3 1\n5 1 5\n2 3 2\n3 4 1\n3 5 3\nZ 1 1\nZ 1 2\nP\nP\nD\nD\nP\nZ 3 5\nP\nZ 3 5\nD\nZ 3 5\nL\nZ 3 5", "0\n-1\n-1\n3\n1\n2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "POI（波兰）", "2022", "2023"], "title": "[POI 2022/2023 R1] kol", "background": "题目译自 [POI2022~2023R1 kol](https://sio2.mimuw.edu.pl/c/oi30-1/p/kol/)。\n\n注意：原题时限为 32s，为避免卡评测，此题时限改为 3s。\n", "description": "你在一个 $m \\times m$ 的棋盘上玩贪吃蛇游戏，已知原本蛇长度为 $1$，内容为 `0`，在 $(1,1)$ 处，棋盘上存在 $p$ 个“食物点”，当一条蛇吃了一个“食物点”时，它将会在其头部增加一个食物点对应数值的部分，下图可以更清楚的演示吃食物的过程（红色数字为蛇身）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8t9pu2br.png)\n\n现在你进行了 $n$ 个操作，存在移动操作（上下左右）和查询操作（询问一个点是否被蛇覆盖），请编写一个程序求出它。", "inputFormat": "第一行三个整数 $m$，$p$，$n \\ (1 \\leq m \\leq 2000$，$1 \\leq p \\leq \\min(m^2 - 1, 10^6)$，$1 \\leq n \\leq 10^6)$。\n\n接下来 $p$ 行，每行三个整数 $w_i$，$k_i$，$c_i \\ (1 \\leq w_i,k_i \\leq m$，$0 \\leq c_i \\leq m^2-1)$，表示坐标 $(w_i,k_i)$ 的点是一个存在食物为 $c_i$ 的食物点。\n\n然后 $n$ 行，每行先是一个字符。\n\n- 如果该字符为 `Z`，则紧接着后面两个左边 $w_j',k_j'$，表示询问 $(w_j',k_j')$ 的地方是否存在蛇身，不存在输出 $-1$，存在输出对应的内容（数值）。\n\n- 否则，按照对应顺序移动：上（`G`）、下（`D`）、左（`L`）或右（`P`）。", "outputFormat": "对应字符为 `Z` 的，输出对应的输出。", "hint": "子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $m \\leq 300$ 且 $p,n \\leq 2000$ | $20$ |\n| $2$ | $m \\leq 800$ 且 $p,n \\leq 50000$ | $20$ |\n| $3$ | $c_i=0$ | $20$ |\n| $4$ | 无附加限制 | $40$ |\n\n本题中，子任务 $0$ 为样例。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2022/2023 R1] kol", "background": "题目译自 [POI2022~2023R1 kol](https://sio2.mimuw.edu.pl/c/oi30-1/p/kol/)。\n\n注意：原题时限为 32s，为避免卡评测，此题时限改为 3s。\n", "description": "你在一个 $m \\times m$ 的棋盘上玩贪吃蛇游戏，已知原本蛇长度为 $1$，内容为 `0`，在 $(1,1)$ 处，棋盘上存在 $p$ 个“食物点”，当一条蛇吃了一个“食物点”时，它将会在其头部增加一个食物点对应数值的部分，下图可以更清楚的演示吃食物的过程（红色数字为蛇身）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8t9pu2br.png)\n\n现在你进行了 $n$ 个操作，存在移动操作（上下左右）和查询操作（询问一个点是否被蛇覆盖），请编写一个程序求出它。", "inputFormat": "第一行三个整数 $m$，$p$，$n \\ (1 \\leq m \\leq 2000$，$1 \\leq p \\leq \\min(m^2 - 1, 10^6)$，$1 \\leq n \\leq 10^6)$。\n\n接下来 $p$ 行，每行三个整数 $w_i$，$k_i$，$c_i \\ (1 \\leq w_i,k_i \\leq m$，$0 \\leq c_i \\leq m^2-1)$，表示坐标 $(w_i,k_i)$ 的点是一个存在食物为 $c_i$ 的食物点。\n\n然后 $n$ 行，每行先是一个字符。\n\n- 如果该字符为 `Z`，则紧接着后面两个左边 $w_j',k_j'$，表示询问 $(w_j',k_j')$ 的地方是否存在蛇身，不存在输出 $-1$，存在输出对应的内容（数值）。\n\n- 否则，按照对应顺序移动：上（`G`）、下（`D`）、左（`L`）或右（`P`）。", "outputFormat": "对应字符为 `Z` 的，输出对应的输出。", "hint": "子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $m \\leq 300$ 且 $p,n \\leq 2000$ | $20$ |\n| $2$ | $m \\leq 800$ 且 $p,n \\leq 50000$ | $20$ |\n| $3$ | $c_i=0$ | $20$ |\n| $4$ | 无附加限制 | $40$ |\n\n本题中，子任务 $0$ 为样例。", "locale": "zh-CN"}}}
{"pid": "P9805", "type": "P", "difficulty": 3, "samples": [["8 2\n(()(()))", "2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["POI（波兰）", "2022", "2023"], "title": "[POI 2022/2023 R1] ply", "background": "题目译自 [POI2022~2023R1 ply](https://sio2.mimuw.edu.pl/c/oi30-1/p/ply/)。", "description": "定义“合法括号串”及其深度如下：\n\n- 空串是一个合法括号串，深度为 $0$。\n- 如果 $w$ 是一个合法括号串，深度为 $h$，则 $(w)$ 也是一个合法括号串，深度为 $h+1$。\n- 如果 $w_1$ 和 $w_2$ 都是合法括号串，深度分别为 $h_1$ 和 $h_2$，则 $w_1w_2$ 也是一个合法括号串，深度为 $\\max(h_1,h_2)$。\n\n定义翻转一个字符为：\n\n- 如果当前字符为 `(`，修改为 `)`。\n- 如果当前字符为 `)`，修改为 `(`。\n\n你需要通过翻转 $s$ 当中某些字符使得深度不超过 $H$，求最小操作次数。", "inputFormat": "第一行两个数字 $n \\ (2 \\leq n \\leq 10^6)$ 和 $H \\ (1 \\leq H \\leq \\frac{n}{2})$，分别表示 $|s|$ 和要求修改后不超过的深度。\n\n第二行一个字符串 $s$，表示原来的括号串。", "outputFormat": "输出最小修改次数。", "hint": "对于样例，可以修改为 `(()()())`，这样深度为 $2$。\n\n子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: |\n| $1$ | $n \\leq 20$ | $20$ |\n| $2$ | $n \\leq 3000$ | $40$ |\n| $3$ | $n \\leq 10^6$ 且 $H = h-1$ | $20$ |\n| $4$ | $n \\leq 10^6$ | $20$ |\n\n注：$h$ 为输入的括号串的深度。\n\n本题中，子任务 $0$ 为样例。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2022/2023 R1] ply", "background": "题目译自 [POI2022~2023R1 ply](https://sio2.mimuw.edu.pl/c/oi30-1/p/ply/)。", "description": "定义“合法括号串”及其深度如下：\n\n- 空串是一个合法括号串，深度为 $0$。\n- 如果 $w$ 是一个合法括号串，深度为 $h$，则 $(w)$ 也是一个合法括号串，深度为 $h+1$。\n- 如果 $w_1$ 和 $w_2$ 都是合法括号串，深度分别为 $h_1$ 和 $h_2$，则 $w_1w_2$ 也是一个合法括号串，深度为 $\\max(h_1,h_2)$。\n\n定义翻转一个字符为：\n\n- 如果当前字符为 `(`，修改为 `)`。\n- 如果当前字符为 `)`，修改为 `(`。\n\n你需要通过翻转 $s$ 当中某些字符使得深度不超过 $H$，求最小操作次数。", "inputFormat": "第一行两个数字 $n \\ (2 \\leq n \\leq 10^6)$ 和 $H \\ (1 \\leq H \\leq \\frac{n}{2})$，分别表示 $|s|$ 和要求修改后不超过的深度。\n\n第二行一个字符串 $s$，表示原来的括号串。", "outputFormat": "输出最小修改次数。", "hint": "对于样例，可以修改为 `(()()())`，这样深度为 $2$。\n\n子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: |\n| $1$ | $n \\leq 20$ | $20$ |\n| $2$ | $n \\leq 3000$ | $40$ |\n| $3$ | $n \\leq 10^6$ 且 $H = h-1$ | $20$ |\n| $4$ | $n \\leq 10^6$ | $20$ |\n\n注：$h$ 为输入的括号串的深度。\n\n本题中，子任务 $0$ 为样例。", "locale": "zh-CN"}}}
{"pid": "P9806", "type": "P", "difficulty": 3, "samples": [["9 4 3\n1 3 2 1 2 3 1 3 2\n1 3 1 2\n", "1 1 0 1 1 1 1 0 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 6000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["POI（波兰）", "2022", "2023"], "title": "[POI 2022/2023 R1] poc", "background": "题目译自 [POI2022~2023R1 poc](https://sio2.mimuw.edu.pl/c/oi30-1/p/poc/)。\n", "description": "小 A 和小 B 在记录过往的车辆的类型！\n\n已知类型分别有 $1 \\sim k$ 个，每种车辆必然属于其中之一。\n\n小 A 按顺序细心地记录了所有的车辆的类型，但是贪玩的小 B 只按顺序记录了一部分车辆。\n\n小 A 记录的内容长度为 $n$，小 B 记录的长度为 $m$。\n\n称在小 A 记录中的第 $i$ 辆车“可能被 B 记录到”当且仅当在小 A 的记录中存在一个包含 $i$ 的子序列与小 B 所记录的完全相同。\n\n保证小 B 记录的序列一定是小 A 记录的子序列，问哪些车辆是可能会被小 B 记录到，哪些没有。", "inputFormat": "第一行三个整数 $n,m,k \\ (1 \\leq n,m,k \\leq 3 \\times 10^5)$。\n\n第二行一个长度为 $n$ 的序列，表示小 A 记录的序列。\n\n第三行一个长度为 $m$ 的序列，表示小 B 记录的序列。\n\n上述序列中的元素均满足 $1\\leq$ 序列元素 $\\leq k$。", "outputFormat": "对于每个小 A 记录到的车辆，请确定它能否被记录到，能输出 $1$，不能输出 $0$。", "hint": "对于样例，存在如下的子序列：\n\n$(1,2,4,5)$，$(1,2,4,9)$，$(1,2,7,9)$，$(1,6,7,9)$，$(4,6,7,9)$。\n\n注意到 $3$ 和 $8$ 一直都没被取到，故不能被小 B 记录到。\n\n子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: |\n| $1$ | $n,m \\leq 100$ | $15$ |\n| $2$ | $n,m \\leq 2000$ | $20$ |\n| $3$ | 每种类型的车辆最多被小 A 记录一次 | $15$ |\n| $4$ | 无附加限制 | $50$ |\n\n时间限制：Subtask1 1s，Subtask2 10s，Subtask3 和 Subtask4 6s。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2022/2023 R1] poc", "background": "题目译自 [POI2022~2023R1 poc](https://sio2.mimuw.edu.pl/c/oi30-1/p/poc/)。\n", "description": "小 A 和小 B 在记录过往的车辆的类型！\n\n已知类型分别有 $1 \\sim k$ 个，每种车辆必然属于其中之一。\n\n小 A 按顺序细心地记录了所有的车辆的类型，但是贪玩的小 B 只按顺序记录了一部分车辆。\n\n小 A 记录的内容长度为 $n$，小 B 记录的长度为 $m$。\n\n称在小 A 记录中的第 $i$ 辆车“可能被 B 记录到”当且仅当在小 A 的记录中存在一个包含 $i$ 的子序列与小 B 所记录的完全相同。\n\n保证小 B 记录的序列一定是小 A 记录的子序列，问哪些车辆是可能会被小 B 记录到，哪些没有。", "inputFormat": "第一行三个整数 $n,m,k \\ (1 \\leq n,m,k \\leq 3 \\times 10^5)$。\n\n第二行一个长度为 $n$ 的序列，表示小 A 记录的序列。\n\n第三行一个长度为 $m$ 的序列，表示小 B 记录的序列。\n\n上述序列中的元素均满足 $1\\leq$ 序列元素 $\\leq k$。", "outputFormat": "对于每个小 A 记录到的车辆，请确定它能否被记录到，能输出 $1$，不能输出 $0$。", "hint": "对于样例，存在如下的子序列：\n\n$(1,2,4,5)$，$(1,2,4,9)$，$(1,2,7,9)$，$(1,6,7,9)$，$(4,6,7,9)$。\n\n注意到 $3$ 和 $8$ 一直都没被取到，故不能被小 B 记录到。\n\n子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: |\n| $1$ | $n,m \\leq 100$ | $15$ |\n| $2$ | $n,m \\leq 2000$ | $20$ |\n| $3$ | 每种类型的车辆最多被小 A 记录一次 | $15$ |\n| $4$ | 无附加限制 | $50$ |\n\n时间限制：Subtask1 1s，Subtask2 10s，Subtask3 和 Subtask4 6s。", "locale": "zh-CN"}}}
{"pid": "P9807", "type": "P", "difficulty": 6, "samples": [["3 1 1 1\n3 2 1 4\n6 3 1 2\n10 2 1 4", "2"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["POI（波兰）", "2022", "2023"], "title": "[POI 2022/2023 R1] wyp", "background": "题目译自 [POI2022~2023R1 wyp](https://sio2.mimuw.edu.pl/c/oi30-1/p/wyp/)。", "description": "你在高速上开着你新买的车，高速上共有 $2$ 个车道（分为左右，初始时所有车辆都在右侧），$n$ 辆在前面的车，但是由于这些车开的实在是太慢了，你想要进行超车。\n\n已知你的速度为 $V$，其他车速度为 $v_i$（保证 $V > v_i$），如果你的车的车头已经要撞上其他车了，那么你将会向左开进行超车，如果你当前右侧位置存在一个空隙使得你的车进入的了，那么你一定进行右侧。\n\n注意此处存在其他车相撞的情况，后面的车的速度会改成与它前面一样的速度。\n\n问你的车会进行几次左转操作。", "inputFormat": "第一行四个整数 $n$，$D$，$W$，$M$（$1 \\leq n \\leq 10^5$，$ 1 \\leq D \\leq 10^9$，$1 \\leq W,M \\leq 1000$），分别表示卡车的数量，自己车的长度，自己车的速度为 $W/M$，默认自己车的车头坐标为 $0$。\n\n接下来 $n$ 行，每行 $4$ 个整数 $x_i$，$d_i$，$w_i$，$m_i$（$1 \\leq x_i,d_i \\leq 10^9$，$1 \\leq w_i,m_i \\leq 1000$），分别表示其他车的坐标、长度，速度为 $w_i / m_i$。\n\n保证按 $x_i$ 升序排序给出。", "outputFormat": "输出要实行超车 $n$ 辆车要左转的次数。", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ymk60iqd.png)\n\n子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $v_i = v_{i+1}$ | $10$ |\n| $2$ | $v_i \\leq v_{i+1}$ | $20$ |\n| $3$ | $n \\leq 1000$ | $35$ |\n| $4$ | 无附加限制 | $35$ |\n\n本题中，子任务 $0$ 为样例。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2022/2023 R1] wyp", "background": "题目译自 [POI2022~2023R1 wyp](https://sio2.mimuw.edu.pl/c/oi30-1/p/wyp/)。", "description": "你在高速上开着你新买的车，高速上共有 $2$ 个车道（分为左右，初始时所有车辆都在右侧），$n$ 辆在前面的车，但是由于这些车开的实在是太慢了，你想要进行超车。\n\n已知你的速度为 $V$，其他车速度为 $v_i$（保证 $V > v_i$），如果你的车的车头已经要撞上其他车了，那么你将会向左开进行超车，如果你当前右侧位置存在一个空隙使得你的车进入的了，那么你一定进行右侧。\n\n注意此处存在其他车相撞的情况，后面的车的速度会改成与它前面一样的速度。\n\n问你的车会进行几次左转操作。", "inputFormat": "第一行四个整数 $n$，$D$，$W$，$M$（$1 \\leq n \\leq 10^5$，$ 1 \\leq D \\leq 10^9$，$1 \\leq W,M \\leq 1000$），分别表示卡车的数量，自己车的长度，自己车的速度为 $W/M$，默认自己车的车头坐标为 $0$。\n\n接下来 $n$ 行，每行 $4$ 个整数 $x_i$，$d_i$，$w_i$，$m_i$（$1 \\leq x_i,d_i \\leq 10^9$，$1 \\leq w_i,m_i \\leq 1000$），分别表示其他车的坐标、长度，速度为 $w_i / m_i$。\n\n保证按 $x_i$ 升序排序给出。", "outputFormat": "输出要实行超车 $n$ 辆车要左转的次数。", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ymk60iqd.png)\n\n子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $v_i = v_{i+1}$ | $10$ |\n| $2$ | $v_i \\leq v_{i+1}$ | $20$ |\n| $3$ | $n \\leq 1000$ | $35$ |\n| $4$ | 无附加限制 | $35$ |\n\n本题中，子任务 $0$ 为样例。", "locale": "zh-CN"}}}
{"pid": "P9808", "type": "P", "difficulty": 6, "samples": [["5 3\n1 4 3\n3 1 6\n1 2 5\n4 5 1\n5\n3\n2", "8\n40\n90\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["POI（波兰）", "2022", "2023"], "title": "[POI 2022/2023 R1] zbo", "background": "题目译自 [POI2022~2023R1 zbo](https://sio2.mimuw.edu.pl/c/oi30-1/p/zbo/)。", "description": "远古时期有一个国王，他统治了 $n$ 个村庄，这些村庄以 $n-1$ 条道路连接，原来的国王城堡在 $1$ 号村庄。\n\n国王的儿子不久就要成年了，作为成年的王子们，其需要自己的城堡，所以在一些村庄会有**新的城堡**。\n\n每座城堡都需要进行通讯，但是无奈距离太过遥远，为此，每个城堡每天都会派出若干个信鸽，向其他每个城堡发送消息。一只信鸽每行驶一公里就要吃一克谷物。\n\n请你实现一个程序，求出按照输入顺序建造的每个城堡建造完之后所有城堡都能通讯的最少花费谷物数量。\n\n具体的，定义 $dis(x,y)$ 为 $x$ 到 $y$ 所花费的谷物数，求每个城堡 $i$ 建造完后的 $\\sum ^{i} _{x=1} \\sum ^{i}_{y=1} dis(x,y)$。\n\n注意上述式子默认两个相同的地点所花费为 $0$。", "inputFormat": "输入第一行两个数字 $n$ 和 $k \\ (1 \\leq k < n \\leq 10^5)$，分别表示村庄数量和即将建造的城堡数量。\n\n接下来 $n-1$ 行，每行三个整数 $a,b,c \\ (1 \\leq a,b \\leq n, a \\neq b, 1 \\leq c \\leq 1000)$，表示 $a$ 到 $b$ 存在一条长度为 $c$ 的无向边。\n\n再接下来 $k$ 行，每行一个整数 $d_{i}$，表示第 $i$ 个城堡建设在 $d_{i}$ 位置上，注意城堡不会重复建在一个位置。", "outputFormat": "对于每个建造完的城堡，输出最小花费。", "hint": "子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $n \\cdot k \\leq 10^5$ | $15$ |\n| $2$ | 村庄是一条从 $1$ 到 $n$ 的链 | $35$ |\n| $3$ | 无特殊性质 | $50$ |\n\n本题中，子任务 $0$ 为样例。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2022/2023 R1] zbo", "background": "题目译自 [POI2022~2023R1 zbo](https://sio2.mimuw.edu.pl/c/oi30-1/p/zbo/)。", "description": "远古时期有一个国王，他统治了 $n$ 个村庄，这些村庄以 $n-1$ 条道路连接，原来的国王城堡在 $1$ 号村庄。\n\n国王的儿子不久就要成年了，作为成年的王子们，其需要自己的城堡，所以在一些村庄会有**新的城堡**。\n\n每座城堡都需要进行通讯，但是无奈距离太过遥远，为此，每个城堡每天都会派出若干个信鸽，向其他每个城堡发送消息。一只信鸽每行驶一公里就要吃一克谷物。\n\n请你实现一个程序，求出按照输入顺序建造的每个城堡建造完之后所有城堡都能通讯的最少花费谷物数量。\n\n具体的，定义 $dis(x,y)$ 为 $x$ 到 $y$ 所花费的谷物数，求每个城堡 $i$ 建造完后的 $\\sum ^{i} _{x=1} \\sum ^{i}_{y=1} dis(x,y)$。\n\n注意上述式子默认两个相同的地点所花费为 $0$。", "inputFormat": "输入第一行两个数字 $n$ 和 $k \\ (1 \\leq k < n \\leq 10^5)$，分别表示村庄数量和即将建造的城堡数量。\n\n接下来 $n-1$ 行，每行三个整数 $a,b,c \\ (1 \\leq a,b \\leq n, a \\neq b, 1 \\leq c \\leq 1000)$，表示 $a$ 到 $b$ 存在一条长度为 $c$ 的无向边。\n\n再接下来 $k$ 行，每行一个整数 $d_{i}$，表示第 $i$ 个城堡建设在 $d_{i}$ 位置上，注意城堡不会重复建在一个位置。", "outputFormat": "对于每个建造完的城堡，输出最小花费。", "hint": "子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $n \\cdot k \\leq 10^5$ | $15$ |\n| $2$ | 村庄是一条从 $1$ 到 $n$ 的链 | $35$ |\n| $3$ | 无特殊性质 | $50$ |\n\n本题中，子任务 $0$ 为样例。", "locale": "zh-CN"}}}
{"pid": "P9809", "type": "P", "difficulty": 5, "samples": [["5\nA 3\nA 5\nB 6\nA 9\nB 4", "3\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2006", "各省省选", "上海", "根号分治"], "title": "[SHOI2006] 作业 Homework", "background": "", "description": "给定一个集合为 $S$，初始为空，你需要执行以下两个操作共 $N$ 次。\n\n操作一，在集合 $S$ 中加入一个新元素，其代号为 $X$，保证 $X$ 在当前集合中不存在。\n\n操作二，在当前的集合 $S$ 中询问所有元素 $\\bmod\\ Y$ 最小的值。", "inputFormat": "第一行一个正整数 $N$。\n\n接下来 $N$ 行，每行一个字符和一个正整数，如字符为 `A`，表示这个操作是操作一。若字符为 `B`，则这个操作为操作二。", "outputFormat": "对于每个操作二，输出一行一个整数表示答案。", "hint": "对于 $100\\%$ 的数据，$N\\leq10^5$，$X,Y\\leq3\\times10^5$。数据保证，第一个操作为操作一。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[SHOI2006] 作业 Homework", "background": "", "description": "给定一个集合为 $S$，初始为空，你需要执行以下两个操作共 $N$ 次。\n\n操作一，在集合 $S$ 中加入一个新元素，其代号为 $X$，保证 $X$ 在当前集合中不存在。\n\n操作二，在当前的集合 $S$ 中询问所有元素 $\\bmod\\ Y$ 最小的值。", "inputFormat": "第一行一个正整数 $N$。\n\n接下来 $N$ 行，每行一个字符和一个正整数，如字符为 `A`，表示这个操作是操作一。若字符为 `B`，则这个操作为操作二。", "outputFormat": "对于每个操作二，输出一行一个整数表示答案。", "hint": "对于 $100\\%$ 的数据，$N\\leq10^5$，$X,Y\\leq3\\times10^5$。数据保证，第一个操作为操作一。", "locale": "zh-CN"}}}
{"pid": "P9810", "type": "P", "difficulty": 2, "samples": [["4\n3\n0\n4\n0", "0"], ["10\n1\n3\n5\n4\n0\n0\n7\n0\n0\n6", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "CCC（加拿大）"], "title": "[CCC 2015 S1] Zero That Out", "background": null, "description": "给定 $k$ 个整数 $a_1,a_2 \\dots ,a_k$，维护一个序列，按顺序进行以下操作：\n\n- 当 $a_{i} = 0$ 时，将序列中最后加入的数删除。\n- 否则，将 $a_{i}$ 加入序列。\n\n例如：当 $a = \\{1,3,5,4,0,0,7,0,0,6\\}$ 时，操作如下。\n\n|$a_{i}$|序列|\n|:--:|:--:|\n|$1$|$\\{1\\}$|\n|$3$|$\\{1,3\\}$|\n|$5$|$\\{1,3,5\\}$|\n|$4$|$\\{1,3,5,4\\}$|\n|$0$|$\\{1,3,5\\}$|\n|$0$|$\\{1,3\\}$|\n|$7$|$\\{1,3,7\\}$|\n|$0$|$\\{1,3\\}$|\n|$0$|$\\{1\\}$|\n|$6$|$\\{1,6\\}$|\n\n你需要计算最终序列中所有数的和。", "inputFormat": "第一行一个整数 $k$。\n\n接下来 $k$ 行，每行一个整数 $a_i$。", "outputFormat": "输出一行一个整数，表示最终序列中所有数的和。", "hint": "**【数据范围】：**\n\n$1 \\le k \\le 10^5$，$0 \\le a_i \\le 100$。\n\n保证在 $a_i = 0$ 时序列不为空。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CCC 2015 S1] Zero That Out", "background": null, "description": "给定 $k$ 个整数 $a_1,a_2 \\dots ,a_k$，维护一个序列，按顺序进行以下操作：\n\n- 当 $a_{i} = 0$ 时，将序列中最后加入的数删除。\n- 否则，将 $a_{i}$ 加入序列。\n\n例如：当 $a = \\{1,3,5,4,0,0,7,0,0,6\\}$ 时，操作如下。\n\n|$a_{i}$|序列|\n|:--:|:--:|\n|$1$|$\\{1\\}$|\n|$3$|$\\{1,3\\}$|\n|$5$|$\\{1,3,5\\}$|\n|$4$|$\\{1,3,5,4\\}$|\n|$0$|$\\{1,3,5\\}$|\n|$0$|$\\{1,3\\}$|\n|$7$|$\\{1,3,7\\}$|\n|$0$|$\\{1,3\\}$|\n|$0$|$\\{1\\}$|\n|$6$|$\\{1,6\\}$|\n\n你需要计算最终序列中所有数的和。", "inputFormat": "第一行一个整数 $k$。\n\n接下来 $k$ 行，每行一个整数 $a_i$。", "outputFormat": "输出一行一个整数，表示最终序列中所有数的和。", "hint": "**【数据范围】：**\n\n$1 \\le k \\le 10^5$，$0 \\le a_i \\le 100$。\n\n保证在 $a_i = 0$ 时序列不为空。", "locale": "zh-CN"}}}
{"pid": "P9811", "type": "P", "difficulty": 2, "samples": [["4\n3\nM\nS\nS\nL\nL 3\nS 3\nL 1", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2015", "CCC（加拿大）"], "title": "[CCC 2015 S2] Jerseys", "background": "", "description": "有编号为 $1 \\sim n$ 的队服要分给 $m$ 个队员，队服从小到大分别有 S、M、L 三种大小，每个队员对于队服有一定的要求，具体的：第 $i$ 个队员希望得到的队服尺码**不小于** $a_{i}$，编号为 $b_{i}$。\n\n求最多能满足多少人的要求。\n", "inputFormat": "第一行一个整数 $n$，第二行一个整数 $m$。\n\n接下来 $n$ 行，每行一个字符 $c_{i}$，表示编号为 $i$ 的队服大小，满足 $c_{i} \\in \\{\\text{S,M,L}\\}$。\n\n接下来 $m$ 行，每行一个字符 $a_{j}$ 和一个整数 $b_{j}$，满足 $a_{j} \\in \\{\\text{S,M,L}\\}$，含义见题目描述。", "outputFormat": "输出一行一个整数，表示最多能满足要求的人数。", "hint": "**【数据范围】：**\n\n对于 $50\\%$ 的数据，$1 \\leq n,m \\leq 10^{3}$；\n\n对于 $100\\%$ 的数据，$1 \\leq n,m \\leq 10^{6}$。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CCC 2015 S2] Jerseys", "background": "", "description": "有编号为 $1 \\sim n$ 的队服要分给 $m$ 个队员，队服从小到大分别有 S、M、L 三种大小，每个队员对于队服有一定的要求，具体的：第 $i$ 个队员希望得到的队服尺码**不小于** $a_{i}$，编号为 $b_{i}$。\n\n求最多能满足多少人的要求。\n", "inputFormat": "第一行一个整数 $n$，第二行一个整数 $m$。\n\n接下来 $n$ 行，每行一个字符 $c_{i}$，表示编号为 $i$ 的队服大小，满足 $c_{i} \\in \\{\\text{S,M,L}\\}$。\n\n接下来 $m$ 行，每行一个字符 $a_{j}$ 和一个整数 $b_{j}$，满足 $a_{j} \\in \\{\\text{S,M,L}\\}$，含义见题目描述。", "outputFormat": "输出一行一个整数，表示最多能满足要求的人数。", "hint": "**【数据范围】：**\n\n对于 $50\\%$ 的数据，$1 \\leq n,m \\leq 10^{3}$；\n\n对于 $100\\%$ 的数据，$1 \\leq n,m \\leq 10^{6}$。\n\n", "locale": "zh-CN"}}}
{"pid": "P9812", "type": "P", "difficulty": 3, "samples": [["4\n3\n4\n1\n1", "2"], ["4\n6\n2\n2\n3\n3\n4\n4", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2015", "CCC（加拿大）"], "title": "[CCC 2015 S3] Gates", "background": "", "description": "机场有 $n$ 个登机口，你需要按顺序安排 $m$ 架飞机，第 $i$ 架飞机只能使用 $1 \\sim g_{i}$ 号登机口，一个登机口永久只能被一架飞机使用。**当没有登机口可以供某架飞机使用时机场便会关闭，之后的飞机都不能登机。**\n\n请确定一种方案，使得有登机口的飞机数量最多。", "inputFormat": "第一行一个整数 $n$。\n\n第二行一个整数 $m$。\n\n接下来 $m$ 行，每行一个整数 $g_{i}$。", "outputFormat": "一行一个整数，表示最多能安排的飞机数量。", "hint": "**【数据范围】：**\n\n对于 $40\\%$ 的数据，$1 \\leq n,m \\leq 2 \\times 10^{3}$。\n\n对于 $100\\%$ 的数据，$1 \\leq n,m \\leq 10^{5}$，$1 \\leq g_{i} \\leq n$。\n\n本题中 Subtask 0 为原题数据，Subtask 1 为 Hack 数据，Hack 数据不计分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CCC 2015 S3] Gates", "background": "", "description": "机场有 $n$ 个登机口，你需要按顺序安排 $m$ 架飞机，第 $i$ 架飞机只能使用 $1 \\sim g_{i}$ 号登机口，一个登机口永久只能被一架飞机使用。**当没有登机口可以供某架飞机使用时机场便会关闭，之后的飞机都不能登机。**\n\n请确定一种方案，使得有登机口的飞机数量最多。", "inputFormat": "第一行一个整数 $n$。\n\n第二行一个整数 $m$。\n\n接下来 $m$ 行，每行一个整数 $g_{i}$。", "outputFormat": "一行一个整数，表示最多能安排的飞机数量。", "hint": "**【数据范围】：**\n\n对于 $40\\%$ 的数据，$1 \\leq n,m \\leq 2 \\times 10^{3}$。\n\n对于 $100\\%$ 的数据，$1 \\leq n,m \\leq 10^{5}$，$1 \\leq g_{i} \\leq n$。\n\n本题中 Subtask 0 为原题数据，Subtask 1 为 Hack 数据，Hack 数据不计分。", "locale": "zh-CN"}}}
{"pid": "P9813", "type": "P", "difficulty": 4, "samples": [["10 4 7\n1 2 4 4\n1 3 7 2\n3 1 8 1\n3 2 2 2\n4 2 1 6\n3 4 1 1\n1 4 6 12\n1 4", "7"], ["3 3 3\n1 2 5 1\n3 2 8 2\n1 3 1 3\n1 3", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2015", "CCC（加拿大）"], "title": "[CCC 2015 S4] Convex Hull", "background": "", "description": "给定一个 $n$ 个点，$m$ 条边的无向图，每条边有两个边权 $t_{i}$ 和 $h_{i}$。\n\n你需要找到一条从 $s$ 到 $t$ 的路径，满足路径上边的 $h_{i}$ 之和 $<k$ 且 $t_{i}$ 之和最小，只需要输出这个最小值即可，如果无法找到满足条件的路径，输出 $-1$。", "inputFormat": "第一行三个整数 $k,n,m$。\n\n接下来 $m$ 行，每行四个整数 $u_{i},v_{i},t_{i},h_{i}$ 表示一条从 $u_{i}$ 到 $v_{i}$ 的路径，边权为 $\\{t_{i},h_{i}\\}$。\n\n最后一行两个整数 $s,t$。", "outputFormat": "当存在满足条件的路径时，输出一行一个整数表示满足条件的最小 $t_{i}$ 之和。\n\n否则输出一行 $-1$。", "hint": "**【数据范围】：**\n\n对于 $20\\%$ 的数据，$k = 1$，$2 \\leq n \\leq 200$。\n\n对于另外 $20\\%$ 的数据，$k = 1$，$2 \\leq n \\leq 2 \\times 10^{3}$。\n\n对于 $100\\%$ 的数据，$0 \\leq h_{i} \\leq 200$，$1 \\leq t_{i} \\leq 10^{5}$，$1 \\leq k \\leq 200$，$2 \\leq n \\leq 2 \\times 10^{3}$，$1 \\leq m \\leq 10^{4}$，$s \\neq t$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CCC 2015 S4] Convex Hull", "background": "", "description": "给定一个 $n$ 个点，$m$ 条边的无向图，每条边有两个边权 $t_{i}$ 和 $h_{i}$。\n\n你需要找到一条从 $s$ 到 $t$ 的路径，满足路径上边的 $h_{i}$ 之和 $<k$ 且 $t_{i}$ 之和最小，只需要输出这个最小值即可，如果无法找到满足条件的路径，输出 $-1$。", "inputFormat": "第一行三个整数 $k,n,m$。\n\n接下来 $m$ 行，每行四个整数 $u_{i},v_{i},t_{i},h_{i}$ 表示一条从 $u_{i}$ 到 $v_{i}$ 的路径，边权为 $\\{t_{i},h_{i}\\}$。\n\n最后一行两个整数 $s,t$。", "outputFormat": "当存在满足条件的路径时，输出一行一个整数表示满足条件的最小 $t_{i}$ 之和。\n\n否则输出一行 $-1$。", "hint": "**【数据范围】：**\n\n对于 $20\\%$ 的数据，$k = 1$，$2 \\leq n \\leq 200$。\n\n对于另外 $20\\%$ 的数据，$k = 1$，$2 \\leq n \\leq 2 \\times 10^{3}$。\n\n对于 $100\\%$ 的数据，$0 \\leq h_{i} \\leq 200$，$1 \\leq t_{i} \\leq 10^{5}$，$1 \\leq k \\leq 200$，$2 \\leq n \\leq 2 \\times 10^{3}$，$1 \\leq m \\leq 10^{4}$，$s \\neq t$。", "locale": "zh-CN"}}}
{"pid": "P9814", "type": "P", "difficulty": 5, "samples": [["5\n10\n12\n6\n14\n7\n3\n1\n8\n2", "44"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "CCC（加拿大）"], "title": "[CCC 2015 S5] Greedy For Pies", "background": "", "description": "给定一个长度为 $n$ 的序列 $a$ 和一个长度为 $m$ 的序列 $b$，你可以将 $b$ 序列中的元素任意插入到 $a$ 序列的任何位置（包括开头和末尾）。之后，你可以从新的序列中选一些元素，但你不能选择两个相邻的元素。\n\n你需要使得你选出的数之和最大，输出这个最大值即可。", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行，每行一个整数 $a_{i}$。\n\n接下来一行一个整数 $m$。\n\n接下来 $m$ 行，每行一个整数 $b_{i}$。", "outputFormat": "输出一行一个整数，表示你能选出元素和的最大值。", "hint": "**【数据范围】：**\n\n对于 $20\\%$ 的数据，$m = 0$。\n\n对于另外 $20\\%$ 的数据，$m = 1$。\n\n对于另外 $20\\%$ 的数据，$m \\leq 10$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 3 \\times 10^{3}$，$0 \\leq m \\leq 100$，$1 \\leq a_{i},b_{i} \\leq 10^{5}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CCC 2015 S5] Greedy For Pies", "background": "", "description": "给定一个长度为 $n$ 的序列 $a$ 和一个长度为 $m$ 的序列 $b$，你可以将 $b$ 序列中的元素任意插入到 $a$ 序列的任何位置（包括开头和末尾）。之后，你可以从新的序列中选一些元素，但你不能选择两个相邻的元素。\n\n你需要使得你选出的数之和最大，输出这个最大值即可。", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行，每行一个整数 $a_{i}$。\n\n接下来一行一个整数 $m$。\n\n接下来 $m$ 行，每行一个整数 $b_{i}$。", "outputFormat": "输出一行一个整数，表示你能选出元素和的最大值。", "hint": "**【数据范围】：**\n\n对于 $20\\%$ 的数据，$m = 0$。\n\n对于另外 $20\\%$ 的数据，$m = 1$。\n\n对于另外 $20\\%$ 的数据，$m \\leq 10$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 3 \\times 10^{3}$，$0 \\leq m \\leq 100$，$1 \\leq a_{i},b_{i} \\leq 10^{5}$。", "locale": "zh-CN"}}}
{"pid": "P9815", "type": "P", "difficulty": 3, "samples": [["3\n1\n1 1\n3\n0 1\n1 1\n1 0\n3\n0 1\n2 3\n4 5", "0\n4\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "O2优化"], "title": "wbyblD", "background": "> D题，我不要被hack！！！", "description": "有 $n+2$ 个点排成一排，编号为 $0\\sim n+1$。对于第 $i$ 号点有两个整数 $a_i,b_i$，其中 $0\\le i\\le n+1$。规定初始时 $a_0=b_0=a_{n+1}=b_{n+1}=0$。\n\n设你当前在第 $x$ 号点，当前的移动方向为 $y$，初始时 $x=0,y=1$。\n\n你将按如下方式移动直到 $x,y$ 某一次变化后满足 $x=0,y=-1$ 或 $x=n+1,y=1$。\n\n- 若 $y=1$，首先将 $x$ 增加 $1$，此时若 $a_x>0$ 则将 $y$ 变成 $-1$，否则 $y$ 不变，最后再将 $a_x$ 减少 $1$。\n- 若 $y=-1$，首先将 $x$ 减少 $1$，此时若 $b_x>0$ 则将 $y$ 变成 $1$，否则 $y$ 不变，最后再将 $b_x$ 减少 $1$。\n\n问最后结束时 $x$ 会在第几号点，事实上，最后 $x$ 仅可能在第 $0$ 号点或第 $n+1$ 号点。", "inputFormat": "本题有多组测试数据。第一行输入一个正整数 $T$，表示测试数据组数，接下来分别输入 $T$ 组数据。\n\n对于每组测试数据，第一行输入一个正整数 $n$。\n\n接下来 $n$ 行每行输入两个非负整数 $a_i,b_i$，表示 $a_i,b_i$ 的初始值。", "outputFormat": "对于每组测试数据输出一行一个整数表示最后结束时 $x$ 会在第几号点。", "hint": "#### 样例解释\n\n对于样例第 $1$ 组数据，$(x,y)$ 依次为 $(0,1)\\to (1,1)\\to (1,-1)\\to (0,-1)$。\n\n对于样例第 $2$ 组数据，$(x,y)$ 依次为 $(0,1)\\to (1,1)\\to (2,1)\\to (2,-1)\\to (1,-1)\\to (1,1)\\to (2,1)\\to (3,1)\\to (3,-1)\\to (2,-1)\\to (2,1)\\to (3,1)\\to (4,1)$。\n\n对于样例第 $3$ 组数据，$(x,y)$ 依次为 $(0,1)\\to (1,1)\\to (2,1)\\to (2,-1)\\to (1,-1)\\to (1,1)\\to (2,1)\\to (2,-1)\\to (1,-1)\\to (0,-1)$。\n\n#### 数据范围与约定\n\n对于前 $30\\%$ 的测试点，保证 $n,a_i,b_i\\le 10$。\n\n对于前 $60\\%$ 的测试点，保证 $\\sum n\\le 5000$。\n\n对于另外 $20\\%$ 的测试点，保证 $T=10$，$n=10^5$，$a_i,b_i$ 在指定范围内均匀随机生成。特别的，保证除该档部分分外所有测试点满足 $T\\ne 10$。\n\n对于所有测试点，保证 $1\\le T\\le 10^4$，$1\\le n\\le 10^5$，$1\\le \\sum n\\le 10^6$，$0\\le a_i,b_i\\le 10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "wbyblD", "background": "> D题，我不要被hack！！！", "description": "有 $n+2$ 个点排成一排，编号为 $0\\sim n+1$。对于第 $i$ 号点有两个整数 $a_i,b_i$，其中 $0\\le i\\le n+1$。规定初始时 $a_0=b_0=a_{n+1}=b_{n+1}=0$。\n\n设你当前在第 $x$ 号点，当前的移动方向为 $y$，初始时 $x=0,y=1$。\n\n你将按如下方式移动直到 $x,y$ 某一次变化后满足 $x=0,y=-1$ 或 $x=n+1,y=1$。\n\n- 若 $y=1$，首先将 $x$ 增加 $1$，此时若 $a_x>0$ 则将 $y$ 变成 $-1$，否则 $y$ 不变，最后再将 $a_x$ 减少 $1$。\n- 若 $y=-1$，首先将 $x$ 减少 $1$，此时若 $b_x>0$ 则将 $y$ 变成 $1$，否则 $y$ 不变，最后再将 $b_x$ 减少 $1$。\n\n问最后结束时 $x$ 会在第几号点，事实上，最后 $x$ 仅可能在第 $0$ 号点或第 $n+1$ 号点。", "inputFormat": "本题有多组测试数据。第一行输入一个正整数 $T$，表示测试数据组数，接下来分别输入 $T$ 组数据。\n\n对于每组测试数据，第一行输入一个正整数 $n$。\n\n接下来 $n$ 行每行输入两个非负整数 $a_i,b_i$，表示 $a_i,b_i$ 的初始值。", "outputFormat": "对于每组测试数据输出一行一个整数表示最后结束时 $x$ 会在第几号点。", "hint": "#### 样例解释\n\n对于样例第 $1$ 组数据，$(x,y)$ 依次为 $(0,1)\\to (1,1)\\to (1,-1)\\to (0,-1)$。\n\n对于样例第 $2$ 组数据，$(x,y)$ 依次为 $(0,1)\\to (1,1)\\to (2,1)\\to (2,-1)\\to (1,-1)\\to (1,1)\\to (2,1)\\to (3,1)\\to (3,-1)\\to (2,-1)\\to (2,1)\\to (3,1)\\to (4,1)$。\n\n对于样例第 $3$ 组数据，$(x,y)$ 依次为 $(0,1)\\to (1,1)\\to (2,1)\\to (2,-1)\\to (1,-1)\\to (1,1)\\to (2,1)\\to (2,-1)\\to (1,-1)\\to (0,-1)$。\n\n#### 数据范围与约定\n\n对于前 $30\\%$ 的测试点，保证 $n,a_i,b_i\\le 10$。\n\n对于前 $60\\%$ 的测试点，保证 $\\sum n\\le 5000$。\n\n对于另外 $20\\%$ 的测试点，保证 $T=10$，$n=10^5$，$a_i,b_i$ 在指定范围内均匀随机生成。特别的，保证除该档部分分外所有测试点满足 $T\\ne 10$。\n\n对于所有测试点，保证 $1\\le T\\le 10^4$，$1\\le n\\le 10^5$，$1\\le \\sum n\\le 10^6$，$0\\le a_i,b_i\\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P9816", "type": "P", "difficulty": 4, "samples": [["3 5 71\n1 1\n3 3\n1 0\n7 5\n9 6\n10 1\n5 6\n7 6", "27\n11\n29\n2\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["倍增", "O2优化"], "title": "少项式复合幂", "background": "> I have won everything except your heart.\n\n终于，小 Z 可以玩一年原神了。但在此之前，他决定做出这道题，以纪念自己对【数据删除】的感情。", "description": "给定多项式 $f(x)=\\sum_{i=1}^ma_ix^{b_i}$。定义 $f_1(x)=f(x)$，$f_n(x)=f(f_{n-1}(x))$。\n\n给定模数 $p$。有 $q$ 次询问，每次给出 $x,y$，查询 $f_y(x)\\bmod p$ 的值。\n\n**请注意 $m,p$ 的特殊数据范围。**", "inputFormat": "输入的第一行包含三个正整数 $m,q,p$，分别为 $f$ 的项数，询问次数和给定模数。\n\n随后 $m$ 行，每行读入两个非负整数 $a_i,b_i$，用于描述多项式 $f$。\n\n随后 $q$ 行，每行两个正整数 $x,y$，表示一次询问。", "outputFormat": "输出共 $q$ 行，每行包含对应询问的答案。", "hint": "#### 样例解释\n\n样例 1 中 $f(x)=3x^3+x+1$。以第 3 次询问为例，$f_1(10)=f(10)=3\\times10^3+10+1=3011\\equiv 29 \\pmod {71}$。\n\n#### 数据范围与约定\n\n|测试点编号|$y$|$m$|$q$|特殊性质|\n|:-:|:-:|:-:|:-:|:-:|\n|$1\\sim 3$|$\\le 10$|$\\le 20$|$\\le 10^3$|无|\n|$4\\sim 7$|$\\le 10^3$|$\\le 20$|$\\le 10^4$|无|\n|$8,9$|$\\le 10^7$|$\\le 1$|$\\le 3\\times 10^5$|A|\n|$10$|$\\le 10^7$|$\\le 1$|$\\le 3\\times 10^5$|无|\n|$11,12$|$\\le 10^7$|$\\le 2$|$\\le 10^5$|A、B|\n|$13$|$\\le 10^7$|$\\le 2$|$\\le 10^5$|B|\n|$14\\sim 16$|$\\le 10^7$|$\\le 20$|$\\le 500$|无|\n|$17\\sim 20$|$\\le 10^7$|$\\le 20$|$\\le 3\\times 10^5$|无|\n- 特殊性质 A：保证 $p$ 为质数。\n- 特殊性质 B：保证 $b_i\\le 1$。\n\n对于所有数据，保证 $1\\le m\\le 20$，$0\\le a_i,b_i\\le 10^5$，$2\\le p\\le 10^5$，$1\\le q\\le 3\\times 10^5$，$1\\le x,y\\le 10^7$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "少项式复合幂", "background": "> I have won everything except your heart.\n\n终于，小 Z 可以玩一年原神了。但在此之前，他决定做出这道题，以纪念自己对【数据删除】的感情。", "description": "给定多项式 $f(x)=\\sum_{i=1}^ma_ix^{b_i}$。定义 $f_1(x)=f(x)$，$f_n(x)=f(f_{n-1}(x))$。\n\n给定模数 $p$。有 $q$ 次询问，每次给出 $x,y$，查询 $f_y(x)\\bmod p$ 的值。\n\n**请注意 $m,p$ 的特殊数据范围。**", "inputFormat": "输入的第一行包含三个正整数 $m,q,p$，分别为 $f$ 的项数，询问次数和给定模数。\n\n随后 $m$ 行，每行读入两个非负整数 $a_i,b_i$，用于描述多项式 $f$。\n\n随后 $q$ 行，每行两个正整数 $x,y$，表示一次询问。", "outputFormat": "输出共 $q$ 行，每行包含对应询问的答案。", "hint": "#### 样例解释\n\n样例 1 中 $f(x)=3x^3+x+1$。以第 3 次询问为例，$f_1(10)=f(10)=3\\times10^3+10+1=3011\\equiv 29 \\pmod {71}$。\n\n#### 数据范围与约定\n\n|测试点编号|$y$|$m$|$q$|特殊性质|\n|:-:|:-:|:-:|:-:|:-:|\n|$1\\sim 3$|$\\le 10$|$\\le 20$|$\\le 10^3$|无|\n|$4\\sim 7$|$\\le 10^3$|$\\le 20$|$\\le 10^4$|无|\n|$8,9$|$\\le 10^7$|$\\le 1$|$\\le 3\\times 10^5$|A|\n|$10$|$\\le 10^7$|$\\le 1$|$\\le 3\\times 10^5$|无|\n|$11,12$|$\\le 10^7$|$\\le 2$|$\\le 10^5$|A、B|\n|$13$|$\\le 10^7$|$\\le 2$|$\\le 10^5$|B|\n|$14\\sim 16$|$\\le 10^7$|$\\le 20$|$\\le 500$|无|\n|$17\\sim 20$|$\\le 10^7$|$\\le 20$|$\\le 3\\times 10^5$|无|\n- 特殊性质 A：保证 $p$ 为质数。\n- 特殊性质 B：保证 $b_i\\le 1$。\n\n对于所有数据，保证 $1\\le m\\le 20$，$0\\le a_i,b_i\\le 10^5$，$2\\le p\\le 10^5$，$1\\le q\\le 3\\times 10^5$，$1\\le x,y\\le 10^7$。", "locale": "zh-CN"}}}
{"pid": "P9817", "type": "P", "difficulty": 5, "samples": [["5\n1 1\n2 1\n4 1\n5 2\n10 10", "0\n1\n4\n9\n810"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化"], "title": "******D", "background": "欢迎新斗友@[lmxcslD](https://www.luogu.com.cn/user/358957)", "description": "定义一个长度为 $m$ 的非空序列 $p_1,p_2,...,p_m$ 是**乱**的当且仅当满足以下两个条件。\n\n- 所有元素之和不超过 $n$，即 $\\sum_{i=1}^m p_i\\le n$。\n- 对于任意一个元素 $p_i$ 满足 $p_i=1$ 或 $p_i$ 为质数。\n\n定义一个**乱**的序列 $p_1,p_2,...,p_m$ 的**乱斗值**为该序列中所有元素减 $k$ 的平方和，即 $\\sum_{i=1}^m (p_i-k)^2$。\n\n特别的，定义一个**不乱**的序列的乱斗值为 $0$。\n\n现在给定两个正整数 $n,k$，问所有序列中**乱斗值**最大的序列的**乱斗值**是多少。", "inputFormat": "本题有多组测试数据。第一行输入一个正整数 $T$，表示测试数据组数，接下来分别输入 $T$ 组数据。\n\n对于每组测试数据，输入一行两个正整数 $n,k$。", "outputFormat": "对于每组测试数据输出一行一个整数表示答案。", "hint": "#### 样例解释\n\n对于样例第 $1,2,3,4$ 组数据，其中一种**乱斗值**最大的序列分别为 $(1),(2),(1,3),(5)$。\n\n#### 数据范围与约定\n\n|测试点编号|$T$|$n$|$k$|特殊性质|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$=100$|$\\le 10$|$\\le 10$|无|\n|$2$|$=200$|$\\le 30$|$\\le 10$|无|\n|$3$|$=300$|$\\le 10^3$|$\\le 5\\times 10^4$|无|\n|$4$|$=400$|$\\le 10^5$|$\\le 5\\times 10^4$|无|\n|$5$|$=500$|$\\le 10^7$|$\\le 5\\times 10^4$|无|\n|$6$|$=600$|$\\le 10^9$|$=1$|$n$ 为质数|\n|$7$|$=700$|$\\le 10^9$|$=1$|无|\n|$8$|$=800$|$\\le 10^9$|$=44444$|无|\n|$9$|$=900$|$\\le 10^9$|$\\le 5\\times 10^4$|$n$ 为质数|\n|$10$|$=10^3$|$\\le 10^9$|$\\le 5\\times 10^4$|无|\n\n对于所有测试点，保证 $1\\le T\\le 10^3$，$1\\le n\\le 10^9$，$1\\le k\\le 5\\times 10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "******D", "background": "欢迎新斗友@[lmxcslD](https://www.luogu.com.cn/user/358957)", "description": "定义一个长度为 $m$ 的非空序列 $p_1,p_2,...,p_m$ 是**乱**的当且仅当满足以下两个条件。\n\n- 所有元素之和不超过 $n$，即 $\\sum_{i=1}^m p_i\\le n$。\n- 对于任意一个元素 $p_i$ 满足 $p_i=1$ 或 $p_i$ 为质数。\n\n定义一个**乱**的序列 $p_1,p_2,...,p_m$ 的**乱斗值**为该序列中所有元素减 $k$ 的平方和，即 $\\sum_{i=1}^m (p_i-k)^2$。\n\n特别的，定义一个**不乱**的序列的乱斗值为 $0$。\n\n现在给定两个正整数 $n,k$，问所有序列中**乱斗值**最大的序列的**乱斗值**是多少。", "inputFormat": "本题有多组测试数据。第一行输入一个正整数 $T$，表示测试数据组数，接下来分别输入 $T$ 组数据。\n\n对于每组测试数据，输入一行两个正整数 $n,k$。", "outputFormat": "对于每组测试数据输出一行一个整数表示答案。", "hint": "#### 样例解释\n\n对于样例第 $1,2,3,4$ 组数据，其中一种**乱斗值**最大的序列分别为 $(1),(2),(1,3),(5)$。\n\n#### 数据范围与约定\n\n|测试点编号|$T$|$n$|$k$|特殊性质|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$=100$|$\\le 10$|$\\le 10$|无|\n|$2$|$=200$|$\\le 30$|$\\le 10$|无|\n|$3$|$=300$|$\\le 10^3$|$\\le 5\\times 10^4$|无|\n|$4$|$=400$|$\\le 10^5$|$\\le 5\\times 10^4$|无|\n|$5$|$=500$|$\\le 10^7$|$\\le 5\\times 10^4$|无|\n|$6$|$=600$|$\\le 10^9$|$=1$|$n$ 为质数|\n|$7$|$=700$|$\\le 10^9$|$=1$|无|\n|$8$|$=800$|$\\le 10^9$|$=44444$|无|\n|$9$|$=900$|$\\le 10^9$|$\\le 5\\times 10^4$|$n$ 为质数|\n|$10$|$=10^3$|$\\le 10^9$|$\\le 5\\times 10^4$|无|\n\n对于所有测试点，保证 $1\\le T\\le 10^3$，$1\\le n\\le 10^9$，$1\\le k\\le 5\\times 10^4$。", "locale": "zh-CN"}}}
{"pid": "P9818", "type": "P", "difficulty": 6, "samples": [["4 10\n2 2 1 5 9\n1 5 3\n3 2 1 2 1 3 3\n1 3 1\n5\n3 3\n2 3\n1 4\n2 4\n3 4", "3\n8\n13\n11\n6"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化"], "title": "游戏王", "background": "**本题已经增加 hack 数据**。hack 数据位于 subtask 7，记 0 分。此外本题时限较大数据点较多，希望各位不要滥用评测资源。\n\n你正在打块，突然家长走了进来，于是你假装在玩原神。", "description": "你改造了原神的抽卡系统。\n\n具体而言，在第 $i$ 次抽卡时，系统将会给出一个可重集合 $S_i$，表示这次抽卡中可供选择的角色。第 $j$ 个角色有两个属性：力量值 $s_{i,j}$ 与魔力值 $m_{i,j}$。你可以从中选择一名角色，并将其加入到自己的背包中；当然，你也可以不做任何选择。你的力量值被定义为背包中所有角色的力量值之和，同时你需要时刻保证背包中角色的魔力值之积不超过魔力上限 $v$。你的任务是最大化自己的力量值。\n\n但是，你很快就厌烦了千篇一律的抽卡。为了给生活找点乐子，你想到了这样的问题：如果游戏从第 $l$ 次抽卡开始，到第 $r$ 次抽卡结束，你的力量值最大是多少呢？\n\n你一口气提出了 $q$ 个这样的问题。现在，你需要计算出它们的答案。\n\n**形式化题意**：\n\n给出一个长为 $n$ 的序列 $\\{S_n\\}$，其中 $S_i$ 为多个二元组 $(s_{i,j},m_{i,j})$ 构成的可重集。有 $q$ 次询问，每次给定 $l,r$，你需要从 $S_l,S_{l+1},\\cdots,S_r$ 的每个集合中分别选出 $0$ 个或 $1$ 个二元组。记选出的 $k$ 个二元组为 $(s'_i,m'_i),1\\le i\\le k$，则你需要在保证 $\\prod_{i=1}^km'_i\\le v$ 的基础上，最大化 $\\sum_{i=1}^k s'_i$。", "inputFormat": "输入的第一行包含两个正整数 $n,v$。\n\n接下来 $n$ 行，每行首先读入 $|S_i|$，接下来读入 $|S_i|$ 对正整数 $(s_{i,j},m_{i,j})$，即 $S_i$ 中每一角色的力量值与魔力值。\n\n随后一行，读入一个正整数 $q$。\n\n接下来 $q$ 行，每行两个正整数 $l,r$，表示一次询问。**注意询问间两两独立，即每次询问都将被视作一次新的游戏。**", "outputFormat": "输出共 $q$ 行。对于每次询问，输出你的体力值的最大值。", "hint": "#### 样例解释\n\n对于第一组询问，最优策略是从 $S_3$ 中选择 $(3,3)$。此时你的能力值为 $3$。\n\n对于第三组询问，最优策略是从 $S_1$ 中选择 $(2,1)$，$S_2$ 中选择 $(5,3)$，$S_3$ 中选择 $(3,3)$，$S_4$ 中选择 $(3,1)$，此时魔力值之积等于 $1\\times 3\\times 3\\times 1=9\\le 10$，你的能力值等于 $2+5+3+3=13$。 \n\n#### 数据范围与约定\n\n**本题使用子任务捆绑测试，只有通过子任务内全部测试点才可以获得该子任务的相应分数**。\n\n记 $tot=\\sum_{i=1}^n|S_i|$。\n\n- 子任务 1（5 分）：保证 $n,tot\\le 10$。\n- 子任务 2（20 分）：保证 $n,v,tot,q\\le 100$。\n- 子任务 3（15 分）：保证所有 $m_{i,j}$ 在范围内均匀随机生成。\n- 子任务 4（20 分）：保证 $1\\le n,v,tot,q\\le 10^4$。\n- 子任务 5（15 分）：保证对于所有询问，均有 $l=1$ 或者 $r=n$。\n- 子任务 6（25 分）：无特殊限制。\n\n对于所有数据，保证 $1\\le n,tot\\le 10^5$，$1\\le q\\le 2\\times 10^5$，$1\\le m_{i,j}\\le v\\le 10^5$，$1\\le s_{i,j}\\le 10^4$，$1\\le l\\le r\\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "游戏王", "background": "**本题已经增加 hack 数据**。hack 数据位于 subtask 7，记 0 分。此外本题时限较大数据点较多，希望各位不要滥用评测资源。\n\n你正在打块，突然家长走了进来，于是你假装在玩原神。", "description": "你改造了原神的抽卡系统。\n\n具体而言，在第 $i$ 次抽卡时，系统将会给出一个可重集合 $S_i$，表示这次抽卡中可供选择的角色。第 $j$ 个角色有两个属性：力量值 $s_{i,j}$ 与魔力值 $m_{i,j}$。你可以从中选择一名角色，并将其加入到自己的背包中；当然，你也可以不做任何选择。你的力量值被定义为背包中所有角色的力量值之和，同时你需要时刻保证背包中角色的魔力值之积不超过魔力上限 $v$。你的任务是最大化自己的力量值。\n\n但是，你很快就厌烦了千篇一律的抽卡。为了给生活找点乐子，你想到了这样的问题：如果游戏从第 $l$ 次抽卡开始，到第 $r$ 次抽卡结束，你的力量值最大是多少呢？\n\n你一口气提出了 $q$ 个这样的问题。现在，你需要计算出它们的答案。\n\n**形式化题意**：\n\n给出一个长为 $n$ 的序列 $\\{S_n\\}$，其中 $S_i$ 为多个二元组 $(s_{i,j},m_{i,j})$ 构成的可重集。有 $q$ 次询问，每次给定 $l,r$，你需要从 $S_l,S_{l+1},\\cdots,S_r$ 的每个集合中分别选出 $0$ 个或 $1$ 个二元组。记选出的 $k$ 个二元组为 $(s'_i,m'_i),1\\le i\\le k$，则你需要在保证 $\\prod_{i=1}^km'_i\\le v$ 的基础上，最大化 $\\sum_{i=1}^k s'_i$。", "inputFormat": "输入的第一行包含两个正整数 $n,v$。\n\n接下来 $n$ 行，每行首先读入 $|S_i|$，接下来读入 $|S_i|$ 对正整数 $(s_{i,j},m_{i,j})$，即 $S_i$ 中每一角色的力量值与魔力值。\n\n随后一行，读入一个正整数 $q$。\n\n接下来 $q$ 行，每行两个正整数 $l,r$，表示一次询问。**注意询问间两两独立，即每次询问都将被视作一次新的游戏。**", "outputFormat": "输出共 $q$ 行。对于每次询问，输出你的体力值的最大值。", "hint": "#### 样例解释\n\n对于第一组询问，最优策略是从 $S_3$ 中选择 $(3,3)$。此时你的能力值为 $3$。\n\n对于第三组询问，最优策略是从 $S_1$ 中选择 $(2,1)$，$S_2$ 中选择 $(5,3)$，$S_3$ 中选择 $(3,3)$，$S_4$ 中选择 $(3,1)$，此时魔力值之积等于 $1\\times 3\\times 3\\times 1=9\\le 10$，你的能力值等于 $2+5+3+3=13$。 \n\n#### 数据范围与约定\n\n**本题使用子任务捆绑测试，只有通过子任务内全部测试点才可以获得该子任务的相应分数**。\n\n记 $tot=\\sum_{i=1}^n|S_i|$。\n\n- 子任务 1（5 分）：保证 $n,tot\\le 10$。\n- 子任务 2（20 分）：保证 $n,v,tot,q\\le 100$。\n- 子任务 3（15 分）：保证所有 $m_{i,j}$ 在范围内均匀随机生成。\n- 子任务 4（20 分）：保证 $1\\le n,v,tot,q\\le 10^4$。\n- 子任务 5（15 分）：保证对于所有询问，均有 $l=1$ 或者 $r=n$。\n- 子任务 6（25 分）：无特殊限制。\n\n对于所有数据，保证 $1\\le n,tot\\le 10^5$，$1\\le q\\le 2\\times 10^5$，$1\\le m_{i,j}\\le v\\le 10^5$，$1\\le s_{i,j}\\le 10^4$，$1\\le l\\le r\\le n$。", "locale": "zh-CN"}}}
{"pid": "P9819", "type": "P", "difficulty": 7, "samples": [["5\n0 0\n1 10\n2 0\n3 10\n4 0", "22.099751242242"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["计算几何", "2020", "上海", "Special Judge", "O2优化", "线段相交", "ICPC"], "title": "[ICPC 2020 Shanghai R] Wowoear", "background": "", "description": "Wowo is a solo adventurer who completed many dangerous journeys on his own foot in forests, deserts and even glaciers. The Shanghai ICPC (Shanghai Invitational Contest on Programmable Cheating) committee invited Wowo as a tester of their new running trial.\n\nThe trial can be described as a 2D simple polyline $(p_1,\\ldots, p_n)$. In other words, the trial consists of $n-1$ line segments $(p_1, p_2),\\ldots, (p_{n-1}, p_n)$. The line segments do not intersect with each other except that two consecutive line segments $(p_i, p_{i+1})$ and $(p_{i+1}, p_{i+2})$ intersect at the point $p_{i+1}$. Any two consecutive segments have different directions. The committee wants Wowo to run from $p_1$ to $p_n$ along the line segments $(p_1,p_2),\\ldots, (p_{n-1}, p_n)$ in order.\n\nHowever, Wowo has a smart device that can hack the committee's system for an interval of time. Wowo is able to choose $2$ points $a, b$ on the trial and run directly from $a$ to $b$ along the line segment $(a, b)$. Each of these $a$ and $b$ can be some $p_i$ ($1\\le i\\le n$) and can be some point on some line segment $(p_i, p_{i+1})$ ($1\\le i<n$) as well. Before reaching $a$ and after reaching $b$, Wowo has to run along the original trial. Wowo does not want to be caught cheating, so he decided that the line segment $(a, b)$ should not intersect or touch any line segment of the trial at any point other than $a$ and $b$. Help Wowo to choose $a$ and $b$ wisely and output the shortest distance Wowo need to run from $p_1$ to $p_n$ using his smart cheating device.", "inputFormat": "The first line includes a single integer $n$ indicating the number of points on the running trial ($2\\le n\\le 200$).\n\nThe $i+1$-th line ($1\\le i\\le n$) contains two integers $x$ and $y$ separated by a single space indicating the coordinates of $p_i$ ($-1000\\le x, y\\le 1000$).\n\nIt is guaranteed that the line segments do not intersect with each other except that two consecutive line segments $(p_i, p_{i+1})$ and $(p_{i+1}, p_{i+2})$ intersect at the point $p_{i+1}$. In other words, $(p_i, p_{i+1})\\cap (p_{j}, p_{j+1})=\\left\\{\\begin{array}{cc}\\emptyset & i\\neq j-1\\\\ \\{p_{j}\\} & i = j-1\\end{array}\\right.$ holds for any integers $i, j$ satisfying $1\\le i< j<n$. Here $(s, t)$ represents all points on the line segment from $s$ to $t$ including $s$ and $t$.\n\nIt is guaranteed that each line segment has nonzero length. In other words, $p_i\\neq p_{i+1}$ for any integer $i\\in [1, n)$.\n\nIt is guaranteed that adjacent line segments are not collinear. In other words, for any integer $i\\in [1,n-2]$ and any real number $\\lambda$, $p_i - p_{i+1}$ is $\\textbf{not}$ equal to $\\lambda(p_{i+1}-p_{i+2})$.", "outputFormat": "Output the shortest distance Wowo needs to run. Your answer will be considered correct if its absolute or relative error does not exceed $10^{-6}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Wowoear", "background": "", "description": "Wowo is a solo adventurer who completed many dangerous journeys on his own foot in forests, deserts and even glaciers. The Shanghai ICPC (Shanghai Invitational Contest on Programmable Cheating) committee invited Wowo as a tester of their new running trial.\n\nThe trial can be described as a 2D simple polyline $(p_1,\\ldots, p_n)$. In other words, the trial consists of $n-1$ line segments $(p_1, p_2),\\ldots, (p_{n-1}, p_n)$. The line segments do not intersect with each other except that two consecutive line segments $(p_i, p_{i+1})$ and $(p_{i+1}, p_{i+2})$ intersect at the point $p_{i+1}$. Any two consecutive segments have different directions. The committee wants Wowo to run from $p_1$ to $p_n$ along the line segments $(p_1,p_2),\\ldots, (p_{n-1}, p_n)$ in order.\n\nHowever, Wowo has a smart device that can hack the committee's system for an interval of time. Wowo is able to choose $2$ points $a, b$ on the trial and run directly from $a$ to $b$ along the line segment $(a, b)$. Each of these $a$ and $b$ can be some $p_i$ ($1\\le i\\le n$) and can be some point on some line segment $(p_i, p_{i+1})$ ($1\\le i<n$) as well. Before reaching $a$ and after reaching $b$, Wowo has to run along the original trial. Wowo does not want to be caught cheating, so he decided that the line segment $(a, b)$ should not intersect or touch any line segment of the trial at any point other than $a$ and $b$. Help Wowo to choose $a$ and $b$ wisely and output the shortest distance Wowo need to run from $p_1$ to $p_n$ using his smart cheating device.", "inputFormat": "The first line includes a single integer $n$ indicating the number of points on the running trial ($2\\le n\\le 200$).\n\nThe $i+1$-th line ($1\\le i\\le n$) contains two integers $x$ and $y$ separated by a single space indicating the coordinates of $p_i$ ($-1000\\le x, y\\le 1000$).\n\nIt is guaranteed that the line segments do not intersect with each other except that two consecutive line segments $(p_i, p_{i+1})$ and $(p_{i+1}, p_{i+2})$ intersect at the point $p_{i+1}$. In other words, $(p_i, p_{i+1})\\cap (p_{j}, p_{j+1})=\\left\\{\\begin{array}{cc}\\emptyset & i\\neq j-1\\\\ \\{p_{j}\\} & i = j-1\\end{array}\\right.$ holds for any integers $i, j$ satisfying $1\\le i< j<n$. Here $(s, t)$ represents all points on the line segment from $s$ to $t$ including $s$ and $t$.\n\nIt is guaranteed that each line segment has nonzero length. In other words, $p_i\\neq p_{i+1}$ for any integer $i\\in [1, n)$.\n\nIt is guaranteed that adjacent line segments are not collinear. In other words, for any integer $i\\in [1,n-2]$ and any real number $\\lambda$, $p_i - p_{i+1}$ is $\\textbf{not}$ equal to $\\lambda(p_{i+1}-p_{i+2})$.", "outputFormat": "Output the shortest distance Wowo needs to run. Your answer will be considered correct if its absolute or relative error does not exceed $10^{-6}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Wowoear", "background": "", "description": "Wowo 是一位单人冒险家，他曾独自一人在森林、沙漠甚至冰川中完成过许多危险的旅程。ICPC（上海市可编程作弊邀请赛）组委会邀请 Wowo 作为新的跑步测试员。\n\n该试验可描述为二维简单折线 $(p_1,\\ldots, p_n)$。换句话说，试验由 $n-1$ 条线段 $(p_1, p_2),\\ldots, (p_{n-1}, p_n)$ 组成。除了两个连续的线段 $(p_i, p_{i+1})$ 和 $(p_{i+1}, p_{i+2})$ 相交于点 $p_{i+1}$ 外，其他线段互不相交。任何两条连续的线段都有不同的方向。委员会希望 Wowo 从 $p_1$ 到 $p_n$ 依次沿着线段 $(p_1,p_2),\\ldots, (p_{n-1}, p_n)$ 运行。\n\n然而，Wowo 拥有一个智能设备，可以在一段时间内侵入委员会的系统。Wowo 能够在试验中选择 $2$ 点 $a, b$ ，并沿着线段 $(a, b)$ 直接从 $a$ 跑到 $b$ 。其中每个 $a$ 和 $b$ 都可以是某个 $p_i$ （$1\\le i\\le n$）。($1\\le i\\le n$) ，也可以是线段 $(p_i, p_{i+1})$ 上的某一点。($1\\le i \\le n$)上的某一点。在到达 $a$ 之前和 $b$ 之后，Wowo 必须沿着原来的试验路线运行。沃沃不想被发现作弊，所以他决定线段 $(a, b)$ 不能与试验中的任何线段相交，也不能接触到 $a$ 和 $b$ 以外的任何点。请帮助 Wowo 明智地选择 $a$ 和 $b$ ，并利用他的智能作弊装置输出 Wowo 需要从 $p_1$ 跑到 $p_n$ 的最短距离", "inputFormat": "第一行包含一个整数 $n$ ，表示运行试验中的点数（ $2\\le n\\le 200$ ）。\n\n第 $i+1$（$1\\le i\\le n$）行包含两个整数 $x$ 和 $y$，中间用一个空格隔开，表示 $p_i$（$-1000\\le x, y\\le 1000$）的坐标。\n\n除了两条连续的线段 $(p_i, p_{i+1})$ 和 $(p_{i+1}, p_{i+2})$ 相交于点 $p_{i+1}$ 之外，其他线段保证互不相交。换句话说，对于满足 $1 \\le i\\lt j \\lt n$ 的任何整数 $i, j$，$(p_i, p_{i+1})\\cap (p_{j}, p_{j+1})=\\left\\{\\begin{array}{cc}\\emptyset & i\\neq j-1\\\\ \\{p_{j}\\} & i = j-1\\end{array}\\right.$ 都成立。这里的 $(s, t)$ 代表从 $s$ 到 $t$ 的线段上的所有点，包括 $s$ 和 $t$。\n可以保证每条线段的长度都不为零。换句话说，$p_i\\neq p_{i+1}$ 满足任意整数 $i\\in [1, n)$。\n\n保证相邻线段不相交。换句话说，对于任意整数 $i\\in [1,n-2]$ 和任意实数 $\\lambda$，$p_i - p_{i+1}$ 不**等于**$\\lambda(p_{i+1}-p_{i+2})$。", "outputFormat": "输出 Wowo 需要运行的最短距离。如果答案的绝对误差或相对误差不超过 $10^{-6}$，则认为答案正确。  \nTranslation by [nightwatch_ryan](/user/961351)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9820", "type": "P", "difficulty": 4, "samples": [["2 4\nX..X\nX.X.\nX.X.\n.X..", "X.XX\n.X.."]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2020", "上海", "Special Judge", "O2优化", "鸽笼原理", "构造", "ICPC", "Ad-hoc"], "title": "[ICPC 2020 Shanghai R] Mine Sweeper II", "background": "", "description": "A mine-sweeper map $X$ can be expressed as an $n\\times m$ grid. Each cell of the grid is either a mine cell or a non-mine cell. A mine cell has no number on it. Each non-mine cell has a number representing the number of mine cells around it. (A cell is around another cell if they share at least one common point. Thus, every cell that is not on the boundary has $8$ cells around it.) The following is a $16\\times 30$ mine-sweeper map where a flagged cell denotes a mine cell and a blank cell denotes a non-mine cell with number 0.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5bykwzuy.png)\n\nGiven two mine-sweeper maps $A, B$ of size $n\\times m$, you should modify at most $\\left\\lfloor\\frac{nm}{2}\\right\\rfloor$ (i.e. the largest nonnegative integer that is less than or equal to $\\frac{nm}{2}$) cells in $B$ (from a non-mine cell to a mine cell or vice versa) such that the sum of numbers in the non-mine cells in $A$ and the sum of numbers in the non-mine cells in $B$ are the same. (If a map has no non-mine cell, the sum is considered as $0$.)\n\nIf multiple solutions exist, print any of them. If no solution exists, print ``-1`` in one line.", "inputFormat": "The first line contains two integers $n, m\\,(1\\le n,m \\le 1000)$, denoting the size of given mine-sweeper maps.\n\nThe $i$-th line of the following $n$ lines contains a length-$m$ string consisting of  ``.`` and ``X`` denoting the $i$-th row of the mine-sweeper map $A$. A ``.`` denotes for a non-mine cell and an ``X`` denotes for a mine cell.\n\nThe $i$-th line of the following $n$ lines contains a length-$m$ string consisting of  ``.`` and ``X`` denoting the $i$-th row of the mine-sweeper map $B$. A ``.`` denotes for a non-mine cell and an ``X`` denotes for a mine cell.", "outputFormat": "If no solution exists, print ``-1`` in one line.\n\nOtherwise, print $n$ lines denoting the modified mine-sweeper map $B$. The $i$-th line should contain a length-$m$ string consisting of  ``.`` and ``X`` denoting the $i$-th row of the modified map $B$. A ``.`` denotes for a non-mine cell and an ``X`` denotes for a mine cell.\n\nPlease notice that you need not print the numbers on non-mine cells since these numbers can be determined by the output mine-sweeper map.", "hint": "We modify one cell in $B$. Then the sums of the numbers on non-mine cells in $A$ and $B$ both equal $10$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Mine Sweeper II", "background": "", "description": "A mine-sweeper map $X$ can be expressed as an $n\\times m$ grid. Each cell of the grid is either a mine cell or a non-mine cell. A mine cell has no number on it. Each non-mine cell has a number representing the number of mine cells around it. (A cell is around another cell if they share at least one common point. Thus, every cell that is not on the boundary has $8$ cells around it.) The following is a $16\\times 30$ mine-sweeper map where a flagged cell denotes a mine cell and a blank cell denotes a non-mine cell with number 0.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5bykwzuy.png)\n\nGiven two mine-sweeper maps $A, B$ of size $n\\times m$, you should modify at most $\\left\\lfloor\\frac{nm}{2}\\right\\rfloor$ (i.e. the largest nonnegative integer that is less than or equal to $\\frac{nm}{2}$) cells in $B$ (from a non-mine cell to a mine cell or vice versa) such that the sum of numbers in the non-mine cells in $A$ and the sum of numbers in the non-mine cells in $B$ are the same. (If a map has no non-mine cell, the sum is considered as $0$.)\n\nIf multiple solutions exist, print any of them. If no solution exists, print ``-1`` in one line.", "inputFormat": "The first line contains two integers $n, m\\,(1\\le n,m \\le 1000)$, denoting the size of given mine-sweeper maps.\n\nThe $i$-th line of the following $n$ lines contains a length-$m$ string consisting of  ``.`` and ``X`` denoting the $i$-th row of the mine-sweeper map $A$. A ``.`` denotes for a non-mine cell and an ``X`` denotes for a mine cell.\n\nThe $i$-th line of the following $n$ lines contains a length-$m$ string consisting of  ``.`` and ``X`` denoting the $i$-th row of the mine-sweeper map $B$. A ``.`` denotes for a non-mine cell and an ``X`` denotes for a mine cell.", "outputFormat": "If no solution exists, print ``-1`` in one line.\n\nOtherwise, print $n$ lines denoting the modified mine-sweeper map $B$. The $i$-th line should contain a length-$m$ string consisting of  ``.`` and ``X`` denoting the $i$-th row of the modified map $B$. A ``.`` denotes for a non-mine cell and an ``X`` denotes for a mine cell.\n\nPlease notice that you need not print the numbers on non-mine cells since these numbers can be determined by the output mine-sweeper map.", "hint": "We modify one cell in $B$. Then the sums of the numbers on non-mine cells in $A$ and $B$ both equal $10$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Mine Sweeper II", "background": "", "description": "扫雷地图 $X$ 可以表示为一个 $n \\times m$ 的网格。网格中的每个单元格要么是地雷单元格，要么是非地雷单元格。地雷单元格上没有数字。每个非地雷单元格有一个数字，表示其周围地雷单元格的数量。（如果一个单元格与另一个单元格共享至少一个公共点，则它们是相邻的。因此，每个不在边界上的单元格周围有 $8$ 个单元格。）以下是一个 $16 \\times 30$ 的扫雷地图，其中标记的单元格表示地雷单元格，空白单元格表示数字为 0 的非地雷单元格。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5bykwzuy.png)\n\n给定两个大小为 $n \\times m$ 的扫雷地图 $A, B$，你应该在 $B$ 中修改最多 $ \\left\\lfloor \\frac{nm}{2} \\right\\rfloor $（即小于或等于 $\\frac{nm}{2}$ 的最大非负整数）个单元格（从非地雷单元格变为地雷单元格或反之），使得 $A$ 中非地雷单元格的数字之和与 $B$ 中非地雷单元格的数字之和相同。（如果地图中没有非地雷单元格，则和被视为 $0$。）\n\n如果存在多个解，输出其中任意一个。如果不存在解，输出一行 ``-1``。", "inputFormat": "第一行包含两个整数 $n, m\\,(1\\le n,m \\le 1000)$，表示给定的扫雷地图的大小。\n\n接下来的 $n$ 行的第 $i$ 行包含一个长度为 $m$ 的字符串，由 ``.`` 和 ``X`` 组成，表示扫雷地图 $A$ 的第 $i$ 行。``.`` 表示非地雷单元格，``X`` 表示地雷单元格。\n\n接下来的 $n$ 行的第 $i$ 行包含一个长度为 $m$ 的字符串，由 ``.`` 和 ``X`` 组成，表示扫雷地图 $B$ 的第 $i$ 行。``.`` 表示非地雷单元格，``X`` 表示地雷单元格。", "outputFormat": "如果不存在解，输出一行 ``-1``。\n\n否则，输出 $n$ 行表示修改后的扫雷地图 $B$。第 $i$ 行应包含一个长度为 $m$ 的字符串，由 ``.`` 和 ``X`` 组成，表示修改后的地图 $B$ 的第 $i$ 行。``.`` 表示非地雷单元格，``X`` 表示地雷单元格。\n\n请注意，您不需要输出非地雷单元格上的数字，因为这些数字可以通过输出的扫雷地图确定。", "hint": "我们在 $B$ 中修改一个单元格。然后 $A$ 和 $B$ 中非地雷单元格上的数字之和都等于 10。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9821", "type": "P", "difficulty": 5, "samples": [["3\n3 3\n19 26\n8 17", "14\n814\n278"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "上海", "O2优化", "数位 DP", "ICPC"], "title": "[ICPC 2020 Shanghai R] Sum of Log", "background": "", "description": "Given two non-negative integers $X$ and $Y$, determine the value of \n$$ \\sum_{i=0}^{X}\\sum_{j=[i=0]}^{Y}[i\\&j=0]\\lfloor\\log_2(i+j)+1\\rfloor $$\nmodulo $10^9+7$ where\n- $\\&$ denotes bitwise AND;\n- $[A]$ equals 1 if $A$ is true, otherwise $0$;\n- $\\lfloor x\\rfloor$ equals the maximum integer whose value is no more than $x$.", "inputFormat": "The first line contains one integer $T\\,(1\\le T \\le 10^5)$ denoting the number of test cases.\n\nEach of the following $T$ lines contains two integers $X, Y\\,(0\\le X,Y \\le 10^9)$ indicating a test case.", "outputFormat": "For each test case, print one line containing one integer, the answer to the test case.", "hint": "For the first test case:\n- Two $(i,j)$ pairs increase the sum by 1: $(0, 1), (1, 0)$\n- Six $(i,j)$ pairs increase the sum by 2: $(0, 2), (0, 3), (1, 2), (2, 0), (2, 1), (3, 0)$\n\nSo the answer is $1\\times 2 + 2\\times 6 = 14$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Sum of Log", "background": "", "description": "Given two non-negative integers $X$ and $Y$, determine the value of \n$$ \\sum_{i=0}^{X}\\sum_{j=[i=0]}^{Y}[i\\&j=0]\\lfloor\\log_2(i+j)+1\\rfloor $$\nmodulo $10^9+7$ where\n- $\\&$ denotes bitwise AND;\n- $[A]$ equals 1 if $A$ is true, otherwise $0$;\n- $\\lfloor x\\rfloor$ equals the maximum integer whose value is no more than $x$.", "inputFormat": "The first line contains one integer $T\\,(1\\le T \\le 10^5)$ denoting the number of test cases.\n\nEach of the following $T$ lines contains two integers $X, Y\\,(0\\le X,Y \\le 10^9)$ indicating a test case.", "outputFormat": "For each test case, print one line containing one integer, the answer to the test case.", "hint": "For the first test case:\n- Two $(i,j)$ pairs increase the sum by 1: $(0, 1), (1, 0)$\n- Six $(i,j)$ pairs increase the sum by 2: $(0, 2), (0, 3), (1, 2), (2, 0), (2, 1), (3, 0)$\n\nSo the answer is $1\\times 2 + 2\\times 6 = 14$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Sum of Log", "background": "", "description": "给定两个非负整数 $X$ 和 $Y$，计算以下值：  \n$$ \\sum_{i=0}^{X}\\sum_{j=[i=0]}^{Y}[i\\&j=0]\\lfloor\\log_2(i+j)+1\\rfloor $$  \n对 $10^9+7$ 取模，其中  \n- $\\&$ 表示按位与运算；  \n- $[A]$ 的值为 1 如果 $A$ 为真，否则为 0；  \n- $\\lfloor x\\rfloor$ 表示不大于 $x$ 的最大整数。", "inputFormat": "第一行包含一个整数 $T\\,(1\\le T \\le 10^5)$，表示测试用例的数量。  \n\n接下来的 $T$ 行中，每行包含两个整数 $X, Y\\,(0\\le X,Y \\le 10^9)$，表示一个测试用例。", "outputFormat": "对于每个测试用例，输出一行一个整数，表示该测试用例的答案。", "hint": "对于第一个测试用例：  \n- 两个 $(i,j)$ 对使得和增加 1：$(0, 1), (1, 0)$  \n- 六个 $(i,j)$ 对使得和增加 2：$(0, 2), (0, 3), (1, 2), (2, 0), (2, 1), (3, 0)$  \n\n所以答案是 $1\\times 2 + 2\\times 6 = 14$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9822", "type": "P", "difficulty": 3, "samples": [["2\n10000.0 1.0 0.001 9999.0 0.001\n4306.063 4079.874 0.607 1033.423 0.847", "5001000.0000000000\n3827.8370013755"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2020", "二分", "上海", "Special Judge", "O2优化", "ICPC"], "title": "[ICPC 2020 Shanghai R] Walker", "background": "", "description": "As a world-famous traveler, Prof. Pang's research interest is to travel as many places as possible in his life.\n\nWe have a segment $[0, n]$. There are two travelers on it. The first one is on position $p_1$ with velocity $v_1$ (which means s/he can walk $v_1$ unit on the segment per second). The second one is on position $p_2$ with velocity $v_2$.\n\nFrom their respective beginning points, travelers can walk on the segment. They cannot walk outside the segment. Whenever they want to change their direction, they can turn around immediately.\n\nPlease help Prof. Pang to calculate the minimum  possible time by which every position of the segment is passed by at least one traveler.", "inputFormat": "The first line contains one integer $test~(1\\le test\\le 10000)$ -- the number of test cases.\n\nThe $i$-th of the next $test$ lines contains five numbers $n, p_{1, i}, v_{1, i}, p_{2, i}, v_{2, i}$ ($0 < n \\le 10000$, $0\\le p_{1, i},p_{2, i} \\le n$, $0.001 \\le v_{1, i},v_{2, i} \\le 1000$). All numbers have at most $3$ digits after the decimal point.", "outputFormat": "For each test case, we should output one number -- the minimum time that every position of the segment is passed by at least one traveler.\n\nYour answer is considered correct if its absolute or relative error does not exceed $10^{-6}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Walker", "background": "", "description": "As a world-famous traveler, Prof. Pang's research interest is to travel as many places as possible in his life.\n\nWe have a segment $[0, n]$. There are two travelers on it. The first one is on position $p_1$ with velocity $v_1$ (which means s/he can walk $v_1$ unit on the segment per second). The second one is on position $p_2$ with velocity $v_2$.\n\nFrom their respective beginning points, travelers can walk on the segment. They cannot walk outside the segment. Whenever they want to change their direction, they can turn around immediately.\n\nPlease help Prof. Pang to calculate the minimum  possible time by which every position of the segment is passed by at least one traveler.", "inputFormat": "The first line contains one integer $test~(1\\le test\\le 10000)$ -- the number of test cases.\n\nThe $i$-th of the next $test$ lines contains five numbers $n, p_{1, i}, v_{1, i}, p_{2, i}, v_{2, i}$ ($0 < n \\le 10000$, $0\\le p_{1, i},p_{2, i} \\le n$, $0.001 \\le v_{1, i},v_{2, i} \\le 1000$). All numbers have at most $3$ digits after the decimal point.", "outputFormat": "For each test case, we should output one number -- the minimum time that every position of the segment is passed by at least one traveler.\n\nYour answer is considered correct if its absolute or relative error does not exceed $10^{-6}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Walker", "background": "", "description": "作为一名世界闻名的旅行者，Pang 教授的研究兴趣是尽可能多地在他的一生中旅行到各个地方。\n\n我们有一个线段 $[0, n]$。在线段上有两名旅行者。第一位旅行者位于位置 $p_1$，速度为 $v_1$（这意味着他/她每秒可以在线段上行走 $v_1$ 单位）。第二位旅行者位于位置 $p_2$，速度为 $v_2$。\n\n从他们各自的起点开始，旅行者可以在线段上行走。他们不能走出线段。无论何时他们想要改变方向，他们可以立即转身。\n\n请帮助 Pang 教授计算每个位置至少被一名旅行者经过所需的最短时间。", "inputFormat": "第一行包含一个整数 $test~(1\\le test\\le 10000)$ —— 测试用例的数量。\n\n接下来的 $test$ 行中的第 $i$ 行包含五个数字 $n, p_{1, i}, v_{1, i}, p_{2, i}, v_{2, i}$ ($0 < n \\le 10000$, $0\\le p_{1, i},p_{2, i} \\le n$, $0.001 \\le v_{1, i},v_{2, i} \\le 1000$)。所有数字最多有 $3$ 位小数。", "outputFormat": "对于每个测试用例，输出一个数字 —— 每个位置至少被一名旅行者经过所需的最短时间。\n\n如果答案的绝对误差或相对误差不超过 $10^{-6}$，则认为答案是正确的。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9823", "type": "P", "difficulty": 5, "samples": [["1 1", "1"], ["2 3", "2"], ["3 2", "4"], ["4 2", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2020", "上海", "O2优化", "组合数学", "逆元", "ICPC"], "title": "[ICPC 2020 Shanghai R] The Journey of Geor Autumn", "background": "", "description": "Once upon a time, there was a witch named Geor Autumn, who set off on a journey across the world. Along the way, she would meet all kinds of people, from a country full of ICPC competitors to a horse in love with dota---but with each meeting, Geor would become a small part of their story, and her own world would get a little bit bigger.\n\nGeor just arrived at the state of Shu where people love poems. A poem is a permutation $(a_1,\\ldots, a_n)$ of $[n]$. ($(a_1,\\ldots, a_n)$ is a permutation of $[n]$ means that each $a_i$ is an integer in $[1,n]$ and that $a_1,\\ldots, a_n$ are distinct.) One poem is $\\textit{good}$ if for all integer $i$ satisfying $i> k$ and $i\\le n$, $a_i>\\min(a_{i-k}, \\ldots, a_{i-1})$. Here $\\min(a_{i-k}, \\ldots, a_{i-1})$ denotes the minimum value among $a_{i-k}, \\ldots, a_{i-1}$.\n\nHelp Geor calculate how many good poems there are, given $n$ and $k$. To avoid huge numbers, output the answer modulo $998244353$.", "inputFormat": "The first line contains two integers $n$ and $k$ separated by a single space ($1\\le n\\le 10^7$, $1\\le k\\le 10^7$).", "outputFormat": "Output only one integer in one line---the number of good poems modulo $998244353$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] The Journey of Geor Autumn", "background": "", "description": "Once upon a time, there was a witch named Geor Autumn, who set off on a journey across the world. Along the way, she would meet all kinds of people, from a country full of ICPC competitors to a horse in love with dota---but with each meeting, Geor would become a small part of their story, and her own world would get a little bit bigger.\n\nGeor just arrived at the state of Shu where people love poems. A poem is a permutation $(a_1,\\ldots, a_n)$ of $[n]$. ($(a_1,\\ldots, a_n)$ is a permutation of $[n]$ means that each $a_i$ is an integer in $[1,n]$ and that $a_1,\\ldots, a_n$ are distinct.) One poem is $\\textit{good}$ if for all integer $i$ satisfying $i> k$ and $i\\le n$, $a_i>\\min(a_{i-k}, \\ldots, a_{i-1})$. Here $\\min(a_{i-k}, \\ldots, a_{i-1})$ denotes the minimum value among $a_{i-k}, \\ldots, a_{i-1}$.\n\nHelp Geor calculate how many good poems there are, given $n$ and $k$. To avoid huge numbers, output the answer modulo $998244353$.", "inputFormat": "The first line contains two integers $n$ and $k$ separated by a single space ($1\\le n\\le 10^7$, $1\\le k\\le 10^7$).", "outputFormat": "Output only one integer in one line---the number of good poems modulo $998244353$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] The Journey of Geor Autumn", "background": null, "description": "给定 $1 \\le k \\le 10^7$，我们规定满足以下性质的 $1\\sim n$（其中 $ 1\\le n \\le 10^7$） 的排列为“好排列”：\n\n$$\\forall k<i \\le n,~a_i > \\min\\{a_{i-k},a_{i-k+1},...,a_{i-1}\\}$$\n\n求好排列的个数。对 $998244353$ 取模。", "inputFormat": "一行，两个整数 $n,k$。", "outputFormat": "一行，为好排列的个数对 $998244353$ 取模的值。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P9824", "type": "P", "difficulty": 6, "samples": [["1\n1", "0"], ["2\n13 24", "26\n13\n0"], ["3\n6 4 7", "33\n21\n12\n8\n4\n0"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2020", "上海", "O2优化", "ICPC"], "title": "[ICPC 2020 Shanghai R] Fountains", "background": "", "description": "Suppose you and your teammate Mixsx will attend the Namomo Camp. The Namomo Camp will happen in $n$ consecutive days. We name the $i$-th day as day $i$ ($1\\le i\\le n$). The cost of day $i$ is $s_i$. \n\nUnfortunately, the schedule of the Namomo Camp conflicts with Mixsx's final exams. Mixsx has final exams every day between day $L$ and day $R$. The exact value of $L$ and $R$ have not been announced by his college so we assume that every pair of integers $L$ and $R$ satisfying $1\\le L\\le R\\le n$ will be chosen with probability $1/(n(n+1)/2)$. He decides to take all the exams and thus be absent from the Namomo Camp from day $L$ to day $R$. His $\\textit{loss}$ will be $\\sum_{i=L}^R s_i$ in this case. \n\nAs Mixsx's teammate, you want Mixsx to give up his final exams and come back to the Namomo Camp. You can prepare $k$ plans before $L$ and $R$ are announced. In the $i$-th plan ($1\\le i\\le k$), you shut the electricity off to his college every day from day $l_i$ to day $r_i$. You can choose the values of $l_i$ and $r_i$ as long as they are two integers satisfying $1\\le l_i\\le r_i\\le n$.\n\nOnce $L$ and $R$ are announced, you can choose a plan $x$ ($1\\le x\\le k$) such that $L\\le l_x\\le r_x\\le R$. Then Mixsx will come back to the Namomo Camp on every day from day $l_x$ to day $r_x$. His loss becomes $\\sum_{i=L}^R s_i-\\sum_{i=l_x}^{r_x} s_i$ in this case. You will choose a plan that minimizes Mixsx's loss. If no plan $x$ satisfies $L\\le l_x\\le r_x\\le R$, Mixsx will attend his final exams normally and his loss is $\\sum_{i=L}^R s_i$.\n\nPlease calculate the minimum possible expected loss $ans_k$ of Mixsx if you choose the $k$ plans optimally. Output $ans_k\\cdot n(n+1)/2$ for every $k$ from $1$ to $n(n+1)/2$.\n\nFormally, given a list of $n$ numbers $s_i$ $(1 \\leq i \\leq n)$, define a loss function $C(L, R) = \\sum_{i=L}^R s_i$. Given an integer $k$ ($1 \\leq k \\leq n (n + 1) / 2$), you should select $2k$ integers $l_1, \\ldots, l_k, r_1,\\ldots, r_k$ satisfying $1\\le l_i\\le r_i\\le n$ for all $1 \\leq i \\leq k$, such that\n\n$$\\sum_{1\\leq L\\leq  R\\leq n} \\left[C(L, R) - \\max_{1\\le i\\le k, L \\leq l_i \\leq r_i \\leq R} C(l_i, r_i) \\right]$$\n\n is minimized. ($\\max_{1\\le i\\le k, L \\leq l_i \\leq r_i \\leq R} C(l_i, r_i)$ is defined as $0$ if no $i$ satisfies $1\\le i\\le k$ and $L \\leq l_i \\leq r_i \\leq R$.) Output the minimized value for every integer $k$ in $[1, n(n + 1) / 2]$. ", "inputFormat": "The first line contains an integer $n~(1 \\leq n \\leq 9)$. The second line contains $n$ space separated integers $s_i~(1 \\leq s_i \\leq 10^9)$.", "outputFormat": "The output contains $n (n + 1) / 2$ integers in their own lines, the expectations when $k = 1, \\ldots, n (n + 1) / 2$ multiplied by $n (n + 1) / 2$. It can be shown that the results are always integers.", "hint": "For the first test case, we only need to consider the case $k = 1$. We can only choose $l_1=r_1=1$. Then the expected loss is $C(1, 1) - C(1, 1) = 0$ and the result is $0 \\times 1 \\times (2) / 2 = 0$.\n\nFor the third test case, consider the case when $k = 3$. We choose $l_1=r_1=1$, $l_2=r_2=3$ and $l_3=1, r_3=3$. The expected loss is $2$. And the result is $2 \\times 6 = 12$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Fountains", "background": "", "description": "Suppose you and your teammate Mixsx will attend the Namomo Camp. The Namomo Camp will happen in $n$ consecutive days. We name the $i$-th day as day $i$ ($1\\le i\\le n$). The cost of day $i$ is $s_i$. \n\nUnfortunately, the schedule of the Namomo Camp conflicts with Mixsx's final exams. Mixsx has final exams every day between day $L$ and day $R$. The exact value of $L$ and $R$ have not been announced by his college so we assume that every pair of integers $L$ and $R$ satisfying $1\\le L\\le R\\le n$ will be chosen with probability $1/(n(n+1)/2)$. He decides to take all the exams and thus be absent from the Namomo Camp from day $L$ to day $R$. His $\\textit{loss}$ will be $\\sum_{i=L}^R s_i$ in this case. \n\nAs Mixsx's teammate, you want Mixsx to give up his final exams and come back to the Namomo Camp. You can prepare $k$ plans before $L$ and $R$ are announced. In the $i$-th plan ($1\\le i\\le k$), you shut the electricity off to his college every day from day $l_i$ to day $r_i$. You can choose the values of $l_i$ and $r_i$ as long as they are two integers satisfying $1\\le l_i\\le r_i\\le n$.\n\nOnce $L$ and $R$ are announced, you can choose a plan $x$ ($1\\le x\\le k$) such that $L\\le l_x\\le r_x\\le R$. Then Mixsx will come back to the Namomo Camp on every day from day $l_x$ to day $r_x$. His loss becomes $\\sum_{i=L}^R s_i-\\sum_{i=l_x}^{r_x} s_i$ in this case. You will choose a plan that minimizes Mixsx's loss. If no plan $x$ satisfies $L\\le l_x\\le r_x\\le R$, Mixsx will attend his final exams normally and his loss is $\\sum_{i=L}^R s_i$.\n\nPlease calculate the minimum possible expected loss $ans_k$ of Mixsx if you choose the $k$ plans optimally. Output $ans_k\\cdot n(n+1)/2$ for every $k$ from $1$ to $n(n+1)/2$.\n\nFormally, given a list of $n$ numbers $s_i$ $(1 \\leq i \\leq n)$, define a loss function $C(L, R) = \\sum_{i=L}^R s_i$. Given an integer $k$ ($1 \\leq k \\leq n (n + 1) / 2$), you should select $2k$ integers $l_1, \\ldots, l_k, r_1,\\ldots, r_k$ satisfying $1\\le l_i\\le r_i\\le n$ for all $1 \\leq i \\leq k$, such that\n\n$$\\sum_{1\\leq L\\leq  R\\leq n} \\left[C(L, R) - \\max_{1\\le i\\le k, L \\leq l_i \\leq r_i \\leq R} C(l_i, r_i) \\right]$$\n\n is minimized. ($\\max_{1\\le i\\le k, L \\leq l_i \\leq r_i \\leq R} C(l_i, r_i)$ is defined as $0$ if no $i$ satisfies $1\\le i\\le k$ and $L \\leq l_i \\leq r_i \\leq R$.) Output the minimized value for every integer $k$ in $[1, n(n + 1) / 2]$. ", "inputFormat": "The first line contains an integer $n~(1 \\leq n \\leq 9)$. The second line contains $n$ space separated integers $s_i~(1 \\leq s_i \\leq 10^9)$.", "outputFormat": "The output contains $n (n + 1) / 2$ integers in their own lines, the expectations when $k = 1, \\ldots, n (n + 1) / 2$ multiplied by $n (n + 1) / 2$. It can be shown that the results are always integers.", "hint": "For the first test case, we only need to consider the case $k = 1$. We can only choose $l_1=r_1=1$. Then the expected loss is $C(1, 1) - C(1, 1) = 0$ and the result is $0 \\times 1 \\times (2) / 2 = 0$.\n\nFor the third test case, consider the case when $k = 3$. We choose $l_1=r_1=1$, $l_2=r_2=3$ and $l_3=1, r_3=3$. The expected loss is $2$. And the result is $2 \\times 6 = 12$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Fountains", "background": "", "description": "假设你和你的队友 Mixsx 将参加 Namomo 训练营。Namomo 训练营将持续 $n$ 天。我们将第 $i$ 天命名为第 $i$ 天（$1 \\le i \\le n$）。第 $i$ 天的费用为 $s_i$。\n\n不幸的是，Namomo 训练营的日程与 Mixsx 的期末考试冲突。Mixsx 在从第 $L$ 天到第 $R$ 天的每一天都有期末考试。他的大学尚未宣布 $L$ 和 $R$ 的确切值，因此我们假设每对整数 $L$ 和 $R$ 满足 $1 \\le L \\le R \\le n$ 的情况将以概率 $1/(n(n+1)/2)$ 被选择。他决定参加所有考试，因此将从第 $L$ 天到第 $R$ 天缺席 Namomo 训练营。在这种情况下，他的损失将是 $\\sum_{i=L}^R s_i$。\n\n作为 Mixsx 的队友，你希望 Mixsx 放弃他的期末考试并回到 Namomo 训练营。在 $L$ 和 $R$ 公布之前，你可以准备 $k$ 个计划。在第 $i$ 个计划中（$1 \\le i \\le k$），你每天从第 $l_i$ 天到第 $r_i$ 天关闭他的大学的电源。你可以选择 $l_i$ 和 $r_i$ 的值，只要它们是满足 $1 \\le l_i \\le r_i \\le n$ 的两个整数。\n\n一旦 $L$ 和 $R$ 被宣布，你可以选择一个计划 $x$（$1 \\le x \\le k$），使得 $L \\le l_x \\le r_x \\le R$。然后 Mixsx 将在从第 $l_x$ 天到第 $r_x$ 天的每一天回到 Namomo 训练营。在这种情况下，他的损失变为 $\\sum_{i=L}^R s_i - \\sum_{i=l_x}^{r_x} s_i$。你将选择一个计划以最小化 Mixsx 的损失。如果没有计划 $x$ 满足 $L \\le l_x \\le r_x \\le R$，Mixsx 将正常参加他的期末考试，他的损失是 $\\sum_{i=L}^R s_i$。\n\n请计算如果你选择 $k$ 个计划最优地，Mixsx 的最小可能期望损失 $ans_k$。输出每个从 $1$ 到 $n(n+1)/2$ 的 $k$ 的 $ans_k \\cdot n(n+1)/2$。\n\n形式上，给定一个 $n$ 个数字 $s_i$ 的列表（$1 \\leq i \\leq n$），定义损失函数 $C(L, R) = \\sum_{i=L}^R s_i$。给定一个整数 $k$（$1 \\leq k \\leq n(n+1)/2$），你应该选择 $2k$ 个整数 $l_1, \\ldots, l_k, r_1, \\ldots, r_k$ 满足对于所有 $1 \\leq i \\leq k$，$1 \\le l_i \\le r_i \\le n$，使得\n\n$$\\sum_{1 \\leq L \\leq R \\leq n} \\left[C(L, R) - \\max_{1 \\le i \\le k, L \\leq l_i \\leq r_i \\leq R} C(l_i, r_i) \\right]$$\n\n被最小化。（如果没有 $i$ 满足 $1 \\le i \\le k$ 且 $L \\leq l_i \\leq r_i \\leq R$，则 $\\max_{1 \\le i \\le k, L \\leq l_i \\leq r_i \\leq R} C(l_i, r_i)$ 定义为 $0$。）输出每个整数 $k$ 在 $[1, n(n+1)/2]$ 中的最小化值。", "inputFormat": "第一行包含一个整数 $n~(1 \\leq n \\leq 9)$。第二行包含 $n$ 个用空格分隔的整数 $s_i~(1 \\leq s_i \\leq 10^9)$。", "outputFormat": "输出包含 $n(n+1)/2$ 个整数，每个整数占一行，表示当 $k = 1, \\ldots, n(n+1)/2$ 时的期望值乘以 $n(n+1)/2$。可以证明结果总是整数。", "hint": "对于第一个测试用例，我们只需要考虑 $k = 1$ 的情况。我们只能选择 $l_1 = r_1 = 1$。然后期望损失是 $C(1, 1) - C(1, 1) = 0$，结果是 $0 \\times 1 \\times (2) / 2 = 0$。\n\n对于第三个测试用例，考虑 $k = 3$ 的情况。我们选择 $l_1 = r_1 = 1$，$l_2 = r_2 = 3$ 和 $l_3 = 1, r_3 = 3$。期望损失是 $2$。结果是 $2 \\times 6 = 12$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9825", "type": "P", "difficulty": 2, "samples": [["3", "2"], ["10", "24"], ["100", "2739"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2020", "数论", "上海", "O2优化", "ICPC"], "title": "[ICPC 2020 Shanghai R] Fibonacci", "background": "", "description": "In mathematics, the Fibonacci numbers, commonly denoted as $f_n$, is a sequence such that each number is the sum of the two preceding numbers, starting with $1$ and $1$. That is, $f_1 = 1, f_2 = 1$ and $f_n = f_{n-2} + f_{n-1}~(n \\ge 3)$.\n\nThus, the beginning of the sequence is $1, 1, 2, 3, 5, 8, 13, 21,\\ldots$ .\n\nGiven $n$, please calculate $\\sum_{i=1}^{n}{\\sum_{j=i+1}^{n}{g(f_i,f_j)}}$, where $g(x,y) = 1$ when $x \\cdot y$ is even, otherwise $g(x,y) = 0$.", "inputFormat": "The only line contains one integer $n~(1\\le n\\le 10^9)$.", "outputFormat": "Output one number -- $\\sum_{i=1}^{n}{\\sum_{j=i+1}^{n}{g(f_i,f_j)}}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Fibonacci", "background": "", "description": "In mathematics, the Fibonacci numbers, commonly denoted as $f_n$, is a sequence such that each number is the sum of the two preceding numbers, starting with $1$ and $1$. That is, $f_1 = 1, f_2 = 1$ and $f_n = f_{n-2} + f_{n-1}~(n \\ge 3)$.\n\nThus, the beginning of the sequence is $1, 1, 2, 3, 5, 8, 13, 21,\\ldots$ .\n\nGiven $n$, please calculate $\\sum_{i=1}^{n}{\\sum_{j=i+1}^{n}{g(f_i,f_j)}}$, where $g(x,y) = 1$ when $x \\cdot y$ is even, otherwise $g(x,y) = 0$.", "inputFormat": "The only line contains one integer $n~(1\\le n\\le 10^9)$.", "outputFormat": "Output one number -- $\\sum_{i=1}^{n}{\\sum_{j=i+1}^{n}{g(f_i,f_j)}}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Fibonacci", "background": "", "description": "在数学中，斐波那契数列通常用 $f_n$ 表示，是一个序列，其中每个数字是前两个数字之和，起始为 $1$ 和 $1$。即 $f_1 = 1, f_2 = 1$，且 $f_n = f_{n-2} + f_{n-1}~(n \\ge 3)$。\n\n因此，该序列的开头是 $1, 1, 2, 3, 5, 8, 13, 21,\\ldots$。\n\n给定 $n$，请计算 $\\sum_{i=1}^{n}{\\sum_{j=i+1}^{n}{g(f_i,f_j)}}$，其中 $g(x,y) = 1$ 当 $x \\cdot y$ 为偶数时，否则 $g(x,y) = 0$。", "inputFormat": "唯一一行包含一个整数 $n~(1\\le n\\le 10^9)$。", "outputFormat": "输出一个数字 -- $\\sum_{i=1}^{n}{\\sum_{j=i+1}^{n}{g(f_i,f_j)}}$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9826", "type": "P", "difficulty": 5, "samples": [["1\n4 2\n0 3\n1 2", "2"], ["1\n14 5\n0 12 13 8 9\n9 2 6 13 5", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "贪心", "2020", "上海", "O2优化", "ICPC"], "title": "[ICPC 2020 Shanghai R] Rice Arrangement", "background": "", "description": "Wowo is a hospitable Xinjiang uncle. $k$ guests will have Uyghur Polo (a traditional Uyghur food) in Wowo's house around a big round table. $n$ ($n\\ge k$) chairs are placed around the table uniformly. Each guest sits on a chair and no two guests sit on the same chair. $k$ bowls of Uyghur Polo are on the table. Each bowl is next to some chair ($\\textbf{with or without}$ some guest sitting on it). No two bowls locate at the same position.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q3gqhsvq.png)\n\nAs a waiter, you are supposed to assign each person with exactly one bowl of Uyghur Polo. The table can be rotated, so each time you can turn it $\\frac{2\\pi}{n}$ degrees clockwise or counterclockwise. The bowls turn with the table while the chairs and guests do not move. When one bowl of Uyghur Polo is in front of a guest, he can either take it or wait for another.\n\nYou want to minimize the total times of table rotating so that everybody can have meals as quickly as possible.\n\n(Formal definition: The boundary of the table is a circle. $n$ chairs are at $n$ points on the circle whose convex hull is a regular polygon with $n$ vertices. We name the points $0,\\ldots, n-1$ in counterclockwise order. The $i$-th bowl is at point $b_i$ ($0\\le b_i<n$) initially. The $i$-th guest is at point $a_i$ ($0\\le a_i < n$) initially. If you turn the table counterclockwise, the bowl at point $b_i$ ($1\\le i\\le k$) will be moved to point $(b_i+ 1) \\bmod n$ after the rotation. If you turn the table clockwise, the bowl at point $b_i$ ($1\\le i\\le k$) will be moved to point $(b_i-1) \\bmod n$ after the rotation. ($x\\bmod n$ is defined as the smallest nonnegative integer $r$ such that $x-r$ is a multiple of $n$.))\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n,k$ ($1\\le n \\le 10^9,1 \\le k \\le \\min(n,1000)$) indicating the size of the table and the number of persons and bowls of Uyghur Polo. \n\nIn the second line, there are $k$ integers $a_1,a_2,\\dots,a_k$ ($0 \\le a_i < n$), indicating the positions of the persons. No two guests share the same position.\n\nIn the third line, there are $k$ integers $b_1,b_2,\\dots,b_k$ ($0 \\le b_i < n$), indicating the initial positions of the bowls. No two bowls of Uyghur Polo locate at the same position.\n\nIt is guaranteed that the sum of $k$ over all test cases does not exceed $5000$.", "outputFormat": "For each test case, output the minimal total times of rotations such that each guest can have exactly one bowl of Uyghur Polo.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Rice Arrangement", "background": "", "description": "Wowo is a hospitable Xinjiang uncle. $k$ guests will have Uyghur Polo (a traditional Uyghur food) in Wowo's house around a big round table. $n$ ($n\\ge k$) chairs are placed around the table uniformly. Each guest sits on a chair and no two guests sit on the same chair. $k$ bowls of Uyghur Polo are on the table. Each bowl is next to some chair ($\\textbf{with or without}$ some guest sitting on it). No two bowls locate at the same position.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q3gqhsvq.png)\n\nAs a waiter, you are supposed to assign each person with exactly one bowl of Uyghur Polo. The table can be rotated, so each time you can turn it $\\frac{2\\pi}{n}$ degrees clockwise or counterclockwise. The bowls turn with the table while the chairs and guests do not move. When one bowl of Uyghur Polo is in front of a guest, he can either take it or wait for another.\n\nYou want to minimize the total times of table rotating so that everybody can have meals as quickly as possible.\n\n(Formal definition: The boundary of the table is a circle. $n$ chairs are at $n$ points on the circle whose convex hull is a regular polygon with $n$ vertices. We name the points $0,\\ldots, n-1$ in counterclockwise order. The $i$-th bowl is at point $b_i$ ($0\\le b_i<n$) initially. The $i$-th guest is at point $a_i$ ($0\\le a_i < n$) initially. If you turn the table counterclockwise, the bowl at point $b_i$ ($1\\le i\\le k$) will be moved to point $(b_i+ 1) \\bmod n$ after the rotation. If you turn the table clockwise, the bowl at point $b_i$ ($1\\le i\\le k$) will be moved to point $(b_i-1) \\bmod n$ after the rotation. ($x\\bmod n$ is defined as the smallest nonnegative integer $r$ such that $x-r$ is a multiple of $n$.))\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n,k$ ($1\\le n \\le 10^9,1 \\le k \\le \\min(n,1000)$) indicating the size of the table and the number of persons and bowls of Uyghur Polo. \n\nIn the second line, there are $k$ integers $a_1,a_2,\\dots,a_k$ ($0 \\le a_i < n$), indicating the positions of the persons. No two guests share the same position.\n\nIn the third line, there are $k$ integers $b_1,b_2,\\dots,b_k$ ($0 \\le b_i < n$), indicating the initial positions of the bowls. No two bowls of Uyghur Polo locate at the same position.\n\nIt is guaranteed that the sum of $k$ over all test cases does not exceed $5000$.", "outputFormat": "For each test case, output the minimal total times of rotations such that each guest can have exactly one bowl of Uyghur Polo.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Rice Arrangement", "background": null, "description": "Wowo 是一位好客的新疆大叔。$k$ 位客人将在 Wowo 家中围着一张大圆桌享用维吾尔抓饭（一种传统的维吾尔食物）。圆桌周围均匀地放置了 $n$ 把椅子（$n \\ge k$）。每位客人坐在一把椅子上，并且没有两位客人坐在同一把椅子上。桌子上有 $k$ 碗维吾尔抓饭。每碗抓饭都放在某把椅子旁边（**无论是否**有客人坐在上面）。没有两碗抓饭放在同一位置。\n\n作为服务员，你需要为每个人分配一碗维吾尔抓饭。桌子可以旋转，因此每次你可以顺时针或逆时针旋转 $\\frac{2\\pi}{n}$ 度。碗会随着桌子一起旋转，而椅子和客人不动。当一碗维吾尔抓饭在某位客人面前时，他可以选择拿起它或等待另一碗。\n\n你希望尽量减少桌子旋转的总次数，以便每个人都能尽快用餐。\n\n（正式定义：桌子的边界是一个圆。$n$ 把椅子位于圆上的 $n$ 个点，其凸包是一个有 $n$ 个顶点的正多边形。我们按逆时针顺序将这些点命名为 $0,\\ldots, n-1$。第 $i$ 碗抓饭最初位于点 $b_i$ ($0\\le b_i<n$)。第 $i$ 位客人最初位于点 $a_i$ ($0\\le a_i < n$)。如果你逆时针旋转桌子，位于点 $b_i$ ($1\\le i\\le k$) 的碗将在旋转后移动到点 $(b_i+ 1) \\bmod n$。如果你顺时针旋转桌子，位于点 $b_i$ ($1\\le i\\le k$) 的碗将在旋转后移动到点 $(b_i-1) \\bmod n$。($x\\bmod n$ 定义为最小的非负整数 $r$ 使得 $x-r$ 是 $n$ 的倍数。)）", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含两个整数 $n,k$ ($1\\le n \\le 10^9,1 \\le k \\le \\min(n,1000)$)，表示桌子的大小以及人数和维吾尔抓饭的碗数。\n\n第二行有 $k$ 个整数 $a_1,a_2,\\dots,a_k$ ($0 \\le a_i < n$)，表示客人的位置。没有两位客人共享同一位置。\n\n第三行有 $k$ 个整数 $b_1,b_2,\\dots,b_k$ ($0 \\le b_i < n$)，表示碗的初始位置。没有两碗维吾尔抓饭放在同一位置。\n\n保证所有测试用例中 $k$ 的总和不超过 $5000$。", "outputFormat": "对于每个测试用例，输出使得每位客人能恰好得到一碗维吾尔抓饭的最小旋转总次数。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9827", "type": "P", "difficulty": 4, "samples": [["1 2", "14.2831853072"], ["2 3", "175.4159265359"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "数学", "2020", "上海", "Special Judge", "O2优化", "ICPC"], "title": "[ICPC 2020 Shanghai R] Sky Garden", "background": "", "description": "Prof. Du and Prof. Pang plan to build a sky garden near the city of Allin. In the garden, there will be a plant maze consisting of straight and circular roads.\n\nOn the blueprint of the plant maze, Prof. Du draws $n$ circles indicating the circular roads. All of them have center $(0, 0)$. The radius of the $i$-th circle is $i$.\n\nMeanwhile, Prof. Pang draws $m$ lines on the blueprint indicating the straight roads. All of the lines pass through $(0, 0)$. Each circle is divided into $2m$ parts with equal lengths by these lines.\n\nLet $Q$ be the set of the $n+m$ roads. Let $P$ be the set of all intersections of two different roads in $Q$. Note that each circular road and each straight road have two intersections.\n\nFor two different points $a\\in P$ and $b\\in P$, we define $dis(\\{a, b\\})$ to be the shortest distance one needs to walk from $a$ to $b$ along the roads. Please calculate the sum of $dis(\\{a, b\\})$ for all $\\{a, b\\}\\subseteq P$. ", "inputFormat": "The only line contains two integers $n,m~(1\\le n,m\\le 500)$.", "outputFormat": "Output one number -- the sum of the distances between every pair of points in $P$.\n\nYour answer is considered correct if its absolute or relative error does not exceed $10^{-6}$.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/81sxvtcp.png)\n\n$dis(p_1, p_2)=dis(p_2, p_3)=dis(p_3, p_4)=dis(p_1, p_4)=\\frac{\\pi}{2}$\n\n$dis(p_1, p_5)=dis(p_2, p_5)=dis(p_3, p_5)=dis(p_4, p_5)=1$\n\n$dis(p_1, p_3)=dis(p_2, p_4)=2$", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Sky Garden", "background": "", "description": "Prof. Du and Prof. Pang plan to build a sky garden near the city of Allin. In the garden, there will be a plant maze consisting of straight and circular roads.\n\nOn the blueprint of the plant maze, Prof. Du draws $n$ circles indicating the circular roads. All of them have center $(0, 0)$. The radius of the $i$-th circle is $i$.\n\nMeanwhile, Prof. Pang draws $m$ lines on the blueprint indicating the straight roads. All of the lines pass through $(0, 0)$. Each circle is divided into $2m$ parts with equal lengths by these lines.\n\nLet $Q$ be the set of the $n+m$ roads. Let $P$ be the set of all intersections of two different roads in $Q$. Note that each circular road and each straight road have two intersections.\n\nFor two different points $a\\in P$ and $b\\in P$, we define $dis(\\{a, b\\})$ to be the shortest distance one needs to walk from $a$ to $b$ along the roads. Please calculate the sum of $dis(\\{a, b\\})$ for all $\\{a, b\\}\\subseteq P$. ", "inputFormat": "The only line contains two integers $n,m~(1\\le n,m\\le 500)$.", "outputFormat": "Output one number -- the sum of the distances between every pair of points in $P$.\n\nYour answer is considered correct if its absolute or relative error does not exceed $10^{-6}$.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/81sxvtcp.png)\n\n$dis(p_1, p_2)=dis(p_2, p_3)=dis(p_3, p_4)=dis(p_1, p_4)=\\frac{\\pi}{2}$\n\n$dis(p_1, p_5)=dis(p_2, p_5)=dis(p_3, p_5)=dis(p_4, p_5)=1$\n\n$dis(p_1, p_3)=dis(p_2, p_4)=2$", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Sky Garden", "background": "", "description": "杜教授和庞教授计划在 Allin 市附近建造一个空中花园。在花园中，将有一个由直路和环形路组成的植物迷宫。\n\n在植物迷宫的蓝图上，杜教授画了 $n$ 个圆，表示环形路。所有圆的圆心都是 $(0, 0)$。第 $i$ 个圆的半径是 $i$。\n\n同时，庞教授在蓝图上画了 $m$ 条直线，表示直路。所有的直线都经过 $(0, 0)$。每个圆被这些直线等分成 $2m$ 个部分。\n\n设 $Q$ 为 $n+m$ 条道路的集合。设 $P$ 为 $Q$ 中两条不同道路的所有交点的集合。注意，每条环形路和每条直路都有两个交点。\n\n对于两个不同的点 $a \\in P$ 和 $b \\in P$，我们定义 $dis(\\{a, b\\})$ 为沿着道路从 $a$ 到 $b$ 需要走的最短距离。请计算对于所有 $\\{a, b\\} \\subseteq P$ 的 $dis(\\{a, b\\})$ 的和。", "inputFormat": "唯一一行包含两个整数 $n,m~(1\\le n,m\\le 500)$。", "outputFormat": "输出一个数字——$P$ 中每对点之间距离的总和。\n\n你的答案被认为是正确的，如果其绝对误差或相对误差不超过 $10^{-6}$。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/81sxvtcp.png)\n\n$dis(p_1, p_2)=dis(p_2, p_3)=dis(p_3, p_4)=dis(p_1, p_4)=\\frac{\\pi}{2}$\n\n$dis(p_1, p_5)=dis(p_2, p_5)=dis(p_3, p_5)=dis(p_4, p_5)=1$\n\n$dis(p_1, p_3)=dis(p_2, p_4)=2$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9828", "type": "P", "difficulty": 7, "samples": [["3\n0 1 0 1 0 1\n10 11 10 11 10 11\n999999999 1000000000 999999999 1000000000 999999999 1000000000", "YES\n0 10 999999999"], ["4\n0 1 0 1 0 1\n999999999 1000000000 0 1 0 1\n0 1 999999999 1000000000 0 1\n0 1 0 1 999999999 1000000000", "YES\n0 0 0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "线段树", "上海", "Special Judge", "O2优化", "ICPC"], "title": "[ICPC 2020 Shanghai R] Octasection", "background": "", "description": "\nAt the Namomo Camp, a cute volunteer celebrates her birthday. Wowo buys her a huge cake. (The cake is so big that it has a 3D coordinate system inside.) There are $n$ cuboid shaped pieces of chocolates $\\textbf{in}$ the cake. The $i$-th ($1\\le i\\le n$) chocolate consists of all points $(x,y,z)$ such that $min\\_x[i]\\le x\\le max\\_x[i], min\\_y[i]\\le y\\le max\\_y[i], min\\_z[i]\\le z\\le max\\_z[i]$. $min\\_x,max\\_x, min\\_y,max\\_y, min\\_z, max\\_z$ are $6$ arrays of integers. Chocolates may overlap or touch each other.\n\nThe volunteer wants to distribute the cake to the campers of the Namomo Camp. To show off his knife skill, Wowo decides to cut the cake into pieces by exactly $3$ cuts such that:\n\n- The first cut is a plane whose equation is $x=a$ for some integer $a$ decided by Wowo.\n- The second cut is a plane whose equation is $y=b$ for some integer $b$ decided by Wowo.\n- The third cut is a plane whose equation is $z=c$ for some integer $c$ decided by Wowo.\n- Each chocolate is $\\textbf{touched}$ by at least one cut (i.e. each cuboid has a nonempty intersection with at least one plane).\n\nDecide whether Wowo can cut the cake under the rules. If the answer is yes, output any possible solution.", "inputFormat": "The first line contains a single integer $n$ ($1\\le n\\le 100000$).\n\nThe $i$-th line of the next $n$ lines contains $6$ integers $min\\_x[i],max\\_x[i], min\\_y[i],max\\_y[i], min\\_z[i], max\\_z[i]$ ($-10^9\\le min\\_x[i],max\\_x[i], min\\_y[i],max\\_y[i], min\\_z[i], max\\_z[i]\\le 10^9$, $min\\_x[i]<max\\_x[i]$, $min\\_y[i]<max\\_y[i]$, $min\\_z[i]< max\\_z[i]$).", "outputFormat": "If Wowo can cut the cake under the rules, the first line of the output should contain ``YES`` and the second line should contain $3$ integers $a$, $b$ and $c$ ($-10^9\\le a, b, c\\le 10^9$). If Wowo cannot cut the cake under the rules, output only one line containing ``NO``.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Octasection", "background": "", "description": "\nAt the Namomo Camp, a cute volunteer celebrates her birthday. Wowo buys her a huge cake. (The cake is so big that it has a 3D coordinate system inside.) There are $n$ cuboid shaped pieces of chocolates $\\textbf{in}$ the cake. The $i$-th ($1\\le i\\le n$) chocolate consists of all points $(x,y,z)$ such that $min\\_x[i]\\le x\\le max\\_x[i], min\\_y[i]\\le y\\le max\\_y[i], min\\_z[i]\\le z\\le max\\_z[i]$. $min\\_x,max\\_x, min\\_y,max\\_y, min\\_z, max\\_z$ are $6$ arrays of integers. Chocolates may overlap or touch each other.\n\nThe volunteer wants to distribute the cake to the campers of the Namomo Camp. To show off his knife skill, Wowo decides to cut the cake into pieces by exactly $3$ cuts such that:\n\n- The first cut is a plane whose equation is $x=a$ for some integer $a$ decided by Wowo.\n- The second cut is a plane whose equation is $y=b$ for some integer $b$ decided by Wowo.\n- The third cut is a plane whose equation is $z=c$ for some integer $c$ decided by Wowo.\n- Each chocolate is $\\textbf{touched}$ by at least one cut (i.e. each cuboid has a nonempty intersection with at least one plane).\n\nDecide whether Wowo can cut the cake under the rules. If the answer is yes, output any possible solution.", "inputFormat": "The first line contains a single integer $n$ ($1\\le n\\le 100000$).\n\nThe $i$-th line of the next $n$ lines contains $6$ integers $min\\_x[i],max\\_x[i], min\\_y[i],max\\_y[i], min\\_z[i], max\\_z[i]$ ($-10^9\\le min\\_x[i],max\\_x[i], min\\_y[i],max\\_y[i], min\\_z[i], max\\_z[i]\\le 10^9$, $min\\_x[i]<max\\_x[i]$, $min\\_y[i]<max\\_y[i]$, $min\\_z[i]< max\\_z[i]$).", "outputFormat": "If Wowo can cut the cake under the rules, the first line of the output should contain ``YES`` and the second line should contain $3$ integers $a$, $b$ and $c$ ($-10^9\\le a, b, c\\le 10^9$). If Wowo cannot cut the cake under the rules, output only one line containing ``NO``.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Octasection", "background": "", "description": "在 Namomo 营地，一位可爱的志愿者庆祝她的生日。Wowo 给她买了一个巨大的蛋糕。（蛋糕大到里面有一个三维坐标系。）蛋糕中有 $n$ 块长方体形状的巧克力。第 $i$ 块巧克力（$1 \\le i \\le n$）包含所有满足 $min\\_x[i] \\le x \\le max\\_x[i], min\\_y[i] \\le y \\le max\\_y[i], min\\_z[i] \\le z \\le max\\_z[i]$ 的点 $(x,y,z)$。$min\\_x, max\\_x, min\\_y, max\\_y, min\\_z, max\\_z$ 是 $6$ 个整数数组。巧克力可能会重叠或接触。\n\n志愿者想要将蛋糕分给 Namomo 营地的露营者。为了展示他的刀工，Wowo 决定通过恰好 $3$ 刀将蛋糕切成几块，使得：\n\n- 第一刀是一个方程为 $x=a$ 的平面，其中 $a$ 是 Wowo 决定的某个整数。\n- 第二刀是一个方程为 $y=b$ 的平面，其中 $b$ 是 Wowo 决定的某个整数。\n- 第三刀是一个方程为 $z=c$ 的平面，其中 $c$ 是 Wowo 决定的某个整数。\n- 每块巧克力至少被一刀“碰到”（即每个长方体与至少一个平面有非空交集）。\n\n判断 Wowo 是否可以按照规则切蛋糕。如果答案是肯定的，输出任意一个可能的解决方案。", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 100000$）。\n\n接下来的 $n$ 行中，第 $i$ 行包含 $6$ 个整数 $min\\_x[i], max\\_x[i], min\\_y[i], max\\_y[i], min\\_z[i], max\\_z[i]$（$-10^9 \\le min\\_x[i], max\\_x[i], min\\_y[i], max\\_y[i], min\\_z[i], max\\_z[i] \\le 10^9$，$min\\_x[i] < max\\_x[i]$，$min\\_y[i] < max\\_y[i]$，$min\\_z[i] < max\\_z[i]$）。", "outputFormat": "如果 Wowo 可以按照规则切蛋糕，输出的第一行应为 \"YES\"，第二行应包含 $3$ 个整数 $a$，$b$ 和 $c$（$-10^9 \\le a, b, c \\le 10^9$）。如果 Wowo 不能按照规则切蛋糕，只需输出一行 \"NO\"。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9829", "type": "P", "difficulty": 6, "samples": [["2\n4 4\nLHLH\n0 1\n1 2\n1 3\n2 3\n3 3\nLHH\n0 1\n0 2\n1 2", "yes\nno"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "上海", "O2优化", "双连通分量", "最近公共祖先 LCA", "ICPC"], "title": "[ICPC 2020 Shanghai R] Traveling Merchant", "background": null, "description": "Mr. Lawrence is a traveling merchant who travels between cities and resells products. Basically, to earn from it, he needs to buy products at a very low price and sell them at a higher price. Your task is to tell him whether there exists an endless traveling path that can earn money all the time.\n\nTo make things simple, suppose there are $n$ cities named from $0$ to $n-1$ and $m$ undirected roads each of which connecting two cities. Mr. Lawrence can travel between cities along the roads. Initially he is located at city $0$ and each of the city $i$ has a starting price $c_i$, either $\\text{Low}$ or $\\text{High}$. Due to the law of markets, the price status at city $i$ will change (i.e. $\\text{High}$ price will become $\\text{Low}$ price, or vice versa) after he departs for a neighboring city $j$ from $i$. (City $j$ is a neighboring city of city $i$ when one of the $m$ roads connects city $i$ and city $j$.) For some reasons (e.g. product freshness, traveling fee, tax), he $\\textbf{must}$:\n\n- Start at city $0$ and buy products at city $0$. It is guaranteed that $c_0$ is $\\text{Low}$.\n- When he arrives some city, he either sells products or buys products. It is not allowed for him to do nothing before he leaves the city.\n- After buying products at some city $i$, he must travel to some neighboring city $j$ whose price $c_j$ is $\\text{High}$ and sell the products at city $j$.\n- After selling products at some city $i$, he must travel to some neighboring city $j$ whose price $c_j$ is $\\text{Low}$ and buy the products at city $j$.\n\nAs a result, the path will look like an alternation between ``buy at low price`` and ``sell at high price``.\n\nAn endless earning path is defined as a path consisting of an endless sequence of cities $p_0, p_1,\\dots$ where city $p_i$ and city $p_{i+1}$ has a road, $p_0=0$, and the price alternates, in other words $c_{p_{2k}}=\\text{Low}$ (indicates a buy-in) and $c_{p_{2k+1}}=\\text{High}$ (indicates a sell-out) for $k\\geq0$. Please note here $c_{p_i}$ is the price when $\\textbf{arriving}$ city $p_i$ and this value may be different when he arrives the second time.\n\nYour task is to determine whether there exists any such path.", "inputFormat": "There are several test cases. The first line contains a positive integer $T$ indicating the number of test cases. Each test case begins with two positive integers $n$ and $m$ indicating the number of cities and the number of roads. \n\nThe next line is a string $c$ of length $n$ containing `H` or `L`. The $i$-th ($0\\le i<n$) charactor of $c$ is $H$ if the starting price $c_i$ at city $i$ is $\\text{High}$. The $i$-th ($0\\le i<n$) charactor of $c$ is $L$ if the starting price $c_i$ at city $i$ is $\\text{Low}$. \n\nThe $i$-th line ($1\\le i\\le m$) of the following $m$ lines contains two different cities $u_i$ and $v_i$, indicating a road between $u_i$ and $v_i$.\n\nThe sum of the values of $n$ over all test cases is no more than $200,000$. The sum of the values of $m$ over all test cases is no more than $200,000$. For each test case, $c_i\\in\\{\\text{H},\\text{L}\\}$ holds for each $i\\in \\{0, \\ldots, n-1\\}$. $c_0$ is always $L$. $0\\leq u_i,v_i<n$ and $u_i\\neq v_i$ hold for each $i\\in \\{1,\\ldots, m\\}$. No two roads connect the same pair of cities.", "outputFormat": "For each test case, output a line of ``yes`` or ``no``, indicating whether there exists an endless earning path.", "hint": "In the first sample test case, the endless earning path is $0\\rightarrow 1\\rightarrow 2\\rightarrow 3\\rightarrow 1\\rightarrow 2\\rightarrow 3\\rightarrow \\dots$. In the illustration, cities with $\\text{Low}$ price are filled with stripe.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2ohq2wfi.png)\n\nIn the second sample test case, Mr. Lawrence can only make one move from city $0$ and after that all cities will have $\\text{High}$ price. Thus, no further moves can be made.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fcv1tw87.png)", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Traveling Merchant", "background": null, "description": "Mr. Lawrence is a traveling merchant who travels between cities and resells products. Basically, to earn from it, he needs to buy products at a very low price and sell them at a higher price. Your task is to tell him whether there exists an endless traveling path that can earn money all the time.\n\nTo make things simple, suppose there are $n$ cities named from $0$ to $n-1$ and $m$ undirected roads each of which connecting two cities. Mr. Lawrence can travel between cities along the roads. Initially he is located at city $0$ and each of the city $i$ has a starting price $c_i$, either $\\text{Low}$ or $\\text{High}$. Due to the law of markets, the price status at city $i$ will change (i.e. $\\text{High}$ price will become $\\text{Low}$ price, or vice versa) after he departs for a neighboring city $j$ from $i$. (City $j$ is a neighboring city of city $i$ when one of the $m$ roads connects city $i$ and city $j$.) For some reasons (e.g. product freshness, traveling fee, tax), he $\\textbf{must}$:\n\n- Start at city $0$ and buy products at city $0$. It is guaranteed that $c_0$ is $\\text{Low}$.\n- When he arrives some city, he either sells products or buys products. It is not allowed for him to do nothing before he leaves the city.\n- After buying products at some city $i$, he must travel to some neighboring city $j$ whose price $c_j$ is $\\text{High}$ and sell the products at city $j$.\n- After selling products at some city $i$, he must travel to some neighboring city $j$ whose price $c_j$ is $\\text{Low}$ and buy the products at city $j$.\n\nAs a result, the path will look like an alternation between ``buy at low price`` and ``sell at high price``.\n\nAn endless earning path is defined as a path consisting of an endless sequence of cities $p_0, p_1,\\dots$ where city $p_i$ and city $p_{i+1}$ has a road, $p_0=0$, and the price alternates, in other words $c_{p_{2k}}=\\text{Low}$ (indicates a buy-in) and $c_{p_{2k+1}}=\\text{High}$ (indicates a sell-out) for $k\\geq0$. Please note here $c_{p_i}$ is the price when $\\textbf{arriving}$ city $p_i$ and this value may be different when he arrives the second time.\n\nYour task is to determine whether there exists any such path.", "inputFormat": "There are several test cases. The first line contains a positive integer $T$ indicating the number of test cases. Each test case begins with two positive integers $n$ and $m$ indicating the number of cities and the number of roads. \n\nThe next line is a string $c$ of length $n$ containing `H` or `L`. The $i$-th ($0\\le i<n$) charactor of $c$ is $H$ if the starting price $c_i$ at city $i$ is $\\text{High}$. The $i$-th ($0\\le i<n$) charactor of $c$ is $L$ if the starting price $c_i$ at city $i$ is $\\text{Low}$. \n\nThe $i$-th line ($1\\le i\\le m$) of the following $m$ lines contains two different cities $u_i$ and $v_i$, indicating a road between $u_i$ and $v_i$.\n\nThe sum of the values of $n$ over all test cases is no more than $200,000$. The sum of the values of $m$ over all test cases is no more than $200,000$. For each test case, $c_i\\in\\{\\text{H},\\text{L}\\}$ holds for each $i\\in \\{0, \\ldots, n-1\\}$. $c_0$ is always $L$. $0\\leq u_i,v_i<n$ and $u_i\\neq v_i$ hold for each $i\\in \\{1,\\ldots, m\\}$. No two roads connect the same pair of cities.", "outputFormat": "For each test case, output a line of ``yes`` or ``no``, indicating whether there exists an endless earning path.", "hint": "In the first sample test case, the endless earning path is $0\\rightarrow 1\\rightarrow 2\\rightarrow 3\\rightarrow 1\\rightarrow 2\\rightarrow 3\\rightarrow \\dots$. In the illustration, cities with $\\text{Low}$ price are filled with stripe.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2ohq2wfi.png)\n\nIn the second sample test case, Mr. Lawrence can only make one move from city $0$ and after that all cities will have $\\text{High}$ price. Thus, no further moves can be made.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fcv1tw87.png)", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Traveling Merchant", "background": null, "description": "劳伦斯先生是一位在不同城市转售商品的旅行商人。基本地，为了赚钱，他需要以低价买进商品，再以高价卖出。现在请你为他规划一条可以一直盈利的旅行路线。\n\n简单地说，假设有 $n$ 座城市，标号为 $0$ 到 $n-1$ ，以及 $m$ 条连接特定两座城市的路，劳伦斯先生可以通过这些路到访每座城市。最初劳伦斯先生位于第 $0$ 座城市，并且对于城市 $i$ 都有一个起始价格 $c_i$ 。根据市场规律，当他从城市 $i$ 来到相邻的城市 $j$ 时（当且仅当城市 $i$ 与城市 $j$ 之间有路径相连时，才称 $i$ 与 $j$ 为相邻城市），城市 $i$ 的价格状况会发生变化（高价会变成低价，反之亦然）。而因为一些原因（比如商品的新鲜程度，旅行费用，税务等），他**必须**：\n\n- 从城市 $0$ 出发并在城市 $0$ 购买一些商品。保证城市 $0$ 的起始价格很**低**。\n- 每当他到达一座城市后，他**必须**售卖**或**购买一些商品。\n- 若他在城市 $i$ 购买了商品，他就必须去一座与 $i$ 相邻且价格 $c_j$ **高于** $c_i$ 的城市 $j$ ，并在那里卖掉手中来自城市 $i$ 的商品。\n- 若他在城市 $i$ 售卖了商品，他就必须去一座与 $i$ 相邻且价格 $c_j$ **低于** $c_i$ 的城市 $j$，并在那里购买一些商品。\n\n\n因此，最终路径会始终重复 ``低价购入`` 和 ``高价卖出`` 。\n\n一条无尽的盈利路线由无尽的城市序列 $p_0,p_1 \\dots$ 组成。其中，城市 $p_i$ 与城市 $p_{i+1}$ 之间有路径相连，$p_0 = 0$，且价格高低是交替循环的，也就是说当 $k \\ge 0$ 时，城市 $p_{2k}$ 的价格 $c_{p_{2k}} = \\text{Low}$ (要在这个城市购买商品) 而相邻城市 $p_{2k+1}$ 的价格 $c_{p_{2k+1}} = \\text{High}$ (要在这个城市卖出商品)。\n\n**注意**：$c_{p_i}$ 是 **到达** 城市 $p_i$ 时的价格，而当他第二次到达城市 $p_i$ 时，这个价格可能会因为市场规律而变化。\n\n你需要写一个程序，判断是否有这样一条永远盈利的路径存在。", "inputFormat": "输入有多组数据。所有数据的第一行是一个整型 $T$ 表示数据组数。每组数据的第一行是两个整型 $n$ 和 $m$，表示城市的数量和道路的数量。\n\n每组数据的第二行是一个长度为 $n$ ，由 $H$ 或 $L$ 组成的字符串 $c$ 。字符串 $c$ 的第 $i$ 个字符若为 $H$，则表示城市 $i$ 的起始价格 $c_i$ **高**，反之若为 $L$ 则表示城市 $i$ 的起始价格 $c_i$ **低**。\n\n接下来 $m$ 行，每行输入一组 $u_i$ 和 $v_i$ ，表示一条连接城市 $u_i$ 和城市 $v_i$ 的双向路径。\n\n所有数据中 $n$ 的总和不超过 $200,000$ ，$m$ 的总和也不超过 $200,000$ 。对于每组数据，$c_i\\in\\{\\text{H}, \\text{L}\\}$ 对应每个 $i\\in\\{0, \\dots, n-1\\}$ ，保证 $c_0$ 总为 $L$ 。保证对于每个 $i\\in\\{1,\\dots,m\\}$ ，都有 $0 \\leq u_i,v_i < n$ 且 $u_i \\neq v_i$ 。保证每两座城市之间只有一条路径相连。", "outputFormat": "对于每组数据，输出一行 ``yes`` 或者 ``no`` ，表示是否存在一条无尽的盈利路径。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P9830", "type": "P", "difficulty": 5, "samples": [["2\n2 2\n2 3", "3.236067977499790\n3.605551275463989"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "贪心", "2020", "上海", "Special Judge", "O2优化", "ICPC"], "title": "[ICPC 2020 Shanghai R] Traveling in the Grid World", "background": "", "description": "Consider a grid pattern with $n$ rows and $m$ columns. There are $(n+1)\\times(m+1)$ grid points in total which is the intersections of $n+1$ horizontal lines and $m+1$ vertical lines. We number the horizontal lines from $0$ to $n$ from top to bottom. We number the vertical lines from $0$ to $m$ from left to right. The intersection of horizontal line $i$ and vertical line $j$ is named $(i, j)$ ($0\\le i\\le n, 0\\le j\\le m$).\n\nThere are some constraints when you travel in the grid world. When you are located at point $(x,y)$, you can choose a destination $(x',y')$ and walk to it along the line segment between $(x, y)$ and $(x', y')$. We call this operation a $\\textit{walk}$. A walk is forbidden if there exists another grid point different from $(x, y)$ and $(x', y')$ lying on the line segment between them. You can walk as many times as you want but the directions of two consecutive walks cannot be the same. (Specifically, if you walk from $(x_0, y_0)$ to $(x_1, y_1)$ and then walk from $(x_1, y_1)$ to $(x_2, y_2)$, you must make sure that $(x_0-x_1)(y_1-y_2)\\neq (x_1-x_2)(y_0-y_1)$.) The length of a walk from $(x, y)$ to $(x', y')$ is defined as the Euclidean distance between the two endpoints, $\\sqrt{(x-x')^2+(y'-y)^2}$.\n\nStarting from $(0,0)$, you are planning to arrive at $(n,m)$ by several walks. Because of the annoying rules, you may need some turning points to achieve your goal. Please find the minimum total length of your walks.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n,m$ ($1\\le n,m \\le 10^6$) indicating the size of the grid graph.\n\nIt is guaranteed that the sum of the values of $\\max(n,m)$ over all test cases does not exceed $10^6$.", "outputFormat": "For each test case, output the minimum total length of walks. Your answer will be considered correct if its absolute or relative error does not exceed $10 ^{-9}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Traveling in the Grid World", "background": "", "description": "Consider a grid pattern with $n$ rows and $m$ columns. There are $(n+1)\\times(m+1)$ grid points in total which is the intersections of $n+1$ horizontal lines and $m+1$ vertical lines. We number the horizontal lines from $0$ to $n$ from top to bottom. We number the vertical lines from $0$ to $m$ from left to right. The intersection of horizontal line $i$ and vertical line $j$ is named $(i, j)$ ($0\\le i\\le n, 0\\le j\\le m$).\n\nThere are some constraints when you travel in the grid world. When you are located at point $(x,y)$, you can choose a destination $(x',y')$ and walk to it along the line segment between $(x, y)$ and $(x', y')$. We call this operation a $\\textit{walk}$. A walk is forbidden if there exists another grid point different from $(x, y)$ and $(x', y')$ lying on the line segment between them. You can walk as many times as you want but the directions of two consecutive walks cannot be the same. (Specifically, if you walk from $(x_0, y_0)$ to $(x_1, y_1)$ and then walk from $(x_1, y_1)$ to $(x_2, y_2)$, you must make sure that $(x_0-x_1)(y_1-y_2)\\neq (x_1-x_2)(y_0-y_1)$.) The length of a walk from $(x, y)$ to $(x', y')$ is defined as the Euclidean distance between the two endpoints, $\\sqrt{(x-x')^2+(y'-y)^2}$.\n\nStarting from $(0,0)$, you are planning to arrive at $(n,m)$ by several walks. Because of the annoying rules, you may need some turning points to achieve your goal. Please find the minimum total length of your walks.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n,m$ ($1\\le n,m \\le 10^6$) indicating the size of the grid graph.\n\nIt is guaranteed that the sum of the values of $\\max(n,m)$ over all test cases does not exceed $10^6$.", "outputFormat": "For each test case, output the minimum total length of walks. Your answer will be considered correct if its absolute or relative error does not exceed $10 ^{-9}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Traveling in the Grid World", "background": "", "description": "考虑一个由 $n$ 行和 $m$ 列组成的网格图案。总共有 $(n+1)\\times(m+1)$ 个网格点，即 $n+1$ 条水平线和 $m+1$ 条垂直线的交点。我们将水平线从上到下编号为 $0$ 到 $n$。我们将垂直线从左到右编号为 $0$ 到 $m$。水平线 $i$ 和垂直线 $j$ 的交点命名为 $(i, j)$ ($0\\le i\\le n, 0\\le j\\le m$)。\n\n在网格世界中旅行时有一些限制。当你位于点 $(x,y)$ 时，你可以选择一个目的地 $(x',y')$ 并沿着 $(x, y)$ 和 $(x', y')$ 之间的线段走过去。我们称这种操作为一次“行走”。如果在它们之间的线段上存在另一个不同于 $(x, y)$ 和 $(x', y')$ 的网格点，则该行走是被禁止的。你可以走任意多次，但两次连续行走的方向不能相同。（具体来说，如果你从 $(x_0, y_0)$ 走到 $(x_1, y_1)$，然后从 $(x_1, y_1)$ 走到 $(x_2, y_2)$，你必须确保 $(x_0-x_1)(y_1-y_2)\neq (x_1-x_2)(y_0-y_1)$。）从 $(x, y)$ 到 $(x', y')$ 的行走长度定义为两个端点之间的欧几里得距离，$\\sqrt{(x-x')^2+(y'-y)^2}$。\n\n从 $(0,0)$ 出发，你计划通过几次行走到达 $(n,m)$。由于这些烦人的规则，你可能需要一些转折点来实现你的目标。请找出你的行走的最小总长度。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含两个整数 $n,m$ ($1\\le n,m \\le 10^6$)，表示网格图的大小。\n\n保证所有测试用例中 $\\max(n,m)$ 的总和不超过 $10^6$。", "outputFormat": "对于每个测试用例，输出最小的行走总长度。你的答案将被认为是正确的，如果其绝对或相对误差不超过 $10^{-9}$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9831", "type": "P", "difficulty": 3, "samples": [["2\n3 0\ndata/train\ndata/test\nmodel\n3 1\ndata/train\ndata/test\nmodel\ndata/sample", "2\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "上海", "O2优化", "ICPC"], "title": "[ICPC 2020 Shanghai R] Gitignore", "background": "", "description": "Your git project (you don't need to be familiar with git to solve this problem) has some files that should be ignored from synchronizing. You need to calculate the minimum number of lines needed for gitignore.\n\nFormally, your project is a folder. A folder can have files and sub folders. There are no empty folders (i.e. folders without any files or sub folders inside). Initially, the git software will synchronize all the files in your project. However, you can specify some files and folders in the settings (which is called gitignore) to exclude them from synchronizing. For each line in gitignore, you can specify either a file or all the files in a folder. You can $\\textbf{not}$  ignore the whole project folder (i.e. an empty line in gitignore).\n\nYou are given paths for all the files in the project and whether they should be ignored or shouldn't. Your task is to calculate the minimum number of lines for gitignore.", "inputFormat": "The input contains several test cases. The first line contains a single positive integer $T$ which is the number of test cases. For each test case, you are first given two non-negative numbers $n$ and $m$. And then $n$ non-empty lines of file paths that should be $\\textbf{ignored}$, and $m$ non-empty lines of file paths that should $\\textbf{not}$ be ignored.\n\nThe paths are strings containing lower-cased English alphabets and slashes (`/`) only. Slashes are used to separate folders, sub folders and file name. For exapmle, ``a/b/c/d`` indicates folder ``a`` in the project folder, folder ``b`` in folder ``a``, folder ``c`` in ``b`` and file ``d`` in folder ``c``. All the paths are valid, specifically:\n\n- The path is non-empty and it always indicates a file (i.e. the path does not end with a slash).\n- The path does not start with a slash.\n- Folder names and file names are non-empty (i.e. there are no consecutive slashes).\n- File paths are always unique (i.e. all the paths in a test case are different).\n- In a folder, no sub folders and files share the same names. For example, there won't be two files ``a/b/a`` and ``a/b/a/d`` in one test case. However, files ``a/b/a`` and ``a/b/b`` are allowed.\n\n$1\\leq n+m\\leq 100$ holds and in the whole input there are no more than $1,000$ characters in file paths (i.e. the sum of lengths of file path strings in the whole input file is no more than $1,000$).", "outputFormat": "$T$ lines of non-negative integers, the minimum number of gitignore lines for each test case.", "hint": "In the first sample test case, the corresponding gitignore file contains $2$ lines: a folder line ``data/`` and a file name ``model``.\n\nIn the second sample test case, the corresponding gitignore file contains $3$ file lines: ``data/train``, ``data/test`` and ``model``.", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Gitignore", "background": "", "description": "Your git project (you don't need to be familiar with git to solve this problem) has some files that should be ignored from synchronizing. You need to calculate the minimum number of lines needed for gitignore.\n\nFormally, your project is a folder. A folder can have files and sub folders. There are no empty folders (i.e. folders without any files or sub folders inside). Initially, the git software will synchronize all the files in your project. However, you can specify some files and folders in the settings (which is called gitignore) to exclude them from synchronizing. For each line in gitignore, you can specify either a file or all the files in a folder. You can $\\textbf{not}$  ignore the whole project folder (i.e. an empty line in gitignore).\n\nYou are given paths for all the files in the project and whether they should be ignored or shouldn't. Your task is to calculate the minimum number of lines for gitignore.", "inputFormat": "The input contains several test cases. The first line contains a single positive integer $T$ which is the number of test cases. For each test case, you are first given two non-negative numbers $n$ and $m$. And then $n$ non-empty lines of file paths that should be $\\textbf{ignored}$, and $m$ non-empty lines of file paths that should $\\textbf{not}$ be ignored.\n\nThe paths are strings containing lower-cased English alphabets and slashes (`/`) only. Slashes are used to separate folders, sub folders and file name. For exapmle, ``a/b/c/d`` indicates folder ``a`` in the project folder, folder ``b`` in folder ``a``, folder ``c`` in ``b`` and file ``d`` in folder ``c``. All the paths are valid, specifically:\n\n- The path is non-empty and it always indicates a file (i.e. the path does not end with a slash).\n- The path does not start with a slash.\n- Folder names and file names are non-empty (i.e. there are no consecutive slashes).\n- File paths are always unique (i.e. all the paths in a test case are different).\n- In a folder, no sub folders and files share the same names. For example, there won't be two files ``a/b/a`` and ``a/b/a/d`` in one test case. However, files ``a/b/a`` and ``a/b/b`` are allowed.\n\n$1\\leq n+m\\leq 100$ holds and in the whole input there are no more than $1,000$ characters in file paths (i.e. the sum of lengths of file path strings in the whole input file is no more than $1,000$).", "outputFormat": "$T$ lines of non-negative integers, the minimum number of gitignore lines for each test case.", "hint": "In the first sample test case, the corresponding gitignore file contains $2$ lines: a folder line ``data/`` and a file name ``model``.\n\nIn the second sample test case, the corresponding gitignore file contains $3$ file lines: ``data/train``, ``data/test`` and ``model``.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Gitignore", "background": "", "description": "你的 git 项目（你不需要熟悉 git 来解决这个问题）中有一些文件应该被忽略同步。你需要计算 .gitignore 文件中所需的最小行数。\n\n形式上，你的项目是一个文件夹。一个文件夹可以包含文件和子文件夹。没有空文件夹（即没有任何文件或子文件夹的文件夹）。最初，git 软件会同步项目中的所有文件。然而，你可以在设置中指定一些文件和文件夹（即 .gitignore）来排除它们的同步。在 .gitignore 中的每一行，你可以指定一个文件或一个文件夹中的所有文件。你不能忽略整个项目文件夹（即 .gitignore 中的空行）。\n\n你将得到项目中所有文件的路径，以及它们是否应该被忽略。你的任务是计算 .gitignore 的最小行数。", "inputFormat": "输入包含多个测试用例。第一行包含一个正整数 $T$，表示测试用例的数量。对于每个测试用例，首先给出两个非负整数 $n$ 和 $m$。接下来是 $n$ 行非空的文件路径，这些文件路径应该被忽略，接着是 $m$ 行非空的文件路径，这些文件路径不应该被忽略。\n\n路径是仅包含小写英文字母和斜杠（`/`）的字符串。斜杠用于分隔文件夹、子文件夹和文件名。例如，`a/b/c/d` 表示项目文件夹中的文件夹 `a`，文件夹 `a` 中的文件夹 `b`，`b` 中的文件夹 `c`，以及 `c` 中的文件 `d`。所有路径都是有效的，具体来说：\n\n- 路径非空且总是表示一个文件（即路径不以斜杠结尾）。\n- 路径不以斜杠开头。\n- 文件夹名和文件名非空（即没有连续的斜杠）。\n- 文件路径总是唯一的（即一个测试用例中的所有路径都是不同的）。\n- 在一个文件夹中，没有子文件夹和文件共享相同的名称。例如，不会在一个测试用例中出现两个文件 `a/b/a` 和 `a/b/a/d`。然而，文件 `a/b/a` 和 `a/b/b` 是允许的。\n\n$1 \\leq n+m \\leq 100$ 且整个输入中文件路径的字符总数不超过 $1,000$（即整个输入文件中文件路径字符串的长度之和不超过 $1,000$）。", "outputFormat": "$T$ 行非负整数，表示每个测试用例的 .gitignore 的最小行数。", "hint": "在第一个示例测试用例中，.gitignore 文件包含 2 行：一个文件夹行 `data/` 和一个文件名 `model`。\n\n在第二个示例测试用例中，.gitignore 文件包含 3 行文件：`data/train`、`data/test` 和 `model`。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9832", "type": "P", "difficulty": 4, "samples": [["8 2 9\n1 2\n1 6\n1 7\n1 8\n1 9\n2 2\n2 3\n2 4", "10"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2005", "USACO"], "title": "[USACO05OPEN] Lazy Cows G", "background": "", "description": "地母是这个世界上大地的主宰，在她眼中整个大地呈现两行 $n$ 列的一个状态。在这个大地上如珍珠般散落着各种宝藏，每个宝藏占据一个格子。不过这个消息让天公知道了，他想抢走这些宝藏。地母决定用「无极」牌帆布盖住这些宝藏。\n\n「无极」牌帆布是矩形状的，而且地母现在手头比较紧，她决定用 $k$ 块帆布盖住所有的宝藏。现在希望你求出这 $k$ 块帆布的面积之和的最小值。", "inputFormat": "第一行给出三个数，分别代表宝藏的个数 $m$，帆布的张数 $k$，以及整个大地所呈现的列数 $n$，下面 $m$ 行给出两个数，代表每个宝藏所在的位置。", "outputFormat": "输出一行一个数，帆布面积之和的最小值。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 1.5 \\times 10^7$，$1 \\leq k \\leq m \\leq 10^3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO05OPEN] Lazy Cows G", "background": "", "description": "地母是这个世界上大地的主宰，在她眼中整个大地呈现两行 $n$ 列的一个状态。在这个大地上如珍珠般散落着各种宝藏，每个宝藏占据一个格子。不过这个消息让天公知道了，他想抢走这些宝藏。地母决定用「无极」牌帆布盖住这些宝藏。\n\n「无极」牌帆布是矩形状的，而且地母现在手头比较紧，她决定用 $k$ 块帆布盖住所有的宝藏。现在希望你求出这 $k$ 块帆布的面积之和的最小值。", "inputFormat": "第一行给出三个数，分别代表宝藏的个数 $m$，帆布的张数 $k$，以及整个大地所呈现的列数 $n$，下面 $m$ 行给出两个数，代表每个宝藏所在的位置。", "outputFormat": "输出一行一个数，帆布面积之和的最小值。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 1.5 \\times 10^7$，$1 \\leq k \\leq m \\leq 10^3$。", "locale": "zh-CN"}}}
{"pid": "P9833", "type": "P", "difficulty": 4, "samples": [["4\n4 4\n5 2\n11 5\n15 10\n25 10\n", "2"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["贪心", "2005", "USACO", "优先队列"], "title": "[USACO05OPEN] Expedition G", "background": null, "description": "一群奶牛抢了一辆卡车决定前往树林里探险，但是由于它们的驾驶技术太糟，油箱在路上给弄破了，所以它们每前进一个单位的路程就会漏掉一个单位的油。\n\n为了修好油箱，奶牛们必须前往最近的城市（不会超过 $10^6$ 单位路程）。  \n在当前位置和城市之间有 $n$ 个加油站．奶牛可以在加油站加 $1$ 到 $100$ 单位的油。  \n\n对于人来说，树林是个危险的地方；对奶牛来说，更是这样。  所以，奶牛要尽可能的少停站加油，幸运的是，这辆卡车的油箱非常大，你可以认为它的容量是无穷大的。  \n卡车在离城 $l$ 个单位时还有 $p$ 个单位的油，你要算出奶牛们至少要停几站才能到城市，或者奶牛们根本到不了城市。", "inputFormat": "第一行，一个整数 $n$。\n\n第二到 $n+1$ 行，每行有两个用空格隔开的整数，描述一个加油站。第一个数表示这个加油站离城市的距离，第二个数表示在这个加油站最多可以加多少油。\n\n第 $n+2$ 行：两个用空格分开的整数 $l$ 和 $p$。", "outputFormat": "一个表示卡车到城市最少要停的次数，如果无法到达输出 `-1`。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 10^4$，$1\\leq p\\leq 1000000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO05OPEN] Expedition G", "background": null, "description": "一群奶牛抢了一辆卡车决定前往树林里探险，但是由于它们的驾驶技术太糟，油箱在路上给弄破了，所以它们每前进一个单位的路程就会漏掉一个单位的油。\n\n为了修好油箱，奶牛们必须前往最近的城市（不会超过 $10^6$ 单位路程）。  \n在当前位置和城市之间有 $n$ 个加油站．奶牛可以在加油站加 $1$ 到 $100$ 单位的油。  \n\n对于人来说，树林是个危险的地方；对奶牛来说，更是这样。  所以，奶牛要尽可能的少停站加油，幸运的是，这辆卡车的油箱非常大，你可以认为它的容量是无穷大的。  \n卡车在离城 $l$ 个单位时还有 $p$ 个单位的油，你要算出奶牛们至少要停几站才能到城市，或者奶牛们根本到不了城市。", "inputFormat": "第一行，一个整数 $n$。\n\n第二到 $n+1$ 行，每行有两个用空格隔开的整数，描述一个加油站。第一个数表示这个加油站离城市的距离，第二个数表示在这个加油站最多可以加多少油。\n\n第 $n+2$ 行：两个用空格分开的整数 $l$ 和 $p$。", "outputFormat": "一个表示卡车到城市最少要停的次数，如果无法到达输出 `-1`。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 10^4$，$1\\leq p\\leq 1000000$。", "locale": "zh-CN"}}}
{"pid": "P9834", "type": "P", "difficulty": 4, "samples": [["3 3\n0\n120\n240\n1 2\n2 3\n1 3\n", "3"]], "limits": {"time": [350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2005", "USACO"], "title": "[USACO05OPEN] Around the world G", "background": "", "description": "这些年，农夫约翰在国际上交了一大批开农场的朋友。由于他有一段时间没有去见过英国的农夫泰德和荷兰的农夫波尔，所以他想去拜访他们。\n\n他知道每个朋友的农场的经度（是一个从 $0$ 到 $359$ 的整数，我们把地球看成一个圆，经度在此圆上顺时针方向递增）。  \n\n农夫约翰打算乘飞机去拜访他的 $n$ 个朋友（用 $1$ 到 $n$ 来表示）。他知道在这些农场之间有 $m$ 条双向的航线。飞机是沿着地面上最短的路径飞行的（就是圆上的最短弧长）。两个农场之间的航线一定是最短的。\n\n保证如果有两个农场在直径两端，那么它们之间一定不会被某条航线直接连接。\n\n所以任何一次航行都可以被描述成顺时针或是逆时针的．比如说，经度 $30$ 到经度 $35$ 是顺时针的，经度 $350$ 到经度 $10$ 也是顺时针的，而经度 $350$ 到经度 $200$ 是逆时针的。\n\n农夫约翰为了耍酷，决定要经过几个朋友的农场做到环球旅行，他想知道这是否可能，如果可能最少要乘几次飞机。\n\n他想在他最好的朋友（即输入中的第一个）的农场上开始和结束这次旅行。为了保证这是一次环球航行，结束旅行，顺时针经过的路程不能等于逆时针经过的路程。", "inputFormat": "第一行两个用空格隔开的整数 $n$ 和 $m$。\n\n第二到 $n+1$ 行：第 $i+1$ 行有一个整数，表示第 $i$ 个农场的经度。第二行是他的最好的朋友的地址。\n\n第 $n+2$ 过程 $n+m+1$ 行：第 $i+n+1$ 行有两个整数，表示这两个农场之间有航线。", "outputFormat": "一个整数，表示农夫约翰至少要乘几次飞机才能完成环球旅行。每次农夫约翰从一个农场前往另一个农场算作乘一次飞机。如果不可能做到环球旅行则输出 `-1`。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 5 \\times 10^3$，$1 \\leq m \\leq 2.5 \\times 10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO05OPEN] Around the world G", "background": "", "description": "这些年，农夫约翰在国际上交了一大批开农场的朋友。由于他有一段时间没有去见过英国的农夫泰德和荷兰的农夫波尔，所以他想去拜访他们。\n\n他知道每个朋友的农场的经度（是一个从 $0$ 到 $359$ 的整数，我们把地球看成一个圆，经度在此圆上顺时针方向递增）。  \n\n农夫约翰打算乘飞机去拜访他的 $n$ 个朋友（用 $1$ 到 $n$ 来表示）。他知道在这些农场之间有 $m$ 条双向的航线。飞机是沿着地面上最短的路径飞行的（就是圆上的最短弧长）。两个农场之间的航线一定是最短的。\n\n保证如果有两个农场在直径两端，那么它们之间一定不会被某条航线直接连接。\n\n所以任何一次航行都可以被描述成顺时针或是逆时针的．比如说，经度 $30$ 到经度 $35$ 是顺时针的，经度 $350$ 到经度 $10$ 也是顺时针的，而经度 $350$ 到经度 $200$ 是逆时针的。\n\n农夫约翰为了耍酷，决定要经过几个朋友的农场做到环球旅行，他想知道这是否可能，如果可能最少要乘几次飞机。\n\n他想在他最好的朋友（即输入中的第一个）的农场上开始和结束这次旅行。为了保证这是一次环球航行，结束旅行，顺时针经过的路程不能等于逆时针经过的路程。", "inputFormat": "第一行两个用空格隔开的整数 $n$ 和 $m$。\n\n第二到 $n+1$ 行：第 $i+1$ 行有一个整数，表示第 $i$ 个农场的经度。第二行是他的最好的朋友的地址。\n\n第 $n+2$ 过程 $n+m+1$ 行：第 $i+n+1$ 行有两个整数，表示这两个农场之间有航线。", "outputFormat": "一个整数，表示农夫约翰至少要乘几次飞机才能完成环球旅行。每次农夫约翰从一个农场前往另一个农场算作乘一次飞机。如果不可能做到环球旅行则输出 `-1`。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 5 \\times 10^3$，$1 \\leq m \\leq 2.5 \\times 10^4$。", "locale": "zh-CN"}}}
{"pid": "P9835", "type": "P", "difficulty": 4, "samples": [["12 1\n1\n2\n3\n3\n3\n2\n1\n3\n2\n2\n1\n2\n", "5"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2005", "USACO"], "title": "[USACO05OPEN] Landscaping G", "background": null, "description": "农夫约翰正在做一次艰难的转型，从养山羊改成养奶牛，他的农场，由于是为养山羊而设计的所以有太多的山，为了养牛就必须将它整平。但是，将山整平是件很花钱的工作，所以他要移走尽可能少的土。\n\n由于农场很细长，所以可以用一个 $n$ 和 $n$ 个整数（范围 $[1,10^6]$）组成的二维的数组来表示，如：\n\n```\n1 2 3 3 3 2 1 3 2 2 1 2\n```\n\n上述农场的侧面图是这样的：\n\n```\n    * * *     *\n  * * * * *   * * *   *\n* * * * * * * * * * * *\n1 2 3 3 3 2 1 3 2 2 1 2\n```\n\n一个或是一些连续等高的地面，如果它左边与右边的海拔都比它低的话，就被称为山顶，上面的例子就有三个山顶。 确定如果要使地图上仅有 $k$ 个山顶，至少要移走多少体积的土（每块地面减少一单位海拔需移走一单位的土）。注意，地面的海拔只能被降低不能被升高。 对于例子，如果要减少到只有 $1$ 个山顶，这需要移走 $2+1+1+1=5$ 个单位的土（`-` 表示移走的土）：\n\n```\n    * * *     -\n  * * * * *   - - -   -\n* * * * * * * * * * * *\n1 2 3 3 3 2 1 3 2 2 1 2\n```", "inputFormat": "第 $1$ 行输入整数 $n$ 和 $k$。\n\n之后 $n$ 行，每行输入一个整数，表示这块地的海拔。", "outputFormat": "如果仅能有 $k$ 个山顶至少要移走多少土。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^3$，$1 \\leq k \\leq 25$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO05OPEN] Landscaping G", "background": null, "description": "农夫约翰正在做一次艰难的转型，从养山羊改成养奶牛，他的农场，由于是为养山羊而设计的所以有太多的山，为了养牛就必须将它整平。但是，将山整平是件很花钱的工作，所以他要移走尽可能少的土。\n\n由于农场很细长，所以可以用一个 $n$ 和 $n$ 个整数（范围 $[1,10^6]$）组成的二维的数组来表示，如：\n\n```\n1 2 3 3 3 2 1 3 2 2 1 2\n```\n\n上述农场的侧面图是这样的：\n\n```\n    * * *     *\n  * * * * *   * * *   *\n* * * * * * * * * * * *\n1 2 3 3 3 2 1 3 2 2 1 2\n```\n\n一个或是一些连续等高的地面，如果它左边与右边的海拔都比它低的话，就被称为山顶，上面的例子就有三个山顶。 确定如果要使地图上仅有 $k$ 个山顶，至少要移走多少体积的土（每块地面减少一单位海拔需移走一单位的土）。注意，地面的海拔只能被降低不能被升高。 对于例子，如果要减少到只有 $1$ 个山顶，这需要移走 $2+1+1+1=5$ 个单位的土（`-` 表示移走的土）：\n\n```\n    * * *     -\n  * * * * *   - - -   -\n* * * * * * * * * * * *\n1 2 3 3 3 2 1 3 2 2 1 2\n```", "inputFormat": "第 $1$ 行输入整数 $n$ 和 $k$。\n\n之后 $n$ 行，每行输入一个整数，表示这块地的海拔。", "outputFormat": "如果仅能有 $k$ 个山顶至少要移走多少土。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^3$，$1 \\leq k \\leq 25$。", "locale": "zh-CN"}}}
{"pid": "P9836", "type": "P", "difficulty": 4, "samples": [["3 60\n8 243 250", "2304"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "贪心", "洛谷原创", "O2优化", "洛谷月赛"], "title": "种树", "background": "小 Rf 不是很喜欢种花，但是他喜欢种树。", "description": "路边有 $n$ 棵树，每棵树的 **高度** 均为正整数，记作 $p_1, p_2 \\dots p_n$。\n\n定义一棵树的 **宽度** 为它高度的正因数个数，这些树能覆盖的距离为它们宽度的乘积，你想请你的朋友们来乘凉，但你发现这些树能覆盖的距离不够多。\n\n于是你买了总量为 $w$ 单位的神奇化肥。你可以施若干次肥，每次你可以使用 $k$ 单位化肥（**要求 $k$ 必须为当前化肥量的正因数**），让任意一棵树的高度乘上 $k$，同时你剩余的化肥量也会除以 $k$。每次施肥的树可任意选择，且每次施肥选择的树不需相同。\n\n你需要最大化这些树所能覆盖的距离，并输出这个最大距离。答案对 $998244353$ 取模。", "inputFormat": "从标准输入中读入数据。\n\n第一行，两个正整数 $n$ 与 $w$。\n\n第二行 $n$ 个正整数 $p_1, p_2 \\dots p_n$。", "outputFormat": "输出到标准输出。\n\n仅一行一个整数，代表答案对 $998244353$ 取模后的结果。", "hint": "**【样例 1 解释】**\n\n+ 第一次施肥，向第一棵树施 $15$ 单位的肥，使其高度变成 $120$，剩余 $4$ 单位的化肥。\n+ 第二次施肥，向第二棵树施 $4$ 单位的肥，使其高度变成 $972$，剩余 $1$ 单位的化肥。\n+ 这时候，三棵树的宽度分别为 $16, 18, 8$，所能覆盖的距离为 $2304$，为最优解。\n\n---\n\n**【样例 2】**\n\n见附件下的 $\\texttt{plant/plant2.in}$ 与 $\\texttt{plant/plant2.ans}$。\n\n---\n\n**【样例 3】**\n\n见附件下的 $\\texttt{plant/plant3.in}$ 与 $\\texttt{plant/plant3.ans}$。\n\n---\n\n**【数据范围】**\n\n| 测试点编号 | $n \\leq$ | $p_i$ | $w$ | 单点分值 |\n| :--------: | :------: | :---: | :---: | :------: |\n| $1 \\sim 5$ | $10^4$ | $=1$ | $=1$ | $1$ |\n| $6 \\sim 10$ | $10^4$ | $\\leq 10^4$ | $=1$ | $3$ |\n| $11 \\sim 15$ | $1$ | $\\leq 10^4$ | $\\leq 10^4$ | $3$ |\n| $16 \\sim 20$ | $5$ | $\\leq 10^4$ | $\\leq 10^4$ | $6$ |\n| $21 \\sim 25$ | $10^4$ | $\\leq 10^4$ | $\\leq 10^4$ | $7$ |\n\n对于 $100 \\%$ 的数据，保证 $1 \\leq n \\leq 10^4$，$1 \\leq p_i \\leq 10^4$，$1 \\leq w \\leq 10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "种树", "background": "小 Rf 不是很喜欢种花，但是他喜欢种树。", "description": "路边有 $n$ 棵树，每棵树的 **高度** 均为正整数，记作 $p_1, p_2 \\dots p_n$。\n\n定义一棵树的 **宽度** 为它高度的正因数个数，这些树能覆盖的距离为它们宽度的乘积，你想请你的朋友们来乘凉，但你发现这些树能覆盖的距离不够多。\n\n于是你买了总量为 $w$ 单位的神奇化肥。你可以施若干次肥，每次你可以使用 $k$ 单位化肥（**要求 $k$ 必须为当前化肥量的正因数**），让任意一棵树的高度乘上 $k$，同时你剩余的化肥量也会除以 $k$。每次施肥的树可任意选择，且每次施肥选择的树不需相同。\n\n你需要最大化这些树所能覆盖的距离，并输出这个最大距离。答案对 $998244353$ 取模。", "inputFormat": "从标准输入中读入数据。\n\n第一行，两个正整数 $n$ 与 $w$。\n\n第二行 $n$ 个正整数 $p_1, p_2 \\dots p_n$。", "outputFormat": "输出到标准输出。\n\n仅一行一个整数，代表答案对 $998244353$ 取模后的结果。", "hint": "**【样例 1 解释】**\n\n+ 第一次施肥，向第一棵树施 $15$ 单位的肥，使其高度变成 $120$，剩余 $4$ 单位的化肥。\n+ 第二次施肥，向第二棵树施 $4$ 单位的肥，使其高度变成 $972$，剩余 $1$ 单位的化肥。\n+ 这时候，三棵树的宽度分别为 $16, 18, 8$，所能覆盖的距离为 $2304$，为最优解。\n\n---\n\n**【样例 2】**\n\n见附件下的 $\\texttt{plant/plant2.in}$ 与 $\\texttt{plant/plant2.ans}$。\n\n---\n\n**【样例 3】**\n\n见附件下的 $\\texttt{plant/plant3.in}$ 与 $\\texttt{plant/plant3.ans}$。\n\n---\n\n**【数据范围】**\n\n| 测试点编号 | $n \\leq$ | $p_i$ | $w$ | 单点分值 |\n| :--------: | :------: | :---: | :---: | :------: |\n| $1 \\sim 5$ | $10^4$ | $=1$ | $=1$ | $1$ |\n| $6 \\sim 10$ | $10^4$ | $\\leq 10^4$ | $=1$ | $3$ |\n| $11 \\sim 15$ | $1$ | $\\leq 10^4$ | $\\leq 10^4$ | $3$ |\n| $16 \\sim 20$ | $5$ | $\\leq 10^4$ | $\\leq 10^4$ | $6$ |\n| $21 \\sim 25$ | $10^4$ | $\\leq 10^4$ | $\\leq 10^4$ | $7$ |\n\n对于 $100 \\%$ 的数据，保证 $1 \\leq n \\leq 10^4$，$1 \\leq p_i \\leq 10^4$，$1 \\leq w \\leq 10^4$。", "locale": "zh-CN"}}}
{"pid": "P9837", "type": "P", "difficulty": 6, "samples": [["2 1", "1\n2 1"], ["5 2", "1\n2 3\n4 2 5\n3 5 1 4\n5 4 3 1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "洛谷原创", "Special Judge", "O2优化", "图论建模", "构造", "洛谷月赛", "Ad-hoc"], "title": "汪了个汪", "background": "你说得对，但是小 P 在 [[NOIP2022] 喵了个喵](https://www.luogu.com.cn/problem/P8866) 中没有输出操作次数，获得了 $0$ 分的好成绩。", "description": "小 P 喜欢上了一款叫做《汪了个汪》的游戏。这个游戏有一个牌堆和一个金字塔形的棋盘，总共有 $3$ 关。具体地，如图所示，棋盘的边长为 $n$，第 $i$ 行有 $i$ 个格子，共 $\\dfrac{n(n+1)}{2}$ 个格子。\n\n牌堆中有 $1, 2 \\dots n$ 的数字卡片 **各无穷多张**。你需要将这些数字卡片放到对应的棋盘格子中，每个格子恰好放一张数字卡片，要求满足棋盘的每一行的第一个元素 **互不相同**。\n\n小 P 发现，这个游戏的难度会随着关卡编号而增加：\n\n- 在第 $0$ 关中，你不必满足其他条件。\n- 在第 $1$ 关中，你需要保证一行内相邻的两个数互不相同，且所有由任意一行内相邻两个数组成的 **无序二元组** 互不相同。\n- 在第 $2$ 关中，你需要满足第 $1$ 关的限制，并且一行内的 **所有数** 必须互不相同。\n\n例如，下面是 $n=5$ 时可以通过第 $2$ 关的摆放方式：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zdln26tg.png)\n\n现在给定 $n$ 与关卡编号，请你帮小 P 找出一种合适的摆放方式来通过这一关。可以证明在游戏限制下一定存在一种过关方式。", "inputFormat": "从标准输入中读入数据。\n\n仅一行，包含两个整数 $n, t$，其中 $t$ 表示关卡编号。", "outputFormat": "输出到标准输出。\n\n输出 $n$ 行，第 $i$ 行包含 $i$ 个正整数（以空格分隔），表示棋盘第 $i$ 行从左到右所有的数。\n\n如果有多种合法的解，你可以输出任何一种。", "hint": "**【说明与提示】**\n\n本题下发校验器（`checker.cpp`）。将 `checker.cpp` 编译成可执行文件 `checker` 后，在当前目录执行 `checker woof.in woof.out woof.ans` 即可校验你的答案是否符合规范。其中 `woof.in` 可以替换为对应输入文件名称，`woof.out` 可以替换为对应输出文件名称，也即构造结果。`woof.ans` 可以为任意文件。\n\n返回结果说明：\n\n- `The numbers are not in the valid range.`：说明你的输出不满足每个数字都在 $1\\sim n$ 的范围内。\n- `The first column does not satisfice.`：说明你的输出不满足每行开头的数互不相同。\n- `The pairs of numbers are not distinct.`：说明你的输出不满足所有由任意一行内相邻两个数组成的无序二元组互不相同。\n- `The adjacent numbers are not distinct.`：说明当前关卡编号 $\\ge1$ 且你的输出不满足关卡 $1$ 的条件。\n- `The numbers in a row are not distinct.`：说明当前关卡编号 $\\ge2$ 且你的输出不满足关卡 $2$ 的条件。\n- `Well done.`：说明你的构造满足要求。\n\n---\n\n#### 【数据范围】\n\n| 测试点编号 | $n \\leq$ | $t =$ | 特殊性质 |\n| :--------: | :------: | :---: | :------: |\n| $1$ | $6$ | $0$ | 无 |\n| $2$ | $6$ | $2$ | 无 |\n| $3 \\sim 4$ | $4000$ | $2$ | A |\n| $5 \\sim 7$ | $500$ | $1$ | 无 |\n| $8 \\sim 13$ | $500$ | $2$ | 无 |\n| $14 \\sim 16$ | $4000$ | $1$ | 无 |\n| $17 \\sim 20$ | $4000$ | $2$ | 无 |\n\n+ 特殊性质 A：保证 $n + 1$ 或 $n + 2$ 为质数。\n\n对于 $100 \\%$ 的数据，保证 $1 \\leq n \\leq 4000$，$t \\in \\{0, 1, 2\\}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "汪了个汪", "background": "你说得对，但是小 P 在 [[NOIP2022] 喵了个喵](https://www.luogu.com.cn/problem/P8866) 中没有输出操作次数，获得了 $0$ 分的好成绩。", "description": "小 P 喜欢上了一款叫做《汪了个汪》的游戏。这个游戏有一个牌堆和一个金字塔形的棋盘，总共有 $3$ 关。具体地，如图所示，棋盘的边长为 $n$，第 $i$ 行有 $i$ 个格子，共 $\\dfrac{n(n+1)}{2}$ 个格子。\n\n牌堆中有 $1, 2 \\dots n$ 的数字卡片 **各无穷多张**。你需要将这些数字卡片放到对应的棋盘格子中，每个格子恰好放一张数字卡片，要求满足棋盘的每一行的第一个元素 **互不相同**。\n\n小 P 发现，这个游戏的难度会随着关卡编号而增加：\n\n- 在第 $0$ 关中，你不必满足其他条件。\n- 在第 $1$ 关中，你需要保证一行内相邻的两个数互不相同，且所有由任意一行内相邻两个数组成的 **无序二元组** 互不相同。\n- 在第 $2$ 关中，你需要满足第 $1$ 关的限制，并且一行内的 **所有数** 必须互不相同。\n\n例如，下面是 $n=5$ 时可以通过第 $2$ 关的摆放方式：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zdln26tg.png)\n\n现在给定 $n$ 与关卡编号，请你帮小 P 找出一种合适的摆放方式来通过这一关。可以证明在游戏限制下一定存在一种过关方式。", "inputFormat": "从标准输入中读入数据。\n\n仅一行，包含两个整数 $n, t$，其中 $t$ 表示关卡编号。", "outputFormat": "输出到标准输出。\n\n输出 $n$ 行，第 $i$ 行包含 $i$ 个正整数（以空格分隔），表示棋盘第 $i$ 行从左到右所有的数。\n\n如果有多种合法的解，你可以输出任何一种。", "hint": "**【说明与提示】**\n\n本题下发校验器（`checker.cpp`）。将 `checker.cpp` 编译成可执行文件 `checker` 后，在当前目录执行 `checker woof.in woof.out woof.ans` 即可校验你的答案是否符合规范。其中 `woof.in` 可以替换为对应输入文件名称，`woof.out` 可以替换为对应输出文件名称，也即构造结果。`woof.ans` 可以为任意文件。\n\n返回结果说明：\n\n- `The numbers are not in the valid range.`：说明你的输出不满足每个数字都在 $1\\sim n$ 的范围内。\n- `The first column does not satisfice.`：说明你的输出不满足每行开头的数互不相同。\n- `The pairs of numbers are not distinct.`：说明你的输出不满足所有由任意一行内相邻两个数组成的无序二元组互不相同。\n- `The adjacent numbers are not distinct.`：说明当前关卡编号 $\\ge1$ 且你的输出不满足关卡 $1$ 的条件。\n- `The numbers in a row are not distinct.`：说明当前关卡编号 $\\ge2$ 且你的输出不满足关卡 $2$ 的条件。\n- `Well done.`：说明你的构造满足要求。\n\n---\n\n#### 【数据范围】\n\n| 测试点编号 | $n \\leq$ | $t =$ | 特殊性质 |\n| :--------: | :------: | :---: | :------: |\n| $1$ | $6$ | $0$ | 无 |\n| $2$ | $6$ | $2$ | 无 |\n| $3 \\sim 4$ | $4000$ | $2$ | A |\n| $5 \\sim 7$ | $500$ | $1$ | 无 |\n| $8 \\sim 13$ | $500$ | $2$ | 无 |\n| $14 \\sim 16$ | $4000$ | $1$ | 无 |\n| $17 \\sim 20$ | $4000$ | $2$ | 无 |\n\n+ 特殊性质 A：保证 $n + 1$ 或 $n + 2$ 为质数。\n\n对于 $100 \\%$ 的数据，保证 $1 \\leq n \\leq 4000$，$t \\in \\{0, 1, 2\\}$。", "locale": "zh-CN"}}}
{"pid": "P9838", "type": "P", "difficulty": 6, "samples": [["2\n3 2\n3 6", "13\n14\n"], ["5\n4 1\n4 10\n4 16\n4 20\n4 24", "32\n34\n36\n36\n38"], ["10\n1000000000000000000 1000000000000000000\n1145141919810 19260817998244353\n15 131413141314\n36 93930322810121243\n172 354354645654567654\n666 233\n1048576 2147483648\n1000000007 1000000009\n99824 44353\n10 1", "36226088\n846277092\n1096\n12356\n1239174\n70731494\n274614617\n511280969\n625722816\n330"]], "limits": {"time": [2000, 2000, 2000, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "数学", "洛谷原创", "O2优化", "记忆化搜索", "位运算", "洛谷月赛"], "title": "挑战 NPC IV", "background": "要是什么都和 NPC 问题一样简单就好了啊。", "description": "小 A 想为小 B 写一首情诗。他现在想出了 $n$ 个句子，每个句子的优美度分别为 $1, 2 \\dots n$。小 A 需要按照一定的顺序将他们组合起来，拼成一首完整的诗。换句话说，小 A 需要重新排列这 $n$ 个句子，形成一个 $1 \\sim n$ 的排列 $p_1, p_2\\dots p_n$；第 $i$ 行诗句的优美度就是原先第 $p_i$ 个句子的优美度，也就是 $p_i$。\n\n不过，由于小 A 是位 OIer，所以他的文采并不是很稳定。他实际上会严重高估自己诗句的优美程度。若一条诗句在小 A 眼里的优美度为 $x$，那么小 B 认为它的优美度是 **$x$ 在二进制表示下最低位的 $1$ 的位置**。其中，小 B 认为最低位的位置是 $1$，次低位为 $2$，以此类推。也就是说，小 B 眼中的优美度 $f(x)$ 为 $1 + \\log_2 \\operatorname{lowbit}(x)$。\n\n小 A 知道，小 B 拿到诗后，只会选取诗的一段来看，而她感受到的优美度是所有她读到的诗句之和。具体的，若诗有 $n$ 句，则小 B 会在 $[1, n]$ 的所有长度 $> 0$ 的区间中抽取一个 $[l, r]$，感受到 $\\displaystyle\\sum_{l \\leq i \\leq r}f(p_i)$ 的优美度。小 A 为了衡量一首诗的优美度，决定将一首诗的总优美度定义为 **所有情况下小 B 感受到的优美度之和**。\n\n照理来说，总优美度最大的组合方式必然是最好的。遗憾的是，在小 A 的精密计算下，他发现，只有他选择总优美度恰好为 **第 $k$ 小** 的情诗时，他才最有可能和小 B 走到一起。于是，小 A 想要知道，对于 $n!$ 首本质不同的诗，第 $k$ 小可能的总优美度是多少。两首诗本质相同当且仅当原排列 $p_1 \\dots p_n$ 相同。\n\n小 A 发现这是一个 NPC 问题，他只好来向你求助了。由于总优美度过于巨大，你只需要帮他求出答案对 $998244353$ 取模后的结果。\n\n特别的，小 A 写了 $q$ 组诗句，所以你需要分别回答他的 $q$ 个问题。", "inputFormat": "从标准输入中读入数据。\n\n第一行一个正整数 $q$，表示诗句的组数。\n\n对于每组数据，仅一行两个正整数 $n, k$ 描述小 A 的问题。", "outputFormat": "输出到标准输出。\n\n对于每组诗句，输出一行一个整数，表示第 $k$ 小的总优美度对 $998244353$ 取模后的结果。", "hint": "#### 【样例 1 解释】\n\n例如，当 $p = [1, 3, 2]$ 时，小 B 眼中每句诗的优美度分别为 $[1, 1, 2]$。那么：\n\n- 当 $l = 1$，$r = 1$ 时，优美度之和为 $1$。\n- 当 $l = 2$，$r = 2$ 时，优美度之和为 $1$。\n- 当 $l = 3$，$r = 3$ 时，优美度之和为 $2$。\n- 当 $l = 1$，$r = 2$ 时，优美度之和为 $1 + 1 = 2$。\n- 当 $l = 2$，$r = 3$ 时，优美度之和为 $1 + 2 = 3$。\n- 当 $l = 1$，$r = 3$ 时，优美度之和为 $1 + 1 + 2 = 4$。\n\n所以 $p = [1, 3, 2]$ 的总优美度为 $1 + 1 + 2 + 2 + 3 + 4 = 13$。\n\n对于所有 $3! = 6$ 个排列 $p$，其总优美度从小到大排序后分别为 $13, 13, 13, 13, 14, 14$，因此当 $k = 2$ 与 $k = 6$ 时答案分别为 $13$ 和 $14$。\n\n---\n\n#### 【样例 2】\n\n见附件下的 $\\verb!npc/npc2.in!$ 与 $\\verb!npc/npc2.ans!$。\n\n---\n\n#### 【样例 3】\n\n见附件下的 $\\verb!npc/npc3.in!$ 与 $\\verb!npc/npc3.ans!$。\n\n---\n\n#### 【数据范围】\n\n**本题各测试点时间限制不相同。具体地，每个点的时间限制为 $\\max(q\\times 0.5, 2)\\ \\rm{s}$**。\n\n| 测试点编号 | $n$ | $k \\leq$ | $q = $ |\n| :--------: | :-: | :------: | :----: |\n| $1 \\sim 3$ | $\\leq 10$ | $n!$ | $2$ |\n| $4 \\sim 8$ | $\\leq 10^3$ | $2$ | $7$ |\n| $9 \\sim 13$ | $\\in [10^5, 10^6]$ | $\\min(10^{18}, n!)$ | $7$ |\n| $14 \\sim 17$ | $\\leq 10^6$ | $\\min(10^{18}, n!)$ | $7$ |\n| $18 \\sim 25$ | $\\leq 10^{18}$ | $\\min(10^{18}, n!)$ | $10$|\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^{18}$，$1 \\leq k \\leq \\min(10^{18}, n!)$，$1 \\leq q\\le 10$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "挑战 NPC IV", "background": "要是什么都和 NPC 问题一样简单就好了啊。", "description": "小 A 想为小 B 写一首情诗。他现在想出了 $n$ 个句子，每个句子的优美度分别为 $1, 2 \\dots n$。小 A 需要按照一定的顺序将他们组合起来，拼成一首完整的诗。换句话说，小 A 需要重新排列这 $n$ 个句子，形成一个 $1 \\sim n$ 的排列 $p_1, p_2\\dots p_n$；第 $i$ 行诗句的优美度就是原先第 $p_i$ 个句子的优美度，也就是 $p_i$。\n\n不过，由于小 A 是位 OIer，所以他的文采并不是很稳定。他实际上会严重高估自己诗句的优美程度。若一条诗句在小 A 眼里的优美度为 $x$，那么小 B 认为它的优美度是 **$x$ 在二进制表示下最低位的 $1$ 的位置**。其中，小 B 认为最低位的位置是 $1$，次低位为 $2$，以此类推。也就是说，小 B 眼中的优美度 $f(x)$ 为 $1 + \\log_2 \\operatorname{lowbit}(x)$。\n\n小 A 知道，小 B 拿到诗后，只会选取诗的一段来看，而她感受到的优美度是所有她读到的诗句之和。具体的，若诗有 $n$ 句，则小 B 会在 $[1, n]$ 的所有长度 $> 0$ 的区间中抽取一个 $[l, r]$，感受到 $\\displaystyle\\sum_{l \\leq i \\leq r}f(p_i)$ 的优美度。小 A 为了衡量一首诗的优美度，决定将一首诗的总优美度定义为 **所有情况下小 B 感受到的优美度之和**。\n\n照理来说，总优美度最大的组合方式必然是最好的。遗憾的是，在小 A 的精密计算下，他发现，只有他选择总优美度恰好为 **第 $k$ 小** 的情诗时，他才最有可能和小 B 走到一起。于是，小 A 想要知道，对于 $n!$ 首本质不同的诗，第 $k$ 小可能的总优美度是多少。两首诗本质相同当且仅当原排列 $p_1 \\dots p_n$ 相同。\n\n小 A 发现这是一个 NPC 问题，他只好来向你求助了。由于总优美度过于巨大，你只需要帮他求出答案对 $998244353$ 取模后的结果。\n\n特别的，小 A 写了 $q$ 组诗句，所以你需要分别回答他的 $q$ 个问题。", "inputFormat": "从标准输入中读入数据。\n\n第一行一个正整数 $q$，表示诗句的组数。\n\n对于每组数据，仅一行两个正整数 $n, k$ 描述小 A 的问题。", "outputFormat": "输出到标准输出。\n\n对于每组诗句，输出一行一个整数，表示第 $k$ 小的总优美度对 $998244353$ 取模后的结果。", "hint": "#### 【样例 1 解释】\n\n例如，当 $p = [1, 3, 2]$ 时，小 B 眼中每句诗的优美度分别为 $[1, 1, 2]$。那么：\n\n- 当 $l = 1$，$r = 1$ 时，优美度之和为 $1$。\n- 当 $l = 2$，$r = 2$ 时，优美度之和为 $1$。\n- 当 $l = 3$，$r = 3$ 时，优美度之和为 $2$。\n- 当 $l = 1$，$r = 2$ 时，优美度之和为 $1 + 1 = 2$。\n- 当 $l = 2$，$r = 3$ 时，优美度之和为 $1 + 2 = 3$。\n- 当 $l = 1$，$r = 3$ 时，优美度之和为 $1 + 1 + 2 = 4$。\n\n所以 $p = [1, 3, 2]$ 的总优美度为 $1 + 1 + 2 + 2 + 3 + 4 = 13$。\n\n对于所有 $3! = 6$ 个排列 $p$，其总优美度从小到大排序后分别为 $13, 13, 13, 13, 14, 14$，因此当 $k = 2$ 与 $k = 6$ 时答案分别为 $13$ 和 $14$。\n\n---\n\n#### 【样例 2】\n\n见附件下的 $\\verb!npc/npc2.in!$ 与 $\\verb!npc/npc2.ans!$。\n\n---\n\n#### 【样例 3】\n\n见附件下的 $\\verb!npc/npc3.in!$ 与 $\\verb!npc/npc3.ans!$。\n\n---\n\n#### 【数据范围】\n\n**本题各测试点时间限制不相同。具体地，每个点的时间限制为 $\\max(q\\times 0.5, 2)\\ \\rm{s}$**。\n\n| 测试点编号 | $n$ | $k \\leq$ | $q = $ |\n| :--------: | :-: | :------: | :----: |\n| $1 \\sim 3$ | $\\leq 10$ | $n!$ | $2$ |\n| $4 \\sim 8$ | $\\leq 10^3$ | $2$ | $7$ |\n| $9 \\sim 13$ | $\\in [10^5, 10^6]$ | $\\min(10^{18}, n!)$ | $7$ |\n| $14 \\sim 17$ | $\\leq 10^6$ | $\\min(10^{18}, n!)$ | $7$ |\n| $18 \\sim 25$ | $\\leq 10^{18}$ | $\\min(10^{18}, n!)$ | $10$|\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^{18}$，$1 \\leq k \\leq \\min(10^{18}, n!)$，$1 \\leq q\\le 10$。", "locale": "zh-CN"}}}
{"pid": "P9839", "type": "P", "difficulty": 7, "samples": [["12 3 5\n2 3 1 2 3 4 1 3 1 5 4 3\n1 2 5 6\n5 5 7 12\n3 4 3 7", "D\nB\nA"], ["7 6 3\n2 3 3 3 1 3 3 \n1 2 5 7\n1 1 5 6\n1 3 1 6\n2 3 7 7\n1 3 3 5\n1 2 1 4", "A\nA\nB\nD\nB\nD\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "树形数据结构", "博弈论", "线段树", "洛谷原创", "O2优化", "洛谷月赛"], "title": "四暗刻单骑", "background": "", "description": "Alice 和 Bob 很喜欢打麻将。他们在对麻将规则熟悉后，开始对「四暗刻单骑」感兴趣。而在这局游戏中，Alice 和 Bob 都已经集齐了四暗刻，处于听牌状态并准备「四暗刻单骑」，于是我们将这样的局面简化如下：\n\n- 一张麻将牌可以用一个范围在 $[1, k]$ 内的正整数表示，数字相同的牌相同，数字不同的牌不相同。\n- Alice 和 Bob 手中各有 $1$ 张牌作为手牌。两人轮流进行摸牌，每次摸牌的玩家会得到一张牌堆顶部的牌，Alice 先进行。摸牌后会有 $2$ 张手牌，此时需要选择一张牌打出。打出的牌双方可见。\n- 当摸牌时两张手牌相同时，或当前对方打出的牌和自己目前手牌相同时，该玩家「和牌」并获胜，游戏结束。\n\n若牌摸完后无玩家「和牌」，则判为「荒牌流局」，此时判定两位玩家平局。\n\n现在 Alice 和 Bob 都绝顶聪明，并且已经得知了牌堆顶部的所有牌，以及对方手牌。他们都希望自己可以「和牌」并获胜，若自己无法「和牌」就会尽可能阻止对方「和牌」。\n\n你现在拿到了 $n$ 张麻将牌组成的 $a$ 数组，下标依次为 $1\\dots n$。现在有 $m$ 次询问，每次会给定 $x, y, l, r$ 表示：若目前 Alice 手牌为 $x$，Bob 手牌为 $y$，且 **按顺序** 取出 $a$ 中下标为 $[l, r]$ 的所有牌作为游戏牌堆，其中牌 $a_l$ 位于牌堆顶部，Alice 和 Bob 按要求进行游戏，最后结局如何。\n\n询问之间相互独立。特别地，**保证 $l$ 为奇数**。", "inputFormat": "从标准输入中读入数据。\n\n第一行三个正整数 $n, m, k$。\n\n接下来一行 $n$ 个正整数，依次表示 $a_1, a_2 \\dots a_n$。\n\n接下来 $m$ 行，每行四个正整数 $x,y,l,r$，表示一次询问。", "outputFormat": "输出到标准输出。\n\n对于每次询问，输出一行一个字符：如果 Alice 获胜，输出 `A`；如果 Bob 获胜，输出 `B`；如果平局，输出 `D`。", "hint": "**【样例 1 解释】**\n\n在第 $1$ 组询问中，牌堆自顶至底依次是 $3, 4$，Alice 手牌为 $1$，Bob 手牌为 $2$。不难发现此局面会导致「荒牌流局」。 \n\n在第 $2$ 组询问中，牌堆自顶至底依次是 $1, 3, 1, 5, 4, 3$，Alice 手牌为 $5$，Bob 手牌为 $5$。此时 Bob 只需要一直保留这张 $5$，就可以在摸上下一张 $5$ 时「和牌」；而 Alice 不能打出 $5$，因为一旦打出就会导致 Bob 立刻「和牌」。\n\n在第 $3$ 组询问中，牌堆自顶至底依次是 $1, 2, 3, 4, 1$，Alice 手牌为 $3$，Bob 手牌为 $4$。Alice 第一局摸上一张 $1$，她打出这张 $1$。Bob 第一局摸上一张 $2$，他无论是否打出这张 $2$，Alice 都可以在下回合「和牌」。 \n\n---\n\n#### 【样例 3】\n\n见附件下的 $\\verb!mahjong/mahjong3.in!$ 与 $\\verb!mahjong/mahjong3.ans!$。\n\n---\n\n#### 【样例 4】\n\n见附件下的 $\\verb!mahjong/mahjong4.in!$ 与 $\\verb!mahjong/mahjong4.ans!$。\n\n---\n\n**【数据范围】**\n\n| 测试点编号 | $n\\le$ | $m\\le$ | $k\\le$ | 特殊性质 |\n| :--------: | :----: | :----: | :----: | :------: |\n| $1$ | $3$ | $3$ | $3$ | A, B |\n| $2$ | $5$ | $5$ | $5$ | 无 |\n| $3\\sim 5$ | $100$ | $100$ | $100$ | 无 |\n| $6\\sim 7$ | $2000$ | $2000$ | $2000$ | 无 |\n| $8\\sim 10$ | $5\\times 10^4$ | $50$ | $5\\times 10^4$ | 无 |\n| $11$ | $2\\times 10^5$ | $2\\times 10^5$ | $2$ | 无 |\n| $12$ | $2\\times 10^5$ | $2\\times 10^5$ | $80$ | 无 |\n| $13$ | $2\\times 10^5$ | $2\\times 10^5$ | $2\\times 10^5$ | A, B |\n| $14\\sim 15$ | $2\\times 10^5$ | $2\\times 10^5$ | $2\\times 10^5$ | B |\n| $16$ | $2\\times 10^5$ | $2\\times 10^5$ | $2\\times 10^5$ | C |\n| $17\\sim 20$ | $10^5$ | $10^5$ | $10^5$ | 无 |\n| $21\\sim 25$ | $2\\times 10^5$ | $2\\times 10^5$ | $2\\times 10^5$ | 无 |\n\n+ 特殊性质 A：保证每次询问 $l = 1$。\n+ 特殊性质 B：保证每次询问 $r = n$。\n+ 特殊性质 C：保证每次询问 $x = y$。\n\n对于 $100\\%$ 的数据，保证 $3 \\leq n \\leq 2\\times 10^5$，$1 \\leq m \\leq 2\\times 10^5$，$1 \\leq a_i, x, y \\leq k \\leq n$，$1 \\leq l \\leq r \\leq n$，**保证 $l$ 是奇数**。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "四暗刻单骑", "background": "", "description": "Alice 和 Bob 很喜欢打麻将。他们在对麻将规则熟悉后，开始对「四暗刻单骑」感兴趣。而在这局游戏中，Alice 和 Bob 都已经集齐了四暗刻，处于听牌状态并准备「四暗刻单骑」，于是我们将这样的局面简化如下：\n\n- 一张麻将牌可以用一个范围在 $[1, k]$ 内的正整数表示，数字相同的牌相同，数字不同的牌不相同。\n- Alice 和 Bob 手中各有 $1$ 张牌作为手牌。两人轮流进行摸牌，每次摸牌的玩家会得到一张牌堆顶部的牌，Alice 先进行。摸牌后会有 $2$ 张手牌，此时需要选择一张牌打出。打出的牌双方可见。\n- 当摸牌时两张手牌相同时，或当前对方打出的牌和自己目前手牌相同时，该玩家「和牌」并获胜，游戏结束。\n\n若牌摸完后无玩家「和牌」，则判为「荒牌流局」，此时判定两位玩家平局。\n\n现在 Alice 和 Bob 都绝顶聪明，并且已经得知了牌堆顶部的所有牌，以及对方手牌。他们都希望自己可以「和牌」并获胜，若自己无法「和牌」就会尽可能阻止对方「和牌」。\n\n你现在拿到了 $n$ 张麻将牌组成的 $a$ 数组，下标依次为 $1\\dots n$。现在有 $m$ 次询问，每次会给定 $x, y, l, r$ 表示：若目前 Alice 手牌为 $x$，Bob 手牌为 $y$，且 **按顺序** 取出 $a$ 中下标为 $[l, r]$ 的所有牌作为游戏牌堆，其中牌 $a_l$ 位于牌堆顶部，Alice 和 Bob 按要求进行游戏，最后结局如何。\n\n询问之间相互独立。特别地，**保证 $l$ 为奇数**。", "inputFormat": "从标准输入中读入数据。\n\n第一行三个正整数 $n, m, k$。\n\n接下来一行 $n$ 个正整数，依次表示 $a_1, a_2 \\dots a_n$。\n\n接下来 $m$ 行，每行四个正整数 $x,y,l,r$，表示一次询问。", "outputFormat": "输出到标准输出。\n\n对于每次询问，输出一行一个字符：如果 Alice 获胜，输出 `A`；如果 Bob 获胜，输出 `B`；如果平局，输出 `D`。", "hint": "**【样例 1 解释】**\n\n在第 $1$ 组询问中，牌堆自顶至底依次是 $3, 4$，Alice 手牌为 $1$，Bob 手牌为 $2$。不难发现此局面会导致「荒牌流局」。 \n\n在第 $2$ 组询问中，牌堆自顶至底依次是 $1, 3, 1, 5, 4, 3$，Alice 手牌为 $5$，Bob 手牌为 $5$。此时 Bob 只需要一直保留这张 $5$，就可以在摸上下一张 $5$ 时「和牌」；而 Alice 不能打出 $5$，因为一旦打出就会导致 Bob 立刻「和牌」。\n\n在第 $3$ 组询问中，牌堆自顶至底依次是 $1, 2, 3, 4, 1$，Alice 手牌为 $3$，Bob 手牌为 $4$。Alice 第一局摸上一张 $1$，她打出这张 $1$。Bob 第一局摸上一张 $2$，他无论是否打出这张 $2$，Alice 都可以在下回合「和牌」。 \n\n---\n\n#### 【样例 3】\n\n见附件下的 $\\verb!mahjong/mahjong3.in!$ 与 $\\verb!mahjong/mahjong3.ans!$。\n\n---\n\n#### 【样例 4】\n\n见附件下的 $\\verb!mahjong/mahjong4.in!$ 与 $\\verb!mahjong/mahjong4.ans!$。\n\n---\n\n**【数据范围】**\n\n| 测试点编号 | $n\\le$ | $m\\le$ | $k\\le$ | 特殊性质 |\n| :--------: | :----: | :----: | :----: | :------: |\n| $1$ | $3$ | $3$ | $3$ | A, B |\n| $2$ | $5$ | $5$ | $5$ | 无 |\n| $3\\sim 5$ | $100$ | $100$ | $100$ | 无 |\n| $6\\sim 7$ | $2000$ | $2000$ | $2000$ | 无 |\n| $8\\sim 10$ | $5\\times 10^4$ | $50$ | $5\\times 10^4$ | 无 |\n| $11$ | $2\\times 10^5$ | $2\\times 10^5$ | $2$ | 无 |\n| $12$ | $2\\times 10^5$ | $2\\times 10^5$ | $80$ | 无 |\n| $13$ | $2\\times 10^5$ | $2\\times 10^5$ | $2\\times 10^5$ | A, B |\n| $14\\sim 15$ | $2\\times 10^5$ | $2\\times 10^5$ | $2\\times 10^5$ | B |\n| $16$ | $2\\times 10^5$ | $2\\times 10^5$ | $2\\times 10^5$ | C |\n| $17\\sim 20$ | $10^5$ | $10^5$ | $10^5$ | 无 |\n| $21\\sim 25$ | $2\\times 10^5$ | $2\\times 10^5$ | $2\\times 10^5$ | 无 |\n\n+ 特殊性质 A：保证每次询问 $l = 1$。\n+ 特殊性质 B：保证每次询问 $r = n$。\n+ 特殊性质 C：保证每次询问 $x = y$。\n\n对于 $100\\%$ 的数据，保证 $3 \\leq n \\leq 2\\times 10^5$，$1 \\leq m \\leq 2\\times 10^5$，$1 \\leq a_i, x, y \\leq k \\leq n$，$1 \\leq l \\leq r \\leq n$，**保证 $l$ 是奇数**。", "locale": "zh-CN"}}}
{"pid": "P9840", "type": "P", "difficulty": 2, "samples": [["3 3 3\n", "RRDD"], ["4 3 2\n", "DLDLDLUR"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2021", "Special Judge", "O2优化", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Oops, It's Yesterday Twice More", "background": "", "description": "After the great success in 2018, 2019, and 2020, Nanjing University of Aeronautics and Astronautics (NUAA) will host the $\\textit{International Collegiate Programming Contest}$ (ICPC) Nanjing regional for the fourth time.\n\nTeam $\\textbf{\\textit{Power of Two}}$ and team $\\textbf{\\textit{Three Hold Two}}$ won the champion for Tsinghua University in 2018 and 2019. In 2020, team $\\textbf{\\textit{Inverted Cross}}$ from Peking University won the champion. In 2021, there are around $700$ teams including $\\textbf{the defending champion}$ participating in the contest. We are so excited to see who will win this year!\n\nAlthough we can't gather in Nanjing this time due to the pandemic, we should still be grateful for the hard work done by all staff and volunteers for this contest. Thank you all for your great contribution to this contest!\n\nIn the 2018 contest, problem K, $\\textbf{\\textit{Kangaroo Puzzle}}$, requires the contestants to construct an operation sequence for the game:\n\n> The puzzle is a grid with $n$ rows and $m$ columns ($1 \\le n, m \\le 20$) and there are some (at least $2$) kangaroos standing in the puzzle. The player's goal is to control them to get together. There are some walls in some cells and the kangaroos cannot enter the cells with walls. The other cells are empty. The kangaroos can move from an empty cell to an adjacent empty cell in four directions: up, down, left, and right.\n>\n> There is exactly one kangaroo in every empty cell in the beginning and the player can control the kangaroos by pressing the button U, D, L, R on the keyboard. The kangaroos will move simultaneously according to the button you press.\n>\n> The contestant needs to construct an operating sequence of at most $5 \\times 10^4$ steps consisting of U, D, L, R only to achieve the goal.\n\nIn the 2020 contest, problem A, $\\textbf{\\textit{Ah, It's Yesterday Once More}}$, requires the contestants to construct an input map to hack the following code of the problem described before:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstring s = \"UDLR\";\nint main()\n{\n  srand(time(NULL));\n  for (int i = 1; i <= 50000; i++) putchar(s[rand() % 4]);\n  return 0;\n}\n```\n\nNow in the 2021 contest, Paimon prepares another version of the problem for you. You are given a grid with $n$ rows and $n$ columns ($2 \\leq n \\leq 500$). All cells are empty and there is one kangaroo standing in each cell.\n\nSimilarly, you can control the kangaroos by pressing the button U, D, L, R on the keyboard. The kangaroos will move simultaneously according to the button you press. Specifically, for any kangaroo located in the cell on the $i$-th row and the $j$-th column, indicated by $(i,j)$:\n\n- Button U: it will move to $(i-1,j)$ if $i>1$. Otherwise, it will stay in the same grid.\n- Button D: it will move to $(i+1,j)$ if $i<n$. Otherwise, it will stay in the same grid.\n- Button L: it will move to $(i,j-1)$ if $j>1$. Otherwise, it will stay in the same grid.\n- Button R: it will move to $(i,j+1)$ if $j<n$. Otherwise, it will stay in the same grid.\n\nYou need to construct an operating sequence consisting only of characters `U`, `D`, `L`, and `R`. After applying it, you must make sure every kangaroo will gather at the specific cell $(a,b)$. The length of the operating sequence cannot exceed $3(n-1)$.", "inputFormat": "There is only one test case in each test file.\n\nThe first and only line of the input contains three integers $n$, $a$, $b$ ($2 \\leq n \\leq 500$, $ 1 \\leq a,b \\leq n$) indicating the size of the grid and the target cell.", "outputFormat": "Output a string consisting only of characters `U`, `D`, `L` and `R` in one line. And its length mustn't exceed $3(n-1)$. It can be proved that the answer always exists.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Oops, It's Yesterday Twice More", "background": "", "description": "After the great success in 2018, 2019, and 2020, Nanjing University of Aeronautics and Astronautics (NUAA) will host the $\\textit{International Collegiate Programming Contest}$ (ICPC) Nanjing regional for the fourth time.\n\nTeam $\\textbf{\\textit{Power of Two}}$ and team $\\textbf{\\textit{Three Hold Two}}$ won the champion for Tsinghua University in 2018 and 2019. In 2020, team $\\textbf{\\textit{Inverted Cross}}$ from Peking University won the champion. In 2021, there are around $700$ teams including $\\textbf{the defending champion}$ participating in the contest. We are so excited to see who will win this year!\n\nAlthough we can't gather in Nanjing this time due to the pandemic, we should still be grateful for the hard work done by all staff and volunteers for this contest. Thank you all for your great contribution to this contest!\n\nIn the 2018 contest, problem K, $\\textbf{\\textit{Kangaroo Puzzle}}$, requires the contestants to construct an operation sequence for the game:\n\n> The puzzle is a grid with $n$ rows and $m$ columns ($1 \\le n, m \\le 20$) and there are some (at least $2$) kangaroos standing in the puzzle. The player's goal is to control them to get together. There are some walls in some cells and the kangaroos cannot enter the cells with walls. The other cells are empty. The kangaroos can move from an empty cell to an adjacent empty cell in four directions: up, down, left, and right.\n>\n> There is exactly one kangaroo in every empty cell in the beginning and the player can control the kangaroos by pressing the button U, D, L, R on the keyboard. The kangaroos will move simultaneously according to the button you press.\n>\n> The contestant needs to construct an operating sequence of at most $5 \\times 10^4$ steps consisting of U, D, L, R only to achieve the goal.\n\nIn the 2020 contest, problem A, $\\textbf{\\textit{Ah, It's Yesterday Once More}}$, requires the contestants to construct an input map to hack the following code of the problem described before:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstring s = \"UDLR\";\nint main()\n{\n  srand(time(NULL));\n  for (int i = 1; i <= 50000; i++) putchar(s[rand() % 4]);\n  return 0;\n}\n```\n\nNow in the 2021 contest, Paimon prepares another version of the problem for you. You are given a grid with $n$ rows and $n$ columns ($2 \\leq n \\leq 500$). All cells are empty and there is one kangaroo standing in each cell.\n\nSimilarly, you can control the kangaroos by pressing the button U, D, L, R on the keyboard. The kangaroos will move simultaneously according to the button you press. Specifically, for any kangaroo located in the cell on the $i$-th row and the $j$-th column, indicated by $(i,j)$:\n\n- Button U: it will move to $(i-1,j)$ if $i>1$. Otherwise, it will stay in the same grid.\n- Button D: it will move to $(i+1,j)$ if $i<n$. Otherwise, it will stay in the same grid.\n- Button L: it will move to $(i,j-1)$ if $j>1$. Otherwise, it will stay in the same grid.\n- Button R: it will move to $(i,j+1)$ if $j<n$. Otherwise, it will stay in the same grid.\n\nYou need to construct an operating sequence consisting only of characters `U`, `D`, `L`, and `R`. After applying it, you must make sure every kangaroo will gather at the specific cell $(a,b)$. The length of the operating sequence cannot exceed $3(n-1)$.", "inputFormat": "There is only one test case in each test file.\n\nThe first and only line of the input contains three integers $n$, $a$, $b$ ($2 \\leq n \\leq 500$, $ 1 \\leq a,b \\leq n$) indicating the size of the grid and the target cell.", "outputFormat": "Output a string consisting only of characters `U`, `D`, `L` and `R` in one line. And its length mustn't exceed $3(n-1)$. It can be proved that the answer always exists.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Oops, It's Yesterday Twice More", "background": "", "description": "继 2018、2019 和 2020 年的巨大成功之后，南京航空航天大学（NUAA）将第四次举办国际大学生程序设计竞赛（ICPC）南京赛区。\n\n2018 年和 2019 年，清华大学的队伍“Power of Two”和“三人行二”分别获得了冠军。2020 年，北京大学的队伍“Inverted Cross”赢得了冠军。2021 年，大约有 700 支队伍，包括卫冕冠军，参加了比赛。我们非常期待今年谁将获胜！\n\n尽管由于疫情我们无法在南京聚集，但我们仍然应该感谢所有工作人员和志愿者为这次比赛所做的辛勤工作。感谢你们对这次比赛的巨大贡献！\n\n在 2018 年的比赛中，问题 K，“Kangaroo Puzzle”，要求参赛者为游戏构建一个操作序列：\n\n> 这个谜题是一个有 $n$ 行 $m$ 列的网格（$1 \\le n, m \\le 20$），其中有一些（至少 2 个）袋鼠站在网格中。玩家的目标是控制它们聚在一起。某些格子中有墙，袋鼠不能进入有墙的格子。其他格子是空的。袋鼠可以从一个空格子移动到相邻的空格子，方向有四个：上、下、左、右。\n>\n> 一开始每个空格子中恰好有一个袋鼠，玩家可以通过按键盘上的 U、D、L、R 按钮来控制袋鼠。袋鼠将根据你按下的按钮同时移动。\n>\n> 参赛者需要构建一个最多 $5 \\times 10^4$ 步的操作序列，仅包含 U、D、L、R，以实现目标。\n\n在 2020 年的比赛中，问题 A，“Ah, It's Yesterday Once More”，要求参赛者构建一个输入地图以破解之前描述的问题的以下代码：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstring s = \"UDLR\";\nint main()\n{\n  srand(time(NULL));\n  for (int i = 1; i <= 50000; i++) putchar(s[rand() % 4]);\n  return 0;\n}\n```\n\n现在在 2021 年的比赛中，Paimon 为你准备了该问题的另一个版本。你得到一个有 $n$ 行 $n$ 列的网格（$2 \\leq n \\leq 500$）。所有格子都是空的，每个格子中有一个袋鼠。\n\n同样，你可以通过按键盘上的 U、D、L、R 按钮来控制袋鼠。袋鼠将根据你按下的按钮同时移动。具体来说，对于位于第 $i$ 行第 $j$ 列的袋鼠，用 $(i,j)$ 表示：\n\n- 按钮 U：如果 $i>1$，它将移动到 $(i-1,j)$。否则，它将停留在同一格子。\n- 按钮 D：如果 $i<n$，它将移动到 $(i+1,j)$。否则，它将停留在同一格子。\n- 按钮 L：如果 $j>1$，它将移动到 $(i,j-1)$。否则，它将停留在同一格子。\n- 按钮 R：如果 $j<n$，它将移动到 $(i,j+1)$。否则，它将停留在同一格子。\n\n你需要构建一个仅由字符 `U`、`D`、`L` 和 `R` 组成的操作序列。在应用它之后，你必须确保每只袋鼠都聚集在特定的格子 $(a,b)$。操作序列的长度不能超过 $3(n-1)$。", "inputFormat": "每个测试文件中只有一个测试用例。\n\n输入的第一行也是唯一一行包含三个整数 $n$，$a$，$b$（$2 \\leq n \\leq 500$，$1 \\leq a,b \\leq n$），表示网格的大小和目标格子。", "outputFormat": "输出一个仅由字符 `U`、`D`、`L` 和 `R` 组成的字符串，并且其长度不能超过 $3(n-1)$。可以证明答案总是存在的。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9841", "type": "P", "difficulty": 7, "samples": [["4\n0 1 1\n0 0\n1\n1 0 0\n1 1\n0\n", "1\n2 1 3 4 1\n"], ["4\n3 3 3\n0 0\n0\n0 0 0\n3 3\n3\n", "1\n1 2 3 4 -3\n"], ["5\n-12 15 -12 1\n37 14 7\n7 9\n-11\n12 5 1 13\n-1 -4 -7\n-5 -9\n18\n", "-1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["搜索", "2021", "Special Judge", "O2优化", "构造", "ICPC", "分类讨论", "南京"], "title": "[ICPC 2021 Nanjing R] Puzzle in Inazuma", "background": "", "description": "Every traveler knows that they'll be rewarded with a treasure box after solving the puzzles in Inazuma, but few know that these puzzles are designed by Yae Miko, the Guuji of the Grand Narukami Shrine, to test whether the traveler is strong enough to save her friend Raiden Shogun and people of Inazuma.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p50zu2m6.png)\n\nAfter a traveler passes the test Yae will have to reset the puzzles to the initial state. But this time she has some troubles and even doubts that whether some of them are already broken.\n\nYae's puzzle can be considered as a weighted undirected complete graph $G$ before resetting. We also denote the initial state as another weighted undirected complete graph $H$. Both $G$ and $H$ have exactly $n$ vertices, and these vertices are labeled from $1$ to $n$.\n\nTo reset graph $G$ to $H$ Yae can perform the following operation any number of times:\n- First select four distinct vertices $a$, $b$, $c$, $d$ and an integer $x$. Note that she can select a different set of $a$, $b$, $c$, $d$ and $x$ each time.\n- Let $(i, j)$ be the edge between vertices $i$ and $j$. Increase the weight of $(a, b)$, $(a, c)$ and $(a, d)$ by $x$ and also decrease the weight of $(b, c)$, $(b, d)$ and $(c, d)$ by $x$.\n\nPlease help Yae determine whether she can change graph $G$ to graph $H$. If yes you also shall tell her the detailed steps.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains an integer $n$ ($4 \\leq n \\leq 100$) indicating the number of vertices in graph $G$ and $H$.\n\nFor the following $(n - 1)$ lines, the $i$-th line contains $(n - i)$ integers $w_{i, i + 1}, w_{i, i + 2}, \\cdots, w_{i, n}$ ($-100 \\le w_{i, j} \\le 100$) where $w_{i, j}$ indicates the weight of the edge connecting vertices $i$ and $j$ in graph $G$.\n\nFor the following $(n - 1)$ lines, the $i$-th line contains $(n - i)$ integers $v_{i, i + 1}, v_{i, i + 2}, \\cdots, v_{i, n}$ ($-100 \\le v_{i, j} \\le 100$) where $v_{i, j}$ indicates the weight of the edge connecting vertices $i$ and $j$ in graph $H$.", "outputFormat": "If Yae cannot change $G$ to $H$, output `-1`.\n\nOtherwise first output an integer $m$ ($0 \\le m \\le 10^5$) in one line indicating the number of operations Yae needs.\n\nFor the following $m$ lines, output five integers $a_i$, $b_i$, $c_i$, $d_i$ and $x_i$ in the $i$-th line separated by a space, indicating that for the $i$-th operation Yae choose vertices $a_i$, $b_i$, $c_i$, $d_i$ and integer $x_i$. Note that $a_i$, $b_i$, $c_i$, $d_i$ must be distinct and $-10^9 \\le x_i \\le 10^9$.\n\nIt can be proved that if graph $G$ can be changed to graph $H$ there exists a solution with no more than $10^5$ operations.\n\nNote that you don't have to minimize $m$. If there are multiple solutions, output any of them.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Puzzle in Inazuma", "background": "", "description": "Every traveler knows that they'll be rewarded with a treasure box after solving the puzzles in Inazuma, but few know that these puzzles are designed by Yae Miko, the Guuji of the Grand Narukami Shrine, to test whether the traveler is strong enough to save her friend Raiden Shogun and people of Inazuma.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p50zu2m6.png)\n\nAfter a traveler passes the test Yae will have to reset the puzzles to the initial state. But this time she has some troubles and even doubts that whether some of them are already broken.\n\nYae's puzzle can be considered as a weighted undirected complete graph $G$ before resetting. We also denote the initial state as another weighted undirected complete graph $H$. Both $G$ and $H$ have exactly $n$ vertices, and these vertices are labeled from $1$ to $n$.\n\nTo reset graph $G$ to $H$ Yae can perform the following operation any number of times:\n- First select four distinct vertices $a$, $b$, $c$, $d$ and an integer $x$. Note that she can select a different set of $a$, $b$, $c$, $d$ and $x$ each time.\n- Let $(i, j)$ be the edge between vertices $i$ and $j$. Increase the weight of $(a, b)$, $(a, c)$ and $(a, d)$ by $x$ and also decrease the weight of $(b, c)$, $(b, d)$ and $(c, d)$ by $x$.\n\nPlease help Yae determine whether she can change graph $G$ to graph $H$. If yes you also shall tell her the detailed steps.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains an integer $n$ ($4 \\leq n \\leq 100$) indicating the number of vertices in graph $G$ and $H$.\n\nFor the following $(n - 1)$ lines, the $i$-th line contains $(n - i)$ integers $w_{i, i + 1}, w_{i, i + 2}, \\cdots, w_{i, n}$ ($-100 \\le w_{i, j} \\le 100$) where $w_{i, j}$ indicates the weight of the edge connecting vertices $i$ and $j$ in graph $G$.\n\nFor the following $(n - 1)$ lines, the $i$-th line contains $(n - i)$ integers $v_{i, i + 1}, v_{i, i + 2}, \\cdots, v_{i, n}$ ($-100 \\le v_{i, j} \\le 100$) where $v_{i, j}$ indicates the weight of the edge connecting vertices $i$ and $j$ in graph $H$.", "outputFormat": "If Yae cannot change $G$ to $H$, output `-1`.\n\nOtherwise first output an integer $m$ ($0 \\le m \\le 10^5$) in one line indicating the number of operations Yae needs.\n\nFor the following $m$ lines, output five integers $a_i$, $b_i$, $c_i$, $d_i$ and $x_i$ in the $i$-th line separated by a space, indicating that for the $i$-th operation Yae choose vertices $a_i$, $b_i$, $c_i$, $d_i$ and integer $x_i$. Note that $a_i$, $b_i$, $c_i$, $d_i$ must be distinct and $-10^9 \\le x_i \\le 10^9$.\n\nIt can be proved that if graph $G$ can be changed to graph $H$ there exists a solution with no more than $10^5$ operations.\n\nNote that you don't have to minimize $m$. If there are multiple solutions, output any of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Puzzle in Inazuma", "background": null, "description": "每个旅行者都知道，在稻妻解开谜题后，他们会得到一个宝箱，但很少有人知道这些谜题是由鸣神大社的宫司八重神子设计的，用来测试旅行者是否足够强大以拯救她的朋友雷电将军和稻妻的人民。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p50zu2m6.png)\n\n在旅行者通过测试后，八重神子必须将谜题重置为初始状态。但这次她遇到了一些麻烦，甚至怀疑其中一些谜题是否已经损坏。\n\n在重置之前，八重神子的谜题可以被视为一个加权无向完全图 $G$。我们也将初始状态表示为另一个加权无向完全图 $H$。$G$ 和 $H$ 都有 $n$ 个顶点，这些顶点从 $1$ 到 $n$ 标记。\n\n为了将图 $G$ 重置为 $H$，八重神子可以执行以下操作任意次：\n- 首先选择四个不同的顶点 $a$，$b$，$c$，$d$ 和一个整数 $x$。注意，每次她可以选择不同的 $a$，$b$，$c$，$d$ 和 $x$。\n- 令 $(i, j)$ 为顶点 $i$ 和 $j$ 之间的边。将 $(a, b)$，$(a, c)$ 和 $(a, d)$ 的权重增加 $x$，同时将 $(b, c)$，$(b, d)$ 和 $(c, d)$ 的权重减少 $x$。\n\n请帮助八重神子确定她是否可以将图 $G$ 变为图 $H$。如果可以，你还需要告诉她详细的步骤。", "inputFormat": "每个测试文件中只有一个测试用例。\n\n输入的第一行包含一个整数 $n$ ($4 \\leq n \\leq 100$)，表示图 $G$ 和 $H$ 中的顶点数。\n\n接下来的 $(n - 1)$ 行中，第 $i$ 行包含 $(n - i)$ 个整数 $w_{i, i + 1}, w_{i, i + 2}, \\cdots, w_{i, n}$ ($-100 \\le w_{i, j} \\le 100$)，其中 $w_{i, j}$ 表示图 $G$ 中连接顶点 $i$ 和 $j$ 的边的权重。\n\n接下来的 $(n - 1)$ 行中，第 $i$ 行包含 $(n - i)$ 个整数 $v_{i, i + 1}, v_{i, i + 2}, \\cdots, v_{i, n}$ ($-100 \\le v_{i, j} \\le 100$)，其中 $v_{i, j}$ 表示图 $H$ 中连接顶点 $i$ 和 $j$ 的边的权重。", "outputFormat": "如果八重神子不能将 $G$ 变为 $H$，输出 `-1`。\n\n否则，首先输出一个整数 $m$ ($0 \\le m \\le 10^5$) 表示八重神子需要的操作次数。\n\n在接下来的 $m$ 行中，每行输出五个整数 $a_i$，$b_i$，$c_i$，$d_i$ 和 $x_i$，用空格分隔，表示在第 $i$ 次操作中，八重神子选择顶点 $a_i$，$b_i$，$c_i$，$d_i$ 和整数 $x_i$。注意，$a_i$，$b_i$，$c_i$，$d_i$ 必须是不同的，且 $-10^9 \\le x_i \\le 10^9$。\n\n可以证明，如果图 $G$ 可以变为图 $H$，则存在一个不超过 $10^5$ 次操作的解决方案。\n\n注意，你不必最小化 $m$。如果有多个解决方案，输出其中任何一个。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9842", "type": "P", "difficulty": 3, "samples": [["5 2\n2 2 4 4 4\n", "5\n"], ["7 1\n3 2 3 2 2 2 3\n", "6\n"], ["7 1\n2 3 2 3 2 3 3\n", "5\n"], ["9 -100\n-1 -2 1 2 -1 -2 1 -2 1\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2021", "Special Judge", "O2优化", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Klee in Solitary Confinement", "background": "", "description": "Since the traveler comes, People in Monstadt suddenly raise great interest in computer programming and algorithms, including Klee, the Spark Knight of the Knights of Favonius.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xcnn0v4q.png)\n\nBeing sent to solitary confinement by Jean again, Klee decides to spend time learning the famous Mo's algorithm, which can compute with a time complexity of $\\mathcal{O}(n^{1.5})$ for some range query problem without modifications.\n\nTo check whether Klee has truly mastered the algorithm (or in fact making another bombs secretly), Jean gives her a problem of an integer sequence $a_1, a_2, \\cdots, a_n$ along with some queries $[l_i, r_i]$ requiring her to find the mode number in the contiguous subsequence $a_{l_i}, a_{l_i + 1}, \\cdots, a_{r_i}$. The mode number is the most common number (that is to say, the number which appears the maximum number of times) in the subsequence.\n\nWith the help of Mo's algorithm, Klee solves that problem without effort, but another problem comes into her mind. Given an integer sequence $a_1, a_2, \\cdots, a_n$ of length $n$ and an integer $k$, you can perform the following operation at most once: Choose two integers $l$ and $r$ such that $1 \\le l \\le r \\le n$ and add $k$ to every $a_i$ where $l \\le i \\le r$. Note that it is OK not to perform this operation. Compute the maximum occurrence of the mode number of the whole sequence if you choose to perform (or not perform) the operation optimally.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains two integers $n$ and $k$ ($1 \\le n \\le 10^6$, $-10^6 \\le k \\le 10^6$) indicating the length of the sequence and the additive number.\n\nThe second line of the input contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($-10^6 \\le a_i \\le 10^6$) indicating the original sequence.", "outputFormat": "Output one line containing one integer indicating the maximum occurrence of the mode number of the whole sequence after performing (or not performing) the operation.", "hint": "For the first sample test case, choose $l = 1$ and $r = 2$ and we'll result in the sequence $\\{4, 4, 4, 4, 4\\}$. The mode number is obviously $4$ which appears $5$ times.\n\nFor the second sample test case, choose $l = 4$ and $r = 6$ and we'll result in the sequence $\\{3, 2, 3, 3, 3, 3, 3\\}$. The mode number is $3$ which appears $6$ times.\n\nFor the fourth sample test case, choose not to perform the operation. The mode number is $1$ and $-2$ which both appear $3$ times.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Klee in Solitary Confinement", "background": "", "description": "Since the traveler comes, People in Monstadt suddenly raise great interest in computer programming and algorithms, including Klee, the Spark Knight of the Knights of Favonius.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xcnn0v4q.png)\n\nBeing sent to solitary confinement by Jean again, Klee decides to spend time learning the famous Mo's algorithm, which can compute with a time complexity of $\\mathcal{O}(n^{1.5})$ for some range query problem without modifications.\n\nTo check whether Klee has truly mastered the algorithm (or in fact making another bombs secretly), Jean gives her a problem of an integer sequence $a_1, a_2, \\cdots, a_n$ along with some queries $[l_i, r_i]$ requiring her to find the mode number in the contiguous subsequence $a_{l_i}, a_{l_i + 1}, \\cdots, a_{r_i}$. The mode number is the most common number (that is to say, the number which appears the maximum number of times) in the subsequence.\n\nWith the help of Mo's algorithm, Klee solves that problem without effort, but another problem comes into her mind. Given an integer sequence $a_1, a_2, \\cdots, a_n$ of length $n$ and an integer $k$, you can perform the following operation at most once: Choose two integers $l$ and $r$ such that $1 \\le l \\le r \\le n$ and add $k$ to every $a_i$ where $l \\le i \\le r$. Note that it is OK not to perform this operation. Compute the maximum occurrence of the mode number of the whole sequence if you choose to perform (or not perform) the operation optimally.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains two integers $n$ and $k$ ($1 \\le n \\le 10^6$, $-10^6 \\le k \\le 10^6$) indicating the length of the sequence and the additive number.\n\nThe second line of the input contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($-10^6 \\le a_i \\le 10^6$) indicating the original sequence.", "outputFormat": "Output one line containing one integer indicating the maximum occurrence of the mode number of the whole sequence after performing (or not performing) the operation.", "hint": "For the first sample test case, choose $l = 1$ and $r = 2$ and we'll result in the sequence $\\{4, 4, 4, 4, 4\\}$. The mode number is obviously $4$ which appears $5$ times.\n\nFor the second sample test case, choose $l = 4$ and $r = 6$ and we'll result in the sequence $\\{3, 2, 3, 3, 3, 3, 3\\}$. The mode number is $3$ which appears $6$ times.\n\nFor the fourth sample test case, choose not to perform the operation. The mode number is $1$ and $-2$ which both appear $3$ times.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Klee in Solitary Confinement", "background": null, "description": "自从旅行者来到蒙德，蒙德的人们突然对计算机编程和算法产生了极大的兴趣，包括西风骑士团的火花骑士可莉。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xcnn0v4q.png)\n\n被琴再次关进禁闭室后，可莉决定花时间学习著名的莫队算法，该算法可以在不进行修改的情况下以 $\\mathcal{O}(n^{1.5})$ 的时间复杂度计算某些区间查询问题。\n\n为了检查可莉是否真正掌握了该算法（或者实际上是在秘密制造另一个炸弹），琴给了她一个整数序列 $a_1, a_2, \\cdots, a_n$ 和一些查询 $[l_i, r_i]$，要求她找到连续子序列 $a_{l_i}, a_{l_i + 1}, \\cdots, a_{r_i}$ 中的众数。众数是指在子序列中出现次数最多的数字。\n\n在莫队算法的帮助下，可莉毫不费力地解决了这个问题，但她脑海中又出现了另一个问题。给定一个长度为 $n$ 的整数序列 $a_1, a_2, \\cdots, a_n$ 和一个整数 $k$，你可以最多进行一次以下操作：选择两个整数 $l$ 和 $r$，使得 $1 \\le l \\le r \\le n$，并 $a_i$ 加上 $k$，其中 $l \\le i \\le r$。注意可以选择不进行此操作。计算如果你选择最优地进行（或不进行）操作，整个序列的众数的最大出现次数。", "inputFormat": "每个测试文件中只有一个测试用例。\n\n输入的第一行包含两个整数 $n$ 和 $k$（$1 \\le n \\le 10^6$，$-10^6 \\le k \\le 10^6$），表示序列的长度和要添加的数。\n\n输入的第二行包含 $n$ 个整数 $a_1, a_2, \\cdots, a_n$（$-10^6 \\le a_i \\le 10^6$），表示原始序列。", "outputFormat": "输出一行，包含一个整数，表示在最优地进行（或不进行）操作后，整个序列的众数的最大出现次数。", "hint": "对于第一个样例测试用例，选择 $l = 1$ 和 $r = 2$，我们将得到序列 $\\{4, 4, 4, 4, 4\\}$。显然，众数是 $4$，出现了 $5$ 次。\n\n对于第二个样例测试用例，选择 $l = 4$ 和 $r = 6$，我们将得到序列 $\\{3, 2, 3, 3, 3, 3, 3\\}$。众数是 $3$，出现了 $6$ 次。\n\n对于第四个样例测试用例，选择不进行操作。众数是 $1$ 和 $-2$，它们都出现了 $3$ 次。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9843", "type": "P", "difficulty": 4, "samples": [["3\n5\n2 3 2 1 5\n3\n1 2 3\n1\n1\n", "0 2 3 5 7\n0 2 4\n0\n"]], "limits": {"time": [1000, 1000], "memory": [262144, 262144]}, "tags": ["2021", "Special Judge", "O2优化", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Paimon Sorting", "background": "", "description": "Paimon just invents a new sorting algorithm which looks much like $\\textit{bubble sort}$, with a few differences. It accepts a $1$-indexed sequence $A$ of length $n$ and sorts it. Its pseudo-code is shown below.\n\n```cpp\n// The Sorting Algorithm\nSORT(A)\n  for i from 1 to n // n is the number of elements if A\n    for j from 1 to n\n      if a[i] < a[j] // a[i] is the i-th element in A\n        Swap a[i] and a[j]\n```\n\n\nIf you don't believe this piece of algorithm can sort a sequence it will also be your task to prove it. Anyway here comes the question:\n\nGiven an integer sequence $A = a_1, a_2, \\cdots, a_n$ of length $n$, for each of its prefix $A_k$ of length $k$ (that is, for each $1 \\le k \\le n$, consider the subsequence $A_k = a_1, a_2, \\cdots, a_k$), count the number of swaps performed if we call $\\text{SORT}(A_k)$.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$) indicating the length of the sequence.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le n$) indicating the given sequence.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing $n$ integers $s_1, s_2, \\cdots, s_n$ separated by a space, where $s_i$ is the number of swaps performed if we call $\\text{SORT}(A_i)$.\n\nPlease, DO NOT output extra spaces at the end of each line or your solution may be considered incorrect!", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Paimon Sorting", "background": "", "description": "Paimon just invents a new sorting algorithm which looks much like $\\textit{bubble sort}$, with a few differences. It accepts a $1$-indexed sequence $A$ of length $n$ and sorts it. Its pseudo-code is shown below.\n\n```cpp\n// The Sorting Algorithm\nSORT(A)\n  for i from 1 to n // n is the number of elements if A\n    for j from 1 to n\n      if a[i] < a[j] // a[i] is the i-th element in A\n        Swap a[i] and a[j]\n```\n\n\nIf you don't believe this piece of algorithm can sort a sequence it will also be your task to prove it. Anyway here comes the question:\n\nGiven an integer sequence $A = a_1, a_2, \\cdots, a_n$ of length $n$, for each of its prefix $A_k$ of length $k$ (that is, for each $1 \\le k \\le n$, consider the subsequence $A_k = a_1, a_2, \\cdots, a_k$), count the number of swaps performed if we call $\\text{SORT}(A_k)$.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$) indicating the length of the sequence.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le n$) indicating the given sequence.\n\nIt's guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing $n$ integers $s_1, s_2, \\cdots, s_n$ separated by a space, where $s_i$ is the number of swaps performed if we call $\\text{SORT}(A_i)$.\n\nPlease, DO NOT output extra spaces at the end of each line or your solution may be considered incorrect!", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Paimon Sorting", "background": "", "description": "派蒙刚刚发明了一种新的排序算法，看起来很像“冒泡排序”，但有一些不同之处。它接受一个长度为 $n$ 的从 1 开始索引的序列 $A$ 并对其进行排序。其伪代码如下所示。\n\n```cpp\n// 排序算法\nSORT(A)\n  for i from 1 to n // n 是 A 中元素的数量\n    for j from 1 to n\n      if a[i] < a[j] // a[i] 是 A 中的第 i 个元素\n        Swap a[i] and a[j]\n```\n\n如果你不相信这段算法可以对一个序列进行排序，你的任务就是证明它。无论如何，问题如下：\n\n给定一个整数序列 $A = a_1, a_2, \\cdots, a_n$，对于其每个长度为 $k$ 的前缀 $A_k$（即，对于每个 $1 \\le k \\le n$，考虑子序列 $A_k = a_1, a_2, \\cdots, a_k$），计算调用 $\\text{SORT}(A_k)$ 时执行的交换次数。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含一个整数 $n$ ($1 \\le n \\le 10^5$)，表示序列的长度。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le n$)，表示给定的序列。\n\n保证所有测试用例的 $n$ 之和不超过 $10^6$。", "outputFormat": "对于每个测试用例，输出一行，包含 $n$ 个用空格分隔的整数 $s_1, s_2, \\cdots, s_n$，其中 $s_i$ 是调用 $\\text{SORT}(A_i)$ 时执行的交换次数。\n\n请不要在每行的末尾输出多余的空格，否则你的解答可能会被判为错误！", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9844", "type": "P", "difficulty": 5, "samples": [["3 1 1\n8 1 6\n2 3 2\n2 2 0 0\n", "1\n"], ["4 3 3\n2 3 2 2\n1 1 6\n1 3 3\n1 3 6\n2 2 2 3\n1 4 1 3\n4 4 2 3\n", "180\n825\n8\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["线段树", "2021", "Special Judge", "O2优化", "矩阵乘法", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Paimon Segment Tree", "background": "", "description": "Paimon just learns the persistent segment tree and decides to practice immediately. Therefore, Lumine gives her an easy problem to start:\n\nGiven a sequence $a_1, a_2, \\cdots, a_n$ of length $n$, Lumine will apply $m$ modifications to the sequence. In the $i$-th modification, indicated by three integers $l_i$, $r_i$ ($1 \\le l_i \\le r_i \\le n$) and $x_i$, Lumine will change $a_k$ to $(a_k + x_i)$ for all $l_i \\le k \\le r_i$.\n\nLet $a_{i, t}$ be the value of $a_i$ just after the $t$-th operation. This way we can keep track of all historial versions of $a_i$. Note that $a_{i,t}$ might be the same as $a_{i,t-1}$ if it hasn't been modified in the $t$-th modification. For completeness we also define $a_{i, 0}$ as the initial value of $a_i$.\n\nAfter all modifications have been applied, Lumine will give Paimon $q$ queries about the sum of squares among the historical values. The $k$-th query is indicated by four integers $l_k$, $r_k$, $x_k$ and $y_k$ and requires Paimon to calculate\n\n$$\\sum\\limits_{i=l_k}^{r_k}\\sum\\limits_{j=x_k}^{y_k} a_{i, j}^2$$\n\nPlease help Paimon compute the result for all queries. As the answer might be very large, please output the answer modulo $10^9 + 7$.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains three integers $n$, $m$ and $q$ ($1 \\le n, m, q \\le 5 \\times 10^4$) indicating the length of the sequence, the number of modifications and the number of queries.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($|a_i| < 10^9 + 7$) indicating the initial sequence.\n\nFor the following $m$ lines, the $i$-th line contains three integers $l_i$, $r_i$ and $x_i$ ($1 \\le l_i \\le r_i \\le n$, $|x_i| < 10^9 + 7$) indicating the $i$-th modification.\n\nFor the following $q$ lines, the $i$-th line contains four integers $l_i$, $r_i$, $x_i$ and $y_i$ ($1 \\le l_i \\le r_i \\le n$, $0 \\le x_i \\le y_i \\le m$) indicating the $i$-th query.", "outputFormat": "For each query output one line containing one integer indicating the answer modulo $10^9 + 7$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Paimon Segment Tree", "background": "", "description": "Paimon just learns the persistent segment tree and decides to practice immediately. Therefore, Lumine gives her an easy problem to start:\n\nGiven a sequence $a_1, a_2, \\cdots, a_n$ of length $n$, Lumine will apply $m$ modifications to the sequence. In the $i$-th modification, indicated by three integers $l_i$, $r_i$ ($1 \\le l_i \\le r_i \\le n$) and $x_i$, Lumine will change $a_k$ to $(a_k + x_i)$ for all $l_i \\le k \\le r_i$.\n\nLet $a_{i, t}$ be the value of $a_i$ just after the $t$-th operation. This way we can keep track of all historial versions of $a_i$. Note that $a_{i,t}$ might be the same as $a_{i,t-1}$ if it hasn't been modified in the $t$-th modification. For completeness we also define $a_{i, 0}$ as the initial value of $a_i$.\n\nAfter all modifications have been applied, Lumine will give Paimon $q$ queries about the sum of squares among the historical values. The $k$-th query is indicated by four integers $l_k$, $r_k$, $x_k$ and $y_k$ and requires Paimon to calculate\n\n$$\\sum\\limits_{i=l_k}^{r_k}\\sum\\limits_{j=x_k}^{y_k} a_{i, j}^2$$\n\nPlease help Paimon compute the result for all queries. As the answer might be very large, please output the answer modulo $10^9 + 7$.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains three integers $n$, $m$ and $q$ ($1 \\le n, m, q \\le 5 \\times 10^4$) indicating the length of the sequence, the number of modifications and the number of queries.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($|a_i| < 10^9 + 7$) indicating the initial sequence.\n\nFor the following $m$ lines, the $i$-th line contains three integers $l_i$, $r_i$ and $x_i$ ($1 \\le l_i \\le r_i \\le n$, $|x_i| < 10^9 + 7$) indicating the $i$-th modification.\n\nFor the following $q$ lines, the $i$-th line contains four integers $l_i$, $r_i$, $x_i$ and $y_i$ ($1 \\le l_i \\le r_i \\le n$, $0 \\le x_i \\le y_i \\le m$) indicating the $i$-th query.", "outputFormat": "For each query output one line containing one integer indicating the answer modulo $10^9 + 7$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Paimon Segment Tree", "background": null, "description": "派蒙刚刚学习了可持久化线段树，她想马上练习一下。因此，荧决定给她出一道简单的问题：\n\n给定数列 $a_1, a_2, \\cdots, a_n$，并进行 $m$ 次操作。操作包含 $3$ 个参数 $l_i, r_i$ ($1 \\le l_i \\le r_i \\le n$) 和 $x_i$，代表对该序列第 $l_i$ 到第 $r_i$ 个元素加上 $x_i$。\n\n记 $a_{i, t}$ 为 $t$ 次操作后 $a_i$ 的值。注意若 $a_i$ 未被修改，则 $a_{i,t}$ 的值与 $a_{i,t-1}$ 相同。定义 $a_{i, 0}$ 是 $a_i$ 的初始值。\n\n\n完成所有操作后，荧进行 $q$ 次询问，询问包含 $4$ 个整数 $l_k, r_k, x_k$ 和 $y_k$，派蒙需要回答\n\n$$\\sum\\limits_{i=l_k}^{r_k}\\sum\\limits_{j=x_k}^{y_k} a_{i, j}^2$$\n\n请将答案对 $10^9 + 7$ 取模后输出。", "inputFormat": "每个测试点含一组测试数据。\n\n第一行 $3$ 个整数 $n, m, q (1 \\le n, m, q \\le 5 \\times 10^4)$ 分别表示数列的长度，操作的次数和询问的次数。\n\n第 $2$ 行 $n$ 个整数 $a_1, a_2, \\cdots, a_n(|a_i| < 10^9 + 7)$，表示原始数列。\n\n接下来 $m$ 行每行 $3$ 个整数 $l_i, r_i, x_i(1 \\le l_i \\le r_i \\le n, |x_i| < 10^9 + 7)$，表示区间加操作。\n\n接下来$q$行每行包含四个整数 $l_i, r_i, x_i, y_i (1 \\le l_i \\le r_i \\le n, 0 \\le x_i \\le y_i \\le m)$，表示询问。", "outputFormat": "对每个询问单起一行输出答案模 $10^9 + 7$ 的结果。", "hint": "数据范围见输入格式。", "locale": "zh-CN"}}}
{"pid": "P9845", "type": "P", "difficulty": 7, "samples": [["3\n4\n0 3\n3 0\n2 3\n3 2\n5\n4 0\n5 -5\n-4 -2\n1 -2\n-5 -2\n4\n0 1\n1 0\n0 2\n1 1\n", "17.2111025509\n36.6326947621\n0.0000000000\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["计算几何", "2021", "Special Judge", "O2优化", "凸包", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Paimon Polygon", "background": "", "description": "Paimon just puts $(n+1)$ distinct points on the plane, one of which is a special point $O=(0,0)$, and denote the group of remaining points as $\\mathbb{S}$.\n\nWe call a point set $\\mathbb{U}$ $\\textit{strict convex set}$, if and only if $|\\mathbb{U}| \\ge 3$ and all the points from $\\mathbb{U}$ lie exactly on the convex hull built from $\\mathbb{U}$, with no three points lying on the same line.\n\nYou should divide $\\mathbb{S}$ into two sets $\\mathbb{A}$ and $\\mathbb{B}$ so that:\n- $\\mathbb{A} \\cap \\mathbb{B}=\\emptyset$.\n- $\\mathbb{A} \\cup \\mathbb{B}=\\mathbb{S}$.\n- $|\\mathbb{A}| \\ge 2, |\\mathbb{B}| \\ge 2$.\n- The point set $\\mathbb{A} \\cup \\{O\\}$ is a $\\textit{strict convex set}$, and denote its convex hull as $C_{\\mathbb{A} \\cup \\{O\\}}$.\n- The point set $\\mathbb{B} \\cup \\{O\\}$ is a $\\textit{strict convex set}$, and denote its convex hull as $C_{\\mathbb{B} \\cup \\{O\\}}$.\n- The outlines(edges) of $C_{\\mathbb{A} \\cup \\{O\\}}$ and $C_{\\mathbb{B} \\cup \\{O\\}}$ only intersect at point $O$. That is, only one point $O$ satisfies that it lies both on the outlines of $C_{\\mathbb{A} \\cup \\{O\\}}$ and $C_{\\mathbb{B} \\cup \\{O\\}}$.\n\nPlease help Paimon to maximize the sum of the perimeters of these two convex hulls. That is, find a valid division $\\mathbb{A}$ and $\\mathbb{B}$ which maximizes $(L(C_{\\mathbb{A} \\cup \\{O\\}}) + L(C_{\\mathbb{B} \\cup \\{O\\}}))$, where $L(\\text{polygon})$ means the perimeter of that polygon.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains one integer $n$ ($4 \\le n \\le 5 \\times 10^5$) indicating the number of points in $\\mathbb{S}$.\n\nFor the following $n$ lines, the $i$-th line contains two integers $x_i$ and $y_i$ ($-10^9 \\le x_i, y_i \\le 10^9$, $(x_i, y_i) \\ne (0, 0)$) indicating the location of the $i$-th point in $\\mathbb{S}$.\n\nIt's guaranteed that the points given in the same test case are pairwise different. However, there may be three points lying on the same line.\n\nIt's also guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing a number indicating the maximum total perimeter. If there does not exist a valid division output `0` instead.\n\nYour answer will be accepted if the relative or absolute error is less than $10^{-6}$.", "hint": "A valid division (left) and an invalid division (right) of the first sample test case are shown below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v17tmtdh.png)", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Paimon Polygon", "background": "", "description": "Paimon just puts $(n+1)$ distinct points on the plane, one of which is a special point $O=(0,0)$, and denote the group of remaining points as $\\mathbb{S}$.\n\nWe call a point set $\\mathbb{U}$ $\\textit{strict convex set}$, if and only if $|\\mathbb{U}| \\ge 3$ and all the points from $\\mathbb{U}$ lie exactly on the convex hull built from $\\mathbb{U}$, with no three points lying on the same line.\n\nYou should divide $\\mathbb{S}$ into two sets $\\mathbb{A}$ and $\\mathbb{B}$ so that:\n- $\\mathbb{A} \\cap \\mathbb{B}=\\emptyset$.\n- $\\mathbb{A} \\cup \\mathbb{B}=\\mathbb{S}$.\n- $|\\mathbb{A}| \\ge 2, |\\mathbb{B}| \\ge 2$.\n- The point set $\\mathbb{A} \\cup \\{O\\}$ is a $\\textit{strict convex set}$, and denote its convex hull as $C_{\\mathbb{A} \\cup \\{O\\}}$.\n- The point set $\\mathbb{B} \\cup \\{O\\}$ is a $\\textit{strict convex set}$, and denote its convex hull as $C_{\\mathbb{B} \\cup \\{O\\}}$.\n- The outlines(edges) of $C_{\\mathbb{A} \\cup \\{O\\}}$ and $C_{\\mathbb{B} \\cup \\{O\\}}$ only intersect at point $O$. That is, only one point $O$ satisfies that it lies both on the outlines of $C_{\\mathbb{A} \\cup \\{O\\}}$ and $C_{\\mathbb{B} \\cup \\{O\\}}$.\n\nPlease help Paimon to maximize the sum of the perimeters of these two convex hulls. That is, find a valid division $\\mathbb{A}$ and $\\mathbb{B}$ which maximizes $(L(C_{\\mathbb{A} \\cup \\{O\\}}) + L(C_{\\mathbb{B} \\cup \\{O\\}}))$, where $L(\\text{polygon})$ means the perimeter of that polygon.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains one integer $n$ ($4 \\le n \\le 5 \\times 10^5$) indicating the number of points in $\\mathbb{S}$.\n\nFor the following $n$ lines, the $i$-th line contains two integers $x_i$ and $y_i$ ($-10^9 \\le x_i, y_i \\le 10^9$, $(x_i, y_i) \\ne (0, 0)$) indicating the location of the $i$-th point in $\\mathbb{S}$.\n\nIt's guaranteed that the points given in the same test case are pairwise different. However, there may be three points lying on the same line.\n\nIt's also guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing a number indicating the maximum total perimeter. If there does not exist a valid division output `0` instead.\n\nYour answer will be accepted if the relative or absolute error is less than $10^{-6}$.", "hint": "A valid division (left) and an invalid division (right) of the first sample test case are shown below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v17tmtdh.png)", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Paimon Polygon", "background": "", "description": "派蒙在平面上放置了$n+1$个互异的点，其中有一特殊点$O=(0,0)$，并记其余点为$\\mathbb{S}$。\n\n我们称一个点集 $\\mathbb{U}$ 为$\\textit{strict convex set}$，当且仅当点集中点的个数大于等于3（$|\\mathbb{U}| \\ge 3$）且$\\mathbb{U}$中的所有点位于$\\mathbb{U}$构成的凸包上，且任意三点不共线。\n\n\n你需要将$\\mathbb{S}$划分为两个集合 $\\mathbb{A}$ 和$\\mathbb{B}$，使其满足\n- $\\mathbb{A} \\cap \\mathbb{B}=\\emptyset$.\n- $\\mathbb{A} \\cup \\mathbb{B}=\\mathbb{S}$.\n- $|\\mathbb{A}| \\ge 2, |\\mathbb{B}| \\ge 2$.\n\n- 点集 $\\mathbb{A} \\cup \\{O\\}$ 是 $\\textit{strict convex set}$，并记它的凸包为$C_{\\mathbb{A} \\cup \\{O\\}}$。\n- 点集 $\\mathbb{B} \\cup \\{O\\}$是 $\\textit{strict convex set}$，并记它的凸包为 $C_{\\mathbb{B} \\cup \\{O\\}}$。\n- $C_{\\mathbb{A} \\cup \\{O\\}}$和 $C_{\\mathbb{B} \\cup \\{O\\}}$ 的轮廓 仅在 $O$相交。 这也就是说，仅有点$O$既在$C_{\\mathbb{A} \\cup \\{O\\}}$的轮廓上，又在$C_{\\mathbb{B} \\cup \\{O\\}}$的轮廓上。\n  \n请协助派蒙计算出这两个凸包周长之和的最大值。\n这也就是说，找到一个合法的划分方案$\\mathbb{A}$ 和 $\\mathbb{B}$，使得 $(L(C_{\\mathbb{A} \\cup \\{O\\}}) + L(C_{\\mathbb{B} \\cup \\{O\\}}))$最大，其中$L(\\text{polygon})$代表多边形的周长。", "inputFormat": "多组测试数据，第一行给出数据组数 $T$。\n\n第一行给出一个整数 $n$ ($4 \\le n \\le 5 \\times 10^5$) ，表示 $\\mathbb{S}$ 中点的个数。\n\n接下来$n$行，第$i$行 包含两个整数 $x_i$ 和 $y_i$ ($-10^9 \\le x_i, y_i \\le 10^9$, $(x_i, y_i) \\ne (0, 0)$) 表示 $\\mathbb{S}$ 中第 $i$个点的坐标。\n\n保证同一组测试数据中的点互异，但可能存在三点共线。\n\n保证 所有测试数据中$n$之和不超过 $10^6$.", "outputFormat": "每组测试数据单起一行输出一个整数，表示两个凸包的周长之和的最大值。如不存在合法的划分方案，输出`0`。\n与标准答案的相对或绝对误差小于 $10^{-6}$的答案会被视作正确答案。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9846", "type": "P", "difficulty": 6, "samples": [["2\n5\n1 7 3 5 4\n1 3\n2 3\n3 4\n4 5\n4 6\n1\n1000000000\n1 2\n", "16\n1000000000\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2021", "Special Judge", "O2优化", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Paimon's Tree", "background": "", "description": "Paimon has found a tree with $(n + 1)$ initially white vertices in her left pocket and decides to play with it. A tree with $(n + 1)$ nodes is an undirected connected graph with $n$ edges.\n\nPaimon will give you an integer sequence $a_1, a_2, \\cdots, a_n$ of length $n$. We first need to select a vertex in the tree and paint it black. Then we perform the following operation $n$ times.\n\nDuring the $i$-th operation, we select a white vertex $x_i$ which is directly connected with a black vertex $y_i$ by an edge, set the weight of that edge to $a_i$ and also paint $x_i$ in black. After these $n$ operations we get a tree whose edges are all weighted.\n\nWhat's the maximum length of the diameter of the weighted tree if we select the vertices optimally? The diameter of a weighted tree is the longest simple path in that tree. The length of a simple path is the sum of the weights of all edges in that path.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 5 \\times 10^3$) indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 150$) indicating the length of the sequence.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le 10^9$) indicating the sequence.\n\nFor the following $n$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n + 1$) indicating that there is an edge connecting vertex $u_i$ and $v_i$ in the tree.\n\nIt's guaranteed that there is at most $10$ test cases satisfying $n > 20$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum length of the diameter of the tree.", "hint": "For the first sample test case, we select the vertices in the order of $1, 3, 4, 5, 2, 6$, resulting in the weighted tree of the following image. It's obvious that the longest simple path is of length $16$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vamukdcv.png)", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Paimon's Tree", "background": "", "description": "Paimon has found a tree with $(n + 1)$ initially white vertices in her left pocket and decides to play with it. A tree with $(n + 1)$ nodes is an undirected connected graph with $n$ edges.\n\nPaimon will give you an integer sequence $a_1, a_2, \\cdots, a_n$ of length $n$. We first need to select a vertex in the tree and paint it black. Then we perform the following operation $n$ times.\n\nDuring the $i$-th operation, we select a white vertex $x_i$ which is directly connected with a black vertex $y_i$ by an edge, set the weight of that edge to $a_i$ and also paint $x_i$ in black. After these $n$ operations we get a tree whose edges are all weighted.\n\nWhat's the maximum length of the diameter of the weighted tree if we select the vertices optimally? The diameter of a weighted tree is the longest simple path in that tree. The length of a simple path is the sum of the weights of all edges in that path.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 5 \\times 10^3$) indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 150$) indicating the length of the sequence.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le 10^9$) indicating the sequence.\n\nFor the following $n$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n + 1$) indicating that there is an edge connecting vertex $u_i$ and $v_i$ in the tree.\n\nIt's guaranteed that there is at most $10$ test cases satisfying $n > 20$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum length of the diameter of the tree.", "hint": "For the first sample test case, we select the vertices in the order of $1, 3, 4, 5, 2, 6$, resulting in the weighted tree of the following image. It's obvious that the longest simple path is of length $16$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vamukdcv.png)", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Paimon's Tree", "background": "", "description": "# Paimon's Tree\n\n## Translation\n\n\n派蒙在她的左口袋中找到了一颗有 $(n+1)$ 个白色节点的树。一颗有 $(n+1)$ 个节点的树是一个有 $n$ 条边的无向连通图。\n\n派蒙会给你一个长度为 $n$ 的整数序列 $a_1,a_2,...,a_n$ 。我们首先需要选择这棵树中的一个节点并将它涂黑。接下来进行以下操作 $n$ 次。\n\n> 在第 $i$ 次操作中，我们选择一个与一个黑色节点 $y_i$ 直连的白色节点 $x_i$ ，将这条边的权值设为 $a_i$ ，并且将节点 $x_i$ 涂黑。\n\n进行上述的 $n$ 次操作后，我们会得到一棵每条边都有权值的树。\n\n在最优的选择节点策略下，这颗树的直径最大是多少？一棵树的直径是这棵树中的最长简单路径的长度。一条简单路径的长度是这条路径中所有边的权值之和。", "inputFormat": "一次运行将会给出多个测试数据。输入的第一行包含一个整数 $T$ ，表示测试数据的组数。\n\n对于每个测试数据：\n\n> 第一行包括一个整数 $n$ ，表示序列 $a$ 的长度。\n>\n> 第二行包括 $n$ 个整数 $a_1,a_2,...,a_n$ ，表示序列 $a$ 的内容。\n>\n> 在接下来的 $n$ 行中，第 $i$ 行包括两个整数 $u_i$ 与 $v_i$ ，表示在这棵树上 $u_i$ 与 $v_i$ 有一条连边。", "outputFormat": "对于每个测试数据，输出一行，表示这棵树在最优操作下的直径长度。", "hint": "* $1\\le T\\le 5\\times 10^3$\n* $1\\le n\\le 150$\n* $1\\le a_i\\le 10^9$\n* $1\\le u_i,v_i\\le n+1$\n* 保证每个样例中最多有 $10$ 组测试数据满足 $n>20$ 。", "locale": "zh-CN"}}}
{"pid": "P9847", "type": "P", "difficulty": 5, "samples": [["2\n5\n1 10 100 1000 10000\n1 2 1 1 1\n1 2\n1 3\n2 4\n2 5\n5\n1 10 100 1000 10000\n1 3 1 1 1\n1 2\n1 3\n2 4\n2 5\n", "10101\n10111\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2021", "Special Judge", "O2优化", "树形 DP", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Crystalfly", "background": "", "description": "Paimon is catching crystalflies on a tree, which are a special kind of butterflies in Teyvat. A tree is a connected graph consisting of $n$ vertices and $(n - 1)$ undirected edges. \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/awi9prsr.png)\n\nThere are initially $a_i$ crystalflies on the $i$-th vertex. When Paimon reaches a vertex, she can catch all the remaining crystalflies on the vertex immediately. However, the crystalflies are timid. When Paimon reaches a vertex, all the crystalflies on the adjacent vertices will be disturbed. For the $i$-th vertex, if the crystalflies on the vertex are disturbed for the first time at the beginning of the $t'$-th second, they will disappear at the end of the $(t' + t_{i})$-th second.\n\nAt the beginning of the $0$-th second, Paimon reaches vertex $1$ and stays there before the beginning of the $1$-st second. Then at the beginning of each following second, she can choose one of the two operations:\n- Move to one of the adjacent vertices of her current vertex and stay there before the beginning of the next second (if the crystalflies in the destination will disappear at the end of that second she can still catch them).\n- Stay still in her current vertex before the beginning of the next second.\n\nCalculate the maximum number of crystalflies Paimon can catch in $10^{10^{10^{10^{10}}}}$ seconds.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$) indicating the number of vertices.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le 10^9$) where $a_i$ is the number of crystalflies on the $i$-th vertex.\n\nThe third line contains $n$ integers $t_1, t_2, \\cdots, t_n$ ($1 \\le t_i \\le 3$) where $t_i$ is the time before the crystalflies on the $i$-th vertex disappear after disturbed.\n\nFor the next $(n - 1)$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$) indicating an edge connecting vertices $u_i$ and $v_i$ in the tree.\n\nIt's guaranteed that the sum of $n$ of all the test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum number of crystalflies Paimon can catch.", "hint": "For the first sample test case, follow the strategy below.\n- During the $0$-th second\n  - Paimon arrives at vertex $1$;\n  - Paimon catches $1$ crystalfly;\n  - Crystalflies in vertices $2$ and $3$ are disturbed.\n- During the $1$-st second\n  - Paimon arrives at vertex $3$;\n  - Paimon catches $100$ crystalflies.\n- During the $2$-nd second\n  - Paimon arrives at vertex $1$;\n  - Crystalflies in vertex $2$ disappears.\n- During the $3$-rd second\n  - Paimon arrives at vertex $2$;\n  - Crystalflies in vertices $4$ and $5$ are disturbed.\n- During the $4$-th second\n  - Paimon arrives at vertex $5$;\n  - Paimon catches $10000$ crystalflies;\n  - Crystalflies in vertex $4$ disappears.\n\nFor the second sample test case, the optimal strategy is the same with the first sample test case. Crystalflies in vertex $2$ are scheduled to disappear at the end of the $3$-rd (instead of the $2$-nd) second, allowing Paimon to catch them.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Crystalfly", "background": "", "description": "Paimon is catching crystalflies on a tree, which are a special kind of butterflies in Teyvat. A tree is a connected graph consisting of $n$ vertices and $(n - 1)$ undirected edges. \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/awi9prsr.png)\n\nThere are initially $a_i$ crystalflies on the $i$-th vertex. When Paimon reaches a vertex, she can catch all the remaining crystalflies on the vertex immediately. However, the crystalflies are timid. When Paimon reaches a vertex, all the crystalflies on the adjacent vertices will be disturbed. For the $i$-th vertex, if the crystalflies on the vertex are disturbed for the first time at the beginning of the $t'$-th second, they will disappear at the end of the $(t' + t_{i})$-th second.\n\nAt the beginning of the $0$-th second, Paimon reaches vertex $1$ and stays there before the beginning of the $1$-st second. Then at the beginning of each following second, she can choose one of the two operations:\n- Move to one of the adjacent vertices of her current vertex and stay there before the beginning of the next second (if the crystalflies in the destination will disappear at the end of that second she can still catch them).\n- Stay still in her current vertex before the beginning of the next second.\n\nCalculate the maximum number of crystalflies Paimon can catch in $10^{10^{10^{10^{10}}}}$ seconds.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10^5$) indicating the number of vertices.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le 10^9$) where $a_i$ is the number of crystalflies on the $i$-th vertex.\n\nThe third line contains $n$ integers $t_1, t_2, \\cdots, t_n$ ($1 \\le t_i \\le 3$) where $t_i$ is the time before the crystalflies on the $i$-th vertex disappear after disturbed.\n\nFor the next $(n - 1)$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$) indicating an edge connecting vertices $u_i$ and $v_i$ in the tree.\n\nIt's guaranteed that the sum of $n$ of all the test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum number of crystalflies Paimon can catch.", "hint": "For the first sample test case, follow the strategy below.\n- During the $0$-th second\n  - Paimon arrives at vertex $1$;\n  - Paimon catches $1$ crystalfly;\n  - Crystalflies in vertices $2$ and $3$ are disturbed.\n- During the $1$-st second\n  - Paimon arrives at vertex $3$;\n  - Paimon catches $100$ crystalflies.\n- During the $2$-nd second\n  - Paimon arrives at vertex $1$;\n  - Crystalflies in vertex $2$ disappears.\n- During the $3$-rd second\n  - Paimon arrives at vertex $2$;\n  - Crystalflies in vertices $4$ and $5$ are disturbed.\n- During the $4$-th second\n  - Paimon arrives at vertex $5$;\n  - Paimon catches $10000$ crystalflies;\n  - Crystalflies in vertex $4$ disappears.\n\nFor the second sample test case, the optimal strategy is the same with the first sample test case. Crystalflies in vertex $2$ are scheduled to disappear at the end of the $3$-rd (instead of the $2$-nd) second, allowing Paimon to catch them.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Crystalfly", "background": "", "description": "派蒙正在一棵树上抓晶蝶，这是一种提瓦特中特殊的蝴蝶。树是由 $n$ 个顶点和 $(n - 1)$ 条无向边组成的连通图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/awi9prsr.png)\n\n初始时，第 $i$ 个顶点上有 $a_i$ 只晶蝶。当派蒙到达一个顶点时，她可以立即抓住该顶点上的所有剩余晶蝶。然而，晶蝶很胆小。当派蒙到达一个顶点时，所有相邻顶点上的晶蝶都会受到惊扰。对于第 $i$ 个顶点，如果晶蝶在第 $t'$ 秒开始时首次受到惊扰，它们将在 $(t' + t_{i})$ 秒结束时消失。\n\n在第 $0$ 秒开始时，派蒙到达顶点 $1$ 并在第 $1$ 秒开始前停留在那里。然后在接下来的每一秒开始时，她可以选择以下两种操作之一：\n- 移动到当前顶点的一个相邻顶点，并在下一秒开始前停留在那里（如果目的地的晶蝶将在该秒结束时消失，她仍然可以抓住它们）。\n- 在当前顶点停留到下一秒开始前。\n\n计算派蒙在 $10^{10^{10^{10^{10}}}}$ 秒内可以抓住的最多晶蝶数量。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含一个整数 $n$ ($1 \\le n \\le 10^5$)，表示顶点的数量。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le 10^9$)，其中 $a_i$ 是第 $i$ 个顶点上的晶蝶数量。\n\n第三行包含 $n$ 个整数 $t_1, t_2, \\cdots, t_n$ ($1 \\le t_i \\le 3$)，其中 $t_i$ 是第 $i$ 个顶点上的晶蝶在受到惊扰后消失前的时间。\n\n接下来的 $(n - 1)$ 行中，第 $i$ 行包含两个整数 $u_i$ 和 $v_i$ ($1 \\le u_i, v_i \\le n$)，表示树中连接顶点 $u_i$ 和 $v_i$ 的一条边。\n\n保证所有测试用例的 $n$ 之和不超过 $10^6$。", "outputFormat": "对于每个测试用例，输出一行，包含一个整数，表示派蒙可以抓住的最多晶蝶数量。", "hint": "对于第一个样例测试用例，按照以下策略进行：\n- 在第 $0$ 秒\n  - 派蒙到达顶点 $1$；\n  - 派蒙抓住 $1$ 只晶蝶；\n  - 顶点 $2$ 和 $3$ 的晶蝶受到惊扰。\n- 在第 $1$ 秒\n  - 派蒙到达顶点 $3$；\n  - 派蒙抓住 $100$ 只晶蝶。\n- 在第 $2$ 秒\n  - 派蒙到达顶点 $1$；\n  - 顶点 $2$ 的晶蝶消失。\n- 在第 $3$ 秒\n  - 派蒙到达顶点 $2$；\n  - 顶点 $4$ 和 $5$ 的晶蝶受到惊扰。\n- 在第 $4$ 秒\n  - 派蒙到达顶点 $5$；\n  - 派蒙抓住 $10000$ 只晶蝶；\n  - 顶点 $4$ 的晶蝶消失。\n\n对于第二个样例测试用例，最佳策略与第一个样例测试用例相同。顶点 $2$ 的晶蝶计划在第 $3$ 秒结束时消失（而不是第 $2$ 秒），这使得派蒙可以抓住它们。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9848", "type": "P", "difficulty": 5, "samples": [["2\n4\n3\n1 1\n2 2\n6 2\n4\n3 1\n3 3\n5 1\n7 3\n3\n1\n4 2\n3\n1 1\n6 2\n9 1\n", "3\n3\n"]], "limits": {"time": [2000, 2000, 2000], "memory": [262144, 262144, 262144]}, "tags": ["动态规划 DP", "2021", "Special Judge", "O2优化", "动态规划优化", "前缀和", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Cloud Retainer's Game", "background": "", "description": "Cloud Retainer, the builder of the Dwelling in the clouds above Qingyun Peak, is very interested in mechanics. Although there is more than one month away from the Lantern Rite Festival in Liyue, she has already started the design of a gaming event for it.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ye0zfdit.png)\n\nThe game is mainly about releasing pinballs to get a score as high as possible. It is played on the 2-dimensional plane with two horizontal straight lines $y = 0$ and $y = H$. Between the two lines, there are $n$ tiny wooden boards and $m$ coins, both can be regarded as single points. The $i$-th wooden board is located at $(x_i, y_i)$ while the $i$-th coin is located at $(x'_i, y'_i)$.\n\nA pinball is released from $(10^{-9}, 10^{-9})$ by the player. Let $\\overrightarrow{v} = (v_x, v_y)$ be the velocity of the ball (that is to say, if the ball is currently located at $(x, y)$ it will move to $(x + v_x\\epsilon, y + v_y\\epsilon)$ after $\\epsilon$ seconds). Initially $\\overrightarrow{v} = (1, 1)$.\n\nWhen the ball hits a wooden board or one of the two horizontal straight lines, $v_y$ will be negated (that is, $v_y$ becomes $-v_y$) while $v_x$ remains unchanged. If the ball hits a coin, the player's score is increased by $1$ and the velocity of the ball remains unchanged.\n\nTo gain a higher score, the player can choose to remove any number of wooden boards before the pinball is released. It is also OK not to remove any wooden board. Cloud Retainer wants you to help her estimate the difficulty by computing the maximum score the player can get after $10^{10^{10^{10^{10}}}}$ seconds under the best strategy?", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains one integer $H$ ($2 \\le H \\le 10^9$).\n\nThe second line contains one integer $n$ ($1 \\le n \\le 10^5$) indicating the number of wooden boards.\n\nFor the following $n$ lines, the $i$-th line contains two integers $x_i$ and $y_i$ ($1 \\le x_i \\le 10^9$, $1 \\le y_i < H$) indicating a wooden board located at $(x_i, y_i)$.\n\nThe following line contains one integer $m$ ($1 \\le m \\le 10^5$) indicating the number of coins.\n\nFor the following $m$ lines, the $i$-th line contains two integers $x'_i$ and $y'_i$ ($1 \\le x'_i \\le 10^9$, $1 \\le y'_i < H$) indicating a coin located at $(x'_i, y'_i)$.\n\nIt's guaranteed that the given $(n + m)$ points in the same test case will be distinct. It's also guaranteed that neither the sum of $n$ nor the sum of $m$ of all test cases will exceed $5 \\times 10^5$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum score the player can get after removing some (or not removing any) wooden boards.", "hint": "The two sample test cases are shown below. Solid diamonds represent the remaining wooden boards, while hollow diamonds represent the removed wooden boards and round dots represent the coins.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/st3aejoc.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oojtcbv6.png)", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Cloud Retainer's Game", "background": "", "description": "Cloud Retainer, the builder of the Dwelling in the clouds above Qingyun Peak, is very interested in mechanics. Although there is more than one month away from the Lantern Rite Festival in Liyue, she has already started the design of a gaming event for it.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ye0zfdit.png)\n\nThe game is mainly about releasing pinballs to get a score as high as possible. It is played on the 2-dimensional plane with two horizontal straight lines $y = 0$ and $y = H$. Between the two lines, there are $n$ tiny wooden boards and $m$ coins, both can be regarded as single points. The $i$-th wooden board is located at $(x_i, y_i)$ while the $i$-th coin is located at $(x'_i, y'_i)$.\n\nA pinball is released from $(10^{-9}, 10^{-9})$ by the player. Let $\\overrightarrow{v} = (v_x, v_y)$ be the velocity of the ball (that is to say, if the ball is currently located at $(x, y)$ it will move to $(x + v_x\\epsilon, y + v_y\\epsilon)$ after $\\epsilon$ seconds). Initially $\\overrightarrow{v} = (1, 1)$.\n\nWhen the ball hits a wooden board or one of the two horizontal straight lines, $v_y$ will be negated (that is, $v_y$ becomes $-v_y$) while $v_x$ remains unchanged. If the ball hits a coin, the player's score is increased by $1$ and the velocity of the ball remains unchanged.\n\nTo gain a higher score, the player can choose to remove any number of wooden boards before the pinball is released. It is also OK not to remove any wooden board. Cloud Retainer wants you to help her estimate the difficulty by computing the maximum score the player can get after $10^{10^{10^{10^{10}}}}$ seconds under the best strategy?", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains one integer $H$ ($2 \\le H \\le 10^9$).\n\nThe second line contains one integer $n$ ($1 \\le n \\le 10^5$) indicating the number of wooden boards.\n\nFor the following $n$ lines, the $i$-th line contains two integers $x_i$ and $y_i$ ($1 \\le x_i \\le 10^9$, $1 \\le y_i < H$) indicating a wooden board located at $(x_i, y_i)$.\n\nThe following line contains one integer $m$ ($1 \\le m \\le 10^5$) indicating the number of coins.\n\nFor the following $m$ lines, the $i$-th line contains two integers $x'_i$ and $y'_i$ ($1 \\le x'_i \\le 10^9$, $1 \\le y'_i < H$) indicating a coin located at $(x'_i, y'_i)$.\n\nIt's guaranteed that the given $(n + m)$ points in the same test case will be distinct. It's also guaranteed that neither the sum of $n$ nor the sum of $m$ of all test cases will exceed $5 \\times 10^5$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum score the player can get after removing some (or not removing any) wooden boards.", "hint": "The two sample test cases are shown below. Solid diamonds represent the remaining wooden boards, while hollow diamonds represent the removed wooden boards and round dots represent the coins.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/st3aejoc.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oojtcbv6.png)", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Cloud Retainer's Game", "background": null, "description": "云堇，青云峰上云中居的建造者，对机械非常感兴趣。虽然距离璃月的海灯节还有一个多月的时间，她已经开始为其设计一个游戏活动。\n\n游戏主要是关于释放弹珠以获得尽可能高的分数。它在二维平面上进行，平面上有两条水平直线 $y = 0$ 和 $y = H$。在这两条直线之间，有 $n$ 块小木板和 $m$ 个硬币，两者都可以视为单个点。第 $i$ 块木板位于 $(x_i, y_i)$，而第 $i$ 个硬币位于 $(x'_i, y'_i)$。\n\n玩家从 $(10^{-9}, 10^{-9})$ 处释放一个弹珠。设 $\\overrightarrow{v} = (v_x, v_y)$ 为弹珠的速度（也就是说，如果弹珠当前位于 $(x, y)$，则在 $\\epsilon$ 秒后它将移动到 $(x + v_x\\epsilon, y + v_y\\epsilon)$）。初始时 $\\overrightarrow{v} = (1, 1)$。\n\n当弹珠撞到木板或两条水平直线之一时，$v_y$ 将被取反（即 $v_y$ 变为 $-v_y$），而 $v_x$ 保持不变。如果弹珠撞到硬币，玩家的分数增加 $1$，弹珠的速度保持不变。\n\n为了获得更高的分数，玩家可以选择在释放弹珠之前移除任意数量的木板。也可以不移除任何木板。云堇希望你帮助她通过计算在最佳策略下经过 $10^{10^{10^{10^{10}}}}$ 秒后玩家可以获得的最高分数来估计游戏的难度。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含一个整数 $H$ ($2 \\le H \\le 10^9$)。\n\n第二行包含一个整数 $n$ ($1 \\le n \\le 10^5$)，表示木板的数量。\n\n接下来的 $n$ 行中，第 $i$ 行包含两个整数 $x_i$ 和 $y_i$ ($1 \\le x_i \\le 10^9$, $1 \\le y_i < H$)，表示位于 $(x_i, y_i)$ 的木板。\n\n接下来的一行包含一个整数 $m$ ($1 \\le m \\le 10^5$)，表示硬币的数量。\n\n接下来的 $m$ 行中，第 $i$ 行包含两个整数 $x'_i$ 和 $y'_i$ ($1 \\le x'_i \\le 10^9$, $1 \\le y'_i < H$)，表示位于 $(x'_i, y'_i)$ 的硬币。\n\n保证同一测试用例中给出的 $(n + m)$ 个点是不同的。也保证所有测试用例中 $n$ 的总和和 $m$ 的总和都不会超过 $5 \\times 10^5$。", "outputFormat": "对于每个测试用例输出一行，包含一个整数，表示在移除一些（或不移除任何）木板后玩家可以获得的最高分数。", "hint": "下面显示了两个示例测试用例。实心菱形表示剩余的木板，空心菱形表示被移除的木板，圆点表示硬币。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9849", "type": "P", "difficulty": 5, "samples": [["5\n4 7\n9 8\n32 84\n11 35\n2 1\n", "2\n7\n5\n4\n0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "递推", "2021", "Special Judge", "O2优化", "最大公约数 gcd", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Xingqiu's Joke", "background": "", "description": "Once again, Xingqiu hides Chongyun's ice cream into a box with a strange lock. Liyue's summer has been always very hot and Chongyun suffers more because of his excessive yang (positive) energy, so he needs that ice cream desperately.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2dtcr426.png)\n\nThere are two integers $a$ and $b$ on the lock. Chongyun can perform the following three types of operations any number of times:\n- Minus $1$ from both $a$ and $b$;\n- Plus $1$ to both $a$ and $b$;\n- Divide both $a$ and $b$ by one of their common $\\textbf{prime}$ factor (that is to say, divide them by a $\\textbf{prime}$ $g$ where $a$ and $b$ are both divisible by $g$).\n\nThe box will be unlocked if either $a$ or $b$ or both become $1$. To help Chongyun gets the ice cream back as quickly as possible, please tell him the minimum number of operations needed to unlock the box.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 300$) indicating the number of test cases. For each test case:\n\nThe first and only line contains two integers $a$ and $b$ ($1 \\le a, b \\le 10^9$, $a \\ne b$).", "outputFormat": "For each test case output one line containing one integer indicating the minimum number of operations to make $a$ or $b$ or both equal $1$.", "hint": "For the first sample test case, the optimal way is $(4, 7) \\rightarrow (3, 6) \\rightarrow (1, 2)$.\n\nFor the second sample test case, the optimal way is to apply the first type of operation $7$ times.\n\nFor the third sample test case, the optimal way is $(32, 84) \\rightarrow (16, 42) \\rightarrow (15, 41) \\rightarrow (14, 40) \\rightarrow (13, 39) \\rightarrow (1, 3)$.\n\nFor the fourth sample test case, the optimal way is $(11, 35) \\rightarrow (12, 36) \\rightarrow (6, 18) \\rightarrow (2, 6) \\rightarrow (1, 3)$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Xingqiu's Joke", "background": "", "description": "Once again, Xingqiu hides Chongyun's ice cream into a box with a strange lock. Liyue's summer has been always very hot and Chongyun suffers more because of his excessive yang (positive) energy, so he needs that ice cream desperately.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2dtcr426.png)\n\nThere are two integers $a$ and $b$ on the lock. Chongyun can perform the following three types of operations any number of times:\n- Minus $1$ from both $a$ and $b$;\n- Plus $1$ to both $a$ and $b$;\n- Divide both $a$ and $b$ by one of their common $\\textbf{prime}$ factor (that is to say, divide them by a $\\textbf{prime}$ $g$ where $a$ and $b$ are both divisible by $g$).\n\nThe box will be unlocked if either $a$ or $b$ or both become $1$. To help Chongyun gets the ice cream back as quickly as possible, please tell him the minimum number of operations needed to unlock the box.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ ($1 \\le T \\le 300$) indicating the number of test cases. For each test case:\n\nThe first and only line contains two integers $a$ and $b$ ($1 \\le a, b \\le 10^9$, $a \\ne b$).", "outputFormat": "For each test case output one line containing one integer indicating the minimum number of operations to make $a$ or $b$ or both equal $1$.", "hint": "For the first sample test case, the optimal way is $(4, 7) \\rightarrow (3, 6) \\rightarrow (1, 2)$.\n\nFor the second sample test case, the optimal way is to apply the first type of operation $7$ times.\n\nFor the third sample test case, the optimal way is $(32, 84) \\rightarrow (16, 42) \\rightarrow (15, 41) \\rightarrow (14, 40) \\rightarrow (13, 39) \\rightarrow (1, 3)$.\n\nFor the fourth sample test case, the optimal way is $(11, 35) \\rightarrow (12, 36) \\rightarrow (6, 18) \\rightarrow (2, 6) \\rightarrow (1, 3)$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Xingqiu's Joke", "background": "![image](https://cdn.luogu.com.cn/upload/image_hosting/2dtcr426.png)", "description": "有 $T$ 个盒子，每盒子上有一个锁，锁上有两个整数 $a$ 和 $b$。你可以对这个锁做若干次以下 3 种操作：\n\n- $a$ 和 $b$ 分别减去 $1$\n- $a$ 和 $b$ 分别增加 $1$\n- $a$ 和 $b$ 分别除以它们共同的素数因子\n\n如果 $a$ 或 $b$ 或两者都变为 $1$，盒子就会解锁。请你编写一个程序，计算每个盒子的锁打开的最少步骤数量。", "inputFormat": "第一行输入一个整数 $T(1≤T≤300)$。\n\n接下来 $T$ 行，每行输入 $a$ 和 $b$（$1\\le a,b\\le 10^9$ 且 $a\\neq b$），表示每个盒子的锁的信息。", "outputFormat": "共输出 $T$ 行，每行输出对应盒子解锁的最少步骤。", "hint": "对于第一个样例，最优解之一为 $(4, 7) \\rightarrow (3, 6) \\rightarrow (1, 2)$。\n\n对于第二个样例，最优解之一是执行第一类操作 $7$ 次。\n\n对于第三个样例，最优解之一是 $(32, 84) \\rightarrow (16, 42) \\rightarrow (15, 41) \\rightarrow (14, 40) \\rightarrow (13, 39) \\rightarrow (1, 3)$。\n\n对于第四个样例，最优解之一是 $(11, 35) \\rightarrow (12, 36) \\rightarrow (6, 18) \\rightarrow (2, 6) \\rightarrow (1, 3)$。", "locale": "zh-CN"}}}
{"pid": "P9850", "type": "P", "difficulty": 7, "samples": [["7 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n", "3\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["图论", "2021", "Special Judge", "O2优化", "容斥原理", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Ancient Magic Circle in Teyvat", "background": "", "description": "Astrologist Mona Megistus discovers an ancient magic circle in Teyvat recently.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gohzab6t.png)\n\nThe magic circle looks like a complete graph with $n$ vertices, where $m$ edges are colored red and other edges are colored blue. Note that a complete graph is a simple undirected graph in which every pair of distinct vertices is connected by a unique edge.\n\nMona realizes that if she chooses four different vertices such that the six edges between these four vertices are of the same color, she will get a *key* from the magic circle. If the color is red, she will get a *red key*, and if the color is blue, she will get a *blue key*.\n\nBase on the information written in the ancient books Mona has read, the magic power of the ancient magic circle is the absolute difference between the number of *red keys* and the number of the number of *blue keys* she can get from the magic circle.\n\nMona needs your help badly, since calculating the magic power of the magic circle is really a tough job.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains two integers $n$ and $m$ ($4 \\le n \\le 10^5$, $0 \\le m \\le \\min(\\frac{n(n-1)}{2}, 2 \\times 10^5)$) indicating the number of vertices and the number of edges colored red of the ancient magic circle.\n\nFor the following $m$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($u_i < v_i$) indicating a red edge connecting vertices $u_i$ and $v_i$. It is guaranteed that each edge appears at most once.", "outputFormat": "Output one line containing one integer indicating the magic power of the ancient magic circle.", "hint": "For the sample case, there is only one *red key* $(1,2,3,4)$ and there are four *blue keys* $(1,5,6,7)$, $(2,5,6,7)$, $(3,5,6,7)$ and $(4,5,6,7)$ in the ancient magic circle, thus the magic power of the magic circle is $|1-4|=3$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Ancient Magic Circle in Teyvat", "background": "", "description": "Astrologist Mona Megistus discovers an ancient magic circle in Teyvat recently.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gohzab6t.png)\n\nThe magic circle looks like a complete graph with $n$ vertices, where $m$ edges are colored red and other edges are colored blue. Note that a complete graph is a simple undirected graph in which every pair of distinct vertices is connected by a unique edge.\n\nMona realizes that if she chooses four different vertices such that the six edges between these four vertices are of the same color, she will get a *key* from the magic circle. If the color is red, she will get a *red key*, and if the color is blue, she will get a *blue key*.\n\nBase on the information written in the ancient books Mona has read, the magic power of the ancient magic circle is the absolute difference between the number of *red keys* and the number of the number of *blue keys* she can get from the magic circle.\n\nMona needs your help badly, since calculating the magic power of the magic circle is really a tough job.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains two integers $n$ and $m$ ($4 \\le n \\le 10^5$, $0 \\le m \\le \\min(\\frac{n(n-1)}{2}, 2 \\times 10^5)$) indicating the number of vertices and the number of edges colored red of the ancient magic circle.\n\nFor the following $m$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($u_i < v_i$) indicating a red edge connecting vertices $u_i$ and $v_i$. It is guaranteed that each edge appears at most once.", "outputFormat": "Output one line containing one integer indicating the magic power of the ancient magic circle.", "hint": "For the sample case, there is only one *red key* $(1,2,3,4)$ and there are four *blue keys* $(1,5,6,7)$, $(2,5,6,7)$, $(3,5,6,7)$ and $(4,5,6,7)$ in the ancient magic circle, thus the magic power of the magic circle is $|1-4|=3$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Ancient Magic Circle in Teyvat", "background": "", "description": "占星师 Mona Megistus 最近在 Teyvat 发现了一个古老的魔法阵。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gohzab6t.png)\n\n这个魔法阵看起来像一个有 $n$ 个顶点的完全图，其中 $m$ 条边被染成红色，其他边被染成蓝色。注意，完全图是一个简单的无向图，其中每一对不同的顶点之间都由一条唯一的边连接。\n\nMona 意识到，如果她选择四个不同的顶点，使得这四个顶点之间的六条边颜色相同，她将从魔法阵中获得一个“钥匙”。如果颜色是红色，她将获得一个“红色钥匙”；如果颜色是蓝色，她将获得一个“蓝色钥匙”。\n\n根据 Mona 阅读的古书中写的信息，古老魔法阵的魔力是她可以从魔法阵中获得的“红色钥匙”和“蓝色钥匙”数量的绝对差。\n\nMona 非常需要你的帮助，因为计算魔法阵的魔力实在是一项艰巨的工作。", "inputFormat": "每个测试文件中只有一个测试用例。\n\n输入的第一行包含两个整数 $n$ 和 $m$ ($4 \\le n \\le 10^5$, $0 \\le m \\le \\min(\\frac{n(n-1)}{2}, 2 \\times 10^5)$)，表示古老魔法阵的顶点数和红色边的数量。\n\n接下来的 $m$ 行中，第 $i$ 行包含两个整数 $u_i$ 和 $v_i$ ($u_i < v_i$)，表示连接顶点 $u_i$ 和 $v_i$ 的红色边。保证每条边最多出现一次。", "outputFormat": "输出一行，包含一个整数，表示古老魔法阵的魔力。", "hint": "对于示例情况，古老魔法阵中只有一个“红色钥匙” $(1,2,3,4)$，而有四个“蓝色钥匙” $(1,5,6,7)$、$(2,5,6,7)$、$(3,5,6,7)$ 和 $(4,5,6,7)$，因此魔法阵的魔力是 $|1-4|=3$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9851", "type": "P", "difficulty": 6, "samples": [["2\n5\n00000\n3\n001\n", "7\n2 5 1 2 3 4 2\n0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2021", "Special Judge", "O2优化", "构造", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Secret of Tianqiu Valley", "background": "", "description": "In the north tower of Tianqiu Valley's ruins, there are some flame torch puzzles and Lumine the traveler is facing the last and the hardest one.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sihi5us5.png)\n\nThere are $n$ torches in a circle and some torches have been ignited initially. The $i$-th and the $(i \\bmod n +1)$-th are adjacent for all $1 \\le i \\le n$.\n\nTo solve the puzzle, all the torches should be ignited. In each move, Lumine can ignite an extinguished torch, and the status of the adjacent torches will be reversed affected by the supernatural. That is, each of the adjacent torches will be ignited if it is currently extinguished, or be extinguished if it is currently ignited.\n\nTime is money, Lumine wants to solve the puzzle in $2n$ moves or determine that the puzzle is unsolvable.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line of the input contains an integer $n$ ($3 \\le n \\le 10^5$) indicating the number of torches in the circle.\n\nThe second line contains a binary string $s_1s_2\\cdots s_n$ of length $n$ ($s_i \\in \\{\\text{`0'}, \\text{`1'}\\}$). If $s_i = \\text{`0'}$ the $i$-th torch is extinguished initially; If $s_i = \\text{`1'}$ the $i$-th torch is ignited initially. It is guaranteed that not all the torches have been ignited initially.\n\nIt is also guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "If the puzzle is unsolvable, output `0`.\n\nOtherwise, output an integer $k$ $(1 \\le k \\le 2n)$ in the first line indicating the number of moves Lumine needs to solve the puzzle. Then output a line containing $k$ integers $t_1, t_2, \\cdots, t_k$ separated by a space, where $t_i$ indicating that Lumine will ignite the $t_i$-th torch in the $i$-th move. If there are multiple answers print any of them.\n\nPlease, DO NOT output extra spaces at the end of each line or your solution may be considered incorrect!", "hint": "For the first sample test case, the status of the torch will change like this: $00000$ $\\to$ $11100$ $\\to$ $01111$ $\\to$ $10110$ $\\to$ $01010$ $\\to$ $00100$ $\\to$ $00011$ $\\to$ $11111$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Secret of Tianqiu Valley", "background": "", "description": "In the north tower of Tianqiu Valley's ruins, there are some flame torch puzzles and Lumine the traveler is facing the last and the hardest one.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sihi5us5.png)\n\nThere are $n$ torches in a circle and some torches have been ignited initially. The $i$-th and the $(i \\bmod n +1)$-th are adjacent for all $1 \\le i \\le n$.\n\nTo solve the puzzle, all the torches should be ignited. In each move, Lumine can ignite an extinguished torch, and the status of the adjacent torches will be reversed affected by the supernatural. That is, each of the adjacent torches will be ignited if it is currently extinguished, or be extinguished if it is currently ignited.\n\nTime is money, Lumine wants to solve the puzzle in $2n$ moves or determine that the puzzle is unsolvable.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line of the input contains an integer $n$ ($3 \\le n \\le 10^5$) indicating the number of torches in the circle.\n\nThe second line contains a binary string $s_1s_2\\cdots s_n$ of length $n$ ($s_i \\in \\{\\text{`0'}, \\text{`1'}\\}$). If $s_i = \\text{`0'}$ the $i$-th torch is extinguished initially; If $s_i = \\text{`1'}$ the $i$-th torch is ignited initially. It is guaranteed that not all the torches have been ignited initially.\n\nIt is also guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "If the puzzle is unsolvable, output `0`.\n\nOtherwise, output an integer $k$ $(1 \\le k \\le 2n)$ in the first line indicating the number of moves Lumine needs to solve the puzzle. Then output a line containing $k$ integers $t_1, t_2, \\cdots, t_k$ separated by a space, where $t_i$ indicating that Lumine will ignite the $t_i$-th torch in the $i$-th move. If there are multiple answers print any of them.\n\nPlease, DO NOT output extra spaces at the end of each line or your solution may be considered incorrect!", "hint": "For the first sample test case, the status of the torch will change like this: $00000$ $\\to$ $11100$ $\\to$ $01111$ $\\to$ $10110$ $\\to$ $01010$ $\\to$ $00100$ $\\to$ $00011$ $\\to$ $11111$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Secret of Tianqiu Valley", "background": "", "description": "在天穹谷遗迹的北塔中，有一些火炬谜题，旅行者荧正面临最后一个也是最难的一个。\n\n在一个圆圈中有 $n$ 个火炬，初始时有些火炬已经被点燃。对于所有 $1 \\le i \\le n$，第 $i$ 个和第 $(i \\bmod n +1)$ 个火炬是相邻的。\n\n为了破解这个谜题，所有的火炬都应该被点燃。在每一步中，荧可以点燃一个熄灭的火炬，并且受超自然力量影响，相邻火炬的状态将被反转。也就是说，如果相邻火炬当前是熄灭的，它将被点燃；如果当前是点燃的，它将被熄灭。\n\n时间就是金钱，荧希望在 $2n$ 步内解决这个谜题，或者确定这个谜题是无法解决的。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n输入的第一行包含一个整数 $n$ ($3 \\le n \\le 10^5$)，表示圆圈中火炬的数量。\n\n第二行包含一个长度为 $n$ 的二进制字符串 $s_1s_2\\cdots s_n$ ($s_i \\in \\{\\text{`0'}, \\text{`1'}\\}$)。如果 $s_i = \\text{`0'}$，则第 $i$ 个火炬初始时是熄灭的；如果 $s_i = \\text{`1'}$，则第 $i$ 个火炬初始时是点燃的。保证初始时并非所有火炬都被点燃。\n\n还保证所有测试用例的 $n$ 之和不超过 $10^6$。", "outputFormat": "如果谜题无法解决，输出 `0`。\n\n否则，第一行输出一个整数 $k$ $(1 \\le k \\le 2n)$，表示荧需要的移动次数。然后输出一行包含 $k$ 个用空格分隔的整数 $t_1, t_2, \\cdots, t_k$，其中 $t_i$ 表示荧将在第 $i$ 次移动中点燃第 $t_i$ 个火炬。如果有多个答案，输出任意一个。\n\n请不要在每行的末尾输出多余的空格，否则您的解决方案可能被认为不正确！", "hint": "对于第一个样例测试用例，火炬的状态将如下变化：$00000$ $\\to$ $11100$ $\\to$ $01111$ $\\to$ $10110$ $\\to$ $01010$ $\\to$ $00100$ $\\to$ $00011$ $\\to$ $11111$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9852", "type": "P", "difficulty": 3, "samples": [["5\n4\n1 -3 2 -4\n11\n91 66 73 71 32 83 72 79 84 33 93\n12\n91 66 73 71 32 83 72 79 84 33 33 93\n13\n91 66 73 71 32 83 72 79 84 33 33 33 93\n1\n0\n", "10\n713\n746\n779\n0\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2021", "Special Judge", "O2优化", "ICPC", "南京"], "title": "[ICPC 2021 Nanjing R] Windblume Festival", "background": "", "description": "The Windblume Festival in Mondstadt is coming! People are preparing windblumes for Barbatos and for those they love and adore. The Windblume Festival is also an opportunity to improve the relationships people have.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nbhhi3bg.png)\n\nDuring the festival, a famous game will be played every year, invented by Jean, the Acting Grand Master of the Knights of Favonius. In the game, $n$ players numbered from $1$ to $n$ stand in a circle, each holding an integer with them. Each turn, one player will be removed. The game will end when there is only one player left.\n\nFor each turn, let $k$ be the number of players remaining and $a_i$ be the integer player $i$ holds. Two adjacent players, $x$ and $(x \\bmod k + 1)$ are selected and player $(x \\bmod k + 1)$ is removed from the game. Player $x$'s integer will then change from $a_x$ to $(a_x - a_{x \\bmod k + 1})$. Player $y$ in this turn will become player $(y - 1)$ in the next turn for all $x < y \\le k$, though the integer they hold will not change.\n\nJean wants to know the maximum possible integer held by the last remaining player in the game by selecting the players in each round optimally.", "inputFormat": "There are multiple test cases. The first line of the input contains one integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains one integer $n$ ($1 \\le n \\le 10^6$) indicating the initial number of players.\n\nThe next line contains $n$ integers $a_i$ ($-10^9 \\le a_i \\le 10^9$) where $a_i$ is the integer held by player $i$ at the beginning.\n\nIt is guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum possible integer.", "hint": "For the first sample test case follow the strategy shown below, where the underlined integers are the integers held by the players selected in each turn.\n\n$\\{\\underline{1}, -3, 2, \\underline{-4}\\}$ (select $x = 4$) $\\to$ $\\{-3, \\underline{2, -5}\\}$ (select $x = 2$) $\\to$ $\\{\\underline{-3, 7}\\}$ (select $x = 2$) $\\to$ $\\{10\\}$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Nanjing R] Windblume Festival", "background": "", "description": "The Windblume Festival in Mondstadt is coming! People are preparing windblumes for Barbatos and for those they love and adore. The Windblume Festival is also an opportunity to improve the relationships people have.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nbhhi3bg.png)\n\nDuring the festival, a famous game will be played every year, invented by Jean, the Acting Grand Master of the Knights of Favonius. In the game, $n$ players numbered from $1$ to $n$ stand in a circle, each holding an integer with them. Each turn, one player will be removed. The game will end when there is only one player left.\n\nFor each turn, let $k$ be the number of players remaining and $a_i$ be the integer player $i$ holds. Two adjacent players, $x$ and $(x \\bmod k + 1)$ are selected and player $(x \\bmod k + 1)$ is removed from the game. Player $x$'s integer will then change from $a_x$ to $(a_x - a_{x \\bmod k + 1})$. Player $y$ in this turn will become player $(y - 1)$ in the next turn for all $x < y \\le k$, though the integer they hold will not change.\n\nJean wants to know the maximum possible integer held by the last remaining player in the game by selecting the players in each round optimally.", "inputFormat": "There are multiple test cases. The first line of the input contains one integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains one integer $n$ ($1 \\le n \\le 10^6$) indicating the initial number of players.\n\nThe next line contains $n$ integers $a_i$ ($-10^9 \\le a_i \\le 10^9$) where $a_i$ is the integer held by player $i$ at the beginning.\n\nIt is guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the maximum possible integer.", "hint": "For the first sample test case follow the strategy shown below, where the underlined integers are the integers held by the players selected in each turn.\n\n$\\{\\underline{1}, -3, 2, \\underline{-4}\\}$ (select $x = 4$) $\\to$ $\\{-3, \\underline{2, -5}\\}$ (select $x = 2$) $\\to$ $\\{\\underline{-3, 7}\\}$ (select $x = 2$) $\\to$ $\\{10\\}$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Nanjing R] Windblume Festival", "background": "", "description": "蒙德城的风花节即将到来！人们正在为巴巴托斯和他们所爱的人准备风花。风花节也是一个改善人际关系的机会。\n\n在节日期间，每年都会玩一个由代理团长琴发明的著名游戏。在游戏中，编号从 $1$ 到 $n$ 的 $n$ 个玩家围成一个圈，每人手中持有一个整数。每一轮，将有一名玩家被移除。游戏将在只剩下一名玩家时结束。\n\n在每一轮中，设 $k$ 为剩余玩家的数量，$a_i$ 为玩家 $i$ 手中的整数。选择两个相邻的玩家 $x$ 和 $(x \\bmod k + 1)$，并将玩家 $(x \\bmod k + 1)$ 移出游戏。然后玩家 $x$ 的整数将从 $a_x$ 变为 $(a_x - a_{x \\bmod k + 1})$。在本轮中，玩家 $y$ 在下一轮中将成为玩家 $(y - 1)$，对于所有 $x < y \\le k$，尽管他们手中的整数不会改变。\n\n琴想知道通过在每轮中最优地选择玩家，最后剩下的玩家手中可能持有的最大整数。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含一个整数 $n$ ($1 \\le n \\le 10^6$)，表示初始的玩家数量。\n\n下一行包含 $n$ 个整数 $a_i$ ($-10^9 \\le a_i \\le 10^9$)，其中 $a_i$ 是玩家 $i$ 在开始时持有的整数。\n\n保证所有测试用例中 $n$ 的总和不超过 $10^6$。", "outputFormat": "对于每个测试用例，输出一行，包含一个整数，表示可能的最大整数。", "hint": "对于第一个样例测试用例，遵循如下策略，其中下划线的整数是每轮中被选中的玩家持有的整数。\n\n$\\{\\underline{1}, -3, 2, \\underline{-4}\\}$（选择 $x = 4$）$\\to$ $\\{-3, \\underline{2, -5}\\}$（选择 $x = 2$）$\\to$ $\\{\\underline{-3, 7}\\}$（选择 $x = 2$）$\\to$ $\\{10\\}$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9853", "type": "P", "difficulty": 2, "samples": [["3 4\n2x+4=10\n-3x+13=10\n4x-8=16\n1 6\n1 8\n3 6\n4 5", "3\n3\n2\n0"], ["5 3\n5x-2=13\n8x+5=45\n4x-12=8\n-2x+10=4\n3x-7=2\n1 3\n1 5\n3 5", "1\n2\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "二分", "2023", "O2优化", "语言月赛"], "title": "[入门赛 #17] 方程求解", "background": "", "description": "小 A 有 $n$ 个关于 $x$ 的方程，第 $i$ 个方程形如 $a_ix_i+b_i=c_i$。方程的解 $x$ 均为正整数，例如下面几个方程都是符合要求的方程：\n\n```\n2x+4=10\n-3x+13=10\n4x-8=16\n```\n\n其中，第一组方程的解为 $x_1=3$，第二组方程的解为 $x_2=1$，第三组方程的解为 $x_3=6$。\n\n小 A 想要知道，给定 $L,R$，在 $L\\leq x\\leq R$ 的范围内，有多少个正整数 $x$ 满足 $x$ 是其中至少一个方程的解。为了防止你欺骗他，他会询问你 $Q$ 次。", "inputFormat": "第一行输入两个正整数 $n,Q$，分别表示小 A 有的方程数，以及小 A 想要向你询问的次数。\n\n第二行开始，往下 $n$ 行，每行一个字符串，描述一个方程。\n\n第 $(n+2)$ 行开始，往下 $Q$ 行，每行两个正整数 $L,R$，表示一次询问，即给定 $L,R$，询问在 $L\\leq x\\leq R$ 的范围内，有多少个正整数 $x$ 满足 $x$ 是其中至少一个方程的解。", "outputFormat": "对于每次询问，输出一行一个整数，表示有多少个在 $L\\leq x\\leq R$ 的范围内的正整数 $x$，满足 $x$ 是其中至少一个方程的解。", "hint": "**【样例解释】**\n\n对于第一组样例，即为题目中的举例。三组方程的解分别为 $x_1=3,x_2=1,x_3=6$。则：\n\n- 对于 $1\\leq x\\leq 6$ 的范围，有 $3$ 个 $x$ 的取值（$x=1,3,6$）是其中至少一个方程的解；\n- 对于 $1\\leq x\\leq 8$ 的范围，同上所述；\n- 对于 $3\\leq x\\leq 6$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,6$）是其中至少一个方程的解；\n- 对于 $4\\leq x\\leq 5$ 的范围，不存在一个 $x$ 是其中至少一个方程的解；\n- 因此分别输出 $3,3,2,0$。\n\n对于第二组样例，五组方程的解分别为 $x_1=3,x_2=5,x_3=5,x_4=3,x_5=3$。则：\n\n- 对于 $1\\leq x\\leq 3$ 的范围，只有 $x=3$ 满足是其中至少一个方程的解；\n- 对于 $1\\leq x\\leq 5$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,5$）是其中至少一个方程的解；\n- 对于 $3\\leq x\\leq 5$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,5$）是其中至少一个方程的解；\n- 因此分别输出 $1,2,2$。\n\n**【数据范围】**\n\n数据保证，$1\\leq n,Q\\leq 2\\times 10^5$，方程中 $a_i,b_i,c_i$ 满足 $1 \\leq |a_i|,|b_i|,|c_i| \\leq 10^9$，每一组方程的解 $x_i$ 必定为正整数。询问时的 $L,R$ 满足 $1\\leq L\\leq R\\leq 2\\times 10^9$。\n\n本题输入数据较大，请注意代码输入输出的运行效率。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[入门赛 #17] 方程求解", "background": "", "description": "小 A 有 $n$ 个关于 $x$ 的方程，第 $i$ 个方程形如 $a_ix_i+b_i=c_i$。方程的解 $x$ 均为正整数，例如下面几个方程都是符合要求的方程：\n\n```\n2x+4=10\n-3x+13=10\n4x-8=16\n```\n\n其中，第一组方程的解为 $x_1=3$，第二组方程的解为 $x_2=1$，第三组方程的解为 $x_3=6$。\n\n小 A 想要知道，给定 $L,R$，在 $L\\leq x\\leq R$ 的范围内，有多少个正整数 $x$ 满足 $x$ 是其中至少一个方程的解。为了防止你欺骗他，他会询问你 $Q$ 次。", "inputFormat": "第一行输入两个正整数 $n,Q$，分别表示小 A 有的方程数，以及小 A 想要向你询问的次数。\n\n第二行开始，往下 $n$ 行，每行一个字符串，描述一个方程。\n\n第 $(n+2)$ 行开始，往下 $Q$ 行，每行两个正整数 $L,R$，表示一次询问，即给定 $L,R$，询问在 $L\\leq x\\leq R$ 的范围内，有多少个正整数 $x$ 满足 $x$ 是其中至少一个方程的解。", "outputFormat": "对于每次询问，输出一行一个整数，表示有多少个在 $L\\leq x\\leq R$ 的范围内的正整数 $x$，满足 $x$ 是其中至少一个方程的解。", "hint": "**【样例解释】**\n\n对于第一组样例，即为题目中的举例。三组方程的解分别为 $x_1=3,x_2=1,x_3=6$。则：\n\n- 对于 $1\\leq x\\leq 6$ 的范围，有 $3$ 个 $x$ 的取值（$x=1,3,6$）是其中至少一个方程的解；\n- 对于 $1\\leq x\\leq 8$ 的范围，同上所述；\n- 对于 $3\\leq x\\leq 6$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,6$）是其中至少一个方程的解；\n- 对于 $4\\leq x\\leq 5$ 的范围，不存在一个 $x$ 是其中至少一个方程的解；\n- 因此分别输出 $3,3,2,0$。\n\n对于第二组样例，五组方程的解分别为 $x_1=3,x_2=5,x_3=5,x_4=3,x_5=3$。则：\n\n- 对于 $1\\leq x\\leq 3$ 的范围，只有 $x=3$ 满足是其中至少一个方程的解；\n- 对于 $1\\leq x\\leq 5$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,5$）是其中至少一个方程的解；\n- 对于 $3\\leq x\\leq 5$ 的范围，有 $2$ 个 $x$ 的取值（$x=3,5$）是其中至少一个方程的解；\n- 因此分别输出 $1,2,2$。\n\n**【数据范围】**\n\n数据保证，$1\\leq n,Q\\leq 2\\times 10^5$，方程中 $a_i,b_i,c_i$ 满足 $1 \\leq |a_i|,|b_i|,|c_i| \\leq 10^9$，每一组方程的解 $x_i$ 必定为正整数。询问时的 $L,R$ 满足 $1\\leq L\\leq R\\leq 2\\times 10^9$。\n\n本题输入数据较大，请注意代码输入输出的运行效率。", "locale": "zh-CN"}}}
{"pid": "P9854", "type": "P", "difficulty": 1, "samples": [["69\n1.73", "Normal weight"], ["84.5\n1.8", "Overweight"]], "limits": {"time": [1000, 1000, 1000], "memory": [131072, 131072, 131072]}, "tags": ["2008", "CCC（加拿大）"], "title": "[CCC 2008 J1] Body Mass Index", "background": "", "description": "The Body Mass Index (BMI) is one of the calculations used by doctors to assess an adult’s health. The doctor measures the patient’s height (in metres) and weight (in kilograms), then calculates the BMI using the formula:\n\n$$\\text{BMI} = \\dfrac{\\text{weight}}{\\text{height} \\times \\text{height}}$$\n\nWrite a program which prompts for the patient’s height and weight, calculates the BMI, and displays the corresponding message from the table below.\n\n| BMI Category | Message |\n| :----------: | :----------: |\n| More than $25$ | Overweight |\n| Between $18.5$ and $25.0$ (inclusive)  | Normal weight |\n| Less than $18.5$ | Underweight |", "inputFormat": "On the first line, enter your weight, and on the second line, enter your height (in meters).", "outputFormat": "Output the information corresponding to the BMI value obtained.", "hint": "**Explanation for Output in Sample Input 1**:\n\nThe BMI is $69 \\div (1.73 \\times 1.73)$, which is approximately $23.0545$. According to the table, this is a \"Normal weight\".\n\n**Explanation for Output in Sample Input 2**:\n\nThe BMI is $84.5 \\div (1.8 \\times 1.8)$, which is approximately $26.0802$. According to the table, this is \"Overweight\".", "locale": "en", "translations": {"en": {"title": "[CCC 2008 J1] Body Mass Index", "background": "", "description": "The Body Mass Index (BMI) is one of the calculations used by doctors to assess an adult’s health. The doctor measures the patient’s height (in metres) and weight (in kilograms), then calculates the BMI using the formula:\n\n$$\\text{BMI} = \\dfrac{\\text{weight}}{\\text{height} \\times \\text{height}}$$\n\nWrite a program which prompts for the patient’s height and weight, calculates the BMI, and displays the corresponding message from the table below.\n\n| BMI Category | Message |\n| :----------: | :----------: |\n| More than $25$ | Overweight |\n| Between $18.5$ and $25.0$ (inclusive)  | Normal weight |\n| Less than $18.5$ | Underweight |", "inputFormat": "On the first line, enter your weight, and on the second line, enter your height (in meters).", "outputFormat": "Output the information corresponding to the BMI value obtained.", "hint": "**Explanation for Output in Sample Input 1**:\n\nThe BMI is $69 \\div (1.73 \\times 1.73)$, which is approximately $23.0545$. According to the table, this is a \"Normal weight\".\n\n**Explanation for Output in Sample Input 2**:\n\nThe BMI is $84.5 \\div (1.8 \\times 1.8)$, which is approximately $26.0802$. According to the table, this is \"Overweight\".", "locale": "en"}, "zh-CN": {"title": "[CCC 2008 J1] Body Mass Index", "background": null, "description": "身体质量指数（BMI）是医生用来评估成年人健康状况的计算方法之一。医生测量患者的身高（以米为单位）和体重（以千克为单位），然后使用公式计算 BMI：\n\n$$\\text{BMI} = \\dfrac{\\text{weight}}{\\text{height} \\times \\text{height}}$$\n\n编写一个程序，提示输入患者的身高和体重，计算 BMI，并输出下表中的相应的英文信息。\n\n| BMI 分类 | 信息 |\n| :----------: | :----------: |\n| 超过 $25$ | 超重 (Overweight)|\n| 在 $18.5$ 和 $25.0$ 之间（含） | 正常体重 (Normal weight)|\n| 小于 $18.5$ | 体重过轻 (Underweight)|", "inputFormat": "第一行输入你的体重，第二行输入你的身高（以米为单位）。", "outputFormat": "输出与所获得的 BMI 值对应的信息。", "hint": "**样例输入 1 的输出解释**：\n\nBMI 为 $69 \\div (1.73 \\times 1.73)$，约为 $23.0545$。根据表格，这是“正常体重”。\n\n**样例输入 2 的输出解释**：\n\nBMI 为 $84.5 \\div (1.8 \\times 1.8)$，约为 $26.0802$。根据表格，这是“超重”。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9855", "type": "P", "difficulty": 1, "samples": [["2\n1\n3\n1\n2\n3\n4\n1", "B C D A E"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["2008", "CCC（加拿大）"], "title": "[CCC 2008 J2] Do the Shuffle", "background": "", "description": "Those tiny music machines that play your digital music are really computers that keep track of and play music files. The CCC music player $(C^3MP)$ is currently in development and will be hitting the stores soon! In this problem, you have to simulate a $C^3MP$.\n\nThe $C^3MP$ music player will hold $5$ songs in memory, whose titles will always be `A`, `B`, `C`, `D`, `E`. The $C^3MP$ also keeps track of a playlist, which is an ordering of all the songs. The $C^3MP$ has 4 buttons that the user will press to rearrange the playlist and play the songs.\n\nInitially, the $C^3MP$ playist is `A,B,C,D,E`. The $4$ control buttons do the following:\n\n- button $1$: move the first song of the playlist to the end of the playlist. For example: `A,B,C,D,E` will change to `B,C,D,E,A`.\n\n- button $2$: move the last song of the playlist to the start of the playlist. For example, `A,B,C,D,E` will change to `E,A,B,C,D`.\n\n- button $3$: swap the first two songs of the playlist. For example, `A,B,C,D,E` will change to `B,A,C,D,E`.\n\n- button $4$: stop rearranging songs and output the playlist.", "inputFormat": "You need to write a program to simulate a CCC music player. Your program should repeatedly ask for two positive integers b and n. Here b represents the button number that the user wants to press, $1 \\leq b \\leq 4$, and n represents the number of times that the user wants to press button b. You can assume that n always satisfies $1 \\leq n \\leq 10$.", "outputFormat": "The input will always finish with the pair of inputs $(b = 4, n = 1)$ when this happens, you should print the order of songs in the current playlist and your program should end. You can assume that the user will only ever press button $4$ once.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CCC 2008 J2] Do the Shuffle", "background": "", "description": "Those tiny music machines that play your digital music are really computers that keep track of and play music files. The CCC music player $(C^3MP)$ is currently in development and will be hitting the stores soon! In this problem, you have to simulate a $C^3MP$.\n\nThe $C^3MP$ music player will hold $5$ songs in memory, whose titles will always be `A`, `B`, `C`, `D`, `E`. The $C^3MP$ also keeps track of a playlist, which is an ordering of all the songs. The $C^3MP$ has 4 buttons that the user will press to rearrange the playlist and play the songs.\n\nInitially, the $C^3MP$ playist is `A,B,C,D,E`. The $4$ control buttons do the following:\n\n- button $1$: move the first song of the playlist to the end of the playlist. For example: `A,B,C,D,E` will change to `B,C,D,E,A`.\n\n- button $2$: move the last song of the playlist to the start of the playlist. For example, `A,B,C,D,E` will change to `E,A,B,C,D`.\n\n- button $3$: swap the first two songs of the playlist. For example, `A,B,C,D,E` will change to `B,A,C,D,E`.\n\n- button $4$: stop rearranging songs and output the playlist.", "inputFormat": "You need to write a program to simulate a CCC music player. Your program should repeatedly ask for two positive integers b and n. Here b represents the button number that the user wants to press, $1 \\leq b \\leq 4$, and n represents the number of times that the user wants to press button b. You can assume that n always satisfies $1 \\leq n \\leq 10$.", "outputFormat": "The input will always finish with the pair of inputs $(b = 4, n = 1)$ when this happens, you should print the order of songs in the current playlist and your program should end. You can assume that the user will only ever press button $4$ once.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CCC 2008 J2] Do the Shuffle", "background": "", "description": "那些播放数字音乐的小型音乐设备实际上是计算机，它们负责管理和播放音乐文件。CCC 音乐播放器 $(C^3MP)$ 正在开发中，并将很快上市！在这个问题中，你需要模拟一个 $C^3MP$。\n\n$C^3MP$ 音乐播放器将会在内存中保存 5 首歌曲，其标题总是 `A`、`B`、`C`、`D`、`E`。$C^3MP$ 还会记录一个播放列表，即所有歌曲的排序。$C^3MP$ 有 4 个按钮，用户可以按下这些按钮来重新排列播放列表并播放歌曲。\n\n最初，$C^3MP$ 的播放列表是 `A,B,C,D,E`。这 4 个控制按钮的功能如下：\n\n- 按钮 $1$：将播放列表中的第一首歌移动到播放列表的末尾。例如：`A,B,C,D,E` 将变为 `B,C,D,E,A`。\n\n- 按钮 $2$：将播放列表中的最后一首歌移动到播放列表的开头。例如：`A,B,C,D,E` 将变为 `E,A,B,C,D`。\n\n- 按钮 $3$：交换播放列表中的前两首歌。例如：`A,B,C,D,E` 将变为 `B,A,C,D,E`。\n\n- 按钮 $4$：停止重新排列歌曲并输出播放列表。", "inputFormat": "你需要编写一个程序来模拟 CCC 音乐播放器。你的程序应反复询问两个正整数 b 和 n。这里 b 表示用户想按下的按钮编号，$1 \\leq b \\leq 4$，n 表示用户想按下按钮 b 的次数。你可以假设 n 总是满足 $1 \\leq n \\leq 10$。", "outputFormat": "输入总是以一对输入 $(b = 4, n = 1)$ 结束，当这种情况发生时，你应该打印当前播放列表中的歌曲顺序，并且你的程序应该结束。你可以假设用户只会按一次按钮 $4$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9856", "type": "P", "difficulty": 2, "samples": [["GPS", "15"], ["ECHO ROCK", "29"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["2008", "CCC（加拿大）"], "title": "[CCC 2008 J3] GPS Text Entry", "background": "", "description": "For her birthday, Sandy got a Global Positioning System (GPS) unit, which is an electronic device she can use to track the local hiking trails. Along the way Sandy can mark waypoints that can be recorded on a map when she gets home. A description of each waypoint can be entered in the unit, however the device does not have a keypad. Instead it has four cursor buttons, up, down, left, and right, and a button to accept the letter. The keypad looks like the following:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cqgjhd0p.png)\n\nThe screen displays a grid of the letters and symbols that can be used to “type out” the description. Here is the layout of the grid:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/btdfon2b.png)\n\nWhen you enter the name of the waypoint, the cursor starts at the `A`. You must move the cursor to the location of the next letter or symbol and then accept that letter. The cursor can only move to squares which are adjacent horizontally or vertically (not diagonally). Once you have entered all the letters in the description, you need to move the cursor to `enter` and accept the entire phrase.\n\nYou are to write a program that will calculate the number of cursor movements it takes to “type in” a phrase. For example, to enter the word `GPS`, starting from the `A` position, you would move down $1$ to select `G`, then move right $3$ and down $1$ to select `P`, then move down 1 and left $3$ to select `S` and finally move down $1$ and right $5$ to select `enter`. This is a total of $15$ cursor movements. Note that the total number of cursor movements does not change if you choose to move down and then across or across and then down. Also note that you cannot move beyond the boundaries of the grid (e.g., you cannot move off the grid nor `wrap-around` the grid).", "inputFormat": "The input for your program will be a string of at most $40$ characters. You may assume that all characters in the string are contained in the grid", "outputFormat": "The output for your program will be an integer that is the total number of cursor movements needed\nto enter the string using the grid layout given.", "hint": "数据保证合法。", "locale": "en", "translations": {"en": {"title": "[CCC 2008 J3] GPS Text Entry", "background": "", "description": "For her birthday, Sandy got a Global Positioning System (GPS) unit, which is an electronic device she can use to track the local hiking trails. Along the way Sandy can mark waypoints that can be recorded on a map when she gets home. A description of each waypoint can be entered in the unit, however the device does not have a keypad. Instead it has four cursor buttons, up, down, left, and right, and a button to accept the letter. The keypad looks like the following:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cqgjhd0p.png)\n\nThe screen displays a grid of the letters and symbols that can be used to “type out” the description. Here is the layout of the grid:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/btdfon2b.png)\n\nWhen you enter the name of the waypoint, the cursor starts at the `A`. You must move the cursor to the location of the next letter or symbol and then accept that letter. The cursor can only move to squares which are adjacent horizontally or vertically (not diagonally). Once you have entered all the letters in the description, you need to move the cursor to `enter` and accept the entire phrase.\n\nYou are to write a program that will calculate the number of cursor movements it takes to “type in” a phrase. For example, to enter the word `GPS`, starting from the `A` position, you would move down $1$ to select `G`, then move right $3$ and down $1$ to select `P`, then move down 1 and left $3$ to select `S` and finally move down $1$ and right $5$ to select `enter`. This is a total of $15$ cursor movements. Note that the total number of cursor movements does not change if you choose to move down and then across or across and then down. Also note that you cannot move beyond the boundaries of the grid (e.g., you cannot move off the grid nor `wrap-around` the grid).", "inputFormat": "The input for your program will be a string of at most $40$ characters. You may assume that all characters in the string are contained in the grid", "outputFormat": "The output for your program will be an integer that is the total number of cursor movements needed\nto enter the string using the grid layout given.", "hint": "数据保证合法。", "locale": "en"}, "zh-CN": {"title": "[CCC 2008 J3] GPS Text Entry", "background": "", "description": "在生日时，Sandy 收到了一个全球定位系统（GPS）设备，这是一种电子设备，她可以用来追踪本地的徒步旅行路线。途中，Sandy 可以标记航点，并在回家后将其记录在地图上。每个航点的描述可以输入到设备中，但设备没有键盘。相反，它有四个光标按钮：上、下、左、右，以及一个接受字母的按钮。键盘看起来如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cqgjhd0p.png)\n\n屏幕显示了可以用来“输入”描述的字母和符号的网格。网格布局如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/btdfon2b.png)\n\n当你输入航点的名称时，光标从 `A` 开始。你必须将光标移动到下一个字母或符号的位置，然后接受该字母。光标只能水平或垂直移动到相邻的方格（不能对角线移动）。一旦你输入了描述中的所有字母，你需要将光标移动到 `enter` 并接受整个短语。\n\n你需要编写一个程序来计算输入一个短语所需的光标移动次数。例如，要输入单词 `GPS`，从 `A` 位置开始，你需要向下移动 $1$ 次选择 `G`，然后向右移动 $3$ 次并向下移动 $1$ 次选择 `P`，然后向下移动 $1$ 次并向左移动 $3$ 次选择 `S`，最后向下移动 $1$ 次并向右移动 $5$ 次选择 `enter`。这总共需要 $15$ 次光标移动。注意，总的光标移动次数不会因为你选择先向下再向右或先向右再向下而改变。还要注意，你不能超出网格的边界（例如，你不能移出网格或“环绕”网格）。", "inputFormat": "你的程序的输入将是一个最多 $40$ 个字符的字符串。你可以假设字符串中的所有字符都包含在网格中。", "outputFormat": "你的程序的输出将是一个整数，即使用给定网格布局输入字符串所需的光标移动总数。", "hint": "数据保证合法。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9857", "type": "P", "difficulty": 2, "samples": [["1\n+ 1 2\n- 2 2\n+ 2 - 2 1\n- - 3 + 2 1 9\n0", "1\n1 2 +\n2 2 -\n2 2 1 - +\n3 2 1 + - 9 -"]], "limits": {"time": [1000, 1000, 1000], "memory": [131072, 131072, 131072]}, "tags": ["2008", "CCC（加拿大）"], "title": "[CCC 2008 J4] From Prefix to Postfix", "background": "", "description": "Prefix notation is a non-conventional notation for writing arithmetic expressions. The standard way of writing arithmetic expressions, also known as infix notation, positions a binary operator between the operands, e.g., $3 + 4$, while in prefix notation the operator is positioned before the operands, e.g., $+$ $3$ $4$. Similarly, the prefix notation for $5$ $-$ $2$ is $-$ $5$ $2$. A nice property of prefix expressions with binary operators is that parentheses are not required since there is no ambiguity about the order of operations. For example, the prefix representation of $5 - (4 - 2)$ is $-5$ $-$ $4$ $2$, while the prefix representation of $(5 - 4) - 2$ is $-$ $-$ $5$ $4$ $2$. The prefix notation is also known as Polish notation, due to Jan Łukasiewicz, a Polish logician, who invented it around $1920$.\n\nSimilarly, in postfix notation, orreverse Polish notation, the operator is positioned after the operands.\n\nFor example, postfix representation of the infix expression $(5 - 4) - 2$ is $5$ $4$ $-$ $2$ $-$. Your task is to write a program that translates a prefix arithmetic expression into a postfix arithmetic expression.", "inputFormat": "Each line contains an arithmetic prefix expression. The operators are $+$ and $-$, and numbers are all single-digit decimal numbers. The operators and numbers are separated by exactly one space with no leading spaces on the line. The end of input is marked by $0$ on a single line. You can assume that each input line contains a valid prefix expression with less than $20$ operators.", "outputFormat": "Translate each expression into postfix notation and produce it on a separate line. The numbers and operators are separated by at least one space. The final $0$ is not translated.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CCC 2008 J4] From Prefix to Postfix", "background": "", "description": "Prefix notation is a non-conventional notation for writing arithmetic expressions. The standard way of writing arithmetic expressions, also known as infix notation, positions a binary operator between the operands, e.g., $3 + 4$, while in prefix notation the operator is positioned before the operands, e.g., $+$ $3$ $4$. Similarly, the prefix notation for $5$ $-$ $2$ is $-$ $5$ $2$. A nice property of prefix expressions with binary operators is that parentheses are not required since there is no ambiguity about the order of operations. For example, the prefix representation of $5 - (4 - 2)$ is $-5$ $-$ $4$ $2$, while the prefix representation of $(5 - 4) - 2$ is $-$ $-$ $5$ $4$ $2$. The prefix notation is also known as Polish notation, due to Jan Łukasiewicz, a Polish logician, who invented it around $1920$.\n\nSimilarly, in postfix notation, orreverse Polish notation, the operator is positioned after the operands.\n\nFor example, postfix representation of the infix expression $(5 - 4) - 2$ is $5$ $4$ $-$ $2$ $-$. Your task is to write a program that translates a prefix arithmetic expression into a postfix arithmetic expression.", "inputFormat": "Each line contains an arithmetic prefix expression. The operators are $+$ and $-$, and numbers are all single-digit decimal numbers. The operators and numbers are separated by exactly one space with no leading spaces on the line. The end of input is marked by $0$ on a single line. You can assume that each input line contains a valid prefix expression with less than $20$ operators.", "outputFormat": "Translate each expression into postfix notation and produce it on a separate line. The numbers and operators are separated by at least one space. The final $0$ is not translated.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CCC 2008 J4] From Prefix to Postfix", "background": "", "description": "前缀表示法是一种非传统的算术表达式书写方式。标准的算术表达式书写方式，也被称为中缀表示法，将二元运算符置于操作数之间，例如 $3 + 4$，而在前缀表示法中，运算符置于操作数之前，例如 $+$ $3$ $4$。类似地，$5 - 2$ 的前缀表示法是 $-$ $5$ $2$。具有二元运算符的前缀表达式的一个优点是无需括号，因为运算顺序没有歧义。例如，$5 - (4 - 2)$ 的前缀表示为 $-5$ $-$ $4$ $2$，而 $(5 - 4) - 2$ 的前缀表示为 $-$ $-$ $5$ $4$ $2$。前缀表示法也被称为波兰表示法，以纪念波兰逻辑学家 Jan Łukasiewicz，他在 1920 年左右发明了这种表示法。\n\n类似地，在后缀表示法或逆波兰表示法中，运算符置于操作数之后。\n\n例如，中缀表达式 $(5 - 4) - 2$ 的后缀表示为 $5$ $4$ $-$ $2$ $-$。你的任务是编写一个程序，将前缀算术表达式转换为后缀算术表达式。", "inputFormat": "每行包含一个算术前缀表达式。运算符为 $+$ 和 $-$，数字均为单位数的十进制数。运算符和数字之间用一个空格分隔，行首没有空格。输入的结束由单独一行的 $0$ 标记。可以假设每个输入行包含少于 20 个运算符的有效前缀表达式。", "outputFormat": "将每个表达式转换为后缀表示法，并在单独的行上输出。数字和运算符之间至少用一个空格分隔。最后的 $0$ 不翻译。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9858", "type": "P", "difficulty": 1, "samples": [["Saskatoon -20\nToronto -2\nWinnipeg -40\nVancouver 8\nHalifax 0\nMontreal -4\nWaterloo -3", "Winnipeg"]], "limits": {"time": [1000, 1000, 1000], "memory": [131072, 131072, 131072]}, "tags": ["2008", "CCC（加拿大）"], "title": "[CCC 2008 S1] It’s Cold Here!", "background": "", "description": "Canada is cold in winter, but some parts are colder than others. Your task is very simple, you need to find the coldest city in Canada. So, when given a list of cities and their temperatures, you are to determine which city in the list has the lowest temperature and is thus the coldest.", "inputFormat": "The input is a sequence of city names and temperature values. Temperatures are integer, possibly preceded with a `-` sign. There is a single space between the city name and the temperature. No city name contains any whitespace and is always less than $256$ characters in length. There is at least one city in the list, no more than $10000$ cities, and the last city is always Waterloo. You may assume that the temperature is not less than $-273$ and not more than $200$.", "outputFormat": "You are to output the name of the coldest city on a single line with no whitespace before or after\nthe name. You may assume that there will not be more than one city which is the coldest.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CCC 2008 S1] It’s Cold Here!", "background": "", "description": "Canada is cold in winter, but some parts are colder than others. Your task is very simple, you need to find the coldest city in Canada. So, when given a list of cities and their temperatures, you are to determine which city in the list has the lowest temperature and is thus the coldest.", "inputFormat": "The input is a sequence of city names and temperature values. Temperatures are integer, possibly preceded with a `-` sign. There is a single space between the city name and the temperature. No city name contains any whitespace and is always less than $256$ characters in length. There is at least one city in the list, no more than $10000$ cities, and the last city is always Waterloo. You may assume that the temperature is not less than $-273$ and not more than $200$.", "outputFormat": "You are to output the name of the coldest city on a single line with no whitespace before or after\nthe name. You may assume that there will not be more than one city which is the coldest.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CCC 2008 S1] It’s Cold Here!", "background": "", "description": "加拿大的冬天很冷，但有些地方比其他地方更冷。你的任务非常简单，你需要找出加拿大最冷的城市。因此，当给定一个城市及其温度的列表时，你需要确定列表中哪个城市的温度最低，从而找出最冷的城市。", "inputFormat": "输入是一系列城市名称和温度值。温度是整数，可能带有 `-` 号。城市名称和温度之间有一个空格。没有城市名称包含空格，且长度总是小于 $256$ 个字符。列表中至少有一个城市，不超过 $10000$ 个城市，最后一个城市总是 Waterloo。你可以假设温度不低于 $-273$ 且不高于 $200$。", "outputFormat": "你需要在一行中输出最冷城市的名称，名称前后没有空格。可以假设不会有多个城市同时是最冷的。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9859", "type": "P", "difficulty": 2, "samples": [["2\n3\n4\n0", "13\n29\n49"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144]}, "tags": ["2008", "CCC（加拿大）"], "title": "[CCC 2008 S2] Pennies in the Ring", "background": "", "description": "The game “Pennies in the Ring” is often played by bored computer programmers who have gotten tired of playing solitare. The objective is to see how many pennies can be put into a circle. The circle is drawn on a grid, with its center at the coordinate $(0, 0)$. A single penny is placed on every integer grid coordinate (e.g., $(1, 1)$,$(1, 2)$, etc.) that lies within or on the circle. It’s not a very exciting game, but it’s very good for wasting time. Your goal is to calculate how many pennies are needed for a circle with a given radius.", "inputFormat": "The input is a sequence of positive integer values, one per line, where each integer is the radius of a circle. You can assume the radius will be less than or equal to $25000$. The last integer will be indicated by $0$. You may assume that the grid is large enough for two pennies to be on adjacent integer coordinates and not touch.", "outputFormat": "You are to output, each on its own line, the number of pennies needed for each circle. You do not need to output $0$ for the last $0$. You may assume that the number of possible pennies is less than $2$ billion (which is only $20$ million dollars: computer scientists have lots of money).", "hint": "", "locale": "en", "translations": {"en": {"title": "[CCC 2008 S2] Pennies in the Ring", "background": "", "description": "The game “Pennies in the Ring” is often played by bored computer programmers who have gotten tired of playing solitare. The objective is to see how many pennies can be put into a circle. The circle is drawn on a grid, with its center at the coordinate $(0, 0)$. A single penny is placed on every integer grid coordinate (e.g., $(1, 1)$,$(1, 2)$, etc.) that lies within or on the circle. It’s not a very exciting game, but it’s very good for wasting time. Your goal is to calculate how many pennies are needed for a circle with a given radius.", "inputFormat": "The input is a sequence of positive integer values, one per line, where each integer is the radius of a circle. You can assume the radius will be less than or equal to $25000$. The last integer will be indicated by $0$. You may assume that the grid is large enough for two pennies to be on adjacent integer coordinates and not touch.", "outputFormat": "You are to output, each on its own line, the number of pennies needed for each circle. You do not need to output $0$ for the last $0$. You may assume that the number of possible pennies is less than $2$ billion (which is only $20$ million dollars: computer scientists have lots of money).", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CCC 2008 S2] Pennies in the Ring", "background": "", "description": "游戏“环中的便士”通常由厌倦了玩纸牌的无聊计算机程序员玩。目标是看看可以在一个圆中放多少便士。圆画在一个网格上，其中心在坐标 $(0, 0)$。在每个整数网格坐标（例如，$(1, 1)$，$(1, 2)$ 等）上放置一个便士，该坐标位于圆内或圆上。这不是一个非常刺激的游戏，但非常适合消磨时间。你的目标是计算给定半径的圆需要多少便士。", "inputFormat": "输入是一系列正整数值，每行一个，其中每个整数是一个圆的半径。你可以假设半径将小于或等于 $25000$。最后一个整数将由 $0$ 指示。你可以假设网格足够大，以至于两个便士可以在相邻的整数坐标上而不接触。", "outputFormat": "你需要输出每个圆所需的便士数量，每个输出占一行。你不需要为最后的 $0$ 输出 $0$。你可以假设可能的便士数量小于 $20$ 亿（这仅仅是 $2000$ 万美元：计算机科学家有很多钱）。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9860", "type": "P", "difficulty": 2, "samples": [["3\n2\n2\n-|\n*+\n3\n5\n+||*+\n+++|+\n**--+\n2\n3\n+*+\n+*+\n", "3\n7\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["2008", "CCC（加拿大）"], "title": "[CCC 2008 S3] Maze", "background": "", "description": "In order to make a few dollars, you have decided to become part of a scientific experiment. You are fed lots of pizza, then more pizza and then you are asked to find your way across the city on a scooter powered only by pizza. Of course, the city has lots of intersections, and these intersections are very controlled. Some intersections are forbidden for you to enter; some only let you move north/south as you leave the intersection; others let you move only east/west as you leave the intersection; and the rest let you go in any compass direction (north, south, east or west).\n\nThankfully your scientific friends have given you a map of the city (on the back of a pizza box), with an arrangement of symbols indicating how you can move around the city. Specifically, there are 4 different symbols on the box:\n\n- The symbol `+` indicates we can move in any direction (north/south/east/west) from this location.\n\n- The symbol `-` indicates we can move only east or west from this location.\n\n- The symbol `|` indicates we can move only north or south from this location.\n\n- The symbol `*` indicates we cannot occupy this location.\n\nYour task is to determine how many intersections you must pass through to move from the northwest corner of the city to the south-east corner of the city.", "inputFormat": "The input begins with a number $t (1 \\leq t \\leq 10)$ on its own line, which indicates how many different cases are contained in this file. Each case begins with a number $r$ on one line, followed by a number $c$ on the next line $(1 \\leq r, c \\leq 20)$. The next $r$ lines contain $c$ characters, where each character is\none of {`+`, `*`, `-`, `|`}. You may assume the north-west corner of the city can be occupied (i.e., it will not be marked with `*`).", "outputFormat": "The output will be $t$ lines long, with one integer per line. The integer on line $i (1 \\leq i \\leq t)$ indicates the minimum number of intersections required to pass through as you move from the north-west corner of the city to the south-east corner of the city. If there is no way to get from the north-west corner to the south-east corner, output $−1$ for that test case.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CCC 2008 S3] Maze", "background": "", "description": "In order to make a few dollars, you have decided to become part of a scientific experiment. You are fed lots of pizza, then more pizza and then you are asked to find your way across the city on a scooter powered only by pizza. Of course, the city has lots of intersections, and these intersections are very controlled. Some intersections are forbidden for you to enter; some only let you move north/south as you leave the intersection; others let you move only east/west as you leave the intersection; and the rest let you go in any compass direction (north, south, east or west).\n\nThankfully your scientific friends have given you a map of the city (on the back of a pizza box), with an arrangement of symbols indicating how you can move around the city. Specifically, there are 4 different symbols on the box:\n\n- The symbol `+` indicates we can move in any direction (north/south/east/west) from this location.\n\n- The symbol `-` indicates we can move only east or west from this location.\n\n- The symbol `|` indicates we can move only north or south from this location.\n\n- The symbol `*` indicates we cannot occupy this location.\n\nYour task is to determine how many intersections you must pass through to move from the northwest corner of the city to the south-east corner of the city.", "inputFormat": "The input begins with a number $t (1 \\leq t \\leq 10)$ on its own line, which indicates how many different cases are contained in this file. Each case begins with a number $r$ on one line, followed by a number $c$ on the next line $(1 \\leq r, c \\leq 20)$. The next $r$ lines contain $c$ characters, where each character is\none of {`+`, `*`, `-`, `|`}. You may assume the north-west corner of the city can be occupied (i.e., it will not be marked with `*`).", "outputFormat": "The output will be $t$ lines long, with one integer per line. The integer on line $i (1 \\leq i \\leq t)$ indicates the minimum number of intersections required to pass through as you move from the north-west corner of the city to the south-east corner of the city. If there is no way to get from the north-west corner to the south-east corner, output $−1$ for that test case.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CCC 2008 S3] Maze", "background": "", "description": "为了赚点钱，你决定参与一个科学实验。你会被喂很多披萨，然后再吃更多的披萨，接着你需要骑着一辆仅靠披萨驱动的滑板车穿越城市。当然，城市里有很多交叉路口，这些路口受到严格控制。有些路口是禁止进入的；有些只允许你在离开路口时向北或向南移动；有些只允许你在离开路口时向东或向西移动；剩下的则允许你朝任意方向（北、南、东或西）移动。\n\n幸运的是，你的科学朋友给了你一张城市地图（在一个披萨盒的背面），上面用一些符号表示你可以如何在城市中移动。具体来说，盒子上有 4 种不同的符号：\n\n- 符号 `+` 表示我们可以从这个位置向任意方向（北/南/东/西）移动。\n- 符号 `-` 表示我们只能从这个位置向东或向西移动。\n- 符号 `|` 表示我们只能从这个位置向北或向南移动。\n- 符号 `*` 表示我们不能占据这个位置。\n\n你的任务是确定从城市的西北角移动到东南角需要经过多少个交叉路口。", "inputFormat": "输入以一个数字 $t (1 \\leq t \\leq 10)$ 开始，单独占一行，表示文件中包含多少个不同的测试用例。每个测试用例以一个数字 $r$ 开始，接下来一行是一个数字 $c$，其中 $(1 \\leq r, c \\leq 20)$。接下来的 $r$ 行包含 $c$ 个字符，其中每个字符是 {`+`, `*`, `-`, `|`} 中的一个。你可以假设城市的西北角可以被占据（即，它不会被标记为 `*`）。", "outputFormat": "输出将有 $t$ 行，每行一个整数。第 $i (1 \\leq i \\leq t)$ 行的整数表示从城市的西北角移动到东南角所需经过的最少交叉路口数。如果无法从西北角到达东南角，则对该测试用例输出 $-1$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9861", "type": "P", "difficulty": 3, "samples": [["3\n3\n3\n3\n3\n1\n1\n1\n1\n12\n5\n13\n1", "24\n4\n21"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["2008", "CCC（加拿大）"], "title": "[CCC 2008 S4] Twenty-four", "background": "", "description": "Twenty-four is a popular card game designed to be played by four players. Each player is dealt a deck of cards, which are kept face down. On every turn, each of the four players turns over the top card of his or her deck, so that it is visible to all. The goal is to find an arithmetic expression using the values of the cards (with $A$ meaning $1$, $J$ meaning $11$, $Q$ meaning $12$, and K meaning $13$) that evaluates to the number $24$. For example, for the example in the illustration, one possible expression would be:\n\n$((A \\times K) - J) \\times Q$\n\n$((1 \\times 13) - 11) \\times 12$\n\nThe first player to find such an expression wins the turn, and adds all four cards to the bottom of his or her deck.\n\nEach valid arithmetic expression must use all four cards, and must combine their values using addition, subtraction, multiplication, or division. Parentheses are allowed to specify precedence of operations. Juxtaposing cards to make multiple-digit decimal numbers is not allowed (e.g. you cannot place the cards $2$ and $4$ beside each other to make $24$). Non-integer quotients of division are also not allowed, even as a partial result (of a subexpression of the overall expression).\n\nIn some cases, the players may take a very long time to find an expression evaluating to $24$. In fact, in some cases, no such expression exists. Your task is to determine, given four cards, an expression that evaluates to the largest number less than or equal to $24$.", "inputFormat": "The first line contains an integer $1 \\leq N \\leq 5$ indicating the number of card hands that follow. Each hand consists of four lines. Each of these lines is an integer $1 \\leq C \\leq 13$ indicating the value of a card.", "outputFormat": "For each hand, output a line containing an integer n if the cards can be combined using arithmetic operators to evaluate to $n$. The value $n$ should be the largest possible value amongst all possible arithmetic expressions using these $4$ cards, so long as $n \\leq 24$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CCC 2008 S4] Twenty-four", "background": "", "description": "Twenty-four is a popular card game designed to be played by four players. Each player is dealt a deck of cards, which are kept face down. On every turn, each of the four players turns over the top card of his or her deck, so that it is visible to all. The goal is to find an arithmetic expression using the values of the cards (with $A$ meaning $1$, $J$ meaning $11$, $Q$ meaning $12$, and K meaning $13$) that evaluates to the number $24$. For example, for the example in the illustration, one possible expression would be:\n\n$((A \\times K) - J) \\times Q$\n\n$((1 \\times 13) - 11) \\times 12$\n\nThe first player to find such an expression wins the turn, and adds all four cards to the bottom of his or her deck.\n\nEach valid arithmetic expression must use all four cards, and must combine their values using addition, subtraction, multiplication, or division. Parentheses are allowed to specify precedence of operations. Juxtaposing cards to make multiple-digit decimal numbers is not allowed (e.g. you cannot place the cards $2$ and $4$ beside each other to make $24$). Non-integer quotients of division are also not allowed, even as a partial result (of a subexpression of the overall expression).\n\nIn some cases, the players may take a very long time to find an expression evaluating to $24$. In fact, in some cases, no such expression exists. Your task is to determine, given four cards, an expression that evaluates to the largest number less than or equal to $24$.", "inputFormat": "The first line contains an integer $1 \\leq N \\leq 5$ indicating the number of card hands that follow. Each hand consists of four lines. Each of these lines is an integer $1 \\leq C \\leq 13$ indicating the value of a card.", "outputFormat": "For each hand, output a line containing an integer n if the cards can be combined using arithmetic operators to evaluate to $n$. The value $n$ should be the largest possible value amongst all possible arithmetic expressions using these $4$ cards, so long as $n \\leq 24$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CCC 2008 S4] Twenty-four", "background": "", "description": "二十四点是一种流行的纸牌游戏，适合四名玩家进行。每位玩家会得到一副牌，牌面朝下。在每一轮中，每位玩家翻开自己牌堆顶的一张牌，使其对所有人可见。目标是使用这些牌的值（其中 $A$ 表示 $1$，$J$ 表示 $11$，$Q$ 表示 $12$，$K$ 表示 $13$）找到一个算术表达式，使其结果为 $24$。例如，在示例中，一个可能的表达式是：\n\n$((A \\times K) - J) \\times Q$\n\n$((1 \\times 13) - 11) \\times 12$\n\n第一个找到这样表达式的玩家赢得这一轮，并将四张牌放到自己牌堆的底部。\n\n每个有效的算术表达式必须使用所有四张牌，并且必须通过加法、减法、乘法或除法组合它们的值。允许使用括号来指定运算的优先级。不能将牌并列以构成多位十进制数（例如，不能将牌 $2$ 和 $4$ 并列以形成 $24$）。不允许非整数的除法结果，即使是作为整体表达式的子表达式的部分结果。\n\n在某些情况下，玩家可能需要很长时间才能找到一个结果为 $24$ 的表达式。实际上，在某些情况下，不存在这样的表达式。你的任务是给定四张牌，找出一个结果为小于或等于 $24$ 的最大数的表达式。", "inputFormat": "第一行包含一个整数 $1 \\leq N \\leq 5$，表示接下来有多少副牌。每副牌由四行组成。每行是一个整数 $1 \\leq C \\leq 13$，表示一张牌的值。", "outputFormat": "对于每副牌，如果这些牌可以通过算术运算符组合成一个结果为 $n$ 的表达式，则输出一行包含一个整数 $n$。值 $n$ 应该是在所有可能的算术表达式中不超过 $24$ 的最大值。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9862", "type": "P", "difficulty": 4, "samples": [["6\n0 2 0 2\n1 3 1 3\n1 5 0 3\n3 3 3 3\n8 8 6 7\n8 8 8 8", "Roland\nPatrick\nRoland\nRoland\nRoland\nPatrick"]], "limits": {"time": [2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288]}, "tags": ["2008", "CCC（加拿大）"], "title": "[CCC 2008 J5/S5] Nukit", "background": "注：J5 与 S5 仅数据范围有所不同，在此选取 S5 的数据范围及数据进行评测。", "description": "Canada’s top two nuclear scientists, Patrick and Roland, have just completed the construction of the world’s first nuclear fission reactor. Now it is their job to sit and operate the reactor all day, every day. Naturally they got a little bored after doing this for a while and as a result, two things have happened. First, they can now control the individual reactions that happen inside the reactor. Second, to pass the time, they have invented a new game called Nukit.\n\nAt the beginning of Nukit, a number of particles are put in the reactor. The players take alternating turns, with Patrick always going first. When it is a player’s turn to move, they must select some of the remaining particles to form one of the possible reactions. Then those particles are destroyed. Eventually there will be so few particles that none of the reactions can be formed; at this point, the first person who is unable to form a reaction on their turn loses.\n\nIn our universe you can assume that there are only $4$ types of particles: `A`, `B`, `C`, `D`. Each reaction is a list of particles that can be destroyed on a single turn. The five reactions are:\n\n$1.$ `AABDD`\n\n$2.$ `ABCD`\n\n$3.$ `CCD`\n\n$4.$ `BBB`\n\n$5.$ `AD`\n\nFor example, the first reaction `AABDD` says that it is allowable to destroy two `A`, one `B`, and two `D` particles all at the same time on a turn.\n\nIt turns out that, no matter how many particles start off in the reactor, exactly one of Patrick or Roland has a perfect winning strategy. By player $X$ has a perfect winning strategy, we mean that no matter what the other player does, player $X$ can always win by carefully choosing reactions.\n\nFor example, if the reactor starts off with one `A`, five `B`, and three `D` particles then Roland has the following perfect winning strategy: “if Patrick forms reaction `BBB` initially, then form reaction `AD` afterward; if Patrick forms reaction AD initially, then form reaction `BBB` afterward.” (The strategy works because either way, on Patrick’s second turn, there are not enough particles left to form any reactions.)\n\nGiven the number of each type of particle initially in the reactor, can you figure out who has a perfect winning strategy?", "inputFormat": "The first line of input contains $n$, the number of test cases $(1 \\leq n < 100)$. Each test case consists of $4$ integers separated by spaces on a single line; they represent the initial number of `A`, `B`, `C` and `D` particles. You can assume that there are initially between $0$ and $30$ (inclusive) of each type of particle.", "outputFormat": "For each test case, output the player who has a perfect winning strategy, either `Roland` or `Patrick`.", "hint": "Partial Explanation for Sample Output:\n\nThe first output occurs since Patrick loses immediately, since he cannot form any reaction. (Roland’s perfect winning strategy is “do nothing.”)\n\nThe second output occurs since Patrick has the perfect winning strategy “form reaction ABCD,” which makes Roland lose on his first turn.\n\nThe third output is explained in the problem statement.", "locale": "en", "translations": {"en": {"title": "[CCC 2008 J5/S5] Nukit", "background": "注：J5 与 S5 仅数据范围有所不同，在此选取 S5 的数据范围及数据进行评测。", "description": "Canada’s top two nuclear scientists, Patrick and Roland, have just completed the construction of the world’s first nuclear fission reactor. Now it is their job to sit and operate the reactor all day, every day. Naturally they got a little bored after doing this for a while and as a result, two things have happened. First, they can now control the individual reactions that happen inside the reactor. Second, to pass the time, they have invented a new game called Nukit.\n\nAt the beginning of Nukit, a number of particles are put in the reactor. The players take alternating turns, with Patrick always going first. When it is a player’s turn to move, they must select some of the remaining particles to form one of the possible reactions. Then those particles are destroyed. Eventually there will be so few particles that none of the reactions can be formed; at this point, the first person who is unable to form a reaction on their turn loses.\n\nIn our universe you can assume that there are only $4$ types of particles: `A`, `B`, `C`, `D`. Each reaction is a list of particles that can be destroyed on a single turn. The five reactions are:\n\n$1.$ `AABDD`\n\n$2.$ `ABCD`\n\n$3.$ `CCD`\n\n$4.$ `BBB`\n\n$5.$ `AD`\n\nFor example, the first reaction `AABDD` says that it is allowable to destroy two `A`, one `B`, and two `D` particles all at the same time on a turn.\n\nIt turns out that, no matter how many particles start off in the reactor, exactly one of Patrick or Roland has a perfect winning strategy. By player $X$ has a perfect winning strategy, we mean that no matter what the other player does, player $X$ can always win by carefully choosing reactions.\n\nFor example, if the reactor starts off with one `A`, five `B`, and three `D` particles then Roland has the following perfect winning strategy: “if Patrick forms reaction `BBB` initially, then form reaction `AD` afterward; if Patrick forms reaction AD initially, then form reaction `BBB` afterward.” (The strategy works because either way, on Patrick’s second turn, there are not enough particles left to form any reactions.)\n\nGiven the number of each type of particle initially in the reactor, can you figure out who has a perfect winning strategy?", "inputFormat": "The first line of input contains $n$, the number of test cases $(1 \\leq n < 100)$. Each test case consists of $4$ integers separated by spaces on a single line; they represent the initial number of `A`, `B`, `C` and `D` particles. You can assume that there are initially between $0$ and $30$ (inclusive) of each type of particle.", "outputFormat": "For each test case, output the player who has a perfect winning strategy, either `Roland` or `Patrick`.", "hint": "Partial Explanation for Sample Output:\n\nThe first output occurs since Patrick loses immediately, since he cannot form any reaction. (Roland’s perfect winning strategy is “do nothing.”)\n\nThe second output occurs since Patrick has the perfect winning strategy “form reaction ABCD,” which makes Roland lose on his first turn.\n\nThe third output is explained in the problem statement.", "locale": "en"}, "zh-CN": {"title": "[CCC 2008 J5/S5] Nukit", "background": "", "description": "加拿大的两位顶尖核科学家，Patrick 和 Roland，刚刚完成了世界上第一个核裂变反应堆的建造。现在，他们的工作是每天坐在反应堆前操作它。自然地，在这样做了一段时间后，他们有些无聊，因此发生了两件事。首先，他们现在可以控制反应堆内发生的个别反应。其次，为了打发时间，他们发明了一种叫做 Nukit 的新游戏。\n\n在 Nukit 的开始阶段，反应堆中放入了一些粒子。玩家轮流进行操作，Patrick 总是先走。当轮到一个玩家操作时，他们必须选择一些剩余的粒子来形成一个可能的反应。然后这些粒子被销毁。最终，粒子会变得如此之少，以至于无法形成任何反应；此时，第一个无法在其回合中形成反应的人输掉比赛。\n\n在我们的宇宙中，你可以假设只有 $4$ 种类型的粒子：`A`，`B`，`C`，`D`。每个反应都是可以在单个回合中销毁的粒子列表。五种反应是：\n\n1. `AABDD`\n\n2. `ABCD`\n\n3. `CCD`\n\n4. `BBB`\n\n5. `AD`\n\n例如，第一个反应 `AABDD` 表示可以在一个回合中同时销毁两个 `A`，一个 `B` 和两个 `D` 粒子。\n\n事实证明，无论反应堆中最初有多少粒子，Patrick 或 Roland 中总有一个人有完美的获胜策略。我们所说的玩家 $X$ 有完美的获胜策略，意味着无论另一个玩家做什么，玩家 $X$ 都可以通过仔细选择反应来获胜。\n\n例如，如果反应堆最初有一个 `A`，五个 `B` 和三个 `D` 粒子，那么 Roland 有以下完美的获胜策略：“如果 Patrick 最初形成反应 `BBB`，那么随后形成反应 `AD`；如果 Patrick 最初形成反应 `AD`，那么随后形成反应 `BBB`。”（策略有效，因为无论哪种方式，在 Patrick 的第二个回合中，剩余的粒子不足以形成任何反应。）\n\n给定反应堆中每种类型的粒子的初始数量，你能找出谁有完美的获胜策略吗？", "inputFormat": "输入的第一行包含 $n$，表示测试用例的数量 $(1 \\leq n < 100)$。每个测试用例由一行上的 $4$ 个整数组成，用空格分隔；它们表示 `A`，`B`，`C` 和 `D` 粒子的初始数量。你可以假设每种类型的粒子最初在 $0$ 到 $30$（含）之间。", "outputFormat": "对于每个测试用例，输出有完美获胜策略的玩家，`Roland` 或 `Patrick`。", "hint": "样例输出的部分解释：\n\n第一个输出发生是因为 Patrick 立即输掉，因为他无法形成任何反应。（Roland 的完美获胜策略是“什么都不做。”）\n\n第二个输出发生是因为 Patrick 有完美的获胜策略“形成反应 ABCD”，这使得 Roland 在他的第一个回合中输掉。\n\n第三个输出在问题陈述中已解释。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9863", "type": "P", "difficulty": 4, "samples": [["8 2 1", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["POI（波兰）", "2021", "2022"], "title": "[POI 2021/2022 R2] arm", "background": "翻译自 [POI2021-2022R2 Day0 试机题](https://szkopul.edu.pl/problemset/problem/gxeCvLD1xW1t-Y33bbC0n3wZ/statement/)。\n", "description": "初始时你有 $1$ 个物品，你需要将物品的数量按若干次以下步骤增加到 $> n$ 个。\n\n- 选择 $1$：将物品数量存储进数据库中，耗费 $a$ 的时间。\n- 选择 $2$：使物品数量增加等同于数据库中的数量，耗费 $b$ 的时间。\n\n初始时数据库为空，问最小操作次数。", "inputFormat": "输入一行，共三个整数 $n,a,b\\ (1 \\leq n \\leq 10^{18},1 \\leq a,b \\leq 10^9)$。", "outputFormat": "输出最小的操作次数。", "hint": "样例解释：\n\n初始时你有一个物品。  \n先进行一次扫描，耗费 $2$ 时间。  \n然后打印 $2$ 次，耗费 $1 \\times 2 = 2$ 时间，数量增加到 $3$。  \n继续进行扫描，耗费 $2$ 时间。  \n最后再打印 $2$ 次，耗费 $1 \\times 2 = 2$ 时间，数量变为 $9$。\n\n子任务分配：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: |\n| $1$ | $a = b = 1$ | $10$ |\n| $2$ | $n \\leq 10^3$ | $40$ |\n| $3$ | $n \\leq 10^5$ | $15$ |\n| $4$ | $n \\leq 10^9$ | $15$ |\n| $5$ | 无特殊限制 | $20$ |\n\n子任务 $0$ 为样例。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2021/2022 R2] arm", "background": "翻译自 [POI2021-2022R2 Day0 试机题](https://szkopul.edu.pl/problemset/problem/gxeCvLD1xW1t-Y33bbC0n3wZ/statement/)。\n", "description": "初始时你有 $1$ 个物品，你需要将物品的数量按若干次以下步骤增加到 $> n$ 个。\n\n- 选择 $1$：将物品数量存储进数据库中，耗费 $a$ 的时间。\n- 选择 $2$：使物品数量增加等同于数据库中的数量，耗费 $b$ 的时间。\n\n初始时数据库为空，问最小操作次数。", "inputFormat": "输入一行，共三个整数 $n,a,b\\ (1 \\leq n \\leq 10^{18},1 \\leq a,b \\leq 10^9)$。", "outputFormat": "输出最小的操作次数。", "hint": "样例解释：\n\n初始时你有一个物品。  \n先进行一次扫描，耗费 $2$ 时间。  \n然后打印 $2$ 次，耗费 $1 \\times 2 = 2$ 时间，数量增加到 $3$。  \n继续进行扫描，耗费 $2$ 时间。  \n最后再打印 $2$ 次，耗费 $1 \\times 2 = 2$ 时间，数量变为 $9$。\n\n子任务分配：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: |\n| $1$ | $a = b = 1$ | $10$ |\n| $2$ | $n \\leq 10^3$ | $40$ |\n| $3$ | $n \\leq 10^5$ | $15$ |\n| $4$ | $n \\leq 10^9$ | $15$ |\n| $5$ | 无特殊限制 | $20$ |\n\n子任务 $0$ 为样例。", "locale": "zh-CN"}}}
{"pid": "P9864", "type": "P", "difficulty": 6, "samples": [["6 2\n2 6\n1 2\n2 3\n2 4\n5 4\n5 6", "5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["POI（波兰）", "2021", "2022", "树形 DP"], "title": "[POI 2021/2022 R2] age", "background": "翻译自 [POI2021~2022R2 Day1T1](https://szkopul.edu.pl/problemset/problem/weKRWGa1NgLNHT1WLDo5ohuH/statement/)。\n", "description": "有一个 $n$ 个城市的国家，我们可以将其看为一棵 $n-1$ 条道路连接的树，有一天，你突发奇想，想要派出 $k$ 个人在不同城市上。人及其移动需要满足如下条件：\n\n- 每天只能是一个人移动，移动到其相邻存在道路连接一个城市。\n\n- 假如有两个人 $a,b$，城市 $i$ 被 $a$ 到达过了，则 $b$ 不能到达 $i$ 城市。\n\n初始时你知道了人的位置，每个人初始所在地不相同，且该城市视为“已到达过”的城市，你需要安排一个合法的经过城市的方案。\n\n请你求出最少要几天才能使所有的城市都被人到达过。", "inputFormat": "第一行两个整数 $n,k\\ (1 \\leq n \\leq 5 \\times 10^5, 1 \\leq k \\leq n)$。\n\n第二行 $k$ 个数，表示那些人的初始位置。\n\n然后 $n-1$ 行，描述了每条道路 $(a_i,b_i)\\ (1 \\leq a_i,b_i \\leq n)$。", "outputFormat": "输出最少天数。", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y9gojuv8.png)\n\n子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $n \\leq 10$ | $6$ |\n| $2$ | $n \\leq 20$ | $13$ |\n| $3$ | $n \\leq 2000$ | $27$ |\n| $4$ | $k=1$ | $10$ |\n| $5$ | $k=2$ | $7$ |\n| $6$ | 输入为一条链 | $7$ |\n| $7$ | 无特殊性质 | $30$ |\n\n子任务 $0$ 为样例。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2021/2022 R2] age", "background": "翻译自 [POI2021~2022R2 Day1T1](https://szkopul.edu.pl/problemset/problem/weKRWGa1NgLNHT1WLDo5ohuH/statement/)。\n", "description": "有一个 $n$ 个城市的国家，我们可以将其看为一棵 $n-1$ 条道路连接的树，有一天，你突发奇想，想要派出 $k$ 个人在不同城市上。人及其移动需要满足如下条件：\n\n- 每天只能是一个人移动，移动到其相邻存在道路连接一个城市。\n\n- 假如有两个人 $a,b$，城市 $i$ 被 $a$ 到达过了，则 $b$ 不能到达 $i$ 城市。\n\n初始时你知道了人的位置，每个人初始所在地不相同，且该城市视为“已到达过”的城市，你需要安排一个合法的经过城市的方案。\n\n请你求出最少要几天才能使所有的城市都被人到达过。", "inputFormat": "第一行两个整数 $n,k\\ (1 \\leq n \\leq 5 \\times 10^5, 1 \\leq k \\leq n)$。\n\n第二行 $k$ 个数，表示那些人的初始位置。\n\n然后 $n-1$ 行，描述了每条道路 $(a_i,b_i)\\ (1 \\leq a_i,b_i \\leq n)$。", "outputFormat": "输出最少天数。", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y9gojuv8.png)\n\n子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $n \\leq 10$ | $6$ |\n| $2$ | $n \\leq 20$ | $13$ |\n| $3$ | $n \\leq 2000$ | $27$ |\n| $4$ | $k=1$ | $10$ |\n| $5$ | $k=2$ | $7$ |\n| $6$ | 输入为一条链 | $7$ |\n| $7$ | 无特殊性质 | $30$ |\n\n子任务 $0$ 为样例。", "locale": "zh-CN"}}}
{"pid": "P9865", "type": "P", "difficulty": 4, "samples": [["10 3 4", "7 9 11 13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["POI（波兰）", "2021", "2022"], "title": "[POI 2021/2022 R2] lic", "background": "翻译自 [POI2021~2022R2 Day1T2](https://szkopul.edu.pl/problemset/problem/kQ5ExYNkFhx3K2FvVuXAAbn4/statement/)。", "description": "定义 $a$ 的「不友好数」$b$ 为 $\\gcd(a,b)=1$ 的数。\n\n现在你知道了数字 $n$，你需要求出它的「不友好数」升序排序第 $k$ 个开始后的 $c$ 个数。", "inputFormat": "一行，三个数 $n,k,c\\ (2 \\leq n \\leq 10^{14}, 1 \\leq k \\leq 10^{14}, 1 \\leq c \\leq 10^5)$。", "outputFormat": "输出 $c$ 个数，表示第 $k \\sim k+c-1$ 个 $n$ 的「不友好数」。", "hint": "样例解释：\n\n$10$ 的「不友好数」依次为 $1,3,7,9,11,13,17\\ldots$。\n\n子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :----------- | :----------- | :----------- |\n| $1$ | $n \\leq 10^6$ 且 $M \\leq n$ | $10$ |\n| $2$ | $f(n) \\leq 10^6$ 且 $M \\leq n$ | $36$ |\n| $3$ | $c \\leq 100$ | $30$ |\n| $4$ | 无特殊限制 | $24$ |\n\n上述 $M$ 为输出的最大值，$f(n)$ 为 $\\leq n$ 的「不友好数」数量。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2021/2022 R2] lic", "background": "翻译自 [POI2021~2022R2 Day1T2](https://szkopul.edu.pl/problemset/problem/kQ5ExYNkFhx3K2FvVuXAAbn4/statement/)。", "description": "定义 $a$ 的「不友好数」$b$ 为 $\\gcd(a,b)=1$ 的数。\n\n现在你知道了数字 $n$，你需要求出它的「不友好数」升序排序第 $k$ 个开始后的 $c$ 个数。", "inputFormat": "一行，三个数 $n,k,c\\ (2 \\leq n \\leq 10^{14}, 1 \\leq k \\leq 10^{14}, 1 \\leq c \\leq 10^5)$。", "outputFormat": "输出 $c$ 个数，表示第 $k \\sim k+c-1$ 个 $n$ 的「不友好数」。", "hint": "样例解释：\n\n$10$ 的「不友好数」依次为 $1,3,7,9,11,13,17\\ldots$。\n\n子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :----------- | :----------- | :----------- |\n| $1$ | $n \\leq 10^6$ 且 $M \\leq n$ | $10$ |\n| $2$ | $f(n) \\leq 10^6$ 且 $M \\leq n$ | $36$ |\n| $3$ | $c \\leq 100$ | $30$ |\n| $4$ | 无特殊限制 | $24$ |\n\n上述 $M$ 为输出的最大值，$f(n)$ 为 $\\leq n$ 的「不友好数」数量。", "locale": "zh-CN"}}}
{"pid": "P9866", "type": "P", "difficulty": 5, "samples": [["6\n......\n.X.##.\n..#.X.\n..X.#K\n.P#.X#\n.X....", "9\n2 3\nGGPPGPPDD\n"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200]}, "tags": ["POI（波兰）", "2021", "2022", "Special Judge"], "title": "[POI 2021/2022 R2] bom", "background": "翻译自 [POI2021~2022R2 Day2T1](https://szkopul.edu.pl/problemset/problem/MfTrGDTrlrVX21vwwhgsjaLv/statement/)。\n\n时限：sub1 和 sub4 8s，sub2 2s, sub3 3s。", "description": "你有一个 $n \\times n$ 的图，仅包含 `.`、`X`、`P`、`K`、`#`，意义如下：\n\n- `P` 起点。\n- `K` 终点。\n- `.` 可以通过的路。\n- `X` 不可以通过的岩石墙。\n- `#` 不可以通过的砖墙。\n\n你还有一枚炸弹，你选择一个不是岩石墙的地方放置，爆炸时，会从原来的地方上下左右依次扩散爆炸直到某一方向碰到了岩石墙或超出了图的范围。  \n爆炸区域变为空地，但岩石墙不会。\n\n然后你需要求出起点至终点的最短路径。", "inputFormat": "第一行一个整数 $n\\ (2 \\leq n \\leq 1000)$。\n\n然后 $n \\times n$ 大小的字符矩阵，描述了图。", "outputFormat": "如果放置完炸弹并引爆后有解，则输出三行：\n\n- 第一行：最短路径长度。\n- 第二行：放置炸弹位置。\n- 第三行：其中符合条件的最短路径（其中 `G` 表示向上，`D` 表示向下，`L` 表示向左，`P` 表示向右）。\n\n若无解，输出 `NIE`。", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v7jk5v8b.png)\n\n子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: |\n| $1$ | 不含砖墙 | $10$ |\n| $2$ | $n \\leq 50$ | $20$ |\n| $3$ | $n \\leq 200$ | $30$ |\n| $4$ | 无特殊限制 | $40$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2021/2022 R2] bom", "background": "翻译自 [POI2021~2022R2 Day2T1](https://szkopul.edu.pl/problemset/problem/MfTrGDTrlrVX21vwwhgsjaLv/statement/)。\n\n时限：sub1 和 sub4 8s，sub2 2s, sub3 3s。", "description": "你有一个 $n \\times n$ 的图，仅包含 `.`、`X`、`P`、`K`、`#`，意义如下：\n\n- `P` 起点。\n- `K` 终点。\n- `.` 可以通过的路。\n- `X` 不可以通过的岩石墙。\n- `#` 不可以通过的砖墙。\n\n你还有一枚炸弹，你选择一个不是岩石墙的地方放置，爆炸时，会从原来的地方上下左右依次扩散爆炸直到某一方向碰到了岩石墙或超出了图的范围。  \n爆炸区域变为空地，但岩石墙不会。\n\n然后你需要求出起点至终点的最短路径。", "inputFormat": "第一行一个整数 $n\\ (2 \\leq n \\leq 1000)$。\n\n然后 $n \\times n$ 大小的字符矩阵，描述了图。", "outputFormat": "如果放置完炸弹并引爆后有解，则输出三行：\n\n- 第一行：最短路径长度。\n- 第二行：放置炸弹位置。\n- 第三行：其中符合条件的最短路径（其中 `G` 表示向上，`D` 表示向下，`L` 表示向左，`P` 表示向右）。\n\n若无解，输出 `NIE`。", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v7jk5v8b.png)\n\n子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: |\n| $1$ | 不含砖墙 | $10$ |\n| $2$ | $n \\leq 50$ | $20$ |\n| $3$ | $n \\leq 200$ | $30$ |\n| $4$ | 无特殊限制 | $40$ |\n", "locale": "zh-CN"}}}
{"pid": "P9867", "type": "P", "difficulty": 7, "samples": [["7\n? 1\nZ 2\n? 1\nZ 1\nW 2\n? 2\n? 3", "1\n2\n3\n2"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["POI（波兰）", "2021", "2022"], "title": "[POI 2021/2022 R2] kon", "background": "翻译自 [POI2021~2022R2 Day2T2](https://szkopul.edu.pl/problemset/problem/TEuljz3gsotYQRUKdlEZZr1G/statement/)。\n", "description": "有一个舞会，一开始角色只有 $1$、$2$，他们两个都愿意和彼此跳舞。\n\n然后存在 $q$ 个事件，分别对应下方的操作：\n\n- `W x`：表示新加入一个人，他和编号 $x$ 的人愿意互相和对方跳舞。\n- `Z x`：表示新加入一个人，初始时他和编号为 $x$ 的人愿意跳舞的对象都互相同意跳舞。\n- `? x`：表示查询愿意与 $x$ 跳舞的有几个人。\n\n新加入的人的编号是当前人数加一。", "inputFormat": "第一行一个整数 $q\\ (1 \\leq q \\leq 10^6)$。\n\n然后 $q$ 行，每行一个字符和一个整数 $x$，含义如题目描述所述。", "outputFormat": "对应每个 `?` 操作，输出一行答案。", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qvrwztvc.png)\n\n子任务分配：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $q \\leq 5000$ | $20$ |\n| $2$ | 仅包含操作 `Z` 和 `?` | $10$ |\n| $3$ | `?` 总是在 $q$ 次操作的末尾部分出现 | $35$ |\n| $4$ | 无附加限制 | $35$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2021/2022 R2] kon", "background": "翻译自 [POI2021~2022R2 Day2T2](https://szkopul.edu.pl/problemset/problem/TEuljz3gsotYQRUKdlEZZr1G/statement/)。\n", "description": "有一个舞会，一开始角色只有 $1$、$2$，他们两个都愿意和彼此跳舞。\n\n然后存在 $q$ 个事件，分别对应下方的操作：\n\n- `W x`：表示新加入一个人，他和编号 $x$ 的人愿意互相和对方跳舞。\n- `Z x`：表示新加入一个人，初始时他和编号为 $x$ 的人愿意跳舞的对象都互相同意跳舞。\n- `? x`：表示查询愿意与 $x$ 跳舞的有几个人。\n\n新加入的人的编号是当前人数加一。", "inputFormat": "第一行一个整数 $q\\ (1 \\leq q \\leq 10^6)$。\n\n然后 $q$ 行，每行一个字符和一个整数 $x$，含义如题目描述所述。", "outputFormat": "对应每个 `?` 操作，输出一行答案。", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qvrwztvc.png)\n\n子任务分配：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $q \\leq 5000$ | $20$ |\n| $2$ | 仅包含操作 `Z` 和 `?` | $10$ |\n| $3$ | `?` 总是在 $q$ 次操作的末尾部分出现 | $35$ |\n| $4$ | 无附加限制 | $35$ |\n", "locale": "zh-CN"}}}
{"pid": "P9868", "type": "P", "difficulty": 2, "samples": [["4 7\nabandon\nbananaa\nbaannaa\nnotnotn\n", "1110"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2023", "NOIP 提高组", "O2优化"], "title": "[NOIP2023] 词典", "background": "", "description": "小 S 的词典里有 $n$ 个两两不同的、长度均为 $m$ 的单词 $w_1,w_2,\\cdots,w_n$。每个单词都是一个小写字母构成的字符串。\n\n小 S 可以做以下操作任意多次（可以不做）：选择词典中的任意一个单词，交换其中任意两个字符。\n\n对于每个 $1 \\le i \\le n$，小 S 想知道，是否可以通过以上操作得到新的 $n$ 个单词 $w'_1,w'_2,\\cdots , w'_n$，使得对于每个 $j \\neq i$，$w'_i$ 的字典序比 $w'_j$ 都要小。**对于 $n=1$ 的情况，我们约定：上述性质是自然成立的。**\n\n对于两个同样长度的字符串 $s = s_1s_2\\cdots s_L$ 和 $t = t_1t_2 \\cdots t_L$，称字符串 $s$ 字典序小于字符串 $t$，当且仅当以下条件成立：存在位置 $i$，在第 $i$ 个字符之前 $s$ 和 $t$ 都相同，而且 $s_i < t_i$，即小写字母 $s_i$ 在英文字母顺序中先于 $t_i$。", "inputFormat": "输入的第一行包含两个正整数 $n$ 和 $m$，分别表示单词个数和单词长度。\n\n接下来 $n$ 行，每行包含一个长度为 $m$ 的小写字母字符串 $w_i$， 表示一个单词。", "outputFormat": "输出一行，其中包含一个长度为 $n$ 的 `01` 字符串 $a$；对于 $1 \\le i \\le n$，如果题目描述中的性质成立，则 $a_i =$ `1`，否则 $a_i =$ `0`。", "hint": "**【样例解释 #1】**\n\n- 不做任何操作，第一个单词字典序最小，因此输出第一个字符为 `1`；\n- 交换 `bananaa` 的前两个字符以及 `abandon` 的第三个和第六个字符，得到 `abondan`, `abnanaa`, `baannaa`, `notnotn`，此时第二个单词字典序最小，因此输出第二个字符为 `1`；\n- 交换 `baannaa` 的第一个和最后一个字符得到 `aaannab`，其余字符串不变，此时第三个单词字典序最小，因此输出第三个字符为 `1`；\n- 无论如何操作，第四个单词不会小于第二个单词，因此输出第四个字符为 `0`。\n\n**【样例解释 #2】**\n\n该组样例满足测试点 $4$ 的限制。\n\n**【样例解释 #3】**\n\n该组样例满足测试点 $7$ 的限制。\n\n**【样例解释 #4】**\n\n该组样例满足测试点 $10$ 的限制。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$1 \\le n \\le 3000$，$1 \\le m \\le 3000$，$w_i$ 为长度为 $m$ 的小写字母字符串且两两不同。\n\n| 测试点编号 | $n\\leq$ | $m\\leq$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $1$ | $1$ |\n| $2\\sim 4$ | $26$ | $1$ |\n| $5\\sim 7$ | $15$ | $2$ |\n| $8$ | $300$ | $300$ |\n| $9$ | $10^3$ | $10^3$ |\n| $10$ | $3000$ | $3000$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOIP2023] 词典", "background": "", "description": "小 S 的词典里有 $n$ 个两两不同的、长度均为 $m$ 的单词 $w_1,w_2,\\cdots,w_n$。每个单词都是一个小写字母构成的字符串。\n\n小 S 可以做以下操作任意多次（可以不做）：选择词典中的任意一个单词，交换其中任意两个字符。\n\n对于每个 $1 \\le i \\le n$，小 S 想知道，是否可以通过以上操作得到新的 $n$ 个单词 $w'_1,w'_2,\\cdots , w'_n$，使得对于每个 $j \\neq i$，$w'_i$ 的字典序比 $w'_j$ 都要小。**对于 $n=1$ 的情况，我们约定：上述性质是自然成立的。**\n\n对于两个同样长度的字符串 $s = s_1s_2\\cdots s_L$ 和 $t = t_1t_2 \\cdots t_L$，称字符串 $s$ 字典序小于字符串 $t$，当且仅当以下条件成立：存在位置 $i$，在第 $i$ 个字符之前 $s$ 和 $t$ 都相同，而且 $s_i < t_i$，即小写字母 $s_i$ 在英文字母顺序中先于 $t_i$。", "inputFormat": "输入的第一行包含两个正整数 $n$ 和 $m$，分别表示单词个数和单词长度。\n\n接下来 $n$ 行，每行包含一个长度为 $m$ 的小写字母字符串 $w_i$， 表示一个单词。", "outputFormat": "输出一行，其中包含一个长度为 $n$ 的 `01` 字符串 $a$；对于 $1 \\le i \\le n$，如果题目描述中的性质成立，则 $a_i =$ `1`，否则 $a_i =$ `0`。", "hint": "**【样例解释 #1】**\n\n- 不做任何操作，第一个单词字典序最小，因此输出第一个字符为 `1`；\n- 交换 `bananaa` 的前两个字符以及 `abandon` 的第三个和第六个字符，得到 `abondan`, `abnanaa`, `baannaa`, `notnotn`，此时第二个单词字典序最小，因此输出第二个字符为 `1`；\n- 交换 `baannaa` 的第一个和最后一个字符得到 `aaannab`，其余字符串不变，此时第三个单词字典序最小，因此输出第三个字符为 `1`；\n- 无论如何操作，第四个单词不会小于第二个单词，因此输出第四个字符为 `0`。\n\n**【样例解释 #2】**\n\n该组样例满足测试点 $4$ 的限制。\n\n**【样例解释 #3】**\n\n该组样例满足测试点 $7$ 的限制。\n\n**【样例解释 #4】**\n\n该组样例满足测试点 $10$ 的限制。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$1 \\le n \\le 3000$，$1 \\le m \\le 3000$，$w_i$ 为长度为 $m$ 的小写字母字符串且两两不同。\n\n| 测试点编号 | $n\\leq$ | $m\\leq$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $1$ | $1$ |\n| $2\\sim 4$ | $26$ | $1$ |\n| $5\\sim 7$ | $15$ | $2$ |\n| $8$ | $300$ | $300$ |\n| $9$ | $10^3$ | $10^3$ |\n| $10$ | $3000$ | $3000$ |", "locale": "zh-CN"}}}
{"pid": "P9869", "type": "P", "difficulty": 4, "samples": [["1 3\n3 3\n- 2 1\n- 3 2\n+ 1 3\n3 3\n- 2 1\n- 3 2\n- 1 3\n2 2\nT 2\nU 2\n", "0\n3\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["并查集", "2023", "NOIP 提高组", "O2优化", "二分图", "基环树"], "title": "[NOIP2023] 三值逻辑", "background": null, "description": "小 L 今天学习了 Kleene 三值逻辑。\n\n在三值逻辑中，一个变量的值可能为：真（$\\mathit{True}$，简写作 $\\mathit{T}$）、假（$\\mathit{False}$，简写作 $\\mathit{F}$）或未确定（$\\mathit{Unknown}$，简写作 $\\mathit{U}$）。\n\n在三值逻辑上也可以定义逻辑运算。由于小 L 学习进度很慢，只掌握了逻辑非运算 $\\lnot$，其运算法则为：\n$$\\lnot \\mathit{T} = \\mathit{F}, \\lnot \\mathit{F} = \\mathit{T}, \\lnot\\mathit{U} = \\mathit{U}.$$\n\n现在小 L 有 $n$ 个三值逻辑变量 $x_1,\\cdots, x_n$。小 L 想进行一些有趣的尝试，于是他写下了 $m$ 条语句。语句有以下三种类型，其中 $\\leftarrow$ 表示赋值：\n\n1. $x_i \\leftarrow v$，其中 $v$ 为 $\\mathit{T}, \\mathit{F}, \\mathit{U}$ 的一种；\n2. $x_i \\leftarrow x_j$；\n3. $x_i \\leftarrow \\lnot x_j$。\n\n一开始，小 L 会给这些变量赋初值，然后按顺序运行这 $m$ 条语句。\n\n小 L 希望执行了所有语句后，所有变量的最终值与初值都相等。在此前提下，小 L 希望初值中 $\\mathit{Unknown}$ 的变量尽可能少。\n\n在本题中，你需要帮助小 L 找到 $\\mathit{Unknown}$ 变量个数最少的赋初值方案，使得执行了所有语句后所有变量的最终值和初始值相等。小 L 保证，至少对于本题的所有测试用例，这样的赋初值方案都必然是存在的。", "inputFormat": "**本题的测试点包含有多组测试数据。**\n\n输入的第一行包含两个整数 $c$ 和 $t$，分别表示测试点编号和测试数据组数。对于样例，$c$ 表示该样例与测试点 $c$ 拥有相同的限制条件。\n\n接下来，对于每组测试数据：\n\n- 输入的第一行包含两个整数 $n$ 和 $m$，分别表示变量个数和语句条数。\n- 接下来 $m$ 行，按运行顺序给出每条语句。\n  - 输入的第一个字符 $v$ 描述这条语句的类型。保证 $v$ 为 `TFU+-` 的其中一种。\n  - 若 $v$ 为 `TFU` 的某一种时，接下来给出一个整数 $i$，表示该语句为 $x_i \\leftarrow v$；\n  - 若 $v$ 为 `+`，接下来给出两个整数 $i,j$，表示该语句为 $x_i \\leftarrow x_j$；\n  - 若 $v$ 为 `-`，接下来给出两个整数 $i,j$，表示该语句为 $x_i \\leftarrow \\lnot x_j$。", "outputFormat": "对于每组测试数据输出一行一个整数，表示所有符合条件的赋初值方案中，$\\mathit{Unknown}$ 变量个数的最小值。", "hint": "**【样例解释 #1】**\n\n第一组测试数据中，$m$ 行语句依次为\n\n- $x_2 \\leftarrow \\lnot x_1$；\n- $x_3 \\leftarrow \\lnot x_2$；\n- $x_1 \\leftarrow x_3$。\n\n一组合法的赋初值方案为 $x_1 = \\mathit{T}, x_2 = \\mathit{F}, x_3 = \\mathit{T}$，共有 $0$ 个 $\\mathit{Unknown}$ 变量。因为不存在赋初值方案中有小于 $0$ 个 $\\mathit{Unknown}$ 变量，故输出为 $0$。\n\n第二组测试数据中，$m$ 行语句依次为\n\n- $x_2 \\leftarrow \\lnot x_1$；\n- $x_3 \\leftarrow \\lnot x_2$；\n- $x_1 \\leftarrow \\lnot x_3$。\n\n唯一的赋初值方案为 $x_1 = x_2 = x_3 = \\mathit{U}$，共有 $3$ 个 $\\mathit{Unknown}$ 变量，故输出为 $3$。\n\n第三组测试数据中，$m$ 行语句依次为\n\n- $x_2 \\leftarrow \\mathit{T}$；\n- $x_2 \\leftarrow \\mathit{U}$；\n\n一个最小化 $\\mathit{Unknown}$ 变量个数的赋初值方案为 $x_1 = \\mathit{T}, x_2 = \\mathit{U}$。$x_1 = x_2 = \\mathit{U}$ 也是一个合法的方案，但它没有最小化 $\\mathit{Unknown}$ 变量的个数。\n\n**【样例解释 #2】**\n\n该组样例满足测试点 $2$ 的条件。\n\n**【样例解释 #3】**\n\n该组样例满足测试点 $5$ 的条件。\n\n**【样例解释 #4】**\n\n该组样例满足测试点 $8$ 的条件。\n\n**【数据范围】**\n\n对于所有测试数据，保证：\n\n- $1 \\le t \\le 6$，$1 \\le n,m \\le 10 ^ 5$；\n- 对于每个操作，$v$ 为 `TFU+-` 中的某个字符，$1 \\le i,j \\le n$。\n\n| 测试点编号 | $n,m\\leq$ | $v$ 可能的取值 |\n| :----------: | :----------: | :----------: |\n| $1,2$ | $10$ | $\\mathit{TFU+-}$ |\n| $3$ | $10^3$ | $\\mathit{TFU}$ |\n| $4$ | $10^5$ | $\\mathit{TFU}$ |\n| $5$ | $10^3$ | $\\mathit{U+}$ |\n| $6$ | $10^5$ | $\\mathit{U+}$ |\n| $7$ | $10^3$ | $\\mathit{+-}$ |\n| $8$ | $10^5$ | $\\mathit{+-}$ |\n| $9$ | $10^3$ | $\\mathit{TFU+-}$ |\n| $10$ | $10^5$ | $\\mathit{TFU+-}$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOIP2023] 三值逻辑", "background": null, "description": "小 L 今天学习了 Kleene 三值逻辑。\n\n在三值逻辑中，一个变量的值可能为：真（$\\mathit{True}$，简写作 $\\mathit{T}$）、假（$\\mathit{False}$，简写作 $\\mathit{F}$）或未确定（$\\mathit{Unknown}$，简写作 $\\mathit{U}$）。\n\n在三值逻辑上也可以定义逻辑运算。由于小 L 学习进度很慢，只掌握了逻辑非运算 $\\lnot$，其运算法则为：\n$$\\lnot \\mathit{T} = \\mathit{F}, \\lnot \\mathit{F} = \\mathit{T}, \\lnot\\mathit{U} = \\mathit{U}.$$\n\n现在小 L 有 $n$ 个三值逻辑变量 $x_1,\\cdots, x_n$。小 L 想进行一些有趣的尝试，于是他写下了 $m$ 条语句。语句有以下三种类型，其中 $\\leftarrow$ 表示赋值：\n\n1. $x_i \\leftarrow v$，其中 $v$ 为 $\\mathit{T}, \\mathit{F}, \\mathit{U}$ 的一种；\n2. $x_i \\leftarrow x_j$；\n3. $x_i \\leftarrow \\lnot x_j$。\n\n一开始，小 L 会给这些变量赋初值，然后按顺序运行这 $m$ 条语句。\n\n小 L 希望执行了所有语句后，所有变量的最终值与初值都相等。在此前提下，小 L 希望初值中 $\\mathit{Unknown}$ 的变量尽可能少。\n\n在本题中，你需要帮助小 L 找到 $\\mathit{Unknown}$ 变量个数最少的赋初值方案，使得执行了所有语句后所有变量的最终值和初始值相等。小 L 保证，至少对于本题的所有测试用例，这样的赋初值方案都必然是存在的。", "inputFormat": "**本题的测试点包含有多组测试数据。**\n\n输入的第一行包含两个整数 $c$ 和 $t$，分别表示测试点编号和测试数据组数。对于样例，$c$ 表示该样例与测试点 $c$ 拥有相同的限制条件。\n\n接下来，对于每组测试数据：\n\n- 输入的第一行包含两个整数 $n$ 和 $m$，分别表示变量个数和语句条数。\n- 接下来 $m$ 行，按运行顺序给出每条语句。\n  - 输入的第一个字符 $v$ 描述这条语句的类型。保证 $v$ 为 `TFU+-` 的其中一种。\n  - 若 $v$ 为 `TFU` 的某一种时，接下来给出一个整数 $i$，表示该语句为 $x_i \\leftarrow v$；\n  - 若 $v$ 为 `+`，接下来给出两个整数 $i,j$，表示该语句为 $x_i \\leftarrow x_j$；\n  - 若 $v$ 为 `-`，接下来给出两个整数 $i,j$，表示该语句为 $x_i \\leftarrow \\lnot x_j$。", "outputFormat": "对于每组测试数据输出一行一个整数，表示所有符合条件的赋初值方案中，$\\mathit{Unknown}$ 变量个数的最小值。", "hint": "**【样例解释 #1】**\n\n第一组测试数据中，$m$ 行语句依次为\n\n- $x_2 \\leftarrow \\lnot x_1$；\n- $x_3 \\leftarrow \\lnot x_2$；\n- $x_1 \\leftarrow x_3$。\n\n一组合法的赋初值方案为 $x_1 = \\mathit{T}, x_2 = \\mathit{F}, x_3 = \\mathit{T}$，共有 $0$ 个 $\\mathit{Unknown}$ 变量。因为不存在赋初值方案中有小于 $0$ 个 $\\mathit{Unknown}$ 变量，故输出为 $0$。\n\n第二组测试数据中，$m$ 行语句依次为\n\n- $x_2 \\leftarrow \\lnot x_1$；\n- $x_3 \\leftarrow \\lnot x_2$；\n- $x_1 \\leftarrow \\lnot x_3$。\n\n唯一的赋初值方案为 $x_1 = x_2 = x_3 = \\mathit{U}$，共有 $3$ 个 $\\mathit{Unknown}$ 变量，故输出为 $3$。\n\n第三组测试数据中，$m$ 行语句依次为\n\n- $x_2 \\leftarrow \\mathit{T}$；\n- $x_2 \\leftarrow \\mathit{U}$；\n\n一个最小化 $\\mathit{Unknown}$ 变量个数的赋初值方案为 $x_1 = \\mathit{T}, x_2 = \\mathit{U}$。$x_1 = x_2 = \\mathit{U}$ 也是一个合法的方案，但它没有最小化 $\\mathit{Unknown}$ 变量的个数。\n\n**【样例解释 #2】**\n\n该组样例满足测试点 $2$ 的条件。\n\n**【样例解释 #3】**\n\n该组样例满足测试点 $5$ 的条件。\n\n**【样例解释 #4】**\n\n该组样例满足测试点 $8$ 的条件。\n\n**【数据范围】**\n\n对于所有测试数据，保证：\n\n- $1 \\le t \\le 6$，$1 \\le n,m \\le 10 ^ 5$；\n- 对于每个操作，$v$ 为 `TFU+-` 中的某个字符，$1 \\le i,j \\le n$。\n\n| 测试点编号 | $n,m\\leq$ | $v$ 可能的取值 |\n| :----------: | :----------: | :----------: |\n| $1,2$ | $10$ | $\\mathit{TFU+-}$ |\n| $3$ | $10^3$ | $\\mathit{TFU}$ |\n| $4$ | $10^5$ | $\\mathit{TFU}$ |\n| $5$ | $10^3$ | $\\mathit{U+}$ |\n| $6$ | $10^5$ | $\\mathit{U+}$ |\n| $7$ | $10^3$ | $\\mathit{+-}$ |\n| $8$ | $10^5$ | $\\mathit{+-}$ |\n| $9$ | $10^3$ | $\\mathit{TFU+-}$ |\n| $10$ | $10^5$ | $\\mathit{TFU+-}$ |", "locale": "zh-CN"}}}
