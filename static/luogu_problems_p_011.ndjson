{"pid": "P3786", "type": "P", "difficulty": 5, "samples": [["5 5 10 3 3\n1 1\n1 11\n1\n3 4\n5 2\n3 5\n1 1\n5 4\n3 4\n2 1\n1 1\n1 1\n5 5", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创", "最短路", "进制", "洛谷比赛", "状压 DP"], "title": "萃香抱西瓜", "background": " ![](https://cdn.luogu.com.cn/upload/pic/5565.png) \n\n伊吹萃香 (Ibuki Suika) 正在魔法之森漫步，突然，许多西瓜 (Suika) 从四周飞来，划出了绚丽的轨迹。虽然阵势有点恐怖，但她还是决定抱走一些西瓜。\n", "description": "萃香所处的环境被简化为一个长为 $h$，宽为 $w$ 的网格平面。$X$ 坐标范围为 $[1,w]$，$Y$ 坐标范围为 $[1,h]$。\n\n她初始时（第 $1$ 个时刻）站在坐标为 $(sx,sy)$ 的方格。\n\n西瓜可能在任意一个方格出现，在每个时间单位，它们可能向任何一个方向移动，也可能静止不动。西瓜的位置和移动的轨迹是已知的。西瓜的总数为 $n$ 个，但只有 $m$ 个西瓜可以被萃香抱走，因为其他都太大了，可能会砸伤她。\n\n整个过程会持续 $T$ 个时刻。萃香希望可以抱走全部的 $m$ 个西瓜，并且在任何时候避免与任何一个过大的西瓜处在同一位置。抱走的方式为在某个时刻，与该西瓜处于同一位置。另外，由于萃香不愿耗费过多体力到处乱跑，她每个时刻可以选择静止不动，也可以选择移动到相邻的四个格子之一，只要不越出环境边界。如果选择移动到相邻格子，则算作移动了一次。第 $1$ 个时刻萃香刚站定，无法移动。\n\n在每个时刻，如果萃香选择移动，可以认为萃香与西瓜同时从原来的位置移到了新的位置，没有先后顺序。\n\n萃香想要知道，不被任何一个大西瓜砸中，并得到所有的m个小西瓜的情况下，最少需要移动多少次。\n", "inputFormat": "第一行五个整数 $h,w,T,sx,sy$ ，含义见题目描述。\n\n第二行两个整数 $n,m$，含义见题目描述。\n\n接下来 $n$ 段数据，每一段描述了一个西瓜的出现位置，时间，移动方式，是否可以被抱走等内容，具体如下:\n\n首先一行，两个整数 $t1,t2$，表示西瓜在 $t1$ 时刻出现，$t2$ 时刻消失。若 $t2=T+1$，表示西瓜在最后一个时刻也不消失。保证西瓜至少存在一个时刻。\n\n接下来一行一个整数 $a$，只能为 $0$ 或 $1$，$0$ 表示这个西瓜需要避开，$1$ 表示这个西瓜需要抱走。数据保证需要抱走的西瓜恰好有 $m$ 个。\n\n接下来 $t2-t1$ 行，每一行两个整数 $x,y$，顺序描述了从 $t1$ 时刻到 $t2-1$ 时刻，该西瓜的坐标。西瓜的移动不一定是连续的，并且是一瞬间完成的，所以无需考虑萃香是否站在了移动路径上。\n", "outputFormat": "如果萃香在整个 $T$ 时刻内无法避免被大西瓜砸中或者无法收集到所有 $m$ 个小西瓜，输出 $-1$，否则输出一个整数，表示萃香需要移动的最少次数。\n", "hint": "\n### 样例说明\n第 $2 \\sim 4$ 个时刻萃香站着不动，在第 $6$ 个时刻，西瓜出现在萃香旁边，萃香移动到 $(3,4)$ 位置即可抱走这个西瓜。\n\n### 数据范围和提示\n\n本题采用捆绑测试。\n\nSubtask $1$：具有特殊性质 A 和 B；\n\nSubtask $2 \\sim 3$：仅具有特殊性质 A；\n\nSubtask $4 \\sim 5$：仅具有特殊性质 B；\n\nSubtask $6 \\sim 10$：不具有任何一个特殊性质。\n\n特殊性质 A：对于所有西瓜，均满足 $t1=1,t2=T+1$。\n所有西瓜全程都静止在原地，不会发生移动。\n\n特殊性质 B：$m=0$。\n\n对于全部子任务，满足：\n\n$1 \\le x \\le w,1 \\le y \\le h$\n\n$1\\le n \\le 20,\n0 \\le m \\le 10,\nm \\le n$\n\n$1 \\le h,w \\le 5,\n1 \\le T \\le 100,\n1 \\le t1 \\le T,\n2 \\le t2 \\le T+1,\nt1< t2$\n\n\n保证一个位置不会同时出现两个或两个以上西瓜。", "locale": "zh-CN", "translations": {"en": {"title": "Suika Hugs Watermelons", "background": "![](https://cdn.luogu.com.cn/upload/pic/5565.png)\n\nIbuki Suika (pinyin: Yībùcuìxiāng; Ibuki Suika) is strolling through the Forest of Magic when suddenly many watermelons (Suika) fly in from all directions, tracing brilliant paths. Although the scene is a bit scary, she still decides to pick up some watermelons.", "description": "Suika’s environment is simplified to a grid of length $h$ and width $w$. The $X$-coordinate range is $[1, w]$, and the $Y$-coordinate range is $[1, h]$.\n\nAt the initial moment (time $1$), she stands on the cell at coordinates $(sx, sy)$.\n\nA watermelon may appear on any cell. At each time unit, it may move in any direction or stay still. The positions and trajectories of all watermelons are known. The total number of watermelons is $n$, but only $m$ of them can be picked up by Suika; the others are too big and may hurt her.\n\nThe whole process lasts for $T$ time steps. Suika wants to pick up all $m$ small watermelons while avoiding being at the same position as any big watermelon at any time. To pick up a watermelon, she must be at the same position as that watermelon at some time step. Also, because Suika does not want to run around too much, at each time step she may either stay still or move to one of the four adjacent cells, as long as she does not leave the grid. If she moves to an adjacent cell, it counts as one move. At time $1$, Suika has just taken her position and cannot move.\n\nAt each time step, if Suika chooses to move, you may assume that Suika and the watermelons move from their old positions to their new positions simultaneously, with no order.\n\nSuika wants to know the minimum number of moves needed to avoid all big watermelons and collect all $m$ small watermelons.", "inputFormat": "The first line contains five integers $h, w, T, sx, sy$, as described above.\n\nThe second line contains two integers $n, m$, as described above.\n\nThen follow $n$ blocks. Each block describes a watermelon's appearance time, disappearance time, movement, and whether it can be picked up:\n\n- First line: two integers $t1, t2$, meaning the watermelon appears at time $t1$ and disappears at time $t2$. If $t2 = T + 1$, the watermelon does not disappear even at the last time step. It is guaranteed that each watermelon exists for at least one time step.\n- Next line: one integer $a$, either $0$ or $1$. $0$ means this watermelon must be avoided; $1$ means this watermelon must be picked up. It is guaranteed that exactly $m$ watermelons need to be picked up.\n- Next $t2 - t1$ lines: each line contains two integers $x, y$, in order describing the coordinates of this watermelon from time $t1$ to time $t2 - 1$. A watermelon’s movement may be non-continuous and happens instantaneously, so you do not need to consider whether Suika was on the movement path.", "outputFormat": "If Suika cannot avoid being hit by any big watermelon during the $T$ time steps or cannot collect all $m$ small watermelons, output $-1$. Otherwise, output a single integer, the minimum number of moves Suika needs.", "hint": "### Sample Explanation\nFrom times $2$ to $4$, Suika stays still. At time $6$, a watermelon appears next to her; Suika can move to $(3, 4)$ to pick it up.\n\n### Constraints and Hint\nThis problem uses bundled testdata.\n\nSubtask 1: has special properties A and B.\n\nSubtasks 2–3: has only special property A.\n\nSubtasks 4–5: has only special property B.\n\nSubtasks 6–10: has neither special property.\n\nSpecial property A: For all watermelons, $t1 = 1, t2 = T + 1$. All watermelons stay still the whole time.\n\nSpecial property B: $m = 0$.\n\nFor all subtasks, the following hold:\n\n$1 \\le x \\le w, 1 \\le y \\le h$.\n\n$1 \\le n \\le 20, 0 \\le m \\le 10, m \\le n$.\n\n$1 \\le h, w \\le 5, 1 \\le T \\le 100, 1 \\le t1 \\le T, 2 \\le t2 \\le T + 1, t1 < t2$.\n\nIt is guaranteed that no position will contain two or more watermelons at the same time.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "萃香抱西瓜", "background": " ![](https://cdn.luogu.com.cn/upload/pic/5565.png) \n\n伊吹萃香 (Ibuki Suika) 正在魔法之森漫步，突然，许多西瓜 (Suika) 从四周飞来，划出了绚丽的轨迹。虽然阵势有点恐怖，但她还是决定抱走一些西瓜。\n", "description": "萃香所处的环境被简化为一个长为 $h$，宽为 $w$ 的网格平面。$X$ 坐标范围为 $[1,w]$，$Y$ 坐标范围为 $[1,h]$。\n\n她初始时（第 $1$ 个时刻）站在坐标为 $(sx,sy)$ 的方格。\n\n西瓜可能在任意一个方格出现，在每个时间单位，它们可能向任何一个方向移动，也可能静止不动。西瓜的位置和移动的轨迹是已知的。西瓜的总数为 $n$ 个，但只有 $m$ 个西瓜可以被萃香抱走，因为其他都太大了，可能会砸伤她。\n\n整个过程会持续 $T$ 个时刻。萃香希望可以抱走全部的 $m$ 个西瓜，并且在任何时候避免与任何一个过大的西瓜处在同一位置。抱走的方式为在某个时刻，与该西瓜处于同一位置。另外，由于萃香不愿耗费过多体力到处乱跑，她每个时刻可以选择静止不动，也可以选择移动到相邻的四个格子之一，只要不越出环境边界。如果选择移动到相邻格子，则算作移动了一次。第 $1$ 个时刻萃香刚站定，无法移动。\n\n在每个时刻，如果萃香选择移动，可以认为萃香与西瓜同时从原来的位置移到了新的位置，没有先后顺序。\n\n萃香想要知道，不被任何一个大西瓜砸中，并得到所有的m个小西瓜的情况下，最少需要移动多少次。\n", "inputFormat": "第一行五个整数 $h,w,T,sx,sy$ ，含义见题目描述。\n\n第二行两个整数 $n,m$，含义见题目描述。\n\n接下来 $n$ 段数据，每一段描述了一个西瓜的出现位置，时间，移动方式，是否可以被抱走等内容，具体如下:\n\n首先一行，两个整数 $t1,t2$，表示西瓜在 $t1$ 时刻出现，$t2$ 时刻消失。若 $t2=T+1$，表示西瓜在最后一个时刻也不消失。保证西瓜至少存在一个时刻。\n\n接下来一行一个整数 $a$，只能为 $0$ 或 $1$，$0$ 表示这个西瓜需要避开，$1$ 表示这个西瓜需要抱走。数据保证需要抱走的西瓜恰好有 $m$ 个。\n\n接下来 $t2-t1$ 行，每一行两个整数 $x,y$，顺序描述了从 $t1$ 时刻到 $t2-1$ 时刻，该西瓜的坐标。西瓜的移动不一定是连续的，并且是一瞬间完成的，所以无需考虑萃香是否站在了移动路径上。\n", "outputFormat": "如果萃香在整个 $T$ 时刻内无法避免被大西瓜砸中或者无法收集到所有 $m$ 个小西瓜，输出 $-1$，否则输出一个整数，表示萃香需要移动的最少次数。\n", "hint": "\n### 样例说明\n第 $2 \\sim 4$ 个时刻萃香站着不动，在第 $6$ 个时刻，西瓜出现在萃香旁边，萃香移动到 $(3,4)$ 位置即可抱走这个西瓜。\n\n### 数据范围和提示\n\n本题采用捆绑测试。\n\nSubtask $1$：具有特殊性质 A 和 B；\n\nSubtask $2 \\sim 3$：仅具有特殊性质 A；\n\nSubtask $4 \\sim 5$：仅具有特殊性质 B；\n\nSubtask $6 \\sim 10$：不具有任何一个特殊性质。\n\n特殊性质 A：对于所有西瓜，均满足 $t1=1,t2=T+1$。\n所有西瓜全程都静止在原地，不会发生移动。\n\n特殊性质 B：$m=0$。\n\n对于全部子任务，满足：\n\n$1 \\le x \\le w,1 \\le y \\le h$\n\n$1\\le n \\le 20,\n0 \\le m \\le 10,\nm \\le n$\n\n$1 \\le h,w \\le 5,\n1 \\le T \\le 100,\n1 \\le t1 \\le T,\n2 \\le t2 \\le T+1,\nt1< t2$\n\n\n保证一个位置不会同时出现两个或两个以上西瓜。", "locale": "zh-CN"}}}
{"pid": "P3787", "type": "P", "difficulty": 5, "samples": [["4\n1 2 1.00000000\n2 3 0.00000000\n3 4 1.00000101\n9\n1 1 3.00000000\n9 2\n9 3\n1 2 1.42856031\n9 4\n9 2\n1 3 4.23333333\n9 2\n9 4", "3.00000000\n0.00000000\n0.00000000\n4.42856031\n4.42856031\n4.23333761"]], "limits": {"time": [900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "线段树", "树状数组", "洛谷原创", "Special Judge", "洛谷比赛"], "title": "冰精冻西瓜", "background": "![](https://cdn.luogu.com.cn/upload/pic/5279.png) \n\n盛夏，冰之妖精琪露诺发现了一大片西瓜地，终于可以吃到美味的冻西瓜啦。", "description": "琪露诺是拥有操纵冷气程度的能力的妖精，一天她发现了一片西瓜地。这里有 $n$ 个西瓜，由 $n-1$ 条西瓜蔓连接，形成一个有根树，琪露诺想要把它们冷冻起来慢慢吃。\n\n这些西瓜蔓具有神奇的性质，可以将经过它的冷气的寒冷程度放大或缩小，每条西瓜蔓放大/缩小冷气寒冷程度的能力值为 $w_i$，表示冷气经过它后，寒冷程度值 $x$ 会变为 $ x\\times w_i$。每个西瓜也有一个寒冷程度值，炎热的夏日，所有西瓜的寒冷程度值初始都为 $0$。\n\n琪露诺会做出两种动作:\n\n①.对着西瓜 $i$ 放出寒冷程度为 $x$ 的冷气。这股冷气顺着西瓜蔓向“西瓜树”的叶子节点蔓延，冷气的寒冷程度会按照上面的规则变化。遇到一个西瓜连了多条西瓜蔓时，每条叶子节点方向的西瓜蔓均会获得与原先寒冷程度相等的冷气。途径的所有西瓜的寒冷程度值都会加上冷气的寒冷程度值。\n\n**冷气只会向释放点的子树蔓延，不会向根方向蔓延**\n\n⑨.向你询问西瓜 $i$ 的寒冷程度值是多少。\n\n等等，为什么会有⑨？因为笨蛋琪露诺自己也会忘记放了多少冰呢。\n\n所以，帮她计算的任务就这么交给你啦。", "inputFormat": "第一行一个整数 $n$，表示西瓜的数量。\n\n西瓜编号为 $1\\sim n$，$1$ 为这棵“西瓜树”的根。\n\n接下来 $n-1$ 行，每行有两个整数 $u$、$v$ 和一个实数 $w$，表示西瓜 $u$ 和西瓜 $v$ 之间连接有一条藤蔓，它放大/缩小冷气寒冷程度的能力值为 $w$。\n\n接下来一行一个整数 $m$，表示操作的数量。\n\n接下来 $m$ 行，每行两个整数或两个整数和一个实数。\n\n第一个数只能是 $1$ 或 $9$。\n\n如果为 $1$，接下来一个整数 $i$ 和一个实数 $x$，表示对西瓜 $i$ 放出寒冷程度为 $x$ 的冷气。\n\n如果为 $9$，接下来一个整数 $i$，表示询问编号为 $i$ 的西瓜的寒冷程度值。", "outputFormat": "对于每个操作⑨，输出一行一个实数，表示对应西瓜的寒冷程度值。", "hint": "子任务可能出现如下的特殊性质:\n\n“西瓜树”退化为一条链\n\n输入数据中的实数均保留8位小数，选手的答案被判作正确当且仅当输出与标准答案误差不超过 $10^{-7}$。请特别注意浮点数精度问题。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5278.png) \n\n实际数据中，冷气的寒冷程度x的范围为 $[-0.1,0.1]$\n\n(样例中的冷气寒冷程度的范围为 $[1,5]$)\n\n命题人:orangebird,鸣谢oscar。", "locale": "zh-CN", "translations": {"en": {"title": "The Ice Fairy Freezes Watermelons", "background": "![](https://cdn.luogu.com.cn/upload/pic/5279.png) \n\nIn midsummer, the ice fairy Cirno discovered a large watermelon field. She can finally enjoy delicious frozen watermelons.", "description": "Cirno is a fairy who can control how cold the air is. One day she found a watermelon field. There are $n$ watermelons, connected by $n-1$ vines, forming a rooted tree. Cirno wants to freeze them and eat them slowly.\n\nThese watermelon vines have a magical property: they can amplify or attenuate the coldness of the passing cold air. Each vine has a multiplier $w_i$, meaning that after the cold air passes through it, a coldness value $x$ becomes $ x\\times w_i$. Each watermelon also has a coldness value, and on a hot summer day all watermelons start with coldness $0$.\n\nCirno performs two types of actions:\n\n①. Release cold air of coldness $x$ at watermelon $i$. This cold air spreads along the vines toward the leaves of the \"watermelon tree\", and its coldness changes according to the above rule. When a watermelon has multiple outgoing vines toward leaf nodes, each vine gets cold air with the same coldness as before the split. Every watermelon along the path adds the current coldness of the air to its own coldness.\n\n**The cold air only spreads within the subtree of the release point and never toward the root.**\n\n⑨. Ask for the coldness value of watermelon $i$.\n\nWait, why is there a ⑨? Because silly Cirno herself sometimes forgets how much ice she has released.\n\nSo please help her compute it.", "inputFormat": "The first line contains an integer $n$, the number of watermelons.\n\nThe watermelons are numbered $1$ to $n$, and $1$ is the root of this \"watermelon tree\".\n\nThe next $n-1$ lines each contain two integers $u$, $v$ and a real number $w$, indicating that there is a vine between watermelons $u$ and $v$, and its amplification/attenuation multiplier is $w$.\n\nThe next line contains an integer $m$, the number of operations.\n\nEach of the next $m$ lines contains either two integers, or two integers and a real number.\n\nThe first number can only be $1$ or $9$.\n\nIf it is $1$, then an integer $i$ and a real number $x$ follow, meaning to release cold air of coldness $x$ at watermelon $i$.\n\nIf it is $9$, then an integer $i$ follows, meaning to query the coldness value of watermelon $i$.", "outputFormat": "For each operation ⑨, output one line with a real number, the coldness value of the corresponding watermelon.", "hint": "A subtask may have the following special property:\n\nThe \"watermelon tree\" degenerates into a chain.\n\nAll real numbers in the input keep 8 decimal places. A solution is accepted if and only if the absolute error from the standard answer is at most $10^{-7}$. Please pay special attention to floating-point precision.\n\n![](https://cdn.luogu.com.cn/upload/pic/5278.png) \n\nIn the actual testdata, the range of the coldness $x$ of the cold air is $[-0.1, 0.1]$.\n\n(In the samples, the range of the coldness is $[1, 5]$.)\n\nProblem setter: orangebird, thanks to oscar.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "冰精冻西瓜", "background": "![](https://cdn.luogu.com.cn/upload/pic/5279.png) \n\n盛夏，冰之妖精琪露诺发现了一大片西瓜地，终于可以吃到美味的冻西瓜啦。", "description": "琪露诺是拥有操纵冷气程度的能力的妖精，一天她发现了一片西瓜地。这里有 $n$ 个西瓜，由 $n-1$ 条西瓜蔓连接，形成一个有根树，琪露诺想要把它们冷冻起来慢慢吃。\n\n这些西瓜蔓具有神奇的性质，可以将经过它的冷气的寒冷程度放大或缩小，每条西瓜蔓放大/缩小冷气寒冷程度的能力值为 $w_i$，表示冷气经过它后，寒冷程度值 $x$ 会变为 $ x\\times w_i$。每个西瓜也有一个寒冷程度值，炎热的夏日，所有西瓜的寒冷程度值初始都为 $0$。\n\n琪露诺会做出两种动作:\n\n①.对着西瓜 $i$ 放出寒冷程度为 $x$ 的冷气。这股冷气顺着西瓜蔓向“西瓜树”的叶子节点蔓延，冷气的寒冷程度会按照上面的规则变化。遇到一个西瓜连了多条西瓜蔓时，每条叶子节点方向的西瓜蔓均会获得与原先寒冷程度相等的冷气。途径的所有西瓜的寒冷程度值都会加上冷气的寒冷程度值。\n\n**冷气只会向释放点的子树蔓延，不会向根方向蔓延**\n\n⑨.向你询问西瓜 $i$ 的寒冷程度值是多少。\n\n等等，为什么会有⑨？因为笨蛋琪露诺自己也会忘记放了多少冰呢。\n\n所以，帮她计算的任务就这么交给你啦。", "inputFormat": "第一行一个整数 $n$，表示西瓜的数量。\n\n西瓜编号为 $1\\sim n$，$1$ 为这棵“西瓜树”的根。\n\n接下来 $n-1$ 行，每行有两个整数 $u$、$v$ 和一个实数 $w$，表示西瓜 $u$ 和西瓜 $v$ 之间连接有一条藤蔓，它放大/缩小冷气寒冷程度的能力值为 $w$。\n\n接下来一行一个整数 $m$，表示操作的数量。\n\n接下来 $m$ 行，每行两个整数或两个整数和一个实数。\n\n第一个数只能是 $1$ 或 $9$。\n\n如果为 $1$，接下来一个整数 $i$ 和一个实数 $x$，表示对西瓜 $i$ 放出寒冷程度为 $x$ 的冷气。\n\n如果为 $9$，接下来一个整数 $i$，表示询问编号为 $i$ 的西瓜的寒冷程度值。", "outputFormat": "对于每个操作⑨，输出一行一个实数，表示对应西瓜的寒冷程度值。", "hint": "子任务可能出现如下的特殊性质:\n\n“西瓜树”退化为一条链\n\n输入数据中的实数均保留8位小数，选手的答案被判作正确当且仅当输出与标准答案误差不超过 $10^{-7}$。请特别注意浮点数精度问题。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5278.png) \n\n实际数据中，冷气的寒冷程度x的范围为 $[-0.1,0.1]$\n\n(样例中的冷气寒冷程度的范围为 $[1,5]$)\n\n命题人:orangebird,鸣谢oscar。", "locale": "zh-CN"}}}
{"pid": "P3788", "type": "P", "difficulty": 5, "samples": [["2\n90 270\n315 45", "0.0%\n70.7%"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "洛谷原创", "洛谷比赛"], "title": "幽幽子吃西瓜", "background": " ![](https://cdn.luogu.com.cn/upload/pic/5575.png) \n\n西行寺幽幽子是冥界的亡灵，她是一个标准的吃货，现在她的面前摆着一个妖梦替她准备的大西瓜。\n", "description": "妖梦费了好大的劲为幽幽子准备了一个大西瓜，甚至和兔子铃仙打了一架。现在妖梦闲来无事，就蹲在一旁看幽幽子吃西瓜。西瓜可以看作一个标准的球体，瓜皮是绿色的，瓜瓤是红色的，瓜皮的厚度可视为0。妖梦恰好以正视的角度看着这个西瓜。幽幽子是一个吃货，妖梦一走神，自己背后的刀就不见了，而西瓜也被切掉了一块。幽幽子切西瓜时刀面始终垂直于桌面，并且切下的一块在俯视图中正好是一个以西瓜中心为顶点，半径为西瓜半径的扇形。如图所示，是一种满足条件的情况\n\n俯视:\n\n ![](https://cdn.luogu.com.cn/upload/pic/5576.png) \n\n正视:\n\n ![](https://cdn.luogu.com.cn/upload/pic/5577.png) \n\n妖梦看着红红绿绿的西瓜，忽然陷入思考，红色的西瓜瓤占整个西瓜可视面积的百分之多少呢？但她对几何一窍不通，于是想问问幽幽子，但幽幽子正抱着切下来的西瓜大吃特吃，没有理会妖梦。于是她想让你来帮她解决这个问题。\n\n为了方便描述问题，我们为俯视图建立一个平面极坐标系，极点在俯视图圆形(扇形)的正中央，极轴方向竖直向下。极轴所对应的角度为0度，角度逆时针依次增加，直到转一圈又回到极轴。因此角度范围是[0,360)。幽幽子会切掉西瓜从a°到b°的这一整块。\n", "inputFormat": "第一行一个整数T，表示数据组数。\n\n接下来T行每行两个整数a,b。表示切掉范围的起始角度和终止角度。若a>b，则切掉的角度为[a,360)∪[0,b]这一范围。\n", "outputFormat": "T行，每行一个实数后跟一个百分号“%”，表示被切掉一部分的西瓜的正视图(平行投影)中，红色的西瓜瓤占西瓜总可视面积的百分比。在此题中，妖梦的视野方向平行于俯视图的极轴，并且极轴射线指向妖梦。\n\n输出的实数四舍五入保留一位小数，你的答案被判作正确，当且仅当与标准答案完全相同。\n", "hint": "样例说明:\n\n第一个样例中，切掉的西瓜恰好在背面，在妖梦的角度看起来与未切过的西瓜并无区别，因此输出0%。第二个样例中，切掉了从315°~45°这一部分,经过计算，得到答案为sqrt(2)/2，化成小数得到0.707,即70.7%\n\n本题目共有10个测试点。\n\n对于第1个测试点，a,b∈{0,90,180,270}。\n\n对于第2个测试点，270<=a<=359,0<=b<=90。\n\n对于第3,4个测试点，180<=a<=359,0<=b<=179。\n\n对于全部测试点，0<=a,b<=359,a≠b。\n\n1<=T<=10000\n\n命题人:orangebird\n", "locale": "zh-CN", "translations": {"en": {"title": "Yuyuko Eats Watermelon", "background": "![](https://cdn.luogu.com.cn/upload/pic/5575.png) \n\nSaigyouji Yuyuko is a spirit of the Netherworld. She is a typical foodie. Right now, a big watermelon prepared by Youmu is placed in front of her.", "description": "Youmu put great effort into preparing a big watermelon for Yuyuko, even getting into a fight with the rabbit Reisen. Now, with nothing else to do, Youmu squats to the side and watches Yuyuko eat the watermelon. The watermelon can be regarded as a perfect sphere: the rind is green, the flesh is red, and the rind’s thickness can be considered 0. Youmu is looking at this watermelon head-on (front view). Because Yuyuko is such a foodie, the moment Youmu looks away, the sword behind her goes missing, and a piece of the watermelon has been cut off. While Yuyuko is cutting, the blade’s plane is always vertical to the tabletop, and the piece she cuts off appears in the top view exactly as a sector whose vertex is at the watermelon’s center and whose radius equals the watermelon’s radius. As shown in the figure, this is one valid situation.\n\nTop view:\n\n ![](https://cdn.luogu.com.cn/upload/pic/5576.png) \n\nFront view:\n\n ![](https://cdn.luogu.com.cn/upload/pic/5577.png) \n\nLooking at the red-and-green watermelon, Youmu suddenly wonders: what percentage of the visible area of the watermelon is the red flesh? However, she knows nothing about geometry. She wants to ask Yuyuko, but Yuyuko is busy devouring the cut-off piece and ignores her. So Youmu wants you to help solve this problem.\n\nTo make the problem easier to describe, we set up a plane polar coordinate system on the top view. The pole is at the exact center of the circular (sector) top view, and the polar axis points straight downward. The polar angle corresponding to the axis is 0 degrees. Angles increase counterclockwise until a full rotation returns to the polar axis. Therefore, the angle range is $[0, 360)$. Yuyuko will cut off the entire sector from $a^\\circ$ to $b^\\circ$.", "inputFormat": "The first line contains an integer T, the number of test cases.\n\nEach of the next T lines contains two integers a and b, representing the starting and ending angles of the cut range. If $a > b$, then the cut angle range is $[a, 360) \\cup [0, b]$.", "outputFormat": "Output T lines. Each line contains a real number followed by a percent sign \"%\", representing the percentage of the red watermelon flesh area in the front view (parallel projection) of the watermelon after the cut. In this problem, Youmu’s viewing direction is parallel to the polar axis in the top view, and the ray of the polar axis points toward Youmu.\n\nRound the real number to one digit after the decimal point. Your answer is judged correct if and only if it matches the standard answer exactly.", "hint": "Sample explanation:\n\nIn the first sample, the cut is exactly on the back side. From Youmu’s point of view, it looks no different from an uncut watermelon, so the output is 0%.\n\nIn the second sample, the cut is from $315^\\circ$ to $45^\\circ$. After calculation, the answer is $\\sqrt{2}/2$, whose decimal is 0.707, i.e., 70.7%.\n\nThere are 10 test points in total.\n\nFor test point 1, $a, b \\in \\{0, 90, 180, 270\\}$.\n\nFor test point 2, $270 \\le a \\le 359$, $0 \\le b \\le 90$.\n\nFor test points 3–4, $180 \\le a \\le 359$, $0 \\le b \\le 179$.\n\nFor all test points, $0 \\le a, b \\le 359$, $a \\ne b$.\n\n$1 \\le T \\le 10000$.\n\nAuthor: orangebird.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "幽幽子吃西瓜", "background": " ![](https://cdn.luogu.com.cn/upload/pic/5575.png) \n\n西行寺幽幽子是冥界的亡灵，她是一个标准的吃货，现在她的面前摆着一个妖梦替她准备的大西瓜。\n", "description": "妖梦费了好大的劲为幽幽子准备了一个大西瓜，甚至和兔子铃仙打了一架。现在妖梦闲来无事，就蹲在一旁看幽幽子吃西瓜。西瓜可以看作一个标准的球体，瓜皮是绿色的，瓜瓤是红色的，瓜皮的厚度可视为0。妖梦恰好以正视的角度看着这个西瓜。幽幽子是一个吃货，妖梦一走神，自己背后的刀就不见了，而西瓜也被切掉了一块。幽幽子切西瓜时刀面始终垂直于桌面，并且切下的一块在俯视图中正好是一个以西瓜中心为顶点，半径为西瓜半径的扇形。如图所示，是一种满足条件的情况\n\n俯视:\n\n ![](https://cdn.luogu.com.cn/upload/pic/5576.png) \n\n正视:\n\n ![](https://cdn.luogu.com.cn/upload/pic/5577.png) \n\n妖梦看着红红绿绿的西瓜，忽然陷入思考，红色的西瓜瓤占整个西瓜可视面积的百分之多少呢？但她对几何一窍不通，于是想问问幽幽子，但幽幽子正抱着切下来的西瓜大吃特吃，没有理会妖梦。于是她想让你来帮她解决这个问题。\n\n为了方便描述问题，我们为俯视图建立一个平面极坐标系，极点在俯视图圆形(扇形)的正中央，极轴方向竖直向下。极轴所对应的角度为0度，角度逆时针依次增加，直到转一圈又回到极轴。因此角度范围是[0,360)。幽幽子会切掉西瓜从a°到b°的这一整块。\n", "inputFormat": "第一行一个整数T，表示数据组数。\n\n接下来T行每行两个整数a,b。表示切掉范围的起始角度和终止角度。若a>b，则切掉的角度为[a,360)∪[0,b]这一范围。\n", "outputFormat": "T行，每行一个实数后跟一个百分号“%”，表示被切掉一部分的西瓜的正视图(平行投影)中，红色的西瓜瓤占西瓜总可视面积的百分比。在此题中，妖梦的视野方向平行于俯视图的极轴，并且极轴射线指向妖梦。\n\n输出的实数四舍五入保留一位小数，你的答案被判作正确，当且仅当与标准答案完全相同。\n", "hint": "样例说明:\n\n第一个样例中，切掉的西瓜恰好在背面，在妖梦的角度看起来与未切过的西瓜并无区别，因此输出0%。第二个样例中，切掉了从315°~45°这一部分,经过计算，得到答案为sqrt(2)/2，化成小数得到0.707,即70.7%\n\n本题目共有10个测试点。\n\n对于第1个测试点，a,b∈{0,90,180,270}。\n\n对于第2个测试点，270<=a<=359,0<=b<=90。\n\n对于第3,4个测试点，180<=a<=359,0<=b<=179。\n\n对于全部测试点，0<=a,b<=359,a≠b。\n\n1<=T<=10000\n\n命题人:orangebird\n", "locale": "zh-CN"}}}
{"pid": "P3789", "type": "P", "difficulty": 7, "samples": [["3 3", "11 4 2 0"], ["20 10", "1398101 4582670 8103780 10126770 9931780 8075094 5618340 3422330 1841460 893790 383524"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 5000, 5000, 5000, 5000, 5000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "递推", "洛谷原创", "O2优化", "线性递推", "级数", "快速傅里叶变换 FFT", "洛谷月赛"], "title": "Azuki loves coloring", "background": "", "description": "NEKOPARA Vol.3 发售之后，在新作中不是主角的 Azuki 终于可以休息了。为了打发时间，她开始给一个由 $n$ 个格子组成的序列涂色，每个格子可以涂黑白灰三种颜色之一。为了美观，Azuki 希望序列中没有两个黑色的格子相邻，也没有两个白色的格子相邻。这样的序列有很多，Azuki 定义每个序列的权值是其中一个黑色格子和一个白色格子相邻的情况的出现次数，如序列“灰黑白黑”的权值为 $2$。Azuki 想知道，对于满足 $0\\le i\\le k$ 的每一个 $i$，长度为 $n$ 且权值为 $i$ 的序列有多少种。由于答案很大，因此她只需要知道答案 $\\text{mod }998244353$ 的值就可以了。Azuki 答应你，如果你解决了这个问题，她就可以给你做~~美味的蛋糕吃~~。\n", "inputFormat": "一行两个正整数 $n,k$。\n", "outputFormat": "一行 $k+1$ 个正整数，分别代表权值为 $0,1,\\dots,k$ 的序列的个数 $\\text{mod }998244353$ 的值。\n", "hint": "对于 $30\\%$ 的测试点，$n,k\\le 100$。\n\n对于 $50\\%$ 的测试点，$n,k\\le 5000$，时限 $1s$。其余测试点时限 $5s$。\n\n对于 $70\\%$ 的测试点，$n,k\\le 60000$。\n\n对于 $100\\%$ 的测试点，$n\\le 10^{18},k\\le 100000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Azuki loves coloring", "background": "", "description": "After the release of NEKOPARA Vol.3, Azuki, who is not the protagonist in the new work, can finally take a break. To pass the time, she starts coloring a sequence of $n$ cells, each cell being one of three colors: black, white, or gray. For aesthetics, Azuki wants no two black cells to be adjacent and no two white cells to be adjacent. There are many such sequences. Azuki defines the weight of a sequence as the number of occurrences where a black cell and a white cell are adjacent. For example, the weight of the sequence \"gray black white black\" is $2$. Azuki wants to know, for each $i$ with $0 \\le i \\le k$, how many sequences of length $n$ have weight $i$. Since the answers can be large, she only needs the values $\\text{mod }998244353$. Azuki promises that if you solve this problem, she will make you ~~delicious cake~~.", "inputFormat": "One line with two positive integers $n, k$.", "outputFormat": "One line with $k+1$ positive integers, representing the values $\\text{mod }998244353$ of the numbers of sequences whose weights are $0, 1, \\dots, k$.", "hint": "For $30\\%$ of the testdata, $n, k \\le 100$.\n\nFor $50\\%$ of the testdata, $n, k \\le 5000$, time limit $1\\ \\text{s}$. The remaining testdata have time limit $5\\ \\text{s}$.\n\nFor $70\\%$ of the testdata, $n, k \\le 60000$.\n\nFor $100\\%$ of the testdata, $n \\le 10^{18}, k \\le 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Azuki loves coloring", "background": "", "description": "NEKOPARA Vol.3 发售之后，在新作中不是主角的 Azuki 终于可以休息了。为了打发时间，她开始给一个由 $n$ 个格子组成的序列涂色，每个格子可以涂黑白灰三种颜色之一。为了美观，Azuki 希望序列中没有两个黑色的格子相邻，也没有两个白色的格子相邻。这样的序列有很多，Azuki 定义每个序列的权值是其中一个黑色格子和一个白色格子相邻的情况的出现次数，如序列“灰黑白黑”的权值为 $2$。Azuki 想知道，对于满足 $0\\le i\\le k$ 的每一个 $i$，长度为 $n$ 且权值为 $i$ 的序列有多少种。由于答案很大，因此她只需要知道答案 $\\text{mod }998244353$ 的值就可以了。Azuki 答应你，如果你解决了这个问题，她就可以给你做~~美味的蛋糕吃~~。\n", "inputFormat": "一行两个正整数 $n,k$。\n", "outputFormat": "一行 $k+1$ 个正整数，分别代表权值为 $0,1,\\dots,k$ 的序列的个数 $\\text{mod }998244353$ 的值。\n", "hint": "对于 $30\\%$ 的测试点，$n,k\\le 100$。\n\n对于 $50\\%$ 的测试点，$n,k\\le 5000$，时限 $1s$。其余测试点时限 $5s$。\n\n对于 $70\\%$ 的测试点，$n,k\\le 60000$。\n\n对于 $100\\%$ 的测试点，$n\\le 10^{18},k\\le 100000$。\n", "locale": "zh-CN"}}}
{"pid": "P3790", "type": "P", "difficulty": 6, "samples": [["4 5  \n1 2 12  \n1 3 9  \n2 4 6  \n3 4 8  \n1 4 4  ", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创", "O2优化", "枚举", "剪枝", "生成树", "洛谷月赛"], "title": "文艺数学题", "background": "小 Y 在 AK 曼哈顿 OI，CTSC 和 APIO 之后，开始研究数学题。", "description": "小 Y 有一张 $N$ 个点，$M$ 条边的无向图（**可能有重边、自环**），每条边都有一个权值 $w$。\n\n\n你需要计算：所有**生成树的边权的最大公约数**之和，具体操作见样例。\n\n\n由于答案可能很大，需要**对 $1000000007$ 取模**。", "inputFormat": "第一行两个正整数 $N,M$，表示点数和边数。\n\n\n接下来 $M$ 行，每行三个正整数 $u,v,w$，表示一条边连接 $u$ 和 $v$，权值为 $w$。", "outputFormat": "输出一行一个数，表示答案**对 $1000000007$ 取模**的值。", "hint": "### 样例 $1$ 的解释\n\n ![](https://cdn.luogu.com.cn/upload/pic/13639.png) \n\n显然，这张图有 $8$ 个不同的生成树。\n\n\n用 $\\gcd(x,y,z)$ 表示 $x,y,z$ 的最大公约数，则答案为\n\n$\\gcd(12,6,8)+\\gcd(6,8,9)+\\gcd(8,9,12)+\\gcd(9,12,6)+\\gcd(9,4,6)+\\gcd(12,4,8)+\\gcd(12,4,9)+\\gcd(6,4,8)$\n\n$=2+1+1+3+1+4+1+2$\n\n$=15$。\n\n### 数据范围\n\n\n对于 $20\\%$ 的数据，$N\\le 10, M\\le 20$；\n\n对于另外 $10\\%$ 的数据，$N\\le 12, M\\le 24$；\n\n对于另外 $20\\%$ 的数据，$N\\le 60, M\\le 3000$，且满足$u_i+1=v_i$；\n\n对于另外 $20\\%$ 的数据，$N\\le 40, M\\le 1000, W\\le 1000$；\n\n对于另外 $15\\%$ 的数据，$N\\le 50, M\\le 2000$；\n\n对于 $100\\%$ 的数据，$N\\le 60, M\\le 3000, W\\le 1000000$。", "locale": "zh-CN", "translations": {"en": {"title": "Artistic Math Problem", "background": "After Xiao Y AK-ed Manhattan OI, CTSC, and APIO, he started studying math problems.", "description": "Xiao Y has an undirected graph with $N$ vertices and $M$ edges (**possibly with multiple edges and self-loops**), and each edge has a weight $w$.\n\nYou need to compute the sum of the greatest common divisors of the edge weights over all spanning trees; see the sample for details.\n\nSince the answer may be large, take it **modulo $1000000007$**.", "inputFormat": "The first line contains two positive integers $N, M$, denoting the number of vertices and the number of edges.\n\nThe next $M$ lines each contain three positive integers $u, v, w$, denoting an edge connecting $u$ and $v$ with weight $w$.", "outputFormat": "Output a single integer: the answer **modulo $1000000007$**.", "hint": "### Explanation of Sample $1$\n\n![](https://cdn.luogu.com.cn/upload/pic/13639.png)\n\nObviously, this graph has $8$ different spanning trees.\n\nLet $\\gcd(x,y,z)$ denote the greatest common divisor of $x, y, z$. Then the answer is\n\n$\\gcd(12,6,8)+\\gcd(6,8,9)+\\gcd(8,9,12)+\\gcd(9,12,6)+\\gcd(9,4,6)+\\gcd(12,4,8)+\\gcd(12,4,9)+\\gcd(6,4,8)$\n\n$=2+1+1+3+1+4+1+2$\n\n$=15$.\n\n### Constraints\n\nFor $20\\%$ of the testdata, $N\\le 10, M\\le 20$;\n\nFor another $10\\%$ of the testdata, $N\\le 12, M\\le 24$;\n\nFor another $20\\%$ of the testdata, $N\\le 60, M\\le 3000$, and it satisfies $u_i+1=v_i$;\n\nFor another $20\\%$ of the testdata, $N\\le 40, M\\le 1000, W\\le 1000$;\n\nFor another $15\\%$ of the testdata, $N\\le 50, M\\le 2000$;\n\nFor $100\\%$ of the testdata, $N\\le 60, M\\le 3000, W\\le 1000000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "文艺数学题", "background": "小 Y 在 AK 曼哈顿 OI，CTSC 和 APIO 之后，开始研究数学题。", "description": "小 Y 有一张 $N$ 个点，$M$ 条边的无向图（**可能有重边、自环**），每条边都有一个权值 $w$。\n\n\n你需要计算：所有**生成树的边权的最大公约数**之和，具体操作见样例。\n\n\n由于答案可能很大，需要**对 $1000000007$ 取模**。", "inputFormat": "第一行两个正整数 $N,M$，表示点数和边数。\n\n\n接下来 $M$ 行，每行三个正整数 $u,v,w$，表示一条边连接 $u$ 和 $v$，权值为 $w$。", "outputFormat": "输出一行一个数，表示答案**对 $1000000007$ 取模**的值。", "hint": "### 样例 $1$ 的解释\n\n ![](https://cdn.luogu.com.cn/upload/pic/13639.png) \n\n显然，这张图有 $8$ 个不同的生成树。\n\n\n用 $\\gcd(x,y,z)$ 表示 $x,y,z$ 的最大公约数，则答案为\n\n$\\gcd(12,6,8)+\\gcd(6,8,9)+\\gcd(8,9,12)+\\gcd(9,12,6)+\\gcd(9,4,6)+\\gcd(12,4,8)+\\gcd(12,4,9)+\\gcd(6,4,8)$\n\n$=2+1+1+3+1+4+1+2$\n\n$=15$。\n\n### 数据范围\n\n\n对于 $20\\%$ 的数据，$N\\le 10, M\\le 20$；\n\n对于另外 $10\\%$ 的数据，$N\\le 12, M\\le 24$；\n\n对于另外 $20\\%$ 的数据，$N\\le 60, M\\le 3000$，且满足$u_i+1=v_i$；\n\n对于另外 $20\\%$ 的数据，$N\\le 40, M\\le 1000, W\\le 1000$；\n\n对于另外 $15\\%$ 的数据，$N\\le 50, M\\le 2000$；\n\n对于 $100\\%$ 的数据，$N\\le 60, M\\le 3000, W\\le 1000000$。", "locale": "zh-CN"}}}
{"pid": "P3791", "type": "P", "difficulty": 7, "samples": [["0 2 233", "14"], ["123 234 345", "205761"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创", "O2优化", "枚举", "进制", "前缀和", "洛谷月赛"], "title": "普通数学题", "background": "一天 zzq 没有题可以出了。于是他随便写了一个式子，求$\\sum_{i=0}^n \\sum_{j=0}^m i \\operatorname{xor}j\\operatorname{xor}x$，其中 $\\operatorname{xor}$ 表示异或。\n\nzzy 一看，这不是水题吗，就随便加了一个函数：$\\sum_{i=0}^n \\sum_{j=0}^m d(i \\operatorname{xor}j\\operatorname{xor}x)$，其中 $\\operatorname{xor}$ 表示异或，$d(x)$ 表示 $x$ 的约数个数。**注意 $d(0)=0$。**\n\n现在 zzq 不会做了，只好写了一个暴力造了数据，然后把这道题丢给了你。\n", "description": "输入三个数 $n,m,x$，要求计算 $\\sum_{i=0}^n \\sum_{j=0}^m d(i \\operatorname{xor}j\\operatorname{xor}x)$，其中 $\\operatorname{xor}$ 表示二进制下的异或，$d(x)$ 表示 $x$ 的约数个数。\n\n由于答案比较大，要求输出答案模 $ 998244353$ 后的结果。\n", "inputFormat": "一行三个数 $n,m,x$。\n", "outputFormat": "输出答案模 $ 998244353$ 后的结果。", "hint": "对于 $20\\%$ 的数据，$n,m,x \\leq 2000$。\n\n对于 $50\\%$ 的数据，$n,m,x \\leq 10^6$。\n\n对于 $80\\%$ 的数据，$n,m,x \\leq 10^8$。\n\n对于 $100\\%$ 的数据，$1 \\leq n,m,x \\leq 10^{10}$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Ordinary Math Problem", "background": "One day, zzq had no problems to set. So he casually wrote an expression to compute $\\sum_{i=0}^n \\sum_{j=0}^m i \\operatorname{xor} j \\operatorname{xor} x$, where $\\operatorname{xor}$ denotes bitwise XOR.\n\nzzy thought this was easy, so he casually added a function: $\\sum_{i=0}^n \\sum_{j=0}^m d(i \\operatorname{xor} j \\operatorname{xor} x)$, where $\\operatorname{xor}$ denotes bitwise XOR and $d(x)$ denotes the number of divisors of $x$. **Note that $d(0) = 0$.**\n\nNow zzq could not solve it, so he wrote a brute-force generator to produce testdata and threw this problem to you.", "description": "Given three integers $n, m, x$, compute $\\sum_{i=0}^n \\sum_{j=0}^m d(i \\operatorname{xor} j \\operatorname{xor} x)$, where $\\operatorname{xor}$ denotes bitwise XOR and $d(x)$ denotes the number of divisors of $x$.\n\nSince the answer can be large, output the result modulo $998244353$.", "inputFormat": "One line with three integers $n, m, x$.", "outputFormat": "Output the answer modulo $998244353$.", "hint": "For $20\\%$ of the testdata, $n, m, x \\leq 2000$.\n\nFor $50\\%$ of the testdata, $n, m, x \\leq 10^6$.\n\nFor $80\\%$ of the testdata, $n, m, x \\leq 10^8$.\n\nFor $100\\%$ of the testdata, $1 \\leq n, m, x \\leq 10^{10}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "普通数学题", "background": "一天 zzq 没有题可以出了。于是他随便写了一个式子，求$\\sum_{i=0}^n \\sum_{j=0}^m i \\operatorname{xor}j\\operatorname{xor}x$，其中 $\\operatorname{xor}$ 表示异或。\n\nzzy 一看，这不是水题吗，就随便加了一个函数：$\\sum_{i=0}^n \\sum_{j=0}^m d(i \\operatorname{xor}j\\operatorname{xor}x)$，其中 $\\operatorname{xor}$ 表示异或，$d(x)$ 表示 $x$ 的约数个数。**注意 $d(0)=0$。**\n\n现在 zzq 不会做了，只好写了一个暴力造了数据，然后把这道题丢给了你。\n", "description": "输入三个数 $n,m,x$，要求计算 $\\sum_{i=0}^n \\sum_{j=0}^m d(i \\operatorname{xor}j\\operatorname{xor}x)$，其中 $\\operatorname{xor}$ 表示二进制下的异或，$d(x)$ 表示 $x$ 的约数个数。\n\n由于答案比较大，要求输出答案模 $ 998244353$ 后的结果。\n", "inputFormat": "一行三个数 $n,m,x$。\n", "outputFormat": "输出答案模 $ 998244353$ 后的结果。", "hint": "对于 $20\\%$ 的数据，$n,m,x \\leq 2000$。\n\n对于 $50\\%$ 的数据，$n,m,x \\leq 10^6$。\n\n对于 $80\\%$ 的数据，$n,m,x \\leq 10^8$。\n\n对于 $100\\%$ 的数据，$1 \\leq n,m,x \\leq 10^{10}$。\n", "locale": "zh-CN"}}}
{"pid": "P3792", "type": "P", "difficulty": 5, "samples": [["5 5\n1 2 3 4 5\n2 1 5\n2 2 3\n2 3 3\n1 3 4\n2 3 5", "damushen\ndamushen\ndamushen\nyuanxing"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "线段树", "平衡树", "洛谷原创", "O2优化", "哈希 hashing", "素数判断,质数,筛法", "洛谷月赛"], "title": "由乃与大母神原型和偶像崇拜", "background": ":::info[题目背景]{open}\n ![](https://cdn.luogu.com.cn/upload/pic/5702.png) \n\n由乃最近没事干，去研究轻拍学去了\n\n就是一个叫做flip flappers，轻拍翻转小膜女的番\n\n ![](https://cdn.luogu.com.cn/upload/pic/5703.png) \n\n然后研究的过程中她看到了一个叫做大母神原型的东西\n\n大母神不仅是部落保护神，而且是部落间互相识别的标记（以后泛化为不同的图形符号、服饰和祭祀仪式），在部落联盟出现后，具有领导力的部落神祇，上升为整个联盟的共神，进而成为酋邦和王国的共神\n\n ![](https://cdn.luogu.com.cn/upload/pic/5709.png) \n\n大概就是说这个东西是母系社会时候的偶像，然后象征着母亲可以创造生命也可以毁灭生命什么什么的，分别是善母与恶母，既孕育一切，又吞噬一切\n\n然后我们熟知的神话里面就有大母神，比如女娲其实就是个大母神。。。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5716.png) \n\n原始部落时期的大母神既具有生育和哺乳的能力，也具有保护部落、带来丰收的神力。\n\n到了神话时期，大母神进一步分化，演变出形形色色的女神，分别象征了女性能量的不同面向：孕育女神、大地女神、爱与美女神、保护女神、战争女神、丰收女神、智慧女神、命运女神……\n\n这些是善母\n\n ![](https://cdn.luogu.com.cn/upload/pic/5717.png) \n\n世间的事物总是两面性的：一切生命诞生于土地，最终要回归土地；创造的必然也拥有毁灭的能力。大母神也同样具有痛苦、恐怖、吞噬和危险的一面。\n\n比如童话故事里面的女巫，其实就是大母神的另一面的体现，也就是恶母\n\n糖果屋的故事讲的就是韩赛尔和格雷特被继母赶出家里，因为没饭吃了，然后进了森林发现了一个糖果屋，里面有个女巫，专门吃小孩子\n\n然而如果我们仔细想想这个故事，会发现它没有那么简单\n\n比如说，女巫真的是吃小孩子吗？如果女巫是个善良的老婆婆，无偿救助在森林里面困住的小孩子呢？\n\n还有就是当韩赛尔和格雷特杀死了女巫，回到家中发现她们的继母也死了\n\n这是否意味着她们实际上杀死的是她们的继母？\n\n所以这个故事本质上讲的是她们杀了她们的母亲，也就是打败了大母神\n\n很多神话故事里面都有打败大母神的情节\n:::", "description": ":::info[无关内容]{open}\n\n ![](https://cdn.luogu.com.cn/upload/pic/5706.png) \n\n你看到这里也许已经觉得由乃精神不正常了\n\n然而由乃自从不小心##了自己的##后早就不正常了\n\n由乃研究了很久大母神原型，但是仍然一脸懵逼\n\n于是就出数据结构题骗钱去了\n\n由乃：给你一个序列，每次询问一个区间是否是值域连续段\n\nzzy：你把题意说详细点\n\n由乃：就是说不能有重复数字，比如1 2 2 3就不行，然后4 2 3 1就可以\n\nyql：sb分块\n\nddd：sb bitset\n\n由乃：woc你们好树链啊，我。。我带修\n\nzzq：#######sb题\n\n由乃：我就是要出原题\n\n ![](https://cdn.luogu.com.cn/upload/pic/5710.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/5705.png)\n\n:::\n给你一个长为 $n$ 的序列 $a$。\n\n每次操作分为两种：\n\n1. 修改 $x$ 位置的值为 $y$。\n2. 查询区间 $[l,r]$ 是否可以重排为值域上连续的一段。", "inputFormat": "第一行两个数 $n,m$。\n\n第二行 $n$ 个数表示 $a_i$。\n\n后面 $m$ 行每行三个数 $opt,x,y$，或者 $opt,l,r$，代表操作。", "outputFormat": "如果可以，输出 `damushen`，否则输出 `yuanxing`。", "hint": "对于 $30\\%$ 的数据，$n,m \\le 500$。\n\n对于 $60\\%$ 的数据，$n,m \\le 10^5$。\n\n对于 $100\\%$ 的数据，$n,m \\le 5\\times 10^5$。\n\n初始值的值域小于 $2.5\\times 10^7$，修改操作的 $y$ 小于等于 $n$。保证在任意时刻所有 $a_i$ 均为正整数。\n\n2s", "locale": "zh-CN", "translations": {"en": {"title": "Yuno, the Great Mother Archetype, and Idolatry", "background": "![](https://cdn.luogu.com.cn/upload/pic/5702.png)\n\nYuno recently had nothing to do and went to study \"light patting\" studies.\n\nIt is an anime called Flip Flappers.\n\n![](https://cdn.luogu.com.cn/upload/pic/5703.png)\n\nDuring her research, she came across something called the Great Mother archetype.\n\nThe Great Mother is not only the tribal protector deity but also a mark for mutual recognition between tribes (later generalized into various graphic symbols, attire, and ritual practices). After tribal alliances emerged, the deity of a tribe with leadership rose to become the common deity of the entire alliance, and then the common deity of chiefdoms and kingdoms.\n\n![](https://cdn.luogu.com.cn/upload/pic/5709.png)\n\nBasically, it says this figure is an idol from matriarchal society, symbolizing that the mother can create life and also destroy life, embodied as the Good Mother and the Terrible Mother—she nurtures all and also devours all.\n\nIn myths we are familiar with, there are Great Mother figures; for example, Nüwa is essentially a Great Mother.\n\n![](https://cdn.luogu.com.cn/upload/pic/5716.png)\n\nIn the era of primitive tribes, the Great Mother not only had the ability to give birth and nurse but also possessed divine power to protect the tribe and bring abundant harvests.\n\nBy the mythic age, the Great Mother further differentiated into a variety of goddesses, each symbolizing different aspects of feminine energy: goddess of birth, earth goddess, goddess of love and beauty, protective goddess, war goddess, harvest goddess, wisdom goddess, goddess of fate, and so on.\n\nThese are the Good Mother aspects.\n\n![](https://cdn.luogu.com.cn/upload/pic/5717.png)\n\nThings in the world are always dual: all life is born from the earth and ultimately returns to the earth; what creates also inherently has the power to destroy. The Great Mother likewise has a side of pain, terror, devouring, and danger.\n\nFor example, the witch in fairy tales is actually an embodiment of the other side of the Great Mother, namely the Terrible Mother.\n\nThe story of the gingerbread house tells of Hansel and Gretel being driven from home by their stepmother because there was no food, then entering the forest and finding a gingerbread house with a witch inside who eats children.\n\nHowever, if we think carefully about this story, we will find it is not so simple.\n\nFor instance, does the witch really eat children? What if the witch is a kind old woman who freely rescues children trapped in the forest?\n\nAnd when Hansel and Gretel kill the witch and return home, they find that their stepmother has also died.\n\nDoes that imply they actually killed their stepmother?\n\nSo the essence of this story is that they killed their mother—defeating the Great Mother.\n\nMany myths include episodes of defeating the Great Mother.", "description": "![](https://cdn.luogu.com.cn/upload/pic/5706.png)\n\nYou may already think Yuno is not mentally normal by this point.\n\nHowever, Yuno has not been normal ever since she accidentally ## her own ##.\n\nYuno studied the Great Mother archetype for a long time but is still completely confused.\n\nSo she went off to make a data structure problem to farm points.\n\nYuno: I give you a sequence; each query asks whether a subarray is a contiguous segment on the value range.\n\nzzy: Explain the problem statement in more detail.\n\nYuno: It means there cannot be duplicate numbers. For example, 1 2 2 3 is not okay, but 4 2 3 1 is okay.\n\nyql: sb block decomposition.\n\nddd: sb bitset.\n\nYuno: Wow, you all love tree chains. I... I’ll support modifications.\n\nzzq: ####### sb problem.\n\nYuno: I’m going to publish the original problem as is.\n\n![](https://cdn.luogu.com.cn/upload/pic/5710.png)\n\nYou are given a sequence $a$ of length $n$.\n\nThere are two types of operations:\n\n1. Update the value at position $x$ to $y$.\n2. Query whether the subarray $[l, r]$ can be rearranged into a consecutive range of values.\n\n![](https://cdn.luogu.com.cn/upload/pic/5705.png)", "inputFormat": "The first line contains two integers $n$ and $m$.\n\nThe second line contains $n$ integers representing $a_i$.\n\nEach of the next $m$ lines contains three integers: either $opt$ $x$ $y$, or $opt$ $l$ $r$, representing an operation.", "outputFormat": "If it is possible, output \"damushen\".\n\nOtherwise, output \"yuanxing\".", "hint": "- For $30\\%$ of the testdata, $n, m \\le 500$.\n- For $60\\%$ of the testdata, $n, m \\le 100000$.\n- For $100\\%$ of the testdata, $n, m \\le 500000$.\n\nThe initial values have value range less than $2.5 \\times 10^7$. In update operations, $y \\le n$. At any time, all $a_i$ are guaranteed to be positive integers.\n\nTime limit: 2 s.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "由乃与大母神原型和偶像崇拜", "background": ":::info[题目背景]{open}\n ![](https://cdn.luogu.com.cn/upload/pic/5702.png) \n\n由乃最近没事干，去研究轻拍学去了\n\n就是一个叫做flip flappers，轻拍翻转小膜女的番\n\n ![](https://cdn.luogu.com.cn/upload/pic/5703.png) \n\n然后研究的过程中她看到了一个叫做大母神原型的东西\n\n大母神不仅是部落保护神，而且是部落间互相识别的标记（以后泛化为不同的图形符号、服饰和祭祀仪式），在部落联盟出现后，具有领导力的部落神祇，上升为整个联盟的共神，进而成为酋邦和王国的共神\n\n ![](https://cdn.luogu.com.cn/upload/pic/5709.png) \n\n大概就是说这个东西是母系社会时候的偶像，然后象征着母亲可以创造生命也可以毁灭生命什么什么的，分别是善母与恶母，既孕育一切，又吞噬一切\n\n然后我们熟知的神话里面就有大母神，比如女娲其实就是个大母神。。。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5716.png) \n\n原始部落时期的大母神既具有生育和哺乳的能力，也具有保护部落、带来丰收的神力。\n\n到了神话时期，大母神进一步分化，演变出形形色色的女神，分别象征了女性能量的不同面向：孕育女神、大地女神、爱与美女神、保护女神、战争女神、丰收女神、智慧女神、命运女神……\n\n这些是善母\n\n ![](https://cdn.luogu.com.cn/upload/pic/5717.png) \n\n世间的事物总是两面性的：一切生命诞生于土地，最终要回归土地；创造的必然也拥有毁灭的能力。大母神也同样具有痛苦、恐怖、吞噬和危险的一面。\n\n比如童话故事里面的女巫，其实就是大母神的另一面的体现，也就是恶母\n\n糖果屋的故事讲的就是韩赛尔和格雷特被继母赶出家里，因为没饭吃了，然后进了森林发现了一个糖果屋，里面有个女巫，专门吃小孩子\n\n然而如果我们仔细想想这个故事，会发现它没有那么简单\n\n比如说，女巫真的是吃小孩子吗？如果女巫是个善良的老婆婆，无偿救助在森林里面困住的小孩子呢？\n\n还有就是当韩赛尔和格雷特杀死了女巫，回到家中发现她们的继母也死了\n\n这是否意味着她们实际上杀死的是她们的继母？\n\n所以这个故事本质上讲的是她们杀了她们的母亲，也就是打败了大母神\n\n很多神话故事里面都有打败大母神的情节\n:::", "description": ":::info[无关内容]{open}\n\n ![](https://cdn.luogu.com.cn/upload/pic/5706.png) \n\n你看到这里也许已经觉得由乃精神不正常了\n\n然而由乃自从不小心##了自己的##后早就不正常了\n\n由乃研究了很久大母神原型，但是仍然一脸懵逼\n\n于是就出数据结构题骗钱去了\n\n由乃：给你一个序列，每次询问一个区间是否是值域连续段\n\nzzy：你把题意说详细点\n\n由乃：就是说不能有重复数字，比如1 2 2 3就不行，然后4 2 3 1就可以\n\nyql：sb分块\n\nddd：sb bitset\n\n由乃：woc你们好树链啊，我。。我带修\n\nzzq：#######sb题\n\n由乃：我就是要出原题\n\n ![](https://cdn.luogu.com.cn/upload/pic/5710.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/5705.png)\n\n:::\n给你一个长为 $n$ 的序列 $a$。\n\n每次操作分为两种：\n\n1. 修改 $x$ 位置的值为 $y$。\n2. 查询区间 $[l,r]$ 是否可以重排为值域上连续的一段。", "inputFormat": "第一行两个数 $n,m$。\n\n第二行 $n$ 个数表示 $a_i$。\n\n后面 $m$ 行每行三个数 $opt,x,y$，或者 $opt,l,r$，代表操作。", "outputFormat": "如果可以，输出 `damushen`，否则输出 `yuanxing`。", "hint": "对于 $30\\%$ 的数据，$n,m \\le 500$。\n\n对于 $60\\%$ 的数据，$n,m \\le 10^5$。\n\n对于 $100\\%$ 的数据，$n,m \\le 5\\times 10^5$。\n\n初始值的值域小于 $2.5\\times 10^7$，修改操作的 $y$ 小于等于 $n$。保证在任意时刻所有 $a_i$ 均为正整数。\n\n2s", "locale": "zh-CN"}}}
{"pid": "P3793", "type": "P", "difficulty": 5, "samples": [["233 233 233", "243704637294"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["洛谷原创", "O2优化", "栈", "分块", "ST 表", "洛谷月赛", "笛卡尔树"], "title": "由乃救爷爷", "background": "大家看过葫芦娃吧？\n\n没看过也没关系，让由乃告诉你吧\n\n ![](https://cdn.luogu.com.cn/upload/pic/5725.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/5740.png) \n\n传说明斯克航空航天局里关着两个坦克，strv103b和krv。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5733.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/5722.png) \n\n鼠爷不小心打破了明斯克航空航天局，两个坦克逃了出来，从此其他坦克过上了水深火热的生活。\n\n明斯克航空航天局急忙去告诉一个叫做serb的光头，只有YY出七辆图纸车，才能消灭这两个卖头势力。\n\nserbYY出了七个连图纸都没有的车，却被瑞典人从bbs中窥见 。他们摧毁不了这七个YY车，\n\n就把serb和鼠爷抓去。但是这时候七个坦克模型已经建出来了。\n\n她们分别是 T28原型，T100lt，907工程，蟋蟀15，WZ111，FV215b183，FV215b\n\n她们为了消灭卖头势力，救出serb和鼠爷，一个接一个去与卖头势力搏斗。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5723.png) \n\nT28原是正面很硬的TD，但装甲在金币弹面前一点用都没有，直接被krv卖头打死。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5728.png) \n\nT100lt是隐蔽超好的眼车，却因为没有视野，被103b活活黑死。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5724.png) \n\n907工程是铁头，被krv顶牛直接抽包抽死。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5727.png) \n\n蟋蟀15会黑枪，却因为辣鸡的转向被krv绕死。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5729.png) \n\nWZ111有三百穿，被103b穿侧面一发爆了弹药架。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5730.png) \n\nFV215b183有183炮，103b和krv瑟瑟发抖，不敢打她，于是她解救了其他所有坦克。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5734.png) \n\n但是自己的兄弟FV215b因为瑞典人的诱惑，决定叛变（因为183OO大），TK了183一发，然后183着火烧死了，结果所有坦克都被103b和krv降服了。\n\n瑞典人把七个坦克还有鼠爷一起给serb，让serb做出两辆最强坦克加入瑞典阵营。serb用尽了他所有的脑洞，做出了两辆车E100WT和T-50-2\n\n ![](https://cdn.luogu.com.cn/upload/pic/5731.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/5732.png) \n\nkrv和103b看到之后蛤蛤大笑\n\nkrv：E100WT，10mm的脸，不被HE糊死才怪\n\n103b：E100WT，灯塔般的隐蔽，不被黑死才怪\n\nkrv：T-50-2，这血量，我一炮就可以打死\n\n103b：T-50-2，看是你机动好还是我黑枪准\n\nserb：百运，胶水，让她们看看你们的厉害", "description": "故事还没讲完\n\nkrv骑坡卖头，却发现百运凭借优秀的精度炮炮打穿她的观察孔\n\nkrv慌了，跑去城市里面伸缩，被百运站桩撸死\n\nstrv103b跑去草后黑枪，看见胶水在肉侦，却发现自己根本打不中她，然后就被胶水点亮了，百运一梭子128的ARCR飞了过来\n\nstrv103b怂了，准备跑路了，但是还没等到自己切换回行走模式，胶水已经开始断她的腿了，被胶水断死\n\n\n瑞典车们高呼不可战胜，从此不敢嚣张了\n\n\n然后serb把百运和胶水加入了WOT\n\n从此\n其他坦克过上了更加水深火热的生活\n\n\n然而你又不玩WOT，这事情不管你什么事啊\n\n然而yql是大家的妹妹，所以这件事很重要：\n\n\nyql在AK曼哈顿OI，CTSC，APIO之后，开始研究数学题。\n\n由乃在挂了字符串OI，CTSC，APIO之后，开始研究大母神原型。\n\nyql出了个数学题，由乃画出了一个表示大母神的图腾。\n\n然后把这两个合成了一个题：\n\n\n然而由于未知原因那个题挂掉了。。。\n\n由乃想起来SCOI 2017 电子科技大学出了个卡常的rmq，然后发生了一件很有趣的事情\n\n就是一位姓王的同学凭借奇奇怪怪的常数优化怒草了那个题，还比标程块了233倍\n\n所以由乃也出了个卡常rmq，因为没题出了", "inputFormat": "给你一个随机数生成器\n\n```cpp\nnamespace GenHelper\n{\n    unsigned z1,z2,z3,z4,b;\n    unsigned rand_()\n    {\n    b=((z1<<6)^z1)>>13;\n    z1=((z1&4294967294U)<<18)^b;\n    b=((z2<<2)^z2)>>27;\n    z2=((z2&4294967288U)<<2)^b;\n    b=((z3<<13)^z3)>>21;\n    z3=((z3&4294967280U)<<7)^b;\n    b=((z4<<3)^z4)>>12;\n    z4=((z4&4294967168U)<<13)^b;\n    return (z1^z2^z3^z4);\n    }\n}\nvoid srand(unsigned x)\n{using namespace GenHelper;\nz1=x; z2=(~x)^0x233333333U; z3=x^0x1234598766U; z4=(~x)+51;}\nint read()\n{\n    using namespace GenHelper;\n    int a=rand_()&32767;\n    int b=rand_()&32767;\n    return a*32768+b;\n}\n```\n\n读入三个数 $n,m,s$\n\n你需要 `srand(s)` 一下\n\n然后 $n$ 个数表示 $a_i$，这个直接调用 `read` 函数\n\n然后 $m$ 个询问，表示区间**最大值**，询问的区间是 $l = \\text{read()} \\bmod n + 1 , r = \\text{read()} \\bmod n + 1$，注意有可能 $l > r$", "outputFormat": "输出一个 `unsigned long long` 表示每次询问的答案的和", "hint": "| 测试点编号 | $n,m =$ | 时限 |\n|:-:|:-:|:-:|\n| $1 \\sim 2$ | $1000$ | 1s |\n| $3$ | $10^5$ | 1s |\n| $4$ | $5\\times10^5$ | 1s |\n| $5$ | $10^6$ | 1s |\n| $6$ | $10^7$ | 5s |\n| $7$ | $1.2 \\times 10^7$ | 5s |\n| $8$ | $1.5 \\times 10^7$ | 5s |\n| $9$ | $2 \\times 10^7$ | 5s |", "locale": "zh-CN", "translations": {"en": {"title": "Yuno Saves Grandpa", "background": "Has everyone watched Calabash Brothers?\n\nEven if you haven't, let Yuno tell you.\n\n ![](https://cdn.luogu.com.cn/upload/pic/5725.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/5740.png) \n\nLegend says the Minsk Aviation and Space Administration held two tanks in custody, strv103b and krv.\n\n ![](https://cdn.luogu.com.cn/upload/pic/5733.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/5722.png) \n\nMouse-ye accidentally broke the Minsk Aviation and Space Administration, and the two tanks escaped. From then on, other tanks lived in deep misery.\n\nThe Minsk Aviation and Space Administration hurried to tell a bald man named SerB that only by releasing seven \"YY\" blueprinted tanks could they eliminate these two hull-down forces.\n\nSerB \"YY\"-ed seven tanks without even blueprints, but they were peeped by the Swedes on the BBS. Unable to destroy these seven \"YY\" tanks, they captured SerB and Mouse-ye. However, by then the seven tank models had already been built.\n\nThey were T28 Prototype, T-100LT, Object 907, Grille 15, WZ-111, FV215b 183, and FV215b.\n\nTo eliminate the hull-down forces and rescue SerB and Mouse-ye, they fought the hull-down forces one by one.\n\n ![](https://cdn.luogu.com.cn/upload/pic/5723.png) \n\nThe T28 Prototype has very tough frontal armor as a TD, but armor is useless against premium shells and was directly head-shot to death by krv in hull-down.\n\n ![](https://cdn.luogu.com.cn/upload/pic/5728.png) \n\nThe T-100LT is an excellent stealth scout, but without view range, it was perma-sniped to death by 103b.\n\n ![](https://cdn.luogu.com.cn/upload/pic/5724.png) \n\nObject 907 has an iron head, but got into a face-off with krv and was clipped to death.\n\n ![](https://cdn.luogu.com.cn/upload/pic/5727.png) \n\nThe Grille 15 can snipe, but due to terrible traverse, it was circle-strafed to death by krv.\n\n ![](https://cdn.luogu.com.cn/upload/pic/5729.png) \n\nThe WZ-111 has 300 mm pen, but 103b penned its side once and ammo-racked it.\n\n ![](https://cdn.luogu.com.cn/upload/pic/5730.png) \n\nThe FV215b 183 has a 183 mm gun; 103b and krv trembled and dared not shoot her, so she rescued all the other tanks.\n\n ![](https://cdn.luogu.com.cn/upload/pic/5734.png) \n\nHowever, her brother FV215b, tempted by the Swedes, decided to defect (because the 183 has \"OO\" big), TKed the 183 with one shot, and the 183 caught fire and burned to death. As a result, all tanks were subdued by 103b and krv.\n\nThe Swedes handed the seven tanks plus Mouse-ye to SerB, asking SerB to make the two strongest tanks to join the Swedish camp. SerB used all his wild ideas and made two tanks, E100WT and T-50-2.\n\n ![](https://cdn.luogu.com.cn/upload/pic/5731.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/5732.png) \n\nkrv and 103b burst into loud laughter upon seeing them.\n\nkrv: E100WT, a 10 mm face; how can it not get smashed by HE?\n\n103b: E100WT, lighthouse-like camouflage; how can it not get bush-sniped?\n\nkrv: T-50-2, with that HP, I can one-shot it.\n\n103b: T-50-2, let's see if you're more mobile or my sniping is more accurate.\n\nSerB: Baiyun, Jiaoshui, show them what you can do.", "description": "The story isn't over yet.\n\nkrv went hull-down on a slope, only to find Baiyun (pinyin) penetrating her cupola shot after shot thanks to great accuracy.\n\nkrv panicked, ran into the city to peek-a-boo, and got mowed down by Baiyun trading shots stationary.\n\nstrv103b went to bush-camp, saw Jiaoshui (pinyin) doing active scouting, but found she simply couldn't hit her; then Jiaoshui lit her up, and Baiyun sent over a burst of 128 ARCR.\n\nstrv103b chickened out and tried to run, but before switching back to travel mode, Jiaoshui had already started tracking her, and she got permatracked to death by Jiaoshui.\n\nThe Swedish tanks shouted that they were invincible, and from then on did not dare to be arrogant.\n\nThen SerB added Baiyun and Jiaoshui to WOT.\n\nFrom then on, other tanks lived an even more miserable life.\n\nBut you don't play WOT—what does this have to do with you?\n\nHowever, yql is everyone's little sister, so this is important:\n\nAfter AK (full score) in Manhattan OI, CTSC, and APIO, yql started studying math problems.\n\nAfter failing string problems in OI, CTSC, and APIO, Yuno started researching the \"Great Mother Goddess\" prototype.\n\nyql made a math problem, and Yuno drew a totem representing the Great Mother Goddess.\n\nThen they combined these into one problem:\n\nBut for unknown reasons that problem failed...\n\nYuno remembered that in SCOI 2017 University of Electronic Science and Technology of China put out a constant-factor-tuned RMQ, and something interesting happened:\n\nA student surnamed Wang, relying on strange constant optimizations, demolished that problem and was 233 times faster than the official solution.\n\nSo Yuno also made a constant-factor-tuned RMQ, because there were no problems left to make.", "inputFormat": "You are given a random number generator:\n\n```cpp\nnamespace GenHelper\n{\n    unsigned z1,z2,z3,z4,b;\n    unsigned rand_()\n    {\n    b=((z1<<6)^z1)>>13;\n    z1=((z1&4294967294U)<<18)^b;\n    b=((z2<<2)^z2)>>27;\n    z2=((z2&4294967288U)<<2)^b;\n    b=((z3<<13)^z3)>>21;\n    z3=((z3&4294967280U)<<7)^b;\n    b=((z4<<3)^z4)>>12;\n    z4=((z4&4294967168U)<<13)^b;\n    return (z1^z2^z3^z4);\n    }\n}\nvoid srand(unsigned x)\n{using namespace GenHelper;\nz1=x; z2=(~x)^0x233333333U; z3=x^0x1234598766U; z4=(~x)+51;}\nint read()\n{\n    using namespace GenHelper;\n    int a=rand_()&32767;\n    int b=rand_()&32767;\n    return a*32768+b;\n}\n```\n\nRead three numbers $n, m, s$.\n\nYou need to call `srand(s)`.\n\nThen there are $n$ numbers representing $a_i$, generated by directly calling the `read` function.\n\nThen there are $m$ queries asking for the range maximum. The query interval is $l = \\text{read()} \\bmod n + 1 , r = \\text{read()} \\bmod n + 1$. Note that it is possible that $l > r$.", "outputFormat": "Output a single `unsigned long long` representing the sum of the answers to all queries.", "hint": "| Test point ID | $n, m =$ | Time limit |\n|:-:|:-:|:-:|\n| $1 \\sim 2$ | $1000$ | 1 s |\n| $3$ | $10^5$ | 1 s |\n| $4$ | $5\\times10^5$ | 1 s |\n| $5$ | $10^6$ | 1 s |\n| $6$ | $10^7$ | 5 s |\n| $7$ | $1.2 \\times 10^7$ | 5 s |\n| $8$ | $1.5 \\times 10^7$ | 5 s |\n| $9$ | $2 \\times 10^7$ | 5 s |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "由乃救爷爷", "background": "大家看过葫芦娃吧？\n\n没看过也没关系，让由乃告诉你吧\n\n ![](https://cdn.luogu.com.cn/upload/pic/5725.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/5740.png) \n\n传说明斯克航空航天局里关着两个坦克，strv103b和krv。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5733.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/5722.png) \n\n鼠爷不小心打破了明斯克航空航天局，两个坦克逃了出来，从此其他坦克过上了水深火热的生活。\n\n明斯克航空航天局急忙去告诉一个叫做serb的光头，只有YY出七辆图纸车，才能消灭这两个卖头势力。\n\nserbYY出了七个连图纸都没有的车，却被瑞典人从bbs中窥见 。他们摧毁不了这七个YY车，\n\n就把serb和鼠爷抓去。但是这时候七个坦克模型已经建出来了。\n\n她们分别是 T28原型，T100lt，907工程，蟋蟀15，WZ111，FV215b183，FV215b\n\n她们为了消灭卖头势力，救出serb和鼠爷，一个接一个去与卖头势力搏斗。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5723.png) \n\nT28原是正面很硬的TD，但装甲在金币弹面前一点用都没有，直接被krv卖头打死。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5728.png) \n\nT100lt是隐蔽超好的眼车，却因为没有视野，被103b活活黑死。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5724.png) \n\n907工程是铁头，被krv顶牛直接抽包抽死。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5727.png) \n\n蟋蟀15会黑枪，却因为辣鸡的转向被krv绕死。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5729.png) \n\nWZ111有三百穿，被103b穿侧面一发爆了弹药架。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5730.png) \n\nFV215b183有183炮，103b和krv瑟瑟发抖，不敢打她，于是她解救了其他所有坦克。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5734.png) \n\n但是自己的兄弟FV215b因为瑞典人的诱惑，决定叛变（因为183OO大），TK了183一发，然后183着火烧死了，结果所有坦克都被103b和krv降服了。\n\n瑞典人把七个坦克还有鼠爷一起给serb，让serb做出两辆最强坦克加入瑞典阵营。serb用尽了他所有的脑洞，做出了两辆车E100WT和T-50-2\n\n ![](https://cdn.luogu.com.cn/upload/pic/5731.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/5732.png) \n\nkrv和103b看到之后蛤蛤大笑\n\nkrv：E100WT，10mm的脸，不被HE糊死才怪\n\n103b：E100WT，灯塔般的隐蔽，不被黑死才怪\n\nkrv：T-50-2，这血量，我一炮就可以打死\n\n103b：T-50-2，看是你机动好还是我黑枪准\n\nserb：百运，胶水，让她们看看你们的厉害", "description": "故事还没讲完\n\nkrv骑坡卖头，却发现百运凭借优秀的精度炮炮打穿她的观察孔\n\nkrv慌了，跑去城市里面伸缩，被百运站桩撸死\n\nstrv103b跑去草后黑枪，看见胶水在肉侦，却发现自己根本打不中她，然后就被胶水点亮了，百运一梭子128的ARCR飞了过来\n\nstrv103b怂了，准备跑路了，但是还没等到自己切换回行走模式，胶水已经开始断她的腿了，被胶水断死\n\n\n瑞典车们高呼不可战胜，从此不敢嚣张了\n\n\n然后serb把百运和胶水加入了WOT\n\n从此\n其他坦克过上了更加水深火热的生活\n\n\n然而你又不玩WOT，这事情不管你什么事啊\n\n然而yql是大家的妹妹，所以这件事很重要：\n\n\nyql在AK曼哈顿OI，CTSC，APIO之后，开始研究数学题。\n\n由乃在挂了字符串OI，CTSC，APIO之后，开始研究大母神原型。\n\nyql出了个数学题，由乃画出了一个表示大母神的图腾。\n\n然后把这两个合成了一个题：\n\n\n然而由于未知原因那个题挂掉了。。。\n\n由乃想起来SCOI 2017 电子科技大学出了个卡常的rmq，然后发生了一件很有趣的事情\n\n就是一位姓王的同学凭借奇奇怪怪的常数优化怒草了那个题，还比标程块了233倍\n\n所以由乃也出了个卡常rmq，因为没题出了", "inputFormat": "给你一个随机数生成器\n\n```cpp\nnamespace GenHelper\n{\n    unsigned z1,z2,z3,z4,b;\n    unsigned rand_()\n    {\n    b=((z1<<6)^z1)>>13;\n    z1=((z1&4294967294U)<<18)^b;\n    b=((z2<<2)^z2)>>27;\n    z2=((z2&4294967288U)<<2)^b;\n    b=((z3<<13)^z3)>>21;\n    z3=((z3&4294967280U)<<7)^b;\n    b=((z4<<3)^z4)>>12;\n    z4=((z4&4294967168U)<<13)^b;\n    return (z1^z2^z3^z4);\n    }\n}\nvoid srand(unsigned x)\n{using namespace GenHelper;\nz1=x; z2=(~x)^0x233333333U; z3=x^0x1234598766U; z4=(~x)+51;}\nint read()\n{\n    using namespace GenHelper;\n    int a=rand_()&32767;\n    int b=rand_()&32767;\n    return a*32768+b;\n}\n```\n\n读入三个数 $n,m,s$\n\n你需要 `srand(s)` 一下\n\n然后 $n$ 个数表示 $a_i$，这个直接调用 `read` 函数\n\n然后 $m$ 个询问，表示区间**最大值**，询问的区间是 $l = \\text{read()} \\bmod n + 1 , r = \\text{read()} \\bmod n + 1$，注意有可能 $l > r$", "outputFormat": "输出一个 `unsigned long long` 表示每次询问的答案的和", "hint": "| 测试点编号 | $n,m =$ | 时限 |\n|:-:|:-:|:-:|\n| $1 \\sim 2$ | $1000$ | 1s |\n| $3$ | $10^5$ | 1s |\n| $4$ | $5\\times10^5$ | 1s |\n| $5$ | $10^6$ | 1s |\n| $6$ | $10^7$ | 5s |\n| $7$ | $1.2 \\times 10^7$ | 5s |\n| $8$ | $1.5 \\times 10^7$ | 5s |\n| $9$ | $2 \\times 10^7$ | 5s |", "locale": "zh-CN"}}}
{"pid": "P3794", "type": "P", "difficulty": 5, "samples": [["5 6\n2 4 3 4 2", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "洛谷原创", "O2优化", "枚举", "进制", "ST 表", "洛谷月赛"], "title": "签到题IV", "background": "这场月赛好像其他题背景都很长，这题就不写背景了。![](https://cdn.luogu.com.cn/upload/pic/1436.png)", "description": "给定一个长度为 $n$ 的序列 $[a_1,a_2\\cdots a_n]$，其中每个数都是正整数。\n\n\n你需要找出有多少对 $(i,j)$，$1 \\leq i \\leq j \\leq n$ 且 $\\gcd(a_i,a_{i+1}...a_j) \\operatorname{xor} (a_i \\operatorname{or} a_{i+1} \\operatorname{or} \\cdots \\operatorname{or} a_j)=k$，其中 $\\operatorname{xor}$ 表示二进制异或，$\\operatorname{or}$ 表示二进制或。", "inputFormat": "第一行两个整数 $n,k$。\n\n第二行 $n$ 个整数 $a_1,a_2\\cdots a_n$。", "outputFormat": "输出合法的 $(i,j)$ 的对数。", "hint": "- 对于 $30\\%$ 的数据，$n \\leq 500$。\n- 对于 $60\\%$ 的数据，$n \\leq 100000$。\n- 对于 $100\\%$ 的数据，$1 \\leq n,a_i \\leq 500000$。", "locale": "zh-CN", "translations": {"en": {"title": "Check-in Problem IV", "background": "It seems the other problems in this monthly contest have long backgrounds, so this one will skip the background. ![](https://cdn.luogu.com.cn/upload/pic/1436.png)", "description": "Given a sequence of length $n$, $[a_1, a_2, \\ldots, a_n]$, where each number is a positive integer.\n\nYou need to find how many pairs $(i, j)$ satisfy $1 \\le i \\le j \\le n$ and $\\gcd(a_i, a_{i+1}, \\ldots, a_j) \\operatorname{xor} (a_i \\operatorname{or} a_{i+1} \\operatorname{or} \\cdots \\operatorname{or} a_j) = k$, where $\\operatorname{xor}$ denotes bitwise XOR and $\\operatorname{or}$ denotes bitwise OR.", "inputFormat": "The first line contains two integers $n$ and $k$.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$.", "outputFormat": "Output the number of valid pairs $(i, j)$.", "hint": "- For $30\\%$ of the testdata, $n \\le 500$.\n- For $60\\%$ of the testdata, $n \\le 100000$.\n- For $100\\%$ of the testdata, $1 \\le n, a_i \\le 500000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "签到题IV", "background": "这场月赛好像其他题背景都很长，这题就不写背景了。![](https://cdn.luogu.com.cn/upload/pic/1436.png)", "description": "给定一个长度为 $n$ 的序列 $[a_1,a_2\\cdots a_n]$，其中每个数都是正整数。\n\n\n你需要找出有多少对 $(i,j)$，$1 \\leq i \\leq j \\leq n$ 且 $\\gcd(a_i,a_{i+1}...a_j) \\operatorname{xor} (a_i \\operatorname{or} a_{i+1} \\operatorname{or} \\cdots \\operatorname{or} a_j)=k$，其中 $\\operatorname{xor}$ 表示二进制异或，$\\operatorname{or}$ 表示二进制或。", "inputFormat": "第一行两个整数 $n,k$。\n\n第二行 $n$ 个整数 $a_1,a_2\\cdots a_n$。", "outputFormat": "输出合法的 $(i,j)$ 的对数。", "hint": "- 对于 $30\\%$ 的数据，$n \\leq 500$。\n- 对于 $60\\%$ 的数据，$n \\leq 100000$。\n- 对于 $100\\%$ 的数据，$1 \\leq n,a_i \\leq 500000$。", "locale": "zh-CN"}}}
{"pid": "P3795", "type": "P", "difficulty": 3, "samples": [["3\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [20480, 20480, 20480, 20480, 20480, 20480, 20480, 20480, 20480, 20480]}, "tags": ["动态规划 DP", "搜索", "数学", "递推"], "title": "钟氏映射", "background": "2233年，CSSYZ学校的数学老师兼数学竞赛顾问钟JG已经2200+岁啦！\n\n为了庆生，他或她给广大人民群众出了道题。\n", "description": "设集合$N=M=\\left\\{x|x\\in N_+,x\\leq k,k\\in N_+\\right\\}$\n\n设$f$为$N$到$M$的映射。\n\n求满足：\n\n$f[f(x)]=x$的不同的映射$f$的个数，由于答案较大，输出答案对$14233333$取余的数即可。\n", "inputFormat": "输入一个正整数$k$\n", "outputFormat": "输出满足$f[f(x)]=x$的不同的映射$f$的个数对$14233333$取余得到的数。\n", "hint": "四个映射分别为：\n\n\n|f(1)|f(2)|f(3)|\n|-|-|-|\n|1|2|3|\n|1|3|2|\n|2|1|3|\n|3|2|1|\n\n数据范围：\n\n对于20%的数据，$1\\leq k\\leq 9$\n\n对于其它的80%的数据，$1\\leq k\\leq 10^7$\n\n\n内存20MB...（一开始开1MB把自己坑了）\n", "locale": "zh-CN", "translations": {"en": {"title": "Zhong's Mapping", "background": "In the year 2233, the math teacher and math contest advisor Zhong JG at CSSYZ School is already over 2200 years old. To celebrate the birthday, they gave a problem to the public.", "description": "Let $N = M = \\left\\{x|x\\in N_+,x\\leq k,k\\in N_+\\right\\}$. Let $f$ be a mapping from $N$ to $M$. Count the number of distinct mappings $f$ that satisfy $f(f(x)) = x$. Since the answer may be large, output the result modulo $14233333$.", "inputFormat": "A single positive integer $k$.", "outputFormat": "Output the number of distinct mappings $f$ satisfying $f(f(x)) = x$, modulo $14233333$.", "hint": "For $k = 3$, the four mappings are:\n\n| f(1) | f(2) | f(3) |\n|-|-|-|\n| 1 | 2 | 3 |\n| 1 | 3 | 2 |\n| 2 | 1 | 3 |\n| 3 | 2 | 1 |\n\nConstraints:\n\n- For 20% of the testdata, $1 \\leq k \\leq 9$.\n- For the other 80% of the testdata, $1 \\leq k \\leq 10^7$.\n\nMemory 20 MB... (I initially set 1 MB and got myself into trouble).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "钟氏映射", "background": "2233年，CSSYZ学校的数学老师兼数学竞赛顾问钟JG已经2200+岁啦！\n\n为了庆生，他或她给广大人民群众出了道题。\n", "description": "设集合$N=M=\\left\\{x|x\\in N_+,x\\leq k,k\\in N_+\\right\\}$\n\n设$f$为$N$到$M$的映射。\n\n求满足：\n\n$f[f(x)]=x$的不同的映射$f$的个数，由于答案较大，输出答案对$14233333$取余的数即可。\n", "inputFormat": "输入一个正整数$k$\n", "outputFormat": "输出满足$f[f(x)]=x$的不同的映射$f$的个数对$14233333$取余得到的数。\n", "hint": "四个映射分别为：\n\n\n|f(1)|f(2)|f(3)|\n|-|-|-|\n|1|2|3|\n|1|3|2|\n|2|1|3|\n|3|2|1|\n\n数据范围：\n\n对于20%的数据，$1\\leq k\\leq 9$\n\n对于其它的80%的数据，$1\\leq k\\leq 10^7$\n\n\n内存20MB...（一开始开1MB把自己坑了）\n", "locale": "zh-CN"}}}
{"pid": "P3796", "type": "P", "difficulty": 5, "samples": [["2\naba\nbab\nababababac\n6\nbeta\nalpha\nhaha\ndelta\ndede\ntata\ndedeltalphahahahototatalpha\n0", "4\naba\n2\nalpha\nhaha"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "字典树 Trie", "AC 自动机"], "title": "AC 自动机（简单版 II）", "background": "", "description": "有 $N$ 个由小写字母组成的模式串以及一个文本串 $T$。每个模式串可能会在文本串中出现多次。你需要找出**哪些**模式串在文本串 $T$ 中出现的次数最多。\n", "inputFormat": "输入含多组数据。保证输入数据不超过 $50$ 组。\n\n每组数据的第一行为一个正整数 $N$，表示共有 $N$ 个模式串，$1 \\leq N \\leq 150$。\n\n接下去 $N$ 行，每行一个长度小于等于 $70$ 的模式串。下一行是一个长度小于等于 $10^6$ 的文本串 $T$。保证不存在两个相同的模式串。\n\n输入结束标志为 $N=0$。", "outputFormat": "对于每组数据，第一行输出模式串最多出现的次数，接下去若干行每行输出一个出现次数最多的模式串，按输入顺序排列。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "AC Automaton (Simple Version II)", "background": "", "description": "There are $N$ pattern strings consisting of lowercase letters and a text string $T$. Each pattern may appear multiple times in the text. You need to find out **which** pattern strings appear the most times in the text $T$.", "inputFormat": "The input contains multiple test cases. There are at most $50$ test cases.\nThe first line of each test case contains a positive integer $N$, indicating the number of pattern strings, where $1 \\leq N \\leq 150$.\nThe next $N$ lines each contain a pattern string of length at most $70$. The next line contains a text string $T$ of length at most $10^6$. It is guaranteed that there are no duplicate pattern strings.\nThe input ends with $N = 0$.", "outputFormat": "For each test case, output on the first line the maximum number of occurrences among all pattern strings. Then output several lines, each containing one pattern string that achieves this maximum, in the same order as in the input.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "AC 自动机（简单版 II）", "background": "", "description": "有 $N$ 个由小写字母组成的模式串以及一个文本串 $T$。每个模式串可能会在文本串中出现多次。你需要找出**哪些**模式串在文本串 $T$ 中出现的次数最多。\n", "inputFormat": "输入含多组数据。保证输入数据不超过 $50$ 组。\n\n每组数据的第一行为一个正整数 $N$，表示共有 $N$ 个模式串，$1 \\leq N \\leq 150$。\n\n接下去 $N$ 行，每行一个长度小于等于 $70$ 的模式串。下一行是一个长度小于等于 $10^6$ 的文本串 $T$。保证不存在两个相同的模式串。\n\n输入结束标志为 $N=0$。", "outputFormat": "对于每组数据，第一行输出模式串最多出现的次数，接下去若干行每行输出一个出现次数最多的模式串，按输入顺序排列。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3797", "type": "P", "difficulty": 5, "samples": [["4 4\n2 1 4\n2 2 4\n1 2 (\n2 2 4", "1\n0\n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "线段树", "洛谷原创", "洛谷比赛"], "title": "妖梦斩木棒", "background": "![](https://cdn.luogu.com.cn/upload/pic/5848.png) \n\n妖梦是住在白玉楼的半人半灵，拥有使用剑术程度的能力。", "description": "有一天，妖梦正在练习剑术。地面上摆放着一根非常长的木棒，妖梦把它切成了等长的 $n$ 段。\n现在这根木棒可以看作由三种小段构成：中间的 $n - 2$ 段都是左右都被切断的断头，我们记作 `X`；最左边的一段和最右边的一段各有一个圆头，分别记作 `(` 和 `)`。\n\n幽幽子吃饱后闲来无事，决定戏弄一下妖梦。她拿来了许多这样的三种小段木棒，来替换掉妖梦切下来的 $n$ 段中的一部分，然后问妖梦一些问题。\n\n这些操作可以这样描述：\n\n- `1 x C` 将第 $x$ 个小段的木棒替换成 $C$ 型，$C$ 只会是 `X`, `(`, `)` 中的一种\n\n- `2 l r` 询问在区间 $[l, r]$ 中（包含两端），有多少个完整的木棒。\n\n完整的木棒左右两端必须分别为 `(` 和 `)`，并且中间要么什么都没有，要么只能有 `X`。\n\n虽然妖梦能够数清楚这些问题，但幽幽子觉得她回答得太慢了，你能教给妖梦一个更快的办法吗？", "inputFormat": "第一行包含两个整数 $n, m$，分别表示共有 $n$ 段木棒，以及有 $m$ 次操作。\n\n木棒的初始形状为 `(XXXX...XXXX)`\n\n接下来 $m$ 行，每行三个整数/字符，用空格隔开。\n\n第一个整数为 $1$ 或 $2$，表示操作的类型，若类型为 $1$，则接下来一个整数 $x$，一个字符 $C$。若类型为 $2$，接下来两个整数 $l,r$。含义见题目描述。", "outputFormat": "对于每一个操作二，输出一行一个整数，表示该询问的答案。", "hint": "对于 $30\\%$ 的数据，$2 \\leq n,m \\leq 1 \\times 10^3$。\n\n对于 $100\\%$ 的数据，$2 \\leq n,m \\leq 2 \\times 10^5$。\n\nby-orangebird。", "locale": "zh-CN", "translations": {"en": {"title": "Youmu Chops the Wooden Rod", "background": "![](https://cdn.luogu.com.cn/upload/pic/5848.png) \n\nYoumu is a half-human, half-phantom living in Hakugyokurou, and she has the ability to wield sword techniques.", "description": "One day, Youmu was practicing swordsmanship. There was an extremely long wooden rod on the ground, and Youmu cut it into $n$ equal segments. Now this rod can be regarded as composed of three kinds of small segments: the middle $n - 2$ segments are stumps cut on both sides, denoted by `X`; the leftmost segment and the rightmost segment each have a rounded end, denoted by `(` and `)` respectively.\n\nAfter eating her fill and feeling bored, Yuyuko decided to play a prank on Youmu. She brought many small wooden segments of these three types to replace part of the $n$ segments Youmu had cut, and then asked Youmu some questions.\n\nThese operations are described as follows:\n\n- `1 x C` Replace the $x$-th small segment with type $C$, where $C$ is one of `X`, `(`, `)`.\n- `2 l r` Query how many complete rods are in the interval $[l, r]$ (inclusive).\n\nA complete rod must have `(` on the left end and `)` on the right end, and between them there may be zero or more `X` only.\n\nAlthough Youmu can count the answers to these questions, Yuyuko thinks she answers too slowly. Can you teach Youmu a faster method?", "inputFormat": "The first line contains two integers $n, m$, representing that there are $n$ segments and $m$ operations.\n\nThe initial shape of the rod is `(XXXX...XXXX)`.\n\nThen follow $m$ lines, each describing one operation in one of the following forms, separated by spaces:\n- Type 1: `1 x C` — an integer $x$ and a character $C$.\n- Type 2: `2 l r` — two integers $l, r$.\n\nThe meanings are as described above.", "outputFormat": "For each type 2 operation, output one line with one integer, representing the answer to that query.", "hint": "For 30% of the testdata, $2 \\leq n, m \\leq 1 \\times 10^3$.\n\nFor 100% of the testdata, $2 \\leq n, m \\leq 2 \\times 10^5$.\n\nby-orangebird.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "妖梦斩木棒", "background": "![](https://cdn.luogu.com.cn/upload/pic/5848.png) \n\n妖梦是住在白玉楼的半人半灵，拥有使用剑术程度的能力。", "description": "有一天，妖梦正在练习剑术。地面上摆放着一根非常长的木棒，妖梦把它切成了等长的 $n$ 段。\n现在这根木棒可以看作由三种小段构成：中间的 $n - 2$ 段都是左右都被切断的断头，我们记作 `X`；最左边的一段和最右边的一段各有一个圆头，分别记作 `(` 和 `)`。\n\n幽幽子吃饱后闲来无事，决定戏弄一下妖梦。她拿来了许多这样的三种小段木棒，来替换掉妖梦切下来的 $n$ 段中的一部分，然后问妖梦一些问题。\n\n这些操作可以这样描述：\n\n- `1 x C` 将第 $x$ 个小段的木棒替换成 $C$ 型，$C$ 只会是 `X`, `(`, `)` 中的一种\n\n- `2 l r` 询问在区间 $[l, r]$ 中（包含两端），有多少个完整的木棒。\n\n完整的木棒左右两端必须分别为 `(` 和 `)`，并且中间要么什么都没有，要么只能有 `X`。\n\n虽然妖梦能够数清楚这些问题，但幽幽子觉得她回答得太慢了，你能教给妖梦一个更快的办法吗？", "inputFormat": "第一行包含两个整数 $n, m$，分别表示共有 $n$ 段木棒，以及有 $m$ 次操作。\n\n木棒的初始形状为 `(XXXX...XXXX)`\n\n接下来 $m$ 行，每行三个整数/字符，用空格隔开。\n\n第一个整数为 $1$ 或 $2$，表示操作的类型，若类型为 $1$，则接下来一个整数 $x$，一个字符 $C$。若类型为 $2$，接下来两个整数 $l,r$。含义见题目描述。", "outputFormat": "对于每一个操作二，输出一行一个整数，表示该询问的答案。", "hint": "对于 $30\\%$ 的数据，$2 \\leq n,m \\leq 1 \\times 10^3$。\n\n对于 $100\\%$ 的数据，$2 \\leq n,m \\leq 2 \\times 10^5$。\n\nby-orangebird。", "locale": "zh-CN"}}}
{"pid": "P3798", "type": "P", "difficulty": 7, "samples": [["样例任务（无需提交）:\n n=2,m=2。 玩家C行动时只可以放置2。请输出一个整数，表示棋盘上可能出现的最大数字。\n", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "动态规划 DP", "搜索", "贪心", "洛谷原创", "提交答案", "剪枝", "记忆化搜索", "洛谷比赛"], "title": "辉夜姬的十道难题", "background": "妹红最近玩了一款叫 $2048$ 的小游戏。\n\n![](https://cdn.luogu.com.cn/upload/pic/5857.png)\n\n(图为个人无撤销最高纪录~ 纯手玩)。", "description": "$2048$ 是一个非常简单的数字游戏，它在 $4\\times 4$ 的棋盘上进行，通过移动来合并数字，达到 $2048$ 即算胜利。妹红最近沉迷上了这个游戏，事情传到辉夜那里后，辉夜决定用曾经无人破解的十道难题来考考妹红。\n\n游戏规则：\n\n1. 游戏在 $n\\times m$ 的方格棋盘上进行。\n\n2. 两个玩家，其中一个可以移动棋盘上的数字，记做 M，另外一个可以向棋盘上放数字，记做 C。\n\n3. 移动数字的规则如下：可以向上/下/左/右四个方向的其中之一移动。选定好方向后，所有数字都会向该方向靠拢，相同的两个数字相撞时会合并成一个新数字，这个数字是它们的和。在一次移动中，每个数字最多只能合并一次，优先合并靠近移动方向棋盘边缘的数字。\n\n以 $n=2,m=4$ 的情况举例如下（$0$ 表示该位置为空）：\n\n```\n2 2 2 2\n2 2 0 2\n```\n\n向左移动后变为：\n\n```\n4 4 0 0\n4 2 0 0\n```\n\n每次合并后，将会获得一定的分数，获得的分数等于所有合并后数字相加之和。若无任何合并发生，则不得分。在上例中，得分为 $12$。\n\n移动前后，若棋盘上的所有数字大小和位置均没有变化，则不算做有效移动，否则即是有效移动。\n\n4. 向棋盘放置数字的规则如下：只能选择棋盘上没有数字的位置放置一个数字，可以放置的数字和放置方法在每个子任务中会具体描述。\n\n5. 游戏开始时棋盘为空，分数为 $0$。先由玩家 C 行动两步，接着玩家 M 和 C 轮流行动，中间的每一步都必须是有效的。当轮到玩家 M 时，若不能够进行有效移动，则游戏结束，此时的得分为最终得分。\n\n本题目为提交答案题，共有 $10$ 个子任务需要你来完成。将你的答案写到 $10$ 个文件中，分别命名为 ```gamex.out```，$x$ 表示子任务的编号（$0\\ldots 9$）。\n\n子任务内无部分分，你可以得到该任务的分数当且仅当你的输出和标准答案完全相同。\n\n十道难题如下:\n\n0. $n=1,m=2$。玩家 C 行动时可以放置 $2$ 或 $4$。若用 $x$ 表示在一局游戏中玩家 M 最多可以行动 $x$ 次，那么这个 $x$ 的最值是多少？输出两行，第一行一个整数表示 $x$ 的最小值，第二行一个整数表示 $x$ 的最大值。\n\n1. $n=10738029,m=921023$。玩家 C 行动时可以放置 $2$ 或 $4$。若用 $x$ 表示棋盘上所有数字之和，请问 $x$ 的最大值是多少。因为这个值可能过大，只需要输出它除以 $10^9+7$ 的余数即可。\n\n2. $n=2,m=2$。玩家 C 行动时可以放置 $2,4$。用 $x$ 表示目标数字， $x$ 一定为 $2$ 的正整数幂。玩家 M 的目标是使盘面上出现大于等于数字 $x$ 的数，玩家 C 的目标是在盘面上出现数字 $x$ 之前使游戏结束。在两方均最优决策的情况下，求一个最大的 $x$，使得玩家 M 能达到自己的目标。\n\n3. $n=4,m=4$。玩家 C 行动时可以放置 $2,4$。输出两行，每行一个数字。第一行的数字表示能达到的最大分数。第二行的数字表示当数字总和达到最大时，分数的最小值。\n\n4. $n=7393,m=9133$。玩家 C 可以放置数字 $2$ 共 $6144$ 次。棋盘初始为空，初始分数为 $0$。首先由玩家 C 连续行动，直到用完所有放置机会或中途主动放弃。然后连续向上移动直到向上方向不能构成有效移动。输出一行一个整数，表示最大得分。\n\n5. $n=7,m=233$。初始分数为 $0$,玩家 C 可以放置数字 $2$ 共 $233$ 次，数字 $4$ 共 $66$ 次。棋盘第一行一开始有若干数字，第 $i$ 列的数字为 $\\text{lowbit}(i)\\times 2$，$\\text{lowbit}(i)$ 表示数字 $i$ 的二进制形式只取最后一个 $1$ 构成的数字。如 $\\text{lowbit}(1\\ldots 8)$ 为 $1,2,1,4,1,2,1,8$。棋盘的其他位置均为空。首先由玩家 C 连续行动，直到用完所有放置机会或中途主动放弃。然后连续向上移动直到向上方向不能构成有效移动。输出一行一个整数，表示最大得分。\n\n6. $n=3,m=3$。玩家 C 行动时可以放置 $2,4$。用 $x$ 表示目标数字，$x$ 一定为 $2$ 的正整数幂。玩家 M 的目标是使盘面上出现数字 $x$，玩家 C 的目标是在盘面上出现数字 $x$ 之前使游戏结束。在两方均最优决策的情况下，输出一个最大的 $x$，使得玩家 M 能达到自己的目标。\n\n7. $n=3,m=3$。玩家 C 行动时可以放置 $2,4$。玩家 M 的目标是让得分最大化，玩家 C 的目标是让得分最小化，在两方均最优决策的情况下，输出一个整数，表示最终的分数。\n\n8. $n=3,m=3$。玩家 C 行动时，有 $90\\%$ 的几率放置一个 $2$，$10\\%$ 的几率放置一个 $4$，放置在各个空位的几率均等。用 $x$ 表示目标数字，玩家 M 的目标是使盘面上出现大于等于数字 $x$ 的数。在玩家 M 最优决策的情况下，输出一行，$9$ 个实数，四舍五入到小数点后 $2$ 位，用空格隔开，分别表示 $x=2,4,8,16,32,64,128,256,512$ 时，达成目标数字的概率。\n\n9. $n=3,m=3$。玩家 C 行动时，有 $90\\%$ 的几率放置一个 $2$，$10\\%$ 的几率放置一个 $4$，放置在各个空位的几率均等。玩家 M 的目标是让分数最大化。在玩家 M 最优决策的情况下，输出一个实数，四舍五入保留整数，表示分数的期望值。\n\n妹红虽然对 $2048$ 有一定了解，但她并不能解决全部的问题，于是就交给了学 OI 的你。", "inputFormat": "见题目描述\n", "outputFormat": "见题目描述\n", "hint": "如果对移动规则有疑惑，可以到 $2048$ 网站进行尝试:\n\nhttp://gabrielecirulli.github.io/2048/\n\nby-orangebird\n", "locale": "zh-CN", "translations": {"en": {"title": "Kaguya-hime's Ten Challenges", "background": "Meihong recently started playing a small game called $2048$.\n\n![](https://cdn.luogu.com.cn/upload/pic/5857.png)\n\n(The picture shows a personal best with no undo — hand played.).", "description": "$2048$ is a very simple number game played on a $4 \\times 4$ board. By moving to merge numbers, reaching $2048$ counts as a win. Meihong has become addicted to the game. When the news reached Kaguya, she decided to test Meihong with ten puzzles that no one had solved before.\n\nGame rules:\n\n1. The game is played on an $n \\times m$ grid.\n\n2. There are two players. One can move the numbers on the board, denoted by M, and the other can place numbers on the board, denoted by C.\n\n3. The rules for moving numbers are as follows: you can move in one of the four directions: up/down/left/right. After choosing a direction, all numbers slide toward that direction. When two equal numbers collide, they merge into a new number equal to their sum. In a single move, each tile can merge at most once, and merges prioritize tiles closer to the edge in the movement direction.\n\nFor example, when $n=2, m=4$ ($0$ denotes an empty cell):\n\n```\n2 2 2 2\n2 2 0 2\n```\n\nAfter moving left, it becomes:\n\n```\n4 4 0 0\n4 2 0 0\n```\n\nAfter each merge, you gain score equal to the sum of all newly created numbers from merges in that move. If no merges occur, you gain no score. In the example above, the score is $12$.\n\nIf, before and after a move, all numbers on the board have the same values and positions, the move is not valid; otherwise, it is a valid move.\n\n4. The rules for placing numbers are as follows: you may place a number only in an empty cell, and which numbers can be placed and how they are placed are specified in each subtask.\n\n5. The game starts with an empty board and a score of $0$. Player C takes two moves first. Then players M and C alternate moves, and every move in between must be valid. When it is player M’s turn and they cannot make a valid move, the game ends, and the current score is the final score.\n\nThis is an output-only problem with $10$ subtasks for you to complete. Write your answers to $10$ files named ```gamex.out```, where $x$ is the subtask index ($0 \\ldots 9$).\n\nThere are no partial points within a subtask; you receive the subtask’s score if and only if your output exactly matches the reference answer.\n\nThe ten challenges are as follows:\n\n0. $n=1, m=2$. When player C acts, they may place $2$ or $4$. Let $x$ denote the maximum number of moves player M can make in a single game. What are the extremal values of $x$? Output two lines: the first line is an integer for the minimum possible $x$, and the second line is an integer for the maximum possible $x$.\n\n1. $n=10738029, m=921023$. When player C acts, they may place $2$ or $4$. Let $x$ be the sum of all numbers on the board. What is the maximum value of $x$? Because this value may be too large, output it modulo $10^9+7$.\n\n2. $n=2, m=2$. When player C acts, they may place $2, 4$. Let $x$ denote the target number, where $x$ is a positive power of $2$. Player M’s goal is to make a number at least $x$ appear on the board, while player C’s goal is to end the game before a number $x$ appears on the board. Under optimal play by both sides, find the largest $x$ such that player M can achieve their goal.\n\n3. $n=4, m=4$. When player C acts, they may place $2, 4$. Output two lines, each with one number. The first line is the maximum achievable score. The second line is the minimum score when the total sum of numbers on the board reaches its maximum.\n\n4. $n=7393, m=9133$. Player C can place the number $2$ a total of $6144$ times. The board is initially empty and the initial score is $0$. First, player C acts consecutively until they use all placement opportunities or voluntarily stop early. Then move upward repeatedly until an upward move is no longer valid. Output one integer on a single line: the maximum score.\n\n5. $n=7, m=233$. The initial score is $0$. Player C can place the number $2$ a total of $233$ times and the number $4$ a total of $66$ times. The first row initially contains some numbers: the number in column $i$ is $\\text{lowbit}(i) \\times 2$, where $\\text{lowbit}(i)$ denotes the number formed by taking only the last $1$ in the binary representation of $i$. For example, $\\text{lowbit}(1 \\ldots 8)$ are $1, 2, 1, 4, 1, 2, 1, 8$. All other cells are empty. First, player C acts consecutively until they use all placement opportunities or voluntarily stop early. Then move upward repeatedly until an upward move is no longer valid. Output one integer on a single line: the maximum score.\n\n6. $n=3, m=3$. When player C acts, they may place $2, 4$. Let $x$ denote the target number, where $x$ is a positive power of $2$. Player M’s goal is to make a number $x$ appear on the board, while player C’s goal is to end the game before a number $x$ appears. Under optimal play by both sides, output the largest $x$ such that player M can achieve their goal.\n\n7. $n=3, m=3$. When player C acts, they may place $2, 4$. Player M’s goal is to maximize the score, and player C’s goal is to minimize the score. Under optimal play by both sides, output an integer representing the final score.\n\n8. $n=3, m=3$. When player C acts, there is a $90\\%$ chance to place a $2$ and a $10\\%$ chance to place a $4$, with equal probability among all empty cells. Let $x$ denote the target number. Player M’s goal is to make a number at least $x$ appear on the board. Under player M’s optimal strategy, output one line with $9$ real numbers, rounded to $2$ decimal places and separated by spaces, representing the probability of achieving the target for $x=2, 4, 8, 16, 32, 64, 128, 256, 512$.\n\n9. $n=3, m=3$. When player C acts, there is a $90\\%$ chance to place a $2$ and a $10\\%$ chance to place a $4$, with equal probability among all empty cells. Player M’s goal is to maximize the score. Under player M’s optimal strategy, output one real number, rounded to the nearest integer, representing the expected score.\n\nAlthough Meihong has some understanding of $2048$, she cannot solve all the problems, so she turns to you, who studies OI.", "inputFormat": "See the problem statement.", "outputFormat": "See the problem statement.", "hint": "If you are unsure about the movement rules, you can try them on the $2048$ website:\n\nhttp://gabrielecirulli.github.io/2048/\n\nby-orangebird.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "辉夜姬的十道难题", "background": "妹红最近玩了一款叫 $2048$ 的小游戏。\n\n![](https://cdn.luogu.com.cn/upload/pic/5857.png)\n\n(图为个人无撤销最高纪录~ 纯手玩)。", "description": "$2048$ 是一个非常简单的数字游戏，它在 $4\\times 4$ 的棋盘上进行，通过移动来合并数字，达到 $2048$ 即算胜利。妹红最近沉迷上了这个游戏，事情传到辉夜那里后，辉夜决定用曾经无人破解的十道难题来考考妹红。\n\n游戏规则：\n\n1. 游戏在 $n\\times m$ 的方格棋盘上进行。\n\n2. 两个玩家，其中一个可以移动棋盘上的数字，记做 M，另外一个可以向棋盘上放数字，记做 C。\n\n3. 移动数字的规则如下：可以向上/下/左/右四个方向的其中之一移动。选定好方向后，所有数字都会向该方向靠拢，相同的两个数字相撞时会合并成一个新数字，这个数字是它们的和。在一次移动中，每个数字最多只能合并一次，优先合并靠近移动方向棋盘边缘的数字。\n\n以 $n=2,m=4$ 的情况举例如下（$0$ 表示该位置为空）：\n\n```\n2 2 2 2\n2 2 0 2\n```\n\n向左移动后变为：\n\n```\n4 4 0 0\n4 2 0 0\n```\n\n每次合并后，将会获得一定的分数，获得的分数等于所有合并后数字相加之和。若无任何合并发生，则不得分。在上例中，得分为 $12$。\n\n移动前后，若棋盘上的所有数字大小和位置均没有变化，则不算做有效移动，否则即是有效移动。\n\n4. 向棋盘放置数字的规则如下：只能选择棋盘上没有数字的位置放置一个数字，可以放置的数字和放置方法在每个子任务中会具体描述。\n\n5. 游戏开始时棋盘为空，分数为 $0$。先由玩家 C 行动两步，接着玩家 M 和 C 轮流行动，中间的每一步都必须是有效的。当轮到玩家 M 时，若不能够进行有效移动，则游戏结束，此时的得分为最终得分。\n\n本题目为提交答案题，共有 $10$ 个子任务需要你来完成。将你的答案写到 $10$ 个文件中，分别命名为 ```gamex.out```，$x$ 表示子任务的编号（$0\\ldots 9$）。\n\n子任务内无部分分，你可以得到该任务的分数当且仅当你的输出和标准答案完全相同。\n\n十道难题如下:\n\n0. $n=1,m=2$。玩家 C 行动时可以放置 $2$ 或 $4$。若用 $x$ 表示在一局游戏中玩家 M 最多可以行动 $x$ 次，那么这个 $x$ 的最值是多少？输出两行，第一行一个整数表示 $x$ 的最小值，第二行一个整数表示 $x$ 的最大值。\n\n1. $n=10738029,m=921023$。玩家 C 行动时可以放置 $2$ 或 $4$。若用 $x$ 表示棋盘上所有数字之和，请问 $x$ 的最大值是多少。因为这个值可能过大，只需要输出它除以 $10^9+7$ 的余数即可。\n\n2. $n=2,m=2$。玩家 C 行动时可以放置 $2,4$。用 $x$ 表示目标数字， $x$ 一定为 $2$ 的正整数幂。玩家 M 的目标是使盘面上出现大于等于数字 $x$ 的数，玩家 C 的目标是在盘面上出现数字 $x$ 之前使游戏结束。在两方均最优决策的情况下，求一个最大的 $x$，使得玩家 M 能达到自己的目标。\n\n3. $n=4,m=4$。玩家 C 行动时可以放置 $2,4$。输出两行，每行一个数字。第一行的数字表示能达到的最大分数。第二行的数字表示当数字总和达到最大时，分数的最小值。\n\n4. $n=7393,m=9133$。玩家 C 可以放置数字 $2$ 共 $6144$ 次。棋盘初始为空，初始分数为 $0$。首先由玩家 C 连续行动，直到用完所有放置机会或中途主动放弃。然后连续向上移动直到向上方向不能构成有效移动。输出一行一个整数，表示最大得分。\n\n5. $n=7,m=233$。初始分数为 $0$,玩家 C 可以放置数字 $2$ 共 $233$ 次，数字 $4$ 共 $66$ 次。棋盘第一行一开始有若干数字，第 $i$ 列的数字为 $\\text{lowbit}(i)\\times 2$，$\\text{lowbit}(i)$ 表示数字 $i$ 的二进制形式只取最后一个 $1$ 构成的数字。如 $\\text{lowbit}(1\\ldots 8)$ 为 $1,2,1,4,1,2,1,8$。棋盘的其他位置均为空。首先由玩家 C 连续行动，直到用完所有放置机会或中途主动放弃。然后连续向上移动直到向上方向不能构成有效移动。输出一行一个整数，表示最大得分。\n\n6. $n=3,m=3$。玩家 C 行动时可以放置 $2,4$。用 $x$ 表示目标数字，$x$ 一定为 $2$ 的正整数幂。玩家 M 的目标是使盘面上出现数字 $x$，玩家 C 的目标是在盘面上出现数字 $x$ 之前使游戏结束。在两方均最优决策的情况下，输出一个最大的 $x$，使得玩家 M 能达到自己的目标。\n\n7. $n=3,m=3$。玩家 C 行动时可以放置 $2,4$。玩家 M 的目标是让得分最大化，玩家 C 的目标是让得分最小化，在两方均最优决策的情况下，输出一个整数，表示最终的分数。\n\n8. $n=3,m=3$。玩家 C 行动时，有 $90\\%$ 的几率放置一个 $2$，$10\\%$ 的几率放置一个 $4$，放置在各个空位的几率均等。用 $x$ 表示目标数字，玩家 M 的目标是使盘面上出现大于等于数字 $x$ 的数。在玩家 M 最优决策的情况下，输出一行，$9$ 个实数，四舍五入到小数点后 $2$ 位，用空格隔开，分别表示 $x=2,4,8,16,32,64,128,256,512$ 时，达成目标数字的概率。\n\n9. $n=3,m=3$。玩家 C 行动时，有 $90\\%$ 的几率放置一个 $2$，$10\\%$ 的几率放置一个 $4$，放置在各个空位的几率均等。玩家 M 的目标是让分数最大化。在玩家 M 最优决策的情况下，输出一个实数，四舍五入保留整数，表示分数的期望值。\n\n妹红虽然对 $2048$ 有一定了解，但她并不能解决全部的问题，于是就交给了学 OI 的你。", "inputFormat": "见题目描述\n", "outputFormat": "见题目描述\n", "hint": "如果对移动规则有疑惑，可以到 $2048$ 网站进行尝试:\n\nhttp://gabrielecirulli.github.io/2048/\n\nby-orangebird\n", "locale": "zh-CN"}}}
{"pid": "P3799", "type": "P", "difficulty": 3, "samples": [["4 \n1\n1\n2\n2", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创", "枚举", "组合数学", "洛谷比赛"], "title": "小 Y 拼木棒", "background": "上道题中，小 Y 斩了一地的木棒，现在她想要将木棒拼起来。", "description": "有 $n$ 根木棒，现在从中选 $4$ 根，想要组成一个正三角形，问有几种选法？\n\n答案对 $10^9+7$ 取模。", "inputFormat": "第一行一个整数 $n$。\n\n第二行往下 $n$ 行，每行 $1$ 个整数，第 $i$ 个整数 $a_i$ 代表第 $i$ 根木棒的长度。", "outputFormat": "一行一个整数代表答案。\n", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\le 5 \\times 10^3$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\le 10^5$，$1 \\le a_i \\le 5 \\times 10^3$。\n\n关于标题：因为一些不可抗力的原因，名称进行了更改。深表歉意。", "locale": "zh-CN", "translations": {"en": {"title": "Xiao Y Assembles Wooden Sticks", "background": "In the previous problem, Xiao Y cut a lot of wooden sticks. Now she wants to put the sticks together.", "description": "There are $n$ wooden sticks. Choose $4$ of them, and you want to be able to form an equilateral triangle. How many such selections are there.\n\nThe answer is taken modulo $10^9+7$.", "inputFormat": "The first line contains an integer $n$.\n\nFrom the second line, there are $n$ lines. Each line contains $1$ integer. The $i$-th integer $a_i$ represents the length of the $i$-th stick.", "outputFormat": "Output a single integer representing the answer.", "hint": "#### Constraints\n\n- For $30\\%$ of the testdata, it is guaranteed that $n \\le 5 \\times 10^3$.\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\le 10^5$, $1 \\le a_i \\le 5 \\times 10^3$.\n\nAbout the title: Due to some unforeseen circumstances, the name has been changed. We sincerely apologize.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小 Y 拼木棒", "background": "上道题中，小 Y 斩了一地的木棒，现在她想要将木棒拼起来。", "description": "有 $n$ 根木棒，现在从中选 $4$ 根，想要组成一个正三角形，问有几种选法？\n\n答案对 $10^9+7$ 取模。", "inputFormat": "第一行一个整数 $n$。\n\n第二行往下 $n$ 行，每行 $1$ 个整数，第 $i$ 个整数 $a_i$ 代表第 $i$ 根木棒的长度。", "outputFormat": "一行一个整数代表答案。\n", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\le 5 \\times 10^3$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\le 10^5$，$1 \\le a_i \\le 5 \\times 10^3$。\n\n关于标题：因为一些不可抗力的原因，名称进行了更改。深表歉意。", "locale": "zh-CN"}}}
{"pid": "P3800", "type": "P", "difficulty": 4, "samples": [["3 3 4 1\n1 1 3\n1 2 1\n2 2 3\n3 3 3\n", "9"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "单调队列", "洛谷原创", "O2优化", "ST 表", "洛谷比赛"], "title": "Power 收集", "background": "据说在红雾异变时，博丽灵梦单身前往红魔馆，用十分强硬的手段将事件解决了。\n\n然而当时灵梦在 Power 达到 MAX 之前，不具有“上线收点”的能力，所以她想要知道她能收集多少 P 点，然而这个问题她答不上来，于是她找到了学 OI 的你。", "description": "可以把游戏界面理解成一个 $N$ 行 $M$ 列的棋盘，有 $K$ 个格子上有 P 点，其价值为 $\\operatorname{val}(i,j)$。\n\n初始灵梦可以选择在第一行的任意一个格子出发，每秒她必须下移一格。\n\n灵梦具有一个左右移动的速度 $T$，可以使她每秒向左或右移动至多 $T$ 格，也可以不移动，并且在单次移动中不能折返。移动可视为瞬间完成，不经过路途上的点，只能获得目标格子的 P 点。\n\n求最终她能获得的所有 P 点的价值总和最大是多少？", "inputFormat": "第一行四个整数，$N,M,K,T$。\n\n接下来 $K$ 行每行 $3$ 个整数 $x,y,v$，代表第 $x$ 行第 $y$ 列有一个 $\\operatorname{val}$ 为 $v$ 的 P 点，数据保证一个格子上最多只有 $1$ 个 P 点。", "outputFormat": "一个整数，表示灵梦能获得的 P 点的价值总和的最大值。", "hint": "对于 $40\\%$ 的测试点，$1 \\le N,M,T,K \\le 200$。\n\n对于 $100\\%$ 的测试点，$1 \\le N,M,T,K \\le 4000$，$0 \\le v \\le 100$，$N,M,K,T$ 均为整数。\n\nby-szc", "locale": "zh-CN", "translations": {"en": {"title": "Power Collection", "background": "It is said that during the Scarlet Mist incident, Reimu Hakurei went alone to the Scarlet Devil Mansion and resolved the incident with very forceful means. However, before her Power reached MAX, Reimu did not have the ability to \"collect at the top line\" (上线收点), so she wanted to know how many P points she could collect. She could not answer this question, so she turned to you, who study OI.", "description": "Treat the game screen as an $N$-row by $M$-column grid. There are P points on $K$ cells, and their values are $\\operatorname{val}(i,j)$.\n\nInitially, Reimu may choose any cell in the first row to start. Each second, she must move down by exactly one row.\n\nReimu has a horizontal speed $T$, allowing her each second to move left or right by at most $T$ columns, or not move horizontally at all, and she cannot reverse direction within a single move. Movement is considered instantaneous: she does not pass through intermediate cells en route and can only obtain the P point on the destination cell.\n\nCompute the maximum possible total value of all P points she can obtain.", "inputFormat": "The first line contains four integers, $N,M,K,T$.\n\nEach of the next $K$ lines contains three integers $x,y,v$, indicating that there is a P point with $\\operatorname{val}=v$ at row $x$, column $y$. It is guaranteed that there is at most $1$ P point on any cell.", "outputFormat": "Output a single integer, the maximum total value of P points Reimu can obtain.", "hint": "For $40\\%$ of the testdata, $1 \\le N,M,T,K \\le 200$.\n\nFor $100\\%$ of the testdata, $1 \\le N,M,T,K \\le 4000$, $0 \\le v \\le 100$, and $N,M,K,T$ are all integers.\n\nby-szc\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Power 收集", "background": "据说在红雾异变时，博丽灵梦单身前往红魔馆，用十分强硬的手段将事件解决了。\n\n然而当时灵梦在 Power 达到 MAX 之前，不具有“上线收点”的能力，所以她想要知道她能收集多少 P 点，然而这个问题她答不上来，于是她找到了学 OI 的你。", "description": "可以把游戏界面理解成一个 $N$ 行 $M$ 列的棋盘，有 $K$ 个格子上有 P 点，其价值为 $\\operatorname{val}(i,j)$。\n\n初始灵梦可以选择在第一行的任意一个格子出发，每秒她必须下移一格。\n\n灵梦具有一个左右移动的速度 $T$，可以使她每秒向左或右移动至多 $T$ 格，也可以不移动，并且在单次移动中不能折返。移动可视为瞬间完成，不经过路途上的点，只能获得目标格子的 P 点。\n\n求最终她能获得的所有 P 点的价值总和最大是多少？", "inputFormat": "第一行四个整数，$N,M,K,T$。\n\n接下来 $K$ 行每行 $3$ 个整数 $x,y,v$，代表第 $x$ 行第 $y$ 列有一个 $\\operatorname{val}$ 为 $v$ 的 P 点，数据保证一个格子上最多只有 $1$ 个 P 点。", "outputFormat": "一个整数，表示灵梦能获得的 P 点的价值总和的最大值。", "hint": "对于 $40\\%$ 的测试点，$1 \\le N,M,T,K \\le 200$。\n\n对于 $100\\%$ 的测试点，$1 \\le N,M,T,K \\le 4000$，$0 \\le v \\le 100$，$N,M,K,T$ 均为整数。\n\nby-szc", "locale": "zh-CN"}}}
{"pid": "P3801", "type": "P", "difficulty": 4, "samples": [["4 4 3\n1 2 2\n1 4 4\n2 1 1 4 4\n", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "树状数组", "洛谷原创", "容斥原理", "洛谷比赛"], "title": "红色的幻想乡", "background": "蕾米莉亚的红雾异变失败后，很不甘心。", "description": "经过上次失败后，蕾米莉亚决定再次发动红雾异变，但为了防止被灵梦退治，她决定将红雾以奇怪的阵势释放。\n\n我们将幻想乡看做是一个 $n \\times m$ 的方格地区，一开始没有任何一个地区被红雾遮盖。蕾米莉亚每次站在某一个地区上，向东南西北四个方向各发出一条无限长的红雾，可以影响到整行/整列，但不会影响到她所站的那个地区。如果两阵红雾碰撞，则会因为密度过大而沉降消失。灵梦察觉到了这次异变，决定去解决它。但在解决之前，灵梦想要了解一片范围红雾的密度。可以简述为两种操作:\n\n``1 x y`` 蕾米莉亚站在坐标 $(x,y)$ 的位置向四个方向释放无限长的红雾。\n\n``2 x1 y1 x2 y2`` 询问左上点为$(x1,y1)$，右下点为 $(x2,y2)$ 的矩形范围内，被红雾遮盖的地区的数量。", "inputFormat": "第一行三个整数 $n,m,q$，表示幻想乡大小为 $n \\times m$，有 $q$ 个询问。\n\n接下来 $q$ 行，每行 $3$ 个或 $5$ 个整数,用空格隔开，含义见题目描述。", "outputFormat": "对于每一个操作 $2$，输出一行一个整数，表示对应询问的答案。", "hint": "#### 样例输入输出 1 解释\n\n用``o``表示没有红雾，``x``表示有红雾，两次释放红雾后幻想乡地图如下:\n\n```\noxox\nxoxo\noxox\nxoxo\n```\n\n---\n\n#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，$1 \\le n,m,q \\le 200$。\n- 对于 $40\\%$ 的数据，$1 \\le n,m,q \\le 10^3$。\n- 对于 $100\\%$ 的数据，$1 \\le n,m,q \\le 10^5$，$1 \\le x_1,x_2,x \\le n$，$x_1 \\le x_2$，$1 \\le y_1,y_2,y \\le m$，$y_1 \\le y_2$。", "locale": "zh-CN", "translations": {"en": {"title": "Red Gensokyo", "background": "After the failure of Remilia’s Scarlet Mist incident, she was unwilling to accept it.", "description": "After the last failure, Remilia decided to launch the Scarlet Mist incident again. To avoid being exorcised by Reimu, she decided to release the red mist in a strange formation.\n\nWe model Gensokyo as an $n \\times m$ grid. Initially, no cell is covered by red mist. Each time, Remilia stands on some cell and emits one infinitely long red mist in each of the four cardinal directions, affecting the entire row/column, but not the cell she stands on. If two red mists collide, they settle and disappear due to excessive density. Reimu notices this incident and decides to resolve it. Before that, she wants to know the density of red mist in a rectangular region, which can be summarized as two operations:\n\n``1 x y`` Remilia stands at coordinate $(x, y)$ and releases infinitely long red mist in the four directions.\n\n``2 x1 y1 x2 y2`` Query the number of cells covered by red mist within the rectangle with top-left $(x_1, y_1)$ and bottom-right $(x_2, y_2)$.", "inputFormat": "The first line contains three integers $n, m, q$, meaning the size of Gensokyo is $n \\times m$, and there are $q$ operations.\n\nThen follow $q$ lines. Each line contains $3$ or $5$ integers separated by spaces, as described above.", "outputFormat": "For each operation of type $2$, output one line with one integer representing the answer to that query.", "hint": "#### Sample Input/Output 1 Explanation\n\nLet ``o`` denote no red mist, and ``x`` denote red mist. After two releases of red mist, the map of Gensokyo looks like:\n\n```\noxox\nxoxo\noxox\nxoxo\n```\n\n---\n\n#### Constraints\n\n- For $20\\%$ of the testdata, $1 \\le n, m, q \\le 200$.\n- For $40\\%$ of the testdata, $1 \\le n, m, q \\le 10^3$.\n- For $100\\%$ of the testdata, $1 \\le n, m, q \\le 10^5$, $1 \\le x_1, x_2, x \\le n$, $x_1 \\le x_2$, $1 \\le y_1, y_2, y \\le m$, $y_1 \\le y_2$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "红色的幻想乡", "background": "蕾米莉亚的红雾异变失败后，很不甘心。", "description": "经过上次失败后，蕾米莉亚决定再次发动红雾异变，但为了防止被灵梦退治，她决定将红雾以奇怪的阵势释放。\n\n我们将幻想乡看做是一个 $n \\times m$ 的方格地区，一开始没有任何一个地区被红雾遮盖。蕾米莉亚每次站在某一个地区上，向东南西北四个方向各发出一条无限长的红雾，可以影响到整行/整列，但不会影响到她所站的那个地区。如果两阵红雾碰撞，则会因为密度过大而沉降消失。灵梦察觉到了这次异变，决定去解决它。但在解决之前，灵梦想要了解一片范围红雾的密度。可以简述为两种操作:\n\n``1 x y`` 蕾米莉亚站在坐标 $(x,y)$ 的位置向四个方向释放无限长的红雾。\n\n``2 x1 y1 x2 y2`` 询问左上点为$(x1,y1)$，右下点为 $(x2,y2)$ 的矩形范围内，被红雾遮盖的地区的数量。", "inputFormat": "第一行三个整数 $n,m,q$，表示幻想乡大小为 $n \\times m$，有 $q$ 个询问。\n\n接下来 $q$ 行，每行 $3$ 个或 $5$ 个整数,用空格隔开，含义见题目描述。", "outputFormat": "对于每一个操作 $2$，输出一行一个整数，表示对应询问的答案。", "hint": "#### 样例输入输出 1 解释\n\n用``o``表示没有红雾，``x``表示有红雾，两次释放红雾后幻想乡地图如下:\n\n```\noxox\nxoxo\noxox\nxoxo\n```\n\n---\n\n#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，$1 \\le n,m,q \\le 200$。\n- 对于 $40\\%$ 的数据，$1 \\le n,m,q \\le 10^3$。\n- 对于 $100\\%$ 的数据，$1 \\le n,m,q \\le 10^5$，$1 \\le x_1,x_2,x \\le n$，$x_1 \\le x_2$，$1 \\le y_1,y_2,y \\le m$，$y_1 \\le y_2$。", "locale": "zh-CN"}}}
{"pid": "P3802", "type": "P", "difficulty": 4, "samples": [["1 1 1 1 1 1 1", "1.000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创", "排列组合", "期望", "洛谷比赛"], "title": "小魔女帕琪", "background": "从前有一个聪明的小魔女帕琪，兴趣是狩猎吸血鬼。\n\n帕琪能熟练使用七种属性（金、木、水、火、土、日、月）的魔法，除了能使用这么多种属性魔法外，她还能将两种以上属性组合，从而唱出强力的魔法。比如说为了加强攻击力而将火和木组合，为了掩盖弱点而将火和土组合等等，变化非常丰富。", "description": "现在帕琪与强大的夜之女王，吸血鬼蕾咪相遇了，夜之女王蕾咪具有非常强大的生命力，普通的魔法难以造成效果，只有终极魔法：帕琪七重奏才能对蕾咪造成伤害。帕琪七重奏的触发条件是：连续施放的 $7$ 个魔法中，如果魔法的属性各不相同，就能触发一次帕琪七重奏。\n\n请注意，无论前 $6$ 个魔法是否已经参与施放终极魔法，只要连续 $7$ 个魔法的属性各不相同，就会再触发一次终极魔法。例如，如果用序号来代表一种魔法，魔法的施放序列为 $1, 2, 3, 4, 5, 6,7, 1$，则前 $7$ 个魔法会触发一次终极魔法，后 $7$ 个魔法会再触发一次终极魔法。\n\n现在帕琪有 $7$ 种属性的能量晶体，第 $i$ 种晶体可以施放出属性为 $i$ 的魔法，共有 $a_i$ 个。每次施放魔法时，会等概率随机消耗一个现有的能量晶体，然后释放一个对应属性的魔法。\n\n现在帕琪想知道，她触发帕琪七重奏的期望次数是多少，可是她并不会算，于是找到了学 OI 的你。", "inputFormat": "输入只有一行 $7$ 个整数，第 $i$ 个整数代表 $a_i$。", "outputFormat": "输出一行一个实数代表答案，四舍五入保留三位小数。", "hint": "#### 样例输入输出 1 解释\n\n显然一定会触发一次帕琪七重奏。\n\n#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $\\sum_{i = 1}^7 a_i \\leq 10$。\n- 对于 $100\\%$ 的数据，保证 $0 \\leq a_i \\leq 10^9$，且 $\\sum_{i = 1}^7 a_i \\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "Little Witch Patchouli", "background": "Once upon a time, there was a clever little witch named Patchouli (Paqi), whose hobby was hunting vampires.\n\nPatchouli can skillfully use seven elemental magics: Metal, Wood, Water, Fire, Earth, Sun, and Moon. Besides using many elements, she can also combine two or more elements to cast powerful spells. For example, combining Fire and Wood to enhance attack power, or combining Fire and Earth to cover weaknesses. The variations are very rich.", "description": "Now Patchouli has encountered the powerful Queen of the Night, the vampire Remi. The Queen of the Night has extremely strong vitality, so ordinary magic has little effect. Only the ultimate spell, Patchouli's Septet, can deal damage to Remi. The trigger condition for Patchouli's Septet is: among any consecutive $7$ spells, if the attributes are all different, Patchouli's Septet is triggered once.\n\nPlease note that regardless of whether the previous $6$ spells have already been part of an ultimate cast, as long as any consecutive $7$ spells have pairwise different attributes, another ultimate is triggered. For example, if we use indices to represent attributes and the casting sequence is $1, 2, 3, 4, 5, 6, 7, 1$, then the first $7$ spells trigger the ultimate once, and the last $7$ spells trigger it once again.\n\nNow Patchouli has energy crystals of $7$ attributes. The $i$-th type of crystal can cast a spell of attribute $i$, and there are $a_i$ crystals in total. Each time a spell is cast, one of the existing energy crystals is consumed uniformly at random, and then a spell of the corresponding attribute is released.\n\nPatchouli wants to know the expected number of times she triggers Patchouli's Septet. She cannot compute it, so she turns to you, an OI student, for help.", "inputFormat": "A single line with $7$ integers. The $i$-th integer is $a_i$.", "outputFormat": "Output a single real number: the answer, rounded to three decimal places.", "hint": "- Sample 1 Explanation:\n  Obviously, Patchouli's Septet will be triggered once.\n\n- Constraints:\n  - For $30\\%$ of the testdata, it is guaranteed that $\\sum_{i = 1}^7 a_i \\leq 10$.\n  - For $100\\%$ of the testdata, it is guaranteed that $0 \\leq a_i \\leq 10^9$ and $\\sum_{i = 1}^7 a_i \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小魔女帕琪", "background": "从前有一个聪明的小魔女帕琪，兴趣是狩猎吸血鬼。\n\n帕琪能熟练使用七种属性（金、木、水、火、土、日、月）的魔法，除了能使用这么多种属性魔法外，她还能将两种以上属性组合，从而唱出强力的魔法。比如说为了加强攻击力而将火和木组合，为了掩盖弱点而将火和土组合等等，变化非常丰富。", "description": "现在帕琪与强大的夜之女王，吸血鬼蕾咪相遇了，夜之女王蕾咪具有非常强大的生命力，普通的魔法难以造成效果，只有终极魔法：帕琪七重奏才能对蕾咪造成伤害。帕琪七重奏的触发条件是：连续施放的 $7$ 个魔法中，如果魔法的属性各不相同，就能触发一次帕琪七重奏。\n\n请注意，无论前 $6$ 个魔法是否已经参与施放终极魔法，只要连续 $7$ 个魔法的属性各不相同，就会再触发一次终极魔法。例如，如果用序号来代表一种魔法，魔法的施放序列为 $1, 2, 3, 4, 5, 6,7, 1$，则前 $7$ 个魔法会触发一次终极魔法，后 $7$ 个魔法会再触发一次终极魔法。\n\n现在帕琪有 $7$ 种属性的能量晶体，第 $i$ 种晶体可以施放出属性为 $i$ 的魔法，共有 $a_i$ 个。每次施放魔法时，会等概率随机消耗一个现有的能量晶体，然后释放一个对应属性的魔法。\n\n现在帕琪想知道，她触发帕琪七重奏的期望次数是多少，可是她并不会算，于是找到了学 OI 的你。", "inputFormat": "输入只有一行 $7$ 个整数，第 $i$ 个整数代表 $a_i$。", "outputFormat": "输出一行一个实数代表答案，四舍五入保留三位小数。", "hint": "#### 样例输入输出 1 解释\n\n显然一定会触发一次帕琪七重奏。\n\n#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $\\sum_{i = 1}^7 a_i \\leq 10$。\n- 对于 $100\\%$ 的数据，保证 $0 \\leq a_i \\leq 10^9$，且 $\\sum_{i = 1}^7 a_i \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3803", "type": "P", "difficulty": 6, "samples": [["1 2\n1 2\n1 2 1", "1 4 5 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["递归", "O2优化", "向量", "快速傅里叶变换 FFT", "快速数论变换 NTT", "模板题"], "title": "【模板】多项式乘法（FFT）", "background": "这是一道多项式乘法模板题。\n\n注意：本题并不属于中国计算机学会划定的提高组知识点考察范围。", "description": "给定一个 $n$ 次多项式 $F(x)$，和一个 $m$ 次多项式 $G(x)$。\n\n请求出 $F(x)$ 和 $G(x)$ 的乘积。", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来一行 $n+1$ 个整数，从低到高表示 $F(x)$ 的系数。\n\n接下来一行 $m+1$ 个整数，从低到高表示 $G(x)$ 的系数。", "outputFormat": "一行 $n+m+1$ 个整数，从低到高表示 $F(x) \\cdot G(x)$ 的系数。", "hint": "保证输入中的系数均为大于等于 $0$ 且小于等于 $9$ 的整数。\n\n对于 $100\\%$ 的数据：$1 \\le n, m \\leq {10}^6$。", "locale": "zh-CN", "translations": {"en": {"title": "【Template】Polynomial Multiplication (FFT)", "background": "This is a template problem for polynomial multiplication.\n\nNote: This problem is not within the CCF-defined Senior knowledge points.", "description": "Given a degree $n$ polynomial $F(x)$ and a degree $m$ polynomial $G(x)$, compute the product $F(x)$ and $G(x)$.", "inputFormat": "The first line contains two integers $n, m$.\n\nThe next line contains $n+1$ integers, representing the coefficients of $F(x)$ from lowest degree to highest.\n\nThe next line contains $m+1$ integers, representing the coefficients of $G(x)$ from lowest degree to highest.", "outputFormat": "Output one line containing $n+m+1$ integers, representing the coefficients of $F(x) \\cdot G(x)$ from lowest degree to highest.", "hint": "It is guaranteed that all input coefficients are integers between $0$ and $9$ inclusive.\n\nFor $100\\%$ of the testdata: $1 \\le n, m \\leq {10}^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】多项式乘法（FFT）", "background": "这是一道多项式乘法模板题。\n\n注意：本题并不属于中国计算机学会划定的提高组知识点考察范围。", "description": "给定一个 $n$ 次多项式 $F(x)$，和一个 $m$ 次多项式 $G(x)$。\n\n请求出 $F(x)$ 和 $G(x)$ 的乘积。", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来一行 $n+1$ 个整数，从低到高表示 $F(x)$ 的系数。\n\n接下来一行 $m+1$ 个整数，从低到高表示 $G(x)$ 的系数。", "outputFormat": "一行 $n+m+1$ 个整数，从低到高表示 $F(x) \\cdot G(x)$ 的系数。", "hint": "保证输入中的系数均为大于等于 $0$ 且小于等于 $9$ 的整数。\n\n对于 $100\\%$ 的数据：$1 \\le n, m \\leq {10}^6$。", "locale": "zh-CN"}}}
{"pid": "P3804", "type": "P", "difficulty": 6, "samples": [["abab", "4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["字符串", "后缀自动机 SAM", "O2优化", "后缀数组 SA", "模板题"], "title": "【模板】后缀自动机（SAM）", "background": "", "description": "给定一个只包含小写字母的字符串 $S$。\n\n请你求出 $S$ 的所有出现次数不为 $1$ 的子串的出现次数乘上该子串长度的最大值。\n", "inputFormat": "一行一个仅包含小写字母的字符串 $S$。", "outputFormat": "一个整数，为所求答案。", "hint": "对于 $10 \\%$ 的数据，$\\lvert S \\rvert \\le 1000$。  \n对于 $100\\% $的数据，$1 \\le \\lvert S \\rvert \\le {10}^6$。\n\n- 2023.7.30：添加一组 hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "【Template】Suffix Automaton (SAM)", "background": "", "description": "Given a string $S$ consisting only of lowercase letters.\n\nPlease find the maximum value of (occurrence count of a substring) multiplied by (the length of that substring) over all substrings of $S$ whose occurrence count is not $1$.", "inputFormat": "One line containing a string $S$ consisting only of lowercase letters.", "outputFormat": "A single integer, the required answer.", "hint": "Constraints:\n- For $10\\%$ of the testdata, $\\lvert S \\rvert \\le 1000$.\n- For $100\\%$ of the testdata, $1 \\le \\lvert S \\rvert \\le {10}^6$.\n\n- 2023.7.30: Added a set of hack testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】后缀自动机（SAM）", "background": "", "description": "给定一个只包含小写字母的字符串 $S$。\n\n请你求出 $S$ 的所有出现次数不为 $1$ 的子串的出现次数乘上该子串长度的最大值。\n", "inputFormat": "一行一个仅包含小写字母的字符串 $S$。", "outputFormat": "一个整数，为所求答案。", "hint": "对于 $10 \\%$ 的数据，$\\lvert S \\rvert \\le 1000$。  \n对于 $100\\% $的数据，$1 \\le \\lvert S \\rvert \\le {10}^6$。\n\n- 2023.7.30：添加一组 hack 数据。", "locale": "zh-CN"}}}
{"pid": "P3805", "type": "P", "difficulty": 5, "samples": [["aaa", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "O2优化", "Manacher 算法", "模板题"], "title": "【模板】Manacher", "background": null, "description": "给出一个只由小写英文字符 $\\texttt a,\\texttt b,\\texttt c,\\ldots\\texttt y,\\texttt z$ 组成的字符串 $S$ ,求 $S$ 中最长回文串的长度 。\n\n字符串长度为 $n$。", "inputFormat": "一行小写英文字符 $\\texttt a,\\texttt b,\\texttt c,\\cdots,\\texttt y,\\texttt z$ 组成的字符串 $S$。", "outputFormat": "一个整数表示答案。", "hint": "$1\\le n\\le 1.1\\times 10^7$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Manacher", "background": "", "description": "Given a string $S$ consisting only of lowercase English letters $\\texttt a,\\texttt b,\\texttt c,\\ldots\\texttt y,\\texttt z$, find the length of the longest palindromic substring in $S$.\n\nThe length of the string is $n$.", "inputFormat": "One line containing a string $S$ consisting of lowercase English letters $\\texttt a,\\texttt b,\\texttt c,\\cdots,\\texttt y,\\texttt z$.", "outputFormat": "Output a single integer representing the answer.", "hint": "$1 \\le n \\le 1.1 \\times 10^7$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】Manacher", "background": null, "description": "给出一个只由小写英文字符 $\\texttt a,\\texttt b,\\texttt c,\\ldots\\texttt y,\\texttt z$ 组成的字符串 $S$ ,求 $S$ 中最长回文串的长度 。\n\n字符串长度为 $n$。", "inputFormat": "一行小写英文字符 $\\texttt a,\\texttt b,\\texttt c,\\cdots,\\texttt y,\\texttt z$ 组成的字符串 $S$。", "outputFormat": "一个整数表示答案。", "hint": "$1\\le n\\le 1.1\\times 10^7$。", "locale": "zh-CN"}}}
{"pid": "P3806", "type": "P", "difficulty": 5, "samples": [["2 1\n1 2 2\n2", "AYE"]], "limits": {"time": [200, 200, 200, 200, 200, 200, 200, 200, 200, 200], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["点分治", "O2优化", "分治", "深度优先搜索 DFS", "模板题"], "title": "【模板】点分治", "background": "感谢 hzwer 的点分治互测。", "description": "给定一棵有 $n$ 个点的树，询问树上距离为 $k$ 的点对是否存在。", "inputFormat": "第一行两个数 $n,m$。\n\n第 $2$ 到第 $n$ 行，每行三个整数 $u, v, w$，代表树上存在一条连接 $u$ 和 $v$ 边权为 $w$ 的路径。\n\n接下来 $m$ 行，每行一个整数 $k$，代表一次询问。", "outputFormat": "对于每次询问输出一行一个字符串代表答案，存在输出 `AYE`，否则输出 `NAY`。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n\\leq 100$。\n- 对于 $60\\%$ 的数据，保证 $n\\leq 1000$，$m\\leq 50$ 。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n\\leq 10^4$，$1 \\leq m\\leq 100$，$1 \\leq k \\leq 10^7$，$1 \\leq u, v \\leq n$，$1 \\leq w \\leq 10^4$。\n\n#### 提示\n\n- **本题不卡常**。\n- 如果您 #7 一直 RE/TLE，不妨看看 [这个帖子](https://www.luogu.com.cn/discuss/show/188596)。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Centroid Decomposition", "background": "Thanks to hzwer for the centroid decomposition cross-testing.", "description": "Given a tree with $n$ nodes, determine for each query whether there exists a pair of nodes whose distance on the tree equals $k$.", "inputFormat": "The first line contains two integers $n, m$.\n\nThe next $n-1$ lines, each contains three integers $u, v, w$, representing an edge between $u$ and $v$ with weight $w$.\n\nThen $m$ lines follow, each containing one integer $k$, representing a query.", "outputFormat": "For each query, output one line with a string representing the answer. Output `AYE` if such a pair exists, otherwise output `NAY`.", "hint": "#### Constraints\n\n- For $30\\%$ of the testdata, $n \\leq 100$ is guaranteed.\n- For $60\\%$ of the testdata, $n \\leq 1000$, $m \\leq 50$ are guaranteed.\n- For $100\\%$ of the testdata, $1 \\leq n \\leq 10^4$, $1 \\leq m \\leq 100$, $1 \\leq k \\leq 10^7$, $1 \\leq u, v \\leq n$, $1 \\leq w \\leq 10^4$ are guaranteed.\n\n#### Notes\n\n- This problem does not stress constant factors.\n- If test point #7 keeps RE/TLE, consider checking this post: https://www.luogu.com.cn/discuss/show/188596.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】点分治", "background": "感谢 hzwer 的点分治互测。", "description": "给定一棵有 $n$ 个点的树，询问树上距离为 $k$ 的点对是否存在。", "inputFormat": "第一行两个数 $n,m$。\n\n第 $2$ 到第 $n$ 行，每行三个整数 $u, v, w$，代表树上存在一条连接 $u$ 和 $v$ 边权为 $w$ 的路径。\n\n接下来 $m$ 行，每行一个整数 $k$，代表一次询问。", "outputFormat": "对于每次询问输出一行一个字符串代表答案，存在输出 `AYE`，否则输出 `NAY`。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n\\leq 100$。\n- 对于 $60\\%$ 的数据，保证 $n\\leq 1000$，$m\\leq 50$ 。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n\\leq 10^4$，$1 \\leq m\\leq 100$，$1 \\leq k \\leq 10^7$，$1 \\leq u, v \\leq n$，$1 \\leq w \\leq 10^4$。\n\n#### 提示\n\n- **本题不卡常**。\n- 如果您 #7 一直 RE/TLE，不妨看看 [这个帖子](https://www.luogu.com.cn/discuss/show/188596)。", "locale": "zh-CN"}}}
{"pid": "P3807", "type": "P", "difficulty": 5, "samples": [["2\n1 2 5\n2 1 5", "3\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递归", "素数判断,质数,筛法", "进制", "组合数学", "逆元", "Lucas 定理", "模板题"], "title": "【模板】卢卡斯定理 / Lucas 定理", "background": "这是一道模板题。\n", "description": "给定整数 $n, m, p$ 的值，求出 $C_{n + m}^n \\bmod p$ 的值。\n\n输入数据保证 $p$ 为质数。\n\n注: $C$ 表示组合数。", "inputFormat": "**本题有多组数据**。\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据: \n\n一行，三个整数 $n, m, p$。", "outputFormat": "对于每组数据，输出一行，一个整数，表示所求的值。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n, m, p \\leq 10^5$，$1 \\leq T \\leq 10$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Lucas Theorem", "background": "This is a template problem.", "description": "Given integers $n, m, p$, compute $C_{n + m}^n \\bmod p$.\n\nThe input guarantees that $p$ is prime.\n\nNote: $C$ denotes the binomial coefficient.", "inputFormat": "This problem contains multiple test cases.\n\nThe first line contains an integer $T$, the number of test cases.\n\nFor each test case:\n\nOne line with three integers $n, m, p$.", "outputFormat": "For each test case, output one line with one integer, the required value.", "hint": "For $100\\%$ of the testdata, $1 \\leq n, m, p \\leq 10^5$, $1 \\leq T \\leq 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】卢卡斯定理 / Lucas 定理", "background": "这是一道模板题。\n", "description": "给定整数 $n, m, p$ 的值，求出 $C_{n + m}^n \\bmod p$ 的值。\n\n输入数据保证 $p$ 为质数。\n\n注: $C$ 表示组合数。", "inputFormat": "**本题有多组数据**。\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据: \n\n一行，三个整数 $n, m, p$。", "outputFormat": "对于每组数据，输出一行，一个整数，表示所求的值。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n, m, p \\leq 10^5$，$1 \\leq T \\leq 10$。", "locale": "zh-CN"}}}
{"pid": "P3808", "type": "P", "difficulty": 5, "samples": [["3\na\naa\naa\naaa", "3"], ["4\na\nab\nac\nabc\nabcd", "3"], ["2\na\naa\naa", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "O2优化", "AC 自动机"], "title": "AC 自动机（简单版）", "background": null, "description": "给定 $n$ 个模式串 $s_i$ 和一个文本串 $t$，求有多少个不同的模式串在文本串里出现过。  \n两个模式串不同当且仅当他们**编号**不同。", "inputFormat": "第一行是一个整数，表示模式串的个数 $n$。  \n第 $2$ 到第 $(n + 1)$ 行，每行一个字符串，第 $(i + 1)$ 行的字符串表示编号为 $i$ 的模式串 $s_i$。  \n最后一行是一个字符串，表示文本串 $t$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "### 样例 1 解释\n\n$s_2$ 与 $s_3$ 编号（下标）不同，因此各自对答案产生了一次贡献。\n\n### 样例 2 解释\n\n$s_1$，$s_2$，$s_4$ 都在串 `abcd` 里出现过。\n\n### 数据规模与约定\n\n- 对于 $10\\%$ 的数据，保证 $n = 1$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^6$，$1 \\leq |t| \\leq 10^6$，$1 \\leq \\sum\\limits_{i = 1}^n |s_i| \\leq 10^6$。$s_i, t$ 中仅包含小写字母。", "locale": "zh-CN", "translations": {"en": {"title": "AC Automaton (Simple Version)", "background": "", "description": "Given $n$ pattern strings $s_i$ and a text string $t$, count how many distinct pattern strings appear in the text. Two pattern strings are different if and only if their indices are different.", "inputFormat": "The first line contains an integer $n$, the number of pattern strings.  \nLines $2$ to $(n + 1)$ each contain one string; the string on line $(i + 1)$ is the pattern string $s_i$ with index $i$.  \nThe last line contains a string, the text string $t$.", "outputFormat": "Output a single integer on one line, which is the answer.", "hint": "### Sample 1 Explanation\n\n$s_2$ and $s_3$ have different indices, so each contributes once to the answer.\n\n### Sample 2 Explanation\n\n$s_1$, $s_2$, and $s_4$ all appear in the string `abcd`.\n\n### Constraints\n\n- For $10\\%$ of the testdata, it is guaranteed that $n = 1$.\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 10^6$, $1 \\leq |t| \\leq 10^6$, $1 \\leq \\sum\\limits_{i = 1}^n |s_i| \\leq 10^6$. $s_i, t$ contain only lowercase letters.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "AC 自动机（简单版）", "background": null, "description": "给定 $n$ 个模式串 $s_i$ 和一个文本串 $t$，求有多少个不同的模式串在文本串里出现过。  \n两个模式串不同当且仅当他们**编号**不同。", "inputFormat": "第一行是一个整数，表示模式串的个数 $n$。  \n第 $2$ 到第 $(n + 1)$ 行，每行一个字符串，第 $(i + 1)$ 行的字符串表示编号为 $i$ 的模式串 $s_i$。  \n最后一行是一个字符串，表示文本串 $t$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "### 样例 1 解释\n\n$s_2$ 与 $s_3$ 编号（下标）不同，因此各自对答案产生了一次贡献。\n\n### 样例 2 解释\n\n$s_1$，$s_2$，$s_4$ 都在串 `abcd` 里出现过。\n\n### 数据规模与约定\n\n- 对于 $10\\%$ 的数据，保证 $n = 1$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^6$，$1 \\leq |t| \\leq 10^6$，$1 \\leq \\sum\\limits_{i = 1}^n |s_i| \\leq 10^6$。$s_i, t$ 中仅包含小写字母。", "locale": "zh-CN"}}}
{"pid": "P3809", "type": "P", "difficulty": 6, "samples": [["ababa", "5 3 1 4 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["字符串", "O2优化", "排序", "后缀数组 SA", "模板题"], "title": "【模板】后缀排序", "background": "这是一道模板题。\n", "description": "读入一个长度为 $ n $ 的由大小写英文字母或数字组成的字符串，请把这个字符串的所有非空后缀按字典序（用 ASCII 数值比较）从小到大排序，然后按顺序输出后缀的第一个字符在原串中的位置。位置编号为 $ 1 $ 到 $ n $。\n", "inputFormat": "一行一个长度为 $ n $ 的仅包含大小写英文字母或数字的字符串。\n", "outputFormat": "一行，共 $n$ 个整数，表示答案。\n", "hint": "$1\\le n \\le 10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Suffix Sorting", "background": "This is a template problem.", "description": "Read a string of length $ n $ consisting of uppercase and lowercase English letters or digits. Sort all its non-empty suffixes in ascending lexicographic order (compared by ASCII values), then output, in that order, the position in the original string of the first character of each suffix. Positions are numbered from $ 1 $ to $ n $.", "inputFormat": "A single line containing a string of length $ n $ consisting only of uppercase and lowercase English letters or digits.", "outputFormat": "One line containing $ n $ integers representing the answer.", "hint": "$ 1 \\le n \\le 10^6 $.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】后缀排序", "background": "这是一道模板题。\n", "description": "读入一个长度为 $ n $ 的由大小写英文字母或数字组成的字符串，请把这个字符串的所有非空后缀按字典序（用 ASCII 数值比较）从小到大排序，然后按顺序输出后缀的第一个字符在原串中的位置。位置编号为 $ 1 $ 到 $ n $。\n", "inputFormat": "一行一个长度为 $ n $ 的仅包含大小写英文字母或数字的字符串。\n", "outputFormat": "一行，共 $n$ 个整数，表示答案。\n", "hint": "$1\\le n \\le 10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P3810", "type": "P", "difficulty": 6, "samples": [["10 3\n3 3 3\n2 3 3\n2 3 1\n3 1 1\n3 1 2\n1 3 1\n1 1 2\n1 2 2\n1 3 2\n1 2 1\n", "3\n1\n3\n0\n1\n0\n1\n0\n0\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["线段树", "树状数组", "cdq 分治", "O2优化", "分治", "排序", "树套树", "分块", "K-D Tree", "bitset", "模板题"], "title": "【模板】三维偏序 / 陌上花开", "background": "这是一道模板题，可以使用 bitset，CDQ 分治，树套树，KD-Tree 等方式解决。", "description": "有 $ n $ 个元素，第 $ i $ 个元素有 $ a_i,b_i,c_i $ 三个属性，设 $ f(i) $ 表示满足 $ a_j \\leq a_i $ 且 $ b_j \\leq b_i $ 且 $ c_j \\leq c_i $ 且 $ j \\ne i $ 的 $j$ 的数量。\n\n对于所有 $ d \\in [0, n) $，求 $ f(i) = d $ 的数量。", "inputFormat": "第一行两个整数 $ n,k $，表示元素数量和最大属性值。\n\n接下来 $ n $ 行，每行三个整数 $ a_i ,b_i,c_i $，分别表示三个属性值。", "outputFormat": "共 $ n $ 行，第 $ d + 1 $ 行表示 $ f(i) = d $ 的 $ i $ 的数量。", "hint": "对于所有数据，保证 $ 1 \\leq n \\leq 10^5$，$1 \\leq a_i, b_i, c_i \\le k \\leq 2 \\times 10^5 $。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Three-Dimensional Partial Order / Mo Shang Hua Kai", "background": "This is a template problem. You can solve it using bitset, CDQ divide-and-conquer, KD-tree, etc.", "description": "There are $ n $ elements. The $ i $-th element has three attributes $ a_i, b_i, c_i $. Let $ f(i) $ be the number of $ j $ such that $ a_j \\leq a_i $, $ b_j \\leq b_i $, $ c_j \\leq c_i $, and $ j \\ne i $.\n\nFor all $ d \\in [0, n) $, find the number of $ i $ such that $ f(i) = d $.", "inputFormat": "The first line contains two integers $ n,k $, denoting the number of elements and the maximum attribute value.\n\nThe next $ n $ lines each contain three integers $ a_i ,b_i,c_i $, representing the three attribute values.", "outputFormat": "Output $ n $ lines. The $ d + 1 $-th line contains the number of $ i $ such that $ f(i) = d $.", "hint": "For all testdata, it is guaranteed that $ 1 \\leq n \\leq 10^5$，$1 \\leq a_i, b_i, c_i \\le k \\leq 2 \\times 10^5 $.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】三维偏序 / 陌上花开", "background": "这是一道模板题，可以使用 bitset，CDQ 分治，树套树，KD-Tree 等方式解决。", "description": "有 $ n $ 个元素，第 $ i $ 个元素有 $ a_i,b_i,c_i $ 三个属性，设 $ f(i) $ 表示满足 $ a_j \\leq a_i $ 且 $ b_j \\leq b_i $ 且 $ c_j \\leq c_i $ 且 $ j \\ne i $ 的 $j$ 的数量。\n\n对于所有 $ d \\in [0, n) $，求 $ f(i) = d $ 的数量。", "inputFormat": "第一行两个整数 $ n,k $，表示元素数量和最大属性值。\n\n接下来 $ n $ 行，每行三个整数 $ a_i ,b_i,c_i $，分别表示三个属性值。", "outputFormat": "共 $ n $ 行，第 $ d + 1 $ 行表示 $ f(i) = d $ 的 $ i $ 的数量。", "hint": "对于所有数据，保证 $ 1 \\leq n \\leq 10^5$，$1 \\leq a_i, b_i, c_i \\le k \\leq 2 \\times 10^5 $。", "locale": "zh-CN"}}}
{"pid": "P3811", "type": "P", "difficulty": 3, "samples": [["10 13", "1\n7\n9\n10\n8\n11\n2\n5\n3\n4"]], "limits": {"time": [500, 500, 500, 500, 500, 500], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "递推", "O2优化", "素数判断,质数,筛法", "逆元", "模板题"], "title": "【模板】模意义下的乘法逆元", "background": "这是一道模板题。", "description": "给定正整数 $n,p$，求 $[1,n]$ 中所有整数在模 $p$ 意义下的乘法逆元。\n\n$a$ 模 $p$ 的乘法逆元定义为 $ax\\equiv1\\pmod p$ 的解。", "inputFormat": "一行两个正整数 $n,p$。", "outputFormat": "输出 $n$ 行，其中第 $i$ 行表示 $i$ 在模 $p$ 下的乘法逆元。", "hint": "所有数据满足 $ 1 \\leq n \\leq 3 \\times 10 ^ 6$，$n < p < 20000528 $。\n\n输入保证 $ p $ 为质数。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Modular Multiplicative Inverse", "background": "This is a template problem.", "description": "Given positive integers $n, p$, find the multiplicative inverses modulo $p$ for all integers in $[1, n]$.\n\nThe multiplicative inverse of $a$ modulo $p$ is defined as the solution $x$ to $ax\\equiv1\\pmod p$.", "inputFormat": "One line with two positive integers $n, p$.", "outputFormat": "Output $n$ lines, where the $i$-th line denotes the multiplicative inverse of $i$ modulo $p$.", "hint": "All testdata satisfy $ 1 \\leq n \\leq 3 \\times 10 ^ 6$, $n < p < 20000528 $.\nThe input guarantees that $ p $ is prime.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】模意义下的乘法逆元", "background": "这是一道模板题。", "description": "给定正整数 $n,p$，求 $[1,n]$ 中所有整数在模 $p$ 意义下的乘法逆元。\n\n$a$ 模 $p$ 的乘法逆元定义为 $ax\\equiv1\\pmod p$ 的解。", "inputFormat": "一行两个正整数 $n,p$。", "outputFormat": "输出 $n$ 行，其中第 $i$ 行表示 $i$ 在模 $p$ 下的乘法逆元。", "hint": "所有数据满足 $ 1 \\leq n \\leq 3 \\times 10 ^ 6$，$n < p < 20000528 $。\n\n输入保证 $ p $ 为质数。", "locale": "zh-CN"}}}
{"pid": "P3812", "type": "P", "difficulty": 5, "samples": [["2\n1 1", "1"], ["4\n1 5 9 4\n", "13\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "进制", "线性基", "模板题"], "title": "【模板】线性基", "background": "这是一道模板题。", "description": "给定 $n$ 个整数（数字可能重复），求在这些数中选取任意个，使得他们的异或和最大。", "inputFormat": "第一行一个数 $n$，表示元素个数。\n\n接下来一行 $n$ 个数。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "$1\\leq n\\leq 50$，$0\\leq S_i<2^{50}$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Linear Basis", "background": "This is a template problem.", "description": "Given $n$ integers (numbers may repeat), choose any subset of them so that their XOR sum is maximized.", "inputFormat": "The first line contains an integer $n$, the number of elements.\nThe next line contains $n$ integers.", "outputFormat": "Output a single integer on one line, the answer.", "hint": "Constraints: $1 \\leq n \\leq 50$, $0 \\leq S_i < 2^{50}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】线性基", "background": "这是一道模板题。", "description": "给定 $n$ 个整数（数字可能重复），求在这些数中选取任意个，使得他们的异或和最大。", "inputFormat": "第一行一个数 $n$，表示元素个数。\n\n接下来一行 $n$ 个数。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "$1\\leq n\\leq 50$，$0\\leq S_i<2^{50}$。", "locale": "zh-CN"}}}
{"pid": "P3813", "type": "P", "difficulty": 6, "samples": [["2\n3 3 2 2\n1 1 2 2 2\n2 2 3 3 1\n4 4 4 4\n1 1 2 3 3\n2 3 4 4 2\n2 1 4 3 2\n1 2 3 4 4", "28\n76475"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "各省省选", "离散化", "福建", "枚举", "容斥原理"], "title": "[FJOI2017] 矩阵填数", "background": "", "description": "给定一个 $h \\times w$ 的矩阵，矩阵的行编号从上到下依次为 $1 \\sim h$，列编号从左到右依次 $1 \\sim w$。\n\n在这个矩阵中你需要在每个格子中填入 $1 \\sim m$ 中的某个数。\n\n给这个矩阵填数的时候有一些限制，给定 $n$ 个该矩阵的子矩阵，以及该子矩阵的最大值 $v$，要求你所填的方案满足该子矩阵的最大值为 $v$。\n\n现在，你的任务是求出有多少种填数的方案满足 $n$ 个限制。\n\n两种方案是不一样的当且仅当两个方案至少存在一个格子上有不同的数。由于答案可能很大，你只需要输出答案对 $10 ^ 9 + 7$ 取模后的结果。", "inputFormat": "输入数据的第一行为一个数 $T$，表示数据组数。\n\n对于每组数据，第一行为四个数 $h,w,m,n$。\n\n接下来 $n$ 行，每一行描述一个子矩阵的最大值 v。每行为五个整数 $x1,y1,x2,y2,v$，表示一个左上角为$(x1,y1)$,右下角为$(x2,y2)$的子矩阵的最大值为 $v$。 $1 \\le x1 \\le x2 \\le h$, $1 \\le y1 \\le y2 \\le w$\n", "outputFormat": "对于每组数据输出一行，表示填数方案 mod $1,000,000,007$ 后的值。\n", "hint": "对于 $20\\%$ 的数据，$n \\le 2$。\n\n另有 $20\\%$ 的数据，$1 \\le h, w \\le 50$。\n\n对于 $100\\%$ 的数据，$T \\le 5$，$1 \\le h, w, m \\le 10 ^ 4$，$1 \\le n \\le 10$，$1 \\le v \\le m$。", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2017] Matrix Filling", "background": "", "description": "Given an $h \\times w$ matrix, the rows are numbered from top to bottom as $1 \\sim h$, and the columns are numbered from left to right as $1 \\sim w$.\n\nYou need to fill each cell in this matrix with a number from $1 \\sim m$.\n\nThere are some restrictions when filling the matrix. You are given $n$ submatrices of this matrix and the maximum value $v$ for each submatrix. Your filling must satisfy that the maximum value of each given submatrix is $v$.\n\nNow, your task is to find how many fillings satisfy the $n$ constraints.\n\nTwo fillings are different if and only if there exists at least one cell where the numbers differ between the two fillings. Since the answer may be large, you only need to output the result modulo $10 ^ 9 + 7$.", "inputFormat": "The first line of the input contains an integer $T$, the number of test cases.\n\nFor each test case, the first line contains four integers $h,w,m,n$.\n\nThen follow $n$ lines, each describing the maximum value $v$ of a submatrix. Each line contains five integers $x1,y1,x2,y2,v$, indicating that the submatrix with top-left corner $(x1,y1)$ and bottom-right corner $(x2,y2)$ has a maximum value of $v$. $1 \\le x1 \\le x2 \\le h$, $1 \\le y1 \\le y2 \\le w$.", "outputFormat": "For each test case, output one line: the number of valid fillings modulo $1,000,000,007$.", "hint": "For $20\\%$ of the testdata, $n \\le 2$.\n\nFor another $20\\%$ of the data, $1 \\le h, w \\le 50$.\n\nFor $100\\%$ of the data, $T \\le 5$, $1 \\le h, w, m \\le 10 ^ 4$, $1 \\le n \\le 10$, $1 \\le v \\le m$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2017] 矩阵填数", "background": "", "description": "给定一个 $h \\times w$ 的矩阵，矩阵的行编号从上到下依次为 $1 \\sim h$，列编号从左到右依次 $1 \\sim w$。\n\n在这个矩阵中你需要在每个格子中填入 $1 \\sim m$ 中的某个数。\n\n给这个矩阵填数的时候有一些限制，给定 $n$ 个该矩阵的子矩阵，以及该子矩阵的最大值 $v$，要求你所填的方案满足该子矩阵的最大值为 $v$。\n\n现在，你的任务是求出有多少种填数的方案满足 $n$ 个限制。\n\n两种方案是不一样的当且仅当两个方案至少存在一个格子上有不同的数。由于答案可能很大，你只需要输出答案对 $10 ^ 9 + 7$ 取模后的结果。", "inputFormat": "输入数据的第一行为一个数 $T$，表示数据组数。\n\n对于每组数据，第一行为四个数 $h,w,m,n$。\n\n接下来 $n$ 行，每一行描述一个子矩阵的最大值 v。每行为五个整数 $x1,y1,x2,y2,v$，表示一个左上角为$(x1,y1)$,右下角为$(x2,y2)$的子矩阵的最大值为 $v$。 $1 \\le x1 \\le x2 \\le h$, $1 \\le y1 \\le y2 \\le w$\n", "outputFormat": "对于每组数据输出一行，表示填数方案 mod $1,000,000,007$ 后的值。\n", "hint": "对于 $20\\%$ 的数据，$n \\le 2$。\n\n另有 $20\\%$ 的数据，$1 \\le h, w \\le 50$。\n\n对于 $100\\%$ 的数据，$T \\le 5$，$1 \\le h, w, m \\le 10 ^ 4$，$1 \\le n \\le 10$，$1 \\le v \\le m$。", "locale": "zh-CN"}}}
{"pid": "P3814", "type": "P", "difficulty": 7, "samples": [["10\nI 1 0\nI 2 1\nI 3 1\nQ 1 3\nI 4 3\nQ 1 4\nR 2 4\nQ 1 4\nM 3 4\nQ 2 7", "0\n2\n2\n6"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "各省省选", "福建"], "title": "[FJOI2017] 远古山脉问题", "background": null, "description": "远古山脉可以看作是一个由山脉元素组成的序列，每个元素有一个高度，远古山脉的变化规则如下：\n\n1. `I h x`：在第 $x$ 个山脉元素右边插入高度为 $h$ 的山脉元素。\n\n2. `R l r`：从第 $l$ 个山脉元素到第 $r$ 个山脉元素的高度翻转，例如，$a_1,a_2,a_3,a_4,a_5$，对 $[2,5]$ 翻转就变为 $a_1,a_5,a_4,a_3,a_2$。\n\n3. `M t x`：在第 $x$ 个山脉元素右边插入第 $t$ 个山脉。\n\n山脉元素按从左到右的顺序从 $1$ 开始编号。一开始时没有山脉元素，记为第 $0$ 个山脉。对于第 $i$ 个山脉，经过任意一种变化后就变成第 $i+1$ 个山脉。山脉中会收集山脉能量，假设山脉中最高的山脉元素的编号为 $x$，如果有 $m$ 个相同的高度，取左数第$\\left \\lceil \\dfrac{m}{2} \\right \\rceil$个元素，那么山脉收集的能量为:\n\n$$\\sum_{i=l}^{x-1}\\left\\{\\begin{matrix} x-i & ,\\ h_{i}>h_{i+1}\\\\ 0 & ,\\ h_{i}\\leq h_{i+1} \\end{matrix}\\right.+\\sum_{i=x+1}^{r}\\left\\{\\begin{matrix} i-x & ,\\ h_{i}>h_{i-1}\\\\ 0 & ,\\ h_{i}\\leq h_{i-1} \\end{matrix}\\right.$$\n\n其中 $h_i$ 代表第 $i$ 个山脉元素的高度。\n\n山脉序列问题需要回答的基本询问是：从第 $l$ 个山脉元素到第 $r$ 个山脉元素组成子山脉能收集的能量是多少？", "inputFormat": "文件的第一行有一个正整数 $n$（$n\\le 50000$），表示山脉变化和询问的总次数。\n\n接下来 $n$ 行，每行是四种格式之一：\n\n1. `I h x`: 在第 $x$ 个山脉元素右边插入高度为 $h$ 的山脉元素，$0\\le h\\le 20000$。\n\n2. `R l r`: 从第 $l$ 个山脉元素到第 $r$ 个山脉元素的高度翻转。\n\n3. `M t x`: 在第 $x$ 个山脉元素右边插入第 $t$ 个山脉。\n\n4. `Q l r`: 询问由第 $l$ 个山脉元素到第 $r$ 个山脉元素组成子山脉能收集的能量是多少。\n\n对于第 $i$ 个山脉，经过任意一种变化后就变成第 $i+1$ 个山脉。\n\n保证以上所有输入整数在 C++ 的 `long long` 范围内。", "outputFormat": "对于每个询问，输出一行答案，答案对 $10^9+7$ 取模。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2017] Ancient Mountain Range Problem", "background": "", "description": "An ancient mountain range can be regarded as a sequence of mountain elements, each with a height. The evolution rules are as follows:\n\n1. I h x: Insert a mountain element of height $h$ to the right of the $x$-th mountain element.\n2. R l r: Reverse the heights of the mountain elements from the $l$-th to the $r$-th. For example, $a_1,a_2,a_3,a_4,a_5$, reversing $(2,5)$ becomes $a_1,a_5,a_4,a_3,a_2$.\n3. M t x: Insert the $t$-th mountain to the right of the $x$-th mountain element.\n\nMountain elements are numbered from $1$ from left to right. Initially there are no mountain elements, denoted as the $0$-th mountain. For the $i$-th mountain, after applying any one operation it becomes the $(i+1)$-th mountain. The mountain collects energy as follows: suppose the index of the highest mountain element is $x$. If there are $m$ elements with the same maximum height, take the $\\left \\lceil \\frac{m}{2} \\right \\rceil$-th one from the left. Then the collected energy is:\n$$\\sum_{i=l}^{x-1}\\left\\{\\begin{matrix} x-i & if\\ h_{i}>h_{i+1}\\\\ 0 & if\\ h_{i}\\leq h_{i+1} \\end{matrix}\\right.+\\sum_{i=x+1}^{r}\\left\\{\\begin{matrix} i-x & if\\ h_{i}>h_{i-1}\\\\ 0 & if\\ h_{i}\\leq h_{i-1} \\end{matrix}\\right.$$\nHere $h_{i}$ denotes the height of the $i$-th mountain element.\n\nThe basic query to answer is: for the sub-mountain formed by the mountain elements from the $l$-th to the $r$-th, how much energy can be collected?", "inputFormat": "The first line contains a positive integer $n$ ($n\\le 50000$), the total number of operations and queries.\n\nThen follow $n$ lines, each in one of the following four formats:\n\n1. I h x: Insert a mountain element of height $h$ to the right of the $x$-th mountain element, $0\\le h\\le 20000$.\n2. R l r: Reverse the heights from the $l$-th mountain element to the $r$-th mountain element.\n3. M t x: Insert the $t$-th mountain to the right of the $x$-th mountain element.\n4. Q l r: Query the energy collected by the sub-mountain formed by the $l$-th to the $r$-th mountain elements.\n\nFor the $i$-th mountain, after applying any one operation it becomes the $(i+1)$-th mountain.\n\nAll input integers fit in the range of long long.", "outputFormat": "For each query, output the answer on one line, modulo 1000000007.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2017] 远古山脉问题", "background": null, "description": "远古山脉可以看作是一个由山脉元素组成的序列，每个元素有一个高度，远古山脉的变化规则如下：\n\n1. `I h x`：在第 $x$ 个山脉元素右边插入高度为 $h$ 的山脉元素。\n\n2. `R l r`：从第 $l$ 个山脉元素到第 $r$ 个山脉元素的高度翻转，例如，$a_1,a_2,a_3,a_4,a_5$，对 $[2,5]$ 翻转就变为 $a_1,a_5,a_4,a_3,a_2$。\n\n3. `M t x`：在第 $x$ 个山脉元素右边插入第 $t$ 个山脉。\n\n山脉元素按从左到右的顺序从 $1$ 开始编号。一开始时没有山脉元素，记为第 $0$ 个山脉。对于第 $i$ 个山脉，经过任意一种变化后就变成第 $i+1$ 个山脉。山脉中会收集山脉能量，假设山脉中最高的山脉元素的编号为 $x$，如果有 $m$ 个相同的高度，取左数第$\\left \\lceil \\dfrac{m}{2} \\right \\rceil$个元素，那么山脉收集的能量为:\n\n$$\\sum_{i=l}^{x-1}\\left\\{\\begin{matrix} x-i & ,\\ h_{i}>h_{i+1}\\\\ 0 & ,\\ h_{i}\\leq h_{i+1} \\end{matrix}\\right.+\\sum_{i=x+1}^{r}\\left\\{\\begin{matrix} i-x & ,\\ h_{i}>h_{i-1}\\\\ 0 & ,\\ h_{i}\\leq h_{i-1} \\end{matrix}\\right.$$\n\n其中 $h_i$ 代表第 $i$ 个山脉元素的高度。\n\n山脉序列问题需要回答的基本询问是：从第 $l$ 个山脉元素到第 $r$ 个山脉元素组成子山脉能收集的能量是多少？", "inputFormat": "文件的第一行有一个正整数 $n$（$n\\le 50000$），表示山脉变化和询问的总次数。\n\n接下来 $n$ 行，每行是四种格式之一：\n\n1. `I h x`: 在第 $x$ 个山脉元素右边插入高度为 $h$ 的山脉元素，$0\\le h\\le 20000$。\n\n2. `R l r`: 从第 $l$ 个山脉元素到第 $r$ 个山脉元素的高度翻转。\n\n3. `M t x`: 在第 $x$ 个山脉元素右边插入第 $t$ 个山脉。\n\n4. `Q l r`: 询问由第 $l$ 个山脉元素到第 $r$ 个山脉元素组成子山脉能收集的能量是多少。\n\n对于第 $i$ 个山脉，经过任意一种变化后就变成第 $i+1$ 个山脉。\n\n保证以上所有输入整数在 C++ 的 `long long` 范围内。", "outputFormat": "对于每个询问，输出一行答案，答案对 $10^9+7$ 取模。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3815", "type": "P", "difficulty": 0, "samples": [["5\n1 9 3 9 1\n1 3 9 3 1\n4\n1 9 3 9\n1 3 9 3\n0", "3\n1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "2017", "各省省选", "福建"], "title": "[FJOI2017] 回文子序列问题", "background": "", "description": "设 X 和 Y 是2个给定的正整数序列 $X=( x_1 , x_2 ,\\cdots, x_m )$和$Y=( y_1, y_2 ,\\cdots, y_n )$。\n\nX 和 Y的一个公共子序列是指X 和 Y的一个公共子序列$(x_{i1}=y_{j1},x_{i2}=y_{j2},\\cdots,x_{it}=y_{jt})$, 其中 $i1<i2<\\cdots<it$ 。\n\n当一个序列正读和反读都相同时，称该序列是回文。例如，序列$(1,3,5,3,1)$就是回文。 X 和 Y的一个公共回文子序列是指X 和 Y的一个公共子序列，且该子序列是回文。 在X 和 Y的所有公共回文子序列中，长度最长的就称为X 和 Y的一个最长公共回文子序列。在一般情况下， X 和 Y会有多个最长公共回文子\n\n序列。例如，对于给定的正整数序列$X=(1,9,3,9,1)$ 和 $Y=(1,3,9,3,1)$，其子序列$(1,3,1)$和$(1,9,1)$都是X 和 Y的最长公共回文子序列。\n\n我们的问题是，对于给定的正整数序列X 和 Y，确定其最长公共回文子序列的长度。\n\n对于给定的2个正整数序列$X=( x_1 , x_2 ,\\cdots, x_n )$和$Y=( y_1 , y_2 ,\\cdots, y_n )$，计算出它们的最长公共回文子序列的长度。\n", "inputFormat": "文件有多个测试项（$ \\le 10$）。每个测试项的第一行有1个正整数$n$， ($1\\le n\\le 500$)，表示2个输入序列X和Y的长度均为$n$。接下来的2行分别给出输入正整数序列$X=(x_1,x_2,\\cdots,x_n)$和$Y=(y_1,y_2,\\cdots, y_n)$。其中序列中每个元素均为正整数（ $\\le 20000$）。文件最后以一个0结束。\n", "outputFormat": "将计算出的每个测试项的最长公共回文子序列的长度依次输出到文件中， 每行输出一个长度。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2017] Palindromic Subsequence Problem", "background": "", "description": "Let X and Y be two given sequences of positive integers $X=( x_1 , x_2 ,\\cdots, x_m )$ and $Y=( y_1, y_2 ,\\cdots, y_n )$.\n\nA common subsequence of X and Y is a sequence $(x_{i1}=y_{j1},x_{i2}=y_{j2},\\cdots,x_{it}=y_{jt})$, where $i1<i2<\\cdots<it$ and $j1<j2<\\cdots<jt$.\n\nA sequence is called a palindrome if it reads the same forward and backward. For example, the sequence (1, 3, 5, 3, 1) is a palindrome. A common palindromic subsequence of X and Y is a common subsequence of X and Y that is also a palindrome. Among all common palindromic subsequences of X and Y, those with the maximum length are called a longest common palindromic subsequence (LCPS) of X and Y. In general, there may be multiple LCPSs. For example, for the given sequences $X=(1,9,3,9,1)$ and $Y=(1,3,9,3,1)$, the subsequences (1, 3, 1) and (1, 9, 1) are both LCPSs of X and Y.\n\nOur task is: given sequences X and Y, determine the length of a longest common palindromic subsequence.\n\nFor the given two sequences $X=( x_1 , x_2 ,\\cdots, x_n )$ and $Y=( y_1 , y_2 ,\\cdots, y_n )$, compute the length of their longest common palindromic subsequence.", "inputFormat": "The file contains multiple test cases ($ \\le 10$). For each test case, the first line contains a positive integer $n$ ($1\\le n\\le 500$), indicating that the lengths of the two input sequences X and Y are both $n$. The next two lines give the input sequences $X=(x_1,x_2,\\cdots,x_n)$ and $Y=(y_1,y_2,\\cdots, y_n)$, respectively. Each element in the sequences is a positive integer ($ \\le 20000$). The file ends with a 0.", "outputFormat": "For each test case, output the computed length of the longest common palindromic subsequence, one length per line.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2017] 回文子序列问题", "background": "", "description": "设 X 和 Y 是2个给定的正整数序列 $X=( x_1 , x_2 ,\\cdots, x_m )$和$Y=( y_1, y_2 ,\\cdots, y_n )$。\n\nX 和 Y的一个公共子序列是指X 和 Y的一个公共子序列$(x_{i1}=y_{j1},x_{i2}=y_{j2},\\cdots,x_{it}=y_{jt})$, 其中 $i1<i2<\\cdots<it$ 。\n\n当一个序列正读和反读都相同时，称该序列是回文。例如，序列$(1,3,5,3,1)$就是回文。 X 和 Y的一个公共回文子序列是指X 和 Y的一个公共子序列，且该子序列是回文。 在X 和 Y的所有公共回文子序列中，长度最长的就称为X 和 Y的一个最长公共回文子序列。在一般情况下， X 和 Y会有多个最长公共回文子\n\n序列。例如，对于给定的正整数序列$X=(1,9,3,9,1)$ 和 $Y=(1,3,9,3,1)$，其子序列$(1,3,1)$和$(1,9,1)$都是X 和 Y的最长公共回文子序列。\n\n我们的问题是，对于给定的正整数序列X 和 Y，确定其最长公共回文子序列的长度。\n\n对于给定的2个正整数序列$X=( x_1 , x_2 ,\\cdots, x_n )$和$Y=( y_1 , y_2 ,\\cdots, y_n )$，计算出它们的最长公共回文子序列的长度。\n", "inputFormat": "文件有多个测试项（$ \\le 10$）。每个测试项的第一行有1个正整数$n$， ($1\\le n\\le 500$)，表示2个输入序列X和Y的长度均为$n$。接下来的2行分别给出输入正整数序列$X=(x_1,x_2,\\cdots,x_n)$和$Y=(y_1,y_2,\\cdots, y_n)$。其中序列中每个元素均为正整数（ $\\le 20000$）。文件最后以一个0结束。\n", "outputFormat": "将计算出的每个测试项的最长公共回文子序列的长度依次输出到文件中， 每行输出一个长度。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3816", "type": "P", "difficulty": 6, "samples": [["1\n2\n3\n0", "1\n3\n5\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["字符串", "动态规划 DP", "2017", "各省省选", "福建", "枚举"], "title": "[FJOI2017] 树的平均路长问题", "background": "", "description": "一棵树 $T$ 的平均路长 $IPL(T)$定义为：\n\n$IPL(T)=\\sum_{v\\varepsilon T}length(path(v))$\n\n其中， $v$ 是树 $T$ 中的内结点， $length(path(v))$是从树根到结点$v$的路径长度。\n\n红黑树是一类特殊的二叉搜索树，其中每个结点被“染成”红色或黑色。若将二叉搜索树结点中的空指针看作是指向一个空结点，则称这类空结点为二叉搜索树的前端结点。并规定所有前端结点的高度为$-1$。除了前端结点外，其他结点均为内结点。\n\n一棵红黑树是满足下面“红黑性质”染色二叉搜索树：\n\n1. 每个结点被染成红色或黑色；\n\n2. 每个前端结点为黑色结点；\n\n3. 任一红结点的儿子结点均为黑结点；\n\n4. 在从任一结点到其子孙前端结点的所有路径上具有相同的黑结点数。\n\n从红黑树中任一结点 $x$ 出发(不包括结点 $x$)，到达一个前端结点的任意一条路径上的黑结点个数称为结点 $x$ 的黑高度，记作 $bh(x)$。红黑树的黑高度定义为其根结点的黑高度。\n\n给定正整数 $n$，试设计一个算法，计算出在所有含有 $n$ 个结点的红黑树中，平均路长的最大值。\n", "inputFormat": "文件有多个测试项。每行有1个正整数$n$， ($1\\le n\\le 30000$)，表示红黑树的结点数。文件最后以一个$0$结束。\n", "outputFormat": "对每行中红黑树的结点数 $n$，将计算出的平均路长的最大值输出到文件中。\n\n每行输出一个最大值。 文件最后以一个$0$ 结束。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[FJOI2017] Average Path Length of a Tree", "background": "", "description": "The internal path length $IPL(T)$ of a tree $T$ is defined as:\n$$IPL(T)=\\sum_{v\\in T} length(path(v)),$$\nwhere $v$ ranges over the internal nodes of $T$, and $length(path(v))$ is the length of the path from the root to node $v$.\n\nA red-black tree is a special binary search tree in which each node is colored red or black. If we regard null pointers in a binary search tree as pointing to an empty node, we call these empty nodes the external nodes of the BST. We stipulate that all external nodes have height $-1$. All nodes other than external nodes are internal nodes.\n\nA red-black tree is a colored binary search tree that satisfies the following red-black properties:\n1. Every node is either red or black.\n2. Every external node is black.\n3. The children of any red node are black.\n4. Every path from any node to its descendant external nodes contains the same number of black nodes.\n\nFor any node $x$ in a red-black tree, the number of black nodes on any path from $x$ (excluding $x$) down to an external node is called the black height of node $x$, denoted $bh(x)$. The black height of a red-black tree is the black height of its root.\n\nGiven a positive integer $n$, design an algorithm to compute, among all red-black trees with $n$ nodes, the maximum possible internal path length.", "inputFormat": "Multiple test cases. Each line contains a single positive integer $n$ ($1\\le n\\le 30000$), which is the number of nodes in the red-black tree. The input is terminated by a line containing a single $0$.", "outputFormat": "For each given $n$, output the maximum internal path length on a separate line. Do not output any extra content.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[FJOI2017] 树的平均路长问题", "background": "", "description": "一棵树 $T$ 的平均路长 $IPL(T)$定义为：\n\n$IPL(T)=\\sum_{v\\varepsilon T}length(path(v))$\n\n其中， $v$ 是树 $T$ 中的内结点， $length(path(v))$是从树根到结点$v$的路径长度。\n\n红黑树是一类特殊的二叉搜索树，其中每个结点被“染成”红色或黑色。若将二叉搜索树结点中的空指针看作是指向一个空结点，则称这类空结点为二叉搜索树的前端结点。并规定所有前端结点的高度为$-1$。除了前端结点外，其他结点均为内结点。\n\n一棵红黑树是满足下面“红黑性质”染色二叉搜索树：\n\n1. 每个结点被染成红色或黑色；\n\n2. 每个前端结点为黑色结点；\n\n3. 任一红结点的儿子结点均为黑结点；\n\n4. 在从任一结点到其子孙前端结点的所有路径上具有相同的黑结点数。\n\n从红黑树中任一结点 $x$ 出发(不包括结点 $x$)，到达一个前端结点的任意一条路径上的黑结点个数称为结点 $x$ 的黑高度，记作 $bh(x)$。红黑树的黑高度定义为其根结点的黑高度。\n\n给定正整数 $n$，试设计一个算法，计算出在所有含有 $n$ 个结点的红黑树中，平均路长的最大值。\n", "inputFormat": "文件有多个测试项。每行有1个正整数$n$， ($1\\le n\\le 30000$)，表示红黑树的结点数。文件最后以一个$0$结束。\n", "outputFormat": "对每行中红黑树的结点数 $n$，将计算出的平均路长的最大值输出到文件中。\n\n每行输出一个最大值。 文件最后以一个$0$ 结束。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3817", "type": "P", "difficulty": 2, "samples": [["3 3\n2 2 2", "1\n"], ["6 1\n1 6 1 2 0 4", "11"], ["5 9\n3 1 4 1 5", "0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["模拟", "贪心", "洛谷月赛"], "title": "小A的糖果", "background": "", "description": "小 A 有 $n$ 个糖果盒，第 $i$ 个盒中有 $a_i$ 颗糖果。\n\n小 A 每次可以从其中一盒糖果中吃掉一颗，他想知道，要让任意两个相邻的盒子中糖的个数之和都不大于 $x$，至少得吃掉几颗糖。\n", "inputFormat": "输入的第一行是两个用空格隔开的整数，代表糖果盒的个数 $n$ 和给定的参数 $x$。\n\n第二行有 $n$ 个用空格隔开的整数，第 $i$ 个整数代表第 $i$ 盒糖的糖果个数 $a_i$。", "outputFormat": "输出一行一个整数，代表最少要吃掉的糖果的数量。", "hint": "#### 样例输入输出 1 解释\n\n吃掉第 2 盒中的一个糖果即可。\n\n---\n\n#### 样例输入输出 2 解释\n\n第 2 盒糖吃掉 $6$ 颗，第 4 盒吃掉 $2$ 颗，第 6 盒吃掉 $3$ 颗。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\leq 20$，$a_i, x \\leq 100$。\n- 对于 $70\\%$ 的数据，保证 $n \\leq 10^3$，$a_i, x \\leq 10^5$。\n- 对于 $100\\%$ 的数据，保证 $2 \\leq n \\leq 10^5$，$0 \\leq a_i, x \\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "Xiao A's Candies", "background": "", "description": "Xiao A has $n$ candy boxes; the $i$-th box contains $a_i$ candies.\n\nEach time, Xiao A can eat one candy from one box. He wants to know: to make the sum of candies in any two adjacent boxes no greater than $x$, what is the minimum number of candies he must eat.", "inputFormat": "The first line contains two space-separated integers, the number of boxes $n$ and the given parameter $x$.\n\nThe second line contains $n$ space-separated integers; the $i$-th integer is $a_i$, the number of candies in the $i$-th box.", "outputFormat": "Output one line with a single integer, the minimum number of candies to eat.", "hint": "#### Explanation for Sample Input/Output 1\n\nEating one candy from box 2 suffices.\n\n---\n\n#### Explanation for Sample Input/Output 2\n\nEat $6$ from box 2, $2$ from box 4, and $3$ from box 6.\n\n---\n\n#### Constraints\n\n- For $30\\%$ of the testdata, it is guaranteed that $n \\leq 20$ and $a_i, x \\leq 100$.\n- For $70\\%$ of the testdata, it is guaranteed that $n \\leq 10^3$ and $a_i, x \\leq 10^5$.\n- For $100\\%$ of the testdata, it is guaranteed that $2 \\leq n \\leq 10^5$ and $0 \\leq a_i, x \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小A的糖果", "background": "", "description": "小 A 有 $n$ 个糖果盒，第 $i$ 个盒中有 $a_i$ 颗糖果。\n\n小 A 每次可以从其中一盒糖果中吃掉一颗，他想知道，要让任意两个相邻的盒子中糖的个数之和都不大于 $x$，至少得吃掉几颗糖。\n", "inputFormat": "输入的第一行是两个用空格隔开的整数，代表糖果盒的个数 $n$ 和给定的参数 $x$。\n\n第二行有 $n$ 个用空格隔开的整数，第 $i$ 个整数代表第 $i$ 盒糖的糖果个数 $a_i$。", "outputFormat": "输出一行一个整数，代表最少要吃掉的糖果的数量。", "hint": "#### 样例输入输出 1 解释\n\n吃掉第 2 盒中的一个糖果即可。\n\n---\n\n#### 样例输入输出 2 解释\n\n第 2 盒糖吃掉 $6$ 颗，第 4 盒吃掉 $2$ 颗，第 6 盒吃掉 $3$ 颗。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\leq 20$，$a_i, x \\leq 100$。\n- 对于 $70\\%$ 的数据，保证 $n \\leq 10^3$，$a_i, x \\leq 10^5$。\n- 对于 $100\\%$ 的数据，保证 $2 \\leq n \\leq 10^5$，$0 \\leq a_i, x \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3818", "type": "P", "difficulty": 4, "samples": [["3 6 2 1\n...#..\n..##..\n..#...", "5\n"], ["3 7 2 1\n..#..#.\n.##.##.\n.#..#..", "-1"], ["6 6 -2 0\n.#....\n.#.#..\n.####.\n.#..#.\n.##.#.\n....#.", "21"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "广度优先搜索 BFS", "最短路", "洛谷月赛"], "title": "小A和uim之大逃离 II", "background": "话说上回……还是参见 <https://www.luogu.com.cn/problem/P1373> 吧\n\n小 a 和 uim 再次来到雨林中探险。突然一阵南风吹来，一片乌云从南部天边急涌过来，还伴着一道道闪电，一阵阵雷声。刹那间，狂风大作，乌云布满了天空，紧接着豆大的雨点从天空中打落下来，只见前方出现了一个牛头马面的怪物，低沉着声音说：“呵呵，既然你们来到这，两个都别活了！”。小 a 和他的小伙伴再次惊呆了！\n", "description": "瞬间，地面上出现了一个 $H$ 行 $W$ 列的巨幅矩阵，矩阵的每个格子上要么是空地 `.` 或者障碍 `#`。\n\n他们起点在 $(1,1)$，要逃往 $(H,W)$ 的出口。他们可以一次向上下左右移动一格，这个算一步操作。不过他们还保留着上次冒险时收集的魔液，一口气喝掉后可以瞬移到相对自己位置的 $(D,R)$ 向量；也就是说，原来的位置是 $(x,y)$，然后新的位置是 $(x+D,y+R)$，这个也算一步操作，不过他们仅能至多进行一次这种操作（当然可以不喝魔液）。\n\n这个地方是个是非之地。所以他们希望知道最小能有几步操作可以离开这个鬼地方。不过他们可能逃不出这个鬼地方，遇到这种情况，只能等死，别无他法。\n", "inputFormat": "第一行个整数，$H,W,D,R$，意义在描述已经说明。\n\n接下来 $H$ 行，每行长度是 $W$，仅有 `.` 或者 `#` 的字符串。\n", "outputFormat": "请输出一个整数表示最小的逃出操作次数。如果他们逃不出来，就输出 $-1$。\n", "hint": "样例解释 $1$\n\n$(1,1) \\to (1,2)\\to (1,3)\\to$ 喝魔液 $\\to (3,4)\\to (3,5)\\to (3,6)$。\n\n样例解释 $2$\n\n因为只有一瓶魔液所以他们没办法逃出来。\n\n样例解释 $3$\n\n$D$ 和 $R$ 还可以是 $0$或者负数。\n\n数据范围与约定\n\n$40\\%$ 的测试数据 $2\\leq H,W\\leq 5$。\n\n$70\\%$ 的测试数据 $2\\leq H,W\\leq 100$。\n\n$100\\%$ 的测试数据 $2\\leq H,W\\leq 1000,|D|<H,|R|<W$。", "locale": "zh-CN", "translations": {"en": {"title": "Little A and uim's Great Escape II", "background": "As for the last story... please see https://www.luogu.com.cn/problem/P1373.\n\nLittle A and his friend uim venture into the rainforest again. Suddenly, a south wind blows, dark clouds surge from the southern horizon, lightning flashes and thunder rumbles. In an instant, a gale rises, the sky is shrouded in clouds, and soon bean-sized raindrops start to fall. A monster with a bull’s head and a horse’s face appears ahead, growling: “Heh, since you’ve come here, neither of you will leave alive!” Little A and his companion are shocked once again.", "description": "In a flash, a huge matrix of $H$ rows and $W$ columns appears on the ground. Each cell is either empty land `.` or an obstacle `#`.\n\nThey start at $(1, 1)$ and must escape to the exit at $(H, W)$. They can move one cell up, down, left, or right; each such move counts as one operation. They still have the magic potion from their last adventure. If they drink it in one go, they can instantly teleport by the relative vector $(D, R)$; that is, if their current position is $(x, y)$, the new position becomes $(x + D, y + R)$. This also counts as one operation, but they can use this operation at most once (they may also choose not to drink the potion).\n\nThis is a dangerous place. They want to know the minimum number of operations needed to get out. However, it might be impossible to escape; in that case, they can only await their fate.", "inputFormat": "The first line contains four integers $H$, $W$, $D$, $R$, whose meanings are explained in the description.\n\nThe next $H$ lines each contain a string of length $W$, consisting only of `.` and `#`.", "outputFormat": "Output a single integer representing the minimum number of operations needed to escape. If they cannot escape, output $-1$.", "hint": "Sample explanation 1.\n\n$(1, 1) \\to (1, 2) \\to (1, 3) \\to$ drink the magic potion $\\to (3, 4) \\to (3, 5) \\to (3, 6)$.\n\nSample explanation 2.\n\nSince there is only one bottle of magic potion, they cannot escape.\n\nSample explanation 3.\n\n$D$ and $R$ can also be $0$ or negative.\n\nConstraints and Notes.\n\n- For $40\\%$ of the testdata, $2 \\le H, W \\le 5$.\n- For $70\\%$ of the testdata, $2 \\le H, W \\le 100$.\n- For $100\\%$ of the testdata, $2 \\le H, W \\le 1000$, $|D| < H$, $|R| < W$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小A和uim之大逃离 II", "background": "话说上回……还是参见 <https://www.luogu.com.cn/problem/P1373> 吧\n\n小 a 和 uim 再次来到雨林中探险。突然一阵南风吹来，一片乌云从南部天边急涌过来，还伴着一道道闪电，一阵阵雷声。刹那间，狂风大作，乌云布满了天空，紧接着豆大的雨点从天空中打落下来，只见前方出现了一个牛头马面的怪物，低沉着声音说：“呵呵，既然你们来到这，两个都别活了！”。小 a 和他的小伙伴再次惊呆了！\n", "description": "瞬间，地面上出现了一个 $H$ 行 $W$ 列的巨幅矩阵，矩阵的每个格子上要么是空地 `.` 或者障碍 `#`。\n\n他们起点在 $(1,1)$，要逃往 $(H,W)$ 的出口。他们可以一次向上下左右移动一格，这个算一步操作。不过他们还保留着上次冒险时收集的魔液，一口气喝掉后可以瞬移到相对自己位置的 $(D,R)$ 向量；也就是说，原来的位置是 $(x,y)$，然后新的位置是 $(x+D,y+R)$，这个也算一步操作，不过他们仅能至多进行一次这种操作（当然可以不喝魔液）。\n\n这个地方是个是非之地。所以他们希望知道最小能有几步操作可以离开这个鬼地方。不过他们可能逃不出这个鬼地方，遇到这种情况，只能等死，别无他法。\n", "inputFormat": "第一行个整数，$H,W,D,R$，意义在描述已经说明。\n\n接下来 $H$ 行，每行长度是 $W$，仅有 `.` 或者 `#` 的字符串。\n", "outputFormat": "请输出一个整数表示最小的逃出操作次数。如果他们逃不出来，就输出 $-1$。\n", "hint": "样例解释 $1$\n\n$(1,1) \\to (1,2)\\to (1,3)\\to$ 喝魔液 $\\to (3,4)\\to (3,5)\\to (3,6)$。\n\n样例解释 $2$\n\n因为只有一瓶魔液所以他们没办法逃出来。\n\n样例解释 $3$\n\n$D$ 和 $R$ 还可以是 $0$或者负数。\n\n数据范围与约定\n\n$40\\%$ 的测试数据 $2\\leq H,W\\leq 5$。\n\n$70\\%$ 的测试数据 $2\\leq H,W\\leq 100$。\n\n$100\\%$ 的测试数据 $2\\leq H,W\\leq 1000,|D|<H,|R|<W$。", "locale": "zh-CN"}}}
{"pid": "P3819", "type": "P", "difficulty": 4, "samples": [["100 3\n20 3\n50 2\n70 1\n", "110\n"], ["100 2\n0 1\n100 10\n", "100\n"], ["10000000000 5\n3282894320 391\n4394338332 929\n6932893249 181\n7823822843 440\n9322388365 623\n", "5473201404068\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "数学", "前缀和", "洛谷月赛"], "title": "松江 1843 路", "background": "", "description": "涞坊路是一条长 $L$ 米的道路，道路上的坐标范围从 $0$ 到 $L$，路上有 $N$ 座房子，第 $i$ 座房子建在坐标为 $x_i$ 的地方，其中住了 $r_i$ 人。\n\n松江 1843 路公交车要在这条路上建一个公交站，市政府希望让最多的人得到方便，因此希望所有的每一个的居民，从家到车站的距离的**总和**最短。\n\n公交站应该建在哪里呢？", "inputFormat": "第一行输入 $L$、$N$。\n\n接下来 $N$ 行，每行两个整数 $x_i$ 和 $r_i$。", "outputFormat": "一个整数，最小的每个人从家到车站的距离的总和。\n", "hint": "### 样例解释 1\n\n当建在坐标 $40$ 的时候，所有人距离车站的距离总和为 $|20-40| \\times 3+|50-40| \\times 2+|70-40| \\times 1=110$。\n\n### 数据范围和约定\n\n对于 $10\\% $的数据，$1\\le N \\le 50$，$R_i=1$。\n\n对于 $30\\%$ 的数据，$1 \\le N \\le 100$，$R_i \\le 10$，$1 \\le L \\le 1000$。\n\n对于 $70\\%$ 的数据，$1 \\le N \\le 1000$，$R_i \\le 100$，$1 \\le L \\le 10^6$。\n\n对于全部数据，$1 \\le L \\le 10^{10}$，$1 \\le N \\le 10^5$，$0 \\le x_i \\le L$，$1 \\le r_i \\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Songjiang 1843 Road", "background": "", "description": "Laifang Road is a road of length $L$ meters, with coordinates ranging from $0$ to $L$. There are $N$ houses on the road. The $i$-th house is located at coordinate $x_i$ and has $r_i$ residents.\n\nThe Songjiang 1843 Road bus line will build a bus stop on this road. The city government wants to serve as many people as possible, so it hopes to minimize the sum of distances from every resident’s home to the stop.\n\nWhere should the bus stop be built?", "inputFormat": "The first line contains $L$, $N$.\n\nThe next $N$ lines each contain two integers $x_i$ and $r_i$.", "outputFormat": "Output one integer: the minimal sum of distances from all residents’ homes to the bus stop.", "hint": "Sample Explanation 1\n\nWhen the stop is built at coordinate $40$, the sum of distances is $|20-40| \\times 3+|50-40| \\times 2+|70-40| \\times 1=110$.\n\nConstraints\n\n- For $10\\%$ of the testdata, $1 \\le N \\le 50$, $r_i=1$.\n- For $30\\%$ of the testdata, $1 \\le N \\le 100$, $r_i \\le 10$, $1 \\le L \\le 1000$.\n- For $70\\%$ of the testdata, $1 \\le N \\le 1000$, $r_i \\le 100$, $1 \\le L \\le 10^6$.\n- For all testdata, $1 \\le L \\le 10^{10}$, $1 \\le N \\le 10^5$, $0 \\le x_i \\le L$, $1 \\le r_i \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "松江 1843 路", "background": "", "description": "涞坊路是一条长 $L$ 米的道路，道路上的坐标范围从 $0$ 到 $L$，路上有 $N$ 座房子，第 $i$ 座房子建在坐标为 $x_i$ 的地方，其中住了 $r_i$ 人。\n\n松江 1843 路公交车要在这条路上建一个公交站，市政府希望让最多的人得到方便，因此希望所有的每一个的居民，从家到车站的距离的**总和**最短。\n\n公交站应该建在哪里呢？", "inputFormat": "第一行输入 $L$、$N$。\n\n接下来 $N$ 行，每行两个整数 $x_i$ 和 $r_i$。", "outputFormat": "一个整数，最小的每个人从家到车站的距离的总和。\n", "hint": "### 样例解释 1\n\n当建在坐标 $40$ 的时候，所有人距离车站的距离总和为 $|20-40| \\times 3+|50-40| \\times 2+|70-40| \\times 1=110$。\n\n### 数据范围和约定\n\n对于 $10\\% $的数据，$1\\le N \\le 50$，$R_i=1$。\n\n对于 $30\\%$ 的数据，$1 \\le N \\le 100$，$R_i \\le 10$，$1 \\le L \\le 1000$。\n\n对于 $70\\%$ 的数据，$1 \\le N \\le 1000$，$R_i \\le 100$，$1 \\le L \\le 10^6$。\n\n对于全部数据，$1 \\le L \\le 10^{10}$，$1 \\le N \\le 10^5$，$0 \\le x_i \\le L$，$1 \\le r_i \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P3820", "type": "P", "difficulty": 5, "samples": [["5 5\n.*...\n.****\n*....\n*****\n.....\n3\n1 2 1 1 1 3\n2 1 3 1\n1 2 1 1 1 3", "2\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["并查集", "洛谷原创", "广度优先搜索 BFS", "连通块", "洛谷月赛"], "title": "小D的地下温泉", "background": "小 D 最喜欢泡温泉了。小 D 找某奸商租下了一块 $N$ 行 $M$ 列的地，左上角为 $(1,1)$，右下角为 $(N,M)$。小 D 本以为这块地里全是温泉，结果这块地极不稳定，曾经发生过一些地形变动，所以其中一些地方全是土。", "description": "一开始他会告诉你当前这块地的情况，但是小 D 有一些假操作，希望你操作给他看：\n\n1. 由小 D 指定 $w$ 个位置，他希望知道其中哪个位置下水泡温泉的范围最大。泡温泉的范围定义为指定位置通过向上下左右四个方向能到达的位置的个数。若询问的位置为土，则范围为 $0$。如果如果有多个位置均为最大，输出给出顺序较前的那个。位置编号为 $1,2,...,w$。\n\n2. 由小 D 指定 $w$ 个位置，他会使用魔法按顺序翻转这 $w$ 个地方的地形。即若原位置是土，则该位置变为温泉；若原位置是温泉，则该位置变为土。因为小 D 不希望活动范围减少得太快，所以他在将温泉变为土时不会将一个区域分割。", "inputFormat": "第一行输入两个整数，$N,M$，为土地大小。\n\n接下来的 $N$ 行每行输入 $M$ 个字符，为 `.`（代表温泉）或 `*`（代表土）\n\n第 $N+2$ 行输入一个整数，$Q$，为操作数量。\n\n接下来的 $Q$ 行，每行先读入两个整数 $opt$ 和 $w$，表示操作类型和指定点的数量，在同一行还有 $2w$ 个数 $x_{1},y_{1},x_{2},y_{2},...,x_{w},y_{w}$，分别表示 $w$ 个操作的位置为 $(x_{1},y_{1}),(x_{2},y_{2}),...,(x_{w},y_{w})$。", "outputFormat": "对于每个操作 1，输出询问的答案并换行", "hint": "对于 $30\\%$ 的数据，$N,M\\le 100,\\sum w\\le 100$\n\n对于 $70\\%$ 的数据，$N,M\\le 1000$\n\n对于 $100\\%$ 的数据，$1\\le NM,Q\\le 10^{6},\\sum w\\le 10^{6},w\\geq 1$\n\n数据在 Windows 下制作", "locale": "zh-CN", "translations": {"en": {"title": "Xiao D's Underground Hot Springs", "background": "Xiao D loves soaking in hot springs. Xiao D rented a piece of land with $N$ rows and $M$ columns from a certain profiteer, with the top-left corner at $(1, 1)$ and the bottom-right corner at $(N, M)$. Xiao D originally thought the entire land was hot springs, but the land is very unstable and has undergone some terrain changes in the past, so some places are all soil.", "description": "At the beginning, he will tell you the current state of this land, but Xiao D has some pretend operations and wants you to perform them for him:\n\n1. Xiao D specifies $w$ positions and wants to know which of these positions has the largest soaking range if he goes down to soak at that position. The soaking range is defined as the number of positions reachable from the specified position by moving in the four directions up, down, left, and right. If the queried position is soil, then the range is $0$. If multiple positions tie for the maximum, output the one that appears earlier in the given order. The positions are indexed as $1, 2, \\ldots, w$.\n\n2. Xiao D specifies $w$ positions. He will use magic to toggle the terrain of these $w$ places in order. That is, if the original position is soil, it becomes a hot spring; if the original position is a hot spring, it becomes soil. Because Xiao D does not want the activity range to shrink too quickly, when turning a hot spring into soil he will not split a connected region.", "inputFormat": "The first line contains two integers, $N, M$, representing the size of the land.\n\nThe next $N$ lines each contain $M$ characters, either `.` (representing a hot spring) or `*` (representing soil).\n\nThe $(N+2)$-th line contains an integer $Q$, the number of operations.\n\nIn each of the next $Q$ lines, first read two integers $opt$ and $w$, representing the operation type and the number of specified points. On the same line, there are also $2w$ numbers $x_{1}, y_{1}, x_{2}, y_{2}, \\ldots, x_{w}, y_{w}$, which represent the $w$ operation positions $(x_{1}, y_{1}), (x_{2}, y_{2}), \\ldots, (x_{w}, y_{w})$.", "outputFormat": "For each operation of type $1$, output the answer to the query on a new line.", "hint": "- For $30\\%$ of the testdata, $N, M \\le 100, \\sum w \\le 100$.\n- For $70\\%$ of the testdata, $N, M \\le 1000$.\n- Constraints: for $100\\%$ of the testdata, $1 \\le NM, Q \\le 10^{6}, \\sum w \\le 10^{6}, w \\ge 1$.\n- The testdata is generated on Windows.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小D的地下温泉", "background": "小 D 最喜欢泡温泉了。小 D 找某奸商租下了一块 $N$ 行 $M$ 列的地，左上角为 $(1,1)$，右下角为 $(N,M)$。小 D 本以为这块地里全是温泉，结果这块地极不稳定，曾经发生过一些地形变动，所以其中一些地方全是土。", "description": "一开始他会告诉你当前这块地的情况，但是小 D 有一些假操作，希望你操作给他看：\n\n1. 由小 D 指定 $w$ 个位置，他希望知道其中哪个位置下水泡温泉的范围最大。泡温泉的范围定义为指定位置通过向上下左右四个方向能到达的位置的个数。若询问的位置为土，则范围为 $0$。如果如果有多个位置均为最大，输出给出顺序较前的那个。位置编号为 $1,2,...,w$。\n\n2. 由小 D 指定 $w$ 个位置，他会使用魔法按顺序翻转这 $w$ 个地方的地形。即若原位置是土，则该位置变为温泉；若原位置是温泉，则该位置变为土。因为小 D 不希望活动范围减少得太快，所以他在将温泉变为土时不会将一个区域分割。", "inputFormat": "第一行输入两个整数，$N,M$，为土地大小。\n\n接下来的 $N$ 行每行输入 $M$ 个字符，为 `.`（代表温泉）或 `*`（代表土）\n\n第 $N+2$ 行输入一个整数，$Q$，为操作数量。\n\n接下来的 $Q$ 行，每行先读入两个整数 $opt$ 和 $w$，表示操作类型和指定点的数量，在同一行还有 $2w$ 个数 $x_{1},y_{1},x_{2},y_{2},...,x_{w},y_{w}$，分别表示 $w$ 个操作的位置为 $(x_{1},y_{1}),(x_{2},y_{2}),...,(x_{w},y_{w})$。", "outputFormat": "对于每个操作 1，输出询问的答案并换行", "hint": "对于 $30\\%$ 的数据，$N,M\\le 100,\\sum w\\le 100$\n\n对于 $70\\%$ 的数据，$N,M\\le 1000$\n\n对于 $100\\%$ 的数据，$1\\le NM,Q\\le 10^{6},\\sum w\\le 10^{6},w\\geq 1$\n\n数据在 Windows 下制作", "locale": "zh-CN"}}}
{"pid": "P3821", "type": "P", "difficulty": 6, "samples": [["2 1 1 2 1\n1 2 1\n0\n", "1\n"], ["2 1 1 2 1\n1 2 2\n0\n", "2"], ["2 1 1 2 10000001\n1 2 2\n0\n", "2"], ["2 1 1 2 10000001\n1 2 2\n1\n2\n2 1\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "图论", "矩阵乘法"], "title": "Isaac", "background": "居润国迷上了一款游戏《以撒的结合重生》。他已经打到了最后一关，这一关有特殊的走位技巧。\n\n1. 居润国从时刻 $0$ 开始，要控制以撒从起点走到终点。\n\n2. 居润国只能在第 $k$ 时刻恰好走到终点。（从一个房间走到另一个房间居润国需要花费一个单位时间，居润国手速快，不会在同一个房间停留，以撒可以在这些房间中来回走动）\n\n3. 若房间 $u$ 和 $v$ 相连，则居润国能控制以撒通过这两个房间的通道当且仅当以撒的血量大于等于 $f(u, v)$\n\n4. 在这些房间之间有一堆怪物在游走。\n\n5. 居润国为了求稳，于是上网找到了一个解码器，在代码中发现这些怪物们游走的房间有固定的规律：怪物每次都会从一个房间移动到另一个房间（也需花费一个单位时间），且他们总是在几个固定的房间按照固定的顺序内游走，游走的房间个数为 $T$。\n\n为了不在玩游戏时失误，居润国希望能够避开所有的怪物走到终点，即无伤通过最后一关，同时希望你找到居润国控制的以撒完成这个任务至少需要的血量。对编程一窍不通的他找到了你，希望寻求解决。如果要是你无法解决，那么就光明正大地告诉他： `'IMP0SSBLE!!'` 他一定不会打死你的。", "description": "求居润国是否能在上述条件要求下无伤通过最后一关。如果可以，输出居润国控制的以撒最少所需的血量 $B$，否则输出 `'IMP0SSBLE!!'` \n", "inputFormat": "第一行有五个数，分别为 $n,m,s,t,k$，分别表示一共有 $n$ 个房间，以及 $m$ 对相邻房间及其通过所需要的血量，以 $s$ 为起点，$t$ 为终点，要在 $k$ 时刻恰好走到终点。\n\n接下来 $m$ 行每行分别有三个数，分别是 $u,v,w$，表示房间 $u$ 和房间 $v$ 相邻，两个房间互相通过的血量均为 $w$。\n\n接下来一行是单独的一个数 $a$，表示一共有 $a$ 只怪物\n\n接下来有 $a$ 个数据分别表示每个怪物的游走规律\n\n每个数据的第一个数 $T$ 表示怪物游走的房间个数，接下来有 $T$ 个房间编号表示从**第零时刻开始**怪物将从第一个房间按顺序和周期游走。", "outputFormat": "仅一行，居润国控制以撒的最少所需血量 $B$，或是 `'IMP0SSBLE!!'` \n", "hint": "共 $20$ 组数据。\n\n对于 $15\\%$ 的数据，$a = 0$，$k \\leq 20$。\n\n对于 $25\\%$ 的数据，$a \\leq 3$，$k \\leq 1500$。\n\n对于 $50\\%$ 的数据，$a \\leq 3$，$k \\leq 10^4$。\n\n对于 $70\\%$ 的数据，$a \\leq 20$，$k \\leq 10^6$。\n\n对于 $85\\%$ 的数据，$a \\leq 30$，$k \\leq 10^8$。\n\n对于 $100\\%$ 的数据，$a \\leq 30$，$k \\leq 2*10^9$，$2 \\leq T \\leq 4$，$n \\leq 50$，$m \\leq 1250$。\n\n所有输入皆在 int 范围内。\n\n所有数据皆大于零，**可能会有重边，若一条边输入多次 则以最后一次出现的权值为准。**", "locale": "zh-CN", "translations": {"en": {"title": "Isaac", "background": "Ju Runguo got hooked on a game, The Binding of Isaac: Rebirth. He has reached the final level, which requires special movement techniques.\n\n1. Starting from time $0$, he must control Isaac to go from the start to the finish.\n2. He can arrive at the finish only exactly at time $k$. (Moving from one room to another costs one time unit. His hands are fast, so he never waits in the same room. Isaac may move back and forth among rooms.)\n3. If rooms $u$ and $v$ are connected, he can control Isaac to traverse the passage between them if and only if Isaac’s health is at least $f(u, v)$.\n4. There are monsters roaming among these rooms.\n5. To play it safe, Ju Runguo found a decoder online and discovered in the code that the monsters roam rooms with a fixed pattern: each time they move from one room to another (also costing one time unit), and they always roam within several fixed rooms in a fixed order. The number of rooms in the roaming cycle is $T$.\n\nTo avoid making mistakes while playing, Ju Runguo hopes to avoid all monsters and reach the finish, i.e., pass the final level without taking damage, and he hopes you can find the minimum health Isaac needs under his control to complete this task. If you cannot solve it, then just tell him openly: 'IMP0SSBLE!!'. He definitely won't kill you.", "description": "Determine whether Ju Runguo can pass the final level without taking damage under the above conditions. If he can, output the minimum required health $B$ for Isaac under Ju Runguo’s control; otherwise, output 'IMP0SSBLE!!'.", "inputFormat": "The first line contains five numbers $n, m, s, t, k$, representing that there are $n$ rooms in total, $m$ pairs of adjacent rooms together with the required health to traverse them, the start is $s$, the finish is $t$, and Isaac must arrive exactly at time $k$.\n\nEach of the next $m$ lines contains three numbers $u, v, w$, meaning that room $u$ and room $v$ are adjacent, and the required health to traverse between the two rooms in both directions is $w$.\n\nThe next line contains a single number $a$, the number of monsters.\n\nThen follow $a$ data blocks, each describing one monster’s roaming pattern.\n\nIn each block, the first number $T$ is the number of rooms in the monster’s roaming cycle, followed by $T$ room IDs that indicate that starting from time $0$, the monster will move from the first room in order and periodically repeat the sequence.", "outputFormat": "Output a single line: the minimum required health $B$ for Isaac under Ju Runguo’s control, or 'IMP0SSBLE!!'.", "hint": "There are $20$ groups of testdata.\n\nFor $15\\%$ of the testdata, $a = 0$, $k \\leq 20$.\n\nFor $25\\%$ of the testdata, $a \\leq 3$, $k \\leq 1500$.\n\nFor $50\\%$ of the testdata, $a \\leq 3$, $k \\leq 10^4$.\n\nFor $70\\%$ of the testdata, $a \\leq 20$, $k \\leq 10^6$.\n\nFor $85\\%$ of the testdata, $a \\leq 30$, $k \\leq 10^8$.\n\nFor $100\\%$ of the testdata, $a \\leq 30$, $k \\leq 2*10^9$, $2 \\leq T \\leq 4$, $n \\leq 50$, $m \\leq 1250$.\n\nAll inputs are within the range of int.\n\nAll numbers are positive. There may be multiple edges; if an edge is given multiple times, the weight of its last occurrence prevails.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Isaac", "background": "居润国迷上了一款游戏《以撒的结合重生》。他已经打到了最后一关，这一关有特殊的走位技巧。\n\n1. 居润国从时刻 $0$ 开始，要控制以撒从起点走到终点。\n\n2. 居润国只能在第 $k$ 时刻恰好走到终点。（从一个房间走到另一个房间居润国需要花费一个单位时间，居润国手速快，不会在同一个房间停留，以撒可以在这些房间中来回走动）\n\n3. 若房间 $u$ 和 $v$ 相连，则居润国能控制以撒通过这两个房间的通道当且仅当以撒的血量大于等于 $f(u, v)$\n\n4. 在这些房间之间有一堆怪物在游走。\n\n5. 居润国为了求稳，于是上网找到了一个解码器，在代码中发现这些怪物们游走的房间有固定的规律：怪物每次都会从一个房间移动到另一个房间（也需花费一个单位时间），且他们总是在几个固定的房间按照固定的顺序内游走，游走的房间个数为 $T$。\n\n为了不在玩游戏时失误，居润国希望能够避开所有的怪物走到终点，即无伤通过最后一关，同时希望你找到居润国控制的以撒完成这个任务至少需要的血量。对编程一窍不通的他找到了你，希望寻求解决。如果要是你无法解决，那么就光明正大地告诉他： `'IMP0SSBLE!!'` 他一定不会打死你的。", "description": "求居润国是否能在上述条件要求下无伤通过最后一关。如果可以，输出居润国控制的以撒最少所需的血量 $B$，否则输出 `'IMP0SSBLE!!'` \n", "inputFormat": "第一行有五个数，分别为 $n,m,s,t,k$，分别表示一共有 $n$ 个房间，以及 $m$ 对相邻房间及其通过所需要的血量，以 $s$ 为起点，$t$ 为终点，要在 $k$ 时刻恰好走到终点。\n\n接下来 $m$ 行每行分别有三个数，分别是 $u,v,w$，表示房间 $u$ 和房间 $v$ 相邻，两个房间互相通过的血量均为 $w$。\n\n接下来一行是单独的一个数 $a$，表示一共有 $a$ 只怪物\n\n接下来有 $a$ 个数据分别表示每个怪物的游走规律\n\n每个数据的第一个数 $T$ 表示怪物游走的房间个数，接下来有 $T$ 个房间编号表示从**第零时刻开始**怪物将从第一个房间按顺序和周期游走。", "outputFormat": "仅一行，居润国控制以撒的最少所需血量 $B$，或是 `'IMP0SSBLE!!'` \n", "hint": "共 $20$ 组数据。\n\n对于 $15\\%$ 的数据，$a = 0$，$k \\leq 20$。\n\n对于 $25\\%$ 的数据，$a \\leq 3$，$k \\leq 1500$。\n\n对于 $50\\%$ 的数据，$a \\leq 3$，$k \\leq 10^4$。\n\n对于 $70\\%$ 的数据，$a \\leq 20$，$k \\leq 10^6$。\n\n对于 $85\\%$ 的数据，$a \\leq 30$，$k \\leq 10^8$。\n\n对于 $100\\%$ 的数据，$a \\leq 30$，$k \\leq 2*10^9$，$2 \\leq T \\leq 4$，$n \\leq 50$，$m \\leq 1250$。\n\n所有输入皆在 int 范围内。\n\n所有数据皆大于零，**可能会有重边，若一条边输入多次 则以最后一次出现的权值为准。**", "locale": "zh-CN"}}}
{"pid": "P3822", "type": "P", "difficulty": 6, "samples": [["10 3 1 2\n1 100 0\n1 2333 0\n1 -233 0\n2 5\n2 7\n2 15\n1 5 15\n2 15\n1 -1 12\n2 15", "0\n1\n0\n1\n0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["高精度", "2017", "线段树", "NOI", "O2优化", "进制"], "title": "[NOI2017] 整数", "background": "在人类智慧的山巅，有着一台字长为 $1\\,048\\,576$ 位（此数字与解题无关）的超级计算机，著名理论计算机科学家 P 博士正用它进行各种研究。不幸的是，这天台风切断了电力系统，超级计算机无法工作，而 P 博士明天就要交实验结果了，只好求助于学过 OI 的你...\n", "description": "P 博士将他的计算任务抽象为对一个整数的操作。\n\n具体来说，有一个整数 $x$，一开始为 $0$。\n\n接下来有 $n$ 个操作，每个操作都是以下两种类型中的一种：\n\n- `1 a b`：将 $x$ 加上整数 $a\\cdot 2^b$，其中 $a$ 为一个整数，$b$ 为一个非负整数\n\n- `2 k` ：询问 $x$ 在用二进制表示时，位权为 $2^k$ 的位的值（即这一位上的 $1$ 代表 $2^k$）\n\n保证在任何时候，$x\\geqslant 0$。", "inputFormat": "输入的第一行包含四个正整数 $n,t_1,t_2,t_3$，$n$ 的含义见题目描述，$t_1$，$t_2$，$t_3$ 的具体含义见子任务。\n\n接下来 $n$ 行，每行给出一个操作，具体格式和含义见题目描述。", "outputFormat": "对于每个询问操作，输出一行，表示该询问的答案（$0$ 或 $1$）。对于加法操作，没有任何输出。\n", "hint": "在所有测试点中，$1\\leqslant t_1 \\leqslant 3, 1 \\leqslant t_2 \\leqslant 4, 1 \\leqslant t_3 \\leqslant 2$。不同的 $t_1, t_2, t_3$ 对应的特殊限制如下：\n\n- 对于 $t_1 = 1$ 的测试点，满足 $a = 1$；\n- 对于 $t_1 = 2$ 的测试点，满足 $|a| = 1$；\n- 对于 $t_1 = 3$ 的测试点，满足 $|a| \\leqslant 10^9$；\n- 对于 $t_2 = 1$ 的测试点，满足 $0 \\leqslant b, k \\leqslant 30$；\n- 对于 $t_2 = 2$ 的测试点，满足 $0 \\leqslant b, k \\leqslant 100$；\n- 对于 $t_2 = 3$ 的测试点，满足 $0 \\leqslant b, k \\leqslant n$；\n- 对于 $t_2 = 4$ 的测试点，满足 $0 \\leqslant b, k \\leqslant 30n$；\n- 对于 $t_3 = 1$ 的测试点，保证所有询问操作都在所有修改操作之后；\n- 对于 $t_3 = 2$ 的测试点，不保证询问操作和修改操作的先后顺序。\n\n本题共 25 个测试点，每个测试点 4 分。各个测试点的数据范围如下：\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\le$ | $t_1$ | $t_2$ | $t_3$ |\n|:-:|:-:|:-:|:-:|:-:|\n| $1$ | $10$ | $3$ | $1$ | $2$ |\n| $2$ | $100$ | $3$ | $2$ | $2$ |\n| $3$ | $2000$ | $3$ | $2$ | $2$ |\n| $4$ | $4000$ | $1$ | $3$ | $2$ |\n| $5$ | $6000$ | $3$ | $3$ | $1$ |\n| $6$ | $8000$ | $2$ | $3$ | $2$ |\n| $7$ | $9000$ | $3$ | $4$ | $2$ |\n| $8$ | $10000$ | $3$ | $3$ | $2$ |\n| $9$ | $30000$ | $3$ | $4$ | $2$ |\n| $10$ | $50000$ | $3$ | $4$ | $1$ |\n| $11$ | $60000$ | $3$ | $3$ | $2$ |\n| $12$ | $65000$ | $2$ | $4$ | $2$ |\n| $13$ | $70000$ | $3$ | $4$ | $2$ |\n| $14$ | $200000$ | $3$ | $4$ | $2$ |\n| $15$ | $300000$ | $2$ | $4$ | $2$ |\n| $16$ | $400000$ | $3$ | $4$ | $2$ |\n| $17$ | $500000$ | $3$ | $3$ | $2$ |\n| $18$ | $600000$ | $3$ | $4$ | $2$ |\n| $19$ | $700000$ | $3$ | $4$ | $2$ |\n| $20$ | $800000$ | $1$ | $4$ | $2$ |\n| $21$ | $900000$ | $2$ | $4$ | $2$ |\n| $22$ | $930000$ | $3$ | $3$ | $2$ |\n| $23$ | $960000$ | $3$ | $4$ | $1$ |\n| $24$ | $990000$ | $3$ | $3$ | $2$ |\n| $25$ | $1000000$ | $3$ | $4$ | $2$ |", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2017] Integer", "background": "At the summit of human wisdom, there is a supercomputer with a word length of $1\\,048\\,576$ bits (this number is irrelevant to solving the problem). Dr. P, a famous theoretical computer scientist, is using it for various research. Unfortunately, a typhoon cut off the power system today, and the supercomputer cannot work. Dr. P needs to submit the experimental results tomorrow, so he has to ask you, who have studied OI, for help...", "description": "Dr. P abstracts his computation task as operations on an integer.\n\nSpecifically, there is an integer $x$, initially $0$.\n\nThen there are $n$ operations, each of the following two types:\n- `1 a b`: add the integer $a \\cdot 2^b$ to $x$, where $a$ is an integer and $b$ is a nonnegative integer.\n- `2 k`: ask for the value of the bit of $x$ in binary whose weight is $2^k$ (that is, a $1$ in this bit represents $2^k$).\n\nIt is guaranteed that $x \\geqslant 0$ at all times.", "inputFormat": "The first line of input contains four positive integers $n, t_1, t_2, t_3$. The meaning of $n$ is given in the problem statement, and the meanings of $t_1, t_2, t_3$ are given in the subtasks.\n\nThen follow $n$ lines, each giving one operation. The specific format and meaning are as described above.", "outputFormat": "For each query operation, output one line representing the answer ($0$ or $1$). For addition operations, there is no output.", "hint": "In all test points, $1 \\leqslant t_1 \\leqslant 3$, $1 \\leqslant t_2 \\leqslant 4$, $1 \\leqslant t_3 \\leqslant 2$. Different pairs $t_1, t_2, t_3$ correspond to the following special restrictions:\n- For $t_1 = 1$, $a = 1$.\n- For $t_1 = 2$, $|a| = 1$.\n- For $t_1 = 3$, $|a| \\leqslant 10^9$.\n- For $t_2 = 1$, $0 \\leqslant b, k \\leqslant 30$.\n- For $t_2 = 2$, $0 \\leqslant b, k \\leqslant 100$.\n- For $t_2 = 3$, $0 \\leqslant b, k \\leqslant n$.\n- For $t_2 = 4$, $0 \\leqslant b, k \\leqslant 30n$.\n- For $t_3 = 1$, all query operations appear after all addition operations.\n- For $t_3 = 2$, the order between query operations and addition operations is not guaranteed.\n\nThere are 25 test points in total, each worth 4 points. The Constraints of each test point are as follows:\n\n::cute-table{tuack}\n\n| Test point ID | $n \\le$ | $t_1$ | $t_2$ | $t_3$ |\n|:-:|:-:|:-:|:-:|:-:|\n| $1$ | $10$ | $3$ | $1$ | $2$ |\n| $2$ | $100$ | $3$ | $2$ | $2$ |\n| $3$ | $2000$ | $3$ | $2$ | $2$ |\n| $4$ | $4000$ | $1$ | $3$ | $2$ |\n| $5$ | $6000$ | $3$ | $3$ | $1$ |\n| $6$ | $8000$ | $2$ | $3$ | $2$ |\n| $7$ | $9000$ | $3$ | $4$ | $2$ |\n| $8$ | $10000$ | $3$ | $3$ | $2$ |\n| $9$ | $30000$ | $3$ | $4$ | $2$ |\n| $10$ | $50000$ | $3$ | $4$ | $1$ |\n| $11$ | $60000$ | $3$ | $3$ | $2$ |\n| $12$ | $65000$ | $2$ | $4$ | $2$ |\n| $13$ | $70000$ | $3$ | $4$ | $2$ |\n| $14$ | $200000$ | $3$ | $4$ | $2$ |\n| $15$ | $300000$ | $2$ | $4$ | $2$ |\n| $16$ | $400000$ | $3$ | $4$ | $2$ |\n| $17$ | $500000$ | $3$ | $3$ | $2$ |\n| $18$ | $600000$ | $3$ | $4$ | $2$ |\n| $19$ | $700000$ | $3$ | $4$ | $2$ |\n| $20$ | $800000$ | $1$ | $4$ | $2$ |\n| $21$ | $900000$ | $2$ | $4$ | $2$ |\n| $22$ | $930000$ | $3$ | $3$ | $2$ |\n| $23$ | $960000$ | $3$ | $4$ | $1$ |\n| $24$ | $990000$ | $3$ | $3$ | $2$ |\n| $25$ | $1000000$ | $3$ | $4$ | $2$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2017] 整数", "background": "在人类智慧的山巅，有着一台字长为 $1\\,048\\,576$ 位（此数字与解题无关）的超级计算机，著名理论计算机科学家 P 博士正用它进行各种研究。不幸的是，这天台风切断了电力系统，超级计算机无法工作，而 P 博士明天就要交实验结果了，只好求助于学过 OI 的你...\n", "description": "P 博士将他的计算任务抽象为对一个整数的操作。\n\n具体来说，有一个整数 $x$，一开始为 $0$。\n\n接下来有 $n$ 个操作，每个操作都是以下两种类型中的一种：\n\n- `1 a b`：将 $x$ 加上整数 $a\\cdot 2^b$，其中 $a$ 为一个整数，$b$ 为一个非负整数\n\n- `2 k` ：询问 $x$ 在用二进制表示时，位权为 $2^k$ 的位的值（即这一位上的 $1$ 代表 $2^k$）\n\n保证在任何时候，$x\\geqslant 0$。", "inputFormat": "输入的第一行包含四个正整数 $n,t_1,t_2,t_3$，$n$ 的含义见题目描述，$t_1$，$t_2$，$t_3$ 的具体含义见子任务。\n\n接下来 $n$ 行，每行给出一个操作，具体格式和含义见题目描述。", "outputFormat": "对于每个询问操作，输出一行，表示该询问的答案（$0$ 或 $1$）。对于加法操作，没有任何输出。\n", "hint": "在所有测试点中，$1\\leqslant t_1 \\leqslant 3, 1 \\leqslant t_2 \\leqslant 4, 1 \\leqslant t_3 \\leqslant 2$。不同的 $t_1, t_2, t_3$ 对应的特殊限制如下：\n\n- 对于 $t_1 = 1$ 的测试点，满足 $a = 1$；\n- 对于 $t_1 = 2$ 的测试点，满足 $|a| = 1$；\n- 对于 $t_1 = 3$ 的测试点，满足 $|a| \\leqslant 10^9$；\n- 对于 $t_2 = 1$ 的测试点，满足 $0 \\leqslant b, k \\leqslant 30$；\n- 对于 $t_2 = 2$ 的测试点，满足 $0 \\leqslant b, k \\leqslant 100$；\n- 对于 $t_2 = 3$ 的测试点，满足 $0 \\leqslant b, k \\leqslant n$；\n- 对于 $t_2 = 4$ 的测试点，满足 $0 \\leqslant b, k \\leqslant 30n$；\n- 对于 $t_3 = 1$ 的测试点，保证所有询问操作都在所有修改操作之后；\n- 对于 $t_3 = 2$ 的测试点，不保证询问操作和修改操作的先后顺序。\n\n本题共 25 个测试点，每个测试点 4 分。各个测试点的数据范围如下：\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\le$ | $t_1$ | $t_2$ | $t_3$ |\n|:-:|:-:|:-:|:-:|:-:|\n| $1$ | $10$ | $3$ | $1$ | $2$ |\n| $2$ | $100$ | $3$ | $2$ | $2$ |\n| $3$ | $2000$ | $3$ | $2$ | $2$ |\n| $4$ | $4000$ | $1$ | $3$ | $2$ |\n| $5$ | $6000$ | $3$ | $3$ | $1$ |\n| $6$ | $8000$ | $2$ | $3$ | $2$ |\n| $7$ | $9000$ | $3$ | $4$ | $2$ |\n| $8$ | $10000$ | $3$ | $3$ | $2$ |\n| $9$ | $30000$ | $3$ | $4$ | $2$ |\n| $10$ | $50000$ | $3$ | $4$ | $1$ |\n| $11$ | $60000$ | $3$ | $3$ | $2$ |\n| $12$ | $65000$ | $2$ | $4$ | $2$ |\n| $13$ | $70000$ | $3$ | $4$ | $2$ |\n| $14$ | $200000$ | $3$ | $4$ | $2$ |\n| $15$ | $300000$ | $2$ | $4$ | $2$ |\n| $16$ | $400000$ | $3$ | $4$ | $2$ |\n| $17$ | $500000$ | $3$ | $3$ | $2$ |\n| $18$ | $600000$ | $3$ | $4$ | $2$ |\n| $19$ | $700000$ | $3$ | $4$ | $2$ |\n| $20$ | $800000$ | $1$ | $4$ | $2$ |\n| $21$ | $900000$ | $2$ | $4$ | $2$ |\n| $22$ | $930000$ | $3$ | $3$ | $2$ |\n| $23$ | $960000$ | $3$ | $4$ | $1$ |\n| $24$ | $990000$ | $3$ | $3$ | $2$ |\n| $25$ | $1000000$ | $3$ | $4$ | $2$ |", "locale": "zh-CN"}}}
{"pid": "P3823", "type": "P", "difficulty": 6, "samples": [["5 9\n3 1 3 5 3\n3 333135 2\n3 333135 1\n1 1 3\n1 2 5\n1 3 2\n1 5 4\n3 333135 2\n3 333135 1\n3 333135 3", "0\n81\n1\n81\n0"], ["2 10\n6 6\n3 666666 1\n1 1 2\n3 666666 2\n3 666666 4\n3 666666666666666666666666666666 1\n2 1\n1 2 1\n3 666666 2\n3 666666 4\n3 666666666666666666666666666666 1", "64\n1\n0\n75497471\n1\n0\n75497471"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000]}, "tags": ["字符串", "2017", "NOI", "O2优化", "哈希 hashing"], "title": "[NOI2017] 蚯蚓排队", "background": null, "description": "蚯蚓幼儿园有 $n$ 只蚯蚓。幼儿园园长神刀手为了管理方便，时常让这些蚯蚓们列队表演。\n\n所有蚯蚓用从 $1$ 到 $n$ 的连续正整数编号。每只蚯蚓的长度可以用一个正整数表示，根据入园要求，所有蚯蚓的长度都不超过 $6$ 。神刀手希望这些蚯蚓排成若干个队伍，初始时，每只蚯蚓各自排成一个仅有一只蚯蚓的队伍，该蚯蚓既在队首，也在队尾。\n\n神刀手将会依次进行 $m$ 次操作，每个操作都是以下三种操作中的一种：\n\n1. 给出 $i$ 和 $j$ ，令 $i$ 号蚯蚓与 $j$ 号蚯蚓所在的两个队伍合并为一个队伍，具体来说，令 $j$ 号蚯蚓紧挨在 $i$ 号蚯蚓之后，其余蚯蚓保持队伍的前后关系不变。\n\n2. 给出 $i$ ，令 $i$ 号蚯蚓与紧挨其后的一只蚯蚓分离为两个队伍，具体来说，在分离之后， $i$ 号蚯蚓在其中一个队伍的队尾，原本紧挨其后的那一只蚯蚓在另一个队伍的队首，其余蚯蚓保持队伍的前后关系不变。\n\n3. 给出一个正整数 $k$ 和一个长度至少为 $k$ 的数字串 $s$ ，对于 $s$ 的每个长度为 $k$ 的连续子串 $t$ （这样的子串共有 $|s|-k+1$ 个，其中 $|s|$ 为 $s$ 的长度），定义函数 $f(t)$，询问所有这些 $f(t)$ 的**乘积**对 $998244353$ 取模后的结果。其中 $f(t)$ 的定义如下：\n\n对于当前的蚯蚓队伍，定义某个蚯蚓的**向后 $k$ 数字串**为：从该蚯蚓出发，沿队伍的向后方向，寻找最近的 $k$ 只蚯蚓（包括其自身），将这些蚯蚓的长度视作字符连接而成的数字串；如果这样找到的蚯蚓不足 $k$ 只，则其没有**向后 $k$ 数字串**。例如蚯蚓的队伍为 $10$ 号蚯蚓在队首，其后是 $22$ 号蚯蚓，其后是 $3$ 号蚯蚓（为队尾），这些蚯蚓的长度分别为 $4$ 、 $5$ 、 $6$ ，则 $10$ 号蚯蚓的**向后 $3$ 数字串**为 `456`， $22$ 号蚯蚓没有**向后 $3$ 数字串**，但其**向后 $2$ 数字串**为 `56`，其**向后 $1$ 数字串**为 `5`。\n\n而 $f(t)$ 表示所有蚯蚓中，**向后 $k$ 数字串**恰好为 $t$ 的蚯蚓只数。", "inputFormat": "输入文件的第一行有两个正整数 $n,m$ ，分别表示蚯蚓的只数与操作次数。\n\n第二行包含 $n$ 个不超过 $6$ 的正整数，依次表示编号为 $1,2,\\dots,n$ 的蚯蚓的长度。\n\n接下来 $m$ 行，每行表示一个操作。每个操作的格式可以为：\n\n* `1` $i$ $j$（$1 \\leq i, j \\leq n$）表示：令 $i$ 号与 $j$ 号蚯蚓**所在**的两个队伍合并为一个队伍，新队伍中，$j$ 号蚯蚓紧挨在 $i$ 号蚯蚓之后。保证在此操作之前，$i$ 号蚯蚓在某个队伍的队尾，$j$ 号蚯蚓在某个队伍的队首，且两只蚯蚓不在同一个队伍中。\n\n* `2` $i$（$1 \\leq i \\leq n$）表示：令 $i$ 号蚯蚓与紧挨其后一个蚯蚓分离为两个队伍。保证在此操作之前，$i$ 号蚯蚓不是某个队伍的队尾。\n\n* `3` $s$ $k$（$k$ 为正整数，$s$ 为一个长度至少为 $k$ 的数字串）表示：询问 $s$ 的每个长度为 $k$ 的子串 $t$ 的 $f(t)$ 的乘积，对 $998244353$ 取模的结果。$f(t)$ 的定义见题目描述。\n\n同一行输入的相邻两个元素之间，用恰好一个空格隔开。\n\n输入文件可能较大，请不要使用过于缓慢的读入方式。", "outputFormat": "依次对于每个形如 `3 s k` 的操作，输出一行，仅包含一个整数，表示询问的结果。", "hint": "保证 $n \\leq 2 \\times 10^{5}$，$m \\leq 5 \\times 10^{5}$，$k \\leq 50$ 。\n\n设 $\\sum |s|$ 为某个输入文件中所有询问的 $s$ 的长度总和，则 $\\sum |s| \\leq 10^{7}$  。\n\n设 $c$ 为某个输入文件中形如 `2 i` 的操作的次数，则 $c \\leq 10^{3}$ 。\n\n每个测试点的详细信息见下表：\n\n| 测试点编号 | $n$ | $m$ | $k$ | $\\sum \\|s\\|$ | $c$ | 全为 $\\texttt{1}$ |\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n| 1 | $=1$ | $\\leq 10^{3}$ | $=1$ | $\\leq 10^{3}$ | $=0$ | No |\n| 2 | $\\leq 20$ | $\\leq 40$ | $\\leq 10$ | $\\leq 10^{3}$ | $=0$ | No |\n| 3 | $\\leq 150$ | $\\leq 2,000$ | $\\leq 50$ | $\\leq 10^{3}$ | $\\leq 10^{3}$ | No |\n| 4 | $\\leq 500$ | $\\leq 600$ | $\\leq 50$ | $\\leq 10^{3}$ | $=0$ | No |\n| 5 | $\\leq 10^{3}$ | $\\leq 2,000$ | $\\leq 50$ | $\\leq 10^{3}$ | $\\leq 10^{3}$ | No |\n| 6 | $\\leq 5 \\times 10^{4}$ | $\\leq 6 \\times 10^{4}$ | $\\leq 5$ | $\\leq 5 \\times 10^{4}$ | $\\leq 10^{3}$ | No |\n| 7 | $\\leq 5 \\times 10^{4}$ | $\\leq 6 \\times 10^{4}$ | $\\leq 50$ | $\\leq 5 \\times 10^{4}$ | $=0$ | Yes |\n| 8 | $\\leq 5 \\times 10^{4}$ | $\\leq 6 \\times 10^{4}$ | $\\leq 50$ | $\\leq 5 \\times 10^{4}$ | $=0$ | No |\n| 9 | $\\leq 5 \\times 10^{4}$ | $\\leq 6 \\times 10^{4}$ | $\\leq 50$ | $\\leq 5 \\times 10^{4}$ | $\\leq 10^{3}$ | No |\n| 10 | $\\leq 5 \\times 10^{4}$ | $\\leq 8 \\times 10^{4}$ | $\\leq 50$ | $\\leq 2.5 \\times 10^{6}$ | $=0$ | No |\n| 11 | $\\leq 5 \\times 10^{4}$ | $\\leq 8 \\times 10^{4}$ | $\\leq 50$ | $\\leq 2.5 \\times 10^{6}$ | $\\leq 10^{3}$ | No |\n| 12 | $\\leq 10^{5}$ | $\\leq 1.1 \\times 10^{5}$ | $\\leq 6$ | $\\leq 10^{5}$ | $\\leq 10^{3}$ | No |\n| 13 | $\\leq 10^{5}$ | $\\leq 1.1 \\times 10^{5}$ | $\\leq 50$ | $\\leq 10^{5}$ | $=0$ | Yes |\n| 14 | $\\leq 10^{5}$ | $\\leq 1.1 \\times 10^{5}$ | $\\leq 50$ | $\\leq 10^{5}$ | $=0$ | No |\n| 15 | $\\leq 10^{5}$ | $\\leq 1.1 \\times 10^{5}$ | $\\leq 50$ | $\\leq 10^{5}$ | $\\leq 10^{3}$ | No |\n| 16 | $\\leq 10^{5}$ | $\\leq 1.5 \\times 10^{5}$ | $\\leq 50$ | $\\leq 5 \\times 10^{6}$ | $=0$ | No |\n| 17 | $\\leq 10^{5}$ | $\\leq 1.5 \\times 10^{5}$ | $\\leq 50$ | $\\leq 5 \\times 10^{6}$ | $\\leq 10^{3}$ | No |\n| 18 | $\\leq 2 \\times 10^{5}$ | $\\leq 5 \\times 10^{5}$ | $=1$ | $\\leq 10^{7}$ | $=0$ | No |\n| 19 | $\\leq 2 \\times 10^{5}$ | $\\leq 5 \\times 10^{5}$ | $=1$ | $\\leq 10^{7}$ | $\\leq 10^{3}$ | No |\n| 20 | $\\leq 2 \\times 10^{5}$ | $\\leq 2.5 \\times 10^{5}$ | $\\leq 7$ | $\\leq 2 \\times 10^{5}$ | $\\leq 10^{3}$ | No |\n| 21 | $\\leq 2 \\times 10^{5}$ | $\\leq 2.5 \\times 10^{5}$ | $\\leq 50$ | $\\leq 2 \\times 10^{5}$ | $=0$ | Yes |\n| 22 | $\\leq 2 \\times 10^{5}$ | $\\leq 2.5 \\times 10^{5}$ | $\\leq 50$ | $\\leq 2 \\times 10^{5}$ | $=0$ | No |\n| 23 | $\\leq 2 \\times 10^{5}$ | $\\leq 2.5 \\times 10^{5}$ | $\\leq 50$ | $\\leq 2 \\times 10^{5}$ | $\\leq 10^{3}$ | No |\n| 24 | $\\leq 2 \\times 10^{5}$ | $\\leq 3 \\times 10^{5}$ | $\\leq 50$ | $\\leq 10^{7}$ | $=0$ | No |\n| 25 | $\\leq 2 \\times 10^{5}$ | $\\leq 3 \\times 10^{5}$ | $\\leq 50$ | $\\leq 10^{7}$ | $\\leq 10^{3}$ | No |\n\n如果一个测试点的“全为`1`”的一列为“Yes”，表示该测试点的所有蚯蚓的长度均为 1，并且所有询问串 $s$ 的每一位也均为`1`。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2017] Earthworms Queueing", "background": "", "description": "There are $n$ earthworms in a kindergarten. For easier management, the principal Shen Dao Shou often asks the earthworms to line up and perform.\n\nAll earthworms are numbered with consecutive positive integers from $1$ to $n$. The length of each earthworm is a positive integer, and by admission requirements, all lengths do not exceed $6$. Shen Dao Shou wants these earthworms to form several queues. Initially, each earthworm forms a queue by itself, where that earthworm is both the head and the tail of its queue.\n\nShen Dao Shou will perform $m$ operations in sequence. Each operation is one of the following three types:\n\n1. Given $i$ and $j$, merge the two queues containing earthworms $i$ and $j$ into a single queue. Specifically, place earthworm $j$ immediately after earthworm $i$, and keep the relative order of all other earthworms unchanged.\n\n2. Given $i$, split earthworm $i$ and the earthworm immediately after it into two queues. Specifically, after the split, earthworm $i$ becomes the tail of one queue, and the earthworm that was immediately after it becomes the head of the other queue. The relative order of all other earthworms remains unchanged.\n\n3. Given a positive integer $k$ and a digit string $s$ of length at least $k$, for every length-$k$ contiguous substring $t$ of $s$ (there are $|s|-k+1$ such substrings, where $|s|$ is the length of $s$), define a function $f(t)$ and ask for the product of all these $f(t)$ values modulo $998244353$. The definition of $f(t)$ is as follows:\n\nFor the current queues of earthworms, define an earthworm’s backward $k$-digit string as follows: starting from that earthworm and moving along the queue towards the back, find the nearest $k$ earthworms (including itself) and concatenate their lengths as characters to form a digit string. If fewer than $k$ earthworms can be found this way, then it does not have a backward $k$-digit string. For example, if the queue of earthworms has earthworm $10$ at the head, followed by earthworm $22$, followed by earthworm $3$ (which is at the tail), and their lengths are $4$, $5$, and $6$ respectively, then the backward $3$-digit string of earthworm $10$ is `456`. Earthworm $22$ does not have a backward $3$-digit string, but its backward $2$-digit string is `56`, and its backward $1$-digit string is `5`.\n\nThen $f(t)$ denotes the number of earthworms whose backward $k$-digit string is exactly $t$.", "inputFormat": "The first line contains two positive integers $n, m$, denoting the number of earthworms and the number of operations.\n\nThe second line contains $n$ positive integers not exceeding $6$, in order, denoting the lengths of earthworms numbered $1, 2, \\dots, n$.\n\nEach of the next $m$ lines describes an operation, in one of the following formats:\n\n- `1` $i$ $j$ ($1 \\leq i, j \\leq n$): Merge the two queues containing earthworms $i$ and $j$ into one queue, and in the new queue, place earthworm $j$ immediately after earthworm $i$. It is guaranteed that before this operation, earthworm $i$ is at the tail of some queue, earthworm $j$ is at the head of some queue, and the two earthworms are not in the same queue.\n\n- `2` $i$ ($1 \\leq i \\leq n$): Split earthworm $i$ and the earthworm immediately after it into two queues. It is guaranteed that before this operation, earthworm $i$ is not the tail of its queue.\n\n- `3` $s$ $k$ ($k$ is a positive integer, and $s$ is a digit string of length at least $k$): Query the product of $f(t)$ over every length-$k$ substring $t$ of $s$, modulo $998244353$. The definition of $f(t)$ is given in the problem statement.\n\nAdjacent elements on the same line are separated by exactly one space.\n\nThe input file can be large. Please avoid overly slow input methods.", "outputFormat": "For each operation of the form `3 s k`, output a single line containing a single integer, which is the answer to that query.", "hint": "Constraints:\n\nIt is guaranteed that $n \\leq 2 \\times 10^{5}$, $m \\leq 5 \\times 10^{5}$, $k \\leq 50$.\n\nLet $\\sum |s|$ be the total length of all query strings $s$ in an input file. Then $\\sum |s| \\leq 10^{7}$.\n\nLet $c$ be the number of operations of the form `2 i` in an input file. Then $c \\leq 10^{3}$.\n\nDetails for each test point are shown in the table below:\n\n| Test Point | $n$ | $m$ | $k$ | $\\sum |s|$ | $c$ | All are $\\texttt{1}$ |\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n| 1 | $=1$ | $\\leq 10^{3}$ | $=1$ | $\\leq 10^{3}$ | $=0$ | No |\n| 2 | $\\leq 20$ | $\\leq 40$ | $\\leq 10$ | $\\leq 10^{3}$ | $=0$ | No |\n| 3 | $\\leq 150$ | $\\leq 2,000$ | $\\leq 50$ | $\\leq 10^{3}$ | $\\leq 10^{3}$ | No |\n| 4 | $\\leq 500$ | $\\leq 600$ | $\\leq 50$ | $\\leq 10^{3}$ | $=0$ | No |\n| 5 | $\\leq 10^{3}$ | $\\leq 2,000$ | $\\leq 50$ | $\\leq 10^{3}$ | $\\leq 10^{3}$ | No |\n| 6 | $\\leq 5 \\times 10^{4}$ | $\\leq 6 \\times 10^{4}$ | $\\leq 5$ | $\\leq 5 \\times 10^{4}$ | $\\leq 10^{3}$ | No |\n| 7 | $\\leq 5 \\times 10^{4}$ | $\\leq 6 \\times 10^{4}$ | $\\leq 50$ | $\\leq 5 \\times 10^{4}$ | $=0$ | Yes |\n| 8 | $\\leq 5 \\times 10^{4}$ | $\\leq 6 \\times 10^{4}$ | $\\leq 50$ | $\\leq 5 \\times 10^{4}$ | $=0$ | No |\n| 9 | $\\leq 5 \\times 10^{4}$ | $\\leq 6 \\times 10^{4}$ | $\\leq 50$ | $\\leq 5 \\times 10^{4}$ | $\\leq 10^{3}$ | No |\n| 10 | $\\leq 5 \\times 10^{4}$ | $\\leq 8 \\times 10^{4}$ | $\\leq 50$ | $\\leq 2.5 \\times 10^{6}$ | $=0$ | No |\n| 11 | $\\leq 5 \\times 10^{4}$ | $\\leq 8 \\times 10^{4}$ | $\\leq 50$ | $\\leq 2.5 \\times 10^{6}$ | $\\leq 10^{3}$ | No |\n| 12 | $\\leq 10^{5}$ | $\\leq 1.1 \\times 10^{5}$ | $\\leq 6$ | $\\leq 10^{5}$ | $\\leq 10^{3}$ | No |\n| 13 | $\\leq 10^{5}$ | $\\leq 1.1 \\times 10^{5}$ | $\\leq 50$ | $\\leq 10^{5}$ | $=0$ | Yes |\n| 14 | $\\leq 10^{5}$ | $\\leq 1.1 \\times 10^{5}$ | $\\leq 50$ | $\\leq 10^{5}$ | $=0$ | No |\n| 15 | $\\leq 10^{5}$ | $\\leq 1.1 \\times 10^{5}$ | $\\leq 50$ | $\\leq 10^{5}$ | $\\leq 10^{3}$ | No |\n| 16 | $\\leq 10^{5}$ | $\\leq 1.5 \\times 10^{5}$ | $\\leq 50$ | $\\leq 5 \\times 10^{6}$ | $=0$ | No |\n| 17 | $\\leq 10^{5}$ | $\\leq 1.5 \\times 10^{5}$ | $\\leq 50$ | $\\leq 5 \\times 10^{6}$ | $\\leq 10^{3}$ | No |\n| 18 | $\\leq 2 \\times 10^{5}$ | $\\leq 5 \\times 10^{5}$ | $=1$ | $\\leq 10^{7}$ | $=0$ | No |\n| 19 | $\\leq 2 \\times 10^{5}$ | $\\leq 5 \\times 10^{5}$ | $=1$ | $\\leq 10^{7}$ | $\\leq 10^{3}$ | No |\n| 20 | $\\leq 2 \\times 10^{5}$ | $\\leq 2.5 \\times 10^{5}$ | $\\leq 7$ | $\\leq 2 \\times 10^{5}$ | $\\leq 10^{3}$ | No |\n| 21 | $\\leq 2 \\times 10^{5}$ | $\\leq 2.5 \\times 10^{5}$ | $\\leq 50$ | $\\leq 2 \\times 10^{5}$ | $=0$ | Yes |\n| 22 | $\\leq 2 \\times 10^{5}$ | $\\leq 2.5 \\times 10^{5}$ | $\\leq 50$ | $\\leq 2 \\times 10^{5}$ | $=0$ | No |\n| 23 | $\\leq 2 \\times 10^{5}$ | $\\leq 2.5 \\times 10^{5}$ | $\\leq 50$ | $\\leq 2 \\times 10^{5}$ | $\\leq 10^{3}$ | No |\n| 24 | $\\leq 2 \\times 10^{5}$ | $\\leq 3 \\times 10^{5}$ | $\\leq 50$ | $\\leq 10^{7}$ | $=0$ | No |\n| 25 | $\\leq 2 \\times 10^{5}$ | $\\leq 3 \\times 10^{5}$ | $\\leq 50$ | $\\leq 10^{7}$ | $\\leq 10^{3}$ | No |\n\nIf the “All are `1`” column of a test point is “Yes”, it means all earthworms have length $1$, and every digit in every query string $s$ is also `1`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2017] 蚯蚓排队", "background": null, "description": "蚯蚓幼儿园有 $n$ 只蚯蚓。幼儿园园长神刀手为了管理方便，时常让这些蚯蚓们列队表演。\n\n所有蚯蚓用从 $1$ 到 $n$ 的连续正整数编号。每只蚯蚓的长度可以用一个正整数表示，根据入园要求，所有蚯蚓的长度都不超过 $6$ 。神刀手希望这些蚯蚓排成若干个队伍，初始时，每只蚯蚓各自排成一个仅有一只蚯蚓的队伍，该蚯蚓既在队首，也在队尾。\n\n神刀手将会依次进行 $m$ 次操作，每个操作都是以下三种操作中的一种：\n\n1. 给出 $i$ 和 $j$ ，令 $i$ 号蚯蚓与 $j$ 号蚯蚓所在的两个队伍合并为一个队伍，具体来说，令 $j$ 号蚯蚓紧挨在 $i$ 号蚯蚓之后，其余蚯蚓保持队伍的前后关系不变。\n\n2. 给出 $i$ ，令 $i$ 号蚯蚓与紧挨其后的一只蚯蚓分离为两个队伍，具体来说，在分离之后， $i$ 号蚯蚓在其中一个队伍的队尾，原本紧挨其后的那一只蚯蚓在另一个队伍的队首，其余蚯蚓保持队伍的前后关系不变。\n\n3. 给出一个正整数 $k$ 和一个长度至少为 $k$ 的数字串 $s$ ，对于 $s$ 的每个长度为 $k$ 的连续子串 $t$ （这样的子串共有 $|s|-k+1$ 个，其中 $|s|$ 为 $s$ 的长度），定义函数 $f(t)$，询问所有这些 $f(t)$ 的**乘积**对 $998244353$ 取模后的结果。其中 $f(t)$ 的定义如下：\n\n对于当前的蚯蚓队伍，定义某个蚯蚓的**向后 $k$ 数字串**为：从该蚯蚓出发，沿队伍的向后方向，寻找最近的 $k$ 只蚯蚓（包括其自身），将这些蚯蚓的长度视作字符连接而成的数字串；如果这样找到的蚯蚓不足 $k$ 只，则其没有**向后 $k$ 数字串**。例如蚯蚓的队伍为 $10$ 号蚯蚓在队首，其后是 $22$ 号蚯蚓，其后是 $3$ 号蚯蚓（为队尾），这些蚯蚓的长度分别为 $4$ 、 $5$ 、 $6$ ，则 $10$ 号蚯蚓的**向后 $3$ 数字串**为 `456`， $22$ 号蚯蚓没有**向后 $3$ 数字串**，但其**向后 $2$ 数字串**为 `56`，其**向后 $1$ 数字串**为 `5`。\n\n而 $f(t)$ 表示所有蚯蚓中，**向后 $k$ 数字串**恰好为 $t$ 的蚯蚓只数。", "inputFormat": "输入文件的第一行有两个正整数 $n,m$ ，分别表示蚯蚓的只数与操作次数。\n\n第二行包含 $n$ 个不超过 $6$ 的正整数，依次表示编号为 $1,2,\\dots,n$ 的蚯蚓的长度。\n\n接下来 $m$ 行，每行表示一个操作。每个操作的格式可以为：\n\n* `1` $i$ $j$（$1 \\leq i, j \\leq n$）表示：令 $i$ 号与 $j$ 号蚯蚓**所在**的两个队伍合并为一个队伍，新队伍中，$j$ 号蚯蚓紧挨在 $i$ 号蚯蚓之后。保证在此操作之前，$i$ 号蚯蚓在某个队伍的队尾，$j$ 号蚯蚓在某个队伍的队首，且两只蚯蚓不在同一个队伍中。\n\n* `2` $i$（$1 \\leq i \\leq n$）表示：令 $i$ 号蚯蚓与紧挨其后一个蚯蚓分离为两个队伍。保证在此操作之前，$i$ 号蚯蚓不是某个队伍的队尾。\n\n* `3` $s$ $k$（$k$ 为正整数，$s$ 为一个长度至少为 $k$ 的数字串）表示：询问 $s$ 的每个长度为 $k$ 的子串 $t$ 的 $f(t)$ 的乘积，对 $998244353$ 取模的结果。$f(t)$ 的定义见题目描述。\n\n同一行输入的相邻两个元素之间，用恰好一个空格隔开。\n\n输入文件可能较大，请不要使用过于缓慢的读入方式。", "outputFormat": "依次对于每个形如 `3 s k` 的操作，输出一行，仅包含一个整数，表示询问的结果。", "hint": "保证 $n \\leq 2 \\times 10^{5}$，$m \\leq 5 \\times 10^{5}$，$k \\leq 50$ 。\n\n设 $\\sum |s|$ 为某个输入文件中所有询问的 $s$ 的长度总和，则 $\\sum |s| \\leq 10^{7}$  。\n\n设 $c$ 为某个输入文件中形如 `2 i` 的操作的次数，则 $c \\leq 10^{3}$ 。\n\n每个测试点的详细信息见下表：\n\n| 测试点编号 | $n$ | $m$ | $k$ | $\\sum \\|s\\|$ | $c$ | 全为 $\\texttt{1}$ |\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n| 1 | $=1$ | $\\leq 10^{3}$ | $=1$ | $\\leq 10^{3}$ | $=0$ | No |\n| 2 | $\\leq 20$ | $\\leq 40$ | $\\leq 10$ | $\\leq 10^{3}$ | $=0$ | No |\n| 3 | $\\leq 150$ | $\\leq 2,000$ | $\\leq 50$ | $\\leq 10^{3}$ | $\\leq 10^{3}$ | No |\n| 4 | $\\leq 500$ | $\\leq 600$ | $\\leq 50$ | $\\leq 10^{3}$ | $=0$ | No |\n| 5 | $\\leq 10^{3}$ | $\\leq 2,000$ | $\\leq 50$ | $\\leq 10^{3}$ | $\\leq 10^{3}$ | No |\n| 6 | $\\leq 5 \\times 10^{4}$ | $\\leq 6 \\times 10^{4}$ | $\\leq 5$ | $\\leq 5 \\times 10^{4}$ | $\\leq 10^{3}$ | No |\n| 7 | $\\leq 5 \\times 10^{4}$ | $\\leq 6 \\times 10^{4}$ | $\\leq 50$ | $\\leq 5 \\times 10^{4}$ | $=0$ | Yes |\n| 8 | $\\leq 5 \\times 10^{4}$ | $\\leq 6 \\times 10^{4}$ | $\\leq 50$ | $\\leq 5 \\times 10^{4}$ | $=0$ | No |\n| 9 | $\\leq 5 \\times 10^{4}$ | $\\leq 6 \\times 10^{4}$ | $\\leq 50$ | $\\leq 5 \\times 10^{4}$ | $\\leq 10^{3}$ | No |\n| 10 | $\\leq 5 \\times 10^{4}$ | $\\leq 8 \\times 10^{4}$ | $\\leq 50$ | $\\leq 2.5 \\times 10^{6}$ | $=0$ | No |\n| 11 | $\\leq 5 \\times 10^{4}$ | $\\leq 8 \\times 10^{4}$ | $\\leq 50$ | $\\leq 2.5 \\times 10^{6}$ | $\\leq 10^{3}$ | No |\n| 12 | $\\leq 10^{5}$ | $\\leq 1.1 \\times 10^{5}$ | $\\leq 6$ | $\\leq 10^{5}$ | $\\leq 10^{3}$ | No |\n| 13 | $\\leq 10^{5}$ | $\\leq 1.1 \\times 10^{5}$ | $\\leq 50$ | $\\leq 10^{5}$ | $=0$ | Yes |\n| 14 | $\\leq 10^{5}$ | $\\leq 1.1 \\times 10^{5}$ | $\\leq 50$ | $\\leq 10^{5}$ | $=0$ | No |\n| 15 | $\\leq 10^{5}$ | $\\leq 1.1 \\times 10^{5}$ | $\\leq 50$ | $\\leq 10^{5}$ | $\\leq 10^{3}$ | No |\n| 16 | $\\leq 10^{5}$ | $\\leq 1.5 \\times 10^{5}$ | $\\leq 50$ | $\\leq 5 \\times 10^{6}$ | $=0$ | No |\n| 17 | $\\leq 10^{5}$ | $\\leq 1.5 \\times 10^{5}$ | $\\leq 50$ | $\\leq 5 \\times 10^{6}$ | $\\leq 10^{3}$ | No |\n| 18 | $\\leq 2 \\times 10^{5}$ | $\\leq 5 \\times 10^{5}$ | $=1$ | $\\leq 10^{7}$ | $=0$ | No |\n| 19 | $\\leq 2 \\times 10^{5}$ | $\\leq 5 \\times 10^{5}$ | $=1$ | $\\leq 10^{7}$ | $\\leq 10^{3}$ | No |\n| 20 | $\\leq 2 \\times 10^{5}$ | $\\leq 2.5 \\times 10^{5}$ | $\\leq 7$ | $\\leq 2 \\times 10^{5}$ | $\\leq 10^{3}$ | No |\n| 21 | $\\leq 2 \\times 10^{5}$ | $\\leq 2.5 \\times 10^{5}$ | $\\leq 50$ | $\\leq 2 \\times 10^{5}$ | $=0$ | Yes |\n| 22 | $\\leq 2 \\times 10^{5}$ | $\\leq 2.5 \\times 10^{5}$ | $\\leq 50$ | $\\leq 2 \\times 10^{5}$ | $=0$ | No |\n| 23 | $\\leq 2 \\times 10^{5}$ | $\\leq 2.5 \\times 10^{5}$ | $\\leq 50$ | $\\leq 2 \\times 10^{5}$ | $\\leq 10^{3}$ | No |\n| 24 | $\\leq 2 \\times 10^{5}$ | $\\leq 3 \\times 10^{5}$ | $\\leq 50$ | $\\leq 10^{7}$ | $=0$ | No |\n| 25 | $\\leq 2 \\times 10^{5}$ | $\\leq 3 \\times 10^{5}$ | $\\leq 50$ | $\\leq 10^{7}$ | $\\leq 10^{3}$ | No |\n\n如果一个测试点的“全为`1`”的一列为“Yes”，表示该测试点的所有蚯蚓的长度均为 1，并且所有询问串 $s$ 的每一位也均为`1`。", "locale": "zh-CN"}}}
{"pid": "P3824", "type": "P", "difficulty": 7, "samples": [["10 5 1 2", "342025319"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 2000, 2500, 2500, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2017", "多项式", "NOI", "O2优化", "动态规划优化", "前缀和", "概率论", "线性递推", "向量"], "title": "[NOI2017] 泳池", "background": "久莲是个爱玩的女孩子。\n\n暑假终于到了，久莲决定请她的朋友们来游泳，她打算先在她家的私人海滩外圈一块长方形的海域作为游泳场。然而大海里有着各种各样的危险，有些地方水太深，有些地方有带毒的水母出没。她想让圈出来的这一块海域都是安全的。\n", "description": "经过初步分析，这块海域可视为一个底边长为 $N$ 米，高为 $1001$ 米的长方形网格。其中网格的底边对应着她家的私人海滩，每一个 $1\\:\\textrm{m}\\times1\\:\\textrm{m}$ 的小正方形都代表着一个单位海域。她拜托了她爸爸明天去测量每一个小正方形是否安全。在得知了信息之后，她要做的就是圈出她想要的游泳场啦。  \n\n她心目中理想的游泳场满足如下三个条件：\n- 必须保证安全性。即游泳场中的每一个单位海域都是安全的。\n- 必须是矩形。即游泳场必须是整个网格中的一个 $a\\times b$ 的子网格。\n- 必须和海滩相邻。即游泳场的下边界必须紧贴网格的下边界。\n\n例如：当 $N = 5$ 时，若测量的结果如下（因为 $1001$ 太大，这儿只画出网格最下面三行的信息，其他部分都是危险的）。 \n\n ![](https://cdn.luogu.com.cn/upload/pic/6465.png) \n\n那么她可以选取最下面一行的 $1\\times4$ 的子海域，也可以选择第三列的 $3\\times1$ 的子海域。注意她不能选取最上面一行的 $1\\times5$ 的子海域，因为它没有与海滩相邻。\n\n为了让朋友们玩的开心，她想让游泳场的面积尽可能的大。因此她会选取最下面那一行的 $1\\times4$ 的子海域作为最终方案。\n\n虽然她要明天才能知道每一个单位海域是否安全，但是她现在就想行动起来估计一下她的游泳场面积有多大。经过简单的估计，她假设每一个单位海域都有独立的 $q$ 的概率是安全的，$1 − q$ 的概率是不安全的。她想要知道她能选择的最大的游泳场的面积**恰好**为 $K$ 的概率是多少。\n\n然而久莲对数学并不感兴趣，因此她想让你来帮她计算一下这个数值。", "inputFormat": "输入一行四个正整数 $N,K,x,y$，其中 $1 \\leq x < y < 998\\,244\\,353$。$q$ 的取值为 $\\dfrac{x}{y}$。", "outputFormat": "输出一行一个整数表示答案在模 $998\\,244\\,353$ 意义下的取值。\n\n即设答案化为最简分式后的形式为 $\\dfrac{a}{b}$ ，其中 $a$ 和 $b$ 的互质。输出整数 $x$ 使得 $bx \\equiv a \\mod 998\\,244\\,353$ 且 $0 \\leq x < 998\\,244\\,353$。可以证明这样的整数 $x$ 是唯一的。 ", "hint": "| 测试点编号 | $N$ | $K$ |\n|:-:|:-:|:-:|\n| 1,2 | $=1$ | $\\leq 1000$ |\n| 3 | $\\leq 10$ | $\\leq 8$ |\n| 4 | $\\leq 10$ | $\\leq 9$ |\n| 5 | $\\leq 10$ | $\\leq 10$ |\n| 6 | $\\leq 1000$ | $\\leq 7$ |\n| 7 | $\\leq 1000$ | $\\leq 8$ |\n| 8 | $\\leq 1000$ | $\\leq 9$ |\n| 9,10,11 | $\\leq 1000$ | $\\leq 100$ |\n| 12,13,14 | $\\leq 1000$ | $\\leq 1000$ |\n| 15,16 | $\\leq 10^9$ | $\\leq 10$ |\n| 17,18 | $\\leq 10^9$ | $\\leq 100$ |\n| 19,20 | $\\leq 10^9$ | $\\leq 1000$ |", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2017] Swimming Pool", "background": "Jiulian is a playful girl.\n\nSummer vacation has finally arrived. Jiulian decides to invite her friends to go swimming, and she plans to fence off a rectangular sea area outside her private beach as the swimming field. However, the ocean has all kinds of dangers: some places are too deep, and some have poisonous jellyfish. She wants the fenced area to be completely safe.", "description": "After preliminary analysis, this sea area can be viewed as a rectangular grid with base length $N$ meters and height $1001$ meters. The base of the grid corresponds to her private beach, and each $1\\:\\textrm{m} \\times 1\\:\\textrm{m}$ small square represents one unit sea area. She will ask her father to measure tomorrow whether each small square is safe. After obtaining the information, all she needs to do is to fence out her desired swimming field.\n\nHer ideal swimming field must satisfy the following three conditions:\n- Safety. Every unit sea area in the swimming field must be safe.\n- Rectangular. The swimming field must be an $a \\times b$ subgrid of the whole grid.\n- Adjacent to the beach. The lower boundary of the swimming field must be flush with the bottom boundary of the grid.\n\nFor example: when $N = 5$, suppose the measurement results are as follows (since $1001$ is too large, only the bottom three rows are shown here; the other parts are unsafe).\n\n![](https://cdn.luogu.com.cn/upload/pic/6465.png)\n\nThen she can select the $1 \\times 4$ subregion in the bottom row, or the $3 \\times 1$ subregion in the third column. Note that she cannot select the $1 \\times 5$ subregion in the top row because it is not adjacent to the beach.\n\nTo maximize her friends’ fun, she wants the swimming field to have the largest possible area. Therefore she would choose the $1 \\times 4$ subregion in the bottom row as the final plan.\n\nAlthough she will only know tomorrow whether each unit sea area is safe, she wants to estimate now how large the area of her swimming field might be. With a simple estimate, she assumes each unit sea area is independently safe with probability $q$ and unsafe with probability $1 - q$. She wants to know the probability that the maximum area of a selectable swimming field is exactly $K$.\n\nHowever, Jiulian is not interested in mathematics, so she wants you to help her compute this value.", "inputFormat": "The input contains one line with four positive integers $N, K, x, y$, where $1 \\leq x < y < 998\\,244\\,353$. The value of $q$ is $\\dfrac{x}{y}$.", "outputFormat": "Output one integer: the value of the answer modulo $998\\,244\\,353$.\n\nThat is, write the answer as a reduced fraction $\\dfrac{a}{b}$ with $\\gcd(a, b) = 1$. Output the integer $x$ such that $b x \\equiv a \\bmod 998\\,244\\,353$ and $0 \\leq x < 998\\,244\\,353$. It can be proven that such an integer $x$ is unique.", "hint": "| Test point ID | $N$ | $K$ |\n|:-:|:-:|:-:|\n| 1,2 | $= 1$ | $\\leq 1000$ |\n| 3 | $\\leq 10$ | $\\leq 8$ |\n| 4 | $\\leq 10$ | $\\leq 9$ |\n| 5 | $\\leq 10$ | $\\leq 10$ |\n| 6 | $\\leq 1000$ | $\\leq 7$ |\n| 7 | $\\leq 1000$ | $\\leq 8$ |\n| 8 | $\\leq 1000$ | $\\leq 9$ |\n| 9,10,11 | $\\leq 1000$ | $\\leq 100$ |\n| 12,13,14 | $\\leq 1000$ | $\\leq 1000$ |\n| 15,16 | $\\leq 10^9$ | $\\leq 10$ |\n| 17,18 | $\\leq 10^9$ | $\\leq 100$ |\n| 19,20 | $\\leq 10^9$ | $\\leq 1000$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2017] 泳池", "background": "久莲是个爱玩的女孩子。\n\n暑假终于到了，久莲决定请她的朋友们来游泳，她打算先在她家的私人海滩外圈一块长方形的海域作为游泳场。然而大海里有着各种各样的危险，有些地方水太深，有些地方有带毒的水母出没。她想让圈出来的这一块海域都是安全的。\n", "description": "经过初步分析，这块海域可视为一个底边长为 $N$ 米，高为 $1001$ 米的长方形网格。其中网格的底边对应着她家的私人海滩，每一个 $1\\:\\textrm{m}\\times1\\:\\textrm{m}$ 的小正方形都代表着一个单位海域。她拜托了她爸爸明天去测量每一个小正方形是否安全。在得知了信息之后，她要做的就是圈出她想要的游泳场啦。  \n\n她心目中理想的游泳场满足如下三个条件：\n- 必须保证安全性。即游泳场中的每一个单位海域都是安全的。\n- 必须是矩形。即游泳场必须是整个网格中的一个 $a\\times b$ 的子网格。\n- 必须和海滩相邻。即游泳场的下边界必须紧贴网格的下边界。\n\n例如：当 $N = 5$ 时，若测量的结果如下（因为 $1001$ 太大，这儿只画出网格最下面三行的信息，其他部分都是危险的）。 \n\n ![](https://cdn.luogu.com.cn/upload/pic/6465.png) \n\n那么她可以选取最下面一行的 $1\\times4$ 的子海域，也可以选择第三列的 $3\\times1$ 的子海域。注意她不能选取最上面一行的 $1\\times5$ 的子海域，因为它没有与海滩相邻。\n\n为了让朋友们玩的开心，她想让游泳场的面积尽可能的大。因此她会选取最下面那一行的 $1\\times4$ 的子海域作为最终方案。\n\n虽然她要明天才能知道每一个单位海域是否安全，但是她现在就想行动起来估计一下她的游泳场面积有多大。经过简单的估计，她假设每一个单位海域都有独立的 $q$ 的概率是安全的，$1 − q$ 的概率是不安全的。她想要知道她能选择的最大的游泳场的面积**恰好**为 $K$ 的概率是多少。\n\n然而久莲对数学并不感兴趣，因此她想让你来帮她计算一下这个数值。", "inputFormat": "输入一行四个正整数 $N,K,x,y$，其中 $1 \\leq x < y < 998\\,244\\,353$。$q$ 的取值为 $\\dfrac{x}{y}$。", "outputFormat": "输出一行一个整数表示答案在模 $998\\,244\\,353$ 意义下的取值。\n\n即设答案化为最简分式后的形式为 $\\dfrac{a}{b}$ ，其中 $a$ 和 $b$ 的互质。输出整数 $x$ 使得 $bx \\equiv a \\mod 998\\,244\\,353$ 且 $0 \\leq x < 998\\,244\\,353$。可以证明这样的整数 $x$ 是唯一的。 ", "hint": "| 测试点编号 | $N$ | $K$ |\n|:-:|:-:|:-:|\n| 1,2 | $=1$ | $\\leq 1000$ |\n| 3 | $\\leq 10$ | $\\leq 8$ |\n| 4 | $\\leq 10$ | $\\leq 9$ |\n| 5 | $\\leq 10$ | $\\leq 10$ |\n| 6 | $\\leq 1000$ | $\\leq 7$ |\n| 7 | $\\leq 1000$ | $\\leq 8$ |\n| 8 | $\\leq 1000$ | $\\leq 9$ |\n| 9,10,11 | $\\leq 1000$ | $\\leq 100$ |\n| 12,13,14 | $\\leq 1000$ | $\\leq 1000$ |\n| 15,16 | $\\leq 10^9$ | $\\leq 10$ |\n| 17,18 | $\\leq 10^9$ | $\\leq 100$ |\n| 19,20 | $\\leq 10^9$ | $\\leq 1000$ |", "locale": "zh-CN"}}}
{"pid": "P3825", "type": "P", "difficulty": 6, "samples": [["3 1\nxcc\n1\n1 A 2 B", "ABA"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "NOI", "Special Judge", "O2优化", "拓扑排序", "2-SAT", "强连通分量"], "title": "[NOI2017] 游戏", "background": "【本题原题时限 1s】\n\n狂野飙车是小 L 最喜欢的游戏。与其他业余玩家不同的是，小 L 在玩游戏之余，还精于研究游戏的设计，因此他有着与众不同的游戏策略。\n", "description": "小 L 计划进行 $n$ 场游戏，每场游戏使用一张地图，小 L 会选择一辆车在该地图上完成游戏。\n\n小 L 的赛车有三辆，分别用大写字母 $A$、$B$、$C$ 表示。地图一共有四种，分别用小写字母 $x$、$a$、$b$、$c$ 表示。\n\n其中，赛车 $A$ 不适合在地图 $a$ 上使用，赛车 $B$ 不适合在地图 $b$ 上使用，赛车 $C$ 不适合在地图 $c$ 上使用，而地图 $x$ 则适合所有赛车参加。\n\n适合所有赛车参加的地图并不多见，最多只会有 $d$ 张。\n\n$n$ 场游戏的地图可以用一个小写字母组成的字符串描述。例如：$S=\\texttt{xaabxcbc}$ 表示小 L 计划进行 $8$ 场游戏，其中第 $1$ 场和第 $5$ 场的地图类型是 $x$，适合所有赛车，第 $2$ 场和第 $3$ 场的地图是 $a$，不适合赛车 $A$，第 $4$ 场和第 $7$ 场的地图是 $b$，不适合赛车 $B$，第 $6$ 场和第 $8$ 场的地图是 $c$，不适合赛车 $C$。\n\n小 L 对游戏有一些特殊的要求，这些要求可以用四元组 $ (i, h_i, j, h_j) $ 来描述，表示若在第 $i$ 场使用型号为 $h_i$ 的车子，则第 $j$ 场游戏要使用型号为 $h_j$ 的车子。\n\n你能帮小 L 选择每场游戏使用的赛车吗？如果有多种方案，输出任意一种方案。\n\n如果无解，输出 `-1`。", "inputFormat": "输入第一行包含两个非负整数 $n$, $d$。\n\n输入第二行为一个字符串 $S$。\n\n$n$, $d$, $S$ 的含义见题目描述，其中 $S$ 包含 $n$ 个字符，且其中恰好 $d$ 个为小写字母 $x$。\n\n输入第三行为一个正整数 $m$ ，表示有 $m$ 条用车规则。\n\n接下来 $m$ 行，每行包含一个四元组 $i,h_i,j,h_j$ ，其中 $i,j$ 为整数，$h_i,h_j$ 为字符 $A$ 、$B$ 或 $C$，含义见题目描述。", "outputFormat": "输出一行。\n\n若无解输出 `-1`。\n\n若有解，则包含一个长度为 $n$ 的仅包含大写字母 A、B、C 的字符串，表示小 L 在这 $n$ 场游戏中如何安排赛车的使用。如果存在多组解，输出其中任意一组即可。", "hint": "### 样例 1 解释\n\n小 $L$ 计划进行 $3$ 场游戏，其中第 $1$ 场的地图类型是 $x$，适合所有赛车，第 $2$ 场和第 $3$ 场的地图是 $c$，不适合赛车 $C$。\n\n小 $L$ 希望：若第 $1$ 场游戏使用赛车 $A$，则第 $2$ 场游戏使用赛车 $B$。\n\n那么为这 $3$ 场游戏分别安排赛车 $A$、$B$、$A$ 可以满足所有条件。\n\n若依次为 $3$ 场游戏安排赛车为 $BBB$ 或 $BAA$ 时，也可以满足所有条件，也被视为正确答案。\n\n但依次安排赛车为 $AAB$ 或 $ABC$ 时，因为不能满足所有条件，所以不被视为正确答案。\n\n### 样例 2\n\n详见附加文件。\n\n### 数据范围\n\n| 测试点编号 |        $n$         |   $d$   |    $m$     |        其他性质         |\n| :--------: | :----------------: | :-----: | :--------: | :---------------------: |\n|    $1$     |      $\\le 2$       |   $0$   |  $\\le 4$   |           无            |\n|    $2$     |      $\\le 2$       | $\\le n$ |  $\\le 4$   |           无            |\n|    $3$     |      $\\le 5$       |   $0$   |  $\\le 10$  |           无            |\n|    $4$     |      $\\le 5$       | $\\le n$ |  $\\le 10$  |           无            |\n|    $5$     |      $\\le 10$      |   $0$   |  $\\le 20$  |           无            |\n|    $6$     |      $\\le 10$      | $\\le 8$ |  $\\le 20$  |           无            |\n|    $7$     |      $\\le 20$      |   $0$   |  $\\le 40$  |    $S$ 中只包含 $c$     |\n|    $8$     |      $\\le 20$      |   $0$   |  $\\le 40$  |           无            |\n|    $9$     |      $\\le 20$      | $\\le 8$ |  $\\le 40$  | $S$ 中只包含 $x$ 或 $c$ |\n|    $10$    |      $\\le 20$      | $\\le 8$ |  $\\le 40$  |           无            |\n|    $11$    |     $\\le 100$      |   $0$   | $\\le 200$  |    $S$ 中只包含 $c$     |\n|    $12$    |     $\\le 100$      |   $0$   | $\\le 200$  |           无            |\n|    $13$    |     $\\le 100$      | $\\le 8$ | $\\le 200$  | $S$ 中只包含 $x$ 或 $c$ |\n|    $14$    |     $\\le 100$      | $\\le 8$ | $\\le 200$  |           无            |\n|    $15$    | $\\le 5\\times 10^3$ |   $0$   | $\\le 10^4$ |           无            |\n|    $16$    | $\\le 5\\times 10^3$ | $\\le 8$ | $\\le 10^4$ | $S$ 中只包含 $x$ 或 $c$ |\n|    $17$    | $\\le 5\\times 10^3$ | $\\le 8$ | $\\le 10^4$ |           无            |\n|    $18$    | $\\le 5\\times 10^4$ |   $0$   | $\\le 10^5$ |           无            |\n|    $19$    | $\\le 5\\times 10^4$ | $\\le 8$ | $\\le 10^5$ | $S$ 中只包含 $x$ 或 $c$ |\n|    $20$    | $\\le 5\\times 10^4$ | $\\le 8$ | $\\le 10^5$ |           无            |", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2017] Game", "background": "[Original problem time limit: 1 s.]\n\nAsphalt is Little L’s favorite game. Unlike other casual players, Little L studies game design in his spare time, so he has a unique strategy for playing.", "description": "Little L plans to play $n$ games. Each game uses one map, and Little L will choose a car to complete the game on that map.\n\nLittle L has three cars, denoted by uppercase letters $A$, $B$, and $C$. There are four types of maps, denoted by lowercase letters $x$, $a$, $b$, and $c$.\n\nAmong them, car $A$ is not suitable for map $a$, car $B$ is not suitable for map $b$, car $C$ is not suitable for map $c$, while map $x$ is suitable for all cars.\n\nMaps that are suitable for all cars are rare; there will be at most $d$ of them.\n\nThe maps for the $n$ games can be described by a string of lowercase letters. For example, $S=\\texttt{xaabxcbc}$ means Little L plans to play $8$ games: the $1$-st and $5$-th maps are of type $x$, suitable for all cars; the $2$-nd and $3$-rd maps are of type $a$, unsuitable for car $A$; the $4$-th and $7$-th maps are of type $b$, unsuitable for car $B$; and the $6$-th and $8$-th maps are of type $c$, unsuitable for car $C$.\n\nLittle L has some special requirements, which can be described by a quadruple $(i, h_i, j, h_j)$, meaning: if the car used in game $i$ is $h_i$, then the car used in game $j$ must be $h_j$.\n\nCan you help Little L choose a car for each game? If there are multiple solutions, output any of them.\n\nIf there is no solution, output `-1`.", "inputFormat": "The first line contains two non-negative integers, $n$ and $d$.\n\nThe second line contains a string $S$.\n\nThe meanings of $n$, $d$, and $S$ are as described above. The string $S$ contains $n$ characters, and exactly $d$ of them are the lowercase letter $x$.\n\nThe third line contains a positive integer $m$, indicating that there are $m$ car-usage rules.\n\nThe next $m$ lines each contain a quadruple $i, h_i, j, h_j$, where $i$ and $j$ are integers, and $h_i$ and $h_j$ are characters among $A$, $B$, and $C$, with meanings as described above.", "outputFormat": "Output one line.\n\nIf there is no solution, output `-1`.\n\nIf there is a solution, output a string of length $n$ consisting only of uppercase letters $A$, $B$, and $C$, indicating how Little L arranges the cars for these $n$ games. If multiple solutions exist, output any one of them.", "hint": "### Sample 1 Explanation\n\nLittle $L$ plans to play $3$ games. The $1$-st map is of type $x$, suitable for all cars, and the $2$-nd and $3$-rd maps are of type $c$, unsuitable for car $C$.\n\nLittle $L$ requires: if car $A$ is used in game $1$, then car $B$ must be used in game $2$.\n\nAssigning cars $A$, $B$, $A$ to the $3$ games satisfies all conditions.\n\nAssigning cars $B B B$ or $B A A$ to the $3$ games also satisfies all conditions and is considered correct.\n\nHowever, assigning cars $A A B$ or $A B C$ does not satisfy all conditions, so it is not considered correct.\n\n### Sample 2\n\nSee the attached file.\n\n### Constraints\n\n| Test point ID |        $n$         |   $d$   |    $m$     |        Other properties        |\n| :-----------: | :----------------: | :-----: | :--------: | :----------------------------: |\n|      $1$      |      $\\le 2$       |   $0$   |  $\\le 4$   |              None              |\n|      $2$      |      $\\le 2$       | $\\le n$ |  $\\le 4$   |              None              |\n|      $3$      |      $\\le 5$       |   $0$   |  $\\le 10$  |              None              |\n|      $4$      |      $\\le 5$       | $\\le n$ |  $\\le 10$  |              None              |\n|      $5$      |      $\\le 10$      |   $0$   |  $\\le 20$  |              None              |\n|      $6$      |      $\\le 10$      | $\\le 8$ |  $\\le 20$  |              None              |\n|      $7$      |      $\\le 20$      |   $0$   |  $\\le 40$  |     $S$ only contains $c$      |\n|      $8$      |      $\\le 20$      |   $0$   |  $\\le 40$  |              None              |\n|      $9$      |      $\\le 20$      | $\\le 8$ |  $\\le 40$  | $S$ only contains $x$ or $c$   |\n|     $10$      |      $\\le 20$      | $\\le 8$ |  $\\le 40$  |              None              |\n|     $11$      |     $\\le 100$      |   $0$   | $\\le 200$  |     $S$ only contains $c$      |\n|     $12$      |     $\\le 100$      |   $0$   | $\\le 200$  |              None              |\n|     $13$      |     $\\le 100$      | $\\le 8$ | $\\le 200$  | $S$ only contains $x$ or $c$   |\n|     $14$      |     $\\le 100$      | $\\le 8$ | $\\le 200$  |              None              |\n|     $15$      | $\\le 5\\times 10^3$ |   $0$   | $\\le 10^4$ |              None              |\n|     $16$      | $\\le 5\\times 10^3$ | $\\le 8$ | $\\le 10^4$ | $S$ only contains $x$ or $c$   |\n|     $17$      | $\\le 5\\times 10^3$ | $\\le 8$ | $\\le 10^4$ |              None              |\n|     $18$      | $\\le 5\\times 10^4$ |   $0$   | $\\le 10^5$ |              None              |\n|     $19$      | $\\le 5\\times 10^4$ | $\\le 8$ | $\\le 10^5$ | $S$ only contains $x$ or $c$   |\n|     $20$      | $\\le 5\\times 10^4$ | $\\le 8$ | $\\le 10^5$ |              None              |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2017] 游戏", "background": "【本题原题时限 1s】\n\n狂野飙车是小 L 最喜欢的游戏。与其他业余玩家不同的是，小 L 在玩游戏之余，还精于研究游戏的设计，因此他有着与众不同的游戏策略。\n", "description": "小 L 计划进行 $n$ 场游戏，每场游戏使用一张地图，小 L 会选择一辆车在该地图上完成游戏。\n\n小 L 的赛车有三辆，分别用大写字母 $A$、$B$、$C$ 表示。地图一共有四种，分别用小写字母 $x$、$a$、$b$、$c$ 表示。\n\n其中，赛车 $A$ 不适合在地图 $a$ 上使用，赛车 $B$ 不适合在地图 $b$ 上使用，赛车 $C$ 不适合在地图 $c$ 上使用，而地图 $x$ 则适合所有赛车参加。\n\n适合所有赛车参加的地图并不多见，最多只会有 $d$ 张。\n\n$n$ 场游戏的地图可以用一个小写字母组成的字符串描述。例如：$S=\\texttt{xaabxcbc}$ 表示小 L 计划进行 $8$ 场游戏，其中第 $1$ 场和第 $5$ 场的地图类型是 $x$，适合所有赛车，第 $2$ 场和第 $3$ 场的地图是 $a$，不适合赛车 $A$，第 $4$ 场和第 $7$ 场的地图是 $b$，不适合赛车 $B$，第 $6$ 场和第 $8$ 场的地图是 $c$，不适合赛车 $C$。\n\n小 L 对游戏有一些特殊的要求，这些要求可以用四元组 $ (i, h_i, j, h_j) $ 来描述，表示若在第 $i$ 场使用型号为 $h_i$ 的车子，则第 $j$ 场游戏要使用型号为 $h_j$ 的车子。\n\n你能帮小 L 选择每场游戏使用的赛车吗？如果有多种方案，输出任意一种方案。\n\n如果无解，输出 `-1`。", "inputFormat": "输入第一行包含两个非负整数 $n$, $d$。\n\n输入第二行为一个字符串 $S$。\n\n$n$, $d$, $S$ 的含义见题目描述，其中 $S$ 包含 $n$ 个字符，且其中恰好 $d$ 个为小写字母 $x$。\n\n输入第三行为一个正整数 $m$ ，表示有 $m$ 条用车规则。\n\n接下来 $m$ 行，每行包含一个四元组 $i,h_i,j,h_j$ ，其中 $i,j$ 为整数，$h_i,h_j$ 为字符 $A$ 、$B$ 或 $C$，含义见题目描述。", "outputFormat": "输出一行。\n\n若无解输出 `-1`。\n\n若有解，则包含一个长度为 $n$ 的仅包含大写字母 A、B、C 的字符串，表示小 L 在这 $n$ 场游戏中如何安排赛车的使用。如果存在多组解，输出其中任意一组即可。", "hint": "### 样例 1 解释\n\n小 $L$ 计划进行 $3$ 场游戏，其中第 $1$ 场的地图类型是 $x$，适合所有赛车，第 $2$ 场和第 $3$ 场的地图是 $c$，不适合赛车 $C$。\n\n小 $L$ 希望：若第 $1$ 场游戏使用赛车 $A$，则第 $2$ 场游戏使用赛车 $B$。\n\n那么为这 $3$ 场游戏分别安排赛车 $A$、$B$、$A$ 可以满足所有条件。\n\n若依次为 $3$ 场游戏安排赛车为 $BBB$ 或 $BAA$ 时，也可以满足所有条件，也被视为正确答案。\n\n但依次安排赛车为 $AAB$ 或 $ABC$ 时，因为不能满足所有条件，所以不被视为正确答案。\n\n### 样例 2\n\n详见附加文件。\n\n### 数据范围\n\n| 测试点编号 |        $n$         |   $d$   |    $m$     |        其他性质         |\n| :--------: | :----------------: | :-----: | :--------: | :---------------------: |\n|    $1$     |      $\\le 2$       |   $0$   |  $\\le 4$   |           无            |\n|    $2$     |      $\\le 2$       | $\\le n$ |  $\\le 4$   |           无            |\n|    $3$     |      $\\le 5$       |   $0$   |  $\\le 10$  |           无            |\n|    $4$     |      $\\le 5$       | $\\le n$ |  $\\le 10$  |           无            |\n|    $5$     |      $\\le 10$      |   $0$   |  $\\le 20$  |           无            |\n|    $6$     |      $\\le 10$      | $\\le 8$ |  $\\le 20$  |           无            |\n|    $7$     |      $\\le 20$      |   $0$   |  $\\le 40$  |    $S$ 中只包含 $c$     |\n|    $8$     |      $\\le 20$      |   $0$   |  $\\le 40$  |           无            |\n|    $9$     |      $\\le 20$      | $\\le 8$ |  $\\le 40$  | $S$ 中只包含 $x$ 或 $c$ |\n|    $10$    |      $\\le 20$      | $\\le 8$ |  $\\le 40$  |           无            |\n|    $11$    |     $\\le 100$      |   $0$   | $\\le 200$  |    $S$ 中只包含 $c$     |\n|    $12$    |     $\\le 100$      |   $0$   | $\\le 200$  |           无            |\n|    $13$    |     $\\le 100$      | $\\le 8$ | $\\le 200$  | $S$ 中只包含 $x$ 或 $c$ |\n|    $14$    |     $\\le 100$      | $\\le 8$ | $\\le 200$  |           无            |\n|    $15$    | $\\le 5\\times 10^3$ |   $0$   | $\\le 10^4$ |           无            |\n|    $16$    | $\\le 5\\times 10^3$ | $\\le 8$ | $\\le 10^4$ | $S$ 中只包含 $x$ 或 $c$ |\n|    $17$    | $\\le 5\\times 10^3$ | $\\le 8$ | $\\le 10^4$ |           无            |\n|    $18$    | $\\le 5\\times 10^4$ |   $0$   | $\\le 10^5$ |           无            |\n|    $19$    | $\\le 5\\times 10^4$ | $\\le 8$ | $\\le 10^5$ | $S$ 中只包含 $x$ 或 $c$ |\n|    $20$    | $\\le 5\\times 10^4$ | $\\le 8$ | $\\le 10^5$ |           无            |", "locale": "zh-CN"}}}
{"pid": "P3826", "type": "P", "difficulty": 7, "samples": [["2 3 2\n3 3 3 3\n2 5 8 3\n1\n3\n", "16\n27\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "递推", "2017", "NOI", "O2优化", "栈", "反悔贪心"], "title": "[NOI2017] 蔬菜", "background": "", "description": "小 N 是蔬菜仓库的管理员，负责设计蔬菜的销售方案。\n\n在蔬菜仓库中，共存放有 $n$ 种蔬菜，小 N 需要根据不同蔬菜的特性，综合考虑各方面因素，设计合理的销售方案，以获得最多的收益。\n\n在计算销售蔬菜的收益时，每销售一个单位第 $i$ 种蔬菜，就可以获得 $a_i$ 的收益。\n\n特别地，由于政策鼓励商家进行多样化销售，第一次销售第 $i$ 种蔬菜时，还会额外得到 $s_i$ 的额外收益。\n\n在经营开始时，第 $i$ 种蔬菜的库存为 $c_i$ 个单位。\n\n然而，蔬菜的保鲜时间非常有限，一旦变质就不能进行销售，不过聪明的小 N 已经计算出了每个单位蔬菜变质的时间：对于第 $i$ 种蔬菜，存在保鲜值 $x_i$，每天结束时会有 $x_i$ 个单位的蔬菜变质，直到所有蔬菜都变质。（注意：每一单位蔬菜的变质时间是固定的，不随销售发生变化）\n\n形式化地：对于所有的满足条件 $d\\times x_i \\leq c_i$ 的正整数 $d$，有 $x_i$ 个单位的蔬菜将在第 $d$ 天结束时变质。\n\n特别地，若 $(d - 1)\\times x_i \\leq c_i < d\\times x_i$，则有 $c_i - (d - 1)\\times x_i$ 单位的蔬菜将在第 $d$ 天结束时变质。\n\n注意，当 $x_i = 0$ 时，意味着这种蔬菜不会变质。\n\n同时，每天销售的蔬菜，总量也是有限的，最多不能超过 $m$ 个单位。\n\n现在，小 N 有 $k$ 个问题，想请你帮忙算一算。每个问题的形式都是：对于已知的 $p_j$，如果需要销售 $p_j$ 天，最多能获得多少收益？", "inputFormat": "第一行包含三个正整数 $n,m,k$，分别表示蔬菜的种类数目、每天能售出蔬菜总量上限、小 N 提出的问题的个数。\n\n接下来 $n$ 行，每行输入四个非负整数，描述一种蔬菜的特点，依次为 $a_i,s_i,c_i,x_i$，意义如上文所述。\n\n接下来 $k$ 行，每行输入一个非负整数 $p_j$，意义如上文所述。", "outputFormat": "输出 $k$ 行，每行包含一个整数，第 $i$ 行的数表示第 $i$ 个问题的答案。", "hint": "### 样例解释\n\n共有两种蔬菜：\n\n销售第 $1$ 种蔬菜时，每销售一单位可以获得的收益为 $3$，第一次销售这种蔬菜时，额外可以获得的收益为 $3$。这种蔬菜共有 $3$ 个单位，均会在第一天结束时变质。\n\n销售第 $2$ 种蔬菜时，每销售一单位可以获得的收益为 $2$，第一次销售这种蔬菜时，额外可以获得的收益为 $5$。这种蔬菜共有 $8$ 个单位，其中，有 $3$ 单位在第一天结束时变质，$3$ 单位在第二天结束时变质，$2$ 单位在第三天结束时变质。\n\n在只销售 $1$ 天时，应当销售 $2$ 单位的第一种蔬菜和 $1$ 单位的第二种蔬菜。\n\n在这种情况下：销售第一种蔬菜的收益为 $2 \\times 3 + 3$；销售第二种蔬菜的收益为 $1 \\times 2 + 5$；总共获得的收益为 $(2 \\times 3 + 3) + (1 \\times 2 + 5) = 16$。\n\n在只销售 $3$ 天时，第一天应当销售 $3$ 单位的第一种蔬菜，第二天应当销售 $3$ 单位的第二种蔬菜（此时选择在第二天结束时会变质的 $3$ 个单位出售），第三天销售 $2$ 单位的第二种蔬菜。\n\n在这种情况下：销售第一种蔬菜的收益为 $3 \\times 3 + 3$；销售第二种蔬菜的收益为 $(3 + 2) \\times 2 + 5$；总共获得的收益为 $(3 \\times 3 + 3) + [(3 + 2) \\times 2 + 5] = 27$。\n\n### 数据范围\n\n::cute-table{tuack}\n\n| 测试点编号 |    $n$     |   $m$    |   $p_j$    | 特性 $1$ |    特性 $2$    |\n| :--------: | :--------: | :------: | :--------: | :------: | :------------: |\n|    $1$     |  $\\le 2$   | $\\le 10$ | $\\le 10^3$ |    无    |       无       |\n|    $2$     |  $\\le 3$   | ^ | ^ |    ^    |       ^       |\n|    $3$     |  $\\le 4$   | ^ | ^ |    ^    |       ^       |\n|    $4$     | $\\le 10^3$ | ^ |  $\\le 2$   |    ^    |       ^       |\n|    $5$     | ^ | ^ |  $\\le 3$   |    ^    |       ^       |\n|    $6$     | ^ | ^ |  $\\le 4$   |    ^    |       ^       |\n|    $7$     |  $\\le 4$   | $\\le 1$  |  ^   |    ^    |       ^       |\n|    $8$     |  $\\le 6$   | $\\le 2$  |  $\\le 6$   |    ^    |       ^       |\n|    $9$     |  $\\le 8$   | $\\le 1$  |  $\\le 8$   |    ^    |       ^       |\n|    $10$    |  $\\le 10$  | $\\le 2$  |  $\\le 10$  |    ^    |       ^       |\n|    $11$    |  $\\le 20$  | $\\le 3$  |  $\\le 20$  |    ^    |       ^       |\n|    $12$    | $\\le 10^2$ | $\\le 10$ | $\\le 10^2$ |    有    | ^ |\n|    $13$    | ^ | ^ | ^ |    无    |       有       |\n|    $14$    | ^ | ^ | ^ |    ^    | 无 |\n|    $15$    | ^ | ^ | ^ |    ^    | ^ |\n|    $16$    | $\\le 10^3$ | ^ | $\\le 10^3$ |    有    | 有 |\n|    $17$    | ^ | ^ | ^ |    ^    | 无 |\n|    $18$    | ^ | ^ | ^ |    无    |       有       |\n|    $19$    | ^ | ^ | ^ |    ^    | 无 |\n|    $20$    | ^ | ^ | ^ |    ^    | ^ |\n|    $21$    | $\\le 10^5$ | ^ | $\\le 10^5$ |    有    | 有 |\n|    $22$    | ^ | ^ | ^ |    ^    |       无       |\n|    $23$    | ^ | ^ | ^ |    无    |       有       |\n|    $24$    | ^ | ^ | ^ |    ^    |       无       |\n|    $25$    | ^ | ^ | ^ |    ^    |       ^       |\n\n特性 $1$：所有的 $s_i$ 均为 $0$；\n\n特性 $2$：所有的 $x_i$ 均为 $0$。\n\n对于所有的测试数据，均保证 $k$ 组询问中的 $p_j$ 互不相同。\n\n对于所有的测试数据，均保证 $0<a_i,c_i\\le 10^9$，$0\\le s_i,x_i\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2017] Vegetables", "background": "", "description": "Xiao N is the administrator of a vegetable warehouse, responsible for designing a sales plan for the vegetables.\n\nThere are $n$ types of vegetables stored in the warehouse. Xiao N needs to design a reasonable sales plan by considering various factors based on the characteristics of different vegetables, in order to obtain the maximum profit.\n\nWhen calculating the profit from selling vegetables, for each unit of the $i$-th vegetable sold, a profit of $a_i$ is obtained.\n\nIn particular, due to policies that encourage diversified sales, the first time the $i$-th vegetable is sold, an additional bonus profit of $s_i$ is also obtained.\n\nAt the beginning of operations, the inventory of the $i$-th vegetable is $c_i$ units.\n\nHowever, vegetables have a very limited freshness period. Once spoiled, they cannot be sold. Fortunately, Xiao N has already calculated the spoilage time of each unit of vegetable: for the $i$-th vegetable, there exists a freshness parameter $x_i$. At the end of each day, $x_i$ units of this vegetable will spoil, until all units have spoiled. (Note: The spoilage time of each unit is fixed and does not change due to sales.)\n\nFormally: for every positive integer $d$ such that $d \\times x_i \\leq c_i$, there will be $x_i$ units of the $i$-th vegetable spoiling at the end of day $d$.\n\nIn particular, if $(d - 1) \\times x_i \\leq c_i < d \\times x_i$, then $c_i - (d - 1) \\times x_i$ units of the $i$-th vegetable will spoil at the end of day $d$.\n\nNote that when $x_i = 0$, it means this vegetable never spoils.\n\nMeanwhile, the total number of vegetables that can be sold per day is limited to at most $m$ units.\n\nNow, Xiao N has $k$ questions and asks for your help. Each question is: given $p_j$, if sales last for $p_j$ days, what is the maximum profit that can be obtained?", "inputFormat": "The first line contains three positive integers $n, m, k$, representing the number of vegetable types, the maximum total number of vegetable units that can be sold per day, and the number of questions asked by Xiao N, respectively.\n\nThe next $n$ lines each contain four non-negative integers describing the characteristics of one type of vegetable, in the order $a_i, s_i, c_i, x_i$, with meanings as described above.\n\nThe next $k$ lines each contain one non-negative integer $p_j$, with the meaning as described above.", "outputFormat": "Output $k$ lines. The number on the $i$-th line is the answer to the $i$-th question.", "hint": "### Sample Explanation\n\nThere are two types of vegetables:\n\nFor the $1$-st vegetable, the profit per unit sold is $3$, and an additional bonus profit of $3$ is obtained when selling this vegetable for the first time. There are $3$ units in total, and all of them will spoil at the end of day $1$.\n\nFor the $2$-nd vegetable, the profit per unit sold is $2$, and an additional bonus profit of $5$ is obtained when selling this vegetable for the first time. There are $8$ units in total, among which $3$ units spoil at the end of day $1$, $3$ units spoil at the end of day $2$, and $2$ units spoil at the end of day $3$.\n\nIf sales last for $1$ day, you should sell $2$ units of the first vegetable and $1$ unit of the second vegetable.\n\nIn this case: the profit from selling the first vegetable is $2 \\times 3 + 3$; the profit from selling the second vegetable is $1 \\times 2 + 5$; the total profit is $(2 \\times 3 + 3) + (1 \\times 2 + 5) = 16$.\n\nIf sales last for $3$ days, on day $1$ you should sell $3$ units of the first vegetable, on day $2$ you should sell $3$ units of the second vegetable (choose the $3$ units that will spoil at the end of day $2$), and on day $3$ you should sell $2$ units of the second vegetable.\n\nIn this case: the profit from selling the first vegetable is $3 \\times 3 + 3$; the profit from selling the second vegetable is $(3 + 2) \\times 2 + 5$; the total profit is $(3 \\times 3 + 3) + [(3 + 2) \\times 2 + 5] = 27$.\n\n### Constraints\n\n::cute-table{tuack}\n| Test point ID |     $n$     |    $m$    |   $p_j$    | Feature $1$ |    Feature $2$    |\n| :-----------: | :---------: | :-------: | :--------: | :---------: | :---------------: |\n|      $1$      |   $\\le 2$   | $\\le 10$  | $\\le 10^3$ |     No      |        No         |\n|      $2$      |   $\\le 3$   | ^         | ^          |     ^       |        ^          |\n|      $3$      |   $\\le 4$   | ^         | ^          |     ^       |        ^          |\n|      $4$      | $\\le 10^3$  | ^         | $\\le 2$    |     ^       |        ^          |\n|      $5$      | ^           | ^         | $\\le 3$    |     ^       |        ^          |\n|      $6$      | ^           | ^         | $\\le 4$    |     ^       |        ^          |\n|      $7$      |   $\\le 4$   | $\\le 1$   | ^          |     ^       |        ^          |\n|      $8$      |   $\\le 6$   | $\\le 2$   | $\\le 6$    |     ^       |        ^          |\n|      $9$      |   $\\le 8$   | $\\le 1$   | $\\le 8$    |     ^       |        ^          |\n|     $10$      |  $\\le 10$   | $\\le 2$   | $\\le 10$   |     ^       |        ^          |\n|     $11$      |  $\\le 20$   | $\\le 3$   | $\\le 20$   |     ^       |        ^          |\n|     $12$      | $\\le 10^2$  | $\\le 10$  | $\\le 10^2$ |     Yes     |        ^          |\n|     $13$      | ^           | ^         | ^          |     No      |        Yes        |\n|     $14$      | ^           | ^         | ^          |     ^       |        No         |\n|     $15$      | ^           | ^         | ^          |     ^       |        ^          |\n|     $16$      | $\\le 10^3$  | ^         | $\\le 10^3$ |     Yes     |        Yes        |\n|     $17$      | ^           | ^         | ^          |     ^       |        No         |\n|     $18$      | ^           | ^         | ^          |     No      |        Yes        |\n|     $19$      | ^           | ^         | ^          |     ^       |        No         |\n|     $20$      | ^           | ^         | ^          |     ^       |        ^          |\n|     $21$      | $\\le 10^5$  | ^         | $\\le 10^5$ |     Yes     |        Yes        |\n|     $22$      | ^           | ^         | ^          |     ^       |        No         |\n|     $23$      | ^           | ^         | ^          |     No      |        Yes        |\n|     $24$      | ^           | ^         | ^          |     ^       |        No         |\n|     $25$      | ^           | ^         | ^          |     ^       |        ^          |\n\nFeature $1$: all $s_i$ are $0$.\n\nFeature $2$: all $x_i$ are $0$.\n\nFor all testdata, it is guaranteed that the $p_j$ in the $k$ queries are pairwise distinct.\n\nFor all testdata, it is guaranteed that $0 < a_i, c_i \\le 10^9$, $0 \\le s_i, x_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2017] 蔬菜", "background": "", "description": "小 N 是蔬菜仓库的管理员，负责设计蔬菜的销售方案。\n\n在蔬菜仓库中，共存放有 $n$ 种蔬菜，小 N 需要根据不同蔬菜的特性，综合考虑各方面因素，设计合理的销售方案，以获得最多的收益。\n\n在计算销售蔬菜的收益时，每销售一个单位第 $i$ 种蔬菜，就可以获得 $a_i$ 的收益。\n\n特别地，由于政策鼓励商家进行多样化销售，第一次销售第 $i$ 种蔬菜时，还会额外得到 $s_i$ 的额外收益。\n\n在经营开始时，第 $i$ 种蔬菜的库存为 $c_i$ 个单位。\n\n然而，蔬菜的保鲜时间非常有限，一旦变质就不能进行销售，不过聪明的小 N 已经计算出了每个单位蔬菜变质的时间：对于第 $i$ 种蔬菜，存在保鲜值 $x_i$，每天结束时会有 $x_i$ 个单位的蔬菜变质，直到所有蔬菜都变质。（注意：每一单位蔬菜的变质时间是固定的，不随销售发生变化）\n\n形式化地：对于所有的满足条件 $d\\times x_i \\leq c_i$ 的正整数 $d$，有 $x_i$ 个单位的蔬菜将在第 $d$ 天结束时变质。\n\n特别地，若 $(d - 1)\\times x_i \\leq c_i < d\\times x_i$，则有 $c_i - (d - 1)\\times x_i$ 单位的蔬菜将在第 $d$ 天结束时变质。\n\n注意，当 $x_i = 0$ 时，意味着这种蔬菜不会变质。\n\n同时，每天销售的蔬菜，总量也是有限的，最多不能超过 $m$ 个单位。\n\n现在，小 N 有 $k$ 个问题，想请你帮忙算一算。每个问题的形式都是：对于已知的 $p_j$，如果需要销售 $p_j$ 天，最多能获得多少收益？", "inputFormat": "第一行包含三个正整数 $n,m,k$，分别表示蔬菜的种类数目、每天能售出蔬菜总量上限、小 N 提出的问题的个数。\n\n接下来 $n$ 行，每行输入四个非负整数，描述一种蔬菜的特点，依次为 $a_i,s_i,c_i,x_i$，意义如上文所述。\n\n接下来 $k$ 行，每行输入一个非负整数 $p_j$，意义如上文所述。", "outputFormat": "输出 $k$ 行，每行包含一个整数，第 $i$ 行的数表示第 $i$ 个问题的答案。", "hint": "### 样例解释\n\n共有两种蔬菜：\n\n销售第 $1$ 种蔬菜时，每销售一单位可以获得的收益为 $3$，第一次销售这种蔬菜时，额外可以获得的收益为 $3$。这种蔬菜共有 $3$ 个单位，均会在第一天结束时变质。\n\n销售第 $2$ 种蔬菜时，每销售一单位可以获得的收益为 $2$，第一次销售这种蔬菜时，额外可以获得的收益为 $5$。这种蔬菜共有 $8$ 个单位，其中，有 $3$ 单位在第一天结束时变质，$3$ 单位在第二天结束时变质，$2$ 单位在第三天结束时变质。\n\n在只销售 $1$ 天时，应当销售 $2$ 单位的第一种蔬菜和 $1$ 单位的第二种蔬菜。\n\n在这种情况下：销售第一种蔬菜的收益为 $2 \\times 3 + 3$；销售第二种蔬菜的收益为 $1 \\times 2 + 5$；总共获得的收益为 $(2 \\times 3 + 3) + (1 \\times 2 + 5) = 16$。\n\n在只销售 $3$ 天时，第一天应当销售 $3$ 单位的第一种蔬菜，第二天应当销售 $3$ 单位的第二种蔬菜（此时选择在第二天结束时会变质的 $3$ 个单位出售），第三天销售 $2$ 单位的第二种蔬菜。\n\n在这种情况下：销售第一种蔬菜的收益为 $3 \\times 3 + 3$；销售第二种蔬菜的收益为 $(3 + 2) \\times 2 + 5$；总共获得的收益为 $(3 \\times 3 + 3) + [(3 + 2) \\times 2 + 5] = 27$。\n\n### 数据范围\n\n::cute-table{tuack}\n\n| 测试点编号 |    $n$     |   $m$    |   $p_j$    | 特性 $1$ |    特性 $2$    |\n| :--------: | :--------: | :------: | :--------: | :------: | :------------: |\n|    $1$     |  $\\le 2$   | $\\le 10$ | $\\le 10^3$ |    无    |       无       |\n|    $2$     |  $\\le 3$   | ^ | ^ |    ^    |       ^       |\n|    $3$     |  $\\le 4$   | ^ | ^ |    ^    |       ^       |\n|    $4$     | $\\le 10^3$ | ^ |  $\\le 2$   |    ^    |       ^       |\n|    $5$     | ^ | ^ |  $\\le 3$   |    ^    |       ^       |\n|    $6$     | ^ | ^ |  $\\le 4$   |    ^    |       ^       |\n|    $7$     |  $\\le 4$   | $\\le 1$  |  ^   |    ^    |       ^       |\n|    $8$     |  $\\le 6$   | $\\le 2$  |  $\\le 6$   |    ^    |       ^       |\n|    $9$     |  $\\le 8$   | $\\le 1$  |  $\\le 8$   |    ^    |       ^       |\n|    $10$    |  $\\le 10$  | $\\le 2$  |  $\\le 10$  |    ^    |       ^       |\n|    $11$    |  $\\le 20$  | $\\le 3$  |  $\\le 20$  |    ^    |       ^       |\n|    $12$    | $\\le 10^2$ | $\\le 10$ | $\\le 10^2$ |    有    | ^ |\n|    $13$    | ^ | ^ | ^ |    无    |       有       |\n|    $14$    | ^ | ^ | ^ |    ^    | 无 |\n|    $15$    | ^ | ^ | ^ |    ^    | ^ |\n|    $16$    | $\\le 10^3$ | ^ | $\\le 10^3$ |    有    | 有 |\n|    $17$    | ^ | ^ | ^ |    ^    | 无 |\n|    $18$    | ^ | ^ | ^ |    无    |       有       |\n|    $19$    | ^ | ^ | ^ |    ^    | 无 |\n|    $20$    | ^ | ^ | ^ |    ^    | ^ |\n|    $21$    | $\\le 10^5$ | ^ | $\\le 10^5$ |    有    | 有 |\n|    $22$    | ^ | ^ | ^ |    ^    |       无       |\n|    $23$    | ^ | ^ | ^ |    无    |       有       |\n|    $24$    | ^ | ^ | ^ |    ^    |       无       |\n|    $25$    | ^ | ^ | ^ |    ^    |       ^       |\n\n特性 $1$：所有的 $s_i$ 均为 $0$；\n\n特性 $2$：所有的 $x_i$ 均为 $0$。\n\n对于所有的测试数据，均保证 $k$ 组询问中的 $p_j$ 互不相同。\n\n对于所有的测试数据，均保证 $0<a_i,c_i\\le 10^9$，$0\\le s_i,x_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3827", "type": "P", "difficulty": 7, "samples": [["6 2\n-1 0\n-1 -1\n0 -1\n1 0\n0 1\n0 0\n3 1 3 6\n2 0 1\n", "3\n2\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "NOI", "O2优化"], "title": "[NOI2017] 分身术", "background": "", "description": "> “分！身！术！” —— 小 P\n\n平面上有 $n$ 个小 P 的分身。定义一组分身占领的区域为覆盖这组分身的最小凸多边形。小 P 能力有限，每一时刻都会有若干分身消失。但在下一时刻之前，小 P 会使用分身术使得这些消失的分身重新出现在原来的位置。\n\n小 P 想知道，每一时刻分身消失后，剩下的分身占领的区域面积是多少？\n", "inputFormat": "输入第一行包含两个正整数 $n,m$，描述初始时分身的个数，和总时刻数。\n\n接下来 $n$ 行，第 $i$ 行有两个整数 $x_i, y_i$ ，描述第 $i$ 个分身的位置。\n\n接下来 $m$ 行，每行的第一个整数 $k$ 表示这一时刻有 $k$ 个分身消失。接下来有 $k$ 个非负整数 $c_1, c_2, \\ldots, c_k$，用于生成消失的分身的编号。\n\n生成方式如下：\n\n设上一个时刻中，分身占领面积的**两倍**为 $S$。则该时刻消失的分身 $p_1, p_2, \\ldots , p_k$ 的编号为：$p_i = [(S + c_i) \\bmod n] + 1$。\n\n特别的，在第一个时刻，我们认为上一个时刻中，$S = -1$，即：第一个时刻消失的分身$p_1, p_2, \\ldots , p_k$的编号为：$p_i = [(−1 + c_i) \\bmod n] + 1$。", "outputFormat": "按给出时刻的顺序依次输出 $m$ 行，每行一个整数，表示该时刻剩余分身所占领区域面积的**两倍**。", "hint": "### 样例解释\n\n如下图所示：左图表示输入的 $6$ 个分身的位置及它们占领的区域；中图表示第一个时刻的情形，消失的分身编号分别为 $1,3,6$，剩余 $3$ 个点占领图中实线内部区域，占据面积的两倍为 $3$；右图表示第二个时刻的情形，消失的分身编号分别为\n\n$[(0 + 3)\\bmod 6] + 1 = 4$\n\n$[(1 + 3)\\bmod 6] + 1 = 5$\n\n剩余的 $4$ 个点占领图中实线内部区域。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bieyspo4.png) \n\n对于所有数据，保证：\n\n-  $|x_i|,|y_i|\\le 10^8$ ；\n- 没有两个分身的坐标是完全相同的；\n-  $k\\le 100$ ；\n- 所有时刻的  $k$ 之和不超过  $2\\times 10^6$ ；\n-  $0\\le c_i\\le 2^{31}-1$ ；\n- 初始时，所有的  $n$ 个分身占据区域面积大于  $0$ ；\n- 定义所有  $n$ 个分身所占据区域的**顶点集合**为  $S$ ，  $|S|\\ge 3$ 。在任意时刻，  $S$ 中至少存在两个未消失的分身。\n\n| 测试点编号 | $n \\leq$ | $m \\leq$ |    $k$     |\n| :--------: | :------: | :------: | :--------: |\n|    $1$     |   $10$   |   $10$   | $\\leq n-3$ |\n|    $2$     |  $10^3$  |  $10^3$  | $\\leq n-3$ |\n|    $3$     |  $10^3$  |  $10^3$  | $\\leq n-3$ |\n|    $4$     |  $10^3$  |  $10^3$  | $\\leq n-3$ |\n|    $5$     |  $10^5$  |  $10^5$  |    $=1$    |\n|    $6$     |  $10^5$  |  $10^5$  |    $=1$    |\n|    $7$     |  $10^5$  |  $10^5$  |    $=1$    |\n|    $8$     |  $10^5$  |  $10^5$  |    $=1$    |\n|    $9$     |  $10^5$  |  $10^5$  |    $=2$    |\n|    $10$    |  $10^5$  |  $10^5$  |    $=2$    |\n|    $11$    |  $10^5$  |  $10^5$  |  $\\leq 3$  |\n|    $12$    |  $10^5$  |  $10^5$  |  $\\leq 5$  |\n|    $13$    |  $10^5$  |  $10^5$  |  $\\leq 9$  |\n|    $14$    |  $10^5$  |  $10^5$  | $\\leq 12$  |\n|    $15$    |  $10^5$  |  $10^5$  | $\\leq 20$  |\n|    $16$    |  $10^5$  |  $10^5$  | $\\leq 100$ |\n|    $17$    |  $10^5$  |  $10^5$  | $\\leq 100$ |\n|    $18$    |  $10^5$  |  $10^5$  | $\\leq 100$ |\n|    $19$    |  $10^5$  |  $10^5$  | $\\leq 100$ |\n|    $20$    |  $10^5$  |  $10^5$  | $\\leq 100$ |", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2017] Clone Technique", "background": "", "description": "\"Clone! Technique!\" — Xiao P.\n\nOn a plane, there are $n$ clones of Xiao P. Define the region occupied by a set of clones as the smallest convex polygon that covers this set of clones (i.e., the convex hull). Xiao P's ability is limited: at each time step, several clones will disappear. However, before the next time step, Xiao P will use the Clone Technique to make these disappeared clones reappear at their original positions.\n\nXiao P wants to know the area of the region occupied by the remaining clones after the disappearances at each time step.\n\nConstraints\n\n- $|x_i|, |y_i| \\le 10^8$.\n- No two clones share exactly the same coordinates.\n- $k \\le 100$.\n- The sum of $k$ over all time steps does not exceed $2 \\times 10^6$.\n- $0 \\le c_i \\le 2^{31} - 1$.\n- Initially, the area occupied by all $n$ clones is greater than $0$.\n- Define the vertex set of the region occupied by all $n$ clones as $S$, with $|S| \\ge 3$. At any time step, there exist at least two clones from $S$ that have not disappeared.\n\n| Test point ID | $n \\leq$ | $m \\leq$ |    $k$     |\n| :-----------: | :------: | :------: | :--------: |\n|      $1$      |   $10$   |   $10$   | $\\leq n-3$ |\n|      $2$      |  $10^3$  |  $10^3$  | $\\leq n-3$ |\n|      $3$      |  $10^3$  |  $10^3$  | $\\leq n-3$ |\n|      $4$      |  $10^3$  |  $10^3$  | $\\leq n-3$ |\n|      $5$      |  $10^5$  |  $10^5$  |    $=1$    |\n|      $6$      |  $10^5$  |  $10^5$  |    $=1$    |\n|      $7$      |  $10^5$  |  $10^5$  |    $=1$    |\n|      $8$      |  $10^5$  |  $10^5$  |    $=1$    |\n|      $9$      |  $10^5$  |  $10^5$  |    $=2$    |\n|     $10$      |  $10^5$  |  $10^5$  |    $=2$    |\n|     $11$      |  $10^5$  |  $10^5$  |  $\\leq 3$  |\n|     $12$      |  $10^5$  |  $10^5$  |  $\\leq 5$  |\n|     $13$      |  $10^5$  |  $10^5$  |  $\\leq 9$  |\n|     $14$      |  $10^5$  |  $10^5$  | $\\leq 12$  |\n|     $15$      |  $10^5$  |  $10^5$  | $\\leq 20$  |\n|     $16$      |  $10^5$  |  $10^5$  | $\\leq 100$ |\n|     $17$      |  $10^5$  |  $10^5$  | $\\leq 100$ |\n|     $18$      |  $10^5$  |  $10^5$  | $\\leq 100$ |\n|     $19$      |  $10^5$  |  $10^5$  | $\\leq 100$ |\n|     $20$      |  $10^5$  |  $10^5$  | $\\leq 100$ |", "inputFormat": "The first line contains two positive integers $n, m$, denoting the initial number of clones and the total number of time steps.\n\nThe next $n$ lines each contain two integers $x_i, y_i$, describing the position of the $i$-th clone.\n\nThe next $m$ lines: on each line, the first integer $k$ indicates that $k$ clones disappear at this time step. Then there are $k$ non-negative integers $c_1, c_2, \\ldots, c_k$, used to generate the indices of the disappearing clones.\n\nGeneration method:\n\nLet $S$ be twice the area of the region occupied by the clones at the previous time step. Then the indices of the clones that disappear at this time step, $p_1, p_2, \\ldots , p_k$, are:\n$p_i = [(S + c_i) \\bmod n] + 1$.\n\nIn particular, at the first time step we assume $S = -1$, i.e., the indices of the clones that disappear at the first time step, $p_1, p_2, \\ldots , p_k$, are:\n$p_i = [(−1 + c_i) \\bmod n] + 1$.", "outputFormat": "Output $m$ lines in the order of the time steps. Each line contains one integer: twice the area of the region occupied by the remaining clones at that time step.", "hint": "Sample explanation:\n\nAs shown in the figure: the left figure shows the positions of the $6$ clones and the region they occupy; the middle figure shows the situation at the first time step, where the indices of the disappearing clones are $1, 3, 6$. The remaining $3$ points occupy the region inside the solid lines in the figure, and twice the area is $3$. The right figure shows the situation at the second time step, where the indices of the disappearing clones are\n\n$[(0 + 3)\\bmod 6] + 1 = 4$\n\n$[(1 + 3)\\bmod 6] + 1 = 5$\n\nThe remaining $4$ points occupy the region inside the solid lines in the figure.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bieyspo4.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2017] 分身术", "background": "", "description": "> “分！身！术！” —— 小 P\n\n平面上有 $n$ 个小 P 的分身。定义一组分身占领的区域为覆盖这组分身的最小凸多边形。小 P 能力有限，每一时刻都会有若干分身消失。但在下一时刻之前，小 P 会使用分身术使得这些消失的分身重新出现在原来的位置。\n\n小 P 想知道，每一时刻分身消失后，剩下的分身占领的区域面积是多少？\n", "inputFormat": "输入第一行包含两个正整数 $n,m$，描述初始时分身的个数，和总时刻数。\n\n接下来 $n$ 行，第 $i$ 行有两个整数 $x_i, y_i$ ，描述第 $i$ 个分身的位置。\n\n接下来 $m$ 行，每行的第一个整数 $k$ 表示这一时刻有 $k$ 个分身消失。接下来有 $k$ 个非负整数 $c_1, c_2, \\ldots, c_k$，用于生成消失的分身的编号。\n\n生成方式如下：\n\n设上一个时刻中，分身占领面积的**两倍**为 $S$。则该时刻消失的分身 $p_1, p_2, \\ldots , p_k$ 的编号为：$p_i = [(S + c_i) \\bmod n] + 1$。\n\n特别的，在第一个时刻，我们认为上一个时刻中，$S = -1$，即：第一个时刻消失的分身$p_1, p_2, \\ldots , p_k$的编号为：$p_i = [(−1 + c_i) \\bmod n] + 1$。", "outputFormat": "按给出时刻的顺序依次输出 $m$ 行，每行一个整数，表示该时刻剩余分身所占领区域面积的**两倍**。", "hint": "### 样例解释\n\n如下图所示：左图表示输入的 $6$ 个分身的位置及它们占领的区域；中图表示第一个时刻的情形，消失的分身编号分别为 $1,3,6$，剩余 $3$ 个点占领图中实线内部区域，占据面积的两倍为 $3$；右图表示第二个时刻的情形，消失的分身编号分别为\n\n$[(0 + 3)\\bmod 6] + 1 = 4$\n\n$[(1 + 3)\\bmod 6] + 1 = 5$\n\n剩余的 $4$ 个点占领图中实线内部区域。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bieyspo4.png) \n\n对于所有数据，保证：\n\n-  $|x_i|,|y_i|\\le 10^8$ ；\n- 没有两个分身的坐标是完全相同的；\n-  $k\\le 100$ ；\n- 所有时刻的  $k$ 之和不超过  $2\\times 10^6$ ；\n-  $0\\le c_i\\le 2^{31}-1$ ；\n- 初始时，所有的  $n$ 个分身占据区域面积大于  $0$ ；\n- 定义所有  $n$ 个分身所占据区域的**顶点集合**为  $S$ ，  $|S|\\ge 3$ 。在任意时刻，  $S$ 中至少存在两个未消失的分身。\n\n| 测试点编号 | $n \\leq$ | $m \\leq$ |    $k$     |\n| :--------: | :------: | :------: | :--------: |\n|    $1$     |   $10$   |   $10$   | $\\leq n-3$ |\n|    $2$     |  $10^3$  |  $10^3$  | $\\leq n-3$ |\n|    $3$     |  $10^3$  |  $10^3$  | $\\leq n-3$ |\n|    $4$     |  $10^3$  |  $10^3$  | $\\leq n-3$ |\n|    $5$     |  $10^5$  |  $10^5$  |    $=1$    |\n|    $6$     |  $10^5$  |  $10^5$  |    $=1$    |\n|    $7$     |  $10^5$  |  $10^5$  |    $=1$    |\n|    $8$     |  $10^5$  |  $10^5$  |    $=1$    |\n|    $9$     |  $10^5$  |  $10^5$  |    $=2$    |\n|    $10$    |  $10^5$  |  $10^5$  |    $=2$    |\n|    $11$    |  $10^5$  |  $10^5$  |  $\\leq 3$  |\n|    $12$    |  $10^5$  |  $10^5$  |  $\\leq 5$  |\n|    $13$    |  $10^5$  |  $10^5$  |  $\\leq 9$  |\n|    $14$    |  $10^5$  |  $10^5$  | $\\leq 12$  |\n|    $15$    |  $10^5$  |  $10^5$  | $\\leq 20$  |\n|    $16$    |  $10^5$  |  $10^5$  | $\\leq 100$ |\n|    $17$    |  $10^5$  |  $10^5$  | $\\leq 100$ |\n|    $18$    |  $10^5$  |  $10^5$  | $\\leq 100$ |\n|    $19$    |  $10^5$  |  $10^5$  | $\\leq 100$ |\n|    $20$    |  $10^5$  |  $10^5$  | $\\leq 100$ |", "locale": "zh-CN"}}}
{"pid": "P3828", "type": "P", "difficulty": 6, "samples": [["2\n46\n78\n0 1 0 1 0 1", "2"], ["2\n23\n52\n1 1 1 1 1 1", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2012", "各省省选", "上海"], "title": "[SHOI2012] 火柴游戏", "background": "SHOI2012D1T1\n", "description": "小明非常喜欢玩火柴游戏：首先用火柴棒摆出一个可能是错误的等式，然后通过添加、删除或移动火柴棒，使得等式成立。下图展示每个数字的样子：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6548.png) \n\n我们只考虑形如“A = B”的式子，其中 A 和 B 是两个具有相同位数的整数。\n\n小明可进行三种操作：\n\n1. 在任意位置添加一根火柴棒；\n\n2. 从任意位置删除一根火柴棒；\n\n3. 将任意一根火柴棒移动到另一个位置。\n\n在完成所有操作后，等号两侧必须都是合法的数字，且完全相等。我们约定：\n\n1. 小明不能消除任何数字，也就是说，可以删除一个数字的部分火柴，但不能令它消失；\n\n2. 小明不能增加任何数字，也就是说，可以在一个已有的数字上添加火柴，或将火柴移动到一个已有的数字上，但不能凭空增加一个数字；\n\n3. 小明不能拆分或者合并数字，比如将一个 8 变成两个 1，或者将两个 1合并成一个 8；\n\n4. 其中代表 1 的火柴棒必须靠右边摆放，放在左边不是有效的数字。每种操作都有一定的代价：\n\n 对一个添加操作，如果这是第$i$次进行添加操作，这一步的费用为 $p_1\\times i+q_1$\n\n 对一个删除操作，如果这是第$i$次进行删除操作，这一步的费用为$p_2\\times i+q_2$\n\n 对一个移动操作，如果这是第$i$次进行移动操作，这一步的费用为$p_3\\times i+q_3$\n\n例如，小明在游戏中添加了 3 根火柴，移动了 1 根火柴，删除了 2 根火柴，那么他总的花费为$[(p_1\\times 1+q_1)+(p_1\\times 2+q_1)+(p_1\\times 3+q_1)]+(p_3\\times 1+q_3)+[(p_2\\times 1+q_2 )+(p_2\\times 2+q_2)]$。\n\n小明想知道，他如何才能用最少的花费使等式成立。你能写个程序帮助他吗？\n", "inputFormat": "第 1 行，一个整数 L，表示等式中两个数的位数。\n\n第 2-3 行，每行各一个长度为 L、仅由数字构成的字符串，表示等式两侧的数。\n\n第 4 行，给出六个不超过 100 的非负整数$p_1,q_1,p_2,q_2,p_3,q_3$。\n", "outputFormat": "输出一行，包含一个整数，为使等式成立的最小的操作代价。\n", "hint": "对于 30%数据，有$L\\le 20$，且$p_1 = p_2 = p_3 = 0$；\n\n对于 60%数据，有$L\\le 100$；\n\n对于 100%数据，有$L\\le 200$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2012] Matchstick Game", "background": "SHOI2012D1T1.", "description": "Xiaoming loves playing the matchstick game: first he uses matchsticks to form an equation that may be incorrect, then by adding, deleting, or moving matchsticks, he makes the equation correct. The following image shows what each digit looks like:\n\n![](https://cdn.luogu.com.cn/upload/pic/6548.png)\n\nWe only consider expressions of the form \"A = B\", where A and B are two integers with the same number of digits.\n\nXiaoming can perform three types of operations:\n1. Add one matchstick at any position.\n2. Delete one matchstick from any position.\n3. Move any one matchstick to another position.\n\nAfter all operations, both sides of the equal sign must be valid numbers and exactly the same. We agree on the following rules:\n1. Xiaoming cannot eliminate any digit entirely. That is, you may delete some sticks from a digit, but you must not make that digit disappear.\n2. Xiaoming cannot create any new digit. That is, you may add sticks onto an existing digit or move sticks onto an existing digit, but you must not create a new digit out of nothing.\n3. Xiaoming cannot split or merge digits. For example, turning an 8 into two 1s, or merging two 1s into one 8, is not allowed.\n4. The matchstick representing the digit 1 must be placed on the right side; placing it on the left does not form a valid digit.\n\nEach operation has a certain cost:\n- For an add operation, if this is the $i$-th add, the cost of this step is $p_1\\times i+q_1$.\n- For a delete operation, if this is the $i$-th delete, the cost of this step is $p_2\\times i+q_2$.\n- For a move operation, if this is the $i$-th move, the cost of this step is $p_3\\times i+q_3$.\n\nFor example, if Xiaoming adds 3 matchsticks, moves 1 matchstick, and deletes 2 matchsticks, then his total cost is $[(p_1\\times 1+q_1)+(p_1\\times 2+q_1)+(p_1\\times 3+q_1)]+(p_3\\times 1+q_3)+[(p_2\\times 1+q_2 )+(p_2\\times 2+q_2)]$.\n\nXiaoming wants to know the minimum cost to make the equation correct. Can you write a program to help him?", "inputFormat": "- Line 1: An integer L, the number of digits on each side of the equation.\n- Lines 2–3: Each line contains a length L string consisting only of digits, representing the numbers on the two sides of the equation.\n- Line 4: Six non-negative integers not exceeding 100: $p_1,q_1,p_2,q_2,p_3,q_3$.", "outputFormat": "Output one line containing a single integer: the minimum total operation cost to make the equation correct.", "hint": "For 30% of the testdata, $L\\le 20$, and $p_1 = p_2 = p_3 = 0$.\n\nFor 60% of the testdata, $L\\le 100$.\n\nFor 100% of the testdata, $L\\le 200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2012] 火柴游戏", "background": "SHOI2012D1T1\n", "description": "小明非常喜欢玩火柴游戏：首先用火柴棒摆出一个可能是错误的等式，然后通过添加、删除或移动火柴棒，使得等式成立。下图展示每个数字的样子：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6548.png) \n\n我们只考虑形如“A = B”的式子，其中 A 和 B 是两个具有相同位数的整数。\n\n小明可进行三种操作：\n\n1. 在任意位置添加一根火柴棒；\n\n2. 从任意位置删除一根火柴棒；\n\n3. 将任意一根火柴棒移动到另一个位置。\n\n在完成所有操作后，等号两侧必须都是合法的数字，且完全相等。我们约定：\n\n1. 小明不能消除任何数字，也就是说，可以删除一个数字的部分火柴，但不能令它消失；\n\n2. 小明不能增加任何数字，也就是说，可以在一个已有的数字上添加火柴，或将火柴移动到一个已有的数字上，但不能凭空增加一个数字；\n\n3. 小明不能拆分或者合并数字，比如将一个 8 变成两个 1，或者将两个 1合并成一个 8；\n\n4. 其中代表 1 的火柴棒必须靠右边摆放，放在左边不是有效的数字。每种操作都有一定的代价：\n\n 对一个添加操作，如果这是第$i$次进行添加操作，这一步的费用为 $p_1\\times i+q_1$\n\n 对一个删除操作，如果这是第$i$次进行删除操作，这一步的费用为$p_2\\times i+q_2$\n\n 对一个移动操作，如果这是第$i$次进行移动操作，这一步的费用为$p_3\\times i+q_3$\n\n例如，小明在游戏中添加了 3 根火柴，移动了 1 根火柴，删除了 2 根火柴，那么他总的花费为$[(p_1\\times 1+q_1)+(p_1\\times 2+q_1)+(p_1\\times 3+q_1)]+(p_3\\times 1+q_3)+[(p_2\\times 1+q_2 )+(p_2\\times 2+q_2)]$。\n\n小明想知道，他如何才能用最少的花费使等式成立。你能写个程序帮助他吗？\n", "inputFormat": "第 1 行，一个整数 L，表示等式中两个数的位数。\n\n第 2-3 行，每行各一个长度为 L、仅由数字构成的字符串，表示等式两侧的数。\n\n第 4 行，给出六个不超过 100 的非负整数$p_1,q_1,p_2,q_2,p_3,q_3$。\n", "outputFormat": "输出一行，包含一个整数，为使等式成立的最小的操作代价。\n", "hint": "对于 30%数据，有$L\\le 20$，且$p_1 = p_2 = p_3 = 0$；\n\n对于 60%数据，有$L\\le 100$；\n\n对于 100%数据，有$L\\le 200$。\n", "locale": "zh-CN"}}}
{"pid": "P3829", "type": "P", "difficulty": 5, "samples": [["2\n6.0 2.0 0.0\n0.0 0.0 0.0\n2.0 -2.0 1.5707963268", "21.66"], ["3\n6.0 6.0 1.0\n4.0 4.0 0.0\n0.0 8.0 0.0\n0.0 0.0 0.0", "41.60"], ["3\n6.0 6.0 1.0\n4.0 4.0 0.1745329252\n0.0 8.0 0.3490658504\n0.0 0.0 0.5235987756", "41.63"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2012", "各省省选", "上海", "凸包"], "title": "[SHOI2012] 信用卡凸包", "background": "SHOI2012D1T2", "description": "信用卡是一个矩形，唯四个角作了圆滑处理，使它们都是与矩形的两边相切的 $\\frac14$ 圆，如下图所示。现在平面上有一些规格相同的信用卡，试求其凸包的周长。注意凸包未必是多边形，因为它可能包含若干段圆弧。\n\n ![](https://cdn.luogu.com.cn/upload/pic/6549.png)", "inputFormat": "输入的第一行是一个正整数 $n$，表示信用卡的张数。第二行包含三个实数 $a,b,r$，分别表示信用卡（圆滑处理前）竖直方向的长度、水平方向的长度，以及 $\\frac14$ 圆的半径。\n\n之后 $n$ 行，每行包含三个实数 $x,y,\\theta$，分别表示一张信用卡中心（即对角线交点）的横、纵坐标，以及绕中心**逆时针**旋转的弧度。", "outputFormat": "输出只有一行，包含一个实数，表示凸包的周长，四舍五入精确到小数点后 2 位。", "hint": "样例 1 说明：\n\n![](https://cdn.luogu.com.cn/upload/pic/6550.png)\n\n本样例中的 $2$ 张信用卡的轮廓在上图中用实线标出，如果视 $1.5707963268$ 为 $\\frac\\pi2$，那么凸包的周长为 $16+4\\sqrt2$\n\n样例 2 说明：\n\n![](https://cdn.luogu.com.cn/upload/pic/6551.png)\n\n样例 3 说明：\n\n![](https://cdn.luogu.com.cn/upload/pic/6552.png)\n\n其凸包的周长约为 $41.628267652$。\n\n\n本题可能需要使用数学库中的三角函数。不熟悉使用方法的选手，可以参考下面的程序及其输出结果：\n\n```cpp\nuses math;\nconst Pi = 3.141592653589793;\nbegin\nwriteln(sin(30.0 / 180.0 * Pi) : 0 : 10);\nwriteln(cos(60.0 / 180.0 * Pi) : 0 : 10);\nwriteln(tan(45.0 / 180.0 * Pi) : 0 : 10);\nwriteln(arcsin(1.0) : 0 : 10);\nwriteln(arccos(0.0) : 0 : 10);\nwriteln(arctan(1.0) : 0 : 10);\nend.\n```\n```cpp\n#include <iostream>\n#include <math.h>\nusing namespace std;\nconst double Pi = 3.141592653589793;\nint main()\n{\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    cout<<sin(30.0 / 180.0 * Pi)<<endl;\n    cout<<cos(60.0 / 180.0 * Pi)<<endl;\n    cout<<tan(45.0 / 180.0 * Pi)<<endl;\n    cout<<asin(1.0)<<endl;\n    cout<<acos(0.0)<<endl;\n    cout<<atan(1.0)<<endl;\n    return 0;\n}\n```\n输出结果：\n```\n0.5000000000\n0.5000000000\n1.0000000000\n1.5707963268\n1.5707963268\n0.7853981634\n```\n\n数据范围：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6553.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/6554.png)", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2012] Credit Card Convex Hull", "background": "SHOI2012D1T2", "description": "A credit card is a rectangle whose four corners are rounded so that each corner is a $1/4$ circle tangent to the two adjacent sides, as shown below. Now there are several credit cards of identical specifications placed on the plane. Find the perimeter of their convex hull. Note that the convex hull is not necessarily a polygon, because it may contain several circular arcs.\n\n![](https://cdn.luogu.com.cn/upload/pic/6549.png)", "inputFormat": "The first line contains a positive integer $n$, the number of credit cards. The second line contains three real numbers $a$, $b$, $r$, which denote, respectively, the length of the credit card (before rounding) in the vertical direction, the length in the horizontal direction, and the radius of each $1/4$ circle.\n\nThen there are $n$ lines. Each line contains three real numbers $x$, $y$, $\\theta$, which denote, respectively, the $x$- and $y$-coordinates of a card’s center (i.e., the intersection point of its diagonals), and the angle (in radians) it is rotated counterclockwise about its center.", "outputFormat": "Output a single line containing one real number: the perimeter of the convex hull, rounded to 2 decimal places.", "hint": "Explanation for Sample 1: ![](https://cdn.luogu.com.cn/upload/pic/6550.png)\n\nIn this sample, the outlines of the 2 credit cards are drawn in solid lines above. If we regard $1.5707963268$ as $\\pi/2$, then the perimeter of the convex hull is $16 + 4\\sqrt{2}$.\n\nExplanation for Sample 2: ![](https://cdn.luogu.com.cn/upload/pic/6551.png)\n\nExplanation for Sample 3: ![](https://cdn.luogu.com.cn/upload/pic/6552.png)\n\nThe perimeter of its convex hull is approximately $41.628267652$.\n\nThis problem may require trigonometric functions from the math library. If you are not familiar with their usage, you can refer to the following programs and their outputs:\n\n```cpp\nuses math;\nconst Pi = 3.141592653589793;\nbegin\nwriteln(sin(30.0 / 180.0 * Pi) : 0 : 10);\nwriteln(cos(60.0 / 180.0 * Pi) : 0 : 10);\nwriteln(tan(45.0 / 180.0 * Pi) : 0 : 10);\nwriteln(arcsin(1.0) : 0 : 10);\nwriteln(arccos(0.0) : 0 : 10);\nwriteln(arctan(1.0) : 0 : 10);\nend.\n```\n```cpp\n#include <iostream>\n#include <math.h>\nusing namespace std;\nconst double Pi = 3.141592653589793;\nint main()\n{\ncout.setf(ios::fixed);\ncout.precision(10);\ncout<<sin(30.0 / 180.0 * Pi)<<endl;\ncout<<cos(60.0 / 180.0 * Pi)<<endl;\ncout<<tan(45.0 / 180.0 * Pi)<<endl;\ncout<<asin(1.0)<<endl;\ncout<<acos(0.0)<<endl;\ncout<<atan(1.0)<<endl;\nreturn 0;\n}\n```\nOutput:\n0.5000000000\n\n0.5000000000\n\n1.0000000000\n\n1.5707963268\n\n1.5707963268\n\n0.7853981634\n\nConstraints:\n\n![](https://cdn.luogu.com.cn/upload/pic/6553.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/6554.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2012] 信用卡凸包", "background": "SHOI2012D1T2", "description": "信用卡是一个矩形，唯四个角作了圆滑处理，使它们都是与矩形的两边相切的 $\\frac14$ 圆，如下图所示。现在平面上有一些规格相同的信用卡，试求其凸包的周长。注意凸包未必是多边形，因为它可能包含若干段圆弧。\n\n ![](https://cdn.luogu.com.cn/upload/pic/6549.png)", "inputFormat": "输入的第一行是一个正整数 $n$，表示信用卡的张数。第二行包含三个实数 $a,b,r$，分别表示信用卡（圆滑处理前）竖直方向的长度、水平方向的长度，以及 $\\frac14$ 圆的半径。\n\n之后 $n$ 行，每行包含三个实数 $x,y,\\theta$，分别表示一张信用卡中心（即对角线交点）的横、纵坐标，以及绕中心**逆时针**旋转的弧度。", "outputFormat": "输出只有一行，包含一个实数，表示凸包的周长，四舍五入精确到小数点后 2 位。", "hint": "样例 1 说明：\n\n![](https://cdn.luogu.com.cn/upload/pic/6550.png)\n\n本样例中的 $2$ 张信用卡的轮廓在上图中用实线标出，如果视 $1.5707963268$ 为 $\\frac\\pi2$，那么凸包的周长为 $16+4\\sqrt2$\n\n样例 2 说明：\n\n![](https://cdn.luogu.com.cn/upload/pic/6551.png)\n\n样例 3 说明：\n\n![](https://cdn.luogu.com.cn/upload/pic/6552.png)\n\n其凸包的周长约为 $41.628267652$。\n\n\n本题可能需要使用数学库中的三角函数。不熟悉使用方法的选手，可以参考下面的程序及其输出结果：\n\n```cpp\nuses math;\nconst Pi = 3.141592653589793;\nbegin\nwriteln(sin(30.0 / 180.0 * Pi) : 0 : 10);\nwriteln(cos(60.0 / 180.0 * Pi) : 0 : 10);\nwriteln(tan(45.0 / 180.0 * Pi) : 0 : 10);\nwriteln(arcsin(1.0) : 0 : 10);\nwriteln(arccos(0.0) : 0 : 10);\nwriteln(arctan(1.0) : 0 : 10);\nend.\n```\n```cpp\n#include <iostream>\n#include <math.h>\nusing namespace std;\nconst double Pi = 3.141592653589793;\nint main()\n{\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    cout<<sin(30.0 / 180.0 * Pi)<<endl;\n    cout<<cos(60.0 / 180.0 * Pi)<<endl;\n    cout<<tan(45.0 / 180.0 * Pi)<<endl;\n    cout<<asin(1.0)<<endl;\n    cout<<acos(0.0)<<endl;\n    cout<<atan(1.0)<<endl;\n    return 0;\n}\n```\n输出结果：\n```\n0.5000000000\n0.5000000000\n1.0000000000\n1.5707963268\n1.5707963268\n0.7853981634\n```\n\n数据范围：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6553.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/6554.png)", "locale": "zh-CN"}}}
{"pid": "P3830", "type": "P", "difficulty": 6, "samples": [["1 4", "2.166667"], ["2 4", "2.666667"], ["1 12", "4.206421"], ["2 12", "5.916614"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2012", "各省省选", "上海", "期望", "构造"], "title": "[SHOI2012] 随机树", "background": "SHOI2012 D1T3", "description": "一棵含 $n$ 个叶结点的二叉树可以通过如下方式生成。初始时只有根结点。首先，将根结点展开（本题中的“展开”是指给一个叶结点添上左、右两个子结点）：\n\n[a]\n\n然后，等概率地随机将两个叶结点中的一个展开，即生成以下两棵树之一：\n\n[b]\n\n之后，每次在当前二叉树的所有叶结点中，等概率地随机选择一个，将其展开。\n\n不断地重复这一操作，直至产生 $n$ 个叶结点为止。例如，某棵含 5 个叶结点的二叉树可能按如下步骤生成。\n\n[c]\n\n对于按该方式随机生成的一棵含 $n$ 个叶结点的二叉树，求：\n\n1. **叶结点平均深度** 的数学期望值。\n2. **树深度** 的数学期望值。约定根结点的深度为 0。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7ql5uhxn.png)", "inputFormat": "输入仅有一行，包含两个正整数 $q$, $n$，分别表示问题编号以及叶结点的个数。", "outputFormat": "输出仅有一行，包含一个实数 $d$，四舍五入精确到小数点后 $6$ 位。如果 $q = 1$，则 $d$ 表示叶结点平均深度的数学期望值；如果 $q = 2$，则 $d$ 表示树深度的数学期望值。", "hint": "### 【样例1、样例2说明】\n数学期望值是随机变量的值乘以其概率的总和：记随机变量 $X$ 可能的取值为 $x_1,x_2,\\cdots,x_n$，它们取到的概率分别为 $p_1,p_2,\\cdots,p_n$，那么随机变量 $X$ 的数学期望值就是\n\n$E(X)=\\sum_{i = 1}^{n}p_ix_i$\n\n例如，掷一枚写有 1、2、3、4、5、6 这 6 个数的均匀骰子，掷到的数的数学期望值是：\n\n$E=\\frac{1}{6}\\times1+\\frac{1}{6}\\times2+\\frac{1}{6}\\times3+\\frac{1}{6}\\times4+\\frac{1}{6}\\times5+\\frac{1}{6}\\times6 = 3.5$\n\n尽管 3.5 不是骰子上的某个数。又如，一道 4 选 1 的选择题，答对得 5 分，不答不得分，答错倒扣 1 分。那么，当我们不答时，一定得 0 分；而等概率地随便猜一个时，得分的数学期望值是：\n\n$E=\\frac{1}{4}\\times 5+\\frac{1}{4}\\times (-1)+\\frac{1}{4}\\times (-1)+\\frac{1}{4}\\times (-1)=\\frac{1}{2}$\n\n本题中，根据二叉树的生成方式，当 $n = 4$ 时，下图中前四棵树被生成的概率均为 $1/6$，最后一棵树被生成的概率为 $1/3$。它们的叶结点平均深度分别是 $9/4$、$9/4$、$9/4$、2，因此叶结点平均深度的数学期望值是\n\n$E=\\frac{1}{6}\\times\\frac{9}{4}+\\frac{1}{6}\\times\\frac{9}{4}+\\frac{1}{6}\\times\\frac{9}{4}+\\frac{1}{6}\\times\\frac{9}{4}+\\frac{1}{3}\\times2=\\frac{13}{6}$\n\n而它们的树深度分别是 3、3、3、3、2，因此树深度的数学期望值是\n\n$E=\\frac{1}{6}\\times3+\\frac{1}{6}\\times3+\\frac{1}{6}\\times3+\\frac{1}{6}\\times3+\\frac{1}{3}\\times2=\\frac{8}{3}$\n\n### 【数据规模】\n| 测试数据编号 | $q$ | $n$ |\n| ---- | ---- | ---- |\n| 1,2 | $q = 1$ | $2\\leq n\\leq10$ |\n| 3,4,5 | $q = 1$ | $2\\leq n\\leq100$ |\n| 6,7 | $q = 2$ | $2\\leq n\\leq10$ |\n| 8,9,10 | $q = 2$ | $2\\leq n\\leq100$ | \n\n![](https://cdn.luogu.com.cn/upload/pic/6556.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/6557.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/6558.png)", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2012] Random Tree", "background": "SHOI2012 D1T3.", "description": "A binary tree with $n$ leaf nodes can be generated as follows. Initially there is only the root node. First, expand the root node (in this problem, “expand” means adding left and right children to a leaf node):\n\n[a]\n\nThen, uniformly at random choose one of the two leaf nodes to expand, i.e., generate one of the following two trees:\n\n[b]\n\nAfter that, at each step, uniformly at random choose one leaf node from all current leaf nodes and expand it.\n\nRepeat this operation until there are $n$ leaf nodes. For example, a binary tree with $5$ leaf nodes might be generated by the following steps.\n\n[c]\n\nFor a binary tree with $n$ leaf nodes generated by this process, find:\n\n1. The expected value of the average depth of the leaf nodes.\n2. The expected value of the tree depth. The root node is defined to have depth $0$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7ql5uhxn.png)", "inputFormat": "The input contains one line with two positive integers $q$, $n$, representing the query type and the number of leaf nodes, respectively.", "outputFormat": "Output one line with a real number $d$, rounded to $6$ digits after the decimal point. If $q = 1$, then $d$ is the expected value of the average depth of the leaf nodes; if $q = 2$, then $d$ is the expected value of the tree depth.", "hint": "【Explanation for Samples 1 and 2】\nThe expected value of a random variable is the sum of each value times its probability. Let the possible values of random variable $X$ be $x_1, x_2, \\cdots, x_n$, and their probabilities be $p_1, p_2, \\cdots, p_n$. Then the expected value of $X$ is\n$E(X)=\\sum_{i = 1}^{n} p_i x_i$.\n\nFor example, when rolling a fair die labeled with the $6$ numbers $1, 2, 3, 4, 5, 6$, the expected value of the outcome is:\n$E=\\frac{1}{6}\\times 1+\\frac{1}{6}\\times 2+\\frac{1}{6}\\times 3+\\frac{1}{6}\\times 4+\\frac{1}{6}\\times 5+\\frac{1}{6}\\times 6 = 3.5$,\neven though $3.5$ is not one of the die faces. As another example, consider a single-choice question with $4$ options: a correct answer gives $5$ points, no answer gives $0$ points, and a wrong answer gives $-1$ point. If we do not answer, we certainly get $0$; if we guess uniformly at random, the expected score is:\n$E=\\frac{1}{4}\\times 5+\\frac{1}{4}\\times (-1)+\\frac{1}{4}\\times (-1)+\\frac{1}{4}\\times (-1)=\\frac{1}{2}$.\n\nIn this problem, according to the generation process, when $n = 4$, in the figure below the first four trees are generated with probability $1/6$ each, and the last tree with probability $1/3$. Their average leaf depths are $9/4$, $9/4$, $9/4$, $9/4$, $2$, so the expected value of the average leaf depth is\n$E=\\frac{1}{6}\\times \\frac{9}{4}+\\frac{1}{6}\\times \\frac{9}{4}+\\frac{1}{6}\\times \\frac{9}{4}+\\frac{1}{6}\\times \\frac{9}{4}+\\frac{1}{3}\\times 2=\\frac{13}{6}$.\nTheir tree depths are $3, 3, 3, 3, 2$, so the expected value of the tree depth is\n$E=\\frac{1}{6}\\times 3+\\frac{1}{6}\\times 3+\\frac{1}{6}\\times 3+\\frac{1}{6}\\times 3+\\frac{1}{3}\\times 2=\\frac{8}{3}$.\n\nConstraints\n| Testdata ID | $q$ | $n$ |\n| ---- | ---- | ---- |\n| 1, 2 | $q = 1$ | $2 \\leq n \\leq 10$ |\n| 3, 4, 5 | $q = 1$ | $2 \\leq n \\leq 100$ |\n| 6, 7 | $q = 2$ | $2 \\leq n \\leq 10$ |\n| 8, 9, 10 | $q = 2$ | $2 \\leq n \\leq 100$ |\n\n![](https://cdn.luogu.com.cn/upload/pic/6556.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/6557.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/6558.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2012] 随机树", "background": "SHOI2012 D1T3", "description": "一棵含 $n$ 个叶结点的二叉树可以通过如下方式生成。初始时只有根结点。首先，将根结点展开（本题中的“展开”是指给一个叶结点添上左、右两个子结点）：\n\n[a]\n\n然后，等概率地随机将两个叶结点中的一个展开，即生成以下两棵树之一：\n\n[b]\n\n之后，每次在当前二叉树的所有叶结点中，等概率地随机选择一个，将其展开。\n\n不断地重复这一操作，直至产生 $n$ 个叶结点为止。例如，某棵含 5 个叶结点的二叉树可能按如下步骤生成。\n\n[c]\n\n对于按该方式随机生成的一棵含 $n$ 个叶结点的二叉树，求：\n\n1. **叶结点平均深度** 的数学期望值。\n2. **树深度** 的数学期望值。约定根结点的深度为 0。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7ql5uhxn.png)", "inputFormat": "输入仅有一行，包含两个正整数 $q$, $n$，分别表示问题编号以及叶结点的个数。", "outputFormat": "输出仅有一行，包含一个实数 $d$，四舍五入精确到小数点后 $6$ 位。如果 $q = 1$，则 $d$ 表示叶结点平均深度的数学期望值；如果 $q = 2$，则 $d$ 表示树深度的数学期望值。", "hint": "### 【样例1、样例2说明】\n数学期望值是随机变量的值乘以其概率的总和：记随机变量 $X$ 可能的取值为 $x_1,x_2,\\cdots,x_n$，它们取到的概率分别为 $p_1,p_2,\\cdots,p_n$，那么随机变量 $X$ 的数学期望值就是\n\n$E(X)=\\sum_{i = 1}^{n}p_ix_i$\n\n例如，掷一枚写有 1、2、3、4、5、6 这 6 个数的均匀骰子，掷到的数的数学期望值是：\n\n$E=\\frac{1}{6}\\times1+\\frac{1}{6}\\times2+\\frac{1}{6}\\times3+\\frac{1}{6}\\times4+\\frac{1}{6}\\times5+\\frac{1}{6}\\times6 = 3.5$\n\n尽管 3.5 不是骰子上的某个数。又如，一道 4 选 1 的选择题，答对得 5 分，不答不得分，答错倒扣 1 分。那么，当我们不答时，一定得 0 分；而等概率地随便猜一个时，得分的数学期望值是：\n\n$E=\\frac{1}{4}\\times 5+\\frac{1}{4}\\times (-1)+\\frac{1}{4}\\times (-1)+\\frac{1}{4}\\times (-1)=\\frac{1}{2}$\n\n本题中，根据二叉树的生成方式，当 $n = 4$ 时，下图中前四棵树被生成的概率均为 $1/6$，最后一棵树被生成的概率为 $1/3$。它们的叶结点平均深度分别是 $9/4$、$9/4$、$9/4$、2，因此叶结点平均深度的数学期望值是\n\n$E=\\frac{1}{6}\\times\\frac{9}{4}+\\frac{1}{6}\\times\\frac{9}{4}+\\frac{1}{6}\\times\\frac{9}{4}+\\frac{1}{6}\\times\\frac{9}{4}+\\frac{1}{3}\\times2=\\frac{13}{6}$\n\n而它们的树深度分别是 3、3、3、3、2，因此树深度的数学期望值是\n\n$E=\\frac{1}{6}\\times3+\\frac{1}{6}\\times3+\\frac{1}{6}\\times3+\\frac{1}{6}\\times3+\\frac{1}{3}\\times2=\\frac{8}{3}$\n\n### 【数据规模】\n| 测试数据编号 | $q$ | $n$ |\n| ---- | ---- | ---- |\n| 1,2 | $q = 1$ | $2\\leq n\\leq10$ |\n| 3,4,5 | $q = 1$ | $2\\leq n\\leq100$ |\n| 6,7 | $q = 2$ | $2\\leq n\\leq10$ |\n| 8,9,10 | $q = 2$ | $2\\leq n\\leq100$ | \n\n![](https://cdn.luogu.com.cn/upload/pic/6556.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/6557.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/6558.png)", "locale": "zh-CN"}}}
{"pid": "P3831", "type": "P", "difficulty": 5, "samples": [["2 1\n1 2\n1 1 2 2", "5"], ["6 9\n2 1\n2 5\n3 2\n4 4\n5 2\n5 6\n6 1\n6 3\n6 4\n1 1 4 6", "27"], ["6 10\n2 1\n2 5\n3 2\n4 4\n5 2\n5 6\n6 1\n6 3\n6 4\n6 6\n1 1 4 6", "26"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2012", "各省省选", "上海", "最短路"], "title": "[SHOI2012] 回家的路", "background": "SHOI2012 D2T1", "description": "2046 年 OI 城的城市轨道交通建设终于全部竣工，由于前期规划周密，建成后的轨道交通网络由 $2n$ 条地铁线路构成，组成了一个 $n$ 纵 $n$ 横的交通网。如下图所示，这 $2n$ 条线路每条线路都包含 $n$ 个车站，而每个车站都在一组纵横线路的交汇处。\n\n\n出于建设成本的考虑，并非每个车站都能够进行站内换乘，能够进行站内换乘的地铁站共有 $m$ 个，在下图中，标上方块标记的车站为换乘车站。已知地铁运行 $1$ 站需要 $2$ 分钟，而站内换乘需要步行 $1$ 分钟。Serenade 想要知道，在不中途出站的前提下，他从学校回家最快需要多少时间（等车时间忽略不计）。\n\n\n![](https://cdn.luogu.com.cn/upload/pic/6547.png)", "inputFormat": "第一行有两个整数 $n,m$。\n\n接下去 $m$ 行每行两个整数 $x,y$，表示第 $x$ 条横向线路与第 $y$ 条纵向线路的交汇站是站内换乘站。\n\n接下去一行是四个整数 $x_1,y_1,x_2,y_2$。表示 Serenade 从学校回家时，在第 $x_1$ 条横向线路与第 $y_1$ 条纵向线路的交汇站上车，在第 $x_2$ 条横向线路与第 $y_2$ 条纵向线路的交汇站下车。", "outputFormat": "输出文件只有一行，即 Serenade 在合理选择线路的情况下，回家所需要的时间。如果 Serenade 无法在不出站换乘的情况下回家，请输出 `-1`。", "hint": "对于 $30\\%$ 的数据，$n\\le 50,m\\le 1000$；\n\n对于 $60\\%$ 的数据，$n\\le 500,m\\le 2000$；\n\n对于 $100\\%$ 的数据，$n\\le 20000,m\\le 100000$；", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2012] The Way Home", "background": "SHOI2012 D2T1.", "description": "In 2046, the urban rail transit construction of OI City was finally completed. Thanks to meticulous planning, the completed rail network consists of $2n$ subway lines, forming a grid with $n$ vertical and $n$ horizontal lines. As shown in the figure below, each of these $2n$ lines contains $n$ stations, and each station lies at the intersection of one vertical line and one horizontal line.\n\nFor cost reasons, not every station allows in-station transfers. There are $m$ stations where in-station transfer is possible; in the figure below, stations marked with squares are transfer stations. It is known that traveling one stop takes $2$ minutes, and an in-station transfer requires $1$ minute of walking. Serenade wants to know, without exiting the station mid-journey, the minimum time needed to get home from school (waiting time is ignored).\n\n![](https://cdn.luogu.com.cn/upload/pic/6547.png)", "inputFormat": "The first line contains two integers $n, m$.\n\nEach of the next $m$ lines contains two integers $x, y$, indicating that the intersection of the $x$-th horizontal line and the $y$-th vertical line is an in-station transfer station.\n\nThe next line contains four integers $x_1, y_1, x_2, y_2$. They mean that Serenade boards at the intersection of the $x_1$-th horizontal line and the $y_1$-th vertical line, and alights at the intersection of the $x_2$-th horizontal line and the $y_2$-th vertical line.", "outputFormat": "Output one line: the minimum time for Serenade to get home with an optimal choice of lines. If Serenade cannot get home without exiting the station to transfer, output `-1`.", "hint": "- For $30\\%$ of the testdata, $n \\le 50, m \\le 1000$.\n- For $60\\%$ of the testdata, $n \\le 500, m \\le 2000$.\n- For $100\\%$ of the testdata, $n \\le 20000, m \\le 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2012] 回家的路", "background": "SHOI2012 D2T1", "description": "2046 年 OI 城的城市轨道交通建设终于全部竣工，由于前期规划周密，建成后的轨道交通网络由 $2n$ 条地铁线路构成，组成了一个 $n$ 纵 $n$ 横的交通网。如下图所示，这 $2n$ 条线路每条线路都包含 $n$ 个车站，而每个车站都在一组纵横线路的交汇处。\n\n\n出于建设成本的考虑，并非每个车站都能够进行站内换乘，能够进行站内换乘的地铁站共有 $m$ 个，在下图中，标上方块标记的车站为换乘车站。已知地铁运行 $1$ 站需要 $2$ 分钟，而站内换乘需要步行 $1$ 分钟。Serenade 想要知道，在不中途出站的前提下，他从学校回家最快需要多少时间（等车时间忽略不计）。\n\n\n![](https://cdn.luogu.com.cn/upload/pic/6547.png)", "inputFormat": "第一行有两个整数 $n,m$。\n\n接下去 $m$ 行每行两个整数 $x,y$，表示第 $x$ 条横向线路与第 $y$ 条纵向线路的交汇站是站内换乘站。\n\n接下去一行是四个整数 $x_1,y_1,x_2,y_2$。表示 Serenade 从学校回家时，在第 $x_1$ 条横向线路与第 $y_1$ 条纵向线路的交汇站上车，在第 $x_2$ 条横向线路与第 $y_2$ 条纵向线路的交汇站下车。", "outputFormat": "输出文件只有一行，即 Serenade 在合理选择线路的情况下，回家所需要的时间。如果 Serenade 无法在不出站换乘的情况下回家，请输出 `-1`。", "hint": "对于 $30\\%$ 的数据，$n\\le 50,m\\le 1000$；\n\n对于 $60\\%$ 的数据，$n\\le 500,m\\le 2000$；\n\n对于 $100\\%$ 的数据，$n\\le 20000,m\\le 100000$；", "locale": "zh-CN"}}}
{"pid": "P3832", "type": "P", "difficulty": 0, "samples": [["3\n1 3 2", "1 2 3\n2 1 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "各省省选", "上海"], "title": "[SHOI2012] 排序", "background": "SHOI2012 D2T2\n", "description": "众所周知，1~n 的全排列包含 n!个排列。通常情况下，我们在生成全排列时都按照他们的字典序生成的。而在本题中，我们就将要考虑一种特殊的全排列生成方式。\n\n具体的，生成的全排列的顺序是由一个生成器决定的。\n\n(1) 生成器本身也是一个 1~n 的排列：$a_1$ , $a_2$ , …, $a_n$ 。\n\n(2) 对于两个不相同的 1~n 的 $x_1$ , $x_2$ , …, $x_n$ 、$y_1$ , $y_2$ , …, $y_n$ 排列而言，首先找到最小的 i，使得 $x_{ai}$ 与 $y_{ai}$ 不相等。\n\n(3) 根据(2)中选择的 i，如果 $x_{ai}$ 在排列 $a_1$ , $a_2$ , …, $a_n$ 中排在 $y_{ai}$ 之前，那么 $x_1$ ,$x_2$ , …, $x_n$ 就会在 $y_1$ , $y_2$ , …, $y_n$ 之前生成。\n\n例如，当 n = 3，生成器为 132 时，1~n 的全排列的生成顺序为：123，132，321，312，231，213。\n\n输入一个排列 $x_1$ , $x_2$, …, $x_n$ ，问，哪个生成器能使得这个排列在所有的排列中尽可能早的生成，哪个生成器能使得这个排列在所有的排列中尽可能晚的生成。\n\n如果有多种生成器能达到要求，那么请输出字典序最小的符合要求的生成器。\n", "inputFormat": "输入的第一行是整数 n，第二行是 1~n 的一个排列 $x_1$ , $x_2$ , …, $x_n$ 。\n", "outputFormat": "输出的第一行是一个 1~n 的排列，表示让 $x_1$ , $x_2$ , …, $x_n$ 尽早输出的生成器。\n\n输出的第二行是一个 1~n 的排列，表示让 $x_1$ , $x_2$ , …, $x_n$ 尽晚输出的生成器。\n\n如果有多种生成器能达到要求，那么请输出字典序最小的符合要求的生成器。\n", "hint": "对于 30%的数据，有 n ≤ 10；\n\n对于 50%的数据，有 n ≤ 200；\n\n对于 90%的数据，有 n ≤ 30000；\n\n对于 100%的数据，有 n ≤ 500000。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2012] Sorting", "background": "SHOI2012 D2T2.", "description": "As is well known, the set of all permutations of $\\{1, 2, \\dots, n\\}$ contains $n!$ permutations. Normally, when we generate all permutations, we list them in lexicographic order. In this problem, we consider a special way of generating all permutations.\n\nSpecifically, the generation order is determined by a generator.\n\n(1) The generator is itself a permutation of $\\{1, 2, \\dots, n\\}$: $a_1$, $a_2$, …, $a_n$.\n\n(2) For two distinct permutations of $\\{1, 2, \\dots, n\\}$, $x_1$, $x_2$, …, $x_n$ and $y_1$, $y_2$, …, $y_n$, first find the smallest $i$ such that $x_{a_i}$ and $y_{a_i}$ are not equal.\n\n(3) According to the $i$ chosen in (2), if $x_{a_i}$ comes before $y_{a_i}$ in the permutation $a_1$, $a_2$, …, $a_n$, then $x_1$, $x_2$, …, $x_n$ will be generated before $y_1$, $y_2$, …, $y_n$.\n\nFor example, when $n = 3$ and the generator is 132, the generation order of all permutations of $\\{1, 2, \\dots, n\\}$ is: 123, 132, 321, 312, 231, 213.\n\nGiven a permutation $x_1$, $x_2$, …, $x_n$, determine which generator makes this permutation appear as early as possible among all permutations, and which generator makes it appear as late as possible.\n\nIf multiple generators satisfy the requirement, output the lexicographically smallest one.", "inputFormat": "The first line contains an integer $n$. The second line contains a permutation $x_1$, $x_2$, …, $x_n$ of $\\{1, 2, \\dots, n\\}$.", "outputFormat": "The first line outputs a permutation of $\\{1, 2, \\dots, n\\}$, representing a generator that makes $x_1$, $x_2$, …, $x_n$ appear as early as possible.\n\nThe second line outputs a permutation of $\\{1, 2, \\dots, n\\}$, representing a generator that makes $x_1$, $x_2$, …, $x_n$ appear as late as possible.\n\nIf multiple generators satisfy the requirement, output the lexicographically smallest one.", "hint": "Constraints\n\n- For 30% of the testdata, $n \\le 10$.\n- For 50% of the testdata, $n \\le 200$.\n- For 90% of the testdata, $n \\le 30000$.\n- For 100% of the testdata, $n \\le 500000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2012] 排序", "background": "SHOI2012 D2T2\n", "description": "众所周知，1~n 的全排列包含 n!个排列。通常情况下，我们在生成全排列时都按照他们的字典序生成的。而在本题中，我们就将要考虑一种特殊的全排列生成方式。\n\n具体的，生成的全排列的顺序是由一个生成器决定的。\n\n(1) 生成器本身也是一个 1~n 的排列：$a_1$ , $a_2$ , …, $a_n$ 。\n\n(2) 对于两个不相同的 1~n 的 $x_1$ , $x_2$ , …, $x_n$ 、$y_1$ , $y_2$ , …, $y_n$ 排列而言，首先找到最小的 i，使得 $x_{ai}$ 与 $y_{ai}$ 不相等。\n\n(3) 根据(2)中选择的 i，如果 $x_{ai}$ 在排列 $a_1$ , $a_2$ , …, $a_n$ 中排在 $y_{ai}$ 之前，那么 $x_1$ ,$x_2$ , …, $x_n$ 就会在 $y_1$ , $y_2$ , …, $y_n$ 之前生成。\n\n例如，当 n = 3，生成器为 132 时，1~n 的全排列的生成顺序为：123，132，321，312，231，213。\n\n输入一个排列 $x_1$ , $x_2$, …, $x_n$ ，问，哪个生成器能使得这个排列在所有的排列中尽可能早的生成，哪个生成器能使得这个排列在所有的排列中尽可能晚的生成。\n\n如果有多种生成器能达到要求，那么请输出字典序最小的符合要求的生成器。\n", "inputFormat": "输入的第一行是整数 n，第二行是 1~n 的一个排列 $x_1$ , $x_2$ , …, $x_n$ 。\n", "outputFormat": "输出的第一行是一个 1~n 的排列，表示让 $x_1$ , $x_2$ , …, $x_n$ 尽早输出的生成器。\n\n输出的第二行是一个 1~n 的排列，表示让 $x_1$ , $x_2$ , …, $x_n$ 尽晚输出的生成器。\n\n如果有多种生成器能达到要求，那么请输出字典序最小的符合要求的生成器。\n", "hint": "对于 30%的数据，有 n ≤ 10；\n\n对于 50%的数据，有 n ≤ 200；\n\n对于 90%的数据，有 n ≤ 30000；\n\n对于 100%的数据，有 n ≤ 500000。\n", "locale": "zh-CN"}}}
{"pid": "P3833", "type": "P", "difficulty": 5, "samples": [["4\n0 1\n1 2\n2 3\n4\nA 1 3 1\nQ 0\nQ 1\nQ 2", "3\n3\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "线段树", "倍增", "各省省选", "上海", "最近公共祖先 LCA", "树链剖分"], "title": "[SHOI2012] 魔法树", "background": "SHOI2012 D2T3\n", "description": "Harry Potter 新学了一种魔法：可以改变树上的果子个数。满心欢喜的他找到了一个巨大的果树，来试验他的新法术。\n\n这棵果树共有 $N$ 个节点，其中节点 $0$ 是根节点，每个节点 $u$ 的父亲记为 $fa[u]$，保证有 $fa[u] < u$ 。初始时，这棵果树上的果子都被 Dumbledore 用魔法清除掉了，所以这个果树的每个节点上都没有果子（即 $0$ 个果子）。\n\n不幸的是，Harry 的法术学得不到位，只能对树上一段路径的节点上的果子个数统一增加一定的数量。也就是说，Harry 的魔法可以这样描述：`A u v d` 。表示将点 $u$ 和 $v$ 之间的路径上的所有节点的果子个数都加上 $d$。\n\n接下来，为了方便检验 Harry 的魔法是否成功，你需要告诉他在释放魔法的过程中的一些有关果树的信息：`Q u`。表示当前果树中，以点 $u$ 为根的子树中，总共有多少个果子？\n", "inputFormat": "第一行一个正整数 $N (1 \\leq N \\leq 100000)$，表示果树的节点总数，节点以 $0,1,\\dots,N - 1$ 标号，$0$ 一定代表根节点。\n\n接下来 $N - 1$ 行，每行两个整数 $a,b (0 \\leq a < b < N)$，表示 $a$ 是 $b$ 的父亲。\n\n接下来是一个正整数 $Q(1 \\leq Q \\leq 100000)$，表示共有 $Q$ 次操作。\n\n后面跟着 $Q$ 行，每行是以下两种中的一种：\n\n1. `A u v d`，表示将 $u$ 到 $v$ 的路径上的所有节点的果子数加上 $d$。保证 $0 \\leq u,v < N,0 < d < 100000$\n\n2. `Q u`，表示询问以 $u$ 为根的子树中的总果子数，注意是包括 $u$ 本身的。\n", "outputFormat": "对于所有的 `Q` 操作，依次输出询问的答案，每行一个。答案可能会超过 $2^{32}$ ，但不会超过 $10^{15}$ 。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2012] Magic Tree", "background": "SHOI2012 D2T3.", "description": "Harry Potter has learned a new kind of magic: he can change the number of fruits on a tree. Overjoyed, he found a huge fruit tree to test his new spell.\n\nThis fruit tree has $N$ nodes. Node $0$ is the root, and the parent of each node $u$ is denoted by $fa[u]$, with the guarantee that $fa[u] < u$. Initially, all the fruits on this tree were removed by Dumbledore’s magic, so every node on this fruit tree has no fruits (that is, $0$ fruits).\n\nUnfortunately, Harry’s magic is not yet perfect; he can only uniformly increase the number of fruits on all nodes along a path in the tree by a fixed amount. In other words, Harry’s magic can be described as: `A u v d`. This means adding $d$ to the number of fruits on every node on the path between nodes $u$ and $v$.\n\nNext, to help check whether Harry’s magic is working, you need to tell him some information about the fruit tree during the process: `Q u`. This asks for the total number of fruits currently in the subtree rooted at node $u$.", "inputFormat": "The first line contains a positive integer $N$ $(1 \\leq N \\leq 100000)$, the total number of nodes in the fruit tree. Nodes are labeled $0, 1, \\dots, N - 1$, and $0$ is the root.\n\nThe next $N - 1$ lines each contain two integers $a, b$ $(0 \\leq a < b < N)$, indicating that $a$ is the parent of $b$.\n\nThen follows a positive integer $Q$ $(1 \\leq Q \\leq 100000)$, the number of operations.\n\nThen there are $Q$ lines, each being one of the following two types:\n1. `A u v d`: Add $d$ to the number of fruits on every node along the path from $u$ to $v$. It is guaranteed that $0 \\leq u, v < N$, $0 < d < 100000$.\n2. `Q u`: Query the total number of fruits in the subtree rooted at $u$, including $u$ itself.", "outputFormat": "For every `Q` operation, output the answer in order, one per line. The answer may exceed $2^{32}$, but will not exceed $10^{15}$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2012] 魔法树", "background": "SHOI2012 D2T3\n", "description": "Harry Potter 新学了一种魔法：可以改变树上的果子个数。满心欢喜的他找到了一个巨大的果树，来试验他的新法术。\n\n这棵果树共有 $N$ 个节点，其中节点 $0$ 是根节点，每个节点 $u$ 的父亲记为 $fa[u]$，保证有 $fa[u] < u$ 。初始时，这棵果树上的果子都被 Dumbledore 用魔法清除掉了，所以这个果树的每个节点上都没有果子（即 $0$ 个果子）。\n\n不幸的是，Harry 的法术学得不到位，只能对树上一段路径的节点上的果子个数统一增加一定的数量。也就是说，Harry 的魔法可以这样描述：`A u v d` 。表示将点 $u$ 和 $v$ 之间的路径上的所有节点的果子个数都加上 $d$。\n\n接下来，为了方便检验 Harry 的魔法是否成功，你需要告诉他在释放魔法的过程中的一些有关果树的信息：`Q u`。表示当前果树中，以点 $u$ 为根的子树中，总共有多少个果子？\n", "inputFormat": "第一行一个正整数 $N (1 \\leq N \\leq 100000)$，表示果树的节点总数，节点以 $0,1,\\dots,N - 1$ 标号，$0$ 一定代表根节点。\n\n接下来 $N - 1$ 行，每行两个整数 $a,b (0 \\leq a < b < N)$，表示 $a$ 是 $b$ 的父亲。\n\n接下来是一个正整数 $Q(1 \\leq Q \\leq 100000)$，表示共有 $Q$ 次操作。\n\n后面跟着 $Q$ 行，每行是以下两种中的一种：\n\n1. `A u v d`，表示将 $u$ 到 $v$ 的路径上的所有节点的果子数加上 $d$。保证 $0 \\leq u,v < N,0 < d < 100000$\n\n2. `Q u`，表示询问以 $u$ 为根的子树中的总果子数，注意是包括 $u$ 本身的。\n", "outputFormat": "对于所有的 `Q` 操作，依次输出询问的答案，每行一个。答案可能会超过 $2^{32}$ ，但不会超过 $10^{15}$ 。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3834", "type": "P", "difficulty": 5, "samples": [["5 5\n25957 6405 15770 26287 26465 \n2 2 1\n3 4 1\n4 5 1\n1 2 2\n4 4 1\n", "6405\n15770\n26287\n25957\n26287\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["莫队", "线段树", "离散化", "O2优化", "可持久化线段树", "可持久化", "分块", "整体二分", "模板题"], "title": "【模板】可持久化线段树 2", "background": "这是个非常经典的可持久化权值线段树入门题——静态区间第 $k$ 小。", "description": "如题，给定 $n$ 个整数构成的序列 $a$，将对于指定的闭区间 $[l, r]$ 查询其区间内的第 $k$ 小值。\n", "inputFormat": "第一行包含两个整数，分别表示序列的长度 $n$ 和查询的个数 $m$。  \n第二行包含 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个元素 $a_i$。   \n接下来 $m$ 行每行包含三个整数 $ l, r, k$ , 表示查询区间 $[l, r]$ 内的第 $k$ 小值。\n", "outputFormat": "对于每次询问，输出一行一个整数表示答案。", "hint": "### 样例 1 解释\n\n$n=5$，数列长度为 $5$，数列从第一项开始依次为 $\\{25957, 6405, 15770, 26287, 26465\\}$。\n\n- 第一次查询为 $[2, 2]$ 区间内的第一小值，即为 $6405$。\n- 第二次查询为 $[3, 4]$ 区间内的第一小值，即为 $15770$。\n- 第三次查询为 $[4, 5]$ 区间内的第一小值，即为 $26287$。\n- 第四次查询为 $[1, 2]$ 区间内的第二小值，即为 $25957$。\n- 第五次查询为 $[4, 4]$ 区间内的第一小值，即为 $26287$。\n\n\n### 数据规模与约定\n\n- 对于 $10\\%$ 的数据，满足 $1 \\leq n,m \\leq 10$。\n- 对于 $25\\%$ 的数据，满足 $1 \\leq n,m \\leq 10^3$。\n- 对于 $40\\%$ 的数据，满足 $1 \\leq n,m \\leq 10^5$。\n- 对于 $50\\%$ 的数据，满足 $1 \\leq n,m \\leq 2\\times 10^5$，$0\\le a_i \\leq 2\\times 10^5$。\n- 对于所有数据，满足 $1 \\leq n,m \\leq 2\\times 10^5$，$0\\le a_i \\leq 10^9$，$1 \\leq l \\leq r \\leq n$，$1 \\leq k \\leq r - l + 1$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Persistent Segment Tree 2", "background": "This is a very classic introductory problem on the persistent value segment tree (权值线段树) — the static range $ k $-th smallest query.", "description": "As stated, given a sequence $ a $ of $ n $ integers, for each specified closed interval $ [l, r] $, query the $ k $-th smallest value within the interval.", "inputFormat": "The first line contains two integers, the length $ n $ of the sequence and the number $ m $ of queries.  \nThe second line contains $ n $ integers; the $ i $-th integer is the $ i $-th element $ a_i $ of the sequence.  \nEach of the next $ m $ lines contains three integers $ l, r, k $, denoting the $ k $-th smallest value within the range $ [l, r] $.", "outputFormat": "For each query, output one line with a single integer, the answer.", "hint": "### Sample 1 Explanation\n\n$n=5$, the sequence length is $5$, and the sequence from the first term is $\\{25957, 6405, 15770, 26287, 26465\\}$.\n\n- The first query asks for the first smallest value in $[2, 2]$, which is $6405$.\n- The second query asks for the first smallest value in $[3, 4]$, which is $15770$.\n- The third query asks for the first smallest value in $[4, 5]$, which is $26287$.\n- The fourth query asks for the second smallest value in $[1, 2]$, which is $25957$.\n- The fifth query asks for the first smallest value in $[4, 4]$, which is $26287$.\n\n### Constraints\n\n- For $10\\%$ of the testdata, $1 \\leq n,m \\leq 10$.\n- For $25\\%$ of the testdata, $1 \\leq n,m \\leq 10^3$.\n- For $40\\%$ of the testdata, $1 \\leq n,m \\leq 10^5$.\n- For $50\\%$ of the testdata, $1 \\leq n,m \\leq 2\\times 10^5$, $0\\le a_i \\leq 2\\times 10^5$.\n- For all testdata, $1 \\leq n,m \\leq 2\\times 10^5$, $0\\le a_i \\leq 10^9$, $1 \\leq l \\leq r \\leq n$, $1 \\leq k \\leq r - l + 1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】可持久化线段树 2", "background": "这是个非常经典的可持久化权值线段树入门题——静态区间第 $k$ 小。", "description": "如题，给定 $n$ 个整数构成的序列 $a$，将对于指定的闭区间 $[l, r]$ 查询其区间内的第 $k$ 小值。\n", "inputFormat": "第一行包含两个整数，分别表示序列的长度 $n$ 和查询的个数 $m$。  \n第二行包含 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个元素 $a_i$。   \n接下来 $m$ 行每行包含三个整数 $ l, r, k$ , 表示查询区间 $[l, r]$ 内的第 $k$ 小值。\n", "outputFormat": "对于每次询问，输出一行一个整数表示答案。", "hint": "### 样例 1 解释\n\n$n=5$，数列长度为 $5$，数列从第一项开始依次为 $\\{25957, 6405, 15770, 26287, 26465\\}$。\n\n- 第一次查询为 $[2, 2]$ 区间内的第一小值，即为 $6405$。\n- 第二次查询为 $[3, 4]$ 区间内的第一小值，即为 $15770$。\n- 第三次查询为 $[4, 5]$ 区间内的第一小值，即为 $26287$。\n- 第四次查询为 $[1, 2]$ 区间内的第二小值，即为 $25957$。\n- 第五次查询为 $[4, 4]$ 区间内的第一小值，即为 $26287$。\n\n\n### 数据规模与约定\n\n- 对于 $10\\%$ 的数据，满足 $1 \\leq n,m \\leq 10$。\n- 对于 $25\\%$ 的数据，满足 $1 \\leq n,m \\leq 10^3$。\n- 对于 $40\\%$ 的数据，满足 $1 \\leq n,m \\leq 10^5$。\n- 对于 $50\\%$ 的数据，满足 $1 \\leq n,m \\leq 2\\times 10^5$，$0\\le a_i \\leq 2\\times 10^5$。\n- 对于所有数据，满足 $1 \\leq n,m \\leq 2\\times 10^5$，$0\\le a_i \\leq 10^9$，$1 \\leq l \\leq r \\leq n$，$1 \\leq k \\leq r - l + 1$。", "locale": "zh-CN"}}}
{"pid": "P3835", "type": "P", "difficulty": 6, "samples": [["10\n0 1 9\n1 1 3\n1 1 10\n2 4 2\n3 3 9\n3 1 2\n6 4 1\n6 2 9\n8 6 3\n4 5 8", "9\n1\n2\n10\n3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864, 1572864]}, "tags": ["线段树", "平衡树", "深度优先搜索 DFS", "可持久化", "模板题"], "title": "【模板】可持久化平衡树", "background": "本题为题目 **普通平衡树** 的可持久化加强版。\n\n**数据已经经过强化**\n\n**感谢@Kelin 提供的一组hack数据**\n", "description": "您需要写一种数据结构（可参考题目标题），来维护一个可重整数集合，其中需要提供以下操作（ **对于各个以往的历史版本** ）：\n\n\n1、 插入 $x$\n\n2、 删除 $x$（若有多个相同的数，应只删除一个，**如果没有请忽略该操作**）\n\n\n3、 查询 $x$ 的排名（排名定义为比当前数小的数的个数 $+1$）\n\n\n4、查询排名为 $x$ 的数\n\n\n5、 求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数，**如不存在输出** $-2^{31}+1$ ）\n\n\n6、求 $x$ 的后继（后继定义为大于 $x$，且最小的数，**如不存在输出** $2^{31}-1$ ）\n\n\n**和原本平衡树不同的一点是，每一次的任何操作都是基于某一个历史版本，同时生成一个新的版本。（操作3, 4, 5, 6即保持原版本无变化）**\n\n每个版本的编号即为操作的序号（版本0即为初始状态，空树）\n", "inputFormat": "第一行包含一个正整数 $n$ ，表示操作的总数。\n\n接下来 $n$ 行，每行包含三个整数，第 $i$ 行记为 $v_i, \\text{opt}_i, x_i$。\n\n$v_i$ 表示基于的过去版本号，$\\text{opt}_i$ 表示操作的序号， $x_i$ 表示参与操作的数值\n", "outputFormat": "每行包含一个整数，依次为各个 $3,4,5,6$ 操作所对应的答案\n", "hint": "【数据范围】   \n对于 $28\\%$ 的数据，$ 1 \\leq n \\leq 10 $；   \n对于 $44\\%$ 的数据，$ 1 \\leq n \\leq 2\\times {10}^2 $；   \n对于 $60\\%$ 的数据， $ 1 \\leq n \\leq 3\\times {10}^3 $；   \n对于 $84\\%$ 的数据， $ 1 \\leq n \\leq {10}^5 $；   \n对于 $92\\%$ 的数据， $ 1 \\leq n \\leq 2\\times {10}^5 $；   \n对于 $100\\%$ 的数据， $ 1 \\leq n \\leq 5 \\times  10^5 $ , $|x_i| \\leq {10}^9$，$0 \\le v_i < i$，$1\\le \\text{opt} \\le 6$。\n\n**经实测，正常常数的可持久化平衡树均可通过，请各位放心**\n\n\n\n样例说明：\n\n共 $10$ 次操作，$11$ 个版本，各版本的状况依次是：\n\n0.  $[]$\n\n1.  $[9]$\n\n2.  $[3, 9]$\n\n3.  $[9, 10]$\n\n4.  $[3, 9]$\n\n5.  $[9, 10]$\n\n6.  $[2, 9, 10]$\n\n7.  $[2, 9, 10]$\n\n8.  $[2, 10]$\n\n9.  $[2, 10]$\n\n10.  $[3, 9]$\n", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Persistent Balanced Tree", "background": "This problem is a persistent enhanced version of the problem Ordinary Balanced Tree.\n\nThe testdata has been strengthened.\n\nThanks to @Kelin for providing a set of hack testdata.", "description": "You need to implement a data structure (refer to the problem title) to maintain a multiset of integers, and support the following operations for each historical version:\n\n1. Insert $x$.\n\n2. Delete $x$ (if there are multiple equal numbers, delete only one; if none exists, ignore this operation).\n\n3. Query the rank of $x$ (rank is defined as the number of elements strictly less than $x$, plus $1$).\n\n4. Query the number whose rank is $x$.\n\n5. Query the predecessor of $x$ (the predecessor is defined as the largest number strictly less than $x$; if it does not exist, output $-2^{31}+1$).\n\n6. Query the successor of $x$ (the successor is defined as the smallest number strictly greater than $x$; if it does not exist, output $2^{31}-1$).\n\nUnlike the original balanced tree, every operation here is based on some historical version and produces a new version. (Operations 3, 4, 5, 6 do not modify the original version.)\n\nEach version is numbered by the operation index (version $0$ is the initial state, an empty tree).", "inputFormat": "The first line contains a positive integer $n$, the total number of operations.\n\nThe next $n$ lines each contain three integers. On the $i$-th line, they are $v_i, \\text{opt}_i, x_i$.\n\n$v_i$ is the index of the past version to base on, $\\text{opt}_i$ is the operation type, and $x_i$ is the value involved in the operation.", "outputFormat": "Each line contains one integer, in order, corresponding to the answers for operations $3, 4, 5, 6$.", "hint": "Constraints  \nFor $28\\%$ of the testdata, $1 \\leq n \\leq 10$.  \nFor $44\\%$ of the testdata, $1 \\leq n \\leq 2 \\times 10^2$.  \nFor $60\\%$ of the testdata, $1 \\leq n \\leq 3 \\times 10^3$.  \nFor $84\\%$ of the testdata, $1 \\leq n \\leq 10^5$.  \nFor $92\\%$ of the testdata, $1 \\leq n \\leq 2 \\times 10^5$.  \nFor $100\\%$ of the testdata, $1 \\leq n \\leq 5 \\times 10^5$, $|x_i| \\leq 10^9$, $0 \\le v_i < i$, $1 \\le \\text{opt} \\le 6$.\n\nEmpirically, persistent balanced trees with normal constant factors can pass. Please rest assured.\n\nSample explanation:\n\nThere are $10$ operations and $11$ versions. The states of each version are:\n\n0. $[]$  \n1. $[9]$  \n2. $[3, 9]$  \n3. $[9, 10]$  \n4. $[3, 9]$  \n5. $[9, 10]$  \n6. $[2, 9, 10]$  \n7. $[2, 9, 10]$  \n8. $[2, 10]$  \n9. $[2, 10]$  \n10. $[3, 9]$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】可持久化平衡树", "background": "本题为题目 **普通平衡树** 的可持久化加强版。\n\n**数据已经经过强化**\n\n**感谢@Kelin 提供的一组hack数据**\n", "description": "您需要写一种数据结构（可参考题目标题），来维护一个可重整数集合，其中需要提供以下操作（ **对于各个以往的历史版本** ）：\n\n\n1、 插入 $x$\n\n2、 删除 $x$（若有多个相同的数，应只删除一个，**如果没有请忽略该操作**）\n\n\n3、 查询 $x$ 的排名（排名定义为比当前数小的数的个数 $+1$）\n\n\n4、查询排名为 $x$ 的数\n\n\n5、 求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数，**如不存在输出** $-2^{31}+1$ ）\n\n\n6、求 $x$ 的后继（后继定义为大于 $x$，且最小的数，**如不存在输出** $2^{31}-1$ ）\n\n\n**和原本平衡树不同的一点是，每一次的任何操作都是基于某一个历史版本，同时生成一个新的版本。（操作3, 4, 5, 6即保持原版本无变化）**\n\n每个版本的编号即为操作的序号（版本0即为初始状态，空树）\n", "inputFormat": "第一行包含一个正整数 $n$ ，表示操作的总数。\n\n接下来 $n$ 行，每行包含三个整数，第 $i$ 行记为 $v_i, \\text{opt}_i, x_i$。\n\n$v_i$ 表示基于的过去版本号，$\\text{opt}_i$ 表示操作的序号， $x_i$ 表示参与操作的数值\n", "outputFormat": "每行包含一个整数，依次为各个 $3,4,5,6$ 操作所对应的答案\n", "hint": "【数据范围】   \n对于 $28\\%$ 的数据，$ 1 \\leq n \\leq 10 $；   \n对于 $44\\%$ 的数据，$ 1 \\leq n \\leq 2\\times {10}^2 $；   \n对于 $60\\%$ 的数据， $ 1 \\leq n \\leq 3\\times {10}^3 $；   \n对于 $84\\%$ 的数据， $ 1 \\leq n \\leq {10}^5 $；   \n对于 $92\\%$ 的数据， $ 1 \\leq n \\leq 2\\times {10}^5 $；   \n对于 $100\\%$ 的数据， $ 1 \\leq n \\leq 5 \\times  10^5 $ , $|x_i| \\leq {10}^9$，$0 \\le v_i < i$，$1\\le \\text{opt} \\le 6$。\n\n**经实测，正常常数的可持久化平衡树均可通过，请各位放心**\n\n\n\n样例说明：\n\n共 $10$ 次操作，$11$ 个版本，各版本的状况依次是：\n\n0.  $[]$\n\n1.  $[9]$\n\n2.  $[3, 9]$\n\n3.  $[9, 10]$\n\n4.  $[3, 9]$\n\n5.  $[9, 10]$\n\n6.  $[2, 9, 10]$\n\n7.  $[2, 9, 10]$\n\n8.  $[2, 10]$\n\n9.  $[2, 10]$\n\n10.  $[3, 9]$\n", "locale": "zh-CN"}}}
{"pid": "P3836", "type": "P", "difficulty": 7, "samples": [["4 5 5\n....#\n.#..#\n...#.\n....#", ".X.X#\n.#..#\n...#X\nXX..#\n\n//这是其中一个有效的输出\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "贪心", "2017", "IOI", "提交答案", "Special Judge", "深度优先搜索 DFS"], "title": "[IOI 2017] Nowruz", "background": "**[数据以及 checker ](http://pan.baidu.com/s/1o8jwPmy)【已搬运至附件】**", "description": "再过几天就是诺鲁孜节了（波斯人的新年），爷爷邀请他的全家人到他的花园来聚会。在众多的宾客中有 $k$ 个小孩。为了让这些孩子们在聚会中更开心，爷爷打算让他们玩一个捉迷藏的游戏。\n\n整个花园可以看成一个有 $m\\times n$ 个方格的网格。其中有一些（或许没有）方格被岩石堵住了，而剩下的方格就称为**空格**。如果两个格子共享同一条边，我们就称这两个格子是**邻居**。因此，每一个方格最多有 $4$ 个邻居：两个水平方向的和两个垂直方向的。爷爷想把花园变成一个迷宫。为达此目的，他会在花园中的一些**空格**上种植灌木来堵住他们。而这些被灌木丛堵住的方格就不再是**空格**了。\n\n一个迷宫必须具有下面所述的性质。在迷宫中的任意一对空格 $a$ 和 $b$ 之间都只会恰有唯一的一条简单路径相连。而这条由 $a$ 到 $b$ 的简单路径就是一个从空格 $a$ 开始并以空格 $b$ 结束的序列，序列中所有的方格必须是不同的，而且每个相连的方格都是邻居。\n\n一个小孩能够躲藏的方格当且仅当这个方格是**空格**，而且它恰有唯一一个邻居是空格。同一个空格内只能躲藏一个小孩。\n\n题目会给出整个花园的地图作为输入文件。你的任务就是帮助爷爷构造一个能够躲藏尽量多小孩的迷宫。\n\n\n## 评分\n\n一个**有效**的输出文件必须符合下列所有的条件：\n\n- 除了把输入文件中的任意多个字母 `.` 修改成字母 `X`（即被灌木堵塞）外，输出的地图必须和输入地图完全一样。\n\n- 输出的地图必须符合在上文中提及的迷宫的所有性质。\n\n\n对于某一个测试数据，如果你的输出不是**有效**的，你的这个测试数据的得分将会是 $0$。反之，你的得分是 $\\min(10, 10\\cdot l/k)$，向下取值至小数后二位，这里的 $l$ 是指你输出的迷宫中能够最多藏着的小孩，而 $k$ 则表示在输入文件中题目要求你躲藏的小孩数目。对于一个测试数据，你能够得到 $10$ 分，当且仅当你的输入是一个能够躲藏 $k$ 个或更多个小孩的迷宫。\n\n对于每组测试数据都存在一个能得到 $10$ 分的答案。\n\n请注意如果你答案是有效的，但根据上述公式你的得分仍然是 $0$ 分，则在评分系统中，现实的结果将会是 'Wrong Answer'。", "inputFormat": "这是一个提交答案型的题目，而且它有部份分。题目会给出 $10$ 个描述爷爷花园的输入文件。对于每个输入文件你应该提交一个含有迷宫的地图作为输出文件我们会根据你提交的每个输入文件中的迷宫能够躲藏的小孩数目来给出你的分数。\n\n这道题目你不需要提交任何源代码。\n\n每个输入文件都描述了一个表示整个花园的网格，我们也会给出爷爷邀请的小孩数目 $k$。格式如下：\n\n第 $1$ 行：$m \\ n \\ k$。\n\n第 $1+i\\ (1 \\leqslant i \\leqslant m)$ 行：网格中的第 $i$ 行，它是一个长度为 $n$ 的字符串，包含以下的字符（中间没有空格）：\n\n- `.`： 一个空格，\n\n- `#`： 一块岩石。", "outputFormat": "第 $i\\ (1 \\leqslant i \\leqslant m)$ 行：迷宫中的第 $i$ 行（种植了树木的花园）。它是一个长度为 $n$ 的字符串，包含以下字母（中间没有空格）：\n\n\\* `.` ： 一个空格，\n\n\\* `#`： 一块岩石，\n\n\\* `X`： 一个灌木（注意字母X必须为大写字母）。", "hint": "样例输出是其中一个有效的输出。\n\n对于这个输出，因为 $l=4$ 个小孩能够这个迷宫中，所以这个解答能够得到 $10 \\cdot 4 / 5 = 8$ 分。小孩能够躲藏的方格如下以 `O` 所示：\n\n```plain\nOXOX#\n.#.O#\n...#X\nXX.O#\n```\n以下的三个输出都不是有效的输出：\n\n```plain\n.XXX#    ...X#    XXXX#\n.#XX#    .#.X#    X#XX#\n...#.    ...#X    ..X#X\nXX..#    XXXX#    ..XX#\n```\n在最左边的输出中，左上角的空格和最右列（位于右下方）的空格之间并没有一条简单路径。\n\n在其他的两个输出中，对于任意两个空格之间都恰有两条简单路径相连。\n\n\n## 限制条件\n\n$1 \\leqslant m,n \\leqslant 1024$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2017] Nowruz", "background": "[Data and checker](http://pan.baidu.com/s/1o8jwPmy) [moved to attachments].", "description": "Nowruz (the Persian New Year) is in a few days. Grandfather has invited his whole family to gather in his garden. Among the many guests, there are $k$ children. To make the party more fun for them, Grandfather plans to let them play hide-and-seek.\n\nThe entire garden can be seen as an $m \\times n$ grid of cells. Some cells (possibly none) are blocked by rocks; the remaining cells are called empty cells. If two cells share a side, they are called neighbors. Therefore, each cell has at most $4$ neighbors: two horizontal and two vertical. Grandfather wants to turn the garden into a maze. To do this, he will plant bushes on some empty cells to block them; those cells then cease to be empty.\n\nA maze must satisfy the following property: for any pair of empty cells $a$ and $b$, there is exactly one simple path between them. A simple path from $a$ to $b$ is a sequence of distinct cells starting at empty cell $a$ and ending at empty cell $b$, where every two consecutive cells are neighbors.\n\nA child can hide in a cell if and only if the cell is empty and it has exactly one empty neighbor. At most one child can hide in a single empty cell.\n\nYou are given a map of the entire garden. Your task is to help Grandfather construct a maze that allows as many children as possible to hide.\n\n# Scoring\n\nA valid output file must satisfy all of the following:\n\n- Apart from changing any number of `.` characters in the input to `X` (i.e., planting bushes), the output map must be identical to the input map.\n- The output map must satisfy all the maze properties stated above.\n\nFor a given testdata, if your output is not valid, your score for this testdata is $0$. Otherwise, your score is $\\min(10, 10 \\cdot l / k)$, rounded down to two decimal places, where $l$ is the maximum number of children that can hide in your output maze, and $k$ is the number of children specified in the input file. You receive $10$ points for a testdata if and only if your output maze can hide at least $k$ children.\n\nFor every testdata there exists a solution worth $10$ points.\n\nNote: If your output is valid but the above formula still yields a score of $0$, the judging system will display “Wrong Answer”.", "inputFormat": "This is an output-only problem with partial scoring. There are $10$ input files describing Grandfather’s garden. For each input file, you should submit an output file containing a maze map. Your score is based on the number of children that can hide in the maze you submit for each input file.\n\nYou do not need to submit any source code.\n\nEach input file describes the garden grid and gives the number of invited children $k$, in the following format:\n\nLine $1$: $m \\ n \\ k$.\n\nLine $1 + i$ ($1 \\leqslant i \\leqslant m$): the $i$-th row of the grid, a string of length $n$ with no spaces, consisting of:\n- `.`: an empty cell,\n- `#`: a rock.", "outputFormat": "Line $i$ ($1 \\leqslant i \\leqslant m$): the $i$-th row of the maze (the garden after planting bushes). It is a string of length $n$ with no spaces, consisting of:\n- `.`: an empty cell,\n- `#`: a rock,\n- `X`: a bush (note that the letter X must be uppercase).", "hint": "The sample output is one valid output.\n\nFor this output, since $l = 4$ children can hide in the maze, the score is $10 \\cdot 4 / 5 = 8$. The cells where children can hide are marked with `O` below:\n\n```plain\nOXOX#\n.#.O#\n...#X\nXX.O#\n```\n\nThe following three outputs are invalid:\n\n```plain\n.XXX#    ...X#    XXXX#\n.#XX#    .#.X#    X#XX#\n...#.    ...#X    ..X#X\nXX..#    XXXX#    ..XX#\n```\n\nIn the leftmost output, there is no simple path between the empty cell in the top-left corner and the empty cell in the rightmost column near the bottom-right.\n\nIn each of the other two outputs, there are two simple paths between some pair of empty cells.\n\n# Constraints\n\n$1 \\leqslant m, n \\leqslant 1024$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2017] Nowruz", "background": "**[数据以及 checker ](http://pan.baidu.com/s/1o8jwPmy)【已搬运至附件】**", "description": "再过几天就是诺鲁孜节了（波斯人的新年），爷爷邀请他的全家人到他的花园来聚会。在众多的宾客中有 $k$ 个小孩。为了让这些孩子们在聚会中更开心，爷爷打算让他们玩一个捉迷藏的游戏。\n\n整个花园可以看成一个有 $m\\times n$ 个方格的网格。其中有一些（或许没有）方格被岩石堵住了，而剩下的方格就称为**空格**。如果两个格子共享同一条边，我们就称这两个格子是**邻居**。因此，每一个方格最多有 $4$ 个邻居：两个水平方向的和两个垂直方向的。爷爷想把花园变成一个迷宫。为达此目的，他会在花园中的一些**空格**上种植灌木来堵住他们。而这些被灌木丛堵住的方格就不再是**空格**了。\n\n一个迷宫必须具有下面所述的性质。在迷宫中的任意一对空格 $a$ 和 $b$ 之间都只会恰有唯一的一条简单路径相连。而这条由 $a$ 到 $b$ 的简单路径就是一个从空格 $a$ 开始并以空格 $b$ 结束的序列，序列中所有的方格必须是不同的，而且每个相连的方格都是邻居。\n\n一个小孩能够躲藏的方格当且仅当这个方格是**空格**，而且它恰有唯一一个邻居是空格。同一个空格内只能躲藏一个小孩。\n\n题目会给出整个花园的地图作为输入文件。你的任务就是帮助爷爷构造一个能够躲藏尽量多小孩的迷宫。\n\n\n## 评分\n\n一个**有效**的输出文件必须符合下列所有的条件：\n\n- 除了把输入文件中的任意多个字母 `.` 修改成字母 `X`（即被灌木堵塞）外，输出的地图必须和输入地图完全一样。\n\n- 输出的地图必须符合在上文中提及的迷宫的所有性质。\n\n\n对于某一个测试数据，如果你的输出不是**有效**的，你的这个测试数据的得分将会是 $0$。反之，你的得分是 $\\min(10, 10\\cdot l/k)$，向下取值至小数后二位，这里的 $l$ 是指你输出的迷宫中能够最多藏着的小孩，而 $k$ 则表示在输入文件中题目要求你躲藏的小孩数目。对于一个测试数据，你能够得到 $10$ 分，当且仅当你的输入是一个能够躲藏 $k$ 个或更多个小孩的迷宫。\n\n对于每组测试数据都存在一个能得到 $10$ 分的答案。\n\n请注意如果你答案是有效的，但根据上述公式你的得分仍然是 $0$ 分，则在评分系统中，现实的结果将会是 'Wrong Answer'。", "inputFormat": "这是一个提交答案型的题目，而且它有部份分。题目会给出 $10$ 个描述爷爷花园的输入文件。对于每个输入文件你应该提交一个含有迷宫的地图作为输出文件我们会根据你提交的每个输入文件中的迷宫能够躲藏的小孩数目来给出你的分数。\n\n这道题目你不需要提交任何源代码。\n\n每个输入文件都描述了一个表示整个花园的网格，我们也会给出爷爷邀请的小孩数目 $k$。格式如下：\n\n第 $1$ 行：$m \\ n \\ k$。\n\n第 $1+i\\ (1 \\leqslant i \\leqslant m)$ 行：网格中的第 $i$ 行，它是一个长度为 $n$ 的字符串，包含以下的字符（中间没有空格）：\n\n- `.`： 一个空格，\n\n- `#`： 一块岩石。", "outputFormat": "第 $i\\ (1 \\leqslant i \\leqslant m)$ 行：迷宫中的第 $i$ 行（种植了树木的花园）。它是一个长度为 $n$ 的字符串，包含以下字母（中间没有空格）：\n\n\\* `.` ： 一个空格，\n\n\\* `#`： 一块岩石，\n\n\\* `X`： 一个灌木（注意字母X必须为大写字母）。", "hint": "样例输出是其中一个有效的输出。\n\n对于这个输出，因为 $l=4$ 个小孩能够这个迷宫中，所以这个解答能够得到 $10 \\cdot 4 / 5 = 8$ 分。小孩能够躲藏的方格如下以 `O` 所示：\n\n```plain\nOXOX#\n.#.O#\n...#X\nXX.O#\n```\n以下的三个输出都不是有效的输出：\n\n```plain\n.XXX#    ...X#    XXXX#\n.#XX#    .#.X#    X#XX#\n...#.    ...#X    ..X#X\nXX..#    XXXX#    ..XX#\n```\n在最左边的输出中，左上角的空格和最右列（位于右下方）的空格之间并没有一条简单路径。\n\n在其他的两个输出中，对于任意两个空格之间都恰有两条简单路径相连。\n\n\n## 限制条件\n\n$1 \\leqslant m,n \\leqslant 1024$。", "locale": "zh-CN"}}}
{"pid": "P3837", "type": "P", "difficulty": 6, "samples": [["r = [1, 2, 3, 7]\nb = [0, 4, 5, 9, 10]", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "贪心", "2017", "IOI", "交互题", "模拟费用流"], "title": "[IOI 2017] Wiring", "background": "这是一道交互题。\n\n本题仅支持 C++ 系列语言，提交时不需要包含 `wiring.h` 头文件，但需要在程序开头包含 `vector` 头文件以及声明函数 `long long min_total_length(std::vector<int> r, std::vector<int> b)`。\n\n**由于不可名状的 BUG，使用 C++14 (GCC9) 提交会导致 CE，请不要使用其提交。**", "description": "Maryam 是一位电机工程师。她正在为一座通讯塔设计接线方案。在这个塔上有一些分布在不同高度的连接点。一条电线可以用来将任何两个连接点连接起来。每一个连接点都可以接上任意数目的电线。而连接点共有两种：分别为红色连接点及蓝色连接点。\n\n为了表述方便起见，通讯塔会被视为一条直线，而那些红色及蓝色连接点会被视为在这条直线上的一些非负整数坐标。一条电线的长度是该电线所连接的两个连接点间的距离。\n\n你要做的是帮 Maryam 找出一个接线的方案，使得满足以下条件：\n\n1. 每个连接点上最少有一条电线连接到一个不同颜色的连接点上\n\n2. 所用的电线的总长为最短。\n\n\n## 实现细节\n\n你需要实现以下的子程序：\n\n`long long min_total_length(std::vector<int> r, std::vector<int> b)`\n\n- $r$：一个长度为 $n$ 的数组，其内以升序排列着所有红色连接点的位置。\n\n- $b$：一个长度为 $m$ 的数组，其内以升序排列着所有蓝色连接点的位置。\n\n- 这个子程序需返回在所有可能的连接方案中，最短电线总长度的那个方案的电线作为其返回值。\n\n- 请注意这个子程序的返回值的类型为 `long long` 。\n", "inputFormat": "你需要实现上面所述的子程序。\n", "outputFormat": "返回一个 `long long` 值。\n", "hint": "样例中函数传递参数：\n\n`min_total_length([1, 2, 3, 7], [0, 4, 5, 9, 10])`\n\n以下的图表表述了样例中的数据。\n\n ![](https://cdn.luogu.com.cn/upload/pic/6724.png) \n\n- 图中以水平的方式表示出相关的通讯塔。\n\n- 因题目打印是黑白色的，所以红色接点以较深色来表示，而蓝色接点则以较浅色来表示。\n\n- 图中有 $4$ 个红色的连接点，其位置分别为 $1,2,3$ 及 $7$ 。\n\n- 图中有 $5$ 个蓝色的连接点，其位置分别为 $0,4,5,9$ 及 $10$ 。\n\n- 该例的最优解的电线总长度为 $1+2+2+2+3=10$ ，所以子程序的返回值为 $10$ 。\n\n- 请注意共有两条电线连接在位置为 $7$ 的连接点上。\n\n\n## 限制条件\n\n- $1 \\leqslant n,m \\leqslant 100000$\n\n- $0 \\leqslant r[i] \\leqslant 10^9 $（对于所有$0 \\leqslant i \\leqslant n-1$）\n\n- $0 \\leqslant b[i] \\leqslant 10^9$（对于所有$0 \\leqslant i \\leqslant m-1$）\n\n- 数组$r$及数组$b$都已经按升序排好序。\n\n- 在数组$r$及$b$内的所有$n+m$个值均是不同的。\n\n\n## 子任务\n\n1. ($7$ 分)  $n,m\\leqslant 200$。\n\n2. ($13$ 分)  所有红色接点的位置坐标小于任何蓝色接点的坐标。\n\n3. ($10$ 分)  在每$7$个连续的（接续）的连接点内必有最少一个红色接点及蓝色接点。\n\n4. ($25$ 分)  所有接点在$[1,n+m]$范围内有不同的位置坐标。\n\n5. ($45$ 分)  没有任何附加的限制。\n", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2017] Wiring", "background": "This is a library problem.\n\nThis problem supports only C++ languages. You do not need to include the header file `wiring.h` when submitting, but you must include the `vector` header and declare the function `long long min_total_length(std::vector<int> r, std::vector<int> b)` at the beginning of your program.\n\nDue to an indescribable bug, submitting with C++14 (GCC9) will cause CE. Please do not use it.", "description": "Maryam is an electrical engineer. She is designing a wiring plan for a communication tower. There are connectors placed at various heights on this tower. A wire can be used to connect any two connectors. Each connector may be connected to any number of wires. There are two types of connectors: red connectors and blue connectors.\n\nFor convenience, the tower is regarded as a straight line, and the red and blue connectors are located at some non-negative integer coordinates on this line. The length of a wire is the distance between the two connectors it connects.\n\nYour task is to help Maryam find a wiring plan that satisfies the following:\n\n1. Each connector has at least one wire connected to a connector of the opposite color.\n2. The total length of the wires is minimized.\n\nImplementation details:\n\nYou need to implement the following subroutine:\n\n`long long min_total_length(std::vector<int> r, std::vector<int> b)`\n\n- $r$: an array of length $n$, containing the positions of all red connectors in ascending order.\n- $b$: an array of length $m$, containing the positions of all blue connectors in ascending order.\n- This subroutine should return the minimal total length of wires among all valid wirings.\n- Note that the return type of this subroutine is `long long`.\n\nConstraints:\n\n- $1 \\leqslant n,m \\leqslant 100000$.\n- $0 \\leqslant r[i] \\leqslant 10^9$ (for all $0 \\leqslant i \\leqslant n-1$).\n- $0 \\leqslant b[i] \\leqslant 10^9$ (for all $0 \\leqslant i \\leqslant m-1$).\n- The arrays $r$ and $b$ are already sorted in ascending order.\n- All $n+m$ values in $r$ and $b$ are distinct.\n\nSubtasks:\n\n1. ($7$ points) $n,m\\leqslant 200$.\n2. ($13$ points) All red connector positions are smaller than any blue connector position.\n3. ($10$ points) In every $7$ consecutive connectors, there is at least one red connector and one blue connector.\n4. ($25$ points) All connectors have distinct positions in the range $[1,n+m]$.\n5. ($45$ points) No additional constraints.", "inputFormat": "You need to implement the subroutine described above.", "outputFormat": "Return a `long long` value.", "hint": "Sample function call:\n\n`min_total_length([1, 2, 3, 7], [0, 4, 5, 9, 10])`\n\nThe following figure illustrates the sample data.\n\n![](https://cdn.luogu.com.cn/upload/pic/6724.png)\n\n- The tower is drawn horizontally.\n- Because the statement is printed in black and white, red connectors are drawn darker, and blue connectors lighter.\n- There are $4$ red connectors at positions $1, 2, 3$, and $7$.\n- There are $5$ blue connectors at positions $0, 4, 5, 9$, and $10$.\n- The optimal total wire length is $1+2+2+2+3=10$, so the subroutine should return $10$.\n- Note that there are two wires incident to the connector at position $7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2017] Wiring", "background": "这是一道交互题。\n\n本题仅支持 C++ 系列语言，提交时不需要包含 `wiring.h` 头文件，但需要在程序开头包含 `vector` 头文件以及声明函数 `long long min_total_length(std::vector<int> r, std::vector<int> b)`。\n\n**由于不可名状的 BUG，使用 C++14 (GCC9) 提交会导致 CE，请不要使用其提交。**", "description": "Maryam 是一位电机工程师。她正在为一座通讯塔设计接线方案。在这个塔上有一些分布在不同高度的连接点。一条电线可以用来将任何两个连接点连接起来。每一个连接点都可以接上任意数目的电线。而连接点共有两种：分别为红色连接点及蓝色连接点。\n\n为了表述方便起见，通讯塔会被视为一条直线，而那些红色及蓝色连接点会被视为在这条直线上的一些非负整数坐标。一条电线的长度是该电线所连接的两个连接点间的距离。\n\n你要做的是帮 Maryam 找出一个接线的方案，使得满足以下条件：\n\n1. 每个连接点上最少有一条电线连接到一个不同颜色的连接点上\n\n2. 所用的电线的总长为最短。\n\n\n## 实现细节\n\n你需要实现以下的子程序：\n\n`long long min_total_length(std::vector<int> r, std::vector<int> b)`\n\n- $r$：一个长度为 $n$ 的数组，其内以升序排列着所有红色连接点的位置。\n\n- $b$：一个长度为 $m$ 的数组，其内以升序排列着所有蓝色连接点的位置。\n\n- 这个子程序需返回在所有可能的连接方案中，最短电线总长度的那个方案的电线作为其返回值。\n\n- 请注意这个子程序的返回值的类型为 `long long` 。\n", "inputFormat": "你需要实现上面所述的子程序。\n", "outputFormat": "返回一个 `long long` 值。\n", "hint": "样例中函数传递参数：\n\n`min_total_length([1, 2, 3, 7], [0, 4, 5, 9, 10])`\n\n以下的图表表述了样例中的数据。\n\n ![](https://cdn.luogu.com.cn/upload/pic/6724.png) \n\n- 图中以水平的方式表示出相关的通讯塔。\n\n- 因题目打印是黑白色的，所以红色接点以较深色来表示，而蓝色接点则以较浅色来表示。\n\n- 图中有 $4$ 个红色的连接点，其位置分别为 $1,2,3$ 及 $7$ 。\n\n- 图中有 $5$ 个蓝色的连接点，其位置分别为 $0,4,5,9$ 及 $10$ 。\n\n- 该例的最优解的电线总长度为 $1+2+2+2+3=10$ ，所以子程序的返回值为 $10$ 。\n\n- 请注意共有两条电线连接在位置为 $7$ 的连接点上。\n\n\n## 限制条件\n\n- $1 \\leqslant n,m \\leqslant 100000$\n\n- $0 \\leqslant r[i] \\leqslant 10^9 $（对于所有$0 \\leqslant i \\leqslant n-1$）\n\n- $0 \\leqslant b[i] \\leqslant 10^9$（对于所有$0 \\leqslant i \\leqslant m-1$）\n\n- 数组$r$及数组$b$都已经按升序排好序。\n\n- 在数组$r$及$b$内的所有$n+m$个值均是不同的。\n\n\n## 子任务\n\n1. ($7$ 分)  $n,m\\leqslant 200$。\n\n2. ($13$ 分)  所有红色接点的位置坐标小于任何蓝色接点的坐标。\n\n3. ($10$ 分)  在每$7$个连续的（接续）的连接点内必有最少一个红色接点及蓝色接点。\n\n4. ($25$ 分)  所有接点在$[1,n+m]$范围内有不同的位置坐标。\n\n5. ($45$ 分)  没有任何附加的限制。\n", "locale": "zh-CN"}}}
{"pid": "P3838", "type": "P", "difficulty": 7, "samples": [["a = [0, 1]\nr = [1, 0]\nu = [0, 0, 1, 1]\nv = [0, 1, 0, 1]", "who_wins = [1, 1]"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2017", "IOI", "交互题"], "title": "[IOI 2017] Toy Train", "background": "### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。", "description": "Arezou 和她的兄弟 Borzou 是双胞胎。他们收到的生日礼物是一套好玩的玩具火车。他们用它建了一下 $n$ 个车站和 $m$ 段单向轨道的铁路系统。这些车站的编号是从 $0$ 到 $n-1$。每段轨道都始于某一车站，然后终于同一车站或其他车站。每个车站至少会有一段轨道以它为起点。\n\n其中有些车站是充电车站。无论何时，如果火车抵达某个充电车站。无论何时，如果火车抵达某个充电车站，它都会被充到满电。满电火车拥有足够的动力连续地试过 $n$ 段轨道，但是如果不再充电的话，在即将进入第 $n+1$ 段轨道时它就会因电已用光而停车。\n\n每个车站都有一个轨道开关，可以扳向任一以该车站为起点的轨道。火车从某个车站驶出时，驶向的正是该车站的开关所扳向的轨道。\n\n这对双胞胎打算用他们的火车玩个游戏。他们已经分完了所有的车站：每个车站要么归 Arezou，要么归 Borzou。游戏里面只有一列火车。游戏开始时，这列火车停在车站 $s$ ，并且充满了电。为启动游戏，车站 $s$ 的拥有者把车站 $s$ 的开关扳向某个以 $s$ 为起点的轨道。随后他们启动火车，火车也就开始沿着轨道行驶。无论何时，在火车首次进入某一车站时，该车站的拥有者都要扳定车站开关。开关一旦扳定，它就会保持状态不变直到游戏结束。因此，火车如果开到了一个曾经进过的车站，就会沿着与之前相同的轨道开出该车站。\n\n由于车站数量是有限的，火车的行驶最终都会落入某个环路。环路是指一系列**不同**的车站 $c_0,c_1,\\cdots ,c_{k-1}$，其中火车在离开车站 $c_i\\ \\ (0\\leqslant i < k-1)$ 后驶上连向车站 $c_{i+1}$ 的轨道，在离开车站 $c_{k-1}$ 后驶上连向车站 $c_0$ 的轨道。一个环路可能只包括一个车站（此时 $k=1$），即火车从车站 $c_0$ 驶出后又驶上了连向车站 $c_0$ 的轨道。\n\n如果火车能够连续行驶跑完，Arezou 就赢了。否则火车最后会把电用光而停车，这样 Borzou 就赢了。换句话说，如果 $c_0,c_1,\\cdots ,c_{k-1}$中至少有一个充电车站，且使得火车能够不断地充电而沿着环路跑个没完，Arezou 赢。否则，它就会最终把电用光（有可能是在沿着环路跑好几圈后），Borzou 赢。\n\n现在给你一个这样的铁路系统。Arezou 和 Borzou将会玩 $n$ 轮游戏。其中在第 $s$ 轮游戏中（$0\\leqslant s \\leqslant n-1$），火车最初停在车站 $s$ 上。你的任务是，对每一轮游戏，判断是否无论 Borzou 怎么玩，Arezou 都必胜。\n\n## 实现细节\n\n你需要实现下面的函数\n\n(C++) `std::vector who_wins(std::vector<int> a, std::vector<int> r, std::vector<int> u, std::vector<int> v)`\n\n(Java) `int[] who_wins(int[] a, int[] r, int[] u, int[] v)`\n\n- $a$：长度为 $n$ 的数组。如果 Arezou 拥有车站 $i$，则 $a_i=1$；否则 Borzou 拥有车站 $i$，且 $a_i=0$。\n\n- $r$：长度为$n$的数组。如果车站$i$是充电车站，则$r[i]=1$。否则$r[i]=0$。\n\n- $u$ 和 $v$：长度为 $m$ 的数组。对于所有 $0\\leqslant i \\leqslant m-1$，存在某一单向轨道，其起点为 $u_i$，终点为 $v_i$。\n\n- 该函数需要返回一个长度为 $n$ 的数组  $w$。对于每个 $0\\leqslant i \\leqslant n-1$，如果在火车最初停在车站 $i$ 的游戏中，不管 Borzou 怎么玩，Arezou 都能赢，则 $w_i$ 的值应为 $1$。否则 $w_i$ 的值应为 $0$。\n", "inputFormat": "你需要实现上述子程序。\n", "outputFormat": "你的子程序需要返回一个合法的结果。\n", "hint": " ![](https://cdn.luogu.com.cn/upload/pic/6727.png) \n\n- 这里有 $2$ 个车站。Borzou 拥有充电车站 $1$。Arezou拥有充电车站 $1$，但是它不是充电车站。\n\n- 这里有 $4$ 段轨道 $(0,0),(0,1),(1,0)$ 和 $(1,1)$，其中 $(i,j)$ 表示一个以车站 $i$ 为起点、车站$j$为终点的单向轨道。\n\n- 考虑火车最初停在车站 $0$ 的游戏。如果 Borzou 将车站 $0$ 的开关扳向轨道 $(0,0)$，那么火车就会沿着这个环形轨道绕个没完（注意，车站 $0$ 是一个充电车站）。在这种情况下，Arezou 赢。否则，如果 Borzou 把车站 $0$ 的开关扳向轨道 $(0,1)$，Arezou 可以把车站 $1$ 的开关扳向轨道 $(1,0)$。这样的话，火车将会在两个车站之间绕个不停。Arezou 还是会赢，因为车站$0$是充电车站，火车将跑个没完。因此，无论 Borzou 怎么玩，Arezou 都会赢。\n\n- 根据类似的逻辑，在火车最初停在车站 $1$ 的游戏中，无论 Borzou 怎么玩，Arezou 也都会赢。因此，函数应当返回 $[1,1]$。\n\n\n## 数据范围和限制\n\n- $1\\leqslant n \\leqslant 5000$\n- $n \\leqslant m \\leqslant 20000$\n- 至少会有一个充电车站。\n- 每个车站至少会有一段轨道以它为起点。\n- 可能会有某个轨道的起点和终点是相同的（即 $u_i=v_i$）。\n- 所有轨道两两不同。也就是说，不存在这样的两个下标 $i$ 和 $j$（$0\\leqslant i < j \\leqslant m-1$），使得 $u_i=u_j$ 且 $v_i=v_j$。\n- 对于所有 $0\\leqslant i \\leqslant m-1$，都有 $0\\leqslant u_i,v_i \\leqslant n-1$。\n\n## 子任务\n\n1. ($5$ 分) 对于所有 $0 \\leqslant i \\leqslant m-1$，都有 $v_i=u_i$ 或者 $v_i=u_i+1$。\n2. ($10$ 分) $n\\leqslant 15$。\n3. ($11$ 分) Arezou 拥有所有车站。\n4. ($11$ 分) Borzou 拥有所有车站。\n5. ($12$ 分) 充电车站的数量为 $1$。\n6. ($51$ 分) 无任何限制。\n", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2017] Toy Train", "background": "Due to technical limitations, please do not submit this problem using C++ 14 (GCC 9).\n\nThis is an interactive-style problem; you only need to implement the function required in the statement.\n\nYour code does not need to include any additional headers, nor implement the main function.", "description": "Arezou and her brother Borzou are twins. Their birthday present is a fun toy train set. They built a railway system with $n$ stations and $m$ directed tracks. The stations are numbered from $0$ to $n - 1$. Each track starts at some station and ends at the same station or another station. Every station has at least one outgoing track.\n\nSome stations are charging stations. Whenever the train arrives at a charging station, it is fully recharged. A fully charged train has enough power to traverse $n$ tracks in a row; without recharging, it will stop right before entering the $(n + 1)$-st track.\n\nEach station has a track switch that can be set to any one of its outgoing tracks. When the train departs a station, it follows the track currently selected by that station’s switch.\n\nThe twins plan to play a game with their train. They have divided the stations between them: each station belongs either to Arezou or to Borzou. There is only one train in the game. At the start, the train is at station $s$ and fully charged. To start the game, the owner of station $s$ sets its switch to one of its outgoing tracks. Then they start the train, and it begins moving along the tracks. Whenever the train enters a station for the first time, the owner of that station must set its switch. Once a switch is set, it remains fixed until the game ends. Therefore, if the train visits a station again, it will leave along the same track as before.\n\nSince the number of stations is finite, the train’s movement will eventually enter a cycle. A cycle is a sequence of distinct stations $c_0, c_1, \\dots, c_{k - 1}$ such that after leaving station $c_i$ for $0 \\leqslant i < k - 1$ the train takes the track to $c_{i + 1}$, and after leaving $c_{k - 1}$ it takes the track to $c_0$. A cycle may consist of a single station ($k = 1$), i.e., the train leaves station $c_0$ and immediately takes the track back to $c_0$.\n\nIf the train can keep running forever, Arezou wins. Otherwise, the train will eventually run out of power and stop, so Borzou wins. In other words, if there is at least one charging station among $c_0, c_1, \\dots, c_{k - 1}$ so that the train can keep getting recharged and run around the cycle forever, then Arezou wins. Otherwise, even if the train loops several times, it will eventually run out of power, and Borzou wins.\n\nYou are given such a railway system. Arezou and Borzou will play $n$ rounds. In round $s$ ($0 \\leqslant s \\leqslant n - 1$), the train initially starts at station $s$. Your task is to determine, for each round, whether Arezou wins no matter how Borzou plays.\n\nImplementation details:\n\nYou need to implement the following function:\n\n(C++) `std::vector<int> who_wins(std::vector<int> a, std::vector<int> r, std::vector<int> u, std::vector<int> v)`\n\n(Java) `int[] who_wins(int[] a, int[] r, int[] u, int[] v)`\n\n- $a$: an array of length $n$. If Arezou owns station $i$, then $a[i] = 1$; otherwise Borzou owns station $i$, and $a[i] = 0$.\n- $r$: an array of length $n$. If station $i$ is a charging station, then $r[i] = 1$; otherwise $r[i] = 0$.\n- $u$ and $v$: arrays of length $m$. For every $0 \\leqslant i \\leqslant m - 1$, there is a directed track that starts at $u[i]$ and ends at $v[i]$.\n- The function should return an array $w$ of length $n$. For every $0 \\leqslant i \\leqslant n - 1$, if in the game starting at station $i$ Arezou can win regardless of how Borzou plays, then $w[i] = 1$. Otherwise, $w[i] = 0$.", "inputFormat": "You need to implement the subroutine described above.", "outputFormat": "Your subroutine must return a valid result.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/6727.png)\n\n- There are 2 stations. Station 0 is a charging station owned by Borzou. Station 1 is owned by Arezou and is not a charging station.\n- There are 4 directed tracks: (0, 0), (0, 1), (1, 0), and (1, 1), where (i, j) denotes a track from station i to station j.\n- Consider the game starting at station 0. If Borzou sets station 0’s switch to (0, 0), the train will loop there forever (note that station 0 is a charging station). In this case, Arezou wins. Otherwise, if Borzou sets station 0’s switch to (0, 1), then Arezou can set station 1’s switch to (1, 0). The train will then loop between the two stations. Arezou still wins because station 0 is a charging station, so the train runs forever. Therefore, regardless of how Borzou plays, Arezou wins.\n- By a similar argument, in the game starting at station 1, Arezou also wins no matter how Borzou plays. Therefore, the function should return [1, 1].\n\n# Constraints\n\n- $1 \\leqslant n \\leqslant 5000$.\n- $n \\leqslant m \\leqslant 20000$.\n- There is at least one charging station.\n- Every station has at least one outgoing track.\n- It is possible that a track starts and ends at the same station (i.e., $u[i] = v[i]$).\n- All tracks are pairwise distinct. That is, there do not exist indices $i$ and $j$ ($0 \\leqslant i < j \\leqslant m - 1$) such that $u[i] = u[j]$ and $v[i] = v[j]$.\n- For all $0 \\leqslant i \\leqslant m - 1$, $0 \\leqslant u[i], v[i] \\leqslant n - 1$.\n\n# Subtasks\n\n1. (5 points) For all $0 \\leqslant i \\leqslant m - 1$, $v[i] = u[i]$ or $v[i] = u[i] + 1$.\n2. (10 points) $n \\leqslant 15$.\n3. (11 points) Arezou owns all stations.\n4. (11 points) Borzou owns all stations.\n5. (12 points) The number of charging stations is $1$.\n6. (51 points) No additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2017] Toy Train", "background": "### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。", "description": "Arezou 和她的兄弟 Borzou 是双胞胎。他们收到的生日礼物是一套好玩的玩具火车。他们用它建了一下 $n$ 个车站和 $m$ 段单向轨道的铁路系统。这些车站的编号是从 $0$ 到 $n-1$。每段轨道都始于某一车站，然后终于同一车站或其他车站。每个车站至少会有一段轨道以它为起点。\n\n其中有些车站是充电车站。无论何时，如果火车抵达某个充电车站。无论何时，如果火车抵达某个充电车站，它都会被充到满电。满电火车拥有足够的动力连续地试过 $n$ 段轨道，但是如果不再充电的话，在即将进入第 $n+1$ 段轨道时它就会因电已用光而停车。\n\n每个车站都有一个轨道开关，可以扳向任一以该车站为起点的轨道。火车从某个车站驶出时，驶向的正是该车站的开关所扳向的轨道。\n\n这对双胞胎打算用他们的火车玩个游戏。他们已经分完了所有的车站：每个车站要么归 Arezou，要么归 Borzou。游戏里面只有一列火车。游戏开始时，这列火车停在车站 $s$ ，并且充满了电。为启动游戏，车站 $s$ 的拥有者把车站 $s$ 的开关扳向某个以 $s$ 为起点的轨道。随后他们启动火车，火车也就开始沿着轨道行驶。无论何时，在火车首次进入某一车站时，该车站的拥有者都要扳定车站开关。开关一旦扳定，它就会保持状态不变直到游戏结束。因此，火车如果开到了一个曾经进过的车站，就会沿着与之前相同的轨道开出该车站。\n\n由于车站数量是有限的，火车的行驶最终都会落入某个环路。环路是指一系列**不同**的车站 $c_0,c_1,\\cdots ,c_{k-1}$，其中火车在离开车站 $c_i\\ \\ (0\\leqslant i < k-1)$ 后驶上连向车站 $c_{i+1}$ 的轨道，在离开车站 $c_{k-1}$ 后驶上连向车站 $c_0$ 的轨道。一个环路可能只包括一个车站（此时 $k=1$），即火车从车站 $c_0$ 驶出后又驶上了连向车站 $c_0$ 的轨道。\n\n如果火车能够连续行驶跑完，Arezou 就赢了。否则火车最后会把电用光而停车，这样 Borzou 就赢了。换句话说，如果 $c_0,c_1,\\cdots ,c_{k-1}$中至少有一个充电车站，且使得火车能够不断地充电而沿着环路跑个没完，Arezou 赢。否则，它就会最终把电用光（有可能是在沿着环路跑好几圈后），Borzou 赢。\n\n现在给你一个这样的铁路系统。Arezou 和 Borzou将会玩 $n$ 轮游戏。其中在第 $s$ 轮游戏中（$0\\leqslant s \\leqslant n-1$），火车最初停在车站 $s$ 上。你的任务是，对每一轮游戏，判断是否无论 Borzou 怎么玩，Arezou 都必胜。\n\n## 实现细节\n\n你需要实现下面的函数\n\n(C++) `std::vector who_wins(std::vector<int> a, std::vector<int> r, std::vector<int> u, std::vector<int> v)`\n\n(Java) `int[] who_wins(int[] a, int[] r, int[] u, int[] v)`\n\n- $a$：长度为 $n$ 的数组。如果 Arezou 拥有车站 $i$，则 $a_i=1$；否则 Borzou 拥有车站 $i$，且 $a_i=0$。\n\n- $r$：长度为$n$的数组。如果车站$i$是充电车站，则$r[i]=1$。否则$r[i]=0$。\n\n- $u$ 和 $v$：长度为 $m$ 的数组。对于所有 $0\\leqslant i \\leqslant m-1$，存在某一单向轨道，其起点为 $u_i$，终点为 $v_i$。\n\n- 该函数需要返回一个长度为 $n$ 的数组  $w$。对于每个 $0\\leqslant i \\leqslant n-1$，如果在火车最初停在车站 $i$ 的游戏中，不管 Borzou 怎么玩，Arezou 都能赢，则 $w_i$ 的值应为 $1$。否则 $w_i$ 的值应为 $0$。\n", "inputFormat": "你需要实现上述子程序。\n", "outputFormat": "你的子程序需要返回一个合法的结果。\n", "hint": " ![](https://cdn.luogu.com.cn/upload/pic/6727.png) \n\n- 这里有 $2$ 个车站。Borzou 拥有充电车站 $1$。Arezou拥有充电车站 $1$，但是它不是充电车站。\n\n- 这里有 $4$ 段轨道 $(0,0),(0,1),(1,0)$ 和 $(1,1)$，其中 $(i,j)$ 表示一个以车站 $i$ 为起点、车站$j$为终点的单向轨道。\n\n- 考虑火车最初停在车站 $0$ 的游戏。如果 Borzou 将车站 $0$ 的开关扳向轨道 $(0,0)$，那么火车就会沿着这个环形轨道绕个没完（注意，车站 $0$ 是一个充电车站）。在这种情况下，Arezou 赢。否则，如果 Borzou 把车站 $0$ 的开关扳向轨道 $(0,1)$，Arezou 可以把车站 $1$ 的开关扳向轨道 $(1,0)$。这样的话，火车将会在两个车站之间绕个不停。Arezou 还是会赢，因为车站$0$是充电车站，火车将跑个没完。因此，无论 Borzou 怎么玩，Arezou 都会赢。\n\n- 根据类似的逻辑，在火车最初停在车站 $1$ 的游戏中，无论 Borzou 怎么玩，Arezou 也都会赢。因此，函数应当返回 $[1,1]$。\n\n\n## 数据范围和限制\n\n- $1\\leqslant n \\leqslant 5000$\n- $n \\leqslant m \\leqslant 20000$\n- 至少会有一个充电车站。\n- 每个车站至少会有一段轨道以它为起点。\n- 可能会有某个轨道的起点和终点是相同的（即 $u_i=v_i$）。\n- 所有轨道两两不同。也就是说，不存在这样的两个下标 $i$ 和 $j$（$0\\leqslant i < j \\leqslant m-1$），使得 $u_i=u_j$ 且 $v_i=v_j$。\n- 对于所有 $0\\leqslant i \\leqslant m-1$，都有 $0\\leqslant u_i,v_i \\leqslant n-1$。\n\n## 子任务\n\n1. ($5$ 分) 对于所有 $0 \\leqslant i \\leqslant m-1$，都有 $v_i=u_i$ 或者 $v_i=u_i+1$。\n2. ($10$ 分) $n\\leqslant 15$。\n3. ($11$ 分) Arezou 拥有所有车站。\n4. ($11$ 分) Borzou 拥有所有车站。\n5. ($12$ 分) 充电车站的数量为 $1$。\n6. ($51$ 分) 无任何限制。\n", "locale": "zh-CN"}}}
{"pid": "P3839", "type": "P", "difficulty": 6, "samples": [["8\n\n0 3\n\n0 1\n\n1 2\n\n0 0\n\n2 1\n\n2 1\n\n1 0\n\n3 0", "\n? 0\n\n? 1\n\n? 2\n\n? 3\n\n? 4\n\n? 5\n\n? 6\n\n? 7\n\n! 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2017", "线段树", "二分", "IOI", "交互题", "Special Judge", "分块"], "title": "[IOI 2017] The Big Prize", "background": "如果你习惯于写函数式交互，以下内容可能对你有帮助：\n\n```cpp\nvector<int>ask(int i)\n{\n\tprintf(\"? %d\\n\",i);fflush(stdout);\n\tvector<int>ret(2);\n\tscanf(\"%d%d\",&ret[0],&ret[1]);\n\treturn ret;\n}\nint find_best(int n)\n{\n\t//\n}\nmain()\n{\n\tint n;scanf(\"%d\",&n);\n\tprintf(\"! %d\\n\",find_best(n));\n}\n```\n\n无论如何，你都不应引入额外的头文件。", "description": "“大奖”是一个家喻户晓的 TV 游戏节目。这次你很幸运地进入到最后一轮。已知编号从 $0$ 到 $n-1$ 的 $n$ 个盒子从左到右排成一行，你就站在这排盒子的前面。每个盒子里面放有一个奖品，必须打开盒子才能看到是什么奖品。已知有 $v\\leq5$ 种不同类型的奖品。这 $v$ 种类型按照奖品价值的降序从 $1$ 到 $v$ 排列。\n\n类型 $1$ 的奖品是一块钻石，价值最高。所有盒子加起来刚好只有一块钻石。类型 $v$ 的奖品是一块棒棒糖，价值最低。为使得游戏更加激动人心，相对便宜的奖品数量远比价值昂贵的奖品数量要多。更具体一点，对于满足 $2\\leq t \\leq v$ 的所有 $t$，我们有： 如果类型 $t-1$ 的奖品有 $k$ 个，那么类型 $t$ 的奖品将严格多于 $k^2$ 个。\n\n你的目标是赢得那块钻石。在游戏结束时，你必须打开一个盒子并收取盒子内的奖品。在选择要打开的盒子之前，你可以向节目主持人 Rambod 提一些问题。在每一个问题中，你选择就某个 $i$ 号盒子进行提问。Rambod 将给你一个包含两个整数的数组 $a$ 作为回答。这两个整数的意义如下：\n\n- 在 $i$ 号盒子左面的盒子中，刚好有 $a[0]$ 个盒子中的奖品，价值比 $i$ 号盒子中的奖品价值要高。\n- 在 $i$ 号盒子右面的盒子中，刚好有 $a[1]$ 个盒子中的奖品，价值比 $i$ 号盒子中的奖品价值要高。\n\n例如，假设 $n=8$，在你的问题中，你选择就 $i=2$ 号盒子进行提问。Rambod 的回答是 $a=[1,2]$。这个回答的意义是：\n\n- $0$ 号盒子和 $1$ 号盒子中恰好有一个盒子中的奖品比 $i$ 号盒子中的奖品更贵。\n- 在 $3,4,\\cdots,7$ 号盒子中恰好有 $2$ 个盒子中的奖品比 $2$ 号盒子中的奖品更贵。\n\n你的任务就是通过问少量的问题找出包含钻石的盒子。", "inputFormat": "你的程序开始运行时，应当读入一个正整数 $n$。\n\n你可以按以下格式发起询问：\n\n- `? i`  \n\t意为你选择就 $i$ 号盒子进行提问。你需要保证 $0\\leq i<n$。  \n\t随后你应当读入两个整数 `a[0] a[1]`，是交互库对你的回答。\n\n你可以按以下格式报告答案：\n\n- `! i`  \n\t意为你确定 $i$ 号盒子内有钻石。  \n    随后你应当立刻结束你的程序。", "outputFormat": "在发起询问后，不要忘记刷新缓冲区。你可以使用：\n\n- `fflush(stdout)` or `cout.flush()` in C++;\n- `stdout.flush()` in Python;  \n- 对于其他语言，参阅其文档。", "hint": "### 样例解释\n\n```plain\n8\n3 2 3 1 3 3 2 3\n```\n\n![](https://cdn.luogu.com.cn/upload/pic/6728.png)\n\n上图阐释了这个例子。图中上半部分给出了每个盒子中奖品的类型。图中的下半部分阐释了询问 `? 2`。\n\n### 限制\n\n- $3\\leq n \\leq200000$.\n- 每个盒子中奖品的类型介于 $1$ 和 $v$ 之间（含）。\n- 类型 $1$ 的奖品恰有一个。\n- 对于所有 $2\\leq t \\leq v$，如果类型 $t-1$ 的奖品有 $k$ 个，那么类型 $t$ 的奖品将严格多于 $k^2$ 个。\n\n\n### 子任务与评分\n\n1.  （$20$ 分）恰好有 $1$ 个钻石和 $n-1$ 个棒棒糖 （所以，$v=2$）。你可以询问最多 $10000$ 次。\n2.  （$80$ 分）没有附加限制。\n\n\n在子任务 2 中你可以获得部分分。令 $q$ 是在这个子任务的所有测试数据上发起询问的最大次数，那么你在这个子任务上的得分将按照下表计算：\n\n|询问次数      |得分        |\n|:--------:|:--------:|\n|$q>10000$ |$0$（在 CMS 中报告为 `Wrong Answer`）|\n|$6000<q\\le10000$|$70$      |\n|$5000<q\\le6000$|$80-\\dfrac{q-5000}{100}$|\n|$q\\le5000$|$80$      |", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2017] The Big Prize", "background": "If you are used to writing functional-style interaction, the following may help you:\n\n```cpp\nvector<int>ask(int i)\n{\n\tprintf(\"? %d\\n\",i);fflush(stdout);\n\tvector<int>ret(2);\n\tscanf(\"%d%d\",&ret[0],&ret[1]);\n\treturn ret;\n}\nint find_best(int n)\n{\n\t//\n}\nmain()\n{\n\tint n;scanf(\"%d\",&n);\n\tprintf(\"! %d\\n\",find_best(n));\n}\n```\n\nIn any case, you must not include any extra header files.", "description": "“The Big Prize” is a well-known TV game show. This time you are lucky to reach the final round. There are $n$ boxes in a row from left to right, numbered from $0$ to $n-1$, and you are standing in front of them. Each box contains exactly one prize, and you must open a box to see which prize it holds. There are $v\\leq5$ distinct types of prizes. These $v$ types are ordered from $1$ to $v$ in decreasing order of value.\n\nThe type $1$ prize is a diamond, the most valuable. Across all boxes there is exactly one diamond. The type $v$ prize is a lollipop, the least valuable. To make the game more exciting, cheaper prizes are far more numerous than expensive prizes. More specifically, for every $t$ with $2\\leq t \\leq v$, if there are $k$ prizes of type $t-1$, then there are strictly more than $k^2$ prizes of type $t$.\n\nYour goal is to win the diamond. At the end of the game, you must open one box and take the prize inside. Before choosing which box to open, you may ask the host, Rambod, some questions. In each question, you choose a box index $i$. Rambod answers with an array $a$ of two integers. They mean:\n\n- Among the boxes to the left of box $i$, there are exactly $a[0]$ boxes whose prizes are more valuable than the prize in box $i$.\n- Among the boxes to the right of box $i$, there are exactly $a[1]$ boxes whose prizes are more valuable than the prize in box $i$.\n\nFor example, suppose $n=8$, and in your query you choose $i=2$. Rambod’s answer is $a=[1,2]$. This means:\n\n- Among boxes $0$ and $1$, exactly one box has a prize more valuable than the prize in box $2$.\n- Among boxes $3,4,\\cdots,7$, exactly $2$ boxes have prizes more valuable than the prize in box $2$.\n\nYour task is to find the box containing the diamond by asking as few questions as possible.", "inputFormat": "When your program starts, it should read a positive integer $n$.\n\nYou may issue queries in the following format:\n\n- `? i`  \n  Meaning you choose to ask about box $i$. You must ensure $0\\leq i<n$.  \n  Then you should read two integers `a[0] a[1]`, which is the interactor’s response.\n\nYou may report your answer in the following format:\n\n- `! i`  \n  Meaning you are certain that the diamond is in box $i$.  \n  Then you must terminate your program immediately.", "outputFormat": "After issuing a query, do not forget to flush the output buffer. You may use:\n\n- `fflush(stdout)` or `cout.flush()` in C++.\n- `stdout.flush()` in Python.\n- For other languages, refer to their documentation.", "hint": "### Sample explanation\n\n```plain\n8\n3 2 3 1 3 3 2 3\n```\n\n![](https://cdn.luogu.com.cn/upload/pic/6728.png)\n\nThe figure illustrates this example. The upper part shows the prize type in each box. The lower part illustrates the query `? 2`.\n\n### Constraints\n\n- $3\\leq n \\leq200000$.\n- The prize type in each box is between $1$ and $v$ (inclusive).\n- There is exactly one type $1$ prize.\n- For all $2\\leq t \\leq v$, if there are $k$ prizes of type $t-1$, then there are strictly more than $k^2$ prizes of type $t$.\n\n### Subtasks and Scoring\n\n1. (20 points) There is exactly $1$ diamond and $n-1$ lollipops (so $v=2$). You may ask at most $10000$ queries.\n2. (80 points) No additional constraints.\n\nIn subtask 2 you can receive partial credit. Let $q$ be the maximum number of queries you use over all testdata in this subtask; then your score for this subtask is computed as follows:\n\n| Queries      | Score        |\n|:------------:|:------------:|\n| $q>10000$    | $0$ (reported as `Wrong Answer` in CMS) |\n| $6000<q\\le10000$ | $70$      |\n| $5000<q\\le6000$  | $80-\\dfrac{q-5000}{100}$ |\n| $q\\le5000$       | $80$      |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2017] The Big Prize", "background": "如果你习惯于写函数式交互，以下内容可能对你有帮助：\n\n```cpp\nvector<int>ask(int i)\n{\n\tprintf(\"? %d\\n\",i);fflush(stdout);\n\tvector<int>ret(2);\n\tscanf(\"%d%d\",&ret[0],&ret[1]);\n\treturn ret;\n}\nint find_best(int n)\n{\n\t//\n}\nmain()\n{\n\tint n;scanf(\"%d\",&n);\n\tprintf(\"! %d\\n\",find_best(n));\n}\n```\n\n无论如何，你都不应引入额外的头文件。", "description": "“大奖”是一个家喻户晓的 TV 游戏节目。这次你很幸运地进入到最后一轮。已知编号从 $0$ 到 $n-1$ 的 $n$ 个盒子从左到右排成一行，你就站在这排盒子的前面。每个盒子里面放有一个奖品，必须打开盒子才能看到是什么奖品。已知有 $v\\leq5$ 种不同类型的奖品。这 $v$ 种类型按照奖品价值的降序从 $1$ 到 $v$ 排列。\n\n类型 $1$ 的奖品是一块钻石，价值最高。所有盒子加起来刚好只有一块钻石。类型 $v$ 的奖品是一块棒棒糖，价值最低。为使得游戏更加激动人心，相对便宜的奖品数量远比价值昂贵的奖品数量要多。更具体一点，对于满足 $2\\leq t \\leq v$ 的所有 $t$，我们有： 如果类型 $t-1$ 的奖品有 $k$ 个，那么类型 $t$ 的奖品将严格多于 $k^2$ 个。\n\n你的目标是赢得那块钻石。在游戏结束时，你必须打开一个盒子并收取盒子内的奖品。在选择要打开的盒子之前，你可以向节目主持人 Rambod 提一些问题。在每一个问题中，你选择就某个 $i$ 号盒子进行提问。Rambod 将给你一个包含两个整数的数组 $a$ 作为回答。这两个整数的意义如下：\n\n- 在 $i$ 号盒子左面的盒子中，刚好有 $a[0]$ 个盒子中的奖品，价值比 $i$ 号盒子中的奖品价值要高。\n- 在 $i$ 号盒子右面的盒子中，刚好有 $a[1]$ 个盒子中的奖品，价值比 $i$ 号盒子中的奖品价值要高。\n\n例如，假设 $n=8$，在你的问题中，你选择就 $i=2$ 号盒子进行提问。Rambod 的回答是 $a=[1,2]$。这个回答的意义是：\n\n- $0$ 号盒子和 $1$ 号盒子中恰好有一个盒子中的奖品比 $i$ 号盒子中的奖品更贵。\n- 在 $3,4,\\cdots,7$ 号盒子中恰好有 $2$ 个盒子中的奖品比 $2$ 号盒子中的奖品更贵。\n\n你的任务就是通过问少量的问题找出包含钻石的盒子。", "inputFormat": "你的程序开始运行时，应当读入一个正整数 $n$。\n\n你可以按以下格式发起询问：\n\n- `? i`  \n\t意为你选择就 $i$ 号盒子进行提问。你需要保证 $0\\leq i<n$。  \n\t随后你应当读入两个整数 `a[0] a[1]`，是交互库对你的回答。\n\n你可以按以下格式报告答案：\n\n- `! i`  \n\t意为你确定 $i$ 号盒子内有钻石。  \n    随后你应当立刻结束你的程序。", "outputFormat": "在发起询问后，不要忘记刷新缓冲区。你可以使用：\n\n- `fflush(stdout)` or `cout.flush()` in C++;\n- `stdout.flush()` in Python;  \n- 对于其他语言，参阅其文档。", "hint": "### 样例解释\n\n```plain\n8\n3 2 3 1 3 3 2 3\n```\n\n![](https://cdn.luogu.com.cn/upload/pic/6728.png)\n\n上图阐释了这个例子。图中上半部分给出了每个盒子中奖品的类型。图中的下半部分阐释了询问 `? 2`。\n\n### 限制\n\n- $3\\leq n \\leq200000$.\n- 每个盒子中奖品的类型介于 $1$ 和 $v$ 之间（含）。\n- 类型 $1$ 的奖品恰有一个。\n- 对于所有 $2\\leq t \\leq v$，如果类型 $t-1$ 的奖品有 $k$ 个，那么类型 $t$ 的奖品将严格多于 $k^2$ 个。\n\n\n### 子任务与评分\n\n1.  （$20$ 分）恰好有 $1$ 个钻石和 $n-1$ 个棒棒糖 （所以，$v=2$）。你可以询问最多 $10000$ 次。\n2.  （$80$ 分）没有附加限制。\n\n\n在子任务 2 中你可以获得部分分。令 $q$ 是在这个子任务的所有测试数据上发起询问的最大次数，那么你在这个子任务上的得分将按照下表计算：\n\n|询问次数      |得分        |\n|:--------:|:--------:|\n|$q>10000$ |$0$（在 CMS 中报告为 `Wrong Answer`）|\n|$6000<q\\le10000$|$70$      |\n|$5000<q\\le6000$|$80-\\dfrac{q-5000}{100}$|\n|$q\\le5000$|$80$      |", "locale": "zh-CN"}}}
{"pid": "P3842", "type": "P", "difficulty": 3, "samples": [["6\n2 6\n3 4\n1 3\n1 2\n3 6\n4 5", "24"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2007", "各省省选", "天津"], "title": "[TJOI2007] 线段", "background": null, "description": "在一个 $n \\times n$ 的平面上，在每一行中有一条线段，第 $i$ 行的线段的左端点是 $(i, L_{i})$，右端点是 $(i, R_{i})$。\n\n你从 $(1,1)$ 点出发，要求沿途走过所有的线段，最终到达 $(n,n)$ 点，且所走的路程长度要尽量短。\n\n更具体一些说，你在任何时候只能选择向下走一步（行数增加 $1$）、向左走一步（列数减少 $1$）或是向右走一步（列数增加 $1$）。当然，由于你不能向上行走，因此在从任何一行向下走到另一行的时候，你必须保证已经走完本行的那条线段。", "inputFormat": "第一行有一个整数 $n$。\n\n以下 $n$ 行，在第 $i$ 行（总第 $(i+1)$ 行）的两个整数表示 $L_i$ 和 $R_i$。", "outputFormat": "仅包含一个整数，你选择的最短路程的长度。", "hint": "我们选择的路线是\n\n```\n (1, 1) (1, 6)\n (2, 6) (2, 3)\n (3, 3) (3, 1)\n (4, 1) (4, 2)\n (5, 2) (5, 6)\n (6, 6) (6, 4) (6, 6)\n```\n不难计算得到，路程的总长度是 $24$。 \n\n对于 $100\\%$ 的数据，$1\\le n \\le 2 \\times 10^4$，$1 \\le L_i \\le R_i \\le n$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Line Segments", "background": "", "description": "On an $n \\times n$ grid, there is a line segment in each row. In row $i$, the segment’s left endpoint is $(i, L_i)$ and its right endpoint is $(i, R_i)$.\n\nYou start from $(1, 1)$, must traverse all the segments along the way, and finally reach $(n, n)$, with the total distance traveled as short as possible.\n\nMore specifically, at any time you may only move one step down (row index increases by $1$), one step left (column index decreases by $1$), or one step right (column index increases by $1$). Since you cannot move up, when moving down from any row to the next, you must ensure you have already completely traversed the segment in the current row.", "inputFormat": "The first line contains an integer $n$.\n\nEach of the next $n$ lines contains two integers. In the $i$-th of these lines (the overall $(i+1)$-th line), the integers denote $L_i$ and $R_i$.", "outputFormat": "Output a single integer: the length of the shortest route.", "hint": "One chosen route is:\n```\n (1, 1) (1, 6)\n (2, 6) (2, 3)\n (3, 3) (3, 1)\n (4, 1) (4, 2)\n (5, 2) (5, 6)\n (6, 6) (6, 4) (6, 6)\n```\nIt is not hard to compute that the total length is $24$.\n\nConstraints: For $100\\%$ of the testdata, $1 \\le n \\le 2 \\times 10^4$, $1 \\le L_i \\le R_i \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 线段", "background": null, "description": "在一个 $n \\times n$ 的平面上，在每一行中有一条线段，第 $i$ 行的线段的左端点是 $(i, L_{i})$，右端点是 $(i, R_{i})$。\n\n你从 $(1,1)$ 点出发，要求沿途走过所有的线段，最终到达 $(n,n)$ 点，且所走的路程长度要尽量短。\n\n更具体一些说，你在任何时候只能选择向下走一步（行数增加 $1$）、向左走一步（列数减少 $1$）或是向右走一步（列数增加 $1$）。当然，由于你不能向上行走，因此在从任何一行向下走到另一行的时候，你必须保证已经走完本行的那条线段。", "inputFormat": "第一行有一个整数 $n$。\n\n以下 $n$ 行，在第 $i$ 行（总第 $(i+1)$ 行）的两个整数表示 $L_i$ 和 $R_i$。", "outputFormat": "仅包含一个整数，你选择的最短路程的长度。", "hint": "我们选择的路线是\n\n```\n (1, 1) (1, 6)\n (2, 6) (2, 3)\n (3, 3) (3, 1)\n (4, 1) (4, 2)\n (5, 2) (5, 6)\n (6, 6) (6, 4) (6, 6)\n```\n不难计算得到，路程的总长度是 $24$。 \n\n对于 $100\\%$ 的数据，$1\\le n \\le 2 \\times 10^4$，$1 \\le L_i \\le R_i \\le n$。", "locale": "zh-CN"}}}
{"pid": "P3843", "type": "P", "difficulty": 3, "samples": [["0 0 4\n-1 Y\n-1 X\n1 Y\n1 X\n1 0 4\n-1 X\n1 Y\n1 X\n-1 Y", "1.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "天津"], "title": "[TJOI2007] 迷路", "background": "小 A 和小 B 在一个二维空间中迷路了，每个人在这个空间中都按照自己特定的路线行\n\n走，由于他们的路线都是周期性的，因此你可以把这种路线理解为一种“轨道”：即一条封\n\n闭的路线，路线的终点和起点重合，这样才能“周期”的行走。\n", "description": "两个人行走的速度都是每秒一个单位距离，而且他们的路线都是平行于坐标轴的。基于\n\n此，如果两个人无限的走下去，我们想知道他们每一秒相离最近的距离。（我们只考虑两人\n\n在每秒行走后相离的距离，不考虑他们在这 1 秒内某个时刻的距离）\n", "inputFormat": "输入文件中有两个相似的部分，分别描述小 A 和小 B 的行走轨道。在每一个部分中的\n\n第一行有三个整数，sx、sy 和 m，前两个整数表示其初始位置，第三个整数表示轨道中折线\n\n的数目，以下 m 行，每行有一个整数 d 和一个非空格字符 c，d 和 c 之间用一个空格隔开。\n\nd 表示小 A 或小 B 沿坐标的正方向行走的距离，而 c 为’X’或’Y’，表示是 X 坐标轴还是 Y\n\n坐标轴。输入数据保证在每一个部分中，我们从起点(sx, sy)开始，执行 m 次行走步骤后，一定能\n\n回到起点，即这个轨道是封闭的。\n", "outputFormat": "输出文件中只包含一个实数，精确到小数点后两位。表示能观测到的两个人的最近距离，\n\n如果可能在某个时间两个人到达同一个点，则输出 0.00。\n", "hint": "100%的数据中，对于任何 m 和 d，有 1 ≤ m, d ≤ 100，轨道的初始坐标的绝对值不超\n\n过 2 000。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Lost", "background": "Xiao A and Xiao B are lost in a two-dimensional space. Each person walks along a specific route. Since their routes are periodic, you can regard each route as an “orbit”: a closed path whose endpoint coincides with its starting point, so that it can be traversed periodically.", "description": "Both people walk at a speed of 1 unit per second, and all their route segments are parallel to the coordinate axes. Based on this, if the two keep walking indefinitely, we want to know the smallest distance between them measured at the end of each second. We only consider the distance after each whole second of walking, not the distance at any moment within a second.", "inputFormat": "The input consists of two similar parts, describing the orbits of Xiao A and Xiao B respectively.\n\nFor each part:\n- The first line contains three integers: sx, sy, and m. The first two integers are the initial position, and the third is the number of polyline segments in the orbit.\n- The next m lines each contain an integer d and a non-space character c, separated by one space. Here d is the distance walked in the positive direction of the specified coordinate axis, and c is 'X' or 'Y', indicating whether the movement is parallel to the X-axis or the Y-axis.\n\nIt is guaranteed that, for each part, starting from (sx, sy) and performing these m walking steps, you will return to the starting point; that is, the orbit is closed.", "outputFormat": "Output a single real number with exactly two digits after the decimal point, representing the smallest observable distance between the two people. If it is possible for them to arrive at the same point at some integer time, output 0.00.", "hint": "For 100% of the testdata, $1 \\le m, d \\le 100$, and the absolute value of the initial coordinates does not exceed $2\\,000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 迷路", "background": "小 A 和小 B 在一个二维空间中迷路了，每个人在这个空间中都按照自己特定的路线行\n\n走，由于他们的路线都是周期性的，因此你可以把这种路线理解为一种“轨道”：即一条封\n\n闭的路线，路线的终点和起点重合，这样才能“周期”的行走。\n", "description": "两个人行走的速度都是每秒一个单位距离，而且他们的路线都是平行于坐标轴的。基于\n\n此，如果两个人无限的走下去，我们想知道他们每一秒相离最近的距离。（我们只考虑两人\n\n在每秒行走后相离的距离，不考虑他们在这 1 秒内某个时刻的距离）\n", "inputFormat": "输入文件中有两个相似的部分，分别描述小 A 和小 B 的行走轨道。在每一个部分中的\n\n第一行有三个整数，sx、sy 和 m，前两个整数表示其初始位置，第三个整数表示轨道中折线\n\n的数目，以下 m 行，每行有一个整数 d 和一个非空格字符 c，d 和 c 之间用一个空格隔开。\n\nd 表示小 A 或小 B 沿坐标的正方向行走的距离，而 c 为’X’或’Y’，表示是 X 坐标轴还是 Y\n\n坐标轴。输入数据保证在每一个部分中，我们从起点(sx, sy)开始，执行 m 次行走步骤后，一定能\n\n回到起点，即这个轨道是封闭的。\n", "outputFormat": "输出文件中只包含一个实数，精确到小数点后两位。表示能观测到的两个人的最近距离，\n\n如果可能在某个时间两个人到达同一个点，则输出 0.00。\n", "hint": "100%的数据中，对于任何 m 和 d，有 1 ≤ m, d ≤ 100，轨道的初始坐标的绝对值不超\n\n过 2 000。\n", "locale": "zh-CN"}}}
{"pid": "P3844", "type": "P", "difficulty": 4, "samples": [["3\n0 0 5\n0 1 2\n10 10 1", "69.12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "天津"], "title": "[TJOI2007] 圆", "background": null, "description": "平面上有 $n$ 个圆，任意两个不同的圆之间只有相离（可以外切）和包含（可以内切）两种关系。\n\n初始时整个平面是黑色的，我们按照输入给定的顺序在平面上画出这些圆。我们画一个圆的时候，把这个圆覆盖的区域全部反色，即如果区域中的一个点原来是黑色，则将它涂为白色；如果这个点原来是白色，则将它涂成黑色。\n\n按照这个步骤把所有的圆都画出来后，请输出平面上的所有白色区域的面积之和。", "inputFormat": "输入文件的第一行有一个整数 $n$，表示圆的个数。\n\n以下 $n$ 行，每行用三个整数 $x,y,r$ 描述一个圆，表示该圆的圆心坐标为 $(x, y)$，半径为 $r$。在平面上画圆的顺序和输入给定的顺序相同。", "outputFormat": "你只需要向输出文件输出一个实数，精确到小数点后两位，表示平面上白色区域面积之和。", "hint": "对于 $100\\%$ 的数据，$0\\le n\\le 100$，对于所有的圆，均有 $|x|, |y|, r \\le 1 000$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Circle", "background": "", "description": "There are $n$ circles on the plane. Any two distinct circles are either disjoint (they may be externally tangent) or one contains the other (they may be internally tangent).\n\nInitially, the entire plane is black. We draw these circles on the plane in the given input order. When we draw a circle, we invert the color of every point covered by that circle: if a point was black, paint it white; if it was white, paint it black.\n\nAfter all circles are drawn following this procedure, output the total area of all white regions on the plane.", "inputFormat": "The first line contains an integer $n$, the number of circles.\n\nEach of the following $n$ lines contains three integers $x, y, r$ describing a circle whose center is at $(x, y)$ and whose radius is $r$. The drawing order is the same as the input order.", "outputFormat": "Output a single real number rounded to two decimal places: the total area of all white regions on the plane.", "hint": "For $100\\%$ of the testdata, $0 \\le n \\le 100$. For all circles, $|x|, |y|, r \\le 1 000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 圆", "background": null, "description": "平面上有 $n$ 个圆，任意两个不同的圆之间只有相离（可以外切）和包含（可以内切）两种关系。\n\n初始时整个平面是黑色的，我们按照输入给定的顺序在平面上画出这些圆。我们画一个圆的时候，把这个圆覆盖的区域全部反色，即如果区域中的一个点原来是黑色，则将它涂为白色；如果这个点原来是白色，则将它涂成黑色。\n\n按照这个步骤把所有的圆都画出来后，请输出平面上的所有白色区域的面积之和。", "inputFormat": "输入文件的第一行有一个整数 $n$，表示圆的个数。\n\n以下 $n$ 行，每行用三个整数 $x,y,r$ 描述一个圆，表示该圆的圆心坐标为 $(x, y)$，半径为 $r$。在平面上画圆的顺序和输入给定的顺序相同。", "outputFormat": "你只需要向输出文件输出一个实数，精确到小数点后两位，表示平面上白色区域面积之和。", "hint": "对于 $100\\%$ 的数据，$0\\le n\\le 100$，对于所有的圆，均有 $|x|, |y|, r \\le 1 000$。", "locale": "zh-CN"}}}
{"pid": "P3845", "type": "P", "difficulty": 5, "samples": [["2\n4\n1-0\n2-0\n0-3\n2-1\n4\n5-0\n1-3\n2-2\n0-0", "2\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2007", "各省省选", "天津"], "title": "[TJOI2007] 球赛", "background": null, "description": "超级球迷 H 每周六晚上都会坐在电视前看球，从不错过一场比赛。\n\n但是上周末，H 突然有一个重要的约会，于是他只能教他三岁的弟弟小 H 记录所有比赛的比分。但是当他约会回来时，他发现小 H 不仅认真的记录了每一场比赛的最终比分，还把一些比赛的中间比分也记录下来，而更糟糕的是，小 H 并没有区分比赛的两个队，同一场比赛的比分可能被记录成 `1-2`，也可能是 `2-1`。因此，若是有一场比赛的最终得分是 5-3，可能实际上被小 H 记录的分数有：\n\n`1-0 3-2 2-3 3-4 5-3`\n\n现在 H 已经拿到了小 H 记录的所有比分，他想知道，在这个周末他由于约会至少错过了多少场比赛。注意小 H 记录的比分是没有先后顺序的。", "inputFormat": "输入文件中可能包含多组测试数据，文件中第一行是一个整数 $n$，表明以下一共有 $n$ 组测试数据。\n\n对于每一组数据，第一行有一个整数 $s$，表示小 H 记录的比分数目，以下每行用 `x-y` 的格式描述一条比分，$x$ 和 $y$ 都是非负整数。", "outputFormat": "对于输入数据中的每一个测试数据，你需要输出一个整数 $m$，表示在这个测试数据中，H 至少错过了 $m$ 场比赛。", "hint": "在第一组输入数据中，两场比赛对应的比分可能是 `1-0 2-0 0-3` 和 `2-1`。\n\n在第二组输入数据中，三场比赛对应的比分可能是 `0-0 5-0、3-1` 和 `2-2`。\n\n$100\\%$ 的数据中 $n \\leq 5，s \\leq 1000$，每一场比赛的比分都在 `longint(Pascal)` / `long(C++)`（$2147483647$）范围内。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Football Match", "background": "# Description\n\nSuper fan H watches football on TV every Saturday night and never misses a match.\n\nBut last weekend, H suddenly had an important date, so he taught his three-year-old brother, little H, to write down the scores of all matches. When he came back, he found that little H not only recorded the final score of each match, but also some intermediate scores. Worse, little H did not distinguish between the two teams; the same match could be recorded as `1-2` or `2-1`. Therefore, if the final score of a match was 5-3, little H might actually have written down the following scores:\n\n`1-0 3-2 2-3 3-4 5-3`\n\nNow H has all the scores recorded by little H. He wants to know the minimum number of matches he must have missed this weekend due to the date. Note that the recorded scores are in no particular order.", "description": "", "inputFormat": "", "outputFormat": "For each testdata, output a single integer $m$, the minimum number of matches that H must have missed.", "hint": "In the first testdata, two matches may correspond to `1-0 2-0 0-3` and `2-1`.\n\nIn the second testdata, three matches may correspond to `0-0`, `5-0 3-1`, and `2-2`.\n\nConstraints: For 100% of the testdata, $n \\leq 5$, $s \\leq 1000$, and every score fits in `longint(Pascal)` / `long(C++)` ($2147483647$).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 球赛", "background": null, "description": "超级球迷 H 每周六晚上都会坐在电视前看球，从不错过一场比赛。\n\n但是上周末，H 突然有一个重要的约会，于是他只能教他三岁的弟弟小 H 记录所有比赛的比分。但是当他约会回来时，他发现小 H 不仅认真的记录了每一场比赛的最终比分，还把一些比赛的中间比分也记录下来，而更糟糕的是，小 H 并没有区分比赛的两个队，同一场比赛的比分可能被记录成 `1-2`，也可能是 `2-1`。因此，若是有一场比赛的最终得分是 5-3，可能实际上被小 H 记录的分数有：\n\n`1-0 3-2 2-3 3-4 5-3`\n\n现在 H 已经拿到了小 H 记录的所有比分，他想知道，在这个周末他由于约会至少错过了多少场比赛。注意小 H 记录的比分是没有先后顺序的。", "inputFormat": "输入文件中可能包含多组测试数据，文件中第一行是一个整数 $n$，表明以下一共有 $n$ 组测试数据。\n\n对于每一组数据，第一行有一个整数 $s$，表示小 H 记录的比分数目，以下每行用 `x-y` 的格式描述一条比分，$x$ 和 $y$ 都是非负整数。", "outputFormat": "对于输入数据中的每一个测试数据，你需要输出一个整数 $m$，表示在这个测试数据中，H 至少错过了 $m$ 场比赛。", "hint": "在第一组输入数据中，两场比赛对应的比分可能是 `1-0 2-0 0-3` 和 `2-1`。\n\n在第二组输入数据中，三场比赛对应的比分可能是 `0-0 5-0、3-1` 和 `2-2`。\n\n$100\\%$ 的数据中 $n \\leq 5，s \\leq 1000$，每一场比赛的比分都在 `longint(Pascal)` / `long(C++)`（$2147483647$）范围内。", "locale": "zh-CN"}}}
{"pid": "P3846", "type": "P", "difficulty": 5, "samples": [["5 2 3\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2007", "各省省选", "O2优化", "素数判断,质数,筛法", "天津", "大步小步算法 BSGS", "模板题"], "title": "【模板】BSGS / [TJOI2007] 可爱的质数", "background": "", "description": "给定一个质数 $p$，以及一个整数 $b$，一个整数 $n$，现在要求你计算一个最小的非负整数 $l$，满足 $b^l \\equiv n \\pmod p$。", "inputFormat": "仅一行，有 $3$ 个整数，依次代表 $p, b, n$。", "outputFormat": "仅一行，如果有 $l$ 满足该要求，输出最小的 $l$，否则输出 `no solution`。", "hint": "#### 数据规模与约定\n\n- 对于所有的测试点，保证 $2\\le b < p<2^{31}$，$1\\leq n<p$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] BSGS / [TJOI2007] Lovely Prime", "background": "", "description": "Given a prime $p$, an integer $b$, and an integer $n$, compute the smallest non-negative integer $l$ such that $b^l \\equiv n \\pmod p$.", "inputFormat": "A single line contains $3$ integers, representing $p, b, n$ in order.", "outputFormat": "A single line. If there exists an $l$ satisfying the requirement, output the smallest $l$; otherwise output `no solution`.", "hint": "#### Constraints\n\n- For all testdata, it is guaranteed that $2 \\le b < p < 2^{31}$, $1 \\le n < p$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】BSGS / [TJOI2007] 可爱的质数", "background": "", "description": "给定一个质数 $p$，以及一个整数 $b$，一个整数 $n$，现在要求你计算一个最小的非负整数 $l$，满足 $b^l \\equiv n \\pmod p$。", "inputFormat": "仅一行，有 $3$ 个整数，依次代表 $p, b, n$。", "outputFormat": "仅一行，如果有 $l$ 满足该要求，输出最小的 $l$，否则输出 `no solution`。", "hint": "#### 数据规模与约定\n\n- 对于所有的测试点，保证 $2\\le b < p<2^{31}$，$1\\leq n<p$。", "locale": "zh-CN"}}}
{"pid": "P3847", "type": "P", "difficulty": 4, "samples": [["5\n1 2 2 4 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2007", "各省省选", "枚举", "区间 DP", "天津"], "title": "[TJOI2007] 调整队形", "background": "学校艺术节上，规定合唱队要参加比赛，各个队员的衣服颜色不能很混乱：合唱队员应排成一横排，且衣服颜色必须是左右对称的。\n\n例如：“红蓝绿蓝红”或“红蓝绿绿蓝红”都是符合的，而“红蓝绿红”或“蓝绿蓝红”就不符合要求。\n\n合唱队人数自然很多，仅现有的同学就可能会有 $3000$ 个。老师希望将合唱队调整得符合要求，但想要调整尽量少，减少麻烦。以下任一动作认为是一次调整：", "description": "1、在队伍左或右边加一个人（衣服颜色依要求而定）；\n\n2、在队伍中任两个人中间插入一个人（衣服颜色依要求而定）；\n\n3、剔掉一个人；\n\n4、让一个人换衣服颜色；\n\n老师想知道就目前的队形最少的调整次数是多少，请你编一个程序来回答他。\n\n因为加入合唱队很热门，你可以认为人数是无限的，即随时想加一个人都能找到人。同时衣服颜色也是任意的。", "inputFormat": "第一行是一个整数 $n$（$1 \\le n \\le 3000$）。\n\n第二行是 $n$ 个整数，从左到右分别表示现有的每个队员衣服的颜色号，都是 $1$ 到 $3000$ 的整数。", "outputFormat": "一个数，即对于输入队列，要调整得符合要求，最少的调整次数。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Adjust the Lineup", "background": "At the school's arts festival, the chorus is required to compete, and the colors of the members' clothes must not be chaotic: the chorus members should stand in a single row, and the clothing colors must be left-right symmetric.\n\nFor example: \"red blue green blue red\" or \"red blue green green blue red\" are acceptable, while \"red blue green red\" or \"blue green blue red\" are not.\n\nThe chorus can be quite large, with up to $3000$ students. The teacher wants to adjust the lineup to meet the requirement with as few adjustments as possible. Each of the following actions counts as one adjustment:", "description": "1. Add one person to the left or right end (their clothing color can be chosen as needed).\n2. Insert one person between any two adjacent people (their clothing color can be chosen as needed).\n3. Remove one person.\n4. Change one person's clothing color.\n\nThe teacher wants to know, for the current lineup, the minimum number of adjustments needed. Please write a program to answer this.\n\nBecause joining the chorus is very popular, you may assume there is an unlimited number of people available, i.e., you can always add someone when needed. Clothing colors can be chosen arbitrarily as well.", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 3000$).\n\nThe second line contains $n$ integers, from left to right, representing the current clothing color ID of each member, all integers from $1$ to $3000$.", "outputFormat": "Output a single number: the minimum number of adjustments needed to make the lineup meet the requirement.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 调整队形", "background": "学校艺术节上，规定合唱队要参加比赛，各个队员的衣服颜色不能很混乱：合唱队员应排成一横排，且衣服颜色必须是左右对称的。\n\n例如：“红蓝绿蓝红”或“红蓝绿绿蓝红”都是符合的，而“红蓝绿红”或“蓝绿蓝红”就不符合要求。\n\n合唱队人数自然很多，仅现有的同学就可能会有 $3000$ 个。老师希望将合唱队调整得符合要求，但想要调整尽量少，减少麻烦。以下任一动作认为是一次调整：", "description": "1、在队伍左或右边加一个人（衣服颜色依要求而定）；\n\n2、在队伍中任两个人中间插入一个人（衣服颜色依要求而定）；\n\n3、剔掉一个人；\n\n4、让一个人换衣服颜色；\n\n老师想知道就目前的队形最少的调整次数是多少，请你编一个程序来回答他。\n\n因为加入合唱队很热门，你可以认为人数是无限的，即随时想加一个人都能找到人。同时衣服颜色也是任意的。", "inputFormat": "第一行是一个整数 $n$（$1 \\le n \\le 3000$）。\n\n第二行是 $n$ 个整数，从左到右分别表示现有的每个队员衣服的颜色号，都是 $1$ 到 $3000$ 的整数。", "outputFormat": "一个数，即对于输入队列，要调整得符合要求，最少的调整次数。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3848", "type": "P", "difficulty": 3, "samples": [["4  3  2\n1  0  1  0 \n1  1  1  1\n0  0  1  0\n1  1  0  1", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "2007", "各省省选", "递归", "深度优先搜索 DFS", "天津"], "title": "[TJOI2007] 跳棋", "background": "### 本题可能为错题，目前数据只是随机生成的 $n\\leq 20$ 的情况，测试数据和题解仅供参考。\n\n在一个n×n的棋盘上，布满了0和1，如图（a）所示（n=7），为叙述方便，将0用字母表示，如图（b）。\n\n![](https://cdn.luogu.com.cn/upload/pic/6077.png)\n", "description": "跳棋规则：\n\n（1）从某个0格出发，可以向上，下，左，右4个方向连续越过若干个（至少1个）\n\n1格而跳入下一个0格。如图（b）中从A出发，可跳到B，或者到E，但不能直接到K。在跳到B之后还可以继续跳到F;在跳到E之后可继续跳到F或K。直到不能再跳为止。\n\n（2）每个0格只能到达一次，给出的起始点不能再到达，也不能越过。\n\n跳过的距离为跳过1格个数加1，如从A到B，跳过距离为3，从B到F，跳过距离为2。\n\n问   题： 当棋盘和起始点给出之后，问最远能跳的距离是多少？\n\n如上图（b）中，从A出发，可跳过的路线不止一条，其中一条为：\n\nA － B － F － L － K － E  （可能不唯一）\n\n3    2    3    3     3\n\n它的距离为14。\n", "inputFormat": "第一行三个整数  n（1≤n≤100），x，y（起点坐标，上图（b）中A处坐标为1，3）\n\n接下来n行，每行n个数（0或1），数与数之间用一个空格分隔。\n", "outputFormat": "一个整数，即最大可跳距离（若不能跳，输出0）。\n", "hint": "$\\text{upd 2022.7.27}$：新增加一组 Hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Checkers", "background": "This problem may be flawed. The current testdata are randomly generated for $n\\leq 20$, and both the testdata and the editorials are for reference only.\n\nOn an $n \\times n$ board filled with 0s and 1s, as shown in Figure (a) (with $n=7$), for convenience, the 0s are labeled with letters, as shown in Figure (b).\n\n![](https://cdn.luogu.com.cn/upload/pic/6077.png)", "description": "Rules of the game:\n\n(1) Starting from some 0-cell, you can jump in one of the four directions (up, down, left, right), consecutively over several (at least one) 1-cells, and land on the next 0-cell. In Figure (b), starting from A, you can jump to B or to E, but not directly to K. After jumping to B, you can continue to F; after jumping to E, you can continue to F or K. Continue until no further jump is possible.\n\n(2) Each 0-cell can be visited at most once. The given starting cell cannot be visited again, nor can it be jumped over.\n\nThe jump distance equals the number of 1-cells jumped over plus 1. For example, from A to B the distance is 3; from B to F the distance is 2.\n\nProblem: Given the board and the starting point, what is the maximum total jump distance?\n\nIn Figure (b), starting from A, there are multiple possible routes. One of them is:\nA - B - F - L - K - E (possibly not unique)\n3 2 3 3 3\nIts total distance is 14.", "inputFormat": "The first line contains three integers: $n$ (1 ≤ $n$ ≤ 100), $x$, $y$ (coordinates of the starting point; in Figure (b), the coordinates of A are 1, 3).\n\nThen follow $n$ lines, each containing $n$ numbers (0 or 1), separated by a single space.", "outputFormat": "Output a single integer: the maximum total jump distance (output 0 if no jump is possible).", "hint": "$\\text{upd 2022.7.27}$：A new hack testdata has been added.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 跳棋", "background": "### 本题可能为错题，目前数据只是随机生成的 $n\\leq 20$ 的情况，测试数据和题解仅供参考。\n\n在一个n×n的棋盘上，布满了0和1，如图（a）所示（n=7），为叙述方便，将0用字母表示，如图（b）。\n\n![](https://cdn.luogu.com.cn/upload/pic/6077.png)\n", "description": "跳棋规则：\n\n（1）从某个0格出发，可以向上，下，左，右4个方向连续越过若干个（至少1个）\n\n1格而跳入下一个0格。如图（b）中从A出发，可跳到B，或者到E，但不能直接到K。在跳到B之后还可以继续跳到F;在跳到E之后可继续跳到F或K。直到不能再跳为止。\n\n（2）每个0格只能到达一次，给出的起始点不能再到达，也不能越过。\n\n跳过的距离为跳过1格个数加1，如从A到B，跳过距离为3，从B到F，跳过距离为2。\n\n问   题： 当棋盘和起始点给出之后，问最远能跳的距离是多少？\n\n如上图（b）中，从A出发，可跳过的路线不止一条，其中一条为：\n\nA － B － F － L － K － E  （可能不唯一）\n\n3    2    3    3     3\n\n它的距离为14。\n", "inputFormat": "第一行三个整数  n（1≤n≤100），x，y（起点坐标，上图（b）中A处坐标为1，3）\n\n接下来n行，每行n个数（0或1），数与数之间用一个空格分隔。\n", "outputFormat": "一个整数，即最大可跳距离（若不能跳，输出0）。\n", "hint": "$\\text{upd 2022.7.27}$：新增加一组 Hack 数据。", "locale": "zh-CN"}}}
{"pid": "P3849", "type": "P", "difficulty": 6, "samples": [["1 10 10 1\n0.3 0.2 0.5 0.7 0.2 0.1", "1.609"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "天津"], "title": "[TJOI2007] 足彩投注", "background": "了解足球彩票的人可能知道，足球彩票中有一种游戏叫做“胜负彩”，意为猜比赛的胜负。下面是一些与胜负彩有关的术语：\n\n注：**每一**组有效组合数据。\n\n投注：彩民以现金购买足球彩票的行为。\n\n单式投注：彩民对于所有球队的比赛成绩均只选择一种预测结果的投注方式。投注的数量（注数）为1。\n\n复式投注：彩民对于某些场次的比赛成绩选择两种以上的预测结果的投注方式。投注的数量为复式投注的组合数。例如，某彩民对一场比赛预测了两个结果（例如胜平），另一场比赛预测了三个结果（胜负平），其他比赛都只预测了一种结果，那么注数就是 $2\\times 3=6$。**这样的一个复式投注，可以看成一个包含六种单式投注的集合。**\n\n\n胜负彩的玩法一般是这样的。彩票机构指定一轮比赛中的若干场，让彩民去猜每场比赛的结果（胜负平）。根据彩民猜中比赛的场次，来确定中奖的额度", "description": "我们现在考虑一个简化的模型。对于一轮比赛，彩民需要竞猜其中 $n$ 场比赛的结果，每场比赛的胜负平都有一个概率 $p(i, r)$ 。其中，$i$ 表示第 $i$ 场比赛。$r\\in \\{0,1,2\\}$，分别表示主队比赛结果的负、平、胜。$p(i, r)$ 则表示第i场比赛、结果为r的概率。此外，还有一个概率 $q(i, r)$，表示第 $i$ 场比赛，投注购买结果为 $r$ 的概率，**即总注数中购买该场次某一比赛结果的概率**。\n\n\n例如，如果 $q(1,0) = 0.5$，我们可以知道第一场比赛有 $50\\%$ 的投注会买主队输球。我们假设这 $n$ 场比赛互不相关，即 $p(i, r)$ 的结果不会受 $p(j, r’)$ 的影响，$q(i, r)$ 的结果也不会受 $q(j, r’)$ 的影响（$r \\ne r’$）。\n\n\n在这个模型里，我们规定，必须猜中全部 $n$ 场比赛的结果才能获奖。总奖金为 $M$，由所有获奖的投注平分。因此，对于一个单式投注 $R_i = \\{r_{i1}, r_{i2}, \\ldots ,r_{in}\\}$，$r_{ij}$ 表示投注 $R_i$对第j场比赛的预测结果，它的中奖概率为：\n\n$$\nP(R_i)=\\prod\\limits_{j=1}^np(j,r_{ij})\n$$\n设投注总数为 $N$，那么中奖的投注总数为：\n\n$$\nN\\cdot Q(R_i)=N\\cdot\\prod\\limits_{j=1}^nq(j,r_{ij})\n$$\n于是，投注 $R_i$ 所能得到的奖金的期望（平均意义下能够获得的奖金数）就是：\n\n$$\n\\dfrac{M}{N\\cdot Q(R_i)} \\cdot P(R_i)\n$$\n以上考虑的仅仅是单式投注的情况，即仅考虑单注 $R_i$ 的中奖情况。对于复式投注，情况要复杂一些。采用复式投注时，投注的是一个集合 $R = \\{R1, R2, …, Rk\\}$，其中k是投注的数量。例如，三场比赛，第一场猜“胜负”，第二场猜“平”，第三场猜“负平”，则 $k = 4$，$R$ 集合所包含的四个元素如下如下：\n\n|       | $r_{i1}$ | $r_{i2}$ | $r_{i3}$ |\n| ----- | -------- | -------- | -------- |\n| $R_1$ | 0        | 1        | 0        |\n| $R_2$ | 0        | 1        | 1        |\n| $R_3$ | 2        | 1        | 0        |\n| $R_4$ | 2        | 1        | 1        |\n\n复式投注R中，只要有一个 $Ri$ 猜对所有比赛结果，即可中奖。因此，复式投注R所能获得的奖金的期望就是：\n\n$$\n\\sum_{R_i\\in R}\\dfrac{M}{N\\cdot Q(R_i)} \\cdot P(R_i)\n$$\n\n我们的问题是，给定 $n$ 场比赛的信息（胜负平的概率和彩民购买三种结果的概率），以及复式投注中可以购买的最大注数 $U$，要求设计一种复式投注的方案，在不超过最大注数（复式投注的注数 $k \\le U$）的前提下，使得获得奖金的期望最大。", "inputFormat": "第一行四个正整数 $n, N, M, U$，其中 $n, U \\le 10^4, N, M \\le 10^9$。\n\n以下 $n$ 行，每行六个实数。第 $i + 1$ 行的六个实数为 $p(i, 0), p(i, 1), p(i, 2), q(i, 0),q(i, 1),q(i, 2)$，用来描述第 $i$ 场比赛的相关信息。其中，$p(i, 0) + p(i, 1) + p(i, 2) = 1$,，$q(i, 0) + q(i, 1) + q(i, 2) = 1$，$ q(i, j) ≠ 0$。", "outputFormat": "一个实数，表示最大的奖金期望的自然对数。\n\n$$\n\\ln \\left( \\operatorname{max}_{\\lvert R \\rvert \\le U}\\left\\{\\sum_{R_i\\in R}\\dfrac{M}{N\\cdot Q(R_i)} \\cdot P(R_i)\\right\\}\\right)\n$$\n\n输出保留 $3$ 位小数（四舍五入）。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Football Lottery Betting", "background": "People who know football lotteries may be familiar with a game called “Win-Draw-Loss,” which means predicting the outcome of each match. Below are some terms related to Win-Draw-Loss.\n\nNote: each group is one valid combination of bets.\n\nBetting: the act of buying football lottery tickets with cash.\n\nSingle bet: the bettor selects exactly one predicted result for every match. The number of bets (tickets) is 1.\n\nMultiple bet: the bettor selects two or more predicted results for some matches. The number of bets equals the number of combinations in the multiple bet. For example, if a bettor predicts two outcomes (e.g., win or draw) for one match, three outcomes (win, draw, loss) for another match, and exactly one outcome for all other matches, then the number of bets is $2 \\times 3 = 6$. Such a multiple bet can be regarded as a set containing six single bets.\n\nIn a typical Win-Draw-Loss game, the lottery operator specifies several matches within a round and asks bettors to predict each match’s result (win, draw, loss). The prize amount depends on how many matches the bettor predicts correctly.", "description": "We now consider a simplified model. In one round, the bettor needs to predict the results of $n$ matches. Each match’s win-draw-loss outcomes have probabilities $p(i, r)$. Here, $i$ denotes the $i$-th match and $r \\in \\{0, 1, 2\\}$ denotes the home team’s loss, draw, and win, respectively. The value $p(i, r)$ is the probability that match $i$ ends with result $r$. In addition, $q(i, r)$ denotes the probability that, among all purchased bets, result $r$ is chosen for match $i$, i.e., the fraction of the total number of bets that select that outcome for that match.\n\nFor example, if $q(1, 0) = 0.5$, then we know that $50\\%$ of the bets choose the home team to lose in the first match. We assume these $n$ matches are independent, i.e., the outcomes $p(i, r)$ are independent across matches, and the selections $q(i, r)$ are also independent across matches (with $r \\ne r'$).\n\nIn this model, a ticket wins only if it correctly predicts all $n$ matches. The total prize pool is $M$ and is shared equally among all winning bets. Therefore, for a single bet $R_i = \\{r_{i1}, r_{i2}, \\ldots, r_{in}\\}$, where $r_{ij}$ is the predicted result of bet $R_i$ for match $j$, its winning probability is:\n$$\nP(R_i)=\\prod\\limits_{j=1}^n p(j, r_{ij}).\n$$\nLet the total number of bets be $N$. Then the total number of winning bets is:\n$$\nN \\cdot Q(R_i)=N\\cdot\\prod\\limits_{j=1}^n q(j, r_{ij}).\n$$\nHence, the expected prize (the average prize) received by bet $R_i$ is:\n$$\n\\dfrac{M}{N\\cdot Q(R_i)} \\cdot P(R_i).\n$$\nThe above only considers single bets, i.e., the winning of a single $R_i$. For multiple bets, the situation is more complicated. A multiple bet is a set $R = \\{R_1, R_2, \\ldots, R_k\\}$, where $k$ is the number of bets. For example, with three matches, if the first match is “win or loss,” the second is “draw,” and the third is “loss or draw,” then $k = 4$, and the set $R$ contains the following four elements:\n\n|       | $r_{i1}$ | $r_{i2}$ | $r_{i3}$ |\n| ----- | -------- | -------- | -------- |\n| $R_1$ | 0        | 1        | 0        |\n| $R_2$ | 0        | 1        | 1        |\n| $R_3$ | 2        | 1        | 0        |\n| $R_4$ | 2        | 1        | 1        |\n\nIn a multiple bet $R$, you win if at least one $R_i$ predicts all results correctly. Therefore, the expected prize of $R$ is:\n$$\n\\sum_{R_i\\in R}\\dfrac{M}{N\\cdot Q(R_i)} \\cdot P(R_i).\n$$\n\nThe problem: given the information for $n$ matches (the probabilities of outcomes and the probabilities that bettors buy those outcomes), and the maximum number of bets $U$ allowed in a multiple bet, design a multiple betting scheme that does not exceed the maximum number of bets ($k \\le U$) and maximizes the expected prize.", "inputFormat": "The first line contains four positive integers $n, N, M, U$, where $n, U \\le 10^4$ and $N, M \\le 10^9$.\n\nEach of the next $n$ lines contains six real numbers. The six real numbers on line $i + 1$ are $p(i, 0), p(i, 1), p(i, 2), q(i, 0), q(i, 1), q(i, 2)$, describing match $i$. Here, $p(i, 0) + p(i, 1) + p(i, 2) = 1$, $q(i, 0) + q(i, 1) + q(i, 2) = 1$, and $q(i, j) \\ne 0$.", "outputFormat": "Output a real number, the natural logarithm of the maximum expected prize:\n$$\n\\ln \\left( \\operatorname{max}_{\\lvert R \\rvert \\le U}\\left\\{\\sum_{R_i\\in R}\\dfrac{M}{N\\cdot Q(R_i)} \\cdot P(R_i)\\right\\}\\right).\n$$\nPrint the answer with $3$ decimal places (rounded half up).", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 足彩投注", "background": "了解足球彩票的人可能知道，足球彩票中有一种游戏叫做“胜负彩”，意为猜比赛的胜负。下面是一些与胜负彩有关的术语：\n\n注：**每一**组有效组合数据。\n\n投注：彩民以现金购买足球彩票的行为。\n\n单式投注：彩民对于所有球队的比赛成绩均只选择一种预测结果的投注方式。投注的数量（注数）为1。\n\n复式投注：彩民对于某些场次的比赛成绩选择两种以上的预测结果的投注方式。投注的数量为复式投注的组合数。例如，某彩民对一场比赛预测了两个结果（例如胜平），另一场比赛预测了三个结果（胜负平），其他比赛都只预测了一种结果，那么注数就是 $2\\times 3=6$。**这样的一个复式投注，可以看成一个包含六种单式投注的集合。**\n\n\n胜负彩的玩法一般是这样的。彩票机构指定一轮比赛中的若干场，让彩民去猜每场比赛的结果（胜负平）。根据彩民猜中比赛的场次，来确定中奖的额度", "description": "我们现在考虑一个简化的模型。对于一轮比赛，彩民需要竞猜其中 $n$ 场比赛的结果，每场比赛的胜负平都有一个概率 $p(i, r)$ 。其中，$i$ 表示第 $i$ 场比赛。$r\\in \\{0,1,2\\}$，分别表示主队比赛结果的负、平、胜。$p(i, r)$ 则表示第i场比赛、结果为r的概率。此外，还有一个概率 $q(i, r)$，表示第 $i$ 场比赛，投注购买结果为 $r$ 的概率，**即总注数中购买该场次某一比赛结果的概率**。\n\n\n例如，如果 $q(1,0) = 0.5$，我们可以知道第一场比赛有 $50\\%$ 的投注会买主队输球。我们假设这 $n$ 场比赛互不相关，即 $p(i, r)$ 的结果不会受 $p(j, r’)$ 的影响，$q(i, r)$ 的结果也不会受 $q(j, r’)$ 的影响（$r \\ne r’$）。\n\n\n在这个模型里，我们规定，必须猜中全部 $n$ 场比赛的结果才能获奖。总奖金为 $M$，由所有获奖的投注平分。因此，对于一个单式投注 $R_i = \\{r_{i1}, r_{i2}, \\ldots ,r_{in}\\}$，$r_{ij}$ 表示投注 $R_i$对第j场比赛的预测结果，它的中奖概率为：\n\n$$\nP(R_i)=\\prod\\limits_{j=1}^np(j,r_{ij})\n$$\n设投注总数为 $N$，那么中奖的投注总数为：\n\n$$\nN\\cdot Q(R_i)=N\\cdot\\prod\\limits_{j=1}^nq(j,r_{ij})\n$$\n于是，投注 $R_i$ 所能得到的奖金的期望（平均意义下能够获得的奖金数）就是：\n\n$$\n\\dfrac{M}{N\\cdot Q(R_i)} \\cdot P(R_i)\n$$\n以上考虑的仅仅是单式投注的情况，即仅考虑单注 $R_i$ 的中奖情况。对于复式投注，情况要复杂一些。采用复式投注时，投注的是一个集合 $R = \\{R1, R2, …, Rk\\}$，其中k是投注的数量。例如，三场比赛，第一场猜“胜负”，第二场猜“平”，第三场猜“负平”，则 $k = 4$，$R$ 集合所包含的四个元素如下如下：\n\n|       | $r_{i1}$ | $r_{i2}$ | $r_{i3}$ |\n| ----- | -------- | -------- | -------- |\n| $R_1$ | 0        | 1        | 0        |\n| $R_2$ | 0        | 1        | 1        |\n| $R_3$ | 2        | 1        | 0        |\n| $R_4$ | 2        | 1        | 1        |\n\n复式投注R中，只要有一个 $Ri$ 猜对所有比赛结果，即可中奖。因此，复式投注R所能获得的奖金的期望就是：\n\n$$\n\\sum_{R_i\\in R}\\dfrac{M}{N\\cdot Q(R_i)} \\cdot P(R_i)\n$$\n\n我们的问题是，给定 $n$ 场比赛的信息（胜负平的概率和彩民购买三种结果的概率），以及复式投注中可以购买的最大注数 $U$，要求设计一种复式投注的方案，在不超过最大注数（复式投注的注数 $k \\le U$）的前提下，使得获得奖金的期望最大。", "inputFormat": "第一行四个正整数 $n, N, M, U$，其中 $n, U \\le 10^4, N, M \\le 10^9$。\n\n以下 $n$ 行，每行六个实数。第 $i + 1$ 行的六个实数为 $p(i, 0), p(i, 1), p(i, 2), q(i, 0),q(i, 1),q(i, 2)$，用来描述第 $i$ 场比赛的相关信息。其中，$p(i, 0) + p(i, 1) + p(i, 2) = 1$,，$q(i, 0) + q(i, 1) + q(i, 2) = 1$，$ q(i, j) ≠ 0$。", "outputFormat": "一个实数，表示最大的奖金期望的自然对数。\n\n$$\n\\ln \\left( \\operatorname{max}_{\\lvert R \\rvert \\le U}\\left\\{\\sum_{R_i\\in R}\\dfrac{M}{N\\cdot Q(R_i)} \\cdot P(R_i)\\right\\}\\right)\n$$\n\n输出保留 $3$ 位小数（四舍五入）。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3850", "type": "P", "difficulty": 5, "samples": [["3\nMath\nAlgorithm\nProgram\n2\nPicture 2\nSystem 1\n3\n0\n1\n3", "Math\nSystem\nPicture"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "平衡树", "枚举", "天津"], "title": "[TJOI2007] 书架", "background": null, "description": "Knuth 先生家里有个精致的书架，书架上有 $N$ 本书，如今他想学到更多的知识，于是又买来了 $M$ 本不同的新书。现在他要把新买的书依次插入到书架中，他已经把每本书要插入的位置标记好了，并且相应的将它们放好。由于 Knuth 年龄已大，过几天他已经记不清某些位置上放的到底是什么书了，请问你能帮助他吗？", "inputFormat": "输入文件的第一行为整数 $N$，接下来 $N$ 行分别是书架上依次放着的 $N$ 本书的书名（书名由不含空格的字符串构成，长度不超过 $10$）。下一行将要输入一个整数 $M$，接下来的 $M$ 行分别为这本书的书名和要插入的位置。下一行将要输入一个整数 $Q$，接下来共有 $Q$ 次询问，每行都是一个整数表示询问的位置。（书架上位置的编号从 $0$ 开始）", "outputFormat": "输出 $Q$ 行，每行对应着相应查询位置的书名。", "hint": "原来有三本书 Math、Algorithm、Program，后来又买了两本书，分别插入到 $2$ 和 $1$ 的位置，每次插入时其他书都要向后挪一个位置，最后书架上书的序列为：\n\n```plain\n0  Math\n1  System\n2  Algorithm\n3  Picture\n4  Program\n```\n$Q$ 次询问依次为 $0$, $1$, $3$ 位置的书，所以答案为：Math、System、Picture\n\n\n对于 $30\\%$ 的数据，$1 \\leqslant N \\leqslant 100$, $1 \\leqslant M \\leqslant 10^3$, $1 \\leqslant Q \\leqslant 10^3$\n\n对于 $100\\%$ 的数据，$1 \\leqslant N \\leqslant 200$, $1 \\leqslant M \\leqslant 10^5$, $1 \\leqslant Q \\leqslant 10^4$\n\n对于 $100\\%$ 的数据都符合题目中所描述的限制关系，数据保证每次插入的位置均不超过当时书架上书的数量，而且保证 $Q$ 次查询中的每个位置上一定有书。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Bookshelf", "background": "", "description": "Mr. Knuth has a delicate bookshelf with $N$ books on it. He has bought $M$ different new books to learn more. He will insert the new books into the shelf one by one; he has already marked the position for each book and placed them accordingly. As Knuth is elderly, after a few days he can no longer remember which book is at certain positions. Can you help him?", "inputFormat": "The first line contains the integer $N$. The next $N$ lines are the titles of the $N$ books currently on the shelf in order (each title is a string without spaces, with length at most $10$).  \nThe next line contains the integer $M$. The following $M$ lines each contain the title of a book and the position where it should be inserted.  \nThe next line contains the integer $Q$. Then there are $Q$ queries; each line contains an integer denoting a position to query. (Positions on the shelf are numbered from $0$.)", "outputFormat": "Output $Q$ lines. Each line contains the title of the book at the corresponding queried position.", "hint": "Originally there are three books: Math, Algorithm, Program. Later he buys two more books and inserts them at positions $2$ and $1$. Each time a book is inserted, other books shift one position to the right. The final sequence on the shelf is:\n\n```plain\n0  Math\n1  System\n2  Algorithm\n3  Picture\n4  Program\n```\n\nThe $Q$ queries ask for positions $0$, $1$, $3$, so the answers are: Math, System, Picture.\n\nConstraints:\n- For $30\\%$ of the testdata, $1 \\leqslant N \\leqslant 100$, $1 \\leqslant M \\leqslant 10^3$, $1 \\leqslant Q \\leqslant 10^3$.\n- For $100\\%$ of the testdata, $1 \\leqslant N \\leqslant 200$, $1 \\leqslant M \\leqslant 10^5$, $1 \\leqslant Q \\leqslant 10^4$.\n- For $100\\%$ of the testdata, all constraints described in the statement hold: each insertion position never exceeds the current number of books on the shelf, and every queried position always has a book.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 书架", "background": null, "description": "Knuth 先生家里有个精致的书架，书架上有 $N$ 本书，如今他想学到更多的知识，于是又买来了 $M$ 本不同的新书。现在他要把新买的书依次插入到书架中，他已经把每本书要插入的位置标记好了，并且相应的将它们放好。由于 Knuth 年龄已大，过几天他已经记不清某些位置上放的到底是什么书了，请问你能帮助他吗？", "inputFormat": "输入文件的第一行为整数 $N$，接下来 $N$ 行分别是书架上依次放着的 $N$ 本书的书名（书名由不含空格的字符串构成，长度不超过 $10$）。下一行将要输入一个整数 $M$，接下来的 $M$ 行分别为这本书的书名和要插入的位置。下一行将要输入一个整数 $Q$，接下来共有 $Q$ 次询问，每行都是一个整数表示询问的位置。（书架上位置的编号从 $0$ 开始）", "outputFormat": "输出 $Q$ 行，每行对应着相应查询位置的书名。", "hint": "原来有三本书 Math、Algorithm、Program，后来又买了两本书，分别插入到 $2$ 和 $1$ 的位置，每次插入时其他书都要向后挪一个位置，最后书架上书的序列为：\n\n```plain\n0  Math\n1  System\n2  Algorithm\n3  Picture\n4  Program\n```\n$Q$ 次询问依次为 $0$, $1$, $3$ 位置的书，所以答案为：Math、System、Picture\n\n\n对于 $30\\%$ 的数据，$1 \\leqslant N \\leqslant 100$, $1 \\leqslant M \\leqslant 10^3$, $1 \\leqslant Q \\leqslant 10^3$\n\n对于 $100\\%$ 的数据，$1 \\leqslant N \\leqslant 200$, $1 \\leqslant M \\leqslant 10^5$, $1 \\leqslant Q \\leqslant 10^4$\n\n对于 $100\\%$ 的数据都符合题目中所描述的限制关系，数据保证每次插入的位置均不超过当时书架上书的数量，而且保证 $Q$ 次查询中的每个位置上一定有书。", "locale": "zh-CN"}}}
{"pid": "P3851", "type": "P", "difficulty": 6, "samples": [["5 5\n4\n*****\n*P..*\nO**.O\n*P..*\n*****", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "网络流", "天津"], "title": "[TJOI2007] 脱险", "background": "一批探险队员正在一个迷宫一样的山洞里摸索，突然他们得到了一个糟糕的消息，由于附近发生地震，这个山洞将有可能在 $T$ 个单位时间后坍塌。现在他们要用最快的速度找出一个方案，使得在 $T$ 个单位时间内逃出的队员最多。已知探险队员在一个单位时间内可以向前后左右任一方向移动一格，也可以停留在原地不动。有一个糟糕的情况是，虽然山洞的内部比较宽敞，但山洞的出口都非常狭窄，一个单位时间只能允许一名队员通过。\n", "description": "山洞的地图用一个 $R \\times C$ 的字符矩阵表示：\n\n- `.` 表示在开始的时候没有探险队员的空地，空地可以容纳任意多的探险队员；\n- `P`表示在开始的时候有探险队员的空地，我们假设在开始的时候所有的队员都在不同的位置上，且没有队员恰好位于出口所在的方格；\n- `*` 表示障碍物，探险队员不能经过被障碍物占据的方格；\n- `O`（大写字母 `O`）表示出口，输入数据保证出口一定位于地图的边界上，即只有第 $1$ 行，第 $R$ 行，第 $1$ 列，第 $C$ 列有可能出现 `O`。\n\n另外，输入数据保证整个地图被边界和出口围住，即第 $1$ 行，第 $R$ 行，第 $1$ 列，第 $C$ 列只能是 `*` 或 `O`。\n", "inputFormat": "输入文件的第一行是用空格隔开的两个整数 $R$ 和 $C$，表示地图的大小。第二行是整数 $T$，即山洞将要坍塌的时间。接下来 $R$ 行，每行包含 $C$ 个字符，表示一幅山洞地图。\n", "outputFormat": "输出一行，包含一个整数，即 $T$ 个单位时间内最多能逃出的人数。\n", "hint": "山洞有两个出口，但只有右边的出口是可以到达的。虽然在 $3$ 个单位时间内两人都可以到达出口左侧的方格处，但由于在出口处一个单位时间只能允许一人通过，故 $4$ 个单位时间内只能逃出一人。两人都逃出需要 $5$ 个单位时间。\n\n- 对于 $30\\%$ 的数据，队员数和出口数均不超过 $10$；\n- 对于 $100\\%$ 的数据，$3 \\le R, C \\le 12，0 < T \\le 50$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Escape", "background": "A group of explorers are groping their way through a maze-like cave when they suddenly receive bad news: due to an earthquake nearby, this cave may collapse after $T$ time units. Now they must quickly find a plan that maximizes the number of explorers who can escape within $T$ time units. In one time unit, an explorer can move one cell up, down, left, or right, or stay in place. Unfortunately, although the inside of the cave is spacious, the exits are very narrow: at most one explorer can pass through an exit per time unit.", "description": "The cave map is represented by an $R \\times C$ character matrix:\n\n- `.` means an empty cell with no explorer at the beginning; an empty cell can hold any number of explorers.\n- `P` means an empty cell with an explorer at the beginning. We assume that initially all explorers are in distinct cells, and no explorer is initially on an exit cell.\n- `*` means an obstacle; explorers cannot pass through cells occupied by obstacles.\n- `O` (capital letter O) means an exit. The input guarantees that every exit lies on the boundary of the map, i.e., `O` can appear only in row $1$, row $R$, column $1$, or column $C$.\n\nAdditionally, the input guarantees that the entire map is enclosed by boundary and exits, i.e., in row $1$, row $R$, column $1$, and column $C$, only `*` or `O` may appear.", "inputFormat": "The first line contains two integers $R$ and $C$ separated by a space, denoting the size of the map. The second line contains the integer $T$, the time until the cave collapses. The next $R$ lines each contain $C$ characters, describing a cave map.", "outputFormat": "Output one line containing a single integer, the maximum number of explorers that can escape within $T$ time units.", "hint": "The cave has two exits, but only the right exit is reachable. Although in $3$ time units both people can reach the cell to the left of the exit, because at most one person can pass through the exit per time unit, only one person can escape within $4$ time units. Both can escape in $5$ time units.\n\n- For $30\\%$ of the testdata, the numbers of explorers and exits are both at most $10$.\n- For $100\\%$ of the testdata, $3 \\le R, C \\le 12$, $0 < T \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 脱险", "background": "一批探险队员正在一个迷宫一样的山洞里摸索，突然他们得到了一个糟糕的消息，由于附近发生地震，这个山洞将有可能在 $T$ 个单位时间后坍塌。现在他们要用最快的速度找出一个方案，使得在 $T$ 个单位时间内逃出的队员最多。已知探险队员在一个单位时间内可以向前后左右任一方向移动一格，也可以停留在原地不动。有一个糟糕的情况是，虽然山洞的内部比较宽敞，但山洞的出口都非常狭窄，一个单位时间只能允许一名队员通过。\n", "description": "山洞的地图用一个 $R \\times C$ 的字符矩阵表示：\n\n- `.` 表示在开始的时候没有探险队员的空地，空地可以容纳任意多的探险队员；\n- `P`表示在开始的时候有探险队员的空地，我们假设在开始的时候所有的队员都在不同的位置上，且没有队员恰好位于出口所在的方格；\n- `*` 表示障碍物，探险队员不能经过被障碍物占据的方格；\n- `O`（大写字母 `O`）表示出口，输入数据保证出口一定位于地图的边界上，即只有第 $1$ 行，第 $R$ 行，第 $1$ 列，第 $C$ 列有可能出现 `O`。\n\n另外，输入数据保证整个地图被边界和出口围住，即第 $1$ 行，第 $R$ 行，第 $1$ 列，第 $C$ 列只能是 `*` 或 `O`。\n", "inputFormat": "输入文件的第一行是用空格隔开的两个整数 $R$ 和 $C$，表示地图的大小。第二行是整数 $T$，即山洞将要坍塌的时间。接下来 $R$ 行，每行包含 $C$ 个字符，表示一幅山洞地图。\n", "outputFormat": "输出一行，包含一个整数，即 $T$ 个单位时间内最多能逃出的人数。\n", "hint": "山洞有两个出口，但只有右边的出口是可以到达的。虽然在 $3$ 个单位时间内两人都可以到达出口左侧的方格处，但由于在出口处一个单位时间只能允许一人通过，故 $4$ 个单位时间内只能逃出一人。两人都逃出需要 $5$ 个单位时间。\n\n- 对于 $30\\%$ 的数据，队员数和出口数均不超过 $10$；\n- 对于 $100\\%$ 的数据，$3 \\le R, C \\le 12，0 < T \\le 50$。\n", "locale": "zh-CN"}}}
{"pid": "P3852", "type": "P", "difficulty": 6, "samples": [["5 6\n1 2\n3 2\n1 3\n3 5\n3 4\n4 5", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "天津", "弦图"], "title": "[TJOI2007] 小朋友", "background": "幼儿园里有N个小朋友，老师要从中选出来一部分做丢手绢的游戏，可是老师没有想到这么小的孩子里面有些人之间还有矛盾。老师想找出尽量多的小朋友去玩游戏，但是又很头疼，他不想看到找出来玩游戏的小朋友里面还有任何两个人之间存在着矛盾。如果告诉你小朋友之间存在的M对矛盾关系，你能否帮助幼儿园老师计算出他最多可以选出多少个小朋友来做这个丢手绢的游戏？\n", "description": "关于矛盾限制的说明：\n\n如果我们把存在着矛盾的两个小朋友看作是无向图中相连的两个点，那么题目中的数据保证M对矛盾所构成的图中不会有超过3个点的环。（图1符合要求，图2则不符合）\n\n![](https://cdn.luogu.com.cn/upload/pic/6098.png)\n", "inputFormat": "输入文件的第一行是用空格隔开的两个整数N和M，表示一共有N个小朋友，这些小朋友之间有M对矛盾关系。接下来的M行，每行将有一对整数a和b（用空格隔开），表示小朋友a与小朋友b有矛盾。（小朋友的编号都是从1开始的）\n", "outputFormat": "输出一行，包含一个整数，即幼儿园老师最多可以选出来做游戏的人数。\n", "hint": "幼儿园有6个小朋友，矛盾关系中1 - 2 - 3组成一个环，3 - 4 - 5组成一个环，因此只能在这两个环中分别选一个小朋友，并且不能选择3号小朋友。\n\n    \n对于20%的数据，1 ≤ N ≤ 20\n\n对于40%的数据，1 ≤ N ≤ 50\n\n对于100%的数据，1 ≤ N ≤ 200\n\n对于100%的数据都符合题目中所描述的矛盾限制关系。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Children", "background": "There are $N$ children in a kindergarten. The teacher wants to select some of them to play a \"drop the handkerchief\" game. However, the teacher did not expect that even among such young children, some pairs have conflicts. The teacher wants to include as many children as possible in the game, but he is troubled because he does not want any two selected children to have a conflict. Given $M$ pairs of conflicts among the children, can you help the teacher compute the maximum number of children he can select for this game?", "description": "Explanation of the conflict constraint:\n\nIf we regard any two conflicting children as two adjacent vertices in an undirected graph, the testdata guarantees that the graph formed by the $M$ conflicting pairs contains no cycle with more than 3 vertices. (Figure 1 satisfies the requirement, while Figure 2 does not.)\n\n![](https://cdn.luogu.com.cn/upload/pic/6098.png)", "inputFormat": "The first line contains two integers $N$ and $M$ separated by a space, indicating there are $N$ children and $M$ pairs of conflicts. Each of the next $M$ lines contains two integers $a$ and $b$ (separated by a space), meaning that child $a$ and child $b$ have a conflict. (Children are numbered starting from $1$.)", "outputFormat": "Output one line containing a single integer — the maximum number of children the teacher can select to play the game.", "hint": "There are 6 children. The conflicts contain a cycle $1 - 2 - 3$ and another cycle $3 - 4 - 5$. Therefore, you can select exactly one child from each of these two cycles, and child $3$ cannot be selected.\n\nConstraints:\n- For $20\\%$ of the testdata, $1 \\le N \\le 20$.\n- For $40\\%$ of the testdata, $1 \\le N \\le 50$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 200$.\n- All $100\\%$ of the testdata satisfy the conflict constraint described in the problem.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 小朋友", "background": "幼儿园里有N个小朋友，老师要从中选出来一部分做丢手绢的游戏，可是老师没有想到这么小的孩子里面有些人之间还有矛盾。老师想找出尽量多的小朋友去玩游戏，但是又很头疼，他不想看到找出来玩游戏的小朋友里面还有任何两个人之间存在着矛盾。如果告诉你小朋友之间存在的M对矛盾关系，你能否帮助幼儿园老师计算出他最多可以选出多少个小朋友来做这个丢手绢的游戏？\n", "description": "关于矛盾限制的说明：\n\n如果我们把存在着矛盾的两个小朋友看作是无向图中相连的两个点，那么题目中的数据保证M对矛盾所构成的图中不会有超过3个点的环。（图1符合要求，图2则不符合）\n\n![](https://cdn.luogu.com.cn/upload/pic/6098.png)\n", "inputFormat": "输入文件的第一行是用空格隔开的两个整数N和M，表示一共有N个小朋友，这些小朋友之间有M对矛盾关系。接下来的M行，每行将有一对整数a和b（用空格隔开），表示小朋友a与小朋友b有矛盾。（小朋友的编号都是从1开始的）\n", "outputFormat": "输出一行，包含一个整数，即幼儿园老师最多可以选出来做游戏的人数。\n", "hint": "幼儿园有6个小朋友，矛盾关系中1 - 2 - 3组成一个环，3 - 4 - 5组成一个环，因此只能在这两个环中分别选一个小朋友，并且不能选择3号小朋友。\n\n    \n对于20%的数据，1 ≤ N ≤ 20\n\n对于40%的数据，1 ≤ N ≤ 50\n\n对于100%的数据，1 ≤ N ≤ 200\n\n对于100%的数据都符合题目中所描述的矛盾限制关系。\n", "locale": "zh-CN"}}}
{"pid": "P3853", "type": "P", "difficulty": 3, "samples": [["101 2 1\n0 101", "51"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "搜索", "2007", "二分", "各省省选", "天津"], "title": "[TJOI2007] 路标设置", "background": "B 市和 T 市之间有一条长长的高速公路，这条公路的某些地方设有路标，但是大家都感觉路标设得太少了，相邻两个路标之间往往隔着相当长的一段距离。为了便于研究这个问题，我们把公路上相邻路标的最大距离定义为该公路的“空旷指数”。\n", "description": "现在政府决定在公路上增设一些路标，使得公路的“空旷指数”最小。他们请求你设计一个程序计算能达到的最小值是多少。请注意，公路的起点和终点保证已设有路标，公路的长度为整数，并且原有路标和新设路标都必须距起点整数个单位距离。\n", "inputFormat": "第 $1$ 行包括三个数 $L,N,K$，分别表示公路的长度，原有路标的数量，以及最多可增设的路标数量。\n\n\n第 $2$ 行包括递增排列的 $N$ 个整数，分别表示原有的 $N$ 个路标的位置。路标的位置用距起点的距离表示，且一定位于区间 $[0,L]$ 内。\n", "outputFormat": "输出 $1$ 行，包含一个整数，表示增设路标后能达到的最小“空旷指数”值。\n", "hint": "公路原来只在起点和终点处有两个路标，现在允许新增一个路标，应该把新路标设在距起点 $50$ 或 $51$ 个单位距离处，这样能达到最小的空旷指数 $51$。\n\n$50\\%$ 的数据中，$2 \\leq N \\leq 100$，$0 \\leq K \\leq 100$。\n\n$100\\%$ 的数据中，$2 \\leq N \\leq 100000$, $0 \\leq K \\leq100000$。\n\n$100\\%$ 的数据中，$0 < L \\leq 10000000$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2007] Road Sign Placement", "background": "There is a long highway between city B and city T. Some places along this highway have signposts, but everyone feels there are too few; adjacent signposts are often separated by a rather long distance. To study this problem, we define the maximum distance between adjacent signposts on the highway as the highway’s \"emptiness index\".", "description": "Now the government plans to add some signposts on the highway to minimize the highway’s \"emptiness index\". They ask you to design a program to compute the minimum achievable value. Note that the start and the end of the highway are guaranteed to already have signposts, the highway length is an integer, and both existing and newly added signposts must be at integer distances from the start.", "inputFormat": "The first line contains three integers $L,N,K$, representing the highway length, the number of existing signposts, and the maximum number of signposts that can be added, respectively.\n\nThe second line contains $N$ integers in increasing order, representing the positions of the existing $N$ signposts. Each position is the distance from the start and lies within the interval $[0,L]$.", "outputFormat": "Output one line containing a single integer, the minimum \"emptiness index\" achievable after adding signposts.", "hint": "Originally, the highway had only two signposts at the start and the end. Now you are allowed to add one signpost. You should place the new signpost at a distance of $50$ or $51$ from the start, which yields the minimum emptiness index of $51$.\n\nConstraints:\n- In $50\\%$ of the testdata, $2 \\leq N \\leq 100$, $0 \\leq K \\leq 100$.\n- In $100\\%$ of the testdata, $2 \\leq N \\leq 100000$, $0 \\leq K \\leq 100000$.\n- In $100\\%$ of the testdata, $0 < L \\leq 10000000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2007] 路标设置", "background": "B 市和 T 市之间有一条长长的高速公路，这条公路的某些地方设有路标，但是大家都感觉路标设得太少了，相邻两个路标之间往往隔着相当长的一段距离。为了便于研究这个问题，我们把公路上相邻路标的最大距离定义为该公路的“空旷指数”。\n", "description": "现在政府决定在公路上增设一些路标，使得公路的“空旷指数”最小。他们请求你设计一个程序计算能达到的最小值是多少。请注意，公路的起点和终点保证已设有路标，公路的长度为整数，并且原有路标和新设路标都必须距起点整数个单位距离。\n", "inputFormat": "第 $1$ 行包括三个数 $L,N,K$，分别表示公路的长度，原有路标的数量，以及最多可增设的路标数量。\n\n\n第 $2$ 行包括递增排列的 $N$ 个整数，分别表示原有的 $N$ 个路标的位置。路标的位置用距起点的距离表示，且一定位于区间 $[0,L]$ 内。\n", "outputFormat": "输出 $1$ 行，包含一个整数，表示增设路标后能达到的最小“空旷指数”值。\n", "hint": "公路原来只在起点和终点处有两个路标，现在允许新增一个路标，应该把新路标设在距起点 $50$ 或 $51$ 个单位距离处，这样能达到最小的空旷指数 $51$。\n\n$50\\%$ 的数据中，$2 \\leq N \\leq 100$，$0 \\leq K \\leq 100$。\n\n$100\\%$ 的数据中，$2 \\leq N \\leq 100000$, $0 \\leq K \\leq100000$。\n\n$100\\%$ 的数据中，$0 < L \\leq 10000000$。", "locale": "zh-CN"}}}
{"pid": "P3854", "type": "P", "difficulty": 5, "samples": [["5 6\n1 2\n1 3\n2 3\n3 4\n3 5\n4 5\n3\n1 5 3\n1 5 4\n4 5 3\n", "yes\nno\nno\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "分治", "Tarjan", "最近公共祖先 LCA", "天津", "圆方树", "线段树分治"], "title": "[TJOI2008] 通讯网破坏", "background": "由于争夺资源引起的矛盾冲突，$A$ 国和 $B$ 国进入了战争一触即发的状态。现在 $A$ 国的间谍机构设法得到了 $B$ 国的通讯网络布置情况，其中每个城市可以看作一个点，在某些点之间有无向边，表示这些城市之间可以进行双向的直接通讯。$A$ 国打算先发制人，通过核武器毁灭某个中间城市 $M$，一举切断B国某两个重要城市 $S$ , $T$ 之间的联系，即从图中删除掉 $M$ 点之后，$S$ 和 $T$ 变得不连通。但是由于 $B$ 国的防御力量也很强大，这样的核打击只能成功进行一次且只能毁灭一个城市。\n", "description": "现在 $A$ 国的首脑提出了很多种作战策略，作为 $A$ 国的首席计算机科学家，你的任务是编写一个程序决定这些策略可行与否。\n", "inputFormat": "输入文件的第一行为两个整数 $N$ 和 $M$，表示 $B$ 国的城市数和可以直接通讯的城市对数目。接下来的 $M$ 行，每行包括两个整数 $C_i$ 和 $D_i$，$1\\leq C_i,D_i \\leq N$ 且 $C_i \\neq D_i$，表示城市 $C_i$ 和 $D_i$ 之间可以直接通讯。输入数据保证每对 $(C_i,D_i)$ 最多出现一次。\n\n接下来一行是一个整数 $Q$，表示 $A$ 国首脑作出的策略数。接下来的 $Q$ 行，每行包括三个整数 $S_i,T_i,M_i$（$1 \\leq S_i,T_i,M_i\\leq N$，且 $M_i,S_i,T_i$ 三个数互不相等）表示这个策略的内容是通过毁灭 $M_i$ 来切断 $S_i$ 和 $T_i$ 之间的联系。\n", "outputFormat": "输出 $Q$ 行，表示对应的策略可行与否。如果毁灭 $M_i$ 以后，$S_i$ 和 $T_i$ 之间不能通讯，说明此策略可行，则应在第 $i$ 行输出 $\\mathtt{yes}$，否则输出 $\\mathtt{no}$。\n", "hint": "对于 $30\\%$ 的数据，$1 \\leq N \\leq 100,1 \\leq Q \\leq 100$。\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 20000,1\\leq M\\leq 100000,1 \\leq Q \\leq 100000$。\n\n输入数据保证原图的任意两点是连通的。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2008] Communication Network Destruction", "background": "Due to conflicts over resources, countries $A$ and $B$ are on the verge of war. Country $A$'s intelligence agency has obtained the layout of country $B$'s communication network, where each city is a vertex, and some pairs of vertices are connected by undirected edges, indicating direct bidirectional communication between those cities. Country $A$ plans to strike first by destroying an intermediate city $M$ with nuclear weapons to sever the connection between two important cities $S$ and $T$ in country $B$. That is, after removing vertex $M$ from the graph, $S$ and $T$ become disconnected. However, since country $B$'s defenses are strong, such a nuclear strike can succeed only once and can destroy only one city.", "description": "The leaders of country $A$ have proposed many strategies. As the chief computer scientist of country $A$, your task is to write a program to determine whether each strategy is feasible.", "inputFormat": "The first line contains two integers $N$ and $M$, representing the number of cities in country $B$ and the number of pairs of cities that can communicate directly. The next $M$ lines each contain two integers $C_i$ and $D_i$, $1\\leq C_i,D_i \\leq N$ and $C_i \\neq D_i$, indicating that cities $C_i$ and $D_i$ can communicate directly. It is guaranteed that each pair $(C_i,D_i)$ appears at most once.\n\nThe next line contains an integer $Q$, representing the number of strategies proposed by the leaders of country $A$. The next $Q$ lines each contain three integers $S_i, T_i, M_i$ ($1 \\leq S_i,T_i,M_i\\leq N$, and $M_i, S_i, T_i$ are pairwise distinct), indicating that this strategy attempts to sever communication between $S_i$ and $T_i$ by destroying $M_i$.", "outputFormat": "Output $Q$ lines, each indicating whether the corresponding strategy is feasible. If, after destroying $M_i$, $S_i$ and $T_i$ cannot communicate, then the strategy is feasible and you should output $\\mathtt{yes}$ on the $i$-th line; otherwise, output $\\mathtt{no}$.", "hint": "For $30\\%$ of the testdata, $1 \\leq N \\leq 100,1 \\leq Q \\leq 100$.\n\nFor $100\\%$ of the testdata, $1 \\leq N \\leq 20000,1\\leq M\\leq 100000,1 \\leq Q \\leq 100000$.\n\nIt is guaranteed that the original graph is connected.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2008] 通讯网破坏", "background": "由于争夺资源引起的矛盾冲突，$A$ 国和 $B$ 国进入了战争一触即发的状态。现在 $A$ 国的间谍机构设法得到了 $B$ 国的通讯网络布置情况，其中每个城市可以看作一个点，在某些点之间有无向边，表示这些城市之间可以进行双向的直接通讯。$A$ 国打算先发制人，通过核武器毁灭某个中间城市 $M$，一举切断B国某两个重要城市 $S$ , $T$ 之间的联系，即从图中删除掉 $M$ 点之后，$S$ 和 $T$ 变得不连通。但是由于 $B$ 国的防御力量也很强大，这样的核打击只能成功进行一次且只能毁灭一个城市。\n", "description": "现在 $A$ 国的首脑提出了很多种作战策略，作为 $A$ 国的首席计算机科学家，你的任务是编写一个程序决定这些策略可行与否。\n", "inputFormat": "输入文件的第一行为两个整数 $N$ 和 $M$，表示 $B$ 国的城市数和可以直接通讯的城市对数目。接下来的 $M$ 行，每行包括两个整数 $C_i$ 和 $D_i$，$1\\leq C_i,D_i \\leq N$ 且 $C_i \\neq D_i$，表示城市 $C_i$ 和 $D_i$ 之间可以直接通讯。输入数据保证每对 $(C_i,D_i)$ 最多出现一次。\n\n接下来一行是一个整数 $Q$，表示 $A$ 国首脑作出的策略数。接下来的 $Q$ 行，每行包括三个整数 $S_i,T_i,M_i$（$1 \\leq S_i,T_i,M_i\\leq N$，且 $M_i,S_i,T_i$ 三个数互不相等）表示这个策略的内容是通过毁灭 $M_i$ 来切断 $S_i$ 和 $T_i$ 之间的联系。\n", "outputFormat": "输出 $Q$ 行，表示对应的策略可行与否。如果毁灭 $M_i$ 以后，$S_i$ 和 $T_i$ 之间不能通讯，说明此策略可行，则应在第 $i$ 行输出 $\\mathtt{yes}$，否则输出 $\\mathtt{no}$。\n", "hint": "对于 $30\\%$ 的数据，$1 \\leq N \\leq 100,1 \\leq Q \\leq 100$。\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 20000,1\\leq M\\leq 100000,1 \\leq Q \\leq 100000$。\n\n输入数据保证原图的任意两点是连通的。\n", "locale": "zh-CN"}}}
{"pid": "P3855", "type": "P", "difficulty": 4, "samples": [["4 7\n#######\n#..T..#\n#G##M##\n#######\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2008", "各省省选", "广度优先搜索 BFS", "天津"], "title": "[TJOI2008] Binary Land", "background": "Binary Land是一款任天堂红白机上的经典游戏，讲述的是两只相爱的企鹅Gurin和Malon的故事。两只企鹅在一个封闭的迷宫中，你可以控制他们向上下左右四个方向移动。但是他们的移动有一个奇怪的规则，即如果你按“上”或“下”方向键，两只企鹅会同时向上移动或向下移动1格；如果你按“左”方向键，则Malon向左移动1格，同时Gurin向右移动1格；如果你按“右”方向键，则Malon向右移动1格，Gurin向左移动1格。当然，如果某只企鹅被障碍挡住，它就不会移动了。另外，在迷宫的某些格子处有蜘蛛网，如果任何一只企鹅进入这种格子，则游戏失败。两只企鹅不会相互阻挡，即在相向运动时他们可以“穿过”彼此，也可以同时处于同一格子里。迷宫的某个格子上有一颗红心，游戏的任务就是使两只企鹅同时到达这个格子。\n\n![](https://cdn.luogu.com.cn/upload/pic/6099.png)\n", "description": "请编写程序找出完成任务所需的最少的操作步数。如果无法完成目标，输出“no”。\n", "inputFormat": "第一行包含两个整数R, C 表示迷宫的长和宽。\n\n按下来有R行，每行包含C个字符，描述了一个迷宫。其中’#’表示企鹅不能通过的障碍物，’X’表示蜘蛛网，’.’表示空地，’G’表示Gurin的初始位置，’M’表示Malon的初始位置，’T’表示终点位置。\n\n输入数据保证标有’G’,’M’,’T’的格子分别只有一个，保证企鹅不可能走到迷宫以外。\n", "outputFormat": "输出只有一行，为最少的操作步数。如果不能完成任务，输出“no”。\n", "hint": "满足要求的一个操作序列为：上－右－左－左\n\n3 ≤ R, C ≤ 30\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2008] Binary Land", "background": "Binary Land is a classic game on the Nintendo Famicom. It tells the story of two penguins in love, Gurin and Malon. The two penguins are in a closed maze, and you can move them in the four directions: up, down, left, and right. However, there is a strange rule for their movement: if you press \"Up\" or \"Down\", both penguins move up or down by 1 cell at the same time; if you press \"Left\", then Malon moves left by 1 cell while Gurin moves right by 1 cell; if you press \"Right\", then Malon moves right by 1 cell while Gurin moves left by 1 cell. Of course, if a penguin is blocked by an obstacle, it will not move. In addition, some cells in the maze contain spider webs; if either penguin enters such a cell, the game fails. The two penguins do not block each other: when moving toward each other they can \"pass through\" one another and may also occupy the same cell at the same time. One cell of the maze has a heart; the goal is to make both penguins reach this cell simultaneously.\n\n![](https://cdn.luogu.com.cn/upload/pic/6099.png)", "description": "Write a program to find the minimum number of moves required to complete the task. If it is impossible, output \"no\".", "inputFormat": "The first line contains two integers R, C, the number of rows and columns of the maze.\n\nThen follow R lines, each containing C characters that describe the maze. '#' denotes an obstacle the penguins cannot pass, 'X' denotes a spider web, '.' denotes empty ground, 'G' denotes Gurin's initial position, 'M' denotes Malon's initial position, and 'T' denotes the target position.\n\nIt is guaranteed that there is exactly one cell labeled 'G', 'M', and 'T', respectively, and that the penguins can never move outside the maze.", "outputFormat": "Output a single line with the minimum number of moves. If the goal cannot be achieved, output \"no\".", "hint": "One valid sequence of moves is: Up-Right-Left-Left.\n\n3 ≤ R, C ≤ 30.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2008] Binary Land", "background": "Binary Land是一款任天堂红白机上的经典游戏，讲述的是两只相爱的企鹅Gurin和Malon的故事。两只企鹅在一个封闭的迷宫中，你可以控制他们向上下左右四个方向移动。但是他们的移动有一个奇怪的规则，即如果你按“上”或“下”方向键，两只企鹅会同时向上移动或向下移动1格；如果你按“左”方向键，则Malon向左移动1格，同时Gurin向右移动1格；如果你按“右”方向键，则Malon向右移动1格，Gurin向左移动1格。当然，如果某只企鹅被障碍挡住，它就不会移动了。另外，在迷宫的某些格子处有蜘蛛网，如果任何一只企鹅进入这种格子，则游戏失败。两只企鹅不会相互阻挡，即在相向运动时他们可以“穿过”彼此，也可以同时处于同一格子里。迷宫的某个格子上有一颗红心，游戏的任务就是使两只企鹅同时到达这个格子。\n\n![](https://cdn.luogu.com.cn/upload/pic/6099.png)\n", "description": "请编写程序找出完成任务所需的最少的操作步数。如果无法完成目标，输出“no”。\n", "inputFormat": "第一行包含两个整数R, C 表示迷宫的长和宽。\n\n按下来有R行，每行包含C个字符，描述了一个迷宫。其中’#’表示企鹅不能通过的障碍物，’X’表示蜘蛛网，’.’表示空地，’G’表示Gurin的初始位置，’M’表示Malon的初始位置，’T’表示终点位置。\n\n输入数据保证标有’G’,’M’,’T’的格子分别只有一个，保证企鹅不可能走到迷宫以外。\n", "outputFormat": "输出只有一行，为最少的操作步数。如果不能完成任务，输出“no”。\n", "hint": "满足要求的一个操作序列为：上－右－左－左\n\n3 ≤ R, C ≤ 30\n", "locale": "zh-CN"}}}
{"pid": "P3856", "type": "P", "difficulty": 6, "samples": [["apartment\napache\napproach\n", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "各省省选", "枚举", "天津"], "title": "[TJOI2008] 公共子串", "background": "", "description": "一个字符串的子串是在这个串基础上去掉0个或者若干个字符所形成的，例如abc, aa和abbc都是字符串aabbcc的子串，而aba不是。 现给你三个字符串，请问他们三个共同含有多少种子串（不算空串）?\n\n注意： 有些相同的公共子串尽管出现在不同的位置，但仍算1种，详见样例。\n", "inputFormat": "每组测试数据只有3行，每行都是一个只包含有小写字母的字符串。\n", "outputFormat": "输出3个字符串共有的公共子串种类数。\n", "hint": "3个字符串共有的公共子串有： “a”, “p”, “ap”, “pa”, “aa”, “apa”。 其中子串 “a” 有多个，但由于统计的是公共子串种类，所以 “a” 只算1种子串。\n\n\n100%的数据中，字符串的长度不超过100。字符串中只含有小写字母。\n\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2008] Common Substrings", "background": "", "description": "A substring of a string is a contiguous block of characters. For example, for the string aabbcc, aa and abbc are substrings, while abc and aba are not. Now, given three strings, how many distinct substrings do all three of them contain in common (excluding the empty string)?\n\nNote: Even if the same common substring appears at different positions, it still counts as 1 kind only. See the example.", "inputFormat": "Each test case consists of 3 lines. Each line is a string containing only lowercase letters.", "outputFormat": "Output the number of distinct substrings common to the 3 strings.", "hint": "The substrings common to the 3 strings are: \"a\", \"p\", \"ap\", \"pa\", \"aa\", \"apa\". Among them, the substring \"a\" occurs multiple times, but since we count kinds of common substrings, \"a\" counts as only 1 kind.\n\nIn 100% of the testdata, the length of each string does not exceed 100. Each string contains only lowercase letters.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2008] 公共子串", "background": "", "description": "一个字符串的子串是在这个串基础上去掉0个或者若干个字符所形成的，例如abc, aa和abbc都是字符串aabbcc的子串，而aba不是。 现给你三个字符串，请问他们三个共同含有多少种子串（不算空串）?\n\n注意： 有些相同的公共子串尽管出现在不同的位置，但仍算1种，详见样例。\n", "inputFormat": "每组测试数据只有3行，每行都是一个只包含有小写字母的字符串。\n", "outputFormat": "输出3个字符串共有的公共子串种类数。\n", "hint": "3个字符串共有的公共子串有： “a”, “p”, “ap”, “pa”, “aa”, “apa”。 其中子串 “a” 有多个，但由于统计的是公共子串种类，所以 “a” 只算1种子串。\n\n\n100%的数据中，字符串的长度不超过100。字符串中只含有小写字母。\n\n\n", "locale": "zh-CN"}}}
{"pid": "P3857", "type": "P", "difficulty": 5, "samples": [["2 3\nOO\nXO\nOX\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "进制", "线性基", "构造", "天津"], "title": "[TJOI2008] 彩灯", "background": "", "description": "Peter 女朋友的生日快到了，他亲自设计了一组彩灯，想给女朋友一个惊喜。已知一组彩灯是由一排 $N$ 个独立的灯泡构成的，并且有 $M$ 个开关控制它们。从数学的角度看，这一排彩灯的任何一个彩灯只有亮与不亮两个状态，所以共有 $2^N$ 个样式。由于技术上的问题，Peter 设计的每个开关控制的彩灯没有什么规律，当一个开关被按下的时候，它会把所有它控制的彩灯改变状态（即亮变成不亮，不亮变成亮）。假如告诉你他设计的每个开关所控制的彩灯范围，你能否帮他计算出这些彩灯有多少种样式可以展示给他的女朋友？\n\n注： 开始时所有彩灯都是不亮的状态。", "inputFormat": "每组测试数据第一行为两个整数 $N$ 和 $M$，用空格隔开。紧接着是有 $M$ 行，每行都是一个长度为 $N$ 的字符串，表示一个开关控制彩灯的范围（$N$ 盏灯），如果第 $i$ 个字母是大写字母 `O`，则表示这个开关控制第 $i$ 盏灯，如果第 $i$ 个字母是大写字母 `X`，则表示这个开关不控制此灯。", "outputFormat": "输出这些开关和彩灯可以变换出来的样式数目。由于这个值可能会很大，请求出它对于整数 $2008$ 的余数。", "hint": "可见样例中第一个开关控制了所有的彩灯，而后两个开关分别控制了第一个和第二个彩灯，这样我们可以只用后两个开关控制彩灯，可以变换出来所有的 $2^2$ 个状态。\n\n对于 $30\\%$ 的数据，$N$ 和 $M$ 不超过 $15$。\n\n另外有 $40\\%$ 的数据，$N$ 和 $M$ 有一个为 $50$。\n\n对于 $100\\%$ 的数据，$N$ 和 $M$ 不超过 $50$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2008] Colored Lights", "background": "Peter’s girlfriend’s birthday is coming, and he designed a set of colored lights as a surprise. A set consists of a row of $N$ independent bulbs, controlled by $M$ switches. Mathematically, each bulb has exactly two states, on or off, so there are $2^N$ possible patterns. Due to technical reasons, the bulbs controlled by each switch have no particular pattern: when a switch is pressed, it toggles the state of every bulb it controls (on becomes off, off becomes on). Given the set of bulbs each switch controls, can you compute how many distinct lighting patterns can be displayed?\n\nNote: Initially, all bulbs are off.", "description": "", "inputFormat": "", "outputFormat": "Output the number of distinct patterns obtainable by these switches and bulbs. Since this number can be large, output it modulo the integer $2008$.", "hint": "As seen in the sample, the first switch controls all bulbs, while the next two switches control the first and second bulbs respectively. In this case, using only the latter two switches suffices to obtain all $2^2$ states.\n\nConstraints:\n- For $30\\%$ of the testdata, $N$ and $M$ do not exceed $15$.\n- Additionally, for $40\\%$ of the testdata, one of $N$ and $M$ equals $50$.\n- For $100\\%$ of the testdata, $N$ and $M$ do not exceed $50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2008] 彩灯", "background": "", "description": "Peter 女朋友的生日快到了，他亲自设计了一组彩灯，想给女朋友一个惊喜。已知一组彩灯是由一排 $N$ 个独立的灯泡构成的，并且有 $M$ 个开关控制它们。从数学的角度看，这一排彩灯的任何一个彩灯只有亮与不亮两个状态，所以共有 $2^N$ 个样式。由于技术上的问题，Peter 设计的每个开关控制的彩灯没有什么规律，当一个开关被按下的时候，它会把所有它控制的彩灯改变状态（即亮变成不亮，不亮变成亮）。假如告诉你他设计的每个开关所控制的彩灯范围，你能否帮他计算出这些彩灯有多少种样式可以展示给他的女朋友？\n\n注： 开始时所有彩灯都是不亮的状态。", "inputFormat": "每组测试数据第一行为两个整数 $N$ 和 $M$，用空格隔开。紧接着是有 $M$ 行，每行都是一个长度为 $N$ 的字符串，表示一个开关控制彩灯的范围（$N$ 盏灯），如果第 $i$ 个字母是大写字母 `O`，则表示这个开关控制第 $i$ 盏灯，如果第 $i$ 个字母是大写字母 `X`，则表示这个开关不控制此灯。", "outputFormat": "输出这些开关和彩灯可以变换出来的样式数目。由于这个值可能会很大，请求出它对于整数 $2008$ 的余数。", "hint": "可见样例中第一个开关控制了所有的彩灯，而后两个开关分别控制了第一个和第二个彩灯，这样我们可以只用后两个开关控制彩灯，可以变换出来所有的 $2^2$ 个状态。\n\n对于 $30\\%$ 的数据，$N$ 和 $M$ 不超过 $15$。\n\n另外有 $40\\%$ 的数据，$N$ 和 $M$ 有一个为 $50$。\n\n对于 $100\\%$ 的数据，$N$ 和 $M$ 不超过 $50$。", "locale": "zh-CN"}}}
{"pid": "P3858", "type": "P", "difficulty": 7, "samples": [["2\n2 2 3\n...\nX.X\n\nX.X\nXXX\n2 2 3\n.X.\n.X.\n\n.X.\n.X.\n", "yes\nno\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "天津"], "title": "[TJOI2008] 贪吃蛇", "background": "佳佳和金明在玩一个新版的对战型贪吃蛇游戏：在一个长方体中，某些格子是障碍物，其余的格子里都有食物。佳佳把贪吃蛇放到其中一个有食物的格子中，然后金明控制贪吃蛇移动一步到相邻的有食物的格子中，然后佳佳再控制它移动一步，就这样双方轮流进行下去。要注意的是移动的时候只能向上下左右前后的六个方向之一移动，且不能走出长方体的边界（当然，有障碍物的格子也是不能走的）。并且游戏要求贪吃蛇每步都必须能吃到新的食物，即不能走回以前经过的格子（包括起点也不能走回）。游戏进行到某方不能再按照上述规则移动蛇时，这一方就输掉了。\n", "description": "佳佳和金明都是十分聪明的孩子，他们在游戏中总是会选择对自己最有利的策略。因为贪吃蛇的初始位置是由佳佳指定的，现在佳佳想知道，能不能找到这样一个初始位置使得自己一定可以获胜呢？\n", "inputFormat": "输入文件的第一行包含一个整数N，表示此文件包含的测试样例数。接下来就是N组样例的描述。\n\n每组样例描述的第一行包含三个整数H,R,C，表示长方体的高度，长度和宽度。接下来是H个R行C列的矩阵，每个矩阵描述此长方体的一层。矩阵包含的字符只有’.’和’X’两种，其中’.’表示初始时有食物的格子，’X’表示障碍。这H个矩阵描述之间都用一个空行隔开。\n", "outputFormat": "输出N行，表示对应的游戏中佳佳是不是一定可以获胜。如果佳佳可以获胜，输出“yes”，否则输出“no”。\n", "hint": "对于40%的数据，H \\* R \\* C ≤ 16\n\n对于100%的数据，H \\* R \\* C ≤ 100,  N ≤ 10\n\n输入数据保证每个长方体至少包含一个不是障碍物的格子。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2008] Snake", "background": "Jiajia and Jinming are playing a new competitive version of the Snake game in a rectangular prism. Some cells are obstacles, and every other cell initially contains food. Jiajia places the snake on a cell that has food. Then Jinming moves the snake one step to an adjacent cell that has food; then Jiajia moves it one step; they alternate in this way. A move may go only in one of the six directions: up, down, left, right, front, or back. The snake cannot leave the rectangular prism or enter an obstacle cell. Moreover, every move must eat new food: the snake may not revisit any previously visited cell, including the starting cell. When a player can no longer move the snake under these rules, that player loses.", "description": "Jiajia and Jinming are very smart and always play optimally. Since the snake’s starting position is chosen by Jiajia, she wants to know whether she can pick a starting cell that guarantees her a win.", "inputFormat": "The first line contains an integer N, the number of test cases. Each test case begins with a line containing three integers H, R, and C, denoting the height, length, and width of the rectangular prism. Then follow H matrices of R rows and C columns; each matrix describes one layer of the prism. Each matrix contains only the characters '.' and 'X', where '.' means a cell initially with food and 'X' means an obstacle. The H layer descriptions are separated by a blank line.", "outputFormat": "Output N lines, each indicating whether Jiajia can guarantee a win in the corresponding game. Output \"yes\" if she can, otherwise output \"no\".", "hint": "- For 40% of the testdata, $H \\times R \\times C \\le 16$.\n- For 100% of the testdata, $H \\times R \\times C \\le 100$, $N \\le 10$.\n- The input guarantees that each rectangular prism contains at least one cell that is not an obstacle.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2008] 贪吃蛇", "background": "佳佳和金明在玩一个新版的对战型贪吃蛇游戏：在一个长方体中，某些格子是障碍物，其余的格子里都有食物。佳佳把贪吃蛇放到其中一个有食物的格子中，然后金明控制贪吃蛇移动一步到相邻的有食物的格子中，然后佳佳再控制它移动一步，就这样双方轮流进行下去。要注意的是移动的时候只能向上下左右前后的六个方向之一移动，且不能走出长方体的边界（当然，有障碍物的格子也是不能走的）。并且游戏要求贪吃蛇每步都必须能吃到新的食物，即不能走回以前经过的格子（包括起点也不能走回）。游戏进行到某方不能再按照上述规则移动蛇时，这一方就输掉了。\n", "description": "佳佳和金明都是十分聪明的孩子，他们在游戏中总是会选择对自己最有利的策略。因为贪吃蛇的初始位置是由佳佳指定的，现在佳佳想知道，能不能找到这样一个初始位置使得自己一定可以获胜呢？\n", "inputFormat": "输入文件的第一行包含一个整数N，表示此文件包含的测试样例数。接下来就是N组样例的描述。\n\n每组样例描述的第一行包含三个整数H,R,C，表示长方体的高度，长度和宽度。接下来是H个R行C列的矩阵，每个矩阵描述此长方体的一层。矩阵包含的字符只有’.’和’X’两种，其中’.’表示初始时有食物的格子，’X’表示障碍。这H个矩阵描述之间都用一个空行隔开。\n", "outputFormat": "输出N行，表示对应的游戏中佳佳是不是一定可以获胜。如果佳佳可以获胜，输出“yes”，否则输出“no”。\n", "hint": "对于40%的数据，H \\* R \\* C ≤ 16\n\n对于100%的数据，H \\* R \\* C ≤ 100,  N ≤ 10\n\n输入数据保证每个长方体至少包含一个不是障碍物的格子。\n", "locale": "zh-CN"}}}
{"pid": "P3859", "type": "P", "difficulty": 3, "samples": [["3 4\n9 5 5\n0 1 2\n1 2 2\n2 3 2\n2 5 3\n", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "各省省选", "背包 DP", "天津"], "title": "[TJOI2008] 小偷", "background": "一位著名的小偷进入了一个充满宝石的储藏室，这个储藏室是由一连串房间构成的，房间的标号从 $0$ 开始，想进入第 $i$ 个房间就必须从第 $i-1$ 个房间进入，如图：\n\n![](https://cdn.luogu.com.cn/upload/pic/6100.png)\n", "description": "上图为三个房间的情况，黑色的部分为连通两个房间的门，从左向右的编号分别为 $0,1,2\\cdots$。已知当小偷从第 $0$ 个门进入储藏室时，储藏室的计时系统开始计时，每个门都有自己的关闭时间。每个屋里有不同种类的宝石，对于每种宝石，它的价值和小偷拿走它所耗费的时间也是不同的，为了简化问题，我们设想小偷在各个屋子之间走动的时间可以忽略不计，而且所有屋子里各种宝石的数量都是无限多的，那么请问小偷在能成功逃出来的情况下，可能获得宝石的最大价值。\n\n附：对于每扇门，小偷都必须在严格早于此门关闭的时候出来才可以。", "inputFormat": "每组测试数据的第一行有两个整数 $N$ 和 $M$，分别代表储藏室有 $N$ 个房间，并且有 $M$ 种宝石。第二行中会有 $N$ 个正整数，分别表示第 $i$ 个门关闭的时间（门的编号从 $0$ 开始），接下来的 $M$ 行，每行有三个整数 $r,v$ 和 $t$，分别代表这种宝石所在的房间编号为 $r$，它的价值为 $v$，小偷拿走它所耗费的时间为 $t$。", "outputFormat": "输出小偷在成功逃出储藏室的情况下获得宝石的最大价值。\n", "hint": "### 样例解释\n\n虽然在第 $2$ 个房间中价值为 $5$ 的宝石好，但是不如拿两次价值为 $3$ 的宝石，在拿两次第 $0$ 房间中价值为 $1$ 的宝石，总价值为 $8$。\n\n### 数据范围及约定\n\n对于 $100\\%$ 的数据，储藏室的屋子数量不超过 $50$，每扇门关闭的时间不超过 $1000$，并且宝石的数量不超过 $100$，价值不超过 $1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2008] Thief", "background": "A famous thief enters a storage room full of gems. This storage is a chain of rooms, numbered from $0$. To enter room $i$, one must come from room $i-1$, as shown in the figure.\n\n![](https://cdn.luogu.com.cn/upload/pic/6100.png)", "description": "The figure above shows the case of three rooms. The black parts are the doors connecting two adjacent rooms, numbered from left to right as $0,1,2\\cdots$. When the thief enters the storage through door $0$, the timing system starts, and each door has its own closing time. Each room contains different kinds of gems. For each kind of gem, its value and the time the thief spends to take one are different. To simplify the problem, we assume the time to move between rooms is negligible, and the quantities of every kind of gem in all rooms are unlimited. What is the maximum total value of gems the thief can obtain while still being able to escape successfully?\n\nNote: For each door, the thief must exit through it strictly before it closes.", "inputFormat": "For each test case, the first line contains two integers $N$ and $M$, representing that the storage has $N$ rooms and there are $M$ kinds of gems. The second line contains $N$ positive integers, where the $i$-th integer denotes the closing time of door $i$ (doors are numbered from $0$). The next $M$ lines each contain three integers $r$, $v$ and $t$, meaning that this kind of gem is located in room $r$, its value is $v$, and it takes time $t$ for the thief to take one.", "outputFormat": "Output the maximum total value of gems the thief can obtain while successfully escaping the storage.", "hint": "### Sample Explanation\n\nAlthough the gem worth $5$ in room $2$ looks good, it is better to take two gems worth $3$, and then take two gems worth $1$ in room $0$, for a total value of $8$.\n\n### Constraints and Conventions\n\nFor $100\\%$ of the testdata, the number of rooms does not exceed $50$, the closing time of each door does not exceed $1000$, the number of gem types does not exceed $100$, and each value does not exceed $1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2008] 小偷", "background": "一位著名的小偷进入了一个充满宝石的储藏室，这个储藏室是由一连串房间构成的，房间的标号从 $0$ 开始，想进入第 $i$ 个房间就必须从第 $i-1$ 个房间进入，如图：\n\n![](https://cdn.luogu.com.cn/upload/pic/6100.png)\n", "description": "上图为三个房间的情况，黑色的部分为连通两个房间的门，从左向右的编号分别为 $0,1,2\\cdots$。已知当小偷从第 $0$ 个门进入储藏室时，储藏室的计时系统开始计时，每个门都有自己的关闭时间。每个屋里有不同种类的宝石，对于每种宝石，它的价值和小偷拿走它所耗费的时间也是不同的，为了简化问题，我们设想小偷在各个屋子之间走动的时间可以忽略不计，而且所有屋子里各种宝石的数量都是无限多的，那么请问小偷在能成功逃出来的情况下，可能获得宝石的最大价值。\n\n附：对于每扇门，小偷都必须在严格早于此门关闭的时候出来才可以。", "inputFormat": "每组测试数据的第一行有两个整数 $N$ 和 $M$，分别代表储藏室有 $N$ 个房间，并且有 $M$ 种宝石。第二行中会有 $N$ 个正整数，分别表示第 $i$ 个门关闭的时间（门的编号从 $0$ 开始），接下来的 $M$ 行，每行有三个整数 $r,v$ 和 $t$，分别代表这种宝石所在的房间编号为 $r$，它的价值为 $v$，小偷拿走它所耗费的时间为 $t$。", "outputFormat": "输出小偷在成功逃出储藏室的情况下获得宝石的最大价值。\n", "hint": "### 样例解释\n\n虽然在第 $2$ 个房间中价值为 $5$ 的宝石好，但是不如拿两次价值为 $3$ 的宝石，在拿两次第 $0$ 房间中价值为 $1$ 的宝石，总价值为 $8$。\n\n### 数据范围及约定\n\n对于 $100\\%$ 的数据，储藏室的屋子数量不超过 $50$，每扇门关闭的时间不超过 $1000$，并且宝石的数量不超过 $100$，价值不超过 $1000$。", "locale": "zh-CN"}}}
{"pid": "P3860", "type": "P", "difficulty": 4, "samples": [["3 2\n100\n200\n300\n", "800\n2\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "各省省选", "天津"], "title": "[TJOI2009] 火星人的手机", "background": "你应火星人之邀为他们设计一款新型的手机。我们知道在标准的地球人手机上，数字键共有 $10$ 个，$26$ 个字母 `a`…`z` 分别与某个数字键相关联，并且一个数字键上的若干字母必须是字母表中连续的一段。比如下图是地球手机的一个标准方案：\n\n![](https://cdn.luogu.com.cn/upload/pic/6103.png)\n", "description": "我们要输入一个字母，必须连续按它所在的数字键若干次，次数即为这个字母在这个键的第几个位置。例如在上图的方案中，若我们要输入 `C`，就需要按三次数字键 `2`；若要输入 `M`，需按一次数字键 `6`。\n\n火星人手机的构造与地球人手机类似，上面有 $M$ 个火星数字键，你需要把火星文的 $N$ 个字母放置在这 $M$ 个键上。（同样要求一个数字键上必须是连续的若干个火星字母）现在给定一段火星文中各个字母的出现次数，你设计的手机必须使得输入这段文字所需的按键次数最少。\n", "inputFormat": "输入文件的第一行包括两个数字 $N$ 和 $M$，分别表示火星文字母数和火星手机的按键数。接下来有 $N$ 行，每行包含一个数字，依次表示每个字母在文章中的出现次数。这个次数不超过 $1000$。\n", "outputFormat": "输出文件的第一行包括一个数字，表示最少的按键次数。\n\n接下来的 $M$ 行表示一种设计方案：每行包含一个数，依次表示每个数字键上有几个火星字母。（这些数字可以为 $0$）\n\n如果有多种方案可以得到最少的按键次数，你需要输出第一个数字键上包含字母最少的方案；如果仍有多种方案，你需要在其中选择第二个数字键上字母最少的方案；依此类推。\n", "hint": "### 数据范围及约定\n\n对于 $100\\%$ 的数据，$1\\le N \\le 500$，$1 \\le M \\le 100$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2009] Martian's Mobile Phone", "background": "At the invitation of the Martians, you are to design a new type of phone for them. We know that a standard Earth phone has $10$ numeric keys, the $26$ letters `a`…`z` are each associated with some numeric key, and the letters on any single numeric key must form a contiguous segment of the alphabet. For example, the figure below shows a standard scheme for an Earth phone:\n\n![](https://cdn.luogu.com.cn/upload/pic/6103.png)", "description": "To input a letter, we must press its numeric key several times consecutively; the number of presses equals the letter’s position on that key. For example, in the scheme above, to input `C`, we press numeric key `2` three times; to input `M`, we press numeric key `6` once.\n\nThe Martian phone is similar to the Earth phone: it has $M$ Martian numeric keys, and you need to place the $N$ letters of the Martian alphabet onto these $M$ keys. (Likewise, the letters on any single numeric key must be a contiguous block of Martian letters.) Now, given the occurrence count of each letter in a passage of Martian text, your design must minimize the total number of key presses required to input this passage.", "inputFormat": "The first line of input contains two numbers, $N$ and $M$, the number of Martian letters and the number of keys on the Martian phone, respectively. The next $N$ lines each contain one number, in order, giving the occurrence count of each letter in the passage. Each count does not exceed $1000$.", "outputFormat": "The first line of output contains a single number, the minimum total number of key presses.\n\nThe next $M$ lines describe one design: each line contains a number, in order, indicating how many Martian letters are placed on each numeric key. (These numbers may be $0$.)\n\nIf multiple designs achieve the same minimum, output the one with the fewest letters on the first numeric key; if still tied, among those choose the one with the fewest letters on the second numeric key; and so on.", "hint": "### Constraints\n\nFor $100\\%$ of the data, $1 \\le N \\le 500$, $1 \\le M \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2009] 火星人的手机", "background": "你应火星人之邀为他们设计一款新型的手机。我们知道在标准的地球人手机上，数字键共有 $10$ 个，$26$ 个字母 `a`…`z` 分别与某个数字键相关联，并且一个数字键上的若干字母必须是字母表中连续的一段。比如下图是地球手机的一个标准方案：\n\n![](https://cdn.luogu.com.cn/upload/pic/6103.png)\n", "description": "我们要输入一个字母，必须连续按它所在的数字键若干次，次数即为这个字母在这个键的第几个位置。例如在上图的方案中，若我们要输入 `C`，就需要按三次数字键 `2`；若要输入 `M`，需按一次数字键 `6`。\n\n火星人手机的构造与地球人手机类似，上面有 $M$ 个火星数字键，你需要把火星文的 $N$ 个字母放置在这 $M$ 个键上。（同样要求一个数字键上必须是连续的若干个火星字母）现在给定一段火星文中各个字母的出现次数，你设计的手机必须使得输入这段文字所需的按键次数最少。\n", "inputFormat": "输入文件的第一行包括两个数字 $N$ 和 $M$，分别表示火星文字母数和火星手机的按键数。接下来有 $N$ 行，每行包含一个数字，依次表示每个字母在文章中的出现次数。这个次数不超过 $1000$。\n", "outputFormat": "输出文件的第一行包括一个数字，表示最少的按键次数。\n\n接下来的 $M$ 行表示一种设计方案：每行包含一个数，依次表示每个数字键上有几个火星字母。（这些数字可以为 $0$）\n\n如果有多种方案可以得到最少的按键次数，你需要输出第一个数字键上包含字母最少的方案；如果仍有多种方案，你需要在其中选择第二个数字键上字母最少的方案；依此类推。\n", "hint": "### 数据范围及约定\n\n对于 $100\\%$ 的数据，$1\\le N \\le 500$，$1 \\le M \\le 100$。\n", "locale": "zh-CN"}}}
{"pid": "P3861", "type": "P", "difficulty": 5, "samples": [["1\n688", "6"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "数论", "洛谷原创", "O2优化", "洛谷月赛"], "title": "拆分", "background": "", "description": "给定一个整数 $n$，求将 $n$ 分解为互不相同的不小于 $2$ 的整数的乘积的方案数。答案模 $998244353$。\n", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n接下来 $T$ 行，每行一个整数 $n$，意义如描述所述。\n", "outputFormat": "一共 $T$ 行，每行一个整数，表示答案。\n", "hint": "样例中，因为\n\n$688 = 2 \\times 4 \\times 86= 2 \\times 8 \\times 43= 2 \\times 344= 4 \\times 172= 8 \\times 86= 16 \\times 43$\n\n所以答案为 $6$\n\n\n\n对于 $10\\%$ 的数据，保证 $n$ 为质数\n\n对于 $20\\%$ 的数据，保证 $2 \\leq n \\leq 10^4$\n\n对于 $50\\%$ 的数据，保证 $ 2  \\leq n \\leq 10^7$\n\n对于 $100\\%$ 的数据， 保证 $ 2 \\leq n \\leq 10^{12}$\n\n所有数据满足 $1 \\leq T \\leq 5$\n", "locale": "zh-CN", "translations": {"en": {"title": "Splitting", "background": "", "description": "Given an integer $n$, find the number of ways to factor $n$ into a product of pairwise distinct integers each at least $2$. Output the answer modulo $998244353$.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\nThe next $T$ lines each contain an integer $n$, as described.", "outputFormat": "Output $T$ lines, each containing a single integer, the answer.", "hint": "In the sample, because\n\n$688 = 2 \\times 4 \\times 86= 2 \\times 8 \\times 43= 2 \\times 344= 4 \\times 172= 8 \\times 86= 16 \\times 43$\n\nthe answer is $6$.\n\nFor $10\\%$ of the testdata, $n$ is prime.\nFor $20\\%$ of the testdata, $2 \\leq n \\leq 10^4$.\nFor $50\\%$ of the testdata, $ 2  \\leq n \\leq 10^7$.\nFor $100\\%$ of the testdata, $ 2 \\leq n \\leq 10^{12}$.\nAll testdata satisfy $1 \\leq T \\leq 5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "拆分", "background": "", "description": "给定一个整数 $n$，求将 $n$ 分解为互不相同的不小于 $2$ 的整数的乘积的方案数。答案模 $998244353$。\n", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n接下来 $T$ 行，每行一个整数 $n$，意义如描述所述。\n", "outputFormat": "一共 $T$ 行，每行一个整数，表示答案。\n", "hint": "样例中，因为\n\n$688 = 2 \\times 4 \\times 86= 2 \\times 8 \\times 43= 2 \\times 344= 4 \\times 172= 8 \\times 86= 16 \\times 43$\n\n所以答案为 $6$\n\n\n\n对于 $10\\%$ 的数据，保证 $n$ 为质数\n\n对于 $20\\%$ 的数据，保证 $2 \\leq n \\leq 10^4$\n\n对于 $50\\%$ 的数据，保证 $ 2  \\leq n \\leq 10^7$\n\n对于 $100\\%$ 的数据， 保证 $ 2 \\leq n \\leq 10^{12}$\n\n所有数据满足 $1 \\leq T \\leq 5$\n", "locale": "zh-CN"}}}
{"pid": "P3862", "type": "P", "difficulty": 5, "samples": [["4\n3\n4\n5\n6", "0\n3\n22\n133"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["图论", "递推", "洛谷原创", "O2优化", "组合数学", "洛谷月赛"], "title": "数圈", "background": "", "description": "求 $n$ 个点的无向完全图删去一条边之后圈的个数，答案模 $998244353$。\n\n\n注：圈指的是任选一个顶点为起点，沿着不重复的边，经过不重复的顶点为途径，之后又回到起点的闭合途径。\n", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n接下来 $T$ 行，每行一个整数 $n$，意义如描述所述。\n", "outputFormat": "一共 $T$ 行，每行一个整数，表示答案。\n", "hint": "前 $10\\%$ 的数据满足 $3 \\leq n \\leq 10$\n\n另外 $20\\%$ 的数据满足 $ 9.99\\times 10^2  \\leq n \\leq 10^3$\n\n另外 $30\\%$ 的数据满足 $ 9.99\\times 10^4 \\leq n \\leq 10^5$\n\n另外 $40\\%$ 的数据满足 $ 9.99\\times 10^8 \\leq n \\leq 10^9$\n\n所有数据满足 $1 \\leq T \\leq 10$\n", "locale": "zh-CN", "translations": {"en": {"title": "Counting Cycles", "background": "", "description": "Compute the number of cycles in the undirected complete graph on $n$ vertices after deleting one edge, and output the answer modulo $998244353$.\n\nNote: A “cycle” means choosing any vertex as the starting point, following non-repeating edges, visiting non-repeating vertices along the way, and then returning to the starting vertex to form a closed path.", "inputFormat": "The first line contains an integer $T$, indicating the number of test cases.\n\nThe next $T$ lines each contain an integer $n$, as described above.", "outputFormat": "Output $T$ lines, each containing one integer, representing the answer.", "hint": "For the first $10\\%$ of the testdata, $3 \\leq n \\leq 10$.\n\nFor an additional $20\\%$ of the testdata, $ 9.99\\times 10^2  \\leq n \\leq 10^3$.\n\nFor an additional $30\\%$ of the testdata, $ 9.99\\times 10^4 \\leq n \\leq 10^5$.\n\nFor the remaining $40\\%$ of the testdata, $ 9.99\\times 10^8 \\leq n \\leq 10^9$.\n\nAll testdata satisfy $1 \\leq T \\leq 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数圈", "background": "", "description": "求 $n$ 个点的无向完全图删去一条边之后圈的个数，答案模 $998244353$。\n\n\n注：圈指的是任选一个顶点为起点，沿着不重复的边，经过不重复的顶点为途径，之后又回到起点的闭合途径。\n", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n接下来 $T$ 行，每行一个整数 $n$，意义如描述所述。\n", "outputFormat": "一共 $T$ 行，每行一个整数，表示答案。\n", "hint": "前 $10\\%$ 的数据满足 $3 \\leq n \\leq 10$\n\n另外 $20\\%$ 的数据满足 $ 9.99\\times 10^2  \\leq n \\leq 10^3$\n\n另外 $30\\%$ 的数据满足 $ 9.99\\times 10^4 \\leq n \\leq 10^5$\n\n另外 $40\\%$ 的数据满足 $ 9.99\\times 10^8 \\leq n \\leq 10^9$\n\n所有数据满足 $1 \\leq T \\leq 10$\n", "locale": "zh-CN"}}}
{"pid": "P3863", "type": "P", "difficulty": 6, "samples": [["3 3\n1 3 5\n2 1 2\n1 1 2 -3\n2 1 1", "0\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["洛谷原创", "O2优化", "排序", "分块", "扫描线", "洛谷月赛"], "title": "序列", "background": "", "description": "给定一个长度为 $n$ 的序列，给出 $q$ 个操作，形如：\n\n$1~l~r~x$ 表示将序列下标介于 $[l,r]$ 的元素加上 $x$ （请注意，$x$ 可能为负）\n\n$2~p~y$ 表示查询 $a_p$ 在过去的多少秒时间内不小于 $y$ （不包括这一秒，细节请参照样例）\n\n开始时为第 $0$ 秒，第 $i$ 个操作发生在第 $i$ 秒。\n", "inputFormat": "第一行两个整数 $n,q$，意义如描述所述。\n\n接下来一行 $n$ 个整数 $a_i$，表示序列的每个元素的初始值。\n\n接下来 $q$ 行，每行第一个数为 $\\text{opt}$，表示这次操作的类型。如果 $\\text{opt} = 1$，后面紧跟三个整数 $l, r, x$，意义如描述所述；如果 $\\text{opt} = 2$，后面紧跟两个整数 $p, y$，意义如描述所述。\n", "outputFormat": "对于每个操作 $2$，在一行内输出一个数表示答案。\n", "hint": "样例一说明：位置 $1$ 在第 $0$ 秒到第 $3$ 秒的值为 $1,1,-2,-2$。对于第一个查询，第 $0$ 到 $1-1=0$ 秒中时间不小于 $2$；对于第二个查询，第 $0$ 到第 $3-1=2$ 秒时间不小于 $1$，分别为第 $0$ 秒，第 $1$ 秒。\n\n\n对于 $30\\%$ 的数据，保证 $n,q \\leq 1000$\n\n对于 $70\\%$ 的数据，保证 $n,q \\leq 50000$\n\n对于 $100\\%$ 的数据，保证 $2 \\leq n,q \\leq 100000$， $1 \\leq l \\leq r \\leq n$， $1 \\leq p \\leq n$，$-10^9 \\leq x,y,a_i \\leq 10^9$\n", "locale": "zh-CN", "translations": {"en": {"title": "Sequence", "background": "", "description": "Given a sequence of length $n$, there are $q$ operations of the following forms.\n\n$1~l~r~x$ means adding $x$ to each element with index in $[l,r]$ (note that $x$ may be negative).\n\n$2~p~y$ means querying for how many seconds in the past $a_p$ has been at least $y$ (excluding the current second; see the sample for details).\n\nTime starts at second $0$, and the $i$-th operation occurs at second $i$.", "inputFormat": "The first line contains two integers $n,q$, as described.\n\nThe second line contains $n$ integers $a_i$, the initial values of the sequence.\n\nEach of the next $q$ lines starts with $\\text{opt}$, indicating the type of this operation. If $\\text{opt} = 1$, it is followed by three integers $l, r, x$, as described. If $\\text{opt} = 2$, it is followed by two integers $p, y$, as described.", "outputFormat": "For each operation of type $2$, output one integer on a single line indicating the answer.", "hint": "Explanation for Sample 1: at position $1$, the values from second $0$ to second $3$ are $1,1,-2,-2$. For the first query, during seconds $0$ to $1-1=0$, the value is not less than $2$. For the second query, during seconds $0$ to $3-1=2$, the value is not less than $1$, namely at second $0$ and second $1$.\n\nFor $30\\%$ of the testdata, $n,q \\leq 1000$.\n\nFor $70\\%$ of the testdata, $n,q \\leq 50000$.\n\nFor $100\\%$ of the testdata, $2 \\leq n,q \\leq 100000$, $1 \\leq l \\leq r \\leq n$, $1 \\leq p \\leq n$, $-10^9 \\leq x,y,a_i \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "序列", "background": "", "description": "给定一个长度为 $n$ 的序列，给出 $q$ 个操作，形如：\n\n$1~l~r~x$ 表示将序列下标介于 $[l,r]$ 的元素加上 $x$ （请注意，$x$ 可能为负）\n\n$2~p~y$ 表示查询 $a_p$ 在过去的多少秒时间内不小于 $y$ （不包括这一秒，细节请参照样例）\n\n开始时为第 $0$ 秒，第 $i$ 个操作发生在第 $i$ 秒。\n", "inputFormat": "第一行两个整数 $n,q$，意义如描述所述。\n\n接下来一行 $n$ 个整数 $a_i$，表示序列的每个元素的初始值。\n\n接下来 $q$ 行，每行第一个数为 $\\text{opt}$，表示这次操作的类型。如果 $\\text{opt} = 1$，后面紧跟三个整数 $l, r, x$，意义如描述所述；如果 $\\text{opt} = 2$，后面紧跟两个整数 $p, y$，意义如描述所述。\n", "outputFormat": "对于每个操作 $2$，在一行内输出一个数表示答案。\n", "hint": "样例一说明：位置 $1$ 在第 $0$ 秒到第 $3$ 秒的值为 $1,1,-2,-2$。对于第一个查询，第 $0$ 到 $1-1=0$ 秒中时间不小于 $2$；对于第二个查询，第 $0$ 到第 $3-1=2$ 秒时间不小于 $1$，分别为第 $0$ 秒，第 $1$ 秒。\n\n\n对于 $30\\%$ 的数据，保证 $n,q \\leq 1000$\n\n对于 $70\\%$ 的数据，保证 $n,q \\leq 50000$\n\n对于 $100\\%$ 的数据，保证 $2 \\leq n,q \\leq 100000$， $1 \\leq l \\leq r \\leq n$， $1 \\leq p \\leq n$，$-10^9 \\leq x,y,a_i \\leq 10^9$\n", "locale": "zh-CN"}}}
{"pid": "P3864", "type": "P", "difficulty": 3, "samples": [["4734\nNMSL\nGREG\nLSDC\n....(太多了不写了)", "GREG\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [230000, 230000, 230000, 230000, 230000, 230000, 230000, 230000, 230000, 230000, 230000, 230000, 230000, 230000, 230000]}, "tags": ["模拟", "字符串", "搜索", "USACO", "枚举", "深度优先搜索 DFS"], "title": "[USACO1.2] 命名那个数字 Name That Number", "background": "", "description": "在威斯康辛州牛守志大农场经营者之中，都习惯于请会计部门用连续数字给母牛打上烙印。但是,母牛本身并没感到这个系统的便利,它们更喜欢用它们喜欢的名字来呼叫它们的同伴，而不是用像这个的语句：“C'mon, #4364, 相处愉快。”请写一个程序来帮助可怜的牧牛工将一只母牛的烙印编号翻译成一个可能的名字。因为母牛们现在都有手机了，可以按照下表来转换数字为字母：\n\n| 数字 | 对应字母 |\n|:-:|:-:|\n| $2$ | A,B,C |\n| $3$ | D,E,F |\n| $4$ | G,H,I |\n| $5$ | J,K,L |\n| $6$ | M,N,O |\n| $7$ | P,R,S |\n| $8$ | T,U,V |\n| $9$ | W,X,Y |\n\n请注意没有字符 `Q` 和字符 `Z`。\n\n牛群们可接受的名字都被放在这样一个叫作 \"[dict.txt](https://usaco.training/usaco/namenumdict.txt)\" 的文件中，它包含一连串的少于 $5000$ 个（准确地说是 $4617$ 个）可被接受的牛的名字。(所有的名字都是大写的且已按字典序排列) 请读入母牛的编号并返回那些能从编号翻译出来并且在字典中的名字。举例来说，编号 $4734$  能产生的 $81$ 个名字中只有一个 \"`GREG`\" 是有效的（在字典中）。\n\n写一个程序来对给出的编号打印出所有的有效名字，如果没有则输出 `NONE`。", "inputFormat": "第一行一行包含一个编号，长度 $1$ 到 $12$。\n\n接下来若干行，每行一个字符串表示可以被接受的名字。", "outputFormat": "以字典顺序输出一个有效名字的不重复列表，一行一个名字。如果没有有效名字，输出 `NONE`。 ", "hint": "$4734$ 所能产生的所有组合如下：\n\n```\nGPDG GPDH GPDI GPEG GPEH GPEI GPFG GPFH GPFI GRDG GRDH GRDI GREG GREH GREI GRFG GRFH GRFI GSDG GSDH GSDI GSEG GSEH GSEI GSFG GSFH GSFI HPDG HPDH HPDI HPEG HPEH HPEI HPFG HPFH HPFI HRDG HRDH HRDI HREG HREH HREI HRFG HRFH HRFI HSDG HSDH HSDI HSEG HSEH HSEI HSFG HSFH HSFI IPDG IPDH IPDI IPEG IPEH IPEI IPFG IPFH IPFI IRDG IRDH IRDI IREG IREH IREI IRFG IRFH IRFI ISDG ISDH ISDI ISEG ISEH ISEI ISFG ISFH ISFI\n```", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.2] Name That Number", "background": "", "description": "Among dairy farmers in Wisconsin, it is customary for the accounting department to brand cows with consecutive numbers. The cows themselves do not find this system convenient; they prefer to call their companions by their favorite names rather than with phrases like \"C'mon, #4364, be friendly.\" Please write a program to help the poor cowhands translate a cow's brand number into a possible name. Since cows now all have cell phones, you can convert digits to letters according to the table below.\n\n| Digit | Letters |\n|:-:|:-:|\n| $2$ | A,B,C |\n| $3$ | D,E,F |\n| $4$ | G,H,I |\n| $5$ | J,K,L |\n| $6$ | M,N,O |\n| $7$ | P,R,S |\n| $8$ | T,U,V |\n| $9$ | W,X,Y |\n\nNote that the letters `Q` and `Z` are not present.\n\nThe set of acceptable cow names is stored in a file called \"[dict.txt](https://usaco.training/usaco/namenumdict.txt)\", which contains a sequence of fewer than $5000$ (specifically, $4617$) acceptable names. All names are uppercase and already sorted in lexicographical order. Read the cow's number and return those names that can be translated from the number and appear in the dictionary. For example, among the $81$ names generated by the number $4734$, only \"`GREG`\" is valid (i.e., present in the dictionary).\n\nWrite a program to print all valid names for the given number. If there are none, output `NONE`.", "inputFormat": "The first line contains a number of length $1$ to $12$.\n\nThe following lines (until EOF), one per line, each contain a string representing an acceptable name.", "outputFormat": "Output a deduplicated list of valid names in lexicographical order, one name per line. If there are no valid names, output `NONE`.", "hint": "All combinations producible from $4734$ are as follows:\n\n```\nGPDG GPDH GPDI GPEG GPEH GPEI GPFG GPFH GPFI GRDG GRDH GRDI GREG GREH GREI GRFG GRFH GRFI GSDG GSDH GSDI GSEG GSEH GSEI GSFG GSFH GSFI HPDG HPDH HPDI HPEG HPEH HPEI HPFG HPFH HPFI HRDG HRDH HRDI HREG HREH HREI HRFG HRFH HRFI HSDG HSDH HSDI HSEG HSEH HSEI HSFG HSFH HSFI IPDG IPDH IPDI IPEG IPEH IPEI IPFG IPFH IPFI IRDG IRDH IRDI IREG IREH IREI IRFG IRFH IRFI ISDG ISDH ISDI ISEG ISEH ISEI ISFG ISFH ISFI\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.2] 命名那个数字 Name That Number", "background": "", "description": "在威斯康辛州牛守志大农场经营者之中，都习惯于请会计部门用连续数字给母牛打上烙印。但是,母牛本身并没感到这个系统的便利,它们更喜欢用它们喜欢的名字来呼叫它们的同伴，而不是用像这个的语句：“C'mon, #4364, 相处愉快。”请写一个程序来帮助可怜的牧牛工将一只母牛的烙印编号翻译成一个可能的名字。因为母牛们现在都有手机了，可以按照下表来转换数字为字母：\n\n| 数字 | 对应字母 |\n|:-:|:-:|\n| $2$ | A,B,C |\n| $3$ | D,E,F |\n| $4$ | G,H,I |\n| $5$ | J,K,L |\n| $6$ | M,N,O |\n| $7$ | P,R,S |\n| $8$ | T,U,V |\n| $9$ | W,X,Y |\n\n请注意没有字符 `Q` 和字符 `Z`。\n\n牛群们可接受的名字都被放在这样一个叫作 \"[dict.txt](https://usaco.training/usaco/namenumdict.txt)\" 的文件中，它包含一连串的少于 $5000$ 个（准确地说是 $4617$ 个）可被接受的牛的名字。(所有的名字都是大写的且已按字典序排列) 请读入母牛的编号并返回那些能从编号翻译出来并且在字典中的名字。举例来说，编号 $4734$  能产生的 $81$ 个名字中只有一个 \"`GREG`\" 是有效的（在字典中）。\n\n写一个程序来对给出的编号打印出所有的有效名字，如果没有则输出 `NONE`。", "inputFormat": "第一行一行包含一个编号，长度 $1$ 到 $12$。\n\n接下来若干行，每行一个字符串表示可以被接受的名字。", "outputFormat": "以字典顺序输出一个有效名字的不重复列表，一行一个名字。如果没有有效名字，输出 `NONE`。 ", "hint": "$4734$ 所能产生的所有组合如下：\n\n```\nGPDG GPDH GPDI GPEG GPEH GPEI GPFG GPFH GPFI GRDG GRDH GRDI GREG GREH GREI GRFG GRFH GRFI GSDG GSDH GSDI GSEG GSEH GSEI GSFG GSFH GSFI HPDG HPDH HPDI HPEG HPEH HPEI HPFG HPFH HPFI HRDG HRDH HRDI HREG HREH HREI HRFG HRFH HRFI HSDG HSDH HSDI HSEG HSEH HSEI HSFG HSFH HSFI IPDG IPDH IPDI IPEG IPEH IPEI IPFG IPFH IPFI IRDG IRDH IRDI IREG IREH IREI IRFG IRFH IRFI ISDG ISDH ISDI ISEG ISEH ISEI ISFG ISFH ISFI\n```", "locale": "zh-CN"}}}
{"pid": "P3865", "type": "P", "difficulty": 3, "samples": [["8 8\n9 3 1 7 5 6 0 8\n1 6\n1 5\n2 7\n2 6\n1 8\n4 8\n3 7\n1 8", "9\n9\n7\n7\n9\n8\n7\n9"]], "limits": {"time": [800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["倍增", "O2优化", "ST 表", "模板题"], "title": "【模板】ST 表 & RMQ 问题", "background": "这是一道 ST 表经典题——静态区间最大值\n\n**请注意最大数据时限只有 0.8s，数据强度不低，请务必保证你的每次查询复杂度为 $O(1)$。若使用更高时间复杂度算法不保证能通过。**\n\n如果您认为您的代码时间复杂度正确但是 TLE，可以尝试使用快速读入：\n\n```cpp\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\treturn x*f;\n}\n```\n\n函数返回值为读入的第一个整数。\n\n**快速读入作用仅为加快读入，并非强制使用。**", "description": "给定一个长度为 $N$ 的数列，和 $ M $ 次询问，求出每一次询问的区间内数字的最大值。", "inputFormat": "第一行包含两个整数 $N,M$，分别表示数列的长度和询问的个数。\n\n第二行包含 $N$ 个整数（记为 $a_i$），依次表示数列的第 $i$ 项。\n\n接下来 $M$ 行，每行包含两个整数 $l_i,r_i$，表示查询的区间为 $[l_i,r_i]$。", "outputFormat": "输出包含 $M$ 行，每行一个整数，依次表示每一次询问的结果。", "hint": "对于 $30\\%$ 的数据，满足 $1\\le N,M\\le 10$。\n\n对于 $70\\%$ 的数据，满足 $1\\le N,M\\le {10}^5$。\n\n对于 $100\\%$ 的数据，满足 $1\\le N\\le {10}^5$，$1\\le M\\le 2\\times{10}^6$，$a_i\\in[0,{10}^9]$，$1\\le l_i\\le r_i\\le N$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] ST Table & RMQ Problem", "background": "This is a classic ST table problem — static range maximum.\n\nPlease note that the maximum time limit for the largest testdata is only 0.8 s, and the data is not weak. Please ensure that the time complexity per query is $O(1)$. If you use a higher time complexity algorithm, it is not guaranteed to pass.\n\nIf you believe your code has the correct time complexity but gets TLE, you can try fast input:\n\n```cpp\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\treturn x*f;\n}\n```\n\nThe function returns the first integer read.\n\nFast input is only for speeding up input and is not mandatory.", "description": "Given a sequence of length $N$ and $M$ queries, for each query, find the maximum number in the specified interval.", "inputFormat": "The first line contains two integers $N, M$, representing the length of the sequence and the number of queries.\n\nThe second line contains $N$ integers (denoted as $a_i$), representing the $i$-th element of the sequence in order.\n\nThe next $M$ lines each contain two integers $l_i, r_i$, indicating that the query interval is $[l_i, r_i]$.", "outputFormat": "Output $M$ lines, each containing one integer, representing the answer to each query in order.", "hint": "- For 30% of the testdata, $1 \\le N, M \\le 10$.\n- For 70% of the testdata, $1 \\le N, M \\le {10}^5$.\n- For 100% of the testdata, $1 \\le N \\le {10}^5$, $1 \\le M \\le 2 \\times {10}^6$, $a_i \\in [0, {10}^9]$, $1 \\le l_i \\le r_i \\le N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】ST 表 & RMQ 问题", "background": "这是一道 ST 表经典题——静态区间最大值\n\n**请注意最大数据时限只有 0.8s，数据强度不低，请务必保证你的每次查询复杂度为 $O(1)$。若使用更高时间复杂度算法不保证能通过。**\n\n如果您认为您的代码时间复杂度正确但是 TLE，可以尝试使用快速读入：\n\n```cpp\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\treturn x*f;\n}\n```\n\n函数返回值为读入的第一个整数。\n\n**快速读入作用仅为加快读入，并非强制使用。**", "description": "给定一个长度为 $N$ 的数列，和 $ M $ 次询问，求出每一次询问的区间内数字的最大值。", "inputFormat": "第一行包含两个整数 $N,M$，分别表示数列的长度和询问的个数。\n\n第二行包含 $N$ 个整数（记为 $a_i$），依次表示数列的第 $i$ 项。\n\n接下来 $M$ 行，每行包含两个整数 $l_i,r_i$，表示查询的区间为 $[l_i,r_i]$。", "outputFormat": "输出包含 $M$ 行，每行一个整数，依次表示每一次询问的结果。", "hint": "对于 $30\\%$ 的数据，满足 $1\\le N,M\\le 10$。\n\n对于 $70\\%$ 的数据，满足 $1\\le N,M\\le {10}^5$。\n\n对于 $100\\%$ 的数据，满足 $1\\le N\\le {10}^5$，$1\\le M\\le 2\\times{10}^6$，$a_i\\in[0,{10}^9]$，$1\\le l_i\\le r_i\\le N$。", "locale": "zh-CN"}}}
{"pid": "P3866", "type": "P", "difficulty": 6, "samples": [["4 3\n1 2 1\n1 10 1\n1 0 -1\n1 1 1", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "各省省选", "最小割", "天津"], "title": "[TJOI2009] 战争游戏", "background": "小R正在玩一个战争游戏。游戏地图是一个M行N列的矩阵，每个格子可能是障碍物，也可能是空地，在游戏开始时有若干支敌军分散在不同的空地格子中。每支敌军都可以从当前所在的格子移动到四个相邻的格子之一，但是不能移动到包含障碍物的格子。如果敌军移动出了地图的边界，那么战争就失败了。\n", "description": "现在你的任务是，在敌军开始移动前，通过飞机轰炸使得某些原本是空地的格子变得不可通行，这样就有可能阻止敌军移出地图边界（出于某种特殊的考虑，你不能直接轰炸敌军所在的格子）。由于地形不同的原因，把每个空地格子轰炸成不可通行所需的炸药数目可能是不同的，你需要计算出要阻止敌军所需的最少的炸药数。\n", "inputFormat": "输入文件的第一行包含两个数M和N，分别表示矩阵的长和宽。接下来M行，每行包含用空格隔开的N个数字，每个数字表示一个格子的情况：若数字为-1，表示这个格子是障碍物；若数字为0，表示这个格子里有一支敌军；若数字为一个正数x，表示这个格子是空地，且把它轰炸成不可通行所需的炸药数为x。\n\n地图上的敌军数量不为1，即地图上有多个0。", "outputFormat": "输出一个数字，表示所需的最少炸药数。数据保证有解存在。\n", "hint": "对50%的数据，1 ≤ M,N ≤ 10\n\n对100%的数据，1 ≤ M,N ≤ 30\n\n矩阵里的每个数不超过100\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2009] War Game", "background": "Xiao R is playing a war game. The map is an $M$-row, $N$-column grid. Each cell may be an obstacle or empty. At the start of the game, several enemy units are scattered across different empty cells. Each enemy unit can move from its current cell to one of the four adjacent cells, but it cannot move into a cell that contains an obstacle. If an enemy unit moves outside the map boundary, the war is lost.", "description": "Before the enemies start moving, your task is to use airstrikes to turn some originally empty cells into impassable cells, which may prevent the enemies from leaving the map. For special reasons, you cannot bomb any cell currently occupied by an enemy unit. Due to terrain differences, the amount of explosives needed to bomb each empty cell into an impassable cell may vary. You need to compute the minimum total amount of explosives required to prevent the enemies from moving out of the map boundary.", "inputFormat": "The first line contains two integers $M$ and $N$, the numbers of rows and columns of the grid. The next $M$ lines each contain $N$ space-separated integers, describing the grid cells:\n- If the number is $-1$, the cell is an obstacle.\n- If the number is $0$, there is an enemy unit in this cell.\n- If the number is a positive integer $x$, the cell is empty, and $x$ units of explosives are needed to bomb it into an impassable cell.\n\nThe number of enemy units on the map is not equal to $1$ (i.e., there are at least two cells with $0$).", "outputFormat": "Output a single number: the minimum total amount of explosives required. The testdata guarantee that a solution exists.", "hint": "- For 50% of the testdata, $1 \\le M, N \\le 10$.\n- For 100% of the testdata, $1 \\le M, N \\le 30$.\n- Every number in the matrix does not exceed $100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2009] 战争游戏", "background": "小R正在玩一个战争游戏。游戏地图是一个M行N列的矩阵，每个格子可能是障碍物，也可能是空地，在游戏开始时有若干支敌军分散在不同的空地格子中。每支敌军都可以从当前所在的格子移动到四个相邻的格子之一，但是不能移动到包含障碍物的格子。如果敌军移动出了地图的边界，那么战争就失败了。\n", "description": "现在你的任务是，在敌军开始移动前，通过飞机轰炸使得某些原本是空地的格子变得不可通行，这样就有可能阻止敌军移出地图边界（出于某种特殊的考虑，你不能直接轰炸敌军所在的格子）。由于地形不同的原因，把每个空地格子轰炸成不可通行所需的炸药数目可能是不同的，你需要计算出要阻止敌军所需的最少的炸药数。\n", "inputFormat": "输入文件的第一行包含两个数M和N，分别表示矩阵的长和宽。接下来M行，每行包含用空格隔开的N个数字，每个数字表示一个格子的情况：若数字为-1，表示这个格子是障碍物；若数字为0，表示这个格子里有一支敌军；若数字为一个正数x，表示这个格子是空地，且把它轰炸成不可通行所需的炸药数为x。\n\n地图上的敌军数量不为1，即地图上有多个0。", "outputFormat": "输出一个数字，表示所需的最少炸药数。数据保证有解存在。\n", "hint": "对50%的数据，1 ≤ M,N ≤ 10\n\n对100%的数据，1 ≤ M,N ≤ 30\n\n矩阵里的每个数不超过100\n", "locale": "zh-CN"}}}
{"pid": "P3867", "type": "P", "difficulty": 5, "samples": [["4 2", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 10000, 10000, 10000, 10000, 10000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "2009", "各省省选", "O2优化", "枚举", "天津"], "title": "[TJOI2009] 排列计数", "background": null, "description": "我们知道，$1,2,...,N$ 这个 $N$ 个数的排列共有 $N!$ 种情况。现在你的任务是，求出在这 $N!$ 种排列中，任意相邻两数之差不超过 $K$ 的排列共有多少个。\n\n因为结果可能很大，你只需输出结果对 $10^9+7$ 取模后的值即可。", "inputFormat": "输入只有一行，包含用空格隔开的两个数：$N, K$。", "outputFormat": "输出满足要求的排列个数对 $10^9+7$ 取模后的结果。", "hint": "在 $30 \\%$ 的数据中，$N \\le 12$\n\n在 $100 \\%$ 的数据中，$N \\le 50,K \\le 4$\n\n每个测试点时限 10 秒。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2009] Permutation Counting", "background": "", "description": "We know there are $N!$ permutations of the $N$ numbers $1,2,...,N$. Your task is to count how many of these permutations have the property that the difference between any two adjacent numbers does not exceed $K$.\n\nSince the result may be large, output the answer modulo $10^9+7$.", "inputFormat": "The input contains a single line with two space-separated integers: $N, K$.", "outputFormat": "Output the number of valid permutations modulo $10^9+7$.", "hint": "On 30% of the testdata, $N \\le 12$.\n\nOn 100% of the testdata, $N \\le 50$, $K \\le 4$.\n\nTime limit per test point: 10 seconds.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2009] 排列计数", "background": null, "description": "我们知道，$1,2,...,N$ 这个 $N$ 个数的排列共有 $N!$ 种情况。现在你的任务是，求出在这 $N!$ 种排列中，任意相邻两数之差不超过 $K$ 的排列共有多少个。\n\n因为结果可能很大，你只需输出结果对 $10^9+7$ 取模后的值即可。", "inputFormat": "输入只有一行，包含用空格隔开的两个数：$N, K$。", "outputFormat": "输出满足要求的排列个数对 $10^9+7$ 取模后的结果。", "hint": "在 $30 \\%$ 的数据中，$N \\le 12$\n\n在 $100 \\%$ 的数据中，$N \\le 50,K \\le 4$\n\n每个测试点时限 10 秒。", "locale": "zh-CN"}}}
{"pid": "P3868", "type": "P", "difficulty": 5, "samples": [["3\n1 2 3\n2 3 5\n", "23"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2009", "各省省选", "扩展欧几里德算法", "中国剩余定理 CRT", "天津"], "title": "[TJOI2009] 猜数字", "background": "", "description": "现有两组数字，每组 $k$ 个。\n\n第一组中的数字分别用 $a_1,a_2,\\cdots ,a_k$ 表示，第二组中的数字分别用 $b_1,b_2,\\cdots ,b_k$ 表示。\n\n其中第二组中的数字是两两互素的。求最小的 $n\\in \\mathbb{N}$，满足对于 $\\forall i\\in [1,k]$，有 $b_i | (n-a_i)$。", "inputFormat": "第一行一个整数 $k$。\n\n第二行 $k$ 个整数，表示：$a_1,a_2,\\cdots ,a_k$。\n\n第三行 $k$ 个整数，表示：$b_1,b_2,\\cdots ,b_k$。", "outputFormat": "输出一行一个整数，为所求的答案 $n$。", "hint": "对于 $100\\%$ 的数据：\n\n$1\\le k \\le 10$，$|a_i|\\le 10^9$，$1\\le b_i\\le 6\\times 10^3$，$\\prod_{i=1}^k b_i\\le 10^{18}$。\n\n每个测试点时限 $1$ 秒。\n\n注意：对于 ```C/C++``` 语言，对 $64$ 位整型数应声明为 ```long long```。\n\n若使用 ```scanf```，```printf``` 函数（以及 ```fscanf```，```fprintf``` 等），应采用 ```%lld``` 标识符。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2009] Guess the Number", "background": "", "description": "There are two groups of numbers, each with $k$ elements.\n\nThe numbers in the first group are denoted by $a_1,a_2,\\cdots ,a_k$, and the numbers in the second group are denoted by $b_1,b_2,\\cdots ,b_k$.\n\nThe numbers in the second group are pairwise coprime. Find the smallest $n\\in \\mathbb{N}$ such that for $\\forall i\\in [1,k]$, $b_i | (n-a_i)$ holds.", "inputFormat": "The first line contains an integer $k$.\n\nThe second line contains $k$ integers: $a_1,a_2,\\cdots ,a_k$.\n\nThe third line contains $k$ integers: $b_1,b_2,\\cdots ,b_k$.", "outputFormat": "Output a single integer, which is the required answer $n$.", "hint": "Constraints:\n\n$1\\le k \\le 10$，$|a_i|\\le 10^9$，$1\\le b_i\\le 6\\times 10^3$，$\\prod_{i=1}^k b_i\\le 10^{18}$.\n\nTime limit per test case: 1 second.\n\nNote: For ```C/C++``` language, 64-bit integers should be declared as ```long long```.\n\nIf using ```scanf``` and ```printf``` (as well as ```fscanf```, ```fprintf```, etc.), use the ```%lld``` specifier.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2009] 猜数字", "background": "", "description": "现有两组数字，每组 $k$ 个。\n\n第一组中的数字分别用 $a_1,a_2,\\cdots ,a_k$ 表示，第二组中的数字分别用 $b_1,b_2,\\cdots ,b_k$ 表示。\n\n其中第二组中的数字是两两互素的。求最小的 $n\\in \\mathbb{N}$，满足对于 $\\forall i\\in [1,k]$，有 $b_i | (n-a_i)$。", "inputFormat": "第一行一个整数 $k$。\n\n第二行 $k$ 个整数，表示：$a_1,a_2,\\cdots ,a_k$。\n\n第三行 $k$ 个整数，表示：$b_1,b_2,\\cdots ,b_k$。", "outputFormat": "输出一行一个整数，为所求的答案 $n$。", "hint": "对于 $100\\%$ 的数据：\n\n$1\\le k \\le 10$，$|a_i|\\le 10^9$，$1\\le b_i\\le 6\\times 10^3$，$\\prod_{i=1}^k b_i\\le 10^{18}$。\n\n每个测试点时限 $1$ 秒。\n\n注意：对于 ```C/C++``` 语言，对 $64$ 位整型数应声明为 ```long long```。\n\n若使用 ```scanf```，```printf``` 函数（以及 ```fscanf```，```fprintf``` 等），应采用 ```%lld``` 标识符。", "locale": "zh-CN"}}}
{"pid": "P3869", "type": "P", "difficulty": 4, "samples": [["5 5\nS.#..\n#####\n..#..\n##.#.\n...#T\n6\n1 5 4 2\n1 4 3 3\n5 1 3 3\n1 4 4 5\n1 2 1 3\n1 5 2 1\n", "22"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2009", "各省省选", "O2优化", "天津", "状压 DP"], "title": "[TJOI2009] 宝藏", "background": "", "description": "为了寻找传说中的宝藏，小明走进了一个迷宫，我们用一个 $r$ 行 $c$ 列的矩阵来描述这个迷宫，矩阵的每个位置表示一个方块区域：\n\n- 字符 `.` 表示可以通过的方格。\n- 字符 `#` 表示不能通过的方格。\n- 在迷宫中有 $k$ 个机关，第 $i$ 个机关工作方式为：  \n  - 每当小明走上第 $r_i$ 行，$c_i$ 列的格子时，位于第 $R_i$ 行，$C_i$ 列的格子改变状态（如果这个格子此时可以通过，此后就变为不能通过；如果此时不能通过，此后可以通过。最左上角的格子是第 $1$ 行第 $1$ 列）。\n\n现给出当前小明的位置，宝藏的位置，迷宫中每个格子的状态，以及所有机关的描述，问小明至少还要走多少步才能拿到宝藏（不能走出迷宫的边界，在开始时刻，小明和宝藏所在的位置都是可以通过的，机关不会出现在起点和终点，也不会影响这两个格子）。\n", "inputFormat": "输入数据的第 $1$ 行是两个整数：$r$ 和 $c$。\n\n输入数据的第 $2$ 行到第 $r+1$ 行，每行是一个长度为 $c$ 的字符串，描述迷宫的当前状态：`.` 表示此时可以通过的格子，`#` 表示此时不能通过的格子，`S` 表示起点，`T` 表示宝藏的位置。\n\n输入数据的第 $r+2$ 行是一个整数 $k$，表示机关的数目。接下来有 $k$ 行，每一行包含 $4$ 个整数 $r_i,c_i,R_i,C_i$，用来描述一个机关。\n", "outputFormat": "输出一个整数：小明最少需要走多少步才能拿到宝藏。测试数据保证可以找到宝藏。\n", "hint": "### 数据范围及约定\n\n对于全部数据，$5 \\le r, c \\le 30$，$0 \\le k \\le 10$，$1 \\le r_i,R_i\\le r$，$1 \\le c_i,C_i \\le c$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2009] Treasure", "background": "", "description": "To search for the legendary treasure, Xiao Ming enters a maze. We describe this maze with an $r$-by-$c$ matrix, where each position represents a square cell:\n\n- The character `.` means the cell is passable.\n- The character `#` means the cell is impassable.\n- There are $k$ mechanisms in the maze. The $i$-th mechanism works as follows:\n  - Whenever Xiao Ming steps onto the cell at row $r_i$, column $c_i$, the cell at row $R_i$, column $C_i$ toggles its state (if that cell is passable at that moment, it becomes impassable afterward; if it is impassable, it becomes passable afterward. The top-left cell is row $1$, column $1$).\n\nGiven Xiao Ming’s current position, the treasure’s position, the current state of every cell in the maze, and all mechanism descriptions, determine the minimum number of steps Xiao Ming still needs to reach the treasure (he cannot move outside the maze boundary. At the start, both Xiao Ming’s cell and the treasure’s cell are passable. No mechanism appears at the start or the end, and no mechanism affects these two cells).", "inputFormat": "The first line contains two integers: $r$ and $c$.\n\nLines $2$ to $r+1$ each contain a string of length $c$, describing the current state of the maze: `.` means a passable cell, `#` means an impassable cell, `S` marks the start, and `T` marks the treasure’s position.\n\nLine $r+2$ contains an integer $k$, the number of mechanisms. Then $k$ lines follow, each containing $4$ integers $r_i, c_i, R_i, C_i$, describing one mechanism.", "outputFormat": "Output a single integer: the minimum number of steps Xiao Ming needs to reach the treasure. The testdata guarantees the treasure is reachable.", "hint": "Constraints\n\nFor all testdata, $5 \\le r, c \\le 30$, $0 \\le k \\le 10$, $1 \\le r_i, R_i \\le r$, $1 \\le c_i, C_i \\le c$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2009] 宝藏", "background": "", "description": "为了寻找传说中的宝藏，小明走进了一个迷宫，我们用一个 $r$ 行 $c$ 列的矩阵来描述这个迷宫，矩阵的每个位置表示一个方块区域：\n\n- 字符 `.` 表示可以通过的方格。\n- 字符 `#` 表示不能通过的方格。\n- 在迷宫中有 $k$ 个机关，第 $i$ 个机关工作方式为：  \n  - 每当小明走上第 $r_i$ 行，$c_i$ 列的格子时，位于第 $R_i$ 行，$C_i$ 列的格子改变状态（如果这个格子此时可以通过，此后就变为不能通过；如果此时不能通过，此后可以通过。最左上角的格子是第 $1$ 行第 $1$ 列）。\n\n现给出当前小明的位置，宝藏的位置，迷宫中每个格子的状态，以及所有机关的描述，问小明至少还要走多少步才能拿到宝藏（不能走出迷宫的边界，在开始时刻，小明和宝藏所在的位置都是可以通过的，机关不会出现在起点和终点，也不会影响这两个格子）。\n", "inputFormat": "输入数据的第 $1$ 行是两个整数：$r$ 和 $c$。\n\n输入数据的第 $2$ 行到第 $r+1$ 行，每行是一个长度为 $c$ 的字符串，描述迷宫的当前状态：`.` 表示此时可以通过的格子，`#` 表示此时不能通过的格子，`S` 表示起点，`T` 表示宝藏的位置。\n\n输入数据的第 $r+2$ 行是一个整数 $k$，表示机关的数目。接下来有 $k$ 行，每一行包含 $4$ 个整数 $r_i,c_i,R_i,C_i$，用来描述一个机关。\n", "outputFormat": "输出一个整数：小明最少需要走多少步才能拿到宝藏。测试数据保证可以找到宝藏。\n", "hint": "### 数据范围及约定\n\n对于全部数据，$5 \\le r, c \\le 30$，$0 \\le k \\le 10$，$1 \\le r_i,R_i\\le r$，$1 \\le c_i,C_i \\le c$。\n", "locale": "zh-CN"}}}
{"pid": "P3870", "type": "P", "difficulty": 4, "samples": [["4 5\n0 1 2\n0 2 4\n1 2 3\n0 2 4\n1 1 4\n", "1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "线段树", "各省省选", "分块", "天津", "bitset"], "title": "[TJOI2009] 开关", "background": "", "description": "现有 $n$ 盏灯排成一排，从左到右依次编号为：$1$，$2$，……，$n$。然后依次执行 $m$ 项操作。\n\n操作分为两种：\n\n1. 指定一个区间 $[a,b]$，然后改变编号在这个区间内的灯的状态（把开着的灯关上，关着的灯打开）；\n2. 指定一个区间 $[a,b]$，要求你输出这个区间内有多少盏灯是打开的。\n\n**灯在初始时都是关着的。**", "inputFormat": "第一行有两个整数 $n$ 和 $m$，分别表示灯的数目和操作的数目。\n\n接下来有 $m$ 行，每行有三个整数，依次为：$c$、$a$、$b$。其中 $c$ 表示操作的种类。\n\n- 当 $c$ 的值为 $0$ 时，表示是第一种操作。\n- 当 $c$ 的值为 $1$ 时，表示是第二种操作。\n\n$a$ 和 $b$ 则分别表示了操作区间的左右边界。", "outputFormat": "每当遇到第二种操作时，输出一行，包含一个整数，表示此时在查询的区间中打开的灯的数目。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $2\\le n\\le 10^5$，$1\\le m\\le 10^5$，$1\\le a,b\\le n$，$c\\in\\{0,1\\}$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2009] Switches", "background": "", "description": "There are $n$ lights in a row, numbered from left to right as $1, 2, \\ldots, n$. Then $m$ operations are performed in order.\n\nThere are two types of operations:\n1. Given an interval $[a, b]$, flip the state of every light whose index is in this interval (turn on lights that are off, and turn off lights that are on).\n2. Given an interval $[a, b]$, output how many lights are on within this interval.\n\nAll lights are initially off.", "inputFormat": "The first line contains two integers $n$ and $m$, the number of lights and the number of operations, respectively.\n\nEach of the next $m$ lines contains three integers $c$, $a$, and $b$, where $c$ denotes the type of operation.\n- If $c = 0$, it is the first type of operation.\n- If $c = 1$, it is the second type of operation.\n\n$a$ and $b$ are the left and right boundaries of the operation interval, respectively.", "outputFormat": "For each operation of the second type, output one line containing an integer, the number of lights that are on in the queried interval.", "hint": "Constraints.\n\nFor all testdata, it is guaranteed that $2 \\le n \\le 10^5$, $1 \\le m \\le 10^5$, $1 \\le a, b \\le n$, and $c \\in \\{0, 1\\}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2009] 开关", "background": "", "description": "现有 $n$ 盏灯排成一排，从左到右依次编号为：$1$，$2$，……，$n$。然后依次执行 $m$ 项操作。\n\n操作分为两种：\n\n1. 指定一个区间 $[a,b]$，然后改变编号在这个区间内的灯的状态（把开着的灯关上，关着的灯打开）；\n2. 指定一个区间 $[a,b]$，要求你输出这个区间内有多少盏灯是打开的。\n\n**灯在初始时都是关着的。**", "inputFormat": "第一行有两个整数 $n$ 和 $m$，分别表示灯的数目和操作的数目。\n\n接下来有 $m$ 行，每行有三个整数，依次为：$c$、$a$、$b$。其中 $c$ 表示操作的种类。\n\n- 当 $c$ 的值为 $0$ 时，表示是第一种操作。\n- 当 $c$ 的值为 $1$ 时，表示是第二种操作。\n\n$a$ 和 $b$ 则分别表示了操作区间的左右边界。", "outputFormat": "每当遇到第二种操作时，输出一行，包含一个整数，表示此时在查询的区间中打开的灯的数目。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $2\\le n\\le 10^5$，$1\\le m\\le 10^5$，$1\\le a,b\\le n$，$c\\in\\{0,1\\}$。", "locale": "zh-CN"}}}
{"pid": "P3871", "type": "P", "difficulty": 4, "samples": [["6\n1 2 13 14 15 16\n5\nadd 5\nadd 3\nmid\nadd 20\nmid\n", "5\n13\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "各省省选", "平衡树", "O2优化", "排序", "天津"], "title": "[TJOI2010] 中位数", "background": "", "description": "给定一个由 $N$ 个元素组成的整数序列，现在有两种操作：\n\n- $\\texttt{1 add }\\textit{a}$：在该序列的最后添加一个整数 $a$，组成长度为 $N + 1$ 的整数序列。\n- $\\texttt{2 mid}$：输出当前序列的中位数。\n\n中位数是指将一个序列按照从小到大排序后处在中间位置的数。（若序列长度为偶数，则指处在中间位置的两个数中较小的那个）\n\n例 $1$：$[1, 2, 13, 14, 15, 16]$ 中位数为 $13$。  \n例 $2$：$[1, 3, 5, 7, 10, 11, 17]$ 中位数为 $7$。  \n例 $3$：$[1, 1, 1, 2, 3]$ 中位数为 $1$。\n", "inputFormat": "第一行为初始序列长度 $N$。第二行为 $N$ 个整数，表示整数序列，数字之间用空格分隔。第三行为操作数 $M$，即要进行 $M$ 次操作。下面为 $M$ 行，每行输入格式如题意所述。\n", "outputFormat": "对于每个 $\\verb!mid!$ 操作输出中位数的值。", "hint": "### 数据范围及约定\n\n- 对于 $30\\%$ 的数据，$1 ≤ N ≤ 10,000$，$0 ≤ M ≤ 1,000$。\n- 对于 $100\\%$ 的数据，$1 ≤ N ≤ 100,000$，$0 ≤ M ≤ 10,000$。\n\n序列中整数的绝对值不超过 $10^9$，序列中的数可能有重复。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2010] Median", "background": "", "description": "Given an integer sequence of $N$ elements, there are two operations:\n\n- $\\texttt{1 add }\\textit{a}$: Append an integer $a$ to the end of the sequence, forming a sequence of length $N + 1$.\n- $\\texttt{2 mid}$: Output the median of the current sequence.\n\nThe median is the number that lies in the middle after sorting the sequence in non-decreasing order. If the sequence length is even, it is the smaller of the two middle numbers.\n\nExample 1: $[1, 2, 13, 14, 15, 16]$ has median $13$.  \nExample 2: $[1, 3, 5, 7, 10, 11, 17]$ has median $7$.  \nExample 3: $[1, 1, 1, 2, 3]$ has median $1$.", "inputFormat": "The first line contains the initial sequence length $N$.  \nThe second line contains $N$ integers, representing the sequence, separated by spaces.  \nThe third line contains the number of operations $M$, meaning you will perform $M$ operations.  \nThen follow $M$ lines, each in the format described above.", "outputFormat": "For each $\\verb!mid!$ operation, output the value of the median.", "hint": "### Constraints\n\n- For $30\\%$ of the testdata, $1 \\le N \\le 10{,}000$, $0 \\le M \\le 1{,}000$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 100{,}000$, $0 \\le M \\le 10{,}000$.\n\nThe absolute value of each integer in the sequence does not exceed $10^9$, and numbers in the sequence may repeat.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2010] 中位数", "background": "", "description": "给定一个由 $N$ 个元素组成的整数序列，现在有两种操作：\n\n- $\\texttt{1 add }\\textit{a}$：在该序列的最后添加一个整数 $a$，组成长度为 $N + 1$ 的整数序列。\n- $\\texttt{2 mid}$：输出当前序列的中位数。\n\n中位数是指将一个序列按照从小到大排序后处在中间位置的数。（若序列长度为偶数，则指处在中间位置的两个数中较小的那个）\n\n例 $1$：$[1, 2, 13, 14, 15, 16]$ 中位数为 $13$。  \n例 $2$：$[1, 3, 5, 7, 10, 11, 17]$ 中位数为 $7$。  \n例 $3$：$[1, 1, 1, 2, 3]$ 中位数为 $1$。\n", "inputFormat": "第一行为初始序列长度 $N$。第二行为 $N$ 个整数，表示整数序列，数字之间用空格分隔。第三行为操作数 $M$，即要进行 $M$ 次操作。下面为 $M$ 行，每行输入格式如题意所述。\n", "outputFormat": "对于每个 $\\verb!mid!$ 操作输出中位数的值。", "hint": "### 数据范围及约定\n\n- 对于 $30\\%$ 的数据，$1 ≤ N ≤ 10,000$，$0 ≤ M ≤ 1,000$。\n- 对于 $100\\%$ 的数据，$1 ≤ N ≤ 100,000$，$0 ≤ M ≤ 10,000$。\n\n序列中整数的绝对值不超过 $10^9$，序列中的数可能有重复。", "locale": "zh-CN"}}}
{"pid": "P3872", "type": "P", "difficulty": 6, "samples": [["2 2\n100 -50\n1 2 49\n2 1 10\n", "51"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "各省省选", "图论建模", "最小割", "天津"], "title": "[TJOI2010] 电影迷", "background": null, "description": "小A是一个电影迷，他收集了上百部的电影，打算从中挑出若干部在假期看完。他根据自己的口味和网上的介绍，对每部电影 $X$ 都打了一个分数 $v_X$，表示自己喜欢的程度。这个分数的范围在 $-1000$ 至 $1000$ 之间，越大表示越喜欢。小A每看一部电影 $X$，他的体验值就会加上 $v_X$。\n\n另外，因为某些电影是组成一个系列的，比如著名的《终结者》系列、《黑客帝国》系列等等，如果小A只看了前一部而没有看后一部的话，他就会觉得不是很爽。准确来讲，对于任意两部不同的电影 $X,Y$，他们可能存在一个依赖值 $d_{X,Y}$，表示如果小A看了 $X$ 但是没看 $Y$，他的体验值就会减少 $d_{X,Y}$。（注意与观看的顺序无关，只要两部都看过，就不会减少体验值）\n\n现在他要选出若干电影来看，使得得到的总的体验值最大。如果他无法得到正的体验值，就输出 $0$。", "inputFormat": "输入的第一行是两个整数：电影总数 $N$ 和依赖关系数目 $M$。第二行包含用空格隔开的 $N$ 个数，表示对每部电影的打分。接下来 $M$ 行，每行包含三个整数 $X,Y,d_{X,Y}$，表示一个依赖关系。每个有序对 $(X,Y)$ 最多出现一次。$\\pod{1\\le X,Y\\le N}$", "outputFormat": "输出一个整数，表示小A能得到的最大体验值。", "hint": "如果小A只看电影 $1$，体验值为 $100-49=51$。如果只看电影2，体验值为 $-50-10=-60$。如果两部都看，体验值为 $100+(-50)=50$。所以应该只看电影 $1$。\n\n### 数据规模与约定\n\n对于 $20\\%$ 的数据，$1\\le N\\le 15$。\n\n对于 $100\\%$ 的数据，$1\\le N\\le 100,-1000\\le v_X \\le 1000,0<d_{X,Y}\\le 1000$\n\n每个测试点时限1秒", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2010] Movie Buff", "background": "", "description": "Xiao A is a movie buff. He has collected hundreds of movies and plans to pick some to watch during the holidays. Based on his taste and online information, he assigned to each movie $X$ a score $v_X$ indicating how much he likes it. The score range is from $-1000$ to $1000$, and a larger score means he likes it more. Each time Xiao A watches a movie $X$, his experience increases by $v_X$.\n\nIn addition, because some movies belong to the same series (for example, the famous Terminator series, The Matrix series, etc.), if Xiao A watches an earlier one but not a later one, he will feel uncomfortable. More precisely, for any two distinct movies $X, Y$, there may be a dependency value $d_{X,Y}$, meaning that if Xiao A watches $X$ but not $Y$, his experience will decrease by $d_{X,Y}$. (Note that the viewing order does not matter; as long as both are watched, there is no penalty.)\n\nNow he wants to select some movies to watch to maximize the total experience. If he cannot obtain a positive experience, output $0$.", "inputFormat": "- The first line contains two integers: the total number of movies $N$ and the number of dependency relations $M$.\n- The second line contains $N$ space-separated numbers, the scores for each movie.\n- Each of the next $M$ lines contains three integers $X, Y, d_{X,Y}$, representing a dependency relation.\n- Each ordered pair $(X, Y)$ appears at most once. $1 \\le X, Y \\le N$.", "outputFormat": "Output one integer, the maximum experience Xiao A can obtain.", "hint": "If Xiao A only watches movie $1$, the experience is $100 - 49 = 51$. If he only watches movie $2$, the experience is $-50 - 10 = -60$. If he watches both, the experience is $100 + (-50) = 50$. Therefore, he should only watch movie $1$.\n\nConstraints:\n- For $20\\%$ of the testdata, $1 \\le N \\le 15$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 100$, $-1000 \\le v_X \\le 1000$, $0 < d_{X,Y} \\le 1000$.\n- Time limit per test point is 1 second.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2010] 电影迷", "background": null, "description": "小A是一个电影迷，他收集了上百部的电影，打算从中挑出若干部在假期看完。他根据自己的口味和网上的介绍，对每部电影 $X$ 都打了一个分数 $v_X$，表示自己喜欢的程度。这个分数的范围在 $-1000$ 至 $1000$ 之间，越大表示越喜欢。小A每看一部电影 $X$，他的体验值就会加上 $v_X$。\n\n另外，因为某些电影是组成一个系列的，比如著名的《终结者》系列、《黑客帝国》系列等等，如果小A只看了前一部而没有看后一部的话，他就会觉得不是很爽。准确来讲，对于任意两部不同的电影 $X,Y$，他们可能存在一个依赖值 $d_{X,Y}$，表示如果小A看了 $X$ 但是没看 $Y$，他的体验值就会减少 $d_{X,Y}$。（注意与观看的顺序无关，只要两部都看过，就不会减少体验值）\n\n现在他要选出若干电影来看，使得得到的总的体验值最大。如果他无法得到正的体验值，就输出 $0$。", "inputFormat": "输入的第一行是两个整数：电影总数 $N$ 和依赖关系数目 $M$。第二行包含用空格隔开的 $N$ 个数，表示对每部电影的打分。接下来 $M$ 行，每行包含三个整数 $X,Y,d_{X,Y}$，表示一个依赖关系。每个有序对 $(X,Y)$ 最多出现一次。$\\pod{1\\le X,Y\\le N}$", "outputFormat": "输出一个整数，表示小A能得到的最大体验值。", "hint": "如果小A只看电影 $1$，体验值为 $100-49=51$。如果只看电影2，体验值为 $-50-10=-60$。如果两部都看，体验值为 $100+(-50)=50$。所以应该只看电影 $1$。\n\n### 数据规模与约定\n\n对于 $20\\%$ 的数据，$1\\le N\\le 15$。\n\n对于 $100\\%$ 的数据，$1\\le N\\le 100,-1000\\le v_X \\le 1000,0<d_{X,Y}\\le 1000$\n\n每个测试点时限1秒", "locale": "zh-CN"}}}
{"pid": "P3873", "type": "P", "difficulty": 5, "samples": [["2 3\n4 5\n6 7\n", "59"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "2010", "各省省选", "矩阵加速", "线性递推", "构造", "天津"], "title": "[TJOI2010] 天气预报", "background": "", "description": "A 公司的天气预报系统的原理如下：用一个大于等于 $0$，小于等于 $4146$ 的整数来表示这一天的天气情况，在预测未来某一天的天气情况时，要根据此前 $n$ 天的天气情况来预测，如果用 $w_i$ 表示第 $i$ 天的天气情况（$i>n$），那么 $w_i=(a_1\\times w_{i-1}+a_2\\times w_{i-2}+\\cdots+a_{n}\\times w_{i-n})\\mod4147$，其中 $a_1,a_2,\\cdots ,a_n$ 是已知常数。现给出前 $n$ 天的天气情况，问第 $m$ 天的天气预测结果是什么。", "inputFormat": "输入数据的第一行是两个正整数 $n$ 和 $m$，第二行有 $n$ 个非负整数，分别为 $w_n,w_{n-1},\\cdots,w_1$。第三行又有 $n$ 个非负整数，分别表示 $a_1,a_2,\\ldots,a_n$。", "outputFormat": "输出一个整数，表示对第 $m$ 天的天气预测结果。", "hint": "$1\\le n\\le 100$，$n<m\\le10^7$，$0\\le a_i,w_i\\le 4146$。\n\n每个测试点时限 1.5 秒", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2010] Weather Forecast", "background": "", "description": "Company A's weather forecasting system works as follows: it represents the weather of a day by an integer greater than or equal to $0$ and less than or equal to $4146$. To predict the weather of some future day, it uses the weather of the previous $n$ days. If we denote the weather of day $i$ by $w_i$ ($i>n$), then $w_i=(a_1\\times w_{i-1}+a_2\\times w_{i-2}+\\cdots+a_{n}\\times w_{i-n})\\mod4147$, where $a_1,a_2,\\cdots ,a_n$ are known constants. Given the weather of the first $n$ days, find the prediction for day $m$.", "inputFormat": "The first line of input contains two positive integers $n$ and $m$. The second line contains $n$ non-negative integers, namely $w_n,w_{n-1},\\cdots,w_1$. The third line contains $n$ non-negative integers, namely $a_1,a_2,\\ldots,a_n$.", "outputFormat": "Output a single integer, which is the predicted weather for day $m$.", "hint": "$1\\le n\\le 100$, $n<m\\le10^7$, $0\\le a_i,w_i\\le 4146$.\n\nTime limit per test point: 1.5 seconds.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2010] 天气预报", "background": "", "description": "A 公司的天气预报系统的原理如下：用一个大于等于 $0$，小于等于 $4146$ 的整数来表示这一天的天气情况，在预测未来某一天的天气情况时，要根据此前 $n$ 天的天气情况来预测，如果用 $w_i$ 表示第 $i$ 天的天气情况（$i>n$），那么 $w_i=(a_1\\times w_{i-1}+a_2\\times w_{i-2}+\\cdots+a_{n}\\times w_{i-n})\\mod4147$，其中 $a_1,a_2,\\cdots ,a_n$ 是已知常数。现给出前 $n$ 天的天气情况，问第 $m$ 天的天气预测结果是什么。", "inputFormat": "输入数据的第一行是两个正整数 $n$ 和 $m$，第二行有 $n$ 个非负整数，分别为 $w_n,w_{n-1},\\cdots,w_1$。第三行又有 $n$ 个非负整数，分别表示 $a_1,a_2,\\ldots,a_n$。", "outputFormat": "输出一个整数，表示对第 $m$ 天的天气预测结果。", "hint": "$1\\le n\\le 100$，$n<m\\le10^7$，$0\\le a_i,w_i\\le 4146$。\n\n每个测试点时限 1.5 秒", "locale": "zh-CN"}}}
{"pid": "P3874", "type": "P", "difficulty": 5, "samples": [["3 1\n20 10 20\n1 1 1\n1 2\n2 3\n", "20.00"], ["3 2\n20 10 20\n1 1 1\n1 2\n2 3\n", "16.67"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2010", "二分", "各省省选", "树形 DP", "分数规划", "天津"], "title": "[TJOI2010] 砍树", "background": "小 A 在果园里发现了一棵结满果子的树，于是他就打起了坏主意，他打算把树的一部分砍下来带回家。", "description": "我们可以把这棵树表示成一个树型的结构，也就是说，任意两个点之间有且仅有一条路径。在每个点 $i$ 处都结着一个水果，每个水果有一个价值 $v_i$ 和重量 $w_i$。小 A 想带走树的一部分（或全部），包含至少 $K$ 个结点（也就是至少 $K$ 个水果），且这些水果的平均价值尽可能高。平均价值是指水果总的价值除以总的重量。注意小 A 砍下的树必须是在原来的树中连通的一部分。", "inputFormat": "第一行包含两个数 $N$ 和 $K$，分别表示树的结点数和小 A 至少应带走的水果数。\n\n第二行包含空格隔开的 $N$ 个数，分别表示每个结点处水果的价值 $v_i$。\n\n第三行包含空格隔开的 $N$ 个数，分别表示每个水果的重量 $w_i$。\n\n按下来 $N-1$ 行，每行包含两个数 $a_i$ 和 $b_i$（$1 \\le a_i,b_i \\le N$），表示在结点 $a_i$ 和 $b_i$ 之间有一条边。输入保证是一棵正确的树结构。", "outputFormat": "输出一行，包含一个数，表示最大可能的平均价值。四舍五入到小数点后两位。\n", "hint": "### 数据规模与约定\n\n- 对 $20\\%$ 的数据，$1 \\le N \\le 16$；\n- 对 $100\\%$ 的数据，$1 \\le N \\le 100$，$1 \\le K \\le N$，$1 \\le v_i \\le 10000$，$1 \\le w_i \\le 10000$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2010] Cutting the Tree", "background": "Xiao A found a tree full of fruits in an orchard, and he came up with a mischievous idea: he plans to cut off part of the tree and take it home.", "description": "We can represent this tree as a tree-structured graph, meaning there is exactly one path between any two nodes. At each node $i$, there is a fruit with value $v_i$ and weight $w_i$. Xiao A wants to take away a connected part (or the whole) of the tree that contains at least $K$ nodes (that is, at least $K$ fruits), such that the average value of these fruits is as high as possible. The average value is defined as the total value of the fruits divided by their total weight. Note that the part Xiao A cuts must be a connected subgraph of the original tree.", "inputFormat": "The first line contains two numbers $N$ and $K$, representing the number of nodes in the tree and the minimum number of fruits Xiao A should take.\n\nThe second line contains $N$ space-separated numbers, representing the value $v_i$ of the fruit at each node.\n\nThe third line contains $N$ space-separated numbers, representing the weight $w_i$ of each fruit.\n\nThe next $N - 1$ lines each contain two numbers $a_i$ and $b_i$ ($1 \\le a_i, b_i \\le N$), indicating that there is an edge between nodes $a_i$ and $b_i$. The input is guaranteed to describe a valid tree.", "outputFormat": "Output one line containing a single number, the maximum possible average value, rounded to two decimal places.", "hint": "- Constraints:\n  - For $20\\%$ of the testdata, $1 \\le N \\le 16$.\n  - For $100\\%$ of the testdata, $1 \\le N \\le 100$, $1 \\le K \\le N$, $1 \\le v_i \\le 10000$, $1 \\le w_i \\le 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2010] 砍树", "background": "小 A 在果园里发现了一棵结满果子的树，于是他就打起了坏主意，他打算把树的一部分砍下来带回家。", "description": "我们可以把这棵树表示成一个树型的结构，也就是说，任意两个点之间有且仅有一条路径。在每个点 $i$ 处都结着一个水果，每个水果有一个价值 $v_i$ 和重量 $w_i$。小 A 想带走树的一部分（或全部），包含至少 $K$ 个结点（也就是至少 $K$ 个水果），且这些水果的平均价值尽可能高。平均价值是指水果总的价值除以总的重量。注意小 A 砍下的树必须是在原来的树中连通的一部分。", "inputFormat": "第一行包含两个数 $N$ 和 $K$，分别表示树的结点数和小 A 至少应带走的水果数。\n\n第二行包含空格隔开的 $N$ 个数，分别表示每个结点处水果的价值 $v_i$。\n\n第三行包含空格隔开的 $N$ 个数，分别表示每个水果的重量 $w_i$。\n\n按下来 $N-1$ 行，每行包含两个数 $a_i$ 和 $b_i$（$1 \\le a_i,b_i \\le N$），表示在结点 $a_i$ 和 $b_i$ 之间有一条边。输入保证是一棵正确的树结构。", "outputFormat": "输出一行，包含一个数，表示最大可能的平均价值。四舍五入到小数点后两位。\n", "hint": "### 数据规模与约定\n\n- 对 $20\\%$ 的数据，$1 \\le N \\le 16$；\n- 对 $100\\%$ 的数据，$1 \\le N \\le 100$，$1 \\le K \\le N$，$1 \\le v_i \\le 10000$，$1 \\le w_i \\le 10000$。", "locale": "zh-CN"}}}
{"pid": "P3875", "type": "P", "difficulty": 5, "samples": [["3\n1 3 4 3\n6 7 6 3\n4 6 7 6\n", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "线段树", "各省省选", "扫描线", "天津"], "title": "[TJOI2010] 被污染的河流", "background": "有一座城市，城市里有许多条人工河，河流的流向都是水平或者竖直的。为了方便市民用水，政府将河流设计成网格状。在水平方向上和竖直方向上，相邻河流的距离都是 $1$ 公里。河流围出许多格子，每个格子就是一个社区，社区里的居民可以到社区周边四条河段中的任意一处打水喝。\n", "description": "郁闷的是，不久之后，有些不法商人修建了工厂，污染了河流。河边许多居民喝了被污染的水，生病了。政府派出专员小强调查污染情况。地理专家小强行动迅速，很快给出了污染分布。他给出了一张污染清单。清单列出了被污染的河段，所有能喝到该河段水的居民都有可能生病（河段的端点处忽略不计）。但是，笨笨的小强怎么也算不出具体会有多少个社区的居民会生病，所以，他请你来帮帮忙。\n\n![](https://cdn.luogu.com.cn/upload/pic/6840.png)\n", "inputFormat": "输入文件的第一行是一个整数 $N$，表示被污染的河段的数目。\n\n接下来 $N$ 行，每行 $4$ 个整数 $x_1,y_1,x_2,y_2$，表示被污染河段的起始位置和结束位置。每行输入的两个位置保证不重合，并且满足 $x_1=x_2$ 或 $y_1=y_2$。\n", "outputFormat": "输出一个整数 $A$，表示有 $A$ 个社区的居民会喝到被污染的水。\n", "hint": "- 对于 $10\\%$ 的数据，$1 \\le  x_1,y_1,x_2,y_2 \\le 100$，$1\\le N \\le 100$；\n- 对于 $30\\%$ 的数据，$1 \\le x_1,y_1,x_2,y_2 \\le 10^4$，$1\\le N \\le 100$；\n- 对于 $100\\%$ 的数据，$1 \\le x_1,y_1,x_2,y_2 \\le 10^5$，$1\\le N \\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2010] Polluted Rivers", "background": "There is a city with many artificial rivers, each flowing either horizontally or vertically. For residents’ convenience, the rivers are arranged in a grid. The distance between adjacent rivers in both the horizontal and vertical directions is $1$ kilometer. The rivers enclose many cells, each of which is a community. Residents of a community can fetch water at any of the four river segments surrounding the community.", "description": "Unfortunately, not long after, some unscrupulous business owners built factories and polluted the rivers. Many residents living by the rivers drank polluted water and became ill. The government sent an investigator, Xiaoqiang (pinyin), to examine the pollution. The geography expert Xiaoqiang acted quickly and soon produced a pollution report. The report lists the polluted river segments. All residents who can fetch water from any such segment may get sick (the endpoints of a segment are ignored). However, Xiaoqiang could not figure out exactly how many communities’ residents would become ill, so he has asked for your help.\n\n![](https://cdn.luogu.com.cn/upload/pic/6840.png)", "inputFormat": "The first line contains an integer $N$, the number of polluted river segments.\n\nEach of the next $N$ lines contains $4$ integers $x_1, y_1, x_2, y_2$, giving the start and end positions of a polluted segment. The two positions on each line are guaranteed to be distinct and satisfy $x_1 = x_2$ or $y_1 = y_2$.", "outputFormat": "Output a single integer $A$, indicating that there are $A$ communities whose residents will drink polluted water.", "hint": "- For $10\\%$ of the testdata, $1 \\le x_1, y_1, x_2, y_2 \\le 100$, $1 \\le N \\le 100$.\n- For $30\\%$ of the testdata, $1 \\le x_1, y_1, x_2, y_2 \\le 10^4$, $1 \\le N \\le 100$.\n- For $100\\%$ of the testdata, $1 \\le x_1, y_1, x_2, y_2 \\le 10^5$, $1 \\le N \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2010] 被污染的河流", "background": "有一座城市，城市里有许多条人工河，河流的流向都是水平或者竖直的。为了方便市民用水，政府将河流设计成网格状。在水平方向上和竖直方向上，相邻河流的距离都是 $1$ 公里。河流围出许多格子，每个格子就是一个社区，社区里的居民可以到社区周边四条河段中的任意一处打水喝。\n", "description": "郁闷的是，不久之后，有些不法商人修建了工厂，污染了河流。河边许多居民喝了被污染的水，生病了。政府派出专员小强调查污染情况。地理专家小强行动迅速，很快给出了污染分布。他给出了一张污染清单。清单列出了被污染的河段，所有能喝到该河段水的居民都有可能生病（河段的端点处忽略不计）。但是，笨笨的小强怎么也算不出具体会有多少个社区的居民会生病，所以，他请你来帮帮忙。\n\n![](https://cdn.luogu.com.cn/upload/pic/6840.png)\n", "inputFormat": "输入文件的第一行是一个整数 $N$，表示被污染的河段的数目。\n\n接下来 $N$ 行，每行 $4$ 个整数 $x_1,y_1,x_2,y_2$，表示被污染河段的起始位置和结束位置。每行输入的两个位置保证不重合，并且满足 $x_1=x_2$ 或 $y_1=y_2$。\n", "outputFormat": "输出一个整数 $A$，表示有 $A$ 个社区的居民会喝到被污染的水。\n", "hint": "- 对于 $10\\%$ 的数据，$1 \\le  x_1,y_1,x_2,y_2 \\le 100$，$1\\le N \\le 100$；\n- 对于 $30\\%$ 的数据，$1 \\le x_1,y_1,x_2,y_2 \\le 10^4$，$1\\le N \\le 100$；\n- 对于 $100\\%$ 的数据，$1 \\le x_1,y_1,x_2,y_2 \\le 10^5$，$1\\le N \\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P3876", "type": "P", "difficulty": 6, "samples": [["2\n7 2\n3 1 2 4\n4 2 4 5 7\n3 1\n2 1 1\n", "Yes\nNo\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "各省省选", "天津"], "title": "[TJOI2010] 数字序列", "background": "", "description": "考虑一个由数字0,1,2,3组成的长度为n的序列，如果它是一个合法序列，那么它应当满足以下两个条件：\n\n1) 序列中任意相邻的两元素没有出现模式{'00', '11', '22', '33', '02', '20', '23', '32', '13', '31'}中的任一种;\n\n2) 序列满足m个约束条件，每个约束条件的形式均为：{p1, p2, ... pL}，它表示序列中的p1, p2, ..., pL这些位置的值不同。例如约束条件{1, 5, 11}表示序列中的第一个，第五个和第十一个元素两两各不相同。\n\n现在已知序列长度n，约束条件个数m以及这m个约束条件，问是否存在这样的合法序列。\n", "inputFormat": "输入文件的第一行是一个正整数T，表示文件中包含T组测试数据。从文件的第二行开始，将依次给出所有的测试数据。每个测试数据的第一行是两个整数n和m，它们的涵义如上面题目描述中所示。接下来有m行，每行描述一个约束条件，其中在描述第i个约束条件的行中，第一个数字是表示这个约束条件包含多少个元素的正整数Li，后面由Li个正整数给出第i个约束的具体情况。\n", "outputFormat": "共输出T行，对每组测试数据输出一行，如果存在满足条件的合法序列，输出\"Yes\"；否则，输出\"No\"。\n", "hint": "T ≤ 10，1 ≤ n ≤ 100000，0 ≤ m ≤ 5000，1 ≤ Li ≤ 100，1 ≤ pi ≤ n\n\n每个测试点时限1秒\n\n第一组样例中，序列0103012是满足要求的一个合法序列。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2010] Number Sequence", "background": "", "description": "Consider a sequence of length $n$ over digits 0, 1, 2, 3. If it is a valid sequence, it must satisfy both of the following:\n\n1) No adjacent pair appears as any pattern in {'00', '11', '22', '33', '02', '20', '23', '32', '13', '31'}.\n\n2) The sequence satisfies $m$ constraints. Each constraint is of the form {p1, p2, ... pL}, meaning the values at positions $p_1, p_2, \\ldots, p_L$ are pairwise distinct. For example, the constraint {1, 5, 11} means the 1st, 5th, and 11th elements are all different.\n\nGiven $n$, $m$, and these $m$ constraints, determine whether such a valid sequence exists.", "inputFormat": "The first line contains a positive integer $T$, the number of test cases. For each test case, the first line contains two integers $n$ and $m$ as described above. Then there are $m$ lines, each describing one constraint: in the $i$-th line, the first integer $L_i$ is the size of the constraint, followed by $L_i$ positive integers giving the positions in the $i$-th constraint.", "outputFormat": "Output $T$ lines. For each test case, print Yes if a valid sequence exists; otherwise, print No.", "hint": "Constraints:\n\n$T \\le 10$, $1 \\le n \\le 100000$, $0 \\le m \\le 5000$, $1 \\le L_i \\le 100$, $1 \\le p_i \\le n$.\n\nTime limit per test point: 1 second.\n\nIn the first sample, the sequence 0103012 is a valid sequence.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2010] 数字序列", "background": "", "description": "考虑一个由数字0,1,2,3组成的长度为n的序列，如果它是一个合法序列，那么它应当满足以下两个条件：\n\n1) 序列中任意相邻的两元素没有出现模式{'00', '11', '22', '33', '02', '20', '23', '32', '13', '31'}中的任一种;\n\n2) 序列满足m个约束条件，每个约束条件的形式均为：{p1, p2, ... pL}，它表示序列中的p1, p2, ..., pL这些位置的值不同。例如约束条件{1, 5, 11}表示序列中的第一个，第五个和第十一个元素两两各不相同。\n\n现在已知序列长度n，约束条件个数m以及这m个约束条件，问是否存在这样的合法序列。\n", "inputFormat": "输入文件的第一行是一个正整数T，表示文件中包含T组测试数据。从文件的第二行开始，将依次给出所有的测试数据。每个测试数据的第一行是两个整数n和m，它们的涵义如上面题目描述中所示。接下来有m行，每行描述一个约束条件，其中在描述第i个约束条件的行中，第一个数字是表示这个约束条件包含多少个元素的正整数Li，后面由Li个正整数给出第i个约束的具体情况。\n", "outputFormat": "共输出T行，对每组测试数据输出一行，如果存在满足条件的合法序列，输出\"Yes\"；否则，输出\"No\"。\n", "hint": "T ≤ 10，1 ≤ n ≤ 100000，0 ≤ m ≤ 5000，1 ≤ Li ≤ 100，1 ≤ pi ≤ n\n\n每个测试点时限1秒\n\n第一组样例中，序列0103012是满足要求的一个合法序列。\n", "locale": "zh-CN"}}}
{"pid": "P3877", "type": "P", "difficulty": 6, "samples": [["4\n3 4\n##..\n....\n....\n3 4\n##..\n....\n#...\n3 4\n##..\n#...\n#...\n3 4\n####\n#..#\n####\n", "YES\nNO\nYES\nNO\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "各省省选", "网络流", "天津"], "title": "[TJOI2010] 打扫房间", "background": "", "description": "学校新建了一批宿舍，值日生小A要把所有的空房间都打扫一遍。这些宿舍的布局很奇怪，整个建筑物里所有的房间组成一个N \\* M的矩阵，每个房间的东南西北四面墙上都有一个门通向隔壁房间。另外有些房间是堆放杂物的，无需打扫。小A想设计若干条打扫路线，使得恰好进出每个需打扫的房间各一次，而且进出每个房间不能通过同一个门。要求每条路线都是一个闭合的环线，并且每条路线经过的房间数大于2。\n\n如下面两图所示均为满足要求的打扫方案（灰色格子为放杂物的房间）：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6841.png) \n\n小A发现对于某些房间布局是不存在这样的满足要求的方案的。他请你写一个程序计算一下，对于一种给定的房间布局，满足要求的方案是否存在。\n", "inputFormat": "输入文件的第一行是一个整数T (1 ≤ T ≤ 10)，表示该文件中一共有T组数据。接下来依次是T组数据的信息。每组数据的第一行包含两个整数N和M，接下来的N行，每行包含M个字符，表示一个房间布局。字符'.'表示该房间需要打扫，'#'表示该房间是堆放杂物的，无需打扫。\n", "outputFormat": "共输出T行，对每组数据输出一行，为\"YES\"或\"NO\"，表示打扫方案存在与否。\n", "hint": "对50%的数据，3 ≤ N,M ≤ 12\n\n对100%的数据，3 ≤ N,M ≤ 30\n\n每个测试点时限1秒\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2010] Cleaning the Room", "background": "", "description": "A new batch of dormitories has been built at the school, and the student on duty, Xiao A, needs to clean all empty rooms. The layout of these dormitories is unusual: all rooms in the building form an $N \\times M$ grid. Each room has a door on each of its north, south, east, and west walls leading to the adjacent room. Some rooms are used for storage and do not need to be cleaned. Xiao A wants to design several cleaning routes such that each room that needs cleaning is entered and exited exactly once, and the same door must not be used to both enter and leave that room. Each route must be a closed cycle, and each route must pass through more than 2 rooms.\n\nAs shown in the two figures below, both are valid cleaning plans (gray cells are rooms used for storage):\n\n![](https://cdn.luogu.com.cn/upload/pic/6841.png)\n\nXiao A finds that for certain layouts, no plan satisfying the requirements exists. He asks you to write a program to determine, for a given room layout, whether a valid plan exists.", "inputFormat": "The first line contains an integer $T$ ($1 \\le T \\le 10$), indicating that there are $T$ groups of testdata in the file. Then follow the descriptions of the $T$ groups of testdata. For each group, the first line contains two integers $N$ and $M$. The next $N$ lines each contain $M$ characters describing a room layout. A '.' means the room needs cleaning; a '#' means the room is used for storage and does not need cleaning.", "outputFormat": "Output $T$ lines. For each group, output one line, either \"YES\" or \"NO\", indicating whether such a cleaning plan exists.", "hint": "- For 50% of the testdata, $3 \\le N, M \\le 12$.\n- For 100% of the testdata, $3 \\le N, M \\le 30$.\n- Time limit per test point: 1 second.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2010] 打扫房间", "background": "", "description": "学校新建了一批宿舍，值日生小A要把所有的空房间都打扫一遍。这些宿舍的布局很奇怪，整个建筑物里所有的房间组成一个N \\* M的矩阵，每个房间的东南西北四面墙上都有一个门通向隔壁房间。另外有些房间是堆放杂物的，无需打扫。小A想设计若干条打扫路线，使得恰好进出每个需打扫的房间各一次，而且进出每个房间不能通过同一个门。要求每条路线都是一个闭合的环线，并且每条路线经过的房间数大于2。\n\n如下面两图所示均为满足要求的打扫方案（灰色格子为放杂物的房间）：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6841.png) \n\n小A发现对于某些房间布局是不存在这样的满足要求的方案的。他请你写一个程序计算一下，对于一种给定的房间布局，满足要求的方案是否存在。\n", "inputFormat": "输入文件的第一行是一个整数T (1 ≤ T ≤ 10)，表示该文件中一共有T组数据。接下来依次是T组数据的信息。每组数据的第一行包含两个整数N和M，接下来的N行，每行包含M个字符，表示一个房间布局。字符'.'表示该房间需要打扫，'#'表示该房间是堆放杂物的，无需打扫。\n", "outputFormat": "共输出T行，对每组数据输出一行，为\"YES\"或\"NO\"，表示打扫方案存在与否。\n", "hint": "对50%的数据，3 ≤ N,M ≤ 12\n\n对100%的数据，3 ≤ N,M ≤ 30\n\n每个测试点时限1秒\n", "locale": "zh-CN"}}}
{"pid": "P3878", "type": "P", "difficulty": 5, "samples": [["2\n3\n2 2 4\n4\n1 2 3 6\n", "0\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "各省省选", "O2优化", "模拟退火", "进制", "天津", "折半搜索 meet in the middle"], "title": "[TJOI2010] 分金币", "background": "", "description": "现在有 $n$ 枚金币，它们可能会有不同的价值，第 $i$ 枚金币的价值为 $v_i$。\n\n现在要把它们分成两部分，要求这两部分金币数目之差不超过 $1$，问这样分成的两部分金币的价值之差最小是多少？\n\n", "inputFormat": "**本题单个测试点内有多组测试数据**。\n\n输入的第一行是一个正整数 $T$，表示该测试点内数据组数。\n\n对于每组测试数据的格式为：\n\n每组测试数据占两行。\n\n第一行是一个整数 $n$，表示金币的个数。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个金币的价值 $v_i$。", "outputFormat": "对于每组数据输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n- 对 $30\\%$ 的数据，保证 $1 \\leq v_i \\leq 1000$\n- 对于 $100\\%$ 的数据，保证 $1 \\leq T \\leq 20$，$1 \\leq n \\leq 30$，$1 \\leq v_i \\leq 2^{30}$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2010] Dividing Coins", "background": "", "description": "There are $n$ coins, which may have different values. The value of the $i$-th coin is $v_i$.\n\nNow we need to split them into two parts such that the difference in the numbers of coins does not exceed $1$. What is the minimum possible difference between the total values of the two parts?", "inputFormat": "This problem contains multiple sets of testdata within a single test point.\n\nThe first line contains a positive integer $T$, denoting the number of test cases in this test point.\n\nFor each test case:\n\nEach test case consists of two lines.\n\nThe first line contains an integer $n$, denoting the number of coins.\n\nThe second line contains $n$ integers. The $i$-th integer denotes the value $v_i$ of the $i$-th coin.", "outputFormat": "For each test case, output one line with a single integer denoting the answer.", "hint": "Constraints\n\n- For $30\\%$ of the data, it is guaranteed that $1 \\leq v_i \\leq 1000$.\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\leq T \\leq 20$, $1 \\leq n \\leq 30$, $1 \\leq v_i \\leq 2^{30}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2010] 分金币", "background": "", "description": "现在有 $n$ 枚金币，它们可能会有不同的价值，第 $i$ 枚金币的价值为 $v_i$。\n\n现在要把它们分成两部分，要求这两部分金币数目之差不超过 $1$，问这样分成的两部分金币的价值之差最小是多少？\n\n", "inputFormat": "**本题单个测试点内有多组测试数据**。\n\n输入的第一行是一个正整数 $T$，表示该测试点内数据组数。\n\n对于每组测试数据的格式为：\n\n每组测试数据占两行。\n\n第一行是一个整数 $n$，表示金币的个数。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个金币的价值 $v_i$。", "outputFormat": "对于每组数据输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n- 对 $30\\%$ 的数据，保证 $1 \\leq v_i \\leq 1000$\n- 对于 $100\\%$ 的数据，保证 $1 \\leq T \\leq 20$，$1 \\leq n \\leq 30$，$1 \\leq v_i \\leq 2^{30}$。", "locale": "zh-CN"}}}
{"pid": "P3879", "type": "P", "difficulty": 2, "samples": [["3\n9 you are a good boy ha ha o yeah\n13 o my god you like bleach naruto one piece and so do i\n11 but i do not think you will get all the points\n5\nyou\ni\no\nall\nnaruto\n", "1 2 3\n2 3\n1 2\n3\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "2010", "各省省选", "哈希 hashing", "字典树 Trie", "天津", "STL"], "title": "[TJOI2010] 阅读理解", "background": "", "description": "英语老师留了 $N$ 篇阅读理解作业，但是每篇英文短文都有很多生词需要查字典，为了节约时间，现在要做个统计，算一算某些生词都在哪几篇短文中出现过。", "inputFormat": "第一行为整数 $N$ ，表示短文篇数，其中每篇短文只含空格和小写字母。\n\n按下来的 $N$ 行，每行描述一篇短文。每行的开头是一个整数 $L$ ，表示这篇短文由 $L$ 个单词组成。接下来是 $L$ 个单词，单词之间用一个空格分隔。\n\n然后为一个整数 $M$ ，表示要做几次询问。后面有 $M$ 行，每行表示一个要统计的生词。\n", "outputFormat": "对于每个生词输出一行，统计其在哪几篇短文中出现过，并按从小到大输出短文的序号，序号不应有重复，序号之间用一个空格隔开（注意第一个序号的前面和最后一个序号的后面不应有空格）。如果该单词一直没出现过，则输出一个空行。\n", "hint": "对于 $30\\%$ 的数据， $1\\le M\\le 10^3$ 。\n\n对于 $100\\%$ 的数据，$1\\le M\\le 10^4$，$1\\le N\\le 10^3$ 。\n\n每篇短文长度（含相邻单词之间的空格）$\\le 5\\times 10^3$ 字符，每个单词长度 $\\le 20$ 字符。\n\n感谢@钟梓俊添加的一组数据。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2010] Reading Comprehension", "background": "", "description": "The English teacher assigned $N$ reading-comprehension passages. Each passage contains many unfamiliar words that would require checking a dictionary. To save time, we want to collect statistics to determine in which passages certain words appear.", "inputFormat": "The first line contains an integer $N$, the number of passages. Each passage contains only spaces and lowercase letters.\n\nThe next $N$ lines each describe one passage. Each line begins with an integer $L$, the number of words in that passage. Then follow $L$ words, separated by a single space.\n\nThen an integer $M$ follows, the number of queries. After that, there are $M$ lines, each containing one word to query.", "outputFormat": "For each query word, output one line listing the indices of the passages in which it appears, in ascending order, without duplicates. Indices are separated by a single space (note that there should be no space before the first index or after the last index). If the word never appears, output an empty line.", "hint": "For $30\\%$ of the testdata, $1\\le M\\le 10^3$.\n\nFor $100\\%$ of the testdata, $1\\le M\\le 10^4$, $1\\le N\\le 10^3$.\n\nEach passage length (including spaces between adjacent words) $\\le 5\\times 10^3$ characters, and each word length $\\le 20$ characters.\n\nThanks to @钟梓俊 for adding a set of testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2010] 阅读理解", "background": "", "description": "英语老师留了 $N$ 篇阅读理解作业，但是每篇英文短文都有很多生词需要查字典，为了节约时间，现在要做个统计，算一算某些生词都在哪几篇短文中出现过。", "inputFormat": "第一行为整数 $N$ ，表示短文篇数，其中每篇短文只含空格和小写字母。\n\n按下来的 $N$ 行，每行描述一篇短文。每行的开头是一个整数 $L$ ，表示这篇短文由 $L$ 个单词组成。接下来是 $L$ 个单词，单词之间用一个空格分隔。\n\n然后为一个整数 $M$ ，表示要做几次询问。后面有 $M$ 行，每行表示一个要统计的生词。\n", "outputFormat": "对于每个生词输出一行，统计其在哪几篇短文中出现过，并按从小到大输出短文的序号，序号不应有重复，序号之间用一个空格隔开（注意第一个序号的前面和最后一个序号的后面不应有空格）。如果该单词一直没出现过，则输出一个空行。\n", "hint": "对于 $30\\%$ 的数据， $1\\le M\\le 10^3$ 。\n\n对于 $100\\%$ 的数据，$1\\le M\\le 10^4$，$1\\le N\\le 10^3$ 。\n\n每篇短文长度（含相邻单词之间的空格）$\\le 5\\times 10^3$ 字符，每个单词长度 $\\le 20$ 字符。\n\n感谢@钟梓俊添加的一组数据。", "locale": "zh-CN"}}}
{"pid": "P3880", "type": "P", "difficulty": 3, "samples": [["Upomoc! Lpv s nm pkrl sv smglsnk.", "......! ... . .. .... .. ........ \nUpomoc! Lp. . .. .... .. ........ \nUpomoc! Lpv s nm pkrl s. ........\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "2008", "各省省选", "吉林"], "title": "[JLOI2008] 提示问题", "background": "", "description": "最近在 JLOI 网上的一个流行游戏中，选手要回答很难的问题。假如在规定时间内不能回答，系统将给出 $1$ 个提示，之后再依次给出第 $2,3$ 个提示。出现在答案中的是字母和下列字符：\n\n$\\verb|. , : ; ! ? - |$ 和空格（空格不会在开头和结尾出现）。\n\n字母是指：小写字母 $\\verb!a! \\cdots \\verb!z!$ 大写字母 $\\verb!A! \\cdots \\verb!Z!$，其中 a e i o u A E I O U 是元音字母。\n\n生成提示的规则：\n\n- 第 $1$ 个提示：简单的将所有字母换成 $\\verb!.!$ 即可；\n- 第 $2$ 个提示：从第 $1$ 个提示而来，将所有字母的个数求出，再将总个数除以三，得到的最接近商的自然数 $N$，将第 $1$ 个提示中的前 $N$ 个字母显示；\n- 第 $3$ 个提示：从第 $2$ 个提示而来，将剩下的元音字母显示。假如没有可显示的元音字母，则从第 $1$ 个提示而来，即我们将前 $2/3$ 的字母显示（同样如不能被 $3$ 整除则取最接近的整数）。", "inputFormat": "仅一行，给出问题，问题字符数最多不超过 $50$。\n", "outputFormat": "三行：按规则输出的三行提示。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2008] Hint Problem", "background": "", "description": "In a popular game on the JLOI website, players must answer difficult questions. If they cannot answer within the time limit, the system provides $1$ hint, followed by the $2$nd and $3$rd hints in order. The answer consists of letters and the following characters:\n\n$\\verb|. , : ; ! ? - |$ and spaces (spaces do not appear at the beginning or the end).\n\nLetters are: lowercase letters $\\verb!a! \\cdots \\verb!z!$ and uppercase letters $\\verb!A! \\cdots \\verb!Z!$, where a e i o u A E I O U are vowels.\n\nRules for generating hints:\n- 1st hint: simply replace all letters with $\\verb!.!$.\n- 2nd hint: derived from the 1st hint. Count all letters, divide the total by three, take the natural number $N$ closest to the quotient, and reveal the first $N$ letters.\n- 3rd hint: derived from the 2nd hint, reveal the remaining vowels. If there are no vowels to reveal, derive it from the 1st hint instead, i.e., reveal the first $2/3$ of the letters (if it is not divisible by $3$, round to the nearest integer as well).", "inputFormat": "One line containing the question, with at most $50$ characters.", "outputFormat": "Three lines: the three hints produced according to the rules.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2008] 提示问题", "background": "", "description": "最近在 JLOI 网上的一个流行游戏中，选手要回答很难的问题。假如在规定时间内不能回答，系统将给出 $1$ 个提示，之后再依次给出第 $2,3$ 个提示。出现在答案中的是字母和下列字符：\n\n$\\verb|. , : ; ! ? - |$ 和空格（空格不会在开头和结尾出现）。\n\n字母是指：小写字母 $\\verb!a! \\cdots \\verb!z!$ 大写字母 $\\verb!A! \\cdots \\verb!Z!$，其中 a e i o u A E I O U 是元音字母。\n\n生成提示的规则：\n\n- 第 $1$ 个提示：简单的将所有字母换成 $\\verb!.!$ 即可；\n- 第 $2$ 个提示：从第 $1$ 个提示而来，将所有字母的个数求出，再将总个数除以三，得到的最接近商的自然数 $N$，将第 $1$ 个提示中的前 $N$ 个字母显示；\n- 第 $3$ 个提示：从第 $2$ 个提示而来，将剩下的元音字母显示。假如没有可显示的元音字母，则从第 $1$ 个提示而来，即我们将前 $2/3$ 的字母显示（同样如不能被 $3$ 整除则取最接近的整数）。", "inputFormat": "仅一行，给出问题，问题字符数最多不超过 $50$。\n", "outputFormat": "三行：按规则输出的三行提示。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3881", "type": "P", "difficulty": 7, "samples": [["5\n0110\n00\n111\n001100\n110\n", "9\n001100110\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP", "搜索", "2008", "各省省选", "吉林", "图论建模", "最短路"], "title": "[JLOI2008] CODES", "background": null, "description": "给定 $n$ 个 $\\texttt{01}$ 编码串 $S_1,S_2,\\dots,S_n$，你的任务是寻找一个编码串 $T$，使得它至少可以被分解为两种不同的 $S_i$ 的排列。\n\n例如：\n\n给定 $5$ 个 $\\texttt{01}$ 编码串：$S_1=\\texttt{0110},S_2=\\texttt{00},S_3=\\texttt{111},S_4=\\texttt{001100},S_5=\\texttt{110}$。那么一个符合要求的编码串 $T$ 是：$\\texttt{001100110}$，它有以下两种分解方法：\n\n$\\texttt{00}+\\texttt{110}+\\texttt{0110} (S_2+S_5+S_1)$ 或 $\\texttt{001100}+\\texttt{110} (S_4+S_5)$\n\n而 $0110110$ 就不符合要求，它只有一种分解方法 $\\texttt{0110}+\\texttt{110} (S_1+S_5)$。\n\n你要寻找长度最短的符合要求的编码串 $T$。若有多个符合要求的最短编码串 $T$，则输出字典顺序最小的。", "inputFormat": "输入文件第一行包含一个整数 $n$，表示 $\\texttt{01}$ 编码串总数。接下来的 $n$ 行每行给出一个长度不超过 $20$ 的 $\\texttt{01}$ 编码串。", "outputFormat": "输出文件共有两行，第一行为要求的编码串 $T$ 的长度，第二行输出编码串 $T$。对所有的测试数据，问题总有解。", "hint": "- $n\\le 20$", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2008] CODES", "background": "", "description": "Given $n$ $\\texttt{01}$ code strings $S_1, S_2, \\dots, S_n$, your task is to find a code string $T$ such that it can be decomposed in at least two different ways as a concatenation of the $S_i$.\n\nFor example:\n\nGiven $5$ $\\texttt{01}$ code strings: $S_1=\\texttt{0110}, S_2=\\texttt{00}, S_3=\\texttt{111}, S_4=\\texttt{001100}, S_5=\\texttt{110}$. Then one valid code string $T$ is: \\texttt{001100110}, which has the following two decompositions:\n\n\\texttt{00}+\\texttt{110}+\\texttt{0110} $(S_2+S_5+S_1)$ or \\texttt{001100}+\\texttt{110} $(S_4+S_5)$.\n\nBut 0110110 does not meet the requirement; it has only one decomposition \\texttt{0110}+\\texttt{110} $(S_1+S_5)$.\n\nYou must find the shortest valid code string $T$. If there are multiple shortest valid code strings $T$, output the lexicographically smallest one.", "inputFormat": "The first line contains an integer $n$, the number of $\\texttt{01}$ code strings. Each of the next $n$ lines contains one $\\texttt{01}$ code string of length at most $20$.", "outputFormat": "Output two lines. The first line is the length of the required code string $T$. The second line is the code string $T$. For all the testdata, a solution always exists.", "hint": "- $n \\le 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2008] CODES", "background": null, "description": "给定 $n$ 个 $\\texttt{01}$ 编码串 $S_1,S_2,\\dots,S_n$，你的任务是寻找一个编码串 $T$，使得它至少可以被分解为两种不同的 $S_i$ 的排列。\n\n例如：\n\n给定 $5$ 个 $\\texttt{01}$ 编码串：$S_1=\\texttt{0110},S_2=\\texttt{00},S_3=\\texttt{111},S_4=\\texttt{001100},S_5=\\texttt{110}$。那么一个符合要求的编码串 $T$ 是：$\\texttt{001100110}$，它有以下两种分解方法：\n\n$\\texttt{00}+\\texttt{110}+\\texttt{0110} (S_2+S_5+S_1)$ 或 $\\texttt{001100}+\\texttt{110} (S_4+S_5)$\n\n而 $0110110$ 就不符合要求，它只有一种分解方法 $\\texttt{0110}+\\texttt{110} (S_1+S_5)$。\n\n你要寻找长度最短的符合要求的编码串 $T$。若有多个符合要求的最短编码串 $T$，则输出字典顺序最小的。", "inputFormat": "输入文件第一行包含一个整数 $n$，表示 $\\texttt{01}$ 编码串总数。接下来的 $n$ 行每行给出一个长度不超过 $20$ 的 $\\texttt{01}$ 编码串。", "outputFormat": "输出文件共有两行，第一行为要求的编码串 $T$ 的长度，第二行输出编码串 $T$。对所有的测试数据，问题总有解。", "hint": "- $n\\le 20$", "locale": "zh-CN"}}}
{"pid": "P3882", "type": "P", "difficulty": 6, "samples": [["3 3\n..N\n...\n...\n", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "吉林", "图论建模", "二分图"], "title": "[JLOI2008] 将军", "background": "", "description": "刘先生最近在学习国际象棋，使用一个叫 jloi-08 的游戏软件。在这个游戏里，不但可以和电脑普通地对弈，还可以学习著名的棋局，还有针对初学者的规则指导等丰富功能。但是…大小却要 1.4G T\\_T。\n\n言归正传，在这个软件里，为了让玩家更好地理解和运用各个棋子，有很多趣味的游戏，比如以下就是一个：\n\n给出一个棋盘和一些棋子，让你把这些棋子摆放在棋盘上，使得两两不互相攻击。你的得分由你摆放上去的棋子的个数与种类有关。\n\n这个游戏很复杂，刘先生老是玩不到高分。于是电脑便降低了难度，替刘先生摆上了一些棋子，最后只给你任意多个 bishop（教主）。\n\n现在刘先生便要考一考你，在电脑给出的这张棋盘上，最多能放几个 bishop。\n\n国际象棋中一共有 6 种棋子：\n\n- king（国王）；\n- queen（皇后）；\n- bishop（教主）；\n- knight（骑士）；\n- rook（车）；\n- pawn（步兵）。\n\n各棋子的攻击范围如下：\n\n- queen 可以攻击与它在同一行，同一列，同一条对角线的棋子；\n- knight 的攻击范围如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/2669.png)\n\n- rook 攻击水平和垂直两条线上的所有格子；\n- pawn 攻击前方两条斜线方向各一格(“前方”指 $x$ 递增的方向，$x$ 行 $y$ 列）；\n- king 攻击周围 8 个方向各 1 格；\n- bishop 攻击两条对角线上的所有格子。\n\n除 knight 以外，所有棋子的攻击范围均会被别的棋子所阻挡。\n\n可惜的是这个软件也不是顶优秀，给出的棋盘上的棋子可能互相会攻击，不过你不用理会这些，你只要保证你摆放的 bishop 不与它们以及不互相攻击就可以了。", "inputFormat": "第一行是两个整数 $x,y$（$1 \\leq x,y \\leq 1024$）。\n\n下面的 $x$ 行每行 $y$ 个字符表示棋盘。\n\n其中：`K` – king，`Q` – queen，`B` – bishop，`N` – knight，`R` – rook，`P` – pawn，`.` – blank.", "outputFormat": "仅一行一个数，表示最多能够摆放的 bishop 的个数。\n", "hint": "```plain\nBBN\n...\n...\n```\n\n```plain\nBBN\n...\nB..\n```\n\n虽然看上去下面的方法比上面的优秀，但是 N 被第三行的 B 攻击了。也就是说，你需要避免的有 2 种情况： 你摆放的 bishop 之间的互相攻击以及你摆放的 bishop 与预先摆放好的棋子之间的互相攻击；但不用考虑预先摆放好的棋子之间的互相攻击。\n", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2008] General", "background": "# Description\n\nMr. Liu has recently been learning chess, using a game software called jloi-08. In this game, you can not only play against the computer in the usual way, but also study famous games, and there are rich features such as rule guidance for beginners. However, its size is 1.4G T\\_T.\n\nBack to the point. In this software, to help players better understand and use each piece, there are many interesting mini-games, such as the following:\n\nGiven a board and some pieces, you are asked to place these pieces on the board so that no two attack each other. Your score depends on the number and types of pieces you place.\n\nThis game is complex, and Mr. Liu often fails to get a high score. So the computer lowered the difficulty by pre-placing some pieces for Mr. Liu, and finally only giving you any number of bishops.\n\nNow Mr. Liu wants to test you: on the board provided by the computer, what is the maximum number of bishops you can place?\n\nThere are 6 types of pieces in chess:\n- king (国王).\n- queen (皇后).\n- bishop (教主, jiaozhu).\n- knight (骑士).\n- rook (车).\n- pawn (步兵).\n\nThe attack ranges of the pieces are as follows:\n- The queen can attack pieces in the same row, the same column, and the same diagonal.\n- The knight’s attack range is shown in the figure below:\n\n![](https://cdn.luogu.com.cn/upload/pic/2669.png)\n\n- The rook attacks all squares along the horizontal and vertical lines.\n- The pawn attacks one square diagonally forward on each side (\"forward\" means the direction of increasing $x$, with $x$ rows and $y$ columns).\n- The king attacks one square in each of the 8 surrounding directions.\n- The bishop attacks all squares along the two diagonals.\n\nExcept for the knight, the attack ranges of all pieces are blocked by other pieces.\n\nUnfortunately, this software is not perfect, and the pieces on the given board may attack each other. However, you can ignore that. You only need to ensure that the bishops you place do not attack the pre-placed pieces and do not attack each other.", "description": "Mr. Liu has recently been learning chess, using a game software called jloi-08. In this game, you can not only play against the computer in the usual way, but also study famous games, and there are rich features such as rule guidance for beginners. However, its size is 1.4G T\\_T.\n\nBack to the point. In this software, to help players better understand and use each piece, there are many interesting mini-games, such as the following:\n\nGiven a board and some pieces, you are asked to place these pieces on the board so that no two attack each other. Your score depends on the number and types of pieces you place.\n\nThis game is complex, and Mr. Liu often fails to get a high score. So the computer lowered the difficulty by pre-placing some pieces for Mr. Liu, and finally only giving you any number of bishops.\n\nNow Mr. Liu wants to test you: on the board provided by the computer, what is the maximum number of bishops you can place?\n\nThere are 6 types of pieces in chess:\n- king (国王).\n- queen (皇后).\n- bishop (教主, jiaozhu).\n- knight (骑士).\n- rook (车).\n- pawn (步兵).\n\nThe attack ranges of the pieces are as follows:\n- The queen can attack pieces in the same row, the same column, and the same diagonal.\n- The knight’s attack range is shown in the figure below:\n\n![](https://cdn.luogu.com.cn/upload/pic/2669.png)\n\n- The rook attacks all squares along the horizontal and vertical lines.\n- The pawn attacks one square diagonally forward on each side (\"forward\" means the direction of increasing $x$, with $x$ rows and $y$ columns).\n- The king attacks one square in each of the 8 surrounding directions.\n- The bishop attacks all squares along the two diagonals.\n\nExcept for the knight, the attack ranges of all pieces are blocked by other pieces.\n\nUnfortunately, this software is not perfect, and the pieces on the given board may attack each other. However, you can ignore that. You only need to ensure that the bishops you place do not attack the pre-placed pieces and do not attack each other.\n\n# Description", "inputFormat": "The first line contains two integers $x,y$ ($1 \\leq x,y \\leq 1024$).\n\nThe next $x$ lines each contain $y$ characters describing the board.\n\nHere: `K` – king, `Q` – queen, `B` – bishop, `N` – knight, `R` – rook, `P` – pawn, `.` – blank.", "outputFormat": "Output a single number on one line, indicating the maximum number of bishops that can be placed.", "hint": "```plain\nBBN\n...\n...\n```\n\n```plain\nBBN\n...\nB..\n```\n\nAlthough the method below looks better than the one above, the N is attacked by the B in the third row. That is, there are two situations you must avoid: mutual attacks among the bishops you place, and attacks between the bishops you place and the pre-placed pieces. You do not need to consider attacks among the pre-placed pieces.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2008] 将军", "background": "", "description": "刘先生最近在学习国际象棋，使用一个叫 jloi-08 的游戏软件。在这个游戏里，不但可以和电脑普通地对弈，还可以学习著名的棋局，还有针对初学者的规则指导等丰富功能。但是…大小却要 1.4G T\\_T。\n\n言归正传，在这个软件里，为了让玩家更好地理解和运用各个棋子，有很多趣味的游戏，比如以下就是一个：\n\n给出一个棋盘和一些棋子，让你把这些棋子摆放在棋盘上，使得两两不互相攻击。你的得分由你摆放上去的棋子的个数与种类有关。\n\n这个游戏很复杂，刘先生老是玩不到高分。于是电脑便降低了难度，替刘先生摆上了一些棋子，最后只给你任意多个 bishop（教主）。\n\n现在刘先生便要考一考你，在电脑给出的这张棋盘上，最多能放几个 bishop。\n\n国际象棋中一共有 6 种棋子：\n\n- king（国王）；\n- queen（皇后）；\n- bishop（教主）；\n- knight（骑士）；\n- rook（车）；\n- pawn（步兵）。\n\n各棋子的攻击范围如下：\n\n- queen 可以攻击与它在同一行，同一列，同一条对角线的棋子；\n- knight 的攻击范围如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/pic/2669.png)\n\n- rook 攻击水平和垂直两条线上的所有格子；\n- pawn 攻击前方两条斜线方向各一格(“前方”指 $x$ 递增的方向，$x$ 行 $y$ 列）；\n- king 攻击周围 8 个方向各 1 格；\n- bishop 攻击两条对角线上的所有格子。\n\n除 knight 以外，所有棋子的攻击范围均会被别的棋子所阻挡。\n\n可惜的是这个软件也不是顶优秀，给出的棋盘上的棋子可能互相会攻击，不过你不用理会这些，你只要保证你摆放的 bishop 不与它们以及不互相攻击就可以了。", "inputFormat": "第一行是两个整数 $x,y$（$1 \\leq x,y \\leq 1024$）。\n\n下面的 $x$ 行每行 $y$ 个字符表示棋盘。\n\n其中：`K` – king，`Q` – queen，`B` – bishop，`N` – knight，`R` – rook，`P` – pawn，`.` – blank.", "outputFormat": "仅一行一个数，表示最多能够摆放的 bishop 的个数。\n", "hint": "```plain\nBBN\n...\n...\n```\n\n```plain\nBBN\n...\nB..\n```\n\n虽然看上去下面的方法比上面的优秀，但是 N 被第三行的 B 攻击了。也就是说，你需要避免的有 2 种情况： 你摆放的 bishop 之间的互相攻击以及你摆放的 bishop 与预先摆放好的棋子之间的互相攻击；但不用考虑预先摆放好的棋子之间的互相攻击。\n", "locale": "zh-CN"}}}
{"pid": "P3883", "type": "P", "difficulty": 6, "samples": [["2 5\n3\nKing's Knight Opening\nPe4\nPe5\nNf3\n3\nNimzowitsch Variation\nPc4\nPe5\nNf3\nPe4\nPe5\nNf3\nNc6\nBb5\n", "King's Knight Opening"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "吉林"], "title": "[JLOI2008] 棋局定式", "background": "", "description": "在“jloi-08”游戏中，还存有非常非常多的棋局定式，也就是常会用到的下棋的组合。有时在学习一个著名棋局时，电脑会考一考刘先生：在这局棋里面，有多少个定式啊？分别是什么啊？\n\n\n对于30~40步的普通棋局，刘先生还能回答出来，可是有时候2个实力相当的大牛下的棋局，2000000步都有可能。如果电脑对这样的棋局提上面的问题时，刘先生就必须写一个程序来帮助自己了。可是，刘先生在这方面却…，怎么写也写不对。你能帮助刘先生吗？\n\n\n棋局是由很多step组成的，而step是由一个字符串组成的，比如Kh2或者是Nxb7。\n\n前者表示K(king)移动至h2格，后者表示N(knight)移动至b7格并吃掉原有的棋子。\n\n\n第一个字符可能有6种：K Q B N R P，而后面可能是一个坐标或者是字符x后跟一个坐标。\n\n\n坐标是由一个小写英文字母(a~h)和一个数字(1~8)组成的。\n\n\n如果一个棋局中完整地并连续地包含一个定式中所有的step，那么这个棋局便包含这个定式。\n", "inputFormat": "第一行2个整数n, m，表示定式的个数(1<=n<=2000)以及这个棋局所包含的步数\n\n\n下面的n个块(block)，每块包含：\n\n第一行一个整数k表示定式包含的步数(1<=k<=100000, ∑k<=200000)\n\n第二行一个字符串表示该定式的名称(长度不超过50)\n\n下面的k行每行一个字符串表示定式中的一步\n\n\n最后的m行每行一个字符串，表示棋局中的一步\n", "outputFormat": "按照输入文件包含的定式的顺序，输出棋局包含的所有定式的名称，一个一行。\n", "hint": "不保证给出的棋局和定式符合国际象棋的规则。\n", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2008] Standard Sequences in a Chess Game", "background": "", "description": "In the \"jloi-08\" game, there are a large number of standard sequences, that is, commonly used combinations of moves. Sometimes, when studying a famous game, the computer will quiz Mr. Liu: How many standard sequences are in this game? What are they?\n\nFor ordinary games with $30$ to $40$ moves, Mr. Liu can still answer. But sometimes, in a game between two equally strong players, there may be as many as $2000000$ moves. If the computer asks the above questions about such a game, Mr. Liu must write a program to help himself. However, Mr. Liu is not good at this... He keeps getting it wrong. Can you help him?\n\nA game consists of many steps, and a step is represented by a string, such as Kh2 or Nxb7.\n\nThe former means K (king) moves to h2, and the latter means N (knight) moves to b7 and captures the piece there.\n\nThe first character can be one of 6 types: K Q B N R P, and the rest is either a coordinate or the character x followed by a coordinate.\n\nA coordinate consists of a lowercase letter from a to h and a digit from 1 to 8.\n\nIf a game contains all the steps of a standard sequence completely and consecutively, then the game contains that standard sequence.", "inputFormat": "The first line contains two integers $n, m$, representing the number of standard sequences ($1 \\le n \\le 2000$) and the number of steps in the game.\n\nThen follow $n$ blocks; each block contains:\n- The first line contains an integer $k$, the number of steps in the standard sequence ($1 \\le k \\le 100000$, $\\sum k \\le 200000$).\n- The second line contains a string, the name of the standard sequence (length no more than $50$).\n- Each of the next $k$ lines contains one string, representing one step in the standard sequence.\n\nEach of the last $m$ lines contains one string, representing one step in the game.", "outputFormat": "In the order of the input, output the names of all standard sequences contained in the game, one per line.", "hint": "It is not guaranteed that the given game and standard sequences comply with the rules of chess.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2008] 棋局定式", "background": "", "description": "在“jloi-08”游戏中，还存有非常非常多的棋局定式，也就是常会用到的下棋的组合。有时在学习一个著名棋局时，电脑会考一考刘先生：在这局棋里面，有多少个定式啊？分别是什么啊？\n\n\n对于30~40步的普通棋局，刘先生还能回答出来，可是有时候2个实力相当的大牛下的棋局，2000000步都有可能。如果电脑对这样的棋局提上面的问题时，刘先生就必须写一个程序来帮助自己了。可是，刘先生在这方面却…，怎么写也写不对。你能帮助刘先生吗？\n\n\n棋局是由很多step组成的，而step是由一个字符串组成的，比如Kh2或者是Nxb7。\n\n前者表示K(king)移动至h2格，后者表示N(knight)移动至b7格并吃掉原有的棋子。\n\n\n第一个字符可能有6种：K Q B N R P，而后面可能是一个坐标或者是字符x后跟一个坐标。\n\n\n坐标是由一个小写英文字母(a~h)和一个数字(1~8)组成的。\n\n\n如果一个棋局中完整地并连续地包含一个定式中所有的step，那么这个棋局便包含这个定式。\n", "inputFormat": "第一行2个整数n, m，表示定式的个数(1<=n<=2000)以及这个棋局所包含的步数\n\n\n下面的n个块(block)，每块包含：\n\n第一行一个整数k表示定式包含的步数(1<=k<=100000, ∑k<=200000)\n\n第二行一个字符串表示该定式的名称(长度不超过50)\n\n下面的k行每行一个字符串表示定式中的一步\n\n\n最后的m行每行一个字符串，表示棋局中的一步\n", "outputFormat": "按照输入文件包含的定式的顺序，输出棋局包含的所有定式的名称，一个一行。\n", "hint": "不保证给出的棋局和定式符合国际象棋的规则。\n", "locale": "zh-CN"}}}
{"pid": "P3884", "type": "P", "difficulty": 3, "samples": [["10                                \n1 2                            \n1 3                            \n2 4\n2 5\n3 6\n3 7\n5 8\n5 9\n6 10\n8 6\n", "4\n4\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2009", "各省省选", "吉林", "深度优先搜索 DFS", "最近公共祖先 LCA"], "title": "[JLOI2009] 二叉树问题", "background": "", "description": "如下图所示的一棵二叉树的深度、宽度及结点间距离分别为：\n\n- 深度：$4$\n- 宽度：$4$\n- 结点 8 和 6 之间的距离：$8$\n- 结点 7 和 6 之间的距离：$3$\n\n其中宽度表示二叉树上同一层最多的结点个数，节点 $u, v$ 之间的距离表示从 $u$ 到 $v$ 的最短有向路径上向根节点的边数的两倍加上向叶节点的边数。\n\n![](https://cdn.luogu.com.cn/upload/pic/6843.png)\n\n给定一颗以 1 号结点为根的二叉树，请求出其深度、宽度和两个指定节点 $x, y$ 之间的距离。\n", "inputFormat": "第一行是一个整数，表示树的结点个数 $n$。  \n接下来 $n - 1$ 行，每行两个整数 $u, v$，表示树上存在一条连接 $u, v$ 的边。  \n最后一行有两个整数 $x, y$，表示求 $x, y$ 之间的距离。", "outputFormat": "输出三行，每行一个整数，依次表示二叉树的深度、宽度和 $x, y$ 之间的距离。", "hint": "对于全部的测试点，保证 $1 \\leq u, v, x, y \\leq n \\leq 100$，且给出的是一棵树。保证 $u$ 是 $v$ 的父结点。", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2009] Binary Tree Problem", "background": "", "description": "For the binary tree shown below, its depth, width, and distances between nodes are as follows:\n- Depth: $4$.\n- Width: $4$.\n- The distance between nodes 8 and 6: $8$.\n- The distance between nodes 7 and 6: $3$.\n\nHere, the width is the maximum number of nodes on the same level of the binary tree. The distance between nodes $u$ and $v$ is defined as twice the number of edges directed toward the root plus the number of edges directed toward the leaves, along the shortest directed path from $u$ to $v$.\n\n![](https://cdn.luogu.com.cn/upload/pic/6843.png)\n\nGiven a binary tree rooted at node 1, compute its depth, width, and the distance between two specified nodes $x, y$.", "inputFormat": "The first line contains an integer $n$, the number of nodes in the tree.  \nThe next $n - 1$ lines each contain two integers $u, v$, indicating that there is an edge connecting $u$ and $v$ in the tree.  \nThe last line contains two integers $x, y$, asking for the distance between $x$ and $y$.", "outputFormat": "Output three lines, each containing one integer, representing the depth, the width, and the distance between $x$ and $y$, in this order.", "hint": "For all test points, $1 \\leq u, v, x, y \\leq n \\leq 100$, and the input describes a tree. It is guaranteed that $u$ is the parent of $v$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2009] 二叉树问题", "background": "", "description": "如下图所示的一棵二叉树的深度、宽度及结点间距离分别为：\n\n- 深度：$4$\n- 宽度：$4$\n- 结点 8 和 6 之间的距离：$8$\n- 结点 7 和 6 之间的距离：$3$\n\n其中宽度表示二叉树上同一层最多的结点个数，节点 $u, v$ 之间的距离表示从 $u$ 到 $v$ 的最短有向路径上向根节点的边数的两倍加上向叶节点的边数。\n\n![](https://cdn.luogu.com.cn/upload/pic/6843.png)\n\n给定一颗以 1 号结点为根的二叉树，请求出其深度、宽度和两个指定节点 $x, y$ 之间的距离。\n", "inputFormat": "第一行是一个整数，表示树的结点个数 $n$。  \n接下来 $n - 1$ 行，每行两个整数 $u, v$，表示树上存在一条连接 $u, v$ 的边。  \n最后一行有两个整数 $x, y$，表示求 $x, y$ 之间的距离。", "outputFormat": "输出三行，每行一个整数，依次表示二叉树的深度、宽度和 $x, y$ 之间的距离。", "hint": "对于全部的测试点，保证 $1 \\leq u, v, x, y \\leq n \\leq 100$，且给出的是一棵树。保证 $u$ 是 $v$ 的父结点。", "locale": "zh-CN"}}}
{"pid": "P3885", "type": "P", "difficulty": 5, "samples": [["3  100  0  10  0  20  0", "300.000  30.000  0"], ["3  100  2  10  0.1  20  1", "422.469  23.457  1\n2  11.111\n"], ["3  100  4  10  0  20  1", "480.000  10.000  2\n1  10.000\n2  10.000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "贪心", "2009", "各省省选", "吉林"], "title": "[JLOI2009] F1一级方程式大赛", "background": "众所周知，迈克尔·舒马赫 (Michael  Schumacher) 是当今车坛最伟大的王者，从 1991 年至 2006 年他一共参加了 260 多场比赛，获得近 100 次分站冠军，9 次年度冠军。舒马赫取得如此辉煌的战绩得益于他有一个非常优秀的智囊团。每次比赛之前他的智囊团将根据场地、气候、路况以及赛车状态，来为舒马赫制定比赛中的策略。", "description": "我们知道，在 F1 大赛中，如果赛车的其他参数都相同，赛车的速度主要取决于其载油量。载油太多就会降低赛车的速度，也会增加汽油的消耗速度；但载油太少就需要在比赛中增加进站加油的次数。因此智囊团的一个关键任务就是在每次比赛前确定舒马赫的初始载油量以及进站加油的方案，使得舒马赫完成所有赛程的总时间尽量短。\n\n\n作为智囊团的首席程序员刘博士，交给他的团队的任务是编写一个程序，为舒马赫确定比赛开始前的载油量以及比赛中进站加油的方案。", "inputFormat": "输入数据包括以下 $7$ 个数：\n\n- 比赛的总圈数 $n$（一个正整数）\n\n- 理论上，没有油的空车跑一圈所需的时间（浮点数，单位为秒）\n\n- 每增加 $1$ 公升汽油，赛车跑一圈所增加的时间（浮点数，单位为秒）\n\n- 理论上，没有油的空车跑一圈所消耗的油量（浮点数，单位为公升）\n\n- 每增加 $1$ 公升汽油，赛车跑一圈所增加的油量损耗（浮点数，单位为公升，且这个数严格小于 $1$）\n\n- 每次进站所需花费的时间（浮点数，单位为秒，这个时间不包括加油所需花费的时间，加油所花费的时间由下一个输入参数决定）\n\n- 每次进站后，每加 $1$ 公升汽油，所需花费的时间（浮点数，单位为秒）\n\n我们总是把一整圈看作一个单位。赛车在跑一圈的过程中，汽油的变化量不做考虑。加油总是在一整圈跑完以后才可以进行。", "outputFormat": "- 第一行包括三个数：\n\n 1. 舒马赫的赛车跑完所有赛程所需的最短时间（浮点数，保留小数点后三位）；\n 2. 舒马赫的赛车在比赛开始前的载油量（浮点数，保留小数点后三位）；\n 3. 舒马赫在比赛过程中进站加油的次数 $m$（整数）；\n\n\n- 接下来是 $m$ 行，每行包括两个数：\n\n 1. 第 $i$ 次进站加油时已经完成的圈数（整数）；\n 2. 第 $i$ 次进站加油所加的油量（浮点数，保留小数点后三位）；", "hint": "对于所有数据，满足 $1 \\le n \\le 100$，其余输入数据均在 $[0,100]$ 范围内。", "locale": "zh-CN", "translations": {"en": {"title": "{{[JLOI2009] F1 Grand Prix}}", "background": "{{As is well known, Michael Schumacher is the greatest champion in today’s motorsport. From 1991 to 2006, he took part in more than 260 races, won nearly 100 Grands Prix, and claimed 9 season titles. Schumacher’s remarkable record owes much to an excellent think tank. Before each race, his team sets the strategy based on the circuit, weather, track conditions, and the car’s state.}}", "description": "{{We know that in F1, if all other parameters are the same, a car’s speed mainly depends on its fuel load. Carrying too much fuel will slow the car down and increase fuel consumption per lap; carrying too little fuel requires more pit stops to refuel. Therefore, a key task for the think tank is to determine the initial fuel load and the pit-refueling plan before each race so that the total time to complete all laps is as short as possible.\n\nAs the chief programmer Dr. Liu, the team’s task is to write a program to determine Schumacher’s initial fuel load before the race and the pit-refueling plan during the race.}}", "inputFormat": "{{The input consists of the following $7$ numbers:\n- The total number of laps $n$ (a positive integer).\n- The time for a theoretically empty car with no fuel to complete one lap (floating-point, in seconds).\n- For each additional $1$ liter of fuel, the extra time per lap (floating-point, in seconds).\n- The fuel consumed per lap for a theoretically empty car with no fuel (floating-point, in liters).\n- For each additional $1$ liter of fuel, the additional fuel consumption per lap (floating-point, in liters, and this number is strictly less than $1$).\n- The time spent for each pit stop (floating-point, in seconds; this does not include the time spent refueling, which is determined by the next input parameter).\n- After each pit stop, the time spent per additional $1$ liter of fuel added (floating-point, in seconds).\n\nWe always treat one whole lap as a unit. Changes in fuel during a lap are not considered. Refueling is allowed only after completing a whole lap.}}", "outputFormat": "{{- The first line contains three numbers:\n  1. The minimum total time needed for Schumacher’s car to finish all laps (floating-point, rounded to three decimals).\n  2. The initial fuel load before the race (floating-point, rounded to three decimals).\n  3. The number of pit stops for refueling during the race $m$ (integer).\n- Then follow $m$ lines, each containing two numbers:\n  1. The number of laps completed at the time of the $i$-th pit stop for refueling (integer).\n  2. The amount of fuel added at the $i$-th pit stop (floating-point, rounded to three decimals).}}", "hint": "{{For all testdata, $1 \\le n \\le 100$, and all other input numbers lie in the range $[0, 100]$.}}\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2009] F1一级方程式大赛", "background": "众所周知，迈克尔·舒马赫 (Michael  Schumacher) 是当今车坛最伟大的王者，从 1991 年至 2006 年他一共参加了 260 多场比赛，获得近 100 次分站冠军，9 次年度冠军。舒马赫取得如此辉煌的战绩得益于他有一个非常优秀的智囊团。每次比赛之前他的智囊团将根据场地、气候、路况以及赛车状态，来为舒马赫制定比赛中的策略。", "description": "我们知道，在 F1 大赛中，如果赛车的其他参数都相同，赛车的速度主要取决于其载油量。载油太多就会降低赛车的速度，也会增加汽油的消耗速度；但载油太少就需要在比赛中增加进站加油的次数。因此智囊团的一个关键任务就是在每次比赛前确定舒马赫的初始载油量以及进站加油的方案，使得舒马赫完成所有赛程的总时间尽量短。\n\n\n作为智囊团的首席程序员刘博士，交给他的团队的任务是编写一个程序，为舒马赫确定比赛开始前的载油量以及比赛中进站加油的方案。", "inputFormat": "输入数据包括以下 $7$ 个数：\n\n- 比赛的总圈数 $n$（一个正整数）\n\n- 理论上，没有油的空车跑一圈所需的时间（浮点数，单位为秒）\n\n- 每增加 $1$ 公升汽油，赛车跑一圈所增加的时间（浮点数，单位为秒）\n\n- 理论上，没有油的空车跑一圈所消耗的油量（浮点数，单位为公升）\n\n- 每增加 $1$ 公升汽油，赛车跑一圈所增加的油量损耗（浮点数，单位为公升，且这个数严格小于 $1$）\n\n- 每次进站所需花费的时间（浮点数，单位为秒，这个时间不包括加油所需花费的时间，加油所花费的时间由下一个输入参数决定）\n\n- 每次进站后，每加 $1$ 公升汽油，所需花费的时间（浮点数，单位为秒）\n\n我们总是把一整圈看作一个单位。赛车在跑一圈的过程中，汽油的变化量不做考虑。加油总是在一整圈跑完以后才可以进行。", "outputFormat": "- 第一行包括三个数：\n\n 1. 舒马赫的赛车跑完所有赛程所需的最短时间（浮点数，保留小数点后三位）；\n 2. 舒马赫的赛车在比赛开始前的载油量（浮点数，保留小数点后三位）；\n 3. 舒马赫在比赛过程中进站加油的次数 $m$（整数）；\n\n\n- 接下来是 $m$ 行，每行包括两个数：\n\n 1. 第 $i$ 次进站加油时已经完成的圈数（整数）；\n 2. 第 $i$ 次进站加油所加的油量（浮点数，保留小数点后三位）；", "hint": "对于所有数据，满足 $1 \\le n \\le 100$，其余输入数据均在 $[0,100]$ 范围内。", "locale": "zh-CN"}}}
{"pid": "P3886", "type": "P", "difficulty": 6, "samples": [["4\n2 -1 -1 -1\n5 -5 -1 -5\n3  2 -1  3\n2 -2 -3  2\n", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "各省省选", "吉林", "进制", "轮廓线 DP"], "title": "[JLOI2009] 神秘的生物", "background": null, "description": "3206 年 5 月，正在钻研 ET 专业的刘博士所在的 OI 团队发现：地球受到了来自外星球的生物人的侵袭。这些生物人采取了极秘的乘法加密电文，控制了具有大量武器的军火库，攻占了大量的城市，甚至出现了 K 弹计划……\n\n刘博士所在的 OI 团队决定要发挥他们的科研机构作用（由于吉林省所在的地理位置具有特殊的优势，此科研机构全球只有吉林一处），以制伏这些外星球的生物人。他们想方设法捕获了几个外星球的生物人，经研究后发现，这些外星球的生物人在地球上的生存，取决于一个参数：生存度。他们要做的就是：找到这个参数的最大值！于是，他们开始了对这些外星球的生物人生长的研究。\n\n每次实验前，他们把一个外星球生物人的细胞随机地放在一个 $N\\times N$ 的方形培养容器的一格中，并给容器的每个格子都标了一个数值，是生物在此单元的生存度（可正可负，数值越大表示越危险）。整个生物的生存度是生物所有占据格子的生存度之和。每次实验开始后，让生物自然生长。这个生物每一单位时间都选择其身体的一部分（某个格子），随机地向与之有公共边的空格生长，例如某次实验，一开始生物只占据一个格子，然后开始了生长：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6844.png) \n\n刘博士所在的 OI 团队做了大量的实验，并且对数据进行了记录和统计。假设进行的实验次数足够多，问在实验进行的某一时刻，该生物达到的最大生存度是多少？\n\n3206 年 9 月，妄图破坏地球的外星球生物人终于被刘博士所在的 OI 团队制伏了……", "inputFormat": "输入文件第一行包括一个正整数 $N$，代表实验容器的边长。\n\n接下来 $N$ 行，每行 $N$ 个用空格隔开的整数，代表外星球生物人在每一格的生存度。", "outputFormat": "输出一行，代表实验过程中，生物达到的最大生存度。", "hint": "对于 $40\\%$ 的数据有 $N\\le 6$。\n\n对于 $100\\%$ 的数据有 $N\\le 9$。\n\n所有数据每个格子生存度的绝对值不超过 $32767$。", "locale": "zh-CN", "translations": {"en": {"title": "[JLOI2009] Mysterious Creature", "background": "", "description": "In May 3206, Dr. Liu, who was studying the ET major, and his OI team discovered that Earth had been invaded by alien “bio-people.” These bio-people used a top-secret multiplicative encrypted telegraph, seized armories with a vast number of weapons, captured many cities, and even launched the K-bomb plan.\n\nDr. Liu’s OI team decided to leverage their research institute (due to the unique geographical advantages of Jilin, this institute exists only in Jilin worldwide) to subdue these alien bio-people. They managed to capture several alien bio-people, and after research, they found that their survival on Earth depends on one parameter: the survival value. What they aimed to do was to find the maximum value of this parameter. Thus, they began studying the growth of these alien bio-people.\n\nBefore each experiment, they randomly place the cell of an alien bio-person into a cell of an $N\\times N$ square culture container, and label each cell of the container with a value, which is the survival value of the organism in that cell (can be positive or negative, and a larger value indicates greater danger). The survival value of the entire organism is the sum of the survival values of all the cells it occupies. After the experiment begins, the organism grows naturally. At each unit of time, it chooses a part of its body (some cell) and randomly grows into an empty cell that shares a common edge with it. For example, in one experiment, the organism initially occupies only one cell, and then starts growing:\n\n ![](https://cdn.luogu.com.cn/upload/pic/6844.png) \n\nDr. Liu’s OI team conducted a large number of experiments and recorded and analyzed the testdata. Assuming the number of experiments is sufficient, ask: at some moment during the experiment, what is the maximum survival value the organism can achieve?\n\nIn September 3206, the alien bio-people who attempted to destroy Earth were finally subdued by Dr. Liu’s OI team.", "inputFormat": "The first line contains a positive integer $N$, representing the side length of the experimental container.\n\nThe next $N$ lines each contain $N$ space-separated integers, representing the survival value of the alien bio-person in each cell.", "outputFormat": "Output one line, the maximum survival value achieved by the organism during the experiment.", "hint": "For 40% of the testdata, $N \\le 6$.\n\nFor 100% of the testdata, $N \\le 9$.\n\nFor all testdata, the absolute value of the survival value in each cell does not exceed $32767$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JLOI2009] 神秘的生物", "background": null, "description": "3206 年 5 月，正在钻研 ET 专业的刘博士所在的 OI 团队发现：地球受到了来自外星球的生物人的侵袭。这些生物人采取了极秘的乘法加密电文，控制了具有大量武器的军火库，攻占了大量的城市，甚至出现了 K 弹计划……\n\n刘博士所在的 OI 团队决定要发挥他们的科研机构作用（由于吉林省所在的地理位置具有特殊的优势，此科研机构全球只有吉林一处），以制伏这些外星球的生物人。他们想方设法捕获了几个外星球的生物人，经研究后发现，这些外星球的生物人在地球上的生存，取决于一个参数：生存度。他们要做的就是：找到这个参数的最大值！于是，他们开始了对这些外星球的生物人生长的研究。\n\n每次实验前，他们把一个外星球生物人的细胞随机地放在一个 $N\\times N$ 的方形培养容器的一格中，并给容器的每个格子都标了一个数值，是生物在此单元的生存度（可正可负，数值越大表示越危险）。整个生物的生存度是生物所有占据格子的生存度之和。每次实验开始后，让生物自然生长。这个生物每一单位时间都选择其身体的一部分（某个格子），随机地向与之有公共边的空格生长，例如某次实验，一开始生物只占据一个格子，然后开始了生长：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6844.png) \n\n刘博士所在的 OI 团队做了大量的实验，并且对数据进行了记录和统计。假设进行的实验次数足够多，问在实验进行的某一时刻，该生物达到的最大生存度是多少？\n\n3206 年 9 月，妄图破坏地球的外星球生物人终于被刘博士所在的 OI 团队制伏了……", "inputFormat": "输入文件第一行包括一个正整数 $N$，代表实验容器的边长。\n\n接下来 $N$ 行，每行 $N$ 个用空格隔开的整数，代表外星球生物人在每一格的生存度。", "outputFormat": "输出一行，代表实验过程中，生物达到的最大生存度。", "hint": "对于 $40\\%$ 的数据有 $N\\le 6$。\n\n对于 $100\\%$ 的数据有 $N\\le 9$。\n\n所有数据每个格子生存度的绝对值不超过 $32767$。", "locale": "zh-CN"}}}
{"pid": "P3887", "type": "P", "difficulty": 2, "samples": [["3 10 12 4\n76 60 87\n78 84 84 84 81 82 72 51 77 57\n85 84 62 87 88 64 81 90 80 66 88 85\n65 83 63 79\n2\n4 5 1\n4 4 2", "85.64\n78.00\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2014", "各省省选", "广东", "排序", "优先队列", "队列"], "title": "[GDOI2014] 世界杯", "background": "", "description": "3014 年世界杯足球赛就要开始了！作为卫冕冠军中国足球队的教练，手下每位球员都是猛将，如何摆出最强的 11 人阵容也是一件幸福的烦恼事啊。\n\n众所周知，足球阵容里的11个球员都会被分配到场上某一个特别的位置，而这些位置主要分为守门员、后卫、中场和前锋四种，其中守门员有且只有一个，后卫、中场和前锋的人数取决于你安排的足球阵型。形容足球阵型的方法由后卫开始计算至前锋，但不把守门员计算在内。例如，3-5-2 阵型是指有三个后卫、五个中场及两名前锋。由于竞争激烈，每位球员只会培养其中一种位置所需要的技能，所以他们每个人都只能胜任四个位置中的其中一种。\n\n作为一个对球员能力了如指掌的教练，你给每个球员的综合水平进行量化。为了将阵型安排得更好，你的教练团队决定使用以下策略安排球员：首先按照顺序提出 $Q$ 个阵型，分别代表第一阵型、第二阵型、……、第 $Q$ 阵型。然后对于每个阵型，从仍未选择的球员中选择最好的对应数量的守门员、后卫、中场和前锋。比如说，对于第一阵型，在所有球员中选择；对于第二阵型，在除了第一阵型外的所有球员中选择；对于第三阵型，在除了第一阵型和第二阵型外的所有球员中选择；以此类推。\n\n现在 $Q$ 个阵型都已经确定，而你需要知道的，是每个阵型的平均综合水平分别是多少。\n", "inputFormat": "第一行有四个整数 $K, D, M, F$，分别表示守门员、后卫、中场和前锋供挑选的球员人数。\n\n第二行有 $K$ 个整数 $k_i$，分别表示每个守门员的综合水平值。\n\n第三行有 $D$ 个整数 $d_i$，分别表示每个后卫的综合水平值。\n\n第四行有 $M$ 个整数 $m_i$，分别表示每个中场的综合水平值。\n\n第五行有 $F$ 个整数 $f_i$，分别表示每个前锋的综合水平值。\n\n第六行有一个整数 $Q$，表示教练团队提出的阵型个数。\n\n以下 $Q$ 行，第 $i$ 行三个整数 $A_i, B_i, C_i$，由空格间隔，表示第 $i$ 阵型是 $A_i - B_i - C_i$ 阵型。", "outputFormat": "输出 $Q$ 行。对于第 $i$ 种阵型，输出一个实数，表示该阵型平均综合水平的最大值，并四舍五入到小数点后 $2$ 位。", "hint": "对于 $30\\%$ 数据，$K, D, M, F≤1000$，$Q≤10$；\n\n对于 $100\\%$ 数据，$1≤K, D, M, F≤10^5$，$0≤k_i, d_i, m_i, f_i≤10^8$，$1≤Q≤K$，$0≤A_i, B_i, C_i≤10$，$A_i+B_i+C_i=10$，$∑A_i≤D$，$∑B_i≤M$，$∑C_i≤F$", "locale": "zh-CN", "translations": {"en": {"title": "[GDOI2014] World Cup", "background": "", "description": "The 3014 World Cup is about to begin! As the coach of the defending champion, the Chinese national football team, every player under your command is a powerhouse. Figuring out the strongest 11-player lineup is a happy kind of trouble.\n\nAs is well known, the 11 players in a football lineup are each assigned to a particular position, which are mainly divided into four types: goalkeeper, defender, midfielder, and forward. There is exactly one goalkeeper, and the number of defenders, midfielders, and forwards depends on the formation you set. A formation is expressed as $A$-$B$-$C$ from defenders to forwards, not counting the goalkeeper. For example, a 3-5-2 formation means there are three defenders, five midfielders, and two forwards. Due to fierce competition, each player is trained only for one position, so each person can play only one of the four positions.\n\nAs a coach who knows the players’ abilities inside out, you have quantified each player’s overall rating. To better arrange the formations, your coaching team decides to use the following strategy to assign players: first, propose $Q$ formations in order, representing the first formation, the second formation, …, the $Q$-th formation. Then, for each formation, choose from the players not yet selected the best available numbers of goalkeeper(s), defenders, midfielders, and forwards. For example, for the first formation, select from all players; for the second formation, select from all players except those chosen for the first formation; for the third formation, select from all players except those chosen for the first and second formations; and so on.\n\nNow that the $Q$ formations are fixed, what you need to know is the average overall rating for each formation.", "inputFormat": "The first line contains four integers $K, D, M, F$, representing the number of available goalkeepers, defenders, midfielders, and forwards.\n\nThe second line contains $K$ integers $k_i$, representing the overall rating of each goalkeeper.\n\nThe third line contains $D$ integers $d_i$, representing the overall rating of each defender.\n\nThe fourth line contains $M$ integers $m_i$, representing the overall rating of each midfielder.\n\nThe fifth line contains $F$ integers $f_i$, representing the overall rating of each forward.\n\nThe sixth line contains an integer $Q$, representing the number of formations proposed by the coaching team.\n\nEach of the following $Q$ lines contains three integers $A_i, B_i, C_i$ separated by spaces, indicating that the $i$-th formation is the $A_i$-$B_i$-$C_i$ formation.", "outputFormat": "Output $Q$ lines. For the $i$-th formation, output a real number representing the maximum possible average overall rating for that formation, rounded to $2$ decimal places.", "hint": "For $30\\%$ testdata, $K, D, M, F \\le 1000$, $Q \\le 10$.\n\nFor $100\\%$ testdata, $1 \\le K, D, M, F \\le 10^5$, $0 \\le k_i, d_i, m_i, f_i \\le 10^8$, $1 \\le Q \\le K$, $0 \\le A_i, B_i, C_i \\le 10$, $A_i + B_i + C_i = 10$, $\\sum A_i \\le D$, $\\sum B_i \\le M$, $\\sum C_i \\le F$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[GDOI2014] 世界杯", "background": "", "description": "3014 年世界杯足球赛就要开始了！作为卫冕冠军中国足球队的教练，手下每位球员都是猛将，如何摆出最强的 11 人阵容也是一件幸福的烦恼事啊。\n\n众所周知，足球阵容里的11个球员都会被分配到场上某一个特别的位置，而这些位置主要分为守门员、后卫、中场和前锋四种，其中守门员有且只有一个，后卫、中场和前锋的人数取决于你安排的足球阵型。形容足球阵型的方法由后卫开始计算至前锋，但不把守门员计算在内。例如，3-5-2 阵型是指有三个后卫、五个中场及两名前锋。由于竞争激烈，每位球员只会培养其中一种位置所需要的技能，所以他们每个人都只能胜任四个位置中的其中一种。\n\n作为一个对球员能力了如指掌的教练，你给每个球员的综合水平进行量化。为了将阵型安排得更好，你的教练团队决定使用以下策略安排球员：首先按照顺序提出 $Q$ 个阵型，分别代表第一阵型、第二阵型、……、第 $Q$ 阵型。然后对于每个阵型，从仍未选择的球员中选择最好的对应数量的守门员、后卫、中场和前锋。比如说，对于第一阵型，在所有球员中选择；对于第二阵型，在除了第一阵型外的所有球员中选择；对于第三阵型，在除了第一阵型和第二阵型外的所有球员中选择；以此类推。\n\n现在 $Q$ 个阵型都已经确定，而你需要知道的，是每个阵型的平均综合水平分别是多少。\n", "inputFormat": "第一行有四个整数 $K, D, M, F$，分别表示守门员、后卫、中场和前锋供挑选的球员人数。\n\n第二行有 $K$ 个整数 $k_i$，分别表示每个守门员的综合水平值。\n\n第三行有 $D$ 个整数 $d_i$，分别表示每个后卫的综合水平值。\n\n第四行有 $M$ 个整数 $m_i$，分别表示每个中场的综合水平值。\n\n第五行有 $F$ 个整数 $f_i$，分别表示每个前锋的综合水平值。\n\n第六行有一个整数 $Q$，表示教练团队提出的阵型个数。\n\n以下 $Q$ 行，第 $i$ 行三个整数 $A_i, B_i, C_i$，由空格间隔，表示第 $i$ 阵型是 $A_i - B_i - C_i$ 阵型。", "outputFormat": "输出 $Q$ 行。对于第 $i$ 种阵型，输出一个实数，表示该阵型平均综合水平的最大值，并四舍五入到小数点后 $2$ 位。", "hint": "对于 $30\\%$ 数据，$K, D, M, F≤1000$，$Q≤10$；\n\n对于 $100\\%$ 数据，$1≤K, D, M, F≤10^5$，$0≤k_i, d_i, m_i, f_i≤10^8$，$1≤Q≤K$，$0≤A_i, B_i, C_i≤10$，$A_i+B_i+C_i=10$，$∑A_i≤D$，$∑B_i≤M$，$∑C_i≤F$", "locale": "zh-CN"}}}
{"pid": "P3888", "type": "P", "difficulty": 5, "samples": [["3 3\n6 5 4\n1 2 3\n7 8 9", "3 6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2014", "各省省选", "广东", "枚举", "进制", "状压 DP"], "title": "[GDOI2014] 拯救莫莉斯", "background": "", "description": "莫莉斯·乔是圣域里一个叱咤风云的人物，他凭借着自身超强的经济头脑，牢牢控制了圣域的石油市场。\n\n圣域的地图可以看成是一个 $n\\times m$ 的矩阵。每个整数坐标点 $(x, y)$ 表示一座城市（$1\\le x\\le n,1\\le y\\le m$）。两座城市间相邻的定义为：对于城市 $(A_x, A_y)$ 和城市 $(B_x, B_y)$，满足 $(A_x - B_x)^2 + (A_y - B_y)^2 = 1$。\n\n由于圣域的石油贸易总量很大，莫莉斯意识到不能让每笔石油订购单都从同一个油库里发货。为了提高效率，莫莉斯·乔决定在其中一些城市里建造油库，最终使得每一个城市 $X$ 都满足下列条件之一：\n\n1. 该城市 $X$ 内建有油库.\n2. 某城市 $Y$ 内建有油库，且城市 $X$ 与城市 $Y$ 相邻。\n\n与地球类似，圣域里不同城市间的地价可能也会有所不同，所以莫莉斯想让完成目标的总花费尽可能少。如果存在多组方案，为了方便管理，莫莉斯会选择建造较少的油库个数。\n", "inputFormat": "第一行两个正整数 $n,m$（$n \\times m \\le 50$ 且 $m\\le n$），表示矩阵的大小。\n\n接下来一个 $n$ 行 $m$ 列的矩阵 $F$，$F_{i, j}$表示在城市 $(i,j)$ 建造油库的代价。\n", "outputFormat": "输出两个数，建造方案的油库个数和方案的总代价。\n", "hint": "对于 $30\\%$ 数据满足 $n \\times m \\le 25$;   \n对于 $100\\%$ 数据满足 $n \\times m \\le 50,0 \\le F_{i, j} \\le 10 ^ 5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[GDOI2014] Save Morris", "background": "", "description": "Morris Qiao is a formidable figure in the Sanctuary. With his outstanding economic acumen, he firmly controls the oil market there.\n\nThe map of the Sanctuary can be seen as an $n \\times m$ grid. Each integer coordinate $(x, y)$ represents a city ($1 \\le x \\le n, 1 \\le y \\le m$). The definition of adjacency between two cities is: for cities $(A_x, A_y)$ and $(B_x, B_y)$, they are adjacent if $(A_x - B_x)^2 + (A_y - B_y)^2 = 1$.\n\nBecause the total volume of oil trade in the Sanctuary is large, Morris realizes that he cannot dispatch every oil order from the same depot. To improve efficiency, Morris Qiao decides to build depots in some cities, so that every city $X$ satisfies one of the following:\n\n1. City $X$ has a depot itself.\n2. There exists a city $Y$ with a depot, and city $X$ is adjacent to city $Y$.\n\nAs on Earth, land prices may differ between cities in the Sanctuary, so Morris wants to minimize the total cost of achieving the goal. If multiple plans have the same minimum total cost, to facilitate management, Morris will choose the one with fewer depots.", "inputFormat": "The first line contains two positive integers $n, m$ (with $n \\times m \\le 50$ and $m \\le n$), representing the size of the grid.\n\nThen follows an $n$-by-$m$ matrix $F$, where $F_{i, j}$ denotes the cost to build a depot in city $(i, j)$.", "outputFormat": "Output two numbers: the number of depots and the minimum total cost.", "hint": "For $30\\%$ of the testdata, $n \\times m \\le 25$.  \nFor $100\\%$ of the testdata, $n \\times m \\le 50$, $0 \\le F_{i, j} \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[GDOI2014] 拯救莫莉斯", "background": "", "description": "莫莉斯·乔是圣域里一个叱咤风云的人物，他凭借着自身超强的经济头脑，牢牢控制了圣域的石油市场。\n\n圣域的地图可以看成是一个 $n\\times m$ 的矩阵。每个整数坐标点 $(x, y)$ 表示一座城市（$1\\le x\\le n,1\\le y\\le m$）。两座城市间相邻的定义为：对于城市 $(A_x, A_y)$ 和城市 $(B_x, B_y)$，满足 $(A_x - B_x)^2 + (A_y - B_y)^2 = 1$。\n\n由于圣域的石油贸易总量很大，莫莉斯意识到不能让每笔石油订购单都从同一个油库里发货。为了提高效率，莫莉斯·乔决定在其中一些城市里建造油库，最终使得每一个城市 $X$ 都满足下列条件之一：\n\n1. 该城市 $X$ 内建有油库.\n2. 某城市 $Y$ 内建有油库，且城市 $X$ 与城市 $Y$ 相邻。\n\n与地球类似，圣域里不同城市间的地价可能也会有所不同，所以莫莉斯想让完成目标的总花费尽可能少。如果存在多组方案，为了方便管理，莫莉斯会选择建造较少的油库个数。\n", "inputFormat": "第一行两个正整数 $n,m$（$n \\times m \\le 50$ 且 $m\\le n$），表示矩阵的大小。\n\n接下来一个 $n$ 行 $m$ 列的矩阵 $F$，$F_{i, j}$表示在城市 $(i,j)$ 建造油库的代价。\n", "outputFormat": "输出两个数，建造方案的油库个数和方案的总代价。\n", "hint": "对于 $30\\%$ 数据满足 $n \\times m \\le 25$;   \n对于 $100\\%$ 数据满足 $n \\times m \\le 50,0 \\le F_{i, j} \\le 10 ^ 5$。\n", "locale": "zh-CN"}}}
{"pid": "P3889", "type": "P", "difficulty": 6, "samples": [["5\n1 2 3 4 5\n2\n2 3\n2 4", "2\n1"], ["5\n2 4 8 16 32\n2\n3 4\n2 3", "16\n8\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2014", "各省省选", "广东"], "title": "[GDOI2014] 吃", "background": "感谢 @FFjet 提醒，第 8 个数据点损坏暂时删除。", "description": "W师兄计划了很久，终于成功的在BG开了一家寿司店。\n\n正当W师兄还在兴奋的时候，这时一个噩耗传来，吃货L师姐居然知道了这件事，而且正赶过来，W师兄瞬间心就冷了下去，但是机智的W师兄也瞬间想到了应付L师姐的策略.......\n\n这时，L师姐到了寿司店，先四处望了望风景，发现现在只有L师姐一个顾客，下面是L师姐的选餐说明：\n\n1.寿司店内的寿司被排在一行共N个盘子里，按从左到右编号为1~N。\n\n2.每个位置上寿司的数量是确定的并且有玻璃窗保护。\n\n3.每隔一段时间就会有一个选餐时间，L师姐可以在一个连续的区间[l, r]中选择其中一盘，然后在该区间之外选择另一盘（如果区间外有盘子）。\n\nL师姐发现这家寿司店厨师的制作速度很快，总能在下一次选餐时间前将寿司数量恢复原样。\n\n作为有尊严有追求的吃货，L师姐也有自己的规则，L师姐在选完两盘寿司后，会决定每口恰好吃D个寿司，且使得两盘寿司刚好可以分别吃完，不剩余任何寿司。比如两盘寿司数量为2和4,那么D=1或者D=2都可以恰好将两盘寿司分别吃干净，而两盘寿司数量为3和5时，那么只能D=1才行。\n\n作为有特殊追求的L师姐才不在乎吃的数量，L师姐在乎的是一口吃多个寿司的感觉。于是，如果L师姐可以一口吃D个寿司，那么L师姐的愉悦值为D，但是L师姐没有选到两盘寿司，那么她的愉悦值为0。\n\n现在L师姐知道每个盘子所放着的寿司数量，L师姐想知道每次选择时间过后她可以获得的最大愉悦值是多少？\n", "inputFormat": "第一行输入一个整数N，表示寿司的盘子数量。\n\n第二行输入N个整数a1,a2,…,aN，ai表示第i个盘子内的寿司数量。\n\n第三行输入一个整数M，表示有多少个选餐时间。\n\n接下来M行，每行两个整数li, ri (1 <= li <= ri <= N)，含义如题面所示。\n", "outputFormat": "输出M行，第i行表示第i个选择时间师姐可能达到的最大愉悦值D。\n", "hint": "###样例解释\n\n样例1里的第一个选餐时间，可以选择2和4，这样L师姐就可以每次吃两个寿司，使得两个盘子都可以吃干净，第二个选餐时间，师姐不管选哪两个盘子，都只能每次吃一个。\n\n样例2 里的第一个选餐时间，可以选择16和32,而第二个选餐时间，L师姐可以选择8和16或者8和32。\n\n对于20%的数据，N <= 100, M <= 100, max(a1,a2,…,aN) <= 100。\n\n对于50%的数据，N <= 10000, M <= 10000, max(a1,a2,…,aN) <= 10000。\n\n对于100%的数据，N <= 100000, M <= 100000, max(a1,a2,…,aN) <= 100000。\n", "locale": "zh-CN", "translations": {"en": {"title": "[GDOI2014] Eating", "background": "Thanks to @FFjet for the reminder, the 8th test point is corrupted and has been temporarily removed.", "description": "Senior Brother W had planned for a long time and finally succeeded in opening a sushi restaurant in BG.\n\nJust as he was still excited, bad news came: foodie Senior Sister L actually learned about this and was on her way. Senior Brother W instantly felt a chill, but being clever, he immediately came up with a strategy to deal with Senior Sister L.\n\nWhen Senior Sister L arrived at the sushi restaurant, she first looked around and found that she was the only customer. Below are her selection rules:\n\n1. The sushi in the restaurant is arranged in a single row of $N$ plates, numbered from $1$ to $N$ from left to right.\n2. The number of sushi on each plate is fixed and protected by a glass cover.\n3. At each selection time, Senior Sister L may choose one plate from a continuous interval $[l, r]$, and then choose another plate outside that interval (if there are plates outside the interval).\n\nSenior Sister L finds that the chefs here work very fast and can always restore the sushi counts to their original numbers before the next selection time.\n\nAs a foodie with standards, after selecting two plates, Senior Sister L will decide to eat exactly $D$ pieces of sushi per bite, such that both plates can be finished exactly with no leftovers. For example, if the two plates contain $2$ and $4$ pieces, then $D = 1$ or $D = 2$ will finish both plates exactly. If the two plates contain $3$ and $5$ pieces, then only $D = 1$ works.\n\nSenior Sister L does not care about the total amount of food; she cares about the feeling of eating multiple pieces in one bite. Thus, if she can eat $D$ pieces per bite, her joy value is $D$. If she cannot select two plates, her joy value is $0$.\n\nGiven the number of sushi on each plate, Senior Sister L wants to know, after each selection time, what is the maximum joy value she can obtain.", "inputFormat": "- The first line contains an integer $N$, the number of sushi plates.\n- The second line contains $N$ integers $a_1, a_2, \\dots, a_N$, where $a_i$ is the number of sushi on the $i$-th plate.\n- The third line contains an integer $M$, the number of selection times.\n- The next $M$ lines each contain two integers $l_i, r_i$ with $1 \\le l_i \\le r_i \\le N$, as described above.", "outputFormat": "Output $M$ lines. The $i$-th line contains the maximum possible joy value $D$ for the $i$-th selection time.", "hint": "Sample explanation:\n- In sample 1, for the first selection time, you can choose $2$ and $4$, so Senior Sister L can eat $2$ pieces per bite and finish both plates exactly. For the second selection time, no matter which two plates she chooses, she can only eat $1$ piece per bite.\n- In sample 2, for the first selection time, she can choose $16$ and $32$. For the second selection time, she can choose $8$ and $16$ or $8$ and $32$.\n\nConstraints:\n- For 20% of the testdata, $N \\le 100$, $M \\le 100$, $\\max(a_1, a_2, \\dots, a_N) \\le 100$.\n- For 50% of the testdata, $N \\le 10000$, $M \\le 10000$, $\\max(a_1, a_2, \\dots, a_N) \\le 10000$.\n- For 100% of the testdata, $N \\le 100000$, $M \\le 100000$, $\\max(a_1, a_2, \\dots, a_N) \\le 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[GDOI2014] 吃", "background": "感谢 @FFjet 提醒，第 8 个数据点损坏暂时删除。", "description": "W师兄计划了很久，终于成功的在BG开了一家寿司店。\n\n正当W师兄还在兴奋的时候，这时一个噩耗传来，吃货L师姐居然知道了这件事，而且正赶过来，W师兄瞬间心就冷了下去，但是机智的W师兄也瞬间想到了应付L师姐的策略.......\n\n这时，L师姐到了寿司店，先四处望了望风景，发现现在只有L师姐一个顾客，下面是L师姐的选餐说明：\n\n1.寿司店内的寿司被排在一行共N个盘子里，按从左到右编号为1~N。\n\n2.每个位置上寿司的数量是确定的并且有玻璃窗保护。\n\n3.每隔一段时间就会有一个选餐时间，L师姐可以在一个连续的区间[l, r]中选择其中一盘，然后在该区间之外选择另一盘（如果区间外有盘子）。\n\nL师姐发现这家寿司店厨师的制作速度很快，总能在下一次选餐时间前将寿司数量恢复原样。\n\n作为有尊严有追求的吃货，L师姐也有自己的规则，L师姐在选完两盘寿司后，会决定每口恰好吃D个寿司，且使得两盘寿司刚好可以分别吃完，不剩余任何寿司。比如两盘寿司数量为2和4,那么D=1或者D=2都可以恰好将两盘寿司分别吃干净，而两盘寿司数量为3和5时，那么只能D=1才行。\n\n作为有特殊追求的L师姐才不在乎吃的数量，L师姐在乎的是一口吃多个寿司的感觉。于是，如果L师姐可以一口吃D个寿司，那么L师姐的愉悦值为D，但是L师姐没有选到两盘寿司，那么她的愉悦值为0。\n\n现在L师姐知道每个盘子所放着的寿司数量，L师姐想知道每次选择时间过后她可以获得的最大愉悦值是多少？\n", "inputFormat": "第一行输入一个整数N，表示寿司的盘子数量。\n\n第二行输入N个整数a1,a2,…,aN，ai表示第i个盘子内的寿司数量。\n\n第三行输入一个整数M，表示有多少个选餐时间。\n\n接下来M行，每行两个整数li, ri (1 <= li <= ri <= N)，含义如题面所示。\n", "outputFormat": "输出M行，第i行表示第i个选择时间师姐可能达到的最大愉悦值D。\n", "hint": "###样例解释\n\n样例1里的第一个选餐时间，可以选择2和4，这样L师姐就可以每次吃两个寿司，使得两个盘子都可以吃干净，第二个选餐时间，师姐不管选哪两个盘子，都只能每次吃一个。\n\n样例2 里的第一个选餐时间，可以选择16和32,而第二个选餐时间，L师姐可以选择8和16或者8和32。\n\n对于20%的数据，N <= 100, M <= 100, max(a1,a2,…,aN) <= 100。\n\n对于50%的数据，N <= 10000, M <= 10000, max(a1,a2,…,aN) <= 10000。\n\n对于100%的数据，N <= 100000, M <= 100000, max(a1,a2,…,aN) <= 100000。\n", "locale": "zh-CN"}}}
{"pid": "P3890", "type": "P", "difficulty": 6, "samples": [["2 4\n10 5\n5 10\n", "0 15\n15 0\n"], ["3 16\n6 5 7\n5 6 7\n7 7 6\n", "0 3 3\n3 0 3\n3 3 0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "各省省选", "广东"], "title": "[GDOI2014] 比特矩阵", "background": "你知道矩阵乘法吗？\n\n对于两个 $n\\times n$ 的矩阵 A 和 B， 假设 $a_{i, j}$ 表示位于矩阵 A 的第 $i$ 行第 $j$ 列的元素， 同样对于B可以定义类似的 $b_{i,j}$。 那么如果 $C = A \\times B$，则有 $c_{i, j}=\\sum_{k=1}^{n} a_{ik} \\times b_{kj}$。 其中 $ \\sum$ 是序列求和符号，例如 $\\sum_{i=1}^{n} i$ 表示 $1 + 2 + \\cdots + n$。\n", "description": "由于霍比特人的大热， L 的室友 X 最近热衷于研究它们所使用的货币。为了进行研究，X 需要了解一种叫比特矩阵的东西。 虽然比特矩阵也是矩阵，但是它的乘法和一般的矩阵有点不一样。\n\n对于比特矩阵 $C = A \\times B$， 意味着 $c_{i,j} = V_{k=1}^{n}a_{ik} \\bigoplus b_{kj}$。其中 $V$ 是序列求按位或的符号，例如 $V_{i=1}^{n} i$ 表示 $1 \\mid 2 \\mid \\cdots \\mid n$。 $\\mid$ 就是按位或的意思。 按位或是指从二进制的角度看两个数， 如果第 $i$ 位上两个数至少一个是1的话那结果的第 $i$ 位就是1， 否则第 $i$ 位就是 $0$。 $\\bigoplus$ 表示按位异或运算， 即如果两个二进制数的第$i$位是不相同的话那么结果的第 $i$ 位就是 $1$，否则就是 $0$。\n\n举个比特矩阵相乘的例子:\n\n$$\\begin{bmatrix}1&6\\\\3&5\\end{bmatrix}\\times\\begin{bmatrix}3&6\\\\5&7\\end{bmatrix}=\\begin{bmatrix}3&7\\\\0&7\\end{bmatrix}$$\n\n现在 X 想要拜托你帮他算 $A^{m}$，其中 $A$ 是一个 $n\\times n$ 的比特矩阵， 而 $A^{m}$ 表示 $m$ 个 $ A$ 相乘的结果。严谨地说:\n\n- $A^{1}=A$；\n- $A^{m}=A^{m-1}\\times A,\\ m>1$。\n", "inputFormat": "输入第一行包含两个正整数 $n,m$。\n\n接下来 $n$ 行，每行包含 $n$ 个非负整数，这 $n$ 行中第 $i$ 行的第 $j$ 个数表示比特矩阵 $a_{i,j}$ 的元素 。\n", "outputFormat": "根据输入，输出一个比特矩阵 $A^{m}$。即按照输入给出 $A$ 的方式输出一个比特矩阵。 具体参看样例输出。\n", "hint": "### 数据范围及约定\n\n- 对于 $10\\%$ 的数据 $n\\le 4$，$ m\\le 10000$。\n- 对于 $30\\%$ 的数据 $n\\le 10$，$ m\\le 10^9$。\n- 对于 $100\\%$ 的数据 $n\\le 500$，$ m\\le 10^9$, 所有输入的整数不超过$10^9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[GDOI2014] Bit Matrix", "background": "Do you know matrix multiplication?\n\nFor two $n \\times n$ matrices $A$ and $B$, suppose $a_{i, j}$ denotes the element in row $i$ and column $j$ of matrix $A$; similarly define $b_{i, j}$ for $B$. If $C = A \\times B$, then $c_{i, j} = \\sum_{k=1}^{n} a_{i k} \\times b_{k j}$. Here $\\sum$ is the summation symbol; for example, $\\sum_{i=1}^{n} i$ means $1 + 2 + \\cdots + n$.", "description": "Due to the popularity of The Hobbit, L’s roommate X has recently become interested in the currency they use. For this study, X needs to understand something called a bit matrix. Although a bit matrix is still a matrix, its multiplication is a little different from ordinary matrix multiplication.\n\nFor bit matrices, $C = A \\times B$ means $c_{i, j} = V_{k=1}^{n} a_{i k} \\bigoplus b_{k j}$. Here $V$ denotes taking bitwise OR over a sequence; for example, $V_{i=1}^{n} i$ means $1 \\mid 2 \\mid \\cdots \\mid n$. The symbol $\\mid$ means bitwise OR. Bitwise OR views two numbers in binary: if at bit $i$ at least one of the two numbers is $1$, then the $i$-th bit of the result is $1$; otherwise that bit is $0$. The symbol $\\bigoplus$ denotes bitwise XOR: if the $i$-th bits of two binary numbers are different, then the $i$-th bit of the result is $1$; otherwise it is $0$.\n\nHere is an example of bit-matrix multiplication.\n$$\\begin{bmatrix}1&6\\\\3&5\\end{bmatrix}\\times\\begin{bmatrix}3&6\\\\5&7\\end{bmatrix}=\\begin{bmatrix}3&7\\\\0&7\\end{bmatrix}$$\n\nNow X would like you to compute $A^{m}$, where $A$ is an $n \\times n$ bit matrix, and $A^{m}$ is the result of multiplying $m$ copies of $A$. Precisely:\n- $A^{1} = A$.\n- $A^{m} = A^{m-1} \\times A$, for $m > 1$.", "inputFormat": "The first line contains two positive integers $n, m$.\nThe next $n$ lines each contain $n$ non-negative integers; in these $n$ lines, the $j$-th number of the $i$-th line is the element $a_{i, j}$ of the bit matrix.", "outputFormat": "Output the bit matrix $A^{m}$. That is, print a bit matrix in the same format as the input matrix $A$. See the sample output for details.", "hint": "Constraints\n- For $10\\%$ of the testdata, $n \\le 4$, $m \\le 10000$.\n- For $30\\%$ of the testdata, $n \\le 10$, $m \\le 10^9$.\n- For $100\\%$ of the testdata, $n \\le 500$, $m \\le 10^9$, and all input integers do not exceed $10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[GDOI2014] 比特矩阵", "background": "你知道矩阵乘法吗？\n\n对于两个 $n\\times n$ 的矩阵 A 和 B， 假设 $a_{i, j}$ 表示位于矩阵 A 的第 $i$ 行第 $j$ 列的元素， 同样对于B可以定义类似的 $b_{i,j}$。 那么如果 $C = A \\times B$，则有 $c_{i, j}=\\sum_{k=1}^{n} a_{ik} \\times b_{kj}$。 其中 $ \\sum$ 是序列求和符号，例如 $\\sum_{i=1}^{n} i$ 表示 $1 + 2 + \\cdots + n$。\n", "description": "由于霍比特人的大热， L 的室友 X 最近热衷于研究它们所使用的货币。为了进行研究，X 需要了解一种叫比特矩阵的东西。 虽然比特矩阵也是矩阵，但是它的乘法和一般的矩阵有点不一样。\n\n对于比特矩阵 $C = A \\times B$， 意味着 $c_{i,j} = V_{k=1}^{n}a_{ik} \\bigoplus b_{kj}$。其中 $V$ 是序列求按位或的符号，例如 $V_{i=1}^{n} i$ 表示 $1 \\mid 2 \\mid \\cdots \\mid n$。 $\\mid$ 就是按位或的意思。 按位或是指从二进制的角度看两个数， 如果第 $i$ 位上两个数至少一个是1的话那结果的第 $i$ 位就是1， 否则第 $i$ 位就是 $0$。 $\\bigoplus$ 表示按位异或运算， 即如果两个二进制数的第$i$位是不相同的话那么结果的第 $i$ 位就是 $1$，否则就是 $0$。\n\n举个比特矩阵相乘的例子:\n\n$$\\begin{bmatrix}1&6\\\\3&5\\end{bmatrix}\\times\\begin{bmatrix}3&6\\\\5&7\\end{bmatrix}=\\begin{bmatrix}3&7\\\\0&7\\end{bmatrix}$$\n\n现在 X 想要拜托你帮他算 $A^{m}$，其中 $A$ 是一个 $n\\times n$ 的比特矩阵， 而 $A^{m}$ 表示 $m$ 个 $ A$ 相乘的结果。严谨地说:\n\n- $A^{1}=A$；\n- $A^{m}=A^{m-1}\\times A,\\ m>1$。\n", "inputFormat": "输入第一行包含两个正整数 $n,m$。\n\n接下来 $n$ 行，每行包含 $n$ 个非负整数，这 $n$ 行中第 $i$ 行的第 $j$ 个数表示比特矩阵 $a_{i,j}$ 的元素 。\n", "outputFormat": "根据输入，输出一个比特矩阵 $A^{m}$。即按照输入给出 $A$ 的方式输出一个比特矩阵。 具体参看样例输出。\n", "hint": "### 数据范围及约定\n\n- 对于 $10\\%$ 的数据 $n\\le 4$，$ m\\le 10000$。\n- 对于 $30\\%$ 的数据 $n\\le 10$，$ m\\le 10^9$。\n- 对于 $100\\%$ 的数据 $n\\le 500$，$ m\\le 10^9$, 所有输入的整数不超过$10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P3891", "type": "P", "difficulty": 5, "samples": [["1 1 8\n1 1\n", "4"], ["2 1 8\n1 1\n2 8\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "递推", "2014", "各省省选", "广东", "背包 DP"], "title": "[GDOI2014] 采集资源", "background": null, "description": "魔兽争霸 3 中，战略资源的采集通过使用农民、苦工、小精灵以及寺僧来进行。\n\n在魔兽争霸 4 的开发中，玻璃渣觉得这种模式太过单一，于是他们想添加更多的单位来使采集的模式更加丰富。\n\n在新的模式中，玩家可以建造更多种类的“苦工”，不同的“苦工”的工作效率不同，同时，建造不同的“苦工”所需要的资源也是不一样的。\n\n玻璃渣出品的游戏以追求平衡著称，所以为了测试这种新的模式的平衡性，他们设计了一套检测的方法：在各种族的起始资源相同时，测量达到某一资源数量的时间，如果相同则可以认为设计是平衡的。\n\n他们将数据给你，希望你能测试出设计是否平衡。", "inputFormat": "第一行三个数，$N,M,T$，表示苦工的种类、开始时拥有的资源数量以及需要达到的资源的数量。\n\n接下来 $N$ 行，每行2个数 $A,B$，表示生产这种苦工所需要的资源，以及这个苦工的效率，效率即为单位时间内产生的资源的数量。", "outputFormat": "一个数字，表示资源数量达到 $T$ 时的最少时间。\n\n\n注意：与魔兽争霸 3 不同，魔兽争霸 4 中，生产苦工不需要时间。并且资源的采集并不连续，亦即如果一个苦工的效率为 $2$，他会在时间为 $1$ 的时候收获 $2$ 点资源，而并不会在时间为 $0.5$ 的时候收获 $1$ 点资源。", "hint": "对于 $30\\%$ 的数据，$N\\le 10$，$M,T \\le  300$；\n\n对于 $100\\%$ 的数据，$N\\le 100$，$M,T \\le1000$，$A,B\\le 2^{31}$。\n\n数据保证有解。", "locale": "zh-CN", "translations": {"en": {"title": "[GDOI2014] Resource Gathering", "background": "# Description\n\nIn Warcraft III, strategic resources are collected by using Peasants, Peons, Wisps, and Acolytes.\n\nDuring the development of Warcraft IV, Blizzard thought this model was too single-pattern, so they wanted to add more units to make gathering more diverse.\n\nIn the new mode, players can build more types of \"workers\". Different \"workers\" have different efficiencies, and the resources required to build different \"workers\" are also different.\n\nBlizzard’s games are known for pursuing balance, so to test the balance of this new mode, they designed a method: when all races have the same starting resources, measure the time to reach a certain amount of resources. If the times are the same, the design is considered balanced.\n\nThey gave you the data and hope you can test whether the design is balanced.", "description": "", "inputFormat": "", "outputFormat": "Print a single number: the minimum time when the amount of resources reaches $T$.\n\nNote: Unlike in Warcraft III, in Warcraft IV producing workers takes no time. Also, resource collection is not continuous. That is, if a worker’s efficiency is $2$, they will harvest $2$ resources at time $1$, and will not harvest $1$ resource at time $0.5$.", "hint": "- For $30\\%$ of the testdata, $N \\le 10$, $M, T \\le 300$.\n- For $100\\%$ of the testdata, $N \\le 100$, $M, T \\le 1000$, $A, B \\le 2^{31}$.\n- The testdata guarantees that a solution exists.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[GDOI2014] 采集资源", "background": null, "description": "魔兽争霸 3 中，战略资源的采集通过使用农民、苦工、小精灵以及寺僧来进行。\n\n在魔兽争霸 4 的开发中，玻璃渣觉得这种模式太过单一，于是他们想添加更多的单位来使采集的模式更加丰富。\n\n在新的模式中，玩家可以建造更多种类的“苦工”，不同的“苦工”的工作效率不同，同时，建造不同的“苦工”所需要的资源也是不一样的。\n\n玻璃渣出品的游戏以追求平衡著称，所以为了测试这种新的模式的平衡性，他们设计了一套检测的方法：在各种族的起始资源相同时，测量达到某一资源数量的时间，如果相同则可以认为设计是平衡的。\n\n他们将数据给你，希望你能测试出设计是否平衡。", "inputFormat": "第一行三个数，$N,M,T$，表示苦工的种类、开始时拥有的资源数量以及需要达到的资源的数量。\n\n接下来 $N$ 行，每行2个数 $A,B$，表示生产这种苦工所需要的资源，以及这个苦工的效率，效率即为单位时间内产生的资源的数量。", "outputFormat": "一个数字，表示资源数量达到 $T$ 时的最少时间。\n\n\n注意：与魔兽争霸 3 不同，魔兽争霸 4 中，生产苦工不需要时间。并且资源的采集并不连续，亦即如果一个苦工的效率为 $2$，他会在时间为 $1$ 的时候收获 $2$ 点资源，而并不会在时间为 $0.5$ 的时候收获 $1$ 点资源。", "hint": "对于 $30\\%$ 的数据，$N\\le 10$，$M,T \\le  300$；\n\n对于 $100\\%$ 的数据，$N\\le 100$，$M,T \\le1000$，$A,B\\le 2^{31}$。\n\n数据保证有解。", "locale": "zh-CN"}}}
{"pid": "P3892", "type": "P", "difficulty": 4, "samples": [["7 5 17\ncreateContest 1 5 1001 1004 1002 1005 1006\nsubmission 1 1 1001 1 AC\nsubmission 2 1 1001 1 AC\nsubmission 3 1 1001 2 UNAC\nsubmission 4 1 1003 3 UNAC\ngetRank 1 1\ngetRank 1 2\ngetRank 1 3\nrejudge 3\nsubmission 3 1 1001 2 AC\ngetRank 1 2\nsubmission 5 1 1006 2 AC\ngetRank 1 1\nsubmission 6 1 1006 2 UNAC\ngetRank 1 2\nrejudge 5\ngetRank 1 2\n", "1 1 1 1\n2 0 2 3\n3 0 2 3\n2 1 1 2\n1 1 2 2\n2 2 1 1\n2 1 1 2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2014", "各省省选", "广东"], "title": "[GDOI2014] OJ", "background": "", "description": "小 M 是一个勤奋的 ACMer，他利用课余时间刷了很多题目。但他是个很健忘的孩子，经常会忘记自己刷过一些什么题目，所以他想写一个 OJ 来管理自己做过的题目。\n\n经过一个星期的努力，小 M 的 OJ 基本成型，只是还差一个 Contest 的模块没有实现。小 M 觉得这个模块很难实现，所以他希望找你来帮忙。\n\n小 M 告诉你，一个 OJ 的基础元素包括：\n\n1. 题目，可以用 pid 唯一标识，pid 为正整数；\n2. 比赛，可以用 cid 唯一标识，cid 为正整数；\n3. 用户，可以用 uid 唯一标识，uid 为正整数；\n4. 提交状态，可以由 sid 唯一标识，sid 为正整数。\n\n一个提交状态是由 sid、cid、pid、uid 和 result 组成的，分别表示本条状态的提交 ID，所属比赛 ID，题目 ID，用户 ID 以及评测结果。\n\n简单起见，这里的 result 只有 AC、UNAC 和 WAIT 三种状态，分别表示通过、不通过和等待评测。\n\n同时小 M 提出一个比赛模块需要实现以下请求：\n\n1. `createContest cid t pid_1 pid_2 … pid_t`\n\n表示要创建一个比赛，cid 是一个正整数，是这场比赛的唯一标识。\n\n$t$ 表示这场比赛有 $t$（($1\\le t\\le1000$)）道题目，接下来 $t$ 个不同的整数，表示这场比赛的题目编号。\n\n2. `submission sid cid pid uid result`\n\n该条状态的 sid 要么之前没出现过，要么以前出现过，但是被 rejudge 了。\n\nresult 为 AC 或者 UNAC。\n\n3. `getRank cid uid`\n\n在一场比赛中，所有有提交的用户都应该算在排名内（包括被 rejudge 的提交），用户的排名按照通过的题目数从大到小排序，如果题目数相同，则按随机顺序排序。\n\n该指令需要统计用户 uid 在 cid 这场比赛中的通过目数，最高排名以及最低排名。\n\n值得注意的是，用户 uid 在 cid 这场比赛中同一道题目的多个通过记录只算一次。\n\n输出格式为：`uid solved highest lowest`。\n\n分别代表用户 ID，通过题目数量，最高排名以及最低排名，其中 $\\mathit{highest}\\le\\mathit{lowest}$。\n\n4. `rejudge sid`\n\n重测以 sid 标识的提交记录，即将该记录的 result 改成 WAIT。\n", "inputFormat": "第一行三个整数 $\\mathit{pcnt}$、$\\mathit{ucnt}$、$m$（$1\\le\\mathit{pcnt}\\le5000,1\\le\\mathit{ucnt}\\le5000,1\\le m\\le3\\times10^5$），分别表示 OJ 有 pcnt 道题目，ucnt 个用户以及 m 条请求。\n\npid 的范围是 $1000\\sim1000+\\mathit{pcnt}-1$，uid 的范围是 $1\\sim\\mathit{ucnt}$，cid 的范围为 $1\\sim50$，$1\\le\\mathit{sid}\\le m$。\n\n接下来有 $m$ 行，每行一个请求，请求为题述四种请求之一，请求需要按输入顺序执行。\n\n你需要注意以下几点：\n\n1. 对于 `createContest` 请求，保证 cid 不会与之前的 createContest 的 cid 重复。\n2. 对于 `submission` 请求，在此请求前，保证比赛 cid 已经创建，题目 pid 是该场比赛的题目之一。\n3. 对于 `getRank` 指令，在此请求前，保证比赛 cid 已经创建，用户 uid 至少在该比赛中有一个提交记录。\n4. 对于 `rejudge` 指令，在此请求前，保证存在以 sid 标识的提交。\n", "outputFormat": "对于每一个 `getRank` 请求，根据要求输出用户 ID，通过题目数量，最高排名以及最低排名，整数之间用一个空格隔开。\n", "hint": "对于 $20\\%$ 的数据，$1\\le\\mathit{pcnt},\\mathit{ucnt},m\\le100$；\n\n对于 $50\\%$ 的数据，$1\\le\\mathit{pcnt},\\mathit{ucnt}\\le2000,1\\le m\\le50000$；\n\n对于 $100\\%$ 的数据，$1\\le\\mathit{pcnt},\\mathit{ucnt}\\le5000,1\\le m\\le3\\times10^5,1\\le\\mathit{cid}\\le50$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[GDOI2014] OJ", "background": "", "description": "Xiao M is a diligent ACMer. He has solved many problems in his spare time. But he is very forgetful and often forgets which problems he has solved, so he wants to write an OJ to manage the problems he has done.\n\nAfter a week of effort, Xiao M’s OJ is basically finished, except for a Contest module that has not been implemented. Xiao M thinks this module is hard to implement, so he wants you to help.\n\nXiao M tells you that the basic elements of an OJ include:\n1. Problem, uniquely identified by pid, where pid is a positive integer.\n2. Contest, uniquely identified by cid, where cid is a positive integer.\n3. User, uniquely identified by uid, where uid is a positive integer.\n4. Submission status, uniquely identified by sid, where sid is a positive integer.\n\nA submission status consists of sid, cid, pid, uid, and result, representing the submission ID of this entry, the contest ID it belongs to, the problem ID, the user ID, and the judging result.\n\nFor simplicity, result has only three states: AC, UNAC, and WAIT, meaning accepted, not accepted, and waiting for judge, respectively.\n\nMeanwhile, the contest module needs to support the following requests:\n1. `createContest cid t pid_1 pid_2 … pid_t`\n\nThis creates a contest. The cid is a positive integer and is the unique identifier of this contest.\n\nHere $t$ indicates there are $t$ problems ($1 \\le t \\le 1000$) in this contest, followed by $t$ distinct integers denoting the problem IDs of this contest.\n\n2. `submission sid cid pid uid result`\n\nThe sid of this status either has not appeared before, or it has appeared before but was rejudged.\n\nThe result is AC or UNAC.\n\n3. `getRank cid uid`\n\nIn a contest, all users who have any submission should be included in the ranking (including submissions that have been rejudged). Users are ranked by the number of solved problems in descending order; if the solved count is the same, the tie-breaking is random.\n\nThis command needs to report the number of problems solved by user uid in contest cid, their best possible rank and worst possible rank.\n\nNote that multiple accepted records on the same problem by user uid in contest cid count only once.\n\nThe output format is: `uid solved highest lowest`.\n\nThese represent the user ID, solved problem count, highest rank, and lowest rank, with $\\mathit{highest} \\le \\mathit{lowest}$.\n\n4. `rejudge sid`\n\nRejudge the submission identified by sid, i.e., set its result to WAIT.", "inputFormat": "The first line contains three integers $\\mathit{pcnt}$, $\\mathit{ucnt}$, and $m$ ($1 \\le \\mathit{pcnt} \\le 5000, 1 \\le \\mathit{ucnt} \\le 5000, 1 \\le m \\le 3 \\times 10^5$), indicating that the OJ has $\\mathit{pcnt}$ problems, $\\mathit{ucnt}$ users, and $m$ requests.\n\nThe range of pid is $1000 \\sim 1000+\\mathit{pcnt}-1$, the range of uid is $1 \\sim \\mathit{ucnt}$, the range of cid is $1 \\sim 50$, and $1 \\le \\mathit{sid} \\le m$.\n\nThen there are $m$ lines, each containing one request, which is one of the four types described above. Requests should be executed in the input order.\n\nYou should note the following:\n1. For a `createContest` request, cid will not duplicate any previous createContest’s cid.\n2. For a `submission` request, before this request, the contest cid has already been created, and pid is one of the problems in that contest.\n3. For a `getRank` request, before this request, the contest cid has already been created, and user uid has at least one submission record in that contest.\n4. For a `rejudge` request, before this request, a submission identified by sid exists.", "outputFormat": "For each `getRank` request, output the user ID, solved problem count, highest rank, and lowest rank, separated by single spaces.", "hint": "For $20\\%$ of the testdata, $1 \\le \\mathit{pcnt}, \\mathit{ucnt}, m \\le 100$.\n\nFor $50\\%$ of the testdata, $1 \\le \\mathit{pcnt}, \\mathit{ucnt} \\le 2000, 1 \\le m \\le 50000$.\n\nFor $100\\%$ of the testdata, $1 \\le \\mathit{pcnt}, \\mathit{ucnt} \\le 5000, 1 \\le m \\le 3 \\times 10^5, 1 \\le \\mathit{cid} \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[GDOI2014] OJ", "background": "", "description": "小 M 是一个勤奋的 ACMer，他利用课余时间刷了很多题目。但他是个很健忘的孩子，经常会忘记自己刷过一些什么题目，所以他想写一个 OJ 来管理自己做过的题目。\n\n经过一个星期的努力，小 M 的 OJ 基本成型，只是还差一个 Contest 的模块没有实现。小 M 觉得这个模块很难实现，所以他希望找你来帮忙。\n\n小 M 告诉你，一个 OJ 的基础元素包括：\n\n1. 题目，可以用 pid 唯一标识，pid 为正整数；\n2. 比赛，可以用 cid 唯一标识，cid 为正整数；\n3. 用户，可以用 uid 唯一标识，uid 为正整数；\n4. 提交状态，可以由 sid 唯一标识，sid 为正整数。\n\n一个提交状态是由 sid、cid、pid、uid 和 result 组成的，分别表示本条状态的提交 ID，所属比赛 ID，题目 ID，用户 ID 以及评测结果。\n\n简单起见，这里的 result 只有 AC、UNAC 和 WAIT 三种状态，分别表示通过、不通过和等待评测。\n\n同时小 M 提出一个比赛模块需要实现以下请求：\n\n1. `createContest cid t pid_1 pid_2 … pid_t`\n\n表示要创建一个比赛，cid 是一个正整数，是这场比赛的唯一标识。\n\n$t$ 表示这场比赛有 $t$（($1\\le t\\le1000$)）道题目，接下来 $t$ 个不同的整数，表示这场比赛的题目编号。\n\n2. `submission sid cid pid uid result`\n\n该条状态的 sid 要么之前没出现过，要么以前出现过，但是被 rejudge 了。\n\nresult 为 AC 或者 UNAC。\n\n3. `getRank cid uid`\n\n在一场比赛中，所有有提交的用户都应该算在排名内（包括被 rejudge 的提交），用户的排名按照通过的题目数从大到小排序，如果题目数相同，则按随机顺序排序。\n\n该指令需要统计用户 uid 在 cid 这场比赛中的通过目数，最高排名以及最低排名。\n\n值得注意的是，用户 uid 在 cid 这场比赛中同一道题目的多个通过记录只算一次。\n\n输出格式为：`uid solved highest lowest`。\n\n分别代表用户 ID，通过题目数量，最高排名以及最低排名，其中 $\\mathit{highest}\\le\\mathit{lowest}$。\n\n4. `rejudge sid`\n\n重测以 sid 标识的提交记录，即将该记录的 result 改成 WAIT。\n", "inputFormat": "第一行三个整数 $\\mathit{pcnt}$、$\\mathit{ucnt}$、$m$（$1\\le\\mathit{pcnt}\\le5000,1\\le\\mathit{ucnt}\\le5000,1\\le m\\le3\\times10^5$），分别表示 OJ 有 pcnt 道题目，ucnt 个用户以及 m 条请求。\n\npid 的范围是 $1000\\sim1000+\\mathit{pcnt}-1$，uid 的范围是 $1\\sim\\mathit{ucnt}$，cid 的范围为 $1\\sim50$，$1\\le\\mathit{sid}\\le m$。\n\n接下来有 $m$ 行，每行一个请求，请求为题述四种请求之一，请求需要按输入顺序执行。\n\n你需要注意以下几点：\n\n1. 对于 `createContest` 请求，保证 cid 不会与之前的 createContest 的 cid 重复。\n2. 对于 `submission` 请求，在此请求前，保证比赛 cid 已经创建，题目 pid 是该场比赛的题目之一。\n3. 对于 `getRank` 指令，在此请求前，保证比赛 cid 已经创建，用户 uid 至少在该比赛中有一个提交记录。\n4. 对于 `rejudge` 指令，在此请求前，保证存在以 sid 标识的提交。\n", "outputFormat": "对于每一个 `getRank` 请求，根据要求输出用户 ID，通过题目数量，最高排名以及最低排名，整数之间用一个空格隔开。\n", "hint": "对于 $20\\%$ 的数据，$1\\le\\mathit{pcnt},\\mathit{ucnt},m\\le100$；\n\n对于 $50\\%$ 的数据，$1\\le\\mathit{pcnt},\\mathit{ucnt}\\le2000,1\\le m\\le50000$；\n\n对于 $100\\%$ 的数据，$1\\le\\mathit{pcnt},\\mathit{ucnt}\\le5000,1\\le m\\le3\\times10^5,1\\le\\mathit{cid}\\le50$。\n", "locale": "zh-CN"}}}
{"pid": "P3893", "type": "P", "difficulty": 7, "samples": [["5\nabcdx\ncdabz\n", "4"], ["4\nabcd\ncdab\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "各省省选", "广东"], "title": "[GDOI2014] Beyond", "background": "", "description": "Jodie 慢慢地步入实验室，跟随在她身旁的灵体 Aiden 似乎有点不高兴，但还是形影不离地跟随着 Jodie。\n\n今天 Jodie 要进行的实验在一个很大很大的圆环上面，圆环上有 $L$ 个格子，每个格子上都显示着一个小写英文字母，Jodie 从任意格子开始当她离开一个格子的时候那个格子的字母就会改变，这个改变是随机的，没有人知道会变成什么。Jodie 在这个环上不回头顺时针地走，每进入一个格子就会在本子上写下这个格子当前显示的字母。由于 Jodie 不能回头而且不知道这个圆环上有多少个格子，她并不知道自己什么时候会走到重复的点，所以她让 Aiden 在她下一步走进重复格子的时候提醒一下。但可能他们闹了矛盾，Aiden 发了脾气，决定在 Jodie 走了 $K$（$K \\geq 0$）步重复的格子之后才告诉她。Jodie 进行了两次实验，记录了两次走的路径。第二次实验再进去之前，每个格子所显示的字母会被重设为第一次实验开始前的样子。Jodie 发现了 Aiden 的恶作剧，她只能把可能的最大的 $L$ 告诉实验人员。\n\n为了帮助你更好的理解题目，请仔细分析一下例子：\n\n假设 $L = 4$，$K = 1$\n\n第一次实验开始前每个格子显示的字母如下图：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6849.png) \n\nJodie 从显示字母为 `a` 的格子开始走，Aiden 在她走了 $K$ 步重复的格子之后告诉她停止，所以 Jodie 一共走了 $5$ 步，每走一步，格子的变化如下（箭头指着 Jodie 所在的格子）：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6850.png) \n\nJodie 的第二次实验从显示字母为 `c` 的格子开始走，每走一步格子的变化如下（箭头指着 Jodie 所在的格子）：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6851.png) \n\nJodie 两次实验记录的路径分别为：\n\n`abcdx`\n\n`cdabz`\n\n现在给出 Jodie 记录的两次路径的长度 $N$，以及 Jodie 所写的内容，但是并不知道 $K$ 是多少，希望你能帮忙求出一个最大的可能的 $L$。\n", "inputFormat": "第一行：包含一个整数 $N$。\n\n第二行：包含一个长度为 $N$ 的字符串，字符串中只包含小写字母。\n\n第三行：包含一个长度为 $N$ 的字符串，字符串中只包含小写字母。\n", "outputFormat": "输出答案只包含一个数字 $L$，表示圆环最大可能有的格子数。\n", "hint": "对于 $20\\%$ 的数据，$1 \\leq N \\leq 5,000$\n\n对于 $50\\%$ 的数据，$1 \\leq N \\leq 600,000$\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 2,000,000$\n", "locale": "zh-CN", "translations": {"en": {"title": "[GDOI2014] Beyond", "background": "", "description": "Jodie slowly walks into the laboratory. The spirit Aiden, who follows by her side, seems a bit upset, but still sticks closely to Jodie.\n\nToday’s experiment takes place on a very large circular ring with $L$ cells. Each cell displays a lowercase English letter. Jodie starts from any cell. Whenever she leaves a cell, the letter in that cell changes randomly; no one knows what it will become. Jodie walks clockwise around the ring without ever turning back. Each time she enters a cell, she writes down the letter currently displayed in that cell.\n\nSince Jodie cannot turn back and does not know how many cells the ring has, she does not know when she will reach a cell she has already visited. So she asks Aiden to remind her when her next step would enter a previously visited cell. However, after a quarrel, Aiden gets angry and decides to tell her only after Jodie has already stepped into $K$ repeated cells (with $K \\geq 0$). Jodie performs two experiments and records the two paths. Before the second experiment begins, the letter in each cell is reset to the state it had before the first experiment started. Jodie discovers Aiden’s prank, so she can only report the largest possible $L$ to the experimenters.\n\nTo help you better understand the problem, please analyze the example:\n\nSuppose $L = 4$, $K = 1$.\n\nBefore the first experiment starts, the letters displayed by each cell are as shown below:\n\n![](https://cdn.luogu.com.cn/upload/pic/6849.png)\n\nJodie starts walking from the cell showing the letter `a`. Aiden tells her to stop after she has stepped into $K$ repeated cells, so Jodie takes a total of $5$ steps. After each step, the cells change as follows (the arrow points to the cell where Jodie is):\n\n![](https://cdn.luogu.com.cn/upload/pic/6850.png)\n\nJodie’s second experiment starts from the cell showing the letter `c`. After each step, the cells change as follows (the arrow points to the cell where Jodie is):\n\n![](https://cdn.luogu.com.cn/upload/pic/6851.png)\n\nThe two paths recorded by Jodie are:\n\n`abcdx`\n\n`cdabz`\n\nNow you are given the length $N$ of each of Jodie’s two recorded paths, and the two strings she wrote down, but $K$ is unknown. Please find the maximum possible value of $L$.", "inputFormat": "The first line contains an integer $N$.\n\nThe second line contains a string of length $N$, consisting only of lowercase letters.\n\nThe third line contains a string of length $N$, consisting only of lowercase letters.", "outputFormat": "Output a single number $L$, the maximum possible number of cells on the ring.", "hint": "Constraints:\n\n- For $20\\%$ of the testdata, $1 \\leq N \\leq 5{,}000$.\n- For $50\\%$ of the testdata, $1 \\leq N \\leq 600{,}000$.\n- For $100\\%$ of the testdata, $1 \\leq N \\leq 2{,}000{,}000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[GDOI2014] Beyond", "background": "", "description": "Jodie 慢慢地步入实验室，跟随在她身旁的灵体 Aiden 似乎有点不高兴，但还是形影不离地跟随着 Jodie。\n\n今天 Jodie 要进行的实验在一个很大很大的圆环上面，圆环上有 $L$ 个格子，每个格子上都显示着一个小写英文字母，Jodie 从任意格子开始当她离开一个格子的时候那个格子的字母就会改变，这个改变是随机的，没有人知道会变成什么。Jodie 在这个环上不回头顺时针地走，每进入一个格子就会在本子上写下这个格子当前显示的字母。由于 Jodie 不能回头而且不知道这个圆环上有多少个格子，她并不知道自己什么时候会走到重复的点，所以她让 Aiden 在她下一步走进重复格子的时候提醒一下。但可能他们闹了矛盾，Aiden 发了脾气，决定在 Jodie 走了 $K$（$K \\geq 0$）步重复的格子之后才告诉她。Jodie 进行了两次实验，记录了两次走的路径。第二次实验再进去之前，每个格子所显示的字母会被重设为第一次实验开始前的样子。Jodie 发现了 Aiden 的恶作剧，她只能把可能的最大的 $L$ 告诉实验人员。\n\n为了帮助你更好的理解题目，请仔细分析一下例子：\n\n假设 $L = 4$，$K = 1$\n\n第一次实验开始前每个格子显示的字母如下图：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6849.png) \n\nJodie 从显示字母为 `a` 的格子开始走，Aiden 在她走了 $K$ 步重复的格子之后告诉她停止，所以 Jodie 一共走了 $5$ 步，每走一步，格子的变化如下（箭头指着 Jodie 所在的格子）：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6850.png) \n\nJodie 的第二次实验从显示字母为 `c` 的格子开始走，每走一步格子的变化如下（箭头指着 Jodie 所在的格子）：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6851.png) \n\nJodie 两次实验记录的路径分别为：\n\n`abcdx`\n\n`cdabz`\n\n现在给出 Jodie 记录的两次路径的长度 $N$，以及 Jodie 所写的内容，但是并不知道 $K$ 是多少，希望你能帮忙求出一个最大的可能的 $L$。\n", "inputFormat": "第一行：包含一个整数 $N$。\n\n第二行：包含一个长度为 $N$ 的字符串，字符串中只包含小写字母。\n\n第三行：包含一个长度为 $N$ 的字符串，字符串中只包含小写字母。\n", "outputFormat": "输出答案只包含一个数字 $L$，表示圆环最大可能有的格子数。\n", "hint": "对于 $20\\%$ 的数据，$1 \\leq N \\leq 5,000$\n\n对于 $50\\%$ 的数据，$1 \\leq N \\leq 600,000$\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 2,000,000$\n", "locale": "zh-CN"}}}
{"pid": "P3894", "type": "P", "difficulty": 6, "samples": [["5\n3\n0 1 1\n0 2 1\n3\n0 1 2\n2 0 1\n3\n0 1 1\n0 2 1\n2\n0 1 2\n3\n0 1 1\n0 2 1\n3\n0 2 2 1\n0 0 2 1\n2 2 4 1\n", "5\n6\n-1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "各省省选", "广东"], "title": "[GDOI2014] 传送", "background": "", "description": "有 $n$ 个国家，编号分别为 $0$ 到 $n-1$。第 $i$ 个国家包含 $m_i$ 个城市，编号分别为 $0$ 到 $m_{i}-1$，其中编号为 $0$ 的城市是该国家的首都。为了表示的方便，我们用 $(i,j)$ 来表示第 $i$ 个国家的第 $j$ 个城市。同一个国家的城市之间有通路，这些通路构成一棵树，首都则是这棵树的根。而不同国家的城市之间没有通路，只能通过传送门。每个国家只有处于叶子节点的城市具有传送门，传送门的目的地可以是编号相邻的国家的任意一个处于叶子节点的城市，每次传送需要花费 $1$ 个单位时间，并且每个传送门只能使用一次。如下图所示，如果出发地是 $(0,2)$，目的地是 $(2,1)$，则 $(0,2)\\rightarrow(1,1)\\rightarrow(1,0)\\rightarrow(1,2)\\rightarrow(2,1)$ 是一条可行路径，而 $(0,2)\\rightarrow(1,1)\\rightarrow(2,1)$ 则是非法的，因为 $(1,1)$ 的传送门在 $(0,2)\\rightarrow(1,1)$ 的时候被使用了一次，在 $(1,1)\\rightarrow(2,1)$ 的时候又被使用了一次。\n\n ![](https://cdn.luogu.com.cn/upload/pic/6852.png) \n\n给定出发地和目的地，问最少需要多少时间。", "inputFormat": "输入第一行有一个正整数 $n$。\n\n接下来有 $n$ 个模块，每块描述一个国家的情况。每个模块的第一行是一个正整数 $m_i$，表示编号为 $i$ 的国家包含的城市个数，接下来 $m_{i}-1$ 行，每行包含三个整数 $u,v,t$，表示从城市 $u$ 到城市 $v$ 有通路，需要花费的时间为 $t (1 \\leq t \\leq 10^{3})$。\n\n接下来一行有一个正整数 $q$，表示查询的个数。接下来 $q$ 行，每一行包含四个整数，$s_0,s_1,e_0,e_1$，其中，$(s_0,s_1)$ 为出发地，$(e_0,e_1)$ 为目的地。", "outputFormat": "输出有 $q$ 行，每行只包含一个整数。如果能从出发地到达目的地，输出最少时间，否则，输出 $-1$。", "hint": "对于 $40\\%$ 的数据，$n \\leq 10,\\sum m_i \\leq 10^{3},q \\leq 10$。\n\n对于 $60\\%$ 的数据，$n \\leq 10^{3},\\sum m_i \\leq 10^{6}$。\n\n对于 $100\\%$ 的数据，$n \\leq 3.5 \\times 10^{5},\\sum m_i \\leq 10^{6},1 \\leq t \\leq 10^{3},q \\leq 10^{5}$。", "locale": "zh-CN", "translations": {"en": {"title": "[GDOI2014] Teleportation", "background": "", "description": "There are $n$ countries, numbered from $0$ to $n-1$. The $i$-th country contains $m_i$ cities, numbered from $0$ to $m_{i}-1$, where the city numbered $0$ is the capital. For convenience, we use $(i,j)$ to denote the $j$-th city of the $i$-th country. The cities within the same country are connected by roads that form a tree, with the capital as the root. There are no roads between cities of different countries; you can only travel via teleportation portals. In each country, only cities that are leaf nodes have teleportation portals, and the destination can be any leaf city in a country with an adjacent index. Each teleport takes $1$ unit of time, and each teleportation portal can be used only once. As shown in the figure below, if the starting point is $(0,2)$ and the destination is $(2,1)$, then $(0,2)\\rightarrow(1,1)\\rightarrow(1,0)\\rightarrow(1,2)\\rightarrow(2,1)$ is a feasible path, while $(0,2)\\rightarrow(1,1)\\rightarrow(2,1)$ is invalid, because the portal of $(1,1)$ was used once in $(0,2)\\rightarrow(1,1)$ and again in $(1,1)\\rightarrow(2,1)$.\n\n ![](https://cdn.luogu.com.cn/upload/pic/6852.png) \n\nGiven the starting point and the destination, find the minimum time required.", "inputFormat": "The first line contains a positive integer $n$.\n\nThen there are $n$ blocks, each describing one country. The first line of each block is a positive integer $m_i$, indicating that the country with index $i$ contains $m_i$ cities. Then follow $m_{i}-1$ lines, each containing three integers $u, v, t$, meaning there is a road between city $u$ and city $v$, and the time cost is $t$ ($1 \\leq t \\leq 10^{3}$).\n\nThe next line contains a positive integer $q$, the number of queries. Each of the next $q$ lines contains four integers $s_0, s_1, e_0, e_1$, where $(s_0, s_1)$ is the starting point and $(e_0, e_1)$ is the destination.", "outputFormat": "Output $q$ lines, each containing a single integer. If the destination is reachable from the starting point, output the minimum time; otherwise, output $-1$.", "hint": "For $40\\%$ of the testdata, $n \\leq 10, \\sum m_i \\leq 10^{3}, q \\leq 10$.\n\nFor $60\\%$ of the testdata, $n \\leq 10^{3}, \\sum m_i \\leq 10^{6}$.\n\nFor $100\\%$ of the testdata, $n \\leq 3.5 \\times 10^{5}, \\sum m_i \\leq 10^{6}, 1 \\leq t \\leq 10^{3}, q \\leq 10^{5}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[GDOI2014] 传送", "background": "", "description": "有 $n$ 个国家，编号分别为 $0$ 到 $n-1$。第 $i$ 个国家包含 $m_i$ 个城市，编号分别为 $0$ 到 $m_{i}-1$，其中编号为 $0$ 的城市是该国家的首都。为了表示的方便，我们用 $(i,j)$ 来表示第 $i$ 个国家的第 $j$ 个城市。同一个国家的城市之间有通路，这些通路构成一棵树，首都则是这棵树的根。而不同国家的城市之间没有通路，只能通过传送门。每个国家只有处于叶子节点的城市具有传送门，传送门的目的地可以是编号相邻的国家的任意一个处于叶子节点的城市，每次传送需要花费 $1$ 个单位时间，并且每个传送门只能使用一次。如下图所示，如果出发地是 $(0,2)$，目的地是 $(2,1)$，则 $(0,2)\\rightarrow(1,1)\\rightarrow(1,0)\\rightarrow(1,2)\\rightarrow(2,1)$ 是一条可行路径，而 $(0,2)\\rightarrow(1,1)\\rightarrow(2,1)$ 则是非法的，因为 $(1,1)$ 的传送门在 $(0,2)\\rightarrow(1,1)$ 的时候被使用了一次，在 $(1,1)\\rightarrow(2,1)$ 的时候又被使用了一次。\n\n ![](https://cdn.luogu.com.cn/upload/pic/6852.png) \n\n给定出发地和目的地，问最少需要多少时间。", "inputFormat": "输入第一行有一个正整数 $n$。\n\n接下来有 $n$ 个模块，每块描述一个国家的情况。每个模块的第一行是一个正整数 $m_i$，表示编号为 $i$ 的国家包含的城市个数，接下来 $m_{i}-1$ 行，每行包含三个整数 $u,v,t$，表示从城市 $u$ 到城市 $v$ 有通路，需要花费的时间为 $t (1 \\leq t \\leq 10^{3})$。\n\n接下来一行有一个正整数 $q$，表示查询的个数。接下来 $q$ 行，每一行包含四个整数，$s_0,s_1,e_0,e_1$，其中，$(s_0,s_1)$ 为出发地，$(e_0,e_1)$ 为目的地。", "outputFormat": "输出有 $q$ 行，每行只包含一个整数。如果能从出发地到达目的地，输出最少时间，否则，输出 $-1$。", "hint": "对于 $40\\%$ 的数据，$n \\leq 10,\\sum m_i \\leq 10^{3},q \\leq 10$。\n\n对于 $60\\%$ 的数据，$n \\leq 10^{3},\\sum m_i \\leq 10^{6}$。\n\n对于 $100\\%$ 的数据，$n \\leq 3.5 \\times 10^{5},\\sum m_i \\leq 10^{6},1 \\leq t \\leq 10^{3},q \\leq 10^{5}$。", "locale": "zh-CN"}}}
{"pid": "P3895", "type": "P", "difficulty": 6, "samples": [["5 4 3 1\n1001\n1101\n1111\n1110\n0111", "2 3 4\n2 3 4\n3 4 5\n2 3 5"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["贪心", "湖南", "Special Judge", "排序"], "title": "[湖南集训] Hungry Rabbit", "background": "", "description": "可怕的洪水在夏天不期而至，兔子王国遭遇了前所未有的饥荒，它们不得不去外面的森林里寻找食物。\n\n为了简化起见，我们假设兔子王国中有 $n$ 只兔子，编号为 $1$ 到 $n$。在救济粮到来之前的 $m$ 天中，每天恰好有 $k$ 只兔子需要去森林里寻找粮食。森林里居住着可怕的大灰狼，所幸兔子已经摸清了大灰狼捕食习惯，即狼们在每一天只会捕食特定编号的兔子。为了安全起见，兔子们需要保证每次出去觅食的 $k$ 只兔子都不会被狼捕食。\n\n由于每天出去捕食的兔子都不尽相同，它们为每一天定义了一个生疏度 $p_i$ ，即第 $i$ 天出来寻找食物，但是第 $i−1$ 天却没有出来觅食的兔子个数。规定第 $1$ 天的生疏度为 $0$。\n\n现在兔子们希望在保证安全的前提下，每天的生疏度不能超过 $l$，请为兔子们构造一个合法的方案。", "inputFormat": "\n第一行包括四个整数 $n, m, k, l$。\n\n接下来 $n$ 行，每行一个长度为 $m$ 的 $01$ 串。其中第 $i$ 行第 $j$ 个字符若为 $0$，则表示狼在第 $j$ 天会捕食编号为 $i$ 的兔子，为 $1$ 则表示不捕食。", "outputFormat": "共 $m$ 行，每行 $k$ 个 $1$ 到 $n$ 之间互不相同的整数，代表这一天出去寻找食物的兔子编号。\n\n如果没有合法方案，则输出一行 `−1` 即可。", "hint": "#### 样例 1 解释\n\n对于样例，在这 $4$ 天中，出去觅食的兔子集合分别为 $\\{2, 3, 4\\}; \\{2, 3, 4\\}; \\{3, 4, 5\\}; \\{2, 3, 5\\}$。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $20\\%$ 的测试数据，保证 $1\\leq n,m\\leq 10$；\n- 对于 $100\\%$ 的测试数据，保证 $1\\leq n,m\\leq 800,$，$1\\leq k\\leq n$，$1\\leq l\\leq k$。", "locale": "zh-CN", "translations": {"en": {"title": "[Hunan Training Camp] Hungry Rabbit", "background": "", "description": "A terrible flood struck unexpectedly in the summer, and the Rabbit Kingdom suffered an unprecedented famine. They have to go to the forest to look for food.\n\nFor simplicity, suppose there are $n$ rabbits in the kingdom, numbered $1$ to $n$. During the $m$ days before relief arrives, exactly $k$ rabbits must go to the forest each day to gather food. Ferocious wolves live in the forest, but fortunately the rabbits have figured out the wolves’ hunting pattern: on each day, the wolves only hunt rabbits with certain indices. For safety, the $k$ rabbits sent out each day must all be ones that will not be hunted that day.\n\nBecause the rabbits going out differ from day to day, they define for each day a newcomer count $p_i$: the number of rabbits that go out on day $i$ but did not go out on day $i - 1$. By convention, $p_1 = 0$.\n\nNow the rabbits want, under the safety requirement, that the newcomer count each day does not exceed $l$. Please construct a valid plan.", "inputFormat": "The first line contains four integers $n, m, k, l$.\n\nThe next $n$ lines each contain a binary string of length $m$. In the $i$-th line, if the $j$-th character is $0$, then on day $j$ rabbit $i$ will be hunted; if it is $1$, then rabbit $i$ will not be hunted on that day.", "outputFormat": "Output $m$ lines. Each line should contain $k$ distinct integers between $1$ and $n$, representing the indices of the rabbits that go out to gather food on that day.\n\nIf there is no valid plan, output a single line with -1.", "hint": "Sample 1 Explanation\n\nFor the sample, over the $4$ days, the sets of rabbits going out are respectively {2, 3, 4}; {2, 3, 4}; {3, 4, 5}; {2, 3, 5}.\n\nConstraints\n\n- For $20\\%$ of the testdata, $1 \\le n, m \\le 10$.\n- For $100\\%$ of the testdata, $1 \\le n, m \\le 800$, $1 \\le k \\le n$, $1 \\le l \\le k$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[湖南集训] Hungry Rabbit", "background": "", "description": "可怕的洪水在夏天不期而至，兔子王国遭遇了前所未有的饥荒，它们不得不去外面的森林里寻找食物。\n\n为了简化起见，我们假设兔子王国中有 $n$ 只兔子，编号为 $1$ 到 $n$。在救济粮到来之前的 $m$ 天中，每天恰好有 $k$ 只兔子需要去森林里寻找粮食。森林里居住着可怕的大灰狼，所幸兔子已经摸清了大灰狼捕食习惯，即狼们在每一天只会捕食特定编号的兔子。为了安全起见，兔子们需要保证每次出去觅食的 $k$ 只兔子都不会被狼捕食。\n\n由于每天出去捕食的兔子都不尽相同，它们为每一天定义了一个生疏度 $p_i$ ，即第 $i$ 天出来寻找食物，但是第 $i−1$ 天却没有出来觅食的兔子个数。规定第 $1$ 天的生疏度为 $0$。\n\n现在兔子们希望在保证安全的前提下，每天的生疏度不能超过 $l$，请为兔子们构造一个合法的方案。", "inputFormat": "\n第一行包括四个整数 $n, m, k, l$。\n\n接下来 $n$ 行，每行一个长度为 $m$ 的 $01$ 串。其中第 $i$ 行第 $j$ 个字符若为 $0$，则表示狼在第 $j$ 天会捕食编号为 $i$ 的兔子，为 $1$ 则表示不捕食。", "outputFormat": "共 $m$ 行，每行 $k$ 个 $1$ 到 $n$ 之间互不相同的整数，代表这一天出去寻找食物的兔子编号。\n\n如果没有合法方案，则输出一行 `−1` 即可。", "hint": "#### 样例 1 解释\n\n对于样例，在这 $4$ 天中，出去觅食的兔子集合分别为 $\\{2, 3, 4\\}; \\{2, 3, 4\\}; \\{3, 4, 5\\}; \\{2, 3, 5\\}$。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $20\\%$ 的测试数据，保证 $1\\leq n,m\\leq 10$；\n- 对于 $100\\%$ 的测试数据，保证 $1\\leq n,m\\leq 800,$，$1\\leq k\\leq n$，$1\\leq l\\leq k$。", "locale": "zh-CN"}}}
{"pid": "P3896", "type": "P", "difficulty": 6, "samples": [["4 10000\n", "8276"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["湖南"], "title": "[湖南集训] Clever Rabbit", "background": "", "description": "聪明的兔子定义了三个函数:\n\n- $g(x)$ 表示将 $x$ 十进制表示中各位数字从高位到低位降序排列组成的数字。\n\n- $l(x)$ 表示将 $x$ 十进制表示中各位数字从高位到低位升序排列组成的数字。\n\n- $f(x)=g(x)-l(x)$。\n\n如果一个数 $x$ 与 $f(x)$ 相等，兔子们称它为幸运数。现在兔子们希望计算在所有的 $n$ 位数字中，所有幸运数的平方的和。结果对 $p$ 取模后输出，注意这里数字可以包含前导 $0$。", "inputFormat": "一行两个整数 $n,p$。", "outputFormat": "一行一个整数，表示所求的结果。", "hint": "#### 数据规模与约定\n- 对于 $20\\%$ 的测试数据，保证 $1\\leq n\\leq 10$。\n- 对于 $100\\%$ 的测试数据，保证 $1\\leq n\\leq 30$，$1\\leq p\\leq 2\\times 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[Hunan Training Camp] Clever Rabbit", "background": "", "description": "The clever rabbit defines three functions:\n\n- $g(x)$ denotes the number formed by arranging the digits of the decimal representation of $x$ in descending order.\n- $l(x)$ denotes the number formed by arranging the digits of the decimal representation of $x$ in ascending order.\n- $f(x)=g(x)-l(x)$.\n\nIf a number $x$ equals $f(x)$, the rabbits call it a lucky number. Now the rabbits want to compute the sum of squares of all lucky numbers among all $n$-digit numbers. Output the result modulo $p$. Note that numbers may contain leading $0$s.", "inputFormat": "One line with two integers $n,p$.", "outputFormat": "One line with one integer, the required result.", "hint": "#### Constraints\n- For $20\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 10$.\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 30$, $1 \\leq p \\leq 2 \\times 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[湖南集训] Clever Rabbit", "background": "", "description": "聪明的兔子定义了三个函数:\n\n- $g(x)$ 表示将 $x$ 十进制表示中各位数字从高位到低位降序排列组成的数字。\n\n- $l(x)$ 表示将 $x$ 十进制表示中各位数字从高位到低位升序排列组成的数字。\n\n- $f(x)=g(x)-l(x)$。\n\n如果一个数 $x$ 与 $f(x)$ 相等，兔子们称它为幸运数。现在兔子们希望计算在所有的 $n$ 位数字中，所有幸运数的平方的和。结果对 $p$ 取模后输出，注意这里数字可以包含前导 $0$。", "inputFormat": "一行两个整数 $n,p$。", "outputFormat": "一行一个整数，表示所求的结果。", "hint": "#### 数据规模与约定\n- 对于 $20\\%$ 的测试数据，保证 $1\\leq n\\leq 10$。\n- 对于 $100\\%$ 的测试数据，保证 $1\\leq n\\leq 30$，$1\\leq p\\leq 2\\times 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3897", "type": "P", "difficulty": 6, "samples": [["6 3\n0 6\n-7 -4\n-3 -2\n7 -5\n-2 3\n8 -3", "4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["湖南", "枚举", "排序"], "title": "[湖南集训] Crazy Rabbit", "background": "", "description": "兔子们决定在自己的城堡里安排一些士兵进行防守。\n\n给出 $n$ 个点的坐标，和城堡里一个圆心在原点的圆形的障碍，兔子们希望从中选出 $k$ 个兔子，使得它们两两**所在的直线**都不与圆相交。\n\n兔子们希望知道最多能选出多少兔子。", "inputFormat": "第一行两个整数 $n$ 和 $r$，表示兔子的个数和圆的半径。\n\n接下来 $n$ 行，每行两个整数 $x_i$ 和 $y_i$，表示第 $i$ 只兔子的坐标\n\n保证每只兔子都严格在障碍外部，且两两所在的直线不与圆相切。", "outputFormat": "输出一行一个整数, 表示最多能选出多少兔子", "hint": "#### 样例 1 解释\n\n ![](https://cdn.luogu.com.cn/upload/pic/6853.png) \n\n选择第 $1, 2, 6, 4$ 只兔子即可。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $10\\%$ 的数据，保证 $1\\leq n\\leq 20$。\n- 对于 $30\\%$ 的数据，保证 $1\\leq n\\leq 100$。\n- 对于 $100\\%$ 的数据，保证 $1\\leq n\\leq 2000$，$1\\leq r,x_i,y_i \\leq 5000$。", "locale": "zh-CN", "translations": {"en": {"title": "[Hunan Training Camp] Crazy Rabbit", "background": "", "description": "The rabbits decide to station some soldiers in their castle.\n\nGiven the coordinates of $n$ points and a circular obstacle in the castle whose center is at the origin, the rabbits want to choose $k$ rabbits such that, for every pair of chosen rabbits, the line determined by them does not intersect the circle.\n\nThe rabbits want to know the maximum number of rabbits they can choose.", "inputFormat": "The first line contains two integers $n$ and $r$, denoting the number of rabbits and the radius of the circle.\n\nThen $n$ lines follow. Each line contains two integers $x_i$ and $y_i$, representing the coordinates of the $i$-th rabbit.\n\nIt is guaranteed that every rabbit lies strictly outside the obstacle, and that for any two rabbits, the line through them is not tangent to the circle.", "outputFormat": "Output a single integer on one line, representing the maximum number of rabbits that can be chosen.", "hint": "#### Sample 1 Explanation\n\n![](https://cdn.luogu.com.cn/upload/pic/6853.png)\n\nChoosing rabbits $1, 2, 6, 4$ works.\n\n---\n\n#### Constraints\n\n- For $10\\%$ of the testdata, $1\\leq n\\leq 20$.\n- For $30\\%$ of the testdata, $1\\leq n\\leq 100$.\n- For $100\\%$ of the testdata, $1\\leq n\\leq 2000$ and $1\\leq r,x_i,y_i \\leq 5000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[湖南集训] Crazy Rabbit", "background": "", "description": "兔子们决定在自己的城堡里安排一些士兵进行防守。\n\n给出 $n$ 个点的坐标，和城堡里一个圆心在原点的圆形的障碍，兔子们希望从中选出 $k$ 个兔子，使得它们两两**所在的直线**都不与圆相交。\n\n兔子们希望知道最多能选出多少兔子。", "inputFormat": "第一行两个整数 $n$ 和 $r$，表示兔子的个数和圆的半径。\n\n接下来 $n$ 行，每行两个整数 $x_i$ 和 $y_i$，表示第 $i$ 只兔子的坐标\n\n保证每只兔子都严格在障碍外部，且两两所在的直线不与圆相切。", "outputFormat": "输出一行一个整数, 表示最多能选出多少兔子", "hint": "#### 样例 1 解释\n\n ![](https://cdn.luogu.com.cn/upload/pic/6853.png) \n\n选择第 $1, 2, 6, 4$ 只兔子即可。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $10\\%$ 的数据，保证 $1\\leq n\\leq 20$。\n- 对于 $30\\%$ 的数据，保证 $1\\leq n\\leq 100$。\n- 对于 $100\\%$ 的数据，保证 $1\\leq n\\leq 2000$，$1\\leq r,x_i,y_i \\leq 5000$。", "locale": "zh-CN"}}}
{"pid": "P3898", "type": "P", "difficulty": 5, "samples": [["3 0.5", "2.000000"], ["123456 0.5", "98063.674346"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["湖南", "Special Judge"], "title": "[湖南集训] 大新闻", "background": "", "description": "有一个在 [0,n) 内等概率随机选择的整数，记其为 x。我们需要在 [0,n)内找到某一个整数 y，使得 x ⊕ y 达到最大值。这里 ⊕ 代表异或。\n\n问题在于，有可能对 x 进行了加密。情报显示，没有被加密的概率为 p。我们决定采取这样的策略：如果 x 没有被加密，那么我们选出使得 x ⊕ y 最大的 y；否则，我们在 [0,n) 内等概率随机选择一个整数作为 y。\n\n请求出 x ⊕ y 的期望值。\n", "inputFormat": "输入文件仅包含一行，其中有一个正整数 n 和一个实数 p，含义如问题描述中所述。 p 至多精确到小数点后六位。\n", "outputFormat": "输出一行，代表 x ⊕ y 的期望值。只有当你的输出与标准输出的相对误差不超过 $10^{-5}$ 时，你的输出才会被判为正确。建议保留至少六位小数。\n", "hint": "考虑样例一。如果 x 没有被加密，那么可能的 x 与对应的 y 的取值如下：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6855.png) \n\n此时的期望值为 8/3。\n\n如果大新闻被加密了，那么可能的 x 和 y 的取值如下：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6856.png) \n\n此时的期望值为 12/9 = 4/3。\n\n所以总的期望值为 2。\n\n\n所有测试点的数据规模如下：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6857.png) \n\n对于全部测试数据，$1 \\le n \\le 10^{18}$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Hunan Training Camp] Big News", "background": "", "description": "Let x be an integer chosen uniformly at random from [0, n). We need to find an integer y in [0, n) such that x ⊕ y is maximized. Here ⊕ denotes bitwise XOR.\n\nThe problem is that x may have been encrypted. Intelligence indicates that the probability that it was not encrypted is p. We adopt the following strategy: if x is not encrypted, we choose a y that maximizes x ⊕ y; otherwise, we choose y uniformly at random from [0, n).\n\nCompute the expected value of x ⊕ y.", "inputFormat": "The input consists of a single line containing a positive integer n and a real number p, as described above. The value p is given with up to six digits after the decimal point.", "outputFormat": "Output a single line containing the expected value of x ⊕ y. Your answer will be accepted if its relative error does not exceed $10^{-5}$. It is recommended to keep at least six decimal places.", "hint": "Consider Sample 1. If x is not encrypted, the possible values of x and the corresponding y are as follows:\n\n ![](https://cdn.luogu.com.cn/upload/pic/6855.png) \n\nThe expected value in this case is 8/3.\n\nIf x is encrypted, the possible values of x and y are as follows:\n\n ![](https://cdn.luogu.com.cn/upload/pic/6856.png) \n\nThe expected value in this case is 12/9 = 4/3.\n\nTherefore, the overall expected value is 2.\n\nThe data scale for all test points is as follows:\n\n ![](https://cdn.luogu.com.cn/upload/pic/6857.png) \n\nConstraints: For all testdata, $1 \\le n \\le 10^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[湖南集训] 大新闻", "background": "", "description": "有一个在 [0,n) 内等概率随机选择的整数，记其为 x。我们需要在 [0,n)内找到某一个整数 y，使得 x ⊕ y 达到最大值。这里 ⊕ 代表异或。\n\n问题在于，有可能对 x 进行了加密。情报显示，没有被加密的概率为 p。我们决定采取这样的策略：如果 x 没有被加密，那么我们选出使得 x ⊕ y 最大的 y；否则，我们在 [0,n) 内等概率随机选择一个整数作为 y。\n\n请求出 x ⊕ y 的期望值。\n", "inputFormat": "输入文件仅包含一行，其中有一个正整数 n 和一个实数 p，含义如问题描述中所述。 p 至多精确到小数点后六位。\n", "outputFormat": "输出一行，代表 x ⊕ y 的期望值。只有当你的输出与标准输出的相对误差不超过 $10^{-5}$ 时，你的输出才会被判为正确。建议保留至少六位小数。\n", "hint": "考虑样例一。如果 x 没有被加密，那么可能的 x 与对应的 y 的取值如下：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6855.png) \n\n此时的期望值为 8/3。\n\n如果大新闻被加密了，那么可能的 x 和 y 的取值如下：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6856.png) \n\n此时的期望值为 12/9 = 4/3。\n\n所以总的期望值为 2。\n\n\n所有测试点的数据规模如下：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6857.png) \n\n对于全部测试数据，$1 \\le n \\le 10^{18}$。\n", "locale": "zh-CN"}}}
{"pid": "P3899", "type": "P", "difficulty": 5, "samples": [["5 3\n1 2\n1 3\n2 4\n4 5\n2 2\n4 1\n2 3", "3\n1\n3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "树状数组", "湖南", "深度优先搜索 DFS", "树链剖分", "可持久化线段树"], "title": "[湖南集训] 更为厉害", "background": "", "description": "设 $\\text T$ 为一棵有根树，我们做如下的定义：\n\n- 设 $a$ 和 $b$ 为 $\\text T$ 中的两个不同节点。如果 $a$ 是 $b$ 的祖先，那么称“$a$ 比 $b$ 更为厉害”。\n- 设 $a$ 和 $b$ 为 $\\text T$ 中的两个不同节点。如果 $a$ 与 $b$ 在树上的距离不超过某个给定常数 $x$，那么称“ $a$ 与 $b$ 彼此彼此”。\n\n给定一棵 $n$ 个节点的有根树 $\\text T$，节点的编号为 $1$ 到 $n$，根节点为 $1$ 号节点。\n你需要回答 $q$ 个询问，询问给定两个整数 $p$ 和 $k$，问有多少个有序三元组 $(a,b,c)$ 满足：\n\n1. $a,b,c$ 为 $\\text T$ 中三个不同的点，且 $a$ 为 $p$ 号节点；\n2. $a$ 和 $b$ 都比 $c$ 更为厉害；\n3. $a$ 和 $b$ 彼此彼此。这里彼此彼此中的常数为给定的 $k$。\n", "inputFormat": "输入文件的第一行含有两个正整数 $n$ 和 $q$，分别代表有根树的点数与询问的个数。\n\n接下来 $n - 1$ 行，每行描述一条树上的边。每行含有两个整数 $u$ 和 $v$，代表在节点 $u$ 和 $v$ 之间有一条边。\n\n接下来 $q$ 行，每行描述一个操作。第 $i$ 行含有两个整数，分别表示第 $i$ 个询问的 $p$ 和 $k$。\n", "outputFormat": "输出 $q$ 行，每行对应一个询问，代表询问的答案。\n", "hint": "样例中的树如下图所示：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6858.png) \n\n对于第一个和第三个询问，合法的三元组有 $(2,1,4)$、 $(2,1,5)$ 和 $(2,4,5)$。\n\n对于第二个询问，合法的三元组只有 $(4,2,5)$。\n\n\n所有测试点的数据规模如下（注意，洛谷并不按照以下方式评测）：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6859.png) \n\n对于全部测试数据的所有询问，$1\\le p,k \\le n$。\n\n- 2023.9.15 添加一组 hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "[Hunan Training Camp] Even More Formidable", "background": "", "description": "Let $\\text T$ be a rooted tree. We make the following definitions:\n\n- Let $a$ and $b$ be two distinct nodes in $\\text T$. If $a$ is an ancestor of $b$, then we say \"$a$ is more formidable than $b$.\"\n- Let $a$ and $b$ be two distinct nodes in $\\text T$. If the distance between $a$ and $b$ in the tree is no more than a given constant $x$, then we say \"$a$ and $b$ are about the same.\"\n\nGiven a rooted tree $\\text T$ with $n$ nodes, numbered from $1$ to $n$, where the root is node $1$. You need to answer $q$ queries. In each query, two integers $p$ and $k$ are given. Determine how many ordered triples $(a, b, c)$ satisfy:\n\n1. $a, b, c$ are three distinct nodes in $\\text T$, and $a$ is node $p$.\n2. $a$ and $b$ are both more formidable than $c$.\n3. $a$ and $b$ are about the same, where the constant in “about the same” is the given $k$.", "inputFormat": "The first line contains two positive integers $n$ and $q$, representing the number of nodes in the rooted tree and the number of queries, respectively.\n\nThe next $n - 1$ lines each describe an edge of the tree. Each line contains two integers $u$ and $v$, indicating that there is an edge between nodes $u$ and $v$.\n\nThe next $q$ lines each describe an operation. The $i$-th line contains two integers, representing $p$ and $k$ for the $i$-th query.", "outputFormat": "Output $q$ lines. Each line corresponds to a query and contains the answer to that query.", "hint": "The tree in the sample is shown below:\n\n ![](https://cdn.luogu.com.cn/upload/pic/6858.png) \n\nFor the first and third queries, the valid triples are $(2,1,4)$, $(2,1,5)$, and $(2,4,5)$.\n\nFor the second query, the only valid triple is $(4,2,5)$.\n\nThe constraints for all test points are as follows (note that Luogu does not evaluate according to the following):\n\n ![](https://cdn.luogu.com.cn/upload/pic/6859.png) \n\nFor all queries in the full testdata, $1 \\le p, k \\le n$.\n\n- On 2023.9.15, a set of hack testdata was added.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[湖南集训] 更为厉害", "background": "", "description": "设 $\\text T$ 为一棵有根树，我们做如下的定义：\n\n- 设 $a$ 和 $b$ 为 $\\text T$ 中的两个不同节点。如果 $a$ 是 $b$ 的祖先，那么称“$a$ 比 $b$ 更为厉害”。\n- 设 $a$ 和 $b$ 为 $\\text T$ 中的两个不同节点。如果 $a$ 与 $b$ 在树上的距离不超过某个给定常数 $x$，那么称“ $a$ 与 $b$ 彼此彼此”。\n\n给定一棵 $n$ 个节点的有根树 $\\text T$，节点的编号为 $1$ 到 $n$，根节点为 $1$ 号节点。\n你需要回答 $q$ 个询问，询问给定两个整数 $p$ 和 $k$，问有多少个有序三元组 $(a,b,c)$ 满足：\n\n1. $a,b,c$ 为 $\\text T$ 中三个不同的点，且 $a$ 为 $p$ 号节点；\n2. $a$ 和 $b$ 都比 $c$ 更为厉害；\n3. $a$ 和 $b$ 彼此彼此。这里彼此彼此中的常数为给定的 $k$。\n", "inputFormat": "输入文件的第一行含有两个正整数 $n$ 和 $q$，分别代表有根树的点数与询问的个数。\n\n接下来 $n - 1$ 行，每行描述一条树上的边。每行含有两个整数 $u$ 和 $v$，代表在节点 $u$ 和 $v$ 之间有一条边。\n\n接下来 $q$ 行，每行描述一个操作。第 $i$ 行含有两个整数，分别表示第 $i$ 个询问的 $p$ 和 $k$。\n", "outputFormat": "输出 $q$ 行，每行对应一个询问，代表询问的答案。\n", "hint": "样例中的树如下图所示：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6858.png) \n\n对于第一个和第三个询问，合法的三元组有 $(2,1,4)$、 $(2,1,5)$ 和 $(2,4,5)$。\n\n对于第二个询问，合法的三元组只有 $(4,2,5)$。\n\n\n所有测试点的数据规模如下（注意，洛谷并不按照以下方式评测）：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6859.png) \n\n对于全部测试数据的所有询问，$1\\le p,k \\le n$。\n\n- 2023.9.15 添加一组 hack 数据。", "locale": "zh-CN"}}}
{"pid": "P3900", "type": "P", "difficulty": 7, "samples": [["3\nabc\nabacde\necab", "7"], ["1\nha", "Infinity"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["湖南", "后缀数组 SA"], "title": "[湖南集训] 图森", "background": "", "description": "有一个字符串集合 $S$，此处集合的概念与数学中的集合不同，其中可以含有重复的元素。初始时 $S$ 包含 $n$ 个字符串 $s_1, s_2, \\cdots, s_n$。有下面两种操作：\n\n- 向 $S$ 中加入一个已经存在于 $S$ 中的字符串。\n- 从 $S$ 中选出两个字符串，将这两个字符串拼接得到的字符串加入集合 $S$。\n\n现在想要知道，进行任意多次操作之后，在 $S$ 中的所有字符串中，最长的回文子串可以有多长？如果发现长度可以是无穷大，这时你需要输出 $\\text{Infinity}$。", "inputFormat": "第一行含有一个整数 $n$，代表初始时集合的大小。\n\n接下来的 $n$ 行，每行含有一个字符串。第 $i$ 行的字符串为 $s_i$。保证字符串中只含有小写英文字母。", "outputFormat": "如果最长的回文子串的长度不为无穷大，则输出一个整数，代表其长度；否则输出 $\\text{Infinity}$。", "hint": "#### 样例解释\n\n第一个样例中，将 $\\text{ecab}$ 与 $\\text{abacde}$ 拼接，得到 $\\text{e}\\underline{\\text{cababac}}\\text{de}$，其中下划线的部分就是最长的回文子串，长度为 $7$。可以证明不存在更长的回文子串。\n\n第二个样例中，可以将任意多个 $\\text{ha}$ 拼接起来，从而得到 $\\underline{\\text{h}}\\text{a},$ $\\underline{\\text{hah}}\\text{a},$ $\\underline{\\text{hahah}}\\text{a}$ 等任意奇数长度的回文子串。因此答案为无穷大，输出 $\\text{Infinity}$。\n\n#### 数据规模与约定\n![OvO](https://cdn.luogu.com.cn/upload/pic/55026.png)", "locale": "zh-CN", "translations": {"en": {"title": "[Hunan Training Camp] Tusen", "background": "", "description": "There is a collection $S$ of strings; the concept of a collection here differs from the mathematical set in that duplicate elements are allowed (i.e., it is a multiset). Initially, $S$ contains $n$ strings $s_1, s_2, \\cdots, s_n$. There are two operations:\n\n- Add to $S$ a string that already exists in $S$.\n- Select two strings from $S$, concatenate them, and add the resulting string to $S$.\n\nAfter performing any number of operations, among all strings in $S$, what is the maximum possible length of a palindromic substring? If the length can be infinite, output $\\text{Infinity}$.", "inputFormat": "The first line contains an integer $n$, the initial size of the collection.\n\nEach of the next $n$ lines contains a string. The string on the $i$-th line is $s_i$. Each string contains only lowercase English letters.", "outputFormat": "If the maximum length of a palindromic substring is not infinite, output an integer representing its length; otherwise output $\\text{Infinity}$.", "hint": "#### Sample explanation\n\nIn the first sample, concatenate $\\text{ecab}$ and $\\text{abacde}$ to get $\\text{e}\\underline{\\text{cababac}}\\text{de}$, where the underlined part is the longest palindromic substring of length $7$. It can be proven that no longer palindromic substring exists.\n\nIn the second sample, you can concatenate arbitrarily many copies of $\\text{ha}$ to obtain $\\underline{\\text{h}}\\text{a},$ $\\underline{\\text{hah}}\\text{a},$ $\\underline{\\text{hahah}}\\text{a}$ and so on, yielding palindromic substrings of any odd length. Therefore the answer is infinite, so output $\\text{Infinity}$.\n\n#### Constraints\n![OvO](https://cdn.luogu.com.cn/upload/pic/55026.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[湖南集训] 图森", "background": "", "description": "有一个字符串集合 $S$，此处集合的概念与数学中的集合不同，其中可以含有重复的元素。初始时 $S$ 包含 $n$ 个字符串 $s_1, s_2, \\cdots, s_n$。有下面两种操作：\n\n- 向 $S$ 中加入一个已经存在于 $S$ 中的字符串。\n- 从 $S$ 中选出两个字符串，将这两个字符串拼接得到的字符串加入集合 $S$。\n\n现在想要知道，进行任意多次操作之后，在 $S$ 中的所有字符串中，最长的回文子串可以有多长？如果发现长度可以是无穷大，这时你需要输出 $\\text{Infinity}$。", "inputFormat": "第一行含有一个整数 $n$，代表初始时集合的大小。\n\n接下来的 $n$ 行，每行含有一个字符串。第 $i$ 行的字符串为 $s_i$。保证字符串中只含有小写英文字母。", "outputFormat": "如果最长的回文子串的长度不为无穷大，则输出一个整数，代表其长度；否则输出 $\\text{Infinity}$。", "hint": "#### 样例解释\n\n第一个样例中，将 $\\text{ecab}$ 与 $\\text{abacde}$ 拼接，得到 $\\text{e}\\underline{\\text{cababac}}\\text{de}$，其中下划线的部分就是最长的回文子串，长度为 $7$。可以证明不存在更长的回文子串。\n\n第二个样例中，可以将任意多个 $\\text{ha}$ 拼接起来，从而得到 $\\underline{\\text{h}}\\text{a},$ $\\underline{\\text{hah}}\\text{a},$ $\\underline{\\text{hahah}}\\text{a}$ 等任意奇数长度的回文子串。因此答案为无穷大，输出 $\\text{Infinity}$。\n\n#### 数据规模与约定\n![OvO](https://cdn.luogu.com.cn/upload/pic/55026.png)", "locale": "zh-CN"}}}
{"pid": "P3901", "type": "P", "difficulty": 4, "samples": [["4 2\n1 2 3 2\n1 3\n2 4", "Yes\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "莫队", "线段树", "排序", "可持久化线段树", "进制", "ST 表"], "title": "数列找不同", "background": null, "description": "现有数列 $A_1,A_2,\\ldots,A_N$，$Q$ 个询问 $(L_i,R_i)$，询问 $A_{L_i} ,A_{L_i+1},\\ldots,A_{R_i}$ 是否互不相同。", "inputFormat": "第一行，两个整数 $N,Q$。  \n第二行，$N$ 个整数 $A_1, A_2, \\ldots , A_N$。  \n接下来 $Q$ 行，每行两个整数 $L_i,R_i$。", "outputFormat": "对每个询问输出一行，`Yes` 或 `No`。", "hint": "对于 $50\\%$ 的数据，$N,Q  \\le 10^3$。  \n对于 $100\\%$ 的数据，$1 \\le N,Q \\le 10^5$，$1 \\le A_i \\le N$，$1 \\le L_i \\le R_i \\le N$。", "locale": "zh-CN", "translations": {"en": {"title": "Distinctness in a Sequence", "background": "", "description": "Given a sequence $A_1, A_2, \\ldots, A_N$ and $Q$ queries $(L_i, R_i)$, determine whether $A_{L_i}, A_{L_i+1}, \\ldots, A_{R_i}$ are all different from each other.", "inputFormat": "The first line contains two integers $N, Q$.  \nThe second line contains $N$ integers $A_1, A_2, \\ldots, A_N$.  \nThen $Q$ lines follow, each containing two integers $L_i, R_i$.", "outputFormat": "For each query, output one line: `Yes` or `No`.", "hint": "For $50\\%$ of the testdata, $N, Q \\le 10^3$.  \nFor $100\\%$ of the testdata, $1 \\le N, Q \\le 10^5$, $1 \\le A_i \\le N$, $1 \\le L_i \\le R_i \\le N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数列找不同", "background": null, "description": "现有数列 $A_1,A_2,\\ldots,A_N$，$Q$ 个询问 $(L_i,R_i)$，询问 $A_{L_i} ,A_{L_i+1},\\ldots,A_{R_i}$ 是否互不相同。", "inputFormat": "第一行，两个整数 $N,Q$。  \n第二行，$N$ 个整数 $A_1, A_2, \\ldots , A_N$。  \n接下来 $Q$ 行，每行两个整数 $L_i,R_i$。", "outputFormat": "对每个询问输出一行，`Yes` 或 `No`。", "hint": "对于 $50\\%$ 的数据，$N,Q  \\le 10^3$。  \n对于 $100\\%$ 的数据，$1 \\le N,Q \\le 10^5$，$1 \\le A_i \\le N$，$1 \\le L_i \\le R_i \\le N$。", "locale": "zh-CN"}}}
{"pid": "P3902", "type": "P", "difficulty": 3, "samples": [["3\n1 3 2", "1"], ["8\n1 2 3 4 4 5 6 7", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "二分", "树状数组", "离散化", "线性 DP"], "title": "递增", "background": null, "description": "现有数 $A_1,A_2,\\cdots,A_n$，修改最少的数字为**实数**，使得数列严格单调递增。\n\n注：原题误表述为修改为整数，现已纠正为实数。本题数据确保按照修改为整数的做法也可以 AC。（只是不能过样例）", "inputFormat": "第一行，一个整数 $n$。\n\n第二行，$n$ 个整数 $A_1,A_2,\\cdots,A_n$。", "outputFormat": "一个整数，表示最少修改多少个数字。", "hint": "- 对于 $50\\%$ 的数据，$n \\le 10^3$。\n\n- 对于 $100\\%$ 的数据，$1 \\le n \\le 10^5 , 1 \\le A_i \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "Increasing", "background": "", "description": "Given numbers $A_1, A_2, \\cdots, A_n$, modify the fewest elements (to real values) so that the sequence becomes strictly increasing.\n\nNote: The original statement mistakenly said to modify to integers; it has now been corrected to real numbers. The testdata ensures that the integer approach would also AC (it just cannot pass the sample).", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains $n$ integers $A_1, A_2, \\cdots, A_n$.", "outputFormat": "Output one integer, the minimum number of elements to modify.", "hint": "- Constraints:\n  - For 50% of the testdata, $N \\le 10^3$.\n  - For 100% of the testdata, $1 \\le N \\le 10^5$, $1 \\le A_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "递增", "background": null, "description": "现有数 $A_1,A_2,\\cdots,A_n$，修改最少的数字为**实数**，使得数列严格单调递增。\n\n注：原题误表述为修改为整数，现已纠正为实数。本题数据确保按照修改为整数的做法也可以 AC。（只是不能过样例）", "inputFormat": "第一行，一个整数 $n$。\n\n第二行，$n$ 个整数 $A_1,A_2,\\cdots,A_n$。", "outputFormat": "一个整数，表示最少修改多少个数字。", "hint": "- 对于 $50\\%$ 的数据，$n \\le 10^3$。\n\n- 对于 $100\\%$ 的数据，$1 \\le n \\le 10^5 , 1 \\le A_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3903", "type": "P", "difficulty": 3, "samples": [["4\n5 3 2 4", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": [], "title": "导弹拦截III", "background": null, "description": "很多年以前，A 国发明了一种导弹系统用来拦截敌对势力发射的导弹。\n\n这个系统可以发射一颗导弹拦截由近到远、高度不增加的多个导弹。\n\n但是现在，科学家们发现这个防御系统还不够强大，所以他们发明了另外一套导弹系统。\n\n这个新系统可以发射一颗导弹由近到远的拦截更多的导弹。\n\n当这个系统启动，首先选择一颗敌人的导弹进行拦截，然后拦截一颗更远的高度更低的导弹进行拦截，然后拦截比第二颗更远的但高度更高的导弹……以此类推，拦截的第奇数颗导弹比前一颗导弹更远、更高，拦截的第偶数颗导弹比前一个更远、更低。\n\n现在，给你一个从近到远的导弹高度列表，计算新系统发射一颗导弹可以拦截的最多的导弹数目。", "inputFormat": "第一行是一个整数 $n$，表示敌人发射的导弹数目。接下来的一行有 $n$ 个整数，表示由近到远的。", "outputFormat": "仅一个整数，表示拦截的最多导弹的数量。", "hint": "$1\\leq n\\leq 10^3$，$1\\leq $ 导弹高度 $\\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "Missile Interception III", "background": "", "description": "Many years ago, Country A invented a missile system to intercept enemy missiles.\n\nThat system can, with a single interceptor missile, shoot down multiple enemy missiles whose heights are non-increasing from near to far.\n\nNow, scientists have found that this defense system is not strong enough, so they invented another missile system.\n\nThis new system can, with a single interceptor missile, intercept more missiles from near to far.\n\nWhen this system starts, it first selects one enemy missile to intercept; then it intercepts a farther missile with a lower height; then it intercepts a missile that is farther than the second one but has a higher height; and so on. In other words, among the intercepted missiles, every odd-numbered one (3rd, 5th, …) is farther and higher than the previous intercepted missile, and every even-numbered one (2nd, 4th, …) is farther and lower than the previous intercepted missile. All comparisons are strict.\n\nGiven a list of missile heights ordered from near to far, compute the maximum number of missiles that the new system can intercept with a single interceptor missile.", "inputFormat": "The first line contains an integer $n$, the number of enemy missiles.  \nThe second line contains $n$ integers, the heights of the missiles from near to far.", "outputFormat": "Output a single integer, the maximum number of missiles that can be intercepted.", "hint": "$1 \\leq n \\leq 10^3$.  \nFor each $i$, $1 \\leq h_i \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "导弹拦截III", "background": null, "description": "很多年以前，A 国发明了一种导弹系统用来拦截敌对势力发射的导弹。\n\n这个系统可以发射一颗导弹拦截由近到远、高度不增加的多个导弹。\n\n但是现在，科学家们发现这个防御系统还不够强大，所以他们发明了另外一套导弹系统。\n\n这个新系统可以发射一颗导弹由近到远的拦截更多的导弹。\n\n当这个系统启动，首先选择一颗敌人的导弹进行拦截，然后拦截一颗更远的高度更低的导弹进行拦截，然后拦截比第二颗更远的但高度更高的导弹……以此类推，拦截的第奇数颗导弹比前一颗导弹更远、更高，拦截的第偶数颗导弹比前一个更远、更低。\n\n现在，给你一个从近到远的导弹高度列表，计算新系统发射一颗导弹可以拦截的最多的导弹数目。", "inputFormat": "第一行是一个整数 $n$，表示敌人发射的导弹数目。接下来的一行有 $n$ 个整数，表示由近到远的。", "outputFormat": "仅一个整数，表示拦截的最多导弹的数量。", "hint": "$1\\leq n\\leq 10^3$，$1\\leq $ 导弹高度 $\\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3904", "type": "P", "difficulty": 4, "samples": [["4 2", "7"], ["6 7", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["高精度", "递推", "组合数学", "排列组合", "线性递推"], "title": "三只小猪", "background": "你听说过三只小猪的故事吗？这是一个经典的故事。很久很久以前，有三只小猪。第一只小猪用稻草建的房子，第二个小猪用木棍建的房子，第三个小猪则使用砖做为材料。一只大灰狼想吃掉它们并吹倒了稻草和木棍建的房子。但是砖盖的房子很结实，狼最终也没有破坏掉，最后小猪们战胜了大灰狼并把它尾巴烧掉了。", "description": "为了自己的安全，小猪们又建造了一个新砖房。但是现在问题出现了，怎样把三个小猪分配到两个房子里呢？第三只小猪是三只小猪中最聪明的一只，为了不浪费任何一个房子，它总共考虑了三种方案，如下图\n\n ![](https://cdn.luogu.com.cn/upload/pic/6862.png) \n\n“但是将来怎么办呢？”第三只小猪知道将来随着成员的增多，它们将会盖更多的房子。它想知道给定了房子和猪的数目后，房子的分配方案有多少，但这个问题对于它来说，很明显有点难了，你能帮小猪解决这个问题吗？", "inputFormat": "输入文件 piggy.in，仅有一行，包含两个整数 $n$ 和 $m$，分别表示小猪的数目和房间数（$1\\leq n, m \\leq 50$）。", "outputFormat": "输出文件 piggy.out，仅一个整数，表示将 $n$ 只小猪安置在 $m$ 个房间且没有房间空闲的方案数。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "The Three Little Pigs", "background": "Have you heard the story of the Three Little Pigs? It is a classic tale. Long, long ago, there were three little pigs. The first little pig built a house of straw, the second little pig built a house of sticks, and the third little pig used bricks as the material. A big bad wolf wanted to eat them and blew down the straw house and the stick house. But the brick house was very sturdy, and the wolf failed to destroy it. In the end, the little pigs defeated the wolf and burned its tail.", "description": "For their safety, the little pigs built another new brick house. But now a problem arises: how should the three little pigs be assigned to the two houses? The third little pig is the smartest of the three. To avoid wasting any house, it considered a total of three plans, as shown below.\n\n ![](https://cdn.luogu.com.cn/upload/pic/6862.png) \n\n\"But what about the future?\" The third little pig knows that as their group grows, they will build more houses. It wants to know, given the numbers of houses and pigs, how many allocation plans there are. However, this problem is clearly a bit hard for it. Can you help the little pig solve it?", "inputFormat": "The input contains a single line with two integers $n$ and $m$, denoting the number of pigs and the number of houses ($1 \\leq n, m \\leq 50$).", "outputFormat": "Output a single integer: the number of ways to place $n$ pigs into $m$ houses such that no house is left empty.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "三只小猪", "background": "你听说过三只小猪的故事吗？这是一个经典的故事。很久很久以前，有三只小猪。第一只小猪用稻草建的房子，第二个小猪用木棍建的房子，第三个小猪则使用砖做为材料。一只大灰狼想吃掉它们并吹倒了稻草和木棍建的房子。但是砖盖的房子很结实，狼最终也没有破坏掉，最后小猪们战胜了大灰狼并把它尾巴烧掉了。", "description": "为了自己的安全，小猪们又建造了一个新砖房。但是现在问题出现了，怎样把三个小猪分配到两个房子里呢？第三只小猪是三只小猪中最聪明的一只，为了不浪费任何一个房子，它总共考虑了三种方案，如下图\n\n ![](https://cdn.luogu.com.cn/upload/pic/6862.png) \n\n“但是将来怎么办呢？”第三只小猪知道将来随着成员的增多，它们将会盖更多的房子。它想知道给定了房子和猪的数目后，房子的分配方案有多少，但这个问题对于它来说，很明显有点难了，你能帮小猪解决这个问题吗？", "inputFormat": "输入文件 piggy.in，仅有一行，包含两个整数 $n$ 和 $m$，分别表示小猪的数目和房间数（$1\\leq n, m \\leq 50$）。", "outputFormat": "输出文件 piggy.out，仅一个整数，表示将 $n$ 只小猪安置在 $m$ 个房间且没有房间空闲的方案数。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3905", "type": "P", "difficulty": 3, "samples": [["3\n2\n1 2 1\n2 3 2\n1\n1 2\n1 3", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "最短路", "队列"], "title": "道路重建", "background": "", "description": "从前，在一个王国中，在 $n$ 个城市间有 $m$ 条道路连接，而且任意两个城市之间至多有一条道路直接相连。在经过一次严重的战争之后，有 $d$ 条道路被破坏了。国王想要修复国家的道路系统，现在有两个重要城市 $A$ 和 $B$ 之间的交通中断，国王希望尽快的恢复两个城市之间的连接。你的任务就是修复一些道路使 $A$ 与 $B$ 之间的连接恢复，并要求修复的道路长度最小。", "inputFormat": "输入文件第一行为一个整数 $n\\ (2<n\\le 100)$，表示城市的个数。这些城市编号从 $1$ 到 $n$。\n\n第二行为一个整数 $m\\ (n-1\\le m\\le \\dfrac{1}{2}n(n-1))$，表示道路的数目。\n\n接下来的 $m$ 行，每行 $3$ 个整数 $i,j,k\\ (1 \\le i,j \\le n,i\\neq j,0<k \\le 100)$，表示城市 $i$ 与 $j$ 之间有一条长为 $k$ 的道路相连。\n\n接下来一行为一个整数 $d\\ (1\\le d\\le m)$，表示战后被破坏的道路的数目。在接下来的 $d$ 行中，每行两个整数 $i$ 和 $j$，表示城市 $i$ 与 $j$ 之间直接相连的道路被破坏。\n\n最后一行为两个整数 $A$ 和 $B$，代表需要恢复交通的两个重要城市。", "outputFormat": "输出文件仅一个整数，表示恢复 $A$ 与 $B$ 间的交通需要修复的道路总长度的最小值。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Road Reconstruction", "background": "", "description": "Once, in a kingdom, there were $m$ roads connecting $n$ cities, and between any two cities there was at most one direct road. After a severe war, $d$ roads were destroyed. The king wants to repair the country's road system. Now, traffic between two important cities $A$ and $B$ is interrupted, and the king hopes to restore the connection between these two cities as soon as possible. Your task is to repair some roads to restore the connection between $A$ and $B$, while minimizing the total length of the repaired roads.", "inputFormat": "The first line contains an integer $n\\ (2<n\\le 100)$, representing the number of cities. These cities are numbered from $1$ to $n$.\n\nThe second line contains an integer $m\\ (n-1\\le m\\le \\dfrac{1}{2}n(n-1))$, representing the number of roads.\n\nEach of the next $m$ lines contains $3$ integers $i,j,k\\ (1 \\le i,j \\le n,i\\neq j,0<k \\le 100)$, indicating that there is a road of length $k$ directly connecting city $i$ and city $j$.\n\nThe next line contains an integer $d\\ (1\\le d\\le m)$, representing the number of roads that were destroyed after the war. In each of the following $d$ lines, there are two integers $i$ and $j$, indicating that the road directly connecting city $i$ and city $j$ was destroyed.\n\nThe last line contains two integers $A$ and $B$, representing the two important cities whose traffic needs to be restored.", "outputFormat": "Output a single integer, representing the minimal total length of roads that must be repaired to restore traffic between $A$ and $B$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "道路重建", "background": "", "description": "从前，在一个王国中，在 $n$ 个城市间有 $m$ 条道路连接，而且任意两个城市之间至多有一条道路直接相连。在经过一次严重的战争之后，有 $d$ 条道路被破坏了。国王想要修复国家的道路系统，现在有两个重要城市 $A$ 和 $B$ 之间的交通中断，国王希望尽快的恢复两个城市之间的连接。你的任务就是修复一些道路使 $A$ 与 $B$ 之间的连接恢复，并要求修复的道路长度最小。", "inputFormat": "输入文件第一行为一个整数 $n\\ (2<n\\le 100)$，表示城市的个数。这些城市编号从 $1$ 到 $n$。\n\n第二行为一个整数 $m\\ (n-1\\le m\\le \\dfrac{1}{2}n(n-1))$，表示道路的数目。\n\n接下来的 $m$ 行，每行 $3$ 个整数 $i,j,k\\ (1 \\le i,j \\le n,i\\neq j,0<k \\le 100)$，表示城市 $i$ 与 $j$ 之间有一条长为 $k$ 的道路相连。\n\n接下来一行为一个整数 $d\\ (1\\le d\\le m)$，表示战后被破坏的道路的数目。在接下来的 $d$ 行中，每行两个整数 $i$ 和 $j$，表示城市 $i$ 与 $j$ 之间直接相连的道路被破坏。\n\n最后一行为两个整数 $A$ 和 $B$，代表需要恢复交通的两个重要城市。", "outputFormat": "输出文件仅一个整数，表示恢复 $A$ 与 $B$ 间的交通需要修复的道路总长度的最小值。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3906", "type": "P", "difficulty": 3, "samples": [["5 6\n1 2\n1 3\n2 3\n2 4\n3 5\n4 5\n3\n2 5\n5 1\n2 4", "2 3 4 5\n1 3 5\n2 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "枚举", "排序", "最短路"], "title": "Geodetic集合", "background": "", "description": "图 $\\text G$ 是一个无向连通图，没有自环，并且两点之间至多只有一条边。我们定义顶点 $v,u$ 的最短路径就是从 $v$ 到 $u$ 经过边最少的路径。所有包含在 $v-u$ 的最短路径上的顶点被称为 $v-u$ 的 Geodetic 顶点，这些顶点的集合记作 $I(v,u)$。\n\n我们称集合 $I(v,u)$ 为一个 Geodetic 集合。\n\n例如下图中，$I(2,5)=\\{2,3,4,5\\}$，$I(1,5)=\\{1,3,5\\}$，$I(2,4)=\\{2,4\\}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/26c7a19d.png)\n\n给定一个图 $\\text G$ 和若干点对 $v,u$，请你分别求出 $I(v,u)$。", "inputFormat": "第一行为两个整数 $n,m$，分别表示图 $\\text G$ 的顶点数和边数（顶点编号为 $1\\sim n$）。\n\n接下来 $m$ 行，每行两个整数 $a,b$，表示 顶点 $a$ 和 $b$ 之间有一条无向边。\n\n第 $m+2$ 行有一个整数 $k$，表示给定的点对数。  \n接下来 $k$ 行，每行两个整数 $v,u$，表示每个点对的起点和终点。", "outputFormat": "共 $k$ 行，对于输入文件中每一个点对 $v,u$，按顶点顺序一行输出 $I(v,u)$ 里面的所有点的编号。", "hint": "对于所有数据，满足 $1\\leq n\\leq 40$，$1\\leq m,k\\leq \\frac{n(n-1)}2$。", "locale": "zh-CN", "translations": {"en": {"title": "Geodetic Set", "background": "", "description": "A graph $\\text G$ is an undirected connected graph with no self-loops, and there is at most one edge between any two vertices. We define the shortest path between vertices $v$ and $u$ as a path from $v$ to $u$ that uses the fewest edges. Every vertex that lies on some shortest $v$-$u$ path is called a $v$-$u$ Geodetic vertex, and the set of these vertices is denoted by $I(v,u)$.\n\nWe call the set $I(v,u)$ a Geodetic set.\n\nFor example, in the figure below, $I(2,5)=\\{2,3,4,5\\}$, $I(1,5)=\\{1,3,5\\}$, and $I(2,4)=\\{2,4\\}$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/26c7a19d.png)\n\nGiven a graph $\\text G$ and several pairs $v, u$, please compute $I(v,u)$ for each pair.", "inputFormat": "The first line contains two integers $n, m$, representing the number of vertices and edges of $\\text G$ (vertices are numbered $1 \\sim n$).\n\nThe next $m$ lines each contain two integers $a, b$, indicating that there is an undirected edge between vertices $a$ and $b$.\n\nThe $(m+2)$-th line contains an integer $k$, representing the number of given pairs.  \nThe next $k$ lines each contain two integers $v, u$, the start and end vertices of each pair.", "outputFormat": "Output $k$ lines. For each pair $v, u$ in the input, output in one line all vertex indices in $I(v,u)$ in increasing order of vertex indices.", "hint": "For all testdata, $1 \\le n \\le 40$, $1 \\le m, k \\le \\frac{n(n-1)}{2}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Geodetic集合", "background": "", "description": "图 $\\text G$ 是一个无向连通图，没有自环，并且两点之间至多只有一条边。我们定义顶点 $v,u$ 的最短路径就是从 $v$ 到 $u$ 经过边最少的路径。所有包含在 $v-u$ 的最短路径上的顶点被称为 $v-u$ 的 Geodetic 顶点，这些顶点的集合记作 $I(v,u)$。\n\n我们称集合 $I(v,u)$ 为一个 Geodetic 集合。\n\n例如下图中，$I(2,5)=\\{2,3,4,5\\}$，$I(1,5)=\\{1,3,5\\}$，$I(2,4)=\\{2,4\\}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/26c7a19d.png)\n\n给定一个图 $\\text G$ 和若干点对 $v,u$，请你分别求出 $I(v,u)$。", "inputFormat": "第一行为两个整数 $n,m$，分别表示图 $\\text G$ 的顶点数和边数（顶点编号为 $1\\sim n$）。\n\n接下来 $m$ 行，每行两个整数 $a,b$，表示 顶点 $a$ 和 $b$ 之间有一条无向边。\n\n第 $m+2$ 行有一个整数 $k$，表示给定的点对数。  \n接下来 $k$ 行，每行两个整数 $v,u$，表示每个点对的起点和终点。", "outputFormat": "共 $k$ 行，对于输入文件中每一个点对 $v,u$，按顶点顺序一行输出 $I(v,u)$ 里面的所有点的编号。", "hint": "对于所有数据，满足 $1\\leq n\\leq 40$，$1\\leq m,k\\leq \\frac{n(n-1)}2$。", "locale": "zh-CN"}}}
{"pid": "P3907", "type": "P", "difficulty": 5, "samples": [["2\n3 3\n1 2 1\n2 3 2\n3 1 3\n1 1\n1 1 1", "Yes\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "图论"], "title": "环的异或", "background": null, "description": "给出无向图 G，边 $(A_i,B_i)$ 的权是 $C_i$，判断下列性质是否成立：\n\n对于任意环 C，其边权的异或和是 $0$。", "inputFormat": "第 $1$ 行，$1$ 个整数 $T$，表示数据的组数。\n\n每组数据第 $1$ 行，$2$ 个整数 $N,M$，表示图 G 点和边的数量。\n\n接下来 $M$ 行，每行 $3$ 个整数 $A_i,B_i,C_i$。", "outputFormat": "对每个数据输出一行，`Yes` 或者 `No`。", "hint": "- 对于 $50\\%$ 的数据，$N,M \\le 20$。\n\n- 对于 $100\\%$ 的数据，$1 \\le T \\le 10$，$1 \\le N,M \\le 50$，$1 \\le A_i,B_i \\le N$，$0 \\le C_i < 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "XOR of Cycles", "background": "", "description": "Given an undirected graph $G$, the weight of edge $(A_i, B_i)$ is $C_i$. Determine whether the following property holds: For any cycle $C$, the XOR of the edge weights along $C$ is $0$.", "inputFormat": "The first line contains an integer $T$, denoting the number of test cases.\nFor each test case, the first line contains two integers $N, M$, denoting the numbers of vertices and edges of graph $G$.\nThe next $M$ lines each contain three integers $A_i, B_i, C_i$.", "outputFormat": "For each test case, output one line: Yes or No.", "hint": "- For 50% of the testdata, $N, M \\le 20$.\n- For 100% of the testdata, $1 \\le T \\le 10$, $1 \\le N, M \\le 50$, $1 \\le A_i, B_i \\le N$, $0 \\le C_i < 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "环的异或", "background": null, "description": "给出无向图 G，边 $(A_i,B_i)$ 的权是 $C_i$，判断下列性质是否成立：\n\n对于任意环 C，其边权的异或和是 $0$。", "inputFormat": "第 $1$ 行，$1$ 个整数 $T$，表示数据的组数。\n\n每组数据第 $1$ 行，$2$ 个整数 $N,M$，表示图 G 点和边的数量。\n\n接下来 $M$ 行，每行 $3$ 个整数 $A_i,B_i,C_i$。", "outputFormat": "对每个数据输出一行，`Yes` 或者 `No`。", "hint": "- 对于 $50\\%$ 的数据，$N,M \\le 20$。\n\n- 对于 $100\\%$ 的数据，$1 \\le T \\le 10$，$1 \\le N,M \\le 50$，$1 \\le A_i,B_i \\le N$，$0 \\le C_i < 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3908", "type": "P", "difficulty": 3, "samples": [["3", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "递归", "进制"], "title": "数列之异或", "background": null, "description": "求 $1 \\oplus 2 \\oplus\\cdots\\oplus N$ 的值。\n\n$A \\oplus B$ 即为 $A,B$ 按位异或后的值。", "inputFormat": "一行一个整数 $N$。", "outputFormat": "一个整数，表示所求的值。", "hint": "- 对于 $50\\%$ 的数据，$1 \\le N \\le 10^6$；\n\n- 对于 $100\\%$ 的数据，$1 \\le N \\le 10^{18}$。", "locale": "zh-CN", "translations": {"en": {"title": "XOR of a Sequence", "background": "", "description": "Find the value of $1 \\oplus 2 \\oplus\\cdots\\oplus N$.\n\n$A \\oplus B$ denotes the bitwise XOR of $A,B$.", "inputFormat": "One line with an integer $N$.", "outputFormat": "One integer, the answer.", "hint": "- For 50% of the testdata, $1 \\le N \\le 10^6$.\n- For 100% of the testdata, $1 \\le N \\le 10^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数列之异或", "background": null, "description": "求 $1 \\oplus 2 \\oplus\\cdots\\oplus N$ 的值。\n\n$A \\oplus B$ 即为 $A,B$ 按位异或后的值。", "inputFormat": "一行一个整数 $N$。", "outputFormat": "一个整数，表示所求的值。", "hint": "- 对于 $50\\%$ 的数据，$1 \\le N \\le 10^6$；\n\n- 对于 $100\\%$ 的数据，$1 \\le N \\le 10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P3909", "type": "P", "difficulty": 3, "samples": [["3\n1 2 3", "36"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "前缀和"], "title": "异或之积", "background": "", "description": "对于$A_1,A_2,A_3,\\cdots,A_N$，求\n\n$$(6\\times \\sum_{i=1}^N\\sum_{j=i+1}^N\\sum_{k=j+1}^N A_i\\times A_j\\times A_k) \\bmod (10^9+7)$$\n", "inputFormat": "第 1 行，1 个整数$N$。\n\n第 2 行，$N$ 个整数 $A_1,A_2,A_3,\\cdots,A_N$。", "outputFormat": "1 个整数，表示所求的值。\n", "hint": "- 对于 $30\\%$ 的数据，$N \\le 500$；\n- 对于 $60\\%$ 的数据，$N \\le 5000$；\n- 对于 $100\\%$ 的数据，$3 \\le N \\le 10^6$，$0 \\le A_i \\le 10^9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "XOR Product", "background": "", "description": "For $A_1, A_2, A_3, \\cdots, A_N$, compute\n$$(6\\times \\sum_{i=1}^N\\sum_{j=i+1}^N\\sum_{k=j+1}^N A_i\\times A_j\\times A_k) \\bmod (10^9+7)$$", "inputFormat": "Line 1: one integer $N$.\n\nLine 2: $N$ integers $A_1, A_2, A_3, \\cdots, A_N$.", "outputFormat": "One integer, representing the required value.", "hint": "- For 30% of the testdata, $N \\le 500$.\n- For 60% of the testdata, $N \\le 5000$.\n- For 100% of the testdata, $3 \\le N \\le 10^6$, $0 \\le A_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "异或之积", "background": "", "description": "对于$A_1,A_2,A_3,\\cdots,A_N$，求\n\n$$(6\\times \\sum_{i=1}^N\\sum_{j=i+1}^N\\sum_{k=j+1}^N A_i\\times A_j\\times A_k) \\bmod (10^9+7)$$\n", "inputFormat": "第 1 行，1 个整数$N$。\n\n第 2 行，$N$ 个整数 $A_1,A_2,A_3,\\cdots,A_N$。", "outputFormat": "1 个整数，表示所求的值。\n", "hint": "- 对于 $30\\%$ 的数据，$N \\le 500$；\n- 对于 $60\\%$ 的数据，$N \\le 5000$；\n- 对于 $100\\%$ 的数据，$3 \\le N \\le 10^6$，$0 \\le A_i \\le 10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P3910", "type": "P", "difficulty": 3, "samples": [["20 15", "[1,5]\n[4,6]\n[7,8]\n[15,15]"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "枚举"], "title": "纪念邮票", "background": "", "description": "邮局最近推出了一套纪念邮票，这套邮票共有 $N$ 张，邮票面值各不相同，按编号顺序为 $1$ 分，$2$ 分，……，$N$ 分。\n\n小明是个集邮爱好者，他很喜欢这套邮票，可惜现在他身上只有 $M$ 分，并不够把全套都买下，但是他希望刚好花光所有的钱。作为一个集邮爱好者，小明也不想买的邮票编号断断续续，所以小明打算买面值 $a$ 分至 $b$ 分的 $b-a+1$ 张连续的邮票，且总价值刚好为 $M$ 分。\n\n你的任务是求出所有符合要求的方案，以 $\\left[a,b\\right]$ 的形式输出。", "inputFormat": "输入文件只有一行。包含两个整数 $N$ 和 $M$（$1\\le N,M \\le 10^9$），之间用空格隔开。", "outputFormat": "输出文件每行包含一个合法方案：$\\left[a,b\\right]$，按 $a$ 值从小到大输出。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Commemorative Stamps", "background": "", "description": "The post office has recently released a set of commemorative stamps. There are $N$ stamps in this set, each with a different face value, in order $1$ cent, $2$ cents, …, $N$ cents.\n\nXiaoming is a stamp collector. He likes this set very much, but he only has $M$ cents, which is not enough to buy the whole set. However, he wants to spend exactly all his money. As a collector, he also does not want the stamp numbers to be discontinuous, so he plans to buy $b-a+1$ consecutive stamps with values from $a$ cents to $b$ cents, and the total value is exactly $M$ cents.\n\nYour task is to find all valid plans and output them in the form $\\left[a,b\\right]$.", "inputFormat": "The input consists of a single line containing two integers $N$ and $M$ ($1 \\le N, M \\le 10^9$), separated by a space.", "outputFormat": "Output each valid plan on a separate line as $\\left[a,b\\right]$, in increasing order of $a$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "纪念邮票", "background": "", "description": "邮局最近推出了一套纪念邮票，这套邮票共有 $N$ 张，邮票面值各不相同，按编号顺序为 $1$ 分，$2$ 分，……，$N$ 分。\n\n小明是个集邮爱好者，他很喜欢这套邮票，可惜现在他身上只有 $M$ 分，并不够把全套都买下，但是他希望刚好花光所有的钱。作为一个集邮爱好者，小明也不想买的邮票编号断断续续，所以小明打算买面值 $a$ 分至 $b$ 分的 $b-a+1$ 张连续的邮票，且总价值刚好为 $M$ 分。\n\n你的任务是求出所有符合要求的方案，以 $\\left[a,b\\right]$ 的形式输出。", "inputFormat": "输入文件只有一行。包含两个整数 $N$ 和 $M$（$1\\le N,M \\le 10^9$），之间用空格隔开。", "outputFormat": "输出文件每行包含一个合法方案：$\\left[a,b\\right]$，按 $a$ 值从小到大输出。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3911", "type": "P", "difficulty": 6, "samples": [["2\n2 3", "17"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "莫比乌斯反演"], "title": "最小公倍数之和", "background": "", "description": "对于$A_1,A_2,\\cdots,A_N$，求\n\n$\\sum_{i=1}^N\\sum_{j=1}^N \\mathrm{lcm}(A_i,A_j)$\n\n的值。\n\n$\\mathrm{lcm}(a,b)$ 表示 $a$ 和 $b$ 的最小公倍数。\n", "inputFormat": "第一行，一个整数 $N$。\n\n第二行，$N$ 个整数 $A_1,A_2,\\cdots,A_N$。\n", "outputFormat": "一行一个整数，表示所求的值。\n", "hint": "对于 $30\\%$ 的数据，$1 \\le N \\le 1000$，$1 \\le A_i \\le 5\\times 10^4$。\n\n对于另外 $30\\%$ 的数据，$1 \\le N \\le 5\\times 10^4$，$1 \\le A_i \\le 1000$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 5\\times 10^4$，$1 \\le A_i \\le 5\\times 10^4$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Sum of Least Common Multiples", "background": "", "description": "For $A_1, A_2, \\cdots, A_N$, compute the following value.\n\n$\\sum_{i=1}^N\\sum_{j=1}^N \\mathrm{lcm}(A_i,A_j)$\n\nHere, $\\mathrm{lcm}(a, b)$ denotes the least common multiple of $a$ and $b$.", "inputFormat": "The first line contains an integer $N$.\n\nThe second line contains $N$ integers $A_1, A_2, \\cdots, A_N$.", "outputFormat": "Output one integer in a single line, representing the required value.", "hint": "Constraints:\n- For 30% of the testdata, $1 \\le N \\le 1000$, $1 \\le A_i \\le 5 \\times 10^4$.\n- For another 30% of the testdata, $1 \\le N \\le 5 \\times 10^4$, $1 \\le A_i \\le 1000$.\n- For 100% of the testdata, $1 \\le N \\le 5 \\times 10^4$, $1 \\le A_i \\le 5 \\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最小公倍数之和", "background": "", "description": "对于$A_1,A_2,\\cdots,A_N$，求\n\n$\\sum_{i=1}^N\\sum_{j=1}^N \\mathrm{lcm}(A_i,A_j)$\n\n的值。\n\n$\\mathrm{lcm}(a,b)$ 表示 $a$ 和 $b$ 的最小公倍数。\n", "inputFormat": "第一行，一个整数 $N$。\n\n第二行，$N$ 个整数 $A_1,A_2,\\cdots,A_N$。\n", "outputFormat": "一行一个整数，表示所求的值。\n", "hint": "对于 $30\\%$ 的数据，$1 \\le N \\le 1000$，$1 \\le A_i \\le 5\\times 10^4$。\n\n对于另外 $30\\%$ 的数据，$1 \\le N \\le 5\\times 10^4$，$1 \\le A_i \\le 1000$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 5\\times 10^4$，$1 \\le A_i \\le 5\\times 10^4$。\n", "locale": "zh-CN"}}}
{"pid": "P3912", "type": "P", "difficulty": 2, "samples": [["10", "4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "枚举", "素数判断,质数,筛法"], "title": "素数个数", "background": "", "description": "求 $1,2,\\cdots,N$ 中素数的个数。\n", "inputFormat": "一行一个整数 $N$。\n", "outputFormat": "一行一个整数，表示素数的个数。\n", "hint": "对于 $40\\%$ 的数据，$1 \\le N \\le 10^6$。\n\n对于 $80\\%$ 的数据，$1 \\le N \\le 10^7$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^8$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Number of Primes", "background": "", "description": "Find the number of primes among $1, 2, \\cdots, N$.", "inputFormat": "One line containing an integer $N$.", "outputFormat": "One line containing an integer, representing the number of primes.", "hint": "For $40\\%$ of the testdata, $1 \\le N \\le 10^6$.\n\nFor $80\\%$ of the testdata, $1 \\le N \\le 10^7$.\n\nFor $100\\%$ of the testdata, $1 \\le N \\le 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "素数个数", "background": "", "description": "求 $1,2,\\cdots,N$ 中素数的个数。\n", "inputFormat": "一行一个整数 $N$。\n", "outputFormat": "一行一个整数，表示素数的个数。\n", "hint": "对于 $40\\%$ 的数据，$1 \\le N \\le 10^6$。\n\n对于 $80\\%$ 的数据，$1 \\le N \\le 10^7$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^8$。\n", "locale": "zh-CN"}}}
{"pid": "P3913", "type": "P", "difficulty": 2, "samples": [["3 2\n1 2\n2 2", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "排序"], "title": "车的攻击", "background": null, "description": "$N \\times N$ 的国际象棋棋盘上有 $K$ 个车，第 $i$ 个车位于第 $R_i$ 行，第 $C_i$ 列。求至少被一个车攻击的格子数量。\n\n车可以攻击所有同一行或者同一列的地方。", "inputFormat": "第 $1$ 行，$2$ 个整数 $N,K$。\n\n接下来 $K$ 行，每行 $2$ 个整数 $R_i,C_i$。", "outputFormat": "$1$ 个整数，表示被攻击的格子数量。", "hint": "• 对于 $30\\%$ 的数据，$1 \\le N \\le 10^3$，$1 \\le K \\le 10^3$；\n\n• 对于 $60\\%$ 的数据，$1 \\le N \\le 10^6$，$1 \\le K \\le 10^6$；\n\n• 对于 $100\\%$ 的数据，$1 \\le N \\le 10^9$，$1 \\le K \\le 10^6$，$1 \\le R_i , C_i \\le N$。", "locale": "zh-CN", "translations": {"en": {"title": "Rooks' Attack", "background": "", "description": "On an $N \\times N$ chessboard, there are $K$ rooks. The $i$-th rook is located at row $R_i$ and column $C_i$. Find the number of cells attacked by at least one rook.\n\nA rook can attack all cells in the same row or the same column.", "inputFormat": "The first line contains 2 integers $N, K$.\n\nThe next $K$ lines each contain 2 integers $R_i, C_i$.", "outputFormat": "Output one integer, the number of cells that are attacked.", "hint": "• For 30% of the testdata, $1 \\le N \\le 10^3; 1 \\le K \\le 10^3$.\n\n• For 60% of the testdata, $1 \\le N \\le 10^6; 1 \\le K \\le 10^6$.\n\n• For 100% of the testdata, $1 \\le N \\le 10^9; 1 \\le K \\le 10^6; 1 \\le R_i, C_i \\le N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "车的攻击", "background": null, "description": "$N \\times N$ 的国际象棋棋盘上有 $K$ 个车，第 $i$ 个车位于第 $R_i$ 行，第 $C_i$ 列。求至少被一个车攻击的格子数量。\n\n车可以攻击所有同一行或者同一列的地方。", "inputFormat": "第 $1$ 行，$2$ 个整数 $N,K$。\n\n接下来 $K$ 行，每行 $2$ 个整数 $R_i,C_i$。", "outputFormat": "$1$ 个整数，表示被攻击的格子数量。", "hint": "• 对于 $30\\%$ 的数据，$1 \\le N \\le 10^3$，$1 \\le K \\le 10^3$；\n\n• 对于 $60\\%$ 的数据，$1 \\le N \\le 10^6$，$1 \\le K \\le 10^6$；\n\n• 对于 $100\\%$ 的数据，$1 \\le N \\le 10^9$，$1 \\le K \\le 10^6$，$1 \\le R_i , C_i \\le N$。", "locale": "zh-CN"}}}
{"pid": "P3914", "type": "P", "difficulty": 4, "samples": [["2 2\n1 1\n2 1 2\n1 2", "1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "数学", "枚举", "深度优先搜索 DFS"], "title": "染色计数", "background": "", "description": "有一颗$N$个节点的树，节点用$1,2,\\cdots,N$编号。你要给它染色，使得相邻节点的颜色不同。有$M$种颜色，用$1,2,\\cdots,M$编号。每个节点可以染$M$种颜色中的若干种，求不同染色方案的数量除以($10^9 + 7$)的余数。\n", "inputFormat": "第1 行，2 个整数$N,M$。\n\n接下来$N$行，第$i$行表示节点$i$可以染的颜色。第1个整数$k_i$，表示可以染的颜色数量。接下来$k_i$个整数，表示可以染的颜色编号。\n\n最后$N - 1$行，每行2个整数$A_i,B_i$，表示边$(A_i,B_i)$。\n", "outputFormat": "1 个整数，表示所有的数。\n", "hint": "• 对于30% 的数据，$1 \\le N \\le 10; 1 \\le M \\le 4$；\n\n• 对于60% 的数据，$1 \\le N \\le 200; 1 \\le M \\le 200$；\n\n• 对于100% 的数据，$1 \\le N \\le 5000; 1 \\le M \\le 5000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Coloring Count", "background": "", "description": "There is a tree with $N$ nodes, numbered $1, 2, \\cdots, N$. You need to color it so that adjacent nodes have different colors. There are $M$ colors, numbered $1, 2, \\cdots, M$. Each node may be colored with a subset of the $M$ colors. Compute the number of different valid colorings modulo $10^9 + 7$.", "inputFormat": "The first line contains two integers $N, M$.\n\nThen follow $N$ lines. The $i$-th line describes the colors allowed for node $i$: the first integer $k_i$ is the number of allowed colors, followed by $k_i$ integers giving the allowed color indices.\n\nFinally, the last $N - 1$ lines each contain two integers $A_i, B_i$, indicating an edge $(A_i, B_i)$.", "outputFormat": "Output one integer, the number of valid colorings modulo $10^9 + 7$.", "hint": "• For 30% of the testdata, $1 \\le N \\le 10; 1 \\le M \\le 4$.\n\n• For 60% of the testdata, $1 \\le N \\le 200; 1 \\le M \\le 200$.\n\n• For 100% of the testdata, $1 \\le N \\le 5000; 1 \\le M \\le 5000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "染色计数", "background": "", "description": "有一颗$N$个节点的树，节点用$1,2,\\cdots,N$编号。你要给它染色，使得相邻节点的颜色不同。有$M$种颜色，用$1,2,\\cdots,M$编号。每个节点可以染$M$种颜色中的若干种，求不同染色方案的数量除以($10^9 + 7$)的余数。\n", "inputFormat": "第1 行，2 个整数$N,M$。\n\n接下来$N$行，第$i$行表示节点$i$可以染的颜色。第1个整数$k_i$，表示可以染的颜色数量。接下来$k_i$个整数，表示可以染的颜色编号。\n\n最后$N - 1$行，每行2个整数$A_i,B_i$，表示边$(A_i,B_i)$。\n", "outputFormat": "1 个整数，表示所有的数。\n", "hint": "• 对于30% 的数据，$1 \\le N \\le 10; 1 \\le M \\le 4$；\n\n• 对于60% 的数据，$1 \\le N \\le 200; 1 \\le M \\le 200$；\n\n• 对于100% 的数据，$1 \\le N \\le 5000; 1 \\le M \\le 5000$。\n", "locale": "zh-CN"}}}
{"pid": "P3915", "type": "P", "difficulty": 3, "samples": [["2\n4 2\n1 2\n2 3\n3 4\n4 2\n1 2\n1 3\n1 4\n", "YES\nNO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "树形数据结构", "深度优先搜索 DFS"], "title": "树的分解", "background": "", "description": "给出 $N$ 个点的树和 $K$，问能否把树划分成 $\\frac{N}{K}$ 个连通块，且每个连通块的点数都是 $K$。", "inputFormat": "第一行，一个整数 $T$，表示数据组数。接下来 $T$ 组数据，对于每组数据：\n\n第一行，两个整数 $N, K$。\n\n接下来 $N - 1$ 行，每行两个整数 $A_i, B_i$，表示边 $(A_i, B_i)$。点用 $1, 2, \\ldots, N$ 编号。", "outputFormat": "对于每组数据，输出 `YES` 或 `NO`。", "hint": "- 对于 $60 \\%$ 的数据，$1 \\le N, K \\le 10^3$；\n- 对于 $100 \\%$ 的数据，$1 \\le T \\le 10$，$1 \\le N ,K \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Tree Decomposition", "background": "", "description": "Given a tree with $N$ vertices and an integer $K$, determine whether it can be partitioned into $\\frac{N}{K}$ connected components, each containing exactly $K$ vertices.", "inputFormat": "The first line contains an integer $T$, the number of test cases. Then follow $T$ test cases:\n\nThe first line of each test case contains two integers $N, K$.\n\nThe next $N - 1$ lines each contain two integers $A_i, B_i$, denoting the edge $(A_i, B_i)$. The vertices are labeled $1, 2, \\ldots, N$.", "outputFormat": "For each test case, output `YES` or `NO`.", "hint": "- For $60\\%$ of the testdata, $1 \\le N, K \\le 10^3$.\n- For $100\\%$ of the testdata, $1 \\le T \\le 10$, $1 \\le N, K \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "树的分解", "background": "", "description": "给出 $N$ 个点的树和 $K$，问能否把树划分成 $\\frac{N}{K}$ 个连通块，且每个连通块的点数都是 $K$。", "inputFormat": "第一行，一个整数 $T$，表示数据组数。接下来 $T$ 组数据，对于每组数据：\n\n第一行，两个整数 $N, K$。\n\n接下来 $N - 1$ 行，每行两个整数 $A_i, B_i$，表示边 $(A_i, B_i)$。点用 $1, 2, \\ldots, N$ 编号。", "outputFormat": "对于每组数据，输出 `YES` 或 `NO`。", "hint": "- 对于 $60 \\%$ 的数据，$1 \\le N, K \\le 10^3$；\n- 对于 $100 \\%$ 的数据，$1 \\le T \\le 10$，$1 \\le N ,K \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3916", "type": "P", "difficulty": 3, "samples": [["4 3\n1 2\n2 4\n4 3", "4 4 3 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "图论", "广度优先搜索 BFS", "深度优先搜索 DFS", "图论建模", "强连通分量"], "title": "图的遍历", "background": null, "description": "给出 $N$ 个点，$M$ 条边的有向图，对于每个点 $v$，令 $A(v)$ 表示从点 $v$ 出发，能到达的编号最大的点。现在请求出 $A(1),A(2),\\dots,A(N)$ 的值。", "inputFormat": "第 $1$ 行 $2$ 个整数 $N,M$，表示点数和边数。\n\n接下来 $M$ 行，每行 $2$ 个整数 $U_i,V_i$，表示边 $(U_i,V_i)$。点用 $1,2,\\dots,N$ 编号。", "outputFormat": "一行 $N$ 个整数 $A(1),A(2),\\dots,A(N)$。", "hint": "- 对于 $60\\%$ 的数据，$1 \\leq N,M \\leq 10^3$。\n- 对于 $100\\%$ 的数据，$1 \\leq N,M \\leq 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Graph Traversal", "background": "", "description": "Given a directed graph with $N$ vertices and $M$ edges, for each vertex $v$, let $A(v)$ denote the reachable vertex with the largest index starting from $v$. Now compute $A(1), A(2), \\dots, A(N)$.", "inputFormat": "The first line contains two integers $N, M$, denoting the number of vertices and edges.\nThe next $M$ lines each contain two integers $U_i, V_i$, representing the edge $(U_i, V_i)$. Vertices are labeled $1, 2, \\dots, N$.", "outputFormat": "One line with $N$ integers $A(1), A(2), \\dots, A(N)$.", "hint": "- For $60\\%$ of the testdata, $1 \\leq N, M \\leq 10^3$.\n- For $100\\%$ of the testdata, $1 \\leq N, M \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "图的遍历", "background": null, "description": "给出 $N$ 个点，$M$ 条边的有向图，对于每个点 $v$，令 $A(v)$ 表示从点 $v$ 出发，能到达的编号最大的点。现在请求出 $A(1),A(2),\\dots,A(N)$ 的值。", "inputFormat": "第 $1$ 行 $2$ 个整数 $N,M$，表示点数和边数。\n\n接下来 $M$ 行，每行 $2$ 个整数 $U_i,V_i$，表示边 $(U_i,V_i)$。点用 $1,2,\\dots,N$ 编号。", "outputFormat": "一行 $N$ 个整数 $A(1),A(2),\\dots,A(N)$。", "hint": "- 对于 $60\\%$ 的数据，$1 \\leq N,M \\leq 10^3$。\n- 对于 $100\\%$ 的数据，$1 \\leq N,M \\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3917", "type": "P", "difficulty": 4, "samples": [["2\n1 2", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "枚举", "进制"], "title": "异或序列", "background": "", "description": "给出序列 $A_1,A_2,\\cdots,A_N$，求\n\n$$\\sum_{1\\le i\\le j\\le N} A_i\\oplus A_{i+1}\\oplus\\cdots\\oplus A_j$$\n\n的值。其中，$\\bigoplus$ 表示按位异或。\n", "inputFormat": "第一行，一个整数 $N$。\n\n第二行，$N$个整数 $A_1,A_2,\\cdots,A_N$。\n", "outputFormat": "一个数，为表达式的值。", "hint": "- 对于 $60\\%$ 的数据，$1 \\le N \\le 10^3$；\n- 对于 $100\\%$ 的数据，$1 \\le N \\le 10^5$，$0 \\le A_i \\le 10^9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "XOR Sequence", "background": "", "description": "Given a sequence $A_1, A_2, \\cdots, A_N$, compute\n$$\\sum_{1\\le i\\le j\\le N} A_i\\oplus A_{i+1}\\oplus\\cdots\\oplus A_j$$\nwhere $\\bigoplus$ denotes bitwise XOR.", "inputFormat": "The first line contains an integer $N$.\n\nThe second line contains $N$ integers $A_1, A_2, \\cdots, A_N$.", "outputFormat": "Output a single integer: the value of the expression.", "hint": "- For $60\\%$ of the testdata, $1 \\le N \\le 10^3$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 10^5$, $0 \\le A_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "异或序列", "background": "", "description": "给出序列 $A_1,A_2,\\cdots,A_N$，求\n\n$$\\sum_{1\\le i\\le j\\le N} A_i\\oplus A_{i+1}\\oplus\\cdots\\oplus A_j$$\n\n的值。其中，$\\bigoplus$ 表示按位异或。\n", "inputFormat": "第一行，一个整数 $N$。\n\n第二行，$N$个整数 $A_1,A_2,\\cdots,A_N$。\n", "outputFormat": "一个数，为表达式的值。", "hint": "- 对于 $60\\%$ 的数据，$1 \\le N \\le 10^3$；\n- 对于 $100\\%$ 的数据，$1 \\le N \\le 10^5$，$0 \\le A_i \\le 10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P3918", "type": "P", "difficulty": 2, "samples": [["5 2\n2 2", "12\n\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "集训队互测", "排序"], "title": "[国家集训队] 特技飞行", "background": "1. wqs 爱好模拟飞行。\n\n2. clj 开了一家神犇航空，由于 clj 还要玩游戏，所以公司的事务由你来打理。\n\n注意：题目中只是用了这样一个背景，并不与真实/模拟飞行相符", "description": "神犇航空开展了一项载客特技飞行业务。每次飞行长 $n$ 个单位时间，每个单位时间可以进行一项特技动作，可选的动作有 $k$ 种，每种动作有一个刺激程度 $c_i$。如果连续进行相同的动作，乘客会感到厌倦，所以定义某次动作的价值为(距上次该动作的时间) $ \\times c_i$，若为第一次进行该动作，价值为 $0$。安排一种方案，使得总价值最大。", "inputFormat": "第一行，两个整数，$n$ 和 $k$，如上所述；\n\n第二行，$k$ 个整数，表示 $k$ 种动作的 $c_i$ 值。", "outputFormat": "仅一行，一个整数，表示最大总价值。\n", "hint": "#### 数据规模与约定\n\n- 对于 $10\\%$ 的测试数据，$n \\le 20$，$k \\le 3$。\n- 对于 $100\\%$ 的测试数据，$1 \\le n \\le 10^3$，$1 \\le k \\le 300$，$0 \\le c_i \\le 10^3$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTT] Stunt Flight", "background": "1. wqs loves flight simulation.\n2. clj founded Shenben Airlines (pinyin). Since clj also wants to play games, you are in charge of managing the company.\n\nNote: This is just a fictional background and does not correspond to real/simulated flying.", "description": "Shenben Airlines (pinyin) has launched a passenger-carrying stunt flying service. Each flight lasts $n$ time units. In each time unit, you can perform one stunt. There are $k$ types of stunts, and each type has an excitement level $c_i$. If the same stunt is performed repeatedly, passengers get bored, so we define the value of performing a stunt as (time since the last time this same stunt was performed) $ \\times c_i$. If it is the first time performing that stunt, the value is $0$. Plan a schedule to maximize the total value.", "inputFormat": "The first line contains two integers, $n$ and $k$, as described above.\nThe second line contains $k$ integers, the $c_i$ values for the $k$ stunt types.", "outputFormat": "Output a single line with one integer, the maximum total value.", "hint": "Constraints\n- For 10% of the testdata, $n \\le 20$, $k \\le 3$.\n- For 100% of the testdata, $1 \\le n \\le 10^3$, $1 \\le k \\le 300$, $0 \\le c_i \\le 10^3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] 特技飞行", "background": "1. wqs 爱好模拟飞行。\n\n2. clj 开了一家神犇航空，由于 clj 还要玩游戏，所以公司的事务由你来打理。\n\n注意：题目中只是用了这样一个背景，并不与真实/模拟飞行相符", "description": "神犇航空开展了一项载客特技飞行业务。每次飞行长 $n$ 个单位时间，每个单位时间可以进行一项特技动作，可选的动作有 $k$ 种，每种动作有一个刺激程度 $c_i$。如果连续进行相同的动作，乘客会感到厌倦，所以定义某次动作的价值为(距上次该动作的时间) $ \\times c_i$，若为第一次进行该动作，价值为 $0$。安排一种方案，使得总价值最大。", "inputFormat": "第一行，两个整数，$n$ 和 $k$，如上所述；\n\n第二行，$k$ 个整数，表示 $k$ 种动作的 $c_i$ 值。", "outputFormat": "仅一行，一个整数，表示最大总价值。\n", "hint": "#### 数据规模与约定\n\n- 对于 $10\\%$ 的测试数据，$n \\le 20$，$k \\le 3$。\n- 对于 $100\\%$ 的测试数据，$1 \\le n \\le 10^3$，$1 \\le k \\le 300$，$0 \\le c_i \\le 10^3$。", "locale": "zh-CN"}}}
{"pid": "P3919", "type": "P", "difficulty": 5, "samples": [["5 10\n59 46 14 87 41\n0 2 1\n0 1 1 14\n0 1 1 57\n0 1 1 88\n4 2 4\n0 2 5\n0 2 4\n4 2 1\n2 2 2\n1 1 5 91", "59\n87\n41\n87\n88\n46"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "平衡树", "递归", "O2优化", "可持久化线段树", "可持久化", "模板题"], "title": "【模板】可持久化线段树 1（可持久化数组）", "background": "2021.9.18 增添一组 hack 数据 by @panyf。\n\n标题即题意。\n\n有了可持久化数组，便可以实现很多衍生的可持久化功能。（例如：可持久化并查集）", "description": "如题，你需要维护这样的一个长度为 $ N $ 的数组，支持如下两种操作：\n\n\n1. 在某个历史版本上修改某一个位置上的值。\n\n2. 访问某个历史版本上的某一位置的值。\n\n\n此外，每进行一次操作，就会生成一个新的版本。版本编号即为当前操作的编号（从 $1$ 开始编号，版本 $0$ 表示初始状态数组）。\n\n**对于操作 $2$，即为生成一个完全一样的版本，不作任何改动**。即，询问生成的版本是询问所访问的那个版本的复制。", "inputFormat": "输入的第一行包含两个正整数 $ N, M $，分别表示数组的长度和操作的个数。\n\n第二行包含 $ N $ 个整数，依次为初始状态下数组各位的值（依次为 $ a_i $，$ 1 \\leq i \\leq N $）。\n\n接下来 $ M $ 行每行包含 $3$ 或 $4$ 个整数，代表两种操作之一（设当前是第 $i$ 次操作）：\n\n1. 对于操作 $1$，格式为 `v 1 p c`，即为在版本 $ v $ 的基础上，将 $ a_{p} $ 修改为 $c$。\n\n2. 对于操作 $2$，格式为 `v 2 p`，即访问版本 $ v $ 中的 $ a_{p} $ 的值，注意：**生成一样版本的对象应为 $v$**。", "outputFormat": "输出包含若干行，依次为每个操作 $2$ 的结果。", "hint": "### 数据规模\n\n对于 $30\\%$ 的数据，$ 1 \\leq N, M \\leq {10}^3 $。\n\n对于 $50\\%$ 的数据，$ 1 \\leq N, M \\leq {10}^4 $。\n\n对于 $70\\%$ 的数据，$ 1 \\leq N, M \\leq {10}^5 $。\n\n对于 $100\\%$ 的数据：\n\n- $ 1 \\leq N, M \\leq {10}^6$；\n- $1 \\leq p \\leq N$；\n- 设当前是第 $x$ 次操作，$0 \\leq v < x$；\n- $-{10}^9 \\leq a_i,c  \\leq {10}^9$。\n\n### 样例说明\n\n所有操作结束后，总共生成了 $11$ 个版本，编号为 $0 \\sim 10$，依次为：\n\n版本 $0$：`59 46 14 87 41`，\n\n版本 $1$：`59 46 14 87 41`，\n\n版本 $2$：`14 46 14 87 41`，\n\n版本 $3$：`57 46 14 87 41`，\n\n版本 $4$：`88 46 14 87 41`，\n\n版本 $5$：`88 46 14 87 41`，\n\n版本 $6$：`59 46 14 87 41`，\n\n版本 $7$：`59 46 14 87 41`，\n\n版本 $8$：`88 46 14 87 41`，\n\n版本 $9$：`14 46 14 87 41`，\n\n版本 $10$：`59 46 14 87 91`。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Persistent Segment Tree 1 (Persistent Array)", "background": "Added a set of hack testdata on 2021-09-18 by @panyf.\n\nThe title describes the problem.\n\nWith a persistent array, many derived persistent features can be implemented (for example: persistent union-find/DSU).", "description": "As described, you need to maintain an array of length $ N $, supporting the following two operations:\n\n1. Modify the value at some position on a certain historical version.\n2. Access the value at some position on a certain historical version.\n\nIn addition, each time you perform an operation, a new version is created. The version number equals the current operation index (starting from $ 1 $; version $ 0 $ is the initial array).\n\nFor operation $ 2 $, a completely identical version is created without any changes. That is, the version generated by a query is a copy of the version that is being accessed.", "inputFormat": "The first line contains two positive integers $ N, M $, the array length and the number of operations.\n\nThe second line contains $ N $ integers, the initial values of the array (denoted as $ a_i $, $ 1 \\leq i \\leq N $).\n\nEach of the next $ M $ lines contains $ 3 $ or $ 4 $ integers, representing one of the two operations (assume the current operation is the $ i $-th):\n\n1. For operation $ 1 $, the format is `v 1 p c`, meaning: based on version $ v $, set $ a_p $ to $ c $.\n2. For operation $ 2 $, the format is `v 2 p`, meaning: access the value of $ a_p $ in version $ v $. Note: the version that is duplicated must be $ v $.", "outputFormat": "Output several lines, each being the result of an operation $ 2 $, in order.", "hint": "Constraints\n\n- For $ 30\\% $ of the testdata, $ 1 \\leq N, M \\leq 10^3 $.\n- For $ 50\\% $ of the testdata, $ 1 \\leq N, M \\leq 10^4 $.\n- For $ 70\\% $ of the testdata, $ 1 \\leq N, M \\leq 10^5 $.\n- For $ 100\\% $ of the testdata:\n  - $ 1 \\leq N, M \\leq 10^6 $;\n  - $ 1 \\leq p \\leq N $;\n  - Suppose this is the $ x $-th operation, then $ 0 \\leq v < x $;\n  - $ -10^9 \\leq a_i, c \\leq 10^9 $.\n\nSample Explanation\n\nAfter all operations, a total of $ 11 $ versions are generated, numbered $ 0 \\sim 10 $, in order:\n\nVersion $ 0 $: `59 46 14 87 41`.\nVersion $ 1 $: `59 46 14 87 41`.\nVersion $ 2 $: `14 46 14 87 41`.\nVersion $ 3 $: `57 46 14 87 41`.\nVersion $ 4 $: `88 46 14 87 41`.\nVersion $ 5 $: `88 46 14 87 41`.\nVersion $ 6 $: `59 46 14 87 41`.\nVersion $ 7 $: `59 46 14 87 41`.\nVersion $ 8 $: `88 46 14 87 41`.\nVersion $ 9 $: `14 46 14 87 41`.\nVersion $ 10 $: `59 46 14 87 91`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】可持久化线段树 1（可持久化数组）", "background": "2021.9.18 增添一组 hack 数据 by @panyf。\n\n标题即题意。\n\n有了可持久化数组，便可以实现很多衍生的可持久化功能。（例如：可持久化并查集）", "description": "如题，你需要维护这样的一个长度为 $ N $ 的数组，支持如下两种操作：\n\n\n1. 在某个历史版本上修改某一个位置上的值。\n\n2. 访问某个历史版本上的某一位置的值。\n\n\n此外，每进行一次操作，就会生成一个新的版本。版本编号即为当前操作的编号（从 $1$ 开始编号，版本 $0$ 表示初始状态数组）。\n\n**对于操作 $2$，即为生成一个完全一样的版本，不作任何改动**。即，询问生成的版本是询问所访问的那个版本的复制。", "inputFormat": "输入的第一行包含两个正整数 $ N, M $，分别表示数组的长度和操作的个数。\n\n第二行包含 $ N $ 个整数，依次为初始状态下数组各位的值（依次为 $ a_i $，$ 1 \\leq i \\leq N $）。\n\n接下来 $ M $ 行每行包含 $3$ 或 $4$ 个整数，代表两种操作之一（设当前是第 $i$ 次操作）：\n\n1. 对于操作 $1$，格式为 `v 1 p c`，即为在版本 $ v $ 的基础上，将 $ a_{p} $ 修改为 $c$。\n\n2. 对于操作 $2$，格式为 `v 2 p`，即访问版本 $ v $ 中的 $ a_{p} $ 的值，注意：**生成一样版本的对象应为 $v$**。", "outputFormat": "输出包含若干行，依次为每个操作 $2$ 的结果。", "hint": "### 数据规模\n\n对于 $30\\%$ 的数据，$ 1 \\leq N, M \\leq {10}^3 $。\n\n对于 $50\\%$ 的数据，$ 1 \\leq N, M \\leq {10}^4 $。\n\n对于 $70\\%$ 的数据，$ 1 \\leq N, M \\leq {10}^5 $。\n\n对于 $100\\%$ 的数据：\n\n- $ 1 \\leq N, M \\leq {10}^6$；\n- $1 \\leq p \\leq N$；\n- 设当前是第 $x$ 次操作，$0 \\leq v < x$；\n- $-{10}^9 \\leq a_i,c  \\leq {10}^9$。\n\n### 样例说明\n\n所有操作结束后，总共生成了 $11$ 个版本，编号为 $0 \\sim 10$，依次为：\n\n版本 $0$：`59 46 14 87 41`，\n\n版本 $1$：`59 46 14 87 41`，\n\n版本 $2$：`14 46 14 87 41`，\n\n版本 $3$：`57 46 14 87 41`，\n\n版本 $4$：`88 46 14 87 41`，\n\n版本 $5$：`88 46 14 87 41`，\n\n版本 $6$：`59 46 14 87 41`，\n\n版本 $7$：`59 46 14 87 41`，\n\n版本 $8$：`88 46 14 87 41`，\n\n版本 $9$：`14 46 14 87 41`，\n\n版本 $10$：`59 46 14 87 91`。", "locale": "zh-CN"}}}
{"pid": "P3920", "type": "P", "difficulty": 7, "samples": [["0\n5\n0 0 6\n1 2 4\n0 9 4\n0 5 5\n0 2 4\n", "0\n1\n2\n4\n7\n"]], "limits": {"time": [12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "点分治", "平衡树", "分治", "WC"], "title": "[WC2014] 紫荆花之恋", "background": null, "description": "强强和萌萌是一对好朋友。有一天他们在外面闲逛，突然看到前方有一棵紫荆树。这已经是紫荆花飞舞的季节了，无数的花瓣以肉眼可见的速度从紫荆树上长了出来。\n\n仔细看看的话，这个大树实际上是一个带权树。每个时刻它会长出一个新的叶子节点，每个节点上有一个可爱的小精灵，新长出的节点上也会同时出现一个新的小精灵。小精灵是很萌但是也很脆弱的生物，每个小精灵 $i$ 都有一个感受能力值 $r_i$，小精灵 $i,j$ 成为朋友当且仅当在树上 $i$ 和 $j$ 的距离 $\\operatorname{dist}(i,j) \\leq r_i+r_j$，其中 $\\operatorname{dist}(i,j)$ 表示在这个树上从 $i$ 到 $j$ 的唯一路径上所有边的边权和。\n\n强强和萌萌很好奇每次新长出一个叶子节点之后，这个树上总共有几对朋友。\n\n\n我们假定这个树一开始为空，节点按照加入的顺序从 $1$ 开始编号。由于强强非常好奇，你必须在他每次出现新结点后马上给出总共的朋友对数，不能拖延哦。", "inputFormat": "第一行包含一个整数，表示测试点编号。\n\n第二行包含一个正整数 $n$，表示总共要加入的节点数。\n\n我们令加入节点前的总共朋友对数是 $last\\_ans$，在一开始时它的值为 $0$。\n\n接下来 $n$ 行中第 $i$ 行有三个非负整数 $a_i,c_i,r_i$，表示结点 $i$ 的父节点的编号为 $a_i \\oplus (last\\_ans  \\bmod  10^9)$（其中 $\\oplus$ 表示异或，数据保证这样操作后得到的结果介于 $1$ 到 $i−1$ 之间），与父结点之间的边权为 $c_i$，节点 $i$ 上小精灵的感受能力值为 $r_i$。\n\n注意 $a_1=c_1=0$，表示 $1$ 号节点是根结点，对于 $i>1$，父节点的编号至少为 $1$。", "outputFormat": "包含 $n$ 行，每行输出 $1$ 个整数，表示加入第 $i$ 个点之后，树上有几对 friends。", "hint": "所有数据均满足 $1 \\leq c_i \\leq 10^4$，$a_i \\leq 2\\times 10^9$，$r_i \\leq 10^9$。\n\n| 测试点编号       | 约定                                                         |\n| :----------------: | :------------------------------------------------------------: |\n| $1,2$            | $n \\leq 100$                                                 |\n| $3,4$            | $n \\leq 1000$                                                |\n| $5,6,7,8$        | $n \\leq 10^5$，节点 $1$ 最多有两个子节点，其他节点最多有一个子节点 |\n| $9,10$           | $n \\leq 10^5$，$r_i \\leq 10$                                 |\n| $11,12$          | $n \\leq 10^5$，树是随机生成的                                |\n| $13,14,15$       | $n \\leq 7\\times 10^4$                                        |\n| $16,17,18,19,20$ | $n \\leq 10^5$                                                |", "locale": "zh-CN", "translations": {"en": {"title": "[WC2014] Love of the Bauhinia", "background": "", "description": "Qiangqiang and Mengmeng are good friends. One day while strolling outside, they suddenly saw a bauhinia tree ahead. It was the season when bauhinia blossoms flutter, and countless petals were growing from the tree at a speed visible to the naked eye.\n\nLooking closely, this big tree is actually a weighted tree. At each moment it grows a new leaf node. There is a cute little spirit on every node, and a new spirit also appears on each newly grown node. Spirits are adorable but fragile creatures. Each spirit $i$ has a sensitivity value $r_i$. Spirits $i$ and $j$ become friends if and only if their distance on the tree satisfies $\\operatorname{dist}(i,j) \\leq r_i + r_j$, where $\\operatorname{dist}(i,j)$ denotes the sum of edge weights along the unique path from $i$ to $j$ on this tree.\n\nQiangqiang and Mengmeng are curious: after each new leaf node appears, how many pairs of friends are there in total on the tree?\n\nWe assume the tree is initially empty, and nodes are numbered from $1$ in the order they are added. Since Qiangqiang is very curious, you must output the total number of friend pairs immediately after each new node appears, without delay.", "inputFormat": "The first line contains an integer representing the test point ID.\n\nThe second line contains a positive integer $n$, the total number of nodes to be added.\n\nLet $last\\_ans$ be the total number of friend pairs before adding the current node, with initial value $0$.\n\nIn each of the next $n$ lines, the $i$-th line contains three non-negative integers $a_i, c_i, r_i$, meaning that the parent ID of node $i$ is $a_i \\oplus (last\\_ans \\bmod 10^9)$ (where $\\oplus$ denotes XOR; the data guarantees that the result after this operation lies between $1$ and $i-1$ inclusive), the edge weight to its parent is $c_i$, and the sensitivity of the spirit on node $i$ is $r_i$.\n\nNote that $a_1 = c_1 = 0$, meaning node $1$ is the root. For $i > 1$, the parent ID is at least $1$.", "outputFormat": "Output $n$ lines. The $i$-th line contains one integer: the number of pairs of friends in the tree after adding node $i$.", "hint": "All data satisfy $1 \\leq c_i \\leq 10^4$, $a_i \\leq 2 \\times 10^9$, and $r_i \\leq 10^9$.\n\n| Test point ID | Assumption                                                    |\n| :-----------: | :-----------------------------------------------------------: |\n|    $1,2$      | $n \\leq 100$                                                 |\n|    $3,4$      | $n \\leq 1000$                                                |\n|  $5,6,7,8$    | $n \\leq 10^5$, node $1$ has at most two children, other nodes have at most one child |\n|   $9,10$      | $n \\leq 10^5$, $r_i \\leq 10$                                 |\n|  $11,12$      | $n \\leq 10^5$, the tree is generated randomly                |\n| $13,14,15$    | $n \\leq 7 \\times 10^4$                                       |\n| $16,17,18,19,20$ | $n \\leq 10^5$                                             |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2014] 紫荆花之恋", "background": null, "description": "强强和萌萌是一对好朋友。有一天他们在外面闲逛，突然看到前方有一棵紫荆树。这已经是紫荆花飞舞的季节了，无数的花瓣以肉眼可见的速度从紫荆树上长了出来。\n\n仔细看看的话，这个大树实际上是一个带权树。每个时刻它会长出一个新的叶子节点，每个节点上有一个可爱的小精灵，新长出的节点上也会同时出现一个新的小精灵。小精灵是很萌但是也很脆弱的生物，每个小精灵 $i$ 都有一个感受能力值 $r_i$，小精灵 $i,j$ 成为朋友当且仅当在树上 $i$ 和 $j$ 的距离 $\\operatorname{dist}(i,j) \\leq r_i+r_j$，其中 $\\operatorname{dist}(i,j)$ 表示在这个树上从 $i$ 到 $j$ 的唯一路径上所有边的边权和。\n\n强强和萌萌很好奇每次新长出一个叶子节点之后，这个树上总共有几对朋友。\n\n\n我们假定这个树一开始为空，节点按照加入的顺序从 $1$ 开始编号。由于强强非常好奇，你必须在他每次出现新结点后马上给出总共的朋友对数，不能拖延哦。", "inputFormat": "第一行包含一个整数，表示测试点编号。\n\n第二行包含一个正整数 $n$，表示总共要加入的节点数。\n\n我们令加入节点前的总共朋友对数是 $last\\_ans$，在一开始时它的值为 $0$。\n\n接下来 $n$ 行中第 $i$ 行有三个非负整数 $a_i,c_i,r_i$，表示结点 $i$ 的父节点的编号为 $a_i \\oplus (last\\_ans  \\bmod  10^9)$（其中 $\\oplus$ 表示异或，数据保证这样操作后得到的结果介于 $1$ 到 $i−1$ 之间），与父结点之间的边权为 $c_i$，节点 $i$ 上小精灵的感受能力值为 $r_i$。\n\n注意 $a_1=c_1=0$，表示 $1$ 号节点是根结点，对于 $i>1$，父节点的编号至少为 $1$。", "outputFormat": "包含 $n$ 行，每行输出 $1$ 个整数，表示加入第 $i$ 个点之后，树上有几对 friends。", "hint": "所有数据均满足 $1 \\leq c_i \\leq 10^4$，$a_i \\leq 2\\times 10^9$，$r_i \\leq 10^9$。\n\n| 测试点编号       | 约定                                                         |\n| :----------------: | :------------------------------------------------------------: |\n| $1,2$            | $n \\leq 100$                                                 |\n| $3,4$            | $n \\leq 1000$                                                |\n| $5,6,7,8$        | $n \\leq 10^5$，节点 $1$ 最多有两个子节点，其他节点最多有一个子节点 |\n| $9,10$           | $n \\leq 10^5$，$r_i \\leq 10$                                 |\n| $11,12$          | $n \\leq 10^5$，树是随机生成的                                |\n| $13,14,15$       | $n \\leq 7\\times 10^4$                                        |\n| $16,17,18,19,20$ | $n \\leq 10^5$                                                |", "locale": "zh-CN"}}}
{"pid": "P3921", "type": "P", "difficulty": 5, "samples": [["1 0 0 1\n", "1 1\n"], ["5 0 0 2\n", "3 90\n"], ["3 1 0 1\n1 2\n", "-1 0\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "洛谷原创", "O2优化", "广度优先搜索 BFS"], "title": "小学数学题", "background": "露米娅：我来先考你一道小学数学题吧！\n\n琪露诺：好！小学的题我肯定都会！", "description": "露米娅：有 $ n $ 只妖精要跨过雾之湖，由于湖边大雾弥漫，妖精们看不清湖到底有多大，不想从边上绕过去。\n\n湖上有一~~条船~~个传送器，且这个传送器每次只能载 $ r $ 只妖精跨过湖面（注意传送器可以同时把两侧的妖精分别运到对岸，但每次运送的总妖精数不能超过 $ r $）。\n\n这些妖精还很喜欢搞事，所以在任何时刻，都需要满足一些条件，其中第一种条件有 $ m_1 $ 个，第二种条件有 $ m_2 $ 个。\n\n第一种条件形如 妖精 $ a $ 和妖精 $ b $ 必须要在湖的同一侧；\n\n第二种条件形如 当妖精 $ a $ 在湖的一侧时，妖精 $ b $ 和妖精 $ c $ 不能同时在湖的另一侧。\n\n\n现在给出这些条件，求：\n\n1. 至少需要传送器几次才能让所有妖精到湖的对岸；\n\n2. 在保证次数最少的前提下，求过河方案数。", "inputFormat": "第一行四个整数 $ n , m_1 , m_2 , r $。\n\n接下来 $ m_1 $ 行每行两个整数 $ a , b $，代表第一种条件。\n\n接下来 $ m_2 $ 行每行三个整数 $ a , b , c $， 代表第二种条件。", "outputFormat": "两个整数，分别为最少使用传送器次数和方案数，用空格分隔。\n\n若无法全部过河，输出 `-1 0`。", "hint": "对于 $ 30 \\% $ 的数据， $ n \\leq 10 $；\n\n对于另外 $ 10 \\% $ 的数据， $ m_1 = m_2 = 0 $；\n\n对于 $ 100 \\% $ 的数据， $ a,b,c \\leq n \\leq 15 $， $ m_1 , m_2 \\leq 50 $， $ r \\leq 10^9 $。\n\n\n请不要相信洛谷评测机的速度，如果得了 $80$ 分以上，可以等人少的时候再交一次。但如果得了 $60$ 分以下，说明可能写的不是正解，就不要再虐萌萌哒评测机啦", "locale": "zh-CN", "translations": {"en": {"title": "Primary School Math Problem", "background": "Rumia: Let me test you with a primary school math problem first!\n\nCirno: Sure! I can do all primary school problems!", "description": "Rumia: There are $ n $ fairies who want to cross Mist Lake. Because the lakeside is covered in thick fog, the fairies cannot tell how big the lake is and do not want to walk around the edge.\n\nThere is a ~~boat~~ teleporter on the lake, and each time this teleporter can carry at most $ r $ fairies across the lake (note that the teleporter can simultaneously send fairies from both sides to the opposite side, but the total number moved in one operation must not exceed $ r $).\n\nThese fairies love to make trouble, so at all times the following conditions must be satisfied. There are $ m_1 $ conditions of the first type and $ m_2 $ conditions of the second type.\n\nFirst type: Fairy $ a $ and fairy $ b $ must be on the same side of the lake.\n\nSecond type: When fairy $ a $ is on one side of the lake, fairies $ b $ and $ c $ must not be simultaneously on the other side.\n\nGiven these conditions, find:\n\n1. The minimum number of times the teleporter must be used to move all fairies to the opposite shore.\n2. Under the constraint of using the minimum number of times, the number of valid crossing plans.", "inputFormat": "The first line contains four integers $ n, m_1, m_2, r $.\n\nEach of the next $ m_1 $ lines contains two integers $ a, b $, representing a condition of the first type.\n\nEach of the next $ m_2 $ lines contains three integers $ a, b, c $, representing a condition of the second type.", "outputFormat": "Output two integers: the minimum number of uses of the teleporter and the number of valid plans, separated by a space.\n\nIf it is impossible for all fairies to cross, output `-1 0`.", "hint": "- For $ 30\\% $ of the testdata, $ n \\leq 10 $.\n- For another $ 10\\% $ of the testdata, $ m_1 = m_2 = 0 $.\n- Constraints: For $ 100\\% $ of the testdata, $ a, b, c \\leq n \\leq 15 $, $ m_1, m_2 \\leq 50 $, $ r \\leq 10^9 $.\n\nPlease do not rely on the Luogu judge’s speed. If you score above $ 80 $, you can submit again when there are fewer users. But if you score below $ 60 $, it probably is not the correct solution, so please do not put extra load on the judge.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小学数学题", "background": "露米娅：我来先考你一道小学数学题吧！\n\n琪露诺：好！小学的题我肯定都会！", "description": "露米娅：有 $ n $ 只妖精要跨过雾之湖，由于湖边大雾弥漫，妖精们看不清湖到底有多大，不想从边上绕过去。\n\n湖上有一~~条船~~个传送器，且这个传送器每次只能载 $ r $ 只妖精跨过湖面（注意传送器可以同时把两侧的妖精分别运到对岸，但每次运送的总妖精数不能超过 $ r $）。\n\n这些妖精还很喜欢搞事，所以在任何时刻，都需要满足一些条件，其中第一种条件有 $ m_1 $ 个，第二种条件有 $ m_2 $ 个。\n\n第一种条件形如 妖精 $ a $ 和妖精 $ b $ 必须要在湖的同一侧；\n\n第二种条件形如 当妖精 $ a $ 在湖的一侧时，妖精 $ b $ 和妖精 $ c $ 不能同时在湖的另一侧。\n\n\n现在给出这些条件，求：\n\n1. 至少需要传送器几次才能让所有妖精到湖的对岸；\n\n2. 在保证次数最少的前提下，求过河方案数。", "inputFormat": "第一行四个整数 $ n , m_1 , m_2 , r $。\n\n接下来 $ m_1 $ 行每行两个整数 $ a , b $，代表第一种条件。\n\n接下来 $ m_2 $ 行每行三个整数 $ a , b , c $， 代表第二种条件。", "outputFormat": "两个整数，分别为最少使用传送器次数和方案数，用空格分隔。\n\n若无法全部过河，输出 `-1 0`。", "hint": "对于 $ 30 \\% $ 的数据， $ n \\leq 10 $；\n\n对于另外 $ 10 \\% $ 的数据， $ m_1 = m_2 = 0 $；\n\n对于 $ 100 \\% $ 的数据， $ a,b,c \\leq n \\leq 15 $， $ m_1 , m_2 \\leq 50 $， $ r \\leq 10^9 $。\n\n\n请不要相信洛谷评测机的速度，如果得了 $80$ 分以上，可以等人少的时候再交一次。但如果得了 $60$ 分以下，说明可能写的不是正解，就不要再虐萌萌哒评测机啦", "locale": "zh-CN"}}}
{"pid": "P3922", "type": "P", "difficulty": 7, "samples": [["1 3\n", "1\n"], ["0 1\n", "1\n"], ["1 10\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "高精度", "洛谷原创", "期望"], "title": "中学数学题", "background": "琪露诺：我知道了！答案是 $-1 \\ 0$，因为幻想乡没有传送器！\n\n露米娅：真拿你没办法。。算了，再来一道中学数学题吧\n\n说着，露米娅写下了一个数列\n\n$ 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , \\cdots , 2048 , 4096 , 8192 , 16384 , \\cdots $", "description": "露米娅：这个数列的通项公式是 $ x_n = 2^{n-1} $。\n\n那么你来求一下前 $ k+1 $ 项中有多少个第一位为 $4$ 吧（比如 $4096$）。\n\n\n输入经过“加密”，\n\n详细输入方式见【输入格式】。", "inputFormat": "一行两个正整数，$ t $ 和 $ k_0 $。\n\n若 $ t = 1 $ 说明实际的 $ k $ 就是 $ k_0 $。\n\n若 $ t = 0 $ 说明实际的 $ k $ 是 $ 10^{k_0} $。", "outputFormat": "一个整数 $ ans $ ，表示有多少个数第一位为 $4$。", "hint": "对于 $ 30\\%$ 的数据， $ k_0 \\leq 10^7, t = 1 $。\n\n对于 $70\\%$ 的数据， $ k_0 \\leq 10^9, t = 1 $。\n\n对于另外 $30\\%$ 的数据， $ k_0 \\leq 233 , t = 0 $。\n\n对于 $100\\%$ 的数据，$ k_0 \\geq 1 $。", "locale": "zh-CN", "translations": {"en": {"title": "Middle School Math Problem", "background": "Cirno: I got it! The answer is $-1 \\ 0$, because Gensokyo has no teleporter!\n\nRumia: I really can’t with you... Fine, let’s do another middle school math problem.\n\nSaying that, Rumia wrote down a sequence:\n\n$ 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , \\cdots , 2048 , 4096 , 8192 , 16384 , \\cdots $.", "description": "Rumia: The general term of this sequence is $ x_n = 2^{n-1} $.\n\nNow, find how many numbers among the first $ k+1 $ terms have the first digit $4$ (for example, $4096$).\n\nThe input is “encrypted”. See [Input Format] for details.", "inputFormat": "One line with two positive integers, $ t $ and $ k_0 $.\n\nIf $ t = 1 $, then the actual $ k $ is $ k_0 $.\n\nIf $ t = 0 $, then the actual $ k $ is $ 10^{k_0} $.", "outputFormat": "A single integer $ ans $, representing how many numbers have the first digit $4$.", "hint": "For $ 30\\% $ of the testdata, $ k_0 \\leq 10^7, \\ t = 1 $.\n\nFor $ 70\\% $ of the testdata, $ k_0 \\leq 10^9, \\ t = 1 $.\n\nFor another $ 30\\% $ of the testdata, $ k_0 \\leq 233, \\ t = 0 $.\n\nFor $ 100\\% $ of the testdata, $ k_0 \\geq 1 $.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "中学数学题", "background": "琪露诺：我知道了！答案是 $-1 \\ 0$，因为幻想乡没有传送器！\n\n露米娅：真拿你没办法。。算了，再来一道中学数学题吧\n\n说着，露米娅写下了一个数列\n\n$ 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , \\cdots , 2048 , 4096 , 8192 , 16384 , \\cdots $", "description": "露米娅：这个数列的通项公式是 $ x_n = 2^{n-1} $。\n\n那么你来求一下前 $ k+1 $ 项中有多少个第一位为 $4$ 吧（比如 $4096$）。\n\n\n输入经过“加密”，\n\n详细输入方式见【输入格式】。", "inputFormat": "一行两个正整数，$ t $ 和 $ k_0 $。\n\n若 $ t = 1 $ 说明实际的 $ k $ 就是 $ k_0 $。\n\n若 $ t = 0 $ 说明实际的 $ k $ 是 $ 10^{k_0} $。", "outputFormat": "一个整数 $ ans $ ，表示有多少个数第一位为 $4$。", "hint": "对于 $ 30\\%$ 的数据， $ k_0 \\leq 10^7, t = 1 $。\n\n对于 $70\\%$ 的数据， $ k_0 \\leq 10^9, t = 1 $。\n\n对于另外 $30\\%$ 的数据， $ k_0 \\leq 233 , t = 0 $。\n\n对于 $100\\%$ 的数据，$ k_0 \\geq 1 $。", "locale": "zh-CN"}}}
{"pid": "P3923", "type": "P", "difficulty": 7, "samples": [["2\n", "0\n0 1\n1 0\n0 0\n0 1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 2000, 3000, 1000, 2000, 2000, 1000, 1000, 2000, 1000, 2000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "洛谷原创", "提交答案", "Special Judge", "素数判断,质数,筛法", "进制", "群论", "期望"], "title": "大学数学题", "background": "琪露诺：我知道了！答案一定是1！\n\n露米娅：什么鬼啊（汗），你还是再想想去吧。。我先把最后一道题给你，这是一道大学数学题哦", "description": "露米娅：大妖精想构造一个 $ n $ 元有限域，元素用 $ 0 \\sim n - 1 $ 的整数表示。\n\n\n有限域需要满足以下条件：\n\n\n1. 有加法单位元 $ o $ ，满足对于任意元素 $ a $ ， $ o + a = a + o = a $；\n\n\n2. 对于任意元素 $ a $ ，存在加法逆元 $ a^{-1} $ ，使得 $ a + a^{-1} = a^{-1} + a = o $；\n\n\n3. 有不同于加法单位元 $ o $ 的乘法单位元 $ i $ ，满足对于任意元素 $ a $ ， $ i \\times a = a \\times i = a $；\n\n\n4. 对于任意非加法单位元元素 $ a $ ，存在乘法逆元 $ a^{-1} $ ，使得 $ a \\times a^{-1} = a^{-1} \\times a = i $；\n\n\n5. 对于任意元素 $ x $ , $ y $ ，有加法交换律，即 $ x + y = y + x  $；\n\n\n6. 对于任意元素 $ x $ , $ y $ ，有乘法交换律，即 $ x \\times y = y \\times x  $；\n\n\n7. 对于任意元素 $ x $ , $ y $ , $ z $ ，有加法结合律，即 $ ( x + y ) + z = x + ( y + z ) $；\n\n\n8. 对于任意元素 $ x $ , $ y $ , $ z $ ，有乘法结合律，即 $ ( x \\times y ) \\times z = x \\times ( y \\times z ) $；\n\n\n9. 对于任意元素 $ x $ , $ y $ , $ z $ ，有乘法分配律，即 $ ( x + y ) \\times z = x \\times z + y \\times z $。\n\n\n大妖精当然会做啦，但是他想考考你。\n\n\n在输出中加法单位元  $ o $ 即为 $ 0 $，乘法单位元  $ i $ 即为 $ 1 $。", "inputFormat": "一个正整数 $ n $（$ 2 \\leq n \\leq 350 $）。", "outputFormat": "第一行输出一个整数 $ k $ ，若存在 $ n $ 元有限域则 $ k = 0 $ ，否则 $ k = -1 $。\n\n若 $ k = 0 $ 则：\n\n1. 接下来 $ n $ 行输出一个 $ n $ 元有限域的加法表，第 $ i + 1 $ 行第 $ j + 1 $ 列上的数代表有限域中 $ i + j $ 的运算结果；\n\n2. 接下来 $ n $ 行输出一个 $ n $ 元有限域的乘法表，第 $ i + 1 $ 行第 $ j + 1 $ 列上的数代表有限域中 $ i \\times j $ 的运算结果。\n\n共输出 $ n \\times 2 + 1 $ 行。\n\nupd1: SPJ 非常严格，请不要在行末输出多余空格（答案文件末尾的换行还是会自动忽略的）\n\nupd2: 正解文件比较大，洛谷可能会一直 judging... 如果遇到这种情况请直接提交源代码", "hint": "| 测试点  |  $ n $ 的范围      | 特殊性质|\n| :-------: | :----------: | :-----------------: |\n|1  | $ n = 3 $    | $ n $ 是质数           |\n|2  | $ n = 4 $     | $ n $ 是 $ 2 $ 的整数次方 |\n|3  | $ n = 6 $     |                无            |\n|4  | $ n = 8 $     | $ n $ 是 $ 2 $ 的整数次方 |\n|5  | $ n = 9 $     |                无            |\n|6  | $ n = 19 $  | $ n $ 是质数           |\n|7  | $ n = 89 $   | $ n $ 是质数           |\n|8  | $ n = 181 $ | $ n $ 是质数           |\n|9  | $ n = 233 $ | $ n $ 是质数           |\n|10| $ n = 25 $  | $ n $ 是质数的平方|\n|11| $ n = 121 $ | $ n $ 是质数的平方|\n|12| $ n = 169 $ | $ n $ 是质数的平方|\n|13| $ n = 27 $   |                无            |\n|14| $ n = 143 $ |                无            |\n|15| $ n = 128 $ | $ n $ 是 $ 2 $ 的整数次方 |\n|16| $ n = 81 $   |                无            |\n|17| $ n = 125 $ |                无            |\n|18| $ n = 243 $ |                无            |\n|19| $ n = 256 $ | $ n $ 是 $ 2 $ 的整数次方 |\n|20| $ n = 343 $ |                无            |", "locale": "zh-CN", "translations": {"en": {"title": "University Mathematics Problem", "background": "Cirno: I got it! The answer must be 1!\n\nRumia: What the heck (sweat). You should think again... I will give you the last problem first. This is a university mathematics problem.", "description": "Rumia: The Great Fairy wants to construct a finite field of order $ n $, where the elements are represented by the integers $ 0 \\sim n - 1 $.\n\nA finite field must satisfy the following conditions:\n\n1. There exists an additive identity $ o $, such that for any element $ a $, $ o + a = a + o = a $.\n2. For any element $ a $, there exists an additive inverse $ a^{-1} $, such that $ a + a^{-1} = a^{-1} + a = o $.\n3. There exists a multiplicative identity $ i $ different from the additive identity $ o $, such that for any element $ a $, $ i \\times a = a \\times i = a $.\n4. For any element $ a $ that is not the additive identity, there exists a multiplicative inverse $ a^{-1} $, such that $ a \\times a^{-1} = a^{-1} \\times a = i $.\n5. For any elements $ x $, $ y $, addition is commutative, i.e., $ x + y = y + x $.\n6. For any elements $ x $, $ y $, multiplication is commutative, i.e., $ x \\times y = y \\times x $.\n7. For any elements $ x $, $ y $, $ z $, addition is associative, i.e., $ ( x + y ) + z = x + ( y + z ) $.\n8. For any elements $ x $, $ y $, $ z $, multiplication is associative, i.e., $ ( x \\times y ) \\times z = x \\times ( y \\times z ) $.\n9. For any elements $ x $, $ y $, $ z $, multiplication distributes over addition, i.e., $ ( x + y ) \\times z = x \\times z + y \\times z $.\n\nThe Great Fairy certainly knows how to do it, but she wants to test you.\n\nIn the output, the additive identity $ o $ is $ 0 $, and the multiplicative identity $ i $ is $ 1 $.\n\n# Description", "inputFormat": "A positive integer $ n $ ($ 2 \\leq n \\leq 350 $).", "outputFormat": "On the first line, output an integer $ k $. If a finite field of order $ n $ exists, then $ k = 0 $; otherwise $ k = -1 $.\n\nIf $ k = 0 $, then:\n\n1. Output an $ n $-by-$ n $ addition table of the finite field in the next $ n $ lines. The number in row $ i + 1 $, column $ j + 1 $ represents the result of $ i + j $ in the field.\n2. Output an $ n $-by-$ n $ multiplication table of the finite field in the following $ n $ lines. The number in row $ i + 1 $, column $ j + 1 $ represents the result of $ i \\times j $ in the field.\n\nIn total, output $ n \\times 2 + 1 $ lines.\n\nupd1: The SPJ is very strict. Do not output extra spaces at the ends of lines (the trailing newline at the end of the file will still be ignored).\n\nupd2: The official correct-answer file is large, so Luogu may keep judging... If this happens, please submit the source code directly.", "hint": "| Test point | Range of $ n $ | Special property |\n| :-------: | :----------: | :-----------------: |\n| 1 | $ n = 3 $ | $ n $ is prime |\n| 2 | $ n = 4 $ | $ n $ is an integer power of $ 2 $ |\n| 3 | $ n = 6 $ | None |\n| 4 | $ n = 8 $ | $ n $ is an integer power of $ 2 $ |\n| 5 | $ n = 9 $ | None |\n| 6 | $ n = 19 $ | $ n $ is prime |\n| 7 | $ n = 89 $ | $ n $ is prime |\n| 8 | $ n = 181 $ | $ n $ is prime |\n| 9 | $ n = 233 $ | $ n $ is prime |\n| 10 | $ n = 25 $ | $ n $ is a square of a prime |\n| 11 | $ n = 121 $ | $ n $ is a square of a prime |\n| 12 | $ n = 169 $ | $ n $ is a square of a prime |\n| 13 | $ n = 27 $ | None |\n| 14 | $ n = 143 $ | None |\n| 15 | $ n = 128 $ | $ n $ is an integer power of $ 2 $ |\n| 16 | $ n = 81 $ | None |\n| 17 | $ n = 125 $ | None |\n| 18 | $ n = 243 $ | None |\n| 19 | $ n = 256 $ | $ n $ is an integer power of $ 2 $ |\n| 20 | $ n = 343 $ | None |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "大学数学题", "background": "琪露诺：我知道了！答案一定是1！\n\n露米娅：什么鬼啊（汗），你还是再想想去吧。。我先把最后一道题给你，这是一道大学数学题哦", "description": "露米娅：大妖精想构造一个 $ n $ 元有限域，元素用 $ 0 \\sim n - 1 $ 的整数表示。\n\n\n有限域需要满足以下条件：\n\n\n1. 有加法单位元 $ o $ ，满足对于任意元素 $ a $ ， $ o + a = a + o = a $；\n\n\n2. 对于任意元素 $ a $ ，存在加法逆元 $ a^{-1} $ ，使得 $ a + a^{-1} = a^{-1} + a = o $；\n\n\n3. 有不同于加法单位元 $ o $ 的乘法单位元 $ i $ ，满足对于任意元素 $ a $ ， $ i \\times a = a \\times i = a $；\n\n\n4. 对于任意非加法单位元元素 $ a $ ，存在乘法逆元 $ a^{-1} $ ，使得 $ a \\times a^{-1} = a^{-1} \\times a = i $；\n\n\n5. 对于任意元素 $ x $ , $ y $ ，有加法交换律，即 $ x + y = y + x  $；\n\n\n6. 对于任意元素 $ x $ , $ y $ ，有乘法交换律，即 $ x \\times y = y \\times x  $；\n\n\n7. 对于任意元素 $ x $ , $ y $ , $ z $ ，有加法结合律，即 $ ( x + y ) + z = x + ( y + z ) $；\n\n\n8. 对于任意元素 $ x $ , $ y $ , $ z $ ，有乘法结合律，即 $ ( x \\times y ) \\times z = x \\times ( y \\times z ) $；\n\n\n9. 对于任意元素 $ x $ , $ y $ , $ z $ ，有乘法分配律，即 $ ( x + y ) \\times z = x \\times z + y \\times z $。\n\n\n大妖精当然会做啦，但是他想考考你。\n\n\n在输出中加法单位元  $ o $ 即为 $ 0 $，乘法单位元  $ i $ 即为 $ 1 $。", "inputFormat": "一个正整数 $ n $（$ 2 \\leq n \\leq 350 $）。", "outputFormat": "第一行输出一个整数 $ k $ ，若存在 $ n $ 元有限域则 $ k = 0 $ ，否则 $ k = -1 $。\n\n若 $ k = 0 $ 则：\n\n1. 接下来 $ n $ 行输出一个 $ n $ 元有限域的加法表，第 $ i + 1 $ 行第 $ j + 1 $ 列上的数代表有限域中 $ i + j $ 的运算结果；\n\n2. 接下来 $ n $ 行输出一个 $ n $ 元有限域的乘法表，第 $ i + 1 $ 行第 $ j + 1 $ 列上的数代表有限域中 $ i \\times j $ 的运算结果。\n\n共输出 $ n \\times 2 + 1 $ 行。\n\nupd1: SPJ 非常严格，请不要在行末输出多余空格（答案文件末尾的换行还是会自动忽略的）\n\nupd2: 正解文件比较大，洛谷可能会一直 judging... 如果遇到这种情况请直接提交源代码", "hint": "| 测试点  |  $ n $ 的范围      | 特殊性质|\n| :-------: | :----------: | :-----------------: |\n|1  | $ n = 3 $    | $ n $ 是质数           |\n|2  | $ n = 4 $     | $ n $ 是 $ 2 $ 的整数次方 |\n|3  | $ n = 6 $     |                无            |\n|4  | $ n = 8 $     | $ n $ 是 $ 2 $ 的整数次方 |\n|5  | $ n = 9 $     |                无            |\n|6  | $ n = 19 $  | $ n $ 是质数           |\n|7  | $ n = 89 $   | $ n $ 是质数           |\n|8  | $ n = 181 $ | $ n $ 是质数           |\n|9  | $ n = 233 $ | $ n $ 是质数           |\n|10| $ n = 25 $  | $ n $ 是质数的平方|\n|11| $ n = 121 $ | $ n $ 是质数的平方|\n|12| $ n = 169 $ | $ n $ 是质数的平方|\n|13| $ n = 27 $   |                无            |\n|14| $ n = 143 $ |                无            |\n|15| $ n = 128 $ | $ n $ 是 $ 2 $ 的整数次方 |\n|16| $ n = 81 $   |                无            |\n|17| $ n = 125 $ |                无            |\n|18| $ n = 243 $ |                无            |\n|19| $ n = 256 $ | $ n $ 是 $ 2 $ 的整数次方 |\n|20| $ n = 343 $ |                无            |", "locale": "zh-CN"}}}
{"pid": "P3924", "type": "P", "difficulty": 5, "samples": [["8 2 1\n1 2 3 4 5 6 7 8\n1 3 4\n1 8 2\n", "90\n120"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "洛谷原创", "O2优化", "前缀和", "期望", "洛谷月赛"], "title": "康娜的线段树", "background": "", "description": "小林是个程序媛，不可避免地康娜对这种人类的“魔法”产生了浓厚的兴趣，于是小林开始教她OI。\n\n ![](https://cdn.luogu.com.cn/upload/pic/8043.png) \n\n今天康娜学习了一种叫做线段树的神奇魔法，这种魔法可以维护一段区间的信息，是非常厉害的东西。康娜试着写了一棵维护区间和的线段树。由于她不会打标记，因此所有的区间加操作她都是暴力修改的。具体的代码如下：\n\n```cpp\nstruct Segment_Tree{\n#define lson (o<<1)\n#define rson (o<<1|1)\n    int sumv[N<<2],minv[N<<2];\n    inline void pushup(int o){sumv[o]=sumv[lson]+sumv[rson];}\n    inline void build(int o,int l,int r){\n        if(l==r){sumv[o]=a[l];return;}\n        int mid=(l+r)>>1;\n        build(lson,l,mid);build(rson,mid+1,r);\n        pushup(o);\n    }\n    inline void change(int o,int l,int r,int q,int v){\n        if(l==r){sumv[o]+=v;return;}\n        int mid=(l+r)>>1;\n        if(q<=mid)change(lson,l,mid,q,v);\n        else change(rson,mid+1,r,q,v);\n        pushup(o);\n    }\n}T; \n```\n\n在修改时，她会这么写：\n\n```cpp\nfor(int i=l;i<=r;i++)T.change(1,1,n,i,addv);\n```\n显然，这棵线段树每个节点有一个值，为该节点管辖区间的区间和。\n\n康娜是个爱思考的孩子，于是她突然想到了一个问题：\n\n如果每次在线段树区间加操作做完后，从根节点开始等概率的选择一个子节点进入，直到进入叶子结点为止，将一路经过的节点权值累加，最后能得到的期望值是多少？\n\n康娜每次会给你一个值 $qwq$ ，保证你求出的概率乘上 $qwq$ 是一个整数。\n\n这个问题太简单了，以至于聪明的康娜一下子就秒了。\n\n现在她想问问你，您会不会做这个题呢？\n", "inputFormat": "第一行整数 $n,m,qwq$ 表示线段树维护的原序列的长度，询问次数，分母。\n\n第二行 $n$ 个数，表示原序列。\n\n接下来 $m$ 行，每行三个数 $l,r,x$ 表示对区间$[l,r]$ 加上 $x$\n", "outputFormat": "共 $m$ 行，表示期望的权值和乘上qwq结果。\n", "hint": "对于30%的数据，保证 $1 \\leq n,m \\leq 100$\n\n对于70%的数据，保证 $1 \\leq n,m, \\leq 10^{5}$\n\n对于100%的数据，保证$1 \\leq n,m \\leq 10^6 $\n\n$-1000 \\leq a_i,x \\leq 1000$\n", "locale": "zh-CN", "translations": {"en": {"title": "Kanna's Segment Tree", "background": "", "description": "Kobayashi is a programmer, and naturally Kanna becomes very interested in this human “magic,” so Kobayashi starts teaching her OI.\n\n![](https://cdn.luogu.com.cn/upload/pic/8043.png)\n\nToday Kanna learned a magical structure called a segment tree, which can maintain information over an interval and is very powerful. Kanna tried to write a segment tree that maintains the sum over intervals. Since she doesn’t know how to use lazy propagation, she performs each range add operation by brute-force point updates. The specific code is as follows:\n\n```cpp\nstruct Segment_Tree{\n#define lson (o<<1)\n#define rson (o<<1|1)\n    int sumv[N<<2],minv[N<<2];\n    inline void pushup(int o){sumv[o]=sumv[lson]+sumv[rson];}\n    inline void build(int o,int l,int r){\n        if(l==r){sumv[o]=a[l];return;}\n        int mid=(l+r)>>1;\n        build(lson,l,mid);build(rson,mid+1,r);\n        pushup(o);\n    }\n    inline void change(int o,int l,int r,int q,int v){\n        if(l==r){sumv[o]+=v;return;}\n        int mid=(l+r)>>1;\n        if(q<=mid)change(lson,l,mid,q,v);\n        else change(rson,mid+1,r,q,v);\n        pushup(o);\n    }\n}T; \n```\n\nWhen modifying, she writes:\n\n```cpp\nfor(int i=l;i<=r;i++)T.change(1,1,n,i,addv);\n```\nObviously, each node of this segment tree stores the sum of the interval it governs.\n\nKanna is thoughtful, and she suddenly came up with a question:\n\nAfter each range add operation on the segment tree is completed, starting from the root, at each internal node choose one child with equal probability and continue until reaching a leaf node. Sum the values of all nodes along the path. What is the expected value of this sum?\n\nEach time, Kanna will give you a value $qwq$, and it is guaranteed that the expected value multiplied by $qwq$ is an integer.\n\nThis problem is so easy that clever Kanna solved it in an instant.\n\nNow she wonders, can you solve it too?", "inputFormat": "The first line contains integers $n, m, qwq$, which denote the length of the original sequence, the number of operations, and the denominator used for output.\n\nThe second line contains $n$ integers, the original sequence.\n\nThe next $m$ lines each contain three integers $l, r, x$, meaning add $x$ to the interval $[l, r]$.", "outputFormat": "Output $m$ lines. Each line is the expected path-sum value multiplied by $qwq$.", "hint": "Constraints:\n- For 30% of the testdata, $1 \\leq n, m \\leq 100$.\n- For 70% of the testdata, $1 \\leq n, m \\leq 10^{5}$.\n- For 100% of the testdata, $1 \\leq n, m \\leq 10^{6}$.\n- $-1000 \\leq a_i, x \\leq 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "康娜的线段树", "background": "", "description": "小林是个程序媛，不可避免地康娜对这种人类的“魔法”产生了浓厚的兴趣，于是小林开始教她OI。\n\n ![](https://cdn.luogu.com.cn/upload/pic/8043.png) \n\n今天康娜学习了一种叫做线段树的神奇魔法，这种魔法可以维护一段区间的信息，是非常厉害的东西。康娜试着写了一棵维护区间和的线段树。由于她不会打标记，因此所有的区间加操作她都是暴力修改的。具体的代码如下：\n\n```cpp\nstruct Segment_Tree{\n#define lson (o<<1)\n#define rson (o<<1|1)\n    int sumv[N<<2],minv[N<<2];\n    inline void pushup(int o){sumv[o]=sumv[lson]+sumv[rson];}\n    inline void build(int o,int l,int r){\n        if(l==r){sumv[o]=a[l];return;}\n        int mid=(l+r)>>1;\n        build(lson,l,mid);build(rson,mid+1,r);\n        pushup(o);\n    }\n    inline void change(int o,int l,int r,int q,int v){\n        if(l==r){sumv[o]+=v;return;}\n        int mid=(l+r)>>1;\n        if(q<=mid)change(lson,l,mid,q,v);\n        else change(rson,mid+1,r,q,v);\n        pushup(o);\n    }\n}T; \n```\n\n在修改时，她会这么写：\n\n```cpp\nfor(int i=l;i<=r;i++)T.change(1,1,n,i,addv);\n```\n显然，这棵线段树每个节点有一个值，为该节点管辖区间的区间和。\n\n康娜是个爱思考的孩子，于是她突然想到了一个问题：\n\n如果每次在线段树区间加操作做完后，从根节点开始等概率的选择一个子节点进入，直到进入叶子结点为止，将一路经过的节点权值累加，最后能得到的期望值是多少？\n\n康娜每次会给你一个值 $qwq$ ，保证你求出的概率乘上 $qwq$ 是一个整数。\n\n这个问题太简单了，以至于聪明的康娜一下子就秒了。\n\n现在她想问问你，您会不会做这个题呢？\n", "inputFormat": "第一行整数 $n,m,qwq$ 表示线段树维护的原序列的长度，询问次数，分母。\n\n第二行 $n$ 个数，表示原序列。\n\n接下来 $m$ 行，每行三个数 $l,r,x$ 表示对区间$[l,r]$ 加上 $x$\n", "outputFormat": "共 $m$ 行，表示期望的权值和乘上qwq结果。\n", "hint": "对于30%的数据，保证 $1 \\leq n,m \\leq 100$\n\n对于70%的数据，保证 $1 \\leq n,m, \\leq 10^{5}$\n\n对于100%的数据，保证$1 \\leq n,m \\leq 10^6 $\n\n$-1000 \\leq a_i,x \\leq 1000$\n", "locale": "zh-CN"}}}
{"pid": "P3925", "type": "P", "difficulty": 6, "samples": [["5\n5 3\n1 2\n1 5\n4 5\n3 9 10 4 7 \n", "189\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["线段树", "树状数组", "洛谷原创", "O2优化", "树链剖分", "洛谷月赛"], "title": "aaa 被​​​​​​​​​​续", "background": "HansBug 持续无聊 ing……", "description": "由于 aaa 没有完成 HansBug 的任务。所以 HansBug 开始计划着如何续 aaa。\n\n现在 HansBug 手里有 $N$ 个 aaa，每个 aaa 有一个码力值。一共存在 $N - 1$ 条连接两个 aaa 的边，故这 $N$ 个 aaa 构成一棵**有根树**，根为 1 号 aaa。\n\n现在 HansBug 想要续了这 $N$ 个 aaa。HansBug 所采用的策略是，对于第 $i$ 个 aaa，先让他和他的各级子 aaa 们~~乖乖♂站好~~成一队，然后依次续掉。\n\n经过长期对于 aaa 码力值的研究，HansBug 发现，**对于每一队 aaa**，设有 $n$ 个，码力值依次为 $v_i$，则续了队伍里的第 $i$ 个 aaa 所能获得的码力值为 $v_1 + v_2 + \\cdots + v_i$。\n\n然而，aaa 之间的关系树相当的复杂，HansBug 的智商早已不够用，于是这个任务就交给了你。不过 HansBug 知道，任何一个 aaa 都不会有超过 5 个的直接子 aaa。\n\nHansBug 想要知道在每次排♂队方法最优的情况下，续了这些 aaa 最多可以获得的码力值，~~事成之后分给你 100000 % 10 点码力值~~。", "inputFormat": "第一行包含一个正整数 $N$，表示 aaa 的个数。\n\n接下来 $N-1$ 行，每行包含两个正整数 $u, v$，代表第 $u$ 个 aaa 和第 $v$ 个 aaa 之间存在从属关系（最高级别的 aaa 编号为 $1$）。\n\n最后一行包含 $N$ 个非负整数，依次代表第 $i$ 个 aaa 的码力值。", "outputFormat": "输出包含一个整数，代表 HansBug 续掉全部的 aaa 之后最多能获得的码力值。\n\n**由于结果较大，所以请对 $\\bm{1000000007}$（$\\bm{{10} ^ 9 + 7}$）取模。**", "hint": "### 样例解释\n\n ![](https://cdn.luogu.com.cn/upload/pic/7980.png) \n\n故续了 5 个 aaa 所得的最大总码力值为：$118 + 9 + 10 + 4 + 48 = 189$。\n\n**对 $\\bm{1000000007}$ 取模后得到答案 $\\bm{189\n}$。**\n\n\n### 数据范围\n\n对于 $30\\%$ 的数据：$1 \\leq N \\leq 3 \\times {10}^3$；\n\n对于 $50\\%$ 的数据：$1 \\leq N \\leq 2 \\times {10}^4$；\n\n对于 $70\\%$ 的数据：$1 \\leq N \\leq {10}^5$；\n\n对于 $100\\%$ 的数据：$1 \\leq N \\leq 5 \\times {10}^5$。\n\n对于每一个 aaa 的码力值 $a_i$，保证 $0 \\leq a_i \\leq {10}^8$。", "locale": "zh-CN", "translations": {"en": {"title": "aaa Gets \"Xu\"-ed", "background": "HansBug keeps being bored...", "description": "Because aaa did not finish HansBug's task, HansBug starts planning how to \"xu\" aaa.\n\nNow HansBug has $N$ aaa, each with a power value. There are $N - 1$ edges connecting pairs of aaa, so these $N$ aaa form a **rooted tree**, rooted at aaa $1$.\n\nHansBug wants to \"xu\" these $N$ aaa. His strategy is: for the $i$-th aaa, first let him and all of his descendant aaa ~~stand obediently ♂~~ in a queue, then \"xu\" them one by one.\n\nAfter long research on aaa power values, HansBug found that, for each such queue of aaa, suppose there are $n$ of them with power values $v_i$; then the power value gained from \"xu\"-ing the $i$-th aaa in the queue is $v_1 + v_2 + \\cdots + v_i$.\n\nHowever, the relationship tree among aaa is quite complex, and HansBug has run out of IQ, so this task is handed over to you. But HansBug does know that no aaa has more than $5$ direct child aaa.\n\nHansBug wants to know, with the optimal queuing method each time, the maximum total power value obtainable after \"xu\"-ing all these aaa, ~~and then give you $100000 \\% 10$ points of power value as a reward~~.", "inputFormat": "The first line contains a positive integer $N$, the number of aaa.\n\nThe next $N - 1$ lines each contain two positive integers $u, v$, indicating that there is a subordinate relationship between the $u$-th aaa and the $v$-th aaa (the highest-level aaa is numbered $1$).\n\nThe last line contains $N$ non-negative integers, where the $i$-th number is the power value of the $i$-th aaa.", "outputFormat": "Output a single integer, the maximum total power value HansBug can obtain after \"xu\"-ing all aaa.\n\nSince the result can be large, take it modulo $\\bm{1000000007}$ ($\\bm{{10} ^ 9 + 7}$).", "hint": "### Sample Explanation\n\n![](https://cdn.luogu.com.cn/upload/pic/7980.png)\n\nTherefore, the maximum total power value from \"xu\"-ing $5$ aaa is $118 + 9 + 10 + 4 + 48 = 189$.\n\nAfter taking modulo $\\bm{1000000007}$, the answer is $\\bm{189}$.\n\n### Constraints\n\nFor $30\\%$ of the testdata: $1 \\leq N \\leq 3 \\times {10}^3$.\n\nFor $50\\%$ of the testdata: $1 \\leq N \\leq 2 \\times {10}^4$.\n\nFor $70\\%$ of the testdata: $1 \\leq N \\leq {10}^5$.\n\nFor $100\\%$ of the testdata: $1 \\leq N \\leq 5 \\times {10}^5$.\n\nFor each aaa's power value $a_i$, it is guaranteed that $0 \\leq a_i \\leq {10}^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "aaa 被​​​​​​​​​​续", "background": "HansBug 持续无聊 ing……", "description": "由于 aaa 没有完成 HansBug 的任务。所以 HansBug 开始计划着如何续 aaa。\n\n现在 HansBug 手里有 $N$ 个 aaa，每个 aaa 有一个码力值。一共存在 $N - 1$ 条连接两个 aaa 的边，故这 $N$ 个 aaa 构成一棵**有根树**，根为 1 号 aaa。\n\n现在 HansBug 想要续了这 $N$ 个 aaa。HansBug 所采用的策略是，对于第 $i$ 个 aaa，先让他和他的各级子 aaa 们~~乖乖♂站好~~成一队，然后依次续掉。\n\n经过长期对于 aaa 码力值的研究，HansBug 发现，**对于每一队 aaa**，设有 $n$ 个，码力值依次为 $v_i$，则续了队伍里的第 $i$ 个 aaa 所能获得的码力值为 $v_1 + v_2 + \\cdots + v_i$。\n\n然而，aaa 之间的关系树相当的复杂，HansBug 的智商早已不够用，于是这个任务就交给了你。不过 HansBug 知道，任何一个 aaa 都不会有超过 5 个的直接子 aaa。\n\nHansBug 想要知道在每次排♂队方法最优的情况下，续了这些 aaa 最多可以获得的码力值，~~事成之后分给你 100000 % 10 点码力值~~。", "inputFormat": "第一行包含一个正整数 $N$，表示 aaa 的个数。\n\n接下来 $N-1$ 行，每行包含两个正整数 $u, v$，代表第 $u$ 个 aaa 和第 $v$ 个 aaa 之间存在从属关系（最高级别的 aaa 编号为 $1$）。\n\n最后一行包含 $N$ 个非负整数，依次代表第 $i$ 个 aaa 的码力值。", "outputFormat": "输出包含一个整数，代表 HansBug 续掉全部的 aaa 之后最多能获得的码力值。\n\n**由于结果较大，所以请对 $\\bm{1000000007}$（$\\bm{{10} ^ 9 + 7}$）取模。**", "hint": "### 样例解释\n\n ![](https://cdn.luogu.com.cn/upload/pic/7980.png) \n\n故续了 5 个 aaa 所得的最大总码力值为：$118 + 9 + 10 + 4 + 48 = 189$。\n\n**对 $\\bm{1000000007}$ 取模后得到答案 $\\bm{189\n}$。**\n\n\n### 数据范围\n\n对于 $30\\%$ 的数据：$1 \\leq N \\leq 3 \\times {10}^3$；\n\n对于 $50\\%$ 的数据：$1 \\leq N \\leq 2 \\times {10}^4$；\n\n对于 $70\\%$ 的数据：$1 \\leq N \\leq {10}^5$；\n\n对于 $100\\%$ 的数据：$1 \\leq N \\leq 5 \\times {10}^5$。\n\n对于每一个 aaa 的码力值 $a_i$，保证 $0 \\leq a_i \\leq {10}^8$。", "locale": "zh-CN"}}}
{"pid": "P3926", "type": "P", "difficulty": 2, "samples": [["-10 0 2 1 3 26\n", "1"], ["-10 0 2 1 3 27", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "洛谷原创", "洛谷月赛"], "title": "SAC E#1 - 一道不可做题 Jelly", "background": "SOL君（炉石主播）和SOL菌（完美信息教室讲师）是好朋友。", "description": "SOL 君很喜欢吃蒟蒻果冻，而 SOL 菌也很喜欢蒟蒻果冻。\n\n有一天，他们在一起搓炉石，而 SOL 菌则要拿出蒟蒻果冻招待他的客人。\n\n蒟蒻果冻一般在 $a$ 度下保存在冰箱里。但是刚拿出来的时候太冰了，需要加热。SOL 菌打算用一种神奇的电炉加热蒟蒻果冻。根据观察，它有一个特点：\n\n1. 蒟蒻果冻小于 $c$ 度的时候，每 $p$ 单位时间加热 $1$ 单位温度；\n\n2. 当蒟蒻果冻等于 $c$ 度的时候，需要 $q$ 单位时间解冻（大家都知道，晶体物态变化温度不变……SOL 菌认为果冻属于晶体）；\n\n3. 当蒟蒻果冻解冻完成之后，每 $r$ 单位时间加热 $1$ 单位温度。\n\n\nSOL 想知道，将果冻加热 $x$ 单位时间后时果冻的温度。\n\n温度向下取整，也就是说，如果加热结束时不足 $p$（或 $q$）单位时间，则认为在这最后一小段时间内果冻温度没有任何变化。", "inputFormat": "输入仅包含一行，$6$ 个整数，依次为 $a,c,p,q,r,x$。", "outputFormat": "输出仅包含一个整数：即为所求温度。", "hint": "对于 $30\\%$ 的数据，$|a|, |c| \\leq 200, x \\leq 100$。\n\n对于 $60\\%$ 的数据，$|a|, |c| \\leq 2 \\times 10^9, x \\leq 100$。\n\n对于 $100\\%$ 的数据，$|a|, |c| \\leq 2 \\times 10^9, 1 \\leq x, p, q, r \\leq 10^9$。\n\n数据中可能有 $a = c$，此时算还未解冻的状态。\n\n\n提示：请使用 `long long` 数据类型。", "locale": "zh-CN", "translations": {"en": {"title": "SAC E#1 - An Impossible Problem Jelly", "background": "SOL 君 (Hearthstone streamer) and SOL 菌 (Perfect Information Classroom lecturer) are good friends.", "description": "SOL 君 likes eating konjac jelly, and SOL 菌 also likes konjac jelly.\n\nOne day, they were playing Hearthstone together, and SOL 菌 was going to serve konjac jelly to his guest.\n\nKonjac jelly is usually stored in a refrigerator at $a$ degrees. However, it is too cold right after being taken out and needs to be heated. SOL 菌 plans to heat the konjac jelly with a magical electric stove. According to observation, it has the following behavior:\n\n1. When the jelly is below $c$ degrees, it heats by $1$ degree every $p$ units of time.\n2. When the jelly is exactly $c$ degrees, it needs $q$ units of time to thaw (everyone knows that during a phase change the temperature does not change... SOL 菌 believes jelly is crystalline).\n3. After thawing is complete, it heats by $1$ degree every $r$ units of time.\n\nSOL wants to know the temperature of the jelly after heating for $x$ units of time.\n\nThe temperature is floored. That is, if the heating ends with less than $p$ (or $q$) units of time, then during this final short period the temperature does not change at all.", "inputFormat": "The input contains a single line with $6$ integers: $a, c, p, q, r, x$.", "outputFormat": "Output a single integer: the required temperature.", "hint": "For $30\\%$ of the testdata, $|a|, |c| \\leq 200$, $x \\leq 100$.\n\nFor $60\\%$ of the testdata, $|a|, |c| \\leq 2 \\times 10^9$, $x \\leq 100$.\n\nFor $100\\%$ of the testdata, $|a|, |c| \\leq 2 \\times 10^9$, $1 \\leq x, p, q, r \\leq 10^9$.\n\nThe testdata may have $a = c$, which should be considered as the not-yet-thawed state.\n\nHint: Please use the long long data type.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "SAC E#1 - 一道不可做题 Jelly", "background": "SOL君（炉石主播）和SOL菌（完美信息教室讲师）是好朋友。", "description": "SOL 君很喜欢吃蒟蒻果冻，而 SOL 菌也很喜欢蒟蒻果冻。\n\n有一天，他们在一起搓炉石，而 SOL 菌则要拿出蒟蒻果冻招待他的客人。\n\n蒟蒻果冻一般在 $a$ 度下保存在冰箱里。但是刚拿出来的时候太冰了，需要加热。SOL 菌打算用一种神奇的电炉加热蒟蒻果冻。根据观察，它有一个特点：\n\n1. 蒟蒻果冻小于 $c$ 度的时候，每 $p$ 单位时间加热 $1$ 单位温度；\n\n2. 当蒟蒻果冻等于 $c$ 度的时候，需要 $q$ 单位时间解冻（大家都知道，晶体物态变化温度不变……SOL 菌认为果冻属于晶体）；\n\n3. 当蒟蒻果冻解冻完成之后，每 $r$ 单位时间加热 $1$ 单位温度。\n\n\nSOL 想知道，将果冻加热 $x$ 单位时间后时果冻的温度。\n\n温度向下取整，也就是说，如果加热结束时不足 $p$（或 $q$）单位时间，则认为在这最后一小段时间内果冻温度没有任何变化。", "inputFormat": "输入仅包含一行，$6$ 个整数，依次为 $a,c,p,q,r,x$。", "outputFormat": "输出仅包含一个整数：即为所求温度。", "hint": "对于 $30\\%$ 的数据，$|a|, |c| \\leq 200, x \\leq 100$。\n\n对于 $60\\%$ 的数据，$|a|, |c| \\leq 2 \\times 10^9, x \\leq 100$。\n\n对于 $100\\%$ 的数据，$|a|, |c| \\leq 2 \\times 10^9, 1 \\leq x, p, q, r \\leq 10^9$。\n\n数据中可能有 $a = c$，此时算还未解冻的状态。\n\n\n提示：请使用 `long long` 数据类型。", "locale": "zh-CN"}}}
{"pid": "P3927", "type": "P", "difficulty": 4, "samples": [["10 40", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["洛谷原创", "O2优化", "素数判断,质数,筛法", "进制", "洛谷月赛"], "title": "SAC E#1 - 一道中档题 Factorial", "background": "SOL 君（炉石主播）和 SOL 菌（完美信息教室讲师）是好朋友。", "description": "SOL 君很喜欢阶乘。而 SOL 菌很喜欢研究进制。\n\n这一天，SOL 君跟 SOL 菌炫技，随口算出了 $n$ 的阶乘。\n\nSOL 菌表示不服，立刻就要算这个数在 $k$ 进制表示下末尾 $0$ 的个数。\n\n但是 SOL 菌太菜了于是请你帮忙。", "inputFormat": "每组输入仅包含一行：两个整数 $n,k$。", "outputFormat": "输出一个整数：$n!$ 在 $k$ 进制下后缀 $0$ 的个数。", "hint": "- 对于 $20\\%$ 的数据，$n \\le 1000000, k = 10$\n- 对于另外 $20\\%$ 的数据，$n \\le 20， k \\le 36$\n- 对于 $100\\%$ 的数据，$n \\le 10^{12}，k \\le 10^{12}$\n\n### update\n\n1. 每个测试点只包含一组数据；\n\n2. k 不会为 $1$；\n\n3. 现在 std 没有爆 `long long`；\n\n4. 对数据有问题联系 icy（建议大家不要面向数据编程）。", "locale": "zh-CN", "translations": {"en": {"title": "SAC E#1 - A Medium-Difficulty Problem: Factorial", "background": "SOL 君 (Hearthstone streamer) and SOL 菌 (Perfect Information Classroom instructor) are good friends.", "description": "SOL 君 likes factorials, while SOL 菌 enjoys studying number bases.\n\nOne day, SOL 君 showed off to SOL 菌 by casually computing the factorial of $n$.\n\nSOL 菌 was unconvinced and immediately wanted to compute the number of trailing zeros of this number in base $k$.\n\nHowever, SOL 菌 is not skilled enough, so he asks you for help.", "inputFormat": "Each input contains a single line with two integers $n,k$.", "outputFormat": "Output a single integer: the number of trailing zeros of $n!$ in base $k$.", "hint": "- For $20\\%$ of the testdata, $n \\le 1000000, k = 10$.\n- For another $20\\%$ of the testdata, $n \\le 20， k \\le 36$.\n- For $100\\%$ of the testdata, $n \\le 10^{12}，k \\le 10^{12}$.\n\n### Update\n\n1. Each test point contains only one test case.\n2. $k$ will not be $1$.\n3. Now the std does not overflow `long long`.\n4. If there is any problem with the testdata, contact icy (it is recommended not to code to the data).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "SAC E#1 - 一道中档题 Factorial", "background": "SOL 君（炉石主播）和 SOL 菌（完美信息教室讲师）是好朋友。", "description": "SOL 君很喜欢阶乘。而 SOL 菌很喜欢研究进制。\n\n这一天，SOL 君跟 SOL 菌炫技，随口算出了 $n$ 的阶乘。\n\nSOL 菌表示不服，立刻就要算这个数在 $k$ 进制表示下末尾 $0$ 的个数。\n\n但是 SOL 菌太菜了于是请你帮忙。", "inputFormat": "每组输入仅包含一行：两个整数 $n,k$。", "outputFormat": "输出一个整数：$n!$ 在 $k$ 进制下后缀 $0$ 的个数。", "hint": "- 对于 $20\\%$ 的数据，$n \\le 1000000, k = 10$\n- 对于另外 $20\\%$ 的数据，$n \\le 20， k \\le 36$\n- 对于 $100\\%$ 的数据，$n \\le 10^{12}，k \\le 10^{12}$\n\n### update\n\n1. 每个测试点只包含一组数据；\n\n2. k 不会为 $1$；\n\n3. 现在 std 没有爆 `long long`；\n\n4. 对数据有问题联系 icy（建议大家不要面向数据编程）。", "locale": "zh-CN"}}}
{"pid": "P3928", "type": "P", "difficulty": 6, "samples": [["6\n1 2 3 6 5 4\n5 4 3 7 8 9\n1 2 3 6 5 4\n", "6"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "树状数组", "离散化", "洛谷原创", "O2优化", "洛谷月赛"], "title": "SAC E#1 - 一道简单题 Sequence2", "background": "小强和阿米巴是好朋友。", "description": "小强喜欢数列。有一天，他心血来潮，写下了三个长度均为 $n$ 的数列。\n\n阿米巴也很喜欢数列。但是他只喜欢其中一种，波动数列。\n\n阿米巴把他的喜好告诉了小强。小强便打算找出这三个数列内的最长波动数列。\n\n也就是说，如果我们将三个数列记做 $a_{n,1},a_{n,2},a_{n,3}$，他必须要构造一个二元组序列：$(p_i,q_i)$，使得对于任何 $i>1$ 有：\n\n- $p_i>p_{i-1}$。\n\n- 若 $q_i=0$，$a_{p_i,q_i} \\ge a_{p_{i-1},q_{i-1}}$。\n\n- 若 $q_i=1$，$a_{p_i,q_i} \\le a_{p_{i-1},q_{i-1}}$。\n\n- 若 $q_i=2$，只要保持段内同向即可（就是对于连续的一段 $q_i=2$，要么都有 $a_{p_i,q_i} \\ge a_{p_{i-1},q_{i-1}}$，要么都有 $a_{p_i,q_i} \\le a_{p_{i-1},q_{i-1}}$。\n\n小强希望这个二元组序列尽可能长。\n\n提示：当 $q_i \\not = q_{i-1}$ 时，数列的增减性由 $q_i$ 而非 $q_{i-1}$ 决定。\n\n**清晰版题目描述**\n\n小强拿到一个 $3 \\times n$ 的数组，要在每一列选一个数（或者不选），满足以下条件：\n\n1. 如果在第一行选，那它必须大于等于上一个数。\n\n2. 如果在第二行选，那么必须小于等于上一个数。\n\n3. 如果在第三行选，对于连续的一段在第三行选的数，必须满足方向相同（都小于等于上一个数或者都大于等于上一个数）。", "inputFormat": "输入包含 $4$ 行。\n\n第一行一个数 $n$，表示数列长度。\n\n第 $2,3,4$ 行，每行 $n$ 个整数，分别表示三个数列。", "outputFormat": "输出仅包含一个整数，即最长波动数列的长度。", "hint": "对于 $20\\%$ 的数据，$n \\le 10$，$m \\le 1000$。\n\n对于 $60\\%$ 的数据，$n \\le 1000$，$m \\le 1000$。\n\n对于 $100\\%$ 的数据，$n \\le 10^5$，$m \\le 10^9$。\n\n其中 $m=\\max\\{|a_i|\\}$。\n\n样例解释：\n\n取第三行 $1,2,3$（增），然后取第一行 $6$（增），然后取第三行 $5,4$（减），长度为 $6$。", "locale": "zh-CN", "translations": {"en": {"title": "SAC E#1 - A Simple Problem Sequence2", "background": "Xiao Qiang and Amiba are good friends.", "description": "Xiao Qiang likes sequences. One day, on a whim, he wrote down three sequences, each of length $n$.\n\nAmiba also likes sequences, but he only likes one type, the wave sequence.\n\nAmiba told Xiao Qiang about his preference. Xiao Qiang plans to find the longest wave sequence within these three sequences.\n\nThat is, if we denote the three sequences as $a_{n,1},a_{n,2},a_{n,3}$, he must construct a sequence of ordered pairs $(p_i,q_i)$ such that for any $i>1$:\n\n- $p_i>p_{i-1}$.\n- If $q_i=0$, then $a_{p_i,q_i} \\ge a_{p_{i-1},q_{i-1}}$.\n- If $q_i=1$, then $a_{p_i,q_i} \\le a_{p_{i-1},q_{i-1}}$.\n- If $q_i=2$, it only needs to keep the same direction within a segment (that is, for a contiguous segment with $q_i=2$, either all satisfy $a_{p_i,q_i} \\ge a_{p_{i-1},q_{i-1}}$, or all satisfy $a_{p_i,q_i} \\le a_{p_{i-1},q_{i-1}}$).\n\nXiao Qiang wants this sequence of ordered pairs to be as long as possible.\n\nHint: When $q_i \\not = q_{i-1}$, the monotonicity is determined by $q_i$, not by $q_{i-1}$.\n\n**Clear version of the problem statement**\n\nXiao Qiang gets a $3 \\times n$ array. In each column, choose one number (or choose none), subject to the following conditions:\n\n1. If you choose from the first row, it must be greater than or equal to the previous number.\n2. If you choose from the second row, it must be less than or equal to the previous number.\n3. If you choose from the third row, then for any contiguous segment of numbers chosen from the third row, the directions must be the same (either all are less than or equal to the previous number, or all are greater than or equal to the previous number).", "inputFormat": "The input contains $4$ lines.\n\nThe first line contains an integer $n$, the length of the sequences.\n\nThe $2$nd, $3$rd, and $4$th lines each contain $n$ integers, representing the three sequences, respectively.", "outputFormat": "Output a single integer, the length of the longest wave sequence.", "hint": "Constraints:\n\n- For $20\\%$ of the testdata, $n \\le 10$, $m \\le 1000$.\n- For $60\\%$ of the testdata, $n \\le 1000$, $m \\le 1000$.\n- For $100\\%$ of the testdata, $n \\le 10^5$, $m \\le 10^9$.\n\nHere $m=\\max\\{|a_i|\\}$.\n\nSample explanation:\n\nTake 1, 2, 3 from the third row (increasing), then take 6 from the first row (increasing), then take 5, 4 from the third row (decreasing), for a length of 6.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "SAC E#1 - 一道简单题 Sequence2", "background": "小强和阿米巴是好朋友。", "description": "小强喜欢数列。有一天，他心血来潮，写下了三个长度均为 $n$ 的数列。\n\n阿米巴也很喜欢数列。但是他只喜欢其中一种，波动数列。\n\n阿米巴把他的喜好告诉了小强。小强便打算找出这三个数列内的最长波动数列。\n\n也就是说，如果我们将三个数列记做 $a_{n,1},a_{n,2},a_{n,3}$，他必须要构造一个二元组序列：$(p_i,q_i)$，使得对于任何 $i>1$ 有：\n\n- $p_i>p_{i-1}$。\n\n- 若 $q_i=0$，$a_{p_i,q_i} \\ge a_{p_{i-1},q_{i-1}}$。\n\n- 若 $q_i=1$，$a_{p_i,q_i} \\le a_{p_{i-1},q_{i-1}}$。\n\n- 若 $q_i=2$，只要保持段内同向即可（就是对于连续的一段 $q_i=2$，要么都有 $a_{p_i,q_i} \\ge a_{p_{i-1},q_{i-1}}$，要么都有 $a_{p_i,q_i} \\le a_{p_{i-1},q_{i-1}}$。\n\n小强希望这个二元组序列尽可能长。\n\n提示：当 $q_i \\not = q_{i-1}$ 时，数列的增减性由 $q_i$ 而非 $q_{i-1}$ 决定。\n\n**清晰版题目描述**\n\n小强拿到一个 $3 \\times n$ 的数组，要在每一列选一个数（或者不选），满足以下条件：\n\n1. 如果在第一行选，那它必须大于等于上一个数。\n\n2. 如果在第二行选，那么必须小于等于上一个数。\n\n3. 如果在第三行选，对于连续的一段在第三行选的数，必须满足方向相同（都小于等于上一个数或者都大于等于上一个数）。", "inputFormat": "输入包含 $4$ 行。\n\n第一行一个数 $n$，表示数列长度。\n\n第 $2,3,4$ 行，每行 $n$ 个整数，分别表示三个数列。", "outputFormat": "输出仅包含一个整数，即最长波动数列的长度。", "hint": "对于 $20\\%$ 的数据，$n \\le 10$，$m \\le 1000$。\n\n对于 $60\\%$ 的数据，$n \\le 1000$，$m \\le 1000$。\n\n对于 $100\\%$ 的数据，$n \\le 10^5$，$m \\le 10^9$。\n\n其中 $m=\\max\\{|a_i|\\}$。\n\n样例解释：\n\n取第三行 $1,2,3$（增），然后取第一行 $6$（增），然后取第三行 $5,4$（减），长度为 $6$。", "locale": "zh-CN"}}}
{"pid": "P3929", "type": "P", "difficulty": 4, "samples": [["5\n1 2 3 2 1\n5\n1 2 3 4 5\n", "Yes\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "洛谷原创", "洛谷月赛"], "title": "SAC E#1 - 一道神题 Sequence1", "background": "小强和阿米巴是好朋友。", "description": "小强很喜欢数列。有一天，他心血来潮，写下了一个数列。\n\n阿米巴也很喜欢数列。但是他只喜欢其中一种：波动数列。\n\n一个长度为 $n$ 的波动数列满足对于任何 $i\\ (1 \\le i < n)$，均满足以下两个条件的**同一个**：\n\n- $a_{2i-1} \\le a_{2i}$ 且 $a_{2i} \\ge a_{2i+1}$（若存在）。\n- $a_{2i-1} \\ge a_{2i}$ 且 $a_{2i} \\le a_{2i+1}$（若存在）。\n\n阿米巴把他的喜好告诉了小强。小强便打算稍作修改，以让这个数列成为波动数列。他想知道，能否通过仅修改一个数（或不修改），使得原数列变成波动数列。", "inputFormat": "输入包含多组数据。\n\n每组数据包含两行：\n\n- 第一行一个整数 $n$ 表示数列的长度。\n- 接下来一行，$n$ 个整数，表示一个数列。", "outputFormat": "对于每一组输入，输出一行 `Yes` 或 `No`，含义如题目所示。", "hint": "### 数据范围及约定\n\n- 对于 $30\\%$ 的数据，$1\\le n \\le 10$。\n- 对于另外 $30\\%$ 的数据，$1\\le m \\le 1000$。\n- 对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，$m \\le 10^9$。\n\n其中 $m = \\max|a_i|$（数列中绝对值的最大值）", "locale": "zh-CN", "translations": {"en": {"title": "SAC E#1 - A Legendary Problem Sequence1", "background": "Xiaoqiang and Amiba are good friends.", "description": "Xiaoqiang really likes sequences. One day, on a whim, he wrote down a sequence.\n\nAmiba also likes sequences, but he only likes one kind: wave sequences.\n\nA wave sequence of length $n$ satisfies, for any $i\\ (1 \\le i < n)$, exactly one of the following two sets of conditions (the same one):\n\n- $a_{2i-1} \\le a_{2i}$ and $a_{2i} \\ge a_{2i+1}$ (if it exists).\n- $a_{2i-1} \\ge a_{2i}$ and $a_{2i} \\le a_{2i+1}$ (if it exists).\n\nAmiba told Xiaoqiang about his preference. Xiaoqiang decided to make a small change to turn the sequence into a wave sequence. He wants to know whether it is possible to make the original sequence a wave sequence by modifying at most one number (or not modifying it).", "inputFormat": "The input contains multiple test cases.\n\nEach test case consists of two lines:\n- The first line contains an integer $n$ denoting the length of the sequence.\n- The second line contains $n$ integers, representing a sequence.", "outputFormat": "For each test case, output one line `Yes` or `No`, as described.", "hint": "### Constraints and Conventions\n\n- For $30\\%$ of the testdata, $1 \\le n \\le 10$.\n- For another $30\\%$ of the testdata, $1 \\le m \\le 1000$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 10^5$, $m \\le 10^9$.\n\nHere $m = \\max|a_i|$ (the maximum absolute value in the sequence).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "SAC E#1 - 一道神题 Sequence1", "background": "小强和阿米巴是好朋友。", "description": "小强很喜欢数列。有一天，他心血来潮，写下了一个数列。\n\n阿米巴也很喜欢数列。但是他只喜欢其中一种：波动数列。\n\n一个长度为 $n$ 的波动数列满足对于任何 $i\\ (1 \\le i < n)$，均满足以下两个条件的**同一个**：\n\n- $a_{2i-1} \\le a_{2i}$ 且 $a_{2i} \\ge a_{2i+1}$（若存在）。\n- $a_{2i-1} \\ge a_{2i}$ 且 $a_{2i} \\le a_{2i+1}$（若存在）。\n\n阿米巴把他的喜好告诉了小强。小强便打算稍作修改，以让这个数列成为波动数列。他想知道，能否通过仅修改一个数（或不修改），使得原数列变成波动数列。", "inputFormat": "输入包含多组数据。\n\n每组数据包含两行：\n\n- 第一行一个整数 $n$ 表示数列的长度。\n- 接下来一行，$n$ 个整数，表示一个数列。", "outputFormat": "对于每一组输入，输出一行 `Yes` 或 `No`，含义如题目所示。", "hint": "### 数据范围及约定\n\n- 对于 $30\\%$ 的数据，$1\\le n \\le 10$。\n- 对于另外 $30\\%$ 的数据，$1\\le m \\le 1000$。\n- 对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，$m \\le 10^9$。\n\n其中 $m = \\max|a_i|$（数列中绝对值的最大值）", "locale": "zh-CN"}}}
{"pid": "P3930", "type": "P", "difficulty": 5, "samples": [["8\n...X....\n........\n........\n........\n........\n........\n........\n......O.", "4"], ["8\n......X.\n........\n.O......\n...P.Q.C\n.....B..\n........\n...K....\n........", "7"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["洛谷原创", "O2优化", "广度优先搜索 BFS", "进制", "洛谷月赛", "状压 DP"], "title": "SAC E#1 - 一道大水题 Knight", "background": "毒奶色和 F91 是好朋友。", "description": "他们经常在一起玩一个游戏，不，不是星际争霸，是国际象棋。\n\n毒奶色觉得 F91 是一只鸡。他在一个 $n \\times n$ 的棋盘上用黑色的城堡（车）、骑士（马）、主教（象）、皇后（副）、国王（帅）、士兵（卒）摆了一个阵。\n\n然而 F91 觉得毒奶色是一只鸡。他发起了挑战：他要操纵一个白色骑士，不经过任何一个棋子的攻击范围（F91 可以连续行动，而毒奶色的棋子不会动，除非白骑士进入了对方的攻击范围），并击杀毒奶色的国王（即进入黑国王所在的位置）。\n\n请告诉 F91 他最少需要多少步骤来完成这一项壮举。\n\n\n### 注意：\n\n1. 当 F91 的白骑士走到毒奶色的棋子所在的格子上的时候，会击杀（吃掉）该棋子。这个棋子也就不再对F91的白骑士有威胁了。\n\n2. 如果白骑士开场就在黑子的攻击范围内，则立刻被击杀、F91立刻失败。\n\n3. 即使白骑士在攻击王的瞬间进入了其他棋子攻击范围（即其他棋子“看护”着王所在的格子），依然算F91获胜。\n\n\n### 攻击范围：\n\n\n城堡：横、竖方向所有位置，直到被一个其他棋子阻拦。\n\n```\n..#..\n..#..\n##C##\n..#..\n..#..\n```\n\n骑士：横 $2$ 竖 $1$ 或者横 $1$ 竖 $2$ 的所有位置（最多 $8$ 个，类似日字）。\n\n```\n.#.#.\n#...#\n..K..\n#...#\n.#.#.\n```\n\n主教：斜向（$45 \\degree$）所有位置，直到被一个其他棋子阻拦。\n\n```\n#...#\n.#.#.\n..B..\n.#.#.\n#...#\n```\n\n皇后：城堡和主教的结合体（既能横 / 竖向攻击，也能 $45 \\degree$ 角斜向攻击，直到被其他棋子阻挡）。\n\n```\n#.#.#\n.###.\n##Q##\n.###.\n#.#.#\n```\n\n国王：身边 $8$ 连通位置的 $8$ 个格子。\n\n```\n.....\n.###.\n.#X#.\n.###.\n.....\n```\n\n士兵：左下方 / 右下方（$45 \\degree$）的格子（最多 $2$ 个）。\n\n```\n.....\n.....\n..P..\n.#.#.\n.....\n```\n\n其中字母表示棋子类型，参考输入格式。\n\n`#` 表示可攻击范围。", "inputFormat": "输入包含多组数据。\n\n每一组数据中，第一行一个整数 $n$ 表示棋盘规模。\n\n接下来 $n$ 行，每行一个长度为 $n$ 的字符串。描述棋盘的格局。\n\n其中：\n\n`.` 表示空\n\n`O` 表示白骑士\n\n`C` 表示黑城堡\n\n`K` 表示黑骑士\n\n`B` 表示黑主教\n\n`Q` 表示黑皇后\n\n`X` 表示黑国王\n\n`P` 表示黑士兵", "outputFormat": "对于每一个测试数据，每行输出一个整数，表示 F91 的最小步数。\n\n如果无论 F91 如何行动也无法击杀黑国王，输出 `-1`。", "hint": "**输入最多包含5组数据。**\n\n- 对于 $20\\%$ 的数据，毒奶色只有国王。$n \\le 8$。\n\n- 对于 $30\\%$ 的数据，毒奶色只有国王、骑士。$n \\le 8$。\n\n对于 $60\\%$ 的数据，毒奶色只有国王、骑士、王后。$n \\le 55$。\n\n对于 $100\\%$ 的数据，毒奶色可以有全套 $16$ 颗棋子（$2$ 城堡，$2$ 骑士，$2$ 主教，$1$ 后，$1$ 王，$8$ 兵）。$n \\le 55$。\n\n\n温馨提示：\n\n时间限制可能比想象之中还要更紧一点，请注意实现细节以保证性能。\n\n\n\n样例 $2$ 解释：\n\n一种可行的做法是：\n\n```\n......X.\n.3..6...\n.O5.....\n4.2P.Q.C\n1....B..\n........\n...K....\n........\n```", "locale": "zh-CN", "translations": {"en": {"title": "SAC E#1 - A Very Easy Problem Knight", "background": "Du nai se and F91 are good friends.", "description": "They often play a game together. No, not StarCraft, but chess.\n\nDu nai se thinks F91 is a chicken. He set up a formation on an $n \\times n$ chessboard using black rooks, knights, bishops, a queen, a king, and pawns.\n\nHowever, F91 thinks Du nai se is a chicken. He issues a challenge: he will control a white knight, move without stepping on any square that is within the attack range of any piece (F91 can move continuously, and Du nai se’s pieces do not move, unless the white knight enters a square in their attack range), and capture Du nai se’s king (i.e., land on the square where the black king is).\n\nPlease tell F91 the minimum number of moves needed to accomplish this.\n\nNote:\n1. When F91’s white knight moves onto a square occupied by one of Du nai se’s pieces, it captures that piece. That piece no longer threatens the white knight.\n2. If the white knight starts in the attack range of a black piece, it is captured immediately and F91 loses at once.\n3. Even if the white knight enters the attack range of other pieces at the exact moment it captures the king (i.e., other pieces “guard” the king’s square), F91 still wins.\n\nAttack ranges:\n\nRook: all squares in the horizontal and vertical directions, until blocked by another piece.\n\n```\n..#..\n..#..\n##C##\n..#..\n..#..\n```\n\nKnight: all positions with a horizontal move of 2 and a vertical move of 1, or a horizontal move of 1 and a vertical move of 2 (at most 8 squares, L-shaped).\n\n```\n.#.#.\n#...#\n..K..\n#...#\n.#.#.\n```\n\nBishop: all squares along diagonals ($45^\\circ$), until blocked by another piece.\n\n```\n#...#\n.#.#.\n..B..\n.#.#.\n#...#\n```\n\nQueen: the combination of rook and bishop (it can attack horizontally/vertically and along $45^\\circ$ diagonals, until blocked by other pieces).\n\n```\n#.#.#\n.###.\n##Q##\n.###.\n#.#.#\n```\n\nKing: the 8 neighboring squares in the 8-connected neighborhood.\n\n```\n.....\n.###.\n.#X#.\n.###.\n.....\n```\n\nPawn: the squares down-left / down-right ($45^\\circ$) (at most 2 squares).\n\n```\n.....\n.....\n..P..\n.#.#.\n.....\n```\n\nThe letters indicate piece types; see the input format. `#` indicates squares in the attack range.", "inputFormat": "The input contains multiple sets of testdata.\n\nFor each set, the first line contains an integer $n$ indicating the board size.\n\nThe next $n$ lines each contain a string of length $n$ describing the board.\n\nWhere:\n- `.` indicates an empty square.\n- `O` indicates the white knight.\n- `C` indicates a black rook.\n- `K` indicates a black knight.\n- `B` indicates a black bishop.\n- `Q` indicates a black queen.\n- `X` indicates a black king.\n- `P` indicates a black pawn.", "outputFormat": "For each set of testdata, output one integer per line, indicating the minimum number of moves F91 needs.\n\nIf it is impossible for F91 to capture the black king no matter how he moves, output `-1`.", "hint": "The input contains at most 5 sets of testdata.\n\n- For 20% of the testdata, Du nai se has only the king. $n \\le 8$.\n- For 30% of the testdata, Du nai se has only the king and knights. $n \\le 8$.\n- For 60% of the testdata, Du nai se has only the king, knights, and the queen. $n \\le 50$.\n- For 100% of the testdata, Du nai se may have the full set of 16 pieces (2 rooks, 2 knights, 2 bishops, 1 queen, 1 king, 8 pawns). $n \\le 50$.\n\nKind reminder: the time limit might be tighter than you think. Please pay attention to implementation details to ensure performance.\n\nExplanation for sample 2:\n\nOne feasible sequence is:\n\n```\n......X.\n.3..6...\n.O5.....\n4.2P.Q.C\n1....B..\n........\n...K....\n........\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "SAC E#1 - 一道大水题 Knight", "background": "毒奶色和 F91 是好朋友。", "description": "他们经常在一起玩一个游戏，不，不是星际争霸，是国际象棋。\n\n毒奶色觉得 F91 是一只鸡。他在一个 $n \\times n$ 的棋盘上用黑色的城堡（车）、骑士（马）、主教（象）、皇后（副）、国王（帅）、士兵（卒）摆了一个阵。\n\n然而 F91 觉得毒奶色是一只鸡。他发起了挑战：他要操纵一个白色骑士，不经过任何一个棋子的攻击范围（F91 可以连续行动，而毒奶色的棋子不会动，除非白骑士进入了对方的攻击范围），并击杀毒奶色的国王（即进入黑国王所在的位置）。\n\n请告诉 F91 他最少需要多少步骤来完成这一项壮举。\n\n\n### 注意：\n\n1. 当 F91 的白骑士走到毒奶色的棋子所在的格子上的时候，会击杀（吃掉）该棋子。这个棋子也就不再对F91的白骑士有威胁了。\n\n2. 如果白骑士开场就在黑子的攻击范围内，则立刻被击杀、F91立刻失败。\n\n3. 即使白骑士在攻击王的瞬间进入了其他棋子攻击范围（即其他棋子“看护”着王所在的格子），依然算F91获胜。\n\n\n### 攻击范围：\n\n\n城堡：横、竖方向所有位置，直到被一个其他棋子阻拦。\n\n```\n..#..\n..#..\n##C##\n..#..\n..#..\n```\n\n骑士：横 $2$ 竖 $1$ 或者横 $1$ 竖 $2$ 的所有位置（最多 $8$ 个，类似日字）。\n\n```\n.#.#.\n#...#\n..K..\n#...#\n.#.#.\n```\n\n主教：斜向（$45 \\degree$）所有位置，直到被一个其他棋子阻拦。\n\n```\n#...#\n.#.#.\n..B..\n.#.#.\n#...#\n```\n\n皇后：城堡和主教的结合体（既能横 / 竖向攻击，也能 $45 \\degree$ 角斜向攻击，直到被其他棋子阻挡）。\n\n```\n#.#.#\n.###.\n##Q##\n.###.\n#.#.#\n```\n\n国王：身边 $8$ 连通位置的 $8$ 个格子。\n\n```\n.....\n.###.\n.#X#.\n.###.\n.....\n```\n\n士兵：左下方 / 右下方（$45 \\degree$）的格子（最多 $2$ 个）。\n\n```\n.....\n.....\n..P..\n.#.#.\n.....\n```\n\n其中字母表示棋子类型，参考输入格式。\n\n`#` 表示可攻击范围。", "inputFormat": "输入包含多组数据。\n\n每一组数据中，第一行一个整数 $n$ 表示棋盘规模。\n\n接下来 $n$ 行，每行一个长度为 $n$ 的字符串。描述棋盘的格局。\n\n其中：\n\n`.` 表示空\n\n`O` 表示白骑士\n\n`C` 表示黑城堡\n\n`K` 表示黑骑士\n\n`B` 表示黑主教\n\n`Q` 表示黑皇后\n\n`X` 表示黑国王\n\n`P` 表示黑士兵", "outputFormat": "对于每一个测试数据，每行输出一个整数，表示 F91 的最小步数。\n\n如果无论 F91 如何行动也无法击杀黑国王，输出 `-1`。", "hint": "**输入最多包含5组数据。**\n\n- 对于 $20\\%$ 的数据，毒奶色只有国王。$n \\le 8$。\n\n- 对于 $30\\%$ 的数据，毒奶色只有国王、骑士。$n \\le 8$。\n\n对于 $60\\%$ 的数据，毒奶色只有国王、骑士、王后。$n \\le 55$。\n\n对于 $100\\%$ 的数据，毒奶色可以有全套 $16$ 颗棋子（$2$ 城堡，$2$ 骑士，$2$ 主教，$1$ 后，$1$ 王，$8$ 兵）。$n \\le 55$。\n\n\n温馨提示：\n\n时间限制可能比想象之中还要更紧一点，请注意实现细节以保证性能。\n\n\n\n样例 $2$ 解释：\n\n一种可行的做法是：\n\n```\n......X.\n.3..6...\n.O5.....\n4.2P.Q.C\n1....B..\n........\n...K....\n........\n```", "locale": "zh-CN"}}}
{"pid": "P3931", "type": "P", "difficulty": 4, "samples": [["4 1\n1 2 1 \n1 3 1\n1 4 1", "3"], ["4 1\n1 2 3\n2 3 1\n3 4 2", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "网络流", "洛谷原创", "树形 DP", "最小割", "洛谷月赛"], "title": "SAC E#1 - 一道难题 Tree", "background": "冴月麟和魏潇承是好朋友。", "description": "冴月麟为了守护幻想乡，而制造了幻想乡的倒影，将真实的幻想乡封印了。任何人都无法进入真实的幻想乡了，但是她给前来救她的魏潇承留了一个线索。\n\n她设置了一棵树（有根）。树的每一条边上具有割掉该边的代价。\n\n魏潇承需要计算出割开这棵树的最小代价，这就是冴月麟和魏潇承约定的小秘密。\n\n帮帮魏潇承吧。\n\n\n注：所谓割开一棵有根树，就是删除若干条边，使得任何叶子节点和根节点不连通。", "inputFormat": "输入第一行两个整数 $n,\\mathrm{root}$ 分别表示树的节点个数和树根。\n\n接下来 $n-1$ 行每行三个整数 $a,b,c$，表示 $a,b$ 之间有一条代价为 $c$ 的边。", "outputFormat": "输出包含一行，一个整数，表示所求最小代价。", "hint": "### 数据范围及约定\n\n- 对于 $20\\%$ 的数据，$n\\le 10$；\n- 对于 $50\\%$ 的数据，$n \\le 1000$；\n- 对于 $100\\%$ 的数据，$2\\le n \\le 100000$，且边权是不大于 $10^6$ 的正整数。", "locale": "zh-CN", "translations": {"en": {"title": "SAC E#1 - A Hard Problem Tree", "background": "冴月麟 and 魏潇承 are good friends.", "description": "To protect Gensokyo, 冴月麟 created a reflection of Gensokyo and sealed away the real Gensokyo. No one can enter the real Gensokyo anymore, but she left a clue for 魏潇承 who came to save her.\n\nShe set up a rooted tree. Each edge has a cost to cut it.\n\n魏潇承 needs to compute the minimum cost to cut this tree. This is the little secret agreed upon by 冴月麟 and 魏潇承.\n\nPlease help 魏潇承.\n\nNote: To “cut open” a rooted tree means to delete some edges so that no leaf node is connected to the root.", "inputFormat": "The first line contains two integers $n, \\mathrm{root}$, representing the number of nodes in the tree and the root.\n\nEach of the next $n-1$ lines contains three integers $a, b, c$, indicating there is an edge between $a$ and $b$ with cost $c$.", "outputFormat": "Output one line containing a single integer, the minimum cost.", "hint": "### Constraints and Agreements\n\n- For $20\\%$ of the testdata, $n \\le 10$.\n- For $50\\%$ of the testdata, $n \\le 1000$.\n- For $100\\%$ of the testdata, $2 \\le n \\le 100000$, and edge weights are non-negative integers not exceeding $10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "SAC E#1 - 一道难题 Tree", "background": "冴月麟和魏潇承是好朋友。", "description": "冴月麟为了守护幻想乡，而制造了幻想乡的倒影，将真实的幻想乡封印了。任何人都无法进入真实的幻想乡了，但是她给前来救她的魏潇承留了一个线索。\n\n她设置了一棵树（有根）。树的每一条边上具有割掉该边的代价。\n\n魏潇承需要计算出割开这棵树的最小代价，这就是冴月麟和魏潇承约定的小秘密。\n\n帮帮魏潇承吧。\n\n\n注：所谓割开一棵有根树，就是删除若干条边，使得任何叶子节点和根节点不连通。", "inputFormat": "输入第一行两个整数 $n,\\mathrm{root}$ 分别表示树的节点个数和树根。\n\n接下来 $n-1$ 行每行三个整数 $a,b,c$，表示 $a,b$ 之间有一条代价为 $c$ 的边。", "outputFormat": "输出包含一行，一个整数，表示所求最小代价。", "hint": "### 数据范围及约定\n\n- 对于 $20\\%$ 的数据，$n\\le 10$；\n- 对于 $50\\%$ 的数据，$n \\le 1000$；\n- 对于 $100\\%$ 的数据，$2\\le n \\le 100000$，且边权是不大于 $10^6$ 的正整数。", "locale": "zh-CN"}}}
{"pid": "P3932", "type": "P", "difficulty": 5, "samples": [["5 5\n2 3 4 5\n1 2 3 4 5\n1 1 5\n3 1 5\n2 3 3\n3 3 3\n1 5 5\n", "125\n72\n9\n0\n70"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["洛谷原创", "O2优化", "前缀和", "分块", "洛谷月赛"], "title": "浮游大陆的68号岛", "background": "浮游大陆的 $68$ 号岛，位于浮游大陆的边境地带。平时很少有人造访。\n\n岛上被浓厚的森林覆盖。\n\n![](https://cdn.luogu.com.cn/upload/pic/9282.png) \n\n在这座边境地区不起眼的浮游岛上，建立着神秘的”兵器“管理仓库——妖精仓库。\n", "description": "妖精仓库里生活着黄金妖精们，她们过着快乐，却随时准备着迎接死亡的生活。\n\n换用更高尚的说法，是随时准备着为这个无药可救的世界献身。\n\n\n然而孩子们的生活却总是无忧无虑的，幼体的黄金妖精们过着天真烂漫的生活，自然也无暇考虑什么拯救世界之类的重任。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qxdahsft.png)\n\n有一天小妖精们又在做游戏。这个游戏是这样的。\n\n妖精仓库的储物点可以看做在一个数轴上。每一个储物点会有一些东西，同时他们之间存在距离。\n\n每次他们会选出一个小妖精，然后剩下的人找到区间$[l,r]$储物点的所有东西，清点完毕之后问她，把这个区间内所有储物点的东西运到另外一个仓库的代价是多少？\n\n比如储物点$i$有$x$个东西，要运到储物点$j$，代价为\n\n\n$$x \\times \\mathrm{dist}( i , j )$$\n\n\ndist就是仓库间的距离。\n\n当然啦，由于小妖精们不会算很大的数字，因此您的答案需要对19260817取模。\n\n![](https://cdn.luogu.com.cn/upload/pic/9294.png)\n", "inputFormat": "第一行两个数表示$n,m$\n\n第二行$n-1$个数，第$i$个数表示第$i$个储物点与第$i+1$个储物点的距离\n\n第三行$n$个数，表示每个储物点的东西个数\n\n之后$m$行每行三个数`x l r`\n\n表示查询要把区间$[l,r]$储物点的物品全部运到储物点x的花费\n", "outputFormat": "对于每个询问输出一个数表示答案\n", "hint": "对于30%的数据，$n , m \\le 1000$\n\n对于另外20%的数据，所有储物点间的距离都为1\n\n对于另外20%的数据，所有储物点的物品数都为1\n\n对于100%的数据 ,$ n , m \\le 200000 ; a_i , b_i <= 2\\cdot 10^9$\n", "locale": "zh-CN", "translations": {"en": {"title": "No. 68 Island of the Floating Continent", "background": "Island No. $68$ of the Floating Continent is located in the borderlands of the Floating Continent. It is rarely visited.\n\nThe island is covered by dense forest.\n\n![](https://cdn.luogu.com.cn/upload/pic/9282.png)\n\nOn this unremarkable floating island at the border, there is a mysterious “weapon” management depot — the Fairy Warehouse.", "description": "Golden fairies live in the Fairy Warehouse. They live happily, yet are always ready to face death.\n\nPut more nobly, they are always ready to sacrifice themselves for this hopeless world.\n\nHowever, children always live carefree lives. The young golden fairies live innocently and naturally have no time to think about heavy duties like saving the world.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qxdahsft.png)\n\nOne day, the little fairies are playing a game again. The game goes like this.\n\nThe storage points of the Fairy Warehouse can be regarded as lying on a number line. Each storage point has some items, and there are distances between them.\n\nEach time they pick one little fairy, and the others collect all the items at the storage points in the interval $[l, r]$. After counting, they ask her: what is the cost to move all items from storage points in this interval to another storage point?\n\nFor example, if storage point $i$ has $x$ items and you want to move them to storage point $j$, the cost is\n$$x \\times \\mathrm{dist}( i , j ).$$\n\nHere, $\\mathrm{dist}$ is the distance between storage points.\n\nOf course, since the little fairies cannot handle very large numbers, your answer needs to be taken modulo $19260817$.\n\n![](https://cdn.luogu.com.cn/upload/pic/9294.png)", "inputFormat": "The first line contains two integers $n, m$.\n\nThe second line contains $n-1$ integers. The $i$-th number is the distance between storage points $i$ and $i+1$.\n\nThe third line contains $n$ integers, giving the number of items at each storage point.\n\nThen follow $m$ lines, each containing three integers `x l r`.\n\nEach query asks for the cost to move all items from storage points in the interval $[l, r]$ to storage point $x$.", "outputFormat": "For each query, output one integer: the answer.", "hint": "- For $30\\%$ of the testdata, $n, m \\le 1000$.\n- For another $20\\%$ of the testdata, all distances between storage points are $1$.\n- For another $20\\%$ of the testdata, the number of items at every storage point is $1$.\n- For $100\\%$ of the testdata, $n, m \\le 200000$; all distances and item counts are at most $2 \\cdot 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "浮游大陆的68号岛", "background": "浮游大陆的 $68$ 号岛，位于浮游大陆的边境地带。平时很少有人造访。\n\n岛上被浓厚的森林覆盖。\n\n![](https://cdn.luogu.com.cn/upload/pic/9282.png) \n\n在这座边境地区不起眼的浮游岛上，建立着神秘的”兵器“管理仓库——妖精仓库。\n", "description": "妖精仓库里生活着黄金妖精们，她们过着快乐，却随时准备着迎接死亡的生活。\n\n换用更高尚的说法，是随时准备着为这个无药可救的世界献身。\n\n\n然而孩子们的生活却总是无忧无虑的，幼体的黄金妖精们过着天真烂漫的生活，自然也无暇考虑什么拯救世界之类的重任。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qxdahsft.png)\n\n有一天小妖精们又在做游戏。这个游戏是这样的。\n\n妖精仓库的储物点可以看做在一个数轴上。每一个储物点会有一些东西，同时他们之间存在距离。\n\n每次他们会选出一个小妖精，然后剩下的人找到区间$[l,r]$储物点的所有东西，清点完毕之后问她，把这个区间内所有储物点的东西运到另外一个仓库的代价是多少？\n\n比如储物点$i$有$x$个东西，要运到储物点$j$，代价为\n\n\n$$x \\times \\mathrm{dist}( i , j )$$\n\n\ndist就是仓库间的距离。\n\n当然啦，由于小妖精们不会算很大的数字，因此您的答案需要对19260817取模。\n\n![](https://cdn.luogu.com.cn/upload/pic/9294.png)\n", "inputFormat": "第一行两个数表示$n,m$\n\n第二行$n-1$个数，第$i$个数表示第$i$个储物点与第$i+1$个储物点的距离\n\n第三行$n$个数，表示每个储物点的东西个数\n\n之后$m$行每行三个数`x l r`\n\n表示查询要把区间$[l,r]$储物点的物品全部运到储物点x的花费\n", "outputFormat": "对于每个询问输出一个数表示答案\n", "hint": "对于30%的数据，$n , m \\le 1000$\n\n对于另外20%的数据，所有储物点间的距离都为1\n\n对于另外20%的数据，所有储物点的物品数都为1\n\n对于100%的数据 ,$ n , m \\le 200000 ; a_i , b_i <= 2\\cdot 10^9$\n", "locale": "zh-CN"}}}
{"pid": "P3933", "type": "P", "difficulty": 5, "samples": [["4 4\n1 12 6 11\n11 4 2 14\n10 1 9 20\n4 17 13 10", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 2000, 2000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "二分", "O2优化", "向量", "洛谷月赛"], "title": "Chtholly Nota Seniorious", "background": "经查，本题是原题，非常抱歉。\n\n大样例下发链接: https://pan.baidu.com/s/1nuVpRS1 密码: sfxg\n\n**こんなにも、たくさんの幸せをあの人に分けてもらった**\n\n**だから、きっと**\n\n**今の、私は**\n\n**谁が何と言おうと**\n\n##世界一、幸せな女の子だ\n\n![](https://cdn.luogu.com.cn/upload/pic/9193.png)\n", "description": "——“假如……我是说假如喔。\n\n万一我再过五天就会死，你能不能对我温柔一点？”\n\n巨大的六号兽五天后将袭击浮游大陆。\n\n无数次计算得到的残酷数据表明，只有圣剑瑟尼欧尼斯的适格精灵——珂朵莉·诺塔·瑟尼欧尼斯(Chtholly Nota Seniorious)开启妖精乡之门，才可以以生命为代价守住浮游岛。\n\n ![](https://cdn.luogu.com.cn/upload/pic/9228.png) \n\n“至少，我也希望自己不用消失，也想让别人记住。我也想留下羁绊啊。”\n\n留给妖精少女珂朵莉的时间似乎已经不多了。\n\n ![](https://cdn.luogu.com.cn/upload/pic/9229.png) \n\n年轻的二等技官，妖精仓库的管理员，世界上最后一个人类——威廉·克梅**修**，数百年前曾经是一名准勇者，掌握着成为一名勇者所需要的所有知识。\n\n大战在即，调整圣剑的状态成为了一项重要的任务。\n\n```cpp\n瑟尼欧里斯（セニオリス）\n圣剑的其中之一，在现存的遗迹兵装中，拥有最强大的力量。\n拥有非常特殊的资质，只有极少一部分的人才能使用。\n由四十一个护符组成。能将所有事物包含不死者都回归「死亡」。\n```\n威廉需要调整圣剑的状态，因此他将瑟尼欧尼斯拆分护符，组成了一个$n$行$m$列的矩阵。\n\n每一个护符都有自己的魔力值。现在为了测试圣剑，你需要将这些护符分成 A,B两部分。\n\n要求如下：\n\n1.  圣剑的所有护符，恰好都属于两部分中的一部分。\n\n2.  每个部分内部的方块之间，可以通过上下左右相互到达，而且每个内部的方块之间互相到达，最多允许拐一次弯。\n\n例如\n```cpp\nＡＡＡＡＡ　　ＡＡＡＡＡ　　ＡＡＡＡＡ\nＡＡＢＡＡ　　ＢａＡＡＡ　　ＡＡＡＢＢ\nＡＢＢＢＡ　　ＢＢＡＡＡ　　ＡＡＡＢＢ\nＡＡＢＡＡ　　ＢａＡＡＡ　　ＡＢＢＢＢ\nＡＡＡＡＡ　　ＡＡＡＡＡ　　ＢＢＢＢＢ\n\n　　(1)　　　　　(2)　　　　　(3)　　　　　　\n```\n其中(1)(2)是不允许的分法，(3)是允许的分法。在(2)中，a属于A区域，这两个a元素之间互相到达，没有办法最多只拐一次弯。\n\n现在要问，所有合法的分法中，A区域的极差与B区域的极差 中间较大的一个的 **最小值** 是多少？\n\n好心而可爱的在一旁默默观察奈芙莲悄悄地告诉你，极差就是区域内最大值减去最小值。\n\n ![](https://cdn.luogu.com.cn/upload/pic/9230.png) \n\n夜晚的风吹拂着，68号岛上的景色竟与地上的森林无异。转念又想，黄金妖精本身就是与森林之中出现，成长，消亡的神秘存在啊。\n\n时间不早了，早上训练中落败的珂朵莉即将回来了。您要尽快和威廉一起调整好圣剑，千万不能迟哟。\n", "inputFormat": "第一行两个自然数$n,m$\n\n接下来$n$行，每行$m$个自然数$A_{i,j}$表示权值\n", "outputFormat": "一个整数表示答案。\n", "hint": "样例解释\n\n```cpp\n1  12 6        11\n11 4  2        14\n10 1  9        20\n4        17 13 10\n```\n分法不唯一，如图是一种合法的分法。左边部分极差12-1=11，右边一块极差20-10=10，所以答案取这两个中较大者11。没有别的分法，可以使答案更小。\n\n\n**数据范围与约定**\n\n\n测试点　　|n　　　　|m　　　　\n-|-|-\n#1-2      |$\\le 10$ |$\\le 10$\n#3-4      |1        |$\\le 2000$\n#5-7      |$\\le 200$|$\\le 200$\n#8-10     |$\\le 2000$|$\\le 2000$\n\n对于所有的权值$1\\le A_{i,j} \\le 10^9$\n\n\n《末日时在做什么？有没有空？可以来拯救吗？》\n\n![](https://cdn.luogu.com.cn/upload/pic/9235.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "Chtholly Nota Seniorious", "background": "Upon verification, this problem already exists; we apologize.\n\nLarge sample download link: https://pan.baidu.com/s/1nuVpRS1 Password: sfxg\n\n—I received so much happiness from that person.  \n—Therefore, surely.  \n—The me of now,  \n—No matter what anyone says,  \n—I am the happiest girl in the world.\n\n![](https://cdn.luogu.com.cn/upload/pic/9193.png)", "description": "—“If... I mean, hypothetically.  \nIf I were to die in five days, could you treat me a little more gently?”\n\nThe colossal Beast No. 6 will attack the Floating Continent in five days.\n\nCountless calculations yield cruel data showing that only the qualified spirit of the sacred sword Seniorious — Chtholly Nota Seniorious — by opening the Gate of Fairyland, can defend the floating island at the cost of her life.\n\n![](https://cdn.luogu.com.cn/upload/pic/9228.png)\n\n“At the very least, I also hope I will not disappear, and I want to be remembered by others. I want to leave bonds behind, too.”\n\nIt seems the fairy girl Chtholly has little time left.\n\n![](https://cdn.luogu.com.cn/upload/pic/9229.png)\n\nA young second-class technical officer, administrator of the Fairy Warehouse, and the last human in the world — 威廉·克梅**修** (Willem Kmetsch). Centuries ago, he was a prospective hero and mastered all the knowledge required to become one.\n\nWith a great battle imminent, adjusting the sacred sword’s state has become an important task.\n\n```cpp\n瑟尼欧里斯（セニオリス）\n圣剑的其中之一，在现存的遗迹兵装中，拥有最强大的力量。\n拥有非常特殊的资质，只有极少一部分的人才能使用。\n由四十一个护符组成。能将所有事物包含不死者都回归「死亡」。\n```\nWillem needs to adjust the sword’s state, so he split Seniorious into talismans that form an $n$-by-$m$ matrix.\n\nEach talisman has its own magic value. To test the sword, you need to divide these talismans into two parts, A and B.\n\nRequirements:\n1. Every talisman of the sacred sword belongs to exactly one of the two parts.\n2. Within each part, the cells must be connected via up, down, left, and right; moreover, for any two cells within the same part, there must be a path between them that uses at most one turn.\n\nFor example:\n```cpp\nＡＡＡＡＡ　　ＡＡＡＡＡ　　ＡＡＡＡＡ\nＡＡＢＡＡ　　ＢａＡＡＡ　　ＡＡＡＢＢ\nＡＢＢＢＡ　　ＢＢＡＡＡ　　ＡＡＡＢＢ\nＡＡＢＡＡ　　ＢａＡＡＡ　　ＡＢＢＢＢ\nＡＡＡＡＡ　　ＡＡＡＡＡ　　ＢＢＢＢＢ\n\n　　(1)　　　　　(2)　　　　　(3)　　　　　　\n```\nAmong these, (1) and (2) are not allowed, while (3) is allowed. In (2), the cells marked a belong to region A; there is no way for those two a cells to reach each other using at most one turn.\n\nAmong all valid partitions, what is the minimum possible value of the larger one between the range of region A and the range of region B?\n\nKind and cute Nephren, quietly observing from the side, softly tells you that the range is defined as the maximum value in the region minus the minimum value.\n\n![](https://cdn.luogu.com.cn/upload/pic/9230.png)\n\nThe night wind blows; the scenery on Island No. 68 looks no different from the forests on the ground. Then again, golden fairies themselves are mysterious beings that appear, grow, and fade within the forest.\n\nTime is running late. Chtholly, who lost the morning training, will return soon. You must quickly adjust the sacred sword with Willem. Do not be late.", "inputFormat": "The first line contains two natural numbers $n, m$.\n\nThe next $n$ lines each contain $m$ natural numbers $A_{i,j}$ representing the weights.", "outputFormat": "Output a single integer: the answer.", "hint": "Explanation of the sample:\n\n```cpp\n1  12 6        11\n11 4  2        14\n10 1  9        20\n4        17 13 10\n```\nThe partition is not unique; the figure shows one valid partition. The left part has range $12 - 1 = 11$, and the right part has range $20 - 10 = 10$, so the answer takes the larger of the two, $11$. There is no other partition that can make the answer smaller.\n\nConstraints and Conventions\n\n测试点　　|$n$　　　　|$m$　　　　\n-|-|-\n#1-2      |$\\le 10$ |$\\le 10$\n#3-4      |1        |$\\le 2000$\n#5-7      |$\\le 200$|$\\le 200$\n#8-10     |$\\le 2000$|$\\le 2000$\n\nFor all weights, $1 \\le A_{i,j} \\le 10^9$.\n\n“What Are You Doing at the End of the World? Are You Busy? Will You Save Us?”\n\n![](https://cdn.luogu.com.cn/upload/pic/9235.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Chtholly Nota Seniorious", "background": "经查，本题是原题，非常抱歉。\n\n大样例下发链接: https://pan.baidu.com/s/1nuVpRS1 密码: sfxg\n\n**こんなにも、たくさんの幸せをあの人に分けてもらった**\n\n**だから、きっと**\n\n**今の、私は**\n\n**谁が何と言おうと**\n\n##世界一、幸せな女の子だ\n\n![](https://cdn.luogu.com.cn/upload/pic/9193.png)\n", "description": "——“假如……我是说假如喔。\n\n万一我再过五天就会死，你能不能对我温柔一点？”\n\n巨大的六号兽五天后将袭击浮游大陆。\n\n无数次计算得到的残酷数据表明，只有圣剑瑟尼欧尼斯的适格精灵——珂朵莉·诺塔·瑟尼欧尼斯(Chtholly Nota Seniorious)开启妖精乡之门，才可以以生命为代价守住浮游岛。\n\n ![](https://cdn.luogu.com.cn/upload/pic/9228.png) \n\n“至少，我也希望自己不用消失，也想让别人记住。我也想留下羁绊啊。”\n\n留给妖精少女珂朵莉的时间似乎已经不多了。\n\n ![](https://cdn.luogu.com.cn/upload/pic/9229.png) \n\n年轻的二等技官，妖精仓库的管理员，世界上最后一个人类——威廉·克梅**修**，数百年前曾经是一名准勇者，掌握着成为一名勇者所需要的所有知识。\n\n大战在即，调整圣剑的状态成为了一项重要的任务。\n\n```cpp\n瑟尼欧里斯（セニオリス）\n圣剑的其中之一，在现存的遗迹兵装中，拥有最强大的力量。\n拥有非常特殊的资质，只有极少一部分的人才能使用。\n由四十一个护符组成。能将所有事物包含不死者都回归「死亡」。\n```\n威廉需要调整圣剑的状态，因此他将瑟尼欧尼斯拆分护符，组成了一个$n$行$m$列的矩阵。\n\n每一个护符都有自己的魔力值。现在为了测试圣剑，你需要将这些护符分成 A,B两部分。\n\n要求如下：\n\n1.  圣剑的所有护符，恰好都属于两部分中的一部分。\n\n2.  每个部分内部的方块之间，可以通过上下左右相互到达，而且每个内部的方块之间互相到达，最多允许拐一次弯。\n\n例如\n```cpp\nＡＡＡＡＡ　　ＡＡＡＡＡ　　ＡＡＡＡＡ\nＡＡＢＡＡ　　ＢａＡＡＡ　　ＡＡＡＢＢ\nＡＢＢＢＡ　　ＢＢＡＡＡ　　ＡＡＡＢＢ\nＡＡＢＡＡ　　ＢａＡＡＡ　　ＡＢＢＢＢ\nＡＡＡＡＡ　　ＡＡＡＡＡ　　ＢＢＢＢＢ\n\n　　(1)　　　　　(2)　　　　　(3)　　　　　　\n```\n其中(1)(2)是不允许的分法，(3)是允许的分法。在(2)中，a属于A区域，这两个a元素之间互相到达，没有办法最多只拐一次弯。\n\n现在要问，所有合法的分法中，A区域的极差与B区域的极差 中间较大的一个的 **最小值** 是多少？\n\n好心而可爱的在一旁默默观察奈芙莲悄悄地告诉你，极差就是区域内最大值减去最小值。\n\n ![](https://cdn.luogu.com.cn/upload/pic/9230.png) \n\n夜晚的风吹拂着，68号岛上的景色竟与地上的森林无异。转念又想，黄金妖精本身就是与森林之中出现，成长，消亡的神秘存在啊。\n\n时间不早了，早上训练中落败的珂朵莉即将回来了。您要尽快和威廉一起调整好圣剑，千万不能迟哟。\n", "inputFormat": "第一行两个自然数$n,m$\n\n接下来$n$行，每行$m$个自然数$A_{i,j}$表示权值\n", "outputFormat": "一个整数表示答案。\n", "hint": "样例解释\n\n```cpp\n1  12 6        11\n11 4  2        14\n10 1  9        20\n4        17 13 10\n```\n分法不唯一，如图是一种合法的分法。左边部分极差12-1=11，右边一块极差20-10=10，所以答案取这两个中较大者11。没有别的分法，可以使答案更小。\n\n\n**数据范围与约定**\n\n\n测试点　　|n　　　　|m　　　　\n-|-|-\n#1-2      |$\\le 10$ |$\\le 10$\n#3-4      |1        |$\\le 2000$\n#5-7      |$\\le 200$|$\\le 200$\n#8-10     |$\\le 2000$|$\\le 2000$\n\n对于所有的权值$1\\le A_{i,j} \\le 10^9$\n\n\n《末日时在做什么？有没有空？可以来拯救吗？》\n\n![](https://cdn.luogu.com.cn/upload/pic/9235.png)\n", "locale": "zh-CN"}}}
{"pid": "P3934", "type": "P", "difficulty": 6, "samples": [["6 4\n1 2 3 4 5 6\n2 1 2 10000007\n2 2 3 5\n1 1 4 1\n2 2 4 10\n", "1\n3\n1"], ["5 5\n2 3 3 3 3\n1 1 1 530739835\n2 1 1 8356089\n2 1 4 5496738\n1 1 2 66050181\n1 2 4 138625417\n", "4306230\n697527\n"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "线段树", "树状数组", "数论", "O2优化", "枚举", "洛谷月赛", "Ynoi", "欧拉降幂"], "title": "[Ynoi Easy Round 2016] 炸脖龙 I", "background": "备餐时光，软泞蜥獾\n\n草地中钻孔，日晷下打转\n\n波若歌鹦苟延残喘，迷途绿龟嚎哮迷茫\n\n“当心炸脖龙，我的孩子！\n\n那锋爪利颚，能挠钩撕咬！\n\n注意秋布秋布鸟，你需回避，\n\n那暴躁冒烟恶怪大毛怪！”\n\n手持宝剑鸣真理之语：寻觅强敌豪壮永不息——于噹噹树下稍事休憩，伫立良久，深陷思绪。\n\n当思绪纷乱杂绪之际，炸脖龙双目如烔炬，从阴暗密林奔跃闯出，一路悲鸣低吟时啭啼！\n\n一，二！一，二！一刺再刺，真理之语将敌斩成糜！\n\n取其首级，置之死地，\n\n伴随胜利，驰马归疾。\n\n“真当是你把怪龙斩于马下？\n\n奋勇吾儿！\n\n来我怀里！奔走相告！衣锦还乡！\n\n父喜不自禁窃鸣得意\n\n波若歌鹦苟延残喘，\n\n迷途绿龟嚎哮迷茫，\n\n备餐时光，软泞蜥獾\n\n草地中钻孔，日晷下打转\n\n波若歌鹦苟延残喘，\n\n迷途绿龟嚎哮迷茫”\n\n——《炸脖龙之诗》\n\n![](https://cdn.luogu.com.cn/upload/pic/21111.png)\n\n我喊了出来...却不成人话\n\n只能，像在水中一边融化一边下沉的方糖一样...\n\n失去自己的轮廓...一直沉向最低处\n\n想要爬上去的子午\n\n维持自己是自己的连续体...\n\n溶解的渐渐七零八落的意识...\n\n失去了用来挣扎的双手\n\n失去了用来挣扎的双臂\n\n向下，\n\n向下，\n\n一直沉下去\n\n向着意识的底层\n\n沉陷下去的自我...\n\n逐渐消失的世界...\n\n我看到了世界\n\n失落的...世界...\n\n![](https://cdn.luogu.com.cn/upload/pic/21112.png)\n\n```plain\n\n   回归天空的话我就可以成为      了\n\n  开什么玩笑，你才不是什么      ！\n\n  吵死了！吵死了！我是      ！而且生来就是！\n\n就是因为这个家伙我才失去      的资格的！\n\n 呜呜呜，由岐姐姐，由岐姐姐！\n\n  ...怎么会...由岐姐...\n\n 卓司！你这家伙！\n\n        吵死了吵死了！像你这样的普通人懂些什么！\n\n   由岐的血慢慢在冰凉的水泥地上扩散开来\n\n   抱在怀里的      在渐渐地流出来        本应成为      而出生\n\n的我的被      妨碍了！\n\n不出生的话我就没法拯救是这个世界！\n\n            所以预言者说能当世界回归天空的此处就是尽头\n\n   只要      回归天空的话！\n\n 我有这么可怕吗？\n\n              因为我是要对一切生物下达审判的存在！\n\n       因为哥哥是凡人呢\n\n    凡人与天才\n\n                            救世主\n\n   世界\n\n                    救世主\n\n                回天之门\n\n  要死的是你！\n\n            我不会死               不会死       诅咒你\n\n       要死的是羽咲\n\n         只要羽咲死了\n\n                  间宫              皆\n\n                                    守           由\n\n                         岐\n\n                                间宫羽咲\n\n                          可能性\n\n                                    和镜\n\n                     终\n\n                   终之空\n\n                     空\n\n```\n\n![](https://cdn.luogu.com.cn/upload/pic/21113.png)\n\n一个婴儿出生了\n\n谁的？\n\n不知道\n\n\n虽然不知道...\n但确实有一个婴儿出生了\n\n嗯...那个婴儿在哭...\n\n呜嘎，呜嘎，地哭着...\n\n听到这个哭声大家都笑了\n\n大家都在为婴儿祝福\n\n母亲也是...\n\n父亲也是...\n\n并且其他人也是...\n\n为那个婴儿的出生...\n\n衷心祝福\n\n世界充满着生命的祝福\n\n但是\n\n但不是这样的\n\n在那里\n\n我\n\n我一个人在那里恐惧着\n\n非常恐惧...\n\n要说为什么的话...\n\n因为那是在对世界进行诅咒\n\n没错...\n\n他在诅咒着那个世界，那个刚出生的婴儿\n\n诅咒着自己的出生\n\n我\n\n我当场全身僵硬\n\n在大家的笑容之中\n\n在祝福之中\n\n独自一人...\n\n我啊...\n\n我摇摇晃晃地...\n\n接近那个婴儿\n\n然后想要让那个婴儿停止哭泣\n\n我想着必须要那样做才行\n\n为什么呢？\n\n我自己也不明白...\n\n那是\n\n那是，自从出生以来\n\n就悲惨地活到今天的我能做到的\n\n我能做到的\n\n唯一的\n\n唯一的赎罪啊。\n\n![](https://cdn.luogu.com.cn/upload/pic/21114.png)\n\n让我在这里了结了你吧…间宫卓司\n\n这里是终之空的下面吧…这不刚好吗\n\n跟我们的终结很相称不是吗…\n\n这里，是只对你而言的，终结的天空…\n\n这里就是终焉之地…\n\n![](https://cdn.luogu.com.cn/upload/pic/21115.png)\n\n“不行！绝对不行！”\n\n…为什么…跟过来了…\n\n![](https://cdn.luogu.com.cn/upload/pic/21116.png)\n\n预定…调和吗…\n\n原来如此…看来不管怎样对于你来说…我都已经毫无任何价值了对吧…\n\n竟然被这家伙打倒了…真是没办法呐…\n\n这也是现实吗…\n\n那就接受吧…\n\n![](https://cdn.luogu.com.cn/upload/pic/21117.png)\n\n不知为何，我好像看到了在夜空中挺立的向日葵…\n\n只有一瞬间…\n\n那株向日葵…\n\n好像在某个地方…\n\n向日葵…\n\n跟羽咲一起…\n\n是啊…\n\n我是哥哥啊…\n\n要是…能再多当当她的哥哥就好了……\n\n![](https://cdn.luogu.com.cn/upload/pic/21119.png)\n\n咦……\n\n刚才的…\n\n那个是…那片风景…\n\n是吗…那片风景…\n\n我也是知道的啊…\n\n在坡道途中的向日葵…\n\n蔚蓝的天空和向日葵。\n\n漂浮着大大的云朵…\n\n羽咲戴着大大的帽子…\n\n然后跟我走在一起…\n\n走着走着…\n\n为了…\n\n两人一起…\n\n爬上那个坡道…\n\n因为…那个坡道的前面有很漂亮的景色…", "description": "您正在打 galgame，然后您觉得这个 gal 不知所云，于是您弃坑了，开始写数据结构题：\n\n给一个长为 $n$ 的序列，$m$ 次操作，每次操作：\n\n1. 区间 $[l,r]$ 加 $x$；\n2. 对于区间 $[l,r]$，查询：\n\n$$a[l]^{a[l+1]^{a[l+2]^{\\dots ^{a[r]}}}} \\mod p$$", "inputFormat": "第一行两个整数 $n,m$ 表示序列长度和操作数。\n\n接下来一行，$n$ 个整数表示这个序列。\n\n接下来 $m$ 行，可能是以下两种操作之一：\n\n- $1\\ l\\ r\\ x$ 表示区间 $[l,r]$ 加上 $x$；\n- $2\\ l\\ r\\ p$ 表示对区间 $[l,r]$ 进行一次查询，模数为 $p$。", "outputFormat": "对于每个询问，输出一个数表示答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477\n\n对于100%的数据，$n , m \\le 500000$ , 序列中每个数在$[1,2\\cdot 10^9]$内，$p \\le 2 \\cdot 10^7 $, 每次加上的数在$[0,2\\cdot 10^9]$内\n\n共10组数据\n", "locale": "zh-CN", "translations": {"en": {"title": "[Ynoi Easy Round 2016] Jabberwock I", "background": "It was supper time, and the slithy skunks\nDid bore through turf and gyre ’neath the gnomon’s mark;\nThe Borogove parrot wheezed in fits, the lost green turtles\nHowled in their blind dark.\n\n“Beware the Jabberwock, my child!\nThe jaws that bite, the claws that catch!\nBeware the Jubjub bird, and shun\nThe frumious Bandersnatch!”\n\nHe took his vorpal sword in hand: long time\nThe manxome foe he sought—\nSo rested he by the Tumtum tree,\nAnd stood awhile in thought.\n\nAnd, as in uffish thought he stood,\nThe Jabberwock, with eyes of flame,\nCame whiffling through the tulgey wood,\nAnd burbled as it came!\n\nOne, two! One, two! And through and through\nThe vorpal blade went snicker-snack!\nHe left it dead, and with its head\nHe went galumphing back.\n\n“And hast thou slain the Jabberwock?\nCome to my arms, my beamish boy!\nO frabjous day! Callooh! Callay!”\nHe chortled in his joy.\n\nIt was supper time, and the slithy skunks\nDid bore through turf and gyre ’neath the gnomon’s mark;\nThe Borogove parrot wheezed in fits, the lost green turtles\nHowled in their blind dark.\n\n— “The Poem of the Jabberwock.”\n\n![](https://cdn.luogu.com.cn/upload/pic/21111.png)\n\nI shouted... but it was not human speech.\nOnly, like a sugar cube that melts as it sinks in water...\nLosing the outline of myself... sinking all the way to the very bottom.\nThe meridian that wants to climb up,\nMaintaining the continuum that I am myself...\nA dissolving, gradually scattered consciousness...\nI lost the hands used to struggle.\nI lost the arms used to struggle.\nDown,\ndown,\nkeep sinking,\ntoward the bottom layer of consciousness.\nThe self that sinks...\nA world that is gradually disappearing...\nI saw the world,\na lost... world.\n\n![](https://cdn.luogu.com.cn/upload/pic/21112.png)\n\n```plain\n\n   回归天空的话我就可以成为      了\n\n  开什么玩笑，你才不是什么      ！\n\n  吵死了！吵死了！我是      ！而且生来就是！\n\n就是因为这个家伙我才失去      的资格的！\n\n 呜呜呜，由岐姐姐，由岐姐姐！\n\n  ...怎么会...由岐姐...\n\n 卓司！你这家伙！\n\n        吵死了吵死了！像你这样的普通人懂些什么！\n\n   由岐的血慢慢在冰凉的水泥地上扩散开来\n\n   抱在怀里的      在渐渐地流出来        本应成为      而出生\n\n的我的被      妨碍了！\n\n不出生的话我就没法拯救是这个世界！\n\n            所以预言者说能当世界回归天空的此处就是尽头\n\n   只要      回归天空的话！\n\n 我有这么可怕吗？\n\n              因为我是要对一切生物下达审判的存在！\n\n       因为哥哥是凡人呢\n\n    凡人与天才\n\n                            救世主\n\n   世界\n\n                    救世主\n\n                回天之门\n\n  要死的是你！\n\n            我不会死               不会死       诅咒你\n\n       要死的是羽咲\n\n         只要羽咲死了\n\n                  间宫              皆\n\n                                    守           由\n\n                         岐\n\n                                间宫羽咲\n\n                          可能性\n\n                                    和镜\n\n                     终\n\n                   终之空\n\n                     空\n\n```\n\n![](https://cdn.luogu.com.cn/upload/pic/21113.png)\n\nA baby was born.\nWhose?\nI don’t know.\n\nAlthough I don’t know...\nA baby was indeed born.\n\nMm... that baby is crying...\nWaa, waa, crying...\n\nHearing that crying, everyone smiled.\nEveryone was blessing the baby.\nThe mother too...\nThe father too...\nAnd the others too...\nFor the baby’s birth...\nBlessing from the heart.\n\nThe world was full of the blessing of life.\n\nBut,\nit was not like that.\nThere,\nI—\nI alone was afraid there.\nVery afraid...\n\nWhy, you ask...\nBecause that was placing a curse upon the world.\n\nThat’s right...\nHe was cursing that world, that newborn baby,\nCursing his own birth.\n\nI—\nMy whole body froze on the spot.\nAmid everyone’s smiles,\nAmid the blessings,\nAll alone...\n\nI...\nI staggered...\nAnd approached that baby,\nThen tried to make that baby stop crying.\n\nI thought I had to do that.\nWhy?\nI myself did not understand...\n\nThat was—\nThat was the one thing,\nFor me, who has lived in misery since birth until today,\nThat I could do.\nWhat I could do—\nThe only,\nThe only atonement.\n\n![](https://cdn.luogu.com.cn/upload/pic/21114.png)\n\nLet me end you here... Mamiya Takuji.\nThis is below the “End Sky”... isn’t that just right.\nIt suits our ending, doesn’t it...\nHere is a sky of ending that exists only for you...\nThis is the land of the end...\n\n![](https://cdn.luogu.com.cn/upload/pic/21115.png)\n\n“No! Absolutely not!”\n...Why... did you follow me...\n\n![](https://cdn.luogu.com.cn/upload/pic/21116.png)\n\nPredestination... harmony, is it...\nI see... it looks like no matter what, to you... I’m already of no value at all, right...\nTo think I was defeated by this guy... how helpless...\nThis too is reality...\nThen I’ll accept it...\n\n![](https://cdn.luogu.com.cn/upload/pic/21117.png)\n\nFor some reason, I seemed to see a sunflower standing in the night sky...\nOnly for a moment...\nThat sunflower...\nAs if somewhere...\nA sunflower...\nTogether with Usaki...\nYeah...\nI am the older brother...\nIf only... I could be her brother a little longer...\n\n![](https://cdn.luogu.com.cn/upload/pic/21119.png)\n\nHuh...\nJust now...\nThat... that landscape...\nIs that so... that landscape...\nI know it too...\nThe sunflower halfway up the slope...\nAn azure sky and sunflowers.\nBig clouds floating...\nUsaki wearing a big hat...\nAnd walking together with me...\nWalking and walking...\nIn order to...\nThe two of us together...\nClimb that slope...\nBecause... there is a very beautiful view beyond that slope...", "description": "You are playing a galgame, but you find this gal confusing and give up. So you start writing a data structure problem instead.\n\nGiven a sequence of length $n$, there are $m$ operations. Each operation is one of the following:\n1. Add $x$ to the range $[l, r]$.\n2. For the range $[l, r]$, query\n$$a[l]^{a[l+1]^{a[l+2]^{\\dots ^{a[r]}}}} \\mod p.$$", "inputFormat": "The first line contains two integers $n, m$, the length of the sequence and the number of operations.\n\nThe second line contains $n$ integers, the sequence.\n\nEach of the next $m$ lines is one of the following two operations.\n- $1\\ l\\ r\\ x$: add $x$ to the range $[l, r]$.\n- $2\\ l\\ r\\ p$: query the range $[l, r]$ with modulus $p$.", "outputFormat": "For each query, output one number as the answer.", "hint": "Idea: nzhtl1477, Solution: nzhtl1477, Code: nzhtl1477, Data: nzhtl1477.\n\nConstraints:\n- For 100% of the testdata, $n, m \\le 500000$, each number in the sequence is in $[1, 2 \\cdot 10^9]$, $p \\le 2 \\cdot 10^7$, and each added $x$ is in $[0, 2 \\cdot 10^9]$.\n\nThere are 10 sets of testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Ynoi Easy Round 2016] 炸脖龙 I", "background": "备餐时光，软泞蜥獾\n\n草地中钻孔，日晷下打转\n\n波若歌鹦苟延残喘，迷途绿龟嚎哮迷茫\n\n“当心炸脖龙，我的孩子！\n\n那锋爪利颚，能挠钩撕咬！\n\n注意秋布秋布鸟，你需回避，\n\n那暴躁冒烟恶怪大毛怪！”\n\n手持宝剑鸣真理之语：寻觅强敌豪壮永不息——于噹噹树下稍事休憩，伫立良久，深陷思绪。\n\n当思绪纷乱杂绪之际，炸脖龙双目如烔炬，从阴暗密林奔跃闯出，一路悲鸣低吟时啭啼！\n\n一，二！一，二！一刺再刺，真理之语将敌斩成糜！\n\n取其首级，置之死地，\n\n伴随胜利，驰马归疾。\n\n“真当是你把怪龙斩于马下？\n\n奋勇吾儿！\n\n来我怀里！奔走相告！衣锦还乡！\n\n父喜不自禁窃鸣得意\n\n波若歌鹦苟延残喘，\n\n迷途绿龟嚎哮迷茫，\n\n备餐时光，软泞蜥獾\n\n草地中钻孔，日晷下打转\n\n波若歌鹦苟延残喘，\n\n迷途绿龟嚎哮迷茫”\n\n——《炸脖龙之诗》\n\n![](https://cdn.luogu.com.cn/upload/pic/21111.png)\n\n我喊了出来...却不成人话\n\n只能，像在水中一边融化一边下沉的方糖一样...\n\n失去自己的轮廓...一直沉向最低处\n\n想要爬上去的子午\n\n维持自己是自己的连续体...\n\n溶解的渐渐七零八落的意识...\n\n失去了用来挣扎的双手\n\n失去了用来挣扎的双臂\n\n向下，\n\n向下，\n\n一直沉下去\n\n向着意识的底层\n\n沉陷下去的自我...\n\n逐渐消失的世界...\n\n我看到了世界\n\n失落的...世界...\n\n![](https://cdn.luogu.com.cn/upload/pic/21112.png)\n\n```plain\n\n   回归天空的话我就可以成为      了\n\n  开什么玩笑，你才不是什么      ！\n\n  吵死了！吵死了！我是      ！而且生来就是！\n\n就是因为这个家伙我才失去      的资格的！\n\n 呜呜呜，由岐姐姐，由岐姐姐！\n\n  ...怎么会...由岐姐...\n\n 卓司！你这家伙！\n\n        吵死了吵死了！像你这样的普通人懂些什么！\n\n   由岐的血慢慢在冰凉的水泥地上扩散开来\n\n   抱在怀里的      在渐渐地流出来        本应成为      而出生\n\n的我的被      妨碍了！\n\n不出生的话我就没法拯救是这个世界！\n\n            所以预言者说能当世界回归天空的此处就是尽头\n\n   只要      回归天空的话！\n\n 我有这么可怕吗？\n\n              因为我是要对一切生物下达审判的存在！\n\n       因为哥哥是凡人呢\n\n    凡人与天才\n\n                            救世主\n\n   世界\n\n                    救世主\n\n                回天之门\n\n  要死的是你！\n\n            我不会死               不会死       诅咒你\n\n       要死的是羽咲\n\n         只要羽咲死了\n\n                  间宫              皆\n\n                                    守           由\n\n                         岐\n\n                                间宫羽咲\n\n                          可能性\n\n                                    和镜\n\n                     终\n\n                   终之空\n\n                     空\n\n```\n\n![](https://cdn.luogu.com.cn/upload/pic/21113.png)\n\n一个婴儿出生了\n\n谁的？\n\n不知道\n\n\n虽然不知道...\n但确实有一个婴儿出生了\n\n嗯...那个婴儿在哭...\n\n呜嘎，呜嘎，地哭着...\n\n听到这个哭声大家都笑了\n\n大家都在为婴儿祝福\n\n母亲也是...\n\n父亲也是...\n\n并且其他人也是...\n\n为那个婴儿的出生...\n\n衷心祝福\n\n世界充满着生命的祝福\n\n但是\n\n但不是这样的\n\n在那里\n\n我\n\n我一个人在那里恐惧着\n\n非常恐惧...\n\n要说为什么的话...\n\n因为那是在对世界进行诅咒\n\n没错...\n\n他在诅咒着那个世界，那个刚出生的婴儿\n\n诅咒着自己的出生\n\n我\n\n我当场全身僵硬\n\n在大家的笑容之中\n\n在祝福之中\n\n独自一人...\n\n我啊...\n\n我摇摇晃晃地...\n\n接近那个婴儿\n\n然后想要让那个婴儿停止哭泣\n\n我想着必须要那样做才行\n\n为什么呢？\n\n我自己也不明白...\n\n那是\n\n那是，自从出生以来\n\n就悲惨地活到今天的我能做到的\n\n我能做到的\n\n唯一的\n\n唯一的赎罪啊。\n\n![](https://cdn.luogu.com.cn/upload/pic/21114.png)\n\n让我在这里了结了你吧…间宫卓司\n\n这里是终之空的下面吧…这不刚好吗\n\n跟我们的终结很相称不是吗…\n\n这里，是只对你而言的，终结的天空…\n\n这里就是终焉之地…\n\n![](https://cdn.luogu.com.cn/upload/pic/21115.png)\n\n“不行！绝对不行！”\n\n…为什么…跟过来了…\n\n![](https://cdn.luogu.com.cn/upload/pic/21116.png)\n\n预定…调和吗…\n\n原来如此…看来不管怎样对于你来说…我都已经毫无任何价值了对吧…\n\n竟然被这家伙打倒了…真是没办法呐…\n\n这也是现实吗…\n\n那就接受吧…\n\n![](https://cdn.luogu.com.cn/upload/pic/21117.png)\n\n不知为何，我好像看到了在夜空中挺立的向日葵…\n\n只有一瞬间…\n\n那株向日葵…\n\n好像在某个地方…\n\n向日葵…\n\n跟羽咲一起…\n\n是啊…\n\n我是哥哥啊…\n\n要是…能再多当当她的哥哥就好了……\n\n![](https://cdn.luogu.com.cn/upload/pic/21119.png)\n\n咦……\n\n刚才的…\n\n那个是…那片风景…\n\n是吗…那片风景…\n\n我也是知道的啊…\n\n在坡道途中的向日葵…\n\n蔚蓝的天空和向日葵。\n\n漂浮着大大的云朵…\n\n羽咲戴着大大的帽子…\n\n然后跟我走在一起…\n\n走着走着…\n\n为了…\n\n两人一起…\n\n爬上那个坡道…\n\n因为…那个坡道的前面有很漂亮的景色…", "description": "您正在打 galgame，然后您觉得这个 gal 不知所云，于是您弃坑了，开始写数据结构题：\n\n给一个长为 $n$ 的序列，$m$ 次操作，每次操作：\n\n1. 区间 $[l,r]$ 加 $x$；\n2. 对于区间 $[l,r]$，查询：\n\n$$a[l]^{a[l+1]^{a[l+2]^{\\dots ^{a[r]}}}} \\mod p$$", "inputFormat": "第一行两个整数 $n,m$ 表示序列长度和操作数。\n\n接下来一行，$n$ 个整数表示这个序列。\n\n接下来 $m$ 行，可能是以下两种操作之一：\n\n- $1\\ l\\ r\\ x$ 表示区间 $[l,r]$ 加上 $x$；\n- $2\\ l\\ r\\ p$ 表示对区间 $[l,r]$ 进行一次查询，模数为 $p$。", "outputFormat": "对于每个询问，输出一个数表示答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477\n\n对于100%的数据，$n , m \\le 500000$ , 序列中每个数在$[1,2\\cdot 10^9]$内，$p \\le 2 \\cdot 10^7 $, 每次加上的数在$[0,2\\cdot 10^9]$内\n\n共10组数据\n", "locale": "zh-CN"}}}
{"pid": "P3935", "type": "P", "difficulty": 5, "samples": [["2 4", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "洛谷原创", "O2优化", "整除分块"], "title": "Calculating", "background": null, "description": "若 $x$ 分解质因数结果为 $x=p_1^{k_1}p_2^{k_2}\\cdots p_n^{k_n}$，令 $f(x)=(k_1+1)(k_2+1)\\cdots (k_n+1)$，求 $\\sum_{i=l}^rf(i)$ 对 $998\\,244\\,353$ 取模的结果。", "inputFormat": "输入只有一行两个整数，分别表示 $l$ 和 $r$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n| 测试点编号 | $l$ | $r$ | $r-l$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1\\sim 3$ | $1\\le l\\le 10$ | $1\\le r\\le 10$ | $r-l=0$ |\n| $4\\sim 7$ | $1\\le l\\le 50$ | $1\\le r\\le 50$ |$r-l=0$ |\n| $8\\sim 10$ | $1\\le l\\le 100$ | $1\\le r\\le 100$ |$r-l<50$ |\n| $11\\sim 16$ | $1\\le l\\le 500$ | $1\\le r\\le 500$ | 无特殊限制 |\n| $17\\sim 25$ | $1\\le l \\le 10^3$ | $1\\le r \\le 10^3$ | 无特殊限制 |\n| $26\\sim 30$ | $1\\le l \\le 5\\times 10^3$ | $1\\le r \\le 5\\times 10^3$ | $r-l<100$ |\n| $31\\sim 40$ | $1\\le l \\le 10^4$ | $1\\le r \\le 10^4$ |无特殊限制  |\n| $41\\sim 60$ | $1\\le l \\le 10^7$ | $1\\le r \\le 10^7$ | 无特殊限制 |\n| $61\\sim 70$ | $1\\le l \\le 10^9$ | $1\\le r \\le 10^9$ | 无特殊限制 |\n| $71\\sim 90$ | $1\\le l \\le 10^{12}$ | $1\\le r \\le 10^{12}$ | 无特殊限制 |\n| $91\\sim 95$ | $1\\le l \\le 10^{13}$ | $1\\le r \\le 10^{13}$ | 无特殊限制 |\n| $96\\sim 97$ | $1\\le l \\le 2\\times 10^{13}$ | $1\\le r \\le 2\\times 10^{13}$ | $r-l<10^{13}$ |\n| $98\\sim 99$ | $1\\le l \\le 10^{13}$ | $1\\le r \\le 10^{14}$ | $r-l>9\\times 10^{13}$ |\n| $100$ | $1\\le l \\le 10^{14}$ | $1\\le r \\le 1.6\\times 10^{14}$ | $r-l>10^{14}$ |", "locale": "zh-CN", "translations": {"en": {"title": "Calculating", "background": "", "description": "If the prime factorization of $x$ is $x=p_1^{k_1}p_2^{k_2}\\cdots p_n^{k_n}$, define $f(x)=(k_1+1)(k_2+1)\\cdots (k_n+1)$. Compute $\\sum_{i=l}^r f(i)$ modulo $998\\,244\\,353$.", "inputFormat": "The input contains a single line with two integers, representing $l$ and $r$.", "outputFormat": "Output a single integer on one line representing the answer.", "hint": "#### Constraints and Conventions\n\n| Test point ID | $l$ | $r$ | $r-l$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1\\sim 3$ | $1\\le l\\le 10$ | $1\\le r\\le 10$ | $r-l=0$ |\n| $4\\sim 7$ | $1\\le l\\le 50$ | $1\\le r\\le 50$ | $r-l=0$ |\n| $8\\sim 10$ | $1\\le l\\le 100$ | $1\\le r\\le 100$ | $r-l<50$ |\n| $11\\sim 16$ | $1\\le l\\le 500$ | $1\\le r\\le 500$ | No special restriction |\n| $17\\sim 25$ | $1\\le l \\le 10^3$ | $1\\le r \\le 10^3$ | No special restriction |\n| $26\\sim 30$ | $1\\le l \\le 5\\times 10^3$ | $1\\le r \\le 5\\times 10^3$ | $r-l<100$ |\n| $31\\sim 40$ | $1\\le l \\le 10^4$ | $1\\le r \\le 10^4$ | No special restriction |\n| $41\\sim 60$ | $1\\le l \\le 10^7$ | $1\\le r \\le 10^7$ | No special restriction |\n| $61\\sim 70$ | $1\\le l \\le 10^9$ | $1\\le r \\le 10^9$ | No special restriction |\n| $71\\sim 90$ | $1\\le l \\le 10^{12}$ | $1\\le r \\le 10^{12}$ | No special restriction |\n| $91\\sim 95$ | $1\\le l \\le 10^{13}$ | $1\\le r \\le 10^{13}$ | No special restriction |\n| $96\\sim 97$ | $1\\le l \\le 2\\times 10^{13}$ | $1\\le r \\le 2\\times 10^{13}$ | $r-l<10^{13}$ |\n| $98\\sim 99$ | $1\\le l \\le 10^{13}$ | $1\\le r \\le 10^{14}$ | $r-l>9\\times 10^{13}$ |\n| $100$ | $1\\le l \\le 10^{14}$ | $1\\le r \\le 1.6\\times 10^{14}$ | $r-l>10^{14}$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Calculating", "background": null, "description": "若 $x$ 分解质因数结果为 $x=p_1^{k_1}p_2^{k_2}\\cdots p_n^{k_n}$，令 $f(x)=(k_1+1)(k_2+1)\\cdots (k_n+1)$，求 $\\sum_{i=l}^rf(i)$ 对 $998\\,244\\,353$ 取模的结果。", "inputFormat": "输入只有一行两个整数，分别表示 $l$ 和 $r$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n| 测试点编号 | $l$ | $r$ | $r-l$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1\\sim 3$ | $1\\le l\\le 10$ | $1\\le r\\le 10$ | $r-l=0$ |\n| $4\\sim 7$ | $1\\le l\\le 50$ | $1\\le r\\le 50$ |$r-l=0$ |\n| $8\\sim 10$ | $1\\le l\\le 100$ | $1\\le r\\le 100$ |$r-l<50$ |\n| $11\\sim 16$ | $1\\le l\\le 500$ | $1\\le r\\le 500$ | 无特殊限制 |\n| $17\\sim 25$ | $1\\le l \\le 10^3$ | $1\\le r \\le 10^3$ | 无特殊限制 |\n| $26\\sim 30$ | $1\\le l \\le 5\\times 10^3$ | $1\\le r \\le 5\\times 10^3$ | $r-l<100$ |\n| $31\\sim 40$ | $1\\le l \\le 10^4$ | $1\\le r \\le 10^4$ |无特殊限制  |\n| $41\\sim 60$ | $1\\le l \\le 10^7$ | $1\\le r \\le 10^7$ | 无特殊限制 |\n| $61\\sim 70$ | $1\\le l \\le 10^9$ | $1\\le r \\le 10^9$ | 无特殊限制 |\n| $71\\sim 90$ | $1\\le l \\le 10^{12}$ | $1\\le r \\le 10^{12}$ | 无特殊限制 |\n| $91\\sim 95$ | $1\\le l \\le 10^{13}$ | $1\\le r \\le 10^{13}$ | 无特殊限制 |\n| $96\\sim 97$ | $1\\le l \\le 2\\times 10^{13}$ | $1\\le r \\le 2\\times 10^{13}$ | $r-l<10^{13}$ |\n| $98\\sim 99$ | $1\\le l \\le 10^{13}$ | $1\\le r \\le 10^{14}$ | $r-l>9\\times 10^{13}$ |\n| $100$ | $1\\le l \\le 10^{14}$ | $1\\le r \\le 1.6\\times 10^{14}$ | $r-l>10^{14}$ |", "locale": "zh-CN"}}}
{"pid": "P3936", "type": "P", "difficulty": 6, "samples": [["2 3 3\n1 2 3", "2 3 1\n2 3 3"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "洛谷原创", "Special Judge", "模拟退火"], "title": "Coloring", "background": null, "description": "$\\text{Snakes}$ 正在玩游戏，他在一张画有 $n\\times m$ 个格子的白纸上给方格染色。然而，杂乱无章的染色并不有趣，所以他想出了一个奇怪的问题：\n\n\n在 $n\\times m$ 的方格中用 $c$ 种不同的颜色尝试将所有方格染色，不同的颜色用 $1...c$ 间的整数表示。染色需要满足以下条件：\n\n\n+ 每个方格只能且必须染一种颜色。\n\n+ 第 $i$ 种颜色最多可以且必须染 $p_i$ 个格子，保证满足 $\\sum_{i=1}^cp_i=n\\times m$。\n\n+ 将每个格子上下左右与其颜色相同的格子视为位于同一个联通块内，并定义不同联通块之间的方格边的条数为 $q$。可参考样例说明。\n\n\n现在，$\\text{Snakes}$ 想知道，如果给出 $n,m,c$ 以及 $p_1...p_c$，你能够构造出的符合条件且 $q$ 尽量小的染色方案。", "inputFormat": "第一行，三个数，$n,m,c$。\n\n\n第二行，$c$ 个数，第 $i$ 个数为 $p_i$。", "outputFormat": "输出共 $n$ 行，每行 $m$ 个数，表示你构造出的 $n\\times m$ 的 $q$ 尽量少的染色方案。", "hint": "```plain\n   |   |   \n 2 | 3 | 1 \n   +   +---\n 2 | 3   3 \n   |       \n```\n\n对于样例，有 $q=4$，其中三条竖边，一条横边。\n\n\n#### 约定\n\n\n本题为 Special Judge。\n\n\n对于每个测试点，将会设置阈值 $w$，并保证存在构造使得 $q\\leq w$。\n\n\n对于程序输出的答案，我们将会以以下方式计算得分：\n\n\n$$\\begin{matrix}q&score&q&score\\\\\\\\ q \\leq w&10&1.75w < q \\leq 2w&5\\\\\\\\ w < q \\leq 1.1w&9&2w < q \\leq 2.3w&4\\\\\\\\ 1.1w < q \\leq 1.25w&8&2.3w < q \\leq 2.6w&3\\\\\\\\ 1.25w < q \\leq 1.5w&7&2.6w < q \\leq 3w&2\\\\\\\\ 1.5w < q \\leq 1.75w&6&3w < q \\leq 3.5w&1\\end{matrix}$$\n\n\n若$q > 3.5w$，将以 `Wrong Answer` 处理。\n\n\n比赛时显示的得分即为最后得分。\n\n\n#### 数据规模\n\n\n对于 $10\\%$ 的数据，有 $1\\leq n,m\\leq 3$，$c\\leq 3$。\n\n\n对于 $30\\%$ 的数据，有 $1\\leq n,m\\leq 8$，$c\\leq 6$。\n\n\n对于 $50\\%$ 的数据，有 $1\\leq n,m\\leq 15$，$c\\leq 25$。\n\n\n对于 $100\\%$ 的数据，有 $1\\leq n,m\\leq 20$，$c\\leq 50$，$p_i\\leq 20$。", "locale": "zh-CN", "translations": {"en": {"title": "Coloring", "background": "", "description": "$\\text{Snakes}$ is playing a game where he colors squares on a white paper with $n\\times m$ grid cells. However, messy coloring is not fun, so he came up with a peculiar problem:\n\nIn an $n\\times m$ grid, use $c$ different colors to try to color all cells. Different colors are represented by integers in $1...c$. The coloring must satisfy the following conditions:\n\n+ Each cell must be colored in exactly one color.\n\n+ Color $i$ must color exactly $p_i$ cells. It is guaranteed that $\\sum_{i=1}^c p_i = n\\times m$.\n\n+ Consider cells that are adjacent up, down, left, or right and have the same color to be in the same connected component, and define $q$ as the number of grid edges between different connected components. See the sample explanation.\n\nNow, $\\text{Snakes}$ wants to know, given $n$, $m$, $c$ and $p_1...p_c$, whether you can construct a valid coloring that makes $q$ as small as possible.", "inputFormat": "The first line contains three numbers, $n,m,c$.\n\nThe second line contains $c$ numbers, where the $i$-th number is $p_i$.", "outputFormat": "Output $n$ lines, each containing $m$ numbers, representing your constructed $n\\times m$ coloring with $q$ as small as possible.", "hint": "```plain\n   |   |   \n 2 | 3 | 1 \n   +   +---\n 2 | 3   3 \n   |       \n```\n\nFor the sample, $q=4$, consisting of three vertical edges and one horizontal edge.\n\n#### Conventions\n\nThis problem is Special Judge.\n\nFor each test point, a threshold $w$ is set, and it is guaranteed that there exists a construction such that $q\\leq w$.\n\nThe score for your output will be computed as follows:\n\n$$\\begin{matrix}q&score&q&score\\\\\\\\ q \\leq w&10&1.75w < q \\leq 2w&5\\\\\\\\ w < q \\leq 1.1w&9&2w < q \\leq 2.3w&4\\\\\\\\ 1.1w < q \\leq 1.25w&8&2.3w < q \\leq 2.6w&3\\\\\\\\ 1.25w < q \\leq 1.5w&7&2.6w < q \\leq 3w&2\\\\\\\\ 1.5w < q \\leq 1.75w&6&3w < q \\leq 3.5w&1\\end{matrix}$$\n\nIf $q > 3.5w$, it will be judged as `Wrong Answer`.\n\nThe score shown during the contest is the final score.\n\n#### Constraints\n\nFor $10\\%$ of the testdata, $1\\leq n,m\\leq 3$, $c\\leq 3$.\n\nFor $30\\%$ of the testdata, $1\\leq n,m\\leq 8$, $c\\leq 6$.\n\nFor $50\\%$ of the testdata, $1\\leq n,m\\leq 15$, $c\\leq 25$.\n\nFor $100\\%$ of the testdata, $1\\leq n,m\\leq 20$, $c\\leq 50$, $p_i\\leq 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Coloring", "background": null, "description": "$\\text{Snakes}$ 正在玩游戏，他在一张画有 $n\\times m$ 个格子的白纸上给方格染色。然而，杂乱无章的染色并不有趣，所以他想出了一个奇怪的问题：\n\n\n在 $n\\times m$ 的方格中用 $c$ 种不同的颜色尝试将所有方格染色，不同的颜色用 $1...c$ 间的整数表示。染色需要满足以下条件：\n\n\n+ 每个方格只能且必须染一种颜色。\n\n+ 第 $i$ 种颜色最多可以且必须染 $p_i$ 个格子，保证满足 $\\sum_{i=1}^cp_i=n\\times m$。\n\n+ 将每个格子上下左右与其颜色相同的格子视为位于同一个联通块内，并定义不同联通块之间的方格边的条数为 $q$。可参考样例说明。\n\n\n现在，$\\text{Snakes}$ 想知道，如果给出 $n,m,c$ 以及 $p_1...p_c$，你能够构造出的符合条件且 $q$ 尽量小的染色方案。", "inputFormat": "第一行，三个数，$n,m,c$。\n\n\n第二行，$c$ 个数，第 $i$ 个数为 $p_i$。", "outputFormat": "输出共 $n$ 行，每行 $m$ 个数，表示你构造出的 $n\\times m$ 的 $q$ 尽量少的染色方案。", "hint": "```plain\n   |   |   \n 2 | 3 | 1 \n   +   +---\n 2 | 3   3 \n   |       \n```\n\n对于样例，有 $q=4$，其中三条竖边，一条横边。\n\n\n#### 约定\n\n\n本题为 Special Judge。\n\n\n对于每个测试点，将会设置阈值 $w$，并保证存在构造使得 $q\\leq w$。\n\n\n对于程序输出的答案，我们将会以以下方式计算得分：\n\n\n$$\\begin{matrix}q&score&q&score\\\\\\\\ q \\leq w&10&1.75w < q \\leq 2w&5\\\\\\\\ w < q \\leq 1.1w&9&2w < q \\leq 2.3w&4\\\\\\\\ 1.1w < q \\leq 1.25w&8&2.3w < q \\leq 2.6w&3\\\\\\\\ 1.25w < q \\leq 1.5w&7&2.6w < q \\leq 3w&2\\\\\\\\ 1.5w < q \\leq 1.75w&6&3w < q \\leq 3.5w&1\\end{matrix}$$\n\n\n若$q > 3.5w$，将以 `Wrong Answer` 处理。\n\n\n比赛时显示的得分即为最后得分。\n\n\n#### 数据规模\n\n\n对于 $10\\%$ 的数据，有 $1\\leq n,m\\leq 3$，$c\\leq 3$。\n\n\n对于 $30\\%$ 的数据，有 $1\\leq n,m\\leq 8$，$c\\leq 6$。\n\n\n对于 $50\\%$ 的数据，有 $1\\leq n,m\\leq 15$，$c\\leq 25$。\n\n\n对于 $100\\%$ 的数据，有 $1\\leq n,m\\leq 20$，$c\\leq 50$，$p_i\\leq 20$。", "locale": "zh-CN"}}}
{"pid": "P3937", "type": "P", "difficulty": 5, "samples": [["4 2 1\n1 0 1 0", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "洛谷原创", "进制", "组合数学"], "title": "Changing", "background": "", "description": "有 $n$ 盏灯环形排列，顺时针依次标号为 $1\\cdots n$。初始时刻为 $0$，初始时刻第 $i$ 盏灯的亮灭 $a_i$ 给定，$0$ 表示灭，$1$ 表示亮。下一时刻每盏灯的亮灭取决于当前时刻这盏灯与顺时针方向下一盏灯的亮灭。若两盏灯状态相同，则下一时刻该灯灭，否则该灯亮。\n\n\n试求时刻 $t$ 第 $k$ 盏灯的状态。\n", "inputFormat": "第一行，三个整数，分别为 $n, t, k$。\n\n\n第二行，共 $n$ 个整数，分别为 $0$ 或 $1$，代表 $a_i$。\n", "outputFormat": "共一行，一个数，$0$ 或 $1$，代表时刻 $t$ 第 $k$ 盏灯的状态。\n", "hint": "- 对于 $25\\%$ 的数据，有$1\\leq t, k\\leq n\\leq 1000$。 \n- 对于 $60\\%$ 的数据，有$1\\leq t, k\\leq n\\leq 10^5$。 \n- 对于 $100\\%$ 的数据，有$1\\leq t, k\\leq n\\leq 3\\times 10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Changing", "background": "", "description": "There are $n$ lamps arranged in a circle, labeled clockwise as $1 \\cdots n$. The initial time is $0$. At the initial time, the on/off state $a_i$ of the $i$-th lamp is given, where $0$ means off and $1$ means on. At the next time, each lamp’s state depends on the current state of this lamp and the next lamp in the clockwise direction. If the two lamps have the same state, then at the next time this lamp is off; otherwise, it is on.\n\nFind the state of the $k$-th lamp at time $t$.", "inputFormat": "The first line contains three integers $n$, $t$, $k$.\n\nThe second line contains $n$ integers, each being $0$ or $1$, representing $a_i$.", "outputFormat": "Output one line with a single number, $0$ or $1$, representing the state of the $k$-th lamp at time $t$.", "hint": "- For $25\\%$ of the testdata, $1 \\leq t, k \\leq n \\leq 1000$.\n- For $60\\%$ of the testdata, $1 \\leq t, k \\leq n \\leq 10^5$.\n- For $100\\%$ of the testdata, $1 \\leq t, k \\leq n \\leq 3 \\times 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Changing", "background": "", "description": "有 $n$ 盏灯环形排列，顺时针依次标号为 $1\\cdots n$。初始时刻为 $0$，初始时刻第 $i$ 盏灯的亮灭 $a_i$ 给定，$0$ 表示灭，$1$ 表示亮。下一时刻每盏灯的亮灭取决于当前时刻这盏灯与顺时针方向下一盏灯的亮灭。若两盏灯状态相同，则下一时刻该灯灭，否则该灯亮。\n\n\n试求时刻 $t$ 第 $k$ 盏灯的状态。\n", "inputFormat": "第一行，三个整数，分别为 $n, t, k$。\n\n\n第二行，共 $n$ 个整数，分别为 $0$ 或 $1$，代表 $a_i$。\n", "outputFormat": "共一行，一个数，$0$ 或 $1$，代表时刻 $t$ 第 $k$ 盏灯的状态。\n", "hint": "- 对于 $25\\%$ 的数据，有$1\\leq t, k\\leq n\\leq 1000$。 \n- 对于 $60\\%$ 的数据，有$1\\leq t, k\\leq n\\leq 10^5$。 \n- 对于 $100\\%$ 的数据，有$1\\leq t, k\\leq n\\leq 3\\times 10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P3938", "type": "P", "difficulty": 4, "samples": [["5 \n1 1 \n2 3 \n5 7 \n7 13 \n4 12", "1 \n1 \n2 \n2 \n4 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "二分", "O2优化", "最近公共祖先 LCA", "Fibonacci 数列"], "title": "斐波那契", "background": "大样例可在页面底部「附件」中下载。", "description": "小 C 养了一些很可爱的兔子。 有一天，小 C 突然发现兔子们都是严格按照伟大的数学家斐波那契提出的模型来进行 繁衍：一对兔子从出生后第二个月起，每个月刚开始的时候都会产下一对小兔子。我们假定， 在整个过程中兔子不会出现任何意外。\n\n小 C 把兔子按出生顺序，把兔子们从 1 开始标号，并且小 C 的兔子都是 1 号兔子和 1 号兔子的后代。如果某两对兔子是同时出生的，那么小 C 会将父母标号更小的一对优先标 号。\n\n如果我们把这种关系用图画下来，前六个月大概就是这样的：\n\n \n  ![](https://cdn.luogu.com.cn/upload/pic/9806.png) \n\n其中，一个箭头 $A \\to B$ 表示 $A$ 是 $B$ 的祖先，相同的颜色表示同一个月出生的兔子。\n\n为了更细致地了解兔子们是如何繁衍的，小 C 找来了一些兔子，并且向你提出了 $m$ 个问题：她想知道关于每两对兔子 $a_i$ 和 $b_i$，他们的最近公共祖先是谁。你能帮帮小 C 吗？\n\n一对兔子的祖先是这对兔子以及他们父母（如果有的话）的祖先，而最近公共祖先是指 两对兔子所共有的祖先中，离他们的距离之和最近的一对兔子。比如，$5$ 和 $7$ 的最近公共祖 先是 $2,1$ 和 $2$ 的最近公共祖先是 $1,6$ 和 $6$ 的最近公共祖先是 $6$。\n", "inputFormat": "输入第一行，包含一个正整数 $m$。输入接下来 $m$ 行，每行包含 $2$ 个正整数，表示 $a_i$ 和 $b_i$。\n", "outputFormat": "输出一共 $m$ 行，每行一个正整数，依次表示你对问题的答案。\n", "hint": "【数据范围与约定】 子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。 每个测试点的数据规模及特点如下表：\n\n ![](https://cdn.luogu.com.cn/upload/pic/9807.png) \n\n特殊性质 $1$：保证 $a_i$, $b_i$ 均为某一个月出生的兔子中标号最大的一对兔子。例如，对 于前六个月，标号最大的兔子分别是 $1, 2, 3, 5, 8, 13$。\n\n特殊性质 $2$：保证 $|a_i-b_i|\\le 1$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Fibonacci", "background": "The large sample can be downloaded in Attachments at the bottom of the page.", "description": "Xiao C (pinyin) keeps some very cute rabbits. One day, Xiao C suddenly discovered that the rabbits reproduce strictly according to the model proposed by the great mathematician Fibonacci: starting from the second month after birth, at the beginning of each month a pair of rabbits gives birth to one new pair. We assume that no accidents occur during the entire process.\n\nXiao C numbers the rabbit pairs in order of birth starting from 1, and all the rabbits are the No. 1 pair and its descendants. If two pairs of rabbits are born at the same time, Xiao C assigns numbers first to the pair whose parents have smaller labels.\n\nIf we draw this relationship as a graph, the first six months look roughly like this:\n\n![](https://cdn.luogu.com.cn/upload/pic/9806.png)\n\nHere, an arrow $A \\to B$ means that $A$ is an ancestor of $B$, and the same color indicates that the pairs were born in the same month.\n\nTo understand the reproduction in more detail, Xiao C picked some pairs of rabbits and asked you $m$ questions: for each two pairs of rabbits $a_i$ and $b_i$, she wants to know their lowest common ancestor. Can you help Xiao C?\n\nAn ancestor of a pair is the pair itself and the ancestors of its parents (if any). The lowest common ancestor (LCA) is the common ancestor of the two pairs that minimizes the sum of distances to them. For example, the LCA of $5$ and $7$ is $2$, the LCA of $1$ and $2$ is $1$, and the LCA of $6$ and $6$ is $6$.\n\n# Description", "inputFormat": "The first line contains a positive integer $m$. Each of the next $m$ lines contains $2$ positive integers, representing $a_i$ and $b_i$.", "outputFormat": "Output $m$ lines. Each line contains one positive integer, in order, representing your answer to the corresponding query.", "hint": "Constraints and Conventions. Subtasks provide characteristics of some testdata. If you encounter difficulties, you may try to solve only part of the testdata. The scale and characteristics of each test point are shown in the table below:\n\n![](https://cdn.luogu.com.cn/upload/pic/9807.png)\n\nSpecial property 1: It is guaranteed that $a_i$ and $b_i$ are both the pair with the largest label among those born in some month. For example, for the first six months, the largest labels are $1, 2, 3, 5, 8, 13$.\n\nSpecial property 2: It is guaranteed that $|a_i-b_i|\\le 1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "斐波那契", "background": "大样例可在页面底部「附件」中下载。", "description": "小 C 养了一些很可爱的兔子。 有一天，小 C 突然发现兔子们都是严格按照伟大的数学家斐波那契提出的模型来进行 繁衍：一对兔子从出生后第二个月起，每个月刚开始的时候都会产下一对小兔子。我们假定， 在整个过程中兔子不会出现任何意外。\n\n小 C 把兔子按出生顺序，把兔子们从 1 开始标号，并且小 C 的兔子都是 1 号兔子和 1 号兔子的后代。如果某两对兔子是同时出生的，那么小 C 会将父母标号更小的一对优先标 号。\n\n如果我们把这种关系用图画下来，前六个月大概就是这样的：\n\n \n  ![](https://cdn.luogu.com.cn/upload/pic/9806.png) \n\n其中，一个箭头 $A \\to B$ 表示 $A$ 是 $B$ 的祖先，相同的颜色表示同一个月出生的兔子。\n\n为了更细致地了解兔子们是如何繁衍的，小 C 找来了一些兔子，并且向你提出了 $m$ 个问题：她想知道关于每两对兔子 $a_i$ 和 $b_i$，他们的最近公共祖先是谁。你能帮帮小 C 吗？\n\n一对兔子的祖先是这对兔子以及他们父母（如果有的话）的祖先，而最近公共祖先是指 两对兔子所共有的祖先中，离他们的距离之和最近的一对兔子。比如，$5$ 和 $7$ 的最近公共祖 先是 $2,1$ 和 $2$ 的最近公共祖先是 $1,6$ 和 $6$ 的最近公共祖先是 $6$。\n", "inputFormat": "输入第一行，包含一个正整数 $m$。输入接下来 $m$ 行，每行包含 $2$ 个正整数，表示 $a_i$ 和 $b_i$。\n", "outputFormat": "输出一共 $m$ 行，每行一个正整数，依次表示你对问题的答案。\n", "hint": "【数据范围与约定】 子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。 每个测试点的数据规模及特点如下表：\n\n ![](https://cdn.luogu.com.cn/upload/pic/9807.png) \n\n特殊性质 $1$：保证 $a_i$, $b_i$ 均为某一个月出生的兔子中标号最大的一对兔子。例如，对 于前六个月，标号最大的兔子分别是 $1, 2, 3, 5, 8, 13$。\n\n特殊性质 $2$：保证 $|a_i-b_i|\\le 1$。\n", "locale": "zh-CN"}}}
{"pid": "P3939", "type": "P", "difficulty": 4, "samples": [["6 5 \n1 2 3 2 3 3  \n1 1 3 2 \n1 4 6 3  \n2 3 \n1 1 3 2  \n1 4 6 3", "1 \n2 \n2 \n3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["线段树", "二分", "O2优化", "可持久化线段树"], "title": "数颜色", "background": "大样例可在页面底部「附件」中下载。", "description": "小 C 的兔子不是雪白的，而是五彩缤纷的。每只兔子都有一种颜色，不同的兔子可能有相同的颜色。小 C 把她标号从 1 到 $n$ 的 $n$ 只兔子排成长长的一排，来给他们喂胡萝卜吃。排列完成后，第 $i$ 只兔子的颜色是 $a_i$。\n\n俗话说得好，“萝卜青菜，各有所爱”。小 C 发现，不同颜色的兔子可能有对胡萝卜的不同偏好。比如，银色的兔子最喜欢吃金色的胡萝卜，金色的兔子更喜欢吃胡萝卜叶子，而绿色的兔子却喜欢吃酸一点的胡萝卜……为了满足兔子们的要求，小 C 十分苦恼。所以，为了使得胡萝卜喂得更加准确，小 C 想知道在区间 $[l_j,r_j]$ 里有多少只颜色为 $c_j$ 的兔子。\n\n不过，因为小 C 的兔子们都十分地活跃，它们不是很愿意待在一个固定的位置；与此同时，小 C 也在根据她知道的信息来给兔子们调整位置。所以，有时编号为 $x_j$ 和 $x_j+1$ 的两只兔子会交换位置。小 C 被这一系列麻烦事给难住了。你能帮帮她吗？", "inputFormat": "从标准输入中读入数据。输入第 1 行两个正整数 $n$,$m$。\n\n输入第 2 行 $n$ 个正整数，第 $i$ 个数表示第 $i$ 只兔子的颜色 $a_i$。\n\n输入接下来 $m$ 行，每行为以下两种中的一种：\n\n- “$1\\ l_j\\ r_j\\ c_j$” ：询问在区间 $[l_j,r_j]$ 里有多少只颜色为 $c_j$ 的兔子；\n\n- “$2\\ x_j$”： $x_j$ 和 $x_j+1$ 两只兔子交换了位置。", "outputFormat": "输出到标准输出中。\n\n对于每个 1 操作，输出一行一个正整数，表示你对于这个询问的答案。", "hint": "【样例 1 说明】\n\n前两个 1 操作和后两个 1 操作对应相同；在第三次的 2 操作后，3 号兔子和 4 号兔子\n\n交换了位置，序列变为 1 2 2 3 3 3。\n\n【数据范围与约定】\n\n子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解 决一部分测试数据。 对于所有测试点，有 $1 \\le l_j < r_j \\le n,1 \\le x_j < n$。 每个测试点的数据规模及特点如下表：\n\n ![](https://cdn.luogu.com.cn/upload/pic/9808.png) \n\n特殊性质 1：保证对于所有操作 1，有 $|r_j - l_j| \\le 20$ 或 $|r_j - l_j| \\le n - 20$。\n\n特殊性质 2：保证不会有两只相同颜色的兔子。", "locale": "zh-CN", "translations": {"en": {"title": "Counting Colors", "background": "Large samples can be downloaded from “Attachments” at the bottom of the page.", "description": "Xiao C’s rabbits are not snow-white, but colorful. Each rabbit has a color, and different rabbits may share the same color. Xiao C lines up her $n$ rabbits, numbered from $1$ to $n$, in a long row to feed them carrots. After arranging, the color of the $i$-th rabbit is $a_i$.\n\nAs the saying goes, “Different strokes for different folks.” Xiao C finds that rabbits of different colors may have different preferences for carrots. For example, silver rabbits like golden carrots the most, golden rabbits prefer carrot leaves, while green rabbits like sour carrots... To satisfy the rabbits’ needs, Xiao C is quite troubled. Therefore, to feed carrots more accurately, Xiao C wants to know how many rabbits of color $c_j$ are in the interval $[l_j, r_j]$.\n\nHowever, Xiao C’s rabbits are very active and are not willing to stay in fixed positions; meanwhile, Xiao C also rearranges the rabbits based on what she knows. So, sometimes the rabbits numbered $x_j$ and $x_j + 1$ will swap positions. Xiao C is overwhelmed by this series of hassles. Can you help her?", "inputFormat": "Read from standard input. The first line contains two positive integers $n, m$.\n\nThe second line contains $n$ positive integers; the $i$-th number denotes the color $a_i$ of the $i$-th rabbit.\n\nThe next $m$ lines each describe one of the following two types of operations:\n- “$1\\ l_j\\ r_j\\ c_j$”: Query how many rabbits of color $c_j$ are in the interval $[l_j, r_j]$.\n- “$2\\ x_j$”: The rabbits numbered $x_j$ and $x_j + 1$ swap positions.", "outputFormat": "Print to standard output.\n\nFor each type-1 operation, output one positive integer on a separate line, which is the answer to that query.", "hint": "[Sample 1 Explanation]\n\nThe first two type-1 operations and the last two type-1 operations are the same queries. After the third type-2 operation, rabbit $3$ and rabbit $4$ swap positions, and the sequence becomes 1 2 2 3 3 3.\n\n[Constraints]\n\nSubtasks provide characteristics of partial testdata. If you encounter difficulties, you can try to solve only part of the testdata. For all test points, $1 \\le l_j < r_j \\le n$, $1 \\le x_j < n$. The scale and characteristics of each test point are shown in the following table:\n\n![](https://cdn.luogu.com.cn/upload/pic/9808.png)\n\nSpecial Property 1: For all type-1 operations, it is guaranteed that either $|r_j - l_j| \\le 20$ or $|r_j - l_j| \\le n - 20$.\n\nSpecial Property 2: It is guaranteed that no two rabbits have the same color.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数颜色", "background": "大样例可在页面底部「附件」中下载。", "description": "小 C 的兔子不是雪白的，而是五彩缤纷的。每只兔子都有一种颜色，不同的兔子可能有相同的颜色。小 C 把她标号从 1 到 $n$ 的 $n$ 只兔子排成长长的一排，来给他们喂胡萝卜吃。排列完成后，第 $i$ 只兔子的颜色是 $a_i$。\n\n俗话说得好，“萝卜青菜，各有所爱”。小 C 发现，不同颜色的兔子可能有对胡萝卜的不同偏好。比如，银色的兔子最喜欢吃金色的胡萝卜，金色的兔子更喜欢吃胡萝卜叶子，而绿色的兔子却喜欢吃酸一点的胡萝卜……为了满足兔子们的要求，小 C 十分苦恼。所以，为了使得胡萝卜喂得更加准确，小 C 想知道在区间 $[l_j,r_j]$ 里有多少只颜色为 $c_j$ 的兔子。\n\n不过，因为小 C 的兔子们都十分地活跃，它们不是很愿意待在一个固定的位置；与此同时，小 C 也在根据她知道的信息来给兔子们调整位置。所以，有时编号为 $x_j$ 和 $x_j+1$ 的两只兔子会交换位置。小 C 被这一系列麻烦事给难住了。你能帮帮她吗？", "inputFormat": "从标准输入中读入数据。输入第 1 行两个正整数 $n$,$m$。\n\n输入第 2 行 $n$ 个正整数，第 $i$ 个数表示第 $i$ 只兔子的颜色 $a_i$。\n\n输入接下来 $m$ 行，每行为以下两种中的一种：\n\n- “$1\\ l_j\\ r_j\\ c_j$” ：询问在区间 $[l_j,r_j]$ 里有多少只颜色为 $c_j$ 的兔子；\n\n- “$2\\ x_j$”： $x_j$ 和 $x_j+1$ 两只兔子交换了位置。", "outputFormat": "输出到标准输出中。\n\n对于每个 1 操作，输出一行一个正整数，表示你对于这个询问的答案。", "hint": "【样例 1 说明】\n\n前两个 1 操作和后两个 1 操作对应相同；在第三次的 2 操作后，3 号兔子和 4 号兔子\n\n交换了位置，序列变为 1 2 2 3 3 3。\n\n【数据范围与约定】\n\n子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解 决一部分测试数据。 对于所有测试点，有 $1 \\le l_j < r_j \\le n,1 \\le x_j < n$。 每个测试点的数据规模及特点如下表：\n\n ![](https://cdn.luogu.com.cn/upload/pic/9808.png) \n\n特殊性质 1：保证对于所有操作 1，有 $|r_j - l_j| \\le 20$ 或 $|r_j - l_j| \\le n - 20$。\n\n特殊性质 2：保证不会有两只相同颜色的兔子。", "locale": "zh-CN"}}}
{"pid": "P3940", "type": "P", "difficulty": 6, "samples": [["5 2 \n1 3 15 10 6", "2\n1 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "O2优化"], "title": "分组", "background": "大样例可在页面底部「附件」中下载。\n", "description": "小 C 在了解了她所需要的信息之后，让兔子们调整到了恰当的位置。小 C 准备给兔子 们分成若干个小组来喂恰当的胡萝卜给兔子们吃。\n\n此时， $n$ 只兔子按一定顺序排成一排，第 $i$ 只兔子的颜色是 $a_i$ 。由于顺序已经是被 调整好了的，所以每个小组都应当是序列上连续的一段。\n\n在分组前，小 C 发现了一个规律：有些兔子会两两发生矛盾。并且，两只兔子会发生矛 盾，当且仅当代表他们的颜色的数值之和为一个正整数的平方。比如，1 色兔子和 2 色兔子 不会发生矛盾，因为 3 不是任何一个正整数的平方；而 1 色兔子却会和 3 色兔子发生矛盾， 因为 $4 = 2^2$。\n\n小 C 认为，只要一个小组内的矛盾不要过大就行。因此，小 C 定义了一个小组的矛盾 值 $k$ ，表示在这个小组里，至少需要将这个组再一次分成 $k$ 个小团体；每个小团体并不需 要是序列上连续的一段，但是需要使得每个小团体内任意两只兔子之间都不会发生矛盾。\n\n小 C 要求，矛盾值最大的小组的矛盾值 $k$ 不超过 $K$ 就可以了。当然，这样的分组方 法可能会有很多个；为了使得分组变得更加和谐，小 C 想知道，在保证分组数量最少的情况 下，字典序最小的方案是什么。你能帮帮她吗？\n\n字典序最小的方案是指，按顺序排列分组的间隔位置，即所有存在兔子 $i$ 和 $i + 1$ 在 不同组的位置 $i$，和其它所有相同分组组数相同的可行方案相比总有第一个不同的位置比其 它方案小的方案。\n", "inputFormat": "从标准输入中读入数据。\n\n输入第 1 行两个正整数 $n,K$。\n\n输入第 2 行 $n$ 个正整数，第 $i$ 个数表示第 $i$ 只兔子的颜色 $a_i$。\n", "outputFormat": "输出到标准输出中。\n\n输出第 1 行一个正整数 $m$，为你至少需要将兔子分为多少个小组。\n\n输出第 2 行$m-1$个从小到大的排列的正整数，第 $i$ 个数 $s_i$ 表示 $s_i$ 和 $s_i + 1$ 在 你的方案里被分到了两个小组。如果 $m = 1$，那么请输出一个空行。\n", "hint": "【样例 1 解释】\n\n如果将五只兔子全部分到同一个小组的话，那么 (1, 3) (3, 6) (6, 10) (10, 15) (1, 15) 均 不能分到同一个小团体；因为最多分成两个小团体，所以为了满足前 4 对限制，只能分为 {{1, 6, 15}, {3, 10}}，但此时不满足 (1, 15) ，所以不存在一种组数为 1 的方案满足全部限制。\n\n\n如果将五只兔子分为两个小组的话，一种字典序最小的可行的分组方案是 {1}, {3, 15, 10, 6}，此时第二组内的小团体数量不超过 2 的一种分法是 {{3, 10}, {15, 6}}。\n\n【数据范围】\n\n子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解 决一部分测试数据。\n\n每个测试点的数据规模及特点如下表：\n\n \n  ![](https://cdn.luogu.com.cn/upload/pic/9809.png) \n\n特殊性质 1：保证最优分组方案唯一。\n\n特殊性质 2：保证不会有两只相同颜色的兔子。\n", "locale": "zh-CN", "translations": {"en": {"title": "Grouping", "background": "Large samples can be downloaded from the \"Attachments\" at the bottom of the page.", "description": "After learning the information she needed, Little C adjusted the rabbits to appropriate positions. She plans to divide the rabbits into several groups to feed them suitable carrots.\n\nAt this moment, $n$ rabbits stand in a line in a fixed order. The $i$-th rabbit has color $a_i$. Since the order has been fixed, each group must be a contiguous segment in the sequence.\n\nBefore grouping, Little C notices a pattern: some rabbits have pairwise conflicts. Two rabbits are in conflict if and only if the sum of their color values is a perfect square. For example, color 1 and color 2 do not conflict because 3 is not a perfect square; but color 1 and color 3 do conflict because $4 = 2^2$.\n\nLittle C thinks it is fine as long as the conflict within a group is not too large. She defines the conflict value $k$ of a group as the minimum number of sub-teams into which this group must be further partitioned so that within each sub-team, any two rabbits do not conflict. These sub-teams do not need to be contiguous segments.\n\nLittle C requires that the maximum conflict value among all groups does not exceed $K$. There may be many grouping methods that satisfy this. To make the grouping more harmonious, she wants to know, among all solutions with the minimum number of groups, which one is lexicographically smallest. Can you help her?\n\nThe lexicographically smallest solution is defined as follows: list in increasing order all positions $i$ such that rabbit $i$ and rabbit $i + 1$ belong to different groups. Among all feasible solutions with the same number of groups, the one whose first differing position is smaller is considered lexicographically smaller.", "inputFormat": "Read from standard input.\n\nThe first line contains two positive integers $n, K$.\n\nThe second line contains $n$ positive integers; the $i$-th number denotes the color $a_i$ of the $i$-th rabbit.", "outputFormat": "Write to standard output.\n\nPrint a single integer $m$ on the first line, the minimum number of groups you need to divide the rabbits into.\n\nPrint $m - 1$ positive integers in increasing order on the second line. The $i$-th number $s_i$ means that $s_i$ and $s_i + 1$ are placed into different groups in your solution. If $m = 1$, then print an empty line.", "hint": "[Sample 1 Explanation]\n\nIf all five rabbits are put into one group, then the pairs (1, 3), (3, 6), (6, 10), (10, 15), (1, 15) cannot be placed in the same sub-team pairwise. Since at most two sub-teams are allowed, to satisfy the first four constraints, the only way is {{1, 6, 15}, {3, 10}}, but then (1, 15) is not satisfied. Therefore, there is no solution with $m = 1$ that satisfies all constraints.\n\nIf the five rabbits are divided into two groups, one lexicographically smallest feasible grouping is {1}, {3, 15, 10, 6}. In this case, one way to partition the second group into at most 2 sub-teams is {{3, 10}, {15, 6}}.\n\nConstraints\n\nSubtasks will specify characteristics of some testdata. If you find the problem difficult, you may try to solve only part of the testdata.\n\nThe size and characteristics of each test point are shown in the table below:\n\n![](https://cdn.luogu.com.cn/upload/pic/9809.png)\n\nSpecial property 1: The optimal grouping is guaranteed to be unique.\n\nSpecial property 2: No two rabbits share the same color.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "分组", "background": "大样例可在页面底部「附件」中下载。\n", "description": "小 C 在了解了她所需要的信息之后，让兔子们调整到了恰当的位置。小 C 准备给兔子 们分成若干个小组来喂恰当的胡萝卜给兔子们吃。\n\n此时， $n$ 只兔子按一定顺序排成一排，第 $i$ 只兔子的颜色是 $a_i$ 。由于顺序已经是被 调整好了的，所以每个小组都应当是序列上连续的一段。\n\n在分组前，小 C 发现了一个规律：有些兔子会两两发生矛盾。并且，两只兔子会发生矛 盾，当且仅当代表他们的颜色的数值之和为一个正整数的平方。比如，1 色兔子和 2 色兔子 不会发生矛盾，因为 3 不是任何一个正整数的平方；而 1 色兔子却会和 3 色兔子发生矛盾， 因为 $4 = 2^2$。\n\n小 C 认为，只要一个小组内的矛盾不要过大就行。因此，小 C 定义了一个小组的矛盾 值 $k$ ，表示在这个小组里，至少需要将这个组再一次分成 $k$ 个小团体；每个小团体并不需 要是序列上连续的一段，但是需要使得每个小团体内任意两只兔子之间都不会发生矛盾。\n\n小 C 要求，矛盾值最大的小组的矛盾值 $k$ 不超过 $K$ 就可以了。当然，这样的分组方 法可能会有很多个；为了使得分组变得更加和谐，小 C 想知道，在保证分组数量最少的情况 下，字典序最小的方案是什么。你能帮帮她吗？\n\n字典序最小的方案是指，按顺序排列分组的间隔位置，即所有存在兔子 $i$ 和 $i + 1$ 在 不同组的位置 $i$，和其它所有相同分组组数相同的可行方案相比总有第一个不同的位置比其 它方案小的方案。\n", "inputFormat": "从标准输入中读入数据。\n\n输入第 1 行两个正整数 $n,K$。\n\n输入第 2 行 $n$ 个正整数，第 $i$ 个数表示第 $i$ 只兔子的颜色 $a_i$。\n", "outputFormat": "输出到标准输出中。\n\n输出第 1 行一个正整数 $m$，为你至少需要将兔子分为多少个小组。\n\n输出第 2 行$m-1$个从小到大的排列的正整数，第 $i$ 个数 $s_i$ 表示 $s_i$ 和 $s_i + 1$ 在 你的方案里被分到了两个小组。如果 $m = 1$，那么请输出一个空行。\n", "hint": "【样例 1 解释】\n\n如果将五只兔子全部分到同一个小组的话，那么 (1, 3) (3, 6) (6, 10) (10, 15) (1, 15) 均 不能分到同一个小团体；因为最多分成两个小团体，所以为了满足前 4 对限制，只能分为 {{1, 6, 15}, {3, 10}}，但此时不满足 (1, 15) ，所以不存在一种组数为 1 的方案满足全部限制。\n\n\n如果将五只兔子分为两个小组的话，一种字典序最小的可行的分组方案是 {1}, {3, 15, 10, 6}，此时第二组内的小团体数量不超过 2 的一种分法是 {{3, 10}, {15, 6}}。\n\n【数据范围】\n\n子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解 决一部分测试数据。\n\n每个测试点的数据规模及特点如下表：\n\n \n  ![](https://cdn.luogu.com.cn/upload/pic/9809.png) \n\n特殊性质 1：保证最优分组方案唯一。\n\n特殊性质 2：保证不会有两只相同颜色的兔子。\n", "locale": "zh-CN"}}}
{"pid": "P3941", "type": "P", "difficulty": 4, "samples": [["2 3 2 \n1 2 1 \n2 1 2", "6 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["O2优化", "枚举", "前缀和"], "title": "入阵曲", "background": "pdf题面和大样例链接：http://pan.baidu.com/s/1cawM7c 密码：xgxv\n\n```plain\n丹青千秋酿，一醉解愁肠。 \n无悔少年枉，只愿壮志狂。 \n```", "description": "小 F 很喜欢数学，但是到了高中以后数学总是考不好。\n\n有一天，他在数学课上发起了呆；他想起了过去的一年。一年前，当他初识算法竞赛的时候，觉得整个世界都焕然一新。这世界上怎么会有这么多奇妙的东西？曾经自己觉得难以解决的问题，被一个又一个算法轻松解决。\n\n小 F 当时暗自觉得，与自己的幼稚相比起来，还有好多要学习的呢。\n\n一年过去了，想想都还有点恍惚。\n\n他至今还能记得，某天晚上听着入阵曲，激动地睡不着觉，写题写到鸡鸣时分都兴奋不已。也许，这就是热血吧。\n\n \n![](https://cdn.luogu.com.cn/upload/pic/9810.png) \n\n也就是在那个时候，小 F 学会了矩阵乘法。让两个矩阵乘几次就能算出斐波那契数列的第 $10^{100}$ 项，真是奇妙无比呢。\n\n不过，小 F 现在可不想手算矩阵乘法——他觉得好麻烦。取而代之的，是一个简单的小问题。他写写画画，画出了一个 $n \\times m$ 的矩阵，每个格子里都有一个不超过 $k$ 的正整数。\n\n小 F 想问问你，这个矩阵里有多少个不同的子矩形中的数字之和是 $k$ 的倍数？ 如果把一个子矩形用它的左上角和右下角描述为 $(x_1,y_1,x_2,y_2)$，其中$x_1 \\le x_2,y_1 \\le y_2$； 那么，我们认为两个子矩形是不同的，当且仅当他们以 $(x_1,y_1,x_2,y_2)$ 表示时不同；也就是说，只要两个矩形以 $(x_1,y_1,x_2,y_2)$ 表示时相同，就认为这两个矩形是同一个矩形，你应该在你的答案里只算一次。", "inputFormat": "从标准输入中读入数据。\n\n输入第一行，包含三个正整数 $n,m,k$。\n\n输入接下来 $n$ 行，每行包含 $m$ 个正整数，第 $i$ 行第 $j$ 列表示矩阵中第 $i$ 行第 $j$ 列 中所填的正整数 $a_{i,j}$。", "outputFormat": "输出到标准输出中。\n\n输入一行一个非负整数，表示你的答案。", "hint": "【样例 1 说明】\n\n这些矩形是符合要求的：$(1, 1, 1, 3),(1, 1, 2, 2),(1, 2, 1, 2),(1, 2, 2, 3),(2, 1, 2, 1),(2, 3, 2, 3)$。\n\n\n子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。\n\n每个测试点的数据规模及特点如下表：\n\n \n  ![](https://cdn.luogu.com.cn/upload/pic/9811.png) \n\n特殊性质：保证所有 $a_{i,j}$ 均相同。", "locale": "zh-CN", "translations": {"en": {"title": "Ruzhenqu", "background": "PDF statement and large samples link: http://pan.baidu.com/s/1cawM7c Password: xgxv.\n\n```plain\n丹青千秋酿，一醉解愁肠。 \n无悔少年枉，只愿壮志狂。 \n```", "description": "Xiao F likes mathematics very much, but after entering high school he has never done well in math exams.\n\nOne day, he spaced out during math class; he thought about the past year. A year ago, when he first encountered algorithm contests, he felt that the whole world was brand new. How could there be so many wonderful things in this world? Problems that he used to think were hard were easily solved by one algorithm after another.\n\nBack then, Xiao F secretly felt that, compared with his own naivety, he still had a lot to learn.\n\nA year has passed, and thinking about it still feels a bit unreal.\n\nHe can still remember that one night, listening to Ruzhenqu, he was too excited to sleep. He kept solving problems until the rooster crowed at dawn, and he was still thrilled. Maybe that’s what “hot-blooded” feels like.\n\n![](https://cdn.luogu.com.cn/upload/pic/9810.png)\n\nIt was around that time that Xiao F learned matrix multiplication. Multiplying two matrices a few times to compute the $10^{100}$-th term of the Fibonacci sequence felt truly amazing.\n\nHowever, Xiao F does not want to do matrix multiplication by hand now—he finds it troublesome. Instead, he came up with a simple little problem. He drew an $n \\times m$ matrix, with each cell containing a positive integer not exceeding $k$.\n\nXiao F wants to ask you: how many different subrectangles in this matrix have a sum of numbers that is a multiple of $k$? If a subrectangle is described by its top-left and bottom-right corners as $(x_1,y_1,x_2,y_2)$, where $x_1 \\le x_2, y_1 \\le y_2$; then we consider two subrectangles to be different if and only if their $(x_1,y_1,x_2,y_2)$ representations differ. In other words, as long as two rectangles have the same $(x_1,y_1,x_2,y_2)$ representation, they are regarded as the same rectangle, and you should count it only once in your answer.", "inputFormat": "Read from standard input.\n\nThe first line contains three positive integers $n,m,k$.\n\nThe next $n$ lines each contain $m$ positive integers. In the $i$-th row, the $j$-th column contains the positive integer $a_{i,j}$.", "outputFormat": "Output to standard output.\n\nOutput a single non-negative integer on one line, which is your answer.", "hint": "[Sample 1 explanation]\n\nThese rectangles meet the requirement: $(1, 1, 1, 3),(1, 1, 2, 2),(1, 2, 1, 2),(1, 2, 2, 3),(2, 1, 2, 1),(2, 3, 2, 3)$.\n\nSubtasks will provide characteristics of some testdata. If you find the problem difficult, you can try solving only part of the testdata.\n\nThe data scale and characteristics for each test point are shown in the following table:\n\n![](https://cdn.luogu.com.cn/upload/pic/9811.png)\n\nSpecial property: all $a_{i,j}$ are guaranteed to be equal.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "入阵曲", "background": "pdf题面和大样例链接：http://pan.baidu.com/s/1cawM7c 密码：xgxv\n\n```plain\n丹青千秋酿，一醉解愁肠。 \n无悔少年枉，只愿壮志狂。 \n```", "description": "小 F 很喜欢数学，但是到了高中以后数学总是考不好。\n\n有一天，他在数学课上发起了呆；他想起了过去的一年。一年前，当他初识算法竞赛的时候，觉得整个世界都焕然一新。这世界上怎么会有这么多奇妙的东西？曾经自己觉得难以解决的问题，被一个又一个算法轻松解决。\n\n小 F 当时暗自觉得，与自己的幼稚相比起来，还有好多要学习的呢。\n\n一年过去了，想想都还有点恍惚。\n\n他至今还能记得，某天晚上听着入阵曲，激动地睡不着觉，写题写到鸡鸣时分都兴奋不已。也许，这就是热血吧。\n\n \n![](https://cdn.luogu.com.cn/upload/pic/9810.png) \n\n也就是在那个时候，小 F 学会了矩阵乘法。让两个矩阵乘几次就能算出斐波那契数列的第 $10^{100}$ 项，真是奇妙无比呢。\n\n不过，小 F 现在可不想手算矩阵乘法——他觉得好麻烦。取而代之的，是一个简单的小问题。他写写画画，画出了一个 $n \\times m$ 的矩阵，每个格子里都有一个不超过 $k$ 的正整数。\n\n小 F 想问问你，这个矩阵里有多少个不同的子矩形中的数字之和是 $k$ 的倍数？ 如果把一个子矩形用它的左上角和右下角描述为 $(x_1,y_1,x_2,y_2)$，其中$x_1 \\le x_2,y_1 \\le y_2$； 那么，我们认为两个子矩形是不同的，当且仅当他们以 $(x_1,y_1,x_2,y_2)$ 表示时不同；也就是说，只要两个矩形以 $(x_1,y_1,x_2,y_2)$ 表示时相同，就认为这两个矩形是同一个矩形，你应该在你的答案里只算一次。", "inputFormat": "从标准输入中读入数据。\n\n输入第一行，包含三个正整数 $n,m,k$。\n\n输入接下来 $n$ 行，每行包含 $m$ 个正整数，第 $i$ 行第 $j$ 列表示矩阵中第 $i$ 行第 $j$ 列 中所填的正整数 $a_{i,j}$。", "outputFormat": "输出到标准输出中。\n\n输入一行一个非负整数，表示你的答案。", "hint": "【样例 1 说明】\n\n这些矩形是符合要求的：$(1, 1, 1, 3),(1, 1, 2, 2),(1, 2, 1, 2),(1, 2, 2, 3),(2, 1, 2, 1),(2, 3, 2, 3)$。\n\n\n子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。\n\n每个测试点的数据规模及特点如下表：\n\n \n  ![](https://cdn.luogu.com.cn/upload/pic/9811.png) \n\n特殊性质：保证所有 $a_{i,j}$ 均相同。", "locale": "zh-CN"}}}
{"pid": "P3942", "type": "P", "difficulty": 5, "samples": [["4 1 0 \n1 2 \n1 3 \n1 4", "1 \n "], ["6 1 0 \n1 2 \n1 3 \n1 4 \n4 5 \n4 6", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "贪心", "O2优化", "排序", "栈"], "title": "将军令", "background": "> 历史/落在/赢家/之手  \n> 至少/我们/拥有/传说  \n> 谁说/败者/无法/不朽  \n> 拳头/只能/让人/低头  \n> 念头/却能/让人/抬头  \n> 抬头/去看/去爱/去追  \n> 你心中的梦", "description": "又想起了四月。\n\n如果不是省选，大家大概不会这么轻易地分道扬镳吧？只见一个又一个昔日的队友离开了机房。\n\n凭君莫话封侯事，一将功成万骨枯。\n\n梦里，小 F 成了一个给将军送密信的信使。\n\n现在，有两封关乎国家生死的密信需要送到前线大将军帐下，路途凶险，时间紧迫。小 F 没有怯战，勇敢地承担了这个任务。\n\n不过，小 F 实在是太粗心了，他一不小心把两封密信中的一封给弄掉了。\n\n小 F 偷偷打开了剩下的那封密信。他发现一副十分详细的地图，以及几句批文——原来这是战场周围的情报地图。他仔细看后发现，在这张地图上标记了 $n$ 个从 $1$ 到 $n$ 标号的驿站，$n - 1$ 条长度为 $1$ 里的小道，每条小道双向连接两个不同的驿站，并且驿站之间可以通过小道两两可达。\n\n小 F 仔细辨认着上面的批注，突然明白了丢失的信的内容了。原来，每个驿站都可以驻扎一个小队，每个小队可以控制距离不超过 $k$ 里的驿站。如果有驿站没被控制，就容易产生危险——因此这种情况应该完全避免。而那封丢失的密信里，就装着数学重臣留下的精妙的排布方案，也就是用了最少的小队来控制所有驿站。\n\n小 F 知道，如果能计算出最优方案的话，也许他就能够将功赎过，免于死罪。他找到了你，你能帮帮他吗？当然，小 F 在等待你的支援的过程中，也许已经从图上观察出了一些可能会比较有用的性质，他会通过一种特殊的方式告诉你。", "inputFormat": "从标准输入中读入数据。\n\n输入第 $1$ 行为三个正整数 $n,k,t$，分别代表：驿站数，一支小队能够控制的最远距离，以及对应的特殊性质的编号。关于特殊性质请参考数据范围中的表格。\n\n输入第 $2$ 行至第 $n$ 行，每行两个正整数 $u_i,v_i$，表示在编号为 $u_i$ 和 $v_i$ 的驿站之间有一条长度为 $1$ 里的小道。", "outputFormat": "输出到标准输出中。\n\n输出仅包含一行一个正整数，为最优方案下需要的小队数。", "hint": "【样例 1 说明】\n\n如图。由于一号节点到周围的点距离均是 $1$，因此可以控制所有驿站。\n\n【样例 2 说明】\n\n如图，和样例 1 类似。\n\n\n\n![](https://cdn.luogu.com.cn/upload/pic/9813.png)\n\n子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。\n\n$t$ 的含义如下：\n- $t = 0$：该测试点没有额外的特殊性质；\n- $t = 1$：保证最多 $8$ 个点的所连接的小道超过 $1$ 条；\n- $t = 2$：保证所有点到 $1$ 号点的距离不超过 $2$。\n\n每个测试点的数据规模及特点如下表\n\n![](https://cdn.luogu.com.cn/upload/pic/9812.png)", "locale": "zh-CN", "translations": {"en": {"title": "General's Order", "background": "> History/falls into/the victor's/hands  \n> At least/we/have/legends  \n> Who says/the defeated/cannot/be immortal  \n> Fists/can only/make people/bow their heads  \n> Thoughts/can/make people/lift their heads  \n> Lift your head/to look/to love/to chase  \n> The dream in your heart.", "description": "April comes to mind again.\n\nIf not for the NOI Qualifier, we probably wouldn’t have parted ways so easily, right? One by one, former teammates left the computer room.\n\n“Speak no more of marquisates; a general's success is built upon myriad bones.”\n\nIn a dream, little F became a courier delivering secret letters to a general.\n\nNow, there are two secret letters crucial to the life and death of the nation that must be delivered to the commanding general at the front. The journey is perilous and time is tight. Little F, undeterred by personal risk, bravely takes on the task.\n\nHowever, little F is very careless. He accidentally lost one of the two secret letters.\n\nHe secretly opened the remaining letter and found a very detailed map together with a few annotations—turns out it was an intelligence map of the battlefield and its surroundings. On this map, there are $n$ relay stations labeled from $1$ to $n$, and $n - 1$ small roads of length $1$ li, each road bidirectionally connecting two different relay stations. Any two stations are reachable via these roads.\n\nCarefully reading the notes, little F suddenly understood the contents of the lost letter. Each relay station can host one squad, and each squad can control all stations within a distance no more than $k$ li. If any station is left uncontrolled, danger may arise—so such situations must be completely avoided. The lost secret letter contained a brilliant arrangement from the imperial mathematical minister: an optimal placement using the fewest squads to control all relay stations.\n\nLittle F knows that if he can compute the optimal plan, he might redeem his mistake and avoid the death penalty. He found you—can you help him? Of course, while waiting for your assistance, little F may have observed some potentially useful properties from the map, which he will convey to you in a special way.", "inputFormat": "Read from standard input.\n\nThe first line contains three positive integers $n$, $k$, $t$, representing the number of relay stations, the maximum distance a squad can control, and the code for a special property. For the special property, see the Hint.\n\nThe next $n - 1$ lines each contain two positive integers $u_i$, $v_i$, indicating that there is a bidirectional small road of length $1$ li between $u_i$ and $v_i$.", "outputFormat": "Write to standard output.\n\nOutput a single line: the number of squads required under an optimal plan.", "hint": "[Sample 1 Explanation]\n\nAs shown in the figure. Since the distance from node $1$ to its surrounding nodes is $1$, it can control all relay stations.\n\n[Sample 2 Explanation]\n\nAs shown in the figure, similar to Sample 1.\n\n![](https://cdn.luogu.com.cn/upload/pic/9813.png)\n\nSubtasks will provide some characteristics of the testdata. If you find the problem difficult, you can try to solve only part of the testdata.\n\nThe meaning of $t$ is as follows:\n- $t = 0$: This test point has no additional special property.\n- $t = 1$: It is guaranteed that at most $8$ nodes are incident to more than $1$ road.\n- $t = 2$: It is guaranteed that the distance from every node to node $1$ is at most $2$.\n\nThe scale and characteristics of each test point are shown in the following table:\n\n![](https://cdn.luogu.com.cn/upload/pic/9812.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "将军令", "background": "> 历史/落在/赢家/之手  \n> 至少/我们/拥有/传说  \n> 谁说/败者/无法/不朽  \n> 拳头/只能/让人/低头  \n> 念头/却能/让人/抬头  \n> 抬头/去看/去爱/去追  \n> 你心中的梦", "description": "又想起了四月。\n\n如果不是省选，大家大概不会这么轻易地分道扬镳吧？只见一个又一个昔日的队友离开了机房。\n\n凭君莫话封侯事，一将功成万骨枯。\n\n梦里，小 F 成了一个给将军送密信的信使。\n\n现在，有两封关乎国家生死的密信需要送到前线大将军帐下，路途凶险，时间紧迫。小 F 没有怯战，勇敢地承担了这个任务。\n\n不过，小 F 实在是太粗心了，他一不小心把两封密信中的一封给弄掉了。\n\n小 F 偷偷打开了剩下的那封密信。他发现一副十分详细的地图，以及几句批文——原来这是战场周围的情报地图。他仔细看后发现，在这张地图上标记了 $n$ 个从 $1$ 到 $n$ 标号的驿站，$n - 1$ 条长度为 $1$ 里的小道，每条小道双向连接两个不同的驿站，并且驿站之间可以通过小道两两可达。\n\n小 F 仔细辨认着上面的批注，突然明白了丢失的信的内容了。原来，每个驿站都可以驻扎一个小队，每个小队可以控制距离不超过 $k$ 里的驿站。如果有驿站没被控制，就容易产生危险——因此这种情况应该完全避免。而那封丢失的密信里，就装着数学重臣留下的精妙的排布方案，也就是用了最少的小队来控制所有驿站。\n\n小 F 知道，如果能计算出最优方案的话，也许他就能够将功赎过，免于死罪。他找到了你，你能帮帮他吗？当然，小 F 在等待你的支援的过程中，也许已经从图上观察出了一些可能会比较有用的性质，他会通过一种特殊的方式告诉你。", "inputFormat": "从标准输入中读入数据。\n\n输入第 $1$ 行为三个正整数 $n,k,t$，分别代表：驿站数，一支小队能够控制的最远距离，以及对应的特殊性质的编号。关于特殊性质请参考数据范围中的表格。\n\n输入第 $2$ 行至第 $n$ 行，每行两个正整数 $u_i,v_i$，表示在编号为 $u_i$ 和 $v_i$ 的驿站之间有一条长度为 $1$ 里的小道。", "outputFormat": "输出到标准输出中。\n\n输出仅包含一行一个正整数，为最优方案下需要的小队数。", "hint": "【样例 1 说明】\n\n如图。由于一号节点到周围的点距离均是 $1$，因此可以控制所有驿站。\n\n【样例 2 说明】\n\n如图，和样例 1 类似。\n\n\n\n![](https://cdn.luogu.com.cn/upload/pic/9813.png)\n\n子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。\n\n$t$ 的含义如下：\n- $t = 0$：该测试点没有额外的特殊性质；\n- $t = 1$：保证最多 $8$ 个点的所连接的小道超过 $1$ 条；\n- $t = 2$：保证所有点到 $1$ 号点的距离不超过 $2$。\n\n每个测试点的数据规模及特点如下表\n\n![](https://cdn.luogu.com.cn/upload/pic/9812.png)", "locale": "zh-CN"}}}
{"pid": "P3943", "type": "P", "difficulty": 6, "samples": [["5 2 2 \n1 5 \n3 4", "2   \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["O2优化", "背包 DP", "差分", "状压 DP"], "title": "星空", "background": "pdf题面和大样例链接：http://pan.baidu.com/s/1cawM7c 密码：xgxv\n\n```cpp\n命运偷走如果只留下结果， 时间偷走初衷只留下了苦衷。\n你来过，然后你走后，只留下星空。\n```", "description": "逃不掉的那一天还是来了，小 F 看着夜空发呆。\n\n天上空荡荡的，没有一颗星星——大概是因为天上吹不散的乌云吧。\n\n心里吹不散的乌云，就让它在那里吧，反正也没有机会去改变什么了。\n\n小 C 拿来了一长串星型小灯泡，假装是星星，递给小 F，想让小 F 开心一点。不过，有着强迫症的小 F 发现，这串一共 $n$ 个灯泡的灯泡串上有 $k$ 个灯泡没有被点亮。小 F 决定和小 C 一起把这个灯泡串全部点亮。\n\n不过，也许是因为过于笨拙，小 F 只能将其中连续一段的灯泡状态给翻转——点亮暗灯泡，熄灭亮灯泡。经过摸索，小 F 发现他一共能够翻转 $m$ 种长度的灯泡段中灯泡的状态。\n\n小 C 和小 F 最终花了很长很长很长很长很长很长的时间把所有灯泡给全部点亮了。他们想知道他们是不是蠢了，因此他们找到了你，让你帮忙算算：在最优的情况下，至少需要几次操作才能把整个灯泡串给点亮？", "inputFormat": "从标准输入中读入数据。\n\n输入第 $1$ 行三个正整数 $n,k,m$。\n\n输入第 $2$ 行 $k$ 个正整数，第 $i$ 个数表示第 $i$ 个被没点亮的灯泡的位置 $a_i$。\n\n输入第 $3$ 行 $m$ 个正整数，第 $i$ 个数表示第 $i$ 种操作的长度 $b_i$。\n\n保证所有 $b_i$ 互不相同；保证对于 $1\\le i<k$，有 $a_i<a_{i+1}$；保证输入数据有解。", "outputFormat": "输出标准输入中。\n\n输出一行一个非负整数，表示最少操作次数。\n", "hint": "【样例 1 解释】\n\n ![](https://cdn.luogu.com.cn/upload/pic/9814.png) \n\n【数据范围与约定】\n\n子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解 决一部分测试数据。\n\n每个测试点的数据规模及特点如下表\n\n ![](https://cdn.luogu.com.cn/upload/pic/9815.png) \n\n特殊性质：保证答案小于 4\n", "locale": "zh-CN", "translations": {"en": {"title": "Starry Sky", "background": "PDF statement and large sample link: http://pan.baidu.com/s/1cawM7c Password: xgxv.\n\n```cpp\n命运偷走如果只留下结果， 时间偷走初衷只留下了苦衷。\n你来过，然后你走后，只留下星空。\n```", "description": "The inevitable day still came. Little F stared blankly at the night sky.\n\nThe sky was empty, with not a single star—probably because of the heavy clouds that would not disperse.\n\nAs for the clouds in the heart that will not disperse, just let them be. After all, there is no chance to change anything.\n\nLittle C brought a long string of star-shaped mini bulbs, pretending they were stars, and handed it to Little F, hoping to cheer him up. However, due to a bit of OCD, Little F noticed that among the total of $n$ bulbs, $k$ bulbs on the string were not lit. Little F decided to work with Little C to light up the entire string.\n\nBut perhaps due to clumsiness, Little F could only flip the states of a contiguous segment of bulbs—turning off lit bulbs and turning on unlit bulbs. After some trials, Little F found that he could flip segments of $m$ different lengths.\n\nLittle C and Little F eventually spent a very very very very very very long time to light up all the bulbs. They want to know if they were being silly, so they came to you to calculate: in the optimal case, what is the minimum number of operations needed to light up the entire bulb string?", "inputFormat": "Read from standard input.\n\n- The first line contains three positive integers $n$, $k$, $m$.\n- The second line contains $k$ positive integers. The $i$-th number is the position $a_i$ of the $i$-th bulb that is not lit.\n- The third line contains $m$ positive integers. The $i$-th number is the length $b_i$ of the $i$-th operation.\n\nIt is guaranteed that all $b_i$ are distinct; for $1 \\le i < k$, $a_i < a_{i+1}$; and the input has a solution.", "outputFormat": "Print one non-negative integer: the minimum number of operations.", "hint": "[Explanation for Sample 1]\n\n![](https://cdn.luogu.com.cn/upload/pic/9814.png)\n\n[Constraints and Conventions]\n\nSubtasks specify some properties of the testdata. If you find the problem difficult, you may try to solve only part of the testdata.\n\nThe data scale and features of each test point are summarized in the table below.\n\n![](https://cdn.luogu.com.cn/upload/pic/9815.png)\n\nSpecial property: It is guaranteed that the answer is less than $4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "星空", "background": "pdf题面和大样例链接：http://pan.baidu.com/s/1cawM7c 密码：xgxv\n\n```cpp\n命运偷走如果只留下结果， 时间偷走初衷只留下了苦衷。\n你来过，然后你走后，只留下星空。\n```", "description": "逃不掉的那一天还是来了，小 F 看着夜空发呆。\n\n天上空荡荡的，没有一颗星星——大概是因为天上吹不散的乌云吧。\n\n心里吹不散的乌云，就让它在那里吧，反正也没有机会去改变什么了。\n\n小 C 拿来了一长串星型小灯泡，假装是星星，递给小 F，想让小 F 开心一点。不过，有着强迫症的小 F 发现，这串一共 $n$ 个灯泡的灯泡串上有 $k$ 个灯泡没有被点亮。小 F 决定和小 C 一起把这个灯泡串全部点亮。\n\n不过，也许是因为过于笨拙，小 F 只能将其中连续一段的灯泡状态给翻转——点亮暗灯泡，熄灭亮灯泡。经过摸索，小 F 发现他一共能够翻转 $m$ 种长度的灯泡段中灯泡的状态。\n\n小 C 和小 F 最终花了很长很长很长很长很长很长的时间把所有灯泡给全部点亮了。他们想知道他们是不是蠢了，因此他们找到了你，让你帮忙算算：在最优的情况下，至少需要几次操作才能把整个灯泡串给点亮？", "inputFormat": "从标准输入中读入数据。\n\n输入第 $1$ 行三个正整数 $n,k,m$。\n\n输入第 $2$ 行 $k$ 个正整数，第 $i$ 个数表示第 $i$ 个被没点亮的灯泡的位置 $a_i$。\n\n输入第 $3$ 行 $m$ 个正整数，第 $i$ 个数表示第 $i$ 种操作的长度 $b_i$。\n\n保证所有 $b_i$ 互不相同；保证对于 $1\\le i<k$，有 $a_i<a_{i+1}$；保证输入数据有解。", "outputFormat": "输出标准输入中。\n\n输出一行一个非负整数，表示最少操作次数。\n", "hint": "【样例 1 解释】\n\n ![](https://cdn.luogu.com.cn/upload/pic/9814.png) \n\n【数据范围与约定】\n\n子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解 决一部分测试数据。\n\n每个测试点的数据规模及特点如下表\n\n ![](https://cdn.luogu.com.cn/upload/pic/9815.png) \n\n特殊性质：保证答案小于 4\n", "locale": "zh-CN"}}}
{"pid": "P3944", "type": "P", "difficulty": 4, "samples": [["3 5\n1 2 3 \n", "0 5"], ["8 8\n10 20 30 40 50 60 70 80\n", "16 23"], ["8 80\n10 20 30 40 50 60 70 80\n", "Human Cannot Win Dog"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "贪心", "排序"], "title": "肮脏的牧师", "background": "@Yumis 出题人在这里哦~\n", "description": "Yumis最近在玩炉石传说。\n\n在炉石传说中脏牧有一张一费卡片（一费就是使用要消耗1点法力水晶），叫做疯狂药水，这个的效果是将一个敌方场上攻击小于等于2的随从拉到自己的战场内。\n\n还有一张四费卡片叫做暗影狂乱，这个的效果是将一个敌方场上攻击小于等于3的随从拉到自己的战场内。\n\n还有一张一费卡片就是缩小药水，这个的效果是将敌人全场的随从攻击力下降3点。\n\n\n你PY了炉石的GM所以你有了无数张的这三种卡片，但是GM告诉你缩小药水是这个牌比较不好创建，为了为GM着想你必须在使用**最少的缩小药水**的情况下A爆对手的脸。\n\n\n现在你的对手场上有n个随从，每个随从的攻击力是ki点。\n\n你的对手有m点血量。\n\n\n而你现在要做的就是将敌方的场上的随从拉过来自己的场上并攻击对手（每一个随从只能攻击一次，攻击力为你拉过来的时候随从剩余的攻击力），A爆对面的脸（将对面的血打到0点及以下）。\n", "inputFormat": "第一行用一个空格隔开的两个整数n,m分别代表敌方场上的随从数量和你对手的血量。\n\n第二行n个整数每两个整数之间用一个空格隔开，分别代表敌方场上每一个随从的攻击力ki。\n", "outputFormat": "一行如果可以A爆则输出**最少使用的缩小药水的数量**和此时使用的法力水晶，两个数据之间用一个空格隔开（如果有多个答案则输出消耗法力水晶最少的答案）。\n\n否则输出“Human Cannot Win Dog”（没有双引号）\n", "hint": "样例说明1：\n\n敌方场上有3只随从，敌方有5点血量\n\n我们把3攻随从和2攻随从拉过来花费0个缩小药水和5点耗费（一张疯狂药水一个暗影狂乱（1+4 = 5））伤害足够击杀对方。\n\n\n样例说明2：\n\n使用16个缩小药水（下面数据后面第一个括号指拉过来的时候伤害为多高 ，第二个括号表示拉过来的时候使用多少的缩小药水）\n\n拿10（1）（3）、20（2）（6）、30（3）（9）、50（2）（16）攻的怪物总共造成8点伤害 刚好A爆！\n\n\n\nEasy : 保证 0 < n <= 10  并且不存在用到暗影狂乱和缩小药水的情况    20%\n\n\nNormal ：保证 0 < n <= 10  并且不存在用到缩小药水的情况           20%\n\n\nHard ：保证 0 < n <= 10                                                 30%\n\n\nExtra：保证0 <= n <= 5000000(6个0)，最大攻击力小于30000                  30%\n\n\n保证 0 < n <= 5000000     0 < ki <=30000    0<=m<=5000000 (6个0)\n", "locale": "zh-CN", "translations": {"en": {"title": "Dirty Priest", "background": "@Yumis, the problem setter, is here~", "description": "Yumis has recently been playing Hearthstone.\n\nIn Hearthstone, the \"Dirty Priest\" archetype uses a 1-mana card called \"Potion of Madness,\" whose effect is: take control of an enemy minion with attack ≤ 2.\n\nThere is also a 4-mana card called \"Shadow Madness,\" whose effect is: take control of an enemy minion with attack ≤ 3.\n\nThere is another 1-mana card called \"Shrink Potion,\" whose effect is: reduce the attack of all enemy minions by 3.\n\nYou have \"PY\" (pinyin) the Hearthstone GM, so you now have unlimited copies of these three cards. However, the GM told you that \"Shrink Potion\" is harder to create. To be considerate to the GM, you must kill the opponent while using the minimum number of Shrink Potions.\n\nYour opponent currently has n minions on board, with attack values k_i.\n\nYour opponent has m health.\n\nYour task is to take control of enemy minions onto your side and attack the opponent with them. Each minion can attack at most once, and the damage it deals equals its remaining attack at the moment you take control. You need to burst the opponent down (reduce their health to 0 or below).", "inputFormat": "- The first line contains two integers n and m, separated by a space, representing the number of enemy minions and the opponent’s health.\n- The second line contains n integers, separated by spaces, representing the attack values k_i of each enemy minion.", "outputFormat": "- If it is possible to burst the opponent down, output one line with two integers: the minimum number of Shrink Potions used and the total mana crystals spent in that case, separated by a space. If there are multiple optimal answers with the same minimum number of Shrink Potions, output the one with the minimum mana crystals spent.\n- Otherwise, output Human Cannot Win Dog (without quotes).", "hint": "Sample explanation 1:\n- The enemy has 3 minions on board, and the opponent has 5 health.\n- Take control of the 3-attack minion and the 2-attack minion, spending 0 Shrink Potions and 5 mana crystals (one Potion of Madness and one Shadow Madness, 1 + 4 = 5). The damage is enough to kill the opponent.\n\nSample explanation 2:\n- Use 16 Shrink Potions (for each minion below, the first parenthesis is the attack when taken, and the second parenthesis is the total number of Shrink Potions used at that moment).\n- Taking minions with original attacks 10 (1) (3), 20 (2) (6), 30 (3) (9), 50 (2) (16) deals a total of 8 damage, exactly lethal.\n\nSubtasks:\n- Easy: Guaranteed 0 < n ≤ 10, and no Shadow Madness or Shrink Potion is needed. 20%.\n- Normal: Guaranteed 0 < n ≤ 10, and no Shrink Potion is needed. 20%.\n- Hard: Guaranteed 0 < n ≤ 10. 30%.\n- Extra: Guaranteed 0 ≤ n ≤ 5,000,000, maximum attack < 30,000. 30%.\n\nConstraints:\n- $0 < n \\le 5{,}000{,}000$\n- $0 < k_i \\le 30{,}000$\n- $0 \\le m \\le 5{,}000{,}000$ (6 zeros).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "肮脏的牧师", "background": "@Yumis 出题人在这里哦~\n", "description": "Yumis最近在玩炉石传说。\n\n在炉石传说中脏牧有一张一费卡片（一费就是使用要消耗1点法力水晶），叫做疯狂药水，这个的效果是将一个敌方场上攻击小于等于2的随从拉到自己的战场内。\n\n还有一张四费卡片叫做暗影狂乱，这个的效果是将一个敌方场上攻击小于等于3的随从拉到自己的战场内。\n\n还有一张一费卡片就是缩小药水，这个的效果是将敌人全场的随从攻击力下降3点。\n\n\n你PY了炉石的GM所以你有了无数张的这三种卡片，但是GM告诉你缩小药水是这个牌比较不好创建，为了为GM着想你必须在使用**最少的缩小药水**的情况下A爆对手的脸。\n\n\n现在你的对手场上有n个随从，每个随从的攻击力是ki点。\n\n你的对手有m点血量。\n\n\n而你现在要做的就是将敌方的场上的随从拉过来自己的场上并攻击对手（每一个随从只能攻击一次，攻击力为你拉过来的时候随从剩余的攻击力），A爆对面的脸（将对面的血打到0点及以下）。\n", "inputFormat": "第一行用一个空格隔开的两个整数n,m分别代表敌方场上的随从数量和你对手的血量。\n\n第二行n个整数每两个整数之间用一个空格隔开，分别代表敌方场上每一个随从的攻击力ki。\n", "outputFormat": "一行如果可以A爆则输出**最少使用的缩小药水的数量**和此时使用的法力水晶，两个数据之间用一个空格隔开（如果有多个答案则输出消耗法力水晶最少的答案）。\n\n否则输出“Human Cannot Win Dog”（没有双引号）\n", "hint": "样例说明1：\n\n敌方场上有3只随从，敌方有5点血量\n\n我们把3攻随从和2攻随从拉过来花费0个缩小药水和5点耗费（一张疯狂药水一个暗影狂乱（1+4 = 5））伤害足够击杀对方。\n\n\n样例说明2：\n\n使用16个缩小药水（下面数据后面第一个括号指拉过来的时候伤害为多高 ，第二个括号表示拉过来的时候使用多少的缩小药水）\n\n拿10（1）（3）、20（2）（6）、30（3）（9）、50（2）（16）攻的怪物总共造成8点伤害 刚好A爆！\n\n\n\nEasy : 保证 0 < n <= 10  并且不存在用到暗影狂乱和缩小药水的情况    20%\n\n\nNormal ：保证 0 < n <= 10  并且不存在用到缩小药水的情况           20%\n\n\nHard ：保证 0 < n <= 10                                                 30%\n\n\nExtra：保证0 <= n <= 5000000(6个0)，最大攻击力小于30000                  30%\n\n\n保证 0 < n <= 5000000     0 < ki <=30000    0<=m<=5000000 (6个0)\n", "locale": "zh-CN"}}}
{"pid": "P3945", "type": "P", "difficulty": 5, "samples": [["3 100\n0 10 0 10000000 0.006207480877613 0 0\n8.660254037844 -5 0 10000000 -0.003103740438807 -0.00537583613352 0\n-8.660254037844 -5 0 10000000 -0.003103740438807 0.00537583613352 0", "0.620349511786 9.980741705470 0.000000000000\n8.333401109655 -5.527609289167 0.000000000000\n-8.953750621441 -4.453132416303 0.000000000000"], ["3 100\n0 10 0 10000000 0.06207480877613 0 0\n8.760254037844 -5 0 10000000 -0.03103740438807 -0.0537583613352 0\n-8.660254037844 -5 0 10000000 -0.03103740438807 0.0537583613352 0", "6.204092324054 9.982347016794 0.000000000000\n5.642963405596 -10.364100727695 0.000000000000\n-11.747055729651 0.381753710901 0.000000000000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "Special Judge", "向量"], "title": "三体问题【std 疑似有误】", "background": "@FirstLight0521 出题人在这里哦~\n\n三体人所居住的星系由于三体运动的不确定性而导致三体星人生活动荡不安，善良的人类程序员（也就是你了！伟大的英雄！）决定帮助愚蠢得连程序都不会写的三体星人模拟天体的运动轨迹。这时，无聊的“歌者”文明决定戏弄一下你，于是给三体星系添加了一些新的星体。\n", "description": "输入 $N$ 个天体与他们在空间中的坐标 $(x_i,y_i,z_i)$、初速度 $(v_x,v_y,v_z)$ 与质量 $M_i$，已知三体世界受到“歌者”影响时间的流动不是连续的（每 $0.01$ 秒钟刷新一次），天体均视为质点，求 $t$ 时刻所有天体的坐标。\n\n本题万有引力常数 $G$ 取 $6.67408 \\times 10^{-11}$，在代码中可以写成：\n\n```cpp\n#define G 6.67408e-11\n```\n\n当你的答案与标准答案的相对误差不超过 $0.5 \\%$ 的时候，你在本测试点得到 AC。也就是说，保留多少位小数你可以自行确定。标准答案将会保留 $12$ 位小数。本题开启 SPJ 判断你的答案是否正确。\n", "inputFormat": "第一行一个正整数 $N$ 和一个非负实数 $t$，分别表示天体数与时刻。\n\n接下来 $N$ 行，每行 $7$ 个实数 $x_i,y_i,z_i,M_i,v_x,v_y,v_z$，分别表示各天体坐标、质量与初速度（三个方向上的分速度）。\n", "outputFormat": "$N$ 行，每行为第 $i$ 个天体在 $t$ 时刻的坐标 $x_i,y_i,z_i$，以单个空格隔开。\n", "hint": "$3 \\le N \\le 30,0 \\le t \\le 100,-100 \\le x_i,y_i,z_i \\le 100$。$M_i$ 在 `long long` 范围内。", "locale": "zh-CN", "translations": {"en": {"title": "Three-Body Problem [std suspected to be incorrect]", "background": "@FirstLight0521 The problem setter is here~\n\nBecause the Trisolarans’ star system is chaotic due to the unpredictability of three-body motion, Trisolarans live in constant turmoil. Kind human programmers (that is you, the great hero!) decide to help the Trisolarans, who are so foolish they cannot even write programs, by simulating the trajectories of celestial bodies. At this moment, the bored \"Singer\" civilization decides to tease you and adds some new celestial bodies to the Trisolaran system.", "description": "You are given $N$ celestial bodies with their positions $(x_i, y_i, z_i)$ in space, initial velocities $(v_x, v_y, v_z)$, and masses $M_i$. It is known that, under the influence of the \"Singer\" civilization, time in the three-body world does not flow continuously (it updates every $0.01$ seconds). All celestial bodies are treated as point masses. Compute the positions of all celestial bodies at time $t$.\n\nThe universal gravitational constant $G$ is $6.67408 \\times 10^{-11}$. In code, you may write:\n\n```cpp\n#define G 6.67408e-11\n```\n\nIf your answer’s relative error does not exceed $0.5\\%$ compared to the standard answer, you will receive AC on that test point. In other words, you may choose how many decimal places to keep. The standard answer keeps $12$ decimal places. This problem uses SPJ to check correctness.", "inputFormat": "The first line contains a positive integer $N$ and a nonnegative real number $t$, representing the number of celestial bodies and the time, respectively.\n\nThe next $N$ lines each contain $7$ real numbers $x_i, y_i, z_i, M_i, v_x, v_y, v_z$, representing each body’s position, mass, and initial velocity (the velocity components in the three directions).", "outputFormat": "Output $N$ lines. The $i$-th line contains the coordinates $x_i, y_i, z_i$ of the $i$-th body at time $t$, separated by single spaces.", "hint": "Constraints: $3 \\le N \\le 30$, $0 \\le t \\le 100$, $-100 \\le x_i, y_i, z_i \\le 100$. $M_i$ is within the range of long long.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "三体问题【std 疑似有误】", "background": "@FirstLight0521 出题人在这里哦~\n\n三体人所居住的星系由于三体运动的不确定性而导致三体星人生活动荡不安，善良的人类程序员（也就是你了！伟大的英雄！）决定帮助愚蠢得连程序都不会写的三体星人模拟天体的运动轨迹。这时，无聊的“歌者”文明决定戏弄一下你，于是给三体星系添加了一些新的星体。\n", "description": "输入 $N$ 个天体与他们在空间中的坐标 $(x_i,y_i,z_i)$、初速度 $(v_x,v_y,v_z)$ 与质量 $M_i$，已知三体世界受到“歌者”影响时间的流动不是连续的（每 $0.01$ 秒钟刷新一次），天体均视为质点，求 $t$ 时刻所有天体的坐标。\n\n本题万有引力常数 $G$ 取 $6.67408 \\times 10^{-11}$，在代码中可以写成：\n\n```cpp\n#define G 6.67408e-11\n```\n\n当你的答案与标准答案的相对误差不超过 $0.5 \\%$ 的时候，你在本测试点得到 AC。也就是说，保留多少位小数你可以自行确定。标准答案将会保留 $12$ 位小数。本题开启 SPJ 判断你的答案是否正确。\n", "inputFormat": "第一行一个正整数 $N$ 和一个非负实数 $t$，分别表示天体数与时刻。\n\n接下来 $N$ 行，每行 $7$ 个实数 $x_i,y_i,z_i,M_i,v_x,v_y,v_z$，分别表示各天体坐标、质量与初速度（三个方向上的分速度）。\n", "outputFormat": "$N$ 行，每行为第 $i$ 个天体在 $t$ 时刻的坐标 $x_i,y_i,z_i$，以单个空格隔开。\n", "hint": "$3 \\le N \\le 30,0 \\le t \\le 100,-100 \\le x_i,y_i,z_i \\le 100$。$M_i$ 在 `long long` 范围内。", "locale": "zh-CN"}}}
{"pid": "P3946", "type": "P", "difficulty": 5, "samples": [["2 1 1 2 10 1\n1 10\n3 10\n1 2 6", "6"], ["5 6 2 5 10 1\n1 10\n1 10\n1 10\n1 10\n1 10\n1 5 9\n1 3 9\n2 4 1\n2 5 9\n3 4 1\n3 5 6", "8"], ["5 6 2 5 10 1\n1 10\n1 10\n10 10\n1 10\n1 10\n1 5 9\n1 3 9\n2 4 1\n2 5 11\n3 4 1\n3 5 6\n", "wtnap wa kotori no oyatsu desu!"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["最短路"], "title": "ことりのおやつ（小鸟的点心）", "background": "", "description": "这是2017年的冬天。（又到了白色相簿的季节2333）\n\n![滑雪鸟](https://db.loveliv.es/png/navi/476/0)\n\n滑完雪之后，ことり突然想吃点心啦！于是她去了甜品店。\n\n日本的冬天经常下雪。不幸的是，今天也是这样，每秒钟雪的厚度会增加q毫米。\n\n秋叶原共有n个地点，编号从1到n。每个地点在开始的时候的积雪高度为hi。\n\n有m条**双向**道路连接这些地点，它们的长度分别为wi米。\n\n雪太大，公共交通系统已经停摆了，所以ことり得走路回家。她走路的速度是1m/s。\n\n为了方便地图的绘制，秋叶原的道路规划使得每条道路严格地连接两个不同的地点，并且不会有两条道路连接的地点相同。\n\n每个地点都有一个极限雪高li，单位是毫米，如果到达这个地点的时候，这里的雪的高度高于li则会被困在这个点走不出去，无法成功地走到ことり家。\n\n点心店这个地点的编号是s，ことり家的编号是t。\n\n不考虑点心店和ことり家的雪。\n\nことり想在g秒内回到家吃点心，越快越好。如果在g秒之内，ことり无法到家，或者她被困在路上了，那么ことり会把wtnap变成她的点心( ・ 8 ・ )\n", "inputFormat": "第1行6个整数，空格隔开，分别代表n，m，s，t，g，q。\n\n以下n行，每行2个整数，空格隔开，分别表示这个地点的hi和li。\n\n以下m行，每行3个整数，空格隔开，分别表示这条路连接的两个地点u, v和这条路的长度wi。\n", "outputFormat": "输出1行1个整数，表示到达ことり家的最短用时。\n\n如果wtnap变成了ことり的点心那么输出\"wtnap wa kotori no oyatsu desu!\"\n\n输出时不含引号。\n", "hint": "对于0%的数据，与样例一模一样；  \n对于40%的数据，q = 0。  \n对于上一行中50%的数据，所有wi < li。  \n对于100%的数据，1 ≤ s, t ≤ n;  0 ≤ g, q ≤ 10^9; 0 ≤ wi ≤ li ≤ 10^9。\n\n![](https://cdn.luogu.com.cn/upload/pic/9826.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "Kotori's Snack", "background": "", "description": "It is the winter of 2017. (It is the season of White Album again 2333.)\n\n![滑雪鸟](https://db.loveliv.es/png/navi/476/0)\n\nAfter skiing, Kotori suddenly wants a snack, so she goes to a dessert shop.\n\nIt often snows in winter in Japan. Unfortunately, today is the same, and the snow depth increases by $q$ millimeters every second.\n\nAkihabara has $n$ locations, numbered from $1$ to $n$. Each location initially has a snow depth of $h_i$.\n\nThere are $m$ bidirectional roads connecting these locations, and their lengths are $w_i$ meters.\n\nThe snow is too heavy and public transportation has stopped, so Kotori has to walk home. Her walking speed is $1$ m/s.\n\nFor convenient mapping, the road network ensures that each road strictly connects two different locations, and there are no two roads connecting the same pair of locations.\n\nEach location has a limit snow height $l_i$ in millimeters. If, upon arrival, the snow depth there is greater than $l_i$, she will be trapped at that location and cannot leave, and thus cannot reach Kotori's home.\n\nThe dessert shop is location $s$, and Kotori's home is location $t$.\n\nDo not consider the snow at the dessert shop and at Kotori's home.\n\nKotori wants to get home within $g$ seconds, as fast as possible. If she cannot reach home within $g$ seconds, or she gets trapped on the way, then she will turn wtnap into her snack ( ・ 8 ・ ).", "inputFormat": "The first line contains $6$ integers, separated by spaces: $n$, $m$, $s$, $t$, $g$, $q$.\n\nThe next $n$ lines each contain $2$ integers, separated by spaces, representing $h_i$ and $l_i$ for that location.\n\nThe next $m$ lines each contain $3$ integers, separated by spaces, representing the two locations $u$, $v$ connected by the road and the road length $w_i$.", "outputFormat": "Output one line with one integer, the shortest time to reach Kotori's home.\n\nIf wtnap becomes Kotori's snack, output \"wtnap wa kotori no oyatsu desu!\" without quotes.", "hint": "For $0\\%$ of the testdata, the same as the sample.  \nFor $40\\%$ of the testdata, $q = 0$.  \nFor $50\\%$ of the testdata in the previous line, all $w_i < l_i$.  \nFor $100\\%$ of the testdata, $1 \\le s, t \\le n$; $0 \\le g, q \\le 10^9$; $0 \\le w_i \\le l_i \\le 10^9$.\n\n![](https://cdn.luogu.com.cn/upload/pic/9826.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "ことりのおやつ（小鸟的点心）", "background": "", "description": "这是2017年的冬天。（又到了白色相簿的季节2333）\n\n![滑雪鸟](https://db.loveliv.es/png/navi/476/0)\n\n滑完雪之后，ことり突然想吃点心啦！于是她去了甜品店。\n\n日本的冬天经常下雪。不幸的是，今天也是这样，每秒钟雪的厚度会增加q毫米。\n\n秋叶原共有n个地点，编号从1到n。每个地点在开始的时候的积雪高度为hi。\n\n有m条**双向**道路连接这些地点，它们的长度分别为wi米。\n\n雪太大，公共交通系统已经停摆了，所以ことり得走路回家。她走路的速度是1m/s。\n\n为了方便地图的绘制，秋叶原的道路规划使得每条道路严格地连接两个不同的地点，并且不会有两条道路连接的地点相同。\n\n每个地点都有一个极限雪高li，单位是毫米，如果到达这个地点的时候，这里的雪的高度高于li则会被困在这个点走不出去，无法成功地走到ことり家。\n\n点心店这个地点的编号是s，ことり家的编号是t。\n\n不考虑点心店和ことり家的雪。\n\nことり想在g秒内回到家吃点心，越快越好。如果在g秒之内，ことり无法到家，或者她被困在路上了，那么ことり会把wtnap变成她的点心( ・ 8 ・ )\n", "inputFormat": "第1行6个整数，空格隔开，分别代表n，m，s，t，g，q。\n\n以下n行，每行2个整数，空格隔开，分别表示这个地点的hi和li。\n\n以下m行，每行3个整数，空格隔开，分别表示这条路连接的两个地点u, v和这条路的长度wi。\n", "outputFormat": "输出1行1个整数，表示到达ことり家的最短用时。\n\n如果wtnap变成了ことり的点心那么输出\"wtnap wa kotori no oyatsu desu!\"\n\n输出时不含引号。\n", "hint": "对于0%的数据，与样例一模一样；  \n对于40%的数据，q = 0。  \n对于上一行中50%的数据，所有wi < li。  \n对于100%的数据，1 ≤ s, t ≤ n;  0 ≤ g, q ≤ 10^9; 0 ≤ wi ≤ li ≤ 10^9。\n\n![](https://cdn.luogu.com.cn/upload/pic/9826.png)\n", "locale": "zh-CN"}}}
{"pid": "P3947", "type": "P", "difficulty": 5, "samples": [["3 2 10\nBokutachiwaHitotsunoHikari 3 8\nKorekara 1 2\nSnowHalation 2 5\n", "6\nSnowHalation\nBokutachiwaHitotsunoHikari\nKorekara\n"], ["2 1 2\nAoizoraJumpingHeart 1 2\nTimeLapse 2 4", "No Answer"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["搜索", "O2优化", "剪枝", "状压 DP"], "title": "肝活动", "background": "Yume 最近在玩一个名为《LoveLive! School idol festival》的音乐游戏。他之所以喜欢上这个游戏，是因为这个游戏对非洲人十分友好，即便你脸黑到抽不出好卡，还可以通过在每个月举办的两次活动中达成一定的目标来获得奖励。", "description": "Yume 很喜欢这一期活动奖励卡的卡面，于是他决定要肝这一期的活动，拿到活动奖励。这一期的活动规则很特殊，玩家需要在活动规定的结束时间前，完成所有指定的歌曲（**每首歌曲只能打一次**），并获得一定的分数，就可以拿到活动奖励。如果在规定的时间前没有完成所有的歌曲，或者分数不够奖励的分数线，则不能领取活动奖励。每首歌有一个限定的奖励开放时间，玩家如果在这段时间内完成了这首歌，便可以获得一定的分数（**获得的分数 = 开放时间 - 当前已用的总时间**）。如果超出了这段时间之后再完成这首歌，就不能获得分数了。\n\n这样的规则对 Yume 这样的老玩家来说本应是轻而易举，但不巧的是 Yume 把活动的结束时间记成了活动的开始时间，以至于当他上线跃跃欲试的时候，惊恐地发现活动已经快要结束了。现在他想知道，在剩余的时间之内，他能否完成所有的歌、达成奖励的分数线拿到活动卡。为了节省时间，他把这个问题交给了你来解决。请你根据给定的数据，帮他计算出能否在剩余的时间内达成目标。如果能，请告诉他完成每首歌曲的顺序。\n", "inputFormat": "输入的第一行是三个整数 $n,m,t$，分别表示规定完成的歌曲数目、获得奖励需要达到的最低分数和距离活动结束剩余的时间。\n\n接下来有 $n$ 行，第 $i$ 行有一个字符串 $S_i$ 和两个整数 $T_i$ 和 $M_i$，表示第 $i$ 首歌的歌名为 $S_i$，完成第 $i$ 首歌所需要的时间为 $T_i$，第 $i$ 首歌的奖励开放时间剩余 $M_i$。保证 $T_i\\le M_i$。其中数据已按 $S_i$ 的字典序给出。", "outputFormat": "如果在活动结束前 Yume 可以完成指定的目标拿到奖励，则在第一行输出一个整数 $C$，表示在获得奖励的前提下，所能够获得的分数的最大值；\n\n接下来的 $n$ 行中，按照完成歌曲的顺序输出第 $i$ 首歌的歌名。如果有多种可能性，则输出字典序最小的情况。\n\n如果在活动结束前 Yume 不能完成所有的歌曲，输出 `No Answer`。", "hint": "对于 $0\\%$ 的数据，与测试数据完全相同。\n\n对于 $20\\%$ 的数据，满足 $n \\le 5$。\n\n对于 $40\\%$ 的数据，满足 $n \\le 9$。\n\n对于 $70\\%$ 的数据，满足 $n \\le 15$。\n\n另有 $10\\%$ 的数据满足 $\\sum\\limits^{n}_{i=1} T_i < t$。\n\n对于 $100\\%$ 的数据，满足 $n \\le 22$，$S_i$ 的长度不超过 $50$。保证 $m,t,M_i,T_i$ 及其相加的结果都在 `int` 最大范围内。", "locale": "zh-CN", "translations": {"en": {"title": "Grind the Event", "background": "Yume has been playing a rhythm game called LoveLive! School idol festival. He likes it because the game is friendly to unlucky players: even if you are so unlucky that you cannot draw good cards, you can still earn rewards by reaching certain goals in the two events held each month.", "description": "Yume really likes the artwork of the reward card for this event, so he decides to grind this event to get the reward. The rules of this event are special: before the event’s end time, the player must finish all designated songs (each song can be played only once) and reach a certain score to claim the reward. If the player does not finish all the songs in time, or the score is below the threshold, the reward cannot be claimed. Each song has a limited reward open window. If the player finishes the song within this window, they earn a score (score earned = open window time − current total time used). If the song is completed after this window, no score is earned.\n\nThis should have been easy for a veteran like Yume, but he mistakenly remembered the event end time as the start time. When he logged in, he was shocked to find that the event was about to end. Now he wants to know whether, within the remaining time, he can finish all the songs and reach the score threshold to get the event card. To save time, he asks you to solve this problem. Based on the given data, determine whether he can achieve the goal in the remaining time. If he can, tell him the order in which to complete the songs.", "inputFormat": "The first line contains three integers $n,m,t$, representing the number of required songs, the minimum score needed to obtain the reward, and the remaining time until the event ends.\n\nThe next $n$ lines each contain a string $S_i$ and two integers $T_i$ and $M_i$, indicating that the $i$-th song’s name is $S_i$, completing the $i$-th song takes $T_i$ time, and the $i$-th song’s reward open window has $M_i$ time remaining. It is guaranteed that $T_i \\le M_i$. The input data are given in the lexicographic order of $S_i$.", "outputFormat": "If Yume can achieve the goal and claim the reward before the event ends, output an integer $C$ on the first line, representing the maximum score that can be obtained while still getting the reward.\n\nThen output $n$ lines, listing the song names in the order they are completed. If there are multiple valid orders, output the lexicographically smallest one.\n\nIf Yume cannot finish all the songs before the event ends, output `No Answer`.", "hint": "- For $0\\%$ of the testdata, it is identical to the testdata.\n- For $20\\%$ of the testdata, $n \\le 5$.\n- For $40\\%$ of the testdata, $n \\le 9$.\n- For $70\\%$ of the testdata, $n \\le 15$.\n- Additionally, for $10\\%$ of the testdata, $\\sum\\limits_{i=1}^{n} T_i < t$.\n- For $100\\%$ of the testdata, $n \\le 22$, the length of $S_i$ does not exceed $50$. It is guaranteed that $m, t, M_i, T_i$ and any of their sums are within the maximum range of `int`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "肝活动", "background": "Yume 最近在玩一个名为《LoveLive! School idol festival》的音乐游戏。他之所以喜欢上这个游戏，是因为这个游戏对非洲人十分友好，即便你脸黑到抽不出好卡，还可以通过在每个月举办的两次活动中达成一定的目标来获得奖励。", "description": "Yume 很喜欢这一期活动奖励卡的卡面，于是他决定要肝这一期的活动，拿到活动奖励。这一期的活动规则很特殊，玩家需要在活动规定的结束时间前，完成所有指定的歌曲（**每首歌曲只能打一次**），并获得一定的分数，就可以拿到活动奖励。如果在规定的时间前没有完成所有的歌曲，或者分数不够奖励的分数线，则不能领取活动奖励。每首歌有一个限定的奖励开放时间，玩家如果在这段时间内完成了这首歌，便可以获得一定的分数（**获得的分数 = 开放时间 - 当前已用的总时间**）。如果超出了这段时间之后再完成这首歌，就不能获得分数了。\n\n这样的规则对 Yume 这样的老玩家来说本应是轻而易举，但不巧的是 Yume 把活动的结束时间记成了活动的开始时间，以至于当他上线跃跃欲试的时候，惊恐地发现活动已经快要结束了。现在他想知道，在剩余的时间之内，他能否完成所有的歌、达成奖励的分数线拿到活动卡。为了节省时间，他把这个问题交给了你来解决。请你根据给定的数据，帮他计算出能否在剩余的时间内达成目标。如果能，请告诉他完成每首歌曲的顺序。\n", "inputFormat": "输入的第一行是三个整数 $n,m,t$，分别表示规定完成的歌曲数目、获得奖励需要达到的最低分数和距离活动结束剩余的时间。\n\n接下来有 $n$ 行，第 $i$ 行有一个字符串 $S_i$ 和两个整数 $T_i$ 和 $M_i$，表示第 $i$ 首歌的歌名为 $S_i$，完成第 $i$ 首歌所需要的时间为 $T_i$，第 $i$ 首歌的奖励开放时间剩余 $M_i$。保证 $T_i\\le M_i$。其中数据已按 $S_i$ 的字典序给出。", "outputFormat": "如果在活动结束前 Yume 可以完成指定的目标拿到奖励，则在第一行输出一个整数 $C$，表示在获得奖励的前提下，所能够获得的分数的最大值；\n\n接下来的 $n$ 行中，按照完成歌曲的顺序输出第 $i$ 首歌的歌名。如果有多种可能性，则输出字典序最小的情况。\n\n如果在活动结束前 Yume 不能完成所有的歌曲，输出 `No Answer`。", "hint": "对于 $0\\%$ 的数据，与测试数据完全相同。\n\n对于 $20\\%$ 的数据，满足 $n \\le 5$。\n\n对于 $40\\%$ 的数据，满足 $n \\le 9$。\n\n对于 $70\\%$ 的数据，满足 $n \\le 15$。\n\n另有 $10\\%$ 的数据满足 $\\sum\\limits^{n}_{i=1} T_i < t$。\n\n对于 $100\\%$ 的数据，满足 $n \\le 22$，$S_i$ 的长度不超过 $50$。保证 $m,t,M_i,T_i$ 及其相加的结果都在 `int` 最大范围内。", "locale": "zh-CN"}}}
{"pid": "P3948", "type": "P", "difficulty": 3, "samples": [["3 2 4 0 2\nA 1 3 5\nQ 2 3 \n5\n1 3\n2 3\n1 1 \n2 2 \n3 3\n", "1\n2\n1\n1\n1\n0\n"], ["17 25 4098 310 2622\nA 10 16 657212040\nA 4 15 229489140\nA 1 2 -433239891\nA 3 12 532385784\nA 10 17 56266644\nA 8 10 10038874\nA 6 9 13084764\nA 4 5 -9206340\nQ 2 8\nA 2 4 -43223955\nA 6 9 31478706\nA 2 4 189818310\nA 2 8 179421180\nA 2 8 40354938\nQ 8 14\nA 3 6 57229575\nA 6 13 132795740\nA 2 17 14558022\nA 14 15 -552674185\nA 5 11 -1104138\nQ 2 12\nQ 1 14\nA 3 9 524902182\nA 8 12 114291440\nA 3 7 107531442\n1\n11 12\n", "3\n6\n7\n8\n2\n"], ["20 3 4317 1020 2232\nA 8 15 -434078222\nA 1 2 54988154\nA 13 19 81757858\n15\n7 11\n3 5\n3 9\n6 9\n9 13\n6 19\n1 20\n3 5\n3 10\n1 7\n2 14\n6 10\n2 3\n2 3\n10 12\n", "0\n0\n0\n0\n0\n2\n2\n0\n0\n0\n0\n0\n0\n0\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "树状数组", "前缀和", "差分"], "title": "数据结构", "background": "**引言**\n\n数据结构学得好，未来工作没烦恼。\n\nEdgration（以下简称 edt）是一个喜欢乱搞数据结构的蒟蒻。有一天，他作死想去刁难一下 dalao：\n\nedt：想求一种数据结构，使得可以实现区间加，求出某一区间大于 $k$ 的元素的个数。\n\ndalao1：sb 线段树。\n\ndalao2：sb 分块。\n\ndalao3：sb 平衡树。\n\nedt: 不行，那就加上取模，求区间取模 mod 后大于 MIN 小于 MAX 的元素个数。\n\ndalao1：线段树&……￥#&……%……&\\*&%￥。\n\ndalao2：sb 分块 &%￥……%#￥#&……&\\*。\n\ndalao3：*&……%&￥ LCT 维护 SBT 水题 &……%&……%。\n\nedt：那不仅取模，每个数乘上数组下标再取模。\n\ndalao：￥%￥￥&*（#￥% 叽里呱啦叽里呱啦。\n\nedt：不行，再把取模的值丢到一棵树上，维护一棵仙人掌乘积方差的最小极差。\n\ndalao：替罪羊树上用 sb 块状链表维护 Toptree 上的最小费用最大流和可持久化仙人掌，算出来在基尔霍夫矩阵中反演后跑一遍 fft 维护的插头 DP 就好了，给我三分钟轻松水过。\n\nedt：mmp。", "description": "蒟蒻 edt 把这个问题交给了你—— 一个精通数据结构的大犇，由于是第一题，这个题没那么难。\n\n![图片已丢失](https://timgsa.baidu.com/timg?image&quality=80&size=b9999\\_10000&sec=1508946101936&di=0c08b703e466d2a3b2d20dd8008821fc&imgtype=0&src=http%3A%2F%2Fjoymepic.joyme.com%2Farticle%2Fuploads%2Fallimg%2F201511%2F1446516425349678.gif)\n\nedt 现在对于题目进行了如下的简化：\n\n最开始的数组每个元素都是 $0$。\n\n\n给出 $\\text{n},\\text{opt},\\text{mod},\\text{min},\\text{max}$ 在 `int` 范围内。\n\n\n操作 $A,Q$：\n\n\n`A L R X` 表示把 $[L,R]$ 这个区间加上 $X$。\n\n**（数组的从 $L$ 到 $R$ 的每个元素都加上 $X$）**\n\n\n`Q L R` 表示询问 $[L,R]$ 这个区间中元素 $T$ 满足 $\\text{min}\\le (T\\times i\\ mod\\ \\text{mod})\\le \\text{max}$  的 $T$ 这样的数的个数（$i$ 是数组下标）。\n\n**（元素的值 $\\times$ 数组下标对 $\\text{mod}$ 取模的值在 $\\min$ 到 $\\max$ 范围内）**\n\n\n由于 edt 请来了一位非三次元的仓鼠，他帮你延后了部分问题，将这些询问打入了混乱时空，你的询问操作不会超过 $1000$ 次，不幸的是，对于延后的询问操作可能有很多次（小于 $1\\times10^7$ 次），但是保证这些延后的询问操作之后不会再次有修改操作（就是在最后会有很多次询问，但不会进行修改）。", "inputFormat": "第一行给出 $\\text{n},\\text{opt},\\text{mod},\\text{min},\\text{max}$ 分别表示序列大小，操作次数，取模，最小值，最大值。\n\n\n之后 $\\text{opt}$ 行，给出：\n\n\n`A L R X` 表示区间加，保证 $\\text{X}$ 在 `int` 范围内。\n\n\n`Q L R` 表示区间查询满足条件的个数。\n\n\n第 $\\text{opt}+1$ 行给出一个数 $\\text{Final}$，表示后面有 $\\text{Final}$ 个询问。\n\n\n之后 $\\text{Final}$ 行，给出 $L,R$ 表示询问区间 $[L,R]$ 表示询问 $[L,R]$ 之间满足条件的个数。", "outputFormat": "对于每个 $Q$ 操作，每行输出一个数表示每次询问的值。\n\n之后 $\\text{Final}$ 行，每行输出一个数表示被延后的 $\\text{Final}$ 个询问的值。", "hint": "## 样例说明\n\n给出样例 1 的解释：\n\n样例 1 中，$a$ 数组修改为$5,5,5$，每个 $a_i\\times i\\ mod\\ 4$ 的值为 $1,2,3$。\n\n对于 $\\text{Final}$ 的询问，询问 $[1,3]$ 中大于等于 $0$ 小于等于 $2$ 的个数为 $2$ 个。\n\n剩下的询问类似。\n\n## 题目说明\n\n**注意**：\n \n### 1.关于负数取模问题，请以 C++ 的向 $0$ 取整为标准，即如：\n\n[ $ -7 \\bmod 3 = -1 $ ]  [ $ 7 \\bmod 3 = 1 $ ]\n\n### 2.一共有 50 个测试点，每个点分值为 2 分。\n\n因为测试点数较多，请 OIer 们自觉地不要故意多次提交来卡评测机，出题人 edt 在这里表示由衷的感谢。\n\n## 数据范围\n\n如果你不能做对所有点，请尝试获得部分分，所有数据都是随机生成。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/whf39g4d.png)", "locale": "zh-CN", "translations": {"en": {"title": "Data Structures", "background": "Introduction\n\nIf you learn data structures well, your future job will have no worries.\n\nEdgration (hereafter edt) is a \"ju ruo\" (newbie) who likes to mess with data structures. One day, he decided to make things hard for some \"dalao\" (experts):\n\nedt: I want a data structure that supports range add and can return the number of elements greater than $k$ in a given interval.\n\ndalao1: sb segment tree.\n\ndalao2: sb block decomposition.\n\ndalao3: sb balanced tree.\n\nedt: Not good enough, then add modulo: count, after taking modulo, how many numbers in the interval are greater than MIN and less than MAX.\n\ndalao1: segment tree &……￥#&……%……&\\*&%￥.\n\ndalao2: sb block decomposition &%￥……%#￥#&……&\\*.\n\ndalao3: *&……%&￥ LCT maintaining SBT easy problem &……%&……%.\n\nedt: Not only modulo, but also multiply each number by its array index and then take modulo.\n\ndalao: ￥%￥￥&*（#￥% gibberish gibberish.\n\nedt: No, then throw the modulo values onto a tree and maintain the minimum range of the cactus product variance.\n\ndalao: Use scapegoat tree with sb block linked list to maintain min-cost max-flow on Toptree and a persistent cactus, then invert in the Kirchhoff matrix and run plug DP maintained by fft. Give me three minutes, easy pass.\n\nedt: mmp.", "description": "The newbie edt gives this problem to you—a master of data structures. Since this is the first problem, it is not that hard.\n\n![图片已丢失](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1508946101936&di=0c08b703e466d2a3b2d20dd8008821fc&imgtype=0&src=http%3A%2F%2Fjoymepic.joyme.com%2Farticle%2Fuploads%2Fallimg%2F201511%2F1446516425349678.gif)\n\nThe problem is simplified as follows:\n\n- Initially, every element in the array is $0$.\n- You are given $\\text{n}, \\text{opt}, \\text{mod}, \\text{min}, \\text{max}$ within the range of `int`.\n\nOperations $A, Q$:\n\n- `A L R X` means add $X$ to the interval $[L, R]$.\n  (Every element from $L$ to $R$ in the array is increased by $X$.)\n- `Q L R` asks, in the interval $[L, R]$, for the count of elements $T$ such that $\\text{min} \\le (T \\times i \\mod \\text{mod}) \\le \\text{max}$, where $i$ is the array index.\n  (The value of the element times its index, modulo $\\text{mod}$, falls within the range from $\\min$ to $\\max$, inclusive.)\n\nBecause edt invited a non-3D hamster to help, some queries are postponed into a chaotic spacetime. The number of online `Q` operations will not exceed $1000$. Unfortunately, there may be many postponed queries (less than $1 \\times 10^7$), but it is guaranteed that after these postponed queries, there will be no more update operations (that is, at the end there are many queries but no modifications).", "inputFormat": "- The first line gives $\\text{n}, \\text{opt}, \\text{mod}, \\text{min}, \\text{max}$, representing the sequence size, the number of operations, the modulo, the minimum value, and the maximum value.\n- Then follow $\\text{opt}$ lines, each being one of:\n  - `A L R X` denotes a range add. $\\text{X}$ is guaranteed to be within the range of `int`.\n  - `Q L R` denotes a range query asking for the count that satisfies the condition.\n- The $(\\text{opt} + 1)$-th line gives a number $\\text{Final}$, meaning there are $\\text{Final}$ postponed queries after that.\n- Then follow $\\text{Final}$ lines, each giving $L, R$, asking for the count that satisfies the condition in $[L, R]$.", "outputFormat": "- For each `Q` operation, output one number per line representing the answer to that query.\n- Then output $\\text{Final}$ lines, each with one number representing the answer to each postponed query.", "hint": "Sample Explanation\n\nExplanation for Sample 1:\n\nIn Sample 1, the array $a$ becomes $5, 5, 5$. Each $a_i \\times i \\mod 4$ equals $1, 2, 3$.\n\nFor the $\\text{Final}$ queries, in $[1, 3]$, the count of values greater than or equal to $0$ and less than or equal to $2$ is $2$.\n\nThe rest are similar.\n\nNotes\n\n- Important:\n  - Regarding modulo with negative numbers, follow C++ truncation toward $0$. For example:\n    [ $ -7 \\bmod 3 = -1 $ ]  [ $ 7 \\bmod 3 = 1 $ ].\n- There are 50 test points, each worth 2 points.\n  Because there are many test points, please do not intentionally submit many times to jam the judge. The author edt expresses sincere thanks.\n\nConstraints\n\nIf you cannot solve all points, try to obtain partial scores. All testdata are randomly generated.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/whf39g4d.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数据结构", "background": "**引言**\n\n数据结构学得好，未来工作没烦恼。\n\nEdgration（以下简称 edt）是一个喜欢乱搞数据结构的蒟蒻。有一天，他作死想去刁难一下 dalao：\n\nedt：想求一种数据结构，使得可以实现区间加，求出某一区间大于 $k$ 的元素的个数。\n\ndalao1：sb 线段树。\n\ndalao2：sb 分块。\n\ndalao3：sb 平衡树。\n\nedt: 不行，那就加上取模，求区间取模 mod 后大于 MIN 小于 MAX 的元素个数。\n\ndalao1：线段树&……￥#&……%……&\\*&%￥。\n\ndalao2：sb 分块 &%￥……%#￥#&……&\\*。\n\ndalao3：*&……%&￥ LCT 维护 SBT 水题 &……%&……%。\n\nedt：那不仅取模，每个数乘上数组下标再取模。\n\ndalao：￥%￥￥&*（#￥% 叽里呱啦叽里呱啦。\n\nedt：不行，再把取模的值丢到一棵树上，维护一棵仙人掌乘积方差的最小极差。\n\ndalao：替罪羊树上用 sb 块状链表维护 Toptree 上的最小费用最大流和可持久化仙人掌，算出来在基尔霍夫矩阵中反演后跑一遍 fft 维护的插头 DP 就好了，给我三分钟轻松水过。\n\nedt：mmp。", "description": "蒟蒻 edt 把这个问题交给了你—— 一个精通数据结构的大犇，由于是第一题，这个题没那么难。\n\n![图片已丢失](https://timgsa.baidu.com/timg?image&quality=80&size=b9999\\_10000&sec=1508946101936&di=0c08b703e466d2a3b2d20dd8008821fc&imgtype=0&src=http%3A%2F%2Fjoymepic.joyme.com%2Farticle%2Fuploads%2Fallimg%2F201511%2F1446516425349678.gif)\n\nedt 现在对于题目进行了如下的简化：\n\n最开始的数组每个元素都是 $0$。\n\n\n给出 $\\text{n},\\text{opt},\\text{mod},\\text{min},\\text{max}$ 在 `int` 范围内。\n\n\n操作 $A,Q$：\n\n\n`A L R X` 表示把 $[L,R]$ 这个区间加上 $X$。\n\n**（数组的从 $L$ 到 $R$ 的每个元素都加上 $X$）**\n\n\n`Q L R` 表示询问 $[L,R]$ 这个区间中元素 $T$ 满足 $\\text{min}\\le (T\\times i\\ mod\\ \\text{mod})\\le \\text{max}$  的 $T$ 这样的数的个数（$i$ 是数组下标）。\n\n**（元素的值 $\\times$ 数组下标对 $\\text{mod}$ 取模的值在 $\\min$ 到 $\\max$ 范围内）**\n\n\n由于 edt 请来了一位非三次元的仓鼠，他帮你延后了部分问题，将这些询问打入了混乱时空，你的询问操作不会超过 $1000$ 次，不幸的是，对于延后的询问操作可能有很多次（小于 $1\\times10^7$ 次），但是保证这些延后的询问操作之后不会再次有修改操作（就是在最后会有很多次询问，但不会进行修改）。", "inputFormat": "第一行给出 $\\text{n},\\text{opt},\\text{mod},\\text{min},\\text{max}$ 分别表示序列大小，操作次数，取模，最小值，最大值。\n\n\n之后 $\\text{opt}$ 行，给出：\n\n\n`A L R X` 表示区间加，保证 $\\text{X}$ 在 `int` 范围内。\n\n\n`Q L R` 表示区间查询满足条件的个数。\n\n\n第 $\\text{opt}+1$ 行给出一个数 $\\text{Final}$，表示后面有 $\\text{Final}$ 个询问。\n\n\n之后 $\\text{Final}$ 行，给出 $L,R$ 表示询问区间 $[L,R]$ 表示询问 $[L,R]$ 之间满足条件的个数。", "outputFormat": "对于每个 $Q$ 操作，每行输出一个数表示每次询问的值。\n\n之后 $\\text{Final}$ 行，每行输出一个数表示被延后的 $\\text{Final}$ 个询问的值。", "hint": "## 样例说明\n\n给出样例 1 的解释：\n\n样例 1 中，$a$ 数组修改为$5,5,5$，每个 $a_i\\times i\\ mod\\ 4$ 的值为 $1,2,3$。\n\n对于 $\\text{Final}$ 的询问，询问 $[1,3]$ 中大于等于 $0$ 小于等于 $2$ 的个数为 $2$ 个。\n\n剩下的询问类似。\n\n## 题目说明\n\n**注意**：\n \n### 1.关于负数取模问题，请以 C++ 的向 $0$ 取整为标准，即如：\n\n[ $ -7 \\bmod 3 = -1 $ ]  [ $ 7 \\bmod 3 = 1 $ ]\n\n### 2.一共有 50 个测试点，每个点分值为 2 分。\n\n因为测试点数较多，请 OIer 们自觉地不要故意多次提交来卡评测机，出题人 edt 在这里表示由衷的感谢。\n\n## 数据范围\n\n如果你不能做对所有点，请尝试获得部分分，所有数据都是随机生成。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/whf39g4d.png)", "locale": "zh-CN"}}}
{"pid": "P3949", "type": "P", "difficulty": 5, "samples": [["3\n2\n4 5", "X\nZ\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": [], "title": "答案错误", "background": "**本题可能不存在唯一解，当前本题与题解仅作参考。**\n\n小 X 比较差，她（她？tan90°）有许多 WA 掉的题，所以她很难受。小 Z 决定去安慰她，可是他的提交记录里一道 WA 都没有（flag），于是他决定篡改一半题的署名，让小 X 觉得他们的错题相当，这样她会好受一些。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cbmwn01e.png)", "description": "每道 WA 了的题都会有一个分数，对于两个人的 WA 题程度是否相同，小X有这样一个评判方法：\n\n无聊的她想了这样一个神奇的函数：\n\n$$f(x)=a_1x^0+a_2x^1+a_3x^2+\\cdots+a_{n}x^{n-1}$$\n\n她认为，无论 $a_i$ 取什么值，两组 $f(x)$ 的和都相等，则这两组题的错误程度很相似。\n\n假如有分值为 $A=\\{1,4,6,7 \\},B=\\{2,3,5,8\\}$ 的两份被篡改完成的 WA 题，当 $a_1=a_2=a_3=1$ 时，神奇的函数为：\n\n$$f(x)=x^2+x+1$$\n\n那么，$f(1)=3,f(2)=7,f(3)=13\\cdots$\n\n显然：$ f(1) + f(4) + f(6) + f(7) = 124 = f(2) + f(3) +f(5) +f(8)$。\n\n对于这组系数，此分组方案是合法的，可以证明，$a_i$ 取任意值，按照以上方案分组都满足条件（两组的 $f(x)$ 和相同），不信可以手动枚举（#滑稽）。\n\n所以，$A=\\{1,4,6,7 \\},B=\\{2,3,5,8\\}$。就是一种合法的分组。\n", "inputFormat": "第一行一个整数 $n$，代表有 $2^n$ 道 WA 题，分值分别从$1$ 到 $2^n$，满足 $n\\ge 2$。\n\n第二行一个整数 $q$，表示有 $q$ 组询问。\n\n最后一行 $q$ 个整数，询问分值为 $x$ 的 WA 题是谁的名字。\n\n（因为小 X 比较菜，所以我们认为分值为 $1$ 的 WA 题是属于她的）\n", "outputFormat": "一共 $q$ 行，每行一个字符 $\\verb!X!$ 或 $\\verb!Z!$，表示分值为 $x$ 的 WA 题是谁的署名。\n", "hint": "### 数据范围及约定\n\n- 对于 $10\\%$ 的数据，$2\\le n\\le 4$，$q\\le 10$；\n- 对于 $40\\%$ 的数据，$2\\le n\\le 20$，$1\\le q\\le 5000$；\n- 对于 $100\\%$ 的数据，$2\\le n\\le 60$，$q\\le 10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Wrong Answer", "background": "**This problem may not have a unique solution; the current problem and solution are for reference only.**\n\nXiao X is not very good (she? tan 90°) and has many problems that were WA, so she feels upset. Xiao Z decides to comfort her, but there is not a single WA in his submission history (flag). So he decides to alter the signature of half of the problems, making Xiao X feel that their wrong problems are comparable, so she will feel better.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cbmwn01e.png)", "description": "Each problem that was WA has a score. To judge whether the degree of WA problems is the same for the two people, Xiao X uses the following method:\n\nWhen bored, she came up with a magical function:\n\n$$f(x)=a_1x^0+a_2x^1+a_3x^2+\\cdots+a_{n}x^{n-1}$$\n\nShe believes that no matter what values $a_i$ take, if the sums of $f(x)$ over two groups are equal, then the error levels of the two groups of problems are very similar.\n\nSuppose there are two modified sets of WA problems with scores $A=\\{1,4,6,7 \\}$ and $B=\\{2,3,5,8\\}$. When $a_1=a_2=a_3=1$, the magical function is:\n\n$$f(x)=x^2+x+1$$\n\nThen $f(1)=3, f(2)=7, f(3)=13 \\cdots$.\n\nObviously: $ f(1) + f(4) + f(6) + f(7) = 124 = f(2) + f(3) + f(5) + f(8)$.\n\nFor this set of coefficients, this partition is valid. It can be proven that for any values of $a_i$, grouping according to the above scheme satisfies the condition (the sums of $f(x)$ over the two groups are the same). If you do not believe it, you can enumerate manually (#huaji).\n\nSo $A=\\{1,4,6,7 \\}, B=\\{2,3,5,8\\}$ is a valid grouping.", "inputFormat": "The first line contains an integer $n$, meaning there are $2^n$ WA problems, with scores from $1$ to $2^n$, with $n \\ge 2$.\n\nThe second line contains an integer $q$, indicating there are $q$ queries.\n\nThe last line contains $q$ integers, each asking whose name is on the WA problem with score $x$.\n\n(Because Xiao X is relatively weak, we assume the WA problem with score $1$ belongs to her.)", "outputFormat": "Output $q$ lines, each containing a character $\\verb!X!$ or $\\verb!Z!$, indicating whose signature is on the WA problem with score $x$.", "hint": "### Constraints and Conventions\n\n- For $10\\%$ of the testdata, $2 \\le n \\le 4$, $q \\le 10$.\n- For $40\\%$ of the testdata, $2 \\le n \\le 20$, $1 \\le q \\le 5000$.\n- For $100\\%$ of the testdata, $2 \\le n \\le 60$, $q \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "答案错误", "background": "**本题可能不存在唯一解，当前本题与题解仅作参考。**\n\n小 X 比较差，她（她？tan90°）有许多 WA 掉的题，所以她很难受。小 Z 决定去安慰她，可是他的提交记录里一道 WA 都没有（flag），于是他决定篡改一半题的署名，让小 X 觉得他们的错题相当，这样她会好受一些。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cbmwn01e.png)", "description": "每道 WA 了的题都会有一个分数，对于两个人的 WA 题程度是否相同，小X有这样一个评判方法：\n\n无聊的她想了这样一个神奇的函数：\n\n$$f(x)=a_1x^0+a_2x^1+a_3x^2+\\cdots+a_{n}x^{n-1}$$\n\n她认为，无论 $a_i$ 取什么值，两组 $f(x)$ 的和都相等，则这两组题的错误程度很相似。\n\n假如有分值为 $A=\\{1,4,6,7 \\},B=\\{2,3,5,8\\}$ 的两份被篡改完成的 WA 题，当 $a_1=a_2=a_3=1$ 时，神奇的函数为：\n\n$$f(x)=x^2+x+1$$\n\n那么，$f(1)=3,f(2)=7,f(3)=13\\cdots$\n\n显然：$ f(1) + f(4) + f(6) + f(7) = 124 = f(2) + f(3) +f(5) +f(8)$。\n\n对于这组系数，此分组方案是合法的，可以证明，$a_i$ 取任意值，按照以上方案分组都满足条件（两组的 $f(x)$ 和相同），不信可以手动枚举（#滑稽）。\n\n所以，$A=\\{1,4,6,7 \\},B=\\{2,3,5,8\\}$。就是一种合法的分组。\n", "inputFormat": "第一行一个整数 $n$，代表有 $2^n$ 道 WA 题，分值分别从$1$ 到 $2^n$，满足 $n\\ge 2$。\n\n第二行一个整数 $q$，表示有 $q$ 组询问。\n\n最后一行 $q$ 个整数，询问分值为 $x$ 的 WA 题是谁的名字。\n\n（因为小 X 比较菜，所以我们认为分值为 $1$ 的 WA 题是属于她的）\n", "outputFormat": "一共 $q$ 行，每行一个字符 $\\verb!X!$ 或 $\\verb!Z!$，表示分值为 $x$ 的 WA 题是谁的署名。\n", "hint": "### 数据范围及约定\n\n- 对于 $10\\%$ 的数据，$2\\le n\\le 4$，$q\\le 10$；\n- 对于 $40\\%$ 的数据，$2\\le n\\le 20$，$1\\le q\\le 5000$；\n- 对于 $100\\%$ 的数据，$2\\le n\\le 60$，$q\\le 10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P3950", "type": "P", "difficulty": 5, "samples": [["5 9\n1 2\n2 3\n3 4\n4 5\nQ 1 4\nC 2 1\nC 4 3\nQ 3 1\nQ 1 5\nU 1\nU 2\nC 4 3\nQ 3 4", "Yes\nNo\nNo\nNo"], ["10 10\n1 2\n1 3\n3 4\n3 5\n1 6\n3 7\n1 8\n2 9\n5 10\nC 8 1\nQ 6 1\nC 2 1\nQ 2 10\nU 1\nC 9 2\nC 7 3\nU 3\nQ 6 7\nQ 1 10", "Yes\nNo\nNo\nYes"], ["20 20\n1 2\n1 3\n2 4\n1 5\n1 6\n4 7\n1 8\n2 9\n5 10\n1 11\n2 12\n7 13\n1 14\n1 15\n11 16\n4 17\n3 18\n18 19\n8 20\nQ 13 5\nC 14 1\nC 16 11\nU 1\nU 2\nC 20 8\nQ 7 1\nC 7 4\nQ 17 17\nQ 1 6\nC 16 11\nC 2 1\nQ 16 2\nU 3\nU 5\nU 6\nC 2 1\nC 6 1\nC 13 7\nC 11 1\n", "Yes\nYes\nYes\nYes\nNo\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "树状数组", "最近公共祖先 LCA", "树链剖分", "动态树 LCT"], "title": "部落冲突", "background": "在一个叫做 Travian 的世界里，生活着各个大大小小的部落。其中最为强大的是罗马、高卢和日耳曼。他们之间为了争夺资源和土地，进行了无数次的战斗。期间诞生了众多家喻户晓的英雄人物，也留下了许多可歌可泣的动人故事。\n\n![](http://img4.dwstatic.com/coc/1602/320370032694/1456415099616.jpg)\n\n其中，在大大小小的部落之间，会有一些道路相连，这些道路是 Travian 世界里的重要枢纽，简单起见，你可以把这些部落与部落之间相连的道路看作一颗树，可见每条道路对于 Travian 世界的重要程度。有了这些道路，建筑工人就可以通过这些道路进行友好外交啦。\n\n然而，事情并不会像想象的那样美好，由于资源的匮乏，相邻的部落（由一条道路相连的部落）之间经常会发生大大小小的冲突事件，更有甚者，会升级为部落之间的大型战争。\n\n为了避免误伤，每当两个相邻的部落之间发生大型战争之时，这两个部落间的道路是不允许通行的，对于一些强大的部落，甚至能与多个相邻的部落同时开战，同样的，这些战争地带的道路十分危险，是不可通行的。\n\n天下之势，分久必合，当两个部落经历了不打不相识的苦战之后，他们可以签订停战协议（暂时停战，以后依旧可能再次开战），这样，两个部落之间的道路又会重新恢复为可通行状态，建筑工人们又可以经过此地购买最新的大本营设计图纸来强大自己的部落了。\n\n为了简单起见，我们把各大战争事件按发起的时间顺序依次编号（最先发起的战争编号就为 $1$，第二次战争编号就为 $2$，以此类推），当两个部落停战之时，则会直接告诉你这场战争的编号，然后这场战争就载入了史册，不复存在了，当然，这并不会影响到其他战争的编号。\n\n建筑工人十分讨厌战争，因为战争，想从一个部落到另一个部落进行友好交流的建筑工人可能就此白跑一趟。所以，在他们出发之前，都会向你问问能不能到达他们想去的部落。\n", "description": "简单起见，你就是要处理下面三件事，所有的事件都是按照时间顺序给出的。\n\n1. `Q p q` 从第 $p$ 个部落出发的建筑工人想知道能否到达第 $q$ 个部落了，你要回答的便是 `Yes` / `No`，注意**大小写**。\n\n2. `C p q` 第 $p$ 个部落与第 $q$ 个部落开战了，保证他们一定是相邻的部落，且目前处于停战（未开战）状态。\n\n3. `U x` 第 $x$ 次发生的战争结束了，它将永远的被载入史册，不复存在（保证这个消息不会告诉你多次）\n", "inputFormat": "第一行两个数 $n$ 和 $m$， $n$ 代表了一共有 $n$ 个部落，$m$ 代表了以上三种事件发生的总数。\n\n接下来的 $n - 1$ 行，每行两个数 $p, q$，代表了第 $p$ 个部落与第 $q$ 个部落之间有一条道路相连。\n\n接下来的 $m$ 行，每行表示一件事，详见题目描述。", "outputFormat": "每行一个 `Yes` 或者 `No`，表示从第 $p$ 个部落出发的建筑工人能否到达第 $q$ 个部落。", "hint": "对于 $30\\%$ 的数据，$n, m\\leq 6\\times10^3$。\n\n对于另 $30\\%$ 的数据，保证部落之间的地理关系是一条链，且 $i$ 与 $i + 1$ 之间有一条道路。\n\n对于另 $30\\%$ 的数据，$n, m\\leq 10^5$。\n\n对于 $100\\%$ 的数据，$1\\leq n, m\\leq 3\\times10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "{{Tribal Conflict}}", "background": "{{In a world called Travian live many tribes both large and small. The strongest among them are the Romans, Gauls, and Germans. They have fought countless battles over resources and land. Many famous heroes were born during these times, and many moving stories were left behind.\n\n![](http://img4.dwstatic.com/coc/1602/320370032694/1456415099616.jpg)\n\nBetween the many tribes, there are roads connecting them. For simplicity, you can regard the road network between tribes as a tree, which shows how important each road is in the Travian world. With these roads, builders can travel for friendly diplomacy.\n\nHowever, things are not always so pleasant. Due to a lack of resources, neighboring tribes (connected by one road) often have conflicts, and sometimes these escalate into large-scale wars between tribes.\n\nTo avoid collateral damage, whenever two neighboring tribes are at large-scale war, the road between them is closed to traffic. Some powerful tribes can even go to war with multiple neighboring tribes at the same time; the roads within these war zones are dangerous and impassable.\n\nAs the saying goes, after long division comes union. After a hard battle, two tribes may sign a truce agreement (a temporary ceasefire; they may go to war again later). Then the road between them becomes passable again, and builders can pass through to buy the latest Town Hall blueprints to strengthen their tribes.\n\nFor simplicity, we number all war events in the order they start (the earliest war is numbered $1$, the second $2$, and so on). When two tribes make a truce, you will be told the number of that war. That war is then recorded in history and no longer exists. Of course, this does not affect the numbering of other wars.\n\nBuilders hate wars. Because of wars, a builder traveling from one tribe to another for friendly exchange may make a wasted trip. So before they set out, they will ask you whether they can reach their destination.}}", "description": "{{You need to handle the three types of events below. All events are given in chronological order. Initially, all roads are passable (no wars).\n\n1. `Q p q` A builder starting from the $p$-th tribe wants to know whether they can reach the $q$-th tribe. You must answer `Yes` / `No`. Note the capitalization.\n\n2. `C p q` The $p$-th tribe and the $q$-th tribe go to war. It is guaranteed they are adjacent tribes and are currently in a truce (not at war). The road between them becomes impassable.\n\n3. `U x` The $x$-th war ends and is recorded in history; it no longer exists (this message will not be given multiple times). The corresponding road becomes passable again.}}", "inputFormat": "{{The first line contains two integers $n$ and $m$: $n$ is the number of tribes, and $m$ is the total number of events.\n\nThe next $n - 1$ lines each contain two integers $p, q$, indicating there is a road connecting the $p$-th tribe and the $q$-th tribe.\n\nThe next $m$ lines each describe one event, as detailed in the Description.}}", "outputFormat": "{{For each query, output one `Yes` or `No` on its own line, indicating whether a builder starting from the $p$-th tribe can reach the $q$-th tribe.}}", "hint": "{{For $30\\%$ of the testdata, $n, m \\leq 6 \\times 10^3$.\n\nFor another $30\\%$ of the testdata, the tribes form a chain, and there is a road between $i$ and $i + 1$.\n\nFor another $30\\%$ of the testdata, $n, m \\leq 10^5$.\n\nFor $100\\%$ of the testdata, $1 \\leq n, m \\leq 3 \\times 10^5$.}}\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "部落冲突", "background": "在一个叫做 Travian 的世界里，生活着各个大大小小的部落。其中最为强大的是罗马、高卢和日耳曼。他们之间为了争夺资源和土地，进行了无数次的战斗。期间诞生了众多家喻户晓的英雄人物，也留下了许多可歌可泣的动人故事。\n\n![](http://img4.dwstatic.com/coc/1602/320370032694/1456415099616.jpg)\n\n其中，在大大小小的部落之间，会有一些道路相连，这些道路是 Travian 世界里的重要枢纽，简单起见，你可以把这些部落与部落之间相连的道路看作一颗树，可见每条道路对于 Travian 世界的重要程度。有了这些道路，建筑工人就可以通过这些道路进行友好外交啦。\n\n然而，事情并不会像想象的那样美好，由于资源的匮乏，相邻的部落（由一条道路相连的部落）之间经常会发生大大小小的冲突事件，更有甚者，会升级为部落之间的大型战争。\n\n为了避免误伤，每当两个相邻的部落之间发生大型战争之时，这两个部落间的道路是不允许通行的，对于一些强大的部落，甚至能与多个相邻的部落同时开战，同样的，这些战争地带的道路十分危险，是不可通行的。\n\n天下之势，分久必合，当两个部落经历了不打不相识的苦战之后，他们可以签订停战协议（暂时停战，以后依旧可能再次开战），这样，两个部落之间的道路又会重新恢复为可通行状态，建筑工人们又可以经过此地购买最新的大本营设计图纸来强大自己的部落了。\n\n为了简单起见，我们把各大战争事件按发起的时间顺序依次编号（最先发起的战争编号就为 $1$，第二次战争编号就为 $2$，以此类推），当两个部落停战之时，则会直接告诉你这场战争的编号，然后这场战争就载入了史册，不复存在了，当然，这并不会影响到其他战争的编号。\n\n建筑工人十分讨厌战争，因为战争，想从一个部落到另一个部落进行友好交流的建筑工人可能就此白跑一趟。所以，在他们出发之前，都会向你问问能不能到达他们想去的部落。\n", "description": "简单起见，你就是要处理下面三件事，所有的事件都是按照时间顺序给出的。\n\n1. `Q p q` 从第 $p$ 个部落出发的建筑工人想知道能否到达第 $q$ 个部落了，你要回答的便是 `Yes` / `No`，注意**大小写**。\n\n2. `C p q` 第 $p$ 个部落与第 $q$ 个部落开战了，保证他们一定是相邻的部落，且目前处于停战（未开战）状态。\n\n3. `U x` 第 $x$ 次发生的战争结束了，它将永远的被载入史册，不复存在（保证这个消息不会告诉你多次）\n", "inputFormat": "第一行两个数 $n$ 和 $m$， $n$ 代表了一共有 $n$ 个部落，$m$ 代表了以上三种事件发生的总数。\n\n接下来的 $n - 1$ 行，每行两个数 $p, q$，代表了第 $p$ 个部落与第 $q$ 个部落之间有一条道路相连。\n\n接下来的 $m$ 行，每行表示一件事，详见题目描述。", "outputFormat": "每行一个 `Yes` 或者 `No`，表示从第 $p$ 个部落出发的建筑工人能否到达第 $q$ 个部落。", "hint": "对于 $30\\%$ 的数据，$n, m\\leq 6\\times10^3$。\n\n对于另 $30\\%$ 的数据，保证部落之间的地理关系是一条链，且 $i$ 与 $i + 1$ 之间有一条道路。\n\n对于另 $30\\%$ 的数据，$n, m\\leq 10^5$。\n\n对于 $100\\%$ 的数据，$1\\leq n, m\\leq 3\\times10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P3951", "type": "P", "difficulty": 3, "samples": [["3 7", "11\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["数学", "2017", "NOIP 提高组", "不定方程", "中国剩余定理 CRT", "构造"], "title": "[NOIP 2017 提高组] 小凯的疑惑", "background": "NOIP2017 提高组 D1T1", "description": "小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小凯想知道在无法准确支付的物品中，最贵的价值是多少金币？\n\n注意：输入数据保证存在小凯无法准确支付的商品。\n", "inputFormat": "两个正整数 $a$ 和 $b$，它们之间用一个空格隔开，表示小凯中金币的面值。\n", "outputFormat": "一个正整数 $N$，表示不找零的情况下，小凯用手中的金币不能准确支付的最贵的物品的价值。\n", "hint": "【输入输出样例 1 说明】\n\n小凯手中有面值为 $3$ 和 $7$ 的金币无数个，在不找零的前提下无法准确支付价值为 $1,2,4,5,8,11$ 的物品，其中最贵的物品价值为 $11$，比 $11$ 贵的物品都能买到，比如：\n\n$12 = 3 \\times 4 + 7 \\times 0$；\n\n$13 = 3 \\times 2 + 7 \\times 1$；\n\n$14 = 3 \\times 0 + 7 \\times 2$；\n\n$15 = 3 \\times 5 + 7 \\times 0 $。\n\n\n【数据范围与约定】\n\n对于 $30\\%$ 的数据： $1 \\le a,b \\le 50 $。\n\n对于 $60\\%$ 的数据： $1 \\le a,b \\le 10^4 $。\n\n对于$ 100\\%$ 的数据：$1 \\le a,b \\le 10^9 $。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2017 Senior] Xiaokai's Doubt", "background": "NOIP 2017 Senior D1T1.", "description": "Xiaokai has two coin denominations, both positive integers and coprime. He has infinitely many coins of each denomination. Without making change, using only these two denominations, there are some item prices he cannot pay exactly. Now Xiaokai wants to know: among the prices that cannot be paid exactly, what is the most expensive price?\n\nNote: The input guarantees that there exists an item that Xiaokai cannot pay exactly.", "inputFormat": "Two positive integers $a$ and $b$, separated by a single space, representing the denominations of Xiaokai's coins.", "outputFormat": "A single positive integer $N$, the most expensive item price that cannot be paid exactly without making change.", "hint": "[Explanation for Sample 1]\n\nXiaokai has infinitely many coins with denominations $3$ and $7$. Without making change, he cannot pay exactly for items priced $1, 2, 4, 5, 8, 11$. Among them, the most expensive price is $11$. Every price greater than $11$ can be paid, for example:\n\n$12 = 3 \\times 4 + 7 \\times 0$；\n\n$13 = 3 \\times 2 + 7 \\times 1$；\n\n$14 = 3 \\times 0 + 7 \\times 2$；\n\n$15 = 3 \\times 5 + 7 \\times 0$。\n\nConstraints\n\nFor $30\\%$ of the testdata: $1 \\le a,b \\le 50$。\n\nFor $60\\%$ of the testdata: $1 \\le a,b \\le 10^4$。\n\nFor $100\\%$ of the testdata: $1 \\le a,b \\le 10^9$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2017 提高组] 小凯的疑惑", "background": "NOIP2017 提高组 D1T1", "description": "小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小凯想知道在无法准确支付的物品中，最贵的价值是多少金币？\n\n注意：输入数据保证存在小凯无法准确支付的商品。\n", "inputFormat": "两个正整数 $a$ 和 $b$，它们之间用一个空格隔开，表示小凯中金币的面值。\n", "outputFormat": "一个正整数 $N$，表示不找零的情况下，小凯用手中的金币不能准确支付的最贵的物品的价值。\n", "hint": "【输入输出样例 1 说明】\n\n小凯手中有面值为 $3$ 和 $7$ 的金币无数个，在不找零的前提下无法准确支付价值为 $1,2,4,5,8,11$ 的物品，其中最贵的物品价值为 $11$，比 $11$ 贵的物品都能买到，比如：\n\n$12 = 3 \\times 4 + 7 \\times 0$；\n\n$13 = 3 \\times 2 + 7 \\times 1$；\n\n$14 = 3 \\times 0 + 7 \\times 2$；\n\n$15 = 3 \\times 5 + 7 \\times 0 $。\n\n\n【数据范围与约定】\n\n对于 $30\\%$ 的数据： $1 \\le a,b \\le 50 $。\n\n对于 $60\\%$ 的数据： $1 \\le a,b \\le 10^4 $。\n\n对于$ 100\\%$ 的数据：$1 \\le a,b \\le 10^9 $。\n", "locale": "zh-CN"}}}
{"pid": "P3952", "type": "P", "difficulty": 4, "samples": [["8\n2 O(1)\nF i 1 1\nE\n2 O(n^1)\nF x 1 n\nE\n1 O(1)\nF x 1 n\n4 O(n^2)\nF x 5 n\nF y 10 n\nE\nE\n4 O(n^2)\nF x 9 n\nE\nF y 2 n\nE\n4 O(n^1)\nF x 9 n\nF y n 4\nE\nE\n4 O(1)\nF y n 4\nF x 9 n\nE\nE\n4 O(n^2)\nF x 1 n\nF x 1 10\nE\nE", "Yes\nYes\nERR\nYes\nNo\nYes\nYes\nERR"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "2017", "NOIP 提高组", "栈"], "title": "[NOIP 2017 提高组] 时间复杂度", "background": "NOIP2017 提高组 D1T2", "description": "小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序，于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。\n\nA++ 语言的循环结构如下：\n\n \n```cpp\nF i x y\n    循环体\nE\n```\n \n \n其中`F i x y`表示新建变量 $i$（变量 $i$ 不可与未被销毁的变量重名）并初始化为 $x$， 然后判断 $i$ 和 $y$ 的大小关系，若 $i$ 小于等于 $y$ 则进入循环，否则不进入。每次循环结束后 $i$ 都会被修改成 $i+1$，一旦 $i$ 大于 $y$ 终止循环。\n\n$x$ 和 $y$ 可以是正整数（$x$ 和 $y$ 的大小关系不定）或变量 $n$。$n$ 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 $100$。\n\n`E` 表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。\n\n注：本题中为了书写方便，在描述复杂度时，使用大写英文字母 $\\operatorname O$ 表示通常意义下 $\\Theta$ 的概念。", "inputFormat": "输入文件第一行一个正整数 $t$，表示有 $t$（$t \\le 10$）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 `F i x y` 和 `E` 即可计算时间复杂度。注意：循环结构允许嵌套。\n\n接下来每个程序的第一行包含一个正整数 $L$ 和一个字符串，$L$ 代表程序行数，字符串表示这个程序的复杂度，`O(1)` 表示常数复杂度，`O(n^w)` 表示复杂度为 $n^w$，其中 $w$ 是一个小于 $100$ 的正整数，输入保证复杂度只有 `O(1)` 和 `O(n^w)` 两种类型。\n\n接下来 $L$ 行代表程序中循环结构中的`F i x y`或者 `E`。 程序行若以`F`开头，表示进入一个循环，之后有空格分离的三个字符（串）`i x y`， 其中 $i$ 是一个小写字母（保证不为 $n$），表示新建的变量名，$x$ 和 $y$ 可能是正整数或 $n$ ，已知若为正整数则一定小于 $100$。\n\n程序行若以`E`开头，则表示循环体结束。", "outputFormat": "输出文件共 $t$ 行，对应输入的 $t$ 个程序，每行输出 `Yes` 或 `No` 或者 `ERR`，若程序实际复杂度与输入给出的复杂度一致则输出 `Yes`，不一致则输出 `No`，若程序有语法错误（其中语法错误只有: ① `F` 和 `E` 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出 `ERR`。\n\n注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 `ERR`。", "hint": "【输入输出样例解释 $1$】\n\n第一个程序 $i$ 从 $1$ 到 $1$ 是常数复杂度。\n\n第二个程序 $x$ 从 $1$ 到 $n$ 是 $n$ 的一次方的复杂度。\n\n第三个程序有一个 `F` 开启循环却没有 `E` 结束，语法错误。\n\n第四个程序二重循环，$n$ 的平方的复杂度。\n\n第五个程序两个一重循环，$n$ 的一次方的复杂度。\n\n第六个程序第一重循环正常，但第二重循环开始即终止（因为 $n$ 远大于 $100$，$100$ 大于 $4$）。\n\n第七个程序第一重循环无法进入，故为常数复杂度。\n\n第八个程序第二重循环中的变量 $x$ 与第一重循环中的变量重复，出现语法错误②，输出 `ERR`。\n\n【数据规模与约定】\n\n对于 $30\\%$ 的数据：不存在语法错误，数据保证小明给出的每个程序的前 $L/2$ 行一定为以 `F` 开头的语句，第 $L/2+1$ 行至第 $L$ 行一定为以 `E` 开头的语句，$L  \\le 10$，若 $x$、$y$ 均为整数，$x$ 一定小于 $y$，且只有 $y$ 有可能为 $n$。\n\n对于 $50\\%$ 的数据：不存在语法错误，$L  \\le 100$，且若 $x$、$y$ 均为整数，$x$ 一定小于 $y$，且只有 $y$ 有可能为 $n$。\n\n对于 $70\\%$ 的数据：不存在语法错误，$L  \\le 100$。\n\n对于 $100\\%$ 的数据：$L  \\le 100$。\n\n\n---\n如果需要 Hack 请私信 @zhouyonglong 或发讨论，提供数据和能 Hack 掉的本题的AC记录。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2017 Senior] Time Complexity", "background": "NOIP 2017 Senior D1T2.", "description": "Xiao Ming is learning a new programming language, A++. After just learning loop statements, he excitedly wrote many programs and gave the time complexity he calculated for each. His programming teacher does not want to check them one by one, so here is your chance! Please write a program to judge whether the time complexity Xiao Ming gave for each program is correct.\n\nThe loop structure in A++ is as follows:\n\n```cpp\nF i x y\n    loop body\nE\n```\n\nHere, `F i x y` means creating a new variable $i$ (the variable $i$ must not have the same name as any existing variable that has not been destroyed) and initializing it to $x$. Then compare $i$ with $y$: if $i$ is less than or equal to $y$, enter the loop; otherwise, do not enter. After each loop, $i$ is updated to $i+1$. Once $i$ becomes greater than $y$, the loop terminates.\n\n$x$ and $y$ can be positive integers (the relation between $x$ and $y$ is not fixed) or the variable $n$. The variable $n$ represents the problem size; in time complexity analysis, $n$ must be kept as a variable and not treated as a constant. It is much larger than $100$.\n\n`E` indicates the end of the loop body. When the loop body ends, the variables created by this loop are destroyed.\n\nNote: For convenience, this problem uses the uppercase letter $\\operatorname O$ to denote the concept of $\\Theta$ in the usual sense when describing complexity.", "inputFormat": "The first line of input contains a positive integer $t$, meaning there are $t$ ($t \\le 10$) programs whose time complexity needs to be checked. For each program, we only need to extract the `F i x y` and `E` lines to compute the time complexity. Note: Loop structures can be nested.\n\nFor each program, the first line contains a positive integer $L$ and a string. $L$ is the number of lines in the program, and the string denotes the program’s claimed complexity. `O(1)` means constant complexity, and `O(n^w)` means the complexity is $n^w$, where $w$ is a positive integer less than $100$. The input guarantees that the claimed complexity is only one of `O(1)` or `O(n^w)`.\n\nThe next $L$ lines are either `F i x y` or `E`, representing the loop structure in the program. If a line starts with `F`, it indicates entering a loop, followed by three space-separated tokens `i x y`, where $i$ is a lowercase letter (guaranteed not to be $n$) representing the newly created variable name, and $x$ and $y$ may be positive integers or $n$. If they are positive integers, they are guaranteed to be less than $100$.\n\nIf a line starts with `E`, it indicates the end of a loop body.", "outputFormat": "Output exactly $t$ lines, each corresponding to one program in the input. For each program, output `Yes`, `No`, or `ERR`. Output `Yes` if the actual complexity matches the given complexity; output `No` if it does not match; output `ERR` if there is a syntax error. The only syntax errors are: ① mismatched `F` and `E`; ② creating a variable with the same name as an already existing but not yet destroyed variable.\n\nNote: Even if a syntax error occurs inside a loop body that will never execute, it is still a compile-time error, and you must output `ERR`.", "hint": "[Explanation of Sample 1]\n\n- The first program: $i$ goes from $1$ to $1$, which is constant complexity.\n- The second program: $x$ goes from $1$ to $n$, which is linear in $n$.\n- The third program: there is an `F` that starts a loop without a matching `E`, which is a syntax error.\n- The fourth program: two nested loops, so the complexity is $n^2$.\n- The fifth program: two separate single loops, so the complexity is linear in $n$.\n- The sixth program: the first loop is normal, but the second loop terminates immediately (because $n$ is much larger than $100$, and $100$ is larger than $4$).\n- The seventh program: the first loop cannot be entered, so it is constant complexity.\n- The eighth program: the variable $x$ in the second nested loop duplicates the variable from the first loop, which triggers syntax error ②, so output `ERR`.\n\n[Constraints and Notes]\n\n- For $30\\%$ of the testdata: no syntax errors. It is guaranteed that the first $L/2$ lines are `F`-starting statements, and lines $L/2+1$ to $L$ are `E`-starting statements. $L \\le 10$. If $x$ and $y$ are both integers, then $x < y$, and only $y$ may be $n$.\n- For $50\\%$ of the testdata: no syntax errors. $L \\le 100$. If $x$ and $y$ are both integers, then $x < y$, and only $y$ may be $n$.\n- For $70\\%$ of the testdata: no syntax errors. $L \\le 100$.\n- For $100\\%$ of the testdata: $L \\le 100$.\n\n---\nIf you need to hack, please private message @zhouyonglong or start a discussion, and provide testdata and an AC submission that this problem can be hacked by.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2017 提高组] 时间复杂度", "background": "NOIP2017 提高组 D1T2", "description": "小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序，于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。\n\nA++ 语言的循环结构如下：\n\n \n```cpp\nF i x y\n    循环体\nE\n```\n \n \n其中`F i x y`表示新建变量 $i$（变量 $i$ 不可与未被销毁的变量重名）并初始化为 $x$， 然后判断 $i$ 和 $y$ 的大小关系，若 $i$ 小于等于 $y$ 则进入循环，否则不进入。每次循环结束后 $i$ 都会被修改成 $i+1$，一旦 $i$ 大于 $y$ 终止循环。\n\n$x$ 和 $y$ 可以是正整数（$x$ 和 $y$ 的大小关系不定）或变量 $n$。$n$ 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 $100$。\n\n`E` 表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。\n\n注：本题中为了书写方便，在描述复杂度时，使用大写英文字母 $\\operatorname O$ 表示通常意义下 $\\Theta$ 的概念。", "inputFormat": "输入文件第一行一个正整数 $t$，表示有 $t$（$t \\le 10$）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 `F i x y` 和 `E` 即可计算时间复杂度。注意：循环结构允许嵌套。\n\n接下来每个程序的第一行包含一个正整数 $L$ 和一个字符串，$L$ 代表程序行数，字符串表示这个程序的复杂度，`O(1)` 表示常数复杂度，`O(n^w)` 表示复杂度为 $n^w$，其中 $w$ 是一个小于 $100$ 的正整数，输入保证复杂度只有 `O(1)` 和 `O(n^w)` 两种类型。\n\n接下来 $L$ 行代表程序中循环结构中的`F i x y`或者 `E`。 程序行若以`F`开头，表示进入一个循环，之后有空格分离的三个字符（串）`i x y`， 其中 $i$ 是一个小写字母（保证不为 $n$），表示新建的变量名，$x$ 和 $y$ 可能是正整数或 $n$ ，已知若为正整数则一定小于 $100$。\n\n程序行若以`E`开头，则表示循环体结束。", "outputFormat": "输出文件共 $t$ 行，对应输入的 $t$ 个程序，每行输出 `Yes` 或 `No` 或者 `ERR`，若程序实际复杂度与输入给出的复杂度一致则输出 `Yes`，不一致则输出 `No`，若程序有语法错误（其中语法错误只有: ① `F` 和 `E` 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出 `ERR`。\n\n注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 `ERR`。", "hint": "【输入输出样例解释 $1$】\n\n第一个程序 $i$ 从 $1$ 到 $1$ 是常数复杂度。\n\n第二个程序 $x$ 从 $1$ 到 $n$ 是 $n$ 的一次方的复杂度。\n\n第三个程序有一个 `F` 开启循环却没有 `E` 结束，语法错误。\n\n第四个程序二重循环，$n$ 的平方的复杂度。\n\n第五个程序两个一重循环，$n$ 的一次方的复杂度。\n\n第六个程序第一重循环正常，但第二重循环开始即终止（因为 $n$ 远大于 $100$，$100$ 大于 $4$）。\n\n第七个程序第一重循环无法进入，故为常数复杂度。\n\n第八个程序第二重循环中的变量 $x$ 与第一重循环中的变量重复，出现语法错误②，输出 `ERR`。\n\n【数据规模与约定】\n\n对于 $30\\%$ 的数据：不存在语法错误，数据保证小明给出的每个程序的前 $L/2$ 行一定为以 `F` 开头的语句，第 $L/2+1$ 行至第 $L$ 行一定为以 `E` 开头的语句，$L  \\le 10$，若 $x$、$y$ 均为整数，$x$ 一定小于 $y$，且只有 $y$ 有可能为 $n$。\n\n对于 $50\\%$ 的数据：不存在语法错误，$L  \\le 100$，且若 $x$、$y$ 均为整数，$x$ 一定小于 $y$，且只有 $y$ 有可能为 $n$。\n\n对于 $70\\%$ 的数据：不存在语法错误，$L  \\le 100$。\n\n对于 $100\\%$ 的数据：$L  \\le 100$。\n\n\n---\n如果需要 Hack 请私信 @zhouyonglong 或发讨论，提供数据和能 Hack 掉的本题的AC记录。", "locale": "zh-CN"}}}
{"pid": "P3953", "type": "P", "difficulty": 5, "samples": [["2\n5 7 2 10\n1 2 1\n2 4 0\n4 5 2\n2 3 2\n3 4 1\n3 5 2\n1 5 3\n2 2 0 10\n1 2 0\n2 1 0", "3\n-1\n\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["搜索", "2017", "NOIP 提高组", "记忆化搜索", "最短路"], "title": "[NOIP 2017 提高组] 逛公园", "background": "NOIP2017 D1T3", "description": "策策同学特别喜欢逛公园。公园可以看成一张 $N$ 个点 $M$ 条边构成的有向图，且没有 自环和重边。其中 $1$ 号点是公园的入口，$N$ 号点是公园的出口，每条边有一个非负权值， 代表策策经过这条边所要花的时间。\n\n策策每天都会去逛公园，他总是从 $1$ 号点进去，从 $N$ 号点出来。\n\n策策喜欢新鲜的事物，他不希望有两天逛公园的路线完全一样，同时策策还是一个特别热爱学习的好孩子，他不希望每天在逛公园这件事上花费太多的时间。如果 $1$ 号点 到 $N$ 号点的最短路长为 $d$，那么策策只会喜欢长度不超过 $d + K$ 的路线。\n\n策策同学想知道总共有多少条满足条件的路线，你能帮帮他吗？\n\n为避免输出过大，答案对 $P$ 取模。\n\n如果有无穷多条合法的路线，请输出 $-1$。", "inputFormat": "第一行包含一个整数 $T$, 代表数据组数。\n\n接下来 $T$ 组数据，对于每组数据： 第一行包含四个整数 $N,M,K,P$，每两个整数之间用一个空格隔开。\n\n\n接下来 $M$ 行，每行三个整数 $a_i,b_i,c_i$，代表编号为 $a_i,b_i$ 的点之间有一条权值为 $c_i$ 的有向边，每两个整数之间用一个空格隔开。", "outputFormat": "输出文件包含 $T$ 行，每行一个整数代表答案。", "hint": "【样例解释1】\n\n\n对于第一组数据，最短路为 $3$。 $1\\to 5, 1\\to 2\\to 4\\to 5, 1\\to 2\\to 3\\to 5$ 为 $3$ 条合法路径。\n\n\n【测试数据与约定】\n\n对于不同的测试点，我们约定各种参数的规模不会超过如下\n\n::cute-table{tuack}\n\n|测试点编号　　|$T$　　　|$N$　　　|$M$　　　|$K$　　　|是否有 $0$ 边|\n:-:|:-:|:-:|:-:|:-:|:-:\n$1$|$5$|$5$|$10$|$0$|否\n$2$|$5$|$10^3$|$2\\times 10^3$|$0$|否\n$3$|$5$|$10^3$|$2\\times 10^3$|$50$|否\n$4$|$5$|$10^3$|$2\\times 10^3$|$50$|否\n$5$|$5$|$10^3$|$2\\times 10^3$|$50$|否\n$6$|$5$|$10^3$|$2\\times 10^3$|$50$|是\n$7$|$5$|$10^5$|$2\\times 10^5$|$0$|否\n$8$|$3$|$10^5$|$2\\times 10^5$|$50$|否\n$9$|$3$|$10^5$|$2\\times 10^5$|$50$|是\n$10$|$3$|$10^5$|$2\\times 10^5$|$50$|是\n\n\n对于 $100\\%$ 的数据，$1 \\le P \\le 10^9$，$1 \\le a_i,b_i \\le N$，$0 \\le c_i \\le 1000$。\n\n数据保证：至少存在一条合法的路线。\n\n---\n\n- 2019.8.30 增加了一组 hack 数据 by @skicean\n- 2022.7.21 增加了一组 hack 数据 by @djwj233", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2017 Senior] Visiting the Park", "background": "NOIP 2017 D1T3.", "description": "Cece loves visiting the park. The park can be regarded as a directed graph with $N$ vertices and $M$ edges, without self-loops and without multiple edges. Vertex $1$ is the entrance and vertex $N$ is the exit. Each edge has a non-negative weight representing the time Cece spends to traverse that edge.\n\nCece visits the park every day. He always enters from vertex $1$ and exits at vertex $N$.\n\nCece likes new things. He does not want to take exactly the same route on two different days. He also does not want to spend too much time. If the shortest path length from vertex $1$ to vertex $N$ is $d$, then Cece only likes routes with length no more than $d + K$.\n\nCece wants to know how many routes satisfy these conditions. Can you help him?\n\nTo avoid large output, report the answer modulo $P$.\n\nIf there are infinitely many valid routes, output $-1$.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nThen follow $T$ test cases. For each test case:\n- The first line contains four integers $N, M, K, P$, separated by a single space.\n- The next $M$ lines each contain three integers $a_i, b_i, c_i$, indicating there is a directed edge from vertex $a_i$ to vertex $b_i$ with weight $c_i$, with integers separated by a single space.", "outputFormat": "The output contains $T$ lines, each with one integer representing the answer.", "hint": "[Sample Explanation 1]\n\nFor the first test case, the shortest distance is $3$. $1\\to 5, 1\\to 2\\to 4\\to 5, 1\\to 2\\to 3\\to 5$ are $3$ valid paths.\n\n[Testdata and Conventions]\n\nFor different test points, the scales of various parameters do not exceed the following.\n\n::cute-table{tuack}\n\n| Test point ID | $T$ | $N$ | $M$ | $K$ | Any $0$-weight edges |\n:-:|:-:|:-:|:-:|:-:|:-:\n$1$ | $5$ | $5$ | $10$ | $0$ | No\n$2$ | $5$ | $10^3$ | $2\\times 10^3$ | $0$ | No\n$3$ | $5$ | $10^3$ | $2\\times 10^3$ | $50$ | No\n$4$ | $5$ | $10^3$ | $2\\times 10^3$ | $50$ | No\n$5$ | $5$ | $10^3$ | $2\\times 10^3$ | $50$ | No\n$6$ | $5$ | $10^3$ | $2\\times 10^3$ | $50$ | Yes\n$7$ | $5$ | $10^5$ | $2\\times 10^5$ | $0$ | No\n$8$ | $3$ | $10^5$ | $2\\times 10^5$ | $50$ | No\n$9$ | $3$ | $10^5$ | $2\\times 10^5$ | $50$ | Yes\n$10$ | $3$ | $10^5$ | $2\\times 10^5$ | $50$ | Yes\n\nFor $100\\%$ of the testdata, $1 \\le P \\le 10^9$, $1 \\le a_i, b_i \\le N$, $0 \\le c_i \\le 1000$.\n\nThe testdata guarantees that at least one valid route exists.\n\n---\n\n- 2019.8.30 Added a set of hack testdata by @skicean.\n- 2022.7.21 Added a set of hack testdata by @djwj233.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2017 提高组] 逛公园", "background": "NOIP2017 D1T3", "description": "策策同学特别喜欢逛公园。公园可以看成一张 $N$ 个点 $M$ 条边构成的有向图，且没有 自环和重边。其中 $1$ 号点是公园的入口，$N$ 号点是公园的出口，每条边有一个非负权值， 代表策策经过这条边所要花的时间。\n\n策策每天都会去逛公园，他总是从 $1$ 号点进去，从 $N$ 号点出来。\n\n策策喜欢新鲜的事物，他不希望有两天逛公园的路线完全一样，同时策策还是一个特别热爱学习的好孩子，他不希望每天在逛公园这件事上花费太多的时间。如果 $1$ 号点 到 $N$ 号点的最短路长为 $d$，那么策策只会喜欢长度不超过 $d + K$ 的路线。\n\n策策同学想知道总共有多少条满足条件的路线，你能帮帮他吗？\n\n为避免输出过大，答案对 $P$ 取模。\n\n如果有无穷多条合法的路线，请输出 $-1$。", "inputFormat": "第一行包含一个整数 $T$, 代表数据组数。\n\n接下来 $T$ 组数据，对于每组数据： 第一行包含四个整数 $N,M,K,P$，每两个整数之间用一个空格隔开。\n\n\n接下来 $M$ 行，每行三个整数 $a_i,b_i,c_i$，代表编号为 $a_i,b_i$ 的点之间有一条权值为 $c_i$ 的有向边，每两个整数之间用一个空格隔开。", "outputFormat": "输出文件包含 $T$ 行，每行一个整数代表答案。", "hint": "【样例解释1】\n\n\n对于第一组数据，最短路为 $3$。 $1\\to 5, 1\\to 2\\to 4\\to 5, 1\\to 2\\to 3\\to 5$ 为 $3$ 条合法路径。\n\n\n【测试数据与约定】\n\n对于不同的测试点，我们约定各种参数的规模不会超过如下\n\n::cute-table{tuack}\n\n|测试点编号　　|$T$　　　|$N$　　　|$M$　　　|$K$　　　|是否有 $0$ 边|\n:-:|:-:|:-:|:-:|:-:|:-:\n$1$|$5$|$5$|$10$|$0$|否\n$2$|$5$|$10^3$|$2\\times 10^3$|$0$|否\n$3$|$5$|$10^3$|$2\\times 10^3$|$50$|否\n$4$|$5$|$10^3$|$2\\times 10^3$|$50$|否\n$5$|$5$|$10^3$|$2\\times 10^3$|$50$|否\n$6$|$5$|$10^3$|$2\\times 10^3$|$50$|是\n$7$|$5$|$10^5$|$2\\times 10^5$|$0$|否\n$8$|$3$|$10^5$|$2\\times 10^5$|$50$|否\n$9$|$3$|$10^5$|$2\\times 10^5$|$50$|是\n$10$|$3$|$10^5$|$2\\times 10^5$|$50$|是\n\n\n对于 $100\\%$ 的数据，$1 \\le P \\le 10^9$，$1 \\le a_i,b_i \\le N$，$0 \\le c_i \\le 1000$。\n\n数据保证：至少存在一条合法的路线。\n\n---\n\n- 2019.8.30 增加了一组 hack 数据 by @skicean\n- 2022.7.21 增加了一组 hack 数据 by @djwj233", "locale": "zh-CN"}}}
{"pid": "P3954", "type": "P", "difficulty": 1, "samples": [["100 100 80 ", "90"], ["60 90 80 ", "79"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "NOIP 普及组", "顺序结构"], "title": "[NOIP 2017 普及组] 成绩", "background": "NOIP2017 普及组 T1", "description": "牛牛最近学习了 C++ 入门课程，这门课程的总成绩计算方法是：\n\n$$\n\\text{总成绩}=\\text{作业成绩}\\times 20\\%+\\text{小测成绩}×30\\%+\\text{期末考试成绩} \\times 50\\%\n$$\n\n牛牛想知道，这门课程自己最终能得到多少分。\n", "inputFormat": "三个非负整数 $A,B,C$，分别表示牛牛的作业成绩、小测成绩和期末考试成绩。相邻两个数之间用一个空格隔开，三项成绩满分都是 $100$ 分。\n", "outputFormat": "一个整数，即牛牛这门课程的总成绩，满分也是 $100$ 分。\n", "hint": "**样例 1 说明**\n\n牛牛的作业成绩是 $100$ 分，小测成绩是 $100$ 分，期末考试成绩是 $80$ 分，总成绩是 $100 \\times 20\\%+100 \\times 30\\%+80 \\times 50\\%=20+30+40=90$。\n\n**样例 2 说明**\n\n牛牛的作业成绩是 $60$ 分，小测成绩是 $90$ 分，期末考试成绩是 $80$ 分，总成绩是 $60 \\times 20\\%+90 \\times 30\\%+80 \\times 50\\%=12+27+40=79$。\n\n**数据说明**\n\n对于 $30\\%$ 的数据，$A=B=0$。\n\n对于另外 $30\\%$ 的数据，$A=B=100$。\n\n对于 $100\\%$ 的数据，$0≤A,B,C≤100$ 且 $A,B,C$ 都是 $10$ 的整数倍。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2017 Junior] Score", "background": "NOIP 2017 Junior T1.", "description": "Niuniu recently studied an introductory C++ course. The total score for this course is calculated as:\n\n$$\n\\text{总成绩}=\\text{作业成绩}\\times 20\\%+\\text{小测成绩}×30\\%+\\text{期末考试成绩} \\times 50\\%\n$$\n\nNiuniu wants to know the final score they can get in this course.", "inputFormat": "Three non-negative integers $A, B, C$, representing Niuniu’s homework score, quiz score, and final exam score, respectively. Adjacent numbers are separated by a single space. Each of the three scores is out of $100$ points.", "outputFormat": "A single integer: Niuniu’s total score for the course, also out of $100$ points.", "hint": "**Sample 1 Explanation**\n\nNiuniu’s homework score is $100$ points, quiz score is $100$ points, and final exam score is $80$ points. The total score is $100 \\times 20\\%+100 \\times 30\\%+80 \\times 50\\%=20+30+40=90$.\n\n**Sample 2 Explanation**\n\nNiuniu’s homework score is $60$ points, quiz score is $90$ points, and final exam score is $80$ points. The total score is $60 \\times 20\\%+90 \\times 30\\%+80 \\times 50\\%=12+27+40=79$.\n\n**Constraints**\n\n- For $30\\%$ of the testdata, $A=B=0$.\n- For another $30\\%$ of the testdata, $A=B=100$.\n- For $100\\%$ of the testdata, $0≤A,B,C≤100$ and $A,B,C$ are all multiples of $10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2017 普及组] 成绩", "background": "NOIP2017 普及组 T1", "description": "牛牛最近学习了 C++ 入门课程，这门课程的总成绩计算方法是：\n\n$$\n\\text{总成绩}=\\text{作业成绩}\\times 20\\%+\\text{小测成绩}×30\\%+\\text{期末考试成绩} \\times 50\\%\n$$\n\n牛牛想知道，这门课程自己最终能得到多少分。\n", "inputFormat": "三个非负整数 $A,B,C$，分别表示牛牛的作业成绩、小测成绩和期末考试成绩。相邻两个数之间用一个空格隔开，三项成绩满分都是 $100$ 分。\n", "outputFormat": "一个整数，即牛牛这门课程的总成绩，满分也是 $100$ 分。\n", "hint": "**样例 1 说明**\n\n牛牛的作业成绩是 $100$ 分，小测成绩是 $100$ 分，期末考试成绩是 $80$ 分，总成绩是 $100 \\times 20\\%+100 \\times 30\\%+80 \\times 50\\%=20+30+40=90$。\n\n**样例 2 说明**\n\n牛牛的作业成绩是 $60$ 分，小测成绩是 $90$ 分，期末考试成绩是 $80$ 分，总成绩是 $60 \\times 20\\%+90 \\times 30\\%+80 \\times 50\\%=12+27+40=79$。\n\n**数据说明**\n\n对于 $30\\%$ 的数据，$A=B=0$。\n\n对于另外 $30\\%$ 的数据，$A=B=100$。\n\n对于 $100\\%$ 的数据，$0≤A,B,C≤100$ 且 $A,B,C$ 都是 $10$ 的整数倍。", "locale": "zh-CN"}}}
{"pid": "P3955", "type": "P", "difficulty": 2, "samples": [["5 5 \n2123 \n1123 \n23 \n24 \n24 \n2 23 \n3 123 \n3 124 \n2 12 \n2 12", "23 \n1123 \n-1 \n-1 \n-1 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["字符串", "2017", "NOIP 普及组", "排序"], "title": "[NOIP 2017 普及组] 图书管理员", "background": "NOIP2017 普及组 T2", "description": "图书馆中每本书都有一个图书编码，可以用于快速检索图书，这个图书编码是一个正整数。每位借书的读者手中有一个需求码，这个需求码也是一个正整数。如果一本书的图书编码恰好以读者的需求码结尾，那么这本书就是这位读者所需要的。小 D 刚刚当上图书馆的管理员，她知道图书馆里所有书的图书编码，她请你帮她写一个程序，对于每一位读者，求出他所需要的书中图书编码最小的那本书，如果没有他需要的书，请输出 `-1`。", "inputFormat": "第一行，包含两个正整数 $n,q$，以一个空格分开，分别代表图书馆里书的数量和读者的数量。\n\n接下来的 $n$ 行，每行包含一个正整数，代表图书馆里某本书的图书编码。\n\n接下来的 $q$ 行，每行包含两个正整数，以一个空格分开，第一个正整数代表图书馆里读者的需求码的长度，第二个正整数代表读者的需求码。", "outputFormat": "$q$ 行，每行包含一个整数，如果存在第 $i$ 个读者所需要的书，则在第 $i$ 行输出第 $i$ 个读者所需要的书中图书编码最小的那本书的图书编码，否则输出 $-1$。", "hint": "**数据规模与约定**\n\n对于 $20\\%$ 的数据，$1 \\le n \\le 2$。\n\n另有 $20\\%$ 的数据，$q = 1$。\n\n另有 $20\\%$ 的数据，所有读者的需求码的长度均为 $1$。\n\n另有 $20\\%$ 的数据，所有的图书编码按从小到大的顺序给出。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 1000,1 \\le q \\le 1000$，所有的图书编码和需求码均不超过 $10^7$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2017 Junior] Librarian", "background": "NOIP 2017 Junior T2.", "description": "Each book in the library has a book code, which is a positive integer, used for quick lookup. Each reader has a request code, also a positive integer. If a book’s code ends with a reader’s request code, then that book is what the reader needs. Xiao D has just become the librarian. She knows the codes of all books in the library and asks you to write a program to, for each reader, find the book with the smallest code among the books they need. If there is no book they need, please output `-1`.", "inputFormat": "The first line contains two positive integers $n, q$, separated by a space, representing the number of books in the library and the number of readers, respectively.\n\nThe next $n$ lines each contain a positive integer, representing the code of a book in the library.\n\nThe next $q$ lines each contain two positive integers separated by a space. The first integer is the length of the reader’s request code, and the second integer is the reader’s request code.", "outputFormat": "Output $q$ lines. For the $i$-th line, if there exists a book needed by the $i$-th reader, output the smallest book code among those books; otherwise, output -1.", "hint": "Constraints and Notes\n\nFor $20\\%$ of the testdata, $1 \\le n \\le 2$.\n\nFor another $20\\%$ of the testdata, $q = 1$.\n\nFor another $20\\%$ of the testdata, the lengths of all readers’ request codes are $1$.\n\nFor another $20\\%$ of the testdata, all book codes are given in ascending order.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 1000, 1 \\le q \\le 1000$, and all book codes and request codes do not exceed $10^7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2017 普及组] 图书管理员", "background": "NOIP2017 普及组 T2", "description": "图书馆中每本书都有一个图书编码，可以用于快速检索图书，这个图书编码是一个正整数。每位借书的读者手中有一个需求码，这个需求码也是一个正整数。如果一本书的图书编码恰好以读者的需求码结尾，那么这本书就是这位读者所需要的。小 D 刚刚当上图书馆的管理员，她知道图书馆里所有书的图书编码，她请你帮她写一个程序，对于每一位读者，求出他所需要的书中图书编码最小的那本书，如果没有他需要的书，请输出 `-1`。", "inputFormat": "第一行，包含两个正整数 $n,q$，以一个空格分开，分别代表图书馆里书的数量和读者的数量。\n\n接下来的 $n$ 行，每行包含一个正整数，代表图书馆里某本书的图书编码。\n\n接下来的 $q$ 行，每行包含两个正整数，以一个空格分开，第一个正整数代表图书馆里读者的需求码的长度，第二个正整数代表读者的需求码。", "outputFormat": "$q$ 行，每行包含一个整数，如果存在第 $i$ 个读者所需要的书，则在第 $i$ 行输出第 $i$ 个读者所需要的书中图书编码最小的那本书的图书编码，否则输出 $-1$。", "hint": "**数据规模与约定**\n\n对于 $20\\%$ 的数据，$1 \\le n \\le 2$。\n\n另有 $20\\%$ 的数据，$q = 1$。\n\n另有 $20\\%$ 的数据，所有读者的需求码的长度均为 $1$。\n\n另有 $20\\%$ 的数据，所有的图书编码按从小到大的顺序给出。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 1000,1 \\le q \\le 1000$，所有的图书编码和需求码均不超过 $10^7$。", "locale": "zh-CN"}}}
{"pid": "P3956", "type": "P", "difficulty": 4, "samples": [["5 7\n1 1 0\n1 2 0\n2 2 1\n3 3 1\n3 4 0\n4 4 1\n5 5 0", "8"], ["5 5\n1 1 0\n1 2 0\n2 2 1\n3 3 1\n5 5 0", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["搜索", "2017", "NOIP 普及组", "广度优先搜索 BFS", "深度优先搜索 DFS", "剪枝", "最短路"], "title": "[NOIP 2017 普及组] 棋盘", "background": "NOIP2017 普及组 T3", "description": "有一个 $m \\times m$ 的棋盘，棋盘上每一个格子可能是红色、黄色或没有任何颜色的。你现在要从棋盘的最左上角走到棋盘的最右下角。\n\n任何一个时刻，你所站在的位置必须是有颜色的（不能是无色的）， 你只能向上、下、左、右四个方向前进。当你从一个格子走向另一个格子时，如果两个格子的颜色相同，那你不需要花费金币；如果不同，则你需要花费 $1 $ 个金币。\n\n另外， 你可以花费 $2$ 个金币施展魔法让下一个无色格子暂时变为你指定的颜色。但这个魔法不能连续使用， 而且这个魔法的持续时间很短，也就是说，如果你使用了这个魔法，走到了这个暂时有颜色的格子上，你就不能继续使用魔法； 只有当你离开这个位置，走到一个本来就有颜色的格子上的时候，你才能继续使用这个魔法，而当你离开了这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢复为无色。\n\n现在你要从棋盘的最左上角，走到棋盘的最右下角，求花费的最少金币是多少？", "inputFormat": "第一行包含两个正整数 $ m, n$，以一个空格分开，分别代表棋盘的大小，棋盘上有颜色的格子的数量。\n\n接下来的 $ n $ 行，每行三个正整数 $ x, y, c$， 分别表示坐标为 $(x,y)$ 的格子有颜色 $ c$。\n\n其中 $ c=1$ 代表黄色，$ c=0$ 代表红色。 相邻两个数之间用一个空格隔开。 棋盘左上角的坐标为 $(1, 1)$，右下角的坐标为 $( m, m)$。\n\n棋盘上其余的格子都是无色。保证棋盘的左上角，也就是 $(1, 1)$ 一定是有颜色的。", "outputFormat": "一个整数，表示花费的金币的最小值，如果无法到达，输出 `-1`。", "hint": "**样例 1 说明**\n\n棋盘的颜色如下表格所示，其中空白的部分表示无色。\n\n| $\\color{red}\\text{红}$ | $\\color{red}\\text{红}$ |  |  |  |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n|  | $\\color{yellow}\\text{黄}$ |  |  |  |\n|  |  | $\\color{yellow}\\text{黄}$ | $\\color{red}\\text{红}$ |  |\n|  |  |  | $\\color{yellow}\\text{黄}$ |  |\n|  |  |  |  | $\\color{red}\\text{红}$ |\n\n\n从 $(1,1)$ 开始，走到 $(1,2)$ 不花费金币。\n\n从 $(1,2)$ 向下走到 $(2,2)$ 花费 $1$ 枚金币。\n\n从 $(2,2)$ 施展魔法，将 $(2,3)$ 变为黄色，花费 $2$ 枚金币。\n\n从 $(2,2)$ 走到 $(2,3)$ 不花费金币。\n\n从 $(2,3)$ 走到 $(3,3)$ 不花费金币。\n\n从 $(3,3)$ 走到 $(3,4)$ 花费 $1$ 枚金币。\n\n从 $(3,4)$ 走到 $(4,4)$ 花费 $1$ 枚金币。\n\n从 $(4,4)$ 施展魔法，将 $(4,5)$ 变为黄色，花费 $ 2$ 枚金币。\n\n从 $(4,4)$ 走到 $(4,5)$ 不花费金币。\n\n从 $(4,5)$ 走到 $(5,5)$ 花费 $1$ 枚金币。\n\n共花费 $8 $ 枚金币。\n\n**样例 2 说明**\n\n棋盘的颜色如下表格所示，其中空白的部分表示无色。\n\n| $\\color{red}\\text{红}$ | $\\color{red}\\text{红}$ |  |  |  |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n|  | $\\color{yellow}\\text{黄}$ |  |  |  |\n|  |  | $\\color{yellow}\\text{黄}$ |  |  |\n|  |  |  | $\\color{white}\\text{　}$ |  |\n|  |  |  |  | $\\color{red}\\text{红}$ |\n\n从 $( 1, 1)$ 走到 $( 1, 2)$，不花费金币。\n\n从 $( 1, 2)$ 走到 $( 2, 2)$，花费 $ 1 $ 金币。\n\n施展魔法将 $( 2, 3)$ 变为黄色，并从 $( 2, 2)$ 走到 $( 2, 3)$ 花费 $ 2$ 金币。\n\n从 $( 2, 3)$ 走到 $( 3, 3)$ 不花费金币。\n\n从 $( 3, 3)$ 只能施展魔法到达 $( 3, 2),( 2, 3),( 3, 4),( 4, 3)$。\n\n而从以上四点均无法到达 $( 5, 5)$，故无法到达终点，输出$-1$。\n\n**数据规模与约定**\n\n对于 $30\\%$ 的数据，$1 ≤ m ≤ 5, 1 ≤ n ≤ 10$。\n\n对于 $60\\%$ 的数据，$1 ≤ m ≤ 20, 1 ≤ n ≤ 200$。\n\n对于 $100\\%$ 的数据，$1 ≤ m ≤ 100, 1 ≤ n ≤ 1,000, 0 ≤ c ≤ 2$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2017 Junior] Chessboard", "background": "NOIP 2017 Junior T3.", "description": "There is an $m \\times m$ chessboard. Each cell on the board may be red, yellow, or colorless. You need to go from the top-left corner of the board to the bottom-right corner.\n\nAt any moment, the cell you stand on must be colored (not colorless). You can move only in four directions: up, down, left, and right. When you move from one cell to another, if the two cells have the same color, you do not need to spend any coins; if the colors are different, you need to spend $1$ coin.\n\nIn addition, you can spend $2$ coins to cast a spell to temporarily change the next colorless cell into a color you choose. But this spell cannot be used consecutively, and its duration is short. That is, if you use this spell and step onto this temporarily colored cell, you cannot use the spell again; only when you leave this position and step onto a cell that originally has a color can you use the spell again. When you leave the cell that was made colored by the spell, it reverts to colorless.\n\nNow you need to go from the top-left corner to the bottom-right corner of the board. Find the minimum number of coins required.", "inputFormat": "The first line contains two positive integers $ m, n$, separated by a space, which denote the size of the board and the number of colored cells, respectively.\n\nThe next $ n $ lines each contain three integers $ x, y, c$, indicating that the cell at coordinates $(x,y)$ has color $ c$.\n\nHere, $ c=1$ means yellow, and $ c=0$ means red. Adjacent numbers are separated by a space. The top-left corner has coordinates $(1, 1)$, and the bottom-right corner has coordinates $( m, m)$.\n\nAll other cells on the board are colorless. It is guaranteed that the top-left corner $(1, 1)$ is colored.", "outputFormat": "Output a single integer, the minimum number of coins required. If it is impossible to reach the destination, output `-1`.", "hint": "Explanation for Sample 1\n\nThe board’s colors are as shown in the table below, where blank cells are colorless.\n\n| $\\color{red}\\text{红}$ | $\\color{red}\\text{红}$ |  |  |  |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n|  | $\\color{yellow}\\text{黄}$ |  |  |  |\n|  |  | $\\color{yellow}\\text{黄}$ | $\\color{red}\\text{红}$ |  |\n|  |  |  | $\\color{yellow}\\text{黄}$ |  |\n|  |  |  |  | $\\color{red}\\text{红}$ |\n\nStart from $(1,1)$ and move to $(1,2)$ without spending coins.\n\nMove from $(1,2)$ down to $(2,2)$, spending $1$ coin.\n\nCast the spell at $(2,2)$ to make $(2,3)$ yellow, spending $2$ coins.\n\nMove from $(2,2)$ to $(2,3)$ without spending coins.\n\nMove from $(2,3)$ to $(3,3)$ without spending coins.\n\nMove from $(3,3)$ to $(3,4)$, spending $1$ coin.\n\nMove from $(3,4)$ to $(4,4)$, spending $1$ coin.\n\nCast the spell at $(4,4)$ to make $(4,5)$ yellow, spending $ 2$ coins.\n\nMove from $(4,4)$ to $(4,5)$ without spending coins.\n\nMove from $(4,5)$ to $(5,5)$, spending $1$ coin.\n\nA total of $8 $ coins are spent.\n\nExplanation for Sample 2\n\nThe board’s colors are as shown in the table below, where blank cells are colorless.\n\n| $\\color{red}\\text{红}$ | $\\color{red}\\text{红}$ |  |  |  |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n|  | $\\color{yellow}\\text{黄}$ |  |  |  |\n|  |  | $\\color{yellow}\\text{黄}$ |  |  |\n|  |  |  | $\\color{white}\\text{　}$ |  |\n|  |  |  |  | $\\color{red}\\text{红}$ |\n\nFrom $( 1, 1)$ to $( 1, 2)$, spend no coins.\n\nFrom $( 1, 2)$ to $( 2, 2)$, spend $ 1 $ coin.\n\nCast the spell to make $( 2, 3)$ yellow, and move from $( 2, 2)$ to $( 2, 3)$, spending $ 2$ coins.\n\nFrom $( 2, 3)$ to $( 3, 3)$, spend no coins.\n\nFrom $( 3, 3)$, you can only cast the spell to reach $( 3, 2),( 2, 3),( 3, 4),( 4, 3)$.\n\nFrom none of these four cells can you reach $( 5, 5)$, so it is impossible to reach the destination, and the output is $-1$.\n\n**Constraints**\n\nFor $30\\%$ of the testdata, $1 ≤ m ≤ 5, 1 ≤ n ≤ 10$.\n\nFor $60\\%$ of the testdata, $1 ≤ m ≤ 20, 1 ≤ n ≤ 200$.\n\nFor $100\\%$ of the testdata, $1 ≤ m ≤ 100, 1 ≤ n ≤ 1,000, 0 ≤ c ≤ 2$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2017 普及组] 棋盘", "background": "NOIP2017 普及组 T3", "description": "有一个 $m \\times m$ 的棋盘，棋盘上每一个格子可能是红色、黄色或没有任何颜色的。你现在要从棋盘的最左上角走到棋盘的最右下角。\n\n任何一个时刻，你所站在的位置必须是有颜色的（不能是无色的）， 你只能向上、下、左、右四个方向前进。当你从一个格子走向另一个格子时，如果两个格子的颜色相同，那你不需要花费金币；如果不同，则你需要花费 $1 $ 个金币。\n\n另外， 你可以花费 $2$ 个金币施展魔法让下一个无色格子暂时变为你指定的颜色。但这个魔法不能连续使用， 而且这个魔法的持续时间很短，也就是说，如果你使用了这个魔法，走到了这个暂时有颜色的格子上，你就不能继续使用魔法； 只有当你离开这个位置，走到一个本来就有颜色的格子上的时候，你才能继续使用这个魔法，而当你离开了这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢复为无色。\n\n现在你要从棋盘的最左上角，走到棋盘的最右下角，求花费的最少金币是多少？", "inputFormat": "第一行包含两个正整数 $ m, n$，以一个空格分开，分别代表棋盘的大小，棋盘上有颜色的格子的数量。\n\n接下来的 $ n $ 行，每行三个正整数 $ x, y, c$， 分别表示坐标为 $(x,y)$ 的格子有颜色 $ c$。\n\n其中 $ c=1$ 代表黄色，$ c=0$ 代表红色。 相邻两个数之间用一个空格隔开。 棋盘左上角的坐标为 $(1, 1)$，右下角的坐标为 $( m, m)$。\n\n棋盘上其余的格子都是无色。保证棋盘的左上角，也就是 $(1, 1)$ 一定是有颜色的。", "outputFormat": "一个整数，表示花费的金币的最小值，如果无法到达，输出 `-1`。", "hint": "**样例 1 说明**\n\n棋盘的颜色如下表格所示，其中空白的部分表示无色。\n\n| $\\color{red}\\text{红}$ | $\\color{red}\\text{红}$ |  |  |  |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n|  | $\\color{yellow}\\text{黄}$ |  |  |  |\n|  |  | $\\color{yellow}\\text{黄}$ | $\\color{red}\\text{红}$ |  |\n|  |  |  | $\\color{yellow}\\text{黄}$ |  |\n|  |  |  |  | $\\color{red}\\text{红}$ |\n\n\n从 $(1,1)$ 开始，走到 $(1,2)$ 不花费金币。\n\n从 $(1,2)$ 向下走到 $(2,2)$ 花费 $1$ 枚金币。\n\n从 $(2,2)$ 施展魔法，将 $(2,3)$ 变为黄色，花费 $2$ 枚金币。\n\n从 $(2,2)$ 走到 $(2,3)$ 不花费金币。\n\n从 $(2,3)$ 走到 $(3,3)$ 不花费金币。\n\n从 $(3,3)$ 走到 $(3,4)$ 花费 $1$ 枚金币。\n\n从 $(3,4)$ 走到 $(4,4)$ 花费 $1$ 枚金币。\n\n从 $(4,4)$ 施展魔法，将 $(4,5)$ 变为黄色，花费 $ 2$ 枚金币。\n\n从 $(4,4)$ 走到 $(4,5)$ 不花费金币。\n\n从 $(4,5)$ 走到 $(5,5)$ 花费 $1$ 枚金币。\n\n共花费 $8 $ 枚金币。\n\n**样例 2 说明**\n\n棋盘的颜色如下表格所示，其中空白的部分表示无色。\n\n| $\\color{red}\\text{红}$ | $\\color{red}\\text{红}$ |  |  |  |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n|  | $\\color{yellow}\\text{黄}$ |  |  |  |\n|  |  | $\\color{yellow}\\text{黄}$ |  |  |\n|  |  |  | $\\color{white}\\text{　}$ |  |\n|  |  |  |  | $\\color{red}\\text{红}$ |\n\n从 $( 1, 1)$ 走到 $( 1, 2)$，不花费金币。\n\n从 $( 1, 2)$ 走到 $( 2, 2)$，花费 $ 1 $ 金币。\n\n施展魔法将 $( 2, 3)$ 变为黄色，并从 $( 2, 2)$ 走到 $( 2, 3)$ 花费 $ 2$ 金币。\n\n从 $( 2, 3)$ 走到 $( 3, 3)$ 不花费金币。\n\n从 $( 3, 3)$ 只能施展魔法到达 $( 3, 2),( 2, 3),( 3, 4),( 4, 3)$。\n\n而从以上四点均无法到达 $( 5, 5)$，故无法到达终点，输出$-1$。\n\n**数据规模与约定**\n\n对于 $30\\%$ 的数据，$1 ≤ m ≤ 5, 1 ≤ n ≤ 10$。\n\n对于 $60\\%$ 的数据，$1 ≤ m ≤ 20, 1 ≤ n ≤ 200$。\n\n对于 $100\\%$ 的数据，$1 ≤ m ≤ 100, 1 ≤ n ≤ 1,000, 0 ≤ c ≤ 2$。", "locale": "zh-CN"}}}
{"pid": "P3957", "type": "P", "difficulty": 5, "samples": [["7 4 10\n2 6\n5 -3\n10 3\n11 -3\n13 1\n17 6\n20 2", "2"], ["7 4 20\n2 6\n5 -3\n10 3\n11 -3\n13 1\n17 6\n20 2", "-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "2017", "二分", "单调队列", "NOIP 普及组", "队列"], "title": "[NOIP 2017 普及组] 跳房子", "background": "NOIP2017 普及组 T4", "description": "跳房子，也叫跳飞机，是一种世界性的儿童游戏，也是中国民间传统的体育游戏之一。\n\n跳房子的游戏规则如下：\n\n在地面上确定一个起点，然后在起点右侧画 $n$ 个格子，这些格子都在同一条直线上。每个格子内有一个数字（整数），表示到达这个格子能得到的分数。玩家第一次从起点开始向右跳，跳到起点右侧的一个格子内。第二次再从当前位置继续向右跳，依此类推。规则规定：\n\n玩家每次都必须跳到当前位置右侧的一个格子内。玩家可以在任意时刻结束游戏，获得的分数为曾经到达过的格子中的数字之和。\n\n现在小 R 研发了一款弹跳机器人来参加这个游戏。但是这个机器人有一个非常严重的缺陷，它每次向右弹跳的距离只能为固定的 $d$。小 R 希望改进他的机器人，如果他花 $g$ 个金币改进他的机器人，那么他的机器人灵活性就能增加 $g$，但是需要注意的是，每 次弹跳的距离至少为 $1$。具体而言，当 $g<d$ 时，他的机器人每次可以选择向右弹跳的距离为 $d-g,d-g+1,d-g+2,\\ldots,d+g-1,d+g$；否则当 $g \\geq d$ 时，他的机器人每次可以选择向右弹跳的距离为 $1,2,3,\\ldots,d+g-1,d+g$。\n\n现在小 R 希望获得至少 $k$ 分，请问他至少要花多少金币来改造他的机器人。", "inputFormat": "第一行三个正整数 $n,d,k$，分别表示格子的数目，改进前机器人弹跳的固定距离，以及希望至少获得的分数。相邻两个数 之间用一个空格隔开。\n\n接下来 $n$ 行，每行两个整数 $x_i,s_i$，分别表示起点到第 $i$ 个格子的距离以及第 $i$ 个格子的分数。两个数之间用一个空格隔开。保证 $x_i$ 按递增顺序输入。", "outputFormat": "共一行，一个整数，表示至少要花多少金币来改造他的机器人。若无论如何他都无法获得至少 $k$ 分，输出 $-1$。", "hint": "**样例 1 说明**\n\n花费 $2$ 个金币改进后，小 R 的机器人依次选择的向右弹跳的距离分别为 $ 2, 3, 5, 3, 4,3$，先后到达的位置分别为 $2, 5, 10, 13, 17, 20$，对应 $ 1, 2, 3, 5, 6, 7$ 这 $6$ 个格子。这些格子中的数字之和 $ 15$ 即为小 R 获得的分数。\n\n**样例 2 说明**\n\n由于样例中 $7$ 个格子组合的最大可能数字之和只有 $18$，所以无论如何都无法获得 $20$ 分。\n\n**数据规模与约定**\n\n本题共 10 组测试数据，每组数据等分。\n\n对于全部的数据满足 $1 \\le n \\le 5\\times10^5$，$1 \\le d \\le2\\times10^3$，$1 \\le x_i, k \\le 10^9$，$|s_i| < 10^5$。\n\n对于第 $1, 2$ 组测试数据，保证 $n\\le 10$。\n\n对于第 $3, 4, 5$ 组测试数据，保证 $n \\le 500$。\n\n对于第 $6, 7, 8$ 组测试数据，保证 $d = 1$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2017 Junior] Hopscotch", "background": "NOIP 2017 Junior T4.", "description": "Hopscotch, also called “jumping the airplane,” is a worldwide children’s game and one of China’s traditional folk sports.\n\nThe rules of hopscotch are as follows:\n\nOn the ground, fix a starting point, and then draw $n$ cells to the right of the start point along a straight line. Each cell contains an integer, which is the score awarded upon reaching that cell. The player starts at the start point and, on the first jump, jumps to a cell to the right of the start point. On the second jump, the player continues jumping to the right from the current position, and so on. The rules state:\n\n- On every jump, the player must land on a cell strictly to the right of the current position. The player may end the game at any time. The final score is the sum of the numbers in all cells that have ever been reached.\n\nNow, Xiao R has developed a bouncing robot to play this game. However, the robot has a very serious flaw: each time it jumps to the right, the distance can only be a fixed $d$. Xiao R wants to improve his robot. If he spends $g$ gold coins to improve the robot, its flexibility increases by $g$. Note that each jump distance must be at least $1$. Specifically, when $g < d$, the robot can choose its rightward jump distance each time from $d-g, d-g+1, d-g+2, \\ldots, d+g-1, d+g$; otherwise, when $g \\ge d$, the robot can choose its rightward jump distance each time from $1, 2, 3, \\ldots, d+g-1, d+g$.\n\nNow Xiao R wants to obtain at least $k$ points. What is the minimum number of gold coins he must spend to modify his robot?", "inputFormat": "The first line contains three positive integers $n, d, k$, representing the number of cells, the robot’s fixed jump distance before improvement, and the desired score (at least $k$). The numbers are separated by a single space.\n\nThe next $n$ lines each contain two integers $x_i, s_i$, representing the distance from the start point to the $i$-th cell and the score of the $i$-th cell. The two numbers are separated by a single space. It is guaranteed that $x_i$ are given in increasing order.", "outputFormat": "Output a single integer: the minimum number of gold coins required to modify the robot. If it is impossible to obtain at least $k$ points under any circumstances, output $-1$.", "hint": "- Sample 1 explanation\n\nAfter spending $2$ gold coins on improvements, Xiao R’s robot chooses rightward jump distances $2, 3, 5, 3, 4, 3$ in order, reaching positions $2, 5, 10, 13, 17, 20$, which correspond to cells $1, 2, 3, 5, 6, 7$. The sum of the numbers in these cells is $15$, which is the score obtained by Xiao R.\n\n- Sample 2 explanation\n\nSince the maximum possible sum of the numbers of any subset of the $7$ cells in the sample is only $18$, it is impossible to obtain $20$ points.\n\n- Constraints\n\nThere are $10$ groups of testdata, each accounting for an equal proportion.\n\nFor all testdata, $1 \\le n \\le 5\\times 10^5$, $1 \\le d \\le 2\\times 10^3$, $1 \\le x_i, k \\le 10^9$, $|s_i| < 10^5$.\n\nFor testdata groups $1$ and $2$, $n \\le 10$.\n\nFor testdata groups $3$, $4$, and $5$, $n \\le 500$.\n\nFor testdata groups $6$, $7$, and $8$, $d = 1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2017 普及组] 跳房子", "background": "NOIP2017 普及组 T4", "description": "跳房子，也叫跳飞机，是一种世界性的儿童游戏，也是中国民间传统的体育游戏之一。\n\n跳房子的游戏规则如下：\n\n在地面上确定一个起点，然后在起点右侧画 $n$ 个格子，这些格子都在同一条直线上。每个格子内有一个数字（整数），表示到达这个格子能得到的分数。玩家第一次从起点开始向右跳，跳到起点右侧的一个格子内。第二次再从当前位置继续向右跳，依此类推。规则规定：\n\n玩家每次都必须跳到当前位置右侧的一个格子内。玩家可以在任意时刻结束游戏，获得的分数为曾经到达过的格子中的数字之和。\n\n现在小 R 研发了一款弹跳机器人来参加这个游戏。但是这个机器人有一个非常严重的缺陷，它每次向右弹跳的距离只能为固定的 $d$。小 R 希望改进他的机器人，如果他花 $g$ 个金币改进他的机器人，那么他的机器人灵活性就能增加 $g$，但是需要注意的是，每 次弹跳的距离至少为 $1$。具体而言，当 $g<d$ 时，他的机器人每次可以选择向右弹跳的距离为 $d-g,d-g+1,d-g+2,\\ldots,d+g-1,d+g$；否则当 $g \\geq d$ 时，他的机器人每次可以选择向右弹跳的距离为 $1,2,3,\\ldots,d+g-1,d+g$。\n\n现在小 R 希望获得至少 $k$ 分，请问他至少要花多少金币来改造他的机器人。", "inputFormat": "第一行三个正整数 $n,d,k$，分别表示格子的数目，改进前机器人弹跳的固定距离，以及希望至少获得的分数。相邻两个数 之间用一个空格隔开。\n\n接下来 $n$ 行，每行两个整数 $x_i,s_i$，分别表示起点到第 $i$ 个格子的距离以及第 $i$ 个格子的分数。两个数之间用一个空格隔开。保证 $x_i$ 按递增顺序输入。", "outputFormat": "共一行，一个整数，表示至少要花多少金币来改造他的机器人。若无论如何他都无法获得至少 $k$ 分，输出 $-1$。", "hint": "**样例 1 说明**\n\n花费 $2$ 个金币改进后，小 R 的机器人依次选择的向右弹跳的距离分别为 $ 2, 3, 5, 3, 4,3$，先后到达的位置分别为 $2, 5, 10, 13, 17, 20$，对应 $ 1, 2, 3, 5, 6, 7$ 这 $6$ 个格子。这些格子中的数字之和 $ 15$ 即为小 R 获得的分数。\n\n**样例 2 说明**\n\n由于样例中 $7$ 个格子组合的最大可能数字之和只有 $18$，所以无论如何都无法获得 $20$ 分。\n\n**数据规模与约定**\n\n本题共 10 组测试数据，每组数据等分。\n\n对于全部的数据满足 $1 \\le n \\le 5\\times10^5$，$1 \\le d \\le2\\times10^3$，$1 \\le x_i, k \\le 10^9$，$|s_i| < 10^5$。\n\n对于第 $1, 2$ 组测试数据，保证 $n\\le 10$。\n\n对于第 $3, 4, 5$ 组测试数据，保证 $n \\le 500$。\n\n对于第 $6, 7, 8$ 组测试数据，保证 $d = 1$。", "locale": "zh-CN"}}}
{"pid": "P3958", "type": "P", "difficulty": 3, "samples": [["3 \n2 4 1 \n0 0 1 \n0 0 3 \n2 5 1 \n0 0 1 \n0 0 4 \n2 5 2 \n0 0 2 \n2 0 4", "Yes\nNo\nYes"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["搜索", "数学", "2017", "并查集", "NOIP 提高组", "广度优先搜索 BFS", "深度优先搜索 DFS"], "title": "[NOIP 2017 提高组] 奶酪", "background": "NOIP2017 提高组 D2T1", "description": "现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为 $z = 0$，奶酪的上表面为 $z = h$。\n\n现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。\n\n位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑到奶酪的上表面去?\n\n空间内两点 $P_1(x_1,y_1,z_1)$、$P_2(x_2,y_2,z_2)$ 的距离公式如下：\n\n\n$$\\mathrm{dist}(P_1,P_2)=\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$$", "inputFormat": "每个输入文件包含多组数据。\n\n第一行，包含一个正整数 $T$，代表该输入文件中所含的数据组数。\n\n接下来是 $T$ 组数据，每组数据的格式如下： 第一行包含三个正整数 $n,h,r$，两个数之间以一个空格分开，分别代表奶酪中空洞的数量，奶酪的高度和空洞的半径。\n\n接下来的 $n$ 行，每行包含三个整数 $x,y,z$，两个数之间以一个空格分开，表示空洞球心坐标为 $(x,y,z)$。", "outputFormat": "$T$ 行，分别对应 $T$ 组数据的答案，如果在第 $i$ 组数据中，Jerry 能从下表面跑到上表面，则输出 `Yes`，如果不能，则输出 `No`。", "hint": "**【输入输出样例 $1$ 说明】**\n\n ![](https://cdn.luogu.com.cn/upload/pic/10860.png) \n\n第一组数据，由奶酪的剖面图可见：\n\n第一个空洞在 $(0,0,0)$ 与下表面相切；\n\n第二个空洞在 $(0,0,4)$ 与上表面相切；\n\n两个空洞在 $(0,0,2)$ 相切。\n\n输出 `Yes`。\n\n \n第二组数据，由奶酪的剖面图可见：\n\n两个空洞既不相交也不相切。\n\n输出 `No`。\n\n \n第三组数据，由奶酪的剖面图可见：\n\n两个空洞相交，且与上下表面相切或相交。\n\n输出 `Yes`。\n\n**【数据规模与约定】**\n\n对于 $20\\%$ 的数据，$n = 1$，$1 \\le h$，$r \\le  10^4$，坐标的绝对值不超过 $10^4$。\n\n对于 $40\\%$ 的数据，$1 \\le n \\le 8$，$1 \\le h$，$r \\le 10^4$，坐标的绝对值不超过 $10^4$。\n\n对于 $80\\%$ 的数据，$1 \\le n \\le 10^3$，$1 \\le h , r \\le 10^4$，坐标的绝对值不超过 $10^4$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 1\\times 10^3$，$1 \\le h , r \\le 10^9$，$1 \\le T \\le 20$，坐标的绝对值不超过 $10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2017 Senior] Cheese", "background": "NOIP 2017 Senior D2T1.", "description": "There is a large block of cheese with height $h$, and we may regard its length and width as infinite. Inside the cheese, there are many spherical cavities with the same radius. We can establish a 3D coordinate system in the cheese, where the bottom surface of the cheese is $z = 0$ and the top surface is $z = h$.\n\nNow, there is a little mouse Jerry on the bottom surface of the cheese. He knows the coordinates of the centers of all the cavities. If two cavities are tangent to or intersect each other, then Jerry can run from one cavity to the other. In particular, if a cavity is tangent to or intersects the bottom surface, Jerry can enter the cavity from the bottom surface; if a cavity is tangent to or intersects the top surface, Jerry can go from the cavity to the top surface.\n\nStarting on the bottom surface, Jerry wants to know whether he can reach the top surface by using the existing cavities without damaging the cheese.\n\nThe distance between two points $P_1(x_1, y_1, z_1)$ and $P_2(x_2, y_2, z_2)$ in space is:\n$$\\mathrm{dist}(P_1,P_2)=\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}.$$", "inputFormat": "Each input file contains multiple data sets.\n\nThe first line contains a positive integer $T$, the number of data sets in the file.\n\nThen follow $T$ data sets, each with the following format: The first line contains three positive integers $n, h, r$, separated by a space, representing the number of cavities, the height of the cheese, and the radius of each cavity.\n\nThe next $n$ lines each contain three integers $x, y, z$, separated by a space, indicating that the center of a cavity is at $(x, y, z)$.", "outputFormat": "Output $T$ lines. For the $i$-th data set, if Jerry can go from the bottom surface to the top surface, output `Yes`; otherwise, output `No`.", "hint": "【Explanation for Sample I/O 1】\n\n![](https://cdn.luogu.com.cn/upload/pic/10860.png)\n\nFor the first data set, from the cross-sectional view:\n- The first cavity is tangent to the bottom surface at $(0, 0, 0)$.\n- The second cavity is tangent to the top surface at $(0, 0, 4)$.\n- The two cavities are tangent at $(0, 0, 2)$.\nOutput `Yes`.\n\nFor the second data set, from the cross-sectional view:\n- The two cavities neither intersect nor are tangent.\nOutput `No`.\n\nFor the third data set, from the cross-sectional view:\n- The two cavities intersect, and they are each tangent to or intersect the top and bottom surfaces.\nOutput `Yes`.\n\n【Constraints】\n\n- For $20\\%$ of the testdata, $n = 1$, $1 \\le h, r \\le 10^4$, and the absolute value of each coordinate does not exceed $10^4$.\n- For $40\\%$ of the testdata, $1 \\le n \\le 8$, $1 \\le h, r \\le 10^4$, and the absolute value of each coordinate does not exceed $10^4$.\n- For $80\\%$ of the testdata, $1 \\le n \\le 10^3$, $1 \\le h, r \\le 10^4$, and the absolute value of each coordinate does not exceed $10^4$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 1 \\times 10^3$, $1 \\le h, r \\le 10^9$, $1 \\le T \\le 20$, and the absolute value of each coordinate does not exceed $10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2017 提高组] 奶酪", "background": "NOIP2017 提高组 D2T1", "description": "现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为 $z = 0$，奶酪的上表面为 $z = h$。\n\n现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。\n\n位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑到奶酪的上表面去?\n\n空间内两点 $P_1(x_1,y_1,z_1)$、$P_2(x_2,y_2,z_2)$ 的距离公式如下：\n\n\n$$\\mathrm{dist}(P_1,P_2)=\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$$", "inputFormat": "每个输入文件包含多组数据。\n\n第一行，包含一个正整数 $T$，代表该输入文件中所含的数据组数。\n\n接下来是 $T$ 组数据，每组数据的格式如下： 第一行包含三个正整数 $n,h,r$，两个数之间以一个空格分开，分别代表奶酪中空洞的数量，奶酪的高度和空洞的半径。\n\n接下来的 $n$ 行，每行包含三个整数 $x,y,z$，两个数之间以一个空格分开，表示空洞球心坐标为 $(x,y,z)$。", "outputFormat": "$T$ 行，分别对应 $T$ 组数据的答案，如果在第 $i$ 组数据中，Jerry 能从下表面跑到上表面，则输出 `Yes`，如果不能，则输出 `No`。", "hint": "**【输入输出样例 $1$ 说明】**\n\n ![](https://cdn.luogu.com.cn/upload/pic/10860.png) \n\n第一组数据，由奶酪的剖面图可见：\n\n第一个空洞在 $(0,0,0)$ 与下表面相切；\n\n第二个空洞在 $(0,0,4)$ 与上表面相切；\n\n两个空洞在 $(0,0,2)$ 相切。\n\n输出 `Yes`。\n\n \n第二组数据，由奶酪的剖面图可见：\n\n两个空洞既不相交也不相切。\n\n输出 `No`。\n\n \n第三组数据，由奶酪的剖面图可见：\n\n两个空洞相交，且与上下表面相切或相交。\n\n输出 `Yes`。\n\n**【数据规模与约定】**\n\n对于 $20\\%$ 的数据，$n = 1$，$1 \\le h$，$r \\le  10^4$，坐标的绝对值不超过 $10^4$。\n\n对于 $40\\%$ 的数据，$1 \\le n \\le 8$，$1 \\le h$，$r \\le 10^4$，坐标的绝对值不超过 $10^4$。\n\n对于 $80\\%$ 的数据，$1 \\le n \\le 10^3$，$1 \\le h , r \\le 10^4$，坐标的绝对值不超过 $10^4$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 1\\times 10^3$，$1 \\le h , r \\le 10^9$，$1 \\le T \\le 20$，坐标的绝对值不超过 $10^9$。", "locale": "zh-CN"}}}
{"pid": "P3959", "type": "P", "difficulty": 6, "samples": [["4 5\n1 2 1\n1 3 3\n1 4 1\n2 3 4\n3 4 1", "4"], ["4 5\n1 2 1\n1 3 3\n1 4 1\n2 3 4\n3 4 2", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["贪心", "2017", "NOIP 提高组", "枚举", "状压 DP"], "title": "[NOIP 2017 提高组] 宝藏", "background": "NOIP2017 D2T2", "description": "参与考古挖掘的小明得到了一份藏宝图，藏宝图上标出了 $n$ 个深埋在地下的宝藏屋， 也给出了这 $n$ 个宝藏屋之间可供开发的 $m$ 条道路和它们的长度。\n\n小明决心亲自前往挖掘所有宝藏屋中的宝藏。但是，每个宝藏屋距离地面都很远，也就是说，从地面打通一条到某个宝藏屋的道路是很困难的，而开发宝藏屋之间的道路则相对容易很多。\n\n小明的决心感动了考古挖掘的赞助商，赞助商决定免费赞助他打通一条从地面到某个宝藏屋的通道，通往哪个宝藏屋则由小明来决定。\n\n在此基础上，小明还需要考虑如何开凿宝藏屋之间的道路。已经开凿出的道路可以任意通行不消耗代价。每开凿出一条新道路，小明就会与考古队一起挖掘出由该条道路所能到达的宝藏屋的宝藏。另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏屋之间的道路无需再开发。\n\n新开发一条道路的代价是 $L\\times K$。其中 $L$ 代表这条道路的长度，$K$ 代表从赞助商帮你打通的宝藏屋到这条道路起点的宝藏屋所经过的宝藏屋的数量（包括赞助商帮你打通的宝藏屋和这条道路起点的宝藏屋） 。\n\n请你编写程序为小明选定由赞助商打通的宝藏屋和之后开凿的道路，使得工程总代价最小，并输出这个最小值。", "inputFormat": "第一行两个用空格分离的正整数 $n,m$，代表宝藏屋的个数和道路数。\n\n接下来 $m$ 行，每行三个用空格分离的正整数，分别是由一条道路连接的两个宝藏屋的编号（编号为 $1-n$），和这条道路的长度 $v$。", "outputFormat": "一个正整数，表示最小的总代价。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/10868.png) \n\n【样例解释 $1$】\n\n小明选定让赞助商打通了 $1$ 号宝藏屋。小明开发了道路 $1 \\to 2$，挖掘了 $2$ 号宝藏。开发了道路 $1 \\to 4$，挖掘了 $4$ 号宝藏。还开发了道路 $4 \\to 3$，挖掘了 $3$ 号宝藏。\n\n工程总代价为 $1 \\times 1 + 1 \\times 1 + 1 \\times 2  = 4 $。\n\n【样例解释 $2$】\n\n小明选定让赞助商打通了 $1$ 号宝藏屋。小明开发了道路 $1 \\to 2$，挖掘了 $2$ 号宝藏。开发了道路 $1 \\to 3$，挖掘了 $3$ 号宝藏。还开发了道路 $1 \\to 4$，挖掘了 $4$ 号宝藏。\n\n工程总代价为 $1 \\times 1 + 3 \\times 1 + 1 \\times 1  = 5$。\n\n\n【数据规模与约定】\n\n对于 $ 20\\%$ 的数据： 保证输入是一棵树，$1 \\le n \\le 8$，$v \\le 5\\times 10^3$ 且所有的 $v$ 都相等。\n\n对于 $40\\%$ 的数据： $1 \\le n \\le 8$，$0 \\le m \\le 10^3$，$v \\le 5\\times 10^3$ 且所有的 $v$ 都相等。\n\n对于 $ 70\\%$ 的数据： $1 \\le n \\le 8$，$0 \\le m \\le 10^3$，$v \\le  5\\times 10^3$。\n\n对于 $ 100\\%$ 的数据： $1 \\le n \\le 12$，$0 \\le m \\le 10^3$，$v \\le  5\\times 10^5$。\n\n---\n\n$\\text{upd 2022.7.27}$：新增加 $50$ 组 Hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2017 Senior] Treasure", "background": "NOIP 2017 D2T2.", "description": "Xiaoming, who is taking part in an archaeological dig, obtained a treasure map. The map marks $n$ treasure chambers buried deep underground, and gives $m$ developable roads between these $n$ chambers together with their lengths.\n\nXiaoming resolves to excavate the treasure in all chambers. However, every chamber is far from the surface. That is, opening a road from the surface to some chamber is difficult, whereas opening roads between chambers is much easier.\n\nMoved by Xiaoming’s determination, the sponsor decides to open for free exactly one passage from the surface to a chamber, and Xiaoming can choose which chamber it leads to.\n\nAfter that, Xiaoming must decide how to open roads between chambers. Any already opened road can be traversed arbitrarily at no cost. Each time a new road is opened, Xiaoming and the team excavate the treasure chambers that become reachable via that road. Moreover, Xiaoming does not want to open useless roads; that is, a road between two already excavated chambers need not be opened.\n\nThe cost to open a new road is $L \\times K$, where $L$ is the road’s length, and $K$ is the number of chambers along the path from the sponsored chamber to the starting chamber of this road (including both the sponsored chamber and this road’s starting chamber).\n\nChoose the sponsored chamber and the subsequent roads to open so that the total cost is minimized, and output this minimum.", "inputFormat": "The first line contains two space-separated positive integers $n,m$, the number of treasure chambers and the number of roads.\n\nThe next $m$ lines each contain three space-separated positive integers: the indices of two chambers connected by a road (numbered $1-n$), and the length $v$ of that road.", "outputFormat": "Output a single positive integer, the minimum total cost.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/10868.png)\n\n[Sample explanation $1$]\n\nXiaoming chooses chamber $1$ to be opened by the sponsor. Xiaoming opens road $1 \\to 2$ and excavates chamber $2$. He opens road $1 \\to 4$ and excavates chamber $4$. He also opens road $4 \\to 3$ and excavates chamber $3$.\n\nThe total cost is $1 \\times 1 + 1 \\times 1 + 1 \\times 2  = 4$.\n\n[Sample explanation $2$]\n\nXiaoming chooses chamber $1$ to be opened by the sponsor. Xiaoming opens road $1 \\to 2$ and excavates chamber $2$. He opens road $1 \\to 3$ and excavates chamber $3$. He also opens road $1 \\to 4$ and excavates chamber $4$.\n\nThe total cost is $1 \\times 1 + 3 \\times 1 + 1 \\times 1  = 5$.\n\nConstraints\n\n- For $20\\%$ of the testdata: the input is guaranteed to be a tree, $1 \\le n \\le 8$, $v \\le 5 \\times 10^3$, and all $v$ are equal.\n- For $40\\%$ of the testdata: $1 \\le n \\le 8$, $0 \\le m \\le 10^3$, $v \\le 5 \\times 10^3$, and all $v$ are equal.\n- For $70\\%$ of the testdata: $1 \\le n \\le 8$, $0 \\le m \\le 10^3$, $v \\le 5 \\times 10^3$.\n- For $100\\%$ of the testdata: $1 \\le n \\le 12$, $0 \\le m \\le 10^3$, $v \\le 5 \\times 10^5$.\n\n---\n\n$\\text{upd 2022.7.27}$: Added $50$ groups of hack testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2017 提高组] 宝藏", "background": "NOIP2017 D2T2", "description": "参与考古挖掘的小明得到了一份藏宝图，藏宝图上标出了 $n$ 个深埋在地下的宝藏屋， 也给出了这 $n$ 个宝藏屋之间可供开发的 $m$ 条道路和它们的长度。\n\n小明决心亲自前往挖掘所有宝藏屋中的宝藏。但是，每个宝藏屋距离地面都很远，也就是说，从地面打通一条到某个宝藏屋的道路是很困难的，而开发宝藏屋之间的道路则相对容易很多。\n\n小明的决心感动了考古挖掘的赞助商，赞助商决定免费赞助他打通一条从地面到某个宝藏屋的通道，通往哪个宝藏屋则由小明来决定。\n\n在此基础上，小明还需要考虑如何开凿宝藏屋之间的道路。已经开凿出的道路可以任意通行不消耗代价。每开凿出一条新道路，小明就会与考古队一起挖掘出由该条道路所能到达的宝藏屋的宝藏。另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏屋之间的道路无需再开发。\n\n新开发一条道路的代价是 $L\\times K$。其中 $L$ 代表这条道路的长度，$K$ 代表从赞助商帮你打通的宝藏屋到这条道路起点的宝藏屋所经过的宝藏屋的数量（包括赞助商帮你打通的宝藏屋和这条道路起点的宝藏屋） 。\n\n请你编写程序为小明选定由赞助商打通的宝藏屋和之后开凿的道路，使得工程总代价最小，并输出这个最小值。", "inputFormat": "第一行两个用空格分离的正整数 $n,m$，代表宝藏屋的个数和道路数。\n\n接下来 $m$ 行，每行三个用空格分离的正整数，分别是由一条道路连接的两个宝藏屋的编号（编号为 $1-n$），和这条道路的长度 $v$。", "outputFormat": "一个正整数，表示最小的总代价。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/10868.png) \n\n【样例解释 $1$】\n\n小明选定让赞助商打通了 $1$ 号宝藏屋。小明开发了道路 $1 \\to 2$，挖掘了 $2$ 号宝藏。开发了道路 $1 \\to 4$，挖掘了 $4$ 号宝藏。还开发了道路 $4 \\to 3$，挖掘了 $3$ 号宝藏。\n\n工程总代价为 $1 \\times 1 + 1 \\times 1 + 1 \\times 2  = 4 $。\n\n【样例解释 $2$】\n\n小明选定让赞助商打通了 $1$ 号宝藏屋。小明开发了道路 $1 \\to 2$，挖掘了 $2$ 号宝藏。开发了道路 $1 \\to 3$，挖掘了 $3$ 号宝藏。还开发了道路 $1 \\to 4$，挖掘了 $4$ 号宝藏。\n\n工程总代价为 $1 \\times 1 + 3 \\times 1 + 1 \\times 1  = 5$。\n\n\n【数据规模与约定】\n\n对于 $ 20\\%$ 的数据： 保证输入是一棵树，$1 \\le n \\le 8$，$v \\le 5\\times 10^3$ 且所有的 $v$ 都相等。\n\n对于 $40\\%$ 的数据： $1 \\le n \\le 8$，$0 \\le m \\le 10^3$，$v \\le 5\\times 10^3$ 且所有的 $v$ 都相等。\n\n对于 $ 70\\%$ 的数据： $1 \\le n \\le 8$，$0 \\le m \\le 10^3$，$v \\le  5\\times 10^3$。\n\n对于 $ 100\\%$ 的数据： $1 \\le n \\le 12$，$0 \\le m \\le 10^3$，$v \\le  5\\times 10^5$。\n\n---\n\n$\\text{upd 2022.7.27}$：新增加 $50$ 组 Hack 数据。", "locale": "zh-CN"}}}
{"pid": "P3960", "type": "P", "difficulty": 6, "samples": [["2 2 3 \n1 1 \n2 2 \n1 2 ", "1\n1\n4\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "线段树", "二分", "平衡树", "树状数组", "NOIP 提高组", "离线处理"], "title": "[NOIP 2017 提高组] 列队", "background": "NOIP2017 D2T3", "description": "Sylvia 是一个热爱学习的女孩子。\n\n前段时间，Sylvia 参加了学校的军训。众所周知，军训的时候需要站方阵。\n\nSylvia 所在的方阵中有 $n \\times m$ 名学生，方阵的行数为 $n$，列数为 $m$。\n\n为了便于管理，教官在训练开始时，按照从前到后，从左到右的顺序给方阵中 的学生从 $1$ 到 $n \\times m$ 编上了号码（参见后面的样例）。即：初始时，第 $i$ 行第 $j$ 列的学生的编号是 $(i-1)\\times m + j$。\n\n然而在练习方阵的时候，经常会有学生因为各种各样的事情需要离队。在一天 中，一共发生了 $q$ 件这样的离队事件。每一次离队事件可以用数对 $(x,y) (1 \\le x \\le n, 1 \\le y \\le m)$ 描述，表示第 $x$ 行第 $y$ 列的学生离队。\n\n在有学生离队后，队伍中出现了一个空位。为了队伍的整齐，教官会依次下达这样的两条指令：\n\n\n1. 向左看齐。这时第一列保持不动，所有学生向左填补空缺。不难发现在这条指令之后，空位在第 $x$ 行第 $m$ 列。\n2. 向前看齐。这时第一行保持不动，所有学生向前填补空缺。不难发现在这条指令之后，空位在第 $n$ 行第 $m$ 列。\n\n\n教官规定不能有两个或更多学生同时离队。即在前一个离队的学生归队之后， 下一个学生才能离队。因此在每一个离队的学生要归队时，队伍中有且仅有第 $n$ 行第 $m$ 列一个空位，这时这个学生会自然地填补到这个位置。\n\n因为站方阵真的很无聊，所以 Sylvia 想要计算每一次离队事件中，离队的同学的编号是多少。\n\n注意：每一个同学的编号不会随着离队事件的发生而改变，在发生离队事件后方阵中同学的编号可能是乱序的。", "inputFormat": "输入共 $q+1$ 行。\n\n第一行包含 $3$ 个用空格分隔的正整数 $n, m, q$，表示方阵大小是 $n$ 行 $m$ 列，一共发生了 $q$ 次事件。\n\n接下来 $q$ 行按照事件发生顺序描述了 $q$ 件事件。每一行是两个整数 $x, y$，用一个空格分隔，表示这个离队事件中离队的学生当时排在第 $x$ 行第 $y$ 列。", "outputFormat": "按照事件输入的顺序，每一个事件输出一行一个整数，表示这个离队事件中离队学生的编号。", "hint": "【输入输出样例 $1$ 说明】\n\n$$\\begin{matrix}\n\\begin{bmatrix}\n1 & 2 \\\\\n3 & 4 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n & 2 \\\\\n3 & 4 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 &  \\\\\n3 & 4 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 4 \\\\\n3 &  \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 4 \\\\\n3 & 1 \\\\\n\\end{bmatrix} \\\\[1em]\n\\begin{bmatrix}\n2 & 4 \\\\\n3 & 1 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 4 \\\\\n3 &  \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 4 \\\\\n3 &  \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 4 \\\\\n3 &  \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 4 \\\\\n3 & 1 \\\\\n\\end{bmatrix}\\\\[1em]\n\\begin{bmatrix}\n2 & 4 \\\\\n3 & 1 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 &  \\\\\n3 & 1 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 &  \\\\\n3 & 1 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 1 \\\\\n3 &  \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 1 \\\\\n3 & 4 \\\\\n\\end{bmatrix}\n\\end{matrix}$$\n\n列队的过程如上图所示，每一行描述了一个事件。在第一个事件中，编号为 $1$ 的同学离队，这时空位在第一行第一列。接着所有同学向左标齐，这时编号为 $2$ 的同学向左移动一步，空位移动到第一行第二列。然后所有同学向上标齐，这时编号为 $4$ 的同学向上一步，这时空位移动到第二行第二列。最后编号为 $1$ 的同学返回填补到空位中。\n\n**【数据规模与约定】**\n\n| 测试点编号 | $n$ | $m$ | $q$ | 其他约定 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1\\sim 6$ | $\\le 10^3$ | $\\le 10^3$ | $\\le 500$ | 无 |\n| $7\\sim 10$ | $\\le 5\\times 10^4$ | $\\le 5\\times 10^4$ | $\\le 500$ | 无 |\n| $11\\sim 12$ | $=1$ | $\\le 10^5$ | $\\le 10^5$ | 所有事件 $x=1$ |\n| $13\\sim 14$ | $=1$ | $\\le 3\\times 10^5$ | $\\le 3\\times 10^5$ | 所有事件 $x=1$ |\n| $15\\sim 16$ | $\\le 3\\times 10^5$ | $\\le 3\\times 10^5$ | $\\le 3\\times 10^5$ | 所有事件 $x=1$ |\n| $17\\sim 18$ | $\\le 10^5$ | $\\le 10^5$ | $\\le 10^5$ | 无 |\n| $19\\sim 20$ | $\\le 3\\times 10^5$ | $\\le 3\\times 10^5$ | $\\le 3\\times 10^5$ | 无 |\n\n数据保证每一个事件满足 $1 \\le x \\le n,1 \\le y \\le m$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2017 Senior] Lineup", "background": "NOIP 2017 D2T3.", "description": "Sylvia is a girl who loves studying.\n\nSome time ago, Sylvia took part in the school’s military training. As is well known, during training they must stand in a square formation.\n\nThere are $n \\times m$ students in Sylvia’s formation, with $n$ rows and $m$ columns.\n\nFor convenience, at the beginning of training, the instructor numbers the students from $1$ to $n \\times m$ in order from front to back and from left to right (see the example below). That is: initially, the student at row $i$, column $j$ has ID $(i-1)\\times m + j$.\n\nHowever, during the formation drills, students often need to leave the formation for various reasons. In one day, there are $q$ such leave events. Each leave event is described by a pair $(x, y)$ ($1 \\le x \\le n, 1 \\le y \\le m$), meaning the student at row $x$, column $y$ leaves.\n\nAfter a student leaves, an empty spot appears. To keep the formation tidy, the instructor issues the following two commands in order:\n\n1. Align left. The first column remains still, and all students shift left to fill the gap. It is easy to see that after this command, the empty spot is at row $x$, column $m$.\n2. Align forward. The first row remains still, and all students shift forward to fill the gap. It is easy to see that after this command, the empty spot is at row $n$, column $m$.\n\nThe instructor stipulates that no two or more students may leave at the same time. That is, after the previously departed student has returned, the next student may leave. Therefore, when each departed student is to return, there is exactly one empty spot at row $n$, column $m$, and the student naturally fills that position.\n\nBecause standing in formation is really boring, Sylvia wants to compute, for each leave event, the ID number of the student who leaves.\n\nNote: A student’s ID never changes due to leave events, though the order of IDs in the formation may become scrambled after events.", "inputFormat": "The input consists of $q+1$ lines.\n\nThe first line contains $3$ positive integers $n$, $m$, and $q$, separated by spaces, indicating a formation of $n$ rows and $m$ columns, with a total of $q$ events.\n\nThe next $q$ lines describe the $q$ events in the order they occur. Each line contains two integers $x, y$, separated by a space, indicating that in this leave event, the student currently at row $x$, column $y$ leaves.", "outputFormat": "For each event, in the input order, output one line with a single integer: the ID of the student who leaves in that event.", "hint": "【Explanation for Sample Input/Output $1$】\n\n$$\\begin{matrix}\n\\begin{bmatrix}\n1 & 2 \\\\\n3 & 4 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n & 2 \\\\\n3 & 4 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 &  \\\\\n3 & 4 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 4 \\\\\n3 &  \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 4 \\\\\n3 & 1 \\\\\n\\end{bmatrix} \\\\[1em]\n\\begin{bmatrix}\n2 & 4 \\\\\n3 & 1 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 4 \\\\\n3 &  \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 4 \\\\\n3 &  \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 4 \\\\\n3 &  \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 4 \\\\\n3 & 1 \\\\\n\\end{bmatrix}\\\\[1em]\n\\begin{bmatrix}\n2 & 4 \\\\\n3 & 1 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 &  \\\\\n3 & 1 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 &  \\\\\n3 & 1 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 1 \\\\\n3 &  \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 1 \\\\\n3 & 4 \\\\\n\\end{bmatrix}\n\\end{matrix}$$\n\nThe lineup process is shown above, with each row describing one event. In the first event, the student with ID $1$ leaves, so the empty spot is at row $1$, column $1$. Next, everyone aligns left; the student with ID $2$ moves one step left, and the empty spot moves to row $1$, column $2$. Then everyone aligns forward; the student with ID $4$ moves one step up, and the empty spot moves to row $2$, column $2$. Finally, the student with ID $1$ returns and fills the empty spot.\n\n【Constraints and Notes】\n\n| Test point ID | $n$ | $m$ | $q$ | Other notes |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1\\sim 6$ | $\\le 10^3$ | $\\le 10^3$ | $\\le 500$ | None |\n| $7\\sim 10$ | $\\le 5\\times 10^4$ | $\\le 5\\times 10^4$ | $\\le 500$ | None |\n| $11\\sim 12$ | $=1$ | $\\le 10^5$ | $\\le 10^5$ | All events have $x=1$ |\n| $13\\sim 14$ | $=1$ | $\\le 3\\times 10^5$ | $\\le 3\\times 10^5$ | All events have $x=1$ |\n| $15\\sim 16$ | $\\le 3\\times 10^5$ | $\\le 3\\times 10^5$ | $\\le 3\\times 10^5$ | All events have $x=1$ |\n| $17\\sim 18$ | $\\le 10^5$ | $\\le 10^5$ | $\\le 10^5$ | None |\n| $19\\sim 20$ | $\\le 3\\times 10^5$ | $\\le 3\\times 10^5$ | $\\le 3\\times 10^5$ | None |\n\nThe testdata guarantees that each event satisfies $1 \\le x \\le n,1 \\le y \\le m$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2017 提高组] 列队", "background": "NOIP2017 D2T3", "description": "Sylvia 是一个热爱学习的女孩子。\n\n前段时间，Sylvia 参加了学校的军训。众所周知，军训的时候需要站方阵。\n\nSylvia 所在的方阵中有 $n \\times m$ 名学生，方阵的行数为 $n$，列数为 $m$。\n\n为了便于管理，教官在训练开始时，按照从前到后，从左到右的顺序给方阵中 的学生从 $1$ 到 $n \\times m$ 编上了号码（参见后面的样例）。即：初始时，第 $i$ 行第 $j$ 列的学生的编号是 $(i-1)\\times m + j$。\n\n然而在练习方阵的时候，经常会有学生因为各种各样的事情需要离队。在一天 中，一共发生了 $q$ 件这样的离队事件。每一次离队事件可以用数对 $(x,y) (1 \\le x \\le n, 1 \\le y \\le m)$ 描述，表示第 $x$ 行第 $y$ 列的学生离队。\n\n在有学生离队后，队伍中出现了一个空位。为了队伍的整齐，教官会依次下达这样的两条指令：\n\n\n1. 向左看齐。这时第一列保持不动，所有学生向左填补空缺。不难发现在这条指令之后，空位在第 $x$ 行第 $m$ 列。\n2. 向前看齐。这时第一行保持不动，所有学生向前填补空缺。不难发现在这条指令之后，空位在第 $n$ 行第 $m$ 列。\n\n\n教官规定不能有两个或更多学生同时离队。即在前一个离队的学生归队之后， 下一个学生才能离队。因此在每一个离队的学生要归队时，队伍中有且仅有第 $n$ 行第 $m$ 列一个空位，这时这个学生会自然地填补到这个位置。\n\n因为站方阵真的很无聊，所以 Sylvia 想要计算每一次离队事件中，离队的同学的编号是多少。\n\n注意：每一个同学的编号不会随着离队事件的发生而改变，在发生离队事件后方阵中同学的编号可能是乱序的。", "inputFormat": "输入共 $q+1$ 行。\n\n第一行包含 $3$ 个用空格分隔的正整数 $n, m, q$，表示方阵大小是 $n$ 行 $m$ 列，一共发生了 $q$ 次事件。\n\n接下来 $q$ 行按照事件发生顺序描述了 $q$ 件事件。每一行是两个整数 $x, y$，用一个空格分隔，表示这个离队事件中离队的学生当时排在第 $x$ 行第 $y$ 列。", "outputFormat": "按照事件输入的顺序，每一个事件输出一行一个整数，表示这个离队事件中离队学生的编号。", "hint": "【输入输出样例 $1$ 说明】\n\n$$\\begin{matrix}\n\\begin{bmatrix}\n1 & 2 \\\\\n3 & 4 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n & 2 \\\\\n3 & 4 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 &  \\\\\n3 & 4 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 4 \\\\\n3 &  \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 4 \\\\\n3 & 1 \\\\\n\\end{bmatrix} \\\\[1em]\n\\begin{bmatrix}\n2 & 4 \\\\\n3 & 1 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 4 \\\\\n3 &  \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 4 \\\\\n3 &  \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 4 \\\\\n3 &  \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 4 \\\\\n3 & 1 \\\\\n\\end{bmatrix}\\\\[1em]\n\\begin{bmatrix}\n2 & 4 \\\\\n3 & 1 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 &  \\\\\n3 & 1 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 &  \\\\\n3 & 1 \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 1 \\\\\n3 &  \\\\\n\\end{bmatrix} & \\Rightarrow & \n\\begin{bmatrix}\n2 & 1 \\\\\n3 & 4 \\\\\n\\end{bmatrix}\n\\end{matrix}$$\n\n列队的过程如上图所示，每一行描述了一个事件。在第一个事件中，编号为 $1$ 的同学离队，这时空位在第一行第一列。接着所有同学向左标齐，这时编号为 $2$ 的同学向左移动一步，空位移动到第一行第二列。然后所有同学向上标齐，这时编号为 $4$ 的同学向上一步，这时空位移动到第二行第二列。最后编号为 $1$ 的同学返回填补到空位中。\n\n**【数据规模与约定】**\n\n| 测试点编号 | $n$ | $m$ | $q$ | 其他约定 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1\\sim 6$ | $\\le 10^3$ | $\\le 10^3$ | $\\le 500$ | 无 |\n| $7\\sim 10$ | $\\le 5\\times 10^4$ | $\\le 5\\times 10^4$ | $\\le 500$ | 无 |\n| $11\\sim 12$ | $=1$ | $\\le 10^5$ | $\\le 10^5$ | 所有事件 $x=1$ |\n| $13\\sim 14$ | $=1$ | $\\le 3\\times 10^5$ | $\\le 3\\times 10^5$ | 所有事件 $x=1$ |\n| $15\\sim 16$ | $\\le 3\\times 10^5$ | $\\le 3\\times 10^5$ | $\\le 3\\times 10^5$ | 所有事件 $x=1$ |\n| $17\\sim 18$ | $\\le 10^5$ | $\\le 10^5$ | $\\le 10^5$ | 无 |\n| $19\\sim 20$ | $\\le 3\\times 10^5$ | $\\le 3\\times 10^5$ | $\\le 3\\times 10^5$ | 无 |\n\n数据保证每一个事件满足 $1 \\le x \\le n,1 \\le y \\le m$。", "locale": "zh-CN"}}}
{"pid": "P3961", "type": "P", "difficulty": 5, "samples": [["3 10\n1 1 1 1\n2 2 2 2\n1 3 15 9", "3"], ["3 10\n1 1 13 1\n2 2 2 2\n1 3 4 7", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "各省省选", "排序", "背包 DP", "图论建模", "天津"], "title": "[TJOI2013] 黄金矿工", "background": "", "description": "小 A 最近迷上了在上课时玩《黄金矿工》这款游戏。为了避免被老师发现，他必须小心翼翼，因此他总是输。\n\n在输掉自己所有的金币后，他向你求助。每个黄金可以看做一个点（没有体积）。现在给出你 $N$ 个黄金的坐标，挖到它们所需要的时间以及它们的价值。有些黄金在同一条直线上，这时候你必须按顺序挖。你可以瞬间把钩子转到任意角度。\n\n小 A 一开始在坐标 $(0,0)$，请你帮助小 A 算出在时间 $T$ 内他最多可以得到多少价值的金子。", "inputFormat": "第一行两个整数 $N$ 和 $T$，表示黄金的个数和总时间。\n\n接下来 $N$ 行，每行四个整数 $x$、$y$、$t$、$v$，分别表示黄金的坐标，挖到这个黄金的时间，以及这个黄金的价值。", "outputFormat": "一个整数,表示你可以在 $T$ 时间内得到的最大价值。", "hint": "- 对于 $30\\%$ 的数据，$0<T\\le 4\\times 10^3$；\n- 对于 $100\\%$ 的数据，$1\\le N\\le 200$，$0<T\\le 4\\times 10^4$。\n\n保证 $0\\le|x|\\le 200$，$0<y≤200$，$0<t\\le 200$，$0\\le v\\le 200$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2013] Gold Miner", "background": "", "description": "Recently, Xiao A became obsessed with playing the game “Gold Miner” during class. To avoid being noticed by the teacher, he has to be very cautious, so he always loses.\n\nAfter losing all his coins, he asks you for help. Each piece of gold can be regarded as a point (no volume). You are given the coordinates of $N$ pieces of gold, the time required to mine each, and their value. Some pieces of gold lie on the same straight line; in that case, you must mine them in order. You can instantly rotate the hook to any angle.\n\nXiao A starts at coordinate $(0, 0)$. Please help Xiao A compute the maximum total value he can obtain within time $T$.", "inputFormat": "The first line contains two integers $N$ and $T$, the number of gold pieces and the total time.\n\nThe next $N$ lines each contain four integers $x$, $y$, $t$, $v$, denoting the coordinates of a piece of gold, the time to mine it, and its value.", "outputFormat": "Output a single integer, the maximum total value obtainable within time $T$.", "hint": "- For $30\\%$ of the testdata, $0 < T \\le 4 \\times 10^3$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 200$, $0 < T \\le 4 \\times 10^4$.\n\nIt is guaranteed that $0 \\le |x| \\le 200$, $0 < y \\le 200$, $0 < t \\le 200$, $0 \\le v \\le 200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2013] 黄金矿工", "background": "", "description": "小 A 最近迷上了在上课时玩《黄金矿工》这款游戏。为了避免被老师发现，他必须小心翼翼，因此他总是输。\n\n在输掉自己所有的金币后，他向你求助。每个黄金可以看做一个点（没有体积）。现在给出你 $N$ 个黄金的坐标，挖到它们所需要的时间以及它们的价值。有些黄金在同一条直线上，这时候你必须按顺序挖。你可以瞬间把钩子转到任意角度。\n\n小 A 一开始在坐标 $(0,0)$，请你帮助小 A 算出在时间 $T$ 内他最多可以得到多少价值的金子。", "inputFormat": "第一行两个整数 $N$ 和 $T$，表示黄金的个数和总时间。\n\n接下来 $N$ 行，每行四个整数 $x$、$y$、$t$、$v$，分别表示黄金的坐标，挖到这个黄金的时间，以及这个黄金的价值。", "outputFormat": "一个整数,表示你可以在 $T$ 时间内得到的最大价值。", "hint": "- 对于 $30\\%$ 的数据，$0<T\\le 4\\times 10^3$；\n- 对于 $100\\%$ 的数据，$1\\le N\\le 200$，$0<T\\le 4\\times 10^4$。\n\n保证 $0\\le|x|\\le 200$，$0<y≤200$，$0<t\\le 200$，$0\\le v\\le 200$。", "locale": "zh-CN"}}}
{"pid": "P3962", "type": "P", "difficulty": 6, "samples": [["5\n101 240 331 4 52\n3\n1 3\n4 5\n1 5", "8 7 6 4 2\n7 4 2 -1 -1\n9 8 7 6 4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "各省省选", "天津"], "title": "[TJOI2013] 数字根", "background": "", "description": "一个数字的数字根定义为:这个数字每一位的数字加起来求和,反复这个过程直到和小于10。例如,64357的数字跟为7,因为6+4+3+5+7=25,2+5=7个区间的数字根定义为这个区间所有数字和的数字根。\n\n给定一个序列A1,A2,A3,…,An,你需要回答一些询问。每一个询问给定个区间[L,R],求出这个区间所有连续子区间里最大的前5个不同的数字根，不够5个的用-1补全\n", "inputFormat": "第一行一个整数N,表示序列的长度。第二行是N个整数Ai(0≤Ai<10^9)。第三行是一个整数Q表示询问次数。接下来Q行,每一行两个正整数1,r,表示询问区间。(1≤l≤r≤N)\n", "outputFormat": "Q行,表示每一个查询区间所有连续子区间里最大的前5个不同的数字根,按降序输出,输出用空格隔开。\n", "hint": "### 样例解释\n\n第一个查询区间[1,3],它的连续子区间有[1,1],[2,2],[3,3],[1,2],[2,3],[1,3].可对应的数字根分别为2,6,7,8,4,6。所以最大的5个是8,7,6,4,2。\n\n### 数据范围\n\n30%的数据，N ≤ 1000; Q ≤ 1000\n\n100%的数据，N ≤ 100000; Q ≤ 100000\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2013] Digital Root", "background": "", "description": "The digital root of a number is defined as repeatedly summing its digits until the result is less than 10. For example, the digital root of 64357 is 7, because $6 + 4 + 3 + 5 + 7 = 25$, and $2 + 5 = 7$. The digital root of an interval is defined as the digital root of the sum of all numbers in that interval.\n\nGiven a sequence $A_1, A_2, A_3, \\ldots, A_n$, you need to answer several queries. For each query, you are given an interval $[l, r]$. Among all contiguous subintervals within $[l, r]$, find the top 5 distinct digital roots. If there are fewer than 5, fill the remaining positions with $-1$.", "inputFormat": "- The first line contains an integer $N$, the length of the sequence.\n- The second line contains $N$ integers $A_i$ ($0 \\le A_i < 10^9$).\n- The third line contains an integer $Q$, the number of queries.\n- Each of the next $Q$ lines contains two integers $l, r$ ($1 \\le l \\le r \\le N$), denoting a query interval.", "outputFormat": "Output $Q$ lines. For each query interval, output the top 5 distinct digital roots of all its contiguous subintervals in descending order, space-separated. If there are fewer than 5, pad with $-1$.", "hint": "### Sample Explanation\n\nFor the first query interval $[1, 3]$, its contiguous subintervals are $[1, 1]$, $[2, 2]$, $[3, 3]$, $[1, 2]$, $[2, 3]$, $[1, 3]$. Their corresponding digital roots are $2, 6, 7, 8, 4, 6$. Therefore, the top 5 are $8, 7, 6, 4, 2$.\n\n### Constraints\n\n- 30% of the testdata: $N \\le 1000$, $Q \\le 1000$.\n- 100% of the testdata: $N \\le 100000$, $Q \\le 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2013] 数字根", "background": "", "description": "一个数字的数字根定义为:这个数字每一位的数字加起来求和,反复这个过程直到和小于10。例如,64357的数字跟为7,因为6+4+3+5+7=25,2+5=7个区间的数字根定义为这个区间所有数字和的数字根。\n\n给定一个序列A1,A2,A3,…,An,你需要回答一些询问。每一个询问给定个区间[L,R],求出这个区间所有连续子区间里最大的前5个不同的数字根，不够5个的用-1补全\n", "inputFormat": "第一行一个整数N,表示序列的长度。第二行是N个整数Ai(0≤Ai<10^9)。第三行是一个整数Q表示询问次数。接下来Q行,每一行两个正整数1,r,表示询问区间。(1≤l≤r≤N)\n", "outputFormat": "Q行,表示每一个查询区间所有连续子区间里最大的前5个不同的数字根,按降序输出,输出用空格隔开。\n", "hint": "### 样例解释\n\n第一个查询区间[1,3],它的连续子区间有[1,1],[2,2],[3,3],[1,2],[2,3],[1,3].可对应的数字根分别为2,6,7,8,4,6。所以最大的5个是8,7,6,4,2。\n\n### 数据范围\n\n30%的数据，N ≤ 1000; Q ≤ 1000\n\n100%的数据，N ≤ 100000; Q ≤ 100000\n", "locale": "zh-CN"}}}
{"pid": "P3963", "type": "P", "difficulty": 5, "samples": [["3 5 70\n30 25\n50 21\n20 20\n5 18\n35 30\n", "35"], ["5 6 9\n4 0\n4 1\n6 3\n8 0\n10 4\n10 5\n", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2013", "二分", "各省省选", "堆", "枚举", "优先队列", "可持久化线段树", "天津"], "title": "[TJOI2013] 奖学金", "background": "小张最近发表了一篇论文，有一个神秘人物要给小张学院发奖学金。", "description": "小张学院有 $c$ 名学生，第 $i$ 名学生的成绩为 $a_i$，要获得的奖学金金额为 $b_i$。  \n要从这 $c$ 名学生中挑出 $n$ 名学生发奖学金。这个神秘人物爱好奇特，他希望得到奖学金的同学的**成绩**的**中位数**尽可能大，但同时，他们的**奖学金总额**不能超过 $f$。\n", "inputFormat": "第一行有三个整数，分别表示要挑出的学生人数 $n$，学生总人数 $c$ 和奖学金总额的最大值 $f$，**保证 $n$ 为奇数**。  \n\n第 $2$ 到第 $(c + 1)$ 行，每行两个整数，第 $(i + 1)$ 行的整数依次表示第 $i$ 名学生的成绩 $a_i$ 和如果要给他发奖学金，则需要发的金额数 $b_i$。", "outputFormat": "输出一行一个整数表示答案。如果无法满足神秘人的条件，请输出 $-1$。", "hint": "### 样例 1 解释\n\n选择成绩为 $5$，$35$，$50$ 的三名同学，奖金总额为 $18 + 30 + 21 = 69$。\n\n### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\leq 10^3$，$c \\leq 2 \\times 10^3$。\n- 对于 $100\\%$ 的数据，保证 $3 \\leq n  \\leq 10^5$，$n \\leq c \\leq 2 \\times 10^5$，$0 \\leq f \\leq 2\\times 10^9$，$0 \\leq a_i \\leq 2 \\times 10^9$，$0 \\leq b_i \\leq 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2013] Scholarship", "background": "Xiao Zhang recently published a paper, and a mysterious person wants to award scholarships to Xiao Zhang's college.", "description": "There are $c$ students in Xiao Zhang's college. The $i$-th student's score is $a_i$, and the scholarship amount they would receive is $b_i$.  \nYou need to select $n$ students from these $c$ students to award scholarships. This mysterious person has a peculiar preference: he wants the median of the scores of the students who receive scholarships to be as large as possible, while their total scholarship amount must not exceed $f$.", "inputFormat": "The first line contains three integers, representing the number of students to select $n$, the total number of students $c$, and the maximum total scholarship amount $f$, **guaranteeing that $n$ is odd**.  \n\nLines $2$ through $(c + 1)$: each line contains two integers. The $(i + 1)$-th line contains the $i$-th student's score $a_i$ and, if they are awarded a scholarship, the amount $b_i$ that needs to be given.", "outputFormat": "Output one integer on a single line representing the answer. If the mysterious person's conditions cannot be met, output $-1$.", "hint": "### Sample 1 Explanation\n\nSelect three students with scores $5$, $35$, and $50$, with a total scholarship amount of $18 + 30 + 21 = 69$.\n\n### Constraints\n\n- For $30\\%$ of the testdata, it is guaranteed that $n \\leq 10^3$, $c \\leq 2 \\times 10^3$.\n- For $100\\%$ of the testdata, it is guaranteed that $3 \\leq n \\leq 10^5$, $n \\leq c \\leq 2 \\times 10^5$, $0 \\leq f \\leq 2 \\times 10^9$, $0 \\leq a_i \\leq 2 \\times 10^9$, $0 \\leq b_i \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2013] 奖学金", "background": "小张最近发表了一篇论文，有一个神秘人物要给小张学院发奖学金。", "description": "小张学院有 $c$ 名学生，第 $i$ 名学生的成绩为 $a_i$，要获得的奖学金金额为 $b_i$。  \n要从这 $c$ 名学生中挑出 $n$ 名学生发奖学金。这个神秘人物爱好奇特，他希望得到奖学金的同学的**成绩**的**中位数**尽可能大，但同时，他们的**奖学金总额**不能超过 $f$。\n", "inputFormat": "第一行有三个整数，分别表示要挑出的学生人数 $n$，学生总人数 $c$ 和奖学金总额的最大值 $f$，**保证 $n$ 为奇数**。  \n\n第 $2$ 到第 $(c + 1)$ 行，每行两个整数，第 $(i + 1)$ 行的整数依次表示第 $i$ 名学生的成绩 $a_i$ 和如果要给他发奖学金，则需要发的金额数 $b_i$。", "outputFormat": "输出一行一个整数表示答案。如果无法满足神秘人的条件，请输出 $-1$。", "hint": "### 样例 1 解释\n\n选择成绩为 $5$，$35$，$50$ 的三名同学，奖金总额为 $18 + 30 + 21 = 69$。\n\n### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\leq 10^3$，$c \\leq 2 \\times 10^3$。\n- 对于 $100\\%$ 的数据，保证 $3 \\leq n  \\leq 10^5$，$n \\leq c \\leq 2 \\times 10^5$，$0 \\leq f \\leq 2\\times 10^9$，$0 \\leq a_i \\leq 2 \\times 10^9$，$0 \\leq b_i \\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3964", "type": "P", "difficulty": 5, "samples": [["6\n-4 -1\n-1 -2\n2 -4\n0 2\n0 3\n5 -2", "20"], ["6\n0 0\n2 0\n-5 -2\n2 -2\n-1 2\n4 0", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "各省省选", "枚举", "前缀和", "天津"], "title": "[TJOI2013] 松鼠聚会", "background": "", "description": "草原上住着一群小松鼠，每个小松鼠都有一个家。时间长了，大家觉得应该聚一聚。但是草原非常大，松鼠们都很头疼应该在谁家聚会才最合理。\n\n每个小松鼠的家可以用一个点 $(x,y)$ 表示,两个点的距离定义为点 $(x,y)$ 和它周围的 $8$ 个点 $(x-1,y)$，$(x+1,y)$，$(x,y-1)$，$(x,y+1)$，$(x-1,y+1)$，$(x-1,y-1)$，$(x+1,y+1)$，$(x+1,y-1)$ 距离为 $1$。\n", "inputFormat": "第一行是一个整数 $N$，表示有多少只松鼠。接下来 $N$ 行，第 $i$ 行是两个整数 $x$ 和 $y$，表示松鼠 $i$ 的家的坐标。", "outputFormat": "一个整数，表示松鼠为了聚会走的路程和最小是多少。\n", "hint": "### 样例解释\n\n在第一个样例中，松鼠在第二只松鼠家 $(-1,-2)$ 聚会；在第二个样例中，松鼠在第一只松鼠家 $(0,0)$ 聚会。\n\n### 数据范围\n\n- $30\\%$ 的数据，$0\\le N \\le 1000$；\n- $100\\%$ 的数据，$0\\le N \\le 10^5$，$-10^9 \\le x, y \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2013] Squirrel Gathering", "background": "", "description": "A group of little squirrels lives on the prairie, and each squirrel has a home. After a long time, they feel they should have a gathering. However, the prairie is very large, and they are troubled about whose home would be the most reasonable place to meet.\n\nEach squirrel’s home is represented by a point $(x,y)$. The distance between two points is defined so that the distance between point $(x,y)$ and each of its eight neighbors $(x-1,y)$, $(x+1,y)$, $(x,y-1)$, $(x,y+1)$, $(x-1,y+1)$, $(x-1,y-1)$, $(x+1,y+1)$, $(x+1,y-1)$ is $1$.", "inputFormat": "The first line contains an integer $N$, the number of squirrels. The next $N$ lines, the $i$-th line contains two integers $x$ and $y$, the coordinates of squirrel $i$’s home.", "outputFormat": "Output a single integer, the minimum possible sum of distances the squirrels need to travel to gather.", "hint": "### Sample Explanation\n\nIn the first sample, the squirrels gather at the second squirrel’s home $(-1,-2)$; in the second sample, they gather at the first squirrel’s home $(0,0)$.\n\n### Constraints\n\n- For $30\\%$ of the testdata, $0 \\le N \\le 1000$.\n- For $100\\%$ of the testdata, $0 \\le N \\le 10^5$, $-10^9 \\le x, y \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2013] 松鼠聚会", "background": "", "description": "草原上住着一群小松鼠，每个小松鼠都有一个家。时间长了，大家觉得应该聚一聚。但是草原非常大，松鼠们都很头疼应该在谁家聚会才最合理。\n\n每个小松鼠的家可以用一个点 $(x,y)$ 表示,两个点的距离定义为点 $(x,y)$ 和它周围的 $8$ 个点 $(x-1,y)$，$(x+1,y)$，$(x,y-1)$，$(x,y+1)$，$(x-1,y+1)$，$(x-1,y-1)$，$(x+1,y+1)$，$(x+1,y-1)$ 距离为 $1$。\n", "inputFormat": "第一行是一个整数 $N$，表示有多少只松鼠。接下来 $N$ 行，第 $i$ 行是两个整数 $x$ 和 $y$，表示松鼠 $i$ 的家的坐标。", "outputFormat": "一个整数，表示松鼠为了聚会走的路程和最小是多少。\n", "hint": "### 样例解释\n\n在第一个样例中，松鼠在第二只松鼠家 $(-1,-2)$ 聚会；在第二个样例中，松鼠在第一只松鼠家 $(0,0)$ 聚会。\n\n### 数据范围\n\n- $30\\%$ 的数据，$0\\le N \\le 1000$；\n- $100\\%$ 的数据，$0\\le N \\le 10^5$，$-10^9 \\le x, y \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3965", "type": "P", "difficulty": 6, "samples": [["4 4\nRRRD\nURDD\nUULD\nULLL", "0"], ["3 4\nRRRD\nURLL\nLRRR", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "各省省选", "图论建模", "费用流", "天津"], "title": "[TJOI2013] 循环格", "background": "一个循环格就是一个矩阵,其中所有元素为箭头,指向相邻四个格子。每个元素有一个坐标(行,列),其中左上角元素坐标为(0,0)。给定一个起始位(r,c),你可以沿着箭头方向在格子间行走。即:如果(r,c)是一个左箭头，那么走到(r,c-1);如果是一个右箭头,走到(r,c+1);如果是上箭头,走到(r-1,c);如果是下箭头,走到(r+1,c)。每一行和每一列都是循环的,即如果走出边界,你会出现在另一侧。比如在一个5\\*5的循环格里,从(3,0)向左走会出现在(3,4)。\n", "description": "一个完美的循环格是这样定义的:对于任意一个起始位置,你都可以沿着箭头最终回到起始位置。如果一个循环格不满足完美,你可以随意修改任意一个元素的箭头直到完美。例如下图,左边不是一个完美的循环格,因为只有从(1,1),(1,2),(2,0),(2,3)出发才会回到起始位置。通过修改其中两个箭头,可以得到右图,一个完美的循环格。\n\n ![](https://cdn.luogu.com.cn/upload/pic/10987.png) \n\n给定一个循环格,你需要计算最少需要修改多少个元素使其完美。\n", "inputFormat": "第一行两个整数R和C,表示循环格的行和列。接下来R行,每一行包含C个字符LRUD表示左右上下\n", "outputFormat": "一个整数,表示最少需要修改多少个元素使得给定的循环格完美。\n", "hint": "### 数据范围\n\n30%的数据，1 ≤ R, C ≤ 7\n\n100%的数据，1 ≤ R, C ≤ 15\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2013] Cyclic Grid", "background": "A cyclic grid is a matrix in which every cell contains an arrow pointing to one of its four adjacent cells. Each cell has coordinates $(r, c)$, with the top-left cell at $(0, 0)$. Given a starting position $(r, c)$, you can move between cells following the arrows: if $(r, c)$ has a left arrow, move to $(r, c - 1)$; if it has a right arrow, move to $(r, c + 1)$; if it has an up arrow, move to $(r - 1, c)$; if it has a down arrow, move to $(r + 1, c)$. Each row and each column is cyclic: if you move out of bounds, you appear on the opposite side. For example, in a $5 \\times 5$ cyclic grid, moving left from $(3, 0)$ will appear at $(3, 4)$.", "description": "A perfect cyclic grid is defined as follows: starting from any position, by following the arrows you will eventually return to the starting position. If a cyclic grid is not perfect, you may arbitrarily modify the arrow in any cell until it becomes perfect. For example, in the figure below, the grid on the left is not perfect, because only starting from $(1, 1)$, $(1, 2)$, $(2, 0)$, $(2, 3)$ will return to the starting position. By modifying two arrows, you obtain the grid on the right, which is perfect.\n\n ![](https://cdn.luogu.com.cn/upload/pic/10987.png) \n\nGiven a cyclic grid, compute the minimum number of cells you need to modify to make it perfect.", "inputFormat": "The first line contains two integers $R$ and $C$, the numbers of rows and columns of the cyclic grid. The next $R$ lines each contain $C$ characters, each being L, R, U, or D, indicating left, right, up, and down.", "outputFormat": "Output a single integer, the minimum number of cells that need to be modified to make the given cyclic grid perfect.", "hint": "### Constraints\n\n30% of the testdata: $1 \\le R, C \\le 7$.\n\n100% of the testdata: $1 \\le R, C \\le 15$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2013] 循环格", "background": "一个循环格就是一个矩阵,其中所有元素为箭头,指向相邻四个格子。每个元素有一个坐标(行,列),其中左上角元素坐标为(0,0)。给定一个起始位(r,c),你可以沿着箭头方向在格子间行走。即:如果(r,c)是一个左箭头，那么走到(r,c-1);如果是一个右箭头,走到(r,c+1);如果是上箭头,走到(r-1,c);如果是下箭头,走到(r+1,c)。每一行和每一列都是循环的,即如果走出边界,你会出现在另一侧。比如在一个5\\*5的循环格里,从(3,0)向左走会出现在(3,4)。\n", "description": "一个完美的循环格是这样定义的:对于任意一个起始位置,你都可以沿着箭头最终回到起始位置。如果一个循环格不满足完美,你可以随意修改任意一个元素的箭头直到完美。例如下图,左边不是一个完美的循环格,因为只有从(1,1),(1,2),(2,0),(2,3)出发才会回到起始位置。通过修改其中两个箭头,可以得到右图,一个完美的循环格。\n\n ![](https://cdn.luogu.com.cn/upload/pic/10987.png) \n\n给定一个循环格,你需要计算最少需要修改多少个元素使其完美。\n", "inputFormat": "第一行两个整数R和C,表示循环格的行和列。接下来R行,每一行包含C个字符LRUD表示左右上下\n", "outputFormat": "一个整数,表示最少需要修改多少个元素使得给定的循环格完美。\n", "hint": "### 数据范围\n\n30%的数据，1 ≤ R, C ≤ 7\n\n100%的数据，1 ≤ R, C ≤ 15\n", "locale": "zh-CN"}}}
{"pid": "P3966", "type": "P", "difficulty": 5, "samples": [["3\na\naa\naaa", "6\n3\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2013", "二分", "各省省选", "AC 自动机", "天津"], "title": "[TJOI2013] 单词", "background": null, "description": "小张最近在忙毕设，所以一直在读论文。一篇论文是由许多单词组成的，但小张发现一个单词会在论文中出现很多次，他想知道每个单词分别在论文中出现了多少次。", "inputFormat": "第一行一个整数 $N$，表示这篇文章有 $N$ 个单词。\n\n接下来 $N$ 行每行一个单词，每个单词都由小写字母 $a\\sim z$ 组成。", "outputFormat": "输出 $N$ 个整数，第 $i$ 行的数表示第 $i$ 个单词在文章中出现了多少次。", "hint": "### 数据规模与约定\n\n- $30\\%$ 的数据，单词总长度不超过 $10^3$。\n- $100\\%$ 的数据，$1 \\leq n \\leq 200$，单词总长度不超过 $10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2013] Word", "background": "", "description": "Xiao Zhang has been busy with his graduation project, so he has been reading papers. A paper is composed of many words, but Xiao Zhang noticed that a word may appear many times in the paper. He wants to know how many times each word appears in the paper.", "inputFormat": "The first line contains an integer $N$, indicating that the article has $N$ words.\n  \nThen the next $N$ lines each contain one word. Each word consists of lowercase letters $a\\sim z$.", "outputFormat": "Output $N$ integers, where the i-th line is the number of times the i-th word appears in the article.", "hint": "### Constraints\n\n- For 30% of the testdata, the total length of all words does not exceed $10^3$.\n- For 100% of the testdata, $1 \\leq N \\leq 200$, and the total length of all words does not exceed $10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2013] 单词", "background": null, "description": "小张最近在忙毕设，所以一直在读论文。一篇论文是由许多单词组成的，但小张发现一个单词会在论文中出现很多次，他想知道每个单词分别在论文中出现了多少次。", "inputFormat": "第一行一个整数 $N$，表示这篇文章有 $N$ 个单词。\n\n接下来 $N$ 行每行一个单词，每个单词都由小写字母 $a\\sim z$ 组成。", "outputFormat": "输出 $N$ 个整数，第 $i$ 行的数表示第 $i$ 个单词在文章中出现了多少次。", "hint": "### 数据规模与约定\n\n- $30\\%$ 的数据，单词总长度不超过 $10^3$。\n- $100\\%$ 的数据，$1 \\leq n \\leq 200$，单词总长度不超过 $10^6$。", "locale": "zh-CN"}}}
{"pid": "P3967", "type": "P", "difficulty": 6, "samples": [["3\n1 1 1\n2 1 1\n1 1 1", "4\n2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "各省省选", "枚举", "二分图", "费用流", "天津"], "title": "[TJOI2014] 匹配", "background": "", "description": "有 $N$ 个单身的男孩和 $N$ 个单身女孩，男孩 $i$ 和女孩 $j$ 在一起得到的幸福值为 $H_{i,j}$。\n\n一个匹配即对这 $N$ 个男孩女孩的安排：每个男孩恰好有一个女朋友，每个女孩恰好有一个男朋友。\n\n一个匹配的幸福值即这 $N$ 对男女朋友的幸福值的和。\n\n经典的问题是计算幸福值最大的匹配，即完美匹配。然而完美匹配有时候并不唯一，你需要计算对于所有的完美匹配，其交集是什么。", "inputFormat": "输入的第一行是一个正整数 $N$ 。\n\n接下来是一个 $N\\times N$ 大小的矩阵 $H$，$H_{i,j}$ 表示男孩 $i$ 和女孩 $j$ 在一起的幸福值。", "outputFormat": "第一行输出完美匹配的幸福值，接下来是若干行，每一行是一对整数 $i$ 和 $j$，表示男孩 $i$ 和女孩 $j$ 在所有完美匹配的交集中，以 $i$ 的递增顺序输出。", "hint": "- 对于 $30\\%$ 的数据，$N \\leq 30$；\n- 对于 $100\\%$ 的数据，$1\\leq N \\leq 80$，$0\\leq H_{i,j}\\leq 5\\times10^3$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2014] Matching", "background": "", "description": "There are $N$ single boys and $N$ single girls. The happiness of pairing boy $i$ with girl $j$ is $H_{i,j}$.\n\nA matching is an arrangement of these $N$ boys and girls such that each boy has exactly one girlfriend and each girl has exactly one boyfriend.\n\nThe happiness of a matching is the sum of the happiness values of these $N$ pairs.\n\nThe classic task is to compute the maximum possible happiness, i.e., a maximum-weight perfect matching (also called an \"assignment\"). However, the maximum-weight perfect matching is not always unique. You need to compute the intersection of all maximum-weight perfect matchings.", "inputFormat": "The first line contains a positive integer $N$.\n\nThen follows an $N \\times N$ matrix $H$, where $H_{i,j}$ denotes the happiness of pairing boy $i$ with girl $j$.", "outputFormat": "On the first line, output the happiness of the maximum-weight perfect matching. Then output several lines, each containing a pair of integers $i$ and $j$, indicating that boy $i$ and girl $j$ appear in the intersection of all maximum-weight perfect matchings, in increasing order of $i$.", "hint": "- For 30% of the testdata, $N \\leq 30$.\n- For 100% of the testdata, $1 \\leq N \\leq 80$, $0 \\leq H_{i,j} \\leq 5 \\times 10^3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2014] 匹配", "background": "", "description": "有 $N$ 个单身的男孩和 $N$ 个单身女孩，男孩 $i$ 和女孩 $j$ 在一起得到的幸福值为 $H_{i,j}$。\n\n一个匹配即对这 $N$ 个男孩女孩的安排：每个男孩恰好有一个女朋友，每个女孩恰好有一个男朋友。\n\n一个匹配的幸福值即这 $N$ 对男女朋友的幸福值的和。\n\n经典的问题是计算幸福值最大的匹配，即完美匹配。然而完美匹配有时候并不唯一，你需要计算对于所有的完美匹配，其交集是什么。", "inputFormat": "输入的第一行是一个正整数 $N$ 。\n\n接下来是一个 $N\\times N$ 大小的矩阵 $H$，$H_{i,j}$ 表示男孩 $i$ 和女孩 $j$ 在一起的幸福值。", "outputFormat": "第一行输出完美匹配的幸福值，接下来是若干行，每一行是一对整数 $i$ 和 $j$，表示男孩 $i$ 和女孩 $j$ 在所有完美匹配的交集中，以 $i$ 的递增顺序输出。", "hint": "- 对于 $30\\%$ 的数据，$N \\leq 30$；\n- 对于 $100\\%$ 的数据，$1\\leq N \\leq 80$，$0\\leq H_{i,j}\\leq 5\\times10^3$。", "locale": "zh-CN"}}}
{"pid": "P3968", "type": "P", "difficulty": 6, "samples": [["7 10\n1\n2\n3\n0 1 2\n0 4 7\n0 2 5\n20\n0 6 6\n99\n0 4 6", "1\n2\n2\n1\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "线段树", "各省省选", "平衡树", "天津"], "title": "[TJOI2014] 电源插排", "background": "", "description": "小 M 的实验室有很多电源插排。这些插排的编号从 $1$ 到 $n$，由左向右排成一排。\n\n每天早晨，这些插排都是没有被使用的。每当一个学生来到实验室，他就将自己的笔记本电源插到某一个未被使用的插排上。\n\n实验室的同学们都很奇怪，他们完成这个过程是这样的：首先，他们找到还没有被使用的插排的最长区间。\n\n如果有多个区间长度相同，他们就选择最靠右的那个。然后将自己的电源插到该区间的中间。\n\n如果区间长度是偶数，他们同样选择靠右的那个。当一个同学离开实验室时,他会将自己的电源拔出来。\n\n数据保证每一个同学来到实验室时，至少有一个空的插排。\n\n需要计算在区间 $[l,r]$ 已经有多少个插排被使用了。", "inputFormat": "第一行是两个整数 $n$ 和 $q$，表示插排数量和询问数量。\n\n接下来 $q$ 行，每一行以一个整数 $k$ 开头。\n\n> 如果 $k$ 为 $0$，接下来就是两个整数 $l$ 和 $r$，表示一个询问。\n>\n> 否则 $k$ 表示表示编号为 $k$ 的学生到来或离开。$k$ 的奇数次出现表示到来，偶数次出现表示离开。每个学生的编号都是唯一的。\n", "outputFormat": "对于每一个询问，输出一个整数，表示询问区间内有多少个插排已经被使用。", "hint": "#### 数据规模与约定\n\n对于 $30\\%$ 的数据，$n \\le 10^5，q \\le 10^3$；\n\n对于 $100\\%$ 的数据，$1\\le n \\le 10^9,1\\le q \\le 10^5,0\\le k \\le 10^9,1\\le l\\le r\\le n$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2014] Power Strip", "background": "", "description": "There are many power strips in Xiao M’s lab. The outlets are indexed from $1$ to $n$, arranged in a line from left to right.\n\nEvery morning, all outlets are unused. Each time a student comes to the lab, they plug their laptop’s power into some unused outlet.\n\nThe students follow a peculiar rule: first, they find the longest contiguous segment of unused outlets.\n\nIf there are multiple segments with the same length, they choose the rightmost one. Then they plug into the middle of that segment.\n\nIf the segment length is even, they pick the right middle position (i.e., the right one). When a student leaves the lab, they unplug their power.\n\nIt is guaranteed that whenever a student arrives, there is at least one empty outlet.\n\nYou need to answer how many outlets are already in use within the interval $[l,r]$.", "inputFormat": "The first line contains two integers $n$ and $q$, the number of outlets and the number of queries.\n\nThen follow $q$ lines. Each line starts with an integer $k$.\n\n> If $k$ is $0$, it is followed by two integers $l$ and $r$, indicating a query.\n>\n> Otherwise, $k$ indicates that the student with ID $k$ arrives or leaves. The $1$st appearance of $k$ means arrival, the $2$nd appearance means departure, and so on. Each student ID is unique.", "outputFormat": "For each query, output one integer: the number of outlets already in use within the query interval.", "hint": "Constraints\n\nFor $30\\%$ of the testdata, $n \\le 10^5, q \\le 10^3$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^9, 1 \\le q \\le 10^5, 0 \\le k \\le 10^9, 1 \\le l \\le r \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2014] 电源插排", "background": "", "description": "小 M 的实验室有很多电源插排。这些插排的编号从 $1$ 到 $n$，由左向右排成一排。\n\n每天早晨，这些插排都是没有被使用的。每当一个学生来到实验室，他就将自己的笔记本电源插到某一个未被使用的插排上。\n\n实验室的同学们都很奇怪，他们完成这个过程是这样的：首先，他们找到还没有被使用的插排的最长区间。\n\n如果有多个区间长度相同，他们就选择最靠右的那个。然后将自己的电源插到该区间的中间。\n\n如果区间长度是偶数，他们同样选择靠右的那个。当一个同学离开实验室时,他会将自己的电源拔出来。\n\n数据保证每一个同学来到实验室时，至少有一个空的插排。\n\n需要计算在区间 $[l,r]$ 已经有多少个插排被使用了。", "inputFormat": "第一行是两个整数 $n$ 和 $q$，表示插排数量和询问数量。\n\n接下来 $q$ 行，每一行以一个整数 $k$ 开头。\n\n> 如果 $k$ 为 $0$，接下来就是两个整数 $l$ 和 $r$，表示一个询问。\n>\n> 否则 $k$ 表示表示编号为 $k$ 的学生到来或离开。$k$ 的奇数次出现表示到来，偶数次出现表示离开。每个学生的编号都是唯一的。\n", "outputFormat": "对于每一个询问，输出一个整数，表示询问区间内有多少个插排已经被使用。", "hint": "#### 数据规模与约定\n\n对于 $30\\%$ 的数据，$n \\le 10^5，q \\le 10^3$；\n\n对于 $100\\%$ 的数据，$1\\le n \\le 10^9,1\\le q \\le 10^5,0\\le k \\le 10^9,1\\le l\\le r\\le n$。", "locale": "zh-CN"}}}
{"pid": "P3969", "type": "P", "difficulty": 5, "samples": [["4\n2 3\n111\n101\n4 2\n01\n01\n11\n01\n2 1\n1 1\n3 2\n10\n10\n11\n4\n1 4\n1111\n1 4\n1111\n1 4\n1111\n1 4\n1111\n4\n1 4\n1111\n1 4\n1111\n1 4\n1111\n2 3\n111\n001", "Yes, only one!\n1112\n1412\n3422\n3442\nYes, many!\nNo solution"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "各省省选", "天津"], "title": "[TJOI2014] 拼图", "background": "", "description": "小Z最近迷上了拼图游戏,然而智商有限,他总是无法拼出完整图案。游戏是这样的：首先小Z会得到一些拼图碎片,然后他试着重新排列这些碎片使得它们组成一个大小为4\\*4的正方形。如下图。注意小Z不能旋转或者翻转这些碎片。\n\n ![](https://cdn.luogu.com.cn/upload/pic/10988.png) \n\n小Z得到如图1的碎片,然后经过重新排列得到图2的正方形。\n\n由于小Z实在太笨了,聪明的你请写一个程序帮助他来解决这个问题吧。\n", "inputFormat": "输入包含多组数据,请使用EOF\n\n每组数据的的第一行包含一个正整数N，表示碎片的个数。接下来输入N个碎片。每个碎片的第一行是两个正整数r和c,表示这个碎片的行数和列数。接下来是r行,每一行包含c个字符'0'或'1'，'1'表示碎片占据这个位置,'0'表示该位置为空。数据保证每个碎片都是完整的一片(即'1'是相互连通的),并且没有行或者列全部为'0'。\n", "outputFormat": "如果无法组成一个正方形,输出”No solution”;如果有多组解,输出”Yes, many!”。否则,输出”Yes, only one!”,接下来输出一个4\\*4的矩阵H,Hij表示位置i,j的碎片编号。碎片编号从1开始。\n", "hint": "### 数据范围\n\n对于 30% 的数据，N < 5\n\n对于 100% 的数据，N ≤ 16\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2014] Puzzle", "background": "", "description": "Little Z has recently become obsessed with jigsaw puzzles, but with limited intelligence, he always fails to complete the full picture. The game works like this: first, Little Z is given some puzzle pieces. He then tries to rearrange these pieces so that they form a $4 \\times 4$ square, as shown below. Note that Little Z cannot rotate or flip the pieces.\n\nLittle Z gets the pieces shown in Figure 1, and after rearranging them, he obtains the $4 \\times 4$ square shown in Figure 2.\n\nSince Little Z is really not good at this, please write a program to help him solve the problem.", "inputFormat": "The input contains multiple test cases; read until EOF.\n\nFor each test case, the first line contains a positive integer $N$, the number of pieces. Then $N$ pieces follow. For each piece, the first line contains two positive integers $r$ and $c$, the number of rows and columns of this piece. Then there are $r$ lines, each containing $c$ characters '0' or '1'; '1' means the piece occupies that cell, and '0' means the cell is empty. It is guaranteed that each piece is a single connected component (i.e., the '1's are connected), and there is no row or column consisting entirely of '0's.", "outputFormat": "If it is impossible to form a square, output \"No solution\". If there are multiple solutions, output \"Yes, many!\". Otherwise, output \"Yes, only one!\", and then output a $4 \\times 4$ matrix $H$, where $H_{i,j}$ denotes the index of the piece at position $(i, j)$. Piece indices start from $1$.", "hint": "### Constraints\n\n- For $30\\%$ of the test cases, $N < 5$.\n- For $100\\%$ of the test cases, $N \\le 16$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2014] 拼图", "background": "", "description": "小Z最近迷上了拼图游戏,然而智商有限,他总是无法拼出完整图案。游戏是这样的：首先小Z会得到一些拼图碎片,然后他试着重新排列这些碎片使得它们组成一个大小为4\\*4的正方形。如下图。注意小Z不能旋转或者翻转这些碎片。\n\n ![](https://cdn.luogu.com.cn/upload/pic/10988.png) \n\n小Z得到如图1的碎片,然后经过重新排列得到图2的正方形。\n\n由于小Z实在太笨了,聪明的你请写一个程序帮助他来解决这个问题吧。\n", "inputFormat": "输入包含多组数据,请使用EOF\n\n每组数据的的第一行包含一个正整数N，表示碎片的个数。接下来输入N个碎片。每个碎片的第一行是两个正整数r和c,表示这个碎片的行数和列数。接下来是r行,每一行包含c个字符'0'或'1'，'1'表示碎片占据这个位置,'0'表示该位置为空。数据保证每个碎片都是完整的一片(即'1'是相互连通的),并且没有行或者列全部为'0'。\n", "outputFormat": "如果无法组成一个正方形,输出”No solution”;如果有多组解,输出”Yes, many!”。否则,输出”Yes, only one!”,接下来输出一个4\\*4的矩阵H,Hij表示位置i,j的碎片编号。碎片编号从1开始。\n", "hint": "### 数据范围\n\n对于 30% 的数据，N < 5\n\n对于 100% 的数据，N ≤ 16\n", "locale": "zh-CN"}}}
{"pid": "P3970", "type": "P", "difficulty": 5, "samples": [["4\n1 2 3 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "线段树", "各省省选", "树状数组", "排序", "天津"], "title": "[TJOI2014] 上升子序列", "background": null, "description": "给定一个只包含整数的序列（序列元素的绝对值大小不超过 $10^9$），你需要计算上升子序列的个数，满足如下条件的称之为一个上升子序列：\n\n1. 是原序列的一个子序列\n2. 长度至少为 $2$\n3. 所有元素都严格递增\n\n如果两个上升子序列相同，那么只需要计算一次。例如，序列 $\\{1,2,3,3\\}$ 有 $4$ 个上升子序列，分别为 $\\{1,2\\}$，$\\{1,3\\}$，$\\{1,2,3\\}$，$\\{2,3\\}$。", "inputFormat": "输入的第一行是一个整数 $n$，表示序列长度。接下来一行是 $n$ 个整数，表示序列。", "outputFormat": "输出仅包含一行，即原序列有多少个上升子序列。由于答案可能非常大，你只需要输出答案模 $10^9+7$ 的余数。", "hint": "### 数据范围\n\n对于 $30\\%$ 的数据，$n\\le5000$；\n\n对于 $100\\%$ 的数据，$n\\le10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2014] Increasing Subsequences", "background": "", "description": "Given a sequence containing only integers (the absolute value of each element does not exceed $10^9$), you need to count the number of increasing subsequences, where an increasing subsequence satisfies the following conditions:\n1. It is a subsequence of the original sequence.\n2. Its length is at least $2$.\n3. All elements are strictly increasing.\n\nIf two increasing subsequences are identical, count them only once. For example, the sequence $\\{1,2,3,3\\}$ has $4$ increasing subsequences: $\\{1,2\\}$, $\\{1,3\\}$, $\\{1,2,3\\}$, $\\{2,3\\}$.", "inputFormat": "The first line contains an integer $n$, the length of the sequence. The next line contains $n$ integers, the sequence elements.", "outputFormat": "Output a single line: the number of increasing subsequences of the original sequence. Since the answer can be very large, output the remainder modulo $10^9 + 7$.", "hint": "### Constraints\n\nFor $30\\%$ of the testdata, $n \\le 5000$.\n\nFor $100\\%$ of the testdata, $n \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2014] 上升子序列", "background": null, "description": "给定一个只包含整数的序列（序列元素的绝对值大小不超过 $10^9$），你需要计算上升子序列的个数，满足如下条件的称之为一个上升子序列：\n\n1. 是原序列的一个子序列\n2. 长度至少为 $2$\n3. 所有元素都严格递增\n\n如果两个上升子序列相同，那么只需要计算一次。例如，序列 $\\{1,2,3,3\\}$ 有 $4$ 个上升子序列，分别为 $\\{1,2\\}$，$\\{1,3\\}$，$\\{1,2,3\\}$，$\\{2,3\\}$。", "inputFormat": "输入的第一行是一个整数 $n$，表示序列长度。接下来一行是 $n$ 个整数，表示序列。", "outputFormat": "输出仅包含一行，即原序列有多少个上升子序列。由于答案可能非常大，你只需要输出答案模 $10^9+7$ 的余数。", "hint": "### 数据范围\n\n对于 $30\\%$ 的数据，$n\\le5000$；\n\n对于 $100\\%$ 的数据，$n\\le10^5$。", "locale": "zh-CN"}}}
{"pid": "P3971", "type": "P", "difficulty": 6, "samples": [["4\n1 2 2 3", "5"], ["4\n1 1 2 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "各省省选", "天津"], "title": "[TJOI2014] Alice and Bob", "background": "", "description": "Alice 和 Bob 发明了一个新的游戏。给定一个序列 $\\{x_0,x_1,\\cdots,x_{n-1}\\}$，Alice 得到一个序列 $\\{a_0,a_1,\\cdots,a_{n-1}\\}$，其中 $a_i$ 表示以 $x_i$ 结尾的最长上升子序列的长度；Bob 得到一个序列$\\{b_0,b_1,\\cdots,b_{n-1}\\}$，其中 $b_i$ 表示以 $x_i$ 开头的最长下降子序列的长度。Alice 的得分是序列 $\\{a_i\\}$ 的和，Bob的得分是序列 $\\{b_i\\}$ 的和。\n", "inputFormat": "输入的第一行是 $n$，第二行是序列 $\\{a_0,a_1,\\cdots,a_{n-1}\\}$。数据保证序列 $\\{a_i\\}$ 可以由至少一个 $1$ 到 $n$ 的排列得到。", "outputFormat": "输出包含一行,表示在序列 $\\{a_i\\}$ 给定的情况下 Bob 能得到的最高分数。", "hint": "### 数据范围\n\n对于 $30\\%$ 的数据，$N \\le 1000$。\n\n对于 $100\\%$ 的数据，$N \\le 10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2014] Alice and Bob", "background": "", "description": "Alice and Bob invented a new game. Given a sequence $\\{x_0, x_1, \\cdots, x_{n-1}\\}$, Alice gets a sequence $\\{a_0, a_1, \\cdots, a_{n-1}\\}$, where $a_i$ is the length of the longest increasing subsequence ending at $x_i$; Bob gets a sequence $\\{b_0, b_1, \\cdots, b_{n-1}\\}$, where $b_i$ is the length of the longest decreasing subsequence starting at $x_i$. Alice’s score is the sum of the sequence $\\{a_i\\}$, and Bob’s score is the sum of the sequence $\\{b_i\\}$.", "inputFormat": "The first line contains $n$, and the second line contains the sequence $\\{a_0, a_1, \\cdots, a_{n-1}\\}$. It is guaranteed that the sequence $\\{a_i\\}$ can be obtained from at least one permutation of $1$ to $n$.", "outputFormat": "Output a single line indicating the highest score Bob can obtain given the sequence $\\{a_i\\}$.", "hint": "### Constraints\n\nFor $30\\%$ of the testdata, $n \\le 1000$.\n\nFor $100\\%$ of the testdata, $n \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2014] Alice and Bob", "background": "", "description": "Alice 和 Bob 发明了一个新的游戏。给定一个序列 $\\{x_0,x_1,\\cdots,x_{n-1}\\}$，Alice 得到一个序列 $\\{a_0,a_1,\\cdots,a_{n-1}\\}$，其中 $a_i$ 表示以 $x_i$ 结尾的最长上升子序列的长度；Bob 得到一个序列$\\{b_0,b_1,\\cdots,b_{n-1}\\}$，其中 $b_i$ 表示以 $x_i$ 开头的最长下降子序列的长度。Alice 的得分是序列 $\\{a_i\\}$ 的和，Bob的得分是序列 $\\{b_i\\}$ 的和。\n", "inputFormat": "输入的第一行是 $n$，第二行是序列 $\\{a_0,a_1,\\cdots,a_{n-1}\\}$。数据保证序列 $\\{a_i\\}$ 可以由至少一个 $1$ 到 $n$ 的排列得到。", "outputFormat": "输出包含一行,表示在序列 $\\{a_i\\}$ 给定的情况下 Bob 能得到的最高分数。", "hint": "### 数据范围\n\n对于 $30\\%$ 的数据，$N \\le 1000$。\n\n对于 $100\\%$ 的数据，$N \\le 10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P3972", "type": "P", "difficulty": 6, "samples": [["10 \nR 1 1 1 \nR 2 2 1 2 \nC 2 2 \nR 3 1 2 \nQ 1 \nC 3 2 \nC 1 5 \nQ 1 \nQ 2 \nQ 3", "2 \n1 \n3 \n2"]], "limits": {"time": [100, 100, 100, 100, 100, 100, 100, 100, 100, 100], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "各省省选", "天津"], "title": "[TJOI2014] 电影评分", "background": "", "description": "小Z发明了一套新的电影评分系统。这套系统有三种操作:发布新电影、对电影评分、以及询问电影评分的排名。具体是这样运作的:如果是发布新电影,并且这部电影的有所主演之前均没有出现过,那么这部新电影的评分为0,否则这部电影的评分为**最近一部**与该电影**至少有一个共同主演**的电影的评分;如果是对电影进行评分,那么这部电影的评分就变成之前评分与新的评分的平均数;如果是查询排名,则根据评分输出相应排名。评分最高的为第一名。如果有多部电影分数相同,那么输出最早的一部。电影的评分在0到5之间。\n", "inputFormat": "输入的第一行是n,表示操作次数。接下来n行,每一行是以下三种操作之一：\n\n1. Q x:查询当前排名为x的电影ID\n\n2. R ID x actor1 actor2 …· actorx:发布新电影ID,该电影有x个主演分别为 actor1, actor2,…’\n\n3. C ID score:评分操作,表示对电影ID的评分为 score\n\n数据保证每个电影的ID不相同,且每部电影至多不超过5名主演。\n\n1≤ actor1, actor2,··≤10^5\n\n1≤ID≤10^5\n", "outputFormat": "对于每一个查询操作,输出相应排名的电影的ID。\n", "hint": "### 样例解释\n\n| Movie | 1 | 2 | 3 | \n| :-: | :-: | :-: | :-: | :-: | :-: |\n| | 0 | - | - |\n| | 0 | 0 | - |\n| | 0 | 1 | - |\n| | 0 | 1 | 1 |\n| Q 1 => 2 | //Movie 2 wa|s released be|fore Movie 3 |\n| | 0 | 1 | 1.5 |\n| | 2.5 | 1 | 1.5 |\n| Q 1 => 1 |\n| Q 2 => 3 |\n| Q 3 => 2 |\n### 数据范围\n\n对于 30% 的数据，n ≤ 100\n\n对于 100% 的数据，n ≤ 10000\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2014] Movie Rating", "background": "", "description": "Xiao Z invented a new movie rating system with three kinds of operations: releasing a new movie, rating a movie, and querying a movie’s rank.\n\n- When releasing a new movie: if none of its leading actors have appeared before, the new movie’s rating is $0$. Otherwise, its initial rating equals the rating of the most recent previously released movie that shares at least one leading actor with it.\n- When rating a movie: its rating becomes the average of its previous rating and the new score.\n- When querying a rank: output the ID of the movie whose current rank is $x$. The highest rating ranks first. If multiple movies have the same rating, the one released earlier ranks higher. All ratings are between $0$ and $5$.", "inputFormat": "The first line contains $n$, the number of operations. Then $n$ lines follow, each being one of the following:\n\n1. Q x: query the movie ID currently ranked $x$.\n2. R ID x actor1 actor2 ... actorx: release a new movie with ID $ID$, which has $x$ leading actors $actor1, actor2, \\dots, actorx$.\n3. C ID score: rate movie $ID$ with the score $score$; the movie’s new rating becomes the average of its previous rating and $score$.\n\nAdditional rules:\n- All movie IDs are distinct.\n- Each movie has at most $5$ leading actors.\n\nConstraints:\n- $1 \\leq actor_i \\leq 10^5$.\n- $1 \\leq ID \\leq 10^5$.\n- For $30\\%$ of the testdata, $n \\leq 100$.\n- For $100\\%$ of the testdata, $n \\leq 10000$.", "outputFormat": "For each query operation, output the corresponding movie ID.", "hint": "- The initial rating of a new movie is $0$ if none of its leading actors have appeared before; otherwise, it equals the rating of the most recently released earlier movie that shares at least one leading actor.\n- After a rating operation C ID score, the new rating becomes the average of the current rating and $score$.\n- If multiple movies have the same rating, the earlier released one ranks higher. For example, if Movie $2$ and Movie $3$ have the same rating, then a query Q $1$ returns $2$ because Movie $2$ was released earlier.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2014] 电影评分", "background": "", "description": "小Z发明了一套新的电影评分系统。这套系统有三种操作:发布新电影、对电影评分、以及询问电影评分的排名。具体是这样运作的:如果是发布新电影,并且这部电影的有所主演之前均没有出现过,那么这部新电影的评分为0,否则这部电影的评分为**最近一部**与该电影**至少有一个共同主演**的电影的评分;如果是对电影进行评分,那么这部电影的评分就变成之前评分与新的评分的平均数;如果是查询排名,则根据评分输出相应排名。评分最高的为第一名。如果有多部电影分数相同,那么输出最早的一部。电影的评分在0到5之间。\n", "inputFormat": "输入的第一行是n,表示操作次数。接下来n行,每一行是以下三种操作之一：\n\n1. Q x:查询当前排名为x的电影ID\n\n2. R ID x actor1 actor2 …· actorx:发布新电影ID,该电影有x个主演分别为 actor1, actor2,…’\n\n3. C ID score:评分操作,表示对电影ID的评分为 score\n\n数据保证每个电影的ID不相同,且每部电影至多不超过5名主演。\n\n1≤ actor1, actor2,··≤10^5\n\n1≤ID≤10^5\n", "outputFormat": "对于每一个查询操作,输出相应排名的电影的ID。\n", "hint": "### 样例解释\n\n| Movie | 1 | 2 | 3 | \n| :-: | :-: | :-: | :-: | :-: | :-: |\n| | 0 | - | - |\n| | 0 | 0 | - |\n| | 0 | 1 | - |\n| | 0 | 1 | 1 |\n| Q 1 => 2 | //Movie 2 wa|s released be|fore Movie 3 |\n| | 0 | 1 | 1.5 |\n| | 2.5 | 1 | 1.5 |\n| Q 1 => 1 |\n| Q 2 => 3 |\n| Q 3 => 2 |\n### 数据范围\n\n对于 30% 的数据，n ≤ 100\n\n对于 100% 的数据，n ≤ 10000\n", "locale": "zh-CN"}}}
{"pid": "P3973", "type": "P", "difficulty": 6, "samples": [["3\n1 2 1\n3 1 0\n1 2 3\n2 3 7", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2015", "各省省选", "图论建模", "最小割", "天津"], "title": "[TJOI2015] 线性代数", "background": "", "description": "为了提高智商，ZJY 开始学习线性代数。\n\n她的小伙伴菠萝给她出了这样一个问题：给定一个 $n \\times n$ 的矩阵 $B$ 和一个 $1 \\times n$ 的矩阵 $C$。求出一个 $1×n$ 的 01 矩阵 $A$，使得 $D=(A×B-C)×A^{\\sf T}$ 最大，其中$A^{\\sf T}$为$A$的转置，输出$D$。", "inputFormat": "第一行输入一个整数 $n$。接下来 $n$ 行输入 $B$ 矩阵，第 $i$ 行第 $j$ 个数代表 $B$ 接下来一行输入 $n$ 个整数，代表矩阵 $C$。矩阵 $B$ 和矩阵 $C$ 中每个数字都是不过 $1000$ 的非负整数。\n", "outputFormat": "输出一个整数，表示最大的 $D$。", "hint": "- 对于 $30\\%$ 的数据，$n \\leq 15$；\n- 对于 $100\\%$ 的数据，$1 \\leq n \\leq 500$；\n- 另外还有两组不计分的 hack 数据，放在 subtask 2 中，数据范围与上面一致。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2015] Linear Algebra", "background": "", "description": "To improve her IQ, ZJY starts to study linear algebra.\n\nHer friend Boluo gives her the following problem: Given an $n \\times n$ matrix $B$ and a $1 \\times n$ matrix $C$. Find a $1 \\times n$ 0-1 matrix $A$ such that $D = (A \\times B - C) \\times A^{\\sf T}$ is maximized, where $A^{\\sf T}$ is the transpose of $A$, and output $D$.", "inputFormat": "The first line contains an integer $n$.  \nThe next $n$ lines give matrix $B$: in the $i$-th line, the $j$-th number is $B_{i,j}$.  \nThe next line contains $n$ integers, representing matrix $C$.  \nEvery number in matrices $B$ and $C$ is a non-negative integer not exceeding $1000$.", "outputFormat": "Output a single integer, the maximum value of $D$.", "hint": "- For $30\\%$ of the testdata, $n \\leq 15$.\n- For $100\\%$ of the testdata, $1 \\leq n \\leq 500$.\n- There are also two extra unscored hack testdata in subtask 2, with the same ranges as above.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2015] 线性代数", "background": "", "description": "为了提高智商，ZJY 开始学习线性代数。\n\n她的小伙伴菠萝给她出了这样一个问题：给定一个 $n \\times n$ 的矩阵 $B$ 和一个 $1 \\times n$ 的矩阵 $C$。求出一个 $1×n$ 的 01 矩阵 $A$，使得 $D=(A×B-C)×A^{\\sf T}$ 最大，其中$A^{\\sf T}$为$A$的转置，输出$D$。", "inputFormat": "第一行输入一个整数 $n$。接下来 $n$ 行输入 $B$ 矩阵，第 $i$ 行第 $j$ 个数代表 $B$ 接下来一行输入 $n$ 个整数，代表矩阵 $C$。矩阵 $B$ 和矩阵 $C$ 中每个数字都是不过 $1000$ 的非负整数。\n", "outputFormat": "输出一个整数，表示最大的 $D$。", "hint": "- 对于 $30\\%$ 的数据，$n \\leq 15$；\n- 对于 $100\\%$ 的数据，$1 \\leq n \\leq 500$；\n- 另外还有两组不计分的 hack 数据，放在 subtask 2 中，数据范围与上面一致。\n", "locale": "zh-CN"}}}
{"pid": "P3974", "type": "P", "difficulty": 6, "samples": [["1\n3 3\n0 1 5\n5 0 0\n1 0 0", "10"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "递推", "2015", "各省省选", "天津", "Dilworth 定理"], "title": "[TJOI2015] 组合数学", "background": "", "description": "为了提高智商，ZJY 开始学习组合数学。某一天她解决了这样一个问题：给一个网格图，其中某些格子有财宝。每次从左上角出发，只能往右或下走。问至少要走几次才可能把财宝全捡完。\n\n但是她还不知足，想到了这个问题的一个变形：假设每个格子中有好多块财宝，而每一次经过一个格子至多只能捡走一块财宝，其他条件不变，至少要走几次才可能把财宝全捡完？\n\n这次她不会做了，你能帮帮她吗？", "inputFormat": "第一行为一个正整数 $t$，表示数据组数。\n\n每组数据的第一行是两个正整数 $n$ 和 $m$，表示这个网格图有 $n$ 行 $m$ 列。\n\n接下来 $n$ 行，每行 $m$ 个非负整数，表示这个格子中的财宝数量（$0$ 表示没有财宝）。", "outputFormat": "对于每组数据，输出一个整数，表示至少走的次数。\n", "hint": "### 数据范围\n\n对于 $30\\%$ 的数据，$n \\le 5$，$m \\le 5$，每个格子中的财宝数不超过 $5$ 块。\n\n对于 $50\\%$ 的数据，$n \\le 100$，$m \\le 100$，每个格子中的财宝数不超过 $1000$ 块。\n\n对于 $100\\%$ 的数据，$1\\le t\\le 2$，$1\\le n \\le 1000$，$1\\le m \\le 1000$，每个格子中的财宝不超过 $10^6$ 块。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2015] Combinatorics", "background": "", "description": "To improve her IQ, ZJY started studying combinatorics. One day she solved this problem: given a grid where some cells contain treasure. Each time, starting from the top-left corner, you can only move right or down. What is the minimum number of walks needed so that it is possible to collect all the treasures?\n\nBut she was not satisfied and thought of a variation: suppose each cell contains many pieces of treasure, and on each pass through a cell you can take at most one piece of treasure. With other conditions unchanged, what is the minimum number of walks needed so that it is possible to collect all the pieces of treasure?\n\nThis time she could not solve it. Can you help her?", "inputFormat": "The first line contains a positive integer $t$, the number of test cases.\n\nFor each test case, the first line contains two positive integers $n$ and $m$, indicating the grid has $n$ rows and $m$ columns.\n\nThe next $n$ lines each contain $m$ non-negative integers, representing the number of pieces of treasure in that cell ($0$ means no treasure).", "outputFormat": "For each test case, output one integer, the minimum number of walks.", "hint": "### Constraints\n\nFor $30\\%$ of the testdata, $n \\le 5$, $m \\le 5$, and the number of pieces of treasure in each cell does not exceed $5$.\n\nFor $50\\%$ of the testdata, $n \\le 100$, $m \\le 100$, and the number of pieces of treasure in each cell does not exceed $1000$.\n\nFor $100\\%$ of the testdata, $1 \\le t \\le 2$, $1 \\le n \\le 1000$, $1 \\le m \\le 1000$, and the number of pieces of treasure in each cell does not exceed $10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2015] 组合数学", "background": "", "description": "为了提高智商，ZJY 开始学习组合数学。某一天她解决了这样一个问题：给一个网格图，其中某些格子有财宝。每次从左上角出发，只能往右或下走。问至少要走几次才可能把财宝全捡完。\n\n但是她还不知足，想到了这个问题的一个变形：假设每个格子中有好多块财宝，而每一次经过一个格子至多只能捡走一块财宝，其他条件不变，至少要走几次才可能把财宝全捡完？\n\n这次她不会做了，你能帮帮她吗？", "inputFormat": "第一行为一个正整数 $t$，表示数据组数。\n\n每组数据的第一行是两个正整数 $n$ 和 $m$，表示这个网格图有 $n$ 行 $m$ 列。\n\n接下来 $n$ 行，每行 $m$ 个非负整数，表示这个格子中的财宝数量（$0$ 表示没有财宝）。", "outputFormat": "对于每组数据，输出一个整数，表示至少走的次数。\n", "hint": "### 数据范围\n\n对于 $30\\%$ 的数据，$n \\le 5$，$m \\le 5$，每个格子中的财宝数不超过 $5$ 块。\n\n对于 $50\\%$ 的数据，$n \\le 100$，$m \\le 100$，每个格子中的财宝数不超过 $1000$ 块。\n\n对于 $100\\%$ 的数据，$1\\le t\\le 2$，$1\\le n \\le 1000$，$1\\le m \\le 1000$，每个格子中的财宝不超过 $10^6$ 块。", "locale": "zh-CN"}}}
{"pid": "P3975", "type": "P", "difficulty": 6, "samples": [["aabc\n0 3", "aab"], ["aabc\n1 3", "aa"], ["aabc\n1 11", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2015", "二分", "各省省选", "后缀自动机 SAM", "枚举", "后缀数组 SA", "天津"], "title": "[TJOI2015] 弦论", "background": "", "description": "为了提高智商，ZJY 开始学习弦论。这一天，她在《String theory》中看到了这样一道问题：对于一个给定的长度为 $n$ 的字符串，求出它的第 $k$ 小子串是什么。你能帮帮她吗?\n", "inputFormat": "第一行是一个仅由小写英文字母构成的字符串 $s$。\n\n第二行为两个整数 $t$ 和 $k$，$t$ 为 $0$ 则表示不同位置的相同子串算作一个，$t$ 为 $1$ 则表示不同位置的相同子串算作多个。$k$ 的意义见题目描述。\n", "outputFormat": "输出数据仅有一行,该行有一个字符串，为第 $k$ 小的子串。若子串数目不足 $k$ 个，则输出 $-1$。\n", "hint": "### 数据范围\n\n对于 $10\\%$ 的数据，$n\\leq 1000$。\n\n对于 $50\\%$ 的数据，$t = 0$。\n\n对于 $100\\%$ 的数据，$1\\leq n \\leq 5 \\times 10^5$，$0\\leq t \\leq 1$，$1\\leq k \\leq 10^9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2015] String Theory", "background": "", "description": "To boost her IQ, ZJY started studying string theory. One day, she saw the following problem in \"String theory\": Given a string of length $n$, find its $k$-th smallest substring. Can you help her?", "inputFormat": "The first line contains a string $s$ consisting only of lowercase English letters.\n\nThe second line contains two integers $t$ and $k$. If $t = 0$, identical substrings at different positions are counted as one; if $t = 1$, identical substrings at different positions are counted multiple times. The meaning of $k$ is as described above.", "outputFormat": "Output exactly one line containing a string, which is the $k$-th smallest substring. If there are fewer than $k$ substrings, output -1.", "hint": "Constraints\n\nFor $10\\%$ of the testdata, $n\\leq 1000$.\n\nFor $50\\%$ of the testdata, $t = 0$.\n\nFor $100\\%$ of the testdata, $1\\leq n \\leq 5 \\times 10^5$, $0\\leq t \\leq 1$, $1\\leq k \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2015] 弦论", "background": "", "description": "为了提高智商，ZJY 开始学习弦论。这一天，她在《String theory》中看到了这样一道问题：对于一个给定的长度为 $n$ 的字符串，求出它的第 $k$ 小子串是什么。你能帮帮她吗?\n", "inputFormat": "第一行是一个仅由小写英文字母构成的字符串 $s$。\n\n第二行为两个整数 $t$ 和 $k$，$t$ 为 $0$ 则表示不同位置的相同子串算作一个，$t$ 为 $1$ 则表示不同位置的相同子串算作多个。$k$ 的意义见题目描述。\n", "outputFormat": "输出数据仅有一行,该行有一个字符串，为第 $k$ 小的子串。若子串数目不足 $k$ 个，则输出 $-1$。\n", "hint": "### 数据范围\n\n对于 $10\\%$ 的数据，$n\\leq 1000$。\n\n对于 $50\\%$ 的数据，$t = 0$。\n\n对于 $100\\%$ 的数据，$1\\leq n \\leq 5 \\times 10^5$，$0\\leq t \\leq 1$，$1\\leq k \\leq 10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P3976", "type": "P", "difficulty": 6, "samples": [["3\n1 2 3\n1 2\n2 3\n2\n1 2 100\n1 3 100", "1\n1"], ["5\n1 2 3 4 5\n1 2\n1 3\n2 4\n4 5\n6\n1 5 50\n2 4 500\n3 4 5000\n3 5 50000\n1 3 500000\n2 3 5000000\n", "4\n2\n551\n551\n0\n499499"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "线段树", "各省省选", "树链剖分", "动态树 LCT", "天津"], "title": "[TJOI2015] 旅游", "background": null, "description": "为了提高智商，ZJY 准备去往一个新世界去旅游。这个世界的城市布局像一棵树，每两座城市之间只有一条路径可以互达。  \n\n每座城市都有一种宝石,有一定的价格。ZJY 为了赚取最高利益,她会选择从 A 城市买入再转手卖到 B 城市（只能进行一次购买）。  \n\n由于ZJY买宝石时经常卖萌，因而凡是 ZJY 路过的城市，这座城市的宝石价格会上涨。让我们来算算 ZJY 旅游完之后能够赚取的最大利润。(如 A 城市宝石价格为 $v$，则ZJY出售价格也为 $v$)", "inputFormat": "第一行输入一个正整数 $n$ 表示城市个数\n\n接下来一行输入 $n$ 个正整数表示每座城市宝石的最初价格 $p$,每个宝石的初始价格不超过 $100$。\n\n第三行开始连续输入 $n-1$ 行,每行有两个数字 $x$ 和 $y$。表示 $x$ 城市和 $y$ 城市有一条路径。城市编号从$1$开始。  \n\n下一行输入一个正整数 $q$ 表示询问次数。\n\n接下来 $q$ 行每行输入三个正整数 $a,b,v$，表示 ZJY 从 $a$ 旅游到 $b$，城市宝石上涨 $v$。", "outputFormat": "对于每次询问，输出 ZJY 可能获得的最大利润，如果亏本了则输出 $0$。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\le 100$，$q \\le 10^4$。\n- 对于 $100\\%$ 的数据，保证 $1\\le n,q \\le 5\\times 10^4$，在任何时刻任何城市的宝石价格都不超过 $10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2015] Tourism", "background": "# Description\n\nTo improve her IQ, ZJY plans to travel to a new world. The cities in this world form a tree, and there is exactly one path between any two cities.\n\nEach city has a type of gem with a certain price. To maximize profit, ZJY will choose to buy in city A and then resell in city B (only one purchase is allowed).\n\nBecause ZJY often acts cute when buying gems, the gem price in every city she passes through will increase. Let us calculate the maximum profit ZJY can earn after the trip. (For example, if the gem price in city A is $v$, then ZJY’s selling price is also $v$.)", "description": "To improve her IQ, ZJY plans to travel to a new world. The cities in this world form a tree, and there is exactly one path between any two cities.\n\nEach city has a type of gem with a certain price. To maximize profit, ZJY will choose to buy in city A and then resell in city B (only one purchase is allowed).\n\nBecause ZJY often acts cute when buying gems, the gem price in every city she passes through will increase. Let us calculate the maximum profit ZJY can earn after the trip. (For example, if the gem price in city A is $v$, then ZJY’s selling price is also $v$.)\n\n# Description", "inputFormat": "- The first line contains a positive integer $n$, the number of cities.\n- The next line contains $n$ positive integers, the initial prices $p$ of the gems in each city. Each initial price does not exceed $100$.\n- Starting from the third line, there are $n-1$ lines. Each line contains two integers $x$ and $y$, indicating there is an edge between city $x$ and city $y$. City indices start from $1$.\n- The next line contains a positive integer $q$, the number of queries.\n- Each of the next $q$ lines contains three positive integers $a$, $b$, $v$, indicating that ZJY travels from $a$ to $b$, and the gem price in every city along the route (including both endpoints) increases by $v$.", "outputFormat": "For each query, output the maximum possible profit ZJY can obtain. If the best result is a loss, output $0$.", "hint": "Constraints\n\n- For $30\\%$ of the testdata, $n \\le 100$, $q \\le 10^4$.\n- For $100\\%$ of the testdata, $1 \\le n, q \\le 5 \\times 10^4$, and at any time the gem price in any city does not exceed $10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2015] 旅游", "background": null, "description": "为了提高智商，ZJY 准备去往一个新世界去旅游。这个世界的城市布局像一棵树，每两座城市之间只有一条路径可以互达。  \n\n每座城市都有一种宝石,有一定的价格。ZJY 为了赚取最高利益,她会选择从 A 城市买入再转手卖到 B 城市（只能进行一次购买）。  \n\n由于ZJY买宝石时经常卖萌，因而凡是 ZJY 路过的城市，这座城市的宝石价格会上涨。让我们来算算 ZJY 旅游完之后能够赚取的最大利润。(如 A 城市宝石价格为 $v$，则ZJY出售价格也为 $v$)", "inputFormat": "第一行输入一个正整数 $n$ 表示城市个数\n\n接下来一行输入 $n$ 个正整数表示每座城市宝石的最初价格 $p$,每个宝石的初始价格不超过 $100$。\n\n第三行开始连续输入 $n-1$ 行,每行有两个数字 $x$ 和 $y$。表示 $x$ 城市和 $y$ 城市有一条路径。城市编号从$1$开始。  \n\n下一行输入一个正整数 $q$ 表示询问次数。\n\n接下来 $q$ 行每行输入三个正整数 $a,b,v$，表示 ZJY 从 $a$ 旅游到 $b$，城市宝石上涨 $v$。", "outputFormat": "对于每次询问，输出 ZJY 可能获得的最大利润，如果亏本了则输出 $0$。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\le 100$，$q \\le 10^4$。\n- 对于 $100\\%$ 的数据，保证 $1\\le n,q \\le 5\\times 10^4$，在任何时刻任何城市的宝石价格都不超过 $10^9$。", "locale": "zh-CN"}}}
{"pid": "P3977", "type": "P", "difficulty": 6, "samples": [["5 5\n3 1\n0 1 0\n1 1 1\n0 1 0\n", "55447\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "2015", "各省省选", "枚举", "矩阵加速", "进制", "天津", "状压 DP"], "title": "[TJOI2015] 棋盘", "background": "", "description": "为了提高智商，ZJY 去新世界旅游了。可是旅游过后的 ZJY 杯具地发现要打开通往原来世界的门，必须要解开门上面画的谜题。谜题是这样的：\n\n有个 $n$ 行 $m$ 列的棋盘，棋盘上可以放许多特殊的棋子。每个棋子的攻击范围是 $3$ 行 $p$ 列。输入数据用一个 $3\\times p$ 的矩阵给出了棋子攻击范围的模板，棋子被默认为模板中的第 $1$ 行，第 $k$ 列，则棋子能攻击到的位置是 $1$，不能攻击到的位置是 $0$。输入数据保证第 $1$ 行第 $k$ 列的位置是 $1$。打开门的密码就是，在要求棋子互相不能攻击到的前提下，摆放棋子的方案数。注意什么棋子都不摆放也算作一种可行方案。由于方案数可能很大,而密码为 $32$ 位的二进制密码,所以 ZJY 仅需要知道方案数对 $2^{32}$ 次方取余数的结果即可。\n\n注意：编号从 $0$ 开始，即第 $1$ 行指的是中间那行。", "inputFormat": "输入数据的第一行为两个整数 $n$ 和 $m$，表示棋盘的大小。\n\n第二行为两个整数 $p$ 和 $k$，表示接下来的攻击范围模板的大小，以及棋子在模板中的位置。\n\n接下来三行,每行有 $p$ 个数,表示攻击范围的模版。每个数字后有一个空格。", "outputFormat": "输出数据仅有一行，一个整数，表示可行的方案数模 $2^{32}$ 的余数。", "hint": "### 数据范围\n\n对于 $10\\%$ 的数据，$1 \\leq n \\leq 5$，$1 \\leq m \\leq5$。\n\n对于 $50\\%$ 的数据，$1 \\leq n \\leq 1000$，$1 \\leq m \\leq 6$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^{6}$，$1 \\leq m \\leq 6$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2015] Chessboard", "background": "", "description": "To improve his IQ, ZJY traveled to a new world. However, after traveling, ZJY unfortunately found that to open the door back to his original world, he must solve the puzzle drawn on the door. The puzzle is as follows:\n\nThere is an $n$-row by $m$-column board on which many special pieces can be placed. Each piece has an attack range of 3 rows and $p$ columns. The input provides a template of the attack range as a $3\\times p$ matrix. A piece is assumed to be at row $1$, column $k$ of the template; positions it can attack are marked with $1$, and positions it cannot attack are marked with $0$. The input guarantees that the entry at row $1$, column $k$ is $1$. The password to open the door is the number of ways to place pieces on the board so that the pieces do not attack each other. Note that placing no pieces at all also counts as a valid arrangement. Since the number of arrangements may be large, and the password is a 32-bit binary number, ZJY only needs the number of arrangements modulo $2^{32}$.\n\nNote: indices start from $0$, i.e., row $1$ refers to the middle row.", "inputFormat": "The first line contains two integers $n$ and $m$, representing the size of the board.\n\nThe second line contains two integers $p$ and $k$, representing the size of the upcoming attack-range template and the piece’s position within the template.\n\nThe next three lines each contain $p$ numbers, describing the attack-range template. There is a space after each number.", "outputFormat": "Output a single line with one integer, the number of valid arrangements modulo $2^{32}$.", "hint": "### Constraints\n\nFor 10% of the testdata, $1 \\leq n \\leq 5$, $1 \\leq m \\leq 5$.\n\nFor 50% of the testdata, $1 \\leq n \\leq 1000$, $1 \\leq m \\leq 6$.\n\nFor 100% of the testdata, $1 \\leq n \\leq 10^{6}$, $1 \\leq m \\leq 6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2015] 棋盘", "background": "", "description": "为了提高智商，ZJY 去新世界旅游了。可是旅游过后的 ZJY 杯具地发现要打开通往原来世界的门，必须要解开门上面画的谜题。谜题是这样的：\n\n有个 $n$ 行 $m$ 列的棋盘，棋盘上可以放许多特殊的棋子。每个棋子的攻击范围是 $3$ 行 $p$ 列。输入数据用一个 $3\\times p$ 的矩阵给出了棋子攻击范围的模板，棋子被默认为模板中的第 $1$ 行，第 $k$ 列，则棋子能攻击到的位置是 $1$，不能攻击到的位置是 $0$。输入数据保证第 $1$ 行第 $k$ 列的位置是 $1$。打开门的密码就是，在要求棋子互相不能攻击到的前提下，摆放棋子的方案数。注意什么棋子都不摆放也算作一种可行方案。由于方案数可能很大,而密码为 $32$ 位的二进制密码,所以 ZJY 仅需要知道方案数对 $2^{32}$ 次方取余数的结果即可。\n\n注意：编号从 $0$ 开始，即第 $1$ 行指的是中间那行。", "inputFormat": "输入数据的第一行为两个整数 $n$ 和 $m$，表示棋盘的大小。\n\n第二行为两个整数 $p$ 和 $k$，表示接下来的攻击范围模板的大小，以及棋子在模板中的位置。\n\n接下来三行,每行有 $p$ 个数,表示攻击范围的模版。每个数字后有一个空格。", "outputFormat": "输出数据仅有一行，一个整数，表示可行的方案数模 $2^{32}$ 的余数。", "hint": "### 数据范围\n\n对于 $10\\%$ 的数据，$1 \\leq n \\leq 5$，$1 \\leq m \\leq5$。\n\n对于 $50\\%$ 的数据，$1 \\leq n \\leq 1000$，$1 \\leq m \\leq 6$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^{6}$，$1 \\leq m \\leq 6$。", "locale": "zh-CN"}}}
{"pid": "P3978", "type": "P", "difficulty": 6, "samples": [["1", "1.000000000"], ["3", "1.200000000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "2015", "各省省选", "Special Judge", "Catalan 数", "生成函数", "期望", "天津"], "title": "[TJOI2015] 概率论", "background": "", "description": "为了提高智商，ZJY 开始学习概率论。有一天，她想到了这样一个问题：对于一棵随机生成的 $n$ 个结点的有根二叉树（所有互相不同构的形态等概率出现），它的叶子节点数的期望是多少呢？\n\n判断两棵树是否同构的伪代码如下：\n\n$$\n\\def\\arraystretch{1.2}\n    \\begin{array}{ll}\n    \\hline\n    \\textbf{算法 1}&\\text{Check}(T1,T2) \\\\\n    \\hline\n    1&\\textbf{Require: }\\text{ 两棵树的节点}T1,T2\\\\\n    2&\\qquad\\textbf{if}\\ \\ T1=\\text{null}\\textbf{ or }T2=\\text{null}\\textbf{ then }\\\\\n    3&\\qquad\\qquad\\textbf{return}\\ \\ T1=\\text{null}\\textbf{ and }T2=\\text{null}\\\\\n    4&\\qquad\\textbf{else}\\\\\n    5&\\qquad\\qquad\\textbf{return}\\ \\text{Check}(T1\\to\\mathit{leftson},T2\\to\\mathit{leftson}) \\\\ \n    & \\qquad\\qquad\\qquad \\textbf{ and }\\text{Check}(T1\\to\\mathit{rightson},T2\\to\\mathit{rightson})\\\\\n    6&\\qquad\\textbf{endif}\\\\\n    \\hline\n    \\end{array} \n    $$\n\n", "inputFormat": "输入一个正整数 $n$，表示有根树的结点数。\n", "outputFormat": "输出这棵树期望的叶子节点数，要求误差小于 $10^{-9}$。\n", "hint": "## 数据范围\n\n对于 $30\\%$ 的数据，$1 \\le n \\le 10$。\n\n对于 $70\\%$ 的数据，$1 \\le n \\le 100$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2015] Probability Theory", "background": "", "description": "To boost her IQ, ZJY started studying probability theory. One day, she came up with this question: among all non-isomorphic rooted binary trees with $n$ nodes, chosen uniformly at random, what is the expected number of leaf nodes?\n\nThe pseudocode to check whether two trees are isomorphic is as follows:\n$$\n\\def\\arraystretch{1.2}\n    \\begin{array}{ll}\n    \\hline\n    \\textbf{Algorithm 1}&\\text{Check}(T1,T2) \\\\\n    \\hline\n    1&\\textbf{Require: }\\text{ nodes }T1,T2\\text{ of the two trees}\\\\\n    2&\\qquad\\textbf{if}\\ \\ T1=\\text{null}\\textbf{ or }T2=\\text{null}\\textbf{ then }\\\\\n    3&\\qquad\\qquad\\textbf{return}\\ \\ T1=\\text{null}\\textbf{ and }T2=\\text{null}\\\\\n    4&\\qquad\\textbf{else}\\\\\n    5&\\qquad\\qquad\\textbf{return}\\ \\text{Check}(T1\\to\\mathit{leftson},T2\\to\\mathit{leftson}) \\\\ \n    & \\qquad\\qquad\\qquad \\textbf{ and }\\text{Check}(T1\\to\\mathit{rightson},T2\\to\\mathit{rightson})\\\\\n    6&\\qquad\\textbf{endif}\\\\\n    \\hline\n    \\end{array} \n    $$", "inputFormat": "Input a positive integer $n$, the number of nodes in the rooted tree.", "outputFormat": "Output the expected number of leaf nodes of the tree. The error must be less than $10^{-9}$.", "hint": "Constraints\n\n- For $30\\%$ of the testdata, $1 \\le n \\le 10$.\n- For $70\\%$ of the testdata, $1 \\le n \\le 100$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2015] 概率论", "background": "", "description": "为了提高智商，ZJY 开始学习概率论。有一天，她想到了这样一个问题：对于一棵随机生成的 $n$ 个结点的有根二叉树（所有互相不同构的形态等概率出现），它的叶子节点数的期望是多少呢？\n\n判断两棵树是否同构的伪代码如下：\n\n$$\n\\def\\arraystretch{1.2}\n    \\begin{array}{ll}\n    \\hline\n    \\textbf{算法 1}&\\text{Check}(T1,T2) \\\\\n    \\hline\n    1&\\textbf{Require: }\\text{ 两棵树的节点}T1,T2\\\\\n    2&\\qquad\\textbf{if}\\ \\ T1=\\text{null}\\textbf{ or }T2=\\text{null}\\textbf{ then }\\\\\n    3&\\qquad\\qquad\\textbf{return}\\ \\ T1=\\text{null}\\textbf{ and }T2=\\text{null}\\\\\n    4&\\qquad\\textbf{else}\\\\\n    5&\\qquad\\qquad\\textbf{return}\\ \\text{Check}(T1\\to\\mathit{leftson},T2\\to\\mathit{leftson}) \\\\ \n    & \\qquad\\qquad\\qquad \\textbf{ and }\\text{Check}(T1\\to\\mathit{rightson},T2\\to\\mathit{rightson})\\\\\n    6&\\qquad\\textbf{endif}\\\\\n    \\hline\n    \\end{array} \n    $$\n\n", "inputFormat": "输入一个正整数 $n$，表示有根树的结点数。\n", "outputFormat": "输出这棵树期望的叶子节点数，要求误差小于 $10^{-9}$。\n", "hint": "## 数据范围\n\n对于 $30\\%$ 的数据，$1 \\le n \\le 10$。\n\n对于 $70\\%$ 的数据，$1 \\le n \\le 100$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3979", "type": "P", "difficulty": 6, "samples": [["3 7\n1 2\n1 3\n1 2 3\n1\n3 1\n2 1 1 6\n3 1\n2 2 2 5\n3 1\n2 3 3 4\n3 1", "1\n2\n3\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "倍增", "最近公共祖先 LCA", "树链剖分"], "title": "遥远的国度", "background": "", "description": "`zcwwzdjn` 在追杀 `zhx` ，而 `zhx` 逃入了一个遥远的国度。当 `zcwwzdjn` 准备进入遥远的国度继续追杀时，守护神 `RapiD` 阻拦了 `zcwwzdjn` 的去路，他需要 `zcwwzdjn` 完成任务后才能进入遥远的国度继续追杀。\n\n问题是这样的：遥远的国度有 $n$ 个城市，这些城市之间由一些路连接且这些城市构成了一颗树。这个国度有一个首都，我们可以把这个首都看做整棵树的根，但遥远的国度比较奇怪，首都是随时有可能变为另外一个城市的。遥远的国度的每个城市有一个防御值，第 $i$ 个的防御值为 $val_i$，有些时候 `RapiD` 会使得某两个城市之间的路径上的所有城市的防御值都变为某个值。\n\n`RapiD` 想知道在某个时候，如果把首都看做整棵树的根的话，那么以某个城市为根的子树的所有城市的防御值最小是多少。\n\n由于 `RapiD` 无法解决这个问题，所以他拦住了 `zcwwzdjn` 希望他能帮忙。但 `zcwwzdjn` 还要追杀 `zhx`，所以这个重大的问题就被转交到了你的手上。", "inputFormat": "第 $1$ 行两个整数 $n\\ m$，代表城市个数和操作数。\n\n第 $2$ 行至第 $n$ 行，每行两个整数 $u\\ v$，代表城市 $u$ 和城市 $v$ 之间有一条路。\n\n第 $n+1$ 行，有 $n$ 个整数，第 $i$ 个代表第 $i$ 个点的初始防御值 $val_i$。\n\n第 $n+2$ 行一个整数 $id$，代表初始的首都为 $id$。\n\n第 $n+3$ 行至第 $n+m+2$ 行，首先有一个整数 $opt$。\n\n如果 $opt=1$，接下来有一个整数 $id$，代表把首都修改为 $id$；\n\n如果 $opt=2$，接下来有三个整数 $x\\ y\\ v$，代表将 $x\\ y$ 路径上的所有城市的防御值修改为 $v$；\n\n如果 $opt=3$，接下来有一个整数 $id$，代表询问以城市 $id$ 为根的子树中的最小防御值。", "outputFormat": "对于每个 $opt=3$ 的操作，输出一行代表对应子树的最小点权值。", "hint": "对于 $20\\%$ 的数据，$n\\le 1000,m\\le 1000$。\n\n对于另外 $10\\%$ 的数据，$n\\le 100000,m\\le 100000$，保证修改为单点修改。\n\n对于另外 $10\\%$ 的数据，$n\\le100000,m \\le 100000$，保证树为一条链。\n\n对于另外 $10\\%$ 的数据，$n\\le 100000,m\\le100000$，没有修改首都的操作。\n\n对于 $100\\%$ 的数据，$1 \\leq n\\le 100000,1 \\leq m \\le 100000,0<val_i<2^{31}$。", "locale": "zh-CN", "translations": {"en": {"title": "A Distant Kingdom", "background": "", "description": "`zcwwzdjn` is hunting down `zhx`, and `zhx` has fled to a distant kingdom. When `zcwwzdjn` is about to enter the distant kingdom to continue the pursuit, the guardian `RapiD` blocks his way. He must complete a task before he can enter the distant kingdom and continue the chase.\n\nHere is the problem: the distant kingdom has $n$ cities. These cities are connected by some roads and they form a tree. The kingdom has a capital, and we can regard this capital as the root of the whole tree; however, the capital may change to another city at any time. Each city has a defense value; the $i$-th city's defense value is $val_i$. Sometimes `RapiD` will set the defense values of all cities on the path between two cities to a certain value.\n\n`RapiD` wants to know, at some moment, if we regard the capital as the root of the whole tree, then what is the minimum defense value among all cities in the subtree rooted at some city.\n\nSince `RapiD` cannot solve this, he stopped `zcwwzdjn` hoping he could help. But `zcwwzdjn` still needs to hunt down `zhx`, so this important problem has been handed over to you.", "inputFormat": "Line $1$: two integers $n\\ m$, representing the number of cities and the number of operations.\n\nLines $2$ to $n$: each line contains two integers $u\\ v$, meaning there is a road between city $u$ and city $v$.\n\nLine $n+1$: $n$ integers; the $i$-th integer is the initial defense value $val_i$ of the $i$-th city.\n\nLine $n+2$: one integer $id$, meaning the initial capital is $id$.\n\nLines $n+3$ to $n+m+2$: first there is an integer $opt$.\n- If $opt=1$, then there is an integer $id$, meaning the capital is updated to $id$.\n- If $opt=2$, then there are three integers $x\\ y\\ v$, meaning the defense values of all cities on the path $x\\ y$ are set to $v$.\n- If $opt=3$, then there is an integer $id$, meaning you need to query the minimum defense value in the subtree rooted at city $id$ (with the current capital regarded as the root of the whole tree).", "outputFormat": "For each $opt=3$ operation, output one line containing the minimum defense value in the corresponding subtree.", "hint": "For $20\\%$ of the testdata, $n\\le 1000,m\\le 1000$.\n\nFor another $10\\%$ of the testdata, $n\\le 100000,m\\le 100000$, and updates are guaranteed to be point updates.\n\nFor another $10\\%$ of the testdata, $n\\le100000,m \\le 100000$, and the tree is guaranteed to be a chain.\n\nFor another $10\\%$ of the testdata, $n\\le 100000,m\\le100000$, and there are no operations that change the capital.\n\nFor $100\\%$ of the testdata, $1 \\leq n\\le 100000,1 \\leq m \\le 100000,0<val_i<2^{31}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "遥远的国度", "background": "", "description": "`zcwwzdjn` 在追杀 `zhx` ，而 `zhx` 逃入了一个遥远的国度。当 `zcwwzdjn` 准备进入遥远的国度继续追杀时，守护神 `RapiD` 阻拦了 `zcwwzdjn` 的去路，他需要 `zcwwzdjn` 完成任务后才能进入遥远的国度继续追杀。\n\n问题是这样的：遥远的国度有 $n$ 个城市，这些城市之间由一些路连接且这些城市构成了一颗树。这个国度有一个首都，我们可以把这个首都看做整棵树的根，但遥远的国度比较奇怪，首都是随时有可能变为另外一个城市的。遥远的国度的每个城市有一个防御值，第 $i$ 个的防御值为 $val_i$，有些时候 `RapiD` 会使得某两个城市之间的路径上的所有城市的防御值都变为某个值。\n\n`RapiD` 想知道在某个时候，如果把首都看做整棵树的根的话，那么以某个城市为根的子树的所有城市的防御值最小是多少。\n\n由于 `RapiD` 无法解决这个问题，所以他拦住了 `zcwwzdjn` 希望他能帮忙。但 `zcwwzdjn` 还要追杀 `zhx`，所以这个重大的问题就被转交到了你的手上。", "inputFormat": "第 $1$ 行两个整数 $n\\ m$，代表城市个数和操作数。\n\n第 $2$ 行至第 $n$ 行，每行两个整数 $u\\ v$，代表城市 $u$ 和城市 $v$ 之间有一条路。\n\n第 $n+1$ 行，有 $n$ 个整数，第 $i$ 个代表第 $i$ 个点的初始防御值 $val_i$。\n\n第 $n+2$ 行一个整数 $id$，代表初始的首都为 $id$。\n\n第 $n+3$ 行至第 $n+m+2$ 行，首先有一个整数 $opt$。\n\n如果 $opt=1$，接下来有一个整数 $id$，代表把首都修改为 $id$；\n\n如果 $opt=2$，接下来有三个整数 $x\\ y\\ v$，代表将 $x\\ y$ 路径上的所有城市的防御值修改为 $v$；\n\n如果 $opt=3$，接下来有一个整数 $id$，代表询问以城市 $id$ 为根的子树中的最小防御值。", "outputFormat": "对于每个 $opt=3$ 的操作，输出一行代表对应子树的最小点权值。", "hint": "对于 $20\\%$ 的数据，$n\\le 1000,m\\le 1000$。\n\n对于另外 $10\\%$ 的数据，$n\\le 100000,m\\le 100000$，保证修改为单点修改。\n\n对于另外 $10\\%$ 的数据，$n\\le100000,m \\le 100000$，保证树为一条链。\n\n对于另外 $10\\%$ 的数据，$n\\le 100000,m\\le100000$，没有修改首都的操作。\n\n对于 $100\\%$ 的数据，$1 \\leq n\\le 100000,1 \\leq m \\le 100000,0<val_i<2^{31}$。", "locale": "zh-CN"}}}
{"pid": "P3980", "type": "P", "difficulty": 6, "samples": [["3 3\n2 3 4\n1 2 2\n2 3 5\n3 3 2", "14"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "NOI", "网络流", "图论建模", "费用流", "线性规划"], "title": "[NOI2008] 志愿者招募", "background": "", "description": "申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。经过估算，这个项目需要 $n$ 天才能完成，其中第 $i$ 天至少需要 $a_i$ 个人。布布通过了解得知，一共有 $m$ 类志愿者可以招募。其中第 $i$ 类可以从第 $s_i$ 天工作到第 $t_i$ 天，招募费用是每人 $c_i$ 元。新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长！于是布布找到了你，希望你帮他设计一种最优的招募方案。", "inputFormat": "第一行包含两个整数 $n,m$，表示完成项目的天数和可以招募的志愿者的种类。接下来的一行中包含 $n$ 个非负整数，表示每天至少需要的志愿者人数。 接下来的 $m$ 行中每行包含三个整数 $s_i, t_i, c_i$，含义如上文所述。为了方便起见，我们可以认为每类志愿者的数量都是无限多的。保证存在可行的招募方案。", "outputFormat": "仅包含一个整数，表示你所设计的最优方案的总费用。\n", "hint": "$1\\leq n\\leq 1000$，$1\\leq m\\leq 10000$，题目中其他所涉及的数据均不超过 $2^{31}-1$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2008] Volunteer Recruitment", "background": "", "description": "After the successful Olympic bid, through persistent effort, Bubu finally became the head of the HR department of a company under the Organizing Committee. On his first day, he faced a challenge: recruiting a group of short-term volunteers for a new Olympic project. It is estimated that the project will take $n$ days to complete, and on day $i$, at least $a_i$ people are needed.\n\nThere are $m$ types of volunteers available. Type $i$ can work from day $s_i$ to day $t_i$ (inclusive), and the recruitment cost is $c_i$ yuan per person. Eager to excel in his new role, Bubu wants to recruit enough volunteers at the minimum possible cost, but this is not his strong suit. He turns to you to design an optimal recruitment plan.\n\nFor convenience, assume the number of volunteers of each type is unlimited. It is guaranteed that there exists a feasible recruitment plan.", "inputFormat": "- The first line contains two integers $n, m$, denoting the number of days needed to complete the project and the number of available volunteer types.\n- The second line contains $n$ non-negative integers, denoting the minimum number of volunteers required for each day.\n- Each of the next $m$ lines contains three integers $s_i, t_i, c_i$, as described above.", "outputFormat": "Output a single integer, the total cost of your optimal plan.", "hint": "Constraints: $1 \\le n \\le 1000$, $1 \\le m \\le 10000$, and all other quantities involved do not exceed $2^{31} - 1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2008] 志愿者招募", "background": "", "description": "申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。经过估算，这个项目需要 $n$ 天才能完成，其中第 $i$ 天至少需要 $a_i$ 个人。布布通过了解得知，一共有 $m$ 类志愿者可以招募。其中第 $i$ 类可以从第 $s_i$ 天工作到第 $t_i$ 天，招募费用是每人 $c_i$ 元。新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长！于是布布找到了你，希望你帮他设计一种最优的招募方案。", "inputFormat": "第一行包含两个整数 $n,m$，表示完成项目的天数和可以招募的志愿者的种类。接下来的一行中包含 $n$ 个非负整数，表示每天至少需要的志愿者人数。 接下来的 $m$ 行中每行包含三个整数 $s_i, t_i, c_i$，含义如上文所述。为了方便起见，我们可以认为每类志愿者的数量都是无限多的。保证存在可行的招募方案。", "outputFormat": "仅包含一个整数，表示你所设计的最优方案的总费用。\n", "hint": "$1\\leq n\\leq 1000$，$1\\leq m\\leq 10000$，题目中其他所涉及的数据均不超过 $2^{31}-1$。", "locale": "zh-CN"}}}
{"pid": "P3981", "type": "P", "difficulty": 6, "samples": [["2 2 2", "1"], ["2 14 5", "12"]], "limits": {"time": [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "递推", "2017", "Fibonacci 数列", "矩阵乘法", "构造"], "title": "琅泽难题", "background": "```cpp\n万事万物总是那么巧妙，数学海洋令我无限徜徉，在那一瞬，我又发现了美。\n```\n真程海洋的伟大数学家**琅泽**响应真程海洋殿主的号召，参与了这次出题。\n\n根据他的思考与推算，出了一道有意思的题目，以下是他给你们的话：\n", "description": "这个题目的灵感来自于这组数据：\n\n ![](https://cdn.luogu.com.cn/upload/pic/9088.png) \n\n这组数据采用**描述法**的规律，在第$ n+1 $层从左到右描述第$ n $层的数据，描述规律如下：从左到右描述第$ n $层的数据，从第一个数据开始，每当碰到连续的$ a_1 $个$ b_1 $时，将$ a_1\\,b_1 $作为新的两个数据写在第$ n+1 $层的最后（这个最后是接在最后一个数据后面，如果第$ n+1 $层本来没有数据，则此时的最后即为开头），**紧接着**再描述接下来连续的$ a_2 $个$ b_2 $（$ b_1\\neq b_2 $），往后亦如此，直到所有数据被描述完毕，则此时第$ n+1 $层也构造完毕，此处的$ n $为正整数。\n\n现在，我有一个新的想法了，给定一个**初始数据** $ Q $（初始数据在第一层，且第一层仅有一个数据——初始数据$ Q $），按照**类似于**上述规律的规律（描述法）构造一组数据，称为“琅泽阵”。我定义的规律为：在奇数层遵循$ A $规律，在偶数层遵循$ B $规律。具体表现如下图：\n\n ![](https://cdn.luogu.com.cn/upload/pic/9091.png) \n\n上图是当初始数据为$ 1 $时呈现的部分琅泽阵，至于是什么规律，就需要你去探究。\n\n### 但是！！！\n\n这还不是最终目的，我要考的是，在第$ i $层中，有多少个$ x $（我们定义初始数据所在的层数为第一层）？\n", "inputFormat": "输入仅一行，包含三个整数$ Q $和$ i $以及$ x $，每两个数据之间有一个空格。\n\n$ Q $作为该琅泽阵的初始数据。\n", "outputFormat": "输出仅一行，包含一个整数，表示在第$ i $层中，$ x $的数量。\n\n由于输出数据较大，请将输出数据对$ 20171111 $取模（即原始输出数据除以$ 20171111 $后取其余数作为最终输出数据）。\n", "hint": "### 样例一说明：\n\n构建出来的琅泽阵（一小部分）为：\n\n ![](https://cdn.luogu.com.cn/upload/pic/10486.png) \n\n故第$ 2 $层中$ 2 $的数量为$ 1 $。\n\n### 注意：\n\n所有数据均为整数；\n\n如果你毫无思路，你可以选择解决一些子问题；\n\n以下是各个测试点中，输入数据的范围大小：\n\n![](https://cdn.luogu.com.cn/upload/pic/10333.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "Langze's Puzzle", "background": "```cpp\n万事万物总是那么巧妙，数学海洋令我无限徜徉，在那一瞬，我又发现了美。\n```\nThe great mathematician Langze of Zhencheng Ocean responded to the call of the Hall Master of Zhencheng Ocean and took part in making this problem.\n\nBased on his thinking and calculations, he created an interesting problem. Here is his message for you:", "description": "The inspiration for this problem comes from the following data:\n\n![](https://cdn.luogu.com.cn/upload/pic/9088.png)\n\nThis data follows the “description method” rule: on the $ n+1 $-th layer, describe the data of the $ n $-th layer from left to right. The rule is as follows: starting from the first datum, whenever you encounter a run of $ a_1 $ consecutive $ b_1 $, write $ a_1\\,b_1 $ as two new data at the end of the $ n+1 $-th layer (the “end” here means appended after the last datum; if the $ n+1 $-th layer has no data yet, then this “end” is the beginning). Then, immediately describe the next run of $ a_2 $ consecutive $ b_2 $ ($ b_1 \\neq b_2 $), and so on, until all data have been fully described. At that point, the $ n+1 $-th layer is constructed. Here $ n $ is a positive integer.\n\nNow, I have a new idea. Given an initial datum $ Q $ (the initial datum is on the first layer, and the first layer contains only one datum — the initial datum $ Q $), construct a data array using a rule similar to the one above (the description method), called the “Langze Array.” My rule is: on odd-numbered layers follow rule $ A $, and on even-numbered layers follow rule $ B $. See the figure below:\n\n![](https://cdn.luogu.com.cn/upload/pic/9091.png)\n\nThe above shows part of the Langze Array when the initial datum is $ 1 $. As for what the exact rules are, that is for you to explore.\n\nHowever!!!\n\nThat is not the final goal. What I want you to find is: on the $ i $-th layer, how many $ x $ are there (we define the layer containing the initial datum as the first layer)?", "inputFormat": "The input contains only one line with three integers $ Q $, $ i $, and $ x $, separated by single spaces.\n\n$ Q $ is the initial datum of the Langze Array.", "outputFormat": "Output a single line with one integer: the count of $ x $ on the $ i $-th layer.\n\nSince the output can be large, output the result modulo $ 20171111 $ (that is, take the remainder after dividing the original result by $ 20171111 $).", "hint": "Sample 1 explanation:\n\nA (small) part of the constructed Langze Array is:\n\n![](https://cdn.luogu.com.cn/upload/pic/10486.png)\n\nTherefore, the count of $ 2 $ on the $ 2 $-nd layer is $ 1 $.\n\nNotes:\n- All data are integers.\n- If you have no idea how to proceed, you may choose to solve some subproblems first.\n- Constraints for each test point are as follows:\n  \n  ![](https://cdn.luogu.com.cn/upload/pic/10333.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "琅泽难题", "background": "```cpp\n万事万物总是那么巧妙，数学海洋令我无限徜徉，在那一瞬，我又发现了美。\n```\n真程海洋的伟大数学家**琅泽**响应真程海洋殿主的号召，参与了这次出题。\n\n根据他的思考与推算，出了一道有意思的题目，以下是他给你们的话：\n", "description": "这个题目的灵感来自于这组数据：\n\n ![](https://cdn.luogu.com.cn/upload/pic/9088.png) \n\n这组数据采用**描述法**的规律，在第$ n+1 $层从左到右描述第$ n $层的数据，描述规律如下：从左到右描述第$ n $层的数据，从第一个数据开始，每当碰到连续的$ a_1 $个$ b_1 $时，将$ a_1\\,b_1 $作为新的两个数据写在第$ n+1 $层的最后（这个最后是接在最后一个数据后面，如果第$ n+1 $层本来没有数据，则此时的最后即为开头），**紧接着**再描述接下来连续的$ a_2 $个$ b_2 $（$ b_1\\neq b_2 $），往后亦如此，直到所有数据被描述完毕，则此时第$ n+1 $层也构造完毕，此处的$ n $为正整数。\n\n现在，我有一个新的想法了，给定一个**初始数据** $ Q $（初始数据在第一层，且第一层仅有一个数据——初始数据$ Q $），按照**类似于**上述规律的规律（描述法）构造一组数据，称为“琅泽阵”。我定义的规律为：在奇数层遵循$ A $规律，在偶数层遵循$ B $规律。具体表现如下图：\n\n ![](https://cdn.luogu.com.cn/upload/pic/9091.png) \n\n上图是当初始数据为$ 1 $时呈现的部分琅泽阵，至于是什么规律，就需要你去探究。\n\n### 但是！！！\n\n这还不是最终目的，我要考的是，在第$ i $层中，有多少个$ x $（我们定义初始数据所在的层数为第一层）？\n", "inputFormat": "输入仅一行，包含三个整数$ Q $和$ i $以及$ x $，每两个数据之间有一个空格。\n\n$ Q $作为该琅泽阵的初始数据。\n", "outputFormat": "输出仅一行，包含一个整数，表示在第$ i $层中，$ x $的数量。\n\n由于输出数据较大，请将输出数据对$ 20171111 $取模（即原始输出数据除以$ 20171111 $后取其余数作为最终输出数据）。\n", "hint": "### 样例一说明：\n\n构建出来的琅泽阵（一小部分）为：\n\n ![](https://cdn.luogu.com.cn/upload/pic/10486.png) \n\n故第$ 2 $层中$ 2 $的数量为$ 1 $。\n\n### 注意：\n\n所有数据均为整数；\n\n如果你毫无思路，你可以选择解决一些子问题；\n\n以下是各个测试点中，输入数据的范围大小：\n\n![](https://cdn.luogu.com.cn/upload/pic/10333.png)\n", "locale": "zh-CN"}}}
{"pid": "P3982", "type": "P", "difficulty": 4, "samples": [["1010000011100000101011111010100010100110", "A PIG"], ["1", "Error"], ["0000001000000010000000100000001010100000", "22A"], ["IOIOOOOI", "Error"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "2017", "进制"], "title": "龙盘雪峰信息解析器", "background": "```cpp\n薄雾笼罩，远方的雪峰无限迷人，感慨之间，阴影将至。\n```\n与真程海洋毗邻的龙盘雪山与我们保持着联系，但是龙盘雪山的通讯员常常把信息进行奇怪的加密，然后要我们来破译，很是谨慎。但是，久而久之，我们的通讯员不耐烦了，差点掀桌子砸凳子不干了。所以我们想做一个信息解析器，就是这样。\n", "description": "龙盘雪峰传来的信息都加密成了复杂的代码，我们需要你来做一个程序，按照解析规则解密这些代码，翻译成文字信息，以下是其解析规则：\n\n该代码应为一连串的二进制码（只存在$ 0 $和$ 1 $，做加法时满$ 2 $进$ 1 $，每个$ 0 $或$ 1 $占一个字符），每八个字符为一单元（这也是规则）。\n\n每个单元都有这样的规则：一、若【前三个字符】为$ 101 $时表示需要转换为字母$ A-Z $，字母$ A $代码为$ 10100000 $，字母$ C $为$ 10100010 $，$ 26 $个**大写字母**以字母表顺序按照这种规律顺序排列，分别对应一个二进制代码。二、若【前三个字符】为$ 111 $，则该单元翻译为空格。三、若【第一个字符】为$ 0 $，则该单元表示一个数，待定**与下一个单元所表示的数做加法**。加法过程中，这两个单元应转换为十进制，然后除以$ 2 $并**舍弃余数**才相加，加法结束后，这两个单元做加法得到的结果即为这两个单元的翻译结果（翻译结果用十进制表示，**这两个单元**就都翻译完毕了，详见样例$ 3 $）。\n\n由于保险，龙盘雪峰经常发送【假代码】，而假代码则不存在上述规则，如果是假代码，**仅**输出$ Error $。\n", "inputFormat": "输入仅一行，包含一串连续的代码（长度不超过$ 171111 $个字符），中间不会出现空格，保证不出现空代码。\n", "outputFormat": "输出仅一行，包含一个字符串，是二进制代码按照上述规则翻译后的文字信息。\n\n若该二进制代码中存在假代码信息，则**只**输出$ Error $。\n", "hint": "### 样例一说明：\n\n$ 10100000 $代表$ A $，下一个单元开头为$ 111 $，那么翻译为空格，再下一个单元开头为$ 101 $，后接$ 01111 $，比$ A $多了$ 2^0+2^1+2^2+2^3=15 $，那么代表的就是$ P $了，以此类推，最后翻译为$ A\\;PIG $。\n\n### 注意：\n\n对于规则一的解释：$ 26 $个大写字母按照字母表的顺序排列，以$ A=10100000 $开始，往后的每一个字母的二进制码的值都比前面一个字母的二进制码的值多$ 1 $（注意满二进一）；\n\n此题目有误解题意的现象，请一定要看清楚题目，搞清楚逻辑关系，注意细节！\n", "locale": "zh-CN", "translations": {"en": {"title": "Longpan Snow Peak Information Parser", "background": "```cpp\n薄雾笼罩，远方的雪峰无限迷人，感慨之间，阴影将至。\n```\nLongpan Snow Peak, adjacent to the Yuzhencheng Ocean, stays in contact with us. However, the correspondent at Longpan Snow Peak often encrypts messages in strange ways and then asks us to decipher them—very cautious indeed. Over time, our own correspondents grew impatient, nearly flipping tables and smashing stools in frustration. So we want to build an information parser. That’s it.", "description": "Messages from Longpan Snow Peak are encrypted into complex codes. We need you to write a program that deciphers these codes according to the rules below and translates them into text.\n\nThe code is a continuous string of binary digits (only $ 0 $ and $ 1 $; when adding, carry $ 1 $ whenever it reaches $ 2 $; each $ 0 $ or $ 1 $ occupies one character). Every eight characters form one unit (this is also a rule).\n\nEach unit follows these rules:\n1. If the first three characters are $ 101 $, the unit represents a letter $ A\\text{-}Z $. The code for $ A $ is $ 10100000 $, the code for $ C $ is $ 10100010 $. The $ 26 $ uppercase letters are arranged in alphabetical order following this pattern, each corresponding to a unique binary code.\n2. If the first three characters are $ 111 $, the unit translates to a space.\n3. If the first character is $ 0 $, then the unit represents a number to be added to the number represented by the next unit. During this addition, convert these two units to decimal, then divide each by $ 2 $ and discard the remainder before adding. After the addition, the sum is the translation result for these two units (the result is expressed in decimal). Both of these units are then considered fully translated (see Sample $ 3 $).\n\nFor safety, Longpan Snow Peak often sends “fake code,” which does not follow the rules above. If fake code appears, only output Error.", "inputFormat": "The input contains a single line with a continuous code string (length does not exceed $ 171111 $ characters). No spaces will appear, and the input is guaranteed to be non-empty.", "outputFormat": "Output a single line containing the string produced by translating the binary code according to the rules above.\n\nIf the binary code contains any fake code, only output Error.", "hint": "Explanation for Sample $ 1 $:\n\n$ 10100000 $ represents $ A $. The next unit begins with $ 111 $, which translates to a space. The next unit begins with $ 101 $ and is followed by $ 01111 $, which is $ 2^0+2^1+2^2+2^3=15 $ more than $ A $, so it represents $ P $. By analogy, the final translation is $ A\\;PIG $.\n\nNote:\n\nFor Rule $ 1 $: the $ 26 $ uppercase letters are arranged in alphabetical order, starting from $ A=10100000 $. Each subsequent letter’s binary code has a value exactly $ 1 $ greater than the previous letter’s binary code (remember to carry in base $ 2 $).\n\nThis problem is prone to misunderstandings. Please read the statement carefully, clarify the logical relationships, and pay attention to details.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "龙盘雪峰信息解析器", "background": "```cpp\n薄雾笼罩，远方的雪峰无限迷人，感慨之间，阴影将至。\n```\n与真程海洋毗邻的龙盘雪山与我们保持着联系，但是龙盘雪山的通讯员常常把信息进行奇怪的加密，然后要我们来破译，很是谨慎。但是，久而久之，我们的通讯员不耐烦了，差点掀桌子砸凳子不干了。所以我们想做一个信息解析器，就是这样。\n", "description": "龙盘雪峰传来的信息都加密成了复杂的代码，我们需要你来做一个程序，按照解析规则解密这些代码，翻译成文字信息，以下是其解析规则：\n\n该代码应为一连串的二进制码（只存在$ 0 $和$ 1 $，做加法时满$ 2 $进$ 1 $，每个$ 0 $或$ 1 $占一个字符），每八个字符为一单元（这也是规则）。\n\n每个单元都有这样的规则：一、若【前三个字符】为$ 101 $时表示需要转换为字母$ A-Z $，字母$ A $代码为$ 10100000 $，字母$ C $为$ 10100010 $，$ 26 $个**大写字母**以字母表顺序按照这种规律顺序排列，分别对应一个二进制代码。二、若【前三个字符】为$ 111 $，则该单元翻译为空格。三、若【第一个字符】为$ 0 $，则该单元表示一个数，待定**与下一个单元所表示的数做加法**。加法过程中，这两个单元应转换为十进制，然后除以$ 2 $并**舍弃余数**才相加，加法结束后，这两个单元做加法得到的结果即为这两个单元的翻译结果（翻译结果用十进制表示，**这两个单元**就都翻译完毕了，详见样例$ 3 $）。\n\n由于保险，龙盘雪峰经常发送【假代码】，而假代码则不存在上述规则，如果是假代码，**仅**输出$ Error $。\n", "inputFormat": "输入仅一行，包含一串连续的代码（长度不超过$ 171111 $个字符），中间不会出现空格，保证不出现空代码。\n", "outputFormat": "输出仅一行，包含一个字符串，是二进制代码按照上述规则翻译后的文字信息。\n\n若该二进制代码中存在假代码信息，则**只**输出$ Error $。\n", "hint": "### 样例一说明：\n\n$ 10100000 $代表$ A $，下一个单元开头为$ 111 $，那么翻译为空格，再下一个单元开头为$ 101 $，后接$ 01111 $，比$ A $多了$ 2^0+2^1+2^2+2^3=15 $，那么代表的就是$ P $了，以此类推，最后翻译为$ A\\;PIG $。\n\n### 注意：\n\n对于规则一的解释：$ 26 $个大写字母按照字母表的顺序排列，以$ A=10100000 $开始，往后的每一个字母的二进制码的值都比前面一个字母的二进制码的值多$ 1 $（注意满二进一）；\n\n此题目有误解题意的现象，请一定要看清楚题目，搞清楚逻辑关系，注意细节！\n", "locale": "zh-CN"}}}
{"pid": "P3983", "type": "P", "difficulty": 4, "samples": [["11\n1 6 11 17 23 27 33 35 38 43", "32"], ["7\n1 5 14 18 20 28 31 34 39 42", "21"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2017", "背包 DP"], "title": "赛斯石（赛后强化版）", "background": "```cpp\n白露横江，水光接天，纵一苇之所如，凌万顷之茫然。——苏轼\n```\n真程海洋近来需要进购大批赛斯石，你或许会问，什么是赛斯石？\n\n首先我们来了解一下赛斯，赛斯是一个重量单位，我们用$ si $作为其单位。比如$ 1 $赛斯就是$ 1si $。\n\n而赛斯石有这样一个性质，它本来是一赛斯一赛斯单独存在的，但是用自然枪将其精化之后，它就会与其它经过精化的赛斯石进行合并，合并到合适的重量之后，便将其钝化，使其不再合并其它赛斯石，如果合错了，也可以用金刚刀将其切开（神奇的是你只能切成整数赛斯重量）。赛斯石的重量只能是**整数**赛斯重量，而不同赛斯重量的赛斯石的价格也是不一样的。\n", "description": "现需上市$ Need $赛斯重量的赛斯石，卖家想算出这些赛斯石经过某种合并方式来获得的最大收益。然而目前有一个问题，市场在真程大殿附近（真程海洋中心位置），卖家需要租船送赛斯石过去（即不考虑卖家自己租船过去的费用），目前有十种船可以租，载重量从$ 1si $到$ 10si $，每艘船的租价也是有所不同的，如下表所示：\n\n ![](https://cdn.luogu.com.cn/upload/pic/10663.png) \n\n由于真程大殿附近有强烈的赛斯力，导致**无法对赛斯石进行任何操作**，商家将赛斯石运过来之后就只能按照之前合并好的卖。假设卖家不返回，且这些赛斯石全部能卖出去。现在卖家他要计算总盈利（设总盈利=赛斯石的总收益-租船所需总费用），请你设计一个程序，算出一种最佳方案，以获得**最大总盈利**。\n", "inputFormat": "输入一共有两行\n\n第一行有一个数据$ Need $（赛斯石的总量，单位：$ si $）\n\n第二行有十个数据$ a_{1}\\  ...\\ a_{10} $（分别为$ 1si $到$ 10si $的赛斯石市场价格，单位：元）\n", "outputFormat": "输出仅一行，包含一个整数，表示最大总盈利。\n", "hint": "### 样例一说明：\n\n将$ 11 $个单位赛斯石合并为一个$ 4si $的赛斯石和一个$ 7si $的赛斯石并且租两个载重分别为$ 4si $和$ 7si $的船，这样做为最佳方案，那么最大总盈利就是$ 32 $元。\n\n### 注意：\n\n对于所有输入数据，均在区间$ (0, 100000) $中，并且为整数；\n\n保证卖家最大总盈利为正；\n\n同一行中，每两个数据之间有一个空格。\n\n赛后强化版于$ 2020 $年$ 10 $月$ 13 $日$ 19 $点$ 18 $分已强化完毕。\n", "locale": "zh-CN", "translations": {"en": {"title": "Sais Stone (Post-contest Enhanced Version)", "background": "```cpp\n白露横江，水光接天，纵一苇之所如，凌万顷之茫然。——苏轼\n```\nZhencheng Ocean recently needs to purchase a large number of Sais stones. You may ask: what is a Sais stone?\n\nFirst, let’s learn about “Sais” (赛斯). It is a unit of weight, and we use $ si $ as its unit symbol. For example, $ 1 $ Sais is $ 1 $ si.\n\nA Sais stone has the following property: originally, it exists as separate pieces of $ 1 $ si each. After being refined with a “Natural Gun,” it will merge with other refined Sais stones. Once merged to a suitable weight, it is “passivated” so it will no longer merge with other Sais stones. If merged incorrectly, it can be cut apart with a “Diamond Knife” (interestingly, you can only cut it into integer Sais weights). A Sais stone’s weight must be an integer number of Sais, and the price differs for different integer weights of Sais stones.", "description": "We now need to bring to market Sais stones with a total weight of $ Need $ si. The seller wants to compute the maximum revenue obtainable by merging the $ 1 $ si units in some way. However, there is a complication: the market is near the Zhencheng Grand Hall (the center of Zhencheng Ocean), and the seller needs to rent boats to deliver the Sais stones there (we do not count the cost for the seller himself to travel). There are ten types of boats available for rent, with carrying capacities from $ 1 $ si to $ 10 $ si, and each boat type has a different rental price, as shown in the table below.\n\n ![](https://cdn.luogu.com.cn/upload/pic/10663.png) \n\nDue to the strong Sais force near the Zhencheng Grand Hall, it is **impossible to perform any operation on the Sais stones** there. After the seller transports the Sais stones over, they can only be sold as pre-merged pieces. Assume the seller does not return and that all these Sais stones can be sold. Now the seller wants to calculate the total profit (let total profit = total revenue from Sais stones − total boat rental cost). Please design a program to find an optimal plan to obtain the **maximum total profit**.", "inputFormat": "The input consists of two lines.\n\n- The first line contains a single number $ Need $ (the total amount of Sais stones, unit: si).\n- The second line contains ten numbers $ a_{1}\\  ...\\ a_{10} $ (the market prices, in yuan, for Sais stones of weights $ 1 $ si to $ 10 $ si, respectively).", "outputFormat": "Output a single line containing one integer, the maximum total profit.", "hint": "- Sample explanation:\n\n  Merge $ 11 $ units of $ 1 $ si Sais stones into one $ 4 $ si stone and one $ 7 $ si stone, and rent two boats with capacities $ 4 $ si and $ 7 $ si. This is optimal, so the maximum total profit is $ 32 $ yuan.\n\n- Notes:\n\n  For all input numbers, they are integers in the interval $ (0, 100000) $.\n\n  It is guaranteed that the maximum total profit is positive.\n\n  In the same line, there is one space between any two numbers.\n\n  The post-contest enhanced version was completed on $ 2020 $-$ 10 $-$ 13 at $ 19 $:$ 18 $.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "赛斯石（赛后强化版）", "background": "```cpp\n白露横江，水光接天，纵一苇之所如，凌万顷之茫然。——苏轼\n```\n真程海洋近来需要进购大批赛斯石，你或许会问，什么是赛斯石？\n\n首先我们来了解一下赛斯，赛斯是一个重量单位，我们用$ si $作为其单位。比如$ 1 $赛斯就是$ 1si $。\n\n而赛斯石有这样一个性质，它本来是一赛斯一赛斯单独存在的，但是用自然枪将其精化之后，它就会与其它经过精化的赛斯石进行合并，合并到合适的重量之后，便将其钝化，使其不再合并其它赛斯石，如果合错了，也可以用金刚刀将其切开（神奇的是你只能切成整数赛斯重量）。赛斯石的重量只能是**整数**赛斯重量，而不同赛斯重量的赛斯石的价格也是不一样的。\n", "description": "现需上市$ Need $赛斯重量的赛斯石，卖家想算出这些赛斯石经过某种合并方式来获得的最大收益。然而目前有一个问题，市场在真程大殿附近（真程海洋中心位置），卖家需要租船送赛斯石过去（即不考虑卖家自己租船过去的费用），目前有十种船可以租，载重量从$ 1si $到$ 10si $，每艘船的租价也是有所不同的，如下表所示：\n\n ![](https://cdn.luogu.com.cn/upload/pic/10663.png) \n\n由于真程大殿附近有强烈的赛斯力，导致**无法对赛斯石进行任何操作**，商家将赛斯石运过来之后就只能按照之前合并好的卖。假设卖家不返回，且这些赛斯石全部能卖出去。现在卖家他要计算总盈利（设总盈利=赛斯石的总收益-租船所需总费用），请你设计一个程序，算出一种最佳方案，以获得**最大总盈利**。\n", "inputFormat": "输入一共有两行\n\n第一行有一个数据$ Need $（赛斯石的总量，单位：$ si $）\n\n第二行有十个数据$ a_{1}\\  ...\\ a_{10} $（分别为$ 1si $到$ 10si $的赛斯石市场价格，单位：元）\n", "outputFormat": "输出仅一行，包含一个整数，表示最大总盈利。\n", "hint": "### 样例一说明：\n\n将$ 11 $个单位赛斯石合并为一个$ 4si $的赛斯石和一个$ 7si $的赛斯石并且租两个载重分别为$ 4si $和$ 7si $的船，这样做为最佳方案，那么最大总盈利就是$ 32 $元。\n\n### 注意：\n\n对于所有输入数据，均在区间$ (0, 100000) $中，并且为整数；\n\n保证卖家最大总盈利为正；\n\n同一行中，每两个数据之间有一个空格。\n\n赛后强化版于$ 2020 $年$ 10 $月$ 13 $日$ 19 $点$ 18 $分已强化完毕。\n", "locale": "zh-CN"}}}
{"pid": "P3984", "type": "P", "difficulty": 2, "samples": [["3 5\n1 2 10", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "数学", "洛谷月赛"], "title": "高兴的津津", "background": null, "description": "津津上高中了。她在自己的妈妈的魔鬼训练下，成为了一个神犇，每次参加一次 OI 比赛必拿 Au 虐全场。每次她拿到一个 Au 后就很高兴。假设津津不会因为其它事高兴，并且她的高兴会持续 $T$ 天（包含获奖当天。就算在高兴的时候再次拿到 Au，她的高兴也只能维持包括这次拿奖之日起 $T$ 天，而不是额外增加 $T$ 天的高兴时间，除非之后再拿奖）。请你帮忙检查一下津津接下来的的日程安排，要参加 $n$ 场比赛，看看接下来的几天，津津会累计开心多久？", "inputFormat": "第一行两个整数 $n$ 和 $T$。\n\n接下来一行，$n$ 个单调递增整数 $t_i$，表示她在第 $t_i$ 天的时候拿了一个 Au。", "outputFormat": "一个整数表示，津津累计开心多久。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le n\\le2\\times10^5$。\n- $1\\le T\\le10^9$。\n- $1\\le t_i\\le 10^9$，$t_i$ 单调递增。", "locale": "zh-CN", "translations": {"en": {"title": "Happy Jinjin", "background": "", "description": "Jinjin has started high school. Under her mom’s strict training, she became a top OI contestant and wins Au every time. Each time she gets an Au, she becomes happy. Assume Jinjin does not get happy for any other reason, and her happiness lasts for $T$ days (including the award day). Even if she wins another Au while still happy, her happiness lasts for $T$ days starting from that new award day; it does not add an extra $T$ days, unless she wins again later. Please help check Jinjin’s upcoming schedule: she will attend $n$ contests. How many days in total will Jinjin be happy in the coming days?", "inputFormat": "The first line contains two integers $n$ and $T$.\n\nThe next line contains $n$ strictly increasing integers $t_i$, meaning she won an Au on day $t_i$.", "outputFormat": "Output a single integer: the total number of days Jinjin is happy.", "hint": "#### Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that:\n\n- $1 \\le n \\le 2 \\times 10^5$.\n- $1 \\le T \\le 10^9$.\n- $1 \\le t_i \\le 10^9$, and $t_i$ is strictly increasing.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "高兴的津津", "background": null, "description": "津津上高中了。她在自己的妈妈的魔鬼训练下，成为了一个神犇，每次参加一次 OI 比赛必拿 Au 虐全场。每次她拿到一个 Au 后就很高兴。假设津津不会因为其它事高兴，并且她的高兴会持续 $T$ 天（包含获奖当天。就算在高兴的时候再次拿到 Au，她的高兴也只能维持包括这次拿奖之日起 $T$ 天，而不是额外增加 $T$ 天的高兴时间，除非之后再拿奖）。请你帮忙检查一下津津接下来的的日程安排，要参加 $n$ 场比赛，看看接下来的几天，津津会累计开心多久？", "inputFormat": "第一行两个整数 $n$ 和 $T$。\n\n接下来一行，$n$ 个单调递增整数 $t_i$，表示她在第 $t_i$ 天的时候拿了一个 Au。", "outputFormat": "一个整数表示，津津累计开心多久。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le n\\le2\\times10^5$。\n- $1\\le T\\le10^9$。\n- $1\\le t_i\\le 10^9$，$t_i$ 单调递增。", "locale": "zh-CN"}}}
{"pid": "P3985", "type": "P", "difficulty": 4, "samples": [["5 10\n2 800\n5 400\n5 300\n3 400\n2 200\n", "1600"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "排序", "背包 DP", "进制", "洛谷月赛"], "title": "不开心的金明", "background": "", "description": "金明今天很不开心，家里购置的二手房就要领钥匙了，房里并没有一间他自己专用的很宽敞的房间。更让他不高兴的是，妈妈昨天对他说：“你需要购买哪些物品，怎么布置，你说了不算（有很大的限制），而且不超过 $W$ 元钱。”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 $W$ 元。于是，他把每件物品规定了一个重要度整数 $p_i$ 表示。他还从因特网上查到了每件物品的价格 $v_i$（都是整数元）。\n\n妈妈看到购物单后进行了审查，要求购物单上所有的物品价格的极差（最贵的减去最便宜的）不超过 $3$（当然金明至今不知道为什么会这样）。他希望在不超过 $W$ 元（可以等于 $W$ 元）的前提下，使购买的重要度总和 $\\sum p_i$ 的最大。\n\n\n请你帮助金明设计一个满足要求的购物单，你只需要告诉我们重要度的最大的和。\n", "inputFormat": "输入的第 $1$ 行，为两个正整数，用一个空格隔开：\n\n$n,W$（其中 $W$ 表示总钱数，$n$ 为希望购买物品的个数。）\n\n从第 $2$ 行到第 $n+1$ 行，第 $j$ 行给出了编号为 $j-1$ 的物品的基本数据，每行有 $2$ 个非负整数 $v,p$（其中 $v$ 表示该物品的价格，$p$ 表示该物品的重要度）", "outputFormat": "输出只有一个正整数，为不超过总钱数的物品的重要度的总和的最大值。", "hint": "$1 \\le N \\le 100$。\n\n$1 \\le W \\le 10^9$。\n\n$1 \\le v_i \\le 10^9$。\n\n对所有的 $i=1,2,3,…,N$，$\\min(v_i) \\le v_i \\le \\min(v_i)+3$。\n\n$1 \\le p_i \\le 10^7$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Unhappy Jinming", "background": "", "description": "Jinming is very unhappy today. The family is about to get the keys to a second-hand apartment, but there is no spacious room exclusively for him. What makes him even more upset is that his mom told him yesterday: \"Which items to buy and how to arrange them is not up to you (there are many restrictions), and moreover the total must not exceed $W$ yuan.\" Early this morning, Jinming started budgeting, but there are so many things he wants to buy that he will surely exceed the $W$ yuan limit. So, he assigns to each item an integer importance $p_i$. He also looked up the price $v_i$ of each item on the Internet (all in integer yuan).\n\nAfter reviewing the shopping list, his mom requires that the range of the prices of all items on the list (the most expensive minus the cheapest) must not exceed $3$ (of course Jinming still does not know why). He hopes, under the constraint that the total cost does not exceed $W$ yuan (it can be equal to $W$), to maximize the total importance $\\sum p_i$.\n\nPlease help Jinming design a shopping list that meets the requirements. You only need to tell us the maximum possible sum of importance.", "inputFormat": "The first line contains two positive integers, separated by a space:\n$N, W$ (where $W$ is the total amount of money, and $N$ is the number of items he wants to buy).\n\nFrom line $2$ to line $N + 1$, the $j$-th line gives the basic data of the item with ID $j - 1$. Each line contains $2$ non-negative integers $v, p$ (where $v$ is the price of that item, and $p$ is its importance).", "outputFormat": "Output a single positive integer: the maximum possible sum of importance of items whose total cost does not exceed the total amount of money.", "hint": "$1 \\le N \\le 100$.\n\n$1 \\le W \\le 10^9$.\n\n$1 \\le v_i \\le 10^9$.\n\nFor all $i = 1, 2, 3, \\dots, N$, $\\min(v_i) \\le v_i \\le \\min(v_i) + 3$.\n\n$1 \\le p_i \\le 10^7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "不开心的金明", "background": "", "description": "金明今天很不开心，家里购置的二手房就要领钥匙了，房里并没有一间他自己专用的很宽敞的房间。更让他不高兴的是，妈妈昨天对他说：“你需要购买哪些物品，怎么布置，你说了不算（有很大的限制），而且不超过 $W$ 元钱。”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 $W$ 元。于是，他把每件物品规定了一个重要度整数 $p_i$ 表示。他还从因特网上查到了每件物品的价格 $v_i$（都是整数元）。\n\n妈妈看到购物单后进行了审查，要求购物单上所有的物品价格的极差（最贵的减去最便宜的）不超过 $3$（当然金明至今不知道为什么会这样）。他希望在不超过 $W$ 元（可以等于 $W$ 元）的前提下，使购买的重要度总和 $\\sum p_i$ 的最大。\n\n\n请你帮助金明设计一个满足要求的购物单，你只需要告诉我们重要度的最大的和。\n", "inputFormat": "输入的第 $1$ 行，为两个正整数，用一个空格隔开：\n\n$n,W$（其中 $W$ 表示总钱数，$n$ 为希望购买物品的个数。）\n\n从第 $2$ 行到第 $n+1$ 行，第 $j$ 行给出了编号为 $j-1$ 的物品的基本数据，每行有 $2$ 个非负整数 $v,p$（其中 $v$ 表示该物品的价格，$p$ 表示该物品的重要度）", "outputFormat": "输出只有一个正整数，为不超过总钱数的物品的重要度的总和的最大值。", "hint": "$1 \\le N \\le 100$。\n\n$1 \\le W \\le 10^9$。\n\n$1 \\le v_i \\le 10^9$。\n\n对所有的 $i=1,2,3,…,N$，$\\min(v_i) \\le v_i \\le \\min(v_i)+3$。\n\n$1 \\le p_i \\le 10^7$。\n", "locale": "zh-CN"}}}
{"pid": "P3986", "type": "P", "difficulty": 5, "samples": [["19260817", "34166325"], ["1000000000", "773877569"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "递归", "枚举", "扩展欧几里德算法", "不定方程", "Fibonacci 数列", "洛谷月赛"], "title": "斐波那契数列", "background": "", "description": "定义一个数列：\n\n\n$f(0) = a, f(1) = b, f(n) = f(n - 1) + f(n - 2)$\n\n\n其中 $a, b$ 均为正整数，$n \\geq 2$。\n\n\n问有多少种 $(a, b)$，使得 $k$ 出现在这个数列里，且不是前两项。\n\n\n由于答案可能很大，你只需要输出答案模 $10^9 + 7$ 的结果即可。\n", "inputFormat": "一行一个整数 $k$。\n", "outputFormat": "一行一个数，表示答案模 $10^9 + 7$ 的结果。\n", "hint": "$1 \\leq k \\leq 10^9$\n", "locale": "zh-CN", "translations": {"en": {"title": "Fibonacci Sequence", "background": "", "description": "Define a sequence:\n\n$f(0) = a, f(1) = b, f(n) = f(n - 1) + f(n - 2)$\n\nwhere $a, b$ are positive integers and $n \\geq 2$.\n\nHow many pairs $(a, b)$ are there such that $k$ appears in this sequence and is not one of the first two terms?\n\nSince the answer may be large, you only need to output the result modulo $10^9 + 7$.", "inputFormat": "One line containing an integer $k$.", "outputFormat": "One line containing an integer, which is the answer modulo $10^9 + 7$.", "hint": "$1 \\leq k \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "斐波那契数列", "background": "", "description": "定义一个数列：\n\n\n$f(0) = a, f(1) = b, f(n) = f(n - 1) + f(n - 2)$\n\n\n其中 $a, b$ 均为正整数，$n \\geq 2$。\n\n\n问有多少种 $(a, b)$，使得 $k$ 出现在这个数列里，且不是前两项。\n\n\n由于答案可能很大，你只需要输出答案模 $10^9 + 7$ 的结果即可。\n", "inputFormat": "一行一个整数 $k$。\n", "outputFormat": "一行一个数，表示答案模 $10^9 + 7$ 的结果。\n", "hint": "$1 \\leq k \\leq 10^9$\n", "locale": "zh-CN"}}}
{"pid": "P3987", "type": "P", "difficulty": 6, "samples": [["5 3\n1 2 3 4 5\n2 1 5\n1 1 5 2\n2 1 5", "15\n12"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000, 1280000]}, "tags": ["平衡树", "树状数组", "深度优先搜索 DFS", "洛谷月赛"], "title": "我永远喜欢珂朵莉~", "background": "http://sukasuka-anime.com/\n\n戒不掉的珂毒\n\n出不动的分块\n\n ![](https://cdn.luogu.com.cn/upload/pic/11191.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/11192.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/11193.png) \n\n哦对了有没有想买BD的珂学家啊？支持一下墨鱼吧~\n\n或者有没有人想来手办众筹啊？\n", "description": "给珂朵莉一个长为 $n$ 的非负数序列 $a$，支持以下两个操作：\n\n- $\\verb!1 l r x!$：把区间 $[l,r]$ 中所有 $x$ 的倍数除以 $x$。\n- $\\verb!2 l r!$：查询区间 $[l,r]$ 内元素的和。\n\n珂朵莉很可爱，所以你要帮珂朵莉写这个题。\n", "inputFormat": "第一行两个数表示 $n,m$。\n\n第二行 $n$ 个非负整数表示 $a_i$。\n\n之后 $m$ 行每行一个操作：\n\n- $\\verb!1 l r x!$：把区间 $[l,r]$ 中所有 $x$ 的倍数除以 $x$。\n- $\\verb!2 l r!$：查询区间 $[l,r]$ 内元素的和。\n", "outputFormat": "对于每次询问，输出一行一个数表示答案。\n", "hint": "### 数据范围及约定\n\n$1 \\le n , m \\le 10^5$，$0 \\le a_i \\le 5\\times 10^5$，$1 \\le x \\le 5\\times 10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "I Will Always Love Chtholly~", "background": "http://sukasuka-anime.com/\n\nCan't quit the Chtholly addiction.\n\nSqrt decomposition that I just can't pull off.\n\n![](https://cdn.luogu.com.cn/upload/pic/11191.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/11192.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/11193.png)\n\nOh, by the way, are there any \"Ke-ologists\" who want to buy the BD? Please support Moyu~.\n\nOr does anyone want to join a figure crowdfunding?", "description": "Give Chtholly a non-negative sequence $a$ of length $n$, supporting the following two operations:\n- $\\verb!1 l r x!$: Divide all multiples of $x$ in the interval $[l,r]$ by $x$.\n- $\\verb!2 l r!$: Query the sum of elements in the interval $[l,r]$.\n\nChtholly is very cute, so you should help her solve this problem.", "inputFormat": "The first line contains two numbers $n,m$.\n\nThe second line contains $n$ non-negative integers $a_i$.\n\nThen there are $m$ lines, each describing one operation:\n- $\\verb!1 l r x!$: Divide all multiples of $x$ in the interval $[l,r]$ by $x$.\n- $\\verb!2 l r!$: Query the sum of elements in the interval $[l,r]$.", "outputFormat": "For each query, output one line with one number denoting the answer.", "hint": "Constraints\n\n$1 \\le n , m \\le 10^5$, $0 \\le a_i \\le 5\\times 10^5$, $1 \\le x \\le 5\\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "我永远喜欢珂朵莉~", "background": "http://sukasuka-anime.com/\n\n戒不掉的珂毒\n\n出不动的分块\n\n ![](https://cdn.luogu.com.cn/upload/pic/11191.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/11192.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/11193.png) \n\n哦对了有没有想买BD的珂学家啊？支持一下墨鱼吧~\n\n或者有没有人想来手办众筹啊？\n", "description": "给珂朵莉一个长为 $n$ 的非负数序列 $a$，支持以下两个操作：\n\n- $\\verb!1 l r x!$：把区间 $[l,r]$ 中所有 $x$ 的倍数除以 $x$。\n- $\\verb!2 l r!$：查询区间 $[l,r]$ 内元素的和。\n\n珂朵莉很可爱，所以你要帮珂朵莉写这个题。\n", "inputFormat": "第一行两个数表示 $n,m$。\n\n第二行 $n$ 个非负整数表示 $a_i$。\n\n之后 $m$ 行每行一个操作：\n\n- $\\verb!1 l r x!$：把区间 $[l,r]$ 中所有 $x$ 的倍数除以 $x$。\n- $\\verb!2 l r!$：查询区间 $[l,r]$ 内元素的和。\n", "outputFormat": "对于每次询问，输出一行一个数表示答案。\n", "hint": "### 数据范围及约定\n\n$1 \\le n , m \\le 10^5$，$0 \\le a_i \\le 5\\times 10^5$，$1 \\le x \\le 5\\times 10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P3988", "type": "P", "difficulty": 4, "samples": [["4\n2\n0\n3\n2", "3\n4\n2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2013", "线段树", "各省省选", "平衡树", "树状数组", "上海"], "title": "[SHOI2013] 发牌", "background": "", "description": "在一些扑克游戏里，如德州扑克，发牌是有讲究的。一般称呼专业的发牌手为荷官。荷官在发牌前，先要销牌（burn card）。所谓销牌，就是把当前在牌库顶的那一张牌移动到牌库底，它用来防止玩家猜牌而影响游戏。\n\n假设一开始，荷官拿出了一副新牌，这副牌有 $N$ 张不同的牌，编号依次为 $1$ 到 $N$。由于是新牌，所以牌是按照顺序排好的，从牌库顶开始，依次为 $1,2,\\cdots,N$，$N$ 号牌在牌库底。为了发完所有的牌，荷官会进行 $N$ 次发牌操作，在第 $i$ 次发牌之前，他会连续进行 $R_i$ 次销牌操作，$R_i$ 由输入给定。请问最后玩家拿到这副牌的顺序是什么样的？\n\n举个例子，假设 $N=4$，则一开始的时候，牌库中牌的构成顺序为 $1,2,3,4$。\n\n- 假设 $R_1=2$，则荷官应该连销两次牌，将 $1$ 和 $2$ 放入牌库底，再将 $3$ 发给玩家。目前牌库中的牌顺序为 $4,1,2$。\n- 假设 $R_2=0$，荷官不需要销牌，直接将 $4$ 发给玩家，目前牌库中的牌顺序为 $1,2$。\n- 假设 $R_3=3$，则荷官依次销去了 $1,2,1$，再将 $2$ 发给了玩家。目前牌库仅剩下一张牌 $1$。\n- 假设 $R_4=2$，荷官在重复销去两次 $1$ 之后，还是将 $1$ 发给了玩家，这是因为 $1$ 是牌库中唯一的一张牌。", "inputFormat": "第一行，一个整数 $N$，表示牌的数量。\n\n第二行到第 $N+1$ 行，在第 $i+1$ 行，有一个整数 $R_i$。\n", "outputFormat": "共 $N$ 行，第 $i$ 行有一个整数，表示玩家收到的第 $i$ 张牌的编号。", "hint": "#### 数据规模与约定\n\n对于 $100 \\%$ 的数据，$0 \\le R_i < N$。  \n\n| 测试点编号 | $N=$ | 测试点编号 | $N=$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $5\\times 10^3$ | $6$ | $3\\times 10^5$ |\n| $2$ | $10^4$ |  $7$ | $4\\times 10^5$ |\n| $3$ | $5\\times 10^4$ | $8$ | $5\\times 10^5$ |\n| $4$ | $10^5$ | $9$ | $6\\times 10^5$ |\n| $5$ | $2\\times 10^5$ | $10$ | $7\\times 10^5$ |", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2013] Dealing Cards", "background": "", "description": "In some poker games, such as Texas hold'em, dealing has its own rules. The professional dealer is commonly called the dealer. Before dealing, the dealer needs to burn a card (burn card). Burning means moving the current top card of the deck to the bottom of the deck. This helps prevent players from guessing cards and affecting the game.\n\nSuppose at the start, the dealer takes out a new deck with $N$ distinct cards labeled from $1$ to $N$. Since it is a new deck, the cards are in order from the top of the deck as $1, 2, \\cdots, N$, with card $N$ at the bottom. To deal all cards, the dealer performs $N$ dealing operations. Before the $i$-th deal, he performs $R_i$ consecutive burn operations, where $R_i$ is given in the input. What is the final order of the cards received by the player?\n\nFor example, suppose $N=4$. Initially, the deck order is $1,2,3,4$.\n\n- Suppose $R_1=2$. The dealer burns twice, moves $1$ and $2$ to the bottom, then deals $3$ to the player. The current deck order is $4,1,2$.\n- Suppose $R_2=0$. The dealer does not burn and directly deals $4$ to the player. The current deck order is $1,2$.\n- Suppose $R_3=3$. The dealer burns $1,2,1$ in order, then deals $2$ to the player. The deck now has only one card left, $1$.\n- Suppose $R_4=2$. After burning $1$ twice again, the dealer still deals $1$ to the player because $1$ is the only card in the deck.", "inputFormat": "The first line contains an integer $N$, the number of cards.\n\nFrom the second line to line $N+1$, the $(i+1)$-th line contains an integer $R_i$.", "outputFormat": "Output $N$ lines. On the $i$-th line, output one integer, the label of the $i$-th card received by the player.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $0 \\le R_i < N$.\n\n| Test point ID | $N=$ | Test point ID | $N=$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $5\\times 10^3$ | $6$ | $3\\times 10^5$ |\n| $2$ | $10^4$ |  $7$ | $4\\times 10^5$ |\n| $3$ | $5\\times 10^4$ | $8$ | $5\\times 10^5$ |\n| $4$ | $10^5$ | $9$ | $6\\times 10^5$ |\n| $5$ | $2\\times 10^5$ | $10$ | $7\\times 10^5$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2013] 发牌", "background": "", "description": "在一些扑克游戏里，如德州扑克，发牌是有讲究的。一般称呼专业的发牌手为荷官。荷官在发牌前，先要销牌（burn card）。所谓销牌，就是把当前在牌库顶的那一张牌移动到牌库底，它用来防止玩家猜牌而影响游戏。\n\n假设一开始，荷官拿出了一副新牌，这副牌有 $N$ 张不同的牌，编号依次为 $1$ 到 $N$。由于是新牌，所以牌是按照顺序排好的，从牌库顶开始，依次为 $1,2,\\cdots,N$，$N$ 号牌在牌库底。为了发完所有的牌，荷官会进行 $N$ 次发牌操作，在第 $i$ 次发牌之前，他会连续进行 $R_i$ 次销牌操作，$R_i$ 由输入给定。请问最后玩家拿到这副牌的顺序是什么样的？\n\n举个例子，假设 $N=4$，则一开始的时候，牌库中牌的构成顺序为 $1,2,3,4$。\n\n- 假设 $R_1=2$，则荷官应该连销两次牌，将 $1$ 和 $2$ 放入牌库底，再将 $3$ 发给玩家。目前牌库中的牌顺序为 $4,1,2$。\n- 假设 $R_2=0$，荷官不需要销牌，直接将 $4$ 发给玩家，目前牌库中的牌顺序为 $1,2$。\n- 假设 $R_3=3$，则荷官依次销去了 $1,2,1$，再将 $2$ 发给了玩家。目前牌库仅剩下一张牌 $1$。\n- 假设 $R_4=2$，荷官在重复销去两次 $1$ 之后，还是将 $1$ 发给了玩家，这是因为 $1$ 是牌库中唯一的一张牌。", "inputFormat": "第一行，一个整数 $N$，表示牌的数量。\n\n第二行到第 $N+1$ 行，在第 $i+1$ 行，有一个整数 $R_i$。\n", "outputFormat": "共 $N$ 行，第 $i$ 行有一个整数，表示玩家收到的第 $i$ 张牌的编号。", "hint": "#### 数据规模与约定\n\n对于 $100 \\%$ 的数据，$0 \\le R_i < N$。  \n\n| 测试点编号 | $N=$ | 测试点编号 | $N=$ |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $5\\times 10^3$ | $6$ | $3\\times 10^5$ |\n| $2$ | $10^4$ |  $7$ | $4\\times 10^5$ |\n| $3$ | $5\\times 10^4$ | $8$ | $5\\times 10^5$ |\n| $4$ | $10^5$ | $9$ | $6\\times 10^5$ |\n| $5$ | $2\\times 10^5$ | $10$ | $7\\times 10^5$ |", "locale": "zh-CN"}}}
{"pid": "P3989", "type": "P", "difficulty": 6, "samples": [["2\n2\nbbaa\n2\naba", "NO\nYES"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "各省省选", "上海"], "title": "[SHOI2013] 阶乘字符串", "background": "shoi2013d1t2\n\n（本题卡常数注意）\n", "description": "给定一个由前 $n$ 个小写字母组成的串 $S$。串 $S$ 是阶乘字符串当且仅当前 $n$ 个小写字母的全排列（共 $n!$ 种）都作为的子序列（可以不连续）出现。\n\n由这个定义出发，可以得到一个简单的枚举法去验证，但是它实在太慢了。所以现在请你设计一个算法，在 $1$ 秒内判断出给定的串是否是阶乘字符串。", "inputFormat": "输入第 $1$ 行一个整数 $T$，表示这个文件中会有 $T$ 组数据。\n\n接下来分 $T$ 个块，每块 $2$ 行：\n\n- 第 $1$ 行一个正整数 $n$，表示 $S$ 由前 $n$ 个小写字母组成。\n- 第 $2$ 行一个字符串 $s$。", "outputFormat": "对于每组数据，分别输出一行。每行是 `YES` 或者 `NO`，表示该数据对应的串 $S$ 是否是阶乘字符串。", "hint": "第一组数据中，`ab` 这个串没有作为子序列出现。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9zs871wl.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2013] Factorial String", "background": "shoi2013d1t2\n\n(Note: Be careful with constant factors.)", "description": "Given a string $S$ composed of the first $n$ lowercase letters. The string $S$ is a factorial string if and only if every permutation of the first $n$ lowercase letters (in total $n!$ permutations) appears as a subsequence (not necessarily contiguous).\n\nFrom this definition, a simple enumeration can be used to verify it, but it is far too slow. Please design an algorithm to determine within $1$ second whether the given string is a factorial string.", "inputFormat": "The first line contains an integer $T$, indicating that there are $T$ test cases in this file.\n\nThen $T$ blocks follow, each with $2$ lines:\n- Line $1$: a positive integer $n$, indicating that $S$ is composed of the first $n$ lowercase letters.\n- Line $2$: a string $s$.", "outputFormat": "For each test case, output one line: `YES` or `NO`, indicating whether the corresponding string $S$ is a factorial string.", "hint": "In the first test case, the string `ab` does not appear as a subsequence.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9zs871wl.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2013] 阶乘字符串", "background": "shoi2013d1t2\n\n（本题卡常数注意）\n", "description": "给定一个由前 $n$ 个小写字母组成的串 $S$。串 $S$ 是阶乘字符串当且仅当前 $n$ 个小写字母的全排列（共 $n!$ 种）都作为的子序列（可以不连续）出现。\n\n由这个定义出发，可以得到一个简单的枚举法去验证，但是它实在太慢了。所以现在请你设计一个算法，在 $1$ 秒内判断出给定的串是否是阶乘字符串。", "inputFormat": "输入第 $1$ 行一个整数 $T$，表示这个文件中会有 $T$ 组数据。\n\n接下来分 $T$ 个块，每块 $2$ 行：\n\n- 第 $1$ 行一个正整数 $n$，表示 $S$ 由前 $n$ 个小写字母组成。\n- 第 $2$ 行一个字符串 $s$。", "outputFormat": "对于每组数据，分别输出一行。每行是 `YES` 或者 `NO`，表示该数据对应的串 $S$ 是否是阶乘字符串。", "hint": "第一组数据中，`ab` 这个串没有作为子序列出现。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9zs871wl.png)\n", "locale": "zh-CN"}}}
{"pid": "P3990", "type": "P", "difficulty": 6, "samples": [["3 5", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2013", "各省省选", "上海", "前缀和", "矩阵乘法", "构造"], "title": "[SHOI2013] 超级跳马", "background": "", "description": "现有一个 $n$ 行 $m$ 列的棋盘，一只马欲从棋盘的左上角跳到右下角。每一步它向右跳奇数列，且跳到本行或相邻行。跳越期间，马不能离开棋盘。例如，当 $n = 3$，$m = 10$ 时，下图是一种可行的跳法。\n\n![](https://cdn.luogu.com.cn/upload/pic/9367.png) \n\n试求跳法种数对 $30\\,011$ 取模的结果。", "inputFormat": "仅有一行，包含两个正整数 $n, m$，表示棋盘的规模。", "outputFormat": "仅有一行，包含一个整数，即跳法种数模 $30\\,011$ 后的结果。\n", "hint": "- 对于 $10\\%$ 的数据，$1 \\leq n \\leq 10$，$2 \\leq m \\leq 10$；\n- 对于 $50\\%$ 的数据，$1 \\leq n \\leq 10$，$2 ≤ m ≤ 10^5$；\n- 对于 $80\\%$ 的数据，$1 \\leq n \\leq 10$，$2 \\leq m \\leq 10^9$；\n- 对于 $100\\%$ 的数据，$1 \\leq n \\leq 50$，$2 \\leq m \\leq 10^9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2013] Super Jumping Knight", "background": "", "description": "Given an $n$-row by $m$-column board, a knight wants to jump from the top-left corner to the bottom-right corner. At each step, it jumps to the right by an odd number of columns and lands in the same row or an adjacent row. During the jump, the knight must not leave the board. For example, when $n = 3$, $m = 10$, the figure below shows a valid sequence of jumps.\n\n![](https://cdn.luogu.com.cn/upload/pic/9367.png)\n\nFind the number of different jump sequences modulo $30\\,011$.", "inputFormat": "A single line containing two positive integers $n$, $m$, representing the size of the board.", "outputFormat": "Output a single line containing one integer, the number of jump sequences modulo $30\\,011$.", "hint": "- For $10\\%$ of the testdata, $1 \\leq n \\leq 10$, $2 \\leq m \\leq 10$.\n- For $50\\%$ of the testdata, $1 \\leq n \\leq 10$, $2 \\leq m \\leq 10^5$.\n- For $80\\%$ of the testdata, $1 \\leq n \\leq 10$, $2 \\leq m \\leq 10^9$.\n- For $100\\%$ of the testdata, $1 \\leq n \\leq 50$, $2 \\leq m \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2013] 超级跳马", "background": "", "description": "现有一个 $n$ 行 $m$ 列的棋盘，一只马欲从棋盘的左上角跳到右下角。每一步它向右跳奇数列，且跳到本行或相邻行。跳越期间，马不能离开棋盘。例如，当 $n = 3$，$m = 10$ 时，下图是一种可行的跳法。\n\n![](https://cdn.luogu.com.cn/upload/pic/9367.png) \n\n试求跳法种数对 $30\\,011$ 取模的结果。", "inputFormat": "仅有一行，包含两个正整数 $n, m$，表示棋盘的规模。", "outputFormat": "仅有一行，包含一个整数，即跳法种数模 $30\\,011$ 后的结果。\n", "hint": "- 对于 $10\\%$ 的数据，$1 \\leq n \\leq 10$，$2 \\leq m \\leq 10$；\n- 对于 $50\\%$ 的数据，$1 \\leq n \\leq 10$，$2 ≤ m ≤ 10^5$；\n- 对于 $80\\%$ 的数据，$1 \\leq n \\leq 10$，$2 \\leq m \\leq 10^9$；\n- 对于 $100\\%$ 的数据，$1 \\leq n \\leq 50$，$2 \\leq m \\leq 10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P3991", "type": "P", "difficulty": 6, "samples": [["5\n0 25 37 46 2\n1 32 14 16 3\n3 99 77 88 4\n2 43 68 57 5\n14 72 36 18 6\n", "92\n75\n396\n319\n432"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "2017", "各省省选", "平衡树", "北京", "O2优化", "分治", "矩阵加速", "动态 DP"], "title": "[BJOI2017] 喷式水战改", "background": "拿到了飞机的驾照(?)，这样补给就不愁了\n\nXXXX年XX月XX日\n\n拿到了喷气机(??)的驾照，这样就飞得更快了\n\nXXXX年XX月XX日\n\n拿到了攻击机(???)的驾照（不存在的）\n\nXXXX年XX月XX日\n\n用铅版做夹层的话，机身可是会变重的呢\n\nXXXX年XX月XX日\n\n幸酱的特制快递，精确投递到了目标地点\n\n-------------------------------------\n\n又是核平的一天。\n\n天音正在给喷气机做保养，并充填燃料。\n\n这种喷气机是某姬(?????)特别制作的，发动机拥有三种工作状态\n\n1、通常型（Original）：在高空平飞或隐蔽飞行时进行的低功耗高效率工作状态\n\n2、后期型（Extended）：为在俯冲时最大化能量利用率而特别改造过的工作状态\n\n3、增强型（Enhanced）：在俯冲攻击结束后为产生极限扭力抬高高度的工作状态\n\n在一次攻击中，喷气机将会经历\"通常-后期-增强-通常\"的工作流程\n\n不同工作状态中，燃料的利用效率是不同的\n\n现在天音正在调整喷气机燃料装填序列\n\n你需要做的就是求出燃料能产生的最大总能量\n\n为什么是你？\n\n和平还是核平，选一个吧", "description": "初始燃料序列为空。每次操作会向序列中的 $p _ i$ 位置添加 $x _ i$ 单位的同种燃料，该燃料每一单位在三种工作状态下能产生的能量分别为 $a _ i, b _ i, c _ i$。\n\n添加的位置 $p _ i$ 是指，在添加后，加入的第一个单位燃料前面有 $p _ i$ 个单位的原燃料。\n\n全部的 $x _ i$ 单位燃料依次放置，然后原来在 $p _ i$ 位置的燃料（如果有的话）依次向后排列。\n\n对于一个确定的燃料序列，其能产生的最大总能量为：将序列依次分成\"通常-后期-增强-通常\"四段（每段可以为空），每一段在对应工作状态下产生的能量之和的最大值。\n\n对于每次添加操作，你需要给出该次操作使得最大总能量增加了多少。\n\n如果对于这种计算方式没有直观的感受，可以查看样例说明。", "inputFormat": "第一行一个数 $n$，表示操作个数。\n\n接下来 $n$ 行，每行 $5$ 个数 $p _ i, a _ i, b _ i, c _ i, x _ i$，空格分隔，表示向序列中的 $p _ i$ 位置添加 $x _ i$ 单位的同种燃料\n\n这种燃料每单位在通常、后期、增强工作状态下产生的能量分别为 $a _ i, b _ i, c _ i$。", "outputFormat": "$n$ 行，每行一个数，表示该次操作后能量序列所能产生的最大总能量增加了多少。", "hint": "第一次操作后，燃料序列为 `[1 1]`，最大能量发生方式为 `[En1 En1]`，共 $46+46=92$。\n\n第二次操作后，燃料序列为 `[1 2 2 2 1]`，最大能量发生方式为 `[Or1 Or2 Or2 Or2 En1]`，共 $25+32+32+32+46=167$，增加了 $167-92=75$。\n\n第三次操作后，燃料序列为 `[1 2 2 3 3 3 3 2 1]`，最大能量发生方式为 `[Or1 Or2 Or2 Or3 Or3 Or3 Or3 Or2 En1]`，增加了 $99\\times 4=396$。\n\n第四次操作后，燃料序列为 `[1 2 4 4 4 4 4 2 3 3 3 3 2 1]`，最大能量发生方式为 `[Or1 Or2 Ex4 Ex4 Ex4 Ex4 Ex4 Or2 Or3 Or3 Or3 Or3 Or2 Or1]`。\n\n第五次操作后，燃料序列为 `[1 2 4 4 4 4 4 2 3 3 3 3 2 1 5 5 5 5 5 5]`，最大能量发生方式为 `[Or1 Or2 Ex4 Ex4 Ex4 Ex4 Ex4 Or2 Or3 Or3 Or3 Or3 Or2 Or1 Or5 Or5 Or5 Or5 Or5 Or5]`。\n\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^5$, $1 \\leq a_i, b_i, c_i \\leq 10^4$， $1 \\leq x_i \\leq 10^9$。\n\n对于 $100\\%$ 的数据，保证插入时序列中至少已有 $p _ i$ 单位的燃料。\n\n后 $50\\%$ 数据有梯度。", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2017] Jet Water War Kai", "background": "Got a pilot license for airplanes (?), so resupply is no longer a problem.\n\nXXXX year XX month XX day.\n\nGot a pilot license for jets (??), so I can fly even faster.\n\nXXXX year XX month XX day.\n\nGot a pilot license for attack aircraft (???), which does not exist.\n\nXXXX year XX month XX day.\n\nIf you use lead plates for the sandwich structure, the fuselage will get heavier.\n\nXXXX year XX month XX day.\n\nKou-chan’s special delivery was precisely dropped on the target.\n\n-------------------------------------\n\nAnother day of “nuke-peace.”\n\nAmane is doing maintenance on the jet and refueling it.\n\nThis jet was specially made by a certain “mou ji” (某姬). Its engine has three operating states:\n\n1. Original: a low-power, high-efficiency state used for high-altitude level flight or stealth flight.\n\n2. Extended: a state specially modified to maximize energy utilization during a dive.\n\n3. Enhanced: a state used after a diving attack to generate extreme torque and regain altitude.\n\nIn one attack, the jet will go through the workflow “Original → Extended → Enhanced → Original.”\n\nFuel utilization efficiency differs across states.\n\nAmane is now tuning the jet’s fuel loading sequence.\n\nYour task is to compute the maximum total energy the fuel can produce.\n\nWhy you? Choose one: peace or “nuke-peace.”", "description": "The initial fuel sequence is empty. Each operation inserts $x _ i$ units of the same type of fuel at position $p _ i$ in the sequence. For this fuel, each unit can produce energy $a _ i, b _ i, c _ i$ in the three operating states, respectively.\n\nThe position $p _ i$ means that, after insertion, there are $p _ i$ units of the original fuel in front of the first inserted unit.\n\nAll $x _ i$ units are placed consecutively. Then the fuel that originally started at position $p _ i$ (if any) is shifted backward in order.\n\nFor a fixed fuel sequence, its maximum total energy is defined as follows: split the sequence into four consecutive segments in the order “Original → Extended → Enhanced → Original” (each segment may be empty). The total energy is the sum, over all units, of the energy corresponding to the state of the segment they belong to. Take the maximum value over all such splits.\n\nFor each insertion operation, output by how much the maximum total energy increases due to this operation.\n\nIf this calculation is not intuitive, see the sample explanation.", "inputFormat": "The first line contains an integer $n$, the number of operations.\n\nEach of the next $n$ lines contains $5$ integers $p _ i, a _ i, b _ i, c _ i, x _ i$, separated by spaces, indicating that $x _ i$ units of the same fuel are inserted at position $p _ i$ in the sequence.\n\nFor this fuel, each unit produces $a _ i, b _ i, c _ i$ energy in the Original, Extended, and Enhanced states, respectively.", "outputFormat": "Output $n$ lines. Each line contains a single integer, the increase in the maximum total energy after that operation.", "hint": "After the first operation, the fuel sequence is “[1 1]”. The way to achieve maximum energy is “[En1 En1]”, totaling $46+46=92$.\n\nAfter the second operation, the fuel sequence is “[1 2 2 2 1]”. The way to achieve maximum energy is “[Or1 Or2 Or2 Or2 En1]”, totaling $25+32+32+32+46=167$, increased by $167-92=75$.\n\nAfter the third operation, the fuel sequence is “[1 2 2 3 3 3 3 2 1]”. The way to achieve maximum energy is “[Or1 Or2 Or2 Or3 Or3 Or3 Or3 Or2 En1]”, increased by $99\\times 4=396$.\n\nAfter the fourth operation, the fuel sequence is “[1 2 4 4 4 4 4 2 3 3 3 3 2 1]”. The way to achieve maximum energy is “[Or1 Or2 Ex4 Ex4 Ex4 Ex4 Ex4 Or2 Or3 Or3 Or3 Or3 Or2 Or1]”.\n\nAfter the fifth operation, the fuel sequence is “[1 2 4 4 4 4 4 2 3 3 3 3 2 1 5 5 5 5 5 5]”. The way to achieve maximum energy is “[Or1 Or2 Ex4 Ex4 Ex4 Ex4 Ex4 Or2 Or3 Or3 Or3 Or3 Or2 Or1 Or5 Or5 Or5 Or5 Or5 Or5]”.\n\nFor $100\\%$ of the testdata, $1 \\leq n \\leq 10^5$, $1 \\leq a_i, b_i, c_i \\leq 10^4$, $1 \\leq x_i \\leq 10^9$.\n\nFor $100\\%$ of the testdata, it is guaranteed that at the time of insertion there are at least $p _ i$ units of fuel already in the sequence.\n\nThe remaining $50\\%$ of the testdata has graded difficulty.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2017] 喷式水战改", "background": "拿到了飞机的驾照(?)，这样补给就不愁了\n\nXXXX年XX月XX日\n\n拿到了喷气机(??)的驾照，这样就飞得更快了\n\nXXXX年XX月XX日\n\n拿到了攻击机(???)的驾照（不存在的）\n\nXXXX年XX月XX日\n\n用铅版做夹层的话，机身可是会变重的呢\n\nXXXX年XX月XX日\n\n幸酱的特制快递，精确投递到了目标地点\n\n-------------------------------------\n\n又是核平的一天。\n\n天音正在给喷气机做保养，并充填燃料。\n\n这种喷气机是某姬(?????)特别制作的，发动机拥有三种工作状态\n\n1、通常型（Original）：在高空平飞或隐蔽飞行时进行的低功耗高效率工作状态\n\n2、后期型（Extended）：为在俯冲时最大化能量利用率而特别改造过的工作状态\n\n3、增强型（Enhanced）：在俯冲攻击结束后为产生极限扭力抬高高度的工作状态\n\n在一次攻击中，喷气机将会经历\"通常-后期-增强-通常\"的工作流程\n\n不同工作状态中，燃料的利用效率是不同的\n\n现在天音正在调整喷气机燃料装填序列\n\n你需要做的就是求出燃料能产生的最大总能量\n\n为什么是你？\n\n和平还是核平，选一个吧", "description": "初始燃料序列为空。每次操作会向序列中的 $p _ i$ 位置添加 $x _ i$ 单位的同种燃料，该燃料每一单位在三种工作状态下能产生的能量分别为 $a _ i, b _ i, c _ i$。\n\n添加的位置 $p _ i$ 是指，在添加后，加入的第一个单位燃料前面有 $p _ i$ 个单位的原燃料。\n\n全部的 $x _ i$ 单位燃料依次放置，然后原来在 $p _ i$ 位置的燃料（如果有的话）依次向后排列。\n\n对于一个确定的燃料序列，其能产生的最大总能量为：将序列依次分成\"通常-后期-增强-通常\"四段（每段可以为空），每一段在对应工作状态下产生的能量之和的最大值。\n\n对于每次添加操作，你需要给出该次操作使得最大总能量增加了多少。\n\n如果对于这种计算方式没有直观的感受，可以查看样例说明。", "inputFormat": "第一行一个数 $n$，表示操作个数。\n\n接下来 $n$ 行，每行 $5$ 个数 $p _ i, a _ i, b _ i, c _ i, x _ i$，空格分隔，表示向序列中的 $p _ i$ 位置添加 $x _ i$ 单位的同种燃料\n\n这种燃料每单位在通常、后期、增强工作状态下产生的能量分别为 $a _ i, b _ i, c _ i$。", "outputFormat": "$n$ 行，每行一个数，表示该次操作后能量序列所能产生的最大总能量增加了多少。", "hint": "第一次操作后，燃料序列为 `[1 1]`，最大能量发生方式为 `[En1 En1]`，共 $46+46=92$。\n\n第二次操作后，燃料序列为 `[1 2 2 2 1]`，最大能量发生方式为 `[Or1 Or2 Or2 Or2 En1]`，共 $25+32+32+32+46=167$，增加了 $167-92=75$。\n\n第三次操作后，燃料序列为 `[1 2 2 3 3 3 3 2 1]`，最大能量发生方式为 `[Or1 Or2 Or2 Or3 Or3 Or3 Or3 Or2 En1]`，增加了 $99\\times 4=396$。\n\n第四次操作后，燃料序列为 `[1 2 4 4 4 4 4 2 3 3 3 3 2 1]`，最大能量发生方式为 `[Or1 Or2 Ex4 Ex4 Ex4 Ex4 Ex4 Or2 Or3 Or3 Or3 Or3 Or2 Or1]`。\n\n第五次操作后，燃料序列为 `[1 2 4 4 4 4 4 2 3 3 3 3 2 1 5 5 5 5 5 5]`，最大能量发生方式为 `[Or1 Or2 Ex4 Ex4 Ex4 Ex4 Ex4 Or2 Or3 Or3 Or3 Or3 Or2 Or1 Or5 Or5 Or5 Or5 Or5 Or5]`。\n\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^5$, $1 \\leq a_i, b_i, c_i \\leq 10^4$， $1 \\leq x_i \\leq 10^9$。\n\n对于 $100\\%$ 的数据，保证插入时序列中至少已有 $p _ i$ 单位的燃料。\n\n后 $50\\%$ 数据有梯度。", "locale": "zh-CN"}}}
{"pid": "P3992", "type": "P", "difficulty": 7, "samples": [["2\n1 2\n3 4\n1\n1 3\n", "4\n2\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2017", "各省省选", "北京", "O2优化", "排序", "前缀和", "分块"], "title": "[BJOI2017] 开车", "background": "", "description": "有 $n$ 辆车，分别在 $a_1, a_2, \\ldots , a_n$ 位置和 $n$ 个加油站，分别在 $b_1, b_2, \\ldots ,b_n$ 位置。\n\n每个加油站只能支持一辆车的加油，所以你要把这些车开到不同的加油站加油。一个车从 $x$ 位置开到 $y$ 位置的代价为 $|x-y|$，问如何安排车辆，使得代价之和最小。\n\n同时你有 $q$ 个操作，每次操作会修改第 $i$ 辆车的位置到 $x$，你要回答每次修改操作之后最优安排方案的总代价。\n", "inputFormat": "第一行一个正整数 $n$。\n\n接下来一行 $n$ 个整数 $a_1, a_2,\\ldots,a_n$。\n\n接下来一行 $n$ 个整数 $b_1, b_2,\\ldots,b_n$。\n\n接下来一行一个正整数 $q$，表示操作的个数。\n\n接下来 $q$ 行，每行有两个整数 $i$（$1\\leq i\\leq n$）和 $x$，表示将i这辆车开到 $x$ 位置的操作。\n\n所有的车和加油站的范围一直在 $0$ 到 $10^9$ 之间。\n", "outputFormat": "共 $q+1$ 行，第一行表示一开始的最优代价。\n\n接下来 $q$ 行，第 $i$ 行表示操作 $i$ 之后的最优代价。\n", "hint": "【样例解释】\n\n一开始将第一辆车开到位置 $4$，将第二辆车开到位置 $3$，代价为 $|4-1|+|3-2|=4$。\n\n修改后第一辆车的位置变成 $3$，代价为 $|3-3|+|4-2|=2$。\n\n|测试点|数据范围|\n|:-:|:-:|\n|$1$| $n\\leq 10^3$，$q=0$|\n|$2$| $n\\leq 10^3$，$q\\leq 10^3$|\n|$3$| $n\\leq 10^4$，$q\\leq 10^4$|\n|$4$| $n\\leq 5\\times 10^4$，$q=0$|\n|$5\\sim 6$| $n\\leq 3\\times 10^4$，$q\\leq 3\\times 10^4$|\n|$7\\sim 10$| $n\\leq 5\\times 10^4$，$q\\leq 5\\times 10^4$|\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 5\\times 10^4$，$0\\leq q\\leq 5\\times 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2017] Driving", "background": "", "description": "There are $n$ cars located at positions $a_1, a_2, \\ldots, a_n$, and $n$ gas stations located at positions $b_1, b_2, \\ldots, b_n$.\n\nEach gas station can serve at most one car, so you must drive the cars to distinct gas stations. The cost for a car to drive from position $x$ to position $y$ is $|x - y|$. Find an assignment that minimizes the sum of costs.\n\nYou are also given $q$ operations. In each operation, the position of the $i$-th car is updated to $x$. After each update, you need to output the minimal total cost of an optimal assignment.", "inputFormat": "The first line contains a positive integer $n$.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$.\n\nThe third line contains $n$ integers $b_1, b_2, \\ldots, b_n$.\n\nThe fourth line contains a positive integer $q$, the number of operations.\n\nEach of the next $q$ lines contains two integers $i$ ($1 \\le i \\le n$) and $x$, indicating that the position of car $i$ is updated to $x$.\n\nAll car and gas station positions are always within $0$ to $10^9$.", "outputFormat": "Output $q + 1$ lines. The first line is the minimal total cost before any operations.\n\nThen output $q$ lines, where the $i$-th line is the minimal total cost after operation $i$.", "hint": "Sample explanation:\n\nInitially, drive the first car to position $4$ and the second car to position $3$, with a total cost of $|4 - 1| + |3 - 2| = 4$.\n\nAfter the update, the first car’s position becomes $3$, and the total cost is $|3 - 3| + |4 - 2| = 2$.\n\n| Test points | Constraints |\n|:-:|:-:|\n| $1$ | $n \\le 10^3$, $q = 0$ |\n| $2$ | $n \\le 10^3$, $q \\le 10^3$ |\n| $3$ | $n \\le 10^4$, $q \\le 10^4$ |\n| $4$ | $n \\le 5 \\times 10^4$, $q = 0$ |\n| $5 \\sim 6$ | $n \\le 3 \\times 10^4$, $q \\le 3 \\times 10^4$ |\n| $7 \\sim 10$ | $n \\le 5 \\times 10^4$, $q \\le 5 \\times 10^4$ |\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 5 \\times 10^4$, $0 \\le q \\le 5 \\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2017] 开车", "background": "", "description": "有 $n$ 辆车，分别在 $a_1, a_2, \\ldots , a_n$ 位置和 $n$ 个加油站，分别在 $b_1, b_2, \\ldots ,b_n$ 位置。\n\n每个加油站只能支持一辆车的加油，所以你要把这些车开到不同的加油站加油。一个车从 $x$ 位置开到 $y$ 位置的代价为 $|x-y|$，问如何安排车辆，使得代价之和最小。\n\n同时你有 $q$ 个操作，每次操作会修改第 $i$ 辆车的位置到 $x$，你要回答每次修改操作之后最优安排方案的总代价。\n", "inputFormat": "第一行一个正整数 $n$。\n\n接下来一行 $n$ 个整数 $a_1, a_2,\\ldots,a_n$。\n\n接下来一行 $n$ 个整数 $b_1, b_2,\\ldots,b_n$。\n\n接下来一行一个正整数 $q$，表示操作的个数。\n\n接下来 $q$ 行，每行有两个整数 $i$（$1\\leq i\\leq n$）和 $x$，表示将i这辆车开到 $x$ 位置的操作。\n\n所有的车和加油站的范围一直在 $0$ 到 $10^9$ 之间。\n", "outputFormat": "共 $q+1$ 行，第一行表示一开始的最优代价。\n\n接下来 $q$ 行，第 $i$ 行表示操作 $i$ 之后的最优代价。\n", "hint": "【样例解释】\n\n一开始将第一辆车开到位置 $4$，将第二辆车开到位置 $3$，代价为 $|4-1|+|3-2|=4$。\n\n修改后第一辆车的位置变成 $3$，代价为 $|3-3|+|4-2|=2$。\n\n|测试点|数据范围|\n|:-:|:-:|\n|$1$| $n\\leq 10^3$，$q=0$|\n|$2$| $n\\leq 10^3$，$q\\leq 10^3$|\n|$3$| $n\\leq 10^4$，$q\\leq 10^4$|\n|$4$| $n\\leq 5\\times 10^4$，$q=0$|\n|$5\\sim 6$| $n\\leq 3\\times 10^4$，$q\\leq 3\\times 10^4$|\n|$7\\sim 10$| $n\\leq 5\\times 10^4$，$q\\leq 5\\times 10^4$|\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 5\\times 10^4$，$0\\leq q\\leq 5\\times 10^4$。", "locale": "zh-CN"}}}
{"pid": "P3993", "type": "P", "difficulty": 7, "samples": [["6\n1\n2\n3\n4\n5\n6\n", "0\n-1\n-1\n-1\n-1\n9\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "各省省选", "北京", "生成函数"], "title": "[BJOI2017] 同构", "background": "", "description": "你有 $n$ 个点，你可以在这 $n$ 个点之间连无向边，两个点之间至多只能连一条边，也不允许连自环，问至多能连多少条边。\n\n但这个问题的答案显然是 $\\dfrac{n(n-1)}{2}$ 条。所以有一个额外的限制，要求这个图不存在非平凡的自同构。\n\n一个图 $G$ 有非平凡的自同构定义为存在一个 $1$ 到 $n$ 的置换 $p(1)$ 到 $p(n)$ 满足对于所有点 $u,v$，$(u, v)$ 之间有边当且仅当 $(p(u), p(v))$ 之间有边，并且这个置换非平凡也就是存在一个点 $u$ 使得 $p(u) \\ne u$。\n\n比如对于一个 $5$ 个点的图 $(1,2),(2,3),(3,4),(4,5),(5,1),(1,3)$，那么 $p(1)=3$，$p(2)=2$，$p(3)=1$，$p(4)=5$，$p(5)=4$ 为这个图的一个非平凡的自同构。\n\n你要回答一个 $n$ 个点的无向简单的不存在非平凡自同构的图最多有多少条边，如果答案不存在，即不存在 $n$ 个点满足条件的图，请输出 `-1`，否则输出答案对 $10^9+7$ 取模的结果。", "inputFormat": "**本题有多组数据。**   \n一行一个正整数 $T$ 表示数据组数。   \n对于每组数据：   \n一个正整数 $n$ 表示你要回答的图的点的个数。", "outputFormat": "对于每组数据：   \n一行一个整数代表答案对 $10^9+7$ 取模的结果，如果不存在 $n$ 个点满足条件的图，就输出 `-1`。", "hint": "|测试点|数据范围|\n|:-:|:-:|\n|$1$|$n ,T \\le 6$|\n|$2$|$n,T \\le 10$|\n|$3,4$|$n,T \\le 100$|\n|$5,6$|$n \\le 10^5$|\n|$7,8$|$n \\le 10^9$|\n|$9$|$n \\le 10^{18}$|\n|$10$|$n=10^{100}$|\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^{100}$，$1 \\le T \\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[BJOI2017] Isomorphism", "background": "", "description": "You have $n$ vertices. You may add undirected edges between these $n$ vertices, with at most one edge per pair and no self-loops. What is the maximum number of edges you can add?\n\nThe obvious answer is $\\dfrac{n(n-1)}{2}$ edges. Therefore, there is an additional constraint: the graph must not have a nontrivial automorphism.\n\nA graph $G$ has a nontrivial automorphism if there exists a permutation $p$ of $\\{1, \\dots, n\\}$ such that for all vertices $u, v$, there is an edge between $u$ and $v$ if and only if there is an edge between $p(u)$ and $p(v)$, and this permutation is nontrivial, i.e., there exists a vertex $u$ with $p(u) \\ne u$.\n\nFor example, for the 5-vertex graph $(1,2),(2,3),(3,4),(4,5),(5,1),(1,3)$, the mapping $p(1)=3$, $p(2)=2$, $p(3)=1$, $p(4)=5$, $p(5)=4$ is a nontrivial automorphism of this graph.\n\nYou need to answer: among simple undirected graphs on $n$ vertices that have no nontrivial automorphism, what is the maximum number of edges? If no such graph on $n$ vertices exists, output `-1`; otherwise, output the answer modulo $10^9+7$.", "inputFormat": "**This problem contains multiple test cases.**  \nA single line with a positive integer $T$, the number of test cases.  \nFor each test case:  \nA single positive integer $n$, the number of vertices.", "outputFormat": "For each test case:  \nOutput a single integer, the answer modulo $10^9+7$. If no graph on $n$ vertices satisfies the condition, output `-1`.", "hint": "| Test point | Constraints |\n|:-:|:-:|\n| $1$ | $n, T \\le 6$ |\n| $2$ | $n, T \\le 10$ |\n| $3,4$ | $n, T \\le 100$ |\n| $5,6$ | $n \\le 10^5$ |\n| $7,8$ | $n \\le 10^9$ |\n| $9$ | $n \\le 10^{18}$ |\n| $10$ | $n=10^{100}$ |\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^{100}$, $1 \\le T \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[BJOI2017] 同构", "background": "", "description": "你有 $n$ 个点，你可以在这 $n$ 个点之间连无向边，两个点之间至多只能连一条边，也不允许连自环，问至多能连多少条边。\n\n但这个问题的答案显然是 $\\dfrac{n(n-1)}{2}$ 条。所以有一个额外的限制，要求这个图不存在非平凡的自同构。\n\n一个图 $G$ 有非平凡的自同构定义为存在一个 $1$ 到 $n$ 的置换 $p(1)$ 到 $p(n)$ 满足对于所有点 $u,v$，$(u, v)$ 之间有边当且仅当 $(p(u), p(v))$ 之间有边，并且这个置换非平凡也就是存在一个点 $u$ 使得 $p(u) \\ne u$。\n\n比如对于一个 $5$ 个点的图 $(1,2),(2,3),(3,4),(4,5),(5,1),(1,3)$，那么 $p(1)=3$，$p(2)=2$，$p(3)=1$，$p(4)=5$，$p(5)=4$ 为这个图的一个非平凡的自同构。\n\n你要回答一个 $n$ 个点的无向简单的不存在非平凡自同构的图最多有多少条边，如果答案不存在，即不存在 $n$ 个点满足条件的图，请输出 `-1`，否则输出答案对 $10^9+7$ 取模的结果。", "inputFormat": "**本题有多组数据。**   \n一行一个正整数 $T$ 表示数据组数。   \n对于每组数据：   \n一个正整数 $n$ 表示你要回答的图的点的个数。", "outputFormat": "对于每组数据：   \n一行一个整数代表答案对 $10^9+7$ 取模的结果，如果不存在 $n$ 个点满足条件的图，就输出 `-1`。", "hint": "|测试点|数据范围|\n|:-:|:-:|\n|$1$|$n ,T \\le 6$|\n|$2$|$n,T \\le 10$|\n|$3,4$|$n,T \\le 100$|\n|$5,6$|$n \\le 10^5$|\n|$7,8$|$n \\le 10^9$|\n|$9$|$n \\le 10^{18}$|\n|$10$|$n=10^{100}$|\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^{100}$，$1 \\le T \\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P3994", "type": "P", "difficulty": 6, "samples": [["6\n1 9 3 0\n1 17 1 9\n1 1 1 6\n4 13 2 15\n4 9 2 4\n", "27\n26\n7\n43\n24\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["单调队列", "O2优化", "斜率优化", "队列"], "title": "高速公路", "background": null, "description": "C 国拥有一张四通八达的高速公路树。\n\nC 国有 $n$ 个城市，城市之间由一共 $n-1$ 条高速公路连接。除了首都 $1$ 号城市，每个城市都有一家本地的客运公司，可以发车前往全国各地。你可以把它认作以 $1$ 为根的树。两城市的距离定义为它们之间简单路径的长度。\n\n假设有一个人要从 $i$ 号城市坐车出发前往与其距离为 $D$ 的 $j$ 号城市，那么他要花费 $P_i \\times D+Q_i$ 元，**且要求满足 $j$ 是 $i$ 的祖先**。由于距离首都越远，国家的监管就越松，所以距离首都越远，客运公司的 $P_i$ 越大，如果 $i$ 号城市是 $j$ 号城市的某个祖先，那么一定存在 $P_i \\leq P_j$。\n\n小 T 成为了国家统计局的调查人员，他需要对现在的高速路网进行一次调查，了解从其他每一个城市到达首都 $1$ 号城市所花费的金钱。\n\n因为可能出现多转车（或不转车）的抵达首都的方法，所以人工计算这个结果是十分复杂的。大宁非常的懒，所以请你编写一个程序解决它。", "inputFormat": "第 $1$ 行包含一个整数 $n$，表示城市的个数。\n\n第 $2$ 到 $n$ 行，每行描述一个除首都之外的城市。其中第 $i$ 行包含 $4$ 个整数 $F_i,S_i,P_i,Q_i$，分别表示 $i$ 号城市的父亲城市，它到父亲城市高速公路的长度，以及乘车价格的两个参数。", "outputFormat": "输出包含 $n-1$ 行，每行包含一个整数。\n\n其中第 $i$ 行表示从 $i+1$ 号城市出发，到达首都最少的乘车费用。", "hint": "#### 数据规模与约定\n\n- 对于前 $40\\%$ 的数据 $n \\leq 1000$。\n- 对于另外 $20\\%$ 的数据，$F_i=i-1$\n- 对于所有的数据，$1 \\leq n \\leq 10^6$，$0 \\leq Pi,Qi \\lt 2^{31}$，保证结果不会大于 $2^{63}-1$。", "locale": "zh-CN", "translations": {"en": {"title": "Highway", "background": "", "description": "Country C has a well-connected highway network that forms a tree.\n\nThere are $n$ cities in Country C, connected by a total of $n - 1$ highways. Except for the capital, city $1$, each city has a local passenger transport company that can dispatch vehicles to various places nationwide. You can regard the network as a tree rooted at $1$. The distance between two cities is defined as the length of the simple path between them.\n\nSuppose a person departs from city $i$ to city $j$, which is at distance $D$ from $i$. Then the cost is $P_i \\times D + Q_i$ yuan, and it is required that $j$ is an ancestor of $i$. Because national supervision becomes looser farther from the capital, the $P_i$ of transport companies increases with distance from the capital: if city $i$ is an ancestor of city $j$, then $P_i \\leq P_j$.\n\nXiao T has become an investigator at the national statistics bureau. He needs to survey the current highway network to find out the cost to reach the capital, city $1$, from every other city.\n\nBecause reaching the capital may involve multiple transfers (or none), computing this by hand is very complicated. Xiao T is very lazy, so please write a program to solve it.", "inputFormat": "The first line contains an integer $n$, the number of cities.\n\nLines $2$ through $n$ each describe one city other than the capital. Specifically, line $i$ contains four integers $F_i, S_i, P_i, Q_i$, representing the parent city of city $i$, the length of the highway from city $i$ to its parent, and the two fare parameters of city $i$.", "outputFormat": "Output $n - 1$ lines, each containing an integer.\n\nThe $i$-th line contains the minimum cost to reach the capital starting from city $i + 1$.", "hint": "Constraints and Notes:\n- For the first $40\\%$ of the testdata, $n \\leq 1000$.\n- For another $20\\%$ of the testdata, $F_i = i - 1$.\n- For all the testdata, $1 \\leq n \\leq 10^6$, $0 \\leq P_i, Q_i < 2^{31}$, and the result is guaranteed not to exceed $2^{63} - 1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "高速公路", "background": null, "description": "C 国拥有一张四通八达的高速公路树。\n\nC 国有 $n$ 个城市，城市之间由一共 $n-1$ 条高速公路连接。除了首都 $1$ 号城市，每个城市都有一家本地的客运公司，可以发车前往全国各地。你可以把它认作以 $1$ 为根的树。两城市的距离定义为它们之间简单路径的长度。\n\n假设有一个人要从 $i$ 号城市坐车出发前往与其距离为 $D$ 的 $j$ 号城市，那么他要花费 $P_i \\times D+Q_i$ 元，**且要求满足 $j$ 是 $i$ 的祖先**。由于距离首都越远，国家的监管就越松，所以距离首都越远，客运公司的 $P_i$ 越大，如果 $i$ 号城市是 $j$ 号城市的某个祖先，那么一定存在 $P_i \\leq P_j$。\n\n小 T 成为了国家统计局的调查人员，他需要对现在的高速路网进行一次调查，了解从其他每一个城市到达首都 $1$ 号城市所花费的金钱。\n\n因为可能出现多转车（或不转车）的抵达首都的方法，所以人工计算这个结果是十分复杂的。大宁非常的懒，所以请你编写一个程序解决它。", "inputFormat": "第 $1$ 行包含一个整数 $n$，表示城市的个数。\n\n第 $2$ 到 $n$ 行，每行描述一个除首都之外的城市。其中第 $i$ 行包含 $4$ 个整数 $F_i,S_i,P_i,Q_i$，分别表示 $i$ 号城市的父亲城市，它到父亲城市高速公路的长度，以及乘车价格的两个参数。", "outputFormat": "输出包含 $n-1$ 行，每行包含一个整数。\n\n其中第 $i$ 行表示从 $i+1$ 号城市出发，到达首都最少的乘车费用。", "hint": "#### 数据规模与约定\n\n- 对于前 $40\\%$ 的数据 $n \\leq 1000$。\n- 对于另外 $20\\%$ 的数据，$F_i=i-1$\n- 对于所有的数据，$1 \\leq n \\leq 10^6$，$0 \\leq Pi,Qi \\lt 2^{31}$，保证结果不会大于 $2^{63}-1$。", "locale": "zh-CN"}}}
{"pid": "P3995", "type": "P", "difficulty": 6, "samples": [["14 7\n1 4\n4 10\n4 9\n4 8\n9 13\n13 14\n3 1\n7 3\n2 1\n2 6\n6 12\n11 6\n5 2\n11 3\n7 8\n2 8\n11 1\n8 14\n5 7\n9 14\n", "2\n6\n7\n8\n0\n11\n0\n0\n13\n0\n0\n0\n14\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["Special Judge", "O2优化", "树链剖分", "期望", "差分"], "title": "树链剖分", "background": "树链剖分，计算机术语，指一种对树进行划分的算法，它先通过轻重边剖分将树分为多条链，保证每个点属于且只属于一条链，然后再通过数据结构（树状数组、SBT、SPLAY、线段树等）来维护每一条链。(摘自百度百科)\n", "description": "大宁最近在研究树链剖分。他发现树链剖分的时间复杂度主要由轻重链的划分方式保证，最常见的剖分方式是按照子树大小剖分。如图（摘自百度百科），黑边为重链，长度任意，白边为轻链，长度全部为1。注意，下图 1-2, 1-3 为不同轻链。\n\n ![](https://cdn.luogu.com.cn/upload/pic/11502.png) \n\n其中对于每个节点，其在重链上的儿子叫做重儿子，且只有唯一一个，而叶子节点没有重儿子。例如对于图上 1 号点，重儿子是 4 号点。显然，对于不同剖分方式，同一组查询访问的链的数量不同。现在给定一棵根为 1 号节点的有根树和若干询问操作，每次询问访问从 $u$ 到 $v$ 上面的所有轻重链一次。例如在上图的剖分方式中，查询 3 到 8 一共访问了 3 条：轻链 1-3，重链 1-4，轻链 4-8；查询 3 到 11 一共访问了 3 条：轻链 1-3，轻链 1-2，重链 2-11。\n\n大宁请你给出一种剖分方案，使所有询问操作总共访问的**轻重链总条数**最小，由于可能有许多合法方案，请任意输出一种，我们提供Special Judge检验你的方案的正确性。\n\n设你的剖分方式的查询链数为 $x$，std 答案的查询数为 $x_0$，评分参数为 $a$ 。\n\n你得到的分数是：\n\n* $10$ 分  当 $x\\leq x_0$ 。\n\n* $8$ 分  当 $0<(x-x_0)\\leq a$ 。\n\n* $7$ 分  当 $a<(x-x0)\\leq 2\\times a$ 。\n\n* $6$ 分  当 $2\\times a<(x-x0)\\leq 3\\times a$ 。\n\n* $1$ 分  输出了合法的方案。\n\n\n\n$a=\\lfloor\\frac{q}{300}\\rfloor$, $q$ 为询问总数。\n\n我们提供了 `Div\\_Checker.exe` 来检验你的答案。把它放到 `div.in` , `div.out` 同文件夹下运行，其中 `div.in` 是输入数据的文件形式, `div.out` 是你的程序在该输入下的输出。如果你的 `div.out` 答案合法，它会返回：\n\n`Your answer is XXX.`\n\n`XXX` 是你的剖分方式在该输入数据下的查询次数，否则返回：\n\n`Wrong Outdata.`\n\n**注意: 在正式提交的时候不能使用文件输入输出。**\n", "inputFormat": "第一行有两个正整数 $n$ 和 $q$ ，表示该树的节点数 $n$ 和查询次数 $q$ 。\n\n接下来 $n-1$ 行，各有两个正整数 $u$ ，$v$ ，表示 $u$ 和 $v$ 之间有一条边。\n\n接下来 $q$ 行为 $q$ 个询问，为 $U$，$V$，表示有一次从 $U$ 到 $V$ 的询问。\n", "outputFormat": "一共 $n$ 行，对于 $i$ 号节点，如果它不是叶子节点，那么输出它在你的剖分方案里的重儿子，否则输出 0。\n", "hint": "样例即为上图，但图上的剖分方式对于此处的查询并非最优。\n\n对于 $20\\%$ 的数据，$n,q<=10$\n\n对于 $60\\%$ 的数据，$n,q<=1000$\n\n对于 $100\\%$ 的数据，$1<=n<=100000$,$1<=q<=200000$ ,保证给出的是一棵合法的树。\n\n[Div\\_Checker下载](https://pan.baidu.com/s/1c26OLf6)\n\n如果对Checker的使用方式不太理解，请参照下面的图片\n\n图中数据为样例。\n\n ![](https://cdn.luogu.com.cn/upload/pic/11563.png) \n\n一个合法方案的输出。\n\n ![](https://cdn.luogu.com.cn/upload/pic/11564.png) \n\n不合法方案的输出。\n\n![](https://cdn.luogu.com.cn/upload/pic/11565.png)\n\n---\n\n$\\text{upd 2022.8.26}$：新增加一组 Hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "Heavy-Light Decomposition", "background": "Heavy-light decomposition is a computing term for an algorithm that partitions a tree. It first splits the tree into multiple chains via heavy-light edge decomposition, ensuring each node belongs to exactly one chain, and then maintains each chain using data structures (Fenwick tree, SBT, SPLAY, segment tree, etc.). (from Baidu Baike)", "description": "Daning has been studying heavy-light decomposition. He found that the time complexity of heavy-light decomposition mainly depends on how heavy and light chains are divided, and the most common method is to split according to subtree size. As shown in the figure (from Baidu Baike), black edges are heavy chains (arbitrary length), and white edges are light chains (all of length $1$. Note that in the figure, $1$–$2$ and $1$–$3$ are different light chains.\n\n ![](https://cdn.luogu.com.cn/upload/pic/11502.png) \n\nFor each node, its child on the heavy chain is called its heavy child, and there is exactly one; leaf nodes have no heavy child. For example, for node $1$ in the figure, its heavy child is node $4$. Clearly, different decompositions lead to different numbers of chains visited by the same set of queries. Now, given a rooted tree with root $1$ and several queries, each query traverses all heavy-light chains along the path from $u$ to $v$ once. For example, under the decomposition in the figure above, the query from $3$ to $8$ visits $3$ chains in total: the light chain $1$–$3$, the heavy chain $1$–$4$, and the light chain $4$–$8$; the query from $3$ to $11$ also visits $3$ chains: the light chain $1$–$3$, the light chain $1$–$2$, and the heavy chain $2$–$11$.\n\nPlease output a decomposition scheme that minimizes the total number of heavy-light chains visited over all queries. Since there may be many valid schemes, output any one of them. We provide a Special Judge to check the correctness of your scheme.\n\nLet the total number of chains visited by your scheme be $x$, by the standard solution be $x_0$, and let the scoring parameter be $a$.\n\nYour score is:\n\n- $10$ points if $x \\leq x_0$.\n- $8$ points if $0 < (x - x_0) \\leq a$.\n- $7$ points if $a < (x - x_0) \\leq 2 \\times a$.\n- $6$ points if $2 \\times a < (x - x_0) \\leq 3 \\times a$.\n- $1$ point if you output a valid scheme.\n\n$a = \\lfloor \\frac{q}{300} \\rfloor$, where $q$ is the number of queries.\n\nWe provide `Div_Checker.exe` to check your answer. Put it in the same folder as `div.in` and `div.out`, then run it, where `div.in` is the input file and `div.out` is your program’s output on that input. If your `div.out` is valid, it will print:\n\n`Your answer is XXX.`\n\n`XXX` is the total number of chains visited by your decomposition on that input. Otherwise, it will print:\n\n`Wrong Outdata.`\n\nNote: You must not use file I/O in the official submission.", "inputFormat": "The first line contains two positive integers $n$ and $q$, the number of nodes of the tree and the number of queries.\n\nThe next $n - 1$ lines each contain two positive integers $u$, $v$, meaning there is an edge between $u$ and $v$.\n\nThe next $q$ lines each describe a query with two integers $U$, $V$, meaning a query from $U$ to $V$.", "outputFormat": "Output $n$ lines. For node $i$, if it is not a leaf, output its heavy child in your decomposition; otherwise, output $0$.", "hint": "The sample corresponds to the figure above, but the decomposition in the figure is not optimal for the sample queries.\n\nConstraints:\n- For $20\\%$ of the testdata, $n, q \\leq 10$.\n- For $60\\%$ of the testdata, $n, q \\leq 1000$.\n- For $100\\%$ of the testdata, $1 \\leq n \\leq 100000$, $1 \\leq q \\leq 200000$. It is guaranteed the input is a valid tree.\n\n[Div_Checker download](https://pan.baidu.com/s/1c26OLf6)\n\nIf you are not sure how to use the checker, please refer to the images below.\n\nThe data in the images is the sample.\n\n ![](https://cdn.luogu.com.cn/upload/pic/11563.png) \n\nAn output of a valid scheme.\n\n ![](https://cdn.luogu.com.cn/upload/pic/11564.png) \n\nAn invalid output.\n\n![](https://cdn.luogu.com.cn/upload/pic/11565.png)\n\n---\n\n$\\text{upd 2022.8.26}$: Added a new set of hack testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "树链剖分", "background": "树链剖分，计算机术语，指一种对树进行划分的算法，它先通过轻重边剖分将树分为多条链，保证每个点属于且只属于一条链，然后再通过数据结构（树状数组、SBT、SPLAY、线段树等）来维护每一条链。(摘自百度百科)\n", "description": "大宁最近在研究树链剖分。他发现树链剖分的时间复杂度主要由轻重链的划分方式保证，最常见的剖分方式是按照子树大小剖分。如图（摘自百度百科），黑边为重链，长度任意，白边为轻链，长度全部为1。注意，下图 1-2, 1-3 为不同轻链。\n\n ![](https://cdn.luogu.com.cn/upload/pic/11502.png) \n\n其中对于每个节点，其在重链上的儿子叫做重儿子，且只有唯一一个，而叶子节点没有重儿子。例如对于图上 1 号点，重儿子是 4 号点。显然，对于不同剖分方式，同一组查询访问的链的数量不同。现在给定一棵根为 1 号节点的有根树和若干询问操作，每次询问访问从 $u$ 到 $v$ 上面的所有轻重链一次。例如在上图的剖分方式中，查询 3 到 8 一共访问了 3 条：轻链 1-3，重链 1-4，轻链 4-8；查询 3 到 11 一共访问了 3 条：轻链 1-3，轻链 1-2，重链 2-11。\n\n大宁请你给出一种剖分方案，使所有询问操作总共访问的**轻重链总条数**最小，由于可能有许多合法方案，请任意输出一种，我们提供Special Judge检验你的方案的正确性。\n\n设你的剖分方式的查询链数为 $x$，std 答案的查询数为 $x_0$，评分参数为 $a$ 。\n\n你得到的分数是：\n\n* $10$ 分  当 $x\\leq x_0$ 。\n\n* $8$ 分  当 $0<(x-x_0)\\leq a$ 。\n\n* $7$ 分  当 $a<(x-x0)\\leq 2\\times a$ 。\n\n* $6$ 分  当 $2\\times a<(x-x0)\\leq 3\\times a$ 。\n\n* $1$ 分  输出了合法的方案。\n\n\n\n$a=\\lfloor\\frac{q}{300}\\rfloor$, $q$ 为询问总数。\n\n我们提供了 `Div\\_Checker.exe` 来检验你的答案。把它放到 `div.in` , `div.out` 同文件夹下运行，其中 `div.in` 是输入数据的文件形式, `div.out` 是你的程序在该输入下的输出。如果你的 `div.out` 答案合法，它会返回：\n\n`Your answer is XXX.`\n\n`XXX` 是你的剖分方式在该输入数据下的查询次数，否则返回：\n\n`Wrong Outdata.`\n\n**注意: 在正式提交的时候不能使用文件输入输出。**\n", "inputFormat": "第一行有两个正整数 $n$ 和 $q$ ，表示该树的节点数 $n$ 和查询次数 $q$ 。\n\n接下来 $n-1$ 行，各有两个正整数 $u$ ，$v$ ，表示 $u$ 和 $v$ 之间有一条边。\n\n接下来 $q$ 行为 $q$ 个询问，为 $U$，$V$，表示有一次从 $U$ 到 $V$ 的询问。\n", "outputFormat": "一共 $n$ 行，对于 $i$ 号节点，如果它不是叶子节点，那么输出它在你的剖分方案里的重儿子，否则输出 0。\n", "hint": "样例即为上图，但图上的剖分方式对于此处的查询并非最优。\n\n对于 $20\\%$ 的数据，$n,q<=10$\n\n对于 $60\\%$ 的数据，$n,q<=1000$\n\n对于 $100\\%$ 的数据，$1<=n<=100000$,$1<=q<=200000$ ,保证给出的是一棵合法的树。\n\n[Div\\_Checker下载](https://pan.baidu.com/s/1c26OLf6)\n\n如果对Checker的使用方式不太理解，请参照下面的图片\n\n图中数据为样例。\n\n ![](https://cdn.luogu.com.cn/upload/pic/11563.png) \n\n一个合法方案的输出。\n\n ![](https://cdn.luogu.com.cn/upload/pic/11564.png) \n\n不合法方案的输出。\n\n![](https://cdn.luogu.com.cn/upload/pic/11565.png)\n\n---\n\n$\\text{upd 2022.8.26}$：新增加一组 Hack 数据。", "locale": "zh-CN"}}}
{"pid": "P3996", "type": "P", "difficulty": 6, "samples": [["7\n3 1 5 16\n10 1 0 5\n2 1 0 3\n2 1 0 10\n3 1 5 59\n1 2 0 998\n0 1 0 0\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化"], "title": "失败的竞猜游戏", "background": "大宁是一个喜欢赌博的人，最近在玩一款竞猜游戏，然而屡战屡败。大宁非常不高兴，就去找游戏的运营商理论，质疑游戏的数据是否有意针对玩家。\n", "description": "游戏规则如下：玩家给出 $A_0$，$a$，$b$ 三个整数，代表一个线性递推式：\n\n$A_i=a \\times A_{i-1} +b$\n\n它定义了一个无限长度的数列 {$A_1$，$A_2$，$A_3$……}，而游戏系统会随机生成一个数 $n$，如果 $n$ 可以表示为该数列中的若干个**互不相同**的项 ( $A_0$ 不计入数列中) 之和，那么玩家胜利，反之玩家失败。现在大宁通过逼迫运营商交出了一组最近的游戏数据，但是他懒得一个个去算了，现在请你帮忙计算一下，数据中玩家一共获胜了多少次。\n", "inputFormat": "第一行一个正整数 $T$，表示进行了 $T$ 场游戏。\n\n接下来 $T$ 行，每行四个整数，描述一场游戏，分别为题目中的 $A_0$，$a$，$b$，$n$。\n", "outputFormat": "输出一行 $Ans$，表示玩家在 $T$ 场游戏中获胜的次数。\n", "hint": "样例说明：\n\n第 $1\\sim 3$ 场游戏玩家失败，$4\\sim 7$ 场游戏玩家胜利。\n\n| 测试点编号 | 数据范围 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1\\sim 2$ | $T=10$, $n\\leq 10^3$ | $a=1$ |\n| $3\\sim 4$ | $T=10^3$, $n\\leq 10^4$ | $a=2$ |\n| $5$ | $T=10^4$, $n\\leq 10^9$ | $a\\leq 3$ |\n| $6$ | $T=10^5$, $n\\leq 10^9$ | $b=0$ |\n| $7\\sim 10$ | $T=2\\times 10^5$, $n\\leq10^9$ | 无 |\n对于所有数据，$1\\leq a\\leq10$, $0 \\leq b \\leq 10^4$, $0\\leq n \\leq 10^9$, $0 \\leq A_0 \\leq 100$。\n\n事实上这个游戏玩家的胜率微乎其微。\n", "locale": "zh-CN", "translations": {"en": {"title": "A Failed Guessing Game", "background": "Daning is a person who likes gambling and has recently been playing a guessing game, but he keeps losing. He is very unhappy and goes to argue with the game operator, questioning whether the game's testdata is intentionally targeting players.", "description": "The game rules are as follows: The player gives three integers $A_0$, $a$, $b$, which define a linear recurrence:\n$A_i=a \\times A_{i-1} +b$\nIt defines an infinite sequence { $A_1$, $A_2$, $A_3$, ... }. The game system randomly generates a number $n$. If $n$ can be represented as the sum of several distinct terms from this sequence (excluding $A_0$), the player wins; otherwise, the player loses. Now Daning has forced the operator to hand over a batch of recent game testdata, but he is too lazy to compute them one by one. Please help determine how many times the player won in the testdata.", "inputFormat": "The first line contains a positive integer $T$, the number of games played.\nEach of the next $T$ lines contains four integers, describing one game: $A_0$, $a$, $b$, $n$.", "outputFormat": "Output one line with $Ans$, the number of times the player won among the $T$ games.", "hint": "Sample explanation:\nIn games $1 \\sim 3$ the player loses; in games $4 \\sim 7$ the player wins.\n\n| Test point ID | Constraints | Special properties |\n| :----------: | :----------: | :----------: |\n| $1 \\sim 2$ | $T=10$, $n \\leq 10^3$ | $a=1$ |\n| $3 \\sim 4$ | $T=10^3$, $n \\leq 10^4$ | $a=2$ |\n| $5$ | $T=10^4$, $n \\leq 10^9$ | $a \\leq 3$ |\n| $6$ | $T=10^5$, $n \\leq 10^9$ | $b=0$ |\n| $7 \\sim 10$ | $T=2 \\times 10^5$, $n \\leq 10^9$ | None |\n\nFor all testdata, $1 \\leq a \\leq 10$, $0 \\leq b \\leq 10^4$, $0 \\leq n \\leq 10^9$, $0 \\leq A_0 \\leq 100$.\n\nIn fact, the player's win rate in this game is negligible.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "失败的竞猜游戏", "background": "大宁是一个喜欢赌博的人，最近在玩一款竞猜游戏，然而屡战屡败。大宁非常不高兴，就去找游戏的运营商理论，质疑游戏的数据是否有意针对玩家。\n", "description": "游戏规则如下：玩家给出 $A_0$，$a$，$b$ 三个整数，代表一个线性递推式：\n\n$A_i=a \\times A_{i-1} +b$\n\n它定义了一个无限长度的数列 {$A_1$，$A_2$，$A_3$……}，而游戏系统会随机生成一个数 $n$，如果 $n$ 可以表示为该数列中的若干个**互不相同**的项 ( $A_0$ 不计入数列中) 之和，那么玩家胜利，反之玩家失败。现在大宁通过逼迫运营商交出了一组最近的游戏数据，但是他懒得一个个去算了，现在请你帮忙计算一下，数据中玩家一共获胜了多少次。\n", "inputFormat": "第一行一个正整数 $T$，表示进行了 $T$ 场游戏。\n\n接下来 $T$ 行，每行四个整数，描述一场游戏，分别为题目中的 $A_0$，$a$，$b$，$n$。\n", "outputFormat": "输出一行 $Ans$，表示玩家在 $T$ 场游戏中获胜的次数。\n", "hint": "样例说明：\n\n第 $1\\sim 3$ 场游戏玩家失败，$4\\sim 7$ 场游戏玩家胜利。\n\n| 测试点编号 | 数据范围 | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1\\sim 2$ | $T=10$, $n\\leq 10^3$ | $a=1$ |\n| $3\\sim 4$ | $T=10^3$, $n\\leq 10^4$ | $a=2$ |\n| $5$ | $T=10^4$, $n\\leq 10^9$ | $a\\leq 3$ |\n| $6$ | $T=10^5$, $n\\leq 10^9$ | $b=0$ |\n| $7\\sim 10$ | $T=2\\times 10^5$, $n\\leq10^9$ | 无 |\n对于所有数据，$1\\leq a\\leq10$, $0 \\leq b \\leq 10^4$, $0\\leq n \\leq 10^9$, $0 \\leq A_0 \\leq 100$。\n\n事实上这个游戏玩家的胜率微乎其微。\n", "locale": "zh-CN"}}}
{"pid": "P3997", "type": "P", "difficulty": 6, "samples": [["3 8 2\n1 -8 8\n3 -7 3\n5 -5 5", "76"], ["2 4 1\n4 -4 2\n1 -4 4", "98"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2013", "线段树", "各省省选", "树状数组", "上海", "O2优化", "扫描线"], "title": "[SHOI2013] 扇形面积并", "background": "", "description": " ![](https://cdn.luogu.com.cn/upload/pic/11825.png) \n\n给定 n 个同心的扇形，求有多少面积，被至少 $k$ 个扇形所覆盖。\n", "inputFormat": "第一行是三个整数 $n$，$m$，$k$。$n$ 代表同心扇形个数，$m$ 代表将 $(−\\pi ,\\pi]$ 的角度区间平均分成 $2m$ 份。\n\n从第二行开始的 $n$ 行，每行三个整数 $r，a_1，a_2$。描述了一个圆心在原点的扇形，半径为 $r$，圆心角是从弧度 $\\pi\\times \\frac{a_1}{m}$ 到 $\\pi\\times \\frac{a_2}{m}$（$a_1$ 不一定小于 $a_2$）。\n", "outputFormat": "输出一个整数 $ans$ ，$\\frac{\\pi}{2m}\\times ans$ 等于至少 $k$ 个扇形所覆盖的总面积。\n\n数据保证答案在 $2^{63} - 1$ 范围内。\n", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 10^5$, $1\\leq m\\leq 10^6$, $1\\leq k\\leq 5000$, $1\\leq r_i\\leq 10^5$,$-m\\leq a_1,a_2\\leq m$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2013] Union of Sector Areas", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/11825.png)\n\nGiven $n$ concentric sectors, find how much area is covered by at least $k$ sectors.", "inputFormat": "The first line contains three integers $n$, $m$, $k$. Here, $n$ is the number of concentric sectors, and $m$ means the angle interval $(-\\pi, \\pi]$ is evenly divided into $2m$ parts.\n\nFrom the second line, each of the next $n$ lines contains three integers $r, a_1, a_2$. Each line describes a sector centered at the origin with radius $r$, whose central angle ranges from radians $\\pi \\times \\frac{a_1}{m}$ to $\\pi \\times \\frac{a_2}{m}$ ($a_1$ is not necessarily less than $a_2$).", "outputFormat": "Output an integer $ans$, such that $\\frac{\\pi}{2m} \\times ans$ equals the total area covered by at least $k$ sectors.\n\nIt is guaranteed that the answer is within the range $2^{63} - 1$.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 10^5$, $1 \\le m \\le 10^6$, $1 \\le k \\le 5000$, $1 \\le r_i \\le 10^5$, $-m \\le a_1, a_2 \\le m$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2013] 扇形面积并", "background": "", "description": " ![](https://cdn.luogu.com.cn/upload/pic/11825.png) \n\n给定 n 个同心的扇形，求有多少面积，被至少 $k$ 个扇形所覆盖。\n", "inputFormat": "第一行是三个整数 $n$，$m$，$k$。$n$ 代表同心扇形个数，$m$ 代表将 $(−\\pi ,\\pi]$ 的角度区间平均分成 $2m$ 份。\n\n从第二行开始的 $n$ 行，每行三个整数 $r，a_1，a_2$。描述了一个圆心在原点的扇形，半径为 $r$，圆心角是从弧度 $\\pi\\times \\frac{a_1}{m}$ 到 $\\pi\\times \\frac{a_2}{m}$（$a_1$ 不一定小于 $a_2$）。\n", "outputFormat": "输出一个整数 $ans$ ，$\\frac{\\pi}{2m}\\times ans$ 等于至少 $k$ 个扇形所覆盖的总面积。\n\n数据保证答案在 $2^{63} - 1$ 范围内。\n", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 10^5$, $1\\leq m\\leq 10^6$, $1\\leq k\\leq 5000$, $1\\leq r_i\\leq 10^5$,$-m\\leq a_1,a_2\\leq m$。\n", "locale": "zh-CN"}}}
{"pid": "P3998", "type": "P", "difficulty": 4, "samples": [["2 8\n! 1\n! 2\n+ 1 2\n! 1\n! 2\n- 1 2\n! 1\n! 2", "1 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2013", "各省省选", "上海", "O2优化"], "title": "[SHOI2013] 发微博", "background": "", "description": "刚开通的 SH 微博共有 $n$ 个用户（$1\\sim n$ 标号），在这短短一个月的时间内，用户们活动频繁，共有 $m$ 条按时间顺序的记录：\n\n```plain\n! x 表示用户 x 发了一条微博；\n+ x y 表示用户 x 和用户 y 成为了好友\n− x y 表示用户 x 和用户 y 解除了好友关系\n```\n当一个用户发微博的时候，所有他的好友（直接关系）都会看到他的消息。\n\n假设最开始所有人之间都不是好友关系，记录也都是合法的（即 `+ x y` 时 $x$ 和 $y$ 一定不是好友，而 `− x y` 时 $x$ 和 $y$ 一定是好友）。\n\n问这 $m$ 条记录发生之后，每个用户分别看到了多少条消息。\n", "inputFormat": "第 $1$ 行两个整数 $n$, $m$。\n\n接下来 $m$ 行，按时间顺序读入 $m$ 条记录，每条记录的格式如题目所述，用空格隔开。", "outputFormat": "输出一行 $n$ 个用空格隔开的数（行末无空格），第 $i$ 个数表示用户 $i$ 最后看到了几条消息。\n", "hint": "对于 $100\\%$ 的数据，$n\\leq 200000$, $m\\leq 500000$", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2013] Posting Weibo", "background": "", "description": "The newly launched SH Weibo has $n$ users (labeled $1\\sim n$). During this brief month, users were very active, and there are $m$ records in chronological order:\n\n```plain\n! x 表示用户 x 发了一条微博；\n+ x y 表示用户 x 和用户 y 成为了好友\n− x y 表示用户 x 和用户 y 解除了好友关系\n```\nWhen a user posts a Weibo, all of their friends (direct connections) will see the message.\n\nAssume that initially no one is friends with anyone else, and all records are valid (i.e., when `+ x y` occurs, $x$ and $y$ are not friends; when `− x y` occurs, $x$ and $y$ are friends).\n\nAfter these $m$ records, determine how many messages each user has seen.", "inputFormat": "The first line contains two integers $n$, $m$.\n\nThe next $m$ lines contain the records in chronological order, each formatted as described above and separated by spaces.", "outputFormat": "Output one line with $n$ space-separated integers (no trailing space). The $i$-th number denotes the number of messages seen by user $i$.", "hint": "For $100\\%$ of the testdata, $n \\leq 200000$, $m \\leq 500000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2013] 发微博", "background": "", "description": "刚开通的 SH 微博共有 $n$ 个用户（$1\\sim n$ 标号），在这短短一个月的时间内，用户们活动频繁，共有 $m$ 条按时间顺序的记录：\n\n```plain\n! x 表示用户 x 发了一条微博；\n+ x y 表示用户 x 和用户 y 成为了好友\n− x y 表示用户 x 和用户 y 解除了好友关系\n```\n当一个用户发微博的时候，所有他的好友（直接关系）都会看到他的消息。\n\n假设最开始所有人之间都不是好友关系，记录也都是合法的（即 `+ x y` 时 $x$ 和 $y$ 一定不是好友，而 `− x y` 时 $x$ 和 $y$ 一定是好友）。\n\n问这 $m$ 条记录发生之后，每个用户分别看到了多少条消息。\n", "inputFormat": "第 $1$ 行两个整数 $n$, $m$。\n\n接下来 $m$ 行，按时间顺序读入 $m$ 条记录，每条记录的格式如题目所述，用空格隔开。", "outputFormat": "输出一行 $n$ 个用空格隔开的数（行末无空格），第 $i$ 个数表示用户 $i$ 最后看到了几条消息。\n", "hint": "对于 $100\\%$ 的数据，$n\\leq 200000$, $m\\leq 500000$", "locale": "zh-CN"}}}
{"pid": "P3999", "type": "P", "difficulty": 5, "samples": [["4 10\n1132411235", "168"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2013", "各省省选", "上海", "O2优化", "枚举", "进制", "状压 DP"], "title": "[SHOI2013] 二重镇", "background": null, "description": "这是一个充满爱的村子，它的名字叫二重镇。在这个爱意浓浓的村子里，居民们的生活快乐又安宁。二重镇呈长条形状，可分为排成一行的 $N$ 个方格。每个格子可能是空地，也可能是小草、灌木、大树、房屋或城堡中的一种物品。每种物品都有一个等级，小草的等级是 $1$，灌木的等级是 $2$，依此类推。\n\n你是这个村庄的建造者。你会陆续获得 $D$ 件物品，你要将它们合理地放置在村庄的空地上。你的目标是要让村子的总人气尽可能大。人气的获得规则在后面说明。关于放置的规则有以下几条：\n\n* 第一，每件物品都必须放在一个地方，不可丢弃，如果没有空地了，游戏直接结束；\n\n* 第二，物品可以放在一格空地上，或者临时放在仓库里。仓库同时最多只能放一件物品，它一开始是空的。只存在一个仓库；\n\n* 第三，一旦物品放在某个空格上，只要符合条件，系统就会自动将一些物品合成一个大的物品，这是强制被动的，也是瞬间的。直到合成结束后，才能放置下一个物品。\n\n* 第四，存放在仓库中的物品，随时可以取出放到空地上（但注意不能在合成的过程中放置），也可以一直留在仓库里。\n\n* 第五，除非利用仓库，不然不能更改物品的放置顺序；\n\n总结起来，这个游戏的流程就是获得一个新物品，决定是否将这个物品存入仓库，再决定将仓库中的物品或新物品放到哪个空地上，系统自动判定合成，获得人气，直到所有物品都被放置完毕，或空地用完为止。\n\n最后是关于合成的规则。合成是自动完成的，也是强制性的。如果有连续两个或以上相邻的格子里有相同等级的物品，它们会自动合体成一个新的物品，新物品的等级比之前高一个级别。合体分三步：\n\n* 第一步，确定有多少物品参与合成，这些物品的位置必须连在一起，等级相同。参与合体的物品会全部消失，对应的格子变成空地；\n\n* 第二步，假设有 $A$ 个 $K$ 级物品参与合体，那么将获得 $A\\times 2^K$ 点人气。例如有一次五棵小草进行了合体，那么总人气就会增加 $5 \\times 2^1=10$；\n\n* 第三步，一个 $K+1$ 等级的物品会出现在一个格子里。如果 $K+1$ 大于 $5$，则跳过这步，但第二步中的人气仍然要算，第一步中的旧物品也会被清除。这个高等级的物品只会出现在参与合体的格子上。每个格子会记录最后一次被放置物品的时间，新的物品会出现在该时间最晚的那个格子里，形象地说，就是出现在最近被放置过东西的格子；\n\n最后，请注意合成是会触发多次的，比如两个小草合成一个灌木，如果这棵灌木旁边还有其他灌木，合体将继续发生下去。\n\n现在，给出 $N$ 和获得物品的顺序及等级，请你要合理地将这些物品放置在一个初始全是空地的村子里，使得村子最终的人气值尽可能高。当所有物品都被放置，或者某一刻村子里没空地了，你都会结束村子的建设，而此时村子里累计人气值就是你的最终成果。", "inputFormat": "第一行给出两个整数 $N$ 和 $D$，用空格隔开。$N$ 表示村庄大小，$D$ 表示建设村庄的天数。\n\n第二行为一个字符串，每个字符为 $1 \\ldots 5$ 之间的一个字符，表示每天你可以放置的物品的等级。", "outputFormat": "输出一个整数，表示你能得到的最大的人气值。", "hint": "对于 $30\\%$ 的数据，$N=3$, $D\\leq 10$。\n\n对于 $60\\%$ 的数据，$N\\leq 4$, $D\\leq 30$。\n\n对于 $100\\%$ 的数据，$N\\leq 6$, $D\\leq 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2013] Double Town", "background": "", "description": "This is a village full of love, called Double Town. In this affectionate village, the residents live happily and peacefully. Double Town is long and narrow and can be divided into a row of $N$ cells. Each cell may be empty, or contain exactly one of the following: grass, shrub, tree, house, or castle. Each type has a level: grass has level $1$, shrub has level $2$, and so on.\n\nYou are the builder of this village. You will receive $D$ items one after another, and you must place them properly on empty cells. Your goal is to maximize the village’s total popularity. The rules for gaining popularity are explained later. The placement rules are as follows:\n\n* First, every item must be placed somewhere and cannot be discarded. If there is no empty cell, the game ends immediately.\n* Second, an item can be placed on one empty cell, or temporarily stored in the warehouse. The warehouse can hold at most one item at a time, and it is initially empty. There is only one warehouse.\n* Third, once an item is placed on a cell, as long as conditions are met, the system will automatically merge some items into a larger item. This is mandatory, passive, and instantaneous. Only after merging finishes can you place the next item.\n* Fourth, an item stored in the warehouse can be taken out and placed on an empty cell at any time (but not during a merge), or it may remain in the warehouse.\n* Fifth, unless you use the warehouse, you cannot change the order in which items are placed.\n\nIn summary, the process is: when you receive a new item, decide whether to store it in the warehouse, then decide where to place either the warehouse item or the new item on an empty cell, the system automatically performs merges and awards popularity, and you continue until all items have been placed or there are no empty cells left.\n\nFinally, here are the merge rules. Merging is automatic and mandatory. If two or more consecutive adjacent cells contain items of the same level, they will automatically merge into a new item whose level is one higher. A merge proceeds in three steps:\n\n* Step 1: Determine how many items participate in the merge; these items must be contiguous and of the same level. All participating items disappear, and their cells become empty.\n* Step 2: Suppose $A$ items of level $K$ merge. You gain $A\\times 2^K$ popularity. For example, if five grasses merge once, the total popularity increases by $5 \\times 2^1=10$.\n* Step 3: One item of level $K+1$ appears in one cell. If $K+1$ is greater than $5$, skip this step, but you still gain the popularity from Step 2, and the old items from Step 1 are still removed. The higher-level item appears only on one of the participating cells. Each cell records the time when an item was last placed on it; the new item appears on the cell with the latest such time—in other words, on the cell most recently placed upon.\n\nFinally, note that merges may be triggered multiple times. For example, two grasses may merge into a shrub; if that shrub is adjacent to other shrubs, merging continues.\n\nGiven $N$ and the sequence and levels of the items you receive, arrange them on an initially all-empty village to maximize the final total popularity. When all items have been placed, or at any moment when there are no empty cells, construction ends, and the accumulated popularity at that time is your final score.", "inputFormat": "The first line contains two integers $N$ and $D$, separated by a space. $N$ is the village size, and $D$ is the number of days.\n\nThe second line is a string, each character between $1 \\ldots 5$, indicating the level of the item you can place each day.", "outputFormat": "Output a single integer, the maximum popularity you can obtain.", "hint": "For $30\\%$ of the testdata, $N=3$, $D\\leq 10$.\n\nFor $60\\%$ of the testdata, $N\\leq 4$, $D\\leq 30$.\n\nFor $100\\%$ of the testdata, $N\\leq 6$, $D\\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2013] 二重镇", "background": null, "description": "这是一个充满爱的村子，它的名字叫二重镇。在这个爱意浓浓的村子里，居民们的生活快乐又安宁。二重镇呈长条形状，可分为排成一行的 $N$ 个方格。每个格子可能是空地，也可能是小草、灌木、大树、房屋或城堡中的一种物品。每种物品都有一个等级，小草的等级是 $1$，灌木的等级是 $2$，依此类推。\n\n你是这个村庄的建造者。你会陆续获得 $D$ 件物品，你要将它们合理地放置在村庄的空地上。你的目标是要让村子的总人气尽可能大。人气的获得规则在后面说明。关于放置的规则有以下几条：\n\n* 第一，每件物品都必须放在一个地方，不可丢弃，如果没有空地了，游戏直接结束；\n\n* 第二，物品可以放在一格空地上，或者临时放在仓库里。仓库同时最多只能放一件物品，它一开始是空的。只存在一个仓库；\n\n* 第三，一旦物品放在某个空格上，只要符合条件，系统就会自动将一些物品合成一个大的物品，这是强制被动的，也是瞬间的。直到合成结束后，才能放置下一个物品。\n\n* 第四，存放在仓库中的物品，随时可以取出放到空地上（但注意不能在合成的过程中放置），也可以一直留在仓库里。\n\n* 第五，除非利用仓库，不然不能更改物品的放置顺序；\n\n总结起来，这个游戏的流程就是获得一个新物品，决定是否将这个物品存入仓库，再决定将仓库中的物品或新物品放到哪个空地上，系统自动判定合成，获得人气，直到所有物品都被放置完毕，或空地用完为止。\n\n最后是关于合成的规则。合成是自动完成的，也是强制性的。如果有连续两个或以上相邻的格子里有相同等级的物品，它们会自动合体成一个新的物品，新物品的等级比之前高一个级别。合体分三步：\n\n* 第一步，确定有多少物品参与合成，这些物品的位置必须连在一起，等级相同。参与合体的物品会全部消失，对应的格子变成空地；\n\n* 第二步，假设有 $A$ 个 $K$ 级物品参与合体，那么将获得 $A\\times 2^K$ 点人气。例如有一次五棵小草进行了合体，那么总人气就会增加 $5 \\times 2^1=10$；\n\n* 第三步，一个 $K+1$ 等级的物品会出现在一个格子里。如果 $K+1$ 大于 $5$，则跳过这步，但第二步中的人气仍然要算，第一步中的旧物品也会被清除。这个高等级的物品只会出现在参与合体的格子上。每个格子会记录最后一次被放置物品的时间，新的物品会出现在该时间最晚的那个格子里，形象地说，就是出现在最近被放置过东西的格子；\n\n最后，请注意合成是会触发多次的，比如两个小草合成一个灌木，如果这棵灌木旁边还有其他灌木，合体将继续发生下去。\n\n现在，给出 $N$ 和获得物品的顺序及等级，请你要合理地将这些物品放置在一个初始全是空地的村子里，使得村子最终的人气值尽可能高。当所有物品都被放置，或者某一刻村子里没空地了，你都会结束村子的建设，而此时村子里累计人气值就是你的最终成果。", "inputFormat": "第一行给出两个整数 $N$ 和 $D$，用空格隔开。$N$ 表示村庄大小，$D$ 表示建设村庄的天数。\n\n第二行为一个字符串，每个字符为 $1 \\ldots 5$ 之间的一个字符，表示每天你可以放置的物品的等级。", "outputFormat": "输出一个整数，表示你能得到的最大的人气值。", "hint": "对于 $30\\%$ 的数据，$N=3$, $D\\leq 10$。\n\n对于 $60\\%$ 的数据，$N\\leq 4$, $D\\leq 30$。\n\n对于 $100\\%$ 的数据，$N\\leq 6$, $D\\leq 100$。", "locale": "zh-CN"}}}
{"pid": "P4000", "type": "P", "difficulty": 6, "samples": [["5\n1000000007", "5"], ["10\n1000000007", "55"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["字符串", "数学", "O2优化", "素数判断,质数,筛法", "Fibonacci 数列"], "title": "斐波那契数列", "background": null, "description": "大家都知道，斐波那契数列是满足如下性质的一个数列：\n\n- $f_0 = 0$\n- $f_1 = 1$\n- $f_n = f_{n-1} + f_{n-2}$（$n \\geq 2$ 且 $n$ 为整数）\n\n请你求出 $f_n \\bmod p$ 的值。", "inputFormat": "- 第 1 行：一个整数 $n$。\n- 第 2 行：一个整数 $p$。", "outputFormat": "- 第 1 行：$f_n \\bmod p$ 的值。", "hint": "对于 $100\\%$ 的数据，$0 \\leq n \\leq 10^{30000000}$，$1 \\leq p<2^{31}$。", "locale": "zh-CN", "translations": {"en": {"title": "Fibonacci Sequence", "background": "", "description": "Everyone knows the Fibonacci sequence is defined by the following properties:\n- $f_0 = 0$.\n- $f_1 = 1$.\n- $f_n = f_{n-1} + f_{n-2}$ ($n \\geq 2$ and $n$ is an integer).\n\nPlease compute the value of $f_n \\bmod p$.", "inputFormat": "- Line 1: An integer $n$.\n- Line 2: An integer $p$.", "outputFormat": "- Line 1: The value of $f_n \\bmod p$.", "hint": "For $100\\%$ of the testdata, $0 \\leq n \\leq 10^{30000000}$, $1 \\leq p < 2^{31}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "斐波那契数列", "background": null, "description": "大家都知道，斐波那契数列是满足如下性质的一个数列：\n\n- $f_0 = 0$\n- $f_1 = 1$\n- $f_n = f_{n-1} + f_{n-2}$（$n \\geq 2$ 且 $n$ 为整数）\n\n请你求出 $f_n \\bmod p$ 的值。", "inputFormat": "- 第 1 行：一个整数 $n$。\n- 第 2 行：一个整数 $p$。", "outputFormat": "- 第 1 行：$f_n \\bmod p$ 的值。", "hint": "对于 $100\\%$ 的数据，$0 \\leq n \\leq 10^{30000000}$，$1 \\leq p<2^{31}$。", "locale": "zh-CN"}}}
{"pid": "P4001", "type": "P", "difficulty": 6, "samples": [["3 4\n5 6 4\n4 3 1\n7 5 3\n5 6 7 8\n8 7 6 5\n5 5 5\n6 6 6", "14"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000]}, "tags": ["2006", "网络流", "北京", "图论建模", "最短路", "平面图", "最小割", "ICPC"], "title": "[ICPC-Beijing 2006] 狼抓兔子", "background": "", "description": "现在小朋友们最喜欢的\"喜羊羊与灰太狼\"。话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形：\n\n ![](https://cdn.luogu.com.cn/upload/pic/11942.png) \n\n左上角点为 $(1,1)$，右下角点为 $(N,M)$（上图中 $N=3$，$M=4$）。有以下三种类型的道路：\n\n1. $(x,y)\\rightleftharpoons(x+1,y)$\n\n2. $(x,y)\\rightleftharpoons(x,y+1)$\n\n3. $(x,y)\\rightleftharpoons(x+1,y+1)$\n\n道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的。左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角 $(1,1)$ 的窝里，现在它们要跑到右下角 $(N,M)$ 的窝中去，狼王开始伏击这些兔子。当然为了保险起见，如果一条道路上最多通过的兔子数为 $K$，狼王需要安排同样数量的 $K$ 只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦。\n", "inputFormat": "第一行两个整数 $N,M$，表示网格的大小。\n\n接下来分三部分。\n\n第一部分共 $N$ 行，每行 $M-1$ 个数，表示横向道路的权值。\n\n第二部分共 $N-1$ 行，每行 $M$ 个数，表示纵向道路的权值。\n\n第三部分共 $N-1$ 行，每行 $M-1$ 个数，表示斜向道路的权值。", "outputFormat": "输出一个整数，表示参与伏击的狼的最小数量。\n", "hint": "### 数据规模与约定\n\n对于全部的测试点，保证 $3 \\leq N,M \\leq 1000$，所有道路的权值均为不超过 $10^6$ 的正整数。", "locale": "zh-CN", "translations": {"en": {"title": "[ICPC-Beijing 2006] Wolf Catches Rabbits", "background": "", "description": "Kids now love \"Pleasant Goat and Big Big Wolf\" (Xi Yangyang yu Hui Tailang). Although Big Big Wolf fails to catch goats, he is quite good at catching rabbits. The rabbits here are rather slow-witted and have only two burrows. As the Wolf King, you face a terrain shaped like a grid:\n\n![](https://cdn.luogu.com.cn/upload/pic/11942.png)\n\nThe upper-left point is $(1,1)$, and the lower-right point is $(N,M)$ (in the figure, $N=3$, $M=4$). There are three types of roads:\n\n1. $(x,y)\\rightleftharpoons(x+1,y)$\n2. $(x,y)\\rightleftharpoons(x,y+1)$\n3. $(x,y)\\rightleftharpoons(x+1,y+1)$\n\nThe weight on a road indicates the maximum number of rabbits that can pass through that road; roads are undirected. The upper-left and lower-right corners are the two burrows of the rabbits. Initially, all rabbits gather in the upper-left burrow at $(1,1)$, and now they want to run to the lower-right burrow at $(N,M)$. The Wolf King starts to ambush these rabbits. To be safe, if the maximum number of rabbits that can pass through a road is $K$, the Wolf King needs to assign the same number of $K$ wolves to completely block this road. You need to help the Wolf King plan an ambush so that, while ensuring all rabbits are captured, the number of participating wolves is minimized, since the wolves still need to trouble Pleasant Goat later.", "inputFormat": "The first line contains two integers $N, M$, indicating the size of the grid.\n\nThen the input consists of three parts.\n\n- Part 1: $N$ lines, each containing $M-1$ numbers, representing the weights of horizontal roads.\n- Part 2: $N-1$ lines, each containing $M$ numbers, representing the weights of vertical roads.\n- Part 3: $N-1$ lines, each containing $M-1$ numbers, representing the weights of diagonal roads.", "outputFormat": "Output a single integer, the minimum number of wolves needed for the ambush.", "hint": "Constraints\n\nFor all test points, it is guaranteed that $3 \\leq N, M \\leq 1000$, and all road weights are positive integers not exceeding $10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ICPC-Beijing 2006] 狼抓兔子", "background": "", "description": "现在小朋友们最喜欢的\"喜羊羊与灰太狼\"。话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形：\n\n ![](https://cdn.luogu.com.cn/upload/pic/11942.png) \n\n左上角点为 $(1,1)$，右下角点为 $(N,M)$（上图中 $N=3$，$M=4$）。有以下三种类型的道路：\n\n1. $(x,y)\\rightleftharpoons(x+1,y)$\n\n2. $(x,y)\\rightleftharpoons(x,y+1)$\n\n3. $(x,y)\\rightleftharpoons(x+1,y+1)$\n\n道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的。左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角 $(1,1)$ 的窝里，现在它们要跑到右下角 $(N,M)$ 的窝中去，狼王开始伏击这些兔子。当然为了保险起见，如果一条道路上最多通过的兔子数为 $K$，狼王需要安排同样数量的 $K$ 只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦。\n", "inputFormat": "第一行两个整数 $N,M$，表示网格的大小。\n\n接下来分三部分。\n\n第一部分共 $N$ 行，每行 $M-1$ 个数，表示横向道路的权值。\n\n第二部分共 $N-1$ 行，每行 $M$ 个数，表示纵向道路的权值。\n\n第三部分共 $N-1$ 行，每行 $M-1$ 个数，表示斜向道路的权值。", "outputFormat": "输出一个整数，表示参与伏击的狼的最小数量。\n", "hint": "### 数据规模与约定\n\n对于全部的测试点，保证 $3 \\leq N,M \\leq 1000$，所有道路的权值均为不超过 $10^6$ 的正整数。", "locale": "zh-CN"}}}
{"pid": "P4002", "type": "P", "difficulty": 7, "samples": [["3 1\n2 3 4", "1728"], ["233 10\n604230822 258609018 347836125 103063600 545593375 983656639 636383432 149579311 37952830 782185282 792399760 556879020 19276539 821164472 992758005 635410231 174811932 967712405 76287574 877354238 403371989 131233662 90928781 909518950 816498283 460305280 688669184 272529638 706529895 931734844 376928193 161521421 41104566 573769373 264585020 586697940 408186715 749973507 585282307 446139544 533914437 228442770 4774211 553190975 51362889 997532216 39361909 75179876 816005324 115649482 801539169 70138016 95888199 892467950 979656965 761391537 354528877 519086852 35676822 910063828 301582400 261610070 73340896 342686965 835379442 186930971 778389960 245321804 936904477 365427914 691461347 321579617 593870684 545240614 874770591 494238628 393533533 914132499 418423560 211294504 878787036 221718376 281432519 823680290 115941973 111850187 435832530 319475906 630937038 471509352 80300437 932519437 733119421 153641332 125967105 419259567 340572302 904357065 664581370 128237482 120545682 206803421 449817099 563421421 752044034 175348393 59415697 147333214 91236540 326844312 207632773 819028631 548562687 338070347 493469625 513509716 449920533 929302154 681990677 929862626 251572209 762291113 713142767 833696686 915932444 839109871 254711900 107265449 594227639 768298325 235502930 563778377 975101745 685320028 128955445 577906482 860668421 37376197 574244751 800910016 364220508 630882579 470699350 761788251 968952925 813174030 126058670 269634161 593236888 808049346 201252435 844809096 572096106 914395201 529266485 338789253 604265775 783978384 295059757 49254118 403037413 530562686 613032494 228899861 66643418 590992994 806806343 776316894 628369191 231811797 427987613 841594754 862694376 898686962 605138652 682408004 562621696 731197321 952042165 157614231 390007370 4055303 851428382 962103475 918450503 382450515 151653431 373476981 17189602 446713187 271736154 420227014 826280929 884768647 649126875 892924346 326522345 306693921 520001943 954891535 387510773 947989555 647246992 100965852 697437220 103146348 783373856 261814563 834343668 737171668 268433849 75111742 741226970 121617879 38970864 510438176 353073449 39629351 732920212 370263050 335347593 6412014 639495120 163384169 740185716 139382698 905313570 68463708 446076618 427071160 872360298 833587390 225821418\n", "521800668\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2017", "O2优化", "生成函数", "快速傅里叶变换 FFT", "CTT（清华集训/北大集训）"], "title": "[清华集训 2017] 生成树计数", "background": "", "description": "在一个 $s$ 个点的图中，存在 $s-n$ 条边，使图中形成了 $n$ 个连通块，第 $i$ 个连通块中有 $a_i$ 个点。\n\n现在我们需要再连接 $n-1$ 条边，使该图变成一棵树。对一种连边方案，设原图中第 $i$ 个连通块连出了 $d_i$ 条边，那么这棵树 $T$ 的价值为：\n\n$$ \\mathrm{val}(T) = \\left(\\prod_{i=1}^{n} {d_i}^m\\right)\\left(\\sum_{i=1}^{n} {d_i}^m\\right) $$\n\n你的任务是求出所有可能的生成树的价值之和，对 $998244353$ 取模。\n", "inputFormat": "输入的第一行包含两个整数 $n,m$，意义见题目描述。\n\n接下来一行有 $n$ 个整数，第 $i$ 个整数表示 $a_i$ $(1\\le a_i< 998244353)$。\n\n* 你可以由 $a_i$ 计算出图的总点数 $s$，所以在输入中不再给出 $s$ 的值。", "outputFormat": "输出包含一行一个整数，表示答案。", "hint": "令 $i$ 表示大小为 $i$ 的原连通块，我们在连通块之间的连边有以下三种可能:\n- $2-3-4$\n- $3-2-4$\n- $2-4-3$\n\n价值和为:\n$$(2×3^2 ×4×2+3×2^2 ×4×2+2×4^2 ×3×2)×(1+2+1)=1728$$\n\n\n---\n\n本题共有 $20$ 个测试点，每个测试点 $5$ 分。 \n\n- $20\\%$ 的数据中，$n\\le500$。\n\n- 另外 $20\\%$ 的数据中，$n \\le 3000$。\n\n- 另外 $10\\%$ 的数据中，$n \\le 10010, m = 1$。 \n\n- 另外 $10\\%$的数据中，$n \\le 10015,m = 2$。 \n\n- 另外 $20\\%$ 的数据中，所有 $a_i$ 相等。\n\n- $100\\%$ 的数据中，$n \\le 3\\times 10^4,m \\le 30$。  \n\n其中，每一个部分分的测试点均有一定梯度。", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training 2017] Counting Spanning Trees", "background": "", "description": "In a graph with $s$ vertices, there are $s-n$ edges, making the graph consist of $n$ connected components. The $i$-th connected component contains $a_i$ vertices.\n\nWe now need to add $n-1$ edges to make the graph a tree. For a particular way of adding edges, let the $i$-th original connected component have $d_i$ edges going out. Then the value of this tree $T$ is:\n$$ \\mathrm{val}(T) = \\left(\\prod_{i=1}^{n} {d_i}^m\\right)\\left(\\sum_{i=1}^{n} {d_i}^m\\right). $$\n\nYour task is to compute the sum of the values of all possible spanning trees, modulo $998244353$.", "inputFormat": "The first line contains two integers $n, m$, as described above.\n\nThe second line contains $n$ integers, where the $i$-th integer denotes $a_i$ $(1 \\le a_i < 998244353)$.\n\nYou can compute the total number of vertices $s$ from the $a_i$, so the value of $s$ is not given separately in the input.", "outputFormat": "Output a single line containing one integer, the answer.", "hint": "Let $i$ denote an original connected component of size $i$. The edges added between components can be in the following three orders:\n- $2-3-4$\n- $3-2-4$\n- $2-4-3$\n\nThe sum of values is:\n$$ (2 \\times 3^2 \\times 4 \\times 2 + 3 \\times 2^2 \\times 4 \\times 2 + 2 \\times 4^2 \\times 3 \\times 2) \\times (1+2+1) = 1728. $$\n\n---\n\nThis problem has $20$ test points, $5$ points each.\n\n- In $20\\%$ of the testdata, $n \\le 500$.\n- In another $20\\%$ of the testdata, $n \\le 3000$.\n- In another $10\\%$ of the testdata, $n \\le 10010, m = 1$.\n- In another $10\\%$ of the testdata, $n \\le 10015, m = 2$.\n- In another $20\\%$ of the testdata, all $a_i$ are equal.\n- For $100\\%$ of the testdata, $n \\le 3\\times 10^4, m \\le 30$.\n\nEach group of test points for a partial score has a certain gradient.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2017] 生成树计数", "background": "", "description": "在一个 $s$ 个点的图中，存在 $s-n$ 条边，使图中形成了 $n$ 个连通块，第 $i$ 个连通块中有 $a_i$ 个点。\n\n现在我们需要再连接 $n-1$ 条边，使该图变成一棵树。对一种连边方案，设原图中第 $i$ 个连通块连出了 $d_i$ 条边，那么这棵树 $T$ 的价值为：\n\n$$ \\mathrm{val}(T) = \\left(\\prod_{i=1}^{n} {d_i}^m\\right)\\left(\\sum_{i=1}^{n} {d_i}^m\\right) $$\n\n你的任务是求出所有可能的生成树的价值之和，对 $998244353$ 取模。\n", "inputFormat": "输入的第一行包含两个整数 $n,m$，意义见题目描述。\n\n接下来一行有 $n$ 个整数，第 $i$ 个整数表示 $a_i$ $(1\\le a_i< 998244353)$。\n\n* 你可以由 $a_i$ 计算出图的总点数 $s$，所以在输入中不再给出 $s$ 的值。", "outputFormat": "输出包含一行一个整数，表示答案。", "hint": "令 $i$ 表示大小为 $i$ 的原连通块，我们在连通块之间的连边有以下三种可能:\n- $2-3-4$\n- $3-2-4$\n- $2-4-3$\n\n价值和为:\n$$(2×3^2 ×4×2+3×2^2 ×4×2+2×4^2 ×3×2)×(1+2+1)=1728$$\n\n\n---\n\n本题共有 $20$ 个测试点，每个测试点 $5$ 分。 \n\n- $20\\%$ 的数据中，$n\\le500$。\n\n- 另外 $20\\%$ 的数据中，$n \\le 3000$。\n\n- 另外 $10\\%$ 的数据中，$n \\le 10010, m = 1$。 \n\n- 另外 $10\\%$的数据中，$n \\le 10015,m = 2$。 \n\n- 另外 $20\\%$ 的数据中，所有 $a_i$ 相等。\n\n- $100\\%$ 的数据中，$n \\le 3\\times 10^4,m \\le 30$。  \n\n其中，每一个部分分的测试点均有一定梯度。", "locale": "zh-CN"}}}
{"pid": "P4003", "type": "P", "difficulty": 7, "samples": [["2 3\n3 14 12\n3 11 12", "2"], ["3 2\n1 8\n5 10\n2 4", "-1"], ["3 3\n9 11 3\n13 15 7\n12 14 6", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "网络流", "费用流", "CTT（清华集训/北大集训）"], "title": "[清华集训 2017] 无限之环", "background": null, "description": "曾经有一款流行的游戏，叫做 Infinity Loop，先来简单的介绍一下这个游戏：\n\n游戏在一个 $n \\times m$ 的网格状棋盘上进行，其中有些小方格中会有水管，水管可能在格某些方向的边界的中点有接口，所有水管的粗细都相同，所以如果两个相邻方格的共边界的中点都有接头，那么可以看作这两个接头互相连接。水管有以下 $15$ 种形状：\n\n ![](https://cdn.luogu.com.cn/upload/pic/12049.png) \n\n游戏开始时，棋盘中水管可能存在漏水的地方。\n\n形式化地：如果存在某个接头，没有和其它接头相连接，那么它就是一个漏水的地方。\n\n玩家可以进行一种操作：选定一个含有**非直线型**水管的方格，将其中的水管绕方格中心顺时针或逆时针旋转 $90$ 度。\n\n直线型水管是指左图里中间一行的两种水管。\n\n现给出一个初始局面，请问最少进行多少次操作可以使棋盘上不存在漏水的地方。", "inputFormat": "第一行两个正整数 $n$, $m$, 代表网格的大小。\n\n接下来 $n$ 行每行 $m$ 个数，每个数是 $[0,15]$ 中的一个，你可以将其看作一个 $4$ 位的二进制数，从低到高每一位分别代表初始局面中这个格子上、右、下、左方向上是否有水管接头。\n\n特别地，如果这个数是 $0$ ，则意味着这个位置没有水管。\n\n比如 $3(0011_{(2)})$ 代表上和右有接头，也就是一个 $L$ 型，而 $12(1100_{(2)})$ 代表下和左有接头，也就是将 $L$ 型旋转 $180$ 度。", "outputFormat": "输出共一行，表示最少操作次数。如果无法达成目标，输出 $-1$。", "hint": "【样例 1 解释】\n\n样例 1 棋盘如下:\n\n旋转方法很显然，先将左上角虚线方格内的水管顺时针转 $90$ 度\n\n ![](https://cdn.luogu.com.cn/upload/pic/12050.png) \n\n然后右下角虚线方格内的水管逆时针旋转 $90$ 度，这样就使得水管封闭了\n\n【样例 2 解释】\n\n样例 2 为题目描述中的第一张图片，无法达成目标。\n\n【样例 3 解释】\n\n样例 3 为题目描述中的第二张图片，将除了中心方格以外的每个方格内的水管都转 $180$ 度即可。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/12051.png)", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training Camp 2017] Infinity Loop", "background": "", "description": "There was once a popular game called Infinity Loop. Here is a brief introduction to the game:\n\nThe game is played on an $n \\times m$ grid board. Some cells contain pipes. A pipe may have joints at the midpoints of the cell’s edges in certain directions. All pipes have the same thickness, so if two adjacent cells both have a joint at the midpoint of their shared edge, those two joints are considered connected. Pipes come in the following $15$ shapes:\n\n ![](https://cdn.luogu.com.cn/upload/pic/12049.png) \n\nAt the start of the game, there may be leaks on the board.\n\nFormally: if there exists a joint that is not connected to any other joint, then it is a leak.\n\nThe player can perform the following operation: choose a cell containing a non-straight pipe and rotate the pipe by $90$ degrees clockwise or counterclockwise about the center of the cell.\n\nA straight pipe refers to the two shapes in the middle row of the figure on the left.\n\nGiven an initial configuration, find the minimum number of operations needed so that there are no leaks on the board.", "inputFormat": "The first line contains two positive integers $n$, $m$, representing the size of the grid.\n\nEach of the next $n$ lines contains $m$ numbers, each in $[0,15]$. You may regard each number as a $4$-bit binary number. From low to high bit, the bits indicate whether in the initial configuration the cell has a joint in the up, right, down, and left directions, respectively.\n\nIn particular, if the number is $0$, it means there is no pipe in this cell.\n\nFor example, $3(0011_{(2)})$ means there are joints up and right, i.e., an $L$ shape; and $12(1100_{(2)})$ means there are joints down and left, i.e., the $L$ shape rotated by $180$ degrees.", "outputFormat": "Output a single line with the minimum number of operations. If it is impossible to achieve the goal, output $-1$.", "hint": "[Sample 1 explanation]\n\nThe board is as follows:\n\nThe rotation method is straightforward: first rotate the pipe in the dashed cell at the top-left clockwise by $90$ degrees.\n\n ![](https://cdn.luogu.com.cn/upload/pic/12050.png) \n\nThen rotate the pipe in the dashed cell at the bottom-right counterclockwise by $90$ degrees. This closes the loop.\n\n[Sample 2 explanation]\n\nSample 2 corresponds to the first picture in the problem description and is impossible to solve.\n\n[Sample 3 explanation]\n\nSample 3 corresponds to the second picture in the problem description. Rotate the pipe in every cell except the center cell by $180$ degrees.\n\n ![](https://cdn.luogu.com.cn/upload/pic/12051.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2017] 无限之环", "background": null, "description": "曾经有一款流行的游戏，叫做 Infinity Loop，先来简单的介绍一下这个游戏：\n\n游戏在一个 $n \\times m$ 的网格状棋盘上进行，其中有些小方格中会有水管，水管可能在格某些方向的边界的中点有接口，所有水管的粗细都相同，所以如果两个相邻方格的共边界的中点都有接头，那么可以看作这两个接头互相连接。水管有以下 $15$ 种形状：\n\n ![](https://cdn.luogu.com.cn/upload/pic/12049.png) \n\n游戏开始时，棋盘中水管可能存在漏水的地方。\n\n形式化地：如果存在某个接头，没有和其它接头相连接，那么它就是一个漏水的地方。\n\n玩家可以进行一种操作：选定一个含有**非直线型**水管的方格，将其中的水管绕方格中心顺时针或逆时针旋转 $90$ 度。\n\n直线型水管是指左图里中间一行的两种水管。\n\n现给出一个初始局面，请问最少进行多少次操作可以使棋盘上不存在漏水的地方。", "inputFormat": "第一行两个正整数 $n$, $m$, 代表网格的大小。\n\n接下来 $n$ 行每行 $m$ 个数，每个数是 $[0,15]$ 中的一个，你可以将其看作一个 $4$ 位的二进制数，从低到高每一位分别代表初始局面中这个格子上、右、下、左方向上是否有水管接头。\n\n特别地，如果这个数是 $0$ ，则意味着这个位置没有水管。\n\n比如 $3(0011_{(2)})$ 代表上和右有接头，也就是一个 $L$ 型，而 $12(1100_{(2)})$ 代表下和左有接头，也就是将 $L$ 型旋转 $180$ 度。", "outputFormat": "输出共一行，表示最少操作次数。如果无法达成目标，输出 $-1$。", "hint": "【样例 1 解释】\n\n样例 1 棋盘如下:\n\n旋转方法很显然，先将左上角虚线方格内的水管顺时针转 $90$ 度\n\n ![](https://cdn.luogu.com.cn/upload/pic/12050.png) \n\n然后右下角虚线方格内的水管逆时针旋转 $90$ 度，这样就使得水管封闭了\n\n【样例 2 解释】\n\n样例 2 为题目描述中的第一张图片，无法达成目标。\n\n【样例 3 解释】\n\n样例 3 为题目描述中的第二张图片，将除了中心方格以外的每个方格内的水管都转 $180$ 度即可。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/12051.png)", "locale": "zh-CN"}}}
{"pid": "P4004", "type": "P", "difficulty": 6, "samples": [["5\n1 2 3 4 5\n1 2\n2 3\n3 4\n2 5\n5\n1 1 4 1\n1 1 4 2\n0 1 5 2\n1 2 4 5\n1 1 5 1", "10\n8 6 5"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "O2优化", "CTT（清华集训/北大集训）"], "title": "[清华集训 2017] Hello world!", "background": "不远的一年前，小 V 还是一名清华集训的选手，坐在机房里为他已如风中残烛的OI 生涯做最后的挣扎。而如今，他已成为了一名光荣的出题人。他感到非常激动，不禁感叹道： “Hello world!”。", "description": "小 V 有 $n$ 道题，他的题都非常毒瘤，所以关爱选手的 ufozgg 打算削弱这些题。为了逃避削弱，小 V 把他的毒瘤题都藏到了一棵 $n$ 个节点的树里（节点编号从 $1$ 至 $n$），这棵树上的所有节点与小 V 的所有题一一对应。小 V 的每一道题都有一个毒瘤值，节点 $i$ （表示标号为 $i$ 的树上节点，下同）对应的题的毒瘤值为 $a_i$。\n\n魔法师小 V 为了保护他的题目，对这棵树施了魔法，这样一来，任何人想要一探这棵树的究竟，都必须在上面做跳跃操作。每一次跳跃操作包含一个起点 $s$ 、一个终点 $t$ 和一个步频 $k$ ，这表示跳跃者会从 $s$ 出发，在树上沿着简单路径多次跳跃到达 $t$ ，每次跳跃，如果从当前点到 $t$ 的最短路长度不超过 $k$ ，那么跳跃者就会直接跳到 $t$ ，否则跳跃者就会沿着最短路跳过恰好 $k$ 条边。\n\n既然小 V 把题藏在了树里， ufozgg 就不能直接削弱题目了。他就必须在树上跳跃，边跳跃边削弱题目。 ufozgg 每次跳跃经过一个节点（包括起点 $s$ ，当 $s = t$ 的时候也是如此），就会把该节点上的题目的毒瘤值开根并向下取整：即如果他经过了节点 $i$，他就会使 $a_i = \\lfloor \\sqrt{a_i} \\rfloor$。这种操作我们称为削弱操作。\n\nufozgg 还会不时地希望知道他对题目的削弱程度。因此，他在一些跳跃操作中会放弃对题目的削弱，转而统计该次跳跃经过节点的题目毒瘤值总和。这种操作我们称为统计操作。\n\n吃瓜群众绿绿对小 V 的毒瘤题和 ufozgg 的削弱计划常感兴趣。他现在想知道ufozgg 每次做统计操作时得到的结果。你能帮帮他吗？\n\n![](https://cdn.luogu.com.cn/upload/pic/12052.png)", "inputFormat": "输入的第一行一个正整数 $n$ ，表示树的节点数。\n\n接下来一行 $n$ 个用空格隔开的正整数 $a_1, a_2, \\ldots, a_n$，依次描述每个节点上题目的毒瘤值。\n\n接下来 $n − 1$ 行，描述这棵树。每行 $2$ 个正整数 $u, v$ ，描述一条树上的边 $(u, v)$ 。（保证 $1 \\leq u, v \\leq n$ ，保证这 $n − 1$ 条边构成了一棵树）\n\n接下来一行一个正整数 $Q$ ，表示 ufozgg 的操作总数。\n\n接下来 $Q$ 行按 ufozgg 执行操作的先后顺序依次描述每个操作，每行 $4$ 个用空格隔开的整数 $op, s, t, k$ ，表示 ufozgg 此次跳跃的起点为 $s$ ，终点为 $t$ ，步频为 $k$ 。如果 $op = 0$ ，表示这是一次削弱操作；如果 $op = 1$ ，表示这是一次统计操作。", "outputFormat": "对于每个统计操作，输出一行一个整数，表示此次统计操作统计到的所有题的毒瘤值总和。", "hint": "对于 $100\\%$ 的数据，$n≤50000$, $Q≤400000$, $1\\leq ai\\leq 10^{13}$。\n\n对于所有的操作保证 $0\\leq op\\leq 1$，$1\\leq s,t,k\\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training 2017] Hello world!", "background": "About a year ago, Xiao V was still a participant in the Tsinghua training camp, sitting in the computer room making a final effort for his OI career that was like a candle in the wind. Now, he has become a proud problem setter. He felt very excited and couldn’t help but exclaim: “Hello world!”.", "description": "Xiao V has $n$ problems. His problems are very tricky, so the caring contestant ufozgg plans to weaken them. To avoid being weakened, Xiao V hides all his tricky problems in a tree with $n$ nodes (nodes are numbered from $1$ to $n$). Every node on the tree corresponds one-to-one with one of Xiao V’s problems. Each problem has a “trickiness value.” The problem corresponding to node $i$ (meaning the node labeled $i$ in the tree, same below) has trickiness value $a_i$.\n\nTo protect his problems, the magician Xiao V cast a spell on the tree. From then on, anyone who wants to explore the tree must perform jump operations on it. Each jump operation includes a start $s$, an end $t$, and a step size $k$. This means the jumper will start from $s$ and reach $t$ by jumping along the simple path on the tree. In each jump, if the shortest path distance from the current node to $t$ is no more than $k$, the jumper jumps directly to $t$; otherwise, the jumper advances exactly $k$ edges along the shortest path toward $t$.\n\nSince Xiao V hid the problems in the tree, ufozgg cannot weaken them directly. He must jump on the tree and weaken problems along the way. Every time ufozgg passes through a node (including the start $s$, even when $s=t$), he will take the square root of that node’s problem’s trickiness value and round it down: that is, if he passes node $i$, he sets $a_i = \\lfloor \\sqrt{a_i} \\rfloor$. We call this a weaken operation.\n\nFrom time to time, ufozgg also wants to know how much he has weakened the problems. Therefore, in some jump operations he gives up weakening and instead computes the sum of trickiness values of the nodes visited in that jump. We call this a query operation.\n\nThe onlooker Lülü is very interested in Xiao V’s tricky problems and ufozgg’s weakening plan. He now wants to know the result ufozgg gets for each query operation. Can you help him?\n\n![](https://cdn.luogu.com.cn/upload/pic/12052.png)", "inputFormat": "The first line contains a positive integer $n$, the number of nodes in the tree.\n\nThe next line contains $n$ space-separated positive integers $a_1, a_2, \\ldots, a_n$, describing the trickiness value on each node.\n\nThe next $n-1$ lines describe the tree. Each line contains two positive integers $u, v$, describing an edge $(u, v)$. It is guaranteed that $1 \\le u, v \\le n$, and that these $n-1$ edges form a tree.\n\nThe next line contains a positive integer $Q$, the total number of operations performed by ufozgg.\n\nThe next $Q$ lines describe each operation in the order they are performed. Each line contains four space-separated integers $op, s, t, k$, meaning the jump starts at $s$, ends at $t$, with step size $k$. If $op = 0$, it is a weaken operation; if $op = 1$, it is a query operation.", "outputFormat": "For each query operation, output a single line with one integer, the sum of the trickiness values of all problems counted in that operation.", "hint": "For $100\\%$ of the testdata, $n \\le 50000$, $Q \\le 400000$, $1 \\le a_i \\le 10^{13}$.\n\nFor all operations, it is guaranteed that $0 \\le op \\le 1$ and $1 \\le s, t, k \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2017] Hello world!", "background": "不远的一年前，小 V 还是一名清华集训的选手，坐在机房里为他已如风中残烛的OI 生涯做最后的挣扎。而如今，他已成为了一名光荣的出题人。他感到非常激动，不禁感叹道： “Hello world!”。", "description": "小 V 有 $n$ 道题，他的题都非常毒瘤，所以关爱选手的 ufozgg 打算削弱这些题。为了逃避削弱，小 V 把他的毒瘤题都藏到了一棵 $n$ 个节点的树里（节点编号从 $1$ 至 $n$），这棵树上的所有节点与小 V 的所有题一一对应。小 V 的每一道题都有一个毒瘤值，节点 $i$ （表示标号为 $i$ 的树上节点，下同）对应的题的毒瘤值为 $a_i$。\n\n魔法师小 V 为了保护他的题目，对这棵树施了魔法，这样一来，任何人想要一探这棵树的究竟，都必须在上面做跳跃操作。每一次跳跃操作包含一个起点 $s$ 、一个终点 $t$ 和一个步频 $k$ ，这表示跳跃者会从 $s$ 出发，在树上沿着简单路径多次跳跃到达 $t$ ，每次跳跃，如果从当前点到 $t$ 的最短路长度不超过 $k$ ，那么跳跃者就会直接跳到 $t$ ，否则跳跃者就会沿着最短路跳过恰好 $k$ 条边。\n\n既然小 V 把题藏在了树里， ufozgg 就不能直接削弱题目了。他就必须在树上跳跃，边跳跃边削弱题目。 ufozgg 每次跳跃经过一个节点（包括起点 $s$ ，当 $s = t$ 的时候也是如此），就会把该节点上的题目的毒瘤值开根并向下取整：即如果他经过了节点 $i$，他就会使 $a_i = \\lfloor \\sqrt{a_i} \\rfloor$。这种操作我们称为削弱操作。\n\nufozgg 还会不时地希望知道他对题目的削弱程度。因此，他在一些跳跃操作中会放弃对题目的削弱，转而统计该次跳跃经过节点的题目毒瘤值总和。这种操作我们称为统计操作。\n\n吃瓜群众绿绿对小 V 的毒瘤题和 ufozgg 的削弱计划常感兴趣。他现在想知道ufozgg 每次做统计操作时得到的结果。你能帮帮他吗？\n\n![](https://cdn.luogu.com.cn/upload/pic/12052.png)", "inputFormat": "输入的第一行一个正整数 $n$ ，表示树的节点数。\n\n接下来一行 $n$ 个用空格隔开的正整数 $a_1, a_2, \\ldots, a_n$，依次描述每个节点上题目的毒瘤值。\n\n接下来 $n − 1$ 行，描述这棵树。每行 $2$ 个正整数 $u, v$ ，描述一条树上的边 $(u, v)$ 。（保证 $1 \\leq u, v \\leq n$ ，保证这 $n − 1$ 条边构成了一棵树）\n\n接下来一行一个正整数 $Q$ ，表示 ufozgg 的操作总数。\n\n接下来 $Q$ 行按 ufozgg 执行操作的先后顺序依次描述每个操作，每行 $4$ 个用空格隔开的整数 $op, s, t, k$ ，表示 ufozgg 此次跳跃的起点为 $s$ ，终点为 $t$ ，步频为 $k$ 。如果 $op = 0$ ，表示这是一次削弱操作；如果 $op = 1$ ，表示这是一次统计操作。", "outputFormat": "对于每个统计操作，输出一行一个整数，表示此次统计操作统计到的所有题的毒瘤值总和。", "hint": "对于 $100\\%$ 的数据，$n≤50000$, $Q≤400000$, $1\\leq ai\\leq 10^{13}$。\n\n对于所有的操作保证 $0\\leq op\\leq 1$，$1\\leq s,t,k\\leq n$。", "locale": "zh-CN"}}}
{"pid": "P4005", "type": "P", "difficulty": 6, "samples": [["4 4\n1 2 1 2\n8\n1 2 3 4 1 2 3 4\n5\n5 4 3 3 5\n8\n1 2 3 4 1 3 2 4", "0 \n0 \n0 \n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["模拟", "搜索", "2017", "树状数组", "O2优化", "枚举", "模拟退火", "CTT（清华集训/北大集训）"], "title": "[清华集训 2017] 小 Y 和地铁", "background": null, "description": "小 Y 是一个爱好旅行的 OIer。一天，她来到了一个新的城市。由于不熟悉那里的交通系统，她选择了坐地铁。\n\n她发现每条地铁线路可以看成平面上的一条曲线，不同线路的交点处一定会设有换乘站 。通过调查得知，没有线路是环线，也没有线路与自身相交。任意两条不同的线路只会在若干个点上相交，没有重合的部分，且没有三线共点的情况。即，如图所示的情况都是不存在的：\n\n ![](https://cdn.luogu.com.cn/upload/pic/12055.png) \n\n小 Y 坐着地铁 $0$ 号线，路上依次经过了 $n$ 个换乘站。她记下了每个换乘站可以换乘的线路编号，发现每条线路与她所乘坐的线路最多只有 $2$ 个换乘站。现在小 Y 想知道，除掉她经过的换乘站以外，这个城市里最少有几个换乘站。只有你告诉她正确的答案，她才会答应下次带你去玩呢。", "inputFormat": "**请注意本题有多组输入数据。**\n\n输入数据的第一行是一个整数 $T$，表示输入数据的组数。接下来依次给出每组数据。\n\n对于每组数据，第一行是一个整数 $n$，表示小 Y 经过的换乘站的数目。第二行为 $n$ 个用空格隔开的整数，依次表示每个换乘站的可以换乘的线路编号。这些编号都在 $1\\sim n$ 之内。", "outputFormat": "对于每组输入数据，输出一行一个整数，表示除掉这 $n$ 个换乘站之外，最少有几个换乘站。", "hint": "【样例 1 解释】\n\n对于样例的前两组数据，一种可能的最优答案如下图所示。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12053.png) \n\n【子任务】\n\n一共有 $50$ 个测试点，每个测试点 $2$ 分。你只有在答案完全正确时才能得到该测试点的全部分数，否则不得分。\n\n对于所有测试点，以及对于样例， $1 \\leq T \\leq 100$, $1 \\leq n \\leq 44$。对于每个测试点， $n$ 的范围如下表：\n\n![](https://cdn.luogu.com.cn/upload/pic/12054.png)", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training 2017] Xiao Y and the Subway", "background": "", "description": "Xiao Y is an OIer who loves traveling. One day, she arrives in a new city. Since she is not familiar with the transportation system there, she chooses to take the subway.\n\nShe discovers that each subway line can be regarded as a curve on the plane, and every intersection between different lines must have a transfer station. From her investigation, she learns that no line is a loop, and no line intersects itself. Any two distinct lines intersect only at finitely many points, have no overlapping segments, and no three lines pass through the same point. That is, the situations shown in the figure do not occur:\n\n![](https://cdn.luogu.com.cn/upload/pic/12055.png)\n\nXiao Y is riding subway line $0$, and along the way she passes $n$ transfer stations in order. She notes the line number available for transfer at each transfer station, and finds that every line shares at most $2$ transfer stations with the line she is on. Now Xiao Y wants to know, excluding the transfer stations she passed, what is the minimum possible number of other transfer stations in the city. Only if you give the correct answer will she agree to take you out next time.", "inputFormat": "Please note that this problem contains multiple test cases.\n\nThe first line of the input data is an integer $T$, indicating the number of test cases. The test cases follow.\n\nFor each test case, the first line is an integer $n$, representing the number of transfer stations Xiao Y passed. The second line contains $n$ space-separated integers, in order, each indicating the line number available for transfer at that transfer station. These indices are all within $1\\sim n$.", "outputFormat": "For each test case, output a single integer on one line, representing the minimum number of transfer stations other than these $n$.", "hint": "[Explanation for Sample 1]\n\nFor the first two test cases in the sample, one possible optimal configuration is shown below.\n\n![](https://cdn.luogu.com.cn/upload/pic/12053.png)\n\n[Subtasks]\n\nThere are $50$ test points, each worth $2$ points. You can only get full points for a test point if your answer is completely correct; otherwise, you get no points.\n\nFor all test points and for the samples, $1 \\leq T \\leq 100$, $1 \\leq n \\leq 44$. For each test point, the range of $n$ is given in the following table:\n\n![](https://cdn.luogu.com.cn/upload/pic/12054.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2017] 小 Y 和地铁", "background": null, "description": "小 Y 是一个爱好旅行的 OIer。一天，她来到了一个新的城市。由于不熟悉那里的交通系统，她选择了坐地铁。\n\n她发现每条地铁线路可以看成平面上的一条曲线，不同线路的交点处一定会设有换乘站 。通过调查得知，没有线路是环线，也没有线路与自身相交。任意两条不同的线路只会在若干个点上相交，没有重合的部分，且没有三线共点的情况。即，如图所示的情况都是不存在的：\n\n ![](https://cdn.luogu.com.cn/upload/pic/12055.png) \n\n小 Y 坐着地铁 $0$ 号线，路上依次经过了 $n$ 个换乘站。她记下了每个换乘站可以换乘的线路编号，发现每条线路与她所乘坐的线路最多只有 $2$ 个换乘站。现在小 Y 想知道，除掉她经过的换乘站以外，这个城市里最少有几个换乘站。只有你告诉她正确的答案，她才会答应下次带你去玩呢。", "inputFormat": "**请注意本题有多组输入数据。**\n\n输入数据的第一行是一个整数 $T$，表示输入数据的组数。接下来依次给出每组数据。\n\n对于每组数据，第一行是一个整数 $n$，表示小 Y 经过的换乘站的数目。第二行为 $n$ 个用空格隔开的整数，依次表示每个换乘站的可以换乘的线路编号。这些编号都在 $1\\sim n$ 之内。", "outputFormat": "对于每组输入数据，输出一行一个整数，表示除掉这 $n$ 个换乘站之外，最少有几个换乘站。", "hint": "【样例 1 解释】\n\n对于样例的前两组数据，一种可能的最优答案如下图所示。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12053.png) \n\n【子任务】\n\n一共有 $50$ 个测试点，每个测试点 $2$ 分。你只有在答案完全正确时才能得到该测试点的全部分数，否则不得分。\n\n对于所有测试点，以及对于样例， $1 \\leq T \\leq 100$, $1 \\leq n \\leq 44$。对于每个测试点， $n$ 的范围如下表：\n\n![](https://cdn.luogu.com.cn/upload/pic/12054.png)", "locale": "zh-CN"}}}
{"pid": "P4006", "type": "P", "difficulty": 5, "samples": [["4\n3 2 3 4\n1 1\n1 1\n1 1", "2 1 3 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "O2优化", "CTT（清华集训/北大集训）"], "title": "[清华集训 2017] 小 Y 和二叉树", "background": null, "description": "小 Y 是一个心灵手巧的 OIer，她有许多二叉树模型。\n\n小 Y 的二叉树模型中，每个结点都具有一个编号，小 Y 把她最喜欢的一个二叉树模型挂在了墙上，树根在最上面，左右子树分别在树根的左下方与右下方，且他们也都满足这样的悬挂规则。为了让这个模型更加美观，小 Y 选择了一种让这棵二叉树的中序遍历序列最小的悬挂方法。所谓中序遍历最小，就是指中序遍历的结点编号序列的字典序最小。\n\n一天，这个模型不小心被掉在了地上，幸运的是，所有结点和边都没摔坏，但是她想不起这个模型原来是怎么悬挂的了，也就是说：她想不起来树根节点的编号了。\n\n小 Y 最近忙于准备清华集训，所以没太多时间处理别的事情，她只好找到同样心灵手巧的你帮忙复原她的二叉树模型。", "inputFormat": "第一行为一个正整数 $n$ ，表示点的个数。\n\n后接 $n$ 行，每行若干个整数：\n\n第 $i + 1$ 行的第一个整数为 $k_i$ ，表示编号为 $i$ 的结点的度数，后接 $k_i$ 个整数 $a_{i, j}$ ，表示编号为 $i$ 的结点与编号为 $a_{i, j}$ 的结点之间有一条边。\n\n同一行输入的相邻两个元素之间，用恰好一个空格隔开。", "outputFormat": "输出共一行， $n$ 个整数，表示字典序最小的中序遍历。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/12056.png) \n\n【子任务】\n\n ![](https://cdn.luogu.com.cn/upload/pic/12057.png) \n\n本题共 $20$ 个测试点，每个测试点 $5$ 分。各个测试点的数据范围如下：\n\n随机数据的生成方式如下：对于第 $13$ 个测试点，从一棵两个结点的树开始，每次随机一个树上的度数为 $1$ 的结点（即叶结点），并生成两个与之直接相连的结点，直到这棵树上有 $n$ 个结点。显然，在这个测试点中， $n$ 是一个偶数。对于第 $15$ 和第 $16$ 个测试点，从一棵一个结点的树开始，每次随机一个树上的度数不超过 $2$ 的结点，并生成一个与之直接相连的结点，直到这棵树上有 $n$ 个结点。\n\n【提示】\n\n我们提供了一个只包含输入和输出功能的程序 `binary\\_sample.cpp`。关于该程序的说明，见 `readme.txt`。你可以在答题时使用该程序的代码，也可以不使用，这将与你的得分无关。", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training 2017] Xiao Y and the Binary Tree", "background": "", "description": "Xiao Y is a handy OIer who owns many binary tree models.\n\nIn Xiao Y’s binary tree model, each node has an id. She hung her favorite binary tree model on the wall, with the root at the top, and the left and right subtrees placed at the lower-left and lower-right of the root, respectively; they all follow the same hanging rule recursively. To make the model more elegant, Xiao Y chose a hanging orientation that makes the inorder traversal sequence of this binary tree lexicographically smallest. “Lexicographically smallest” means the sequence of node ids visited by an inorder traversal is lexicographically minimal.\n\nOne day, the model accidentally fell to the ground. Fortunately, none of the nodes or edges were damaged, but she could no longer recall how the model had been hung; in other words, she forgot the id of the root node.\n\nRecently, Xiao Y has been busy preparing for the Tsinghua training, so she doesn’t have much time for other things. She turns to you for help to restore her binary tree model.", "inputFormat": "The first line contains a positive integer $n$, the number of nodes.\n\nThen follow $n$ lines, each containing several integers:\n\nIn the $(i + 1)$-th line, the first integer is $k_i$, the degree of node $i$, followed by $k_i$ integers $a_{i, j}$, indicating that there is an edge between node $i$ and node $a_{i, j}$.\n\nAdjacent elements on the same line are separated by exactly one space.", "outputFormat": "Output a single line with $n$ integers: the lexicographically smallest inorder traversal.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/12056.png)\n\nSubtasks\n\n![](https://cdn.luogu.com.cn/upload/pic/12057.png)\n\nThis problem has $20$ test points, each worth $5$ points. Constraints for each test point are as follows:\n\nThe random testdata are generated as follows: For the $13$-th test point, start from a tree with two nodes. Each time, pick a node of degree $1$ (i.e., a leaf) uniformly at random and attach two new nodes to it, until the tree has $n$ nodes. Clearly, in this test point, $n$ is even. For the $15$-th and $16$-th test points, start from a tree with one node. Each time, pick a node whose degree does not exceed $2$ uniformly at random and attach one new node to it, until the tree has $n$ nodes.\n\nHint\n\nWe provide a program binary_sample.cpp that only handles input and output. See readme.txt for details. You may use the code of this program when solving the problem, or not; this will not affect your score.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2017] 小 Y 和二叉树", "background": null, "description": "小 Y 是一个心灵手巧的 OIer，她有许多二叉树模型。\n\n小 Y 的二叉树模型中，每个结点都具有一个编号，小 Y 把她最喜欢的一个二叉树模型挂在了墙上，树根在最上面，左右子树分别在树根的左下方与右下方，且他们也都满足这样的悬挂规则。为了让这个模型更加美观，小 Y 选择了一种让这棵二叉树的中序遍历序列最小的悬挂方法。所谓中序遍历最小，就是指中序遍历的结点编号序列的字典序最小。\n\n一天，这个模型不小心被掉在了地上，幸运的是，所有结点和边都没摔坏，但是她想不起这个模型原来是怎么悬挂的了，也就是说：她想不起来树根节点的编号了。\n\n小 Y 最近忙于准备清华集训，所以没太多时间处理别的事情，她只好找到同样心灵手巧的你帮忙复原她的二叉树模型。", "inputFormat": "第一行为一个正整数 $n$ ，表示点的个数。\n\n后接 $n$ 行，每行若干个整数：\n\n第 $i + 1$ 行的第一个整数为 $k_i$ ，表示编号为 $i$ 的结点的度数，后接 $k_i$ 个整数 $a_{i, j}$ ，表示编号为 $i$ 的结点与编号为 $a_{i, j}$ 的结点之间有一条边。\n\n同一行输入的相邻两个元素之间，用恰好一个空格隔开。", "outputFormat": "输出共一行， $n$ 个整数，表示字典序最小的中序遍历。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/12056.png) \n\n【子任务】\n\n ![](https://cdn.luogu.com.cn/upload/pic/12057.png) \n\n本题共 $20$ 个测试点，每个测试点 $5$ 分。各个测试点的数据范围如下：\n\n随机数据的生成方式如下：对于第 $13$ 个测试点，从一棵两个结点的树开始，每次随机一个树上的度数为 $1$ 的结点（即叶结点），并生成两个与之直接相连的结点，直到这棵树上有 $n$ 个结点。显然，在这个测试点中， $n$ 是一个偶数。对于第 $15$ 和第 $16$ 个测试点，从一棵一个结点的树开始，每次随机一个树上的度数不超过 $2$ 的结点，并生成一个与之直接相连的结点，直到这棵树上有 $n$ 个结点。\n\n【提示】\n\n我们提供了一个只包含输入和输出功能的程序 `binary\\_sample.cpp`。关于该程序的说明，见 `readme.txt`。你可以在答题时使用该程序的代码，也可以不使用，这将与你的得分无关。", "locale": "zh-CN"}}}
{"pid": "P4007", "type": "P", "difficulty": 6, "samples": [["3 2 6\n1\n2\n3", "499122177\n415935148\n471393168"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "O2优化", "矩阵加速", "概率论", "期望", "CTT（清华集训/北大集训）"], "title": "[清华集训 2017] 小 Y 和恐怖的奴隶主", "background": "“A fight? Count me in!” 要打架了，算我一个。\n\n“Everyone, get in here!” 所有人，都过来！", "description": "小 Y 是一个喜欢玩游戏的 OIer。一天，她正在玩一款游戏，要打一个 Boss。\n\n虽然这个 Boss 有 $10^{100}$ 点生命值，但它只带了一个随从——一个只有 $m$ 点生命值的“恐怖的奴隶主”。\n\n这个“恐怖的奴隶主”有一个特殊的技能：每当它被扣减生命值但没有死亡（死亡即生命值 $\\leq 0$），且 Boss 的随从数量小于上限 $k$，便会召唤一个新的具有 $m$ 点生命值的“恐怖的奴隶主”。\n\n现在小 Y 可以进行 $n$ 次攻击，每次攻击时，会从 Boss 以及 Boss 的所有随从中的等概率随机选择一个，并扣减 $1$ 点生命值，她想知道进行 $n$ 次攻击后扣减 Boss 的生命值点数的期望。为了避免精度误差，你的答案需要对 $998244353$ 取模。", "inputFormat": "输入第一行包含三个正整数 $T, m, k$，$T$ 表示询问组数，$m, k$ 的含义见题目描述。\n\n接下来 $T$ 行，每行包含一个正整数 $n$，表示询问进行 $n$ 次攻击后扣减Boss的生命值点数的期望。", "outputFormat": "输出共 $T$ 行，对于每个询问输出一行一个非负整数，表示该询问的答案对 $998244353$ 取模的结果。\n\n可以证明，所求期望一定是一个有理数，设其为 $p / q$ $(\\mathrm{gcd}(p,q) = 1)$，那么你输出的数 $x$ 要满足 $p \\equiv qx \\pmod{998244353}$。", "hint": "【样例 $1$ 解释】\n\n对于第一次询问，第一次攻击有 $\\frac{1}{2}$ 的概率扣减 Boss 的生命值，有 $\\frac{1}{2}$ 的概率扣减随从的生命值，所以答案为 $\\frac{1}{2}$。$1 \\equiv 2 \\times 499122177 \\pmod{998244353}$。\n\n对于第二次询问，如果第一次攻击扣减了 Boss 的生命值，那么有 $\\frac{1}{2}$ 的概率第二次攻击仍扣减 Boss 的生命值，有 $\\frac{1}{2}$ 的概率第二次攻击扣减随从的生命值；如果第一次攻击扣减了随从的生命值，那么现在又新召唤了一个随从（“恐怖的奴隶主”），于是有 $\\frac{1}{3}$ 的概率第二次攻击扣减 Boss 的生命值，有 $\\frac{2}{3}$ 的概率第二次攻击扣减随从的生命值。所以答案为 $\\frac{1}{2}\\times\\frac{1}{2}\\times2+\\frac{1}{2}\\times\\frac{1}{2}\\times1+\\frac{1}{2}\\times\\frac{1}{3}\\times1+\\frac{1}{2}\\times\\frac{2}{3}\\times0 = \\frac{11}{12}$。 $11 \\equiv 12 \\times 415935148\\pmod{998244353}$。\n\n【提示】\n\n题目顺序可能与难度无关。\n\n【子任务】\n\n在所有测试点中，$1 \\leq T \\leq 1000, 1 \\leq n \\leq {10}^{18}, 1 \\leq m \\leq 3, 1 \\leq k \\leq 8$。\n\n各个测试点的分值和数据范围如下：\n\n![12058](https://cdn.luogu.com.cn/upload/pic/12058.png)", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training 2017] Xiao Y and the \"Terrifying Slave Owner\"", "background": "“A fight? Count me in!” Count me in for a fight.\n\n“Everyone, get in here!” Everyone, come here!", "description": "Xiao Y is an OIer who likes playing games. One day, she is playing a game and needs to fight a Boss.\n\nAlthough this Boss has $10^{100}$ HP, it only brings one minion — a \"Terrifying Slave Owner\" with exactly $m$ HP.\n\nThis \"Terrifying Slave Owner\" has a special skill: whenever it takes damage but does not die (death means HP $ \\leq 0$), and the number of the Boss's minions is less than the cap $k$, it summons a new \"Terrifying Slave Owner\" with $m$ HP.\n\nNow Xiao Y can make $n$ attacks. Each time she attacks, she chooses uniformly at random one target from the set consisting of the Boss and all of the Boss's minions, and reduces that target's HP by $1$. She wants to know the expected total HP deducted from the Boss after $n$ attacks. To avoid precision issues, your answer should be taken modulo $998244353$.", "inputFormat": "The first line contains three positive integers $T, m, k$, where $T$ is the number of queries, and $m, k$ are as defined in the statement.\n\nThen follow $T$ lines. Each line contains a positive integer $n$, representing a query asking for the expected HP deducted from the Boss after $n$ attacks.", "outputFormat": "Output $T$ lines. For each query, output a non-negative integer — the answer modulo $998244353$.\n\nIt can be proven that the desired expectation is a rational number. Suppose it equals $p / q$ $(\\mathrm{gcd}(p,q) = 1)$. Then the number $x$ you output should satisfy $p \\equiv qx \\pmod{998244353}$.", "hint": "[Sample 1 Explanation]\n\nFor the first query, the first attack has probability $\\frac{1}{2}$ to hit the Boss and probability $\\frac{1}{2}$ to hit the minion, so the answer is $\\frac{1}{2}$. $1 \\equiv 2 \\times 499122177 \\pmod{998244353}$.\n\nFor the second query: if the first attack hits the Boss, then there is probability $\\frac{1}{2}$ that the second attack still hits the Boss and probability $\\frac{1}{2}$ that it hits the minion; if the first attack hits the minion, then a new minion (the \"Terrifying Slave Owner\") is summoned, so there is probability $\\frac{1}{3}$ that the second attack hits the Boss and probability $\\frac{2}{3}$ that it hits a minion. Therefore the answer is $\\frac{1}{2}\\times\\frac{1}{2}\\times2+\\frac{1}{2}\\times\\frac{1}{2}\\times1+\\frac{1}{2}\\times\\frac{1}{3}\\times1+\\frac{1}{2}\\times\\frac{2}{3}\\times0 = \\frac{11}{12}$. $11 \\equiv 12 \\times 415935148\\pmod{998244353}$.\n\n[Tips]\n\nThe order of problems may not correspond to difficulty.\n\n[Subtasks]\n\nAcross all test points, $1 \\leq T \\leq 1000, 1 \\leq n \\leq {10}^{18}, 1 \\leq m \\leq 3, 1 \\leq k \\leq 8$.\n\nThe scores and Constraints for each test point are as follows:\n\n![12058](https://cdn.luogu.com.cn/upload/pic/12058.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2017] 小 Y 和恐怖的奴隶主", "background": "“A fight? Count me in!” 要打架了，算我一个。\n\n“Everyone, get in here!” 所有人，都过来！", "description": "小 Y 是一个喜欢玩游戏的 OIer。一天，她正在玩一款游戏，要打一个 Boss。\n\n虽然这个 Boss 有 $10^{100}$ 点生命值，但它只带了一个随从——一个只有 $m$ 点生命值的“恐怖的奴隶主”。\n\n这个“恐怖的奴隶主”有一个特殊的技能：每当它被扣减生命值但没有死亡（死亡即生命值 $\\leq 0$），且 Boss 的随从数量小于上限 $k$，便会召唤一个新的具有 $m$ 点生命值的“恐怖的奴隶主”。\n\n现在小 Y 可以进行 $n$ 次攻击，每次攻击时，会从 Boss 以及 Boss 的所有随从中的等概率随机选择一个，并扣减 $1$ 点生命值，她想知道进行 $n$ 次攻击后扣减 Boss 的生命值点数的期望。为了避免精度误差，你的答案需要对 $998244353$ 取模。", "inputFormat": "输入第一行包含三个正整数 $T, m, k$，$T$ 表示询问组数，$m, k$ 的含义见题目描述。\n\n接下来 $T$ 行，每行包含一个正整数 $n$，表示询问进行 $n$ 次攻击后扣减Boss的生命值点数的期望。", "outputFormat": "输出共 $T$ 行，对于每个询问输出一行一个非负整数，表示该询问的答案对 $998244353$ 取模的结果。\n\n可以证明，所求期望一定是一个有理数，设其为 $p / q$ $(\\mathrm{gcd}(p,q) = 1)$，那么你输出的数 $x$ 要满足 $p \\equiv qx \\pmod{998244353}$。", "hint": "【样例 $1$ 解释】\n\n对于第一次询问，第一次攻击有 $\\frac{1}{2}$ 的概率扣减 Boss 的生命值，有 $\\frac{1}{2}$ 的概率扣减随从的生命值，所以答案为 $\\frac{1}{2}$。$1 \\equiv 2 \\times 499122177 \\pmod{998244353}$。\n\n对于第二次询问，如果第一次攻击扣减了 Boss 的生命值，那么有 $\\frac{1}{2}$ 的概率第二次攻击仍扣减 Boss 的生命值，有 $\\frac{1}{2}$ 的概率第二次攻击扣减随从的生命值；如果第一次攻击扣减了随从的生命值，那么现在又新召唤了一个随从（“恐怖的奴隶主”），于是有 $\\frac{1}{3}$ 的概率第二次攻击扣减 Boss 的生命值，有 $\\frac{2}{3}$ 的概率第二次攻击扣减随从的生命值。所以答案为 $\\frac{1}{2}\\times\\frac{1}{2}\\times2+\\frac{1}{2}\\times\\frac{1}{2}\\times1+\\frac{1}{2}\\times\\frac{1}{3}\\times1+\\frac{1}{2}\\times\\frac{2}{3}\\times0 = \\frac{11}{12}$。 $11 \\equiv 12 \\times 415935148\\pmod{998244353}$。\n\n【提示】\n\n题目顺序可能与难度无关。\n\n【子任务】\n\n在所有测试点中，$1 \\leq T \\leq 1000, 1 \\leq n \\leq {10}^{18}, 1 \\leq m \\leq 3, 1 \\leq k \\leq 8$。\n\n各个测试点的分值和数据范围如下：\n\n![12058](https://cdn.luogu.com.cn/upload/pic/12058.png)", "locale": "zh-CN"}}}
{"pid": "P4008", "type": "P", "difficulty": 6, "samples": [["15\nInsert 26\nabcdefghijklmnop\nqrstuv wxy\nMove 15\nDelete 11\nMove 5\nInsert 1\n^\nNext\nInsert 1\n_\nNext\nNext\nInsert 4\n.\\/.\nGet 4\nPrev\nInsert 1\n^\nMove 0\nGet 22\n\n", ".\\/.\nabcde^_^f.\\/.ghijklmno\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "2003", "平衡树", "递归", "NOI", "分块"], "title": "[NOI2003] 文本编辑器", "background": null, "description": "很久很久以前，DOS 3.x 的程序员们开始对 `EDLIN` 感到厌倦。于是，人们开始纷纷改用自己写的文本编辑器⋯⋯\n\n多年之后，出于偶然的机会，小明找到了当时的一个编辑软件。进行了一些简单的测试后，小明惊奇地发现：那个软件每秒能够进行上万次编辑操作（当然，你不能手工进行这样的测试）！于是，小明废寝忘食地想做一个同样的东西出来。你能帮助他吗？\n\n为了明确目标，小明对“文本编辑器”做了一个抽象的定义：\n\n文本：由 $0$ 个或多个 ASCII 码在闭区间 $\\left[32,126\\right]$ 内的字符构成的序列。\n\n光标：在一段文本中用于指示位置的标记，可以位于文本首部，文本尾部或文本的某两个字符之间。\n\n文本编辑器：由一段文本和该文本中的一个光标组成的，支持如下操作的数据结构。如果这段文本为空，我们就说这个文本编辑器是空的。\n\n| 操作名称                 | 输入文件中的格式   | 功能                                         |\n| :------------------- | :--------- | :----------------------------------------- |\n| $\\text{Move}(k)$     | Move k     | 将光标移动到第 $k$ 个字符之后，如果 $k=0$，将光标移到文本开头。      |\n| $\\text{Insert}(n,s)$ | Insert n s | 在光标处插入长度为 $n$ 的字符串 $s$，光标位置不变 保证 $n\\geq1$。 |\n| $\\text{Delete}(n)$   | Delete n   | 删除光标后的 $n$ 个字符，光标位置不变，保证 $n \\geq 1$。       |\n| $\\text{Get}(n)$      | Get n      | 输出光标后的 $n$ 个字符，光标位置不变，保证 $n \\geq 1$。       |\n| $\\text{Prev}()$      | Prev       | 光标前移一个字符。                                  |\n| $\\text{Next}()$      | Next       | 光标后移一个字符。                                  |\n\n你的任务是：\n\n- 建立一个空的文本编辑器。\n\n- 从输入文件中读入一些操作并执行。\n\n- 对所有执行过的 `GET` 操作，将指定的内容写入输出文件。", "inputFormat": "输入文件 `editor.in` 的第一行是指令条数 $t$，以下是需要执行的 $t$ 个操作。其中：\n\n为了使输入文件便于阅读，`Insert` 操作的字符串中可能会插入一些回车符，请忽略掉它们（如果难以理解这句话，可以参照样例）。\n\n除了回车符之外，输入文件的所有字符的 ASCII 码都在闭区间 $\\left[32,126\\right]$ 内。行尾没有空格。\n\n这里我们有如下假定：\n\n- `Move` 操作不超过 $5 \\times 10^4$ 个，`Insert` 和 `Delete` 操作的总个数不超过 $4 \\times 10^3$，`Prev` 和 `Next` 操作的总个数不超过 $2 \\times 10^5$。\n\n- 所有 `INSERT` 插入的字符数之和不超过 $2$ MB（$1$ MB = $1024\\times 1024$ 字节），正确的输出文件长度不超过 $3$ MB。\n\n- `Delete` 操作和 `Get` 操作执行时光标后必然有足够的字符。`Move`、`Prev`、`Next` 操作必然不会试图把光标移动到非法位置。\n\n- 输入文件没有错误。\n\n对 C++ 选手的提示：经测试，最大的测试数据使用 `fstream` 进行输入有可能会比使用 `stdio` 慢约 $1$ 秒。", "outputFormat": "输出文件 `editor.out` 的每行依次对应输入文件中每条 `Get` 指令的输出。", "hint": ":::info[关于样例输出]\n第一个操作插入 `abcdefghijklmnopqrstuv wxy`，完成后文本变为 `abcdefghijklmnopqrstuv wxy`。\n\n第三个操作在第 $15$ 个字符后面删除 $11$ 个字符，完成后文本变为 `abcdefghijklmno`。\n\n第五个操作在第 $5$ 个字符后面插入 `^`，第七个操作在第 $6$ 个字符后面插入 `_`，完成后文本变为 `abcde^_fghijklmno`。\n\n第十个操作在第 $8$ 个字符后面插入 `.\\/.`，完成后文本变为 `abcde^_f.\\/.ghijklmno`。\n\n第十一个操作获取第 $8$ 个字符后面的 $4$ 个字符，输出 `.\\/.`。\n\n第十三个操作在第 $7$ 个字符后面插入 `^`，完成后文本变为 `abcde^_^f.\\/.ghijklmno`。\n\n第十五个操作获取开头后面的 $22$ 个字符，输出 `abcde^_^f.\\/.ghijklmno`。\n:::", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2003] Text Editor", "background": "", "description": "A long time ago, programmers using DOS 3.x grew tired of `EDLIN`. So, people started switching to their own text editors...\n\nMany years later, by chance, Xiaoming found one of those editors. After running some simple tests, he was surprised to find that the software could perform over ten thousand editing operations per second (of course, you cannot perform such a test by hand). Xiaoming became determined to build something similar. Can you help him?\n\nTo clarify the goal, Xiaoming gives an abstract definition of a \"text editor\":\n\nText: A sequence consisting of $0$ or more characters whose ASCII codes lie in the closed interval $\\left[32,126\\right]$.\n\nCursor: A marker indicating a position within a text. It can be at the beginning of the text, at the end of the text, or between any two characters.\n\nText editor: A data structure composed of a piece of text and a cursor within the text, supporting the following operations. If the text is empty, we say the text editor is empty.\n\n| Operation name            | Format in input file | Function                                                                 |\n| :------------------------ | :------------------- | :------------------------------------------------------------------------ |\n| $\\text{Move}(k)$          | Move k               | Move the cursor to the position after the $k$-th character; if $k = 0$, move the cursor to the beginning of the text. |\n| $\\text{Insert}(n,s)$      | Insert n s           | Insert the string $s$ of length $n$ at the cursor. The cursor position does not change. Guarantee that $n \\geq 1$. |\n| $\\text{Delete}(n)$        | Delete n             | Delete the $n$ characters after the cursor. The cursor position does not change. Guarantee that $n \\geq 1$. |\n| $\\text{Get}(n)$           | Get n                | Output the $n$ characters after the cursor. The cursor position does not change. Guarantee that $n \\geq 1$. |\n| $\\text{Prev}()$           | Prev                 | Move the cursor one character to the left.                                |\n| $\\text{Next}()$           | Next                 | Move the cursor one character to the right.                               |\n\nYour task is:\n\n- Build an empty text editor.\n- Read a sequence of operations from the input file and execute them.\n- For every executed `GET` operation, write the specified content to the output file.", "inputFormat": "The first line of the input file `editor.in` contains the number of commands $t$. Then follow the $t$ operations to perform.\n\nTo make the input file easier to read, newline characters may be inserted into the string of an `Insert` operation; please ignore them (if this is unclear, refer to the sample).\n\nExcept for newline characters, the ASCII codes of all characters in the input file lie in the closed interval $\\left[32,126\\right]$. There are no trailing spaces at the ends of lines.\n\nWe make the following assumptions:\n\n- The number of `Move` operations does not exceed $5 \\times 10^4$, the total number of `Insert` and `Delete` operations does not exceed $4 \\times 10^3$, and the total number of `Prev` and `Next` operations does not exceed $2 \\times 10^5$.\n- The total number of characters inserted by all `INSERT` operations does not exceed $2$ MB ($1$ MB = $1024 \\times 1024$ bytes), and the length of the correct output file does not exceed $3$ MB.\n- When executing `Delete` and `Get`, there are always enough characters after the cursor. `Move`, `Prev`, and `Next` will never attempt to move the cursor to an invalid position.\n- The input file contains no errors.\n\nHint for C++ contestants: As tested, on the largest testdata, using `fstream` for input may be about $1$ second slower than using `stdio`.", "outputFormat": "Each line of the output file `editor.out` corresponds, in order, to the output of each `Get` command in the input file.", "hint": ":::info[About the sample output]\nThe first operation inserts `abcdefghijklmnopqrstuv wxy`, resulting in the text `abcdefghijklmnopqrstuv wxy`.\n\nThe third operation deletes $11$ characters after the $15$-th character, resulting in the text `abcdefghijklmno`.\n\nThe fifth operation inserts `^` after the $5$-th character, and the seventh operation inserts `_` after the $6$-th character, resulting in the text `abcde^_fghijklmno`.\n\nThe tenth operation inserts `.\\/.` after the $8$-th character, resulting in the text `abcde^_f.\\/.ghijklmno`.\n\nThe eleventh operation gets the $4$ characters after the $8$-th character and outputs `.\\/.`.\n\nThe thirteenth operation inserts `^` after the $7$-th character, resulting in the text `abcde^_^f.\\/.ghijklmno`.\n\nThe fifteenth operation gets the $22$ characters after the beginning and outputs `abcde^_^f.\\/.ghijklmno`.\n:::\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2003] 文本编辑器", "background": null, "description": "很久很久以前，DOS 3.x 的程序员们开始对 `EDLIN` 感到厌倦。于是，人们开始纷纷改用自己写的文本编辑器⋯⋯\n\n多年之后，出于偶然的机会，小明找到了当时的一个编辑软件。进行了一些简单的测试后，小明惊奇地发现：那个软件每秒能够进行上万次编辑操作（当然，你不能手工进行这样的测试）！于是，小明废寝忘食地想做一个同样的东西出来。你能帮助他吗？\n\n为了明确目标，小明对“文本编辑器”做了一个抽象的定义：\n\n文本：由 $0$ 个或多个 ASCII 码在闭区间 $\\left[32,126\\right]$ 内的字符构成的序列。\n\n光标：在一段文本中用于指示位置的标记，可以位于文本首部，文本尾部或文本的某两个字符之间。\n\n文本编辑器：由一段文本和该文本中的一个光标组成的，支持如下操作的数据结构。如果这段文本为空，我们就说这个文本编辑器是空的。\n\n| 操作名称                 | 输入文件中的格式   | 功能                                         |\n| :------------------- | :--------- | :----------------------------------------- |\n| $\\text{Move}(k)$     | Move k     | 将光标移动到第 $k$ 个字符之后，如果 $k=0$，将光标移到文本开头。      |\n| $\\text{Insert}(n,s)$ | Insert n s | 在光标处插入长度为 $n$ 的字符串 $s$，光标位置不变 保证 $n\\geq1$。 |\n| $\\text{Delete}(n)$   | Delete n   | 删除光标后的 $n$ 个字符，光标位置不变，保证 $n \\geq 1$。       |\n| $\\text{Get}(n)$      | Get n      | 输出光标后的 $n$ 个字符，光标位置不变，保证 $n \\geq 1$。       |\n| $\\text{Prev}()$      | Prev       | 光标前移一个字符。                                  |\n| $\\text{Next}()$      | Next       | 光标后移一个字符。                                  |\n\n你的任务是：\n\n- 建立一个空的文本编辑器。\n\n- 从输入文件中读入一些操作并执行。\n\n- 对所有执行过的 `GET` 操作，将指定的内容写入输出文件。", "inputFormat": "输入文件 `editor.in` 的第一行是指令条数 $t$，以下是需要执行的 $t$ 个操作。其中：\n\n为了使输入文件便于阅读，`Insert` 操作的字符串中可能会插入一些回车符，请忽略掉它们（如果难以理解这句话，可以参照样例）。\n\n除了回车符之外，输入文件的所有字符的 ASCII 码都在闭区间 $\\left[32,126\\right]$ 内。行尾没有空格。\n\n这里我们有如下假定：\n\n- `Move` 操作不超过 $5 \\times 10^4$ 个，`Insert` 和 `Delete` 操作的总个数不超过 $4 \\times 10^3$，`Prev` 和 `Next` 操作的总个数不超过 $2 \\times 10^5$。\n\n- 所有 `INSERT` 插入的字符数之和不超过 $2$ MB（$1$ MB = $1024\\times 1024$ 字节），正确的输出文件长度不超过 $3$ MB。\n\n- `Delete` 操作和 `Get` 操作执行时光标后必然有足够的字符。`Move`、`Prev`、`Next` 操作必然不会试图把光标移动到非法位置。\n\n- 输入文件没有错误。\n\n对 C++ 选手的提示：经测试，最大的测试数据使用 `fstream` 进行输入有可能会比使用 `stdio` 慢约 $1$ 秒。", "outputFormat": "输出文件 `editor.out` 的每行依次对应输入文件中每条 `Get` 指令的输出。", "hint": ":::info[关于样例输出]\n第一个操作插入 `abcdefghijklmnopqrstuv wxy`，完成后文本变为 `abcdefghijklmnopqrstuv wxy`。\n\n第三个操作在第 $15$ 个字符后面删除 $11$ 个字符，完成后文本变为 `abcdefghijklmno`。\n\n第五个操作在第 $5$ 个字符后面插入 `^`，第七个操作在第 $6$ 个字符后面插入 `_`，完成后文本变为 `abcde^_fghijklmno`。\n\n第十个操作在第 $8$ 个字符后面插入 `.\\/.`，完成后文本变为 `abcde^_f.\\/.ghijklmno`。\n\n第十一个操作获取第 $8$ 个字符后面的 $4$ 个字符，输出 `.\\/.`。\n\n第十三个操作在第 $7$ 个字符后面插入 `^`，完成后文本变为 `abcde^_^f.\\/.ghijklmno`。\n\n第十五个操作获取开头后面的 $22$ 个字符，输出 `abcde^_^f.\\/.ghijklmno`。\n:::", "locale": "zh-CN"}}}
{"pid": "P4009", "type": "P", "difficulty": 5, "samples": [["9 3 2 3 6\n0 0 0 0 1 0 0 0 0\n0 0 0 1 0 1 1 0 0\n1 0 1 0 0 0 0 1 0\n0 0 0 0 0 1 0 0 1\n1 0 0 1 0 0 1 0 0\n0 1 0 0 0 0 0 1 0\n0 0 0 0 1 0 0 0 1\n1 0 0 1 0 0 0 1 0\n0 1 0 0 0 0 0 0 0", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["O2优化", "图论建模", "最短路", "费用流", "网络流与线性规划 24 题"], "title": "汽车加油行驶问题", "background": null, "description": "给定一个 $N \\times N$ 的方形网格，设其左上角为起点◎，坐标$(1,1)$，$X$ 轴向右为正，$Y$ 轴向下为正，每个方格边长为 $1$，如图所示。\n\n![](https://cdn.luogu.com.cn/upload/pic/12156.png)\n\n一辆汽车从起点◎出发驶向右下角终点▲，其坐标为 $(N,N)$。\n\n在若干个网格交叉点处，设置了油库，可供汽车在行驶途中加油。汽车在行驶过程中应遵守如下规则：\n\n1. 汽车只能沿网格边行驶，装满油后能行驶 $K$ 条网格边。出发时汽车已装满油，在起点与终点处不设油库。\n\n1. 汽车经过一条网格边时，若其 $X$ 坐标或 $Y$ 坐标减小，则应付费用 $B$ ，否则免付费用。\n\n1. 汽车在行驶过程中遇油库则应加满油并付加油费用 $A$。\n\n1. 在需要时可在网格点处增设油库，并付增设油库费用 $C$（不含加油费用$A$）。\n\n1. $N,K,A,B,C$ 均为正整数，且满足约束：$2\\leq N\\leq 100,2 \\leq K \\leq 10$。\n\n设计一个算法，求出汽车从起点出发到达终点所付的最小费用。", "inputFormat": "文件的第一行是 $N,K,A,B,C$ 的值。\n\n第二行起是一个 $N\\times N$ 的 $0-1$ 方阵，每行 $N$ 个值，至 $N+1$ 行结束。\n\n方阵的第 $i$ 行第 $j$ 列处的值为 $1$ 表示在网格交叉点 $(i,j)$ 处设置了一个油库，为 $0$ 时表示未设油库。各行相邻两个数以空格分隔。", "outputFormat": "程序运行结束时，输出最小费用。", "hint": "$2 \\leq n \\leq 100,2 \\leq k \\leq 10$。", "locale": "zh-CN", "translations": {"en": {"title": "Car Refueling on a Grid", "background": "", "description": "Given an $N \\times N$ square grid with the top-left corner as the start point ◎ at coordinates $(1, 1)$, where the $X$-axis increases to the right and the $Y$-axis increases downward, and each grid cell has side length $1$, as shown in the figure.\n\n![](https://cdn.luogu.com.cn/upload/pic/12156.png)\n\nA car starts from ◎ and drives to the bottom-right corner ▲ at coordinates $(N, N)$.\n\nFuel depots are set at some grid intersections, where the car can refuel during the trip. The car must follow these rules:\n\n1. The car can move only along grid edges, and with a full tank it can travel $K$ grid edges. The car starts with a full tank. There are no depots at the start or end points.\n2. When the car traverses a grid edge, if its $X$-coordinate or $Y$-coordinate decreases, it must pay a fee of $B$; otherwise, there is no fee.\n3. When the car encounters a depot during the trip, it must refuel to full and pay a refueling cost of $A$.\n4. When needed, a new depot may be added at a grid point by paying an installation cost of $C$ (this does not include the refueling cost $A$).\n5. $N, K, A, B, C$ are all positive integers and satisfy the constraints $2 \\leq N \\leq 100, 2 \\leq K \\leq 10$.\n\nDesign an algorithm to compute the minimum total cost for the car to travel from the start to the destination.", "inputFormat": "The first line contains the values of $N, K, A, B, C$.\n\nStarting from the second line, an $N \\times N$ binary matrix is given, ending at line $N + 1$, with $N$ values per row.\n\nIf the value at row $i$, column $j$ is $1$, it means a fuel depot is set at the grid intersection $(i, j)$; if it is $0$, no depot is set there. Adjacent numbers in the same row are separated by spaces.", "outputFormat": "Output the minimum total cost at the end of the program.", "hint": "Constraints: $2 \\leq N \\leq 100, 2 \\leq K \\leq 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "汽车加油行驶问题", "background": null, "description": "给定一个 $N \\times N$ 的方形网格，设其左上角为起点◎，坐标$(1,1)$，$X$ 轴向右为正，$Y$ 轴向下为正，每个方格边长为 $1$，如图所示。\n\n![](https://cdn.luogu.com.cn/upload/pic/12156.png)\n\n一辆汽车从起点◎出发驶向右下角终点▲，其坐标为 $(N,N)$。\n\n在若干个网格交叉点处，设置了油库，可供汽车在行驶途中加油。汽车在行驶过程中应遵守如下规则：\n\n1. 汽车只能沿网格边行驶，装满油后能行驶 $K$ 条网格边。出发时汽车已装满油，在起点与终点处不设油库。\n\n1. 汽车经过一条网格边时，若其 $X$ 坐标或 $Y$ 坐标减小，则应付费用 $B$ ，否则免付费用。\n\n1. 汽车在行驶过程中遇油库则应加满油并付加油费用 $A$。\n\n1. 在需要时可在网格点处增设油库，并付增设油库费用 $C$（不含加油费用$A$）。\n\n1. $N,K,A,B,C$ 均为正整数，且满足约束：$2\\leq N\\leq 100,2 \\leq K \\leq 10$。\n\n设计一个算法，求出汽车从起点出发到达终点所付的最小费用。", "inputFormat": "文件的第一行是 $N,K,A,B,C$ 的值。\n\n第二行起是一个 $N\\times N$ 的 $0-1$ 方阵，每行 $N$ 个值，至 $N+1$ 行结束。\n\n方阵的第 $i$ 行第 $j$ 列处的值为 $1$ 表示在网格交叉点 $(i,j)$ 处设置了一个油库，为 $0$ 时表示未设油库。各行相邻两个数以空格分隔。", "outputFormat": "程序运行结束时，输出最小费用。", "hint": "$2 \\leq n \\leq 100,2 \\leq k \\leq 10$。", "locale": "zh-CN"}}}
{"pid": "P4010", "type": "P", "difficulty": 6, "samples": [["5\n2 1\n2 2\n2 3\n2 4\n3 1\n1 1\n1 2\n1 3\n3 2", "42/43"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "O2优化", "CTSC/CTS"], "title": "[CTSC2012] 梭哈游戏", "background": "", "description": "小 Y 和小 Z 最近迷上了一种叫梭哈的扑克游戏。梭哈又称沙蟹，是英文 Show Hand 的音译，是一种使用黑桃、红心、梅花、方片的 A 到 K 共 $52$ 张牌(没有大小王）来进行的扑克牌游戏。\n\n和其他扑克游戏一样，梭哈的目的是得到最大的牌型并赢得牌局：每名玩家首先需要下基本的注额，之后将获得一张底牌，这张牌只有自己知道。普通梭哈游戏的规则是，在发完底牌后的第一轮时，每个玩家都将得到一张明牌（明牌是摆在台面上的，所有人都能看见），拥有最大明牌的玩家首先发言，他可以下注、不下注（让牌）或盖牌（放弃）也可以全压（梭哈），其他玩家可以跟注（有玩家全压时必须全压）、加注或盖牌（放弃），放弃的玩家将无法继续游戏，并且之\n\n前押的筹码无法取回。而全压之后将直接把每个人的手牌补充至 $5$ 张进行最后的判定；第二圈、第三圈和第四圈的进程与第一圈是类似的。最后，每位玩家要比牌型的大小以确定赢家。牌最大的玩家赢得牌局。\n\n所有五张牌的组合，按以下秩序， 由大至小 排行分为不同牌型：\n\n1、同花顺（`Straight Flush`）：同一花色，顺序的牌。 例： $Q♦ J♦ 10♦ 9♦ 8♦$；\n\n2、四条（`Four of a Kind`）：有四张同一点数的牌。 例： $10♣ 10♦ 10♥ 10♠ 9♥$；\n\n3、满堂红（`Full House`）：三张同一点数的牌，加一对其他点数的牌。 例： $8♣ 8♦ 8♠ K♥ K♠$；\n\n4、同花（`Flush`）：五张同一花色的牌。 例： $A♠ K♠ 10♠ 9♠ 8♠$；\n\n5、顺子（`Straight`）：五张顺连的牌。 例： $K♦ Q♥ J♠ 10♦ 9♦$；\n\n6、三条（`Three of a kind`）：有三张同一点数的牌。 例： $J♣ J♥ J♠ K♦ 9♠$；\n\n7、两对（`Two Pairs`）：两张相同点数的牌，加另外两张相同点数的牌。 例： $A♣ A♦ 8♥ 8♠ Q♠$；\n\n8、一对（`One Pair`）：两张相同点数的牌。 例： $9♥ 9♠ A♣ J♠ 8♥$；\n\n9、无对（`Zilch`）：不能排成以上组合的牌，以点数决定大小。例： $A♦ Q♦ J♠ 9♣ 8♣$。\n\n若牌型一样则 利用 点数 和花色决定胜负 。（点数 优先）\n\n点数 的顺序（ 从 大至小） 为：$A>K>Q>J>10>9>8>7>6>5>4>3>2$。（注：当 $5$ 张手牌是 $5, 4, 3, 2, A$ 的时候，$A$ 可以看作最小的牌，此时的牌型仍然为顺子，是顺子里面最小的一个）。\n\n花色的顺序（大至小） 为：黑桃(♠)$>$红心(♥)$>$梅花(♣)$>$方块(♦)。\n\n举例说明：\n\n1、$Q♦ J♦ 10♦ 9♦ 8♦ > 8♣ 8♥ 8♠ K♥ K♠$ （前者牌型为同花顺，比后者大）；\n\n2、$9♣ 9♦ 9♠ Q♥ Q♠ > 8♣ 8♦ 8♠ K♥ K♠$ （两者牌型均为满堂红，比较牌型中三张同一点数的牌 $9$ 比 $8$ 大）；\n\n3、$A♣ A♦ 8♥ 8♠ Q♠ > A♠ A♥ 7♥ 7♠ K♠$ （两者牌型均为两对，且最大的对子相同，此时比较次大的对子，$8$ 比 $7$ 大）；\n\n4、$A♠ Q♠ J♥ 9♥ 8♥ > A♦ Q♦ J♠ 9♣ 8♣$ （两者牌型均为无对，所有数码均相同，此时比较最大牌的花色，$A♠$ > $A♦$）。\n\n5、$4♠ 4♥ A♦ Q♦ 5♦ > 4♣ 4♦ A♠ Q♠ 5♠$ （两者牌型均为一对，所有数码均相同，此时对 4 为牌型里最大的部分，因此比较 $4♠ > 4♣$）\n\n在小 Y 和小 Z 玩梭哈的过程中，小 Y 总希望能够实时了解目前的形势，即根据自己手上的牌算出自己的胜率。但是他的编程能力有限，你能帮他完成这个任务么？\n", "inputFormat": "第一行包含 $1$ 个正整数 $N$，表示小 Y 自己手上牌的数量。\n\n接下来 $N$ 行每行用两个整数描述一张小 Y 手上的牌：第一个数表示牌的数码（$1$ 表示 $A$，$13$ 表示 $K$，$12$ 表示 $Q$，$11$ 表示 $J$），第二个数表示牌的花色（$1$ 表示黑桃，$2$ 表示红心，$3$ 表示梅花，$4$ 表示方块）。\n\n接下来 $N – 1$ 行每行用两个整数描述一张小 Z 手上的明牌：第一个数表示牌的数码（$1$ 表示 $A$，$13$ 表示 $K$，$12$ 表示 $Q$，$11$ 表示 $J$），第二个数表示牌的花色（$1$ 表示黑桃，$2$ 表示红心，$3$ 表示梅花，$4$ 表示方块）。\n", "outputFormat": "输出仅包含一行，格式为 `A/B` 形式。$A$, $B$ 为两个互质的自然数，`A/B` 表示了小 Y 当前局面下的获胜可能性。特别的，若 $A$ 为 $0$，则应输出 `0/1`。\n", "hint": "【样例说明】\n\n小 Y 手上牌的型是 $4$ 条，小 Z 若底牌是方块 $A$ 则也能构成 $4$ 条，并通过数码大获胜 。其他情况下都是小 Y 获胜。\n\n【数据规模和约定】\n\n对于 $10\\%$ 的数据，$N = 5$;\n\n对于 $30\\%$ 的数据，$3 \\leq N \\leq 5$;\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2012] Show Hand Game", "background": "", "description": "Xiao Y and Xiao Z have recently become obsessed with a poker game called Show Hand. Show Hand (Chinese: 梭哈, also called 沙蟹) is a poker game played with $52$ cards from $A$ to $K$ in spades, hearts, clubs, and diamonds (no jokers).\n\nAs with other poker games, the goal in Show Hand is to obtain the highest-ranking hand and win the pot. Each player first places an ante, then receives one hole card, which only the player can see. In the first round after the hole card is dealt, each player receives one upcard (face-up on the table, visible to everyone). The player with the highest upcard acts first and may bet, check, fold, or go all-in (“Show Hand”). Other players may call (if someone has gone all-in, they must also go all-in to call), raise, or fold. A player who folds cannot continue in the game, and the chips they have already bet cannot be retrieved. After an all-in, all players’ hands are immediately filled to $5$ cards for the final showdown. The second, third, and fourth rounds proceed in a similar way. Finally, each player compares hand ranks to determine the winner. The player with the highest hand wins.\n\nAll $5$-card combinations are ranked from highest to lowest as follows:\n\n1. Straight Flush: five consecutive cards of the same suit. Example: $Q♦ J♦ 10♦ 9♦ 8♦$.\n\n2. Four of a Kind: four cards of the same rank. Example: $10♣ 10♦ 10♥ 10♠ 9♥$.\n\n3. Full House: three cards of one rank plus a pair of another rank. Example: $8♣ 8♦ 8♠ K♥ K♠$.\n\n4. Flush: five cards of the same suit. Example: $A♠ K♠ 10♠ 9♠ 8♠$.\n\n5. Straight: five consecutive ranks. Example: $K♦ Q♥ J♠ 10♦ 9♦$.\n\n6. Three of a Kind: three cards of the same rank. Example: $J♣ J♥ J♠ K♦ 9♠$.\n\n7. Two Pairs: two cards of one rank plus two cards of another rank. Example: $A♣ A♦ 8♥ 8♠ Q♠$.\n\n8. One Pair: two cards of the same rank. Example: $9♥ 9♠ A♣ J♠ 8♥$.\n\n9. Zilch: none of the above; compare ranks to decide. Example: $A♦ Q♦ J♠ 9♣ 8♣$.\n\nIf the hand types are the same, use ranks and then suits to break ties (ranks have priority).\n\nThe order of ranks (from high to low) is $A > K > Q > J > 10 > 9 > 8 > 7 > 6 > 5 > 4 > 3 > 2$. Note: when the $5$ cards are $5, 4, 3, 2, A$, the $A$ can be treated as the lowest rank. In this case it is still a straight, which is the lowest straight.\n\nThe order of suits (from high to low) is spades (♠) > hearts (♥) > clubs (♣) > diamonds (♦).\n\nExamples:\n\n1. $Q♦ J♦ 10♦ 9♦ 8♦ > 8♣ 8♥ 8♠ K♥ K♠$ (the former is a Straight Flush, which is higher).\n\n2. $9♣ 9♦ 9♠ Q♥ Q♠ > 8♣ 8♦ 8♠ K♥ K♠$ (both are Full Houses; compare the triplets, $9$ beats $8$).\n\n3. $A♣ A♦ 8♥ 8♠ Q♠ > A♠ A♥ 7♥ 7♠ K♠$ (both are Two Pairs and the higher pair is the same; compare the lower pair, $8$ beats $7$).\n\n4. $A♠ Q♠ J♥ 9♥ 8♥ > A♦ Q♦ J♠ 9♣ 8♣$ (both are Zilch with exactly the same ranks; compare the highest card’s suit, $A♠ > A♦$).\n\n5. $4♠ 4♥ A♦ Q♦ 5♦ > 4♣ 4♦ A♠ Q♠ 5♠$ (both are One Pair with identical ranks; the pair of $4$s is the most significant component, so compare $4♠ > 4♣$).\n\nDuring their game, Xiao Y wants to know the current situation in real time—namely, to compute his winning probability based on his current cards. However, his programming skills are limited. Can you help him?", "inputFormat": "The first line contains $1$ positive integer $N$, the number of cards currently in Xiao Y’s hand.\n\nEach of the next $N$ lines contains two integers describing one card in Xiao Y’s hand: the first is the rank ($1$ denotes $A$, $13$ denotes $K$, $12$ denotes $Q$, $11$ denotes $J$), and the second is the suit ($1$ denotes spades, $2$ denotes hearts, $3$ denotes clubs, $4$ denotes diamonds).\n\nEach of the next $N - 1$ lines contains two integers describing one upcard in Xiao Z’s hand: the first is the rank ($1$ denotes $A$, $13$ denotes $K$, $12$ denotes $Q$, $11$ denotes $J$), and the second is the suit ($1$ denotes spades, $2$ denotes hearts, $3$ denotes clubs, $4$ denotes diamonds).", "outputFormat": "Output exactly one line in the form `A/B`. Here $A$ and $B$ are two coprime natural numbers, and `A/B` is Xiao Y’s probability of winning in the current situation. In particular, if $A$ is $0$, output `0/1`.", "hint": "Sample Explanation:\n\nXiao Y’s current hand type is Four of a Kind. If Xiao Z’s hole card is $A♦$, he can also make Four of a Kind and win by rank. In all other cases, Xiao Y wins.\n\nConstraints:\n\n- For $10\\%$ of the testdata, $N = 5$.\n- For $30\\%$ of the testdata, $3 \\leq N \\leq 5$.\n- For $100\\%$ of the testdata, $1 \\leq N \\leq 5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2012] 梭哈游戏", "background": "", "description": "小 Y 和小 Z 最近迷上了一种叫梭哈的扑克游戏。梭哈又称沙蟹，是英文 Show Hand 的音译，是一种使用黑桃、红心、梅花、方片的 A 到 K 共 $52$ 张牌(没有大小王）来进行的扑克牌游戏。\n\n和其他扑克游戏一样，梭哈的目的是得到最大的牌型并赢得牌局：每名玩家首先需要下基本的注额，之后将获得一张底牌，这张牌只有自己知道。普通梭哈游戏的规则是，在发完底牌后的第一轮时，每个玩家都将得到一张明牌（明牌是摆在台面上的，所有人都能看见），拥有最大明牌的玩家首先发言，他可以下注、不下注（让牌）或盖牌（放弃）也可以全压（梭哈），其他玩家可以跟注（有玩家全压时必须全压）、加注或盖牌（放弃），放弃的玩家将无法继续游戏，并且之\n\n前押的筹码无法取回。而全压之后将直接把每个人的手牌补充至 $5$ 张进行最后的判定；第二圈、第三圈和第四圈的进程与第一圈是类似的。最后，每位玩家要比牌型的大小以确定赢家。牌最大的玩家赢得牌局。\n\n所有五张牌的组合，按以下秩序， 由大至小 排行分为不同牌型：\n\n1、同花顺（`Straight Flush`）：同一花色，顺序的牌。 例： $Q♦ J♦ 10♦ 9♦ 8♦$；\n\n2、四条（`Four of a Kind`）：有四张同一点数的牌。 例： $10♣ 10♦ 10♥ 10♠ 9♥$；\n\n3、满堂红（`Full House`）：三张同一点数的牌，加一对其他点数的牌。 例： $8♣ 8♦ 8♠ K♥ K♠$；\n\n4、同花（`Flush`）：五张同一花色的牌。 例： $A♠ K♠ 10♠ 9♠ 8♠$；\n\n5、顺子（`Straight`）：五张顺连的牌。 例： $K♦ Q♥ J♠ 10♦ 9♦$；\n\n6、三条（`Three of a kind`）：有三张同一点数的牌。 例： $J♣ J♥ J♠ K♦ 9♠$；\n\n7、两对（`Two Pairs`）：两张相同点数的牌，加另外两张相同点数的牌。 例： $A♣ A♦ 8♥ 8♠ Q♠$；\n\n8、一对（`One Pair`）：两张相同点数的牌。 例： $9♥ 9♠ A♣ J♠ 8♥$；\n\n9、无对（`Zilch`）：不能排成以上组合的牌，以点数决定大小。例： $A♦ Q♦ J♠ 9♣ 8♣$。\n\n若牌型一样则 利用 点数 和花色决定胜负 。（点数 优先）\n\n点数 的顺序（ 从 大至小） 为：$A>K>Q>J>10>9>8>7>6>5>4>3>2$。（注：当 $5$ 张手牌是 $5, 4, 3, 2, A$ 的时候，$A$ 可以看作最小的牌，此时的牌型仍然为顺子，是顺子里面最小的一个）。\n\n花色的顺序（大至小） 为：黑桃(♠)$>$红心(♥)$>$梅花(♣)$>$方块(♦)。\n\n举例说明：\n\n1、$Q♦ J♦ 10♦ 9♦ 8♦ > 8♣ 8♥ 8♠ K♥ K♠$ （前者牌型为同花顺，比后者大）；\n\n2、$9♣ 9♦ 9♠ Q♥ Q♠ > 8♣ 8♦ 8♠ K♥ K♠$ （两者牌型均为满堂红，比较牌型中三张同一点数的牌 $9$ 比 $8$ 大）；\n\n3、$A♣ A♦ 8♥ 8♠ Q♠ > A♠ A♥ 7♥ 7♠ K♠$ （两者牌型均为两对，且最大的对子相同，此时比较次大的对子，$8$ 比 $7$ 大）；\n\n4、$A♠ Q♠ J♥ 9♥ 8♥ > A♦ Q♦ J♠ 9♣ 8♣$ （两者牌型均为无对，所有数码均相同，此时比较最大牌的花色，$A♠$ > $A♦$）。\n\n5、$4♠ 4♥ A♦ Q♦ 5♦ > 4♣ 4♦ A♠ Q♠ 5♠$ （两者牌型均为一对，所有数码均相同，此时对 4 为牌型里最大的部分，因此比较 $4♠ > 4♣$）\n\n在小 Y 和小 Z 玩梭哈的过程中，小 Y 总希望能够实时了解目前的形势，即根据自己手上的牌算出自己的胜率。但是他的编程能力有限，你能帮他完成这个任务么？\n", "inputFormat": "第一行包含 $1$ 个正整数 $N$，表示小 Y 自己手上牌的数量。\n\n接下来 $N$ 行每行用两个整数描述一张小 Y 手上的牌：第一个数表示牌的数码（$1$ 表示 $A$，$13$ 表示 $K$，$12$ 表示 $Q$，$11$ 表示 $J$），第二个数表示牌的花色（$1$ 表示黑桃，$2$ 表示红心，$3$ 表示梅花，$4$ 表示方块）。\n\n接下来 $N – 1$ 行每行用两个整数描述一张小 Z 手上的明牌：第一个数表示牌的数码（$1$ 表示 $A$，$13$ 表示 $K$，$12$ 表示 $Q$，$11$ 表示 $J$），第二个数表示牌的花色（$1$ 表示黑桃，$2$ 表示红心，$3$ 表示梅花，$4$ 表示方块）。\n", "outputFormat": "输出仅包含一行，格式为 `A/B` 形式。$A$, $B$ 为两个互质的自然数，`A/B` 表示了小 Y 当前局面下的获胜可能性。特别的，若 $A$ 为 $0$，则应输出 `0/1`。\n", "hint": "【样例说明】\n\n小 Y 手上牌的型是 $4$ 条，小 Z 若底牌是方块 $A$ 则也能构成 $4$ 条，并通过数码大获胜 。其他情况下都是小 Y 获胜。\n\n【数据规模和约定】\n\n对于 $10\\%$ 的数据，$N = 5$;\n\n对于 $30\\%$ 的数据，$3 \\leq N \\leq 5$;\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 5$。\n", "locale": "zh-CN"}}}
{"pid": "P4011", "type": "P", "difficulty": 5, "samples": [["4 4 9\n9\n1 2 1 3 2\n1 2 2 2 0\n2 1 2 2 0\n2 1 3 1 0\n2 3 3 3 0\n2 4 3 4 1\n3 2 3 3 0\n3 3 4 3 0\n4 3 4 4 0\n2\n2 1 2\n4 2 1", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["O2优化", "广度优先搜索 BFS", "图论建模", "进制", "网络流与线性规划 24 题", "状压 DP"], "title": "孤岛营救问题", "background": "", "description": "$1944$ 年，特种兵麦克接到国防部的命令，要求立即赶赴太平洋上的一个孤岛，营救被敌军俘虏的大兵瑞恩。瑞恩被关押在一个迷宫里，迷宫地形复杂，但幸好麦克得到了迷宫的地形图。迷宫的外形是一个长方形，其南北方向被划分为 $N$ 行，东西方向被划分为 $M$ 列，于是整个迷宫被划分为 $N\\times M$ 个单元。每一个单元的位置可用一个有序数对(单元的行号，单元的列号)来表示。南北或东西方向相邻的 $2$ 个单元之间可能互通，也可能有一扇锁着的门，或者是一堵不可逾越的墙。迷宫中有一些单元存放着钥匙，并且所有的门被分成$P$ 类，打开同一类的门的钥匙相同，不同类门的钥匙不同。\n\n\n大兵瑞恩被关押在迷宫的东南角，即 $(N,M)$ 单元里，并已经昏迷。迷宫只有一个入口，在西北角。也就是说，麦克可以直接进入 $(1,1)$ 单元。另外，麦克从一个单元移动到另一个相邻单元的时间为 $1$，拿取所在单元的钥匙的时间以及用钥匙开门的时间可忽略不计。\n\n\n试设计一个算法，帮助麦克以最快的方式到达瑞恩所在单元，营救大兵瑞恩。\n", "inputFormat": "第 $1$ 行有 $3$ 个整数，分别表示 $N,M,P$ 的值。\n\n第 $2$ 行是 $1$ 个整数 $K$，表示迷宫中门和墙的总数。\n\n第 $I+2$ 行$(1\\leq I\\leq K)$，有 $5$ 个整数，依次为$X_{i1},Y_{i1},X_{i2},Y_{i2},G_i$：\n\n- 当 $G_i \\geq 1$ 时，表示 $(X_{i1},Y_{i1})$ 单元与 $(X_{i2},Y_{i2})$ 单元之间有一扇第 $G_i$ 类的门\n\n- 当 $G_i=0$ 时，表示 $(X_{i1},Y_{i1})$ 单元与 $(X_{i2},Y_{i2})$ 单元之间有一堵不可逾越的墙（其中，$|X_{i1}-X_{i2}|+|Y_{i1}-Y_{i2}|=1$，$0\\leq G_i\\leq P$）。\n\n第 $K+3$ 行是一个整数 $S$，表示迷宫中存放的钥匙总数。\n\n第 $K+3+J$  行$(1\\leq J\\leq S)$，有 $3$ 个整数，依次为 $X_{i1},Y_{i1},Q_i$：表示第 $J$ 把钥匙存放在 $(X_{i1},Y_{i1})$单元里，并且第 $J$ 把钥匙是用来开启第 $Q_i$ 类门的。（其中$1\\leq Q_i\\leq P$）。\n\n输入数据中同一行各相邻整数之间用一个空格分隔。\n", "outputFormat": "将麦克营救到大兵瑞恩的最短时间的值输出。如果问题无解，则输出 $-1$。\n", "hint": "$|X_{i1}-X_{i2}|+|Y_{i1}-Y_{i2}|=1,0\\leq G_i\\leq P$\n\n$1\\leq Q_i\\leq P$\n\n\n$N,M,P\\leq10, K<150,S\\leq 14$\n", "locale": "zh-CN", "translations": {"en": {"title": "Isolated Island Rescue Problem", "background": "", "description": "In the year $1944$, special forces soldier Mike received an order from the Ministry of Defense to rush to a deserted island in the Pacific to rescue Private Ryan, who had been captured by the enemy. Ryan is imprisoned in a maze. The maze is complex, but fortunately Mike has obtained a map of it. The maze is rectangular, divided into $N$ rows from north to south and $M$ columns from west to east, so the entire maze consists of $N \\times M$ cells. The position of each cell is represented by an ordered pair (row, column). Two adjacent cells in the north-south or east-west direction may be connected, or there may be a locked door between them, or an impassable wall. Some cells contain keys. All doors are divided into $P$ classes; keys that open doors of the same class are identical, and keys for different classes are different.\n\nPrivate Ryan is held in the southeast corner of the maze, i.e., in cell $(N, M)$, and is unconscious. The maze has only one entrance at the northwest corner. That is, Mike can directly enter cell $(1, 1)$. The time for Mike to move from one cell to an adjacent cell is $1$. The time to pick up a key in the current cell and to unlock a door is negligible.\n\nDesign an algorithm to help Mike reach the cell where Ryan is as quickly as possible and rescue him.", "inputFormat": "- The first line contains $3$ integers, representing the values of $N$, $M$, and $P$.\n- The second line contains $1$ integer $K$, the total number of doors and walls in the maze.\n- The $I+2$-th line ($1 \\leq I \\leq K$) contains $5$ integers, in order $X_{i1}, Y_{i1}, X_{i2}, Y_{i2}, G_i$:\n  - When $G_i \\geq 1$, there is a class-$G_i$ door between cells $(X_{i1}, Y_{i1})$ and $(X_{i2}, Y_{i2})$.\n  - When $G_i = 0$, there is an impassable wall between cells $(X_{i1}, Y_{i1})$ and $(X_{i2}, Y_{i2})$ (where $|X_{i1} - X_{i2}| + |Y_{i1} - Y_{i2}| = 1$, $0 \\leq G_i \\leq P$).\n- The $K+3$-th line contains an integer $S$, the total number of keys in the maze.\n- The $K+3+J$-th line ($1 \\leq J \\leq S$) contains $3$ integers, in order $X_{j}, Y_{j}, Q_j$: the $J$-th key is placed in cell $(X_{j}, Y_{j})$, and it opens doors of class $Q_j$ (where $1 \\leq Q_j \\leq P$).\n\nAdjacent integers on the same line in the input are separated by a single space.", "outputFormat": "Output the minimum time for Mike to rescue Private Ryan. If the problem has no solution, output $-1$.", "hint": "$|X_{i1} - X_{i2}| + |Y_{i1} - Y_{i2}| = 1$, $0 \\leq G_i \\leq P$.\n\n$1 \\leq Q_j \\leq P$.\n\nConstraints: $N, M, P \\leq 10$, $K < 150$, $S \\leq 14$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "孤岛营救问题", "background": "", "description": "$1944$ 年，特种兵麦克接到国防部的命令，要求立即赶赴太平洋上的一个孤岛，营救被敌军俘虏的大兵瑞恩。瑞恩被关押在一个迷宫里，迷宫地形复杂，但幸好麦克得到了迷宫的地形图。迷宫的外形是一个长方形，其南北方向被划分为 $N$ 行，东西方向被划分为 $M$ 列，于是整个迷宫被划分为 $N\\times M$ 个单元。每一个单元的位置可用一个有序数对(单元的行号，单元的列号)来表示。南北或东西方向相邻的 $2$ 个单元之间可能互通，也可能有一扇锁着的门，或者是一堵不可逾越的墙。迷宫中有一些单元存放着钥匙，并且所有的门被分成$P$ 类，打开同一类的门的钥匙相同，不同类门的钥匙不同。\n\n\n大兵瑞恩被关押在迷宫的东南角，即 $(N,M)$ 单元里，并已经昏迷。迷宫只有一个入口，在西北角。也就是说，麦克可以直接进入 $(1,1)$ 单元。另外，麦克从一个单元移动到另一个相邻单元的时间为 $1$，拿取所在单元的钥匙的时间以及用钥匙开门的时间可忽略不计。\n\n\n试设计一个算法，帮助麦克以最快的方式到达瑞恩所在单元，营救大兵瑞恩。\n", "inputFormat": "第 $1$ 行有 $3$ 个整数，分别表示 $N,M,P$ 的值。\n\n第 $2$ 行是 $1$ 个整数 $K$，表示迷宫中门和墙的总数。\n\n第 $I+2$ 行$(1\\leq I\\leq K)$，有 $5$ 个整数，依次为$X_{i1},Y_{i1},X_{i2},Y_{i2},G_i$：\n\n- 当 $G_i \\geq 1$ 时，表示 $(X_{i1},Y_{i1})$ 单元与 $(X_{i2},Y_{i2})$ 单元之间有一扇第 $G_i$ 类的门\n\n- 当 $G_i=0$ 时，表示 $(X_{i1},Y_{i1})$ 单元与 $(X_{i2},Y_{i2})$ 单元之间有一堵不可逾越的墙（其中，$|X_{i1}-X_{i2}|+|Y_{i1}-Y_{i2}|=1$，$0\\leq G_i\\leq P$）。\n\n第 $K+3$ 行是一个整数 $S$，表示迷宫中存放的钥匙总数。\n\n第 $K+3+J$  行$(1\\leq J\\leq S)$，有 $3$ 个整数，依次为 $X_{i1},Y_{i1},Q_i$：表示第 $J$ 把钥匙存放在 $(X_{i1},Y_{i1})$单元里，并且第 $J$ 把钥匙是用来开启第 $Q_i$ 类门的。（其中$1\\leq Q_i\\leq P$）。\n\n输入数据中同一行各相邻整数之间用一个空格分隔。\n", "outputFormat": "将麦克营救到大兵瑞恩的最短时间的值输出。如果问题无解，则输出 $-1$。\n", "hint": "$|X_{i1}-X_{i2}|+|Y_{i1}-Y_{i2}|=1,0\\leq G_i\\leq P$\n\n$1\\leq Q_i\\leq P$\n\n\n$N,M,P\\leq10, K<150,S\\leq 14$\n", "locale": "zh-CN"}}}
{"pid": "P4012", "type": "P", "difficulty": 6, "samples": [["1 1\n2 2\n1 2\n3 4\n5 6\n7 2\n8 10\n9 3\n2 0 0\n2 2 2", "42"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["图论建模", "费用流", "网络流与线性规划 24 题"], "title": "深海机器人问题", "background": null, "description": "深海资源考察探险队的潜艇将到达深海的海底进行科学考察。\n\n\n潜艇内有多个深海机器人。潜艇到达深海海底后，深海机器人将离开潜艇向预定目标移动。\n\n\n深海机器人在移动中还必须沿途采集海底生物标本。沿途生物标本由最先遇到它的深海机器人完成采集。\n\n\n每条预定路径上的生物标本的价值是已知的，而且生物标本只能被采集一次。\n\n\n本题限定深海机器人只能从其出发位置沿着向北或向东的方向移动，而且多个深海机器人可以在同一时间占据同一位置。\n\n\n用一个 $P\\times Q$ 网格表示深海机器人的可移动位置。西南角的坐标为 $(0,0)$，东北角的坐标为 $(Q,P)$ 。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/12215.png) \n\n给定每个深海机器人的出发位置和目标位置，以及每条网格边上生物标本的价值。\n\n\n计算深海机器人的最优移动方案， 使深海机器人到达目的地后，采集到的生物标本的总价值最高。", "inputFormat": "文件的第 $1$ 行为深海机器人的出发位置数 $a$,和目的地数 $b$ 。\n\n\n第 $2$ 行为 $P$ 和 $Q$ 的值。\n\n\n接下来的 $P+1$ 行,每行有 $Q$ 个正整数，其中第 $i$ 行（从 0 开始计数）的第 $j$ 个（从 0 开始计数）正整数表示点 $(i,j)$ 到点 $(i,j+1)$ 的路径上生物标本的价值。\n\n\n再接下来的 $Q+1$ 行,每行有 $P$ 个正整数，其中第 $i$ 行（从 0 开始计数）的第 $j$ 个（从 0 开始计数）正整数表示点 $(j,i)$ 到点 $(j+1,i)$ 的路径上生物标本的价值。\n\n\n接下来的 $a$ 行，每行有三个正整数 $k,x,y$,表示有 $k$ 个深海机器人从 $(x,y)$ 位置坐标出发。\n\n\n再接下来的 $b$ 行，每行有三个正整数 $r,x,y$ ,表示有 $r$ 个深海机器人可选择 $(x,y)$ 位置坐标作为目的地。", "outputFormat": "输出采集到的生物标本的最高总价值.", "hint": "$1\\leq P,Q\\leq15$\n\n\n$1\\leq a\\leq 4$\n\n\n$1\\leq b\\leq 6$", "locale": "zh-CN", "translations": {"en": {"title": "Deep-Sea Robot Problem", "background": "", "description": "The submarine of a deep-sea resource exploration team will arrive at the ocean floor for scientific investigation.\n\nThere are multiple deep-sea robots inside the submarine. After reaching the seafloor, the robots will leave the submarine and move toward their predetermined targets.\n\nWhile moving, the robots must collect biological specimens along the way. Each specimen along the route is collected by the first robot that encounters it.\n\nThe value of specimens on each prescribed path (i.e., each grid edge) is known, and each specimen can be collected at most once.\n\nIn this problem, each robot may move only to the north or to the east from its current position. Multiple robots may occupy the same position at the same time.\n\nThe movable positions of the robots are represented by a $P \\times Q$ grid. The southwest corner has coordinates $(0,0)$, and the northeast corner has coordinates $(Q,P)$.\n\n![](https://cdn.luogu.com.cn/upload/pic/12215.png)\n\nGiven the starting positions and destination positions of each robot, as well as the specimen values on each grid edge, compute the optimal movement plan that maximizes the total value of collected specimens after all robots reach their destinations.", "inputFormat": "The first line contains the number of starting locations $a$ and the number of destination locations $b$.\n\nThe second line contains the values of $P$ and $Q$.\n\nThe next $P+1$ lines each contain $Q$ positive integers. In the $i$-th line (0-indexed), the $j$-th (0-indexed) integer gives the specimen value on the edge from $(i,j)$ to $(i,j+1)$.\n\nThe next $Q+1$ lines each contain $P$ positive integers. In the $i$-th line (0-indexed), the $j$-th (0-indexed) integer gives the specimen value on the edge from $(j,i)$ to $(j+1,i)$.\n\nThe next $a$ lines each contain three positive integers $k, x, y$, indicating that there are $k$ robots starting from position $(x,y)$.\n\nThe next $b$ lines each contain three positive integers $r, x, y$, indicating that there are $r$ robots that may choose position $(x,y)$ as a destination.", "outputFormat": "Output the maximum total value of collected specimens.", "hint": "$1 \\leq P, Q \\leq 15$.\n\n$1 \\leq a \\leq 4$.\n\n$1 \\leq b \\leq 6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "深海机器人问题", "background": null, "description": "深海资源考察探险队的潜艇将到达深海的海底进行科学考察。\n\n\n潜艇内有多个深海机器人。潜艇到达深海海底后，深海机器人将离开潜艇向预定目标移动。\n\n\n深海机器人在移动中还必须沿途采集海底生物标本。沿途生物标本由最先遇到它的深海机器人完成采集。\n\n\n每条预定路径上的生物标本的价值是已知的，而且生物标本只能被采集一次。\n\n\n本题限定深海机器人只能从其出发位置沿着向北或向东的方向移动，而且多个深海机器人可以在同一时间占据同一位置。\n\n\n用一个 $P\\times Q$ 网格表示深海机器人的可移动位置。西南角的坐标为 $(0,0)$，东北角的坐标为 $(Q,P)$ 。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/12215.png) \n\n给定每个深海机器人的出发位置和目标位置，以及每条网格边上生物标本的价值。\n\n\n计算深海机器人的最优移动方案， 使深海机器人到达目的地后，采集到的生物标本的总价值最高。", "inputFormat": "文件的第 $1$ 行为深海机器人的出发位置数 $a$,和目的地数 $b$ 。\n\n\n第 $2$ 行为 $P$ 和 $Q$ 的值。\n\n\n接下来的 $P+1$ 行,每行有 $Q$ 个正整数，其中第 $i$ 行（从 0 开始计数）的第 $j$ 个（从 0 开始计数）正整数表示点 $(i,j)$ 到点 $(i,j+1)$ 的路径上生物标本的价值。\n\n\n再接下来的 $Q+1$ 行,每行有 $P$ 个正整数，其中第 $i$ 行（从 0 开始计数）的第 $j$ 个（从 0 开始计数）正整数表示点 $(j,i)$ 到点 $(j+1,i)$ 的路径上生物标本的价值。\n\n\n接下来的 $a$ 行，每行有三个正整数 $k,x,y$,表示有 $k$ 个深海机器人从 $(x,y)$ 位置坐标出发。\n\n\n再接下来的 $b$ 行，每行有三个正整数 $r,x,y$ ,表示有 $r$ 个深海机器人可选择 $(x,y)$ 位置坐标作为目的地。", "outputFormat": "输出采集到的生物标本的最高总价值.", "hint": "$1\\leq P,Q\\leq15$\n\n\n$1\\leq a\\leq 4$\n\n\n$1\\leq b\\leq 6$", "locale": "zh-CN"}}}
{"pid": "P4013", "type": "P", "difficulty": 6, "samples": [["2 5\n2 3\n3 4 5\n9 10 9 1\n1 1 10 1 1\n1 1 10 12 1 1", "66\n75\n77"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["O2优化", "图论建模", "费用流", "网络流与线性规划 24 题"], "title": "数字梯形问题", "background": "", "description": "给定一个由 $n$ 行数字组成的数字梯形如下图所示。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/12216.png) \n\n梯形的第一行有 $m$ 个数字。从梯形的顶部的 $m$ 个数字开始，在每个数字处可以沿左下或右下方向移动，形成一条从梯形的顶至底的路径。\n\n\n分别遵守以下规则：\n\n\n1. 从梯形的顶至底的 $m$ 条路径互不相交；\n\n1. 从梯形的顶至底的 $m$ 条路径仅在数字结点处相交；\n\n1. 从梯形的顶至底的 $m$  条路径允许在数字结点相交或边相交。\n", "inputFormat": "第 $1$ 行中有 $2$ 个正整数 $m$ 和 $n$，分别表示数字梯形的第一行有 $m$ 个数字，共有 $n$ 行。接下来的 $n$ 行是数字梯形中各行的数字。\n\n第 $1$ 行有 $m$ 个数字，第 $2$ 行有 $m+1$ 个数字，以此类推。\n", "outputFormat": "将按照规则 $1$，规则 $2$，和规则 $3$ 计算出的最大数字总和并输出，每行一个最大总和。\n", "hint": "$1\\leq m,n \\leq 20$\n", "locale": "zh-CN", "translations": {"en": {"title": "Number Trapezoid Problem", "background": "", "description": "Given a number trapezoid with $n$ rows as shown in the figure.\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/12216.png) \n\nThe first row of the trapezoid contains $m$ numbers. Starting from each of the $m$ numbers in the top row, you may move at each step to the lower-left or lower-right adjacent number, forming a path from the top to the bottom of the trapezoid.\n\nRespect the following rules respectively:\n\n1. The $m$ top-to-bottom paths are pairwise disjoint (no common nodes or edges).\n2. The $m$ top-to-bottom paths may intersect only at numeric nodes (shared nodes allowed, shared edges not allowed).\n3. The $m$ top-to-bottom paths may intersect at numeric nodes or along edges (both nodes and edges may be shared).", "inputFormat": "The first line contains two positive integers $m$ and $n$, denoting that the first row of the number trapezoid has $m$ numbers and there are $n$ rows in total. The next $n$ lines give the numbers in each row of the trapezoid.\n\nRow $1$ has $m$ numbers, row $2$ has $m+1$ numbers, and so on.", "outputFormat": "Output the maximum total sum computed under Rule $1$, Rule $2$, and Rule $3$, respectively, one maximum sum per line.", "hint": "$1 \\leq m,n \\leq 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数字梯形问题", "background": "", "description": "给定一个由 $n$ 行数字组成的数字梯形如下图所示。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/12216.png) \n\n梯形的第一行有 $m$ 个数字。从梯形的顶部的 $m$ 个数字开始，在每个数字处可以沿左下或右下方向移动，形成一条从梯形的顶至底的路径。\n\n\n分别遵守以下规则：\n\n\n1. 从梯形的顶至底的 $m$ 条路径互不相交；\n\n1. 从梯形的顶至底的 $m$ 条路径仅在数字结点处相交；\n\n1. 从梯形的顶至底的 $m$  条路径允许在数字结点相交或边相交。\n", "inputFormat": "第 $1$ 行中有 $2$ 个正整数 $m$ 和 $n$，分别表示数字梯形的第一行有 $m$ 个数字，共有 $n$ 行。接下来的 $n$ 行是数字梯形中各行的数字。\n\n第 $1$ 行有 $m$ 个数字，第 $2$ 行有 $m+1$ 个数字，以此类推。\n", "outputFormat": "将按照规则 $1$，规则 $2$，和规则 $3$ 计算出的最大数字总和并输出，每行一个最大总和。\n", "hint": "$1\\leq m,n \\leq 20$\n", "locale": "zh-CN"}}}
{"pid": "P4014", "type": "P", "difficulty": 5, "samples": [["5\n2 2 2 1 2\n2 3 1 2 4\n2 0 1 1 1\n2 3 4 3 3\n3 2 1 2 1", "5\n14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["深度优先搜索 DFS", "二分图", "费用流", "网络流与线性规划 24 题"], "title": "分配问题", "background": "", "description": "有 $n$ 件工作要分配给 $n$ 个人做。第 $i$ 个人做第 $j$ 件工作产生的效益为 $c_{ij}$ 。试设计一个将 $n$ 件工作分配给 $n$ 个人做的分配方案，使产生的总效益最小或最大。\n", "inputFormat": "文件的第一行有 $1$ 个正整数 $n$，表示有 $n$ 件工作要分配给 $n$ 个人做。\n\n接下来的 $n$ 行中，每行有 $n$ 个整数 $c_{i,j}$，表示第 $i$ 个人做第 $j$ 件工作产生的效益为 $c_{i,j}$。\n", "outputFormat": "两行分别输出最小总效益和最大总效益。\n", "hint": "$1 \\leq n \\leq 50, 0 \\le c _ {i, j} \\le 100$。\n\n一个人只能修一个工件。", "locale": "zh-CN", "translations": {"en": {"title": "Assignment Problem", "background": "", "description": "There are $n$ jobs to be assigned to $n$ people. When person $i$ does job $j$, the benefit is $c_{ij}$. Design an assignment that assigns $n$ jobs to $n$ people so that the total benefit is minimized or maximized.", "inputFormat": "The first line contains one positive integer $n$, indicating there are $n$ jobs to be assigned to $n$ people.\nIn the next $n$ lines, each line contains $n$ integers $c_{i,j}$, where $c_{i,j}$ is the benefit when person $i$ does job $j$.", "outputFormat": "Output two lines: the minimum total benefit and the maximum total benefit, respectively.", "hint": "$1 \\leq n \\leq 50, 0 \\le c _ {i, j} \\le 100$.\n\nEach person can do only one job.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "分配问题", "background": "", "description": "有 $n$ 件工作要分配给 $n$ 个人做。第 $i$ 个人做第 $j$ 件工作产生的效益为 $c_{ij}$ 。试设计一个将 $n$ 件工作分配给 $n$ 个人做的分配方案，使产生的总效益最小或最大。\n", "inputFormat": "文件的第一行有 $1$ 个正整数 $n$，表示有 $n$ 件工作要分配给 $n$ 个人做。\n\n接下来的 $n$ 行中，每行有 $n$ 个整数 $c_{i,j}$，表示第 $i$ 个人做第 $j$ 件工作产生的效益为 $c_{i,j}$。\n", "outputFormat": "两行分别输出最小总效益和最大总效益。\n", "hint": "$1 \\leq n \\leq 50, 0 \\le c _ {i, j} \\le 100$。\n\n一个人只能修一个工件。", "locale": "zh-CN"}}}
{"pid": "P4015", "type": "P", "difficulty": 5, "samples": [["2 3\n220 280\n170 120 210\n77 39 105\n150 186 122", "48500\n69140"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["O2优化", "费用流", "网络流与线性规划 24 题"], "title": "运输问题", "background": null, "description": "$W$ 公司有 $m$ 个仓库和 $n$ 个零售商店。第 $i$ 个仓库有 $a_i$ 个单位的货物；第 $j$ 个零售商店需要 $b_j$ 个单位的货物。\n\n\n货物供需平衡，即$\\sum\\limits_{i=1}^{m}a_i=\\sum\\limits_{j=1}^{n}b_j$。\n\n\n从第 $i$ 个仓库运送每单位货物到第 $j$ 个零售商店的费用为 $c_{i,j}$ 。\n\n\n试设计一个将仓库中所有货物运送到零售商店的运输方案，使总运输费用最少。", "inputFormat": "第 $1$ 行有 $2$ 个正整数 $m$ 和 $n$，分别表示仓库数和零售商店数。\n\n\n接下来的一行中有 $m$ 个正整数 $a_i$，表示第 $i$ 个仓库有 $a_i$个单位的货物。\n\n\n再接下来的一行中有 $n$ 个正整数 $b_j$，表示第 $j$ 个零售商店需要 $b_j$ 个单位的货物。\n\n\n接下来的 $m$ 行，每行有 $n$ 个整数，表示从第 $i$ 个仓库运送每单位货物到第 $j$ 个零售商店的费用 $c_{i,j}$。", "outputFormat": "两行分别输出最小运输费用和最大运输费用。", "hint": "$1 \\leq n, m \\leq 100$", "locale": "zh-CN", "translations": {"en": {"title": "Transportation Problem", "background": "", "description": "Company $W$ has $m$ warehouses and $n$ retail stores. The $i$-th warehouse has $a_i$ units of goods; the $j$-th retail store needs $b_j$ units of goods.\n\nThe supply and demand are balanced, i.e., $\\sum\\limits_{i=1}^{m}a_i=\\sum\\limits_{j=1}^{n}b_j$.\n\nThe cost to transport each unit of goods from the $i$-th warehouse to the $j$-th retail store is $c_{i,j}$.\n\nDesign a transportation plan to ship all goods from the warehouses to the retail stores so that the total transportation cost is minimized.", "inputFormat": "Line 1 contains 2 positive integers $m$ and $n$, representing the number of warehouses and retail stores, respectively.\n\nThe next line contains $m$ positive integers $a_i$, where the $i$-th warehouse has $a_i$ units of goods.\n\nThe following line contains $n$ positive integers $b_j$, where the $j$-th retail store requires $b_j$ units of goods.\n\nThe next $m$ lines each contain $n$ integers, representing the per-unit transportation cost $c_{i,j}$ from the $i$-th warehouse to the $j$-th retail store.", "outputFormat": "Output two lines: the minimum total transportation cost and the maximum total transportation cost.", "hint": "$1 \\leq n, m \\leq 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "运输问题", "background": null, "description": "$W$ 公司有 $m$ 个仓库和 $n$ 个零售商店。第 $i$ 个仓库有 $a_i$ 个单位的货物；第 $j$ 个零售商店需要 $b_j$ 个单位的货物。\n\n\n货物供需平衡，即$\\sum\\limits_{i=1}^{m}a_i=\\sum\\limits_{j=1}^{n}b_j$。\n\n\n从第 $i$ 个仓库运送每单位货物到第 $j$ 个零售商店的费用为 $c_{i,j}$ 。\n\n\n试设计一个将仓库中所有货物运送到零售商店的运输方案，使总运输费用最少。", "inputFormat": "第 $1$ 行有 $2$ 个正整数 $m$ 和 $n$，分别表示仓库数和零售商店数。\n\n\n接下来的一行中有 $m$ 个正整数 $a_i$，表示第 $i$ 个仓库有 $a_i$个单位的货物。\n\n\n再接下来的一行中有 $n$ 个正整数 $b_j$，表示第 $j$ 个零售商店需要 $b_j$ 个单位的货物。\n\n\n接下来的 $m$ 行，每行有 $n$ 个整数，表示从第 $i$ 个仓库运送每单位货物到第 $j$ 个零售商店的费用 $c_{i,j}$。", "outputFormat": "两行分别输出最小运输费用和最大运输费用。", "hint": "$1 \\leq n, m \\leq 100$", "locale": "zh-CN"}}}
{"pid": "P4016", "type": "P", "difficulty": 4, "samples": [["5\n17 9 14 16 4", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "贪心", "网络流", "O2优化", "费用流", "网络流与线性规划 24 题"], "title": "负载平衡问题", "background": null, "description": "G 公司有 $n$ 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 $n$ 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。", "inputFormat": "第一行一个正整数 $n$，表示有 $n$ 个仓库。\n\n第二行 $n$ 个正整数，表示 $n$ 个仓库的库存量。", "outputFormat": "一行一个非负整数，输出最少搬运量。", "hint": "$1 \\leq n \\leq 100,1\\leq a_i\\leq 100$，保证 $\\sum a_i$ 是 $n$ 的倍数。", "locale": "zh-CN", "translations": {"en": {"title": "Load Balancing Problem", "background": "", "description": "Company G has $n$ warehouses arranged in a ring along a railway transport line. The amount of goods stored in each warehouse is not necessarily the same. What is the minimum total amount of goods that must be moved to make the inventories of the $n$ warehouses equal? When moving goods, you may only transfer goods between adjacent warehouses.", "inputFormat": "The first line contains a positive integer $n$, denoting there are $n$ warehouses.\nThe second line contains $n$ positive integers, denoting the inventory of the $n$ warehouses.", "outputFormat": "Output a single non-negative integer on one line, the minimum total amount of goods to move.", "hint": "$1 \\leq n \\leq 100, 1 \\leq a_i \\leq 100$, and it is guaranteed that $\\sum a_i$ is a multiple of $n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "负载平衡问题", "background": null, "description": "G 公司有 $n$ 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 $n$ 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。", "inputFormat": "第一行一个正整数 $n$，表示有 $n$ 个仓库。\n\n第二行 $n$ 个正整数，表示 $n$ 个仓库的库存量。", "outputFormat": "一行一个非负整数，输出最少搬运量。", "hint": "$1 \\leq n \\leq 100,1\\leq a_i\\leq 100$，保证 $\\sum a_i$ 是 $n$ 的倍数。", "locale": "zh-CN"}}}
{"pid": "P4017", "type": "P", "difficulty": 3, "samples": [["5 7\n1 2\n1 3\n2 3\n3 5\n2 5\n4 5\n3 4", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "图论", "排序", "深度优先搜索 DFS", "拓扑排序"], "title": "最大食物链计数", "background": "你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。", "description": "给你一个食物网，你要求出这个食物网中最大食物链的数量。\n\n（这里的“最大食物链”，指的是**生物学意义上的食物链**，即**最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者**。）\n\nDelia 非常急，所以你只有 $1$ 秒的时间。\n\n由于这个结果可能过大，你只需要输出总数模上 $80112002$ 的结果。", "inputFormat": "第一行，两个正整数 $n$、$m$，表示生物种类 $n$ 和吃与被吃的关系数 $m$。\n\n接下来 $m$ 行，每行两个正整数，表示被吃的生物 A 和吃 A 的生物 B。", "outputFormat": "一行一个整数，为最大食物链数量模上 $80112002$ 的结果。", "hint": "各测试点满足以下约定：\n\n|测试点编号|$n$|$m$|\n|:-:|:-:|:-:|\n|$1,2$|$\\le 40$|$\\le 400$|\n|$3,4$|$\\le 100$|$\\le 2\\times 10^3$|\n|$5,6$|$\\le 10^3$|$\\le 6\\times 10^4$|\n|$7,8$|$\\le 2\\times 10^3$|$\\le 2\\times 10^5$|\n|$9,10$|$\\le 5\\times 10^3$|$\\le 5\\times 10^5$|\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 5\\times 10^3,1\\le m \\le 5\\times 10^5$\n\n【补充说明】\n\n数据中不会出现环，满足生物学的要求。（感谢 @AKEE）", "locale": "zh-CN", "translations": {"en": {"title": "Maximal Food Chain Count", "background": "Do you know about food chains? During Delia's biology exam, she got all the questions about counting food chains wrong because she kept double-counting or missing some. So she came to ask you for help, but you don’t know either. Write a program to help her.", "description": "Given a food web, you are to compute the number of maximal food chains in this food web.\n\n(Here, a \"maximal food chain\" refers to a food chain in the biological sense: the leftmost end is a producer that does not prey on any other species, and the rightmost end is a consumer that is not preyed upon by any other species.)\n\nDelia is in a hurry, so you have only $1$ second.\n\nSince the result may be large, you only need to output the total modulo $80112002$.", "inputFormat": "The first line contains two positive integers $n$, $m$, denoting the number of species $n$ and the number of predator-prey relations $m$.\n\nThen $m$ lines follow. Each line contains two positive integers, denoting a species $A$ that is eaten and a species $B$ that eats $A$.", "outputFormat": "Output a single integer on one line: the number of maximal food chains modulo $80112002$.", "hint": "Each test point satisfies the following constraints:\n\n| Test point ID | $n$ | $m$ |\n|:-:|:-:|:-:|\n| $1,2$ | $\\le 40$ | $\\le 400$ |\n| $3,4$ | $\\le 100$ | $\\le 2\\times 10^3$ |\n| $5,6$ | $\\le 10^3$ | $\\le 6\\times 10^4$ |\n| $7,8$ | $\\le 2\\times 10^3$ | $\\le 2\\times 10^5$ |\n| $9,10$ | $\\le 5\\times 10^3$ | $\\le 5\\times 10^5$ |\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 5\\times 10^3, 1 \\le m \\le 5\\times 10^5$.\n\nAdditional note: The data contains no cycles, in line with biological requirements. (Thanks to @AKEE.)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最大食物链计数", "background": "你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。", "description": "给你一个食物网，你要求出这个食物网中最大食物链的数量。\n\n（这里的“最大食物链”，指的是**生物学意义上的食物链**，即**最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者**。）\n\nDelia 非常急，所以你只有 $1$ 秒的时间。\n\n由于这个结果可能过大，你只需要输出总数模上 $80112002$ 的结果。", "inputFormat": "第一行，两个正整数 $n$、$m$，表示生物种类 $n$ 和吃与被吃的关系数 $m$。\n\n接下来 $m$ 行，每行两个正整数，表示被吃的生物 A 和吃 A 的生物 B。", "outputFormat": "一行一个整数，为最大食物链数量模上 $80112002$ 的结果。", "hint": "各测试点满足以下约定：\n\n|测试点编号|$n$|$m$|\n|:-:|:-:|:-:|\n|$1,2$|$\\le 40$|$\\le 400$|\n|$3,4$|$\\le 100$|$\\le 2\\times 10^3$|\n|$5,6$|$\\le 10^3$|$\\le 6\\times 10^4$|\n|$7,8$|$\\le 2\\times 10^3$|$\\le 2\\times 10^5$|\n|$9,10$|$\\le 5\\times 10^3$|$\\le 5\\times 10^5$|\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 5\\times 10^3,1\\le m \\le 5\\times 10^5$\n\n【补充说明】\n\n数据中不会出现环，满足生物学的要求。（感谢 @AKEE）", "locale": "zh-CN"}}}
{"pid": "P4018", "type": "P", "difficulty": 3, "samples": [["3\n4\n9\n14", "October wins!\nOctober wins!\nOctober wins!"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "博弈论", "素数判断,质数,筛法"], "title": "Roy&October之取石子", "background": "Roy 和 October 两人在玩一个取石子的游戏。\n", "description": "游戏规则是这样的：共有 $n$ 个石子，两人每次都只能取 $p^k$ 个（ $p$ 为质数，$k$ 为自然数，且 $p^k$ 小于等于当前剩余石子数），谁取走最后一个石子，谁就赢了。\n\n现在 October 先取，问她有没有必胜策略。\n\n若她有必胜策略，输出一行 `October wins!`；否则输出一行 `Roy wins!`。\n", "inputFormat": "第一行一个正整数 $T$，表示测试点组数。\n\n第 $2$ 行$\\sim$ 第 $T+1$ 行，一行一个正整数 $n$，表示石子个数。\n", "outputFormat": "$T$ 行，每行分别为 `October wins!` 或 `Roy wins!`。\n", "hint": "对于 $30\\%$ 的数据，$1\\leq n\\leq 30$；\n\n对于 $60\\%$ 的数据，$1\\leq n\\leq 10^6$；\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 5\\times 10^7$, $1\\leq T\\leq 10^5$。\n\n（改编题）\n", "locale": "zh-CN", "translations": {"en": {"title": "Roy & October: Taking Stones", "background": "Roy and October are playing a stone-taking game.", "description": "The rules are as follows: There are $n$ stones in total. On each turn, a player may take exactly $p^k$ stones ($p$ is a prime, $k$ is a natural number, and $p^k$ is less than or equal to the current remaining number of stones). Whoever takes the last stone wins.\n\nOctober moves first. Determine whether she has a winning strategy.\n\nIf she has a winning strategy, output a line `October wins!`; otherwise, output a line `Roy wins!`.", "inputFormat": "The first line contains a positive integer $T$, the number of test cases.\n\nFrom line $2$ to line $T+1$, each line contains a positive integer $n$, the number of stones.", "outputFormat": "$T$ lines, each being either `October wins!` or `Roy wins!`.", "hint": "For $30\\%$ of the testdata, $1 \\leq n \\leq 30$.\nFor $60\\%$ of the testdata, $1 \\leq n \\leq 10^6$.\nFor $100\\%$ of the testdata, $1 \\leq n \\leq 5\\times 10^7$, $1 \\leq T \\leq 10^5$.\n\n(Adapted problem).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Roy&October之取石子", "background": "Roy 和 October 两人在玩一个取石子的游戏。\n", "description": "游戏规则是这样的：共有 $n$ 个石子，两人每次都只能取 $p^k$ 个（ $p$ 为质数，$k$ 为自然数，且 $p^k$ 小于等于当前剩余石子数），谁取走最后一个石子，谁就赢了。\n\n现在 October 先取，问她有没有必胜策略。\n\n若她有必胜策略，输出一行 `October wins!`；否则输出一行 `Roy wins!`。\n", "inputFormat": "第一行一个正整数 $T$，表示测试点组数。\n\n第 $2$ 行$\\sim$ 第 $T+1$ 行，一行一个正整数 $n$，表示石子个数。\n", "outputFormat": "$T$ 行，每行分别为 `October wins!` 或 `Roy wins!`。\n", "hint": "对于 $30\\%$ 的数据，$1\\leq n\\leq 30$；\n\n对于 $60\\%$ 的数据，$1\\leq n\\leq 10^6$；\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 5\\times 10^7$, $1\\leq T\\leq 10^5$。\n\n（改编题）\n", "locale": "zh-CN"}}}
{"pid": "P4019", "type": "P", "difficulty": 5, "samples": [["3 0 3", "6"], ["5 2 5\n2 3 4\n3 2 3", "208"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP"], "title": "多边形染色", "background": null, "description": "Flokirie 有一个美丽的凸 $n$ 边形，顶点编号为 $1$ 到 $n$，每条边连接顶点 $i$ 和 $i+1$。特别的，顶点 $n$ 与顶点 $1$ 相连\n\n他想把每个顶点都染成某一种颜色 $k(k \\le c)$，且相邻顶点颜色不能相同。\n\n他想知道所有可行方案共有多少。于是他在纸上算了算，$5$ 分钟就解决了这题。\n\n于是他觉得太 low 了，便定义了以下骚操作。\n\n1. `1 x p`：表示第 $x$ 个顶点必须染颜色 $p$。\n\n2. `2 x p`：表示第 $x$ 个顶点必须不染颜色 $p$。\n\n3. `3 x y`：表示更改第 $x$ 个顶点与第 $y$ 个顶点之间边的属性（保证 $y=x±1$，且 $x,y≠1,n$），即第 $x$ 个顶点必须与第 $y$ 个顶点颜色相同。\n\n现在，他想知道所有可行的方案共有多少种。由于结果可能过大，你只需输出它对 $987654321$ 取模的结果即可。", "inputFormat": "第一行，三个正整数 $n$，$m$，$c$，表示多边形边数、操作个数、颜色个数。\n\n之后 $m$ 行，每行三个正整数表示一个操作，具体意义见题目描述。", "outputFormat": "一行一个整数，为所有可行操作和模上 $987654321$ 的结果。", "hint": "|  测试点编号 | $n$  | $m$  | $c$  |\n|:-:|:-:|:-:|:-:|\n| $1\\sim 2$  |  $3\\le n\\le 10$  |  $0\\le m\\le 10$ |  $1\\le c\\le 5$ |\n| $3\\sim 4$  |  $3\\le n\\le 100$  | $0\\le m\\le 30$  | $1\\le c\\le 8$  |\n| $5$  |  $3\\le n\\le 2\\times 10^3$  |  $m=0$ |  $1\\le c\\le 10$  |\n| $6$  |  $3\\le n\\le 2\\times 10^3$  |  $0\\le m\\le 100$ |  $1\\le c\\le 10$ |\n| $7$  |  $3\\le n\\le 5\\times 10^4$  | $m=0$  | $1\\le c\\le 10$  |\n| $8$  |  $3\\le n\\le 5\\times 10^4$  | $0\\le m\\le500$  | $1\\le c\\le 10$  |\n| $9\\sim 10$  |  $3\\le n\\le 5\\times 10^4$  | $0\\le m\\le10^3$  | $1\\le c\\le 10$ |\n\n保证对于 $100\\%$ 的数据，$3\\le n\\le 5\\times 10^4,0\\le m\\le10^3, 1\\le c\\le10$。", "locale": "zh-CN", "translations": {"en": {"title": "Polygon Coloring", "background": "", "description": "Flokirie has a beautiful convex $n$-gon with vertices numbered from $1$ to $n$. Each edge connects vertex $i$ and $i+1$, and in particular, vertex $n$ is connected to vertex $1$.\n\nHe wants to color each vertex with some color $k$ ($k \\le c$), i.e., each vertex is assigned a color from $1$ to $c$, and adjacent vertices must not have the same color.\n\nHe wants to know how many feasible colorings there are. He calculated it on paper and solved it in $5$ minutes.\n\nHe thought that was too trivial, so he defined the following “fancy” operations:\n\n1. `1 x p`: vertex $x$ must be colored with color $p$.\n2. `2 x p`: vertex $x$ must not be colored with color $p$.\n3. `3 x y`: change the attribute of the edge between vertex $x$ and vertex $y$ (guaranteed that $y = x \\pm 1$ and $x, y \\ne 1, n$), i.e., vertex $x$ must have the same color as vertex $y$.\n\nNow, he wants to know the total number of feasible colorings after applying all operations. Since the result may be large, output it modulo $987654321$.", "inputFormat": "The first line contains three positive integers $n$, $m$, $c$, representing the number of sides of the polygon, the number of operations, and the number of colors.\n\nEach of the following $m$ lines contains three positive integers describing one operation, as defined above.", "outputFormat": "Output a single integer: the number of feasible colorings modulo $987654321$.", "hint": "| Test Point ID | $n$ | $m$ | $c$ |\n|:-:|:-:|:-:|:-:|\n| $1 \\sim 2$ | $3 \\le n \\le 10$ | $0 \\le m \\le 10$ | $1 \\le c \\le 5$ |\n| $3 \\sim 4$ | $3 \\le n \\le 100$ | $0 \\le m \\le 30$ | $1 \\le c \\le 8$ |\n| $5$ | $3 \\le n \\le 2 \\times 10^3$ | $m = 0$ | $1 \\le c \\le 10$ |\n| $6$ | $3 \\le n \\le 2 \\times 10^3$ | $0 \\le m \\le 100$ | $1 \\le c \\le 10$ |\n| $7$ | $3 \\le n \\le 5 \\times 10^4$ | $m = 0$ | $1 \\le c \\le 10$ |\n| $8$ | $3 \\le n \\le 5 \\times 10^4$ | $0 \\le m \\le 500$ | $1 \\le c \\le 10$ |\n| $9 \\sim 10$ | $3 \\le n \\le 5 \\times 10^4$ | $0 \\le m \\le 10^3$ | $1 \\le c \\le 10$ |\n\nIt is guaranteed that for $100\\%$ of the testdata, $3 \\le n \\le 5 \\times 10^4$, $0 \\le m \\le 10^3$, $1 \\le c \\le 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "多边形染色", "background": null, "description": "Flokirie 有一个美丽的凸 $n$ 边形，顶点编号为 $1$ 到 $n$，每条边连接顶点 $i$ 和 $i+1$。特别的，顶点 $n$ 与顶点 $1$ 相连\n\n他想把每个顶点都染成某一种颜色 $k(k \\le c)$，且相邻顶点颜色不能相同。\n\n他想知道所有可行方案共有多少。于是他在纸上算了算，$5$ 分钟就解决了这题。\n\n于是他觉得太 low 了，便定义了以下骚操作。\n\n1. `1 x p`：表示第 $x$ 个顶点必须染颜色 $p$。\n\n2. `2 x p`：表示第 $x$ 个顶点必须不染颜色 $p$。\n\n3. `3 x y`：表示更改第 $x$ 个顶点与第 $y$ 个顶点之间边的属性（保证 $y=x±1$，且 $x,y≠1,n$），即第 $x$ 个顶点必须与第 $y$ 个顶点颜色相同。\n\n现在，他想知道所有可行的方案共有多少种。由于结果可能过大，你只需输出它对 $987654321$ 取模的结果即可。", "inputFormat": "第一行，三个正整数 $n$，$m$，$c$，表示多边形边数、操作个数、颜色个数。\n\n之后 $m$ 行，每行三个正整数表示一个操作，具体意义见题目描述。", "outputFormat": "一行一个整数，为所有可行操作和模上 $987654321$ 的结果。", "hint": "|  测试点编号 | $n$  | $m$  | $c$  |\n|:-:|:-:|:-:|:-:|\n| $1\\sim 2$  |  $3\\le n\\le 10$  |  $0\\le m\\le 10$ |  $1\\le c\\le 5$ |\n| $3\\sim 4$  |  $3\\le n\\le 100$  | $0\\le m\\le 30$  | $1\\le c\\le 8$  |\n| $5$  |  $3\\le n\\le 2\\times 10^3$  |  $m=0$ |  $1\\le c\\le 10$  |\n| $6$  |  $3\\le n\\le 2\\times 10^3$  |  $0\\le m\\le 100$ |  $1\\le c\\le 10$ |\n| $7$  |  $3\\le n\\le 5\\times 10^4$  | $m=0$  | $1\\le c\\le 10$  |\n| $8$  |  $3\\le n\\le 5\\times 10^4$  | $0\\le m\\le500$  | $1\\le c\\le 10$  |\n| $9\\sim 10$  |  $3\\le n\\le 5\\times 10^4$  | $0\\le m\\le10^3$  | $1\\le c\\le 10$ |\n\n保证对于 $100\\%$ 的数据，$3\\le n\\le 5\\times 10^4,0\\le m\\le10^3, 1\\le c\\le10$。", "locale": "zh-CN"}}}
{"pid": "P4020", "type": "P", "difficulty": 6, "samples": [["4 3\n1 2\n2 3\n2 4\nQ 2\nC 2 4 5\nQ 2", "0.0000000000\n-1.6666666666"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["递推", "2012", "Special Judge", "高斯消元", "CTSC/CTS"], "title": "[CTSC2012] 电阻网络", "background": null, "description": "给定一个树型电网，树中的每条边上有一个电阻 $R_i$，电阻值均为 $10000\\ Ω$。下图为一个包含 $4$ 个节点的树型电路情况：\n\n![图1](https://i.loli.net/2018/10/03/5bb46c0c587be.png)\n\n树中的所有叶子节点（度为 $1$ 的节点称为叶子）都接地，每条线上都接地，每条线上都附有 $10000\\ Ω$ 的电阻，最终形成的电网如下图所示：\n\n![图2](https://i.loli.net/2018/10/03/5bb46c0c72576.png)\n\n现有如下两种操作：\n\n`C u v w`：表示在边 $(u,v)$ 上串联一个电源，电源的大小为 $w$ 伏，电源位于靠近节点 $u$ 一侧（如下图所示），电源负极指向 $u$。注意同一条边上可以串联多个电源。\n\n![图3](https://i.loli.net/2018/10/03/5bb46c0c6a122.png)\n\n`Q u` ：表示询问点 $u$ 当前的电压，此是指对地。\n\n如对上图进行 `C 2 4 5` 操作后，网络变为：\n\n![图4](https://i.loli.net/2018/10/03/5bb46c0c86064.png)\n\n此时每个节点上的电压见上图的标注。", "inputFormat": "输入文件 circuit.in 的第一行包含两个整数 $N,M$，分别表示树的节点数和操作个数。接下来 $N-1$ 行，每行两个数 $u,v$，表示有一条连接节点 $u,v$ 的边，这条边上恰好包含一个电阻。\n\n接下来 $M$ 行，每行一个命令，格式见题目描述。", "outputFormat": "输出文件为 circuit.out。对于每个 `Q` 命令，输出一个数表示此刻该点的电压值。你可以输出任意多位的小数，只要你的答案和标准答案相差不超过 $10^{-3}$ 就算合法。", "hint": "【样例说明】\n\n对于第一个询问，由于原图中没有电源，所以没有电流，所有点的电压都相\n\n等（否则如果有 $U_i>U_j$，则就有 $i$ 流向 $j$ 的电流，与没有电源矛盾），都等于地电压 $0\\text{V}$。\n\n之后在 $(2,4)$ 中加一个 $5\\text{V}$ 的电源，得到的新图见题目描述。\n\n整理后可以发现，新图的形式是串联（电源，$R_2+10000$，并联（$R_1+10000$，$R_3+10000$）），由此可以得到新图的总电阻为:\n\n$$\nR 2 +10000+\\frac{1}{\\frac{1}{R_3 +10000}+\\frac{1}{R_1 +10000}}=30000\\ Ω\n$$\n\n所以流过节点 $4$ 的电流就是 $\\frac{5}{30000}\\ A$，所以 $U_4=\\frac{5}{3}V$，$U_2=U_4+R_2\\cdot I-5=-\\frac{5}{3}V$，由\n\n于 $U_1$ 和 $U_3$ 形式对称，由分压关系可知 $U_1 =U_3 =U_2\\times\\frac{10000}{10000+10000}=-\\frac{5}{6}V$。\n\n【数据规模】\n\n$30\\%$ 的数据保证 $N,M ≤ 30$。\n\n$60\\%$ 的数据保证 $N,M ≤ 3000$。\n\n$100\\%$ 的数据保证 $3 ≤ N,M ≤ 50000$，$1 ≤ u,v ≤ n$，$1 ≤ w ≤ 10$，树中最长链的长度不超过 $50$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2012] Resistor Network", "background": "", "description": "Given a tree-shaped circuit, each edge in the tree has a resistor $R_i$, and all resistances are $10000\\ Ω$. The figure below shows a tree-shaped circuit with $4$ nodes:\n\n![Figure 1](https://i.loli.net/2018/10/03/5bb46c0c587be.png)\n\nAll leaf nodes in the tree (nodes of degree $1$ are called leaves) are connected to ground, each line is connected to ground, and each line carries a $10000\\ Ω$ resistor, forming the network shown below:\n\n![Figure 2](https://i.loli.net/2018/10/03/5bb46c0c72576.png)\n\nThere are two types of operations:\n\n`C u v w`: Insert a voltage source in series on edge $(u, v)$, with magnitude $w$ volts. The source is placed on the side closer to node $u$ (as shown below), with its negative terminal pointing toward $u$. Note that multiple voltage sources can be inserted in series on the same edge.\n\n![Figure 3](https://i.loli.net/2018/10/03/5bb46c0c6a122.png)\n\n`Q u`: Query the current voltage of node $u$, measured with respect to ground.\n\nAfter performing `C 2 4 5` on the figure above, the network becomes:\n\n![Figure 4](https://i.loli.net/2018/10/03/5bb46c0c86064.png)\n\nAt this time, the voltage at each node is as labeled in the figure.", "inputFormat": "The input file circuit.in contains two integers $N, M$ on the first line, representing the number of nodes in the tree and the number of operations, respectively. The next $N-1$ lines each contain two integers $u, v$, indicating that there is an edge connecting nodes $u$ and $v$, and this edge contains exactly one resistor.\n\nThen there are $M$ lines, each containing one command in the format described above.", "outputFormat": "Output to circuit.out. For each `Q` command, output a single number representing the voltage at that node at that moment. You may print any number of decimal places; your answer is considered correct if it differs from the standard answer by at most $10^{-3}$.", "hint": "[Sample Explanation]\n\nFor the first query, since there is no voltage source in the original circuit, there is no current, and all node voltages are equal (otherwise, if there exists $U_i > U_j$, there would be current flowing from $i$ to $j$, contradicting the absence of a source). They are all equal to the ground potential $0\\text{V}$.\n\nAfter adding a $5\\text{V}$ voltage source on $(2, 4)$, the new circuit is as shown in the problem statement.\n\nAfter simplification, the new circuit can be seen as series (source, $R_2+10000$, parallel ($R_1+10000$, $R_3+10000$)), hence the equivalent resistance is:\n\n$$\nR 2 +10000+\\frac{1}{\\frac{1}{R_3 +10000}+\\frac{1}{R_1 +10000}}=30000\\ Ω\n$$\n\nTherefore, the current flowing through node $4$ is $\\frac{5}{30000}\\ A$, so $U_4=\\frac{5}{3}V$ and $U_2=U_4+R_2\\cdot I-5=-\\frac{5}{3}V$; since $U_1$ and $U_3$ are symmetric, by the voltage division relation we have $U_1 =U_3 =U_2\\times\\frac{10000}{10000+10000}=-\\frac{5}{6}V$.\n\n[Constraints]\n\n$30\\%$ of the testdata guarantees $N, M ≤ 30$.\n\n$60\\%$ of the testdata guarantees $N, M ≤ 3000$.\n\n$100\\%$ of the testdata guarantees $3 ≤ N, M ≤ 50000$, $1 ≤ u, v ≤ n$, $1 ≤ w ≤ 10$, and the length of the longest chain in the tree does not exceed $50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2012] 电阻网络", "background": null, "description": "给定一个树型电网，树中的每条边上有一个电阻 $R_i$，电阻值均为 $10000\\ Ω$。下图为一个包含 $4$ 个节点的树型电路情况：\n\n![图1](https://i.loli.net/2018/10/03/5bb46c0c587be.png)\n\n树中的所有叶子节点（度为 $1$ 的节点称为叶子）都接地，每条线上都接地，每条线上都附有 $10000\\ Ω$ 的电阻，最终形成的电网如下图所示：\n\n![图2](https://i.loli.net/2018/10/03/5bb46c0c72576.png)\n\n现有如下两种操作：\n\n`C u v w`：表示在边 $(u,v)$ 上串联一个电源，电源的大小为 $w$ 伏，电源位于靠近节点 $u$ 一侧（如下图所示），电源负极指向 $u$。注意同一条边上可以串联多个电源。\n\n![图3](https://i.loli.net/2018/10/03/5bb46c0c6a122.png)\n\n`Q u` ：表示询问点 $u$ 当前的电压，此是指对地。\n\n如对上图进行 `C 2 4 5` 操作后，网络变为：\n\n![图4](https://i.loli.net/2018/10/03/5bb46c0c86064.png)\n\n此时每个节点上的电压见上图的标注。", "inputFormat": "输入文件 circuit.in 的第一行包含两个整数 $N,M$，分别表示树的节点数和操作个数。接下来 $N-1$ 行，每行两个数 $u,v$，表示有一条连接节点 $u,v$ 的边，这条边上恰好包含一个电阻。\n\n接下来 $M$ 行，每行一个命令，格式见题目描述。", "outputFormat": "输出文件为 circuit.out。对于每个 `Q` 命令，输出一个数表示此刻该点的电压值。你可以输出任意多位的小数，只要你的答案和标准答案相差不超过 $10^{-3}$ 就算合法。", "hint": "【样例说明】\n\n对于第一个询问，由于原图中没有电源，所以没有电流，所有点的电压都相\n\n等（否则如果有 $U_i>U_j$，则就有 $i$ 流向 $j$ 的电流，与没有电源矛盾），都等于地电压 $0\\text{V}$。\n\n之后在 $(2,4)$ 中加一个 $5\\text{V}$ 的电源，得到的新图见题目描述。\n\n整理后可以发现，新图的形式是串联（电源，$R_2+10000$，并联（$R_1+10000$，$R_3+10000$）），由此可以得到新图的总电阻为:\n\n$$\nR 2 +10000+\\frac{1}{\\frac{1}{R_3 +10000}+\\frac{1}{R_1 +10000}}=30000\\ Ω\n$$\n\n所以流过节点 $4$ 的电流就是 $\\frac{5}{30000}\\ A$，所以 $U_4=\\frac{5}{3}V$，$U_2=U_4+R_2\\cdot I-5=-\\frac{5}{3}V$，由\n\n于 $U_1$ 和 $U_3$ 形式对称，由分压关系可知 $U_1 =U_3 =U_2\\times\\frac{10000}{10000+10000}=-\\frac{5}{6}V$。\n\n【数据规模】\n\n$30\\%$ 的数据保证 $N,M ≤ 30$。\n\n$60\\%$ 的数据保证 $N,M ≤ 3000$。\n\n$100\\%$ 的数据保证 $3 ≤ N,M ≤ 50000$，$1 ≤ u,v ≤ n$，$1 ≤ w ≤ 10$，树中最长链的长度不超过 $50$。", "locale": "zh-CN"}}}
{"pid": "P4021", "type": "P", "difficulty": 7, "samples": [["3 3 1\n1 2 1\n2 3 1\n1 3 1", "1\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "提交答案", "Special Judge", "CTSC/CTS"], "title": "[CTSC2012] 最短路", "background": null, "description": "给定一个节点 $1$ 和节点 $N$ 连通的正权无向图，请你删除不超过 $K$ 条边，使得节点 $1$ 和节点 $N$ 仍然连通的同时，这两点之间的最短路尽可能长 。", "inputFormat": "**本题为提交答案试题，[输入文件](https://pan.baidu.com/s/1o7K2dCm)（`shortest1.in`~`shortest10.in`）请在链接中下载**。\n\n输入文件 `shortest*.in` 的第一行包含三个正整数 $N,M,K$。其中 $N$ 表示节点数，$M$ 表示边数，节点的编号由 $1$ 至 $N$，边的编号由 $1$ 至 $M$。接下来 $M$ 行，\n\n每行三个正整数 $u,v,w$，表示有一条连接节点 $u$ 和节点 $v$ 的边，权值为 $w$。", "outputFormat": "输出文件 `shortest*.out` 的第一行包含一个非负整数 $T$，表示需要删掉的边数。\n\n接下来 $T$ 行，每行一个 $1$ 到 $M$ 之间的整数 $x$，表示删掉输入中的第 $x$ 条边。你需要保证这 $T$ 个整数互不相同。", "hint": "### 样例说明\n\n样例中从节点 $1$ 到 $3$ 的最短路径长度为 $1$，删去第三条边之后，最短路径长度为 $2$。\n\n### 评分标准\n\n对于每个测试点，设有评分四个参数 $s_1,s_2,s_3,s_4$。假设你的方案的最短路为 $\\textit{ans}$。\n\n如果你没有输出，或者输出不合法，或者最短路不存在，得 $0$ 分。\n\n如果最短路存在，得 $1$ 分。\n\n如果 $\\textit{ans}\\geq s_1$，得 $3$ 分。\n\n如果 $\\textit{ans}\\geq s_2$，得 $5$ 分。\n\n如果 $\\textit{ans}\\geq s_3$，得 $8$ 分。\n\n如果 $\\textit{ans}=s_4$，得 $10$ 分。\n\n如果 $\\textit{ans}>s_4$，得 $12$ 分。\n\n取满足条件的分数中的最高得分为该测试点你的得分。\n\n### 如何测试你的输出\n\n首先先编译 `checker.cpp`。\n\n在你的目录下有一个名为 `checker` 的程序可以用来检查你的输出，你可以在终端中使用以下命令来检查你的输出：\n\n```\n./checker N\n```\n\n其中 $N$ 为测试点的编号；例如，要测试第 $3$ 个测试点可以使用\n\n```\n./checker 3\n```\n\n该程序会检测你的输出方案是否合法。如果方案合法，程序还会给出该方案的最短路的长度值。\n\n### 特别提示\n\n请妥善保存输入文件和你的输出文件，及时备份，以免误删。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2012] Shortest Path", "background": "", "description": "Given an undirected graph with positive edge weights in which node $1$ and node $N$ are connected, delete at most $K$ edges so that nodes $1$ and $N$ remain connected, while making the shortest path between them as long as possible.", "inputFormat": "This is an output-only problem. Please download the input files from the link: [input files](https://pan.baidu.com/s/1o7K2dCm) (`shortest1.in` ~ `shortest10.in`).\n\nThe first line of the input file `shortest*.in` contains three positive integers $N, M, K$. Here $N$ is the number of nodes, $M$ is the number of edges. Nodes are numbered from $1$ to $N$, and edges are numbered from $1$ to $M$ in input order.  \nThen follow $M$ lines.  \nEach line contains three positive integers $u, v, w$, indicating an edge between nodes $u$ and $v$ with weight $w$.", "outputFormat": "The first line of the output file `shortest*.out` contains a non-negative integer $T$, the number of edges to delete.  \nThen output $T$ lines, each containing an integer $x$ between $1$ and $M$, indicating that the $x$-th edge in the input is deleted. These $T$ integers must be pairwise distinct.", "hint": "### Sample Explanation\n\nIn the sample, the shortest path length from node $1$ to $3$ is $1$. After deleting the third edge, the shortest path length becomes $2$.\n\n### Scoring\n\nFor each test point, there are four scoring parameters $s_1, s_2, s_3, s_4$. Let your solution’s shortest path be $\\textit{ans}$.\n\n- If you produce no output, or the output is invalid, or the shortest path does not exist, you get $0$ points.\n- If a shortest path exists, you get $1$ point.\n- If $\\textit{ans}\\geq s_1$, you get $3$ points.\n- If $\\textit{ans}\\geq s_2$, you get $5$ points.\n- If $\\textit{ans}\\geq s_3$, you get $8$ points.\n- If $\\textit{ans}=s_4$, you get $10$ points.\n- If $\\textit{ans}>s_4$, you get $12$ points.\n\nYour score for a test point is the maximum among the applicable cases above.\n\n### How to Test Your Output\n\nFirst, compile `checker.cpp`.\n\nThere will be a program named `checker` in your directory that can be used to verify your output. You can run the following command in the terminal:\n\n```\n./checker N\n```\n\nHere $N$ is the test point index. For example, to test the $3$-rd test point:\n\n```\n./checker 3\n```\n\nThis program checks whether your output solution is valid. If it is valid, it will also report the length of the shortest path.\n\n### Special Notes\n\nPlease keep your input files and output files properly saved and back them up in time to avoid accidental deletion.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2012] 最短路", "background": null, "description": "给定一个节点 $1$ 和节点 $N$ 连通的正权无向图，请你删除不超过 $K$ 条边，使得节点 $1$ 和节点 $N$ 仍然连通的同时，这两点之间的最短路尽可能长 。", "inputFormat": "**本题为提交答案试题，[输入文件](https://pan.baidu.com/s/1o7K2dCm)（`shortest1.in`~`shortest10.in`）请在链接中下载**。\n\n输入文件 `shortest*.in` 的第一行包含三个正整数 $N,M,K$。其中 $N$ 表示节点数，$M$ 表示边数，节点的编号由 $1$ 至 $N$，边的编号由 $1$ 至 $M$。接下来 $M$ 行，\n\n每行三个正整数 $u,v,w$，表示有一条连接节点 $u$ 和节点 $v$ 的边，权值为 $w$。", "outputFormat": "输出文件 `shortest*.out` 的第一行包含一个非负整数 $T$，表示需要删掉的边数。\n\n接下来 $T$ 行，每行一个 $1$ 到 $M$ 之间的整数 $x$，表示删掉输入中的第 $x$ 条边。你需要保证这 $T$ 个整数互不相同。", "hint": "### 样例说明\n\n样例中从节点 $1$ 到 $3$ 的最短路径长度为 $1$，删去第三条边之后，最短路径长度为 $2$。\n\n### 评分标准\n\n对于每个测试点，设有评分四个参数 $s_1,s_2,s_3,s_4$。假设你的方案的最短路为 $\\textit{ans}$。\n\n如果你没有输出，或者输出不合法，或者最短路不存在，得 $0$ 分。\n\n如果最短路存在，得 $1$ 分。\n\n如果 $\\textit{ans}\\geq s_1$，得 $3$ 分。\n\n如果 $\\textit{ans}\\geq s_2$，得 $5$ 分。\n\n如果 $\\textit{ans}\\geq s_3$，得 $8$ 分。\n\n如果 $\\textit{ans}=s_4$，得 $10$ 分。\n\n如果 $\\textit{ans}>s_4$，得 $12$ 分。\n\n取满足条件的分数中的最高得分为该测试点你的得分。\n\n### 如何测试你的输出\n\n首先先编译 `checker.cpp`。\n\n在你的目录下有一个名为 `checker` 的程序可以用来检查你的输出，你可以在终端中使用以下命令来检查你的输出：\n\n```\n./checker N\n```\n\n其中 $N$ 为测试点的编号；例如，要测试第 $3$ 个测试点可以使用\n\n```\n./checker 3\n```\n\n该程序会检测你的输出方案是否合法。如果方案合法，程序还会给出该方案的最短路的长度值。\n\n### 特别提示\n\n请妥善保存输入文件和你的输出文件，及时备份，以免误删。", "locale": "zh-CN"}}}
{"pid": "P4022", "type": "P", "difficulty": 7, "samples": [["1 2\n10110\n000001110\n1011001100", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["字符串", "2012", "后缀自动机 SAM", "CTSC/CTS"], "title": "[CTSC2012] 熟悉的文章", "background": "", "description": "阿米巴是小强的好朋友。\n\n在小强眼中，阿米巴是一个作文成绩很高的文艺青年。为了获取考试作文的真谛，小强向阿米巴求教。阿米巴给小强展示了几篇作文，小强觉得这些文章怎么看怎么觉得熟悉，仿佛是某些范文拼拼凑凑而成的。小强不禁向阿米巴投去了疑惑的眼光，却发现阿米巴露出了一个狡黠的微笑。\n\n为了有说服力地向阿米巴展示阿米巴的作文是多么让人觉得“眼熟”，小强想出了一个评定作文 “熟悉程度”的量化指标：$L_0$ .小强首先将作文转化成一个 $01$ 串。之后，小强搜集了各路名家的文章，同样分别转化成 $01$ 串后，整理出一个包含了 $M$ 个 $01$ 串的 “ 标准作文库 ”。\n\n小强认为：如果一个 $01$ 串长度不少于 $L$ 且在标准作文库中的某个串里出现过（即，它是标准作文库的某个串的一个 连续子串），那么它是 “ 熟悉 ” 的。对于一篇作文（一个 $01$ 串）$A$，如果能够把 $A$ 分割成若干段子串，其中 “ 熟悉 ” 的子串的长度总和不少于 $A$ 总长度的 $90\\%$，那么称 $A$ 是 “ 熟悉的文章 ”。 $L_0$ 是能够让 $A$ 成为 “ 熟悉的文章 ” 的 所有 $L$ 的最大值 （如果不存在这样的 $L$，那么规定 $L_0=0$）。\n\n举个例子：\n\n小强的作文库里包含了如下 $2$ 个字符串：\n\n```cpp\n10110\n000001110\n```\n有一篇待考察的作文是：\n\n```cpp\n1011001100\n```\n小强计算出这篇作文 $L$ 的最大值是 $4$，因为待考察的作文可以视作 $10110+0110+0$，其中 $10110$ 和 $0110$ 被判定为 “熟悉” 的。而当 $L = 5$ 或是更大的时候，不存在符合题意的分割方法。所以，这篇作文的 $L_0 = 4$。小强认为阿米巴作文的 $L_0$ 值比其他同学的明显要大。请你帮他验证一下。\n", "inputFormat": "输入第一行是两个整数 $N, M$，表示待检查的作文数量，和小强的标准作文库的行数。\n\n接下来是 $M$ 行的 $01$ 串，表示标准作文库。\n\n接下来是 $N$ 行的 $01$ 串，表示 $N$ 篇作文。\n", "outputFormat": "输出包含 $N$ 行，每一行包含一个整数，表示该篇作文的 $L_0$ 值。\n", "hint": "对于 $30\\%$ 的测试数据，输入文件的长度不超过 $1000$ 字节。\n\n对于 $50\\%$ 的测试数据，输入文件的长度不超过 $61000$ 字节。\n\n对于 $80\\%$ 的测试数据，输入文件的长度不超过 $250000$ 字节。\n\n对于 $100\\%$ 的测试数据，输入文件的长度不超过 $1100000$ 字节。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2012] Familiar Article", "background": "", "description": "Amiba is Xiao Qiang’s good friend.\n\nIn Xiao Qiang’s eyes, Amiba is a literary youth with excellent essay scores. To grasp the essence of exam essays, Xiao Qiang asked Amiba for guidance. Amiba showed him several essays. Xiao Qiang felt they looked very familiar, as if they were pieced together from some model essays. He cast a doubtful look at Amiba, only to see a sly smile.\n\nTo convincingly show how “familiar” Amiba’s essays feel, Xiao Qiang devised a quantitative metric for the “degree of familiarity” of an essay: $L_0$. He first converts an essay into a $01$ string. Then he collects essays from various famous authors, also converts them into $01$ strings, and compiles a “standard essay library” containing $M$ $01$ strings.\n\nXiao Qiang considers the following: if a $01$ string has length at least $L$ and appears in some string in the standard essay library (i.e., it is a contiguous substring of some string in the library), then it is “familiar.” For an essay (a $01$ string) $A$, if we can split $A$ into several substrings such that the total length of the “familiar” substrings is at least $90\\%$ of the total length of $A$, then $A$ is a “familiar article.” $L_0$ is the maximum among all $L$ that make $A$ a “familiar article” (if no such $L$ exists, define $L_0 = 0$).\n\nFor example:\n\nXiao Qiang’s essay library contains the following $2$ strings:\n\n```cpp\n10110\n000001110\n```\nThere is an essay to be examined:\n\n```cpp\n1011001100\n```\nXiao Qiang computes that the maximum $L$ for this essay is $4$, because the essay can be viewed as $10110+0110+0$, where $10110$ and $0110$ are judged “familiar.” When $L = 5$ or larger, no valid split exists. Therefore, this essay’s $L_0 = 4$. Xiao Qiang believes that Amiba’s $L_0$ values are noticeably larger than other students’. Please help him verify this.", "inputFormat": "The first line contains two integers $N, M$, denoting the number of essays to check and the number of strings in Xiao Qiang’s standard essay library.\n\nThe next $M$ lines contain $01$ strings, forming the standard essay library.\n\nThe next $N$ lines contain $01$ strings, representing the $N$ essays.", "outputFormat": "Output $N$ lines. Each line contains one integer, the $L_0$ value of the corresponding essay.", "hint": "For $30\\%$ of the testdata, the input file length does not exceed $1000$ bytes.\n\nFor $50\\%$ of the testdata, the input file length does not exceed $61000$ bytes.\n\nFor $80\\%$ of the testdata, the input file length does not exceed $250000$ bytes.\n\nFor $100\\%$ of the testdata, the input file length does not exceed $1100000$ bytes.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2012] 熟悉的文章", "background": "", "description": "阿米巴是小强的好朋友。\n\n在小强眼中，阿米巴是一个作文成绩很高的文艺青年。为了获取考试作文的真谛，小强向阿米巴求教。阿米巴给小强展示了几篇作文，小强觉得这些文章怎么看怎么觉得熟悉，仿佛是某些范文拼拼凑凑而成的。小强不禁向阿米巴投去了疑惑的眼光，却发现阿米巴露出了一个狡黠的微笑。\n\n为了有说服力地向阿米巴展示阿米巴的作文是多么让人觉得“眼熟”，小强想出了一个评定作文 “熟悉程度”的量化指标：$L_0$ .小强首先将作文转化成一个 $01$ 串。之后，小强搜集了各路名家的文章，同样分别转化成 $01$ 串后，整理出一个包含了 $M$ 个 $01$ 串的 “ 标准作文库 ”。\n\n小强认为：如果一个 $01$ 串长度不少于 $L$ 且在标准作文库中的某个串里出现过（即，它是标准作文库的某个串的一个 连续子串），那么它是 “ 熟悉 ” 的。对于一篇作文（一个 $01$ 串）$A$，如果能够把 $A$ 分割成若干段子串，其中 “ 熟悉 ” 的子串的长度总和不少于 $A$ 总长度的 $90\\%$，那么称 $A$ 是 “ 熟悉的文章 ”。 $L_0$ 是能够让 $A$ 成为 “ 熟悉的文章 ” 的 所有 $L$ 的最大值 （如果不存在这样的 $L$，那么规定 $L_0=0$）。\n\n举个例子：\n\n小强的作文库里包含了如下 $2$ 个字符串：\n\n```cpp\n10110\n000001110\n```\n有一篇待考察的作文是：\n\n```cpp\n1011001100\n```\n小强计算出这篇作文 $L$ 的最大值是 $4$，因为待考察的作文可以视作 $10110+0110+0$，其中 $10110$ 和 $0110$ 被判定为 “熟悉” 的。而当 $L = 5$ 或是更大的时候，不存在符合题意的分割方法。所以，这篇作文的 $L_0 = 4$。小强认为阿米巴作文的 $L_0$ 值比其他同学的明显要大。请你帮他验证一下。\n", "inputFormat": "输入第一行是两个整数 $N, M$，表示待检查的作文数量，和小强的标准作文库的行数。\n\n接下来是 $M$ 行的 $01$ 串，表示标准作文库。\n\n接下来是 $N$ 行的 $01$ 串，表示 $N$ 篇作文。\n", "outputFormat": "输出包含 $N$ 行，每一行包含一个整数，表示该篇作文的 $L_0$ 值。\n", "hint": "对于 $30\\%$ 的测试数据，输入文件的长度不超过 $1000$ 字节。\n\n对于 $50\\%$ 的测试数据，输入文件的长度不超过 $61000$ 字节。\n\n对于 $80\\%$ 的测试数据，输入文件的长度不超过 $250000$ 字节。\n\n对于 $100\\%$ 的测试数据，输入文件的长度不超过 $1100000$ 字节。\n", "locale": "zh-CN"}}}
{"pid": "P4023", "type": "P", "difficulty": 7, "samples": [["4 5 \n6 3 7 -1 -6 -5 1 5\n-5 -5 7 -5 9 -9 -10 11 -5 -6", "3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "CTSC/CTS"], "title": "[CTSC2012] 极点统计", "background": "", "description": "对于一个由平面上点组成的集合 $S$，以及一个平面上的点，以及一个平面上的点 $p$，函数 $f(p,S)$ 当且仅当 $p$ 在 $S$ 的凸包内部（包括 $S$ 的凸包的边界）时值为 $1$，其余情况下其值为 $0$。\n\n现给定两个平面上的点集 $P=\\{p_1,p_2,\\cdots,p_N\\}$ 和 $A=\\{a_1,a_2,\\cdots,a_M\\}$，我们称 $A$ 中的一个点 $a_i$ 为极点，当且仅其满足\n\n$$\\sum_{j\\ne i} f(a_i,P\\cup\\{a_j\\})=0$$\n\n也就是说，**$a_i$ 不在任意 $A$ 集合中非 $a_i$ 的点与 $P$ 组成的凸包内部。**\n\n请统计出集合 $A$ 中极点的个数。", "inputFormat": "第一行包含两个用空格隔开正整数 $N$ 和 $M$；\n\n第二行包含 $N$ 个用空格隔开的整数对，第 $i$ 个数对  $(x_i^p,y_i^p)$ 表示点 $p_i$ 的坐标；\n\n第二行包含$M$个用空格隔开的整数对，第 $j$ 个数对  $(x_j^a,y_j^a)$ 表示点 $a_j$ 的坐标。\n\n对于同一个集合，输入数据保证不会出现坐标相同的两个点。", "outputFormat": "仅包含一行一个整数，表示集合$A$中极点的个数。\n\n## 说明", "hint": "对于 $30\\%$ 的数据满足 $N,M\\le 50$；\n\n对于另外 $30\\%$ 的数据满足 $N\\le 10,M\\le 20000$；\n\n对于 $100\\%$ 的数据满足 $3\\le N\\le 10^5,1\\le M\\le 10^5,\\ |x_i|,|y_i|≤10^6$，且点集 $P$ 的凸包面积不为 $0$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2012] Extreme Point Statistics", "background": "", "description": "For a set $S$ of points in the plane and a point $p$ in the plane, define the function $f(p, S)$ to be $1$ if and only if $p$ lies inside the convex hull of $S$ (including its boundary), and $0$ otherwise.\n\nGiven two sets of points in the plane $P=\\{p_1,p_2,\\cdots,p_N\\}$ and $A=\\{a_1,a_2,\\cdots,a_M\\}$, we call a point $a_i \\in A$ an extreme point if and only if\n$$\\sum_{j\\ne i} f(a_i,P\\cup\\{a_j\\})=0.$$\n\nThat is, $a_i$ is not inside the convex hull formed by $P$ together with any other single point from $A$.\n\nPlease count the number of extreme points in set $A$.", "inputFormat": "- The first line contains two space-separated positive integers $N$ and $M$.\n- The second line contains $N$ space-separated pairs of integers; the $i$-th pair $(x_i^p,y_i^p)$ denotes the coordinates of point $p_i$.\n- The third line contains $M$ space-separated pairs of integers; the $j$-th pair $(x_j^a,y_j^a)$ denotes the coordinates of point $a_j$.\n- For the same set, the input guarantees that no two points share identical coordinates.", "outputFormat": "Output a single line with a single integer, the number of extreme points in set $A$.", "hint": "Constraints:\n- For $30\\%$ of the testdata, $N,M\\le 50$.\n- For another $30\\%$ of the testdata, $N\\le 10, M\\le 20000$.\n- For $100\\%$ of the testdata, $3\\le N\\le 10^5, 1\\le M\\le 10^5,\\ |x_i|,|y_i|\\le 10^6$, and the convex hull of set $P$ has non-zero area.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2012] 极点统计", "background": "", "description": "对于一个由平面上点组成的集合 $S$，以及一个平面上的点，以及一个平面上的点 $p$，函数 $f(p,S)$ 当且仅当 $p$ 在 $S$ 的凸包内部（包括 $S$ 的凸包的边界）时值为 $1$，其余情况下其值为 $0$。\n\n现给定两个平面上的点集 $P=\\{p_1,p_2,\\cdots,p_N\\}$ 和 $A=\\{a_1,a_2,\\cdots,a_M\\}$，我们称 $A$ 中的一个点 $a_i$ 为极点，当且仅其满足\n\n$$\\sum_{j\\ne i} f(a_i,P\\cup\\{a_j\\})=0$$\n\n也就是说，**$a_i$ 不在任意 $A$ 集合中非 $a_i$ 的点与 $P$ 组成的凸包内部。**\n\n请统计出集合 $A$ 中极点的个数。", "inputFormat": "第一行包含两个用空格隔开正整数 $N$ 和 $M$；\n\n第二行包含 $N$ 个用空格隔开的整数对，第 $i$ 个数对  $(x_i^p,y_i^p)$ 表示点 $p_i$ 的坐标；\n\n第二行包含$M$个用空格隔开的整数对，第 $j$ 个数对  $(x_j^a,y_j^a)$ 表示点 $a_j$ 的坐标。\n\n对于同一个集合，输入数据保证不会出现坐标相同的两个点。", "outputFormat": "仅包含一行一个整数，表示集合$A$中极点的个数。\n\n## 说明", "hint": "对于 $30\\%$ 的数据满足 $N,M\\le 50$；\n\n对于另外 $30\\%$ 的数据满足 $N\\le 10,M\\le 20000$；\n\n对于 $100\\%$ 的数据满足 $3\\le N\\le 10^5,1\\le M\\le 10^5,\\ |x_i|,|y_i|≤10^6$，且点集 $P$ 的凸包面积不为 $0$。", "locale": "zh-CN"}}}
{"pid": "P4024", "type": "P", "difficulty": 6, "samples": [["3 5 3\n1 2 3 4 5\n9 9 9 9 9\n1 4 3 5 2\n1 1 2 5\n3 1 3 5\n2 1 3 5\n", "0\n4\n19\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2012", "提交答案", "CTSC/CTS"], "title": "[CTSC2012] 统计学家", "background": "[输入文件](https://pan.baidu.com/s/1i5laUcH)\n\n**由于洛谷评测机限制，最后请输出所有回答的异或和。**\n", "description": "给定一个 $N\\times M$ 的整数矩阵 $\\{A[i,j]\\}$（$1\\le i\\le N$，$1\\le j\\le M$）。请回答 $K$ 个询问，其中第 $i$ 个询问要求统计满足下述条件的二维逆序对 $(x_1,y_1,x_2,y_2)$ 的个数：\n\n- $u_{i,1}\\le x_1\\le x_2\\le u_{i,2}$\n- 且 $v_{i,1}\\le y_1\\le y_2\\le v_{i,2}$\n- 且 $A[x_1,y_1]>A[x_2,y_2]$", "inputFormat": "本题为提交答案试题，[输入文件](https://pan.baidu.com/s/1i5laUcH) `rev1.in ~ rev10.in`。\n\n输入文件 `rev*.in` 的第一行依次包含三个正整数 $N, M, K$。\n\n接下来 $N$ 行，每行 $M$ 个数给出整数矩阵 $A$，其中第 $i$ 行第 $j$ 个数为 $A[i,j]$。接下来 $K$ 行，每行四个整数给出所有的询问，其中第 $i$ 行依次为 $u_{i,1}, v_{i,1}, u_{i,2}, v_{i,2}$。", "outputFormat": "输出文件 `rev*.out` 的包含 $K$ 行，其中第 $i$ 行为一个整数，对应的第 $i$ 个询问的答案，即满足相应条件的二维逆序对个数。\n\n## 说明\n\n### 评分标准\n\n对于每个测试点，如果你有输出，且输出结果与标准输出完全一致，则该测试点得 $10$ 分，否则该测试点得 $0$ 分。\n\n**由于洛谷评测机限制，最后请输出所有回答的异或和。样例仅为理解题目之用，并非最后输出格式。**", "hint": "请妥善保存输入文件 `*.in` 和你的输出 `*.out`，及时备份，以免误删。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2012] Statistician", "background": "[Input files](https://pan.baidu.com/s/1i5laUcH).\n\nDue to the limitation of the Luogu judge, please output the XOR of all answers at the end.\n\nScoring: For each test point, if you produce an output and it exactly matches the official output, you get 10 points; otherwise, you get 0 points.", "description": "Given an $N \\times M$ integer matrix $\\{A[i,j]\\}$ ($1 \\le i \\le N$, $1 \\le j \\le M$). You need to answer $K$ queries. The $i$‑th query asks you to count the number of 2D inversion pairs $(x_1, y_1, x_2, y_2)$ that satisfy all of the following:\n- $u_{i,1} \\le x_1 \\le x_2 \\le u_{i,2}$,\n- $v_{i,1} \\le y_1 \\le y_2 \\le v_{i,2}$,\n- $A[x_1, y_1] > A[x_2, y_2]$.", "inputFormat": "This is an answer-submission problem. The [input files](https://pan.baidu.com/s/1i5laUcH) are named `rev1.in ~ rev10.in`.\n\nFor each `rev*.in`, the first line contains three positive integers $N, M, K$.\n\nThe next $N$ lines each contain $M$ integers, giving the matrix $A$, where the $j$‑th number in the $i$‑th line is $A[i, j]$. Then the next $K$ lines each contain four integers describing the queries; in the $i$‑th of these lines, the four integers are $u_{i,1}, v_{i,1}, u_{i,2}, v_{i,2}$.", "outputFormat": "On Luogu, output a single integer: the XOR of all $K$ answers (i.e., the XOR of the answers to all queries).\n\nNote: The sample is only for understanding the problem and is not the final output format.\n\n(Original answer-submission format for each `rev*.out`: it contains $K$ lines, where the $i$‑th line is the answer to the $i$‑th query, i.e., the number of 2D inversion pairs that satisfy the corresponding conditions.)", "hint": "Please keep the input files `*.in` and your outputs `*.out` safe and back them up in time to avoid accidental deletion.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2012] 统计学家", "background": "[输入文件](https://pan.baidu.com/s/1i5laUcH)\n\n**由于洛谷评测机限制，最后请输出所有回答的异或和。**\n", "description": "给定一个 $N\\times M$ 的整数矩阵 $\\{A[i,j]\\}$（$1\\le i\\le N$，$1\\le j\\le M$）。请回答 $K$ 个询问，其中第 $i$ 个询问要求统计满足下述条件的二维逆序对 $(x_1,y_1,x_2,y_2)$ 的个数：\n\n- $u_{i,1}\\le x_1\\le x_2\\le u_{i,2}$\n- 且 $v_{i,1}\\le y_1\\le y_2\\le v_{i,2}$\n- 且 $A[x_1,y_1]>A[x_2,y_2]$", "inputFormat": "本题为提交答案试题，[输入文件](https://pan.baidu.com/s/1i5laUcH) `rev1.in ~ rev10.in`。\n\n输入文件 `rev*.in` 的第一行依次包含三个正整数 $N, M, K$。\n\n接下来 $N$ 行，每行 $M$ 个数给出整数矩阵 $A$，其中第 $i$ 行第 $j$ 个数为 $A[i,j]$。接下来 $K$ 行，每行四个整数给出所有的询问，其中第 $i$ 行依次为 $u_{i,1}, v_{i,1}, u_{i,2}, v_{i,2}$。", "outputFormat": "输出文件 `rev*.out` 的包含 $K$ 行，其中第 $i$ 行为一个整数，对应的第 $i$ 个询问的答案，即满足相应条件的二维逆序对个数。\n\n## 说明\n\n### 评分标准\n\n对于每个测试点，如果你有输出，且输出结果与标准输出完全一致，则该测试点得 $10$ 分，否则该测试点得 $0$ 分。\n\n**由于洛谷评测机限制，最后请输出所有回答的异或和。样例仅为理解题目之用，并非最后输出格式。**", "hint": "请妥善保存输入文件 `*.in` 和你的输出 `*.out`，及时备份，以免误删。", "locale": "zh-CN"}}}
{"pid": "P4025", "type": "P", "difficulty": 4, "samples": [["3 5\n3 1\n4 8\n8 3", "TAK\n2 3 1 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "Special Judge", "PA（波兰）"], "title": "[PA 2014] Bohater", "background": "", "description": "在一款电脑游戏中，你需要打败 $n$ 只怪物（从 $1$ 到 $n$ 编号）。\n\n为了打败第 $i$ 只怪物，你需要消耗 $d_i$ 点生命值，但怪物死后会掉落血药，使你恢复 $a_i$ 点生命值。\n\n任何时候你的生命值都不能降到 $0$（或 $0$ 以下）。\n\n请问是否存在一种打怪顺序，使得你可以打完这 $n$ 只怪物而不死掉。", "inputFormat": "第一行两个整数 $n,z$，分别表示怪物的数量和你的初始生命值。\n\n接下来 $n$ 行，每行两个整数 $d_i,a_i$。", "outputFormat": "第一行为 `TAK`（是）或 `NIE`（否），表示是否存在这样的顺序。\n\n如果第一行为 `TAK`，则第二行为空格隔开的 $1\\sim n$ 的排列，表示合法的顺序。\n\n如果答案有很多，你可以输出其中任意一个。（**本题使用 SPJ**）", "hint": "对于 $100\\%$ 的数据，$1\\le n,z\\le 10^5$，$0\\le d_i,a_i\\le 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2014] Bohater", "background": "", "description": "在一款电脑游戏中，你需要打败 $n$ 只怪物（从 $1$ 到 $n$ 编号）。\n\n为了打败第 $i$ 只怪物，你需要消耗 $d_i$ 点生命值，但怪物死后会掉落血药，使你恢复 $a_i$ 点生命值。\n\n任何时候你的生命值都不能降到 $0$（或 $0$ 以下）。\n\n请问是否存在一种打怪顺序，使得你可以打完这 $n$ 只怪物而不死掉。", "inputFormat": "第一行两个整数 $n,z$，分别表示怪物的数量和你的初始生命值。\n\n接下来 $n$ 行，每行两个整数 $d_i,a_i$。", "outputFormat": "第一行为 `TAK`（是）或 `NIE`（否），表示是否存在这样的顺序。\n\n如果第一行为 `TAK`，则第二行为空格隔开的 $1\\sim n$ 的排列，表示合法的顺序。\n\n如果答案有很多，你可以输出其中任意一个。（**本题使用 SPJ**）", "hint": "对于 $100\\%$ 的数据，$1\\le n,z\\le 10^5$，$0\\le d_i,a_i\\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P4026", "type": "P", "difficulty": 6, "samples": [["10 0 0\n0 1 0 0 0 0\n0 0 0 3 0 10\n0 0 3 0 0 0", "5"], ["-10 -10 -10\n0 0 0 0 0 0\n0 0 0 0 0 0\n0 0 0 0 0 0", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "各省省选", "上海", "枚举", "背包 DP"], "title": "[SHOI2008] 循环的债务", "background": null, "description": "Alice、Bob 和 Cynthia 总是为他们之间混乱的债务而烦恼，终于有一天，他们决定坐下来一起解决这个问题。不过，鉴别钞票的真伪是一件很麻烦的事情，于是他们决定要在清还债务的时候尽可能少的交换现金。\n\n比如说，Alice 欠 Bob $10$ 元，而 Cynthia 和他俩互不相欠。现在假设 Alice 只有一张 $50$ 元，Bob 有 $3$ 张 $10$ 元和 $10$ 张 $1$ 元，Cynthia有 $3$ 张 $20$ 元。一种比较直接的做法是：Alice 将 $50$ 元交给 Bob，而 Bob 将他身上的钱找给 Alice，这样一共就会有 $14$ 张钞票被交换。但这不是最好的做法，最好的做法是：Alice 把 $50$ 块给 Cynthia，Cynthia 再把两张 $20$ 给 Alice，另一张 $20$ 给 Bob，而 Bob 把一张 $10$ 块给 Cynthia，此时只有 $5$ 张钞票被交换过。\n\n没过多久他们就发现这是一个很棘手的问题，于是他们找到了精通数学的你为他们解决这个难题。", "inputFormat": "输入的第一行包括三个整数：$x_1$、$x_2$、$x_3$（$-1,000 \\le x_1, x_2, x_3 \\le 1,000$），其中\n\n$x_1$ 代表 Alice 欠 Bob 的钱（如果 $x_1$ 是负数，说明 Bob 欠了 Alice 的钱）\n\n$x_2$ 代表 Bob 欠 Cynthia 的钱（如果 $x_2$ 是负数，说明 Cynthia 欠了 Bob 的钱）\n\n$x_3$ 代表 Cynthia 欠 Alice 的钱（如果 $x_3$ 是负数，说明 Alice 欠了 Cynthia 的钱）\n\n接下来有三行，每行包括 6 个自然数：\n\n$\na_{100}, a_{50}, a_{20}, a_{10}, a_5, a_1\n$\n\n$\nb_{100}, b_{50}, b_{20}, b_{10}, b_5, b_1\n$\n\n$\nc_{100}, c_{50}, c_{20}, c_{10}, c_5, c_1\n$\n\n$a_{100}$ 表示 Alice 拥有的 $100$ 元钞票张数，$b_{50}$ 表示 Bob 拥有的 $50$ 元钞票张数，以此类推。另外，我们保证有 $a_{10} + a_5 + a_1 \\le 30$，$b_{10} + b_5 + b_1 \\le 30$，$c_{10} + c_5 + c_1 \\le 30$，而且三人总共拥有的钞票面值总额不会超过 $1,000$。", "outputFormat": "如果债务可以还清，则输出需要交换钞票的最少张数；如果不能还清，则输出“```impossible```”（注意单词全部小写，输出到文件时不要加引号）。", "hint": "对于 $30\\%$ 的数据，$x_1, x_2, x_3 \\le 50$。\n\n对于 $100\\%$ 的数据，$x_1, x_2, x_3 \\le 1,000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2008] Cyclic Debts", "background": "", "description": "Alice, Bob, and Cynthia are always troubled by the messy debts among them. One day, they decide to sit together and settle everything. However, checking the authenticity of banknotes is troublesome, so they decide to exchange as little cash as possible when paying off their debts.\n\nFor example, Alice owes Bob $10$ yuan, while Cynthia owes neither of them anything. Suppose Alice has one $50$ yuan note, Bob has three $10$ yuan notes and ten $1$ yuan notes, and Cynthia has three $20$ yuan notes. A straightforward way is: Alice gives the $50$ yuan to Bob, and Bob gives change back to Alice. In total, $14$ banknotes are exchanged. But this is not optimal. The optimal way is: Alice gives the $50$ to Cynthia, Cynthia gives two $20$ notes to Alice and one $20$ note to Bob, and Bob gives one $10$ note to Cynthia. In this case, only $5$ banknotes are exchanged.\n\nBefore long, they find this is a hard problem, so they ask you, who are good at math, to solve it for them.", "inputFormat": "The first line contains three integers: $x_1$, $x_2$, $x_3$ ($-1,000 \\le x_1, x_2, x_3 \\le 1,000$), where\n\n$x_1$ is the amount Alice owes Bob (if $x_1$ is negative, it means Bob owes Alice),\n\n$x_2$ is the amount Bob owes Cynthia (if $x_2$ is negative, it means Cynthia owes Bob),\n\n$x_3$ is the amount Cynthia owes Alice (if $x_3$ is negative, it means Alice owes Cynthia).\n\nThen there are three lines, each containing 6 natural numbers:\n\n$\na_{100}, a_{50}, a_{20}, a_{10}, a_5, a_1\n$\n\n$\nb_{100}, b_{50}, b_{20}, b_{10}, b_5, b_1\n$\n\n$\nc_{100}, c_{50}, c_{20}, c_{10}, c_5, c_1\n$\n\n$a_{100}$ is the number of $100$ yuan banknotes Alice has, $b_{50}$ is the number of $50$ yuan banknotes Bob has, and so on. We also guarantee $a_{10} + a_5 + a_1 \\le 30$, $b_{10} + b_5 + b_1 \\le 30$, $c_{10} + c_5 + c_1 \\le 30$, and the total face value of all banknotes owned by the three people does not exceed $1,000$.", "outputFormat": "If the debts can be fully settled, output the minimum number of banknotes that need to be exchanged. If they cannot be settled, output impossible.", "hint": "For $30\\%$ of the testdata, $x_1, x_2, x_3 \\le 50$.\n\nFor $100\\%$ of the testdata, $x_1, x_2, x_3 \\le 1,000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2008] 循环的债务", "background": null, "description": "Alice、Bob 和 Cynthia 总是为他们之间混乱的债务而烦恼，终于有一天，他们决定坐下来一起解决这个问题。不过，鉴别钞票的真伪是一件很麻烦的事情，于是他们决定要在清还债务的时候尽可能少的交换现金。\n\n比如说，Alice 欠 Bob $10$ 元，而 Cynthia 和他俩互不相欠。现在假设 Alice 只有一张 $50$ 元，Bob 有 $3$ 张 $10$ 元和 $10$ 张 $1$ 元，Cynthia有 $3$ 张 $20$ 元。一种比较直接的做法是：Alice 将 $50$ 元交给 Bob，而 Bob 将他身上的钱找给 Alice，这样一共就会有 $14$ 张钞票被交换。但这不是最好的做法，最好的做法是：Alice 把 $50$ 块给 Cynthia，Cynthia 再把两张 $20$ 给 Alice，另一张 $20$ 给 Bob，而 Bob 把一张 $10$ 块给 Cynthia，此时只有 $5$ 张钞票被交换过。\n\n没过多久他们就发现这是一个很棘手的问题，于是他们找到了精通数学的你为他们解决这个难题。", "inputFormat": "输入的第一行包括三个整数：$x_1$、$x_2$、$x_3$（$-1,000 \\le x_1, x_2, x_3 \\le 1,000$），其中\n\n$x_1$ 代表 Alice 欠 Bob 的钱（如果 $x_1$ 是负数，说明 Bob 欠了 Alice 的钱）\n\n$x_2$ 代表 Bob 欠 Cynthia 的钱（如果 $x_2$ 是负数，说明 Cynthia 欠了 Bob 的钱）\n\n$x_3$ 代表 Cynthia 欠 Alice 的钱（如果 $x_3$ 是负数，说明 Alice 欠了 Cynthia 的钱）\n\n接下来有三行，每行包括 6 个自然数：\n\n$\na_{100}, a_{50}, a_{20}, a_{10}, a_5, a_1\n$\n\n$\nb_{100}, b_{50}, b_{20}, b_{10}, b_5, b_1\n$\n\n$\nc_{100}, c_{50}, c_{20}, c_{10}, c_5, c_1\n$\n\n$a_{100}$ 表示 Alice 拥有的 $100$ 元钞票张数，$b_{50}$ 表示 Bob 拥有的 $50$ 元钞票张数，以此类推。另外，我们保证有 $a_{10} + a_5 + a_1 \\le 30$，$b_{10} + b_5 + b_1 \\le 30$，$c_{10} + c_5 + c_1 \\le 30$，而且三人总共拥有的钞票面值总额不会超过 $1,000$。", "outputFormat": "如果债务可以还清，则输出需要交换钞票的最少张数；如果不能还清，则输出“```impossible```”（注意单词全部小写，输出到文件时不要加引号）。", "hint": "对于 $30\\%$ 的数据，$x_1, x_2, x_3 \\le 50$。\n\n对于 $100\\%$ 的数据，$x_1, x_2, x_3 \\le 1,000$。", "locale": "zh-CN"}}}
{"pid": "P4027", "type": "P", "difficulty": 6, "samples": [["3 100\n1 1 1\n1 2 2\n2 2 3", "225.000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2007", "平衡树", "NOI", "离散化", "cdq 分治", "Special Judge", "分治", "动态规划优化", "斜率优化", "凸包", "李超线段树"], "title": "[NOI2007] 货币兑换", "background": "", "description": "小 Y 最近在一家金券交易所工作。该金券交易所只发行交易两种金券：A 纪念券（以下简称 A 券）和 B 纪念券（以下简称 B 券）。每个持有金券的顾客都有一个自己的帐户。金券的数目可以是一个实数。\n\n每天随着市场的起伏波动，两种金券都有自己当时的价值，即每一单位金券当天可以兑换的人民币数目。我们记录第 $K$ 天中 A 券和 B 券的价值分别为 $A_K$ 和 $B_K$（元/单位金券）。\n\n为了方便顾客，金券交易所提供了一种非常方便的交易方式：比例交易法。\n\n比例交易法分为两个方面：\n\na)  卖出金券：顾客提供一个 $[0, 100]$ 内的实数 $OP$ 作为卖出比例，其意义为：将 $OP\\%$ 的 A 券和 $OP\\%$ 的 B 券以当时的价值兑换为人民币；\n\nb)  买入金券：顾客支付 $IP$ 元人民币，交易所将会兑换给用户总价值为 $IP$ 的金券，并且，满足提供给顾客的 A 券和 B 券的比例在第 $K$ 天恰好为 $\\mathrm{Rate}_ K$；\n\n例如，假定接下来 $3$ 天内的 $A_K,B_K,\\mathrm{Rate}_ K$ 的变化分别为：\n\n| 时间 | $A_K$ | $B_K$ | $\\mathrm{Rate}_ K$ |\n| ----- | ----- | ----- | ----- |\n| 第一天 | $1$ | $1$ | $1$ |\n| 第二天 | $1$ | $2$ | $2$ |\n| 第三天 | $2$ | $2$ | $3$ |\n\n\n\n假定在第一天时，用户手中有 $100$ 元人民币但是没有任何金券。\n\n用户可以执行以下的操作：\n\n| 时间 | 用户操作 | 人民币(元) | A 券的数量 | B 券的数量 |\n| ----- | ----- | ----- | ----- | ----- |\n| 开户 | 无 | $100$ | $0$ | $0$ |\n| 第一天 | 买入 $100$ 元 | $0$ | $50$ | $50$ |\n| 第二天 | 卖出 $50\\%$ | $75$ | $25$ | $25$ |\n| 第二天 | 买入 $60$ 元 | $15$ | $55$ | $40$ |\n| 第三天 | 卖出 $100\\%$ | $205$ | $0$ | $0$ |\n\n注意到，同一天内可以进行多次操作。\n\n小 Y 是一个很有经济头脑的员工，通过较长时间的运作和行情测算，他已经知道了未来 $N$ 天内的 A 券和 B 券的价值以及 $\\mathrm{Rate}$。他还希望能够计算出来，如果开始时拥有 $S$ 元钱，那么 $N$ 天后最多能够获得多少元钱。\n", "inputFormat": "第一行两个正整数 $N,S$，分别表示小 Y 能预知的天数以及初始时拥有的钱数。\n\n接下来 $N$ 行，第 $K$ 行三个实数 $A_K,B_K,\\mathrm{Rate} _ K$ ，意义如题目中所述。\n", "outputFormat": "只有一个实数 $\\mathrm{MaxProfit}$，表示第 $N$ 天的操作结束时能够获得的最大的金钱数目。答案保留 $3$ 位小数。\n", "hint": "| 时间 | 用户操作 | 人民币(元) | A 券的数量 | B 券的数量 |\n| ----- | ----- | ----- | ----- | ----- |\n| 开户 | 无 | $100$ | $0$ | $0$ |\n| 第一天 | 买入 $100$ 元 | $0$ | $50$ | $50$ |\n| 第二天 | 卖出 $100\\%$ | $150$ | $0$ | $0$ |\n| 第二天 | 买入 $150$ 元 | $0$ | $75$ | $37.5$ |\n| 第三天 | 卖出 $100\\%$ | $225$ | $0$ | $0$ |\n\n\n本题没有部分分，你的程序的输出只有和标准答案相差不超过 $0.001$ 时，才能获得该测试点的满分，否则不得分。\n\n\n测试数据设计使得精度误差不会超过 $10^{-7}$ 。\n\n对于 $40\\%$ 的测试数据，满足 $N \\le 10$。\n\n对于 $60\\%$ 的测试数据，满足 $N \\le 1 000$。\n\n对于 $100\\%$ 的测试数据，满足 $N \\le 10^5$。\n\n对于 $100\\%$ 的测试数据，满足：\n\n$0 < A_K \\leq 10$，$0 < B_K\\le 10$，$0 < \\mathrm{Rate}_K \\le 100$，$\\mathrm{MaxProfit}  \\leq 10^9$。\n\n输入文件可能很大，请采用快速的读入方式。\n\n必然存在一种最优的买卖方案满足：\n\n每次买进操作使用完所有的人民币，每次卖出操作卖出所有的金券。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2007] Currency Exchange", "background": "", "description": "Xiao Y (pinyin) recently started working at a voucher exchange. This exchange issues and trades only two types of vouchers: A commemorative voucher (hereinafter A voucher) and B commemorative voucher (hereinafter B voucher). Each customer who holds vouchers has their own account. The quantities of vouchers can be real numbers.\n\nWith daily market fluctuations, the two vouchers each have their current value, i.e., each unit of voucher can be exchanged for a certain amount of RMB on that day. We record the values of A and B vouchers on day $K$ as $A_K$ and $B_K$ (yuan per unit voucher), respectively.\n\nFor customer convenience, the exchange provides a very convenient trading method: proportional trading.\n\nProportional trading has two aspects:\n\na) Sell vouchers: The customer provides a real number $OP$ in $[0, 100]$ as the selling ratio, meaning: exchange $OP\\%$ of A vouchers and $OP\\%$ of B vouchers into RMB at the current values.\n\nb) Buy vouchers: The customer pays $IP$ RMB, and the exchange will convert it into vouchers with a total value of $IP$, and the proportion of A and B vouchers provided to the customer will be exactly $\\mathrm{Rate}_ K$ on day $K$.\n\nFor example, suppose over the next $3$ days the changes of $A_K$, $B_K$, and $\\mathrm{Rate}_ K$ are as follows:\n\n| Time | $A_K$ | $B_K$ | $\\mathrm{Rate}_ K$ |\n| ----- | ----- | ----- | ----- |\n| Day 1 | $1$ | $1$ | $1$ |\n| Day 2 | $1$ | $2$ | $2$ |\n| Day 3 | $2$ | $2$ | $3$ |\n\nAssume that on day 1, the user has $100$ RMB yuan and no vouchers.\n\nThe user can perform the following operations:\n\n| Time | User operation | RMB (yuan) | Quantity of A vouchers | Quantity of B vouchers |\n| ----- | ----- | ----- | ----- | ----- |\n| Account opening | None | $100$ | $0$ | $0$ |\n| Day 1 | Buy $100$ yuan | $0$ | $50$ | $50$ |\n| Day 2 | Sell $50\\%$ | $75$ | $25$ | $25$ |\n| Day 2 | Buy $60$ yuan | $15$ | $55$ | $40$ |\n| Day 3 | Sell $100\\%$ | $205$ | $0$ | $0$ |\n\nNote that multiple operations can be performed on the same day.\n\nXiao Y is financially savvy. Through long-term operations and market estimation, he already knows the values of A and B vouchers and $\\mathrm{Rate}$ for the next $N$ days. He also wants to compute, if he starts with $S$ RMB yuan, what is the maximum amount of money he can obtain after $N$ days.", "inputFormat": "The first line contains two positive integers $N, S$, representing the number of days Xiao Y can foresee and the initial amount of money, respectively.\n\nThe next $N$ lines each contain three real numbers $A_K, B_K, \\mathrm{Rate} _ K$ on line $K$, as described above.", "outputFormat": "Output a single real number $\\mathrm{MaxProfit}$, the maximum amount of money obtainable by the end of day $N$. The answer should be rounded to $3$ decimal places.", "hint": "| Time | User operation | RMB (yuan) | Quantity of A vouchers | Quantity of B vouchers |\n| ----- | ----- | ----- | ----- | ----- |\n| Account opening | None | $100$ | $0$ | $0$ |\n| Day 1 | Buy $100$ yuan | $0$ | $50$ | $50$ |\n| Day 2 | Sell $100\\%$ | $150$ | $0$ | $0$ |\n| Day 2 | Buy $150$ yuan | $0$ | $75$ | $37.5$ |\n| Day 3 | Sell $100\\%$ | $225$ | $0$ | $0$ |\n\nThere is no partial credit for this problem. Your program’s output must not differ from the standard answer by more than $0.001$ to receive full credit for a test point; otherwise, you get no points.\n\nThe testdata is designed such that the precision error will not exceed $10^{-7}$.\n\nFor $40\\%$ of the testdata, $N \\le 10$.\n\nFor $60\\%$ of the testdata, $N \\le 1\\,000$.\n\nFor $100\\%$ of the testdata, $N \\le 10^5$.\n\nFor $100\\%$ of the testdata, the following hold:\n$0 < A_K \\leq 10$, $0 < B_K \\le 10$, $0 < \\mathrm{Rate}_K \\le 100$, $\\mathrm{MaxProfit} \\leq 10^9$.\n\nThe input file may be large; please use fast I/O.\n\nThere always exists an optimal buy/sell strategy that satisfies:\neach buy operation uses up all RMB, and each sell operation sells all vouchers.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2007] 货币兑换", "background": "", "description": "小 Y 最近在一家金券交易所工作。该金券交易所只发行交易两种金券：A 纪念券（以下简称 A 券）和 B 纪念券（以下简称 B 券）。每个持有金券的顾客都有一个自己的帐户。金券的数目可以是一个实数。\n\n每天随着市场的起伏波动，两种金券都有自己当时的价值，即每一单位金券当天可以兑换的人民币数目。我们记录第 $K$ 天中 A 券和 B 券的价值分别为 $A_K$ 和 $B_K$（元/单位金券）。\n\n为了方便顾客，金券交易所提供了一种非常方便的交易方式：比例交易法。\n\n比例交易法分为两个方面：\n\na)  卖出金券：顾客提供一个 $[0, 100]$ 内的实数 $OP$ 作为卖出比例，其意义为：将 $OP\\%$ 的 A 券和 $OP\\%$ 的 B 券以当时的价值兑换为人民币；\n\nb)  买入金券：顾客支付 $IP$ 元人民币，交易所将会兑换给用户总价值为 $IP$ 的金券，并且，满足提供给顾客的 A 券和 B 券的比例在第 $K$ 天恰好为 $\\mathrm{Rate}_ K$；\n\n例如，假定接下来 $3$ 天内的 $A_K,B_K,\\mathrm{Rate}_ K$ 的变化分别为：\n\n| 时间 | $A_K$ | $B_K$ | $\\mathrm{Rate}_ K$ |\n| ----- | ----- | ----- | ----- |\n| 第一天 | $1$ | $1$ | $1$ |\n| 第二天 | $1$ | $2$ | $2$ |\n| 第三天 | $2$ | $2$ | $3$ |\n\n\n\n假定在第一天时，用户手中有 $100$ 元人民币但是没有任何金券。\n\n用户可以执行以下的操作：\n\n| 时间 | 用户操作 | 人民币(元) | A 券的数量 | B 券的数量 |\n| ----- | ----- | ----- | ----- | ----- |\n| 开户 | 无 | $100$ | $0$ | $0$ |\n| 第一天 | 买入 $100$ 元 | $0$ | $50$ | $50$ |\n| 第二天 | 卖出 $50\\%$ | $75$ | $25$ | $25$ |\n| 第二天 | 买入 $60$ 元 | $15$ | $55$ | $40$ |\n| 第三天 | 卖出 $100\\%$ | $205$ | $0$ | $0$ |\n\n注意到，同一天内可以进行多次操作。\n\n小 Y 是一个很有经济头脑的员工，通过较长时间的运作和行情测算，他已经知道了未来 $N$ 天内的 A 券和 B 券的价值以及 $\\mathrm{Rate}$。他还希望能够计算出来，如果开始时拥有 $S$ 元钱，那么 $N$ 天后最多能够获得多少元钱。\n", "inputFormat": "第一行两个正整数 $N,S$，分别表示小 Y 能预知的天数以及初始时拥有的钱数。\n\n接下来 $N$ 行，第 $K$ 行三个实数 $A_K,B_K,\\mathrm{Rate} _ K$ ，意义如题目中所述。\n", "outputFormat": "只有一个实数 $\\mathrm{MaxProfit}$，表示第 $N$ 天的操作结束时能够获得的最大的金钱数目。答案保留 $3$ 位小数。\n", "hint": "| 时间 | 用户操作 | 人民币(元) | A 券的数量 | B 券的数量 |\n| ----- | ----- | ----- | ----- | ----- |\n| 开户 | 无 | $100$ | $0$ | $0$ |\n| 第一天 | 买入 $100$ 元 | $0$ | $50$ | $50$ |\n| 第二天 | 卖出 $100\\%$ | $150$ | $0$ | $0$ |\n| 第二天 | 买入 $150$ 元 | $0$ | $75$ | $37.5$ |\n| 第三天 | 卖出 $100\\%$ | $225$ | $0$ | $0$ |\n\n\n本题没有部分分，你的程序的输出只有和标准答案相差不超过 $0.001$ 时，才能获得该测试点的满分，否则不得分。\n\n\n测试数据设计使得精度误差不会超过 $10^{-7}$ 。\n\n对于 $40\\%$ 的测试数据，满足 $N \\le 10$。\n\n对于 $60\\%$ 的测试数据，满足 $N \\le 1 000$。\n\n对于 $100\\%$ 的测试数据，满足 $N \\le 10^5$。\n\n对于 $100\\%$ 的测试数据，满足：\n\n$0 < A_K \\leq 10$，$0 < B_K\\le 10$，$0 < \\mathrm{Rate}_K \\le 100$，$\\mathrm{MaxProfit}  \\leq 10^9$。\n\n输入文件可能很大，请采用快速的读入方式。\n\n必然存在一种最优的买卖方案满足：\n\n每次买进操作使用完所有的人民币，每次卖出操作卖出所有的金券。\n", "locale": "zh-CN"}}}
{"pid": "P4028", "type": "P", "difficulty": 5, "samples": [["1\n5 2 3", "3"], ["1\n2 2 2", "Couldn't Produce!"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "洛谷原创", "O2优化", "枚举", "哈希 hashing", "大步小步算法 BSGS"], "title": "New Product", "background": "**一个经商的神奇故事……**\n\n(善意提醒：注意时限！）\n", "description": "LiM 有一家手工糕点店，因为糕点既实惠又好吃，于是积累了 $P$ 个常客（$P$ 为质数）。\n\n每次这家店出 New Product（新品）的时候，都会做很多个，这 $P$ 个人都会支持，支持方法是：\n\n**每个人买的数量都相同，而且买的总数要尽量多。**\n\n这家店共有 $B$ 个工人，一分钟可以生产已经生产的数量的 $A$ 倍。\n\n（注：一开始有一个已制作的 New Product 作为制作样品）\n\n而当制作完毕，抢购（只考虑常客）完后：\n\n**为了考虑工人们，最后要剩下正好 $B$ 个。**\n\n下面给出已知条件，请你帮 LiM 算算最少要工作多长时间吧！", "inputFormat": "\n\n共 $T+1$ 行。\n\n第一行一个数 $T$，表示共要出 $T$ 个 New Product。\n\n第 $2 \\sim T+1$ 行，每行三个数 $P$，$A$，$B$，意义如题。", "outputFormat": "\n对于每个 New Product：\n\n如果可以实现（有可能不行），输出最少工作的分钟数。\n\n如果不行，输出 `Couldn't Produce!`。", "hint": "\n\n#### 样例 $1$ 解释：\n\n有 $5$ 个常客，一分钟可以生产已生产的 $2$ 倍，有 $3$ 个工人。\n\n则最小需要 $3$ 分钟（生产 $2^3=8$ 个）才能符合要求。\n\n#### 样例 $2$ 解释：\n\n有 $2$ 个常客，一分钟可以生产已生产的 $2$ 倍，有 $2$ 个工人。\n\n因为不管是多长时间都会余下 $0$ 个，所以输出 `Couldn't Produce!`。\n\n\n----------------------------------------------\n\n说明：\n\nLiM 不是工人哦！\n\n对于每组 New Product，常客数量不同。\n\n对于 $20\\%$ 的数据，$T=1$，所有条件 $\\leqslant 100$。\n\n对于 $100\\%$ 的数据，$T \\leqslant 5000$，所有条件 $\\leqslant 5 \\times 10^4$。$P$ 为质数。", "locale": "zh-CN", "translations": {"en": {"title": "New Product", "background": "A magical story about doing business...\n\n(Friendly reminder: mind the time limit!).", "description": "LiM owns a handmade pastry shop. Because the pastries are both affordable and delicious, the shop has accumulated $P$ regular customers ($P$ is prime).\n\nEvery time the shop launches a New Product, they make many items. All $P$ customers will support it in this way:\n- Each customer buys the same quantity.\n- They buy as much as possible.\n\nThe shop has $B$ workers. At the end of each minute, the total number of products becomes $A$ times the current total.\n\n(Note: initially, there is one already-made New Product as a sample.)\n\nAfter production is finished and the $P$ regular customers rush to buy (only these regular customers are considered):\n- To take care of the workers, exactly $B$ items must remain.\n\nGiven the known conditions, please help LiM compute the minimal working time.", "inputFormat": "There are $T+1$ lines.\n\nThe first line contains an integer $T$, the number of New Products.\n\nLines $2$ to $T+1$ each contain three integers $P$, $A$, $B$, as described above.", "outputFormat": "For each New Product:\n- If it is achievable, output the minimal number of minutes worked.\n- If it is not achievable, output `Couldn't Produce!`.", "hint": "Sample 1 explanation:\nThere are $5$ regular customers, the total multiplies by $2$ each minute, and there are $3$ workers. The minimum is $3$ minutes (produce $2^3 = 8$ items) to meet the requirement.\n\nSample 2 explanation:\nThere are $2$ regular customers, the total multiplies by $2$ each minute, and there are $2$ workers. Since no matter how long they work the leftover will always be $0$, output `Couldn't Produce!`.\n\nNotes:\n- LiM is not a worker.\n- For each New Product, the number of regular customers may differ.\n\nConstraints:\n- For $20\\%$ of the testdata, $T = 1$ and all values $\\leqslant 100$.\n- For $100\\%$ of the testdata, $T \\leqslant 5000$, all values $\\leqslant 5 \\times 10^4$, and $P$ is prime.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "New Product", "background": "**一个经商的神奇故事……**\n\n(善意提醒：注意时限！）\n", "description": "LiM 有一家手工糕点店，因为糕点既实惠又好吃，于是积累了 $P$ 个常客（$P$ 为质数）。\n\n每次这家店出 New Product（新品）的时候，都会做很多个，这 $P$ 个人都会支持，支持方法是：\n\n**每个人买的数量都相同，而且买的总数要尽量多。**\n\n这家店共有 $B$ 个工人，一分钟可以生产已经生产的数量的 $A$ 倍。\n\n（注：一开始有一个已制作的 New Product 作为制作样品）\n\n而当制作完毕，抢购（只考虑常客）完后：\n\n**为了考虑工人们，最后要剩下正好 $B$ 个。**\n\n下面给出已知条件，请你帮 LiM 算算最少要工作多长时间吧！", "inputFormat": "\n\n共 $T+1$ 行。\n\n第一行一个数 $T$，表示共要出 $T$ 个 New Product。\n\n第 $2 \\sim T+1$ 行，每行三个数 $P$，$A$，$B$，意义如题。", "outputFormat": "\n对于每个 New Product：\n\n如果可以实现（有可能不行），输出最少工作的分钟数。\n\n如果不行，输出 `Couldn't Produce!`。", "hint": "\n\n#### 样例 $1$ 解释：\n\n有 $5$ 个常客，一分钟可以生产已生产的 $2$ 倍，有 $3$ 个工人。\n\n则最小需要 $3$ 分钟（生产 $2^3=8$ 个）才能符合要求。\n\n#### 样例 $2$ 解释：\n\n有 $2$ 个常客，一分钟可以生产已生产的 $2$ 倍，有 $2$ 个工人。\n\n因为不管是多长时间都会余下 $0$ 个，所以输出 `Couldn't Produce!`。\n\n\n----------------------------------------------\n\n说明：\n\nLiM 不是工人哦！\n\n对于每组 New Product，常客数量不同。\n\n对于 $20\\%$ 的数据，$T=1$，所有条件 $\\leqslant 100$。\n\n对于 $100\\%$ 的数据，$T \\leqslant 5000$，所有条件 $\\leqslant 5 \\times 10^4$。$P$ 为质数。", "locale": "zh-CN"}}}
{"pid": "P4029", "type": "P", "difficulty": 4, "samples": [["3 0\nA=?\n?=A+B\nC+O2=?", "A\nAB\nCO2"], ["3 1\nA1=?\nA1+?=B1\nC1+O2=?", "A\nNo Solution\nCO2"], ["1 2\nA0B0C0D0E0F0G0H0I0JK0L0M0N0O0P0QR0S0T0U0V0W0X0Y2Z0=?", "JQY2"], ["2 3\n?=A0B0C0D0E0F0G0H0I0J1K0L0M0N0O0P0Q1R0S0T0U0V0W0X0Y2Z0\nA0B0C0D0E0F0G0H0I0J1K0L0M0N0O0P0Q1R0S0T0U0V0W0X0Y2Z0+A0B0C0D0E0F0G0H0I0J1K0L0M0N0O0P0Q1R0S0T0U0V0W0X0Y2Z0=?", "JQY2\nJ2Q2Y4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["Code+"], "title": "[Code+#2] 化学狂暴", "background": "在那遥远的钦钦草原，住着 Yazid 和 YJQQQAQ，他们都是炼金术士。\n\n\n一般而言，题目背景总是没有用的，但这道题是个例外。在这里，我们将严谨地介绍钦钦草原世界化学学科的一些基本知识。如果你对这些内容感到枯燥乏味，你也可以跳过这个部分，直接阅读题目描述中的简述并结合样例来帮助你更快地理解题目。\n\n\n钦钦草原的世界里共有 $26$ 种元素，分别用大写字母A至Z表示。\n\n\n钦钦草原世界中的物质由元素构成，对于任意的物质，每种元素的出现次数都是非负整数，且至少有 $1$ 种物质的出现次数为正整数，我们把每种元素在物质中的出现次数称作该元素在该物质中的下标。我们可以按A到Z的顺序写下每种元素及其下标来描述一个物质。这是一个例子：`A0B0C0D0E0F0G0H0I0J1K0L0M0N0O0P0Q1R0S0T0U0V0W0X0Y2Z0`。这个例子描述了一种 J、Q 各出现 $1$ 次，Y 出现 $2$ 次的物质。\n\n\n然而，这种描述方法实在是太麻烦了，于是钦钦草原世界中的炼金术士们便尝试简化物质的描述。对于某种物质，我们定义“虚无元素”表示在该物质中下标为 $0$ 的元素，“单一元素”表示在该物质中下标为 $1$ 的元素。针对这两个定义，炼金术士们提出了两种化简方式：\n\n\n省略“虚无元素”：将“虚无元素”的字母和下标省略。如上面的物质可以通过该操作化简为：`J1Q1Y2`。\n\n省略“单一元素”的下标：将“单一元素”的下标省略。如上面的物质可以通过该操作化简为：`A0B0C0D0E0F0G0H0I0JK0L0M0N0O0P0QR0S0T0U0V0W0X0Y2Z0`。\n\n\n特别地，对于同时省略了“虚无元素”和“单一元素”下标的表示，我们把它叫做该物质的“最简式”。如上面物质的“最简式”即为：`JQY2`。\n\n\n由于钦钦草原世界的化学研究仍处于起步阶段，因此对于任意的物质，所有元素下标均为不超过 $9$ 的非负整数。\n\n\n化学方程式是描述化学反应的式子。一个化学方程式包含恰好一个等号（=），等号两边是由加号（+）连接的若干物质。形象地说，它的形式是这样的：\n\n```\n物质+物质+…+物质=物质+物质+…+物质\n```\n除了需要满足上述格式外，元素守恒也是不可忽视的。这表示等号两边所有元素在各物质中的出现次数总和必须相等。比如，这就是一个合法的（格式正确、元素守恒的）化学方程式：\n\n```\nJQY2+J2=J3QY2\n```\n需要特别注意的是，在化学方程式的书写中，未被化至“最简式”的元素也是可以被接受的。例如，下面的化学方程式也是合法的：\n\n```\nJ1Q1Y2+J2=J3Q1Y2\n```\n而下面这个化学方程式就不是合法的了，因为它并没有满足元素守恒。\n\n```\nJQY2+J2=JQY\n```\n钦钦草原化学学科的基本知识就介绍到这。祝各位选手武运昌隆！", "description": "所谓化学方程式，即是用加号（+）和等号（=）连接一些化学物质的式子。保证一个化学方程式中含有恰好一个等号（=）。化学物质由一些元素（用大写字母A至Z表示）加上下标（保证下标为不超过 $9$ 的非负整数）连接而成的。例如：`JQY2`、`A0J1QY2` 等。书写时需要保证字典序越小的字母排在越前面。\n\n\n需要注意的是，像 `A0J1QY2` 这样的物质书写同样是合法的，虽然事实上它和 `JQY2` 是等价的。我们把下标为 $1$ 的元素称为“单一元素”，把下标为 $0$ 的元素称为“虚无元素”。在书写一种物质时，我们既可以省去“单一元素”的下标，又可以直接省去“虚无元素”。特别地，我们把用这两种规则省略至最简的书写称为该物质的“最简式”。例如，`JQY2` 就是 `A0J1Q1Y2` 的最简式。\n\n\n既然称之为“方程式”，元素守恒就是必须的了。对于一个化学方程式，元素守恒指的是指等号两边所有元素的下标之和相等。比如，这个化学方程式就是元素守恒的：\n\n```\nJQY2+J2=J3QY2\n```\n而这个化学方程式就是不合法的，因为它不满足元素守恒：\n\n```\nJQY2+J2=JQY\n```\n作为一名资深炼金术士，Yazid 自然是整日沉迷在化学狂暴中。某一天，Yazid 写下了 $n$ 个化学方程式，并把它们放在一边，为后续的研究做着准备。\n\n\n然而，见习炼金术士 YJQQQAQ 不慎打翻了一瓶绿色的试剂，导致 Yazid 写下的所有化学方程式中，都有恰好 $1$ 个物质被绿色液体弄得模糊不清了。\n\n\n暴怒的 Yazid 狠狠地把 YJQQQAQ 批判了一番，并要求他将所有模糊不清的物质重新写出来。除此之外，作为惩罚，无论原来 Yazid 如何书写这些物质，YJQQQAQ 都必须将它们以“最简式”的形式写出。\n\n\n如果不能完成这些任务，Yazid 就会把他从钦钦草原放逐。面对这么多的化学方程式，弱小、无助的 YJQQQAQ 手足无措，于是他找到了钦钦草原最擅长编程的你，请你帮他完成任务。", "inputFormat": "从标准输入读入数据。\n\n\n第一行 $2$ 个整数 $n,m$，分别表示化学方程式的数目和Yazid的书写习惯。其中，书写习惯 $m$ 是 $0$ 到 $3$ 之间的整数，对于不同的 $m$，Yazid 书写物质的方式不同（这一信息可能对你解决部分测试点有帮助）：\n\n\n如果 $m=0$，则 Yazid 在书写方程式时一定会将所有物质化为“最简式”；\n\n如果 $m=1$，则 Yazid 在书写方程式时一定会将所有物质的“虚无元素”省略，且不会存在“单一元素”的下标被省略；\n\n如果 $m=2$，则 Yazid 在书写方程式时一定会将所有物质“单一元素”的下标省略，且不会存在“虚无元素”被省略；\n\n如果 $m=3$，则 Yazid 在书写方程式时一定不会省略“单一元素”的下标，也一定不会省略“虚无元素”。\n\n\n接下来 $n$ 行，每行一个字符串，描述一个被污染的化学方程式。其中，被污染的物质用?表示，保证对于每一个方程式都会存在恰好 $1$ 个?。\n\n\n数据保证化学方程式严格按照题目背景和题目描述中的格式，且不存在多余的空格或其他字符。", "outputFormat": "输出到标准输出。\n\n\n输出 $n$ 行，每行一个字符串，表示化为“最简式”的?所表示的物质。特别地，对于无解的情况（即?表示的物质超出钦钦草原世界化学学科的研究范围），请输出 `No Solution`。", "hint": "|测试点编号|m|?在方程式最左端|等号左边不含+|等号右边不含+|\n|:-:|:-:|:-:|:-:|:-:|\n|1|0|Yes|Yes|Yes|\n|2|1|Yes|Yes|Yes|\n|3|2|Yes|Yes|Yes|\n|4|3|Yes|Yes|Yes|\n|5|0|Yes|Yes||\n|6|1|Yes|Yes||\n|7|2|Yes|Yes||\n|8|3|Yes|Yes||\n|9|0|Yes||Yes|\n|10|1|Yes||Yes|\n|11|2|Yes||Yes|\n|12|3|Yes||Yes|\n|13|0||||\n|14|1||||\n|15|2||||\n|16|3||||\n|17|0||||\n|18|1||||\n|19|2||||\n|20|3|||\n\n如表格中“?在方程式的最左端”为 `Yes`，则表示该测试点保证每个字符串的第一个字符均为?；否则无特殊保证。\n\n\n如表格中“等号左边不含+”为 `Yes`，则表示该测试点保证等号左边没有加号（+），即等号左边只有一种物质；否则无特殊保证。\n\n\n如表格中“等号右边不含+”为 `Yes`，则表示该测试点保证等号右边没有加号（+），即等号右边只有一种物质；否则无特殊保证。\n\n\n对于所有的测试点，保证 $n\\leq 100$，保证每个方程式中等式两边的加号+都不超过 $5$ 个，这也意味着每行字符串（每个化学方程式）的长度不超过 $635$。\n\n\n来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/王聿中 命题/王聿中 验题/陈宇\n\nGit Repo：[https://git.thusaac.org/publish/CodePlus201712](https://git.thusaac.org/publish/CodePlus201712)\n\n感谢腾讯公司对此次比赛的支持。\n\n感谢 @[ChampionCyan](https://www.luogu.com.cn/user/1036180) 提供了修复后的题面。", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#2] Chemical Rampage", "background": "In the distant Qinqin Grassland, Yazid and YJQQQAQ live there as alchemists.\n\nIn general, problem backgrounds are often useless, but this one is an exception. Here, we will rigorously introduce some basic knowledge of the chemistry discipline in the world of the Qinqin Grassland. If you find this content tedious, you may skip it and directly read the brief description in the problem statement and the samples to help you understand the problem more quickly.\n\nThere are $26$ kinds of elements in the world of the Qinqin Grassland, denoted by uppercase letters A to Z.\n\nSubstances in the Qinqin Grassland are composed of elements. For any substance, the occurrence count of each element is a non-negative integer, and at least one element has a positive count. We call the occurrence count of each element in a substance the subscript (index) of that element in that substance. We can write down each element and its subscript in the order from A to Z to describe a substance. Here is an example: `A0B0C0D0E0F0G0H0I0J1K0L0M0N0O0P0Q1R0S0T0U0V0W0X0Y2Z0`. This example describes a substance where J and Q each appear $1$ time, and Y appears $2$ times.\n\nHowever, this way of describing is too cumbersome, so the alchemists in the Qinqin Grassland tried to simplify substance descriptions. For a given substance, we define “null elements” as elements with subscript $0$ in this substance, and “unit elements” as elements with subscript $1$ in this substance. Based on these two definitions, the alchemists proposed two simplification methods:\n\nOmit “null elements”: remove the letters and subscripts of “null elements”. The substance above can be simplified to: `J1Q1Y2`.\n\nOmit the subscripts of “unit elements”: remove the subscripts of “unit elements”. The substance above can be simplified to: `A0B0C0D0E0F0G0H0I0JK0L0M0N0O0P0QR0S0T0U0V0W0X0Y2Z0`.\n\nIn particular, when both the “null elements” and the subscripts of “unit elements” are omitted, we call it the “minimal form” of the substance. For the substance above, its “minimal form” is: `JQY2`.\n\nSince the chemical research in the Qinqin Grassland is still in its infancy, for any substance, all element subscripts are non-negative integers not exceeding $9$.\n\nA chemical equation describes a chemical reaction. A chemical equation contains exactly one equals sign (=), and each side of the equals sign is a number of substances connected by plus signs (+). Informally, it looks like this:\n\n```\nSubstance+Substance+…+Substance=Substance+Substance+…+Substance\n```\nIn addition to satisfying the above format, conservation of elements must not be ignored. This means the total occurrence counts of all elements on both sides of the equals sign must be equal across all substances. For example, this is a valid (format-correct and element-conserving) chemical equation:\n\n```\nJQY2+J2=J3QY2\n```\nIt is especially important to note that, in writing chemical equations, elements not reduced to the “minimal form” are also acceptable. For example, the following chemical equation is also valid:\n\n```\nJ1Q1Y2+J2=J3Q1Y2\n```\nHowever, the following chemical equation is not valid, because it does not satisfy conservation of elements.\n\n```\nJQY2+J2=JQY\n```\nThat concludes the basic knowledge of chemistry in the Qinqin Grassland. Good luck to all contestants!", "description": "A chemical equation is an expression that connects several chemical substances with plus signs (+) and an equals sign (=). It is guaranteed that a chemical equation contains exactly one equals sign (=). A chemical substance is formed by several elements (denoted by uppercase letters A to Z) concatenated with subscripts (subscripts are non-negative integers not exceeding $9$). For example: `JQY2`, `A0J1QY2`. When writing, you must ensure that letters with smaller lexicographic order appear earlier.\n\nNote that a substance like `A0J1QY2` is also valid, although it is in fact equivalent to `JQY2`. We call elements with subscript $1$ “unit elements”, and elements with subscript $0$ “null elements”. When writing a substance, you may omit the subscript of “unit elements”, and you may directly omit “null elements”. In particular, we call the writing minimized by these two rules the “minimal form” of the substance. For example, `JQY2` is the minimal form of `A0J1Q1Y2`.\n\nSince it is called an “equation”, conservation of elements is required. For a chemical equation, conservation of elements means the sums of subscripts of all elements on the two sides of the equals sign are equal. For example, this chemical equation conserves elements:\n\n```\nJQY2+J2=J3QY2\n```\nThis chemical equation is invalid because it does not satisfy conservation of elements:\n\n```\nJQY2+J2=JQY\n```\nAs a seasoned alchemist, Yazid is naturally obsessed with chemical rampage all day long. One day, Yazid wrote down $n$ chemical equations and set them aside for later research.\n\nHowever, the apprentice alchemist YJQQQAQ accidentally knocked over a bottle of green reagent, causing exactly $1$ substance in each of Yazid’s chemical equations to be blurred.\n\nThe enraged Yazid harshly criticized YJQQQAQ and demanded that he rewrite all the blurred substances. Moreover, as punishment, regardless of how Yazid originally wrote those substances, YJQQQAQ must write them in their “minimal form”.\n\nIf he cannot complete these tasks, Yazid will banish him from the Qinqin Grassland. Faced with so many chemical equations, the weak and helpless YJQQQAQ was at a loss, so he found you, the best programmer in the Qinqin Grassland, to help him complete the task.", "inputFormat": "Read from standard input.\n\nThe first line contains $2$ integers $n, m$, representing the number of chemical equations and Yazid’s writing habit, respectively. The writing habit $m$ is an integer from $0$ to $3$. For different $m$, Yazid writes substances differently (this information may help you on some test points):\n\nIf $m=0$, then when writing equations, Yazid will always reduce all substances to their “minimal form”.\n\nIf $m=1$, then when writing equations, Yazid will always omit all “null elements”, and the subscripts of “unit elements” will not be omitted.\n\nIf $m=2$, then when writing equations, Yazid will always omit the subscripts of all “unit elements”, and no “null elements” will be omitted.\n\nIf $m=3$, then when writing equations, Yazid will neither omit the subscripts of “unit elements” nor omit “null elements”.\n\nThe next $n$ lines each contain one string describing a polluted chemical equation. The blurred substance is denoted by ?, and it is guaranteed that for each equation there is exactly $1$ ?.\n\nThe testdata guarantees that chemical equations strictly follow the format described in the Background and Description, and there are no extra spaces or other characters.", "outputFormat": "Output to standard output.\n\nOutput $n$ lines, each containing a string that is the “minimal form” of the substance represented by ?. In particular, for cases with no solution (i.e., the substance represented by ? is beyond the scope of the chemistry discipline of the Qinqin Grassland), output `No Solution`.", "hint": "|Testpoint ID|m|? at the very left|No + on the left of =|No + on the right of =|\n|:-:|:-:|:-:|:-:|:-:|\n|1|0|Yes|Yes|Yes|\n|2|1|Yes|Yes|Yes|\n|3|2|Yes|Yes|Yes|\n|4|3|Yes|Yes|Yes|\n|5|0|Yes|Yes||\n|6|1|Yes|Yes||\n|7|2|Yes|Yes||\n|8|3|Yes|Yes||\n|9|0|Yes||Yes|\n|10|1|Yes||Yes|\n|11|2|Yes||Yes|\n|12|3|Yes||Yes|\n|13|0||||\n|14|1||||\n|15|2||||\n|16|3||||\n|17|0||||\n|18|1||||\n|19|2||||\n|20|3|||\n\nIf “? at the very left” is `Yes` in the table, then each string in that testpoint is guaranteed to have ? as its first character; otherwise there is no special guarantee.\n\nIf “No + on the left of =” is `Yes` in the table, then each testpoint is guaranteed to have no plus sign (+) on the left side of the equals sign, i.e., there is only one substance on the left; otherwise there is no special guarantee.\n\nIf “No + on the right of =” is `Yes` in the table, then each testpoint is guaranteed to have no plus sign (+) on the right side of the equals sign, i.e., there is only one substance on the right; otherwise there is no special guarantee.\n\nFor all test points, it is guaranteed that $n \\le 100$, and the number of plus signs (+) on each side of the equation does not exceed $5$. This also implies that the length of each line (each chemical equation) does not exceed $635$.\n\nFrom CodePlus 2017 December Contest, proudly presented by the Student Algorithms and Competition Association of the Department of Computer Science and Technology, Tsinghua University.\n\nCredit: idea/Wang Yuzhong, problem setting/Wang Yuzhong, verification/Chen Yu.\n\nGit Repo: [https://git.thusaac.org/publish/CodePlus201712](https://git.thusaac.org/publish/CodePlus201712)\n\nThanks to Tencent for supporting this contest.\n\nThanks to @[ChampionCyan](https://www.luogu.com.cn/user/1036180) for providing the fixed statement.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#2] 化学狂暴", "background": "在那遥远的钦钦草原，住着 Yazid 和 YJQQQAQ，他们都是炼金术士。\n\n\n一般而言，题目背景总是没有用的，但这道题是个例外。在这里，我们将严谨地介绍钦钦草原世界化学学科的一些基本知识。如果你对这些内容感到枯燥乏味，你也可以跳过这个部分，直接阅读题目描述中的简述并结合样例来帮助你更快地理解题目。\n\n\n钦钦草原的世界里共有 $26$ 种元素，分别用大写字母A至Z表示。\n\n\n钦钦草原世界中的物质由元素构成，对于任意的物质，每种元素的出现次数都是非负整数，且至少有 $1$ 种物质的出现次数为正整数，我们把每种元素在物质中的出现次数称作该元素在该物质中的下标。我们可以按A到Z的顺序写下每种元素及其下标来描述一个物质。这是一个例子：`A0B0C0D0E0F0G0H0I0J1K0L0M0N0O0P0Q1R0S0T0U0V0W0X0Y2Z0`。这个例子描述了一种 J、Q 各出现 $1$ 次，Y 出现 $2$ 次的物质。\n\n\n然而，这种描述方法实在是太麻烦了，于是钦钦草原世界中的炼金术士们便尝试简化物质的描述。对于某种物质，我们定义“虚无元素”表示在该物质中下标为 $0$ 的元素，“单一元素”表示在该物质中下标为 $1$ 的元素。针对这两个定义，炼金术士们提出了两种化简方式：\n\n\n省略“虚无元素”：将“虚无元素”的字母和下标省略。如上面的物质可以通过该操作化简为：`J1Q1Y2`。\n\n省略“单一元素”的下标：将“单一元素”的下标省略。如上面的物质可以通过该操作化简为：`A0B0C0D0E0F0G0H0I0JK0L0M0N0O0P0QR0S0T0U0V0W0X0Y2Z0`。\n\n\n特别地，对于同时省略了“虚无元素”和“单一元素”下标的表示，我们把它叫做该物质的“最简式”。如上面物质的“最简式”即为：`JQY2`。\n\n\n由于钦钦草原世界的化学研究仍处于起步阶段，因此对于任意的物质，所有元素下标均为不超过 $9$ 的非负整数。\n\n\n化学方程式是描述化学反应的式子。一个化学方程式包含恰好一个等号（=），等号两边是由加号（+）连接的若干物质。形象地说，它的形式是这样的：\n\n```\n物质+物质+…+物质=物质+物质+…+物质\n```\n除了需要满足上述格式外，元素守恒也是不可忽视的。这表示等号两边所有元素在各物质中的出现次数总和必须相等。比如，这就是一个合法的（格式正确、元素守恒的）化学方程式：\n\n```\nJQY2+J2=J3QY2\n```\n需要特别注意的是，在化学方程式的书写中，未被化至“最简式”的元素也是可以被接受的。例如，下面的化学方程式也是合法的：\n\n```\nJ1Q1Y2+J2=J3Q1Y2\n```\n而下面这个化学方程式就不是合法的了，因为它并没有满足元素守恒。\n\n```\nJQY2+J2=JQY\n```\n钦钦草原化学学科的基本知识就介绍到这。祝各位选手武运昌隆！", "description": "所谓化学方程式，即是用加号（+）和等号（=）连接一些化学物质的式子。保证一个化学方程式中含有恰好一个等号（=）。化学物质由一些元素（用大写字母A至Z表示）加上下标（保证下标为不超过 $9$ 的非负整数）连接而成的。例如：`JQY2`、`A0J1QY2` 等。书写时需要保证字典序越小的字母排在越前面。\n\n\n需要注意的是，像 `A0J1QY2` 这样的物质书写同样是合法的，虽然事实上它和 `JQY2` 是等价的。我们把下标为 $1$ 的元素称为“单一元素”，把下标为 $0$ 的元素称为“虚无元素”。在书写一种物质时，我们既可以省去“单一元素”的下标，又可以直接省去“虚无元素”。特别地，我们把用这两种规则省略至最简的书写称为该物质的“最简式”。例如，`JQY2` 就是 `A0J1Q1Y2` 的最简式。\n\n\n既然称之为“方程式”，元素守恒就是必须的了。对于一个化学方程式，元素守恒指的是指等号两边所有元素的下标之和相等。比如，这个化学方程式就是元素守恒的：\n\n```\nJQY2+J2=J3QY2\n```\n而这个化学方程式就是不合法的，因为它不满足元素守恒：\n\n```\nJQY2+J2=JQY\n```\n作为一名资深炼金术士，Yazid 自然是整日沉迷在化学狂暴中。某一天，Yazid 写下了 $n$ 个化学方程式，并把它们放在一边，为后续的研究做着准备。\n\n\n然而，见习炼金术士 YJQQQAQ 不慎打翻了一瓶绿色的试剂，导致 Yazid 写下的所有化学方程式中，都有恰好 $1$ 个物质被绿色液体弄得模糊不清了。\n\n\n暴怒的 Yazid 狠狠地把 YJQQQAQ 批判了一番，并要求他将所有模糊不清的物质重新写出来。除此之外，作为惩罚，无论原来 Yazid 如何书写这些物质，YJQQQAQ 都必须将它们以“最简式”的形式写出。\n\n\n如果不能完成这些任务，Yazid 就会把他从钦钦草原放逐。面对这么多的化学方程式，弱小、无助的 YJQQQAQ 手足无措，于是他找到了钦钦草原最擅长编程的你，请你帮他完成任务。", "inputFormat": "从标准输入读入数据。\n\n\n第一行 $2$ 个整数 $n,m$，分别表示化学方程式的数目和Yazid的书写习惯。其中，书写习惯 $m$ 是 $0$ 到 $3$ 之间的整数，对于不同的 $m$，Yazid 书写物质的方式不同（这一信息可能对你解决部分测试点有帮助）：\n\n\n如果 $m=0$，则 Yazid 在书写方程式时一定会将所有物质化为“最简式”；\n\n如果 $m=1$，则 Yazid 在书写方程式时一定会将所有物质的“虚无元素”省略，且不会存在“单一元素”的下标被省略；\n\n如果 $m=2$，则 Yazid 在书写方程式时一定会将所有物质“单一元素”的下标省略，且不会存在“虚无元素”被省略；\n\n如果 $m=3$，则 Yazid 在书写方程式时一定不会省略“单一元素”的下标，也一定不会省略“虚无元素”。\n\n\n接下来 $n$ 行，每行一个字符串，描述一个被污染的化学方程式。其中，被污染的物质用?表示，保证对于每一个方程式都会存在恰好 $1$ 个?。\n\n\n数据保证化学方程式严格按照题目背景和题目描述中的格式，且不存在多余的空格或其他字符。", "outputFormat": "输出到标准输出。\n\n\n输出 $n$ 行，每行一个字符串，表示化为“最简式”的?所表示的物质。特别地，对于无解的情况（即?表示的物质超出钦钦草原世界化学学科的研究范围），请输出 `No Solution`。", "hint": "|测试点编号|m|?在方程式最左端|等号左边不含+|等号右边不含+|\n|:-:|:-:|:-:|:-:|:-:|\n|1|0|Yes|Yes|Yes|\n|2|1|Yes|Yes|Yes|\n|3|2|Yes|Yes|Yes|\n|4|3|Yes|Yes|Yes|\n|5|0|Yes|Yes||\n|6|1|Yes|Yes||\n|7|2|Yes|Yes||\n|8|3|Yes|Yes||\n|9|0|Yes||Yes|\n|10|1|Yes||Yes|\n|11|2|Yes||Yes|\n|12|3|Yes||Yes|\n|13|0||||\n|14|1||||\n|15|2||||\n|16|3||||\n|17|0||||\n|18|1||||\n|19|2||||\n|20|3|||\n\n如表格中“?在方程式的最左端”为 `Yes`，则表示该测试点保证每个字符串的第一个字符均为?；否则无特殊保证。\n\n\n如表格中“等号左边不含+”为 `Yes`，则表示该测试点保证等号左边没有加号（+），即等号左边只有一种物质；否则无特殊保证。\n\n\n如表格中“等号右边不含+”为 `Yes`，则表示该测试点保证等号右边没有加号（+），即等号右边只有一种物质；否则无特殊保证。\n\n\n对于所有的测试点，保证 $n\\leq 100$，保证每个方程式中等式两边的加号+都不超过 $5$ 个，这也意味着每行字符串（每个化学方程式）的长度不超过 $635$。\n\n\n来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/王聿中 命题/王聿中 验题/陈宇\n\nGit Repo：[https://git.thusaac.org/publish/CodePlus201712](https://git.thusaac.org/publish/CodePlus201712)\n\n感谢腾讯公司对此次比赛的支持。\n\n感谢 @[ChampionCyan](https://www.luogu.com.cn/user/1036180) 提供了修复后的题面。", "locale": "zh-CN"}}}
{"pid": "P4030", "type": "P", "difficulty": 4, "samples": [["3 3 4\n1 1 1\n1 1 1\n1 1 2\n1 1 2\n1 1 3\n2 2 2\n2 1 2", "Y\nN\nN\nY"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["Code+"], "title": "[Code+#2] 可做题1", "background": "“codeplus比赛的时候在做什么？有没有空？能来解决停机问题吗？”qmqmqm这样问sublinekelzrip。\n\n\n当然，sublinekelzrip并不会停机问题，所以qmqmqm改为提出了另一个题目，现在请你帮助sublinekelzrip解决这个题目。\n", "description": "这个问题是这样的：\n\n\n对于任何一个$n$阶方阵，若任意从其中选择$n$个不同行不同列的位置，其上的权值之和均相等，则我们称这个矩阵是巧妙的。注意对于$n=1$的任何矩阵都是巧妙的。 例如矩阵：\n\n```cpp\n1 2 3\n4 5 6\n7 8 9\n```\n是巧妙的，因为$1+5+9=1+6+8=2+4+9=2+6+7=3+5+7=3+4+8=15$。\n\n而矩阵：\n\n```cpp\n1 2\n2 1\n```\n不巧妙，因为$1+1 \\neq 2+2$。\n\n现在有一个$n \\times m$大小的矩阵$M$以及$T$个询问，每次询问其一个子方阵是否是巧妙的。\n", "inputFormat": "从标准输入读入数据。\n\n\n输入第一行包含三个正整数$n,m,T$。\n\n\n之后$n$行每行$m$个空格分割的非负整数，表示矩阵$M$。\n\n\n之后$T$行每行$3$个正整数$x,y,k$,表示询问第$x$行第$y$列为左上角的$k$阶方阵是否是巧妙的。保证这个矩阵完全位于$M$之中。\n", "outputFormat": "输出到标准输出。\n\n\n输出包含$T$行每行一个字符Y或者N。Y表示被询问的方阵是巧妙的，N表示不是。\n", "hint": " ![](https://cdn.luogu.com.cn/upload/pic/12654.png) \n\n对于所有的数据，$0 \\leq M_{ij} \\leq 10^9$，$1 \\leq x \\leq n$，$1 \\leq y \\leq m$。\n\n\n来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/卢政荣 命题/卢政荣 验题/吕时清，王聿中\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201712\n\n感谢腾讯公司对此次比赛的支持。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#2] Doable Problem 1", "background": "“During the CodePlus contest, what are you doing? Are you free? Can you come solve the Halting Problem?” qmqmqm asked sublinekelzrip.\n\nOf course, sublinekelzrip cannot solve the Halting Problem, so qmqmqm proposed another problem instead. Now please help sublinekelzrip solve this problem.", "description": "The problem is as follows:\n\nFor any $n$-by-$n$ matrix, if for any selection of $n$ positions with no two in the same row or column, the sum of the values on those positions is always the same, then we call this matrix “clever.” Note that any matrix with $n = 1$ is clever. For example, the matrix:\n\n```cpp\n1 2 3\n4 5 6\n7 8 9\n```\nis clever because $1+5+9=1+6+8=2+4+9=2+6+7=3+5+7=3+4+8=15$.\n\nThe matrix:\n\n```cpp\n1 2\n2 1\n```\nis not clever because $1+1 \\neq 2+2$.\n\nNow you are given an $n \\times m$ matrix $M$ and $T$ queries. Each query asks whether a subsquare is clever.", "inputFormat": "Read from standard input.\n\nThe first line contains three positive integers $n, m, T$.\n\nThe next $n$ lines each contain $m$ space-separated non-negative integers, representing the matrix $M$.\n\nThe next $T$ lines each contain three positive integers $x, y, k$, indicating the $k$-by-$k$ square whose top-left corner is at row $x$, column $y$. It is guaranteed that this square lies entirely within $M$.", "outputFormat": "Output to standard output.\n\nPrint $T$ lines, each containing a single character Y or N. Y means the queried square is clever, and N means it is not.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/12654.png)\n\nConstraints: For all the testdata, $0 \\leq M_{ij} \\leq 10^9$, $1 \\leq x \\leq n$, $1 \\leq y \\leq m$.\n\nFrom CodePlus 2017 December Contest, proudly presented by the Student Association for Algorithms and Programming Contest, Department of Computer Science and Technology, Tsinghua University.\n\nCredit: idea/卢政荣 命题/卢政荣 验题/吕时清，王聿中.\n\nGit Repo: https://git.thusaac.org/publish/CodePlus201712\n\nThanks to Tencent for supporting this contest.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#2] 可做题1", "background": "“codeplus比赛的时候在做什么？有没有空？能来解决停机问题吗？”qmqmqm这样问sublinekelzrip。\n\n\n当然，sublinekelzrip并不会停机问题，所以qmqmqm改为提出了另一个题目，现在请你帮助sublinekelzrip解决这个题目。\n", "description": "这个问题是这样的：\n\n\n对于任何一个$n$阶方阵，若任意从其中选择$n$个不同行不同列的位置，其上的权值之和均相等，则我们称这个矩阵是巧妙的。注意对于$n=1$的任何矩阵都是巧妙的。 例如矩阵：\n\n```cpp\n1 2 3\n4 5 6\n7 8 9\n```\n是巧妙的，因为$1+5+9=1+6+8=2+4+9=2+6+7=3+5+7=3+4+8=15$。\n\n而矩阵：\n\n```cpp\n1 2\n2 1\n```\n不巧妙，因为$1+1 \\neq 2+2$。\n\n现在有一个$n \\times m$大小的矩阵$M$以及$T$个询问，每次询问其一个子方阵是否是巧妙的。\n", "inputFormat": "从标准输入读入数据。\n\n\n输入第一行包含三个正整数$n,m,T$。\n\n\n之后$n$行每行$m$个空格分割的非负整数，表示矩阵$M$。\n\n\n之后$T$行每行$3$个正整数$x,y,k$,表示询问第$x$行第$y$列为左上角的$k$阶方阵是否是巧妙的。保证这个矩阵完全位于$M$之中。\n", "outputFormat": "输出到标准输出。\n\n\n输出包含$T$行每行一个字符Y或者N。Y表示被询问的方阵是巧妙的，N表示不是。\n", "hint": " ![](https://cdn.luogu.com.cn/upload/pic/12654.png) \n\n对于所有的数据，$0 \\leq M_{ij} \\leq 10^9$，$1 \\leq x \\leq n$，$1 \\leq y \\leq m$。\n\n\n来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/卢政荣 命题/卢政荣 验题/吕时清，王聿中\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201712\n\n感谢腾讯公司对此次比赛的支持。\n", "locale": "zh-CN"}}}
{"pid": "P4031", "type": "P", "difficulty": 5, "samples": [["6\n2 17 68 3 23 1\n1 17 68 3 57 1\n5 17 68 10 11 9\n5 17 68 10 71 9\n10 17 68 11 12 3\n10 17 68 8 6 4", "3\n1\n4\n1\n5\n9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["矩阵加速", "扩展欧几里德算法", "Code+"], "title": "[Code+#2] 可做题2", "background": "“codeplus比赛的时候在做什么？有没有空？能来解决丢番图方程问题吗？”sublinekelzrip这样问qmqmqm。\n\n\n当然，qmqmqm并不会丢番图方程问题，所以sublinekelzrip改为提出了另一个题目，现在请你帮助qmqmqm解决这个题目。\n", "description": "这个问题是这样的：\n\n\n若一个数列$a$满足条件$a_n=a_{n-1}+a_{n-2}$,$n \\geq 3$,而$a_1,a_2$为任意实数，则我们称这个数列为广义斐波那契数列。\n\n\n现在请你求出满足条件$a_1=i$，$a_2$为区间$[l,r]$中的整数，且$a_k mod p = m$的广义斐波那契数列有多少个。\n", "inputFormat": "从标准输入读入数据。\n\n\n本题包含多组数据，输入第一行包含一个正整数$T$，表示数据组数。对于每组数据：\n\n\n一行六个用空格隔开的整数$i,l,r,k,p,m$，意义如「题目描述」所示。\n", "outputFormat": "输出到标准输出。\n\n\n输出共$T$行，每行一个数表示该组数据的答案。\n", "hint": " ![](https://cdn.luogu.com.cn/upload/pic/12655.png) \n\n对于所有数据，$0 \\leq l \\leq r$,$1 \\leq p \\leq 10^9$,$0 \\leq m < p$,$T=10$,$0 \\leq i \\leq 10^{18},k \\geq 3$。\n\n\n来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/卢政荣 命题/卢政荣 验题/吕时清，茹逸中，王聿中\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201712\n\n感谢腾讯公司对此次比赛的支持。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#2] Solvable Problem 2", "background": "\"What are you doing during the CodePlus contest? Are you free? Can you come solve a Diophantine equation problem?\" sublinekelzrip asked qmqmqm.\n\nOf course, qmqmqm could not solve a Diophantine equation problem, so sublinekelzrip instead proposed another problem. Now please help qmqmqm solve this one.", "description": "The problem is as follows:\n\nA sequence $a$ is called a generalized Fibonacci sequence if it satisfies $a_n = a_{n-1} + a_{n-2}$ for $n \\ge 3$, and $a_1, a_2$ are arbitrary real numbers.\n\nNow please count how many generalized Fibonacci sequences satisfy $a_1 = i$, $a_2$ is an integer in the interval $[l, r]$, and $a_k \\bmod p = m$.", "inputFormat": "Read from standard input.\n\nThis problem contains multiple test cases. The first line contains a positive integer $T$, the number of test cases. For each test case:\n\nOne line with six space-separated integers: i, l, r, k, p, m, whose meanings are as defined in the Description.", "outputFormat": "Write to standard output.\n\nOutput $T$ lines. Each line contains a single number, the answer for that test case.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/12655.png)\n\nConstraints:\nFor all testdata, $0 \\le l \\le r$, $1 \\le p \\le 10^9$, $0 \\le m < p$, $T = 10$, $0 \\le i \\le 10^{18}$, $k \\ge 3$.\n\nFrom the CodePlus 2017 December Contest, proudly presented by the Student Association for Algorithms and Programming Competitions, Department of Computer Science and Technology, Tsinghua University.\n\nCredit: idea/卢政荣 (Lu Zhengrong), problem setting/卢政荣 (Lu Zhengrong), verification/吕时清 (Lü Shiqing), 茹逸中 (Ru Yizhong), 王聿中 (Wang Yuzhong).\n\nGit repo: https://git.thusaac.org/publish/CodePlus201712\n\nWe thank Tencent for supporting this contest.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#2] 可做题2", "background": "“codeplus比赛的时候在做什么？有没有空？能来解决丢番图方程问题吗？”sublinekelzrip这样问qmqmqm。\n\n\n当然，qmqmqm并不会丢番图方程问题，所以sublinekelzrip改为提出了另一个题目，现在请你帮助qmqmqm解决这个题目。\n", "description": "这个问题是这样的：\n\n\n若一个数列$a$满足条件$a_n=a_{n-1}+a_{n-2}$,$n \\geq 3$,而$a_1,a_2$为任意实数，则我们称这个数列为广义斐波那契数列。\n\n\n现在请你求出满足条件$a_1=i$，$a_2$为区间$[l,r]$中的整数，且$a_k mod p = m$的广义斐波那契数列有多少个。\n", "inputFormat": "从标准输入读入数据。\n\n\n本题包含多组数据，输入第一行包含一个正整数$T$，表示数据组数。对于每组数据：\n\n\n一行六个用空格隔开的整数$i,l,r,k,p,m$，意义如「题目描述」所示。\n", "outputFormat": "输出到标准输出。\n\n\n输出共$T$行，每行一个数表示该组数据的答案。\n", "hint": " ![](https://cdn.luogu.com.cn/upload/pic/12655.png) \n\n对于所有数据，$0 \\leq l \\leq r$,$1 \\leq p \\leq 10^9$,$0 \\leq m < p$,$T=10$,$0 \\leq i \\leq 10^{18},k \\geq 3$。\n\n\n来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/卢政荣 命题/卢政荣 验题/吕时清，茹逸中，王聿中\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201712\n\n感谢腾讯公司对此次比赛的支持。\n", "locale": "zh-CN"}}}
{"pid": "P4032", "type": "P", "difficulty": 5, "samples": [["1\n2\n1 100\n10\n1 0 2\n2 0 1\n3 2 1\n4 2 2\n5 2 1\n200 0 1\n201 3 1 2\n202 1\n203 1\n204 1", "Succeeded!\n97\nYJQQQAQ is angry.\n2\n1\n2\nYazid is angry."]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["线段树", "树状数组", "优先队列", "队列", "Code+"], "title": "[Code+#2] 火锅盛宴", "background": "SkyDec 和 YJQQQAQ 都是 Yazid 的好朋友。他们都非常喜欢吃火锅。有一天，他们聚在一起，享受一场火锅盛宴。", "description": "在这场火锅盛宴中，有一个麻辣浓汤锅底的火锅和 $n$ 种食物，每种食物数量都是无限的。我们用 $1$ 至 $n$ 将这些食材编号。\n\n每种食物煮熟所需要的时间不同，第 $i$ 种食物煮熟需要 $s_i$ 单位时间。这表示如果你在第 $T$ 个时刻将一个食物 $i$ 下到火锅里，那么它会在第 $T+s_i$ 个时刻被煮熟，并且此后一直会延续被煮熟的状态，直到它被拿走为止。\n\nYazid 和 YJQQQAQ 的口味不同：YJQQQAQ 觉得所有食物的好吃程度都是相同的；而 Yazid 则觉得没有两种食材的好吃程度是相同的，并且，巧合的是，编号越小的食物 Yazid 越喜欢吃。可怜的 SkyDec 由于不能吃辣，所以只能帮 Yazid 和 YJQQQAQ 煮食物。\n\n整个火锅盛宴持续 $10^9$ 单位时间。在整个盛宴中，三位好朋友除了谈笑风生之外，最重要的事当然就是吃东西了。在任意整数时刻，都有可能发生下列 $4$ 种事件中的任意一种，我们用 $0$ 至 $3$ 之间的整数 $op$ 描述事件类型：\n\n- $0\\ id$：表示 SkyDec 往火锅里下了一个编号为 $id$ 的食物。\n- $1$：Yazid 在锅内搜寻熟了的且最喜欢吃的食物，并拿走一个这种食物。特别地，如果锅里没有熟了的食物，那么 Yazid 会很愤怒。\n- $2\\ id$：YJQQQAQ 在锅内搜寻编号为 $id$ 的食物：\n   - 如果锅里不存在该种食物，则 YJQQQAQ 会很愤怒；\n   - 如果锅里存在熟了的该食物，则 YJQQQAQ 会取走一个并食用；\n   - 如果锅里只有未煮熟的该种食物，那么 YJQQQAQ 会希望知道最接近煮熟的该种食物（即锅内存在时间最长的该种食物）还需要多少时间被煮熟。\n- $3\\ l\\ r$：馋涎欲滴的 SkyDec 想知道，锅里编号在 $[l,r]$ 之间的且熟了的食物总共有多少个。", "inputFormat": "从标准输入读入数据。\n\n本题包含多组数据，输入的第一行为一个正整数 $T$，表示数据组数。接下来依次描述每组数据，对于每组数据：\n\n第一行一个正整数 $n$，表示食物的种类数。\n\n第二行 $n$ 个用空格隔开的正整数 $s_1,s_2,\\cdots, s_n$，描述每种食物煮熟需要的时间。\n\n第三行一个正整数 $Q$，表示事件的数目。\n\n接下来 $Q$ 行，每行若干个用空格隔开的非负整数，描述一个事件。先是两个整数 $t,op$，分别表示发生事件的时间以及事件的类型。\n\n- 如果 $op=0$ 或 $op=2$，则接下来 $1$ 个正整数 $id$，意义见题目描述；\n- 如果 $op=1$，则接下来没有其他数；\n- 如果 $op=3$，则接下来 $2$ 个正整数 $l,r$，意义见题目描述。\n\n数据保证 $t$ 按输入顺序严格递增。\n", "outputFormat": "对于每个 $op\\neq 0$ 的操作，输出一行表示答案。对于不同的 $op$，需要输出的内容如下：\n\n- 对于 $op=1$，如果 Yazid 成功取走食物，则输出他取走食物的编号；否则输出 $\\text{``\\texttt{Yazid is angry.}''}\\!\\!$（不含引号，下同）。\n- 对于 $op=2$，如果 YJQQQAQ 成功取走食物，则输出 $\\!\\!\\text{``\\texttt{Succeeded!}''}\\!\\!$；否则，如果锅里有未煮熟的该类食物，输出最接近煮熟的该种食物还需要多少时间被煮熟；否则，输出 $\\!\\!\\text{``\\texttt{YJQQQAQ is angry.}''}\\!$。\n- 对于 $op=3$，输出锅内编号在指定范围内的熟食的数量。", "hint": "对于所有数据，保证$ T\\leq 4$，保证 $n\\leq 100,000$，$Q\\leq 500,000$，$1\\leq s_i\\leq 10^8$，$1\\leq t\\leq 10^9$，$op\\in\\{0, 1, 2, 3\\}$，$1\\leq id\\leq n$，$1\\leq l\\leq r\\leq n$。数据保证 $t$ 按输入顺序严格递增。\n\n来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/王聿中 命题/王聿中 验题/吕时清，杨景钦\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201712\n\n感谢腾讯公司对此次比赛的支持。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#2] Hotpot Feast", "background": "SkyDec and YJQQQAQ are both good friends of Yazid. They all love eating hotpot. One day, they get together to enjoy a hotpot feast.", "description": "In this hotpot feast, there is one spicy rich-broth hotpot and $n$ types of food, each available in unlimited quantity. We number the foods from $1$ to $n$.\n\nEach type takes a different amount of time to cook. The $i$-th type takes $s_i$ units of time to get cooked. This means if you put a food $i$ into the pot at time $T$, it will be cooked at time $T+s_i$, and thereafter it will remain cooked until it is taken out.\n\nYazid and YJQQQAQ have different tastes: YJQQQAQ thinks all foods are equally tasty; Yazid thinks no two types have the same tastiness, and, coincidentally, the smaller the id, the more Yazid likes it. Poor SkyDec cannot eat spicy food, so he can only help Yazid and YJQQQAQ cook.\n\nThe whole feast lasts $10^9$ units of time. Throughout the feast, besides chatting and laughing, the most important thing is of course eating. At any integer time, any one of the following $4$ types of events may occur. We use an integer $op$ between $0$ and $3$ to denote the event type:\n\n- $0\\ id$: SkyDec puts one food with id $id$ into the hotpot.\n- $1$: Yazid searches the pot for a cooked food that he likes the most and takes one of that type. In particular, if there is no cooked food in the pot, Yazid will be angry.\n- $2\\ id$: YJQQQAQ searches the pot for food with id $id$:\n  - If there is no such food in the pot, YJQQQAQ will be angry;\n  - If there is a cooked one of that type, YJQQQAQ will take one and eat it;\n  - If only uncooked ones of that type are in the pot, YJQQQAQ wants to know how much longer it will take for the one closest to being cooked (i.e., the one that has been in the pot the longest) to get cooked.\n- $3\\ l\\ r$: The mouthwatering SkyDec wants to know how many cooked foods with ids in $[l,r]$ are currently in the pot.", "inputFormat": "Read from standard input.\n\nThis problem contains multiple testcases. The first line contains a positive integer $T$, the number of testcases. Then for each testcase:\n\nThe first line contains a positive integer $n$, the number of food types.\n\nThe second line contains $n$ space-separated positive integers $s_1,s_2,\\cdots,s_n$, the cooking time required for each type.\n\nThe third line contains a positive integer $Q$, the number of events.\n\nThen follow $Q$ lines, each containing several space-separated nonnegative integers describing one event. Each line starts with two integers $t,op$, denoting the time the event occurs and the event type, respectively.\n\n- If $op=0$ or $op=2$, then one positive integer $id$ follows, as described above;\n- If $op=1$, then nothing else follows;\n- If $op=3$, then two positive integers $l,r$ follow, as described above.\n\nIt is guaranteed that $t$ is strictly increasing in the order of input.", "outputFormat": "For each operation with $op\\neq 0$, output one line with the answer. For different values of $op$, output as follows:\n\n- For $op=1$, if Yazid successfully takes a food, output the id of the food he takes; otherwise output $\\text{``\\texttt{Yazid is angry.}''}\\!\\!$.\n- For $op=2$, if YJQQQAQ successfully takes a food, output $\\!\\!\\text{``\\texttt{Succeeded!}''}\\!\\!$; otherwise, if there is an uncooked food of that type in the pot, output how much longer it will take for the closest-to-cooked one of that type to get cooked; otherwise, output $\\!\\!\\text{``\\texttt{YJQQQAQ is angry.}''}\\!$.\n- For $op=3$, output the number of cooked foods in the pot whose ids are within the specified range.", "hint": "For all testdata, it is guaranteed that $T\\leq 4$, $n\\leq 100,000$, $Q\\leq 500,000$, $1\\leq s_i\\leq 10^8$, $1\\leq t\\leq 10^9$, $op\\in\\{0, 1, 2, 3\\}$, $1\\leq id\\leq n$, $1\\leq l\\leq r\\leq n$. It is guaranteed that $t$ is strictly increasing in the order of input.\n\nFrom CodePlus December 2017 Contest, proudly presented by the Student Algorithm and Programming Association, Department of Computer Science and Technology, Tsinghua University.\n\nCredit: idea/Wang Yuzhong, problem setter/Wang Yuzhong, testers/Lü Shiqing, Yang Jingqin.\n\nGit Repo: https://git.thusaac.org/publish/CodePlus201712\n\nThanks to Tencent for supporting this contest.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#2] 火锅盛宴", "background": "SkyDec 和 YJQQQAQ 都是 Yazid 的好朋友。他们都非常喜欢吃火锅。有一天，他们聚在一起，享受一场火锅盛宴。", "description": "在这场火锅盛宴中，有一个麻辣浓汤锅底的火锅和 $n$ 种食物，每种食物数量都是无限的。我们用 $1$ 至 $n$ 将这些食材编号。\n\n每种食物煮熟所需要的时间不同，第 $i$ 种食物煮熟需要 $s_i$ 单位时间。这表示如果你在第 $T$ 个时刻将一个食物 $i$ 下到火锅里，那么它会在第 $T+s_i$ 个时刻被煮熟，并且此后一直会延续被煮熟的状态，直到它被拿走为止。\n\nYazid 和 YJQQQAQ 的口味不同：YJQQQAQ 觉得所有食物的好吃程度都是相同的；而 Yazid 则觉得没有两种食材的好吃程度是相同的，并且，巧合的是，编号越小的食物 Yazid 越喜欢吃。可怜的 SkyDec 由于不能吃辣，所以只能帮 Yazid 和 YJQQQAQ 煮食物。\n\n整个火锅盛宴持续 $10^9$ 单位时间。在整个盛宴中，三位好朋友除了谈笑风生之外，最重要的事当然就是吃东西了。在任意整数时刻，都有可能发生下列 $4$ 种事件中的任意一种，我们用 $0$ 至 $3$ 之间的整数 $op$ 描述事件类型：\n\n- $0\\ id$：表示 SkyDec 往火锅里下了一个编号为 $id$ 的食物。\n- $1$：Yazid 在锅内搜寻熟了的且最喜欢吃的食物，并拿走一个这种食物。特别地，如果锅里没有熟了的食物，那么 Yazid 会很愤怒。\n- $2\\ id$：YJQQQAQ 在锅内搜寻编号为 $id$ 的食物：\n   - 如果锅里不存在该种食物，则 YJQQQAQ 会很愤怒；\n   - 如果锅里存在熟了的该食物，则 YJQQQAQ 会取走一个并食用；\n   - 如果锅里只有未煮熟的该种食物，那么 YJQQQAQ 会希望知道最接近煮熟的该种食物（即锅内存在时间最长的该种食物）还需要多少时间被煮熟。\n- $3\\ l\\ r$：馋涎欲滴的 SkyDec 想知道，锅里编号在 $[l,r]$ 之间的且熟了的食物总共有多少个。", "inputFormat": "从标准输入读入数据。\n\n本题包含多组数据，输入的第一行为一个正整数 $T$，表示数据组数。接下来依次描述每组数据，对于每组数据：\n\n第一行一个正整数 $n$，表示食物的种类数。\n\n第二行 $n$ 个用空格隔开的正整数 $s_1,s_2,\\cdots, s_n$，描述每种食物煮熟需要的时间。\n\n第三行一个正整数 $Q$，表示事件的数目。\n\n接下来 $Q$ 行，每行若干个用空格隔开的非负整数，描述一个事件。先是两个整数 $t,op$，分别表示发生事件的时间以及事件的类型。\n\n- 如果 $op=0$ 或 $op=2$，则接下来 $1$ 个正整数 $id$，意义见题目描述；\n- 如果 $op=1$，则接下来没有其他数；\n- 如果 $op=3$，则接下来 $2$ 个正整数 $l,r$，意义见题目描述。\n\n数据保证 $t$ 按输入顺序严格递增。\n", "outputFormat": "对于每个 $op\\neq 0$ 的操作，输出一行表示答案。对于不同的 $op$，需要输出的内容如下：\n\n- 对于 $op=1$，如果 Yazid 成功取走食物，则输出他取走食物的编号；否则输出 $\\text{``\\texttt{Yazid is angry.}''}\\!\\!$（不含引号，下同）。\n- 对于 $op=2$，如果 YJQQQAQ 成功取走食物，则输出 $\\!\\!\\text{``\\texttt{Succeeded!}''}\\!\\!$；否则，如果锅里有未煮熟的该类食物，输出最接近煮熟的该种食物还需要多少时间被煮熟；否则，输出 $\\!\\!\\text{``\\texttt{YJQQQAQ is angry.}''}\\!$。\n- 对于 $op=3$，输出锅内编号在指定范围内的熟食的数量。", "hint": "对于所有数据，保证$ T\\leq 4$，保证 $n\\leq 100,000$，$Q\\leq 500,000$，$1\\leq s_i\\leq 10^8$，$1\\leq t\\leq 10^9$，$op\\in\\{0, 1, 2, 3\\}$，$1\\leq id\\leq n$，$1\\leq l\\leq r\\leq n$。数据保证 $t$ 按输入顺序严格递增。\n\n来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/王聿中 命题/王聿中 验题/吕时清，杨景钦\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201712\n\n感谢腾讯公司对此次比赛的支持。\n", "locale": "zh-CN"}}}
{"pid": "P4033", "type": "P", "difficulty": 6, "samples": [["5\n3 9\nLLRRUDUUU\nLLR.UDUUU\nLLRRUDUUU\n4 4\nLLRR\nL.LL\nRR.R\nLLRR\n4 3\nLRD\nLUL\nDLU\nRDL\n1 2\nLR\n2 2\n..\n..", "3\n8\n0\n1\n192"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["搜索", "图论建模", "生成树", "Code+"], "title": "[Code+#2] 白金元首与独舞", "background": "```cpp\n到河北省 见斯大林 / 在月光下 你的背影 / 让我们一起跳舞吧\n```\nうそだよ~ 河北省怎么可能有 Stalin。\n\n\n可是…… 可是如果 Stalin 把自己当作炸弹扔到地堡花园里来了呢？\n\n\n怀揣着这份小小的希望，元首 Adolf 独自走进了花园。终有一天会重逢的吧，Stalin。或许是在此处，或许是在遥远的彼方。\n\n\n无论如何，在此之前，好好装点一番花园，编排一段优美的舞步吧！", "description": "元首把花园分为 $n$ 行 $m$ 列的网格。每个格子中都可以放置一个标识，指向上、下、左、右四个方向中的任意一个。元首位于一个格子时，会按照其中标识所指的方向进入周围的格子，或者走出花园（即目的格子不在网格之内）。举个例子 —— 对于下面的放置方式，元首从第 $3$ 行第 $2$ 列的格子开始，会沿着以红色标出的路径走出花园；从第 $2$ 行第 $2$ 列的格子开始，则会在以蓝色标出的环路内不断地行走。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12659.png) \n\n元首已经设计好了大部分格子的标识。元首用字符 L、R、U、D 分别表示指向左、右、上、下四个方向的标识，用字符 . 表示未决定的格子。现在，元首希望将每个 . 替换为 L、R、U、D 中任意一种，使得从花园中的任意一个格子出发，按照上述规则行走，都可以最终走出花园。\n\n\n你需要编写程序帮助元首计算替换的不同方案数。两个方案不同当且仅当存在一个格子，使得两个方案中该格子内的标识不同。当然，由于答案可能很大，只需给出方案数除以 $10^9 + 7$所得的余数即可。", "inputFormat": "从标准输入读入数据。\n\n\n输入的第一行包含一个正整数 $T$ —— 测试数据的组数。接下来包含 $T$ 组测试数据，格式如下，测试数据间没有空行。\n\n\n第 $1$ 行：两个空格分隔的正整数 $n$、$m$ —— 依次表示花园被分成的行数和列数。\n\n接下来 $n$ 行：每行一个长度为 $m$ 的由字符 L、R、U、D 和 . 组成的字符串 —— 表示花园内已经确定的格子状态。", "outputFormat": "输出到标准输出。\n\n\n对于每组测试数据输出一行 —— 满足条件的方案数除以 $10^9 + 7 $所得的余数。", "hint": "**样例解释**\n\n第 $1$ 组数据中，将惟一的 . 替换成 R、U 或 D 均满足要求。\n\n\n第 $2$ 组数据中，将左上方和右下方的两个 . 分别替换成 LR、LU、LD、UR、UU、UD、DR 或 DD 均满足要求。\n\n\n第 $3$ 组数据中，没有待决定的格子，原本的安排会使得元首陷入无尽的环路，故答案为 $0$。该组数据与**题目描述**中的例子相同。\n\n\n第 $4$ 组数据中，也没有待决定的格子，但原本的安排已经满足要求，故答案为 $1$。\n\n\n令 $k$ 表示标记未确定（即包含 `.`）的格子总数。\n\n\n对于所有数据，有 $1 \\leq T \\leq 10$，$1 \\leq n, m \\leq 200$，$0 \\leq k \\leq \\min(nm, 300)$。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12660.png) \n\n“... wie Stalin!”\n\n\n题面与史实无关。\n\n\n来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/吕时清 命题/吕时清 验题/王聿中，杨景钦\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201712\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#2] Platinum Führer and the Solo Dance", "background": "```cpp\n到河北省 见斯大林 / 在月光下 你的背影 / 让我们一起跳舞吧\n```\nJust kidding — how could there be Stalin in Hebei Province.\n\nBut... what if Stalin threw himself like a bomb into the bunker garden.\n\nWith this small hope in his heart, the Führer Adolf walked into the garden alone. We will meet again someday, Stalin. Perhaps here, perhaps far away.\n\nIn any case, before that, let’s decorate the garden and choreograph a graceful dance.", "description": "The Führer divides the garden into an $n$ by $m$ grid. Each cell can hold a marker pointing in one of the four directions: up, down, left, or right. When the Führer is in a cell, he moves to the adjacent cell indicated by the marker, or leaves the garden if the target cell is outside the grid. For example — in the placement below, starting from the cell at row $3$, column $2$, the Führer will leave the garden along the red path; starting from row $2$, column $2$, he will keep walking around the blue cycle.\n\n![](https://cdn.luogu.com.cn/upload/pic/12659.png)\n\nMost cells’ markers have already been designed. Characters L, R, U, D denote markers pointing left, right, up, and down, respectively, and the character . denotes an undecided cell. Now, the Führer wants to replace each . with one of L, R, U, D so that starting from any cell in the garden and following the rule above, the walk will eventually leave the garden.\n\nYou need to write a program to count the number of different valid replacements. Two replacements are different if and only if there exists a cell whose marker differs between the two. Since the answer can be large, output the remainder modulo $10^9 + 7$.", "inputFormat": "Read from standard input.\n\nThe first line contains a positive integer $T$ — the number of test cases. Then follow $T$ test cases with no blank lines between them.\n\nLine 1: Two space-separated positive integers $n$, $m$ — the number of rows and columns of the garden.\n\nNext $n$ lines: Each line is a string of length $m$ consisting of characters L, R, U, D, and . — the current state of the garden.", "outputFormat": "Output to standard output.\n\nFor each test case, output one line — the number of valid replacements modulo $10^9 + 7$.", "hint": "Sample explanation.\n\nIn the first test, replacing the only . with R, U, or D all works.\n\nIn the second test, the two . at the top-left and bottom-right can be replaced, respectively, as one of the pairs LR, LU, LD, UR, UU, UD, DR, or DD.\n\nIn the third test, there is no undecided cell, and the original arrangement traps the Führer in an endless cycle, so the answer is $0$. This test matches the example in the Description.\n\nIn the fourth test, there is also no undecided cell, and the original arrangement already satisfies the requirement, so the answer is $1$.\n\nLet $k$ be the total number of undecided cells (those containing .).\n\nFor all test cases, $1 \\le T \\le 10$, $1 \\le n, m \\le 200$, $0 \\le k \\le \\min(nm, 300)$.\n\n![](https://cdn.luogu.com.cn/upload/pic/12660.png)\n\n“... like Stalin.”\n\nThis problem statement is unrelated to historical facts.\n\nFrom CodePlus December 2017 Contest, proudly presented by the Student Association for Algorithms and Competitions, Department of Computer Science and Technology, Tsinghua University.\n\nCredit: idea/吕时清, problem setting/吕时清, verification/王聿中, 杨景钦.\n\nGit Repo: https://git.thusaac.org/publish/CodePlus201712\n\nThanks to Tencent for supporting this contest.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#2] 白金元首与独舞", "background": "```cpp\n到河北省 见斯大林 / 在月光下 你的背影 / 让我们一起跳舞吧\n```\nうそだよ~ 河北省怎么可能有 Stalin。\n\n\n可是…… 可是如果 Stalin 把自己当作炸弹扔到地堡花园里来了呢？\n\n\n怀揣着这份小小的希望，元首 Adolf 独自走进了花园。终有一天会重逢的吧，Stalin。或许是在此处，或许是在遥远的彼方。\n\n\n无论如何，在此之前，好好装点一番花园，编排一段优美的舞步吧！", "description": "元首把花园分为 $n$ 行 $m$ 列的网格。每个格子中都可以放置一个标识，指向上、下、左、右四个方向中的任意一个。元首位于一个格子时，会按照其中标识所指的方向进入周围的格子，或者走出花园（即目的格子不在网格之内）。举个例子 —— 对于下面的放置方式，元首从第 $3$ 行第 $2$ 列的格子开始，会沿着以红色标出的路径走出花园；从第 $2$ 行第 $2$ 列的格子开始，则会在以蓝色标出的环路内不断地行走。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12659.png) \n\n元首已经设计好了大部分格子的标识。元首用字符 L、R、U、D 分别表示指向左、右、上、下四个方向的标识，用字符 . 表示未决定的格子。现在，元首希望将每个 . 替换为 L、R、U、D 中任意一种，使得从花园中的任意一个格子出发，按照上述规则行走，都可以最终走出花园。\n\n\n你需要编写程序帮助元首计算替换的不同方案数。两个方案不同当且仅当存在一个格子，使得两个方案中该格子内的标识不同。当然，由于答案可能很大，只需给出方案数除以 $10^9 + 7$所得的余数即可。", "inputFormat": "从标准输入读入数据。\n\n\n输入的第一行包含一个正整数 $T$ —— 测试数据的组数。接下来包含 $T$ 组测试数据，格式如下，测试数据间没有空行。\n\n\n第 $1$ 行：两个空格分隔的正整数 $n$、$m$ —— 依次表示花园被分成的行数和列数。\n\n接下来 $n$ 行：每行一个长度为 $m$ 的由字符 L、R、U、D 和 . 组成的字符串 —— 表示花园内已经确定的格子状态。", "outputFormat": "输出到标准输出。\n\n\n对于每组测试数据输出一行 —— 满足条件的方案数除以 $10^9 + 7 $所得的余数。", "hint": "**样例解释**\n\n第 $1$ 组数据中，将惟一的 . 替换成 R、U 或 D 均满足要求。\n\n\n第 $2$ 组数据中，将左上方和右下方的两个 . 分别替换成 LR、LU、LD、UR、UU、UD、DR 或 DD 均满足要求。\n\n\n第 $3$ 组数据中，没有待决定的格子，原本的安排会使得元首陷入无尽的环路，故答案为 $0$。该组数据与**题目描述**中的例子相同。\n\n\n第 $4$ 组数据中，也没有待决定的格子，但原本的安排已经满足要求，故答案为 $1$。\n\n\n令 $k$ 表示标记未确定（即包含 `.`）的格子总数。\n\n\n对于所有数据，有 $1 \\leq T \\leq 10$，$1 \\leq n, m \\leq 200$，$0 \\leq k \\leq \\min(nm, 300)$。\n\n ![](https://cdn.luogu.com.cn/upload/pic/12660.png) \n\n“... wie Stalin!”\n\n\n题面与史实无关。\n\n\n来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/吕时清 命题/吕时清 验题/王聿中，杨景钦\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201712\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN"}}}
{"pid": "P4034", "type": "P", "difficulty": 6, "samples": [["2 4 3\n1 1 -1\n-1 1 -1\n0 2\n-2 1\n2 1\n0 0", "4.00\n8.50\n8.50\n15.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["Code+"], "title": "[Code+#2] 寄蒜几盒", "background": "R姓出题人：第一次出CodePlus月赛，好紧脏，怎么才能装作经常出CodePlus月赛的样子？\n\n\n某W姓出题人：写题面记得要加背景。\n\n\nR姓出题人：可是我的题目没有什么背景可以写，怎么办？\n\n\n某W姓出题人：其实背景和题面没有关系也是可以的。\n\n\nR姓出题人：原来如此，那我知道了。\n", "description": "在二维平面上有$n$条直线，这些直线会将平面划分成若干个区域。给定$m$个点，求每个点所在的区域的面积。\n\n\n聪明的读者会发现有些点所在的区域面积是无穷大的。R姓出题人早就想到了这一点，所以他给出了一个实数$L$，由额外的四条直线$x=L,x=-L,y=L,y=-L$框定了一个有限的平面区域，并且所有的询问点都在这个框定的平面区域内部。\n\n\n聪明绝顶的读者会发现如果询问点恰好落在某条直线上或者离某条直线的距离非常近，那么精度误差会严重影响答案。R姓出题人早就想到了这一点，所以在他造的数据中，任意一个询问点距离任意一条直线的距离大于$10^{-7}$。\n", "inputFormat": "从标准输入读入数据。\n\n\n第一行两个正整数$n,m$和一个正实数$L$。\n\n\n接下来$n$行每行三个实数$A,B,C$，表示这条直线的方程为$Ax+By+C=0$\n\n\n接下来$m$行，第$i$行两个实数$x_i,y_i$，表示第$i$个点的坐标。\n", "outputFormat": "输出到标准输出。\n\n\n输出$m$行，每行一个实数，第iii行输出的实数表示第$i$个点所在的区域的面积。保留两位小数。\n", "hint": "对于$20\\%$的数据，$n,m \\le 10$。\n\n\n对于$40\\%$的数据，$n,m \\le 300$。\n\n\n对于$100\\%$的数据，$n \\le 500,m \\le 100000$。\n\n\n对于$100\\%$的数据，输入数据的绝对值$ \\le 10^7$，且输入数据最多保留两位小数。\n\n\n来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/茹逸中 命题/茹逸中 验题/陈宇，王聿中\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201712\n\n感谢腾讯公司对此次比赛的支持。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#2] How Many Boxes of Garlic to Ship", "background": "R-surnamed problem setter: It’s my first time hosting a CodePlus monthly contest. I’m so nervous—how can I act like I do CodePlus monthlies all the time?\n\nA certain W-surnamed problem setter: When you write the statement, remember to add a background.\n\nR-surnamed problem setter: But my problem doesn’t really have a background. What should I do?\n\nA certain W-surnamed problem setter: Actually, it’s fine if the background is unrelated to the statement.\n\nR-surnamed problem setter: I see. Got it.", "description": "In the 2D plane, there are $n$ lines that partition the plane into regions. Given $m$ points, find the area of the region that contains each point.\n\nA careful reader will notice that some regions have infinite area. The R-surnamed author has anticipated this and provides a real number $L$. Four extra lines $x = L, x = -L, y = L, y = -L$ bound a finite rectangular area, and all query points lie strictly inside this bounded region.\n\nAn even more careful reader will note that if a query point lies exactly on a line or extremely close to one, numerical error could severely affect the answer. The R-surnamed author has anticipated this as well: in the testdata, the distance from any query point to any line is greater than $10^{-7}$.", "inputFormat": "Read from standard input.\n\nThe first line contains two positive integers $n, m$ and one positive real number $L$.\n\nThe next $n$ lines each contain three real numbers $A, B, C$, indicating a line with equation $Ax + By + C = 0$.\n\nThe next $m$ lines, the $i$-th line contains two real numbers $x_i, y_i$, which are the coordinates of the $i$-th point.", "outputFormat": "Write to standard output.\n\nOutput $m$ lines, each containing one real number. The number on the $i$-th line is the area of the region containing the $i$-th point. Print with two decimal places.", "hint": "For $20\\%$ of the testdata, $n, m \\le 10$.\n\nFor $40\\%$ of the testdata, $n, m \\le 300$.\n\nFor $100\\%$ of the testdata, $n \\le 500, m \\le 100000$.\n\nFor $100\\%$ of the testdata, the absolute value of every input number is $\\le 10^7$, and each input number has at most two decimal places.\n\nFrom the CodePlus 2017 December Contest, proudly presented by the Student Algorithms and Contest Association of the Department of Computer Science and Technology, Tsinghua University.\n\nCredit: idea/Ru Yizhong; setter/Ru Yizhong; testers/Chen Yu, Wang Yuzhong.\n\nGit Repo: https://git.thusaac.org/publish/CodePlus201712\n\nThanks to Tencent for supporting this contest.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#2] 寄蒜几盒", "background": "R姓出题人：第一次出CodePlus月赛，好紧脏，怎么才能装作经常出CodePlus月赛的样子？\n\n\n某W姓出题人：写题面记得要加背景。\n\n\nR姓出题人：可是我的题目没有什么背景可以写，怎么办？\n\n\n某W姓出题人：其实背景和题面没有关系也是可以的。\n\n\nR姓出题人：原来如此，那我知道了。\n", "description": "在二维平面上有$n$条直线，这些直线会将平面划分成若干个区域。给定$m$个点，求每个点所在的区域的面积。\n\n\n聪明的读者会发现有些点所在的区域面积是无穷大的。R姓出题人早就想到了这一点，所以他给出了一个实数$L$，由额外的四条直线$x=L,x=-L,y=L,y=-L$框定了一个有限的平面区域，并且所有的询问点都在这个框定的平面区域内部。\n\n\n聪明绝顶的读者会发现如果询问点恰好落在某条直线上或者离某条直线的距离非常近，那么精度误差会严重影响答案。R姓出题人早就想到了这一点，所以在他造的数据中，任意一个询问点距离任意一条直线的距离大于$10^{-7}$。\n", "inputFormat": "从标准输入读入数据。\n\n\n第一行两个正整数$n,m$和一个正实数$L$。\n\n\n接下来$n$行每行三个实数$A,B,C$，表示这条直线的方程为$Ax+By+C=0$\n\n\n接下来$m$行，第$i$行两个实数$x_i,y_i$，表示第$i$个点的坐标。\n", "outputFormat": "输出到标准输出。\n\n\n输出$m$行，每行一个实数，第iii行输出的实数表示第$i$个点所在的区域的面积。保留两位小数。\n", "hint": "对于$20\\%$的数据，$n,m \\le 10$。\n\n\n对于$40\\%$的数据，$n,m \\le 300$。\n\n\n对于$100\\%$的数据，$n \\le 500,m \\le 100000$。\n\n\n对于$100\\%$的数据，输入数据的绝对值$ \\le 10^7$，且输入数据最多保留两位小数。\n\n\n来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。\n\nCredit：idea/茹逸中 命题/茹逸中 验题/陈宇，王聿中\n\nGit Repo：https://git.thusaac.org/publish/CodePlus201712\n\n感谢腾讯公司对此次比赛的支持。\n", "locale": "zh-CN"}}}
{"pid": "P4035", "type": "P", "difficulty": 5, "samples": [["2\n0.0 0.0\n-1.0 1.0\n1.0 0.0", "0.500 1.500"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "江苏", "模拟退火", "高斯消元", "构造"], "title": "[JSOI2008] 球形空间产生器", "background": "", "description": "有一个球形空间产生器能够在 $n$ 维空间中产生一个坚硬的球体。现在，你被困在了这个 $n$ 维球体中，你只知道球面上 $n+1$ 个点的坐标，你需要以最快的速度确定这个 $n$ 维球体的球心坐标，以便于摧毁这个球形空间产生器。", "inputFormat": "第一行是一个整数 $n$ $(1\\le N\\le 10)$。接下来的 $n+1$ 行，每行有 $n$ 个实数，表示球面上一点的 $n$ 维坐标。每一个实数精确到小数点后 $6$ 位，且其绝对值都不超过 $20000$。", "outputFormat": "有且只有一行，依次给出球心的 $n$ 维坐标（ $n$ 个实数），两个实数之间用一个空格隔开。每个实数精确到小数点后 $3$ 位。数据保证有解。你的答案必须和标准输出一模一样才能够得分。", "hint": "提示：给出两个定义：\n\n1. 球心：到球面上任意一点距离都相等的点。\n2. 距离：设两个 $n$ 维空间上的点 $A,B$ 的坐标为 $(a_1, a_2, \\cdots , a_n), (b_1, b_2, \\cdots , b_n)$，则 $A,B$ 的距离定义为：$dist = \\sqrt{ (a_1-b_1)^2 + (a_2-b_2)^2 + \\cdots + (a_n-b_n)^2 }$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2008] Spherical Space Generator", "background": "", "description": "There is a spherical space generator that can create a rigid sphere in $n$-dimensional space. Now you are trapped inside this $n$-dimensional sphere. You only know the coordinates of $n+1$ points on the sphere, and you need to determine the coordinates of the center of this $n$-dimensional sphere as quickly as possible in order to destroy the spherical space generator.", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 10$). The next $n+1$ lines each contain $n$ real numbers, representing the $n$-dimensional coordinates of a point on the sphere. Each real number is given to $6$ decimal places, and its absolute value does not exceed $20000$.", "outputFormat": "Output exactly one line containing the $n$ coordinates of the center (i.e., $n$ real numbers), separated by a single space. Each real number must be printed to $3$ decimal places. It is guaranteed that a solution exists. Your answer must be exactly the same as the standard output to receive points.", "hint": "Hint: Two definitions are given:\n\n1. Center: a point whose distances to all points on the sphere are equal.\n2. Distance: let two points $A, B$ in $n$-dimensional space have coordinates $(a_1, a_2, \\cdots, a_n), (b_1, b_2, \\cdots, b_n)$. The distance between $A$ and $B$ is defined as $dist = \\sqrt{ (a_1-b_1)^2 + (a_2-b_2)^2 + \\cdots + (a_n-b_n)^2 }$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2008] 球形空间产生器", "background": "", "description": "有一个球形空间产生器能够在 $n$ 维空间中产生一个坚硬的球体。现在，你被困在了这个 $n$ 维球体中，你只知道球面上 $n+1$ 个点的坐标，你需要以最快的速度确定这个 $n$ 维球体的球心坐标，以便于摧毁这个球形空间产生器。", "inputFormat": "第一行是一个整数 $n$ $(1\\le N\\le 10)$。接下来的 $n+1$ 行，每行有 $n$ 个实数，表示球面上一点的 $n$ 维坐标。每一个实数精确到小数点后 $6$ 位，且其绝对值都不超过 $20000$。", "outputFormat": "有且只有一行，依次给出球心的 $n$ 维坐标（ $n$ 个实数），两个实数之间用一个空格隔开。每个实数精确到小数点后 $3$ 位。数据保证有解。你的答案必须和标准输出一模一样才能够得分。", "hint": "提示：给出两个定义：\n\n1. 球心：到球面上任意一点距离都相等的点。\n2. 距离：设两个 $n$ 维空间上的点 $A,B$ 的坐标为 $(a_1, a_2, \\cdots , a_n), (b_1, b_2, \\cdots , b_n)$，则 $A,B$ 的距离定义为：$dist = \\sqrt{ (a_1-b_1)^2 + (a_2-b_2)^2 + \\cdots + (a_n-b_n)^2 }$。\n", "locale": "zh-CN"}}}
{"pid": "P4036", "type": "P", "difficulty": 6, "samples": [["madamimadam\n7\nQ 1 7\nQ 4 8\nQ 10 11\nR 3 a\nQ 1 7\nI 10 a\nQ 2 11", "5\n1\n0\n2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "2008", "各省省选", "平衡树", "江苏", "哈希 hashing"], "title": "[JSOI2008] 火星人", "background": "", "description": "火星人最近研究了一种操作：求一个字串两个后缀的公共前缀。\n\n比方说，有这样一个字符串：madamimadam，我们将这个字符串的各个字符予以标号：\n```\n序号 1 2 3 4 5 6 7 8 9 10 11 \n字符 m a d a m i m a d a m\n```\n现在，火星人定义了一个函数 $LCQ(x, y)$，表示：该字符串中第 $x$ 个字符开始的字串，与该字符串中第 $y$ 个字符开始的字串，两个字串的公共前缀的长度。比方说，$LCQ(1, 7) = 5, LCQ(2, 10) = 1, LCQ(4, 7) = 0$\n\n在研究 $LCQ$ 函数的过程中，火星人发现了这样的一个关联：如果把该字符串的所有后缀排好序，就可以很快地求出 $LCQ$ 函数的值；同样，如果求出了 $LCQ$ 函数的值，也可以很快地将该字符串的后缀排好序。\n\n尽管火星人聪明地找到了求取 $LCQ$ 函数的快速算法，但不甘心认输的地球人又给火星人出了个难题：在求取 $LCQ$ 函数的同时，还可以改变字符串本身。具体地说，可以更改字符串中某一个字符的值，也可以在字符串中的某一个位置插入一个字符。地球人想考验一下，在如此复杂的问题中，火星人是否还能够做到很快地求取 $LCQ$ 函数的值。", "inputFormat": "第一行给出初始的字符串。第二行是一个非负整数 $M$ ，表示操作的个数。接下来的M行，每行描述一个操作。操作有 $3$ 种，如下所示\n\n1. 询问。语法：$Q$ $x$ $y$ ，$x$ ,$y$ 均为正整数。功能：计算 $LCQ(x,y)$ 限制：$1$ $\\leq$ $x$ , $y$ $\\leq$ 当前字符串长度 。\n2. 修改。语法：$R$ $x$ $d$，$x$ 是正整数，$d$ 是字符。功能：将字符串中第 $x$ 个数修改为字符 $d$ 。限制：$x$ 不超过当前字符串长度。\n3. 插入：语法：$I$ $x$ $d$ ，$x$ 是非负整数，$d$ 是字符。功能：在字符串第 $x$ 个字符之后插入字符 $d$ ，如果 $x=0$，则在字符串开头插入。限制：$x$ 不超过当前字符串长度", "outputFormat": "对于输入文件中每一个询问操作，你都应该输出对应的答案。一个答案一行。", "hint": "1. 所有字符串自始至终都只有小写字母构成。\n2. $M\\leq150,000$\n3. 字符串长度L自始至终都满足$L\\leq100,000$\n4. 询问操作的个数不超过 $10,000$ 个。\n\n对于第 $1$，$2$ 个数据，字符串长度自始至终都不超过 $1,000$\n对于第 $3$，$4$，$5$ 个数据，没有插入操作。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2008] Martians", "background": "", "description": "Martians have recently been studying an operation: finding the common prefix of two suffixes of a string.\n\nFor example, consider this string: madamimadam. We label its characters as follows:\n```\n序号 1 2 3 4 5 6 7 8 9 10 11 \n字符 m a d a m i m a d a m\n```\nNow, Martians define a function $LCQ(x, y)$, which means: the length of the common prefix between the substring starting at the $x$-th character and the substring starting at the $y$-th character of the string. For example, $LCQ(1, 7) = 5, LCQ(2, 10) = 1, LCQ(4, 7) = 0$.\n\nIn the process of studying the $LCQ$ function, Martians found a connection: if you sort all suffixes of the string, you can quickly compute the value of $LCQ$; likewise, if you know the values of $LCQ$, you can quickly sort the suffixes of the string.\n\nAlthough Martians cleverly discovered a fast algorithm for computing $LCQ$, the unyielding Earthlings posed a new challenge: while computing $LCQ$, the string itself may change. Specifically, you may change the value of a character in the string, or insert a character at some position in the string. The Earthlings want to test whether Martians can still compute $LCQ$ quickly under such a complex scenario.", "inputFormat": "The first line gives the initial string. The second line is a non-negative integer $M$, the number of operations. The next M lines each describe one operation. There are 3 types of operations:\n\n1. Query. Syntax: $Q$ $x$ $y$, where $x$, $y$ are positive integers. Function: compute $LCQ(x, y)$. Constraint: $1 \\leq x, y \\leq$ current string length.\n2. Modify. Syntax: $R$ $x$ $d$, where $x$ is a positive integer and $d$ is a character. Function: replace the $x$-th character of the string with $d$. Constraint: $x$ does not exceed the current string length.\n3. Insert. Syntax: $I$ $x$ $d$, where $x$ is a non-negative integer and $d$ is a character. Function: insert character $d$ after the $x$-th character of the string; if $x=0$, insert at the beginning of the string. Constraint: $x$ does not exceed the current string length.", "outputFormat": "For each query operation in the input, output the corresponding answer, one per line.", "hint": "1. All strings always consist of lowercase letters only.\n2. $M\\leq150,000$\n3. The string length $L$ always satisfies $L\\leq100,000$.\n4. The number of query operations does not exceed $10,000$.\n\nFor testdata 1 and 2, the string length never exceeds $1,000$.\nFor testdata 3, 4, and 5, there are no insert operations.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2008] 火星人", "background": "", "description": "火星人最近研究了一种操作：求一个字串两个后缀的公共前缀。\n\n比方说，有这样一个字符串：madamimadam，我们将这个字符串的各个字符予以标号：\n```\n序号 1 2 3 4 5 6 7 8 9 10 11 \n字符 m a d a m i m a d a m\n```\n现在，火星人定义了一个函数 $LCQ(x, y)$，表示：该字符串中第 $x$ 个字符开始的字串，与该字符串中第 $y$ 个字符开始的字串，两个字串的公共前缀的长度。比方说，$LCQ(1, 7) = 5, LCQ(2, 10) = 1, LCQ(4, 7) = 0$\n\n在研究 $LCQ$ 函数的过程中，火星人发现了这样的一个关联：如果把该字符串的所有后缀排好序，就可以很快地求出 $LCQ$ 函数的值；同样，如果求出了 $LCQ$ 函数的值，也可以很快地将该字符串的后缀排好序。\n\n尽管火星人聪明地找到了求取 $LCQ$ 函数的快速算法，但不甘心认输的地球人又给火星人出了个难题：在求取 $LCQ$ 函数的同时，还可以改变字符串本身。具体地说，可以更改字符串中某一个字符的值，也可以在字符串中的某一个位置插入一个字符。地球人想考验一下，在如此复杂的问题中，火星人是否还能够做到很快地求取 $LCQ$ 函数的值。", "inputFormat": "第一行给出初始的字符串。第二行是一个非负整数 $M$ ，表示操作的个数。接下来的M行，每行描述一个操作。操作有 $3$ 种，如下所示\n\n1. 询问。语法：$Q$ $x$ $y$ ，$x$ ,$y$ 均为正整数。功能：计算 $LCQ(x,y)$ 限制：$1$ $\\leq$ $x$ , $y$ $\\leq$ 当前字符串长度 。\n2. 修改。语法：$R$ $x$ $d$，$x$ 是正整数，$d$ 是字符。功能：将字符串中第 $x$ 个数修改为字符 $d$ 。限制：$x$ 不超过当前字符串长度。\n3. 插入：语法：$I$ $x$ $d$ ，$x$ 是非负整数，$d$ 是字符。功能：在字符串第 $x$ 个字符之后插入字符 $d$ ，如果 $x=0$，则在字符串开头插入。限制：$x$ 不超过当前字符串长度", "outputFormat": "对于输入文件中每一个询问操作，你都应该输出对应的答案。一个答案一行。", "hint": "1. 所有字符串自始至终都只有小写字母构成。\n2. $M\\leq150,000$\n3. 字符串长度L自始至终都满足$L\\leq100,000$\n4. 询问操作的个数不超过 $10,000$ 个。\n\n对于第 $1$，$2$ 个数据，字符串长度自始至终都不超过 $1,000$\n对于第 $3$，$4$，$5$ 个数据，没有插入操作。", "locale": "zh-CN"}}}
{"pid": "P4037", "type": "P", "difficulty": 6, "samples": [["10 59\n5 A 3 6 1 9 2 10 1\n1 B 5 3\n1 B 4 3\n1 B 2 3\n8 A 3 2 1 3 1 7 1\n1 B 5 3\n5 B 3 3\n15 A 3 1 1 5 1 4 1\n1 B 3 5\n1 B 4 3", "33"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "江苏", "O2优化", "枚举", "背包 DP"], "title": "[JSOI2008] 魔兽地图", "background": "本题疑似错题，不保证存在算法能通过该数据范围下的所有数据。目前所有题解的复杂度都是错误的，且绝大部分能被 https://www.luogu.com.cn/discuss/1112812 中的 Hack 卡掉。", "description": "DotR (Defense of the Robots) Allstars 是一个风靡全球的魔兽地图，他的规则简单与同样流行的地图 DotA (Defense of the Ancients) Allstars。\n\nDotR 里面的英雄只有一个属性——力量。他们需要购买装备来提升自己的力量值，每件装备都可以使佩戴它的英雄的力量值提高固定的点数，所以英雄的力量值等于它购买的所有装备的力量值之和。装备分为基本装备和高级装备两种。基本装备可以直接从商店里面用金币购买，而高级装备需要用基本装备或者较低级的高级装备来合成，合成不需要附加的金币。装备的合成路线可以用一棵树来表示。\n\n比如，Sange and Yasha 的合成需要 Sange，Yasha 和 Sange and Yasha Recipe Scroll 三样物品。其中 Sange 又要用 Ogre Axe，Belt of Giant Strength 和 Sange Recipe Scroll 合成。每件基本装备都有数量限制，这限制了你不能无限制地合成某些性价比很高的装备。\n\n现在，英雄 Spectre 有 $M$ 个金币，他想用这些钱购买装备使自己的力量值尽量高。你能帮帮他吗？他会教你魔法 Haunt（幽灵附体）作为回报的。", "inputFormat": "第一行包含两个整数，$N(1\\le N\\le 51)$ 和 $M(0\\le M\\le  2000)$。分别表示装备的种类数和金币数。装备用 $1$ 到 $N$ 的整数编号。\n\n接下来的 $N$ 行，按照装备 $1$ 到装备 $N$ 的顺序，每行描述一种装备。\n\n每一行的第一个非负整数表示这个装备贡献的力量值。\n\n接下来的非空字符表示这种装备是基本装备还是高级装备，A 表示高级装备，B 表示基本装备。如果是基本装备，紧接着的两个正整数分别表示它的单价（单位为金币）和数量限制（不超过 $100$）。如果是高级装备，后面紧跟着一个正整数 $C$，表示这个高级装备需要 $C$ 种低级装备。后面的 $2C$ 个数，依次描述某个低级装备的种类和需要的个数。", "outputFormat": "第一行包含一个整数 $S$，表示最多可以提升多少点力量值。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2008] Warcraft Map", "background": "This problem is suspected to be flawed, and there is no guarantee that any algorithm can pass all testdata under these constraints. The time complexity of all existing solutions is incorrect, and most of them can be hacked by the cases in https://www.luogu.com.cn/discuss/1112812.", "description": "DotR (Defense of the Robots) Allstars is a globally popular Warcraft map. Its rules are simple, similar to the also popular map DotA (Defense of the Ancients) Allstars.\n\nIn DotR, heroes have only one attribute — Strength. They need to buy equipment to improve their Strength. Each piece of equipment increases the hero’s Strength by a fixed amount, so the hero’s Strength equals the sum of the Strength values of all purchased equipment. There are two types of equipment: basic equipment and advanced equipment. Basic equipment can be purchased directly from the shop with gold, while advanced equipment must be crafted from basic equipment or lower-tier advanced equipment. Crafting requires no additional gold. The crafting dependency can be represented by a tree.\n\nFor example, Sange and Yasha is crafted from Sange, Yasha, and a Sange and Yasha Recipe Scroll. Sange itself is crafted from an Ogre Axe, a Belt of Giant Strength, and a Sange Recipe Scroll. Each basic equipment has a stock limit, which prevents you from crafting certain high cost-performance equipment infinitely.\n\nNow, the hero Spectre has $M$ gold coins and wants to buy equipment to maximize his Strength. Can you help him? He will teach you the spell Haunt (幽灵附体) as a reward.\n\n# Description", "inputFormat": "The first line contains two integers, $N$ ($1 \\le N \\le 51$) and $M$ ($0 \\le M \\le 2000$), representing the number of equipment types and the amount of gold, respectively. Equipment are numbered from $1$ to $N$.\n\nThe next $N$ lines, in the order of equipment $1$ to equipment $N$, each describe one equipment.\n\n- The first nonnegative integer on each line is the Strength contributed by this equipment.\n- The next character indicates whether this equipment is basic or advanced: A denotes advanced equipment, B denotes basic equipment.\n  - If it is basic equipment, it is followed by two positive integers: its unit price (in gold) and its stock limit (no more than $100$).\n  - If it is advanced equipment, it is followed by a positive integer $C$, indicating that this advanced equipment requires $C$ types of lower-tier equipment. The next $2C$ integers then describe, in order, for each lower-tier equipment, its type and the required quantity.", "outputFormat": "Output a single integer $S$, the maximum total Strength that can be achieved.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2008] 魔兽地图", "background": "本题疑似错题，不保证存在算法能通过该数据范围下的所有数据。目前所有题解的复杂度都是错误的，且绝大部分能被 https://www.luogu.com.cn/discuss/1112812 中的 Hack 卡掉。", "description": "DotR (Defense of the Robots) Allstars 是一个风靡全球的魔兽地图，他的规则简单与同样流行的地图 DotA (Defense of the Ancients) Allstars。\n\nDotR 里面的英雄只有一个属性——力量。他们需要购买装备来提升自己的力量值，每件装备都可以使佩戴它的英雄的力量值提高固定的点数，所以英雄的力量值等于它购买的所有装备的力量值之和。装备分为基本装备和高级装备两种。基本装备可以直接从商店里面用金币购买，而高级装备需要用基本装备或者较低级的高级装备来合成，合成不需要附加的金币。装备的合成路线可以用一棵树来表示。\n\n比如，Sange and Yasha 的合成需要 Sange，Yasha 和 Sange and Yasha Recipe Scroll 三样物品。其中 Sange 又要用 Ogre Axe，Belt of Giant Strength 和 Sange Recipe Scroll 合成。每件基本装备都有数量限制，这限制了你不能无限制地合成某些性价比很高的装备。\n\n现在，英雄 Spectre 有 $M$ 个金币，他想用这些钱购买装备使自己的力量值尽量高。你能帮帮他吗？他会教你魔法 Haunt（幽灵附体）作为回报的。", "inputFormat": "第一行包含两个整数，$N(1\\le N\\le 51)$ 和 $M(0\\le M\\le  2000)$。分别表示装备的种类数和金币数。装备用 $1$ 到 $N$ 的整数编号。\n\n接下来的 $N$ 行，按照装备 $1$ 到装备 $N$ 的顺序，每行描述一种装备。\n\n每一行的第一个非负整数表示这个装备贡献的力量值。\n\n接下来的非空字符表示这种装备是基本装备还是高级装备，A 表示高级装备，B 表示基本装备。如果是基本装备，紧接着的两个正整数分别表示它的单价（单位为金币）和数量限制（不超过 $100$）。如果是高级装备，后面紧跟着一个正整数 $C$，表示这个高级装备需要 $C$ 种低级装备。后面的 $2C$ 个数，依次描述某个低级装备的种类和需要的个数。", "outputFormat": "第一行包含一个整数 $S$，表示最多可以提升多少点力量值。", "hint": "", "locale": "zh-CN"}}}
