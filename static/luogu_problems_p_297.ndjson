{"pid": "P7010", "type": "P", "difficulty": 5, "samples": [["3\n\nStops: OxfordCircus, PiccadillyCircus, HydeParkCorner, King'sCross, GreenPark, Arsenal, Victoria, Highbury&Islington, LeicesterSquare\nLines: Blue, Cyan\nCyan route: Highbury&Islington, King'sCross, OxfordCircus, GreenPark, Victoria\nBlue route: HydeParkCorner, GreenPark, PiccadillyCircus, LeicesterSquare, King'sCross, Arsenal\nJohny lives at King'sCross\nMichelle lives at GreenPark\n\nStops: OxfordCircus, PiccadillyCircus, HydeParkCorner, King'sCross, GreenPark, Arsenal, Victoria, Highbury&Islington, LeicesterSquare\nLines: Blue, Cyan\nCyan route: Highbury&Islington, King'sCross, OxfordCircus, GreenPark, Victoria\nBlue route: HydeParkCorner, GreenPark, PiccadillyCircus, LeicesterSquare, King'sCross, Arsenal\nJohny lives at PiccadillyCircus\nMichelle lives at LeicesterSquare\n\nStops: OxfordCircus, PiccadillyCircus, HydeParkCorner, King'sCross, GreenPark, Arsenal, Victoria, Highbury&Islington, LeicesterSquare\nLines: Blue, Cyan\nCyan route: Highbury&Islington, King'sCross, OxfordCircus, GreenPark, Victoria\nBlue route: HydeParkCorner, GreenPark, PiccadillyCircus, LeicesterSquare, King'sCross, Arsenal\nJohny lives at Victoria\nMichelle lives at HydeParkCorner\n", "optimal travel from King'sCross to GreenPark: 1 line, 3 minutes\noptimal travel from PiccadillyCircus to LeicesterSquare: 1 line, 1 minute\noptimal travel from Victoria to HydeParkCorner: 2 lines, 7 minutes\n"]], "limits": {"time": [8000, 8000, 8000], "memory": [262144, 262144, 262144]}, "tags": ["2013", "ICPC", "CERC"], "title": "[CERC2013] Subway", "background": "", "description": "\n\nJohny is going to visit his friend Michelle. His dad allowed him to go there on his own by subway. Johny loves traveling by subway and would gladly use this opportunity to spend half a day underground, but his dad obliged him to make as few line changes as possible. There are a lot of stations in the city, and several subway lines connecting them. All trains are perfectly synchronized $-$ the travel between two consecutive stations on every line takes exactly one minute, and changing lines at any station takes no time at all.\n\nGiven the subway map, help Johny to plan his trip so that he can travel for as long as possible, while still following his dad's order.\n\n", "inputFormat": "\n\nFirst line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nThe description of each test case starts with an empty line. The next two lines begin with the strings Stops: and Lines:, and contain the names (separated by a comma and a space) of all subway stops and lines, respectively. A single line for each subway line follows (in no particular order), beginning with route: and listing the names of the stops along this particular line. The final two lines specify the names of the (different) stations nearby Johny's and Michelle's homes.\n\nIn each test case, there are at most $300 000$ stations and $100 000$ lines, whose total length does not exceed $1 000 000$ . The names of lines and stations are between $1$ and $50$ characters long and can contain letters, digits, hyphens $(-),$ apostrophes $(‘)$ and `and` signs $(&).$ All lines are bidirectional (although changing the direction of travel counts as a line change) and there are no self-crossings.\n\n", "outputFormat": "\n\nPrint the answers to the test cases in the order in which they appear in the input. For each test case, print a single line summarizing the optimal route Johny can take (see example output for exact format). You may assume that such a route always exists.\n\n", "hint": "Time limit: 8 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[CERC2013] Subway", "background": "", "description": "\n\nJohny is going to visit his friend Michelle. His dad allowed him to go there on his own by subway. Johny loves traveling by subway and would gladly use this opportunity to spend half a day underground, but his dad obliged him to make as few line changes as possible. There are a lot of stations in the city, and several subway lines connecting them. All trains are perfectly synchronized $-$ the travel between two consecutive stations on every line takes exactly one minute, and changing lines at any station takes no time at all.\n\nGiven the subway map, help Johny to plan his trip so that he can travel for as long as possible, while still following his dad's order.\n\n", "inputFormat": "\n\nFirst line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nThe description of each test case starts with an empty line. The next two lines begin with the strings Stops: and Lines:, and contain the names (separated by a comma and a space) of all subway stops and lines, respectively. A single line for each subway line follows (in no particular order), beginning with route: and listing the names of the stops along this particular line. The final two lines specify the names of the (different) stations nearby Johny's and Michelle's homes.\n\nIn each test case, there are at most $300 000$ stations and $100 000$ lines, whose total length does not exceed $1 000 000$ . The names of lines and stations are between $1$ and $50$ characters long and can contain letters, digits, hyphens $(-),$ apostrophes $(‘)$ and `and` signs $(&).$ All lines are bidirectional (although changing the direction of travel counts as a line change) and there are no self-crossings.\n\n", "outputFormat": "\n\nPrint the answers to the test cases in the order in which they appear in the input. For each test case, print a single line summarizing the optimal route Johny can take (see example output for exact format). You may assume that such a route always exists.\n\n", "hint": "Time limit: 8 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[CERC2013] Subway", "background": "", "description": "$Johny$ 准备去拜访他的朋友 $Michelle$。他的父亲允许他乘地铁独自去那里。$Johny$ 喜欢乘地铁旅行，并很愿意用这次机会在地铁里呆上半天，但是父亲要求他尽量减少换乘次数。这个城市有很多地铁车站，并有几条地铁线路连接它们。所有列车都完全同步——在每条线上的两个连续地铁站点之间地铁行驶的时间恰好需要 $1$ 分钟，而在该城市的任何一个地铁站点上更改线路是不需要花费时间的。\n\n现在 $Johny$ 有了该城市的地铁线路图，请帮助 $Johny$ 计划行程，以便他可以尽可能长时间的在地铁里呆着，同时还要尽量减少换乘次数。", "inputFormat": "输入的第 $1$ 行为测试数据 $T$ 的数量。\n\n每组测试数据均用空行分隔。接下来的两行以字符串以 $ Stops: $ 和  $Lines: $ 开头，并分别包含所有地铁站和线路的名称（以逗号和空格分隔）。每条地铁线路中的其中一条线路（不分先后）从 $route: $ 开始，并一一列出了该条线路的站点名称。最后两行给定了 $Johny$ 和 $Michelle$ 的家附近的车站的名称。\n\n在每组测试数据中，最多有 $300000$ 个站点以及 $100000$ 条铁路线路，保证其总长度不超过 $1000000$；铁路线路和地铁站点的名称长度均在 $1$ 至 $50$ 个字符之间，其名称中可以含有字母、数字、连字符 `-`、引号 `'` 和特殊符号 `&`。所有的地铁线路都是双向的（改变行进方向即该条线路被改变），并保证没有自交叉。", "outputFormat": "按照在输入中测试数据的顺序来输出每组测试数据的答案。对于每组测试用例，需输出一行来总结 Johny 可以采用的最佳路线（参见样例输出）。假设这样的线路始终存在。\n\n### 输入输出样例\n\n**输入 #1**\n\n```txt\n3\n\nStops: OxfordCircus, PiccadillyCircus, HydeParkCorner, King'sCross, GreenPark, Arsenal, Victoria, Highbury&Islington, LeicesterSquare\nLines: Blue, Cyan\nCyan route: Highbury&Islington, King'sCross, OxfordCircus, GreenPark, Victoria\nBlue route: HydeParkCorner, GreenPark, PiccadillyCircus, LeicesterSquare, King'sCross, Arsenal\nJohny lives at King'sCross\nMichelle lives at GreenPark\n\nStops: OxfordCircus, PiccadillyCircus, HydeParkCorner, King'sCross, GreenPark, Arsenal, Victoria, Highbury&Islington, LeicesterSquare\nLines: Blue, Cyan\nCyan route: Highbury&Islington, King'sCross, OxfordCircus, GreenPark, Victoria\nBlue route: HydeParkCorner, GreenPark, PiccadillyCircus, LeicesterSquare, King'sCross, Arsenal\nJohny lives at PiccadillyCircus\nMichelle lives at LeicesterSquare\n\nStops: OxfordCircus, PiccadillyCircus, HydeParkCorner, King'sCross, GreenPark, Arsenal, Victoria, Highbury&Islington, LeicesterSquare\nLines: Blue, Cyan\nCyan route: Highbury&Islington, King'sCross, OxfordCircus, GreenPark, Victoria\nBlue route: HydeParkCorner, GreenPark, PiccadillyCircus, LeicesterSquare, King'sCross, Arsenal\nJohny lives at Victoria\nMichelle lives at HydeParkCorner\n```\n\n**输出 #1**\n\n```txt\noptimal travel from King'sCross to GreenPark: 1 line, 3 minutes\noptimal travel from PiccadillyCircus to LeicesterSquare: 1 line, 1 minute\noptimal travel from Victoria to HydeParkCorner: 2 lines, 7 minutes\n```", "hint": "时间限制：$8s$\n\n内存限制：$256\\texttt{MB}$", "locale": "zh-CN"}}}
{"pid": "P7011", "type": "P", "difficulty": 6, "samples": [["2\n7 7\n0 -3 2 2 3 -4 0\n1 2\n2 3\n2 4\n1 5\n5 6\n6 7\n3 2\n3 3 -4\n1 3\n2 3\n", "escaped\ntrapped\n"]], "limits": {"time": [8000, 8000], "memory": [131072, 131072]}, "tags": ["2013", "ICPC", "CERC"], "title": "[CERC2013] Escape", "background": "", "description": "\n\nYou hit the emperor lich with full force and slay it. There is a stair leading upwards here. You climb upstairs. You drink from the pool. You feel much better. The karmic lizard punches through your armor and hits you. You die...\n\nAfter an epic fight with the emperor lich, the hero struggles to escape the dungeon consisting of $n$ chambers and $n − 1$ corridors connecting them. He starts in chamber number $1$ and must reach chamber number $t$ , moving only along the corridors. All chambers are reachable from chamber number $1$ . Bruised after the last fight, the hero starts the journey with $0$ hit-points $(HP).$ These points represent his health $-$ if ever they fall below zero, the hero's story ends there as a tragic one.\n\nIn some chambers there are monsters $-$ a monster must be fought, and it always manages to take some of the hero's HP. In some other chambers there are magic pools $-$ every pool restores some number of the hit-points. There is no upper limit on the hero's health. Every chamber can be visited multiple times, but the gain or loss of HP happens only once, on the very first visit.\n\nDetermine whether the hero can escape the dungeon alive.\n\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nThe first line of each test case contains two integers: the number of chambers $n , 2 \\le n \\le 200 000$ , and the number of the exit chamber $t , 2 \\le t \\le n$ . The second line contains $n$ space separated integers between $-10^{6}$ and $10^{6} -$ the i-th of them denotes the HP gain in the i-th chamber (negative denotes a monster, positive $-$ a pool, and zero means that the chamber is empty). The first chamber does not contain a monster, but a pool is possible there. The exit chamber may contain a pool or a monster, and the monster will have to be fought before escaping.\n\nThe next $n−1$ lines contain the descriptions of corridors. Each one contains a pair of integers $-$ the ends of a corridor.\n\n", "outputFormat": "\n\nFor each test case print a single line containing the word escaped if escape is possible, or trapped otherwise.\n\n", "hint": "Time limit: 8 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[CERC2013] Escape", "background": "", "description": "\n\nYou hit the emperor lich with full force and slay it. There is a stair leading upwards here. You climb upstairs. You drink from the pool. You feel much better. The karmic lizard punches through your armor and hits you. You die...\n\nAfter an epic fight with the emperor lich, the hero struggles to escape the dungeon consisting of $n$ chambers and $n − 1$ corridors connecting them. He starts in chamber number $1$ and must reach chamber number $t$ , moving only along the corridors. All chambers are reachable from chamber number $1$ . Bruised after the last fight, the hero starts the journey with $0$ hit-points $(HP).$ These points represent his health $-$ if ever they fall below zero, the hero's story ends there as a tragic one.\n\nIn some chambers there are monsters $-$ a monster must be fought, and it always manages to take some of the hero's HP. In some other chambers there are magic pools $-$ every pool restores some number of the hit-points. There is no upper limit on the hero's health. Every chamber can be visited multiple times, but the gain or loss of HP happens only once, on the very first visit.\n\nDetermine whether the hero can escape the dungeon alive.\n\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nThe first line of each test case contains two integers: the number of chambers $n , 2 \\le n \\le 200 000$ , and the number of the exit chamber $t , 2 \\le t \\le n$ . The second line contains $n$ space separated integers between $-10^{6}$ and $10^{6} -$ the i-th of them denotes the HP gain in the i-th chamber (negative denotes a monster, positive $-$ a pool, and zero means that the chamber is empty). The first chamber does not contain a monster, but a pool is possible there. The exit chamber may contain a pool or a monster, and the monster will have to be fought before escaping.\n\nThe next $n−1$ lines contain the descriptions of corridors. Each one contains a pair of integers $-$ the ends of a corridor.\n\n", "outputFormat": "\n\nFor each test case print a single line containing the word escaped if escape is possible, or trapped otherwise.\n\n", "hint": "Time limit: 8 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[CERC2013] Escape", "background": "", "description": "### 题目背景\n\n在经历和巫妖王史诗级别的战斗后，英雄们想要从地牢中逃走。\n\n\n这个地牢是由 $n$ 个房间和 $n-1$ 条走廊连接组成的树状结构，英雄一开始在 $1$ 号房间，而且他只有抵达 $t$ 号房间才能逃离这个地牢。从 $1$ 号房间出发可以抵达任何一个其它的房间，可惜的是，在经历激烈的战斗后，英雄的精力使用完了，所以一开始该英雄的精力为 $0$，并且一旦英雄的精力低于 $0$，那么英雄就会当场逝世，以悲剧结束。在这些房间中，里面暗藏玄机，里面可能有怪兽，也有可能是可以补充精力的魔泉，当然也可能什么也没有，如果是怪兽，那么英雄就必须与它战斗从而消耗一些精力，如果是魔泉，那么英雄可以补充自己的精力。所有的怪兽只会战斗一次，所有的魔泉只能使用一次。（换句话说就是所有的精力的上升或者下降只会发生在第一次访问这个房间的时候）\n\n英雄的精力没有上限，每一个房间都可以反复走多次。", "inputFormat": "输入包括多组数据，第一行表示测试的数据的组数 $T$。\n\n每一个测试用例的第 $1$ 行都包括两个整数 $n$ $(2 \\le n \\le 200000 )$ 和 $t$ $(2 \\le t \\le n)$，分别表示地牢的房间的数量和英雄必须到达的房间号。第二行是 $n$ 个整数，代表了 $n$ 个房间的情况，其中第 $i$ 个数代表了第 $i$ 个房间情况，所有的数的绝对值都不大于 $10^{6}$。如果该数是负数，表明该房间里面有怪兽，精力会减少，如果是正数，表明房间里面有魔泉，可以补充精力，如果是 $0$，表明房间里面空空如也。注意 $1$ 号房间不会有怪兽，但是有可能会有魔泉，$t$ 号房间可能怪兽或者魔泉，如果是怪兽，那么英雄必须要击败怪兽才能逃离。\n\n在接下来的 $n-1$ 行中，每行两个整数 $a$ 和 $b$ ，表示房间 $a, b$ 之间有一条走廊连接。", "outputFormat": "对于每一个测试用例都单行输出：\n\n如果英雄能够逃脱，那么输出 `escaped`，否则输出 `trapped`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7012", "type": "P", "difficulty": 2, "samples": [["2\n\n.#.#.#.#.#\n#.#.#.#.#.\n.#.#.B.#.#\n#.#.#.#.#.\n.#.#.B.#.#\n#.#.W.#.#.\n.#.#.#.#.#\n#.#.#.B.#.\n.#.#.#.#.#\n#.#.#.#.#.\n\n.#.#.#.#.#\n#.#.#.#.#.\n.#.#.B.#.#\n#.B.#.B.#.\n.#.#.B.#.#\n#.B.W.#.#.\n.#.B.B.#.#\n#.#.#.#.#.\n.#.B.B.#.#\n#.#.#.#.#.\n", "2\n4\n"]], "limits": {"time": [2000, 2000], "memory": [262144, 262144]}, "tags": ["搜索", "2013", "广度优先搜索 BFS", "深度优先搜索 DFS", "ICPC", "CERC"], "title": "[CERC2013] Draughts", "background": "", "description": "\n\nDraughts (or checkers) is a game played by two opponents, on opposite sides of a $10 \\times 10$ board. The board squares are painted black and white, as on a classic chessboard. One player controls the dark, and the other the light pieces. The pieces can only occupy the black squares. The players make their moves alternately, each moving one of his own pieces.\n\nThe most interesting type of move is capturing: if a diagonally adjacent square contains an opponent's piece, it may be captured (and removed from the game) by jumping over it to the unoccupied square immediately beyond it. It is allowed to make several consecutive captures in one move, if they are all made with a single piece. It is also legal to capture by either forward or backward jumps.\n\n![](/upload/images2/dr.png)\n\nThe board before and after a single move with two captures.\n\nYou are given a draughts position. It is the light player's turn. Compute the maximal possible number of dark pieces he can capture in his next move.\n\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nEach test case starts with an empty line. The following $10$ lines of $10$ characters each describe the board squares. The characters $#$ and . denote empty black and white squares, $W$ denotes a square with a light piece, $B -$ a square with a dark piece.\n\n", "outputFormat": "\n\nFor each test case print a single line containing the maximal possible number of captures. If there is no legal move (for example, there are no light pieces on the board), simply output $0$ .\n\n", "hint": "Time limit: 2 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[CERC2013] Draughts", "background": "", "description": "\n\nDraughts (or checkers) is a game played by two opponents, on opposite sides of a $10 \\times 10$ board. The board squares are painted black and white, as on a classic chessboard. One player controls the dark, and the other the light pieces. The pieces can only occupy the black squares. The players make their moves alternately, each moving one of his own pieces.\n\nThe most interesting type of move is capturing: if a diagonally adjacent square contains an opponent's piece, it may be captured (and removed from the game) by jumping over it to the unoccupied square immediately beyond it. It is allowed to make several consecutive captures in one move, if they are all made with a single piece. It is also legal to capture by either forward or backward jumps.\n\n![](/upload/images2/dr.png)\n\nThe board before and after a single move with two captures.\n\nYou are given a draughts position. It is the light player's turn. Compute the maximal possible number of dark pieces he can capture in his next move.\n\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nEach test case starts with an empty line. The following $10$ lines of $10$ characters each describe the board squares. The characters $#$ and . denote empty black and white squares, $W$ denotes a square with a light piece, $B -$ a square with a dark piece.\n\n", "outputFormat": "\n\nFor each test case print a single line containing the maximal possible number of captures. If there is no legal move (for example, there are no light pieces on the board), simply output $0$ .\n\n", "hint": "Time limit: 2 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[CERC2013] Draughts", "background": "", "description": "国际跳棋（或称跳棋）是一种由两个对手在 $10 \\times 10$ 的棋盘上进行的游戏。棋盘上的方块是黑色或白色的，就像经典的国际象棋棋盘一样。玩家一方控制黑棋，另一方控制白棋。棋子只能占据黑色的格子。棋手们交替走棋，各自移动自己的一个棋子。\n\n最有趣的走法是吃掉：如果一个对角线相邻的格子里有对手的棋子，可以通过跳过它到紧挨着它的未被占领的格子来吃掉（并从游戏中删除被吃掉的这个棋子）。允许在一步棋中用一个棋子连续吃掉几个棋子。通过向前或向后的跳跃来吃子也是合法的。\n\n你会得到一个棋子的位置。现在轮到白方了。计算他在下一步棋中能吃掉的最大可能的黑棋数量。", "inputFormat": "输入的第一行包含测试用例 $T$ 的数量。接下来是测试用例的描述。\n\n每个测试用例以空行开始。接下来的 10 行，每行都有 10 个字符，描述棋盘的方格。字符 # 和 . 表示空的黑色和白色方块，W 表示有浅色棋子的方块，B 表示有深色棋子的方块。", "outputFormat": "对于每个测试案例，输出一行一个整数，代表最多可以吃黑子的个数。如果没有合法的棋步（例如，棋盘上没有白棋），只需输出 0。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7013", "type": "P", "difficulty": 7, "samples": [["1\n3\n1 6\n2 3\n4 5\n", "1\n2 3\n1 6\n4 5\n"]], "limits": {"time": [10000, 10000], "memory": [131072, 131072]}, "tags": ["2013", "Special Judge", "ICPC", "CERC"], "title": "[CERC2013] History course", "background": "", "description": "You are to give a series of lectures on important historical events, one event per lecture, in some order. Each event lasted for some time interval $[a_i, b_i].$ We say that two events are related if their intervals have a common point. It would be convenient to schedule lectures on related events close to each other. Moreover, lectures on unrelated events should be given in the order in which the events have taken place (if an event A preceded an unrelated event $B$ , then the lecture on A should precede the lecture on $B)$ .\n\nFind the minimum integer $k \\ge 0$ and an order of the lectures such that any two related events are scheduled at most $k$ lectures apart from each other (lectures number $i$ and $j$ are considered to be $|i−j|$ lectures apart).", "inputFormat": "\nThe first line of input contains the number of test cases $t$ . The descriptions of the test cases follow:\n\nThe first line of each test case contains the number $n (1 \\le n \\le 50000)$ . Each of the next $n$ lines contains two integers $a_i$ and $b_i (-10^9  \\le a_i \\le b_i \\le 10^9) $ - the ends of the i-th interval. The intervals are pairwise different.", "outputFormat": "\nPrint the answers to the test cases in the order in which they appear in the input. The first line of the answer to each test case should contain the minimum value of $k$ . The next $n$ lines should list the intervals (in the same format as in the input) in an order such that any two related events are scheduled at most $k$ lectures apart. Remember to put any unrelated intervals in the proper order! ", "hint": "Time limit: 10 s, Memory limit: 128 MB. \n\n感谢 [hht2006](/user/175829) 提供的 Special Judge。", "locale": "en", "translations": {"en": {"title": "[CERC2013] History course", "background": "", "description": "You are to give a series of lectures on important historical events, one event per lecture, in some order. Each event lasted for some time interval $[a_i, b_i].$ We say that two events are related if their intervals have a common point. It would be convenient to schedule lectures on related events close to each other. Moreover, lectures on unrelated events should be given in the order in which the events have taken place (if an event A preceded an unrelated event $B$ , then the lecture on A should precede the lecture on $B)$ .\n\nFind the minimum integer $k \\ge 0$ and an order of the lectures such that any two related events are scheduled at most $k$ lectures apart from each other (lectures number $i$ and $j$ are considered to be $|i−j|$ lectures apart).", "inputFormat": "\nThe first line of input contains the number of test cases $t$ . The descriptions of the test cases follow:\n\nThe first line of each test case contains the number $n (1 \\le n \\le 50000)$ . Each of the next $n$ lines contains two integers $a_i$ and $b_i (-10^9  \\le a_i \\le b_i \\le 10^9) $ - the ends of the i-th interval. The intervals are pairwise different.", "outputFormat": "\nPrint the answers to the test cases in the order in which they appear in the input. The first line of the answer to each test case should contain the minimum value of $k$ . The next $n$ lines should list the intervals (in the same format as in the input) in an order such that any two related events are scheduled at most $k$ lectures apart. Remember to put any unrelated intervals in the proper order! ", "hint": "Time limit: 10 s, Memory limit: 128 MB. \n\n感谢 [hht2006](/user/175829) 提供的 Special Judge。", "locale": "en"}, "zh-CN": {"title": "[CERC2013] History course", "background": "", "description": "你需要按某种顺序为一系列重要历史事件安排讲座，每个讲座对应一个事件。每个事件持续一段时间区间 $[a_i, b_i]$。如果两个事件的时间区间有公共点，则称这两个事件是相关的。为了方便起见，安排相关事件的讲座时应尽量靠近。此外，对于不相关的事件，讲座应按照事件发生的顺序进行（如果事件 A 先于不相关事件 $B$ 发生，那么 A 的讲座应先于 B 的讲座）。找到最小的整数 $k \\ge 0$ 和一个讲座顺序，使得任何两个相关事件的讲座之间的间隔最多为 $k$（讲座编号 $i$ 和 $j$ 之间的间隔被认为是 $|i−j|$）。", "inputFormat": "输入的第一行包含测试用例的数量 $t$。每个测试用例的描述如下：每个测试用例的第一行包含一个整数 $n (1 \\le n \\le 50000)$。接下来的 $n$ 行中的每一行包含两个整数 $a_i$ 和 $b_i (-10^9 \\le a_i \\le b_i \\le 10^9)$，表示第 $i$ 个区间的两个端点。所有区间是两两不同的。", "outputFormat": "按输入中出现的顺序输出每个测试用例的答案。每个测试用例答案的第一行应包含最小值 $k$。接下来的 $n$ 行应按顺序列出区间（格式与输入相同），使得任何两个相关事件的讲座之间的间隔最多为 $k$。记得将任何不相关的区间按正确的顺序排列！", "hint": "时间限制：10 秒，内存限制：128 MB。感谢 [hht2006](/user/175829) 提供的 Special Judge。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7014", "type": "P", "difficulty": 6, "samples": [["3\n\n2\n0 0 0 0 10 10\n-5 5 15 5 5 25\n\n5\n0 0 0 0 10 10\n-5 5 6 5 5 16\n-5 5 -6 5 5 4\n-5 6 5 5 16 5\n-5 -6 5 5 4 5\n\n3\n0 0 0 3 0 -3\n1 -1 -1 1 2 -4\n-1 -2 -2 2 1 -2\n", "NO\nYES\nYES\n"]], "limits": {"time": [10000, 10000], "memory": [262144, 262144]}, "tags": ["2013", "ICPC", "CERC"], "title": "[CERC2013] Chain & Co.", "background": "", "description": "\n\nChain $&$ Co. specializes in producing infinitely strong chains. Because of their high quality products, they are quickly gaining market share. This leads to new challenges, some of which they could have never imagined before. Like, for example, automatic verification of link endurance with a computer program, which you are supposed to write.\n\nThe company produces links of equal size. Each link is an infinitely thin square frame in three dimensions (made of four infinitely thin segments).\n\nDuring tests all links are $axis-aligned^{1}$ and placed so that no two frames touch. To make a proper strength test, two sets of links A and $B$ are forged so that every link of A is inseparable from every link of $B$ (being inseparable means that they cannot be moved apart without breaking one of them).\n\nYou stumble upon some links (axis-aligned, pairwise disjoint). Are they in proper testing position? In other words, can they be divided into two non-empty sets A and $B$ with the desired property?\n\n$^{1}Axis-aligned$ means that all segments are parallel to either $X , Y$ , or $Z$ axis.\n\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nThe description of each test case starts with an empty line. The next line contains an integer $n , 1 \\le n \\le 10^{6} -$ the number of links in the chain. Each of the next $n$ lines contains $6$ space separated integers $x_{i}, y_{i}, z_{i}, x_{i}', y_{i}', z_{i}',$ all between $-10^{9}$ and $10^{9} -$ the coordinates of two opposite corners of the i-th link.\n\n", "outputFormat": "\n\nFor each test case, print a single line containing the word YES if the set is in proper testing position, or NO otherwise.\n\n", "hint": "Time limit: 10 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[CERC2013] Chain & Co.", "background": "", "description": "\n\nChain $&$ Co. specializes in producing infinitely strong chains. Because of their high quality products, they are quickly gaining market share. This leads to new challenges, some of which they could have never imagined before. Like, for example, automatic verification of link endurance with a computer program, which you are supposed to write.\n\nThe company produces links of equal size. Each link is an infinitely thin square frame in three dimensions (made of four infinitely thin segments).\n\nDuring tests all links are $axis-aligned^{1}$ and placed so that no two frames touch. To make a proper strength test, two sets of links A and $B$ are forged so that every link of A is inseparable from every link of $B$ (being inseparable means that they cannot be moved apart without breaking one of them).\n\nYou stumble upon some links (axis-aligned, pairwise disjoint). Are they in proper testing position? In other words, can they be divided into two non-empty sets A and $B$ with the desired property?\n\n$^{1}Axis-aligned$ means that all segments are parallel to either $X , Y$ , or $Z$ axis.\n\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nThe description of each test case starts with an empty line. The next line contains an integer $n , 1 \\le n \\le 10^{6} -$ the number of links in the chain. Each of the next $n$ lines contains $6$ space separated integers $x_{i}, y_{i}, z_{i}, x_{i}', y_{i}', z_{i}',$ all between $-10^{9}$ and $10^{9} -$ the coordinates of two opposite corners of the i-th link.\n\n", "outputFormat": "\n\nFor each test case, print a single line containing the word YES if the set is in proper testing position, or NO otherwise.\n\n", "hint": "Time limit: 10 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[CERC2013] Chain & Co.", "background": "", "description": "Chain $&$ Co. 专注于生产无限强度的链条。由于其高质量的产品，他们迅速占领了市场。这带来了新的挑战，其中一些是他们之前从未想象过的。例如，使用计算机程序自动验证链环的耐久性，而这正是你需要编写的程序。\n\n公司生产的链环大小相同。每个链环都是三维空间中的一个无限薄的正方形框架（由四个无限薄的线段构成）。\n\n在测试过程中，所有链环都是“轴对齐的”并且放置得没有两个框架接触。为了进行适当的强度测试，锻造了两个链环集合 A 和 $B$，使得 A 的每个链环都与 B 的每个链环不可分离（不可分离意味着它们不能在不破坏其中一个的情况下分开）。\n\n你偶然发现了一些链环（轴对齐，成对不相交）。它们是否处于适当的测试位置？换句话说，它们能否被划分为两个非空集合 A 和 $B$，并具有所需的特性？\n\n“轴对齐”意味着所有线段都平行于 $X, Y$ 或 $Z$ 轴。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来的部分是测试用例的描述：\n\n每个测试用例的描述以一个空行开始。下一行包含一个整数 $n, 1 \\le n \\le 10^{6}$ —— 链条中的链环数量。接下来的 $n$ 行中的每一行包含 $6$ 个以空格分隔的整数 $x_{i}, y_{i}, z_{i}, x_{i}', y_{i}', z_{i}'$，所有数值都在 $-10^{9}$ 和 $10^{9}$ 之间 —— 这是第 $i$ 个链环两个对角的坐标。", "outputFormat": "对于每个测试用例，打印一行，包含单词 YES 如果集合处于适当的测试位置，否则打印 NO。", "hint": "时间限制：10 秒，内存限制：128 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7015", "type": "P", "difficulty": 4, "samples": [["2\n6\n5 4 6 3 2 1\n5\n1 2 3 4 5\n", "5\n1 2\n4 5\n5 6\n4 5\n1 6\n0\n"]], "limits": {"time": [4000], "memory": [131072]}, "tags": ["2013", "Special Judge", "ICPC", "CERC"], "title": "[CERC2013] Crane", "background": "", "description": "\n\nThere are $n$ crates waiting to be loaded onto a ship. The crates are numbered $1 , 2 , \\cdots , n$ , the numbers determining the order of loading. Unfortunately, someone messed up the transit and the crates are standing in a row in an arbitrary order. As there is only limited space in the dock area, you must sort the crates by swapping some of them.\n\nYou are given a crane that works in the following way: you select a connected interval of crates of even length. The crane then exchanges the first half of the interval with the second half. The order inside both halves remains unchanged. Determine the sequence of crane moves that reorders the crates properly.\n\nThe crane's software has a bug: the move counter is a $9-based$ (not $10-based,$ as you might think) integer with at most $6$ digits. Therefore, the crane stops working (and has to be serviced) after $9^{6} = 531441$ moves. Your solution must fit within this limit.\n\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nEach test case starts with an integer $n , 1 \\le n \\le 10 000$ , denoting the number of crates. In the next line a permutation of numbers ${1 , 2 , \\cdots $ , n} follows.\n\n", "outputFormat": "\n\nFor each test case print a single line containing $m -$ the number of swaps $-$ followed by $m$ lines describing the swaps in the order in which they should be performed. A single swap is described by two numbers $-$ the indices of the first and the last element in the interval to be exchanged. Do not follow the crane's strange software design $-$ use standard decimal numeral system.\n\n", "hint": "Time limit: 4 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[CERC2013] Crane", "background": "", "description": "\n\nThere are $n$ crates waiting to be loaded onto a ship. The crates are numbered $1 , 2 , \\cdots , n$ , the numbers determining the order of loading. Unfortunately, someone messed up the transit and the crates are standing in a row in an arbitrary order. As there is only limited space in the dock area, you must sort the crates by swapping some of them.\n\nYou are given a crane that works in the following way: you select a connected interval of crates of even length. The crane then exchanges the first half of the interval with the second half. The order inside both halves remains unchanged. Determine the sequence of crane moves that reorders the crates properly.\n\nThe crane's software has a bug: the move counter is a $9-based$ (not $10-based,$ as you might think) integer with at most $6$ digits. Therefore, the crane stops working (and has to be serviced) after $9^{6} = 531441$ moves. Your solution must fit within this limit.\n\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nEach test case starts with an integer $n , 1 \\le n \\le 10 000$ , denoting the number of crates. In the next line a permutation of numbers ${1 , 2 , \\cdots $ , n} follows.\n\n", "outputFormat": "\n\nFor each test case print a single line containing $m -$ the number of swaps $-$ followed by $m$ lines describing the swaps in the order in which they should be performed. A single swap is described by two numbers $-$ the indices of the first and the last element in the interval to be exchanged. Do not follow the crane's strange software design $-$ use standard decimal numeral system.\n\n", "hint": "Time limit: 4 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[CERC2013] Crane", "background": "", "description": "有 $n$ 个箱子等着装上船。箱子的编号是 $a_1,a_2,\\cdots,a_n$。你的工作是通过若干次交换，将它们从小到大排列。你每次可以选择一个区间，将它的前半部分与后半部分交换，两半内部的顺序保持不变。你最多可以交换 $531441$ 次。", "inputFormat": "第一行输入包含数据组数 $T$。\n\n接下来 $2\\times T$ 行，表示 $T$ 组数据。每组数据的第一行为 $n\\ (1 \\leq n \\leq 10000)$，表示箱子的数量。第二行为 $n$ 个正整数$a_1,a_2,\\cdots,a_n $ ，表示箱子的编号。", "outputFormat": "对于每组数据，首先输出一个数 $m$ ，表示交换的次数。 然后输出 $m$ 行，按照顺序描述每一次交换。对于每次交换，输出要交换的区间中第一个元素和最后一个元素的下标。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7016", "type": "P", "difficulty": 6, "samples": [["2\n4 619\n5 25 125 6\n3 101\n5 11 29\n", "30\n83\n"]], "limits": {"time": [6000], "memory": [262144]}, "tags": ["2013", "ICPC", "CERC"], "title": "[CERC2013] Captain Obvious and the Rabbit-Man", "background": "", "description": "\n\nIt's you, Captain Obvious! - cried the evil Rabbit-Man - you came here to foil my evil plans!\n\nYes, it's me.  - said Captain Obvious.\n\nBut... how did you know that $I$ would be here, on $625$ Sunflower Street?! Did you crack my evil code?\n\nI did. Three days ago, you robbed a bank on $5$ Sunflower Street, the next day you blew up $25$ Sunflower Street, and yesterday you left quite a mess under number $125$ . These are all powers of $5$ . And last year you pulled a similar stunt with powers of $13$ . You seem to have a knack for Fibonacci numbers, Rabbit-Man. \n\nThat's not over! $I$ will learn... arithmetics! - Rabbit-Man screamed as he was dragged into custody - You will never know what to expect... Owww! Not my ears, you morons!\n\nMaybe, but right now you are being arrested.  - Captain added proudly.\n\nUnfortunately, Rabbit-Man has now indeed learned some more advanced arithmetics. To understand it, let us define the sequence $F_n$ (being not completely unlike the Fibonacci sequence):\n\n$F_{1} = 1$ ,\n\n$F_{2} = 2$ ,\n\n$F_{n} = F_{n-1} + F_{n-2}$ for $n \\ge 3$ .\n\nRabbit-Man has combined all his previous evil ideas into one master plan. On the i-th day, he does a malicious act on the spot number $p(i)$ , defined as follows:\n\n$p(i) = a_{1}·F_{1}^{i} + a_{2}·F_{2}^{i} + \\cdots + a_{k}·F_{k}^{i}.$\n\nThe number $k$ and the integer coefficients $a_1 , \\cdots $ , ak are fixed. Captain Obvious learned $k$ , but does not know the coefficients. Given $p(1) , p(2) , \\cdots , p(k)$ , help him to determine p(k $+ 1)$ . To avoid overwhelmingly large numbers, do all the calculations modulo a fixed prime number $M$ . You may assume that $F_1 , F_2 , \\cdots , F_n$ are pairwise distinct modulo $M$ . You may also assume that there always exists a unique solution for the given input.\n\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nThe first line of each test case contains two integers $k$ and $M , 1 \\le k \\le 4000 , 3 \\le M \\le 10^{9}.$ The second line contains $k$ space-separated integers $-$ the values of $p(1) , p(2) , \\cdots , p(k)$ modulo $M$ .\n\n", "outputFormat": "\n\nPrint the answers to the test cases in the order in which they appear in the input. For each test case print a single line containing one integer: the value of $p(k + 1)$ modulo $M$ .\n\n", "hint": "Time limit: 6 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[CERC2013] Captain Obvious and the Rabbit-Man", "background": "", "description": "\n\nIt's you, Captain Obvious! - cried the evil Rabbit-Man - you came here to foil my evil plans!\n\nYes, it's me.  - said Captain Obvious.\n\nBut... how did you know that $I$ would be here, on $625$ Sunflower Street?! Did you crack my evil code?\n\nI did. Three days ago, you robbed a bank on $5$ Sunflower Street, the next day you blew up $25$ Sunflower Street, and yesterday you left quite a mess under number $125$ . These are all powers of $5$ . And last year you pulled a similar stunt with powers of $13$ . You seem to have a knack for Fibonacci numbers, Rabbit-Man. \n\nThat's not over! $I$ will learn... arithmetics! - Rabbit-Man screamed as he was dragged into custody - You will never know what to expect... Owww! Not my ears, you morons!\n\nMaybe, but right now you are being arrested.  - Captain added proudly.\n\nUnfortunately, Rabbit-Man has now indeed learned some more advanced arithmetics. To understand it, let us define the sequence $F_n$ (being not completely unlike the Fibonacci sequence):\n\n$F_{1} = 1$ ,\n\n$F_{2} = 2$ ,\n\n$F_{n} = F_{n-1} + F_{n-2}$ for $n \\ge 3$ .\n\nRabbit-Man has combined all his previous evil ideas into one master plan. On the i-th day, he does a malicious act on the spot number $p(i)$ , defined as follows:\n\n$p(i) = a_{1}·F_{1}^{i} + a_{2}·F_{2}^{i} + \\cdots + a_{k}·F_{k}^{i}.$\n\nThe number $k$ and the integer coefficients $a_1 , \\cdots $ , ak are fixed. Captain Obvious learned $k$ , but does not know the coefficients. Given $p(1) , p(2) , \\cdots , p(k)$ , help him to determine p(k $+ 1)$ . To avoid overwhelmingly large numbers, do all the calculations modulo a fixed prime number $M$ . You may assume that $F_1 , F_2 , \\cdots , F_n$ are pairwise distinct modulo $M$ . You may also assume that there always exists a unique solution for the given input.\n\n", "inputFormat": "\n\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nThe first line of each test case contains two integers $k$ and $M , 1 \\le k \\le 4000 , 3 \\le M \\le 10^{9}.$ The second line contains $k$ space-separated integers $-$ the values of $p(1) , p(2) , \\cdots , p(k)$ modulo $M$ .\n\n", "outputFormat": "\n\nPrint the answers to the test cases in the order in which they appear in the input. For each test case print a single line containing one integer: the value of $p(k + 1)$ modulo $M$ .\n\n", "hint": "Time limit: 6 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[CERC2013] Captain Obvious and the Rabbit-Man", "background": "", "description": "“是你，显而易见船长！”邪恶的兔子人喊道，“你来这里是为了阻止我的邪恶计划！”\n\n“是的，是我。”显而易见船长说道。\n\n“但是……你怎么知道我会在向日葵街 625 号？！你破解了我的邪恶代码吗？”\n\n“我破解了。三天前，你抢劫了向日葵街 5 号的银行，第二天你炸毁了向日葵街 25 号，昨天你在 125 号制造了一场混乱。这些都是 5 的幂。而去年你用 13 的幂做了类似的事情。你似乎对斐波那契数有一种天赋，兔子人。”\n\n“这还没完！我会学习……算术！”兔子人被拖入拘留时尖叫道，“你永远不知道会发生什么……哎哟！别碰我的耳朵，你们这些笨蛋！”\n\n“也许吧，但现在你被捕了。”船长自豪地补充道。\n\n不幸的是，兔子人现在确实学会了一些更高级的算术。为了理解它，让我们定义序列 $F_n$（与斐波那契序列不完全相似）：\n\n$F_{1} = 1$，\n\n$F_{2} = 2$，\n\n$F_{n} = F_{n-1} + F_{n-2}$ 对于 $n \\ge 3$。\n\n兔子人将他所有以前的邪恶想法结合成一个总计划。在第 $i$ 天，他在编号为 $p(i)$ 的地方进行恶意行为，定义如下：\n\n$p(i) = a_{1}\\cdot F_{1}^{i} + a_{2}\\cdot F_{2}^{i} + \\cdots + a_{k}\\cdot F_{k}^{i}$。\n\n数字 $k$ 和整数系数 $a_1 , \\cdots , a_k$ 是固定的。显而易见船长知道 $k$，但不知道系数。给定 $p(1), p(2), \\cdots, p(k)$，帮助他确定 $p(k + 1)$。为了避免过大的数字，所有计算都在一个固定的素数 $M$ 模下进行。你可以假设 $F_1, F_2, \\cdots, F_n$ 在模 $M$ 下是两两不同的。你也可以假设给定的输入总是存在唯一解。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来的每个测试用例描述如下：\n\n每个测试用例的第一行包含两个整数 $k$ 和 $M$，其中 $1 \\le k \\le 4000, 3 \\le M \\le 10^{9}$。第二行包含 $k$ 个以空格分隔的整数——$p(1), p(2), \\cdots, p(k)$ 模 $M$ 的值。", "outputFormat": "按照输入中出现的顺序打印测试用例的答案。对于每个测试用例，打印一行包含一个整数：$p(k + 1)$ 模 $M$ 的值。", "hint": "时间限制：6 秒，内存限制：128 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7017", "type": "P", "difficulty": 4, "samples": [["2\n628\naa\naz\nba\nbb\nbc\nbd\nbe\nbf\nbg\nbh\nbi\nbj\nbk\nbl\nbm\nbn\nbo\nbp\nbq\nbr\nbs\nbt\nbu\nbv\nbw\nbx\nby\nca\ncb\ncc\ncd\nce\ncf\ncg\nch\nci\ncj\nck\ncl\ncm\ncn\nco\ncp\ncq\ncr\ncs\nct\ncu\ncv\ncw\ncx\ncy\nda\ndb\ndc\ndd\nde\ndf\ndg\ndh\ndi\ndj\ndk\ndl\ndm\ndn\ndo\ndp\ndq\ndr\nds\ndt\ndu\ndv\ndw\ndx\ndy\nea\neb\nec\ned\nee\nef\neg\neh\nei\nej\nek\nel\nem\nen\neo\nep\neq\ner\nes\net\neu\nev\new\nex\ney\nfa\nfb\nfc\nfd\nfe\nff\nfg\nfh\nfi\nfj\nfk\nfl\nfm\nfn\nfo\nfp\nfq\nfr\nfs\nft\nfu\nfv\nfw\nfx\nfy\nga\ngb\ngc\ngd\nge\ngf\ngg\ngh\ngi\ngj\ngk\ngl\ngm\ngn\ngo\ngp\ngq\ngr\ngs\ngt\ngu\ngv\ngw\ngx\ngy\nha\nhb\nhc\nhd\nhe\nhf\nhg\nhh\nhi\nhj\nhk\nhl\nhm\nhn\nho\nhp\nhq\nhr\nhs\nht\nhu\nhv\nhw\nhx\nhy\nia\nib\nic\nid\nie\nif\nig\nih\nii\nij\nik\nil\nim\nin\nio\nip\niq\nir\nis\nit\niu\niv\niw\nix\niy\nja\njb\njc\njd\nje\njf\njg\njh\nji\njj\njk\njl\njm\njn\njo\njp\njq\njr\njs\njt\nju\njv\njw\njx\njy\nka\nkb\nkc\nkd\nke\nkf\nkg\nkh\nki\nkj\nkk\nkl\nkm\nkn\nko\nkp\nkq\nkr\nks\nkt\nku\nkv\nkw\nkx\nky\nla\nlb\nlc\nld\nle\nlf\nlg\nlh\nli\nlj\nlk\nll\nlm\nln\nlo\nlp\nlq\nlr\nls\nlt\nlu\nlv\nlw\nlx\nly\nma\nmb\nmc\nmd\nme\nmf\nmg\nmh\nmi\nmj\nmk\nml\nmm\nmn\nmo\nmp\nmq\nmr\nms\nmt\nmu\nmv\nmw\nmx\nmy\nna\nnb\nnc\nnd\nne\nnf\nng\nnh\nni\nnj\nnk\nnl\nnm\nnn\nno\nnp\nnq\nnr\nns\nnt\nnu\nnv\nnw\nnx\nny\noa\nob\noc\nod\noe\nof\nog\noh\noi\noj\nok\nol\nom\non\noo\nop\noq\nor\nos\not\nou\nov\now\nox\noy\npa\npb\npc\npd\npe\npf\npg\nph\npi\npj\npk\npl\npm\npn\npo\npp\npq\npr\nps\npt\npu\npv\npw\npx\npy\nqa\nqb\nqc\nqd\nqe\nqf\nqg\nqh\nqi\nqj\nqk\nql\nqm\nqn\nqo\nqp\nqq\nqr\nqs\nqt\nqu\nqv\nqw\nqx\nqy\nra\nrb\nrc\nrd\nre\nrf\nrg\nrh\nri\nrj\nrk\nrl\nrm\nrn\nro\nrp\nrq\nrr\nrs\nrt\nru\nrv\nrw\nrx\nry\nsa\nsb\nsc\nsd\nse\nsf\nsg\nsh\nsi\nsj\nsk\nsl\nsm\nsn\nso\nsp\nsq\nsr\nss\nst\nsu\nsv\nsw\nsx\nsy\nta\ntb\ntc\ntd\nte\ntf\ntg\nth\nti\ntj\ntk\ntl\ntm\ntn\nto\ntp\ntq\ntr\nts\ntt\ntu\ntv\ntw\ntx\nty\nua\nub\nuc\nud\nue\nuf\nug\nuh\nui\nuj\nuk\nul\num\nun\nuo\nup\nuq\nur\nus\nut\nuu\nuv\nuw\nux\nuy\nva\nvb\nvc\nvd\nve\nvf\nvg\nvh\nvi\nvj\nvk\nvl\nvm\nvn\nvo\nvp\nvq\nvr\nvs\nvt\nvu\nvv\nvw\nvx\nvy\nwa\nwb\nwc\nwd\nwe\nwf\nwg\nwh\nwi\nwj\nwk\nwl\nwm\nwn\nwo\nwp\nwq\nwr\nws\nwt\nwu\nwv\nww\nwx\nwy\nxa\nxb\nxc\nxd\nxe\nxf\nxg\nxh\nxi\nxj\nxk\nxl\nxm\nxn\nxo\nxp\nxq\nxr\nxs\nxt\nxu\nxv\nxw\nxx\nxy\nya\nyb\nyc\nyd\nye\nyf\nyg\nyh\nyi\nyj\nyk\nyl\nym\nyn\nyo\nyp\nyq\nyr\nys\nyt\nyu\nyv\nyw\nyx\nyy\nza\nzb\nzc\nzd\nze\nzf\nzg\nzh\nzi\nzj\nzk\nzl\nzm\nzn\nzo\nzp\nzq\nzr\nzs\nzt\nzu\nzv\nzw\nzx\nzy\nzz\n2\naa\nbb\n", "aw\nwz\nabababababababababab\nbabababababababababa\nabababababababababab\nbabababababababababa\nabababababababababab\nbabababababababababa\nabababababababababab\nbabababababababababa\nabababababababababab\nbabababababababababa\nabababababababababab\nbabababababababababa\nabababababababababab\nbabababababababababa\nabababababababababab\nbabababababababababa\nabababababababababab\nbabababababababababa\nabababababababababab\nbabababababababababa\n"]], "limits": {"time": [2000, 2000], "memory": [1048576, 1048576]}, "tags": ["2013", "Special Judge", "ICPC", "CERC"], "title": "[CERC2013] Digraphs", "background": "", "description": "A digraph is a graph with orientation... oh, sorry, not this time. Let's stop being nerds for a minute and talk about languages (human languages, not PHP).\n\nDigraphs are pairs of characters that represent one phoneme (sound). For example, \"ch\" in English (as in \"church\") is a single consonant sound. The languages of Central Europe are fond of digraphs: Hungarian \"sz\", Czech \"ch\" and Polish \"rz\" are fine examples of them.\n\nDigraphs are very annoying for people who do not use them natively. We will make up a letter-puzzle specifically for those people. Given a list of digraphs, construct a biggest possible square of lower case English letters such that its rows and columns do not contain any of these digraphs. This means that no two consecutive letters (read from top to bottom or from left to right) can form a digraph.\n", "inputFormat": "\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nEach test case starts with an integer $n , 0 \\le n \\le 676$ , denoting the number of forbidden digraphs. The $n$ following lines contain the digraphs.\n", "outputFormat": "For each test case print a square of the largest possible size which does not contain any of the digraphs. If it is possible to construct a square of size $20 \\times 20$ or bigger, print only a $20 \\times 20$ square.\n\nWarning: Part of the example test data below was omitted for clarity. You can access full sample tests at your workstation. ", "hint": "Time limit: 2 s, Memory limit: 128 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[CERC2013] Digraphs", "background": "", "description": "A digraph is a graph with orientation... oh, sorry, not this time. Let's stop being nerds for a minute and talk about languages (human languages, not PHP).\n\nDigraphs are pairs of characters that represent one phoneme (sound). For example, \"ch\" in English (as in \"church\") is a single consonant sound. The languages of Central Europe are fond of digraphs: Hungarian \"sz\", Czech \"ch\" and Polish \"rz\" are fine examples of them.\n\nDigraphs are very annoying for people who do not use them natively. We will make up a letter-puzzle specifically for those people. Given a list of digraphs, construct a biggest possible square of lower case English letters such that its rows and columns do not contain any of these digraphs. This means that no two consecutive letters (read from top to bottom or from left to right) can form a digraph.\n", "inputFormat": "\nThe first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:\n\nEach test case starts with an integer $n , 0 \\le n \\le 676$ , denoting the number of forbidden digraphs. The $n$ following lines contain the digraphs.\n", "outputFormat": "For each test case print a square of the largest possible size which does not contain any of the digraphs. If it is possible to construct a square of size $20 \\times 20$ or bigger, print only a $20 \\times 20$ square.\n\nWarning: Part of the example test data below was omitted for clarity. You can access full sample tests at your workstation. ", "hint": "Time limit: 2 s, Memory limit: 128 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[CERC2013] Digraphs", "background": null, "description": "有一些有向字母对，构造一个尽量大（最大 $20\\times20$）的方阵，使得这个方阵中任意两个相邻字母对（从左到右或从上到下）都不是这些有向字母对中的一个。", "inputFormat": "第一行一个整数 $T\\ (1 \\le T \\le 111)$，表示数据组数。\n\n每组数据第一行一个整数 $n\\ (0 \\le n \\le 676)$，表示有向字母对数。\n\n接下来 $n$ 行，每行 $2$ 个小写字母，表示一组有向字母对。", "outputFormat": "对于每组数据，输出一个尽量大的方阵，不包含任何一个有向字母对（如果可以构造比 $20\\times20$ 规模更大的方阵，只需要 $20\\times20$ 规模就够了）。\n\n如果有多组解，输出任意一组即可。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P7018", "type": "P", "difficulty": 1, "samples": [["2\n1\n3\n", "1\n7\n"]], "limits": {"time": [1000], "memory": [1048576]}, "tags": ["2013", "ICPC", "CERC"], "title": "[CERC2013] Bus", "background": "", "description": "A bus with $n$ passengers opens its door at the bus stop. Exactly half of its passengers and an additional half of a passenger get out. On the next stop, again, half of the passengers plus half of a passenger leave the bus. This goes on for $k$ stops in total. Knowing that the bus leaves the last stop empty, and that no one was hurt during the trip, determine the initial number $n$ of people in the bus.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe only line of each test case contains the number of stops $k$, $1 \\leq k \\leq 30$.", "outputFormat": "For each test case, output a single line containing a single integer—the initial number of bus passengers.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n Central Europe Regional Contest (CERC) 2013", "locale": "en", "translations": {"en": {"title": "[CERC2013] Bus", "background": "", "description": "A bus with $n$ passengers opens its door at the bus stop. Exactly half of its passengers and an additional half of a passenger get out. On the next stop, again, half of the passengers plus half of a passenger leave the bus. This goes on for $k$ stops in total. Knowing that the bus leaves the last stop empty, and that no one was hurt during the trip, determine the initial number $n$ of people in the bus.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe only line of each test case contains the number of stops $k$, $1 \\leq k \\leq 30$.", "outputFormat": "For each test case, output a single line containing a single integer—the initial number of bus passengers.", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n Central Europe Regional Contest (CERC) 2013", "locale": "en"}, "zh-CN": {"title": "[CERC2013] Bus", "background": "", "description": "# [CERC2013] Bus\n\n## 题面翻译\n\n有一个数 $n$ ，定义一次操作为使 $n\\rightarrow \\frac{n-1}{2}$ 。已知经过了 $k$ 次操作后 $n$ 恰好为 $0$，求 $n$。\n \n多测，有 $T$ 组数据，$T$ 在输入数据开头给出。 \n\n保证 $1\\leqslant k\\leqslant 30$。\n\n\nA bus with $n$ passengers opens its door at the bus stop. Exactly half of its passengers and an additional half of a passenger get out. On the next stop, again, half of the passengers plus half of a passenger leave the bus. This goes on for $k$ stops in total. Knowing that the bus leaves the last stop empty, and that no one was hurt during the trip, determine the initial number $n$ of people in the bus.", "inputFormat": "The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:\n\nThe only line of each test case contains the number of stops $k$, $1 \\leq k \\leq 30$.", "outputFormat": "For each test case, output a single line containing a single integer—the initial number of bus passengers.\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n2\n1\n3\n```\n\n### 样例输出 #1\n\n```\n1\n7\n```", "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n Central Europe Regional Contest (CERC) 2013", "locale": "zh-CN"}}}
{"pid": "P7019", "type": "P", "difficulty": 2, "samples": [["4\n", "4\n"], ["7\n", "11\n"], ["6\n", "14\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Auxiliary Project", "background": "", "description": "\n\nAnna has just finished her course project. She has a lot of seven-segment LED displays as leftovers and a small power source. Each display consumes power proportionally to the number of lit segments, e.g . $‘9'$ consumes twice more power than $‘7'.$\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15131/1.png)\n\nAnna wonders what is the maximum possible sum of digits she is able to achieve, if her power source is able to light $n$ segments, and she wants to light exactly $n$ segments.\n\n", "inputFormat": "\n\nThe single line of the input contains one integer $n$ -- the number of segments that should be lit $(2 \\le n \\le 10^{6}).$\n\n", "outputFormat": "\n\nOutput a single integer -- the maximum possible sum of digits that can be displayed simultaneously.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Auxiliary Project", "background": "", "description": "\n\nAnna has just finished her course project. She has a lot of seven-segment LED displays as leftovers and a small power source. Each display consumes power proportionally to the number of lit segments, e.g . $‘9'$ consumes twice more power than $‘7'.$\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15131/1.png)\n\nAnna wonders what is the maximum possible sum of digits she is able to achieve, if her power source is able to light $n$ segments, and she wants to light exactly $n$ segments.\n\n", "inputFormat": "\n\nThe single line of the input contains one integer $n$ -- the number of segments that should be lit $(2 \\le n \\le 10^{6}).$\n\n", "outputFormat": "\n\nOutput a single integer -- the maximum possible sum of digits that can be displayed simultaneously.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Auxiliary Project", "background": "", "description": "Anna 刚刚完成了她的课程项目。她有很多七段 LED 显示器作为剩余物品，还有一个小型电源。每个显示器的耗电量与点亮的段数成正比，例如，数字 $9$ 的耗电量是数字 $7$ 的两倍。\n\nAnna 想知道，如果她的电源能够点亮 $n$ 个段，并且她想要恰好点亮 $n$ 个段，那么她能够实现的最大数字和是多少。", "inputFormat": "输入的单行包含一个整数 $n$，表示应该点亮的段数 $(2 \\le n \\le 10^{6})$。", "outputFormat": "输出一个整数，表示可以同时显示的最大数字和。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7020", "type": "P", "difficulty": 3, "samples": [["a\n", "1\n"], ["B|~B\n", "2\n"], ["c|~C\n", "3\n"], ["i|c|p|c\n", "7\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Boolean Satisfiability", "background": "", "description": "\n\nBoolean satisfiability problem (SAT) is known to be a very hard problem in computer science. In this problem you are given a Boolean formula, and you need to find out if the variables of a given formula can be consistently replaced by the values true or false in such a way that the formula evaluates to true. SAT is known to be NP-complete problem. Moreover, it is NP-complete even in case of $3-CNF$ formula $(3-SAT).$ However, for example, SAT problem for $2-CNF$ formulae $(2-SAT)$ is in $P$ .\n\n$#SAT$ is the extension of SAT problem. In this problem you need to check if it is possible, and count the number of ways to assign values to variables. This problem is known to be $#P-complete$ even for $2-CNF$ formulae. We ask you to solve $#1-DNF-SAT,$ which is $#SAT$ problem for $1-DNF$ formulae.\n\nYou are given a Boolean formula in $1-DNF$ form. It means that it is a disjunction (logical or) of one or more clauses, each clause is exactly one literal, each literal is either variable or its negation (logical not).\n\nFormally:\n\n$〈formula〉 ::= 〈clause〉 | 〈formula〉 ∨ 〈clause〉$\n\n$〈clause〉 ::= 〈literal〉$\n\n$〈literal〉 ::= 〈variable〉 | ¬ 〈variable〉$\n\n$〈variable〉 ::=$ A . . . $Z |$ a . . . $z$\n\nYour task is to find the number of ways to replace all variables with values true and false (all occurrences of the same variable should be replaced with same value), such that the formula evaluates to true.\n\n", "inputFormat": "\n\nThe only line of the input file contains a logical formula in $1-DNF$ form (not longer than $1000$ symbols). Logical operations are represented by $‘|'$ (disjunction) and $‘ \\sim ' (negatio_n).$ The variables are $‘A'$ . . . $‘Z'$ and $‘a'$ . . . $‘z'$ (uppercase and lowercase letters are different variables). The formula contains neither spaces nor other characters not mentioned in the grammar.\n\n", "outputFormat": "\n\nOutput a single integer -- the answer for $#SAT$ problem for the given formula.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Boolean Satisfiability", "background": "", "description": "\n\nBoolean satisfiability problem (SAT) is known to be a very hard problem in computer science. In this problem you are given a Boolean formula, and you need to find out if the variables of a given formula can be consistently replaced by the values true or false in such a way that the formula evaluates to true. SAT is known to be NP-complete problem. Moreover, it is NP-complete even in case of $3-CNF$ formula $(3-SAT).$ However, for example, SAT problem for $2-CNF$ formulae $(2-SAT)$ is in $P$ .\n\n$#SAT$ is the extension of SAT problem. In this problem you need to check if it is possible, and count the number of ways to assign values to variables. This problem is known to be $#P-complete$ even for $2-CNF$ formulae. We ask you to solve $#1-DNF-SAT,$ which is $#SAT$ problem for $1-DNF$ formulae.\n\nYou are given a Boolean formula in $1-DNF$ form. It means that it is a disjunction (logical or) of one or more clauses, each clause is exactly one literal, each literal is either variable or its negation (logical not).\n\nFormally:\n\n$〈formula〉 ::= 〈clause〉 | 〈formula〉 ∨ 〈clause〉$\n\n$〈clause〉 ::= 〈literal〉$\n\n$〈literal〉 ::= 〈variable〉 | ¬ 〈variable〉$\n\n$〈variable〉 ::=$ A . . . $Z |$ a . . . $z$\n\nYour task is to find the number of ways to replace all variables with values true and false (all occurrences of the same variable should be replaced with same value), such that the formula evaluates to true.\n\n", "inputFormat": "\n\nThe only line of the input file contains a logical formula in $1-DNF$ form (not longer than $1000$ symbols). Logical operations are represented by $‘|'$ (disjunction) and $‘ \\sim ' (negatio_n).$ The variables are $‘A'$ . . . $‘Z'$ and $‘a'$ . . . $‘z'$ (uppercase and lowercase letters are different variables). The formula contains neither spaces nor other characters not mentioned in the grammar.\n\n", "outputFormat": "\n\nOutput a single integer -- the answer for $#SAT$ problem for the given formula.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Boolean Satisfiability", "background": "", "description": "布尔可满足性问题（SAT）在计算机科学中被认为是一个非常困难的问题。在这个问题中，给定一个布尔公式，你需要判断该公式的变量是否可以被一致地替换为真或假，使得公式的结果为真。SAT 是已知的 NP 完全问题。此外，即使在 $3-CNF$ 公式（$3-SAT$）的情况下，它也是 NP 完全的。然而，例如，对于 $2-CNF$ 公式（$2-SAT$）的 SAT 问题是在 $P$ 中的。\n\n$#SAT$ 是 SAT 问题的扩展。在这个问题中，你需要检查是否可能，并计算赋值给变量的方式的数量。这个问题即使对于 $2-CNF$ 公式也是已知的 $#P$ 完全问题。我们要求你解决 $#1-DNF-SAT$，这是 $1-DNF$ 公式的 $#SAT$ 问题。\n\n你被给定一个 $1-DNF$ 形式的布尔公式。这意味着它是一个或多个子句的析取（逻辑或），每个子句正好是一个文字，每个文字要么是变量，要么是它的否定（逻辑非）。\n\n形式化地：\n\n$\\langle \\text{formula} \\rangle ::= \\langle \\text{clause} \\rangle \\ | \\ \\langle \\text{formula} \\rangle \\lor \\langle \\text{clause} \\rangle$\n\n$\\langle \\text{clause} \\rangle ::= \\langle \\text{literal} \\rangle$\n\n$\\langle \\text{literal} \\rangle ::= \\langle \\text{variable} \\rangle \\ | \\ \neg \\langle \\text{variable} \\rangle$\n\n$\\langle \\text{variable} \\rangle ::= A \\ldots Z \\ | \\ a \\ldots z$\n\n你的任务是找到将所有变量替换为真和假（同一变量的所有出现应替换为相同的值）的方法的数量，使得公式的结果为真。", "inputFormat": "输入文件的唯一一行包含一个 $1-DNF$ 形式的逻辑公式（不超过 $1000$ 个符号）。逻辑操作由 ‘|’（析取）和 ‘~’（否定）表示。变量是 ‘A’ 到 ‘Z’ 和 ‘a’ 到 ‘z’（大写和小写字母是不同的变量）。公式不包含空格或语法中未提到的其他字符。", "outputFormat": "输出一个整数——给定公式的 $#SAT$ 问题的答案。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7021", "type": "P", "difficulty": 4, "samples": [["consonants\n", "CoNsoNaNts\n"], ["destruction\n", "dEsTrUcTiOn\n"], ["strength\n", "StRenGtH\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Consonant Fencity", "background": "", "description": "\n\nThere are two kinds of sounds in spoken languages: vowels and consonants. Vowel is a sound, produced with an open vocal tract; and consonant is pronounced in such a way that the breath is at least partly obstructed. For example, letters a and $o$ are used to express vowel sounds, while letters $b$ and $p$ are the consonants (e.g . bad, pot).\n\na vowel (e.g . silly) or as a consonant (e.g . yellow). The letter $w$ , usually used as a consonant (e.g . wet) could produce a vowel after another vowel (e.g . growth) in English, and in some languages (e.g . Welsh) it could be even the only vowel in a word.\n\nIn this task, we consider $y$ and $w$ as vowels, so there are seven vowels in English alphabet: a , $e , i , o , u , w$ and $y$ , all other letters are consonants.\n\nLet's define the consonant fencity of a string as the number of pairs of consecutive letters in the string which both are consonants and have different cases (lowercase letter followed by uppercase or vice versa). For example, the consonant fencity of a string CoNsoNaNts is $2$ , the consonant fencity of a string dEsTrUcTiOn is $3$ and the consonant fencity of string StRenGtH is $5$ .\n\nYou will be given a string consisting of lowercase English letters. Your task is to change the case of some letters in such a way that all equal letters will be of the same case (that means, no letter can occur in resulting string as both lowercase and uppercase), and the consonant fencity of resulting string is maximal.\n\n", "inputFormat": "\n\nThe only line of the input contains non-empty original string consisting of no more than $10^{6}$ lowercase English letters.\n\n", "outputFormat": "\n\nOutput the only line: the input string changed to have maximum consonant fencity.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Consonant Fencity", "background": "", "description": "\n\nThere are two kinds of sounds in spoken languages: vowels and consonants. Vowel is a sound, produced with an open vocal tract; and consonant is pronounced in such a way that the breath is at least partly obstructed. For example, letters a and $o$ are used to express vowel sounds, while letters $b$ and $p$ are the consonants (e.g . bad, pot).\n\na vowel (e.g . silly) or as a consonant (e.g . yellow). The letter $w$ , usually used as a consonant (e.g . wet) could produce a vowel after another vowel (e.g . growth) in English, and in some languages (e.g . Welsh) it could be even the only vowel in a word.\n\nIn this task, we consider $y$ and $w$ as vowels, so there are seven vowels in English alphabet: a , $e , i , o , u , w$ and $y$ , all other letters are consonants.\n\nLet's define the consonant fencity of a string as the number of pairs of consecutive letters in the string which both are consonants and have different cases (lowercase letter followed by uppercase or vice versa). For example, the consonant fencity of a string CoNsoNaNts is $2$ , the consonant fencity of a string dEsTrUcTiOn is $3$ and the consonant fencity of string StRenGtH is $5$ .\n\nYou will be given a string consisting of lowercase English letters. Your task is to change the case of some letters in such a way that all equal letters will be of the same case (that means, no letter can occur in resulting string as both lowercase and uppercase), and the consonant fencity of resulting string is maximal.\n\n", "inputFormat": "\n\nThe only line of the input contains non-empty original string consisting of no more than $10^{6}$ lowercase English letters.\n\n", "outputFormat": "\n\nOutput the only line: the input string changed to have maximum consonant fencity.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Consonant Fencity", "background": "", "description": "在口语中有两种声音：元音和辅音。元音是通过开放的声道发出的声音；而辅音的发音方式是气流至少部分受阻。例如，字母 a 和 $o$ 用来表达元音，而字母 $b$ 和 $p$ 是辅音（例如 bad, pot）。\n\n字母 $y$ 可以作为元音（例如 silly）或辅音（例如 yellow）。字母 $w$ 通常用作辅音（例如 wet），但在另一个元音之后可以发出元音（例如 growth），在某些语言中（例如威尔士语），它甚至可以是单词中的唯一元音。\n\n在这个任务中，我们将 $y$ 和 $w$ 视为元音，所以在英语字母表中有七个元音：a, $e, i, o, u, w$ 和 $y$，其他所有字母都是辅音。\n\n我们定义一个字符串的辅音密度为字符串中连续字母对的数量，这些字母对都是辅音并且大小写不同（小写字母后跟大写字母或反之亦然）。例如，字符串 CoNsoNaNts 的辅音密度是 $2$，字符串 dEsTrUcTiOn 的辅音密度是 $3$，字符串 StRenGtH 的辅音密度是 $5$。\n\n你将得到一个由小写英文字母组成的字符串。你的任务是改变一些字母的大小写，使得所有相同的字母都具有相同的大小写（这意味着，结果字符串中不能同时出现同一个字母的小写和大写形式），并且结果字符串的辅音密度最大化。", "inputFormat": "输入的唯一一行包含一个非空的原始字符串，由不超过 $10^6$ 个小写英文字母组成。", "outputFormat": "输出唯一一行：将输入字符串更改为具有最大辅音密度的形式。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7022", "type": "P", "difficulty": 6, "samples": [["2\n1 0 1 0\n0 1 2 3\n", "3\n6 2 4\n4 2 2\n2 1 1\n5\n15 10 5\n10 5 5\n5 1 4\n4 2 2\n2 1 1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Dividing Marbles", "background": "", "description": "\n\nDebbie, Debby, Debra and Deborah are going to play a game with marbles together. Debbie has brought $2^{d_{1}}$ marbles, Debby -- $2^{d_{2}}$ marbles, Debra -- $2^{d3}$ marbles, while Deborah -- $2^{d4}$ marbles. The kids have gathered their marbles into a single pile containing $2^{d_{1}} + 2^{d_{2}} + 2^{d_{3}} + 2^{d_{4}}$ marbles, and the game is starting.\n\nThe game consists of turns. Each turn consists of two steps:\n\nThe kids choose any of their piles with more than one marble and divide it into two non-empty piles. That is, if the chosen pile contains $m \\ge 2$ marbles, the new piles must contain $m_{1}$ and $m_{2}$ marbles where $m_1$ and $m_2$ are positive integers, and $m_{1} + m_{2} = m$ .\n\nIf there are several piles with the same number of marbles, only one of these piles is kept, while all the others with this number of marbles are discarded (thrown away).\n\nThe game ends when only one pile is left, and this pile contains a single marble. The goal of the game is to end it in the least possible number of turns. Note that the game is cooperative, that is, the kids aren't playing against each other, but trying to reach a common goal together.\n\nHelp the kids and find the best way to play.\n\n", "inputFormat": "\n\nThe first line of the input contains a single integer $T$ -- the number of test cases $(1 \\le T \\le 500)$ .\n\nEach of the next $T$ lines describes one test case and contains four non-negative integers $d_{1}, d_{2}, d_{3}, d_{4} (0 \\le d_{i} \\le 20)$ .\n\n", "outputFormat": "\n\nFor each test case, output an integer $t$ -- the smallest number of turns required to end the game.\n\nThen, output $t$ turn descriptions, in the order the turns should be made. Each description should consist of three integers $m , m_{1}, m_{2}$ -- the size of the divided pile and the sizes of the new piles, respectively $(m \\ge 2$ ; $m_{1} > 0$ ; $m_{2} > 0$ ; $m_{1} + m_{2} = m)$ . Note that a pile of size $m$ must exist at that moment, and at the end of the game there should be only one pile left and that pile should contain a single marble.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Dividing Marbles", "background": "", "description": "\n\nDebbie, Debby, Debra and Deborah are going to play a game with marbles together. Debbie has brought $2^{d_{1}}$ marbles, Debby -- $2^{d_{2}}$ marbles, Debra -- $2^{d3}$ marbles, while Deborah -- $2^{d4}$ marbles. The kids have gathered their marbles into a single pile containing $2^{d_{1}} + 2^{d_{2}} + 2^{d_{3}} + 2^{d_{4}}$ marbles, and the game is starting.\n\nThe game consists of turns. Each turn consists of two steps:\n\nThe kids choose any of their piles with more than one marble and divide it into two non-empty piles. That is, if the chosen pile contains $m \\ge 2$ marbles, the new piles must contain $m_{1}$ and $m_{2}$ marbles where $m_1$ and $m_2$ are positive integers, and $m_{1} + m_{2} = m$ .\n\nIf there are several piles with the same number of marbles, only one of these piles is kept, while all the others with this number of marbles are discarded (thrown away).\n\nThe game ends when only one pile is left, and this pile contains a single marble. The goal of the game is to end it in the least possible number of turns. Note that the game is cooperative, that is, the kids aren't playing against each other, but trying to reach a common goal together.\n\nHelp the kids and find the best way to play.\n\n", "inputFormat": "\n\nThe first line of the input contains a single integer $T$ -- the number of test cases $(1 \\le T \\le 500)$ .\n\nEach of the next $T$ lines describes one test case and contains four non-negative integers $d_{1}, d_{2}, d_{3}, d_{4} (0 \\le d_{i} \\le 20)$ .\n\n", "outputFormat": "\n\nFor each test case, output an integer $t$ -- the smallest number of turns required to end the game.\n\nThen, output $t$ turn descriptions, in the order the turns should be made. Each description should consist of three integers $m , m_{1}, m_{2}$ -- the size of the divided pile and the sizes of the new piles, respectively $(m \\ge 2$ ; $m_{1} > 0$ ; $m_{2} > 0$ ; $m_{1} + m_{2} = m)$ . Note that a pile of size $m$ must exist at that moment, and at the end of the game there should be only one pile left and that pile should contain a single marble.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Dividing Marbles", "background": "", "description": "Debbie, Debby, Debra 和 Deborah要一起玩一个关于弹珠的游戏。Debbie 带来了  $2^{d_{1}}$ 颗弹珠, Debby 带来了  $2^{d_{2}}$ 颗弹珠, Debra 带来了  $2^{d3}$ 颗弹珠, 而 Deborah 带来了  $2^{d4}$ 颗弹珠。这些孩子们把他们的弹珠放在一起，总共有 $2^{d_{1}} + 2^{d_{2}} + 2^{d_{3}} + 2^{d_{4}}$ 颗, 游戏开始了。\n\n游戏是多回合制。每一个回合包括两个步骤：\n\n这些孩子们选择他们的任意一堆大于1个的弹珠然后分入两个大于0个的堆中。相当于，如果选中的那堆有 $m \\ge 2$ 颗弹珠, 新的一堆必须要有 $m_{1}$ 和 $m_{2}$ 颗弹珠且 $m_1$ 和 $m_2$ 为正整数, 且 $m_{1} + m_{2} = m$.\n\n如果有许多堆拥有同样数目的弹珠，只有一堆会被保留，其他的都会被丢弃。\n\n当只有一堆弹珠被留下且这堆弹珠只有一颗时，游戏就结束了。游戏的目标就是用尽量少的回合让游戏结束。注意这个游戏是合作性质的，那就是，这些孩子不是互相争斗的，而是一起尝试达成同一个目标。\n\n请帮助这些孩子找到游戏的最佳方案。", "inputFormat": "第一行包括一个单独的整数，T 即测试用例的数量$(1≤T≤500)$ .\n\n下面的每一行都描述一个测试用例且包含四个非负整数 $d_{1}, d_{2}, d_{3}, d_{4} (0 \\le d_{i} \\le 20)$", "outputFormat": "对于每一个测试用例，输出一个整数t，即游戏结束所需的最少次数。\n\n然后，按照回合的顺序，输出这些回合的说明。每一行说明都要包括三个整数 $ m , m_{1}, m_{2}$ 即是被分的堆和新堆的弹珠数量，依次为$(m≥2 ; m_{1} > 0; m_{2} > 0 ;  m_{1} + m_{2} = m)$ \n\n请注意大小为m的弹珠堆一定要存在，且在游戏结束时应该只剩下一堆且那一堆应该只有一颗弹珠。", "hint": "时间限制: 3 s, 内存限制: 512 MB.", "locale": "zh-CN"}}}
{"pid": "P7023", "type": "P", "difficulty": 4, "samples": [["6\n3 4 1 2 1 2\n", "4 4 3 3 2 2 1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Equal Numbers", "background": "", "description": "\n\nYou are given a list of $n$ integers $a_{1},$ . . . , $a_{n}.$ You can perform the following operation: choose some $a_{i}$ and multiply it by any positive integer.\n\nYour task is to compute the minimum number of different integers that could be on the list after $k$ operations for all $0 \\le k \\le n$ .\n\n", "inputFormat": "\n\nThe first line of the input contains single integer $n (1 \\le n \\le 3·10^{5}).$ The second line of the input contains $n$ integers $a_{i} (1 \\le a_{i} \\le 10^{6}).$\n\n", "outputFormat": "\n\nOutput a single line that contains $n + 1$ integers. The i-th integer should be the minimum possible number of different integers in the list after $i − 1$ operations.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Equal Numbers", "background": "", "description": "\n\nYou are given a list of $n$ integers $a_{1},$ . . . , $a_{n}.$ You can perform the following operation: choose some $a_{i}$ and multiply it by any positive integer.\n\nYour task is to compute the minimum number of different integers that could be on the list after $k$ operations for all $0 \\le k \\le n$ .\n\n", "inputFormat": "\n\nThe first line of the input contains single integer $n (1 \\le n \\le 3·10^{5}).$ The second line of the input contains $n$ integers $a_{i} (1 \\le a_{i} \\le 10^{6}).$\n\n", "outputFormat": "\n\nOutput a single line that contains $n + 1$ integers. The i-th integer should be the minimum possible number of different integers in the list after $i − 1$ operations.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Equal Numbers", "background": "", "description": "给定一个包含 $n$ 个整数 $a_{1}, \\ldots, a_{n}$ 的列表。你可以执行以下操作：选择某个 $a_{i}$ 并将其乘以任意正整数。  \n\n你的任务是计算在进行 $k$ 次操作后列表中可能出现的不同整数的最小数量，要求对所有 $0 \\le k \\le n$ 都进行计算。", "inputFormat": "输入的第一行包含一个整数 $n (1 \\le n \\le 3 \\times 10^{5})$。输入的第二行包含 $n$ 个整数 $a_{i} (1 \\le a_{i} \\le 10^{6})$。", "outputFormat": "输出一行包含 $n + 1$ 个整数。第 $i$ 个整数应为在进行 $i - 1$ 次操作后列表中可能的不同整数的最小数量。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7024", "type": "P", "difficulty": 6, "samples": [["4\nfor i in range(1, n):\n    for j in range(1, i):\n        for k in range(j, n):\n            lag", "3 1/3\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Fygon 2.0", "background": "", "description": "\n\nThe new version of beloved programming language Fygon has been released! The brand new Fygon $2$ . $0$ still has only two statements. The first statement is lag. It substitutes almost any other statement. Second statement is a for loop:\n\n```\nfor <variable> in range(<from>, <to>):\n    <body>\n```\n\nThe for loop makes iterate from to , both inclusive.\n\nIf is greater than , is not executed at all.\n\nis a lowercase letter from a to $z$ , except for $n$ , which is a variable that is defined prior to the given code snippet.\n\nand can be equal to any variable defined in outer loop. In addition to that, can be $1$ and can be $n$ .\n\nThe of the loop is indented by four spaces and contains at least one statement.\n\nIf you are familiar with Fygon $1$ . $0$ , you can notice that, in the spirit of the best programming practices, Fygon $2$ . $0$ is not backwards compatible, since the range function now requires two parameters.\n\nThe performance of the new version is significantly improved, so you can write more nested for loops. That is why we are no longer interested in the exact number of operations, but in the asymptotic complexity of the program instead. For simplicity, all for loops are nested in a single chain and there is exactly one lag statement that is inside all for loops. All loop variables are different and are not equal to $n$ .\n\nLet's define $f(n)$ as the number of lag operations exectuted by a given Fygon program as the function of $n$ . For non-negative integer $k$ and positive rational number $C$ we say that $C · n^{k}$ is the asymptotic complexity of the program if\n\n$$\\lim_{n \\to \\infty}{\\frac{f(n)}{C \\cdot n^k}} = 1$$\n\nGiven a Fygon $2$ . $0$ program, find its asymptotic complexity.\n\n", "inputFormat": "\n\nThe first line of the input contains single integer $m$ -- the number of lines in Fygon $2$ . $0$ program. Next $m$ lines contain the program itself. The program has at least $1$ and at most $20$ for statements. Each for statement contains either single nested for statement or lag statement.\n\n", "outputFormat": "\n\nOutput numbers $k$ and $C$ . $C$ should be output in the form of irreducible fraction $p/q$ , where $p$ and $q$ are coprime.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Fygon 2.0", "background": "", "description": "\n\nThe new version of beloved programming language Fygon has been released! The brand new Fygon $2$ . $0$ still has only two statements. The first statement is lag. It substitutes almost any other statement. Second statement is a for loop:\n\n```\nfor <variable> in range(<from>, <to>):\n    <body>\n```\n\nThe for loop makes iterate from to , both inclusive.\n\nIf is greater than , is not executed at all.\n\nis a lowercase letter from a to $z$ , except for $n$ , which is a variable that is defined prior to the given code snippet.\n\nand can be equal to any variable defined in outer loop. In addition to that, can be $1$ and can be $n$ .\n\nThe of the loop is indented by four spaces and contains at least one statement.\n\nIf you are familiar with Fygon $1$ . $0$ , you can notice that, in the spirit of the best programming practices, Fygon $2$ . $0$ is not backwards compatible, since the range function now requires two parameters.\n\nThe performance of the new version is significantly improved, so you can write more nested for loops. That is why we are no longer interested in the exact number of operations, but in the asymptotic complexity of the program instead. For simplicity, all for loops are nested in a single chain and there is exactly one lag statement that is inside all for loops. All loop variables are different and are not equal to $n$ .\n\nLet's define $f(n)$ as the number of lag operations exectuted by a given Fygon program as the function of $n$ . For non-negative integer $k$ and positive rational number $C$ we say that $C · n^{k}$ is the asymptotic complexity of the program if\n\n$$\\lim_{n \\to \\infty}{\\frac{f(n)}{C \\cdot n^k}} = 1$$\n\nGiven a Fygon $2$ . $0$ program, find its asymptotic complexity.\n\n", "inputFormat": "\n\nThe first line of the input contains single integer $m$ -- the number of lines in Fygon $2$ . $0$ program. Next $m$ lines contain the program itself. The program has at least $1$ and at most $20$ for statements. Each for statement contains either single nested for statement or lag statement.\n\n", "outputFormat": "\n\nOutput numbers $k$ and $C$ . $C$ should be output in the form of irreducible fraction $p/q$ , where $p$ and $q$ are coprime.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Fygon 2.0", "background": "", "description": "心爱的编程语言 Fygon 的新版本发布了！全新的 Fygon 2.0 仍然只有两个语句。第一个语句是 lag。它几乎可以替代任何其他语句。第二个语句是一个 for 循环：\n\n```\nfor <variable> in range(<from>, <to>):\n    <body>\n```\n\nfor 循环使得从 from 到 to 进行迭代，包含两端。\n\n如果 from 大于 to，则循环体不执行。\n\n<variable> 是从 a 到 z 的小写字母，除了 n，它是一个在给定代码片段之前定义的变量。\n\n<from> 和 <to> 可以等于外层循环中定义的任何变量。此外，<from> 可以是 1，<to> 可以是 n。\n\n循环体缩进四个空格，并且至少包含一个语句。\n\n如果你熟悉 Fygon 1.0，你会注意到，秉承最佳编程实践的精神，Fygon 2.0 不向后兼容，因为 range 函数现在需要两个参数。\n\n新版本的性能显著提高，因此你可以编写更多嵌套的 for 循环。这就是为什么我们不再关注操作的确切数量，而是关注程序的渐进复杂性。为简单起见，所有 for 循环都嵌套在一个链中，并且在所有 for 循环中恰好有一个 lag 语句。所有循环变量都不同，并且不等于 n。\n\n让我们定义 $f(n)$ 为给定 Fygon 程序执行的 lag 操作的数量，作为 n 的函数。对于非负整数 $k$ 和正有理数 $C$，如果\n\n$$\\lim_{n \\to \\infty}{\\frac{f(n)}{C \\cdot n^k}} = 1$$\n\n我们称 $C \\cdot n^{k}$ 是程序的渐进复杂性。\n\n给定一个 Fygon 2.0 程序，找出其渐进复杂性。", "inputFormat": "输入的第一行包含单个整数 $m$ —— Fygon 2.0 程序中的行数。接下来的 $m$ 行包含程序本身。程序至少有 1 个，最多有 20 个 for 语句。每个 for 语句包含一个嵌套的 for 语句或 lag 语句。", "outputFormat": "输出数字 $k$ 和 $C$。$C$ 应以不可约分数 $p/q$ 的形式输出，其中 $p$ 和 $q$ 互质。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7025", "type": "P", "difficulty": 6, "samples": [["2\n6 6\n3 6\n3 4\n1 4\n1 2\n1 3\n2 3\n3 1\n1 2\n", "1 3\n3 1 2 3\n2 1 3\n3 1 4 3\n-1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Grand Test", "background": "", "description": "\n\nJeremy, Richard and James like to test cars. It is always hard for them to decide where they should do it. Usually car test looks like this. They choose a country and examine its cities and two-way roads that connect them. To perform a test, they need to choose two different cities $S$ and $F$ , such that there exist three routes between them. Moreover, each city except $S$ and $F$ should be visited by at most one route, and none of the roads may be used twice.\n\nThen each of them takes a car in city $S$ , drives along one of those routes and tries to get to city $F$ faster than others.\n\nYou are given a description of multiple countries. For each country you should decide if it is possible to choose two cities and three routes between them in a way described above.\n\n", "inputFormat": "\n\nThe first line of the input contains a single integer $T$ -- number of countries $(1 \\le T \\le 100 000)$ . It is followed by $T$ country descriptions.\n\nThe first line of each country description contains two integers $n$ and $m$ -- the number of its cities and roads $(1 \\le n , m \\le 100 000)$ . The following $m$ lines contain two integer numbers each: $u_{i}$ and $v_{i}$ -- the cities at the ends of the road $(1 \\le u_{i} < v_{i} \\le n)$ . All roads are two-way. Each pair of cities is connected by at most one road.\n\nBoth the total number of cities and roads in all countries does not exceed $100 000$ .\n\n", "outputFormat": "\n\nOutput the answer for each country in the order they are given in the input.\n\nIf it is not possible to test cars in this country, the answer is $−1$ . Otherwise the first line of the answer should contain two integers $S$ and $F$ -- start and finish cities. The next three lines should contain three distinct routes. Each route is described by an integer $k$ -- the number of cities it visits, and $k$ numbers $v_{1}, v_{2}, \\cdots , v_{k}$ -- the cities, where $v_{1} = S , v_{k} = F$ , and there is a road between cities $v_{i}$ and $v_{i+1}$ for all $1 \\le i \\le k − 1$ .\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Grand Test", "background": "", "description": "\n\nJeremy, Richard and James like to test cars. It is always hard for them to decide where they should do it. Usually car test looks like this. They choose a country and examine its cities and two-way roads that connect them. To perform a test, they need to choose two different cities $S$ and $F$ , such that there exist three routes between them. Moreover, each city except $S$ and $F$ should be visited by at most one route, and none of the roads may be used twice.\n\nThen each of them takes a car in city $S$ , drives along one of those routes and tries to get to city $F$ faster than others.\n\nYou are given a description of multiple countries. For each country you should decide if it is possible to choose two cities and three routes between them in a way described above.\n\n", "inputFormat": "\n\nThe first line of the input contains a single integer $T$ -- number of countries $(1 \\le T \\le 100 000)$ . It is followed by $T$ country descriptions.\n\nThe first line of each country description contains two integers $n$ and $m$ -- the number of its cities and roads $(1 \\le n , m \\le 100 000)$ . The following $m$ lines contain two integer numbers each: $u_{i}$ and $v_{i}$ -- the cities at the ends of the road $(1 \\le u_{i} < v_{i} \\le n)$ . All roads are two-way. Each pair of cities is connected by at most one road.\n\nBoth the total number of cities and roads in all countries does not exceed $100 000$ .\n\n", "outputFormat": "\n\nOutput the answer for each country in the order they are given in the input.\n\nIf it is not possible to test cars in this country, the answer is $−1$ . Otherwise the first line of the answer should contain two integers $S$ and $F$ -- start and finish cities. The next three lines should contain three distinct routes. Each route is described by an integer $k$ -- the number of cities it visits, and $k$ numbers $v_{1}, v_{2}, \\cdots , v_{k}$ -- the cities, where $v_{1} = S , v_{k} = F$ , and there is a road between cities $v_{i}$ and $v_{i+1}$ for all $1 \\le i \\le k − 1$ .\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Grand Test", "background": "", "description": "给定一张 $n$ 个节点 $m$ 条边的无向图，请在图中找出两个点 $S$ 和 $F$，使得这两点间至少存在三条不相交的路径。", "inputFormat": "输入的第一行包数据组数 $T(1 \\leq T \\leq 100000)$。对于每组数据，第一行为两个整数 $n$ 和 $m$。接下来 $m$ 行每行包含两个整数 $u$ 和 $v(1 \\leq u < v \\leq n)$，表示节点 $u$ 和 $v$ 之间有一条边。每对节点至多被一条边连接。保证 $\\sum n$ 及 $\\sum m$ 不超过 $100000$。", "outputFormat": "对于每组数据，若不存在，则输出`-1`。若存在，则第一行输出 $S$ 和 $F$。接下来三行输出三条路径。每行先输出路径路径包含的点数，然后依次输出由 $S$ 到 $F$ 的路径上各点。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7026", "type": "P", "difficulty": 6, "samples": [["6\n3 1 0 4 4\n", "2\n3 1 2 4 4\n"], ["6\n3 1 0 6 4\n", "3\n3 1 1 6 4\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Hidden Supervisors", "background": "", "description": "\n\nHelena works in a big company as a psychologist. Her task is to organize a team building game to enhance social relations between employees. Each employee except the Big boss has a single supervisor. So, employees of the company form a tree where each employee is a node, and the parent of that node is their supervisor. The root of the tree is the Big boss.\n\nA team building game requires teams of two people. Every team should consist of an employee and their supervisor.\n\nHelena asked every employee except the Big boss to send their supervisor ID. Some of them didn't reply. She is going to assign a fake supervisor to every employee that didn't reply, so that she could arrange as many teams as possible. And, of course, fake and real supervisors must form a tree.\n\nHelena had a difficult, but a successful day organizing the event. Will you be able to assign fake supervisors?\n\n", "inputFormat": "\n\nThe first line of the input contains a single integer $n$ -- the number of employees in the company $(2 \\le n \\le 100 000)$ .\n\nThe following line contains $n − 1$ integers $p_{2}, p_{3},$ . . . , $p_{n},$ where $p_{i}$ is the supervisor of employee $i (0 \\le p_{i} \\le n)$ . If employee $i$ didn't reply to Helena, $p_{i}$ equals zero, and she needs to assign a fake supervisor to that employee. The Big boss has the number $1$ .\n\nIt's possible to assign a fake supervisor to each employee that didn't reply to Helena so that all employees will form a tree having the Big boss as a root.\n\n", "outputFormat": "\n\nIn the first line output a single integer $m$ -- the maximum possible number of arranged teams.\n\nThe next line should contain supervisors: $n−1$ integers, i-th of which denoting the supervisor of employee $i + 1$ (either fake or real). Of course, all real supervisors should be preserved, and employees must form a tree. It should be possible to arrange $m$ teams using specified supervisors.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Hidden Supervisors", "background": "", "description": "\n\nHelena works in a big company as a psychologist. Her task is to organize a team building game to enhance social relations between employees. Each employee except the Big boss has a single supervisor. So, employees of the company form a tree where each employee is a node, and the parent of that node is their supervisor. The root of the tree is the Big boss.\n\nA team building game requires teams of two people. Every team should consist of an employee and their supervisor.\n\nHelena asked every employee except the Big boss to send their supervisor ID. Some of them didn't reply. She is going to assign a fake supervisor to every employee that didn't reply, so that she could arrange as many teams as possible. And, of course, fake and real supervisors must form a tree.\n\nHelena had a difficult, but a successful day organizing the event. Will you be able to assign fake supervisors?\n\n", "inputFormat": "\n\nThe first line of the input contains a single integer $n$ -- the number of employees in the company $(2 \\le n \\le 100 000)$ .\n\nThe following line contains $n − 1$ integers $p_{2}, p_{3},$ . . . , $p_{n},$ where $p_{i}$ is the supervisor of employee $i (0 \\le p_{i} \\le n)$ . If employee $i$ didn't reply to Helena, $p_{i}$ equals zero, and she needs to assign a fake supervisor to that employee. The Big boss has the number $1$ .\n\nIt's possible to assign a fake supervisor to each employee that didn't reply to Helena so that all employees will form a tree having the Big boss as a root.\n\n", "outputFormat": "\n\nIn the first line output a single integer $m$ -- the maximum possible number of arranged teams.\n\nThe next line should contain supervisors: $n−1$ integers, i-th of which denoting the supervisor of employee $i + 1$ (either fake or real). Of course, all real supervisors should be preserved, and employees must form a tree. It should be possible to arrange $m$ teams using specified supervisors.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Hidden Supervisors", "background": null, "description": "有一棵大小为 $n$ 的有根树，根为 $1$，其中若干结点的父亲没有确定。试求出所有可能构成的以 $1$ 为根的有根树中，最大匹配的最大值是多少，并输出构造方案。保证数据有解。", "inputFormat": "第一行输入一个整数 $n$。\n\n第二行输入 $n-1$ 个整数 $p_2,p_3,\\cdots,p_n$，分别表示 $2,3,\\cdots,n$ 的父亲。其中 $p_i = 0$ 表示点 $i$ 的父亲未确定，$p_i \\neq 0$ 表示点 $i$ 的父亲已确定。", "outputFormat": "第一行输出一个整数表示最大匹配的最大值。\n\n第二行输出 $n-1$ 个整数 $p'_2,p'_3,\\cdots,p'_n$，分别表示 $2,3,\\cdots,n$ 的父亲。", "hint": "$2\\leq n\\leq 10^5,0\\leq p_i\\leq n.$", "locale": "zh-CN"}}}
{"pid": "P7027", "type": "P", "difficulty": 2, "samples": [["10\n1 1\n6 1\n6 4\n3 4\n3 3\n5 3\n5 2\n2 2\n2 3\n1 3\n", "6\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Intelligence in Perpendicularia", "background": null, "description": "There are only two directions in Perpendicularia: vertical and horizontal. Perpendicularia government are going to build a new secret service facility. They have some proposed facility plans and want to calculate total secured perimeter for each of them.\n\nThe total secured perimeter is calculated as the total length of the facility walls invisible for the perpendicularly-looking outside observer. The figure below shows one of the proposed plans and corresponding secured perimeter.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2ao0ncji.png)\n\nWrite a program that calculates the total secured perimeter for the given plan of the secret service facility.", "inputFormat": "The plan of the secret service facility is specified as a polygon.\n\nThe first line of the input contains one integer $n$ -- the number of vertices of the polygon $(4 \\le n \\le 1000)$ . Each of the following $n$ lines contains two integers $x_{i}$ and $y_{i} -$ the coordinates of the i-th vertex $(−10^{6} \\le x_{i}, y_{i} \\le 10^{6}).$ Vertices are listed in the consecutive order.\n\nAll polygon vertices are distinct and none of them lie at the polygon's edge. All polygon edges are either vertical $(x_{i} = x_{i+1} or$ horizontal $(y_{i} = y_{i+1})$ and none of them intersect each other.", "outputFormat": "Output a single integer -- the total secured perimeter of the secret service facility.", "hint": "Time limit: 3 s, Memory limit: 512 MB.", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Intelligence in Perpendicularia", "background": null, "description": "There are only two directions in Perpendicularia: vertical and horizontal. Perpendicularia government are going to build a new secret service facility. They have some proposed facility plans and want to calculate total secured perimeter for each of them.\n\nThe total secured perimeter is calculated as the total length of the facility walls invisible for the perpendicularly-looking outside observer. The figure below shows one of the proposed plans and corresponding secured perimeter.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2ao0ncji.png)\n\nWrite a program that calculates the total secured perimeter for the given plan of the secret service facility.", "inputFormat": "The plan of the secret service facility is specified as a polygon.\n\nThe first line of the input contains one integer $n$ -- the number of vertices of the polygon $(4 \\le n \\le 1000)$ . Each of the following $n$ lines contains two integers $x_{i}$ and $y_{i} -$ the coordinates of the i-th vertex $(−10^{6} \\le x_{i}, y_{i} \\le 10^{6}).$ Vertices are listed in the consecutive order.\n\nAll polygon vertices are distinct and none of them lie at the polygon's edge. All polygon edges are either vertical $(x_{i} = x_{i+1} or$ horizontal $(y_{i} = y_{i+1})$ and none of them intersect each other.", "outputFormat": "Output a single integer -- the total secured perimeter of the secret service facility.", "hint": "Time limit: 3 s, Memory limit: 512 MB.", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Intelligence in Perpendicularia", "background": "", "description": "给你一个数 $ n $ ，再给你 $ n $ 个点（$ x_i , y_i $），这 $ n $ 个点依次连成一个多边形。（保证多边形的每条边都与坐标轴平行或垂直，点不重合，点不在边上，边无相交）\n\n求有多长的边是安全的？\n\n（一个单位长度的边是安全的当且仅当它向外平移后能与其余边相遇，结合一下图看看）", "inputFormat": "第一行一个数$ n $,表示有多少个定点。\n\n接下来 $ n $ 行，行两个数 $ x_i \\; y_i $ 表示每个点的坐标。", "outputFormat": "一个数，表示安全的长度。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7028", "type": "P", "difficulty": 6, "samples": [["4 7\n1 -5 3 -5\n4 -1\n2 -1\n3 10\n4 10\n1 -1\n2 1\n3 -1\n", "3\n1\n3\n3\n1\n4\n4\n4\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "分块", "凸包", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Joker", "background": "", "description": "\n\nJoker prepares a new card trick with a strong mathematical background. You are asked to help Joker with calculations.\n\nThere is a row of $n$ cards with non-zero numbers $a_{i}$ written on them. Let's call the sum of all positive numbers $P$ and the sum of all negative numbers $N$ . Every card $i$ has a weight $w_{i} = a_{i}/P$ if $a_{i} > 0$ and $a_{i}/|N|$ otherwise.\n\nLet's denote $s_{i} = ( \\sum_{j=1}^{j \\le i}{w_j})$. Joker needs to know positive $i$ with the largest $s_{i}.$ If there is more than one such $i$ , he is interested in the smallest one.\n\nBut static tricks are boring, so Joker wants to change numbers on some cards, and after each change he needs to known where is the largest $s_{i}$ is.\n\n", "inputFormat": "\n\nThe first line of the input contains two integers $n$ and $m$ -- the number of cards and the number of changes $(1 \\le n , m \\le 50 000)$ .\n\nThe second line consists of $n$ integers $a_{i}$ -- numbers written on cards at the beginning $(−10^{9} \\le a_{i} \\le 10^{9}; a_{i} ≠ 0)$ .\n\nThe following $m$ lines contain two integers each: $p_{i}$ and $v_{i},$ that means value of card at position $p_{i}$ is changed to $v_{i} (1 \\le p_{i} \\le n$ ; $−10^{9} \\le v_{i} \\le 10^{9}; v_{i} ≠ 0)$ .\n\nIt is guaranteed that at each moment there is at least one card with positive number and at least one card with negative number. The sum of all positive cards will never exceed $10^{9}$ and the sum of all negative cards will never exceed $−10^{9}.$\n\n", "outputFormat": "\n\nYou should output $m+1$ integers. The first integer is the position of the largest $s_{i}$ for the initial numbers. Next $m$ numbers are positions of the largest $s_{i}$ after each change.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Joker", "background": "", "description": "\n\nJoker prepares a new card trick with a strong mathematical background. You are asked to help Joker with calculations.\n\nThere is a row of $n$ cards with non-zero numbers $a_{i}$ written on them. Let's call the sum of all positive numbers $P$ and the sum of all negative numbers $N$ . Every card $i$ has a weight $w_{i} = a_{i}/P$ if $a_{i} > 0$ and $a_{i}/|N|$ otherwise.\n\nLet's denote $s_{i} = ( \\sum_{j=1}^{j \\le i}{w_j})$. Joker needs to know positive $i$ with the largest $s_{i}.$ If there is more than one such $i$ , he is interested in the smallest one.\n\nBut static tricks are boring, so Joker wants to change numbers on some cards, and after each change he needs to known where is the largest $s_{i}$ is.\n\n", "inputFormat": "\n\nThe first line of the input contains two integers $n$ and $m$ -- the number of cards and the number of changes $(1 \\le n , m \\le 50 000)$ .\n\nThe second line consists of $n$ integers $a_{i}$ -- numbers written on cards at the beginning $(−10^{9} \\le a_{i} \\le 10^{9}; a_{i} ≠ 0)$ .\n\nThe following $m$ lines contain two integers each: $p_{i}$ and $v_{i},$ that means value of card at position $p_{i}$ is changed to $v_{i} (1 \\le p_{i} \\le n$ ; $−10^{9} \\le v_{i} \\le 10^{9}; v_{i} ≠ 0)$ .\n\nIt is guaranteed that at each moment there is at least one card with positive number and at least one card with negative number. The sum of all positive cards will never exceed $10^{9}$ and the sum of all negative cards will never exceed $−10^{9}.$\n\n", "outputFormat": "\n\nYou should output $m+1$ integers. The first integer is the position of the largest $s_{i}$ for the initial numbers. Next $m$ numbers are positions of the largest $s_{i}$ after each change.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Joker", "background": "", "description": "Joker 准备了一种新的纸牌戏法，具有强烈的数学背景。你被要求帮助 Joker 进行计算。\n\n有一排 $n$ 张牌，上面写着非零数字 $a_{i}$。我们称所有正数的和为 $P$，所有负数的和为 $N$。每张牌 $i$ 的权重为 $w_{i} = a_{i}/P$ 如果 $a_{i} > 0$，否则为 $a_{i}/|N|$。\n\n我们用 $s_{i} = ( \\sum_{j=1}^{j \\le i}{w_j})$ 表示。Joker 需要知道使 $s_{i}$ 最大的正整数 $i$。如果有多个这样的 $i$，他对最小的一个感兴趣。\n\n但静态的戏法很无聊，所以 Joker 想要改变一些牌上的数字，并且在每次改变后，他需要知道最大的 $s_{i}$ 在哪里。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $m$ —— 牌的数量和变化的次数 $(1 \\le n , m \\le 50 000)$。\n\n第二行包含 $n$ 个整数 $a_{i}$ —— 初始时牌上写的数字 $(-10^{9} \\le a_{i} \\le 10^{9}; a_{i} \neq 0)$。\n\n接下来的 $m$ 行每行包含两个整数：$p_{i}$ 和 $v_{i}$，表示位置 $p_{i}$ 的牌的值被改为 $v_{i} (1 \\le p_{i} \\le n$；$-10^{9} \\le v_{i} \\le 10^{9}; v_{i} \neq 0)$。\n\n保证在每个时刻至少有一张牌上的数字是正的，至少有一张牌上的数字是负的。所有正数牌的和不会超过 $10^{9}$，所有负数牌的和不会超过 $-10^{9}$。", "outputFormat": "你应该输出 $m+1$ 个整数。第一个整数是初始数字时最大的 $s_{i}$ 的位置。接下来的 $m$ 个数字是在每次变化后最大的 $s_{i}$ 的位置。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7029", "type": "P", "difficulty": 0, "samples": [["3 5 4\n", "..#..\n#####\n..#..\n"], ["2 1 1\n", "#\n.\n"], ["5 3 10\n", "Impossible\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Kotlin Island", "background": "", "description": "\n\nThere is an urban myth that Peter the Great wanted to make a rectangular channel-grid engineering masterpiece not only from Vasilyevskiy island, but also from Kotlin island (where the town of Kronstadt is located nowadays).\n\nThe following mathematical model was (allegedly) presented to the tsar. The island is considered a rectangular grid $h$ cells high and $w$ cells wide. Each cell is dry land initially but can become water.\n\nTechnologies of those days allowed engineers to dig a channel across the entire island. In that case an entire row or an entire column of cells became water. If some of these cells already were water, their status did not change.\n\nYour task is to propose a plan of the island which has exactly $n$ connected components of dry land cells.\n\n", "inputFormat": "\n\nThe only line of the input contains three integers $h , w$ , and $n$ -- grid's height, width and the desired number of connected components $(1 \\le h , w \\le 100$ ; $1 \\le n \\le 10^{9}).$\n\n", "outputFormat": "\n\nIf there is no valid plan containing $n$ connected components, output a single word `Impossible`.\n\nOtherwise output $h$ lines of length $w$ depicting the plan. Dot $(‘. ')$ represents a dry land cell, hash $(‘#')$ represents a water cell.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Kotlin Island", "background": "", "description": "\n\nThere is an urban myth that Peter the Great wanted to make a rectangular channel-grid engineering masterpiece not only from Vasilyevskiy island, but also from Kotlin island (where the town of Kronstadt is located nowadays).\n\nThe following mathematical model was (allegedly) presented to the tsar. The island is considered a rectangular grid $h$ cells high and $w$ cells wide. Each cell is dry land initially but can become water.\n\nTechnologies of those days allowed engineers to dig a channel across the entire island. In that case an entire row or an entire column of cells became water. If some of these cells already were water, their status did not change.\n\nYour task is to propose a plan of the island which has exactly $n$ connected components of dry land cells.\n\n", "inputFormat": "\n\nThe only line of the input contains three integers $h , w$ , and $n$ -- grid's height, width and the desired number of connected components $(1 \\le h , w \\le 100$ ; $1 \\le n \\le 10^{9}).$\n\n", "outputFormat": "\n\nIf there is no valid plan containing $n$ connected components, output a single word `Impossible`.\n\nOtherwise output $h$ lines of length $w$ depicting the plan. Dot $(‘. ')$ represents a dry land cell, hash $(‘#')$ represents a water cell.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Kotlin Island", "background": "", "description": "有一个都市传说，说彼得大帝不仅想把瓦西里耶夫斯基岛建造成一个矩形渠道网的工程杰作，还想把科特林岛（如今克朗施塔特镇所在地）也建造成这样的工程。据说，以下数学模型曾被呈现给沙皇。岛被视为一个矩形网格，高为 $h$ 个单元格，宽为 $w$ 个单元格。每个单元格最初都是陆地，但可以变成水。 当时的技术允许工程师在整个岛上挖掘一条渠道。在这种情况下，整个行或整个列的单元格变成水。如果其中一些单元格已经是水，它们的状态不会改变。你的任务是提出一个岛屿计划，使其恰好有 $n$ 个连通的陆地单元格。", "inputFormat": "输入的唯一一行包含三个整数 $h, w$ 和 $n$，分别表示网格的高度、宽度和所需的连通陆地区域的数量 $(1 \\le h, w \\le 100; 1 \\le n \\le 10^{9})$。", "outputFormat": "如果没有包含 $n$ 个连通区域的有效计划，则输出一个单词 `Impossible`。否则，输出 $h$ 行，每行长度为 $w$，描述该计划。点（‘.’）表示一个陆地单元格，井号（‘#’）表示一个水单元格。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
