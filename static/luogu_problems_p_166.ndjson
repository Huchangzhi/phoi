{"pid": "P4359", "type": "P", "difficulty": 6, "samples": [["12345 20", "9167"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["搜索", "2016", "重庆", "各省省选", "可并堆", "素数判断,质数,筛法"], "title": "[CQOI2016] 伪光滑数", "background": "", "description": "若一个大于 $1$ 的整数 $M$ 的质因数分解有 $k$ 项，其最大的质因子为 $a_k$ ，并且满足 $a_{k}^{k} \\le N$，$a_k < 128$，我们就称整数 $M$ 为 $N$ - 伪光滑数。\n\n现在给出 $N$，求所有整数中，第 $K$ 大的 $N$ - 伪光滑数。\n\n### 题意澄清\n\n设 $M = 36 = 2^2 \\times 3^2$，则其对应的 $k = 4$，也就是说，对 $M$ 运用唯一分解定理，$M = \\prod_{i=1}^n{p_i^{c_i}}$，$k = \\sum_{i=1}^n{c_i}$。\n\n第 $K$ 大为字面意思，是真的从大到小第 $K$ 个。\n\nmodified by expect2004 2020-11-25，这或许是他退役前对洛谷公共题库的最后一次贡献", "inputFormat": "只有一行，为用空格隔开的整数 $N$ 和 $K$ 。", "outputFormat": "只有一行，为一个整数，表示答案。", "hint": "对于 $30\\%$ 的数据，$N \\le 10^6$；  \n对于 $100\\%$ 的数据，$2 \\le N \\le 10^{18},1 \\le K \\le 800000$。保证至少有 $K$ 个满足要求的数。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2016] Pseudo-smooth Numbers", "background": "", "description": "If a positive integer $M > 1$ has $k$ terms in its prime factorization, its largest prime factor is $a_k$, and it satisfies $a_k^k \\le N$, $a_k < 128$, then $M$ is called an $N$-pseudo-smooth number.\n\nGiven $N$, among all integers, find the $K$-th largest $N$-pseudo-smooth number.\n\nClarification: Let $M = 36 = 2^2 \\times 3^2$. Then the corresponding $k = 4$. That is, by the Fundamental Theorem of Arithmetic, write $M = \\prod_{i=1}^n p_i^{c_i}$ and $k = \\sum_{i=1}^n c_i$. “$K$-th largest” is literal: the $K$-th from largest to smallest.\n\nModified by expect2004 on 2020-11-25; this may be his last contribution to the Luogu public problem set before retirement.", "inputFormat": "One line with two space-separated integers $N$ and $K$.", "outputFormat": "One line containing a single integer, the answer.", "hint": "For $30\\%$ of the testdata, $N \\le 10^6$.  \nFor $100\\%$ of the testdata, $2 \\le N \\le 10^{18}, 1 \\le K \\le 800000$. It is guaranteed that there are at least $K$ numbers that satisfy the requirements.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2016] 伪光滑数", "background": "", "description": "若一个大于 $1$ 的整数 $M$ 的质因数分解有 $k$ 项，其最大的质因子为 $a_k$ ，并且满足 $a_{k}^{k} \\le N$，$a_k < 128$，我们就称整数 $M$ 为 $N$ - 伪光滑数。\n\n现在给出 $N$，求所有整数中，第 $K$ 大的 $N$ - 伪光滑数。\n\n### 题意澄清\n\n设 $M = 36 = 2^2 \\times 3^2$，则其对应的 $k = 4$，也就是说，对 $M$ 运用唯一分解定理，$M = \\prod_{i=1}^n{p_i^{c_i}}$，$k = \\sum_{i=1}^n{c_i}$。\n\n第 $K$ 大为字面意思，是真的从大到小第 $K$ 个。\n\nmodified by expect2004 2020-11-25，这或许是他退役前对洛谷公共题库的最后一次贡献", "inputFormat": "只有一行，为用空格隔开的整数 $N$ 和 $K$ 。", "outputFormat": "只有一行，为一个整数，表示答案。", "hint": "对于 $30\\%$ 的数据，$N \\le 10^6$；  \n对于 $100\\%$ 的数据，$2 \\le N \\le 10^{18},1 \\le K \\le 800000$。保证至少有 $K$ 个满足要求的数。", "locale": "zh-CN"}}}
{"pid": "P4360", "type": "P", "difficulty": 6, "samples": [["9 \n1 2 \n2 1 \n3 3 \n1 1 \n3 2 \n1 6 \n2 1 \n1 2 \n1 1\n", "26"]], "limits": {"time": [200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["模拟", "动态规划 DP", "2004", "单调队列", "CEOI（中欧）", "模拟退火", "斜率优化"], "title": "[CEOI 2004] 锯木厂选址", "background": null, "description": "从山顶上到山底下沿着一条直线种植了 $n$ 棵老树。当地的人们决定把他们砍下来。为了不浪费任何一棵木材，树被砍倒后要运送到锯木厂。\n\n木材只能朝山下运。山脚下有一个锯木厂。另外两个锯木厂将新修建在山路上。你必须决定在哪里修建这两个锯木厂，使得运输的费用总和最小。假定运输每公斤木材每米需要一分钱。\n\n你的任务是编写一个程序，从输入文件中读入树的个数和他们的重量与位置，计算最小运输费用。", "inputFormat": "输入的第一行为一个正整数 $n$ ——树的个数 $(2\\leq n\\leq 20000)$。树从山顶到山脚按照 $1,2,\\dots,n$ 标号。 \n\n接下来 $n$ 行，每行有两个正整数（用空格分开）。 \n\n第 $i+1$ 行含有：$w_i$ ——第 $i$ 棵树的重量（公斤为单位）和 $d_i$——第 $i$ 棵树和第 $i+1$ 棵树之间的距离， $1\\leq w_i\\leq 10000,0\\leq d_i\\leq 10000$。 \n\n最后一颗树的 $d_n$，表示第 $n$ 棵树到山脚的锯木厂的距离。保证所有树运到山脚的锯木厂所需要的费用小于 $2\\times 10^9$ 分。", "outputFormat": "输出最小的运输费用。", "hint": "样例图示，黑点为锯木厂。\n\n![](https://cdn.luogu.com.cn/upload/pic/16339.png)\n\n本题共有 $13$ 个测试点，每个测试点的数据范围如下：\n\n测试点 $1\\sim 5$：$n\\leq 200$；\n\n测试点 $6\\sim7$：$n\\leq 1000$；\n\n测试点 $7\\sim13$：$2\\leq n\\leq 20000$。", "locale": "zh-CN", "translations": {"en": {"title": "[CEOI 2004] Sawmill Location", "background": "", "description": "Along a straight line from the mountain top to the foot, there are $n$ old trees. The locals have decided to cut them down. To avoid wasting any wood, once a tree is felled, the wood must be transported to a sawmill.\n\nLumber can only be transported downhill. There is one sawmill at the foot of the mountain. Two additional sawmills will be newly built along the mountain road. You must decide where to build these two sawmills so that the total transportation cost is minimized. Assume it costs one cent to transport $1$ kilogram by $1$ meter.\n\nYour task is to write a program that reads the number of trees and their weights and positions from the input, and computes the minimal transportation cost.", "inputFormat": "The first line contains a positive integer $n$ — the number of trees ($2 \\le n \\le 20000$). Trees are numbered $1, 2, \\dots, n$ from the mountain top down to the foot.\n\nEach of the next $n$ lines contains two integers separated by a space.\n\nThe $(i+1)$-th line contains $w_i$ — the weight of the $i$-th tree (in kilograms), and $d_i$ — the distance between the $i$-th and the $(i+1)$-th tree, with $1 \\le w_i \\le 10000$, $0 \\le d_i \\le 10000$.\n\nFor the last tree, $d_n$ denotes the distance from tree $n$ to the sawmill at the foot of the mountain. It is guaranteed that the total cost of transporting all trees to the sawmill at the foot of the mountain is less than $2 \\times 10^9$ cents.", "outputFormat": "Output the minimal transportation cost.", "hint": "The sample illustration; black dots represent sawmills.\n\n![](https://cdn.luogu.com.cn/upload/pic/16339.png)\n\nConstraints:\n- Test points $1$–$5$: $n \\le 200$.\n- Test points $6$–$7$: $n \\le 1000$.\n- Test points $7$–$13$: $2 \\le n \\le 20000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CEOI 2004] 锯木厂选址", "background": null, "description": "从山顶上到山底下沿着一条直线种植了 $n$ 棵老树。当地的人们决定把他们砍下来。为了不浪费任何一棵木材，树被砍倒后要运送到锯木厂。\n\n木材只能朝山下运。山脚下有一个锯木厂。另外两个锯木厂将新修建在山路上。你必须决定在哪里修建这两个锯木厂，使得运输的费用总和最小。假定运输每公斤木材每米需要一分钱。\n\n你的任务是编写一个程序，从输入文件中读入树的个数和他们的重量与位置，计算最小运输费用。", "inputFormat": "输入的第一行为一个正整数 $n$ ——树的个数 $(2\\leq n\\leq 20000)$。树从山顶到山脚按照 $1,2,\\dots,n$ 标号。 \n\n接下来 $n$ 行，每行有两个正整数（用空格分开）。 \n\n第 $i+1$ 行含有：$w_i$ ——第 $i$ 棵树的重量（公斤为单位）和 $d_i$——第 $i$ 棵树和第 $i+1$ 棵树之间的距离， $1\\leq w_i\\leq 10000,0\\leq d_i\\leq 10000$。 \n\n最后一颗树的 $d_n$，表示第 $n$ 棵树到山脚的锯木厂的距离。保证所有树运到山脚的锯木厂所需要的费用小于 $2\\times 10^9$ 分。", "outputFormat": "输出最小的运输费用。", "hint": "样例图示，黑点为锯木厂。\n\n![](https://cdn.luogu.com.cn/upload/pic/16339.png)\n\n本题共有 $13$ 个测试点，每个测试点的数据范围如下：\n\n测试点 $1\\sim 5$：$n\\leq 200$；\n\n测试点 $6\\sim7$：$n\\leq 1000$；\n\n测试点 $7\\sim13$：$2\\leq n\\leq 20000$。", "locale": "zh-CN"}}}
{"pid": "P4361", "type": "P", "difficulty": 6, "samples": [["0 2 1 0\n2\n0 4 3 1 1 1\n4 0 0 -4 1 1", "1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2015", "各省省选", "上海"], "title": "[SHOI2015] 激光发生器", "background": "", "description": "曾经发明了超能粒子炮・改的发明家 SHTSC 又公开了他的新发明：激光发生器——一种可以产生高能激光的神秘装置。\n\n激光发生器从正上方看是一个无穷大的平面，里面由一个定向激光发射装置和若干个激光偏转装置组成。一个激光发生器的示例如图所示，细箭头表示定向激光发射装置，粗线段表示激光偏转装置。\n\n![](https://cdn.luogu.com.cn/upload/pic/16401.png)\n\n由定向激光发射装置发射出的激光可以看成是一条射线，如果遇到激光偏转装置就会发生偏转。奇特的是，SHTSC 所使用的激光偏转装置并非像传统的镜子那样遵循反射定律，而是对于每个激光偏转装置，有一个固定的偏转系数 $λ$，其出射角 $β$ 与入射角 $α$ 的关系为 $β=λα$，并且能在这一过程中增强激光的能量。\n\n![](https://cdn.luogu.com.cn/upload/pic/16402.png)\n\n注意：\n\n1. 入射角是入射光线和反射平面法向量的夹角。\n2. 偏转装置的两面均可偏转。\n3. 如果激光平行射入偏转装置，则认为没有发生偏转。\n4. 如果不平行且照射到了端点，则认为发生偏转。\n5. 当 $β>\\frac{1}{2}π$ 时，可能会偏转到另一面。\n\n现在 SHTSC 希望你模拟他所设计的激光发生器的工作过程，来帮助他计算激光究竟被哪些激光偏转装置所偏转。", "inputFormat": "第一行四个整数 $x,y,dx,dy$。表示定向激光发射装置的位置是 $(x,y)$，方向是 $(dx,dy)$。\n\n第二行一个整数 $n$，表示一共有 $n$ 个激光偏转装置。\n以下n行，每行六个整数 $x1,y1,x2,y2,a,b$，表示一个激光偏转装置是 $(x1,y1)$ 到 $(x2,y2)$ 的一条线段，其偏转系数 $\\lambda=a/b$。\n\n$n\\leq 100$，所有坐标与 $a$ 和 $b$ 的绝对值不超过 $1000$，$a$、$b$ 均非 $0$。保证所有的偏转装置没有交点。激光发射起始点不在任何偏转装置上。方向向量不为零向量。", "outputFormat": "一行由空格隔开的若干个整数，表示激光依次照射到的激光偏转装置的编号（按照输入顺序从 $1$ 到 $n$ 编号）。如果激光被偏转超过 $10$ 次，则只需输出前 $10$ 次所照射到的偏转装置的编号。特别地，如果激光没有被任何一个偏转装置所偏转，输出 `NONE`。", "hint": "### 样例解释\n\n如图所示，激光依次被 $1$ 号和 $2$ 号偏转装置偏转。\n\n![](https://cdn.luogu.com.cn/upload/pic/16403.png)\n\n## 数据规模和约定\n\n对于 $10\\%$ 的数据，$n=1$；  \n对于 $40\\%$ 的数据，$a=b=1$；  \n对于 $100\\%$ 的数据，$n \\le 100$，所有坐标与 $a$ 和 $b$ 的绝对值不超过 $1000$，$a,b$ 均非零，$dx$ 、$dy$ 不同时为零。保证所有的偏转装置没有交点，且激光发射起始点不在任何偏转装置上。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2015] Laser Generator", "background": "", "description": "Having once invented the Super Particle Cannon · Modified, the inventor SHTSC has now unveiled his new invention: the Laser Generator — a mysterious device that can produce high-energy lasers.\n\nFrom a top-down view, the Laser Generator is an infinite plane containing one directional laser emitter and several laser deflection devices. An example is shown in the figure: the thin arrow denotes the directional laser emitter, and the thick segments denote the laser deflection devices.\n\n![](https://cdn.luogu.com.cn/upload/pic/16401.png)\n\nThe laser emitted by the directional emitter can be regarded as a ray. When it encounters a deflection device, it will be deflected. Interestingly, the deflection devices used by SHTSC do not obey the law of reflection like traditional mirrors. For each deflection device, there is a fixed deflection coefficient $λ$, and the relation between the exit angle $β$ and the incident angle $α$ is $β=λα$. The device can also amplify the laser’s energy in the process.\n\n![](https://cdn.luogu.com.cn/upload/pic/16402.png)\n\nNotes:\n1. The incident angle is the angle between the incident ray and the normal vector of the deflection plane.\n2. Both sides of a deflection device can deflect.\n3. If the laser is incident parallel to a deflection device, we consider that no deflection occurs.\n4. If it is not parallel and hits an endpoint, we consider that a deflection occurs.\n5. When $β>\\frac{1}{2}π$, it may be deflected to the other side.\n\nNow SHTSC hopes you will simulate the operation of his Laser Generator to help compute which deflection devices the laser is deflected by.", "inputFormat": "The first line contains four integers $x, y, dx, dy$, indicating that the directional laser emitter is at $(x, y)$ and points in direction $(dx, dy)$.\n\nThe second line contains an integer $n$, the number of laser deflection devices.\nThe next $n$ lines each contain six integers $x1, y1, x2, y2, a, b$, describing one deflection device as the segment from $(x1, y1)$ to $(x2, y2)$ with deflection coefficient $\\lambda=a/b$.", "outputFormat": "Output one line with a sequence of integers separated by spaces, indicating the indices of the deflection devices the laser hits in order (devices are numbered from $1$ to $n$ in input order). If the laser is deflected more than $10$ times, output only the indices of the first $10$ devices hit. In particular, if the laser is not deflected by any device, output `NONE`.", "hint": "### Sample Explanation\n\nAs shown in the figure, the laser is deflected by device $1$ and then device $2$ in order.\n\n![](https://cdn.luogu.com.cn/upload/pic/16403.png)\n\n# Constraints\n\n- For $10\\%$ of the testdata, $n=1$.\n- For $40\\%$ of the testdata, $a=b=1$.\n- For $100\\%$ of the testdata, $n \\le 100$; the absolute values of all coordinates and of $a$ and $b$ do not exceed $1000$; $a$ and $b$ are nonzero; $dx$ and $dy$ are not both zero. It is guaranteed that no two deflection devices intersect, and the starting point of the laser emitter is not on any deflection device.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2015] 激光发生器", "background": "", "description": "曾经发明了超能粒子炮・改的发明家 SHTSC 又公开了他的新发明：激光发生器——一种可以产生高能激光的神秘装置。\n\n激光发生器从正上方看是一个无穷大的平面，里面由一个定向激光发射装置和若干个激光偏转装置组成。一个激光发生器的示例如图所示，细箭头表示定向激光发射装置，粗线段表示激光偏转装置。\n\n![](https://cdn.luogu.com.cn/upload/pic/16401.png)\n\n由定向激光发射装置发射出的激光可以看成是一条射线，如果遇到激光偏转装置就会发生偏转。奇特的是，SHTSC 所使用的激光偏转装置并非像传统的镜子那样遵循反射定律，而是对于每个激光偏转装置，有一个固定的偏转系数 $λ$，其出射角 $β$ 与入射角 $α$ 的关系为 $β=λα$，并且能在这一过程中增强激光的能量。\n\n![](https://cdn.luogu.com.cn/upload/pic/16402.png)\n\n注意：\n\n1. 入射角是入射光线和反射平面法向量的夹角。\n2. 偏转装置的两面均可偏转。\n3. 如果激光平行射入偏转装置，则认为没有发生偏转。\n4. 如果不平行且照射到了端点，则认为发生偏转。\n5. 当 $β>\\frac{1}{2}π$ 时，可能会偏转到另一面。\n\n现在 SHTSC 希望你模拟他所设计的激光发生器的工作过程，来帮助他计算激光究竟被哪些激光偏转装置所偏转。", "inputFormat": "第一行四个整数 $x,y,dx,dy$。表示定向激光发射装置的位置是 $(x,y)$，方向是 $(dx,dy)$。\n\n第二行一个整数 $n$，表示一共有 $n$ 个激光偏转装置。\n以下n行，每行六个整数 $x1,y1,x2,y2,a,b$，表示一个激光偏转装置是 $(x1,y1)$ 到 $(x2,y2)$ 的一条线段，其偏转系数 $\\lambda=a/b$。\n\n$n\\leq 100$，所有坐标与 $a$ 和 $b$ 的绝对值不超过 $1000$，$a$、$b$ 均非 $0$。保证所有的偏转装置没有交点。激光发射起始点不在任何偏转装置上。方向向量不为零向量。", "outputFormat": "一行由空格隔开的若干个整数，表示激光依次照射到的激光偏转装置的编号（按照输入顺序从 $1$ 到 $n$ 编号）。如果激光被偏转超过 $10$ 次，则只需输出前 $10$ 次所照射到的偏转装置的编号。特别地，如果激光没有被任何一个偏转装置所偏转，输出 `NONE`。", "hint": "### 样例解释\n\n如图所示，激光依次被 $1$ 号和 $2$ 号偏转装置偏转。\n\n![](https://cdn.luogu.com.cn/upload/pic/16403.png)\n\n## 数据规模和约定\n\n对于 $10\\%$ 的数据，$n=1$；  \n对于 $40\\%$ 的数据，$a=b=1$；  \n对于 $100\\%$ 的数据，$n \\le 100$，所有坐标与 $a$ 和 $b$ 的绝对值不超过 $1000$，$a,b$ 均非零，$dx$ 、$dy$ 不同时为零。保证所有的偏转装置没有交点，且激光发射起始点不在任何偏转装置上。", "locale": "zh-CN"}}}
{"pid": "P4362", "type": "P", "difficulty": 5, "samples": [["8 2 4 \n1 2 20 \n1 3 4 \n1 4 13 \n2 5 10 \n2 6 12 \n3 7 15 \n3 8 5 ", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2002", "NOI", "树形 DP"], "title": "[NOI2002] 贪吃的九头龙", "background": "传说中的九头龙是一种特别贪吃的动物。虽然名字叫“九头龙”，但这只是说它出生的时候有九个头，而在成长的过程中，它有时会长出很多的新头，头的总数会远大于九，当然也会有旧头因衰老而自己脱落。", "description": "有一天，有 $M$ 个脑袋的九头龙看到一棵长有 $N$ 个果子的果树，喜出望外，恨不得一口把它全部吃掉。可是必须照顾到每个头，因此它需要把 $N$ 个果子分成 $M$ 组，每组至少有一个果子，让每个头吃一组。\n\n这 $M$ 个脑袋中有一个最大，称为“大头”，是众头之首，它要吃掉恰好 $K$ 个果子，而且 $K$ 个果子中理所当然地应该包括唯一的一个最大的果子。果子由 $N-1$ 根树枝连接起来，由于果树是一个整体，因此可以从任意一个果子出发沿着树枝“走到”任何一个其他的果子。\n\n对于每段树枝，如果它所连接的两个果子需要由不同的头来吃掉，那么两个头会共同把树枝弄断而把果子分开；如果这两个果子是由同一个头来吃掉，那么这个头会懒得把它弄断而直接把果子连同树枝一起吃掉。当然，吃树枝并不是很舒服的，因此每段树枝都有一个吃下去的“难受值”，而九头龙的难受值就是所有头吃掉的树枝的“难受值”之和。\n\n九头龙希望它的“难受值”尽量小，你能帮它算算吗？\n\n例如图 $1$ 所示的例子中，果树包含 $8$ 个果子，$7$ 段树枝，各段树枝的“难受值”标记在了树枝的旁边。九头龙有两个脑袋，大头需要吃掉 $4$ 个果子，其中必须包含最大的果子。即 $N=8$，$M=2$，$K=4$：\n\n![](https://cdn.luogu.com.cn/upload/pic/16595.png )\n\n图一描述了果树的形态，图二描述了最优策略。", "inputFormat": "输入的第 $1$ 行包含三个整数 $N$，$M$，$K$。$N$ 个果子依次编号 $1,2, \\cdots N$，且最大的果子的编号总是 $1$。\n\n第 $2$ 行到第 $N$ 行描述了果树的形态，每行包含三个整数 $a,b,c$，表示存在一段难受值为 $c$ 的树枝连接果子 $a$ 和果子 $b$。", "outputFormat": "输出仅有一行，包含一个整数，表示在满足“大头”的要求 的前提下，九头龙的难受值的最小值。如果无法满足要求，输出 $-1$。", "hint": "该样例对应于题目描述中的例子。 \n\n【数据范围】\n  \n对于 $100\\%$ 的数据，有  $\\ 1 \\le N \\le 300\\ ,2 \\le M \\le N,1 \\le K \\le N,\\ 1 \\le {a,b} \\le N,\\ 0 \\le c \\le 10^5$ 。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2002] The Gluttonous Nine-Headed Dragon", "background": "The legendary nine-headed dragon is especially gluttonous. Although it is called a “nine-headed dragon,” that only refers to the fact that it is born with nine heads. During its growth, it may grow many new heads, so the total number of heads can be much larger than nine, and of course some old heads may fall off due to aging.", "description": "One day, a nine-headed dragon with $M$ heads sees a fruit tree bearing $N$ fruits. Delighted, it wishes it could eat them all in one bite. However, it must treat each head fairly, so it needs to divide the $N$ fruits into $M$ groups, with at least one fruit in each group, and let each head eat one group.\n\nAmong these $M$ heads, there is a largest head, called the “Big Head,” which is the leader of the heads. It must eat exactly $K$ fruits, and those $K$ fruits must, of course, include the unique largest fruit. The $N$ fruits are connected by $N-1$ branches. Since the fruit tree is a single connected whole, one can “walk” from any fruit to any other fruit along the branches.\n\nFor each branch, if the two fruits it connects are to be eaten by different heads, then the two heads will break the branch to separate the fruits. If the two fruits are to be eaten by the same head, then that head will be too lazy to break it and will eat the fruits together with the branch. Eating branches is uncomfortable, so each branch has a “discomfort value,” and the dragon’s total discomfort is the sum of the “discomfort values” of all branches that are eaten by the heads.\n\nThe dragon wants to minimize its total discomfort. Can you help it compute the minimum?\n\nFor example, in the instance shown in Figure 1, the fruit tree has $8$ fruits and $7$ branches, with each branch’s “discomfort value” labeled next to it. The dragon has two heads, and the Big Head must eat $4$ fruits, which must include the largest fruit. That is, $N = 8$, $M = 2$, $K = 4$:\n\n![](https://cdn.luogu.com.cn/upload/pic/16595.png )\n\nFigure 1 illustrates the shape of the fruit tree, and Figure 2 illustrates the optimal strategy.", "inputFormat": "The first line contains three integers $N$, $M$, $K$. The $N$ fruits are numbered $1, 2, \\cdots, N$, and the largest fruit is always numbered $1$.\n\nLines $2$ through $N$ describe the structure of the fruit tree. Each line contains three integers $a, b, c$, indicating that there is a branch with discomfort value $c$ connecting fruits $a$ and $b$.", "outputFormat": "Output a single line containing one integer, the minimum possible total discomfort while satisfying the Big Head’s requirement. If it is impossible to meet the requirement, output $-1$.", "hint": "This sample corresponds to the example in the problem statement.\n\nConstraints\n\nFor $100\\%$ of the testdata, $1 \\le N \\le 300$, $2 \\le M \\le N$, $1 \\le K \\le N$, $1 \\le a, b \\le N$, $0 \\le c \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2002] 贪吃的九头龙", "background": "传说中的九头龙是一种特别贪吃的动物。虽然名字叫“九头龙”，但这只是说它出生的时候有九个头，而在成长的过程中，它有时会长出很多的新头，头的总数会远大于九，当然也会有旧头因衰老而自己脱落。", "description": "有一天，有 $M$ 个脑袋的九头龙看到一棵长有 $N$ 个果子的果树，喜出望外，恨不得一口把它全部吃掉。可是必须照顾到每个头，因此它需要把 $N$ 个果子分成 $M$ 组，每组至少有一个果子，让每个头吃一组。\n\n这 $M$ 个脑袋中有一个最大，称为“大头”，是众头之首，它要吃掉恰好 $K$ 个果子，而且 $K$ 个果子中理所当然地应该包括唯一的一个最大的果子。果子由 $N-1$ 根树枝连接起来，由于果树是一个整体，因此可以从任意一个果子出发沿着树枝“走到”任何一个其他的果子。\n\n对于每段树枝，如果它所连接的两个果子需要由不同的头来吃掉，那么两个头会共同把树枝弄断而把果子分开；如果这两个果子是由同一个头来吃掉，那么这个头会懒得把它弄断而直接把果子连同树枝一起吃掉。当然，吃树枝并不是很舒服的，因此每段树枝都有一个吃下去的“难受值”，而九头龙的难受值就是所有头吃掉的树枝的“难受值”之和。\n\n九头龙希望它的“难受值”尽量小，你能帮它算算吗？\n\n例如图 $1$ 所示的例子中，果树包含 $8$ 个果子，$7$ 段树枝，各段树枝的“难受值”标记在了树枝的旁边。九头龙有两个脑袋，大头需要吃掉 $4$ 个果子，其中必须包含最大的果子。即 $N=8$，$M=2$，$K=4$：\n\n![](https://cdn.luogu.com.cn/upload/pic/16595.png )\n\n图一描述了果树的形态，图二描述了最优策略。", "inputFormat": "输入的第 $1$ 行包含三个整数 $N$，$M$，$K$。$N$ 个果子依次编号 $1,2, \\cdots N$，且最大的果子的编号总是 $1$。\n\n第 $2$ 行到第 $N$ 行描述了果树的形态，每行包含三个整数 $a,b,c$，表示存在一段难受值为 $c$ 的树枝连接果子 $a$ 和果子 $b$。", "outputFormat": "输出仅有一行，包含一个整数，表示在满足“大头”的要求 的前提下，九头龙的难受值的最小值。如果无法满足要求，输出 $-1$。", "hint": "该样例对应于题目描述中的例子。 \n\n【数据范围】\n  \n对于 $100\\%$ 的数据，有  $\\ 1 \\le N \\le 300\\ ,2 \\le M \\le N,1 \\le K \\le N,\\ 1 \\le {a,b} \\le N,\\ 0 \\le c \\le 10^5$ 。", "locale": "zh-CN"}}}
{"pid": "P4363", "type": "P", "difficulty": 6, "samples": [["2 3\n2 7 3\n9 1 2\n3 7 2\n2 3 1\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["搜索", "2018", "各省省选", "轮廓线 DP", "状压 DP"], "title": "[九省联考 2018] 一双木棋 chess", "background": "", "description": "菲菲和牛牛在一块 $n$ 行 $m$ 列的棋盘上下棋，菲菲执黑棋先手，牛牛执白棋后手。\n\n棋局开始时，棋盘上没有任何棋子，两人轮流在格子上落子，直到填满棋盘时结束。  \n\n落子的规则是：一个格子可以落子当且仅当这个格子内没有棋子且这个格子的左侧及上方的所有格子内都有棋子。\n\n棋盘的每个格子上，都写有两个非负整数，从上到下第 $i$ 行中从左到右第 $j$ 列的格子上的两个整数记作 $a_{i,j}$ 和 $b_{i,j}$。\n\n在游戏结束后，菲菲和牛牛会分别计算自己的得分：菲菲的得分是所有有黑棋的格子上的 $a_{i,j}$ 之和，牛牛的得分是所有有白棋的格子上的 $b_{i,j}$ 的和。\n\n菲菲和牛牛都希望，自己的得分减去对方的得分得到的结果最大。现在他们想知道，在给定的棋盘上，如果双方都采用最优策略且知道对方会采用最优策略，那么，最终的结果如何？\n", "inputFormat": "第一行有两个整数，分别表示棋盘的行数 $n$ 和列数 $m$。  \n第 $2$ 到第 $(n + 1)$ 行，每行 $m$ 个整数，第 $(i + 1)$ 行的第 $j$ 个整数表示 $a_{i, j}$。  \n第 $(n + 2)$ 到第 $(2n + 1)$ 行，每行 $m$ 个整数，第 $(n + i + 1)$ 行的第 $j$ 个整数表示 $b_{i, j}$。", "outputFormat": "输出一行一个整数，表示菲菲的得分减去牛牛的得分的结果。", "hint": "### 样例 1 说明\n\n![](https://cdn.luogu.com.cn/upload/pic/16877.png)\n\n棋盘如图所示，双方都采用最优策略时，棋局如下：\n\n- 菲菲下在第 $1$ 行第 $1$ 列（这是第一步时唯一可以落子的格子）。\n- 牛牛下在第 $1$ 行第 $2$ 列。\n- 菲菲下在第 $2$ 行第 $1$ 列。\n- 牛牛下在第 $1$ 行第 $3$ 列。\n- 菲菲下在第 $2$ 行第 $2$ 列。\n- 牛牛下在第 $2$ 行第 $3$ 列（这是这一步时唯一可以落子的格子）。\n- 填满棋盘，游戏结束。\n\n盘面如下：\n\n![](https://cdn.luogu.com.cn/upload/pic/16878.png)\n\n菲菲的得分为 $2 + 9 + 1 = 12$，牛牛的得分为 $7 + 2 + 1 = 10$。\n\n### 数据规模与约定\n\n各测试点信息如下表。\n\n![](https://cdn.luogu.com.cn/upload/pic/16879.png)\n\n- 对于编号为奇数的测试点，保证 $b_{i, j} = 0$。\n- 对于全部的测试点，保证 $1 \\leq n, m \\leq 10$，$0 \\leq a_{i, j}, b_{i, j} \\leq 10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Nine-Province Joint Exam 2018] Double Wooden Chess (chess)", "background": "", "description": "Feifei and Niuniu play on an $n$ by $m$ board. Feifei plays black and goes first, Niuniu plays white and goes second.\n\nAt the start, the board is empty. They alternately place pieces on cells until the board is completely filled.\n\nThe placement rule is: a cell can be chosen if and only if the cell is empty and all cells to its left in the same row and all cells above it in the same column already contain pieces.\n\nEach cell of the board has two nonnegative integers written on it. For the cell in row $i$ (from top to bottom) and column $j$ (from left to right), the two integers are denoted by $a_{i, j}$ and $b_{i, j}$.\n\nAfter the game ends, Feifei’s score is the sum of $a_{i, j}$ over all cells with a black piece, and Niuniu’s score is the sum of $b_{i, j}$ over all cells with a white piece.\n\nBoth players want to maximize the result of their own score minus the opponent’s score. They would like to know, on the given board, if both sides play optimally and know the other will also play optimally, what is the final result.", "inputFormat": "The first line contains two integers, the numbers of rows $n$ and columns $m$ of the board.  \nLines $2$ through $(n + 1)$ each contain $m$ integers; on line $(i + 1)$, the $j$-th integer is $a_{i, j}$.  \nLines $(n + 2)$ through $(2n + 1)$ each contain $m$ integers; on line $(n + i + 1)$, the $j$-th integer is $b_{i, j}$.", "outputFormat": "Output a single integer, the value of Feifei’s score minus Niuniu’s score.", "hint": "### Sample 1 Explanation\n\n![](https://cdn.luogu.com.cn/upload/pic/16877.png)\n\nThe board is as shown. Under optimal play, the game proceeds as follows:\n\n- Feifei plays at row $1$, column $1$ (this is the only legal move on the first turn).\n- Niuniu plays at row $1$, column $2$.\n- Feifei plays at row $2$, column $1$.\n- Niuniu plays at row $1$, column $3$.\n- Feifei plays at row $2$, column $2$.\n- Niuniu plays at row $2$, column $3$ (this is the only legal move on this turn).\n- The board is filled, and the game ends.\n\nThe final position is:\n\n![](https://cdn.luogu.com.cn/upload/pic/16878.png)\n\nFeifei’s score is $2 + 9 + 1 = 12$, and Niuniu’s score is $7 + 2 + 1 = 10$.\n\n### Constraints\n\nThe information for each test point is shown in the table below.\n\n![](https://cdn.luogu.com.cn/upload/pic/16879.png)\n\n- For test points with odd indices, it is guaranteed that $b_{i, j} = 0$.\n- For all test points, it is guaranteed that $1 \\leq n, m \\leq 10$ and $0 \\leq a_{i, j}, b_{i, j} \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[九省联考 2018] 一双木棋 chess", "background": "", "description": "菲菲和牛牛在一块 $n$ 行 $m$ 列的棋盘上下棋，菲菲执黑棋先手，牛牛执白棋后手。\n\n棋局开始时，棋盘上没有任何棋子，两人轮流在格子上落子，直到填满棋盘时结束。  \n\n落子的规则是：一个格子可以落子当且仅当这个格子内没有棋子且这个格子的左侧及上方的所有格子内都有棋子。\n\n棋盘的每个格子上，都写有两个非负整数，从上到下第 $i$ 行中从左到右第 $j$ 列的格子上的两个整数记作 $a_{i,j}$ 和 $b_{i,j}$。\n\n在游戏结束后，菲菲和牛牛会分别计算自己的得分：菲菲的得分是所有有黑棋的格子上的 $a_{i,j}$ 之和，牛牛的得分是所有有白棋的格子上的 $b_{i,j}$ 的和。\n\n菲菲和牛牛都希望，自己的得分减去对方的得分得到的结果最大。现在他们想知道，在给定的棋盘上，如果双方都采用最优策略且知道对方会采用最优策略，那么，最终的结果如何？\n", "inputFormat": "第一行有两个整数，分别表示棋盘的行数 $n$ 和列数 $m$。  \n第 $2$ 到第 $(n + 1)$ 行，每行 $m$ 个整数，第 $(i + 1)$ 行的第 $j$ 个整数表示 $a_{i, j}$。  \n第 $(n + 2)$ 到第 $(2n + 1)$ 行，每行 $m$ 个整数，第 $(n + i + 1)$ 行的第 $j$ 个整数表示 $b_{i, j}$。", "outputFormat": "输出一行一个整数，表示菲菲的得分减去牛牛的得分的结果。", "hint": "### 样例 1 说明\n\n![](https://cdn.luogu.com.cn/upload/pic/16877.png)\n\n棋盘如图所示，双方都采用最优策略时，棋局如下：\n\n- 菲菲下在第 $1$ 行第 $1$ 列（这是第一步时唯一可以落子的格子）。\n- 牛牛下在第 $1$ 行第 $2$ 列。\n- 菲菲下在第 $2$ 行第 $1$ 列。\n- 牛牛下在第 $1$ 行第 $3$ 列。\n- 菲菲下在第 $2$ 行第 $2$ 列。\n- 牛牛下在第 $2$ 行第 $3$ 列（这是这一步时唯一可以落子的格子）。\n- 填满棋盘，游戏结束。\n\n盘面如下：\n\n![](https://cdn.luogu.com.cn/upload/pic/16878.png)\n\n菲菲的得分为 $2 + 9 + 1 = 12$，牛牛的得分为 $7 + 2 + 1 = 10$。\n\n### 数据规模与约定\n\n各测试点信息如下表。\n\n![](https://cdn.luogu.com.cn/upload/pic/16879.png)\n\n- 对于编号为奇数的测试点，保证 $b_{i, j} = 0$。\n- 对于全部的测试点，保证 $1 \\leq n, m \\leq 10$，$0 \\leq a_{i, j}, b_{i, j} \\leq 10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P4364", "type": "P", "difficulty": 6, "samples": [["4 2.0\n114 514 1919 810", "114 810 514 1919"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2018", "线段树", "各省省选", "排序"], "title": "[九省联考 2018] IIIDX", "background": "Osu 听过没？那是 Konano 最喜欢的一款音乐游戏，而他的梦想就是有一天自己也能做个独特酷炫的音乐游戏。现在，他在世界知名游戏公司 KONMAI 内工作，离他的梦想也越来越近了。\n\n这款音乐游戏内一般都包含了许多歌曲，歌曲越多，玩家越不易玩腻。同时，为了使玩家在游戏上~~氪更多的金钱~~花更多的时间，游戏一开始一般都不会将所有曲目公开，有些曲目你需要通关某首特定歌曲才会解锁，而且越晚解锁的曲目难度越高。", "description": "这一天，Konano 接到了一个任务，他需要给正在制作中的游戏《IIIDX》安排曲目的解锁顺序。游戏内共有 $n$ 首曲目，每首曲目都会有一个难度 $d$，游戏内第 $i$ 首曲目会在玩家 Pass 第 $\\left\\lfloor \\frac i k \\right\\rfloor$ 首曲目后解锁（$\\left\\lfloor x \\right\\rfloor$ 为下取整符号）若 $\\left\\lfloor \\frac i k \\right\\rfloor = 0$，则说明这首曲目**无需解锁**。\n\n举个例子：当 $k = 2$ 时，第 $1$ 首曲目是无需解锁的（$\\left\\lfloor \\frac 12 \\right\\rfloor = 0$），第 $7$ 首曲目需要玩家 Pass 第 $\\left\\lfloor \\frac 72 \\right\\rfloor = 3$ 首曲目才会被解锁。\n\nKonano 的工作，便是安排这些曲目的顺序，使得每次解锁出的曲子的难度**不低于**作为条件需要玩家通关的曲子的难度，即使得确定顺序后的曲目的难度对于每个 $i$ 满足 $d_i \\geq d_{\\left\\lfloor \\frac ik \\right\\rfloor}$。\n\n当然这难不倒曾经在信息学竞赛摸鱼许久的 Konano。那假如是你，你会怎么解决这份任务呢？", "inputFormat": "第 $1$ 行 $1$ 个正整数 $n$ 和 $1$ 个小数 $k,n$ 表示曲目数量，$k$ 其含义如题所示。\n\n第 $2$ 行 $n$ 个用空格隔开的正整数 $d$，表示这 $n$ 首曲目的难度。", "outputFormat": "输出 $1$ 行 $n$ 个整数，按顺序输出安排完曲目顺序后第 $i$ 首曲目的难度。\n\n若有多解，则输出 $d_1$ **最大**的；若仍有多解，则输出 $d_2$ **最大**的，以此类推。", "hint": "| 测试点编号 | $n$ | $k$ | $d$ | 特殊限制 |\n|-|-|-|-|-|\n| $1$ | $1 \\leq n \\leq 10$ | $k=2$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $2$ | $1 \\leq n \\leq 10$ | $k=3$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $3$ | $1 \\leq n \\leq 10$ | $k=1.1$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $4$ | $1 \\leq n \\leq 10$ | $k=n$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $5$ | $1 \\leq n \\leq 10$ | $1 < k \\leq 100$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $6$ | $1 \\leq n \\leq 10$ | $1 < k \\leq 100$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $7$ | $1\\leq n\\leq 2000$ | $k=2$ | $1\\leq d\\leq 10^9$ | 保证 $d_i$ 互不相同 |\n| $8$ | $1\\leq n\\leq 2000$ | $k=2$ | $1\\leq d\\leq 10^9$ | 无 |\n| $9$ | $1\\leq n\\leq 2000$ | $k=3$ | $1\\leq d\\leq 10^9$ | 保证 $d_i$ 互不相同 |\n| $10$ | $1\\leq n\\leq 2000$ | $k=3$ | $1\\leq d\\leq 10^9$ | 无 |\n| $11$ | $1\\leq n\\leq 2000$ | $1 < k \\leq 10^9$ | $1\\leq d\\leq 10^9$ | 保证 $d_i$ 互不相同 |\n| $12$ | $1\\leq n\\leq 2000$ | $1 < k \\leq 10^9$ | $1\\leq d\\leq 10^9$ | 无 |\n| $13$ | $1\\leq n\\leq 500000$ | $k=2$ | $1\\leq d\\leq 10^9$ | 无 |\n| $14$ | $1\\leq n\\leq 500000$ | $k=3$ | $1\\leq d\\leq 10^9$ | 无 |\n| $15$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 保证 $d_i$ 互不相同 |\n| $16$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 保证 $d_i$ 互不相同 |\n| $17$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 无 |\n| $18$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 无 |\n| $19$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 无 |\n| $20$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 无 |", "locale": "zh-CN", "translations": {"en": {"title": "[Nine-Province Joint Exam 2018] IIIDX", "background": "Have you heard of Osu? That is Konano’s favorite rhythm game, and his dream is to make a unique and cool music game of his own someday. Now he works at the world-renowned game company KONMAI, getting closer to his dream.\n\nA music game usually contains many songs; the more songs, the less likely players get bored. Meanwhile, to make players spend ~~more money~~ more time on the game, not all tracks are available from the beginning. Some tracks are unlocked only after you clear a specific track, and the later a track is unlocked, the higher its difficulty tends to be.", "description": "Konano received a task to arrange the unlock order of tracks for the in-development game “IIIDX.” There are $n$ tracks in total. Each track has a difficulty $d$. The $i$-th track is unlocked after the player clears the $\\left\\lfloor \\frac i k \\right\\rfloor$-th track ($\\left\\lfloor x \\right\\rfloor$ is the floor function). If $\\left\\lfloor \\frac i k \\right\\rfloor = 0$, then this track requires no unlock.\n\nFor example, when $k = 2$, the $1$-st track requires no unlock ($\\left\\lfloor \\frac 1 2 \\right\\rfloor = 0$), and the $7$-th track is unlocked after the player clears the $3$-rd track since $\\left\\lfloor \\frac 7 2 \\right\\rfloor = 3$.\n\nKonano’s job is to arrange the order of these tracks so that each newly unlocked track has a difficulty not lower than the prerequisite track’s difficulty. That is, after determining the order, the difficulties satisfy $d_i \\geq d_{\\left\\lfloor \\frac i k \\right\\rfloor}$ for every $i$.\n\nOf course, this is easy for Konano, who has spent a lot of time “chilling” in informatics competitions. If it were you, how would you solve this task?", "inputFormat": "The first line contains one positive integer $n$ and one real number $k$. $n$ is the number of tracks, and $k$ is as described above.\n\nThe second line contains $n$ space-separated positive integers $d$, representing the difficulties of the $n$ tracks.", "outputFormat": "Output one line with $n$ integers: the difficulty of the $i$-th track after arranging the order.\n\nIf there are multiple valid solutions, output the one with $d_1$ maximized; if still tied, maximize $d_2$; and so on.", "hint": "| Test point ID | $n$ | $k$ | $d$ | Special constraints |\n|-|-|-|-|-|\n| $1$ | $1 \\leq n \\leq 10$ | $k=2$ | $1 \\leq d \\leq 100$ | All $d_i$ are distinct |\n| $2$ | $1 \\leq n \\leq 10$ | $k=3$ | $1 \\leq d \\leq 100$ | All $d_i$ are distinct |\n| $3$ | $1 \\leq n \\leq 10$ | $k=1.1$ | $1 \\leq d \\leq 100$ | All $d_i$ are distinct |\n| $4$ | $1 \\leq n \\leq 10$ | $k=n$ | $1 \\leq d \\leq 100$ | All $d_i$ are distinct |\n| $5$ | $1 \\leq n \\leq 10$ | $1 < k \\leq 100$ | $1 \\leq d \\leq 100$ | All $d_i$ are distinct |\n| $6$ | $1 \\leq n \\leq 10$ | $1 < k \\leq 100$ | $1 \\leq d \\leq 100$ | All $d_i$ are distinct |\n| $7$ | $1\\leq n\\leq 2000$ | $k=2$ | $1\\leq d\\leq 10^9$ | All $d_i$ are distinct |\n| $8$ | $1\\leq n\\leq 2000$ | $k=2$ | $1\\leq d\\leq 10^9$ | None |\n| $9$ | $1\\leq n\\leq 2000$ | $k=3$ | $1\\leq d\\leq 10^9$ | All $d_i$ are distinct |\n| $10$ | $1\\leq n\\leq 2000$ | $k=3$ | $1\\leq d\\leq 10^9$ | None |\n| $11$ | $1\\leq n\\leq 2000$ | $1 < k \\leq 10^9$ | $1\\leq d\\leq 10^9$ | All $d_i$ are distinct |\n| $12$ | $1\\leq n\\leq 2000$ | $1 < k \\leq 10^9$ | $1\\leq d\\leq 10^9$ | None |\n| $13$ | $1\\leq n\\leq 500000$ | $k=2$ | $1\\leq d\\leq 10^9$ | None |\n| $14$ | $1\\leq n\\leq 500000$ | $k=3$ | $1\\leq d\\leq 10^9$ | None |\n| $15$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | All $d_i$ are distinct |\n| $16$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | All $d_i$ are distinct |\n| $17$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | None |\n| $18$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | None |\n| $19$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | None |\n| $20$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | None |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[九省联考 2018] IIIDX", "background": "Osu 听过没？那是 Konano 最喜欢的一款音乐游戏，而他的梦想就是有一天自己也能做个独特酷炫的音乐游戏。现在，他在世界知名游戏公司 KONMAI 内工作，离他的梦想也越来越近了。\n\n这款音乐游戏内一般都包含了许多歌曲，歌曲越多，玩家越不易玩腻。同时，为了使玩家在游戏上~~氪更多的金钱~~花更多的时间，游戏一开始一般都不会将所有曲目公开，有些曲目你需要通关某首特定歌曲才会解锁，而且越晚解锁的曲目难度越高。", "description": "这一天，Konano 接到了一个任务，他需要给正在制作中的游戏《IIIDX》安排曲目的解锁顺序。游戏内共有 $n$ 首曲目，每首曲目都会有一个难度 $d$，游戏内第 $i$ 首曲目会在玩家 Pass 第 $\\left\\lfloor \\frac i k \\right\\rfloor$ 首曲目后解锁（$\\left\\lfloor x \\right\\rfloor$ 为下取整符号）若 $\\left\\lfloor \\frac i k \\right\\rfloor = 0$，则说明这首曲目**无需解锁**。\n\n举个例子：当 $k = 2$ 时，第 $1$ 首曲目是无需解锁的（$\\left\\lfloor \\frac 12 \\right\\rfloor = 0$），第 $7$ 首曲目需要玩家 Pass 第 $\\left\\lfloor \\frac 72 \\right\\rfloor = 3$ 首曲目才会被解锁。\n\nKonano 的工作，便是安排这些曲目的顺序，使得每次解锁出的曲子的难度**不低于**作为条件需要玩家通关的曲子的难度，即使得确定顺序后的曲目的难度对于每个 $i$ 满足 $d_i \\geq d_{\\left\\lfloor \\frac ik \\right\\rfloor}$。\n\n当然这难不倒曾经在信息学竞赛摸鱼许久的 Konano。那假如是你，你会怎么解决这份任务呢？", "inputFormat": "第 $1$ 行 $1$ 个正整数 $n$ 和 $1$ 个小数 $k,n$ 表示曲目数量，$k$ 其含义如题所示。\n\n第 $2$ 行 $n$ 个用空格隔开的正整数 $d$，表示这 $n$ 首曲目的难度。", "outputFormat": "输出 $1$ 行 $n$ 个整数，按顺序输出安排完曲目顺序后第 $i$ 首曲目的难度。\n\n若有多解，则输出 $d_1$ **最大**的；若仍有多解，则输出 $d_2$ **最大**的，以此类推。", "hint": "| 测试点编号 | $n$ | $k$ | $d$ | 特殊限制 |\n|-|-|-|-|-|\n| $1$ | $1 \\leq n \\leq 10$ | $k=2$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $2$ | $1 \\leq n \\leq 10$ | $k=3$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $3$ | $1 \\leq n \\leq 10$ | $k=1.1$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $4$ | $1 \\leq n \\leq 10$ | $k=n$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $5$ | $1 \\leq n \\leq 10$ | $1 < k \\leq 100$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $6$ | $1 \\leq n \\leq 10$ | $1 < k \\leq 100$ | $1 \\leq d \\leq 100$ | 保证 $d_i$ 互不相同 |\n| $7$ | $1\\leq n\\leq 2000$ | $k=2$ | $1\\leq d\\leq 10^9$ | 保证 $d_i$ 互不相同 |\n| $8$ | $1\\leq n\\leq 2000$ | $k=2$ | $1\\leq d\\leq 10^9$ | 无 |\n| $9$ | $1\\leq n\\leq 2000$ | $k=3$ | $1\\leq d\\leq 10^9$ | 保证 $d_i$ 互不相同 |\n| $10$ | $1\\leq n\\leq 2000$ | $k=3$ | $1\\leq d\\leq 10^9$ | 无 |\n| $11$ | $1\\leq n\\leq 2000$ | $1 < k \\leq 10^9$ | $1\\leq d\\leq 10^9$ | 保证 $d_i$ 互不相同 |\n| $12$ | $1\\leq n\\leq 2000$ | $1 < k \\leq 10^9$ | $1\\leq d\\leq 10^9$ | 无 |\n| $13$ | $1\\leq n\\leq 500000$ | $k=2$ | $1\\leq d\\leq 10^9$ | 无 |\n| $14$ | $1\\leq n\\leq 500000$ | $k=3$ | $1\\leq d\\leq 10^9$ | 无 |\n| $15$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 保证 $d_i$ 互不相同 |\n| $16$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 保证 $d_i$ 互不相同 |\n| $17$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 无 |\n| $18$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 无 |\n| $19$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 无 |\n| $20$ | $1\\leq n\\leq 500000$ | $1<k\\leq 10^9$ | $1\\leq d\\leq 10^9$ | 无 |", "locale": "zh-CN"}}}
{"pid": "P4365", "type": "P", "difficulty": 7, "samples": [["5 3 3\n2 1 1 2 3\n1 2\n2 3\n1 4\n1 5", "11"], ["10 2 3\n2 1 1 3 1 2 3 3 1 3\n1 2\n2 3\n2 4\n2 5\n2 6\n5 7\n1 8\n8 9\n1 10", "435"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["动态规划 DP", "2018", "线段树", "各省省选", "枚举", "背包 DP"], "title": "[九省联考 2018] 秘密袭击 coat", "background": "> We could have had it all. . . . . .\n>\n> 我们本该，拥有一切\n>\n> Counting on a tree. . . . . .\n>\n> 何至于此，数数树上\n\nCounting on a Tree（CoaT）即是本题的英文名称。", "description": "Access Globe 最近正在玩一款战略游戏。在游戏中，他操控的角色是一名 C 国士兵。他的任务就是服从指挥官的指令参加战斗，并在战斗中取胜。\n\nC 国即将向 D 国发动一场秘密袭击。作战计划是这样的：选择 D 国的 $s$ 个城市，派出 C 国战绩最高的 $s$ 个士兵分别秘密潜入这些城市。每个城市都有一个危险程度 $d_i$。\n\nC 国指挥官会派遣战绩最高的士兵潜入所选择的城市中危险程度最高的城市，派遣战绩第二高的士兵潜入所选择的城市中危险程度次高的城市，以此类推（即派遣战绩第 $i$ 高的士兵潜入所选择城市中危险程度第 $i$ 高的城市）。D 国有 $n$ 个城市，$n - 1$ 条双向道路连接着这些城市，使得这些城市两两之间都可以互相到达。为了任务执行顺利，C 国选出的 $s$ 个城市中，任意两个所选的城市，都可以不经过未被选择的城市互相到达。\n\nAccess Globe 操控的士兵的战绩是第 $k$ 高，他希望能估计出最终自己潜入的城市的危险程度。Access Globe 假设 C 国是以等概率选出任意满足条件的城市集合 $S$，他希望你帮他求出所有可能的城市集合中，Access Globe 操控的士兵潜入城市的危险程度之和。如果选择的城市不足 $k$ 个，那么Access Globe 不会被派出，这种情况下危险程度为 $0$。\n\n当然，你并不想帮他解决这个问题，你也不打算告诉他这个值除以 $998\\,244\\,353$ 的余数，你只打算告诉他这个值除以 $64\\,123$ 的余数。", "inputFormat": "第 $1$ 行包含 $3$ 个整数 $n,k,W$，表示 D 国城市的个数，Access Globe 所操控士兵潜入的城市战绩排名以及 D 国的所有城市中最大的危险程度；\n\n第 $2$ 行包含 $n$ 个 $1$ 到 $W$ 之间的整数 $d_1, d_2, \\ldots, d_n$，表示每个城市的危险程度；\n\n第 $3$ 行到第 $n + 1$ 行，每行两个整数 $x_i, y_i$，表示 D 国存在一条连接城市 $x_i$ 和城市 $y_i$ 的双向道路。", "outputFormat": "输出一个整数，表示所有可行的城市集合中，Access Globe 操控的士兵潜入城市的危险程度之和除以 $64\\,123$ 的余数。", "hint": "D 国地图如下，其中危险程度为 $d$ 的城市的形状是 $d + 3$ 边形。\n\n![](https://cdn.luogu.com.cn/upload/pic/16888.png)\n\n以下是所有符合条件且选择的城市不少于 $3$ 个的方案：\n\n- 选择城市 $1,2,3$，Access Globe 的士兵潜入的城市危险程度为 $1$；\n- 选择城市 $1,2,3,4$，Access Globe 的士兵潜入的城市危险程度为 $1$；\n- 选择城市 $1,2,3,5$，Access Globe 的士兵潜入的城市危险程度为 $1$；\n- 选择城市 $1,2,3,4,5$，Access Globe 的士兵潜入的城市危险程度为 $2$；\n- 选择城市 $1,2,4$，Access Globe 的士兵潜入的城市危险程度为 $1$；\n- 选择城市 $1,2,5$，Access Globe 的士兵潜入的城市危险程度为 $1$；\n- 选择城市 $1,2,4,5$，Access Globe 的士兵潜入的城市危险程度为 $2$；\n- 选择城市 $1,4,5$，Access Globe 的士兵潜入的城市危险程度为 $2$；\n- 而在选择的城市少于 $3$ 时，Access Globe 的士兵潜入的城市危险程度均为 $0$。\n\n所以你应该输出 $(1 + 1 + 1 + 2 + 1 + 1 + 2 + 2) \\bmod 64\\,123 = 11$。\n\n![](https://cdn.luogu.com.cn/upload/pic/16889.png)", "locale": "zh-CN", "translations": {"en": {"title": "[Nine-Province Joint Exam 2018] Secret Raid coat", "background": "> We could have had it all. . . . . .\n>\n> 我们本该，拥有一切\n>\n> Counting on a tree. . . . . .\n>\n> 何至于此，数数树上\n\nCounting on a Tree (CoaT) is the English name of this problem.", "description": "Access Globe is playing a strategy game. In the game, he controls a soldier from country C. His mission is to follow the commander’s orders to join battles and win.\n\nCountry C is about to launch a secret raid on country D. The battle plan is: choose $s$ cities in country D, and send the $s$ top-performing soldiers of country C to secretly infiltrate these cities, one soldier per city. Each city has a danger level $d_i$.\n\nThe commander of country C will send the best-performing soldier to the most dangerous city among the chosen cities, the second-best to the second most dangerous city, and so on (that is, the soldier with the $i$-th highest record goes to the city with the $i$-th highest danger level among the chosen cities). Country D has $n$ cities, with $n - 1$ bidirectional roads connecting them, so that every pair of cities is mutually reachable. To ensure smooth execution, among the $s$ chosen cities, any two chosen cities can reach each other without passing through any unchosen city.\n\nAccess Globe controls the soldier with the $k$-th highest record, and he wants to estimate the danger level of the city he will eventually infiltrate. He assumes country C chooses any set $S$ of cities that satisfies the conditions uniformly at random. He wants you to compute, over all possible city sets, the sum of the danger levels of the city that Access Globe’s soldier will infiltrate. If fewer than $k$ cities are chosen, Access Globe will not be dispatched; in this case the danger level is $0$.\n\nOf course, you do not want to solve this problem for him, and you are not going to tell him the remainder modulo $998\\,244\\,353$. You will only tell him the remainder modulo $64\\,123$.", "inputFormat": "The first line contains $3$ integers $n, k, W$, denoting the number of cities in country D, the rank of the city that Access Globe’s soldier will infiltrate, and the maximum danger level among all cities in country D.\n\nThe second line contains $n$ integers between $1$ and $W$, $d_1, d_2, \\ldots, d_n$, denoting the danger level of each city.\n\nLines $3$ through $n + 1$ each contain two integers $x_i, y_i$, indicating that there is a bidirectional road between cities $x_i$ and $y_i$ in country D.", "outputFormat": "Output a single integer: the remainder modulo $64\\,123$ of the sum, over all feasible city sets, of the danger level of the city that Access Globe’s soldier will infiltrate.", "hint": "Country D’s map is shown below. A city with danger level $d$ is drawn as a $(d + 3)$-gon.\n\n![](https://cdn.luogu.com.cn/upload/pic/16888.png)\n\nAll valid choices with at least $3$ selected cities are:\n\n- Choose cities $1, 2, 3$; the danger level for Access Globe’s soldier is $1$.\n- Choose cities $1, 2, 3, 4$; the danger level is $1$.\n- Choose cities $1, 2, 3, 5$; the danger level is $1$.\n- Choose cities $1, 2, 3, 4, 5$; the danger level is $2$.\n- Choose cities $1, 2, 4$; the danger level is $1$.\n- Choose cities $1, 2, 5$; the danger level is $1$.\n- Choose cities $1, 2, 4, 5$; the danger level is $2$.\n- Choose cities $1, 4, 5$; the danger level is $2$.\n- When fewer than $3$ cities are chosen, the danger level is $0$.\n\nTherefore you should output $(1 + 1 + 1 + 2 + 1 + 1 + 2 + 2) \\bmod 64\\,123 = 11$.\n\n![](https://cdn.luogu.com.cn/upload/pic/16889.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[九省联考 2018] 秘密袭击 coat", "background": "> We could have had it all. . . . . .\n>\n> 我们本该，拥有一切\n>\n> Counting on a tree. . . . . .\n>\n> 何至于此，数数树上\n\nCounting on a Tree（CoaT）即是本题的英文名称。", "description": "Access Globe 最近正在玩一款战略游戏。在游戏中，他操控的角色是一名 C 国士兵。他的任务就是服从指挥官的指令参加战斗，并在战斗中取胜。\n\nC 国即将向 D 国发动一场秘密袭击。作战计划是这样的：选择 D 国的 $s$ 个城市，派出 C 国战绩最高的 $s$ 个士兵分别秘密潜入这些城市。每个城市都有一个危险程度 $d_i$。\n\nC 国指挥官会派遣战绩最高的士兵潜入所选择的城市中危险程度最高的城市，派遣战绩第二高的士兵潜入所选择的城市中危险程度次高的城市，以此类推（即派遣战绩第 $i$ 高的士兵潜入所选择城市中危险程度第 $i$ 高的城市）。D 国有 $n$ 个城市，$n - 1$ 条双向道路连接着这些城市，使得这些城市两两之间都可以互相到达。为了任务执行顺利，C 国选出的 $s$ 个城市中，任意两个所选的城市，都可以不经过未被选择的城市互相到达。\n\nAccess Globe 操控的士兵的战绩是第 $k$ 高，他希望能估计出最终自己潜入的城市的危险程度。Access Globe 假设 C 国是以等概率选出任意满足条件的城市集合 $S$，他希望你帮他求出所有可能的城市集合中，Access Globe 操控的士兵潜入城市的危险程度之和。如果选择的城市不足 $k$ 个，那么Access Globe 不会被派出，这种情况下危险程度为 $0$。\n\n当然，你并不想帮他解决这个问题，你也不打算告诉他这个值除以 $998\\,244\\,353$ 的余数，你只打算告诉他这个值除以 $64\\,123$ 的余数。", "inputFormat": "第 $1$ 行包含 $3$ 个整数 $n,k,W$，表示 D 国城市的个数，Access Globe 所操控士兵潜入的城市战绩排名以及 D 国的所有城市中最大的危险程度；\n\n第 $2$ 行包含 $n$ 个 $1$ 到 $W$ 之间的整数 $d_1, d_2, \\ldots, d_n$，表示每个城市的危险程度；\n\n第 $3$ 行到第 $n + 1$ 行，每行两个整数 $x_i, y_i$，表示 D 国存在一条连接城市 $x_i$ 和城市 $y_i$ 的双向道路。", "outputFormat": "输出一个整数，表示所有可行的城市集合中，Access Globe 操控的士兵潜入城市的危险程度之和除以 $64\\,123$ 的余数。", "hint": "D 国地图如下，其中危险程度为 $d$ 的城市的形状是 $d + 3$ 边形。\n\n![](https://cdn.luogu.com.cn/upload/pic/16888.png)\n\n以下是所有符合条件且选择的城市不少于 $3$ 个的方案：\n\n- 选择城市 $1,2,3$，Access Globe 的士兵潜入的城市危险程度为 $1$；\n- 选择城市 $1,2,3,4$，Access Globe 的士兵潜入的城市危险程度为 $1$；\n- 选择城市 $1,2,3,5$，Access Globe 的士兵潜入的城市危险程度为 $1$；\n- 选择城市 $1,2,3,4,5$，Access Globe 的士兵潜入的城市危险程度为 $2$；\n- 选择城市 $1,2,4$，Access Globe 的士兵潜入的城市危险程度为 $1$；\n- 选择城市 $1,2,5$，Access Globe 的士兵潜入的城市危险程度为 $1$；\n- 选择城市 $1,2,4,5$，Access Globe 的士兵潜入的城市危险程度为 $2$；\n- 选择城市 $1,4,5$，Access Globe 的士兵潜入的城市危险程度为 $2$；\n- 而在选择的城市少于 $3$ 时，Access Globe 的士兵潜入的城市危险程度均为 $0$。\n\n所以你应该输出 $(1 + 1 + 1 + 2 + 1 + 1 + 2 + 2) \\bmod 64\\,123 = 11$。\n\n![](https://cdn.luogu.com.cn/upload/pic/16889.png)", "locale": "zh-CN"}}}
{"pid": "P4366", "type": "P", "difficulty": 5, "samples": [["4 2 1\n1 3 1\n2 4 4\n1 4", "5"], ["7 2 10\n1 3 1\n2 4 4\n3 6", "34"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论建模", "最短路", "进制", "Code+"], "title": "[Code+#4] 最短路", "background": "在北纬 91°，有一个神奇的国度，叫做企鹅国。这里的企鹅也有自己发达的文明，称为企鹅文明。因为企鹅只有黑白两种颜色，所以他们的数学也是以二进制为基础发展的。\n\n比如早在 $11101001$ 年前，他们就有了异或这样一个数学概念。如果你不知道异或是什么，请出门过墙左转到[这里](https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96)。\n\n再比如早在 $1000010$ 年前，他们的大科学家 Penguin. Tu 就提出了[图](https://zh.wikipedia.org/wiki/%E5%9B%BE_%28%E6%95%B0%E5%AD%A6%29#%E6%9C%89/%E7%84%A1_%E5%90%91%E5%9B%BE)和[最短路径](https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98)这样一些概念。", "description": "企鹅国中有 $N$ 座城市，编号从 $1$ 到 $N$。\n\n对于任意的两座城市 $i$ 和 $j$，企鹅们可以花费 $(i~\\mathrm{xor}~j) \\times C$ 的时间从城市 $i$ 走到城市 $j$，这里 $C$ 为一个给定的常数。\n\n当然除此之外还有 $M$ 条单向的快捷通道，第 $i$ 条快捷通道从第 $F_i$​​ 个城市通向第 $T_i$​​ 个城市，走这条通道需要消耗 $V_i$​​ 的时间。\n\n现在来自 **P**enguin **K**ingdom **U**niversity 的企鹅豆豆正在考虑从城市 $A$ 前往城市 $B$ 最少需要多少时间？", "inputFormat": "从标准输入读入数据。\n\n输入第一行包含三个整数 $N,M,C$ $(1 \\leq C \\leq 100)$，表示企鹅国城市的个数、快捷通道的个数以及题面中提到的给定的常数 $C$。\n\n接下来的 $M$ 行，每行三个正整数 $F_i,T_i,V_i$​ ($1 \\leq F_i \\leq N$,$1 \\leq T_i \\leq N ,1\\leq V_i \\leq 100$)，分别表示对应通道的起点城市标号、终点城市标号和通过这条通道需要消耗的时间。\n\n最后一行两个正整数 $A,B$，表示企鹅豆豆选择的起点城市标号和终点城市标号。", "outputFormat": "输出到标准输出。\n\n输出一行一个整数，表示从城市 $A$ 前往城市 $B$ 需要的最少时间。", "hint": "**样例 1 解释**\n\n直接从 $1$ 走到 $4$ 就好了。\n\n**样例 2 解释**\n\n先从 $3$ 走到 $2$ ，再从 $2$ 通过通道到达 $4$ ，再从 $4$ 走到 $6$。\n\n![0](https://cdn.luogu.com.cn/upload/pic/16868.png)\n\n活泼可爱的出题人给大家留下了下面这张图。\n\n![1](https://i.loli.net/2018/04/02/5ac1bb2333c22.jpg)\n\nCredit: https://www.luogu.org/discuss/show/38908", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#4] Shortest Path", "background": "At latitude 91° N, there is a magical country called the Penguin Kingdom. The penguins here have their own advanced civilization, known as the Penguin Civilization. Since penguins are only black and white, their mathematics is also based on binary.\n\nFor example, as early as $11101001$ years ago, they had the mathematical concept of XOR. If you do not know what XOR is, please go out, turn left, and head over to [here](https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96).\n\nAlso, as early as $1000010$ years ago, their great scientist Penguin. Tu proposed concepts such as [graph](https://zh.wikipedia.org/wiki/%E5%9B%BE_%28%E6%95%B0%E5%AD%A6%29#%E6%9C%89/%E7%84%A1_%E5%90%91%E5%9B%BE) and [shortest path](https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98).", "description": "There are $N$ cities in the Penguin Kingdom, numbered from $1$ to $N$.\n\nFor any two cities $i$ and $j$, penguins can spend $(i~\\mathrm{xor}~j) \\times C$ time to travel from city $i$ to city $j$, where $C$ is a given constant.\n\nIn addition, there are $M$ one-way express channels. The $i$-th express channel goes from city $F_i$ to city $T_i$, and taking this channel costs $V_i$ time.\n\nNow a penguin named Doudou from **P**enguin **K**ingdom **U**niversity is considering the minimum time needed to travel from city $A$ to city $B$.", "inputFormat": "Read from standard input.\n\nThe first line of input contains three integers $N,M,C$ $(1 \\leq C \\leq 100)$, representing the number of cities, the number of express channels, and the given constant $C$ mentioned in the statement.\n\nThe next $M$ lines each contain three positive integers $F_i,T_i,V_i$ ($1 \\leq F_i \\leq N$, $1 \\leq T_i \\leq N, 1 \\leq V_i \\leq 100$), representing the start city, the end city, and the time cost of taking this channel, respectively.\n\nThe last line contains two positive integers $A,B$, representing the start city and the end city chosen by Doudou.", "outputFormat": "Output to standard output.\n\nOutput one line with a single integer, the minimum time required to travel from city $A$ to city $B$.", "hint": "Sample 1 explanation.\n\nIt is optimal to go directly from $1$ to $4$.\n\nSample 2 explanation.\n\nFirst go from $3$ to $2$, then take the channel from $2$ to $4$, and finally go from $4$ to $6$.\n\n![0](https://cdn.luogu.com.cn/upload/pic/16868.png)\n\nThe lively and lovely problem setter left everyone the picture below.\n\n![1](https://i.loli.net/2018/04/02/5ac1bb2333c22.jpg)\n\nCredit: https://www.luogu.org/discuss/show/38908\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#4] 最短路", "background": "在北纬 91°，有一个神奇的国度，叫做企鹅国。这里的企鹅也有自己发达的文明，称为企鹅文明。因为企鹅只有黑白两种颜色，所以他们的数学也是以二进制为基础发展的。\n\n比如早在 $11101001$ 年前，他们就有了异或这样一个数学概念。如果你不知道异或是什么，请出门过墙左转到[这里](https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96)。\n\n再比如早在 $1000010$ 年前，他们的大科学家 Penguin. Tu 就提出了[图](https://zh.wikipedia.org/wiki/%E5%9B%BE_%28%E6%95%B0%E5%AD%A6%29#%E6%9C%89/%E7%84%A1_%E5%90%91%E5%9B%BE)和[最短路径](https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98)这样一些概念。", "description": "企鹅国中有 $N$ 座城市，编号从 $1$ 到 $N$。\n\n对于任意的两座城市 $i$ 和 $j$，企鹅们可以花费 $(i~\\mathrm{xor}~j) \\times C$ 的时间从城市 $i$ 走到城市 $j$，这里 $C$ 为一个给定的常数。\n\n当然除此之外还有 $M$ 条单向的快捷通道，第 $i$ 条快捷通道从第 $F_i$​​ 个城市通向第 $T_i$​​ 个城市，走这条通道需要消耗 $V_i$​​ 的时间。\n\n现在来自 **P**enguin **K**ingdom **U**niversity 的企鹅豆豆正在考虑从城市 $A$ 前往城市 $B$ 最少需要多少时间？", "inputFormat": "从标准输入读入数据。\n\n输入第一行包含三个整数 $N,M,C$ $(1 \\leq C \\leq 100)$，表示企鹅国城市的个数、快捷通道的个数以及题面中提到的给定的常数 $C$。\n\n接下来的 $M$ 行，每行三个正整数 $F_i,T_i,V_i$​ ($1 \\leq F_i \\leq N$,$1 \\leq T_i \\leq N ,1\\leq V_i \\leq 100$)，分别表示对应通道的起点城市标号、终点城市标号和通过这条通道需要消耗的时间。\n\n最后一行两个正整数 $A,B$，表示企鹅豆豆选择的起点城市标号和终点城市标号。", "outputFormat": "输出到标准输出。\n\n输出一行一个整数，表示从城市 $A$ 前往城市 $B$ 需要的最少时间。", "hint": "**样例 1 解释**\n\n直接从 $1$ 走到 $4$ 就好了。\n\n**样例 2 解释**\n\n先从 $3$ 走到 $2$ ，再从 $2$ 通过通道到达 $4$ ，再从 $4$ 走到 $6$。\n\n![0](https://cdn.luogu.com.cn/upload/pic/16868.png)\n\n活泼可爱的出题人给大家留下了下面这张图。\n\n![1](https://i.loli.net/2018/04/02/5ac1bb2333c22.jpg)\n\nCredit: https://www.luogu.org/discuss/show/38908", "locale": "zh-CN"}}}
{"pid": "P4367", "type": "P", "difficulty": 7, "samples": [["5 4\n2 1 2 1\n1 1 1\n1 2 3 4\n1 2 2\n-8 -1 6\n4 -3 7\n-7 5 5\n-7 5 -5", "5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "斜率优化", "凸包", "Code+"], "title": "[Code+#4] Tommy 的结合", "background": "深邃的天空仿佛要吞噬一切，一场 Codeforces 比赛刚刚结束。“怎么还不理我……”，睡眼惺忪的 Tommy 拿起盖在一旁的手机。空空荡荡的 QQ 提示框，没有一丝的温度。Tommy 叹了口气。昏黄的灯发出微弱的光芒，抚摸着呼呼作响的电脑。\n\n桌面上堆满了写满 $\\partial$ 和 $\\int$ 的草稿纸，手机闪光灯自制的简易台灯发出刺眼的白光；灯火缱绻，映照一双如画倦容。十几个 DDL 就在附近，QQ 那边的人已经三天三夜没有合眼了。这是 Tommy 所不知道的事。", "description": "人生大概就是这样。在这物欲横流的红尘紫陌中，芸芸众生为了生计四处奔走，交谈越来越少，感情越来越淡。但是，著名科学家 Access Globe 的最新研究成果可以解决这样的问题：通过增加同时做的事情来增加共同语言。\n\nA 和 B 都得到了一些任务，设他们要执行的任务集合分别为 $V_A$​​ 和 $V_B$​​。对每个人来说，任务 $1$ 是必须一开始做的，而其他的每个任务 $e$ 都存在一个前置任务 $p_e$​，表示任务 $e$ 必须在任务 $p_e$​​ 完成后才能执行。也就是说，每个人的任务的依赖关系构成了一棵**有根外向树**，一个任务 $e$ 能被执行当且仅当 $p_e,p_{p_{e}},\\cdots,1$ 这些任务全部都被执行，称 $p$ **依赖**任务 $p_e,p_{p_{e}},\\cdots,1$。\n\n现在，A 和 B 希望他们能有一些任务是共同完成的，因此他们决定这样选出一些任务：A 选出 $m$ 个任务 $a_1,\\cdots,a_m$​​，要求 $a_1=1$，并且对于任意的 $1\\le i<m$，都要求 $a_{i+1}$ 依赖任务$a_i$​​,同时 B 也选出 $m$ 个满足同样要求的任务 $b_1,\\cdots,b_m$​​，这样，A 就可以沿着从 $1$ 到 $A_m$​​ 的路径依次执行这些任务，同时 B 也可以沿着 $1$ 到 $B_m$​​ 的路径依次执行这些任务；并且经过安排，当 A 在执行任务 $a_i$​​ 的时候，B 恰好在执行任务 $b_i$​​，在这时 A 和 B 就能取得联系，增进感情。\n\n模型的目标为最大化亲密度。对于一组同时执行任务的关系 $a_i$​ 和 $b_i$，可以获得 $C_{a_i,b_i}$​​​​ 的得分；同时，A 和 B 一旦失去联系，就会使得亲密度降低，在每一分钟，如果一方距离上次和对方联系后已经执行任务 $i$ 分钟，就会使得亲密度降低 $2i-1$。\n\n例如，两个人要做的任务所花费的时间分别为 $2,1,4,7$ 和 $4,8,3,6,4$，并且共同完成了第一个任务和最后一个任务，那么 A 在执行中间两个任务的 $1+4=5$ 分钟没有和 B 联系，使得亲密度降低 $1+3+...+11=25$；同时 B 在执行中间三个任务的 $8+3+6=17$ 分钟没有和 A 联系，使得亲密度降低 $1+3+...+35=289$。注意，亲密度的计算只和任务执行的时间有关；并且任意两个任务都可以作为 $a_i$​​ 和 $b_i$​​ 同时执行，不需要保证它们花费的时间相同。\n\n现在，给出 A 和 B 的任务、依赖关系和每个任务的执行时间，请你帮我们求出能够获得的最大的亲密度。", "inputFormat": "从标准输入读入数据。\n\n第一行两个整数 $|V_A|,|V_B|$；\n\n第二行 $|V_A|-1$ 个整数 $t^{(a)}_{2},t^{(a)}_{3},...,t^{(a)}_{|V_A|}$​​，表示 A 的每个任务的时间长度；\n\n第三行 $|V_B|-1$ 个整数 $t^{(b)}_{2},t^{(b)}_{3},...,t^{(b)}_{|V_B|}$，表示 B 的每个任务的时间长度；\n\n第四行 $|V_A|-1∣$ 个整数 $p^{(a)}_{2},p^{(a)}_{3},...,p^{(a)}_{|V_A|}$，表示 A 的每个任务的前置任务，保证 $p^{(a)}_{i}< i$；\n\n第五行 $|V_B|-1$ 个整数 $p^{(b)}_{2},p^{(b)}_{3},...,p^{(b)}_{|V_B|}$，表示 B 的每个任务的前置任务，保证 $p^{(b)}_{i}< i$；\n\n接下来 $|V_A|-1$ 行，每行 $|V_B|-1$ 个整数，第 $i-1$ 行第 $j-1$ 列为 $C_{i,j}$，表示 A 和 B 同时分别执行对应的任务 $i,j$ 能获得的亲密度，注意这些亲密度不一定是非负的；\n\n注意以上输入均不包括第 1 个任务的信息，因为它和亲密度的计算没有关系。\n", "outputFormat": "输出到标准输出。\n\n输出能获得的最大的亲密度。\n", "hint": "**样例解释**\n\nA 和 B 分别选出任务 $1,3,4$ 和 $1,2,3$，同时执行的任务对 $(1,1)$、$(3,2)$ 和 $(4,3)$ 使得他们获得了 $4+5=9$ 的亲密度；A 孤独地执行任务 $2$ 的 $2$ 分钟丢失了 $1+3=4$ 的亲密度，因此最终的总亲密度为 $9-4=5$。这就是亲密度最大的方案。\n\n![0](https://cdn.luogu.com.cn/upload/pic/16896.png)\n\n对于所有数据，$2\\le |V_A|,|V_B|\\le 2,666$，$1\\le t^{(a)}_i,t^{(b)}_i\\le 1,206$，$0\\le |C_{i,j}|\\le 2,017,011,328$。\n\nCredit: https://www.luogu.org/discuss/show/38908\n\nCredit：idea 与命题/陈俊锟　验题/Tommy > <\n\nGit Repo：https://git.thusaac.org/publish/CodePlus4\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#4] Tommy's Bonding", "background": "The deep sky seems to devour everything; a Codeforces contest has just ended. “Why are you still ignoring me...”, sleepy-eyed Tommy picks up the phone lying beside him. The empty QQ notification box carries no warmth. Tommy sighs. The dim lamp glows faintly, brushing over the humming computer.\n\nThe desk is piled with scratch paper full of $\\partial$ and $\\int$. The phone’s flashlight, a makeshift desk lamp, emits dazzling white light; the flickering lights reflect a painted, weary face. A dozen DDLs are around the corner, and the person on the other end of QQ hasn’t slept for three days and nights. This is what Tommy doesn’t know.", "description": "Life is probably like this. In this materialistic world, people hustle for a living, talk less and less, and grow more distant emotionally. However, the latest research by the renowned scientist Access Globe can solve this: increase the shared topics by increasing the things done simultaneously.\n\nA and B each receive some tasks. Let the sets of tasks they need to execute be $V_A$ and $V_B$, respectively. For each person, task $1$ must be done first, and each other task $e$ has a prerequisite task $p_e$, meaning task $e$ can be executed only after $p_e$ is completed. That is, the dependency of each person’s tasks forms a rooted directed tree whose edges point away from the root. A task $e$ can be executed if and only if all tasks $p_e, p_{p_e}, \\cdots, 1$ have been executed. We say task $e$ depends on tasks $p_e, p_{p_e}, \\cdots, 1$.\n\nNow, A and B hope to complete some tasks together, so they decide to select tasks as follows: A selects $m$ tasks $a_1, \\cdots, a_m$ with the requirements $a_1 = 1$ and, for any $1 \\le i < m$, task $a_{i+1}$ depends on $a_i$. Similarly, B selects $m$ tasks $b_1, \\cdots, b_m$ satisfying the same requirements. Then A can execute tasks along the path from $1$ to $a_m$ in order, and B can execute tasks along the path from $1$ to $b_m$ in order. Moreover, after scheduling, when A is executing task $a_i$, B is executing task $b_i$ at the same time. At such moments, A and B can get in touch and increase their intimacy.\n\nThe objective is to maximize the intimacy. For each pair of simultaneously executed tasks $a_i$ and $b_i$, they gain a score of $C_{a_i, b_i}$. Meanwhile, once A and B lose contact, their intimacy decreases: in each minute, if it is the $i$-th minute since one side last contacted the other, the intimacy decreases by $2i - 1$.\n\nFor example, suppose the times for the two people’s tasks are 2, 1, 4, 7 and 4, 8, 3, 6, 4, and they jointly complete only the first and the last tasks. Then A has 1 + 4 = 5 minutes without contact while executing the two middle tasks, which causes an intimacy decrease of $1 + 3 + \\cdots + 11 = 25$; B has 8 + 3 + 6 = 17 minutes without contact while executing the three middle tasks, which causes an intimacy decrease of $1 + 3 + \\cdots + 35 = 289$. Note that the intimacy calculation depends only on task execution times, and any two tasks can be executed simultaneously as $a_i$ and $b_i$; they need not take the same amount of time.\n\nGiven A’s and B’s tasks, dependencies, and the execution time of each task, please compute the maximum intimacy that can be achieved.", "inputFormat": "Read from standard input.\n\n- The first line contains two integers $|V_A|, |V_B|$.\n- The second line contains $|V_A| - 1$ integers $t^{(a)}_{2}, t^{(a)}_{3}, \\ldots, t^{(a)}_{|V_A|}$, the duration of each of A’s tasks.\n- The third line contains $|V_B| - 1$ integers $t^{(b)}_{2}, t^{(b)}_{3}, \\ldots, t^{(b)}_{|V_B|}$, the duration of each of B’s tasks.\n- The fourth line contains $|V_A| - 1$ integers $p^{(a)}_{2}, p^{(a)}_{3}, \\ldots, p^{(a)}_{|V_A|}$, the prerequisite of each of A’s tasks, with $p^{(a)}_{i} < i$ guaranteed.\n- The fifth line contains $|V_B| - 1$ integers $p^{(b)}_{2}, p^{(b)}_{3}, \\ldots, p^{(b)}_{|V_B|}$, the prerequisite of each of B’s tasks, with $p^{(b)}_{i} < i$ guaranteed.\n- Then follow $|V_A| - 1$ lines, each with $|V_B| - 1$ integers. In the $(i - 1)$-th row and $(j - 1)$-th column is $C_{i, j}$, the intimacy gained if A and B simultaneously execute tasks $i$ and $j$, respectively. Note that these intimacy scores are not necessarily nonnegative.\n\nNote: the above input does not include information for task $1$, because it is irrelevant to the intimacy calculation.", "outputFormat": "Output to standard output.\n\nPrint the maximum achievable intimacy.", "hint": "Sample explanation:\n\nA and B select tasks $1, 3, 4$ and $1, 2, 3$, respectively. The simultaneous pairs $(1, 1)$, $(3, 2)$, and $(4, 3)$ yield intimacy $4 + 5 = 9$. A executes task $2$ alone for 2 minutes and loses $1 + 3 = 4$ intimacy. Therefore, the final total intimacy is $9 - 4 = 5$. This is the optimal plan.\n\n![0](https://cdn.luogu.com.cn/upload/pic/16896.png)\n\nConstraints:\nFor all testdata, $2 \\le |V_A|, |V_B| \\le 2{,}666$, $1 \\le t^{(a)}_i, t^{(b)}_i \\le 1{,}206$, and $0 \\le |C_{i, j}| \\le 2{,}017{,}011{,}328$.\n\nCredit: https://www.luogu.org/discuss/show/38908\n\nCredit: idea and problemsetting/Chen Junkun; problem verification/Tommy > <\n\nGit Repo: https://git.thusaac.org/publish/CodePlus4\n\nThanks to Tencent for supporting this contest.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#4] Tommy 的结合", "background": "深邃的天空仿佛要吞噬一切，一场 Codeforces 比赛刚刚结束。“怎么还不理我……”，睡眼惺忪的 Tommy 拿起盖在一旁的手机。空空荡荡的 QQ 提示框，没有一丝的温度。Tommy 叹了口气。昏黄的灯发出微弱的光芒，抚摸着呼呼作响的电脑。\n\n桌面上堆满了写满 $\\partial$ 和 $\\int$ 的草稿纸，手机闪光灯自制的简易台灯发出刺眼的白光；灯火缱绻，映照一双如画倦容。十几个 DDL 就在附近，QQ 那边的人已经三天三夜没有合眼了。这是 Tommy 所不知道的事。", "description": "人生大概就是这样。在这物欲横流的红尘紫陌中，芸芸众生为了生计四处奔走，交谈越来越少，感情越来越淡。但是，著名科学家 Access Globe 的最新研究成果可以解决这样的问题：通过增加同时做的事情来增加共同语言。\n\nA 和 B 都得到了一些任务，设他们要执行的任务集合分别为 $V_A$​​ 和 $V_B$​​。对每个人来说，任务 $1$ 是必须一开始做的，而其他的每个任务 $e$ 都存在一个前置任务 $p_e$​，表示任务 $e$ 必须在任务 $p_e$​​ 完成后才能执行。也就是说，每个人的任务的依赖关系构成了一棵**有根外向树**，一个任务 $e$ 能被执行当且仅当 $p_e,p_{p_{e}},\\cdots,1$ 这些任务全部都被执行，称 $p$ **依赖**任务 $p_e,p_{p_{e}},\\cdots,1$。\n\n现在，A 和 B 希望他们能有一些任务是共同完成的，因此他们决定这样选出一些任务：A 选出 $m$ 个任务 $a_1,\\cdots,a_m$​​，要求 $a_1=1$，并且对于任意的 $1\\le i<m$，都要求 $a_{i+1}$ 依赖任务$a_i$​​,同时 B 也选出 $m$ 个满足同样要求的任务 $b_1,\\cdots,b_m$​​，这样，A 就可以沿着从 $1$ 到 $A_m$​​ 的路径依次执行这些任务，同时 B 也可以沿着 $1$ 到 $B_m$​​ 的路径依次执行这些任务；并且经过安排，当 A 在执行任务 $a_i$​​ 的时候，B 恰好在执行任务 $b_i$​​，在这时 A 和 B 就能取得联系，增进感情。\n\n模型的目标为最大化亲密度。对于一组同时执行任务的关系 $a_i$​ 和 $b_i$，可以获得 $C_{a_i,b_i}$​​​​ 的得分；同时，A 和 B 一旦失去联系，就会使得亲密度降低，在每一分钟，如果一方距离上次和对方联系后已经执行任务 $i$ 分钟，就会使得亲密度降低 $2i-1$。\n\n例如，两个人要做的任务所花费的时间分别为 $2,1,4,7$ 和 $4,8,3,6,4$，并且共同完成了第一个任务和最后一个任务，那么 A 在执行中间两个任务的 $1+4=5$ 分钟没有和 B 联系，使得亲密度降低 $1+3+...+11=25$；同时 B 在执行中间三个任务的 $8+3+6=17$ 分钟没有和 A 联系，使得亲密度降低 $1+3+...+35=289$。注意，亲密度的计算只和任务执行的时间有关；并且任意两个任务都可以作为 $a_i$​​ 和 $b_i$​​ 同时执行，不需要保证它们花费的时间相同。\n\n现在，给出 A 和 B 的任务、依赖关系和每个任务的执行时间，请你帮我们求出能够获得的最大的亲密度。", "inputFormat": "从标准输入读入数据。\n\n第一行两个整数 $|V_A|,|V_B|$；\n\n第二行 $|V_A|-1$ 个整数 $t^{(a)}_{2},t^{(a)}_{3},...,t^{(a)}_{|V_A|}$​​，表示 A 的每个任务的时间长度；\n\n第三行 $|V_B|-1$ 个整数 $t^{(b)}_{2},t^{(b)}_{3},...,t^{(b)}_{|V_B|}$，表示 B 的每个任务的时间长度；\n\n第四行 $|V_A|-1∣$ 个整数 $p^{(a)}_{2},p^{(a)}_{3},...,p^{(a)}_{|V_A|}$，表示 A 的每个任务的前置任务，保证 $p^{(a)}_{i}< i$；\n\n第五行 $|V_B|-1$ 个整数 $p^{(b)}_{2},p^{(b)}_{3},...,p^{(b)}_{|V_B|}$，表示 B 的每个任务的前置任务，保证 $p^{(b)}_{i}< i$；\n\n接下来 $|V_A|-1$ 行，每行 $|V_B|-1$ 个整数，第 $i-1$ 行第 $j-1$ 列为 $C_{i,j}$，表示 A 和 B 同时分别执行对应的任务 $i,j$ 能获得的亲密度，注意这些亲密度不一定是非负的；\n\n注意以上输入均不包括第 1 个任务的信息，因为它和亲密度的计算没有关系。\n", "outputFormat": "输出到标准输出。\n\n输出能获得的最大的亲密度。\n", "hint": "**样例解释**\n\nA 和 B 分别选出任务 $1,3,4$ 和 $1,2,3$，同时执行的任务对 $(1,1)$、$(3,2)$ 和 $(4,3)$ 使得他们获得了 $4+5=9$ 的亲密度；A 孤独地执行任务 $2$ 的 $2$ 分钟丢失了 $1+3=4$ 的亲密度，因此最终的总亲密度为 $9-4=5$。这就是亲密度最大的方案。\n\n![0](https://cdn.luogu.com.cn/upload/pic/16896.png)\n\n对于所有数据，$2\\le |V_A|,|V_B|\\le 2,666$，$1\\le t^{(a)}_i,t^{(b)}_i\\le 1,206$，$0\\le |C_{i,j}|\\le 2,017,011,328$。\n\nCredit: https://www.luogu.org/discuss/show/38908\n\nCredit：idea 与命题/陈俊锟　验题/Tommy > <\n\nGit Repo：https://git.thusaac.org/publish/CodePlus4\n\n感谢腾讯公司对此次比赛的支持。", "locale": "zh-CN"}}}
{"pid": "P4368", "type": "P", "difficulty": 3, "samples": [["3\n5 5 3 3 2 2\n5 7 3 5 2 2\n5 7 4 6 1 1", "1\n1\n1"], ["3\n5 5 3 3 3 2\n5 7 1 4 2 2\n5 7 1 2 1 2", "-1\n-1\n-1"], ["4\n999999999999 999999999999 454545454545 454545454545 1 1\n777777777777 777777777777 343434343434 343434343434 1 1\n777777777777 999999999999 343434343434 454545454545 1 1\n999999999999 777777777777 454545454545 343434343434 1 1", "454545454544\n343434343433\n-1\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["模拟", "数学", "枚举", "Code+"], "title": "[Code+#4] 喵呜", "background": "", "description": "在马路边有一排整齐的 $n$ 棵樱花树，每棵树的高度都恰好为 $h$。某天，一只可爱的小猫偶然跑到树上来玩，但是这只小猫有些对樱花过敏，所以她现在想赶快离开这些樱花树。\n\n具体来说，现在小猫位于第 $x$ 棵樱花树上高度为 $y$ 的位置，她可以通过两种跳跃来离开樱花树：\n\n轻轻跳：向左或向右移动 $a$ 棵樱花树的同时，所在高度下降 $b$，即一次轻轻跳可以从起点移动到第 $x+a$ 或 $x-a$ 棵树上高度为 $y-b$ 的位置，注意当小猫所在高度不大于 $b$ 时不可以使用轻轻跳。\n\n使劲跳：向左或向右移动 $a$ 棵樱花树的同时，所在高度上升 $b$，即一次使劲跳可以从起点移动到第 $x+a$ 或 $x-a$ 棵树上高度为 $y+b$ 的位置，注意当小猫所在高度大于 $h-b$ 时不可以使用使劲跳。\n\n为了离开这片樱花树，小猫需要移动到第 $1$ 或第 $n$ 棵树上，高度为 $h$ 或 $1$ 的位置（这样她可以呼吸新鲜空气或者直接走开樱花树）。现在小猫想知道，自己最少需要多少次跳跃才能达成目标。由于她是一只可爱的小猫，所以希望由你来告诉她。\n", "inputFormat": "从标准输入读入数据。\n\n输入数据第一行包含一个正整数 $T$，表示测试数据的组数，各组数据之间没有空行。\n\n接下来 $T$ 行，依次描述每组数据：\n\n每组数据包含一行，包含六个正整数 $n,h,x,y,a,b$，其含义见题目描述。\n", "outputFormat": "输出到标准输出。\n\n输出由 $T$ 组数据组成，各组数据之间没有空行。对于每一组数据：\n\n若小猫可以成功离开樱花树，请输出她需要的最少跳跃次数。\n\n若小猫无法通过给定的跳跃方法离开樱花树，**请输出-1**。\n", "hint": "| 测试点编号 | $n,h$ 的范围 | 特殊约定 |\n| :----------: | :----------: | :----------: |\n|$1,2$  | $\\le10$ | $b=1$ |\n|$3,4$  |  $\\le10$| $a=b=1$ |\n|$5,6,7,8$  |$\\le10$  | 无 |\n|$9,10$  | $\\le500$ | $b=1$ |\n|  $11,12$| $\\le500$ | $a=b=1$ |\n|$13,14,15$  | $\\le500$ | 无 |\n|$16,17$  | $\\le10^5$ | $h\\le10$ |\n|$18,19,20$  | $\\le10^5$ | 无 |\n| $21,22$ | $\\le10^{15}$ | $h\\le10$ |\n| $23,24,25$ | $\\le10^{15}$ | 无 |\n\n对于所有数据，保证 $n \\geq 2$，$a < n$，$b \\leq h$。\n\nCredit: https://www.luogu.org/discuss/show/38908", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#4] Meow", "background": "", "description": "There is a neat row of $n$ cherry trees along the roadside, each exactly of height $h$. One day, a cute kitten happened to climb onto the trees to play, but she is a bit allergic to cherry blossoms, so she now wants to leave these cherry trees as soon as possible.\n\nSpecifically, the kitten is currently at height $y$ on the $x$-th cherry tree. She can leave the cherry trees by using two types of jumps:\n\nLight jump: Move $a$ trees to the left or right while decreasing the height by $b$. That is, in one light jump, she can move from the starting point to height $y-b$ on the $(x+a)$-th or $(x-a)$-th tree. Note that when the kitten’s current height is not greater than $b$, a light jump cannot be used.\n\nStrong jump: Move $a$ trees to the left or right while increasing the height by $b$. That is, in one strong jump, she can move from the starting point to height $y+b$ on the $(x+a)$-th or $(x-a)$-th tree. Note that when the kitten’s current height is greater than $h-b$, a strong jump cannot be used.\n\nTo leave this stretch of cherry trees, the kitten needs to move to either the $1$-st or the $n$-th tree, at height $h$ or $1$ (so that she can breathe fresh air or just walk away from the trees). Now she wants to know the minimum number of jumps required to achieve the goal. Since she is a cute kitten, she hopes you will tell her.", "inputFormat": "Read from standard input.\n\nThe first line contains a positive integer $T$, the number of groups of testdata. There are no blank lines between groups.\n\nThen follow $T$ lines, each describing one group of data:\n\nEach group consists of one line containing six positive integers $n,h,x,y,a,b$, whose meanings are as described in the problem statement.", "outputFormat": "Output to standard output.\n\nThe output consists of $T$ groups of results, with no blank lines between groups. For each group of data:\n\nIf the kitten can successfully leave the cherry trees, output the minimum number of jumps she needs.\n\nIf the kitten cannot leave the cherry trees using the given jump methods, please output -1.", "hint": "| Test point ID | Range of $n,h$ | Special note |\n| :----------: | :----------: | :----------: |\n| $1,2$  | $\\le 10$ | $b=1$ |\n| $3,4$  | $\\le 10$ | $a=b=1$ |\n| $5,6,7,8$  | $\\le 10$ | None |\n| $9,10$  | $\\le 500$ | $b=1$ |\n| $11,12$ | $\\le 500$ | $a=b=1$ |\n| $13,14,15$ | $\\le 500$ | None |\n| $16,17$ | $\\le 10^5$ | $h \\le 10$ |\n| $18,19,20$ | $\\le 10^5$ | None |\n| $21,22$ | $\\le 10^{15}$ | $h \\le 10$ |\n| $23,24,25$ | $\\le 10^{15}$ | None |\n\nFor all testdata, it is guaranteed that $n \\ge 2$, $a < n$, $b \\le h$.\n\nCredit: https://www.luogu.org/discuss/show/38908\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#4] 喵呜", "background": "", "description": "在马路边有一排整齐的 $n$ 棵樱花树，每棵树的高度都恰好为 $h$。某天，一只可爱的小猫偶然跑到树上来玩，但是这只小猫有些对樱花过敏，所以她现在想赶快离开这些樱花树。\n\n具体来说，现在小猫位于第 $x$ 棵樱花树上高度为 $y$ 的位置，她可以通过两种跳跃来离开樱花树：\n\n轻轻跳：向左或向右移动 $a$ 棵樱花树的同时，所在高度下降 $b$，即一次轻轻跳可以从起点移动到第 $x+a$ 或 $x-a$ 棵树上高度为 $y-b$ 的位置，注意当小猫所在高度不大于 $b$ 时不可以使用轻轻跳。\n\n使劲跳：向左或向右移动 $a$ 棵樱花树的同时，所在高度上升 $b$，即一次使劲跳可以从起点移动到第 $x+a$ 或 $x-a$ 棵树上高度为 $y+b$ 的位置，注意当小猫所在高度大于 $h-b$ 时不可以使用使劲跳。\n\n为了离开这片樱花树，小猫需要移动到第 $1$ 或第 $n$ 棵树上，高度为 $h$ 或 $1$ 的位置（这样她可以呼吸新鲜空气或者直接走开樱花树）。现在小猫想知道，自己最少需要多少次跳跃才能达成目标。由于她是一只可爱的小猫，所以希望由你来告诉她。\n", "inputFormat": "从标准输入读入数据。\n\n输入数据第一行包含一个正整数 $T$，表示测试数据的组数，各组数据之间没有空行。\n\n接下来 $T$ 行，依次描述每组数据：\n\n每组数据包含一行，包含六个正整数 $n,h,x,y,a,b$，其含义见题目描述。\n", "outputFormat": "输出到标准输出。\n\n输出由 $T$ 组数据组成，各组数据之间没有空行。对于每一组数据：\n\n若小猫可以成功离开樱花树，请输出她需要的最少跳跃次数。\n\n若小猫无法通过给定的跳跃方法离开樱花树，**请输出-1**。\n", "hint": "| 测试点编号 | $n,h$ 的范围 | 特殊约定 |\n| :----------: | :----------: | :----------: |\n|$1,2$  | $\\le10$ | $b=1$ |\n|$3,4$  |  $\\le10$| $a=b=1$ |\n|$5,6,7,8$  |$\\le10$  | 无 |\n|$9,10$  | $\\le500$ | $b=1$ |\n|  $11,12$| $\\le500$ | $a=b=1$ |\n|$13,14,15$  | $\\le500$ | 无 |\n|$16,17$  | $\\le10^5$ | $h\\le10$ |\n|$18,19,20$  | $\\le10^5$ | 无 |\n| $21,22$ | $\\le10^{15}$ | $h\\le10$ |\n| $23,24,25$ | $\\le10^{15}$ | 无 |\n\n对于所有数据，保证 $n \\geq 2$，$a < n$，$b \\leq h$。\n\nCredit: https://www.luogu.org/discuss/show/38908", "locale": "zh-CN"}}}
{"pid": "P4369", "type": "P", "difficulty": 3, "samples": [["6 2", "3 1\n3 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["Special Judge", "Code+"], "title": "[Code+#4] 组合数问题", "background": "", "description": "众所周知，小葱同学擅长计算，尤其擅长计算组合数，所以小葱给了你两个数 $x$ 和 $k$，希望你把 $x$ 分成恰好 $k$ 个不同的组合数的和。所谓不同，即对于两个组合数 $C(n_1,m_1)$ 和 $C(n_2,m_2)$，如果 $n_1\\neq n_2$​​ 或者 $m_1\\neq m_2$​，我们就称这两个组合数是不同的。为了使得计算不过于复杂，你需要保证你给出的任何一个组合数 $C(n,m)$ 满足 $0\\leq m\\leq n\\leq x$。数据保证一定有解。", "inputFormat": "从标准输入读入数据。\n\n第一行两个整数 $x,k$。\n", "outputFormat": "输出到标准输出。\n\n$k$ 行，每行两个整数 $n,m$ 代表一个组合数 $C(n,m)$。如果有多种可能的答案，任意输出一组即可。\n", "hint": "对于 $20\\%$ 的数据，$k=1$。\n\n对于另外 $20\\%$ 的数据，$x\\leq 100$。\n\n对于另外 $20\\%$ 的数据，$k=2$。\n\n对于 $100\\%$ 的数据，$1\\leq x\\leq 10^9,1\\leq k\\leq 10^3.$\n\nCredit: https://www.luogu.org/discuss/show/38908", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#4] Binomial Coefficient Problem", "background": "", "description": "As we all know, Xiao Cong is good at calculations, especially at computing binomial coefficients. So Xiao Cong gives you two numbers $x$ and $k$, and wants you to express $x$ as the sum of exactly $k$ distinct binomial coefficients. By distinct, we mean that for two binomial coefficients $C(n_1, m_1)$ and $C(n_2, m_2)$, if $n_1 \\neq n_2$ or $m_1 \\neq m_2$, then these two binomial coefficients are considered different. To keep the computation from being too complex, you must ensure that every binomial coefficient $C(n, m)$ you provide satisfies $0 \\leq m \\leq n \\leq x$. It is guaranteed that there is a solution.", "inputFormat": "Read from standard input.\n\nThe first line contains two integers $x, k$.", "outputFormat": "Output to standard output.\n\nOutput $k$ lines. Each line contains two integers $n, m$ representing a binomial coefficient $C(n, m)$. If multiple answers are possible, output any one of them.", "hint": "For $20\\%$ of the testdata, $k = 1$.\n\nFor another $20\\%$ of the testdata, $x \\leq 100$.\n\nFor another $20\\%$ of the testdata, $k = 2$.\n\nFor $100\\%$ of the testdata, $1 \\leq x \\leq 10^9, 1 \\leq k \\leq 10^3$.\n\nCredit: https://www.luogu.org/discuss/show/38908\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#4] 组合数问题", "background": "", "description": "众所周知，小葱同学擅长计算，尤其擅长计算组合数，所以小葱给了你两个数 $x$ 和 $k$，希望你把 $x$ 分成恰好 $k$ 个不同的组合数的和。所谓不同，即对于两个组合数 $C(n_1,m_1)$ 和 $C(n_2,m_2)$，如果 $n_1\\neq n_2$​​ 或者 $m_1\\neq m_2$​，我们就称这两个组合数是不同的。为了使得计算不过于复杂，你需要保证你给出的任何一个组合数 $C(n,m)$ 满足 $0\\leq m\\leq n\\leq x$。数据保证一定有解。", "inputFormat": "从标准输入读入数据。\n\n第一行两个整数 $x,k$。\n", "outputFormat": "输出到标准输出。\n\n$k$ 行，每行两个整数 $n,m$ 代表一个组合数 $C(n,m)$。如果有多种可能的答案，任意输出一组即可。\n", "hint": "对于 $20\\%$ 的数据，$k=1$。\n\n对于另外 $20\\%$ 的数据，$x\\leq 100$。\n\n对于另外 $20\\%$ 的数据，$k=2$。\n\n对于 $100\\%$ 的数据，$1\\leq x\\leq 10^9,1\\leq k\\leq 10^3.$\n\nCredit: https://www.luogu.org/discuss/show/38908", "locale": "zh-CN"}}}
{"pid": "P4370", "type": "P", "difficulty": 6, "samples": [["2 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["优先队列", "逆元", "队列", "Code+"], "title": "[Code+#4] 组合数问题2", "background": "", "description": "众所周知，小葱同学擅长计算，尤其擅长计算组合数，所以小葱给了你两个数 $n$ 和 $k$，希望你找到 $k$ 个不同的组合数使得这 $k$ 个组合数的和最大。所谓不同的组合数，即对于组合数 $C_{a_1}^{b_1}$​​​ 和 $C_{a_2}^{b_2}$，若 $a_1\\neq a_2$ 或者 $b_1\\neq b_2$​​，则我们认为这两个组合数是不同的。现在小葱希望你找到这样 $k$ 个不同的组合数，使得它们互不相同且对于其中任何一个组合数 $C_a^b$ 有 $0\\leq b\\leq a\\leq n$。问这 $k$ 个组合数的和最大是多少？", "inputFormat": "从标准输入读入数据。\n\n第一行两个整数 $n,k$。\n", "outputFormat": "输出到标准输出。\n\n一行一个整数，代表 $k$ 个组合数的和对 $10^9+7$ 取模之后的结果；数据保证一定有至少 $k$ 个数可以选。\n", "hint": "对于 $20\\%$ 的数据，$n\\leq 10$。\n\n对于 $40\\%$ 的数据，$n\\leq 500$。\n\n对于另外 $20\\%$ 的数据，$k=1$。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 10^6,1\\leq k\\leq 10^5.$\n\nCredit: https://www.luogu.org/discuss/show/38908", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#4] Binomial Coefficient Problem 2", "background": "", "description": "It is well known that Xiaocong is skilled at calculation, especially at computing binomial coefficients. Given two numbers $n$ and $k$, he wants you to find $k$ distinct binomial coefficients such that their sum is maximized. By distinct binomial coefficients, for $C_{a_1}^{b_1}$ and $C_{a_2}^{b_2}$, if $a_1\\neq a_2$ or $b_1\\neq b_2$, we consider them different. Now, please find such $k$ distinct binomial coefficients so that for any one of them $C_a^b$ we have $0\\leq b\\leq a\\leq n$. What is the maximum possible sum of these $k$ binomial coefficients?", "inputFormat": "Read from standard input.\n\nThe first line contains two integers $n,k$.", "outputFormat": "Write to standard output.\n\nOne line with a single integer, representing the sum of the $k$ binomial coefficients modulo $10^9+7$; it is guaranteed that there are at least $k$ numbers to choose from.", "hint": "For 20% of the testdata, $n\\leq 10$.\n\nFor 40% of the testdata, $n\\leq 500$.\n\nFor another 20% of the testdata, $k=1$.\n\nFor 100% of the testdata, $1\\leq n\\leq 10^6,1\\leq k\\leq 10^5.$\n\nCredit: https://www.luogu.org/discuss/show/38908\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#4] 组合数问题2", "background": "", "description": "众所周知，小葱同学擅长计算，尤其擅长计算组合数，所以小葱给了你两个数 $n$ 和 $k$，希望你找到 $k$ 个不同的组合数使得这 $k$ 个组合数的和最大。所谓不同的组合数，即对于组合数 $C_{a_1}^{b_1}$​​​ 和 $C_{a_2}^{b_2}$，若 $a_1\\neq a_2$ 或者 $b_1\\neq b_2$​​，则我们认为这两个组合数是不同的。现在小葱希望你找到这样 $k$ 个不同的组合数，使得它们互不相同且对于其中任何一个组合数 $C_a^b$ 有 $0\\leq b\\leq a\\leq n$。问这 $k$ 个组合数的和最大是多少？", "inputFormat": "从标准输入读入数据。\n\n第一行两个整数 $n,k$。\n", "outputFormat": "输出到标准输出。\n\n一行一个整数，代表 $k$ 个组合数的和对 $10^9+7$ 取模之后的结果；数据保证一定有至少 $k$ 个数可以选。\n", "hint": "对于 $20\\%$ 的数据，$n\\leq 10$。\n\n对于 $40\\%$ 的数据，$n\\leq 500$。\n\n对于另外 $20\\%$ 的数据，$k=1$。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 10^6,1\\leq k\\leq 10^5.$\n\nCredit: https://www.luogu.org/discuss/show/38908", "locale": "zh-CN"}}}
{"pid": "P4371", "type": "P", "difficulty": 6, "samples": [["6\n30 30 30 30\n120 60 120 60\n270 100 270 100\n30 30 120 60\n120 60 270 100\n270 100 30 30", "0.8785\n0.7540\n0.2600\n0.9704\n0.9408\n0.8785"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["Code+"], "title": "[Code+#4] 白金元首与七彩魔法", "background": "小朋友 你们好吗　还能记得 我是谁吗　我就是魔法元首まどか！", "description": "「和我签订契约，成为魔法元首吧！」\n\n于是这天元首不明所以地被地外生物 Kyubey 忽悠去成为了魔法元首。不过在开始练习魔法之前，元首需要为自己的魔法选择一个代表色。\n\n下图是一个明度最大（即，HSV 色彩空间中 $V = 100\\%$）的单位圆色盘。色盘上任意一点的坐标为一个非负实数对 (α°,$r\\%$) $(0 \\leq \\alpha < 360,0 \\leq r \\leq 100)$，表示色相为 α°、饱和度为 $r\\%$ 的颜色。另一种理解是，α° 表示从联结圆心和纯红色点的射线顺时针到达该点所经过的角度，$\\frac {r}{100}$​​ 是该点到单位圆圆心的距离。\n\n![0](https://i.loli.net/2018/04/02/5ac1bb23a4d50.png)\n\n具体而言，从这个坐标 (α°,$r\\%$) 到红绿蓝颜色值 $(R,G,B)$ 的转换如下：\n\n![1](https://cdn.luogu.com.cn/upload/pic/16828.png)\n\n请参照样例确认你对公式的理解和实现。\n\n按照 Kyubey 的判断，元首可以选择色盘所在的平面上一条给定直线段 (α1°,$r1\\%$)-(α2°,$r2\\%$) 上的任意颜色。元首可不需要犹豫，作为一名 bling bling 的帝国领导者，当然要选择最亮的颜色啦！\n\n一个颜色 $(R,G,B)$ 的亮度定义为 $L = 0.30R + 0.59G + 0.11B$。下图给出了彩色色盘和表示亮度的灰度色盘的左右对比。\n\n![2](https://i.loli.net/2018/04/02/5ac1bb2371a0b.png)\n\n你需要编写程序帮助元首计算给定直线段上所有颜色的最大亮度。", "inputFormat": "从标准输入读入数据。\n\n输入的第一行包含一个正整数 $T$—— 数据的组数。接下来包含 $T$ 组数据，格式如下，数据间没有空行。\n\n第 $1$ 行：四个空格分隔的整数 $\\alpha_1$​​、$r_1$​​、$\\alpha_2$​​、$r_2$​​。\n\n", "outputFormat": "输出到标准输出。\n\n对于每组数据输出一行，包含一个 $[0,1]$ 范围内的十进制小数 —— 直线段 (α1°,$r1\\%$)-(α2°,$r2\\%$) 上所有颜色的最大亮度，四舍五入保留恰好四位小数。数据保证若参考答案为 $A$，则 [$A-10^{-5},A+10^{-5}$]​ 范围内任意实数四舍五入到第四位小数后均相等。\n", "hint": "**样例解释**\n\n点 (30°, $30\\%$) 的红绿蓝颜色值为 $(1.00, 0.85, 0.70)$，亮度为 $0.30 \\times 1.00 + 0.59 \\times 0.85 + 0.11 \\times 0.70 = 0.8785$；\n\n点 (120°,$60\\%$) 的红绿蓝颜色值为 $(0.40, 1.00, 0.40)$，亮度为 $0.30 \\times 0.40 + 0.59 \\times 1.00 + 0.11 \\times 0.40 = 0.7540$； \n\n点 (270°,$100\\%$) 的红绿蓝颜色值为 $(0.50, 0.00, 1.00)$，亮度为 $0.30 \\times 0.50 + 0.59 \\times 0.00 + 0.11 \\times 1.00 = 0.2600$。\n\n![6](https://cdn.luogu.com.cn/upload/pic/16899.png)\n\n “Ich glaube, ich habe mich klar genug ausgedrückt!”\n\n题面与史实无关。\n\nCredit: https://www.luogu.org/discuss/show/38908", "locale": "zh-CN", "translations": {"en": {"title": "[Code+#4] Platinum Head of State and Seven-Color Magic", "background": "Children, how are you? Do you still remember who I am? I am the magical head of state Madoka!", "description": "\"Make a contract with me and become a magical head of state!\"\n\nOn this day, the head of state was coaxed by the extraterrestrial creature Kyubey into becoming a magical head of state. However, before practicing magic, the head of state needs to choose a representative color for their magic.\n\nThe figure below is a unit-circle color wheel with maximum value (that is, in the HSV color space, $V = 100\\%$). The coordinates of any point on the wheel are a pair of nonnegative real numbers $(\\alpha^\\circ, r\\%)$ ($0 \\leq \\alpha < 360, 0 \\leq r \\leq 100$), meaning a color with hue $\\alpha^\\circ$ and saturation $r\\%$. Another interpretation is that $\\alpha^\\circ$ is the angle swept clockwise from the ray connecting the center of the circle to the pure red point to the given point, and $\\frac{r}{100}$ is the distance from that point to the center of the unit circle.\n\n![0](https://i.loli.net/2018/04/02/5ac1bb23a4d50.png)\n\nSpecifically, the conversion from these coordinates $(\\alpha^\\circ, r\\%)$ to RGB values $(R, G, B)$ is as follows:\n\n![1](https://cdn.luogu.com.cn/upload/pic/16828.png)\n\nPlease refer to the sample to confirm your understanding and implementation of the formula.\n\nAccording to Kyubey, the head of state may choose any color on a given line segment $(\\alpha_1^\\circ, r_1\\%)-(\\alpha_2^\\circ, r_2\\%)$ lying on the plane of the color wheel. No need to hesitate—being a bling bling imperial leader, of course they will choose the brightest color!\n\nThe brightness of a color $(R, G, B)$ is defined as $L = 0.30R + 0.59G + 0.11B$. The figure below shows a side-by-side comparison between the colorful color wheel and a grayscale wheel representing brightness.\n\n![2](https://i.loli.net/2018/04/02/5ac1bb2371a0b.png)\n\nYou need to write a program to compute the maximum brightness among all colors on the given line segment.", "inputFormat": "Read from standard input.\n\nThe first line contains a positive integer $T$ — the number of test cases. Then follow $T$ test cases with no blank lines between them.\n\nLine 1: Four space-separated integers $\\alpha_1$, $r_1$, $\\alpha_2$, $r_2$.", "outputFormat": "Output to standard output.\n\nFor each test case, output one line containing a decimal in the range $[0, 1]$ — the maximum brightness among all colors on the line segment $(\\alpha_1^\\circ, r_1\\%)-(\\alpha_2^\\circ, r_2\\%)$, rounded to exactly four decimal places. It is guaranteed that if the reference answer is $A$, then any real number in the range $[A - 10^{-5}, A + 10^{-5}]$ will round to the same value at four decimal places.", "hint": "Sample explanation:\n\nThe point $(30^\\circ, 30\\%)$ has RGB values $(1.00, 0.85, 0.70)$, with brightness $0.30 \\times 1.00 + 0.59 \\times 0.85 + 0.11 \\times 0.70 = 0.8785$.\n\nThe point $(120^\\circ, 60\\%)$ has RGB values $(0.40, 1.00, 0.40)$, with brightness $0.30 \\times 0.40 + 0.59 \\times 1.00 + 0.11 \\times 0.40 = 0.7540$.\n\nThe point $(270^\\circ, 100\\%)$ has RGB values $(0.50, 0.00, 1.00)$, with brightness $0.30 \\times 0.50 + 0.59 \\times 0.00 + 0.11 \\times 1.00 = 0.2600$.\n\n![6](https://cdn.luogu.com.cn/upload/pic/16899.png)\n\n\"Ich glaube, ich habe mich klar genug ausgedrückt!\"\n\nThis statement has nothing to do with historical facts.\n\nCredit: https://www.luogu.org/discuss/show/38908\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[Code+#4] 白金元首与七彩魔法", "background": "小朋友 你们好吗　还能记得 我是谁吗　我就是魔法元首まどか！", "description": "「和我签订契约，成为魔法元首吧！」\n\n于是这天元首不明所以地被地外生物 Kyubey 忽悠去成为了魔法元首。不过在开始练习魔法之前，元首需要为自己的魔法选择一个代表色。\n\n下图是一个明度最大（即，HSV 色彩空间中 $V = 100\\%$）的单位圆色盘。色盘上任意一点的坐标为一个非负实数对 (α°,$r\\%$) $(0 \\leq \\alpha < 360,0 \\leq r \\leq 100)$，表示色相为 α°、饱和度为 $r\\%$ 的颜色。另一种理解是，α° 表示从联结圆心和纯红色点的射线顺时针到达该点所经过的角度，$\\frac {r}{100}$​​ 是该点到单位圆圆心的距离。\n\n![0](https://i.loli.net/2018/04/02/5ac1bb23a4d50.png)\n\n具体而言，从这个坐标 (α°,$r\\%$) 到红绿蓝颜色值 $(R,G,B)$ 的转换如下：\n\n![1](https://cdn.luogu.com.cn/upload/pic/16828.png)\n\n请参照样例确认你对公式的理解和实现。\n\n按照 Kyubey 的判断，元首可以选择色盘所在的平面上一条给定直线段 (α1°,$r1\\%$)-(α2°,$r2\\%$) 上的任意颜色。元首可不需要犹豫，作为一名 bling bling 的帝国领导者，当然要选择最亮的颜色啦！\n\n一个颜色 $(R,G,B)$ 的亮度定义为 $L = 0.30R + 0.59G + 0.11B$。下图给出了彩色色盘和表示亮度的灰度色盘的左右对比。\n\n![2](https://i.loli.net/2018/04/02/5ac1bb2371a0b.png)\n\n你需要编写程序帮助元首计算给定直线段上所有颜色的最大亮度。", "inputFormat": "从标准输入读入数据。\n\n输入的第一行包含一个正整数 $T$—— 数据的组数。接下来包含 $T$ 组数据，格式如下，数据间没有空行。\n\n第 $1$ 行：四个空格分隔的整数 $\\alpha_1$​​、$r_1$​​、$\\alpha_2$​​、$r_2$​​。\n\n", "outputFormat": "输出到标准输出。\n\n对于每组数据输出一行，包含一个 $[0,1]$ 范围内的十进制小数 —— 直线段 (α1°,$r1\\%$)-(α2°,$r2\\%$) 上所有颜色的最大亮度，四舍五入保留恰好四位小数。数据保证若参考答案为 $A$，则 [$A-10^{-5},A+10^{-5}$]​ 范围内任意实数四舍五入到第四位小数后均相等。\n", "hint": "**样例解释**\n\n点 (30°, $30\\%$) 的红绿蓝颜色值为 $(1.00, 0.85, 0.70)$，亮度为 $0.30 \\times 1.00 + 0.59 \\times 0.85 + 0.11 \\times 0.70 = 0.8785$；\n\n点 (120°,$60\\%$) 的红绿蓝颜色值为 $(0.40, 1.00, 0.40)$，亮度为 $0.30 \\times 0.40 + 0.59 \\times 1.00 + 0.11 \\times 0.40 = 0.7540$； \n\n点 (270°,$100\\%$) 的红绿蓝颜色值为 $(0.50, 0.00, 1.00)$，亮度为 $0.30 \\times 0.50 + 0.59 \\times 0.00 + 0.11 \\times 1.00 = 0.2600$。\n\n![6](https://cdn.luogu.com.cn/upload/pic/16899.png)\n\n “Ich glaube, ich habe mich klar genug ausgedrückt!”\n\n题面与史实无关。\n\nCredit: https://www.luogu.org/discuss/show/38908", "locale": "zh-CN"}}}
{"pid": "P4372", "type": "P", "difficulty": 6, "samples": [["7\n20\n2\n3\n4\n9\n8\n7", "12\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "USACO", "排序", "Ad-hoc"], "title": "[USACO18OPEN] Out of Sorts P", "background": "", "description": "留意着农场之外的长期职业生涯的可能性，奶牛 Bessie 开始在不同的在线编程网站上学习算法。她最喜欢的两个算法是“冒泡排序”和“快速排序”，但不幸的是，Bessie 轻易地把它们搞混了，最后实现了一个奇怪的混合算法！\n\n如果数组 $A$ 中 $A[0 \\ldots i]$ 的最大值不大于 $A[i+1 \\ldots N-1]$ 的最小值，我们就称元素 $i$ 和 $i+1$ 之间的位置为一个“分隔点”。Bessie 还记得快速排序包含对数组的重排，产生一个分隔点，然后递归对两侧的 $A[0 \\ldots i]$ 和 $A[i+1 \\ldots N-1]$ 排序。然而，尽管她正确地记下了数组中所有的分隔点都可以在线性时间内求出，她却忘记了快速排序应该如何重排来快速构造一个分隔点！在这个可能是排序算法历史上最糟糕的失误之下，她做出了一个不幸的决定：使用冒泡排序来完成这个任务。\n\n以下是 Bessie 最初对数组 $A$ 进行排序的实现的概要。她首先写了一个简单的函数，执行冒泡排序的一轮：\n\n```\nbubble_sort_pass(A) {\n   for i = 0 to length(A)-2\n      if A[i] > A[i+1], swap A[i] and A[i+1]\n}\n```\n\n她的快速排序（相当快）函数的递归代码如下：\n\n```\nquickish_sort(A) {\n   if length(A) == 1, return\n   do { // Main loop\n      work_counter = work_counter + length(A)\n      bubble_sort_pass(A)\n   } while (no partition points exist in A)\n   divide A at all partition points; recursively quickish_sort each piece\n}\n```\n\nBessie 好奇于她的代码能够运行得多快。简单起见，她计算出主循环的每一轮都消耗线性时间，因此她通过增加一个全局变量 `work_counter` 的值来跟踪整个算法完成的总工作量。\n\n给定一个输入数组，请预测 `quickish_sort` 函数接收这个数组后，变量 `work_counter` 的最终值。", "inputFormat": "输入的第一行包含 $N$（$1 \\leq N \\leq 100,000$）。接下来的 $N$ 行描述了 $A[0] \\ldots A[N-1]$，每个数都是一个范围在 $0 \\ldots 10^9$ 的整数。输入数据不保证各不相同。", "outputFormat": "输出 `work_counter` 的最终值。", "hint": "在这个例子中，数组初始为 `20 2 3 4 9 8 7`。在一轮冒泡排序之后（增加 $7$ 的工作量），我们得到 `2 | 3 | 4 | 9 8 7 | 20`，其中 `|` 表示一个分隔点。于是问题被分成了递归的子问题，包括对 `2`、`3`、`4`、`20` 排序（每个消耗 $0$ 单元的工作量）和对 `9 8 7` 排序。对于 `9 8 7` 这个子问题，主循环的一轮（$3$ 单元工作量）得到 `8 7 | 9`，在此之后最后一轮处理 `8 7`（$2$ 单元工作量）就有效地完成了排序。\n\n题目来源：Brian Dean", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18OPEN] Out of Sorts P", "background": "", "description": "Eyeing the possibility of a long-term career beyond the farm, the cow Bessie starts learning algorithms on various online programming sites. Her two favorite algorithms are \"bubble sort\" and \"quicksort,\" but unfortunately, Bessie easily mixes them up and ends up implementing a strange hybrid algorithm!\n\nIf in array $A$ the maximum of $A[0 \\ldots i]$ is no greater than the minimum of $A[i+1 \\ldots N-1]$, then the position between elements $i$ and $i+1$ is called a \"partition point.\" Bessie also remembers that quicksort involves rearranging the array to produce a partition point, and then recursively sorting $A[0 \\ldots i]$ and $A[i+1 \\ldots N-1]$ on the two sides. However, although she correctly notes that all the partition points in the array can be found in linear time, she forgets how quicksort should rearrange the array to quickly construct a partition point. In what is perhaps the worst blunder in the history of sorting algorithms, she makes the unfortunate decision to use bubble sort to perform this task.\n\nBelow is a summary of Bessie's initial implementation for sorting array $A$. She first writes a simple function that performs one pass of bubble sort:\n\n```\nbubble_sort_pass(A) {\n   for i = 0 to length(A)-2\n      if A[i] > A[i+1], swap A[i] and A[i+1]\n}\n```\n\nThe recursive code of her quickish sort function is as follows:\n\n```\nquickish_sort(A) {\n   if length(A) == 1, return\n   do { // Main loop\n      work_counter = work_counter + length(A)\n      bubble_sort_pass(A)\n   } while (no partition points exist in A)\n   divide A at all partition points; recursively quickish_sort each piece\n}\n```\n\nBessie is curious how fast her code can run. For simplicity, she decides that each iteration of the main loop takes linear time, so she tracks the total amount of work done by the entire algorithm by increasing a global variable, work_counter.\n\nGiven an input array, please predict the final value of work_counter after the quickish_sort function processes this array.", "inputFormat": "The first line of input contains $N$ ($1 \\leq N \\leq 100{,}000$). The next $N$ lines describe $A[0] \\ldots A[N-1]$, each being an integer in the range $0 \\ldots 10^9$. The input numbers are not guaranteed to be distinct.", "outputFormat": "Output the final value of work_counter.", "hint": "In this example, the array initially is `20 2 3 4 9 8 7`. After one pass of bubble sort (adding $7$ units of work), we obtain `2 | 3 | 4 | 9 8 7 | 20`, where `|` denotes a partition point. The problem then splits into recursive subproblems, including sorting `2`, `3`, `4`, and `20` (each costing $0$ units of work) and sorting `9 8 7`. For the subproblem `9 8 7`, one iteration of the main loop ($3$ units of work) yields `8 7 | 9`, after which the final pass on `8 7` ($2$ units of work) effectively completes the sort.\n\nSource: Brian Dean.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18OPEN] Out of Sorts P", "background": "", "description": "留意着农场之外的长期职业生涯的可能性，奶牛 Bessie 开始在不同的在线编程网站上学习算法。她最喜欢的两个算法是“冒泡排序”和“快速排序”，但不幸的是，Bessie 轻易地把它们搞混了，最后实现了一个奇怪的混合算法！\n\n如果数组 $A$ 中 $A[0 \\ldots i]$ 的最大值不大于 $A[i+1 \\ldots N-1]$ 的最小值，我们就称元素 $i$ 和 $i+1$ 之间的位置为一个“分隔点”。Bessie 还记得快速排序包含对数组的重排，产生一个分隔点，然后递归对两侧的 $A[0 \\ldots i]$ 和 $A[i+1 \\ldots N-1]$ 排序。然而，尽管她正确地记下了数组中所有的分隔点都可以在线性时间内求出，她却忘记了快速排序应该如何重排来快速构造一个分隔点！在这个可能是排序算法历史上最糟糕的失误之下，她做出了一个不幸的决定：使用冒泡排序来完成这个任务。\n\n以下是 Bessie 最初对数组 $A$ 进行排序的实现的概要。她首先写了一个简单的函数，执行冒泡排序的一轮：\n\n```\nbubble_sort_pass(A) {\n   for i = 0 to length(A)-2\n      if A[i] > A[i+1], swap A[i] and A[i+1]\n}\n```\n\n她的快速排序（相当快）函数的递归代码如下：\n\n```\nquickish_sort(A) {\n   if length(A) == 1, return\n   do { // Main loop\n      work_counter = work_counter + length(A)\n      bubble_sort_pass(A)\n   } while (no partition points exist in A)\n   divide A at all partition points; recursively quickish_sort each piece\n}\n```\n\nBessie 好奇于她的代码能够运行得多快。简单起见，她计算出主循环的每一轮都消耗线性时间，因此她通过增加一个全局变量 `work_counter` 的值来跟踪整个算法完成的总工作量。\n\n给定一个输入数组，请预测 `quickish_sort` 函数接收这个数组后，变量 `work_counter` 的最终值。", "inputFormat": "输入的第一行包含 $N$（$1 \\leq N \\leq 100,000$）。接下来的 $N$ 行描述了 $A[0] \\ldots A[N-1]$，每个数都是一个范围在 $0 \\ldots 10^9$ 的整数。输入数据不保证各不相同。", "outputFormat": "输出 `work_counter` 的最终值。", "hint": "在这个例子中，数组初始为 `20 2 3 4 9 8 7`。在一轮冒泡排序之后（增加 $7$ 的工作量），我们得到 `2 | 3 | 4 | 9 8 7 | 20`，其中 `|` 表示一个分隔点。于是问题被分成了递归的子问题，包括对 `2`、`3`、`4`、`20` 排序（每个消耗 $0$ 单元的工作量）和对 `9 8 7` 排序。对于 `9 8 7` 这个子问题，主循环的一轮（$3$ 单元工作量）得到 `8 7 | 9`，在此之后最后一轮处理 `8 7`（$2$ 单元工作量）就有效地完成了排序。\n\n题目来源：Brian Dean", "locale": "zh-CN"}}}
{"pid": "P4373", "type": "P", "difficulty": 7, "samples": [["10 3\n5 7 9 2 0 1 7 4 3 6", "5\n2\n0\n0\n0\n1\n3\n3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "USACO", "单调队列", "交互题", "Special Judge", "分块"], "title": "[USACO18OPEN] Train Tracking P", "background": "鉴于本题存在特殊要求且大部分人**不遵守**，题解通道关闭。如确有正解，请联系管理员单独添加。\n\n1. 你的程序不需要，也不应该包含 `grader.h` 头文件。\n2. 请在程序中加入如下函数声明语句：\n\n```cpp\nint get(int);\nvoid set(int,int);\nvoid shoutMinimum(int);\nint getTrainLength();\nint getWindowLength();\nint getCurrentCarIndex();\nint getCurrentPassIndex();\n```", "description": "每天早晨特快列车会经过农场，开往大城市，每天下午它又会折回来，回到郊区。今天，Bessie 会花时间观察它，早晨和下午都会。\n\nBessie 提前知道，列车有 $N$ 节车厢，方便起见，将其编号为 $0\\sim N-1$。车厢 $i$ 有一个 ID $c_i$。在早晨和下午，所有的数字都是可见的，所以对于每节车厢 Bessie 有两次机会观察它的 ID。也就是说，当列车早晨经过的时候，Bessie 能够观察 $c_0$，然后是 $c_1$，直到 $c_{N-1}$。当列车下午驶回的时候，她又一次能够观察 $c_0$，然后是 $c_1$，直到 $c_{N-1}$。 \n\nBessie 挑选了一个整数 $K$，她想要求出每个连续的 $K$ 节车厢中最小的 ID。她有一本能够帮助执行计算的笔记本，但是这个笔记本相当小，并且 Bessie 的手写（蹄写？）字相当大。比方说，可能没有足够的空间记下所有 $N+1-K$ 个最小值。由于某些神秘的原因，Bessie 满足于当她算出最小数的时候向天哞出这些数，所以这个问题至少还不成问题。\n\n列车马上就要来了！帮助 Bessie 在列车经过两次之后求出这 $N+1−K$ 个最小数，确保她有效地利用她有限的笔记本空间。她的笔记本被分为 $5500$ 个部分，方便起见编号为 $0\\sim 5499$，每个部分的空间恰好能够记录一个在 $[-2^{31} , 2^{31}-1]$ 之间的整数。最初的时候，每个部分都记录着整数 $0$。\n\n请帮助 Bessie 有效管理她有限的笔记本空间。\n\n### 交互方式\n\n这是一道交互式题目，你不需要使用标准（或文件）输入输出。具体地说，你需要实现下面的函数，这个函数用来帮助 Bessie 有效管理她有限的笔记本空间：\n\n```cpp\nvoid helpBessie(int ID);\n```\n\n每当一节列车车厢经过的时候，无论是在早晨和下午，你的函数都会被调用，函数的输入是这节车厢的 ID。 \n\n你的 `helpBessie` 函数的实现可以调用下面这些函数：\n\n- `int get(int index)`：获取记录在 Bessie 的笔记本上的给定的索引处的整数值（_index_）。\n- `void set (int index, int value)`：设置给定的索引（_index_）处的值为给定的整数值（_value_）。\n- `void shoutMinimum (int output)`：通知 Bessie 向天哞一个指定的数。\n- `int getTrainLength()`：返回列车的车厢数 $N$。\n- `int getWindowLength()`：返回窗口的长度 $K$。\n- `int getCurrentCarIndex()`：返回当前正在通过的车厢编号。\n- `int getCurrentPassIndex()`：如果 Bessie 正在观察早晨的列车返回 $0$，下午的列车返回 $1$。\n\n为了帮助你开始编码，我们为你提供了初始的 C/C++ 模板。遗憾地，这道题目不支持 Python 和 Pascal 语言的程序。\n\n```cpp\n#include \"grader.h\"\n\n// If you find it necessary, you may import standard libraries here.\n\nvoid helpBessie(int ID)\n{\n\t// Put your code here.\n}\n```\n\n调用 `void shoutMinimum (int output)` 函数进行输出。\n\n各个窗口的最小数必须按顺序输出（所以车厢 $0,1,\\cdots ,K−1$ 之中的最小值必须在车厢 $1,2,\\cdots ,K$ 之中的最小值之前输出，等等），但是除了这个顺序的限制之外，你的函数可以在任何一次函数调用中任意多次地输出一些最小值。比如，你的函数可能在某几次调用中不产生任何输出，而在某几次调用中产生多个输出。\n\nBessie 拥有惊人的短时记忆能力，因此在 `helpBessie` 函数中没有任何的内存使用限制，除了要满足常规的 256MB 限制。然而，在车厢与车厢之间，Bessie 不能够「记住」任何不在笔记本中出现过的内容。所以在两次函数调用之间，你的程序除了通过 `get` 和 `set` 函数调用之外不能保存任何的状态。\n\n这意味着：\n\n**不允许定义任何非常量的全局或静态变量。任何如此做的提交会被取消成绩。教练会人工检查所有的提交以验证是否符合题目要求。由于这个问题无需文件输入输出，所以也不允许在代码中使用任何的文件输入输出**。", "inputFormat": "", "outputFormat": "", "hint": "对于全部数据，$1\\le N\\le 10^6,0\\le c_i\\le 10^9,1\\le K\\le N$，你的程序进行的 `set` 调用和 `get` 调用的总次数被限制为 $25\\times 10^6$ 次。\n\n供题：Dhruv Rohatgi", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18OPEN] Train Tracking P", "background": "Given the special requirements of this problem and the fact that most people do not follow them, the solution channel is closed. If you do have a correct solution, please contact an administrator to add it separately.\n\n1. Your program does not need, and should not include, the header file `grader.h`.\n2. Please add the following function declarations in your program:\n\n```cpp\nint get(int);\nvoid set(int,int);\nvoid shoutMinimum(int);\nint getTrainLength();\nint getWindowLength();\nint getCurrentCarIndex();\nint getCurrentPassIndex();\n```", "description": "Every morning, an express train passes by the farm on its way to the big city, and every afternoon it comes back to the suburbs. Today, Bessie will watch it both in the morning and in the afternoon.\n\nBessie knows in advance that the train has $N$ cars, numbered $0\\sim N-1$ for convenience. Car $i$ has an ID $c_i$. In both the morning and the afternoon, all the numbers are visible, so Bessie has two chances to observe the ID of each car. That is, when the train goes by in the morning, Bessie can observe $c_0$, then $c_1$, up to $c_{N-1}$. When the train returns in the afternoon, she can again observe $c_0$, then $c_1$, up to $c_{N-1}$.\n\nBessie chooses an integer $K$, and she wants to compute the minimum ID in every consecutive block of $K$ cars. She has a notebook to help her do computations, but the notebook is quite small, and Bessie’s handwriting (hoof-writing?) is rather large. For example, there might not be enough space to write down all $N+1-K$ minima. For some mysterious reason, Bessie is satisfied with mooing these numbers to the sky when she computes each minimum, so at least that part is not a problem.\n\nThe train is coming soon! Help Bessie compute these $N+1−K$ minima after the train passes twice, making sure she uses her limited notebook space efficiently. Her notebook is divided into $5500$ sections, numbered $0\\sim 5499$ for convenience, and each section can store exactly one integer in the range $[-2^{31} , 2^{31}-1]$. Initially, each section stores the integer $0$.\n\nPlease help Bessie manage her limited notebook space efficiently.\n\nInteractive protocol\n\nThis is an interactive problem; you do not need to use standard (or file) input/output. Specifically, you need to implement the following function, which is used to help Bessie manage her limited notebook space efficiently:\n\n```cpp\nvoid helpBessie(int ID);\n```\n\nWhenever a train car passes by, whether in the morning or in the afternoon, your function will be called with the ID of that car as input.\n\nYour implementation of `helpBessie` can call the following functions:\n\n- `int get(int index)`: Get the integer value recorded at the given index in Bessie’s notebook (_index_).\n- `void set (int index, int value)`: Set the value at the given index (_index_) to the given integer (_value_).\n- `void shoutMinimum (int output)`: Tell Bessie to moo a specified number to the sky.\n- `int getTrainLength()`: Return the number of cars $N$.\n- `int getWindowLength()`: Return the window length $K$.\n- `int getCurrentCarIndex()`: Return the index of the car currently passing by.\n- `int getCurrentPassIndex()`: Return $0$ if Bessie is watching the morning pass, and $1$ for the afternoon pass.\n\nTo help you get started, we provide an initial C/C++ template. Unfortunately, Python and Pascal are not supported for this problem.\n\n```cpp\n#include \"grader.h\"\n\n// If you find it necessary, you may import standard libraries here.\n\nvoid helpBessie(int ID)\n{\n\t// Put your code here.\n}\n```\n\nCall `void shoutMinimum (int output)` to produce output.\n\nThe minima for the windows must be output in order (so the minimum of cars $0,1,\\cdots ,K−1$ must be output before the minimum of cars $1,2,\\cdots ,K$ and so on), but aside from this ordering constraint, your function may output any number of minima during any call. For example, your function may produce no output during some calls and multiple outputs during others.\n\nBessie has amazing short-term memory, so there is no memory usage limit inside the `helpBessie` function other than the standard 256 MB limit. However, between cars, Bessie cannot “remember” anything that does not appear in the notebook. Therefore, between two calls of the function, your program cannot preserve any state except via calls to `get` and `set`.\n\nThis means:\n\nYou are not allowed to define any non-constant global or static variables. Any submission that does so will receive zero credit. Coaches will manually check all submissions to verify compliance with the problem requirements. Since this problem does not require file input/output, using any file I/O in the code is also not allowed.", "inputFormat": "", "outputFormat": "", "hint": "For all testdata, $1\\le N\\le 10^6,0\\le c_i\\le 10^9,1\\le K\\le N$, and the total number of `set` and `get` calls your program makes is limited to $25\\times 10^6$.\n\nProblem by: Dhruv Rohatgi.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18OPEN] Train Tracking P", "background": "鉴于本题存在特殊要求且大部分人**不遵守**，题解通道关闭。如确有正解，请联系管理员单独添加。\n\n1. 你的程序不需要，也不应该包含 `grader.h` 头文件。\n2. 请在程序中加入如下函数声明语句：\n\n```cpp\nint get(int);\nvoid set(int,int);\nvoid shoutMinimum(int);\nint getTrainLength();\nint getWindowLength();\nint getCurrentCarIndex();\nint getCurrentPassIndex();\n```", "description": "每天早晨特快列车会经过农场，开往大城市，每天下午它又会折回来，回到郊区。今天，Bessie 会花时间观察它，早晨和下午都会。\n\nBessie 提前知道，列车有 $N$ 节车厢，方便起见，将其编号为 $0\\sim N-1$。车厢 $i$ 有一个 ID $c_i$。在早晨和下午，所有的数字都是可见的，所以对于每节车厢 Bessie 有两次机会观察它的 ID。也就是说，当列车早晨经过的时候，Bessie 能够观察 $c_0$，然后是 $c_1$，直到 $c_{N-1}$。当列车下午驶回的时候，她又一次能够观察 $c_0$，然后是 $c_1$，直到 $c_{N-1}$。 \n\nBessie 挑选了一个整数 $K$，她想要求出每个连续的 $K$ 节车厢中最小的 ID。她有一本能够帮助执行计算的笔记本，但是这个笔记本相当小，并且 Bessie 的手写（蹄写？）字相当大。比方说，可能没有足够的空间记下所有 $N+1-K$ 个最小值。由于某些神秘的原因，Bessie 满足于当她算出最小数的时候向天哞出这些数，所以这个问题至少还不成问题。\n\n列车马上就要来了！帮助 Bessie 在列车经过两次之后求出这 $N+1−K$ 个最小数，确保她有效地利用她有限的笔记本空间。她的笔记本被分为 $5500$ 个部分，方便起见编号为 $0\\sim 5499$，每个部分的空间恰好能够记录一个在 $[-2^{31} , 2^{31}-1]$ 之间的整数。最初的时候，每个部分都记录着整数 $0$。\n\n请帮助 Bessie 有效管理她有限的笔记本空间。\n\n### 交互方式\n\n这是一道交互式题目，你不需要使用标准（或文件）输入输出。具体地说，你需要实现下面的函数，这个函数用来帮助 Bessie 有效管理她有限的笔记本空间：\n\n```cpp\nvoid helpBessie(int ID);\n```\n\n每当一节列车车厢经过的时候，无论是在早晨和下午，你的函数都会被调用，函数的输入是这节车厢的 ID。 \n\n你的 `helpBessie` 函数的实现可以调用下面这些函数：\n\n- `int get(int index)`：获取记录在 Bessie 的笔记本上的给定的索引处的整数值（_index_）。\n- `void set (int index, int value)`：设置给定的索引（_index_）处的值为给定的整数值（_value_）。\n- `void shoutMinimum (int output)`：通知 Bessie 向天哞一个指定的数。\n- `int getTrainLength()`：返回列车的车厢数 $N$。\n- `int getWindowLength()`：返回窗口的长度 $K$。\n- `int getCurrentCarIndex()`：返回当前正在通过的车厢编号。\n- `int getCurrentPassIndex()`：如果 Bessie 正在观察早晨的列车返回 $0$，下午的列车返回 $1$。\n\n为了帮助你开始编码，我们为你提供了初始的 C/C++ 模板。遗憾地，这道题目不支持 Python 和 Pascal 语言的程序。\n\n```cpp\n#include \"grader.h\"\n\n// If you find it necessary, you may import standard libraries here.\n\nvoid helpBessie(int ID)\n{\n\t// Put your code here.\n}\n```\n\n调用 `void shoutMinimum (int output)` 函数进行输出。\n\n各个窗口的最小数必须按顺序输出（所以车厢 $0,1,\\cdots ,K−1$ 之中的最小值必须在车厢 $1,2,\\cdots ,K$ 之中的最小值之前输出，等等），但是除了这个顺序的限制之外，你的函数可以在任何一次函数调用中任意多次地输出一些最小值。比如，你的函数可能在某几次调用中不产生任何输出，而在某几次调用中产生多个输出。\n\nBessie 拥有惊人的短时记忆能力，因此在 `helpBessie` 函数中没有任何的内存使用限制，除了要满足常规的 256MB 限制。然而，在车厢与车厢之间，Bessie 不能够「记住」任何不在笔记本中出现过的内容。所以在两次函数调用之间，你的程序除了通过 `get` 和 `set` 函数调用之外不能保存任何的状态。\n\n这意味着：\n\n**不允许定义任何非常量的全局或静态变量。任何如此做的提交会被取消成绩。教练会人工检查所有的提交以验证是否符合题目要求。由于这个问题无需文件输入输出，所以也不允许在代码中使用任何的文件输入输出**。", "inputFormat": "", "outputFormat": "", "hint": "对于全部数据，$1\\le N\\le 10^6,0\\le c_i\\le 10^9,1\\le K\\le N$，你的程序进行的 `set` 调用和 `get` 调用的总次数被限制为 $25\\times 10^6$ 次。\n\n供题：Dhruv Rohatgi", "locale": "zh-CN"}}}
{"pid": "P4374", "type": "P", "difficulty": 5, "samples": [["6 3\n1 2\n1 3\n4 1\n4 5\n6 5\n2 3 7\n3 6 8\n6 4 5", "7\n7\n8\n5\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "线段树", "USACO", "树链剖分"], "title": "[USACO18OPEN] Disruption P", "background": "", "description": "Farmer John 自豪于他所经营的交通发达的农场。这个农场由 $N$ 块牧场（$2 \\leq N \\leq 50,000$）组成，$N-1$ 条双向道路将它们连接起来，每条道路的长度均为 $1$ 单位。Farmer John 注意到，从任何一块牧场到另一块牧场，都能通过一组合适的道路到达。\n\n尽管 FJ 的农场现在是连通的，他担心如果有一条道路被阻断会发生什么，因为这会将农场分为两个不相交的牧场集合，奶牛们只能在每个集合内移动而不能在集合间移动。于是 FJ 又建造了 $M$ 条额外的双向道路（$1 \\leq M \\leq 50,000$），每条道路的长度都是一个至多为 $10^9$ 的正整数。奶牛们仍然可以使用原有的道路进行移动，除非其中的某些被阻断。\n\n如果某条原有的道路被阻断，农场就会被分为两块不相交的区域，那么 FJ 会从他的额外修建的道路中选择一条能够重建这两块区域连通性的道路，取代原来的那条，从而使奶牛们又可以从任何一块牧场去往另一块牧场。\n\n对于农场上每一条原有的道路，帮助 FJ 选出最短的替代道路。", "inputFormat": "输入的第一行包含 $N$ 和 $M$。接下来的 $N-1$ 行，每行用整数 $p$ 和 $q$ 描述了一条原有的道路，其中 $p \\neq q$ 是这条道路连接的两块牧场（在 $1 \\ldots N$ 范围内）。剩下的 $M$ 行，每行用三个整数 $p$、$q$ 和 $r$ 描述了一条额外的道路，其中 $r$ 是这条道路的长度。任何两块牧场之间至多只有一条道路。", "outputFormat": "对原有的 $N-1$ 条道路的每一条，按照它们在输入中出现的顺序，输出如果这条道路被阻断的话，能够重新连接农场的最短替代道路的长度。如果不存在合适的替代道路，输出 $-1$。", "hint": "供题：Brian Dean", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18OPEN] Disruption P", "background": "", "description": "Farmer John is proud of his well-connected farm. The farm consists of $N$ pastures ($2 \\leq N \\leq 50,000$) with $N-1$ bidirectional roads connecting them, each of length $1$ unit. Farmer John notices that from any pasture to any other, one can travel via some sequence of roads.\n\nAlthough FJ's farm is currently connected, he worries about what would happen if a road were blocked, since this would split the farm into two disjoint sets of pastures, and the cows could move only within each set but not between sets. So FJ builds $M$ additional bidirectional roads ($1 \\leq M \\leq 50,000$), each with a positive integer length of at most $10^9$. The cows can still use the original roads to travel unless some of them are blocked.\n\nIf one of the original roads is blocked, the farm is divided into two disjoint regions. FJ will then choose one of his additional roads that can restore connectivity between these two regions to replace the original one, so that the cows can again travel from any pasture to any other pasture.\n\nFor each original road on the farm, help FJ pick the shortest replacement road.", "inputFormat": "The first line contains $N$ and $M$. The next $N-1$ lines each describe an original road with integers $p$ and $q$, where $p \\neq q$ are the two pastures it connects (within $1 \\ldots N$). The remaining $M$ lines each describe an additional road with three integers $p$, $q$, and $r$, where $r$ is the road's length. There is at most one road between any two pastures.", "outputFormat": "For each of the original $N-1$ roads, in the order they appear in the input, output the length of the shortest replacement road that can reconnect the farm if that road is blocked. If no suitable replacement road exists, output $-1$.", "hint": "Author: Brian Dean.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18OPEN] Disruption P", "background": "", "description": "Farmer John 自豪于他所经营的交通发达的农场。这个农场由 $N$ 块牧场（$2 \\leq N \\leq 50,000$）组成，$N-1$ 条双向道路将它们连接起来，每条道路的长度均为 $1$ 单位。Farmer John 注意到，从任何一块牧场到另一块牧场，都能通过一组合适的道路到达。\n\n尽管 FJ 的农场现在是连通的，他担心如果有一条道路被阻断会发生什么，因为这会将农场分为两个不相交的牧场集合，奶牛们只能在每个集合内移动而不能在集合间移动。于是 FJ 又建造了 $M$ 条额外的双向道路（$1 \\leq M \\leq 50,000$），每条道路的长度都是一个至多为 $10^9$ 的正整数。奶牛们仍然可以使用原有的道路进行移动，除非其中的某些被阻断。\n\n如果某条原有的道路被阻断，农场就会被分为两块不相交的区域，那么 FJ 会从他的额外修建的道路中选择一条能够重建这两块区域连通性的道路，取代原来的那条，从而使奶牛们又可以从任何一块牧场去往另一块牧场。\n\n对于农场上每一条原有的道路，帮助 FJ 选出最短的替代道路。", "inputFormat": "输入的第一行包含 $N$ 和 $M$。接下来的 $N-1$ 行，每行用整数 $p$ 和 $q$ 描述了一条原有的道路，其中 $p \\neq q$ 是这条道路连接的两块牧场（在 $1 \\ldots N$ 范围内）。剩下的 $M$ 行，每行用三个整数 $p$、$q$ 和 $r$ 描述了一条额外的道路，其中 $r$ 是这条道路的长度。任何两块牧场之间至多只有一条道路。", "outputFormat": "对原有的 $N-1$ 条道路的每一条，按照它们在输入中出现的顺序，输出如果这条道路被阻断的话，能够重新连接农场的最短替代道路的长度。如果不存在合适的替代道路，输出 $-1$。", "hint": "供题：Brian Dean", "locale": "zh-CN"}}}
{"pid": "P4375", "type": "P", "difficulty": 5, "samples": [["5\n1\n8\n5\n3\n2", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "USACO", "树状数组", "离散化", "排序"], "title": "[USACO18OPEN] Out of Sorts G", "background": "", "description": "留意着农场之外的长期职业生涯的可能性，奶牛 Bessie 开始在不同的在线编程网站上学习算法。\n\n她到目前为止最喜欢的算法是“冒泡排序”。以下是 Bessie 最初的对长度为 $N$ 的数组 $A$ 进行排序的代码实现：\n\n```\nsorted = false\nwhile (not sorted):\n   sorted = true\n   moo\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n         sorted = false\n```\n\n显然，代码中的 `moo` 指令的作用只是输出“moo”。奇怪的是，Bessie 似乎执着于在她的代码中的不同位置使用这个语句。\n\n在用若干个数组测试了她的代码之后，Bessie 观察到一个有趣的现象：大的元素很快就会被拉到数组末尾，而小的元素需要很长时间“冒泡”到数组的开头（她怀疑这就是这个算法得名的原因）。为了实验和缓解这一问题，Bessie 修改了她的代码，使代码在每次循环中向前再向后各扫描一次，从而无论是大的元素还是小的元素在每一次循环中都有机会被拉较长的一段距离。她的代码现在是这样的：\n\n```\nsorted = false\nwhile (not sorted):\n   sorted = true\n   moo\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n   for i = N-2 downto 0:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         sorted = false\n```\n\n给定一个输入数组，请预测 Bessie 修改后的代码会输出多少次“moo”。\n", "inputFormat": "输入的第一行包含 $N$（$1 \\leq N \\leq 100,000$）。接下来的 $N$ 行描述了 $A[0] \\ldots A[N-1]$，每个数都是一个范围在 $0 \\ldots 10^9$ 的整数。输入数据不保证各不相同。", "outputFormat": "输出“moo”被输出的次数。", "hint": "供题：Brian Dean", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18OPEN] Out of Sorts G", "background": "", "description": "Looking toward the possibility of a long-term career beyond the farm, the cow Bessie has started studying algorithms on various online programming websites.\n\nHer favorite algorithm so far is \"bubble sort.\" Below is Bessie's initial code implementation for sorting an array $A$ of length $N$:\n\n```\nsorted = false\nwhile (not sorted):\n   sorted = true\n   moo\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n         sorted = false\n```\n\nClearly, the `moo` instruction in the code simply outputs \"moo.\" Strangely, Bessie seems fixated on using this statement in different places in her code.\n\nAfter testing her code on several arrays, Bessie noticed an interesting phenomenon: large elements are quickly pulled to the end of the array, while small elements take a long time to \"bubble\" up to the front (she suspects this is why the algorithm has this name). To experiment and ease this issue, Bessie modified her code so that in each loop it scans forward and then backward, giving both large and small elements a chance to move a relatively long distance in each loop. Her code is now as follows:\n\n```\nsorted = false\nwhile (not sorted):\n   sorted = true\n   moo\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n   for i = N-2 downto 0:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         sorted = false\n```\n\nGiven an input array, predict how many times Bessie's modified code will output \"moo.\"", "inputFormat": "The first line contains $N$ ($1 \\leq N \\leq 100,000$). The next $N$ lines describe $A[0] \\ldots A[N-1]$, each an integer in the range $0 \\ldots 10^9$. The input numbers are not guaranteed to be distinct.", "outputFormat": "Output the number of times \"moo\" is printed.", "hint": "Problem by Brian Dean.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18OPEN] Out of Sorts G", "background": "", "description": "留意着农场之外的长期职业生涯的可能性，奶牛 Bessie 开始在不同的在线编程网站上学习算法。\n\n她到目前为止最喜欢的算法是“冒泡排序”。以下是 Bessie 最初的对长度为 $N$ 的数组 $A$ 进行排序的代码实现：\n\n```\nsorted = false\nwhile (not sorted):\n   sorted = true\n   moo\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n         sorted = false\n```\n\n显然，代码中的 `moo` 指令的作用只是输出“moo”。奇怪的是，Bessie 似乎执着于在她的代码中的不同位置使用这个语句。\n\n在用若干个数组测试了她的代码之后，Bessie 观察到一个有趣的现象：大的元素很快就会被拉到数组末尾，而小的元素需要很长时间“冒泡”到数组的开头（她怀疑这就是这个算法得名的原因）。为了实验和缓解这一问题，Bessie 修改了她的代码，使代码在每次循环中向前再向后各扫描一次，从而无论是大的元素还是小的元素在每一次循环中都有机会被拉较长的一段距离。她的代码现在是这样的：\n\n```\nsorted = false\nwhile (not sorted):\n   sorted = true\n   moo\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n   for i = N-2 downto 0:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         sorted = false\n```\n\n给定一个输入数组，请预测 Bessie 修改后的代码会输出多少次“moo”。\n", "inputFormat": "输入的第一行包含 $N$（$1 \\leq N \\leq 100,000$）。接下来的 $N$ 行描述了 $A[0] \\ldots A[N-1]$，每个数都是一个范围在 $0 \\ldots 10^9$ 的整数。输入数据不保证各不相同。", "outputFormat": "输出“moo”被输出的次数。", "hint": "供题：Brian Dean", "locale": "zh-CN"}}}
{"pid": "P4376", "type": "P", "difficulty": 5, "samples": [["4 3\n3 1 2 3\n2 4 2\n3 3 4 1", "1 4 2 3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "二分", "USACO", "图论建模", "拓扑排序"], "title": "[USACO18OPEN] Milking Order G", "background": "", "description": "Farmer John 的 $N$ 头奶牛（$1 \\leq N \\leq 10^5$），编号为 $1 \\ldots N$，最近闲得发慌。因此，她们发展了一个与 Farmer John 每天早上为她们挤牛奶时的排队顺序相关的复杂社会阶层。\n\n经过若干周的研究，Farmer John 对他的奶牛的社会结构总计进行了 $M$ 次观察（$1 \\leq M \\leq 50,000$）。每个观察结果都是某些奶牛的一个有序序列，表示这些奶牛应该按照序列中的顺序进行挤奶。例如，如果 Farmer John 的一次观察结果是序列 $2$、$5$、$1$，那么 Farmer John 应该在给奶牛 $5$ 挤奶之前的某个时刻给奶牛 $2$ 挤奶，并在给奶牛 $1$ 挤奶之前的某个时刻给奶牛 $5$ 挤奶。\n\nFarmer John 的观察结果是按优先级排列的，因此他的目标是最大化 $X$ 的值，使得他的挤奶顺序能够符合前 $X$ 个观察结果描述的状态。当多种挤奶顺序都能符合前 $X$ 个状态时，Farmer John 遵循一个长期以来的传统——编号较小的奶牛的地位高于编号较大的奶牛，因此他会最先给编号最小的奶牛挤奶。更正式地说，如果有多个挤奶顺序符合这些状态，Farmer John 会采用字典序最小的那一个。挤奶顺序 $x$ 的字典序比挤奶顺序 $y$ 小，如果对于某个 $j$，$x_i = y_i$ 对所有 $i < j$ 成立，并且 $x_j < y_j$（即这两个挤奶顺序到某个位置之前完全相同，而在该位置上 $x$ 比 $y$ 小）。\n\n请帮助 Farmer John 确定给奶牛挤奶的最佳顺序。", "inputFormat": "第一行包含 $N$ 和 $M$。接下来的 $M$ 行，每行描述了一个观察结果。第 $i+1$ 行描述了观察结果 $i$，第一个数是观察结果中的奶牛数量 $m_i$，后面是一列 $m_i$ 个整数，给出这次观察中奶牛的顺序。所有 $m_i$ 的总和至多为 $200,000$。", "outputFormat": "输出 $N$ 个空格分隔的整数，表示一个 $1 \\ldots N$ 的排列，为 Farmer John 给他的奶牛们挤奶应该采用的顺序。", "hint": "在这个例子中，Farmer John 有四头奶牛，他的挤奶顺序应该满足以下规则：奶牛 $1$ 在奶牛 $2$ 之前、奶牛 $2$ 在奶牛 $3$ 之前（第一个观察结果），奶牛 $4$ 在奶牛 $2$ 之前（第二个观察结果），奶牛 $3$ 在奶牛 $4$ 之前、奶牛 $4$ 在奶牛 $1$ 之前（第三个观察结果）。前两个观察结果可以同时被满足，但 Farmer John 不能同时满足所有规则，因为这会要求奶牛 $1$ 在奶牛 $3$ 之前，同时奶牛 $3$ 在奶牛 $1$ 之前。\n\n这意味着总共有两种可能的挤奶顺序：$1\\ 4\\ 2\\ 3$ 和 $4\\ 1\\ 2\\ 3$，第一种是字典序较小的。\n\n题目来源：Jay Leeds", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18OPEN] Milking Order G", "background": "", "description": "Farmer John has $N$ cows ($1 \\leq N \\leq 10^5$), numbered $1 \\ldots N$, who have recently gotten bored. They have developed a complex social hierarchy related to the order in which Farmer John milks them each morning.\n\nAfter several weeks of study, Farmer John has made $M$ observations ($1 \\leq M \\leq 50{,}000$) about the social structure of his cows. Each observation is an ordered sequence of certain cows, indicating that these cows should be milked in the order shown by the sequence. For example, if one observation is the sequence $2$, $5$, $1$, then Farmer John should milk cow $2$ sometime before cow $5$, and milk cow $5$ sometime before cow $1$.\n\nThe observations are prioritized, and his goal is to maximize the value $X$ such that his milking order can satisfy the first $X$ observations. When multiple milking orders satisfy the first $X$ observations, Farmer John follows a long tradition: cows with smaller IDs outrank those with larger IDs, so he will milk the smallest-numbered cow first. More formally, if multiple milking orders satisfy these observations, Farmer John uses the lexicographically smallest one. A milking order $x$ is lexicographically smaller than a milking order $y$ if, for some $j$, $x_i = y_i$ holds for all $i < j$, and $x_j < y_j$ (that is, the two orders are identical up to some position, and at that position $x$ is smaller than $y$).\n\nPlease help Farmer John determine the best order in which to milk the cows.", "inputFormat": "The first line contains $N$ and $M$. Each of the next $M$ lines describes one observation. Line $i+1$ describes observation $i$: the first number is the number of cows in the observation, $m_i$, followed by a list of $m_i$ integers giving the order of cows in that observation. The sum of all $m_i$ is at most $200{,}000$.", "outputFormat": "Output $N$ space-separated integers, a permutation of $1 \\ldots N$, giving the order in which Farmer John should milk his cows.", "hint": "In this example, Farmer John has four cows, and his milking order should satisfy the following rules: cow $1$ before cow $2$, and cow $2$ before cow $3$ (first observation); cow $4$ before cow $2$ (second observation); cow $3$ before cow $4$, and cow $4$ before cow $1$ (third observation). The first two observations can be satisfied together, but Farmer John cannot satisfy all rules simultaneously, since that would require cow $1$ before cow $3$ while also having cow $3$ before cow $1$.\n\nThis means there are two possible milking orders: $1\\ 4\\ 2\\ 3$ and $4\\ 1\\ 2\\ 3$, and the first is lexicographically smaller.\n\nProblem source: Jay Leeds.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18OPEN] Milking Order G", "background": "", "description": "Farmer John 的 $N$ 头奶牛（$1 \\leq N \\leq 10^5$），编号为 $1 \\ldots N$，最近闲得发慌。因此，她们发展了一个与 Farmer John 每天早上为她们挤牛奶时的排队顺序相关的复杂社会阶层。\n\n经过若干周的研究，Farmer John 对他的奶牛的社会结构总计进行了 $M$ 次观察（$1 \\leq M \\leq 50,000$）。每个观察结果都是某些奶牛的一个有序序列，表示这些奶牛应该按照序列中的顺序进行挤奶。例如，如果 Farmer John 的一次观察结果是序列 $2$、$5$、$1$，那么 Farmer John 应该在给奶牛 $5$ 挤奶之前的某个时刻给奶牛 $2$ 挤奶，并在给奶牛 $1$ 挤奶之前的某个时刻给奶牛 $5$ 挤奶。\n\nFarmer John 的观察结果是按优先级排列的，因此他的目标是最大化 $X$ 的值，使得他的挤奶顺序能够符合前 $X$ 个观察结果描述的状态。当多种挤奶顺序都能符合前 $X$ 个状态时，Farmer John 遵循一个长期以来的传统——编号较小的奶牛的地位高于编号较大的奶牛，因此他会最先给编号最小的奶牛挤奶。更正式地说，如果有多个挤奶顺序符合这些状态，Farmer John 会采用字典序最小的那一个。挤奶顺序 $x$ 的字典序比挤奶顺序 $y$ 小，如果对于某个 $j$，$x_i = y_i$ 对所有 $i < j$ 成立，并且 $x_j < y_j$（即这两个挤奶顺序到某个位置之前完全相同，而在该位置上 $x$ 比 $y$ 小）。\n\n请帮助 Farmer John 确定给奶牛挤奶的最佳顺序。", "inputFormat": "第一行包含 $N$ 和 $M$。接下来的 $M$ 行，每行描述了一个观察结果。第 $i+1$ 行描述了观察结果 $i$，第一个数是观察结果中的奶牛数量 $m_i$，后面是一列 $m_i$ 个整数，给出这次观察中奶牛的顺序。所有 $m_i$ 的总和至多为 $200,000$。", "outputFormat": "输出 $N$ 个空格分隔的整数，表示一个 $1 \\ldots N$ 的排列，为 Farmer John 给他的奶牛们挤奶应该采用的顺序。", "hint": "在这个例子中，Farmer John 有四头奶牛，他的挤奶顺序应该满足以下规则：奶牛 $1$ 在奶牛 $2$ 之前、奶牛 $2$ 在奶牛 $3$ 之前（第一个观察结果），奶牛 $4$ 在奶牛 $2$ 之前（第二个观察结果），奶牛 $3$ 在奶牛 $4$ 之前、奶牛 $4$ 在奶牛 $1$ 之前（第三个观察结果）。前两个观察结果可以同时被满足，但 Farmer John 不能同时满足所有规则，因为这会要求奶牛 $1$ 在奶牛 $3$ 之前，同时奶牛 $3$ 在奶牛 $1$ 之前。\n\n这意味着总共有两种可能的挤奶顺序：$1\\ 4\\ 2\\ 3$ 和 $4\\ 1\\ 2\\ 3$，第一种是字典序较小的。\n\n题目来源：Jay Leeds", "locale": "zh-CN"}}}
{"pid": "P4377", "type": "P", "difficulty": 5, "samples": [["3 15\n20 21\n10 11\n30 31", "1066\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2018", "二分", "USACO", "背包 DP", "分数规划"], "title": "[USACO18OPEN] Talent Show G", "background": "", "description": "Farmer John 要带着他的 $n$ 头奶牛，方便起见编号为 $1\\ldots n$，到农业展览会上去，参加每年的达牛秀！他的第 $i$ 头奶牛重量为 $w_i$，才艺水平为 $t_i$，两者都是整数。\n\n在到达时，Farmer John 就被今年达牛秀的新规则吓到了：\n\n（一）参加比赛的一组奶牛必须总重量至少为 $W$（这是为了确保是强大的队伍在比赛，而不仅是强大的某头奶牛），并且。\n\n（二）总才艺值与总重量的比值最大的一组获得胜利。\n\nFJ 注意到他的所有奶牛的总重量不小于 $W$，所以他能够派出符合规则（一）的队伍。帮助他确定这样的队伍中能够达到的最佳的才艺与重量的比值。", "inputFormat": "第一行是两个整数，分别表示牛的个数 $n$ 和总重量限制 $W$。\n\n第 $2$ 到 $(n+1)$ 行，每行两个整数，第 $(i + 1)$ 行的整数表示第 $i$ 头奶牛的重量 $w_i$ 和才艺水平 $t_i$。", "outputFormat": "请求出 Farmer 用一组总重量最少为 $W$ 的奶牛最大可能达到的总才艺值与总重量的比值。\n\n如果你的答案是 $A$，输出 $1000A$ 向下取整的值，以使得输出是整数（当问题中的数不是一个整数的时候，向下取整操作在向下舍入到整数的时候去除所有小数部分）。\n\n请注意当问题的答案恰好是整数 $x$ 时，你的程序可能会由于**浮点数精度误差**问题最后得到一个 $x-\\epsilon$ 的答案，向下取整后变为 $x-1$ 导致答案错误。这种情况下你可以在输出答案前给答案加上一个极小的值 $x\\gets x+10^{-k}$ 来避免该问题。", "hint": "#### 样例解释\n\n在这个例子中，总体来看最佳的才艺与重量的比值应该是仅用一头才艺值为 $11$、重量为 $10$ 的奶牛，但是由于我们需要至少 $15$ 单位的重量，最优解最终为使用这头奶牛加上才艺值为 $21$、重量为 $20$ 的奶牛。这样的话才艺与重量的比值为 $\\frac{11+21}{10+20}=\\frac{32}{30} = 1.0666\\dots$，乘以 $1000$ 向下取整之后得到 $1066$。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 250$，$1 \\leq W \\leq 1000$，$1 \\leq w_i \\leq 10^6$，$1 \\leq t_i \\leq 10^3$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18OPEN] Talent Show G", "background": "", "description": "Farmer John is taking his $n$ cows, conveniently numbered $1 \\ldots n$, to the agricultural fair to participate in the annual Talent Show. His $i$-th cow has weight $w_i$ and talent $t_i$, both integers.\n\nUpon arrival, Farmer John is alarmed by the new rules for this year's show:\n\n(1) A participating group of cows must have total weight at least $W$ (this is to ensure strong teams compete, not just a single strong cow), and\n\n(2) The group with the maximum ratio of total talent to total weight wins.\n\nFJ notices that the total weight of all his cows is at least $W$, so he can send a team that satisfies rule (1). Help him determine the best achievable ratio of total talent to total weight among such teams.", "inputFormat": "The first line contains two integers, the number of cows $n$ and the weight threshold $W$.\n\nLines $2$ through $(n+1)$ each contain two integers. The integers on line $(i+1)$ give the weight $w_i$ and talent $t_i$ of the $i$-th cow.", "outputFormat": "Compute the maximum possible ratio of total talent to total weight for a group of cows whose total weight is at least $W$.\n\nIf your answer is $A$, output the value of $1000A$ rounded down to an integer (i.e., take the floor; when a number is not an integer, flooring removes all fractional digits).\n\nNote that if the exact answer is an integer $x$, your program may produce $x - \\epsilon$ due to floating-point precision and, after flooring, incorrectly output $x - 1$. In this case, you can add a tiny value before flooring, e.g., $x \\gets x + 10^{-k}$, to avoid this issue.", "hint": "#### Sample Explanation\n\nIn this example, the globally best ratio of talent to weight would be achieved by using only the cow with talent $11$ and weight $10$. However, since we need at least $15$ units of weight, the optimal solution is to use that cow together with the cow of talent $21$ and weight $20$. The resulting ratio is $\\frac{11+21}{10+20}=\\frac{32}{30} = 1.0666\\dots$, which becomes $1066$ after multiplying by $1000$ and taking the floor.\n\n#### Constraints\n\nFor all testdata, it is guaranteed that $1 \\leq n \\leq 250$, $1 \\leq W \\leq 1000$, $1 \\leq w_i \\leq 10^6$, and $1 \\leq t_i \\leq 10^3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18OPEN] Talent Show G", "background": "", "description": "Farmer John 要带着他的 $n$ 头奶牛，方便起见编号为 $1\\ldots n$，到农业展览会上去，参加每年的达牛秀！他的第 $i$ 头奶牛重量为 $w_i$，才艺水平为 $t_i$，两者都是整数。\n\n在到达时，Farmer John 就被今年达牛秀的新规则吓到了：\n\n（一）参加比赛的一组奶牛必须总重量至少为 $W$（这是为了确保是强大的队伍在比赛，而不仅是强大的某头奶牛），并且。\n\n（二）总才艺值与总重量的比值最大的一组获得胜利。\n\nFJ 注意到他的所有奶牛的总重量不小于 $W$，所以他能够派出符合规则（一）的队伍。帮助他确定这样的队伍中能够达到的最佳的才艺与重量的比值。", "inputFormat": "第一行是两个整数，分别表示牛的个数 $n$ 和总重量限制 $W$。\n\n第 $2$ 到 $(n+1)$ 行，每行两个整数，第 $(i + 1)$ 行的整数表示第 $i$ 头奶牛的重量 $w_i$ 和才艺水平 $t_i$。", "outputFormat": "请求出 Farmer 用一组总重量最少为 $W$ 的奶牛最大可能达到的总才艺值与总重量的比值。\n\n如果你的答案是 $A$，输出 $1000A$ 向下取整的值，以使得输出是整数（当问题中的数不是一个整数的时候，向下取整操作在向下舍入到整数的时候去除所有小数部分）。\n\n请注意当问题的答案恰好是整数 $x$ 时，你的程序可能会由于**浮点数精度误差**问题最后得到一个 $x-\\epsilon$ 的答案，向下取整后变为 $x-1$ 导致答案错误。这种情况下你可以在输出答案前给答案加上一个极小的值 $x\\gets x+10^{-k}$ 来避免该问题。", "hint": "#### 样例解释\n\n在这个例子中，总体来看最佳的才艺与重量的比值应该是仅用一头才艺值为 $11$、重量为 $10$ 的奶牛，但是由于我们需要至少 $15$ 单位的重量，最优解最终为使用这头奶牛加上才艺值为 $21$、重量为 $20$ 的奶牛。这样的话才艺与重量的比值为 $\\frac{11+21}{10+20}=\\frac{32}{30} = 1.0666\\dots$，乘以 $1000$ 向下取整之后得到 $1066$。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 250$，$1 \\leq W \\leq 1000$，$1 \\leq w_i \\leq 10^6$，$1 \\leq t_i \\leq 10^3$。", "locale": "zh-CN"}}}
{"pid": "P4378", "type": "P", "difficulty": 3, "samples": [["5\n1\n5\n3\n8\n2", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "USACO", "树状数组", "排序"], "title": "[USACO18OPEN] Out of Sorts S", "background": "", "description": "留意着农场之外的长期职业生涯的可能性，奶牛 Bessie 开始在不同的在线编程网站上学习算法。\n\n她到目前为止最喜欢的算法是“冒泡排序”。这是 Bessie 的对长度为 $N$ 的数组 $A$ 进行排序的奶牛码实现。\n\n```\nsorted = false\nwhile (not sorted):\n   sorted = true\n   moo\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n         sorted = false\n```\n显然，奶牛码中的“moo”指令的作用只是输出“moo”。奇怪的是，Bessie 看上去执着于在她的代码中的不同位置使用这个语句。\n\n给定一个输入数组，请预测 Bessie 的代码会输出多少次“moo”。", "inputFormat": "输入的第一行包含 $N$（$1 \\leq N \\leq 100,000$）。接下来 $N$ 行描述了 $A[0] \\ldots A[N-1]$，每个数都是一个范围为 $0 \\ldots 10^9$ 的整数。输入数据不保证各不相同。", "outputFormat": "输出“moo”被输出的次数。", "hint": "供题：Brian Dean", "locale": "zh-CN", "translations": {"en": {"title": "[USACO18OPEN] Out of Sorts S", "background": "", "description": "With an eye on the possibility of a long-term career off the farm, the cow Bessie has started learning algorithms on various online programming sites.\n\nHer favorite algorithm so far is bubble sort. This is Bessie's cow-code implementation for sorting an array $A$ of length $N$.\n\n```\nsorted = false\nwhile (not sorted):\n   sorted = true\n   moo\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n         sorted = false\n```\n\nObviously, the 'moo' instruction in the cow-code simply prints 'moo'. Strangely, Bessie seems fixated on using this statement at different places in her code.\n\nGiven an input array, predict how many times Bessie's code will print 'moo'.", "inputFormat": "The first line contains $N$ ($1 \\leq N \\leq 100{,}000$). The next $N$ lines describe $A[0] \\ldots A[N-1]$, each an integer in the range $0 \\ldots 10^9$. The values are not guaranteed to be distinct.", "outputFormat": "Output the number of times 'moo' is printed.", "hint": "Setter: Brian Dean.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO18OPEN] Out of Sorts S", "background": "", "description": "留意着农场之外的长期职业生涯的可能性，奶牛 Bessie 开始在不同的在线编程网站上学习算法。\n\n她到目前为止最喜欢的算法是“冒泡排序”。这是 Bessie 的对长度为 $N$ 的数组 $A$ 进行排序的奶牛码实现。\n\n```\nsorted = false\nwhile (not sorted):\n   sorted = true\n   moo\n   for i = 0 to N-2:\n      if A[i+1] < A[i]:\n         swap A[i], A[i+1]\n         sorted = false\n```\n显然，奶牛码中的“moo”指令的作用只是输出“moo”。奇怪的是，Bessie 看上去执着于在她的代码中的不同位置使用这个语句。\n\n给定一个输入数组，请预测 Bessie 的代码会输出多少次“moo”。", "inputFormat": "输入的第一行包含 $N$（$1 \\leq N \\leq 100,000$）。接下来 $N$ 行描述了 $A[0] \\ldots A[N-1]$，每个数都是一个范围为 $0 \\ldots 10^9$ 的整数。输入数据不保证各不相同。", "outputFormat": "输出“moo”被输出的次数。", "hint": "供题：Brian Dean", "locale": "zh-CN"}}}
