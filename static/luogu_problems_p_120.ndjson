{"pid": "P3431", "type": "P", "difficulty": 5, "samples": [["8 7 11\n4 3 4\n6 2 4\n2 3 2\n5 6 1\n2 5 2\n1 5 5\n2 1 1\n3 1 1\n7 7 1\n7 4 2\n8 6 2", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2005", "树状数组", "POI（波兰）", "离散化", "扫描线"], "title": "[POI 2005] AUT-The Bus", "background": "", "description": "The streets of Byte City form a regular, chessboardlike network - they are either north-south or west-east directed. We shall call them NS- and WE-streets. Furthermore, each street crosses the whole city. Every NS-street intersects every WE- one and vice versa. The NS-streets are numbered from $1$ to $n$, starting from the westernmost. The WE-streets are numbered from $1$ to $m$, beginning with the southernmost. Each intersection of the $i$'th NS-street with the $j$'th WE-street is denoted by a pair of numbers $(i,j)$ (for $1\\le i\\le n$, $1\\le j\\le m$).\n\nThere is a bus line in Byte City, with intersections serving as bus stops. The bus begins its itinerary by the $(1,1)$ intersection, and finishes by the $(n,m)$ intersection. Moreover, the bus may only travel in the eastern and/or northern direction.\n\nThere are passengers awaiting the bus by some of the intersections. The bus driver wants to choose his route in a way that allows him to take as many of them as possible. (We shall make an assumption that the interior of the bus is spacious enough to take all of the awaiting passengers, regardless of the route chosen.)TaskWrite a programme which:\n\nreads from the standard input a description of the road network and the number of passengers waiting at each intersection,finds, how many passengers the bus can take at the most,writes the outcome to the standard output.\n", "inputFormat": "The first line of the standard input contains three positive integers $n$, $m$ and $k$ - denoting the number of NS-streets, the number of WE-streets and the number of intersections by which the passengers await the bus, respectively ($1\\le n\\le 10^9$, $1\\le m\\le 10^9$, $1\\le k\\le 10^5$).\n\nThe following $k$ lines describe the deployment of passengers awaiting the bus, a single line per intersection. In the $(i+1)$'st line there are three positive integers $x_i$, $y_i$ and $p_i$, separated by single spaces, $1\\le x_i\\le n$,$1\\le y_i\\le m$,$1\\le p_i\\le 10^6$ . A triplet of this form signifies that by the intersection$(x_i,y_i)p_i$ passengers await the bus. Each intersection is described in the input data once at the most. The total number of passengers waiting for the bus does not exceed $1\\ 000\\ 000\\ 000$.\n", "outputFormat": "Your programme should write to the standard output one line containing a single integer - the greatest number of passengers the bus can take.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2005] AUT-The Bus", "background": "", "description": "The streets of Byte City form a regular, chessboardlike network - they are either north-south or west-east directed. We shall call them NS- and WE-streets. Furthermore, each street crosses the whole city. Every NS-street intersects every WE- one and vice versa. The NS-streets are numbered from $1$ to $n$, starting from the westernmost. The WE-streets are numbered from $1$ to $m$, beginning with the southernmost. Each intersection of the $i$'th NS-street with the $j$'th WE-street is denoted by a pair of numbers $(i,j)$ (for $1\\le i\\le n$, $1\\le j\\le m$).\n\nThere is a bus line in Byte City, with intersections serving as bus stops. The bus begins its itinerary by the $(1,1)$ intersection, and finishes by the $(n,m)$ intersection. Moreover, the bus may only travel in the eastern and/or northern direction.\n\nThere are passengers awaiting the bus by some of the intersections. The bus driver wants to choose his route in a way that allows him to take as many of them as possible. (We shall make an assumption that the interior of the bus is spacious enough to take all of the awaiting passengers, regardless of the route chosen.)TaskWrite a programme which:\n\nreads from the standard input a description of the road network and the number of passengers waiting at each intersection,finds, how many passengers the bus can take at the most,writes the outcome to the standard output.\n", "inputFormat": "The first line of the standard input contains three positive integers $n$, $m$ and $k$ - denoting the number of NS-streets, the number of WE-streets and the number of intersections by which the passengers await the bus, respectively ($1\\le n\\le 10^9$, $1\\le m\\le 10^9$, $1\\le k\\le 10^5$).\n\nThe following $k$ lines describe the deployment of passengers awaiting the bus, a single line per intersection. In the $(i+1)$'st line there are three positive integers $x_i$, $y_i$ and $p_i$, separated by single spaces, $1\\le x_i\\le n$,$1\\le y_i\\le m$,$1\\le p_i\\le 10^6$ . A triplet of this form signifies that by the intersection$(x_i,y_i)p_i$ passengers await the bus. Each intersection is described in the input data once at the most. The total number of passengers waiting for the bus does not exceed $1\\ 000\\ 000\\ 000$.\n", "outputFormat": "Your programme should write to the standard output one line containing a single integer - the greatest number of passengers the bus can take.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2005] AUT-The Bus", "background": "", "description": "字节市的街道形成了一个规则的棋盘状网络——它们要么是南北方向，要么是东西方向。我们称它们为 NS 街道和 WE 街道。此外，每条街道都贯穿整个城市。每条 NS 街道与每条 WE 街道相交，反之亦然。NS 街道从最西边开始编号，从 $1$ 到 $n$。WE 街道从最南边开始编号，从 $1$ 到 $m$。每条第 $i$ 条 NS 街道与第 $j$ 条 WE 街道的交点用一对数字 $(i,j)$ 表示（$1\\le i\\le n$，$1\\le j\\le m$）。  字节市有一条公交线路，交叉点作为公交车站。公交车从 $(1,1)$ 交点开始行程，并在 $(n,m)$ 交点结束。此外，公交车只能向东和/或向北行驶。  在一些交叉点有乘客在等车。公交车司机希望选择一条路线，使他能够尽可能多地接到这些乘客。（我们假设公交车内部空间足够大，可以接收所有等待的乘客，无论选择哪条路线。）任务编写一个程序：  从标准输入读取道路网络的描述和每个交叉点等待的乘客人数，找到公交车最多能接到多少乘客，将结果写入标准输出。 ", "inputFormat": "标准输入的第一行包含三个正整数 $n$，$m$ 和 $k$——分别表示 NS 街道的数量、WE 街道的数量以及乘客等待公交车的交叉点数量（$1\\le n\\le 10^9$，$1\\le m\\le 10^9$，$1\\le k\\le 10^5$）。  接下来的 $k$ 行描述了乘客等待公交车的分布，每个交叉点一行。在第 $(i+1)$ 行有三个正整数 $x_i$，$y_i$ 和 $p_i$，用单个空格分隔，$1\\le x_i\\le n$，$1\\le y_i\\le m$，$1\\le p_i\\le 10^6$。这种形式的三元组表示在交叉点 $(x_i,y_i)$ 有 $p_i$ 名乘客在等待公交车。输入数据中每个交叉点最多描述一次。等待公交车的乘客总数不超过 $1\\ 000\\ 000\\ 000$。 ", "outputFormat": "你的程序应在标准输出中写出一行，包含一个整数——公交车可以接到的最多乘客数。 ", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3432", "type": "P", "difficulty": 6, "samples": [["2\n5 6 7\n5 6 6", "4 5 6\n4 6 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "POI（波兰）"], "title": "[POI 2005] LUS-Mirror Trap", "background": null, "description": "镜子陷阱是由镜子构成的长方体，镜子的反射面对着长方体的内部。在长方体的几何中心放入一个微型激光器（尺寸忽略）。现在我们的任务是把激光向某一个方向发射，并且使光束在回到激光器自身之前，通过的总距离尽可能长。通过的总距离表示为激光束在与镜子反射面平行的三个方向的距离之和，也就是曼哈顿（城市）度量。\n\n不同的侧面相遇的陷阱的边和顶点不会反射激光束，且陷阱的边长是整数。在长方形陷阱中，使用笛卡尔坐标系。坐标系的纵横轴分别平行于陷阱的长和宽，激光器的位置在原点。激光器可以瞄准陷阱内的任意一个点包括反射镜的表面上的点（唯一的例外就是激光器本身，点 $(0,0,0)$）。\n\n我们的任务：\n\n输入这个镜子陷阱的尺寸，通过编写的程序计算出一个点，即激光器指向这一点：这一束激光应在反射镜（但不一定是所有反射镜）反射，但是不与陷阱的边、顶点相交，最后需要回到激光器本身（不需要一定的方向）同时尽可能使得总距离长。", "inputFormat": "输入有多个陷阱。输入的第一行包含一个整数 $K(1 \\le K\\le 1000)$，表示要分析的陷阱数。 在 $2,3,\\dots,K + 1$ 行中，有一个陷阱的描述，每行一个。 陷阱的描述由三个用空格分隔的数字 $x,y,z(5 \\le x,y,z \\le 1000)$ 组成。镜面陷阱的尺寸为 $2x \\times 2y \\times 2z$。", "outputFormat": "输出 $K$ 行。第 $K$ 行应包含第 $K$ 个陷阱的解决方案，由空格分隔的 $3$ 个数 $x,y,z$，表示激光器需要瞄准的点的坐标。\n\n如果有多个不同的正确解决方案，则任意的输出一个。", "hint": "感谢@SLYZ\\_0120 提供翻译。", "locale": "zh-CN", "translations": {"en": {"title": "", "background": "", "description": "A mirror trap is a cuboid made of mirrors, the reflecting sides of which are facing the interior of the cuboid. Precisely in the geometric centre of the cuboid there is a miniature laser (whose dimensions we shall neglect). The task is to aim the laser in such a way that the beam travels the longest total distance possible and returns to the laser itself. By total distance we shall denote the sum of distances traveled by the laser beam in each of the three directions parallel to the edges of the mirrors (i.e. we are using the so called Manhattan (city) metric).\n\nThe dimensions of the trap are even integers. The edges and vertices of the trap, where distinct sides meet, do not reflect the laser beam. Inside the cuboid we shall introduce a cartesian coordinate system. Its axes are parallel to the edges of the trap and the laser shall be placed in the origin. The laser may be aimed at any integer point (a point whose all coordinates are integers) within the trap, the points on the surface of the mirrors included (with the single exception of the laser itself, i.e. the point $(0,0,0)$).\n\nTask\n\nWrite a programme which:\n\nreads from the standard input the dimensions of the mirror trap,calculates such a point, that a laser beam fired from the laser it the direction of this point:\n\nshall be reflected from the mirrors (but not necessarily from all of them),  shall neither intersect an edge nor a vertex of the mirror trap,  shall return to the laser, possibly from a different direction,  shall travel the longest total distance possible (in the sense of the definition provided).\n\nwrites the outcome to the standard output.", "inputFormat": "A single test consists of many mirror traps to be analysed. The first line of the standard input contains a single integer $1\\le K\\le 1000$, denoting the number of traps to be analysed. In the lines $2..K+1$ there are descriptions of the traps, a single per line. The description of the trap consists of three numbers $5\\le x,y,z\\le 1000$, separated by single spaces. The mirror trap has the dimensions of $2x\\times 2y\\times 2z$.", "outputFormat": "Your programme should write exactly $K$ lines to the standard output. The $i$'th line should contain a solution for the $i$'th trap: three integers $k_x,k_y,k_z$separated by single spaces, $-x\\le k_{x}\\le x$, $-y\\le k_{y}\\le y$, $-z\\le k_{z}\\le z$,$ \\{k_{x},k_{y},k_{z}\\}\\neq\\{0,0,0\\}$. Those numbers signify that in the $i$'th trap the laser should be aimed at the point, whose coordinates are $\\{k_{x},k_{y},k_{z}\\}$.\n\nShould there be a greater number of correct solutions, your programme ought to output any one of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2005] LUS-Mirror Trap", "background": null, "description": "镜子陷阱是由镜子构成的长方体，镜子的反射面对着长方体的内部。在长方体的几何中心放入一个微型激光器（尺寸忽略）。现在我们的任务是把激光向某一个方向发射，并且使光束在回到激光器自身之前，通过的总距离尽可能长。通过的总距离表示为激光束在与镜子反射面平行的三个方向的距离之和，也就是曼哈顿（城市）度量。\n\n不同的侧面相遇的陷阱的边和顶点不会反射激光束，且陷阱的边长是整数。在长方形陷阱中，使用笛卡尔坐标系。坐标系的纵横轴分别平行于陷阱的长和宽，激光器的位置在原点。激光器可以瞄准陷阱内的任意一个点包括反射镜的表面上的点（唯一的例外就是激光器本身，点 $(0,0,0)$）。\n\n我们的任务：\n\n输入这个镜子陷阱的尺寸，通过编写的程序计算出一个点，即激光器指向这一点：这一束激光应在反射镜（但不一定是所有反射镜）反射，但是不与陷阱的边、顶点相交，最后需要回到激光器本身（不需要一定的方向）同时尽可能使得总距离长。", "inputFormat": "输入有多个陷阱。输入的第一行包含一个整数 $K(1 \\le K\\le 1000)$，表示要分析的陷阱数。 在 $2,3,\\dots,K + 1$ 行中，有一个陷阱的描述，每行一个。 陷阱的描述由三个用空格分隔的数字 $x,y,z(5 \\le x,y,z \\le 1000)$ 组成。镜面陷阱的尺寸为 $2x \\times 2y \\times 2z$。", "outputFormat": "输出 $K$ 行。第 $K$ 行应包含第 $K$ 个陷阱的解决方案，由空格分隔的 $3$ 个数 $x,y,z$，表示激光器需要瞄准的点的坐标。\n\n如果有多个不同的正确解决方案，则任意的输出一个。", "hint": "感谢@SLYZ\\_0120 提供翻译。", "locale": "zh-CN"}}}
{"pid": "P3433", "type": "P", "difficulty": 7, "samples": [["6\n1 1\n-1 4\n0 -1\n4 1\n0 3\n1 4", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "POI（波兰）"], "title": "[POI 2005] PRA-Dextrogyrate Camel", "background": "", "description": "\nByteotia 由 $N$ 个绿洲组成，且任意三点不共线。Byteasar 住在其中一个绿洲里，并且在其他每个绿洲都有一位熟人。Byteasar 想尽可能多地去拜访他们。他打算骑着他的骆驼出行。这只骆驼像骡子一样倔强，因此以一种特别的方式移动：\n\n- 从某个绿洲出发后，它沿一条直线前进，直到到达另一个绿洲。\n- 骆驼只在绿洲处转向，而且只向右（顺时针）转，转角属于区间 $[0\\degree, 180\\degree]$（在同一个绿洲它只会转一次，也就是说不会通过连续两次各 $100\\degree$ 的转向来达成总计 $200\\degree$ 的转弯）。\n- 骆驼不愿踩着自己留下的足迹返回。\n\n请帮助 Byteasar 规划一条路线，使他能在遵守上述规则的前提下拜访尽量多的朋友。路线必须从 Byteasar 所在的绿洲出发，并最终回到该绿洲。路线应由依次连接所访绿洲的线段组成。除了 Byteasar 的起始绿洲（旅程的起点与终点）外，路线不得经过任意一点两次。\n\n起初，Byteasar 的骆驼面朝某个绿洲，且必须首先朝该方向出发。旅程结束时骆驼面向的方向无关紧要。\n\n### 任务\n\n编写一个程序，完成以下要求：\n\n1. 从标准输入读入骆驼面朝的方向与各个绿洲的坐标；\n2. 计算在遵守规则的情况下，Byteasar 最多可以拜访的朋友数量；\n3. 将结果写到标准输出。\n", "inputFormat": "\n\n标准输入的第一行包含一个整数 $N$（$3 \\le N \\le 1\\ 000$）—— Byteotia 中的绿洲数量。所有绿洲按 $1$ 到 $N$ 编号。Byteasar 居住在编号为 $1$ 的绿洲上，且他的骆驼面朝编号为 $2$ 的绿洲。接下来的 $N$ 行给出各个绿洲的坐标。在第 $(i+1)$ 行，给出两个整数 $x_i, y_i$，分别表示编号为 $i$ 的绿洲的横坐标与纵坐标，二者以一个空格分隔。所有坐标均在区间 $[-16\\ 000, 16\\ 000]$ 内。\n", "outputFormat": "\n标准输出仅一行，输出一个整数—— Byteasar 最多可以拜访的朋友数量。\n", "hint": "\n样例解释：\n\n![](https://cdn.luogu.com.cn/upload/pic/8961.png)\n\n翻译来自 ChatGPT 5。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2005] PRA-Dextrogyrate Camel", "background": "", "description": "\nByteotia consists of $N$ oasis in the desert, no three of which are collinear. Byteasar lives in one of these oasis and moreover he has an acquaintance in every other. Byteasar wants to pay a visit to as many of them as possible. He plans to travel on the back of his camel. The camel is as obstinate as a mule and thus moves in its own peculiar way:\n\nAfter departure from an oasis it moves along a straight line, until it gets to another oasis.\n\nThe camel turns only at oasis, but it turns only right (clockwise) and by an angle from the interval $[0\\degree,180\\degree]$ (the camel makes only one turn at an oasis, i.e. it will not turn by f.i. $200\\degree$ as a result of two subsequent turns by $100\\degree$).\n\nThe camel doesn't want to follow its own footprints.\n\nHelp Byteasar in planning such a route that he will be able to visit as many friends as possible. It should both begin and end in the oasis where Byteasar lives. It has to consist of segments connecting subsequently visited oasis. The route may not pass through any point two times, except the Byteasar's oasis, where the camel turns up twice: at the beginning and the end of the journey.\n\nByteasar's camel is initially facing a certain oasis and it has to start moving toward it. The direction the camel faces after returning from the journey is of no importance.\n\nTaskWrite a programme that:\n\nreads from the standard input the camel's coordinates and the direction it faces as well as the coordinates of the Byteotian oasis,determines the maximum number of friends Byteasar can pay a visit to while sticking to the presented rules,writes the result to the standard output.", "inputFormat": "\nIn the first line of the standard input there is one integer $N$ ($3\\le N\\le 1\\ 000$) - the number of oasis in Byteotia. The oasis are numbered from $1$ to $N$. Byteasar lives in the oasis no. $1$ and his camel is facing the oasis no. $2$. In the following $N$ lines the coordinates of the oasis are given. In the $(i+1)$'th line there are two integers $x_i$, $y_i$ - the horizontal and vertical coordinate of the $i$'th oasis - separated by a single space. All coordinates are from the interval from $-16\\ 000$ to $16\\ 000$.", "outputFormat": "\nIn the first and only line of the standard output your programme should write one integer - the maximum number of friends Byteasar can visit.\n", "hint": "Explanation of the example:\n\n ![](https://cdn.luogu.com.cn/upload/pic/8961.png) ", "locale": "en"}, "zh-CN": {"title": "[POI 2005] PRA-Dextrogyrate Camel", "background": "", "description": "\nByteotia 由 $N$ 个绿洲组成，且任意三点不共线。Byteasar 住在其中一个绿洲里，并且在其他每个绿洲都有一位熟人。Byteasar 想尽可能多地去拜访他们。他打算骑着他的骆驼出行。这只骆驼像骡子一样倔强，因此以一种特别的方式移动：\n\n- 从某个绿洲出发后，它沿一条直线前进，直到到达另一个绿洲。\n- 骆驼只在绿洲处转向，而且只向右（顺时针）转，转角属于区间 $[0\\degree, 180\\degree]$（在同一个绿洲它只会转一次，也就是说不会通过连续两次各 $100\\degree$ 的转向来达成总计 $200\\degree$ 的转弯）。\n- 骆驼不愿踩着自己留下的足迹返回。\n\n请帮助 Byteasar 规划一条路线，使他能在遵守上述规则的前提下拜访尽量多的朋友。路线必须从 Byteasar 所在的绿洲出发，并最终回到该绿洲。路线应由依次连接所访绿洲的线段组成。除了 Byteasar 的起始绿洲（旅程的起点与终点）外，路线不得经过任意一点两次。\n\n起初，Byteasar 的骆驼面朝某个绿洲，且必须首先朝该方向出发。旅程结束时骆驼面向的方向无关紧要。\n\n### 任务\n\n编写一个程序，完成以下要求：\n\n1. 从标准输入读入骆驼面朝的方向与各个绿洲的坐标；\n2. 计算在遵守规则的情况下，Byteasar 最多可以拜访的朋友数量；\n3. 将结果写到标准输出。\n", "inputFormat": "\n\n标准输入的第一行包含一个整数 $N$（$3 \\le N \\le 1\\ 000$）—— Byteotia 中的绿洲数量。所有绿洲按 $1$ 到 $N$ 编号。Byteasar 居住在编号为 $1$ 的绿洲上，且他的骆驼面朝编号为 $2$ 的绿洲。接下来的 $N$ 行给出各个绿洲的坐标。在第 $(i+1)$ 行，给出两个整数 $x_i, y_i$，分别表示编号为 $i$ 的绿洲的横坐标与纵坐标，二者以一个空格分隔。所有坐标均在区间 $[-16\\ 000, 16\\ 000]$ 内。\n", "outputFormat": "\n标准输出仅一行，输出一个整数—— Byteasar 最多可以拜访的朋友数量。\n", "hint": "\n样例解释：\n\n![](https://cdn.luogu.com.cn/upload/pic/8961.png)\n\n翻译来自 ChatGPT 5。", "locale": "zh-CN"}}}
{"pid": "P3434", "type": "P", "difficulty": 3, "samples": [["7 3\n5 6 4 3 6 2 3\n3 2 5", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "POI（波兰）"], "title": "[POI 2006] KRA-The Disks", "background": "", "description": "Johnny 在他生日的那天收到了来自他父母的生日礼物：一个管子和一套圆盘。管子由若干个高度相等的圆柱体组合而成，并且每个圆盘拥有和每段圆柱相同的高度，每个圆柱体上开大小不同的孔。\n\nJohnny 收到这套礼物后，发明了一个小游戏：他按一定顺序将圆盘放入管子当中，他想算出最后一个圆盘会停在哪个深度。\n\n显然，有两种情况会让圆盘停止掉落：其一是圆盘无法通过小孔（即孔的直径小于圆盘的直径），其二则是被其他圆盘挡住。\n\nJohnny 被他自己发明的游戏难住了，他现在把这个问题交给了你，你一定会帮助他解决这个难题的！", "inputFormat": "第一行两个整数 $n$ 和 $m$，分别代表管子的深度和圆盘的数量。\n\n下一行 $n$ 个整数 $r_i$，代表第 $i$ 层管子小孔的直径。\n\n第三行 $m$ 个整数 $k_i$，代表第 $i$ 个放入管子的圆盘的直径。", "outputFormat": "输出一个整数，代表最后一个圆盘会停留在第几层。\n\n如果最后一个圆盘无法放入管子，则输出 $0$。", "hint": "$1 \\leq n,m \\leq 3 \\times 10^5$，$1 \\leq r_i,k_i \\leq 10^9$", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2006] KRA-The Disks", "background": "", "description": "On his birthday, Johnny received a gift from his parents: a tube and a set of disks. The tube is composed of several cylindrical segments of equal height, and each disk has the same height as one segment. Each cylindrical segment has a hole, and the hole diameters may differ between segments.\n\nJohnny invented a game: he inserts the disks into the tube in a given order and wants to determine at which depth (level) the last disk will stop.\n\nA disk stops falling in two cases: either it cannot pass through a small hole (i.e., the hole’s diameter is smaller than the disk’s diameter), or it is blocked by previously inserted disks.\n\nJohnny is puzzled by his own game. He asks you to solve this problem for him.", "inputFormat": "The first line contains two integers $n$ and $m$, the tube’s depth (number of segments) and the number of disks, respectively.\n\nThe second line contains $n$ integers $r_i$, where $r_i$ is the diameter of the hole in the $i$-th segment of the tube.\n\nThe third line contains $m$ integers $k_i$, where $k_i$ is the diameter of the $i$-th disk inserted into the tube.", "outputFormat": "Output a single integer: the level at which the last disk will rest.\n\nIf the last disk cannot be inserted into the tube, output $0$.", "hint": "Constraints: $1 \\le n,m \\le 3 \\times 10^5$, $1 \\le r_i,k_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2006] KRA-The Disks", "background": "", "description": "Johnny 在他生日的那天收到了来自他父母的生日礼物：一个管子和一套圆盘。管子由若干个高度相等的圆柱体组合而成，并且每个圆盘拥有和每段圆柱相同的高度，每个圆柱体上开大小不同的孔。\n\nJohnny 收到这套礼物后，发明了一个小游戏：他按一定顺序将圆盘放入管子当中，他想算出最后一个圆盘会停在哪个深度。\n\n显然，有两种情况会让圆盘停止掉落：其一是圆盘无法通过小孔（即孔的直径小于圆盘的直径），其二则是被其他圆盘挡住。\n\nJohnny 被他自己发明的游戏难住了，他现在把这个问题交给了你，你一定会帮助他解决这个难题的！", "inputFormat": "第一行两个整数 $n$ 和 $m$，分别代表管子的深度和圆盘的数量。\n\n下一行 $n$ 个整数 $r_i$，代表第 $i$ 层管子小孔的直径。\n\n第三行 $m$ 个整数 $k_i$，代表第 $i$ 个放入管子的圆盘的直径。", "outputFormat": "输出一个整数，代表最后一个圆盘会停留在第几层。\n\n如果最后一个圆盘无法放入管子，则输出 $0$。", "hint": "$1 \\leq n,m \\leq 3 \\times 10^5$，$1 \\leq r_i,k_i \\leq 10^9$", "locale": "zh-CN"}}}
{"pid": "P3435", "type": "P", "difficulty": 4, "samples": [["8\nbabababa", "24"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "2006", "POI（波兰）", "KMP 算法"], "title": "[POI 2006] OKR-Periods of Words", "background": "", "description": "A string is a finite sequence of lower-case (non-capital) letters of the English alphabet. Particularly, it may be an empty sequence, i.e. a sequence of 0 letters. By A=BC we denotes that A is a string obtained by concatenation (joining by writing one immediately after another, i.e. without any space, etc.) of the strings B and C (in this order). A string P is a prefix of the string !, if there is a string B, that A=PB. In other words, prefixes of A are the initial fragments of A. In addition, if P!=A and P is not an empty string, we say, that P is a proper prefix of A.\n\n\nA string Q is a period of Q, if Q is a proper prefix of A and A is a prefix (not necessarily a proper one) of the string QQ. For example, the strings abab and ababab are both periods of the string abababa. The maximum period of a string A is the longest of its periods or the empty string, if A doesn't have any period. For example, the maximum period of ababab is abab. The maximum period of abc is the empty string.\n\nTask Write a programme that:\n\nreads from the standard input the string's length and the string itself,calculates the sum of lengths of maximum periods of all its prefixes,writes the result to the standard output.\n\n\n", "inputFormat": "In the first line of the standard input there is one integer $k$ ($1\\le k\\le 1\\ 000\\ 000$) - the length of the string. In the following line a sequence of exactly $k$ lower-case letters of the English alphabet is written - the string.\n", "outputFormat": "In the first and only line of the standard output your programme should write an integer - the sum of lengths of maximum periods of all prefixes of the string given in the input.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2006] OKR-Periods of Words", "background": "", "description": "A string is a finite sequence of lower-case (non-capital) letters of the English alphabet. Particularly, it may be an empty sequence, i.e. a sequence of 0 letters. By A=BC we denotes that A is a string obtained by concatenation (joining by writing one immediately after another, i.e. without any space, etc.) of the strings B and C (in this order). A string P is a prefix of the string !, if there is a string B, that A=PB. In other words, prefixes of A are the initial fragments of A. In addition, if P!=A and P is not an empty string, we say, that P is a proper prefix of A.\n\n\nA string Q is a period of Q, if Q is a proper prefix of A and A is a prefix (not necessarily a proper one) of the string QQ. For example, the strings abab and ababab are both periods of the string abababa. The maximum period of a string A is the longest of its periods or the empty string, if A doesn't have any period. For example, the maximum period of ababab is abab. The maximum period of abc is the empty string.\n\nTask Write a programme that:\n\nreads from the standard input the string's length and the string itself,calculates the sum of lengths of maximum periods of all its prefixes,writes the result to the standard output.\n\n\n", "inputFormat": "In the first line of the standard input there is one integer $k$ ($1\\le k\\le 1\\ 000\\ 000$) - the length of the string. In the following line a sequence of exactly $k$ lower-case letters of the English alphabet is written - the string.\n", "outputFormat": "In the first and only line of the standard output your programme should write an integer - the sum of lengths of maximum periods of all prefixes of the string given in the input.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2006] OKR-Periods of Words", "background": null, "description": "一个**字符串**是由小写英文字母组成的有限序列。特别地，它也可以是空序列（即长度为 $0$ 的序列）。\n\n如果字符串 $A$ 是通过字符串 $B$ 和 $C$ 按顺序连接（中间没有任何间隔符号）得到的，我们表示为 $A=BC$。\n\n如果存在一个字符串 $B$ 使得 $A=PB$，那么字符串 $P$ 是字符串 $A$ 的**前缀**。此外，如果 $P \\neq A$ 且 $P$ 不是空字符串，我们称 $P$ 是 $A$ 的**真前缀**。\n\n如果 $Q$ 是 $A$ 的真前缀，并且 $A$ 是字符串 $QQ$ 的前缀（不一定是真前缀），那么字符串 $Q$ 是 $A$ 的**周期**。例如，字符串 `abab` 和 `ababab` 都是 `abababa` 的周期。\n\n字符串 $A$ 的**最大周期**是其最长的周期，如果 $A$ 没有周期，则为空字符串。例如，`ababab` 的最大周期是 `abab`；`abc` 的最大周期是空字符串。\n\n---\n\n任务：\n\n编写一个程序，计算该字符串所有前缀的最大周期长度之和。", "inputFormat": "第一行包含一个整数 $k$，表示字符串的长度。 \n\n接下来的一行包含一个由 $k$ 个小写英文字母组成的字符串。", "outputFormat": "单独一行输出一个整数，表示输入字符串所有前缀的最大周期长度之和。", "hint": "（由 Gemini 2.5 Flash 翻译，人工审核）\n\n### 数据范围\n\n对于所有数据，$1\\le k\\le10^6$。", "locale": "zh-CN"}}}
{"pid": "P3436", "type": "P", "difficulty": 5, "samples": [["3 5\n1 2\n1 3\n2 3\n3 4\n3 4", "4\n1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2006", "POI（波兰）", "拓扑排序", "Tarjan"], "title": "[POI 2006] PRO-Professor Szu", "background": "", "description": "The Byteotian University is situated in the city of Byteion.\n\nApart from the main building the university owns \\(n\\) cottages for its academic staff. The cottages are connected with one - way alleys, however, there could be more than one alley between any two cottages (the alley can also form a loop connecting a building to itself). There are also alleys connecting the cottages to the main building. Byteion has been constructed so that no two alleys intersect in a point different from a cottage or the main building (there can however be bridges or tunnels on alleys). Moreover, each and every alley starts and ends in a cottage or the main building. It is known that a route exists between at least one of the cottages and the main building.\n\nOnce upon a time, the Byteotian University fancied to hire a well - known computer science pundit - professor Szu. As most outstanding scientists professor Szu has a certain peculiarity to him: each day he wishes to go to the university using a different route (a route being a sequence of alleys, each starting at the cottage the previous one ended at; the main building and each of the cottages may be visited many times). The professor considers two routes distinct if they differ by at least one alley (the order matters; two different alleys connecting the very same two cottages are considered distinct).\n\nKnowing the diagram of connections help the university in finding a cottage which has the greatest number of different routes to the main building possible (staying in such a cottage professor Szu will spend the longest time working at the university). Should there be more than one such cottage - find all of them. Should there be more than 36500 possible routes between a certain cottage and the main building we will assume that professor Szu can stay in this particular cottage forever (as he surely cannot live infinitely and 100 years seems a safe guess).\n\n### Task\n\nWrite a programme which:\n- reads from the standard input the diagram of connections between the cottages of Byteion,\n- determines the cottages which Professor Szu could live the longest time in and the longest possible time of habitation,\n- writes the outcome to the standard output.\n", "inputFormat": "The first line of the standard input contains two integers $n$ and $m$ ($1\\leq n,m\\leq1000000$) separated by a single space and denoting the number of cottages and alleys in Byteion, respectively (the cottages are numbered from 1 to $n$, and the university main building is denoted by $n + 1$). \n\nIn the following lines (2 to $m + 1$) there are pairs of integers $a_i,b_i$ ($1\\leq a_i,b_i\\leq n + 1$ for $1\\leq i\\leq m$) separated by single spaces and denoting the number of the cottage which the $i$'th alley starts at and the number of the cottage which the $i$'th alley ends at, respectively.", "outputFormat": "The first line of the standard output should contain the largest number of days that professor Szu could spend in Byteion or a single word *zawsze* (i.e. always in Polish) should this number exceed 36500 days. \n\nThe second line of the standard output should contain the number of cottages, living in which the professor can stay in Byteion for the amount of time specified in the first line. \n\nIn the third line of the standard output your programme should write out the numbers of all such cottages, separated by single spaces, and arranged in increasing order. All cottages, which the professor can stay forever in, are considered equal. ", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2006] PRO-Professor Szu", "background": "", "description": "The Byteotian University is situated in the city of Byteion.\n\nApart from the main building the university owns \\(n\\) cottages for its academic staff. The cottages are connected with one - way alleys, however, there could be more than one alley between any two cottages (the alley can also form a loop connecting a building to itself). There are also alleys connecting the cottages to the main building. Byteion has been constructed so that no two alleys intersect in a point different from a cottage or the main building (there can however be bridges or tunnels on alleys). Moreover, each and every alley starts and ends in a cottage or the main building. It is known that a route exists between at least one of the cottages and the main building.\n\nOnce upon a time, the Byteotian University fancied to hire a well - known computer science pundit - professor Szu. As most outstanding scientists professor Szu has a certain peculiarity to him: each day he wishes to go to the university using a different route (a route being a sequence of alleys, each starting at the cottage the previous one ended at; the main building and each of the cottages may be visited many times). The professor considers two routes distinct if they differ by at least one alley (the order matters; two different alleys connecting the very same two cottages are considered distinct).\n\nKnowing the diagram of connections help the university in finding a cottage which has the greatest number of different routes to the main building possible (staying in such a cottage professor Szu will spend the longest time working at the university). Should there be more than one such cottage - find all of them. Should there be more than 36500 possible routes between a certain cottage and the main building we will assume that professor Szu can stay in this particular cottage forever (as he surely cannot live infinitely and 100 years seems a safe guess).\n\n### Task\n\nWrite a programme which:\n- reads from the standard input the diagram of connections between the cottages of Byteion,\n- determines the cottages which Professor Szu could live the longest time in and the longest possible time of habitation,\n- writes the outcome to the standard output.\n", "inputFormat": "The first line of the standard input contains two integers $n$ and $m$ ($1\\leq n,m\\leq1000000$) separated by a single space and denoting the number of cottages and alleys in Byteion, respectively (the cottages are numbered from 1 to $n$, and the university main building is denoted by $n + 1$). \n\nIn the following lines (2 to $m + 1$) there are pairs of integers $a_i,b_i$ ($1\\leq a_i,b_i\\leq n + 1$ for $1\\leq i\\leq m$) separated by single spaces and denoting the number of the cottage which the $i$'th alley starts at and the number of the cottage which the $i$'th alley ends at, respectively.", "outputFormat": "The first line of the standard output should contain the largest number of days that professor Szu could spend in Byteion or a single word *zawsze* (i.e. always in Polish) should this number exceed 36500 days. \n\nThe second line of the standard output should contain the number of cottages, living in which the professor can stay in Byteion for the amount of time specified in the first line. \n\nIn the third line of the standard output your programme should write out the numbers of all such cottages, separated by single spaces, and arranged in increasing order. All cottages, which the professor can stay forever in, are considered equal. ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2006] PRO-Professor Szu", "background": "", "description": "某大学校内有一栋主楼，还有 $n$ 栋住宅楼。这些楼之间由一些单向道路连接，但是任意两栋楼之间可能有多条道路，也可能存在起点和终点为同一栋楼的环路。存在住宅楼无法到达主楼的情况，但**保证至少有一间宿舍和主楼之间存在路径**。\n\n现在有一位古怪的教授，他希望每天去主楼上班的路线不同。\n\n一条上班路线中，每栋楼都可以访问任意多次。我们称两条上班路线是**不同的**，当且仅当两条路线中存在**至少**一条路是不同的（两栋楼之间的多条道路被视为是不同的道路）。\n\n现在教授希望知道，从哪些住宅楼前往主楼的上班路线数最多。", "inputFormat": "第一行两个整数 $n,m$，分别为大学内住宅楼的数量和道路的数量。大学内所有住宅楼编号为 $1 \\sim n$，主楼编号为 $n+1$。\n\n接下来 $m$ 行，第 $i$ 行两个整数 $u_i,v_i$，代表大学内存在一条从 $u_i$ 号楼到 $v_i$ 号楼的道路。", "outputFormat": "第一行：如果存在一栋楼到主楼的上班路线数超过了 $36500$，输出 `zawsze`。否则输出一个整数，代表从一栋住宅楼前往主楼的最多上班路线数。\n\n第二行：输出一个整数 $p$，代表有多少栋住宅楼能使前往主楼的上班路线数最大化。特别地，如果最大上班路线数超过了 $36500$，那么这一行请输出能使上班路线数超过 $36500$ 的住宅楼的数量。\n\n第三行：按编号从小到大的顺序输出 $p$ 个整数，代表能使前往主楼的上班路线最大化的住宅楼的编号。特别地，如果最大上班路线数超过了 $36500$，那么这一行请输出所有能使上班路线数超过 $36500$ 的住宅楼的编号。", "hint": "对于 $100\\%$ 的数据，满足 $1\\leq n,m\\leq1000000$ ，$1\\leq u_i,v_i\\leq n + 1$。", "locale": "zh-CN"}}}
{"pid": "P3437", "type": "P", "difficulty": 5, "samples": [["7 5 4\n4 3 2 0 0\n3 3 1 3 0\n7 1 2 0 3\n2 3 3 2 2", "6"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2006", "线段树", "POI（波兰）"], "title": "[POI 2006] TET-Tetris 3D", "background": "", "description": "The authors of the game \"Tetris\" have decided to make a new, three-dimensional version, in which cuboids would fall down on a rectangular platform. The blocks fall down separately in a certain order, just like in the two-dimensional game. A block falls down until it reaches an obstacle: the platform or another block, that has already stopped - then it stops and remains in this exact position till the game is over.\n\nHowever, the authors wanted to change the spirit of the game, turning it from a simple arcade-game into a play far more puzzling. Knowing the order of the falling blocks and their flight path the player's task is to tell the height of the highest point of the arrangement after all blocks have fallen down (and stopped). All the blocks are falling down vertically and do not rotate while falling. For convenience we'll introduce a cartesian coordinate system on the platform, with the center in one of the platform's corners and the axes parallel to the platform's edges.\n\nWrite a programme that automates verification of the player's answer.\n\nTaskWrite a programme that:\n\nreads the descriptions of subsequent falling blocks from the standard input,determines the height of the highest point of the arrangement of blocks after all have fallen down and stopped,writes the result to the standard output.\n\n", "inputFormat": "In the first line of the input there are three integers $D$, $S$ and $N$ ($1\\le N\\le 20\\ 000$, $1\\le D,S\\le 1\\ 000$), separated by single spaces and denoting respectively: the length and the depth of the platform and the number of blocks that are going to fall down on it. In the following $N$ lines the descriptions of subsequent blocks are given, one in each line.\n\nEach description of a block consists of five integers: $d$,$s$,$w$,$x$ and $y$ ($1\\le d$, $0\\le x$, $d+x\\le D$, $1\\le s$, $0\\le y$, $s+y\\le S$, $1\\le w\\le 100\\ 000$), representing a block of length $d$ depth $s$ and height $w$. This very block will be be falling down on the platform with its $d\\times s$ face as the bottom, where the length and depth of the block are parallel to those of the platform. The coordinates of the vertices of the projection of the block on the platform are: $(x,y)$, $(x+d,y)$, $(x,y+s)$ and $(x+d,y+s)$.\n", "outputFormat": "The first and only line of the standard output should contain exactly one integer, the height of the highest point of the arrangement of blocks after all have fallen down and stopped.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2006] TET-Tetris 3D", "background": "", "description": "The authors of the game \"Tetris\" have decided to make a new, three-dimensional version, in which cuboids would fall down on a rectangular platform. The blocks fall down separately in a certain order, just like in the two-dimensional game. A block falls down until it reaches an obstacle: the platform or another block, that has already stopped - then it stops and remains in this exact position till the game is over.\n\nHowever, the authors wanted to change the spirit of the game, turning it from a simple arcade-game into a play far more puzzling. Knowing the order of the falling blocks and their flight path the player's task is to tell the height of the highest point of the arrangement after all blocks have fallen down (and stopped). All the blocks are falling down vertically and do not rotate while falling. For convenience we'll introduce a cartesian coordinate system on the platform, with the center in one of the platform's corners and the axes parallel to the platform's edges.\n\nWrite a programme that automates verification of the player's answer.\n\nTaskWrite a programme that:\n\nreads the descriptions of subsequent falling blocks from the standard input,determines the height of the highest point of the arrangement of blocks after all have fallen down and stopped,writes the result to the standard output.\n\n", "inputFormat": "In the first line of the input there are three integers $D$, $S$ and $N$ ($1\\le N\\le 20\\ 000$, $1\\le D,S\\le 1\\ 000$), separated by single spaces and denoting respectively: the length and the depth of the platform and the number of blocks that are going to fall down on it. In the following $N$ lines the descriptions of subsequent blocks are given, one in each line.\n\nEach description of a block consists of five integers: $d$,$s$,$w$,$x$ and $y$ ($1\\le d$, $0\\le x$, $d+x\\le D$, $1\\le s$, $0\\le y$, $s+y\\le S$, $1\\le w\\le 100\\ 000$), representing a block of length $d$ depth $s$ and height $w$. This very block will be be falling down on the platform with its $d\\times s$ face as the bottom, where the length and depth of the block are parallel to those of the platform. The coordinates of the vertices of the projection of the block on the platform are: $(x,y)$, $(x+d,y)$, $(x,y+s)$ and $(x+d,y+s)$.\n", "outputFormat": "The first and only line of the standard output should contain exactly one integer, the height of the highest point of the arrangement of blocks after all have fallen down and stopped.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2006] TET-Tetris 3D", "background": "", "description": "最近，有人发明了一种三维版的俄罗斯方块。和二维版本类似，一些立方体按照一定的顺序掉落，直到碰到别的方块或是地面才会停止掉落。立方体停止掉落后会一直保持掉落时的位置，直到游戏结束。\n\n你的朋友决定以这个新版本的俄罗斯方块为背景，出一道题。给出每个立方体的掉落顺序和其掉落的轨迹，在所有方块完成掉落后求出最高方块的高度。在这个游戏中，方块均垂直下落，且方块不会旋转或翻转。为了方便描述，我们会建立一个空间直角坐标系，该坐标系的原点为地面的一角，并且坐标轴与地面边缘平行。\n\n现在轮到你解决这个问题了。", "inputFormat": "第一行三个整数 $D,S,N$，分别为地面的长度，宽度，和将要掉落的立方体数量。\n\n接下来 $N$ 行，每行五个整数 $d_i,s_i,w_i,x_i,y_i$，描述一个掉落的立方体。其中 $d_i,s_i,w_i$ 分别代表立方体的长，宽，高。立方体的底面（即长 $\\times$ 宽的那一面）将正对地面。立方体底面四个角在地面的投影坐标分别为 $(x_i,y_i)$，$(x_i+d_i,y_i)$，$(x_i,y_i+s_i)$，$(x_i+d_i,y_i+s_i)$。", "outputFormat": "输出一个整数，即方块掉落结束后最高方块的高度。", "hint": "$1 \\leq N \\leq 20\\,000$，$1 \\leq D,S \\leq 1\\,000$，$d_i,s_i \\geq 1$，$1 \\leq w_i \\leq 100\\,000$，$0 \\leq x_i,d_i+x_i \\leq D$，$0 \\leq y_i,s_i+y_i \\leq S$。", "locale": "zh-CN"}}}
{"pid": "P3438", "type": "P", "difficulty": 6, "samples": [["5 5\n1 1 5 5\n2\n3 3\n4 2", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "二分", "单调队列", "POI（波兰）", "广度优先搜索 BFS"], "title": "[POI 2006] ZAB-Frogs", "background": "", "description": "A scourge of frogs destroying all the crop has started in Byteotia. A farmer named Byteasar has decided to fight the vermin with peculiar \"scarefrogs\", that he has set up at certain points of his field. While moving from one place to another, every frog tries to keep as far of them as possible, i.e. maximizes the distance to the closest scarefrog.\n\nThe field that belongs to Byteasar has rectangular shape. The frogs leap in directions parallel to the field's sides and their leaps are unitary (of length 1). The scarefrogs-distance, for a given frog's route, is the minimum of all distances from all scarefrogs at all inter-leap-points of the route.\n\nByteasar already knows the most common starting and destination points of the frogs' routes, therefore he experiments with various deployments of the scarefrogs. He asks you for help, namely he would like you to write a programme that calculates the maximum (over all routes) scarefrogs-distance for a given deployment of scarefrogs - which we call in short the frogshold distance.\n\nTaskWrite a programme that:\n\nreads from the standard input the size of the field, the coordinates of the screfrogs and the source and target position of a frog,determines the frogshold distance (the maximum scarefrogs-distance a frog may achieve while still being able to reach the target point)writes the square of this number to the standard output.\n\n给定一个网格图，其中有一些坏点，要求使起点到终点的路径上的所有点到离该点最近的坏点的最小距离距离最大，求这个最大值。\n", "inputFormat": "The first line of the input contains two integers: $w_x$ and $w_y$ separated by a single space - the breadth and length of the field ($2 \\le w_x, w_y \\le 1000$). The second line of the input contains four integers: $p_x$, $p_y$, $k_x$ and $k_y$ separated by single spaces; $(p_x, p_y)$ is the initial position of the frog, $(k_x, k_y)$is the target (final) position of the frog ($1 \\le p_x, k_x \\le w_x$, $1 \\le p_y, k_y \\le w_y$). The third line of the standard input contains one integer $n$ - these are the coordinates of the ith scarefrog ($1 \\le n \\le w_x \\cdot w_y$). No two scarefrogs occupy the same position and none of them is at the point $(p_x, p_y)$ nor $(k_x, k_y)$.\n", "outputFormat": "In the first and only line of the standard output one integer should be written, namely the square of the frogshold distance. If the frog cannot avoid leaping directly on some scarefrog the result is 0.\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2006] ZAB-Frogs", "background": "", "description": "A scourge of frogs destroying all the crops has started in Byteotia. A farmer named Byteasar has decided to fight the vermin with peculiar “scarefrogs” that he has set up at certain points of his field. While moving from one place to another, every frog tries to keep as far from them as possible, i.e., it maximizes the distance to the closest scarefrog.\n\nByteasar’s field is rectangular. The frogs leap in directions parallel to the field’s sides, and each leap has unit length 1. For a given route, the scarefrog-distance is the minimum, over all points visited continuously along the route (including the points between leaps), of the distance to the nearest scarefrog.\n\nByteasar already knows the most common starting and destination points of the frogs’ routes, so he experiments with various deployments of scarefrogs. He asks you to compute the maximum (over all routes from the start to the target) scarefrog-distance achievable while still reaching the target. We call this value the frogshold distance. You should output the square of this number.\n\nIn other words, given a grid with some “bad” points (the scarefrogs), find a path from the start to the end that maximizes the minimum distance, over all points on the path, to the nearest bad point, and output this maximum squared.", "inputFormat": "- The first line contains two integers $w_x$ and $w_y$ — the width and height of the field ($2 \\le w_x, w_y \\le 1000$).\n- The second line contains four integers $p_x$, $p_y$, $k_x$ and $k_y$; $(p_x, p_y)$ is the frog’s start position, and $(k_x, k_y)$ is the target position ($1 \\le p_x, k_x \\le w_x$, $1 \\le p_y, k_y \\le w_y$).\n- The third line contains one integer $n$ ($1 \\le n \\le w_x \\cdot w_y$).\n- Each of the next $n$ lines contains two integers $x_i$ and $y_i$ — the coordinates of the $i$-th scarefrog.\n- No two scarefrogs occupy the same position, and none of them is at $(p_x, p_y)$ or $(k_x, k_y)$.", "outputFormat": "Output a single integer — the square of the frogshold distance. If the frog cannot avoid leaping directly onto some scarefrog, output $0$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2006] ZAB-Frogs", "background": "", "description": "A scourge of frogs destroying all the crop has started in Byteotia. A farmer named Byteasar has decided to fight the vermin with peculiar \"scarefrogs\", that he has set up at certain points of his field. While moving from one place to another, every frog tries to keep as far of them as possible, i.e. maximizes the distance to the closest scarefrog.\n\nThe field that belongs to Byteasar has rectangular shape. The frogs leap in directions parallel to the field's sides and their leaps are unitary (of length 1). The scarefrogs-distance, for a given frog's route, is the minimum of all distances from all scarefrogs at all inter-leap-points of the route.\n\nByteasar already knows the most common starting and destination points of the frogs' routes, therefore he experiments with various deployments of the scarefrogs. He asks you for help, namely he would like you to write a programme that calculates the maximum (over all routes) scarefrogs-distance for a given deployment of scarefrogs - which we call in short the frogshold distance.\n\nTaskWrite a programme that:\n\nreads from the standard input the size of the field, the coordinates of the screfrogs and the source and target position of a frog,determines the frogshold distance (the maximum scarefrogs-distance a frog may achieve while still being able to reach the target point)writes the square of this number to the standard output.\n\n给定一个网格图，其中有一些坏点，要求使起点到终点的路径上的所有点到离该点最近的坏点的最小距离距离最大，求这个最大值。\n", "inputFormat": "The first line of the input contains two integers: $w_x$ and $w_y$ separated by a single space - the breadth and length of the field ($2 \\le w_x, w_y \\le 1000$). The second line of the input contains four integers: $p_x$, $p_y$, $k_x$ and $k_y$ separated by single spaces; $(p_x, p_y)$ is the initial position of the frog, $(k_x, k_y)$is the target (final) position of the frog ($1 \\le p_x, k_x \\le w_x$, $1 \\le p_y, k_y \\le w_y$). The third line of the standard input contains one integer $n$ - these are the coordinates of the ith scarefrog ($1 \\le n \\le w_x \\cdot w_y$). No two scarefrogs occupy the same position and none of them is at the point $(p_x, p_y)$ nor $(k_x, k_y)$.\n", "outputFormat": "In the first and only line of the standard output one integer should be written, namely the square of the frogshold distance. If the frog cannot avoid leaping directly on some scarefrog the result is 0.\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3439", "type": "P", "difficulty": 6, "samples": [["3\n2 2 1\n6 2 1\n4 6 1", "4 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2006", "POI（波兰）", "Special Judge"], "title": "[POI 2006] MAG-Warehouse", "background": "", "description": "The streets of the New Byte City form a rectangular grid - those running east-west are simply called streets, while those running north-south are called avenues. To avoid mistakes, we shall call them h-streets and v-streets, respectively. The v-streets are numbered from $1$ to $500\\ 000\\ 000$ eastwards. Similarly, the h-streets are numbered from $1$ to $500\\ 000\\ 000$ northwards. Every v-street crosses every h-street and, conversely, every h-street crosses every v-street. The distance between two consecutive v-streets, as well as between two consecutive h-streets, is exactly one kilometre.\n\n ![](https://cdn.luogu.com.cn/upload/pic/6964.png) \n\nThere are $k$ shops in the city, each one of them is situated at a crossroads. Byteasar, the merchant, supplies every single one of the $k$ shops, and furthermore he returns to some of them several times a day with fresh supplies. Recently he has decided to have a warehouse built, from which the goods would be delivered. For obvious reasons, it should stand at a crossroads. The lorry loaded with goods can supply only one shop per course - it leaves the warehouse, delivers to the shop and returns to the warehouse. The lorry always picks the shortest path from the warehouse to the shop, and the shortest one back (possibly the same one). The distance between points $(x_i, y_i)$ and $(x_j, y_j)$ equals $\\max \\{ |x_i - x_j|, |y_i - y_j| \\}$.\n\nTaskWrite a programme that:\n\nreads the locations of shops, as well as the numbers of their daily deliveries, from the standard inputdetermines such a warehouse's position that the summary distance of the lorry's daily route is minimal,writes the result to the standard output.\n\n给定一个网格图，其上有一堆坏点(整点，同一位置多个)，求一个整点，使得该整点到所有的坏点的**切比雪夫距离**之和最小。\n\n求这个整点位置。(横纵坐标最大)\n", "inputFormat": "The first line of the standard input contains one integer $n$ ($1 \\le n \\le 100\\ 000$), the number of shops in the New Byte City.\n\nThe following $n$ lines contain the shops' descriptions. The $(i+1)$'th line contains three integers $x_i$, $y_i$ and $t_i$ ($1 \\le x_i, y_i \\le 500\\ 000\\ 000$, $1 \\le t_i \\le 1\\ 000\\ 000$), separated by single spaces. This triple means that the $i$'th shop lies at the crossing of $x_i$'th v-street and $y_i$'th h-street and the lorry delivers goods to this shop $t_i$ times a day.\n", "outputFormat": "The first and only line of the standard output should contain two integers $x_m$ and $y_m$, separated by a single space, denoting the optimal position of the warehouse as the crossroads of the $x_m$'th v-street and the $y_m$'th h-street. Should there be many optimal solutions, your programme is to pick one of them arbitrarily.\n", "hint": "感谢@oscar 提供SPJ\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2006] MAG-Warehouse", "background": "", "description": "The streets of the New Byte City form a rectangular grid — those running east-west are simply called streets, while those running north-south are called avenues. To avoid mistakes, we shall call them h-streets and v-streets, respectively. The v-streets are numbered from $1$ to $500\\ 000\\ 000$ eastwards. Similarly, the h-streets are numbered from $1$ to $500\\ 000\\ 000$ northwards. Every v-street crosses every h-street and, conversely, every h-street crosses every v-street. The distance between two consecutive v-streets, as well as between two consecutive h-streets, is exactly one kilometre.\n\n![](https://cdn.luogu.com.cn/upload/pic/6964.png)\n\nThere are $k$ shops in the city, each one of them situated at a crossroads. Byteasar, the merchant, supplies every single one of the $k$ shops, and furthermore he returns to some of them several times a day with fresh supplies. Recently he has decided to have a warehouse built, from which the goods would be delivered. For obvious reasons, it should stand at a crossroads. The lorry loaded with goods can supply only one shop per course — it leaves the warehouse, delivers to the shop, and returns to the warehouse. The lorry always picks the shortest path from the warehouse to the shop, and the shortest one back (possibly the same one). The distance between points $(x_i, y_i)$ and $(x_j, y_j)$ equals $\\max \\{ |x_i - x_j|, |y_i - y_j| \\}$.\n\nTask: Write a program that:\n- reads the locations of shops, as well as the numbers of their daily deliveries, from the standard input,\n- determines such a warehouse position that the total distance of the lorry’s daily route is minimal,\n- writes the result to the standard output.\n\nGiven a grid graph with a set of “bad points” at integer coordinates (multiplicity allowed at the same location), find an integer lattice point that minimizes the sum of Chebyshev distances to all the bad points. Find such a lattice point position.", "inputFormat": "The first line of the standard input contains one integer $n$ ($1 \\le n \\le 100\\ 000$), the number of shops in the New Byte City.\n\nThe following $n$ lines contain the shops’ descriptions. The $(i+1)$'th line contains three integers $x_i$, $y_i$ and $t_i$ ($1 \\le x_i, y_i \\le 500\\ 000\\ 000$, $1 \\le t_i \\le 1\\ 000\\ 000$), separated by single spaces. This triple means that the $i$'th shop lies at the crossing of the $x_i$'th v-street and the $y_i$'th h-street, and the lorry delivers goods to this shop $t_i$ times a day.", "outputFormat": "The first and only line of the standard output should contain two integers $x_m$ and $y_m$, separated by a single space, denoting the optimal position of the warehouse as the crossroads of the $x_m$'th v-street and the $y_m$'th h-street. Should there are many optimal solutions, your program may pick one of them arbitrarily.", "hint": "Thanks to @oscar for providing the SPJ.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2006] MAG-Warehouse", "background": "", "description": "The streets of the New Byte City form a rectangular grid - those running east-west are simply called streets, while those running north-south are called avenues. To avoid mistakes, we shall call them h-streets and v-streets, respectively. The v-streets are numbered from $1$ to $500\\ 000\\ 000$ eastwards. Similarly, the h-streets are numbered from $1$ to $500\\ 000\\ 000$ northwards. Every v-street crosses every h-street and, conversely, every h-street crosses every v-street. The distance between two consecutive v-streets, as well as between two consecutive h-streets, is exactly one kilometre.\n\n ![](https://cdn.luogu.com.cn/upload/pic/6964.png) \n\nThere are $k$ shops in the city, each one of them is situated at a crossroads. Byteasar, the merchant, supplies every single one of the $k$ shops, and furthermore he returns to some of them several times a day with fresh supplies. Recently he has decided to have a warehouse built, from which the goods would be delivered. For obvious reasons, it should stand at a crossroads. The lorry loaded with goods can supply only one shop per course - it leaves the warehouse, delivers to the shop and returns to the warehouse. The lorry always picks the shortest path from the warehouse to the shop, and the shortest one back (possibly the same one). The distance between points $(x_i, y_i)$ and $(x_j, y_j)$ equals $\\max \\{ |x_i - x_j|, |y_i - y_j| \\}$.\n\nTaskWrite a programme that:\n\nreads the locations of shops, as well as the numbers of their daily deliveries, from the standard inputdetermines such a warehouse's position that the summary distance of the lorry's daily route is minimal,writes the result to the standard output.\n\n给定一个网格图，其上有一堆坏点(整点，同一位置多个)，求一个整点，使得该整点到所有的坏点的**切比雪夫距离**之和最小。\n\n求这个整点位置。(横纵坐标最大)\n", "inputFormat": "The first line of the standard input contains one integer $n$ ($1 \\le n \\le 100\\ 000$), the number of shops in the New Byte City.\n\nThe following $n$ lines contain the shops' descriptions. The $(i+1)$'th line contains three integers $x_i$, $y_i$ and $t_i$ ($1 \\le x_i, y_i \\le 500\\ 000\\ 000$, $1 \\le t_i \\le 1\\ 000\\ 000$), separated by single spaces. This triple means that the $i$'th shop lies at the crossing of $x_i$'th v-street and $y_i$'th h-street and the lorry delivers goods to this shop $t_i$ times a day.\n", "outputFormat": "The first and only line of the standard output should contain two integers $x_m$ and $y_m$, separated by a single space, denoting the optimal position of the warehouse as the crossroads of the $x_m$'th v-street and the $y_m$'th h-street. Should there be many optimal solutions, your programme is to pick one of them arbitrarily.\n", "hint": "感谢@oscar 提供SPJ\n", "locale": "zh-CN"}}}
{"pid": "P3440", "type": "P", "difficulty": 6, "samples": [["5\n1 1 2 3\n1 1 5 1\n3 2 5 5\n4 1 5 10\n3 3 3 1", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "POI（波兰）", "深度优先搜索 DFS", "最小割"], "title": "[POI 2006] SZK-Schools", "background": "", "description": "B 国境内有 $n$ 所学校，每所学校都有一个 $1 \\sim n$ 的编号。\n\n由于管理过于宽松，可能存在两个学校同时用一个编号的情况，当然也存在一个编号没有学校用的情况。\n\n现在国王决定重新给所有学校编号，使得任意两个学校的编号不同。\n\n当然，改变编号是一个很繁重的工作，学校不希望自己的编号改变太多。每个学校都有一个可以接受的新编号区间 $[a,b]$，以及改变编号的单位成本 $k$。如果一个学校的旧编号为 $m$，新编号为 $m'$，那么给这个学校改变编号的成本即为 $k \\times |m'-m|$。\n\n现在你需要告诉国王完成编号更新的最低成本是多少，或者说明这是不可能的。", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行，每行四个整数 $m_i,a_i,b_i,k_i$，代表 $i$ 号学校的旧编号为 $m_i$，新编号的范围为 $[a_i,b_i]$，改变编号的单位成本为 $k_i$。", "outputFormat": "如果不存在一种方案，使得任意两个学校的编号不同，输出 `NIE`。\n\n否则输出一个整数，代表最小成本。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le a_i \\le m_i \\le b_i \\le n \\le 200$，$1\\le k_i \\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2006] SZK-Schools", "background": "", "description": "There are $n$ schools in country B, each with an ID from $1 \\sim n$.\n\nDue to lax administration, it may happen that two schools share the same ID, and some IDs may be unused.\n\nNow the king decides to reassign IDs to all schools so that any two schools have different IDs.\n\nHowever, changing IDs is a heavy workload, and schools do not want their IDs to change too much. Each school has an acceptable interval for its new ID $[a,b]$, and a unit cost $k$. If a school’s old ID is $m$ and the new ID is $m'$, then the cost to change this school’s ID is $k \\times |m'-m|$.\n\nYou need to tell the king the minimum total cost to complete the renumbering, or state that it is impossible.", "inputFormat": "The first line contains an integer $n$.\n\nThen follow $n$ lines, each containing four integers $m_i,a_i,b_i,k_i$, meaning that school $i$ has old ID $m_i$, its new ID must be in the range $[a_i,b_i]$, and its unit cost is $k_i$.", "outputFormat": "If there is no assignment such that any two schools have different IDs, output `NIE`.\n\nOtherwise, output a single integer, the minimum total cost.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1\\le a_i \\le m_i \\le b_i \\le n \\le 200$, $1\\le k_i \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2006] SZK-Schools", "background": "", "description": "B 国境内有 $n$ 所学校，每所学校都有一个 $1 \\sim n$ 的编号。\n\n由于管理过于宽松，可能存在两个学校同时用一个编号的情况，当然也存在一个编号没有学校用的情况。\n\n现在国王决定重新给所有学校编号，使得任意两个学校的编号不同。\n\n当然，改变编号是一个很繁重的工作，学校不希望自己的编号改变太多。每个学校都有一个可以接受的新编号区间 $[a,b]$，以及改变编号的单位成本 $k$。如果一个学校的旧编号为 $m$，新编号为 $m'$，那么给这个学校改变编号的成本即为 $k \\times |m'-m|$。\n\n现在你需要告诉国王完成编号更新的最低成本是多少，或者说明这是不可能的。", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行，每行四个整数 $m_i,a_i,b_i,k_i$，代表 $i$ 号学校的旧编号为 $m_i$，新编号的范围为 $[a_i,b_i]$，改变编号的单位成本为 $k_i$。", "outputFormat": "如果不存在一种方案，使得任意两个学校的编号不同，输出 `NIE`。\n\n否则输出一个整数，代表最小成本。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le a_i \\le m_i \\le b_i \\le n \\le 200$，$1\\le k_i \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P3441", "type": "P", "difficulty": 6, "samples": [["17 3\n1 2\n3 2\n2 4\n5 2\n5 6\n5 8\n7 8\n9 8\n5 10\n10 13\n13 14\n10 12\n12 11\n15 17\n15 16\n15 10", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2006", "POI（波兰）"], "title": "[POI 2006] MET-Subway", "background": "", "description": "某城市长期进行地铁建设。由于财务管理不善且成本被严重低估，导致没有预留购买列车的资金。结果只建成了过多的车站和部分规划中的隧道——仅能确保任意两个车站之间存在连接。隧道数量（每条隧道都是双向的）比已建成的车站数量少一。剩余资金仅能购置少量列车。\n\n为了挽回颜面，董事会请你规划地铁线路，使得被连接的站点数量最大化。每列列车在指定线路上行驶。线路不能分叉（即同一车站不能有三条隧道属于同一条线路）。不同线路可以包含相同的车站或隧道。\n\n**任务**  \n编写一个程序：\n\n1. 从标准输入读取隧道系统的描述和待规划的地铁线路数量；\n2. 计算指定数量的地铁线路能覆盖的最大站点数；\n3. 将结果输出到标准输出。", "inputFormat": "标准输入的第一行包含两个整数 $n$ 和 $l$（$2 \\le n \\le 1\\,000\\,000$，$0 \\le l \\le n$），以单个空格分隔。$n$ 表示车站数量，$l$ 表示待规划的地铁线路数量。车站编号为 $1$ 至 $n$。\n\n接下来的 $n-1$ 行，每行包含两个不同的整数，以单个空格分隔。第 $(i+1)$ 行的数字 $1 \\le a_i, b_i \\le n$ 表示第 $i$ 条隧道连接的两个车站编号。", "outputFormat": "标准输出的第一行（也是唯一一行）应包含一个整数，表示列车线路能覆盖的最大站点数。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2006] MET-Subway", "background": "", "description": "A certain city has been coping with subway construction for a long time. The finances have been mismanaged and the costs have been underestimated to such extent that no funds were foreseen for the purchase of trains. As a result, too many stations and only some of the planned tunnels have been built - barely enough to allow a connection between any two stations to exist. The number of tunnels (each of them is bidirectional) is one less than the number of stations built. From the remaining funds only a handful of trains have been acquired.\n\nTo save their face, the board of directors have asked you to plan subway routes in such a way as to allow maximal number of stations to be connected. Each train travels on a specified route. The routes cannot branch (no three tunnels starting at a single station may belong to the same route). Distinct routes may comprise the same station or tunnel.\n\nTaskWrite a programme which:\n\nreads a description of the tunnel system and the number of subway lines, which are to be planned from the standard input,calculates the maximal number of stations which can be covered by the specified number of subway lines,writes the outcome to the standard output.", "inputFormat": "The first line of the standard input contains two integers $n$ and $l$ ($2 \\le n \\le 1\\ 000\\ 000, 0 \\le l \\le n$) separated by a single space. $n$ denotes the number of stations and $l$ denotes the number of subway lines, which are to be planned. The stations are numbered from $1$ to $n$.\n\nEach of the following $n-1$ lines contains two distinct integers separated by a single space.\n\nThe numbers $1 \\le a_i, b_i \\le n$ in the $(i+1)$'th line denote the numbers of stations connected by $i$'th tunnel.\n", "outputFormat": "The first and only line of the standard output should contain a single integer denoting the maximal number of stations which can be covered by train routes.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2006] MET-Subway", "background": "", "description": "某城市长期进行地铁建设。由于财务管理不善且成本被严重低估，导致没有预留购买列车的资金。结果只建成了过多的车站和部分规划中的隧道——仅能确保任意两个车站之间存在连接。隧道数量（每条隧道都是双向的）比已建成的车站数量少一。剩余资金仅能购置少量列车。\n\n为了挽回颜面，董事会请你规划地铁线路，使得被连接的站点数量最大化。每列列车在指定线路上行驶。线路不能分叉（即同一车站不能有三条隧道属于同一条线路）。不同线路可以包含相同的车站或隧道。\n\n**任务**  \n编写一个程序：\n\n1. 从标准输入读取隧道系统的描述和待规划的地铁线路数量；\n2. 计算指定数量的地铁线路能覆盖的最大站点数；\n3. 将结果输出到标准输出。", "inputFormat": "标准输入的第一行包含两个整数 $n$ 和 $l$（$2 \\le n \\le 1\\,000\\,000$，$0 \\le l \\le n$），以单个空格分隔。$n$ 表示车站数量，$l$ 表示待规划的地铁线路数量。车站编号为 $1$ 至 $n$。\n\n接下来的 $n-1$ 行，每行包含两个不同的整数，以单个空格分隔。第 $(i+1)$ 行的数字 $1 \\le a_i, b_i \\le n$ 表示第 $i$ 条隧道连接的两个车站编号。", "outputFormat": "标准输出的第一行（也是唯一一行）应包含一个整数，表示列车线路能覆盖的最大站点数。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P3442", "type": "P", "difficulty": 6, "samples": [["5\n4 1\n1 4\n8 9\n11 5\n8 1\n4\n7 2 3\n6 3 -1\n4 5 3\n9 6 -4", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "POI（波兰）", "凸包"], "title": "[POI 2006] NAJ-The Invasion", "background": "", "description": "And so it has come - the Triangles have invaded Byteotia!\n\nByteotia lies on an island, occupying its entire surface.\n\nThe shape of the island is a convex polygon(i.e. a polygon whose each inner angle is smaller than $180\\degree$).\n\nA certain number of software factories are located in Byteotia, each of which generates constant gains or losses.\n\nThe Triangles have decided to occupy such a part of Byteotia which:\n\nis a triangle-shaped area, the vertices of which are three different vertices of the polygon-island,     brings the largest income i.e. the sum of all gains and losses generated by factories within the occupied area is maximal.\n\nWe assume that a factory located on the border or in the vertex of occupied area belongs to that area. A territory which contains no factory brings, obviously, a zero income.\n\nByteasar, the King of Byteotia, is concerned by the amount of losses the Triangles' invasion could generate. Help him by writing a programme which shall calculate the sum of gains and losses generated by factories which the Triangles wish to capture.\n\nTaskWrite a programme which:\n\nreads a decription of Byteotia's shape and the locations of factories from the input file,     determines the maximal value of sum of all gains and losses generated by factories within a triangle, whose vertices are three different vertices of the polygon island,     writes the outcome to the output file.\n\n给定一个凸包， 并给出凸包内部或边上的若干个资源，每个资源都有权值,现在要在凸包上面选择不同的3个点，使得3个点组成的三角形\n内部的资源的权值之和最大。\n\n\n凸包点个数 $n \\le 600$\n\n\n资源个数 $m \\le 10000$\n", "inputFormat": "The first line of the input file contains a single integer $n$ ($3 \\le n \\le 600$), denoting the number of vertices of the polygon-island.\n\nThe following $n$ lines of the input contain two integers each $x_j$ and $y_j$ ($-10\\ 000 \\le x_j, y_j \\le 10\\ 000$), separated by a single space, denoting the coordinates $x$ and $y$ of consecutive vertices of the island, in a clockwise order.\n\nThe $(n+2)$-nd line contains a single integer $m$ ($1 \\le m \\le 10\\ 000$), denoting thetotal number of factories.\n\nIn each of the following $m$ lines there are three integers $x_i'$, $y_i'$ and $w_i$ ($-10\\ 000 \\le x_i', y_i' \\le 10\\ 000$, $-100\\ 000 \\le w_i \\le 100\\ 000$), separated by single spaces, denoting: the coordinates $x$ and $y$ of the $i$-th factory and the gain (for $w_i \\ge 0$) or loss (for $w_i < 0$) this factory generates, respectively. Each factory is situated on the polygon-island i.e. within or on the border of it. Distinct factories may be located in the same place i.e. have the same coordinates.\n", "outputFormat": "The first and only line of the output file should contain a single integer denoting the maximal value of sum of all gains and losses generated by factories within a triangle whose vertices are three different vertices of the polygon-island. Notice that it may happen that the outcome is a negative integer.\n", "hint": "the correct result is:\n\n![](https://cdn.luogu.com.cn/upload/pic/6970.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2006] NAJ-The Invasion", "background": "", "description": "And so it has come — the Triangles have invaded Byteotia.\n\nByteotia lies on an island, occupying its entire surface. The shape of the island is a convex polygon (i.e., a polygon whose each interior angle is smaller than $180\\degree$).\n\nA certain number of software factories are located in Byteotia, each of which generates constant gains or losses.\n\nThe Triangles have decided to occupy such a part of Byteotia which:\n- is a triangle-shaped area whose vertices are three different vertices of the polygon island, and\n- brings the largest income, i.e., the sum of all gains and losses generated by factories within the occupied area is maximal.\n\nWe assume that a factory located on the border or at a vertex of the occupied area belongs to that area. A territory which contains no factory obviously brings zero income.\n\nByteasar, the King of Byteotia, is concerned about the amount of losses the Triangles' invasion could generate. Help him by writing a program that calculates the sum of gains and losses generated by the factories which the Triangles wish to capture.\n\nTask. Write a program that:\n- reads a description of Byteotia's shape and the locations of factories from the input,\n- determines the maximal sum of gains and losses generated by factories within a triangle whose vertices are three different vertices of the polygon island,\n- writes the result to the output.\n\nGiven a convex hull, and a number of resources (factories) inside or on its boundary, each with a weight, choose three different vertices on the convex hull to form a triangle such that the sum of the weights of the resources strictly inside or on the boundary of the triangle is maximized.\n\nThe number of convex hull vertices $n \\le 600$.\n\nThe number of resources $m \\le 10000$.", "inputFormat": "The first line contains a single integer $n$ ($3 \\le n \\le 600$), denoting the number of vertices of the polygon island.\n\nEach of the following $n$ lines contains two integers $x_j$ and $y_j$ ($-10\\ 000 \\le x_j, y_j \\le 10\\ 000$), separated by a single space, denoting the coordinates $x$ and $y$ of consecutive vertices of the island, in clockwise order.\n\nThe $(n+2)$-nd line contains a single integer $m$ ($1 \\le m \\le 10\\ 000$), denoting the total number of factories.\n\nEach of the following $m$ lines contains three integers $x_i'$, $y_i'$ and $w_i$ ($-10\\ 000 \\le x_i', y_i' \\le 10\\ 000$, $-100\\ 000 \\le w_i \\le 100\\ 000$), separated by single spaces, denoting the coordinates $x$ and $y$ of the $i$-th factory and the gain (for $w_i \\ge 0$) or loss (for $w_i < 0$) this factory generates, respectively. Each factory is situated on the polygon island, i.e., within it or on its border. Distinct factories may be located in the same place, i.e., have the same coordinates.", "outputFormat": "The first and only line should contain a single integer denoting the maximal sum of gains and losses generated by factories within a triangle whose vertices are three different vertices of the polygon island. Notice that it may happen that the outcome is a negative integer.", "hint": "The correct result is:\n\n![](https://cdn.luogu.com.cn/upload/pic/6970.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2006] NAJ-The Invasion", "background": "", "description": "And so it has come - the Triangles have invaded Byteotia!\n\nByteotia lies on an island, occupying its entire surface.\n\nThe shape of the island is a convex polygon(i.e. a polygon whose each inner angle is smaller than $180\\degree$).\n\nA certain number of software factories are located in Byteotia, each of which generates constant gains or losses.\n\nThe Triangles have decided to occupy such a part of Byteotia which:\n\nis a triangle-shaped area, the vertices of which are three different vertices of the polygon-island,     brings the largest income i.e. the sum of all gains and losses generated by factories within the occupied area is maximal.\n\nWe assume that a factory located on the border or in the vertex of occupied area belongs to that area. A territory which contains no factory brings, obviously, a zero income.\n\nByteasar, the King of Byteotia, is concerned by the amount of losses the Triangles' invasion could generate. Help him by writing a programme which shall calculate the sum of gains and losses generated by factories which the Triangles wish to capture.\n\nTaskWrite a programme which:\n\nreads a decription of Byteotia's shape and the locations of factories from the input file,     determines the maximal value of sum of all gains and losses generated by factories within a triangle, whose vertices are three different vertices of the polygon island,     writes the outcome to the output file.\n\n给定一个凸包， 并给出凸包内部或边上的若干个资源，每个资源都有权值,现在要在凸包上面选择不同的3个点，使得3个点组成的三角形\n内部的资源的权值之和最大。\n\n\n凸包点个数 $n \\le 600$\n\n\n资源个数 $m \\le 10000$\n", "inputFormat": "The first line of the input file contains a single integer $n$ ($3 \\le n \\le 600$), denoting the number of vertices of the polygon-island.\n\nThe following $n$ lines of the input contain two integers each $x_j$ and $y_j$ ($-10\\ 000 \\le x_j, y_j \\le 10\\ 000$), separated by a single space, denoting the coordinates $x$ and $y$ of consecutive vertices of the island, in a clockwise order.\n\nThe $(n+2)$-nd line contains a single integer $m$ ($1 \\le m \\le 10\\ 000$), denoting thetotal number of factories.\n\nIn each of the following $m$ lines there are three integers $x_i'$, $y_i'$ and $w_i$ ($-10\\ 000 \\le x_i', y_i' \\le 10\\ 000$, $-100\\ 000 \\le w_i \\le 100\\ 000$), separated by single spaces, denoting: the coordinates $x$ and $y$ of the $i$-th factory and the gain (for $w_i \\ge 0$) or loss (for $w_i < 0$) this factory generates, respectively. Each factory is situated on the polygon-island i.e. within or on the border of it. Distinct factories may be located in the same place i.e. have the same coordinates.\n", "outputFormat": "The first and only line of the output file should contain a single integer denoting the maximal value of sum of all gains and losses generated by factories within a triangle whose vertices are three different vertices of the polygon-island. Notice that it may happen that the outcome is a negative integer.\n", "hint": "the correct result is:\n\n![](https://cdn.luogu.com.cn/upload/pic/6970.png)\n", "locale": "zh-CN"}}}
{"pid": "P3443", "type": "P", "difficulty": 6, "samples": [["6 10\n1 5\n1 3\n4 1\n6 4\n3 6\n3 4\n4 3\n5 6\n6 2\n2 1\n4\n3 1 5 6\n3 3 4 3\n4 4 3 6 4\n3 5 6 2", "TAK\n1\n3\n4\n3\n6\n4\n1\n5\n6\n2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2006", "POI（波兰）", "Special Judge", "欧拉回路"], "title": "[POI 2006] LIS-The Postman", "background": "", "description": "每天早上，忙碌的邮递员需要经过城市的所有街道，完成投递邮件的任务。城市内的所有道路都是单向的，并通过一些路口连接起来。两个路口 $u,v$ 最多只有两条道路直接相连：一条 $u \\to v$，一条 $v \\to u$（也即不存在两条 $u \\to v$ 的街道）。所有路口从 $1$ 到 $n$ 编号。\n\n在路口 $1$，邮递员可以开始他的行程，或是结束他的行程。很长的一段时间里，邮递员可以随意选择他的路线，但最近新出的一条规定打乱了他的计划：每个邮递员得到了若干组路口序列，现在邮递员的路线必须满足如下要求：\n\n- 路线必须从路口 $1$ 开始，在路口 $1$ 结束。\n- 路线必须经过每条街道**恰好**一次。\n- 规定的每个路口序列都必须在路线中**连续**出现。例如：`1 2 1` 这个序列在 `1 2 1 3` 中出现了，而在 `1 2 3 1` 中没有出现（不是连续的）。\n\n现在邮递员找到了你，希望你能告诉他是否存在满足上述条件的路线，如果有的话，也请告诉他一条满足要求的路线。", "inputFormat": "输入第一行两个整数 $n,m$，分别为路口数和街道数。\n\n接下来 $m$ 行，每行两个整数 $a,b$，表示存在一条 $a \\to b$ 的街道。保证相同的街道不会重复给出，也不会有自环。\n\n下一行一个整数 $t$，代表规定的路口序列数。\n\n接下来 $t$ 行，每行第一个整数 $k$，接下来 $k$ 个数，代表一个规定的路口序列。", "outputFormat": "如果存在一个满足条件的路线，输出 `TAK`，否则输出 `NIE`。\n\n如果答案是 `TAK` 的话，请在接下来每行输出一个整数，代表一个满足条件的路线。\n\n设你输出了 $m+1$ 个数，输出的第 $i$ 个数为 $v_i$，你的输出需要满足如下条件：\n\n- $v_1=v_{m+1}=1$。\n- $\\forall 1 \\leq i \\leq m$，都存在 $v_i$ 到 $v_{i+1}$ 的街道。\n- 城市中的每条街道**恰好**出现一次。\n- 规定的每个路口序列都必须在路线中**连续**出现。", "hint": "所有数据均满足：$2 \\leq n \\leq 5 \\times 10^4$，$1 \\leq m \\leq 2 \\times 10^5$，$1 \\leq a,b \\leq n$，$a \\neq b$，$0 \\leq t \\leq 10^4$，$2 \\leq k \\leq 10^5$，$\\sum k \\leq 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2006] LIS-The Postman", "background": "", "description": "Every morning, a busy postman needs to traverse all the city’s streets to deliver mail. All roads in the city are one-way and connected by intersections. For any two intersections $u, v$, there are at most two streets directly between them: one $u \\to v$ and one $v \\to u$ (i.e., there are no two $u \\to v$ streets). All intersections are numbered from $1$ to $n$.\n\nAt intersection $1$, the postman may start his trip or end his trip. For a long time, the postman could freely choose his route, but a new regulation has disrupted his plan: each postman has been given several sequences of intersections, and now his route must satisfy the following requirements:\n\n- The route must start at intersection $1$ and end at intersection $1$.\n- The route must traverse each street exactly once.\n- Each prescribed sequence of intersections must appear contiguously in the route. For example: the sequence `1 2 1` appears in `1 2 1 3`, but does not appear in `1 2 3 1` (not contiguous).\n\nThe postman asks you to determine whether there exists a route that satisfies the above conditions; if so, also provide one such route.", "inputFormat": "The first line contains two integers $n, m$, the number of intersections and the number of streets.\n\nThe next $m$ lines each contain two integers $a, b$, indicating there is a street $a \\to b$. It is guaranteed that identical streets are not repeated and there are no self-loops.\n\nThe next line contains an integer $t$, the number of prescribed intersection sequences.\n\nThe next $t$ lines each describe one prescribed sequence: the first integer is $k$, followed by $k$ integers giving the sequence.", "outputFormat": "If there exists a route that satisfies the conditions, output `TAK`; otherwise, output `NIE`.\n\nIf the answer is `TAK`, then output the route in the following lines, one integer per line.\n\nSuppose you output $m+1$ integers, where the $i$-th printed integer is $v_i$. Your output must satisfy the following conditions:\n\n- $v_1 = v_{m+1} = 1$.\n- For all $1 \\leq i \\leq m$, there exists a street from $v_i$ to $v_{i+1}$.\n- Each street in the city is used exactly once.\n- Each prescribed intersection sequence appears contiguously in the route.", "hint": "Constraints: $2 \\leq n \\leq 5 \\times 10^4$, $1 \\leq m \\leq 2 \\times 10^5$, $1 \\leq a, b \\leq n$, $a \\neq b$, $0 \\leq t \\leq 10^4$, $2 \\leq k \\leq 10^5$, $\\sum k \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2006] LIS-The Postman", "background": "", "description": "每天早上，忙碌的邮递员需要经过城市的所有街道，完成投递邮件的任务。城市内的所有道路都是单向的，并通过一些路口连接起来。两个路口 $u,v$ 最多只有两条道路直接相连：一条 $u \\to v$，一条 $v \\to u$（也即不存在两条 $u \\to v$ 的街道）。所有路口从 $1$ 到 $n$ 编号。\n\n在路口 $1$，邮递员可以开始他的行程，或是结束他的行程。很长的一段时间里，邮递员可以随意选择他的路线，但最近新出的一条规定打乱了他的计划：每个邮递员得到了若干组路口序列，现在邮递员的路线必须满足如下要求：\n\n- 路线必须从路口 $1$ 开始，在路口 $1$ 结束。\n- 路线必须经过每条街道**恰好**一次。\n- 规定的每个路口序列都必须在路线中**连续**出现。例如：`1 2 1` 这个序列在 `1 2 1 3` 中出现了，而在 `1 2 3 1` 中没有出现（不是连续的）。\n\n现在邮递员找到了你，希望你能告诉他是否存在满足上述条件的路线，如果有的话，也请告诉他一条满足要求的路线。", "inputFormat": "输入第一行两个整数 $n,m$，分别为路口数和街道数。\n\n接下来 $m$ 行，每行两个整数 $a,b$，表示存在一条 $a \\to b$ 的街道。保证相同的街道不会重复给出，也不会有自环。\n\n下一行一个整数 $t$，代表规定的路口序列数。\n\n接下来 $t$ 行，每行第一个整数 $k$，接下来 $k$ 个数，代表一个规定的路口序列。", "outputFormat": "如果存在一个满足条件的路线，输出 `TAK`，否则输出 `NIE`。\n\n如果答案是 `TAK` 的话，请在接下来每行输出一个整数，代表一个满足条件的路线。\n\n设你输出了 $m+1$ 个数，输出的第 $i$ 个数为 $v_i$，你的输出需要满足如下条件：\n\n- $v_1=v_{m+1}=1$。\n- $\\forall 1 \\leq i \\leq m$，都存在 $v_i$ 到 $v_{i+1}$ 的街道。\n- 城市中的每条街道**恰好**出现一次。\n- 规定的每个路口序列都必须在路线中**连续**出现。", "hint": "所有数据均满足：$2 \\leq n \\leq 5 \\times 10^4$，$1 \\leq m \\leq 2 \\times 10^5$，$1 \\leq a,b \\leq n$，$a \\neq b$，$0 \\leq t \\leq 10^4$，$2 \\leq k \\leq 10^5$，$\\sum k \\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3444", "type": "P", "difficulty": 6, "samples": [["12 6 4\n6 0 4 8 0 5\n0 4 5 4 6 0\n0 5 6 5 6 0\n5 4 0 0 5 4", "8"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "POI（波兰）"], "title": "[POI 2006] ORK-Ploughing", "background": "", "description": "Byteasar, the farmer, wants to plough his rectangular field. He can begin with ploughing a slice from any of the field's edges, then he can plough a slice from any unploughed field's edges, and so on, until the whole field is ploughed. After the ploughing of every successive slice, the yet-unploughed field has a rectangular shape. Each slice has a span of $1$, and the length and width of the field are the integers $n$ and $m$.\n\nUnfortunately, Byteasar has only one puny and frail nag (horse) at his disposal for the ploughing. Once the nag starts to plough a slice, it won't stop until the slice is completely ploughed. However, if the slice is to much for the nag to bear, it will die of exhaustion, so Byteasar has to be careful. After every ploughed slice, the nag can rest and gather strength. The difficulty of certain parts of the field varies, but Byteasar is a good farmer and knows his field well, hence he knows every part's ploughing-difficulty.\n\nLet us divide the field into $m\\times n$ unitary squares - these are called tiles in short.\n\nWe identify them by their coordinates $(i,j)$, for $1\\le i\\le m$ and $1\\le j\\le n$.\n\nEach tile has its ploughing-difficulty - a non-negative integer.\n\nLet $t_{i,j}$ denote the difficulty of the tile which coordinates are $(i,j)$.\n\n\nFor every slice, the sum of ploughing-difficulties of the tiles forming it up cannot exceed a certain constant $k$ - lest the nag dies.\n\nA difficult task awaits Byteasar: before ploughing each subsequent slice he has to decide which edge of the field he'll plough, so that the nag won't die. On the other hand, he'd like to plough as few slices as possible.\n\nTaskWrite a programme that:\n\nreads the numbers $k$,$m$ and $n$ from the input file, as well as the ploughing-difficulty coefficients,     determines the best way to plough Byteasar's field,     writes the result to the output file.\n\nByteasar想耕种他那块矩形的田，他每次能耕种矩形的一边（上下左右都行），在他每次耕完后，剩下的田也一定是矩形，每块小区域边长为$1$，耕地的长宽分别为$m$和$n$，不幸的是Byteasar只有一匹老弱的马，从马开始耕地开始，只有当它耕完了一边才会停下休息。但有些地会非常难耕以至于马会非常的累，因此Byteasar需要特别小心。当耕完了一边之后，马可以停下来休息恢复体力。每块地耕种的难度不一，但是Byteasar都非常清楚。我们将地分成$m\\times n$块单位矩形——我们用坐标$(i,j)$来定义它们。每块地都有一个整数$t_{i,j}$,来定义$(i,j)$的耕种难度。所以每次马耕一边地时的难度就是所有它耕种的地的难度总和，对于这匹虚弱的马而言，这个值不能超过他的体力值。Byteasar想知道在马不死掉的情况下最少需要耕多少次才能把地耕完。\n", "inputFormat": "There are three positive integers in the first line of the input file: $k$,$m$ and $n$,separated by single spaces, $1\\le k\\le 200\\ 000\\ 000$,$1\\le m,n\\le 2000$.\n\nIn the following $n$ lines there are the ploughing-difficulty coefficients.\n\nThe line no. $j+1$ contains the coefficients $t_{1,j},t_{2,j}...,t_{n,m}$, separated by single spaces,$0\\le t_{i,j}\\le 100\\ 000$.\n", "outputFormat": "Your programme should write one integer to the output file: the minimum number of slices required to plough the field while satisfying the given conditions. Since we care for animals, we guarantee that the field can be ploughed according to the above rules. But remember, saving the nag is up to you!\n", "hint": "感谢@NaVi\\_Awson 提供翻译\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2006] ORK-Ploughing", "background": "", "description": "Byteasar, the farmer, wants to plough his rectangular field. He can begin by ploughing a slice from any of the field’s edges; then he can plough a slice from any edge of the remaining unploughed field, and so on, until the whole field is ploughed. After each slice is ploughed, the yet-unploughed field is still a rectangle. Each slice has a span of $1$, and the field is divided into $m\\times n$ unit tiles.\n\nWe identify the tiles by their coordinates $(i,j)$, for $1\\le i\\le m$ and $1\\le j\\le n$. Each tile has a non-negative ploughing-difficulty. Let $t_{i,j}$ denote the difficulty of the tile with coordinates $(i,j)$.\n\nByteasar has only one puny and frail nag (horse). Once the nag starts to plough a slice, it will not stop until the slice is completely ploughed. However, if the slice is too much for the nag to bear, it will die of exhaustion, so Byteasar has to be careful. After every ploughed slice, the nag can rest and gather strength. For every slice, the sum of ploughing-difficulties of the tiles forming it cannot exceed a certain constant $k$.\n\nDetermine the minimum number of slices required to plough the entire field without exceeding the limit $k$ on any slice. It is guaranteed that there exists a way to plough the field according to the above rules.", "inputFormat": "- The first line contains three positive integers $k$, $m$ and $n$, separated by single spaces, where $1\\le k\\le 200\\ 000\\ 000$ and $1\\le m,n\\le 2000$.\n- The next $m$ lines contain the ploughing-difficulty coefficients. Specifically, line $i+1$ ($1\\le i\\le m$) contains $n$ integers $t_{i,1}, t_{i,2}, \\ldots, t_{i,n}$, separated by single spaces, where $0\\le t_{i,j}\\le 100\\ 000$.", "outputFormat": "Output one integer: the minimum number of slices required to plough the field while satisfying the given conditions. It is guaranteed that a valid ploughing exists.", "hint": "Thanks to @NaVi_Awson for the translation.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2006] ORK-Ploughing", "background": "", "description": "Byteasar, the farmer, wants to plough his rectangular field. He can begin with ploughing a slice from any of the field's edges, then he can plough a slice from any unploughed field's edges, and so on, until the whole field is ploughed. After the ploughing of every successive slice, the yet-unploughed field has a rectangular shape. Each slice has a span of $1$, and the length and width of the field are the integers $n$ and $m$.\n\nUnfortunately, Byteasar has only one puny and frail nag (horse) at his disposal for the ploughing. Once the nag starts to plough a slice, it won't stop until the slice is completely ploughed. However, if the slice is to much for the nag to bear, it will die of exhaustion, so Byteasar has to be careful. After every ploughed slice, the nag can rest and gather strength. The difficulty of certain parts of the field varies, but Byteasar is a good farmer and knows his field well, hence he knows every part's ploughing-difficulty.\n\nLet us divide the field into $m\\times n$ unitary squares - these are called tiles in short.\n\nWe identify them by their coordinates $(i,j)$, for $1\\le i\\le m$ and $1\\le j\\le n$.\n\nEach tile has its ploughing-difficulty - a non-negative integer.\n\nLet $t_{i,j}$ denote the difficulty of the tile which coordinates are $(i,j)$.\n\n\nFor every slice, the sum of ploughing-difficulties of the tiles forming it up cannot exceed a certain constant $k$ - lest the nag dies.\n\nA difficult task awaits Byteasar: before ploughing each subsequent slice he has to decide which edge of the field he'll plough, so that the nag won't die. On the other hand, he'd like to plough as few slices as possible.\n\nTaskWrite a programme that:\n\nreads the numbers $k$,$m$ and $n$ from the input file, as well as the ploughing-difficulty coefficients,     determines the best way to plough Byteasar's field,     writes the result to the output file.\n\nByteasar想耕种他那块矩形的田，他每次能耕种矩形的一边（上下左右都行），在他每次耕完后，剩下的田也一定是矩形，每块小区域边长为$1$，耕地的长宽分别为$m$和$n$，不幸的是Byteasar只有一匹老弱的马，从马开始耕地开始，只有当它耕完了一边才会停下休息。但有些地会非常难耕以至于马会非常的累，因此Byteasar需要特别小心。当耕完了一边之后，马可以停下来休息恢复体力。每块地耕种的难度不一，但是Byteasar都非常清楚。我们将地分成$m\\times n$块单位矩形——我们用坐标$(i,j)$来定义它们。每块地都有一个整数$t_{i,j}$,来定义$(i,j)$的耕种难度。所以每次马耕一边地时的难度就是所有它耕种的地的难度总和，对于这匹虚弱的马而言，这个值不能超过他的体力值。Byteasar想知道在马不死掉的情况下最少需要耕多少次才能把地耕完。\n", "inputFormat": "There are three positive integers in the first line of the input file: $k$,$m$ and $n$,separated by single spaces, $1\\le k\\le 200\\ 000\\ 000$,$1\\le m,n\\le 2000$.\n\nIn the following $n$ lines there are the ploughing-difficulty coefficients.\n\nThe line no. $j+1$ contains the coefficients $t_{1,j},t_{2,j}...,t_{n,m}$, separated by single spaces,$0\\le t_{i,j}\\le 100\\ 000$.\n", "outputFormat": "Your programme should write one integer to the output file: the minimum number of slices required to plough the field while satisfying the given conditions. Since we care for animals, we guarantee that the field can be ploughed according to the above rules. But remember, saving the nag is up to you!\n", "hint": "感谢@NaVi\\_Awson 提供翻译\n", "locale": "zh-CN"}}}
{"pid": "P3445", "type": "P", "difficulty": 6, "samples": [["7 2 3", "420"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "POI（波兰）"], "title": "[POI 2006] TAN-Dancing in Circles", "background": null, "description": "幼儿园中有 $N$ 个小朋友在做游戏，每天小朋友们都会有一个尬舞方案（围成 $K$ 个圈尬舞）。\n\n每个圈子里至少有 $L$ 个小朋友，如果在一个方案里有一个小朋友他右面的小朋友和另一个方案里他右面的小朋友不同，那么两个尬舞方案就会被认为是不同的。\n\n你的任务是计算所有不同的尬舞方案的数量，因为结果可能比较大，所以最后输出答案 $d\\bmod 2005$ 的结果。\n\n如果没有符合要求的尬舞方案，输出 $0$。", "inputFormat": "只有一行输入，三个整数 $N,K,L$ （$3\\leq N\\leq 10^9; 1\\leq K\\leq N; 2\\leq L\\leq N$）分别代表小朋友数量，圈子数量，每个圈子里最少的小朋友数。", "outputFormat": "只有一行输出，即合理的尬舞方案数 $d\\bmod2005$。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[POI 2006] TAN-Dancing in Circles", "background": null, "description": "$n$ kids attend a certain kindergarten. Everyday the kids arrange themselves in $k$ circles and dance.\n\nAt least $l$ kids dance in each circle. Two arrangements of children are considered distinct if there is a child who has a different right neighbour in one of the arrangements than in the other.\n\nYour task is to calculate the number of all distinct arrangements modulo $2005$. Should there beno arrangements satisfying the aforementioned conditions, the correct outcome is $0$.\n\nWrite a programme which:\n\nreads the numbers $n$, $k$ and $l$ from the standard input, calculates the number $d'=d \\bmod 2005$, where $d$ denotes the number of distinct arrangements of the children (\"$d \\bmod 2005$\" denotes the remainder of the division of $d$ by $2005$), writes $d'$ to the standard output.", "inputFormat": "The first and only line of the standard input contains three integers separated by single spaces: $n$- the number of children ($3\\le n\\le 10^9$), $k$ - the number of circles ($1\\le k\\le n$) and $l$ - the minimal number of kids in a circle ($2\\le l\\le n$).", "outputFormat": "The first and only line of the standard output should contain a single integer: $d \\bmod2005$.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[POI 2006] TAN-Dancing in Circles", "background": null, "description": "幼儿园中有 $N$ 个小朋友在做游戏，每天小朋友们都会有一个尬舞方案（围成 $K$ 个圈尬舞）。\n\n每个圈子里至少有 $L$ 个小朋友，如果在一个方案里有一个小朋友他右面的小朋友和另一个方案里他右面的小朋友不同，那么两个尬舞方案就会被认为是不同的。\n\n你的任务是计算所有不同的尬舞方案的数量，因为结果可能比较大，所以最后输出答案 $d\\bmod 2005$ 的结果。\n\n如果没有符合要求的尬舞方案，输出 $0$。", "inputFormat": "只有一行输入，三个整数 $N,K,L$ （$3\\leq N\\leq 10^9; 1\\leq K\\leq N; 2\\leq L\\leq N$）分别代表小朋友数量，圈子数量，每个圈子里最少的小朋友数。", "outputFormat": "只有一行输出，即合理的尬舞方案数 $d\\bmod2005$。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3446", "type": "P", "difficulty": 6, "samples": [["6 4\n4 3 2 5", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "POI（波兰）"], "title": "[POI 2006] EST-Aesthetic Text", "background": "", "description": "Let us consider a text consisting of n words numbered from 1 to n. We represent any of its decompositions into k lines by a sequence of numbers (a\\_1,a\\_2...a\\_{k-1}), such that the words with numbers from 1 to a\\_1 are in the first line, the words with umbers from a\\_1 + 1 to a\\_2 are in the second line, and so on, and finally, the words with numbers from a\\_{k-1} + 1 to n are in the last, k-th line.\n\n\nEach word has a certain length (measured in the number of characters). Let length(x) denote the length of the word no. . Furthermore, every two subsequent words in a line are separated by a space of width of a single character. By length of the line we denote the sum of lengths of the words in this line, increased by the number of spaces between them. Let line(w) denote the length of the line no.w . I.e., if the line no.w contains the words with numbers from i to j inclusive, its length is:\n\n\n\n\n\n```cpp\nXXXX (1st line)\nXXX XX (2nd line)\nXXXXX (3rd line)\n```\n\nline(w)=length(i)+..length(j)+(j-i)\n\nAs an example, let us consider a text consisting of 4 words of lengths 4, 3, 2 and 5, respectively, and its decomposition (1,3) into 3 lines. Then the length of the first line is 4, second -6 , and third -5 :\n\nWe shall refer to the number\n\n\n|line(1)-line(2)|+...+|line(k-1)-line(k)|\n\nas the coefficient of aestheticism of a decomposition of the given text into k lines. Particularly, if the decomposition has only one line, its coefficient of aestheticism is 0.\n\n\nNeedles to say, the smaller the coefficient, the more aesthetical the decomposition. We shall consider only these decompositions that have no line whose length exceeds some constant m. Of all such decompositions of a given text into any number of lines we seek the one most aesthetical, i.e. the one with the smallest coefficient of aestheticism. The aforementioned examplary decomposition's coefficient is 3, and that is exactly the minimum coefficient of aestheticism for m=6 and m=7.\n", "inputFormat": "The first line of the standard input contains the numbers $m$ and $n$, $1\\le m\\le 1\\ 000\\ 000$,$1\\le n\\le 2\\ 000$, separated by a single space. The second, last line of the standard input contains $n$ integers, denotingthe lengths of subsequent words, $1\\le length(i)\\le m$ for $i=1,2,\\cdots,n$, separated by single spaces.\n", "outputFormat": "The first and only line of the standard output should contain exactly one integer: the minimumcoefficient of aestheticism for those decompositions, whose every line's length does not exceed $m$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2006] EST-Aesthetic Text", "background": "", "description": "Let us consider a text consisting of n words numbered from 1 to n. We represent any of its decompositions into k lines by a sequence of numbers (a\\_1,a\\_2...a\\_{k-1}), such that the words with numbers from 1 to a\\_1 are in the first line, the words with umbers from a\\_1 + 1 to a\\_2 are in the second line, and so on, and finally, the words with numbers from a\\_{k-1} + 1 to n are in the last, k-th line.\n\n\nEach word has a certain length (measured in the number of characters). Let length(x) denote the length of the word no. . Furthermore, every two subsequent words in a line are separated by a space of width of a single character. By length of the line we denote the sum of lengths of the words in this line, increased by the number of spaces between them. Let line(w) denote the length of the line no.w . I.e., if the line no.w contains the words with numbers from i to j inclusive, its length is:\n\n\n\n\n\n```cpp\nXXXX (1st line)\nXXX XX (2nd line)\nXXXXX (3rd line)\n```\n\nline(w)=length(i)+..length(j)+(j-i)\n\nAs an example, let us consider a text consisting of 4 words of lengths 4, 3, 2 and 5, respectively, and its decomposition (1,3) into 3 lines. Then the length of the first line is 4, second -6 , and third -5 :\n\nWe shall refer to the number\n\n\n|line(1)-line(2)|+...+|line(k-1)-line(k)|\n\nas the coefficient of aestheticism of a decomposition of the given text into k lines. Particularly, if the decomposition has only one line, its coefficient of aestheticism is 0.\n\n\nNeedles to say, the smaller the coefficient, the more aesthetical the decomposition. We shall consider only these decompositions that have no line whose length exceeds some constant m. Of all such decompositions of a given text into any number of lines we seek the one most aesthetical, i.e. the one with the smallest coefficient of aestheticism. The aforementioned examplary decomposition's coefficient is 3, and that is exactly the minimum coefficient of aestheticism for m=6 and m=7.\n", "inputFormat": "The first line of the standard input contains the numbers $m$ and $n$, $1\\le m\\le 1\\ 000\\ 000$,$1\\le n\\le 2\\ 000$, separated by a single space. The second, last line of the standard input contains $n$ integers, denotingthe lengths of subsequent words, $1\\le length(i)\\le m$ for $i=1,2,\\cdots,n$, separated by single spaces.\n", "outputFormat": "The first and only line of the standard output should contain exactly one integer: the minimumcoefficient of aestheticism for those decompositions, whose every line's length does not exceed $m$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2006] EST-Aesthetic Text", "background": "", "description": "让我们考虑一个由 $n$ 个单词组成的文本，这些单词从 1 到 $n$ 编号。我们用一个数列 $(a_1, a_2, \\ldots, a_{k-1})$ 来表示将其分解为 $k$ 行的任意方式，使得编号从 1 到 $a_1$ 的单词在第一行，编号从 $a_1 + 1$ 到 $a_2$ 的单词在第二行，依此类推，最后编号从 $a_{k-1} + 1$ 到 $n$ 的单词在最后一行，即第 $k$ 行。\n\n每个单词都有一定的长度（以字符数衡量）。令 $length(x)$ 表示第 $x$ 个单词的长度。此外，行中的每两个相邻单词之间用一个字符宽度的空格隔开。行的长度被定义为该行中单词长度的总和，加上它们之间的空格数。令 $line(w)$ 表示第 $w$ 行的长度。即，如果第 $w$ 行包含编号从 $i$ 到 $j$ 的单词（包括 $i$ 和 $j$），其长度为：\n\n```cpp\nXXXX (第 1 行)\nXXX XX (第 2 行)\nXXXXX (第 3 行)\n```\n\n$$line(w) = length(i) + \\ldots + length(j) + (j-i)$$\n\n例如，考虑一个由 4 个单词组成的文本，其长度分别为 4, 3, 2 和 5，以及将其分解为 3 行的方式 (1,3)。那么第一行的长度是 4，第二行是 6，第三行是 5：\n\n我们称数值\n\n$$|line(1) - line(2)| + \\ldots + |line(k-1) - line(k)|$$\n\n为将给定文本分解为 $k$ 行的美学系数。特别地，如果分解只有一行，其美学系数为 0。\n\n不言而喻，系数越小，分解越美观。我们只考虑那些没有行长度超过某个常数 $m$ 的分解。在所有这样的分解中，我们寻找最美观的，即美学系数最小的分解。上述示例分解的系数是 3，这正是 $m=6$ 和 $m=7$ 时美学系数的最小值。", "inputFormat": "标准输入的第一行包含两个数字 $m$ 和 $n$，$1 \\le m \\le 1\\ 000\\ 000$，$1 \\le n \\le 2\\ 000$，以单个空格分隔。标准输入的第二行（也是最后一行）包含 $n$ 个整数，表示后续单词的长度，$1 \\le length(i) \\le m$ 对于 $i=1,2,\\cdots,n$，以单个空格分隔。", "outputFormat": "标准输出的第一行且唯一一行应包含一个整数：对于那些每行长度不超过 $m$ 的分解，最小的美学系数。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3447", "type": "P", "difficulty": 6, "samples": [["3\n2 1 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "POI（波兰）"], "title": "[POI 2006] KRY-Crystals", "background": "", "description": "Byteman is a scientist who investigates creation of crystals consisting of atoms of different elements.\n\nHe has designed a special process for creating crystals and has discovered a formula specifying theamount of elements that can be used to create a crystal. Now, he wonders how many differentcrystals can be created in such process.\n\nFor non-negative integers $x$ and $y$, by $x\\bigoplus y$ we shall denote their bit-wise xor. The basic xor forsingle bits is defined by:\n\n$1\\bigoplus 1=0\\bigoplus 0=0$,$0\\bigoplus 1=1\\bigoplus 0=1$.\n\nByteman knows $n$ different elements that can be used to create crystals -these are numbered from $1$ to $n$. For each element $i$ there is an upper bound $m_i$ on number of atoms of this elementthat can be used to create a crystal. Byteman can create one unique crystal composed of $a_i$ atomsof the element $i$ (for $i=1,\\cdots,n$), if and only if:\n\n- $0\\le a_i\\le m_i$ for $i=1,\\cdots,n$\n\n- $a_1\\bigoplus\\cdots\\bigoplus a_n=0$, and\n\n- $a_1+a_2+\\cdots+a_n\\ge 1$.\n\nNote that the last condition is quite obvious and essentially states that every crystal is composed ofat least one atom.\n\nTaskWrite a programme which:\n\nreads form the standard input: the number of elements and the bounds on numbers of atoms    of particular elements,        computes the number of different crystals that can be created,        writes the result to the standard output.", "inputFormat": "The first line of the standard input contains the number of elements $n$, $1\\le n\\le 50$.\n\nThe second, last line of the standard input contains $n$ positive integers $m_1,\\cdots,m_n$, separated by single spaces,$1\\le m_i<2^{32}-1$.\n", "outputFormat": "Your programme should write one integer to the standard output - total number of different crystals  that can be created. You can assume that this number is less than $2^{64}$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2006] KRY-Crystals", "background": "", "description": "Byteman is a scientist who investigates creation of crystals consisting of atoms of different elements.\n\nHe has designed a special process for creating crystals and has discovered a formula specifying theamount of elements that can be used to create a crystal. Now, he wonders how many differentcrystals can be created in such process.\n\nFor non-negative integers $x$ and $y$, by $x\\bigoplus y$ we shall denote their bit-wise xor. The basic xor forsingle bits is defined by:\n\n$1\\bigoplus 1=0\\bigoplus 0=0$,$0\\bigoplus 1=1\\bigoplus 0=1$.\n\nByteman knows $n$ different elements that can be used to create crystals -these are numbered from $1$ to $n$. For each element $i$ there is an upper bound $m_i$ on number of atoms of this elementthat can be used to create a crystal. Byteman can create one unique crystal composed of $a_i$ atomsof the element $i$ (for $i=1,\\cdots,n$), if and only if:\n\n- $0\\le a_i\\le m_i$ for $i=1,\\cdots,n$\n\n- $a_1\\bigoplus\\cdots\\bigoplus a_n=0$, and\n\n- $a_1+a_2+\\cdots+a_n\\ge 1$.\n\nNote that the last condition is quite obvious and essentially states that every crystal is composed ofat least one atom.\n\nTaskWrite a programme which:\n\nreads form the standard input: the number of elements and the bounds on numbers of atoms    of particular elements,        computes the number of different crystals that can be created,        writes the result to the standard output.", "inputFormat": "The first line of the standard input contains the number of elements $n$, $1\\le n\\le 50$.\n\nThe second, last line of the standard input contains $n$ positive integers $m_1,\\cdots,m_n$, separated by single spaces,$1\\le m_i<2^{32}-1$.\n", "outputFormat": "Your programme should write one integer to the standard output - total number of different crystals  that can be created. You can assume that this number is less than $2^{64}$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2006] KRY-Crystals", "background": "", "description": "给定 $n$ 个正整数 $m_1$ 到 $m_n$，对长度为 $n$ 且满足以下条件的整数序列 $a$ 计数：\n- 对于任意 $1\\le i\\le n$，$0\\le a_i\\le m_i$；\n- $a_1\\oplus a_2\\oplus\\cdots\\oplus a_n=0$，其中 $\\oplus$ 为按位异或运算；\n- $a_1+a_2+\\cdots+a_n\\ge1$。", "inputFormat": "第一行有一个正整数 $n$。\n\n第二行有 $n$ 个正整数，表示 $m_1,m_2,\\ldots,m_n$。", "outputFormat": "输出一行一个正整数表示序列的个数。", "hint": "$1\\le n\\le50$。\n\n$1\\le m_i\\le2^{32}-1$。\n\n数据保证答案小于 $2^{64}$。\n\n感谢 @FZzzz @UnyieldingTrilobite 提供翻译。", "locale": "zh-CN"}}}
{"pid": "P3448", "type": "P", "difficulty": 4, "samples": [["0 1 2 1", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "POI（波兰）"], "title": "[POI 2006] MIS-Teddies", "background": "", "description": "Byteoian 是一家专业生产儿童玩具的公司。他们生产的玩具质量上乘，广受好评。\n\n但最近，有人发现他们生产的泰迪熊存在致命缺陷。总共有四种泰迪熊型号：$A1$，$A2$，$B1$，$B2$，一旦将三个字母相同或数字相同的泰迪熊放在一块，就会对泰迪熊造成致命损坏。\n\n如果一种摆放泰迪熊的方案中不存在连续三个字母相同或数字相同的泰迪熊，则称这种摆放方案是**安全的**。\n\n现在你收集了一些泰迪熊，你想要知道有多少种安全的摆放泰迪熊的方案。由于安全的方案可能较多，请输出方案数对 $1\\,000\\,000$ 取模的结果。", "inputFormat": "输入包含四个整数：$n_{A1},n_{A2},n_{B1},n_{B2}$，分别代表 $A1$ 型，$A2$ 型，$B1$ 型，$B2$ 型泰迪熊的数量。", "outputFormat": "输出一个整数，即安全摆放泰迪熊的方案数对 $1\\,000\\,000$ 取模的结果。", "hint": "$0 \\leq n_{A1},n_{A2},n_{B1},n_{B2} \\leq 38$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2006] MIS-Teddies", "background": "", "description": "Byteoian is a company specializing in children's toys. Their products are of high quality and well received.\n\nHowever, it was recently discovered that their teddy bears have a fatal flaw. There are four models of teddy bears: $A1$, $A2$, $B1$, $B2$. If three teddy bears with the same letter or the same digit are placed together, it will cause fatal damage.\n\nAn arrangement of teddy bears is called safe if there are no three consecutive teddy bears with the same letter or the same digit.\n\nYou have collected some teddy bears and want to know how many safe arrangements in a row of all these teddy bears exist. Since the number of safe arrangements can be large, output the result modulo $1\\,000\\,000$.", "inputFormat": "The input contains four integers: $n_{A1}, n_{A2}, n_{B1}, n_{B2}$, which denote the numbers of type $A1$, $A2$, $B1$, and $B2$ teddy bears, respectively.", "outputFormat": "Output a single integer, the number of safe arrangements modulo $1\\,000\\,000$.", "hint": "Constraints: $0 \\leq n_{A1}, n_{A2}, n_{B1}, n_{B2} \\leq 38$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2006] MIS-Teddies", "background": "", "description": "Byteoian 是一家专业生产儿童玩具的公司。他们生产的玩具质量上乘，广受好评。\n\n但最近，有人发现他们生产的泰迪熊存在致命缺陷。总共有四种泰迪熊型号：$A1$，$A2$，$B1$，$B2$，一旦将三个字母相同或数字相同的泰迪熊放在一块，就会对泰迪熊造成致命损坏。\n\n如果一种摆放泰迪熊的方案中不存在连续三个字母相同或数字相同的泰迪熊，则称这种摆放方案是**安全的**。\n\n现在你收集了一些泰迪熊，你想要知道有多少种安全的摆放泰迪熊的方案。由于安全的方案可能较多，请输出方案数对 $1\\,000\\,000$ 取模的结果。", "inputFormat": "输入包含四个整数：$n_{A1},n_{A2},n_{B1},n_{B2}$，分别代表 $A1$ 型，$A2$ 型，$B1$ 型，$B2$ 型泰迪熊的数量。", "outputFormat": "输出一个整数，即安全摆放泰迪熊的方案数对 $1\\,000\\,000$ 取模的结果。", "hint": "$0 \\leq n_{A1},n_{A2},n_{B1},n_{B2} \\leq 38$。", "locale": "zh-CN"}}}
{"pid": "P3449", "type": "P", "difficulty": 6, "samples": [["6\n2 aa\n3 aba\n3 aaa\n6 abaaba\n5 aaaaa\n4 abba", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2006", "POI（波兰）", "哈希 hashing", "字典树 Trie"], "title": "[POI 2006] PAL-Palindromes", "background": "", "description": "Little Johnny enjoys playing with words. He has chosen $n$ palindromes (a palindrome is a wordthat reads the same when the letters composing it are taken in the reverse order, such as dad, eye orracecar for instance) then generated all $n^2$ possible pairs of them and concatenated the pairs intosingle words. Lastly, he counted how many of the so generated words are palindromes themselves.\n\nHowever, Johnny cannot be certain of not having comitted a mistake, so he has asked you to repeatthe very same actions and to give him the outcome. Write a programme which shall perform thistask for you.\n\nTaskWrite a programme which:\n\nreads the palindromes given by Johnny from the standard input,        determines the number of words formed out of pairs of palindromes from the input, which are palindromes    themselves,        writes the outcome to the standard output.\n", "inputFormat": "The first line of the standard input contains a single integer $n$, $n\\ge 2$, denoting the number ofpalindromes given by Johnny. The following $n$ lines contain a description of the palindromes. The $(i+1)$'st line contains a single positive integer $a_i$ denoting the length of $i$'th palindrome and apalindrome of $a_i$ small letters of English alphabet. The number $a_i$ is separated from the palindromeby a single space. The palindromes in distinct lines are distinct. The total length of all palindromesdoes not exceed $2\\ 000\\ 000$.\n", "outputFormat": "The first and only line of the standard output should contain a single integer: the number of distinctordered pairs of palindromes which form a palindrome upon being concatenated.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2006] PAL-Palindromes", "background": "", "description": "Little Johnny enjoys playing with words. He has chosen $n$ palindromes (a palindrome is a wordthat reads the same when the letters composing it are taken in the reverse order, such as dad, eye orracecar for instance) then generated all $n^2$ possible pairs of them and concatenated the pairs intosingle words. Lastly, he counted how many of the so generated words are palindromes themselves.\n\nHowever, Johnny cannot be certain of not having comitted a mistake, so he has asked you to repeatthe very same actions and to give him the outcome. Write a programme which shall perform thistask for you.\n\nTaskWrite a programme which:\n\nreads the palindromes given by Johnny from the standard input,        determines the number of words formed out of pairs of palindromes from the input, which are palindromes    themselves,        writes the outcome to the standard output.\n", "inputFormat": "The first line of the standard input contains a single integer $n$, $n\\ge 2$, denoting the number ofpalindromes given by Johnny. The following $n$ lines contain a description of the palindromes. The $(i+1)$'st line contains a single positive integer $a_i$ denoting the length of $i$'th palindrome and apalindrome of $a_i$ small letters of English alphabet. The number $a_i$ is separated from the palindromeby a single space. The palindromes in distinct lines are distinct. The total length of all palindromesdoes not exceed $2\\ 000\\ 000$.\n", "outputFormat": "The first and only line of the standard output should contain a single integer: the number of distinctordered pairs of palindromes which form a palindrome upon being concatenated.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2006] PAL-Palindromes", "background": null, "description": "Johnny 喜欢玩文字游戏。\n\n他写下了 $n$ 个回文串，随后将这些串两两组合，合并成一个新串。容易看出，一共会有 $n^2$ 个新串。\n\n两个串组合时顺序是任意的，即 `a` 和 `b` 可以组合成 `ab` 和 `ba`，另外自己和自己组合也是允许的。\n\n现在他想知道这些新串中有多少个回文串，你能帮帮他吗？", "inputFormat": "第一行一个整数 $n$，保证 $n \\ge 2$。\n\n接下来 $n$ 行，第 $i$ 行包含一个数 $a_i$ 和一个长度为 $a_i$ 的回文串。\n\n保证所有串只包含小写字母，且所有串两两不同，所有回文串的长度和不超过 $2 \\times 10^6$。", "outputFormat": "输出一个整数，代表满足条件的新串的数量。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3450", "type": "P", "difficulty": 6, "samples": [["9 4\n12\n9 6\n4 6\n7 9\n1 2\n2 1\n9 7\n7 6\n4 5\n7 8\n8 9\n3 4\n4 3", "5\n1 3 5 6 8"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2006", "POI（波兰）", "Special Judge"], "title": "[POI 2006] ZOS-Sophie", "background": null, "description": "Little Sophie gives a birthday party. She has written a tentative list of her kindergarten friendsshe would like to invite. However, kids are very demanding guests. Mary said she should come, butonly provided Camille and Emily are not present, for they took her doll last week. Little Christopheronly plays with Sophie and Camille and he does not wish to see any other kids at the party. And soon...\n\nSophie considers a party a success if none of the guests invited has objection against any other'spresence. She has decided not to invite certain kids to assure that the party is a success. On theother hand she would like to invite as many kids as possible. Should Sophie not be able to invite atleast $k$ kids she won't give any party at all.\n\n## Task\n\nHelp little Sophie! Write a programme which:\n\n- reads the number of all Sophie's acquaintances $n$, the number $k$ and a description of kids' demands from the standard input,\n\n- verifies if it is possible to invite at least $k$ kids so that the party could be a success,\n\n- if it is not possible, writes the word NIE (i.e. no in Polish)  to the standard output; if it is possible, finds the largest group of kids who could be invited to the party so that it is a success and  writes it to the standard output.", "inputFormat": "The first line of the standard input contains two positive integers separated by a single space:\n\n$n$ - the number of all Sophie's acquaintances ($2 \\le n \\le 1000\\ 000$) and $k$ -the minimal number of kids Sophie wishes to invite to the party($n-10 \\le k < n$). The kids are assigned numbers from therange $1$ to $n$.\n\nThe following lines contain a description of kids' demands. In the second line there is a singleinteger $m$, $1 \\le m \\le 3\\ 000\\ 000$\n\nEach of the following $m$ lines contains a pair of integers $a$, $b$, separated by a single space ($1 \\le a,b, \\le n, a \\neq b$). You can assume that each (ordered) pair appears in the standard input once at the most. The pair $a$, $b$ denotes that the child $a$ does not wish to meet child $b$ at the party.", "outputFormat": "If it is not possible to invite $k$ kids to the party so that it is a success then the first and only line ofthe standard output should contain a single word: NIE.\n\nIf it is possible, then the first line of the standard input should contain a single integer - themaximal number of kids that can be invited to the party so that it is a success.\n\nThe second line of the standard output should contain the numbers of kids to be invited, separated by single spaces, inincreasing order. Should there be more correct answers your programme should write out any oneof them.", "hint": null, "locale": "en", "translations": {"en": {"title": "[POI 2006] ZOS-Sophie", "background": null, "description": "Little Sophie gives a birthday party. She has written a tentative list of her kindergarten friendsshe would like to invite. However, kids are very demanding guests. Mary said she should come, butonly provided Camille and Emily are not present, for they took her doll last week. Little Christopheronly plays with Sophie and Camille and he does not wish to see any other kids at the party. And soon...\n\nSophie considers a party a success if none of the guests invited has objection against any other'spresence. She has decided not to invite certain kids to assure that the party is a success. On theother hand she would like to invite as many kids as possible. Should Sophie not be able to invite atleast $k$ kids she won't give any party at all.\n\n## Task\n\nHelp little Sophie! Write a programme which:\n\n- reads the number of all Sophie's acquaintances $n$, the number $k$ and a description of kids' demands from the standard input,\n\n- verifies if it is possible to invite at least $k$ kids so that the party could be a success,\n\n- if it is not possible, writes the word NIE (i.e. no in Polish)  to the standard output; if it is possible, finds the largest group of kids who could be invited to the party so that it is a success and  writes it to the standard output.", "inputFormat": "The first line of the standard input contains two positive integers separated by a single space:\n\n$n$ - the number of all Sophie's acquaintances ($2 \\le n \\le 1000\\ 000$) and $k$ -the minimal number of kids Sophie wishes to invite to the party($n-10 \\le k < n$). The kids are assigned numbers from therange $1$ to $n$.\n\nThe following lines contain a description of kids' demands. In the second line there is a singleinteger $m$, $1 \\le m \\le 3\\ 000\\ 000$\n\nEach of the following $m$ lines contains a pair of integers $a$, $b$, separated by a single space ($1 \\le a,b, \\le n, a \\neq b$). You can assume that each (ordered) pair appears in the standard input once at the most. The pair $a$, $b$ denotes that the child $a$ does not wish to meet child $b$ at the party.", "outputFormat": "If it is not possible to invite $k$ kids to the party so that it is a success then the first and only line ofthe standard output should contain a single word: NIE.\n\nIf it is possible, then the first line of the standard input should contain a single integer - themaximal number of kids that can be invited to the party so that it is a success.\n\nThe second line of the standard output should contain the numbers of kids to be invited, separated by single spaces, inincreasing order. Should there be more correct answers your programme should write out any oneof them.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[POI 2006] ZOS-Sophie", "background": null, "description": "小 Sophie 要举办生日派对。她列了一个想邀请的幼儿园朋友名单。然而，孩子们是非常挑剔的客人。Mary 说她应该来，但前提是 Camille 和 Emily 不在场，因为她们上周拿走了她的娃娃。小 Christopher 只和 Sophie 以及 Camille 玩，他不希望在派对上看到其他孩子。类似的情况还有很多……\n\nSophie 认为，如果邀请的客人中没有人对其他人的到场有异议，那么派对就是成功的。她决定不邀请某些孩子，以确保派对成功。另一方面，她希望尽可能多地邀请孩子。如果 Sophie 无法邀请至少 $k$ 个孩子，她将不会举办任何派对。\n\n### 任务\n\n帮助小 Sophie！编写一个程序，完成以下任务：\n\n- 从标准输入中读取 Sophie 所有熟人的数量 $n$、数字 $k$ 以及孩子们的要求描述；\n- 验证是否可以邀请至少 $k$ 个孩子，使得派对能够成功；\n- 如果不可能，向标准输出写入单词 NIE（波兰语中的“不”）；如果可能，则找到可以邀请的最大孩子群体，使得派对成功，并将结果写入标准输出。", "inputFormat": "标准输入的第一行包含两个用单个空格分隔的正整数：\n\n$n$ —— Sophie 所有熟人的数量（$2 \\le n \\le 1000\\ 000$），以及 $k$ —— Sophie 希望邀请到派对的最小孩子数量（$n-10 \\le k < n$）。孩子们被分配了从 $1$ 到 $n$ 的编号。\n\n接下来的几行包含孩子们的要求描述。第二行是一个整数 $m$，$1 \\le m \\le 3\\ 000\\ 000$。\n\n接下来的 $m$ 行中，每行包含一对用单个空格分隔的整数 $a$, $b$（$1 \\le a,b \\le n$, $a \\neq b$）。可以假设每对（有序）在标准输入中最多出现一次。这对数字 $a$, $b$ 表示孩子 $a$ 不希望与孩子 $b$ 在派对上见面。", "outputFormat": "如果无法邀请 $k$ 个孩子使得派对成功，则标准输出的第一行且唯一一行应包含一个单词：NIE。\n\n如果可能，则标准输出的第一行应包含一个整数 —— 可以邀请的最大孩子数量，使得派对成功。\n\n标准输出的第二行应包含被邀请孩子的编号，用单个空格分隔，按递增顺序排列。如果有多个正确答案，程序可以输出其中任意一个。", "hint": null, "locale": "zh-CN"}}}
