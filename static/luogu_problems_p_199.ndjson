{"pid": "P5026", "type": "P", "difficulty": 4, "samples": [["1 10\n1 5", "0 0 1 0 -1 0 1 0 0 0 "], ["2 10\n2 6\n3 1", "-2 0 0 0 0 0 2 2 2 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "差分"], "title": "Lycanthropy", "background": "小正方形亲眼看见了自己昔日的朋友被卷进了黑暗的深渊，然而它无力阻止……\n\n现在它的朋友已经向它发起了攻击，因此小正方形不得不抵抗。", "description": "我们把山顶上的湖泊看作一条长度为 $m$ 的直线，一开始水深都在水平线上，我们视作此时的水深为 '0'\n\n接下来，在一瞬间，小正方形的\"朋友\"们跳起并扎入水中，导致在入水点的水降低而远离入水点的水升高，注意两个 \"朋友\" 可能在同一地点入水。\n\n小正方形的每个朋友有一个体积数值 $v$，当体积为 $v$ 的一个朋友跳入水中，我们设入水点为 $i$，将会导致 $i - v + 1$ 到 $i$ 的水位依次降低 $1,2,\\cdots,v$\n\n同样地，第 $i$ 到 $i + v - 1$ 的水位会依次降低 $v,v - 1,\\cdots,1$.\n\n相对应地，$i - v$ 的水位不变， $i - v - 1$ 到 $i - 2 * v$ 水位依次增加 $1,2,\\cdots,v$， $i - 2 * v$ 到 $i - 3 * v + 1$ 水位依次增加 $v,v - 1,\\cdots,1$\n\n同样，$i + v$ 水位不变，$i + v + 1$ 到 $i + 2 * v$ 水位增加 $1,2,\\cdots,v$，$i + 2 * v$ 到 $i + 3 * v - 1$ 水位依次增加 $v,v - 1,\\cdots,1$\n\n现在小正方形想要穿过这个湖，他想要知道在这 $n$ 个\"朋友\"跳入水中后湖上每个节点的水位，你能帮帮它吗？", "inputFormat": "第一行为两个整数 $n$,$m$，表示\"朋友\"的数目与湖泊的宽度。\n\n接下来 $n$ 行，一行两个整数 $v,x$，表示第 $i + 1$ 个朋友的体积与入水点。", "outputFormat": "一行 $m$ 个整数，第 $i$ 个整数表示 $i$ 号位的水深。", "hint": "对于 $30\\%$ 的数据，$n <= 50,m <= 500$\n\n对于 $70\\%$ 的数据，$n <= 10^5,m <= 10^5$\n\n对于 $100\\%$ 的数据，$n <= 10^6,m <= 10^6,1 <= v <= 10000,1 <= x <= m$", "locale": "zh-CN", "translations": {"en": {"title": "Lycanthropy", "background": "The little square saw with its own eyes that its former friend was swept into a dark abyss, yet it was powerless to stop it……\n\nNow its friend has attacked it, so the little square has no choice but to fight back.", "description": "We treat the lake on the mountaintop as a straight line of length $m$. At the beginning, the water depth everywhere is on the baseline, and we regard the water depth at this time as '0'.\n\nNext, in an instant, the little square’s \"friends\" jump up and dive into the water, causing the water level at the entry point to drop and the water level far away from the entry point to rise. Note that two \"friends\" may enter the water at the same position.\n\nEach friend of the little square has a volume value $v$. When a friend with volume $v$ jumps into the water, let the entry point be $i$. This will cause the water levels from $i - v + 1$ to $i$ to decrease by $1,2,\\cdots,v$ respectively.\n\nSimilarly, the water levels from $i$ to $i + v - 1$ will decrease by $v,v - 1,\\cdots,1$ respectively.\n\nCorrespondingly, the water level at $i - v$ does not change. The water levels from $i - v - 1$ to $i - 2 * v$ increase by $1,2,\\cdots,v$ respectively, and the water levels from $i - 2 * v$ to $i - 3 * v + 1$ increase by $v,v - 1,\\cdots,1$ respectively.\n\nSimilarly, the water level at $i + v$ does not change. The water levels from $i + v + 1$ to $i + 2 * v$ increase by $1,2,\\cdots,v$ respectively, and the water levels from $i + 2 * v$ to $i + 3 * v - 1$ increase by $v,v - 1,\\cdots,1$ respectively.\n\nNow the little square wants to cross this lake. It wants to know the water level at each position of the lake after these $n$ \"friends\" have jumped into the water. Can you help it?", "inputFormat": "The first line contains two integers $n$, $m$, representing the number of \"friends\" and the width of the lake.\n\nThe next $n$ lines each contain two integers $v,x$, representing the volume and the entry point of the $(i + 1)$-th friend.", "outputFormat": "Output one line with $m$ integers. The $i$-th integer represents the water depth at position $i$.", "hint": "For $30\\%$ of the testdata, $n <= 50, m <= 500$.\n\nFor $70\\%$ of the testdata, $n <= 10^5, m <= 10^5$.\n\nFor $100\\%$ of the testdata, $n <= 10^6, m <= 10^6, 1 <= v <= 10000, 1 <= x <= m$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Lycanthropy", "background": "小正方形亲眼看见了自己昔日的朋友被卷进了黑暗的深渊，然而它无力阻止……\n\n现在它的朋友已经向它发起了攻击，因此小正方形不得不抵抗。", "description": "我们把山顶上的湖泊看作一条长度为 $m$ 的直线，一开始水深都在水平线上，我们视作此时的水深为 '0'\n\n接下来，在一瞬间，小正方形的\"朋友\"们跳起并扎入水中，导致在入水点的水降低而远离入水点的水升高，注意两个 \"朋友\" 可能在同一地点入水。\n\n小正方形的每个朋友有一个体积数值 $v$，当体积为 $v$ 的一个朋友跳入水中，我们设入水点为 $i$，将会导致 $i - v + 1$ 到 $i$ 的水位依次降低 $1,2,\\cdots,v$\n\n同样地，第 $i$ 到 $i + v - 1$ 的水位会依次降低 $v,v - 1,\\cdots,1$.\n\n相对应地，$i - v$ 的水位不变， $i - v - 1$ 到 $i - 2 * v$ 水位依次增加 $1,2,\\cdots,v$， $i - 2 * v$ 到 $i - 3 * v + 1$ 水位依次增加 $v,v - 1,\\cdots,1$\n\n同样，$i + v$ 水位不变，$i + v + 1$ 到 $i + 2 * v$ 水位增加 $1,2,\\cdots,v$，$i + 2 * v$ 到 $i + 3 * v - 1$ 水位依次增加 $v,v - 1,\\cdots,1$\n\n现在小正方形想要穿过这个湖，他想要知道在这 $n$ 个\"朋友\"跳入水中后湖上每个节点的水位，你能帮帮它吗？", "inputFormat": "第一行为两个整数 $n$,$m$，表示\"朋友\"的数目与湖泊的宽度。\n\n接下来 $n$ 行，一行两个整数 $v,x$，表示第 $i + 1$ 个朋友的体积与入水点。", "outputFormat": "一行 $m$ 个整数，第 $i$ 个整数表示 $i$ 号位的水深。", "hint": "对于 $30\\%$ 的数据，$n <= 50,m <= 500$\n\n对于 $70\\%$ 的数据，$n <= 10^5,m <= 10^5$\n\n对于 $100\\%$ 的数据，$n <= 10^6,m <= 10^6,1 <= v <= 10000,1 <= x <= m$", "locale": "zh-CN"}}}
{"pid": "P5027", "type": "P", "difficulty": 5, "samples": [["2\n1 1 2\n2 1 2 5\n2 1 2 1", "2"], ["2\n1 1 2\n2 1 2 4\n2 1 2 5", "2"], ["2\n1 1 2\n2 1 2 6\n2 1 2 5", "illegal"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["枚举", "高斯消元"], "title": "Barracuda", "background": "小正方形的冒险旅途，并不顺利。\n\n一路上，小正方形看到了壮美秀丽的小岛被污染，看到了雄伟壮观的火山，还碰到了许许多多的敌人。\n\n眼下，小正方形正在对付一个巨大的三角形。", "description": "大三角形给小正方形讲起自己的过去：过去的它是一个挖宝工，后来被黑暗之主污染才会落到此番境地。\n\n它也希望小正方形去战胜黑暗之主，不过限于黑暗之主的眼线密布，因此必须给小正方形设置障碍才能骗过那些“眼线”。\n\n他给小正方形的问题是：它有 $n$ 个小三角形，每个小三角形有一定的质量，它对这些三角形进行了 $n + 1$ 次称量，然而由于托盘天平(?)的问题，有一次称量的结果是有误的。\n\n现在，大三角形想要知道最重的小三角形的 编号。\n\n一组输入是合法的，当且仅当输入满足以下条件：\n\n不存在一组 $i$,$j$，使得当我们**假定**第 $i$ 条称量数据有误时能求出一种合法方案且我们**假定**第 $j$ 条称量数据有误时也能求出一种合法方案。\n\n合法方案定义如下：\n\n1、最重的三角形只有一个。\n\n2、不存在重量不确定的三角形。\n\n3、所有三角形的重量均为正整数。", "inputFormat": "输入的第一行为一个正整数 $n$，表示小三角形的数目。\n\n接下来 $n + 1$ 行，每行按照以下格式输入：\n\n首先是一个正整数 $m$，表示这次称量抓了几个小三角形。\n\n接下来 $m$ 个整数，表示称量的小三角形的编号。\n\n最后一个整数 $weight$ ，表示这次称量的结果。", "outputFormat": "若合法，输出最重小三角形的编号，否则输出 \"illegal\"(不含引号)。", "hint": "样例一：\n\n若第一次称量结果错误，则无法得出正确解。\n\n若第二次称量结果错误，则第二个小三角形重量为负，显然不对。\n\n若第三次称量结果错误，我们得出 $1$ 号小三角形重量为 $2$，$2$号小三角形重量为 $3$，$2$号小三角形最重。\n\n本题采用捆绑测试，共有三个 $subtask$，描述如下：\n\n$subtask 0 - 30Pts$ 保证小三角形的重量 <= 20且 $n <= 5$，在这个 $subtask$ 中，你每通过一个点可获得 $10$ 分。\n\n$subtask 1 - 30Pts$ 保证小三角形的重量 <= 100 并且 $n <= 100$，数据为随机生成。\n\n$subtask 2 - 40Pts$ 保证小三角形的重量 <= 100 并且 $n <= 100$\n\n在后两个 $subtask$ 中，你必须通过所有数据才能得分。\n\n对于 $100\\%$ 的数据， $1 <= m <= n$", "locale": "zh-CN", "translations": {"en": {"title": "Barracuda", "background": "The small square’s adventure journey has not been smooth.\n\nAlong the way, the small square saw magnificent and beautiful islands being polluted, saw grand volcanoes, and encountered many enemies.\n\nNow, the small square is dealing with a huge triangle.", "description": "The big triangle tells the small square about its past: it used to be a treasure miner, but later it was corrupted by the Lord of Darkness and ended up like this.\n\nIt also hopes that the small square can defeat the Lord of Darkness, but because the Lord of Darkness has spies everywhere, it must set obstacles for the small square to fool those “spies”.\n\nThe problem it gives to the small square is: it has $n$ small triangles, and each small triangle has a certain weight. It performed $n + 1$ weighings on these triangles; however, due to an issue with the pan balance (?), one weighing result is wrong.\n\nNow, the big triangle wants to know the index of the heaviest small triangle.\n\nAn input is considered valid if and only if it satisfies the following condition:\n\nThere do not exist two indices $i$, $j$ such that, when we **assume** the $i$-th weighing data is wrong, we can find a valid solution, and when we **assume** the $j$-th weighing data is wrong, we can also find a valid solution.\n\nA valid solution is defined as follows:\n\n1. There is exactly one heaviest triangle.\n\n2. There is no triangle whose weight is undetermined.\n\n3. The weights of all triangles are positive integers.", "inputFormat": "The first line contains a positive integer $n$, representing the number of small triangles.\n\nThe next $n + 1$ lines are given in the following format:\n\nFirst, an integer $m$, representing how many small triangles are grabbed in this weighing.\n\nThen $m$ integers, representing the indices of the small triangles being weighed.\n\nThe last integer $weight$ represents the result of this weighing.", "outputFormat": "If it is valid, output the index of the heaviest small triangle; otherwise output \"illegal\" (without quotes).", "hint": "Sample 1:\n\nIf the result of the first weighing is wrong, then a correct solution cannot be obtained.\n\nIf the result of the second weighing is wrong, then the weight of the second small triangle is negative, which is obviously not correct.\n\nIf the result of the third weighing is wrong, we obtain that triangle $1$ has weight $2$, triangle $2$ has weight $3$, and triangle $2$ is the heaviest.\n\nThis problem uses bundled testdata and has three $subtask$s, described as follows:\n\n$subtask 0 - 30Pts$: It is guaranteed that the weights of small triangles are <= 20 and $n <= 5$. In this $subtask$, you can get $10$ points for each test you pass.\n\n$subtask 1 - 30Pts$: It is guaranteed that the weights of small triangles are <= 100 and $n <= 100$. The testdata are randomly generated.\n\n$subtask 2 - 40Pts$: It is guaranteed that the weights of small triangles are <= 100 and $n <= 100$.\n\nIn the last two $subtask$s, you must pass all testdata to get any score.\n\nFor $100\\%$ of the testdata, $1 <= m <= n$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Barracuda", "background": "小正方形的冒险旅途，并不顺利。\n\n一路上，小正方形看到了壮美秀丽的小岛被污染，看到了雄伟壮观的火山，还碰到了许许多多的敌人。\n\n眼下，小正方形正在对付一个巨大的三角形。", "description": "大三角形给小正方形讲起自己的过去：过去的它是一个挖宝工，后来被黑暗之主污染才会落到此番境地。\n\n它也希望小正方形去战胜黑暗之主，不过限于黑暗之主的眼线密布，因此必须给小正方形设置障碍才能骗过那些“眼线”。\n\n他给小正方形的问题是：它有 $n$ 个小三角形，每个小三角形有一定的质量，它对这些三角形进行了 $n + 1$ 次称量，然而由于托盘天平(?)的问题，有一次称量的结果是有误的。\n\n现在，大三角形想要知道最重的小三角形的 编号。\n\n一组输入是合法的，当且仅当输入满足以下条件：\n\n不存在一组 $i$,$j$，使得当我们**假定**第 $i$ 条称量数据有误时能求出一种合法方案且我们**假定**第 $j$ 条称量数据有误时也能求出一种合法方案。\n\n合法方案定义如下：\n\n1、最重的三角形只有一个。\n\n2、不存在重量不确定的三角形。\n\n3、所有三角形的重量均为正整数。", "inputFormat": "输入的第一行为一个正整数 $n$，表示小三角形的数目。\n\n接下来 $n + 1$ 行，每行按照以下格式输入：\n\n首先是一个正整数 $m$，表示这次称量抓了几个小三角形。\n\n接下来 $m$ 个整数，表示称量的小三角形的编号。\n\n最后一个整数 $weight$ ，表示这次称量的结果。", "outputFormat": "若合法，输出最重小三角形的编号，否则输出 \"illegal\"(不含引号)。", "hint": "样例一：\n\n若第一次称量结果错误，则无法得出正确解。\n\n若第二次称量结果错误，则第二个小三角形重量为负，显然不对。\n\n若第三次称量结果错误，我们得出 $1$ 号小三角形重量为 $2$，$2$号小三角形重量为 $3$，$2$号小三角形最重。\n\n本题采用捆绑测试，共有三个 $subtask$，描述如下：\n\n$subtask 0 - 30Pts$ 保证小三角形的重量 <= 20且 $n <= 5$，在这个 $subtask$ 中，你每通过一个点可获得 $10$ 分。\n\n$subtask 1 - 30Pts$ 保证小三角形的重量 <= 100 并且 $n <= 100$，数据为随机生成。\n\n$subtask 2 - 40Pts$ 保证小三角形的重量 <= 100 并且 $n <= 100$\n\n在后两个 $subtask$ 中，你必须通过所有数据才能得分。\n\n对于 $100\\%$ 的数据， $1 <= m <= n$", "locale": "zh-CN"}}}
{"pid": "P5028", "type": "P", "difficulty": 6, "samples": [["3\nabb\nbcc\naba", "1 2\n1 1\n2 1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2500, 2000, 2000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}, "tags": ["字符串", "后缀数组 SA"], "title": "Annihilate", "background": "前情提要：小正方形与黑暗之主展开了大战，最后小正方形击败了黑暗之主，成功从黑暗之主的手上夺下最后一个三角。\n\n三角旋转着，净化着，正当三角即将净化完成时，黑暗之主突然到来，阻断了三角形的净化，吸收了三角的能量。\n\n可是，因为三角的能量太过巨大，导致黑暗之主发生了变异，现在的黑暗之主一次次复制，最终成为了一条蜈蚣……\n\n现在，小正方形还能阻止黑暗之主毁灭世界吗？", "description": "黑暗之主的蜈蚣几乎可以毁灭一切，因此小正方形陷入了苦战……\n\n小正方形现在需要减弱黑暗之主的攻击。\n\n一个黑暗之主的攻击可以用一个仅有小写字母的字符串表示。\n\n现在黑暗之主向小正方形发动了若干攻击，对于两个攻击，小正方形能选出它们最长的公共**子串**，并把这一段消除。\n\n现在小正方形想要知道，对于**任意两个**黑暗之主的攻击，它们的最长公共子串长度是多少，你能帮帮它吗？", "inputFormat": "第一行为一个整数 $n$，表示字符串数目。\n\n接下来 $n$ 行，一行一个字符串，保证所有字符串长度之和不超过 $10^6$。", "outputFormat": "输出共有 $n$ 行，每行 $n - 1$个正整数。\n\n第一行第一个正整数表示第 $1$ 个串与第 $2$ 个串的最长公共子串。\n\n第二个正整数表示第 $1$ 个串与第 $3$ 个串的最长公共子串。\n\n……\n\n第二行第一个正整数表示第 $2$ 个串与第 $1$ 个串的最长公共子串。\n\n以此类推。", "hint": "对于 $30\\%$ 的数据，$n \\le 5$，每个字符串长度不超过 $500$。\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 50$，字符串长度之和不超过 $10^6$。\n\n**注意：本题内存限制仅为 $64$ MB,请尽量使用内存运用优秀的方法。**\n\n另外，对于占 $60$ pts 的测试点，您每通过一个点即可获得 $10$ pts。\n\n对于剩下的测试点，您只有全部通过才能获得 $40$ pts。\n\n**对于所有数据点，不保证数据为随机生成。**", "locale": "zh-CN", "translations": {"en": {"title": "Annihilate", "background": "Previously: The little square and the Lord of Darkness fought a great battle. In the end, the little square defeated the Lord of Darkness and successfully took the last triangle from him.\n\nThe triangle was spinning and purifying. Just as the purification was about to finish, the Lord of Darkness suddenly arrived, interrupted the triangle’s purification, and absorbed the triangle’s energy.\n\nHowever, because the triangle’s energy was too huge, the Lord of Darkness mutated. The current Lord of Darkness keeps duplicating again and again, and eventually became a centipede...\n\nNow, can the little square still stop the Lord of Darkness from destroying the world?", "description": "The centipede of the Lord of Darkness can destroy almost everything, so the little square is trapped in a hard fight...\n\nNow the little square needs to weaken the attacks of the Lord of Darkness.\n\nOne attack of the Lord of Darkness can be represented by a string consisting only of lowercase letters.\n\nNow the Lord of Darkness launches several attacks at the little square. For any two attacks, the little square can find their longest common **substring** and erase that part.\n\nNow the little square wants to know: for **any two** attacks of the Lord of Darkness, what is the length of their longest common substring? Can you help?", "inputFormat": "The first line contains an integer $n$, representing the number of strings.\n\nThe next $n$ lines each contain one string. It is guaranteed that the total length of all strings does not exceed $10^6$.", "outputFormat": "Output a total of $n$ lines, each containing $n - 1$ positive integers.\n\nThe first positive integer in the first line represents the longest common substring of the $1$st string and the $2$nd string.\n\nThe second positive integer represents the longest common substring of the $1$st string and the $3$rd string.\n\n...\n\nThe first positive integer in the second line represents the longest common substring of the $2$nd string and the $1$st string.\n\nAnd so on.", "hint": "For $30\\%$ of the testdata, $n \\le 5$, and the length of each string does not exceed $500$.\n\nFor $100\\%$ of the testdata, $2 \\le n \\le 50$, and the total length of all strings does not exceed $10^6$.\n\n**Note: the memory limit of this problem is only $64$ MB. Please use a method with good memory usage.**\n\nIn addition, for the test points worth $60$ pts, you will get $10$ pts for each point you pass.\n\nFor the remaining test points, you will get $40$ pts only if you pass all of them.\n\n**For all test points, the data is not guaranteed to be randomly generated.**\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Annihilate", "background": "前情提要：小正方形与黑暗之主展开了大战，最后小正方形击败了黑暗之主，成功从黑暗之主的手上夺下最后一个三角。\n\n三角旋转着，净化着，正当三角即将净化完成时，黑暗之主突然到来，阻断了三角形的净化，吸收了三角的能量。\n\n可是，因为三角的能量太过巨大，导致黑暗之主发生了变异，现在的黑暗之主一次次复制，最终成为了一条蜈蚣……\n\n现在，小正方形还能阻止黑暗之主毁灭世界吗？", "description": "黑暗之主的蜈蚣几乎可以毁灭一切，因此小正方形陷入了苦战……\n\n小正方形现在需要减弱黑暗之主的攻击。\n\n一个黑暗之主的攻击可以用一个仅有小写字母的字符串表示。\n\n现在黑暗之主向小正方形发动了若干攻击，对于两个攻击，小正方形能选出它们最长的公共**子串**，并把这一段消除。\n\n现在小正方形想要知道，对于**任意两个**黑暗之主的攻击，它们的最长公共子串长度是多少，你能帮帮它吗？", "inputFormat": "第一行为一个整数 $n$，表示字符串数目。\n\n接下来 $n$ 行，一行一个字符串，保证所有字符串长度之和不超过 $10^6$。", "outputFormat": "输出共有 $n$ 行，每行 $n - 1$个正整数。\n\n第一行第一个正整数表示第 $1$ 个串与第 $2$ 个串的最长公共子串。\n\n第二个正整数表示第 $1$ 个串与第 $3$ 个串的最长公共子串。\n\n……\n\n第二行第一个正整数表示第 $2$ 个串与第 $1$ 个串的最长公共子串。\n\n以此类推。", "hint": "对于 $30\\%$ 的数据，$n \\le 5$，每个字符串长度不超过 $500$。\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 50$，字符串长度之和不超过 $10^6$。\n\n**注意：本题内存限制仅为 $64$ MB,请尽量使用内存运用优秀的方法。**\n\n另外，对于占 $60$ pts 的测试点，您每通过一个点即可获得 $10$ pts。\n\n对于剩下的测试点，您只有全部通过才能获得 $40$ pts。\n\n**对于所有数据点，不保证数据为随机生成。**", "locale": "zh-CN"}}}
{"pid": "P5029", "type": "P", "difficulty": 6, "samples": [["5 4 5\n1 3 1 3\n1 3 3 2\n1 3 2 5\n4 1 1 1 4 5", "4"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "网络流", "图论建模"], "title": "T'ill It's Over", "background": "小正方形被黑暗之主碾成了粉末。\n\n一切，就这么结束了吗？\n\n就当大家都以为再无翻盘的希望时，\n\n已经被净化的两个世界之树的部分，微微闪烁……", "description": "小正方形被三角的力量复活了，它即将与黑暗之主展开最后的战斗。\n\n小正方形最后的目标，就是净化黑暗之主。\n\n黑暗之主的蜈蚣长度为 $n$，一开始每一节的光明程度为 $1$。\n\n当一节蜈蚣的光明程度达到一个指定的值 ($k$)，我们就视作这节蜈蚣被净化。\n\n为了净化黑暗之主，小正方形准备了 $m$ 种方案，这些方案按本质上的不同大约可分为四种：\n\n1. 将一节光明程度为 $a$ 的蜈蚣的光明程度 变为 $b$。（注意，$b$ 可能 $\\le a$）\n\n2. 将一节光明程度在 $a1$ 到 $a2$ 区间的蜈蚣的光明程度变为 $b1$。\n\n3. 将一节光明程度为 $a1$ 的蜈蚣的光明程度变为 $b1$ 到 $b2$ 区间的任意值。\n\n4. 将一节光明程度在 $a1$ 到 $a2$ 区间的蜈蚣的光明程度变为 $b1$ 到 $b2$ 区间的任意值。\n\n由于小正方形使用每种方案需要消耗一定程度的属性能量，因此每种方案都有一个独立的使用次数的上限，在一种方案中我们用 $l$ 来表示这个上限。\n\n小正方形想要知道，自己最多能够净化几节黑暗之主的蜈蚣。", "inputFormat": "第一行为三个正整数 $n,m,k$，表示黑暗之主蜈蚣身体的长度，小正方形的方案总数与上文所述的 $k$。\n\n接下来 $m$行，每行开头为两个正整数 $op,l$，表示方案的种类与使用次数的上限，方案的输入方式如下：\n\n若 $op = 1$，则接下来两个整数 $a,b$，意义如上文所述。\n\n若 $op = 2$，则接下来三个整数 $a1,a2,b1$，意义如上文所述。\n\n若 $op = 3$，则接下来三个整数 $a1,b1,b2$，意义如上文所述。\n\n若 $op = 4$，则接下来四个整数 $a1,a2,b1,b2$，意义如上文所述。\n\n数据保证，所有 $1 \\le a,b,a1,b1,a2,b2 \\le k$", "outputFormat": "一行一个整数，表示最多能净化的节数。", "hint": "首先使用方案 1，2，3，将三节光明程度变为 $3$，接着再变为 $2$，再变为 $5$。\n\n然后使用方案 4，将一节的光明程度变为 $5$。\n\n对于 $10\\%$ 的数据，$n = 1,op = 1$。\n\n对于另外 $10\\%$ 的数据，$n = 1,op \\le 3$。\n\n对于另外 $10\\%$ 的数据，$n \\le 10,op = 1$。\n\n对于另外 $20\\%$ 的数据，$n \\le 100,m \\le 100,op = 1$。\n\n对于 $70\\%$ 的数据，$n  \\le 1000,m \\le 1000,op \\le 3,k \\le 20000$。\n\n**对于前 $70\\%$ 的数据，时限为 $500$ ms**。\n\n对于 $100\\%$ 的数据，$n \\le 10^7,m \\le 20000,1 \\le k \\le 10^5,1 \\le l \\le 10^5$。\n\n**对于后 $30\\%$ 的数据，时限为 $8000$ ms**。\n\n**数据保证，操作为随机生成**。", "locale": "zh-CN", "translations": {"en": {"title": "T'ill It's Over", "background": "The little square was crushed into dust by the Lord of Darkness.\n\nIs everything really over like this?\n\nJust when everyone thought there was no hope of turning the tables,\n\nparts of the two World Trees that had already been purified began to flicker faintly……", "description": "The little square has been revived by the power of the triangle, and it is about to start the final battle with the Lord of Darkness.\n\nThe little square’s final goal is to purify the Lord of Darkness.\n\nThe Lord of Darkness has a centipede body of length $n$, and at the beginning the brightness level of each segment is $1$.\n\nWhen the brightness level of a segment reaches a specified value ($k$), we consider this segment to be purified.\n\nTo purify the Lord of Darkness, the little square has prepared $m$ types of plans. By their essential differences, these plans can be roughly divided into four types:\n\n1. Change the brightness level of a segment with brightness level $a$ to $b$. (Note that $b$ may be $\\le a$.)\n\n2. Change the brightness level of a segment whose brightness level is in the interval from $a1$ to $a2$ to $b1$.\n\n3. Change the brightness level of a segment with brightness level $a1$ to any value in the interval from $b1$ to $b2$.\n\n4. Change the brightness level of a segment whose brightness level is in the interval from $a1$ to $a2$ to any value in the interval from $b1$ to $b2$.\n\nSince using each plan consumes a certain amount of attribute energy, each plan has its own independent upper limit on the number of uses. In one plan, we use $l$ to denote this upper limit.\n\nThe little square wants to know the maximum number of segments of the Lord of Darkness’s centipede that can be purified.", "inputFormat": "The first line contains three positive integers $n, m, k$, representing the length of the Lord of Darkness’s centipede body, the total number of plans, and the $k$ described above.\n\nThe next $m$ lines each start with two positive integers $op, l$, representing the type of the plan and the upper limit on the number of uses. The input for each plan type is as follows:\n\nIf $op = 1$, then two integers $a, b$ follow, with the meaning described above.\n\nIf $op = 2$, then three integers $a1, a2, b1$ follow, with the meaning described above.\n\nIf $op = 3$, then three integers $a1, b1, b2$ follow, with the meaning described above.\n\nIf $op = 4$, then four integers $a1, a2, b1, b2$ follow, with the meaning described above.\n\nThe data guarantees that all $1 \\le a, b, a1, b1, a2, b2 \\le k$.", "outputFormat": "Output one integer in a single line, representing the maximum number of segments that can be purified.", "hint": "First use plans 1, 2, and 3 to change the brightness levels of three segments to $3$, then change them to $2$, and then to $5$.\n\nThen use plan 4 to change the brightness level of one segment to $5$.\n\nFor $10\\%$ of the testdata, $n = 1, op = 1$.\n\nFor another $10\\%$ of the testdata, $n = 1, op \\le 3$.\n\nFor another $10\\%$ of the testdata, $n \\le 10, op = 1$.\n\nFor another $20\\%$ of the testdata, $n \\le 100, m \\le 100, op = 1$.\n\nFor $70\\%$ of the testdata, $n \\le 1000, m \\le 1000, op \\le 3, k \\le 20000$.\n\n**For the first $70\\%$ of the testdata, the time limit is $500$ ms**.\n\nFor $100\\%$ of the testdata, $n \\le 10^7, m \\le 20000, 1 \\le k \\le 10^5, 1 \\le l \\le 10^5$.\n\n**For the last $30\\%$ of the testdata, the time limit is $8000$ ms**.\n\n**The data guarantees that the operations are randomly generated**.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "T'ill It's Over", "background": "小正方形被黑暗之主碾成了粉末。\n\n一切，就这么结束了吗？\n\n就当大家都以为再无翻盘的希望时，\n\n已经被净化的两个世界之树的部分，微微闪烁……", "description": "小正方形被三角的力量复活了，它即将与黑暗之主展开最后的战斗。\n\n小正方形最后的目标，就是净化黑暗之主。\n\n黑暗之主的蜈蚣长度为 $n$，一开始每一节的光明程度为 $1$。\n\n当一节蜈蚣的光明程度达到一个指定的值 ($k$)，我们就视作这节蜈蚣被净化。\n\n为了净化黑暗之主，小正方形准备了 $m$ 种方案，这些方案按本质上的不同大约可分为四种：\n\n1. 将一节光明程度为 $a$ 的蜈蚣的光明程度 变为 $b$。（注意，$b$ 可能 $\\le a$）\n\n2. 将一节光明程度在 $a1$ 到 $a2$ 区间的蜈蚣的光明程度变为 $b1$。\n\n3. 将一节光明程度为 $a1$ 的蜈蚣的光明程度变为 $b1$ 到 $b2$ 区间的任意值。\n\n4. 将一节光明程度在 $a1$ 到 $a2$ 区间的蜈蚣的光明程度变为 $b1$ 到 $b2$ 区间的任意值。\n\n由于小正方形使用每种方案需要消耗一定程度的属性能量，因此每种方案都有一个独立的使用次数的上限，在一种方案中我们用 $l$ 来表示这个上限。\n\n小正方形想要知道，自己最多能够净化几节黑暗之主的蜈蚣。", "inputFormat": "第一行为三个正整数 $n,m,k$，表示黑暗之主蜈蚣身体的长度，小正方形的方案总数与上文所述的 $k$。\n\n接下来 $m$行，每行开头为两个正整数 $op,l$，表示方案的种类与使用次数的上限，方案的输入方式如下：\n\n若 $op = 1$，则接下来两个整数 $a,b$，意义如上文所述。\n\n若 $op = 2$，则接下来三个整数 $a1,a2,b1$，意义如上文所述。\n\n若 $op = 3$，则接下来三个整数 $a1,b1,b2$，意义如上文所述。\n\n若 $op = 4$，则接下来四个整数 $a1,a2,b1,b2$，意义如上文所述。\n\n数据保证，所有 $1 \\le a,b,a1,b1,a2,b2 \\le k$", "outputFormat": "一行一个整数，表示最多能净化的节数。", "hint": "首先使用方案 1，2，3，将三节光明程度变为 $3$，接着再变为 $2$，再变为 $5$。\n\n然后使用方案 4，将一节的光明程度变为 $5$。\n\n对于 $10\\%$ 的数据，$n = 1,op = 1$。\n\n对于另外 $10\\%$ 的数据，$n = 1,op \\le 3$。\n\n对于另外 $10\\%$ 的数据，$n \\le 10,op = 1$。\n\n对于另外 $20\\%$ 的数据，$n \\le 100,m \\le 100,op = 1$。\n\n对于 $70\\%$ 的数据，$n  \\le 1000,m \\le 1000,op \\le 3,k \\le 20000$。\n\n**对于前 $70\\%$ 的数据，时限为 $500$ ms**。\n\n对于 $100\\%$ 的数据，$n \\le 10^7,m \\le 20000,1 \\le k \\le 10^5,1 \\le l \\le 10^5$。\n\n**对于后 $30\\%$ 的数据，时限为 $8000$ ms**。\n\n**数据保证，操作为随机生成**。", "locale": "zh-CN"}}}
{"pid": "P5030", "type": "P", "difficulty": 5, "samples": [["2 2 1\n1 1", "3"], ["8 7 5\n1 1\n5 4\n2 3\n4 7\n8 3", "28"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["网络流", "二分图"], "title": "长脖子鹿放置", "background": "众所周知，在西洋棋中，我们有城堡、骑士、皇后、主教和长脖子鹿。", "description": "如图所示，西洋棋的“长脖子鹿”，类似于中国象棋的马，但按照“目”字攻击，且没有中国象棋“别马腿”的规则。（因为长脖子鹿没有马腿）\n\n![horse](https://cdn.luogu.com.cn/upload/pic/37260.png)\n\n给定一个 $N \\times M$ 的棋盘，有一些格子禁止放棋子。问棋盘上最多能放多少个不能互相攻击的长脖子鹿。", "inputFormat": "输入的第一行为两个正整数 $N,M,K$。其中 $K$ 表示禁止放置长脖子鹿的格子数。\n\n输入的第 $2 \\sim K+1$ 行每一行为两个整数 $X_i, Y_i$，表示禁止放置的格子。\n\n不保证禁止放置的格子互不相同。", "outputFormat": "一行一个正整数，表示最多能放置的长脖子鹿个数。", "hint": "对于 $10\\%$ 的数据，$1 \\le N,M \\le 5$；\n\n对于 $30\\%$ 的数据，$1 \\le N,M \\le 10$；\n\n对于 $60\\%$ 的数据，$1 \\le N,M \\le 50$；\n\n对于 $80\\%$ 的数据，$1 \\le N,M \\le 100$；\n\n对于 $100\\%$ 的数据，$1 \\le N,M \\le 200$。", "locale": "zh-CN", "translations": {"en": {"title": "Long-necked Giraffe Placement", "background": "As everyone knows, in chess, we have rooks, knights, queens, bishops, and long-necked giraffes.", "description": "As shown in the picture, the chess piece \"long-necked giraffe\" is similar to the knight in Chinese chess, but it attacks in a \"目\" shape, and there is no rule like the Chinese chess \"blocking the horse's leg\" (because the long-necked giraffe has no legs).\n\n![horse](https://cdn.luogu.com.cn/upload/pic/37260.png)\n\nGiven an $N \\times M$ chessboard, some cells are forbidden to place pieces. Find the maximum number of long-necked giraffes that can be placed on the board such that none of them can attack each other.", "inputFormat": "The first line contains two positive integers $N, M, K$. Here, $K$ is the number of cells where placing a long-necked giraffe is forbidden.\n\nLines $2$ to $K + 1$ each contain two integers $X_i, Y_i$, indicating a forbidden cell.\n\nIt is not guaranteed that the forbidden cells are all distinct.", "outputFormat": "Output one positive integer in a single line, representing the maximum number of long-necked giraffes that can be placed.", "hint": "For $10\\%$ of the testdata, $1 \\le N, M \\le 5$.\n\nFor $30\\%$ of the testdata, $1 \\le N, M \\le 10$.\n\nFor $60\\%$ of the testdata, $1 \\le N, M \\le 50$.\n\nFor $80\\%$ of the testdata, $1 \\le N, M \\le 100$.\n\nFor $100\\%$ of the testdata, $1 \\le N, M \\le 200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "长脖子鹿放置", "background": "众所周知，在西洋棋中，我们有城堡、骑士、皇后、主教和长脖子鹿。", "description": "如图所示，西洋棋的“长脖子鹿”，类似于中国象棋的马，但按照“目”字攻击，且没有中国象棋“别马腿”的规则。（因为长脖子鹿没有马腿）\n\n![horse](https://cdn.luogu.com.cn/upload/pic/37260.png)\n\n给定一个 $N \\times M$ 的棋盘，有一些格子禁止放棋子。问棋盘上最多能放多少个不能互相攻击的长脖子鹿。", "inputFormat": "输入的第一行为两个正整数 $N,M,K$。其中 $K$ 表示禁止放置长脖子鹿的格子数。\n\n输入的第 $2 \\sim K+1$ 行每一行为两个整数 $X_i, Y_i$，表示禁止放置的格子。\n\n不保证禁止放置的格子互不相同。", "outputFormat": "一行一个正整数，表示最多能放置的长脖子鹿个数。", "hint": "对于 $10\\%$ 的数据，$1 \\le N,M \\le 5$；\n\n对于 $30\\%$ 的数据，$1 \\le N,M \\le 10$；\n\n对于 $60\\%$ 的数据，$1 \\le N,M \\le 50$；\n\n对于 $80\\%$ 的数据，$1 \\le N,M \\le 100$；\n\n对于 $100\\%$ 的数据，$1 \\le N,M \\le 200$。", "locale": "zh-CN"}}}
{"pid": "P5031", "type": "P", "difficulty": 5, "samples": [["2 2", "2"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": [], "title": "庞氏骗局", "background": "众所周知，庞氏骗局就是借新债还就债的骗术，隐瞒企业已经大开倒车的真相，保持虚假的增长。", "description": "庞氏骗局源自于一个名叫查尔斯•庞兹的人。1919 年，他故弄玄虚，设计了一份假金融企划向大众兜售。借此，坑骗了成千上万的波士顿的长脖子鹿，套走了近 1500 万美金。\n\n查尔斯•庞兹的骗局计划分为两部分，第一次他向 $K_1$ 名长脖子鹿展示了自己的创业计划，向每一头长脖子鹿要来了 $1$ 万元的投资。第二次他向 $K_2$ 名长脖子鹿展示了自己的创业计划，由于第二次需要填补第一次的亏空，所以向每一头长脖子鹿要来了 $2$ 万元的投资。\n\n现在，查尔斯•庞兹拥有了 $K_1$ 份 $1$ 万元和 $K_2$ 份 $2$ 万元，他希望通过一种特定的方式消费从而躲避美国税务局（IRS）的追查。每一天，他都会选择两份钱，各消费 $1$ 万元。为了进一步减轻自己的嫌疑，他每天选择的两份钱不会与之前重复。他想知道，花光所有的钱，共有多少不同的方案集合，**即方案内没有先后顺序，每一天不分先后**。\n\n例如：第一天选择了从 $(1,2)$ 两只长脖子鹿那里拿钱，第二天不能花 $(1,2)$ 两只长脖子鹿的钱，但可以从 $(2,3)$ 或 $(1,3)$ 这样的长脖子鹿组中拿钱。\n\n方案数对 $10^9+7$ 取模。", "inputFormat": "一行，两个正整数，$K_1,K_2$。", "outputFormat": "一行，一个正整数，方案数。", "hint": "##### 样例解释\n\n我们设 $1,2$ 号长颈鹿给了 $1$ 万元，$3,4$ 号长颈鹿给了 $2$ 万元。\n\n方案一为这样的方案集合${(1,3),(3,4),(2,4)}$。\n\n方案二位这样的方案集合${(1,4),(3,4),(2,3)}$。\n\n![](https://cdn.luogu.com.cn/upload/pic/40820.png)", "locale": "zh-CN", "translations": {"en": {"title": "Ponzi Scheme", "background": "As everyone knows, a Ponzi scheme is a scam that uses new debt to pay off old debt, hiding the truth that the business has already gone downhill, while maintaining fake growth.", "description": "The Ponzi scheme originated from a man named Charles Ponzi. In 1919, he created a mysterious-looking fake financial plan and sold it to the public. In this way, he cheated tens of thousands of long-necked giraffes in Boston, taking nearly 15 million US dollars from them.\n\nCharles Ponzi’s scam plan has two parts. The first time, he showed his startup plan to $K_1$ giraffes, and asked each giraffe for an investment of 10,000 yuan. The second time, he showed his startup plan to $K_2$ giraffes. Since the second time needed to cover the losses from the first time, he asked each giraffe for an investment of 20,000 yuan.\n\nNow, Charles Ponzi has $K_1$ amounts of 10,000 yuan and $K_2$ amounts of 20,000 yuan. He hopes to spend the money in a specific way to avoid being tracked by the IRS. Every day, he will choose two amounts of money, and spend 10,000 yuan from each of them. To further reduce suspicion, the two amounts he chooses each day will not repeat any pair chosen before. He wants to know: after spending all the money, how many different sets of plans are there, **that is, there is no order inside a plan set, and the days are also unordered**.\n\nFor example, if on the first day he chooses money from giraffes $(1,2)$, then on the second day he cannot spend money from giraffes $(1,2)$ again, but he can take money from a giraffe pair such as $(2,3)$ or $(1,3)$.\n\nOutput the number of plans modulo $10^9+7$.", "inputFormat": "One line with two positive integers, $K_1,K_2$.", "outputFormat": "One line with one positive integer, the number of plans.", "hint": "##### Sample Explanation\n\nSuppose giraffes $1,2$ each gave 10,000 yuan, and giraffes $3,4$ each gave 20,000 yuan.\n\nPlan 1 is the plan set ${(1,3),(3,4),(2,4)}$.\n\nPlan 2 is the plan set ${(1,4),(3,4),(2,3)}$.\n\n![](https://cdn.luogu.com.cn/upload/pic/40820.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "庞氏骗局", "background": "众所周知，庞氏骗局就是借新债还就债的骗术，隐瞒企业已经大开倒车的真相，保持虚假的增长。", "description": "庞氏骗局源自于一个名叫查尔斯•庞兹的人。1919 年，他故弄玄虚，设计了一份假金融企划向大众兜售。借此，坑骗了成千上万的波士顿的长脖子鹿，套走了近 1500 万美金。\n\n查尔斯•庞兹的骗局计划分为两部分，第一次他向 $K_1$ 名长脖子鹿展示了自己的创业计划，向每一头长脖子鹿要来了 $1$ 万元的投资。第二次他向 $K_2$ 名长脖子鹿展示了自己的创业计划，由于第二次需要填补第一次的亏空，所以向每一头长脖子鹿要来了 $2$ 万元的投资。\n\n现在，查尔斯•庞兹拥有了 $K_1$ 份 $1$ 万元和 $K_2$ 份 $2$ 万元，他希望通过一种特定的方式消费从而躲避美国税务局（IRS）的追查。每一天，他都会选择两份钱，各消费 $1$ 万元。为了进一步减轻自己的嫌疑，他每天选择的两份钱不会与之前重复。他想知道，花光所有的钱，共有多少不同的方案集合，**即方案内没有先后顺序，每一天不分先后**。\n\n例如：第一天选择了从 $(1,2)$ 两只长脖子鹿那里拿钱，第二天不能花 $(1,2)$ 两只长脖子鹿的钱，但可以从 $(2,3)$ 或 $(1,3)$ 这样的长脖子鹿组中拿钱。\n\n方案数对 $10^9+7$ 取模。", "inputFormat": "一行，两个正整数，$K_1,K_2$。", "outputFormat": "一行，一个正整数，方案数。", "hint": "##### 样例解释\n\n我们设 $1,2$ 号长颈鹿给了 $1$ 万元，$3,4$ 号长颈鹿给了 $2$ 万元。\n\n方案一为这样的方案集合${(1,3),(3,4),(2,4)}$。\n\n方案二位这样的方案集合${(1,4),(3,4),(2,3)}$。\n\n![](https://cdn.luogu.com.cn/upload/pic/40820.png)", "locale": "zh-CN"}}}
{"pid": "P5032", "type": "P", "difficulty": 5, "samples": [["5\n1 1 2 3 4", "-1"], ["4\n1 1 1 1", "7"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递归", "O2优化", "优先队列", "队列"], "title": "经验", "background": "[赛时答疑](https://www.luogu.org/discuss/show/80694)  \n\n**简略版已经更新，时限改为 500ms**。\n\n攒够经验附魔去~~\n\nSteve 在 Minecraft 中总是会遇上难题：\n他想要修理 $n$ 本附魔书，每本附魔书的等级为 $a_i$，他总是不知道铁砧修理和经验值的机制。他便在 wiki 上搜索到了一些资料：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7qa0g8xy.png)\n\n——图为经验值与等级的关系。\n\n他看到这个图，就想：我等级升的越高，我所需要的经验值便越多，那么如果我等级刚好够铁砧修理的话，那我所耗费的经验不就越少了吗？他便继续搜索了下去，并将铁砧机制附在了下面,让你帮他解决问题。", "description": "#### 累积惩罚\n\n无论是重命名、修复、还是合并操作，其经验花费都会因其物品先前在铁砧上的操作而增加，这些额外增加的花费被称作“累积惩罚”。对于一件从未放上铁砧的物品，累积惩罚为 $0$。\n\n一个物品每次在铁砧上操作过后（不包括重命名），其累积惩罚都会先乘 $2$ 再加 $1$。如此一来，一个物品在操作过 $N$ 次后累积惩罚是 $2^N-1$。$6$ 次操作之后，累积惩罚是 $63$ 级，此时生存模式下无法再作进一步的修复和附魔工作。$31$ 次操作后，惩罚等级是 $2147483647$ 级，此时在任何模式下都不能再进行操作。\n\n当合并两个物品时，玩家会同时受到两件物品的累积惩罚。合并后物品的累积惩罚根据先前两个物品中较高者计算。例如，合并两个累积惩罚分别是 $3$ 级和 $15$ 级的物品会额外花费 $18$ 级的惩罚经验，而合并后的物品惩罚是 $31$ 级（$15 \\times 2+1$）。\n\n累积惩罚甚至会作用在不会磨损的物品上，譬如附魔书。因此，合并 $4$ 本时运 I 的附魔书，会得到一本累积惩罚为 $3$ 的时运 III 附魔书。\n\n|累计操作数|惩罚|\n|:--:|:--:|\n|$0$|$0$|\n|$1$|$1$|\n|$2$|$3$|\n|$3$|$7$|\n|$4$|$15$|\n|$5$|$31$|\n\n使用合成方格进行的物品修复操作会移除所有累积惩罚，但也会丢失所有的魔咒。\n\n#### 合并物品\n\n铁砧界面中第一格/左边的物品称为目标物品；第二格/右边的物品称为牺牲物品——合并后会消失。如果牺牲物品附有魔咒，铁砧会同时试图将牺牲物品的附魔合并至目标物品上。无论目标物品上的魔咒是否产生实际变化，铁砧都将根据目标物品与牺牲物品上的魔咒收取玩家的等级耗费。\n\n对于牺牲物品上的每个魔咒来说，如果目标物品也拥有相同的魔咒：\n\n- 当牺牲物品的魔咒等级较高时，目标物品魔咒的等级将上升至牺牲物品上的等级。\n\n- 当牺牲物品的魔咒等级相同时，目标物品上魔咒的等级将提升 $1$ 级，除非其等级已为最高。    \n\n- 当牺牲物品的魔咒等级较低时，目标物品上该魔咒的等级不变。\n    \n合并物品的总花费将是下列费用之和：\n\n1. 目标物品和牺牲物品的累积惩罚之和。\n\n2. 如果同时进行重命名，则额外产生重命名的费用。\n\n3. 如果目标物品耐久度未满，则耗费 $2$ 级用于维修。\n\n4. 如果牺牲物品拥有魔咒，则产生附魔费用。\n\n5. 如果牺牲物品是一本附魔书，则不会产生维修费用，铁砧会尝试将书本上的魔咒合并至目标物品上。亦可同时对目标物品进行重命名。此时的附魔花费一般会少于合并两个类似物品的费用。\n\n——摘自 mcwiki，稍作删改。\n\n#### 简略版\n\n给出附魔书，只有同等等级的才能合并。合并的代价为两本书的累计代价之和。合成后的书的累计代价为合成前最大代价的 $2$ 倍加上 $1$。求最高等级和最小花费（要求最高等级为第一关键字），Steve 因为开了挂，所以最高等级不限。\n\n现给出 $n$ 本附魔书，每本附魔书有它的等级 $a_i$，问如何才能得到附魔书的最大等级 $x$，在此基础上，请计算合成它消耗的最小等级 $y$（我们假设每本附魔书初始的累积惩罚为 $1$）。\n\nSteve 很懒，他不想看上面的话，他只想要让你编写出一个程序计算出 $x$ 与 $y$。但 Steve 为了不外传，他只要求你输出 $x$ 在模 $y$ 意义下的乘法逆元 $k$ 即可。如果没有，请输出 $-1$。", "inputFormat": "第一行为一个整数 $n$。\n\n接下来 $n$ 行，每行均有一个整数 $a_i$，表示每本附魔书的初始等级，不保证数据有序。", "outputFormat": "一个整数 $k$，表示 $x$ 在模 $y$ 意义下的乘法逆元，如果没有，请输出 $-1$。  \n\nPS：乘法逆元 $k$ 也可以这样理解：$k$ 是使得 $kx \\equiv 1 \\pmod y$的最小正整数。", "hint": "### 样例解释\n \n第一个样例：\n\n合并两个第一等级的，合并花费 $2$ 经验，代价升为 $3$；  \n再合并两个第二等级的，花费 $3+1=4$ 经验，代价升为 $7$；  \n再合并两个第三等级的，花费 $7+1=8$ 经验，代价升为 $15$；  \n最后合并两个第四等级的，花费 $15+1=16$ 经验，代价升为 $31$。  \n\n经验总花费：$2+4+8+16=30$，最大等级：$5$。\n\n\n对于第一个样例: $x=5,y=30$；\n\n对于第二个样例: $x=3,y=10$。\n\n### 数据范围\n\n![]( https://cdn.luogu.com.cn/upload/pic/41547.png )\n\n保证数据随机，$x,y,k$ 在 `long int` 范围内。\n\n### 温馨提示\n\n本题读入量较大，请使用较快的读入方法，在此，提供一种快速读入的样式：（需包含头文件 `<cctype>`）\n\n```cpp\n#include<cctype>\ninline void read(int &x){\n     char ch=getchar();x=0;\n     while(!isdigit(ch))   ch=getchar();\n     while(isdigit(ch))   x=x*10+ch-'0',ch=getchar();\n}\n```", "locale": "zh-CN", "translations": {"en": {"title": "Experience", "background": "[In-contest Q&A](https://www.luogu.org/discuss/show/80694).\n\n**The simplified version has been updated, and the time limit has been changed to 500 ms.**\n\nSave up enough experience to enchant~~\n\nSteve often runs into problems in Minecraft:\nHe wants to repair $n$ enchanted books, and the level of each book is $a_i$. He never really understands the anvil repair and experience mechanisms, so he searched for some information on the wiki:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7qa0g8xy.png)\n\n—The figure shows the relationship between experience and level.\n\nAfter seeing this figure, he thought: the higher my level is, the more experience I need. So if my level is just enough for anvil repairing, wouldn’t I spend the least experience? He continued searching and attached the anvil mechanism below, asking you to help him solve the problem.", "description": "#### Prior Work Penalty\n\nWhether it is renaming, repairing, or combining, the experience cost increases due to the item’s previous operations on an anvil. This extra cost is called the “prior work penalty”. For an item that has never been put on an anvil, the prior work penalty is $0$.\n\nAfter each anvil operation on an item (excluding renaming), its prior work penalty is multiplied by $2$ and then increased by $1$. Therefore, after $N$ operations, the prior work penalty is $2^N-1$. After $6$ operations, the prior work penalty is $63$ levels, and in survival mode no further repairing or enchanting can be done. After $31$ operations, the penalty level is $2147483647$, and no operations can be done in any mode.\n\nWhen combining two items, the player suffers the prior work penalties of both items at the same time. The prior work penalty of the combined item is calculated based on the higher one of the two items. For example, combining two items with prior work penalties of $3$ and $15$ will add an extra penalty cost of $18$ levels, and the resulting item’s penalty is $31$ ($15 \\times 2+1$).\n\nThe prior work penalty even applies to items that do not wear out, such as enchanted books. Therefore, combining $4$ Fortune I enchanted books will produce a Fortune III enchanted book with a prior work penalty of $3$.\n\n|Total operation count|Penalty|\n|:--:|:--:|\n|$0$|$0$|\n|$1$|$1$|\n|$2$|$3$|\n|$3$|$7$|\n|$4$|$15$|\n|$5$|$31$|\n\nRepairing items using the crafting grid removes all prior work penalties, but it also removes all enchantments.\n\n#### Combining Items\n\nIn the anvil interface, the item in the first slot/on the left is called the target item; the item in the second slot/on the right is called the sacrifice item—it will disappear after combining. If the sacrifice item has enchantments, the anvil will also try to merge the sacrifice item’s enchantments into the target item. Regardless of whether the enchantments on the target item actually change, the anvil will charge the player a level cost based on the enchantments on both the target item and the sacrifice item.\n\nFor each enchantment on the sacrifice item, if the target item also has the same enchantment:\n\n- If the sacrifice item’s enchantment level is higher, the target item’s enchantment level will increase to the sacrifice item’s level.\n\n- If the sacrifice item’s enchantment level is the same, the target item’s enchantment level will increase by $1$ level, unless it is already at the maximum level.\n\n- If the sacrifice item’s enchantment level is lower, the target item’s enchantment level does not change.\n\nThe total cost of combining items is the sum of the following costs:\n\n1. The sum of the target item’s and the sacrifice item’s prior work penalties.\n\n2. If renaming is also performed, an additional renaming cost is added.\n\n3. If the target item’s durability is not full, it costs $2$ levels for repairing.\n\n4. If the sacrifice item has enchantments, an enchanting cost is added.\n\n5. If the sacrifice item is an enchanted book, there is no repairing cost. The anvil will attempt to merge the book’s enchantments into the target item. Renaming the target item can also be performed at the same time. In this case, the enchanting cost is usually less than the cost of combining two similar items.\n\n—Adapted from mcwiki with minor edits.\n\n#### Simplified Version\n\nYou are given enchanted books. Only books of the same level can be combined. The cost of combining is the sum of the two books’ accumulated costs. The accumulated cost of the resulting book becomes $2$ times the maximum accumulated cost before combining, plus $1$. Find the highest level and the minimum cost (the highest level is the primary objective). Steve is using cheats, so the highest level is unlimited.\n\nNow you are given $n$ enchanted books, and each book has its level $a_i$. Ask how to obtain the maximum level $x$ of an enchanted book. On this basis, compute the minimum level cost $y$ to combine it (we assume the initial prior work penalty of each book is $1$).\n\nSteve is lazy. He does not want to read the above text; he only wants you to write a program to compute $x$ and $y$. But to prevent it from being spread, he only asks you to output $k$, the multiplicative inverse of $x$ modulo $y$. If it does not exist, output $-1$.", "inputFormat": "The first line contains an integer $n$.\n\nIn the next $n$ lines, each line contains an integer $a_i$, representing the initial level of each enchanted book. The data is not guaranteed to be sorted.", "outputFormat": "Output one integer $k$, representing the multiplicative inverse of $x$ modulo $y$. If it does not exist, output $-1$.\n\nPS: The multiplicative inverse $k$ can also be understood as: $k$ is the smallest positive integer such that $kx \\equiv 1 \\pmod y$.", "hint": "### Sample Explanation\n\nThe first sample:\n\nCombine two level $1$ books: cost $2$ experience, accumulated cost becomes $3$;  \nThen combine two level $2$ books: cost $3+1=4$ experience, accumulated cost becomes $7$;  \nThen combine two level $3$ books: cost $7+1=8$ experience, accumulated cost becomes $15$;  \nFinally combine two level $4$ books: cost $15+1=16$ experience, accumulated cost becomes $31$.\n\nTotal experience cost: $2+4+8+16=30$, maximum level: $5$.\n\nFor the first sample: $x=5,y=30$.\n\nFor the second sample: $x=3,y=10$.\n\n### Constraints\n\n![]( https://cdn.luogu.com.cn/upload/pic/41547.png )\n\nThe data is guaranteed to be random, and $x,y,k$ are within the range of `long int`.\n\n### Friendly Reminder\n\nThe input size of this problem is large, so please use a fast input method. Here is an example of fast input (requires including the header `<cctype>`):\n\n```cpp\n#include<cctype>\ninline void read(int &x){\n     char ch=getchar();x=0;\n     while(!isdigit(ch))   ch=getchar();\n     while(isdigit(ch))   x=x*10+ch-'0',ch=getchar();\n}\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "经验", "background": "[赛时答疑](https://www.luogu.org/discuss/show/80694)  \n\n**简略版已经更新，时限改为 500ms**。\n\n攒够经验附魔去~~\n\nSteve 在 Minecraft 中总是会遇上难题：\n他想要修理 $n$ 本附魔书，每本附魔书的等级为 $a_i$，他总是不知道铁砧修理和经验值的机制。他便在 wiki 上搜索到了一些资料：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7qa0g8xy.png)\n\n——图为经验值与等级的关系。\n\n他看到这个图，就想：我等级升的越高，我所需要的经验值便越多，那么如果我等级刚好够铁砧修理的话，那我所耗费的经验不就越少了吗？他便继续搜索了下去，并将铁砧机制附在了下面,让你帮他解决问题。", "description": "#### 累积惩罚\n\n无论是重命名、修复、还是合并操作，其经验花费都会因其物品先前在铁砧上的操作而增加，这些额外增加的花费被称作“累积惩罚”。对于一件从未放上铁砧的物品，累积惩罚为 $0$。\n\n一个物品每次在铁砧上操作过后（不包括重命名），其累积惩罚都会先乘 $2$ 再加 $1$。如此一来，一个物品在操作过 $N$ 次后累积惩罚是 $2^N-1$。$6$ 次操作之后，累积惩罚是 $63$ 级，此时生存模式下无法再作进一步的修复和附魔工作。$31$ 次操作后，惩罚等级是 $2147483647$ 级，此时在任何模式下都不能再进行操作。\n\n当合并两个物品时，玩家会同时受到两件物品的累积惩罚。合并后物品的累积惩罚根据先前两个物品中较高者计算。例如，合并两个累积惩罚分别是 $3$ 级和 $15$ 级的物品会额外花费 $18$ 级的惩罚经验，而合并后的物品惩罚是 $31$ 级（$15 \\times 2+1$）。\n\n累积惩罚甚至会作用在不会磨损的物品上，譬如附魔书。因此，合并 $4$ 本时运 I 的附魔书，会得到一本累积惩罚为 $3$ 的时运 III 附魔书。\n\n|累计操作数|惩罚|\n|:--:|:--:|\n|$0$|$0$|\n|$1$|$1$|\n|$2$|$3$|\n|$3$|$7$|\n|$4$|$15$|\n|$5$|$31$|\n\n使用合成方格进行的物品修复操作会移除所有累积惩罚，但也会丢失所有的魔咒。\n\n#### 合并物品\n\n铁砧界面中第一格/左边的物品称为目标物品；第二格/右边的物品称为牺牲物品——合并后会消失。如果牺牲物品附有魔咒，铁砧会同时试图将牺牲物品的附魔合并至目标物品上。无论目标物品上的魔咒是否产生实际变化，铁砧都将根据目标物品与牺牲物品上的魔咒收取玩家的等级耗费。\n\n对于牺牲物品上的每个魔咒来说，如果目标物品也拥有相同的魔咒：\n\n- 当牺牲物品的魔咒等级较高时，目标物品魔咒的等级将上升至牺牲物品上的等级。\n\n- 当牺牲物品的魔咒等级相同时，目标物品上魔咒的等级将提升 $1$ 级，除非其等级已为最高。    \n\n- 当牺牲物品的魔咒等级较低时，目标物品上该魔咒的等级不变。\n    \n合并物品的总花费将是下列费用之和：\n\n1. 目标物品和牺牲物品的累积惩罚之和。\n\n2. 如果同时进行重命名，则额外产生重命名的费用。\n\n3. 如果目标物品耐久度未满，则耗费 $2$ 级用于维修。\n\n4. 如果牺牲物品拥有魔咒，则产生附魔费用。\n\n5. 如果牺牲物品是一本附魔书，则不会产生维修费用，铁砧会尝试将书本上的魔咒合并至目标物品上。亦可同时对目标物品进行重命名。此时的附魔花费一般会少于合并两个类似物品的费用。\n\n——摘自 mcwiki，稍作删改。\n\n#### 简略版\n\n给出附魔书，只有同等等级的才能合并。合并的代价为两本书的累计代价之和。合成后的书的累计代价为合成前最大代价的 $2$ 倍加上 $1$。求最高等级和最小花费（要求最高等级为第一关键字），Steve 因为开了挂，所以最高等级不限。\n\n现给出 $n$ 本附魔书，每本附魔书有它的等级 $a_i$，问如何才能得到附魔书的最大等级 $x$，在此基础上，请计算合成它消耗的最小等级 $y$（我们假设每本附魔书初始的累积惩罚为 $1$）。\n\nSteve 很懒，他不想看上面的话，他只想要让你编写出一个程序计算出 $x$ 与 $y$。但 Steve 为了不外传，他只要求你输出 $x$ 在模 $y$ 意义下的乘法逆元 $k$ 即可。如果没有，请输出 $-1$。", "inputFormat": "第一行为一个整数 $n$。\n\n接下来 $n$ 行，每行均有一个整数 $a_i$，表示每本附魔书的初始等级，不保证数据有序。", "outputFormat": "一个整数 $k$，表示 $x$ 在模 $y$ 意义下的乘法逆元，如果没有，请输出 $-1$。  \n\nPS：乘法逆元 $k$ 也可以这样理解：$k$ 是使得 $kx \\equiv 1 \\pmod y$的最小正整数。", "hint": "### 样例解释\n \n第一个样例：\n\n合并两个第一等级的，合并花费 $2$ 经验，代价升为 $3$；  \n再合并两个第二等级的，花费 $3+1=4$ 经验，代价升为 $7$；  \n再合并两个第三等级的，花费 $7+1=8$ 经验，代价升为 $15$；  \n最后合并两个第四等级的，花费 $15+1=16$ 经验，代价升为 $31$。  \n\n经验总花费：$2+4+8+16=30$，最大等级：$5$。\n\n\n对于第一个样例: $x=5,y=30$；\n\n对于第二个样例: $x=3,y=10$。\n\n### 数据范围\n\n![]( https://cdn.luogu.com.cn/upload/pic/41547.png )\n\n保证数据随机，$x,y,k$ 在 `long int` 范围内。\n\n### 温馨提示\n\n本题读入量较大，请使用较快的读入方法，在此，提供一种快速读入的样式：（需包含头文件 `<cctype>`）\n\n```cpp\n#include<cctype>\ninline void read(int &x){\n     char ch=getchar();x=0;\n     while(!isdigit(ch))   ch=getchar();\n     while(isdigit(ch))   x=x*10+ch-'0',ch=getchar();\n}\n```", "locale": "zh-CN"}}}
{"pid": "P5033", "type": "P", "difficulty": 5, "samples": [["2\n1 4 P\n4 5 P", "1"], ["3\n1 6 P\n2 4 N\n3 4 P", "0"], ["2\n5 8 P\n7 11 P", "qwq"]], "limits": {"time": [100, 100, 100, 100, 100, 100, 100, 100, 100, 100], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP"], "title": "跑酷", "background": "[赛时答疑](https://www.luogu.org/discuss/show/80694)  \n\n跑酷这东西，还是得看人品的（比如 zm 和 mt）…", "description": "在 Minecraft 中，跑酷可以算得上是一门技术了，Steve 现在想在一个跑道上（二维）进行跑酷。但是 Steve 不知道能不能跑到终点，于是他便查询了 MC Wiki，来获得更多的知识。内容具体如下：\n\n### 生命值\n\n1. 我们规定每个玩家的初始生命为 $20$ 点。\n2. 掉落伤害的计算:\n   - 如果玩家的高度为 $3$ 格或以下，免除此伤害。\n   - 如果玩家的高度为 $4$ 格或以上，便会造成 $x-3$ 点伤害，$x$ 为摔落的高度。\n   - 这里的高度均指相对高度，即当前方块与下一个方块之间的高度差。\n3. 掉落伤害降低的情况：见特殊方块。\n\n4. 当生命值为 $0$ 的时候，视为不能到达终点。\n\n### 跑酷\n\n1. 对于站在一个方块上的玩家来说，玩家最多可以往前面跳 $3$ 格并且可以往上跳一个格子。\n2. 对于站在一个方块上的玩家来说，玩家最多也可以往前跳 $4$ 格，但是不能向上跳一个格子。\n3. 为了计算方便，我们规定下落时玩家不会移动，也就是说，如果下一个方块比现在方块的高度要低的话，我们只能正好下落到下一个方块的位置。\n4. 默认终点为最后一个方块。\n\n### 特殊方块\n\n1. **粘液块**：会使你跳跃至 $60\\%$ 坠落距离的高度，如果有小数，我们向下取整。当你达到最高点的时候，只能往前再移动一格。当然，如果落在前方的方块上，同样要受到摔落伤害。你也可以按住 Shift 键来免除反弹。我们认为在粘液块上面进行跑酷不受减速的限制。  \n2. **蜘蛛网**：下落时会让你免除伤害。我们也认为玩家在蜘蛛网上跑酷不受减速的限制。  \n\nSteve 找到了你，让你帮他去解决这个问题。判断 Steve 能不能到达终点。\n\n- 如果能到达终点，输出最少的跳跃次数；\n- 如果不能到达终点，请输出：`qwq`。", "inputFormat": "第一行为一个整数 $n$，表示有 $n$ 个方块。\n\n从第二行开始，下面连续 $n$ 行，表示有 $n$ 个方块。每个方块都有它的属性：横坐标，高度和是否为特殊方块。（普通方块输入为 $\\verb!P!$，粘液块为 $\\verb!N!$，蜘蛛网为 $\\verb!Z!$）\n", "outputFormat": "如果能到达终点，输出一个整数，表示最少的跳跃次数；\n如果不能到达终点，请输出 `qwq`。", "hint": "\n\n### 数据范围及约定\n\n数据保证输入的横坐标单调递增。每一个横坐标只有一格方块。\n\n数据保证不会在相邻的横坐标中间出现两个特殊方块。\n\n对于方块而言，默认是都没有浮空方块的存在；也就是说，所有方块下面都会有支撑柱。\n\n为了方便，不能先跳跃再下落。也就是说，只能下落到前面一格的方块。\n\n对于 $30\\%$ 的数据 $n\\le 10$；  \n对于另外 $20\\%$ 的数据，保证不存在特殊方块；  \n对于这前面的 $50\\%$ 的数据，保证 Steve 往前跳只能跳四格远或者三格远一格高；  \n对于 $100\\%$ 的数据 $1\\le n\\le 1000$，$1\\le x_{\\rm max}\\le 10000$，$1\\le height\\le 1000$。\n\n保证数据有一定梯度。", "locale": "zh-CN", "translations": {"en": {"title": "Parkour.", "background": "[In-contest Q\\&A](https://www.luogu.org/discuss/show/80694)\n\nThis parkour thing still depends on luck (for example, zm and mt)...", "description": "In Minecraft, parkour can be considered a skill. Steve now wants to do parkour on a (2D) track. But Steve does not know whether he can reach the finish, so he checked the MC Wiki to learn more. The details are as follows.\n\n### Health Points\n\n1. We define that each player starts with $20$ health points.\n2. Fall damage calculation:\n   - If the player’s height is $3$ blocks or less, this damage is ignored.\n   - If the player’s height is $4$ blocks or more, it causes $x-3$ damage, where $x$ is the falling height.\n   - The height here is relative height, i.e., the height difference between the current block and the next block.\n3. Cases where fall damage is reduced: see Special Blocks.\n4. When health becomes $0$, it is considered that the finish cannot be reached.\n\n### Parkour\n\n1. For a player standing on a block, the player can jump forward at most $3$ blocks, and can also jump up by $1$ block.\n2. For a player standing on a block, the player can also jump forward at most $4$ blocks, but cannot jump up by $1$ block.\n3. For convenience, we assume the player does not move while falling. That is, if the next block is lower than the current block, we can only fall exactly to the position of the next block.\n4. By default, the finish is the last block.\n\n### Special Blocks\n\n1. **Slime Block**: It will bounce you up to a height equal to $60\\%$ of the falling distance. If there is a decimal part, round down. When you reach the highest point, you can only move forward by one more block. Of course, if you land on a block in front, you will still take fall damage. You can also hold the Shift key to cancel the bounce. We assume that doing parkour on slime blocks is not affected by the slowdown limit.\n2. **Cobweb**: It makes you ignore damage while falling. We also assume that doing parkour on cobwebs is not affected by the slowdown limit.\n\nSteve found you and asked you to solve this problem. Determine whether Steve can reach the finish.\n\n- If he can reach the finish, output the minimum number of jumps.\n- If he cannot reach the finish, output: `qwq`.", "inputFormat": "The first line contains an integer $n$, meaning there are $n$ blocks.\n\nStarting from the second line, the next $n$ lines describe the $n$ blocks. Each block has its attributes: $x$-coordinate, height, and whether it is a special block. (A normal block is given as $\\verb!P!$, a slime block as $\\verb!N!$, and a cobweb as $\\verb!Z!$.)", "outputFormat": "If he can reach the finish, output one integer, the minimum number of jumps.\nIf he cannot reach the finish, output `qwq`.", "hint": "### Constraints and Notes\n\nThe testdata guarantees that the input $x$-coordinates are strictly increasing. Each $x$-coordinate has exactly one block.\n\nThe testdata guarantees that there will not be two special blocks between two adjacent $x$-coordinates.\n\nFor blocks, by default there are no floating blocks; that is, every block has a supporting pillar beneath it.\n\nFor convenience, you cannot jump first and then fall. That is, you can only fall onto the block that is one block ahead.\n\nFor $30\\%$ of the testdata, $n\\le 10$.\nFor another $20\\%$ of the testdata, it is guaranteed that there are no special blocks.\nFor the first $50\\%$ of the testdata, it is guaranteed that Steve’s forward jump can only be either $4$ blocks far, or $3$ blocks far with $1$ block upward.\nFor $100\\%$ of the testdata, $1\\le n\\le 1000$, $1\\le x_{\\rm max}\\le 10000$, $1\\le height\\le 1000$.\n\nThe testdata is guaranteed to have a reasonable difficulty gradient.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "跑酷", "background": "[赛时答疑](https://www.luogu.org/discuss/show/80694)  \n\n跑酷这东西，还是得看人品的（比如 zm 和 mt）…", "description": "在 Minecraft 中，跑酷可以算得上是一门技术了，Steve 现在想在一个跑道上（二维）进行跑酷。但是 Steve 不知道能不能跑到终点，于是他便查询了 MC Wiki，来获得更多的知识。内容具体如下：\n\n### 生命值\n\n1. 我们规定每个玩家的初始生命为 $20$ 点。\n2. 掉落伤害的计算:\n   - 如果玩家的高度为 $3$ 格或以下，免除此伤害。\n   - 如果玩家的高度为 $4$ 格或以上，便会造成 $x-3$ 点伤害，$x$ 为摔落的高度。\n   - 这里的高度均指相对高度，即当前方块与下一个方块之间的高度差。\n3. 掉落伤害降低的情况：见特殊方块。\n\n4. 当生命值为 $0$ 的时候，视为不能到达终点。\n\n### 跑酷\n\n1. 对于站在一个方块上的玩家来说，玩家最多可以往前面跳 $3$ 格并且可以往上跳一个格子。\n2. 对于站在一个方块上的玩家来说，玩家最多也可以往前跳 $4$ 格，但是不能向上跳一个格子。\n3. 为了计算方便，我们规定下落时玩家不会移动，也就是说，如果下一个方块比现在方块的高度要低的话，我们只能正好下落到下一个方块的位置。\n4. 默认终点为最后一个方块。\n\n### 特殊方块\n\n1. **粘液块**：会使你跳跃至 $60\\%$ 坠落距离的高度，如果有小数，我们向下取整。当你达到最高点的时候，只能往前再移动一格。当然，如果落在前方的方块上，同样要受到摔落伤害。你也可以按住 Shift 键来免除反弹。我们认为在粘液块上面进行跑酷不受减速的限制。  \n2. **蜘蛛网**：下落时会让你免除伤害。我们也认为玩家在蜘蛛网上跑酷不受减速的限制。  \n\nSteve 找到了你，让你帮他去解决这个问题。判断 Steve 能不能到达终点。\n\n- 如果能到达终点，输出最少的跳跃次数；\n- 如果不能到达终点，请输出：`qwq`。", "inputFormat": "第一行为一个整数 $n$，表示有 $n$ 个方块。\n\n从第二行开始，下面连续 $n$ 行，表示有 $n$ 个方块。每个方块都有它的属性：横坐标，高度和是否为特殊方块。（普通方块输入为 $\\verb!P!$，粘液块为 $\\verb!N!$，蜘蛛网为 $\\verb!Z!$）\n", "outputFormat": "如果能到达终点，输出一个整数，表示最少的跳跃次数；\n如果不能到达终点，请输出 `qwq`。", "hint": "\n\n### 数据范围及约定\n\n数据保证输入的横坐标单调递增。每一个横坐标只有一格方块。\n\n数据保证不会在相邻的横坐标中间出现两个特殊方块。\n\n对于方块而言，默认是都没有浮空方块的存在；也就是说，所有方块下面都会有支撑柱。\n\n为了方便，不能先跳跃再下落。也就是说，只能下落到前面一格的方块。\n\n对于 $30\\%$ 的数据 $n\\le 10$；  \n对于另外 $20\\%$ 的数据，保证不存在特殊方块；  \n对于这前面的 $50\\%$ 的数据，保证 Steve 往前跳只能跳四格远或者三格远一格高；  \n对于 $100\\%$ 的数据 $1\\le n\\le 1000$，$1\\le x_{\\rm max}\\le 10000$，$1\\le height\\le 1000$。\n\n保证数据有一定梯度。", "locale": "zh-CN"}}}
{"pid": "P5034", "type": "P", "difficulty": 5, "samples": [["3 1\n1\n2 1\n3 2", "1"], ["7 3\nLDLD\ntk_sky LDLD\nJayden_deng LDLD\nonly_xiaohuang tk_sky\nMuddled_xiaopan tk_sky\nInkn only_xiaohuang\nipdjkl only_xiaohuang", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化"], "title": "果冻", "background": "[赛时答疑](https://www.luogu.org/discuss/show/80694)\n\n**数据已经修复**。\n\n【生存世界】Steve：你们哪位 dalao 可以收留我啊 qwq……\n\n在 Minecraft 一个很友善、和谐的服务器里面，Steve 很喜欢在里面畅游，服务器采用小镇机制，于是有很多小镇。有一个镇叫果冻镇，镇长~~长得很像~~喜欢吃果冻，他很喜欢~~对着镜子~~吃着 bling bling 的果冻。突然，他收到“捷报”，镇上不久就要造反。他吓了一跳，赶紧从床上跳了起来（qwq），吃了一口果冻（误），着手处理这件事情。", "description": "镇上有一个镇长以及 $n-1$ 个镇员，所有的镇员都有着他的直属上司 $f_i$。每个镇镇员与镇长都有一个距离 $d_i$（也就是他与镇长之间上司的人数加 $1$）。镇长想要所有镇员都是自己的直属下司，也就是与他的距离为 $1$。\n\n他每分钟可以让自己的一个镇员变为自己的直属下司，在第 $t (t > 0)$ 分钟的时候，（也就是每一分钟的意思，而 $t$ 将从 $1$ 开始），这个镇员变为自己的直属下司，镇长可以收获 $ (d_i+t) \\& k$ 的安全指数（其中，$\\&$ 为按位与运算）。然后**这个镇员的下司都会跟着这个镇员一起变动**（也就是这个镇员的直属下司仍然是这个镇员的，除非镇长把这个下司变为自己的直属下司）。\n\n当所有镇员都是自己的直属下司后，镇长就可以安心吃他的果冻了。他现在想问你，应该怎样变动，才能使安全指数最大。因为镇长很想快点吃到果冻，他就把这个任务交给你了。", "inputFormat": "第一行是两个正整数 $n$ 和 $k$（具体意义请见题目描述）。\n\n从第二行开始，下面连续 $n$ 行，每行有两个字符串（由大写字母、小写字母、下划线、数字、上引号或者逗号组成），分别表示的是这个镇员和他的直属上司。**特别地，第二行是镇长，他没有直属上司，所以第二行只有一个字符串，表示镇长**。数据保证第二个字符串在第一个字符串前出现过。", "outputFormat": "一行一个整数，表示最大的安全值。", "hint": "### 样例解释\n\n第二个样例：（图片有可能会挂，请耐心等待一会哦 qwq）\n![](https://s1.ax1x.com/2018/10/28/ic6RmQ.png)  \n![](https://s1.ax1x.com/2018/10/28/ic6Wwj.png)    \n![](https://s1.ax1x.com/2018/10/28/ic6fTs.png)  \n![](https://s1.ax1x.com/2018/10/28/ic64kn.png)  \n![](https://s1.ax1x.com/2018/10/28/ic6gOg.png)  \n由于~~出题人过懒~~，移动子节点的情况就未列举。请自行 hack 自己。（滑稽）\n\n### 数据范围\n\n记下列两种特殊情况：  \n1. 保证字符串长度为 $1$。\n2. 树退化成一条链。\n![]( https://cdn.luogu.com.cn/upload/pic/39861.png)     \n对于所有的数据，保证 $k$ 在 `int` 范围内，字符串长度不超过 $10^6$。$n,k$ 均为正整数。", "locale": "zh-CN", "translations": {"en": {"title": "Jelly", "background": "[In-contest Q&A](https://www.luogu.org/discuss/show/80694)\n\n**The testdata has been fixed**.\n\n[Survival World] Steve: Is there any dalao who can take me in qwq……\n\nOn a very friendly and harmonious Minecraft server, Steve loves to wander around. The server uses a town system, so there are many towns. One town is called Jelly Town. The mayor ~~looks very similar~~ likes eating jelly, and he loves ~~staring at the mirror~~ eating bling bling jelly. Suddenly, he received “good news” that the town would soon start a rebellion. He was shocked, quickly jumped out of bed (qwq), took a bite of jelly (oops), and started dealing with it.", "description": "There is one mayor in the town and $n-1$ townspeople. Each townsperson has their direct boss $f_i$. Each townsperson has a distance $d_i$ to the mayor (i.e., the number of bosses between them and the mayor plus $1$). The mayor wants every townsperson to become his direct subordinate, i.e., have distance $1$ from him.\n\nEach minute, he can make one townsperson become his direct subordinate. At minute $t (t > 0)$ (i.e., each minute, and $t$ starts from $1$), when this townsperson becomes his direct subordinate, the mayor gains a safety index of $(d_i+t) \\& k$ (where $\\&$ is the bitwise AND operator). Then **all subordinates of this townsperson will move together with this townsperson** (that is, this townsperson’s direct subordinates are still their subordinates, unless the mayor makes one of those subordinates his direct subordinate).\n\nAfter all townspeople become his direct subordinates, the mayor can eat his jelly in peace. Now he wants to ask you: how should he perform the changes to maximize the safety index? Since the mayor wants to eat jelly as soon as possible, he gives this task to you.", "inputFormat": "The first line contains two positive integers $n$ and $k$ (see the description for details).\n\nStarting from the second line, there are $n$ lines. Each line contains two strings (consisting of uppercase letters, lowercase letters, underscores, digits, apostrophes, or commas), representing a townsperson and their direct boss. **In particular, the second line is the mayor. He has no direct boss, so the second line contains only one string, representing the mayor**. The data guarantees that the second string has appeared before the first string.", "outputFormat": "Output one integer in a single line, representing the maximum safety value.", "hint": "### Sample Explanation\n\nThe second sample: (the images may fail to load, please wait a moment qwq)\n![](https://s1.ax1x.com/2018/10/28/ic6RmQ.png)  \n![](https://s1.ax1x.com/2018/10/28/ic6Wwj.png)    \n![](https://s1.ax1x.com/2018/10/28/ic6fTs.png)  \n![](https://s1.ax1x.com/2018/10/28/ic64kn.png)  \nBecause ~~the problem setter is too lazy~~, the cases of moving child nodes are not listed. Please hack yourself. (troll)\n\n### Constraints\n\nNote the following two special cases:  \n1. It is guaranteed that the string length is $1$.\n2. The tree degenerates into a chain.\n![]( https://cdn.luogu.com.cn/upload/pic/39861.png)     \nFor all data, $k$ is guaranteed to be within the `int` range, and the string length does not exceed $10^6$. Both $n$ and $k$ are positive integers.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "果冻", "background": "[赛时答疑](https://www.luogu.org/discuss/show/80694)\n\n**数据已经修复**。\n\n【生存世界】Steve：你们哪位 dalao 可以收留我啊 qwq……\n\n在 Minecraft 一个很友善、和谐的服务器里面，Steve 很喜欢在里面畅游，服务器采用小镇机制，于是有很多小镇。有一个镇叫果冻镇，镇长~~长得很像~~喜欢吃果冻，他很喜欢~~对着镜子~~吃着 bling bling 的果冻。突然，他收到“捷报”，镇上不久就要造反。他吓了一跳，赶紧从床上跳了起来（qwq），吃了一口果冻（误），着手处理这件事情。", "description": "镇上有一个镇长以及 $n-1$ 个镇员，所有的镇员都有着他的直属上司 $f_i$。每个镇镇员与镇长都有一个距离 $d_i$（也就是他与镇长之间上司的人数加 $1$）。镇长想要所有镇员都是自己的直属下司，也就是与他的距离为 $1$。\n\n他每分钟可以让自己的一个镇员变为自己的直属下司，在第 $t (t > 0)$ 分钟的时候，（也就是每一分钟的意思，而 $t$ 将从 $1$ 开始），这个镇员变为自己的直属下司，镇长可以收获 $ (d_i+t) \\& k$ 的安全指数（其中，$\\&$ 为按位与运算）。然后**这个镇员的下司都会跟着这个镇员一起变动**（也就是这个镇员的直属下司仍然是这个镇员的，除非镇长把这个下司变为自己的直属下司）。\n\n当所有镇员都是自己的直属下司后，镇长就可以安心吃他的果冻了。他现在想问你，应该怎样变动，才能使安全指数最大。因为镇长很想快点吃到果冻，他就把这个任务交给你了。", "inputFormat": "第一行是两个正整数 $n$ 和 $k$（具体意义请见题目描述）。\n\n从第二行开始，下面连续 $n$ 行，每行有两个字符串（由大写字母、小写字母、下划线、数字、上引号或者逗号组成），分别表示的是这个镇员和他的直属上司。**特别地，第二行是镇长，他没有直属上司，所以第二行只有一个字符串，表示镇长**。数据保证第二个字符串在第一个字符串前出现过。", "outputFormat": "一行一个整数，表示最大的安全值。", "hint": "### 样例解释\n\n第二个样例：（图片有可能会挂，请耐心等待一会哦 qwq）\n![](https://s1.ax1x.com/2018/10/28/ic6RmQ.png)  \n![](https://s1.ax1x.com/2018/10/28/ic6Wwj.png)    \n![](https://s1.ax1x.com/2018/10/28/ic6fTs.png)  \n![](https://s1.ax1x.com/2018/10/28/ic64kn.png)  \n![](https://s1.ax1x.com/2018/10/28/ic6gOg.png)  \n由于~~出题人过懒~~，移动子节点的情况就未列举。请自行 hack 自己。（滑稽）\n\n### 数据范围\n\n记下列两种特殊情况：  \n1. 保证字符串长度为 $1$。\n2. 树退化成一条链。\n![]( https://cdn.luogu.com.cn/upload/pic/39861.png)     \n对于所有的数据，保证 $k$ 在 `int` 范围内，字符串长度不超过 $10^6$。$n,k$ 均为正整数。", "locale": "zh-CN"}}}
{"pid": "P5035", "type": "P", "difficulty": 2, "samples": [["1", "1"], ["2", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "递推", "2018"], "title": "金坷垃", "background": "[@rainheavy](https://www.luogu.com.cn/user/107646) 原创。\n\n这是一道巨（du）水（liu）题。\n\n第一届中国国际博览会于 2018 年 11.5 ~ 11.10 在上海举行，特朗普统治的国家——美丽国带来了金坷垃。这是一种神奇的产品，据他们的广告所说：肥料用了金坷垃，能吸收 20 米以下的氮磷钾。\n\n可是，在经过富土（tu）康的质检员 DevZhu 质检的时候发现出了点问题，金坷垃的效果并不像广告所说的那样。毕竟植物的根只能到深度为 $1$ 的位置，金坷垃的效果有限。", "description": "它只有如下的效果：（以 $20$ 为例）\n\n$20$ 的真因子有 $10,5,4,2,1$。\n\n从地下 $20$ 米深处可以往上跳一个约数的长度。（比如 $10$）\n\n现在它在 $10$ 米处，$10$ 的真因子有 $5,2,1$。\n\n再跳一个 $5$，为 $5$，$5$ 的真因子有 $1$。\n\n再跳 $1$ 个 $1$，为 $4$，$4$ 的真因子有 $2,1$。\n\n**$1$ 已用过，不能再用**。\n\n再跳一个 $2$，为 $2$。$2$ 的真因子有 $1$。\n\n**$1$ 已用过**，此时没法再跳了。此时的深度为 $2$。\n\n按上述要求跳，把所有符合要求的能跳的所有情况全试一遍，只要有一种情况最后结果为 $1$，这个肥料就合格，否则不合格。\n\nDevZhu 面对一大堆待检验的金坷垃，并不想检验那么多，他想问问你有哪些金坷垃是合格的，在这些合格的金坷垃中，初始深度排在第 $k$ 个的是哪一个。\n\n把合格的金坷垃按初始深度从小到大排，请输出第 $k$ 个金坷垃的初始深度，对 $123456789$ 取模。（富土康从不用 $10^9+7$ 和 $998244353$）", "inputFormat": "一个数 $k$。", "outputFormat": "合格的第 $k$ 个金坷垃的初始深度对 $123456789$ 取模后的结果。", "hint": "（简单死了。。。）\n\n（给不会的人一点福利：有一个数据 $k=1$。）\n\n对于 $30\\%$ 的数据，$k \\le 10^5$；\n\n对于 $70\\%$ 的数据，$k \\le 10^9$；\n\n对于 $100\\%$ 的数据，$k \\le 10^{18}$。", "locale": "zh-CN", "translations": {"en": {"title": "Jinkela", "background": "Originally created by [@rainheavy](https://www.luogu.com.cn/user/107646).\n\nThis is a very (du) easy (liu) problem.\n\nThe 1st China International Import Expo was held in Shanghai from 2018.11.5 to 2018.11.10. The country ruled by Trump, the “beautiful country” (Meiliguo, pinyin), brought Jinkela. This is a magical product. According to their advertisements: if you use Jinkela fertilizer, it can absorb nitrogen, phosphorus, and potassium from depths below 20 meters.\n\nHowever, when it was inspected by the quality inspector DevZhu from “Futukang” (pinyin), some problems were found. The effect of Jinkela was not as the advertisement said. After all, plant roots can only reach depth $1$, so the effect of Jinkela is limited.", "description": "It only has the following effect (take $20$ as an example).\n\nThe proper divisors of $20$ are $10, 5, 4, 2, 1$.\n\nFrom a depth of $20$ meters underground, you can jump upward by a length equal to one divisor. (For example, $10$.)\n\nNow it is at depth $10$ meters. The proper divisors of $10$ are $5, 2, 1$.\n\nJump another $5$ to reach $5$. The proper divisors of $5$ are $1$.\n\nJump $1$ to reach $4$. The proper divisors of $4$ are $2, 1$.\n\n**$1$ has already been used, so it cannot be used again.**\n\nJump another $2$ to reach $2$. The proper divisors of $2$ are $1$.\n\n**$1$ has already been used**, so it cannot jump anymore. The final depth is $2$.\n\nFollowing the rules above, try all possible jump sequences that are allowed. If there exists at least one sequence whose final result is $1$, then this fertilizer is qualified; otherwise it is not qualified.\n\nDevZhu is facing a large pile of Jinkela to be tested and does not want to test so many. He wants to ask which Jinkela are qualified, and among these qualified ones, which one is the $k$-th by initial depth.\n\nSort the qualified Jinkela by initial depth from small to large. Output the initial depth of the $k$-th qualified Jinkela modulo $123456789$. (Futukang never uses $10^9+7$ or $998244353$.)", "inputFormat": "One number $k$.", "outputFormat": "Output the initial depth of the $k$-th qualified Jinkela modulo $123456789$.", "hint": "(It is super easy...)\n\n(A little benefit for those who cannot do it: there is one testdata with $k = 1$.)\n\nConstraints:\n\nFor $30\\%$ of the testdata, $k \\le 10^5$.\n\nFor $70\\%$ of the testdata, $k \\le 10^9$.\n\nFor $100\\%$ of the testdata, $k \\le 10^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "金坷垃", "background": "[@rainheavy](https://www.luogu.com.cn/user/107646) 原创。\n\n这是一道巨（du）水（liu）题。\n\n第一届中国国际博览会于 2018 年 11.5 ~ 11.10 在上海举行，特朗普统治的国家——美丽国带来了金坷垃。这是一种神奇的产品，据他们的广告所说：肥料用了金坷垃，能吸收 20 米以下的氮磷钾。\n\n可是，在经过富土（tu）康的质检员 DevZhu 质检的时候发现出了点问题，金坷垃的效果并不像广告所说的那样。毕竟植物的根只能到深度为 $1$ 的位置，金坷垃的效果有限。", "description": "它只有如下的效果：（以 $20$ 为例）\n\n$20$ 的真因子有 $10,5,4,2,1$。\n\n从地下 $20$ 米深处可以往上跳一个约数的长度。（比如 $10$）\n\n现在它在 $10$ 米处，$10$ 的真因子有 $5,2,1$。\n\n再跳一个 $5$，为 $5$，$5$ 的真因子有 $1$。\n\n再跳 $1$ 个 $1$，为 $4$，$4$ 的真因子有 $2,1$。\n\n**$1$ 已用过，不能再用**。\n\n再跳一个 $2$，为 $2$。$2$ 的真因子有 $1$。\n\n**$1$ 已用过**，此时没法再跳了。此时的深度为 $2$。\n\n按上述要求跳，把所有符合要求的能跳的所有情况全试一遍，只要有一种情况最后结果为 $1$，这个肥料就合格，否则不合格。\n\nDevZhu 面对一大堆待检验的金坷垃，并不想检验那么多，他想问问你有哪些金坷垃是合格的，在这些合格的金坷垃中，初始深度排在第 $k$ 个的是哪一个。\n\n把合格的金坷垃按初始深度从小到大排，请输出第 $k$ 个金坷垃的初始深度，对 $123456789$ 取模。（富土康从不用 $10^9+7$ 和 $998244353$）", "inputFormat": "一个数 $k$。", "outputFormat": "合格的第 $k$ 个金坷垃的初始深度对 $123456789$ 取模后的结果。", "hint": "（简单死了。。。）\n\n（给不会的人一点福利：有一个数据 $k=1$。）\n\n对于 $30\\%$ 的数据，$k \\le 10^5$；\n\n对于 $70\\%$ 的数据，$k \\le 10^9$；\n\n对于 $100\\%$ 的数据，$k \\le 10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P5036", "type": "P", "difficulty": 6, "samples": [["4\n3 2 3 2", "1 2\n1 4\n1 3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "枚举", "连通块"], "title": "随机生成树", "background": "@葛军 改编的水题。", "description": "rainheavy 在纸上画了 $N$ 个点（从 $1$ 到 $N$ 编号），每个点的颜色用一个整数描述。rainheavy 决定用这 $N$ 个点随机生成一棵树，生成的规则如下：\n\n对于 $2$ 号点到 $N$ 号点，每个点随机指定连接一个点。$i$ 号点 $(2 \\le i \\le N)$ 连的点在 $i$ 的约数中和 $i$ 的倍数中不超过 $N$ 的中随机挑选一个。（例如 $N=30$ 时 $10$ 号点的可以连接 $1$ 号，$2$ 号，$5$ 号，$20$ 号，$30$ 号）\n\n生成的树中不能有重边。（不然就不叫树了）\n\n树生成完之后，rainheavy 可以计算出这个树有多少个联通块，一个联通块是一些点的集合，需要满足以下两个条件：\n\n1、从集合中任取两个点都满足：两个点颜色相同，且这两个点之间存在一条树边组成的路径，路径上的所有点都和这两个点颜色相同。\n\n2、对于集合中的任意一个点和集合外的任意一个点：两点要么不同色，要么不存在一条树边组成的路径使得路径上所有点都和这两个点同色。\n\nrainheavy 希望计算出生成的树中联通块个数最多时，需要连接哪些边，但是 rainheavy 太强了，不屑于做这种辣鸡题目，~~更重要的是他要去 AK IOI~~，于是就把题目扔给了你。\n\n注：边的顺序\n\n1. 首先，满足连通块个数最多的优先（即对于生成连通块有贡献的优先）。\n\n2. 同样满足条件 $1$ 时，连接的两个点编号之和较小的边优先。（如满足条件 $1$ 时，连接 $3$ 号点和 $5$ 号点的边比连接 $4$ 号点和 $5$ 号点的边优先）\n\n3. 同时满足条件 $2$ 时，连接的两个点编号的之中较小的一个较小的边优先。（如满足条件2时，连接2号点和6号点的边比连接3号点和5号点的边优先）", "inputFormat": "第一行一个整数 $N$ 代表点数。\n\n第二行 $N$ 个整数，第 $i$ 个整数 $c_i$ 代表第 $i$ 个点的颜色。", "outputFormat": "输出共 $N-1$ 行，每行两个整数 $x,y$ 表示需要一条边连接点 $x$ 和点 $y$。（要求 $x<y$，且输出的顺序满足题目描述中边的顺序）\n\nTip：由于输出较多，建议用快速输出。（不会就算了顶多 T 掉嘛对不对）", "hint": "对于样例的解释：因为 $2$ 号、$4$ 号点会对生成联通块有贡献（$3$ 号你连了也没用），又因为 $1+2 \\lt 1+4$ ，所以 $(1,2)$ 比 $(1,4)$ 优先输出，最后再输出 $(1,3)$。\n\n\n对于 $30\\%$ 的数据，$2 \\le N \\le 10$；  \n对于 $60\\%$ 的数据，$2 \\le N \\le 5000$；  \n对于 $80\\%$ 的数据，$2 \\le N \\le 2 \\times 10^5$；  \n对于 $100\\%$ 的数据，$2 \\le N \\le 5 \\times 10^5,1 \\le c_i \\le 10^9$。（反正多了也没用）", "locale": "zh-CN", "translations": {"en": {"title": "Randomly Generated Tree", "background": "An easy problem adapted by @Gejun.", "description": "Rainheavy drew $N$ points on paper (numbered from $1$ to $N$). The color of each point is described by an integer. Rainheavy decides to randomly generate a tree using these $N$ points. The rules are as follows.\n\nFor points $2$ to $N$, each point randomly chooses one point to connect to. The point that node $i$ $(2 \\le i \\le N)$ connects to is randomly selected from: the divisors of $i$, and the multiples of $i$ that do not exceed $N$. (For example, when $N=30$, node $10$ can connect to node $1$, $2$, $5$, $20$, or $30$.)\n\nThe generated tree cannot have multiple edges. (Otherwise it would not be a tree.)\n\nAfter the tree is generated, Rainheavy can compute how many connected components it has. A connected component is a set of points that must satisfy the following two conditions.\n\n1. For any two points chosen from the set: the two points have the same color, and there exists a path consisting of tree edges between them such that all points on the path have the same color as these two points.\n\n2. For any point inside the set and any point outside the set: the two points are either of different colors, or there does not exist a path consisting of tree edges between them such that all points on the path have the same color as these two points.\n\nRainheavy wants to find, when the number of connected components in the generated tree is maximized, which edges should be connected. However, Rainheavy is too strong and does not bother with such a boring problem. ~~More importantly, he is going to AK IOI~~, so he throws the problem to you.\n\nNote: the order of edges.\n\n1. First, prioritize maximizing the number of connected components (i.e., prioritize edges that contribute to forming connected components).\n\n2. If condition 1 is tied, prioritize the edge with the smaller sum of the two endpoint indices. (For example, under condition 1, the edge connecting node $3$ and node $5$ has higher priority than the edge connecting node $4$ and node $5$.)\n\n3. If condition 2 is also tied, prioritize the edge whose smaller endpoint index is smaller. (For example, under condition 2, the edge connecting node $2$ and node $6$ has higher priority than the edge connecting node $3$ and node $5$.)", "inputFormat": "The first line contains an integer $N$, representing the number of nodes.\n\nThe second line contains $N$ integers. The $i$-th integer $c_i$ represents the color of node $i$.", "outputFormat": "Output a total of $N-1$ lines. Each line contains two integers $x,y$, indicating that an edge should connect node $x$ and node $y$. (It is required that $x<y$, and the output order must satisfy the edge order described in the statement.)\n\nTip: Since the output is large, fast output is recommended. (If you cannot, then forget it, at worst you will get TLE, right.)", "hint": "Explanation for the sample: Because nodes $2$ and $4$ will contribute to forming connected components (connecting node $3$ is useless), and since $1+2 \\lt 1+4$, $(1,2)$ should be output before $(1,4)$, and finally output $(1,3)$.\n\nConstraints:\n\nFor $30\\%$ of the testdata, $2 \\le N \\le 10$.  \nFor $60\\%$ of the testdata, $2 \\le N \\le 5000$.  \nFor $80\\%$ of the testdata, $2 \\le N \\le 2 \\times 10^5$.  \nFor $100\\%$ of the testdata, $2 \\le N \\le 5 \\times 10^5$, $1 \\le c_i \\le 10^9$. (Anyway, bigger is useless.)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "随机生成树", "background": "@葛军 改编的水题。", "description": "rainheavy 在纸上画了 $N$ 个点（从 $1$ 到 $N$ 编号），每个点的颜色用一个整数描述。rainheavy 决定用这 $N$ 个点随机生成一棵树，生成的规则如下：\n\n对于 $2$ 号点到 $N$ 号点，每个点随机指定连接一个点。$i$ 号点 $(2 \\le i \\le N)$ 连的点在 $i$ 的约数中和 $i$ 的倍数中不超过 $N$ 的中随机挑选一个。（例如 $N=30$ 时 $10$ 号点的可以连接 $1$ 号，$2$ 号，$5$ 号，$20$ 号，$30$ 号）\n\n生成的树中不能有重边。（不然就不叫树了）\n\n树生成完之后，rainheavy 可以计算出这个树有多少个联通块，一个联通块是一些点的集合，需要满足以下两个条件：\n\n1、从集合中任取两个点都满足：两个点颜色相同，且这两个点之间存在一条树边组成的路径，路径上的所有点都和这两个点颜色相同。\n\n2、对于集合中的任意一个点和集合外的任意一个点：两点要么不同色，要么不存在一条树边组成的路径使得路径上所有点都和这两个点同色。\n\nrainheavy 希望计算出生成的树中联通块个数最多时，需要连接哪些边，但是 rainheavy 太强了，不屑于做这种辣鸡题目，~~更重要的是他要去 AK IOI~~，于是就把题目扔给了你。\n\n注：边的顺序\n\n1. 首先，满足连通块个数最多的优先（即对于生成连通块有贡献的优先）。\n\n2. 同样满足条件 $1$ 时，连接的两个点编号之和较小的边优先。（如满足条件 $1$ 时，连接 $3$ 号点和 $5$ 号点的边比连接 $4$ 号点和 $5$ 号点的边优先）\n\n3. 同时满足条件 $2$ 时，连接的两个点编号的之中较小的一个较小的边优先。（如满足条件2时，连接2号点和6号点的边比连接3号点和5号点的边优先）", "inputFormat": "第一行一个整数 $N$ 代表点数。\n\n第二行 $N$ 个整数，第 $i$ 个整数 $c_i$ 代表第 $i$ 个点的颜色。", "outputFormat": "输出共 $N-1$ 行，每行两个整数 $x,y$ 表示需要一条边连接点 $x$ 和点 $y$。（要求 $x<y$，且输出的顺序满足题目描述中边的顺序）\n\nTip：由于输出较多，建议用快速输出。（不会就算了顶多 T 掉嘛对不对）", "hint": "对于样例的解释：因为 $2$ 号、$4$ 号点会对生成联通块有贡献（$3$ 号你连了也没用），又因为 $1+2 \\lt 1+4$ ，所以 $(1,2)$ 比 $(1,4)$ 优先输出，最后再输出 $(1,3)$。\n\n\n对于 $30\\%$ 的数据，$2 \\le N \\le 10$；  \n对于 $60\\%$ 的数据，$2 \\le N \\le 5000$；  \n对于 $80\\%$ 的数据，$2 \\le N \\le 2 \\times 10^5$；  \n对于 $100\\%$ 的数据，$2 \\le N \\le 5 \\times 10^5,1 \\le c_i \\le 10^9$。（反正多了也没用）", "locale": "zh-CN"}}}
{"pid": "P5037", "type": "P", "difficulty": 6, "samples": [["1\n5\n2 4\n1 2 3 4 5", "5"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化", "最短路", "素数判断,质数,筛法"], "title": "抓捕", "background": "@葛军  原创\n\n古桥文乃作为一名 OIer，每天勤奋地在洛谷上刷题，然而她的父母却认为他有网瘾，就将她送到了杨叫兽的网戒中心。\n\n![](https://cdn.luogu.com.cn/upload/pic/41018.png )\n\n一年之后，凭借不懈地努力古桥文乃终于逃了出来，并且立刻向警察蜀黍举报杨叫兽的所作所为，了解情况后警察请她带路去网戒中心抓捕杨叫兽。", "description": "啊~~~~！\n\n他们刚到达网戒中心就听到惨叫声从里面传来。古桥文乃在网戒中心呆了一年，对里面的情况很熟悉，立马就知道杨叔又在 $13$ 号治疗室“点现钱”。同时，她知道网戒中心有 $n$ 个房间，任意房间都有走廊相连，每个走廊和房间之间都有门，门是向外锁上的，且在开启后会自动锁上（即每次从房间 $i$ 进入任意一个与其相连的走廊需要花费 $c_i$ 的体力开锁，而从走廊进入房间不用耗费体力）。\n\n杨叔为了防止“盟友”逃跑，在每个房间安装了摄像头，安排了 $n$ 个手下在监控中心看着监控。\n\n**特别的，$\\bf1$ 号房间为监控中心，$\\bf1$ 号手下负责防止任何人（除了杨叔）进入监控中心（否则立刻报告给杨叔）**，其余的 $2$ 号到 $n$ 号手下每人负责监控编号是自己整数倍的房间（例如 $n=10$ 时 $2$ 号手下监控 $2$ 号，$4$ 号，$6$ 号，$8$ 号，$10$ 号房间），$13$ 号治疗室也按照此规则被监控，如果他们其中一个人看到同一个人两次，就会向杨叔报告（但是每一个手下不会互相交流信息），好在这些手下都四肢发达头脑简单，只能记得上一秒的事情。\n\n为了保证抓捕的顺利，古桥文乃和警察不能被发现，现在他们在 $x$ 号房间，$13$ 号治疗室在 $y$ 号房间，已知他们通过每一条走廊要 $1$ 秒，开锁和通过房间不用花费时间（但会被监控室的手下看到），古桥文乃和警察想知道他们在不被发现的情况下最少要花费多少体力才能进入 $13$ 号治疗室。", "inputFormat": "本题多组询问。\n\n第一行一个数 $T$，表示有 $T$ 组询问，第二行一个数 $n$，表示有 $n$ 个房间和手下（不过注意，本题中只读入一次 $n$，这个 $n$ 在每组数据中都是相同的）。\n\n对于每一个询问，第一行两个数：$x,y$，其中 $x$ 表示古桥文乃和警察所在房间的编号，$y$ 表示 $13$ 号治疗室所在房间的编号，接下来一行 $n$ 个数，表示 $c_i$。", "outputFormat": "输出共 $T$ 行，每个询问输出一行，仅一个数，表示在不被发现的情况下最少要花费多少体力才能进入 $13$ 号治疗室，若不能到达输出 $-1$。", "hint": "### 样例解释\n一种可行的方案：$2\\to3\\to4$。\n\n### 数据范围\n\n对于 $30\\%$ 的数据，$n\\leq1500$，$T\\leq15$；\n\n对于 $50\\%$ 的数据，$n\\leq2500$，$T\\leq30$；\n\n对于 $70\\%$ 的数据，$n\\leq4500$，$T\\leq50$；\n\n对于 $100%$ 的数据，$n\\leq4500$，$T\\leq200$，$2\\leq x,y\\leq n$，$c_i\\leq9900$\n\n### 提示：\n\n本题读入可能较多，建议使用快读和 O2 优化。", "locale": "zh-CN", "translations": {"en": {"title": "Capture", "background": "@Ge Jun  Original.\n\nAs an OIer, Fumino Furuhashi works hard on Luogu every day. However, her parents think she is addicted to the Internet, so they send her to Yang Jiaoshou’s Internet Addiction Treatment Center.\n\n![](https://cdn.luogu.com.cn/upload/pic/41018.png )\n\nOne year later, thanks to unremitting effort, Fumino Furuhashi finally escapes. She immediately reports Yang Jiaoshou’s actions to the police. After learning the situation, the police ask her to lead the way to the center to arrest Yang Jiaoshou.", "description": "Ah~~~~！\n\nAs soon as they arrive at the Internet Addiction Treatment Center, they hear screams coming from inside. Fumino Furuhashi has stayed in the center for a year and is very familiar with it, so she immediately knows that Uncle Yang is “counting cash” again in Treatment Room No. $13$. At the same time, she knows the center has $n$ rooms, and any two rooms are connected by corridors. There is a door between each corridor and each room. The doors are locked from the outside, and will automatically lock again after being opened (that is, each time you go from room $i$ into any corridor connected to it, you need to spend $c_i$ stamina to unlock it, while entering a room from a corridor costs no stamina).\n\nTo prevent “allies” from escaping, Uncle Yang installs cameras in every room, and assigns $n$ underlings in the monitoring center to watch the feeds.\n\n**In particular, Room $\\bf1$ is the monitoring center. Underling $\\bf1$ is responsible for preventing anyone (except Uncle Yang) from entering the monitoring center (otherwise he reports to Uncle Yang immediately).** The other underlings from No. $2$ to No. $n$ each monitor rooms whose numbers are integer multiples of their own number (for example, when $n=10$, underling No. $2$ monitors Rooms No. $2$, $4$, $6$, $8$, $10$). Treatment Room No. $13$ is also monitored by this rule. If any one of them sees the same person twice, they will report to Uncle Yang (but the underlings do not share information with each other). Fortunately, these underlings are strong but simple-minded, and can only remember what happened in the previous second.\n\nTo ensure the arrest goes smoothly, Fumino Furuhashi and the police must not be discovered. They are currently in Room $x$, and Treatment Room No. $13$ is in Room $y$. It is known that passing through each corridor takes $1$ second, and unlocking doors and passing through rooms takes no time (but will be seen by the underlings in the monitoring center). Fumino Furuhashi and the police want to know the minimum stamina needed to enter Treatment Room No. $13$ without being discovered.", "inputFormat": "This problem has multiple queries.\n\nThe first line contains an integer $T$, meaning there are $T$ queries. The second line contains an integer $n$, meaning there are $n$ rooms and underlings (note that in this problem, $n$ is read only once, and this $n$ is the same for every query).\n\nFor each query, the first line contains two integers: $x,y$, where $x$ is the room number where Fumino Furuhashi and the police are, and $y$ is the room number of Treatment Room No. $13$. The next line contains $n$ integers, representing $c_i$.", "outputFormat": "Output $T$ lines in total. For each query, output one line with one integer, meaning the minimum stamina needed to enter Treatment Room No. $13$ without being discovered. If it is impossible to reach, output $-1$.", "hint": "### Sample Explanation\n\nOne feasible plan is: $2\\to3\\to4$.\n\n### Constraints\n\nFor $30\\%$ of the testdata, $n\\leq1500$, $T\\leq15$.\n\nFor $50\\%$ of the testdata, $n\\leq2500$, $T\\leq30$.\n\nFor $70\\%$ of the testdata, $n\\leq4500$, $T\\leq50$.\n\nFor $100\\%$ of the testdata, $n\\leq4500$, $T\\leq200$, $2\\leq x,y\\leq n$, $c_i\\leq9900$.\n\n### Note\n\nThe input size may be large. Fast input and O2 optimization are recommended.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "抓捕", "background": "@葛军  原创\n\n古桥文乃作为一名 OIer，每天勤奋地在洛谷上刷题，然而她的父母却认为他有网瘾，就将她送到了杨叫兽的网戒中心。\n\n![](https://cdn.luogu.com.cn/upload/pic/41018.png )\n\n一年之后，凭借不懈地努力古桥文乃终于逃了出来，并且立刻向警察蜀黍举报杨叫兽的所作所为，了解情况后警察请她带路去网戒中心抓捕杨叫兽。", "description": "啊~~~~！\n\n他们刚到达网戒中心就听到惨叫声从里面传来。古桥文乃在网戒中心呆了一年，对里面的情况很熟悉，立马就知道杨叔又在 $13$ 号治疗室“点现钱”。同时，她知道网戒中心有 $n$ 个房间，任意房间都有走廊相连，每个走廊和房间之间都有门，门是向外锁上的，且在开启后会自动锁上（即每次从房间 $i$ 进入任意一个与其相连的走廊需要花费 $c_i$ 的体力开锁，而从走廊进入房间不用耗费体力）。\n\n杨叔为了防止“盟友”逃跑，在每个房间安装了摄像头，安排了 $n$ 个手下在监控中心看着监控。\n\n**特别的，$\\bf1$ 号房间为监控中心，$\\bf1$ 号手下负责防止任何人（除了杨叔）进入监控中心（否则立刻报告给杨叔）**，其余的 $2$ 号到 $n$ 号手下每人负责监控编号是自己整数倍的房间（例如 $n=10$ 时 $2$ 号手下监控 $2$ 号，$4$ 号，$6$ 号，$8$ 号，$10$ 号房间），$13$ 号治疗室也按照此规则被监控，如果他们其中一个人看到同一个人两次，就会向杨叔报告（但是每一个手下不会互相交流信息），好在这些手下都四肢发达头脑简单，只能记得上一秒的事情。\n\n为了保证抓捕的顺利，古桥文乃和警察不能被发现，现在他们在 $x$ 号房间，$13$ 号治疗室在 $y$ 号房间，已知他们通过每一条走廊要 $1$ 秒，开锁和通过房间不用花费时间（但会被监控室的手下看到），古桥文乃和警察想知道他们在不被发现的情况下最少要花费多少体力才能进入 $13$ 号治疗室。", "inputFormat": "本题多组询问。\n\n第一行一个数 $T$，表示有 $T$ 组询问，第二行一个数 $n$，表示有 $n$ 个房间和手下（不过注意，本题中只读入一次 $n$，这个 $n$ 在每组数据中都是相同的）。\n\n对于每一个询问，第一行两个数：$x,y$，其中 $x$ 表示古桥文乃和警察所在房间的编号，$y$ 表示 $13$ 号治疗室所在房间的编号，接下来一行 $n$ 个数，表示 $c_i$。", "outputFormat": "输出共 $T$ 行，每个询问输出一行，仅一个数，表示在不被发现的情况下最少要花费多少体力才能进入 $13$ 号治疗室，若不能到达输出 $-1$。", "hint": "### 样例解释\n一种可行的方案：$2\\to3\\to4$。\n\n### 数据范围\n\n对于 $30\\%$ 的数据，$n\\leq1500$，$T\\leq15$；\n\n对于 $50\\%$ 的数据，$n\\leq2500$，$T\\leq30$；\n\n对于 $70\\%$ 的数据，$n\\leq4500$，$T\\leq50$；\n\n对于 $100%$ 的数据，$n\\leq4500$，$T\\leq200$，$2\\leq x,y\\leq n$，$c_i\\leq9900$\n\n### 提示：\n\n本题读入可能较多，建议使用快读和 O2 优化。", "locale": "zh-CN"}}}
{"pid": "P5038", "type": "P", "difficulty": 6, "samples": [["2 \n2 2 \n1 2 \n2 3 \n3 3 \n1 2 3 \n2 3 4 \n4 3 2 ", "2 \n-1 \n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "四川", "二分", "各省省选", "网络流"], "title": "[SCOI2012] 奇怪的游戏", "background": "", "description": "Blinker 最近喜欢上一个奇怪的游戏。 \n\n这个游戏在一个 $N \\times M$ 的棋盘上玩，每个格子有一个数。每次 Blinker 会选择两个相邻的格子，并使这两个数都加上 $1$。 \n\n现在 Blinker 想知道最少多少次能使棋盘上的数都变成同一个数，如果永远不能变成同一个数则输出 $-1$。 ", "inputFormat": "输入的第一行是一个整数 $T$，表示输入数据有 $T$ 轮游戏组成。 \n\n每轮游戏的第一行有两个整数 $N$ 和 $M$，分别代表棋盘的行数和列数。  \n接下来有 $N$ 行，每行 $M$ 个数。 ", "outputFormat": "对于每个游戏输出最少能使游戏结束的次数，如果永远不能变成同一个数则输出 $-1$。", "hint": "对于 $30\\%$ 的数据，保证 $ T\\le 10,1\\le N,M \\le 8$。   \n对于 $100\\%$ 的数据，保证 $T \\le 10,1 \\le N,M\\le 40$，所有数为正整数且小于 $10^9$。 ", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2012] Strange Game", "background": "", "description": "Blinker has recently become interested in a strange game.\n\nThe game is played on an $N \\times M$ board, and each cell contains a number. Each time, Blinker chooses two adjacent cells and increases both numbers by $1$.\n\nNow Blinker wants to know the minimum number of moves needed to make all numbers on the board become the same. If it can never become the same, output $-1$.", "inputFormat": "The first line contains an integer $T$, meaning the input consists of $T$ rounds of the game.\n\nIn each round, the first line contains two integers $N$ and $M$, representing the number of rows and columns of the board.  \nThen follow $N$ lines, each containing $M$ numbers.", "outputFormat": "For each round, output the minimum number of moves needed to finish the game. If it can never become the same number, output $-1$.", "hint": "For $30\\%$ of the testdata, it is guaranteed that $T \\le 10$ and $1 \\le N, M \\le 8$.  \nFor $100\\%$ of the testdata, it is guaranteed that $T \\le 10$ and $1 \\le N, M \\le 40$. All numbers are positive integers and less than $10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2012] 奇怪的游戏", "background": "", "description": "Blinker 最近喜欢上一个奇怪的游戏。 \n\n这个游戏在一个 $N \\times M$ 的棋盘上玩，每个格子有一个数。每次 Blinker 会选择两个相邻的格子，并使这两个数都加上 $1$。 \n\n现在 Blinker 想知道最少多少次能使棋盘上的数都变成同一个数，如果永远不能变成同一个数则输出 $-1$。 ", "inputFormat": "输入的第一行是一个整数 $T$，表示输入数据有 $T$ 轮游戏组成。 \n\n每轮游戏的第一行有两个整数 $N$ 和 $M$，分别代表棋盘的行数和列数。  \n接下来有 $N$ 行，每行 $M$ 个数。 ", "outputFormat": "对于每个游戏输出最少能使游戏结束的次数，如果永远不能变成同一个数则输出 $-1$。", "hint": "对于 $30\\%$ 的数据，保证 $ T\\le 10,1\\le N,M \\le 8$。   \n对于 $100\\%$ 的数据，保证 $T \\le 10,1 \\le N,M\\le 40$，所有数为正整数且小于 $10^9$。 ", "locale": "zh-CN"}}}
{"pid": "P5039", "type": "P", "difficulty": 6, "samples": [["4 6 1\n1 2 2\n1 3 2\n1 4 3\n2 3 2\n2 4 4\n3 4 5", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2010", "各省省选", "上海"], "title": "[SHOI2010] 最小生成树", "background": "", "description": "Secsa最近对最小生成树问题特别感兴趣。他已经知道如果要去求出一个 $ n $ 个点、 $ m $ 条边的无向图的最小生成树有一个Krustal算法和另一个Prim的算法。另外，他还知道，某一个图可能有多种不同的最小生成树。例如，下面图3中所示的都是图2中的无向图的最小生成树：\n\n![](https://cdn.luogu.com.cn/upload/pic/43631.png)\n\n当然啦，这些都不是今天需要你解决的问题。Secsa想知道对于某一条无向图中的边AB，至少需要多少代价可以保证AB边在这个无向图的最小生成树中。为了使得AB边一定在最小生成树中，你可以对这个无向图进行操作，一次单独的操作是指：先选择一条图中的边 P1P2，再把图中除了这条边以外的边，每一条的权值都减少 $ 1 $ 。如图4所示就是一次这样的操作：\n\n![](https://cdn.luogu.com.cn/upload/pic/43632.png)\n\n", "inputFormat": "输入文件的第一行有3个正整数 $ n,m,Lab $ 分别表示无向图中的点数、边数、必须要在最小生成树中出现的AB边的标号。\n\n接下来 $ m $ 行依次描述标号为 $ 1,2,3 \\ldots m $ 的无向边，每行描述一条边。每个描述包含3个整数 $ x,y,d $ ，表示这条边连接着标号为 $ x,y $ 的点，且这条边的权值为 $ d $ 。\n\n输入文件保证 $ 1 \\leq x,y \\leq N $ ， $ x \\neq y $ ，且输入数据保证这个无向图一定是一个连通图。", "outputFormat": "输出文件只有一行，这行只有一个整数，即，使得标号为 $ Lab $ 边一定出现最小生成树中的最少操作次数。", "hint": "$ 1 \\leq N \\leq 500,1 \\leq M \\leq 800,1 \\leq d<10^6 $", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2010] Minimum Spanning Tree", "background": "", "description": "Secsa has recently become very interested in the minimum spanning tree problem. He already knows that to find the minimum spanning tree of an undirected graph with $n$ vertices and $m$ edges, there is the Krustal algorithm and another Prim algorithm. He also knows that a graph may have several different minimum spanning trees. For example, all the graphs shown in Figure 3 below are minimum spanning trees of the undirected graph in Figure 2:\n\n![](https://cdn.luogu.com.cn/upload/pic/43631.png)\n\nOf course, these are not what you need to solve today. Secsa wants to know, for a certain edge $AB$ in an undirected graph, at least how much cost is needed to guarantee that edge $AB$ is in the minimum spanning tree of this undirected graph. To make sure that edge $AB$ must be in the minimum spanning tree, you may perform operations on this undirected graph. A single operation is defined as follows: first choose an edge $P1P2$ in the graph, then decrease the weight of every edge except this one by $1$. Figure 4 shows one such operation:\n\n![](https://cdn.luogu.com.cn/upload/pic/43632.png)", "inputFormat": "The first line of the input file contains three positive integers $n, m, Lab$, which represent the number of vertices, the number of edges, and the index of the edge $AB$ that must appear in the minimum spanning tree.\n\nThe next $m$ lines describe the undirected edges with indices $1, 2, 3 \\ldots m$ in order, one edge per line. Each line contains three integers $x, y, d$, meaning this edge connects vertices $x$ and $y$, and its weight is $d$.\n\nThe input guarantees that $1 \\leq x, y \\leq N$, $x \\neq y$, and the undirected graph is connected.", "outputFormat": "The output file contains only one line with one integer: the minimum number of operations required to ensure that the edge with index $Lab$ must appear in the minimum spanning tree.", "hint": "Constraints: $1 \\leq N \\leq 500$, $1 \\leq M \\leq 800$, $1 \\leq d < 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2010] 最小生成树", "background": "", "description": "Secsa最近对最小生成树问题特别感兴趣。他已经知道如果要去求出一个 $ n $ 个点、 $ m $ 条边的无向图的最小生成树有一个Krustal算法和另一个Prim的算法。另外，他还知道，某一个图可能有多种不同的最小生成树。例如，下面图3中所示的都是图2中的无向图的最小生成树：\n\n![](https://cdn.luogu.com.cn/upload/pic/43631.png)\n\n当然啦，这些都不是今天需要你解决的问题。Secsa想知道对于某一条无向图中的边AB，至少需要多少代价可以保证AB边在这个无向图的最小生成树中。为了使得AB边一定在最小生成树中，你可以对这个无向图进行操作，一次单独的操作是指：先选择一条图中的边 P1P2，再把图中除了这条边以外的边，每一条的权值都减少 $ 1 $ 。如图4所示就是一次这样的操作：\n\n![](https://cdn.luogu.com.cn/upload/pic/43632.png)\n\n", "inputFormat": "输入文件的第一行有3个正整数 $ n,m,Lab $ 分别表示无向图中的点数、边数、必须要在最小生成树中出现的AB边的标号。\n\n接下来 $ m $ 行依次描述标号为 $ 1,2,3 \\ldots m $ 的无向边，每行描述一条边。每个描述包含3个整数 $ x,y,d $ ，表示这条边连接着标号为 $ x,y $ 的点，且这条边的权值为 $ d $ 。\n\n输入文件保证 $ 1 \\leq x,y \\leq N $ ， $ x \\neq y $ ，且输入数据保证这个无向图一定是一个连通图。", "outputFormat": "输出文件只有一行，这行只有一个整数，即，使得标号为 $ Lab $ 边一定出现最小生成树中的最少操作次数。", "hint": "$ 1 \\leq N \\leq 500,1 \\leq M \\leq 800,1 \\leq d<10^6 $", "locale": "zh-CN"}}}
{"pid": "P5040", "type": "P", "difficulty": 4, "samples": [["2  3", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2006", "四川", "各省省选", "Special Judge"], "title": "[SCOI2006] k进制集合的映射", "background": "", "description": "设$A(N,K)$是全体$N$位$K$进制整数$a$的集合（$a$的高位可以为$0$，例如，$0023$可看作一个$4$位$8$进制数，或一个$4$位$5$进制数，由题中指定的条件可以唯一确定），其中$2≤K≤6000$，$N=2$，$3$，$4$，即:$$A(N,K)={a|a=a_1a_2a_3\\cdots a_N,0≤a_i≤K-1,i=1,\\cdots,N}$$\n\n设$D(N-1,K)$是$A(N-1,K)$的一个子集，它是由$A(N,K)$生成的一个$N-1$位$K$进制整数$d$的集合，**生成规则如下**:\n\n对任何$d\\in D(N-1,K)$，存在$a\\in A(N,K)$，使$d=Image(a)$，其中，$d=d_1d_2\\cdots d_{N-1},d_i=min(a_i,a_{i+1})$，即$d_i$取为$a_i,a_{i+1}$的最小值。\n\n注1：我们称这个规则为$A(N,K)$ 到$A(N-1,K)$内的一个映射$d=Image(a)$，可以证明这个映射是多对一的，即：如果$d,e\\in D(N-1,k)$且$d\\not=e$，则对任何满足$d=Image(a),e=Image(c)$的$A(N,K)$中的元素$a,c$，均有$a\\not=c$\n \n注2：对某些$K,N$, $D(N-1,K)$是$A(N-1,K)$的一个真子集，例如$K=4,N=4$，则不存在$a\\in A(4,4)$，使$Image(a)=(323)$\n\n**任务**：从文本文件输入两个用空格隔开的整数 $N,K$，然后在指定的文本文件中输出下列表达式的值：\n\n$$f(N,K)=\\sum_{a\\in A(N,K),Image(a)=d}(\\prod_{i=1}^{N-1}(d_i+1))$$\n\n上式表示对$A(N,K)$中的全部元素$a$，对其映像$d=Image(a)=d_1d_2\\cdots d_{N-1}$的各位数字加$1$后的乘积求和。\n\n其中$\\prod^{N-1}_{i=1}(d_i+1)=(d_1+1)(d_2+1)\\cdots(d_{N-1}+1)$\n\n**例**：设$N=2,K=3$，则$A(N,K)={00,01,02,11,10,12,20,21,22}$，正确的输出结果应为$14$。\n\n**提示**：应先建立相应的计算方法，直接利用$f(N,K)$的表达式计算会使多数测试超时。", "inputFormat": "输入文件只有一行：用空格隔开的两个整数N  k。", "outputFormat": "输出文件只有一个大整数，为计算结果。", "hint": "**关于测试的说明**：\n\n数字完全正确，给满分。当输出结果的位数超过$15$位时，如果仅最后两位不准确时给一半分。（每个需测试的计算结果不超过$10^{19}$）。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2006] Mapping of Sets in Base $K$", "background": "", "description": "Let $A(N,K)$ be the set of all $N$-digit base-$K$ integers $a$ (the most significant digit of $a$ may be $0$; for example, $0023$ can be regarded as a $4$-digit base-$8$ number or a $4$-digit base-$5$ number. Under the conditions specified in the problem, it can be uniquely determined), where $2 \\le K \\le 6000$ and $N = 2, 3, 4$. That is,\n$$A(N,K)={a|a=a_1a_2a_3\\cdots a_N,0≤a_i≤K-1,i=1,\\cdots,N}$$\n\nLet $D(N-1,K)$ be a subset of $A(N-1,K)$. It is the set of $(N-1)$-digit base-$K$ integers $d$ generated from $A(N,K)$. **The generation rule is as follows**:\n\nFor any $d \\in D(N-1,K)$, there exists $a \\in A(N,K)$ such that $d = Image(a)$, where $d = d_1d_2\\cdots d_{N-1}$ and $d_i = min(a_i,a_{i+1})$. That is, $d_i$ is the smaller one of $a_i$ and $a_{i+1}$.\n\nNote 1: We call this rule a mapping from $A(N,K)$ to $A(N-1,K)$, written as $d = Image(a)$. It can be proven that this mapping is many-to-one. That is, if $d,e \\in D(N-1,k)$ and $d \\not= e$, then for any elements $a,c \\in A(N,K)$ satisfying $d = Image(a)$ and $e = Image(c)$, we have $a \\not= c$.\n\nNote 2: For some $K,N$, $D(N-1,K)$ is a proper subset of $A(N-1,K)$. For example, when $K=4,N=4$, there does not exist any $a \\in A(4,4)$ such that $Image(a)=(323)$.\n\n**Task**: Read two integers $N,K$ separated by a space from the input text file, and then output the value of the following expression to the specified output text file:\n\n$$f(N,K)=\\sum_{a\\in A(N,K),Image(a)=d}(\\prod_{i=1}^{N-1}(d_i+1))$$\n\nThe expression above means: for all elements $a$ in $A(N,K)$, let its image be $d = Image(a) = d_1d_2\\cdots d_{N-1}$, add $1$ to each digit of $d$, take the product, and then sum these products.\n\nWhere\n$$\\prod^{N-1}_{i=1}(d_i+1)=(d_1+1)(d_2+1)\\cdots(d_{N-1}+1)$$\n\n**Example**: Let $N=2,K=3$. Then $A(N,K)={00,01,02,11,10,12,20,21,22}$, and the correct output should be $14$.\n\n**Hint**: You should first build a suitable method for computation. Directly computing using the expression of $f(N,K)$ will cause most testdata to time out.", "inputFormat": "The input file contains only one line: two integers $N$ and $K$ separated by a space.", "outputFormat": "Output a single big integer, which is the computed result.", "hint": "**About the tests**:\n\nFull marks are given if the number is completely correct. When the number of digits of the output exceeds $15$, if only the last two digits are incorrect, half of the score is given. (Each required result does not exceed $10^{19}$.)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2006] k进制集合的映射", "background": "", "description": "设$A(N,K)$是全体$N$位$K$进制整数$a$的集合（$a$的高位可以为$0$，例如，$0023$可看作一个$4$位$8$进制数，或一个$4$位$5$进制数，由题中指定的条件可以唯一确定），其中$2≤K≤6000$，$N=2$，$3$，$4$，即:$$A(N,K)={a|a=a_1a_2a_3\\cdots a_N,0≤a_i≤K-1,i=1,\\cdots,N}$$\n\n设$D(N-1,K)$是$A(N-1,K)$的一个子集，它是由$A(N,K)$生成的一个$N-1$位$K$进制整数$d$的集合，**生成规则如下**:\n\n对任何$d\\in D(N-1,K)$，存在$a\\in A(N,K)$，使$d=Image(a)$，其中，$d=d_1d_2\\cdots d_{N-1},d_i=min(a_i,a_{i+1})$，即$d_i$取为$a_i,a_{i+1}$的最小值。\n\n注1：我们称这个规则为$A(N,K)$ 到$A(N-1,K)$内的一个映射$d=Image(a)$，可以证明这个映射是多对一的，即：如果$d,e\\in D(N-1,k)$且$d\\not=e$，则对任何满足$d=Image(a),e=Image(c)$的$A(N,K)$中的元素$a,c$，均有$a\\not=c$\n \n注2：对某些$K,N$, $D(N-1,K)$是$A(N-1,K)$的一个真子集，例如$K=4,N=4$，则不存在$a\\in A(4,4)$，使$Image(a)=(323)$\n\n**任务**：从文本文件输入两个用空格隔开的整数 $N,K$，然后在指定的文本文件中输出下列表达式的值：\n\n$$f(N,K)=\\sum_{a\\in A(N,K),Image(a)=d}(\\prod_{i=1}^{N-1}(d_i+1))$$\n\n上式表示对$A(N,K)$中的全部元素$a$，对其映像$d=Image(a)=d_1d_2\\cdots d_{N-1}$的各位数字加$1$后的乘积求和。\n\n其中$\\prod^{N-1}_{i=1}(d_i+1)=(d_1+1)(d_2+1)\\cdots(d_{N-1}+1)$\n\n**例**：设$N=2,K=3$，则$A(N,K)={00,01,02,11,10,12,20,21,22}$，正确的输出结果应为$14$。\n\n**提示**：应先建立相应的计算方法，直接利用$f(N,K)$的表达式计算会使多数测试超时。", "inputFormat": "输入文件只有一行：用空格隔开的两个整数N  k。", "outputFormat": "输出文件只有一个大整数，为计算结果。", "hint": "**关于测试的说明**：\n\n数字完全正确，给满分。当输出结果的位数超过$15$位时，如果仅最后两位不准确时给一半分。（每个需测试的计算结果不超过$10^{19}$）。", "locale": "zh-CN"}}}
{"pid": "P5041", "type": "P", "difficulty": 5, "samples": [["SHLLZSHZS", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "河南", "各省省选"], "title": "[HAOI2009] 求回文串", "background": "", "description": "所谓回文串，就是对于给定的字符串，正着读和反着读都一样，比如 ABCBA 就是一个回文串，ABCAB 则不是。我们的目标是对于任意输入的字符串，不断将第 $i$ 个字符和第 $i+1$ 个字符交换，使得该串最终变为回文串。求最少交换次数。", "inputFormat": "一个由大写字母字母组成的字符串。", "outputFormat": "若能经过有限次操作能将原串变为回文串，则输出最少操作次数；否则输出 $-1$。", "hint": "### 样例说明\n\n1. 交换 $\\tt L$ 和 $\\tt Z$ 变成 $\\tt SHLZLSHZS$；\n2. 交换 $\\tt L$ 和 $\\tt Z$ 变成 $\\tt SHZLLSHZS$；\n3. 交换 $\\tt L$ 和 $\\tt S$ 变成 $\\tt SHZLSLHZS$；\n4. 交换 $\\tt H$ 和 $\\tt Z$ 变成 $\\tt SHZLSLZHS$。\n\n### 数据范围\n\n- $40\\%$ 的数据，长度 $\\leq50000$；\n- $100\\%$ 的数据，长度 $\\leq10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2009] Make a Palindrome", "background": "", "description": "A palindrome is a string that reads the same forwards and backwards. For example, ABCBA is a palindrome, while ABCAB is not. Given any input string, you may repeatedly swap the $i$-th character with the $(i+1)$-th character to eventually make the string a palindrome. Find the minimum number of swaps.", "inputFormat": "A string consisting of uppercase letters.", "outputFormat": "If it can be transformed into a palindrome by a finite number of operations, output the minimum number of operations; otherwise output $-1$.", "hint": "Sample Explanation:\n1. Swap $\\tt L$ and $\\tt Z$ to get $\\tt SHLZLSHZS$.\n2. Swap $\\tt L$ and $\\tt Z$ to get $\\tt SHZLLSHZS$.\n3. Swap $\\tt L$ and $\\tt S$ to get $\\tt SHZLSLHZS$.\n4. Swap $\\tt H$ and $\\tt Z$ to get $\\tt SHZLSLZHS$.\n\nConstraints:\n- For $40\\%$ of the testdata, length $\\leq50000$.\n- For $100\\%$ of the testdata, length $\\leq10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2009] 求回文串", "background": "", "description": "所谓回文串，就是对于给定的字符串，正着读和反着读都一样，比如 ABCBA 就是一个回文串，ABCAB 则不是。我们的目标是对于任意输入的字符串，不断将第 $i$ 个字符和第 $i+1$ 个字符交换，使得该串最终变为回文串。求最少交换次数。", "inputFormat": "一个由大写字母字母组成的字符串。", "outputFormat": "若能经过有限次操作能将原串变为回文串，则输出最少操作次数；否则输出 $-1$。", "hint": "### 样例说明\n\n1. 交换 $\\tt L$ 和 $\\tt Z$ 变成 $\\tt SHLZLSHZS$；\n2. 交换 $\\tt L$ 和 $\\tt Z$ 变成 $\\tt SHZLLSHZS$；\n3. 交换 $\\tt L$ 和 $\\tt S$ 变成 $\\tt SHZLSLHZS$；\n4. 交换 $\\tt H$ 和 $\\tt Z$ 变成 $\\tt SHZLSLZHS$。\n\n### 数据范围\n\n- $40\\%$ 的数据，长度 $\\leq50000$；\n- $100\\%$ 的数据，长度 $\\leq10^6$。", "locale": "zh-CN"}}}
{"pid": "P5042", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2015", "集训队互测"], "title": "[集训队互测 2015] 丢失的题面（ydc的题面）", "background": null, "description": "曾经，有一个题面摆在 ydc 的面前没有珍惜，直到失去时才后悔莫及，\n\n如果上天再给他一次机会，ydc 一定会牢牢的记住这个题面。\n\n没办法，已经失去了，所以这道题只能让你帮 ydc 做了。\n\n已知的信息只有，这道题是传统题，采用全文比较的方式，时间限制 1s，空间限制 256MB。\n\nydc 还给你提供了这道题的所有数据（见附件）。", "inputFormat": "已给出", "outputFormat": "已给出", "hint": "### 来源\n\n中国国家集训队互测2015 \n\n### Author\n\n于纪平", "locale": "zh-CN", "translations": {"en": {"title": "[CTT Mutual Test 2015] The Lost Problem Statement (ydc’s statement).", "background": "", "description": "Once, there was a problem statement placed in front of ydc, but he did not cherish it, and only felt deep regret after it was lost.\n\nIf Heaven could give him one more chance, ydc would definitely remember this problem statement firmly.\n\nBut there is no way—since it has already been lost, this problem can only be done with your help for ydc.\n\nThe only information known is that this is a traditional problem, it uses full-text comparison, the time limit is 1 s, and the memory limit is 256 MB.\n\nydc also provides you with all the testdata for this problem (see the attachment).", "inputFormat": "Already given.", "outputFormat": "Already given.", "hint": "### Source\n\nChina National CTT Mutual Test 2015.\n\n### Author\n\nYu Jiping.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[集训队互测 2015] 丢失的题面（ydc的题面）", "background": null, "description": "曾经，有一个题面摆在 ydc 的面前没有珍惜，直到失去时才后悔莫及，\n\n如果上天再给他一次机会，ydc 一定会牢牢的记住这个题面。\n\n没办法，已经失去了，所以这道题只能让你帮 ydc 做了。\n\n已知的信息只有，这道题是传统题，采用全文比较的方式，时间限制 1s，空间限制 256MB。\n\nydc 还给你提供了这道题的所有数据（见附件）。", "inputFormat": "已给出", "outputFormat": "已给出", "hint": "### 来源\n\n中国国家集训队互测2015 \n\n### Author\n\n于纪平", "locale": "zh-CN"}}}
{"pid": "P5043", "type": "P", "difficulty": 5, "samples": [["4 \n4 0 1 1 2 \n4 2 0 2 3 \n4 0 1 1 1 \n4 0 1 2 3 ", "1 \n1 \n3 \n1 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["图论", "2015", "各省省选", "北京", "哈希 hashing", "模板题"], "title": "【模板】树同构 / [BJOI2015] 树的同构", "background": null, "description": "树是一种很常见的数据结构。\n\n我们把 $N$ 个点，$N-1$ 条边的连通无向图称为树。\n\n若将某个点作为根，从根开始遍历，则其它的点都有一个前驱，这个树就成为有根树。\n\n对于两个树 $T_1$ 和 $T_2$，如果能够把树 $T_1$ 的所有点重新标号，使得树 $T_1$ 和树 $T_2$ 完全相同，那么这两个树是同构的。也就是说，它们具有相同的形态。\n\n现在，给你 $M$ 个无根树，请你把它们按同构关系分成若干个等价类。", "inputFormat": "第一行，一个整数 $M$。\n\n接下来 $M$ 行，每行包含若干个整数，表示一个树。第一个整数 $N$表示点数。接下来 $N$ 个整数，依次表示编号为 $1$ 到 $N$ 的每个点的父亲结点的编号。根节点父亲结点编号为 $0$。", "outputFormat": "输出 $M$ 行，每行一个整数，表示与每个树同构的树的最小编号。", "hint": "编号为 $1, 2, 4$ 的树是同构的。编号为 $3$ 的树只与它自身同构。\n\n对于 $100\\%$ 的数据，保证 $1\\leq N,M\\leq 50$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Tree Isomorphism / [BJOI2015] Tree Isomorphism.", "background": "", "description": "A tree is a very common data structure.\n\nWe call a connected undirected graph with $N$ vertices and $N - 1$ edges a tree.\n\nIf we choose a vertex as the root and traverse from the root, then every other vertex has a predecessor. This tree becomes a rooted tree.\n\nFor two trees $T_1$ and $T_2$, if we can relabel all vertices of $T_1$ so that $T_1$ and $T_2$ become exactly the same, then these two trees are isomorphic. That is, they have the same shape.\n\nNow you are given $M$ unrooted trees. Please partition them into several equivalence classes according to the isomorphism relation.", "inputFormat": "The first line contains an integer $M$.\n\nThe next $M$ lines each contain several integers describing one tree. The first integer is $N$, the number of vertices. Then follow $N$ integers, which in order give the parent vertex number of each vertex numbered from $1$ to $N$. The parent number of the root vertex is $0$.", "outputFormat": "Output $M$ lines. Each line contains one integer, representing the smallest index among the trees that are isomorphic to the corresponding tree.", "hint": "Trees numbered $1$, $2$, and $4$ are isomorphic. The tree numbered $3$ is only isomorphic to itself.\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\leq N, M \\leq 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】树同构 / [BJOI2015] 树的同构", "background": null, "description": "树是一种很常见的数据结构。\n\n我们把 $N$ 个点，$N-1$ 条边的连通无向图称为树。\n\n若将某个点作为根，从根开始遍历，则其它的点都有一个前驱，这个树就成为有根树。\n\n对于两个树 $T_1$ 和 $T_2$，如果能够把树 $T_1$ 的所有点重新标号，使得树 $T_1$ 和树 $T_2$ 完全相同，那么这两个树是同构的。也就是说，它们具有相同的形态。\n\n现在，给你 $M$ 个无根树，请你把它们按同构关系分成若干个等价类。", "inputFormat": "第一行，一个整数 $M$。\n\n接下来 $M$ 行，每行包含若干个整数，表示一个树。第一个整数 $N$表示点数。接下来 $N$ 个整数，依次表示编号为 $1$ 到 $N$ 的每个点的父亲结点的编号。根节点父亲结点编号为 $0$。", "outputFormat": "输出 $M$ 行，每行一个整数，表示与每个树同构的树的最小编号。", "hint": "编号为 $1, 2, 4$ 的树是同构的。编号为 $3$ 的树只与它自身同构。\n\n对于 $100\\%$ 的数据，保证 $1\\leq N,M\\leq 50$。", "locale": "zh-CN"}}}
{"pid": "P5044", "type": "P", "difficulty": 7, "samples": [["4 2\n2 4 3 5\n0 2\n1 3\n", "10\n12\n"], ["3 3\n2 1 2\n0 0\n0 1\n0 2\n", "2\n3\n5\n"], ["5 1\n1000000000 1000000000 1 1000000000 1000000000\n0 4\n", "4000000001\n"], ["15 10\n10 71 84 33 6 47 23 25 52 64 70 31 22 31 2\n5 10\n3 7\n0 13\n8 12\n0 0\n1 3\n7 13\n1 13\n10 12\n1 1\n", "281\n180\n828\n263\n10\n201\n364\n744\n123\n71\n"]], "limits": {"time": [4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500], "memory": [824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320, 824320]}, "tags": ["2018", "IOI", "O2优化"], "title": "[IOI 2018] meetings 会议", "background": "本题为交互题，但在此请提交**完整程序**。", "description": "有 $N$ 座山横着排成一行，从左到右编号为从 $0$ 到 $N-1$。山的高度为 $H_i$（$0\\leq i\\leq N-1$）。每座山的顶上恰好住着一个人。\n\n你打算举行 $Q$ 个会议，编号为从 $0$ 到 $Q-1$。会议 $j$（$0\\leq j\\leq Q-1$） 的参加者为住在从山 $L_j$ 到山 $R_j$（包括 $L_j$ 和 $R_j$）上的人（$0\\leq L_j\\leq R_j\\leq N-1$）。对于该会议，你必须选择某个山 $x$ 做为会议举办地（$L_j\\leq x\\leq R_j$）。举办该会议的成本与你的选择有关，其计算方式如下：\n\n- 来自每座山 $y$（$L_j\\leq y\\leq R_j$） 的参会者的成本，等于在山 $x$ 和 $y$ 之间（包含 $x$ 和 $y$）的所有山的最大高度。特别地，来自山 $x$ 的参会者的成本是 $H_x$，也就是山 $x$ 的高度。\n\n- 会议的成本等于其所有参会者的成本之和。\n\n你想要用最低的成本来举办每个会议。\n\n注意，所有的参会者将在每次会议后回到他们自己的山；所以一个会议的成本不会受到先前会议的影响。", "inputFormat": "输入的第一行包含两个正整数 $N$ 和 $Q$，其意义见题目描述。\n\n第二行包含 $N$ 个正整数 $H_0,H_1,\\cdots, H_{N-1}$，表示这些山的高度。\n\n第 $3+j$ 行（$0\\leq j\\leq Q-1$），每行两个整数 $L_j, R_j$，表示这些会议的参会者的范围。", "outputFormat": "共 $Q$ 行，第 $1+j$ 行（$0\\leq j\\leq Q-1$）一个整数 $C_j$，表示举办会议 $j $ 的最低的可能成本。", "hint": "### 样例#1解释\n\n会议$j=0$有$L_j=0$和$R_j=2$，所以将由住在山$0$、$1$和$2$上的人参加。如果山$0$被选做举办地，会议$0$的成本计算如下：\n\n- 住在山$0$上的参会者的成本是$\\max\\lbrace H_0\\rbrace=2$。\n- 住在山$1$上的参会者的成本是$\\max\\lbrace H_0,H_1\\rbrace=4$。\n- 住在山$2$上的参会者的成本是$\\max\\lbrace H_0,H_1,H_2\\rbrace=4$。\n- 因此，会议$0$的成本是$2+4+4=10$。\n\n不可能以更低的成本来举办会议$0$了，因此会议$0$的最低成本是$10$。\n\n会议$j=1$有$L_j=1$和$R_j=3$，因此将由住在山$1$、$2$和$3$上的人参加。如果山$2$被选做举办地，会议$1$的成本计算如下：\n\n- 住在山$1$上的参会者的成本是$\\max\\lbrace H_1,H_2\\rbrace=4$。\n- 住在山$2$上的参会者的成本是$\\max\\lbrace H_2\\rbrace=3$。\n- 住在山$3$上的参会者的成本是$\\max\\lbrace H_1,H_2,H_3\\rbrace=5$。\n- 因此，会议$1$的成本是$4+3+5=12$。\n\n不可能以更低的成本来举办会议$1$了，所以会议$1$的最低成本是$12$。\n\n### 限制条件\n\n- $1\\leq N\\leq 750\\space000$\n- $1\\leq Q\\leq 750\\space000$\n- $1\\leq H_i\\leq1\\space000\\space000\\space000$\n- $0\\leq L_j\\leq R_j\\leq R-1(0\\leq j\\leq Q-1)$\n- $(L_j,R_j)\\neq(L_k,R_k)(0\\leq j<k\\leq Q-1)$\n\n### 子任务\n\n1. (4分) $N\\leq3000,Q\\leq10$\n2. (15分) $N\\leq5000,Q\\leq5000$\n3. (17分) $N\\leq100\\space000,Q\\leq100\\space000,H_i\\leq2(0\\leq i\\leq N-1)$\n4. (24分) $N\\leq100\\space000,Q\\leq100\\space000,H_i\\leq20(0\\leq i\\leq N-1)$\n5. (40分) 没有附加限制\n\n### Author\n\nRiku Kawasaki (Japan)\n\n### Source\n\nIOI 2018 D2T3", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2018] meetings Meeting.", "background": "This is an interactive problem, but here you should submit a **complete program**.", "description": "There are $N$ mountains arranged in a horizontal line, numbered from $0$ to $N-1$ from left to right. The height of mountain $i$ is $H_i$ ($0\\leq i\\leq N-1$). Exactly one person lives on the top of each mountain.\n\nYou plan to hold $Q$ meetings, numbered from $0$ to $Q-1$. The participants of meeting $j$ ($0\\leq j\\leq Q-1$) are the people living on mountains from $L_j$ to $R_j$ (including $L_j$ and $R_j$) ($0\\leq L_j\\leq R_j\\leq N-1$). For this meeting, you must choose some mountain $x$ as the meeting location ($L_j\\leq x\\leq R_j$). The cost of holding the meeting depends on your choice, and is computed as follows:\n\n- The cost for each participant coming from a mountain $y$ ($L_j\\leq y\\leq R_j$) equals the maximum height among all mountains between $x$ and $y$ (including $x$ and $y$). In particular, the cost for the participant from mountain $x$ is $H_x$, i.e. the height of mountain $x$.\n\n- The cost of the meeting equals the sum of the costs of all its participants.\n\nYou want to hold each meeting with the minimum possible cost.\n\nNote that all participants return to their own mountains after each meeting, so the cost of a meeting is not affected by previous meetings.", "inputFormat": "The first line contains two positive integers $N$ and $Q$, as described above.\n\nThe second line contains $N$ positive integers $H_0,H_1,\\cdots, H_{N-1}$, representing the heights of the mountains.\n\nLine $3+j$ ($0\\leq j\\leq Q-1$) contains two integers $L_j, R_j$, describing the participant range of the meeting.", "outputFormat": "Output $Q$ lines. Line $1+j$ ($0\\leq j\\leq Q-1$) contains one integer $C_j$, the minimum possible cost of holding meeting $j$.", "hint": "### Explanation of Sample #1\n\nMeeting $j=0$ has $L_j=0$ and $R_j=2$, so it will be attended by the people living on mountains $0$, $1$, and $2$. If mountain $0$ is chosen as the meeting location, the cost of meeting $0$ is computed as follows:\n\n- The cost for the participant from mountain $0$ is $\\max\\lbrace H_0\\rbrace=2$.\n- The cost for the participant from mountain $1$ is $\\max\\lbrace H_0,H_1\\rbrace=4$.\n- The cost for the participant from mountain $2$ is $\\max\\lbrace H_0,H_1,H_2\\rbrace=4$.\n- Therefore, the total cost of meeting $0$ is $2+4+4=10$.\n\nIt is not possible to hold meeting $0$ at a lower cost, so the minimum cost of meeting $0$ is $10$.\n\nMeeting $j=1$ has $L_j=1$ and $R_j=3$, so it will be attended by the people living on mountains $1$, $2$, and $3$. If mountain $2$ is chosen as the meeting location, the cost of meeting $1$ is computed as follows:\n\n- The cost for the participant from mountain $1$ is $\\max\\lbrace H_1,H_2\\rbrace=4$.\n- The cost for the participant from mountain $2$ is $\\max\\lbrace H_2\\rbrace=3$.\n- The cost for the participant from mountain $3$ is $\\max\\lbrace H_1,H_2,H_3\\rbrace=5$.\n- Therefore, the total cost of meeting $1$ is $4+3+5=12$.\n\nIt is not possible to hold meeting $1$ at a lower cost, so the minimum cost of meeting $1$ is $12$.\n\n### Constraints\n\n- $1\\leq N\\leq 750\\space000$\n- $1\\leq Q\\leq 750\\space000$\n- $1\\leq H_i\\leq1\\space000\\space000\\space000$\n- $0\\leq L_j\\leq R_j\\leq N-1(0\\leq j\\leq Q-1)$\n- $(L_j,R_j)\\neq(L_k,R_k)(0\\leq j<k\\leq Q-1)$\n\n### Subtasks\n\n1. (4 points) $N\\leq3000,Q\\leq10$.\n2. (15 points) $N\\leq5000,Q\\leq5000$.\n3. (17 points) $N\\leq100\\space000,Q\\leq100\\space000,H_i\\leq2(0\\leq i\\leq N-1)$.\n4. (24 points) $N\\leq100\\space000,Q\\leq100\\space000,H_i\\leq20(0\\leq i\\leq N-1)$.\n5. (40 points) No additional constraints.\n\n### Author\n\nRiku Kawasaki (Japan).\n\n### Source\n\nIOI 2018 D2T3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2018] meetings 会议", "background": "本题为交互题，但在此请提交**完整程序**。", "description": "有 $N$ 座山横着排成一行，从左到右编号为从 $0$ 到 $N-1$。山的高度为 $H_i$（$0\\leq i\\leq N-1$）。每座山的顶上恰好住着一个人。\n\n你打算举行 $Q$ 个会议，编号为从 $0$ 到 $Q-1$。会议 $j$（$0\\leq j\\leq Q-1$） 的参加者为住在从山 $L_j$ 到山 $R_j$（包括 $L_j$ 和 $R_j$）上的人（$0\\leq L_j\\leq R_j\\leq N-1$）。对于该会议，你必须选择某个山 $x$ 做为会议举办地（$L_j\\leq x\\leq R_j$）。举办该会议的成本与你的选择有关，其计算方式如下：\n\n- 来自每座山 $y$（$L_j\\leq y\\leq R_j$） 的参会者的成本，等于在山 $x$ 和 $y$ 之间（包含 $x$ 和 $y$）的所有山的最大高度。特别地，来自山 $x$ 的参会者的成本是 $H_x$，也就是山 $x$ 的高度。\n\n- 会议的成本等于其所有参会者的成本之和。\n\n你想要用最低的成本来举办每个会议。\n\n注意，所有的参会者将在每次会议后回到他们自己的山；所以一个会议的成本不会受到先前会议的影响。", "inputFormat": "输入的第一行包含两个正整数 $N$ 和 $Q$，其意义见题目描述。\n\n第二行包含 $N$ 个正整数 $H_0,H_1,\\cdots, H_{N-1}$，表示这些山的高度。\n\n第 $3+j$ 行（$0\\leq j\\leq Q-1$），每行两个整数 $L_j, R_j$，表示这些会议的参会者的范围。", "outputFormat": "共 $Q$ 行，第 $1+j$ 行（$0\\leq j\\leq Q-1$）一个整数 $C_j$，表示举办会议 $j $ 的最低的可能成本。", "hint": "### 样例#1解释\n\n会议$j=0$有$L_j=0$和$R_j=2$，所以将由住在山$0$、$1$和$2$上的人参加。如果山$0$被选做举办地，会议$0$的成本计算如下：\n\n- 住在山$0$上的参会者的成本是$\\max\\lbrace H_0\\rbrace=2$。\n- 住在山$1$上的参会者的成本是$\\max\\lbrace H_0,H_1\\rbrace=4$。\n- 住在山$2$上的参会者的成本是$\\max\\lbrace H_0,H_1,H_2\\rbrace=4$。\n- 因此，会议$0$的成本是$2+4+4=10$。\n\n不可能以更低的成本来举办会议$0$了，因此会议$0$的最低成本是$10$。\n\n会议$j=1$有$L_j=1$和$R_j=3$，因此将由住在山$1$、$2$和$3$上的人参加。如果山$2$被选做举办地，会议$1$的成本计算如下：\n\n- 住在山$1$上的参会者的成本是$\\max\\lbrace H_1,H_2\\rbrace=4$。\n- 住在山$2$上的参会者的成本是$\\max\\lbrace H_2\\rbrace=3$。\n- 住在山$3$上的参会者的成本是$\\max\\lbrace H_1,H_2,H_3\\rbrace=5$。\n- 因此，会议$1$的成本是$4+3+5=12$。\n\n不可能以更低的成本来举办会议$1$了，所以会议$1$的最低成本是$12$。\n\n### 限制条件\n\n- $1\\leq N\\leq 750\\space000$\n- $1\\leq Q\\leq 750\\space000$\n- $1\\leq H_i\\leq1\\space000\\space000\\space000$\n- $0\\leq L_j\\leq R_j\\leq R-1(0\\leq j\\leq Q-1)$\n- $(L_j,R_j)\\neq(L_k,R_k)(0\\leq j<k\\leq Q-1)$\n\n### 子任务\n\n1. (4分) $N\\leq3000,Q\\leq10$\n2. (15分) $N\\leq5000,Q\\leq5000$\n3. (17分) $N\\leq100\\space000,Q\\leq100\\space000,H_i\\leq2(0\\leq i\\leq N-1)$\n4. (24分) $N\\leq100\\space000,Q\\leq100\\space000,H_i\\leq20(0\\leq i\\leq N-1)$\n5. (40分) 没有附加限制\n\n### Author\n\nRiku Kawasaki (Japan)\n\n### Source\n\nIOI 2018 D2T3", "locale": "zh-CN"}}}
{"pid": "P5045", "type": "P", "difficulty": 3, "samples": [["2\n2 0 6\n5 1 6\n1\n3 4 2\n2 2", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2003", "四川", "各省省选"], "title": "[SCOI2003] 蜘蛛难题", "background": "", "description": "有一堆管道，还有一个蜘蛛$\\text{Willy}$，如下图所示。所有管道的是上端开口，下端封底，直径都是$1cm$，连接两个管道的连接容量无限，但体积可以忽略不计。\n\n![](https://cdn.luogu.com.cn/upload/pic/43701.png)\n\n在第一个管道上方有一个水源，从中有水不断往下流，速度为每秒$0.25cm^3$。由于管道横截面积为$0.25cm^3$，所以单给一个管道注水时水面每秒上升$1cm$。根据物理知识，在前$2$秒中，水注如左边的管道底部，第$[3,5]$秒时注入右边的管道，第$[6,9]$秒同时注入两个管道（虽然流量不变，但是由于同时给两个管道注水，因此水面上升的速度仅为每秒$0.5cm$），接触到蜘蛛。 给出管道和管道之间连接的位置，以及蜘蛛$\\text{Willy}$的位置，求水面接触到$\\text{Willy}$的时间。假设蜘蛛的实际位置比给出的略高一点，因此如果蜘蛛在左边管道的$n=4$的位置，答案应该是$5$秒。因为前两秒后水面虽然看起来接触到了$\\text{Willy}$，但实际上比$\\text{Willy}$略低一点。\n\n", "inputFormat": "所有位置都用有序数对$(x, y)$表示，其中y坐标从上到下逐渐增大；$x$坐标从左到右逐渐增大，因此左上角的坐标为$(0,0)$，其他所有坐标值为$0$到$100$之间的整数。输入第一行为一个整数$p(1<=p<=20)$，表示管道的数目；以下$p$行，每行用$x, y, h$三个整数描述一根管道。$(x,y)$为管道左上角坐标；$h$为管道高度$(1<=h<=20)$。以下一行为一个整数$L(0<=L<=50)$，为连接的个数。\n\n以下$L$行每行用三个整数$x, y, d$描述一个连接，$(x,y)$为左端点的坐标，$d$为连接的长度$(1<=d<=20)$。最后一行为两个整数$a,b$，表示$\\text{Willy}$在管道$a$的$y$坐标为$b$的位置。管道按照在文件中出现的顺序编号为$1,2,3…p$\n\n以下为一些假设： 水源总是在第一根管道的正上方, 连接不会穿越管道,任意两个连接的$y$坐标都不相同,任意两个管道的左上角的$x$坐标都不相同,任意连接的两个端点都在管道上（不会出现悬空的情形）", "outputFormat": "仅一个整数，为水面接触到$\\text{Willy}$的时间。如果水面无法接触到$\\text{Willy}$，输出$-1$。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2003] Spider Problem", "background": "", "description": "There is a set of pipes and a spider $\\text{Willy}$, as shown in the figure below. All pipes are open at the top and sealed at the bottom. Each pipe has a diameter of $1cm$. The connections between two pipes have infinite capacity, but their volume can be ignored.\n\n![](https://cdn.luogu.com.cn/upload/pic/43701.png)\n\nAbove the first pipe there is a water source, from which water keeps flowing downward at a rate of $0.25cm^3$ per second. Since the cross-sectional area of a pipe is $0.25cm^2$, when filling only one pipe, the water level rises by $1cm$ per second. According to physics, during the first $2$ seconds, the water flows into the bottom of the left pipe; during seconds $[3,5]$, it flows into the right pipe; during seconds $[6,9]$, it flows into both pipes at the same time (although the total flow rate is unchanged, because two pipes are filled simultaneously, the rising speed in each pipe is only $0.5cm$ per second), and then it reaches the spider.\n\nGiven the positions of the connections between pipes and the position of the spider $\\text{Willy}$, find the time when the water level touches $\\text{Willy}$. Assume the spider’s actual position is slightly higher than the given one. Therefore, if the spider is at position $n=4$ in the left pipe, the answer should be $5$ seconds. This is because after the first two seconds the water level seems to touch $\\text{Willy}$, but it is actually slightly below $\\text{Willy}$.", "inputFormat": "All positions are represented by ordered pairs $(x, y)$, where the $y$ coordinate increases from top to bottom, and the $x$ coordinate increases from left to right. Therefore, the top-left corner is $(0,0)$. All other coordinate values are integers between $0$ and $100$.\n\nThe first line contains an integer $p(1<=p<=20)$, the number of pipes. The next $p$ lines each contain three integers $x, y, h$ describing one pipe. $(x,y)$ is the coordinate of the top-left corner of the pipe, and $h$ is the height of the pipe $(1<=h<=20)$.\n\nThe next line contains an integer $L(0<=L<=50)$, the number of connections.\n\nThe next $L$ lines each contain three integers $x, y, d$ describing a connection. $(x,y)$ is the coordinate of the left endpoint, and $d$ is the length of the connection $(1<=d<=20)$.\n\nThe last line contains two integers $a,b$, meaning that $\\text{Willy}$ is in pipe $a$ at the position whose $y$ coordinate is $b$. Pipes are numbered $1,2,3…p$ in the order they appear in the input file.\n\nThe following assumptions hold: the water source is always directly above the first pipe; connections do not cross pipes; the $y$ coordinates of any two connections are different; the $x$ coordinates of the top-left corners of any two pipes are different; and both endpoints of every connection lie on pipes (there will be no “hanging” endpoints).", "outputFormat": "Output only one integer: the time when the water level touches $\\text{Willy}$. If the water level can never touch $\\text{Willy}$, output $-1$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2003] 蜘蛛难题", "background": "", "description": "有一堆管道，还有一个蜘蛛$\\text{Willy}$，如下图所示。所有管道的是上端开口，下端封底，直径都是$1cm$，连接两个管道的连接容量无限，但体积可以忽略不计。\n\n![](https://cdn.luogu.com.cn/upload/pic/43701.png)\n\n在第一个管道上方有一个水源，从中有水不断往下流，速度为每秒$0.25cm^3$。由于管道横截面积为$0.25cm^3$，所以单给一个管道注水时水面每秒上升$1cm$。根据物理知识，在前$2$秒中，水注如左边的管道底部，第$[3,5]$秒时注入右边的管道，第$[6,9]$秒同时注入两个管道（虽然流量不变，但是由于同时给两个管道注水，因此水面上升的速度仅为每秒$0.5cm$），接触到蜘蛛。 给出管道和管道之间连接的位置，以及蜘蛛$\\text{Willy}$的位置，求水面接触到$\\text{Willy}$的时间。假设蜘蛛的实际位置比给出的略高一点，因此如果蜘蛛在左边管道的$n=4$的位置，答案应该是$5$秒。因为前两秒后水面虽然看起来接触到了$\\text{Willy}$，但实际上比$\\text{Willy}$略低一点。\n\n", "inputFormat": "所有位置都用有序数对$(x, y)$表示，其中y坐标从上到下逐渐增大；$x$坐标从左到右逐渐增大，因此左上角的坐标为$(0,0)$，其他所有坐标值为$0$到$100$之间的整数。输入第一行为一个整数$p(1<=p<=20)$，表示管道的数目；以下$p$行，每行用$x, y, h$三个整数描述一根管道。$(x,y)$为管道左上角坐标；$h$为管道高度$(1<=h<=20)$。以下一行为一个整数$L(0<=L<=50)$，为连接的个数。\n\n以下$L$行每行用三个整数$x, y, d$描述一个连接，$(x,y)$为左端点的坐标，$d$为连接的长度$(1<=d<=20)$。最后一行为两个整数$a,b$，表示$\\text{Willy}$在管道$a$的$y$坐标为$b$的位置。管道按照在文件中出现的顺序编号为$1,2,3…p$\n\n以下为一些假设： 水源总是在第一根管道的正上方, 连接不会穿越管道,任意两个连接的$y$坐标都不相同,任意两个管道的左上角的$x$坐标都不相同,任意连接的两个端点都在管道上（不会出现悬空的情形）", "outputFormat": "仅一个整数，为水面接触到$\\text{Willy}$的时间。如果水面无法接触到$\\text{Willy}$，输出$-1$。", "hint": "", "locale": "zh-CN"}}}
